[MUSIC PLAYING] DAVID J. Malan: Baiklah, ini CS50. Dan ini adalah satu minggu. Jadi ingat bahwa terakhir kali dalam seminggu nol, kami fokus pada pemikiran komputasi. Dan kita beralih dari itu untuk Scratch, pemrograman grafis bahasa dari teman-teman kita di MIT Media Lab. 

Dan dengan Scratch, apakah kita mengeksplorasi ide seperti fungsi, dan kondisi, dan loop, dan variabel, dan bahkan peristiwa, dan benang, dan banyak lagi. Dan hari ini, kita akan terus menggunakan ide-ide mereka, dan benar-benar mengambil mereka untuk diberikan, tapi menerjemahkannya ke bahasa lain dikenal sebagai C. Sekarang, C adalah bahasa yang lebih tradisional. Ini adalah tingkat yang lebih rendah bahasa, jika Anda mau. 

Ini murni tekstual. Dan pada pandangan pertama, itu semua akan terlihat agak samar jika Anda belum pernah diprogram sebelumnya. Kita akan memiliki semi-titik dua, dan tanda kurung, dan kurung kurawal, dan banyak lagi. Tapi menyadari bahwa bahkan meskipun sintaks akan terlihat sedikit asing untuk sebagian besar dari Anda, melihat masa lalu itu. Dan mencoba untuk melihat ide-ide yang, memang, akrab, karena di sini di minggu satu apa kami akan mulai lakukan adalah untuk membandingkan, awalnya, Scratch dibandingkan C. 

Jadi, misalnya, ingat bahwa ketika kita diimplementasikan pertama program kami terakhir kali, kami memiliki blok yang tampak sedikit sesuatu seperti ini-- ketika bendera hijau diklik, dan kemudian kita harus satu potongan puzzle atau lebih di bawahnya, dalam kasus ini, mengatakan, halo dunia. Jadi, memang, di Scratch, ketika saya klik bendera hijau untuk menjalankan program saya, jadi untuk berbicara, ini adalah blok yang dijalankan, atau dikelola. Dan, khususnya, Scratch kata, halo, dunia. 

Sekarang, aku bisa ditentukan kata yang berbeda di sini. Tapi kita akan melihat bahwa, memang, banyak dari blocks-- ini dan memang, di C banyak functions-- dapat parametrized atau disesuaikan untuk melakukan hal yang berbeda. Bahkan, di C jika kita dikonversi, sekarang, Program Scratch ini untuk bahasa lain ini, kita akan menulis sedikit sesuatu seperti ini. 

Memang, ada beberapa asing sintaks ada kemungkinan besar, int, dan tanda kurung, dan kosong. Tapi printf-- meskipun Anda akan pikir itu hanya akan menjadi cetak. Tapi cetak berarti cetak diformat, karena kami akan segera melihat. Ini benar-benar akan mencetak ke layar apapun adalah dalam mereka kurung, yang tentu saja dalam hal ini adalah, halo dunia. 

Tapi Anda akan melihat beberapa lainnya sintaks, beberapa tanda kutip ganda, bahwa kurung di akhir, semi-usus dan sejenisnya. Jadi ada sedikit overhead, sehingga untuk berbicara, baik secara kognitif dan sintaksis, bahwa kita akan harus diingat sebelum lama. Tapi menyadari bahwa dengan latihan, ini akan mulai melompat keluar pada Anda. 

Bahkan, mari kita fokus pada satu Fungsi specifically-- dalam kasus ini, menyapa dunia. Jadi katakan adalah fungsi. Halo dunia adalah parameter yang, atau argumen, kustomisasi. 

Dan kesetaraan di C hanya akan menjadi satu baris ini di sini, di mana printf setara dengan, mengatakan, ganda string yang dikutip, halo dunia setara, tentu saja, apa yang ada di kotak putih di sana. Dan backslash n, meskipun sedikit aneh dan absen dari Scratch, hanya akan memiliki efek kita akan lihat di komputer, seperti Mac saya atau PC, hanya memindahkan kursor ke baris berikutnya. Ini seperti memukul Enter pada keyboard Anda. 

Jadi kita akan melihat itu lagi sebelum lama. Tapi pertama-tama, mari kita lihat ini contoh lain dalam kasus loop. Kami memiliki ini selamanya lingkaran terakhir kali, yang merupakan serangkaian potongan puzzle yang melakukan sesuatu yang benar forever-- dalam kasus ini, mengatakan, halo dunia, halo dunia, halo dunia, halo dunia. Jadi itu loop tak terbatas dengan desain. 

Dalam C, jika kita ingin menerapkan ini ide yang sama, kita mungkin hanya melakukan ini. Sementara benar, printf halo dunia-- sekarang sementara, hanya semantik, jenis memunculkan ide untuk melakukan sesuatu lagi, dan lagi, dan lagi, dan untuk berapa lama? Nah, ingat true-- yang benar adalah hanya pada atau satu. 

Dan benar, tentu saja, selalu benar. Jadi itu semacam berarti sebuah Pernyataan hanya untuk mengatakan yang benar. Tapi memang, ini disengaja, karena jika benar hanya selalu benar, dari sementara benar hanya menyiratkan, jika sedikit tidak langsung, bahwa baris kode berikut di antara mereka kurung kurawal harus hanya menjalankan lagi, dan lagi, dan lagi, dan tidak pernah benar-benar berhenti. 

Tapi jika Anda ingin Anda loop untuk berhenti, seperti yang kita lakukan terakhir kali dengan sesuatu seperti ini, ulangi berikut 50 kali, di C kita bisa melakukan hal yang sama dengan apa yang disebut untuk loop-- kata kunci tidak menjadi sementara, tapi untuk. Dan kemudian kami memiliki beberapa sintaks baru di sini, dengan int i sama dengan 0, i kurang dari 50, i ++. Dan kami akan kembali ke itu. Tapi ini hanya bagaimana kita akan menerjemahkan set blok Scratch untuk satu set C baris kode. 

Sementara itu, mempertimbangkan variabel. Dan, pada kenyataannya, kita hanya melihat satu saat yang lalu. Dan dalam kasus Scratch, jika kita ingin mendeklarasikan variabel yang disebut i untuk i menjadi integer, hanya nomor, dan kami ingin mengatur itu untuk beberapa nilai, kita akan menggunakan jeruk ini memblokir sini-set i ke 0. 

Dan kita akan melihat hari ini dan luar, seperti minggu lalu, programmer melakukan hampir selalu mulai menghitung dari nol, benar-benar dengan perjanjian. Tetapi juga karena ingat dari diskusi kami biner, jumlah terkecil Anda bisa mewakili dengan jumlah bit hanya akan menjadi 0 itu sendiri. Dan jadi kita akan umumnya mulai menginisialisasi bahkan variabel untuk 0. 

Dan di C untuk melakukan hal yang sama, kita akan mengatakan int untuk integer, saya hanya oleh konvensi. Saya bisa disebut variabel ini apapun yang saya inginkan, seperti di Scratch. Dan kemudian sama dengan 0 hanya ditunjuk nilai 0 dari kanan dan menempatkan ke variabel, atau wadah penyimpanan di sana, di sebelah kiri. Dan semi-kolon karena kami akan see-- dan kami telah melihat beberapa already-- ini hanya berarti akhir pemikiran. Lanjutkan untuk melakukan sesuatu yang lain pada garis yang mengikuti. 

Sekarang, bagaimana dengan ekspresi Boolean? Ingat bahwa di Scratch, ini adalah ekspresi yang baik benar atau pertanyaan false--, benar-benar, yang benar atau salah. Jadi dalam kasus Scratch, kita mungkin mengajukan pertanyaan sederhana seperti ini, adalah saya kurang dari 50? Jadi saya, sekali lagi, adalah bilangan bulat. Mungkin kita menggunakannya dalam program Scratch untuk melacak skor atau semacam itu. Jadi sintaks ini di sini di Scratch hanya berarti, adalah i kurang dari 50? Nah, untungnya, ada sesuatu yang sederhana dalam C. Dan untuk menerjemahkan, ini kita hanya akan mengatakan saya kurang dari 50, dengan menggunakan kunci familiar pada keyboard Anda. 

Sementara itu, jika Anda ingin mengatakan sesuatu yang lebih umum, seperti, baik, adalah x kurang dari y di mana setiap dari x dan y itu sendiri variabel? Kita bisa melakukan hal yang sama di C, selama kita sudah menciptakan variabel-variabel ini sudah. Dan kita akan melihat bagaimana melakukan itu tak lama. Kami hanya akan mengatakan x kurang dari y. 

Jadi Anda mulai melihat beberapa kesamaan. Dan orang-orang itu yang membuat Scratch yang pasti terinspirasi oleh beberapa ide dasar. Dan Anda akan melihat semacam ini sintaks di banyak languages-- bukan hanya Scratch, tidak hanya C, tapi Python, dan JavaScript, dan bahasa lain masih. 

Mari kita pertimbangkan membangun lain dari C, gagasan kondisi, melakukan sesuatu kondisional. Jika sesuatu itu benar, melakukan hal ini. Jika sesuatu yang lain benar, melakukan itu. Ini semacam pemrograman setara dengan persimpangan jalan. Mungkin dua arah garpu, tiga-cara garpu, atau lebih. Dan di Scratch, kita mungkin memiliki melihat sesuatu seperti ini. 

Jadi yang satu ini adalah salah satu yang besar. Tapi mempertimbangkan relatif kesederhanaan logika. Jika x kurang dari y, maka katakan x kurang dari y, lain jika x lebih besar dari y, kemudian berkata x lebih besar dari y. Dan kemudian, secara logis, jika Anda berpikir kembali ke Scratch atau hanya intuisi manusia sendiri, baik, jika x tidak lebih besar dari y, dan x tidak kurang dari y, maka tentu saja x akan menjadi sama dengan y. Jadi dalam hal ini, oleh bersarang blok-blok Scratch, kita dapat mencapai tiga Cara pertigaan jalan? 

Sementara itu, jika kita ingin melakukan itu di C, itu bisa dibilang terlihat simpler-- sedikit setidaknya setelah Anda mendapatkan akrab dengan sintaks. Jika x kurang dari y, printf x kurang dari y. Lain jika x lebih besar dari y, printf x lebih besar dari y. Lain printf x sama dengan y-- dan, lagi, dengan backslash mereka berakhir hanya untuk garis baru sehingga jika Anda benar-benar berlari program semacam ini itu hanya akan memindahkan kursor Anda pada akhirnya ke baris berikutnya dari layar. 

Sekarang, sementara Scratch memiliki lainnya fitur yang lebih canggih, hanya beberapa di antaranya kita akan awalnya pindah ke dunia C. Dan salah satunya adalah disebut daftar di Scratch. Dan ini adalah khusus jenis variabel yang diizinkan Anda untuk menyimpan beberapa hal di kembali, ke belakang, ke belakang, ke belakang. 

Dalam C, tidak memiliki daftar, per se, tetapi sesuatu yang lebih umum disebut array, meskipun kami akan kembali lagi nanti semester ini untuk melihat sesuatu disebut daftar, atau benar-benar sebuah linked list. Tapi untuk saat ini, yang paling dekat setara dalam C untuk kita akan menjadi sesuatu yang disebut array. Dan sebuah array hanyalah sebuah jenis khusus dari variabel yang memungkinkan Anda untuk menyimpan data kembali, ke belakang, ke belakang, ke belakang. 

Dan, memang, di Scratch, jika kita ingin mengakses elemen pertama dari array atau a list-- dan aku akan menyebutnya, dengan konvensi, argv, argumen vektor, tetapi lebih pada sebelum lama. Jika saya ingin mendapatkan pada elemen pertama argv, dalam dunia Scratch Anda benar-benar melakukan biasanya mulai menghitung dari 1. 

Dan jadi saya mungkin mendapatkan item 1 dari argv. Itu hanya bagaimana MIT dilaksanakan gagasan daftar. Tapi di C, aku akan lebih sederhana hanya mengatakan, argv, yang lagi adalah nama saya list-- atau harus jelas, array. Dan jika saya ingin yang pertama elemen, aku akan menggunakan tanda kurung persegi, yang Anda mungkin tidak sering digunakan di bawah keyboard. 

Tapi 0 hanya berarti, mendapatkan saya yang pertama. Jadi pada kesempatan dan sebagai waktu berlalu, kita akan untuk mulai melihat dikotomi ini antara Scratch dan C, dimana Scratch menggunakan satu. Kami di C menggunakan 0 sini. Tapi Anda akan segera melihat setelah Anda memahami dasar setiap bahasa, yang hal-hal ini mulai mendapatkan semua lebih akrab melalui praktek dan praktek. 

Jadi mari kita benar-benar melihat sekarang di sebuah program. Berikut akan menjadi yang pertama dari C kami kode sumber untuk program lengkap. Dan program kita akan menawarkan untuk pertimbangan adalah salah satu yang setara untuk potongan Scratch sebelumnya. 

Jadi di sini, kita memiliki apa yang bisa dibilang program C sederhana Anda dapat menulis bahwa sebenarnya sesuatu. Sekarang, kita akan melihat masa lalu, untuk saat ini, telah mencakup, io.h standar, dan sudut ini kurung, dan int, dan tidak berlaku, dan kurung kurawal, dan sejenisnya. 

Dan mari kita fokus pada apa, setidaknya secara intuitif, mungkin melompat keluar pada Anda sudah. Bahkan, utama, saya tidak tentu tahu apa ini, tapi banyak seperti Scratch memiliki bahwa ketika bendera hijau diklik potongan puzzle, begitu juga C sebagai bahasa pemrograman memiliki sepotong utama kode yang dijalankan secara default. Dan, memang, itu benar akan disebut utama. 

Jadi utama adalah fungsi. Dan itu fungsi khusus yang ada di C bahwa ketika Anda menjalankan program, itu adalah utama yang akan dijalankan oleh default. Dalam dunia Scratch, itu biasanya ketika bendera hijau diklik yang mendapat dijalankan secara default. 

Sementara itu, kami telah melihat ini sebelumnya, printf atau cetak diformat, itu akan menjadi fungsi yang datang dengan C, bersama dengan sejumlah orang lain, yang akan dari waktu dan waktu lagi, untuk melakukan hal seperti namanya, mencetak sesuatu. Apa yang kita ingin mencetak? Nah, kita akan melihat bahwa oleh karakter melampirkan seperti these-- dunia halo, backslash n dalam tanda kutip ganda, kita bisa mengatakan printf persis apa untuk mencetak di layar. 

Tetapi untuk melakukan itu, kami sayangnya perlu mengambil sesuatu yang sudah samar untuk kita manusia, tapi setidaknya itu agak readable-- tajam termasuk, standar io.h, int, utama, kekosongan, printf, semua magis mantra kita hanya melihat pada layar. Tapi kami benar-benar harus pergi lebih misterius masih. Pertama kita perlu untuk menerjemahkan kode yang kita tulis ke dalam kode mesin. Dan ingat dari minggu lalu bahwa mesin, setidaknya orang-orang yang kita kenal di sini, pada akhir hari hanya memahami nol dan satu. 

Dan Allahku, jika kita harus menulis ini nol dan satu untuk benar-benar program itu akan sangat, sangat cepat mengambil kesenangan dari apa pun. Tapi ternyata, per pekan lalu, bahwa pola-pola nol dan satu hanya memiliki arti khusus. Dalam konteks tertentu, mereka mungkin berarti angka. 

Dalam beberapa konteks, mereka mungkin berarti huruf, atau warna, atau sejumlah abstraksi lain ada pada. Tapi sama seperti komputer Anda memiliki CPU, Central Processing Unit, atau otak dalam komputer Anda. Ini biasanya Intel dalam, karena itulah salah satu perusahaan terbesar yang membuat CPU untuk komputer. 

Nah, CPU Intel dan lain-lain hanya telah memutuskan di muka bahwa pola-pola tertentu nol dan yang berarti hal-hal tertentu. pola-pola tertentu dari nol dan satu akan berarti, mencetak ini ke layar, atau menambahkan dua nomor tersebut, atau kurangi dua nomor tersebut, atau memindahkan sepotong data dari memori komputer saya di sini, atau jumlah tingkat yang sangat rendah lainnya, tapi akhirnya berguna, operasi. Tapi, untungnya, kita manusia tidak akan perlu mengetahui tingkat detail. Memang, sama seperti terakhir kali, di mana kita disarikan lagi, dan lagi, dan lagi, bangunan dari tingkat yang sangat rendah primitif seperti nol dan satu konsep tingkat yang lebih tinggi seperti angka, dan huruf, dan warna, dan banyak lagi, sehingga kita sebagai programmer berdiri di atas pundak orang lain yang datang sebelum kita dan menggunakan perangkat lunak yang lainnya orang telah ditulis sebelum us-- yaitu program yang disebut compiler. 

C adalah bahasa yang biasanya disusun, yang berarti dikonversi dari kode sumber untuk kode mesin. Secara khusus, apa artinya ini adalah bahwa jika Anda punya sumber Anda kode yang Anda sendiri menulis, seperti yang kita segera akan hanya sesaat pada layar, dan Anda ingin mengubahnya akhirnya ke mesin code-- mereka nol dan satu yang hanya Mac atau PC Anda understands-- Anda punya pertama pakan yang kode sumber sebagai input ke khusus Program yang disebut kompilator, output yang kita akan lihat adalah kode mesin. Dan, memang, terakhir kali kami berbicara tentang, benar-benar, pada akhir hari, pemecahan masalah. Anda punya masukan. Dan Anda punya output. Dan Anda punya beberapa jenis algoritma di tengah. 

Algoritma pasti bisa diimplementasikan dalam perangkat lunak, seperti yang kita lihat dengan pseudocode minggu lalu dan seperti yang kita lihat dengan kode aktual minggu ini. Dan kompilator benar-benar hanya memiliki satu set algoritma dalam itu yang tahu bagaimana mengkonversi kata kunci khusus, seperti utama, dan printf, dan lain-lain yang baru saja kita melihat ke dalam pola nol dan orang yang Intel dalam dan lainnya CPU benar-benar mengerti. Jadi bagaimana kita melakukan ini? Mana kita mendapatkan kompilator? 

Sebagian besar dari kita di sini memiliki Mac atau PC. Dan Anda menjalankan Mac OS, atau Windows, atau Linux, atau Solaris, atau jumlah lain sistem operasi. Dan, memang, kita bisa pergi ke web dan download kompilator untuk Mac atau PC Anda untuk sistem operasi tertentu. Tapi kita semua akan berada di halaman yang berbeda, sehingga untuk berbicara. Kita akan memiliki sedikit konfigurasi yang berbeda. Dan hal tidak akan bekerja semua sama. Dan, memang, hari ini banyak dari kita tidak menggunakan software yang berjalan hanya pada laptop kita. Sebaliknya, kita menggunakan sesuatu seperti browser yang memungkinkan kita untuk mengakses web berbasis aplikasi di awan. Dan kemudian semester ini, kita akan melakukan hal itu. Kami akan menulis aplikasi atau software menggunakan code-- tidak C, tetapi bahasa lain seperti Python dan JavaScript-- yang berjalan di awan. 

Dan untuk melakukan itu, kita sendiri selama semester benar-benar akan menggunakan cloud berbasis lingkungan yang dikenal sebagai CS50 IDE. Ini adalah pemrograman berbasis web lingkungan, atau pengembangan terintegrasi lingkungan, IDE, yang dibangun di atas beberapa perangkat lunak sumber terbuka yang disebut Cloud 9. Dan kami telah membuat beberapa pedagogis penyederhanaan untuk itu sehingga untuk menyembunyikan fitur tertentu di minggu-minggu pertama yang kita tidak perlu, setelah itu Anda bisa mengungkapkan mereka dan melakukan sebagian apa pun yang Anda inginkan dengan lingkungan. 

Dan memungkinkan kita, juga, untuk pra-instal software tertentu. Hal-hal seperti yang disebut CS50 perpustakaan, yang kita akan segera melihat memberikan kita dalam C dengan beberapa fungsionalitas tambahan. Jadi, jika Anda pergi ke, akhirnya, CS50.io, Anda akan diminta untuk log in, dan sekali Anda lakukan dan membuat akun gratis, Anda akan dapat mengakses lingkungan yang terlihat cukup seperti ini. 

Sekarang, ini adalah dalam mode default. Semuanya bagus dan cerah di layar. Banyak dari kita memiliki kebiasaan bekerja pada CS50 sepotong itu cukup larut malam. Dan beberapa dari Anda mungkin lebih memilih untuk mengubahnya menjadi modus malam, sehingga untuk berbicara. 

Tapi, pada akhirnya, apa yang Anda akan melihat dalam CS50 IDE adalah tiga areas-- berbeda daerah di mana kiri file Anda akan berada di awan, area di kanan atas di mana kode Anda akan menjadi diedit. Anda akan dapat membuka tab individu untuk setiap program yang Anda tulis semester ini di dalam itu sudut kanan atas. Dan kemudian yang paling arcanely, dan belum kuat, akan menjadi hal ini di bawah dikenal sebagai jendela terminal. 

Ini adalah sekolah tua Command Line Interface, atau CLI, yang memungkinkan Anda untuk menjalankan perintah pada computer-- dalam kasus ini, komputer di cloud-- untuk melakukan hal-hal seperti kompilasi kode Anda dari kode sumber untuk kode mesin, untuk menjalankan program Anda, atau untuk memulai Anda web server, atau untuk mengakses database Anda, dan sejumlah teknik lainnya bahwa kita akan mulai menggunakan sebelum lama. Tapi untuk sampai ke sana, kami akan benar-benar memiliki untuk online dan mulai bermain. Dan untuk melakukan itu, mari kita pertama mulai mengutak-atik utama, dan menulis bagian utama dari program. Dan mari kita gunakan fungsi yang printf, yang kita gunakan sebelumnya, hanya untuk mengatakan sesuatu. 

Jadi di sini saya sudah dalam CS50 IDE. Aku sudah login terlebih dahulu. Dan saya penuh disaring jendela. Dan, pada akhirnya, Anda juga dalam masalah kedatangan akan mengikuti langkah serupa yang akan memberikan dokumentasi online. Jadi Anda tidak perlu khawatir tentang menyerap setiap langkah teknis kecil yang saya lakukan di sini hari ini. 

Tapi Anda akan mendapatkan layar seperti ini. Saya kebetulan berada di modus malam. Dan Anda dapat mencerahkan segalanya up dengan menonaktifkan modus malam. Dan pada akhir hari, Anda akan melihat tiga utama ini areas-- file Browser di kiri, kode tab di bagian atas, dan jendela terminal di bagian bawah. 

Biarkan aku pergi ke depan dan menulis program pertama saya. Aku akan Terlebih Dahulu buka File, Simpan, dan menyimpan file saya sebagai hello.c. Memang, dengan konvensi, program kami menulis yang ditulis dalam bahasa C harus dinamai sesuatu dot c, dengan konvensi. Jadi aku akan nama itu hello.c, karena Aku hanya ingin menyapa dunia. Sekarang aku akan tampilannya dan klik Simpan. Dan semua yang saya miliki di sini sekarang adalah tab di mana saya bisa mulai menulis kode. 

Ini tidak akan dikompilasi. Ini berarti apa-apa. Dan bahkan jika aku dikonversi ini untuk nol dan satu, CPU akan memiliki tahu apa yang terjadi di sekitar. Tapi jika saya menulis baris yang cocok dengan C C makhluk conventions--, lagi, ini language-- dengan sintaks seperti ini, printf halo dunia-- dan saya sudah mendapatkan nyaman dengan melakukan ini dari waktu ke waktu. Jadi saya tidak berpikir saya membuat setiap kesalahan ketik. 

Tapi, selalu, pertama kali Anda melakukan ini, Anda akan. Dan apa yang akan saya lakukan mungkin sangat baik tidak bekerja untuk Anda pertama kalinya. Dan itu sangat OK, karena sekarang Anda mungkin hanya melihat seluruh banyak kebaruan, tapi seiring waktu setelah Anda mendapatkan akrab dengan lingkungan ini, dan bahasa ini, dan lain-lain, Anda akan mulai melihat hal-hal yang yang baik benar atau salah. 

Dan ini adalah apa yang fellows mengajar dan tentu saja asisten mendapatkan begitu baik pada waktu ke waktu, yang bercak kesalahan atau bug dalam kode Anda. Tapi saya mengklaim bahwa ada ada bug dalam kode ini. Jadi sekarang saya ingin menjalankan program ini. 

Sekarang pada Mac atau PC saya sendiri, saya di kebiasaan ikon mengklik ganda ketika saya ingin menjalankan beberapa program yang. Tapi itu bukan model di sini. Dalam lingkungan ini, yang CS50 IDE. Kami menggunakan operasi sistem yang disebut Linux. Linux mengingatkan lain sistem operasi, umumnya dikenal sebagai Unix. Dan Linux terutama dikenal untuk memiliki Command Line Lingkungan, CLI. Sekarang, kita sedang menggunakan spesifik rasa Linux disebut Ubuntu. Dan Ubuntu hanyalah sebuah Versi tertentu Linux. 

Tapi ini Linux hari ini lakukan sebenarnya datang dengan antarmuka pengguna grafis. Dan yang kita kebetulan menggunakan di sini adalah web berbasis. Jadi ini mungkin terlihat bahkan sedikit berbeda dari sesuatu Anda sendiri mungkin memiliki melihat atau berjalan di masa lalu. 

Jadi aku akan pergi ke depan sekarang dan melakukan hal berikut. Saya telah menyimpan file ini sebagai hello.c. Aku akan pergi ke depan dan Jenis clanghello.c Jadi dentang untuk bahasa C adalah kompilator. Ini pra-instal di CS50 IDE. Dan Anda benar-benar dapat men-download dan menginstal ini pada Mac Anda sendiri atau PC. 

Tapi, sekali lagi, Anda tidak akan memiliki semua pra-konfigurasi dilakukan untuk Anda. Jadi untuk saat ini, aku hanya akan menjalankan clanghello.c. Dan sekarang perhatikan sintaks ini sini akhirnya akan menyadari hanya berarti bahwa aku dalam folder atau direktori yang disebut Workspace. tanda dolar ini hanya konvensi makna, ketik perintah Anda di sini. 

Ini apa yang disebut prompt, hanya dengan konvensi adalah tanda dolar. Dan jika aku pergi ke depan sekarang dan klik Masukkan, sepertinya tidak ada yang terjadi. Tapi itu sebenarnya hal yang baik. Kurang yang terjadi di layar Anda, semakin besar kemungkinan kode Anda adalah untuk menjadi benar, setidaknya sintaksis. 

Jadi jika saya ingin menjalankan ini Program, apa yang harus saya lakukan? Nah, ternyata bahwa Nama default oleh konvensi untuk program ketika Anda tidak menentukan nama untuk program Anda hanya a.out. Dan sintaks ini juga, Anda akan mendapatkan akrab dengan sebelum lama. 

Dot slash hanya berarti, hey, CS50 IDE, menjalankan program yang disebut a.out yang ada di dalam direktori saya saat ini. dot itu berarti direktori saat ini. Dan kita akan melihat apa urutan seperti lainnya karakter berarti sebelum lama. 

Jadi di sini kita pergi, Masukkan, halo dunia. Dan Anda akan melihat, bahwa apa yang terjadi? Tidak hanya itu mencetak hello world. Hal ini juga memindahkan kursor ke baris berikutnya. 

Dan mengapa itu? Apa kode yang kita tulis sebelumnya yang menjamin bahwa kursor akan pergi pada baris berikutnya? hal yang lucu tentang komputer itu hanya akan untuk melakukan harfiah apa yang Anda katakan untuk dilakukan. 

Jadi jika Anda kirim ke printf halo, koma, ruang, dunia, kutipan dekat, itu benar-benar hanya akan untuk mencetak karakter mereka. Tapi aku punya karakter khusus ini pada akhir, ingat, backslash n. Dan itulah yang memastikan bahwa karakter pergi ke baris berikutnya dari layar. 

Bahkan, biarkan aku pergi dan melakukan hal ini. Biarkan aku pergi ke depan dan menghapus ini. Sekarang, perhatikan bahwa atas layar saya ada lampu merah kecil di tab menunjukkan, hey, Anda tidak menyimpan file Anda. Jadi aku akan pergi ke depan dengan kontrol S atau perintah S, menyimpan file. Sekarang goes-- pergi untuk hijau moment--. Dan sekarang kembali ke hanya menjadi ikon dekat. 

Jika saya sekarang menjalankan clanghello.c lagi, Masukkan, dot slash, a.out, Enter, Anda akan melihat bahwa itu masih bekerja. Tapi itu bisa dibilang sedikit kereta. Sekarang, ruang kerja prompt-- saya, dan kemudian bahwa dolar tanda, dan kemudian prompt-- yang sebenarnya adalah semua pada baris yang sama. Jadi tentu bug estetika ini, bahkan jika itu tidak benar-benar bug logis. 

Jadi aku akan membatalkan apa yang baru saja saya lakukan. Aku akan menjalankan kembali a.out. Perhatikan Saya telah menambahkan baris karakter kembali. Aku sudah menyimpan file. 

Jadi aku akan mengulangi a.out, dan-- sialan, bug, bug yang berarti kesalahan. Jadi bug adalah bahwa meskipun Saya menambahkan backslash n ada, re-disimpan, re-berlari program, perilaku adalah sama. Mengapa hal itu terjadi? 

Aku hilang langkah, kan? Bahwa langkah kunci sebelumnya adalah bahwa Anda memiliki to-- ketika Anda mengubah kode sumber Anda, ternyata juga menjalankan melalui compiler lagi sehingga Anda mendapatkan kode mesin baru. Dan kode mesin, nol dan yang, akan menjadi hampir sama, tapi tidak sempurna begitu, karena yang kita butuhkan, Tentu saja, yang baris baru. 

Jadi untuk memperbaiki ini, saya akan membutuhkan untuk mengulangi clanghello.c, masukkan, dot slash, a.out. Dan sekarang, halo dunia kembali ke tempat saya berharap untuk menjadi. Jadi ini semua baik dan bagus. Tapi a.out adalah nama cukup bodoh untuk Program, meskipun itu terjadi menjadi, untuk alasan historis, default-- berarti output perakitan. 

Tapi biarkan aku pergi ke depan di sini dan melakukan hal ini berbeda. Saya ingin saya Program Halo dunia untuk benar-benar disebut halo. Jadi jika itu sebuah ikon pada saya Desktop, itu tidak akan a.out. Itu akan disebut halo. 

Jadi untuk melakukan ini, ternyata yang dentang, seperti banyak program, mendukung argumen baris perintah, atau bendera, atau switch, yang hanya mempengaruhi perilakunya. Secara khusus, dentang mendukung dash o flag, yang kemudian mengambil kata kedua. Dalam hal ini, saya akan sewenang-wenang, tapi cukup, menyebutnya halo. Tapi aku bisa menyebutnya apa-apa Saya ingin, kecuali a.out, yang akan lebih selain titik. 

Dan kemudian hanya menentukan nama file saya ingin mengkompilasi. Jadi sekarang meskipun di awal dari perintah saya masih memiliki dentang, pada akhir perintah Saya masih memiliki nama file, Saya sekarang memiliki baris perintah ini argumen, bendera ini yang mengatakan, oh, by the way, keluaran-o, file disebut halo, bukan a.out default. 

Jadi jika saya tekan Enter sekarang, tidak ada tampaknya telah terjadi. Dan, namun, sekarang saya bisa melakukan dot slash halo. Sehingga program yang sama. The nol dan satu yang identik pada akhir hari. 

Tapi mereka dalam dua a.out files-- berbeda, yang merupakan versi pertama dan hanya bodoh bernama, dan sekarang halo, yang jauh Nama yang lebih menarik untuk sebuah program. Tapi, jujur, saya tidak pernah akan mengingat ini lagi, dan lagi, dan lagi. Dan, sebenarnya, seperti yang kita tulis program yang lebih rumit, perintah Anda akan harus menulis akan mendapatkan bahkan lebih rumit masih. 

Dan jadi tidak perlu khawatir. Ternyata manusia sebelum kita telah menyadari mereka juga memiliki ini masalah yang sama. Mereka juga tidak menikmati harus ketik cukup panjang, perintah misterius, apalagi mengingat mereka. Dan jadi manusia sebelum kita telah membuat program lain yang membuatnya lebih mudah untuk mengkompilasi perangkat lunak Anda. 

Dan, memang, salah satu seperti Program ini disebut Membuat. Jadi aku akan pergi ke depan dan melakukan hal ini. Aku akan membatalkan semua yang saya hanya melakukan dengan cara berikut. Mari saya ketik LS. Dan Anda akan melihat tiga things-- a.out, dan bintang, halo dan bintang, dan hello.c. Mudah-mudahan, ini harus sedikit intuitif, sejauh sebelumnya ada tidak ada di ruang kerja ini. Ada apa-apa yang saya punya dibuat sampai kita mulai kelas. 

Dan saya buat hello.c. Saya kemudian dikompilasi, dan menyebutnya a.out. Dan kemudian aku dikompilasi lagi sedikit berbeda dan menyebutnya halo. Jadi saya memiliki tiga file dalam direktori ini, dalam folder ini disebut Workspace. Sekarang, saya bisa melihat bahwa juga jika saya zoom out sebenarnya. 

Jika saya tampilannya sini dan melihat bahwa tangan kanan atas sudut, seperti yang dijanjikan kiri sisi layar Anda selalu akan menunjukkan kepada Anda apa yang ada di akun Anda, apa dalam CS50 IDE. Dan ada tiga file yang ada. 

Jadi saya ingin menyingkirkan a.out dan Halo. Dan seperti yang mungkin Anda bayangkan intuitif, Anda bisa mengurutkan kontrol klik atau klik kanan pada ini. Dan menu kecil ini muncul. Anda dapat men-download file, jalankan itu, preview, menyegarkan, mengubah nama, atau apa yang tidak. 

Dan aku hanya bisa menghapus, dan itu akan pergi. Tapi mari kita melakukan hal-hal dengan perintah baris untuk saat ini, sehingga untuk mendapatkan nyaman dengan ini, dan melakukan hal berikut. Aku akan pergi ke depan dan menghapus a.out dengan mengetik harfiah rma.out. Ternyata, perintah untuk menghapus atau menghapus sesuatu, tidak menghapus atau menghapus. 

Ini lebih ringkas RM, hanya untuk menyimpan Anda beberapa keystrokes, dan tekan Enter. Sekarang kita akan menjadi agak samar menghapus file yang a.out biasa. Aku tidak benar-benar tahu apa File tidak teratur akan belum. Tapi saya ingin menghapusnya. 

Jadi aku akan mengetik y untuk yes. Atau aku bisa mengetik keluar, dan tekan Enter. Dan, sekali lagi, tidak ada yang tampaknya terjadi. Tapi itu, umumnya, merupakan hal yang baik. 

Jika saya ketik LS saat ini, apa yang harus saya lihat? Mudah-mudahan, hanya Halo dan hello.c. Sekarang, sebagai samping, Anda akan melihat bintang ini, tanda bintang, itu pada akhir program saya. Dan mereka juga muncul dalam warna hijau. Itu hanya cara CS50 IDE dari cluing Anda ke fakta bahwa itu bukan kode sumber. Itu eksekusi, sebuah runnable program yang Anda benar-benar dapat menjalankan dengan melakukan dot slash, dan kemudian nama itu. 

Sekarang, biarkan aku pergi ke depan dan menghapus ini, rm halo, Masukkan, hapus biasa mengajukan halo, ya. Dan jika saya ketik LS, kita kembali ke hello.c. Cobalah untuk tidak menghapus Anda kode sumber yang sebenarnya. Meskipun ada fitur dibangun ke CS50 IDE mana Anda dapat pergi melalui sejarah revisi Anda dan mundur dalam waktu jika Anda secara tidak sengaja menghapus sesuatu, lakukan harus sadar sesuai petunjuk ini ya atau tidak, dari apa yang sebenarnya ingin Anda lakukan. Dan jika aku pergi ke atas meninggalkan pojok sini, semua yang tersisa adalah hello.c. Jadi ada tandan perintah lain bahwa Anda dapat mengeksekusi dalam dunia Linux, salah satunya adalah, sekali lagi, Membuat. Dan kita akan Membuat Program saya sekarang sebagai berikut. 

Alih-alih melakukan dentang, bukannya melakukan dentang-o, Aku akan hanya harfiah mengetik, membuat halo. Dan sekarang perhatikan, saya tidak mengetik membuat hello.c. Saya mengetik membuat halo. 

Dan program ini Membuat bahwa dilengkapi dengan CS50 IDE, dan lebih umumnya dengan Linux, adalah program yang akan membuat sebuah program yang disebut Hello. Dan itu akan berasumsi, dengan konvensi, bahwa jika program ini dapat dibuat, itu akan dibuat dari sumber file kode berakhiran dot c, hello.c. 

Jadi jika saya tekan Enter sekarang, pemberitahuan bahwa perintah yang dijalankan sebenarnya bahkan lebih lama sebelum dari sebelumnya. Dan itu karena kita sudah dikonfigurasikan CS50 IDE untuk memiliki beberapa fitur tambahan built in yang kita tidak perlu dulu, tapi akan segera. Tetapi hal kunci untuk mewujudkan sekarang saya punya program Hello. 

Jika saya ketik LS lagi, saya memiliki program halo. Dan saya bisa menjalankannya dengan dot slash a.out, tidak ada, karena seluruh titik ini latihan adalah dot slash halo. Dan sekarang aku punya saya Program hello world. Jadi bergerak maju, kami hampir selalu hanya akan mengkompilasi program kami menggunakan perintah Membuat. Dan kemudian kita akan menjalankannya dengan dot slash, dan nama program. Tapi menyadari apa Membuat lakukan untuk Anda, adalah ia sendiri tidak kompilator. Ini hanya sebuah program kenyamanan yang tahu bagaimana untuk memicu kompilator untuk menjalankan sehingga Anda sendiri dapat menggunakannya. 

Apa perintah lain yang ada di Linux, dan pada gilirannya CS50 IDE? Kami akan segera melihat bahwa ada perintah CD, Change Directory. Hal ini memungkinkan Anda dalam antarmuka baris perintah Anda untuk bergerak maju, dan kembali, dan membuka folder yang berbeda tanpa menggunakan mouse Anda. 

LS kita melihat, yang merupakan singkatan dari daftar file dalam direktori saat ini. Membuat Dir, Anda bisa mungkin mulai untuk menyimpulkan apa ini berarti sekarang-- membuat direktori, jika Anda ingin membuat folder. RM untuk menghapus, RM Dir untuk menghapus directory-- dan ini, lagi, adalah baris perintah setara dari apa yang Anda bisa dilakukan di CS50 IDE dengan mouse Anda. Tapi Anda akan segera menemukan bahwa kadang-kadang itu hanya banyak lebih cepat untuk melakukan hal dengan keyboard, dan akhirnya jauh lebih kuat. 

Tapi sulit untuk berpendapat bahwa apa yang telah kami lakukan sejauh ini adalah semua yang kuat, ketika semua kami sudah katakan adalah, halo dunia. Dan, pada kenyataannya, saya hardcoded kata halo dunia ke dalam program saya. Tidak ada dinamisme belum. Scratch adalah urutan besarnya lebih menarik pekan lalu. 

Dan jadi mari kita ke sana. Mari kita mengambil langkah menuju bahwa dengan cara beberapa fungsi. Jadi tidak hanya C datang dengan printf, dan tandan fungsi lainnya beberapa di antaranya kita akan melihat dari waktu ke waktu, tidak membuat semuanya mudah keluar dari gerbang dalam mendapatkan input pengguna. 

Bahkan, salah satu kelemahan bahasa seperti C, dan bahkan Jawa dan belum lain, adalah bahwa hal itu tidak membuatnya mudah untuk hanya mendapatkan hal-hal seperti bilangan bulat dari pengguna, atau string, kata-kata, dan frase, membiarkan hal-hal sendiri seperti nilai floating point, atau bilangan real dengan poin desimal, dan benar-benar nomor lama, karena kami akan segera melihat. Jadi daftar ini fungsi di sini, ini seperti potongan Scratch puzzle lainnya bahwa kita telah pra-instal di CS50 IDE yang akan kami gunakan untuk beberapa minggu sebagai roda pelatihan macam, dan akhirnya membawa mereka off, dan mencari di bawah kap mesin, mungkin, di bagaimana hal-hal ini dilaksanakan. 

Tapi untuk melakukan ini, mari kita benar-benar menulis sebuah program. Biarkan aku pergi ke depan sekarang. Dan aku akan membuat yang baru mengajukan dengan mengklik sedikit ditambah ini, dan mengklik File New. 

Aku akan menyimpan ini selanjutnya satu sebagai, katakanlah, string.c, karena saya ingin bermain dengan string. Dan string dalam C hanya urutan karakter. Jadi sekarang mari kita pergi ke depan dan melakukan hal berikut. 

Termasuk standar IO.h-- dan ternyata standar IO, IO hanya berarti input dan output. Jadi ternyata bahwa baris ini di sini adalah apa adalah tetangga kita untuk menggunakan printf. Printf, tentu saja, menghasilkan output. Jadi untuk menggunakan printf, ternyata out Anda harus memiliki baris kode di bagian atas file Anda. 

Dan kami akan kembali ke apa yang benar-benar berarti tak lama. Ternyata di program C saya menulis, Aku harus memulainya dengan kode yang terlihat seperti ini. Dan Anda akan melihat CS50 IDE, dan pengembangan terpadu lainnya lingkungan seperti itu, akan mencoba sebaik mereka dapat untuk menyelesaikan pikiran Anda. Bahkan, beberapa saat yang lalu jika saya membatalkan apa yang baru saja saya lakukan, saya tekan Enter. 

Saya kemudian memukul keriting terbuka brace, tekan Enter lagi. Dan selesai pikiran saya. Ini memberi saya baris baru, menjorok tidak kurang untuk alasan gaya yang bagus kita akan lihat. Dan kemudian secara otomatis memberi saya bahwa penjepit keriting untuk menyelesaikan pikiran saya. Sekarang, itu tidak selalu menebak apa yang ingin Anda lakukan. Tapi sebagian besar, itu tidak menghemat keystrokes. Jadi saat yang lalu, kami berlari program-- ini halo, dunia, dan kemudian disusun itu, dan kemudian berlari. Tapi tidak ada dinamika di sini. Bagaimana jika kita ingin melakukan sesuatu yang berbeda? Nah, bagaimana jika saya ingin benar-benar mendapatkan string dari pengguna? Aku akan menggunakan potongan puzzle disebut persis itu-- mendapatkan tali. 

Ternyata di C bahwa ketika Anda tidak ingin untuk memberikan masukan untuk sepotong puzzle, atau lebih tepat ke fungsi, Anda harfiah hanya melakukan kurung buka, kurung tutup. Jadi seolah-olah ada ada kotak putih untuk mengetik dalam. The katakanlah blok sebelum memiliki kotak putih kecil. Kami tidak memiliki kotak putih sekarang. 

Tapi ketika saya sebut mendapatkan string, saya ingin menempatkan hasilnya di suatu tempat. Jadi paradigma yang sangat umum di C adalah untuk memanggil fungsi, seperti get tali di sini, dan kemudian menyimpan nilai kembali. Ini hasil yang usaha dalam sesuatu. 

Dan apa membangun dalam pemrograman, apakah di Scratch atau sekarang C, bahwa kita dapat digunakan untuk benar-benar menyimpan sesuatu? Menyebutnya variabel, kan? Dan di Scratch, kita tidak benar-benar peduli apa yang terjadi dalam variabel. 

Tapi dalam kasus ini, kita benar-benar dilakukan. Aku akan mengatakan tali. Dan kemudian aku bisa menelepon apa ini yang saya inginkan. Aku akan menyebutnya nama, mendapat mendapatkan tali. 

Dan sekarang bahkan jika Anda baru sedikit ini, melihat bahwa saya kurang rinci. Saya lupa titik koma. Aku harus menyelesaikan pikiran ini. Jadi aku akan memindahkan kursor saya, dan tekan semi-colon ada. Dan apa yang saya baru saja dilakukan? Dalam baris kode ini, nomor 5 pada saat ini, Saya menelepon get string dengan tidak ada input. Jadi tidak ada putih kecil kotak seperti Simpan blok memiliki. 

Aku hanya mengatakan, hei, komputer, mendapatkan saya string. Tanda sama tidak benar-benar tanda sama, per se. Ini tugas operator, yang berarti, hey, komputer, memindahkan nilai dari kanan ke kiri. Dan di sebelah kiri, saya memiliki berikut. 

Hei, komputer, memberi saya string-- a urutan karakter. Dan menyebut bahwa string Nama. Dan saya bahkan tidak menyebutnya Nama. 

Saya bisa menyebutnya, konvensional, sesuatu seperti S, seperti yang kita digunakan i untuk memanggil variabel i. Tapi sekarang saya harus melakukan sesuatu dengan itu. Itu akan sangat bodoh untuk coba kompilasi kode ini, berjalan program ini, meskipun Saya mendapatkan string, karena itu masih hanya akan menyapa dunia. 

Tapi bagaimana jika saya ingin mengubah ini. Mengapa saya tidak melakukan ini? Persen s, koma s. Dan ini sedikit samar masih. 

Jadi saya membuat variabel saya lebih jelas. Mari saya nama Nama variabel ini. Dan mari kita lihat apakah kita tidak bisa menggoda selain apa yang terjadi di sini. 

Jadi pada baris lima, saya mendapatkan string. Dan aku menyimpan string itu, apa pun pengguna telah diketik di di nya keyboard, dalam variabel yang disebut Nama. Dan ternyata printf tidak hanya mengambil satu argumen di ganda kutipan, satu input dalam tanda kutip ganda. 

Hal ini dapat mengambil dua, atau tiga, atau lebih, seperti yang kedua, atau ketiga, atau keempat, adalah semua nama variabel, atau secara khusus nilai, bahwa Anda ingin plug ke, dinamis, string dalam tanda kutip. Dengan kata lain, apa yang akan salah dengan ini? Jika saya hanya menyapa nama, backslash n, menyimpan file saya, dikompilasi kode saya, dan berlari ini, apa yang akan terjadi? 

Ini hanya akan mengatakan, halo nama, secara harfiah N-A-M-E, yang merupakan jenis bodoh karena itu tidak berbeda dari dunia. Jadi apa pun dalam tanda kutip adalah apa yang benar-benar akan dicetak. Jadi jika saya ingin memiliki placeholder di sana, Aku benar-benar perlu menggunakan beberapa sintaks khusus. Dan ternyata jika Anda membaca dokumentasi untuk fungsi printf, itu akan memberitahu Anda bahwa jika Anda menggunakan persen s, Anda dapat mengganti nilai sebagai berikut. 

Setelah koma setelah itu ganda kutipan, Anda hanya menulis nama variabel yang Anda inginkan pasang di dalam format yang kode, atau format specifier, persen s untuk string. Dan sekarang jika saya menyimpan file saya, Aku kembali ke terminal saya. Dan saya ketik Membuat String, karena, sekali lagi, nama ini file yang saya memilih sebelumnya adalah string.c. 

Jadi saya akan mengatakan Membuat String, masukkan. Oh ya ampun, melihat semua kesalahan yang kami buat sudah. Dan ini is-- apa, ini benar-benar seperti enam, tujuh program baris? Jadi ini adalah di mana ia sangat bisa cepat mendapatkan luar biasa. 

jendela terminal ini memiliki sekarang hanya dimuntahkan sejumlah besar pesan kesalahan. Tentunya, saya tidak memiliki lebih banyak kesalahan pesan dari saya memiliki baris kode. Jadi apa yang terjadi? 

Nah, strategi terbaik untuk melakukan kapan saja Anda jangan menjumpai luar biasa daftar kesalahan seperti itu, adalah gulir kembali, mencari perintah Anda hanya berlari, yang dalam kasus saya adalah membuat tali. Lihatlah apa yang membuat lakukan, dan itulah yang perintah dentang panjang, tidak ada masalah besar di sana. 

Tapi merah yang buruk. Hijau mencoba untuk menjadi lembut dan membantu. Tapi itu masih buruk, dalam hal ini. Tapi di mana itu buruk? 

String.c, garis lima, karakter lima. Jadi ini hanya konvensi umum. Sesuatu usus sesuatu berarti nomor baris dan nomor karakter. Kesalahan, penggunaan dideklarasikan identifier string yang. Apakah maksud Anda standar dalam? 

Jadi, sayangnya, dentang berusaha untuk membantu. Tapi itu salah, dalam hal ini. Tidak, dentang, aku tidak bermaksud standar IO. Aku berarti bahwa di saluran satu, ya. 

Tapi garis lima adalah salah satu ini di sini. Dan dentang tidak memahami S-T-R-I-N-G. Ini adalah dideklarasikan identifier, sebuah Kata itu hanya belum pernah terlihat sebelumnya. Dan itu karena C, bahasa kita menulis kode di sekarang, tidak memiliki variabel disebut string. 

Ini tidak, secara default, dukungan sesuatu yang disebut string. Itu sepotong CS50 dari jargon, tetapi sangat konvensional. Tapi saya bisa memperbaiki ini sebagai berikut. 

Jika saya menambahkan satu baris kode ke atas program ini, termasuk CS50.h, yang merupakan file lain suatu tempat di dalam dari CS50 IDE, di suatu tempat pada hard drive, sehingga untuk berbicara, dari sistem operasi Ubuntu bahwa aku berjalan, yang adalah file yang akan mengajarkan operasi Sistem apa string adalah, hanya seperti io.h standar file dalam sistem operasi itu akan mengajarkannya apa printf adalah. 

Memang, kita akan mendapatkan pesan yang sangat mirip jika IO telah mengakui standar Io.h dan mencoba menggunakan printf. Jadi aku akan pergi ke depan dan hanya mengambil Kontrol L untuk membersihkan layar saya. Atau Anda dapat mengetik jelas dan itu akan hanya membersihkan jendela terminal. Tapi Anda masih dapat menggulir kembali dalam waktu. 

Dan aku akan mengulangi Membuat String. Menyilangkan jari saya kali ini, Enter. Oh Tuhan, itu bekerja. itu menunjukkan saya perintah samar panjang itulah yang Membuat dihasilkan melalui dentang, tapi tidak ada pesan error. Jadi menyadari, meskipun Anda mungkin mendapatkan benar kewalahan dengan jumlah pesan error, itu hanya mungkin menjadi Cascading ini menjengkelkan efek, di mana dentang tidak mengerti satu hal, yang berarti kemudian tidak memahami kata berikutnya, atau baris berikutnya. Dan sehingga hanya tersedak kode Anda. Tapi fix mungkin sederhana. Dan selalu fokus pada baris pertama dari output. Dan jika Anda tidak memahaminya, hanya melihat untuk kata kunci yang mungkin petunjuk, dan nomor baris, dan karakter, di mana kesalahan yang mungkin. 

Sekarang biarkan aku pergi ke depan dan ketik dot slash, string, masukkan. Hm, itu tidak menyapa apa-apa. Mengapa? Nah, ingat, di mana itu berjalan? 

Itu mungkin terjebak pada saat ini dalam satu lingkaran, jika Anda mau, on line enam, karena Dapatkan String dengan desain, ditulis oleh staf CS50, secara harfiah berarti hanya duduk di sana menunggu, dan menunggu, dan menunggu string. Semua yang kita maksud dengan string input manusia. Sehingga Anda tahu apa? Biarkan aku pergi ke depan. Dan hanya pada kemauan, biarkan aku ketik nama saya, David, masukkan. Sekarang saya memiliki program yang lebih dinamis. Dikatakan, halo David. 

Jika saya pergi ke depan dan menjalankan ini lagi, biarkan aku mencoba mengatakan nama Zamila, masukkan. Dan sekarang kami memiliki program yang dinamis. Saya telah tidak sulit kode dunia. Saya belum sulit kode nama, atau David, atau Zamila. 

Sekarang jauh lebih seperti program kita tahu, di mana jika mengambil input, menghasilkan output yang sedikit berbeda. Sekarang, ini bukan yang terbaik pengalaman pengguna, atau UX. Saya menjalankan program. 

Aku tidak tahu apa yang seharusnya saya yang harus dilakukan, kecuali aku benar-benar melihat atau ingat kode sumber. Jadi mari kita membuat pengguna mengalami sedikit lebih baik dengan sederhana hal. Biarkan aku kembali ke ini Program, dan hanya mengatakan printf. 

Dan biarkan aku pergi ke depan dan mengatakan nama, usus besar, dan ruang, dan kemudian semi-colon. Dan hanya untuk iseng, tidak ada serangan balik n. Dan itu disengaja, karena saya tidak ingin prompt untuk pindah ke baris berikutnya. 

Saya ingin, sebaliknya, melakukan hal ini, membuat tali untuk mengkompilasi ulang kode saya ke dalam mesin baru Kode dot slash tali. Ah, ini jauh lebih cantik. Sekarang aku benar-benar tahu apa yang komputer ingin aku lakukan, memberikan nama. 

Jadi aku akan pergi ke depan dan ketik di Rob, masukkan, dan halo, Rob. Jadi, menyadari, ini masih, di akhir hari, hanya program sembilan line. Tapi kami telah mengambil langkah-langkah bayi tersebut. 

Kami menulis satu baris dengan yang kita akrab, printf, halo dunia. Kemudian kita meluruhkan sedikit itu. Dan kami benar-benar digunakan get tali. Dan kami melemparkan bahwa nilai dalam variabel. Dan kemudian kami pergi ke depan dan ditingkatkan lebih lanjut dengan baris ketiga. Dan proses berulang ini menulis perangkat lunak benar-benar kunci. Dalam CS50, dan dalam kehidupan pada umumnya, Anda harus umumnya tidak duduk, memiliki program dalam pikiran, dan mencoba menulis sialan seluruh sekaligus. 

Ini akan, pasti, mengakibatkan jalan kesalahan lebih dari kita sendiri lihat di sini. Bahkan aku, sampai hari ini, terus-menerus membuat kesalahan bodoh lainnya, adalah kesalahan sebenarnya lebih sulit yang sulit untuk mencari tahu. Tapi Anda akan membuat lebih banyak kesalahan yang lebih baris kode yang Anda tulis sekaligus. Dan praktek ini, menulis sedikit kode bahwa Anda merasa nyaman dengan, kompilasi itu, menjalankannya, mengujinya lebih umum, kemudian pindah on-- jadi seperti kita terus layering dan layering pekan lalu, membangun dari sesuatu yang sangat sederhana untuk sesuatu yang lebih kompleks, melakukan hal yang sama di sini. Jangan duduk, dan mencoba untuk menulis seluruh masalah. Benar-benar mengambil langkah-langkah bayi tersebut. 

Sekarang, string tidak semua yang berguna bagi diri mereka sendiri. Kami akan benar-benar, idealnya, seperti untuk memiliki sesuatu yang lain dalam toolkit kami. Jadi mari kita benar-benar melakukan hal itu. 

Biarkan aku pergi ke depan sekarang dan menyiapkan program yang sedikit berbeda. Dan kami akan memanggil int.c ini, untuk integer. Aku akan, sama, termasuk CS550.h. Aku akan mencakup standar IO. Dan itu akan menjadi cukup umum dalam beberapa hari pertama kelas. 

Dan aku akan siap diri dengan fungsi utama. Dan sekarang bukannya string, mari kita pergi ke depan dan mendapatkan int. Sebut saja saya, dan menyebutnya mendapatkan int, parens dekat, semi-kolon. Dan sekarang mari kita lakukan sesuatu dengan itu, printf. 

Katakanlah sesuatu seperti halo, backslash n, koma i. Jadi aku cukup banyak meniru apa yang saya lakukan beberapa saat yang lalu. Saya memiliki placeholder di sini. Saya telah koma saya di sini, karena saya ingin untuk plug saya ke placeholder itu. 

Jadi mari kita pergi ke depan dan mencoba kompilasi program ini. File ini disebut int.c. Jadi saya akan mengatakan, membuat int, masukkan. Oh Tuhan, tapi bukan masalah besar, kan? Ada kesalahan. 

Ada kesalahan sintaksis di sini sehingga program tidak bisa dikompilasi dalam int.c, baris tujuh, karakter 27, Format error menentukan tipe char membintangi, apa pun itu. Namun jenis argumen adalah int. 

Jadi di sini, juga, kita tidak akan to-- meskipun saat ini banyak bahan, kita akan membanjiri Anda dengan benar-benar setiap fitur C, dan pemrograman lebih umum, hanya beberapa minggu pertama. Jadi ada sering akan menjadi jargon dengan yang Anda tidak terbiasa. Dan, pada kenyataannya, bintang arang adalah sesuatu kita akan kembali ke dalam seminggu atau waktu dua ini. 

Tapi untuk saat ini, mari kita lihat apakah kita bisa mengurai kata-kata yang familiar. Formats-- jadi kami mendengar Format specifier, kode format yang sebelumnya. Itu familiar. Jenis usaha-- tetapi argumen memiliki tipe int. Tunggu sebentar, saya adalah int. 

Mungkin persen s sebenarnya memiliki beberapa makna didefinisikan. Dan, memang, itu tidak. Integer, jika Anda ingin printf untuk menggantikannya, Anda benar-benar harus menggunakan format yang berbeda specifier. Dan Anda tidak akan tahu ini kecuali jika seseorang mengatakan kepada Anda, atau Anda telah melakukannya sebelumnya. Tapi persen saya adalah apa dapat umum digunakan di printf untuk mencolokkan integer. Anda juga dapat menggunakan persen d untuk integer desimal. Tetapi saya bagus dan sederhana di sini. Jadi kita akan pergi dengan itu. 

Sekarang biarkan aku pergi ke depan dan jalankan kembali make int, Enter. Itu bagus, tidak ada kesalahan. Dot memangkas OK int--, pengalaman pengguna yang buruk, karena saya belum memberitahu diriku Apa yang harus dilakukan. Tapi itu baik-baik saja. Saya penangkapan pada cepat. 

Dan sekarang biarkan aku pergi ke depan dan ketik David, OK, Zamila, Rob. OK, jadi ini adalah hal yang baik. Kali ini, saya menggunakan fungsi, sepotong puzzle, yang disebut get int. Dan ternyata out-- dan kami akan lihat nanti ini di term-- yang staf CS50 telah menerapkan mendapatkan string yang sedemikian rupa bahwa hal itu akan hanya secara fisik mendapatkan string untuk Anda. 

Ini telah menerapkan get int di sedemikian rupa bahwa itu hanya akan mendapatkan integer untuk Anda. Dan jika Anda, manusia, tidak bekerja sama, itu benar-benar hanya akan mengatakan coba lagi, coba lagi, coba lagi, harfiah duduk di sana perulangan, sampai Anda mewajibkan dengan beberapa nomor ajaib, seperti 50, dan Halo 50. 

Atau jika kita menjalankan ini lagi dan ketik 42, halo 42. Dan fungsi get int dalam bahwa potongan puzzle cukup logika, cukup pikiran, untuk mencari tahu, apa kata? Dan apa adalah nomor? Hanya menerima, akhirnya, nomor. 

Jadi ternyata bahwa ini tidak semua yang ekspresif. sejauh ini. Jadi, yay, terakhir kali kami berjalan cukup cepat dalam menerapkan permainan, dan animasi, dan karya seni di Scratch. Dan di sini, kita sedang konten dengan halo dunia, dan Halo 50. 

Ini tidak semua inspirasi itu. Dan, memang, ini pertama beberapa contoh akan memakan waktu untuk meningkatkan dalam kegembiraan. Tapi kami memiliki begitu banyak mengontrol sekarang, sebenarnya. Dan kita akan sangat cepat mulai layering di atas ini primitif dasar. 

Tapi pertama-tama, mari kita memahami apa keterbatasan yang. Bahkan, salah satu hal Scratch tidak mudah mari kita lakukan adalah benar-benar melihat di bawah kap mesin, dan memahami apa komputer, apa yang dapat dilakukan, dan apa keterbatasan yang. Dan, memang, bahwa kurangnya pemahaman, berpotensi, jangka panjang dapat menyebabkan menulis mistakes-- kita sendiri bug, menulis perangkat lunak tidak aman yang hacked dalam beberapa cara. 

Jadi mari kita mengambil beberapa langkah-langkah menuju memahami ini sedikit lebih baik dengan cara, mengatakan, contoh berikut. Aku akan pergi ke depan dan menerapkan cepat nyata sebuah program yang disebut Adder. Seperti, mari kita tambahkan beberapa angka bersama. Dan aku akan kode beberapa sudut di sini, dan hanya copy dan paste di mana saya sebelumnya, hanya sehingga kami bisa pergi lebih cepat. Jadi sekarang aku punya awal dasar dari sebuah program yang disebut Adder. 

Dan mari kita pergi ke depan dan melakukan hal ini. Aku akan pergi ke depan dan katakanlah, INTx mendapat mendapatkan int. Dan kau tahu apa? Mari kita membuat pengalaman pengguna yang lebih baik. 

Jadi mari kita hanya mengatakan x adalah, dan efektif meminta pengguna untuk memberikan x. Dan kemudian biarkan aku pergi ke depan dan berkata, printf bagaimana y adalah, saat ini mengharapkan dua nilai dari pengguna. Dan kemudian mari kita pergi ke depan dan katakanlah, printf, jumlah x dan y adalah. Dan sekarang saya tidak ingin melakukan persen s. Saya ingin melakukan persen i, backslash n, dan kemudian pasang di nilai sum. 

Jadi bagaimana saya bisa pergi untuk melakukan ini? Kamu tahu apa? Aku tahu bagaimana menggunakan variabel. Mari saya hanya menyatakan yang baru, int z. 

Dan aku akan mengambil menebak di sini. Jika ada tanda-tanda sama dalam ini bahasa, mungkin aku hanya bisa melakukan x ditambah y, selama aku mengakhiri saya berpikir dengan semi-colon? Sekarang aku bisa kembali ke sini, pasang di z, menyelesaikan pikiran ini dengan semi-kolon. Dan mari kita lihat sekarang, apakah ini urutan lines-- x adalah mendapatkan int. Y adalah mendapatkan int. 

Tambahkan x dan y, menyimpan nilai di z-- Jadi, sekali lagi, ingat tanda sama tidak sama. Ini tugas dari kanan ke kiri. Dan mari kita mencetak sum dari x dan y tidak harfiah z, tapi apa dalam z. Jadi mari kita membuat Adder - bagus, tidak ada kesalahan saat ini. Dot memangkas Adder, masukkan, x akan menjadi 1. 

Y akan menjadi 2. Dan jumlah x dan y adalah 3. Jadi itu semua baik dan bagus. 

Jadi Anda akan membayangkan matematika yang harus bekerja dalam program seperti ini. Tapi kau tahu apa? Apakah variabel ini, baris 12, bahkan perlu? Anda tidak perlu masuk ke dalam kebiasaan hanya menyimpan hal-hal di variabel hanya karena Anda bisa. Dan, pada kenyataannya, itu umumnya desain yang buruk Dianggap jika Anda membuat sebuah variabel, disebut z dalam kasus ini, menyimpan sesuatu di dalamnya, dan kemudian segera menggunakannya, tapi tidak pernah lagi. Mengapa memberikan sesuatu nama seperti z jika Anda benar-benar akan menggunakan Hal hanya sekali, dan sebagainya proksimal ke tempat Anda buat itu di tempat pertama, begitu dekat dalam hal baris kode? Sehingga Anda tahu apa? Ternyata C cukup fleksibel. Jika saya benar-benar ingin plug-in nilai di sini, Aku tidak perlu mendeklarasikan variabel baru. Aku hanya bisa plug-in x ditambah y, karena C mengerti aritmatika, dan operator matematika. 

Jadi saya hanya bisa mengatakan, melakukan matematika ini, x ditambah y, apa pun nilai-nilai tersebut, pasang yang dihasilkan integer menjadi string. Jadi ini mungkin, meskipun hanya satu baris yang lebih pendek, desain yang lebih baik, program yang lebih baik, karena ada kode kurang, oleh karena itu kurang bagi saya untuk memahami. Dan itu juga hanya bersih, sejauh kita tidak memperkenalkan kata-kata baru, simbol baru, seperti z, meskipun mereka tidak benar-benar melayani banyak tujuan. 

Sayangnya, matematika tidak semua yang kadang-kadang dapat diandalkan. Mari kita pergi ke depan dan melakukan hal ini. Aku akan pergi ke depan sekarang dan melakukan hal berikut. 

Mari kita lakukan printf, persen saya, ditambah persen i, harus persen i, backslash n. Dan aku akan melakukan ini-- xyx ditambah y. Jadi aku hanya akan menulis ulang ini sedikit berbeda di sini. Saya hanya melakukan cek kewarasan cepat. Sekali lagi, mari kita tidak maju dari diri kita sendiri. Membuat penambah, dot slash penambah. x adalah 1, y adalah 2, 1 ditambah 2 adalah 3. Jadi itu bagus. Tapi mari kita mempersulit ini sekarang sedikit, dan membuat file baru. 

Aku akan menyebutnya satu, mengatakan, int, jamak untuk bilangan bulat. Mari saya mulai di mana aku berada saat yang lalu. Tapi sekarang mari kita lakukan beberapa baris lainnya. Biarkan aku pergi ke depan dan melakukan hal berikut, printf, persen i, dikurangi persen i, adalah persen i, koma x, koma yx dikurangi y. Jadi aku melakukan sedikit matematika yang berbeda di sana. Mari kita lakukan satu sama lain. Jadi persen saya kali persen i adalah persen i, backslash n. Mari plug-in x, dan y, dan x kali y. Kami akan menggunakan tanda bintang pada komputer Anda untuk kali. 

Anda tidak menggunakan x. x adalah nama variabel di sini. Anda menggunakan bintang untuk perkalian. Mari kita lakukan satu lagi. Printf persen I, dibagi oleh persen i, adalah persen i, n backslash. xy dibagi dengan y-- sehingga Anda menggunakan garis miring di C untuk melakukan pembagian. Dan mari kita lakukan yang lain. Sisa persen i, dibagi oleh persen i, adalah persen i. xy-- dan sekarang sisanya adalah apa yang tersisa. Ketika Anda mencoba membagi penyebut menjadi pembilang sebuah, berapa banyak yang tersisa yang Anda tidak bisa membagi keluar? 

Jadi tidak ada benar-benar, tentu, simbol kami telah digunakan di sekolah dasar untuk ini. Tapi ada di C. Anda dapat mengatakan x modulo y, di mana ini tanda persen di context-- ini membingungkan ketika Anda di dalam dari tanda kutip ganda, dalam printf, persen digunakan sebagai format specifier. 

Bila Anda menggunakan persen di luar bahwa dalam ekspresi matematika, itu operator modulo untuk modular arithmetic-- untuk tujuan kita di sini, hanya berarti, apa yang sisa x dibagi dengan y? Jadi x dibagi dengan y adalah x slash y. Apa sisa x dibagi dengan y? Ini x mod y, sebagai programmer akan mengatakan. 

Jadi jika saya tidak membuat kesalahan di sini, saya pergi ke depan dan membuat int, plural, baik, dan int slash dot. Dan mari kita pergi ke depan dan lakukan, katakanlah, 1, 10. Baiklah, 1 ditambah 10 adalah 11, cek. 1 minus 10 negatif 9, periksa. 

1 kali 10 adalah 10, cek. 1 dibagi dengan 10 is-- OK, kita akan melewatkan satu itu. Sisa 1 dibagi dengan 10 adalah 1. Itu benar. Tapi ada bug di sini. 

Jadi satu saya menempatkan saya menyerahkan, tidak benar. Maksudku, itu dekat dengan 0. 1 dibagi dengan 10, Anda tahu, jika kita memotong beberapa sudut, yakin, itu nol. Tapi itu benar-benar harus 1/10, 0,1, atau 0,10, 0,1000, atau lain sebagainya. 

Ini harus benar-benar nol. Nah, ternyata bahwa komputer adalah melakukan harfiah apa yang kita diberitahu untuk melakukan. Kami melakukan matematika seperti x dibagi dengan y. Dan kedua x dan y, per baris kode sebelumnya, adalah bilangan bulat. 

Selain itu, pada baris 15, kita mengatakan printf, hey, printf plug-in integer, plug-in integer, plug-dalam integer-- khusus x, dan kemudian y, dan kemudian x dibagi dengan y. x dan y adalah int. Kami baik di sana. 

Tapi apa yang x dibagi dengan x? x dibagi dengan y harus, matematis, 1/10, atau 0,1, yang merupakan bilangan real, bilangan real memiliki, berpotensi, titik desimal. Ini bukan integer. 

Tapi apa yang paling dekat integer untuk 1/10, atau 0,1? Ya, itu jenis adalah nol. 0.1 adalah seperti banyak ini. Dan 1 adalah sebanyak ini. Jadi 1/10 lebih dekat dengan 0 daripada untuk satu. 

Dan jadi apa C lakukan untuk us-- jenis karena kami diberitahu itu to-- adalah truncating integer yang. Itu mengambil nilai, yang lagi seharusnya menjadi sesuatu seperti 0,1000, 0 dan sebagainya. Dan itu truncating segalanya setelah titik desimal sehingga semua ini hal, karena tidak cocok gagasan integer, yang adalah nomor seperti negatif 1, 0, 1, atas dan ke bawah, itu membuang segalanya setelah titik desimal karena Anda tidak bisa cocok dengan titik desimal di sebuah integer dengan definisi. 

Jadi jawabannya di sini adalah nol. Jadi bagaimana kita mengatasinya? Kita perlu solusi lain bersama-sama. Dan kita bisa melakukan ini, sebagai berikut. 

Biarkan aku pergi ke depan dan membuat yang baru berkas, yang satu ini disebut floats.c. Dan simpan di sini di direktori yang sama, float.c. Dan biarkan aku pergi ke depan dan menyalin beberapa kode dari sebelumnya. 

Tapi bukannya int, mari kita lakukan ini. Beri aku nilai floating point disebut x. di mana floating point Nilai hanya harfiah sesuatu dengan floating point. Hal ini dapat bergerak ke kiri, ke kanan. Ini adalah bilangan real. 

Dan biarkan aku sebut tidak mendapatkan int, tapi mendapatkan float, yang juga berada di antara menu pilihan di perpustakaan C250. Mari kita mengubah y ke float. Jadi ini menjadi mendapatkan float. 

Dan sekarang, kita tidak ingin pasang di int. Ternyata kita harus menggunakan persen f untuk float, persen f untuk float, dan sekarang simpan. Dan sekarang, semoga, membuat mengapung, bagus, mengapung dot slash. x akan menjadi salah satu 1. y Akan menjadi 10 lagi. 

Dan, bagus, OK Selain saya benar. Saya berharap untuk lebih, tapi saya lupa untuk menulis itu. Jadi mari kita pergi dan memperbaiki kesalahan logis ini. 

Mari kita pergi ke depan dan ambil berikut. Kami hanya akan melakukan copy sedikit dan paste. Dan aku akan mengatakan dikurangi. 

Dan aku akan mengatakan kali. Dan aku akan mengatakan dibagi. Dan aku tidak akan melakukan Modulo, yang tidak erat di sini, dibagi dengan f, dan kali plus-- OK, mari kita lakukan ini lagi. 

Membuat mengapung, mengapung dot slash, dan 1, 10, dan-- bagus, tidak ada, OK. Jadi aku idiot. Jadi ini sangat umum dalam ilmu komputer untuk membuat kesalahan bodoh seperti ini. 

Untuk tujuan pedagogis, apa yang saya benar-benar ingin lakukan itu mengubah ilmu di sini untuk ditambah, menjadi minus, untuk kali, dan untuk membagi, karena Anda mudah-mudahan perhatikan selama latihan ini. Jadi sekarang mari kita melakukan kompilasi ulang ini Program, melakukan mengapung dot slash. 

Dan untuk ketiga kalinya, mari kita melihat apakah memenuhi harapan saya. 1, 10, masukkan, ya, OK, 1.000, dibagi dengan 10.000, adalah 0,100000. Dan ternyata kita dapat mengontrol berapa banyak angka setelah titik-titik desimal. Kami benar-benar akan. Kami akan kembali ke itu. 

Tapi sekarang, pada kenyataannya, matematika adalah benar. Jadi, sekali lagi, apa takeaway di sini? Ternyata di C, ada tidak hanya strings-- dan, pada kenyataannya, tidak ada benar-benar, karena kita menambahkan mereka dengan perpustakaan CS50. Tapi ada tidak hanya int. 

Ada juga mengapung. Dan ternyata sekelompok data lainnya jenis juga, yang akan kami gunakan sebelum lama. Ternyata jika Anda ingin satu karakter, bukan string karakter, Anda dapat menggunakan hanya char. 

Ternyata bahwa jika Anda ingin bool, nilai Boolean, benar atau salah satunya, berkat perpustakaan CS50, kami telah ditambahkan ke C tipe data bool juga. Tapi itu juga hadir di banyak bahasa lain juga. Dan ternyata bahwa kadang-kadang Anda perlu nomor lebih besar kemudian datang secara default dengan ints dan mengapung. 

Dan, pada kenyataannya, ganda adalah angka yang menggunakan tidak 32 bit, tapi 64 bit. Dan lama adalah angka yang menggunakan tidak 32, bit tapi 64 bit, masing-masing, untuk floating point nilai-nilai dan bilangan bulat, masing-masing. Jadi mari kita benar-benar sekarang melihat ini dalam tindakan. 

Aku akan pergi ke depan di sini dan menyiapkan satu program lainnya. Di sini, saya akan pergi ke depan dan jangan termasuk CS50.h. Dan biarkan aku pergi, termasuk standar IO.h. 

Dan Anda akan melihat sesuatu yang funky yang terjadi di sini. Ini tidak warna coding hal di dengan cara yang sama seperti yang terjadi sebelumnya. Dan ternyata, itu karena aku tidak memberikan hal nama file. 

Aku akan menyebutnya satu sizeof.c, dan tekan Simpan. Dan perhatikan apa yang terjadi pada saya sangat Kode putih terhadap yang latar belakang hitam. Sekarang, setidaknya ada beberapa ungu di sana. Dan itu adalah sintaks disorot. 

Itu karena, cukup sederhana, saya sudah mengatakan IDE apa jenis file itu adalah dengan memberi nama, dan khusus ekstensi file. Sekarang, mari kita pergi ke depan dan melakukan hal ini. Aku akan pergi ke depan dan sangat hanya mencetak bool following-- adalah persen LU. 

Kami akan kembali ke yang hanya dalam beberapa saat. Dan kemudian aku akan ukuran cetak dari bool. Dan sekarang, hanya untuk menyimpan sendiri beberapa waktu, aku akan melakukan keseluruhan sekelompok tersebut sekaligus. Dan, khususnya, aku akan mengubahnya ke char dan arang. yang satu ini, saya akan mengubah untuk ganda dan ganda. 

yang satu ini, saya akan mengubah untuk pelampung dan pelampung. yang satu ini, saya akan mengubah ke int dan int. Dan yang satu ini, saya akan untuk mengubah ke yang lama. Dan itu masih mengambil lama, lama. 

Dan kemudian, terakhir, saya berikan diriku satu terlalu banyak, tali. Ternyata di C, ada operator khusus yang disebut ukuran yang secara harfiah akan, ketika dijalankan, memberitahu kami ukuran masing-masing variabel. Dan ini adalah cara, sekarang, kita bisa menghubungkan kembali untuk diskusi minggu lalu data dan representasi. 

Biarkan aku pergi ke depan dan kompilasi ukuran ukuran slash dot dari. Dan mari kita lihat. Ternyata di C, khusus pada CS50 IDE, secara khusus pada sistem operasi Ubuntu, yang merupakan operasi 64-bit sistem dalam kasus ini, bool akan menggunakan satu byte ruang. Itulah cara ukuran diukur, tidak dalam bit, tapi dalam byte. Dan ingat bahwa satu byte adalah delapan bit. Jadi bool, meskipun Anda secara teknis hanya perlu 0 atau 1, itu sedikit boros bagaimana kita telah menerapkan hal itu. Ini benar-benar akan menggunakan keseluruhan byte-- sehingga semua nol, yang mungkin semua orang, atau sesuatu seperti itu, atau hanya satu 1 di antara delapan bit. 

Sebuah char, sementara itu, digunakan untuk karakter seperti karakter Ascii per pekan lalu, akan menjadi satu karakter. Dan yang synchs dengan gagasan kami itu menjadi tidak lebih dari 256 bits-- lebih tepatnya, synchs dengan itu menjadi tidak ada lebih dari 8 bit, yang memberi kita sebanyak 256 nilai. Sebuah ganda akan menjadi 8 byte atau 64 bit. 

Sebuah float adalah 4. Int adalah 4. Sebuah panjang, panjang 8. Dan string adalah 8. Tapi jangan khawatir tentang itu. Kita akan mengupas lapisan itu. Ternyata, string bisa lebih panjang dari 8 byte. 

Dan, memang, kami telah menulis string sudah, halo dunia, lebih dari 8 byte. Tapi kita akan kembali ke yang hanya dalam beberapa saat. Tapi take away di sini adalah sebagai berikut. 

Setiap komputer hanya memiliki terbatas jumlah memori dan ruang. Anda hanya dapat menyimpan begitu banyak file pada Mac atau PC. Anda hanya dapat menyimpan begitu banyak program di RAM berjalan sekaligus, tentu, bahkan dengan memori virtual, karena Anda memiliki jumlah terbatas RAM. 

Dan hanya untuk picture-- jika Anda tidak pernah membuka laptop atau memerintahkan memori tambahan untuk komputer, Anda mungkin tidak tahu bahwa dalam komputer Anda adalah sesuatu yang tampak sedikit seperti ini. Jadi ini hanya sebuah perusahaan umum bernama Penting yang membuat RAM untuk komputer. Dan RAM adalah tempat program hidup sementara mereka sedang berjalan. 

Jadi pada setiap Mac atau PC, ketika Anda dua kali lipat klik program, dan membuka, dan membuka beberapa dokumen Word atau semacam itu, itu toko sementara di RAM, karena RAM yang lebih cepat dari hard disk Anda, atau solid state disk Anda. Jadi itu hanya di mana program pergi untuk hidup ketika mereka sedang berjalan, atau ketika file sedang digunakan. 

Jadi Anda memiliki hal-hal yang terlihat seperti dalam ini laptop Anda, atau hal-hal sedikit lebih besar dalam desktop Anda. Tapi kuncinya adalah Anda hanya memiliki jumlah terbatas hal-hal ini. Dan hanya ada sejumlah terbatas hardware duduk di meja ini benar sini. 

Jadi, pasti, kita tidak bisa menyimpan nomor panjang tak terhingga. Dan, namun, jika Anda berpikir kembali ke sekolah dasar, berapa banyak digit bisa Anda harus kanan dari titik desimal? Untuk itu, berapa banyak digit bisa Anda harus di sebelah kiri titik desimal? Sungguh, tak terhingga banyaknya. 

Sekarang, kita manusia hanya mungkin tahu bagaimana cara mengucapkan juta, dan miliar, triliun, dan kuadriliun, dan triliun. Dan aku mendorong batas-batas saya understanding-- atau my-- saya mengerti angka, tapi saya pengucapan angka. Tapi mereka bisa mendapatkan jauh besar dengan tak terhingga banyaknya digit ke kiri atau ke kanan titik desimal. 

Tetapi komputer hanya memiliki jumlah terbatas memori, jumlah terbatas transistor, jumlah terbatas bola lampu di dalam. Jadi apa yang terjadi ketika Anda kehabisan ruang? Dengan kata lain, jika Anda berpikir kembali ke minggu lalu ketika kita berbicara tentang angka sendiri yang diwakili dalam biner, misalkan kita punya nilai ini 8-bit di sini. 

Dan kami memiliki tujuh 1 dan satu 0. Dan misalkan kita ingin untuk menambah 1 untuk nilai ini. Ini adalah jumlah yang sangat besar sekarang. 

Ini adalah 254, jika saya ingat matematika dari minggu lalu yang tepat. Tapi bagaimana jika saya mengubah yang paling kanan 0 ke 1? Jumlah keseluruhan, dari Tentu saja, menjadi delapan 1 ini. Jadi kita masih baik. 

Dan yang mungkin mewakili 255, meskipun tergantung pada konteks itu benar-benar bisa mewakili angka negatif. Tetapi lebih pada lain waktu. Ini terasa seperti itu tentang setinggi aku bisa menghitung. 

Sekarang, itu hanya 8 bit. Dan Mac saya, pasti, memiliki cara lebih dari 8 bit memori. Tetapi memiliki terbatas. Jadi argumen yang sama berlaku, bahkan jika kita memiliki lebih dari orang-orang ini di layar. 

Tapi apa yang terjadi jika Anda menyimpan nomor ini, 255, dan Anda ingin menghitung 1 bit yang lebih tinggi? Anda ingin pergi 255-256. Masalahnya, tentu saja, adalah bahwa jika Anda mulai menghitung dari nol seperti minggu lalu, Anda tidak bisa menghitung setinggi 256, apalagi 257, apalagi 258, m karena apa terjadi ketika Anda menambahkan 1? Jika Anda melakukan sekolah dasar tua Pendekatan, Anda menempatkan 1 di sini, dan kemudian 1 ditambah 1 adalah 2, tapi itu benar-benar nol, Anda membawa 1, membawa 1, membawa 1. Semua hal ini, ini 1 ini, pergi ke nol. Dan Anda angin, ya, sebagai seseorang menunjukkan, 1 di sisi kiri. Tapi semua yang Anda bisa benar-benar melihat dan muat di memori hanya delapan 0, yang adalah untuk mengatakan di beberapa titik jika Anda, komputer, mencoba menghitung cukup tinggi, Anda akan membungkus, tampaknya, dengan nol, atau mungkin bahkan negatif angka, yang bahkan lebih rendah dari nol. 

Dan kita bisa semacam melihat ini. Biarkan aku pergi ke depan dan menulis program cepat nyata di sini. Biarkan aku pergi ke depan dan menulis sebuah program yang disebut Overflow. Termasuk CS50.h, termasuk standar IO.h-- oh, Aku benar-benar merindukan penyorotan sintaks saya. Jadi mari kita simpan ini sebagai overflow.c. 

Dan sekarang int void-- utama dan tak lama, kami akan kembali ke menjelaskan mengapa kami terus menulis void main int. Tapi untuk saat ini, mari kita lakukan itu, mengambil begitu saja. Mari kita memberi diriku int, dan menginisialisasi ke 0. 

Mari kita kemudian lakukan untuk int saya mendapatkan zero-- sebenarnya, mari kita lakukan loop tak terbatas dan melihat apa yang terjadi. Sementara benar, maka mari kita mencetak n adalah persen i, backslash n, plug-in n. Tapi, sekarang, mari kita lakukan n mendapat n ditambah 1. 

Jadi dengan kata lain, pada setiap iterasi dari loop tak terbatas ini, mari kita nilai n ini, dan tambahkan 1 untuk itu, dan kemudian menyimpan hasilnya kembali n di sebelah kiri. Dan, pada kenyataannya, kita telah melihat sintaks sedikit seperti ini, sebentar. Sebuah trik keren adalah bukan menulis semua ini, Anda benar-benar dapat mengatakan sebuah n ditambah sama dengan 1. 

Atau jika Anda benar-benar ingin menjadi mewah, Anda bisa mengatakan n plus plus semi-kolon. Tapi ini dua terakhir hanya apa yang kita sebut gula sintaksis untuk hal pertama. 

Hal pertama adalah lebih eksplisit, benar-benar baik, benar-benar benar. Tapi ini lebih umum, saya akan mengatakan. Jadi kita akan melakukan ini untuk sesaat. 

Sekarang mari kita membuat overflow, yang terdengar agak menyenangkan, dot slash melimpah. Mari kita lihat, n semakin cukup besar. Tapi mari berpikir, seberapa besar n bisa mendapatkan? 

n adalah int. Kami melihat beberapa saat yang lalu dengan ukuran Contoh yang int adalah empat byte. Kita tahu dari minggu lalu, empat byte adalah 32 bit, karena 8 kali 4, itu 32. Itu akan menjadi 4 miliar. 

Dan kami sampai 800.000. Ini akan mengambil selamanya untuk dihitung sebagai tinggi seperti yang saya bisa. Jadi aku akan pergi ke depan, seperti yang mungkin Anda sebelum lama, dan tekan Control C-- terus terang, Kontrol C, banyak, di mana kontrol C umumnya berarti membatalkan. Sayangnya, karena ini berjalan di awan, kadang-kadang awan adalah menyemburkan begitu banyak hal, begitu banyak output, itu akan mengambil sedikit waktu untuk masukan saya untuk sampai ke awan. Jadi meskipun aku memukul Kontrol C beberapa detik yang lalu, ini jelas sisi efek loop tak terbatas. 

Dan dalam kasus tersebut, kami akan meninggalkan yang ada. Dan kita akan menambah jendela terminal di sini dengan ditambah, yang tentu saja tidak seperti itu, karena itu masih berpikir. Dan mari kita pergi ke depan dan menjadi sedikit lebih masuk akal. 

Aku akan pergi ke depan dan melakukan ini hanya finitely berkali-kali. Mari kita gunakan untuk loop, yang saya singgung sebelumnya. Ayo lakukan ini. Beri aku variabel int lain saya mendapat 0. i kurang dari, katakanlah, 64 i ++. Dan sekarang biarkan aku pergi ke depan dan cetak out n adalah persen i, koma n. Dan kemudian n-- ini masih akan mengambil selamanya. Ayo lakukan ini. 

n mendapat n kali 2. Atau kita bisa menjadi mewah dan melakukan kali sama 2. Tapi mari kita hanya mengatakan n sama itu sendiri, kali 2. Dengan kata lain, dalam hal ini Versi baru dari program, Saya tidak ingin menunggu selamanya dari seperti 800.000 untuk 4 miliar. Mari kita mendapatkan lebih dari ini dengan. 

Mari kita benar-benar menggandakan n setiap kali. Yang, ingat, penggandaan adalah berlawanan memiliki, tentu saja. Dan sedangkan minggu lalu kita memiliki sesuatu lagi, dan lagi, dan sekali lagi, super cepat, penggandaan pasti akan mendapatkan kita dari 1 ke terbesar mungkin nilai yang kita dapat menghitung sampai dengan int. 

Jadi mari kita melakukan hal ini. Dan kami akan kembali ke ini sebelum lama. Tapi ini, sekali lagi, adalah seperti blok ulangi di Scratch. Dan Anda akan menggunakan ini sebelum lama. 

Ini hanya berarti menghitung dari nol sampai, tapi tak sama, 64. Dan pada setiap iterasi ini lingkaran, terus incrementing i. Jadi i ++ - dan membangun umum ini pada baris 7 adalah cara super umum mengulangi beberapa baris kode, beberapa beberapa kali. baris kode yang? Ini kurung kurawal, seperti yang Anda mungkin diperoleh dari sekarang, berarti, lakukan langkah berikut. 

Ini di seperti Scratch, ketika memiliki blok kuning dan warna lain yang sejenis merangkul atau memeluk blok lainnya. Itulah yang mereka keriting kawat gigi lakukan di sini. Jadi jika saya punya sintaks saya right-- Anda dapat melihat simbol wortel di C berarti itu berapa kali saya mencoba untuk memecahkan masalah ini. Jadi mari kita menyingkirkan salah satu yang sama sekali, dan menutup jendela itu. Dan kita akan menggunakan yang baru. Membuat overflow, dot slash overflow, Masukkan, baiklah, terlihat buruk pada awalnya. Tapi mari kita gulir kembali waktu, karena saya melakukan ini 64 kali. 

Dan melihat pertama kalinya, n adalah 1. Kedua kalinya, n adalah 2, kemudian 4, kemudian 8, kemudian 16. Dan tampaknya segera Saya mendapatkan sekitar 1 miliar, jika saya dua kali lipat lagi, bahwa harus memberi saya 2 miliar. Tapi ternyata, itu tepat di titik puncak. 

Dan itu benar-benar meluap int dari 1 miliar kira-kira negatif 2 miliar, karena integer, tidak seperti nomor kami yang mengasumsikan pekan lalu, bisa positif dan negatif dalam realitas dan di komputer. Dan jadi setidaknya salah satu dari mereka bit secara efektif dicuri. Jadi kita benar-benar hanya memiliki 31 bit, atau 2 miliar nilai yang mungkin. 

Tapi untuk saat ini, takeaway cukup sederhana, apa nomor ini dan apa pun matematika adalah, sesuatu yang buruk terjadi pada akhirnya, karena pada akhirnya Anda mencoba untuk permutasi bit satu kali terlalu banyak. Dan Anda secara efektif pergi dari semua 1 untuk mungkin semua 0, atau mungkin hanya beberapa pola lain yang jelas, tergantung pada konteks, dapat diartikan sebagai angka negatif. Dan sehingga akan tampak I tertinggi dapat menghitung dalam program khusus ini hanya sekitar 1 miliar. Tapi ada solusi parsial sini. Kamu tahu apa? 

Mari saya berubah dari int ke yang lama. Dan biarkan aku pergi ke depan di sini dan say-- aku akan memiliki untuk mengubah ini ke sebuah panjang unsigned. Atau, mari kita lihat, saya tidak pernah ingat diriku. 

Mari kita pergi ke depan dan membuat melimpah. Tidak, bukan itu, LLD, terima kasih. Jadi kadang-kadang dentang dapat membantu. Aku tidak ingat apa format specifier adalah untuk lama. 

Tapi, memang, dentang mengatakan kepada saya. Hijau adalah beberapa jenis yang baik, masih berarti Anda melakukan kesalahan. Ini menebak bahwa saya berarti LLD. 

Jadi biarkan aku mengambil nasihat, panjang angka desimal yang panjang, simpan itu. Dan biarkan aku jalankan itu, dot slash overflow, Enter. Dan sekarang apa yang keren adalah ini. 

Jika saya gulir kembali waktu, kita masih mulai menghitung pada saat yang sama place-- 1, 2, 4, 8, 16. Perhatikan, kita mendapatkan semua Cara hingga 1 miliar. Tapi kemudian kita aman sampai ke 2 miliar. 

Kemudian kita bisa 4 miliar, kemudian 8 miliar, 17 miliar. Dan kita pergi lebih tinggi, dan lebih tinggi, dan lebih tinggi. Akhirnya, ini, juga, istirahat. 

Akhirnya, dengan lama, yang merupakan nilai 64-bit, tidak nilai 32-bit, jika Anda menghitung terlalu tinggi, Anda membungkus 0. Dan dalam hal ini, kita kebetulan berakhir dengan angka negatif. 

Jadi ini adalah masalah. Dan ternyata ini Masalahnya adalah tidak semua rahasia itu. Meskipun saya sudah sengaja diinduksi dengan kesalahan-kesalahan ini, ternyata kita lihat jenis semua di sekitar kita, atau setidaknya sebagian dari kita lakukan. 

Jadi dalam Lego Star Wars, jika Anda pernah memainkan permainan, ternyata Anda bisa pergi sekitar melanggar hal-hal di dunia LEGO, dan mengumpulkan koin, dasarnya. Dan jika Anda pernah memainkan ini cara permainan terlalu banyak waktu, sebagai individu yang tidak disebutkan namanya ini di sini melakukan, jumlah koin yang bisa Anda kumpulkan adalah, tampaknya, 4 miliar. 

Sekarang, dengan itu benar-benar bulat. Jadi LEGO berusaha menjaga hal-hal user friendly. Mereka tidak melakukannya tepat 2 untuk 32 kekuatan, per pekan lalu. Tapi 4 miliar alasan. Tampaknya, berdasarkan informasi ini, bahwa LEGO, dan perusahaan yang membuat perangkat lunak yang sebenarnya ini, memutuskan bahwa jumlah maksimum koin pengguna dapat menumpuk adalah, memang, 4 miliar, karena mereka memilih dalam kode mereka untuk menggunakan tidak lama, tampaknya, tetapi hanya sebuah integer, unsigned integer, hanya bilangan bulat positif, yang nilai maks kira-kira itu. Nah, inilah satu lagi yang lucu. Jadi di game Civilization, yang beberapa dari Anda mungkin akrab dengan ternyata tahun yang lalu ada bug di mana game ini jika Anda bermain peran Gandhi dalam permainan, bukan dia yang sangat damai, sebaliknya adalah sangat, sangat agresif, dalam beberapa keadaan. Secara khusus, cara yang Peradaban karya adalah bahwa jika Anda, pemain, mengadopsi demokrasi, Anda skor agresivitas mendapat dikurangi oleh dua, jadi dikurangi dikurangi, dan kemudian dikurangi dikurangi. 

Jadi Anda kurangi 2 dari iterasi yang sebenarnya Anda. Sayangnya, jika iterasi Anda awalnya 1, dan kurangi 2 dari itu setelah mengadopsi demokrasi sebagai Gandhi di sini mungkin telah dilakukan, karena dia sangat passive-- 1 pada skala agresivitas. Tetapi jika ia mengadopsi demokrasi, maka dia pergi dari 1 sampai negatif 1. 

Sayangnya, mereka menggunakan nomor unsigned, yang berarti mereka memperlakukan bahkan negatif nomor seolah-olah mereka positif. Dan ternyata bahwa setara positif dari negatif 1, dalam program komputer biasa, adalah 255. Jadi jika Gandhi mengadopsi demokrasi, dan karena itu memiliki skor agresivitas nya menurun, itu benar-benar gulungan sekitar 255 dan membuat dia yang paling karakter agresif dalam permainan. Jadi Anda dapat Google pada ini. Dan itu, memang, disengaja pemrograman bug, tapi itu masuk cukup yang pengetahuan sejak. 

Itu semua menyenangkan dan lucu. Lebih menakutkan adalah ketika sebenarnya perangkat dunia nyata, dan tidak game, memiliki bug yang sama. Bahkan, setahun yang lalu sebuah artikel datang tahu tentang Boeing 787 Dreamliner. 

Dan artikel pada awalnya Sekilas membaca misterius sedikit. Tapi kata ini, perangkat lunak kerentanan di Boeing baru 787 Dreamliner jet memiliki potensi untuk menyebabkan pilot kehilangan kontrol pesawat, mungkin pada pertengahan penerbangan, pejabat FAA Maskapai penerbangan memperingatkan baru-baru ini. Itu tekad bahwa model 787 pesawat yang telah didukung terus menerus selama 248 hari bisa kehilangan semua alternating current, AC, daya listrik karena generator unit kontrol, GCUs, secara bersamaan masuk ke gagal safe mode. Ini semacam kehilangan saya. Tapi memo itu menyatakan, OK, sekarang saya punya itu, Kondisi itu disebabkan oleh perangkat lunak melawan internal untuk kontrol Generator unit yang akan meluap setelah 248 hari power secara berkelanjutan. Kami mengeluarkan ini melihat untuk mencegah hilangnya semua AC listrik listrik, yang dapat mengakibatkan hilangnya kontrol pesawat. 

Jadi, secara harfiah, ada beberapa integer, atau beberapa jenis data yang setara, yang digunakan dalam perangkat lunak dalam sebuah pesawat yang sebenarnya bahwa jika Anda tetap pesawat Anda cukup lama, yang tampaknya dapat terjadi jika Anda hanya berjalan mereka terus-menerus dan tidak pernah mencabut pesawat Anda, tampaknya, atau membiarkan baterai yang mati, akhirnya akan menghitung, dan atas, dan atas, dan atas, dan atas, dan atas. 

Dan, oleh alam, jumlah terbatas memori akan meluap, bergulir kembali ke nol atau beberapa nilai negatif, efek samping dari yang merupakan realitas menakutkan nyata bahwa pesawat mungkin perlu untuk reboot, efektif, atau mungkin jatuh, lebih buruk, seperti lalat. Jadi jenis masalah masih dengan kami, even-- ini adalah sebuah artikel 2015, semua lebih menakutkan ketika Anda tidak selalu memahami, menghargai, atau mengantisipasi orang-orang macam kesalahan. 

Jadi ternyata ada satu lainnya hal yang buruk tentang representasi data. Ternyata bahkan mengapung jenis cacat, karena mengapung, juga, Aku diusulkan 32 bit, atau mungkin 64 jika Anda menggunakan ganda. Tapi itu masih terbatas. 

Dan menangkap adalah bahwa jika Anda bisa menempatkan jumlah tak terbatas nomor setelah titik desimal, tidak ada cara Anda dapat mewakili semua kemungkinan angka yang kita diajarkan di kelas sekolah dapat eksis di dunia. Sebuah komputer, pada dasarnya, harus memilih subset dari angka-angka untuk mewakili akurat. 

Sekarang, komputer dapat putaran mungkin sedikit, dan dapat memungkinkan Anda untuk sekitar toko setiap nomor yang Anda mungkin mungkin ingin. Tapi secara intuitif, jika Anda memiliki jumlah terbatas bit, Anda hanya dapat mengubah urutan mereka dalam banyak cara yang terbatas. Jadi Anda tidak bisa mungkin menggunakan jumlah terbatas permutasi bit, pola nol dan satu, untuk mewakili terbatas jumlah angka, yang menunjukkan bahwa komputer mungkin sangat baik menjadi berbohong kepada kami kadang-kadang. 

Bahkan, mari kita lakukan ini. Biarkan aku kembali ke CS50 IDE. Biarkan aku pergi ke depan dan membuat program kecil disebut ketidaktepatan, untuk menunjukkan bahwa komputer, memang, tidak tepat. 

Dan biarkan aku pergi ke depan dan mulai dengan beberapa kode yang dari sebelumnya, dan sekarang hanya melakukan hal berikut. Biarkan aku pergi ke depan dan melakukan printf, persen f, backslash n, 1 dibagi dengan 10. Dengan kata lain, mari kita menyelam lebih dalam untuk 1/10, seperti 1 dan dibagi dengan 10. Tentunya, komputer dapat mewakili 1/10. 

Jadi mari kita pergi ke depan dan membuat ketidaktepatan. Ayo lihat. Format menentukan tipe double. Tetapi argumen memiliki tipe int. Apa yang sedang terjadi? 

Oh, menarik, jadi itu adalah pelajaran dari sebelumnya. Saya mengatakan, hei, komputer menunjukkan saya pelampung dengan persen f. Tapi aku memberikannya 2 int. Jadi ternyata, saya bisa memperbaiki ini dalam beberapa cara. 

Aku hanya bisa mengubah satu ke 1.0, dan 10 menjadi 10,0, yang akan, memang, memiliki efek mengkonversi mereka ke floats-- masih mudah-mudahan nomor yang sama. Atau ternyata ada sesuatu kita akan melihat lagi sebelum lama. Anda bisa cast angka. 

Anda dapat, menggunakan tanda kurung ini ekspresi, Anda bisa mengatakan, hey, komputer, mengambil ini 10, yang saya tahu adalah int. Tapi mengobatinya, silahkan, seolah-olah itu pelampung. Tapi ini terasa tidak perlu kompleks. 

Untuk tujuan kita hari ini, mari kita secara harfiah membuat mereka nilai floating point dengan titik desimal, seperti ini. Biarkan aku pergi ke depan dan jalankan kembali, membuat ketidaktepatan, baik, dot slash ketidaktepatan, masukkan. OK, kita cari yang baik. 

1 dibagi dengan 10, menurut saya Mac sini, adalah, memang, 0,100000. Sekarang, saya diajarkan di sekolah dasar ada harus jumlah tak terbatas 0 ini. Jadi mari kita setidaknya mencoba untuk melihat beberapa dari mereka. Ternyata printf sedikit masih lebih menarik daripada kita telah menggunakan. Ternyata Anda tidak harus menentukan hanya persen f, atau hanya persen i. Anda benar-benar dapat menentukan beberapa pilihan kontrol di sini. 

Secara khusus, saya akan mengatakan, hei, printf, benar-benar menunjukkan 10 poin desimal. Sehingga terlihat sedikit aneh. Tapi Anda katakan persen, dot, berapa banyak angka Anda ingin melihat setelah titik desimal, dan kemudian f untuk datar, hanya karena itu apa yang dikatakan dokumentasi. Biarkan aku pergi ke depan dan menyelamatkan. 

Dan perhatikan juga, saya mendapatkan lelah mengetik ulang hal. Jadi aku hanya menyiapkan dan panah ke bawah pada tombol saya di sini. Dan jika saya tetap memukul sampai, Anda bisa melihat semua perintah yang saya buat, atau salah dibuat. 

Dan aku akan pergi ke depan sekarang dan tidak benar-benar menggunakan itu, rupanya. Membuat ketidaktepatan, dot slash imprecision-- sehingga apa yang saya diajarkan di sekolah dasar check out. Bahkan jika saya mencetak ke 10 desimal menempatkannya, memang, adalah 0,10000. Tapi kau tahu apa? 

Mari kita sedikit serakah. Katakanlah, seperti, menunjukkan 55 menunjuk setelah desimal. Mari kita benar-benar mengambil ini memprogram keluar untuk spin. Mari saya remake dengan make ketidaktepatan, dot slash, ketidaktepatan. 

Dan di sini kita pergi. masa kecil Anda adalah bohong. Rupanya, 1 dibagi dengan 10 memang 0.100000000000000005551115123-- 

Apa yang terjadi? Nah, ternyata, jika Anda jenis melihat cukup jauh di dasar representasi ini jumlah, itu benar-benar tidak persis 1/10, atau 0,1 dan jumlah tak terbatas nol. Sekarang, kenapa begitu? 

Nah, meskipun ini adalah sederhana nomor untuk kita manusia, 1 dibagi dengan 10, itu masih salah satu tak terhingga banyak angka yang kita bisa memikirkan. Tapi komputer hanya dapat mewakili finitely banyak nomor jadi. Dan, efektif, apa yang komputer menunjukkan kita adalah terdekatnya pendekatan ke nomor kita ingin percaya adalah 1/10, atau benar-benar 0,10000 tak terhingga. 

Sebaliknya, meskipun, ini adalah sedekat itu bisa. Dan, memang, jika Anda melihat di bawah kap mesin, seperti kita di sini dengan melihat 55 digit setelah desimal, kita benar-benar melihat kenyataan itu. Sekarang sebagai samping, jika Anda sudah pernah melihat movie-- sebagian besar dari Anda mungkin haven't-- tapi Superman 3 beberapa tahun yang lalu, Richard Pryor dasarnya memanfaatkan ini kenyataan di perusahaannya untuk mencuri banyak dari fraksi dan fraksi uang, karena company-- seperti yang saya ingat, itu sudah while-- pada dasarnya membuang sesuatu yang tidak cocok ke dalam gagasan sen. 

Tetapi jika Anda menambahkan semua ini kecil, kecil, angka kecil lagi, dan lagi, dan lagi, Anda bisa, seperti di kasusnya, membuat jumlah uang yang baik. 

Itu ide yang sama merobek oleh lebih baru-baru ini, tapi masih sekarang lebih tua Film, yang disebut Office Space, di mana orang-orang di film itu, melakukan hal yang sama, mengacaukannya benar, berakhir dengan terlalu banyak uang di rekening bank mereka. Itu semua sangat mencurigakan. Tetapi pada akhir hari, ketidaktepatan ada di sekitar kita. 

Dan itu juga, bisa menakutkan kasus ini. Ternyata Superman 3 dan Office Space samping, ada dapat beberapa yang sangat nyata konsekuensi dunia dari realitas tidak tepat representasi data bahkan kita manusia untuk hari ini belum tentu memahami serta kita harus, atau mengingat sesering kita harus. Dan, memang, klip berikut ini dari melihat beberapa dunia yang sangat nyata konsekuensi dari apa yang terjadi jika Anda tidak menghargai ketidaktepatan yang dapat terjadi dalam representasi angka. 

[VIDEO PEMUTARAN] 

-Computers, Kita semua datang untuk menerima masalah yang sering frustasi yang pergi dengan mengujinya-- bug, virus, dan gangguan perangkat lunak, untuk harga kecil untuk membayar untuk kenyamanan. Namun dalam teknologi tinggi dan kecepatan tinggi militer dan program ruang aplikasi, masalah terkecil bisa diperbesar menjadi bencana. 

Pada 4 Juni 1996, para ilmuwan disiapkan untuk meluncurkan berawak Ariane 5 roket. Hal itu membawa ilmiah satelit dirancang untuk menetapkan secara tepat bagaimana berinteraksi medan magnet bumi dengan angin surya. Roket ini dibangun untuk European Space Agency, dan lepas landas dari fasilitas yang di pantai Guyana Prancis. 

-Pada Sekitar 37 detik ke penerbangan, mereka pertama kali melihat sesuatu yang tidak beres. Nozel yang berputar di cara mereka benar-benar tidak seharusnya. Sekitar 40 detik ke penerbangan, jelas, kendaraan itu dalam kesulitan. 

Dan saat itulah mereka membuat keputusan untuk menghancurkannya. Kisaran petugas keamanan, dengan nyali yang luar biasa, menekan tombol, meledakkan roket, sebelum bisa menjadi bahaya bagi keselamatan publik. 

-ini Adalah gadis yang pelayaran dari Ariane 5. Dan kehancuran mengambil menempatkan karena cacat tertanam dalam perangkat lunak roket. -Masalah pada Ariane adalah bahwa ada nomor yang diperlukan 64 bit untuk mengekspresikan. Dan mereka ingin mengkonversi ke nomor 16-bit. Mereka beranggapan bahwa Jumlah itu tidak akan menjadi sangat besar, yang sebagian besar dari mereka digit di sejumlah 64-bit yang nol. Mereka salah. 

-The Ketidakmampuan satu program perangkat lunak untuk menerima jenis nomor yang dihasilkan oleh lain adalah akar dari kegagalan. pengembangan perangkat lunak telah menjadi sangat mahal bagian dari teknologi baru. Roket Ariane telah sangat sukses, begitu banyak perangkat lunak diciptakan untuk itu juga digunakan dalam Ariane 5. 

-Masalah dasar adalah bahwa Ariane 5 lebih cepat, dipercepat lebih cepat. Dan perangkat lunak belum menyumbang untuk itu. 

-The Penghancuran roket adalah bencana keuangan yang besar, semua karena kesalahan software menit. Tapi ini bukan yang pertama masalah konversi data waktu telah melanda teknologi roket modern. 

-Dalam 1991, dengan awal Perang Teluk pertama, Patriot Missile mengalami serupa dari masalah nomor konversi. Dan sebagai hasilnya, 28 orang, 28 tentara Amerika, tewas, dan sekitar 100 lainnya luka-luka, ketika Patriot, yang seharusnya untuk melindungi terhadap Scud masuk, gagal menembakkan rudal. 

-Ketika Irak menginvasi Kuwait, dan Amerika diluncurkan Desert Storm di awal 1991, baterai Patriot Missile dikerahkan untuk melindungi Arab Saudi dan Israel dari serangan rudal Scud Irak. The Patriot adalah jarak menengah AS permukaan ke sistem udara, diproduksi oleh perusahaan Raytheon. 

-The Ukuran pencegat Patriot itu sendiri panjang sekitar kira-kira 20 kaki. Dan beratnya sekitar 2.000 pound. Dan itu membawa hulu ledak sekitar, Saya pikir itu sekitar 150 pound. Dan hulu ledak itu sendiri ledak tinggi, yang memiliki fragmen sekitarnya. Casing hulu ledak adalah dirancang untuk bertindak seperti gotri. 

rudal -The dilakukan empat per kontainer, dan diangkut oleh semi trailer. 

-Sistem Patriot anti-rudal kembali setidaknya 20 tahun sekarang. Ini pada awalnya dirancang sebagai rudal pertahanan udara untuk menembak jatuh pesawat musuh. Dalam Perang Teluk pertama, ketika perang itu datang, Tentara ingin menggunakannya untuk menembak jatuh rudal Scud, bukan pesawat terbang. 

Angkatan Udara Irak tidak begitu banyak masalah. Tapi Angkatan Darat khawatir tentang Scud. Dan mereka mencoba untuk upgrade Patriot. 

-Intercepting Musuh rudal bepergian di mach 5 itu akan cukup menantang. Tetapi ketika Patriot dilarikan ke layanan, Angkatan Darat tidak menyadari sebuah modifikasi Irak yang membuat Scud mereka hampir mustahil untuk memukul. 

-Apa Yang terjadi adalah Scud yang yang datang tidak stabil. Mereka bergoyang-goyang. Alasan untuk ini adalah Irak, dalam rangka untuk mendapatkan 600 kilometer dari 300 kilometer rudal jarak, mengambil berat badan keluar dari hulu ledak depan. Mereka membuat hulu ledak ringan. 

Jadi sekarang Patriot adalah mencoba untuk datang di Scud. Dan sebagian besar waktu, mayoritas waktu, itu hanya akan terbang oleh Scud. Setelah operator sistem Patriot menyadari Patriot terjawab target, mereka meledakkan hulu ledak Patriot untuk menghindari kemungkinan korban jika diizinkan untuk jatuh ke tanah. 

-Itu Adalah apa yang kebanyakan orang melihat, mereka bola api besar di langit, dan disalahpahami sebagai penyadapan hulu ledak Scud. 

-Meskipun Di malam hari langit, Patriots muncul menjadi sukses menghancurkan Scud, di Dhahran, mungkin ada kesalahan tentang kinerjanya. Ada, sistem radar Patriot kehilangan jejak dari Scud masuk, dan tidak pernah diluncurkan karena untuk cacat software. Itu adalah Israel yang pertama kali ditemukan bahwa semakin lama sistem itu pada, semakin besar waktu perbedaan menjadi, karena jam tertanam di komputer sistem. 

-Tentang Dua minggu sebelum tragedi di Dhahran, Israel dilaporkan Departemen Pertahanan bahwa sistem itu kehilangan waktu. Setelah sekitar delapan jam atau berjalan, mereka melihat bahwa sistem itu menjadi terasa kurang akurat. Departemen Pertahanan menanggapi dengan memberitahu semua baterai Patriot untuk tidak meninggalkan sistem untuk waktu yang lama. Mereka tidak pernah mengatakan apa lama was-- delapan jam, 10 jam, 1.000 jam. Tak ada yang tahu. 

-The Baterai Patriot ditempatkan di barak di Dhahran dan cacat internal Jam sudah di lebih dari 100 jam pada malam 25 Februari. 

-itu Dilacak waktu dengan akurasi dari sekitar sepersepuluh detik. Sekarang, sepersepuluh detik adalah angka yang menarik, karena tidak bisa diungkapkan dalam biner persis, yang berarti itu tidak bisa diungkapkan dengan tepat di setiap komputer digital modern. Sulit untuk percaya. 

Tetapi menggunakan ini sebagai contoh. Mari kita nomor satu ketiga. Sepertiga tidak bisa dinyatakan dalam desimal persis. Sepertiga adalah 0,333 berlangsung selama tak terhingga. 

Tidak ada cara untuk melakukan itu dengan akurasi mutlak dalam desimal. Itulah jenis masalah yang terjadi di Patriot. Semakin lama sistem berlari, yang buruk kesalahan waktu menjadi. 

-Setelah 100 jam operasi, kesalahan dalam waktu hanya sekitar sepertiga detik. Tapi dalam hal menargetkan rudal bepergian di mach 5, itu mengakibatkan pelacakan sebuah error lebih dari 600 meter. Ini akan menjadi kesalahan fatal bagi para prajurit pada apa terjadi adalah peluncuran Scud itu terdeteksi oleh satelit Peringatan dini dan mereka tahu bahwa Scud itu datang ke arah umum mereka. Mereka tidak tahu di mana itu berasal. 

-itu Sekarang hingga radar komponen dari sistem Patriot membela Dhahran untuk mencari dan menjaga melacak rudal musuh masuk. 

radar -The sangat cerdas. Ini benar-benar akan melacak posisi Scud, dan kemudian memprediksi mana mungkin akan menjadi waktu berikutnya radar mengirim sebuah pulsa keluar. Yang disebut gerbang jangkauan. 

-Lalu, Setelah Patriot memutuskan waktu yang cukup memiliki berlalu untuk kembali dan memeriksa berikutnya lokasi untuk objek yang terdeteksi ini, itu akan kembali. Jadi ketika kembali ke salah tempat, kemudian melihat ada objek. Dan memutuskan bahwa tidak ada objek, itu adalah deteksi palsu, dan tetes trek. 

-The Masuk Scud menghilang dari layar radar. Dan beberapa detik kemudian, itu terhempas ke barak. Scud menewaskan 28, dan yang terakhir satu dipecat selama Perang Teluk pertama. 

Tragisnya, perangkat lunak diperbarui tiba di Dhahran hari berikutnya. Cacat software memiliki pernah tetap, penutupan salah satu bab dalam bermasalah sejarah rudal Patriot. 

[VIDEO PEMUTARAN] DAVID J. Malan: Jadi ini semua untuk mengatakan bahwa masalah ini overflow dan ketidaktepatan yang terlalu nyata. Jadi bagaimana kita sampai di sini? Kami mulai dengan hanya berbicara tentang printf. Sekali lagi, fungsi ini yang mencetak sesuatu ke layar, dan kami memperkenalkan sesudahnya beberapa fungsi lain dari apa yang disebut perpustakaan CS50 ini. Dan kami akan terus melihat ini pada waktunya. Dan kita, khususnya, digunakan get string, dan int, dan sekarang juga mendapatkan float, dan yang lain masih akan kita temui dan menggunakan diri sendiri sebelum lama. 

Tapi pada kesempatan, memiliki kita sudah melihat kebutuhan untuk menyimpan apa tangan fungsi-fungsi kembali? Mereka menyerahkan kami kembali string, atau int, atau pelampung. Dan kadang-kadang kita perlu menempatkan bahwa string, atau int, atau float, di suatu tempat. 

Dan untuk menyimpan hal-hal, ingat hanya seperti di Scratch, kita memiliki variabel. Tapi tidak seperti di Scratch, di C kita memiliki jenis yang sebenarnya data variables-- jenis, lebih generally-- di antara mereka, string, int, sebuah mengapung, dan ini lain masih. 

Dan ketika kita mendeklarasikan variabel di C, kita harus mendeklarasikan tipe data kami. Ini bukan sesuatu yang kita akan harus lakukan nanti di semester seperti yang kita transisi ke bahasa lain. Tapi untuk saat ini, kita perlu untuk a priori di muka, menjelaskan ke komputer jenis variabel kita ingin memberi kita. 

Sekarang, sementara itu, untuk mencetak orang-orang macam jenis data, kita harus memberitahu printf apa yang diharapkan. Dan kami melihat persen s untuk string, dan persen saya untuk bilangan bulat, dan beberapa orang lainnya sudah. Dan orang-orang yang hanya persyaratan untuk presentasi visual informasi tersebut. 

Dan masing-masing benar-benar dapat parametrized atau tweak dalam beberapa cara, jika Anda ingin lebih lanjut kontrol jenis output yang Anda dapatkan. Dan, pada kenyataannya, ternyata tidak hanya ada backslash n untuk baris baru. Ada sesuatu yang lain yang disebut backslash r untuk carriage return, yang lebih mirip dengan sebuah mesin tik sekolah tua, dan juga Windows yang digunakan selama bertahun-tahun. 

Ada backslash t untuk tab. Ternyata, bahwa jika Anda ingin kutipan ganda dalam string, ingat bahwa kita telah menggunakan ganda double quote kutipan di sebelah kiri dan kanan berakhir string kami sejauh ini. Yang akan tampak membingungkan hal. 

Jika Anda ingin menempatkan kutipan ganda di tengah string-- dan, memang, itu membingungkan untuk melihat. Dan sehingga Anda harus melarikan diri, sehingga untuk berbicara, kutipan ganda dengan sesuatu seperti, secara harfiah, backslash kutip ganda. Dan ada beberapa lainnya masih. Dan kita akan melihat lebih banyak dari mereka dalam penggunaan aktual sebelum lama. 

Jadi mari kita sekarang transisi dari data, dan representasi, dan operator aritmatika, semua yang memberi kami beberapa bangunan blok dengan yang untuk bermain. Tapi sekarang mari kita benar-benar memberikan kami sisa kosa kata bahwa kita sudah memiliki minggu lalu dengan Scratch dengan melihat beberapa lainnya konstruksi di C-- tidak semua dari mereka. Tetapi ide-ide kita sekitar untuk melihat benar-benar hanya untuk menekankan terjemahan dari satu bahasa, Scratch, ke yang lain, C. 

Dan dari waktu ke waktu, kami akan mengambil alat yang lebih untuk toolkit kami, sehingga untuk berbicara, sintaksis. Dan, memang, Anda akan melihat bahwa ide-ide sekarang lebih akrab dari minggu lalu. Jadi mari kita lakukan ini. 

Mari kita pergi ke depan dan menyiapkan program yang benar-benar menggunakan beberapa ekspresi, ekspresi Boolean. Biarkan aku pergi ke depan di sini dan membuat file baru. Saya akan menelepon condition.c ini. 

Biarkan aku pergi ke depan dan termasuk perpustakaan CS50. Dan biarkan aku pergi ke depan dan mencakup standar io.h untuk fungsi kami, dan printf, dan lebih masing-masing. Biarkan saya memberi diri bahwa boilerplate dari void main int, yang penjelasan kami akan kembali ke di masa depan. 

Sekarang biarkan aku pergi ke depan dan memberikan diriku int via get int. Maka biarkan aku pergi ke depan dan melakukan hal ini. Saya ingin mengatakan jika saya adalah less-- mari membedakan antara positif, negatif, atau nilai nol. 

Jadi jika saya kurang dari nol, biarkan aku hanya memiliki program ini hanya mengatakan, negatif, backslash n, lain jika saya lebih besar dari nol. Sekarang aku, tentu saja, akan mengatakan printf positif, backslash n. Dan kemudian lain if-- aku bisa melakukan ini. 

Saya bisa lakukan jika saya sama dengan 0. Tapi aku akan membuat di Setidaknya satu kesalahan sudah. Ingat bahwa tanda sama adalah tidak sama, karena kita manusia tahu itu. 

Tapi itu operator penugasan. Dan kami tidak ingin mengambil 0 pada kanan dan meletakkannya di i di sebelah kiri. Jadi untuk menghindari kebingungan ini, atau mungkin penyalahgunaan tanda sama dengan, manusia memutuskan beberapa tahun yang lalu bahwa dalam banyak bahasa pemrograman ketika Anda ingin memeriksa kesetaraan antara kiri dan kanan, Anda benar-benar menggunakan sama sederajat. Jadi anda menekan tanda sama dengan dua kali. Bila Anda ingin menetapkan dari kanan ke kiri, Anda menggunakan tanda sama tunggal. Sehingga kita bisa melakukan ini-- lain jika saya sama sama dengan nol. 

Saya kemudian bisa pergi dan membuka kurung kurawal saya, dan mengatakan, printf 0, backslash n, dilakukan. Tapi ingat bagaimana garpu di jalan dapat bekerja. Dan, benar-benar, hanya berpikir tentang logika. i adalah nomor. Ini integer, khususnya. Dan itu berarti itu akan menjadi kurang dari 0, atau lebih besar dari 0, atau 0. Jadi ada semacam ini default kasus tersirat. 

Dan jadi kami bisa, sama seperti Scratch, membuang dengan lain jika, dan hanya mengatakan lain. Logikanya, jika Anda programmer tahu hanya ada tiga ember ke mana Skenario dapat fall-- pertama, kedua, atau ketiga dalam hal ini case-- tidak repot-repot menambahkan presisi tambahan dan tambahan logika ada. Langsung saja dengan kasus default di sini dari yang lain. 

Sekarang, mari kita pergi ke depan setelah menyimpan ini, membuat kondisi dot slash conditions-- tidak antarmuka pengguna yang luar biasa, karena aku tidak mendorong pengguna, seperti yang saya sebutkan sebelumnya. Tapi itu baik-baik saja. Kami akan tetap sederhana. Mari kita coba nomor 42. Dan itu positif. Mari kita coba nomor negatif 42, negatif. 

Mari kita coba nilai 0. Dan, memang, ia bekerja. Sekarang, Anda akan melihat dengan masalah sebelum panjang, pengujian hal tiga kali, mungkin tidak cukup. Anda mungkin ingin menguji beberapa angka yang lebih besar, beberapa lebih kecil angka, beberapa kasus sudut, sebagai kami akan datang untuk menggambarkan mereka. 

Tetapi untuk sekarang, ini adalah program yang cukup sederhana. Dan aku cukup yakin, secara logis, yang jatuh ke dalam tiga kasus. Dan, memang, meskipun kami hanya difokuskan pada kerugian potensial ketidaktepatan dan melimpah, di realitas di mana banyak masalah CS50 ini, kita tidak akan khawatir tentang, sepanjang waktu, isu-isu overflow dan ketidaktepatan, karena, pada kenyataannya, di C, itu sebenarnya tidak semua yang mudah untuk menghindari hal-hal. Jika Anda ingin menghitung lebih besar, dan lebih besar, dan lebih besar, ternyata ada teknik Anda dapat digunakan, sering melibatkan hal-hal yang disebut perpustakaan, koleksi kode, yang orang lain menulis bahwa Anda dapat menggunakan, dan bahasa lainnya seperti Java dan lain-lain, sebenarnya membuatnya jauh lebih mudah untuk menghitung lebih tinggi. Sehingga benar-benar beberapa bahaya ini fungsi dari bahasa yang Anda gunakan. Dan dalam beberapa minggu mendatang, kami akan melihat bagaimana berbahaya C benar dapat jika Anda tidak menggunakannya dengan benar. Tapi dari sana, dan dengan Python, dan JavaScript, akan kami lapisan pada beberapa perlindungan tambahan, dan menjalankan lebih sedikit dari risiko tersebut. 

Jadi mari kita membuat sedikit lebih logika menarik dalam program kami. Jadi biarkan aku pergi ke depan dan menciptakan sebuah program yang disebut Logical hanya jadi saya bisa bermain dengan beberapa logika yang sebenarnya, logical.c. Saya hanya akan copy dan paste beberapa kode dari sebelumnya sehingga aku kembali untuk titik awal yang bagus ini. 

Mari saya kali ini dilakukan arang C. Saya akan memberikan nama C hanya karena konvensional, mendapatkan karakter dari pengguna. Dan mari kita berpura-pura seperti Aku menerapkan bagian dari program Rm, hapus yang Program sebelum itu diminta pengguna untuk menghapus file. Bagaimana kita bisa melakukan ini? 

Saya ingin mengatakan, jika C sama sama, kutipan tanda kutip, y, maka aku akan menganggap bahwa pengguna telah memilih ya. Aku hanya akan mencetak ya. Jika itu benar-benar menulis program penghapusan, kita bisa menghapus file dengan garis lebih dari kode. Tapi kita akan tetap sederhana. 

Lain jika c sama sama n-- dan sekarang di sini, aku akan mengatakan, pengguna harus berarti tidak ada. Dan kemudian lain, Anda tahu apa? Aku tidak tahu apa lagi pengguna akan mengetik. Jadi aku hanya akan mengatakan bahwa yang merupakan kesalahan, apa pun ia benar-benar mengetik. 

Jadi apa yang terjadi di sini? Ada perbedaan mendasar versus apa yang saya lakukan di masa lalu. tanda kutip ganda, tanda kutip ganda, ganda kutipan, dan, namun, tanda kutip tunggal, tanda kutip tunggal. Ternyata di C, bahwa ketika Anda ingin menulis string, Anda menggunakan tanda kutip ganda, seperti yang kita sudah telah menggunakan semua kali ini dengan printf. 

Tetapi jika Anda ingin berurusan dengan hanya karakter tunggal, yang disebut char, maka Anda benar-benar menggunakan tanda kutip tunggal. Bagi Anda yang sudah diprogram sebelumnya, Anda mungkin tidak memiliki harus khawatir tentang hal ini Perbedaan dalam bahasa tertentu. Dalam C, itu tidak masalah. Dan ketika saya mendapatkan char dan saya ingin untuk membandingkan char yang menggunakan equals sama dengan beberapa surat seperti y atau n, saya lakukan, memang, harus memiliki tanda kutip tunggal. 

Sekarang, mari kita pergi ke depan dan melakukan hal ini. Mari kita pergi ke depan dan jangan membuat dot logis memangkas logis. Dan sekarang aku sedang diminta. Jadi, mungkin, pengalaman pengguna yang lebih baik akan benar-benar tahu apa yang harus dilakukan di sini. Tapi aku akan hanya membabi buta mengatakan y untuk yes, OK, baik. 

Mari kita jalankan lagi, n tanpa, bagus. Misalkan seperti orang-orang tertentu yang saya tahu, caps saya lock pada semua terlalu sering. Jadi saya lakukan modal Y, masukkan, kesalahan. OK, itu tidak persis apa yang saya harapkan. Memang, komputer adalah melakukan harfiah apa Aku bilang ke do-- memeriksa huruf kecil y dan huruf kecil n. Ini tidak merasa seperti yang baik pengalaman pengguna, meskipun. Mari saya meminta dan menerima kedua kasus lebih rendah atau huruf. Jadi ternyata, Anda mungkin ingin mengatakan sesuatu seperti di Scratch, seperti harfiah atau C sama sama modal tunggal dikutip y. Ternyata, C tidak memiliki kata kunci literal atau. 

Tetapi memiliki dua bar vertikal. Anda harus menahan Shift biasanya, jika Anda menggunakan keyboard US, dan memukul bar vertikal kunci di atas kunci Anda kembali. Tapi bar vertikal ini bar vertikal berarti atau. 

Jika, sebaliknya, kita ingin mengatakan dan, seperti di Scratch, kita bisa melakukan ampersand ampersand. Itu tidak masuk akal logis di sini, karena manusia tidak mungkin bisa telah diketik baik y dan huruf kecil y dan modal Y sebagai karakter yang sama. Jadi atau itulah yang akan kita di sini. 

Jadi jika saya melakukan ini di kedua tempat, atau c sama equals modal N, sekarang jalankan, membuat logis, jalankan kembali logis. Sekarang, saya bisa mengetik y. Dan saya bisa melakukannya lagi dengan modal Y, atau N. modal Dan saya bisa menambahkan tambahan kombinasi masih. 

Jadi ini adalah logis Program sejauh sekarang Aku memeriksa secara logis untuk nilai ini atau nilai ini. Dan saya tidak perlu, tentu, datang dengan dua ifs lebih atau yang lain seandainya. Aku benar-benar dapat menggabungkan beberapa logika terkait bersama-sama dengan cara ini. Jadi ini akan menjadi lebih baik dirancang dari sekedar mengatakan, jika C sama dengan huruf kecil y, mencetak ya, lain jika c sama modal Y, mencetak ya, lain jika c sama lower-- dengan kata lain, Anda tidak harus memiliki semakin banyak cabang. Anda dapat menggabungkan beberapa setara cabang logis, karena dengan cara ini. 

Jadi mari kita lihat hanya satu bahan akhir, satu konstruk akhir, bahwa C memungkinkan. Dan kami akan kembali di masa depan kepada orang lain masih. Dan kemudian kita akan menyimpulkan dengan melihat di tidak kebenaran code-- mendapatkan kode untuk work-- tetapi desain kode, dan menanam benih awal. 

Jadi biarkan aku pergi ke depan dan membuka file baru di sini. Kamu tahu apa? Aku akan kembali melaksanakan program yang sama, tetapi menggunakan konstruksi yang berbeda. 

Jadi biar cepat memberi diriku Akses untuk menyertakan CS50.h untuk perpustakaan CS50, standar io.h untuk printf. Beri aku void main saya int. Dan kemudian di sini, biarkan saya pergi ke depan dan melakukan hal ini. 

Char c mendapat dapatkan char, seperti sebelumnya. Dan aku akan menggunakan konstruksi baru sekarang-- beralih, pada karakter apa? Jadi switch adalah jenis seperti beralih kereta rel. Atau, benar-benar, itu adalah jenis sebuah jika lain, jika lain jika, tapi ditulis agak berbeda. 

Sebuah switch terlihat seperti ini. Anda memiliki switch, dan kemudian apa karakter atau nomor yang ingin melihat, kemudian beberapa kurung kurawal seperti di Scratch, hanya mengatakan melakukan hal ini. Dan kemudian Anda memiliki kasus yang berbeda. 

Anda tidak menggunakan jika dan lain. Anda benar-benar menggunakan kasus kata. Dan Anda akan mengatakan sesuatu seperti ini. 

Jadi dalam kasus huruf kecil y, atau dalam kasus modal Y, pergi ke depan dan mencetak ya. Dan kemudian keluar dari switch. Itu dia. Dilakukan. 

Lain jika, sehingga untuk berbicara, kasus n lebih rendah, atau modal N, kemudian pergi ke depan dan mencetak out ada, dan kemudian istirahat. Else-- dan jenis adalah kasus default indeed-- printf error-- dan hanya untuk mengukur baik, meskipun logis istirahat ini tidak diperlukan karena kita berada di akhir switch pula, Sekarang saya melanggar keluar dari switch. Jadi ini terlihat sedikit berbeda. 

Tapi, secara logis, itu sebenarnya setara. Dan mengapa Anda akan menggunakan satu atas yang lain? Kadang-kadang, hanya preferensi pribadi, kadang-kadang estetika, jika saya melirik ini sekarang, ada sesuatu yang bisa dikatakan untuk pembacaan kode ini. Maksudku, apalagi fakta bahwa ini kode baru untuk banyak dari kita di dalam ruangan. 

Tapi itu hanya semacam cukup. Anda melihat huruf kecil y, modal Y, kasus n lebih rendah, modal N default, itu hanya jenis melompat keluar pada Anda dengan cara itu, bisa dibilang, mungkin contoh sebelumnya dengan ifs, dan bar vertikal, dan seandainya pun, mungkin tidak memiliki. Jadi ini benar-benar masalah pribadi pilihan, benar-benar, atau mudah dibaca, kode. 

Tapi dalam hal fungsi, biarkan aku pergi ke depan dan membuat switch, dot slash switch, dan sekarang ketik huruf kecil y, modal Y, huruf kecil n, modal N, David, coba lagi karena itulah tidak satu karakter. Mari kita lakukan x, kesalahan, seperti yang diharapkan. Dan, logically-- dan ini adalah sesuatu Saya akan mendorong di general-- bahkan meskipun kita hanya menggaruk permukaan beberapa fitur ini. 

Dan itu mungkin tidak jelas ketika Anda sendiri duduk di keyboard, bagaimana ini bekerja? Apa yang akan dilakukan? Hal yang indah tentang memiliki laptop, atau desktop, atau akses untuk komputer dengan kompilator, dan dengan editor kode seperti ini, adalah Anda hampir selalu dapat menjawab ini pertanyaan untuk diri sendiri hanya dengan mencoba. 

Misalnya, jika retoris Pertanyaan di tangan yang, apa yang terjadi jika Anda lupa laporan istirahat Anda? Yang sebenarnya merupakan sangat umum hal yang harus dilakukan, karena tidak terlihat seperti Anda benar-benar membutuhkannya. Mereka tidak benar-benar menyelesaikan Anda berpikir seperti kurung atau keriting a brace tidak. Mari kita pergi ke depan dan mengkompilasi ulang kode dan melihat. Sehingga membuat switch, dot slash switch. Mari kita ketik dalam huruf kecil y, kasus atas, Enter. Jadi saya mengetik y. 

Program ini mengatakan ya, tidak, kesalahan, seolah-olah itu berubah pikiran. Tapi itu semacam itu, karena apa yang terjadi dengan switch adalah kasus pertama yang Pertandingan dasarnya berarti, hey komputer, mengeksekusi semua kode di bawahnya. Dan jika Anda tidak mengatakan istirahat, atau tidak mengatakan istirahat, atau tidak mengatakan istirahat, komputer akan meniup melalui semua garis dan mengeksekusi semua dari mereka sampai itu sampai ke yang brace keriting. Jadi rem, memang, diperlukan. Tapi takeaway di sini adalah, ketika ragu, mencoba sesuatu. Mungkin menyimpan kode Anda pertama, atau menyimpannya dalam sebuah file tambahan jika Anda benar-benar khawatir tentang mengacaukan dan harus memulihkan pekerjaan yang Anda tahu bekerja. 

Tapi mencoba hal. Dan jangan menjadi seperti takut, mungkin, dari apa yang mungkin dilakukan komputer, atau bahwa Anda mungkin memecahkan sesuatu. Anda dapat selalu kembali beberapa versi sebelumnya. 

Jadi mari kita berakhir dengan melihat di desain kode. Kami memiliki kemampuan ini sekarang untuk menulis kondisi, dan menulis loop, dan variabel, dan fungsi panggilan. Jadi, terus terang, kami agak kembali di mana kami seminggu yang lalu dengan Scratch, meskipun dengan tekstual kurang menarik lingkungan daripada Scratch memungkinkan. 

Tapi perhatikan seberapa cepat kita sudah mengakuisisi bahwa kosakata, bahkan jika itu akan mengambil sedikit waktu untuk meresap, sehingga kita sekarang dapat menggunakan kosakata ini untuk menulis program yang lebih menarik. Dan mari kita mengambil langkah bayi arah itu, sebagai berikut. Biarkan aku pergi ke depan dan membuat file baru di sini. 

Aku akan menyebutnya prototype.c, dan memperkenalkan untuk pertama kalinya, kemampuan untuk membuat fungsi sendiri. Beberapa dari Anda mungkin memiliki melakukan ini dengan Scratch, dimana Anda dapat membuat Anda blok kustom sendiri di Scratch, dan kemudian menyeret mereka ke tempatnya di mana pun Anda ingin di C. Dan di sebagian besar pemrograman bahasa, Anda dapat melakukan hal itu-- membuat fungsi sendiri, jika mereka tidak sudah ada. 

Jadi, misalnya, biarkan aku pergi ke depan dan termasuk CS50.h, dan termasuk standar io.h, int void main. Dan sekarang kita memiliki placeholder siap untuk pergi. Saya tetap mencetak hal-hal seperti nama orang hari ini. Dan yang terasa like-- tidak akan lebih baik jika ada adalah fungsi yang disebut nama cetak? Saya tidak harus menggunakan printf. Saya tidak harus ingat semua kode format yang. Mengapa tidak saya, atau mengapa tidak seseorang sebelum saya, membuat fungsi yang disebut cetak nama, yang diberikan beberapa nama, hanya mencetak keluar? 

Dengan kata lain, jika saya mengatakan, hey, komputer, memberi saya sebuah string dengan meminta pengguna untuk seperti, melalui fungsi get tali CS50 ini. Hei, komputer, menempatkan string yang di variabel di sisi kiri, dan menyebutnya s. Dan kemudian, hey komputer, pergi ke depan dan mencetak bahwa nama orang, dilakukan. 

Sekarang, itu akan menyenangkan, karena program ini, aptly bernama, memberitahu saya apa yang seharusnya dilakukan dengan cara nama-nama fungsi ini. Biarkan aku pergi dan membuat prototipe, Enter. Dan, sayangnya, ini tidak akan terbang. 

Prototype.c, line 7, karakter 5, error, deklarasi implisit fungsi nama cetak adalah tidak sah di C99, C99 berarti versi C yang keluar pada tahun 1999. Itu saja. 

Jadi saya tidak tahu apa yang semua ini berarti belum. Tapi saya mengakui kesalahan dalam merah. Itu cukup jelas. 

Dan tampaknya bahwa dengan karakter hijau di sini, masalah ini dengan nama cetak, terbuka paren s, paren dekat, semi-kolon. Tapi deklarasi implisit fungsi kami memang melihat sebentar tadi. Ini berarti, hanya, bahwa dentang tidak tahu apa yang saya maksud. 

Saya telah menggunakan kata kosa kata yang itu pernah melihat atau telah diajarkan sebelumnya. Dan jadi saya harus mengajarkannya apa artinya fungsi ini. Jadi aku akan pergi ke depan dan melakukan itu. 

Aku akan pergi ke depan dan menerapkan fungsi sendiri disebut Cetak Nama. Dan aku akan mengatakan, sebagai berikut, bahwa hal ini ini, printf, halo, persen s, backslash n, nama, semi-kolon. Jadi apa yang saya lakukan? 

Jadi ternyata, untuk mengimplementasikan fungsi sendiri, kami jenis meminjam beberapa struktur yang sama seperti main bahwa kami baru saja berkunjung diambil untuk diberikan, dan saya tahu hanya menyalin dan menyisipkan cukup banyak apa Aku sudah menulis di masa lalu. Tapi perhatikan pola di sini. Int, Main, Void, kami akan menggoda terpisah tak lama apa yang benar-benar berarti. 

Tapi untuk saat ini, hanya melihat paralelisme. Void, nama cetak, nama string, jadi ada kata kunci ungu, yang kita akan mulai memanggil kembali jenis, nama fungsi, dan kemudian masukan. Jadi, sebenarnya, kita bisa menyaring semacam ini seperti minggu lalu seperti, ini adalah nama atau algoritma dari kode kita akan write-- yang algoritma yang mendasari kode kita akan menulis. 

Ini adalah input. Ini adalah outputnya. Fungsi ini, nama cetak, adalah dirancang untuk mengambil string disebut nama, atau apa pun, sebagai masukan, dan kemudian batal. Tidak mengembalikan apa-apa, seperti mendapatkan string atau mendapatkan int tidak. Jadi itu akan menyerahkan sesuatu kembali. Ini hanya akan memiliki efek samping, sehingga untuk berbicara, mencetak nama seseorang. Jadi perhatikan, line 7, saya dapat memanggil nama cetak. Baris 10, saya bisa mendefinisikan atau menerapkan nama cetak. Tapi, sayangnya, itu tidak cukup. 

Biarkan aku pergi ke depan dan ulang ini setelah menyimpan. Whoa, sekarang, saya telah membuat buruk, tampaknya. Deklarasi Jadi implisit nama fungsi print tidak valid. Dan, sekali lagi, masih ada lagi kesalahan. Tapi seperti yang saya memperingatkan sebelumnya, bahkan jika Anda mendapatkan kewalahan dengan, atau sedih sedikit untuk melihat begitu banyak kesalahan, fokus hanya pada pertama awalnya, karena mungkin hanya memiliki efek cascading. Jadi C, atau dentang lebih khusus, masih tidak mengenali nama cetak. 

Dan itu karena dentang, dengan desain, agak bodoh. Hanya melakukan apa yang Anda katakan untuk dilakukan. Dan hanya melakukannya dalam urutan di mana Anda kirim ke lakukan. 

Jadi saya telah didefinisikan utama di saluran empat, seperti kita sudah melakukan cukup sering. Aku telah menetapkan nama cetak on line 10. Tapi aku mencoba untuk menggunakan Nama cetak on line tujuh. 

Ini terlalu cepat, belum ada. Jadi saya bisa menjadi pintar, dan menjadi seperti, OK, jadi mari kita bermain bersama, dan bergerak nama cetak up di sini, dan kompilasi ulang. Ya Tuhan. Itu bekerja. Itu sesederhana itu. 

Tapi logika adalah persis seperti itu. Anda harus mengajarkan dentang apa adalah dengan mendefinisikan fungsi pertama. Kemudian Anda dapat menggunakannya. Tapi, terus terang, ini terasa seperti lereng licin. 

Jadi setiap kali saya menjalankan menjadi masalah, aku hanya akan menyoroti dan menyalin kode Aku menulis, memotong dan paste di sini. Dan, tentu, kita bisa merancang beberapa skenario di mana salah satu fungsi mungkin perlu menelepon lain. Dan Anda tidak bisa menempatkan setiap fungsi di atas setiap lain. 

Jadi ternyata ada ini solusi yang lebih baik. Kita bisa meninggalkan ini menjadi. Dan, terus terang, itu umumnya baik, dan nyaman, dan desain yang baik untuk menempatkan utama pertama, karena, sekali lagi, utama seperti ketika bendera hijau diklik, yaitu fungsi yang dijalankan secara default. Jadi Anda mungkin juga menempatkan itu di bagian atas file sehingga ketika Anda atau manusia lainnya melihat file Anda tahu apa yang terjadi hanya dengan membaca utama pertama. Jadi ternyata, kita bisa mengatakan dentang proaktif, hey, dentang, di saluran empat, Saya berjanji untuk melaksanakan fungsi yang disebut Cetak Nama yang mengambil nama string disebut sebagai masukan, dan hasil apa-apa, batal. Dan aku akan mendapatkan sekitar untuk menerapkan nanti. 

Di sinilah Main. Main sekarang on line 9 dapat menggunakan Cetak Nama karena dentang adalah percaya bahwa, pada akhirnya, itu akan menghadapi definisi pelaksanaan Cetak Nama. Jadi setelah menyimpan file saya, biarkan saya pergi ke depan dan membuat prototipe, terlihat baik saat ini. Dot slash, prototipe, biarkan aku pergi ke depan dan ketik nama. David, halo David, Zamila, halo Zamila, dan, memang, sekarang bekerja. 

Jadi bahan di sini adalah bahwa kita sudah membuat fungsi kustom, seperti kustom blok awal kita menyebutnya. Tapi tidak seperti Scratch mana Anda dapat hanya membuat dan mulai menggunakannya, sekarang kita harus menjadi sedikit lebih bertele-tele, dan benar-benar melatih dentang menggunakan, atau untuk mengharapkan itu. Sekarang, sebagai samping, mengapa selama ini memiliki kita telah hanya membabi buta iman termasuk CS50.h, dan termasuk standar io.h? 

Nah, ternyata, antara beberapa hal lainnya, semua itu pada mereka dot h file, yang kebetulan menjadi file. Mereka file header, sehingga untuk berbicara. Mereka masih ditulis dalam C. Tapi mereka berbagai jenis file. 

Untuk saat ini, Anda dapat cukup banyak berasumsi bahwa semua yang ada dalam diri CS50.h beberapa satu kalimat seperti ini, tidak untuk fungsi-fungsi yang disebut Cetak Nama, tapi untuk Dapatkan String, Dapatkan Mengambang, dan beberapa orang lainnya. Dan ada prototipe yang sama, satu liners, dalam io.h standar untuk printf, yang sekarang di Fungsi Cetak Nama saya sendiri. Jadi dengan kata lain, sepanjang waktu ini kita sudah saja membabi buta menyalin dan menyisipkan termasuk ini, termasuk itu, apa yang terjadi? Mereka adalah hanya semacam petunjuk untuk dentang untuk fungsi apa yang, memang, dilaksanakan, hanya tempat lain dalam file yang berbeda tempat lain pada sistem. 

Jadi kita telah menerapkan nama cetak. Itu memiliki ini efek samping dari mencetak sesuatu di layar. Tapi itu tidak benar-benar tangan saya sesuatu kembali. Bagaimana kita pergi tentang melaksanakan program yang tidak menyerahkan sesuatu kembali? 

Nah, mari kita coba ini. Biarkan aku pergi ke depan dan menerapkan file bernama return.c sehingga kami dapat menunjukkan bagaimana sesuatu Dapatkan String, atau Dapatkan Int, sebenarnya kembali sesuatu kembali ke pengguna. Mari kita pergi ke depan dan menentukan void main int. 

Dan, sekali lagi, di masa depan, kita akan menjelaskan apa yang int dan kekosongan itu sebenarnya lakukan. Tapi untuk hari ini, kita akan menerima begitu saja. Aku akan pergi ke depan dan printf, untuk pengalaman pengguna yang baik, x adalah. Dan kemudian aku akan menunggu pengguna untuk memberi saya x dengan get int. 

Dan kemudian aku akan pergi ke depan dan mencetak x ke alun-alun. Jadi, ketika Anda hanya memiliki Keyboard, orang biasa menggunakan wortel kecil simbol pada keyboard untuk mewakili ke listrik dari, atau eksponen. Jadi x kuadrat hadir i. 

Dan sekarang aku akan melakukan hal ini. Aku hanya bisa do-- apa x kuadrat? x kuadrat adalah x kali x. 

Dan kami melakukan ini beberapa waktu lalu sudah hari ini. Ini tidak merasa seperti semua yang banyak kemajuan. Kamu tahu apa? Mari kita memanfaatkan beberapa ide yang dari terakhir kali abstraksi. 

Bukankah lebih baik jika ada fungsi yang disebut persegi yang tidak tepat? Masih, pada akhir hari, apakah matematika yang sama. Tapi mari kita abstrak jauh ide taking satu nomor dikalikan dengan lain, dan hanya memberikan nama, seperti persegi nilai ini. 

Dan, dengan kata lain, di C, mari kita membuat fungsi disebut persegi yang tidak tepat. Ini akan disebut persegi. Ini akan mengambil int. Dan kami hanya akan akan menyebutnya n, secara default. 

Tapi kita bisa menyebutnya apa pun yang kita inginkan. Dan semua yang akan lakukan, secara harfiah, adalah pulang hasil n kali n. Tetapi karena itu adalah kembali sesuatu, yang adalah kata kunci dalam warna ungu kita sudah tidak pernah terlihat sebelumnya, saya, on line 11, tidak bisa hanya mengatakan kekosongan saat ini. 

Void, dalam contoh kita hanya melihat bukan nama cetak, hanya berarti, lakukan sesuatu. Tapi jangan tangan saya sesuatu kembali. Dalam hal ini, saya ingin untuk kembali n kali n, atau apa pun itu, jumlah itu. 

Jadi saya tidak bisa mengatakan, hei, komputer, Aku kembali apa-apa, batal. Ini akan kembali, oleh alam, int. Dan itulah yang terjadi di sini. 

input untuk persegi akan menjadi int. Dan sehingga kita dapat menggunakannya, itu harus memiliki nama, N. Ini akan keluaran int yang tidak perlu nama. Kita bisa meninggalkannya to main, atau siapa pun menggunakan saya untuk mengingat nilai ini jika kita inginkan dengan variabel sendiri. 

Dan, sekali lagi, satu-satunya yang baru kata kunci di sini adalah Return. Dan aku hanya melakukan beberapa matematika. Jika aku benar-benar ingin menjadi tidak perlu, Saya bisa mengatakan int produk mendapat n kali n. 

Dan kemudian saya bisa mengatakan, produk kembali. Tapi, sekali lagi, ke titik awal ini hanya tidak menjadi design-- baik seperti, mengapa memperkenalkan nama, simbol, seperti produk, hanya untuk segera mengembalikannya? Ini sedikit lebih bersih, sedikit lebih ketat, sehingga untuk berbicara, hanya untuk mengatakan pulang n kali n, menyingkirkan baris ini sama sekali. 

Dan itu kode hanya kurang membaca, kesempatan lebih sedikit untuk kesalahan. Dan mari kita lihat apakah ini sebenarnya sekarang bekerja. Sekarang, aku akan pergi depan dan membuat kembali. 

Uh-oh, deklarasi implisit fungsi. Saya membuat kesalahan ini sebelumnya, bukan masalah besar. Saya hanya mengetik, atau sorot dan menyalin, sama persis prototipe fungsi, atau tanda tangan, dari fungsi di sini. Atau aku bisa memindahkan seluruh fungsi. 

Tapi itu sedikit malas. Jadi kita tidak akan melakukan itu. Sekarang, biarkan saya membuat kembali lagi, dot slash pulang. 

x adalah 2. x kuadrat adalah 4. x adalah 3. x kuadrat adalah 9. Dan fungsi tampaknya sekarang untuk bekerja. Jadi apa bedanya di sini? Saya memiliki fungsi yang disebut persegi, dalam hal ini, yang saya dimasukkan ke dalam input. Dan aku kembali output. Namun, sebelumnya, jika Aku membuka contoh lainnya dari sebelumnya, yang adalah disebut prototype.c, Aku punya nama cetak, yang kembali batal, sehingga untuk berbicara, Atau kembali apa-apa, dan hanya memiliki efek samping. 

Jadi apa yang terjadi di sini? Nah, pertimbangkan fungsi mendapatkan tali untuk sesaat. Kami telah menggunakan fungsi mendapatkan tali dengan cara berikut. 

Kami telah memiliki fungsi mendapatkan string, seperti termasuk CS50.h, termasuk standar io.h, int, utama, batal. Dan kemudian setiap kali aku sudah disebut get tali sejauh ini, Aku sudah mengatakan sesuatu seperti, string s mendapat mendapatkan string, karena get string-- sebut get tali get.c-- ini sendiri mengembalikan string yang saya dapat kemudian menggunakan, dan mengatakan, halo, koma, persen s, backslash n, s. 

Jadi ini adalah contoh yang sama, benar-benar, bahwa kita punya sebelumnya. Jadi mendapatkan string yang mengembalikan nilai. Tapi beberapa saat yang lalu, tali cetak tidak mengembalikan nilai. Ini hanya memiliki efek samping. Jadi ini adalah perbedaan mendasar. Kami telah melihat yang berbeda jenis fungsi sekarang, beberapa di antaranya telah kembali nilai-nilai, beberapa di antaranya tidak. Jadi mungkin itu string, atau int, atau float. Atau mungkin itu hanya berlaku. 

Dan perbedaannya adalah bahwa fungsi-fungsi ini yang mendapatkan data dan mengembalikan nilai sebenarnya membawa sesuatu kembali ke meja, boleh dikatakan. Jadi mari kita pergi ke depan dan melihat satu set terakhir contoh yang memberikan arti, sekarang, dari bagaimana kita mungkin, memang, abstrak lebih baik, dan lebih baik, dan lebih baik, atau lebih, dan lebih, dan lebih, dalam rangka untuk menulis, akhirnya, kode yang lebih baik. Mari kita pergi ke depan, dan dalam roh dari Scratch, lakukan langkah berikut. 

Biarkan aku pergi ke depan dan mencakup CS50.h dan standar IO.h. Biarkan aku pergi ke depan dan memberikan diriku int, utama, batal. Dan biarkan aku pergi ke depan, sebut cough.c ini. 

Dan biarkan aku pergi ke depan dan hanya seperti Scratch, mencetak batuk / n. Dan saya ingin melakukan ini tiga kali. Jadi aku, tentu saja, hanya akan copy dan paste tiga kali. Sekarang saya akan membuat batuk slash batuk dot. Mari kita memberi diriku sedikit lebih banyak ruang di sini, Masukkan, batuk, batuk, batuk. 

Ada, jelas, sudah menjadi kesempatan untuk perbaikan. Aku sudah disalin dan disisipkan beberapa kali hari ini. Tapi itu hanya jadi saya tidak harus mengetik banyak karakter. Aku masih berubah apa mereka baris kode yang. 

Ketiga garis identik, yang merasa malas dan memang adalah, dan mungkin bukan pendekatan yang tepat. Jadi dengan apa bahan bisa kita memperbaiki kode ini? Kami tidak perlu copy dan paste kode. 

Dan, memang, setiap kali Anda merasa diri Anda menyalin dan paste, dan bahkan mengubah kode, kemungkinan besar ada cara yang lebih baik. Dan, memang, ada. Biarkan aku pergi ke depan dan melakukan untuk loop, meskipun sintaks mungkin tidak datang secara alami belum. 

Lakukan ini tiga kali, hanya dengan melakukan following-- yang dan saya kebetulan tahu ini dari praktik. Tapi kami memiliki sejumlah contoh sekarang. Dan Anda akan melihat secara online referensi lebih masih. 

Ini adalah sintaks pada baris 6, yang seperti Scratch yang berulang blok, ulangi berikut tiga kali. Ini ajaib kecil untuk saat ini. Tapi ini akan mendapatkan lebih banyak, dan lebih akrab. 

Dan itu akan mengulangi baris delapan tiga kali, sehingga jika saya melakukan kompilasi ulang make batuk, dot slash batuk, batuk, batuk, batuk. Masih bekerja dengan cara yang sama. Jadi itu semua baik dan bagus. Tapi itu tidak terlalu abstrak. 

Ini sangat benar. Tapi rasanya seperti ada bisa menjadi kesempatan, seperti di dunia Scratch, untuk jenis start untuk menambahkan beberapa semantik sini sehingga Saya tidak hanya memiliki beberapa untuk loop, dan fungsi yang mengatakan batuk, atau apakah batuk. Kamu tahu apa? Biarkan saya mencoba untuk menjadi sedikit lebih dingin dari itu, dan benar-benar menulis fungsi yang memiliki beberapa efek samping, menyebutnya batuk. 

Dan dibutuhkan tidak ada input, dan mengembalikan nilai sebagai output. Tapi kau tahu apa yang dilakukannya? Itu tidak printf ini--, kutipan tanda kutip, batuk. 

Dan sekarang di sini, aku akan untuk pergi ke depan dan untuk int, i mendapat nol, i kurang dari 3, i plus plus. Aku akan tidak melakukan printf, yang bisa dibilang implementasi tingkat rendah rinci. Saya tidak peduli bagaimana batuk. Saya hanya ingin menggunakan fungsi batuk. Dan aku hanya akan menelepon batuk. 

Sekarang, perhatikan dikotomi. Ketika Anda memanggil fungsi, jika Anda tidak ingin memberikan masukan, benar-benar baik-baik saja. Hanya melakukan paren terbuka, dekat paren, dan Anda sudah selesai. 

Ketika Anda mendefinisikan fungsi, atau mendeklarasikan prototipe fungsi ini, jika Anda tahu sebelumnya itu tidak akan mengambil argumen, mengatakan kekosongan pada mereka kurung sana. Dan yang membuat tertentu yang Anda tidak akan sengaja menyalahgunakannya. Biarkan aku pergi ke depan dan membuat batuk. Dan, tentu saja, saya telah melakukan kesalahan. 

Sialan, ada yang deklarasi implisit. Tapi itu baik-baik saja. Ini mudah memperbaikinya. Aku hanya perlu prototipe lebih tinggi dalam file saya daripada aku benar-benar menggunakannya. 

Jadi sekarang saya membuat batuk lagi, bagus. Sekarang, ia bekerja. Membuat batuk, batuk, batuk, batuk. Jadi, Anda mungkin berpikir bahwa kita benar-benar lebih rekayasa masalah ini. Dan, memang, kita. Ini bukan yang baik calon program pada saat ini untuk refactoring, dan melakukan apa yang disebut hirarkis dekomposisi, di mana Anda mengambil beberapa kode, dan kemudian Anda jenis faktor hal-hal, sehingga untuk menganggap lebih semantik kepada mereka, dan menggunakannya kembali jangka akhirnya lagi. Tapi itu sebuah blok bangunan ke arah program yang lebih canggih bahwa kita akan mulai menulis sebelum panjang yang memungkinkan kita untuk memiliki kosakata yang dapat digunakan untuk menulis kode yang lebih baik. Dan, memang, mari kita lihat apakah kita tidak bisa menggeneralisasi ini lebih lanjut. 

Tampaknya agak lumpuh yang saya, utama, perlu khawatir tentang ini darn untuk loop, dan memanggil batuk lagi dan lagi. Mengapa saya tidak bisa hanya memberitahu batuk, silahkan batuk tiga kali? Dengan kata lain, kenapa aku tidak bisa hanya memberikan masukan untuk batuk dan melakukan hal ini? 

Mengapa saya tidak bisa hanya mengatakan, di batuk utama tiga kali. Dan sekarang, ini adalah jenis magis. Ini sangat berulang di sini. Dan itu, memang, langkah bayi. 

Tapi kemampuan untuk mengatakan pada baris delapan, batuk tiga kali, itu hanya jauh lebih mudah dibaca. Dan, ditambah, saya tidak harus tahu atau peduli berapa batuk diimplementasikan. Dan, memang, kemudian di Istilah dan untuk proyek-proyek akhir, jika Anda menangani sebuah proyek dengan teman sekelas atau dua teman sekelas, Anda akan menyadari bahwa Anda akan harus, atau ingin, membagi pekerjaan. 

Dan Anda akan ingin memutuskan di muka, siapa yang akan melakukan apa, dan di mana potongan? Dan tidak akan menyenangkan jika Anda, misalnya, mengambil alih penulisan utama, dilakukan. Dan teman sekamar Anda, atau Anda mitra lebih umum, mengurus pelaksanaan batuk. 

Dan divisi ini, ini dinding abstraksi, atau lapisan abstraksi jika Anda akan, super kuat, karena terutama untuk yang lebih besar, program yang lebih kompleks dan sistem, memungkinkan beberapa orang untuk membangun hal bersama-sama, dan akhirnya menjahit pekerjaan mereka bersama-sama dengan cara ini. Tapi, tentu saja, kita perlu sekarang memperbaiki batuk. Kita perlu memberitahu batuk bahwa, hei, kau tahu apa? Anda akan perlu untuk mengambil input-- jadi tidak batal, tetapi int dan sekarang. Mari kita pergi ke depan dan dimasukkan ke dalam batuk int. i mendapat nol. 

i kurang dari berapa kali. Saya mengatakan tiga sebelumnya. Tapi bukan itu yang saya inginkan. Saya ingin batuk untuk digeneralisasi untuk mendukung sejumlah iterasi. 

Jadi, memang, itu n yang saya inginkan, apa pun pengguna memberitahu saya. Sekarang, saya bisa pergi ke depan dan mengatakan batuk cetak. Dan tidak peduli apa nomor pengguna lewat di, Aku akan iterate bahwa banyak kali. 

Jadi pada akhir hari, Program identik. Tetapi melihat semua hal ini bahkan bisa di file lain. Memang, saya tidak tahu di saat bagaimana printf diimplementasikan. 

Saya tidak tahu saat ini bagaimana mendapatkan string, atau mendapatkan int, atau mendapatkan mengambang diimplementasikan. Dan aku tidak ingin melihat mereka di layar saya. Seperti itu, aku mulai fokus pada program saya, tidak fungsi-fungsi. 

Dan, memang, segera setelah Anda mulai anjak kode seperti ini keluar, bisa kita bahkan bergerak batuk ke file terpisah? Orang lain bisa menerapkannya. Dan Anda dan program Anda menjadi sangat indah, dan sangat mudah dibaca, bisa dibilang, benar-benar empat program baris di sana. 

Jadi mari kita pergi ke depan sekarang dan membuat satu perubahan lagi. Perhatikan bahwa prototipe saya harus berubah di bagian atas. Jadi biarkan aku memperbaikinya sehingga Saya tidak dimarahi. 

Membuat batuk, biarkan aku menjalankan batuk sekali lebih, masih melakukan hal yang sama. Tapi sekarang, melihat kami memiliki bahan untuk satu versi final. Kamu tahu apa? Saya tidak ingin hanya batuk, tentu. Saya ingin memiliki sesuatu yang lebih umum. Sehingga Anda tahu apa? Saya ingin melakukan ini. Saya ingin memiliki, seperti Scratch tidak, blok katakanlah, tapi bukan hanya mengatakan sesuatu beberapa beberapa kali. Saya ingin katakan string yang sangat spesifik. Dan, karena itu, saya tidak ingin untuk hanya mengatakan batuk. Saya ingin mengatakan apa pun string yang dilewatkan di. 

Jadi perhatikan, saya sudah umum ini sehingga sekarang katakanlah terasa seperti nama baik untuk ini, seperti Scratch, membutuhkan dua argumen, tidak seperti Scratch. Salah satunya adalah string. Salah satunya adalah int. 

Dan saya bisa beralih mereka. Aku hanya jenis seperti ide mengatakan string pertama, dan kemudian berapa kali kemudian. Void berarti masih tidak kembali apa-apa. Ini hanya sisi visual efek, seperti dengan [? Jordan,?] efek samping verbal berteriak. Masih melakukan sesuatu n kali, 0 sampai, tapi tidak sama dengan n. Ini berarti n Total kali. Dan kemudian hanya mencetak apa yang string. Jadi aku benar-benar umum baris kode ini. Jadi sekarang, bagaimana cara menerapkannya fungsi batuk? 

Aku bisa melakukan batuk batal. Dan aku masih dapat mengambil dalam bagaimana banyak kali Anda ingin batuk. Tapi kau tahu apa? Saya sekarang bisa menyepak bola untuk mengatakan. 

Aku bisa menelepon mengatakan dengan Kata batuk, lewat di n. Dan jika saya ingin juga menerapkan, hanya untuk bersenang-senang, fungsi bersin, Aku bisa bersin beberapa beberapa kali. Dan saya bisa tetap menggunakan kembali n, karena melihat bahwa m dalam konteks ini atau lingkup hanya ada dalam fungsi ini. 

Dan n dalam konteks ini hanya ada dalam fungsi ini di sini. Jadi kita akan kembali ke masalah ini dari lingkup. Dan di sini, aku hanya akan mengatakan, Achoo, dan kemudian n kali, semi-kolon. 

Dan sekarang, aku hanya perlu meminjam Fungsi ini tanda tangan di sini. Jadi batuk benar. bersin Void benar sekarang. 

Dan aku masih hanya perlu mengatakan. Jadi aku akan mengatakan, katakanlah string s, int n, semi-kolon. Jadi saya sudah over-rekayasa heck keluar dari program ini. 

Dan ini tidak berarti ini apa yang harus Anda lakukan ketika menulis bahkan yang paling sederhana program. Mengambil sesuatu yang jelas benar-benar sederhana, benar-benar pendek, dan re menerapkan-itu menggunakan terlalu banyak kode. Tapi Anda benar-benar akan melihat, dan di Waktu melihat kembali pada contoh-contoh ini, dan menyadari, oh, mereka adalah langkah-langkah kami mengambil untuk benar-benar generalisasi, faktor sesuatu, sampai pada akhir hari kode saya sebenarnya cukup masuk akal. Karena jika saya ingin batuk tiga kali kemudian bersin tiga kali, Saya hanya akan mengulangi ini, Program membuat batuk, dan menjalankan batuk. Dan saya memiliki tiga batuk dan tiga bersin. 

Dan jadi ini adalah dasar paradigma, jika Anda mau, untuk bagaimana kita bisa pergi tentang benar-benar menerapkan program. Tapi mari kita lihat sekarang apa itu kami sudah melakukan semua ini, dan apa beberapa potongan terakhir berada di balik perintah sederhana ini. Pada akhir hari, kami telah telah menggunakan dentang sebagai compiler kami. Kami telah menulis sumber kode, mengubahnya melalui dentang ke dalam kode mesin. 

Dan kami telah menggunakan Membuat hanya untuk memfasilitasi keystrokes kami jadi bahwa kita tidak harus ingat mereka mantra dari dentang itu sendiri. Tapi apa yang membuat benar-benar melakukan? Dan, pada gilirannya, apa yang Dentang benar-benar melakukan? 

Ternyata, meskipun kami telah disederhanakan diskusi hari ini dengan mengatakan, Anda mengambil kode sumber, lulus sebagai masukan ke compiler, yang memberi Anda output mesin kode, ternyata ada ini beberapa langkah yang berbeda dalam sana. Dan kompilasi terjadi menjadi payung istilah untuk sejumlah langkah. Tapi mari kita menggoda out ini benar-benar cepat. 

Ternyata bahwa kita sudah melakukan lebih banyak hal setiap kali saya menjalankan program, atau setiap kali saya mengkompilasi program hari ini. Jadi preprocessing mengacu ini-- apapun dalam program C, seperti yang akan kita lihat lagi dan lagi, yang dimulai dengan simbol hash ini, atau simbol hashtag sini, berarti itu direktif preprocessor. Itu berarti, dalam kasus ini, hey komputer, melakukan sesuatu dengan file ini sebelum Anda benar-benar mengkompilasi kode sendiri. 

Dalam hal ini, hash termasuk adalah, dasarnya, cara C mengatakan, hey komputer, pergi mendapatkan isi dari CS50.h dan tempelkan di sini. Hey komputer, pergi mendapatkan isi standar io.h, dimanapun yang ada di hard drive, paste di sini. Jadi hal-hal terjadi pertama selama preprocessing. 

Dan dentang melakukan semua ini untuk kita. Dan itu tidak begitu darn cepat, Anda bahkan tidak melihat empat hal yang berbeda terjadi. Tapi itu langkah yang pertama. 

Apa yang sebenarnya terjadi? Nah, resmi berikutnya langkah kompilasi. Dan ternyata kompilasi program secara teknis berarti pergi dari kode sumber, hal-hal yang kami telah telah menulis hari ini, untuk sesuatu disebut kode assembly, sesuatu yang terlihat sedikit berbeda. 

Dan, pada kenyataannya, kita bisa melihat ini sangat cepat. Biarkan aku benar-benar pergi ke IDE saya. Biarkan aku pergi ke depan dan hello.c terbuka, yang adalah program pertama yang kita mulai hari ini. Dan biarkan aku pergi ke depan dan menjalankan dentang sebuah sedikit berbeda, dentang-s, hello.c, yang benar-benar akan memberi saya lagi hello.s berkas. 

Dan kita mungkin akan tidak pernah lagi melihat kode semacam ini. Jika Anda mengambil tingkat yang lebih rendah kelas sistem seperti CS61, Anda akan melihat lebih banyak dari kode semacam ini. Tapi ini adalah bahasa assembly. Ini adalah bahasa assembly X86 bahwa CPU yang mendasari CS50 IDE benar-benar mengerti. 

Dan samar seperti halnya terlihat, itu adalah sesuatu komputer mengerti cukup baik. Sub q, ini adalah kurangi a. Ada gerakan. 

Ada yang memanggil fungsi di sini, x oring, gerakan, add, pop, kembali. Jadi ada beberapa yang sangat instruksi tingkat rendah bahwa CPU memahami bahwa Saya singgung sebelumnya. Itulah yang Intel Inside. 

Ada pola nol dan orang-orang yang memetakan ini arcanely worded, tapi agak baik-bernama, petunjuk, boleh dikatakan. Itulah yang terjadi ketika Anda mengkompilasi kode Anda. Anda mendapatkan perakitan bahasa dari itu, yang berarti langkah ketiga adalah untuk merakit kode assembly ke dalam, akhirnya, mesin nol code-- dan orang-orang, bukan teks yang kita hanya melihat beberapa saat yang lalu. 

Jadi pre-processing apakah itu menemukan dan mengganti, dan beberapa hal lainnya. Kompilasi mengambil sumber Anda kode dari C, source code bahwa kita menulis, untuk perakitan kode yang kita hanya melirik. Perakitan mengambil perakitan yang kode untuk nol dan yang bahwa CPU benar-benar akan memahami pada akhir hari. Dan menghubungkan adalah langkah terakhir yang terjadi untuk us-- lagi, begitu cepat kami bahkan tidak notice-- yang mengatakan, hey komputer, mengambil semua nol dan orang-orang yang dihasilkan dari kompilasi kode Daud, dan fungsi utamanya dalam hal ini. 

Dan hey komputer, pergi mendapatkan semua nol dan satu bahwa staf CS50 menulis dalam perpustakaan CS50. Campur mereka dengan Daud. Dan hey komputer, pergi mendapatkan semua nol dan orang-orang yang orang lain menulis tahun lalu untuk printf. Dan menambahkan mereka ke dalam semuanya, sehingga kita sudah mendapat nol saya dan orang-orang, yang CS50 staf nol dan satu, nol printf dan orang-orang, dan apa pun yang kita gunakan. 

Mereka semua mendapatkan digabungkan bersama-sama menjadi satu program yang disebut, dalam hal ini, halo. Jadi untuk selanjutnya, kita hanya akan menggunakan kompilasi kata. Dan kami akan mengambil begitu saja bahwa ketika kita katakan, mengkompilasi program Anda, itu berarti, hey melakukan pre-processing, perakitan, dan menghubungkan. Tapi sebenarnya ada beberapa hal menarik terjadi di sana di bawah kap mesin. Dan terutama jika Anda mendapatkan penasaran beberapa waktu, Anda dapat mulai menyodok sekitar pada tingkat yang lebih rendah ini. Tapi untuk saat ini, menyadari bahwa antara takeaways untuk hari ini adalah cukup sederhana mulai dari proses, mendapatkan nyaman dengan sesuatu seperti dunia halo. Memang, sebagian besar dari apa yang kita lakukan hari ini tentu tidak akan tenggelam di super cepat. Dan itu akan mengambil beberapa waktu, dan beberapa latihan. Dan kemungkinan besar, Anda akan menyortir dari ingin memukul keyboard Anda atau berteriak pada layar. Dan semua itu OK. Meskipun, mungkin mencoba untuk tidak melakukannya di perpustakaan begitu banyak. 

Dan akhirnya, Anda akan akan mampu meskipun, untuk memulai melihat pola, baik dalam kode yang baik bahwa Anda telah ditulis dan di kesalahan yang telah Anda buat. Dan banyak seperti proses menjadi TF atau CA adalah seperti, Anda akan mulai mendapatkan yang lebih baik dan lebih baik dalam melihat pola tersebut, dan hanya memecahkan Anda masalah sendiri akhirnya. Sementara itu, akan ada banyak dari kita untuk memberikan dukungan Anda, dan membuat Anda melalui ini. Dan di write-ups untuk semua masalah akan Anda akan dipandu melalui semua perintah bahwa aku pasti tahu dari banyak latihan sekarang, tapi mungkin telah terbang di atas kepala seseorang untuk saat ini. Dan itu benar-benar baik-baik saja. 

Tapi, pada akhirnya, Anda akan untuk mulai melihat pola yang muncul. Dan setelah Anda melewati semua Rincian bodoh, seperti tanda kurung, dan kurung kurawal, dan semi-titik dua, dan hal-hal yang, terus terang, yang sama sekali tidak intelektual yang menarik. Dan itu bukan tujuan mengambil setiap kelas pengantar. Ini adalah ide yang akan menjadi masalah. 

Ini loop, dan kondisi, dan fungsi, dan lebih kuat abstraksi, dan anjak kode, dan desain yang baik, dan baik gaya, dan akhirnya kebenaran yang kode Anda, itu akhirnya akan paling penting. Jadi minggu depan, kita akan mengambil ini ide-ide yang kita lihat pada Scratch dan sekarang telah diterjemahkan C. Dan kita akan mulai untuk memperkenalkan pertama domain dunia nyata saja ini. 

Kami akan fokus pada dunia keamanan, dan lebih khusus kriptografi, seni berebut informasi. Dan di antara yang pertama masalah Anda sendiri akan mendapatkan untuk menulis di luar bermain dengan beberapa sintaks dan memecahkan beberapa logis masalah, akhirnya tak lama, adalah untuk benar-benar berebut, atau mengenkripsi, dan akhirnya mendekripsi informasi. Dan segala sesuatu yang kita lakukan hari ini, akan cukup rendah tingkat, hanya akan memungkinkan kita untuk mengambil satu, dan satu, dan satu langkah lebih di atas menuju menulis kode yang paling menarik belum. 

Jadi lebih pada minggu depan. 

[VIDEO PEMUTARAN] 

-Apa Yang bisa Anda ceritakan tentang terakhir kali Anda melihatnya? -Apa Yang bisa saya katakan, benar-benar? Maksudku, itu seperti yang lain latihan pra-produksi, kecuali ada sesuatu katanya di akhir yang terjebak dengan saya. 

-Ini Adalah CS50. 

-Itu Memotong semua orang, pekerjaan yang besar pada latihan. 

siang -yaitu ini? 

Yeah, kau dan aku bisa ambil sandwich dalam sedikit. Saya hanya berdiskusi dengan David benar-benar cepat. David? David? 

[END PEMUTARAN] 