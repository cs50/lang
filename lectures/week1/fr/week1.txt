[MUSIC PLAYING] DAVID J. Malan: Très bien, cela est CS50. Et ceci est la première semaine. Donc, rappeler que la dernière fois dans la semaine zéro, nous nous sommes concentrés sur la pensée de calcul. Et nous sommes passés de celui Scratch, une programmation graphique la langue de nos amis au Media Lab du MIT. 

Et avec Scratch, ne nous explorons des idées comme les fonctions et les conditions, et les boucles et les variables, et même les événements et les discussions, et plus encore. Et aujourd'hui, nous allons continuer à utiliser ces idées, et vraiment les prendre pour acquis, mais les traduire à une autre langue connue sous le nom C. Maintenant, C est un langage plus traditionnel. Il est un niveau inférieur la langue, si vous voulez. 

Il est purement textuel. Et donc, à première vue, il est tout va regarder plutôt cryptique si vous ne l'avez jamais programmé auparavant. Nous allons avoir points-virgules et les parenthèses, et accolades, et plus encore. Mais se rendre compte que même si la syntaxe est sur le point de regarder un peu familier à la plupart d'entre vous, voir passé. Et essayer de voir les idées qui sont, en effet, familier, car ici en première semaine ce nous allons commencer à faire est de comparer, initialement, Scratch contre C. 

Ainsi, par exemple, rappeler que lorsque nous mis en œuvre le premier de nos programmes la dernière fois, nous avions un bloc qui avait l'air un petit quelque chose comme this-- quand drapeau vert cliqué, et puis nous avons eu une ou plusieurs pièces de puzzle en dessous, dans ce cas, dire bonjour monde. Donc, en effet, dans Scratch, lorsque je clique sur le drapeau vert pour exécuter mon programme, de sorte de parler, ce sont les blocs qui s'exécutés, ou l'exécution. Et, plus précisément, Scratch dit, bonjour, monde. 

Maintenant, je pourrais avoir spécifié différents mots ici. Mais nous verrons que, en effet, beaucoup de ces blocks-- et, en fait, en C beaucoup functions-- peuvent être paramétrés ou personnalisés faire des choses différentes. En effet, si l'on en C voulez convertir, maintenant, ce programme de Scratch à cette autre langue, nous allons écrire un petit quelque chose comme ça. 

Certes, il y a une certaine inconnue syntaxe il le plus probable, int, et entre parenthèses, et non avenu. Mais printf-- même si vous le feriez pense que ce serait tout simplement l'impression. Mais l'impression des moyens d'impression formaté, comme nous le verrons bientôt. Cela va littéralement imprimer à l'écran quelle que soit est à l'intérieur de ces parenthèses, qui bien sûr, dans ce cas est, bonjour monde. 

Mais vous remarquerez une autre syntaxe, certains guillemets doubles, que les parenthèses à la fin, le point-virgule et analogues. Donc, il y a un peu de frais généraux, pour ainsi dire, à la fois cognitivement et syntaxiquement, que nous allons d'avoir à se rappeler avant longtemps. Mais se rendre compte que la pratique, cela va commencer à sauter à vous. 

En fait, nous allons concentrer sur celui-là fonction specifically-- dans ce cas, dire bonjour monde. Donc, dire est la fonction. Bonjour tout le monde est son paramètre, ou un argument, sa personnalisation. 

Et l'équivalence en C est juste va être cette seule ligne ici, où printf est équivalent à, disons, la chaîne entre guillemets, bonjour monde est équivalent, bien sûr, à ce qui est dans la boîte blanche là-bas. Et le backslash n, bien qu'un peu étrange et absent à partir de zéro, tout simplement va avoir l'effet nous allons voir dans un ordinateur, comme mon Mac ou un PC, de simplement déplacer le curseur à la ligne suivante. Il est comme frapper Entrée de votre clavier. 

Donc, nous allons voir que de nouveau avant longtemps. Mais d'abord, nous allons jeter un oeil à cette un autre exemple dans le cas de boucles. Nous avons eu cette boucle pour toujours la dernière fois, qui était une série de pièces de puzzle qui a fait quelque chose littéralement forever-- dans ce cas, dire bonjour monde, bonjour monde, Bonjour tout le monde, bonjour monde. Il est donc une boucle infinie par la conception. 

En C, si l'on veut mettre en œuvre cette même idée, nous pourrions simplement faire ceci. Bien vrai, printf bonjour monde-- maintenant tandis que, juste sémantiquement, sorte de évoque l'idée de faire quelque chose de nouveau, et encore, et encore, et pour combien de temps? Eh bien, le rappel true-- que vrai est juste ou un. 

Et vrai est, bien sûr, toujours vrai. Donc, il est une sorte de sens déclaration juste pour dire vrai. Mais en effet, ceci est délibéré, parce que si vrai est juste toujours vrai, que tout vrai implique juste, si un peu indirectement, que les lignes de code suivantes entre ces accolades devrait simplement exécuter à nouveau, et encore, et encore, et ne jamais cesser réellement. 

Mais si vous ne voulez que votre boucle pour arrêter, comme nous a fait la dernière fois avec quelque chose comme cela, répéter les 50 heures suivantes, en C, nous pouvons faire la même chose avec ce qui est appelé le mot-clé pour loop-- ne pas être tout, mais pour. Et puis nous avons une nouvelle syntaxe ici, avec un entier i est égal à 0, i inférieur à 50, i ++. Et nous reviendrons à cela. Mais cela est tout simplement la façon dont nous le ferions traduire l'ensemble des blocs de grattage à un ensemble de lignes de code C. 

Pendant ce temps, tenir compte des variables. Et, en fait, nous avons juste vu un il y a un moment. Et dans le cas de Scratch, si nous voulu déclarer une variable appelée i pour i étant entier, juste un nombre, et nous voulons le mettre à une certaine valeur, nous devrions utiliser cette orange bloquer ici-- i mis à 0. 

Et nous allons voir aujourd'hui et au-delà, tout comme la semaine dernière, programmeurs font presque toujours commencer à compter à partir de zéro, vraiment par convention. Mais aussi parce que le rappel de notre discussion de binaire, le plus petit nombre possible représenter avec un nombre quelconque de bits va tout simplement être 0 lui-même. Et donc nous allons généralement commencer initialisant même nos variables à 0. 

Et en C pour faire la même chose, nous allons dire int pour entier, je viens par convention. Je aurais pu appeler cette variable tout ce que je veux, comme dans Scratch. Et puis est égal à 0 seulement ayants droit la valeur 0 de la droite et le met dans la variable, ou Récipient de stockage bas, sur la gauche. Et le point-virgule comme nous allons see-- et nous avons vu quelques-unes de ces already-- signifie simplement la fin de la pensée. Passez à faire autre chose sur les lignes qui suivent. 

Maintenant, qu'en est-il des expressions booléennes? Rappelons que dans Scratch, ceux-ci étaient des expressions qui sont soit vrai ou des questions false--, vraiment, qui sont soit vrai ou faux. Donc, dans le cas de Scratch, nous pourrions poser une question simple comme ça, est i moins de 50? Donc je, encore une fois, est un nombre entier. Peut-être que nous l'utiliser dans un programme de Scratch de garder une trace d'une partition ou quelque chose comme ça. Donc, cette syntaxe ici Scratch signifie simplement, est i moins de 50? Eh bien, heureusement, quelque chose est simple C. Et à traduire, cela nous serait tout simplement dire que je moins à 50, en utilisant la clé familière sur votre clavier. 

Pendant ce temps, si vous vouliez dire quelque chose de plus général, comme, bien, est x moins y où chaque x et y sont eux-mêmes des variables? Nous pouvons faire la même chose en C, aussi longtemps que nous avons créé déjà ces variables. Et nous allons voir comment faire avant longtemps. Nous dirions simplement x moins y. 

Donc, vous commencez à voir quelques similitudes. Et ces gens qui ont fait Scratch étaient certainement inspiré par certaines de ces idées de base. Et vous verrez ce genre de syntaxe dans un grand nombre languages-- pas seulement Scratch, pas juste C, mais Python, et JavaScript, et d'autres langues encore. 

Considérons une autre construction de C, la notion d'une condition, faire quelque chose de manière conditionnelle. Si quelque chose est vrai, faire cela. Si quelque chose est vrai, faire cela. Il est en quelque sorte de la programmation équivalent d'une bifurcation de la route. Peut-être qu'il est une fourche à deux voies, une fourchette à trois voies ou plus. Et dans Scratch, nous pourrions avoir vu quelque chose comme ça. 

Donc, celui-ci est un grand. Mais considérer le rapport la simplicité de la logique. Si x est inférieur à y, dites x est moins à y, sinon si x est supérieur à y, dire alors x est supérieur à y. Et puis, logiquement, si vous repensez à Scratch ou tout simplement votre propre intuition humaine, De plus, si x est inférieure ou égale à y, et x est pas inférieur à y, alors bien sûr x va être égal à y. Donc dans ce cas, par emboîtement ces blocs de Scratch, pouvons-nous atteindre trois fourche chemin dans la route? 

Pendant ce temps, si nous voulons faire que, dans C, il sans doute regarde un peu simpler-- au moins une fois que vous vous familiariser avec la syntaxe. Si x est inférieur à y, printf x est inférieur à y. Sinon, si x est supérieur à y, printf x est supérieur à y. Else printf x est égal à Y- et, encore une fois, avec les backslash se termine juste pour les nouvelles lignes de telle sorte que si vous effectivement couru ce genre de programme il suffit de déplacer votre curseur en fin de compte à la ligne suivante de l'écran. 

Maintenant, quant à lui Scratch avait d'autres des fonctionnalités plus sophistiquées, seulement dont certains que nous allons déplacer d'abord vers le monde de C. Et l'un d'entre eux était appelé une liste dans Scratch. Et ce fut une spéciale le type de variable vous a permis de stocker plusieurs choses à revenir, à dos, à dos, à l'arrière. 

En C, il n'a pas listes, en soi, mais quelque chose qui sont généralement plus appelé tableaux, bien que nous allons revenir plus tard ce semestre à regarder quelque chose appelé une liste, ou vraiment une liste liée. Mais pour l'instant, le plus proche équivalent en C pour nous va être quelque chose appelé un tableau. Et un tableau est tout simplement un type spécial de la variable qui vous permet de stocker des données dos, à dos, à dos, à dos. 

Et, en effet, dans Scratch, si nous voulions accéder le premier élément d'un tableau ou un films-- et je vais l'appeler, par convention, argv argument vecteur, mais plus sur cela avant longtemps. Si je veux obtenir le premier élément de argv, dans le monde du Scratch vous faites en fait généralement commencer à compter du 1er. 

Et donc je pourrais obtenir le point 1 de argv. C'est juste comment MIT mis en œuvre la notion de listes. Mais en C, je vais plus simplement dire simplement, argv, qui est à nouveau le nom de mon films-- ou pour être clair, un tableau. Et si je veux la première éléments, je vais d'utiliser des crochets, que vous peut-être pas souvent utilisé sous un clavier. 

Mais 0 signifie juste, me faire le premier. Donc, à l'occasion, et comme le temps passe, nous allons pour commencer à voir ces dichotomies entre zéro et C, lequel Scratch utilise un. Nous en C utilisons 0 ici. Mais vous verrez rapidement une fois que vous comprenez les fondements de chaque langue, que ces choses commencent à devenir d'autant plus familiers par la pratique et la pratique. 

Donc, nous allons effectivement maintenant regarder un programme. Ici sera la première de notre C code source de programmes complets. Et le programme que nous allons à offrir pour examen est celui qui est l'équivalent à ce morceau de Scratch plus tôt. 

Donc, ici, nous avons ce qui est sans doute le programme le plus simple C vous pouvez écrire que ne fait quelque chose. Maintenant, nous allons regarder passé, pour l'instant, a inclure, io.h standard, et ceux-ci angle entre parenthèses, et int, et non avenu, et les accolades, et similaires. 

Et nous allons nous concentrer sur ce qui, au moins intuitivement, pourrait sauter à vous déjà. En fait, le principal, je ne savoir nécessairement ce que cela est, mais beaucoup comme Scratch avait que lorsque drapeau vert cliqué morceau de puzzle, il en va de C comme un langage de programmation avoir un morceau principal de code est exécuté par défaut. Et en effet, il est littéralement va être appelé principal. 

Si principale est une fonction. Et il est une fonction spéciale qui existe en C que lorsque vous exécutez un programme, il est le principal qui obtient géré par défaut. Dans le monde du Scratch, il était généralement lorsque le drapeau vert cliqué qui a obtenu exécuter par défaut. 

Pendant ce temps, nous avons vu cela avant, printf ou imprimer au format, qui est va être une fonction qui vient avec C, ainsi que tout un tas d'autres, cette volonté de temps et le temps encore une fois, afin de faire exactement comme son nom l'indique, imprimer quelque chose. Que voulons-nous imprimer? Eh bien, nous allons voir que par des caractères enserrant comme these-- monde bonjour, backslash n entre guillemets, nous pouvons dire exactement printf ce que pour imprimer sur l'écran. 

Mais pour faire que nous avons malheureusement besoin de prendre quelque chose qui est déjà cryptique pour nous les humains, mais au moins il est un peu readable-- forte comprennent, io.h standard, int, principale, vide, printf, toute la magie incantations nous venons de voir à l'écran. Mais nous avons effectivement aller plus mystérieux encore. Nous devons d'abord traduire le code que nous écrivons en code machine. Et rappeler de la semaine dernière que les machines, au moins ceux que nous connaissons ici, à la fin de la journée seulement comprendre zéros et des uns. 

Et mon Dieu, si nous devions écrire ces zéros et des uns à fait le programme, il serait très, très rapidement prendre du plaisir sur quoi que ce soit. Mais il se trouve, par la semaine dernière, que ces schémas de zéros et juste avoir une signification particulière. Dans certains contextes, ils pourraient signifier des chiffres. 

Dans certains contextes, ils pourraient signifier lettres ou couleurs, ou un nombre quelconque d'autres abstractions là sur. Mais tout comme votre ordinateur une CPU, Central Processing Unit, ou le cerveau à l'intérieur de votre ordinateur. Il est généralement Intel à l'intérieur, parce que ce l'une des plus grandes entreprises qui rend les processeurs pour les ordinateurs. 

Eh bien, les processeurs Intel et d'autres ont tout simplement décidé à l'avance que certains modèles de zéros et ceux entend des choses spécifiques. Certains modèles de zéros et signifiera, imprimer à l'écran, ou ajouter ces deux nombres, ou soustraire ces deux nombres, ou déplacer ce morceau de données à partir la mémoire de mon ordinateur ici, ou un nombre quelconque d'autres très bas niveau, mais finalement utile opérations. Mais, heureusement, nous, les humains ne vont pas avoir besoin de connaître ce niveau de détail. En effet, tout comme la dernière fois, où nous Abstraite encore, et encore, et encore, bâtiment de très faible niveau primitives comme zéros et des uns à la hausse des concepts de niveau comme les numéros et les lettres, et les couleurs, et plus encore, donc pouvons-nous en tant que programmeurs se tenir debout sur les épaules de d'autres qui nous ont précédés et utiliser des logiciels que d'autres les gens ont écrit avant us-- à savoir les programmes appelés compilateurs. 

C est une langue est habituellement compilé, ce qui veut dire convertie à partir le code source en code machine. En particulier, ce que cela signifie est que si vous avez la source code qui vous vous écrivez, comme nous bientôt sera dans un instant sur l'écran, et que vous voulez convertir en fin de compte à la machine code-- ces zéros et ceux qui seulement votre Mac ou votre PC understands-- vous avez une première nourrir que le code source en tant entrée à une spéciale programme appelé un compilateur, la sortie de laquelle nous doit voir est le code machine. Et, en effet, la dernière fois nous avons parlé environ, en fait, à la fin de la journée, résolution de problème. Vous avez entrées. Et vous avez sorties. Et vous avez une sorte de l'algorithme dans le milieu. 

Les algorithmes peuvent sûrement mis en œuvre dans le logiciel, comme nous l'avons vu avec pseudocode la semaine dernière et comme nous le verrons avec le code réel cette semaine. Et donc un compilateur vraiment juste a un ensemble d'algorithmes intérieur de celui qui sait comment convertir les mots-clés spéciaux, comme principal et printf, et d'autres que nous venons a vu dans les modèles de zéros et ceux qui Intel à l'intérieur et d'autres processeurs comprend réellement. Alors, comment faisons-nous cela? Où pouvons-nous obtenir un compilateur? 

La plupart d'entre nous ont un Mac ou un PC. Et vous êtes sous Mac OS, ou Windows ou Linux ou Solaris, ou un nombre quelconque d'autres systèmes d'exploitation. Et, en effet, nous avons pu aller sur le web et télécharger un compilateur pour votre Mac ou votre PC pour votre système d'exploitation particulier. Mais nous serions tous sur différentes pages, pour ainsi dire. Nous aurions légèrement différentes configurations. Et les choses ne fonctionneraient pas tous les mêmes. Et, en effet, ces jours-ci beaucoup d'entre nous ne pas utiliser logiciel qui ne fonctionne que sur nos ordinateurs portables. Au lieu de cela, nous utilisons quelque chose comme un navigateur nous permet d'accès Web applications dans le nuage. Et plus tard ce semestre, nous allons faire exactement cela. Nous allons écrire des applications ou logiciel en utilisant code-- pas C, mais d'autres langages comme Python et JavaScript-- qui courent dans le nuage. 

Et pour ce faire, nous nous au cours du semestre sera effectivement utiliser un basé sur un nuage environnement connu sous le nom CS50 IDE. Ceci est une programmation basée sur le Web environnement ou développement intégré environnement, IDe, qui est construit au sommet d'une certaine logiciel open source appelé Cloud 9. Et nous avons fait des pédagogique simplifications à ce afin de cacher certaines caractéristiques les premières semaines que nous ne devons, après quoi vous pouvez les révéler et faire plus tout ce que vous voulez avec l'environnement. 

Et cela nous permet, aussi, de pré-installer certains logiciels. Des choses comme un soi-disant CS50 bibliothèque, que nous verrons bientôt nous fournit en C avec une certaine des fonctionnalités supplémentaires. Donc, si vous allez à, finalement, CS50.io, vous serez invité à vous connecter, et une fois que vous faites et créer un compte gratuitement, vous serez en mesure d'accéder à un environnement qui semble tout à fait comme ça. 

Or, ceci est dans le mode par défaut. Tout est agréable et lumineux sur l'écran. Beaucoup d'entre nous ont l'habitude de travailler sur le morceau de CS50 qui est assez tard dans la nuit. Et certains d'entre vous pourraient préférer transformer en mode nuit, pour ainsi dire. 

Mais, en fin de compte, ce que vous êtes aller voir dans les CS50 IDE est trois areas-- distincte une zone sur la gauche où vos fichiers vont être dans la nuage, une zone en haut à droite où votre code va être modifiable. Vous serez en mesure d'ouvrir onglets individuels pour tout programme que vous écrivez ce semestre à l'intérieur de ce coin en haut à droite. Et puis plus arcanely, et pourtant puissamment, va être cette chose à la bas connu comme une fenêtre de terminal. 

Ceci est une ancienne école Command Line Interface, ou CLI, qui permet d'exécuter des commandes sur le computer-- dans ce cas, l'ordinateur dans le cloud-- à faire des choses comme compiler votre code à partir du code source en code machine, pour exécuter vos programmes, ou pour commencer votre serveur web, ou pour accéder à votre base de données, et un certain nombre d'autres techniques que nous allons commencer à utiliser avant longtemps. Mais pour y arriver, nous sommes va avoir effectivement d'aller en ligne et commencer à jouer. Et pour ce faire, nous allons d'abord commencer à bricoler avec principale, et écrire la partie principale d'un programme. Et nous allons utiliser cette fonction printf, que nous avons utilisé plus tôt, tout simplement pour dire quelque chose. 

Donc ici, je suis déjà à l'intérieur du CS50 IDE. Je suis connecté à l'avance. Et je complète DEPISTAGE la fenêtre. Et donc, en fin de compte, vous trop de problèmes à venir suivra les étapes similaires fournira la documentation en ligne. Donc, vous ne devez pas vous inquiéter au sujet absorber chaque petite étape technique que je fais ici aujourd'hui. 

Mais vous obtiendrez un écran comme celui-ci. Je me trouve être en mode nuit. Et vous pouvez égayer tout par désactivation du mode nuit. Et à la fin de la jour, vous allez voir ces trois principaux areas-- le fichier navigateur à gauche, les onglets de code en haut, et la fenêtre du terminal vers le bas. 

Laissez-moi aller de l'avant et écrire mon premier programme. Je vais aller préemptive dans un fichier, Enregistrer et enregistrer mon fichier comme hello.c. En effet, par convention, tout ce que nous programme écriture qui est écrit dans le langage C devrait être nommé quelque chose point c, par convention. Donc, je vais le nommer hello.c, parce Je veux juste dire bonjour au monde. Maintenant, je vais faire un zoom out et cliquez sur Enregistrer. Et tout ce que j'ai ici maintenant est un onglet dans lequel je peux commencer à écrire du code. 

Cela ne va pas à compiler. Cela n'a aucun sens. Et même si je me suis converti cela zéros et des uns, la CPU va avoir aucun idée de ce qui se passe autour. Mais si j'écris les lignes qui ne correspondent avec conventions-- C étant de C, à nouveau, cette language-- avec la syntaxe comme cela, printf bonjour monde-- et je l'ai obtenu à l'aise avec faisant cela au fil du temps. Donc, je ne pense pas que je fait toute erreur typographique. 

Mais, invariablement, la première fois que vous faites cela, vous. Et ce que je vais faire pourrait très bien fonctionne pas pour vous la première fois. Et c'est parfaitement OK, parce que maintenant vous pourrait bien voir un tas de nouveauté, mais au fil du temps une fois que vous familiariser avec cet environnement, et ce langage, et d'autres, vous allez commencer à voir des choses qui sont soit correcte ou incorrecte. 

Et voici ce que le boursiers d'enseignement et bien sûr assistants sont tellement bons au fil du temps, est repérer des erreurs ou des bugs dans votre code. Mais je prétends qu'il y n'y a pas de bugs dans ce code. Je veux maintenant exécuter ce programme. 

Maintenant, sur mon propre Mac ou PC, je suis en l'habitude de doubles icônes de cliquetis quand je veux lancer un programme. Mais ce n'est pas le modèle ici. Dans cet environnement, qui est CS50 IDE. Nous utilisons une exploitation système appelé Linux. Linux rappelle une autre système d'exploitation, généralement connu comme Unix. Et Linux est particulièrement connu pour ayant une ligne de commande de l'environnement, CLI. Maintenant, nous utilisons un particulier saveur de Linux appelée Ubuntu. Et Ubuntu est tout simplement un certaine version de Linux. 

Mais de ces Linux ces jours-ci font réellement venir avec des interfaces utilisateur graphiques. Et celui que nous arrive de être en utilisant ici est basé sur le Web. Donc, cela pourrait regarder même un peu différent de quelque chose vous vous pourriez avoir vu ou courir dans le passé. 

Je vais donc aller de l'avant maintenant et faire ce qui suit. J'ai sauvé ce fichier comme hello.c. Je vais aller de l'avant et Type clanghello.c Alors Clang pour le langage C est un compilateur. Il est pré-installé dans CS50 IDE. Et vous ne pouvez absolument télécharger et installer sur votre propre Mac ou PC. 

Mais, encore une fois, il n'y aurait pas tous la pré-configuration fait pour vous. Donc pour l'instant, je suis juste va courir clanghello.c. Et maintenant remarquer cette syntaxe ici finira réalise signifie juste que je suis dans un dossier ou un répertoire appelé espace de travail. Ce signe dollar est juste convention de sens, tapez vos commandes ici. 

Il est ce qu'on appelle une invite, juste par convention est le signe dollar. Et si j'aller de l'avant maintenant et cliquez sur Entrez, rien ne semble s'être produit. Mais c'est en fait une bonne chose. Le moins ce qui se passe sur votre écran, plus il est probable votre code est d'être correct, au moins syntaxiquement. 

Donc, si je veux courir ce programme, que dois-je faire? Eh bien, il se trouve que la le nom par défaut, par convention, pour les programmes lorsque vous ne spécifiez pas de le nom de votre programme est juste a.out. Et cette syntaxe aussi, vous aurez se familiariser avec avant longtemps. 

Dot slash signifie juste, hé, CS50 IDE, exécutez un programme appelé a.out qui est dans mon répertoire en cours. Ce point signifie le répertoire courant. Et nous allons voir ce que d'autres telles séquences de caractères signifie avant longtemps. 

Alors on y va, Entrée, bonjour monde. Et vous remarquerez, que ce qui est arrivé? Non seulement at-il imprimer bonjour monde. Il a également proposé la curseur à la ligne suivante. 

Et pourquoi était-ce? Quel était le code que nous avons écrit avant qui veillé à ce que le curseur serait aller sur la ligne suivante? Chose drôle au sujet d'un ordinateur est il va seulement de faire littéralement ce que vous lui demandez de faire. 

Donc, si vous le dites à printf bonjour, virgule, espace, monde, près devis, il est littéralement ne va d'imprimer ces caractères. Mais j'ai eu ce caractère spécial à la fin, le rappel, backslash n. Et voilà ce qui assure que le caractère a à la ligne suivante de l'écran. 

En fait, laissez-moi aller et le faire. Laissez-moi aller de l'avant et de supprimer cela. Maintenant, notez que la haut de mon écran, il est un peu de lumière rouge l'onglet indiquant, hey, vous avez pas enregistré votre fichier. Je vais donc aller de l'avant avec le contrôle S ou commande S, enregistrez le fichier. Maintenant, il goes-- est allé pour un vert moment--. Et maintenant il est de retour à juste être une icône proche. 

Si je lance maintenant clanghello.c à nouveau, Entrez, slash dot, a.out, Entrée, vous verrez que cela a fonctionné encore. Mais il est sans doute un peu buggé. En ce moment, mon espace de travail prompt--, puis ce signe de dollar, et puis mon prompt-- réelle est le tout sur la même ligne. Donc, cela a certainement un bug esthétique, même si elle est pas vraiment un bug logique. 

Donc, je vais défaire ce que je viens de faire. Je vais relancer a.out. Remarquez que j'ai ajouté la newline retour de caractère. Je l'ai enregistré le fichier. 

Donc, je vais relancer a.out, et-- dammit, un bogue, un bogue qui signifie erreur. Ainsi, le bug est que même si J'ai ajouté le backslash n là, re-enregistré, re-dirigé le programme, le comportement était le même. Pourquoi serait-ce? 

Il me manque une étape, non? Cette étape clé a été plus tôt que vous avez to-- lorsque vous modifiez votre code source, il se trouve aussi fonctionner par l'intermédiaire du compilateur à nouveau de sorte que vous obtenez le nouveau code de la machine. Et le code de la machine, les zéros et les uns, vont être à peu près identique, mais pas parfaitement, parce que nous avons besoin, bien sûr, que la nouvelle ligne. 

Donc, pour résoudre ce problème, je vais avoir besoin réexécuter clanghello.c, entrez, dot slash, a.out. Et maintenant, bonjour tout le monde est de retour là où je pense qu'elle doit être. Donc, tout cela est bel et bon. Mais a.out est un nom assez stupide pour un programme, même si elle se trouve être, pour des raisons historiques, la default-- signifie sorties d'assemblage. 

Mais laissez-moi aller de l'avant ici et cela différemment. Je veux que mon programme bonjour mondial effectivement être appelé bonjour. Donc, si elle était une icône sur mon bureau, il ne serait pas a.out. Il serait appelé bonjour. 

Donc, pour ce faire, il se trouve que Clang, comme de nombreux programmes, soutient les arguments de ligne de commande, ou des drapeaux, ou des commutateurs, qui influencent simplement son comportement. Plus précisément, Clang prend en charge un tiret o drapeau, qui prend alors un second mot. Dans ce cas, je vais arbitrairement, mais raisonnablement, appeler bonjour. Mais je pourrais appeler ça Je veux, sauf a.out, qui serait plutôt d'ailleurs le point. 

Et puis il suffit de spécifier le nom du fichier que je ne veux compiler. Alors maintenant, même si au début de la commande, je dois encore Clang, à la fin de la commande J'ai encore le nom du fichier, J'ai maintenant ces lignes de commande arguments, ces drapeaux qui disent, oh, en passant, la sortie-o, un fichier appelé bonjour, pas le a.out par défaut. 

Donc, si je frappe maintenant entrer, rien semble s'être produit. Et pourtant, maintenant, je peux faire slash dot bonjour. Il est donc le même programme. Les zéros et les uns sont identique à la fin de la journée. 

Mais ils sont en deux différente a.out files--, qui est la première version et juste bêtement nommé, et maintenant bonjour, qui est un bien nom de plus convaincant pour un programme. Mais, honnêtement, je ne suis jamais va se souvenir de ce nouveau, et encore et encore. Et, en fait, que nous écrivons programmes plus complexes, les commandes que vous êtes allez avoir à écrire vont devenir encore plus compliqué encore. 

Et ne vous inquiétez pas. Il se trouve que les humains avant nous avons réalisé eux aussi eu ce même problème. Ils ne bénéficient pas non plus avoir à tapez assez longues, les commandes ésotériques, et encore moins en souvenir. Et les humains qui nous ont fait d'autres programmes qui facilitent pour compiler votre logiciel. 

Et, en effet, un tel programme est appelé Marque. Je vais donc aller de l'avant et de le faire. Je vais défaire tout ce que je vient de le faire de la manière suivante. Permettez-moi de taper LS. Et vous remarquerez trois things-- a.out, et une étoile, bonjour et une étoile, et hello.c. Espérons que cela devrait être un peu intuitive, dans la mesure où il y avait précédemment rien dans cet espace de travail. Il n'y avait rien que je devais créé jusqu'à ce que nous avons commencé la classe. 

Et je créé hello.c. Je puis compilé, et l'a appelé a.out. Et puis je compilé à nouveau légèrement différemment et appelé bonjour. J'ai trois fichiers dans ce répertoire, dans ce dossier appelé espace de travail. Maintenant, je peux voir cela aussi si je zoome sur réellement. 

Si je zoome ici et regarder cette main en haut à droite coin, comme promis la gauche côté de votre écran va toujours vous montrer ce qui est dans votre compte, ce qui est intérieur du CS50 IDE. Et il y a trois fichiers. 

Donc, je veux me débarrasser de a.out et bonjour. Et comme vous pouvez imaginer intuitivement, vous pourrait trier du contrôle cliquez ou un clic droit sur ce point. Et ce petit menu apparaît. Vous pouvez télécharger le fichier, exécutez elle, prévisualiser, rafraîchir, renommer, ou de ce pas. 

Et je ne pouvais tout simplement supprimer, et il irait. Mais nous allons faire les choses avec une commande ligne pour le moment, de manière à mettre à l'aise avec cela, et faire ce qui suit. Je vais aller de l'avant et retirer a.out en tapant littéralement rma.out. Il se trouve, la commande pour la suppression ou la suppression de quelque chose, est pas retirer ou supprimer. 

Il est plus succinctement RM, juste pour sauver vous quelques frappes, et appuyez sur Entrée. Maintenant, nous allons être un peu supprimer énigmatiquement a.out fichier régulier. Je ne sais pas vraiment ce qu'est un fichier irrégulière serait encore. Mais je ne veux l'enlever. 

Donc, je vais y entrer pour oui. Ou je pourrais taper sur, et appuyez sur Entrée. Et, encore une fois, rien ne semble se produire. Mais cela est, en général, une bonne chose. 

Si je tape LS cette fois, Que dois-je voir? Espérons juste bonjour et hello.c. Maintenant, en passant, vous aurez remarquer cette étoile, astérisque, qui est à la fin de mes programmes. Et ils sont également montrant en vert. C'est juste moyen de CS50 IDE vous cluing dans le fait que ce n'est pas le code source. C'est un exécutable, un runnable programme que vous pouvez réellement exécuter en faisant slash dot, puis son nom. 

Maintenant, laissez-moi aller de l'avant et de supprimer cela, rm bonjour, Entrez, enlever régulièrement déposer bonjour, oui. Et maintenant, si je tape LS, nous sommes de retour à hello.c. Essayez de ne pas supprimer votre code source. Même si il y a des caractéristiques intégré dans CS50 IDE où vous pouvez passer par votre historique de révision et revenir en arrière dans le temps si vous avez accidentellement supprimer quelque chose, faire garder à l'esprit selon ces invites oui ou non, de ce que vous voulez réellement faire. Et si je monte vers le haut coin gauche de la main ici, tout ce qui reste est hello.c. Donc, il y a des grappes de d'autres commandes que vous peut exécuter dans le monde de Linux, dont l'un est, encore une fois, Make. Et nous allons faire mon programme maintenant comme suit. 

Au lieu de faire clang, au lieu de faire clang-o, Je vais tout simplement taper littéralement, faire bonjour. Et maintenant remarqué, je suis pas tapant make hello.c. Je tape faire bonjour. 

Et ce programme Faire que est livré avec CS50 IDE, et plus généralement avec Linux, est un programme qui est va faire un programme appelé Bonjour. Et il va supposer, par convention, que si ce programme peut être faite, il va être fait à partir d'une source fichier de code se terminant par c dot, hello.c. 

Donc, si je frappe Entrez maintenant, notez que la commande qui est exécuté est en fait encore plus longtemps avant qu'auparavant. Et c'est parce que nous avons préconfiguré CS50 IDE pour avoir quelques fonctionnalités supplémentaires intégrées dans ce on n'a pas besoin pour l'instant, mais bientôt. Mais l'élément clé pour réaliser est maintenant j'ai un programme Bonjour. 

Si je tape à nouveau LS, je avoir un programme de bonjour. Et je peux courir avec dot slash a.out, non, parce que le point entier de cette exercice était dot slash bonjour. Et maintenant je dois mon programme bonjour mondial. Donc, aller de l'avant, nous sommes presque toujours juste va compiler nos programmes en utilisant la commande Marque. Et puis nous allons les exécuter par dot slash et le nom du programme. Mais réaliser ce que font est fait pour vous, est-ce est pas lui-même un compilateur. Il est juste un programme de commodité qui sait comment déclencher un compilateur pour exécuter de telle sorte que vous vous pouvez l'utiliser. 

Quelles autres commandes existent dans Linux, et à son tour le CS50 IDE? Nous verrons bientôt qu'il ya un commande CD, Changer de répertoire. Cela vous permet dans les votre interface de ligne de commande pour aller de l'avant et en arrière, et d'ouvrir des dossiers différents sans utiliser votre souris. 

LS nous avons vu, qui signifie la liste les fichiers dans le répertoire en cours. Faire Dir, vous pouvez probablement commencer à déduire ce que cela signifie maintenant-- créer le répertoire, si vous voulez créer un dossier. RM pour supprimer, RM Dir supprimer directory-- et ceux-ci, à nouveau, sont la ligne de commande équivalents de ce que vous pourrait faire CS50 IDE avec votre souris. Mais vous trouverez bientôt que parfois il est juste beaucoup plus rapide à faire les choses avec un clavier, et, finalement, beaucoup plus puissant. 

Mais il est difficile de faire valoir que tout ce que nous avons fait jusqu'à présent est tout ce que puissant, quand tout nous disons est, bonjour monde. Et, en fait, je l'Hardcoded mots bonjour monde dans mon programme. Il n'y a pas encore de dynamisme. Scratch est un ordre de grandeur plus intéressante la semaine dernière. 

Et donc nous allons y arriver. Prenons un pas vers ce que par mode de certaines de ces fonctions. Donc, non seulement C viennent avec printf, et des grappes d'autres fonctions dont certains que nous allons voir au fil du temps, il n'a pas faire tout ce qui facile dès la sortie de la porte d'entrée dans l'obtention de l'utilisateur. 

En effet, une des lacunes des langages comme C, et même Java et encore d'autres, est que cela ne le rendre facile à obtenir juste des choses comme entiers des utilisateurs, ou des chaînes, des mots, et les phrases, laisser les choses comme seul valeurs à virgule flottante ou nombres réels avec des points décimaux, et vraiment numéros longs, comme nous le verrons bientôt. Donc, cette liste de fonctions ici, ceux-ci sont comme les autres pièces de puzzle Scratch que nous avons pré-installé dans CS50 IDE que nous allons utiliser pour quelques semaines comme des roues de formation de toutes sortes, et éventuellement les enlever, et de regarder sous le capot, peut-être, comment ces choses sont mises en œuvre. 

Mais pour ce faire, nous allons en fait écrire un programme. Laissez-moi aller de l'avant maintenant. Et je vais créer un nouveau déposer en cliquant sur ce petit plus, et en cliquant sur Nouveau fichier. 

Je vais enregistrer cette prochaine un comme, disons, string.c, parce que je veux jouer avec des cordes. Et chaîne dans C est juste une séquence de caractères. Alors maintenant, nous allons aller de l'avant et procédez comme suit. 

Inclure la norme IO.h-- et il se trouve la norme IO, IO signifie simplement entrée et de sortie. Ainsi, il apparaît que cette ligne ici est ce que est le voisin de nous d'utiliser printf. Printf, bien entendu, produit de sortie. Ainsi, afin d'utiliser printf, il se out, vous devez avoir cette ligne de code en haut de votre fichier. 

Et nous reviendrons sur ce cela signifie vraiment avant longtemps. Il se trouve que, dans tout programme de C je vous écris, Je dois commencer avec code qui ressemble à ceci. Et vous remarquerez CS50 IDE et autre développement intégré environnements comme elle, vont essayer mieux ils peuvent terminer votre pensée. En fait, il y a un instant si j'Annuler ce que je viens de faire, je frappe sur Entrée. 

Je me suis alors frappé bouclés ouverte brace, appuyez sur Entrée à nouveau. Et il a fini ma pensée. Il m'a donné une nouvelle ligne, en retrait pas moins pour de belles raisons stylistiques que nous allons voir. Et puis il m'a donné automatiquement qui accolade pour terminer ma pensée. Or, il n'a pas toujours devinez ce que vous voulez faire. Mais en grande partie, il ne vous faire économiser quelques frappes. Donc, il y a un instant, nous avons couru cette program-- bonjour, monde, puis compilé, puis il a couru. Mais il n'y a pas de dynamisme ici. Que faire si nous voulions faire quelque chose de différent? Eh bien, si je voulais réellement obtenir une chaîne de l'utilisateur? Je vais utiliser un morceau de puzzle appelé exactement that-- obtenir chaîne. 

Active en C que lorsque vous ne voulez pas de contribuer à une pièce de puzzle, ou plus exactement à une fonction, vous littéralement juste faire parenthèse ouverte, étroite entre parenthèses. Donc, il est comme si il y a aucune boîte blanche à taper dans. Le bloc de dire avant avait une petite boîte blanche. Nous ne disposons pas que la boîte blanche maintenant. 

Mais quand je l'appelle chaîne get, je vouloir mettre le résultat quelque part. Donc, un paradigme très répandu dans C est de appeler une fonction, comme la chaîne get ici, puis stocker sa valeur de retour. Il est le résultat de son effort dans quelque chose. 

Et quelle est la construire dans la programmation, que ce soit dans Scratch ou maintenant C, que nous peut utiliser pour réellement stocker quelque chose? Appelé il une variable, à droite? Et dans Scratch, nous ne sommes pas vraiment soin ce qui se passait dans les variables. 

Mais dans ce cas, nous faisons réellement. Je vais dire chaîne. Et puis je pourrais appeler ce que je veux. Je vais l'appeler nom, obtient obtenir chaîne. 

Et maintenant, même si vous êtes un peu de nouveau à cela, remarque que je manque quelques détails. J'oublie un point-virgule. Je dois terminer cette pensée. Donc, je vais passer mon curseur, et appuyez sur point-virgule là. Et qu'est-ce que je viens de faire? Dans cette ligne de code, numéro 5 à l'heure actuelle, Je vous appelle chaîne get sans entrées. Donc, il n'y a pas peu de blanc boîte comme le bloc Save a. 

Je dis simplement que, hé, ordinateur, get me une chaîne. Le signe égal est pas vraiment un signe égal, en soi. Il est l'affectation opérateur, ce qui signifie, hey, ordinateur, déplacer la valeur de la droite vers la gauche. Et dans la gauche, je dois le suivant. 

Hey, ordinateur, donne-moi un string-- une séquence de caractères. Et appeler cette chaîne Nom. Et je ne même pas l'appeler Nom. 

Je pourrais l'appeler, de façon classique, quelque chose comme S, un peu comme nous l'habitude d'i appeler la variable i. Mais maintenant, je dois faire quelque chose avec elle. Il serait assez stupide pour essayez de compiler ce code, en cours d'exécution ce programme, même si Je reçois une chaîne, car il est encore juste va dire bonjour monde. 

Mais si je ne veux changer cela. Pourquoi dois-je faire ce pas? Pour cent s, comma s. Et cela est un peu cryptique encore. 

Alors permettez-moi de faire mes variables plus clair. Permettez-moi de nommer ce nom variable. Et nous allons voir si nous ne pouvons pas taquiner à part ce qui se passe ici. 

Donc, sur la ligne de cinq, je reçois une chaîne. Et je stocker cette chaîne, quel que soit l'utilisateur a tapé dans à son clavier, dans une variable appelée Nom. Et il se trouve que printf n'a pas seulement prendre un argument dans le double citations, une entrée entre guillemets. 

Elle peut prendre deux ou trois, ou plus, par exemple que la seconde, troisième ou quatrième, sont tous les noms de variables, ou des valeurs spécifiquement, que vous souhaitez brancher, dynamique, cette chaîne entre guillemets. En d'autres termes, ce qui serait mal à cela? Si je viens de dire bonjour nom, backslash n, a sauvé mon dossier, compilé mon code, et a couru cela, ce qui se passerait? 

Il va juste dire bonjour nom, littéralement N-A-M-E, qui est une sorte de stupide parce que il est pas différent de monde. Donc, quoi que ce soit entre guillemets est ce qui littéralement est imprimé. Donc, si je veux avoir un espace réservé là-bas, En fait, je dois utiliser une syntaxe spéciale. Et il se trouve si vous lisez le documentation de la fonction printf, il vous dira que si vous utilisez pour cent s, vous pouvez substituer une valeur comme suit. 

Après une virgule après cela guillemet double, il vous suffit écrire le nom de la variable que vous voulez brancher dans ce format code, ou spécificateur de format, pour cent s pour les chaînes. Et maintenant, si je l'ai sauvé mon dossier, Je redescends à mon terminal. Et je tape Faire String, parce que, encore une fois, le nom de cette fichier que j'ai choisi avant est string.c. 

Donc, je vais dire Faire chaîne, entrez. Oh mon Dieu, regardez tous les erreurs que nous avons déjà fait. Et ce est-- quoi, ce qui est vraiment comme un, sept programme de ligne de six? Donc, ceci est où il peut très obtenir rapidement écrasante. 

Cette fenêtre de terminal a maintenant juste régurgité un grand nombre de messages d'erreur. Certes, je n'ai pas plus d'erreur messages que j'ai lignes de code. Alors, quoi de neuf? 

Eh bien, la meilleure stratégie à faire quand vous ne rencontrent une écrasante liste des erreurs comme ça, est revenir en arrière, recherchez la commande vous venez de courir, qui dans mon cas est de faire la chaîne. Regardez ce make a fait, et que ce que commande longue Clang, pas grand-chose là-bas. 

Mais le rouge est mauvais. Vert essaie d'être douce et serviable. Mais il est encore mauvais, dans ce cas. Mais où est-il mauvais? 

String.c, ligne de cinq, cinq caractères. Donc, ceci est juste convention commune. Quelque chose signifie quelque chose du côlon numéro de ligne et le nombre de caractères. Erreur, l'utilisation du noir chaîne d'identification. Vouliez-vous dire standard? 

Donc, malheureusement, Clang est d'essayer d'être utile. Mais il ne va pas, dans ce cas. Non, Clang, je ne voulais pas la norme IO. Je voulais dire que sur une seule ligne, oui. 

Mais la ligne de cinq ans est celui-là. Et ne Clang comprendre S-T-R-I-N-G. Il est un identificateur non déclaré, un mot, il a tout simplement jamais vu auparavant. Et c'est parce que C, la langue nous écrivons le code dans ce moment, n'a pas variables appelées chaînes. 

Il ne fait pas, par défaut, le support ce qu'on appelle une chaîne. C'est un morceau de la CS50 jargon, mais très classique. Mais je peux résoudre ce problème de la manière suivante. 

Si j'ajouter une ligne de code au début de ce programme, inclure CS50.h, qui est un autre fichier quelque part à l'intérieur du CS50 IDE, quelque part sur le disque dur, pour ainsi dire, du système d'exploitation Ubuntu que je suis en cours d'exécution, que est le fichier qui est va enseigner l'exploitation système quelle chaîne est, juste comme io.h standard est le fichier dans le système d'exploitation qui est va enseigner ce que printf est. 

En effet, nous aurions obtenu un message très similaire si IO avait admis la norme Io.h et a essayé d'utiliser printf. Je vais donc aller de l'avant et juste Prenez le contrôle L pour effacer mon écran. Ou vous pouvez taper clair et il sera décochez simplement la fenêtre du terminal. Mais vous pouvez toujours revenir en arrière dans le temps. 

Et je vais relancer Faire String. Traversez mes doigts cette fois, Entrée. Oh mon Dieu, il a travaillé. il me montre une longue commande cryptique qui est ce qui fait généré par Clang, mais aucun message d'erreur. Donc réaliser, même si vous pourriez obtenir complètement dépassés par la nombre de messages d'erreur, ça pourrait être cette cascade ennuyeux effet, où Clang ne comprend pas une chose, ce qui signifie alors ne comprend pas le mot suivant, ou la ligne suivante. Et il étouffe tout simplement sur votre code. Mais la solution pourrait être simple. Et toujours se concentrer sur la première ligne de sortie. Et si vous ne le faites pas comprendre, il suffit de regarder pour les mots clés qui pourraient être indices, et le numéro de ligne, et le personnage, où cette erreur pourrait être. 

Maintenant, laissez-moi aller de l'avant et tapez dot slash, string, entrez. Hm, il ne dit pas bonjour quoi que ce soit. Pourquoi? Eh bien, rappelons-le, où est-il en cours d'exécution? 

Il est probablement coincé au moment dans une boucle, si vous voulez, en ligne six, parce Obtenez chaîne par la conception, écrite par le personnel CS50, est littéralement destiné à rester assis là à attendre, et attendre, et en attente d'une chaîne. Tout ce que nous entendons par chaîne est entrée humaine. Donc, vous savez quoi? Laissez-moi aller de l'avant. Et sur un coup de tête, laissez-moi tapez mon nom, David, entrez. Maintenant, j'ai un programme plus dynamique. Il dit bonjour David. 

Si je vais de l'avant et lance ce nouveau, laissez-moi essayer dire le nom Zamila, entrez. Et maintenant, nous avons un programme dynamique. Je ne l'ai pas codé en dur monde. Je ne l'ai pas codé en dur nom, ou David ou Zamila. 

Maintenant, il est beaucoup plus comme les programmes nous le savons, où si elle prend entrée, il produit une sortie légèrement différente. Or, ce ne sont pas les meilleurs expérience utilisateur ou UX. Je lance le programme. 

Je ne sais pas ce que je suis censé à faire, à moins que je regarde effectivement à ou de se rappeler le code source. Faisons donc l'utilisateur l'expérience d'un peu mieux avec le plus simple des choses. Permettez-moi de revenir dans cette programme, et simplement dire printf. 

Et laissez-moi aller de l'avant et de dire le nom, du côlon, et un espace, puis un point-virgule. Et juste pour le plaisir, pas de jeu n. Et c'est délibéré, parce que je ne veux pas l'invite à passer à la ligne suivante. 

Je veux, à la place, faire, faire chaîne recompiler mon code en nouvelle machine Code dot slash chaîne. Ah, ce qui est beaucoup plus jolie. Maintenant, je sais réellement ce que l'ordinateur veut que je fasse, lui donner un nom. 

Je vais donc aller de l'avant et tapez à Rob, entrez, et bonjour, Rob. Donc, se rendre compte, cela est encore, à la fin de la journée, seulement un programme neuf de ligne. Mais nous avons pris ces mesures de bébé. 

Nous avons écrit une ligne avec laquelle nous étaient familiers, printf, bonjour monde. Ensuite, nous défaisions un peu de cela. Et nous avons utilisé la chaîne get. Et nous tournions cette valeur dans une variable. Et puis nous sommes allés de l'avant et amélioré davantage avec une troisième ligne. Et ce processus itératif de logiciel d'écriture est vraiment la clé. En CS50, et dans la vie en général, vous devriez généralement pas asseoir, avoir un programme à l'esprit, et essayer l'écriture toute fichue chose à la fois. 

Il sera, inévitablement, entraîner de manière plus d'erreurs que nous nous avons vu ici. Même moi, à ce jour, en permanence faire d'autres erreurs stupides, sont des erreurs effectivement plus difficile qui sont plus difficiles à comprendre. Mais vous allez faire plus d'erreurs plus lignes de code que vous écrivez tout à la fois. Et cette pratique, écrire un petit morceau de code que vous êtes à l'aise avec, compilez elle, exécuter, tester de façon plus générale, puis passer on-- donc tout comme nous avons gardé marcottage et marcottage la semaine dernière, la construction de quelque chose de très simple à quelque chose de plus complexe, faire la même chose ici. Ne vous asseyez pas, et essayer de écrire tout un problème. En fait, prendre ces mesures de bébé. 

Maintenant, les chaînes ne sont pas tous qui utiles à eux-mêmes. Nous avions en fait, idéalement, comme à quelque chose d'autre dans notre boîte à outils. Donc, nous allons effectivement faire exactement cela. 

Laissez-moi aller de l'avant maintenant et fouetter un programme légèrement différent. Et nous appelons cela int.c, pour entier. Je vais, de même, inclure CS550.h. Je vais inclure la norme IO. Et cela va être assez commun dans ces premiers jours de la classe. 

Et je vais prêt moi-même avec une fonction principale. Et maintenant, au lieu d'obtenir une chaîne, nous allons aller de l'avant et obtenir un int. Appelons-i, et appellent obtenir int, proches parens, point-virgule. Et maintenant, nous allons faire quelque chose avec elle, printf. 

Disons que quelque chose comme bonjour, backslash n, i virgule. Donc, je suis à peu près imitant ce que je faisais il y a un instant. J'ai un espace réservé ici. Je Comma i ici, parce que je veux i brancher dans cette espace réservé. 

Donc, nous allons aller de l'avant et essayer la compilation de ce programme. Le fichier est appelé int.c. Donc, je vais dire, faire int, entrez. Oh mon Dieu, mais pas grand-chose, non? Il y a une erreur. 

Il y a une erreur syntaxique ici, tels que le programme ne peut pas être compilé intérieur int.c, ligne sept ans, caractère 27, le format d'erreur spécifie type char étoiles, quelle qu'elle soit. Mais le type d'argument est int. 

Donc, là aussi, on ne va pas to-- même si aujourd'hui est un lot de matériel, nous allons vous submerger avec absolument toutes les fonctionnalités de C, et la programmation de façon plus générale, en seulement ces quelques premières semaines. Donc, il y a souvent va être le jargon avec lequel vous n'êtes pas familier. Et, en fait, char étoiles est quelque chose nous allons revenir à dans une semaine ou le temps de deux. 

Mais pour l'instant, nous allons voir si nous pouvons analyser les mots qui sont familiers. Formats-- donc nous avons entendu le format spécificateur, le code de format avant. C'est familier. Bien-- mais l'argument est de type int. Attendez une minute, i est un int. 

Peut-être pour cent s en fait a un sens défini. Et, en effet, il le fait. Un entier, si vous voulez printf de lui substituer, vous avez réellement à utiliser un différente spécificateur de format. Et vous ne seriez pas le savoir à moins que quelqu'un vous a dit, ou si vous l'aviez fait auparavant. Mais pour cent i est ce que peut être utilisée par dans printf pour brancher un entier. Vous pouvez également utiliser pour cent d un entier décimal. Mais i est agréable et simple ici. Nous allons donc avec cela. 

Maintenant, laissez-moi aller de l'avant et relancez make int, Entrée. C'est bon, pas d'erreurs. Dot slash OK int--, mauvaise expérience de l'utilisateur, parce que je ne me suis pas dit Que faire. Mais ça va. J'attraper rapidement. 

Et maintenant, laissez-moi aller de l'avant et tapez David, OK, Zamila, Rob. OK, donc ceci est une bonne chose. Cette fois, je suis en utilisant une fonction, un morceau de puzzle, appelé get int. Et il se out-- et nous voir plus tard dans le term-- le personnel de CS50 a mis en œuvre obtenir la chaîne de telle manière que ce sera seulement physiquement obtenir une chaîne pour vous. 

Il a mis en œuvre get int dans de telle sorte qu'il ne sera que obtenir un nombre entier pour vous. Et si vous, l'humain, ne coopèrent pas, il est littéralement juste aller dire relancez, relancez, relancez, littéralement assis là en boucle, jusqu'à ce que vous obligez avec un certain nombre magique, comme 50, et bonjour 50. 

Ou si nous courons ce nouveau et tapez 42, bonjour 42. Et donc la fonction get int à l'intérieur de cette pièce de puzzle est assez logique, assez pensée, de comprendre, ce qui est un mot? Et qu'est-ce qu'un nombre? accepter seulement, en fin de compte, numéros. 

Donc, il se trouve que ce est pas tout à fait expressif. jusque là. Donc, yay, nous la dernière fois est allé assez rapidement dans les jeux de mise en œuvre et l'animation, et des œuvres artistiques dans Scratch. Et ici, nous faisons preuve de contenu avec Bonjour tout le monde, et bonjour 50. 

Il est pas tout à fait inspirant. Et, en effet, ces quelques premiers exemples prendra un certain temps à la rampe dans l'excitation. Mais nous avons tellement plus contrôler maintenant, en fait. Et nous allons très commencer rapidement marcottage au-dessus de ces primitives de base. 

Mais d'abord, nous allons comprendre quelles sont les limites. En fait, l'une des choses Scratch ne facilement laissez-nous faire est vraiment regarder sous le capot, et comprendre ce qu'est un ordinateur est, ce qu'il peut faire, et quelles sont ses limites. Et, en effet, que le manque de compréhension, potentiellement, à long terme peut conduire à notre propre écriture mistakes-- bogues, l'écriture des logiciels que l'insécurité est piraté en quelque sorte. 

Prenons donc quelques pas vers comprendre cela un peu mieux par manière de, disons, l'exemple suivant. Je vais aller de l'avant et mettre en œuvre réel rapide d'un programme appelé Adder. Comme, nous allons ajouter quelques chiffres ensemble. Et je vais coder certains coins ici, et il suffit de copier et coller où je me trouvais avant, juste afin que nous puissions aller plus vite. Alors maintenant, j'ai les débuts de base d'un programme appelé Adder. 

Et nous allons aller de l'avant et à faire cela. Je vais aller de l'avant et disons, INTX obtient obtenir int. Et tu sais quoi? Faisons une meilleure expérience utilisateur. 

Donc, disons simplement que x est, et efficacement invite l'utilisateur à nous donner x. Et puis laissez-moi aller de l'avant et de dire, printf que diriez-vous y est, cette fois-ci attend deux valeurs de l'utilisateur. Et puis nous allons simplement aller de l'avant et disons, printf, la somme de x et y est. Et maintenant, je ne veux pas faire pour cent s. Je veux faire pour cent i, backslash n, puis brancher valeur de somme. 

Alors, comment puis-je m'y prendre? Vous savez quoi? Je sais comment utiliser les variables. Permettez-moi de déclarer une nouvelle, int z. 

Et je vais faire une supposition ici. S'il y a des signes égaux dans ce la langue, peut-être que je peux juste faire x plus y, tant que je termine mon pensée avec un point-virgule? Maintenant, je peux revenir ici, branchez z, terminer cette pensée avec un point-virgule. Et nous allons voir maintenant, si ceux-ci séquences de lines-- x est obtenir int. Y est d'obtenir int. 

Ajouter x et y, stocker la valeur dans Z- donc, encore une fois, rappelez-vous le signe égal est pas égale. Il est l'affectation de droite à gauche. Et nous allons imprimer que la somme de x et y est pas littéralement z, mais ce qui est à l'intérieur de z. Faisons donc Adder - nice, aucune erreur cette fois. Dot slash Adder, entrez, x va être 1. 

Y va être 2. Et la somme de x et y est 3. Donc, c'est tout beau et bon. 

Donc, vous imaginez que les mathématiques devraient travailler dans un tel programme. Mais tu sais quoi? Est-ce variable ligne 12, voire nécessaire? Vous ne devez pas prendre l'habitude de simplement stocker des choses dans les variables juste parce que vous pouvez. Et, en fait, il est généralement mauvaise conception réfléchie si vous créez une variable, appelée z dans ce cas, le stockage en elle quelque chose, puis immédiatement l'utiliser, mais jamais plus. Pourquoi donner quelque chose d'un nom comme z si vous êtes littéralement va utiliser chose qu'une seule fois, et ainsi proximale à l'endroit où vous avez créé en premier lieu, si proche en termes de lignes de code? Donc, vous savez quoi? Il se trouve que C est assez flexible. Si je veux vraiment plug-in ici les valeurs, Je ne ai pas besoin de déclarer une nouvelle variable. Je ne pouvais tout simplement plug-in x plus y, parce que C comprend arithmétique et opérateurs mathématiques. 

Donc, je peux simplement dire, faire les mathématiques, x plus y, quels que soient ces valeurs sont, branchez le résultat entier dans cette chaîne. Donc, ce serait peut-être, bien que une seule ligne plus courte, une meilleure conception, un meilleur programme, parce qu'il ya moins de code, donc moins pour moi de comprendre. Et il est aussi tout simplement plus propre, dans la mesure où nous ne sommes pas l'introduction de nouveaux mots, de nouveaux symboles, comme z, même si elles ne sont pas vraiment servira beaucoup d'un but. 

Malheureusement, les mathématiques ne sont pas tout ce que parfois fiables. Allons de l'avant et faire cela. Je vais aller de l'avant maintenant et faire ce qui suit. 

Faisons printf, pour cent i, plus pour cent i, i serai pour cent, backslash n. Et je vais faire this-- xyx plus y. Donc, je vais juste réécrire ce peu différemment ici. Permettez-moi de faire une vérification de la santé mentale rapide. Encore une fois, il ne faut pas prendre de l'avance de nous-mêmes. Faire additionneur, point barre oblique additionneur. x vaut 1, y vaut 2, 1 + 2 est égal à 3. Donc, ce qui est bon. Mais nous allons compliquer cela maintenant un peu, et créer un nouveau fichier. 

Je vais appeler celui-ci, dire, ints, pluriel pour les entiers. Permettez-moi de commencer où je me trouvais il y a un instant. Mais maintenant, nous allons faire quelques autres lignes. Laissez-moi aller de l'avant et de faire ce qui suit, printf, pour cent i, moins pour cent i, est pour cent i, virgule x, virgule yx moins y. Je suis donc un peu faire mathématiques différent là-bas. Faisons un autre. Donc, cent pour cent i fois i est pour cent i, backslash n. Voyons plug-in x et y, et x fois y. Nous allons utiliser l'astérisque sur votre ordinateur pour les temps. 

Vous n'utilisez pas x. x est un nom de variable ici. Vous utilisez l'étoile pour la multiplication. Faisons un de plus. Printf pour cent I, divisée en pour cent i, est pour cent i, backslash n. xy divisé par Y- de sorte que vous utilisez la barre oblique en C de faire la division. Et nous allons faire un autre. Reste de pour cent i, divisé en pour cent i, est pour cent i. xy-- et maintenant reste est ce qui reste. Lorsque vous essayez diviser un le dénominateur dans un numérateur, combien il en reste plus que vous ne pouviez pas diviser out? 

Donc, il n'y a pas vraiment, nécessairement, un symbole nous avons utilisé à l'école primaire pour cela. Mais il y en C. Vous pouvez dire x modulo y, où ce signe pour cent dans ce context-- prêter à confusion lorsque vous êtes à l'intérieur des guillemets doubles, intérieur de printf, pour cent est utilisé comme indicateur de format. 

Lorsque vous utilisez pour cent à l'extérieur de que, dans une expression mathématique, il est l'opérateur modulo modulaire arithmetic-- pour nos besoins ici, signifie simplement, quelle est la reste de x divisée par y? Si x est divisé par y x y slash. Quel est le reste de x divisé par y? Il est x y mod, en tant que programmeur dirait. 

Donc, si je faisais pas d'erreur ici, laissez-moi aller de l'avant et de faire ints, pluriel, gentil, et dot ints slash. Et allons-y et faire, disons, 1, 10. Tout droit, 1 plus 10 est 11, chèque. 1 moins 10 est négative 9, vérifier. 

1 fois 10 est 10, chèque. 1 divisé par 10 est-- OK, nous allons sauter celui-là. Le reste de 1 divisé par 10 est égal à 1. C'est correct. Mais il y a un bug ici. 

Donc, celui que je mets ma remettre, pas correct. Je veux dire, il est proche de 0. 1 divisé par 10, vous savez, si nous sommes couper quelques coins, bien sûr, il est nul. Mais il devrait vraiment être 1/10, 0,1 ou 0,10, 0,1000, ou ainsi de suite. 

Il ne devrait pas vraiment être nul. Eh bien, il se trouve que l'ordinateur est faire littéralement ce que nous avons dit de faire. Nous faisons des mathématiques comme x divisé par y. Et x et y, par les lignes du code précédent, sont des nombres entiers. 

En outre, sur la ligne 15, nous sommes dire printf, hé, printf plug-in un nombre entier, plug-in un nombre entier, plug-in un integer-- spécifiquement x, puis y, puis x divisé par y. x et y sont des entiers. Nous sommes bien là. 

Mais ce qui est x divisé par x? x divisé par y devrait être, mathématiquement, 1/10, ou 0,1, qui est un nombre réel, un nombre réel ayant, potentiellement, un point décimal. Il est pas un entier. 

Mais ce qui est le plus proche entier à 10/01, ou 0,1? Oui, ce genre de zéro. 0.1 est comme ça beaucoup. Et 1 est autant. Donc 1/10 est plus proche de 0 qu'il est à un. 

Et donc ce que C est fait pour us-- sorte de parce que nous lui avons dit to-- est tronquant cet entier. Il prend la valeur, qui est à nouveau censé être quelque chose comme 0.1000, 0 et ainsi de suite. Et il est tout tronquant après la virgule de sorte que tout cela choses, parce qu'il ne intégrer la notion d'un nombre entier, qui est juste un nombre comme négatif 1, 0, 1, de haut en bas, il jette tout après le point parce que vous décimales ne peut pas adapter à un point décimal en un nombre entier par définition. 

Donc, la réponse est ici zéro. Alors, comment pouvons-nous résoudre ce problème? Nous avons besoin d'une autre solution tous ensemble. Et nous pouvons le faire, comme suit. 

Laissez-moi aller de l'avant et de créer une nouvelle fichier, celui-ci a appelé floats.c. Et enregistrez-le ici dans le même répertoire, float.c. Et laissez-moi aller de l'avant et copier une partie de ce code à partir plus tôt. 

Mais au lieu d'obtenir un int, faisons cela. Donnez-moi une valeur à virgule flottante appelé x. où un point flottant la valeur est juste littéralement quelque chose avec un point flottant. Il peut se déplacer vers la gauche, vers la droite. Il est un nombre réel. 

Et laissez-moi appeler pas obtenir int, mais obtenir flotteur, qui a également été parmi le menu des options de la bibliothèque C250. Nous allons y changer à un flotteur. Donc, cela devient obtenir flotteur. 

Et maintenant, nous ne voulons pas brancher ints. Il se trouve que nous devons utiliser pour cent f pour float, pour cent f pour flotteur, et maintenant il sauver. Et maintenant, les doigts croisés, faire flotteurs, gentil, flotteurs slash dot. x va être un 1. y Va être 10 à nouveau. 

Et, bien, OK mon addition est correcte. J'espérais plus, mais j'oublié de l'écrire. Allons donc et corriger cette erreur logique. 

Allons de l'avant et de saisir ce qui suit. Nous allons juste faire un petit copier-coller. Et je vais dire moins. 

Et je vais dire fois. Et je vais dire divisée. Et je ne vais pas faire modulo, qui ne sont pas aussi germane ici, divisé par f, et les temps plus-- OK, nous allons le faire à nouveau. 

Faire des flotteurs, flotteurs slash dot, et 1, 10, et-- agréable, non, OK. Donc, je suis un idiot. Donc, ce qui est très commun en informatique de faire des erreurs stupides comme ça. 

Pour des fins pédagogiques, ce que je voulais vraiment faire a été changer science ici pour atteindre plus, à moins, à l'époque, et de diviser, comme vous nous l'espérons remarqué au cours de cet exercice. Alors maintenant, nous allons re-compiler cette programme, faire des flotteurs slash dot. 

Et pour la troisième fois, nous allons voir si elle répond à mes attentes. 1, 10, entrez, oui, OK, 1.000, divisé par 10,000, est 0,100000. Et il se trouve que nous pouvons contrôler le nombre chiffres sont après ces chiffres après la virgule. En fait, nous le ferons. Nous reviendrons à cela. 

Mais maintenant, en fait, le calcul est correct. Donc, encore une fois, quelle est la livraison ici? Il se trouve que, dans C, il y a non seulement juste strings-- et, en fait, il n'y a pas vraiment, parce que nous ajouter ceux avec la bibliothèque CS50. Mais il n'y a pas seulement ints. 

Il existe également des flotteurs. Et il se trouve un tas d'autres données types aussi, que nous allons utiliser avant longtemps. Active si vous voulez un seul caractère, pas une chaîne de caractères, vous pouvez simplement utiliser un caractère. 

Avère que si vous voulez un bool, une valeur booléenne, vrai ou faux seulement, grâce à la bibliothèque de CS50, nous avons ajouté à C le type de données bool ainsi. Mais il est présent aussi dans beaucoup d'autres langues. Et il se trouve que, parfois, vous besoin de plus grands nombres puis viennent par défaut avec ints et flotteurs. 

Et, en fait, un double est un nombre qui utilise non pas 32 bits, mais 64 bits. Et un long est un nombre qui utilise pas 32, les bits, mais 64 bits, respectivement, pour virgule flottante des valeurs et des nombres entiers, respectivement. Donc, nous allons effectivement maintenant voir en action. 

Je vais aller de l'avant ici et concocter un autre programme. Ici, je vais aller de l'avant et ne comprennent CS50.h. Et laissez-moi aller, inclure la norme io.h. 

Et vous remarquerez quelque chose génial qui se passe ici. Il est pas le codage couleur des choses dans de la même manière comme avant. Et il se trouve, c'est parce que je ont pas donné la chose un nom de fichier. 

Je vais appeler celui-ci sizeof.c, et cliquez sur Enregistrer. Et remarquez ce qui arrive à mon très Code blanc sur cette toile de fond noir. Maintenant, au moins, il y a certains pourpre là-dedans. Et il est la syntaxe en surbrillance. 

C'est parce que, tout simplement, je l'ai dit l'IDE quel type de fichier il est en lui donnant un nom, et spécifiquement une extension de fichier. Maintenant, nous allons aller de l'avant et de faire cela. Je vais aller de l'avant et très il suffit d'imprimer le bool following-- est pour cent LU. 

Nous y reviendrons que, dans un instant. Et puis je vais taille d'impression de bool. Et maintenant, juste pour sauver moi un peu de temps, je suis va faire ensemble tas de cela à la fois. Et, précisément, je vais changer à un omble chevalier et l'omble. Celui-ci, je vais changer à un double et un double. 

Celui-ci, je vais changer à un flotteur et un flotteur. Celui-ci, je vais changer pour un int et un int. Et celui-ci, je vais pour passer à un long. Et il est toujours prendre depuis longtemps, bien longtemps. 

Et puis, enfin, je donnai moi-même un trop grand nombre, chaîne. Il se trouve que dans C, il y a l'opérateur spécial appelé taille qui est littéralement va, lorsqu'il est exécuté, nous dire la taille de chacune de ces variables. Et cela est une façon, maintenant, nous pouvons nous connecter de retour à la discussion de la semaine dernière des données et de la représentation. 

Laissez-moi aller de l'avant et de compiler la taille de la taille de slash dot de. Et nous allons voir. Il se trouve que, dans C, spécifiquement sur CS50 IDE, plus précisément sur la système d'exploitation Ubuntu, qui est une exploitation 64 bits système dans ce cas, un bool va utiliser un octet d'espace. Voilà comment la taille est mesurée, pas en bits, mais en octets. Et rappeler qu'un octet est de huit bits. Ainsi, un bool, même si vous techniquement seulement besoin d'un 0 ou 1, il est un peu inutile comment nous avons implémenté. Il va réellement utiliser ensemble byte-- donc tous les zéros, sont peut-être tous ceux, ou quelque chose comme ça, ou juste un 1 parmi les huit bits. 

Un char, quant à lui, utilisé pour un caractère comme un caractère Ascii par la semaine dernière, va être un caractère. Et ce synchs avec notre notion de étant pas plus de 256 bits-- plutôt, synchs avec elle étant pas plus de 8 bits, nous donne jusqu'à 256 valeurs. Un double va être de 8 octets ou 64 bits. 

Un flotteur est 4. Un int est 4. Une longue, est longue 8. Et une chaîne est 8. Mais ne vous inquiétez pas à ce sujet. Nous allons décoller cette couche. Il se trouve, les chaînes peuvent être supérieure à 8 octets. 

Et, en effet, nous avons écrit cordes déjà, bonjour monde, plus de 8 octets. Mais nous y reviendrons que, dans un instant. Mais la prise de distance ici est le suivant. 

Tout ordinateur ne dispose que d'un fini la quantité de mémoire et de l'espace. Vous ne pouvez stocker autant de fichiers sur votre Mac ou PC. Vous ne pouvez stocker autant de programmes RAM en cours d'exécution à la fois, nécessairement, même avec de la mémoire virtuelle, parce vous avez une quantité finie de RAM. 

Et juste pour picture-- si vous ne l'avez jamais ouvert un ordinateur portable ou ordonné mémoire supplémentaire pour un ordinateur, vous pourrait ne pas savoir que à l'intérieur de votre ordinateur est quelque chose qui ressemble un peu comme ça. Donc, ceci est juste une société commune nommée Crucial qui fait RAM pour les ordinateurs. Et RAM est le cas des programmes vivre pendant qu'ils courent. 

Ainsi, sur chaque Mac ou PC, lorsque vous double cliquez sur un programme, et il ouvre, et il ouvre un certain document Word ou quelque chose comme ça, il stocke temporairement dans RAM, parce que la RAM est plus rapide que votre disque dur, ou votre disque d'état solide. Donc, il est juste là où les programmes vont pour vivre quand ils sont en cours d'exécution, ou lorsque les fichiers sont utilisés. 

Donc, vous avez des choses qui ressemblent comme celui-ci à l'intérieur de votre ordinateur portable, ou légèrement plus grandes choses à l'intérieur de votre bureau. Mais la clé est que vous avez seulement nombre fini de ces choses. Et il y a seulement une quantité finie de matériel assis sur ce bureau droit ici. 

Alors, sûrement, nous ne pouvons pas stocker infiniment longs numéros. Et pourtant, si vous pensez revenir à école primaire, le nombre de chiffres peut vous avez le droit d'un point décimal? Pour cette question, combien de chiffres peut vous avez à la gauche d'un point décimal? Vraiment, infiniment nombreux. 

Maintenant, nous, les humains pourraient seulement savoir comment prononcer millions, et milliards, billions de dollars, et quadrillions et quintillion. Et je pousse les limites de mon understanding-- ou my-- Je comprends numéros, mais mon Prononciation de nombres. Mais ils peuvent obtenir infiniment grand avec un nombre infini de chiffres à gauche ou à droite d'un point décimal. 

Mais les ordinateurs ont seulement quantité finie de mémoire, un nombre fini de transistors, un nombre fini d'ampoules à l'intérieur. Alors qu'est-ce qui se passe quand vous manquez d'espace? En d'autres termes, si vous penser à la semaine dernière lorsque nous avons parlé des numéros étant eux-mêmes représentés en binaire, supposons que nous avons cette valeur de 8 bits ici. 

Et nous avons sept de 1 et un 0. Et supposons que nous voulons à ajouter 1 à cette valeur. Ceci est un très grand nombre en ce moment. 

Ceci est 254, si je me souviens le calcul de la semaine dernière à droite. Mais si je change que l'extrême droite 0 à 1? Le nombre entier, de Bien sûr, devient huit des 1. Nous sommes donc toujours bon. 

Et cela représente probablement 255, selon que le contexte il pourrait en fait représenter un nombre négatif. Mais plus sur une autre fois. Cela se sent comme il est à propos de aussi haut que je peux compter. 

Maintenant, il est seulement 8 bits. Et mon Mac, sûrement, a ainsi plus de 8 bits de mémoire. Mais il n'a fini. Ainsi, le même argument vaut, même si nous avoir plus de celles-ci sur l'écran. 

Mais ce qui se passe si vous êtes stocker ce nombre, 255, et vous voulez compter 1 peu plus élevé? Vous voulez aller 255-256. Le problème, bien sûr, est que si vous commencer à compter à zéro comme la semaine dernière, vous ne pouvez pas compter aussi élevé comme 256, et encore moins 257, et encore moins 258, m parce que qui se passe lorsque vous ajoutez un 1? Si vous faites l'ancienne école primaire approche, vous mettez un 1 ici, puis 1 plus 1 est 2, mais c'est vraiment un zéro, vous portez le 1, porter le 1, porter le 1. Toutes ces choses, ces 1 de, aller à zéro. Et vous vous retrouvez, oui, comme quelqu'un souligné, un 1 sur le côté gauche. Mais tout ce que vous pouvez en fait voir et tenir en mémoire est seulement huit des 0, ce qui est à dire à un moment donné si vous, un ordinateur, essayé de compter assez haut, vous êtes va enrouler autour, il semblerait, à zéro, ou peut-être même négative numéros, qui sont encore plus bas que zéro. 

Et nous pouvons sorte de voir cela. Laissez-moi aller de l'avant et d'écrire un véritable programme rapide ici. Laissez-moi aller de l'avant et d'écrire un programme appelé débordement. Inclure CS50.h, comprennent norme IO.h-- oh, J'ai vraiment raté ma coloration syntaxique. Donc, nous allons l'enregistrer comme overflow.c. 

Et void-- principale maintenant int et avant longtemps, nous allons revenir à expliquer pourquoi nous continuons à écrire void main int. Mais pour l'instant, nous allons faire tout elle, en prenant pour acquis. Allons me donner un int, et l'initialiser à 0. 

Nous allons ensuite faire pour int i obtenir zero-- en fait, nous allons faire une boucle infinie et de voir ce qui se passe. Bien vrai, alors nous allons imprimer n est pour cent i, backslash n, plug-in n. Mais, maintenant, nous allons faire n obtient n + 1. 

En d'autres termes, à chaque itération de cette boucle infinie, Prenons la valeur de n, et ajouter 1 à elle, puis stocker le résultat de retour n sur la gauche. Et, en fait, nous avons vu la syntaxe légèrement comme cela, brièvement. Une astuce est cool place d'écrire tout ça, vous pouvez réellement dire un n plus égal à 1. 

Ou si vous voulez vraiment être de fantaisie, vous pouvez dire n plus plus point-virgule. Mais ces deux derniers sont juste ce que nous appellerions le sucre syntaxique pour la première chose. 

La première chose est plus explicite, tout à fait bien, tout à fait correct. Mais ce qui est plus commun, je vais le dire. Donc, nous allons faire cela pour un instant. 

Nous allons maintenant faire trop-plein, qui sonne plutôt inquiétant, débordement de slash dot. Voyons voir, n commence à faire assez grand. Mais nous allons réfléchir, la taille peut n obtenir? 

n est un entier. Nous avons vu il y a quelques instants avec la taille de exemple qu'un int est de quatre octets. Nous savons depuis la semaine dernière, quatre octets est 32 bits, parce que 8 fois 4, c'est 32. Cela va être de 4 milliards de dollars. 

Et nous sommes jusqu'à 800.000. Cela va prendre une éternité pour compter aussi haut que je le peux. Je vais donc aller de l'avant, comme vous pouvez avant longtemps, et appuyez sur Commande C-- franchement, Contrôle C, beaucoup, où le contrôle C généralement des moyens d'annuler. Malheureusement, parce que cette est en cours d'exécution dans le nuage, parfois le nuage est cracher tellement de choses, tellement sortie, ça va prendre un peu de temps pour mon entrée pour obtenir le nuage. Donc, même si je frappe Contrôle C il y a quelques secondes, c'est certainement le côté effet d'une boucle infinie. 

Et dans ce cas, nous sommes va laisser ce soit. Et nous allons ajouter un autre fenêtre de terminal ici avec le plus, qui bien sûr ne comme ça, car il est toujours penser. Et nous allons aller de l'avant et être un peu plus raisonnable. 

Je vais aller de l'avant et de faire ce qu'un nombre fini de fois. Nous allons utiliser une boucle, dont je parlais tout à l'heure. Faisons cela. Donnez-moi une autre variable int i obtient 0. i est inférieur à, disons, 64 i ++. Et maintenant, laissez-moi aller de l'avant et d'imprimer out n est pour cent i, virgule n. Et puis n-- cela est encore va prendre une éternité. Faisons cela. 

n obtient n fois 2. Ou nous pourrions être de fantaisie et font parfois égale 2. Mais disons simplement que n lui-même égal à égal, 2 fois. En d'autres termes, dans ce la nouvelle version du programme, Je ne veux pas attendre indéfiniment à partir comme 800.000 à 4 milliards. Finissons-en avec. 

Disons en fait le double n à chaque fois. Ce qui, le rappel, le doublement est le en face d'avoir, bien sûr. Et alors que la semaine dernière, nous avons quelque chose de nouveau, et encore, et encore une fois, super rapide, doublement va sûrement nous faire de 1 à la plus grande possible valeur que nous pouvons compter pour int. 

Donc, nous allons faire exactement cela. Et nous reviendrons à cela avant longtemps. Mais cela, encore une fois, est tout comme le bloc de répétition dans Scratch. Et vous utilisez cette avant longtemps. 

Cela signifie simplement le nombre de zéro jusqu'à, mais pas égale, à 64 ans. Et à chaque itération de cet boucle, gardez simplement incrémenter i. Donc i ++ - et cette construction générale sur la ligne 7 est juste un moyen super commun de répéter quelques lignes de code, un certain nombre de fois. Quelles lignes de code? Ces accolades, comme vous peut-être glanées à partir de maintenant, moyens, procédez comme suit. 

Il est dans Scratch comme, quand il a les blocs jaunes et d'autres couleurs ce genre de embrasser ou serrer les autres blocs. Voilà ce que ces bouclés accolades font ici. Donc, si je suis ma syntaxe droite- vous peut voir le symbole de la carotte en C des moyens c'est combien de fois je suis essayer de résoudre ce problème. Donc, nous allons débarrasser de celui-là tout à fait, et fermer cette fenêtre. Et nous allons utiliser la nouvelle. Faire débordement, slash dot débordement, Entrez, tout droit, il est mauvais au premier abord. Mais nous allons revenir en arrière dans le temps, parce que je l'ai fait 64 fois. 

Et remarquez la première fois, n est 1. Une deuxième fois, n est égal à 2, puis 4, puis 8, puis 16. Et il semble que, dès que Je reçois à peu près 1 milliard, si je double encore une fois, que devrait me donner 2 milliards. Mais il se trouve, il est à droite sur le point. 

Et il déborde effectivement un int de 1 milliard à peu près négatif 2 milliards, en raison d'un nombre entier, à la différence du nombre nous ont été en supposant que la semaine dernière, peut être à la fois positif et négatif dans la réalité et dans un ordinateur. Et si au moins un de ces bits est effectivement volés. Donc, nous avons vraiment avons seulement 31 bits, ou 2 milliards de valeurs possibles. 

Mais pour l'instant, les plats à emporter est tout à fait tout simplement, quelles que soient ces chiffres sont et quel que soit le calcul est, quelque chose de mauvais arrive à terme, parce que finalement vous essayez de permuter les bits une fois de trop. Et vous allez effectivement de tous de 1 à peut-être tous les 0, ou peut-être juste un autre motif que ce De toute évidence, selon le contexte, peut être interprété comme un nombre négatif. Et il semblerait que le plus élevé que je peut compter dans ce programme particulier est seulement environ 1 milliard. Mais il y a une solution partielle ici. Vous savez quoi? 

Permettez-moi de changer d'un int à un long long. Et laissez-moi aller de l'avant ici et say-- je vais avoir de changer cela à un unsigned long. Ou, voyons, je ne me souviens moi-même. 

Allons de l'avant et de faire déborder. Non, c'est pas, LLD, je vous remercie. Alors parfois Clang peut être utile. Je ne me souviens pas ce que le format spécificateur était pendant une longue période. 

Mais, en effet, Clang m'a dit. Le vert est une sorte de bon, signifie encore que vous avez fait une erreur. Il est devine que je voulais dire LLD. 

Alors laissez-moi prendre c'est des conseils, une longue longue nombre décimal, sauf que. Et permettez-moi de le relancer, dot slash débordement, Entrée. Et maintenant, ce qui est cool est la suivante. 

Si je fais défiler dans le temps, nous commençons toujours comptage au même place-- 1, 2, 4, 8, 16. Remarquez, nous obtenons tous les chemin jusqu'à 1 milliard. Mais alors nous obtenons en toute sécurité à 2 milliards. 

Puis nous arrivons à 4 milliards, puis 8 milliards, 17 milliards. Et nous allons plus haut, et de plus en plus haut. Finalement, cela, aussi, les pauses. 

Finalement, avec un long temps, qui est la valeur de 64 bits, non une valeur 32 bits, si vous comptez trop élevé, vous enveloppez autour de 0. Et dans ce cas, nous nous trouvons se retrouver avec un nombre négatif. 

Donc, cela est un problème. Et il se trouve que cette problème est pas tout à fait mystérieux. Même si je l'ai délibérément induite avec ces erreurs, il se trouve que nous le voyons genre de tous autour de nous, ou du moins certains d'entre nous. 

Donc, dans Lego Star Wars, si vous avez déjà joué le jeu, il se trouve que vous pouvez faire le tour briser les choses dans LEGO monde, et la collecte des pièces, essentiellement. Et si vous avez déjà joué ce jeu beaucoup trop de temps, que cet individu sans nom ici a fait, le nombre total des pièces de monnaie que vous pouvez recueillir est, il semblerait, 4 milliards. 

Maintenant, avec il est effectivement arrondi. Donc, LEGO a essayé de garder les choses convivial. Ils ne le font pas exactement 2 à la puissance 32, par la semaine dernière. Mais 4 milliards est une raison. Il semble, sur la base de cette information, que LEGO, et l'entreprise qui fait de ce logiciel lui-même, a décidé que le nombre maximal de pièces de monnaie l'utilisateur peut accumuler est, en effet, 4 milliards, parce qu'ils ont choisi dans leur code de ne pas utiliser un long, apparemment, mais juste un nombre entier, un unsigned nombre entier, seul un nombre entier positif, dont valeur max est à peu près cela. Eh bien, voici un autre drôle. Ainsi, dans la civilisation de jeu, qui certains d'entre vous connaissent peut-être, avec il se trouve qu'il ya quelques années, il avait un bug dans ce jeu dans lequel si vous avez joué le rôle de Gandhi dans le jeu, au lieu de lui être très pacifiste, la place était incroyablement, incroyablement agressif, dans certaines circonstances. En particulier, la façon dont la civilisation œuvres est que si vous, le joueur, adopter la démocratie, votre Le score agressivité obtient décrémenté par deux, donc moins moins, puis minus. 

Donc, vous soustrayez 2 de votre itérer réelle. Malheureusement, si votre itérer est initialement 1, et vous soustraire 2 de celui-ci après l'adoption de la démocratie comme Gandhi ici pourrait ont fait, parce qu'il était très passive-- 1 sur l'échelle de l'agressivité. Mais s'il adopte la démocratie, puis il va de 1 à 1 négative. 

Malheureusement, ils étaient en utilisant des nombres non signés, ce qui signifie qu'ils traitaient même négative numéros comme si elles étaient positives. Et il se trouve que la équivalent positif de négatif 1, dans des programmes informatiques typiques, est 255. Donc, si Gandhi adopte la démocratie a, et donc son score d'agressivité a diminué, il roule en fait autour de 255 et lui le plus fait caractère agressif dans le jeu. Donc, vous pouvez Google sur ce sujet. Et ce fut, en effet, un bug de programmation accidentelle, mais ce n'est entré tout à fait la tradition depuis. 

C'est tout amusant et mignon. Plus effrayant est quand même dispositifs du monde réel, et non pas des jeux, avoir ces mêmes insectes. En fait, il y a un an un article est venu à propos du Boeing 787 Dreamliner. 

Et l'article au premier coup d'oeil lit un peu mystérieux. Mais il a dit cela, un logiciel vulnérabilité dans Boeing nouveau Dreamliner jet 787 a le potentiel de causer des pilotes perdre le contrôle de l'aéronef, le cas échéant à la mi-vol, les fonctionnaires de la FAA compagnies aériennes a récemment averti. Ce fut la détermination qu'un modèle 787 avion qui a été alimenté en continu pendant 248 jours peut perdre tout courant alternatif, AC, puissance électrique due au générateur des unités de commande, CGU, simultanément entrer dans le mode sans échec échec. Il est une sorte de me perdre. Mais le mémo a déclaré, OK, maintenant je suis que, la condition est provoquée par un logiciel Le compteur interne de le contrôle du générateur unités qui débordera après 248 jours de puissance continue. Nous publions cette remarquer pour prévenir la perte Tout courant alternatif électrique puissance, ce qui pourrait entraîner la perte de contrôle de l'avion. 

Donc, littéralement, il y a un certain nombre entier, ou un certain type de données équivalent, utilisé dans les logiciels dans un avion réel que si vous gardez votre avion assez longtemps, qui, apparemment, peut être le cas si vous êtes juste en cours d'exécution les débrancher constamment et jamais votre avion, il semble, ou laissant ses batteries meurent, finira par compter, et jusqu'à, et, et, et, et vers le haut. 

Et, par nature, un quantité finie de mémoire débordera, le retour à zéro ou une valeur négative, un effet secondaire qui est le effroyablement réalité réelle que le plan pourrait avoir besoin être redémarré, efficacement, ou pourrait tomber, pire, comme il vole. Donc, ce genre de questions sont toujours avec nous, even-- ce fut un article 2015, d'autant plus effrayant quand vous faites pas nécessairement comprendre, apprécier, ou d'anticiper ces types d'erreurs. 

Donc, il se trouve qu'il ya un autre mauvaise chose à propos de la représentation des données. Il se trouve que même les flotteurs sont genre de défauts, parce que les flotteurs, aussi, Je proposai de 32 bits, ou peut-être 64 si vous utilisez un double. Mais c'est encore finie. 

Et le problème est que si vous le pouvez mettre un nombre infini de nombres après la virgule décimale, il n'y a aucun moyen que vous peut représenter tout le possible chiffres qui nous ont appris dans le grade école peut exister dans le monde. Un ordinateur, en substance, doit choisir un sous-ensemble de ces chiffres pour représenter avec précision. 

Maintenant, l'ordinateur peut rond peut-être un peu, et peut vous permettre d'environ magasin tout numéro que vous pourriez probablement vouloir. Mais intuitivement, si vous un nombre fini de bits, vous ne pouvez les permuter à bien des égards finis. Donc, vous ne pouvez pas peut-être utiliser un nombre fini de permutation de bits, motifs de zéros et de uns, pour représenter un infini nombre de numéros, ce qui suggère que les ordinateurs pourraient très bien être de nous mentir parfois. 

En fait, nous allons le faire. Permettez-moi de revenir en CS50 IDE. Laissez-moi aller de l'avant et créer un petit programme appelé Imprécision, pour montrer que les ordinateurs sont, en effet, imprécis. 

Et laissez-moi aller de l'avant et commencer par une partie de ce code à partir d'avant, et maintenant il suffit de faire ce qui suit. Laissez-moi aller de l'avant et faire printf, pour cent f, backslash n, 1 divisé par 10. En d'autres termes, nous allons plonger plus profondément à 1/10, comme 1 et divisé par 10. Certes, un ordinateur peut représenter 1/10. 

Donc, nous allons aller de l'avant et de faire l'imprécision. Voyons voir. Format spécifie le type double. Mais l'argument est de type int. Qu'est-ce qui se passe? 

Oh, intéressant, il est donc un leçon de devant. Je veux dire, hé, salon de l'informatique moi un flotteur avec pour cent f. Mais je lui donne 2 ints. Donc, il se trouve, je peux fixer cela dans un couple des manières. 

Je ne pouvais tout simplement tourner un dans 1.0, et 10 dans 10,0, ce qui serait, en effet, ont pour effet de convertir les en floats-- encore, espérons le même numéro. Ou il se trouve qu'il ya quelque chose nous verrons à nouveau avant longtemps. Vous pourriez lancer les numéros. 

Vous pouvez, en utilisant cette parenthèse expression, vous pouvez dire, hey, ordinateur, prendre cette 10, que je connais est un int. Mais le traiter, s'il vous plaît, comme si elle est un flotteur. Mais cela se sent inutilement complexe. 

Pour nos besoins d'aujourd'hui, disons simplement littéralement rendent les valeurs à virgule flottante avec un point décimal, comme celui-ci. Laissez-moi aller de l'avant et relancez, fais imprécision, bon, slash dot imprécision, entrez. OK, nous sommes à la recherche bonne. 

1 divisé par 10, selon mon Mac ici, est, en effet, 0,100000. Maintenant, on m'a enseigné à l'école primaire, il devrait être un nombre infini de 0 de. Donc, nous allons au moins essayer de voir certains de ceux-ci. Il se trouve que printf est un peu encore plus sophistiqué que nous utilisons. Il se trouve que vous ne devez pas spécifier juste pour cent f, ou tout simplement pour cent i. Vous pouvez réellement spécifier certaines options de contrôle ici. 

Plus précisément, je vais à-dire, hé, printf, me montrer en fait 10 points décimaux. Donc, il semble un peu bizarre. Mais vous dites pour cent, point, combien de numéros Voulez-vous voir après la point décimal, puis f pour plat, juste parce que ce ce que dit la documentation. Laissez-moi aller de l'avant et sauver ça. 

Et remarque aussi, je suis en train de fatigué de retaper les choses. Donc, je suis juste mise en place et la flèche vers le bas sur mes clés ici. Et si je continue à frapper, vous peut voir toutes les commandes que je fait, ou mal fait. 

Et je vais aller de l'avant dès maintenant et pas vraiment l'utiliser, apparemment. Faire imprécision, dot slash imprecision-- donc ce qu'on m'a appris à l'école primaire vérifie. Même si je l'imprime à 10 décimales le place, en effet, est 0,10000. Mais tu sais quoi? 

Allons un peu gourmand. Disons que, comme, montrez-moi 55 points après la virgule. Nous allons vraiment prendre cette programmer pour une rotation. Permettez-moi de le refaire avec make imprécision, slash dot, l'imprécision. 

Et c'est reparti. Votre enfance a été un mensonge. Apparemment, 1 divisé par 10 est en effet 0.100000000000000005551115123-- 

Que se passe-t-il? Eh bien, il se trouve, si vous genre de regarder assez loin dans le sous-jacent représentation de cette nombre, il fait est pas exactement 1/10, ou 0,1 et un nombre infini de zéros. Maintenant, pourquoi est-ce? 

Eh bien, même si cela est un simple numéro pour nous les humains, 1 divisé par 10, il est toujours l'un des nombreux infiniment numéros que nous pourrions imaginer. Mais un ordinateur ne peut représenter un nombre fini de nombres ainsi. Et donc, effectivement, ce que le ordinateur montre nous est son plus proche approximation du nombre nous voulons croire est 1/10, ou vraiment ad infinitum 0,10000. 

Au contraire, cependant, ceci est aussi proche qu'il peut obtenir. Et, en effet, si vous regardez sous le capot, que nous sommes ici en regardant 55 chiffres après la virgule, on voit en fait que la réalité. Maintenant, en passant, si vous avez jamais vu le movie-- la plupart d'entre vous avez probablement haven't-- mais il y a Superman 3 quelques années, Richard Pryor essentiellement exploité cette la réalité dans son entreprise pour voler beaucoup des fractions et des fractions de centimes, parce que le company-- je me souviens bien, il a été un while-- était essentiellement jeter tout ce qui ne correspondait pas dans la notion de cents. 

Mais si vous ajoutez tous ces minuscules, minuscules, chiffres minuscules encore, et encore, et encore, vous pouvez, comme dans son cas, faire un bon montant d'argent. 

Cette même idée a été arraché par une plus récente, mais encore maintenant plus âgés film, appelé Office Space, où les gars dans ce film, fait la même chose, vissé vers le haut complètement fini avec beaucoup trop l'argent dans leur compte bancaire. Tout cela était très suspect. Mais à la fin de la journée, imprécision est tout autour de nous. 

Et cela, aussi, peut être effroyablement le cas. Il se trouve que Superman 3 et l'espace de bureau à part, il peut être une très réelle ramifications mondiales des réalités imprécises représentation des données que même nous, les humains à ce jour-là ne le font pas nécessairement comprendre aussi bien que nous le devrions, ou de se rappeler aussi souvent que nous le devrions. Et, en effet, le clip suivant est à partir d'un regard sur un monde très réel ramifications de ce qui se passe si vous ne pas apprécier l'imprécision peut se produire dans la représentation des nombres. 

[LECTURE VIDÉO] 

-Ordinateurs, Nous avons tous appris à accepter les problèmes souvent frustrant que aller avec eux-- insectes, virus, et des pépins logiciels, pour les petits prix à payer pour la commodité. Mais dans la haute technologie et à haute vitesse applications programme spatial militaire et, le plus petit problème peut être agrandie en cas de catastrophe. 

Le 4 Juin 1996, les scientifiques préparés de lancer une fusée Ariane 5 sans pilote. Il transportait scientifique satellites conçus d'établir avec précision comment le interagit champ magnétique terrestre avec des vents solaires. La fusée a été construit pour l'Agence spatiale européenne, et a décollé de son installation sur la côte de la Guyane française. 

-Au Environ 37 secondes dans le vol, ils ont d'abord quelque chose remarqué allait mal. Les buses sont orientables dans une façon qu'ils ne devraient pas vraiment. Environ 40 secondes de vol, clairement, le véhicule était en difficulté. 

Et c'est quand ils ont fait une décision de la détruire. L'agent de sécurité de gamme, avec d'énormes tripes, appuyé sur le bouton, fait exploser la fusée, avant qu'il ne pourrait devenir un danger pour la sécurité publique. 

-Ce Était la jeune fille voyage d'Ariane 5. Et sa destruction a placer en raison d'un défaut intégré dans le logiciel de la fusée. -Le Problème sur le lanceur Ariane était qu'il y avait un nombre qui 64 bits requis pour exprimer. Et ils ont voulu convertir à un certain nombre de 16 bits. Ils ont supposé que le nombre n'a jamais été va être très grand, que la plupart de ceux chiffres dans un nombre de 64 bits sont des zéros. Ils avaient tord. 

-la Une incapacité Programme logiciel pour accepter le genre de numéro généré par un autre était à l'origine de l'échec. Le développement de logiciels était devenu un partie très coûteuse de la nouvelle technologie. La fusée Ariane a été très couronnée de succès, tant du logiciel créé pour elle était aussi utilisé dans l'Ariane 5. 

-Le Problème de base est que le lanceur Ariane 5 était plus rapide, accéléré plus rapidement. Et le logiciel avait pas comptabilisés pour cela. 

-La Destruction de la fusée a été un énorme désastre financier, dû à une erreur logicielle minutes. Mais ce ne fut pas le premier temps des problèmes de conversion de données avait en proie à la technologie des fusées modernes. 

-En 1991, avec le début de la première guerre du Golfe, le Patriot missiles connu le même genre du problème de conversion de nombre. Et en conséquence, 28 personnes, 28 soldats américains, ont été tués et environ 100 autres blessés, lorsque le Patriot, qui était censé pour protéger contre les gammares entrants, pas tirer un missile. 

-Lorsque L'Irak a envahi le Koweït, et en Amérique lancé Desert Storm au début de 1991, batteries Patriot missiles ont été déployés pour protéger l'Arabie Saoudite et Israël d'Irak des attaques de missiles Scud. Le Patriot est un milieu de gamme US surface à système d'air, fabriqué par la société Raytheon. 

-La Taille de l'intercepteur Patriot lui-même est d'environ environ 20 pieds de long. Et il pèse environ 2000 livres. Et il porte une ogive d'environ, Je pense qu'il est à peu près 150 livres. Et la charge militaire est lui-même un explosif, qui a des fragments autour de lui. L'enveloppe de la tête militaire est conçu pour agir comme chevrotines. 

-Les Missiles sont portés quatre par conteneur, et sont transportés par une semi-remorque. 

-Le Système Patriot anti-missile remonte au moins 20 ans. Il a été conçu à l'origine comme un missile de défense aérienne pour abattre des avions ennemis. Dans la première guerre du Golfe, lorsque cette guerre est arrivée, l'armée voulait l'utiliser pour abattre gammares, pas des avions. 

La Force aérienne irakienne était non pas tant d'un problème. Mais l'armée était inquiet à propos de gammares. Et donc ils ont essayé de mettre à niveau le Patriot. 

-Intercepting Un ennemi missile voyage à mach 5 allait être assez difficile. Mais quand le Patriot a été transporté en service, l'armée n'a pas connaissance d'un modification irakienne qui a fait leurs gammares presque impossible de frapper. 

-Quel Est arrivé les gammares que venaient en étaient instables. Ils ont été vacillant. La raison de ceci était les Irakiens, afin pour obtenir 600 kilomètres sur un 300 km missile à portée, a pris du poids de la tête militaire avant. Ils ont fait l'ogive plus léger. 

Alors maintenant, le Patriot est en essayant de venir au Scud. Et la plupart du temps, la écrasante majorité du temps, il serait juste voler par le Scud. Une fois que les opérateurs du système Patriot a réalisé le Patriot a raté sa cible, ils ont fait exploser la tête du Patriot pour éviter les pertes possibles si elle a été autorisé à tomber sur le sol. 

-Que Est ce que la plupart des gens ont vu, ces grosses boules de feu dans le ciel, et mal compris, comme intercepts d'ogives Scud. 

-Bien Dans la nuit ciel, Patriots est apparu être avec succès détruire Scuds, à Dhahran, il pourrait y avoir aucune erreur sur ses performances. Là, le système radar de la Patriot perdu la trace d'un Scud entrant, et jamais lancé en raison à un défaut de logiciel. Ce sont les Israéliens qui découvrit le premier que plus le système était allumé, plus l'écart de temps est devenue, grâce à une horloge incorporée dans l'ordinateur du système. 

-Environ Deux semaines avant la tragédie à Dhahran, les Israéliens ont déclaré à le Département de la Défense que le système était en train de perdre du temps. Après environ huit heures ou en cours d'exécution, ils ont remarqué que le système devenait nettement moins précis. Le Département de la Défense a répondu par dire toutes les batteries Patriot de ne pas laisser les systèmes pendant une longue période. Ils ne disaient jamais ce que longtemps était-- huit heures, 10 heures, 1000 heures. Personne ne savait. 

-La Batterie Patriot stationné à la caserne à Dhahran et ses défauts internes horloge avait été sur plus de 100 heures dans la nuit du 25 Février. 

-Il Suivis le temps d'une précision d'environ un dixième de seconde. Or, un dixième de seconde, est un nombre intéressant, parce qu'il ne peut pas être exprimé exactement en binaire, qui signifie qu'il ne peut pas être exprimé exactement dans un ordinateur numérique moderne. C'est dur à croire. 

Mais l'utiliser comme un exemple. Prenons le numéro un tiers. Un tiers ne peut pas être exprimée en décimal exactement. Un tiers est 0,333 passe pour l'infini. 

Il n'y a aucun moyen de le faire avec précision absolue en décimal. Voilà exactement le genre de problème cela est arrivé dans le Patriot. Plus le système a la pire erreur de temps est devenu. 

-Après 100 heures de fonctionnement, la erreur dans le temps était seulement environ un tiers d'une seconde. Mais en termes de ciblage d'un missile se déplaçant à mach 5, il a donné lieu à un suivi erreur de plus de 600 mètres. Ce serait une erreur fatale pour les soldats sur ce des événements est un lancement Scud était détecté par les satellites d'alerte précoce et ils savaient que le Scud était venant dans leur direction générale. Ils ne savaient pas d'où il venait. 

-C'était Maintenant au radar composant du système Patriot défendre Dhahran pour localiser et garder piste du missile ennemi entrant. 

-Le Radar était très intelligent. Il serait en fait suivre la position du Scud, puis prédire où il a probablement serait la prochaine fois que le radar envoyé une impulsion sur. Cela a été appelé une porte de gamme. 

-Ensuite, Une fois que le Patriot décide assez de temps a passé à revenir en arrière et vérifier le prochain emplacement pour cet objet détecté, il remonte. Alors, quand il est retourné à la mauvaise lieu, il voit alors aucun objet. Et il décide qu'il n'y a pas objet, il était une fausse détection, et laisse tomber la piste. 

-Le Entrant Scud a disparu à partir de l'écran radar. Et quelques secondes plus tard, il claqué dans les casernes. Le Scud a tué 28, et a été le dernier un tiré au cours de la première guerre du Golfe. 

Tragiquement, le logiciel mis à jour arrivé à Dhahran le lendemain. La faille du logiciel avait été fixée, la fermeture un chapitre dans le trouble l'histoire du missile Patriot. 

[LECTURE VIDÉO] DAVID J. Malan: Donc, tout cela est à dire que ces questions de débordement et l'imprécision sont trop réel. Alors, comment sommes-nous arrivés là? Nous avons commencé avec juste parler de printf. Encore une fois, cette fonction imprime quelque chose à l'écran, et nous avons introduit la suite quelques autres fonctions de la bibliothèque que l'on appelle de CS50. Et nous allons continuer à voir ces en temps voulu. Et nous, en particulier, utilisé chaîne get, et obtenir int, et maintenant également obtenir flotteur, et d'autres encore seront toujours nous rencontrer et de nous utiliser avant longtemps. 

Mais à l'occasion, nous avons déjà vu un besoin pour stocker ce que ces fonctions main en arrière? Ils nous renvoient une chaîne part, ou un int, ou un flotteur. Et parfois, nous avons besoin de mettre ce string ou int, ou float, quelque part. 

Et pour stocker ces choses, rappeler simplement comme dans Scratch, nous avons des variables. Mais contrairement à Scratch, en C, nous avons les types réels des données variables-- types, plus generally-- parmi eux, une chaîne, un int, un flotter, et ces autres encore. 

Et donc quand nous déclarons variables C, nous devons déclarer nos types de données. Cela ne veut pas quelque chose que nous avoir à faire plus tard dans le semestre que nous passons à d'autres langues. Mais pour l'instant, nous devons a priori à l'avance, expliquer à l'ordinateur quel type de la variable que nous voulons qu'elle nous donne. 

Maintenant, quant à lui, d'imprimer ce genre de types de données, nous devons dire printf à quoi nous attendre. Et nous avons vu pour cent s pour les chaînes, et pour les nombres entiers i pour cent, et quelques autres déjà. Et ce sont tout simplement les exigences pour la présentation visuelle de cette information. 

Et chacun d'eux peut effectivement être paramétrés ou tordu d'une certaine façon, si vous voulez poursuivre le contrôle le type de sortie que vous obtenez. Et, en fait, il se trouve que non seulement est là backslash n pour une nouvelle ligne. Il y a quelque chose d'autre appelé backslash r pour un retour chariot, qui est plus proche d'un vieille machine à écrire à l'école, ainsi que Windows utilisé depuis de nombreuses années. 

Il y a t backslash pour les onglets. Il s'avère, que si vous voulez guillemet à l'intérieur d'une chaîne, rappel que nous avons utilisé guillemets doubles devis sur la gauche et la droite les extrémités de nos cordes jusqu'ici. Cela semble confondre les choses. 

Si vous voulez mettre une double citation dans au milieu d'une string-- et, en fait, il est déroutant de voir. Et donc vous devez échapper, pour ainsi dire, une double citation avec quelque chose comme, littéralement, backslasher guillemets doubles. Et il y a quelques autres encore. Et nous allons voir plus de ceux en utilisation réelle avant longtemps. 

Donc, nous allons maintenant de transition données, et la représentation, et les opérateurs arithmétiques, tous qui nous a donné un certain bâtiment blocs avec lesquels jouer. Mais maintenant, nous allons donner effectivement nous le reste du vocabulaire que nous avions déjà la semaine dernière avec Scratch en prenant un coup d'oeil à un autre constructions en C-- pas tous d'entre eux. Mais les idées nous sommes sur le point de voir vraiment juste mettre l'accent sur la traduction de une langue, Scratch, à un autre, C. 

Et au fil du temps, nous allons chercher plus d'outils pour notre boîte à outils, pour ainsi dire, syntaxiquement. Et, en effet, vous verrez que les idées sont maintenant plutôt familiers de la semaine dernière. Donc, nous allons le faire. 

Allons de l'avant et de concocter un programme qui utilise effectivement quelques expressions, une expression booléenne. Laissez-moi aller de l'avant ici et de créer un nouveau fichier. Je vais appeler ce condition.c. 

Laissez-moi aller de l'avant et inclure la bibliothèque CS50. Et laissez-moi aller de l'avant et inclure norme io.h pour nos fonctions, et printf, et plus, respectivement. Permettez-moi de me donner que des passe-partout void main int, dont l'explication nous allons revenir à l'avenir. 

Maintenant, laissez-moi aller de l'avant et donner moi un int via get int. Alors laissez-moi aller de l'avant et de faire cela. Je veux dire si i est less-- nous allons distinction entre positif, négatif, ou des valeurs nulles. 

Donc, si i est inférieur à zéro, laissez-moi ont tout simplement ce programme simplement dire, négative, backslash n, d'autre si i est supérieur à zéro. Maintenant, je suis, bien sûr, va dire printf positif, backslash n. Et puis d'autre si-- je pouvais le faire. 

Je pourrais faire si i est égal à 0. Mais je serais fais à moins une erreur déjà. Rappelons que le signe égal est pas égaux, que nous, les humains le savent. 

Mais il est l'opérateur d'affectation. Et nous ne voulons pas prendre 0 sur le droit et le mettre dans i à gauche. Donc, pour éviter cette confusion, ou peut-être une mauvaise utilisation du signe égal, l'homme a décidé il y a quelques années que dans de nombreux langages de programmation lorsque vous souhaitez vérifier l'égalité entre la gauche et la droite, vous utilisez réellement égal à égal. Donc, vous frappez le signe égal à deux reprises. Lorsque vous souhaitez affecter de droite à gauche, vous utilisez un seul signe égal. Donc, nous pourrions faire d'autre this-- si i est égal à égal à zéro. 

Je pourrais alors aller ouvrir mes accolades, et dire, printf 0, backslash n, fait. Mais rappelez-vous comment ces bifurcations peuvent travailler. Et, vraiment, il suffit de penser à la logique. i est un nombre. Il est un entier, en particulier. Et cela signifie que ça va être moins à 0 ou supérieur à 0, ou 0. Donc, il est en quelque sorte de cette cas de défaut implicite. 

Et pour que nous puissions, juste comme Scratch, passer de l'autre si, et juste dire d'autre. Logiquement, si vous le programmeur sais qu'il ya seulement trois godets dans lesquels un scénario peut fall-- la première, le deuxième, le troisième ou dans ce case-- ne le font pas la peine d'ajouter la précision supplémentaire et la logique supplémentaire là. Il suffit d'aller de l'avant avec la cas ici d'autre par défaut. 

Maintenant, nous allons aller de l'avant après avoir enregistré cela, assurez conditions dot slash conditions-- pas une grande interface utilisateur, parce que je ne suis pas incité le utilisateur, comme je l'ai mentionné plus tôt. Mais ça va. Nous allons garder les choses simples. Essayons le nombre 42. Et c'est positif. Essayons le nombre négative 42, négative. 

Essayons la valeur 0. Et, en effet, cela fonctionne. Maintenant, vous verrez des problèmes avant longues, des choses de test à trois reprises, probablement pas suffisante. Vous voudrez probablement tester certains plus grand nombre, certains petits numéros, certains cas de coin, comme nous venons de les décrire. 

Mais pour l'instant, ceci est un assez simple programme. Et je suis assez sûr, logiquement, qu'il tombe dans trois cas. Et, en effet, même si nous venons de mis l'accent sur les inconvénients potentiels d'imprécision et de débordement, réalité où de nombreux problèmes de CS50, on ne va pas à vous soucier à propos, tout le temps, ces questions de débordement et imprécision, parce que, en fait, en C, il est en fait pas du tout facile d'éviter ces choses. Si vous voulez compter jusqu'à plus grand, et plus grand, et plus grand, il se trouve qu'il existe des techniques vous peut utiliser, impliquant souvent des choses appelées bibliothèques, collections de code, que d'autres personnes ont écrit que vous pouvez utiliser, et d'autres langues comme Java et autres, en fait rendre beaucoup plus facile compter encore plus élevé. Donc, il est vraiment certains de ces dangers en fonction de la langue que vous utilisez. Et dans les prochaines semaines, nous allons voir comment dangereux C vraiment peut être si vous ne l'utilisez pas correctement. Mais à partir de là, et Python et JavaScript, sera nous couche sur des protections supplémentaires, et courir moins de ces risques. 

Faisons donc un peu plus logique intéressant dans notre programme. Alors laissez-moi aller de l'avant et de créer un programme appelé logique juste pour que je peux jouer avec certains la logique réelle logical.c. Je vais copier et coller un peu code à partir plus tôt afin que je revienne à ce joli point de départ. 

Permettez-moi de faire cette fois C. omble Je suis va lui donner un nom de C juste parce qu'il est classique, obtenir un personnage de l'utilisateur. Et supposons que Je suis en œuvre une partie de ce programme de Rm, le supprimer programme avant qui a incité l'utilisateur de supprimer un fichier. Comment pourrions-nous faire cela? 

Je veux dire, si C est égal à égal à égal, entre guillemets, y, alors je vais assumer que l'utilisateur a choisi oui. Je vais juste imprimer oui. Si elle était effectivement en train d'écrire le programme d'enlèvement, nous pourrions supprimer le fichier avec plus de lignes de code. Mais nous allons garder les choses simples. 

Sinon, si c est égal à égal à n-- et maintenant ici, je vais dire, l'utilisateur doit avoir signifié pas. Et puis d'autre, vous savez quoi? Je ne sais pas quoi d'autre l'utilisateur va taper. Donc, je vais juste dire que qui est une erreur, quelle que soit il ou elle a effectivement tapé. 

Alors qu'est-ce qui se passe ici? Il y a une différence fondamentale par rapport à ce que je l'ai fait dans le passé. Les guillemets doubles, guillemets doubles, double citations, et, pourtant, des guillemets simples, apostrophes. Il se trouve en C, que lorsque vous voulez écrire une chaîne, vous utilisez des guillemets, tout comme nous avons été en utilisant tout ce temps avec printf. 

Mais si vous voulez traiter avec juste un seul caractère, un caractère soi-disant, alors vous utilisez réellement des guillemets simples. Ceux d'entre vous qui ont programmé avant, vous pourriez ne pas avoir eu à se soucier de cette distinction dans certaines langues. En C, il importe. Et quand je reçois un caractère et je veux pour comparer ce que l'omble utilisant égaux équivaut à quelque lettre comme y ou n, je fais, en effet, besoin d'avoir les guillemets simples. 

Maintenant, nous allons aller de l'avant et de faire cela. Allons de l'avant et ne font dot logiques slash logique. Et maintenant, je suis être invité. Alors, sans doute, une meilleure expérience utilisateur serait en fait me dire ce qu'il faut faire ici. Mais je vais aveuglément y dire pour oui, OK, bien. 

Courons à nouveau, n pour non, agréable. Supposons que certaines personnes que je connais, mes verrouillage des majuscules est trop souvent. Donc, je fais le capital Y, entrez, erreur. OK, il est pas exactement ce que j'attends. En effet, l'ordinateur est de faire littéralement ce que Je l'ai dit à do-- vérifier minuscules y et minuscules n. Cela ne se sent pas comme bon expérience utilisateur, cependant. Permettez-moi de demander et d'accepter soit minuscules ou majuscules. Donc, il se trouve, vous voudrez peut-être dire quelque chose comme dans Scratch, comme littéralement ou C est égal à est égal à capitaux unique y citée. Tours dehors, C n'a pas ce mot-clé littéral ou. 

Mais il a deux barres verticales. Vous devez tenir Maj habituellement, si vous utilisez un clavier américain, et appuyez sur la barre verticale clé ci-dessus la clé de votre retour. Mais cette barre verticale signifie barre verticale ou. 

Si, au contraire, nous avons voulu à dire et, comme dans Scratch, nous pourrions faire esperluette esperluette. Cela n'a aucun sens logique ici, parce qu'un homme ne pouvait pas ont tapé y et minuscules y et le capital Y comme le même caractère. Donc, ou est ce que nous entendons ici. 

Donc, si je fais cela dans les deux endroits, ou c est égal à equals N majuscule, maintenant rediffuser, make logique, relancez logique. Maintenant, je peux taper y. Et je peux le faire à nouveau avec capitale Y ou N. de capital Et je pourrais ajouter en plus combinaisons fixes. 

Donc, cela est logique programme dans la mesure où maintenant Je vérifie logiquement pour cette valeur ou cette valeur. Et je ne dois pas, nécessairement, venir avec deux ifs ou bien des ifs. Je peux effectivement combiner une partie de la une logique liée ensemble de cette façon. Donc, ce serait mieux conçu que simplement dire, si C est égal à minuscules y, imprimer oui, autre si c est égal à Y majuscule, imprimer oui, autre si c est égal à lower-- en d'autres termes, vous ne devez pas avoir de plus en plus de branches. Vous pouvez combiner certains de l'équivalent branches logiquement, que de cette manière. 

Donc, nous allons jeter un oeil à un seul ingrédient final, une construction finale, que C permet. Et nous reviendrons dans le avenir pour d'autres encore. Et puis nous allons conclure en regardant de ne pas la justesse de code-- obtenir le code pour work-- mais la conception du code, et planter ces graines tôt. 

Alors laissez-moi aller de l'avant et ouvrir un nouveau fichier ici. Vous savez quoi? Je vais ré-implémenter ce même programme, mais en utilisant une construction différente. 

Alors laissez-moi vite me donner l'accès à inclure CS50.h pour la bibliothèque CS50, Io.h standard pour printf. Donnez-moi mon void main int. Et puis ici, laissez moi aller de l'avant et faire cela. 

Char c obtient obtenir char, comme avant. Et je vais utiliser une nouvelle construction maintenant-- passer, sur ce personnage? Donc interrupteur est un peu comme la commutation d'un train pistes. Ou, vraiment, il est une sorte de un si bien, si bien si, mais écrit un peu différemment. 

Un commutateur ressemble à ceci. Vous avez l'interrupteur, puis ce caractère ou numéro que vous voulez regarder, puis quelques accolades aiment dans Scratch, dites simplement faire ce genre de choses. Et puis vous avez différents cas. 

Vous n'utilisez pas si et d'autre. Vous utilisez littéralement le mot cas. Et vous dire quelque chose comme ça. 

Ainsi, dans le cas d'un minuscule y, ou dans le cas d'un chapiteau Y, aller de l'avant et d'imprimer oui. Et puis sortir de l'interrupteur. C'est tout. Avaient fini. 

Sinon, si, pour ainsi dire, minuscules n ou N majuscule, alors allez-y et imprimer out pas, puis briser. Else-- et ce genre de est le cas par défaut indeed-- printf error-- et juste pour faire bonne mesure, bien que logiquement cette rupture est pas nécessaire parce que nous sommes à la fin du commutateur de toute façon, Je vais maintenant sortir de l'interrupteur. Donc, cela ressemble un peu différent. 

Mais, logiquement, il est en fait équivalent. Et pourquoi voudriez-vous utiliser l'un sur l'autre? Parfois, juste préférence personnelle, parfois l'esthétique, si je regarde à ce maintenant, il y a quelque chose à dire pour la la lisibilité de ce code. Je veux dire, sans parler du fait que cette le code est nouveau pour beaucoup d'entre nous dans la chambre. 

Mais il juste un peu est assez. Vous voyez minuscules y, capitale Y, minuscules n, N majuscule par défaut, juste sorte de sauts sur vous d'une manière que, sans doute, peut-être l'exemple précédent avec les ifs et les barres verticales, et les ifs d'autre, pourraient ne pas avoir. Donc, ce qui est vraiment une question de personnel choix, vraiment, ou la lisibilité, du code. 

Mais en termes de fonctionnalité, laissez-moi aller de l'avant et de faire un commutateur, slash dot commutateur, et maintenant taper y minuscules, Y majuscule, minuscule n, N majuscule, David, réessayez parce que ce pas un seul caractère. Faisons x, erreur, comme prévu. Et, logically-- et cela est quelque chose Je vous encourage à general-- même si nous ne faisons que gratter la la surface de certaines de ces fonctions. 

Et il ne serait pas évident quand vous vous asseoir au clavier, Comment cela marche-t-il? Qu'est-ce que cela? La belle chose d'avoir un ordinateur portable ou de bureau, ou l'accès à un ordinateur avec un compilateur, et avec un éditeur de code comme ceci, est que vous pouvez presque toujours répondre à ces questions pour vous-même juste en essayant. 

Par exemple, si la rhétorique question à portée de main étaient, ce qui se passe si vous oubliez vos déclarations de rupture? Qui est en fait un très courante chose à faire, car il ne semble pas comme vous avez vraiment besoin. Ils ne sont pas vraiment complètent pas votre pensé comme une parenthèse ou bouclés brace fait. Allons-y et recompiler le code et voir. Donc, assurez-commutateur, barre oblique point. Voyons tapez en minuscules y, le dessus du boîtier, Entrée. Je tapais y. 

Le programme dit oui, non, erreur, comme si elle était en train de changer son esprit. Mais ce genre d'été, parce que ce qui se passe avec un commutateur est le premier cas que correspondance signifie essentiellement, hé ordinateur, exécuter la totalité du code-dessous. Et si vous ne dites pas la rupture, ou ne dites pas la rupture, ou ne pas dire pause, l'ordinateur va exploser à travers toutes les lignes et d'exécuter tous les jusqu'à il obtient à cette accolade. Donc, les freins sont, en effet, nécessaire. Mais un plat à emporter ici est, quand dans le doute, essayer quelque chose. Peut-être enregistrer votre premier code, ou l'enregistrer dans un fichier supplémentaire si vous êtes vraiment inquiet gâcher et d'avoir à récupérer le travail que vous savez fonctionne. 

Mais essayer des choses. Et ne soyez pas aussi peur, peut-être, de ce que l'ordinateur peut faire, ou que vous pourriez casser quelque chose. Vous pouvez toujours revenir en arrière à une version antérieure. 

Donc, nous allons mettre fin en regardant à la conception de code. Nous avons cette capacité maintenant écrire conditions, et des boucles d'écriture, et les variables et les fonctions d'appel. Donc, franchement, nous sommes un peu en arrière à où nous étions il y a une semaine avec Scratch, mais avec un texte moins convaincant environnement que Scratch permet. 

Mais remarquons rapidité avec laquelle nous avons acquis ce vocabulaire, même si elle est va prendre un peu de temps à couler, de sorte que nous pouvons maintenant utiliser ce vocabulaire pour écrire des programmes plus intéressants. Et nous allons prendre un pas de bébé dans cette direction, comme suit. Laissez-moi aller de l'avant et créer un nouveau fichier ici. 

Je vais appeler cette prototype.c, et d'introduire pour la première fois, la possibilité de faire vos propres fonctions. Certains d'entre vous pourraient avoir fait avec Scratch, de sorte que vous pouvez créer votre propres blocs personnalisés dans Scratch, puis faites-les glisser en place partout où vous souhaitez en C. Et dans la plupart des émissions langues, vous pouvez faire exactement that-- faire vos propres fonctions, si elles ne sont pas déjà. 

Ainsi, par exemple, laissez-moi aller de l'avant et comprennent CS50.h, et comprennent norme io.h, void main int. Et maintenant, nous avons un espace réservé prêt à aller. Je garde les choses d'impression comme les noms des personnes aujourd'hui. Et cela se sent like-- ne serait pas bien s'il y étaient une fonction appelée nom d'impression? Je ne dois pas utiliser printf. Je n'ai pas de se rappeler tous les codes de format. Pourquoi pas moi, ou pourquoi n'a pas quelqu'un avant moi, créer une fonction appelée impression nom, donné un nom, imprime simplement it out? 

En d'autres termes, si je dis, hey, ordinateur, donnez-moi une chaîne en demandant à l'utilisateur d'une telle, via la fonction de chaîne get de CS50. Hey, ordinateur, mettez cette chaîne dans la variable du côté de la main gauche, et appelez-le par. Et puis, hé ordinateur, aller de l'avant et imprimer que le nom de la personne, fait. 

Maintenant, ce serait bien, parce que ce programme, bien nommé, me dit ce qu'il est censé faire par des noms de ceux fonction. Laissez-moi aller et faire un prototype, entrez. Et, malheureusement, cela ne va pas à voler. 

Prototype.c, ligne 7, caractère 5, erreur, déclaration implicite de la fonction nom d'impression est invalide dans C99, C99 ce qui signifie une version de C qui est sorti en 1999. C'est tout. 

Donc, je ne sais pas ce que tout cela signifie encore. Mais je reconnais erreur en rouge. C'est assez évident. 

Et il semble qu'avec le caractère vert ici, le problème est avec le nom d'impression, ouvert paren s, à proximité paren, semi-colon. Mais déclaration implicite de fonction que nous avons vu brièvement plus tôt. Cela signifie simplement que Clang ne sais pas ce que je veux dire. 

Je l'ai utilisé un mot de vocabulaire qu'il est jamais vu ou été enseigné auparavant. Et donc je dois enseigner ce que signifie cette fonction. Je vais donc aller de l'avant et de le faire. 

Je vais aller de l'avant et mettre en œuvre ma propre fonction appelée Imprimer Nom. Et je vais vous dire, comme suit, il le fait, printf, bonjour, pour cent s, backslash n, nom, point-virgule. Alors qu'est-ce que je viens de faire? 

Donc, il se trouve, à mettre en œuvre votre propre fonction, nous sorte de empruntons certains la même structure principale que nous venons de pris pour acquis, et je il suffit de savoir la copie et coller à peu près ce que J'ai écrit dans le passé. Mais remarquez le modèle ici. Int, Main, Void, nous allons taquiner dehors avant longtemps ce que cela signifie réellement. 

Mais pour aujourd'hui, juste remarquer le parallélisme. Void, le nom d'impression, nom de chaîne, donc il n'y a un mot-clé pourpre, qui nous allons commencer appeler un type de retour, le nom de la fonction, puis l'entrée. Donc, en fait, nous pouvons distiller ce genre de comme la semaine dernière comme cela est le nom ou le algorithme du code que nous sommes va write-- la algorithme sous-jacent le code que nous allons écrire. 

Ceci est son entrée. Ceci est sa sortie. Cette fonction, le nom d'impression, est conçu pour prendre une chaîne appelée nom, ou autre chose, comme entrée, puis vide. Il ne retourne rien, comme obtenir string ou obtenir int fait. Donc, ça va me remettre quelque chose en retour. Il va juste avoir un effet secondaire, pour ainsi dire, d'imprimer le nom d'une personne. Donc, remarque, ligne 7, je peut appeler le nom d'impression. Ligne 10, je peux définir ou mettre en œuvre le nom d'impression. Mais, malheureusement, cela ne suffit pas. 

Laissez-moi aller de l'avant et recompiler après avoir sauvegardé. Whoa, maintenant, je l'ai fait Pire encore, il semblerait. déclaration Donc implicite de nom fonction d'impression est invalide. Et, encore une fois, il n'y a plus d'erreurs. Mais comme je l'ai mis en garde plus tôt, même si vous obtenez accablé avec, ou un peu triste de voir tant de erreurs, se concentrer uniquement sur la première d'abord, parce qu'il pourrait juste ont eu un effet en cascade. Donc, C ou plus précisément Clang, ne reconnaît toujours pas le nom d'impression. 

Et c'est parce Clang, par la conception, est un peu idiot. Il ne fait que ce que vous lui demandez de faire. Et il ne le fait que dans l'ordre dans laquelle vous lui demandez de faire. 

Donc, je l'ai défini principale sur la ligne de quatre, comme nous l'avons fait assez souvent. J'ai défini le nom d'impression à la ligne 10. Mais je suis en train d'utiliser nom d'impression en ligne sept. 

Il est trop tôt, n'existe pas encore. Donc, je pourrais être intelligent, et être comme, OK, donc nous allons jouer tout le long, et déplacer le nom d'impression jusqu'à ici, et re-compiler. Oh mon Dieu. Ça a marché. C'était aussi simple que ça. 

Mais la logique est exactement cela. Vous devez apprendre à Clang ce qu'il est en définissant la fonction première. Ensuite, vous pouvez l'utiliser. Mais, franchement, cela se sent comme une pente glissante. 

Ainsi, chaque fois que je lance dans un problème, je suis juste va mettre en évidence et de copier le code Je l'ai écrit, le couper et le coller ici. Et, sûrement, nous pourrions ingénier certains scénarios où une fonction pourrait besoin d'appeler un autre. Et vous ne pouvez pas mettre tous les fonction ci-dessus tous les autres. 

Donc, il se trouve qu'il y a une meilleure solution. Nous pouvons laisser ce soit. Et, franchement, il est généralement agréable, et pratique, et un bon design de mettre principale d'abord, parce que, encore une fois, principale, juste comme quand le drapeau vert cliqué, qui est la fonction qui est exécuté par défaut. Donc, vous pourriez aussi bien mettre au sommet du fichier de sorte que lorsque vous ou tout autre homme regarde le fichier vous savez ce qui se passe juste en lisant principal en premier. Donc, il se trouve, nous pouvons dire Clang de manière proactive, hé, Clang, sur la quatrième ligne, Je promets de mettre en œuvre une fonction appelée Imprimer Nom qui prend un nom de chaîne appelée comme entrée, et retourne rien, vide. Et je vais autour de la mise en œuvre plus tard. 

Voici Main. Principal maintenant sur la ligne 9 peut utiliser Imprimer Nom parce Clang est confiant que, par la suite, il rencontre la définition de la mise en œuvre du Print Nom. Donc, après avoir sauvé mon dossier, laissez moi aller de l'avant et de faire un prototype, semble bon cette fois. Dot slash, prototype, laissez-moi aller de l'avant et taper un nom. David, bonjour David, Zamila, bonjour Zamila, et, en fait, maintenant il fonctionne. 

Donc, l'ingrédient ici est que nous avons fait une fonction personnalisée, comme une coutume bloc de Scratch nous appeler. Mais contrairement à Scratch où vous pouvez il suffit de créer et commencer à l'utiliser, maintenant, nous devons être un peu plus pédant, et effectivement former Clang d'utiliser ou de s'y attendre. Maintenant, en passant, pourquoi tout ce temps ont nous avions été aveuglément sur la foi, y compris CS50.h, et notamment la norme io.h? 

Eh bien, il se trouve, parmi quelques autres choses, tout ce qui est dans les points h fichiers, qui se trouvent être des fichiers. Ils sont des fichiers d'en-tête, pour ainsi dire. Ils sont toujours écrits en C. Mais ils sont un type de fichier différent. 

Pour l'instant, vous pouvez très bien supposer que tout ce qui est à l'intérieur CS50.h est des one-liners comme celui-ci, et non pas pour les fonctions appelées Imprimer Nom, mais pour Get String, Get Float, et quelques autres. Et il y a des prototypes semblables, revêtements un, à l'intérieur de la norme io.h pour printf, qui est maintenant en ma propre fonction Imprimer Nom. Donc, en d'autres termes, tout ce temps, nous avons vient d'être aveuglément copiant et collant inclure ce, inclure que, ce qui se passe? Ce sont juste un peu d'indices à Clang à quelles fonctions sont, en effet, mis en œuvre, tout simplement ailleurs dans différents fichiers ailleurs sur le système. 

Nous avons donc mis en place le nom d'impression. Il possède cet effet secondaire de impression quelque chose sur l'écran. Mais il ne fait donnez-moi quelque chose en retour. Comment allons-nous mettre en oeuvre un programme qui ne me remettre quelque chose en retour? 

Eh bien, nous allons essayer cela. Laissez-moi aller de l'avant et de mettre en œuvre un return.c de fichier appelé afin que nous puissions démontrer comment quelque chose comme Get String, ou Get Int, est en fait retourner quelque chose en retour à l'utilisateur. Allons de l'avant et de définir void main int. 

Et, encore une fois, à l'avenir, nous allons expliquer ce que int et ce vide est en train de faire. Mais pour aujourd'hui, nous allons prendre pour acquis. Je vais aller de l'avant et printf, pour une bonne expérience utilisateur, x est. Et puis je vais attendre la utilisateur pour me donner x avec get int. 

Et puis je vais aller de l'avant et imprimer x au carré. Alors, quand vous avez seulement un clavier, les gens couramment utiliser la petite carotte symbole sur le clavier pour représenter la puissance , ou l'exposant. Donc x au carré est présent i. 

Et maintenant, je vais le faire. Je ne pouvais tout simplement ce qui est do-- x au carré? x au carré est x fois x. 

Et nous avons fait un certain Il y a longtemps déjà aujourd'hui. Cela ne se sent pas comme tout ce que beaucoup de progrès. Vous savez quoi? Nous allons tirer parti de certains de cette idée depuis la dernière fois de l'abstraction. 

Ne serait-il pas bien si il y a une fonction appelée carré qui fait exactement cela? Il reste, à la fin de la jour, fait la même mathématiques. Résumé d'Mais laissez loin de l'idée de la prise un nombre multiplié par une autre, et juste lui donner un nom, comme carré de cette valeur. 

Et, en d'autres termes, C, nous allons créer une fonction appelé carré qui fait exactement cela. Il va être appelé carré. Il va prendre un int. Et nous allons tout va appeler n, par défaut. 

Mais nous pourrions l'appeler tout ce que nous voulons. Et tout ce que ça va faire, littéralement, est le retour le résultat de n fois n. Mais parce qu'il est retourner quelque chose qui est le mot-clé dans le pourpre, nous avons jamais vu auparavant, je, sur la ligne 11, ne peut pas simplement dire vide cette fois. 

Void, dans l'exemple que nous venons de voir plutôt du nom d'impression, signifie simplement, faire quelque chose. Mais ne me remettre pas quelque chose en retour. Dans ce cas, je ne veux pour revenir n fois n, ou tout ce qui est, ce nombre. 

Donc, je ne peux pas dire, hé, ordinateur, Je reviens rien, nulle. Il va revenir, par nature, un int. Et voilà tout ce qui se passe ici. 

L'entrée au carré va être un int. Et pour que nous puissions l'utiliser, il doit avoir un nom, N. Il va à la sortie un int qui n'a pas besoin d'un nom. Nous pouvons laisser à principal, ou celui qui est moi en utilisant de se rappeler cette valeur si nous veulent avec sa propre variable. 

Et, encore une fois, la seule nouvelle mot-clé ici est de retour. Et je fais juste un peu de maths. Si je voulais vraiment être inutile, Je pourrais dire produit int obtient n fois n. 

Et puis, je pourrais dire, le produit de retour. Mais, encore une fois, à mon point antérieur de ce tout simplement pas être bon design-- comme, pourquoi introduire un nom, un symbole, comme produit, juste pour retourner immédiatement? Il est un peu plus propre, un peu plus serré, donc de parler, juste pour dire le retour n fois n, se débarrasser de cette ligne complètement. 

Et il est juste moins de code à lire, moins de possibilités d'erreurs. Et nous allons voir si ce fonctionne réellement maintenant. Maintenant, je vais aller avant et de faire retour. 

Uh-oh, déclaration implicite de la fonction. J'ai fait cette erreur avant, pas une grosse affaire. Permettez-moi de taper, ou mettre en évidence et copier, le même prototype de fonction exacte, ou la signature, de la fonction ici. Ou je pourrais déplacer toute la fonction. 

Mais c'est un peu paresseux. Donc, nous ne le ferons pas. Maintenant, permettez-moi de retour à nouveau, dot retour slash. 

x est 2. x au carré est 4. x est 3. x au carré est 9. Et la fonction semble maintenant travailler. Alors, quelle est la différence ici? J'ai une fonction qui est appelée carré, dans ce cas, que je mets dans une entrée. Et je reviens d'une sortie. Et pourtant, précédemment, si J'ouvre l'autre exemple de plus tôt, ce qui était appelé prototype.c, J'ai eu le nom d'impression, qui retourné vide, pour ainsi dire, Ou il est revenu rien, et avait tout simplement un effet secondaire. 

Alors qu'est-ce qui se passe ici? Eh bien, considérons la fonction obtenir la chaîne pour un instant. Nous avons utilisé la fonction obtenir la chaîne de la façon suivante. 

Nous avons eu une fonction get chaîne, comme comprennent CS50.h, inclure la norme io.h, int, principale, vide. Et puis chaque fois que je l'ai appelé chaîne get jusqu'à présent, Je l'ai dit quelque chose comme, string s obtient obtenir chaîne, car get string-- Appelons cette chaîne get get.c-- elle renvoie une chaîne qui je peux alors utiliser, et dire bonjour, virgule, pour cent s, backslash n, s. 

Voici donc le même exemple, vraiment, que nous avions auparavant. Donc obtenir chaîne renvoie une valeur. Mais il y a un instant, chaîne d'impression ne retourne pas de valeur. Il a tout simplement un effet secondaire. Donc, ceci est une différence fondamentale. Nous avons vu différents types de fonctions maintenant, dont certains sont rentrés Les valeurs, dont certains ne le font pas. Alors peut-être qu'il est une chaîne ou int, ou float. Ou peut-être qu'il est juste vide. 

Et la différence est que ces fonctions obtenir des données et retourner une valeur sont en fait apporter quelque chose à la table, pour ainsi dire. Donc, nous allons aller de l'avant et regarder un ensemble final des exemples qui donne un sens, maintenant, comment nous pourrions, en effet, abstrait mieux, et mieux, et mieux, ou plus, et plus, et plus, pour à écrire, en fin de compte, un meilleur code. Allons de l'avant, et dans l'esprit Scratch, procédez comme suit. 

Laissez-moi aller de l'avant et inclure CS50.h et la norme io.h. Laissez-moi aller de l'avant et de donner moi un int, principale, vide. Et laissez-moi aller de l'avant, appelle ce cough.c. 

Et laissez-moi aller de l'avant et juste comme Scratch, imprimez la toux / n. Et je veux faire cela trois fois. Je suis, bien sûr, tout va copier et coller trois fois. Je vais maintenant faire Toux slash dot. Allons me donner un peu plus d'espace ici, Entrez, la toux, la toux, la toux. 

Il y a, évidemment, déjà possibilité d'amélioration. Je l'ai copié et collé quelques fois aujourd'hui. Mais ce fut seulement alors je ne l'ai pas avoir à taper autant de caractères. J'ai changé encore ce ces lignes de code sont. 

Ces trois lignes sont identiques, qui se sent paresseux et en effet est, et est probablement pas la bonne approche. Donc, avec ce que l'ingrédient pourrions-nous améliorer ce code? Nous ne devons pas copier et coller le code. 

Et, en effet, chaque fois que vous vous sentez vous copier-coller, et même pas changer le code, les chances sont qu'il ya une meilleure façon. Et, en effet, il y a. Laissez-moi aller de l'avant et faire une boucle, même si la syntaxe peut-être pas viennent naturellement encore. 

Pour ce faire, trois fois, tout simplement en faisant l'following-- et je sais cela de pratique. Mais nous avons un certain nombre d'exemples maintenant. Et vous verrez en ligne références encore. 

Ceci est la syntaxe sur la ligne 6, qui un peu comme Scratch qui se répète bloc, répéter les trois fois suivantes. Il est un peu magique pour le moment. Mais cela va obtenir plus, et plus familier. 

Et il va répéter ligne de huit à trois reprises, de sorte que si je re-compiler make toux, dot slash toux, la toux, la toux, la toux. Il fonctionne toujours de la même façon. Donc, c'est tout beau et bon. Mais ce n'est pas très abstraite. 

Il est parfaitement correct. Mais il se sent comme il pourrait être l'occasion, comme dans le monde Scratch, au genre de début d'ajouter une sémantique ici afin que Je n'ai simplement pas une boucle, et une fonction qui dit toux, ou ne la toux. Vous savez quoi? Je vais essayer d'être un peu plus frais que cela, et en fait écrire une fonction qui a certains effets secondaires, appeler la toux. 

Et il ne prend pas d'entrée et retourne pas de valeur en tant que sortie. Mais vous savez ce qu'il fait? Il fait this-- printf, entre guillemets, toux. 

Et maintenant ici, je vais aller de l'avant et int, i obtient zéro, i inférieur à 3, i plus plus. Je vais pas faire printf, qui est sans doute une implémentation de bas niveau détail. Je ne me soucie pas comment tousser. Je veux juste utiliser la fonction de la toux. Et je vais juste appeler la toux. 

Maintenant, remarquez la dichotomie. Lorsque vous appelez une fonction, si vous ne le faites pas vouloir lui donner entrées, tout à fait bien. Il suffit de faire paren ouvrir, fermer paren, et vous avez terminé. 

Lorsque vous définissez une fonction, ou déclarer le prototype d'une fonction, si vous savez à l'avance ce n'est pas va prendre tous les arguments, dire vide dans ces parenthèses là-bas. Et cela fait certain que vous ne sera pas accidentellement abuser. Laissez-moi aller de l'avant et de faire la toux. Et, bien sûr, je l'ai fait une erreur. 

Zut, il n'y a que déclaration implicite. Mais ça va. Il est une solution facile. Je dois juste le prototype plus haut dans mon dossier que je ne suis en fait l'utiliser. 

Alors maintenant, permettez-moi de la toux à nouveau, agréable. Maintenant ça marche. Faire la toux, la toux, la toux, la toux. Donc, vous pourriez penser que nous sommes vraiment juste ingénierie sur ce problème. Et, en effet, nous sommes. Ce n'est pas un bon candidat d'un programme au moment de refactoring, et faire ce qui est appelée décomposition hiérarchique, où vous prenez un peu de code, puis vous genre de choses de facteurs, de sorte que d'attribuer plus de sémantique pour eux, et le réutiliser en fin de compte à plus long terme. Mais il est un bloc de construction vers des programmes plus sophistiqués que nous allons commencer écrit avant longtemps que nous permet d'avoir le vocabulaire avec lequel pour écrire un meilleur code. Et, en effet, nous allons voir si nous ne peut pas généraliser davantage. 

Il semble un peu boiteux que je, principale, à se soucier de cette bougresse boucle for, et appeler encore et encore la toux. Pourquoi ne puis-je dire à la toux, s'il vous plaît tousser trois fois? En d'autres termes, pourquoi je ne peux pas juste apporter une contribution à tousser et à faire cela? 

Pourquoi ne puis-je dire, en la toux principale trois fois. Et maintenant, cela est une sorte de magique. Il est très itérative ici. Et il est, en effet, une étape de bébé. 

Mais la capacité à dire sur ligne de huit, toux trois fois, il est tellement plus lisible. Et, plus, je ne dois pas savoir ou de soin comment la toux est mis en œuvre. Et, en effet, plus tard dans la terme et pour les projets finaux, si vous abordez un projet avec un camarade de classe ou deux camarades de classe, vous vous rendrez compte que vous allez doivent, ou si vous voulez, diviser le travail. 

Et vous allez vouloir décider à l'avance, qui va faire quoi, et dans lequel les pièces? Et ne serait-il pas agréable si vous, par exemple, prendre en charge l'écriture principale, fait. Et votre colocataire ou votre partenaire plus généralement, prend soin de mettre en œuvre la toux. 

Et cette division, ceux-ci murs de l'abstraction, ou des couches d'abstraction si vous, sont super puissant, parce que surtout pour les plus grands, plus de programmes et de systèmes complexes, il permet à plusieurs personnes de construire choses ensemble, et, finalement, point leur travail ensemble de cette façon. Mais, bien sûr, nous besoin de fixer maintenant la toux. Nous devons dire la toux que, hé, vous savez quoi? Vous allez avoir besoin de prendre un input-- donc pas vide, mais int et maintenant. Allons de l'avant et de mettre en toux int. i obtient zéro. 

i est inférieur à combien de fois. Je l'ai dit trois avant. Mais ce n'est pas ce que je veux. Je veux tousser être généralisé à soutenir un certain nombre d'itérations. 

Donc, en effet, il est n que je veux, quel que soit l'utilisateur me dit. Maintenant, je peux aller de l'avant et dire imprimer la toux. Et peu importe ce nombre l'utilisateur passe, J'itérer que de nombreuses fois. 

Ainsi, à la fin de la journée, programme est identique. Mais remarquez tous ces trucs pourrait même être dans un autre fichier. En effet, je ne sais pas à la instant comment printf est mis en œuvre. 

Je ne sais pas pour le moment comment obtenir chaîne, ou obtenir int, float ou obtenir sont mises en oeuvre. Et je ne veux pas les voir sur mon écran. Comme il est, je commence à se concentrer sur mon programme, et non pas ces fonctions. 

Et donc, en effet, dès que vous commencer affacturage code comme ceci, pourrions-nous déplacer même la toux dans un fichier séparé? Quelqu'un d'autre pourrait le mettre en œuvre. Et vous et votre programme devenez très beau, et très lisible, sans doute, vraiment quatre programme en ligne là. 

Donc, nous allons aller de l'avant maintenant et faire encore un changement. Notez que mon prototype doit changer en haut. Alors permettez-moi de résoudre que tant Je ne suis pas crié. 

Faire la toux, permettez-moi de courir la toux, une fois plus, toujours faire la même chose. Mais maintenant, nous avons remarqué une ingrédient pour une version finale. Vous savez quoi? Je ne veux pas de tousser juste, nécessairement. Je veux avoir quelque chose de plus général. Donc, vous savez quoi? Je veux faire ça. Je veux avoir, un peu comme Scratch fait, un bloc de dire, mais pas seulement dire quelque chose un certain nombre de fois. Je veux dire une chaîne très spécifique. Et, donc, je ne voulez qu'il vient de dire la toux. Je veux dire ce que chaîne est passée dans. 

Donc remarquer, j'ai généralisé cette sorte que maintenant dire se sent comme un bon nom pour cela, comme Scratch, prend deux arguments, à la différence Scratch. La première est une chaîne. L'un est un int. 

Et je pourrais les passer. Je viens un peu comme l'idée de dire que la première chaîne, puis combien de fois plus tard. Void signifie qu'il reste ne retourne rien. Ce sont juste côté visuel effets, comme avec [? Jordan,?] un effet secondaire verbal de crier. Il fait encore quelque chose n fois, 0 jusqu'à, mais pas égal à n. Cela signifie que les temps n totaux. Et puis juste imprimer quelle que soit cette chaîne est. Donc, je suis vraiment généralisé cette ligne de code. Alors maintenant, comment puis-je mettre en œuvre la fonction de la toux? 

Je peux faire la toux vide. Et je peux encore prendre dans la façon de nombreuses fois que vous voulez tousser. Mais tu sais quoi? Je peux maintenant dire punt. 

Je peux appeler dire avec le mot toux, en passant dans le n. Et si je veux aussi mettre en œuvre, juste pour le plaisir, une fonction d'éternuement, Je peux éternuer un certain nombre de fois. Et je peux continuer à réutiliser n, parce que remarquer que m dans ce contexte ou étendue existe uniquement dans cette fonction. 

Et n dans ce contexte que existe dans cette fonction ici. Donc, nous allons y revenir ces questions de portée. Et ici, je vais juste dire, Achoo, et ensuite n fois, point-virgule. 

Et maintenant, je dois juste emprunter ces fonctions signatures ici. Donc, la toux est correcte. éternuement Void est correct maintenant. 

Et je reste juste besoin dire. Donc, je vais dire, disons chaîne s, int n, point-virgule. Donc, je suis sur l'ingénierie de la heck out de ce programme. 

Et cela ne nécessairement dire ceci est ce que vous devez faire lors de l'écriture même le plus simple des programmes. Prenez quelque chose qui est évidemment très simple, très court, et re-mettre en œuvre en utilisant beaucoup trop de code. Mais vous allez vraiment voir, et le temps de regarder en arrière sur ces exemples, et de réaliser, oh, ce sont les étapes nous avons pris réellement généraliser, de tenir compte de quelque chose, jusqu'à ce qu'à la fin de la journée mon code est en fait assez raisonnable. Parce que si je veux tousser trois fois, puis éternuer trois fois, Je vais simplement relancer cela, programme faire la toux, et exécuter la toux. Et j'ai trois toux et trois éternue. 

Et ceci est une base paradigme, si vous voulez, pour savoir comment nous pourrions aller sur la mise en œuvre en fait un programme. Mais nous allons voir tout à l'heure, il est nous avons fait tout ce temps, et ce que quelques-unes des pièces finales sont derrière cette commande simple. A la fin de la journée, nous avons été en utilisant Clang comme notre compilateur. Nous avons écrit la source code, convertissant via Clang en code machine. 

Et nous avons utilisé Faites juste pour faciliter nos frappes afin que nous ne devons pas oublier ces incantations de Clang lui-même. Mais ce qui est réellement faire faire? Et, à son tour, ce qui est Clang en train de faire? 

Il se trouve, bien que nous avons simplifié la discussion d'aujourd'hui en disant: vous prenez le code source, passez comme entrée à un compilateur, qui vous donne la sortie de la machine code, se révèle-t-il de à quelques pas différentes à l'intérieur il. Et la compilation se trouve être le parapluie terme pour tout un tas d'étapes. Mais nous allons taquiner juste ceci très rapidement. 

Il se trouve que nous avons fait plus de choses à chaque fois que je lance un programme, ou chaque fois que je compile un programme aujourd'hui. Donc, le prétraitement se réfère à this-- quoi que ce soit dans un programme C, comme nous le verrons encore et encore, qui commence par ce symbole de hachage, ou le symbole de hashtag ici, signifie il est une directive de préprocesseur. Cela signifie que, dans ce cas, hé ordinateur, faire quelque chose avec ce fichier avant de vous compilez mon propre code. 

Dans ce cas, hachage include est, essentiellement, la manière de C de dire, hey ordinateur, allez obtenir le contenu de CS50.h et collez-les ici. Hey ordinateur, allez obtenir le le contenu de la norme io.h, où que ce soit sur la disque dur, collez-le ici. Donc, ces choses se produisent première au cours du prétraitement. 

Et Clang fait tout cela pour nous. Et il le fait horriblement rapide, vous faites même pas voir quatre choses distinctes qui se passe. Mais c'est la première telle étape. 

Qu'est-ce qui se passe réellement à côté? Eh bien, la prochaine officielle étape est la compilation. Et il se trouve que compilation d'un programme des moyens techniquement allant de code source, les choses que nous avons été écrit aujourd'hui, à quelque chose appelé code assembleur, quelque chose qui ressemble un peu différent. 

Et, en fait, nous pouvons le voir très vite. Permettez-moi de réellement entrer dans mon IDE. Laissez-moi aller de l'avant et hello.c ouvert, qui est le tout premier programme avec lequel nous a commencé aujourd'hui. Et laissez-moi aller de l'avant et d'exécuter un Clang peu différemment, Clang-s, hello.c, qui se passe réellement à me donner un autre fichier hello.s. 

Et nous le ferons probablement jamais voir à nouveau ce genre de code. Si vous prenez un niveau inférieur classe de systèmes comme CS61, vous verrez beaucoup plus de ce genre de code. Mais ceci est le langage d'assemblage. Ceci est X86 langage d'assemblage que l'unité centrale de traitement qui est sous-jacente CS50 IDE comprend réellement. 

Et cryptique comme il le fait regardez, il est quelque chose l'ordinateur comprend assez bien. Sous q, ceci est une soustraction. Il y a des mouvements. 

Il y a d'appeler des fonctions ici, x oring, un mouvement, un complément, un pop, un retour. Donc, il y a quelques très instructions de bas niveau que les processeurs comprennent que J'y ai fait allusion plus tôt. Voilà ce que Intel Inside. 

Il existe des modèles de zéros et de uns que la carte à ces arcanely rédigé, mais un peu bien nommé, des instructions, pour ainsi dire. Voilà ce qui arrive quand vous compilez votre code. Vous obtenez l'assemblage langue hors de lui, qui signifie la troisième étape consiste à assembler que le code d'assemblage en fin de compte, machines zéros et des uns, et non pas les code-- texte que nous venons de voir il y a un instant. 

Donc, pré-traitement ne qui trouvent et remplacer, et quelques autres choses. Compiler prend source le code de C, le code source que nous avons écrit, à l'assemblage Code que nous venons jeta un regard. Assemblage prend cette assemblée code zéros et des uns que le CPU va vraiment comprendre à la fin de la journée. Et la liaison est la dernière étape cela se produit pour us-- à nouveau, si vite que nous ne le faisons pas même notice-- qui dit, hey ordinateur, prendre toutes les zéros et ceux qui le résultat de la compilation du code de David, et sa fonction principale dans ce cas. 

Et hey ordinateur, aller chercher tous les zéros et que le personnel a écrit CS50 à l'intérieur de la bibliothèque de CS50. Mélanger ceux avec David. Et hé ordinateur, allez obtenir tous les zéros et ceux que quelqu'un d'autre a écrit années Il y a pour printf. Et d'ajouter ceux dans le chose ensemble, de sorte que nous avons obtenu mes zéros et des uns, la les zéros et les uns du personnel CS50, les zéros printf et ceux, et tout ce que nous utilisons. 

Ils ont tous se combiner en une seule programme appelé, dans ce cas, bonjour. Donc désormais, nous allons tout simplement utiliser le mot compilation. Et nous prendrons pour acquis que lorsque nous disons, compiler votre programme, cela signifie, hey faire le pré-traitement, l'assemblage et la liaison. Mais il y a effectivement quelques trucs juteux passe là-bas sous le capot. Et surtout si vous obtenir curieux un certain temps, vous pouvez commencer à piquer autour de ce niveau inférieur. Mais pour l'instant, se rendre compte que parmi les plats à emporter pour aujourd'hui sont tout simplement début d'un processus, de se familiariser avec quelque chose comme bonjour monde. En effet, la plupart de ce que nous avons fait aujourd'hui ne sera certainement pas sombrer dans super rapide. Et il faudra un certain le temps, et une certaine pratique. Et les chances sont, vous triez de vouloir frapper votre clavier ou crier à l'écran. Et tout cela est OK. Bien, peut-être essayer de ne pas le faire dans la bibliothèque tellement. 

Et en fin de compte, vous aurez être en mesure cependant, pour commencer voir les modèles, aussi bien dans un bon code que vous avez écrit et erreurs que vous avez fait. Et tout comme le processus de devient un TF ou CA est comme, vous allez commencer à aller mieux et mieux de voir ces modèles, et juste la résolution de votre en fin de compte des problèmes propres. En attendant, il y aura beaucoup nous vous prêter assistance, et vous obtenez à travers cela. Et dans les comptes-rendus pour tous les problèmes vous serez guidé à travers toutes les commandes que je sais certainement de beaucoup de pratique maintenant, mais pourrait avoir volé dessus de la tête pour l'instant. Et c'est tout à fait bien. 

Mais, en fin de compte, vous allez pour commencer à voir des tendances émergent. Et une fois que vous avez passé tous les détails stupides, comme entre parenthèses, et des accolades et des points-virgules, et les choses, franchement, ce n'est pas du tout intellectuellement intéressant. Et il est pas l'objectif de prendre une classe d'introduction. Ce sont les idées qui vont à la matière. 

Ce sont les boucles, et les conditions et les fonctions, et plus puissamment l'abstraction, et l'affacturage de code, et la bonne conception, et le bon le style, et, finalement, l'exactitude de votre code, qui est en fin de compte aller à la matière le plus. Donc, la semaine prochaine, nous allons prendre ces idées que nous avons vu la première fois en Scratch et ont maintenant traduit C. Et nous allons commencer à introduire le premier de la monde réel les domaines de cours. 

Nous allons nous concentrer sur le monde de la sécurité, et la cryptographie plus spécifiquement, l'art de brouiller l'information. Et parmi les premiers problèmes vous-même se rendre à écrire au delà en jouant avec une partie de la syntaxe et la résolution de certains logique problèmes, en fin de compte avant longtemps, est de brouiller effectivement, ou chiffrer, et, finalement, décrypter les informations. Et tout ce que nous avons fait aujourd'hui, sera assez faible niveau, va tout simplement pour permettre nous prenons un, et un, et une étape de plus vers ci-dessus écrit encore le code le plus intéressant. 

Donc, plus sur que la semaine prochaine. 

[LECTURE VIDÉO] 

-Quel Pouvez-vous me dire au sujet la dernière fois que vous l'avez vu? -Qu'est Ce que je peux dire, vraiment? Je veux dire, il était comme tout autre répétition de pré-production, sauf qu'il y avait quelque chose qu'il a dit à la fin qui a collé avec moi. 

-Ce Était CS50. 

-C'est Une coupe tout le monde, excellent travail sur la répétition. 

le déjeuner de -Que? 

-Oui, Vous et je peux prendre un sandwich dans un peu. Permettez-moi de reprendre avec David très rapidement. David? David? 

[FIN LECTURE] 