1
00:00:00,000 --> 00:00:00,000

2
00:00:00,000 --> 00:00:00,000
[MUSIC PLAYING]

3
00:00:00,000 --> 00:00:13,950

4
00:00:13,950 --> 00:00:16,240
>> DAVID J. Malan: Très bien, cela est CS50.

5
00:00:16,240 --> 00:00:18,010
Et ceci est la première semaine.

6
00:00:18,010 --> 00:00:22,050
Donc, rappeler que la dernière fois dans la semaine zéro,
nous nous sommes concentrés sur la pensée de calcul.

7
00:00:22,050 --> 00:00:25,440
Et nous sommes passés de celui
Scratch, une programmation graphique

8
00:00:25,440 --> 00:00:27,360
la langue de nos amis
au Media Lab du MIT.

9
00:00:27,360 --> 00:00:31,730
>> Et avec Scratch, ne nous explorons
des idées comme les fonctions et les conditions,

10
00:00:31,730 --> 00:00:35,210
et les boucles et les variables, et même
les événements et les discussions, et plus encore.

11
00:00:35,210 --> 00:00:37,880
Et aujourd'hui, nous allons
continuer à utiliser ces idées,

12
00:00:37,880 --> 00:00:40,630
et vraiment les prendre pour
acquis, mais les traduire

13
00:00:40,630 --> 00:00:44,220
à une autre langue connue sous le nom C. Maintenant,
C est un langage plus traditionnel.

14
00:00:44,220 --> 00:00:46,020
Il est un niveau inférieur
la langue, si vous voulez.

15
00:00:46,020 --> 00:00:47,300
>> Il est purement textuel.

16
00:00:47,300 --> 00:00:49,910
Et donc, à première vue, il est
tout va regarder plutôt cryptique

17
00:00:49,910 --> 00:00:51,430
si vous ne l'avez jamais programmé auparavant.

18
00:00:51,430 --> 00:00:53,530
Nous allons avoir
points-virgules et les parenthèses,

19
00:00:53,530 --> 00:00:55,150
et accolades, et plus encore.

20
00:00:55,150 --> 00:00:57,240
Mais se rendre compte que même
si la syntaxe est

21
00:00:57,240 --> 00:01:00,600
sur le point de regarder un peu familier
à la plupart d'entre vous, voir passé.

22
00:01:00,600 --> 00:01:03,220
Et essayer de voir les idées
qui sont, en effet, familier,

23
00:01:03,220 --> 00:01:06,750
car ici en première semaine ce
nous allons commencer à faire est de comparer,

24
00:01:06,750 --> 00:01:08,980
initialement, Scratch contre C.

25
00:01:08,980 --> 00:01:12,350
>> Ainsi, par exemple, rappeler que lorsque nous
mis en œuvre le premier de nos programmes

26
00:01:12,350 --> 00:01:16,220
la dernière fois, nous avions un bloc qui avait l'air
un petit quelque chose comme this-- quand

27
00:01:16,220 --> 00:01:19,990
drapeau vert cliqué, et puis nous avons eu
une ou plusieurs pièces de puzzle en dessous,

28
00:01:19,990 --> 00:01:22,150
dans ce cas, dire bonjour monde.

29
00:01:22,150 --> 00:01:24,870
Donc, en effet, dans Scratch,
lorsque je clique sur le drapeau vert

30
00:01:24,870 --> 00:01:27,390
pour exécuter mon programme, de sorte
de parler, ce sont

31
00:01:27,390 --> 00:01:29,520
les blocs qui s'exécutés, ou l'exécution.

32
00:01:29,520 --> 00:01:32,230
Et, plus précisément, Scratch
dit, bonjour, monde.

33
00:01:32,230 --> 00:01:35,377
>> Maintenant, je pourrais avoir spécifié
différents mots ici.

34
00:01:35,377 --> 00:01:37,960
Mais nous verrons que, en effet, beaucoup
de ces blocks-- et, en fait,

35
00:01:37,960 --> 00:01:41,880
en C beaucoup functions-- peuvent être
paramétrés ou personnalisés

36
00:01:41,880 --> 00:01:43,150
faire des choses différentes.

37
00:01:43,150 --> 00:01:45,520
En effet, si l'on en C
voulez convertir, maintenant,

38
00:01:45,520 --> 00:01:47,567
ce programme de Scratch
à cette autre langue,

39
00:01:47,567 --> 00:01:49,650
nous allons écrire un
petit quelque chose comme ça.

40
00:01:49,650 --> 00:01:52,540
>> Certes, il y a une certaine inconnue
syntaxe il le plus probable, int,

41
00:01:52,540 --> 00:01:54,380
et entre parenthèses, et non avenu.

42
00:01:54,380 --> 00:01:57,740
Mais printf-- même si vous le feriez
pense que ce serait tout simplement l'impression.

43
00:01:57,740 --> 00:02:00,120
Mais l'impression des moyens d'impression
formaté, comme nous le verrons bientôt.

44
00:02:00,120 --> 00:02:02,140
Cela va littéralement imprimer
à l'écran quelle que soit

45
00:02:02,140 --> 00:02:05,990
est à l'intérieur de ces parenthèses, qui
bien sûr, dans ce cas est, bonjour monde.

46
00:02:05,990 --> 00:02:09,290
>> Mais vous remarquerez une autre
syntaxe, certains guillemets doubles,

47
00:02:09,290 --> 00:02:11,890
que les parenthèses à la fin,
le point-virgule et analogues.

48
00:02:11,890 --> 00:02:15,027
Donc, il y a un peu de frais généraux,
pour ainsi dire, à la fois cognitivement

49
00:02:15,027 --> 00:02:17,860
et syntaxiquement, que nous allons
d'avoir à se rappeler avant longtemps.

50
00:02:17,860 --> 00:02:20,720
Mais se rendre compte que la pratique,
cela va commencer à sauter à vous.

51
00:02:20,720 --> 00:02:24,920
>> En fait, nous allons concentrer sur celui-là
fonction specifically-- dans ce cas,

52
00:02:24,920 --> 00:02:26,290
dire bonjour monde.

53
00:02:26,290 --> 00:02:27,560
Donc, dire est la fonction.

54
00:02:27,560 --> 00:02:31,320
Bonjour tout le monde est son paramètre,
ou un argument, sa personnalisation.

55
00:02:31,320 --> 00:02:34,320
>> Et l'équivalence en C est juste
va être cette seule ligne ici,

56
00:02:34,320 --> 00:02:38,710
où printf est équivalent à, disons,
la chaîne entre guillemets, bonjour

57
00:02:38,710 --> 00:02:41,470
monde est équivalent, bien sûr,
à ce qui est dans la boîte blanche là-bas.

58
00:02:41,470 --> 00:02:45,680
Et le backslash n, bien qu'un peu
étrange et absent à partir de zéro,

59
00:02:45,680 --> 00:02:49,380
tout simplement va avoir l'effet nous allons
voir dans un ordinateur, comme mon Mac ou un PC,

60
00:02:49,380 --> 00:02:51,660
de simplement déplacer le
curseur à la ligne suivante.

61
00:02:51,660 --> 00:02:53,970
Il est comme frapper
Entrée de votre clavier.

62
00:02:53,970 --> 00:02:55,580
>> Donc, nous allons voir que de nouveau avant longtemps.

63
00:02:55,580 --> 00:02:58,640
Mais d'abord, nous allons jeter un oeil à cette
un autre exemple dans le cas de boucles.

64
00:02:58,640 --> 00:03:02,830
Nous avons eu cette boucle pour toujours la dernière fois,
qui était une série de pièces de puzzle

65
00:03:02,830 --> 00:03:05,490
qui a fait quelque chose littéralement
forever-- dans ce cas,

66
00:03:05,490 --> 00:03:08,360
dire bonjour monde, bonjour monde,
Bonjour tout le monde, bonjour monde.

67
00:03:08,360 --> 00:03:10,350
Il est donc une boucle infinie par la conception.

68
00:03:10,350 --> 00:03:14,580
>> En C, si l'on veut mettre en œuvre cette
même idée, nous pourrions simplement faire ceci.

69
00:03:14,580 --> 00:03:19,570
Bien vrai, printf bonjour monde-- maintenant
tandis que, juste sémantiquement, sorte de

70
00:03:19,570 --> 00:03:23,090
évoque l'idée de faire
quelque chose de nouveau, et encore, et encore,

71
00:03:23,090 --> 00:03:23,980
et pour combien de temps?

72
00:03:23,980 --> 00:03:27,990
Eh bien, le rappel true-- que
vrai est juste ou un.

73
00:03:27,990 --> 00:03:30,660
>> Et vrai est, bien sûr, toujours vrai.

74
00:03:30,660 --> 00:03:33,060
Donc, il est une sorte de sens
déclaration juste pour dire vrai.

75
00:03:33,060 --> 00:03:36,890
Mais en effet, ceci est délibéré,
parce que si vrai est juste toujours vrai,

76
00:03:36,890 --> 00:03:40,850
que tout vrai implique juste,
si un peu indirectement,

77
00:03:40,850 --> 00:03:44,070
que les lignes de code suivantes
entre ces accolades

78
00:03:44,070 --> 00:03:48,320
devrait simplement exécuter à nouveau, et encore,
et encore, et ne jamais cesser réellement.

79
00:03:48,320 --> 00:03:50,230
>> Mais si vous ne voulez que votre
boucle pour arrêter, comme nous

80
00:03:50,230 --> 00:03:54,500
a fait la dernière fois avec quelque chose comme
cela, répéter les 50 heures suivantes,

81
00:03:54,500 --> 00:03:57,700
en C, nous pouvons faire la même chose avec ce qui est
appelé le mot-clé pour loop--

82
00:03:57,700 --> 00:03:59,330
ne pas être tout, mais pour.

83
00:03:59,330 --> 00:04:03,290
Et puis nous avons une nouvelle syntaxe ici,
avec un entier i est égal à 0, i inférieur à 50,

84
00:04:03,290 --> 00:04:03,880
i ++.

85
00:04:03,880 --> 00:04:05,430
Et nous reviendrons à cela.

86
00:04:05,430 --> 00:04:09,660
Mais cela est tout simplement la façon dont nous le ferions
traduire l'ensemble des blocs de grattage

87
00:04:09,660 --> 00:04:13,079
à un ensemble de lignes de code C.

88
00:04:13,079 --> 00:04:14,450
>> Pendant ce temps, tenir compte des variables.

89
00:04:14,450 --> 00:04:16,540
Et, en fait, nous avons juste
vu un il y a un moment.

90
00:04:16,540 --> 00:04:21,220
Et dans le cas de Scratch, si nous
voulu déclarer une variable appelée i

91
00:04:21,220 --> 00:04:24,590
pour i étant entier, juste un nombre,
et nous voulons le mettre à une certaine valeur,

92
00:04:24,590 --> 00:04:28,410
nous devrions utiliser cette orange
bloquer ici-- i mis à 0.

93
00:04:28,410 --> 00:04:30,800
>> Et nous allons voir aujourd'hui et
au-delà, tout comme la semaine dernière,

94
00:04:30,800 --> 00:04:33,850
programmeurs font presque toujours
commencer à compter à partir de zéro, vraiment

95
00:04:33,850 --> 00:04:34,950
par convention.

96
00:04:34,950 --> 00:04:37,250
Mais aussi parce que le rappel de
notre discussion de binaire,

97
00:04:37,250 --> 00:04:39,990
le plus petit nombre possible
représenter avec un nombre quelconque de bits

98
00:04:39,990 --> 00:04:41,640
va tout simplement être 0 lui-même.

99
00:04:41,640 --> 00:04:45,190
Et donc nous allons généralement commencer
initialisant même nos variables à 0.

100
00:04:45,190 --> 00:04:47,710
>> Et en C pour faire la même chose,
nous allons dire int

101
00:04:47,710 --> 00:04:50,110
pour entier, je viens par convention.

102
00:04:50,110 --> 00:04:53,390
Je aurais pu appeler cette variable
tout ce que je veux, comme dans Scratch.

103
00:04:53,390 --> 00:04:57,770
Et puis est égal à 0 seulement ayants droit
la valeur 0 de la droite

104
00:04:57,770 --> 00:05:01,319
et le met dans la variable, ou
Récipient de stockage bas, sur la gauche.

105
00:05:01,319 --> 00:05:04,360
Et le point-virgule comme nous allons see-- et
nous avons vu quelques-unes de ces already--

106
00:05:04,360 --> 00:05:06,530
signifie simplement la fin de la pensée.

107
00:05:06,530 --> 00:05:09,430
Passez à faire autre chose
sur les lignes qui suivent.

108
00:05:09,430 --> 00:05:11,330
>> Maintenant, qu'en est-il des expressions booléennes?

109
00:05:11,330 --> 00:05:14,320
Rappelons que dans Scratch,
ceux-ci étaient des expressions

110
00:05:14,320 --> 00:05:16,740
qui sont soit vrai
ou des questions false--,

111
00:05:16,740 --> 00:05:18,910
vraiment, qui sont soit vrai ou faux.

112
00:05:18,910 --> 00:05:21,960
Donc, dans le cas de Scratch, nous pourrions
poser une question simple comme ça,

113
00:05:21,960 --> 00:05:24,586
est i moins de 50?

114
00:05:24,586 --> 00:05:25,710
Donc je, encore une fois, est un nombre entier.

115
00:05:25,710 --> 00:05:27,210
Peut-être que nous l'utiliser
dans un programme de Scratch

116
00:05:27,210 --> 00:05:29,310
de garder une trace d'une partition
ou quelque chose comme ça.

117
00:05:29,310 --> 00:05:33,810
Donc, cette syntaxe ici Scratch
signifie simplement, est i moins de 50?

118
00:05:33,810 --> 00:05:37,330
Eh bien, heureusement, quelque chose est
simple C. Et à traduire,

119
00:05:37,330 --> 00:05:41,780
cela nous serait tout simplement dire que je moins
à 50, en utilisant la clé familière

120
00:05:41,780 --> 00:05:42,850
sur votre clavier.

121
00:05:42,850 --> 00:05:45,141
>> Pendant ce temps, si vous vouliez
dire quelque chose de plus général,

122
00:05:45,141 --> 00:05:49,890
comme, bien, est x moins y où chaque
x et y sont eux-mêmes des variables?

123
00:05:49,890 --> 00:05:52,280
Nous pouvons faire la même chose
en C, aussi longtemps que nous avons

124
00:05:52,280 --> 00:05:53,942
créé déjà ces variables.

125
00:05:53,942 --> 00:05:55,650
Et nous allons voir comment
faire avant longtemps.

126
00:05:55,650 --> 00:05:58,590
Nous dirions simplement x moins y.

127
00:05:58,590 --> 00:06:00,530
>> Donc, vous commencez à
voir quelques similitudes.

128
00:06:00,530 --> 00:06:03,490
Et ces gens qui ont fait
Scratch étaient certainement

129
00:06:03,490 --> 00:06:05,250
inspiré par certaines de ces idées de base.

130
00:06:05,250 --> 00:06:10,350
Et vous verrez ce genre de
syntaxe dans un grand nombre languages--

131
00:06:10,350 --> 00:06:12,160
pas seulement Scratch, pas
juste C, mais Python,

132
00:06:12,160 --> 00:06:14,790
et JavaScript, et
d'autres langues encore.

133
00:06:14,790 --> 00:06:18,270
>> Considérons une autre construction
de C, la notion d'une condition,

134
00:06:18,270 --> 00:06:20,370
faire quelque chose de manière conditionnelle.

135
00:06:20,370 --> 00:06:22,720
Si quelque chose est vrai, faire cela.

136
00:06:22,720 --> 00:06:24,457
Si quelque chose est vrai, faire cela.

137
00:06:24,457 --> 00:06:27,040
Il est en quelque sorte de la programmation
équivalent d'une bifurcation de la route.

138
00:06:27,040 --> 00:06:29,730
Peut-être qu'il est une fourche à deux voies,
une fourchette à trois voies ou plus.

139
00:06:29,730 --> 00:06:32,800
Et dans Scratch, nous pourrions avoir
vu quelque chose comme ça.

140
00:06:32,800 --> 00:06:34,010
>> Donc, celui-ci est un grand.

141
00:06:34,010 --> 00:06:36,750
Mais considérer le rapport
la simplicité de la logique.

142
00:06:36,750 --> 00:06:44,010
Si x est inférieur à y, dites x est moins
à y, sinon si x est supérieur à y,

143
00:06:44,010 --> 00:06:46,230
dire alors x est supérieur à y.

144
00:06:46,230 --> 00:06:48,300
Et puis, logiquement, si
vous repensez à Scratch

145
00:06:48,300 --> 00:06:52,610
ou tout simplement votre propre intuition humaine,
De plus, si x est inférieure ou égale à y, et x

146
00:06:52,610 --> 00:06:57,000
est pas inférieur à y, alors bien sûr
x va être égal à y.

147
00:06:57,000 --> 00:06:59,690
Donc dans ce cas, par emboîtement
ces blocs de Scratch,

148
00:06:59,690 --> 00:07:02,580
pouvons-nous atteindre trois
fourche chemin dans la route?

149
00:07:02,580 --> 00:07:04,980
>> Pendant ce temps, si nous voulons
faire que, dans C, il sans doute

150
00:07:04,980 --> 00:07:08,420
regarde un peu simpler-- au moins
une fois que vous vous familiariser avec la syntaxe.

151
00:07:08,420 --> 00:07:12,050
Si x est inférieur à y,
printf x est inférieur à y.

152
00:07:12,050 --> 00:07:16,140
Sinon, si x est supérieur à y,
printf x est supérieur à y.

153
00:07:16,140 --> 00:07:21,210
Else printf x est égal à Y- et,
encore une fois, avec les backslash se termine juste

154
00:07:21,210 --> 00:07:24,160
pour les nouvelles lignes de telle sorte que si vous
effectivement couru ce genre de programme

155
00:07:24,160 --> 00:07:25,940
il suffit de déplacer
votre curseur en fin de compte

156
00:07:25,940 --> 00:07:28,100
à la ligne suivante de l'écran.

157
00:07:28,100 --> 00:07:31,270
>> Maintenant, quant à lui Scratch avait d'autres
des fonctionnalités plus sophistiquées, seulement

158
00:07:31,270 --> 00:07:34,320
dont certains que nous allons
déplacer d'abord vers le monde de C.

159
00:07:34,320 --> 00:07:37,010
Et l'un d'entre eux était
appelé une liste dans Scratch.

160
00:07:37,010 --> 00:07:39,100
Et ce fut une spéciale
le type de variable

161
00:07:39,100 --> 00:07:42,840
vous a permis de stocker plusieurs choses
à revenir, à dos, à dos, à l'arrière.

162
00:07:42,840 --> 00:07:45,540
>> En C, il n'a pas
listes, en soi, mais quelque chose

163
00:07:45,540 --> 00:07:48,090
qui sont généralement plus
appelé tableaux, bien que nous allons

164
00:07:48,090 --> 00:07:50,590
revenir plus tard ce semestre
à regarder quelque chose

165
00:07:50,590 --> 00:07:52,780
appelé une liste, ou vraiment une liste liée.

166
00:07:52,780 --> 00:07:55,510
Mais pour l'instant, le plus proche
équivalent en C pour nous

167
00:07:55,510 --> 00:07:57,345
va être quelque chose
appelé un tableau.

168
00:07:57,345 --> 00:07:59,740
Et un tableau est tout simplement un
type spécial de la variable

169
00:07:59,740 --> 00:08:03,160
qui vous permet de stocker des données
dos, à dos, à dos, à dos.

170
00:08:03,160 --> 00:08:05,840
>> Et, en effet, dans Scratch,
si nous voulions accéder

171
00:08:05,840 --> 00:08:09,030
le premier élément d'un tableau ou
un films-- et je vais l'appeler,

172
00:08:09,030 --> 00:08:13,600
par convention, argv argument
vecteur, mais plus sur cela avant longtemps.

173
00:08:13,600 --> 00:08:17,090
Si je veux obtenir le premier élément
de argv, dans le monde du Scratch

174
00:08:17,090 --> 00:08:20,930
vous faites en fait généralement
commencer à compter du 1er.

175
00:08:20,930 --> 00:08:22,850
>> Et donc je pourrais obtenir le point 1 de argv.

176
00:08:22,850 --> 00:08:26,310
C'est juste comment MIT mis en œuvre
la notion de listes.

177
00:08:26,310 --> 00:08:29,860
Mais en C, je vais
plus simplement dire simplement, argv,

178
00:08:29,860 --> 00:08:32,758
qui est à nouveau le nom de mon
films-- ou pour être clair, un tableau.

179
00:08:32,758 --> 00:08:34,549
Et si je veux la première
éléments, je vais

180
00:08:34,549 --> 00:08:37,890
d'utiliser des crochets, que vous
peut-être pas souvent utilisé sous un clavier.

181
00:08:37,890 --> 00:08:40,150
>> Mais 0 signifie juste, me faire le premier.

182
00:08:40,150 --> 00:08:42,160
Donc, à l'occasion, et comme
le temps passe, nous allons

183
00:08:42,160 --> 00:08:44,570
pour commencer à voir ces dichotomies
entre zéro et C,

184
00:08:44,570 --> 00:08:46,070
lequel Scratch utilise un.

185
00:08:46,070 --> 00:08:47,670
Nous en C utilisons 0 ici.

186
00:08:47,670 --> 00:08:49,420
Mais vous verrez rapidement
une fois que vous comprenez

187
00:08:49,420 --> 00:08:52,920
les fondements de chaque langue, que
ces choses commencent à devenir d'autant plus

188
00:08:52,920 --> 00:08:56,860
familiers par la pratique et la pratique.

189
00:08:56,860 --> 00:08:59,700
>> Donc, nous allons effectivement maintenant regarder un programme.

190
00:08:59,700 --> 00:09:04,031
Ici sera la première de notre C
code source de programmes complets.

191
00:09:04,031 --> 00:09:06,280
Et le programme que nous allons
à offrir pour examen

192
00:09:06,280 --> 00:09:09,340
est celui qui est l'équivalent
à ce morceau de Scratch plus tôt.

193
00:09:09,340 --> 00:09:13,210
>> Donc, ici, nous avons ce qui est
sans doute le programme le plus simple C

194
00:09:13,210 --> 00:09:15,410
vous pouvez écrire que
ne fait quelque chose.

195
00:09:15,410 --> 00:09:18,250
Maintenant, nous allons regarder passé,
pour l'instant, a inclure,

196
00:09:18,250 --> 00:09:21,190
io.h standard, et ceux-ci angle
entre parenthèses, et int, et non avenu,

197
00:09:21,190 --> 00:09:22,840
et les accolades, et similaires.

198
00:09:22,840 --> 00:09:25,390
>> Et nous allons nous concentrer sur
ce qui, au moins intuitivement,

199
00:09:25,390 --> 00:09:26,860
pourrait sauter à vous déjà.

200
00:09:26,860 --> 00:09:30,300
En fait, le principal, je ne
savoir nécessairement ce que cela est,

201
00:09:30,300 --> 00:09:34,580
mais beaucoup comme Scratch avait que lorsque
drapeau vert cliqué morceau de puzzle,

202
00:09:34,580 --> 00:09:39,070
il en va de C comme un langage de programmation
avoir un morceau principal de code

203
00:09:39,070 --> 00:09:43,380
est exécuté par défaut. Et en effet,
il est littéralement va être appelé principal.

204
00:09:43,380 --> 00:09:44,720
>> Si principale est une fonction.

205
00:09:44,720 --> 00:09:48,720
Et il est une fonction spéciale qui existe
en C que lorsque vous exécutez un programme,

206
00:09:48,720 --> 00:09:52,720
il est le principal qui obtient géré par
défaut. Dans le monde du Scratch,

207
00:09:52,720 --> 00:09:56,970
il était généralement lorsque le drapeau vert
cliqué qui a obtenu exécuter par défaut.

208
00:09:56,970 --> 00:10:01,130
>> Pendant ce temps, nous avons vu cela avant,
printf ou imprimer au format, qui est

209
00:10:01,130 --> 00:10:05,620
va être une fonction qui vient avec
C, ainsi que tout un tas d'autres,

210
00:10:05,620 --> 00:10:10,140
cette volonté de temps et le temps
encore une fois, afin de faire exactement

211
00:10:10,140 --> 00:10:12,450
comme son nom l'indique, imprimer quelque chose.

212
00:10:12,450 --> 00:10:13,500
Que voulons-nous imprimer?

213
00:10:13,500 --> 00:10:15,770
Eh bien, nous allons voir que
par des caractères enserrant

214
00:10:15,770 --> 00:10:18,680
comme these-- monde bonjour,
backslash n entre guillemets,

215
00:10:18,680 --> 00:10:23,040
nous pouvons dire exactement printf
ce que pour imprimer sur l'écran.

216
00:10:23,040 --> 00:10:26,430
>> Mais pour faire
que nous avons malheureusement

217
00:10:26,430 --> 00:10:30,010
besoin de prendre quelque chose qui est
déjà cryptique pour nous les humains,

218
00:10:30,010 --> 00:10:34,510
mais au moins il est un peu readable--
forte comprennent, io.h standard, int,

219
00:10:34,510 --> 00:10:39,340
principale, vide, printf, toute la magie
incantations nous venons de voir à l'écran.

220
00:10:39,340 --> 00:10:42,470
Mais nous avons effectivement
aller plus mystérieux encore.

221
00:10:42,470 --> 00:10:47,140
Nous devons d'abord traduire le code
que nous écrivons en code machine.

222
00:10:47,140 --> 00:10:51,370
Et rappeler de la semaine dernière que les machines,
au moins ceux que nous connaissons ici,

223
00:10:51,370 --> 00:10:54,450
à la fin de la journée seulement
comprendre zéros et des uns.

224
00:10:54,450 --> 00:10:58,100
>> Et mon Dieu, si nous devions écrire ces
zéros et des uns à fait le programme,

225
00:10:58,100 --> 00:11:01,260
il serait très, très rapidement
prendre du plaisir sur quoi que ce soit.

226
00:11:01,260 --> 00:11:05,150
Mais il se trouve, par la semaine dernière,
que ces schémas de zéros et

227
00:11:05,150 --> 00:11:06,400
juste avoir une signification particulière.

228
00:11:06,400 --> 00:11:08,500
Dans certains contextes,
ils pourraient signifier des chiffres.

229
00:11:08,500 --> 00:11:11,840
>> Dans certains contextes, ils pourraient signifier
lettres ou couleurs, ou un nombre quelconque

230
00:11:11,840 --> 00:11:14,710
d'autres abstractions là sur.

231
00:11:14,710 --> 00:11:18,450
Mais tout comme votre ordinateur
une CPU, Central Processing Unit,

232
00:11:18,450 --> 00:11:20,390
ou le cerveau à l'intérieur de votre ordinateur.

233
00:11:20,390 --> 00:11:22,240
Il est généralement Intel
à l'intérieur, parce que ce

234
00:11:22,240 --> 00:11:24,900
l'une des plus grandes entreprises
qui rend les processeurs pour les ordinateurs.

235
00:11:24,900 --> 00:11:28,910
>> Eh bien, les processeurs Intel et d'autres
ont tout simplement décidé à l'avance

236
00:11:28,910 --> 00:11:33,970
que certains modèles de zéros et
ceux entend des choses spécifiques.

237
00:11:33,970 --> 00:11:37,040
Certains modèles de zéros et
signifiera, imprimer à l'écran,

238
00:11:37,040 --> 00:11:39,710
ou ajouter ces deux nombres, ou
soustraire ces deux nombres,

239
00:11:39,710 --> 00:11:43,310
ou déplacer ce morceau de données à partir
la mémoire de mon ordinateur ici,

240
00:11:43,310 --> 00:11:47,870
ou un nombre quelconque d'autres très bas niveau,
mais finalement utile opérations.

241
00:11:47,870 --> 00:11:53,022
Mais, heureusement, nous, les humains ne vont pas
avoir besoin de connaître ce niveau de détail.

242
00:11:53,022 --> 00:11:56,230
En effet, tout comme la dernière fois, où nous
Abstraite encore, et encore, et encore,

243
00:11:56,230 --> 00:11:58,930
bâtiment de très faible niveau
primitives comme zéros et des uns

244
00:11:58,930 --> 00:12:01,160
à la hausse des concepts de niveau
comme les numéros et les lettres,

245
00:12:01,160 --> 00:12:04,330
et les couleurs, et plus encore,
donc pouvons-nous en tant que programmeurs

246
00:12:04,330 --> 00:12:07,080
se tenir debout sur les épaules de
d'autres qui nous ont précédés

247
00:12:07,080 --> 00:12:11,260
et utiliser des logiciels que d'autres
les gens ont écrit avant us--

248
00:12:11,260 --> 00:12:14,340
à savoir les programmes appelés compilateurs.

249
00:12:14,340 --> 00:12:17,770
>> C est une langue
est habituellement compilé,

250
00:12:17,770 --> 00:12:22,130
ce qui veut dire convertie à partir
le code source en code machine.

251
00:12:22,130 --> 00:12:25,230
En particulier, ce que cela signifie
est que si vous avez la source

252
00:12:25,230 --> 00:12:29,530
code qui vous vous écrivez, comme nous bientôt
sera dans un instant sur l'écran,

253
00:12:29,530 --> 00:12:33,140
et que vous voulez convertir
en fin de compte à la machine code--

254
00:12:33,140 --> 00:12:37,100
ces zéros et ceux qui
seulement votre Mac ou votre PC

255
00:12:37,100 --> 00:12:41,230
understands-- vous avez une première
nourrir que le code source en tant

256
00:12:41,230 --> 00:12:46,340
entrée à une spéciale
programme appelé un compilateur,

257
00:12:46,340 --> 00:12:48,974
la sortie de laquelle nous
doit voir est le code machine.

258
00:12:48,974 --> 00:12:51,890
Et, en effet, la dernière fois nous avons parlé
environ, en fait, à la fin de la journée,

259
00:12:51,890 --> 00:12:52,610
résolution de problème.

260
00:12:52,610 --> 00:12:53,360
Vous avez entrées.

261
00:12:53,360 --> 00:12:54,318
Et vous avez sorties.

262
00:12:54,318 --> 00:12:56,560
Et vous avez une sorte
de l'algorithme dans le milieu.

263
00:12:56,560 --> 00:12:59,830
>> Les algorithmes peuvent sûrement
mis en œuvre dans le logiciel,

264
00:12:59,830 --> 00:13:02,900
comme nous l'avons vu avec pseudocode la semaine dernière
et comme nous le verrons avec le code réel

265
00:13:02,900 --> 00:13:03,490
cette semaine.

266
00:13:03,490 --> 00:13:06,430
Et donc un compilateur vraiment juste
a un ensemble d'algorithmes intérieur

267
00:13:06,430 --> 00:13:10,060
de celui qui sait comment
convertir les mots-clés spéciaux,

268
00:13:10,060 --> 00:13:12,180
comme principal et printf,
et d'autres que nous venons

269
00:13:12,180 --> 00:13:17,620
a vu dans les modèles de zéros et
ceux qui Intel à l'intérieur et d'autres processeurs

270
00:13:17,620 --> 00:13:20,020
comprend réellement.

271
00:13:20,020 --> 00:13:22,460
Alors, comment faisons-nous cela?

272
00:13:22,460 --> 00:13:24,470
Où pouvons-nous obtenir un compilateur?

273
00:13:24,470 --> 00:13:26,400
>> La plupart d'entre nous ont un Mac ou un PC.

274
00:13:26,400 --> 00:13:29,152
Et vous êtes sous Mac OS, ou
Windows ou Linux ou Solaris,

275
00:13:29,152 --> 00:13:30,860
ou un nombre quelconque d'autres
systèmes d'exploitation.

276
00:13:30,860 --> 00:13:32,568
Et, en effet, nous avons pu
aller sur le web

277
00:13:32,568 --> 00:13:35,710
et télécharger un compilateur
pour votre Mac ou votre PC

278
00:13:35,710 --> 00:13:37,360
pour votre système d'exploitation particulier.

279
00:13:37,360 --> 00:13:39,617
Mais nous serions tous sur
différentes pages, pour ainsi dire.

280
00:13:39,617 --> 00:13:41,450
Nous aurions légèrement
différentes configurations.

281
00:13:41,450 --> 00:13:43,210
Et les choses ne fonctionneraient pas tous les mêmes.

282
00:13:43,210 --> 00:13:45,280
Et, en effet, ces jours-ci
beaucoup d'entre nous ne pas utiliser

283
00:13:45,280 --> 00:13:47,516
logiciel qui ne fonctionne que sur nos ordinateurs portables.

284
00:13:47,516 --> 00:13:49,390
Au lieu de cela, nous utilisons quelque chose
comme un navigateur

285
00:13:49,390 --> 00:13:52,930
nous permet d'accès Web
applications dans le nuage.

286
00:13:52,930 --> 00:13:55,630
Et plus tard ce semestre,
nous allons faire exactement cela.

287
00:13:55,630 --> 00:13:59,660
Nous allons écrire des applications ou
logiciel en utilisant code-- pas C,

288
00:13:59,660 --> 00:14:02,860
mais d'autres langages comme Python et
JavaScript-- qui courent dans le nuage.

289
00:14:02,860 --> 00:14:05,860
>> Et pour ce faire, nous nous
au cours du semestre

290
00:14:05,860 --> 00:14:11,890
sera effectivement utiliser un basé sur un nuage
environnement connu sous le nom CS50 IDE.

291
00:14:11,890 --> 00:14:16,030
Ceci est une programmation basée sur le Web
environnement ou développement intégré

292
00:14:16,030 --> 00:14:20,610
environnement, IDe, qui est construit au sommet d'une certaine
logiciel open source appelé Cloud 9.

293
00:14:20,610 --> 00:14:22,966
Et nous avons fait des pédagogique
simplifications à ce

294
00:14:22,966 --> 00:14:25,840
afin de cacher certaines caractéristiques
les premières semaines que nous ne devons,

295
00:14:25,840 --> 00:14:27,770
après quoi vous pouvez
les révéler et faire plus

296
00:14:27,770 --> 00:14:29,400
tout ce que vous voulez avec l'environnement.

297
00:14:29,400 --> 00:14:32,470
>> Et cela nous permet, aussi, de
pré-installer certains logiciels.

298
00:14:32,470 --> 00:14:35,330
Des choses comme un soi-disant CS50
bibliothèque, que nous verrons bientôt

299
00:14:35,330 --> 00:14:39,210
nous fournit en C avec une certaine
des fonctionnalités supplémentaires.

300
00:14:39,210 --> 00:14:44,392
Donc, si vous allez à, finalement, CS50.io,
vous serez invité à vous connecter,

301
00:14:44,392 --> 00:14:46,350
et une fois que vous faites et créer
un compte gratuitement,

302
00:14:46,350 --> 00:14:52,150
vous serez en mesure d'accéder à un
environnement qui semble tout à fait comme ça.

303
00:14:52,150 --> 00:14:53,760
>> Or, ceci est dans le mode par défaut.

304
00:14:53,760 --> 00:14:55,650
Tout est agréable et
lumineux sur l'écran.

305
00:14:55,650 --> 00:14:57,941
Beaucoup d'entre nous ont l'habitude de
travailler sur le morceau de CS50 qui est

306
00:14:57,941 --> 00:14:59,150
assez tard dans la nuit.

307
00:14:59,150 --> 00:15:02,400
Et certains d'entre vous pourraient préférer
transformer en mode nuit, pour ainsi dire.

308
00:15:02,400 --> 00:15:05,550
>> Mais, en fin de compte, ce que vous êtes
aller voir dans les CS50 IDE

309
00:15:05,550 --> 00:15:08,340
est trois areas-- distincte
une zone sur la gauche où

310
00:15:08,340 --> 00:15:12,604
vos fichiers vont être dans la
nuage, une zone en haut à droite

311
00:15:12,604 --> 00:15:14,270
où votre code va être modifiable.

312
00:15:14,270 --> 00:15:16,650
Vous serez en mesure d'ouvrir
onglets individuels pour tout programme

313
00:15:16,650 --> 00:15:19,670
que vous écrivez ce semestre à l'intérieur
de ce coin en haut à droite.

314
00:15:19,670 --> 00:15:23,070
Et puis plus arcanely,
et pourtant puissamment,

315
00:15:23,070 --> 00:15:26,610
va être cette chose à la
bas connu comme une fenêtre de terminal.

316
00:15:26,610 --> 00:15:29,450
>> Ceci est une ancienne école
Command Line Interface,

317
00:15:29,450 --> 00:15:32,240
ou CLI, qui permet
d'exécuter des commandes

318
00:15:32,240 --> 00:15:35,260
sur le computer-- dans ce cas,
l'ordinateur dans le cloud--

319
00:15:35,260 --> 00:15:39,090
à faire des choses comme compiler votre code
à partir du code source en code machine,

320
00:15:39,090 --> 00:15:43,600
pour exécuter vos programmes, ou pour commencer votre
serveur web, ou pour accéder à votre base de données,

321
00:15:43,600 --> 00:15:47,454
et un certain nombre d'autres techniques
que nous allons commencer à utiliser avant longtemps.

322
00:15:47,454 --> 00:15:49,370
Mais pour y arriver, nous sommes
va avoir effectivement

323
00:15:49,370 --> 00:15:51,240
d'aller en ligne et commencer à jouer.

324
00:15:51,240 --> 00:15:54,399
Et pour ce faire, nous allons d'abord
commencer à bricoler avec principale,

325
00:15:54,399 --> 00:15:55,940
et écrire la partie principale d'un programme.

326
00:15:55,940 --> 00:15:59,170
Et nous allons utiliser cette fonction
printf, que nous avons utilisé plus tôt,

327
00:15:59,170 --> 00:16:01,050
tout simplement pour dire quelque chose.

328
00:16:01,050 --> 00:16:04,910
>> Donc ici, je suis déjà à l'intérieur du CS50 IDE.

329
00:16:04,910 --> 00:16:05,930
Je suis connecté à l'avance.

330
00:16:05,930 --> 00:16:07,360
Et je complète DEPISTAGE la fenêtre.

331
00:16:07,360 --> 00:16:09,670
Et donc, en fin de compte, vous
trop de problèmes à venir

332
00:16:09,670 --> 00:16:12,960
suivra les étapes similaires
fournira la documentation en ligne.

333
00:16:12,960 --> 00:16:16,360
Donc, vous ne devez pas vous inquiéter au sujet
absorber chaque petite étape technique

334
00:16:16,360 --> 00:16:17,730
que je fais ici aujourd'hui.

335
00:16:17,730 --> 00:16:19,222
>> Mais vous obtiendrez un écran comme celui-ci.

336
00:16:19,222 --> 00:16:20,430
Je me trouve être en mode nuit.

337
00:16:20,430 --> 00:16:22,944
Et vous pouvez égayer tout
par désactivation du mode nuit.

338
00:16:22,944 --> 00:16:24,860
Et à la fin de la
jour, vous allez voir

339
00:16:24,860 --> 00:16:30,090
ces trois principaux areas-- le fichier
navigateur à gauche, les onglets de code en haut,

340
00:16:30,090 --> 00:16:32,430
et la fenêtre du terminal vers le bas.

341
00:16:32,430 --> 00:16:34,890
>> Laissez-moi aller de l'avant et
écrire mon premier programme.

342
00:16:34,890 --> 00:16:42,300
Je vais aller préemptive dans un fichier,
Enregistrer et enregistrer mon fichier comme hello.c.

343
00:16:42,300 --> 00:16:46,850
En effet, par convention, tout ce que nous programme
écriture qui est écrit dans le langage C

344
00:16:46,850 --> 00:16:49,739
devrait être nommé quelque chose
point c, par convention.

345
00:16:49,739 --> 00:16:53,030
Donc, je vais le nommer hello.c, parce
Je veux juste dire bonjour au monde.

346
00:16:53,030 --> 00:16:54,820
Maintenant, je vais faire un zoom
out et cliquez sur Enregistrer.

347
00:16:54,820 --> 00:16:58,180
Et tout ce que j'ai ici maintenant est un onglet
dans lequel je peux commencer à écrire du code.

348
00:16:58,180 --> 00:16:59,490
>> Cela ne va pas à compiler.

349
00:16:59,490 --> 00:17:00,300
Cela n'a aucun sens.

350
00:17:00,300 --> 00:17:02,750
Et même si je me suis converti
cela zéros et des uns,

351
00:17:02,750 --> 00:17:05,390
la CPU va avoir aucun
idée de ce qui se passe autour.

352
00:17:05,390 --> 00:17:14,170
Mais si j'écris les lignes qui ne correspondent
avec conventions-- C étant de C,

353
00:17:14,170 --> 00:17:20,150
à nouveau, cette language-- avec la syntaxe comme
cela, printf bonjour monde-- et je l'ai

354
00:17:20,150 --> 00:17:22,210
obtenu à l'aise avec
faisant cela au fil du temps.

355
00:17:22,210 --> 00:17:24,510
Donc, je ne pense pas que je fait
toute erreur typographique.

356
00:17:24,510 --> 00:17:27,910
>> Mais, invariablement, la première
fois que vous faites cela, vous.

357
00:17:27,910 --> 00:17:31,090
Et ce que je vais faire pourrait très
bien fonctionne pas pour vous la première fois.

358
00:17:31,090 --> 00:17:33,610
Et c'est parfaitement OK,
parce que maintenant vous

359
00:17:33,610 --> 00:17:37,662
pourrait bien voir un tas de nouveauté,
mais au fil du temps une fois que vous familiariser

360
00:17:37,662 --> 00:17:39,870
avec cet environnement, et
ce langage, et d'autres,

361
00:17:39,870 --> 00:17:42,370
vous allez commencer à voir des choses qui
sont soit correcte ou incorrecte.

362
00:17:42,370 --> 00:17:44,369
>> Et voici ce que le
boursiers d'enseignement et bien sûr

363
00:17:44,369 --> 00:17:48,780
assistants sont tellement bons au fil du temps, est
repérer des erreurs ou des bugs dans votre code.

364
00:17:48,780 --> 00:17:52,110
Mais je prétends qu'il y
n'y a pas de bugs dans ce code.

365
00:17:52,110 --> 00:17:53,990
Je veux maintenant exécuter ce programme.

366
00:17:53,990 --> 00:17:57,440
>> Maintenant, sur mon propre Mac ou PC, je suis en
l'habitude de doubles icônes de cliquetis

367
00:17:57,440 --> 00:17:59,350
quand je veux lancer un programme.

368
00:17:59,350 --> 00:18:01,080
Mais ce n'est pas le modèle ici.

369
00:18:01,080 --> 00:18:04,570
Dans cet environnement, qui est CS50 IDE.

370
00:18:04,570 --> 00:18:07,192
Nous utilisons une exploitation
système appelé Linux.

371
00:18:07,192 --> 00:18:09,900
Linux rappelle une autre
système d'exploitation, généralement connu

372
00:18:09,900 --> 00:18:10,850
comme Unix.

373
00:18:10,850 --> 00:18:16,340
Et Linux est particulièrement connu pour
ayant une ligne de commande de l'environnement, CLI.

374
00:18:16,340 --> 00:18:20,070
Maintenant, nous utilisons un particulier
saveur de Linux appelée Ubuntu.

375
00:18:20,070 --> 00:18:22,770
Et Ubuntu est tout simplement un
certaine version de Linux.

376
00:18:22,770 --> 00:18:27,900
>> Mais de ces Linux ces jours-ci font réellement
venir avec des interfaces utilisateur graphiques.

377
00:18:27,900 --> 00:18:30,360
Et celui que nous arrive de
être en utilisant ici est basé sur le Web.

378
00:18:30,360 --> 00:18:32,735
Donc, cela pourrait regarder même un
peu différent de quelque chose

379
00:18:32,735 --> 00:18:35,310
vous vous pourriez avoir
vu ou courir dans le passé.

380
00:18:35,310 --> 00:18:37,910
>> Je vais donc aller de l'avant
maintenant et faire ce qui suit.

381
00:18:37,910 --> 00:18:40,950
J'ai sauvé ce fichier comme hello.c.

382
00:18:40,950 --> 00:18:47,350
Je vais aller de l'avant et
Type clanghello.c Alors Clang

383
00:18:47,350 --> 00:18:49,850
pour le langage C est un compilateur.

384
00:18:49,850 --> 00:18:51,952
Il est pré-installé dans CS50 IDE.

385
00:18:51,952 --> 00:18:54,910
Et vous ne pouvez absolument télécharger et
installer sur votre propre Mac ou PC.

386
00:18:54,910 --> 00:18:57,910
>> Mais, encore une fois, il n'y aurait pas tous
la pré-configuration fait pour vous.

387
00:18:57,910 --> 00:19:00,940
Donc pour l'instant, je suis juste
va courir clanghello.c.

388
00:19:00,940 --> 00:19:03,240
Et maintenant remarquer cette syntaxe
ici finira

389
00:19:03,240 --> 00:19:06,930
réalise signifie juste que je suis dans un
dossier ou un répertoire appelé espace de travail.

390
00:19:06,930 --> 00:19:11,030
Ce signe dollar est juste convention
de sens, tapez vos commandes ici.

391
00:19:11,030 --> 00:19:14,560
>> Il est ce qu'on appelle une invite, juste
par convention est le signe dollar.

392
00:19:14,560 --> 00:19:19,130
Et si j'aller de l'avant maintenant et cliquez sur
Entrez, rien ne semble s'être produit.

393
00:19:19,130 --> 00:19:20,930
Mais c'est en fait une bonne chose.

394
00:19:20,930 --> 00:19:23,650
Le moins ce qui se passe sur
votre écran, plus il est probable

395
00:19:23,650 --> 00:19:26,710
votre code est d'être correct,
au moins syntaxiquement.

396
00:19:26,710 --> 00:19:29,120
>> Donc, si je veux courir ce
programme, que dois-je faire?

397
00:19:29,120 --> 00:19:33,770
Eh bien, il se trouve que la
le nom par défaut, par convention,

398
00:19:33,770 --> 00:19:38,854
pour les programmes lorsque vous ne spécifiez pas de
le nom de votre programme est juste a.out.

399
00:19:38,854 --> 00:19:41,270
Et cette syntaxe aussi, vous aurez
se familiariser avec avant longtemps.

400
00:19:41,270 --> 00:19:47,500
>> Dot slash signifie juste, hé, CS50
IDE, exécutez un programme appelé a.out

401
00:19:47,500 --> 00:19:49,400
qui est dans mon répertoire en cours.

402
00:19:49,400 --> 00:19:51,520
Ce point signifie le répertoire courant.

403
00:19:51,520 --> 00:19:55,040
Et nous allons voir ce que d'autres telles séquences
de caractères signifie avant longtemps.

404
00:19:55,040 --> 00:19:58,430
>> Alors on y va, Entrée, bonjour monde.

405
00:19:58,430 --> 00:20:00,080
Et vous remarquerez, que ce qui est arrivé?

406
00:20:00,080 --> 00:20:01,580
Non seulement at-il imprimer bonjour monde.

407
00:20:01,580 --> 00:20:05,990
Il a également proposé la
curseur à la ligne suivante.

408
00:20:05,990 --> 00:20:07,160
>> Et pourquoi était-ce?

409
00:20:07,160 --> 00:20:12,400
Quel était le code que nous avons écrit avant
qui veillé à ce que le curseur serait

410
00:20:12,400 --> 00:20:14,882
aller sur la ligne suivante?

411
00:20:14,882 --> 00:20:16,840
Chose drôle au sujet d'un
ordinateur est il va seulement

412
00:20:16,840 --> 00:20:18,570
de faire littéralement ce que vous lui demandez de faire.

413
00:20:18,570 --> 00:20:26,050
>> Donc, si vous le dites à printf bonjour,
virgule, espace, monde, près devis,

414
00:20:26,050 --> 00:20:29,090
il est littéralement ne va
d'imprimer ces caractères.

415
00:20:29,090 --> 00:20:31,980
Mais j'ai eu ce caractère spécial
à la fin, le rappel, backslash n.

416
00:20:31,980 --> 00:20:34,230
Et voilà ce qui assure
que le caractère a

417
00:20:34,230 --> 00:20:36,570
à la ligne suivante de l'écran.

418
00:20:36,570 --> 00:20:38,097
>> En fait, laissez-moi aller et le faire.

419
00:20:38,097 --> 00:20:39,430
Laissez-moi aller de l'avant et de supprimer cela.

420
00:20:39,430 --> 00:20:41,180
Maintenant, notez que la
haut de mon écran, il est

421
00:20:41,180 --> 00:20:42,890
un peu de lumière rouge
l'onglet indiquant,

422
00:20:42,890 --> 00:20:45,047
hey, vous avez pas enregistré votre fichier.

423
00:20:45,047 --> 00:20:47,880
Je vais donc aller de l'avant avec le contrôle
S ou commande S, enregistrez le fichier.

424
00:20:47,880 --> 00:20:51,130
Maintenant, il goes-- est allé pour un vert moment--.

425
00:20:51,130 --> 00:20:53,760
Et maintenant il est de retour à
juste être une icône proche.

426
00:20:53,760 --> 00:21:01,860
>> Si je lance maintenant clanghello.c à nouveau,
Entrez, slash dot, a.out, Entrée,

427
00:21:01,860 --> 00:21:04,110
vous verrez que cela a fonctionné encore.

428
00:21:04,110 --> 00:21:06,020
Mais il est sans doute un peu buggé.

429
00:21:06,020 --> 00:21:08,714
En ce moment, mon espace de travail prompt--,
puis ce signe de dollar,

430
00:21:08,714 --> 00:21:10,880
et puis mon prompt-- réelle
est le tout sur la même ligne.

431
00:21:10,880 --> 00:21:14,540
Donc, cela a certainement un bug esthétique,
même si elle est pas vraiment un bug logique.

432
00:21:14,540 --> 00:21:16,250
>> Donc, je vais défaire ce que je viens de faire.

433
00:21:16,250 --> 00:21:18,560
Je vais relancer a.out.

434
00:21:18,560 --> 00:21:22,710
Remarquez que j'ai ajouté la
newline retour de caractère.

435
00:21:22,710 --> 00:21:24,280
Je l'ai enregistré le fichier.

436
00:21:24,280 --> 00:21:31,630
>> Donc, je vais relancer a.out, et--
dammit, un bogue, un bogue qui signifie erreur.

437
00:21:31,630 --> 00:21:35,020
Ainsi, le bug est que même si
J'ai ajouté le backslash n là,

438
00:21:35,020 --> 00:21:41,180
re-enregistré, re-dirigé le programme,
le comportement était le même.

439
00:21:41,180 --> 00:21:42,640
Pourquoi serait-ce?

440
00:21:42,640 --> 00:21:43,910
>> Il me manque une étape, non?

441
00:21:43,910 --> 00:21:47,620
Cette étape clé a été plus tôt que vous avez
to-- lorsque vous modifiez votre code source,

442
00:21:47,620 --> 00:21:49,610
il se trouve aussi fonctionner
par l'intermédiaire du compilateur

443
00:21:49,610 --> 00:21:51,102
à nouveau de sorte que vous obtenez le nouveau code de la machine.

444
00:21:51,102 --> 00:21:52,810
Et le code de la machine,
les zéros et les uns,

445
00:21:52,810 --> 00:21:56,260
vont être à peu près identique, mais
pas parfaitement, parce que nous avons besoin,

446
00:21:56,260 --> 00:21:57,510
bien sûr, que la nouvelle ligne.

447
00:21:57,510 --> 00:22:02,640
>> Donc, pour résoudre ce problème, je vais avoir besoin
réexécuter clanghello.c, entrez, dot

448
00:22:02,640 --> 00:22:03,800
slash, a.out.

449
00:22:03,800 --> 00:22:08,402
Et maintenant, bonjour tout le monde est de retour
là où je pense qu'elle doit être.

450
00:22:08,402 --> 00:22:09,610
Donc, tout cela est bel et bon.

451
00:22:09,610 --> 00:22:13,150
Mais a.out est un nom assez stupide pour un
programme, même si elle se trouve être,

452
00:22:13,150 --> 00:22:16,530
pour des raisons historiques, la
default-- signifie sorties d'assemblage.

453
00:22:16,530 --> 00:22:20,780
>> Mais laissez-moi aller de l'avant ici
et cela différemment.

454
00:22:20,780 --> 00:22:24,760
Je veux que mon programme bonjour mondial
effectivement être appelé bonjour.

455
00:22:24,760 --> 00:22:28,320
Donc, si elle était une icône sur mon
bureau, il ne serait pas a.out.

456
00:22:28,320 --> 00:22:29,730
Il serait appelé bonjour.

457
00:22:29,730 --> 00:22:33,660
>> Donc, pour ce faire, il se trouve
que Clang, comme de nombreux programmes,

458
00:22:33,660 --> 00:22:37,980
soutient les arguments de ligne de commande,
ou des drapeaux, ou des commutateurs,

459
00:22:37,980 --> 00:22:39,600
qui influencent simplement son comportement.

460
00:22:39,600 --> 00:22:45,160
Plus précisément, Clang prend en charge un tiret o
drapeau, qui prend alors un second mot.

461
00:22:45,160 --> 00:22:48,190
Dans ce cas, je vais arbitrairement,
mais raisonnablement, appeler bonjour.

462
00:22:48,190 --> 00:22:50,710
Mais je pourrais appeler ça
Je veux, sauf a.out, qui

463
00:22:50,710 --> 00:22:52,390
serait plutôt d'ailleurs le point.

464
00:22:52,390 --> 00:22:55,640
>> Et puis il suffit de spécifier le nom
du fichier que je ne veux compiler.

465
00:22:55,640 --> 00:22:59,190
Alors maintenant, même si au début
de la commande, je dois encore Clang,

466
00:22:59,190 --> 00:23:01,410
à la fin de la commande
J'ai encore le nom du fichier,

467
00:23:01,410 --> 00:23:05,520
J'ai maintenant ces lignes de commande
arguments, ces drapeaux qui disent,

468
00:23:05,520 --> 00:23:11,180
oh, en passant, la sortie-o, un fichier
appelé bonjour, pas le a.out par défaut.

469
00:23:11,180 --> 00:23:13,810
>> Donc, si je frappe maintenant entrer, rien
semble s'être produit.

470
00:23:13,810 --> 00:23:17,900
Et pourtant, maintenant, je peux faire slash dot bonjour.

471
00:23:17,900 --> 00:23:19,089
Il est donc le même programme.

472
00:23:19,089 --> 00:23:21,380
Les zéros et les uns sont
identique à la fin de la journée.

473
00:23:21,380 --> 00:23:24,210
>> Mais ils sont en deux
différente a.out files--,

474
00:23:24,210 --> 00:23:26,490
qui est la première version
et juste bêtement nommé,

475
00:23:26,490 --> 00:23:30,250
et maintenant bonjour, qui est un bien
nom de plus convaincant pour un programme.

476
00:23:30,250 --> 00:23:33,195
Mais, honnêtement, je ne suis jamais
va se souvenir de ce nouveau,

477
00:23:33,195 --> 00:23:34,070
et encore et encore.

478
00:23:34,070 --> 00:23:36,411
Et, en fait, que nous écrivons
programmes plus complexes,

479
00:23:36,411 --> 00:23:38,160
les commandes que vous êtes
allez avoir à écrire

480
00:23:38,160 --> 00:23:40,920
vont devenir encore
plus compliqué encore.

481
00:23:40,920 --> 00:23:41,940
>> Et ne vous inquiétez pas.

482
00:23:41,940 --> 00:23:46,220
Il se trouve que les humains avant
nous avons réalisé eux aussi

483
00:23:46,220 --> 00:23:47,530
eu ce même problème.

484
00:23:47,530 --> 00:23:50,900
Ils ne bénéficient pas non plus avoir à
tapez assez longues, les commandes ésotériques,

485
00:23:50,900 --> 00:23:52,200
et encore moins en souvenir.

486
00:23:52,200 --> 00:23:56,070
Et les humains qui nous ont fait
d'autres programmes qui facilitent

487
00:23:56,070 --> 00:23:57,670
pour compiler votre logiciel.

488
00:23:57,670 --> 00:24:01,609
>> Et, en effet, un tel
programme est appelé Marque.

489
00:24:01,609 --> 00:24:03,150
Je vais donc aller de l'avant et de le faire.

490
00:24:03,150 --> 00:24:05,691
Je vais défaire tout ce que je
vient de le faire de la manière suivante.

491
00:24:05,691 --> 00:24:07,690
Permettez-moi de taper LS.

492
00:24:07,690 --> 00:24:10,980
Et vous remarquerez trois things--
a.out, et une étoile, bonjour

493
00:24:10,980 --> 00:24:12,810
et une étoile, et hello.c.

494
00:24:12,810 --> 00:24:14,730
Espérons que cela devrait
être un peu intuitive,

495
00:24:14,730 --> 00:24:18,220
dans la mesure où il y avait précédemment
rien dans cet espace de travail.

496
00:24:18,220 --> 00:24:21,240
Il n'y avait rien que je devais
créé jusqu'à ce que nous avons commencé la classe.

497
00:24:21,240 --> 00:24:22,840
>> Et je créé hello.c.

498
00:24:22,840 --> 00:24:24,544
Je puis compilé, et l'a appelé a.out.

499
00:24:24,544 --> 00:24:27,460
Et puis je compilé à nouveau légèrement
différemment et appelé bonjour.

500
00:24:27,460 --> 00:24:32,830
J'ai trois fichiers dans ce répertoire,
dans ce dossier appelé espace de travail.

501
00:24:32,830 --> 00:24:35,005
Maintenant, je peux voir cela aussi
si je zoome sur réellement.

502
00:24:35,005 --> 00:24:37,530
>> Si je zoome ici et
regarder cette main en haut à droite

503
00:24:37,530 --> 00:24:39,940
coin, comme promis la gauche
côté de votre écran

504
00:24:39,940 --> 00:24:42,990
va toujours vous montrer
ce qui est dans votre compte, ce qui est

505
00:24:42,990 --> 00:24:44,790
intérieur du CS50 IDE.

506
00:24:44,790 --> 00:24:46,680
Et il y a trois fichiers.

507
00:24:46,680 --> 00:24:49,070
>> Donc, je veux me débarrasser de a.out et bonjour.

508
00:24:49,070 --> 00:24:51,275
Et comme vous pouvez
imaginer intuitivement, vous

509
00:24:51,275 --> 00:24:53,400
pourrait trier du contrôle cliquez
ou un clic droit sur ce point.

510
00:24:53,400 --> 00:24:54,590
Et ce petit menu apparaît.

511
00:24:54,590 --> 00:24:57,170
Vous pouvez télécharger le fichier, exécutez
elle, prévisualiser, rafraîchir, renommer,

512
00:24:57,170 --> 00:24:57,700
ou de ce pas.

513
00:24:57,700 --> 00:25:00,260
>> Et je ne pouvais tout simplement supprimer,
et il irait.

514
00:25:00,260 --> 00:25:05,260
Mais nous allons faire les choses avec une commande
ligne pour le moment, de manière à mettre à l'aise

515
00:25:05,260 --> 00:25:07,010
avec cela, et faire ce qui suit.

516
00:25:07,010 --> 00:25:12,345
Je vais aller de l'avant et retirer
a.out en tapant littéralement rma.out.

517
00:25:12,345 --> 00:25:14,890
Il se trouve, la commande pour
la suppression ou la suppression de quelque chose,

518
00:25:14,890 --> 00:25:16,280
est pas retirer ou supprimer.

519
00:25:16,280 --> 00:25:21,260
>> Il est plus succinctement RM, juste pour sauver
vous quelques frappes, et appuyez sur Entrée.

520
00:25:21,260 --> 00:25:24,707
Maintenant, nous allons être un peu
supprimer énigmatiquement a.out fichier régulier.

521
00:25:24,707 --> 00:25:27,040
Je ne sais pas vraiment ce qu'est un
fichier irrégulière serait encore.

522
00:25:27,040 --> 00:25:28,660
Mais je ne veux l'enlever.

523
00:25:28,660 --> 00:25:30,150
>> Donc, je vais y entrer pour oui.

524
00:25:30,150 --> 00:25:31,940
Ou je pourrais taper sur, et appuyez sur Entrée.

525
00:25:31,940 --> 00:25:33,440
Et, encore une fois, rien ne semble se produire.

526
00:25:33,440 --> 00:25:35,840
Mais cela est, en général, une bonne chose.

527
00:25:35,840 --> 00:25:40,490
>> Si je tape LS cette fois,
Que dois-je voir?

528
00:25:40,490 --> 00:25:44,930
Espérons juste bonjour et hello.c.

529
00:25:44,930 --> 00:25:47,286
Maintenant, en passant, vous aurez
remarquer cette étoile, astérisque,

530
00:25:47,286 --> 00:25:48,660
qui est à la fin de mes programmes.

531
00:25:48,660 --> 00:25:50,201
Et ils sont également montrant en vert.

532
00:25:50,201 --> 00:25:53,970
C'est juste moyen de CS50 IDE
vous cluing dans le fait

533
00:25:53,970 --> 00:25:55,280
que ce n'est pas le code source.

534
00:25:55,280 --> 00:25:58,880
C'est un exécutable, un runnable
programme que vous pouvez réellement exécuter

535
00:25:58,880 --> 00:26:01,020
en faisant slash dot, puis son nom.

536
00:26:01,020 --> 00:26:05,860
>> Maintenant, laissez-moi aller de l'avant et de supprimer
cela, rm bonjour, Entrez, enlever régulièrement

537
00:26:05,860 --> 00:26:08,010
déposer bonjour, oui.

538
00:26:08,010 --> 00:26:11,180
Et maintenant, si je tape LS,
nous sommes de retour à hello.c.

539
00:26:11,180 --> 00:26:13,917
Essayez de ne pas supprimer votre
code source.

540
00:26:13,917 --> 00:26:16,250
Même si il y a des caractéristiques
intégré dans CS50 IDE où

541
00:26:16,250 --> 00:26:19,870
vous pouvez passer par votre historique de révision
et revenir en arrière dans le temps si vous avez accidentellement

542
00:26:19,870 --> 00:26:23,660
supprimer quelque chose, faire garder à l'esprit
selon ces invites oui ou non,

543
00:26:23,660 --> 00:26:25,381
de ce que vous voulez réellement faire.

544
00:26:25,381 --> 00:26:27,380
Et si je monte vers le haut
coin gauche de la main ici,

545
00:26:27,380 --> 00:26:30,696
tout ce qui reste est hello.c.

546
00:26:30,696 --> 00:26:32,570
Donc, il y a des grappes de
d'autres commandes que vous

547
00:26:32,570 --> 00:26:37,550
peut exécuter dans le monde de Linux,
dont l'un est, encore une fois, Make.

548
00:26:37,550 --> 00:26:40,180
Et nous allons faire
mon programme maintenant comme suit.

549
00:26:40,180 --> 00:26:43,270
>> Au lieu de faire clang,
au lieu de faire clang-o,

550
00:26:43,270 --> 00:26:45,860
Je vais tout simplement
taper littéralement, faire bonjour.

551
00:26:45,860 --> 00:26:49,630
Et maintenant remarqué, je suis
pas tapant make hello.c.

552
00:26:49,630 --> 00:26:50,910
Je tape faire bonjour.

553
00:26:50,910 --> 00:26:54,840
>> Et ce programme Faire que
est livré avec CS50 IDE, et plus

554
00:26:54,840 --> 00:26:57,090
généralement avec Linux,
est un programme qui est

555
00:26:57,090 --> 00:26:59,120
va faire un programme appelé Bonjour.

556
00:26:59,120 --> 00:27:03,680
Et il va supposer, par convention,
que si ce programme peut être faite,

557
00:27:03,680 --> 00:27:09,030
il va être fait à partir d'une source
fichier de code se terminant par c dot, hello.c.

558
00:27:09,030 --> 00:27:12,210
>> Donc, si je frappe Entrez maintenant, notez que
la commande qui est exécuté

559
00:27:12,210 --> 00:27:14,340
est en fait encore plus longtemps
avant qu'auparavant.

560
00:27:14,340 --> 00:27:16,670
Et c'est parce que nous avons
préconfiguré CS50 IDE pour avoir

561
00:27:16,670 --> 00:27:19,878
quelques fonctionnalités supplémentaires intégrées dans ce
on n'a pas besoin pour l'instant, mais bientôt.

562
00:27:19,878 --> 00:27:23,470
Mais l'élément clé pour réaliser
est maintenant j'ai un programme Bonjour.

563
00:27:23,470 --> 00:27:27,080
>> Si je tape à nouveau LS, je
avoir un programme de bonjour.

564
00:27:27,080 --> 00:27:32,070
Et je peux courir avec
dot slash a.out, non,

565
00:27:32,070 --> 00:27:35,590
parce que le point entier de cette
exercice était dot slash bonjour.

566
00:27:35,590 --> 00:27:38,089
Et maintenant je dois mon programme bonjour mondial.

567
00:27:38,089 --> 00:27:39,880
Donc, aller de l'avant,
nous sommes presque toujours juste

568
00:27:39,880 --> 00:27:42,088
va compiler nos programmes
en utilisant la commande Marque.

569
00:27:42,088 --> 00:27:45,300
Et puis nous allons les exécuter par
dot slash et le nom du programme.

570
00:27:45,300 --> 00:27:49,610
Mais réaliser ce que font est fait pour
vous, est-ce est pas lui-même un compilateur.

571
00:27:49,610 --> 00:27:53,310
Il est juste un programme de commodité
qui sait comment déclencher un compilateur

572
00:27:53,310 --> 00:27:56,470
pour exécuter de telle sorte que vous vous pouvez l'utiliser.

573
00:27:56,470 --> 00:28:00,220
>> Quelles autres commandes existent dans
Linux, et à son tour le CS50 IDE?

574
00:28:00,220 --> 00:28:03,107
Nous verrons bientôt qu'il ya un
commande CD, Changer de répertoire.

575
00:28:03,107 --> 00:28:05,190
Cela vous permet dans les
votre interface de ligne de commande

576
00:28:05,190 --> 00:28:07,610
pour aller de l'avant et en arrière,
et d'ouvrir des dossiers différents

577
00:28:07,610 --> 00:28:08,860
sans utiliser votre souris.

578
00:28:08,860 --> 00:28:12,470
>> LS nous avons vu, qui signifie la liste
les fichiers dans le répertoire en cours.

579
00:28:12,470 --> 00:28:14,650
Faire Dir, vous pouvez
probablement commencer à déduire

580
00:28:14,650 --> 00:28:18,150
ce que cela signifie maintenant-- créer le répertoire,
si vous voulez créer un dossier.

581
00:28:18,150 --> 00:28:21,270
RM pour supprimer, RM Dir
supprimer directory-- et ceux-ci,

582
00:28:21,270 --> 00:28:24,160
à nouveau, sont la ligne de commande
équivalents de ce que vous

583
00:28:24,160 --> 00:28:26,945
pourrait faire CS50 IDE avec votre souris.

584
00:28:26,945 --> 00:28:28,820
Mais vous trouverez bientôt
que parfois il est juste

585
00:28:28,820 --> 00:28:30,610
beaucoup plus rapide à faire
les choses avec un clavier,

586
00:28:30,610 --> 00:28:33,690
et, finalement, beaucoup plus puissant.

587
00:28:33,690 --> 00:28:36,440
>> Mais il est difficile de faire valoir que
tout ce que nous avons fait jusqu'à présent

588
00:28:36,440 --> 00:28:39,990
est tout ce que puissant, quand tout
nous disons est, bonjour monde.

589
00:28:39,990 --> 00:28:43,740
Et, en fait, je l'Hardcoded
mots bonjour monde dans mon programme.

590
00:28:43,740 --> 00:28:45,530
Il n'y a pas encore de dynamisme.

591
00:28:45,530 --> 00:28:49,320
Scratch est un ordre de grandeur
plus intéressante la semaine dernière.

592
00:28:49,320 --> 00:28:51,220
>> Et donc nous allons y arriver.

593
00:28:51,220 --> 00:28:55,310
Prenons un pas vers ce que par
mode de certaines de ces fonctions.

594
00:28:55,310 --> 00:28:59,470
Donc, non seulement C viennent avec printf,
et des grappes d'autres fonctions

595
00:28:59,470 --> 00:29:01,850
dont certains que nous allons voir
au fil du temps, il n'a pas

596
00:29:01,850 --> 00:29:05,760
faire tout ce qui facile dès la sortie
de la porte d'entrée dans l'obtention de l'utilisateur.

597
00:29:05,760 --> 00:29:08,140
>> En effet, une des lacunes
des langages comme C,

598
00:29:08,140 --> 00:29:10,140
et même Java et encore
d'autres, est que cela ne

599
00:29:10,140 --> 00:29:15,860
le rendre facile à obtenir juste des choses comme
entiers des utilisateurs, ou des chaînes, des mots,

600
00:29:15,860 --> 00:29:19,970
et les phrases, laisser les choses comme seul
valeurs à virgule flottante ou nombres réels

601
00:29:19,970 --> 00:29:23,240
avec des points décimaux, et vraiment
numéros longs, comme nous le verrons bientôt.

602
00:29:23,240 --> 00:29:27,000
Donc, cette liste de fonctions ici, ceux-ci
sont comme les autres pièces de puzzle Scratch

603
00:29:27,000 --> 00:29:31,090
que nous avons pré-installé dans CS50
IDE que nous allons utiliser pour quelques semaines

604
00:29:31,090 --> 00:29:34,010
comme des roues de formation de toutes sortes, et
éventuellement les enlever, et de regarder

605
00:29:34,010 --> 00:29:37,210
sous le capot, peut-être,
comment ces choses sont mises en œuvre.

606
00:29:37,210 --> 00:29:40,460
>> Mais pour ce faire, nous allons
en fait écrire un programme.

607
00:29:40,460 --> 00:29:41,770
Laissez-moi aller de l'avant maintenant.

608
00:29:41,770 --> 00:29:44,750
Et je vais créer un nouveau
déposer en cliquant sur ce petit plus,

609
00:29:44,750 --> 00:29:45,970
et en cliquant sur Nouveau fichier.

610
00:29:45,970 --> 00:29:49,250
>> Je vais enregistrer cette prochaine
un comme, disons, string.c,

611
00:29:49,250 --> 00:29:50,750
parce que je veux jouer avec des cordes.

612
00:29:50,750 --> 00:29:53,990
Et chaîne dans C est juste
une séquence de caractères.

613
00:29:53,990 --> 00:29:56,090
Alors maintenant, nous allons aller de l'avant
et procédez comme suit.

614
00:29:56,090 --> 00:30:01,204
>> Inclure la norme IO.h-- et
il se trouve la norme IO,

615
00:30:01,204 --> 00:30:03,360
IO signifie simplement entrée et de sortie.

616
00:30:03,360 --> 00:30:05,920
Ainsi, il apparaît que
cette ligne ici est ce que

617
00:30:05,920 --> 00:30:08,140
est le voisin de nous d'utiliser printf.

618
00:30:08,140 --> 00:30:10,410
Printf, bien entendu, produit de sortie.

619
00:30:10,410 --> 00:30:15,000
Ainsi, afin d'utiliser printf, il se
out, vous devez avoir cette ligne de code

620
00:30:15,000 --> 00:30:16,040
en haut de votre fichier.

621
00:30:16,040 --> 00:30:18,456
>> Et nous reviendrons sur ce
cela signifie vraiment avant longtemps.

622
00:30:18,456 --> 00:30:20,400
Il se trouve que, dans
tout programme de C je vous écris,

623
00:30:20,400 --> 00:30:23,640
Je dois commencer avec
code qui ressemble à ceci.

624
00:30:23,640 --> 00:30:26,860
Et vous remarquerez CS50 IDE et
autre développement intégré

625
00:30:26,860 --> 00:30:30,050
environnements comme elle,
vont essayer mieux

626
00:30:30,050 --> 00:30:31,780
ils peuvent terminer votre pensée.

627
00:30:31,780 --> 00:30:35,930
En fait, il y a un instant si j'Annuler
ce que je viens de faire, je frappe sur Entrée.

628
00:30:35,930 --> 00:30:39,160
>> Je me suis alors frappé bouclés ouverte
brace, appuyez sur Entrée à nouveau.

629
00:30:39,160 --> 00:30:40,430
Et il a fini ma pensée.

630
00:30:40,430 --> 00:30:45,140
Il m'a donné une nouvelle ligne, en retrait pas moins
pour de belles raisons stylistiques que nous allons voir.

631
00:30:45,140 --> 00:30:48,559
Et puis il m'a donné automatiquement
qui accolade pour terminer ma pensée.

632
00:30:48,559 --> 00:30:50,600
Or, il n'a pas toujours
devinez ce que vous voulez faire.

633
00:30:50,600 --> 00:30:53,620
Mais en grande partie, il ne
vous faire économiser quelques frappes.

634
00:30:53,620 --> 00:30:59,560
Donc, il y a un instant, nous avons couru cette program--
bonjour, monde, puis compilé,

635
00:30:59,560 --> 00:31:00,460
puis il a couru.

636
00:31:00,460 --> 00:31:01,867
Mais il n'y a pas de dynamisme ici.

637
00:31:01,867 --> 00:31:03,700
Que faire si nous voulions
faire quelque chose de différent?

638
00:31:03,700 --> 00:31:07,630
Eh bien, si je voulais réellement
obtenir une chaîne de l'utilisateur?

639
00:31:07,630 --> 00:31:11,250
Je vais utiliser un morceau de puzzle
appelé exactement that-- obtenir chaîne.

640
00:31:11,250 --> 00:31:15,860
>> Active en C que lorsque vous ne voulez pas
de contribuer à une pièce de puzzle,

641
00:31:15,860 --> 00:31:19,360
ou plus exactement à une fonction, vous
littéralement juste faire parenthèse ouverte,

642
00:31:19,360 --> 00:31:20,430
étroite entre parenthèses.

643
00:31:20,430 --> 00:31:25,540
Donc, il est comme si il y a
aucune boîte blanche à taper dans.

644
00:31:25,540 --> 00:31:27,720
Le bloc de dire avant
avait une petite boîte blanche.

645
00:31:27,720 --> 00:31:29,660
Nous ne disposons pas que la boîte blanche maintenant.

646
00:31:29,660 --> 00:31:33,310
>> Mais quand je l'appelle chaîne get, je
vouloir mettre le résultat quelque part.

647
00:31:33,310 --> 00:31:37,680
Donc, un paradigme très répandu dans C est de
appeler une fonction, comme la chaîne get ici,

648
00:31:37,680 --> 00:31:41,070
puis stocker sa valeur de retour.

649
00:31:41,070 --> 00:31:44,450
Il est le résultat de son
effort dans quelque chose.

650
00:31:44,450 --> 00:31:47,630
>> Et quelle est la
construire dans la programmation,

651
00:31:47,630 --> 00:31:53,450
que ce soit dans Scratch ou maintenant C, que nous
peut utiliser pour réellement stocker quelque chose?

652
00:31:53,450 --> 00:31:55,990
Appelé il une variable, à droite?

653
00:31:55,990 --> 00:32:00,320
Et dans Scratch, nous ne sommes pas vraiment
soin ce qui se passait dans les variables.

654
00:32:00,320 --> 00:32:02,170
>> Mais dans ce cas, nous faisons réellement.

655
00:32:02,170 --> 00:32:03,719
Je vais dire chaîne.

656
00:32:03,719 --> 00:32:05,510
Et puis je pourrais appeler
ce que je veux.

657
00:32:05,510 --> 00:32:08,340
Je vais l'appeler
nom, obtient obtenir chaîne.

658
00:32:08,340 --> 00:32:10,250
>> Et maintenant, même si vous êtes
un peu de nouveau à cela,

659
00:32:10,250 --> 00:32:11,984
remarque que je manque quelques détails.

660
00:32:11,984 --> 00:32:13,150
J'oublie un point-virgule.

661
00:32:13,150 --> 00:32:14,400
Je dois terminer cette pensée.

662
00:32:14,400 --> 00:32:17,480
Donc, je vais passer mon curseur,
et appuyez sur point-virgule là.

663
00:32:17,480 --> 00:32:19,130
Et qu'est-ce que je viens de faire?

664
00:32:19,130 --> 00:32:21,440
Dans cette ligne de code,
numéro 5 à l'heure actuelle,

665
00:32:21,440 --> 00:32:23,799
Je vous appelle chaîne get sans entrées.

666
00:32:23,799 --> 00:32:26,090
Donc, il n'y a pas peu de blanc
boîte comme le bloc Save a.

667
00:32:26,090 --> 00:32:28,590
>> Je dis simplement que, hé,
ordinateur, get me une chaîne.

668
00:32:28,590 --> 00:32:31,390
Le signe égal est pas vraiment
un signe égal, en soi.

669
00:32:31,390 --> 00:32:33,790
Il est l'affectation
opérateur, ce qui signifie,

670
00:32:33,790 --> 00:32:37,860
hey, ordinateur, déplacer la valeur
de la droite vers la gauche.

671
00:32:37,860 --> 00:32:40,480
Et dans la gauche, je dois le suivant.

672
00:32:40,480 --> 00:32:43,580
>> Hey, ordinateur, donne-moi un string--
une séquence de caractères.

673
00:32:43,580 --> 00:32:45,637
Et appeler cette chaîne Nom.

674
00:32:45,637 --> 00:32:47,220
Et je ne même pas l'appeler Nom.

675
00:32:47,220 --> 00:32:49,970
>> Je pourrais l'appeler, de façon classique,
quelque chose comme S,

676
00:32:49,970 --> 00:32:52,900
un peu comme nous l'habitude d'i
appeler la variable i.

677
00:32:52,900 --> 00:32:54,829
Mais maintenant, je dois faire quelque chose avec elle.

678
00:32:54,829 --> 00:32:57,370
Il serait assez stupide pour
essayez de compiler ce code, en cours d'exécution

679
00:32:57,370 --> 00:32:59,410
ce programme, même si
Je reçois une chaîne,

680
00:32:59,410 --> 00:33:01,580
car il est encore juste
va dire bonjour monde.

681
00:33:01,580 --> 00:33:06,140
>> Mais si je ne veux changer cela.

682
00:33:06,140 --> 00:33:07,940
Pourquoi dois-je faire ce pas?

683
00:33:07,940 --> 00:33:11,632
Pour cent s, comma s.

684
00:33:11,632 --> 00:33:13,090
Et cela est un peu cryptique encore.

685
00:33:13,090 --> 00:33:15,560
>> Alors permettez-moi de faire mes variables plus clair.

686
00:33:15,560 --> 00:33:17,510
Permettez-moi de nommer ce nom variable.

687
00:33:17,510 --> 00:33:20,230
Et nous allons voir si nous ne pouvons pas taquiner
à part ce qui se passe ici.

688
00:33:20,230 --> 00:33:22,770
>> Donc, sur la ligne de cinq, je reçois une chaîne.

689
00:33:22,770 --> 00:33:25,620
Et je stocker cette chaîne,
quel que soit l'utilisateur a tapé dans

690
00:33:25,620 --> 00:33:28,430
à son clavier,
dans une variable appelée Nom.

691
00:33:28,430 --> 00:33:30,590
Et il se trouve que
printf n'a pas seulement

692
00:33:30,590 --> 00:33:34,220
prendre un argument dans le double
citations, une entrée entre guillemets.

693
00:33:34,220 --> 00:33:39,100
>> Elle peut prendre deux ou trois, ou plus, par exemple
que la seconde, troisième ou quatrième,

694
00:33:39,100 --> 00:33:42,320
sont tous les noms de variables,
ou des valeurs spécifiquement,

695
00:33:42,320 --> 00:33:48,610
que vous souhaitez brancher,
dynamique, cette chaîne entre guillemets.

696
00:33:48,610 --> 00:33:52,110
En d'autres termes, ce qui
serait mal à cela?

697
00:33:52,110 --> 00:33:57,920
Si je viens de dire bonjour nom, backslash
n, a sauvé mon dossier, compilé mon code,

698
00:33:57,920 --> 00:34:01,660
et a couru cela, ce qui se passerait?

699
00:34:01,660 --> 00:34:05,139
>> Il va juste dire bonjour
nom, littéralement N-A-M-E,

700
00:34:05,139 --> 00:34:07,900
qui est une sorte de stupide parce que
il est pas différent de monde.

701
00:34:07,900 --> 00:34:10,400
Donc, quoi que ce soit entre guillemets est
ce qui littéralement est imprimé.

702
00:34:10,400 --> 00:34:12,520
Donc, si je veux avoir
un espace réservé là-bas,

703
00:34:12,520 --> 00:34:14,422
En fait, je dois utiliser
une syntaxe spéciale.

704
00:34:14,422 --> 00:34:17,380
Et il se trouve si vous lisez le
documentation de la fonction printf,

705
00:34:17,380 --> 00:34:21,320
il vous dira que
si vous utilisez pour cent s,

706
00:34:21,320 --> 00:34:23,920
vous pouvez substituer une valeur comme suit.

707
00:34:23,920 --> 00:34:27,190
>> Après une virgule après cela
guillemet double, il vous suffit

708
00:34:27,190 --> 00:34:29,179
écrire le nom de la
variable que vous voulez

709
00:34:29,179 --> 00:34:33,790
brancher dans ce format
code, ou spécificateur de format,

710
00:34:33,790 --> 00:34:35,469
pour cent s pour les chaînes.

711
00:34:35,469 --> 00:34:39,190
Et maintenant, si je l'ai sauvé mon dossier,
Je redescends à mon terminal.

712
00:34:39,190 --> 00:34:42,870
Et je tape Faire String,
parce que, encore une fois, le nom de cette

713
00:34:42,870 --> 00:34:45,510
fichier que j'ai choisi avant est string.c.

714
00:34:45,510 --> 00:34:48,510
>> Donc, je vais dire Faire chaîne, entrez.

715
00:34:48,510 --> 00:34:51,550
Oh mon Dieu, regardez tous
les erreurs que nous avons déjà fait.

716
00:34:51,550 --> 00:34:55,540
Et ce est-- quoi, ce qui est vraiment
comme un, sept programme de ligne de six?

717
00:34:55,540 --> 00:34:57,790
Donc, ceci est où il peut très
obtenir rapidement écrasante.

718
00:34:57,790 --> 00:35:00,890
>> Cette fenêtre de terminal a
maintenant juste régurgité

719
00:35:00,890 --> 00:35:03,230
un grand nombre de messages d'erreur.

720
00:35:03,230 --> 00:35:07,560
Certes, je n'ai pas plus d'erreur
messages que j'ai lignes de code.

721
00:35:07,560 --> 00:35:08,680
Alors, quoi de neuf?

722
00:35:08,680 --> 00:35:10,920
>> Eh bien, la meilleure stratégie
à faire quand vous

723
00:35:10,920 --> 00:35:13,710
ne rencontrent une écrasante
liste des erreurs comme ça,

724
00:35:13,710 --> 00:35:16,690
est revenir en arrière, recherchez la commande
vous venez de courir, qui dans mon cas

725
00:35:16,690 --> 00:35:18,020
est de faire la chaîne.

726
00:35:18,020 --> 00:35:21,630
Regardez ce make a fait, et que ce que
commande longue Clang, pas grand-chose là-bas.

727
00:35:21,630 --> 00:35:22,950
>> Mais le rouge est mauvais.

728
00:35:22,950 --> 00:35:24,750
Vert essaie d'être
douce et serviable.

729
00:35:24,750 --> 00:35:26,140
Mais il est encore mauvais, dans ce cas.

730
00:35:26,140 --> 00:35:27,510
Mais où est-il mauvais?

731
00:35:27,510 --> 00:35:31,450
>> String.c, ligne de cinq, cinq caractères.

732
00:35:31,450 --> 00:35:32,930
Donc, ceci est juste convention commune.

733
00:35:32,930 --> 00:35:36,060
Quelque chose signifie quelque chose du côlon
numéro de ligne et le nombre de caractères.

734
00:35:36,060 --> 00:35:41,080
Erreur, l'utilisation du noir
chaîne d'identification.

735
00:35:41,080 --> 00:35:42,900
Vouliez-vous dire standard?

736
00:35:42,900 --> 00:35:45,530
>> Donc, malheureusement, Clang
est d'essayer d'être utile.

737
00:35:45,530 --> 00:35:46,850
Mais il ne va pas, dans ce cas.

738
00:35:46,850 --> 00:35:49,350
Non, Clang, je ne voulais pas la norme IO.

739
00:35:49,350 --> 00:35:51,070
Je voulais dire que sur une seule ligne, oui.

740
00:35:51,070 --> 00:35:53,420
>> Mais la ligne de cinq ans est celui-là.

741
00:35:53,420 --> 00:35:57,040
Et ne Clang
comprendre S-T-R-I-N-G.

742
00:35:57,040 --> 00:36:01,490
Il est un identificateur non déclaré, un
mot, il a tout simplement jamais vu auparavant.

743
00:36:01,490 --> 00:36:05,730
Et c'est parce que C, la langue
nous écrivons le code dans ce moment,

744
00:36:05,730 --> 00:36:08,070
n'a pas variables appelées chaînes.

745
00:36:08,070 --> 00:36:11,380
>> Il ne fait pas, par défaut, le support
ce qu'on appelle une chaîne.

746
00:36:11,380 --> 00:36:16,750
C'est un morceau de la CS50
jargon, mais très classique.

747
00:36:16,750 --> 00:36:18,600
Mais je peux résoudre ce problème de la manière suivante.

748
00:36:18,600 --> 00:36:22,090
>> Si j'ajouter une ligne de code
au début de ce programme,

749
00:36:22,090 --> 00:36:27,890
inclure CS50.h, qui est un autre fichier
quelque part à l'intérieur du CS50 IDE, quelque part

750
00:36:27,890 --> 00:36:30,820
sur le disque dur, pour ainsi dire,
du système d'exploitation Ubuntu

751
00:36:30,820 --> 00:36:33,590
que je suis en cours d'exécution, que
est le fichier qui est

752
00:36:33,590 --> 00:36:38,740
va enseigner l'exploitation
système quelle chaîne est, juste

753
00:36:38,740 --> 00:36:41,930
comme io.h standard est le fichier
dans le système d'exploitation qui est

754
00:36:41,930 --> 00:36:44,430
va enseigner ce que printf est.

755
00:36:44,430 --> 00:36:46,810
>> En effet, nous aurions obtenu
un message très similaire

756
00:36:46,810 --> 00:36:50,600
si IO avait admis la norme
Io.h et a essayé d'utiliser printf.

757
00:36:50,600 --> 00:36:53,632
Je vais donc aller de l'avant et juste
Prenez le contrôle L pour effacer mon écran.

758
00:36:53,632 --> 00:36:56,340
Ou vous pouvez taper clair et il sera
décochez simplement la fenêtre du terminal.

759
00:36:56,340 --> 00:36:58,020
Mais vous pouvez toujours revenir en arrière dans le temps.

760
00:36:58,020 --> 00:37:01,100
>> Et je vais relancer Faire String.

761
00:37:01,100 --> 00:37:03,660
Traversez mes doigts cette fois, Entrée.

762
00:37:03,660 --> 00:37:05,380
Oh mon Dieu, il a travaillé.

763
00:37:05,380 --> 00:37:09,280
il me montre une longue commande cryptique
qui est ce qui fait généré par Clang,

764
00:37:09,280 --> 00:37:10,460
mais aucun message d'erreur.

765
00:37:10,460 --> 00:37:12,460
Donc réaliser, même si
vous pourriez obtenir complètement

766
00:37:12,460 --> 00:37:14,480
dépassés par la
nombre de messages d'erreur,

767
00:37:14,480 --> 00:37:17,540
ça pourrait être cette cascade ennuyeux
effet, où Clang ne comprend pas

768
00:37:17,540 --> 00:37:19,620
une chose, ce qui signifie alors
ne comprend pas le mot suivant,

769
00:37:19,620 --> 00:37:20,560
ou la ligne suivante.

770
00:37:20,560 --> 00:37:22,850
Et il étouffe tout simplement sur votre code.

771
00:37:22,850 --> 00:37:24,440
Mais la solution pourrait être simple.

772
00:37:24,440 --> 00:37:27,822
Et toujours se concentrer sur la
première ligne de sortie.

773
00:37:27,822 --> 00:37:29,530
Et si vous ne le faites pas
comprendre, il suffit de regarder

774
00:37:29,530 --> 00:37:32,480
pour les mots clés qui pourraient être
indices, et le numéro de ligne,

775
00:37:32,480 --> 00:37:34,650
et le personnage, où
cette erreur pourrait être.

776
00:37:34,650 --> 00:37:40,328
>> Maintenant, laissez-moi aller de l'avant et tapez
dot slash, string, entrez.

777
00:37:40,328 --> 00:37:44,340
Hm, il ne dit pas bonjour quoi que ce soit.

778
00:37:44,340 --> 00:37:46,210
Pourquoi?

779
00:37:46,210 --> 00:37:48,170
Eh bien, rappelons-le, où est-il en cours d'exécution?

780
00:37:48,170 --> 00:37:53,730
>> Il est probablement coincé au moment
dans une boucle, si vous voulez, en ligne six,

781
00:37:53,730 --> 00:37:56,950
parce Obtenez chaîne par la conception,
écrite par le personnel CS50,

782
00:37:56,950 --> 00:38:00,350
est littéralement destiné à rester assis
là à attendre, et attendre,

783
00:38:00,350 --> 00:38:01,850
et en attente d'une chaîne.

784
00:38:01,850 --> 00:38:03,792
Tout ce que nous entendons par chaîne est entrée humaine.

785
00:38:03,792 --> 00:38:04,500
Donc, vous savez quoi?

786
00:38:04,500 --> 00:38:05,166
Laissez-moi aller de l'avant.

787
00:38:05,166 --> 00:38:08,704
Et sur un coup de tête, laissez-moi
tapez mon nom, David, entrez.

788
00:38:08,704 --> 00:38:10,120
Maintenant, j'ai un programme plus dynamique.

789
00:38:10,120 --> 00:38:11,240
Il dit bonjour David.

790
00:38:11,240 --> 00:38:16,280
>> Si je vais de l'avant et lance ce nouveau,
laissez-moi essayer dire le nom Zamila, entrez.

791
00:38:16,280 --> 00:38:17,940
Et maintenant, nous avons un programme dynamique.

792
00:38:17,940 --> 00:38:19,380
Je ne l'ai pas codé en dur monde.

793
00:38:19,380 --> 00:38:21,760
Je ne l'ai pas codé en dur
nom, ou David ou Zamila.

794
00:38:21,760 --> 00:38:25,350
>> Maintenant, il est beaucoup plus comme les programmes
nous le savons, où si elle prend entrée,

795
00:38:25,350 --> 00:38:27,870
il produit une sortie légèrement différente.

796
00:38:27,870 --> 00:38:31,020
Or, ce ne sont pas les meilleurs
expérience utilisateur ou UX.

797
00:38:31,020 --> 00:38:33,000
Je lance le programme.

798
00:38:33,000 --> 00:38:35,830
>> Je ne sais pas ce que je suis censé
à faire, à moins que je regarde effectivement à

799
00:38:35,830 --> 00:38:37,290
ou de se rappeler le code source.

800
00:38:37,290 --> 00:38:39,640
Faisons donc l'utilisateur
l'expérience d'un peu mieux

801
00:38:39,640 --> 00:38:41,240
avec le plus simple des choses.

802
00:38:41,240 --> 00:38:44,782
Permettez-moi de revenir dans cette
programme, et simplement dire printf.

803
00:38:44,782 --> 00:38:48,870
>> Et laissez-moi aller de l'avant et de dire le nom, du côlon,
et un espace, puis un point-virgule.

804
00:38:48,870 --> 00:38:51,170
Et juste pour le plaisir, pas de jeu n.

805
00:38:51,170 --> 00:38:52,980
Et c'est délibéré,
parce que je ne veux pas

806
00:38:52,980 --> 00:38:54,590
l'invite à passer à la ligne suivante.

807
00:38:54,590 --> 00:38:58,800
>> Je veux, à la place, faire, faire chaîne
recompiler mon code en nouvelle machine

808
00:38:58,800 --> 00:39:00,980
Code dot slash chaîne.

809
00:39:00,980 --> 00:39:02,460
Ah, ce qui est beaucoup plus jolie.

810
00:39:02,460 --> 00:39:05,780
Maintenant, je sais réellement ce que l'ordinateur
veut que je fasse, lui donner un nom.

811
00:39:05,780 --> 00:39:10,020
>> Je vais donc aller de l'avant et tapez
à Rob, entrez, et bonjour, Rob.

812
00:39:10,020 --> 00:39:13,640
Donc, se rendre compte, cela est encore, à la fin
de la journée, seulement un programme neuf de ligne.

813
00:39:13,640 --> 00:39:15,090
Mais nous avons pris ces mesures de bébé.

814
00:39:15,090 --> 00:39:18,380
>> Nous avons écrit une ligne avec laquelle nous
étaient familiers, printf, bonjour monde.

815
00:39:18,380 --> 00:39:19,980
Ensuite, nous défaisions un peu de cela.

816
00:39:19,980 --> 00:39:21,560
Et nous avons utilisé la chaîne get.

817
00:39:21,560 --> 00:39:23,362
Et nous tournions cette valeur dans une variable.

818
00:39:23,362 --> 00:39:26,070
Et puis nous sommes allés de l'avant et amélioré
davantage avec une troisième ligne.

819
00:39:26,070 --> 00:39:29,220
Et ce processus itératif de
logiciel d'écriture est vraiment la clé.

820
00:39:29,220 --> 00:39:33,420
En CS50, et dans la vie en général,
vous devriez généralement pas asseoir,

821
00:39:33,420 --> 00:39:36,800
avoir un programme à l'esprit, et essayer l'écriture
toute fichue chose à la fois.

822
00:39:36,800 --> 00:39:40,810
>> Il sera, inévitablement, entraîner de manière
plus d'erreurs que nous nous avons vu ici.

823
00:39:40,810 --> 00:39:44,070
Même moi, à ce jour, en permanence
faire d'autres erreurs stupides,

824
00:39:44,070 --> 00:39:47,480
sont des erreurs effectivement plus difficile
qui sont plus difficiles à comprendre.

825
00:39:47,480 --> 00:39:52,095
Mais vous allez faire plus d'erreurs plus
lignes de code que vous écrivez tout à la fois.

826
00:39:52,095 --> 00:39:54,220
Et cette pratique,
écrire un petit morceau de code

827
00:39:54,220 --> 00:39:57,930
que vous êtes à l'aise avec, compilez
elle, exécuter, tester de façon plus générale,

828
00:39:57,930 --> 00:40:01,370
puis passer on-- donc tout comme nous avons gardé
marcottage et marcottage la semaine dernière,

829
00:40:01,370 --> 00:40:04,190
la construction de quelque chose de très
simple à quelque chose de plus complexe,

830
00:40:04,190 --> 00:40:05,200
faire la même chose ici.

831
00:40:05,200 --> 00:40:08,500
Ne vous asseyez pas, et essayer de
écrire tout un problème.

832
00:40:08,500 --> 00:40:10,780
En fait, prendre ces mesures de bébé.

833
00:40:10,780 --> 00:40:15,100
>> Maintenant, les chaînes ne sont pas tous
qui utiles à eux-mêmes.

834
00:40:15,100 --> 00:40:18,210
Nous avions en fait, idéalement, comme à
quelque chose d'autre dans notre boîte à outils.

835
00:40:18,210 --> 00:40:20,990
Donc, nous allons effectivement faire exactement cela.

836
00:40:20,990 --> 00:40:24,900
>> Laissez-moi aller de l'avant maintenant et fouetter
un programme légèrement différent.

837
00:40:24,900 --> 00:40:28,320
Et nous appelons cela int.c, pour entier.

838
00:40:28,320 --> 00:40:30,870
Je vais, de même,
inclure CS550.h.

839
00:40:30,870 --> 00:40:33,060
Je vais inclure la norme IO.

840
00:40:33,060 --> 00:40:36,630
Et cela va être assez commun
dans ces premiers jours de la classe.

841
00:40:36,630 --> 00:40:39,050
>> Et je vais prêt
moi-même avec une fonction principale.

842
00:40:39,050 --> 00:40:43,370
Et maintenant, au lieu d'obtenir une chaîne,
nous allons aller de l'avant et obtenir un int.

843
00:40:43,370 --> 00:40:49,285
Appelons-i, et appellent obtenir
int, proches parens, point-virgule.

844
00:40:49,285 --> 00:40:51,410
Et maintenant, nous allons faire
quelque chose avec elle, printf.

845
00:40:51,410 --> 00:40:56,190
>> Disons que quelque chose comme
bonjour, backslash n, i virgule.

846
00:40:56,190 --> 00:41:00,010
Donc, je suis à peu près imitant
ce que je faisais il y a un instant.

847
00:41:00,010 --> 00:41:01,660
J'ai un espace réservé ici.

848
00:41:01,660 --> 00:41:05,150
Je Comma i ici, parce que je veux
i brancher dans cette espace réservé.

849
00:41:05,150 --> 00:41:07,250
>> Donc, nous allons aller de l'avant et essayer
la compilation de ce programme.

850
00:41:07,250 --> 00:41:10,060
Le fichier est appelé int.c.

851
00:41:10,060 --> 00:41:12,920
Donc, je vais dire, faire int, entrez.

852
00:41:12,920 --> 00:41:16,420
Oh mon Dieu, mais pas grand-chose, non?

853
00:41:16,420 --> 00:41:17,230
Il y a une erreur.

854
00:41:17,230 --> 00:41:19,810
>> Il y a une erreur syntaxique
ici, tels que le programme ne peut pas

855
00:41:19,810 --> 00:41:25,460
être compilé intérieur int.c, ligne
sept ans, caractère 27, le format d'erreur

856
00:41:25,460 --> 00:41:28,400
spécifie type char
étoiles, quelle qu'elle soit.

857
00:41:28,400 --> 00:41:30,020
Mais le type d'argument est int.

858
00:41:30,020 --> 00:41:33,110
>> Donc, là aussi, on ne va pas to--
même si aujourd'hui est un lot de matériel,

859
00:41:33,110 --> 00:41:35,710
nous allons vous submerger avec
absolument toutes les fonctionnalités de C,

860
00:41:35,710 --> 00:41:38,070
et la programmation de façon plus générale,
en seulement ces quelques premières semaines.

861
00:41:38,070 --> 00:41:40,400
Donc, il y a souvent va être le jargon
avec lequel vous n'êtes pas familier.

862
00:41:40,400 --> 00:41:43,350
Et, en fait, char étoiles est quelque chose
nous allons revenir à

863
00:41:43,350 --> 00:41:44,830
dans une semaine ou le temps de deux.

864
00:41:44,830 --> 00:41:47,530
>> Mais pour l'instant, nous allons voir si nous pouvons
analyser les mots qui sont familiers.

865
00:41:47,530 --> 00:41:50,750
Formats-- donc nous avons entendu le format
spécificateur, le code de format avant.

866
00:41:50,750 --> 00:41:51,840
C'est familier.

867
00:41:51,840 --> 00:41:53,840
Bien-- mais l'argument est de type int.

868
00:41:53,840 --> 00:41:55,980
Attendez une minute, i est un int.

869
00:41:55,980 --> 00:41:59,230
>> Peut-être pour cent s en fait
a un sens défini.

870
00:41:59,230 --> 00:42:00,230
Et, en effet, il le fait.

871
00:42:00,230 --> 00:42:03,101
Un entier, si vous voulez
printf de lui substituer,

872
00:42:03,101 --> 00:42:05,350
vous avez réellement à utiliser un
différente spécificateur de format.

873
00:42:05,350 --> 00:42:06,890
Et vous ne seriez pas le savoir
à moins que quelqu'un vous a dit,

874
00:42:06,890 --> 00:42:07,973
ou si vous l'aviez fait auparavant.

875
00:42:07,973 --> 00:42:10,490
Mais pour cent i est ce que
peut être utilisée par

876
00:42:10,490 --> 00:42:12,240
dans printf pour brancher un entier.

877
00:42:12,240 --> 00:42:14,920
Vous pouvez également utiliser pour cent
d un entier décimal.

878
00:42:14,920 --> 00:42:16,490
Mais i est agréable et simple ici.

879
00:42:16,490 --> 00:42:17,590
Nous allons donc avec cela.

880
00:42:17,590 --> 00:42:21,160
>> Maintenant, laissez-moi aller de l'avant et
relancez make int, Entrée.

881
00:42:21,160 --> 00:42:23,328
C'est bon, pas d'erreurs.

882
00:42:23,328 --> 00:42:27,260
Dot slash OK int--, mauvaise expérience de l'utilisateur,
parce que je ne me suis pas dit

883
00:42:27,260 --> 00:42:27,760
Que faire.

884
00:42:27,760 --> 00:42:28,426
Mais ça va.

885
00:42:28,426 --> 00:42:29,480
J'attraper rapidement.

886
00:42:29,480 --> 00:42:36,260
>> Et maintenant, laissez-moi aller de l'avant et
tapez David, OK, Zamila, Rob.

887
00:42:36,260 --> 00:42:37,820
OK, donc ceci est une bonne chose.

888
00:42:37,820 --> 00:42:41,710
Cette fois, je suis en utilisant une fonction,
un morceau de puzzle, appelé get int.

889
00:42:41,710 --> 00:42:44,230
Et il se out-- et nous
voir plus tard dans le term--

890
00:42:44,230 --> 00:42:47,730
le personnel de CS50 a mis en œuvre
obtenir la chaîne de telle manière

891
00:42:47,730 --> 00:42:50,350
que ce sera seulement physiquement
obtenir une chaîne pour vous.

892
00:42:50,350 --> 00:42:54,340
>> Il a mis en œuvre get int dans
de telle sorte qu'il ne sera que

893
00:42:54,340 --> 00:42:55,590
obtenir un nombre entier pour vous.

894
00:42:55,590 --> 00:42:57,830
Et si vous, l'humain,
ne coopèrent pas, il est

895
00:42:57,830 --> 00:43:00,590
littéralement juste aller
dire relancez, relancez, relancez,

896
00:43:00,590 --> 00:43:05,200
littéralement assis là en boucle, jusqu'à ce que
vous obligez avec un certain nombre magique,

897
00:43:05,200 --> 00:43:07,670
comme 50, et bonjour 50.

898
00:43:07,670 --> 00:43:11,440
>> Ou si nous courons ce nouveau
et tapez 42, bonjour 42.

899
00:43:11,440 --> 00:43:15,750
Et donc la fonction get int
à l'intérieur de cette pièce de puzzle

900
00:43:15,750 --> 00:43:19,050
est assez logique, assez pensée,
de comprendre, ce qui est un mot?

901
00:43:19,050 --> 00:43:20,330
Et qu'est-ce qu'un nombre?

902
00:43:20,330 --> 00:43:23,165
accepter seulement, en fin de compte, numéros.

903
00:43:23,165 --> 00:43:25,690

904
00:43:25,690 --> 00:43:30,230
>> Donc, il se trouve que ce
est pas tout à fait expressif.

905
00:43:30,230 --> 00:43:30,910
jusque là.

906
00:43:30,910 --> 00:43:33,690
Donc, yay, nous la dernière fois
est allé assez rapidement

907
00:43:33,690 --> 00:43:38,320
dans les jeux de mise en œuvre et l'animation,
et des œuvres artistiques dans Scratch.

908
00:43:38,320 --> 00:43:42,260
Et ici, nous faisons preuve de contenu
avec Bonjour tout le monde, et bonjour 50.

909
00:43:42,260 --> 00:43:43,696
>> Il est pas tout à fait inspirant.

910
00:43:43,696 --> 00:43:46,070
Et, en effet, ces quelques premiers
exemples prendra un certain temps

911
00:43:46,070 --> 00:43:47,510
à la rampe dans l'excitation.

912
00:43:47,510 --> 00:43:49,854
Mais nous avons tellement plus
contrôler maintenant, en fait.

913
00:43:49,854 --> 00:43:51,770
Et nous allons très
commencer rapidement marcottage

914
00:43:51,770 --> 00:43:53,870
au-dessus de ces primitives de base.

915
00:43:53,870 --> 00:43:56,370
>> Mais d'abord, nous allons comprendre
quelles sont les limites.

916
00:43:56,370 --> 00:43:58,620
En fait, l'une des choses
Scratch ne facilement

917
00:43:58,620 --> 00:44:00,990
laissez-nous faire est vraiment regarder
sous le capot,

918
00:44:00,990 --> 00:44:03,740
et comprendre ce qu'est un
ordinateur est, ce qu'il peut faire,

919
00:44:03,740 --> 00:44:05,250
et quelles sont ses limites.

920
00:44:05,250 --> 00:44:08,580
Et, en effet, que le manque de
compréhension, potentiellement, à long terme

921
00:44:08,580 --> 00:44:12,520
peut conduire à notre propre écriture mistakes--
bogues, l'écriture des logiciels que l'insécurité

922
00:44:12,520 --> 00:44:13,880
est piraté en quelque sorte.

923
00:44:13,880 --> 00:44:17,130
>> Prenons donc quelques pas vers
comprendre cela un peu mieux par

924
00:44:17,130 --> 00:44:19,710
manière de, disons, l'exemple suivant.

925
00:44:19,710 --> 00:44:23,550
Je vais aller de l'avant et mettre en œuvre
réel rapide d'un programme appelé Adder.

926
00:44:23,550 --> 00:44:25,134
Comme, nous allons ajouter quelques chiffres ensemble.

927
00:44:25,134 --> 00:44:27,800
Et je vais coder certains coins
ici, et il suffit de copier et coller

928
00:44:27,800 --> 00:44:30,270
où je me trouvais avant, juste
afin que nous puissions aller plus vite.

929
00:44:30,270 --> 00:44:33,090
Alors maintenant, j'ai les débuts de base
d'un programme appelé Adder.

930
00:44:33,090 --> 00:44:34,670
>> Et nous allons aller de l'avant et à faire cela.

931
00:44:34,670 --> 00:44:38,680
Je vais aller de l'avant et
disons, INTX obtient obtenir int.

932
00:44:38,680 --> 00:44:39,430
Et tu sais quoi?

933
00:44:39,430 --> 00:44:40,990
Faisons une meilleure expérience utilisateur.

934
00:44:40,990 --> 00:44:45,740
>> Donc, disons simplement que x est, et efficacement
invite l'utilisateur à nous donner x.

935
00:44:45,740 --> 00:44:50,600
Et puis laissez-moi aller de l'avant et de dire, printf
que diriez-vous y est, cette fois-ci attend

936
00:44:50,600 --> 00:44:53,140
deux valeurs de l'utilisateur.

937
00:44:53,140 --> 00:44:59,759
Et puis nous allons simplement aller de l'avant et
disons, printf, la somme de x et y est.

938
00:44:59,759 --> 00:45:01,300
Et maintenant, je ne veux pas faire pour cent s.

939
00:45:01,300 --> 00:45:09,080
Je veux faire pour cent i, backslash
n, puis brancher valeur de somme.

940
00:45:09,080 --> 00:45:10,620
>> Alors, comment puis-je m'y prendre?

941
00:45:10,620 --> 00:45:11,270
Vous savez quoi?

942
00:45:11,270 --> 00:45:12,840
Je sais comment utiliser les variables.

943
00:45:12,840 --> 00:45:15,140
Permettez-moi de déclarer une nouvelle, int z.

944
00:45:15,140 --> 00:45:16,770
>> Et je vais faire une supposition ici.

945
00:45:16,770 --> 00:45:21,470
S'il y a des signes égaux dans ce
la langue, peut-être que je peux juste faire x plus y,

946
00:45:21,470 --> 00:45:23,660
tant que je termine mon
pensée avec un point-virgule?

947
00:45:23,660 --> 00:45:28,170
Maintenant, je peux revenir ici, branchez z,
terminer cette pensée avec un point-virgule.

948
00:45:28,170 --> 00:45:33,160
Et nous allons voir maintenant, si ceux-ci
séquences de lines-- x est obtenir int.

949
00:45:33,160 --> 00:45:34,770
Y est d'obtenir int.

950
00:45:34,770 --> 00:45:37,980
>> Ajouter x et y, stocker la valeur dans Z-
donc, encore une fois, rappelez-vous le signe égal

951
00:45:37,980 --> 00:45:38,560
est pas égale.

952
00:45:38,560 --> 00:45:41,100
Il est l'affectation de droite à gauche.

953
00:45:41,100 --> 00:45:45,180
Et nous allons imprimer que la somme
de x et y est pas littéralement z,

954
00:45:45,180 --> 00:45:46,830
mais ce qui est à l'intérieur de z.

955
00:45:46,830 --> 00:45:50,090
Faisons donc Adder -
nice, aucune erreur cette fois.

956
00:45:50,090 --> 00:45:53,030
Dot slash Adder, entrez,
x va être 1.

957
00:45:53,030 --> 00:45:55,380
>> Y va être 2.

958
00:45:55,380 --> 00:45:58,964
Et la somme de x et y est 3.

959
00:45:58,964 --> 00:46:00,130
Donc, c'est tout beau et bon.

960
00:46:00,130 --> 00:46:03,260
>> Donc, vous imaginez que les mathématiques
devraient travailler dans un tel programme.

961
00:46:03,260 --> 00:46:04,040
Mais tu sais quoi?

962
00:46:04,040 --> 00:46:06,904
Est-ce variable ligne
12, voire nécessaire?

963
00:46:06,904 --> 00:46:09,820
Vous ne devez pas prendre l'habitude
de simplement stocker des choses dans les variables

964
00:46:09,820 --> 00:46:10,980
juste parce que vous pouvez.

965
00:46:10,980 --> 00:46:13,550
Et, en fait, il est généralement
mauvaise conception réfléchie

966
00:46:13,550 --> 00:46:18,100
si vous créez une variable, appelée
z dans ce cas, le stockage en elle quelque chose,

967
00:46:18,100 --> 00:46:21,390
puis immédiatement
l'utiliser, mais jamais plus.

968
00:46:21,390 --> 00:46:24,700
Pourquoi donner quelque chose d'un nom
comme z si vous êtes littéralement

969
00:46:24,700 --> 00:46:26,770
va utiliser
chose qu'une seule fois, et ainsi

970
00:46:26,770 --> 00:46:29,380
proximale à l'endroit où vous avez créé
en premier lieu,

971
00:46:29,380 --> 00:46:31,052
si proche en termes de lignes de code?

972
00:46:31,052 --> 00:46:31,760
Donc, vous savez quoi?

973
00:46:31,760 --> 00:46:34,480
Il se trouve que C est assez flexible.

974
00:46:34,480 --> 00:46:36,586
Si je veux vraiment
plug-in ici les valeurs,

975
00:46:36,586 --> 00:46:38,210
Je ne ai pas besoin de déclarer une nouvelle variable.

976
00:46:38,210 --> 00:46:41,680
Je ne pouvais tout simplement plug-in x plus
y, parce que C comprend

977
00:46:41,680 --> 00:46:43,390
arithmétique et opérateurs mathématiques.

978
00:46:43,390 --> 00:46:47,140
>> Donc, je peux simplement dire, faire les mathématiques,
x plus y, quels que soient ces valeurs sont,

979
00:46:47,140 --> 00:46:50,780
branchez le résultat
entier dans cette chaîne.

980
00:46:50,780 --> 00:46:53,730
Donc, ce serait peut-être, bien que
une seule ligne plus courte,

981
00:46:53,730 --> 00:46:58,480
une meilleure conception, un meilleur programme,
parce qu'il ya moins de code, donc

982
00:46:58,480 --> 00:46:59,921
moins pour moi de comprendre.

983
00:46:59,921 --> 00:47:01,920
Et il est aussi tout simplement plus propre,
dans la mesure où nous ne sommes pas

984
00:47:01,920 --> 00:47:04,620
l'introduction de nouveaux mots,
de nouveaux symboles, comme z,

985
00:47:04,620 --> 00:47:07,510
même si elles ne sont pas vraiment
servira beaucoup d'un but.

986
00:47:07,510 --> 00:47:12,890
>> Malheureusement, les mathématiques ne sont pas
tout ce que parfois fiables.

987
00:47:12,890 --> 00:47:15,270
Allons de l'avant et faire cela.

988
00:47:15,270 --> 00:47:18,200
Je vais aller de l'avant
maintenant et faire ce qui suit.

989
00:47:18,200 --> 00:47:27,650
>> Faisons printf, pour cent i, plus pour cent
i, i serai pour cent, backslash n.

990
00:47:27,650 --> 00:47:32,240
Et je vais faire this-- xyx plus y.

991
00:47:32,240 --> 00:47:34,821
Donc, je vais juste réécrire
ce peu différemment ici.

992
00:47:34,821 --> 00:47:36,320
Permettez-moi de faire une vérification de la santé mentale rapide.

993
00:47:36,320 --> 00:47:37,986
Encore une fois, il ne faut pas prendre de l'avance de nous-mêmes.

994
00:47:37,986 --> 00:47:41,420
Faire additionneur, point barre oblique additionneur.

995
00:47:41,420 --> 00:47:44,950
x vaut 1, y vaut 2, 1 + 2 est égal à 3.

996
00:47:44,950 --> 00:47:45,870
Donc, ce qui est bon.

997
00:47:45,870 --> 00:47:49,060
Mais nous allons compliquer cela maintenant
un peu, et créer un nouveau fichier.

998
00:47:49,060 --> 00:47:53,350
>> Je vais appeler celui-ci,
dire, ints, pluriel pour les entiers.

999
00:47:53,350 --> 00:47:55,980
Permettez-moi de commencer où je me trouvais il y a un instant.

1000
00:47:55,980 --> 00:47:57,770
Mais maintenant, nous allons faire quelques autres lignes.

1001
00:47:57,770 --> 00:48:03,430
Laissez-moi aller de l'avant et de faire ce qui suit,
printf, pour cent i, moins pour cent i,

1002
00:48:03,430 --> 00:48:08,959
est pour cent i, virgule x, virgule yx moins y.

1003
00:48:08,959 --> 00:48:10,750
Je suis donc un peu faire
mathématiques différent là-bas.

1004
00:48:10,750 --> 00:48:11,624
Faisons un autre.

1005
00:48:11,624 --> 00:48:16,610
Donc, cent pour cent i fois
i est pour cent i, backslash n.

1006
00:48:16,610 --> 00:48:21,430
Voyons plug-in x et y, et x fois y.

1007
00:48:21,430 --> 00:48:24,530
Nous allons utiliser l'astérisque sur
votre ordinateur pour les temps.

1008
00:48:24,530 --> 00:48:26,390
>> Vous n'utilisez pas x. x est
un nom de variable ici.

1009
00:48:26,390 --> 00:48:28,270
Vous utilisez l'étoile pour la multiplication.

1010
00:48:28,270 --> 00:48:29,020
Faisons un de plus.

1011
00:48:29,020 --> 00:48:34,580
Printf pour cent I, divisée
en pour cent i, est pour cent i,

1012
00:48:34,580 --> 00:48:40,460
backslash n. xy divisé par Y-
de sorte que vous utilisez la barre oblique en C

1013
00:48:40,460 --> 00:48:41,502
de faire la division.

1014
00:48:41,502 --> 00:48:42,460
Et nous allons faire un autre.

1015
00:48:42,460 --> 00:48:47,920

1016
00:48:47,920 --> 00:48:55,240
Reste de pour cent i, divisé
en pour cent i, est pour cent i.

1017
00:48:55,240 --> 00:48:59,550
xy-- et maintenant reste
est ce qui reste.

1018
00:48:59,550 --> 00:49:02,980
Lorsque vous essayez diviser un
le dénominateur dans un numérateur,

1019
00:49:02,980 --> 00:49:05,570
combien il en reste plus que
vous ne pouviez pas diviser out?

1020
00:49:05,570 --> 00:49:07,910
>> Donc, il n'y a pas vraiment,
nécessairement, un symbole

1021
00:49:07,910 --> 00:49:09,470
nous avons utilisé à l'école primaire pour cela.

1022
00:49:09,470 --> 00:49:13,830
Mais il y en C. Vous pouvez
dire x modulo y, où

1023
00:49:13,830 --> 00:49:18,000
ce signe pour cent dans ce context--
prêter à confusion lorsque vous êtes à l'intérieur

1024
00:49:18,000 --> 00:49:20,170
des guillemets doubles,
intérieur de printf, pour cent

1025
00:49:20,170 --> 00:49:21,830
est utilisé comme indicateur de format.

1026
00:49:21,830 --> 00:49:25,420
>> Lorsque vous utilisez pour cent à l'extérieur de
que, dans une expression mathématique,

1027
00:49:25,420 --> 00:49:29,910
il est l'opérateur modulo modulaire
arithmetic-- pour nos besoins

1028
00:49:29,910 --> 00:49:33,650
ici, signifie simplement, quelle est la
reste de x divisée par y?

1029
00:49:33,650 --> 00:49:36,130
Si x est divisé par y x y slash.

1030
00:49:36,130 --> 00:49:38,220
Quel est le reste de x divisé par y?

1031
00:49:38,220 --> 00:49:41,780
Il est x y mod, en tant que programmeur dirait.

1032
00:49:41,780 --> 00:49:48,300
>> Donc, si je faisais pas d'erreur ici, laissez-moi
aller de l'avant et de faire ints, pluriel, gentil,

1033
00:49:48,300 --> 00:49:50,010
et dot ints slash.

1034
00:49:50,010 --> 00:49:55,270
Et allons-y et
faire, disons, 1, 10.

1035
00:49:55,270 --> 00:49:58,390
Tout droit, 1 plus 10 est 11, chèque.

1036
00:49:58,390 --> 00:50:01,240
1 moins 10 est négative 9, vérifier.

1037
00:50:01,240 --> 00:50:03,420
>> 1 fois 10 est 10, chèque.

1038
00:50:03,420 --> 00:50:07,090
1 divisé par 10 est--
OK, nous allons sauter celui-là.

1039
00:50:07,090 --> 00:50:09,480
Le reste de 1 divisé par 10 est égal à 1.

1040
00:50:09,480 --> 00:50:10,680
C'est correct.

1041
00:50:10,680 --> 00:50:12,630
Mais il y a un bug ici.

1042
00:50:12,630 --> 00:50:15,390
>> Donc, celui que je mets ma
remettre, pas correct.

1043
00:50:15,390 --> 00:50:16,670
Je veux dire, il est proche de 0.

1044
00:50:16,670 --> 00:50:20,670
1 divisé par 10, vous savez, si nous sommes
couper quelques coins, bien sûr, il est nul.

1045
00:50:20,670 --> 00:50:28,050
Mais il devrait vraiment être 1/10,
0,1 ou 0,10, 0,1000, ou ainsi de suite.

1046
00:50:28,050 --> 00:50:30,600
>> Il ne devrait pas vraiment être nul.

1047
00:50:30,600 --> 00:50:35,990
Eh bien, il se trouve que l'ordinateur est
faire littéralement ce que nous avons dit de faire.

1048
00:50:35,990 --> 00:50:39,460
Nous faisons des mathématiques comme x divisé par y.

1049
00:50:39,460 --> 00:50:44,680
Et x et y, par les lignes
du code précédent, sont des nombres entiers.

1050
00:50:44,680 --> 00:50:50,440
>> En outre, sur la ligne 15, nous sommes
dire printf, hé, printf plug-in

1051
00:50:50,440 --> 00:50:54,230
un nombre entier, plug-in un nombre entier,
plug-in un integer-- spécifiquement

1052
00:50:54,230 --> 00:50:57,580
x, puis y, puis x
divisé par y. x et y sont des entiers.

1053
00:50:57,580 --> 00:50:59,060
Nous sommes bien là.

1054
00:50:59,060 --> 00:51:01,250
>> Mais ce qui est x divisé par x?

1055
00:51:01,250 --> 00:51:06,790
x divisé par y devrait être,
mathématiquement, 1/10, ou 0,1,

1056
00:51:06,790 --> 00:51:11,600
qui est un nombre réel, un nombre réel
ayant, potentiellement, un point décimal.

1057
00:51:11,600 --> 00:51:13,230
Il est pas un entier.

1058
00:51:13,230 --> 00:51:18,290
>> Mais ce qui est le plus proche
entier à 10/01, ou 0,1?

1059
00:51:18,290 --> 00:51:21,114
Oui, ce genre de zéro.

1060
00:51:21,114 --> 00:51:22,030
0.1 est comme ça beaucoup.

1061
00:51:22,030 --> 00:51:22,890
Et 1 est autant.

1062
00:51:22,890 --> 00:51:25,870
Donc 1/10 est plus proche de
0 qu'il est à un.

1063
00:51:25,870 --> 00:51:30,800
>> Et donc ce que C est fait pour us--
sorte de parce que nous lui avons dit to--

1064
00:51:30,800 --> 00:51:32,600
est tronquant cet entier.

1065
00:51:32,600 --> 00:51:40,540
Il prend la valeur, qui est à nouveau
censé être quelque chose comme 0.1000,

1066
00:51:40,540 --> 00:51:41,800
0 et ainsi de suite.

1067
00:51:41,800 --> 00:51:45,320
Et il est tout tronquant
après la virgule

1068
00:51:45,320 --> 00:51:47,510
de sorte que tout cela
choses, parce qu'il ne

1069
00:51:47,510 --> 00:51:51,910
intégrer la notion d'un nombre entier, qui
est juste un nombre comme négatif 1, 0, 1,

1070
00:51:51,910 --> 00:51:55,830
de haut en bas, il jette tout
après le point parce que vous décimales

1071
00:51:55,830 --> 00:51:59,020
ne peut pas adapter à un point décimal
en un nombre entier par définition.

1072
00:51:59,020 --> 00:52:01,290
>> Donc, la réponse est ici zéro.

1073
00:52:01,290 --> 00:52:02,600
Alors, comment pouvons-nous résoudre ce problème?

1074
00:52:02,600 --> 00:52:04,400
Nous avons besoin d'une autre solution tous ensemble.

1075
00:52:04,400 --> 00:52:06,880
Et nous pouvons le faire, comme suit.

1076
00:52:06,880 --> 00:52:12,820
>> Laissez-moi aller de l'avant et de créer une nouvelle
fichier, celui-ci a appelé floats.c.

1077
00:52:12,820 --> 00:52:16,500
Et enregistrez-le ici dans le
même répertoire, float.c.

1078
00:52:16,500 --> 00:52:19,360

1079
00:52:19,360 --> 00:52:23,260
Et laissez-moi aller de l'avant et copier
une partie de ce code à partir plus tôt.

1080
00:52:23,260 --> 00:52:27,690
>> Mais au lieu d'obtenir
un int, faisons cela.

1081
00:52:27,690 --> 00:52:31,037
Donnez-moi une valeur à virgule flottante
appelé x. où un point flottant

1082
00:52:31,037 --> 00:52:33,370
la valeur est juste littéralement
quelque chose avec un point flottant.

1083
00:52:33,370 --> 00:52:34,410
Il peut se déplacer vers la gauche, vers la droite.

1084
00:52:34,410 --> 00:52:35,530
Il est un nombre réel.

1085
00:52:35,530 --> 00:52:38,050
>> Et laissez-moi appeler pas
obtenir int, mais obtenir flotteur,

1086
00:52:38,050 --> 00:52:41,420
qui a également été parmi le menu
des options de la bibliothèque C250.

1087
00:52:41,420 --> 00:52:43,220
Nous allons y changer à un flotteur.

1088
00:52:43,220 --> 00:52:45,000
Donc, cela devient obtenir flotteur.

1089
00:52:45,000 --> 00:52:47,620
>> Et maintenant, nous ne voulons pas brancher ints.

1090
00:52:47,620 --> 00:52:53,130
Il se trouve que nous devons utiliser pour cent
f pour float, pour cent f pour flotteur,

1091
00:52:53,130 --> 00:52:54,560
et maintenant il sauver.

1092
00:52:54,560 --> 00:53:01,220
Et maintenant, les doigts croisés, faire
flotteurs, gentil, flotteurs slash dot.

1093
00:53:01,220 --> 00:53:04,280
x va être un 1. y
Va être 10 à nouveau.

1094
00:53:04,280 --> 00:53:08,240
>> Et, bien, OK mon addition est correcte.

1095
00:53:08,240 --> 00:53:10,240
J'espérais plus,
mais j'oublié de l'écrire.

1096
00:53:10,240 --> 00:53:13,250
Allons donc et corriger cette erreur logique.

1097
00:53:13,250 --> 00:53:16,280
>> Allons de l'avant et de saisir ce qui suit.

1098
00:53:16,280 --> 00:53:18,080
Nous allons juste faire un petit copier-coller.

1099
00:53:18,080 --> 00:53:20,080
Et je vais dire moins.

1100
00:53:20,080 --> 00:53:21,890
>> Et je vais dire fois.

1101
00:53:21,890 --> 00:53:24,060
Et je vais dire divisée.

1102
00:53:24,060 --> 00:53:28,240
Et je ne vais pas faire modulo,
qui ne sont pas aussi germane ici,

1103
00:53:28,240 --> 00:53:33,690
divisé par f, et les temps plus--
OK, nous allons le faire à nouveau.

1104
00:53:33,690 --> 00:53:44,210
>> Faire des flotteurs, flotteurs slash dot,
et 1, 10, et-- agréable, non, OK.

1105
00:53:44,210 --> 00:53:45,250
Donc, je suis un idiot.

1106
00:53:45,250 --> 00:53:47,000
Donc, ce qui est très commun
en informatique

1107
00:53:47,000 --> 00:53:49,780
de faire des erreurs stupides comme ça.

1108
00:53:49,780 --> 00:53:53,100
>> Pour des fins pédagogiques,
ce que je voulais vraiment faire

1109
00:53:53,100 --> 00:53:57,410
a été changer science ici
pour atteindre plus, à moins, à l'époque,

1110
00:53:57,410 --> 00:54:01,140
et de diviser, comme vous nous l'espérons
remarqué au cours de cet exercice.

1111
00:54:01,140 --> 00:54:04,700
Alors maintenant, nous allons re-compiler cette
programme, faire des flotteurs slash dot.

1112
00:54:04,700 --> 00:54:07,950
>> Et pour la troisième fois, nous allons
voir si elle répond à mes attentes.

1113
00:54:07,950 --> 00:54:21,480
1, 10, entrez, oui, OK, 1.000,
divisé par 10,000, est 0,100000.

1114
00:54:21,480 --> 00:54:24,952
Et il se trouve que nous pouvons contrôler le nombre
chiffres sont après ces chiffres après la virgule.

1115
00:54:24,952 --> 00:54:25,660
En fait, nous le ferons.

1116
00:54:25,660 --> 00:54:26,790
Nous reviendrons à cela.

1117
00:54:26,790 --> 00:54:28,440
>> Mais maintenant, en fait, le calcul est correct.

1118
00:54:28,440 --> 00:54:30,090
Donc, encore une fois, quelle est la livraison ici?

1119
00:54:30,090 --> 00:54:33,050
Il se trouve que, dans C, il y a
non seulement juste strings-- et, en fait,

1120
00:54:33,050 --> 00:54:36,120
il n'y a pas vraiment, parce que nous
ajouter ceux avec la bibliothèque CS50.

1121
00:54:36,120 --> 00:54:37,710
Mais il n'y a pas seulement ints.

1122
00:54:37,710 --> 00:54:38,990
>> Il existe également des flotteurs.

1123
00:54:38,990 --> 00:54:42,810
Et il se trouve un tas d'autres données
types aussi, que nous allons utiliser avant longtemps.

1124
00:54:42,810 --> 00:54:46,270
Active si vous voulez un seul
caractère, pas une chaîne de caractères,

1125
00:54:46,270 --> 00:54:47,610
vous pouvez simplement utiliser un caractère.

1126
00:54:47,610 --> 00:54:52,350
>> Avère que si vous voulez un bool,
une valeur booléenne, vrai ou faux seulement,

1127
00:54:52,350 --> 00:54:56,840
grâce à la bibliothèque de CS50, nous avons
ajouté à C le type de données bool ainsi.

1128
00:54:56,840 --> 00:54:59,180
Mais il est présent aussi dans
beaucoup d'autres langues.

1129
00:54:59,180 --> 00:55:04,130
Et il se trouve que, parfois, vous
besoin de plus grands nombres puis viennent par défaut

1130
00:55:04,130 --> 00:55:05,210
avec ints et flotteurs.

1131
00:55:05,210 --> 00:55:10,590
>> Et, en fait, un double est un nombre
qui utilise non pas 32 bits, mais 64 bits.

1132
00:55:10,590 --> 00:55:14,990
Et un long est un nombre qui
utilise pas 32, les bits, mais 64 bits,

1133
00:55:14,990 --> 00:55:19,190
respectivement, pour virgule flottante
des valeurs et des nombres entiers, respectivement.

1134
00:55:19,190 --> 00:55:22,780
Donc, nous allons effectivement maintenant
voir en action.

1135
00:55:22,780 --> 00:55:26,150
>> Je vais aller de l'avant ici
et concocter un autre programme.

1136
00:55:26,150 --> 00:55:32,020
Ici, je vais aller de l'avant
et ne comprennent CS50.h.

1137
00:55:32,020 --> 00:55:34,910
Et laissez-moi aller, inclure la norme io.h.

1138
00:55:34,910 --> 00:55:37,320
>> Et vous remarquerez quelque chose
génial qui se passe ici.

1139
00:55:37,320 --> 00:55:40,592
Il est pas le codage couleur des choses dans
de la même manière comme avant.

1140
00:55:40,592 --> 00:55:43,550
Et il se trouve, c'est parce que je
ont pas donné la chose un nom de fichier.

1141
00:55:43,550 --> 00:55:47,270
>> Je vais appeler celui-ci
sizeof.c, et cliquez sur Enregistrer.

1142
00:55:47,270 --> 00:55:51,039
Et remarquez ce qui arrive à mon très
Code blanc sur cette toile de fond noir.

1143
00:55:51,039 --> 00:55:52,830
Maintenant, au moins, il y a
certains pourpre là-dedans.

1144
00:55:52,830 --> 00:55:54,490
Et il est la syntaxe en surbrillance.

1145
00:55:54,490 --> 00:55:57,700
>> C'est parce que, tout simplement, je l'ai
dit l'IDE quel type de fichier

1146
00:55:57,700 --> 00:56:01,060
il est en lui donnant un nom, et
spécifiquement une extension de fichier.

1147
00:56:01,060 --> 00:56:03,620
Maintenant, nous allons aller de l'avant et de faire cela.

1148
00:56:03,620 --> 00:56:08,910
Je vais aller de l'avant et très
il suffit d'imprimer le bool following--

1149
00:56:08,910 --> 00:56:11,080
est pour cent LU.

1150
00:56:11,080 --> 00:56:12,950
>> Nous y reviendrons
que, dans un instant.

1151
00:56:12,950 --> 00:56:15,840
Et puis je vais
taille d'impression de bool.

1152
00:56:15,840 --> 00:56:18,170
Et maintenant, juste pour sauver
moi un peu de temps, je suis

1153
00:56:18,170 --> 00:56:20,280
va faire ensemble
tas de cela à la fois.

1154
00:56:20,280 --> 00:56:24,620
Et, précisément, je vais
changer à un omble chevalier et l'omble.

1155
00:56:24,620 --> 00:56:27,760
Celui-ci, je vais changer
à un double et un double.

1156
00:56:27,760 --> 00:56:31,440
>> Celui-ci, je vais changer
à un flotteur et un flotteur.

1157
00:56:31,440 --> 00:56:35,670
Celui-ci, je vais
changer pour un int et un int.

1158
00:56:35,670 --> 00:56:38,660
Et celui-ci, je vais
pour passer à un long.

1159
00:56:38,660 --> 00:56:40,840
Et il est toujours prendre
depuis longtemps, bien longtemps.

1160
00:56:40,840 --> 00:56:44,572
>> Et puis, enfin, je donnai
moi-même un trop grand nombre, chaîne.

1161
00:56:44,572 --> 00:56:47,030
Il se trouve que dans C, il y a
l'opérateur spécial appelé

1162
00:56:47,030 --> 00:56:50,260
taille qui est littéralement
va, lorsqu'il est exécuté,

1163
00:56:50,260 --> 00:56:52,099
nous dire la taille de
chacune de ces variables.

1164
00:56:52,099 --> 00:56:53,890
Et cela est une façon, maintenant,
nous pouvons nous connecter de retour

1165
00:56:53,890 --> 00:56:57,140
à la discussion de la semaine dernière
des données et de la représentation.

1166
00:56:57,140 --> 00:57:00,330
>> Laissez-moi aller de l'avant et de compiler
la taille de la taille de slash dot de.

1167
00:57:00,330 --> 00:57:01,210
Et nous allons voir.

1168
00:57:01,210 --> 00:57:05,210
Il se trouve que, dans C,
spécifiquement sur CS50 IDE,

1169
00:57:05,210 --> 00:57:08,170
plus précisément sur la
système d'exploitation Ubuntu,

1170
00:57:08,170 --> 00:57:11,100
qui est une exploitation 64 bits
système dans ce cas,

1171
00:57:11,100 --> 00:57:14,189
un bool va
utiliser un octet d'espace.

1172
00:57:14,189 --> 00:57:16,480
Voilà comment la taille est mesurée,
pas en bits, mais en octets.

1173
00:57:16,480 --> 00:57:18,690
Et rappeler qu'un octet est de huit bits.

1174
00:57:18,690 --> 00:57:22,030
Ainsi, un bool, même si vous
techniquement seulement besoin d'un 0 ou 1,

1175
00:57:22,030 --> 00:57:24,092
il est un peu inutile
comment nous avons implémenté.

1176
00:57:24,092 --> 00:57:26,800
Il va réellement utiliser ensemble
byte-- donc tous les zéros, sont peut-être

1177
00:57:26,800 --> 00:57:31,050
tous ceux, ou quelque chose comme ça,
ou juste un 1 parmi les huit bits.

1178
00:57:31,050 --> 00:57:34,962
>> Un char, quant à lui, utilisé pour un caractère
comme un caractère Ascii par la semaine dernière,

1179
00:57:34,962 --> 00:57:36,170
va être un caractère.

1180
00:57:36,170 --> 00:57:42,340
Et ce synchs avec notre notion de
étant pas plus de 256 bits-- plutôt,

1181
00:57:42,340 --> 00:57:45,360
synchs avec elle étant pas
plus de 8 bits,

1182
00:57:45,360 --> 00:57:47,450
nous donne jusqu'à 256 valeurs.

1183
00:57:47,450 --> 00:57:49,680
Un double va
être de 8 octets ou 64 bits.

1184
00:57:49,680 --> 00:57:50,510
>> Un flotteur est 4.

1185
00:57:50,510 --> 00:57:51,690
Un int est 4.

1186
00:57:51,690 --> 00:57:52,980
Une longue, est longue 8.

1187
00:57:52,980 --> 00:57:54,716
Et une chaîne est 8.

1188
00:57:54,716 --> 00:57:55,840
Mais ne vous inquiétez pas à ce sujet.

1189
00:57:55,840 --> 00:57:57,340
Nous allons décoller cette couche.

1190
00:57:57,340 --> 00:57:59,940
Il se trouve, les chaînes peuvent
être supérieure à 8 octets.

1191
00:57:59,940 --> 00:58:02,310
>> Et, en effet, nous avons écrit
cordes déjà, bonjour monde,

1192
00:58:02,310 --> 00:58:03,700
plus de 8 octets.

1193
00:58:03,700 --> 00:58:06,270
Mais nous y reviendrons
que, dans un instant.

1194
00:58:06,270 --> 00:58:09,690
Mais la prise de distance ici est le suivant.

1195
00:58:09,690 --> 00:58:15,320
>> Tout ordinateur ne dispose que d'un fini
la quantité de mémoire et de l'espace.

1196
00:58:15,320 --> 00:58:17,860
Vous ne pouvez stocker autant de
fichiers sur votre Mac ou PC.

1197
00:58:17,860 --> 00:58:23,030
Vous ne pouvez stocker autant de programmes
RAM en cours d'exécution à la fois, nécessairement, même

1198
00:58:23,030 --> 00:58:26,360
avec de la mémoire virtuelle, parce
vous avez une quantité finie de RAM.

1199
00:58:26,360 --> 00:58:28,990
>> Et juste pour picture-- si
vous ne l'avez jamais ouvert un ordinateur portable

1200
00:58:28,990 --> 00:58:31,300
ou ordonné mémoire supplémentaire
pour un ordinateur, vous

1201
00:58:31,300 --> 00:58:33,670
pourrait ne pas savoir que
à l'intérieur de votre ordinateur

1202
00:58:33,670 --> 00:58:36,590
est quelque chose qui ressemble
un peu comme ça.

1203
00:58:36,590 --> 00:58:40,540
Donc, ceci est juste une société commune nommée
Crucial qui fait RAM pour les ordinateurs.

1204
00:58:40,540 --> 00:58:43,620
Et RAM est le cas des programmes
vivre pendant qu'ils courent.

1205
00:58:43,620 --> 00:58:46,630
>> Ainsi, sur chaque Mac ou PC, lorsque vous double
cliquez sur un programme, et il ouvre,

1206
00:58:46,630 --> 00:58:48,921
et il ouvre un certain document Word
ou quelque chose comme ça,

1207
00:58:48,921 --> 00:58:51,764
il stocke temporairement dans
RAM, parce que la RAM est plus rapide

1208
00:58:51,764 --> 00:58:53,680
que votre disque dur, ou
votre disque d'état solide.

1209
00:58:53,680 --> 00:58:56,600
Donc, il est juste là où les programmes vont
pour vivre quand ils sont en cours d'exécution,

1210
00:58:56,600 --> 00:58:58,060
ou lorsque les fichiers sont utilisés.

1211
00:58:58,060 --> 00:59:00,890
>> Donc, vous avez des choses qui ressemblent
comme celui-ci à l'intérieur de votre ordinateur portable,

1212
00:59:00,890 --> 00:59:03,320
ou légèrement plus grandes choses
à l'intérieur de votre bureau.

1213
00:59:03,320 --> 00:59:07,440
Mais la clé est que vous avez seulement
nombre fini de ces choses.

1214
00:59:07,440 --> 00:59:11,230
Et il y a seulement une quantité finie de
matériel assis sur ce bureau droit

1215
00:59:11,230 --> 00:59:11,730
ici.

1216
00:59:11,730 --> 00:59:15,920
>> Alors, sûrement, nous ne pouvons pas stocker
infiniment longs numéros.

1217
00:59:15,920 --> 00:59:19,030
Et pourtant, si vous pensez revenir à
école primaire, le nombre de chiffres peut

1218
00:59:19,030 --> 00:59:21,400
vous avez le droit
d'un point décimal?

1219
00:59:21,400 --> 00:59:24,680
Pour cette question, combien de chiffres peut
vous avez à la gauche d'un point décimal?

1220
00:59:24,680 --> 00:59:26,300
Vraiment, infiniment nombreux.

1221
00:59:26,300 --> 00:59:30,840
>> Maintenant, nous, les humains pourraient seulement
savoir comment prononcer millions,

1222
00:59:30,840 --> 00:59:34,990
et milliards, billions de dollars, et
quadrillions et quintillion.

1223
00:59:34,990 --> 00:59:39,370
Et je pousse les limites de mon
understanding-- ou my-- Je comprends

1224
00:59:39,370 --> 00:59:41,110
numéros, mais mon
Prononciation de nombres.

1225
00:59:41,110 --> 00:59:44,720
Mais ils peuvent obtenir infiniment grand avec
un nombre infini de chiffres à gauche

1226
00:59:44,720 --> 00:59:47,050
ou à droite d'un point décimal.

1227
00:59:47,050 --> 00:59:50,040
>> Mais les ordinateurs ont seulement
quantité finie de mémoire,

1228
00:59:50,040 --> 00:59:53,510
un nombre fini de transistors, un
nombre fini d'ampoules à l'intérieur.

1229
00:59:53,510 --> 00:59:57,350
Alors qu'est-ce qui se passe quand
vous manquez d'espace?

1230
00:59:57,350 --> 00:59:59,620
En d'autres termes, si vous
penser à la semaine dernière

1231
00:59:59,620 --> 01:00:03,160
lorsque nous avons parlé des numéros
étant eux-mêmes représentés en binaire,

1232
01:00:03,160 --> 01:00:05,480
supposons que nous avons
cette valeur de 8 bits ici.

1233
01:00:05,480 --> 01:00:08,290
>> Et nous avons sept de 1 et un 0.

1234
01:00:08,290 --> 01:00:10,827
Et supposons que nous voulons
à ajouter 1 à cette valeur.

1235
01:00:10,827 --> 01:00:12,410
Ceci est un très grand nombre en ce moment.

1236
01:00:12,410 --> 01:00:16,610
>> Ceci est 254, si je me souviens
le calcul de la semaine dernière à droite.

1237
01:00:16,610 --> 01:00:19,480
Mais si je change
que l'extrême droite 0 à 1?

1238
01:00:19,480 --> 01:00:22,800
Le nombre entier, de
Bien sûr, devient huit des 1.

1239
01:00:22,800 --> 01:00:24,050
Nous sommes donc toujours bon.

1240
01:00:24,050 --> 01:00:27,204
>> Et cela représente probablement
255, selon que le contexte

1241
01:00:27,204 --> 01:00:29,120
il pourrait en fait représenter
un nombre négatif.

1242
01:00:29,120 --> 01:00:31,240
Mais plus sur une autre fois.

1243
01:00:31,240 --> 01:00:34,220
Cela se sent comme il est à propos de
aussi haut que je peux compter.

1244
01:00:34,220 --> 01:00:35,290
>> Maintenant, il est seulement 8 bits.

1245
01:00:35,290 --> 01:00:38,170
Et mon Mac, sûrement, a ainsi
plus de 8 bits de mémoire.

1246
01:00:38,170 --> 01:00:39,170
Mais il n'a fini.

1247
01:00:39,170 --> 01:00:43,230
Ainsi, le même argument vaut, même si nous
avoir plus de celles-ci sur l'écran.

1248
01:00:43,230 --> 01:00:47,020
>> Mais ce qui se passe si vous êtes
stocker ce nombre, 255,

1249
01:00:47,020 --> 01:00:49,290
et vous voulez compter 1 peu plus élevé?

1250
01:00:49,290 --> 01:00:51,600
Vous voulez aller 255-256.

1251
01:00:51,600 --> 01:00:55,800
Le problème, bien sûr, est que si vous
commencer à compter à zéro comme la semaine dernière,

1252
01:00:55,800 --> 01:00:59,670
vous ne pouvez pas compter aussi élevé
comme 256, et encore moins 257,

1253
01:00:59,670 --> 01:01:02,584
et encore moins 258, m parce que
qui se passe lorsque vous ajoutez un 1?

1254
01:01:02,584 --> 01:01:05,000
Si vous faites l'ancienne école primaire
approche, vous mettez un 1 ici,

1255
01:01:05,000 --> 01:01:08,150
puis 1 plus 1 est 2, mais c'est
vraiment un zéro, vous portez le 1,

1256
01:01:08,150 --> 01:01:09,695
porter le 1, porter le 1.

1257
01:01:09,695 --> 01:01:12,620
Toutes ces choses,
ces 1 de, aller à zéro.

1258
01:01:12,620 --> 01:01:17,820
Et vous vous retrouvez, oui, comme quelqu'un
souligné, un 1 sur le côté gauche.

1259
01:01:17,820 --> 01:01:22,540
Mais tout ce que vous pouvez
en fait voir et tenir en mémoire

1260
01:01:22,540 --> 01:01:27,960
est seulement huit des 0, ce qui est à dire
à un moment donné si vous, un ordinateur,

1261
01:01:27,960 --> 01:01:32,490
essayé de compter assez haut, vous êtes
va enrouler autour, il semblerait,

1262
01:01:32,490 --> 01:01:35,850
à zéro, ou peut-être même négative
numéros, qui sont encore plus bas que zéro.

1263
01:01:35,850 --> 01:01:37,260
>> Et nous pouvons sorte de voir cela.

1264
01:01:37,260 --> 01:01:39,900
Laissez-moi aller de l'avant et d'écrire
un véritable programme rapide ici.

1265
01:01:39,900 --> 01:01:43,690
Laissez-moi aller de l'avant et d'écrire
un programme appelé débordement.

1266
01:01:43,690 --> 01:01:49,980
Inclure CS50.h, comprennent
norme IO.h-- oh,

1267
01:01:49,980 --> 01:01:51,730
J'ai vraiment raté ma coloration syntaxique.

1268
01:01:51,730 --> 01:01:54,440
Donc, nous allons l'enregistrer comme overflow.c.

1269
01:01:54,440 --> 01:01:57,084
>> Et void-- principale maintenant int
et avant longtemps, nous allons

1270
01:01:57,084 --> 01:01:59,500
revenir à expliquer pourquoi
nous continuons à écrire void main int.

1271
01:01:59,500 --> 01:02:02,080
Mais pour l'instant, nous allons faire tout
elle, en prenant pour acquis.

1272
01:02:02,080 --> 01:02:06,200
Allons me donner un int,
et l'initialiser à 0.

1273
01:02:06,200 --> 01:02:11,716
>> Nous allons ensuite faire pour int i obtenir zero--
en fait, nous allons faire une boucle infinie

1274
01:02:11,716 --> 01:02:12,590
et de voir ce qui se passe.

1275
01:02:12,590 --> 01:02:22,440
Bien vrai, alors nous allons imprimer n
est pour cent i, backslash n, plug-in n.

1276
01:02:22,440 --> 01:02:27,200
Mais, maintenant, nous allons faire n obtient n + 1.

1277
01:02:27,200 --> 01:02:29,660
>> En d'autres termes, à chaque
itération de cette boucle infinie,

1278
01:02:29,660 --> 01:02:32,550
Prenons la valeur de n,
et ajouter 1 à elle, puis

1279
01:02:32,550 --> 01:02:34,350
stocker le résultat de retour n sur la gauche.

1280
01:02:34,350 --> 01:02:37,150
Et, en fait, nous avons vu la syntaxe
légèrement comme cela, brièvement.

1281
01:02:37,150 --> 01:02:39,730
Une astuce est cool place
d'écrire tout ça,

1282
01:02:39,730 --> 01:02:42,770
vous pouvez réellement dire un n plus égal à 1.

1283
01:02:42,770 --> 01:02:47,480
>> Ou si vous voulez vraiment être de fantaisie,
vous pouvez dire n plus plus point-virgule.

1284
01:02:47,480 --> 01:02:50,130
Mais ces deux derniers sont juste
ce que nous appellerions le sucre syntaxique

1285
01:02:50,130 --> 01:02:50,790
pour la première chose.

1286
01:02:50,790 --> 01:02:53,456
>> La première chose est plus explicite,
tout à fait bien, tout à fait correct.

1287
01:02:53,456 --> 01:02:55,470
Mais ce qui est plus commun, je vais le dire.

1288
01:02:55,470 --> 01:02:57,210
Donc, nous allons faire cela pour un instant.

1289
01:02:57,210 --> 01:03:01,685
>> Nous allons maintenant faire trop-plein, qui sonne
plutôt inquiétant, débordement de slash dot.

1290
01:03:01,685 --> 01:03:04,380

1291
01:03:04,380 --> 01:03:09,852
Voyons voir, n commence à faire assez grand.

1292
01:03:09,852 --> 01:03:11,310
Mais nous allons réfléchir, la taille peut n obtenir?

1293
01:03:11,310 --> 01:03:12,870
>> n est un entier.

1294
01:03:12,870 --> 01:03:16,400
Nous avons vu il y a quelques instants avec la taille de
exemple qu'un int est de quatre octets.

1295
01:03:16,400 --> 01:03:22,070
Nous savons depuis la semaine dernière, quatre octets est
32 bits, parce que 8 fois 4, c'est 32.

1296
01:03:22,070 --> 01:03:23,460
Cela va être de 4 milliards de dollars.

1297
01:03:23,460 --> 01:03:25,802
>> Et nous sommes jusqu'à 800.000.

1298
01:03:25,802 --> 01:03:28,510
Cela va prendre une éternité pour
compter aussi haut que je le peux.

1299
01:03:28,510 --> 01:03:30,635
Je vais donc aller de l'avant,
comme vous pouvez avant longtemps,

1300
01:03:30,635 --> 01:03:34,910
et appuyez sur Commande C-- franchement, Contrôle
C, beaucoup, où le contrôle C généralement

1301
01:03:34,910 --> 01:03:36,034
des moyens d'annuler.

1302
01:03:36,034 --> 01:03:38,200
Malheureusement, parce que cette
est en cours d'exécution dans le nuage,

1303
01:03:38,200 --> 01:03:41,190
parfois le nuage est
cracher tellement de choses,

1304
01:03:41,190 --> 01:03:44,180
tellement sortie, ça va
prendre un peu de temps pour mon entrée

1305
01:03:44,180 --> 01:03:45,630
pour obtenir le nuage.

1306
01:03:45,630 --> 01:03:49,240
Donc, même si je frappe
Contrôle C il y a quelques secondes,

1307
01:03:49,240 --> 01:03:53,110
c'est certainement le côté
effet d'une boucle infinie.

1308
01:03:53,110 --> 01:03:56,070
>> Et dans ce cas, nous sommes
va laisser ce soit.

1309
01:03:56,070 --> 01:03:59,050
Et nous allons ajouter un autre
fenêtre de terminal ici

1310
01:03:59,050 --> 01:04:03,186
avec le plus, qui bien sûr ne
comme ça, car il est toujours penser.

1311
01:04:03,186 --> 01:04:05,310
Et nous allons aller de l'avant et être
un peu plus raisonnable.

1312
01:04:05,310 --> 01:04:07,768
>> Je vais aller de l'avant et de faire
ce qu'un nombre fini de fois.

1313
01:04:07,768 --> 01:04:10,047
Nous allons utiliser une boucle,
dont je parlais tout à l'heure.

1314
01:04:10,047 --> 01:04:10,630
Faisons cela.

1315
01:04:10,630 --> 01:04:13,430
Donnez-moi une autre variable int i obtient 0.

1316
01:04:13,430 --> 01:04:17,430
i est inférieur à, disons, 64 i ++.

1317
01:04:17,430 --> 01:04:24,010
Et maintenant, laissez-moi aller de l'avant et d'imprimer
out n est pour cent i, virgule n.

1318
01:04:24,010 --> 01:04:27,547
Et puis n-- cela est encore
va prendre une éternité.

1319
01:04:27,547 --> 01:04:28,130
Faisons cela.

1320
01:04:28,130 --> 01:04:30,620
>> n obtient n fois 2.

1321
01:04:30,620 --> 01:04:34,140
Ou nous pourrions être de fantaisie
et font parfois égale 2.

1322
01:04:34,140 --> 01:04:37,120
Mais disons simplement que n
lui-même égal à égal, 2 fois.

1323
01:04:37,120 --> 01:04:39,321
En d'autres termes, dans ce
la nouvelle version du programme,

1324
01:04:39,321 --> 01:04:41,820
Je ne veux pas attendre indéfiniment
à partir comme 800.000 à 4 milliards.

1325
01:04:41,820 --> 01:04:43,070
Finissons-en avec.

1326
01:04:43,070 --> 01:04:44,920
>> Disons en fait le double n à chaque fois.

1327
01:04:44,920 --> 01:04:47,660
Ce qui, le rappel, le doublement est le
en face d'avoir, bien sûr.

1328
01:04:47,660 --> 01:04:50,035
Et alors que la semaine dernière, nous avons
quelque chose de nouveau, et encore,

1329
01:04:50,035 --> 01:04:52,200
et encore une fois, super rapide,
doublement va sûrement

1330
01:04:52,200 --> 01:04:58,080
nous faire de 1 à la plus grande possible
valeur que nous pouvons compter pour int.

1331
01:04:58,080 --> 01:04:59,750
>> Donc, nous allons faire exactement cela.

1332
01:04:59,750 --> 01:05:01,720
Et nous reviendrons à cela avant longtemps.

1333
01:05:01,720 --> 01:05:04,180
Mais cela, encore une fois, est tout comme
le bloc de répétition dans Scratch.

1334
01:05:04,180 --> 01:05:05,600
Et vous utilisez cette avant longtemps.

1335
01:05:05,600 --> 01:05:10,170
>> Cela signifie simplement le nombre de zéro
jusqu'à, mais pas égale, à 64 ans.

1336
01:05:10,170 --> 01:05:14,285
Et à chaque itération de cet
boucle, gardez simplement incrémenter i.

1337
01:05:14,285 --> 01:05:18,990
Donc i ++ - et cette construction générale
sur la ligne 7 est juste un moyen super commun

1338
01:05:18,990 --> 01:05:22,290
de répéter quelques lignes de
code, un certain nombre de fois.

1339
01:05:22,290 --> 01:05:23,362
Quelles lignes de code?

1340
01:05:23,362 --> 01:05:25,570
Ces accolades, comme vous
peut-être glanées à partir de maintenant,

1341
01:05:25,570 --> 01:05:26,780
moyens, procédez comme suit.

1342
01:05:26,780 --> 01:05:29,510
>> Il est dans Scratch comme, quand
il a les blocs jaunes

1343
01:05:29,510 --> 01:05:32,680
et d'autres couleurs ce genre de
embrasser ou serrer les autres blocs.

1344
01:05:32,680 --> 01:05:34,750
Voilà ce que ces bouclés
accolades font ici.

1345
01:05:34,750 --> 01:05:40,200
Donc, si je suis ma syntaxe droite- vous
peut voir le symbole de la carotte en C des moyens

1346
01:05:40,200 --> 01:05:42,706
c'est combien de fois je suis
essayer de résoudre ce problème.

1347
01:05:42,706 --> 01:05:45,330
Donc, nous allons débarrasser de celui-là
tout à fait, et fermer cette fenêtre.

1348
01:05:45,330 --> 01:05:46,520
Et nous allons utiliser la nouvelle.

1349
01:05:46,520 --> 01:05:51,980
Faire débordement, slash dot
débordement, Entrez, tout droit,

1350
01:05:51,980 --> 01:05:53,090
il est mauvais au premier abord.

1351
01:05:53,090 --> 01:05:56,200
Mais nous allons revenir en arrière dans le temps,
parce que je l'ai fait 64 fois.

1352
01:05:56,200 --> 01:05:58,700
>> Et remarquez la première fois, n est 1.

1353
01:05:58,700 --> 01:06:03,110
Une deuxième fois, n est égal à 2,
puis 4, puis 8, puis 16.

1354
01:06:03,110 --> 01:06:09,450
Et il semble que, dès que
Je reçois à peu près 1 milliard,

1355
01:06:09,450 --> 01:06:12,800
si je double encore une fois, que
devrait me donner 2 milliards.

1356
01:06:12,800 --> 01:06:14,980
Mais il se trouve, il est
à droite sur le point.

1357
01:06:14,980 --> 01:06:18,930
>> Et il déborde effectivement
un int de 1 milliard

1358
01:06:18,930 --> 01:06:23,514
à peu près négatif 2
milliards, en raison d'un nombre entier,

1359
01:06:23,514 --> 01:06:25,430
à la différence du nombre nous
ont été en supposant que la semaine dernière,

1360
01:06:25,430 --> 01:06:28,397
peut être à la fois positif et négatif
dans la réalité et dans un ordinateur.

1361
01:06:28,397 --> 01:06:30,730
Et si au moins un de ces
bits est effectivement volés.

1362
01:06:30,730 --> 01:06:34,190
Donc, nous avons vraiment avons seulement 31 bits,
ou 2 milliards de valeurs possibles.

1363
01:06:34,190 --> 01:06:38,220
>> Mais pour l'instant, les plats à emporter est tout à fait
tout simplement, quelles que soient ces chiffres sont

1364
01:06:38,220 --> 01:06:42,280
et quel que soit le calcul est,
quelque chose de mauvais arrive à terme,

1365
01:06:42,280 --> 01:06:46,980
parce que finalement vous essayez de
permuter les bits une fois de trop.

1366
01:06:46,980 --> 01:06:51,060
Et vous allez effectivement de tous
de 1 à peut-être tous les 0, ou peut-être

1367
01:06:51,060 --> 01:06:54,260
juste un autre motif que ce
De toute évidence, selon le contexte,

1368
01:06:54,260 --> 01:06:56,342
peut être interprété comme un nombre négatif.

1369
01:06:56,342 --> 01:06:59,300
Et il semblerait que le plus élevé que je
peut compter dans ce programme particulier

1370
01:06:59,300 --> 01:07:01,210
est seulement environ 1 milliard.

1371
01:07:01,210 --> 01:07:02,760
Mais il y a une solution partielle ici.

1372
01:07:02,760 --> 01:07:03,480
Vous savez quoi?

1373
01:07:03,480 --> 01:07:07,600
>> Permettez-moi de changer d'un
int à un long long.

1374
01:07:07,600 --> 01:07:10,633
Et laissez-moi aller de l'avant ici
et say-- je vais avoir

1375
01:07:10,633 --> 01:07:12,290
de changer cela à un unsigned long.

1376
01:07:12,290 --> 01:07:16,860
Ou, voyons, je ne me souviens moi-même.

1377
01:07:16,860 --> 01:07:19,920
>> Allons de l'avant et de faire déborder.

1378
01:07:19,920 --> 01:07:21,860
Non, c'est pas, LLD, je vous remercie.

1379
01:07:21,860 --> 01:07:23,430
Alors parfois Clang peut être utile.

1380
01:07:23,430 --> 01:07:27,550
Je ne me souviens pas ce que le format
spécificateur était pendant une longue période.

1381
01:07:27,550 --> 01:07:28,950
>> Mais, en effet, Clang m'a dit.

1382
01:07:28,950 --> 01:07:31,570
Le vert est une sorte de bon,
signifie encore que vous avez fait une erreur.

1383
01:07:31,570 --> 01:07:33,190
Il est devine que je voulais dire LLD.

1384
01:07:33,190 --> 01:07:38,750
>> Alors laissez-moi prendre c'est des conseils, une longue
longue nombre décimal, sauf que.

1385
01:07:38,750 --> 01:07:43,190
Et permettez-moi de le relancer, dot
slash débordement, Entrée.

1386
01:07:43,190 --> 01:07:45,020
Et maintenant, ce qui est cool est la suivante.

1387
01:07:45,020 --> 01:07:49,140
>> Si je fais défiler dans le temps, nous commençons toujours
comptage au même place-- 1, 2, 4,

1388
01:07:49,140 --> 01:07:50,220
8, 16.

1389
01:07:50,220 --> 01:07:54,860
Remarquez, nous obtenons tous les
chemin jusqu'à 1 milliard.

1390
01:07:54,860 --> 01:07:57,070
Mais alors nous obtenons en toute sécurité à 2 milliards.

1391
01:07:57,070 --> 01:08:01,300
>> Puis nous arrivons à 4 milliards,
puis 8 milliards, 17 milliards.

1392
01:08:01,300 --> 01:08:03,340
Et nous allons plus haut, et
de plus en plus haut.

1393
01:08:03,340 --> 01:08:05,740
Finalement, cela, aussi, les pauses.

1394
01:08:05,740 --> 01:08:09,350
>> Finalement, avec un long temps,
qui est la valeur de 64 bits, non

1395
01:08:09,350 --> 01:08:13,660
une valeur 32 bits, si vous comptez
trop élevé, vous enveloppez autour de 0.

1396
01:08:13,660 --> 01:08:16,410
Et dans ce cas, nous nous trouvons
se retrouver avec un nombre négatif.

1397
01:08:16,410 --> 01:08:17,550
>> Donc, cela est un problème.

1398
01:08:17,550 --> 01:08:20,439
Et il se trouve que cette
problème est pas tout à fait mystérieux.

1399
01:08:20,439 --> 01:08:23,060
Même si je l'ai délibérément
induite avec ces erreurs,

1400
01:08:23,060 --> 01:08:26,149
il se trouve que nous le voyons genre de tous
autour de nous, ou du moins certains d'entre nous.

1401
01:08:26,149 --> 01:08:28,939
>> Donc, dans Lego Star Wars, si
vous avez déjà joué le jeu,

1402
01:08:28,939 --> 01:08:33,830
il se trouve que vous pouvez faire le tour
briser les choses dans LEGO monde,

1403
01:08:33,830 --> 01:08:36,640
et la collecte des pièces, essentiellement.

1404
01:08:36,640 --> 01:08:39,200
Et si vous avez déjà joué
ce jeu beaucoup trop de temps,

1405
01:08:39,200 --> 01:08:42,630
que cet individu sans nom
ici a fait, le nombre total

1406
01:08:42,630 --> 01:08:46,700
des pièces de monnaie que vous pouvez recueillir
est, il semblerait, 4 milliards.

1407
01:08:46,700 --> 01:08:48,240
>> Maintenant, avec il est effectivement arrondi.

1408
01:08:48,240 --> 01:08:50,239
Donc, LEGO a essayé de
garder les choses convivial.

1409
01:08:50,239 --> 01:08:53,779
Ils ne le font pas exactement 2 à
la puissance 32, par la semaine dernière.

1410
01:08:53,779 --> 01:08:55,310
Mais 4 milliards est une raison.

1411
01:08:55,310 --> 01:08:58,979
Il semble, sur la base de cette information,
que LEGO, et l'entreprise qui

1412
01:08:58,979 --> 01:09:02,624
fait de ce logiciel lui-même, a décidé
que le nombre maximal de pièces de monnaie

1413
01:09:02,624 --> 01:09:04,540
l'utilisateur peut accumuler
est, en effet, 4 milliards,

1414
01:09:04,540 --> 01:09:12,069
parce qu'ils ont choisi dans leur code
de ne pas utiliser un long, apparemment,

1415
01:09:12,069 --> 01:09:16,140
mais juste un nombre entier, un unsigned
nombre entier, seul un nombre entier positif, dont

1416
01:09:16,140 --> 01:09:18,089
valeur max est à peu près cela.

1417
01:09:18,089 --> 01:09:19,380
Eh bien, voici un autre drôle.

1418
01:09:19,380 --> 01:09:23,500
Ainsi, dans la civilisation de jeu, qui
certains d'entre vous connaissent peut-être, avec

1419
01:09:23,500 --> 01:09:26,660
il se trouve qu'il ya quelques années, il
avait un bug dans ce jeu dans lequel

1420
01:09:26,660 --> 01:09:28,750
si vous avez joué le rôle
de Gandhi dans le jeu,

1421
01:09:28,750 --> 01:09:34,020
au lieu de lui être très pacifiste,
la place était incroyablement, incroyablement

1422
01:09:34,020 --> 01:09:36,399
agressif, dans certaines circonstances.

1423
01:09:36,399 --> 01:09:40,529
En particulier, la façon dont la civilisation
œuvres est que si vous, le joueur,

1424
01:09:40,529 --> 01:09:44,680
adopter la démocratie, votre
Le score agressivité obtient

1425
01:09:44,680 --> 01:09:48,130
décrémenté par deux, donc moins
moins, puis minus.

1426
01:09:48,130 --> 01:09:50,569
>> Donc, vous soustrayez 2 de
votre itérer réelle.

1427
01:09:50,569 --> 01:09:56,650
Malheureusement, si votre itérer est
initialement 1, et vous soustraire 2 de celui-ci

1428
01:09:56,650 --> 01:09:59,050
après l'adoption de la démocratie
comme Gandhi ici pourrait

1429
01:09:59,050 --> 01:10:02,200
ont fait, parce qu'il était très passive--
1 sur l'échelle de l'agressivité.

1430
01:10:02,200 --> 01:10:04,830
Mais s'il adopte la démocratie, puis
il va de 1 à 1 négative.

1431
01:10:04,830 --> 01:10:11,470
>> Malheureusement, ils étaient
en utilisant des nombres non signés,

1432
01:10:11,470 --> 01:10:15,400
ce qui signifie qu'ils traitaient même négative
numéros comme si elles étaient positives.

1433
01:10:15,400 --> 01:10:19,780
Et il se trouve que la
équivalent positif de négatif 1,

1434
01:10:19,780 --> 01:10:23,480
dans des programmes informatiques typiques, est 255.

1435
01:10:23,480 --> 01:10:27,250
Donc, si Gandhi adopte
la démocratie a, et donc

1436
01:10:27,250 --> 01:10:32,470
son score d'agressivité a diminué,
il roule en fait autour de 255

1437
01:10:32,470 --> 01:10:35,470
et lui le plus fait
caractère agressif dans le jeu.

1438
01:10:35,470 --> 01:10:36,930
Donc, vous pouvez Google sur ce sujet.

1439
01:10:36,930 --> 01:10:39,380
Et ce fut, en effet, un
bug de programmation accidentelle,

1440
01:10:39,380 --> 01:10:43,010
mais ce n'est entré tout à fait
la tradition depuis.

1441
01:10:43,010 --> 01:10:44,360
>> C'est tout amusant et mignon.

1442
01:10:44,360 --> 01:10:47,760
Plus effrayant est quand même
dispositifs du monde réel, et non pas des jeux,

1443
01:10:47,760 --> 01:10:48,820
avoir ces mêmes insectes.

1444
01:10:48,820 --> 01:10:54,500
En fait, il y a un an un article est venu
à propos du Boeing 787 Dreamliner.

1445
01:10:54,500 --> 01:10:56,850
>> Et l'article au premier
coup d'oeil lit un peu mystérieux.

1446
01:10:56,850 --> 01:11:01,480
Mais il a dit cela, un logiciel
vulnérabilité dans Boeing

1447
01:11:01,480 --> 01:11:04,790
nouveau Dreamliner jet 787 a
le potentiel de causer des pilotes

1448
01:11:04,790 --> 01:11:07,220
perdre le contrôle de
l'aéronef, le cas échéant

1449
01:11:07,220 --> 01:11:11,750
à la mi-vol, les fonctionnaires de la FAA
compagnies aériennes a récemment averti.

1450
01:11:11,750 --> 01:11:14,520
Ce fut la détermination
qu'un modèle 787

1451
01:11:14,520 --> 01:11:19,770
avion qui a été alimenté
en continu pendant 248 jours

1452
01:11:19,770 --> 01:11:24,880
peut perdre tout courant alternatif, AC,
puissance électrique due au générateur

1453
01:11:24,880 --> 01:11:28,892
des unités de commande, CGU, simultanément
entrer dans le mode sans échec échec.

1454
01:11:28,892 --> 01:11:29,850
Il est une sorte de me perdre.

1455
01:11:29,850 --> 01:11:35,390
Mais le mémo a déclaré, OK, maintenant je suis que,
la condition est provoquée par un logiciel

1456
01:11:35,390 --> 01:11:38,590
Le compteur interne de
le contrôle du générateur

1457
01:11:38,590 --> 01:11:44,860
unités qui débordera après
248 jours de puissance continue.

1458
01:11:44,860 --> 01:11:47,070
Nous publions cette
remarquer pour prévenir la perte

1459
01:11:47,070 --> 01:11:49,300
Tout courant alternatif électrique
puissance, ce qui pourrait entraîner

1460
01:11:49,300 --> 01:11:50,980
la perte de contrôle de l'avion.

1461
01:11:50,980 --> 01:11:55,380
>> Donc, littéralement, il y a un certain nombre entier,
ou un certain type de données équivalent,

1462
01:11:55,380 --> 01:11:57,960
utilisé dans les logiciels
dans un avion réel

1463
01:11:57,960 --> 01:12:00,756
que si vous gardez votre avion
assez longtemps, qui, apparemment,

1464
01:12:00,756 --> 01:12:03,880
peut être le cas si vous êtes juste en cours d'exécution
les débrancher constamment et jamais

1465
01:12:03,880 --> 01:12:06,810
votre avion, il semble, ou
laissant ses batteries meurent,

1466
01:12:06,810 --> 01:12:09,840
finira par compter, et jusqu'à,
et, et, et, et vers le haut.

1467
01:12:09,840 --> 01:12:12,150
>> Et, par nature, un
quantité finie de mémoire

1468
01:12:12,150 --> 01:12:15,880
débordera, le retour à
zéro ou une valeur négative,

1469
01:12:15,880 --> 01:12:19,920
un effet secondaire qui est le
effroyablement réalité réelle

1470
01:12:19,920 --> 01:12:23,970
que le plan pourrait avoir besoin
être redémarré, efficacement,

1471
01:12:23,970 --> 01:12:27,290
ou pourrait tomber, pire, comme il vole.

1472
01:12:27,290 --> 01:12:29,230
Donc, ce genre de questions
sont toujours avec nous,

1473
01:12:29,230 --> 01:12:33,130
even-- ce fut un article 2015,
d'autant plus effrayant

1474
01:12:33,130 --> 01:12:36,100
quand vous faites pas nécessairement
comprendre, apprécier, ou d'anticiper

1475
01:12:36,100 --> 01:12:38,640
ces types d'erreurs.

1476
01:12:38,640 --> 01:12:42,030
>> Donc, il se trouve qu'il ya un autre
mauvaise chose à propos de la représentation des données.

1477
01:12:42,030 --> 01:12:47,080
Il se trouve que même les flotteurs sont
genre de défauts, parce que les flotteurs, aussi,

1478
01:12:47,080 --> 01:12:51,440
Je proposai de 32 bits, ou
peut-être 64 si vous utilisez un double.

1479
01:12:51,440 --> 01:12:53,070
Mais c'est encore finie.

1480
01:12:53,070 --> 01:12:57,070
>> Et le problème est que si vous le pouvez
mettre un nombre infini de nombres

1481
01:12:57,070 --> 01:12:59,460
après la virgule décimale,
il n'y a aucun moyen que vous

1482
01:12:59,460 --> 01:13:02,690
peut représenter tout le possible
chiffres qui nous ont appris

1483
01:13:02,690 --> 01:13:04,990
dans le grade école peut exister dans le monde.

1484
01:13:04,990 --> 01:13:08,870
Un ordinateur, en substance, doit
choisir un sous-ensemble de ces chiffres

1485
01:13:08,870 --> 01:13:10,200
pour représenter avec précision.

1486
01:13:10,200 --> 01:13:12,450
>> Maintenant, l'ordinateur peut
rond peut-être un peu,

1487
01:13:12,450 --> 01:13:17,900
et peut vous permettre d'environ magasin
tout numéro que vous pourriez probablement vouloir.

1488
01:13:17,900 --> 01:13:20,940
Mais intuitivement, si vous
un nombre fini de bits,

1489
01:13:20,940 --> 01:13:24,560
vous ne pouvez les permuter
à bien des égards finis.

1490
01:13:24,560 --> 01:13:26,570
Donc, vous ne pouvez pas peut-être
utiliser un nombre fini

1491
01:13:26,570 --> 01:13:29,880
de permutation de bits,
motifs de zéros et de uns,

1492
01:13:29,880 --> 01:13:32,940
pour représenter un infini
nombre de numéros,

1493
01:13:32,940 --> 01:13:37,370
ce qui suggère que les ordinateurs pourraient
très bien être de nous mentir parfois.

1494
01:13:37,370 --> 01:13:38,770
>> En fait, nous allons le faire.

1495
01:13:38,770 --> 01:13:41,239
Permettez-moi de revenir en CS50 IDE.

1496
01:13:41,239 --> 01:13:43,030
Laissez-moi aller de l'avant et
créer un petit programme

1497
01:13:43,030 --> 01:13:47,940
appelé Imprécision, pour montrer que
les ordinateurs sont, en effet, imprécis.

1498
01:13:47,940 --> 01:13:51,910
>> Et laissez-moi aller de l'avant et commencer par
une partie de ce code à partir d'avant,

1499
01:13:51,910 --> 01:13:53,830
et maintenant il suffit de faire ce qui suit.

1500
01:13:53,830 --> 01:14:03,640
Laissez-moi aller de l'avant et faire printf, pour cent
f, backslash n, 1 divisé par 10.

1501
01:14:03,640 --> 01:14:07,430
En d'autres termes, nous allons plonger plus profondément
à 1/10, comme 1 et divisé par 10.

1502
01:14:07,430 --> 01:14:09,760
Certes, un ordinateur peut représenter 1/10.

1503
01:14:09,760 --> 01:14:13,620
>> Donc, nous allons aller de l'avant et de faire l'imprécision.

1504
01:14:13,620 --> 01:14:14,390
Voyons voir.

1505
01:14:14,390 --> 01:14:16,210
Format spécifie le type double.

1506
01:14:16,210 --> 01:14:18,160
Mais l'argument est de type int.

1507
01:14:18,160 --> 01:14:19,040
Qu'est-ce qui se passe?

1508
01:14:19,040 --> 01:14:21,970
>> Oh, intéressant, il est donc un
leçon de devant.

1509
01:14:21,970 --> 01:14:26,050
Je veux dire, hé, salon de l'informatique
moi un flotteur avec pour cent f.

1510
01:14:26,050 --> 01:14:28,200
Mais je lui donne 2 ints.

1511
01:14:28,200 --> 01:14:31,120
Donc, il se trouve, je peux fixer
cela dans un couple des manières.

1512
01:14:31,120 --> 01:14:38,430
>> Je ne pouvais tout simplement tourner un dans 1.0, et
10 dans 10,0, ce qui serait, en effet,

1513
01:14:38,430 --> 01:14:42,390
ont pour effet de convertir
les en floats-- encore, espérons

1514
01:14:42,390 --> 01:14:43,180
le même numéro.

1515
01:14:43,180 --> 01:14:45,880
Ou il se trouve qu'il ya quelque chose
nous verrons à nouveau avant longtemps.

1516
01:14:45,880 --> 01:14:47,170
Vous pourriez lancer les numéros.

1517
01:14:47,170 --> 01:14:49,880
>> Vous pouvez, en utilisant cette parenthèse
expression, vous pouvez dire,

1518
01:14:49,880 --> 01:14:52,560
hey, ordinateur, prendre cette
10, que je connais est un int.

1519
01:14:52,560 --> 01:14:54,660
Mais le traiter, s'il vous plaît,
comme si elle est un flotteur.

1520
01:14:54,660 --> 01:14:56,680
Mais cela se sent inutilement complexe.

1521
01:14:56,680 --> 01:14:59,040
>> Pour nos besoins d'aujourd'hui,
disons simplement littéralement

1522
01:14:59,040 --> 01:15:02,700
rendent les valeurs à virgule flottante
avec un point décimal, comme celui-ci.

1523
01:15:02,700 --> 01:15:07,060
Laissez-moi aller de l'avant et relancez, fais
imprécision, bon, slash dot

1524
01:15:07,060 --> 01:15:08,870
imprécision, entrez.

1525
01:15:08,870 --> 01:15:10,990
OK, nous sommes à la recherche bonne.

1526
01:15:10,990 --> 01:15:18,194
>> 1 divisé par 10, selon mon
Mac ici, est, en effet, 0,100000.

1527
01:15:18,194 --> 01:15:21,360
Maintenant, on m'a enseigné à l'école primaire, il
devrait être un nombre infini de 0 de.

1528
01:15:21,360 --> 01:15:23,151
Donc, nous allons au moins essayer
de voir certains de ceux-ci.

1529
01:15:23,151 --> 01:15:26,770
Il se trouve que printf est un peu
encore plus sophistiqué que nous utilisons.

1530
01:15:26,770 --> 01:15:30,890
Il se trouve que vous ne devez pas spécifier
juste pour cent f, ou tout simplement pour cent i.

1531
01:15:30,890 --> 01:15:33,830
Vous pouvez réellement spécifier
certaines options de contrôle ici.

1532
01:15:33,830 --> 01:15:36,470
>> Plus précisément, je vais
à-dire, hé, printf,

1533
01:15:36,470 --> 01:15:39,660
me montrer en fait 10 points décimaux.

1534
01:15:39,660 --> 01:15:40,820
Donc, il semble un peu bizarre.

1535
01:15:40,820 --> 01:15:42,845
Mais vous dites pour cent,
point, combien de numéros

1536
01:15:42,845 --> 01:15:44,970
Voulez-vous voir après la
point décimal, puis f

1537
01:15:44,970 --> 01:15:48,340
pour plat, juste parce que ce
ce que dit la documentation.

1538
01:15:48,340 --> 01:15:50,080
Laissez-moi aller de l'avant et sauver ça.

1539
01:15:50,080 --> 01:15:52,460
>> Et remarque aussi, je suis en train de
fatigué de retaper les choses.

1540
01:15:52,460 --> 01:15:55,900
Donc, je suis juste mise en place et la
flèche vers le bas sur mes clés ici.

1541
01:15:55,900 --> 01:15:58,710
Et si je continue à frapper, vous
peut voir toutes les commandes

1542
01:15:58,710 --> 01:16:01,090
que je fait, ou mal fait.

1543
01:16:01,090 --> 01:16:04,630
>> Et je vais aller de l'avant dès maintenant et
pas vraiment l'utiliser, apparemment.

1544
01:16:04,630 --> 01:16:11,416
Faire imprécision, dot
slash imprecision-- donc

1545
01:16:11,416 --> 01:16:13,290
ce qu'on m'a appris à
l'école primaire vérifie.

1546
01:16:13,290 --> 01:16:19,010
Même si je l'imprime à 10 décimales
le place, en effet, est 0,10000.

1547
01:16:19,010 --> 01:16:19,840
Mais tu sais quoi?

1548
01:16:19,840 --> 01:16:21,150
>> Allons un peu gourmand.

1549
01:16:21,150 --> 01:16:23,990
Disons que, comme, montrez-moi 55
points après la virgule.

1550
01:16:23,990 --> 01:16:26,160
Nous allons vraiment prendre cette
programmer pour une rotation.

1551
01:16:26,160 --> 01:16:31,170
Permettez-moi de le refaire avec make
imprécision, slash dot, l'imprécision.

1552
01:16:31,170 --> 01:16:32,390
>> Et c'est reparti.

1553
01:16:32,390 --> 01:16:34,420
Votre enfance a été un mensonge.

1554
01:16:34,420 --> 01:16:48,410
Apparemment, 1 divisé par 10 est en effet
0.100000000000000005551115123--

1555
01:16:48,410 --> 01:16:49,740
>> Que se passe-t-il?

1556
01:16:49,740 --> 01:16:53,360
Eh bien, il se trouve, si vous genre de
regarder assez loin dans le sous-jacent

1557
01:16:53,360 --> 01:16:55,950
représentation de cette
nombre, il fait

1558
01:16:55,950 --> 01:17:00,400
est pas exactement 1/10, ou 0,1 et
un nombre infini de zéros.

1559
01:17:00,400 --> 01:17:01,630
Maintenant, pourquoi est-ce?

1560
01:17:01,630 --> 01:17:06,250
>> Eh bien, même si cela est un simple
numéro pour nous les humains, 1 divisé par 10,

1561
01:17:06,250 --> 01:17:10,910
il est toujours l'un des nombreux infiniment
numéros que nous pourrions imaginer.

1562
01:17:10,910 --> 01:17:14,490
Mais un ordinateur ne peut représenter
un nombre fini de nombres ainsi.

1563
01:17:14,490 --> 01:17:18,710
Et donc, effectivement, ce que le
ordinateur montre nous est son plus proche

1564
01:17:18,710 --> 01:17:22,940
approximation du nombre
nous voulons croire est 1/10,

1565
01:17:22,940 --> 01:17:27,760
ou vraiment ad infinitum 0,10000.

1566
01:17:27,760 --> 01:17:30,425
>> Au contraire, cependant, ceci est
aussi proche qu'il peut obtenir.

1567
01:17:30,425 --> 01:17:32,300
Et, en effet, si vous regardez
sous le capot,

1568
01:17:32,300 --> 01:17:37,050
que nous sommes ici en regardant
55 chiffres après la virgule,

1569
01:17:37,050 --> 01:17:39,990
on voit en fait que la réalité.

1570
01:17:39,990 --> 01:17:42,610
Maintenant, en passant, si vous avez
jamais vu le movie--

1571
01:17:42,610 --> 01:17:45,780
la plupart d'entre vous avez probablement haven't--
mais il y a Superman 3 quelques années,

1572
01:17:45,780 --> 01:17:49,500
Richard Pryor essentiellement exploité cette
la réalité dans son entreprise pour voler beaucoup

1573
01:17:49,500 --> 01:17:53,500
des fractions et des fractions de centimes,
parce que le company-- je me souviens bien,

1574
01:17:53,500 --> 01:17:57,210
il a été un while-- était essentiellement
jeter tout ce qui ne correspondait pas

1575
01:17:57,210 --> 01:17:58,790
dans la notion de cents.

1576
01:17:58,790 --> 01:18:01,480
>> Mais si vous ajoutez tous ces
minuscules, minuscules, chiffres minuscules encore,

1577
01:18:01,480 --> 01:18:04,960
et encore, et encore, vous pouvez, comme dans
son cas, faire un bon montant d'argent.

1578
01:18:04,960 --> 01:18:08,010
>> Cette même idée a été arraché par
une plus récente, mais encore maintenant plus âgés

1579
01:18:08,010 --> 01:18:10,500
film, appelé Office Space,
où les gars dans ce film,

1580
01:18:10,500 --> 01:18:13,501
fait la même chose, vissé vers le haut
complètement fini avec beaucoup trop

1581
01:18:13,501 --> 01:18:14,666
l'argent dans leur compte bancaire.

1582
01:18:14,666 --> 01:18:15,800
Tout cela était très suspect.

1583
01:18:15,800 --> 01:18:19,290
Mais à la fin de la journée,
imprécision est tout autour de nous.

1584
01:18:19,290 --> 01:18:22,240
>> Et cela, aussi, peut être
effroyablement le cas.

1585
01:18:22,240 --> 01:18:25,590
Il se trouve que Superman 3
et l'espace de bureau à part, il

1586
01:18:25,590 --> 01:18:28,460
peut être une très réelle
ramifications mondiales

1587
01:18:28,460 --> 01:18:32,290
des réalités imprécises
représentation des données

1588
01:18:32,290 --> 01:18:34,770
que même nous, les humains à
ce jour-là ne le font pas nécessairement

1589
01:18:34,770 --> 01:18:38,230
comprendre aussi bien que nous le devrions,
ou de se rappeler aussi souvent que nous le devrions.

1590
01:18:38,230 --> 01:18:42,950
Et, en effet, le clip suivant est
à partir d'un regard sur un monde très réel

1591
01:18:42,950 --> 01:18:47,730
ramifications de ce qui se passe si vous
ne pas apprécier l'imprécision

1592
01:18:47,730 --> 01:18:50,065
peut se produire dans la représentation des nombres.

1593
01:18:50,065 --> 01:18:51,300
>> [LECTURE VIDÉO]

1594
01:18:51,300 --> 01:18:55,620
>> -Ordinateurs, Nous avons tous appris à accepter
les problèmes souvent frustrant que

1595
01:18:55,620 --> 01:19:00,310
aller avec eux-- insectes, virus,
et des pépins logiciels,

1596
01:19:00,310 --> 01:19:03,130
pour les petits prix à payer
pour la commodité.

1597
01:19:03,130 --> 01:19:07,800
Mais dans la haute technologie et à haute vitesse
applications programme spatial militaire et,

1598
01:19:07,800 --> 01:19:12,800
le plus petit problème peut
être agrandie en cas de catastrophe.

1599
01:19:12,800 --> 01:19:18,900
>> Le 4 Juin 1996, les scientifiques préparés
de lancer une fusée Ariane 5 sans pilote.

1600
01:19:18,900 --> 01:19:21,220
Il transportait scientifique
satellites conçus

1601
01:19:21,220 --> 01:19:24,600
d'établir avec précision comment le
interagit champ magnétique terrestre

1602
01:19:24,600 --> 01:19:27,410
avec des vents solaires.

1603
01:19:27,410 --> 01:19:30,800
La fusée a été construit pour
l'Agence spatiale européenne,

1604
01:19:30,800 --> 01:19:34,370
et a décollé de son installation
sur la côte de la Guyane française.

1605
01:19:34,370 --> 01:19:37,540
>> -Au Environ 37 secondes dans
le vol, ils ont d'abord

1606
01:19:37,540 --> 01:19:39,270
quelque chose remarqué allait mal.

1607
01:19:39,270 --> 01:19:42,250
Les buses sont orientables dans
une façon qu'ils ne devraient pas vraiment.

1608
01:19:42,250 --> 01:19:46,580
Environ 40 secondes de vol,
clairement, le véhicule était en difficulté.

1609
01:19:46,580 --> 01:19:48,850
>> Et c'est quand ils ont fait
une décision de la détruire.

1610
01:19:48,850 --> 01:19:52,780
L'agent de sécurité de gamme, avec
d'énormes tripes, appuyé sur le bouton,

1611
01:19:52,780 --> 01:19:58,150
fait exploser la fusée, avant qu'il ne pourrait
devenir un danger pour la sécurité publique.

1612
01:19:58,150 --> 01:20:01,060
>> -Ce Était la jeune fille
voyage d'Ariane 5.

1613
01:20:01,060 --> 01:20:03,960
Et sa destruction a
placer en raison d'un défaut

1614
01:20:03,960 --> 01:20:05,822
intégré dans le logiciel de la fusée.

1615
01:20:05,822 --> 01:20:08,280
-Le Problème sur le lanceur Ariane était
qu'il y avait un nombre qui

1616
01:20:08,280 --> 01:20:10,600
64 bits requis pour exprimer.

1617
01:20:10,600 --> 01:20:13,590
Et ils ont voulu convertir
à un certain nombre de 16 bits.

1618
01:20:13,590 --> 01:20:15,610
Ils ont supposé que le
nombre n'a jamais été va

1619
01:20:15,610 --> 01:20:20,980
être très grand, que la plupart de ceux
chiffres dans un nombre de 64 bits sont des zéros.

1620
01:20:20,980 --> 01:20:22,440
Ils avaient tord.

1621
01:20:22,440 --> 01:20:25,060
>> -la Une incapacité
Programme logiciel pour accepter

1622
01:20:25,060 --> 01:20:29,510
le genre de numéro généré par
un autre était à l'origine de l'échec.

1623
01:20:29,510 --> 01:20:34,350
Le développement de logiciels était devenu un
partie très coûteuse de la nouvelle technologie.

1624
01:20:34,350 --> 01:20:38,140
La fusée Ariane a été très
couronnée de succès, tant du logiciel

1625
01:20:38,140 --> 01:20:41,550
créé pour elle était aussi
utilisé dans l'Ariane 5.

1626
01:20:41,550 --> 01:20:47,940
>> -Le Problème de base est que le lanceur Ariane
5 était plus rapide, accéléré plus rapidement.

1627
01:20:47,940 --> 01:20:51,450
Et le logiciel avait pas
comptabilisés pour cela.

1628
01:20:51,450 --> 01:20:55,060
>> -La Destruction de la fusée
a été un énorme désastre financier,

1629
01:20:55,060 --> 01:20:58,790
dû à une erreur logicielle minutes.

1630
01:20:58,790 --> 01:21:01,210
Mais ce ne fut pas le premier
temps des problèmes de conversion de données

1631
01:21:01,210 --> 01:21:04,820
avait en proie à la technologie des fusées modernes.

1632
01:21:04,820 --> 01:21:08,050
>> -En 1991, avec le début
de la première guerre du Golfe,

1633
01:21:08,050 --> 01:21:10,570
le Patriot missiles
connu le même genre

1634
01:21:10,570 --> 01:21:12,800
du problème de conversion de nombre.

1635
01:21:12,800 --> 01:21:16,090
Et en conséquence, 28 personnes,
28 soldats américains,

1636
01:21:16,090 --> 01:21:19,080
ont été tués et environ
100 autres blessés,

1637
01:21:19,080 --> 01:21:22,780
lorsque le Patriot, qui était censé
pour protéger contre les gammares entrants,

1638
01:21:22,780 --> 01:21:25,830
pas tirer un missile.

1639
01:21:25,830 --> 01:21:31,670
>> -Lorsque L'Irak a envahi le Koweït, et en Amérique
lancé Desert Storm au début de 1991,

1640
01:21:31,670 --> 01:21:35,780
batteries Patriot missiles ont été déployés
pour protéger l'Arabie Saoudite et Israël

1641
01:21:35,780 --> 01:21:39,230
d'Irak des attaques de missiles Scud.

1642
01:21:39,230 --> 01:21:43,810
Le Patriot est un milieu de gamme US
surface à système d'air, fabriqué

1643
01:21:43,810 --> 01:21:45,770
par la société Raytheon.

1644
01:21:45,770 --> 01:21:52,340
>> -La Taille de l'intercepteur Patriot
lui-même est d'environ environ 20 pieds de long.

1645
01:21:52,340 --> 01:21:55,230
Et il pèse environ 2000 livres.

1646
01:21:55,230 --> 01:21:59,320
Et il porte une ogive d'environ,
Je pense qu'il est à peu près 150 livres.

1647
01:21:59,320 --> 01:22:03,930
Et la charge militaire est lui-même
un explosif, qui

1648
01:22:03,930 --> 01:22:07,330
a des fragments autour de lui.

1649
01:22:07,330 --> 01:22:11,680
L'enveloppe de la tête militaire est
conçu pour agir comme chevrotines.

1650
01:22:11,680 --> 01:22:14,110
>> -Les Missiles sont portés
quatre par conteneur,

1651
01:22:14,110 --> 01:22:17,130
et sont transportés par une semi-remorque.

1652
01:22:17,130 --> 01:22:24,930
>> -Le Système Patriot anti-missile
remonte au moins 20 ans.

1653
01:22:24,930 --> 01:22:28,420
Il a été conçu à l'origine
comme un missile de défense aérienne

1654
01:22:28,420 --> 01:22:30,720
pour abattre des avions ennemis.

1655
01:22:30,720 --> 01:22:34,500
Dans la première guerre du Golfe,
lorsque cette guerre est arrivée,

1656
01:22:34,500 --> 01:22:39,745
l'armée voulait l'utiliser pour
abattre gammares, pas des avions.

1657
01:22:39,745 --> 01:22:43,620
>> La Force aérienne irakienne était
non pas tant d'un problème.

1658
01:22:43,620 --> 01:22:46,670
Mais l'armée était inquiet à propos de gammares.

1659
01:22:46,670 --> 01:22:50,170
Et donc ils ont essayé de
mettre à niveau le Patriot.

1660
01:22:50,170 --> 01:22:52,800
>> -Intercepting Un ennemi
missile voyage à mach 5

1661
01:22:52,800 --> 01:22:55,830
allait être assez difficile.

1662
01:22:55,830 --> 01:22:58,490
Mais quand le Patriot
a été transporté en service,

1663
01:22:58,490 --> 01:23:02,860
l'armée n'a pas connaissance d'un
modification irakienne qui a fait

1664
01:23:02,860 --> 01:23:05,930
leurs gammares presque impossible de frapper.

1665
01:23:05,930 --> 01:23:10,740
>> -Quel Est arrivé les gammares que
venaient en étaient instables.

1666
01:23:10,740 --> 01:23:11,692
Ils ont été vacillant.

1667
01:23:11,692 --> 01:23:14,910
La raison de ceci était
les Irakiens, afin

1668
01:23:14,910 --> 01:23:18,280
pour obtenir 600 kilomètres
sur un 300 km

1669
01:23:18,280 --> 01:23:21,700
missile à portée, a pris du poids
de la tête militaire avant.

1670
01:23:21,700 --> 01:23:23,390
Ils ont fait l'ogive plus léger.

1671
01:23:23,390 --> 01:23:27,330
>> Alors maintenant, le Patriot est
en essayant de venir au Scud.

1672
01:23:27,330 --> 01:23:30,230
Et la plupart du temps, la
écrasante majorité du temps,

1673
01:23:30,230 --> 01:23:32,940
il serait juste voler par le Scud.

1674
01:23:32,940 --> 01:23:37,260
Une fois que les opérateurs du système Patriot
a réalisé le Patriot a raté sa cible,

1675
01:23:37,260 --> 01:23:41,690
ils ont fait exploser la tête du Patriot
pour éviter les pertes possibles si elle

1676
01:23:41,690 --> 01:23:44,570
a été autorisé à tomber sur le sol.

1677
01:23:44,570 --> 01:23:48,790
>> -Que Est ce que la plupart des gens ont vu,
ces grosses boules de feu dans le ciel,

1678
01:23:48,790 --> 01:23:54,550
et mal compris, comme
intercepts d'ogives Scud.

1679
01:23:54,550 --> 01:23:56,630
>> -Bien Dans la nuit
ciel, Patriots est apparu

1680
01:23:56,630 --> 01:24:00,370
être avec succès
détruire Scuds, à Dhahran,

1681
01:24:00,370 --> 01:24:03,360
il pourrait y avoir aucune erreur
sur ses performances.

1682
01:24:03,360 --> 01:24:07,970
Là, le système radar de la Patriot
perdu la trace d'un Scud entrant,

1683
01:24:07,970 --> 01:24:10,721
et jamais lancé en raison
à un défaut de logiciel.

1684
01:24:10,721 --> 01:24:14,090

1685
01:24:14,090 --> 01:24:18,940
Ce sont les Israéliens qui découvrit le premier
que plus le système était allumé,

1686
01:24:18,940 --> 01:24:22,690
plus l'écart de temps
est devenue, grâce à une horloge incorporée

1687
01:24:22,690 --> 01:24:24,810
dans l'ordinateur du système.

1688
01:24:24,810 --> 01:24:28,210
>> -Environ Deux semaines avant
la tragédie à Dhahran,

1689
01:24:28,210 --> 01:24:30,770
les Israéliens ont déclaré à
le Département de la Défense

1690
01:24:30,770 --> 01:24:32,590
que le système était en train de perdre du temps.

1691
01:24:32,590 --> 01:24:35,360
Après environ huit heures ou en cours d'exécution,
ils ont remarqué que le système

1692
01:24:35,360 --> 01:24:37,720
devenait nettement moins précis.

1693
01:24:37,720 --> 01:24:41,900
Le Département de la Défense a répondu par
dire toutes les batteries Patriot

1694
01:24:41,900 --> 01:24:44,950
de ne pas laisser les systèmes
pendant une longue période.

1695
01:24:44,950 --> 01:24:49,160
Ils ne disaient jamais ce que longtemps était--
huit heures, 10 heures, 1000 heures.

1696
01:24:49,160 --> 01:24:51,360
Personne ne savait.

1697
01:24:51,360 --> 01:24:53,380
>> -La Batterie Patriot
stationné à la caserne

1698
01:24:53,380 --> 01:24:58,350
à Dhahran et ses défauts internes
horloge avait été sur plus de 100 heures

1699
01:24:58,350 --> 01:25:01,670
dans la nuit du 25 Février.

1700
01:25:01,670 --> 01:25:05,917
>> -Il Suivis le temps d'une précision
d'environ un dixième de seconde.

1701
01:25:05,917 --> 01:25:08,000
Or, un dixième de seconde,
est un nombre intéressant,

1702
01:25:08,000 --> 01:25:11,920
parce qu'il ne peut pas être exprimé
exactement en binaire, qui

1703
01:25:11,920 --> 01:25:16,820
signifie qu'il ne peut pas être exprimé exactement
dans un ordinateur numérique moderne.

1704
01:25:16,820 --> 01:25:18,540
C'est dur à croire.

1705
01:25:18,540 --> 01:25:21,210
>> Mais l'utiliser comme un exemple.

1706
01:25:21,210 --> 01:25:23,540
Prenons le numéro un tiers.

1707
01:25:23,540 --> 01:25:27,350
Un tiers ne peut pas être
exprimée en décimal exactement.

1708
01:25:27,350 --> 01:25:32,080
Un tiers est 0,333
passe pour l'infini.

1709
01:25:32,080 --> 01:25:36,480
>> Il n'y a aucun moyen de le faire avec
précision absolue en décimal.

1710
01:25:36,480 --> 01:25:39,560
Voilà exactement le genre de problème
cela est arrivé dans le Patriot.

1711
01:25:39,560 --> 01:25:44,100
Plus le système a la
pire erreur de temps est devenu.

1712
01:25:44,100 --> 01:25:48,890
>> -Après 100 heures de fonctionnement, la
erreur dans le temps était seulement environ un tiers

1713
01:25:48,890 --> 01:25:50,600
d'une seconde.

1714
01:25:50,600 --> 01:25:54,210
Mais en termes de ciblage d'un
missile se déplaçant à mach 5,

1715
01:25:54,210 --> 01:25:58,710
il a donné lieu à un suivi
erreur de plus de 600 mètres.

1716
01:25:58,710 --> 01:26:02,120
Ce serait une erreur fatale
pour les soldats sur ce

1717
01:26:02,120 --> 01:26:08,940
des événements est un lancement Scud était
détecté par les satellites d'alerte précoce

1718
01:26:08,940 --> 01:26:12,860
et ils savaient que le Scud était
venant dans leur direction générale.

1719
01:26:12,860 --> 01:26:15,320
Ils ne savaient pas d'où il venait.

1720
01:26:15,320 --> 01:26:18,250
>> -C'était Maintenant au radar
composant du système Patriot

1721
01:26:18,250 --> 01:26:23,190
défendre Dhahran pour localiser et garder
piste du missile ennemi entrant.

1722
01:26:23,190 --> 01:26:24,609
>> -Le Radar était très intelligent.

1723
01:26:24,609 --> 01:26:26,650
Il serait en fait suivre
la position du Scud,

1724
01:26:26,650 --> 01:26:30,350
puis prédire où il a probablement
serait la prochaine fois que le radar envoyé

1725
01:26:30,350 --> 01:26:31,420
une impulsion sur.

1726
01:26:31,420 --> 01:26:33,110
Cela a été appelé une porte de gamme.

1727
01:26:33,110 --> 01:26:37,660
>> -Ensuite, Une fois que le Patriot
décide assez de temps a

1728
01:26:37,660 --> 01:26:42,450
passé à revenir en arrière et vérifier le prochain
emplacement pour cet objet détecté,

1729
01:26:42,450 --> 01:26:43,600
il remonte.

1730
01:26:43,600 --> 01:26:48,650
Alors, quand il est retourné à la mauvaise
lieu, il voit alors aucun objet.

1731
01:26:48,650 --> 01:26:52,160
Et il décide qu'il n'y a pas
objet, il était une fausse détection,

1732
01:26:52,160 --> 01:26:53,930
et laisse tomber la piste.

1733
01:26:53,930 --> 01:26:57,030
>> -Le Entrant Scud a disparu
à partir de l'écran radar.

1734
01:26:57,030 --> 01:27:00,260
Et quelques secondes plus tard, il
claqué dans les casernes.

1735
01:27:00,260 --> 01:27:06,150
Le Scud a tué 28, et a été le dernier
un tiré au cours de la première guerre du Golfe.

1736
01:27:06,150 --> 01:27:11,960
>> Tragiquement, le logiciel mis à jour
arrivé à Dhahran le lendemain.

1737
01:27:11,960 --> 01:27:14,930
La faille du logiciel avait
été fixée, la fermeture

1738
01:27:14,930 --> 01:27:19,806
un chapitre dans le trouble
l'histoire du missile Patriot.

1739
01:27:19,806 --> 01:27:20,729
>> [LECTURE VIDÉO]

1740
01:27:20,729 --> 01:27:23,520
DAVID J. Malan: Donc, tout cela est à
dire que ces questions de débordement

1741
01:27:23,520 --> 01:27:25,860
et l'imprécision sont trop réel.

1742
01:27:25,860 --> 01:27:26,920
Alors, comment sommes-nous arrivés là?

1743
01:27:26,920 --> 01:27:28,895
Nous avons commencé avec juste parler de printf.

1744
01:27:28,895 --> 01:27:31,270
Encore une fois, cette fonction
imprime quelque chose à l'écran,

1745
01:27:31,270 --> 01:27:33,450
et nous avons introduit la suite
quelques autres fonctions

1746
01:27:33,450 --> 01:27:34,945
de la bibliothèque que l'on appelle de CS50.

1747
01:27:34,945 --> 01:27:36,910
Et nous allons continuer à
voir ces en temps voulu.

1748
01:27:36,910 --> 01:27:40,760
Et nous, en particulier, utilisé chaîne get,
et obtenir int, et maintenant également obtenir flotteur,

1749
01:27:40,760 --> 01:27:44,410
et d'autres encore seront toujours nous rencontrer
et de nous utiliser avant longtemps.

1750
01:27:44,410 --> 01:27:47,220
>> Mais à l'occasion,
nous avons déjà vu un besoin

1751
01:27:47,220 --> 01:27:50,520
pour stocker ce que ces fonctions main en arrière?

1752
01:27:50,520 --> 01:27:52,920
Ils nous renvoient une chaîne part,
ou un int, ou un flotteur.

1753
01:27:52,920 --> 01:27:56,070
Et parfois, nous avons besoin de mettre ce
string ou int, ou float, quelque part.

1754
01:27:56,070 --> 01:28:00,100
>> Et pour stocker ces choses, rappeler simplement
comme dans Scratch, nous avons des variables.

1755
01:28:00,100 --> 01:28:03,260
Mais contrairement à Scratch,
en C, nous avons les types réels

1756
01:28:03,260 --> 01:28:05,530
des données variables--
types, plus generally--

1757
01:28:05,530 --> 01:28:08,640
parmi eux, une chaîne, un int, un
flotter, et ces autres encore.

1758
01:28:08,640 --> 01:28:12,321
>> Et donc quand nous déclarons variables C,
nous devons déclarer nos types de données.

1759
01:28:12,321 --> 01:28:14,820
Cela ne veut pas quelque chose que nous
avoir à faire plus tard dans le semestre

1760
01:28:14,820 --> 01:28:16,810
que nous passons à d'autres langues.

1761
01:28:16,810 --> 01:28:19,610
Mais pour l'instant, nous devons
a priori à l'avance,

1762
01:28:19,610 --> 01:28:24,370
expliquer à l'ordinateur quel type
de la variable que nous voulons qu'elle nous donne.

1763
01:28:24,370 --> 01:28:27,290
>> Maintenant, quant à lui, d'imprimer
ce genre de types de données,

1764
01:28:27,290 --> 01:28:29,570
nous devons dire printf à quoi nous attendre.

1765
01:28:29,570 --> 01:28:32,450
Et nous avons vu pour cent s pour les chaînes,
et pour les nombres entiers i pour cent,

1766
01:28:32,450 --> 01:28:33,790
et quelques autres déjà.

1767
01:28:33,790 --> 01:28:37,237
Et ce sont tout simplement les exigences
pour la présentation visuelle

1768
01:28:37,237 --> 01:28:38,070
de cette information.

1769
01:28:38,070 --> 01:28:42,080
>> Et chacun d'eux peut effectivement être
paramétrés ou tordu d'une certaine façon,

1770
01:28:42,080 --> 01:28:45,370
si vous voulez poursuivre le contrôle
le type de sortie que vous obtenez.

1771
01:28:45,370 --> 01:28:49,604
Et, en fait, il se trouve que non seulement
est là backslash n pour une nouvelle ligne.

1772
01:28:49,604 --> 01:28:52,520
Il y a quelque chose d'autre appelé backslash
r pour un retour chariot, qui

1773
01:28:52,520 --> 01:28:54,360
est plus proche d'un
vieille machine à écrire à l'école,

1774
01:28:54,360 --> 01:28:57,690
ainsi que Windows utilisé depuis de nombreuses années.

1775
01:28:57,690 --> 01:28:59,690
>> Il y a t backslash pour les onglets.

1776
01:28:59,690 --> 01:29:03,170
Il s'avère, que si vous voulez
guillemet à l'intérieur d'une chaîne,

1777
01:29:03,170 --> 01:29:05,000
rappel que nous avons utilisé
guillemets doubles

1778
01:29:05,000 --> 01:29:07,900
devis sur la gauche et la droite
les extrémités de nos cordes jusqu'ici.

1779
01:29:07,900 --> 01:29:09,420
Cela semble confondre les choses.

1780
01:29:09,420 --> 01:29:12,503
>> Si vous voulez mettre une double citation dans
au milieu d'une string-- et, en fait,

1781
01:29:12,503 --> 01:29:13,670
il est déroutant de voir.

1782
01:29:13,670 --> 01:29:17,120
Et donc vous devez échapper, pour ainsi
dire, une double citation avec quelque chose

1783
01:29:17,120 --> 01:29:18,860
comme, littéralement, backslasher guillemets doubles.

1784
01:29:18,860 --> 01:29:20,230
Et il y a quelques autres encore.

1785
01:29:20,230 --> 01:29:24,540
Et nous allons voir plus de ceux
en utilisation réelle avant longtemps.

1786
01:29:24,540 --> 01:29:27,930
>> Donc, nous allons maintenant de transition
données, et la représentation,

1787
01:29:27,930 --> 01:29:30,820
et les opérateurs arithmétiques, tous
qui nous a donné un certain bâtiment

1788
01:29:30,820 --> 01:29:32,070
blocs avec lesquels jouer.

1789
01:29:32,070 --> 01:29:34,481
Mais maintenant, nous allons donner effectivement
nous le reste du vocabulaire

1790
01:29:34,481 --> 01:29:36,230
que nous avions déjà
la semaine dernière avec Scratch

1791
01:29:36,230 --> 01:29:39,350
en prenant un coup d'oeil à un autre
constructions en C-- pas tous d'entre eux.

1792
01:29:39,350 --> 01:29:41,680
Mais les idées nous sommes
sur le point de voir vraiment juste

1793
01:29:41,680 --> 01:29:45,610
mettre l'accent sur la traduction de
une langue, Scratch, à un autre, C.

1794
01:29:45,610 --> 01:29:48,470
>> Et au fil du temps, nous allons chercher
plus d'outils pour notre boîte à outils,

1795
01:29:48,470 --> 01:29:49,820
pour ainsi dire, syntaxiquement.

1796
01:29:49,820 --> 01:29:54,190
Et, en effet, vous verrez que les idées
sont maintenant plutôt familiers de la semaine dernière.

1797
01:29:54,190 --> 01:29:55,200
Donc, nous allons le faire.

1798
01:29:55,200 --> 01:29:58,870
>> Allons de l'avant et de concocter un programme
qui utilise effectivement quelques expressions,

1799
01:29:58,870 --> 01:30:00,720
une expression booléenne.

1800
01:30:00,720 --> 01:30:02,810
Laissez-moi aller de l'avant ici
et de créer un nouveau fichier.

1801
01:30:02,810 --> 01:30:06,090
Je vais appeler ce condition.c.

1802
01:30:06,090 --> 01:30:09,350
>> Laissez-moi aller de l'avant et
inclure la bibliothèque CS50.

1803
01:30:09,350 --> 01:30:12,640
Et laissez-moi aller de l'avant et inclure
norme io.h pour nos fonctions,

1804
01:30:12,640 --> 01:30:14,690
et printf, et plus, respectivement.

1805
01:30:14,690 --> 01:30:18,900
Permettez-moi de me donner que des passe-partout
void main int, dont l'explication nous allons

1806
01:30:18,900 --> 01:30:20,360
revenir à l'avenir.

1807
01:30:20,360 --> 01:30:23,820
>> Maintenant, laissez-moi aller de l'avant et donner
moi un int via get int.

1808
01:30:23,820 --> 01:30:25,970
Alors laissez-moi aller de l'avant et de faire cela.

1809
01:30:25,970 --> 01:30:30,150
Je veux dire si i est less-- nous allons
distinction entre positif, négatif,

1810
01:30:30,150 --> 01:30:31,260
ou des valeurs nulles.

1811
01:30:31,260 --> 01:30:36,630
>> Donc, si i est inférieur à zéro, laissez-moi
ont tout simplement ce programme simplement dire,

1812
01:30:36,630 --> 01:30:42,370
négative, backslash n, d'autre
si i est supérieur à zéro.

1813
01:30:42,370 --> 01:30:47,030
Maintenant, je suis, bien sûr, va dire
printf positif, backslash n.

1814
01:30:47,030 --> 01:30:50,690
Et puis d'autre si-- je pouvais le faire.

1815
01:30:50,690 --> 01:30:53,410
>> Je pourrais faire si i est égal à 0.

1816
01:30:53,410 --> 01:30:55,840
Mais je serais fais à
moins une erreur déjà.

1817
01:30:55,840 --> 01:30:59,480
Rappelons que le signe égal est
pas égaux, que nous, les humains le savent.

1818
01:30:59,480 --> 01:31:01,010
>> Mais il est l'opérateur d'affectation.

1819
01:31:01,010 --> 01:31:05,640
Et nous ne voulons pas prendre 0 sur le
droit et le mettre dans i à gauche.

1820
01:31:05,640 --> 01:31:11,810
Donc, pour éviter cette confusion, ou
peut-être une mauvaise utilisation du signe égal,

1821
01:31:11,810 --> 01:31:14,740
l'homme a décidé il y a quelques années
que dans de nombreux langages de programmation

1822
01:31:14,740 --> 01:31:18,000
lorsque vous souhaitez vérifier l'égalité
entre la gauche et la droite,

1823
01:31:18,000 --> 01:31:19,635
vous utilisez réellement égal à égal.

1824
01:31:19,635 --> 01:31:21,010
Donc, vous frappez le signe égal à deux reprises.

1825
01:31:21,010 --> 01:31:25,600
Lorsque vous souhaitez affecter de droite
à gauche, vous utilisez un seul signe égal.

1826
01:31:25,600 --> 01:31:29,360
Donc, nous pourrions faire d'autre this--
si i est égal à égal à zéro.

1827
01:31:29,360 --> 01:31:31,710
>> Je pourrais alors aller
ouvrir mes accolades,

1828
01:31:31,710 --> 01:31:36,087
et dire, printf 0, backslash n, fait.

1829
01:31:36,087 --> 01:31:38,170
Mais rappelez-vous comment ces
bifurcations peuvent travailler.

1830
01:31:38,170 --> 01:31:39,836
Et, vraiment, il suffit de penser à la logique.

1831
01:31:39,836 --> 01:31:41,510
i est un nombre.

1832
01:31:41,510 --> 01:31:43,320
Il est un entier, en particulier.

1833
01:31:43,320 --> 01:31:48,600
Et cela signifie que ça va être moins
à 0 ou supérieur à 0, ou 0.

1834
01:31:48,600 --> 01:31:51,600
Donc, il est en quelque sorte de cette
cas de défaut implicite.

1835
01:31:51,600 --> 01:31:54,920
>> Et pour que nous puissions, juste comme
Scratch, passer de l'autre si,

1836
01:31:54,920 --> 01:31:55,747
et juste dire d'autre.

1837
01:31:55,747 --> 01:31:57,830
Logiquement, si vous le
programmeur sais qu'il ya seulement

1838
01:31:57,830 --> 01:32:01,635
trois godets dans lesquels un
scénario peut fall-- la première,

1839
01:32:01,635 --> 01:32:03,510
le deuxième, le troisième ou
dans ce case-- ne le font pas

1840
01:32:03,510 --> 01:32:07,100
la peine d'ajouter la précision supplémentaire
et la logique supplémentaire là.

1841
01:32:07,100 --> 01:32:09,690
Il suffit d'aller de l'avant avec la
cas ici d'autre par défaut.

1842
01:32:09,690 --> 01:32:11,950
>> Maintenant, nous allons aller de l'avant
après avoir enregistré cela, assurez

1843
01:32:11,950 --> 01:32:15,760
conditions dot slash conditions--
pas une grande interface utilisateur,

1844
01:32:15,760 --> 01:32:18,914
parce que je ne suis pas incité le
utilisateur, comme je l'ai mentionné plus tôt.

1845
01:32:18,914 --> 01:32:19,580
Mais ça va.

1846
01:32:19,580 --> 01:32:20,454
Nous allons garder les choses simples.

1847
01:32:20,454 --> 01:32:21,890
Essayons le nombre 42.

1848
01:32:21,890 --> 01:32:23,240
Et c'est positif.

1849
01:32:23,240 --> 01:32:26,120
Essayons le nombre
négative 42, négative.

1850
01:32:26,120 --> 01:32:28,244
>> Essayons la valeur 0.

1851
01:32:28,244 --> 01:32:29,160
Et, en effet, cela fonctionne.

1852
01:32:29,160 --> 01:32:33,900
Maintenant, vous verrez des problèmes avant
longues, des choses de test à trois reprises,

1853
01:32:33,900 --> 01:32:34,980
probablement pas suffisante.

1854
01:32:34,980 --> 01:32:37,438
Vous voudrez probablement tester certains
plus grand nombre, certains petits

1855
01:32:37,438 --> 01:32:40,520
numéros, certains cas de coin, comme
nous venons de les décrire.

1856
01:32:40,520 --> 01:32:42,500
>> Mais pour l'instant, ceci est un
assez simple programme.

1857
01:32:42,500 --> 01:32:45,160
Et je suis assez sûr, logiquement,
qu'il tombe dans trois cas.

1858
01:32:45,160 --> 01:32:49,360
Et, en effet, même si nous venons de
mis l'accent sur les inconvénients potentiels

1859
01:32:49,360 --> 01:32:53,480
d'imprécision et de débordement,
réalité où de nombreux problèmes de CS50,

1860
01:32:53,480 --> 01:32:56,000
on ne va pas à vous soucier
à propos, tout le temps,

1861
01:32:56,000 --> 01:32:59,050
ces questions de débordement et
imprécision, parce que, en fait, en C,

1862
01:32:59,050 --> 01:33:01,889
il est en fait pas du tout
facile d'éviter ces choses.

1863
01:33:01,889 --> 01:33:04,180
Si vous voulez compter jusqu'à
plus grand, et plus grand, et plus grand,

1864
01:33:04,180 --> 01:33:07,510
il se trouve qu'il existe des techniques vous
peut utiliser, impliquant souvent des choses appelées

1865
01:33:07,510 --> 01:33:11,240
bibliothèques, collections de code, que
d'autres personnes ont écrit que vous pouvez utiliser,

1866
01:33:11,240 --> 01:33:13,910
et d'autres langues comme
Java et autres, en fait

1867
01:33:13,910 --> 01:33:15,800
rendre beaucoup plus facile
compter encore plus élevé.

1868
01:33:15,800 --> 01:33:19,810
Donc, il est vraiment certains de ces dangers
en fonction de la langue que vous utilisez.

1869
01:33:19,810 --> 01:33:22,710
Et dans les prochaines semaines, nous allons
voir comment dangereux C vraiment

1870
01:33:22,710 --> 01:33:24,950
peut être si vous ne l'utilisez pas correctement.

1871
01:33:24,950 --> 01:33:27,610
Mais à partir de là, et
Python et JavaScript, sera

1872
01:33:27,610 --> 01:33:32,620
nous couche sur des protections supplémentaires,
et courir moins de ces risques.

1873
01:33:32,620 --> 01:33:35,820
>> Faisons donc un peu plus
logique intéressant dans notre programme.

1874
01:33:35,820 --> 01:33:39,110
Alors laissez-moi aller de l'avant et de créer
un programme appelé logique

1875
01:33:39,110 --> 01:33:43,804
juste pour que je peux jouer avec certains
la logique réelle logical.c.

1876
01:33:43,804 --> 01:33:46,870
Je vais copier et coller un peu
code à partir plus tôt afin que je revienne

1877
01:33:46,870 --> 01:33:49,950
à ce joli point de départ.

1878
01:33:49,950 --> 01:33:53,980
>> Permettez-moi de faire cette fois C. omble Je suis
va lui donner un nom de C

1879
01:33:53,980 --> 01:33:58,510
juste parce qu'il est classique,
obtenir un personnage de l'utilisateur.

1880
01:33:58,510 --> 01:34:00,730
Et supposons que
Je suis en œuvre une partie

1881
01:34:00,730 --> 01:34:04,130
de ce programme de Rm, le supprimer
programme avant qui a incité l'utilisateur

1882
01:34:04,130 --> 01:34:05,400
de supprimer un fichier.

1883
01:34:05,400 --> 01:34:06,750
Comment pourrions-nous faire cela?

1884
01:34:06,750 --> 01:34:11,090
>> Je veux dire, si C est égal à
égal à égal, entre guillemets,

1885
01:34:11,090 --> 01:34:16,304
y, alors je vais assumer
que l'utilisateur a choisi oui.

1886
01:34:16,304 --> 01:34:17,470
Je vais juste imprimer oui.

1887
01:34:17,470 --> 01:34:19,440
Si elle était effectivement en train d'écrire
le programme d'enlèvement,

1888
01:34:19,440 --> 01:34:21,420
nous pourrions supprimer le fichier
avec plus de lignes de code.

1889
01:34:21,420 --> 01:34:22,461
Mais nous allons garder les choses simples.

1890
01:34:22,461 --> 01:34:25,950

1891
01:34:25,950 --> 01:34:31,250
>> Sinon, si c est égal à égal à n--
et maintenant ici, je vais dire,

1892
01:34:31,250 --> 01:34:32,980
l'utilisateur doit avoir signifié pas.

1893
01:34:32,980 --> 01:34:34,360
Et puis d'autre, vous savez quoi?

1894
01:34:34,360 --> 01:34:36,200
Je ne sais pas quoi d'autre
l'utilisateur va taper.

1895
01:34:36,200 --> 01:34:38,533
Donc, je vais juste dire que
qui est une erreur, quelle que soit

1896
01:34:38,533 --> 01:34:40,070
il ou elle a effectivement tapé.

1897
01:34:40,070 --> 01:34:41,180
>> Alors qu'est-ce qui se passe ici?

1898
01:34:41,180 --> 01:34:44,530
Il y a une différence fondamentale
par rapport à ce que je l'ai fait dans le passé.

1899
01:34:44,530 --> 01:34:49,300
Les guillemets doubles, guillemets doubles, double
citations, et, pourtant, des guillemets simples,

1900
01:34:49,300 --> 01:34:50,170
apostrophes.

1901
01:34:50,170 --> 01:34:52,860
Il se trouve en C, que lorsque
vous voulez écrire une chaîne,

1902
01:34:52,860 --> 01:34:56,680
vous utilisez des guillemets, tout comme nous avons
été en utilisant tout ce temps avec printf.

1903
01:34:56,680 --> 01:35:02,030
>> Mais si vous voulez traiter avec juste un
seul caractère, un caractère soi-disant,

1904
01:35:02,030 --> 01:35:03,780
alors vous utilisez réellement des guillemets simples.

1905
01:35:03,780 --> 01:35:05,450
Ceux d'entre vous qui ont programmé
avant, vous pourriez ne pas avoir

1906
01:35:05,450 --> 01:35:07,850
eu à se soucier de cette
distinction dans certaines langues.

1907
01:35:07,850 --> 01:35:09,450
En C, il importe.

1908
01:35:09,450 --> 01:35:12,560
Et quand je reçois un caractère et je veux
pour comparer ce que l'omble utilisant égaux

1909
01:35:12,560 --> 01:35:18,350
équivaut à quelque lettre comme y ou n, je fais,
en effet, besoin d'avoir les guillemets simples.

1910
01:35:18,350 --> 01:35:19,770
>> Maintenant, nous allons aller de l'avant et de faire cela.

1911
01:35:19,770 --> 01:35:26,180
Allons de l'avant et ne font
dot logiques slash logique.

1912
01:35:26,180 --> 01:35:27,305
Et maintenant, je suis être invité.

1913
01:35:27,305 --> 01:35:30,638
Alors, sans doute, une meilleure expérience utilisateur
serait en fait me dire ce qu'il faut faire ici.

1914
01:35:30,638 --> 01:35:33,030
Mais je vais aveuglément
y dire pour oui, OK, bien.

1915
01:35:33,030 --> 01:35:35,780
>> Courons à nouveau, n pour non, agréable.

1916
01:35:35,780 --> 01:35:39,610
Supposons que certaines personnes que je connais,
mes verrouillage des majuscules est trop souvent.

1917
01:35:39,610 --> 01:35:43,740
Donc, je fais le capital Y, entrez, erreur.

1918
01:35:43,740 --> 01:35:46,130
OK, il est pas exactement ce que j'attends.

1919
01:35:46,130 --> 01:35:48,170
En effet, l'ordinateur
est de faire littéralement ce que

1920
01:35:48,170 --> 01:35:51,794
Je l'ai dit à do-- vérifier
minuscules y et minuscules n.

1921
01:35:51,794 --> 01:35:53,960
Cela ne se sent pas comme bon
expérience utilisateur, cependant.

1922
01:35:53,960 --> 01:35:59,010
Permettez-moi de demander et d'accepter
soit minuscules ou majuscules.

1923
01:35:59,010 --> 01:36:02,090
Donc, il se trouve, vous voudrez peut-être
dire quelque chose comme dans Scratch,

1924
01:36:02,090 --> 01:36:08,150
comme littéralement ou C est égal à
est égal à capitaux unique y citée.

1925
01:36:08,150 --> 01:36:11,400
Tours dehors, C n'a pas
ce mot-clé littéral ou.

1926
01:36:11,400 --> 01:36:12,880
>> Mais il a deux barres verticales.

1927
01:36:12,880 --> 01:36:15,463
Vous devez tenir Maj habituellement,
si vous utilisez un clavier américain,

1928
01:36:15,463 --> 01:36:18,910
et appuyez sur la barre verticale
clé ci-dessus la clé de votre retour.

1929
01:36:18,910 --> 01:36:22,410
Mais cette barre verticale
signifie barre verticale ou.

1930
01:36:22,410 --> 01:36:26,220
>> Si, au contraire, nous avons voulu
à dire et, comme dans Scratch,

1931
01:36:26,220 --> 01:36:28,180
nous pourrions faire esperluette esperluette.

1932
01:36:28,180 --> 01:36:31,330
Cela n'a aucun sens logique ici,
parce qu'un homme ne pouvait pas

1933
01:36:31,330 --> 01:36:37,110
ont tapé y et minuscules y
et le capital Y comme le même caractère.

1934
01:36:37,110 --> 01:36:39,470
Donc, ou est ce que nous entendons ici.

1935
01:36:39,470 --> 01:36:46,280
>> Donc, si je fais cela dans les deux endroits, ou c
est égal à equals N majuscule, maintenant rediffuser,

1936
01:36:46,280 --> 01:36:49,390
make logique, relancez logique.

1937
01:36:49,390 --> 01:36:51,200
Maintenant, je peux taper y.

1938
01:36:51,200 --> 01:36:53,920
Et je peux le faire à nouveau avec
capitale Y ou N. de capital

1939
01:36:53,920 --> 01:36:56,630
Et je pourrais ajouter en plus
combinaisons fixes.

1940
01:36:56,630 --> 01:36:58,810
>> Donc, cela est logique
programme dans la mesure où maintenant

1941
01:36:58,810 --> 01:37:01,940
Je vérifie logiquement pour
cette valeur ou cette valeur.

1942
01:37:01,940 --> 01:37:06,420
Et je ne dois pas, nécessairement,
venir avec deux ifs ou bien des ifs.

1943
01:37:06,420 --> 01:37:09,960
Je peux effectivement combiner une partie de la
une logique liée ensemble de cette façon.

1944
01:37:09,960 --> 01:37:11,950
Donc, ce serait mieux
conçu que simplement

1945
01:37:11,950 --> 01:37:17,490
dire, si C est égal à minuscules y,
imprimer oui, autre si c est égal à Y majuscule,

1946
01:37:17,490 --> 01:37:20,074
imprimer oui, autre si c est égal à
lower-- en d'autres termes,

1947
01:37:20,074 --> 01:37:21,990
vous ne devez pas avoir
de plus en plus de branches.

1948
01:37:21,990 --> 01:37:28,840
Vous pouvez combiner certains de l'équivalent
branches logiquement, que de cette manière.

1949
01:37:28,840 --> 01:37:34,150
>> Donc, nous allons jeter un oeil à un seul
ingrédient final, une construction finale,

1950
01:37:34,150 --> 01:37:34,847
que C permet.

1951
01:37:34,847 --> 01:37:36,930
Et nous reviendrons dans le
avenir pour d'autres encore.

1952
01:37:36,930 --> 01:37:41,400
Et puis nous allons conclure en regardant
de ne pas la justesse de code--

1953
01:37:41,400 --> 01:37:46,070
obtenir le code pour work-- mais la conception
du code, et planter ces graines tôt.

1954
01:37:46,070 --> 01:37:51,337
>> Alors laissez-moi aller de l'avant et
ouvrir un nouveau fichier ici.

1955
01:37:51,337 --> 01:37:51,920
Vous savez quoi?

1956
01:37:51,920 --> 01:37:54,450
Je vais ré-implémenter
ce même programme,

1957
01:37:54,450 --> 01:37:55,940
mais en utilisant une construction différente.

1958
01:37:55,940 --> 01:38:00,110
>> Alors laissez-moi vite me donner
l'accès à inclure CS50.h

1959
01:38:00,110 --> 01:38:04,150
pour la bibliothèque CS50,
Io.h standard pour printf.

1960
01:38:04,150 --> 01:38:06,510
Donnez-moi mon void main int.

1961
01:38:06,510 --> 01:38:09,310
Et puis ici, laissez
moi aller de l'avant et faire cela.

1962
01:38:09,310 --> 01:38:12,010
>> Char c obtient obtenir char, comme avant.

1963
01:38:12,010 --> 01:38:16,770
Et je vais utiliser une nouvelle construction
maintenant-- passer, sur ce personnage?

1964
01:38:16,770 --> 01:38:19,820
Donc interrupteur est un peu comme
la commutation d'un train pistes.

1965
01:38:19,820 --> 01:38:22,070
Ou, vraiment, il est une sorte de
un si bien, si bien si,

1966
01:38:22,070 --> 01:38:23,980
mais écrit un peu différemment.

1967
01:38:23,980 --> 01:38:25,490
>> Un commutateur ressemble à ceci.

1968
01:38:25,490 --> 01:38:29,060
Vous avez l'interrupteur, puis ce
caractère ou numéro que vous voulez regarder,

1969
01:38:29,060 --> 01:38:32,000
puis quelques accolades aiment dans
Scratch, dites simplement faire ce genre de choses.

1970
01:38:32,000 --> 01:38:33,480
Et puis vous avez différents cas.

1971
01:38:33,480 --> 01:38:34,830
>> Vous n'utilisez pas si et d'autre.

1972
01:38:34,830 --> 01:38:37,050
Vous utilisez littéralement le mot cas.

1973
01:38:37,050 --> 01:38:38,790
Et vous dire quelque chose comme ça.

1974
01:38:38,790 --> 01:38:43,820
>> Ainsi, dans le cas d'un minuscule y,
ou dans le cas d'un chapiteau Y,

1975
01:38:43,820 --> 01:38:47,350
aller de l'avant et d'imprimer oui.

1976
01:38:47,350 --> 01:38:49,020
Et puis sortir de l'interrupteur.

1977
01:38:49,020 --> 01:38:49,580
C'est tout.

1978
01:38:49,580 --> 01:38:50,880
Avaient fini.

1979
01:38:50,880 --> 01:38:57,270
>> Sinon, si, pour ainsi dire,
minuscules n ou N majuscule,

1980
01:38:57,270 --> 01:39:02,560
alors allez-y et imprimer
out pas, puis briser.

1981
01:39:02,560 --> 01:39:08,022
Else-- et ce genre de est le
cas par défaut indeed-- printf error--

1982
01:39:08,022 --> 01:39:10,980
et juste pour faire bonne mesure, bien que
logiquement cette rupture est pas nécessaire

1983
01:39:10,980 --> 01:39:12,896
parce que nous sommes à la fin
du commutateur de toute façon,

1984
01:39:12,896 --> 01:39:14,520
Je vais maintenant sortir de l'interrupteur.

1985
01:39:14,520 --> 01:39:16,280
Donc, cela ressemble un peu différent.

1986
01:39:16,280 --> 01:39:18,272
>> Mais, logiquement, il est
en fait équivalent.

1987
01:39:18,272 --> 01:39:19,980
Et pourquoi voudriez-vous utiliser
l'un sur l'autre?

1988
01:39:19,980 --> 01:39:23,220
Parfois, juste préférence personnelle,
parfois l'esthétique,

1989
01:39:23,220 --> 01:39:25,420
si je regarde à ce
maintenant, il y a quelque chose

1990
01:39:25,420 --> 01:39:27,510
à dire pour la
la lisibilité de ce code.

1991
01:39:27,510 --> 01:39:30,690
Je veux dire, sans parler du fait que cette
le code est nouveau pour beaucoup d'entre nous dans la chambre.

1992
01:39:30,690 --> 01:39:33,515
>> Mais il juste un peu est assez.

1993
01:39:33,515 --> 01:39:37,760
Vous voyez minuscules y, capitale Y,
minuscules n, N majuscule par défaut,

1994
01:39:37,760 --> 01:39:40,150
juste sorte de sauts
sur vous d'une manière

1995
01:39:40,150 --> 01:39:42,200
que, sans doute, peut-être
l'exemple précédent

1996
01:39:42,200 --> 01:39:45,780
avec les ifs et les barres verticales,
et les ifs d'autre, pourraient ne pas avoir.

1997
01:39:45,780 --> 01:39:51,600
Donc, ce qui est vraiment une question de personnel
choix, vraiment, ou la lisibilité,

1998
01:39:51,600 --> 01:39:52,360
du code.

1999
01:39:52,360 --> 01:39:58,230
>> Mais en termes de fonctionnalité, laissez-moi
aller de l'avant et de faire un commutateur, slash dot

2000
01:39:58,230 --> 01:40:05,830
commutateur, et maintenant taper y minuscules,
Y majuscule, minuscule n, N majuscule,

2001
01:40:05,830 --> 01:40:09,250
David, réessayez parce que ce
pas un seul caractère.

2002
01:40:09,250 --> 01:40:12,050
Faisons x, erreur, comme prévu.

2003
01:40:12,050 --> 01:40:15,640
Et, logically-- et cela est quelque chose
Je vous encourage à general-- même

2004
01:40:15,640 --> 01:40:17,790
si nous ne faisons que gratter la
la surface de certaines de ces fonctions.

2005
01:40:17,790 --> 01:40:20,560
>> Et il ne serait pas évident quand vous
vous asseoir au clavier,

2006
01:40:20,560 --> 01:40:21,370
Comment cela marche-t-il?

2007
01:40:21,370 --> 01:40:22,240
Qu'est-ce que cela?

2008
01:40:22,240 --> 01:40:25,630
La belle chose d'avoir
un ordinateur portable ou de bureau, ou l'accès

2009
01:40:25,630 --> 01:40:29,290
à un ordinateur avec un compilateur,
et avec un éditeur de code comme ceci,

2010
01:40:29,290 --> 01:40:32,990
est que vous pouvez presque toujours répondre à ces
questions pour vous-même juste en essayant.

2011
01:40:32,990 --> 01:40:36,570
>> Par exemple, si la rhétorique
question à portée de main étaient,

2012
01:40:36,570 --> 01:40:39,540
ce qui se passe si vous oubliez
vos déclarations de rupture?

2013
01:40:39,540 --> 01:40:41,400
Qui est en fait un
très courante chose à faire,

2014
01:40:41,400 --> 01:40:43,540
car il ne semble pas
comme vous avez vraiment besoin.

2015
01:40:43,540 --> 01:40:46,790
Ils ne sont pas vraiment complètent pas votre
pensé comme une parenthèse ou bouclés

2016
01:40:46,790 --> 01:40:47,714
brace fait.

2017
01:40:47,714 --> 01:40:49,630
Allons-y et
recompiler le code et voir.

2018
01:40:49,630 --> 01:40:53,690
Donc, assurez-commutateur, barre oblique point.

2019
01:40:53,690 --> 01:40:56,435
Voyons tapez en minuscules
y, le dessus du boîtier, Entrée.

2020
01:40:56,435 --> 01:40:59,390

2021
01:40:59,390 --> 01:41:00,700
Je tapais y.

2022
01:41:00,700 --> 01:41:04,420
>> Le programme dit oui, non, erreur,
comme si elle était en train de changer son esprit.

2023
01:41:04,420 --> 01:41:09,280
Mais ce genre d'été, parce que ce qui se passe
avec un commutateur est le premier cas que

2024
01:41:09,280 --> 01:41:13,899
correspondance signifie essentiellement, hé ordinateur,
exécuter la totalité du code-dessous.

2025
01:41:13,899 --> 01:41:16,690
Et si vous ne dites pas la rupture, ou
ne dites pas la rupture, ou ne pas dire pause,

2026
01:41:16,690 --> 01:41:19,540
l'ordinateur va exploser
à travers toutes les lignes

2027
01:41:19,540 --> 01:41:22,779
et d'exécuter tous les jusqu'à
il obtient à cette accolade.

2028
01:41:22,779 --> 01:41:24,320
Donc, les freins sont, en effet, nécessaire.

2029
01:41:24,320 --> 01:41:27,120
Mais un plat à emporter ici est, quand
dans le doute, essayer quelque chose.

2030
01:41:27,120 --> 01:41:29,510
Peut-être enregistrer votre premier code,
ou l'enregistrer dans un fichier supplémentaire

2031
01:41:29,510 --> 01:41:32,930
si vous êtes vraiment inquiet
gâcher et d'avoir à récupérer

2032
01:41:32,930 --> 01:41:34,430
le travail que vous savez fonctionne.

2033
01:41:34,430 --> 01:41:35,410
>> Mais essayer des choses.

2034
01:41:35,410 --> 01:41:38,074
Et ne soyez pas aussi peur, peut-être,
de ce que l'ordinateur peut faire,

2035
01:41:38,074 --> 01:41:39,490
ou que vous pourriez casser quelque chose.

2036
01:41:39,490 --> 01:41:42,790
Vous pouvez toujours revenir en arrière
à une version antérieure.

2037
01:41:42,790 --> 01:41:45,640
>> Donc, nous allons mettre fin en regardant
à la conception de code.

2038
01:41:45,640 --> 01:41:49,020
Nous avons cette capacité maintenant écrire
conditions, et des boucles d'écriture,

2039
01:41:49,020 --> 01:41:50,850
et les variables et les fonctions d'appel.

2040
01:41:50,850 --> 01:41:54,590
Donc, franchement, nous sommes un peu en arrière à
où nous étions il y a une semaine avec Scratch,

2041
01:41:54,590 --> 01:42:00,120
mais avec un texte moins convaincant
environnement que Scratch permet.

2042
01:42:00,120 --> 01:42:03,990
>> Mais remarquons rapidité avec laquelle nous avons acquis
ce vocabulaire, même si elle est

2043
01:42:03,990 --> 01:42:07,570
va prendre un peu de temps à couler,
de sorte que nous pouvons maintenant utiliser ce vocabulaire

2044
01:42:07,570 --> 01:42:10,320
pour écrire des programmes plus intéressants.

2045
01:42:10,320 --> 01:42:12,940
Et nous allons prendre un pas de bébé
dans cette direction, comme suit.

2046
01:42:12,940 --> 01:42:14,890
Laissez-moi aller de l'avant et
créer un nouveau fichier ici.

2047
01:42:14,890 --> 01:42:17,750
>> Je vais appeler cette
prototype.c, et d'introduire

2048
01:42:17,750 --> 01:42:20,954
pour la première fois, la possibilité
de faire vos propres fonctions.

2049
01:42:20,954 --> 01:42:22,870
Certains d'entre vous pourraient avoir
fait avec Scratch,

2050
01:42:22,870 --> 01:42:25,430
de sorte que vous pouvez créer votre
propres blocs personnalisés dans Scratch,

2051
01:42:25,430 --> 01:42:27,892
puis faites-les glisser en place
partout où vous souhaitez en C.

2052
01:42:27,892 --> 01:42:30,100
Et dans la plupart des émissions
langues, vous pouvez faire exactement

2053
01:42:30,100 --> 01:42:33,580
that-- faire vos propres fonctions,
si elles ne sont pas déjà.

2054
01:42:33,580 --> 01:42:38,660
>> Ainsi, par exemple, laissez-moi aller de l'avant
et comprennent CS50.h, et comprennent

2055
01:42:38,660 --> 01:42:43,110
norme io.h, void main int.

2056
01:42:43,110 --> 01:42:46,020
Et maintenant, nous avons un
espace réservé prêt à aller.

2057
01:42:46,020 --> 01:42:48,550
Je garde les choses d'impression
comme les noms des personnes aujourd'hui.

2058
01:42:48,550 --> 01:42:51,910
Et cela se sent like--
ne serait pas bien s'il y

2059
01:42:51,910 --> 01:42:53,936
étaient une fonction appelée nom d'impression?

2060
01:42:53,936 --> 01:42:55,060
Je ne dois pas utiliser printf.

2061
01:42:55,060 --> 01:42:56,976
Je n'ai pas de se rappeler
tous les codes de format.

2062
01:42:56,976 --> 01:43:00,050
Pourquoi pas moi, ou pourquoi
n'a pas quelqu'un avant moi,

2063
01:43:00,050 --> 01:43:02,980
créer une fonction appelée impression
nom, donné un nom,

2064
01:43:02,980 --> 01:43:03,980
imprime simplement it out?

2065
01:43:03,980 --> 01:43:08,700
>> En d'autres termes, si je dis, hey,
ordinateur, donnez-moi une chaîne

2066
01:43:08,700 --> 01:43:11,870
en demandant à l'utilisateur d'une telle,
via la fonction de chaîne get de CS50.

2067
01:43:11,870 --> 01:43:15,090
Hey, ordinateur, mettez cette chaîne dans
la variable du côté de la main gauche,

2068
01:43:15,090 --> 01:43:16,150
et appelez-le par.

2069
01:43:16,150 --> 01:43:22,150
Et puis, hé ordinateur, aller de l'avant
et imprimer que le nom de la personne, fait.

2070
01:43:22,150 --> 01:43:26,240
>> Maintenant, ce serait bien, parce que
ce programme, bien nommé,

2071
01:43:26,240 --> 01:43:29,170
me dit ce qu'il est censé faire
par des noms de ceux fonction.

2072
01:43:29,170 --> 01:43:32,930
Laissez-moi aller et faire un prototype, entrez.

2073
01:43:32,930 --> 01:43:34,930
Et, malheureusement,
cela ne va pas à voler.

2074
01:43:34,930 --> 01:43:39,430
>> Prototype.c, ligne 7, caractère
5, erreur, déclaration implicite

2075
01:43:39,430 --> 01:43:42,960
de la fonction nom d'impression
est invalide dans C99, C99

2076
01:43:42,960 --> 01:43:45,130
ce qui signifie une version de C
qui est sorti en 1999.

2077
01:43:45,130 --> 01:43:45,730
C'est tout.

2078
01:43:45,730 --> 01:43:48,780
>> Donc, je ne sais pas ce que
tout cela signifie encore.

2079
01:43:48,780 --> 01:43:50,810
Mais je reconnais erreur en rouge.

2080
01:43:50,810 --> 01:43:51,770
C'est assez évident.

2081
01:43:51,770 --> 01:43:53,769
>> Et il semble qu'avec
le caractère vert ici,

2082
01:43:53,769 --> 01:43:57,520
le problème est avec le nom d'impression, ouvert
paren s, à proximité paren, semi-colon.

2083
01:43:57,520 --> 01:44:01,800
Mais déclaration implicite de
fonction que nous avons vu brièvement plus tôt.

2084
01:44:01,800 --> 01:44:04,880
Cela signifie simplement que Clang
ne sais pas ce que je veux dire.

2085
01:44:04,880 --> 01:44:09,000
>> Je l'ai utilisé un mot de vocabulaire qu'il est
jamais vu ou été enseigné auparavant.

2086
01:44:09,000 --> 01:44:11,950
Et donc je dois enseigner
ce que signifie cette fonction.

2087
01:44:11,950 --> 01:44:13,590
Je vais donc aller de l'avant et de le faire.

2088
01:44:13,590 --> 01:44:17,970
>> Je vais aller de l'avant et mettre en œuvre
ma propre fonction appelée Imprimer Nom.

2089
01:44:17,970 --> 01:44:24,720
Et je vais vous dire, comme suit,
il le fait, printf, bonjour, pour cent

2090
01:44:24,720 --> 01:44:27,760
s, backslash n, nom, point-virgule.

2091
01:44:27,760 --> 01:44:29,250
Alors qu'est-ce que je viens de faire?

2092
01:44:29,250 --> 01:44:31,325
>> Donc, il se trouve, à
mettre en œuvre votre propre fonction,

2093
01:44:31,325 --> 01:44:33,845
nous sorte de empruntons certains
la même structure principale

2094
01:44:33,845 --> 01:44:35,720
que nous venons de
pris pour acquis, et je

2095
01:44:35,720 --> 01:44:37,730
il suffit de savoir la copie et
coller à peu près ce que

2096
01:44:37,730 --> 01:44:39,170
J'ai écrit dans le passé.

2097
01:44:39,170 --> 01:44:40,570
Mais remarquez le modèle ici.

2098
01:44:40,570 --> 01:44:43,750
Int, Main, Void, nous allons taquiner dehors
avant longtemps ce que cela signifie réellement.

2099
01:44:43,750 --> 01:44:46,160
>> Mais pour aujourd'hui, juste
remarquer le parallélisme.

2100
01:44:46,160 --> 01:44:48,210
Void, le nom d'impression,
nom de chaîne, donc il n'y a

2101
01:44:48,210 --> 01:44:50,310
un mot-clé pourpre, qui
nous allons commencer

2102
01:44:50,310 --> 01:44:54,067
appeler un type de retour, le nom de
la fonction, puis l'entrée.

2103
01:44:54,067 --> 01:44:56,400
Donc, en fait, nous pouvons distiller
ce genre de comme la semaine dernière

2104
01:44:56,400 --> 01:44:59,030
comme cela est le nom ou le
algorithme du code que nous sommes

2105
01:44:59,030 --> 01:45:00,761
va write-- la
algorithme sous-jacent

2106
01:45:00,761 --> 01:45:02,010
le code que nous allons écrire.

2107
01:45:02,010 --> 01:45:03,180
>> Ceci est son entrée.

2108
01:45:03,180 --> 01:45:04,670
Ceci est sa sortie.

2109
01:45:04,670 --> 01:45:08,730
Cette fonction, le nom d'impression, est
conçu pour prendre une chaîne appelée nom,

2110
01:45:08,730 --> 01:45:11,350
ou autre chose, comme entrée, puis vide.

2111
01:45:11,350 --> 01:45:13,904
Il ne retourne rien,
comme obtenir string ou obtenir int fait.

2112
01:45:13,904 --> 01:45:15,570
Donc, ça va me remettre quelque chose en retour.

2113
01:45:15,570 --> 01:45:17,960
Il va juste avoir un
effet secondaire, pour ainsi dire,

2114
01:45:17,960 --> 01:45:19,570
d'imprimer le nom d'une personne.

2115
01:45:19,570 --> 01:45:22,260
Donc, remarque, ligne 7, je
peut appeler le nom d'impression.

2116
01:45:22,260 --> 01:45:25,920
Ligne 10, je peux définir
ou mettre en œuvre le nom d'impression.

2117
01:45:25,920 --> 01:45:28,450
Mais, malheureusement, cela ne suffit pas.

2118
01:45:28,450 --> 01:45:31,230
>> Laissez-moi aller de l'avant et
recompiler après avoir sauvegardé.

2119
01:45:31,230 --> 01:45:33,910
Whoa, maintenant, je l'ai fait
Pire encore, il semblerait.

2120
01:45:33,910 --> 01:45:37,027
déclaration Donc implicite de
nom fonction d'impression est invalide.

2121
01:45:37,027 --> 01:45:38,360
Et, encore une fois, il n'y a plus d'erreurs.

2122
01:45:38,360 --> 01:45:41,430
Mais comme je l'ai mis en garde plus tôt, même
si vous obtenez accablé avec,

2123
01:45:41,430 --> 01:45:44,850
ou un peu triste de voir tant de
erreurs, se concentrer uniquement sur la première

2124
01:45:44,850 --> 01:45:47,500
d'abord, parce qu'il pourrait juste
ont eu un effet en cascade.

2125
01:45:47,500 --> 01:45:51,970
Donc, C ou plus précisément Clang,
ne reconnaît toujours pas le nom d'impression.

2126
01:45:51,970 --> 01:45:54,580
>> Et c'est parce Clang,
par la conception, est un peu idiot.

2127
01:45:54,580 --> 01:45:56,280
Il ne fait que ce que vous lui demandez de faire.

2128
01:45:56,280 --> 01:46:00,950
Et il ne le fait que dans l'ordre
dans laquelle vous lui demandez de faire.

2129
01:46:00,950 --> 01:46:05,270
>> Donc, je l'ai défini principale sur la ligne de quatre,
comme nous l'avons fait assez souvent.

2130
01:46:05,270 --> 01:46:07,980
J'ai défini le nom d'impression à la ligne 10.

2131
01:46:07,980 --> 01:46:11,793
Mais je suis en train d'utiliser
nom d'impression en ligne sept.

2132
01:46:11,793 --> 01:46:13,670
>> Il est trop tôt, n'existe pas encore.

2133
01:46:13,670 --> 01:46:19,150
Donc, je pourrais être intelligent, et être comme,
OK, donc nous allons jouer tout le long,

2134
01:46:19,150 --> 01:46:23,680
et déplacer le nom d'impression jusqu'à
ici, et re-compiler.

2135
01:46:23,680 --> 01:46:24,550
Oh mon Dieu.

2136
01:46:24,550 --> 01:46:25,260
Ça a marché.

2137
01:46:25,260 --> 01:46:26,670
C'était aussi simple que ça.

2138
01:46:26,670 --> 01:46:28,120
>> Mais la logique est exactement cela.

2139
01:46:28,120 --> 01:46:30,870
Vous devez apprendre à Clang ce qu'il
est en définissant la fonction première.

2140
01:46:30,870 --> 01:46:31,920
Ensuite, vous pouvez l'utiliser.

2141
01:46:31,920 --> 01:46:33,940
Mais, franchement, cela se sent
comme une pente glissante.

2142
01:46:33,940 --> 01:46:35,773
>> Ainsi, chaque fois que je lance
dans un problème, je suis juste

2143
01:46:35,773 --> 01:46:39,450
va mettre en évidence et de copier le code
Je l'ai écrit, le couper et le coller ici.

2144
01:46:39,450 --> 01:46:41,370
Et, sûrement, nous pourrions
ingénier certains scénarios

2145
01:46:41,370 --> 01:46:43,286
où une fonction pourrait
besoin d'appeler un autre.

2146
01:46:43,286 --> 01:46:46,030
Et vous ne pouvez pas mettre tous les
fonction ci-dessus tous les autres.

2147
01:46:46,030 --> 01:46:47,930
>> Donc, il se trouve qu'il y a
une meilleure solution.

2148
01:46:47,930 --> 01:46:50,100
Nous pouvons laisser ce soit.

2149
01:46:50,100 --> 01:46:53,677
Et, franchement, il est généralement agréable,
et pratique, et un bon design

2150
01:46:53,677 --> 01:46:56,760
de mettre principale d'abord, parce que, encore une fois,
principale, juste comme quand le drapeau vert cliqué,

2151
01:46:56,760 --> 01:46:59,027
qui est la fonction qui
est exécuté par défaut.

2152
01:46:59,027 --> 01:47:01,110
Donc, vous pourriez aussi bien mettre
au sommet du fichier

2153
01:47:01,110 --> 01:47:03,560
de sorte que lorsque vous ou tout
autre homme regarde le fichier

2154
01:47:03,560 --> 01:47:06,360
vous savez ce qui se passe
juste en lisant principal en premier.

2155
01:47:06,360 --> 01:47:15,360
Donc, il se trouve, nous pouvons dire Clang
de manière proactive, hé, Clang, sur la quatrième ligne,

2156
01:47:15,360 --> 01:47:17,940
Je promets de mettre en œuvre
une fonction appelée Imprimer

2157
01:47:17,940 --> 01:47:22,600
Nom qui prend un nom de chaîne appelée
comme entrée, et retourne rien, vide.

2158
01:47:22,600 --> 01:47:24,770
Et je vais autour de
la mise en œuvre plus tard.

2159
01:47:24,770 --> 01:47:25,680
>> Voici Main.

2160
01:47:25,680 --> 01:47:29,130
Principal maintenant sur la ligne 9 peut utiliser
Imprimer Nom parce Clang

2161
01:47:29,130 --> 01:47:32,600
est confiant que, par la suite,
il rencontre la définition

2162
01:47:32,600 --> 01:47:34,880
de la mise en œuvre du Print Nom.

2163
01:47:34,880 --> 01:47:37,390
Donc, après avoir sauvé mon dossier, laissez
moi aller de l'avant et de faire un prototype,

2164
01:47:37,390 --> 01:47:38,498
semble bon cette fois.

2165
01:47:38,498 --> 01:47:43,470
Dot slash, prototype, laissez-moi
aller de l'avant et taper un nom.

2166
01:47:43,470 --> 01:47:48,440
David, bonjour David, Zamila, bonjour
Zamila, et, en fait, maintenant il fonctionne.

2167
01:47:48,440 --> 01:47:52,200
>> Donc, l'ingrédient ici est que nous avons
fait une fonction personnalisée, comme une coutume

2168
01:47:52,200 --> 01:47:54,219
bloc de Scratch nous appeler.

2169
01:47:54,219 --> 01:47:57,010
Mais contrairement à Scratch où vous pouvez
il suffit de créer et commencer à l'utiliser,

2170
01:47:57,010 --> 01:47:59,330
maintenant, nous devons être un
peu plus pédant,

2171
01:47:59,330 --> 01:48:03,410
et effectivement former Clang
d'utiliser ou de s'y attendre.

2172
01:48:03,410 --> 01:48:09,140
Maintenant, en passant, pourquoi tout ce temps ont
nous avions été aveuglément sur la foi, y compris

2173
01:48:09,140 --> 01:48:12,170
CS50.h, et notamment la norme io.h?

2174
01:48:12,170 --> 01:48:15,190
>> Eh bien, il se trouve,
parmi quelques autres choses,

2175
01:48:15,190 --> 01:48:18,550
tout ce qui est dans les points h
fichiers, qui se trouvent être des fichiers.

2176
01:48:18,550 --> 01:48:20,460
Ils sont des fichiers d'en-tête, pour ainsi dire.

2177
01:48:20,460 --> 01:48:23,270
Ils sont toujours écrits en C. Mais
ils sont un type de fichier différent.

2178
01:48:23,270 --> 01:48:28,690
>> Pour l'instant, vous pouvez très bien supposer
que tout ce qui est à l'intérieur CS50.h

2179
01:48:28,690 --> 01:48:33,360
est des one-liners comme celui-ci, et non pas
pour les fonctions appelées Imprimer Nom,

2180
01:48:33,360 --> 01:48:36,840
mais pour Get String, Get
Float, et quelques autres.

2181
01:48:36,840 --> 01:48:41,510
Et il y a des prototypes semblables,
revêtements un, à l'intérieur de la norme io.h

2182
01:48:41,510 --> 01:48:46,241
pour printf, qui est maintenant en
ma propre fonction Imprimer Nom.

2183
01:48:46,241 --> 01:48:49,490
Donc, en d'autres termes, tout ce temps, nous avons
vient d'être aveuglément copiant et collant

2184
01:48:49,490 --> 01:48:51,780
inclure ce, inclure
que, ce qui se passe?

2185
01:48:51,780 --> 01:48:55,310
Ce sont juste un peu d'indices
à Clang à quelles fonctions

2186
01:48:55,310 --> 01:49:00,170
sont, en effet, mis en œuvre, tout simplement
ailleurs dans différents fichiers

2187
01:49:00,170 --> 01:49:02,440
ailleurs sur le système.

2188
01:49:02,440 --> 01:49:05,160
>> Nous avons donc mis en place le nom d'impression.

2189
01:49:05,160 --> 01:49:07,910
Il possède cet effet secondaire de
impression quelque chose sur l'écran.

2190
01:49:07,910 --> 01:49:10,170
Mais il ne fait
donnez-moi quelque chose en retour.

2191
01:49:10,170 --> 01:49:12,200
Comment allons-nous
mettre en oeuvre un programme qui

2192
01:49:12,200 --> 01:49:14,510
ne me remettre quelque chose en retour?

2193
01:49:14,510 --> 01:49:15,580
>> Eh bien, nous allons essayer cela.

2194
01:49:15,580 --> 01:49:21,360
Laissez-moi aller de l'avant et de mettre en œuvre
un return.c de fichier appelé

2195
01:49:21,360 --> 01:49:24,530
afin que nous puissions démontrer comment quelque chose
comme Get String, ou Get Int,

2196
01:49:24,530 --> 01:49:27,340
est en fait retourner
quelque chose en retour à l'utilisateur.

2197
01:49:27,340 --> 01:49:29,840
Allons de l'avant et de définir void main int.

2198
01:49:29,840 --> 01:49:33,230
>> Et, encore une fois, à l'avenir, nous allons
expliquer ce que int et ce vide

2199
01:49:33,230 --> 01:49:34,090
est en train de faire.

2200
01:49:34,090 --> 01:49:35,840
Mais pour aujourd'hui, nous allons
prendre pour acquis.

2201
01:49:35,840 --> 01:49:39,970
Je vais aller de l'avant et printf,
pour une bonne expérience utilisateur, x est.

2202
01:49:39,970 --> 01:49:44,360
Et puis je vais attendre la
utilisateur pour me donner x avec get int.

2203
01:49:44,360 --> 01:49:48,459
>> Et puis je vais aller de l'avant
et imprimer x au carré.

2204
01:49:48,459 --> 01:49:50,500
Alors, quand vous avez seulement un
clavier, les gens couramment

2205
01:49:50,500 --> 01:49:52,600
utiliser la petite carotte
symbole sur le clavier

2206
01:49:52,600 --> 01:49:55,330
pour représenter la puissance
, ou l'exposant.

2207
01:49:55,330 --> 01:49:58,960
Donc x au carré est présent i.

2208
01:49:58,960 --> 01:50:00,660
>> Et maintenant, je vais le faire.

2209
01:50:00,660 --> 01:50:03,940
Je ne pouvais tout simplement ce qui est do-- x
au carré? x au carré est x fois x.

2210
01:50:03,940 --> 01:50:06,690
>> Et nous avons fait un certain
Il y a longtemps déjà aujourd'hui.

2211
01:50:06,690 --> 01:50:08,730
Cela ne se sent pas comme
tout ce que beaucoup de progrès.

2212
01:50:08,730 --> 01:50:09,570
Vous savez quoi?

2213
01:50:09,570 --> 01:50:13,100
Nous allons tirer parti de certains de cette idée
depuis la dernière fois de l'abstraction.

2214
01:50:13,100 --> 01:50:16,080
>> Ne serait-il pas bien si
il y a une fonction appelée

2215
01:50:16,080 --> 01:50:18,460
carré qui fait exactement cela?

2216
01:50:18,460 --> 01:50:20,640
Il reste, à la fin de la
jour, fait la même mathématiques.

2217
01:50:20,640 --> 01:50:22,410
Résumé d'Mais laissez
loin de l'idée de la prise

2218
01:50:22,410 --> 01:50:25,280
un nombre multiplié par
une autre, et juste lui donner un nom,

2219
01:50:25,280 --> 01:50:27,360
comme carré de cette valeur.

2220
01:50:27,360 --> 01:50:29,560
>> Et, en d'autres termes,
C, nous allons créer une fonction

2221
01:50:29,560 --> 01:50:32,660
appelé carré qui fait exactement cela.

2222
01:50:32,660 --> 01:50:34,600
Il va être appelé carré.

2223
01:50:34,600 --> 01:50:35,790
Il va prendre un int.

2224
01:50:35,790 --> 01:50:37,820
Et nous allons tout va
appeler n, par défaut.

2225
01:50:37,820 --> 01:50:39,403
>> Mais nous pourrions l'appeler tout ce que nous voulons.

2226
01:50:39,403 --> 01:50:42,900
Et tout ce que ça va
faire, littéralement, est le retour

2227
01:50:42,900 --> 01:50:45,810
le résultat de n fois n.

2228
01:50:45,810 --> 01:50:48,980
Mais parce qu'il est
retourner quelque chose qui

2229
01:50:48,980 --> 01:50:53,690
est le mot-clé dans le pourpre, nous avons
jamais vu auparavant, je, sur la ligne 11,

2230
01:50:53,690 --> 01:50:55,410
ne peut pas simplement dire vide cette fois.

2231
01:50:55,410 --> 01:51:01,320
>> Void, dans l'exemple que nous venons de voir
plutôt du nom d'impression, signifie simplement,

2232
01:51:01,320 --> 01:51:02,190
faire quelque chose.

2233
01:51:02,190 --> 01:51:04,170
Mais ne me remettre pas quelque chose en retour.

2234
01:51:04,170 --> 01:51:06,790
Dans ce cas, je ne veux
pour revenir n fois n,

2235
01:51:06,790 --> 01:51:08,460
ou tout ce qui est, ce nombre.

2236
01:51:08,460 --> 01:51:12,460
>> Donc, je ne peux pas dire, hé, ordinateur,
Je reviens rien, nulle.

2237
01:51:12,460 --> 01:51:16,166
Il va revenir, par nature, un int.

2238
01:51:16,166 --> 01:51:17,790
Et voilà tout ce qui se passe ici.

2239
01:51:17,790 --> 01:51:20,070
>> L'entrée au carré
va être un int.

2240
01:51:20,070 --> 01:51:24,760
Et pour que nous puissions l'utiliser, il doit
avoir un nom, N. Il va à la sortie

2241
01:51:24,760 --> 01:51:26,240
un int qui n'a pas besoin d'un nom.

2242
01:51:26,240 --> 01:51:29,590
Nous pouvons laisser à principal, ou celui qui est
moi en utilisant de se rappeler cette valeur si nous

2243
01:51:29,590 --> 01:51:31,120
veulent avec sa propre variable.

2244
01:51:31,120 --> 01:51:33,230
>> Et, encore une fois, la seule nouvelle
mot-clé ici est de retour.

2245
01:51:33,230 --> 01:51:34,480
Et je fais juste un peu de maths.

2246
01:51:34,480 --> 01:51:41,825
Si je voulais vraiment être inutile,
Je pourrais dire produit int obtient n fois n.

2247
01:51:41,825 --> 01:51:44,170
>> Et puis, je pourrais dire, le produit de retour.

2248
01:51:44,170 --> 01:51:47,360
Mais, encore une fois, à mon point antérieur de
ce tout simplement pas être bon design--

2249
01:51:47,360 --> 01:51:50,060
comme, pourquoi introduire un nom,
un symbole, comme produit,

2250
01:51:50,060 --> 01:51:51,570
juste pour retourner immédiatement?

2251
01:51:51,570 --> 01:51:53,670
Il est un peu plus propre,
un peu plus serré, donc

2252
01:51:53,670 --> 01:51:59,380
de parler, juste pour dire le retour n fois
n, se débarrasser de cette ligne complètement.

2253
01:51:59,380 --> 01:52:02,860
>> Et il est juste moins de code à lire,
moins de possibilités d'erreurs.

2254
01:52:02,860 --> 01:52:05,180
Et nous allons voir si ce
fonctionne réellement maintenant.

2255
01:52:05,180 --> 01:52:09,380
Maintenant, je vais aller
avant et de faire retour.

2256
01:52:09,380 --> 01:52:11,460
>> Uh-oh, déclaration implicite de la fonction.

2257
01:52:11,460 --> 01:52:14,080
J'ai fait cette erreur avant, pas une grosse affaire.

2258
01:52:14,080 --> 01:52:18,950
Permettez-moi de taper, ou mettre en évidence et
copier, le même prototype de fonction exacte,

2259
01:52:18,950 --> 01:52:21,342
ou la signature, de la fonction ici.

2260
01:52:21,342 --> 01:52:22,800
Ou je pourrais déplacer toute la fonction.

2261
01:52:22,800 --> 01:52:23,841
>> Mais c'est un peu paresseux.

2262
01:52:23,841 --> 01:52:24,870
Donc, nous ne le ferons pas.

2263
01:52:24,870 --> 01:52:27,960
Maintenant, permettez-moi de retour
à nouveau, dot retour slash.

2264
01:52:27,960 --> 01:52:32,790
>> x est 2. x au carré est 4.
x est 3. x au carré est 9.

2265
01:52:32,790 --> 01:52:35,300
Et la fonction semble
maintenant travailler.

2266
01:52:35,300 --> 01:52:36,550
Alors, quelle est la différence ici?

2267
01:52:36,550 --> 01:52:42,520
J'ai une fonction qui est appelée carré,
dans ce cas, que je mets dans une entrée.

2268
01:52:42,520 --> 01:52:43,830
Et je reviens d'une sortie.

2269
01:52:43,830 --> 01:52:46,210
Et pourtant, précédemment, si
J'ouvre l'autre exemple

2270
01:52:46,210 --> 01:52:51,640
de plus tôt, ce qui
était appelé prototype.c,

2271
01:52:51,640 --> 01:52:54,770
J'ai eu le nom d'impression, qui
retourné vide, pour ainsi dire,

2272
01:52:54,770 --> 01:52:58,730
Ou il est revenu rien, et
avait tout simplement un effet secondaire.

2273
01:52:58,730 --> 01:53:00,230
>> Alors qu'est-ce qui se passe ici?

2274
01:53:00,230 --> 01:53:03,520
Eh bien, considérons la fonction
obtenir la chaîne pour un instant.

2275
01:53:03,520 --> 01:53:06,570
Nous avons utilisé la fonction
obtenir la chaîne de la façon suivante.

2276
01:53:06,570 --> 01:53:10,464
>> Nous avons eu une fonction get
chaîne, comme comprennent CS50.h,

2277
01:53:10,464 --> 01:53:16,624
inclure la norme io.h, int, principale, vide.

2278
01:53:16,624 --> 01:53:18,790
Et puis chaque fois que je l'ai
appelé chaîne get jusqu'à présent,

2279
01:53:18,790 --> 01:53:23,260
Je l'ai dit quelque chose comme, string s
obtient obtenir chaîne, car get string--

2280
01:53:23,260 --> 01:53:27,880
Appelons cette chaîne get get.c--
elle renvoie une chaîne qui je peux alors

2281
01:53:27,880 --> 01:53:32,050
utiliser, et dire bonjour, virgule,
pour cent s, backslash n, s.

2282
01:53:32,050 --> 01:53:35,660
>> Voici donc le même exemple,
vraiment, que nous avions auparavant.

2283
01:53:35,660 --> 01:53:37,920
Donc obtenir chaîne renvoie une valeur.

2284
01:53:37,920 --> 01:53:41,260
Mais il y a un instant, chaîne d'impression
ne retourne pas de valeur.

2285
01:53:41,260 --> 01:53:42,721
Il a tout simplement un effet secondaire.

2286
01:53:42,721 --> 01:53:44,220
Donc, ceci est une différence fondamentale.

2287
01:53:44,220 --> 01:53:46,710
Nous avons vu différents
types de fonctions maintenant,

2288
01:53:46,710 --> 01:53:49,490
dont certains sont rentrés
Les valeurs, dont certains ne le font pas.

2289
01:53:49,490 --> 01:53:51,890
Alors peut-être qu'il est une chaîne ou int, ou float.

2290
01:53:51,890 --> 01:53:53,480
Ou peut-être qu'il est juste vide.

2291
01:53:53,480 --> 01:53:55,710
>> Et la différence est
que ces fonctions

2292
01:53:55,710 --> 01:53:59,940
obtenir des données et retourner une valeur sont en fait
apporter quelque chose à la table,

2293
01:53:59,940 --> 01:54:01,110
pour ainsi dire.

2294
01:54:01,110 --> 01:54:03,710
Donc, nous allons aller de l'avant et
regarder un ensemble final

2295
01:54:03,710 --> 01:54:09,129
des exemples qui donne un sens, maintenant,
comment nous pourrions, en effet, abstrait mieux,

2296
01:54:09,129 --> 01:54:11,670
et mieux, et mieux, ou plus,
et plus, et plus, pour

2297
01:54:11,670 --> 01:54:13,810
à écrire, en fin de compte, un meilleur code.

2298
01:54:13,810 --> 01:54:16,860
Allons de l'avant, et dans l'esprit
Scratch, procédez comme suit.

2299
01:54:16,860 --> 01:54:21,700
>> Laissez-moi aller de l'avant et inclure
CS50.h et la norme io.h.

2300
01:54:21,700 --> 01:54:24,010
Laissez-moi aller de l'avant et de donner
moi un int, principale, vide.

2301
01:54:24,010 --> 01:54:27,380
Et laissez-moi aller de l'avant, appelle ce cough.c.

2302
01:54:27,380 --> 01:54:35,510
>> Et laissez-moi aller de l'avant et juste
comme Scratch, imprimez la toux / n.

2303
01:54:35,510 --> 01:54:37,170
Et je veux faire cela trois fois.

2304
01:54:37,170 --> 01:54:39,670
Je suis, bien sûr, tout va
copier et coller trois fois.

2305
01:54:39,670 --> 01:54:46,440
Je vais maintenant faire
Toux slash dot.

2306
01:54:46,440 --> 01:54:50,120
Allons me donner un peu plus d'espace
ici, Entrez, la toux, la toux, la toux.

2307
01:54:50,120 --> 01:54:53,970
>> Il y a, évidemment, déjà
possibilité d'amélioration.

2308
01:54:53,970 --> 01:54:55,679
Je l'ai copié et collé
quelques fois aujourd'hui.

2309
01:54:55,679 --> 01:54:58,261
Mais ce fut seulement alors je ne l'ai pas
avoir à taper autant de caractères.

2310
01:54:58,261 --> 01:55:00,250
J'ai changé encore ce
ces lignes de code sont.

2311
01:55:00,250 --> 01:55:04,240
>> Ces trois lignes sont identiques,
qui se sent paresseux et en effet est,

2312
01:55:04,240 --> 01:55:07,110
et est probablement pas la bonne approche.

2313
01:55:07,110 --> 01:55:11,029
Donc, avec ce que l'ingrédient
pourrions-nous améliorer ce code?

2314
01:55:11,029 --> 01:55:12,570
Nous ne devons pas copier et coller le code.

2315
01:55:12,570 --> 01:55:15,070
>> Et, en effet, chaque fois que vous vous sentez
vous copier-coller,

2316
01:55:15,070 --> 01:55:17,700
et même pas changer le code,
les chances sont qu'il ya une meilleure façon.

2317
01:55:17,700 --> 01:55:19,470
Et, en effet, il y a.

2318
01:55:19,470 --> 01:55:22,510
Laissez-moi aller de l'avant et faire une boucle,
même si la syntaxe peut-être pas

2319
01:55:22,510 --> 01:55:24,570
viennent naturellement encore.

2320
01:55:24,570 --> 01:55:29,494
>> Pour ce faire, trois fois, tout simplement
en faisant l'following--

2321
01:55:29,494 --> 01:55:31,160
et je sais cela de pratique.

2322
01:55:31,160 --> 01:55:32,810
Mais nous avons un certain nombre d'exemples maintenant.

2323
01:55:32,810 --> 01:55:34,950
Et vous verrez en ligne
références encore.

2324
01:55:34,950 --> 01:55:37,790
>> Ceci est la syntaxe sur la ligne 6, qui
un peu comme Scratch qui se répète

2325
01:55:37,790 --> 01:55:40,090
bloc, répéter les trois fois suivantes.

2326
01:55:40,090 --> 01:55:41,340
Il est un peu magique pour le moment.

2327
01:55:41,340 --> 01:55:43,050
Mais cela va obtenir plus,
et plus familier.

2328
01:55:43,050 --> 01:55:45,050
>> Et il va répéter
ligne de huit à trois reprises,

2329
01:55:45,050 --> 01:55:52,390
de sorte que si je re-compiler make toux,
dot slash toux, la toux, la toux, la toux.

2330
01:55:52,390 --> 01:55:54,030
Il fonctionne toujours de la même façon.

2331
01:55:54,030 --> 01:55:55,550
Donc, c'est tout beau et bon.

2332
01:55:55,550 --> 01:55:58,200
Mais ce n'est pas très abstraite.

2333
01:55:58,200 --> 01:55:59,371
>> Il est parfaitement correct.

2334
01:55:59,371 --> 01:56:01,370
Mais il se sent comme il
pourrait être l'occasion,

2335
01:56:01,370 --> 01:56:03,750
comme dans le monde
Scratch, au genre de début

2336
01:56:03,750 --> 01:56:07,530
d'ajouter une sémantique ici afin que
Je n'ai simplement pas une boucle,

2337
01:56:07,530 --> 01:56:09,867
et une fonction qui dit
toux, ou ne la toux.

2338
01:56:09,867 --> 01:56:10,450
Vous savez quoi?

2339
01:56:10,450 --> 01:56:12,620
Je vais essayer d'être un
peu plus frais que cela,

2340
01:56:12,620 --> 01:56:16,090
et en fait écrire une fonction qui
a certains effets secondaires, appeler la toux.

2341
01:56:16,090 --> 01:56:20,830
>> Et il ne prend pas d'entrée et
retourne pas de valeur en tant que sortie.

2342
01:56:20,830 --> 01:56:22,680
Mais vous savez ce qu'il fait?

2343
01:56:22,680 --> 01:56:29,370
Il fait this-- printf,
entre guillemets, toux.

2344
01:56:29,370 --> 01:56:32,380
>> Et maintenant ici, je vais
aller de l'avant et int,

2345
01:56:32,380 --> 01:56:36,070
i obtient zéro, i inférieur à 3, i plus plus.

2346
01:56:36,070 --> 01:56:39,770
Je vais pas faire printf, qui est
sans doute une implémentation de bas niveau

2347
01:56:39,770 --> 01:56:40,270
détail.

2348
01:56:40,270 --> 01:56:41,353
Je ne me soucie pas comment tousser.

2349
01:56:41,353 --> 01:56:43,240
Je veux juste utiliser la fonction de la toux.

2350
01:56:43,240 --> 01:56:44,840
Et je vais juste appeler la toux.

2351
01:56:44,840 --> 01:56:46,204
>> Maintenant, remarquez la dichotomie.

2352
01:56:46,204 --> 01:56:49,370
Lorsque vous appelez une fonction, si vous ne le faites pas
vouloir lui donner entrées, tout à fait bien.

2353
01:56:49,370 --> 01:56:51,780
Il suffit de faire paren ouvrir, fermer
paren, et vous avez terminé.

2354
01:56:51,780 --> 01:56:56,271
>> Lorsque vous définissez une fonction, ou
déclarer le prototype d'une fonction,

2355
01:56:56,271 --> 01:56:58,770
si vous savez à l'avance ce n'est pas
va prendre tous les arguments,

2356
01:56:58,770 --> 01:57:01,170
dire vide dans ces parenthèses là-bas.

2357
01:57:01,170 --> 01:57:05,660
Et cela fait certain que vous
ne sera pas accidentellement abuser.

2358
01:57:05,660 --> 01:57:07,020
Laissez-moi aller de l'avant et de faire la toux.

2359
01:57:07,020 --> 01:57:08,540
Et, bien sûr, je l'ai fait une erreur.

2360
01:57:08,540 --> 01:57:10,410
>> Zut, il n'y a que
déclaration implicite.

2361
01:57:10,410 --> 01:57:11,325
Mais ça va.

2362
01:57:11,325 --> 01:57:12,590
Il est une solution facile.

2363
01:57:12,590 --> 01:57:18,240
Je dois juste le prototype plus haut
dans mon dossier que je ne suis en fait l'utiliser.

2364
01:57:18,240 --> 01:57:20,070
>> Alors maintenant, permettez-moi de la toux à nouveau, agréable.

2365
01:57:20,070 --> 01:57:20,790
Maintenant ça marche.

2366
01:57:20,790 --> 01:57:22,930
Faire la toux, la toux, la toux, la toux.

2367
01:57:22,930 --> 01:57:25,930
Donc, vous pourriez penser que nous sommes vraiment
juste ingénierie sur ce problème.

2368
01:57:25,930 --> 01:57:26,763
Et, en effet, nous sommes.

2369
01:57:26,763 --> 01:57:28,870
Ce n'est pas un bon
candidat d'un programme

2370
01:57:28,870 --> 01:57:31,930
au moment de
refactoring, et faire ce qui est

2371
01:57:31,930 --> 01:57:35,645
appelée décomposition hiérarchique,
où vous prenez un peu de code, puis

2372
01:57:35,645 --> 01:57:38,790
vous genre de choses de facteurs, de sorte que
d'attribuer plus de sémantique pour eux,

2373
01:57:38,790 --> 01:57:40,930
et le réutiliser en fin de compte à plus long terme.

2374
01:57:40,930 --> 01:57:43,490
Mais il est un bloc de construction vers
des programmes plus sophistiqués

2375
01:57:43,490 --> 01:57:45,600
que nous allons commencer
écrit avant longtemps que

2376
01:57:45,600 --> 01:57:50,090
nous permet d'avoir le vocabulaire
avec lequel pour écrire un meilleur code.

2377
01:57:50,090 --> 01:57:52,920
Et, en effet, nous allons voir si nous
ne peut pas généraliser davantage.

2378
01:57:52,920 --> 01:57:57,984
>> Il semble un peu boiteux que je, principale,
à se soucier de cette bougresse boucle for,

2379
01:57:57,984 --> 01:57:59,400
et appeler encore et encore la toux.

2380
01:57:59,400 --> 01:58:03,050
Pourquoi ne puis-je dire à la toux,
s'il vous plaît tousser trois fois?

2381
01:58:03,050 --> 01:58:08,170
En d'autres termes, pourquoi je ne peux pas juste
apporter une contribution à tousser et à faire cela?

2382
01:58:08,170 --> 01:58:11,270
>> Pourquoi ne puis-je dire, en
la toux principale trois fois.

2383
01:58:11,270 --> 01:58:13,150
Et maintenant, cela est une sorte de magique.

2384
01:58:13,150 --> 01:58:14,540
Il est très itérative ici.

2385
01:58:14,540 --> 01:58:15,940
Et il est, en effet, une étape de bébé.

2386
01:58:15,940 --> 01:58:19,250
>> Mais la capacité à dire sur
ligne de huit, toux trois fois,

2387
01:58:19,250 --> 01:58:20,730
il est tellement plus lisible.

2388
01:58:20,730 --> 01:58:24,210
Et, plus, je ne dois pas savoir
ou de soin comment la toux est mis en œuvre.

2389
01:58:24,210 --> 01:58:26,460
Et, en effet, plus tard dans la
terme et pour les projets finaux,

2390
01:58:26,460 --> 01:58:29,150
si vous abordez un projet avec
un camarade de classe ou deux camarades de classe,

2391
01:58:29,150 --> 01:58:32,370
vous vous rendrez compte que vous allez
doivent, ou si vous voulez, diviser le travail.

2392
01:58:32,370 --> 01:58:34,650
>> Et vous allez vouloir décider
à l'avance, qui va faire quoi,

2393
01:58:34,650 --> 01:58:35,483
et dans lequel les pièces?

2394
01:58:35,483 --> 01:58:37,520
Et ne serait-il pas agréable
si vous, par exemple,

2395
01:58:37,520 --> 01:58:40,100
prendre en charge l'écriture principale, fait.

2396
01:58:40,100 --> 01:58:43,470
Et votre colocataire ou votre
partenaire plus généralement,

2397
01:58:43,470 --> 01:58:45,230
prend soin de mettre en œuvre la toux.

2398
01:58:45,230 --> 01:58:49,540
>> Et cette division, ceux-ci
murs de l'abstraction,

2399
01:58:49,540 --> 01:58:52,310
ou des couches d'abstraction si
vous, sont super puissant,

2400
01:58:52,310 --> 01:58:55,480
parce que surtout pour les plus grands,
plus de programmes et de systèmes complexes,

2401
01:58:55,480 --> 01:59:00,070
il permet à plusieurs personnes de construire
choses ensemble, et, finalement,

2402
01:59:00,070 --> 01:59:02,680
point leur travail ensemble de cette façon.

2403
01:59:02,680 --> 01:59:05,332
Mais, bien sûr, nous
besoin de fixer maintenant la toux.

2404
01:59:05,332 --> 01:59:07,290
Nous devons dire la toux
que, hé, vous savez quoi?

2405
01:59:07,290 --> 01:59:11,230
Vous allez avoir besoin de prendre un
input-- donc pas vide, mais int et maintenant.

2406
01:59:11,230 --> 01:59:15,170
Allons de l'avant et de mettre en
toux int. i obtient zéro.

2407
01:59:15,170 --> 01:59:16,890
>> i est inférieur à combien de fois.

2408
01:59:16,890 --> 01:59:18,550
Je l'ai dit trois avant.

2409
01:59:18,550 --> 01:59:20,420
Mais ce n'est pas ce que je veux.

2410
01:59:20,420 --> 01:59:25,520
Je veux tousser être généralisé à
soutenir un certain nombre d'itérations.

2411
01:59:25,520 --> 01:59:28,800
>> Donc, en effet, il est n que je veux,
quel que soit l'utilisateur me dit.

2412
01:59:28,800 --> 01:59:31,620
Maintenant, je peux aller de l'avant et dire imprimer la toux.

2413
01:59:31,620 --> 01:59:34,750
Et peu importe ce nombre
l'utilisateur passe,

2414
01:59:34,750 --> 01:59:36,890
J'itérer que de nombreuses fois.

2415
01:59:36,890 --> 01:59:39,160
>> Ainsi, à la fin de la journée,
programme est identique.

2416
01:59:39,160 --> 01:59:42,820
Mais remarquez tous ces trucs
pourrait même être dans un autre fichier.

2417
01:59:42,820 --> 01:59:45,620
En effet, je ne sais pas à la
instant comment printf est mis en œuvre.

2418
01:59:45,620 --> 01:59:47,980
>> Je ne sais pas pour le moment comment obtenir
chaîne, ou obtenir int, float ou obtenir

2419
01:59:47,980 --> 01:59:48,646
sont mises en oeuvre.

2420
01:59:48,646 --> 01:59:50,930
Et je ne veux pas
les voir sur mon écran.

2421
01:59:50,930 --> 01:59:55,320
Comme il est, je commence à se concentrer sur
mon programme, et non pas ces fonctions.

2422
01:59:55,320 --> 01:59:59,070
>> Et donc, en effet, dès que vous
commencer affacturage code comme ceci,

2423
01:59:59,070 --> 02:00:01,397
pourrions-nous déplacer même la toux
dans un fichier séparé?

2424
02:00:01,397 --> 02:00:02,730
Quelqu'un d'autre pourrait le mettre en œuvre.

2425
02:00:02,730 --> 02:00:06,810
Et vous et votre programme devenez
très beau, et très lisible,

2426
02:00:06,810 --> 02:00:10,830
sans doute, vraiment quatre
programme en ligne là.

2427
02:00:10,830 --> 02:00:13,510
>> Donc, nous allons aller de l'avant maintenant
et faire encore un changement.

2428
02:00:13,510 --> 02:00:16,180
Notez que mon prototype
doit changer en haut.

2429
02:00:16,180 --> 02:00:18,390
Alors permettez-moi de résoudre que tant
Je ne suis pas crié.

2430
02:00:18,390 --> 02:00:22,580
>> Faire la toux, permettez-moi de courir la toux, une fois
plus, toujours faire la même chose.

2431
02:00:22,580 --> 02:00:26,010
Mais maintenant, nous avons remarqué une
ingrédient pour une version finale.

2432
02:00:26,010 --> 02:00:26,940
Vous savez quoi?

2433
02:00:26,940 --> 02:00:29,040
Je ne veux pas de tousser juste, nécessairement.

2434
02:00:29,040 --> 02:00:30,802
Je veux avoir quelque chose de plus général.

2435
02:00:30,802 --> 02:00:31,510
Donc, vous savez quoi?

2436
02:00:31,510 --> 02:00:32,450
Je veux faire ça.

2437
02:00:32,450 --> 02:00:37,140
Je veux avoir, un peu comme Scratch
fait, un bloc de dire, mais pas seulement

2438
02:00:37,140 --> 02:00:38,680
dire quelque chose un certain nombre de fois.

2439
02:00:38,680 --> 02:00:41,510
Je veux dire une chaîne très spécifique.

2440
02:00:41,510 --> 02:00:43,850
Et, donc, je ne
voulez qu'il vient de dire la toux.

2441
02:00:43,850 --> 02:00:47,660
Je veux dire ce que
chaîne est passée dans.

2442
02:00:47,660 --> 02:00:49,960
>> Donc remarquer, j'ai généralisé
cette sorte que maintenant

2443
02:00:49,960 --> 02:00:53,110
dire se sent comme un bon nom
pour cela, comme Scratch,

2444
02:00:53,110 --> 02:00:55,530
prend deux arguments, à la différence Scratch.

2445
02:00:55,530 --> 02:00:56,570
La première est une chaîne.

2446
02:00:56,570 --> 02:00:57,300
L'un est un int.

2447
02:00:57,300 --> 02:00:58,130
>> Et je pourrais les passer.

2448
02:00:58,130 --> 02:01:00,713
Je viens un peu comme l'idée de
dire que la première chaîne, puis

2449
02:01:00,713 --> 02:01:01,940
combien de fois plus tard.

2450
02:01:01,940 --> 02:01:03,970
Void signifie qu'il reste
ne retourne rien.

2451
02:01:03,970 --> 02:01:06,428
Ce sont juste côté visuel
effets, comme avec [? Jordan,?]

2452
02:01:06,428 --> 02:01:08,240
un effet secondaire verbal de crier.

2453
02:01:08,240 --> 02:01:12,630
Il fait encore quelque chose n fois,
0 jusqu'à, mais pas égal à n.

2454
02:01:12,630 --> 02:01:14,540
Cela signifie que les temps n totaux.

2455
02:01:14,540 --> 02:01:16,540
Et puis juste imprimer
quelle que soit cette chaîne est.

2456
02:01:16,540 --> 02:01:19,060
Donc, je suis vraiment généralisé
cette ligne de code.

2457
02:01:19,060 --> 02:01:22,460
Alors maintenant, comment puis-je mettre en œuvre
la fonction de la toux?

2458
02:01:22,460 --> 02:01:25,520
>> Je peux faire la toux vide.

2459
02:01:25,520 --> 02:01:28,501
Et je peux encore prendre dans la façon
de nombreuses fois que vous voulez tousser.

2460
02:01:28,501 --> 02:01:29,250
Mais tu sais quoi?

2461
02:01:29,250 --> 02:01:31,240
Je peux maintenant dire punt.

2462
02:01:31,240 --> 02:01:36,540
>> Je peux appeler dire avec le
mot toux, en passant dans le n.

2463
02:01:36,540 --> 02:01:40,410
Et si je veux aussi mettre en œuvre,
juste pour le plaisir, une fonction d'éternuement,

2464
02:01:40,410 --> 02:01:42,290
Je peux éternuer un certain nombre de fois.

2465
02:01:42,290 --> 02:01:47,300
Et je peux continuer à réutiliser n, parce que
remarquer que m dans ce contexte ou étendue

2466
02:01:47,300 --> 02:01:49,470
existe uniquement dans cette fonction.

2467
02:01:49,470 --> 02:01:52,767
>> Et n dans ce contexte que
existe dans cette fonction ici.

2468
02:01:52,767 --> 02:01:54,600
Donc, nous allons y revenir
ces questions de portée.

2469
02:01:54,600 --> 02:02:01,160
Et ici, je vais juste dire,
Achoo, et ensuite n fois, point-virgule.

2470
02:02:01,160 --> 02:02:04,340
>> Et maintenant, je dois juste emprunter
ces fonctions signatures ici.

2471
02:02:04,340 --> 02:02:06,290
Donc, la toux est correcte.

2472
02:02:06,290 --> 02:02:10,090
éternuement Void est correct maintenant.

2473
02:02:10,090 --> 02:02:12,390
>> Et je reste juste besoin dire.

2474
02:02:12,390 --> 02:02:18,990
Donc, je vais dire, disons
chaîne s, int n, point-virgule.

2475
02:02:18,990 --> 02:02:22,010
Donc, je suis sur l'ingénierie de la
heck out de ce programme.

2476
02:02:22,010 --> 02:02:23,760
>> Et cela ne
nécessairement dire ceci est

2477
02:02:23,760 --> 02:02:26,343
ce que vous devez faire lors de l'écriture
même le plus simple des programmes.

2478
02:02:26,343 --> 02:02:29,280
Prenez quelque chose qui est évidemment
très simple, très court,

2479
02:02:29,280 --> 02:02:31,800
et re-mettre en œuvre
en utilisant beaucoup trop de code.

2480
02:02:31,800 --> 02:02:34,560
Mais vous allez vraiment voir, et
le temps de regarder en arrière sur ces exemples,

2481
02:02:34,560 --> 02:02:38,610
et de réaliser, oh, ce sont les étapes
nous avons pris réellement généraliser,

2482
02:02:38,610 --> 02:02:40,797
de tenir compte de quelque chose,
jusqu'à ce qu'à la fin de la journée

2483
02:02:40,797 --> 02:02:42,380
mon code est en fait assez raisonnable.

2484
02:02:42,380 --> 02:02:45,960
Parce que si je veux tousser trois
fois, puis éternuer trois fois,

2485
02:02:45,960 --> 02:02:50,420
Je vais simplement relancer cela,
programme faire la toux, et exécuter la toux.

2486
02:02:50,420 --> 02:02:53,620
Et j'ai trois toux
et trois éternue.

2487
02:02:53,620 --> 02:02:55,990
>> Et ceci est une base
paradigme, si vous voulez,

2488
02:02:55,990 --> 02:03:00,110
pour savoir comment nous pourrions aller sur
la mise en œuvre en fait un programme.

2489
02:03:00,110 --> 02:03:03,220
Mais nous allons voir tout à l'heure, il est
nous avons fait tout ce temps,

2490
02:03:03,220 --> 02:03:06,940
et ce que quelques-unes des pièces finales
sont derrière cette commande simple.

2491
02:03:06,940 --> 02:03:09,620
A la fin de la journée, nous avons
été en utilisant Clang comme notre compilateur.

2492
02:03:09,620 --> 02:03:11,494
Nous avons écrit la source
code, convertissant

2493
02:03:11,494 --> 02:03:12,820
via Clang en code machine.

2494
02:03:12,820 --> 02:03:15,540
>> Et nous avons utilisé Faites juste
pour faciliter nos frappes afin

2495
02:03:15,540 --> 02:03:20,740
que nous ne devons pas oublier
ces incantations de Clang lui-même.

2496
02:03:20,740 --> 02:03:22,640
Mais ce qui est réellement faire faire?

2497
02:03:22,640 --> 02:03:24,750
Et, à son tour, ce qui est
Clang en train de faire?

2498
02:03:24,750 --> 02:03:28,790
>> Il se trouve, bien que nous avons simplifié
la discussion d'aujourd'hui en disant:

2499
02:03:28,790 --> 02:03:33,090
vous prenez le code source, passez comme
entrée à un compilateur, qui vous donne

2500
02:03:33,090 --> 02:03:35,750
la sortie de la machine
code, se révèle-t-il de

2501
02:03:35,750 --> 02:03:37,420
à quelques pas différentes à l'intérieur il.

2502
02:03:37,420 --> 02:03:41,940
Et la compilation se trouve être le parapluie
terme pour tout un tas d'étapes.

2503
02:03:41,940 --> 02:03:43,970
Mais nous allons taquiner juste
ceci très rapidement.

2504
02:03:43,970 --> 02:03:48,070
>> Il se trouve que nous avons fait
plus de choses à chaque fois que je lance un programme,

2505
02:03:48,070 --> 02:03:50,990
ou chaque fois que je compile un programme aujourd'hui.

2506
02:03:50,990 --> 02:03:55,020
Donc, le prétraitement se réfère à
this-- quoi que ce soit dans un programme C,

2507
02:03:55,020 --> 02:03:58,720
comme nous le verrons encore et encore,
qui commence par ce symbole de hachage,

2508
02:03:58,720 --> 02:04:03,320
ou le symbole de hashtag ici, signifie
il est une directive de préprocesseur.

2509
02:04:03,320 --> 02:04:07,330
Cela signifie que, dans ce cas, hé
ordinateur, faire quelque chose avec ce fichier

2510
02:04:07,330 --> 02:04:09,430
avant de vous compilez mon propre code.

2511
02:04:09,430 --> 02:04:15,220
>> Dans ce cas, hachage include est,
essentiellement, la manière de C de dire,

2512
02:04:15,220 --> 02:04:19,325
hey ordinateur, allez obtenir le contenu
de CS50.h et collez-les ici.

2513
02:04:19,325 --> 02:04:22,170
Hey ordinateur, allez obtenir le
le contenu de la norme io.h,

2514
02:04:22,170 --> 02:04:24,690
où que ce soit sur la
disque dur, collez-le ici.

2515
02:04:24,690 --> 02:04:27,390
Donc, ces choses se produisent
première au cours du prétraitement.

2516
02:04:27,390 --> 02:04:28,880
>> Et Clang fait tout cela pour nous.

2517
02:04:28,880 --> 02:04:30,510
Et il le fait horriblement
rapide, vous faites même pas

2518
02:04:30,510 --> 02:04:32,000
voir quatre choses distinctes qui se passe.

2519
02:04:32,000 --> 02:04:34,100
Mais c'est la première telle étape.

2520
02:04:34,100 --> 02:04:35,560
>> Qu'est-ce qui se passe réellement à côté?

2521
02:04:35,560 --> 02:04:38,320
Eh bien, la prochaine officielle
étape est la compilation.

2522
02:04:38,320 --> 02:04:40,385
Et il se trouve que
compilation d'un programme

2523
02:04:40,385 --> 02:04:44,060
des moyens techniquement allant de
code source, les choses que nous avons

2524
02:04:44,060 --> 02:04:47,890
été écrit aujourd'hui, à quelque chose
appelé code assembleur, quelque chose

2525
02:04:47,890 --> 02:04:49,260
qui ressemble un peu différent.

2526
02:04:49,260 --> 02:04:51,050
>> Et, en fait, nous pouvons le voir très vite.

2527
02:04:51,050 --> 02:04:53,890
Permettez-moi de réellement entrer dans mon IDE.

2528
02:04:53,890 --> 02:04:58,050
Laissez-moi aller de l'avant et hello.c ouvert, qui
est le tout premier programme avec lequel nous

2529
02:04:58,050 --> 02:04:59,120
a commencé aujourd'hui.

2530
02:04:59,120 --> 02:05:04,130
Et laissez-moi aller de l'avant et d'exécuter un Clang
peu différemment, Clang-s, hello.c,

2531
02:05:04,130 --> 02:05:07,720
qui se passe réellement à
me donner un autre fichier hello.s.

2532
02:05:07,720 --> 02:05:10,330
>> Et nous le ferons probablement jamais
voir à nouveau ce genre de code.

2533
02:05:10,330 --> 02:05:13,030
Si vous prenez un niveau inférieur
classe de systèmes comme CS61,

2534
02:05:13,030 --> 02:05:14,920
vous verrez beaucoup plus
de ce genre de code.

2535
02:05:14,920 --> 02:05:17,020
Mais ceci est le langage d'assemblage.

2536
02:05:17,020 --> 02:05:22,050
Ceci est X86 langage d'assemblage
que l'unité centrale de traitement qui est sous-jacente

2537
02:05:22,050 --> 02:05:24,460
CS50 IDE comprend réellement.

2538
02:05:24,460 --> 02:05:27,060
>> Et cryptique comme il le fait
regardez, il est quelque chose

2539
02:05:27,060 --> 02:05:29,180
l'ordinateur comprend assez bien.

2540
02:05:29,180 --> 02:05:30,790
Sous q, ceci est une soustraction.

2541
02:05:30,790 --> 02:05:31,660
Il y a des mouvements.

2542
02:05:31,660 --> 02:05:35,730
>> Il y a d'appeler des fonctions ici,
x oring, un mouvement, un complément, un pop,

2543
02:05:35,730 --> 02:05:36,430
un retour.

2544
02:05:36,430 --> 02:05:38,850
Donc, il y a quelques très
instructions de bas niveau

2545
02:05:38,850 --> 02:05:41,280
que les processeurs comprennent que
J'y ai fait allusion plus tôt.

2546
02:05:41,280 --> 02:05:43,100
Voilà ce que Intel Inside.

2547
02:05:43,100 --> 02:05:45,030
>> Il existe des modèles de
zéros et de uns que

2548
02:05:45,030 --> 02:05:51,800
la carte à ces arcanely rédigé, mais
un peu bien nommé, des instructions,

2549
02:05:51,800 --> 02:05:52,780
pour ainsi dire.

2550
02:05:52,780 --> 02:05:54,780
Voilà ce qui arrive quand
vous compilez votre code.

2551
02:05:54,780 --> 02:05:58,560
Vous obtenez l'assemblage
langue hors de lui, qui

2552
02:05:58,560 --> 02:06:04,680
signifie la troisième étape consiste à assembler
que le code d'assemblage en fin de compte,

2553
02:06:04,680 --> 02:06:09,080
machines zéros et des uns, et non pas les code--
texte que nous venons de voir il y a un instant.

2554
02:06:09,080 --> 02:06:13,370
>> Donc, pré-traitement ne qui trouvent
et remplacer, et quelques autres choses.

2555
02:06:13,370 --> 02:06:16,430
Compiler prend source
le code de C, le code source

2556
02:06:16,430 --> 02:06:18,980
que nous avons écrit, à l'assemblage
Code que nous venons jeta un regard.

2557
02:06:18,980 --> 02:06:22,170
Assemblage prend cette assemblée
code zéros et des uns

2558
02:06:22,170 --> 02:06:24,680
que le CPU va vraiment
comprendre à la fin de la journée.

2559
02:06:24,680 --> 02:06:27,630
Et la liaison est la dernière étape
cela se produit pour us-- à nouveau,

2560
02:06:27,630 --> 02:06:29,830
si vite que nous ne le faisons pas même
notice-- qui dit,

2561
02:06:29,830 --> 02:06:32,460
hey ordinateur, prendre toutes
les zéros et ceux qui

2562
02:06:32,460 --> 02:06:36,750
le résultat de la compilation du code de David,
et sa fonction principale dans ce cas.

2563
02:06:36,750 --> 02:06:39,160
>> Et hey ordinateur, aller chercher
tous les zéros et

2564
02:06:39,160 --> 02:06:42,180
que le personnel a écrit CS50
à l'intérieur de la bibliothèque de CS50.

2565
02:06:42,180 --> 02:06:43,440
Mélanger ceux avec David.

2566
02:06:43,440 --> 02:06:46,648
Et hé ordinateur, allez obtenir tous les zéros
et ceux que quelqu'un d'autre a écrit années

2567
02:06:46,648 --> 02:06:47,470
Il y a pour printf.

2568
02:06:47,470 --> 02:06:49,880
Et d'ajouter ceux dans le
chose ensemble, de sorte que nous avons

2569
02:06:49,880 --> 02:06:52,870
obtenu mes zéros et des uns, la
les zéros et les uns du personnel CS50,

2570
02:06:52,870 --> 02:06:55,370
les zéros printf et ceux,
et tout ce que nous utilisons.

2571
02:06:55,370 --> 02:07:00,410
>> Ils ont tous se combiner en une seule
programme appelé, dans ce cas, bonjour.

2572
02:07:00,410 --> 02:07:03,141
Donc désormais, nous allons tout simplement
utiliser le mot compilation.

2573
02:07:03,141 --> 02:07:06,390
Et nous prendrons pour acquis que lorsque
nous disons, compiler votre programme, cela signifie,

2574
02:07:06,390 --> 02:07:08,849
hey faire le pré-traitement,
l'assemblage et la liaison.

2575
02:07:08,849 --> 02:07:11,890
Mais il y a effectivement quelques trucs juteux
passe là-bas sous le capot.

2576
02:07:11,890 --> 02:07:13,723
Et surtout si vous
obtenir curieux un certain temps,

2577
02:07:13,723 --> 02:07:15,900
vous pouvez commencer à piquer
autour de ce niveau inférieur.

2578
02:07:15,900 --> 02:07:19,660
Mais pour l'instant, se rendre compte que
parmi les plats à emporter pour aujourd'hui

2579
02:07:19,660 --> 02:07:23,420
sont tout simplement
début d'un processus,

2580
02:07:23,420 --> 02:07:26,700
de se familiariser avec
quelque chose comme bonjour monde.

2581
02:07:26,700 --> 02:07:29,575
En effet, la plupart de ce que nous avons fait aujourd'hui
ne sera certainement pas sombrer dans super rapide.

2582
02:07:29,575 --> 02:07:31,491
Et il faudra un certain
le temps, et une certaine pratique.

2583
02:07:31,491 --> 02:07:33,864
Et les chances sont, vous triez
de vouloir frapper votre clavier

2584
02:07:33,864 --> 02:07:34,780
ou crier à l'écran.

2585
02:07:34,780 --> 02:07:35,880
Et tout cela est OK.

2586
02:07:35,880 --> 02:07:38,320
Bien, peut-être essayer de ne pas
le faire dans la bibliothèque tellement.

2587
02:07:38,320 --> 02:07:40,820
>> Et en fin de compte, vous aurez
être en mesure cependant, pour commencer

2588
02:07:40,820 --> 02:07:44,580
voir les modèles, aussi bien dans un bon code
que vous avez écrit et erreurs

2589
02:07:44,580 --> 02:07:45,370
que vous avez fait.

2590
02:07:45,370 --> 02:07:48,965
Et tout comme le processus de
devient un TF ou CA est comme,

2591
02:07:48,965 --> 02:07:51,590
vous allez commencer à aller mieux et
mieux de voir ces modèles,

2592
02:07:51,590 --> 02:07:53,774
et juste la résolution de votre
en fin de compte des problèmes propres.

2593
02:07:53,774 --> 02:07:56,940
En attendant, il y aura beaucoup
nous vous prêter assistance, et vous obtenez

2594
02:07:56,940 --> 02:07:57,481
à travers cela.

2595
02:07:57,481 --> 02:07:59,450
Et dans les comptes-rendus
pour tous les problèmes

2596
02:07:59,450 --> 02:08:01,366
vous serez guidé à travers
toutes les commandes

2597
02:08:01,366 --> 02:08:05,330
que je sais certainement de
beaucoup de pratique maintenant,

2598
02:08:05,330 --> 02:08:07,380
mais pourrait avoir volé
dessus de la tête pour l'instant.

2599
02:08:07,380 --> 02:08:08,580
Et c'est tout à fait bien.

2600
02:08:08,580 --> 02:08:11,230
>> Mais, en fin de compte, vous allez
pour commencer à voir des tendances émergent.

2601
02:08:11,230 --> 02:08:14,260
Et une fois que vous avez passé tous les
détails stupides, comme entre parenthèses,

2602
02:08:14,260 --> 02:08:16,710
et des accolades et des points-virgules,
et les choses, franchement,

2603
02:08:16,710 --> 02:08:19,360
ce n'est pas du tout
intellectuellement intéressant.

2604
02:08:19,360 --> 02:08:22,690
Et il est pas l'objectif de
prendre une classe d'introduction.

2605
02:08:22,690 --> 02:08:24,410
Ce sont les idées qui vont à la matière.

2606
02:08:24,410 --> 02:08:26,659
>> Ce sont les boucles, et
les conditions et les fonctions,

2607
02:08:26,659 --> 02:08:30,552
et plus puissamment l'abstraction,
et l'affacturage de code,

2608
02:08:30,552 --> 02:08:33,510
et la bonne conception, et le bon
le style, et, finalement, l'exactitude

2609
02:08:33,510 --> 02:08:37,330
de votre code, qui est en fin de compte
aller à la matière le plus.

2610
02:08:37,330 --> 02:08:40,925
Donc, la semaine prochaine, nous allons prendre ces
idées que nous avons vu la première fois en Scratch

2611
02:08:40,925 --> 02:08:42,800
et ont maintenant traduit
C. Et nous allons commencer

2612
02:08:42,800 --> 02:08:45,740
à introduire le premier de la
monde réel les domaines de cours.

2613
02:08:45,740 --> 02:08:50,140
>> Nous allons nous concentrer sur le monde de la sécurité,
et la cryptographie plus spécifiquement,

2614
02:08:50,140 --> 02:08:51,980
l'art de brouiller l'information.

2615
02:08:51,980 --> 02:08:54,000
Et parmi les premiers
problèmes vous-même

2616
02:08:54,000 --> 02:08:56,840
se rendre à écrire au delà
en jouant avec une partie de la syntaxe

2617
02:08:56,840 --> 02:08:59,880
et la résolution de certains logique
problèmes, en fin de compte avant longtemps,

2618
02:08:59,880 --> 02:09:03,960
est de brouiller effectivement, ou chiffrer,
et, finalement, décrypter les informations.

2619
02:09:03,960 --> 02:09:06,470
Et tout ce que nous avons fait
aujourd'hui, sera assez faible

2620
02:09:06,470 --> 02:09:09,190
niveau, va tout simplement pour permettre
nous prenons un, et un,

2621
02:09:09,190 --> 02:09:13,550
et une étape de plus vers ci-dessus
écrit encore le code le plus intéressant.

2622
02:09:13,550 --> 02:09:15,050
>> Donc, plus sur que la semaine prochaine.

2623
02:09:15,050 --> 02:09:17,834

2624
02:09:17,834 --> 02:09:18,762
>> [LECTURE VIDÉO]

2625
02:09:18,762 --> 02:09:19,690

2626
02:09:19,690 --> 02:09:22,006
>> -Quel Pouvez-vous me dire au sujet
la dernière fois que vous l'avez vu?

2627
02:09:22,006 --> 02:09:26,041

2628
02:09:26,041 --> 02:09:27,040
-Qu'est Ce que je peux dire, vraiment?

2629
02:09:27,040 --> 02:09:30,500

2630
02:09:30,500 --> 02:09:35,340
Je veux dire, il était comme tout autre
répétition de pré-production,

2631
02:09:35,340 --> 02:09:40,510
sauf qu'il y avait quelque chose qu'il a dit
à la fin qui a collé avec moi.

2632
02:09:40,510 --> 02:09:44,810

2633
02:09:44,810 --> 02:09:46,640
>> -Ce Était CS50.

2634
02:09:46,640 --> 02:09:49,440

2635
02:09:49,440 --> 02:09:52,190
>> -C'est Une coupe tout le monde,
excellent travail sur la répétition.

2636
02:09:52,190 --> 02:09:53,070
>> le déjeuner de -Que?

2637
02:09:53,070 --> 02:09:54,986
>> -Oui, Vous et je peux
prendre un sandwich dans un peu.

2638
02:09:54,986 --> 02:09:58,380
Permettez-moi de reprendre avec
David très rapidement.

2639
02:09:58,380 --> 02:09:59,160
David?

2640
02:09:59,160 --> 02:10:01,260
David?

2641
02:10:01,260 --> 02:10:03,110
>> [FIN LECTURE]

