1
00:00:00,000 --> 00:00:00,000

2
00:00:00,000 --> 00:00:00,000
[音乐]

3
00:00:00,000 --> 00:00:13,950

4
00:00:13,950 --> 00:00:16,240
>> DAVID J. MALAN：好吧，这是CS50。

5
00:00:16,240 --> 00:00:18,010
而这是一个星期。

6
00:00:18,010 --> 00:00:22,050
所以，记得最后一次是在零一周，
我们专注于计算思维。

7
00:00:22,050 --> 00:00:25,440
而我们从转变，要
从无到有，图形化编程

8
00:00:25,440 --> 00:00:27,360
从我们的朋友的语言
在麻省理工学院的媒体实验室。

9
00:00:27,360 --> 00:00:31,730
>> 并与划痕，没有我们探讨
想法一样的功能，和条件，

10
00:00:31,730 --> 00:00:35,210
和循环，和变量，甚至
事件，以及线程，以及更多。

11
00:00:35,210 --> 00:00:37,880
而今天，我们要
继续使用这些想法，

12
00:00:37,880 --> 00:00:40,630
真正带他们
理所当然，但他们翻译

13
00:00:40,630 --> 00:00:44,220
被称为现在C.另一种语言，
C是一个更传统的语言。

14
00:00:44,220 --> 00:00:46,020
这是一个较低的水平
语言，如果你愿意。

15
00:00:46,020 --> 00:00:47,300
>> 这纯粹是文字。

16
00:00:47,300 --> 00:00:49,910
所以乍看之下，它的
一切都将看起来相当神秘

17
00:00:49,910 --> 00:00:51,430
如果你从来没有编程。

18
00:00:51,430 --> 00:00:53,530
我们将有
分号和括号，

19
00:00:53,530 --> 00:00:55,150
和大括号，等等。

20
00:00:55,150 --> 00:00:57,240
但是认识到，即使
虽然语法

21
00:00:57,240 --> 00:01:00,600
即将看起来有点陌生
大多数的你，看过去那种。

22
00:01:00,600 --> 00:01:03,220
并尝试看看的想法
这的确都是熟悉的，

23
00:01:03,220 --> 00:01:06,750
因为在这里每周有什么
我们将开始做的是比较，

24
00:01:06,750 --> 00:01:08,980
最初，耐刮与C.

25
00:01:08,980 --> 00:01:12,350
>> 所以，举例来说，回想一下，当我们
实现了第一个我们的节目

26
00:01:12,350 --> 00:01:16,220
最后一次，我们有看起来块
有点像this--时

27
00:01:16,220 --> 00:01:19,990
绿旗点击，然后我们有
一个或多个拼图在它下面，

28
00:01:19,990 --> 00:01:22,150
在这种情况下，就是说，世界你好。

29
00:01:22,150 --> 00:01:24,870
因此，事实上，在划痕，
当我点击了绿色环保标志

30
00:01:24,870 --> 00:01:27,390
运行我的程序，所以
可以说，这些都是

31
00:01:27,390 --> 00:01:29,520
得到执行的块，或运行。

32
00:01:29,520 --> 00:01:32,230
和，特别是，临时
说，你好，世界。

33
00:01:32,230 --> 00:01:35,377
>> 现在，我可以指定
这里不同的话。

34
00:01:35,377 --> 00:01:37,960
但是我们会发现，事实上，许多
这些blocks--确实的，

35
00:01:37,960 --> 00:01:41,880
用C许多functions--可
参数化或定制

36
00:01:41,880 --> 00:01:43,150
做不同的事情。

37
00:01:43,150 --> 00:01:45,520
事实上，在C，如果我们
要转换，现在，

38
00:01:45,520 --> 00:01:47,567
这耐刮划
这个其他语言，

39
00:01:47,567 --> 00:01:49,650
我们将写一
小这样的事情。

40
00:01:49,650 --> 00:01:52,540
>> 当然，有一些陌生
语法有最有可能，INT，

41
00:01:52,540 --> 00:01:54,380
和括号，和无效的。

42
00:01:54,380 --> 00:01:57,740
但是，尽管你甚至会printf--
认为这将只是打印。

43
00:01:57,740 --> 00:02:00,120
但是打印表示打印
格式化，因为我们很快就会看到。

44
00:02:00,120 --> 00:02:02,140
这从字面上将打印
到屏幕上的任何

45
00:02:02,140 --> 00:02:05,990
是那些括号内，这
当然，在这种情况下，世界你好。

46
00:02:05,990 --> 00:02:09,290
>> 但你会发现一些其他的
语法，一些双引号，

47
00:02:09,290 --> 00:02:11,890
，在结束括号，
分号等。

48
00:02:11,890 --> 00:02:15,027
因此，有一点开销，
可以这么说，无论是认知

49
00:02:15,027 --> 00:02:17,860
和语法，我们要去
有不久记住。

50
00:02:17,860 --> 00:02:20,720
但要意识到联系实际，
这将开始在你跳出来。

51
00:02:20,720 --> 00:02:24,920
>> 事实上，让我们专注于一个
功能specifically--在这种情况下，

52
00:02:24,920 --> 00:02:26,290
打招呼的世界。

53
00:02:26,290 --> 00:02:27,560
所以说是功能。

54
00:02:27,560 --> 00:02:31,320
你好世界是它的参数，
或参数，它的定制。

55
00:02:31,320 --> 00:02:34,320
>> 而在C中的等价只是
要在这里成为这一行，

56
00:02:34,320 --> 00:02:38,710
在这里的printf相当于，说，
双引号字符串，你好

57
00:02:38,710 --> 00:02:41,470
世界是等效的，当然，
什么是在白框那里。

58
00:02:41,470 --> 00:02:45,680
和反斜线N，虽然有点
奇怪的并从头缺席，

59
00:02:45,680 --> 00:02:49,380
简单地说就是将有我们的影响
看到一台电脑，像我的Mac或PC，

60
00:02:49,380 --> 00:02:51,660
只是移动
光标移到下一行。

61
00:02:51,660 --> 00:02:53,970
这就像打
键盘上的Enter。

62
00:02:53,970 --> 00:02:55,580
>> 因此，我们将不久再次看到这一点。

63
00:02:55,580 --> 00:02:58,640
但首先，让我们来看看这个
在循环的情况下，其他的例子。

64
00:02:58,640 --> 00:03:02,830
我们有这样永远循环最后一次，
这是一系列的拼图

65
00:03:02,830 --> 00:03:05,490
那做了字面上
forever--在这种情况下，

66
00:03:05,490 --> 00:03:08,360
说，你好世界，你好世界，
世界你好，你好世界。

67
00:03:08,360 --> 00:03:10,350
所以这是设计一个无限循环。

68
00:03:10,350 --> 00:03:14,580
>> 在C中，如果我们想实现这个
同样的想法，我们可以简单地做到这一点。

69
00:03:14,580 --> 00:03:19,570
虽然如此，printf的招呼现在天下 -
同时，刚刚语义，那种

70
00:03:19,570 --> 00:03:23,090
联想到做的念头
重复的事情，又一次，又一次，

71
00:03:23,090 --> 00:03:23,980
多长时间？

72
00:03:23,980 --> 00:03:27,990
那么，true--回忆一下，
真正是刚上或1。

73
00:03:27,990 --> 00:03:30,660
>> 而真正的，当然，总是如此。

74
00:03:30,660 --> 00:03:33,060
所以这是一种毫无意义的
声明只是说真的。

75
00:03:33,060 --> 00:03:36,890
但事实上，这是故意的，
因为如果真的仅仅是总是正确的，

76
00:03:36,890 --> 00:03:40,850
而不是真正的就是意味着，
如果有点间接的，

77
00:03:40,850 --> 00:03:44,070
那下面的代码行
在这些大括号

78
00:03:44,070 --> 00:03:48,320
应该只是又一次，又一次执行，
又一次，从来没有真正停止。

79
00:03:48,320 --> 00:03:50,230
>> 但是，如果你希望你的
循环停止，因为我们

80
00:03:50,230 --> 00:03:54,500
跟上次喜欢的东西
这种重复以下50次，

81
00:03:54,500 --> 00:03:57,700
用C我们可以做什么是相同的
被称为为loop--关键字

82
00:03:57,700 --> 00:03:59,330
不是一阵子，而是。

83
00:03:59,330 --> 00:04:03,290
然后，我们有一些新的语法在这里，
使用int i等于0，我不到50，

84
00:04:03,290 --> 00:04:03,880
我++。

85
00:04:03,880 --> 00:04:05,430
我们会回来这一点。

86
00:04:05,430 --> 00:04:09,660
但是，这仅仅是我们如何会
翻译组划痕块

87
00:04:09,660 --> 00:04:13,079
一组的码C的行。

88
00:04:13,079 --> 00:04:14,450
>> 同时，考虑的变量。

89
00:04:14,450 --> 00:04:16,540
而且，事实上，我们只是
看见一个人刚才。

90
00:04:16,540 --> 00:04:21,220
并且在暂存的情况下，如果我们
要声明一个叫做变量i

91
00:04:21,220 --> 00:04:24,590
因为我是整数，只是一个数字，
我们希望将它设置为某个值，

92
00:04:24,590 --> 00:04:28,410
我们将使用这个橙色
阻断这里 - 我设置为0。

93
00:04:28,410 --> 00:04:30,800
>> 而我们今天将看到和
超越，就像上周，

94
00:04:30,800 --> 00:04:33,850
程序员做几乎总是
从零开始计数，真

95
00:04:33,850 --> 00:04:34,950
按照惯例。

96
00:04:34,950 --> 00:04:37,250
但也因为召回
我们的二元讨论，

97
00:04:37,250 --> 00:04:39,990
最小的号码，你可以
用任何数目的位表示

98
00:04:39,990 --> 00:04:41,640
只是将是0本身。

99
00:04:41,640 --> 00:04:45,190
所以，我们通常会开始
即使初始化我们的变量为0。

100
00:04:45,190 --> 00:04:47,710
>> 而在C ++做的一样，
我们会说INT

101
00:04:47,710 --> 00:04:50,110
为整数，我只是按照惯例。

102
00:04:50,110 --> 00:04:53,390
我可以叫这个变量
任何我想要的，就像在刮。

103
00:04:53,390 --> 00:04:57,770
然后等于0只是受让人
从右侧的值0

104
00:04:57,770 --> 00:05:01,319
并将其放入变量，或
储存容器有，在左侧。

105
00:05:01,319 --> 00:05:04,360
和分号，我们会see--和
我们已经看到了一些这些already--的

106
00:05:04,360 --> 00:05:06,530
只是意味着思想的终结。

107
00:05:06,530 --> 00:05:09,430
继续做别的事情
在接下来的线。

108
00:05:09,430 --> 00:05:11,330
>> 现在，关于布尔表达式？

109
00:05:11,330 --> 00:05:14,320
回想一下，在刮，
这些人表情

110
00:05:14,320 --> 00:05:16,740
那些是真
或false--问题，

111
00:05:16,740 --> 00:05:18,910
真的，要么是真还是假。

112
00:05:18,910 --> 00:05:21,960
因此，在划痕的情况下，我们可能
问一个简单的问题，这样，

113
00:05:21,960 --> 00:05:24,586
为i小于50？

114
00:05:24,586 --> 00:05:25,710
所以我，再次是整数。

115
00:05:25,710 --> 00:05:27,210
也许我们正在使用它
在临时计划

116
00:05:27,210 --> 00:05:29,310
保持比分的轨道
或类似的东西。

117
00:05:29,310 --> 00:05:33,810
所以这个语法在这里划痕
只是手段，是我不到50？

118
00:05:33,810 --> 00:05:37,330
好了，幸运的是，事情是
简单的C。和翻译，

119
00:05:37,330 --> 00:05:41,780
这一点，我们就简单的说我少
50，使用熟悉的关键

120
00:05:41,780 --> 00:05:42,850
键盘上。

121
00:05:42,850 --> 00:05:45,141
>> 同时，如果你想
说一些比较一般，

122
00:05:45,141 --> 00:05:49,890
像，很好，比y这里每个x少
x和y的本身变量？

123
00:05:49,890 --> 00:05:52,280
我们可以做同样的事情
在C，只要我们已经

124
00:05:52,280 --> 00:05:53,942
创建这些变量了。

125
00:05:53,942 --> 00:05:55,650
我们将看到如何
这样做不久。

126
00:05:55,650 --> 00:05:58,590
我们就简单的说比Y X更少。

127
00:05:58,590 --> 00:06:00,530
>> 所以，你开始
看到一些相似之处。

128
00:06:00,530 --> 00:06:03,490
和谁做那些人
从无到有是肯定

129
00:06:03,490 --> 00:06:05,250
通过其中的一些基本思想的启发。

130
00:06:05,250 --> 00:06:10,350
你会看到这样的
语法在很多languages​​--

131
00:06:10,350 --> 00:06:12,160
不只是划伤，
只是C，但是Python，

132
00:06:12,160 --> 00:06:14,790
和JavaScript，以及
其他语言依旧。

133
00:06:14,790 --> 00:06:18,270
>> 让我们考虑另一种结构
从C，条件的概念，

134
00:06:18,270 --> 00:06:20,370
做一些有条件。

135
00:06:20,370 --> 00:06:22,720
如果事情是真的，做到这一点。

136
00:06:22,720 --> 00:06:24,457
如果别的东西是真实的，做到这一点。

137
00:06:24,457 --> 00:06:27,040
这有点编程的
在一个岔路口的等价物。

138
00:06:27,040 --> 00:06:29,730
也许这是一个叉双向的，
三通叉，或更多。

139
00:06:29,730 --> 00:06:32,800
而在划痕，我们可能有
看到这样的事情。

140
00:06:32,800 --> 00:06:34,010
>> 所以这一块是一个大的。

141
00:06:34,010 --> 00:06:36,750
但考虑到相对
逻辑简单性。

142
00:06:36,750 --> 00:06:44,010
如果x小于y，然后说x是少
比Y，否则如果x大于y，

143
00:06:44,010 --> 00:06:46,230
然后说x是大于y。

144
00:06:46,230 --> 00:06:48,300
然后，在逻辑上，如果，
回想一下划痕

145
00:06:48,300 --> 00:06:52,610
或者只是你自己的人的直觉，
好吧，如果x不大于y，并且x

146
00:06:52,610 --> 00:06:57,000
不除Y更小，则当然
x被将是等于y。

147
00:06:57,000 --> 00:06:59,690
因此，在这种情况下，通过嵌套
这些划痕块，

148
00:06:59,690 --> 00:07:02,580
我们可以实现一个三
在行进的方式叉？

149
00:07:02,580 --> 00:07:04,980
>> 同时，如果我们想
这样做，在C，它可以说是

150
00:07:04,980 --> 00:07:08,420
看起来至少有一点simpler--
一旦你熟悉的语法。

151
00:07:08,420 --> 00:07:12,050
如果x小于y，
printf的x是小于y。

152
00:07:12,050 --> 00:07:16,140
否则如果x大于y，
printf的x是大于y。

153
00:07:16,140 --> 00:07:21,210
其他的printf x等于y--和，
再次，与那些反斜杠只

154
00:07:21,210 --> 00:07:24,160
对于这些新的生产线，这样，如果你
居然跑这种方案

155
00:07:24,160 --> 00:07:25,940
它只是移动
光标最终

156
00:07:25,940 --> 00:07:28,100
到屏幕的下一行。

157
00:07:28,100 --> 00:07:31,270
>> 现在，同时有划痕等
更复杂的功能，只

158
00:07:31,270 --> 00:07:34,320
其中有些我们要
最初移动到C的世界

159
00:07:34,320 --> 00:07:37,010
其中之一是
称为划痕列表。

160
00:07:37,010 --> 00:07:39,100
这是一个特殊的
变量的类型

161
00:07:39,100 --> 00:07:42,840
允许你存储多个事
在回来，背，背，背。

162
00:07:42,840 --> 00:07:45,540
>> 在C中，它不具有
名单，本身的事，但

163
00:07:45,540 --> 00:07:48,090
是更一般
所谓的阵列，虽然我们

164
00:07:48,090 --> 00:07:50,590
回来以后这个学期
要寻找的东西

165
00:07:50,590 --> 00:07:52,780
所谓的名单，还是真的链表。

166
00:07:52,780 --> 00:07:55,510
但现在，最接近
相当于C语言为我们

167
00:07:55,510 --> 00:07:57,345
会是什么
称为阵列。

168
00:07:57,345 --> 00:07:59,740
和阵列是一个简单的
特殊类型的可变的

169
00:07:59,740 --> 00:08:03,160
这允许你存储数据
背，背，背，背到。

170
00:08:03,160 --> 00:08:05,840
>> 而且，事实上，在划痕，
如果我们想访问

171
00:08:05,840 --> 00:08:09,030
数组的第一元素或
一个列表中 - 我要去称呼它，

172
00:08:09,030 --> 00:08:13,600
按照惯例，argv的，说法
矢量，但不久还有更多。

173
00:08:13,600 --> 00:08:17,090
如果我想要得到的第一个元素
ARGV的，在刮的世界

174
00:08:17,090 --> 00:08:20,930
你实际上做一般
从1开始计数。

175
00:08:20,930 --> 00:08:22,850
>> 所以，我可能会得到argv的第1项。

176
00:08:22,850 --> 00:08:26,310
这是麻省理工学院的只是如何实现的
列表的概念。

177
00:08:26,310 --> 00:08:29,860
但在C，我要去
更简单地只是说，ARGV，

178
00:08:29,860 --> 00:08:32,758
这又是对我的名字
列表中 - 或者是明确的，一个数组。

179
00:08:32,758 --> 00:08:34,549
如果我想第一
元素，我要去

180
00:08:34,549 --> 00:08:37,890
用方括号，你
可能不会经常键盘下使用。

181
00:08:37,890 --> 00:08:40,150
>> 但是，0只是意味着，拿到我的第一。

182
00:08:40,150 --> 00:08:42,160
等等场合和
久而久之，我们要去

183
00:08:42,160 --> 00:08:44,570
开始看到这些二分法
划痕和C之间，

184
00:08:44,570 --> 00:08:46,070
即刮使用一个。

185
00:08:46,070 --> 00:08:47,670
我们用C在这里使用0。

186
00:08:47,670 --> 00:08:49,420
但你会很快看到
一旦你理解

187
00:08:49,420 --> 00:08:52,920
每种语言的基础，即
这些事情开始变得更加

188
00:08:52,920 --> 00:08:56,860
熟悉通过实践和实践。

189
00:08:56,860 --> 00:08:59,700
>> 因此，让我们实际上是在一个程序现在看起来。

190
00:08:59,700 --> 00:09:04,031
这里应是第一个我们的C
完整程序的源代码。

191
00:09:04,031 --> 00:09:06,280
而该计划，我们要去
提供审议

192
00:09:06,280 --> 00:09:09,340
就是这相当于一个
那个早期的刮片。

193
00:09:09,340 --> 00:09:13,210
>> 所以在这里，我们有什么
可以说是最简单的C程序

194
00:09:13,210 --> 00:09:15,410
你可以写
实际上做什么。

195
00:09:15,410 --> 00:09:18,250
现在，我们来看看过去，
现在，已经包括，

196
00:09:18,250 --> 00:09:21,190
标准io.h，而这些角度
括号和int和无效的，

197
00:09:21,190 --> 00:09:22,840
及大括号，和类似物。

198
00:09:22,840 --> 00:09:25,390
>> 而我们只专注于
什么，至少直觉，

199
00:09:25,390 --> 00:09:26,860
可能会对你已经跳出。

200
00:09:26,860 --> 00:09:30,300
事实上，主要的，我不知道
一定知道这是什么，

201
00:09:30,300 --> 00:09:34,580
但就像刮了，当
绿旗点击拼图，

202
00:09:34,580 --> 00:09:39,070
这样做C作为编程语言
有一个主一段代码，

203
00:09:39,070 --> 00:09:43,380
被默认执行。而且，事实上，
它字面上将被称为主。

204
00:09:43,380 --> 00:09:44,720
>> 所以主要是一个函数。

205
00:09:44,720 --> 00:09:48,720
而且它是一个真实存在的特殊功能
用C，当你运行一个程序，

206
00:09:48,720 --> 00:09:52,720
它是由被主运行
默认。在划痕的世界里，

207
00:09:52,720 --> 00:09:56,970
它通常是，当绿旗
点击的得到了默认情况下运行。

208
00:09:56,970 --> 00:10:01,130
>> 同时，我们已经见过这个，
printf的或打印的格式，这是

209
00:10:01,130 --> 00:10:05,620
也会有一些自带的功能
C，伴随着一大堆别人的，

210
00:10:05,620 --> 00:10:10,140
从时间和时间的意愿
再次，为了准确地做

211
00:10:10,140 --> 00:10:12,450
正如它的名字所暗示的，打印的东西。

212
00:10:12,450 --> 00:10:13,500
我们究竟要打印？

213
00:10:13,500 --> 00:10:15,770
好吧，我们会看到，
由封闭字符

214
00:10:15,770 --> 00:10:18,680
像these--世界你好，
反斜杠n的双引号，

215
00:10:18,680 --> 00:10:23,040
我们可以告诉准确的printf
什么要打印在屏幕上。

216
00:10:23,040 --> 00:10:26,430
>> 但为了做
这一点，我们很遗憾

217
00:10:26,430 --> 00:10:30,010
需要采取的东西是
已经隐晦了我们人类，

218
00:10:30,010 --> 00:10:34,510
但至少它有点readable--
犀利包括标准io.h，INT，

219
00:10:34,510 --> 00:10:39,340
主要的，无效的printf，所有的神奇
咒语刚才我们看到在屏幕上。

220
00:10:39,340 --> 00:10:42,470
但是实际上我们要
走得更神秘依旧。

221
00:10:42,470 --> 00:10:47,140
我们首先需要翻译的代码
我们编写成机器代码。

222
00:10:47,140 --> 00:10:51,370
而从上周回顾机，
至少那些我们知道这里，

223
00:10:51,370 --> 00:10:54,450
在一天结束的时候只
了解零和一。

224
00:10:54,450 --> 00:10:58,100
>> 我的上帝，如果我们写这些
零和的实际计划，

225
00:10:58,100 --> 00:11:01,260
它会非常快
采取乐趣的事情。

226
00:11:01,260 --> 00:11:05,150
但事实证明，每上周，
该零和一的这些模式

227
00:11:05,150 --> 00:11:06,400
只是有特殊的意义。

228
00:11:06,400 --> 00:11:08,500
在某些情况下，
他们可能意味着数。

229
00:11:08,500 --> 00:11:11,840
>> 在某些情况下，它们可能意味着
字母或颜色，或任何数目的

230
00:11:11,840 --> 00:11:14,710
其他抽象存在于。

231
00:11:14,710 --> 00:11:18,450
但是，就像你的电脑有
一个CPU，中央处理单元，

232
00:11:18,450 --> 00:11:20,390
或您的计算机内的大脑。

233
00:11:20,390 --> 00:11:22,240
它通常是英特尔
在里面，因为这是

234
00:11:22,240 --> 00:11:24,900
最大的公司之一
这使得CPU的电脑。

235
00:11:24,900 --> 00:11:28,910
>> 那么，英特尔的CPU及其他
只需提前决定

236
00:11:28,910 --> 00:11:33,970
该零点的某些模式和
那些指具体的事情。

237
00:11:33,970 --> 00:11:37,040
零和一的某种模式
将意味着，打印此屏幕，

238
00:11:37,040 --> 00:11:39,710
或加这两个数字，或
减去这两个数字，

239
00:11:39,710 --> 00:11:43,310
或将这块数据从
我的电脑的记忆在这里，

240
00:11:43,310 --> 00:11:47,870
或任何数量的其他非常低的水平，
但最终有用的，运营。

241
00:11:47,870 --> 00:11:53,022
不过，值得庆幸的是，我们人类都不会
需要知道这些细节。

242
00:11:53,022 --> 00:11:56,230
事实上，和上次一样，我们在那里
又一次，又一次，又一次抽象，

243
00:11:56,230 --> 00:11:58,930
从很低水平建设
基元像零和一

244
00:11:58,930 --> 00:12:01,160
更高层次的概念
像数字和字母，

245
00:12:01,160 --> 00:12:04,330
和颜色，以及多，
所以我们可以为程序员

246
00:12:04,330 --> 00:12:07,080
站在肩上
别人在我们面前谁也来了

247
00:12:07,080 --> 00:12:11,260
和使用的软件，其他
人前us--采写

248
00:12:11,260 --> 00:12:14,340
即所谓的程序编译器。

249
00:12:14,340 --> 00:12:17,770
>> C是一种语言，
通常编译，

250
00:12:17,770 --> 00:12:22,130
这意味着从转换
源代码的机器代码。

251
00:12:22,130 --> 00:12:25,230
特别是，这意味着什么
是，如果你有你的源代码

252
00:12:25,230 --> 00:12:29,530
代码，您自己写，因为我们很快
将在刚刚在屏幕上的时刻，

253
00:12:29,530 --> 00:12:33,140
并且希望将其转换
最终以机器代码 -

254
00:12:33,140 --> 00:12:37,100
这些零和那些
只有你的Mac或PC机

255
00:12:37,100 --> 00:12:41,230
understands--你已经有了一个第一
养活源代码作为

256
00:12:41,230 --> 00:12:46,340
输入到一个特
程序调用一个编译器，

257
00:12:46,340 --> 00:12:48,974
输出其中我们
应当看到的是机器代码。

258
00:12:48,974 --> 00:12:51,890
而且，事实上，上次我们聊
一下，果然，在一天结束的时候，

259
00:12:51,890 --> 00:12:52,610
解决问题。

260
00:12:52,610 --> 00:12:53,360
你有投入。

261
00:12:53,360 --> 00:12:54,318
和你有输出。

262
00:12:54,318 --> 00:12:56,560
和你有某种
在中间算法。

263
00:12:56,560 --> 00:12:59,830
>> 算法可以肯定是
在软件中实现，

264
00:12:59,830 --> 00:13:02,900
正如我们所看到上周伪
当我们将与实际的代码看

265
00:13:02,900 --> 00:13:03,490
本星期。

266
00:13:03,490 --> 00:13:06,430
所以编译器真的只是
有一组算法内

267
00:13:06,430 --> 00:13:10,060
它知道如何
转换成特殊的关键字，

268
00:13:10,060 --> 00:13:12,180
像主，和printf，
和其他人，我们只是

269
00:13:12,180 --> 00:13:17,620
只见到零的模式和
那些Intel Inside和其他CPU

270
00:13:17,620 --> 00:13:20,020
其实理解。

271
00:13:20,020 --> 00:13:22,460
那么，如何才能做到这一点？

272
00:13:22,460 --> 00:13:24,470
我们在哪里可以得到一个编译器？

273
00:13:24,470 --> 00:13:26,400
>> 我们中的大多数在这里有一台Mac或PC。

274
00:13:26,400 --> 00:13:29,152
而你运行Mac OS，或
Windows或Linux或Solaris，

275
00:13:29,152 --> 00:13:30,860
或任何数量的其他
操作系统。

276
00:13:30,860 --> 00:13:32,568
而且，事实上，我们可以
走出去到网上

277
00:13:32,568 --> 00:13:35,710
并下载一个编译器
为您的Mac或PC机

278
00:13:35,710 --> 00:13:37,360
为您的特定的操作系统。

279
00:13:37,360 --> 00:13:39,617
但是，我们都将是上
不同的页面，可以这么说。

280
00:13:39,617 --> 00:13:41,450
我们会略有
不同的配置。

281
00:13:41,450 --> 00:13:43,210
而事情是行不通的都是一样的。

282
00:13:43,210 --> 00:13:45,280
而且，事实上，这些天
我们很多人不使用

283
00:13:45,280 --> 00:13:47,516
仅运行在我们的笔记本电脑的软件。

284
00:13:47,516 --> 00:13:49,390
相反，我们使用的东西
像的浏览器

285
00:13:49,390 --> 00:13:52,930
允许我们访问基于Web的
在云应用。

286
00:13:52,930 --> 00:13:55,630
后来这个学期，
我们将这样做。

287
00:13:55,630 --> 00:13:59,660
我们将编写应用程序或
使用代码 - 软件不是C，

288
00:13:59,660 --> 00:14:02,860
但其他语言如Python和
JavaScript--在云中运行。

289
00:14:02,860 --> 00:14:05,860
>> 要做到这一点，我们自己
在本学期

290
00:14:05,860 --> 00:14:11,890
将实际使用基于云计算的
环境被称为CS50 IDE。

291
00:14:11,890 --> 00:14:16,030
这是一个基于网络的编程
环境，或集成开发

292
00:14:16,030 --> 00:14:20,610
环境，IDE，它内建一些之上
所谓云9开源软件。

293
00:14:20,610 --> 00:14:22,966
我们已经取得了一定的教学
简化到它

294
00:14:22,966 --> 00:14:25,840
从而隐藏某些功能
我们并不需要在第一周，

295
00:14:25,840 --> 00:14:27,770
之后就可以
揭示他们做最

296
00:14:27,770 --> 00:14:29,400
任何你想要的环境。

297
00:14:29,400 --> 00:14:32,470
>> 它让我们也一样，要
预安装某些软件。

298
00:14:32,470 --> 00:14:35,330
比如像所谓的CS50
图书馆，我们很快就会看到

299
00:14:35,330 --> 00:14:39,210
为我们提供了用C与一些
附加功能。

300
00:14:39,210 --> 00:14:44,392
所以，如果你去，最终CS50.io，
你会被提​​示登录，

301
00:14:44,392 --> 00:14:46,350
一旦你这样做，并创建
一个是免费的账号，

302
00:14:46,350 --> 00:14:52,150
你将能够访问
环境看起来很喜欢这一点。

303
00:14:52,150 --> 00:14:53,760
>> 现在，这是默认模式。

304
00:14:53,760 --> 00:14:55,650
一切都是好的，
明亮的屏幕上。

305
00:14:55,650 --> 00:14:57,941
我们很多人都习惯
工作CS50一块是

306
00:14:57,941 --> 00:14:59,150
挺到深夜。

307
00:14:59,150 --> 00:15:02,400
所以，有些人可能更喜欢
把它变成夜间模式，可以这么说。

308
00:15:02,400 --> 00:15:05,550
>> 但是，最终，你在做什么
要CS50 IDE中看到

309
00:15:05,550 --> 00:15:08,340
是三个不同的areas--
在离开的地方面积

310
00:15:08,340 --> 00:15:12,604
您的文件将要在
云，在右上方的区域

311
00:15:12,604 --> 00:15:14,270
在您的代码将是编辑。

312
00:15:14,270 --> 00:15:16,650
您可以打开
对于任何程序各个选项卡

313
00:15:16,650 --> 00:15:19,670
你写的里面这学期
最重要的是右上角。

314
00:15:19,670 --> 00:15:23,070
然后最arcanely，
然而有力，

315
00:15:23,070 --> 00:15:26,610
将是这个东西在
底部被称​​为一个终端窗口。

316
00:15:26,610 --> 00:15:29,450
>> 这是一个老同学
命令行界面，

317
00:15:29,450 --> 00:15:32,240
或CLI，允许
你执行命令

318
00:15:32,240 --> 00:15:35,260
在这种情况下，computer--，
在cloud--电脑

319
00:15:35,260 --> 00:15:39,090
做事喜欢编译代码
从源代码到机器码，

320
00:15:39,090 --> 00:15:43,600
运行您的程序，或者启动
Web服务器或访问数据库，

321
00:15:43,600 --> 00:15:47,454
和任意数量的其他技术
我们将开始不久使用。

322
00:15:47,454 --> 00:15:49,370
但到那里，我们
去居然有

323
00:15:49,370 --> 00:15:51,240
到网上去，并开始播放。

324
00:15:51,240 --> 00:15:54,399
要做到这一点，让我们先
开始摆弄为主，

325
00:15:54,399 --> 00:15:55,940
写一个程序的主要部分。

326
00:15:55,940 --> 00:15:59,170
让我们使用这个函数
printf的，这是我们前面使用，

327
00:15:59,170 --> 00:16:01,050
简单地说几句。

328
00:16:01,050 --> 00:16:04,910
>> 所以我在这里已经CS50 IDE里面。

329
00:16:04,910 --> 00:16:05,930
我登录的进步。

330
00:16:05,930 --> 00:16:07,360
我完全屏蔽的窗口。

331
00:16:07,360 --> 00:16:09,670
所以，最终，你
过在未来的问题

332
00:16:09,670 --> 00:16:12,960
将遵循类似步骤
将提供在线文档。

333
00:16:12,960 --> 00:16:16,360
所以你不必担心
每吸收一点技术一步

334
00:16:16,360 --> 00:16:17,730
我今天在这里做。

335
00:16:17,730 --> 00:16:19,222
>> 但你会得到这样的画面。

336
00:16:19,222 --> 00:16:20,430
我碰巧在夜间模式。

337
00:16:20,430 --> 00:16:22,944
你可以照亮一切
同比禁用夜间模式。

338
00:16:22,944 --> 00:16:24,860
而在底了
一天，你会看到

339
00:16:24,860 --> 00:16:30,090
这三个主要areas--文件
在浏览器的左边，代码标签向上顶，

340
00:16:30,090 --> 00:16:32,430
和在底部的终端窗口。

341
00:16:32,430 --> 00:16:34,890
>> 让我继续前进，
写我的第一个程序。

342
00:16:34,890 --> 00:16:42,300
我要抢先去文件，
保存，我的文件保存为hello.c的。

343
00:16:42,300 --> 00:16:46,850
事实上，按照惯例，任何程序我们
写是写C语言

344
00:16:46,850 --> 00:16:49,739
名称应该
C点，按照约定。

345
00:16:49,739 --> 00:16:53,030
所以，我打算将其命名为hello.c的，因为
我只是想打个招呼世界。

346
00:16:53,030 --> 00:16:54,820
现在，我要放大
并点击保存。

347
00:16:54,820 --> 00:16:58,180
和所有我现在这里是一个标签
在我可以开始编写代码。

348
00:16:58,180 --> 00:16:59,490
>> 这不会编译。

349
00:16:59,490 --> 00:17:00,300
这意味着什么。

350
00:17:00,300 --> 00:17:02,750
所以，即使我转换
这对零和一，

351
00:17:02,750 --> 00:17:05,390
在CPU将不得不无
知道发生了什么绕来绕去。

352
00:17:05,390 --> 00:17:14,170
但是，如果我写的线条那些匹配
就以C的conventions-- C是，

353
00:17:14,170 --> 00:17:20,150
再次，这language--语法像
对此，printf的招呼天下 - 我已经

354
00:17:20,150 --> 00:17:22,210
得到舒服
这样随着时间的推移。

355
00:17:22,210 --> 00:17:24,510
所以，我不认为我做了
任何印刷错误。

356
00:17:24,510 --> 00:17:27,910
>> 但是，不约而同地，第一个
你这样做的时候，你会的。

357
00:17:27,910 --> 00:17:31,090
什么我将做很可能会
也不会为你工作的第一次。

358
00:17:31,090 --> 00:17:33,610
而这完全确定，
因为现在你

359
00:17:33,610 --> 00:17:37,662
可能只是看到一大堆新奇的，
但随着时间的推移，一旦你熟悉

360
00:17:37,662 --> 00:17:39,870
与此环境下，并
这种语言，等人，

361
00:17:39,870 --> 00:17:42,370
你会开始看到的东西，
要么是正确或不正确。

362
00:17:42,370 --> 00:17:44,369
>> 这是什么
教学研究员，当然

363
00:17:44,369 --> 00:17:48,780
助理在得到随着时间的推移这么好，是
察觉你的代码错误或错误。

364
00:17:48,780 --> 00:17:52,110
但我要求有
在这段代码中没有错误。

365
00:17:52,110 --> 00:17:53,990
所以，我现在要运行这个程序。

366
00:17:53,990 --> 00:17:57,440
>> 现在我自己的Mac或PC，我在
中双击图标的习惯

367
00:17:57,440 --> 00:17:59,350
当我要运行一些程序。

368
00:17:59,350 --> 00:18:01,080
但是，这不是模型在这里。

369
00:18:01,080 --> 00:18:04,570
在这样的环境中，这是CS50的IDE。

370
00:18:04,570 --> 00:18:07,192
我们使用的操作系统
系统称为Linux。

371
00:18:07,192 --> 00:18:09,900
Linux是让人联想到另一
操作系统，通常已知

372
00:18:09,900 --> 00:18:10,850
作为Unix的。

373
00:18:10,850 --> 00:18:16,340
而Linux是特别出名
有一个命令行环境，CLI。

374
00:18:16,340 --> 00:18:20,070
现在，我们使用一个特定的
Linux的味道叫做Ubuntu Linux系统。

375
00:18:20,070 --> 00:18:22,770
和Ubuntu是一个简单的
某些版本的Linux。

376
00:18:22,770 --> 00:18:27,900
>> 但是这些的Linux的这些天真正做到
配备了图形用户界面。

377
00:18:27,900 --> 00:18:30,360
和一个我们碰巧
在这里使用是基于Web的。

378
00:18:30,360 --> 00:18:32,735
因此，这可能看起来甚至
从东西有点不同

379
00:18:32,735 --> 00:18:35,310
你自己可能有
看到或跑过去。

380
00:18:35,310 --> 00:18:37,910
>> 所以我要继续前进
现在做到以下几点。

381
00:18:37,910 --> 00:18:40,950
我已经保存此文件的hello.c。

382
00:18:40,950 --> 00:18:47,350
我要继续前进，
类型clanghello.c所以锵

383
00:18:47,350 --> 00:18:49,850
对于C语言编译器。

384
00:18:49,850 --> 00:18:51,952
这是预安装在CS50 IDE。

385
00:18:51,952 --> 00:18:54,910
你完全可以下载
在自己的Mac或PC上安装它。

386
00:18:54,910 --> 00:18:57,910
>> 但是，同样，你不会有所有的
为您预先配置完成。

387
00:18:57,910 --> 00:19:00,940
所以现在，我只是
要运行clanghello.c。

388
00:19:00,940 --> 00:19:03,240
而现在注意到这一点语法
这里最终将

389
00:19:03,240 --> 00:19:06,930
认识只是意味着我在
文件夹或目录被称为工作区。

390
00:19:06,930 --> 00:19:11,030
这个美元符号仅仅是惯例
为内涵，在这里输入你的命令。

391
00:19:11,030 --> 00:19:14,560
>> 这就是被称为一个提示，只是
按照惯例是美元符号。

392
00:19:14,560 --> 00:19:19,130
如果我继续前进，现在并点击
回车后，似乎没有任何已经发生。

393
00:19:19,130 --> 00:19:20,930
但是，这实际上是一件好事。

394
00:19:20,930 --> 00:19:23,650
出现这种情况就少
您的屏幕，越有可能

395
00:19:23,650 --> 00:19:26,710
你的代码是正确，
至少语法。

396
00:19:26,710 --> 00:19:29,120
>> 所以，如果我想运行此
程序，我该怎么办？

397
00:19:29,120 --> 00:19:33,770
嗯，事实证明，
按照惯例默认名称

398
00:19:33,770 --> 00:19:38,854
对于程序时，您不指定
名称为您的计划仅仅是为a.out。

399
00:19:38,854 --> 00:19:41,270
而这也是语法，你会
熟悉不久。

400
00:19:41,270 --> 00:19:47,500
>> 点斜线只是意味着，哎，CS50
IDE，运行一个名为a.out的程序

401
00:19:47,500 --> 00:19:49,400
这是我的当前目录里。

402
00:19:49,400 --> 00:19:51,520
这点是指当前目录。

403
00:19:51,520 --> 00:19:55,040
我们会看到什么其他的这些序列
人物不久手段。

404
00:19:55,040 --> 00:19:58,430
>> 所以在这里我们去，回车，世界你好。

405
00:19:58,430 --> 00:20:00,080
你会发现，发生了什么？

406
00:20:00,080 --> 00:20:01,580
它不仅打印的hello world。

407
00:20:01,580 --> 00:20:05,990
它也感动
光标移到下一行。

408
00:20:05,990 --> 00:20:07,160
>> 以及为什么呢？

409
00:20:07,160 --> 00:20:12,400
那是什么，我们以前写的代码
即确保该光标将

410
00:20:12,400 --> 00:20:14,882
继续下一行？

411
00:20:14,882 --> 00:20:16,840
大约一个有趣的事情
计算机是它一定会

412
00:20:16,840 --> 00:20:18,570
做字面上你告诉它做。

413
00:20:18,570 --> 00:20:26,050
>> 所以，如果你告诉它给printf你好，
逗号，空间，世界，接近报价，

414
00:20:26,050 --> 00:20:29,090
它字面上只打算
打印这些字符。

415
00:20:29,090 --> 00:20:31,980
但我有这个特殊字符
在年底，召回，反斜线ñ。

416
00:20:31,980 --> 00:20:34,230
而这正是保证
该字符去

417
00:20:34,230 --> 00:20:36,570
到屏幕的下一行。

418
00:20:36,570 --> 00:20:38,097
>> 事实上，让我去做到这一点。

419
00:20:38,097 --> 00:20:39,430
让我继续前进，删除。

420
00:20:39,430 --> 00:20:41,180
现在，请注意
我的屏幕上方有

421
00:20:41,180 --> 00:20:42,890
一个小红灯
标签显示，

422
00:20:42,890 --> 00:20:45,047
哎，你不保存文件。

423
00:20:45,047 --> 00:20:47,880
所以，我要与控制继续前进
S或命令S，保存文件。

424
00:20:47,880 --> 00:20:51,130
现在goes--去了moment--绿色。

425
00:20:51,130 --> 00:20:53,760
而现在又回到了
只是作为一个关闭图标。

426
00:20:53,760 --> 00:21:01,860
>> 如果我现在再次运行clanghello.c，
进入，点斜线，a.out的，回车，

427
00:21:01,860 --> 00:21:04,110
你会看到，它仍然工作。

428
00:21:04,110 --> 00:21:06,020
但它可以说是一个小马车。

429
00:21:06,020 --> 00:21:08,714
现在，我的工作区prompt--，
然后是美元符号，

430
00:21:08,714 --> 00:21:10,880
然后我的实际prompt--
是所有在同一行上。

431
00:21:10,880 --> 00:21:14,540
所以这肯定是一个错误的审美，
即使它不是一个真正的逻辑错误。

432
00:21:14,540 --> 00:21:16,250
>> 所以，我要撤销我只是做了。

433
00:21:16,250 --> 00:21:18,560
我要重新运行的a.out。

434
00:21:18,560 --> 00:21:22,710
请注意，我已经添加了
换行符回来。

435
00:21:22,710 --> 00:21:24,280
我保存的文件。

436
00:21:24,280 --> 00:21:31,630
>> 所以，我要的a.out重新运行，还有 -
该死，一个bug，错误的意思的错误。

437
00:21:31,630 --> 00:21:35,020
因此，错误是，即使
我加了反斜线Ñ那里，

438
00:21:35,020 --> 00:21:41,180
重新保存，重新运行该程序，
的行为是相同的。

439
00:21:41,180 --> 00:21:42,640
为什么会是这样？

440
00:21:42,640 --> 00:21:43,910
>> 我缺少的一个步骤，对不对？

441
00:21:43,910 --> 00:21:47,620
这关键的一步早前是你有
当你改变你的源代码中场休息，

442
00:21:47,620 --> 00:21:49,610
事实证明也办
它通过编译

443
00:21:49,610 --> 00:21:51,102
再次让你获得新的机器代码。

444
00:21:51,102 --> 00:21:52,810
和机器代码，
在零和一，

445
00:21:52,810 --> 00:21:56,260
将要几乎相同，但
不完全是这样，因为我们需要的，

446
00:21:56,260 --> 00:21:57,510
当然，新的线路。

447
00:21:57,510 --> 00:22:02,640
>> 因此，要解决这个问题，我会需要
重新运行clanghello.c，输入，点

448
00:22:02,640 --> 00:22:03,800
斜线，a.out的。

449
00:22:03,800 --> 00:22:08,402
而现在，世界您好又回来了
在那里我希望它是。

450
00:22:08,402 --> 00:22:09,610
因此，这是一切优秀和良好。

451
00:22:09,610 --> 00:22:13,150
但a.out的是一个相当愚蠢的名字
方案，即使它正好是，

452
00:22:13,150 --> 00:22:16,530
由于历史的原因，
default--意思装配输出。

453
00:22:16,530 --> 00:22:20,780
>> 但让我继续在这里
而不同的做到这一点。

454
00:22:20,780 --> 00:22:24,760
我希望我的Hello World程序
实际上叫你好。

455
00:22:24,760 --> 00:22:28,320
所以，如果它是一个图标我
台式机，它不会被A.OUT。

456
00:22:28,320 --> 00:22:29,730
它会被称为打招呼。

457
00:22:29,730 --> 00:22:33,660
>> 因此，要做到这一点，事实证明
那铛，像许多节目，

458
00:22:33,660 --> 00:22:37,980
支持命令行参数，
或标志，或开关

459
00:22:37,980 --> 00:22:39,600
它只是影响其行为。

460
00:22:39,600 --> 00:22:45,160
具体来说，锵支持破折号Ø
标志，然后拿着第二个字。

461
00:22:45,160 --> 00:22:48,190
在这种情况下，我会随意，
但合理的，把它打个招呼。

462
00:22:48,190 --> 00:22:50,710
但我可以把它叫做什么
我想，除了a.out的，这

463
00:22:50,710 --> 00:22:52,390
会相当除了点。

464
00:22:52,390 --> 00:22:55,640
>> 然后只需指定名称
文件我确实想编译。

465
00:22:55,640 --> 00:22:59,190
所以，现在即使在开始
命令我仍然有铛的，

466
00:22:59,190 --> 00:23:01,410
在命令结束时
我仍然有文件名，

467
00:23:01,410 --> 00:23:05,520
我现在有这些命令行
参数，这些标志是在说，

468
00:23:05,520 --> 00:23:11,180
哦，对了，输出-O，文件
名为hello，而不是默认的a.out。

469
00:23:11,180 --> 00:23:13,810
>> 所以，现在如果我打回车键，没什么
似乎已经发生了。

470
00:23:13,810 --> 00:23:17,900
而且，然而，现在我可以做点斜线打招呼。

471
00:23:17,900 --> 00:23:19,089
所以这是相同的程序。

472
00:23:19,089 --> 00:23:21,380
在零和一的
相同在一天结束。

473
00:23:21,380 --> 00:23:24,210
>> 但是他们两个
不同files--的a.out，

474
00:23:24,210 --> 00:23:26,490
这是第一个版本
和公正的愚蠢命名，

475
00:23:26,490 --> 00:23:30,250
现在你好，这是一个非常
更引人注目的名字的程序。

476
00:23:30,250 --> 00:23:33,195
但是，说实话，我从来没有
又要记住这一点，

477
00:23:33,195 --> 00:23:34,070
又一次，又一次。

478
00:23:34,070 --> 00:23:36,411
而且，事实上，正如我们写
更复杂的程序，

479
00:23:36,411 --> 00:23:38,160
你的命令
不得不写

480
00:23:38,160 --> 00:23:40,920
要报复
更复杂的仍。

481
00:23:40,920 --> 00:23:41,940
>> 所以不用担心。

482
00:23:41,940 --> 00:23:46,220
事实证明，人类前
我们已经意识到，他们也

483
00:23:46,220 --> 00:23:47,530
有这个相同的问题。

484
00:23:47,530 --> 00:23:50,900
他们也没有享受不必
键入相当长的，神秘的命令，

485
00:23:50,900 --> 00:23:52,200
更不用说记住他们。

486
00:23:52,200 --> 00:23:56,070
所以，摆在我们面前的人类已经取得
其他程序，可以更容易

487
00:23:56,070 --> 00:23:57,670
编译软件。

488
00:23:57,670 --> 00:24:01,609
>> 而且，事实上，这样的一个
计划被称为制作。

489
00:24:01,609 --> 00:24:03,150
所以我要继续前进，并做到这一点。

490
00:24:03,150 --> 00:24:05,691
我要撤销我的一切
正好在下面的方式一样。

491
00:24:05,691 --> 00:24:07,690
让我LS型。

492
00:24:07,690 --> 00:24:10,980
你会注意到三个things--
a.out的，和一个明星，你好

493
00:24:10,980 --> 00:24:12,810
和一个明星，而hello.c中。

494
00:24:12,810 --> 00:24:14,730
但愿，这应该
有一点直观，

495
00:24:14,730 --> 00:24:18,220
只要前面有
没有在此工作空间。

496
00:24:18,220 --> 00:24:21,240
没有什么，我有
创建，直到我们开始上课。

497
00:24:21,240 --> 00:24:22,840
>> 和我创建的hello.c。

498
00:24:22,840 --> 00:24:24,544
然后我编译它，并把它称为a.out的。

499
00:24:24,544 --> 00:24:27,460
然后我再编译稍微
不同，称之为打招呼。

500
00:24:27,460 --> 00:24:32,830
所以我有这个目录中的三个文件，
在这个文件夹叫工作空间。

501
00:24:32,830 --> 00:24:35,005
现在，我可以看到，以及
如果我缩小实际。

502
00:24:35,005 --> 00:24:37,530
>> 如果我缩小这里
看那个右上角

503
00:24:37,530 --> 00:24:39,940
角落里，如许左
屏幕的右侧

504
00:24:39,940 --> 00:24:42,990
总是会告诉你
什么是在您的帐户，有什么

505
00:24:42,990 --> 00:24:44,790
里面CS50的IDE。

506
00:24:44,790 --> 00:24:46,680
而且有三个文件存在。

507
00:24:46,680 --> 00:24:49,070
>> 所以，我想摆脱的a.out和打招呼。

508
00:24:49,070 --> 00:24:51,275
正如你可能
想象直观，你

509
00:24:51,275 --> 00:24:53,400
可以控制排序点击
或右键点击这个。

510
00:24:53,400 --> 00:24:54,590
而这个小菜单弹出。

511
00:24:54,590 --> 00:24:57,170
您也可以下载文件，运行
它，预览，刷新，重命名，

512
00:24:57,170 --> 00:24:57,700
或什么不是。

513
00:24:57,700 --> 00:25:00,260
>> 而且我可能只是删除，
它会消失。

514
00:25:00,260 --> 00:25:05,260
但是让我们做的事情有一个命令
行了，这样才能让自己舒服

515
00:25:05,260 --> 00:25:07,010
这一点，并做到以下几点。

516
00:25:07,010 --> 00:25:12,345
我要继续前进，并删除
通过键入字面上rma.out的a.out。

517
00:25:12,345 --> 00:25:14,890
原来，该命令
去除或删除的东西，

518
00:25:14,890 --> 00:25:16,280
是不是删除或删除。

519
00:25:16,280 --> 00:25:21,260
>> 这是更简洁RM，只是为了节省
你一些按键，并按下回车键。

520
00:25:21,260 --> 00:25:24,707
现在，我们要有点
神秘地删除常规文件的a.out。

521
00:25:24,707 --> 00:25:27,040
我真的不知道是什么的
不规​​则的文件会呢。

522
00:25:27,040 --> 00:25:28,660
但我要删除它。

523
00:25:28,660 --> 00:25:30,150
>> 所以，我要键入Y（是）。

524
00:25:30,150 --> 00:25:31,940
或者，我可以键入它，然后按Enter键。

525
00:25:31,940 --> 00:25:33,440
并再次，好像没有什么改变。

526
00:25:33,440 --> 00:25:35,840
但是，这是一般，是一件好事。

527
00:25:35,840 --> 00:25:40,490
>> 如果我输入ls这一次，
我应该怎么看？

528
00:25:40,490 --> 00:25:44,930
我们希望，只是打招呼，hello.c中。

529
00:25:44,930 --> 00:25:47,286
现在，顺便说一句，你会
注意到这一点明星，星号，

530
00:25:47,286 --> 00:25:48,660
这是在我的节目的结束。

531
00:25:48,660 --> 00:25:50,201
而且他们也显示为绿色。

532
00:25:50,201 --> 00:25:53,970
这仅仅是CS50 IDE的方式
cluing你到事实的

533
00:25:53,970 --> 00:25:55,280
那这不是源代码。

534
00:25:55,280 --> 00:25:58,880
这是一个可执行文件，可运行
你可以实际运行的程序

535
00:25:58,880 --> 00:26:01,020
通过做点斜杠，然后它的名字。

536
00:26:01,020 --> 00:26:05,860
>> 现在，让我继续和删除
对此，RM你好，回车，定期删除

537
00:26:05,860 --> 00:26:08,010
文件你好，是的。

538
00:26:08,010 --> 00:26:11,180
现在，如果我输入LS，
我们又回到hello.c中。

539
00:26:11,180 --> 00:26:13,917
尽量不要删除
实际的源代码。

540
00:26:13,917 --> 00:26:16,250
即使有特点
内置IDE CS50在哪里

541
00:26:16,250 --> 00:26:19,870
你可以通过你的修订历史记录
并及时退，如果你不小心

542
00:26:19,870 --> 00:26:23,660
删除一些东西，做铭记
按照这些提示是或否，

543
00:26:23,660 --> 00:26:25,381
什么你真正想做的事情。

544
00:26:25,381 --> 00:26:27,380
如果我去到顶部
这里左手角落，

545
00:26:27,380 --> 00:26:30,696
剩下的工作就是hello.c中。

546
00:26:30,696 --> 00:26:32,570
因此，有一束束
其他命令你

547
00:26:32,570 --> 00:26:37,550
可在Linux世界执行，
其中之一是，再次进行。

548
00:26:37,550 --> 00:26:40,180
而我们要制作
我现在的程序如下。

549
00:26:40,180 --> 00:26:43,270
>> 而不是做铛的，
而不是做铛-O，

550
00:26:43,270 --> 00:26:45,860
我要简单地
从字面上类型，制造打招呼。

551
00:26:45,860 --> 00:26:49,630
而现在发现，我
不打字做的hello.c。

552
00:26:49,630 --> 00:26:50,910
我打字做打招呼。

553
00:26:50,910 --> 00:26:54,840
>> 而这个节目的制作
自带CS50 IDE，以及更多

554
00:26:54,840 --> 00:26:57,090
一般的Linux，
是一个程序，是

555
00:26:57,090 --> 00:26:59,120
要做一个名为Hello程序。

556
00:26:59,120 --> 00:27:03,680
而且它要承担，按照惯例，
如果可以进行该程序，

557
00:27:03,680 --> 00:27:09,030
它会从一个源发
代码文件中C点结束，hello.c中。

558
00:27:09,030 --> 00:27:12,210
>> 所以，现在如果我打回车，通知，
这被执行的命令

559
00:27:12,210 --> 00:27:14,340
实际上甚至更长
前比以前。

560
00:27:14,340 --> 00:27:16,670
那是因为我们已经
预配置CS50 IDE有

561
00:27:16,670 --> 00:27:19,878
建于一些额外的功能
我们并不需要，只是还没有，但很快会。

562
00:27:19,878 --> 00:27:23,470
但关键的事情来实现
现在我有一个Hello程序。

563
00:27:23,470 --> 00:27:27,080
>> 如果我再次键入LS，我
有一个hello程序。

564
00:27:27,080 --> 00:27:32,070
而且我可以运行它
点斜线a.out的，不，

565
00:27:32,070 --> 00:27:35,590
因为这个整点
演习点斜线打招呼。

566
00:27:35,590 --> 00:27:38,089
现在，我有我的Hello World程序。

567
00:27:38,089 --> 00:27:39,880
所以向前走，
我们几乎永远只是

568
00:27:39,880 --> 00:27:42,088
要编译我们的节目
使用命令make。

569
00:27:42,088 --> 00:27:45,300
然后，我们将通过为它们运行
点斜线，程序的名字。

570
00:27:45,300 --> 00:27:49,610
但要意识到什么使正在为
你，是它本身不是一个编译器。

571
00:27:49,610 --> 00:27:53,310
这只是一个方便程序
知道如何触发一个编译器

572
00:27:53,310 --> 00:27:56,470
运行，让你自己可以使用它。

573
00:27:56,470 --> 00:28:00,220
>> 还有什么其他的命令中存在
Linux和依次CS50的IDE？

574
00:28:00,220 --> 00:28:03,107
我们很快就会看到，有一个
CD命令，切换目录。

575
00:28:03,107 --> 00:28:05,190
这允许您在
你的命令行界面

576
00:28:05,190 --> 00:28:07,610
继续前进，和背部，
并打开不同的文件夹

577
00:28:07,610 --> 00:28:08,860
不使用鼠标。

578
00:28:08,860 --> 00:28:12,470
>> 我们看到了LS，代表名单
在当前目录中的文件。

579
00:28:12,470 --> 00:28:14,650
让迪尔，你可以
可能开始推断

580
00:28:14,650 --> 00:28:18,150
这些意味着什么now--创建目录，
如果你想创建一个文件夹。

581
00:28:18,150 --> 00:28:21,270
RM为删除，RM为迪尔
删除directory--而这些，

582
00:28:21,270 --> 00:28:24,160
再次，是命令行
什么你现金等价物

583
00:28:24,160 --> 00:28:26,945
可在CS50 IDE与你的鼠标。

584
00:28:26,945 --> 00:28:28,820
但是，你很快就会发现
有时它只是

585
00:28:28,820 --> 00:28:30,610
速度快了很多做
事用键盘，

586
00:28:30,610 --> 00:28:33,690
最终很多更强大。

587
00:28:33,690 --> 00:28:36,440
>> 但是，这很难说
任何事情我们一直在做，到目前为止

588
00:28:36,440 --> 00:28:39,990
是所有强大的，当所有
我们一直在说的是，世界你好。

589
00:28:39,990 --> 00:28:43,740
而且，事实上，我的硬编码
也就是说世界你好了我的计划。

590
00:28:43,740 --> 00:28:45,530
有没有活力呢。

591
00:28:45,530 --> 00:28:49,320
划痕是一个数量级
更有趣的最后一周。

592
00:28:49,320 --> 00:28:51,220
>> 所以，让我们在那里。

593
00:28:51,220 --> 00:28:55,310
让我们走向一个一步
一些这些功能的方法。

594
00:28:55,310 --> 00:28:59,470
所以不仅ç配备的printf，
其它的功能和束

595
00:28:59,470 --> 00:29:01,850
其中的一些，我们会看到
随着时间的推移，它不

596
00:29:01,850 --> 00:29:05,760
使这一切容易右出
在获取用户输入的栅极。

597
00:29:05,760 --> 00:29:08,140
>> 弱点事实上，人们
的语言，如C，

598
00:29:08,140 --> 00:29:10,140
甚至Java和尚未
别人是，它不

599
00:29:10,140 --> 00:29:15,860
可以很容易地只得到一样的东西
从用户或字符串，整数的话，

600
00:29:15,860 --> 00:29:19,970
和短语，让喜欢独处的东西
浮点值，或实数

601
00:29:19,970 --> 00:29:23,240
带有小数点的，真
长数字，因为我们很快就会看到。

602
00:29:23,240 --> 00:29:27,000
所以功能这个名单在这里，这些
就像其他的划痕拼图

603
00:29:27,000 --> 00:29:31,090
我们已经预先安装在CS50
IDE，我们将用数周

604
00:29:31,090 --> 00:29:34,010
作为各种训练车轮，和
最终把他们赶走，并期待

605
00:29:34,010 --> 00:29:37,210
引擎盖，也许，在下方
这些东西是如何实现的。

606
00:29:37,210 --> 00:29:40,460
>> 但要做到这一点，让我们
其实写一个程序。

607
00:29:40,460 --> 00:29:41,770
现在让我先走。

608
00:29:41,770 --> 00:29:44,750
而且我要创建一个新的
通过点击这个小加档，

609
00:29:44,750 --> 00:29:45,970
然后单击新建文件。

610
00:29:45,970 --> 00:29:49,250
>> 我要救这下
一个作为，让我们说，string.c，

611
00:29:49,250 --> 00:29:50,750
因为我想用绳子玩。

612
00:29:50,750 --> 00:29:53,990
和字符串在C是刚
字符序列。

613
00:29:53,990 --> 00:29:56,090
所以，现在让我们继续
并做到以下几点。

614
00:29:56,090 --> 00:30:01,204
>> 包括标准IO.h--和
事实证明标准IO，

615
00:30:01,204 --> 00:30:03,360
IO只是意味着输入和输出。

616
00:30:03,360 --> 00:30:05,920
所以，事实证明，
这里这条线是什么

617
00:30:05,920 --> 00:30:08,140
在相邻的我们用printf。

618
00:30:08,140 --> 00:30:10,410
printf的，当然，产生输出。

619
00:30:10,410 --> 00:30:15,000
因此，为了用printf，原来
出你必须有这行代码

620
00:30:15,000 --> 00:30:16,040
在你的文件的顶部。

621
00:30:16,040 --> 00:30:18,456
>> 我们会回来的是什么
不久的真正含义。

622
00:30:18,456 --> 00:30:20,400
事实证明，在
任何C程序我写的，

623
00:30:20,400 --> 00:30:23,640
我必须与启动
代码如下所示。

624
00:30:23,640 --> 00:30:26,860
你会发现CS50 IDE和
其他集成开发

625
00:30:26,860 --> 00:30:30,050
喜欢它的环境，
要尽可能在

626
00:30:30,050 --> 00:30:31,780
他们可以完成你的想法。

627
00:30:31,780 --> 00:30:35,930
其实，刚才我是否撤消
我只是做了，我打回车键。

628
00:30:35,930 --> 00:30:39,160
>> 然后我打左大
撑，命中再次输入。

629
00:30:39,160 --> 00:30:40,430
它完成了我的想法。

630
00:30:40,430 --> 00:30:45,140
它给了我一个新的生产线，缩进不会少
对于好的文体的原因，我们拭目以待。

631
00:30:45,140 --> 00:30:48,559
然后它会自动给我
那花括号来完成我的想法。

632
00:30:48,559 --> 00:30:50,600
现在，它并不总是
猜你想要做什么。

633
00:30:50,600 --> 00:30:53,620
但在很大程度上，它确实
为您节省一些按键。

634
00:30:53,620 --> 00:30:59,560
所以，刚才，我们跑这program--
你好，世界，然后编译它，

635
00:30:59,560 --> 00:31:00,460
然后运行它。

636
00:31:00,460 --> 00:31:01,867
但这里有没有活力。

637
00:31:01,867 --> 00:31:03,700
如果我们想
做不同的事情？

638
00:31:03,700 --> 00:31:07,630
好吧，如果我想实际
获取来自用户的字符串？

639
00:31:07,630 --> 00:31:11,250
我将使用一块拼图
正是所谓的that--得到的字符串。

640
00:31:11,250 --> 00:31:15,860
>> 用C原来，当你不想要
提供输入到一块拼图，

641
00:31:15,860 --> 00:31:19,360
或者更恰当给一个函数，你
从字面上只是做开括号，

642
00:31:19,360 --> 00:31:20,430
右括号。

643
00:31:20,430 --> 00:31:25,540
因此，这好像有
没有白框键入。

644
00:31:25,540 --> 00:31:27,720
之前说块
有一个白色的小盒子。

645
00:31:27,720 --> 00:31:29,660
我们没有白框现在。

646
00:31:29,660 --> 00:31:33,310
>> 但是，当我调用get字符串，我
想不想找个地方把结果。

647
00:31:33,310 --> 00:31:37,680
所以在C很常见的模式是
这里调用一个函数，以获得更多的字符串，

648
00:31:37,680 --> 00:31:41,070
然后存储它的返回值。

649
00:31:41,070 --> 00:31:44,450
它的结果其
努力的东西。

650
00:31:44,450 --> 00:31:47,630
>> 什么是
构造在编程，

651
00:31:47,630 --> 00:31:53,450
无论是在划痕或现在C，我们
可以使用实际存储的东西吗？

652
00:31:53,450 --> 00:31:55,990
称它是可变的，对不对？

653
00:31:55,990 --> 00:32:00,320
而在划伤，我们真的不
关心变量打算。

654
00:32:00,320 --> 00:32:02,170
>> 但是，在这种情况下，我们实际上做的。

655
00:32:02,170 --> 00:32:03,719
我要说的字符串。

656
00:32:03,719 --> 00:32:05,510
然后，我可以打电话给
这样的事情我想要的。

657
00:32:05,510 --> 00:32:08,340
我要叫它
名称，获取得到的字符串。

658
00:32:08,340 --> 00:32:10,250
>> 现在，即使你
有点新本，

659
00:32:10,250 --> 00:32:11,984
注意到，我缺少一些细节。

660
00:32:11,984 --> 00:32:13,150
我忘了一个分号。

661
00:32:13,150 --> 00:32:14,400
我需要完成这一思想。

662
00:32:14,400 --> 00:32:17,480
所以，我打算将我的光标，
并创下分号那里。

663
00:32:17,480 --> 00:32:19,130
和你有我只是做了什么？

664
00:32:19,130 --> 00:32:21,440
在这行代码，
此刻号5，

665
00:32:21,440 --> 00:32:23,799
我调用get字符串，没有投入。

666
00:32:23,799 --> 00:32:26,090
因此，有不小的白色
像盒保存块。

667
00:32:26,090 --> 00:32:28,590
>> 我只是说，嘿，
电脑，给我一个字符串。

668
00:32:28,590 --> 00:32:31,390
等号是不是真的
一个等号，本身。

669
00:32:31,390 --> 00:32:33,790
这是分配
操作者，这意味着，

670
00:32:33,790 --> 00:32:37,860
哎，电脑，移动值
从以上至左右。

671
00:32:37,860 --> 00:32:40,480
而在左边，我有以下。

672
00:32:40,480 --> 00:32:43,580
>> 嘿，电脑，给我一个string--
字符序列。

673
00:32:43,580 --> 00:32:45,637
并调用该字符串名称。

674
00:32:45,637 --> 00:32:47,220
我甚至不具备调用它的名称。

675
00:32:47,220 --> 00:32:49,970
>> 我可以调用它，按照惯例，
像S，

676
00:32:49,970 --> 00:32:52,900
就像我们用我来
调用变量i。

677
00:32:52,900 --> 00:32:54,829
但现在我需要用它做什么。

678
00:32:54,829 --> 00:32:57,370
这将是非常愚蠢的
尝试编译这段代码，运行

679
00:32:57,370 --> 00:32:59,410
这个程序，即使
我得到一个字符串，

680
00:32:59,410 --> 00:33:01,580
因为它仍然只是
去打招呼的世界。

681
00:33:01,580 --> 00:33:06,140
>> 但是，如果我不想要什么来改变这种状况。

682
00:33:06,140 --> 00:33:07,940
我为什么不这样做呢？

683
00:33:07,940 --> 00:33:11,632
％的S，逗号秒。

684
00:33:11,632 --> 00:33:13,090
这是一个有点神秘依旧。

685
00:33:13,090 --> 00:33:15,560
>> 所以，让我的变量更加清晰。

686
00:33:15,560 --> 00:33:17,510
让我这个变量名称。

687
00:33:17,510 --> 00:33:20,230
让我们看看如果我们不能去惹
除了这里发生了什么。

688
00:33:20,230 --> 00:33:22,770
>> 因此，对五号线，我得到的字符串。

689
00:33:22,770 --> 00:33:25,620
而我存储这个字符串，
无论用户已键入的

690
00:33:25,620 --> 00:33:28,430
在他或她的键盘，
在一个名为名称的变量。

691
00:33:28,430 --> 00:33:30,590
而事实证明，
printf的不只是

692
00:33:30,590 --> 00:33:34,220
采取双重一个参数
引号，在双引号的输入。

693
00:33:34,220 --> 00:33:39,100
>> 它可以采取两个或三个，或更多，如
使第二，或第三，或第四，

694
00:33:39,100 --> 00:33:42,320
是变量所有的名字，
或者特别重视，

695
00:33:42,320 --> 00:33:48,610
要插入，
动态，用引号引起该字符串。

696
00:33:48,610 --> 00:33:52,110
换句话说，什么
将问题呢？

697
00:33:52,110 --> 00:33:57,920
如果我只是说你好名称，反斜线
N，救了我的文件，我的编译代码，

698
00:33:57,920 --> 00:34:01,660
跑了这一点，会发生什么？

699
00:34:01,660 --> 00:34:05,139
>> 它只是会说，你好
名字，从字面上N-A-M-E，

700
00:34:05,139 --> 00:34:07,900
这是一种愚蠢的，因为
这是一个从世界上没有什么不同。

701
00:34:07,900 --> 00:34:10,400
因此，在行情是什么
什么字面上被打印出来。

702
00:34:10,400 --> 00:34:12,520
所以，如果我想有
一个占位符那里，

703
00:34:12,520 --> 00:34:14,422
我真正需要使用
一些特殊的语法。

704
00:34:14,422 --> 00:34:17,380
而事实证明，如果你读了
对于printf函数的文档，

705
00:34:17,380 --> 00:34:21,320
它会告诉你，
如果你使用％的S，

706
00:34:21,320 --> 00:34:23,920
您可以按如下替换值。

707
00:34:23,920 --> 00:34:27,190
>> 后一个逗号后
双引号，你只需

708
00:34:27,190 --> 00:34:29,179
写的名字
要变

709
00:34:29,179 --> 00:34:33,790
插上到该格式
代码或格式说明，

710
00:34:33,790 --> 00:34:35,469
％的S代表字符串。

711
00:34:35,469 --> 00:34:39,190
现在，如果我救了我的文件，
我回去到我的终端。

712
00:34:39,190 --> 00:34:42,870
而I型制作绳，
因为，再次，在此名称

713
00:34:42,870 --> 00:34:45,510
我之前选择的文件是string.c。

714
00:34:45,510 --> 00:34:48,510
>> 所以，我要说让字符串，请输入。

715
00:34:48,510 --> 00:34:51,550
我的天哪，看看所有的
错误我们已经取得了。

716
00:34:51,550 --> 00:34:55,540
而这is--什么，这实在是
像六，七行程序？

717
00:34:55,540 --> 00:34:57,790
因此，这是它可以很
快速获得压倒性的。

718
00:34:57,790 --> 00:35:00,890
>> 该终端窗口有
现在只是反刍

719
00:35:00,890 --> 00:35:03,230
数量巨大的错误消息。

720
00:35:03,230 --> 00:35:07,560
当然，我没有更多的错误
消息比我行代码。

721
00:35:07,560 --> 00:35:08,680
那么到底是怎么回事？

722
00:35:08,680 --> 00:35:10,920
>> 那么，最好的策略
做到任何时候你

723
00:35:10,920 --> 00:35:13,710
确实遇到了压倒性
这样的错误列表，

724
00:35:13,710 --> 00:35:16,690
被回滚，查找命令
你刚刚运行，这在我的情况下，

725
00:35:16,690 --> 00:35:18,020
为使字符串。

726
00:35:18,020 --> 00:35:21,630
看看什么使所做的，就是这样
长铛命令，没什么大不了的存在。

727
00:35:21,630 --> 00:35:22,950
>> 但红色是坏的。

728
00:35:22,950 --> 00:35:24,750
格林试图将
温柔，乐于助人。

729
00:35:24,750 --> 00:35:26,140
但它仍然很糟糕，在这种情况下。

730
00:35:26,140 --> 00:35:27,510
但是，在这样做不好？

731
00:35:27,510 --> 00:35:31,450
>> String.c，五号线，性格五位。

732
00:35:31,450 --> 00:35:32,930
所以这只是常见的约定。

733
00:35:32,930 --> 00:35:36,060
结肠癌的东西意味着什么
行数和字符数。

734
00:35:36,060 --> 00:35:41,080
错误，使用未申报
标识字符串。

735
00:35:41,080 --> 00:35:42,900
你的意思是标准？

736
00:35:42,900 --> 00:35:45,530
>> 所以，不幸的是，锵
试图有所帮助。

737
00:35:45,530 --> 00:35:46,850
但是，它是错的，在这种情况下。

738
00:35:46,850 --> 00:35:49,350
不，锵，我不是故意的标准IO。

739
00:35:49,350 --> 00:35:51,070
我的意思是在同一行，不错。

740
00:35:51,070 --> 00:35:53,420
>> 但是，五号线在这里这一个。

741
00:35:53,420 --> 00:35:57,040
而锵不
了解S-T-R-I-N-G。

742
00:35:57,040 --> 00:36:01,490
这是一个未声明的标识符，
一句话，它只是从来没有见过的。

743
00:36:01,490 --> 00:36:05,730
那是因为C，语言
我们在写代码的权利，

744
00:36:05,730 --> 00:36:08,070
不具有的变量称为串。

745
00:36:08,070 --> 00:36:11,380
>> 这不，在默认情况下，支持
所谓的字符串。

746
00:36:11,380 --> 00:36:16,750
这是一个CS50一块
行话，但很传统。

747
00:36:16,750 --> 00:36:18,600
但是，我可以按如下方式解决这个问题。

748
00:36:18,600 --> 00:36:22,090
>> 如果我添加一行代码
这个程序的顶部，

749
00:36:22,090 --> 00:36:27,890
包括CS50.h，这是另一种文件
里面的某个地方IDE CS50的某处

750
00:36:27,890 --> 00:36:30,820
在硬盘上，可以这么说，
在Ubuntu操作系统

751
00:36:30,820 --> 00:36:33,590
我参加竞选，这
是的文件

752
00:36:33,590 --> 00:36:38,740
要教工作
系统中的字符串是什么，只是

753
00:36:38,740 --> 00:36:41,930
像标准io.h是文件
在操作系统中那

754
00:36:41,930 --> 00:36:44,430
要教它是什么的printf。

755
00:36:44,430 --> 00:36:46,810
>> 事实上，我们会得到
一个非常类似的消息

756
00:36:46,810 --> 00:36:50,600
如果IO也认标准
IO.h并试图用printf。

757
00:36:50,600 --> 00:36:53,632
所以我要继续前进，只是
采取控制L到清除我的屏幕。

758
00:36:53,632 --> 00:36:56,340
或者，您可以键入清晰，它会
只是清除终端窗口。

759
00:36:56,340 --> 00:36:58,020
但你仍然可以在时间上向后滚动。

760
00:36:58,020 --> 00:37:01,100
>> 而我要重新运行制作绳。

761
00:37:01,100 --> 00:37:03,660
穿过我的手指此时，回车。

762
00:37:03,660 --> 00:37:05,380
哦，我的上帝，它的工作。

763
00:37:05,380 --> 00:37:09,280
它显示了我很长的神秘命令
这是通过锵请生成的内容，

764
00:37:09,280 --> 00:37:10,460
但没有错误消息。

765
00:37:10,460 --> 00:37:12,460
所以实现的，即使
你可能会得到完全

766
00:37:12,460 --> 00:37:14,480
此番与
错误信息的数量，

767
00:37:14,480 --> 00:37:17,540
也许会是这恼人的级联
实际上，在那里锵不明白

768
00:37:17,540 --> 00:37:19,620
一方面，这意味着它然后
不理解下一个字，

769
00:37:19,620 --> 00:37:20,560
或下一行。

770
00:37:20,560 --> 00:37:22,850
所以它只是扼流圈您的代码。

771
00:37:22,850 --> 00:37:24,440
但是，该补丁可能很简单。

772
00:37:24,440 --> 00:37:27,822
所以始终围绕
输出的第一行。

773
00:37:27,822 --> 00:37:29,530
如果你不这样做
理解，只是看

774
00:37:29,530 --> 00:37:32,480
关键字，可能是
线索，并且行号，

775
00:37:32,480 --> 00:37:34,650
和字符，其中
这种错误可能是。

776
00:37:34,650 --> 00:37:40,328
>> 现在让我先走，然后键入
点斜线，字符串，请输入。

777
00:37:40,328 --> 00:37:44,340
嗯，这不是打个招呼什么。

778
00:37:44,340 --> 00:37:46,210
为什么？

779
00:37:46,210 --> 00:37:48,170
好了，还记得，它在哪儿跑？

780
00:37:48,170 --> 00:37:53,730
>> 它可能停留在此刻
在一个循环中，如果你愿意，六线，

781
00:37:53,730 --> 00:37:56,950
因为设计的GET字符串，
通过CS50的工作人员写的，

782
00:37:56,950 --> 00:38:00,350
字面意思只是坐在
在那里等着，等着，

783
00:38:00,350 --> 00:38:01,850
并等待一个字符串。

784
00:38:01,850 --> 00:38:03,792
所有我们所说的字符串是人力的投入。

785
00:38:03,792 --> 00:38:04,500
所以，你知道吗？

786
00:38:04,500 --> 00:38:05,166
让我先走。

787
00:38:05,166 --> 00:38:08,704
而就心血来潮，让我
输入我的名字，大卫进入。

788
00:38:08,704 --> 00:38:10,120
现在我有一个更加动态的程序。

789
00:38:10,120 --> 00:38:11,240
它说，你好大卫。

790
00:38:11,240 --> 00:38:16,280
>> 如果我继续前进，再次运行此，
让我试试说Zamila名称，输入。

791
00:38:16,280 --> 00:38:17,940
现在我们有一个动态的程序。

792
00:38:17,940 --> 00:38:19,380
我没有硬编码的世界。

793
00:38:19,380 --> 00:38:21,760
我没有硬编码
名称或大卫，或Zamila。

794
00:38:21,760 --> 00:38:25,350
>> 现在它更像程序
我们知道，在那里，如果需要输入，

795
00:38:25,350 --> 00:38:27,870
它产生的输出结果略有不同。

796
00:38:27,870 --> 00:38:31,020
现在，这并不是最好的
用户体验，或者UX。

797
00:38:31,020 --> 00:38:33,000
我运行该程序。

798
00:38:33,000 --> 00:38:35,830
>> 我不知道我应该
这样做，除非我其实看

799
00:38:35,830 --> 00:38:37,290
或记住的源代码。

800
00:38:37,290 --> 00:38:39,640
因此，让用户
遇到好一点

801
00:38:39,640 --> 00:38:41,240
用最简单的事情。

802
00:38:41,240 --> 00:38:44,782
让我回去到这个
程序，简单地说printf的。

803
00:38:44,782 --> 00:38:48,870
>> 让我继续说名字，结肠，
和一个空间，然后分号。

804
00:38:48,870 --> 00:38:51,170
而只是踢，无隙ñ。

805
00:38:51,170 --> 00:38:52,980
这就是故意的，
因为我不想

806
00:38:52,980 --> 00:38:54,590
提示移动到下一行。

807
00:38:54,590 --> 00:38:58,800
>> 我想，相反，这样做，使串
重新编译我的代码到新机

808
00:38:58,800 --> 00:39:00,980
代码点斜线的字符串。

809
00:39:00,980 --> 00:39:02,460
啊，这是非常漂亮。

810
00:39:02,460 --> 00:39:05,780
现在，我实际上知道什么是电脑
要我做的，给它一个名字。

811
00:39:05,780 --> 00:39:10,020
>> 所以我要继续前进，并键入
在罗布，进入，你好，罗布。

812
00:39:10,020 --> 00:39:13,640
因此，实现，这仍然是，在结束
当天，只有一个九行程序。

813
00:39:13,640 --> 00:39:15,090
但是，我们已经采取了这些婴儿的步骤。

814
00:39:15,090 --> 00:39:18,380
>> 我们写了一行与我们
熟悉，printf的，世界你好。

815
00:39:18,380 --> 00:39:19,980
然后，我们毁掉了那一点。

816
00:39:19,980 --> 00:39:21,560
而我们实际使用的GET字符串。

817
00:39:21,560 --> 00:39:23,362
而我们在扔一个变量值。

818
00:39:23,362 --> 00:39:26,070
然后我们说干就干，提高
它进一步与第三行。

819
00:39:26,070 --> 00:39:29,220
与此迭代过程
写软件是真正的关键。

820
00:39:29,220 --> 00:39:33,420
在CS50，而在一般的生活，
一般情况下不应坐下，

821
00:39:33,420 --> 00:39:36,800
心中有一个程序，并尝试写作
整个该死的事情一下子。

822
00:39:36,800 --> 00:39:40,810
>> 这将不可避免地导致的方式
更多的错误比我们自己在这里看到。

823
00:39:40,810 --> 00:39:44,070
就连我，为了这一天，不断
让其他愚蠢的错误，

824
00:39:44,070 --> 00:39:47,480
其实更难错误
这是很难搞清楚。

825
00:39:47,480 --> 00:39:52,095
但你会犯更多的错误越多
行代码你写的一次。

826
00:39:52,095 --> 00:39:54,220
所以这种做法，
编写代码一点点

827
00:39:54,220 --> 00:39:57,930
你是舒服，编译
它，运行它，更普遍的测试，

828
00:39:57,930 --> 00:40:01,370
然后移动on--所以就像我们不停
分层和上周层次感，

829
00:40:01,370 --> 00:40:04,190
从建筑的东西很
简单，更复杂的东西，

830
00:40:04,190 --> 00:40:05,200
做同样的在这里。

831
00:40:05,200 --> 00:40:08,500
不要坐下来，并尝试
写一个完整的问题。

832
00:40:08,500 --> 00:40:10,780
实际上采取这些婴儿的步骤。

833
00:40:10,780 --> 00:40:15,100
>> 现在，字符串是不是所有的
对自己有用。

834
00:40:15,100 --> 00:40:18,210
实际上，我们应该，理想情况下，喜欢
在我们的工具包东西。

835
00:40:18,210 --> 00:40:20,990
因此，让我们真正做到这一点。

836
00:40:20,990 --> 00:40:24,900
>> 现在让我继续前进，掀起
一个稍微不同的程序。

837
00:40:24,900 --> 00:40:28,320
我们会打电话给这个int.c，为整数。

838
00:40:28,320 --> 00:40:30,870
我要去，同样，
包括CS550.h。

839
00:40:30,870 --> 00:40:33,060
我将包括标准IO。

840
00:40:33,060 --> 00:40:36,630
而这将是很常见
在类的这些最初几天。

841
00:40:36,630 --> 00:40:39,050
>> 而我要准备好
我自己用的主要功能。

842
00:40:39,050 --> 00:40:43,370
而现在，而不是得到一个字符串，
让我们继续前进，并得到一个int。

843
00:40:43,370 --> 00:40:49,285
让我们把它叫做我，并把它弄
INT，关闭括号，分号。

844
00:40:49,285 --> 00:40:51,410
现在，让我们做
东西吧，printf的。

845
00:40:51,410 --> 00:40:56,190
>> 比方说像
你好，反斜杠N，逗号我。

846
00:40:56,190 --> 00:41:00,010
所以，我几乎模仿
我所做的只是一个刚才。

847
00:41:00,010 --> 00:41:01,660
我有一个占位符在这里。

848
00:41:01,660 --> 00:41:05,150
我在这里用逗号我，因为我想
堵塞我到该占位符。

849
00:41:05,150 --> 00:41:07,250
>> 因此，让我们继续前进，并尝试
编译此程序。

850
00:41:07,250 --> 00:41:10,060
该文件称为int.c.

851
00:41:10,060 --> 00:41:12,920
所以我要说，让INT输入。

852
00:41:12,920 --> 00:41:16,420
噢，我的上帝，但没什么大不了的，对不对？

853
00:41:16,420 --> 00:41:17,230
有一个错误。

854
00:41:17,230 --> 00:41:19,810
>> 有一个语法错误
这里是程序不能

855
00:41:19,810 --> 00:41:25,460
里面int.c，行编译
七，性格27，错误格式

856
00:41:25,460 --> 00:41:28,400
指定char类型
明星，不管它是什么。

857
00:41:28,400 --> 00:41:30,020
不过，参数类型为int。

858
00:41:30,020 --> 00:41:33,110
>> 所以在这里，我们不打算中场休息
虽然今天是很多的材料，

859
00:41:33,110 --> 00:41:35,710
我们要以压倒你
绝对的C每一个功能，

860
00:41:35,710 --> 00:41:38,070
和编程更一般地，
在短短的这些最初的几个星期。

861
00:41:38,070 --> 00:41:40,400
因此，有经常将是行话
与你不熟悉。

862
00:41:40,400 --> 00:41:43,350
而且，事实上，焦炭星是什么
我们要回来

863
00:41:43,350 --> 00:41:44,830
在两个星期的时间。

864
00:41:44,830 --> 00:41:47,530
>> 但现在，让我们看看如果我们能
解析是熟悉的字眼。

865
00:41:47,530 --> 00:41:50,750
Formats--所以我们听到的格式
说明，格式代码之前。

866
00:41:50,750 --> 00:41:51,840
这是熟悉的。

867
00:41:51,840 --> 00:41:53,840
类型 - 但参数的类型为int。

868
00:41:53,840 --> 00:41:55,980
等一下，我是一个int。

869
00:41:55,980 --> 00:41:59,230
>> 也许％的5事实上
有一些定义的含义。

870
00:41:59,230 --> 00:42:00,230
而且，事实上，它的作用。

871
00:42:00,230 --> 00:42:03,101
一个整数，如果你想
printf的替代它，

872
00:42:03,101 --> 00:42:05,350
你确实有使用
不同的格式说明。

873
00:42:05,350 --> 00:42:06,890
你不会知道这
除非有人告诉你，

874
00:42:06,890 --> 00:42:07,973
或者你已经这样做。

875
00:42:07,973 --> 00:42:10,490
但是我百分之什么
可共同使用

876
00:42:10,490 --> 00:42:12,240
在printf中的一个整数堵塞。

877
00:42:12,240 --> 00:42:14,920
您还可以使用百分比
d表示十进制整数。

878
00:42:14,920 --> 00:42:16,490
但我是好的，简单的在这里。

879
00:42:16,490 --> 00:42:17,590
因此，我们将与该走了。

880
00:42:17,590 --> 00:42:21,160
>> 现在让我继续前进，
重新运行化妆INT，回车。

881
00:42:21,160 --> 00:42:23,328
这是很好的，没有错误。

882
00:42:23,328 --> 00:42:27,260
点斜线int-- OK，不好的用户体验，
因为我没有告诉自己

883
00:42:27,260 --> 00:42:27,760
该怎么办。

884
00:42:27,760 --> 00:42:28,426
但是，这很好。

885
00:42:28,426 --> 00:42:29,480
我迅速迎头赶上。

886
00:42:29,480 --> 00:42:36,260
>> 现在让我去前进，
键入大卫，OK，Zamila，罗布。

887
00:42:36,260 --> 00:42:37,820
好了，所以这是一件好事。

888
00:42:37,820 --> 00:42:41,710
这一次，我使用的功能，
一个拼图，名为get int类型。

889
00:42:41,710 --> 00:42:44,230
而事实证明out--，我们将
看到这个以后在term--

890
00:42:44,230 --> 00:42:47,730
该工作人员CS50已实施
以这样的方式获得的字符串

891
00:42:47,730 --> 00:42:50,350
它只会物理
得到你的字符串。

892
00:42:50,350 --> 00:42:54,340
>> 它已经实施的get int类型
这样一种方式，它仅将

893
00:42:54,340 --> 00:42:55,590
得到一个整数你。

894
00:42:55,590 --> 00:42:57,830
如果你的人，
不配合，这是

895
00:42:57,830 --> 00:43:00,590
从字面上只是要
说重试，重试，重试，

896
00:43:00,590 --> 00:43:05,200
从字面上坐在那里循环，直到
你迫使一些神奇的数字，

897
00:43:05,200 --> 00:43:07,670
像50和50打招呼。

898
00:43:07,670 --> 00:43:11,440
>> 或者，如果我们再次运行此
并键入42，你好42。

899
00:43:11,440 --> 00:43:15,750
这样一来，GET INT功能
那一块拼图内

900
00:43:15,750 --> 00:43:19,050
足够的逻辑，足够的思想，
要弄清楚，什么是一个字？

901
00:43:19,050 --> 00:43:20,330
什么是多少？

902
00:43:20,330 --> 00:43:23,165
只有接受，最终的数字。

903
00:43:23,165 --> 00:43:25,690

904
00:43:25,690 --> 00:43:30,230
>> 因此，原来这
是不是所有的表现力。

905
00:43:30,230 --> 00:43:30,910
至今。

906
00:43:30,910 --> 00:43:33,690
所以，耶，我们最后一次
去很快

907
00:43:33,690 --> 00:43:38,320
为实现游戏和动画，
在划痕和艺术作品。

908
00:43:38,320 --> 00:43:42,260
而在这里，我们正在内容
与世界你好，你好和50。

909
00:43:42,260 --> 00:43:43,696
>> 这是不是所有的令人振奋。

910
00:43:43,696 --> 00:43:46,070
而且，事实上，这些前几
实施例将需要一些时间

911
00:43:46,070 --> 00:43:47,510
在兴奋的增产行动。

912
00:43:47,510 --> 00:43:49,854
但是，我们有这么多
现在控制，实际上。

913
00:43:49,854 --> 00:43:51,770
而且我们要非常
快速启动分层

914
00:43:51,770 --> 00:43:53,870
这些基本的原语的顶部。

915
00:43:53,870 --> 00:43:56,370
>> 但首先，让我们了解
什么限制是。

916
00:43:56,370 --> 00:43:58,620
的东西事实上，人们
刮不容易

917
00:43:58,620 --> 00:44:00,990
让我们做的是真正审视
引擎盖下，

918
00:44:00,990 --> 00:44:03,740
并且明白什么是
计算机是，它能做什么，

919
00:44:03,740 --> 00:44:05,250
和它的局限性是什么。

920
00:44:05,250 --> 00:44:08,580
而且，事实上，缺乏的
理解，潜在地，长期

921
00:44:08,580 --> 00:44:12,520
可以导致我们自己的写作mistakes--
错误，写出不安全的软件，

922
00:44:12,520 --> 00:44:13,880
以某种方式被黑客攻击。

923
00:44:13,880 --> 00:44:17,130
>> 因此，让我们对一些步骤
理解这一点更好一点通过

924
00:44:17,130 --> 00:44:19,710
的，这样说了，下面的例子。

925
00:44:19,710 --> 00:44:23,550
我要继续前进，实现
真正的快一个叫做加法程序。

926
00:44:23,550 --> 00:44:25,134
像，让我们添加一些数字加在一起。

927
00:44:25,134 --> 00:44:27,800
而且我要编写一些角落
在这里，只是复制和粘贴

928
00:44:27,800 --> 00:44:30,270
我在那里之前，恰好
所以我们可以得到更快去。

929
00:44:30,270 --> 00:44:33,090
所以，现在我已经得到了基本的开端
一个叫做加法器程序。

930
00:44:33,090 --> 00:44:34,670
>> 让我们继续前进，做到这一点。

931
00:44:34,670 --> 00:44:38,680
我要继续前进，
比方说和INTx得到得到int类型。

932
00:44:38,680 --> 00:44:39,430
你知道吗？

933
00:44:39,430 --> 00:44:40,990
让我们做一个更好的用户体验。

934
00:44:40,990 --> 00:44:45,740
>> 所以让我们只说X是有效的
提示用户给我们的X.

935
00:44:45,740 --> 00:44:50,600
然后让我先走，说的printf
怎么样y是，这一次期待

936
00:44:50,600 --> 00:44:53,140
从用户的两个值。

937
00:44:53,140 --> 00:44:59,759
然后就让我们继续前进，
比方说，printf的，x和y的总和为。

938
00:44:59,759 --> 00:45:01,300
现在我不想做百分之秒。

939
00:45:01,300 --> 00:45:09,080
我想做％的我，反斜线
N，再插上总和值。

940
00:45:09,080 --> 00:45:10,620
>> 所以，我怎么能去这样做？

941
00:45:10,620 --> 00:45:11,270
你知道吗？

942
00:45:11,270 --> 00:45:12,840
我知道如何使用变量。

943
00:45:12,840 --> 00:45:15,140
让我声明一个新的，INT态。

944
00:45:15,140 --> 00:45:16,770
>> 而我要在这里采取了猜测。

945
00:45:16,770 --> 00:45:21,470
如果在此等号
语言，也许我可以做X加Y，

946
00:45:21,470 --> 00:45:23,660
只要我结束我的
用分号想？

947
00:45:23,660 --> 00:45:28,170
现在我可以回到这里了，插上Z，
完成本以为用分号。

948
00:45:28,170 --> 00:45:33,160
而且，我们现在看到的，如果这些
lines-- x的序列是获得int类型。

949
00:45:33,160 --> 00:45:34,770
Y是获得int类型。

950
00:45:34,770 --> 00:45:37,980
>> 添加x和y，存储在值z--
所以，再一次，记住等号

951
00:45:37,980 --> 00:45:38,560
是不相等的。

952
00:45:38,560 --> 00:45:41,100
这是从右到左分配。

953
00:45:41,100 --> 00:45:45,180
让我们打印出的总和
x和y的是不是字面上Z，

954
00:45:45,180 --> 00:45:46,830
但什么的Z里面。

955
00:45:46,830 --> 00:45:50,090
所以，让我们做加法 -
不错，没有错误这一次。

956
00:45:50,090 --> 00:45:53,030
点斜线加法器，输入，
x被将是1。

957
00:45:53,030 --> 00:45:55,380
>> Y为将是2。

958
00:45:55,380 --> 00:45:58,964
x和y的总和为3。

959
00:45:58,964 --> 00:46:00,130
所以这是一切优秀和良好。

960
00:46:00,130 --> 00:46:03,260
>> 所以，你会想象数学
应该在这样的程序中工作。

961
00:46:03,260 --> 00:46:04,040
但是，你知道吗？

962
00:46:04,040 --> 00:46:06,904
这是可变的，行
12，甚至是必要的？

963
00:46:06,904 --> 00:46:09,820
你不需要的习惯得到
只是存储在变数的事情

964
00:46:09,820 --> 00:46:10,980
只是因为你可以。

965
00:46:10,980 --> 00:46:13,550
并且，实际上，它通常是
认为是不好的设计

966
00:46:13,550 --> 00:46:18,100
如果您正在创建一个变量，叫
中的Z这种情况下，存储在它的东西，

967
00:46:18,100 --> 00:46:21,390
然后立即
使用它，但从来没有一次。

968
00:46:21,390 --> 00:46:24,700
为什么要给东西的名字
像Z如果你从字面上

969
00:46:24,700 --> 00:46:26,770
要使用该
事仅一次，所以

970
00:46:26,770 --> 00:46:29,380
近端创建哪里
它摆在首位，

971
00:46:29,380 --> 00:46:31,052
如此接近的代码行的条款？

972
00:46:31,052 --> 00:46:31,760
所以，你知道吗？

973
00:46:31,760 --> 00:46:34,480
事实证明，C是非常灵活。

974
00:46:34,480 --> 00:46:36,586
如果我真的想
插件值这里，

975
00:46:36,586 --> 00:46:38,210
我并不需要声明一个新的变量。

976
00:46:38,210 --> 00:46:41,680
我可以外挂x加
Y，因为C理解

977
00:46:41,680 --> 00:46:43,390
算术和数学运算。

978
00:46:43,390 --> 00:46:47,140
>> 所以，我可以简单地说，这样做数学，
X加Y，无论这些值，

979
00:46:47,140 --> 00:46:50,780
堵塞造成
整成字符串。

980
00:46:50,780 --> 00:46:53,730
因此，这可能是，虽然
只有一条线短，

981
00:46:53,730 --> 00:46:58,480
一个更好的设计，更好的节目，
因为有更少的代码，因此

982
00:46:58,480 --> 00:46:59,921
少我明白。

983
00:46:59,921 --> 00:47:01,920
而且这也只是清洁，
只要我们不是

984
00:47:01,920 --> 00:47:04,620
引进新词，
新的符号，比如Z，

985
00:47:04,620 --> 00:47:07,510
即使他们真的不
服务太大的目的。

986
00:47:07,510 --> 00:47:12,890
>> 不幸的是，数学不是
所有可靠的时候。

987
00:47:12,890 --> 00:47:15,270
让我们继续前进，并做到这一点。

988
00:47:15,270 --> 00:47:18,200
我要继续前进
现在做到以下几点。

989
00:47:18,200 --> 00:47:27,650
>> 让我们做的printf，我百分之，百分之加
我，应该我百分之，反斜线ñ。

990
00:47:27,650 --> 00:47:32,240
而我要做的this-- XYX加y。

991
00:47:32,240 --> 00:47:34,821
所以我只是要改写
此略有不同在这里。

992
00:47:34,821 --> 00:47:36,320
我只想做一个快速的健全性检查。

993
00:47:36,320 --> 00:47:37,986
再次，让我们不要超前。

994
00:47:37,986 --> 00:47:41,420
做加法，点斜线加法器。

995
00:47:41,420 --> 00:47:44,950
x为1，y为2，1加2是3。

996
00:47:44,950 --> 00:47:45,870
所以这是很好的。

997
00:47:45,870 --> 00:47:49,060
但是，让我们现在这个复杂
了一下，并创建一个新的文件。

998
00:47:49,060 --> 00:47:53,350
>> 我会打电话给这一个，
说，整型，复数的整数。

999
00:47:53,350 --> 00:47:55,980
让我先在那里我是刚才。

1000
00:47:55,980 --> 00:47:57,770
但是，现在让我们做一些其他的线路。

1001
00:47:57,770 --> 00:48:03,430
让我继续前进，做到以下几点，
printf的，我百分比，减去％的我，

1002
00:48:03,430 --> 00:48:08,959
是我百分之逗号X，逗号YX减Y。

1003
00:48:08,959 --> 00:48:10,750
所以我稍微做
不同的数学存在。

1004
00:48:10,750 --> 00:48:11,624
让我们做一个又一个。

1005
00:48:11,624 --> 00:48:16,610
所以，我百分之百分之倍
我是百分之一，反斜线ñ。

1006
00:48:16,610 --> 00:48:21,430
让我们插件x和y，以及x乘以y。

1007
00:48:21,430 --> 00:48:24,530
我们将使用星号上
您的计算机时代。

1008
00:48:24,530 --> 00:48:26,390
>> 你不会用x。 x是
这里变量名。

1009
00:48:26,390 --> 00:48:28,270
你用乘法的明星。

1010
00:48:28,270 --> 00:48:29,020
让我们做一个。

1011
00:48:29,020 --> 00:48:34,580
百分之printf的我，分
由百分之一，百分之是我，

1012
00:48:34,580 --> 00:48:40,460
反斜杠ñ。 XY由y--分
所以你用C中的正斜杠

1013
00:48:40,460 --> 00:48:41,502
做除法。

1014
00:48:41,502 --> 00:48:42,460
让我们做一个其他的。

1015
00:48:42,460 --> 00:48:47,920

1016
00:48:47,920 --> 00:48:55,240
我百分比剩余，分
由百分之一，百分之是我。

1017
00:48:55,240 --> 00:48:59,550
xy--现在剩下的
是什么遗留下来的。

1018
00:48:59,550 --> 00:49:02,980
当您尝试将一
分母变成分子，

1019
00:49:02,980 --> 00:49:05,570
有多少是遗留下来
你不能分裂出去？

1020
00:49:05,570 --> 00:49:07,910
>> 所以是不是真的，
必须地，一个符号

1021
00:49:07,910 --> 00:49:09,470
我们在小学用于此。

1022
00:49:09,470 --> 00:49:13,830
但是，在C.你可以
例如x模y，其中

1023
00:49:13,830 --> 00:49:18,000
在这个context--这个百分号
容易混淆的，当你在里面

1024
00:49:18,000 --> 00:49:20,170
双引号的，
里面的printf，百分比

1025
00:49:20,170 --> 00:49:21,830
用作格式说明。

1026
00:49:21,830 --> 00:49:25,420
>> 当您使用百分比之外
在数学表达式，

1027
00:49:25,420 --> 00:49:29,910
它是模块化模运算符
arithmetic--我们的目的

1028
00:49:29,910 --> 00:49:33,650
在这里，只是意味着，什么是
x的剩余除以y？

1029
00:49:33,650 --> 00:49:36,130
所以x除以y为x斜线年。

1030
00:49:36,130 --> 00:49:38,220
什么是x的除以y的余数？

1031
00:49:38,220 --> 00:49:41,780
它的x模Y，作为一个程序员会说。

1032
00:49:41,780 --> 00:49:48,300
>> 所以，如果我在这里没有失误，让我
继续前进，使整型，复数，美观大方，

1033
00:49:48,300 --> 00:49:50,010
和点斜线整数。

1034
00:49:50,010 --> 00:49:55,270
让我们继续前进，
这样做，比方说，1，10。

1035
00:49:55,270 --> 00:49:58,390
好吧，1加10是11，检查。

1036
00:49:58,390 --> 00:50:01,240
1减去10为负9，检查。

1037
00:50:01,240 --> 00:50:03,420
>> 1次10是10，检查。

1038
00:50:03,420 --> 00:50:07,090
1 10 is--分
OK，我们将跳过一个。

1039
00:50:07,090 --> 00:50:09,480
余数1除以10为1。

1040
00:50:09,480 --> 00:50:10,680
这是正确的。

1041
00:50:10,680 --> 00:50:12,630
但有一个错误在这里。

1042
00:50:12,630 --> 00:50:15,390
>> 所以，一个我把我的
交出，不正确的。

1043
00:50:15,390 --> 00:50:16,670
我的意思是，这是接近0。

1044
00:50:16,670 --> 00:50:20,670
1除以10，你知道，如果我们
削减一些角落，当然，它是零。

1045
00:50:20,670 --> 00:50:28,050
但它确实应该1/10，
0.1或0.10，0.1000，或等等。

1046
00:50:28,050 --> 00:50:30,600
>> 它真的不应该是零。

1047
00:50:30,600 --> 00:50:35,990
那么，事实证明，电脑
从字面上做什么，我们告诉它做的事。

1048
00:50:35,990 --> 00:50:39,460
我们正在做数学一样x除以y。

1049
00:50:39,460 --> 00:50:44,680
和x和y，每行
代码前，都是整数。

1050
00:50:44,680 --> 00:50:50,440
>> 此外，第15行，我们都
告诉printf的，嘿嘿，printf的插件

1051
00:50:50,440 --> 00:50:54,230
的整数，插件的整数，
插件的integer--具体

1052
00:50:54,230 --> 00:50:57,580
x，然后y和则x
除以y。 x和y是整数。

1053
00:50:57,580 --> 00:50:59,060
我们是好那里。

1054
00:50:59,060 --> 00:51:01,250
>> 但是，为x除以x？

1055
00:51:01,250 --> 00:51:06,790
点¯x分由y是应该的，
数学上，1/10，或0.1，

1056
00:51:06,790 --> 00:51:11,600
这是一个实数，一个实数
有潜在的，一个小数点。

1057
00:51:11,600 --> 00:51:13,230
这不是一个整数。

1058
00:51:13,230 --> 00:51:18,290
>> 但是，什么是最接近
整数到1/10，或0.1？

1059
00:51:18,290 --> 00:51:21,114
是的，这一种是零。

1060
00:51:21,114 --> 00:51:22,030
0.1是这个样子了。

1061
00:51:22,030 --> 00:51:22,890
和1是本得多。

1062
00:51:22,890 --> 00:51:25,870
所以1/10更接近
0比它为一个。

1063
00:51:25,870 --> 00:51:30,800
>> 所以什么C是做us--
样的，因为我们告诉它中场休息

1064
00:51:30,800 --> 00:51:32,600
被截断的整数。

1065
00:51:32,600 --> 00:51:40,540
它采取的值，而这又是
应该是这样的0.1000，

1066
00:51:40,540 --> 00:51:41,800
0等等。

1067
00:51:41,800 --> 00:51:45,320
而且这一切截断
小数点后

1068
00:51:45,320 --> 00:51:47,510
这样，所有这一切
的东西，因为它没有

1069
00:51:47,510 --> 00:51:51,910
适合的整数的概念，这
就像负1，0，1的数，

1070
00:51:51,910 --> 00:51:55,830
上下，它抛出了一切
小数点，因​​为你以后

1071
00:51:55,830 --> 00:51:59,020
不适合小数点
在由定义的整数。

1072
00:51:59,020 --> 00:52:01,290
>> 因此，这里的答案是零。

1073
00:52:01,290 --> 00:52:02,600
那么，我们如何解决这个问题？

1074
00:52:02,600 --> 00:52:04,400
我们需要另一种解决方案都在一起。

1075
00:52:04,400 --> 00:52:06,880
我们可以做到这一点，如下所示。

1076
00:52:06,880 --> 00:52:12,820
>> 让我继续前进，创造一个新的
文件中，这个叫floats.c。

1077
00:52:12,820 --> 00:52:16,500
这里保存了
同一目录下，float.c。

1078
00:52:16,500 --> 00:52:19,360

1079
00:52:19,360 --> 00:52:23,260
让我继续和复制
一些早期的代码。

1080
00:52:23,260 --> 00:52:27,690
>> 但是，而不是领
一个int，让我们做到这一点。

1081
00:52:27,690 --> 00:52:31,037
给我一个浮点值
名为x。其中，浮点

1082
00:52:31,037 --> 00:52:33,370
值只是从字面上
一些与一个浮点。

1083
00:52:33,370 --> 00:52:34,410
它可以移动到左边，在右边。

1084
00:52:34,410 --> 00:52:35,530
这是一个实数。

1085
00:52:35,530 --> 00:52:38,050
>> 让我没有打电话
得到INT，但得到浮动，

1086
00:52:38,050 --> 00:52:41,420
这也就是菜单中
在C250库选项。

1087
00:52:41,420 --> 00:52:43,220
让我们修改y为float。

1088
00:52:43,220 --> 00:52:45,000
因此，这将成为获取浮动。

1089
00:52:45,000 --> 00:52:47,620
>> 而现在，我们不希望在整数堵塞。

1090
00:52:47,620 --> 00:52:53,130
事实证明，我们必须使用百分
如欲浮动，浮法％的楼

1091
00:52:53,130 --> 00:52:54,560
现在保存它。

1092
00:52:54,560 --> 00:53:01,220
而现在，手指交叉，使
彩车，美观大方，点斜线浮动。

1093
00:53:01,220 --> 00:53:04,280
x被打算当1ÿ
将会再次成为10。

1094
00:53:04,280 --> 00:53:08,240
>> 而且，美观大方，OK我除了是正确的。

1095
00:53:08,240 --> 00:53:10,240
我希望更多的，
但我忘了写。

1096
00:53:10,240 --> 00:53:13,250
因此，让我们去解决这个逻辑上的错误。

1097
00:53:13,250 --> 00:53:16,280
>> 让我们继续前进，抓住以下。

1098
00:53:16,280 --> 00:53:18,080
我们只是做一些复制和粘贴。

1099
00:53:18,080 --> 00:53:20,080
而我要说负。

1100
00:53:20,080 --> 00:53:21,890
>> 而我要说倍。

1101
00:53:21,890 --> 00:53:24,060
而我要说的分歧。

1102
00:53:24,060 --> 00:53:28,240
而且我不会做模，
这是不一样锗这里，

1103
00:53:28,240 --> 00:53:33,690
用f分割，时间plus--
好吧，让我们再次做到这一点。

1104
00:53:33,690 --> 00:53:44,210
>> 制作花车，点斜线花车，
1，10，还有 - 不错，没有，OK。

1105
00:53:44,210 --> 00:53:45,250
所以，我是个白痴。

1106
00:53:45,250 --> 00:53:47,000
因此，这是很常见
在计算机科学

1107
00:53:47,000 --> 00:53:49,780
做出愚蠢的错误是这样的。

1108
00:53:49,780 --> 00:53:53,100
>> 用于教导的目的，
我真正想做的事

1109
00:53:53,100 --> 00:53:57,410
在这里改变科学
要加，零下，到时候，

1110
00:53:57,410 --> 00:54:01,140
和来划分，你希望
这个练习过程中发现。

1111
00:54:01,140 --> 00:54:04,700
现在让我们重新编译这个
节目，做点斜线浮动。

1112
00:54:04,700 --> 00:54:07,950
>> 而第三次，我们
看它是否符合我的期望。

1113
00:54:07,950 --> 00:54:21,480
1，10，输入，是的，OK，1.000，
由10.000分，是0.100000。

1114
00:54:21,480 --> 00:54:24,952
而事实证明，我们能控制多少
数字是那些小数点后。

1115
00:54:24,952 --> 00:54:25,660
实际上，我们会的。

1116
00:54:25,660 --> 00:54:26,790
我们会回来这一点。

1117
00:54:26,790 --> 00:54:28,440
>> 但现在，其实数学是正确的。

1118
00:54:28,440 --> 00:54:30,090
那么，又是什么这里的外卖？

1119
00:54:30,090 --> 00:54:33,050
事实证明，在C，有
不仅只是strings--，事实上，

1120
00:54:33,050 --> 00:54:36,120
有没有真正的，因为我们
添加这些与CS50库。

1121
00:54:36,120 --> 00:54:37,710
但也有不只是整数。

1122
00:54:37,710 --> 00:54:38,990
>> 也有浮动。

1123
00:54:38,990 --> 00:54:42,810
而事实证明了一堆其他数据
类型也一样，我们将在不久使用。

1124
00:54:42,810 --> 00:54:46,270
事实证明，如果你想单
字符，而不是一个字符串，

1125
00:54:46,270 --> 00:54:47,610
你可以只使用一个char。

1126
00:54:47,610 --> 00:54:52,350
>> 事实证明，如果你想有一个布尔值，
一个布尔值，只有真或假，

1127
00:54:52,350 --> 00:54:56,840
感谢CS50库，我们已经
添加到C BOOL数据类型为好。

1128
00:54:56,840 --> 00:54:59,180
但它也存在于
许多其他语言。

1129
00:54:59,180 --> 00:55:04,130
而事实证明，有时你
需要更大的数字则默认情况下都

1130
00:55:04,130 --> 00:55:05,210
与整型和浮点型。

1131
00:55:05,210 --> 00:55:10,590
>> 并且，实际上，双是一个数字
使用不是32位，但64位。

1132
00:55:10,590 --> 00:55:14,990
和长隆是一个数字，
不使用32位，但64位，

1133
00:55:14,990 --> 00:55:19,190
分别为浮点
值和整数，分别为。

1134
00:55:19,190 --> 00:55:22,780
所以，让我们现在实际上
看到这个动作。

1135
00:55:22,780 --> 00:55:26,150
>> 我要在这里继续
并掀起另一个程序。

1136
00:55:26,150 --> 00:55:32,020
在这里，我要继续前进
并且确实包括CS50.h.

1137
00:55:32,020 --> 00:55:34,910
让我走，包括标准IO.h.

1138
00:55:34,910 --> 00:55:37,320
>> 你会发现什么
时髦发生在这里。

1139
00:55:37,320 --> 00:55:40,592
这不是颜色编码的东西
以同样的方式，因为它以前那样。

1140
00:55:40,592 --> 00:55:43,550
而事实证明，那是因为我
没有给的东西的文件名。

1141
00:55:43,550 --> 00:55:47,270
>> 我会打电话给这一个
sizeof.c，并创下保存。

1142
00:55:47,270 --> 00:55:51,039
并注意发生了什么我很
白色的代码针对黑色背景。

1143
00:55:51,039 --> 00:55:52,830
现在，至少有
一些紫色在那里。

1144
00:55:52,830 --> 00:55:54,490
它是语法高亮。

1145
00:55:54,490 --> 00:55:57,700
>> 这是因为，很简单，我已经
告诉IDE哪些类型的文件

1146
00:55:57,700 --> 00:56:01,060
它是由给它一个名称，
具体的文件扩展名。

1147
00:56:01,060 --> 00:56:03,620
现在，让我们继续前进，做到这一点。

1148
00:56:03,620 --> 00:56:08,910
我要继续前进，很
简单地打印出following--布尔

1149
00:56:08,910 --> 00:56:11,080
是百分之LU。

1150
00:56:11,080 --> 00:56:12,950
>> 我们会回来的
在短短的时刻。

1151
00:56:12,950 --> 00:56:15,840
然后我要去
布尔的打印尺寸。

1152
00:56:15,840 --> 00:56:18,170
而现在，只是为了节省
我有一段时间，我

1153
00:56:18,170 --> 00:56:20,280
要做一个整体
这些一堆一次。

1154
00:56:20,280 --> 00:56:24,620
而且，具体而言，我要去
更改为一个char和char。

1155
00:56:24,620 --> 00:56:27,760
这一次，我要改变
以一张双人床和一个双。

1156
00:56:27,760 --> 00:56:31,440
>> 这一次，我要改变
一个浮子和一个浮动。

1157
00:56:31,440 --> 00:56:35,670
这一次，我要去
更改为int和一个int。

1158
00:56:35,670 --> 00:56:38,660
而这一次，我要去
更改为一个很长很长。

1159
00:56:38,660 --> 00:56:40,840
它仍然采取
时间长了，很长很长。

1160
00:56:40,840 --> 00:56:44,572
>> 然后，最后，我放弃
我太多了，字符串。

1161
00:56:44,572 --> 00:56:47,030
事实证明，在C，有
被称为特殊的运算符

1162
00:56:47,030 --> 00:56:50,260
那大小是字面上
要在运行时，

1163
00:56:50,260 --> 00:56:52,099
告诉我们的大小
这些变量。

1164
00:56:52,099 --> 00:56:53,890
这是一种方式，现在，
我们可以连接回

1165
00:56:53,890 --> 00:56:57,140
上周的讨论
数据和代表性。

1166
00:56:57,140 --> 00:57:00,330
>> 让我继续前进，编译
的点斜线大小的尺寸。

1167
00:57:00,330 --> 00:57:01,210
让我们来看看。

1168
00:57:01,210 --> 00:57:05,210
事实证明，在C，
特别是在CS50 IDE，

1169
00:57:05,210 --> 00:57:08,170
特别是在
操作系统Ubuntu的，

1170
00:57:08,170 --> 00:57:11,100
这是一个64位操作
系统在此情况下，

1171
00:57:11,100 --> 00:57:14,189
一个布尔打算
使用的空间的一个字节。

1172
00:57:14,189 --> 00:57:16,480
这就是大小如何衡量，
不在位，但在字节。

1173
00:57:16,480 --> 00:57:18,690
并且记得，一个字节为8位。

1174
00:57:18,690 --> 00:57:22,030
因此，一个布尔值，即使你
技术上只需要一个0或1，

1175
00:57:22,030 --> 00:57:24,092
这是一个有点浪费
如何我们已经实现了它。

1176
00:57:24,092 --> 00:57:26,800
它实际上是要使用一个整体
byte--因此所有零，也许是

1177
00:57:26,800 --> 00:57:31,050
所有的人，或者类似的东西，
或只是一个1间八位。

1178
00:57:31,050 --> 00:57:34,962
>> 一个char，同时，用于字符
每一样上周ASCII字符，

1179
00:57:34,962 --> 00:57:36,170
将是一个字符。

1180
00:57:36,170 --> 00:57:42,340
这SYNCHS与我们的观念
它是不超过256 bits--相当，

1181
00:57:42,340 --> 00:57:45,360
SYNCHS了它是没有
超过8位，这

1182
00:57:45,360 --> 00:57:47,450
为我们提供了多达256个值。

1183
00:57:47,450 --> 00:57:49,680
双打算
为8字节或64位。

1184
00:57:49,680 --> 00:57:50,510
>> 一个浮点是4。

1185
00:57:50,510 --> 00:57:51,690
一个int是4。

1186
00:57:51,690 --> 00:57:52,980
长，长为8。

1187
00:57:52,980 --> 00:57:54,716
和一个字符串为8。

1188
00:57:54,716 --> 00:57:55,840
但是不要担心。

1189
00:57:55,840 --> 00:57:57,340
我们要剥开那层。

1190
00:57:57,340 --> 00:57:59,940
事实证明，字符串可以
超过8个字节。

1191
00:57:59,940 --> 00:58:02,310
>> 而且，事实上，我们已经写
弦已经，世界你好，

1192
00:58:02,310 --> 00:58:03,700
超过8个字节。

1193
00:58:03,700 --> 00:58:06,270
但是，我们会回来的
在短短的时刻。

1194
00:58:06,270 --> 00:58:09,690
但带走这里如下。

1195
00:58:09,690 --> 00:58:15,320
>> 任何计算机中仅具有有限
的存储器和空间量。

1196
00:58:15,320 --> 00:58:17,860
你只能储存那么多
你的Mac或PC上的文件。

1197
00:58:17,860 --> 00:58:23,030
您只能存储在这么多程序
RAM运行一次，一定，甚至

1198
00:58:23,030 --> 00:58:26,360
使用虚拟内存，因为
你的内存有限数量。

1199
00:58:26,360 --> 00:58:28,990
>> 而只是为了picture--如果
你从来没有打开一台笔记本电脑

1200
00:58:28,990 --> 00:58:31,300
或下令额外的内存
对于一台电脑，你

1201
00:58:31,300 --> 00:58:33,670
可能不知道
你的电脑里面

1202
00:58:33,670 --> 00:58:36,590
是一些看起来
有点像这样。

1203
00:58:36,590 --> 00:58:40,540
所以，这只是一个普通的公司命名为
至关重要的是，使计算机的RAM。

1204
00:58:40,540 --> 00:58:43,620
和RAM就是程序
而他们正在运行生活。

1205
00:58:43,620 --> 00:58:46,630
>> 所以每次Mac或PC，当您双击上
点击一个程序，它打开了，

1206
00:58:46,630 --> 00:58:48,921
它打开了一些Word文档
或类似的东西，

1207
00:58:48,921 --> 00:58:51,764
它存储在临时
RAM，RAM因为速度更快

1208
00:58:51,764 --> 00:58:53,680
比你的硬盘上，或
你的固态硬盘。

1209
00:58:53,680 --> 00:58:56,600
所以，这只是程序的地方去
当他们正在运行的生活，

1210
00:58:56,600 --> 00:58:58,060
或当正在使用的文件。

1211
00:58:58,060 --> 00:59:00,890
>> 所以，你有事情看起来
这样你的笔记本电脑里面，

1212
00:59:00,890 --> 00:59:03,320
或者稍微大一点的东西
里面的桌面。

1213
00:59:03,320 --> 00:59:07,440
但关键是你只有一个
有限数量的这些事情。

1214
00:59:07,440 --> 00:59:11,230
还有的只是一个有限的
硬件坐在这张桌子右边

1215
00:59:11,230 --> 00:59:11,730
这里。

1216
00:59:11,730 --> 00:59:15,920
>> 因此，可以肯定，我们不能存储
无限长的数字。

1217
00:59:15,920 --> 00:59:19,030
而且，然而，如果你想回
小学的时候，有多少位可以

1218
00:59:19,030 --> 00:59:21,400
你有权利
一个小数点？

1219
00:59:21,400 --> 00:59:24,680
对于这个问题，有多少位可以
你有一个小数点左边？

1220
00:59:24,680 --> 00:59:26,300
真的，无限多的。

1221
00:59:26,300 --> 00:59:30,840
>> 现在，我们人类唯一可能
知道如何发音万元，

1222
00:59:30,840 --> 00:59:34,990
和十亿，万亿，和
万亿和三次方。

1223
00:59:34,990 --> 00:59:39,370
而我推的限制我
understanding--或my--我明白

1224
00:59:39,370 --> 00:59:41,110
数字，但我
数字的发音。

1225
00:59:41,110 --> 00:59:44,720
但他们可以得到无限大
无限多的数字向左

1226
00:59:44,720 --> 00:59:47,050
或小数点的右边。

1227
00:59:47,050 --> 00:59:50,040
>> 但电脑只有一个
内存量有限，

1228
00:59:50,040 --> 00:59:53,510
晶体管的一个有限数量，一
数量有限的内部灯泡。

1229
00:59:53,510 --> 00:59:57,350
会发生什么时
您运行的空间？

1230
00:59:57,350 --> 00:59:59,620
换句话说，如果
回想起上周

1231
00:59:59,620 --> 01:00:03,160
当我们谈到数字
自己被代表二进制，

1232
01:00:03,160 --> 01:00:05,480
假设我们有
这8位值在这里。

1233
01:00:05,480 --> 01:00:08,290
>> 而且我们有七个1的和一个0。

1234
01:00:08,290 --> 01:00:10,827
而假设我们想
添加1至这个值。

1235
01:00:10,827 --> 01:00:12,410
这是一个非常大的数字现在。

1236
01:00:12,410 --> 01:00:16,610
>> 这是254，如果我没有记错
从上周权的数学。

1237
01:00:16,610 --> 01:00:19,480
但是，如果我改变
最右边是0到1？

1238
01:00:19,480 --> 01:00:22,800
整数，
当然，成为8个1的。

1239
01:00:22,800 --> 01:00:24,050
所以，我们还是不错的。

1240
01:00:24,050 --> 01:00:27,204
>> 这可能代表
255，虽然根据上下文

1241
01:00:27,204 --> 01:00:29,120
它实际上代表
负数。

1242
01:00:29,120 --> 01:00:31,240
但更多的是另一次。

1243
01:00:31,240 --> 01:00:34,220
这感觉就像它是关于
高达我可以指望。

1244
01:00:34,220 --> 01:00:35,290
>> 现在，它只有8位。

1245
01:00:35,290 --> 01:00:38,170
而我的Mac，当然，有办法
内存大于8位。

1246
01:00:38,170 --> 01:00:39,170
但它确实有有限的。

1247
01:00:39,170 --> 01:00:43,230
所以同样的观点也适用，即使我们
有更多的人，这些在屏幕上。

1248
01:00:43,230 --> 01:00:47,020
>> 但是，如果你发生了什么
存储该号码，255，

1249
01:00:47,020 --> 01:00:49,290
并且要算1位高？

1250
01:00:49,290 --> 01:00:51,600
你想去从255到256。

1251
01:00:51,600 --> 01:00:55,800
的问题，当然，是如果
从零开始，就像上周算起，

1252
01:00:55,800 --> 01:00:59,670
你不能指望高
256，更不用说257，

1253
01:00:59,670 --> 01:01:02,584
别说258，男因为什么
当您添加1会怎么样？

1254
01:01:02,584 --> 01:01:05,000
如果你做旧小学
方法，你把这里1，

1255
01:01:05,000 --> 01:01:08,150
然后1加1是2，但是这
真的是零，你扛1，

1256
01:01:08,150 --> 01:01:09,695
扛1，携带1。

1257
01:01:09,695 --> 01:01:12,620
所有这些事情，
这些1的，去到零。

1258
01:01:12,620 --> 01:01:17,820
和你风，是的，正如有人
在左手侧所指出的，一个1。

1259
01:01:17,820 --> 01:01:22,540
但是，一切都可以
真正看到并装入内存

1260
01:01:22,540 --> 01:01:27,960
是只有八0年代，这是说
在某些时候，如果你一台电脑，

1261
01:01:27,960 --> 01:01:32,490
试着计数足够高了，你
要环绕，这似乎

1262
01:01:32,490 --> 01:01:35,850
零，或者甚至负
号，这是大于零甚至更低。

1263
01:01:35,850 --> 01:01:37,260
>> 我们可以样的看到这一点。

1264
01:01:37,260 --> 01:01:39,900
我要继续写
一个真正的快速程序在这里。

1265
01:01:39,900 --> 01:01:43,690
我要继续写
一个叫溢出程序。

1266
01:01:43,690 --> 01:01:49,980
包括CS50.h包括
标准IO.h--哦，

1267
01:01:49,980 --> 01:01:51,730
我真的很想念我的语法高亮。

1268
01:01:51,730 --> 01:01:54,440
因此，让我们这个保存为overflow.c。

1269
01:01:54,440 --> 01:01:57,084
>> 而现在INT主要void--
过不了多久，我们就会

1270
01:01:57,084 --> 01:01:59,500
回过头来解释为什么
我们继续写INT主作废。

1271
01:01:59,500 --> 01:02:02,080
但现在，我们只是做
它，视之为理所当然。

1272
01:02:02,080 --> 01:02:06,200
让我们给自己一个int，
并初始化为0。

1273
01:02:06,200 --> 01:02:11,716
>> 让我们再对INT做我得到zero--
其实，让我们做一个无限循环

1274
01:02:11,716 --> 01:02:12,590
看看会发生什么。

1275
01:02:12,590 --> 01:02:22,440
虽然如此，那么让我们打印出ñ
是我百分比，反斜线N，插件在正。

1276
01:02:22,440 --> 01:02:27,200
但是，现在，让我们做n得到n与1。

1277
01:02:27,200 --> 01:02:29,660
>> 因此，换句话说，在每
这个无限循环迭代，

1278
01:02:29,660 --> 01:02:32,550
让我们取n的值，
并把它加1，然后

1279
01:02:32,550 --> 01:02:34,350
将结果存储回在正在左侧。

1280
01:02:34,350 --> 01:02:37,150
而且，事实上，我们已经看到了语法
微微就是这样，简单。

1281
01:02:37,150 --> 01:02:39,730
一个很棒的技巧反而
编写出这一切的，

1282
01:02:39,730 --> 01:02:42,770
你可以居然说一个n加等于1。

1283
01:02:42,770 --> 01:02:47,480
>> 或者，如果你真的想成为幻想，
你可以说n与加分号。

1284
01:02:47,480 --> 01:02:50,130
但后两个都只是
我们会打电话语法糖

1285
01:02:50,130 --> 01:02:50,790
对的第一件事。

1286
01:02:50,790 --> 01:02:53,456
>> 的第一件事是更加明确，
完全正常的，完全正确的。

1287
01:02:53,456 --> 01:02:55,470
但是，这是比较常见的，我会说。

1288
01:02:55,470 --> 01:02:57,210
所以，我们会为短短的时刻做到这一点。

1289
01:02:57,210 --> 01:03:01,685
>> 现在，让我们做溢出，这听起来
而不祥，点斜线溢出。

1290
01:03:01,685 --> 01:03:04,380

1291
01:03:04,380 --> 01:03:09,852
让我们来看看，正变得越来越蛮大的。

1292
01:03:09,852 --> 01:03:11,310
但我们认为，有多大可能得到ň？

1293
01:03:11,310 --> 01:03:12,870
>> n是一个int。

1294
01:03:12,870 --> 01:03:16,400
我们看到刚才用的大小
例子，一个int是四个字节。

1295
01:03:16,400 --> 01:03:22,070
我们从上周知道，四个字节是
32位，因为8次4，这是32。

1296
01:03:22,070 --> 01:03:23,460
那将是4个十亿。

1297
01:03:23,460 --> 01:03:25,802
>> 而我们可达80万。

1298
01:03:25,802 --> 01:03:28,510
这将永远采取
数高达我所能。

1299
01:03:28,510 --> 01:03:30,635
所以我要继续前进，
正如你可能过不了多久，

1300
01:03:30,635 --> 01:03:34,910
并创下控制C--坦言，控制
C，很多，其中对照C一般

1301
01:03:34,910 --> 01:03:36,034
手段取消。

1302
01:03:36,034 --> 01:03:38,200
不幸的是，因为这
在云中运行时，

1303
01:03:38,200 --> 01:03:41,190
有时云
吐出了这么多东西，

1304
01:03:41,190 --> 01:03:44,180
如此多的产量，这将
取一小会儿我输入

1305
01:03:44,180 --> 01:03:45,630
去云。

1306
01:03:45,630 --> 01:03:49,240
所以，即使我打
对照C几秒钟前，

1307
01:03:49,240 --> 01:03:53,110
这绝对是侧
无限循环的效果。

1308
01:03:53,110 --> 01:03:56,070
>> 因此在这种情况下，我们
要离开的是。

1309
01:03:56,070 --> 01:03:59,050
而且我们要增加另一个
在这里的终端窗口

1310
01:03:59,050 --> 01:04:03,186
与加，这当然不
这样，因为它仍在思考。

1311
01:04:03,186 --> 01:04:05,310
让我们继续前进，并
多了几分合理性。

1312
01:04:05,310 --> 01:04:07,768
>> 我要继续前进，做
这只有有限多次。

1313
01:04:07,768 --> 01:04:10,047
让我们用一个for循环，
我前面提到。

1314
01:04:10,047 --> 01:04:10,630
我们开工吧。

1315
01:04:10,630 --> 01:04:13,430
再给我一次变量int我得到0。

1316
01:04:13,430 --> 01:04:17,430
我不到，比方说，64个I ++。

1317
01:04:17,430 --> 01:04:24,010
现在让我继续和打印
出n是百分之一，逗号ñ。

1318
01:04:24,010 --> 01:04:27,547
然后N--这仍然是
要采取永远。

1319
01:04:27,547 --> 01:04:28,130
我们开工吧。

1320
01:04:28,130 --> 01:04:30,620
>> n得到n次2。

1321
01:04:30,620 --> 01:04:34,140
或者我们可以被看中
做次等于2。

1322
01:04:34,140 --> 01:04:37,120
但是，让我们只说ñ
等于本身，乘以2。

1323
01:04:37,120 --> 01:04:39,321
换句话说，在该
程序的新版本，

1324
01:04:39,321 --> 01:04:41,820
我不想永远等待
从像80万至4十亿。

1325
01:04:41,820 --> 01:04:43,070
就让我们这种过度使用。

1326
01:04:43,070 --> 01:04:44,920
>> 让我们实际上每次加倍ñ。

1327
01:04:44,920 --> 01:04:47,660
其中，召回，加倍是
对面有当然的。

1328
01:04:47,660 --> 01:04:50,035
和而上周我们有
重复的事情，并再次，

1329
01:04:50,035 --> 01:04:52,200
又一次，超快速，
加倍必将

1330
01:04:52,200 --> 01:04:58,080
1让我们以最大的可能
值，我们可以用一个int计数。

1331
01:04:58,080 --> 01:04:59,750
>> 因此，让我们做的正是这一点。

1332
01:04:59,750 --> 01:05:01,720
我们再回过头来此不久。

1333
01:05:01,720 --> 01:05:04,180
但是这又好比
在从无到有的重复块。

1334
01:05:04,180 --> 01:05:05,600
你会不久使用。

1335
01:05:05,600 --> 01:05:10,170
>> 这也就意味着，从零计数
达，但不相等，为64。

1336
01:05:10,170 --> 01:05:14,285
而在此每次迭代
循环，只是不停地增加i。

1337
01:05:14,285 --> 01:05:18,990
所以，我++  - 这一般结构
第7行仅仅是一个超级常见的方式

1338
01:05:18,990 --> 01:05:22,290
重复的部分线路
代码，一些次数。

1339
01:05:22,290 --> 01:05:23,362
哪行代码？

1340
01:05:23,362 --> 01:05:25,570
这些大括号，如你
可能从现在收集，

1341
01:05:25,570 --> 01:05:26,780
手段，做到以下几点。

1342
01:05:26,780 --> 01:05:29,510
>> 它像划痕，当
它具有黄色块

1343
01:05:29,510 --> 01:05:32,680
和其他颜色的那种
拥抱或拥抱其他块。

1344
01:05:32,680 --> 01:05:34,750
这就是那些花
括号在这里做。

1345
01:05:34,750 --> 01:05:40,200
所以，如果我得到了我的语法right--你
可以看到C表示胡萝卜符号

1346
01:05:40,200 --> 01:05:42,706
这就是我多少次
试图解决这个问题。

1347
01:05:42,706 --> 01:05:45,330
因此，让我们摆脱的那一个
干脆，并关闭该窗口。

1348
01:05:45,330 --> 01:05:46,520
我们将使用新的。

1349
01:05:46,520 --> 01:05:51,980
使溢出，点斜杠
溢出，进入，所有的权利，

1350
01:05:51,980 --> 01:05:53,090
它看起来坏在第一。

1351
01:05:53,090 --> 01:05:56,200
但是，让我们向后滚动的时候，
因为我这样做64次。

1352
01:05:56,200 --> 01:05:58,700
>> 和在第一时间通知，n是1。

1353
01:05:58,700 --> 01:06:03,110
第二次，n为2，
然后4，然后按8，然后16。

1354
01:06:03,110 --> 01:06:09,450
并尽快似乎
我得到低于约1十亿，

1355
01:06:09,450 --> 01:06:12,800
如果我再翻一番它，
应该给我两十亿。

1356
01:06:12,800 --> 01:06:14,980
但事实证明，这是
正确的风口浪尖上。

1357
01:06:14,980 --> 01:06:18,930
>> 所以它实际上溢出
1十亿一个int

1358
01:06:18,930 --> 01:06:23,514
大致2负
十亿，因为一个整数，

1359
01:06:23,514 --> 01:06:25,430
不像我们的数字
上周假设，

1360
01:06:25,430 --> 01:06:28,397
既可以是正和负
在现实中，并在一台计算机。

1361
01:06:28,397 --> 01:06:30,730
而这些，所以至少一个
位被有效被盗。

1362
01:06:30,730 --> 01:06:34,190
所以，我们真的只有31位，
或2十亿可能的值。

1363
01:06:34,190 --> 01:06:38,220
>> 但就目前而言，外卖相当
简单地说，不管这些数字

1364
01:06:38,220 --> 01:06:42,280
而无论数学，
有坏事发生，最终，

1365
01:06:42,280 --> 01:06:46,980
因为最终你试图
重排的位太多次。

1366
01:06:46,980 --> 01:06:51,060
你有效地都去
1对也许所有0，或者

1367
01:06:51,060 --> 01:06:54,260
只是一些其他的模式，它
清楚地，根据上下文，

1368
01:06:54,260 --> 01:06:56,342
可以理解为一个负数。

1369
01:06:56,342 --> 01:06:59,300
因此它似乎最高的I
可以在这个特定的程序计数

1370
01:06:59,300 --> 01:07:01,210
只有大约1十亿。

1371
01:07:01,210 --> 01:07:02,760
但是，这里有一个部分解决方案。

1372
01:07:02,760 --> 01:07:03,480
你知道吗？

1373
01:07:03,480 --> 01:07:07,600
>> 让我从改变
诠释一个很长很长。

1374
01:07:07,600 --> 01:07:10,633
让我继续在这里
和say--我将有

1375
01:07:10,633 --> 01:07:12,290
要改变这种为unsigned long。

1376
01:07:12,290 --> 01:07:16,860
或者，让我们来看看，我从来不记得自己。

1377
01:07:16,860 --> 01:07:19,920
>> 让我们继续前进，使溢出。

1378
01:07:19,920 --> 01:07:21,860
不，这不是它，LLD，谢谢。

1379
01:07:21,860 --> 01:07:23,430
所以有时锵能有所帮助。

1380
01:07:23,430 --> 01:07:27,550
我不记得是什么格式
说明是一个很长很长。

1381
01:07:27,550 --> 01:07:28,950
>> 但是，事实上，锵告诉我的。

1382
01:07:28,950 --> 01:07:31,570
绿色是某种好，
仍然意味着你犯了一个错误。

1383
01:07:31,570 --> 01:07:33,190
它是猜，我的意思是LLD。

1384
01:07:33,190 --> 01:07:38,750
>> 因此，让我把它的建议，长
长十进制数，保存。

1385
01:07:38,750 --> 01:07:43,190
让我重新运行它，点
斜线溢出，回车。

1386
01:07:43,190 --> 01:07:45,020
现在什么是酷是这样的。

1387
01:07:45,020 --> 01:07:49,140
>> 如果我回卷的时候，我们还是开始
在同一place--计数1，2，4，

1388
01:07:49,140 --> 01:07:50,220
8，16。

1389
01:07:50,220 --> 01:07:54,860
请注意，我们得到了所有的
一路攀升至1十亿。

1390
01:07:54,860 --> 01:07:57,070
但是，我们安全到达2十亿。

1391
01:07:57,070 --> 01:08:01,300
>> 然后我们4十亿，
然后从8十亿，17个十亿。

1392
01:08:01,300 --> 01:08:03,340
而我们走的更高，而且
越来越高。

1393
01:08:03,340 --> 01:08:05,740
最终，这也算休息。

1394
01:08:05,740 --> 01:08:09,350
>> 最终，用长长的，
它是64位的值，而不是

1395
01:08:09,350 --> 01:08:13,660
一个32位的值，如果算上
过高，环绕0。

1396
01:08:13,660 --> 01:08:16,410
在这种情况下，我们碰巧
结束了一个负数。

1397
01:08:16,410 --> 01:08:17,550
>> 因此，这是一个问题。

1398
01:08:17,550 --> 01:08:20,439
而事实证明，这
问题是，不是所有的神秘。

1399
01:08:20,439 --> 01:08:23,060
即使我刻意
这些错误引起的，

1400
01:08:23,060 --> 01:08:26,149
事实证明，我们那种看到它的全部
我们，或者至少我们中的一些周围的人。

1401
01:08:26,149 --> 01:08:28,939
>> 因此，在乐高星球大战，如果
你曾经玩过的游戏，

1402
01:08:28,939 --> 01:08:33,830
事实证明，你可以去周围
打破东西在世界乐高，

1403
01:08:33,830 --> 01:08:36,640
和收集硬币，本质上。

1404
01:08:36,640 --> 01:08:39,200
如果你打过
这个游戏了太多的时间，

1405
01:08:39,200 --> 01:08:42,630
因为这无名的个人
在这里做到了，总数

1406
01:08:42,630 --> 01:08:46,700
你可以收集硬币
是，它似乎，4个十亿。

1407
01:08:46,700 --> 01:08:48,240
>> 现在，它的实际四舍五入。

1408
01:08:48,240 --> 01:08:50,239
所以LEGO试图
让事情变得人性化。

1409
01:08:50,239 --> 01:08:53,779
他们没有做到这一点正是2
32次幂，每上周。

1410
01:08:53,779 --> 01:08:55,310
但4个十亿是一个道理。

1411
01:08:55,310 --> 01:08:58,979
看来，基于该信息，
这LEGO，该公司的

1412
01:08:58,979 --> 01:09:02,624
使这个实际的软件，决定
该硬币的最大数目

1413
01:09:02,624 --> 01:09:04,540
用户可以积累
确实是，4个十亿，

1414
01:09:04,540 --> 01:09:12,069
因为他们选择在自己的代码
使用不是很长很长，很显然，

1415
01:09:12,069 --> 01:09:16,140
但仅仅是一个整数，一个无符号
整数，只有一个正整数，其

1416
01:09:16,140 --> 01:09:18,089
最大值大约是这一点。

1417
01:09:18,089 --> 01:09:19,380
那么，这里的另一个有趣的。

1418
01:09:19,380 --> 01:09:23,500
所以在游戏中文明，这
有些人可能很熟悉，与

1419
01:09:23,500 --> 01:09:26,660
原来，几年前有
在本场比赛由此错误

1420
01:09:26,660 --> 01:09:28,750
如果你所扮演的角色
甘地在比赛中，

1421
01:09:28,750 --> 01:09:34,020
代替他的是非常和平，
反而是令人难以置信的，令人难以置信

1422
01:09:34,020 --> 01:09:36,399
攻击性，在某些情况下。

1423
01:09:36,399 --> 01:09:40,529
特别是，方式文明
作品是，如果您的播放器，

1424
01:09:40,529 --> 01:09:44,680
采取民主，你
侵略性成绩获得

1425
01:09:44,680 --> 01:09:48,130
由两个，所以减去递减
减，再减去负。

1426
01:09:48,130 --> 01:09:50,569
>> 所以你减去2从
实际的迭代。

1427
01:09:50,569 --> 01:09:56,650
不幸的是，如果你的是迭代
最初1，你从中减去2

1428
01:09:56,650 --> 01:09:59,050
采用经过民主
甘地在这里可能

1429
01:09:59,050 --> 01:10:02,200
这样做，是因为他很passive--
1对侵略性的规模。

1430
01:10:02,200 --> 01:10:04,830
但是，如果他采取民主，那么
他去从1到1负。

1431
01:10:04,830 --> 01:10:11,470
>> 不幸的是，它们是
使用无符号数，

1432
01:10:11,470 --> 01:10:15,400
这意味着他们对待甚至是负
数字，好像他们是积极的。

1433
01:10:15,400 --> 01:10:19,780
而且事实证明，
负1阳性当量，

1434
01:10:19,780 --> 01:10:23,480
在典型的计算机程序，为255。

1435
01:10:23,480 --> 01:10:27,250
因此，如果采用甘地
，因此具有民主

1436
01:10:27,250 --> 01:10:32,470
他的侵略性评分下降，
它实际上来临时，以255

1437
01:10:32,470 --> 01:10:35,470
而让他最
侵略性的比赛。

1438
01:10:35,470 --> 01:10:36,930
所以，你可以在此Google了。

1439
01:10:36,930 --> 01:10:39,380
而且，的确是一个
意外编程错误，

1440
01:10:39,380 --> 01:10:43,010
但是这相当进入
绝杀至今。

1441
01:10:43,010 --> 01:10:44,360
>> 这是所有的乐趣和可爱。

1442
01:10:44,360 --> 01:10:47,760
更可怕的是，当实际
真实世界的设备，而不是游戏，

1443
01:10:47,760 --> 01:10:48,820
有这些相同的错误。

1444
01:10:48,820 --> 01:10:54,500
事实上，就在一年前的一篇文章来了
更多关于波音787梦想飞机。

1445
01:10:54,500 --> 01:10:56,850
>> 和制品在第一
读取一目了然有点神秘。

1446
01:10:56,850 --> 01:11:01,480
但它说，这是一家软件
在波音公司的脆弱性

1447
01:11:01,480 --> 01:11:04,790
新型787梦想飞机具有
可能造成飞行员

1448
01:11:04,790 --> 01:11:07,220
失去控制
飞机，可能

1449
01:11:07,220 --> 01:11:11,750
在飞行中，美国联邦航空局官员
告诫航空公司最近。

1450
01:11:11,750 --> 01:11:14,520
这是确定
一个模型787

1451
01:11:14,520 --> 01:11:19,770
已通电飞机
连续248天

1452
01:11:19,770 --> 01:11:24,880
可能会失去所有的交流电流，交流，
电功率，由于发电机

1453
01:11:24,880 --> 01:11:28,892
控制单元，同时GCUs，
进入故障安全模式。

1454
01:11:28,892 --> 01:11:29,850
这是一种失去我的。

1455
01:11:29,850 --> 01:11:35,390
但备忘录说，好了，现在我得到的，
条件是由软件引起的

1456
01:11:35,390 --> 01:11:38,590
专柜内部
发电机控制

1457
01:11:38,590 --> 01:11:44,860
单元后，将溢出
248天连续功率。

1458
01:11:44,860 --> 01:11:47,070
颁发本
注意防止损失

1459
01:11:47,070 --> 01:11:49,300
所有交流电
功率，这可能导致

1460
01:11:49,300 --> 01:11:50,980
在飞机的失控。

1461
01:11:50,980 --> 01:11:55,380
>> 所以，从字面上看，有一些整数，
或者一些等价的数据类型，

1462
01:11:55,380 --> 01:11:57,960
在软件被使用
在实际的飞机

1463
01:11:57,960 --> 01:12:00,756
如果你保持你的飞机
足够长的时间，这显然

1464
01:12:00,756 --> 01:12:03,880
可如果你只是运行情况
他们不断地从不拔下

1465
01:12:03,880 --> 01:12:06,810
你的飞机，现在看来，还是
让其电池不行了，

1466
01:12:06,810 --> 01:12:09,840
将最终计数和向上，
和起来，向上，及以上，和向上。

1467
01:12:09,840 --> 01:12:12,150
>> 并且，按质，一
内存数量有限

1468
01:12:12,150 --> 01:12:15,880
会溢出，回滚到
零或者一些负值，

1469
01:12:15,880 --> 01:12:19,920
其中的一个副作用是
实得吓人现实

1470
01:12:19,920 --> 01:12:23,970
这架飞机可能需要
必须重新启动，有效，

1471
01:12:23,970 --> 01:12:27,290
也可能下降，更糟糕的，因为它飞起来。

1472
01:12:27,290 --> 01:12:29,230
所以这类问题
仍然伴随着我们，

1473
01:12:29,230 --> 01:12:33,130
even--这是一个2015年的文章，
所有的更可怕

1474
01:12:33,130 --> 01:12:36,100
当你不一定
理解，欣赏，或预期

1475
01:12:36,100 --> 01:12:38,640
这些类型的错误。

1476
01:12:38,640 --> 01:12:42,030
>> 因此，原来还有另一个
有关数据表示坏事。

1477
01:12:42,030 --> 01:12:47,080
事实证明，即使花车
样的缺陷，因为花车也是如此，

1478
01:12:47,080 --> 01:12:51,440
我提出的是32位的，或
也许64如果你使用双。

1479
01:12:51,440 --> 01:12:53,070
但是，这仍然是有限的。

1480
01:12:53,070 --> 01:12:57,070
>> 而美中不足的是，如果你能
把数的无限数量

1481
01:12:57,070 --> 01:12:59,460
小数点后，
没有办法，你

1482
01:12:59,460 --> 01:13:02,690
可以代表所有可能的
我们被教导号码

1483
01:13:02,690 --> 01:13:04,990
在小学可以在世界上存在。

1484
01:13:04,990 --> 01:13:08,870
一台电脑，从本质上讲，有
选择这些数字的一个子集

1485
01:13:08,870 --> 01:13:10,200
准确地表示。

1486
01:13:10,200 --> 01:13:12,450
>> 现在，该计算机可以
轮也许一点点，

1487
01:13:12,450 --> 01:13:17,900
并且可以让你大致店
任何号码，你有可能会需要。

1488
01:13:17,900 --> 01:13:20,940
但是，仅仅凭直觉，如果你
有比特的有限数目，

1489
01:13:20,940 --> 01:13:24,560
你只能他们重排
在很多方面有限。

1490
01:13:24,560 --> 01:13:26,570
所以，你不可能
用有限数量的

1491
01:13:26,570 --> 01:13:29,880
比特置换，
零和一的模式，

1492
01:13:29,880 --> 01:13:32,940
代表无限
号的数目，

1493
01:13:32,940 --> 01:13:37,370
这表明计算机可能
很好是对我们撒谎的时候。

1494
01:13:37,370 --> 01:13:38,770
>> 事实上，让我们做到这一点。

1495
01:13:38,770 --> 01:13:41,239
让我重新回到CS50 IDE。

1496
01:13:41,239 --> 01:13:43,030
让我继续前进，
创建一个小程序

1497
01:13:43,030 --> 01:13:47,940
叫不精确，就表明
电脑的确都是不精确的。

1498
01:13:47,940 --> 01:13:51,910
>> 让我继续前进，并与开始
一些代码来自之前，

1499
01:13:51,910 --> 01:13:53,830
现在只要做到以下几点。

1500
01:13:53,830 --> 01:14:03,640
我要继续做的printf，百分比
楼反斜线N，1除以10。

1501
01:14:03,640 --> 01:14:07,430
换句话说，让我们在更深的下潜
到1/10，象1和除以10。

1502
01:14:07,430 --> 01:14:09,760
当然，一个计算机可以代表1/10。

1503
01:14:09,760 --> 01:14:13,620
>> 因此，让我们继续前进，使不精确。

1504
01:14:13,620 --> 01:14:14,390
让我们来看看。

1505
01:14:14,390 --> 01:14:16,210
格式指定double类型。

1506
01:14:16,210 --> 01:14:18,160
但参数的类型为int。

1507
01:14:18,160 --> 01:14:19,040
这是怎么回事？

1508
01:14:19,040 --> 01:14:21,970
>> 呵呵，有意思，所以这是一个
从课前的教训。

1509
01:14:21,970 --> 01:14:26,050
我说，哎，电脑展
我百分之F A浮动。

1510
01:14:26,050 --> 01:14:28,200
但我给它2个整数。

1511
01:14:28,200 --> 01:14:31,120
所以，事实证明，我可以修复
这几种方式。

1512
01:14:31,120 --> 01:14:38,430
>> 我只是把一成1.0，和
10到10.0，这，的确，

1513
01:14:38,430 --> 01:14:42,390
有转换的效果
他们进入floats--仍有望

1514
01:14:42,390 --> 01:14:43,180
相同的号码。

1515
01:14:43,180 --> 01:14:45,880
或者，它原来有什么东西
我们不久再见到。

1516
01:14:45,880 --> 01:14:47,170
你可以投中的数字。

1517
01:14:47,170 --> 01:14:49,880
>> 您可以使用此括号
表达式，你可以说，

1518
01:14:49,880 --> 01:14:52,560
哎，电脑，借此
10，我知道是一个int。

1519
01:14:52,560 --> 01:14:54,660
但是对待它，请
就好像它是一个浮动。

1520
01:14:54,660 --> 01:14:56,680
但这种感觉过于复杂。

1521
01:14:56,680 --> 01:14:59,040
>> 对于我们今天的目的，
我们只是从字面上

1522
01:14:59,040 --> 01:15:02,700
让他们浮点值
带小数点，就像这样。

1523
01:15:02,700 --> 01:15:07,060
让我继续前进并重新运行，使
不精确，好，点斜线

1524
01:15:07,060 --> 01:15:08,870
不精确，进入。

1525
01:15:08,870 --> 01:15:10,990
OK，我们正在寻找好的。

1526
01:15:10,990 --> 01:15:18,194
>> 1除以10，按照我的
苹果在这里，的确是0.100000。

1527
01:15:18,194 --> 01:15:21,360
现在，我学会了上小学的时候有
应该是0的无限数量。

1528
01:15:21,360 --> 01:15:23,151
因此，让我们至少尝试
看到其中的一些。

1529
01:15:23,151 --> 01:15:26,770
事实证明，printf的是一个小
票友仍然比我们一直在使用。

1530
01:15:26,770 --> 01:15:30,890
原来你没有指定
刚刚％的F或只是我百分比。

1531
01:15:30,890 --> 01:15:33,830
实际上，你可以指定
这里的一些控制选项。

1532
01:15:33,830 --> 01:15:36,470
>> 具体来说，我要去
就是说，哎，printf的，

1533
01:15:36,470 --> 01:15:39,660
居然告诉我10小数点。

1534
01:15:39,660 --> 01:15:40,820
所以它看起来有点怪异。

1535
01:15:40,820 --> 01:15:42,845
但是你说个百分点，
点，多少号

1536
01:15:42,845 --> 01:15:44,970
你想以后看到
小数点，以及则f

1537
01:15:44,970 --> 01:15:48,340
平，只是因为这是
文件说什么。

1538
01:15:48,340 --> 01:15:50,080
让我继续前进并保存。

1539
01:15:50,080 --> 01:15:52,460
>> 并注意过，我越来越
厌倦了重复输入的事情。

1540
01:15:52,460 --> 01:15:55,900
所以我只是设置和
在这里我的钥匙向下箭头。

1541
01:15:55,900 --> 01:15:58,710
如果我继续打了，你
可以看到所有的命令

1542
01:15:58,710 --> 01:16:01,090
我犯了，或不正确的。

1543
01:16:01,090 --> 01:16:04,630
>> 而我现在要继续前进，
没有实际使用，显然。

1544
01:16:04,630 --> 01:16:11,416
让不精确，点
斜线imprecision--所以

1545
01:16:11,416 --> 01:16:13,290
我所教
小学检查出来。

1546
01:16:13,290 --> 01:16:19,010
即使我把它打印到10进制
地方，它确实是0.10000。

1547
01:16:19,010 --> 01:16:19,840
但是，你知道吗？

1548
01:16:19,840 --> 01:16:21,150
>> 让我们有点贪心。

1549
01:16:21,150 --> 01:16:23,990
比方说，比如，告诉我55
小数点后点。

1550
01:16:23,990 --> 01:16:26,160
让我们真的采取这种
划出来兜风。

1551
01:16:26,160 --> 01:16:31,170
让我用make改造它
不精确，点斜线，不精确。

1552
01:16:31,170 --> 01:16:32,390
>> 现在我们开始。

1553
01:16:32,390 --> 01:16:34,420
你的童年是一个谎言。

1554
01:16:34,420 --> 01:16:48,410
很显然，1除以10的确
0.100000000000000005551115123--

1555
01:16:48,410 --> 01:16:49,740
>> 到底是怎么回事？

1556
01:16:49,740 --> 01:16:53,360
那么，事实证明，如果你种
看远远不够出在底层

1557
01:16:53,360 --> 01:16:55,950
这表示
数目，它实际上

1558
01:16:55,950 --> 01:17:00,400
是不完全的1/10，或0.1和
无限数量的零。

1559
01:17:00,400 --> 01:17:01,630
现在，这是为什么？

1560
01:17:01,630 --> 01:17:06,250
>> 那么，即使这是一个简单的
我们人类数，1除以10，

1561
01:17:06,250 --> 01:17:10,910
它仍然是无限多的一个
数字，我们能想到的。

1562
01:17:10,910 --> 01:17:14,490
但是，一台电脑只能代表
有限多个这样的数字。

1563
01:17:14,490 --> 01:17:18,710
所以，有效的，是什么
电脑正显示出我们的是其最接近

1564
01:17:18,710 --> 01:17:22,940
近似​​与数
我们愿意相信是1/10，

1565
01:17:22,940 --> 01:17:27,760
还是真的0.10000循环往复。

1566
01:17:27,760 --> 01:17:30,425
>> 而，虽然，这是
尽可能接近，因为它可以得到的。

1567
01:17:30,425 --> 01:17:32,300
而且，事实上，如果你看看
引擎盖下，

1568
01:17:32,300 --> 01:17:37,050
因为我们在这里通过看
小数点后55位，

1569
01:17:37,050 --> 01:17:39,990
实际上我们看到的现实。

1570
01:17:39,990 --> 01:17:42,610
现在，顺便说一句，如果你
见过movie--

1571
01:17:42,610 --> 01:17:45,780
大多数人可能haven't--
但超人3若干年前，

1572
01:17:45,780 --> 01:17:49,500
理查德·普赖尔基本上是利用这
现实中，他的公司窃取了很多

1573
01:17:49,500 --> 01:17:53,500
便士的分数和分数的，
因为我记得在company--，

1574
01:17:53,500 --> 01:17:57,210
它是一个while--基本上是
扔掉任何东西，不适合

1575
01:17:57,210 --> 01:17:58,790
进入仙的概念。

1576
01:17:58,790 --> 01:18:01,480
>> 但是，如果你把所有这些
很小，很小，很小的数字再次，

1577
01:18:01,480 --> 01:18:04,960
又一次，又一次，你可以象在
他的情况下，赚钱的一个良好的数额。

1578
01:18:04,960 --> 01:18:08,010
>> 那同样的想法被扯掉
更近，但还是现在年纪大了

1579
01:18:08,010 --> 01:18:10,500
电影，叫办公空间，
凡在那部电影的家伙，

1580
01:18:10,500 --> 01:18:13,501
做同样的事情，搞砸了
彻底，结束了太多

1581
01:18:13,501 --> 01:18:14,666
钱在自己的银行账户。

1582
01:18:14,666 --> 01:18:15,800
这一切都是很可疑。

1583
01:18:15,800 --> 01:18:19,290
但在一天结束时，
不精确就在我们身边。

1584
01:18:19,290 --> 01:18:22,240
>> 并且，也可以是
令人震惊的情况。

1585
01:18:22,240 --> 01:18:25,590
原来，3超人
和办公空间之外，还有

1586
01:18:25,590 --> 01:18:28,460
可能有一些非常现实的
世界后果

1587
01:18:28,460 --> 01:18:32,290
不精确的现实
数据的表示

1588
01:18:32,290 --> 01:18:34,770
即使我们人类
这一天不一定

1589
01:18:34,770 --> 01:18:38,230
理解，以及我们应该，
或记住尽可能多我们应该。

1590
01:18:38,230 --> 01:18:42,950
而且，事实上，以下剪辑是
从看一些很真实的世界

1591
01:18:42,950 --> 01:18:47,730
如果你会发生什么后果
不欣赏的不精确性

1592
01:18:47,730 --> 01:18:50,065
在数字代表出现。

1593
01:18:50,065 --> 01:18:51,300
>> [视频回放]

1594
01:18:51,300 --> 01:18:55,620
>> -Computers，我们都逐渐接受
经常令人沮丧的问题，

1595
01:18:55,620 --> 01:19:00,310
去them--错误，病毒，
和软件故障，

1596
01:19:00,310 --> 01:19:03,130
对于小的价格支付
为方便。

1597
01:19:03,130 --> 01:19:07,800
但是，在高科技和高速度
军事和航天计划的应用，

1598
01:19:07,800 --> 01:19:12,800
最小的问题即可
被放大成灾难。

1599
01:19:12,800 --> 01:19:18,900
>> 在1996年6月4日，科学家们准备
发射无人阿丽亚娜5型火箭。

1600
01:19:18,900 --> 01:19:21,220
它携带的科学
卫星设计

1601
01:19:21,220 --> 01:19:24,600
建立精确如何
地球的磁场相互作用

1602
01:19:24,600 --> 01:19:27,410
与太阳风。

1603
01:19:27,410 --> 01:19:30,800
火箭是专为
欧洲航天局，

1604
01:19:30,800 --> 01:19:34,370
并从其设施升空
在法属圭亚那的海岸。

1605
01:19:34,370 --> 01:19:37,540
>> -At约37秒进
飞行中，他们首先

1606
01:19:37,540 --> 01:19:39,270
注意到某些事正在错误的。

1607
01:19:39,270 --> 01:19:42,250
喷嘴在被旋转
某种意义上说，他们实在不应该。

1608
01:19:42,250 --> 01:19:46,580
大约40秒后进入飞行，
显然，车辆遇到了麻烦。

1609
01:19:46,580 --> 01:19:48,850
>> 那就是当他们做了
决定摧毁它。

1610
01:19:48,850 --> 01:19:52,780
该范围内的安全官员，与
巨大的胆量，按下按钮，

1611
01:19:52,780 --> 01:19:58,150
炸毁了火箭，它可能前
成为对公众安全造成危害。

1612
01:19:58,150 --> 01:20:01,060
>>  - 这是处女
阿丽亚娜5的航程。

1613
01:20:01,060 --> 01:20:03,960
而其毁灭了
地方，因为一个缺陷

1614
01:20:03,960 --> 01:20:05,822
嵌入火箭的软件。

1615
01:20:05,822 --> 01:20:08,280
在阿丽亚​​娜-The问题是
认为有许多

1616
01:20:08,280 --> 01:20:10,600
需要64位来表示。

1617
01:20:10,600 --> 01:20:13,590
他们想转换
它的16位数字。

1618
01:20:13,590 --> 01:20:15,610
他们假定
数字是永远不会

1619
01:20:15,610 --> 01:20:20,980
是非常大的，大多数的那些
在一个64位的号码数字是零。

1620
01:20:20,980 --> 01:20:22,440
但他们错了。

1621
01:20:22,440 --> 01:20:25,060
>> -The无力之一
软件程序接受

1622
01:20:25,060 --> 01:20:29,510
所产生的那种数
另一种是在失败的根源。

1623
01:20:29,510 --> 01:20:34,350
软件开发已经成为一个
的新技术非常昂贵的部分。

1624
01:20:34,350 --> 01:20:38,140
该阿丽亚娜火箭已经很
成功，那么多的软件

1625
01:20:38,140 --> 01:20:41,550
创造了它也是
在阿丽亚​​娜5中。

1626
01:20:41,550 --> 01:20:47,940
>> -The根本的问题是，阿丽亚娜
5增快，加速快。

1627
01:20:47,940 --> 01:20:51,450
而且软件早已不是
占了点。

1628
01:20:51,450 --> 01:20:55,060
>> 火箭-The破坏
是一个巨大的金融灾难，

1629
01:20:55,060 --> 01:20:58,790
一切缘于一分钟，软件错误。

1630
01:20:58,790 --> 01:21:01,210
但是，这不是第一次
实时数据转换问题

1631
01:21:01,210 --> 01:21:04,820
一直困扰现代火箭技术。

1632
01:21:04,820 --> 01:21:08,050
>> -in 1991年，开始时
第一次海湾战争中，

1633
01:21:08,050 --> 01:21:10,570
爱国者导弹
经历了类似的一种

1634
01:21:10,570 --> 01:21:12,800
数转换的问题。

1635
01:21:12,800 --> 01:21:16,090
而作为一个结果，28人，
28名美国士兵，

1636
01:21:16,090 --> 01:21:19,080
被打死，约
100人受伤，

1637
01:21:19,080 --> 01:21:22,780
当爱国者，这本来是
防止传入的飞毛腿导弹，

1638
01:21:22,780 --> 01:21:25,830
没有发射导弹。

1639
01:21:25,830 --> 01:21:31,670
>>  - 当伊拉克入侵科威特和美国
在1991年年初推出沙漠风暴

1640
01:21:31,670 --> 01:21:35,780
爱国者导弹部署
保护沙特阿拉伯和以色列

1641
01:21:35,780 --> 01:21:39,230
伊拉克飞毛腿导弹袭击。

1642
01:21:39,230 --> 01:21:43,810
爱国者是美国中程
表面空气系统，制造

1643
01:21:43,810 --> 01:21:45,770
由雷神公司。

1644
01:21:45,770 --> 01:21:52,340
>> 爱国者拦截-The大小
本身是关于约20英尺长。

1645
01:21:52,340 --> 01:21:55,230
它重约2000磅。

1646
01:21:55,230 --> 01:21:59,320
同时还可以进行约一个弹头，
我认为这是大约150磅。

1647
01:21:59,320 --> 01:22:03,930
和弹头本身
高爆发力，这

1648
01:22:03,930 --> 01:22:07,330
周围有碎片。

1649
01:22:07,330 --> 01:22:11,680
弹头的外壳是
旨在像大号铅弹。

1650
01:22:11,680 --> 01:22:14,110
>> -The导弹进行
百分之四的容器中，

1651
01:22:14,110 --> 01:22:17,130
和由半拖车运输。

1652
01:22:17,130 --> 01:22:24,930
>> -The爱国者反导弹系统
追溯到现在至少有20年。

1653
01:22:24,930 --> 01:22:28,420
它最初的设计
作为防空导弹

1654
01:22:28,420 --> 01:22:30,720
击落敌人的飞机。

1655
01:22:30,720 --> 01:22:34,500
在第一次海湾战争，
当战争来了，

1656
01:22:34,500 --> 01:22:39,745
陆军想用它来
击落飞毛腿导弹，而不是飞机。

1657
01:22:39,745 --> 01:22:43,620
>> 伊拉克空军
没有那么多的问题。

1658
01:22:43,620 --> 01:22:46,670
但军队是担心飞毛腿导弹。

1659
01:22:46,670 --> 01:22:50,170
所以他们试图
升级爱国者。

1660
01:22:50,170 --> 01:22:52,800
>> -Intercepting敌人
在导弹5马赫旅行

1661
01:22:52,800 --> 01:22:55,830
将要被足够的挑战性。

1662
01:22:55,830 --> 01:22:58,490
但是，当爱国者
被送往投入服务，

1663
01:22:58,490 --> 01:23:02,860
陆军不知道的
伊拉克的修改，使得

1664
01:23:02,860 --> 01:23:05,930
他们的飞毛腿导弹几乎是不可能的打击。

1665
01:23:05,930 --> 01:23:10,740
>>  - 什么事是飞毛腿导弹的
要来的是不稳定的。

1666
01:23:10,740 --> 01:23:11,692
他们在晃动。

1667
01:23:11,692 --> 01:23:14,910
这样做的原因是
伊拉克人，为了

1668
01:23:14,910 --> 01:23:18,280
获得600公里
出300公里

1669
01:23:18,280 --> 01:23:21,700
中程导弹，重了
从前面弹头。

1670
01:23:21,700 --> 01:23:23,390
他们提出的弹头更轻。

1671
01:23:23,390 --> 01:23:27,330
>> 所以，现在的爱国者
苦思的飞毛腿。

1672
01:23:27,330 --> 01:23:30,230
和大部分的时间，该
绝大多数的时间，

1673
01:23:30,230 --> 01:23:32,940
它只是由飞毛腿飞。

1674
01:23:32,940 --> 01:23:37,260
一旦爱国者系统运营商
实现了爱国者错过了目标，

1675
01:23:37,260 --> 01:23:41,690
他们引爆爱国者的弹头
以避免如果可能的人员伤亡

1676
01:23:41,690 --> 01:23:44,570
被允许倒在地上。

1677
01:23:44,570 --> 01:23:48,790
>>  - 那是大多数人所看到的，
在天空中那些大火球，

1678
01:23:48,790 --> 01:23:54,550
和误解成
飞毛腿弹头的拦截。

1679
01:23:54,550 --> 01:23:56,630
>>  - 虽然在夜间
天空，出现了爱国者

1680
01:23:56,630 --> 01:24:00,370
要成功地
摧毁飞毛腿导弹，在宰赫兰

1681
01:24:00,370 --> 01:24:03,360
有可能是没有错
关于它的性能。

1682
01:24:03,360 --> 01:24:07,970
目前，爱国者的雷达系统
失去了进入的飞毛腿的轨道，

1683
01:24:07,970 --> 01:24:10,721
从不因推出
到一个软件缺陷。

1684
01:24:10,721 --> 01:24:14,090

1685
01:24:14,090 --> 01:24:18,940
这是谁首先发现了以色列人
的时间越长该系统上，

1686
01:24:18,940 --> 01:24:22,690
越大时间差异
成为，由于嵌入的时钟

1687
01:24:22,690 --> 01:24:24,810
在系统的计算机。

1688
01:24:24,810 --> 01:24:28,210
>>  - 关于前两周
悲剧发生在宰赫兰

1689
01:24:28,210 --> 01:24:30,770
以色列人报
国防部

1690
01:24:30,770 --> 01:24:32,590
该系统正在失去的时间。

1691
01:24:32,590 --> 01:24:35,360
约8小时运行之后，
他们注意到，该系统

1692
01:24:35,360 --> 01:24:37,720
变得明显不准确。

1693
01:24:37,720 --> 01:24:41,900
国防部回应
告诉所有的爱国者电池

1694
01:24:41,900 --> 01:24:44,950
不离开系统
上很长一段时间。

1695
01:24:44,950 --> 01:24:49,160
他们从来不说什么了很久was--
八小时，10小时，千小时。

1696
01:24:49,160 --> 01:24:51,360
没有人知道。

1697
01:24:51,360 --> 01:24:53,380
>> -The爱国者电池
驻扎在军营

1698
01:24:53,380 --> 01:24:58,350
在宰赫兰和内部缺陷
时钟已经超过100小时一直在

1699
01:24:58,350 --> 01:25:01,670
2月25日的夜晚。

1700
01:25:01,670 --> 01:25:05,917
>>  - 它跟踪的时间精度
约一秒钟的十分之一。

1701
01:25:05,917 --> 01:25:08,000
现在，第二的第十
是一个有趣的数字，

1702
01:25:08,000 --> 01:25:11,920
因为它不能表示
二进制准确地说，这

1703
01:25:11,920 --> 01:25:16,820
意味着它不能精确地表达
在任何现代数字计算机。

1704
01:25:16,820 --> 01:25:18,540
很难相信。

1705
01:25:18,540 --> 01:25:21,210
>> 但是使用此作为一个例子。

1706
01:25:21,210 --> 01:25:23,540
让我们来数三分之一。

1707
01:25:23,540 --> 01:25:27,350
三分之一不能
十进制明确地表达。

1708
01:25:27,350 --> 01:25:32,080
三分之一是0.333
持续了无穷大。

1709
01:25:32,080 --> 01:25:36,480
>> 有没有办法做到这一点与
绝对精度十进制。

1710
01:25:36,480 --> 01:25:39,560
这正是那种问题
这发生在爱国者。

1711
01:25:39,560 --> 01:25:44,100
时间越长，系统运行时，
更糟糕的时间误差成了。

1712
01:25:44,100 --> 01:25:48,890
>>  - 后运行100小时后，
在时间误差仅为约三分之一

1713
01:25:48,890 --> 01:25:50,600
的第二。

1714
01:25:50,600 --> 01:25:54,210
但是，在一个目标的角度
导弹在5马赫旅行，

1715
01:25:54,210 --> 01:25:58,710
它导致了跟踪
超过600米错误。

1716
01:25:58,710 --> 01:26:02,120
这将是一个致命的错误
对于什么战士

1717
01:26:02,120 --> 01:26:08,940
碰巧是飞毛腿发射是
通过预警卫星检测

1718
01:26:08,940 --> 01:26:12,860
他们知道，是飞毛腿
未来在他们的大方向。

1719
01:26:12,860 --> 01:26:15,320
他们不知道有人来了。

1720
01:26:15,320 --> 01:26:18,250
>>  - 它现在要由雷达
爱国者系统的组成部分

1721
01:26:18,250 --> 01:26:23,190
卫冕达兰定位和保持
跟踪来袭的敌方导弹。

1722
01:26:23,190 --> 01:26:24,609
>> -The雷达是非常聪明的。

1723
01:26:24,609 --> 01:26:26,650
它实际上是将跟踪
飞毛腿的位置，

1724
01:26:26,650 --> 01:26:30,350
然后预测出可能
将是下一个时间的雷达发送

1725
01:26:30,350 --> 01:26:31,420
脉冲出来。

1726
01:26:31,420 --> 01:26:33,110
这是所谓的范围内门。

1727
01:26:33,110 --> 01:26:37,660
>>  - 然后，一旦爱国者
决定时间已够

1728
01:26:37,660 --> 01:26:42,450
传递回去检查下
此检测物体的位置，

1729
01:26:42,450 --> 01:26:43,600
它可以追溯到。

1730
01:26:43,600 --> 01:26:48,650
因此，当它回到了错
地方，然后看见没有对象。

1731
01:26:48,650 --> 01:26:52,160
和它决定，没有
对象，这是一个错误的检测，

1732
01:26:52,160 --> 01:26:53,930
和下降的轨道。

1733
01:26:53,930 --> 01:26:57,030
>> -The传入飞毛腿消失
从雷达屏幕上。

1734
01:26:57,030 --> 01:27:00,260
几秒钟后，它
撞上军营。

1735
01:27:00,260 --> 01:27:06,150
飞毛腿打死28，并且是最后一个
在第一次海湾战争中开火。

1736
01:27:06,150 --> 01:27:11,960
>> 可悲的是，更新的软件
抵达宰赫兰的第二天。

1737
01:27:11,960 --> 01:27:14,930
该软件有缺陷
得到修复，闭合

1738
01:27:14,930 --> 01:27:19,806
在陷入困境的一章
爱国者导弹的历史。

1739
01:27:19,806 --> 01:27:20,729
>> [视频回放]

1740
01:27:20,729 --> 01:27:23,520
DAVID J. MALAN：所以这是所有
说，溢出的这些问题

1741
01:27:23,520 --> 01:27:25,860
和不精确都太真实了。

1742
01:27:25,860 --> 01:27:26,920
那么我们是如何来到这里的？

1743
01:27:26,920 --> 01:27:28,895
我们开始只是谈论的printf。

1744
01:27:28,895 --> 01:27:31,270
再次，此函数
打印一些东西到屏幕上，

1745
01:27:31,270 --> 01:27:33,450
我们随后推出
几个其他功能

1746
01:27:33,450 --> 01:27:34,945
从所谓CS50的库。

1747
01:27:34,945 --> 01:27:36,910
我们将继续
看到这些在适当的时候。

1748
01:27:36,910 --> 01:27:40,760
而我们，尤其是使用的GET字符串，
并获得INT，现在还可以获得浮动，

1749
01:27:40,760 --> 01:27:44,410
还有一些仍然会遇到我们
不久使用自己。

1750
01:27:44,410 --> 01:27:47,220
>> 但有时，有
我们已经看到有必要

1751
01:27:47,220 --> 01:27:50,520
存储什么这些功能的手背？

1752
01:27:50,520 --> 01:27:52,920
他们一方面我们回到一个字符串，
或int或浮动。

1753
01:27:52,920 --> 01:27:56,070
有时，我们需要把该
字符串或int，或float地方。

1754
01:27:56,070 --> 01:28:00,100
>> 并存储那些东西，只是召回
就像在刮，我们有变数。

1755
01:28:00,100 --> 01:28:03,260
但与划痕，
在C中有实际的类型

1756
01:28:03,260 --> 01:28:05,530
variables--数据
类型，更generally--

1757
01:28:05,530 --> 01:28:08,640
其中，一个字符串，一个int，一个
浮动，而这些人依然。

1758
01:28:08,640 --> 01:28:12,321
>> 所以，当我们用C声明变量，
我们必须声明的数据类型。

1759
01:28:12,321 --> 01:28:14,820
这不是我们
必须在学期过去了做

1760
01:28:14,820 --> 01:28:16,810
因为我们过渡到其他语言。

1761
01:28:16,810 --> 01:28:19,610
但现在，我们确实需要
到预先先验，

1762
01:28:19,610 --> 01:28:24,370
解释计算机是什么类型
可变的，我们希望它给我们。

1763
01:28:24,370 --> 01:28:27,290
>> 现在，同时，进行打印
这些类型的数据类型，

1764
01:28:27,290 --> 01:28:29,570
我们要告诉printf的什么期望。

1765
01:28:29,570 --> 01:28:32,450
我们看到字符串％的S，
和我百分之整数，

1766
01:28:32,450 --> 01:28:33,790
和其他几个人了。

1767
01:28:33,790 --> 01:28:37,237
而这些仅仅是要求
对于视觉呈现

1768
01:28:37,237 --> 01:28:38,070
这些信息。

1769
01:28:38,070 --> 01:28:42,080
>> 而且每个这些其实是可以
参数化或以某种方式调整，

1770
01:28:42,080 --> 01:28:45,370
如果你想进一步控制
你得到的输出类型。

1771
01:28:45,370 --> 01:28:49,604
而且，事实上，它不仅证明
有反斜杠n，则新行。

1772
01:28:49,604 --> 01:28:52,520
还有别的东西叫反斜线
r代表回车，这

1773
01:28:52,520 --> 01:28:54,360
更类似于一个
老同学打字机，

1774
01:28:54,360 --> 01:28:57,690
并且还视窗使用多年。

1775
01:28:57,690 --> 01:28:59,690
>> 有制表符反斜杠吨。

1776
01:28:59,690 --> 01:29:03,170
事实证明，如果你想
字符串里面的双引号，

1777
01:29:03,170 --> 01:29:05,000
我们已经使用召回
双引号双

1778
01:29:05,000 --> 01:29:07,900
引用在左侧和右
迄今为止，我们的字符串结束。

1779
01:29:07,900 --> 01:29:09,420
这似乎混淆的东西。

1780
01:29:09,420 --> 01:29:12,503
>> 如果你想要把双引号中
一个string--，实际上中间，

1781
01:29:12,503 --> 01:29:13,670
它是混乱看到的。

1782
01:29:13,670 --> 01:29:17,120
所以你要逃跑，所以
说话，用的东西一个双引号

1783
01:29:17,120 --> 01:29:18,860
像，从字面上看，反斜杠双引号。

1784
01:29:18,860 --> 01:29:20,230
而且还有一些其他的还在。

1785
01:29:20,230 --> 01:29:24,540
我们将看到更多的这些
在不久的实际使用。

1786
01:29:24,540 --> 01:29:27,930
>> 现在让我们从过渡
数据和代表性，

1787
01:29:27,930 --> 01:29:30,820
和算术运算符，所有
这给了我们一些建筑

1788
01:29:30,820 --> 01:29:32,070
与玩积木。

1789
01:29:32,070 --> 01:29:34,481
但现在，让我们实际上给
我们的词汇的其余部分

1790
01:29:34,481 --> 01:29:36,230
我们已经完成了
上周与划痕

1791
01:29:36,230 --> 01:29:39,350
通过一些其他的考虑看看
在C--结构不是所有的人。

1792
01:29:39,350 --> 01:29:41,680
但是我们的想法
就要看真的只是

1793
01:29:41,680 --> 01:29:45,610
要强调从翻译
一种语言，从无到有，到另一个，C.

1794
01:29:45,610 --> 01:29:48,470
>> 随着时间的推移，我们会拿起
更多的工具，我们的工具包，

1795
01:29:48,470 --> 01:29:49,820
可以这么说，语法上。

1796
01:29:49,820 --> 01:29:54,190
而且，事实上，你会看到的想法
现在从上周相当熟悉。

1797
01:29:54,190 --> 01:29:55,200
因此，让我们做到这一点。

1798
01:29:55,200 --> 01:29:58,870
>> 让我们继续前进，并掀起程序
实际使用一些表情，

1799
01:29:58,870 --> 01:30:00,720
布尔表达式。

1800
01:30:00,720 --> 01:30:02,810
让我继续在这里
并创建一个新的文件。

1801
01:30:02,810 --> 01:30:06,090
我会打电话给这个condition.c。

1802
01:30:06,090 --> 01:30:09,350
>> 让我继续前进，
包括CS50库。

1803
01:30:09,350 --> 01:30:12,640
让我继续前进，包括
标准IO.h我们的功能，

1804
01:30:12,640 --> 01:30:14,690
和printf，更分别。

1805
01:30:14,690 --> 01:30:18,900
让我给自己的样板
INT主要无效，其解释我们

1806
01:30:18,900 --> 01:30:20,360
回来的未来。

1807
01:30:20,360 --> 01:30:23,820
>> 现在让我先走，并把
我通过get INT一个int。

1808
01:30:23,820 --> 01:30:25,970
然后让我继续前进，做到这一点。

1809
01:30:25,970 --> 01:30:30,150
我想说，如果我是less--让我们
正，负区分

1810
01:30:30,150 --> 01:30:31,260
或零值。

1811
01:30:31,260 --> 01:30:36,630
>> 所以，如果我是小于零，让我
只是有这个计划简单地说，

1812
01:30:36,630 --> 01:30:42,370
负，反斜线N，否则
如果i大于零。

1813
01:30:42,370 --> 01:30:47,030
现在，我当然会说
printf的正面，反斜线ñ。

1814
01:30:47,030 --> 01:30:50,690
然后，其他if--我能做到这一点。

1815
01:30:50,690 --> 01:30:53,410
>> 如果我等于0，我可以做的。

1816
01:30:53,410 --> 01:30:55,840
但我在做被
至少一个错误了。

1817
01:30:55,840 --> 01:30:59,480
回想一下，等号
不相等的，因为我们人类知道这一点。

1818
01:30:59,480 --> 01:31:01,010
>> 但它的赋值操作符。

1819
01:31:01,010 --> 01:31:05,640
而我们不希望在采取0
权利，把它放在我的左边。

1820
01:31:05,640 --> 01:31:11,810
因此，为了避免这种混乱，或
也许是平等的滥用签收，

1821
01:31:11,810 --> 01:31:14,740
人类决定几年前
在许多编程语言

1822
01:31:14,740 --> 01:31:18,000
当您要检查等式
左和右之间，

1823
01:31:18,000 --> 01:31:19,635
你实际使用等于等号。

1824
01:31:19,635 --> 01:31:21,010
所以，你打等号的两倍。

1825
01:31:21,010 --> 01:31:25,600
当你想从分配权
到左，你用一个等号。

1826
01:31:25,600 --> 01:31:29,360
因此，我们可以做别的this--
如果我等于为零。

1827
01:31:29,360 --> 01:31:31,710
>> 然后，我可以去
打开我的大括号，

1828
01:31:31,710 --> 01:31:36,087
并说，printf的0，反斜线N，完成。

1829
01:31:36,087 --> 01:31:38,170
但要记住，这些是如何
在岔路口能正常工作。

1830
01:31:38,170 --> 01:31:39,836
而且，真的，只是想想逻辑。

1831
01:31:39,836 --> 01:31:41,510
i是一个数字。

1832
01:31:41,510 --> 01:31:43,320
这是一个整数，具体。

1833
01:31:43,320 --> 01:31:48,600
这意味着它将会是少
大于0，或者大于0，或者0大。

1834
01:31:48,600 --> 01:31:51,600
因此，有一种这样
隐含的默认情况。

1835
01:31:51,600 --> 01:31:54,920
>> 因此，我们可以，就像
划伤，免除了其他如，

1836
01:31:54,920 --> 01:31:55,747
而只是说别的。

1837
01:31:55,747 --> 01:31:57,830
从逻辑上讲，如果您在
程序员知道，只有

1838
01:31:57,830 --> 01:32:01,635
三个存储成一个
情况可能fall--第一，

1839
01:32:01,635 --> 01:32:03,510
第二，或第三
在这个case--不

1840
01:32:03,510 --> 01:32:07,100
懒得添加额外的精度
和附加​​逻辑那里。

1841
01:32:07,100 --> 01:32:09,690
只是继续用
默认情况下，这里的人。

1842
01:32:09,690 --> 01:32:11,950
>> 现在，让我们继续
保存此之后，使

1843
01:32:11,950 --> 01:32:15,760
条件斜线点条件 -
不是一个伟大的用户界面，

1844
01:32:15,760 --> 01:32:18,914
因为我不惹得
用户，正如我前面提到的。

1845
01:32:18,914 --> 01:32:19,580
但是，这很好。

1846
01:32:19,580 --> 01:32:20,454
我们将保持简单。

1847
01:32:20,454 --> 01:32:21,890
让我们尝试数字42。

1848
01:32:21,890 --> 01:32:23,240
这就是积极的。

1849
01:32:23,240 --> 01:32:26,120
让我们尝试次数
负42负。

1850
01:32:26,120 --> 01:32:28,244
>> 让我们尝试值0。

1851
01:32:28,244 --> 01:32:29,160
而且，事实上，它的工作原理。

1852
01:32:29,160 --> 01:32:33,900
现在，你将与之前看到的问题
长，检测的事三次，

1853
01:32:33,900 --> 01:32:34,980
可能不充分。

1854
01:32:34,980 --> 01:32:37,438
你可能想测试一些
更大的数字，一些规模较小的

1855
01:32:37,438 --> 01:32:40,520
数字，一些角落情况下，如
我们会来描述它们。

1856
01:32:40,520 --> 01:32:42,500
>> 但现在，这是一个
很简单的程序。

1857
01:32:42,500 --> 01:32:45,160
而且我敢肯定，在逻辑上，
它分为三种情况。

1858
01:32:45,160 --> 01:32:49,360
而且，事实上，即使我们只是
集中在潜在的缺点

1859
01:32:49,360 --> 01:32:53,480
不精确和溢出，在
现实中，许多的CS50的问题，

1860
01:32:53,480 --> 01:32:56,000
我们不会担心
一下，所有的时间，

1861
01:32:56,000 --> 01:32:59,050
溢出的这些问题，
不精确的，因为，事实上，在C，

1862
01:32:59,050 --> 01:33:01,889
它实际上不是所有的
容易避免这些东西。

1863
01:33:01,889 --> 01:33:04,180
如果你想计数
大，大，大，

1864
01:33:04,180 --> 01:33:07,510
事实证明，有技术，您
可以使用，常累及东西叫做

1865
01:33:07,510 --> 01:33:11,240
图书馆的馆藏代码，即
其他人写的，你可以使用，

1866
01:33:11,240 --> 01:33:13,910
和其他语言如
Java和其他人，其实

1867
01:33:13,910 --> 01:33:15,800
让人们更方便
数甚至更高。

1868
01:33:15,800 --> 01:33:19,810
因此，它确实是有些危险
您使用的语言的函数。

1869
01:33:19,810 --> 01:33:22,710
并在未来几周内，我们将
看有多危险真的Ç

1870
01:33:22,710 --> 01:33:24,950
可如果不正确地使用它。

1871
01:33:24,950 --> 01:33:27,610
但是从那里，并与
蟒蛇，和JavaScript，将

1872
01:33:27,610 --> 01:33:32,620
我们图层上的某些额外的保护，
并运行这些风险较少。

1873
01:33:32,620 --> 01:33:35,820
>> 因此，让多一点
有趣的逻辑在我们的节目。

1874
01:33:35,820 --> 01:33:39,110
因此，让我继续创建
一个叫做逻辑程序

1875
01:33:39,110 --> 01:33:43,804
只是这样我就可以玩一些
实际的逻辑，logical.c。

1876
01:33:43,804 --> 01:33:46,870
我只是复制和粘贴一些
从早期的代码，所以我回来

1877
01:33:46,870 --> 01:33:49,950
这个漂亮的出发点。

1878
01:33:49,950 --> 01:33:53,980
>> 让我这个时候做字符C.我
打算给​​它的C名称

1879
01:33:53,980 --> 01:33:58,510
只是因为它的传统，
获取来自用户的字符。

1880
01:33:58,510 --> 01:34:00,730
让我们假装
我实施的一部分

1881
01:34:00,730 --> 01:34:04,130
该室的方案，删除
在此之前，程序提示用户

1882
01:34:04,130 --> 01:34:05,400
删除文件。

1883
01:34:05,400 --> 01:34:06,750
我们怎么能做到这一点？

1884
01:34:06,750 --> 01:34:11,090
>> 我想说的是，如果C等于
等于，报价引文结束，

1885
01:34:11,090 --> 01:34:16,304
Y，然后我要去承担
该用户已经是选择。

1886
01:34:16,304 --> 01:34:17,470
我只是要打印的是。

1887
01:34:17,470 --> 01:34:19,440
如果它被实际编写
拆除程序，

1888
01:34:19,440 --> 01:34:21,420
我们可以删除文件
有更多行的代码。

1889
01:34:21,420 --> 01:34:22,461
但我们会保持它的简单。

1890
01:34:22,461 --> 01:34:25,950

1891
01:34:25,950 --> 01:34:31,250
>> 如果C等于等于N--
现在这里，我会说，

1892
01:34:31,250 --> 01:34:32,980
用户必须意味着没有。

1893
01:34:32,980 --> 01:34:34,360
然后别的，你知道吗？

1894
01:34:34,360 --> 01:34:36,200
我不知道还有什么
用户将要输入。

1895
01:34:36,200 --> 01:34:38,533
所以，我只是说，
这是一个错误，无论

1896
01:34:38,533 --> 01:34:40,070
他或她实际键入。

1897
01:34:40,070 --> 01:34:41,180
>> 那么是什么回事？

1898
01:34:41,180 --> 01:34:44,530
有一个根本的区别
与我在过去所做的那样。

1899
01:34:44,530 --> 01:34:49,300
双引号，双引号，双
报价和，但是，单引号

1900
01:34:49,300 --> 01:34:50,170
单引号。

1901
01:34:50,170 --> 01:34:52,860
原来，在C，当
你想要写一个字符串，

1902
01:34:52,860 --> 01:34:56,680
你使用双引号，就像我们已经
使用所有这一次的printf了。

1903
01:34:56,680 --> 01:35:02,030
>> 但是，如果你要处理的只是一个
单个字符，所谓字符，

1904
01:35:02,030 --> 01:35:03,780
那么你实际使用单引号。

1905
01:35:03,780 --> 01:35:05,450
你们当中谁已设定
之前，你可能没有

1906
01:35:05,450 --> 01:35:07,850
不用担心这个
区别在某些语言。

1907
01:35:07,850 --> 01:35:09,450
在C中，这非常重要。

1908
01:35:09,450 --> 01:35:12,560
所以，当我得到一个char，我想
使用equals来比较字符

1909
01:35:12,560 --> 01:35:18,350
等于像y或n一些信，我做的，
的确，需要有单引号。

1910
01:35:18,350 --> 01:35:19,770
>> 现在，让我们继续前进，做到这一点。

1911
01:35:19,770 --> 01:35:26,180
让我们继续前进，不要做
逻辑点斜线逻辑。

1912
01:35:26,180 --> 01:35:27,305
而现在我被提示。

1913
01:35:27,305 --> 01:35:30,638
因此，据推测，更好的用户体验
实际上告诉我在这里做什么。

1914
01:35:30,638 --> 01:35:33,030
但我要去只是盲目
说Y（是），不错，真不错。

1915
01:35:33,030 --> 01:35:35,780
>> 让我们再次运行它，正因为没有，美观大方。

1916
01:35:35,780 --> 01:35:39,610
假设像某些人我知道，
我的大写锁定键是所有过于频繁。

1917
01:35:39,610 --> 01:35:43,740
所以我做资本Y，回车，错误。

1918
01:35:43,740 --> 01:35:46,130
OK，这不是正是我期待的。

1919
01:35:46,130 --> 01:35:48,170
的确，计算机
简直是在做什么

1920
01:35:48,170 --> 01:35:51,794
我告诉它do--检查
小写字母y和小写的n。

1921
01:35:51,794 --> 01:35:53,960
这并不觉得自己是最好
用户体验，虽然。

1922
01:35:53,960 --> 01:35:59,010
让我索取，接受采访
无论是小写或大写。

1923
01:35:59,010 --> 01:36:02,090
因此，原来，你可能想
说类似的划痕，

1924
01:36:02,090 --> 01:36:08,150
像字面上或C等于
等于资本单引号年。

1925
01:36:08,150 --> 01:36:11,400
事实证明，C没有
这个文字关键字或。

1926
01:36:11,400 --> 01:36:12,880
>> 但它确实有两个竖条。

1927
01:36:12,880 --> 01:36:15,463
你要平时按住Shift，
如果您使用的是美式键盘，

1928
01:36:15,463 --> 01:36:18,910
并击中竖线
按键上的回车键。

1929
01:36:18,910 --> 01:36:22,410
但是，这竖线
竖线表示或。

1930
01:36:22,410 --> 01:36:26,220
>> 如果，相反，我们希望
说，就像在刮，

1931
01:36:26,220 --> 01:36:28,180
我们可以做的符号与符号。

1932
01:36:28,180 --> 01:36:31,330
这使得没有任何逻辑意义在这里，
因为人不可能

1933
01:36:31,330 --> 01:36:37,110
键入y和小写ÿ
和资本y为相同的字符。

1934
01:36:37,110 --> 01:36:39,470
所以，还是就是我们打算在这里。

1935
01:36:39,470 --> 01:36:46,280
>> 所以，如果我这样做，在这两个地方，或c
等于等于资本N，现在重新运行，

1936
01:36:46,280 --> 01:36:49,390
使逻辑，重新运行逻辑。

1937
01:36:49,390 --> 01:36:51,200
现在，我可以键入y。

1938
01:36:51,200 --> 01:36:53,920
而且我可以再做一次
资本Y，或资本N.

1939
01:36:53,920 --> 01:36:56,630
而且我可以添加额外的
组合依然。

1940
01:36:56,630 --> 01:36:58,810
>> 因此，这是一个逻辑
程序只要现在

1941
01:36:58,810 --> 01:37:01,940
我检查的逻辑
这个值或该值。

1942
01:37:01,940 --> 01:37:06,420
我不就得了，必然，
拿出两个IFS否则IFS。

1943
01:37:06,420 --> 01:37:09,960
其实我可以结合一些
以这种方式将相关逻辑。

1944
01:37:09,960 --> 01:37:11,950
因此，这将是更好
设计不是简单的

1945
01:37:11,950 --> 01:37:17,490
他说，如果C等于较低的情况下，y，
打印是的，如果C等于资本Y，

1946
01:37:17,490 --> 01:37:20,074
打印是的，如果C等于
lower--换句话说，

1947
01:37:20,074 --> 01:37:21,990
你不必有
越来越多的分支。

1948
01:37:21,990 --> 01:37:28,840
您可以结合一些等价的
分支逻辑，如在这种方式。

1949
01:37:28,840 --> 01:37:34,150
>> 因此，让我们来看看只有一个
最后一个要素，一是最终的构建，

1950
01:37:34,150 --> 01:37:34,847
这C允许。

1951
01:37:34,847 --> 01:37:36,930
我们会回来的
今后其他的还是。

1952
01:37:36,930 --> 01:37:41,400
然后我们通过观察得出结论：
在代码 - 不正确性

1953
01:37:41,400 --> 01:37:46,070
让代码work--而设计
的代码，建厂初期这些种子。

1954
01:37:46,070 --> 01:37:51,337
>> 因此，让我继续前进，
在这里开辟一个新的文件。

1955
01:37:51,337 --> 01:37:51,920
你知道吗？

1956
01:37:51,920 --> 01:37:54,450
我要重新实现
同样的程序，

1957
01:37:54,450 --> 01:37:55,940
但使用不同的构建体。

1958
01:37:55,940 --> 01:38:00,110
>> 因此，让我赶紧给自己
获得包括CS50.h

1959
01:38:00,110 --> 01:38:04,150
为CS50库，
标准Io.h像printf。

1960
01:38:04,150 --> 01:38:06,510
给我INT主要无效。

1961
01:38:06,510 --> 01:38:09,310
然后在这里，让
我继续前进，做到这一点。

1962
01:38:09,310 --> 01:38:12,010
>> 煤焦Ç得到得到CHAR，就像以前一样。

1963
01:38:12,010 --> 01:38:16,770
而且我将使用一个新的结构
now--切换，什么角色？

1964
01:38:16,770 --> 01:38:19,820
因此，开关是一种像
切换火车轨道。

1965
01:38:19,820 --> 01:38:22,070
或者，真的，这是怎么样的
如果一个别人，如果别人如果

1966
01:38:22,070 --> 01:38:23,980
但写的有些不同。

1967
01:38:23,980 --> 01:38:25,490
>> 开关看起来是这样的。

1968
01:38:25,490 --> 01:38:29,060
你有开关，然后什么
字符或你想看看号码，

1969
01:38:29,060 --> 01:38:32,000
然后一些大括号喜欢
划痕，只是说做这个东西。

1970
01:38:32,000 --> 01:38:33,480
然后你有不同的情况。

1971
01:38:33,480 --> 01:38:34,830
>> 你不if和else使用。

1972
01:38:34,830 --> 01:38:37,050
你从字面上用字情况。

1973
01:38:37,050 --> 01:38:38,790
你会说这样的事情。

1974
01:38:38,790 --> 01:38:43,820
>> 因此，在一个小写y的情况下，
或在资本Y的情况下，

1975
01:38:43,820 --> 01:38:47,350
继续前进并打印出肯定的。

1976
01:38:47,350 --> 01:38:49,020
然后打出来的开关。

1977
01:38:49,020 --> 01:38:49,580
而已。

1978
01:38:49,580 --> 01:38:50,880
我们就大功告成了。

1979
01:38:50,880 --> 01:38:57,270
>> 否则，如果，可以这么说，
小写n或大写字母N，

1980
01:38:57,270 --> 01:39:02,560
然后继续和打印
出去不，再突破。

1981
01:39:02,560 --> 01:39:08,022
Else--和这种是
默认情况下indeed--的printf error--

1982
01:39:08,022 --> 01:39:10,980
和公正的良好措施，但
这在逻辑​​上破则没有必要

1983
01:39:10,980 --> 01:39:12,896
因为我们是在最后
反正开关，

1984
01:39:12,896 --> 01:39:14,520
现在我打破了开关了​​。

1985
01:39:14,520 --> 01:39:16,280
因此，这看起来有点不同。

1986
01:39:16,280 --> 01:39:18,272
>> 但是，从逻辑上讲，它是
实际上相当于。

1987
01:39:18,272 --> 01:39:19,980
你为什么要使用
一个比其他？

1988
01:39:19,980 --> 01:39:23,220
有时候，只是个人喜好，
有时美学，

1989
01:39:23,220 --> 01:39:25,420
如果我看了一眼这个
现在，有什么东西

1990
01:39:25,420 --> 01:39:27,510
以说是为
这个代码的可读性。

1991
01:39:27,510 --> 01:39:30,690
我的意思是，心中永远的事实，这
代码是新的在房间里我们许多人。

1992
01:39:30,690 --> 01:39:33,515
>> 但它只是一种很漂亮。

1993
01:39:33,515 --> 01:39:37,760
你看小写字母Y，资本Y，
小写N，大写字母N默认情况下，

1994
01:39:37,760 --> 01:39:40,150
它只是一种跳跃
出你的方式

1995
01:39:40,150 --> 01:39:42,200
如此，可以说，也许
在前面的例子

1996
01:39:42,200 --> 01:39:45,780
与如果，和垂直杆，
和其他IFS，可能没有。

1997
01:39:45,780 --> 01:39:51,600
因此，这是真正的个人问题
选择，真的，还是可读性，

1998
01:39:51,600 --> 01:39:52,360
的代码。

1999
01:39:52,360 --> 01:39:58,230
>> 但在功能方面，让我
继续前进，使开关，点斜杠

2000
01:39:58,230 --> 01:40:05,830
开关，现在键入小写字母Y，
资本Y，小写的n，资本N，

2001
01:40:05,830 --> 01:40:09,250
大卫，重试，因为这是
不是单个字符。

2002
01:40:09,250 --> 01:40:12,050
让我们做X，错误，符合市场预期。

2003
01:40:12,050 --> 01:40:15,640
和，logically--这是值得
我会鼓励general--甚至

2004
01:40:15,640 --> 01:40:17,790
虽然我们只是刮伤
的一些功能上。

2005
01:40:17,790 --> 01:40:20,560
>> 它可能不是很明显，当你
自己坐到键盘，

2006
01:40:20,560 --> 01:40:21,370
这个怎么用？

2007
01:40:21,370 --> 01:40:22,240
你会这样吗？

2008
01:40:22,240 --> 01:40:25,630
关于有美丽的东西
膝上型或桌面，或访问

2009
01:40:25,630 --> 01:40:29,290
与编译器的计算机，
与这样的代码编辑器，

2010
01:40:29,290 --> 01:40:32,990
是你几乎总是可以回答这些
问题为自己只是尝试。

2011
01:40:32,990 --> 01:40:36,570
>> 例如，如果修辞
在眼前的问题是，

2012
01:40:36,570 --> 01:40:39,540
如果你忘记了，会发生什么
你break语句？

2013
01:40:39,540 --> 01:40:41,400
这实际上是一个
很平常的事，

2014
01:40:41,400 --> 01:40:43,540
因为它看起来并不
就像你真的需要它们。

2015
01:40:43,540 --> 01:40:46,790
他们并不真正完成
像想一个括号或卷曲

2016
01:40:46,790 --> 01:40:47,714
括号一样。

2017
01:40:47,714 --> 01:40:49,630
让我们继续前进，
重新编译代码，看看。

2018
01:40:49,630 --> 01:40:53,690
因此，请开关，点斜线开关。

2019
01:40:53,690 --> 01:40:56,435
让我们输入小写
Y，顶的情况下，回车。

2020
01:40:56,435 --> 01:40:59,390

2021
01:40:59,390 --> 01:41:00,700
所以我输入年。

2022
01:41:00,700 --> 01:41:04,420
>> 该计划说的没错，没有，错误，
因为虽然它是改变了主意。

2023
01:41:04,420 --> 01:41:09,280
但是，那种是的，因为会发生什么
有开关是第一种情况是

2024
01:41:09,280 --> 01:41:13,899
比赛实际上意味着，哎电脑，
执行所有代码的下方。

2025
01:41:13,899 --> 01:41:16,690
如果你不说破，或
不说破，还是不说破，

2026
01:41:16,690 --> 01:41:19,540
电脑会爆
通过所有这些行

2027
01:41:19,540 --> 01:41:22,779
并执行所有的人，直到
它获取到大括号。

2028
01:41:22,779 --> 01:41:24,320
因此，刹车，的确有必要。

2029
01:41:24,320 --> 01:41:27,120
但这里外卖，当
有疑问，尝试一些东西。

2030
01:41:27,120 --> 01:41:29,510
也许先救你的代码，
或将其保存在一个额外的文件

2031
01:41:29,510 --> 01:41:32,930
如果你真的很担心
搞乱了，不得不恢复

2032
01:41:32,930 --> 01:41:34,430
你知道的工作是工作。

2033
01:41:34,430 --> 01:41:35,410
>> 但尝试的事情。

2034
01:41:35,410 --> 01:41:38,074
不要像害怕，也许，
什么样的电脑可能会做，

2035
01:41:38,074 --> 01:41:39,490
或者，你可能碰坏。

2036
01:41:39,490 --> 01:41:42,790
您可以随时恢复
一些早期版本。

2037
01:41:42,790 --> 01:41:45,640
>> 因此，让我们通过观察结束
在代码的设计。

2038
01:41:45,640 --> 01:41:49,020
现在，我们有这个能力来写
的条件下，与写循环，

2039
01:41:49,020 --> 01:41:50,850
和变量，和通话功能。

2040
01:41:50,850 --> 01:41:54,590
因此，坦率地说，我们是那种回
我们是一个星期前从无到有，

2041
01:41:54,590 --> 01:42:00,120
尽管有一个不太引人注目的文本
环境比刮允许。

2042
01:42:00,120 --> 01:42:03,990
>> 但是请注意，我们的速度已经获得
那个词汇，即使是

2043
01:42:03,990 --> 01:42:07,570
要带一小会儿下沉，
所以，我们现在可以使用这个词汇

2044
01:42:07,570 --> 01:42:10,320
写出比较有趣的节目。

2045
01:42:10,320 --> 01:42:12,940
让我们一起来小步
往那，如下所示。

2046
01:42:12,940 --> 01:42:14,890
让我继续前进，
在这里创建一个新文件。

2047
01:42:14,890 --> 01:42:17,750
>> 我要调用此
prototype.c，并引进

2048
01:42:17,750 --> 01:42:20,954
首次的能力
使自己的功能。

2049
01:42:20,954 --> 01:42:22,870
有些人可能有
有划痕做到了这一点，

2050
01:42:22,870 --> 01:42:25,430
让你可以创建你
在刮自己的自定义模块，

2051
01:42:25,430 --> 01:42:27,892
然后将它们拖放到的地方
无论你想在C.

2052
01:42:27,892 --> 01:42:30,100
而在大多数编程
语言，你可以做完全

2053
01:42:30,100 --> 01:42:33,580
that--使自己的功能，
如果它们不存在。

2054
01:42:33,580 --> 01:42:38,660
>> 所以，举例来说，让我先走
和包括CS50.h，并且包括

2055
01:42:38,660 --> 01:42:43,110
标准IO.h，INT主要作废。

2056
01:42:43,110 --> 01:42:46,020
现在我们有一个
占位蓄势待发。

2057
01:42:46,020 --> 01:42:48,550
我一直在承印物
像今天的人的名字。

2058
01:42:48,550 --> 01:42:51,910
那种感觉like--
不会是很好，如果有

2059
01:42:51,910 --> 01:42:53,936
是所谓的打印功能的名称？

2060
01:42:53,936 --> 01:42:55,060
我没有用printf。

2061
01:42:55,060 --> 01:42:56,976
我不必记住
所有的格式代码。

2062
01:42:56,976 --> 01:43:00,050
为什么不要我，为什么
没有人在我面前，

2063
01:43:00,050 --> 01:43:02,980
创建一个函数调用打印
名，给予一定的名字，

2064
01:43:02,980 --> 01:43:03,980
简单地打印出来？

2065
01:43:03,980 --> 01:43:08,700
>> 换句话说，如果我说，嘿，
电脑，给我一个字符串

2066
01:43:08,700 --> 01:43:11,870
通过询问用户这样，
通过CS50的get字符串函数。

2067
01:43:11,870 --> 01:43:15,090
嘿，计算机，把那个字符串
在左手侧的变量，

2068
01:43:15,090 --> 01:43:16,150
并称之为秒。

2069
01:43:16,150 --> 01:43:22,150
然后，嘿嘿计算机，勇往直前
并打印此人的姓名，完成。

2070
01:43:22,150 --> 01:43:26,240
>> 现在，这将是很好的，因为
这一方案，适当命名的，

2071
01:43:26,240 --> 01:43:29,170
告诉我这是什么应该做的
这些函数的名称的方式。

2072
01:43:29,170 --> 01:43:32,930
让我走，让原型，回车。

2073
01:43:32,930 --> 01:43:34,930
而且，不幸的是，
这是不会飞。

2074
01:43:34,930 --> 01:43:39,430
>> Prototype.c，7号线，字符
5，错误，隐式声明

2075
01:43:39,430 --> 01:43:42,960
函数打印名字
在C99，C99是无效的

2076
01:43:42,960 --> 01:43:45,130
这意味着一个版本的C
，在1999年就出来了。

2077
01:43:45,130 --> 01:43:45,730
就这样。

2078
01:43:45,730 --> 01:43:48,780
>> 所以，我不知道是什么
所有这一切意味着呢。

2079
01:43:48,780 --> 01:43:50,810
但我认识到红色的错误。

2080
01:43:50,810 --> 01:43:51,770
这是很明显的。

2081
01:43:51,770 --> 01:43:53,769
>> 并且似乎与
绿色性格在这里，

2082
01:43:53,769 --> 01:43:57,520
问题是打印的名字，开
括号S，右括号，分号。

2083
01:43:57,520 --> 01:44:01,800
但隐式声明
函数，我们确实看到前面简单。

2084
01:44:01,800 --> 01:44:04,880
这意味着，简单地说，锵
不知道我的意思。

2085
01:44:04,880 --> 01:44:09,000
>> 我用一个词汇词，它的
以前从未见过或被教导。

2086
01:44:09,000 --> 01:44:11,950
所以，我要教它
这个函数是什么意思。

2087
01:44:11,950 --> 01:44:13,590
所以我要继续前进，并做到这一点。

2088
01:44:13,590 --> 01:44:17,970
>> 我要继续前进，实现
我自己的函数调用打印名称。

2089
01:44:17,970 --> 01:44:24,720
而我要说，如下所示，这
它这样做，printf的，你好，百分比

2090
01:44:24,720 --> 01:44:27,760
S，反斜线N，名称，分号。

2091
01:44:27,760 --> 01:44:29,250
那么，为什么我只是做？

2092
01:44:29,250 --> 01:44:31,325
>> 因此，原来，为了
实现自己的功能，

2093
01:44:31,325 --> 01:44:33,845
我们种借用一些
相同的结构主要

2094
01:44:33,845 --> 01:44:35,720
我们刚刚得到
理所当然的，我

2095
01:44:35,720 --> 01:44:37,730
知道刚才复制和
粘贴几乎什么

2096
01:44:37,730 --> 01:44:39,170
我已经写了过去​​。

2097
01:44:39,170 --> 01:44:40,570
但这里要注意的格局。

2098
01:44:40,570 --> 01:44:43,750
诠释，主，无效的，我们将梳理出
没过多久什么实际意义。

2099
01:44:43,750 --> 01:44:46,160
>> 但在今天，只是
注意到并行性。

2100
01:44:46,160 --> 01:44:48,210
太虚，打印的名字，
字符串名称，所以有

2101
01:44:48,210 --> 01:44:50,310
一个紫色的关键字，这
我们要开始

2102
01:44:50,310 --> 01:44:54,067
调用返回类型，名称
的功能，并且然后将输入。

2103
01:44:54,067 --> 01:44:56,400
所以，实际上，我们可以提炼出
这种上周一样的

2104
01:44:56,400 --> 01:44:59,030
如，这是名称或
我们的代码算法

2105
01:44:59,030 --> 01:45:00,761
去写 - 的
底层算法

2106
01:45:00,761 --> 01:45:02,010
代码我们将书写。

2107
01:45:02,010 --> 01:45:03,180
>> 这是它的输入。

2108
01:45:03,180 --> 01:45:04,670
这是它的输出。

2109
01:45:04,670 --> 01:45:08,730
此功能，打印的名字，是
设计上采用了一个名为名称的字符串，

2110
01:45:08,730 --> 01:45:11,350
也好，作为输入，然后空隙。

2111
01:45:11,350 --> 01:45:13,904
它不返回任何东西，
像得到字符串或得到INT一样。

2112
01:45:13,904 --> 01:45:15,570
所以它要交给我的东西回来。

2113
01:45:15,570 --> 01:45:17,960
它只是将有一个
副作用，可以这么说，

2114
01:45:17,960 --> 01:45:19,570
印刷一个人的名字。

2115
01:45:19,570 --> 01:45:22,260
因此注意到，7号线，我
可以调用打印名称。

2116
01:45:22,260 --> 01:45:25,920
10号线，我可以定义
或实施打印的名称。

2117
01:45:25,920 --> 01:45:28,450
但不幸的是，这还不够。

2118
01:45:28,450 --> 01:45:31,230
>> 让我继续前进，
保存后重新编译这一点。

2119
01:45:31,230 --> 01:45:33,910
哇，现在，我做了它
更糟的是，它似乎。

2120
01:45:33,910 --> 01:45:37,027
这样的隐式声明
功能打印名称无效。

2121
01:45:37,027 --> 01:45:38,360
并再次，还有更多的错误。

2122
01:45:38,360 --> 01:45:41,430
但正如我前面提醒，即使
如果你不知所措，

2123
01:45:41,430 --> 01:45:44,850
还是有点难过，看到这么多
错误，只专注于第一

2124
01:45:44,850 --> 01:45:47,500
最初，因为它可能只是
产生了连锁效应。

2125
01:45:47,500 --> 01:45:51,970
所以C，或锵更具体地，
仍不能识别打印的名称。

2126
01:45:51,970 --> 01:45:54,580
>> 那是因为铛，
在设计上，是种愚蠢。

2127
01:45:54,580 --> 01:45:56,280
它只做你告诉它做什么。

2128
01:45:56,280 --> 01:46:00,950
而且只在该命令这样做
在你告诉它做。

2129
01:46:00,950 --> 01:46:05,270
>> 所以我定义主四线，
就像我们一直很经常做的事情。

2130
01:46:05,270 --> 01:46:07,980
我在第10行定义的打印名称。

2131
01:46:07,980 --> 01:46:11,793
但我想使用
在七号线打印的名称。

2132
01:46:11,793 --> 01:46:13,670
>> 这太快了，还不存在。

2133
01:46:13,670 --> 01:46:19,150
所以，我可能是聪明，像，
好了，我们只是一起玩，

2134
01:46:19,150 --> 01:46:23,680
和移动打印的名字了
这里，和重新编译。

2135
01:46:23,680 --> 01:46:24,550
哦，我的上帝。

2136
01:46:24,550 --> 01:46:25,260
有效。

2137
01:46:25,260 --> 01:46:26,670
它是那样简单。

2138
01:46:26,670 --> 01:46:28,120
>> 但逻辑正是如此。

2139
01:46:28,120 --> 01:46:30,870
你要教锵什么
是通过首先确定函数。

2140
01:46:30,870 --> 01:46:31,920
然后你可以使用它。

2141
01:46:31,920 --> 01:46:33,940
但是，坦率地说，这种感觉
像滑坡。

2142
01:46:33,940 --> 01:46:35,773
>> 所以每次我运行
一个问题，我只是

2143
01:46:35,773 --> 01:46:39,450
要突出显示并复制代码
我写的，就把它和它粘贴在这里了。

2144
01:46:39,450 --> 01:46:41,370
而且，可以肯定，我们可以
图谋一些场景

2145
01:46:41,370 --> 01:46:43,286
其中一个可能的功能
需要调用另一个。

2146
01:46:43,286 --> 01:46:46,030
而你只是不能把每
功能上面隔。

2147
01:46:46,030 --> 01:46:47,930
>> 因此，原来在那里的
一个更好的解决方案。

2148
01:46:47,930 --> 01:46:50,100
我们可以离开这个可以。

2149
01:46:50,100 --> 01:46:53,677
而且，坦率地说，这是普遍不错，
方便，良好的设计

2150
01:46:53,677 --> 01:46:56,760
把主要一是因为，再次，
主要就好像当绿旗点击，

2151
01:46:56,760 --> 01:46:59,027
这是函数是
被默认执行。

2152
01:46:59,027 --> 01:47:01,110
所以，你不妨把
它在该文件的顶部

2153
01:47:01,110 --> 01:47:03,560
所以，当您或任何
其他人查看文件

2154
01:47:03,560 --> 01:47:06,360
你知道这是怎么回事
通过阅读主要首位。

2155
01:47:06,360 --> 01:47:15,360
所以，事实证明，我们可以告诉锵
主动，嘿嘿，锵，四线，

2156
01:47:15,360 --> 01:47:17,940
我答应实施
一个函数调用打印

2157
01:47:17,940 --> 01:47:22,600
名称以一个字符串名为name
作为输入，并且没有返回的，无效的。

2158
01:47:22,600 --> 01:47:24,770
我会避开
后来实现它。

2159
01:47:24,770 --> 01:47:25,680
>> 这里谈到主。

2160
01:47:25,680 --> 01:47:29,130
现在主要在第9行可以使用
打印名称，因为锵

2161
01:47:29,130 --> 01:47:32,600
被信任的是，最终，
它会遇到的定义

2162
01:47:32,600 --> 01:47:34,880
姓名正楷的实施。

2163
01:47:34,880 --> 01:47:37,390
所以，救了我的文件之后，让
我继续前进，使原型，

2164
01:47:37,390 --> 01:47:38,498
看起来不错，这一次。

2165
01:47:38,498 --> 01:47:43,470
点斜线，原型，让我
继续前进，键入一个名称。

2166
01:47:43,470 --> 01:47:48,440
大卫，你好大卫Zamila，你好
Zamila，事实上，现在的作品。

2167
01:47:48,440 --> 01:47:52,200
>> 因此，这里的成分是，我们已经
做了一个自定义的功能，如自定义

2168
01:47:52,200 --> 01:47:54,219
划痕块中，我们要调用它。

2169
01:47:54,219 --> 01:47:57,010
但是，与划痕在那里你可以
只是创建它，并开始使用它，

2170
01:47:57,010 --> 01:47:59,330
现在我们要成为一个
多一点迂腐，

2171
01:47:59,330 --> 01:48:03,410
实际上训练锵
使用，或指望它。

2172
01:48:03,410 --> 01:48:09,140
现在，顺便说一句，为什么这段时间有
我们一直只是盲目信仰，包括

2173
01:48:09,140 --> 01:48:12,170
CS50.h，并且包括标准IO.h？

2174
01:48:12,170 --> 01:48:15,190
>> 那么，事实证明，
其中一些其他的东西，

2175
01:48:15,190 --> 01:48:18,550
所有的这些点^ h
文件，这恰好是文件。

2176
01:48:18,550 --> 01:48:20,460
他们在头文件，可以这么说。

2177
01:48:20,460 --> 01:48:23,270
他们还在用C写的但是
他们是不同类型的文件。

2178
01:48:23,270 --> 01:48:28,690
>> 现在，你几乎可以承担
所有这是CS50.h内

2179
01:48:28,690 --> 01:48:33,360
一些单行尚且如此，
名为打印名称的功能，

2180
01:48:33,360 --> 01:48:36,840
但对于获取字符串，获取
浮动，和其他几个人。

2181
01:48:36,840 --> 01:48:41,510
而也有类似的原型，
单行，标准IO.h内

2182
01:48:41,510 --> 01:48:46,241
像printf，这是现在在
我自己打印名称的功能。

2183
01:48:46,241 --> 01:48:49,490
因此，换句话说，这整个时间内，我们
刚刚被盲目复制和粘贴

2184
01:48:49,490 --> 01:48:51,780
包括这一点，包括
这，这是怎么回事？

2185
01:48:51,780 --> 01:48:55,310
这些仅仅是一种线索
以铛，以什么功能

2186
01:48:55,310 --> 01:49:00,170
的确都是执行，只是
在不同的文件别处

2187
01:49:00,170 --> 01:49:02,440
别处在系统上。

2188
01:49:02,440 --> 01:49:05,160
>> 因此，我们已经实现打印的名称。

2189
01:49:05,160 --> 01:49:07,910
它确实有这种副作用
打印屏幕上的内容。

2190
01:49:07,910 --> 01:49:10,170
但它实际上并没有
递给我的东西回来。

2191
01:49:10,170 --> 01:49:12,200
我们如何去
执行一个程序，

2192
01:49:12,200 --> 01:49:14,510
并交给我的东西回来？

2193
01:49:14,510 --> 01:49:15,580
>> 好吧，让我们试试这个。

2194
01:49:15,580 --> 01:49:21,360
我要继续贯彻
一个名为return.c

2195
01:49:21,360 --> 01:49:24,530
所以我们可以演示如何的东西
以获得更多的字符串，或得到诠释，

2196
01:49:24,530 --> 01:49:27,340
实际上回国
回馈给用户。

2197
01:49:27,340 --> 01:49:29,840
让我们继续前进，并确定主要INT无效。

2198
01:49:29,840 --> 01:49:33,230
>> 并再次，在未来，我们将
解释什么是int和这一空白

2199
01:49:33,230 --> 01:49:34,090
其实这样做。

2200
01:49:34,090 --> 01:49:35,840
但今天，我们将
理所当然。

2201
01:49:35,840 --> 01:49:39,970
我会继续和printf，
一个良好的用户体验，x是。

2202
01:49:39,970 --> 01:49:44,360
然后，我会等待
用户给我x，其中GET INT。

2203
01:49:44,360 --> 01:49:48,459
>> 然后我要继续前进
并打印出X到广场。

2204
01:49:48,459 --> 01:49:50,500
所以，当你只有一个
键盘，一般的人

2205
01:49:50,500 --> 01:49:52,600
使用小萝卜
键盘上的符号

2206
01:49:52,600 --> 01:49:55,330
代表的功率
的，或者的指数。

2207
01:49:55,330 --> 01:49:58,960
SO x的平方是目前我。

2208
01:49:58,960 --> 01:50:00,660
>> 现在我要做到这一点。

2209
01:50:00,660 --> 01:50:03,940
我可以do--什么的x
平方？点¯x平方为x倍的X.

2210
01:50:03,940 --> 01:50:06,690
>> 我们这样做了一些
今天已经很久以前。

2211
01:50:06,690 --> 01:50:08,730
这种感觉并不像
那么多的进展。

2212
01:50:08,730 --> 01:50:09,570
你知道吗？

2213
01:50:09,570 --> 01:50:13,100
让我们利用一些想法
从抽象的最后一次。

2214
01:50:13,100 --> 01:50:16,080
>> 那岂不是很好，如果
有一个调用的函数

2215
01:50:16,080 --> 01:50:18,460
方认为正是这么做的？

2216
01:50:18,460 --> 01:50:20,640
它仍然在的结束
一天，做了同样的数学。

2217
01:50:20,640 --> 01:50:22,410
但是，让我们抽象
拿走的想法

2218
01:50:22,410 --> 01:50:25,280
一个数字乘以
另一个，只要给它一个名称，

2219
01:50:25,280 --> 01:50:27,360
像方此值。

2220
01:50:27,360 --> 01:50:29,560
>> 并且，换句话说，在
C，让我们创建一个功能

2221
01:50:29,560 --> 01:50:32,660
叫方认为正是这么做的。

2222
01:50:32,660 --> 01:50:34,600
这将被调用方。

2223
01:50:34,600 --> 01:50:35,790
这将需要一个int。

2224
01:50:35,790 --> 01:50:37,820
我们会只是
称之为N，默认情况下。

2225
01:50:37,820 --> 01:50:39,403
>> 但我们可以把它叫做什么，我们想要的。

2226
01:50:39,403 --> 01:50:42,900
和所有它会
这样做，从字面上看，就是回报

2227
01:50:42,900 --> 01:50:45,810
n次n的结果。

2228
01:50:45,810 --> 01:50:48,980
但是，因为它是
回国东西，这

2229
01:50:48,980 --> 01:50:53,690
在紫色我们已经关键字
以前从未见过，我，第11行，

2230
01:50:53,690 --> 01:50:55,410
不能说作废这个时候。

2231
01:50:55,410 --> 01:51:01,320
>> 太虚，在这个例子中，我们刚才看到
而打印的名字，只是表示，

2232
01:51:01,320 --> 01:51:02,190
做一点事。

2233
01:51:02,190 --> 01:51:04,170
但是，不要递给我的东西回来。

2234
01:51:04,170 --> 01:51:06,790
在这种情况下，我想
返回n次N，

2235
01:51:06,790 --> 01:51:08,460
或者不管它是什么，该号码。

2236
01:51:08,460 --> 01:51:12,460
>> 所以，我不能说，哎，电脑，
我返回任何结果，无效的。

2237
01:51:12,460 --> 01:51:16,166
这将返回在本质上，一个int。

2238
01:51:16,166 --> 01:51:17,790
所以，这是所有在这里吗。

2239
01:51:17,790 --> 01:51:20,070
>> 输入方
将是一个int。

2240
01:51:20,070 --> 01:51:24,760
因此，我们可以使用它，它有
有一个名字，N.这将输出

2241
01:51:24,760 --> 01:51:26,240
一个int并不需要一个名字。

2242
01:51:26,240 --> 01:51:29,590
我们可以把它交给主，或者是谁
用我记住，如果我们这个值

2243
01:51:29,590 --> 01:51:31,120
想拥有自己的变量。

2244
01:51:31,120 --> 01:51:33,230
>> 并再次，唯一的新
关键字这里是回归。

2245
01:51:33,230 --> 01:51:34,480
而我只是在做一些数学。

2246
01:51:34,480 --> 01:51:41,825
如果我真的想成为不必要的，
我可以说INT产品得到n次ñ。

2247
01:51:41,825 --> 01:51:44,170
>> 然后，我可以说，回归产品。

2248
01:51:44,170 --> 01:51:47,360
但同样，我的观点同期
这恰恰不是好的设计 -

2249
01:51:47,360 --> 01:51:50,060
喜欢，为什么引入一个名字，
一个符号，如产品，

2250
01:51:50,060 --> 01:51:51,570
只是立即返回呢？

2251
01:51:51,570 --> 01:51:53,670
这是一个有点清洁，
有点紧张，所以

2252
01:51:53,670 --> 01:51:59,380
说话，只是说回n倍
N，摆脱这一行干脆。

2253
01:51:59,380 --> 01:52:02,860
>> 它只是较少的代码阅读，
失误少的机会。

2254
01:52:02,860 --> 01:52:05,180
让我们看看这个
其实现在的作品。

2255
01:52:05,180 --> 01:52:09,380
现在，我要去
提前做出回报。

2256
01:52:09,380 --> 01:52:11,460
>> 嗯，哦，功能隐式声明。

2257
01:52:11,460 --> 01:52:14,080
我以前犯了这个错误，没什么大不了的。

2258
01:52:14,080 --> 01:52:18,950
我只需键入，或突出显示和
复制，完全相同的函数原型，

2259
01:52:18,950 --> 01:52:21,342
或签名，该功能在这里的。

2260
01:52:21,342 --> 01:52:22,800
或者，我可以移动整个功能。

2261
01:52:22,800 --> 01:52:23,841
>> 但是，这是一个有点懒惰。

2262
01:52:23,841 --> 01:52:24,870
因此，我们不会那么做。

2263
01:52:24,870 --> 01:52:27,960
现在，让我回
再次，点斜线回报。

2264
01:52:27,960 --> 01:52:32,790
>> x为2。X的平方等于4。
x被。X的平方等于9。

2265
01:52:32,790 --> 01:52:35,300
而功能似乎
现在的工作。

2266
01:52:35,300 --> 01:52:36,550
那么，有什么区别吗？

2267
01:52:36,550 --> 01:52:42,520
我有一个这就是所谓的平方函数，
在这种情况下，我把在一个输入。

2268
01:52:42,520 --> 01:52:43,830
而我回来的输出。

2269
01:52:43,830 --> 01:52:46,210
然而，此前，如果
我打开其他的例子

2270
01:52:46,210 --> 01:52:51,640
从早期的，这
被称为prototype.c，

2271
01:52:51,640 --> 01:52:54,770
我有打印的名称，
退回作废，可以这么说，

2272
01:52:54,770 --> 01:52:58,730
或者，它返回什么，
简单地产生了副作用。

2273
01:52:58,730 --> 01:53:00,230
>> 那么是什么回事？

2274
01:53:00,230 --> 01:53:03,520
那么，考虑功能
得到的字符串只是一瞬间。

2275
01:53:03,520 --> 01:53:06,570
我们一直在使用功能
得到以下列方式串。

2276
01:53:06,570 --> 01:53:10,464
>> 我们有一个函数来获取
字符串，如包括CS50.h，

2277
01:53:10,464 --> 01:53:16,624
包括标准IO.h，INT，主要的，无效的。

2278
01:53:16,624 --> 01:53:18,790
然后每一次我
名为get字符串到目前为止，

2279
01:53:18,790 --> 01:53:23,260
我说的一样，字符串s
得到得到的字符串，因为GET string--

2280
01:53:23,260 --> 01:53:27,880
我们称之为get.c-- GET字符串
本身返回一个字符串，我可以再

2281
01:53:27,880 --> 01:53:32,050
用了，说，你好，逗号，
％的S，反斜线N，S。

2282
01:53:32,050 --> 01:53:35,660
>> 因此，这是相同的例子，
真的，我们前面了。

2283
01:53:35,660 --> 01:53:37,920
因此，获得字符串返回一个值。

2284
01:53:37,920 --> 01:53:41,260
但是刚才，打印字符串
没有返回值。

2285
01:53:41,260 --> 01:53:42,721
它只是有一个副作用。

2286
01:53:42,721 --> 01:53:44,220
所以这是一个根本的区别。

2287
01:53:44,220 --> 01:53:46,710
我们已经看到了不同的
类型的功能现在，

2288
01:53:46,710 --> 01:53:49,490
其中一些已经返回
值，其中一些则没有。

2289
01:53:49,490 --> 01:53:51,890
因此，也许它的字符串或整型，浮点或。

2290
01:53:51,890 --> 01:53:53,480
或者，也许它只是无效。

2291
01:53:53,480 --> 01:53:55,710
>> 不同的是
这些函数

2292
01:53:55,710 --> 01:53:59,940
获取数据并返回一个值实际上是
把东西回表，

2293
01:53:59,940 --> 01:54:01,110
可以这么说。

2294
01:54:01,110 --> 01:54:03,710
因此，让我们继续前进，
看一眼决胜盘

2295
01:54:03,710 --> 01:54:09,129
的实施例，给出了一个感，现在的
我们怎么可能，的确，抽象更好，

2296
01:54:09,129 --> 01:54:11,670
更好，更好或更多
多，而且多，为了

2297
01:54:11,670 --> 01:54:13,810
写，最终更好的代码。

2298
01:54:13,810 --> 01:54:16,860
让我们继续前进，并在精神
刮，做到以下几点。

2299
01:54:16,860 --> 01:54:21,700
>> 让我继续前进，包括
CS50.h和标准IO.h.

2300
01:54:21,700 --> 01:54:24,010
让我先走，并把
我自己一个int，主要的，无效的。

2301
01:54:24,010 --> 01:54:27,380
让我先走，称此cough.c。

2302
01:54:27,380 --> 01:54:35,510
>> 让我继续前进，只是
像划痕，打印出咳嗽/ N。

2303
01:54:35,510 --> 01:54:37,170
我想这样做三次。

2304
01:54:37,170 --> 01:54:39,670
所以我，当然，只是去
复制和粘贴三次。

2305
01:54:39,670 --> 01:54:46,440
我现在要作
咳嗽点斜线咳嗽。

2306
01:54:46,440 --> 01:54:50,120
让我们给自己多一点的房间
在这里，回车，咳，咳，咳。

2307
01:54:50,120 --> 01:54:53,970
>> 还有，很明显，已经是一个
机会改善。

2308
01:54:53,970 --> 01:54:55,679
我复制并粘贴
今天一几次。

2309
01:54:55,679 --> 01:54:58,261
但是，这是唯一的，所以我没有
必须输入尽可能多的字符。

2310
01:54:58,261 --> 01:55:00,250
我还是改变了什么
这些代码行。

2311
01:55:00,250 --> 01:55:04,240
>> 这三条线是相同的，
这感觉懒惰，的确是，

2312
01:55:04,240 --> 01:55:07,110
而可能是不正确的方法。

2313
01:55:07,110 --> 01:55:11,029
那么什么成分
我们可以改善这个代码？

2314
01:55:11,029 --> 01:55:12,570
我们不必复制和粘贴的代码。

2315
01:55:12,570 --> 01:55:15,070
>> 而且，事实上，任何时候你感觉
自己复制和粘贴，

2316
01:55:15,070 --> 01:55:17,700
即使不更改代码，
赔率是有一个更好的办法。

2317
01:55:17,700 --> 01:55:19,470
而且，事实上，有。

2318
01:55:19,470 --> 01:55:22,510
让我继续前进，循环做了，
即使语法可能不

2319
01:55:22,510 --> 01:55:24,570
自然来呢。

2320
01:55:24,570 --> 01:55:29,494
>> 这样做三次，只需
通过执行following--

2321
01:55:29,494 --> 01:55:31,160
我碰巧从实践中知道这一点。

2322
01:55:31,160 --> 01:55:32,810
但是，我们有一些例子吧。

2323
01:55:32,810 --> 01:55:34,950
你会看到在线
更多的参考依然。

2324
01:55:34,950 --> 01:55:37,790
>> 这是第6行的句法，即
就像从头开始重复

2325
01:55:37,790 --> 01:55:40,090
块，重复下面的三倍。

2326
01:55:40,090 --> 01:55:41,340
这是一个有点神奇现在。

2327
01:55:41,340 --> 01:55:43,050
但是，这会得到更多，
越来越熟悉。

2328
01:55:43,050 --> 01:55:45,050
>> 而且它会重复
八号线三次，

2329
01:55:45,050 --> 01:55:52,390
所以，如果我重新编译化妆咳嗽，
点斜线咳，咳，咳，咳。

2330
01:55:52,390 --> 01:55:54,030
它仍然以同样的方式。

2331
01:55:54,030 --> 01:55:55,550
所以这是一切优秀和良好。

2332
01:55:55,550 --> 01:55:58,200
但是，这不是很抽象。

2333
01:55:58,200 --> 01:55:59,371
>> 这是完全正确的。

2334
01:55:59,371 --> 01:56:01,370
但感觉好像有
可能是一个机会，

2335
01:56:01,370 --> 01:56:03,750
作为在世界
从无到有，来样开始

2336
01:56:03,750 --> 01:56:07,530
在这里添加一些语义使
我不只是有一定的循环，

2337
01:56:07,530 --> 01:56:09,867
和一个函数，说
咳嗽，还是咳嗽。

2338
01:56:09,867 --> 01:56:10,450
你知道吗？

2339
01:56:10,450 --> 01:56:12,620
我想做个
有点凉比，

2340
01:56:12,620 --> 01:56:16,090
实际上编写一个函数，
有一定的副作用，称之为咳嗽。

2341
01:56:16,090 --> 01:56:20,830
>> 而且它没有输入，
无返回值作为输出。

2342
01:56:20,830 --> 01:56:22,680
但是你知道它做什么？

2343
01:56:22,680 --> 01:56:29,370
它this--的printf，
报价引文结束，咳嗽。

2344
01:56:29,370 --> 01:56:32,380
>> 现在在这里，我要去
继续前进，对于int，

2345
01:56:32,380 --> 01:56:36,070
我得到零，我不到3，我加再加。

2346
01:56:36,070 --> 01:56:39,770
我会不会做的printf，这是
可以说是一个低层次的实现

2347
01:56:39,770 --> 01:56:40,270
详情。

2348
01:56:40,270 --> 01:56:41,353
我不在乎怎么咳嗽。

2349
01:56:41,353 --> 01:56:43,240
我只是想用止咳的功能。

2350
01:56:43,240 --> 01:56:44,840
而我只是要打电话咳嗽。

2351
01:56:44,840 --> 01:56:46,204
>> 现在，请注意二分法。

2352
01:56:46,204 --> 01:56:49,370
当你调用一个函数，如果你不
想给它输入，完全罚款。

2353
01:56:49,370 --> 01:56:51,780
只要做开括号，接近
括号，就大功告成了。

2354
01:56:51,780 --> 01:56:56,271
>> 当你定义一个函数，或
声明函数的原型，

2355
01:56:56,271 --> 01:56:58,770
如果你事先知道这不是
要采取任何参数，

2356
01:56:58,770 --> 01:57:01,170
说这些括号出现空白。

2357
01:57:01,170 --> 01:57:05,660
这使某些你
会不小心误用。

2358
01:57:05,660 --> 01:57:07,020
让我继续前进，使咳嗽。

2359
01:57:07,020 --> 01:57:08,540
而且，当然，我犯了一个错误。

2360
01:57:08,540 --> 01:57:10,410
>> 该死的，还有那
隐式声明。

2361
01:57:10,410 --> 01:57:11,325
但是，这很好。

2362
01:57:11,325 --> 01:57:12,590
这是一个容易解决。

2363
01:57:12,590 --> 01:57:18,240
我需要的只是原型上涨
在我的文件比我实际使用它。

2364
01:57:18,240 --> 01:57:20,070
>> 所以，现在让我又咳嗽，美观大方。

2365
01:57:20,070 --> 01:57:20,790
现在，它的工作原理。

2366
01:57:20,790 --> 01:57:22,930
让咳，咳，咳，咳。

2367
01:57:22,930 --> 01:57:25,930
所以，你可能会认为我们真的
刚过工程这个问题。

2368
01:57:25,930 --> 01:57:26,763
而且，事实上，我们是。

2369
01:57:26,763 --> 01:57:28,870
这不是一个好
的程序的候补

2370
01:57:28,870 --> 01:57:31,930
在时刻
重构，做什么

2371
01:57:31,930 --> 01:57:35,645
所谓的层次分解，
在这里你需要一些代码，然后

2372
01:57:35,645 --> 01:57:38,790
有种你因子东西出来，这样
归于更多的语义他们，

2373
01:57:38,790 --> 01:57:40,930
和重用它最终长期的。

2374
01:57:40,930 --> 01:57:43,490
但它是一个构建块朝
更复杂的程序

2375
01:57:43,490 --> 01:57:45,600
我们将开始
之前写了长

2376
01:57:45,600 --> 01:57:50,090
让我们有词汇
与写出更好的代码。

2377
01:57:50,090 --> 01:57:52,920
而且，事实上，让我们看看，如果我们
不能一概而论进一步此。

2378
01:57:52,920 --> 01:57:57,984
>> 这似乎有点跛，我，主，
需要担心这个该死的for循环，

2379
01:57:57,984 --> 01:57:59,400
并一再呼吁咳嗽。

2380
01:57:59,400 --> 01:58:03,050
为什么我不能只是告诉咳嗽，
请咳嗽三次？

2381
01:58:03,050 --> 01:58:08,170
换句话说，为什么我不能只是
给输入咳嗽，做到这一点？

2382
01:58:08,170 --> 01:58:11,270
>> 为什么我不能只是说，在
主咳嗽三次。

2383
01:58:11,270 --> 01:58:13,150
而现在，这是种神奇。

2384
01:58:13,150 --> 01:58:14,540
这是非常反复的在这里。

2385
01:58:14,540 --> 01:58:15,940
而且它是，事实上，一个婴儿的一步。

2386
01:58:15,940 --> 01:58:19,250
>> 但就在能力上说，
八号线，咳嗽三次，

2387
01:58:19,250 --> 01:58:20,730
它只是这么多的可读性。

2388
01:58:20,730 --> 01:58:24,210
而且，再加上，我不必知道
或护理咳嗽是如何实现的。

2389
01:58:24,210 --> 01:58:26,460
而且，事实上，在后来的
长期和最终项目，

2390
01:58:26,460 --> 01:58:29,150
如果你处理一个项目
一个同学或两位同学，

2391
01:58:29,150 --> 01:58:32,370
你会意识到，你要
有，或者想，分工。

2392
01:58:32,370 --> 01:58:34,650
>> 而你会想决定
事先，谁去做些什么，

2393
01:58:34,650 --> 01:58:35,483
并在其中部分？

2394
01:58:35,483 --> 01:58:37,520
而不会是好的
如果，例如，

2395
01:58:37,520 --> 01:58:40,100
负责撰写主力，完成。

2396
01:58:40,100 --> 01:58:43,470
而你的室友，或者你
伙伴更一般地，

2397
01:58:43,470 --> 01:58:45,230
负责实施的咳嗽。

2398
01:58:45,230 --> 01:58:49,540
>> 而且这种划分，这些
抽象的墙，

2399
01:58:49,540 --> 01:58:52,310
抽象或层，如果
你会，是超级强大，

2400
01:58:52,310 --> 01:58:55,480
因为特别是较大的，
更复杂的程序和系统，

2401
01:58:55,480 --> 01:59:00,070
它允许多个人建
东西放在一起，最终

2402
01:59:00,070 --> 01:59:02,680
缝合在一起以这种方式工作。

2403
01:59:02,680 --> 01:59:05,332
但是，当然，我们
现在需要解决的咳嗽。

2404
01:59:05,332 --> 01:59:07,290
我们需要告诉咳嗽
，嘿，你知道吗？

2405
01:59:07,290 --> 01:59:11,230
你将需要采取
input--所以并不作废，int和现在。

2406
01:59:11,230 --> 01:59:15,170
让我们继续前进并投入
咳嗽整型。我得到零。

2407
01:59:15,170 --> 01:59:16,890
>> i小于多少倍。

2408
01:59:16,890 --> 01:59:18,550
我以前说过三种。

2409
01:59:18,550 --> 01:59:20,420
但是，这不是我想要的。

2410
01:59:20,420 --> 01:59:25,520
我想咳嗽推广到
支持任何数量的迭代。

2411
01:59:25,520 --> 01:59:28,800
>> 所以，事实上，它是n表示我想，
无论用户告诉我。

2412
01:59:28,800 --> 01:59:31,620
现在，我可以继续说打印咳嗽。

2413
01:59:31,620 --> 01:59:34,750
无论什么号码
用户通过在，

2414
01:59:34,750 --> 01:59:36,890
我会重复很多次。

2415
01:59:36,890 --> 01:59:39,160
>> 这样在一天结束时，
程序是相同的。

2416
01:59:39,160 --> 01:59:42,820
但是请注意，所有的这些东西
甚至可以是在另一文件中。

2417
01:59:42,820 --> 01:59:45,620
事实上，我不知道在
此刻怎么printf的实现。

2418
01:59:45,620 --> 01:59:47,980
>> 我不知道此刻怎么弄
串，或得到int或获得浮动

2419
01:59:47,980 --> 01:59:48,646
的贯彻落实。

2420
01:59:48,646 --> 01:59:50,930
而且我不希望
看到他们我的屏幕上。

2421
01:59:50,930 --> 01:59:55,320
正因为如此，我开始专注于
我的程序，而不是那些功能。

2422
01:59:55,320 --> 01:59:59,070
>> 所以，事实上，只要你
开始分解这样的代码了，

2423
01:59:59,070 --> 02:00:01,397
可能我们连招咳嗽
到一个单独的文件？

2424
02:00:01,397 --> 02:00:02,730
别人可以实现它。

2425
02:00:02,730 --> 02:00:06,810
你和你的程序成为
很漂亮，非常具有可读性，

2426
02:00:06,810 --> 02:00:10,830
可以说，真正的4
行程序就在那里。

2427
02:00:10,830 --> 02:00:13,510
>> 现在让我们继续前进
并作一次改变。

2428
02:00:13,510 --> 02:00:16,180
请注意，我的原型
必须改变往上顶。

2429
02:00:16,180 --> 02:00:18,390
因此，让我解决，这么
我没有得到大声呵斥。

2430
02:00:18,390 --> 02:00:22,580
>> 使咳嗽，让我跑一次咳嗽
更多的，仍然在做同样的事情。

2431
02:00:22,580 --> 02:00:26,010
但现在，看到我们有一个
成分为最后一个版本。

2432
02:00:26,010 --> 02:00:26,940
你知道吗？

2433
02:00:26,940 --> 02:00:29,040
我不希望只是咳嗽，不一定。

2434
02:00:29,040 --> 02:00:30,802
我希望有更多的东西一般。

2435
02:00:30,802 --> 02:00:31,510
所以，你知道吗？

2436
02:00:31,510 --> 02:00:32,450
我想这样做。

2437
02:00:32,450 --> 02:00:37,140
我想有，就像刮
确实，一说块，但不只是

2438
02:00:37,140 --> 02:00:38,680
说些什么的时候一定数目。

2439
02:00:38,680 --> 02:00:41,510
我希望它说一个非常具体的字符串。

2440
02:00:41,510 --> 02:00:43,850
，因此，我不知道
希望它只是说咳嗽。

2441
02:00:43,850 --> 02:00:47,660
我希望它说什么
字符串在通过。

2442
02:00:47,660 --> 02:00:49,960
>> 所以请注意，我全身
这让现在

2443
02:00:49,960 --> 02:00:53,110
比方说感觉就像一个好名字
对于这一点，喜欢从无到有，

2444
02:00:53,110 --> 02:00:55,530
有两个参数，不像划伤。

2445
02:00:55,530 --> 02:00:56,570
之一是一个字符串。

2446
02:00:56,570 --> 02:00:57,300
一个是一个int。

2447
02:00:57,300 --> 02:00:58,130
>> 我可以切换。

2448
02:00:58,130 --> 02:01:00,713
我只是有点像的想法
说字符串，然后再

2449
02:01:00,713 --> 02:01:01,940
多少次以后。

2450
02:01:01,940 --> 02:01:03,970
虚空意味着它仍然
不返回任何东西。

2451
02:01:03,970 --> 02:01:06,428
这些仅仅是视觉方面
效果，像[？乔丹？]

2452
02:01:06,428 --> 02:01:08,240
大呼小叫的口头副作用。

2453
02:01:08,240 --> 02:01:12,630
它仍然做了n次，
0到，但不等于n。

2454
02:01:12,630 --> 02:01:14,540
这意味着全部N次。

2455
02:01:14,540 --> 02:01:16,540
然后只需打印出
无论是字符串。

2456
02:01:16,540 --> 02:01:19,060
所以，我真的全身
这行代码。

2457
02:01:19,060 --> 02:01:22,460
所以，现在，我该如何实现
咳嗽功能？

2458
02:01:22,460 --> 02:01:25,520
>> 我可以做无效咳嗽。

2459
02:01:25,520 --> 02:01:28,501
我仍然可以在如何
你想多次咳嗽。

2460
02:01:28,501 --> 02:01:29,250
但是，你知道吗？

2461
02:01:29,250 --> 02:01:31,240
现在我可以踢的话。

2462
02:01:31,240 --> 02:01:36,540
>> 我可以调用的说
字咳嗽，经过n的。

2463
02:01:36,540 --> 02:01:40,410
如果我想，也能实现，
只是为了好玩，一个喷嚏功能，

2464
02:01:40,410 --> 02:01:42,290
我打喷嚏的时候一定数目。

2465
02:01:42,290 --> 02:01:47,300
我可以继续重用N，因为
注意到在这种情况下或范围是m

2466
02:01:47,300 --> 02:01:49,470
只有在这个函数中存在。

2467
02:01:49,470 --> 02:01:52,767
>> 和N在这种情况下只
这里这个函数中存在。

2468
02:01:52,767 --> 02:01:54,600
因此，我们会回来的
范围这些问题。

2469
02:01:54,600 --> 02:02:01,160
而在这里，我只是说，
ACHOO，然后n倍，分号。

2470
02:02:01,160 --> 02:02:04,340
>> 而现在，我只需要借用
这些功能在这里签名了。

2471
02:02:04,340 --> 02:02:06,290
所以咳嗽是正确的。

2472
02:02:06,290 --> 02:02:10,090
虚空喷嚏现在是正确的。

2473
02:02:10,090 --> 02:02:12,390
>> 我仍然只是需要说。

2474
02:02:12,390 --> 02:02:18,990
所以我要说，说
字符串s，诠释N，分号。

2475
02:02:18,990 --> 02:02:22,010
所以，我已经过度设计的
赫克出这个计划。

2476
02:02:22,010 --> 02:02:23,760
>> 这并不
一定意味着这是

2477
02:02:23,760 --> 02:02:26,343
写作时你应该做的
节目即使是最简单。

2478
02:02:26,343 --> 02:02:29,280
就拿东西是很明显
很简单，真的很短，

2479
02:02:29,280 --> 02:02:31,800
并重新实现它
使用太多的代码。

2480
02:02:31,800 --> 02:02:34,560
但是，你实际看到的，而在
时间回头看这些例子，

2481
02:02:34,560 --> 02:02:38,610
与实现，哦，那些步骤
我们采取了实际一概而论，

2482
02:02:38,610 --> 02:02:40,797
要因素出来的东西，
直到在一天结束

2483
02:02:40,797 --> 02:02:42,380
我的代码实际上是非常合理的。

2484
02:02:42,380 --> 02:02:45,960
因为如果我想咳嗽3
次，然后打喷嚏三次，

2485
02:02:45,960 --> 02:02:50,420
我只是要重新运行此，
计划使咳嗽，并运行咳嗽。

2486
02:02:50,420 --> 02:02:53,620
而且我有三个咳嗽
和三个喷嚏。

2487
02:02:53,620 --> 02:02:55,990
>> 所以这是一个基本的
范例，如果你愿意，

2488
02:02:55,990 --> 02:03:00,110
对于我们如何去
实际执行的程序。

2489
02:03:00,110 --> 02:03:03,220
但是让我们只看到现在是什么
我们一直在做这一切的时候，

2490
02:03:03,220 --> 02:03:06,940
什么一些最终件
这是简单的命令后面。

2491
02:03:06,940 --> 02:03:09,620
在一天结束的时候，我们已经
使用锵作为我们编译了。

2492
02:03:09,620 --> 02:03:11,494
我们一直在写源
代码，将其转换

2493
02:03:11,494 --> 02:03:12,820
通过锵成机器代码。

2494
02:03:12,820 --> 02:03:15,540
>> 而且我们一直在使用刚刚制作
以方便我们这样的击键

2495
02:03:15,540 --> 02:03:20,740
我们不必记住
锵本身的咒语。

2496
02:03:20,740 --> 02:03:22,640
但是，什么是让真正在做什么？

2497
02:03:22,640 --> 02:03:24,750
并且，反过来，是什么
锵实际上做？

2498
02:03:24,750 --> 02:03:28,790
>> 事实证明，尽管我们已经简化
说今天的讨论，

2499
02:03:28,790 --> 02:03:33,090
你把源代码，把它作为
输入一个编译器，它给你

2500
02:03:33,090 --> 02:03:35,750
机的输出
代码，原来有

2501
02:03:35,750 --> 02:03:37,420
里边有几个不同的步骤。

2502
02:03:37,420 --> 02:03:41,940
和编译恰好是伞
术语一大堆的步骤。

2503
02:03:41,940 --> 02:03:43,970
但是，我们只是戏弄
这一点真的很快。

2504
02:03:43,970 --> 02:03:48,070
>> 事实证明，我们一直在做
更多的事情我每次运行一个程序的时候，

2505
02:03:48,070 --> 02:03:50,990
或每次我今天编译程序。

2506
02:03:50,990 --> 02:03:55,020
因此，预处理是指
在C程序this--什么，

2507
02:03:55,020 --> 02:03:58,720
如我们一次又一次地看到，
与此井号开始，

2508
02:03:58,720 --> 02:04:03,320
还是这里的＃标签符号，意味着
这是一个预处理指令。

2509
02:04:03,320 --> 02:04:07,330
这意味着，在这种情况下，喂
计算机，做一些与此文件

2510
02:04:07,330 --> 02:04:09,430
在你真正编译自己的代码。

2511
02:04:09,430 --> 02:04:15,220
>> 在此情况下，散列包括就是
本质上，C的说法方式，

2512
02:04:15,220 --> 02:04:19,325
哎电脑，去获得内容
CS50.h，并将其粘贴在这里。

2513
02:04:19,325 --> 02:04:22,170
嘿电脑，去获得的
标准IO.h的内容，

2514
02:04:22,170 --> 02:04:24,690
无论是在
硬盘驱动器，它贴在这里。

2515
02:04:24,690 --> 02:04:27,390
因此，这些事情发生
预处理时先。

2516
02:04:27,390 --> 02:04:28,880
>> 而锵做这一切对我们来说。

2517
02:04:28,880 --> 02:04:30,510
并且实现起来这么混账
快，你甚至不

2518
02:04:30,510 --> 02:04:32,000
看到四个不同的事情发生。

2519
02:04:32,000 --> 02:04:34,100
但是，这是第一个这样的一步。

2520
02:04:34,100 --> 02:04:35,560
>> 其实什么接下来会发生？

2521
02:04:35,560 --> 02:04:38,320
好了，接下来的正式
一步是编译。

2522
02:04:38,320 --> 02:04:40,385
而事实证明，
编译程序

2523
02:04:40,385 --> 02:04:44,060
技术上意味着从去
源代码，我们已经东东

2524
02:04:44,060 --> 02:04:47,890
今天一直在写，东西
所谓的汇编代码，东西

2525
02:04:47,890 --> 02:04:49,260
看起来有点不同。

2526
02:04:49,260 --> 02:04:51,050
>> 而且，事实上，我们可以真正快速的看到这一点。

2527
02:04:51,050 --> 02:04:53,890
让我真正进入我的IDE。

2528
02:04:53,890 --> 02:04:58,050
让我继续前进，开放的hello.c，这
是第一个程序，使用它我们

2529
02:04:58,050 --> 02:04:59,120
今天开始了。

2530
02:04:59,120 --> 02:05:04,130
让我继续运行锵一
有点不同，锵-S，hello.c中，

2531
02:05:04,130 --> 02:05:07,720
这实际上是要
给我另一个文件hello.s。

2532
02:05:07,720 --> 02:05:10,330
>> 我们可能永远不会
再次看到这种代码。

2533
02:05:10,330 --> 02:05:13,030
如果你把一个较低的水平
系统类像CS61，

2534
02:05:13,030 --> 02:05:14,920
你会看到更多
的这种代码。

2535
02:05:14,920 --> 02:05:17,020
但是，这是汇编语言。

2536
02:05:17,020 --> 02:05:22,050
这是X86汇编语言
这是基本的CPU

2537
02:05:22,050 --> 02:05:24,460
CS50 IDE实际上理解。

2538
02:05:24,460 --> 02:05:27,060
>> 和隐蔽因为它
看，那是什么

2539
02:05:27,060 --> 02:05:29,180
计算机理解得很好。

2540
02:05:29,180 --> 02:05:30,790
子Q，这是一个减法。

2541
02:05:30,790 --> 02:05:31,660
有动作。

2542
02:05:31,660 --> 02:05:35,730
>> 还有的调用函数在这里，
点¯xO形圈，一个动作，一个插件，弹出，

2543
02:05:35,730 --> 02:05:36,430
回报。

2544
02:05:36,430 --> 02:05:38,850
因此，有一些非常
低级别的指令

2545
02:05:38,850 --> 02:05:41,280
该CPU的理解，
我前面提到。

2546
02:05:41,280 --> 02:05:43,100
这就是英特尔内部。

2547
02:05:43,100 --> 02:05:45,030
>> 有模式
零和一其

2548
02:05:45,030 --> 02:05:51,800
映射到这些措辞arcanely，但
有些良好的命名，说明，

2549
02:05:51,800 --> 02:05:52,780
可以这么说。

2550
02:05:52,780 --> 02:05:54,780
那是发生在什么
您编译代码。

2551
02:05:54,780 --> 02:05:58,560
你得到总成
语言出来，这

2552
02:05:58,560 --> 02:06:04,680
装置的第三个步骤是组装
该汇编代码进入，最终，

2553
02:06:04,680 --> 02:06:09,080
机代码 - 零和一，而不是
文本刚才我们看到刚才。

2554
02:06:09,080 --> 02:06:13,370
>> 因此，预处理这是否找到
和替换，以及一些其他的东西。

2555
02:06:13,370 --> 02:06:16,430
编译把你的源代码
从C代码，源代码

2556
02:06:16,430 --> 02:06:18,980
我们写的，到组装
代码，我们只是看了一眼。

2557
02:06:18,980 --> 02:06:22,170
组装需要该程序集
码到零和一

2558
02:06:22,170 --> 02:06:24,680
该CPU真的会
理解在一天结束。

2559
02:06:24,680 --> 02:06:27,630
和链接是最后一步
出现这种情况的再次us--，

2560
02:06:27,630 --> 02:06:29,830
如此之快，我们甚至不
notice--，上面写着：

2561
02:06:29,830 --> 02:06:32,460
哎电脑，采取所有的
在零和一的

2562
02:06:32,460 --> 02:06:36,750
源于编译大卫的代码，
和他在这种情况下，主要的功能。

2563
02:06:36,750 --> 02:06:39,160
>> 哎电脑，去获得
所有的零和一

2564
02:06:39,160 --> 02:06:42,180
该工作人员CS50写道：
在CS50库内。

2565
02:06:42,180 --> 02:06:43,440
混合那些与大卫的。

2566
02:06:43,440 --> 02:06:46,648
哎电脑，去获得所有的零
和那些别人写了几年

2567
02:06:46,648 --> 02:06:47,470
以前像printf。

2568
02:06:47,470 --> 02:06:49,880
而这些添加进
整个事情，让我们已经

2569
02:06:49,880 --> 02:06:52,870
得到了我的零和一的
CS50员工的零和的，

2570
02:06:52,870 --> 02:06:55,370
printf的的零和一，
和我们使用其他任何东西。

2571
02:06:55,370 --> 02:07:00,410
>> 它们都能够结合在一起成一个
程序调用，在这种情况下，喂。

2572
02:07:00,410 --> 02:07:03,141
所以，从今以后，我们将只
用这个词编译。

2573
02:07:03,141 --> 02:07:06,390
我们会理所当然地认为，当
我们说，编译你的程序，这意味着，

2574
02:07:06,390 --> 02:07:08,849
哎做预处理，
汇编和连接。

2575
02:07:08,849 --> 02:07:11,890
但实际上有一些多汁的东西
对那里发生的引擎盖下面。

2576
02:07:11,890 --> 02:07:13,723
特别是如果你
让好奇的一段时间，

2577
02:07:13,723 --> 02:07:15,900
你可以开始戳
围绕在这个较低的水平。

2578
02:07:15,900 --> 02:07:19,660
但是现在，意识到
在外卖今天之一

2579
02:07:19,660 --> 02:07:23,420
是很简单的
开始的过程中，

2580
02:07:23,420 --> 02:07:26,700
越来越舒服的
类似的hello world。

2581
02:07:26,700 --> 02:07:29,575
事实上，大多数的我们今天做了
当然不会下沉超快。

2582
02:07:29,575 --> 02:07:31,491
它会采取一些
时间，以及一些实践。

2583
02:07:31,491 --> 02:07:33,864
赔率是，你将整理
的想打你的键盘

2584
02:07:33,864 --> 02:07:34,780
或者在屏幕大喊大叫。

2585
02:07:34,780 --> 02:07:35,880
而所有的这行。

2586
02:07:35,880 --> 02:07:38,320
不过，也许是尽量不要
这样做在图书馆这么多。

2587
02:07:38,320 --> 02:07:40,820
>> 最终，你会
被能够虽然，以启动

2588
02:07:40,820 --> 02:07:44,580
眼看模式，无论是在好的代码
你写在错误

2589
02:07:44,580 --> 02:07:45,370
你所做的。

2590
02:07:45,370 --> 02:07:48,965
和很像的过程
成为一个TF或CA是什么样子，

2591
02:07:48,965 --> 02:07:51,590
你会开始变得更好，
在看到这些模式比较好，

2592
02:07:51,590 --> 02:07:53,774
和公正的解决您的
自己的问题最终。

2593
02:07:53,774 --> 02:07:56,940
在此期间，将有大量
我们借给你们的支持，让你

2594
02:07:56,940 --> 02:07:57,481
通过这个。

2595
02:07:57,481 --> 02:07:59,450
而在写窗口
对于所有的问题

2596
02:07:59,450 --> 02:08:01,366
你会通过引导
所有的命令

2597
02:08:01,366 --> 02:08:05,330
我当然知道，从
现在大量的实践，

2598
02:08:05,330 --> 02:08:07,380
但可能已飞过
在一个人的头了。

2599
02:08:07,380 --> 02:08:08,580
这是完全的罚款。

2600
02:08:08,580 --> 02:08:11,230
>> 但是，最终，你会
开始看到的模式出现。

2601
02:08:11,230 --> 02:08:14,260
而一旦你过去所有的
愚蠢的细节，比如括号，

2602
02:08:14,260 --> 02:08:16,710
和大括号和分号，
和东西，坦率地说，

2603
02:08:16,710 --> 02:08:19,360
这不是在所有的
智力有趣。

2604
02:08:19,360 --> 02:08:22,690
它不是客观
服用任何入门级。

2605
02:08:22,690 --> 02:08:24,410
它是将要事情的想法。

2606
02:08:24,410 --> 02:08:26,659
>> 它的循环，而
条件，以及功能，

2607
02:08:26,659 --> 02:08:30,552
和更有力的抽象，
与上面的代码保理，

2608
02:08:30,552 --> 02:08:33,510
和良好的设计，以及良好的
风格，最终的正确性

2609
02:08:33,510 --> 02:08:37,330
你的代码，这是最终
事情影响最大。

2610
02:08:37,330 --> 02:08:40,925
所以下周，我们将采取以下
想法，我们第一次看到划痕

2611
02:08:40,925 --> 02:08:42,800
现在已经翻译
到C.我们将开始

2612
02:08:42,800 --> 02:08:45,740
引进第一的
当然，真实世界的领域。

2613
02:08:45,740 --> 02:08:50,140
>> 我们将专注于安全领域，
更具体密码学，

2614
02:08:50,140 --> 02:08:51,980
艺术扰码信息。

2615
02:08:51,980 --> 02:08:54,000
和第一批
你自己的问题，你

2616
02:08:54,000 --> 02:08:56,840
将得到超越写
与一些语法的打

2617
02:08:56,840 --> 02:08:59,880
和解决一些逻辑
问题，最终没多久，

2618
02:08:59,880 --> 02:09:03,960
是真正争我夺，或加密，
并最终解密信息。

2619
02:09:03,960 --> 02:09:06,470
而我们所做的一切
今天，将相当低

2620
02:09:06,470 --> 02:09:09,190
的水平，只是要允许
我们采取之一，和一，

2621
02:09:09,190 --> 02:09:13,550
以上朝着一个步骤
写作最有趣的代码呢。

2622
02:09:13,550 --> 02:09:15,050
>> 因此，更多的是在下周。

2623
02:09:15,050 --> 02:09:17,834

2624
02:09:17,834 --> 02:09:18,762
>> [视频回放]

2625
02:09:18,762 --> 02:09:19,690

2626
02:09:19,690 --> 02:09:22,006
>>  - 什么，你能告诉我
您看见他是什么时候？

2627
02:09:22,006 --> 02:09:26,041

2628
02:09:26,041 --> 02:09:27,040
 - 什么我可以说，真的吗？

2629
02:09:27,040 --> 02:09:30,500

2630
02:09:30,500 --> 02:09:35,340
我的意思是，它像任何其他
生产前的排练，

2631
02:09:35,340 --> 02:09:40,510
但有些事情，他说
在最后与我卡住了。

2632
02:09:40,510 --> 02:09:44,810

2633
02:09:44,810 --> 02:09:46,640
>>  - 这是CS50。

2634
02:09:46,640 --> 02:09:49,440

2635
02:09:49,440 --> 02:09:52,190
>>  - 那是一个切大家，
在排练伟大的工作。

2636
02:09:52,190 --> 02:09:53,070
>>  - 这就是午餐？

2637
02:09:53,070 --> 02:09:54,986
>> 是啊，你和我可以
抢位三明治。

2638
02:09:54,986 --> 02:09:58,380
我只是听取汇报
大卫真的很快。

2639
02:09:58,380 --> 02:09:59,160
大卫？

2640
02:09:59,160 --> 02:10:01,260
大卫？

2641
02:10:01,260 --> 02:10:03,110
>> [结束播放]

