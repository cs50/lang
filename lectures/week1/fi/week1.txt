[MUSIIKKIA] DAVID J. MALAN: Selvä, tämä on CS50. Ja tämä on viikolla yksi. Niin muistaa, että viimeisen kerran viikolla nolla, keskityimme päättelyä. Ja me siirtynyt kuin se, Scratch, graafinen ohjelmointi kieli ystävämme MIT: n Media Lab. 

Ja Scratch, teimme tutkia ajatuksia, kuten toiminnot, ja olosuhteet, ja silmukat ja muuttujia, ja jopa tapahtumia, ja langat, ja enemmän. Ja tänään, aiomme jatkaa näitä ideoita, ja todella ottaa niitä myönnetty, mutta kääntää ne toiselle kielelle tunnetaan C. Nyt, C on perinteisempi kieltä. Se on alemmalla tasolla kieli, jos haluatte. 

Se on puhtaasti tekstimuodossa. Ja niin ensi silmäyksellä, se on kaikki tulee näyttämään varsin arvoituksellinen jos et ole koskaan ohjelmoida ennen. Aiomme olla puolipistettä, ja suluissa, ja aaltosulkei-, ja enemmän. Mutta ymmärtää, että vaikka vaikka syntaksi on noin näyttää hieman tuntemattomia useimpiin teistä, katso aiemmin, että. Ja yrittää nähdä ideoita jotka ovat todellakin tuttu, koska täällä viikolla yhdessä mitä alamme tehdä on vertailla, aluksi, Scratch versus C. 

Niinpä esimerkiksi, muistaa, että kun me toteutetaan ensimmäinen ohjelmiemme viimeksi meillä oli lohko, joka näytti vähän jotain tämän kaltaisia ​​osia, kun Vihreä lippu napsautetaan, ja sitten meillä oli yksi tai useampi palapelin palaset sen alapuolella, tässä tapauksessa sanoa, hei maailma. Joten todellakin Scratch, kun klikkaa että Vihreä lippu ajaa minun ohjelma, niin puhumaan, nämä ovat lohkot saavat toteutettu, tai juosta. Ja erityisesti, Scratch sanoi, hei, maailma. 

Nyt olen voinut määritellyt eri sanoja täällä. Mutta saa nähdä, että todellakin, monet Näiden blocks-- ja todellakin C monet functions-- voi olla parametrized tai räätälöityjä tehdä eri asioita. Itse asiassa C jos haluat muuntaa, nyt, Tämän Scratch-ohjelma Tämän muuta kieltä, aiomme kirjoittaa vähän jotain tällaista. 

Myönnettäköön, on jonkin verran tuntemattomia syntaksin siellä todennäköisesti, int, ja suluissa, ja mitätön. Mutta printf-- vaikka olisit sitä mieltä, että olisi vain tulostaa. Mutta print tarkoittaa print alustettu, kuten tulemme pian nähdä. Tämä kirjaimellisesti tulostaa näytölle tahansa on sisällä niitä sulkuja, jotka tietenkin tässä tapauksessa on, Hello World. 

Mutta huomaat joitakin muita syntaksi, jotkut lainausmerkkeihin, että suluissa lopussa, semi-paksusuolen ja vastaavat. Joten siellä on hieman yläpuolella, niin sanotusti sekä kognitiivisesti ja syntaktisesti, että aiomme täytyy muistaa ennen pitkää. Mutta ymmärtää, että käytäntöä, tämä alkaa hyppää ulos sinua. 

Itse asiassa, nyt keskittyä, että yksi toiminto specifically-- tässä tapauksessa, tervehtimään maailmassa. Sano on funktio. Hello world on sen parametri, tai argumentti, sen räätälöinnin. 

Ja vastaavuuden C on vain olemaan tämä rivi täällä, missä printf vastaa, sanoa, kaksinkertainen lainattu merkkijono, hei maailma on vastaava, tietenkin, ja mitä on valkoisen laatikon siellä. Ja kenoviivan n, vaikka hieman outoja ja poissa Scratch, yksinkertaisesti tulee olemaan vaikutusta me will katso tietokoneessa, kuten Mac tai PC, vain siirtämällä kursori seuraavalle riville. Se on kuin lyödä Enter-näppäintä. 

Niinpä näemme, että uudelleen ennen pitkää. Mutta ensin katsomaan tätä Toinen esimerkki tapauksessa silmukoita. Meillä oli tämä ikuisesti silmukan viimeinen kerta, joka oli sarja palapelin palaset että teki jotain kirjaimellisesti forever-- tässä tapauksessa, sanoa, hei maailma, hello world, Hello World, Hello World. Joten se päättymättömään silmukkaan virhe. 

In C, jos haluamme toteuttaa tämän Sama ajatus, voisimme yksinkertaisesti tehdä. Vaikka totta, printf hei world-- nyt kun taas vain semanttisesti, millaisia loihtii ajatus tehdä jotain uudestaan ​​ja uudestaan, ja uudestaan, ja kuinka kauan? No, true-- muistuttaa, että totta on pelkästään tai yhdessä. 

Ja totta on, tietenkin, aina totta. Joten se on tavallaan merkityksetön lausuma vain sanoa totta. Mutta tosiaan, tämä on tarkoituksellista, sillä jos totta on vain aina totta, kuin vaikka totta vain merkitsee, jos hieman epäsuorasti, että seuraava riviä koodia välillä ne aaltosulkeita pitäisi vain suorittaa uudestaan, ja uudestaan, ja uudelleen, ja koskaan todella lopettaa. 

Mutta jos et halua loop lopettaa, koska me viime kerralla kanssa jotain Tämän, toista seuraavat 50 kertaa, C voimme tehdä saman mitä kutsutaan varten loop-- avainsanan ei ole aikaa, mutta varten. Ja sitten meillä on joitakin uusia syntaksin täällä, int i on yhtä kuin 0, i alle 50, i ++. Ja palaamme siihen. Mutta tämä on yksinkertaisesti kuinka olisimme kääntää joukko Scratch lohkojen joukolle C riviä koodia. 

Samaan aikaan, harkitse muuttujia. Ja itse asiassa, me vain Näin yhden hetki sitten. Ja kun kyseessä on Scratch, jos me halusi julistaa muuttuja nimeltä i i on kokonaisluku, vain numero, ja haluamme asettaa sen jotain arvoa, me käyttää tätä oranssi lohko here-- asetetaan i 0. 

Ja näemme tänään pidemmälle, aivan kuten viime viikolla, ohjelmoijat tekevät melkein aina alkaa laskea nollasta, oikeastaan sopimuksen mukaan. Vaan myös siksi, hae keskustelumme binary, pienin määrä voit edustavat minkä tahansa määrän bittejä on vain olemaan 0 itseään. Ja niin me yleensä alkaa alustetaan jopa meidän muuttujia 0. 

Ja C tekemään samoin, aiomme sanoa int kokonaisluku, en vain sopimuksen mukaan. Voisin ovat kutsuneet tätä muuttujaa mitä haluan, kuten Scratch. Ja sitten on yhtä kuin 0 vain valtuutettuja arvo 0 oikealta ja ottaa sen muuttujan, tai säilytysastia siellä, vasemmalla. Ja puolipistettä kuten me see-- ja olemme nähneet muutamia näistä already-- tarkoittaa vain loppuun ajatuksen. Jatka tehdä jotain muuta viivoille, jotka seuraavat. 

Nyt entä Boolen ilmaisuja? Muista, että Scratch, nämä olivat ilmaisuja jotka ovat joko totta tai false-- kysymyksiä, todella, jotka ovat joko tosi tai epätosi. Joten jos kyseessä on Scratch, voisimme esittää yksinkertaisen kysymyksen näin, on i alle 50? Joten i, jälleen, on kokonaisluku. Ehkä käytämme sitä joka Scratch-ohjelma seurata pisteet Tai jotain sellaista. Joten tämä syntaksin täällä Scratch vain tarkoittaa, on i alle 50? No, onneksi jotain on yksinkertaisia ​​C. Ja kääntää, Tässä me yksinkertaisesti sanoa i vähemmän yli 50, tutuilla avaimen näppäimistöllä. 

Sillä välin, jos halusi sanoa jotain yleisempää, kuin hyvin, on x alle y, jossa kukin x ja y ovat itse muuttujia? Voimme tehdä sama asia C, kunhan olemme luoneet nämä muuttujat jo. Ja näemme, miten tehdä ennen pitkää. Haluamme yksinkertaisesti sanoa x vähemmän kuin y. 

Joten olet alkanut katso joitakin yhtäläisyyksiä. Ja ne ihmiset, jotka ovat tehneet Scratch olivat varmasti innoittamana joitakin näistä perusajatuksia. Ja näet tällaista syntaksin monissa languages-- ei vain Scratch, ei juuri C, mutta Python, ja JavaScript, ja muita kieliä vielä. 

Tarkastellaan toinen konstruktio C: ltä, käsitteestä ehdon, tekemässä jotain ehdollisesti. Jos jokin on totta, tehdä tämä. Jos jotain muuta on totta, tehdä. Se on eräänlainen ohjelmointi vastine tienhaaraan. Ehkä se on kaksisuuntainen haarukka, kolmitie haarukka, tai enemmän. Ja Scratch, olisimme nähnyt jotain tällaista. 

Eli tämä on iso. Mutta pitävät suhteellisen yksinkertaisuus logiikan. Jos x on pienempi kuin y, niin sano x on pienempi kuin y, muuta, jos x on suurempi kuin y, sitten sanoa x on suurempi kuin y. Ja sitten, loogisesti, jos luulet takaisin Scratch tai vain oman ihmisen intuitio, hyvin, jos x ei ole suurempi kuin y ja x ei ole pienempi kuin y, niin tietenkin x tulee olemaan yhtä kuin y. Joten tässä tapauksessa, jonka pesintä nämä Scratch lohkot, voimme saavuttaa kolme tapa tienhaaraan? 

Samalla jos haluamme tehdä sen C, se luultavasti näyttää hieman simpler-- ainakin kun saat perehtynyt syntaksia. Jos x on pienempi kuin y, printf x on pienempi kuin y. Else jos x on suurempi kuin y, printf x on suurempi kuin y. Else printf x on yhtä suuri kuin y-- ja, jälleen, kanssa kenoviiva päättyy juuri näitä uusia rivejä niin, että jos oikeastaan ​​juoksi tällaista ohjelmaa se vain siirtää kohdistin lopulta seuraavalle riville näytön. 

Nyt puolestaan ​​Scratch ollut muita kehittyneempiä ominaisuuksia, vain joista osa aiomme aluksi siirtyä maailmaan C. Ja yksi niistä oli kutsutaan listan Scratch. Ja tämä oli erityinen tyyppinen muuttuja sallittu voit tallentaa useita asioita se takaisin, takaisin, takaisin, takaisin. 

C, sillä ei ole luetteloita, sinänsä, mutta jotain jotka ovat yleisesti nimeltään paneelit, vaikka me palata myöhemmin tämän lukukauden katsomalla jotain kutsutaan lista, tai oikeastaan ​​linkitetty lista. Mutta nyt, lähin vastaava C meille tulee olemaan jotain kutsutaan jono. Ja joukko on yksinkertaisesti erityinen muuttuja jonka avulla voit tallentaa tietoja takaisin, takaisin, takaisin, takaisin. 

Ja todellakin, Scratch, jos halusimme päästä ensimmäinen osa array tai list-- ja aion kutsua sitä, Sopimuksen mukaan argv, argumentti vektori, mutta siitä lisää ennen pitkää. Jos Haluan saada ensimmäisen elementin of argv, maailmassa Scratch te itse tehdä yleensä aloita laskien 1. 

Ja niin voisin saada erä 1 argv. Se, miten MIT toteutettu käsite listojen. Mutta C, aion yksinkertaisemmin vain sanoa, argv, joka taas on nimi minun list-- tai olla selvää, jono. Ja jos haluan ensimmäisen elementtejä, aion käyttää hakasulkeissa johon ehkä ei usein alle näppäimistön. 

Mutta 0 tarkoittaa vain, saada minulle ensimmäinen. Joten välillä ja Ajan myötä aiomme alkaa nähdä nämä dikotomioiden välillä Scratch ja C, jolloin Scratch käyttää yhtä. Me C käyttää 0 täällä. Mutta voit nopeasti nähdä kun ymmärrät perustan jokaisen kielen, joka nämä asiat alkavat saada sitäkin tuttuja käytännön kautta ja käytäntö. 

Joten todella näyttävät nyt ohjelmaa. Tässä on ensimmäinen meidän C lähdekoodi täydellistä ohjelmia. Ja ohjelma aiomme tarjottavaa vastiketta on yksi, joka on vastaava kyseiseen aiemmin Scratch pala. 

Joten täällä, meillä on mitä luultavasti yksinkertaisin C-ohjelma voit kirjoittaa, että todella tekee jotain. Nyt me näkemättä, nyt, on muun muassa, vakio io.h, ja nämä kulma suluissa, ja int ja tyhjä, ja aaltosulkumerkkien ja vastaavat. 

Ja Haluan vain keskittyä mitä, ainakin intuitiivisesti, ponnahtavat ulos sinua jo. Itse tärkein, en välttämättä tiedä, mitä tämä on, mutta aivan kuten Scratch oli, että kun Vihreä lippu napsautetaan palapelin pala, niin tekee C ohjelmointikielellä on tärkein koodinpätkä, joka saa suorittaa oletusarvoisesti. Ja, todellakin, se kirjaimellisesti aiotaan kutsua main. 

Joten tärkein on funktio. Ja se on erityinen toiminto, joka on olemassa C, että kun käynnistää ohjelman se on tärkein, joka saa hoitaa oletuksena. Kun maailma Scratch, se oli yleensä silloin, kun vihreä lippu napsautetaan, joka sai käynnistetään oletusarvona. 

Samalla olemme nähneet tämän ennenkin, printf tai tulostaa muotoiltu, se olemaan funktio mukana C, sekä koko joukko muita, että tulee aika ja aika uudelleen, jotta tekemään juuri nimensä, tulostaa jotain. Mitä haluat tulostaa? No, näemme, että sulkemalla merkkiä kuten these-- Hello World, kenoviiva n lainausmerkkeihin, voimme kertoa printf tarkalleen mitä tulostaa ruudulla. 

Mutta jotta tehdä että, valitettavasti otettava jotain, joka on jo arvoituksellinen meille ihmisille, mutta ainakin se on hieman readable-- terävä sisältävät, standardi io.h, int, main, mitätön, printf, kaikki maaginen loitsut me juuri nähnyt ruudulla. Mutta meidän oikeastaan ​​tarvitse mennä enemmän mystistä edelleen. Meidän täytyy ensin kääntää koodia kirjoittaisimme konekielelle. Ja muistaa viime viikolla, että koneet, ainakin ne tiedämme täällä, lopussa päivän ainoa ymmärtää nollia ja ykkösiä. 

Ja minun Jumalani, jos olisimme kirjoittaa nämä nollia ja ykkösiä itse ohjelmaan, se olisi hyvin, hyvin nopeasti ottaa hauskaa pois mitään. Mutta näyttää siltä, ​​per viime viikolla, että nämä kuviot nollia ja ykkösiä vain on erityinen merkitys. Tietyissä yhteyksissä, ne saattavat merkitä numeroita. 

Joissakin yhteyksissä, he saattavat merkitä kirjaimia, tai väreihin tai useita Muiden abstraktioita siinä sen. Mutta aivan kuten tietokoneessa on CPU, Central Processing Unit, tai aivot tietokoneesi sisälle. Se on yleensä Intel sisällä, koska se on yksi suurimmista yrityksistä joka tekee suorittimia tietokoneita. 

No, Intel prosessorit ja muut yksinkertaisesti ovat päättäneet etukäteen että tietyt kuviot nollien ja niistä tarkoittaa tiettyjä asioita. Tiettyjä uusia nollia ja ykkösiä tarkoittaa, tulostaa näyttöön, tai lisätä nämä kaksi lukua, tai vähentää nämä kaksi lukua, tai siirtää tämä pala tiedot minun tietokoneen muistiin tänne, tai useita muita erittäin alhainen, mutta lopulta hyödyllinen, toimintaa. Mutta onneksi me ihmiset eivät aio tarvitse tietää tämä taso. Todellakin, aivan kuten viime kerralla, jossa hajamielinen uudestaan ​​ja uudestaan, ja uudestaan, rakennus hyvin alhainen primitives kuten nollia ja ykkösiä korkeamman tason käsitteitä kuten numeroita ja kirjaimia, ja värit, ja lisää, jotta voimme kuin ohjelmoijat seistä harteille muita, jotka ovat tulleet ennen meitä ja käyttää ohjelmistoa, että muut ihmiset ovat kirjoittaneet ennen us-- nimittäin ohjelmia kutsutaan kääntäjiä. 

C on kieli, on yleensä koottu, joka tarkoittaa muunnettu lähdekoodi konekielelle. Erityisesti mitä tämä tarkoittaa on, että jos olet saanut lähde koodi, joka itse kirjoittaa, koska me pian tulee aivan hetken ruudulla, ja haluat muuntaa sen lopulta kone code-- ne nollia ja ykkösiä, jotka vain Mac- tai PC understands-- sinulla ensimmäinen ruokkia että lähdekoodi kuin tulo erityiseen ohjelma nimeltä kääntäjä, jonka lähtö me on näet on konekielelle. Ja todellakin, viimeksi puhuimme noin, todella, lopussa päivä, ongelmanratkaisu. Sinulla tuloa. Ja olet saanut lähdöt. Ja olet saanut jonkinlaista algoritmin keskellä. 

Algoritmit voivat varmasti ohjelmistossa, kuten näimme kanssa pseudokoodina viime viikolla ja kuten näemme todellisia koodia Tämä viikko. Ja niin kääntäjän oikeastaan ​​vain on joukko algoritmeja sisällä siitä, että osaavat muuntaa erityinen avainsanoja, kuten tärkein, ja printf, ja muut, jotka olemme juuri Näin osaksi malleja nollia ja ne, jotka Intel sisällä ja muita suorittimia todella ymmärtää. Miten teemme tämän? Mistä saamme kääntäjä? 

Useimmat meistä täällä on Mac tai PC. Ja käytät Mac OS, tai Windows tai Linux tai Solaris, tai useita muita käyttöjärjestelmät. Ja todellakin, voisimme mennä ulos radalle ja lataa kääntäjä Mac- tai PC juuri sinun käyttöjärjestelmään. Mutta me kaikki olla eri sivuja, niin sanotusti. Meidän täytyisi hieman eri kokoonpanoissa. Ja asiat eivät toimi kaikille sama. Ja, todellakin, näinä päivinä monet meistä eivät käytä ohjelmisto, joka toimii vain meidän läppäreissä. Sen sijaan käyttää jotain kuten selaimen, joka pystymme käyttämään web-pohjainen sovellukset pilvessä. Ja myöhemmin tämän lukukauden, teemme juuri näin. Me kirjoittaa sovelluksia tai ohjelmistoa käyttäen code-- ei C, mutta muita kieliä, kuten Python ja JavaScript-- jotka kulkevat pilvessä. 

Ja tehdä niin, me itse lukukauden aikana todella käyttää pilvipohjaisen ympäristö tunnetaan CS50 IDE. Tämä on web-pohjainen ohjelmointi ympäristö, tai yhtenäinen kehittäminen ympäristö, Ide, joka on rakennettu huipulla joitakin avoimen lähdekoodin ohjelmistoja kutsutaan Cloud 9. Ja olemme tehneet joitakin pedagogisia yksinkertaistuksia se jotta salata tiettyjä ominaisuuksia, ensimmäisten viikkojen emme tarvitse, jonka jälkeen voit paljastavat heitä ja useimmat mitä haluat ympäristön kanssa. 

Ja se antaa meille myös, että esiasenna tiettyjä ohjelmistoja. Asioita, kuten ns CS50 kirjasto, josta pian nähdä antaa meille C joidenkin lisätoimintoja. Joten jos menet lopulta CS50.io, sinua pyydetään kirjautumaan sisään, ja kun teet ja luoda tilin ilmaiseksi, voit jolla siirrytään ympäristö, joka näyttää aivan näin. 

Nyt tämä on oletustila. Kaikki on mukavaa ja kirkas ruudulla. Monet meistä on tapana työskentelevät CS50 pala, joka on melko myöhään yöhön. Ja niin jotkut ehkä mieluummin muuttaa sen Yökäyttötilassa niin sanotusti. 

Mutta lopulta, mitä olet näkemään sisällä CS50 IDE on kolme erillistä areas-- alue vasemmalla, jossa tiedostot ovat menossa olevan pilvi, alue ylhäällä oikealla jossa koodi tulee olemaan muokattavissa. Voit avata yksittäisiä välilehtiä mihinkään ohjelmaan että kirjoitat tämän lukukauden sisällä Kyseisen oikeassa yläkulmassa. Ja sitten useimmat arcanely, ja vielä voimakkaasti, tulee olemaan tämä asia on pohja tunnetaan pääteikkunaan. 

Tämä on vanha koulu Command Line Interface, tai CLI, joka sallii voit suorittaa komentoja on computer-- tässä tapauksessa tietokone uudelleen cloud-- tehdä asioita, kuten kääntää koodia lähdekoodista konekielelle, ajaa ohjelmia, tai aloittaa web-palvelin, tai päästä käsiksi tietokantaan, ja useita muita tekniikoita että aloitamme käyttää ennen pitkää. Mutta sinne, olemme menossa oikeastaan mennä verkossa ja aloittaa pelaamisen. Ja tehdä niin, nyt ensimmäinen aloittaa puuhastelun kanssa tärkein, ja kirjoittaa pääosan ohjelmaa. Ja nyt käyttää tätä toimintoa printf, jota käytimme aiemmin, yksinkertaisesti sanoa jotain. 

Joten tässä olen jo sisällä CS50 IDE. Olen kirjautunut etukäteen. Ja minä täysin seulotaan ikkunan. Ja niin, lopulta, sinun Myös tulevina ongelmia seuraa samanlainen vaiheita, tarjoaa online-dokumentaatio. Joten sinun ei tarvitse huolehtia imevää jokainen pieni tekninen askel että en tänään. 

Mutta saat seuraavanlaisen näytön. Satun olemaan yötilassa. Ja voit kirkastaa kaiken up poistamalla yötila. Ja lopussa on päivä, olet menossa nähdä nämä kolme areas-- tiedosto selain vasemmalla, koodi välilehdet ylös, ja pääteikkuna alareunassa. 

Anna minun mennä eteenpäin ja kirjoittaa ensimmäinen ohjelma. Aion ennaltaehkäisevästi mene File, Save, ja pelastaa minun tiedosto hello.c. Itse Sopimuksen mukaan mitään ohjelmaa me kirjoitus, joka on kirjoitettu C-kielellä tulee nimetä jotain piste c, sopimuksen mukaan. Joten aion nimetä sen hello.c, koska Haluan vain sanoa hei maailmaan. Nyt aion zoomata ulos ja sitten Tallenna. Ja kaikki Minulla on tässä nyt on välilehti jossa voin alkaa kirjoittaa koodia. 

Tämä ei aio koota. Tämä ei tarkoita mitään. Ja joten vaikka I muunnetaan tämä nollia ja ykkösiä, CPU tulee ole idea, mitä tapahtuu ympärillä. Mutta jos kirjoitan radoilla, jotka eivät täsmää kanssa C: n conventions-- C olento, uudelleen, tämä language-- kanssa syntaksi kuten Tämän printf hei world-- ja olen mennyt mukava Näin ajan mittaan. Joten en usko tein tahansa painovirheitä. 

Mutta, poikkeuksetta, ensimmäinen aika teet tämän, et. Ja mitä aion tehdä ehkä kovin hyvin toimi sinulle ensimmäistä kertaa. Ja se on täysin OK, koska juuri nyt te voi vain nähdä paljon uutuuden, mutta ajan mittaan kun saat tuttuja Tämän ympäristöön, ja tällä kielellä, ja toiset, voit alkaa nähdä asioita, ovat joko oikea tai väärä. 

Ja tämä on mitä opetus kaverit ja kurssi avustajat saada niin hyvä ajan, on tiputtelua virheitä tai vikoja koodissa. Mutta Väitän, että siellä Ei vikoja tämän koodin. Joten Haluan nyt ohjelman suorittamiseen. 

Nyt yksin Mac- tai PC, olen tapana kaksoinäpäyttämällä kuvakkeita kun haluan ajaa joitakin ohjelmaan. Mutta se ei ole täällä mallin. Tässä ympäristössä, joka on CS50 IDE. Olemme käyttöympäristön nimeltään Linux. Linux muistuttaa toinen käyttöjärjestelmä, yleisesti tunnettua kuten Unix. Ja Linux tunnetaan erityisesti jonka Command Line Ympäristö, CLI. Nyt käytämme tiettyä maku Linux kutsutaan Ubuntu. Ja Ubuntu on yksinkertaisesti tietyt versio Linux. 

Mutta nämä Linuxin näinä päivinä tehdä todella tulevat graafisia käyttöliittymiä. Ja yksi satumme käyttää tässä web-pohjainen. Joten tämä voisi näyttää jopa hieman erilainen kuin jotain itse voisi olla nähnyt tai ajaa ohi. 

Joten aion mennä eteenpäin nyt ja toimi seuraavasti. Olen tallentanut tämä kuva hello.c. Aion mennä eteenpäin ja tyyppi clanghello.c Niin Clang että C-kieli on kääntäjä. Se valmiiksi asennettuna CS50 IDE. Ja voit ehdottomasti ladata ja asentaa tämän itse Mac tai PC. 

Mutta jälleen kerran, sinun ei tarvitse kaikkia esikokoonpano tehty. Joten nyt, olen vain aikoo juosta clanghello.c. Ja nyt huomaa syntaksin tässä lopulta ymmärtää vain sitä, että minulla on kansion tai hakemiston nimeltä Työtila. Tämä dollarin merkki on vain yleissopimus for merkitys, kirjoita komennot täällä. 

Se, mitä kutsutaan nopea, vain sopimuksen mukaan on dollarin merkki. Ja jos menen eteenpäin nyt ja valitse Anna, mikään ei tunnu tapahtuneen. Mutta se on itse asiassa hyvä asia. Mitä vähemmän, mikä tapahtuu näytön, sitä todennäköisemmin koodi on olla oikea, ainakin syntaktisesti. 

Joten jos haluan suorittaa tämän ohjelma, mitä teen? No, käy ilmi, että oletusnimi sopimuksen mukaan ohjelmia kun et määritä Nimeä ohjelma on vain a.out. Ja tämä syntaksi liian, luultavasti tutustua ennen pitkää. 

Dot slash tarkoittaa vain, hei, CS50 IDE, suorita ohjelma nimeltä a.out se sisällä minun hakemistossa. Tämä piste tarkoittaa nykyisen hakemiston. Ja näemme, mitä muut tällaiset sekvenssit Merkkien merkitsee ennen pitkää. 

Joten tässä sitä mennään, Enter, Hello World. Ja huomaat, että mitä tapahtui? Se ei ainoastaan ​​tulostaa Hello World. Se myös muutti kursori seuraavalle riville. 

Ja miksi se oli? Mikä oli koodi että me kirjoitti ennen että varmistetaan, että kursori siirry seuraavalle riville? Hassua noin tietokone on se vain menee tehdä kirjaimellisesti mitä kerrot sitä tekemään. 

Joten jos kerrot sen printf hei, pilkku, avaruus, maailma, lähellä lainaus, se kirjaimellisesti vain menossa tulostaa ne merkit. Mutta minulla oli tämä erikoismerkki lopussa, muistaa, kenoviiva n. Ja juuri varmistettu että merkki oli seuraavalle riville näytön. 

Itse asiassa, anna minun mennä ja tehdä tämän. Anna minun mennä eteenpäin ja poistaa. Nyt, huomaa, että alkuun minun näytön siellä pieni punainen valo välilehti ilmaisee, hei, et ole tallentanut tiedostoa. Joten aion edetä ohjaus S tai komento S, tallenna tiedosto. Nyt goes-- meni varten moment-- vihreä. Ja nyt se takaisin vain on läheinen ikoni. 

Jos minä nyt ajaa clanghello.c uudelleen, Enter, piste slash, a.out, Enter, näet, että se vielä toimi. Mutta se luultavasti hieman buginen. Juuri nyt minun prompt-- työtila, ja sitten, että dollarin merkki, ja sitten minun todellinen prompt-- on kaikki samalla linjalla. Joten tämä varmasti esteettinen vika, vaikka se ei oikeastaan ​​looginen vika. 

Joten aion kumota mitä tein. Aion uusintana a.out. Huomatkaa Olen lisännyt Rivinvaihtomerkkiä takaisin. Olen tallentanut tiedoston. 

Joten aion uusintana a.out, and-- dammit, bug, bug tarkoittaa virhe. Eli vika on, että vaikka Lisäsin kenoviivan n siellä, uudelleen tallennettu, uudelleen juoksi ohjelma, käyttäytyminen oli sama. Miksi olisi? 

Olen puuttuu askel, eikö? Tämä keskeinen askel aikaisemmin oli, että olet to-- kun muutat lähdekoodia, se kääntyy pois myös ajaa se läpi kääntäjä uudelleen niin saat uuden koneen koodi. Ja konekoodi nollat ​​ja ykköset, tulevat olemaan lähes identtiset, mutta ei täydellisesti niin, koska tarvitsemme, tietenkin, että uusi rivi. 

Joten korjata, aion tarvitsevat uusintana clanghello.c, kirjoita, dot slash, a.out. Ja nyt, hei maailma on palannut missä Odotan sen olevan. Tämä kaikki on siis hieno ja hyvä. Mutta a.out on tyhmä nimi varten ohjelma, vaikka se sattuu olemaan, historiallisista syistä default-- tarkoittaa kokoonpano lähdöt. 

Mutta anna minun mennä eteenpäin täällä ja tehdä tämän eri tavalla. Haluan hei maailma -ohjelma todella kutsua hei. Joten jos se olisi kuvake minun työpöydälle, se ei olisi a.out. Sitä olisi nimeltään hei. 

Joten tehdä tämän, se kääntyy pois että Clang, kuten monet ohjelmat, tukee komentoriviargumentteja, tai lippuja, tai kytkimiä, joka yksinkertaisesti vaikuttaa sen käyttäytymiseen. Erityisesti Clang tukee viiva o lippu, joka sitten ottaa toinen sana. Tässä tapauksessa, minä mielivaltaisesti, mutta kohtuudella, kutsuvat sitä hei. Mutta voisin kutsua sitä jotain Haluan, paitsi a.out, joka olisi melko lisäksi piste. 

Ja sitten vain määritellä nimi Tiedoston en haluaisi kääntää. Joten nyt vaikka alussa komennon minulla on vielä Clang, lopussa komennon Minulla on vielä tiedostonimi, Nyt nämä komentoriviltä argumentteja, nämä liput, jotka sanovat, oh, muuten, lähtö-o, tiedosto kutsutaan hei, ei oletuksena a.out. 

Joten jos osuin Anna nyt, ei mitään näyttää tapahtuneen. Ja vielä, nyt voin tehdä piste slash hei. Joten se on sama ohjelma. Nollat ​​ja niistä ovat identtiset lopussa päivän. 

Mutta he kahdessa eri files-- a.out, joka on ensimmäinen versio ja vain tyhmästi nimetty, ja nyt hei, joka on paljon enemmän pakottavia nimi ohjelmalle. Mutta rehellisesti, olen koskaan menossa muistaa tätä uudelleen, ja uudestaan, ja uudestaan. Ja itse asiassa, kuten me kirjoittaa monimutkaisempi ohjelmia, komennot olet täytyy kirjoittaa menevät vielä monimutkaisempia edelleen. 

Ja niin ei hätää. On käynyt ilmi, että ihmiset ennen meistä ovat ymmärtäneet hekin oli tämä täsmälleen sama ongelma. Hekin eivät nauti tarvitse tyyppi melko pitkä, mystistä komentoja, puhumattakaan muista niitä. Ja niin ihmiset ennen meitä tehneet muita ohjelmia, jotka helpottavat koota ohjelmiston. 

Ja, todellakin, yksi tällainen Ohjelma on nimeltään Make. Joten aion mennä eteenpäin ja tehdä tätä. Aion perua kaiken I juuri teki seuraavalla tavalla. Saanen tyyppi LS. Ja huomaat kolme things-- a.out, ja tähti, hei ja tähti, ja hello.c. Toivottavasti tämä olisi olla hieman intuitiivinen, sikäli kuin aiemmin oli mitään tässä työtilassa. Ei ollut mitään jouduin luotu kunnes aloimme luokassa. 

Ja olen luonut hello.c. Sitten kootaan sitä, ja kutsui sitä a.out. Ja sitten kootaan uudelleen hieman eri tavalla ja kutsui sitä hei. Olen siis kolme tiedostoja tähän hakemistoon, Tässä kansio nimeltä Työtila. Nyt näen, että myös jos en loitontaa itse. 

Jos minä loitontaa täällä ja katsokaa, että sivun oikeassa kulma, kuten luvattiin vasen laidassa näytön on aina menossa näyttämään mitä tililläsi, mitä sisäpuoli CS50 IDE. Ja on kolme tiedostoa siellä. 

Joten haluan päästä eroon a.out ja hei. Ja kuten ehkä kuvitella intuitiivisesti, sinun voisi lajitella valvonnan klikkauksen tai oikealla klikkaa tästä. Ja tämä pieni valikko ponnahtaa. Voit ladata tiedoston, suorita se, esikatsella sitä, virkistää, nimetä uudelleen, tai mitä ei. 

Voisin vain poistaa, ja se menisi pois. Mutta nyt tehdä asioita komennolla linja nyt, jotta totutella Tämän, ja toimi seuraavasti. Aion mennä eteenpäin ja poistaa a.out kirjoittamalla kirjaimellisesti rma.out. On käynyt ilmi, komento poistamalla tai poistamalla jotain, ei poista tai poista. 

Se on enemmän ytimekkäästi RM, vain säästää sinulle näppäimistön, ja paina Enter. Nyt aiomme olla hieman arvoituksellisesti poistaa tavallinen tiedosto a.out. En todellakaan tiedä, mitä epäsäännöllinen tiedosto olisi vielä. Mutta en halua poistaa sitä. 

Joten aion kirjoittaa y kyllä. Tai voisin kirjoittaa sen ulos, ja paina Enter. Ja jälleen, mikään ei tunnu tapahtuvan. Mutta se on yleensä hyvä asia. 

Jos kirjoitan LS tällä kertaa, mitä minun pitäisi nähdä? Toivottavasti vain hei ja hello.c. Nyt sivuhuomautuksena, luultavasti huomaa tähti, tähti, se lopussa minun ohjelmia. Ja he myös näy vihreänä. Tämä on vain CS50 IDE tapa of cluing sinut siihen että se ei ole lähdekoodia. Se suoritettavan, eli runnable ohjelma, jonka voit todella ajaa tekemällä piste slash, ja sitten se nimi. 

Nyt, anna minun mennä eteenpäin ja poistaa Tämän, rm hei, Enter, poista säännöllisesti tiedosto hei, kyllä. Ja nyt jos kirjoitan LS, olemme takaisin hello.c. Yritä poistaa Varsinainen lähdekoodia. Vaikka on olemassa ominaisuuksia rakennettu CS50 IDE jossa voit käydä läpi versiohistoriaa ja taaksepäin ajassa, jos olet vahingossa poistaa jotain, tee olla tietoinen kohti näitä kehotteita kyllä ​​tai ei, mitä todella haluat tehdä. Ja jos menen ylös vasen yläkulmassa täällä, jäljellä on hello.c. Joten ei kimppua muut komennot voi suorittaa maailmassa Linux, joista yksi on, jälleen, Saa. Ja aiomme tehdä minun ohjelma nyt seuraavasti. 

Sijaan tehdä kalahtaa, sen sijaan tehdä kalahtaa-o, Aion yksinkertaisesti kirjaimellisesti tyyppi, tehdä hei. Ja nyt huomaa, olen ei kirjoittamalla tehdä hello.c. Olen kirjoittamalla tehdä hei. 

Ja tämä ohjelma Tee että mukana CS50 IDE, ja lisää yleensä Linux, on ohjelma, joka on aikoo tehdä ohjelma nimeltä Hei. Ja se tulee olettaa, sopimuksen mukaan, että jos ohjelma voidaan tehdä, se aiotaan tehdä lähteestä koodi tiedosto päättyy piste c, hello.c. 

Joten jos osuin Anna nyt huomaa, että komennon, joka saa suorittaa on itse asiassa jopa pidempi ennen kuin aikaisemmin. Ja se johtuu siitä olemme esimääritetty CS50 IDE olla lisäominaisuuksia rakennettu, että emme tarvitse vielä, mutta pian tulee. Mutta avain asia on ymmärrettävä Nyt olen Hei ohjelma. 

Jos kirjoitan LS taas, I on hei ohjelma. Ja voin ajaa sen kanssa piste slash a.out, no, koska koko kohta tämän Harjoitus oli piste slash hei. Ja nyt minulla on hei maailma -ohjelma. Joten eteenpäin, olemme melkein aina vain menossa koota meidän ohjelmia komennolla Make. Ja sitten me aiomme käyttää niitä piste leikata, ja ohjelman nimi. Mutta ymmärtää, mitä tehdä, on tekemässä te, se ei itse ole kääntäjä. Se on vain mukavuussyistä ohjelma joka osaa käynnistää kääntäjä ajaa niin, että voit itse käyttää sitä. 

Mitä muita komentoja olemassa Linux, ja vuorostaan ​​CS50 IDE? Tulemme pian nähdä, että on olemassa CD-komento, Change Directory. Näin voit sisällä sinun komentorivikäyttöliittymän eteenpäin, ja takaisin, ja avata eri kansioihin ilman hiirtä. 

LS näimme, joka tarkoittaa lista tiedostot hakemistossa. Tee Dir, voit luultavasti alkaa päätellä mitä nämä tarkoittavat now-- tehdä hakemistoon, Jos haluat luoda kansion. RM poistaa, RM Dir varten poista directory-- ja nämä, jälleen, ovat komentorivin vastineet, mitä voisi tehdä CS50 IDE hiirellä. Mutta löydät pian että joskus se on vain paljon nopeammin tekemistä asioita, joissa on näppäimistö, ja lopulta paljon tehokkaampi. 

Mutta on vaikea väittää, että mitä olemme tehneet tähän mennessä on kaikki, tehokas, kun kaikki olemme sanoneet on, hei maailma. Ja itse en hardcoded sanat Hello World minun ohjelmaan. Ei ole mitään dynamiikkaa vielä. Scratch oli kertaluokkaa mielenkiintoisempia viime viikolla. 

Ja niin mennään sinne. Otetaan askel kohti että tapa joitakin näistä toiminnoista. Joten ei ainoastaan ​​C mukana printf, ja rypäleterttuja muita toimintoja joista näemme ajan mittaan, se ei tekevät kaiken niin helppoa heti portin saada käyttäjä syöttää. 

Itse asiassa, yksi puutteista kielten kuten C, ja jopa Java ja vielä muut, on se, että se ei helpottavat vain saada asioita, kuten kokonaislukuja käyttäjiltä, ​​tai jouset, sanoja, ja lauseita, puhumattakaan asioita, kuten liukuluku arvoja tai todelliset luvut jossa desimaalipisteet, ja oikeastaan pitkä numeroita, kuten tulemme pian nähdä. Joten tämä luettelo rakenteista, nämä ovat kuin muut Scratch palapelin palaset että olemme esiasennettuna CS50 IDE että käytämme muutaman viikon kuten apupyörät tapaisena, ja lopulta ottaa niitä pois, ja katso alla huppu, ehkä kello miten nämä asiat toteutetaan. 

Mutta tehdä tämän, nyt todella kirjoittaa ohjelma. Anna minun mennä eteenpäin nyt. Ja aion luoda uusi tiedosto napsauttamalla tätä pientä plus, ja valitsemalla uusi tiedosto. 

Aion säästää tämän seuraavan yksi niin, sanokaamme, string.c, koska haluan pelata jouset. Ja merkkijono C on vain merkkijono. Joten nyt mennään eteenpäin ja toimi seuraavasti. 

Lisää vakio IO.h-- ja se kääntyy pois standardin IO, IO tarkoittaa vain tulo ja lähtö. Joten käy ilmi, että tämä linja tässä mitä on naapurimaiden meitä käyttämään printf. Printf tietenkin tuottaa ulostulon. Joten voidakseen käyttää printf, se kääntyy ulos täytyy olla koodirivin yläosassa tiedoston. 

Ja me palaamme mitä joka todella merkitsee ennen pitkää. On käynyt ilmi, että tahansa C-ohjelma I kirjoittaa, Minun täytyy aloittaa sen kanssa koodia, joka näyttää tältä. Ja huomaat CS50 IDE, ja muut yhtenäinen kehittäminen ympäristöissä, kuten se, ovat menossa yrittää parhaansa he voivat lopettaa oman ajattelun. Itse asiassa, hetki sitten, jos en kumoa mitä tein, osuin Enter. 

Sitten osuma auki kihara ahdin, paina Enter uudelleen. Ja se päättynyt minun ajatus. Se antoi uuden linjan, sisennetty ei vähempää for nice tyylillinen syistä näemme. Ja sitten se automaattisesti antoi minulle että kihara ahdin päätän ajatus. Nyt, se ei aina arvata mitä haluat tehdä. Mutta suurelta osin, se tekee säästää noin painalluksia. Joten hetki sitten meillä oli tämä program-- hei, maailma, ja sitten koottu se, ja sitten juoksi sen. Mutta ei ole dynamiikkaa täällä. Mitä jos halusimme tehdä jotain erilaista? No, mitä jos halusin todella saat merkkijonon käyttäjä? Aion käyttää palapelin pala nimeltään tarkalleen that-- saada merkkijono. 

Osoittautuu C että kun et halua tarjota aineksia palapelin pala, tai oikeammin on -toiminnolla kirjaimellisesti vain tehdä alkusulun, lähellä suluissa. Joten se on ikään kuin siellä ei valkoista ruutua kirjoitat. Sano lohko ennen oli pieni valkoinen laatikko. Meillä ei ole, että valkoisen laatikon nyt. 

Mutta kun kutsun get merkkijono, minä haluavat laittaa tuloksen jonnekin. Joten hyvin yleinen paradigma C on soittaa toiminto, kuten get string täällä, ja sitten tallentaa sen palauttama arvo. Se on seurausta sen vaivaa jotain. 

Ja mikä on rakentaa ohjelmointi, onko Scratch tai nyt C, että me voi käyttää todella tallentaa jotain? Kutsui sitä muuttuja, eikö? Ja Scratch, emme oikeastaan välitä mitä oli menossa muuttujiin. 

Mutta tässä tapauksessa, me todella tehdä. Aion sanoa merkkijono. Ja sitten voisi kutsua Tässä mitä haluan. Aion kutsua sitä nimi, saa saada merkkijono. 

Nyt vaikka olet vähän uusi tässä, huomata, että olen puuttuu joitakin yksityiskohtia. Olen unohtamatta puolipisteellä. Minun täytyy lopettaa tämän ajatuksen. Joten aion siirtää minun osoitinta, ja osuma puolipisteellä siellä. Ja mitä olen juuri tehnyt? Tällä rivillä koodia, numero 5 tällä hetkellä, Soitan get merkkijonon ilman panoksia. Joten ei ole pieni valkoinen ajas Tallenna lohko on. 

Sanon vain, hei, tietokone, saada minut merkkijono. Yhtäsuuruusmerkin ei oikeastaan yhtäläisyysmerkki, sinänsä. Se on tehtävä operaattorin, joka tarkoittaa, hei, tietokone, siirrä arvo oikealta yli vasemmalle. Ja vasemmassa, olen seuraava. 

Hei, tietokone, anna minulle string-- merkkijono. Ja soittaa merkkijono nimi. Enkä edes kutsua sitä Name. 

Voisin kutsua sitä, perinteisesti, jotain S, paljon kuin käytimme i soittaa muuttuja i. Mutta nyt minun täytyy tehdä jotain. Olisi aika tyhmää kääntämistä tätä koodia, käynnissä Tämän ohjelman, vaikka Saan merkkijono, koska se on edelleen vain menossa tervehtimään maailmaan. 

Mutta mitä jos en halua muuttaa tätä. Miksi en tee tätä? Prosentti s, pilkku s. Ja tämä on hieman arvoituksellinen vielä. 

Haluan siis tehdä minun muuttujia selvempi. Saanen nimetä tämän muuttujan nimi. Ja katsotaan jos emme voi kiusata lisäksi mitä täällä tapahtuu. 

Joten linja viisi, Saan merkkijono. Ja olen tallentamiseksi merkkijonon, mitä käyttäjä on kirjoittanut at hänen näppäimistö, muuttujaan nimeltä Name. Ja käy ilmi, että printf ei vain ottaa yhden argumentin hengen lainauksia, yksi tulo lainausmerkkeihin. 

Se voi kestää kaksi tai kolme tai enemmän, kuten että toinen tai kolmas tai neljäs, ovat kaikki nimet muuttujien tai erityisesti arvot, että haluat kytkeä, dynaamisesti, että merkkijono lainausmerkeissä. Toisin sanoen, mitä olisi vikana? Jos minä vain sanoi hei nimi, kenoviiva n, pelasti minun tiedosto käännetty minun koodi, ja juoksi tämä, mitä tapahtuisi? 

Se juuri menossa sanoa, hei nimi, kirjaimellisesti N-A-M-E, mikä on typerää, koska se ei poikkea maailmasta. Joten mitään lainausmerkit on mitä kirjaimellisesti tulostetaan. Joten jos Haluan olla paikkamerkin siellä, Olen itse täytyy käyttää joitakin erityisiä syntaksi. Ja se osoittautuu jos olet lukenut dokumentaatio printf toiminto, se kertoo, että Jos käytät prosenttia s, voit korvata arvon seuraavasti. 

Pilkun jälkeen jälkeen lainausmerkki, voit yksinkertaisesti kirjoittaa nimi muuttuja, että haluat kytkeä tuohon muotoon koodin, tai muodossa määrittelyksi, prosentin s jousille. Ja nyt jos säästin minun arkistoida, Menen takaisin alas minun terminaaliin. Ja kirjoitan Tee String, koska, jälleen, nimi tämän tiedosto että valitsin ennen on string.c. 

Joten aion sanoa tehdä String, kirjoita. Hyvänen, tarkastella kaikkia virheet olemme tehneet jo. Ja tämä is-- mitä, tämä on todella kuten kuusi, seitsemän linja-ohjelma? Joten tämä on, jos se voi hyvin nopeasti ylivoimainen. 

Tämä terminaali ikkuna on nyt vain regurgitated valtava määrä virheilmoituksia. Varmasti, en ole enemmän virhettä viestejä kuin olen riviä koodia. Joten mitä on tekeillä? 

No, paras strategia tehdä milloin do kohtaavat ylivoimainen virheluetteloa niin, on selaa taaksepäin, etsiä komennolla juuri juoksemasi joka minun tapauksessani on tehdä merkkijono. Katsokaa, mitä tehdä teki, ja se, että pitkä Clang komento, no big deal siellä. 

Mutta punainen on huono. Green yrittää olla lempeä ja avulias. Mutta se on edelleen huono, tässä tapauksessa. Mutta missä on se huono? 

String.c, linja viisi, merkki viisi. Joten tämä on vain yleinen sopimus. Jotain paksusuolen jotain merkitsee rivinumero ja merkin numero. Virhe, käyttö pimeän tunniste merkkijono. Tarkoititko vakiona? 

Joten valitettavasti Clang yrittää olla avuksi. Mutta se on väärin, tässä tapauksessa. Ei, Clang, en tarkoita standardi IO. Tarkoitin että linjalla, kyllä. 

Mutta linja viisi on tämä yksi täällä. Ja Clang ei ymmärtää S-T-R-I-N-G. Se on pimeän tunniste, joka on sana se vain ei ole koskaan ennen nähty. Ja se johtuu C-kieli me kirjoittaa koodia juuri nyt, ei ole muuttujia kutsutaan jouset. 

Se ei oletuksena, tuki jotain kutsutaan merkkijono. Se on CS50 pala ammattikieltä, mutta hyvin tavanomainen. Mutta voin korjata seuraavasti. 

Jos lisään yhtä riviä koodia alkuun tämän ohjelman, sisältävät CS50.h, joka on toinen tiedosto jonnekin sisällä CS50 IDE, jonnekin kiintolevyn, niin sanotusti, Ubuntu-käyttöjärjestelmä että olen käynnissä, että on tiedosto, joka on menossa opettaa toiminta järjestelmä mikä merkkijono on vain kuten standardi io.h on tiedosto käyttöjärjestelmä, joka on menossa opettaa sitä mitä printf on. 

Todellakin, olisimme saaneet hyvin samanlaisen viestin jos IO oli myöntänyt standardi IO.h ja yritti käyttää printf. Joten aion mennä eteenpäin ja vain Ohjaa L tyhjentää tietokoneen näytöllä. Tai voit kirjoittaa selkeitä ja se tulee vain tyhjentää pääteikkuna. Mutta voit silti vierittää ajassa taaksepäin. 

Ja aion uusintana tehdä String. Cross sormiani tällä kertaa Enter. Voi luoja, se toimi. se näyttää minulle pitkä arvoituksellisesti komennon sitähän Varmista luotu kautta Clang, mutta ei virheilmoituksia. Joten ymmärtää, vaikka saatat saada täysin hukkua määrä virheilmoituksia, se vain voi olla ärsyttävää CSS vaikutus, jossa Clang ei ymmärrä Ensinnäkin, mikä tarkoittaa, että sen jälkeen ei ymmärrä seuraava sana, tai seuraavalle riville. Ja niin se vain tukehtuu koodin. Mutta fix voisi olla yksinkertaista. Ja niin aina keskittyä ensimmäinen rivi tuotos. Ja jos et ymmärtää se, katsokaa avainsanoja, jotka saattavat olla vihjeitä, ja rivinumero, ja merkin, jossa että virhe voi olla. 

Nyt haluan mennä eteenpäin ja kirjoita piste slash, merkkijono, kirjoita. Hm, se ei sano hei mitään. Miksi? No, muistaa, missä on se käynnissä? 

Se on luultavasti jumissa tällä hetkellä silmukan, jos haluatte, on line kuusi, koska Get String suunnittelun, kirjoittanut CS50 henkilöstö, on kirjaimellisesti tarkoitus vain istua siellä odottamassa, ja odottaa, ja odottaa merkkijono. Kaikki me tarkoitamme merkkijono on ihmisen panos. Joten tiedätkö mitä? Anna minun mennä eteenpäin. Ja vain hetken mielijohteesta, haluaisin kirjoita nimeäni, David, anna. Nyt minulla on enemmän dynaaminen ohjelma. Se sanoi, hei David. 

Jos menen eteenpäin ja suorita tämä uudelleen, Yritän sanoa Zamila nimen, anna. Ja nyt meillä on dynaaminen ohjelma. En ole koodattu maailmaa. En ole koodattu nimi, tai David tai Zamila. 

Nyt se on paljon enemmän kuin ohjelmat me tiedämme, missä se kestää tulo, se tuottaa hieman eri tuotos. Nyt tämä ei ole paras käyttäjäkokemusta tai UX. Juoksen ohjelma. 

En tiedä, mitä minun pitäisi tehdä, jos en oikeastaan ​​katsoa tai muistaa lähdekoodia. Joten tehdä käyttäjän Koe hieman paremmin yksinkertaisin asioita. Anna minun mennä takaisin tähän ohjelma, ja sanoa yksinkertaisesti printf. 

Ja anna minun mennä eteenpäin ja sanoa nimi, paksusuoli, ja välilyönti, ja sitten puolipisteellä. Ja huvin, ei takaisku n. Ja se on tahallista, koska en halua kehotteen siirtyä seuraavalle riville. 

Haluan sen sijaan tehdä tämän, tee merkkijono kääntää minun koodi uuden koneen koodi piste slash merkkijono. Ah, tämä on paljon kauniimpi. Nyt en oikeastaan ​​tiedä mitä tietokone haluaa minun tekevän, antaa sille nimi. 

Joten aion mennä eteenpäin ja kirjoita Rob, kirjoita, ja hei, Rob. Niin, ymmärtää, tämä on vielä lopussa Päivän vain yhdeksän linja ohjelmaa. Mutta olemme ottaneet nämä vauvan askelia. 

Kirjoitimme yksi rivi, jolla me olivat tuttuja, printf, Hello World. Sitten undid hieman siitä. Ja me todella käytetään get merkkijono. Ja me heitti että arvon muuttujaan. Sitten menimme eteenpäin ja parantanut se edelleen, kolmannella rivillä. Ja tämä iteratiivinen prosessi tallennusohjelmistojen on todella avain. Vuonna CS50, ja elämässä yleensä, ei yleisesti ottaen tulisi istua alas, on ohjelma mielessä, ja kokeile kirjoittaminen koko hemmetin asia kerralla. 

Se väistämättä johtaa tavalla enemmän virheitä kuin me itse nähnyt täällä. Jopa minä, tähän päivään, jatkuvasti tehdä muita typeriä virheitä, ovat todella vaikeampaa virheitä jotka ovat vaikeampi selvittää. Mutta te tekee enemmän virheitä enemmän riviä koodia kirjoittaa kaikki kerralla. Ja niin tämä käytäntö, kirjoittaa hieman koodia että olet tyytyväinen, koota se, ajaa sitä, testata sitä yleisemmin, siirrä on-- joten aivan kuten me jatkoimme kerrospukeutuminen ja kerrospukeutuminen viime viikolla, rakentamassa jotain hyvin yksinkertaista jotain monimutkaisempi, tehdä saman täällä. Älä istu, ja yritä kirjoittaa koko ongelma. Oikeastaan ​​ottaa nämä vauvan askelia. 

Nyt jouset eivät ole kaikki että hyödyllisiä itselleen. Olimme itse asiassa, ihannetapauksessa, kuten on jotain muuta meidän työkalusarja. Joten itse asiassa juuri siihen. 

Anna minun mennä eteenpäin nyt ja lietsoa hieman eri ohjelmaa. Ja me kutsumme tätä int.c, kokonaisluku. Aion vastaavasti kuuluu CS550.h. Aion vakiovarusteista IO. Ja se tulee olemaan melko yleisiä Näiden ensimmäisten päivien luokan. 

Ja aion valmis itseni päätehtävä. Nyt sen sijaan saada merkkijono, mennään eteenpäin ja saada int. Kutsutaan sitä i, ja kutsua sitä saada int, lähellä parens, puolipisteellä. Ja nyt Tehdään jotain sen kanssa, printf. 

Sanotaan jotain Hei, kenoviiva n, pilkulla i. Joten olen aika paljon matkii mitä tein juuri äsken. Olen paikkamerkki täällä. Olen pilkku i täällä, koska haluan kytkeä i tuohon paikkamerkki. 

Joten mene eteenpäin ja kokeile koottaessa ohjelma. Tiedosto on nimeltään int.c. Joten aion sanoa, tehdä int, kirjoita. Voi luoja, mutta ei ole iso juttu, eikö? On virhe. 

Siellä on syntaktinen virhe tässä niin, että ohjelma ei voi koottava sisällä int.c, viiva seitsemän, merkki 27, virhe formaatti täsmennetään tyyppi char tähti, mitä se on. Mutta väite tyyppi on int. 

Niin tässäkin emme aio to-- vaikka tänään on paljon materiaalia, aiomme hukuttaa teitä ehdottomasti jokainen piirre C, ja ohjelmointi yleisemmin vain nämä ensimmäisten viikkojen aikana. Joten siellä on usein olemaan ammattikieltä jolla et tunne. Ja itse asiassa, nieriä tähti on jotain aiomme palata viikon tai kahden kuluttua. 

Mutta nyt, katsotaanpas jos voimme jäsentää sanoja, jotka ovat tuttuja. Alustat-- joten kuulimme muoto specifier, formaatti koodin ennen. Se on tuttu. Type-- mutta väite on tyyppiä int. Hetkinen, i on int. 

Ehkä prosenttia s oikeastaan on joitakin määritelty merkitys. Ja todellakin, se tekee. Kokonaisluku, jos haluat printf korvata sitä, todella on käytettävä eri muotoon määrittelyksi. Ja et tiedä tätä ellei joku määrännyt, tai olet tehnyt sen ennenkin. Mutta prosenttia i on mitä voidaan yleisesti käytetty Printf varten kytkemällä kokonaisluku. Voit myös käyttää prosenttia d desimaalikokonaisluku. Mutta i on mukava ja yksinkertainen täällä. Joten mennään sen kanssa. 

Nyt haluan mennä eteenpäin ja uusintana make int, Enter. Se on hyvä, ei virheitä. Dot slash int-- OK, huono käyttökokemuksen koska en ole kertonut itse mitä tehdä. Mutta se käy hyvin. Olen kiinni siitä nopeasti. 

Nyt anna minun mennä eteenpäin ja Kirjoita David, OK, Zamila, Rob. OK, joten tämä on hyvä asia. Tällä kertaa, olen käyttäen toimintoa, palapelin pala, nimeltään get int. Ja se osoittautuu out-- ja me katso tätä myöhemmin term-- CS50 henkilökunta on toteuttanut saada merkkijono siten että se vain fyysisesti saada merkkijono sinulle. 

Se on toteutettu get int vuonna siten, että se vain saada kokonaisluku sinulle. Ja jos, ihmisen, eivät tee yhteistyötä, se on kirjaimellisesti juuri menossa sano uudelleen, uudelleen, uudelleen, kirjaimellisesti istuu siellä silmukoiden, kunnes te velvoittaa joitakin maaginen numero, kuten 50, ja hei 50. 

Tai jos me suorita tämä uudelleen ja kirjoita 42, hei 42. Ja niin get int toiminto sisällä että palapelin pala riittää logiikka, tarpeeksi ajatus, selvittää, mikä on sana? Ja mikä on numero? Vain hyväksymällä lopulta numeroita. 

Joten käy ilmi, että tämä ei ole kovin ilmeikäs. niin kaukana. Joten, jee, viimeinen kerta meni melko nopeasti osaksi täytäntöön pelejä, ja animaatio, ja taideteosten Scratch. Ja tässä, me ollaan sisältöä jossa Hello World, ja hei 50. 

Se ei ole kaikki, että inspiroiva. Ja, todellakin, nämä ensimmäiset esimerkkejä kestää jonkin aikaa ylösajamiseen jännitystä. Mutta meillä on niin paljon enemmän hallita nyt, itse asiassa. Ja aiomme hyvin nopeasti aloittaa kerrospukeutuminen päälle näistä perus perusalkioiden. 

Mutta ensin on ymmärrettävä mitä rajoitukset ovat. Itse asiassa, yksi niistä asioista Scratch ei helposti tehkäämme todella näyttää alla huppu, ja ymmärtää, mitä tietokone on, mitä se voi tehdä, ja mitä sen rajoitukset ovat. Ja todellakin, että puute ymmärtämistä, mahdollisesti pitkäaikainen voi johtaa omia mistakes-- kirjoittaminen vikoja, kirjallisesti turvaton ohjelmisto, hakkeroidaan jollakin tavalla. 

Joten ottamaan askeleita kohti ymmärrystä tämä vähän paremmin tapa, sanovat, seuraava esimerkki. Aion mennä eteenpäin ja toteuttaa todella nopeasti ohjelma nimeltä lisääjä. Kuten, nyt lisätä joitakin numeroita yhteen. Ja aion koodata joitakin kulmat täällä, ja kopioi ja liitä jossa olin ennen, vain jotta voimme lähteä aikaisemmin. Nyt olen saanut perus alkuja ohjelma nimeltä lisääjä. 

Ja mennään eteenpäin ja tehdä tätä. Aion mennä eteenpäin ja vaikkapa intx saa päästä int. Ja tiedätkö mitä? Tehdään paremman käyttökokemuksen. 

Joten sanotaan että x on, ja tehokkaasti kehottaa käyttäjää antamaan meille x. Ja anna minun mennä eteenpäin ja sanoa, printf miten y on, tällä kertaa odottaa kaksi arvoa käyttäjältä. Ja sitten mennään vain eteenpäin ja esimerkiksi printf, summa x ja y on. Ja nyt en halua tehdä prosenttiin s. Haluan tehdä prosenttiin i, kenoviiva n, ja sitten kytke summa-arvoon. 

Joten miten voin edetä tässä? Tiedätkö mitä? En osaa käyttää muuttujia. Saanen ilmoittaa uuden, int z. 

Ja aion yrittää arvata täällä. Jos on yhtäsuuruusmerkit tässä kieli, ehkä voin vain tehdä x plus y, kunhan päätän ajatteli puolipistettä? Nyt voin palata tänne, kytke z, lopettaa tämän ajatuksen kanssa puolipisteellä. Ja katsotaan nyt, jos nämä sekvenssit lines-- x on saada int. Y on saada int. 

Lisää x ja y, säilytä arvoa z-- niin, taas, muista yhtäläisyysmerkki ei ole yhtä suuri. Se toimeksianto oikealta vasemmalle. Ja nyt tulostaa että summa x ja y eivät ole kirjaimellisesti z, mutta mitä sisällä z. Joten tehdä Adder - mukava, ei virheitä tällä kertaa. Dot slash Adder, kirjoita, x tulee olemaan 1. 

Y tulee olemaan 2. Ja summa x ja y on 3. Niin, että kaikki hyvä ja hieno. 

Voisi siis kuvitella, että matematiikka pitäisi toimia tällaisen ohjelman. Mutta tiedätkö mitä? Onko tämä muuttuja, viiva 12, jopa välttämätöntä? Sinun ei tarvitse saada tapana vain tallentamiseen asioita muuttujien vain koska voit. Ja itse asiassa, se on yleensä harkittu huono suunnittelu jos olet luomassa muuttuja, nimeltään z tässä tapauksessa, säilytykseen jotain se, ja sitten heti käyttää sitä, mutta ei koskaan enää. Miksi antaa jotakin nimi kuten z jos olet kirjaimellisesti aio käyttää, että asia vain kerran, ja niin proksimaalisesti jossa loit se ensimmäinen paikka, niin lähellä suhteen riviä koodia? Joten tiedätkö mitä? On käynyt ilmi, että C on melko joustava. Jos minä todella haluavat plug-in-arvojen täällä, En tarvitse julistaa uusi muuttuja. Voisin plug-in x plus y, koska C ymmärtää aritmeettinen ja matemaattisia operaattoreita. 

Voin siis vain sanoa, tehdä tämän matematiikka, x plus y riippumatta nämä arvot ovat, plug tuloksena kokonaisluvun merkkijono. Joten tämä voisi olla, vaikka vain yksi rivi lyhyempi, parempi suunnittelu, parempaa ohjelmaa, koska siellä on vähemmän koodia, siis vähemmän minua ymmärtämään. Ja se on myös juuri siivooja, sikäli kuin emme ole käyttöön uusia sanoja, uusia symboleja, kuten z, vaikka ne eivät oikeastaan palvella paljon tarkoitusta. 

Valitettavasti matematiikka ei ole kaikki luotettavia joskus. Mennään eteenpäin ja tehdä tätä. Aion mennä eteenpäin nyt ja toimi seuraavasti. 

Tehdään printf, prosenttia i, plus prosenttia i, on oltava prosenttia i, kenoviiva n. Ja aion tehdä this-- xyx plus y. Joten olen juuri menossa kirjoittaa Tässä hieman eri täällä. Saanen tehdä nopeasti järki tarkistaa. Jälleen älkäämme päästä eteenpäin itsestämme. Tee lisätoiminto, piste slash lisätoiminto. x on 1, y on 2, 1 ja 2 on 3. Niin se on hyvä. Mutta katsotaanpa mutkistaa tätä nyt hieman, ja luo uuden tiedoston. 

Aion kutsua tätä, sanovat, ints, monikko kokonaislukuja. Aloitan jossa olin hetki sitten. Mutta nyt tehkäämme muutamia muita rivejä. Anna minun mennä eteenpäin ja tehdä seuraava, printf, prosenttia i miinus prosenttia i, on prosentti i, pilkku x, pilkku yx miinus y. Joten teen hieman eri matematiikka siellä. Tehdään toinen. Joten prosenttia i kertaa prosenttiin i on prosentti i, kenoviiva n. Katsotaan plug-in x ja y ja x kertaa y. Käytämme tähtimerkkiä tietokoneen kertaa. 

Et käytä x. x on muuttujan nimi. Käytät tähti kertolasku. Tehdään yksi. Printf prosenttia I jaettuna by prosenttia i, on prosentti i, backslash n. xy jaettuna y-- joten käytät vinoviivan C tehdä jako. Ja Tehdään yksi muu. Loput prosenttia i, jakautuu by prosenttia i, on prosenttia i. xy-- ja nyt jäljellä on mitä on jäljellä. Kun yrität jakamalla nimittäjä osaksi osoittaja, kuinka paljon on jäljellä, että et voisi jakaa ulos? 

Joten ei ole oikeastaan, väistämättä, symboli olemme käyttäneet asteella tätä. Mutta C. Voit sanoa x modulo y, jossa Tämän prosenttimerkkiä tässä context-- erehdyttävästi kun olet sisällä kaksinkertaisen lainausmerkkejä, sisällä printf, prosenttia käytetään muodossa määrittelyksi. 

Kun käytät prosenttia ulkopuolella että matemaattinen lauseke, se on modulo operaattori modulaarinen arithmetic-- meidän tarkoituksiin täällä, vain tarkoittaa, mikä on Loput x jaettuna y? Joten x jaettuna y on x slash y. Mikä jäljellä x jaettuna y? Se x mod y, ohjelmoijana sanoisi. 

Jos siis tehnyt virheitä täällä, haluan mennä eteenpäin ja tehdä ints, monikossa, mukava, ja piste slash ints. Ja mennään eteenpäin ja do, sanokaamme, 1, 10. Selvä, 1 plus 10 on 11, check. 1 miinus 10 on negatiivinen 9, tarkista. 

1 kertaa 10 on 10, check. 1 jaettuna 10 is-- OK, me ohittaa tämän yhden. Loput 1 jaettuna 10 on 1. Pitää paikkansa. Mutta on vika täällä. 

Joten yksi esitin luovuttaa, ei ole oikein. Siis, se on lähellä 0. 1 jaettuna 10, tiedätte, jos olemme vähentämiseksi noin kulmat, varma, se on nolla. Mutta se pitäisi oikeastaan ​​olla 1/10, 0,1 tai 0,10, 0,1000, tai niin edelleen. 

Sen ei pitäisi oikeastaan ​​olla nolla. No, käy ilmi, että tietokone on tekemällä kirjaimellisesti mitä kerroimme sitä tekemään. Teemme matematiikka kuten x jaettuna y. Ja sekä x ja y, per linjat koodia aikaisemmin, ovat kokonaislukuja. 

Lisäksi linjalla 15, olemme kertoo printf, hei, printf plug-in kokonaisluku, plug-in kokonaisluku, plug-käytettäessä integer-- nimenomaan x ja sitten y, ja niin x jaettuna y. x ja y ovat ints. Olemme hyvä siellä. 

Mutta mitä on x jaetaan x? x jaettuna y pitäisi olla, matemaattisesti, 1/10 tai 0,1, joka on reaaliluku, reaaliluku ottaa mahdollisesti desimaalipisteen. Se ei ole kokonaisluku. 

Mutta mikä on lähin kokonaisluvun 1/10 eli 0,1? Joo, se tavallaan on nolla. 0.1 on näin paljon. Ja 1 on näin paljon. Joten 1/10 on lähempänä 0 kuin se on yksi. 

Ja mitä sitten C on tekemässä us-- Tällainen koska kerroimme se to-- on lyhennetty, että kokonaisluku. Se ottaa arvon, joka taas on tarkoitus olla jotain 0,1000, 0 ja niin edelleen. Ja se katkaisemiseksi kaiken desimaalipisteen jälkeen siten, että kaikki tämän tavaraa, koska se ei sovi käsite kokonaisluku, joka on vain numero kuin negatiivinen 1, 0, 1, ylös ja alas, se heittää pois kaiken desimaalipisteen jälkeen, koska olet ei mahdu desimaalipisteen in kokonaisluku määritelmän. 

Joten vastaus tässä on nolla. Miten siis korjata? Me tarvitsemme toinen ratkaisu kaikki yhdessä. Ja voimme tehdä tämän seuraavasti. 

Anna minun mennä eteenpäin ja luoda uusi tiedosto, tämä yksi nimeltään floats.c. Ja tallenna se täällä samaan hakemistoon, float.c. Ja anna minun mennä eteenpäin ja kopioi joitakin että koodia aikaisemmin. 

Mutta sen sijaan saada int, tehdään tämä. Anna minulle liukulukuarvoksi nimeltään x. jossa liukuluku arvo on vain kirjaimellisesti jotain liukuvan pilkun. Se voi liikkua vasemmalle, oikealle. Se on todellinen numero. 

Ja Soitan ei saada int, mutta saada kellua, joka myös oli yksi valikko annetuista vaihtoehdoista C250 kirjastossa. Vaihdetaan y käteisvaroja. Joten tämä tulee saada kellua. 

Ja nyt, emme halua kytkeä ints. On käynyt ilmi, meidän on käytettävä prosenttiin f float, prosenttia f float, ja nyt tallentaa sen. Ja nyt, sormet ristissä, tee kellukkeet, mukava, piste slash kelluu. x tulee olemaan yksi 1. y Tulee olemaan 10 uudelleen. 

Ja kiva, OK minun lisäksi on oikea. Toivoin enemmän, mutta unohdin kirjoittaa sitä. Joten mennään ja korjata looginen virhe. 

Mennään eteenpäin ja napata seuraavaa. Me vain tehdä vähän kopioi ja liitä. Ja aion sanoa miinus. 

Ja aion sanoa kertaa. Ja aion sanoa jaettu. Ja en aio tehdä modulo, joka ei ole yhtä germane tässä, jaettuna f, ja ajat plus-- OK, tehdään tämä uudestaan. 

Tee kellukkeet, piste slash kellukkeet, ja 1, 10, and-- mukava, no, OK. Joten olen idiootti. Joten tämä on hyvin yleinen tietotekniikassa tehdä typeriä virheitä näin. 

Opetuksellisia tarkoituksia varten, mitä halusin tehdä oli muuttaa tiedettä täällä plus, miinus, että ajat, ja jakaa, kun toivottavasti huomanneet tämän harjoituksen aikana. Nyt Katsotaanpa uudelleen kokoaa ohjelma, tehdä piste slash kelluu. 

Ja kolmannen kerran, nyt katso jos se täyttää odotukseni. 1, 10, kirjoita, kyllä, OK, 1.000, jaettuna 10.000, on 0,100000. Ja se osoittautuu voimme valvoa, kuinka monta numerot ovat sen jälkeen ne desimaaliin. Me itse asiassa tulee. Palaamme tähän. 

Mutta nyt, itse asiassa, matematiikka on oikea. Joten, jälleen, mikä on takeaway täällä? On käynyt ilmi, että C, on ei vain pelkästään strings-- ja, itse asiassa, ei ole oikeastaan, koska me lisätä ne kanssa CS50 kirjasto. Mutta ei ole vain ints. 

On myös kelluu. Ja se osoittautuu joukko muita tietoja tyyppejä myös, että käytämme ennen pitkää. Osoittautuu, jos haluat yhden merkki, ei merkkijono, voit käyttää vain char. 

Osoittautuu, että jos haluat bool, looginen arvo, tosi tai epätosi vain, kiitos CS50 kirjasto, olemme lisätään C BOOL tietotyyppi samoin. Mutta se myös esittää vuonna monia muita kieliä samoin. Ja käy ilmi, että joskus tarvitsee suurempia numeroita sitten tulevat oletuksena jossa ints ja kelluu. 

Ja itse asiassa, kaksinkertainen on useita joka käyttää ei 32 bittiä, mutta 64 bittiä. Ja pitkään pitkään on numero, käyttää ei 32 bittiä mutta 64 bittiä, vastaavasti, liukuluku arvot ja kokonaislukuja, vastaavasti. Joten itse asiassa nyt tutustua tähän toimintoon. 

Aion mennä eteenpäin tässä ja lietsoa yksi muu ohjelma. Täällä, aion mennä eteenpäin ja sisällyttävät CS50.h. Ja anna minun mennä, ovat standardin IO.h. 

Ja huomaat jotain funky täällä tapahtuu. Se ei ole värikoodeja asioita samoin kuin ennen. Ja on käynyt ilmi, että koska minä eivät ole antaneet asia tiedostonimen. 

Aion kutsua tätä yksi sizeof.c, ja valitse Tallenna. Ja huomaa, mitä tapahtuu, hyvin valkoinen koodia vastaan ​​mustaa taustaa. Nyt ainakin siellä purppuramaisen siellä. Ja se on syntaksi korostettu. 

Tämä johtuu yksinkertaisesti, olen kertoi IDE minkälainen tiedosto se on antamalla sille nimi, ja erityisesti tiedostopääte. Nyt mennään eteenpäin ja tehdä tätä. Aion mennä eteenpäin ja hyvin yksinkertaisesti tulostaa following-- bool on prosenttia LU. 

Tulemme takaisin että vain hetken. Ja sitten aion tulostuskoon bool. Ja nyt, vain säästää itse jonkin aikaa, olen aikoo tehdä koko joukko näistä kerralla. Ja erityisesti, aion vaihtaa tämän char ja char. Tämä yksi, aion muuttaa kaksinkertainen ja kaksinkertainen. 

Tämä yksi, aion muuttaa kelluvaan ja kellua. Tämä yksi, aion muuttuvat int ja int. Ja tämä, aion vaihtaa pitkään pitkään. Ja se on edelleen ottaen pitkään, pitkään pitkään. 

Ja sitten lopuksi annoin itse liikaa, merkkijono. On käynyt ilmi, että C, siellä erityinen operaattori nimeltään koko se kirjaimellisesti menossa, kun ajaa, Kerro meille kokoa jokainen näistä muuttujista. Ja tämä on tapa, nyt, voimme liittää takaisin viime viikon keskustelu Tietojen ja edustus. 

Anna minun mennä eteenpäin ja koota koko piste slash koko. Ja katsotaan. On käynyt ilmi, että C, nimenomaan CS50 IDE, nimenomaan käyttöjärjestelmä Ubuntu, joka on 64-bittinen käyttöjärjestelmä järjestelmä tässä tapauksessa, bool on menossa käyttää yhden tavun tilaa. Niin koko mitataan, ei bittiä, mutta tavuina. Ja muistaa, että yksi tavu on kahdeksan bittiä. Joten bool, vaikka Teknisesti tarvitaan vain 0 tai 1, se on hieman tuhlaileva miten me lisännyt sen. Se todella tulee käyttää koko byte-- niin kaikki nollia, ovat ehkä kaikki ne, tai jotain sellaista, tai vain yksi 1 joukossa kahdeksan bittiä. 

Char puolestaan ​​käytetään hahmo kuten ASCII per viime viikolla, tulee olemaan yksi merkki. Ja että synchs kanssa käsityksemme se on enintään 256 bits-- pikemminkin synchs sen kanssa yhteydessä ole pidempi kuin 8 bittiä, joka antaa meille jopa 256 arvoa. Kaksinkertainen on menossa olla 8 tavua tai 64 bittiä. 

Koho on 4. Int on 4. Pitkä, pitkä on 8. Ja merkkijono on 8. Mutta älä huoli siitä. Aiomme kuoria takaisin, että kerros. On käynyt ilmi, jouset voi olla pidempi kuin 8 tavua. 

Ja todellakin, olemme kirjoittaneet jouset jo, Hello World, yli 8 tavua. Mutta me palaamme että vain hetken. Mutta take pois tässä on seuraava. 

Mikä tahansa tietokone on vain rajallinen muistin määrän ja tilaa. Voit tallentaa vain niin paljon tiedostoja Macin tai PC. Voit tallentaa vain niin paljon ohjelmia RAM käynnissä kerralla, välttämättä edes virtuaalinen muisti, koska sinulla on rajallinen määrä muistia. 

Ja vain picture-- jos et ole koskaan avannut kannettavan tai tilata lisää muistia for tietokonetta, ehkä tiedä, että tietokoneesi sisälle on jotain, joka näyttää vähän kuin tämä. Joten tämä on vain yleinen yhtiö nimeltä Ratkaisevaa joka tekee RAM tietokoneita. Ja RAM on jossa ohjelmat elävät, kun he käynnissä. 

Joten jokaisen Mac- tai PC, kun kaksinkertainen valitse ohjelma, ja se avautuu, ja se avaa joitakin Word-dokumentti Tai jotain sellaista, se varastoi väliaikaisesti RAM, koska RAM on nopeampi kuin kovalevyllä, tai SSD-levy. Joten se on vain jos ohjelmia mennä elää kun he käynnissä, tai kun tiedostoja käytetään. 

Joten sinulla on asioita, jotka näyttävät näin sisällä kannettavan tietokoneen, tai hieman suurempi asioita sisällä työpöydän. Mutta avain on sinulla on vain rajallinen määrä näistä asioista. Ja on vain rajallinen määrä laitteisto istuu tällä työpöytä oikealla tässä. 

Joten, varmasti, emme voi varastoida äärettömän pitkä numeroita. Ja vielä, jos luulet takaisin asteella, kuinka monta numeroa voi sinun on oikea of desimaalipilkkua? Tästä asiasta, kuinka monta numeroa voi olet vasemmalla desimaalipilkkua? Todella, äärettömän monta. 

Nyt me ihmiset ehkä vain osaavat lausua miljoonaan, ja miljardia biljoonaa, ja Kvadriljoona, ja quintillion. Ja olen Loitonnetaan minun understanding-- tai my-- ymmärrän numeroita, mutta minun ääntäminen numeroita. Mutta he voivat saada äärettömän suuri kanssa äärettömän monta numeroa vasemmalle tai oikealla desimaalipilkkua. 

Mutta tietokoneissa on vain rajallinen määrä muistia, äärellinen määrä transistoreita, joka on rajallinen määrä lamppujen sisälle. Mitä tapahtuu, kun olet tila loppuu? Toisin sanoen, jos muistelen viime viikolla Kun puhuimme numeroita itse edustaa binary, Oletetaan, että meillä Tämä 8-bittinen arvo täällä. 

Ja meillä on seitsemän 1: n ja yhden 0. Ja oletetaan, että haluamme Lisää 1 tähän arvoon. Tämä on todella suuri määrä nyt. 

Tämä on 254, jos muistan matematiikka viime viikolla oikealta. Mutta mitä jos muutan että oikeanpuoleisin 0 1? Koko määrä, ja Tietenkin tulee kahdeksan 1: n. Joten olemme edelleen hyvä. 

Ja että luultavasti edustaa 255, vaikkakin riippuen yhteydessä se voisi todella edustaa negatiivinen luku. Mutta siitä lisää toisella kertaa. Tämä tuntuu se on noin peräti voin luottaa. 

Nyt se on vain 8 bittiä. Ja Mac, varmasti, on tapa enemmän kuin 8 bittiä muistia. Mutta se ei ole rajallinen. Joten Sama pätee, vaikka on enemmän nämä ovat näytöllä. 

Mutta mitä tapahtuu, jos olet tallentamista tämä määrä, 255, ja haluat laskea 1 hieman korkeampi? Haluatko mennä 255-256. Ongelma on tietenkin se, että jos alkaa laskea nollasta kuten viime viikolla, et voi laskea niin korkea 256, puhumattakaan 257, puhumattakaan 258, m koska mitä tapahtuu, kun lisäät 1? Jos tehdä vanhan alakoulussa lähestymistapa, laittaa 1 täällä, ja sitten 1 plus 1 on 2, mutta se on todella nolla, kannat 1, kuljettaa 1, kuljettaa 1. Kaikki nämä asiat, Näiden 1: n, mene nollaan. Ja te päätteeksi, kyllä, kuten joku huomautti, 1 vasemmalla puolella. Mutta kaiken voit itse nähdä ja mahdu muistiin on vain kahdeksan 0: n, toisin sanoen jossain vaiheessa, jos, tietokone, kokeillut laskee riittävän korkea ylös, olet menossa kietoa, näyttäisi siltä, nolla, tai ehkä jopa negatiivinen numerot, jotka ovat jopa pienempi kuin nolla. 

Voimme tavallaan nähdä tämän. Anna minun mennä eteenpäin ja kirjoittaa todellinen nopea ohjelma täällä. Anna minun mennä eteenpäin ja kirjoittaa ohjelma nimeltä ylivuoto. Sisällytä CS50.h, sisältävät standardi IO.h-- oh, Olen todella ikävä syntaksin. Joten tallentaa tämän overflow.c. 

Ja nyt int main void-- ja ennen pitkää käymme palata miksi pidämme kirjoittamista int main mitätön. Mutta nyt, haluan vain tehdä se, itsestäänselvyytenä. Annetaan itse int, ja alustaa sen 0. 

Katsotaan sitten tehdä int saan zero-- itse asiassa, tehdään päättymättömään silmukkaan ja katso mitä tapahtuu. Vaikka totta, niin nyt tulostaa n on prosentti i, kenoviiva n, plug-in n. Mutta nyt, tehdään n saa n plus 1. 

Eli toisin sanoen, kullakin iteraatio tämän loputon silmukka, Otetaan n arvosta, ja lisätään 1 siihen, ja sitten tuloksen tallentaminen takaisin n vasemmalla. Ja itse asiassa, olemme nähneet syntaksin hieman näin lyhyesti. Viileä temppu on sen sijaan kirjoittamisen tämän kaiken, voit itse sanoa n plus on 1. 

Tai jos todella haluat olla fancy, voit sanoa n plus plus puolipisteellä. Mutta nämä kaksi jälkimmäistä ovat vain mitä olimme kutsua syntaktinen sokeria että ensimmäinen asia. 

Ensimmäinen asia on selvempi, täysin hieno, täysin oikea. Mutta tämä on yleisempää, sanon. Niin teemme tätä vain hetken. 

Oletetaan nyt tehdä ylivuoto, joka kuulostaa melko pahaenteinen, piste slash ylivuoto. Katsotaan, n on tulossa melko iso. Mutta Ajatellaanpa, kuinka suuri voi n päästä? 

n on int. Näimme äsken kokoon Esimerkiksi että int on neljä tavua. Tiedämme viime viikolla, neljä tavua on 32 bittiä, koska 8 kertaa 4, joka on 32. Se tulee olemaan 4 miljardia. 

Ja olemme jopa 800000. Tämä tulee kestää ikuisesti laskea niin korkealle kuin suinkin mahdollista. Joten aion mennä eteenpäin, kuten saatat ennen pitkää, ja osuma ohjaus C-- rehellisesti, Ohjaus C, paljon, jossa valvonta C yleisesti välineet peruuttaa. Valitettavasti, koska tämä on käynnissä pilveen, joskus pilvi on sylkeminen ulos niin paljon tavaraa, niin paljon tuotos, se tulee kestää vähän aikaa minun panos päästä pilveen. Joten vaikka osuin Ohjaus C muutaman sekunnin sitten, tämä on ehdottomasti sivussa vaikutus päättymättömään silmukkaan. 

Ja niin tällaisissa tapauksissa, olemme aio jättää sen olla. Ja aiomme lisätä toisen pääteikkuna tänne kanssa plus, mikä tietysti ei niin, koska se on vielä miettiä. Ja mennään eteenpäin ja olla hieman järkevämpi. 

Aion mennä eteenpäin ja tehdä tämä vain äärellisen monta kertaa. Käytetään for-silmukka, joka viittasin aiemmin. Tehdään tämä. Anna minulle toinen muuttuja int i saa 0. i on pienempi kuin, sanokaamme, 64 i ++. Nyt anna minun mennä eteenpäin ja tulostaa out n on prosentin i, pilkku n. Ja sitten n- tämä on edelleen vie ikuisesti. Tehdään tämä. 

n saa n kertaa 2. Tai voisimme olla fancy ja tehdä kertaa = 2. Mutta sanotaan vaikka n on yhtä kuin itse, kertaa 2. Toisin sanoen, tämän uusi versio ohjelmasta, En halua odottaa ikuisesti alkaen kuten 800000 4 miljardia. Toivotaan vain hoitaa tämän. 

Katsotaan todella kaksinkertaistuu n kerta. Joka muistaa, kaksinkertaistaminen on vastakohta ottaa tietenkin. Ja kun viime viikolla meillä jotain uudestaan, ja uudestaan, ja jälleen, huippunopea, kaksinkertaistaminen varmasti saa meidät 1 suurin mahdollinen arvoa, että voimme laskea sisäisellä. 

Joten tehdä juuri tätä. Ja me palaamme tähän ennen pitkää. Mutta tämä taas on aivan toistuva lohko Scratch. Ja voit käyttää tätä ennen pitkää. 

Tämä tarkoittaa vain sitä, count nollasta asti, mutta ei yhtä suuri, 64. Ja jokaisen iteraation tämän silmukka, vain pitää kasvattamalla i. Joten i ++ - ja tämä yleinen konstruktio rivillä 7 on vain erittäin yleinen tapa toistamaan muutaman rivin koodi, jokin määrä kertoja. Mitkä riviä koodia? Nämä aaltosulkei-, kun saattanut poimittu nyt, tarkoittaa, toimi seuraavasti. 

Se on kuin Scratch, kun se on keltainen lohkojen ja muut värit tuollaista omaksua tai halata muita lohkoja. Se mitä nämä kihara olkaimet tekevät täällä. Joten jos sain syntaksin right-- sinulle näkee porkkana symboli C välineet niin monta kertaa olin yritetään ratkaista tämä ongelma. Joten päästä eroon, että yksi kokonaan, ja sulje se ikkuna. Ja käytämme uuteen. Tee ylivuoto, piste slash ylivuoto, Enter, kaikki hyvin, se näyttää pahalta aluksi. Mutta nyt selata ajassa taaksepäin, koska tein tämän 64 kertaa. 

Ja huomaa, ensimmäistä kertaa, n on 1. Toisen kerran, n on 2, Sitten 4, sitten 8, sitten 16. Ja näyttää siltä, ​​että niin pian kuin Saan noin 1 miljardi, jos en kaksinkertaistaa jälleen, että pitäisi antaa minulle 2 miljardia. Mutta näyttää siltä, ​​se on aivan partaalla. 

Ja niin se todella pursuaa int alkaen 1 miljardi karkeasti negatiivinen 2 miljardia, koska kokonaisluku, toisin kuin numerot me olivat olettaen viime viikolla, voi olla sekä positiivisia että negatiivisia todellisuudessa ja tietokoneen. Niin ainakin yksi näistä bittiä tehokkaasti varastettu. Niinpä me oikeastaan ​​vain 31 bittiä, tai 2 miljardia mahdollisia arvoja. 

Mutta nyt, takeaway on melko yksinkertaisesti, mitä nämä luvut ovat ja mitä matematiikka on, jotain pahaa tapahtuu lopulta, koska lopulta yrität permutoimaan bitit yksi liian monta kertaa. Ja te tehokkaasti menevät kaikki 1: n ja ehkä kaikki 0: n, tai ehkä vain joitakin muita malli, että se selvästi, riippuen asiayhteydestä, voidaan tulkita negatiiviseksi numero. Ja niin se näyttäisi korkein I voi laskea tässä nimenomaisessa ohjelmassa on vain noin 1 miljardi. Mutta on osaratkaisu täällä. Tiedätkö mitä? 

Saanen muuttuvat peräisin int pitkä pitkä. Ja anna minun mennä eteenpäin täällä ja say-- aion olla muuttaa tämä allekirjoittamaton pitkä. Tai, katsotaanpa, en koskaan muista itse. 

Mennään eteenpäin ja tehdä ylivuoto. Ei, se ei ole sitä, OTT, kiitos. Joten joskus Clang voi olla hyödyksi. En muista mitä muotoa specifier oli pitkään pitkään. 

Mutta todellakin, Clang kertoi. Green on jonkinlainen hyviä, edelleen sitä teit virheen. Se arvaamaan, että tarkoitin LLD. 

Joten Otan se neuvo, pitkä pitkä desimaaliluku, paitsi että. Ja anna minun uusintana se, dot slash ylivuoto, Enter. Ja nyt, mitä on siistiä tämä. 

Jos minä vierittää ajassa taaksepäin, vielä käynnisty laskenta samalla place-- 1, 2, 4, 8, 16. Ilmoitus, saamme kaikki asti 1 miljardi. Mutta sitten noustaan ​​2 miljardia. 

Sitten saamme 4 miljardia, sitten 8 miljardia, 17 miljardia. Ja me mennä enemmän, ja korkeampi, ja korkeampi. Lopulta tämäkin taukoja. 

Lopulta pitkä pitkä, joka on 64-bittinen arvo, ei 32-bittinen arvo, jos lasketaan liian korkea ja sitä kietoa 0. Ja tässä tapauksessa, me sattuvat päätyä negatiivinen luku. 

Eli tämä on ongelma. Ja käy ilmi, että tämä Ongelma ei ole kovin mystistä. Vaikka olen tarkoituksella aiheuttama sitä näitä virheitä, se kääntyy pois näemme sen tavallaan kaiken ympärillämme, tai ainakin jotkut meistä tekevät. 

Joten Lego Star Wars, jos olet koskaan pelannut peliä, se osoittautuu voit mennä ympäri rikkoa asioita LEGO maailmassa, ja kerätä kolikoita, olennaisesti. Ja jos olet koskaan pelannut tämä peli aivan liian paljon aikaa, koska tämä nimetön yksittäiset täällä teki, kokonaismäärä kolikoita, jotka voit kerätä on, näyttäisi siltä, ​​4 miljardia. 

Nyt se on todella pyöristetty. Joten LEGO yritti pitää asiat käyttäjäystävällinen. He eivät tee sitä tarkalleen 2 32 teho, per viime viikolla. Mutta 4 miljardia on syy. Näyttää siltä, ​​tämän tiedon perusteella, että LEGO, ja yritys, joka teki tämän todellinen ohjelmisto, päätti että Enimmäismäärä kolikoita käyttäjä voi kerääntyä on todellakin 4 miljardia, koska he valitsivat niiden koodin käyttää ei pitkään pitkään, ilmeisesti, mutta vain kokonaisluku, allekirjoittamattomasta kokonaisluku, vain positiivinen kokonaisluku, jonka max arvo on karkeasti se. No, tässä on toinen hauska yksi. Joten pelin Civilization, joka jotkut teistä saattavat tuntea, jossa käy ilmi, että vuosia sitten oli virhe tässä pelissä, jolloin jos rooliin Gandhi peliin, sen sijaan hänestä on hyvin pasifisti, sen sijaan oli uskomattoman, uskomattoman aggressiivinen, joissakin olosuhteissa. Erityisesti sillä tavalla, että Civilization teoksia on, että jos pelaaja, hyväksyä demokratia, sinun aggressiivisuus pisteet saa vähennetään kahdella, joten miinus miinus, ja sitten miinus miinus. 

Joten vähennä 2 alkaen todellinen iteroimalla. Valitettavasti jos iteroimalla on aluksi 1, ja vähennä 2 siitä hyväksymisen jälkeen demokratia kuten Gandhi täällä saattaisi ovat tehneet, koska hän oli hyvin passive-- 1 mittakaavassa aggressiivisuus. Mutta jos hän omaksuu demokratian, sitten hän kulkee 1 negatiiviseksi 1. 

Valitettavasti ne olivat käyttämällä unsigned numerot, mikä tarkoittaa, että ne käsitellään jopa negatiivista numeroita kuin ne olisivat positiivisia. Ja se osoittautuu, että positiivinen vastaava negatiivinen 1, tyypilliseen tietokoneohjelmat, on 255. Joten jos Gandhi hyväksyy demokratiaa, ja siksi on hänen aggressiivisuus pisteet laskivat, se todella koittavat 255 ja tekee hänestä eniten aggressiivinen luonne peliin. Joten voit googlettaa ylös tästä. Ja se oli todellakin vahingossa ohjelmointi bug, mutta joka on tullut varsin Lore lähtien. 

Siinä kaikki hauskaa ja söpö. Enemmän pelottavaa on, kun varsinainen reaalimaailman laitteita, eikä pelejä, nämä samat viat. Itse asiassa vain vuosi sitten artikkeli tuli ulos noin Boeing 787. 

Ja artikkeli ensin silmäyksellä lukee hieman mystistä. Mutta se sanoi, ohjelmisto haavoittuvuus Boeingin uusi 787 Dreamliner jet on voi aiheuttaa lentäjien hallinnan menetyksen ilma, mahdollisesti puolivälissä lennon, FAA virkamiehet varoitti lentoyhtiöt hiljattain. Se oli määritys että malli 787 lentokone, joka on kytketty yhtäjaksoisesti 248 päivää voivat menettää kokonaan vaihtovirran, AC, sähkövoimaa vuoksi generaattorin ohjausyksiköt, GCUs samanaikaisesti menee epäonnistua vikasietotilassa. Se on tavallaan menettää minua. Mutta muistio totesi, OK, nyt sain, että ehto johtui ohjelmisto laskuri sisäiset generaattorin ohjaus yksiköt, jotka vuotaa yli jälkeen 248 päivää jatkuvan tehon. Olemme julkaista tämän huomaa katoamisen estämiseksi Kaikkien vaihtovirtateknologialla voima, joka voi johtaa menetys ohjaamaan lentokonetta. 

Joten, kirjaimellisesti, on jonkin verran kokonaisluku, tai jostakin vastaavasta tietotyyppi, käytetään ohjelmistojen todellisessa lentokoneessa että jos pidät lentokone tarpeeksi kauan, mikä ilmeisesti voi olla, jos olet juuri käynnissä niitä jatkuvasti ja koskaan irrottamalla oman lentokone, näyttää siltä, ​​tai kerroit sen akut kuolee, lopulta laskea, ja ylös, ja ylös, ja ylös ja ylös, ja ylös. 

Ja luonnostaan, joka on rajallinen määrä muistia vuotaa yli, liikkuva takaisin nolla tai jokin negatiivinen arvo, sivuvaikutus, joka on pelottavan todellinen todellisuus että kone saattaa tarvita käynnistettävä uudelleen, tehokkaasti, tai voi pudota, pahempi, koska se lentää. Joten tällaisia ​​asioita ovat edelleen keskuudessamme, even-- tämä oli 2015 artikkelin, sitäkin pelottavaa kun et välttämättä ymmärtää, arvostaa, tai ennakoida tuollaiset virheet. 

Joten se kääntyy pois on olemassa yksi muu huono puoli datan esityksessä. On käynyt ilmi, että jopa kellukkeet ovat Tällainen virheellinen, koska kellukkeet, liian, Ehdotin ovat 32 bittiä, tai ehkä 64, jos käytät kaksinkertainen. Mutta se on silti rajallinen. 

Ja saalis on, että jos voit laittaa ääretön määrä numeroita desimaalipisteen jälkeen, ei ole mitään keinoa sinun voi edustaa kaikkia mahdollisia numeroita, jotka me opetettiin alakoulussa voi esiintyä maailmassa. Tietokone lähinnä, on valita osajoukko näitä numeroita edustaa tarkasti. 

Nyt tietokone voi pyöreä ehkä vähän, ja voi voit karkeasti tallentaa rajoittamattoman määrän saatat mahdollisesti haluta. Mutta intuitiivisesti, jos on rajallinen määrä bittejä, voit vain permute niitä niin monella rajallinen tavoin. Joten et voi mahdollisesti Käytä rajallinen määrä permutaatiomat- bittien, malleja nollia ja ykkösiä, edustamaan ääretön määrä numeroita, mikä viittaa siihen, että tietokoneet saattavat hyvinkin olla valehtelee meille joskus. 

Itse asiassa, tehdään tämä. Anna minun mennä takaisin CS50 IDE. Anna minun mennä eteenpäin ja luoda pieni ohjelma kutsuttu epätarkkuus, jotka osoittavat, että tietokoneet ovat todellakin epätarkka. 

Ja anna minun mennä eteenpäin ja aloittaa joitakin että koodin ennen, ja nyt vain toimi seuraavasti. Anna minun mennä eteenpäin ja tehdä printf, prosenttia f, kenoviiva n, 1 jaettuna 10. Toisin sanoen, nyt sukeltaa syvemmälle 1/10, kuten 1 ja jaettuna 10. Varmasti, tietokone voi edustaa 1/10. 

Joten mene eteenpäin ja tehdä epätarkkuus. Katsotaan. Muoto määrittelee tyypin kaksinkertainen. Mutta väite on tyyppiä int. Mitä tapahtuu? 

Voi, mielenkiintoinen, joten se on opetus oli ennen. Sanon, hei, tietokone näyttää minulle float prosenttia f. Mutta annan sen 2 ints. Joten se kääntyy pois, voin korjata tämä pari tapaa. 

Voisin vain kääntää One 1.0, ja 10 otetaan 10,0, mikä todellakin vaikutuksesta muuntaa ne floats-- edelleen toivottavasti sama numero. Tai se osoittautuu on jotain näemme taas ennen pitkää. Voisit heittää numeroita. 

Voit käyttää tätä sulkumerkintä lauseke, voit sanoa, hei, tietokone, ota tämä 10, jonka tiedän on int. Mutta hoitamattomana kiitos, ikään kuin se on float. Mutta tämä tuntuu tarpeettoman monimutkainen. 

Meidän tarkoituksiin tänään, Haluan vain kirjaimellisesti tekevät niistä liukulukuarvoja joiden desimaalierottimen näin. Anna minun mennä eteenpäin ja uusinta, tee epätäsmällisyys, hyvä, piste slash epätäsmällisyys, kirjoita. OK, etsimme hyvää. 

1 jaettuna 10, saamieni Mac täällä, on todellakin 0,100000. Nyt minulle opetettiin alakoulussa siellä pitäisi olla ääretön määrä 0: n. Joten ainakin yrittää nähdä joitakin niistä. On käynyt ilmi, että printf on hieman harrastaja silti kuin olemme käyttäneet. On käynyt ilmi, sinun ei tarvitse määrittää vain prosentin f, tai vain prosentti i. Voit itse määrittää jotkut ohjaus vaihtoehtoja täällä. 

Erityisesti aion sanoa, hei, printf, oikeastaan ​​näytä minulle 10 desimaaliin. Joten se näyttää hieman outo. Mutta te sanotte prosenttia, piste, kuinka monta numeroa haluat nähdä jälkeen desimaalipilkun, ja sitten f Litteiden, vain koska se on mitä dokumentaatio sanoo. Anna minun mennä eteenpäin ja tallenna se. 

Ja huomaa myös, Saan väsynyt retyping asioita. Joten olen vain asettamalla ylös ja alas nuoli minun avaimet tänne. Ja jos minä pitää lyödä ylös, sinun voi nähdä kaikkien komentojen että tein, tai väärin tehty. 

Ja aion mennä eteenpäin nyt ja ei oikeastaan ​​käyttää tätä, ilmeisesti. Tee epätäsmällisyys, dot slash imprecision-- niin mitä opetettiin asteella tarkastusten perusteella. Vaikka olen tulostaa sen 10 desimaalin asettaa se, todellakin on 0,10000. Mutta tiedätkö mitä? 

Mennään hieman ahne. Sanotaan, kuten, näytä minulle 55 huomauttaa jälkeen desimaalin. Katsotaan todella ottaa tämän ohjelmoida ulos spin. Saanen sen uudestaan ​​make epätäsmällisyys, piste slash, epätarkkuus. 

Ja tässä mennään. Lapsuuden oli valhe. Ilmeisesti 1 jaettuna 10 on todellakin 0.100000000000000005551115123-- 

Mitä tapahtuu? No, se kääntyy pois, jos sellainen Katso riittävän ulos taustalla edustus tästä numero, se todella ei ole juuri 1/10 tai 0,1 ja ääretön määrä nollia. Nyt Miksi? 

No, vaikka tämä on yksinkertainen numeron meille ihmisille, 1 jaettuna 10, se on edelleen yksi äärettömän monta numeroita että voisimme ajatella. Mutta tietokone voi edustaa vain äärellisen monta niin numeroita. Ja niin tehokkaasti, mitä tietokone näyttää meille on sen lähin approksimaatio numero Haluamme uskoa on 1/10, tai oikeastaan ​​0,10000 loputtomiin. 

Pikemminkin, vaikka tämä on niin lähellä kuin se voi saada. Ja todellakin, jos tarkastellaan alla huppu, koska olemme täällä tarkastelemalla 55 desimaalilla, me itse nähdä, että todellisuus. Nyt kun Sivuhuomautuksena, jos olet koskaan nähnyt movie-- useimmat varmaan haven't-- mutta Superman 3 muutama vuosi sitten, Richard Pryor olennaisesti panostettava tähän todellisuus hänen yrityksensä varastaa paljon Fraktioiden ja jakeet penniä, koska company-- muistaakseni, se on ollut while-- oli olennaisesti heittää pois mitään, mikä ei sopinut osaksi käsite senttiä. 

Mutta jos lisäät kaikki nämä pieni, pieni, pieni määrä uudestaan, ja uudestaan, ja uudestaan, voit, kuten hänen tapauksessa tehdä hyvä määrä rahaa. 

Tämä sama ajatus oli huijannut uudempi, mutta silti nyt vanhemmat elokuva, nimeltään Office Space, jossa kaverit siinä elokuvassa, teki saman, ruuvata se ylös täysin, päätyi aivan liikaa rahaa niiden pankkitilille. Se oli hyvin epäilyttävä. Mutta lopussa päivä, epätäsmällisyys on kaikkialla ympärillämme. 

Ja myös, voi olla pelottavan tapauksessa. On käynyt ilmi, että Superman 3 ja Toimistotilaa sivuun, siellä voi olla joitakin hyvin todellinen maailma seurauksia realiteetit epätarkka tietojen esittämisessä että vaikka me ihmisten tämä päivä ei välttämättä ymmärtää samoin kuin meidän pitäisi, tai muistaa niin usein kuin pitäisi. Ja todellakin, seuraavat leike on mistä katsomaan joitakin hyvin todellinen maailma seurauksia, mitä tapahtuu, jos eivät ymmärrä epätarkkuus että voi tapahtua numeroita edustus. 

[VIDEOTOISTOSTA] 

-Tietotekniikka, Olemme kaikki tulleet hyväksyä usein turhauttavaa ongelmia, mennä them-- vikoja, viruksia, ja ohjelmistot glitches, Pienten hinta maksaa helpotukseksi. Mutta korkean teknologian ja nopea sotilas- ja avaruusohjelma sovelluksia, pienin ongelma voi suurennetaan katastrofiin. 

4. kesäkuuta, 1996 tutkijat valmistettu käynnistää miehittämättömän Ariane 5 raketti. Se kantoi tieteen satelliitit suunnitellut vahvistaa tarkasti, kuinka Maan magneettikenttä toimii vuorovaikutuksessa aurinko tuulet. Raketti rakennettiin Euroopan avaruusjärjestön ja nostetaan pois sen laitos rannikolla Guyanassa. 

-At Noin 37 sekunnin lennon, he ensin huomasi jotain oli vialla. Suuttimet oli kääntyvä vuonna tapa ne todella pitäisi. Noin 40 sekunnin lennon, selvästi, ajoneuvo oli vaikeuksissa. 

Ja silloin he tekivät päätöstä tuhota sen. Valikoima turvallisuusvastuuhenkilön, jossa valtava suolet, painetaan nappia, räjähti raketti, ennen kuin se voisi tullut vaaran yleiselle turvallisuudelle. 

-Tämä Oli neito matkasta Ariane 5. Ja sen tuhoamista otti aseta koska virhe upotettu raketin ohjelmisto. -The Ongelma Ariane oli että oli useita, että vaaditaan 64 bittiä ilmaista. Ja he halusivat muuntaa se on 16-bittinen numero. Ne olettaa, että numero ei koskaan tule erittäin suuri, että useimmat niistä numerot 64-bittinen numero olivat nollia. He olivat väärässä. 

-edellä Kyvyttömyys yhden ohjelma hyväksyä sellainen määrä tuottaman toinen oli juureen epäonnistumisen. Ohjelmistojen kehittäminen oli tullut kalliiksi osa uutta teknologiaa. Ariane raketti ovat olleet hyvin onnistuu, niin ohjelmisto luotu se oli myös käytetty Ariane 5. 

-The Perusongelmana oli, että Ariane 5 oli nopeampi, kiihtyi nopeammin. Ja ohjelmisto ei ollut osuus siitä. 

-The Tuhoaminen raketti oli valtava taloudellinen katastrofi, kaikki johtuu minuutti ohjelmistovirhe. Mutta tämä ei ollut ensimmäinen aika tietojen muuntaminen ongelmat oli vaivannut moderni ohjusteknologia. 

-In 1991 käynnistäen Ensimmäisen Persianlahden sodan, Patriot Missile kokenut samantyyppinen Numeron muuntaminen ongelma. Ja sen seurauksena, 28 ihmistä, 28 amerikkalaista sotilasta, kuoli, ja noin 100 toiset haavoittui, kun Patriot, joka piti suojautua saapuvat scuds, ei osunut. 

-Kun Irak hyökkäsi Kuwaitiin, ja Amerikassa käynnistettiin Aavikkomyrskyn vuoden 1991 alussa, Patriot Missile akut lähetettiin suojella Saudi-Arabia ja Israel Irakin Scud ohjus hyökkäyksiä. Patriot on US keskipitkän kantaman pinta ilmaan järjestelmä, valmistettu jonka Raytheon yhtiö. 

-The Koko Patriot torjuntahävittäjä itsessään on noin noin 20 jalkaa pitkä. Ja se painaa noin 2000 kiloa. Ja se harjoittaa taistelukärjestä noin, Minusta se on noin 150 kiloa. Ja taistelukärki itsessään korkea räjähtävä, joka on fragmentteja sen ympärille. Koteloa taistelukärki on tarkoituksena on toimia kuten buckshot. 

-The Ohjuksia kuljetetaan neljä per kontti, ja kuljetetaan puoliperävaunu. 

-The Patriot ohjuspuolustusjärjestelmää ulottuu vähintään 20 vuotta. Se oli alun perin suunniteltu kuin ilmatorjuntaohjusjärjestelmään ampua alas vihollisen lentokoneita. Ensimmäisessä Persianlahden sodan, kun se sota tuli mukaan, armeijan halusi käyttää sitä ampua alas scuds, ei lentokoneita. 

Irakin Air Force oli ei niin suuri ongelma. Mutta armeija oli huolissaan scuds. Ja niin he yrittivät päivittää Patriot. 

-Intercepting Vihollinen ohjus kulkee Mach 5 tultaisiin riittävän haastava. Mutta kun Patriot kiidätettiin laskemista, armeija ei ollut tietoisia Irakin muutos, joka teki niiden scuds lähes mahdotonta lyödä. 

Mitä tapahtui on scuds että oli tulossa oli epävakaa. Heidät huojuu. Syynä tähän oli irakilaisia, jotta päästä 600 km ulos 300 kilometrin kantaman ohjusten, otti paino pois edestä taistelukärki. He tekivät taistelukärki kevyempi. 

Joten nyt Patriot on yrittää tulla klo Scud. Ja suurimman osan ajasta, Valtaosa ajasta, se vain lentää, jonka Scud. Kun Patriot-operaattoreille tajusi Patriot jäi kohteeseensa, ne räjäytetään Patriot ydinpommi vältetään mahdolliset tappiot, jos se annettiin pudota maahan. 

-Se Oli mitä useimmat ihmiset näkivät, näitä suuria tulipalloja taivaalla, ja ymmärtää väärin kuuntelevansa Scud taistelukärkiä. 

-Vaikka Yöllä taivas, Patriots ilmestyi olla onnistuneesti tuhoaa Scuds kello Dhahran, ei voi olla virhe sen toiminnasta. Siellä Patriot tutkajärjestelmän kadottaa saapuvasta Scud, ja ei koskaan käynnistetty takia ohjelmaongelmaan virhe. Se oli israelilaisia, joka ensimmäisenä löysi että enää järjestelmä oli, sitä suurempi aika ristiriita tuli, koska kellon sulautettujen järjestelmän tietokoneelle. 

-Noin Kaksi viikkoa ennen tragedia Dhahran, israelilaiset raportoidaan puolustusministeriö että järjestelmä oli menettää aikaa. Noin kahdeksan tuntia tai käynnissä, he huomasivat, että järjestelmä oli tulossa huomattavasti epätarkempi. Puolustusministeriö vastasi kertoo kaikki Patriot akkujen ja jätä järjestelmiä on pitkään. He eivät koskaan sanoi mitä pitkään was-- kahdeksan tuntia, 10 tuntia, 1000 tuntia. Kukaan ei tiennyt. 

-The Patriot akku sijoitettiin kasarmin at Dhahran ja sen puutteellinen sisäinen kello oli ollut yli 100 tuntia yönä helmikuun 25. päivä. 

-Se Seurataan aika tarkkuudella noin kymmenesosa toinen. Nyt kymmenesosa toinen on mielenkiintoinen numero, koska se ei voi ilmaista binary tarkalleen, mikä tarkoittaa sitä ei voida ilmaista tarkasti, missä tahansa nykyaikaisessa digitaalisen tietokoneen. On vaikea uskoa. 

Mutta käyttää tätä esimerkkinä. Otetaan numero yksi kolmasosa. Kolmasosa ei voi olla ilmaistaan ​​desimaalilukuna tarkalleen. Kolmannes on 0,333 jatkunut äärettömyyteen. 

Ei ole mitenkään tehdä sitä absoluuttinen tarkkuus desimaalin. Juuri sellainen ongelma että tapahtui Patriot. Mitä pidempi järjestelmä juoksi, The huonompi aika virhe tuli. 

-Kun 100 tunnin toimintaa, virheestä ajassa oli vain noin kolmannes toisen. Mutta mitä kohdistaminen ohjus kulkee Mach 5, se johti seuranta virhe on yli 600 metriä. Olisi kohtalokas virhe sotilaat mitä tapahtui on Scud käynnistää oli havaitaan varhaisessa vaiheessa varoitus satelliittien ja he tiesivät, että Scud oli tulossa niiden yleistä suuntaa. He eivät tiedä, missä se oli tulossa. 

-Se Oli nyt jopa tutka komponentti Patriot järjestelmän puolustavat Dhahran paikantaa ja pitää Seuraa saapuvan vihollisen ohjus. 

-The Tutka oli hyvin älykäs. Olisi todella seurata asento Scud, ja sitten ennustaa missä se todennäköisesti olisi seuraavan kerran tutka lähetetään pulssi ulos. Tämä kutsuttiin erilaisia ​​portti. 

-Sitten, Kun Patriot päättää tarpeeksi aikaa on välitetään mennä takaisin ja tarkista seuraava paikka tälle havaittu kohde, se menee takaisin. Joten kun se meni takaisin väärään paikka, sitten se ei näe mitään esinettä. Ja se päättää, että ei ole esine, se oli väärä tunnistus, ja laskee radan. 

-The Saapuva Scud katosi tutkanäytöltä. Ja sekuntia myöhemmin, se lyönyt kasarmiin. Scud tappoi 28, ja oli viimeinen yksi ampui ensimmäisen Persianlahden sodan. 

On traagista, päivitetty ohjelmisto saapui Dhahran seuraavana päivänä. Ohjelmisto virhe oli ollut kiinteä, sulkeminen yksi luku levoton historiasta Patriot ohjus. 

[VIDEOTOISTOSTA] DAVID J. MALAN: Eli tämä on kaikki sanoa, että nämä kysymykset ylivuoto ja epätarkkuus ovat liian todellinen. Miten tähän on tultu? Aloitimme puhu vain printf. Tämäkin toiminto tulostaa jotain näyttöä, ja toimme sen jälkeen muutamia muita toimintoja alkaen ns CS50: n kirjasto. Ja jatkamme katso nämä aikanaan. Ja me, erityisesti, käyttää get merkkijono, ja saada int, ja nyt myös saada kellua, ja vielä toiset silti kohtaamme ja käyttää itse ennen pitkää. 

Mutta toisinaan, on me jo nähneet tarvetta tallentaa mitä nämä tehtävät käsin takaisin? He käsi meidät takaisin merkkijono, tai int tai float. Ja joskus meidän täytyy laittaa, että string, tai int tai float, jonnekin. 

Ja tallentaa ne asiat, muistaa vain kuten Scratch, olemme muuttujia. Mutta toisin Scratch, C meillä on todellinen tyypit of variables-- data tyypit, lisää generally-- niiden joukossa, merkkijono, int, joka on kellua, ja nämä toiset vielä. 

Ja niin kun me julistaa muuttujia C, meidän täytyy julistaa meidän tietotyyppejä. Tämä ei ole jotain me will täytyy tehdä myöhemmin lukukauden kuten siirtyminen muille kielille. Mutta nyt, tarvitsemme joka priori etukäteen, selittää tietokoneeseen minkälaista muuttuvan haluamme antaa meille. 

Nyt puolestaan ​​tulostaa tuollaiset tietotyyppejä, meidän on kerrottava printf mitä odottaa. Ja näimme prosentin s jousille, ja prosenttia i kokonaislukuja, ja muutama muu jo. Ja ne ovat yksinkertaisesti vaatimukset visuaalisen esityksen nämä tiedot. 

Ja jokainen näistä voi todella olla parametrized tai viritetty jollakin tavalla, jos haluat edelleen ohjaus tyyppi tuotoksen että saat. Ja itse asiassa, käy ilmi, että ei ainoastaan on olemassa backslash n uuden linjan. On jotain muuta kutsutaan kenoviiva r rivinvaihto, joka on lähempänä vanha koulu kirjoituskone, ja myös Windows käytetty jo useita vuosia. 

On backslash t välilehdet. Osoittautuu, että jos haluat lainausmerkki sisällä merkkijono, muistuttaa, että olemme käyttäneet lainausmerkki double lainaus vasemmalla ja oikealla päättyy meidän jousille toistaiseksi. Tämä näyttäisi sekoittaa asioita. 

Jos haluat laittaa lainausmerkki vuonna keskellä string-- ja, todellakin, se on hämmentävää nähdä. Ja niin sinun täytyy paeta, niin puhua, kaksinkertainen lainata jotain kuten, kirjaimellisesti, Kenoviiva lainausmerkki. Ja siellä on muutamia muita vielä. Ja näemme enemmän näistä todellisessa käytössä ennen pitkää. 

Joten nyt siirtyminen data, ja edustus, ja aritmeettiset operaattorit, kaikki joista antoi meille jonkin rakennuksen lohkojen joka pelata. Mutta nyt katsotaanpa todella antaa meille loput sanaston että meillä oli jo viime viikolla Scratch ottamalla tarkastella joitakin muita konstruktioita in C-- ei niitä kaikkia. Mutta ideat olemme tulleet oikeastaan ​​vain korostaa käännös yksi kieli, Scratch, toiseen, C. 

Ja ajan myötä, me poimia lisää työkaluja meidän työkalupakki, niin sanotusti syntaktisesti. Ja todellakin, näet, että ideat ovat nyt melko tuttuja viime viikolla. Joten tehdään tämä. 

Mennään eteenpäin ja lietsoa ohjelma joka todella käyttää joitakin ilmaisuja, Boolen lauseke. Anna minun mennä eteenpäin täällä ja luo uuden tiedoston. Soitan tämän condition.c. 

Anna minun mennä eteenpäin ja sisältävät CS50 kirjasto. Ja anna minun mennä eteenpäin ja sisältävät standardi IO.h meidän toimintoja, ja printf, ja lisää vastaavasti. Annan itselleni että boilerplate of int main mitätön, jonka selitys me will palata tulevaisuudessa. 

Nyt haluan mennä eteenpäin ja antaa Itse int kautta get int. Sitten anna minun mennä eteenpäin ja tehdä tätä. Haluan sanoa, jos i on less-- katsotaanpa erottaa positiivinen, negatiivinen, tai nolla-arvot. 

Joten jos i on pienempi kuin nolla, anna minun on vain tämä ohjelma yksinkertaisesti sanoa, negatiivinen, kenoviiva n, muu Jos i on suurempi kuin nolla. Nyt olen tietenkin aikoo sanoa printf positiivinen, kenoviiva n. Ja sitten muu if-- voisin tehdä tätä. 

Voisin tehdä, jos i on yhtä suuri kuin 0. Mutta olisin päätöksenteon Ainakin yksi virhe jo. Muista, että yhtäläisyysmerkki on erisuuri, koska me ihmiset tunnemme. 

Mutta se on tehtävä operaattori. Ja me emme halua ottaa 0 annetun oikealle ja laita se i vasemmalla. Joten välttää tämän sekaannuksen, tai ehkä väärinkäyttö yhtäläisyysmerkin, ihmisillä päätti joitakin vuosia sitten että monissa ohjelmointikielissä kun haluat tarkistaa tasa vasemman ja oikean, te itse käyttää yhtä kuin tasavertaisina. Joten osut yhtäsuuruusmerkkiä kahdesti. Kun haluat määrittää oikealta vasemmalle, käytät yhden yhtäläisyysmerkki. Jotta voisimme tehdä this-- muuta jos i on yhtä suuri kuin nolla. 

Voisin sitten mennä ja avaan aaltosulkeita, ja sanoa, printf 0, kenoviiva n, tehty. Mutta muista, miten nämä haarautuu tie voi toimia. Ja todellakin, ajattele logiikka. i on useita. Se on kokonaisluku, erityisesti. Ja se tarkoittaa se tulee olemaan vähemmän kuin 0 tai suurempi kuin 0, tai 0. On siis olemassa sellaista tämän implisiittinen oletusmarginaali. 

Ja jotta voisimme, aivan kuten Scratch, luopua if, ja vain sanoa muuta. Loogisesti, jos sinulle ohjelmoija tietää on vain kolme kauhat, johon skenaario voi fall-- ensimmäinen, Toisen tai kolmannen Tässä case-- eivät vaivaudu lisäämällä ylimääräisiä tarkkuus ja lisälogiikka siellä. Vain mennä eteenpäin kanssa Oletuksena tässä tapauksessa on muu. 

Nyt mennään eteenpäin tallennuksen jälkeen tämä, tee olosuhteet piste slash conditions-- ole suuri käyttöliittymä, koska en ole kehotukset käyttäjä, kuten aiemmin mainitsin. Mutta se käy hyvin. Me pitää se yksinkertainen. Yritetään numero 42. Ja se on positiivinen. Kokeillaan numero negatiivinen 42, negatiivinen. 

Kokeillaan arvo 0. Ja, todellakin, se toimii. Nyt näet ongelmia ennen pitkä, testaus asiat kolme kertaa, todennäköisesti riitä. Et luultavasti halua testata joitakin isompi numeroita, jotkut pienempiä numeroita, jotkut kulma tapauksissa, kuten tulemme kuvaamaan niitä. 

Mutta nyt, tämä on melko yksinkertainen ohjelma. Ja olen melko varma, loogisesti, että se kuuluu kolme tapausta. Ja tosiaankin, vaikka me vain keskitytty mahdollisten haittoja epätarkkuuden ja ylivuoto, vuonna Todellisuudessa jossa monet CS50 ongelmia, emme aio huolehtia noin, koko ajan, näitä kysymyksiä ylivuodon ja epätäsmällisyys, sillä itse asiassa C, se on itse asiassa ole kovin helppo välttää niitä asioita. Jos haluat laskea isompi, ja isompi, ja isompi, se kääntyy pois on tekniikoita olet voi käyttää, joihin liittyy usein asioita kutsutaan kirjastoja, kokoelmia koodin, joka muut ihmiset kirjoitti, että voit käyttää, ja muut kielet kuten Java ja muut, itse asiassa tehdä paljon helpompaa laskea jopa korkeampi. Niin se todella on joitakin näistä vaaroista funktio käyttämäsi kielen. Ja tulevina viikkoina käymme kuinka vaarallista C todella voi olla, jos et käytä sitä oikein. Mutta sieltä, ja Python ja JavaScript, on me kerros joitakin ylimääräisiä suojauksia, ja ajaa vähemmän näiden riskien. 

Joten tehdä hieman enemmän mielenkiintoinen logiikka ohjelmaamme. Joten anna minun mennä eteenpäin ja luoda ohjelma nimeltä Looginen vain jotta voin leikkiä joitakin Varsinainen logiikka, logical.c. Otan vain kopioida ja liittää joitakin koodi aikaisemmin niin saan takaisin Tämän mukava lähtökohta. 

Anna minun tällä kertaa tehdä char C. Olen aio antaa sille nimi C vain koska se on tavanomainen, saat merkin käyttäjältä. Ja Teeskennelläänpä kuten Olen osan täytäntöönpanossa Kyseisen Rm ohjelman remove ohjelma ennen kehotuksen käyttäjä poistaa tiedoston. Miten teemme tämän? 

Haluan sanoa, jos C on yhtä suuri kuin on yhtä suuri kuin, lainaus lainaus päättyy, y, niin aion olettaa että käyttäjä on valinnut kyllä. Olen juuri menossa painoon kyllä. Jos se oli todella kirjallisesti poisto-ohjelma, voisimme poistaa tiedoston enemmän riviä koodia. Mutta me pitää se yksinkertainen. 

If c on yhtä kuin yhtä kuin n- ja nyt täällä, aion sanoa, käyttäjän on tarkoittanut mitään. Ja sitten muuta, tiedätkö mitä? En tiedä mitä muuta käyttäjän tulee kirjoittaa. Joten olen juuri menossa sanoa, että että on virhe, mitä hän todella kirjoitettu. 

Joten mitä täällä tapahtuu? On perustavanlaatuinen ero versus mitä olen tehnyt aikaisemmin. Lainausmerkkeihin, lainausmerkit, double lainauksia, ja, vielä, heittomerkkejä, heittomerkkeihin. On käynyt ilmi C, että kun haluat kirjoittaa merkkijonon, et käytä lainausmerkkejä, aivan kuten olemme käyttänyt kaikki tällä kertaa printf. 

Mutta jos haluat käsitellä vain yhden merkin, ns nieriä, sitten todellisuudessa käytettiin heittomerkkeihin. Ne teistä, jotka ovat ohjelmoitu ennen, ei ehkä ole oli huolestua erottelu tietyillä kielillä. In C, sillä on väliä. Ja niin kun saan char ja haluan vertailla, että char käyttäen tasavertaisten on yhtä kuin jotkut kirjain, kuten y tai n, teen, todellakin, täytyy olla puolilainausmerkkejä. 

Nyt mennään eteenpäin ja tehdä tätä. Mennään eteenpäin ja tekevät looginen piste slash looginen. Ja nyt Minua pyydetään. Joten, oletettavasti, paremman käyttökokemuksen itse asiassa kerro, mitä tehdä täällä. Mutta aion vain sokeasti sanoa y for kyllä, OK, mukava. 

Oletetaan ajaa sen uudestaan, n ilman, mukava. Oletetaan kuten tietyt ihmiset tiedän, minun lukitusnäppäin on aivan liian usein. Joten en pääoma Y, kirjoita, virhe. OK, se ei ole, mitä olen odottanut. Todellakin, tietokone tekee kirjaimellisesti mitä Kerroin sen do-- tarkistaa pieniä y ja pieniä n. Tämä ei tunnu hyvältä käyttökokemuksen, vaikka. Saanen kysyä ja hyväksyn joko pienet kirjaimet tai isot kirjaimet. Joten se kääntyy pois, haluat ehkä sanoa jotain Scratch, kuten kirjaimellisesti tai C yhtä suuri kuin on yhtä kuin pääoman yhden lainattu y. Osoittautuu, C ei ole Tämän kirjaimellinen avainsanan tai. 

Mutta siinä on kaksi pystysuoraa baaria. Sinun täytyy pitää Shift yleensä, Jos käytät Yhdysvaltain näppäimistö, ja osui pystypalkki avain yläpuolella enteriä. Mutta tämä pystypalkki pystyviiva tarkoittaa tai. 

Jos sitä vastoin halusimme sanoa ja, kuten Scratch, voisimme tehdä ampersand ampersand. Siinä ei ole mitään loogista järkeä täällä, koska ihmisen ei mitenkään kirjoitit sekä y että pieniä y ja pääoma Y samaa merkkiä. Joten vai mitä aiomme täällä. 

Joten jos en tee tätä molemmissa paikoissa, tai c on yhtä kuin yhtä suuri kuin pääoman N, nyt uusintana, tehdä loogisia, aloita looginen. Nyt voin kirjoittaa y. Ja voin tehdä sen uudelleen pääoma Y, tai pääoman N. Ja voisin lisätä ylimääräisiä yhdistelmät edelleen. 

Joten tämä on looginen Ohjelma sikäli kuin nyt Olen tarkkailun loogisesti tämä arvo tai tätä arvoa. Enkä tarvitse välttämättä, keksiä kaksi ifs tai muuten IFS. Itse asiassa voin yhdistää joitakin logiikan yhteen tällä tavalla. Joten tämä olisi parempi suunniteltu pelkästään sanomalla, jos C on yhtä pieniä kirjaimia y, tulostaa kyllä, muuta, jos c on yhtä kuin pääoman Y, tulostaa kyllä, muuten jos c on yhtä suuri kuin lower-- Toisin sanoen, sinun ei tarvitse olla enemmän ja enemmän oksia. Voit yhdistää joitakin vastaavia oksat loogisesti, koska tällä tavalla. 

Joten katsomaan vain yhdellä lopullinen ainesosa, yksi lopullisen rakenteen, että C avulla. Ja tulemme takaisin Tulevaisuudessa muille edelleen. Ja sitten me päätellä tarkastelemalla at ei oikeellisuutta code-- saada koodin work-- mutta suunnittelu koodia, ja istuttaa ne siemenet varhain. 

Joten anna minun mennä eteenpäin ja avata uuden tiedoston täällä. Tiedätkö mitä? Aion uudelleen toteuttamaan että samaa ohjelmaa, mutta eri konstruktia. 

Haluan siis nopeasti antaa itselleni pääsy ovat CS50.h että CS50 kirjasto, standardi Io.h varten printf. Anna minulle int main mitätön. Ja sitten täällä, anna minun mennä eteenpäin ja tehdä tätä. 

Char c saa päästä nieriä, aivan kuten ennenkin. Ja aion käyttää uutta konstruktio now-- kytkin, mitä merkki? Joten kytkin on ikään kuin kytkentä juna kappaleita. Tai oikeastaan, se on eräänlainen if else, jos if, mutta kirjoitettu hieman eri tavalla. 

Kytkin näyttää tältä. Sinulla on kytkin, ja mitä sitten merkki tai numero, jonka haluat katsoa, Sitten jotkut aaltosulkeita like in Scratch, sano tehdä tätä kamaa. Ja sitten on erilaisia ​​tapauksia. 

Et käytä jos ja muuta. Sinä kirjaimellisesti käyttää sanaa tapaus. Ja sanoisit jotain tällaista. 

Joten kyseessä on pieniä y, tai jos kyseessä on pääoman Y, mennä eteenpäin ja tulostaa kyllä. Ja sitten puhkeaa kytkimen. Se siitä. Olemme valmiit. 

If, niin sanotusti, pienet kirjaimet n, tai pääoman N, sitten mennä eteenpäin ja tulostaa out ei, ja sitten tauko. Else-- ja tällainen on oletusmarginaali indeed-- printf error-- ja vain hyvä toimenpide, vaikka loogisesti tämä tauko ei ole välttämätöntä koska olemme lopussa kytkimen tapauksessa, Olen nyt murtaa pois kytkin. Joten tämä näyttää hieman erilainen. 

Mutta, loogisesti, se on vastaa todellisuudessa. Ja miksi käytät yksi yli muiden? Joskus vain henkilökohtaisista mieltymyksistä, joskus estetiikka, jos Vilkaisen tämän Nyt on jotain sanottava, että luettavuus tämän koodin. Siis, puhumattakaan siitä, että tämä koodi on uusi monille meistä huoneessa. 

Mutta se juuri sellainen on melko. Katsos pieniä y, pääoma Y, pienet kirjaimet n, pääoma N oletus, se juuri sellainen hyppää ulos sinua tavalla että, luultavasti, ehkä edellisessä esimerkissä kanssa IFS ja pystypalkit, ja muuten IFS, ei välttämättä ole. Eli tämä on oikeastaan ​​kyse henkilökohtaisista valinta, todella, tai luettavuutta, koodin. 

Mutta kannalta toiminnallisuus, haluan mennä eteenpäin ja tehdä kytkin, piste slash kytkin, ja nyt kirjoittaa pieniä kirjaimia y, pääoma Y, pienet n, pääoman N, David, uudelleen koska se on ei yksi merkki. Tehdään x, virhe, odotetusti. Ja logically-- ja tämä on jotain Kannustan in general-- jopa vaikka olemme vain naarmuttamista pinta joitakin näistä ominaisuuksista. 

Ja se ei ehkä ole ilmeinen, kun itse istuutua näppäimistö, miten tämä toimii? Mitä tämä tekee? Kaunis asia ottaa kannettavan tietokoneen tai työpöydällä, tai käyttää tietokoneeseen, jossa on kääntäjä, ja koodieditori näin, on voit melkein aina vastata näihin kysymykset itse vain yrittää. 

Esimerkiksi jos retorisen kysymys käsillä olivat, mitä tapahtuu, jos unohdat tauko lausuntoja? Joka on itse asiassa hyvin yleinen asia tehdä, koska se ei näytä kuten todella tarvitset niitä. He eivät todellakaan kruunaavat ajatellut kuten suluissa tai kihara ahdin tekee. Mennään eteenpäin ja kääntää koodin ja nähdä. Joten kytkin, piste slash kytkin. Katsotaan kirjoittaa pienillä kirjaimilla y, ylhäältä tapauksessa Enter. Joten olen kirjoittanut y. 

Ohjelma sanoi kyllä, ei, virhe, ikään kuin se muuttaa käsitystään. Mutta se sellainen oli, koska mitä tapahtuu kytkimellä on ensimmäinen tapaus, joka ottelu tarkoittaa sitä, hei tietokone, suorittaa kaikki koodi alla. Ja jos et sano taukoa, tai älä sano taukoa, tai eivät sano taukoa, tietokone räjäyttää läpi kaikki nämä rivit ja suorittaa ne kaikki kunnes se pääsee että kihara ahdin. Joten jarruilla todellakin tarpeen. Mutta takeaway tässä, kun epävarma, kokeilla jotain. Ehkä tallentaa koodin ensimmäinen, tai tallentaa sen ylimääräinen tiedostoon jos olet todella huolissaan Messing ja ottaa talteen työtä, jota tiedät toimivan. 

Mutta yritä asiat. Ja älä niin pelätä, ehkä, mitä tietokone voisi tehdä, tai että saatat rikkoa jotain. Voit aina palata takaisin jossain aiemmassa versiossa. 

Joten lopettaa katsomalla suunnitteluvaiheessa koodia. Meillä on tämä kyky nyt kirjoittaa olosuhteet, ja kirjoittaa silmukoita, ja muuttujia, ja puhelutoiminnot. Joten rehellisesti, olemme tavallaan takaisin jossa olimme viikko sitten Scratch, vaikkakin vähemmän pakottavia tekstisisällön ympäristö kuin Scratch sallii. 

Mutta huomaa, miten nopeasti olemme hankkinut että sanastoa, vaikka se on vie vähän aikaa uppoavat, jotta voimme nyt käyttää tätä sanastoa kirjoittaa enemmän mielenkiintoisia ohjelmia. Ja sallikaa vauva askel kohti tuota, seuraavasti. Anna minun mennä eteenpäin ja luo uuden tiedoston täällä. 

Aion kutsua tätä prototype.c, ja ottaa käyttöön ensimmäistä kertaa, kyky tehdä omia toimintoja. Jotkut teistä saattaa olla tehnyt tämän Scratch, jolloin voit luoda omia lohkojen Scratch, ja vedä ne paikoilleen minne haluat C. Ja useimmissa ohjelmointi kieliä, voit tehdä juuri that-- tehdä omia toimintoja, jos ne eivät ole jo olemassa. 

Niinpä esimerkiksi, anna minun mennä eteenpäin ja ovat CS50.h, ja ne sisältävät standardi IO.h, int main mitätön. Ja nyt meillä on paikkamerkkikentät valmiina. En pidä tulostus asioita kuten ihmisten nimet tänään. Ja se tuntuu like-- ei olisi mukavaa, jos siellä oli toiminto nimeltään nimenselvennys? En tarvitse käyttää printf. En tarvitse muistaa kaikki muotoa koodit. Miksi en, tai miksi ei joku ennen minua, luo toiminto nimeltään print nimi, joka annetaan jonkin nimen, yksinkertaisesti tulostaa sen? 

Toisin sanoen, jos sanon, hei, tietokone, anna minulle merkkijono pyytämällä käyttäjä tällaista, kautta CS50: n get merkkijono. Hei, tietokone, laita se merkkijono muuttujaa vasemmalla puolella, ja kutsuvat sitä s. Ja sitten, hei tietokone, mennä eteenpäin ja tulostaa henkilön nimen, tehty. 

Nyt, se olisi mukavaa, koska Ohjelman osuvasti nimetty, kertoo minulle mitä sen pitäisi tehdä Poiketen näistä funktion nimiä. Anna minun mennä ja tehdä prototyyppi, Enter. Ja valitettavasti tämä ei aio lentää. 

Prototype.c, rivi 7, merkki 5, virhe, implisiittinen ilmoitus Funktion nimenselvennys on pätemätön C99, C99 tarkoittaen versio C joka tuli ulos vuonna 1999. Siinä kaikki. 

Joten en tiedä mitä kaikki tämä tarkoittaa vielä. Mutta en tunnista virhe punaisena. Se on aika selvää. 

Ja näyttää siltä, ​​että vihreä merkki tästä, ongelma on painatuksella nimi, avoin paren s, lähellä paren, puolipisteellä. Mutta implisiittinen ilmoitus toiminto näimme lyhyesti aikaisemmin. Tämä tarkoittaa yksinkertaisesti, että Clang ei tiedä mitä tarkoitan. 

Olen käyttänyt sanaston sanaa, että se on koskaan nähnyt tai opetettu ennen. Ja niin minun täytyy opettaa sitä mitä tämä toiminto tarkoittaa. Joten aion mennä eteenpäin ja tehdä se. 

Aion mennä eteenpäin ja toteuttaa oma toiminto nimeltään Print Name. Ja aion sanoa, seuraavasti, että se tekee näin, printf, hei, prosenttia s, kenoviiva n, nimi, puolipisteellä. Joten mitä minä juuri tehdä? 

Joten se kääntyy pois, jotta toteuttaa oma toiminta, me tavallaan lainata joidenkin sama rakenne kuin pääasiallisena että olemme juuri olleet itsestään selvänä, ja minä tietävät vain kopioimalla ja liittämällä melko paljon, mitä Olen kirjoittanut aikaisemmin. Mutta huomaa kuvio täällä. Int, Main, Void, me kiusaa toisistaan ennen pitkää, mitä se todella tarkoittaa. 

Mutta tänään, vain huomaa rinnakkaisuus. Void, tulostaa nimi, string nimi, joten ei violetti avainsanan, joka aiomme aloittaa soittamalla palautuva, nimi toiminnon, ja sitten tulo. Joten itse asiassa, voimme tislata tällainen kuten viime viikolla koska tämä on nimi tai algoritmi koodin olemme menossa write-- algoritmi taustalla koodi aiomme kirjoittaa. 

Tämä on sen panos. Tämä on sen ulostulo. Tämä toiminto, tulostaa nimi, on tarkoituksena on ottaa merkkijonon nimeltään nimi, tai mitä tahansa, kuten syöttö, ja sitten mitätön. Se ei palaa mitään, kuten saada merkkijono tai saada int tekee. Joten se tulee luovuttaa minulle jotain takaisin. Se on vain olemaan sivuvaikutus, niin sanotusti, tulostus henkilön nimen. Joten huomata, rivi 7, I voi soittaa nimenselvennys. Linja 10, voin määritellä tai toteuttaa nimenselvennys. Mutta valitettavasti se ei riitä. 

Anna minun mennä eteenpäin ja kääntää tämän tallennuksen jälkeen. Whoa, nyt, olen tehnyt sen pahempaa, se näyttäisi. Joten implisiittinen ilmoitus toiminto tulostaa nimi on virheellinen. Ja taas on enemmän virheitä. Mutta kun varoitettiin aikaisemmin, jopa jos saat hukkua, tai hieman surullista nähdä niin monta virheitä, keskittyä vain ensimmäiseen aluksi, koska se voi vain on ollut kerrannaisvaikutuksia. Joten C, tai Clang tarkemmin, ei vieläkään tunnista nimenselvennys. 

Ja se johtuu Clang, suunnittelun, on tavallaan tyhmä. Se tekee vain mitä kerrot sitä tekemään. Ja se vain tekee niin siinä järjestyksessä jossa kerrot sitä tekemään. 

Olen siis määritellyt tärkeimmät linjalla neljä, kuten olemme tehneet melko usein. Olen määritellyt print nimi rivillä 10. Mutta olen yrittänyt käyttää print nimi rivillä seitsemän. 

Se liian pian, ei ole vielä olemassa. Joten en voinut olla fiksu, ja olla, OK, joten tehdään vain pelata yhdessä, ja siirrä nimenselvennys ylös täällä, ja uudelleen koota. Herranjumala. Se toimi. Se oli niin yksinkertaista. 

Mutta logiikka on juuri näin. Sinun täytyy opettaa Clang mitä se on määrittelemällä funktion ensimmäinen. Sitten voit käyttää sitä. Mutta suoraan sanoen, tämä tuntuu kuten kaltevalle pinnalle. 

Joten joka kerta Juoksen osaksi ongelma, olen vain menossa esiin ja kopioi koodi Kirjoitin, leikkaa se ja liitä se täällä. Ja varmasti, voisimme keksiä joitakin skenaarioita jossa yksi toiminto saattaisi täytyy soittaa toiselle. Ja et vain voi laittaa jokaisen toiminto kaikkien muiden yläpuolelle. 

Joten se kääntyy pois siellä n parempi ratkaisu. Voimme jättää tämän olla. Ja rehellisesti, se on yleensä mukava, ja kätevä, ja hyvä muotoilu laittaa tärkein ensin, koska, jälleen, Tärkein aivan kuten silloin, kun vihreä lippu napsautetaan, että on toiminto, saa suorittaa oletusarvoisesti. Joten ehkä myös laittaa se yläosassa tiedoston niin, että kun tai muut ihmisen tarkastellaan tiedosto Tiedätkö mitä tapahtuu vain lukemalla tärkein ensin. Joten se kääntyy pois, voimme kertoa Clang ennakoivasti, hei, Clang, rivillä neljä, Lupaan toteuttaa toiminto nimeltään Tulosta Nimi joka vie merkkijonon kutsutaan nimellä syötteenä, ja palaa mitään, mitätön. Ja minä kiertää sen täytäntöönpanoa myöhemmin. 

Täältä tulee Main. Tärkeimmät nyt rivillä 9 voi käyttää Tulosta Name koska Clang on luottavainen, että lopulta, se kohtaavat määritelmän täytäntöönpanon Print Name. Joten kun tallentavan tiedostoa, anna minun mennä eteenpäin ja tehdä prototyyppi, näyttää hyvältä tällä kertaa. Dot slash, prototyyppi, haluan mennä eteenpäin ja kirjoittaa nimen. David, hei David, Zamila, hei Zamila, ja todellakin nyt se toimii. 

Joten ainesosa tässä on se, että olemme teki mukautetun funktion, kuten mukautetun Scratch lohko me kutsuvat sitä. Mutta toisin Scratch jossa voit vain luoda sen ja alkaa käyttää sitä, Nyt meidän täytyy olla hieman pikkutarkka, ja itse kouluttaa Clang käyttää, tai odottaa sitä. Nyt sivuhuomautuksena, miksi koko ajan on me olleet vain sokeasti uskoon lukien CS50.h, ja myös vakio IO.h? 

No, se kääntyy pois, joukossa muutamia muita asioita, kaikki se näissä dot h tiedostoja, jotka sattuvat olemaan tiedostoja. He header-tiedostoja, niin sanotusti. He vielä kirjoitettu C. Mutta he erityyppinen tiedosto. 

Nyt voit melko paljon olettaa että kaikki mikä on sisällä CS50.h on noin yksi-alukset, kuten tämä, ei Toimintojen nimeltään Print Name, mutta Get String, Get Float, ja muutama muu. Ja on samanlaisia ​​prototyyppejä, yksi vaipat sisällä standardin IO.h varten printf, joka on nyt oma Tulosta nimi -toiminto. Eli toisin sanoen, tämä koko ajan olemme juuri sokeasti kopioida ja liittää sisällyttää tämän, sisältävät että, mitä tapahtuu? Nämä ovat vain sellainen vihjeitä että kalahtaa, mitä toimintoja ovat todellakin täytäntöön, vain muualla eri tiedostoja muualla järjestelmässä. 

Niinpä olemme ottaneet käyttöön nimenselvennys. Se on tämä sivuvaikutus tulostus jotain ruudulla. Mutta se ei varsinaisesti käsi minulle jotain takaisin. Miten edetä toteuttamista varten, joka ei käsi minulle jotain takaisin? 

No, kokeile tätä. Anna minun mennä eteenpäin ja toteuttaa niminen tiedosto return.c jotta voimme osoittaa, miten jotain kuten Get String, tai Get Int, on todella palaamassa jotain takaisin käyttäjälle. Mennään eteenpäin ja määritellä int main mitätön. 

Ja jälleen, että tulevaisuudessa käymme selittää, mitä se int ja että void on todella tekee. Mutta tänään käymme pitää itsestäänselvyytenä. Aion mennä eteenpäin ja printf, hyvä käyttäjäkokemus, x on. Ja sitten aion odottaa Käyttäjä antaa minulle x get int. 

Ja sitten aion mennä eteenpäin ja tulostaa x neliöön. Joten kun on vain näppäimistö, ihmiset yleisesti käyttää pikku porkkana symboli näppäimistöllä edustamaan valta yhdessä tai että eksponentti. Joten x potenssiin on läsnä i. 

Ja nyt aion tehdä tämän. Voisin do-- mitä x potenssiin? x potenssiin on x kertaa x. 

Ja teimme joitakin aika sitten jo tänään. Tämä ei tunnu kovin paljon edistystä. Tiedätkö mitä? Katsotaan hyödyntää jotakin siitä ajatuksesta viime aika abstraktio. 

Eikö olisi mukavaa, jos siellä on toiminto nimeltään neliö, että juuri näin? Se on edelleen, on lopussa päivä, tekee saman matematiikka. Mutta katsotaanpa abstrakti pois ajatusta ottaen yksi numero kerrottuna toinen, ja vain antaa sille nimi, kuten neliö tämä arvo. 

Ja, toisin sanoen, C, nyt luoda funktion kutsutaan neliön että juuri näin. Se tulee kutsua neliö. Se tulee ottaa int. Ja me tulee juuri kutsuvat sitä n oletusarvoisesti. 

Mutta voisimme kutsua sitä mitä me haluamme. Ja kaikki se menee do, kirjaimellisesti, on paluu tulos n kertaa n. Mutta koska se on palaavat jotain, joka on avainsana violetti olemme koskaan ennen nähnyt, I rivillä 11, voi vain sanoa mitätön tällä kertaa. 

Void, esimerkissä olemme juuri nähnyt pikemminkin tulostaa nimi, tarkoittaa vain sitä, tee jotain. Mutta älä käsi jotain takaisin. Tässä tapauksessa en halua palata n kertaa n, tai mitä se on, että numero. 

Joten en voi sanoa, hei, tietokone, Palaan mitään, mitätön. Se tulee palata, luonteeltaan, int. Ja niin se on kaikki mitä on tekeillä. 

Panos lähtöruutuun tulee olemaan int. Ja jotta voimme käyttää sitä, se on on nimi, N. Se tulee lähtö int, joka ei tarvitse nimeä. Voimme jättää tärkein, tai kuka on käyttävät minua muistamaan tätä arvoa, jos me haluavat omalla vaihteleva. 

Ja, jälleen, ainoa uusi avainsana tässä Return. Ja olen juuri tekemässä joitakin matematiikkaa. Jos halusin olla tarpeetonta, Voisin sanoa int tuote saa n kertaa n. 

Ja sitten voisi sanoa, palauta tuote. Mutta jälleen kerran, minun kohta aikaisempana tämä vain ei ole hyvä design-- kuten, miksi käyttöön nimi, symboli, kuten tuote, vain välittömästi palauttaa sen? Se on vähän puhtaampi, hieman tiukempi, niin puhua, vain sanoa paluu n kertaa n, päästä eroon tästä linjan kokonaan. 

Ja se on vain vähemmän koodia lukea, vähemmän mahdollisuuksia virheitä. Ja katsotaanpa, jos tämä todella toimii nyt. Nyt aion mennä eteenpäin ja tehdä paluun. 

Voi ei, implisiittinen ilmoitus toiminto. Tein tämän virheen ennen, no big deal. Saanen kirjoita, tai korosta ja kopioida, täsmälleen sama toiminto prototyyppi, tai allekirjoitus, funktion täällä. Tai voisin siirtää koko toiminto. 

Mutta se on vähän laiska. Joten emme tee sitä. Nyt, tehtäköön paluu jälleen, piste slash paluu. 

x 2. x potenssiin on 4. x 3. x potenssiin on 9. Ja toiminto näyttää Nyt toimivan. Joten mitä eroa täällä? Olen toiminto, joka kutsutaan neliö, Tässä tapauksessa, joka laitoin tulo. Ja palaan lähtö. Ja kuitenkin aikaisemmin, jos Avaan toinen esimerkki aiemmista, josta oli nimeltään prototype.c, Minulla oli print nimi, joka palasi mitätön, niin sanotusti, Tai se palasi mitään, ja yksinkertaisesti oli sivuvaikutus. 

Joten mitä täällä tapahtuu? No, pitävät toiminto saada merkkijono vain hetken. Olemme funktiolla saada merkkijono seuraavalla tavalla. 

Meillä on ollut tehtävä saada merkkijono, kuten muun muassa CS50.h, ovat standardin IO.h, int, tärkein, mitätön. Ja sen jälkeen joka kerta olen nimeltään get merkkijono tähän mennessä, Olen sanonut jotain, merkkijono s saa saada merkkijono, koska get string-- kutsukaamme tätä get.c-- get merkkijono itse palauttaa merkkijonon, joka voin sitten käyttää, ja sanoa, hei, pilkku, prosentin s, kenoviiva n, s. 

Joten tämä on samaa esimerkkiä, todella, että meillä oli aikaisemmin. Joten merkkijono palauttaa arvon. Mutta hetki sitten, print string ei palauta arvoa. Se vain on sivuvaikutus. Joten tämä on perustavanlaatuinen ero. Olemme nähneet eri tyyppisiä toimintoja nyt, joista jotkut ovat palanneet arvot, joista jotkut eivät. Joten ehkä se on merkkijono, tai int tai float. Tai ehkä se on vain mitätön. 

Ja ero on että nämä toiminnot, jotka saada tietoja ja palauttaa arvon todella tuo jotakin takaisin pöytään, niin sanoakseni. Joten mene eteenpäin ja katsokaa yksi viimeinen Esimerkkien joka antaa tunteen, nyt on miten voisimme todellakin abstrakti parempi, ja paremmin, ja paremmin, tai enemmän, ja enemmän, ja enemmän, jotta kirjoittamaan lopulta parempaa koodia. Mennään eteenpäin, ja hengessä Scratch, toimi seuraavasti. 

Anna minun mennä eteenpäin ja sisältävät CS50.h ja standardi IO.h. Anna minun mennä eteenpäin ja antaa itse int, tärkein, mitätön. Ja anna minun mennä eteenpäin, kutsuvat tätä cough.c. 

Ja anna minun mennä eteenpäin ja vain kuten Scratch, tulostaa yskä / n. Ja haluan tehdä tätä kolme kertaa. Joten olen tietenkin juuri menossa kopioida ja liittää kolme kertaa. Olen nyt menossa tekemään yskä piste slash yskä. Annetaan itse vähän enemmän tilaa täällä, Anna, yskä, yskä, yskä. 

On tietysti jo mahdollisuus parantaa. Olen kopioida ja liittää muutaman kerran tänään. Mutta se oli vain niin en täytyy kirjoittaa niin monta merkkiä. Olen edelleen muuttaneet nämä riviä koodia ovat. 

Nämä kolme riviä ovat samanlaiset, joka tuntuu laiska ja todellakin on, ja ei luultavasti ole oikea lähestymistapa. Joten mitä ainesosan voisimme parantaa tätä koodia? Meillä ei tarvitse kopioida ja liittää koodin. 

Ja tosiaankin, milloin tunnet itse kopioimalla, eikä edes muuttuvat koodia, kertoimet ovat olemassa parempi tapa. Ja todellakin, siellä on. Anna minun mennä eteenpäin ja tehdä silmukka, vaikka syntaksi ei ehkä tulevat luonnollisesti vielä. 

Tekemällä tämän kolmesti, yksinkertaisesti tekemällä following-- ja satun tietää tätä käytäntöön. Meillä on kuitenkin useita esimerkkejä nyt. Ja näet verkossa lisää viitteitä edelleen. 

Tämä on syntaksi rivillä 6, että aivan kuten Scratch joka toistuu lohko, toista seuraavat kolme kertaa. Se on vähän maaginen nyt. Mutta tämä saa enemmän, ja tutumpi. 

Ja se tulee toistaa line kahdeksan kolme kertaa, niin että jos olen uudelleen koota make yskä, piste slash yskä, yskä, yskä, yskä. Se toimii edelleen samalla tavalla. Niin, että kaikki hyvä ja hieno. Mutta se ei ole kovin abstracted. 

Se on täysin oikein. Mutta se tuntuu siellä voisi olla mahdollisuus, kuten maailmassa Scratch, eräänlainen alku lisätä muutamia semantiikan tässä niin, että En vain joitakin varten silmukka, ja toiminto, jossa lukee yskä, vai yskä. Tiedätkö mitä? Yritän olla hieman viileämpi kuin, ja itse asiassa kirjoittaa funktio, joka on joitakin sivuvaikutuksia, kutsuvat sitä yskä. 

Ja siinä ei tulo, ja palauttaa mitään arvoa tuotokseksi. Mutta tiedätkö mitä se tekee? Se this-- printf, lainaus lainaus, yskä. 

Ja nyt täällä, aion mennä eteenpäin ja int, i saa nolla, i alle 3, i plus plus. Aion tehdä printf, joka on luultavasti alhainen täytäntöönpano yksityiskohta. En välitä miten yskä. Haluan vain käyttää yskä toimintoa. Ja olen juuri menossa soittaa yskä. 

Nyt huomaa kahtiajako. Kun soitat toiminto, jos et haluavat antaa sen tuloihin, täysin hieno. Tee avoin paren lähellä paren, ja olet valmis. 

Kun määrittää funktion, tai julistaa funktion prototyyppi, Jos tiedät etukäteen se ei ole vie argumentteja, sanoa mitätön näissä suluissa siellä. Ja se tekee, että olet ei vahingossa sitä väärin. Anna minun mennä eteenpäin ja tehdä yskä. Ja tietenkin, olen tehnyt virheen. 

Dammit, siellä on, että implisiittinen ilmoitus. Mutta se käy hyvin. Se on helppo korjata. Tarvitsen vain prototyyppi ylempänä minun tiedosto kuin olen todellisuudessa käyttävät sitä. 

Joten nyt tehtäköön yskä taas mukava. Nyt se toimii. Tee yskä, yskä, yskä, yskä. Joten voisi ajatella, että olemme todella runsaat insinöörin tätä ongelmaa. Ja todellakin, me olemme. Tämä ei ole hyvä ehdokas ohjelman kategoriassa refaktorointi, ja tekee mitä nimeltään hierarkkinen hajoaminen, jos otat koodia, ja sitten te sellainen tekijä asioita, niin kuin syyksi enemmän semantiikka heille ja käyttää sitä lopulta pitkällä aikavälillä. Mutta se on rakennuspalikka kohti kehittyneempiä ohjelmia että aloitamme kirjallisesti ennen pitkää, että antaa meille mahdollisuuden sanastoa jolla kirjoittamaan parempaa koodia. Ja todellakin, katsotaanpa jos voi yleistää tätä pidemmälle. 

Se tuntuu hieman ontuva, että minä, tärkein, tarvitse huolehtia tästä hiton silmukka, ja kutsuvan yskä uudestaan ​​ja uudestaan. Miksi en voi vain kertoa yskä, ota yskä kolme kertaa? Toisin sanoen, miksi en voi vain antaa panos yskä ja tehdä tämän? 

Miksi en voi vain sanoa, vuonna Tärkein yskä kolme kertaa. Ja nyt, tämä on tavallaan maaginen. Se on hyvin iteratiivinen täällä. Ja se on, todellakin, vauva askel. 

Mutta juuri kyky sanoa rivi kahdeksan, yskä kolme kertaa, se on vain niin paljon enemmän luettavaa. Ja plus, en tarvitse tietää tai välitä kuinka yskä on toteutettu. Ja todellakin, myöhemmin termi ja opinnäytetöiden, Jos puuttua projektin luokkatoveri tai kaksi luokkatoverit, huomaat, että olet menossa on, tai haluat, jakaa työ. 

Ja olet menossa haluavat päättää etukäteen, kuka tekee mitä, ja jossa kappaleet? Ja eikö olisi mukavaa Jos esimerkiksi huolehtia kirjoittamisen tärkein, tehty. Ja kämppäkaveri, tai kumppani yleisemmin huolehtii täytäntöönpanon yskä. 

Ja tämä jako, nämä seinät abstraktio, tai kerrosten abstraktio jos te, ovat erittäin tehokkaita, koska erityisesti suurempien, monimutkaisempia ohjelmia ja järjestelmiä, se mahdollistaa useiden ihmisiä rakentamaan asioita yhdessä, ja lopulta ommel työnsä yhteen tällä tavalla. Mutta tietenkin, me täytyy nyt korjata yskä. Meidän täytyy kertoa yskä että, hei, tiedätkö mitä? Olet menossa tarvitse ottaa input-- niin ei mitätön, mutta int ja nyt. Mennään eteenpäin ja panna yskä int. i saa nolla. 

i on pienempi kuin se, kuinka monta kertaa. Sanoin kolme aiemmin. Mutta se ei ole mitä haluan. En halua yskä voidaan yleistää tukea mitä tahansa määrää toistojen. 

Joten, todellakin, se on n että haluan, mitä käyttäjä kertoo minulle. Nyt voin mennä eteenpäin ja sanoa tulostaa yskä. Ja mitä numero käyttäjä kulkee, Aion kerrata, että monta kertaa. 

Joten lopussa päivä, Ohjelma on sama. Mutta huomaa kaikki tätä kamaa voisi olla jopa toiseen tiedostoon. Itse asiassa en tiedä tällä hetki miten printf toteutetaan. 

En tiedä tällä hetkellä, miten saada string, tai saada int, tai saada kellua pannaan täytäntöön. Ja en halua nähdä niitä tietokoneen näytöllä. Koska se on, olen alkanut keskittyä minun ohjelma, eikä näitä tehtäviä. 

Ja niin, todellakin, heti kun Aloita factoring koodi näin ulos, voisimme jopa siirtää yskä erilliseen tiedostoon? Joku voisi toteuttaa sitä. Ja sinun ja ohjelma tulee hyvin kaunis, ja hyvin luettavissa, luultavasti, todella neljä line-ohjelma oikeassa. 

Joten mene eteenpäin nyt ja vielä yksi muutos. Huomaa, että minun prototyyppi on vaihtaa ylös. Haluan siis korjata, että niin En saa huusi. 

Tee yskä, minä juoksen yskä kerran enemmän, edelleen tehdä sama asia. Mutta nyt huomaa meillä on ainesosa yksi lopullinen versio. Tiedätkö mitä? En halua vain yskä, välttämättä. Haluan olla jotain yleisempää. Joten tiedätkö mitä? En halua tehdä tätä. Haluan olla, aivan kuten Scratch ei, sanoa lohko, mutta ei pelkästään sanoa jotain muutamia kertoja. Haluan sen sanoa hyvin erityinen merkkijono. Ja siksi en haluavat sen vain sanoa yskä. Haluan sen sanoa mitä tahansa merkkijono johdetaan. 

Joten huomata, olen yleistynyt tämä niin, että nyt vaikkapa tuntuu hyvältä nimi Tämän, kuten Scratch, ottaa kaksi argumenttia, toisin Scratch. Yksi on merkkijono. Yksi on int. 

Ja voisin vaihtaa niitä. Olen juuri sellainen kuin ajatus sanoa merkkijono ensin, ja sitten kuinka monta kertaa myöhemmin. Void tarkoittaa sitä vielä ei palaa mitään. Nämä ovat vain visuaalinen puoli vaikutuksia, kuten kanssa [? Jordan,?] sanallinen sivuvaikutus huutaa. Se kuitenkin tekee jotain n kertaa, 0 asti, mutta ei yhtä suuri kuin n. Tämä tarkoittaa n koko kertaa. Ja sitten vain tulostaa mitä se merkkijono on. Joten olen todella yleistynyt koodirivin. Joten nyt, miten voin toteuttaa yskä toiminto? 

Voin tehdä mitätön yskä. Ja voin silti ottaa miten monta kertaa haluat yskä. Mutta tiedätkö mitä? Voin nyt punt sanoa. 

Voin soittaa sanoa kanssa sana yskä, kulkee n. Ja jos haluan myös toteuttaa, vain huvin vuoksi, aivastus funktio, Voin sneeze joitakin kertoja. Ja voin pitää uudelleenkäyttö n, koska huomaa, että m tässä yhteydessä tai laajuus on olemassa vain tämän toiminnon. 

Ja n tässä yhteydessä vain vallitsee tätä toimintoa täällä. Joten me palaamme näitä kysymyksiä soveltamisalan. Ja tässä, olen juuri menossa sanoa, Achoo, ja sitten n kertaa, puolipisteellä. 

Ja nyt, minä vain täytyy lainata nämä toiminnot allekirjoitukset täällä. Joten yskä on oikea. Void aivastus on oikea nyt. 

Ja olen edelleen täytyy vain sanoa. Joten aion sanoa, vaikkapa string s, int n, puolipisteellä. Joten olen yli-suunnitelleet pahus pois tästä ohjelmasta. 

Ja tämä ei välttämättä tarkoita tämä on mitä pitäisi tehdä, kun kirjallinen edes yksinkertaisimpia ohjelmia. Ota jotain, joka on ilmeisesti todella yksinkertainen, todella lyhyt, ja uudelleen toteuttaa se käyttämällä aivan liikaa koodia. Mutta voit itse nähdä ja aika muistella näitä esimerkkejä, ja ymmärtää,, oi, ne ovat vaiheet otimme todella yleistää, tekijä jotain, kunnes lopussa päivän minun koodi on oikeastaan ​​aika kohtuullinen. Koska jos Haluan yskä kolme ajat sitten aivastaa kolme kertaa, En yksinkertaisesti menossa uusintana tämän, ohjelma tehdä yskä, ja suorita yskä. Ja minulla on kolme yskää ja kolme aivastaa. 

Ja niin tämä on perus paradigma, jos haluatte, kuinka voisimme edetä todella toteuttaa ohjelmaa. Mutta Haluan vain nähdä nyt, mikä on olemme tehneet kaiken tämän ajan, ja mitä jotkut lopullista kappaletta ovat tämän takana yksinkertaisen komennon. Lopussa päivän, olemme käyttänyt Clang meidän kääntäjä. Olemme kirjallisesti lähde koodi, muuttaen sen kautta Clang konekielelle. 

Ja olemme käyttäneet tehdä vain helpottaa meidän näppäimistön niin että meidän ei tarvitse muistaa ne loitsut of Clang itse. Mutta mikä on tehdä todella tekee? Ja puolestaan ​​mitä on Kalahtaa todella tekee? 

On käynyt ilmi, vaikka olemme yksinkertaistettu tämänpäiväisessä keskustelussa sanomalla, otat lähdekoodia, siirtää sen tulona kääntäjä, joka antaa sinulle tuotos koneen koodi kääntyy siellä n muutamia eri vaiheita sisällä siellä. Ja kokoaminen sattuu olemaan sateenvarjo termi koko joukko vaiheita. Mutta Haluan vain kiusaa tätä todella nopeasti. 

On käynyt ilmi, että olemme tehneet enemmän asioita joka kerta kun käynnistää ohjelman tai joka kerta kun kääntää ohjelmaa tänään. Niin esikäsittelyyn viittaa this-- mitään C-ohjelma, kuten näemme uudelleen ja uudelleen, joka alkaa tämän hash symboli, tai hashtagin symboli täällä, merkitsee se on esikäsittelijään direktiivi. Tämä tarkoittaa tässä tapauksessa, hei tietokone, tehdä jotain tämän tiedoston ennen kuin itse koota oman koodin. 

Tässä tapauksessa hash sisältävät sanoen, pohjimmiltaan, C tapa sanoa, hei tietokone, mene saada sisältöä of CS50.h ja liittää ne täällä. Hei tietokone, mene saada sisällöstä standardin IO.h, aina kun se on sen kiintolevy, liitä se tähän. Joten ne asioita tapahtuu Ensimmäinen aikana esikäsittely. 

Ja Clang tekee kaiken tämän meille. Ja se tekee sen niin hiton nopea, et edes katso neljä erillistä asioita tapahtuu. Mutta se ensimmäinen tällainen askel. 

Mitä oikeastaan ​​tapahtuu? No, seuraava virallinen vaihe on koota. Ja käy ilmi, että ohjelmaa koostettaessa teknisesti tarkoittaa menee lähdekoodi, tavaraa olemme kirjoittanut tänään, jotain nimeltään assembly, jotain joka näyttää hieman erilainen. 

Ja itse asiassa, voimme nähdä tämän todella nopeasti. Anna minun itse mennä minun IDE. Anna minun mennä eteenpäin ja avoin hello.c, joka on ensimmäinen ohjelma, jota alkoi tänään. Ja anna minun mennä eteenpäin ja ajaa Clang hieman eri tavalla, Clang-s, hello.c, joka on todella aikoo anna minulle toinen tiedosto hello.s. 

Ja me luultavasti koskaan jälleen nähdä tällaista koodia. Jos ottaa alemmalla tasolla järjestelmät luokan kuten CS61, näet paljon enemmän Tällaisen koodin. Mutta tämä on konekielellä. Tämä on X86 konekielellä että CPU, joka on taustalla CS50 IDE todella ymmärtää. 

Ja arvoituksellinen kuin se katso, se on jotain tietokone ymmärtää melko hyvin. Sub q, tämä on vähennä. On liikkeitä. 

Siellä soittaa toimintoja täällä, x Oring, liike, lisäosa, pop, paluuta. Joten on joitakin hyvin alhainen ohjeet että suorittimia ymmärtää, että Viittasin aikaisemmin. Juuri Intel Inside. 

On malleja nollia ja ykkösiä, jotka karttaa näihin arcanely muotoiltu, mutta jokseenkin hyvin nimetty, ohjeet, niin sanoakseni. Tämä on mitä tapahtuu, kun te kääntää koodia. Saat kokoonpano kieli ulos siitä, mikä tarkoittaa, että kolmas vaihe on koota että kokoonpano koodin, lopulta, kone code-- nollia ja ykkösiä, eikä tekstissä, josta juuri nähnyt hetki sitten. 

Joten esikäsittelyä ei joka löytää ja korvaa, ja muutamia muita asioita. Kääntäminen vie lähde koodi C, lähdekoodi että me kirjoitti, kokoonpano koodi, joka me vain vilkaisi. Kokoaminen vie että kokoonpano koodi nollia ja ykkösiä että CPU todella ymmärtää lopussa päivän. Ja linkittäminen on viimeinen vaihe että tapahtuu us-- uudelleen, niin nopeasti emme edes notice-- joka sanoo, hei tietokone, ottaa kaikki nollat ​​ja ne, jotka johtui kokoamisessa Daavidin koodia, ja hänen pääasiallinen tehtävä tässä tapauksessa. 

Ja hei tietokone, mene saada kaikki nollat ​​ja ykköset että CS50 henkilöstö kirjoitti sisällä CS50 kirjasto. Sekoita ne sisään Daavidin. Ja hei tietokone, mene saada kaikki nollat ja ne, jotka joku muu kirjoitti vuotta sitten varten printf. Ja lisätä ne osaksi koko asia, joten olemme sain nollia ja ykkösiä, The CS50 henkilöstön nollia ja ykkösiä, printf nollia ja ykkösiä, ja mitään muuta käytämme. 

He kaikki saavat yhdistetään yhdeksi ohjelmaa nimeltä, tässä tapauksessa, hei. Joten tästä lähtien, me vain käyttää sanaa kokoamiseen. Ja otamme selvänä, että kun sanomme, kääntää ohjelma, se tarkoittaa, hei tehdä esikäsittelyä, kokoonpano, ja yhdistää. Mutta on todella jokin mehukas tavaraa siellä tapahtuu alla huppu. Ja varsinkin jos saada utelias jonkin aikaa, voit alkaa tönäisi noin tällä alhaisemmalla tasolla. Mutta nyt, ymmärtää, että joukossa takeaways tänään ovat yksinkertaisesti alkaa prosessi, saada mukava jotain Hello World. Itse asiassa suurin osa mitä teimme tänään ei varmasti uppoavat huippunopea. Ja kestää jonkin aika, ja jotkut käytäntö. Ja kertoimet ovat, sinun tulee lajitella of haluat lyödä näppäimistön tai huutaa näyttöä. Ja kaikki tämä on OK. Tosin ehkä yritä tee se kirjastossa niin paljon. 

Ja lopulta, luultavasti olisi voinut kuitenkin, aloittaa nähdä kuvioita, niin hyvää koodia että olet kirjoittanut ja virheitä että olet tehnyt. Ja paljon kuin prosessin tulossa TF tai CA on kuin, voit alkaa saada paremmin ja paremmin näkemään näitä kuvioita, ja vain ratkaisemaan omat ongelmansa lopulta. Tällä välin tulee olemaan runsaasti meistä antamaan sinulle tukea ja painukaa tämän läpi. Ja arvonkorotukset kaikki ongelmat aiotte ohjataan läpi kaikki komennot että en todellakaan tiedä mistä paljon käytännön nyt, mutta ehkä lentänyt yli pään nyt. Ja se on täysin kunnossa. 

Mutta lopulta olet menossa alkaa nähdä kuvioita syntyä. Ja kun saat ohi kaikki tyhmä yksityiskohtia, kuten suluissa, ja aaltosulkei-, ja puolipistettä, ja tavaraa, rehellisesti, joka ei ole ollenkaan älyllisesti mielenkiintoinen. Ja se ei ole tavoite minkään johdanto luokassa. Se on ideoita, jotka ovat menossa merkitystä. 

Se on silmukoita, ja olosuhteet, ja toiminnot, ja voimakkaammin ottoon, ja factoring koodia, ja hyvä suunnittelu, ja hyvä tyyli, ja lopulta oikeellisuutta oman koodin, joka on viime kädessä menossa asia eniten. Joten ensi viikolla, otamme nämä ideoita, tuli ensimmäisen kerran Scratch ja ovat nyt kääntänyt C. Ja aloitamme esitellä ensimmäinen kurssin reaalimaailman verkkotunnuksia. 

Me keskitymme maailman turvallisuutta, ja tarkemmin salaus, taidetta muokkaamisella tietoja. Ja ensimmäisten joukossa ongelmat itse saa kirjoittaa pidemmälle leikkii joitakin syntaksin ja ratkaista loogisia ongelmia, lopulta ennen pitkää, on todella muokkaamaan tai salata, ja lopulta purkaa tietoa. Ja kaikki olemme tehneet tänään, tulee melko alhainen tasolla, on juuri menossa sallia voimme ottaa yhden, ja yksi, ja yksi askel edellä kohti kirjallisesti mielenkiintoisin koodin vielä. 

Niin siitä lisää ensi viikolla. 

[VIDEOTOISTOSTA] 

-Mitä Voi kertoa minulle viimeinen kerta, kun näin hänet? -Mitä Voin sanoa, todella? Siis, se oli kuin mikä tahansa muu pre-tuotanto harjoitus, paitsi siellä oli jotain hän sanoi aivan lopussa, että kiinni minua. 

-Tämä Oli CS50. 

-Se On leikattu kaikille, hienoa työtä harjoitus. 

-Se Lounas? 

-Joo, Sinä ja voin napata voileipä hieman. Saanen tiedotustilaisuuden kanssa David todella nopeasti. David? David? 

[END TOISTO] 