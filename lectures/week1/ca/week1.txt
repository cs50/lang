[MÚSICA] DAVID J. Malan: Molt bé, això és CS50. I aquesta és la setmana un. Així recordar que l'última vegada en la setmana zero, ens hem centrat en el pensament computacional. I que la transició que a Scratch, una programació gràfica el llenguatge dels nostres amics en el Laboratori de Mitjans del MIT. 

I amb Scratch, ens vam explorar idees com les funcions i condicions, i els bucles i variables, i fins i tot esdeveniments, i fils, i més. I avui, anem a seguir utilitzant aquestes idees, i realment prendre-les per assegut, però traduir-les a un altre idioma conegut com a C. Ara, C és un llenguatge més tradicional. És un nivell més baix idioma, si es vol. 

És purament textual. I així, a primera vista, és tot va a semblar més aviat críptica si mai has programat abans. Tindrem punt i coma, i parèntesis, i claus, i més. Però adonar-se que fins i tot tot i que la sintaxi és a punt de mirar una mica familiaritzat per a la majoria de vostès, veure més enllà d'això. I tractar de veure les idees que són, de fet, familiar, perquè aquí a la setmana un ho començarem a fer és comparar, Inicialment, a les ratllades en comparació amb C. 

Així, per exemple, recordar que quan implementat el primer dels nostres programes última vegada, vam tenir un bloc que semblava una mica d'alguna cosa així- quan bandera verda es fa clic, i després vam una o més peces del trencaclosques per sota d'ella, en aquest cas, dir, hola món. Així que, de fet, en Scratch, en fer clic en aquesta bandera verda per executar el meu programa, per la qual parlar, aquests són els blocs que s'executen, o córrer. I, en concret, Scratch va dir, hola, món. 

Ara, podria haver especificat diferents paraules aquí. Però veurem que, de fet, molts d'aquests blocks-- i, de fet, en C moltes functions-- poden ser parametritzada o personalitzada per fer coses diferents. De fet, en C si voler convertir, ara, aquest programa de Scratch a aquest altre idioma, anem a escriure una mica alguna cosa com això. 

Per descomptat, hi ha alguna desconeguda Sintaxi hi ha més probable, int, i els parèntesis i sense efecte. Però printf-- tot i que ho faria crec que seria només d'impressió. Però la impressió d'impressió significa formatat, com aviat veurem. Això, literalment, s'imprimirà a la pantalla el està dins d'aquests parèntesis, que per descomptat, en aquest cas és, hola món. 

No obstant això, es donarà compte d'alguna altra sintaxi, algunes cites dobles, que els parèntesis al final, el punt i coma i similars. Així que hi ha una mica de sobrecàrrega, per així dir-ho, tant cognitivament i sintàcticament, que anem haver de recordar en poc temps. Però adonar-se que amb la pràctica, això començarà a saltar a la vista. 

De fet, ens centrarem en què un funció specifically-- en aquest cas, saludar món. Així és a dir la funció. Hola món és seu paràmetre, o argument, la seva personalització. 

I l'equivalència en C és només això serà una línia aquí, on printf és equivalent a, per exemple, la cadena entre cometes dobles, hola món és equivalent, per descomptat, al que hi ha a la caixa blanca allà. I la barra invertida n, encara que una mica estranya i absent de Scratch, simplement va a tenir l'efecte que anem a veure en un ordinador, com el meu Mac o un PC, de tan sols moure el cursor a la línia següent. És com colpejar Retorn al teclat. 

Així que veurem de nou en poc temps. Però primer, anem a fer una ullada a aquest un altre exemple en el cas dels bucles. Hem tingut aquest bucle infinit última vegada, que era una sèrie de peces d'un trencaclosques que van fer alguna cosa, literalment, forever-- en aquest cas, dir hola món, Hello World, hola món, hola món. Així que és un bucle infinit per disseny. 

En C, si volem posar en pràctica aquest mateixa idea, que podria simplement fer això. Encara que és veritat, printf hola món-- ara mentre que, igual semànticament, tipus de evoca la idea de fer alguna cosa una altra vegada, i una altra, i una altra, i per quant de temps? Bé, recordo que cert-- és cert només en o un. 

I és cert, per descomptat, sempre és cert. Així que és una mena de sentit declaració que acaba de dir veritat. Però de fet, això és deliberat, perquè si és cert és just sempre és cert, que mentre que la veritable simplement implica, si una mica indirectament, que les següents línies de codi entre aquestes claus només ha d'executar de nou, i de nou, i una altra, i en realitat mai parar. 

Però si vostè vol que el seu bucle per aturar, ja que va ser l'última vegada amb una mena això, repetiu els següents 50 vegades, en C podem fer el mateix amb el que hi ha anomenat per loop-- la paraula clau no sent temps, però per. I llavors tenim una nova sintaxi aquí, amb int i és igual a 0, i de menys de 50, i ++. I anem a tornar a això. Però això és simplement la forma en què ho faria traduir el conjunt de blocs de Scratch a un conjunt de línies C de codi. 

Mentrestant, considerar variables. I, de fet, només vaig veure un fa un moment. I en el cas de Scratch, si volgut declarar una variable anomenada i per a i ser sencer, només un número, i volem posar-lo en algun valor, faríem servir aquesta taronja bloquejar aquí-- i s'estableix en 0. 

I anem a veure avui i més enllà, igual que la setmana passada, programadors fan gairebé sempre començarà a comptar a partir de zero, de veritat per convenció. Però també perquè el record de la nostra discussió de la binària, el més petit nombre que pot representar amb qualsevol nombre de bits és només va a ser 0 en si. I així anem a començar en general inicialitzar fins i tot les nostres variables a 0. 

I en C per fer el mateix, direm int completament, només per convenció. Podria haver cridat a aquesta variable el que vulgui, igual que en Scratch. I llavors és igual a 0 cessionaris el valor 0 per la dreta i la col·loca en la variable, o el contenidor d'emmagatzematge d'allà, a l'esquerra. I el punt i coma com anem a veure-- i hem vist alguns d'aquests ya-- Només vol dir fi del pensament. Procedirà a fer una altra cosa en les línies que segueixen. 

Ara, què passa amb les expressions booleanes? Recordem que en Scratch, aquestes eren expressions que són veritables o preguntes false--, Realment, que són veritables o falses. Així, en el cas de les ratllades, podríem fer una pregunta tan simple com aquest, i és menor que 50? Així que, de nou, és un nombre sencer. Potser ho estem utilitzant en un programa d'Scratch fer un seguiment d'una puntuació o alguna cosa aixi. Així que aquesta sintaxi aquí a Scratch Només vol dir, i és inferior a 50? Bé, per sort, és una cosa simple en C. I per traduir, això seria simplement dir que menys de 50, utilitzant la clau familiaritzat en el seu teclat. 

Mentrestant, si vostè vol dir alguna cosa més general, com, bé, és x menor que i on cadascú de X i Y són ells mateixos variables? Podem fer la mateixa cosa en C, tant de temps com hem creat aquestes variables ja. I veurem com fer que en poc temps. Ens agradaria dir simplement x menor que i. 

Així que vostè està començant a veure algunes similituds. I aquelles persones que van fer Scratch van ser sens dubte inspirat en algunes d'aquestes idees bàsiques. I veurà aquest tipus de Les Llengües de sintaxi en molts No només rascar, no simplement C, però Python, i JavaScript, i altres idiomes encara. 

Anem a considerar una altra construcció de C, la noció d'una condició, fer alguna cosa de forma condicional. Si alguna cosa és cert, fer això. Si hi ha alguna cosa més és cert, fer això. És una espècie de la programació equivalent a una forquilla a la carretera. Potser és una forquilla de dues vies, una de tres vies forquilla, o més. I en Scratch, podríem tenir vist alguna cosa com això. 

Així que aquest és un gran. Fixeu-vos, la relativa simplicitat de la lògica. Si x és menor que i, a continuació, dir x és menor que i, més si x és més gran que i, després dir x és més gran que i. I llavors, lògicament, si pensa tornar a les ratllades o simplement la seva pròpia intuïció humana, així, si x no és més gran que i, i x no és menor que i, a continuació, per descomptat x serà igual a i. Així doncs, en aquest cas, per la jerarquització aquests blocs d'Scratch, podem aconseguir un període de tres forquilla camí en el camí? 

Mentrestant, si volem fer que en C, es podria dir que es veu una mica simpler-- almenys Una vegada que es familiaritzi amb la sintaxi. Si x és menor que i, printf x és menor que i. Else si x és més gran que i, printf x és més gran que i. Else printf x és igual a I- i, de nou, amb els extrems de barra invertida només per a aquestes noves línies de manera que si actualment es va trobar aquest tipus de programa que seria només moure el cursor en última instància, a la següent línia de la pantalla. 

Ara, per la seva banda esgarrapades tenia una altra característiques més sofisticades, només alguns dels quals anem a Inicialment moure cap al món de la C. I un d'ells era diu una llista en Scratch. I això era un especial tipus de variable que va permetre que li permet emmagatzemar múltiples coses en ella cap enrere, cap enrere, cap enrere, cap enrere. 

En C, que no té llistes, per se, però alguna cosa que són més generalment crida matrius, tot i que va tornar més tard aquest semestre que mira alguna cosa diu una llista, o en realitat una llista enllaçada. Però per ara, el més proper equivalent en C per a nosaltres serà una cosa denominat matriu. I una matriu és simplement una tipus especial de variable que li permet emmagatzemar dades cap enrere, cap enrere, cap enrere, cap enrere. 

I, de fet, en Scratch, si volíem accedir el primer element d'una matriu o 1 pel·lícules-- i vaig a anomenar-lo, per convenció, argv, l'argument vector, però més d'això en poc temps. Si vull aconseguir en el primer element de argv, en el món de les ratllades que realment fan típicament començarà a comptar a partir de l'1. 

I pel que podria aconseguir l'article 1 de argv. Així és com el MIT implementat la noció de llistes. Però en C, vaig a més simplement dir, argv, que al seu torn és el nom del meu pel·lícules-- o per ser clars, una matriu. I si vull que la primera elements, vaig utilitzar claudàtors, que es pot ser que no s'utilitza sovint en un teclat. 

Però a 0 vol dir, me la primera. Així que de tant en tant i com el temps passa, ens anem per començar a veure aquestes dicotomies entre zero i C, mitjançant el qual les ratllades utilitza un. Nosaltres fem servir en C 0 aquí. Però que dóna gust veure una vegada que entengui els fonaments de cada idioma, que les aquestes coses es posen encara més familiar a través de la pràctica i la pràctica. 

Així que realment es veuen ara en un programa. Aquí serà el primer de la nostra C codi font de programes complets. I el programa que anem per oferir a la consideració és la que és equivalent a aquest tros de Scratch anterior. 

Així que aquí, tenim el que és sens dubte el programa més simple C que es pot escriure En realitat fa alguna cosa. Ara, anem a veure més enllà, per ara, s'ha d'incloure, io.h estàndard, i aquests angle claudàtors, i int, i sense efecte, i les claus, i similars. 

I ens centrarem en el que, almenys intuïtivament, podria salten a la vista ia. De fet, la principal, no ho crec necessàriament sap el que és això, però igual que les ratllades que quan tenien bandera verda clic peça del trencaclosques, el mateix passa amb C com un llenguatge de programació tenir una peça principal de codi que és executat per defecte. I, de fet, És, literalment, va ser cridat principal. 

Així principal és una funció. I és una funció especial que existeix en C que quan s'executa un programa, és principal que és atropellat per predeterminat. En el món de les ratllades, que era en general quan la bandera verda fet clic que va aconseguir funcionament per defecte. 

Mentrestant, hem vist això abans, printf o d'impressió amb format, això és serà una funció que ve amb C, juntament amb un munt d'altres, que la voluntat del temps i el temps de nou, amb la finalitat de fer exactament com el seu nom indica, imprimir alguna cosa. Què volem per imprimir? Bé, veurem que per caràcters que tanquen com these-- hola món, n barra invertida entre cometes dobles, podem dir exactament printf El que cal imprimir a la pantalla. 

No obstant això, per tal de fer que, per desgràcia necessitarà prendre alguna cosa que és Ja críptica per a nosaltres els éssers humans, però almenys és alguna cosa readable-- agut inclouen, io.h estàndard, int, principal, nul·la, printf, tota la màgica encanteris que acabem de veure a la pantalla. Però en realitat hem de anar més arcà encara. Primer hem de traduir el codi que s'escriu en codi màquina. I recordar a la setmana passada que les màquines, almenys els que saben que aquí, al final de la dia només entendre zeros i uns. 

I el meu Déu, si haguéssim de escriure aquests zeros i els uns als realitat el programa, que seria molt, molt ràpidament eliminar la diversió de res. Però resulta que, a la setmana passada, que aquests patrons de zeros i uns només tenen un significat especial. En certs contextos, que poden significar nombres. 

En alguns contextos, que poden significar lletres o colors, o qualsevol nombre d'altres abstraccions allà sobre. Però igual que l'equip té una CPU, Central Processing Unit, o el cervell en l'interior del seu ordinador. Generalment és Intel a l'interior, perquè això és una de les majors empreses que fa que les CPU dels ordinadors. 

Doncs bé, les CPU Intel i altres simplement han decidit per endavant que certs patrons de zeros i les coses s'entendrà específics. Certs patrons de zeros i uns significarà, imprimir aquesta a la pantalla, o afegir aquests dos nombres, o restar aquests dos nombres, o moure aquesta peça de dades de la memòria del meu ordinador a través d'aquí, o qualsevol altre número de molt baix nivell, però en última instància útil, operacions. Però, per sort, els humans no van a necessitar saber aquest nivell de detall. De fet, com l'última vegada, en la qual abstret de nou, i una altra, i una altra, edifici de molt baix nivell primitives com zeros i uns als conceptes de més alt nivell com números i lletres, i els colors, i molt més, pel que podem, com a programadors de peu sobre les espatlles de altres que han vingut abans que nosaltres i utilitzar el programari que una altra persones han escrit abans de nosaltres-- a saber, els programes anomenats compiladors. 

C és un llenguatge que en general es compila, el que significa convertit de codi font a codi màquina. En particular, el que això significa és que si vostè té la seva font codi que s'escriu a si mateix, com aviat ho farà en un moment a la pantalla, i vol convertir-lo en última instància, a la màquina code-- aquests zeros i uns que Només teu Mac o PC understands-- vostè té una primera alimentar que el codi font com en d'entrada a una especial programa anomenat un compilador, la sortida de la qual veurà és el codi màquina. I, de fet, l'última vegada que parlem aproximadament, en realitat, al final del dia, solucionar problemes. Tens entrades. I vostè té sortides. I vostè té algun tipus d'algorisme en el medi. 

Els algoritmes poden ser sens dubte implementat en programari, com hem vist amb pseudocodi la setmana passada i com veurem amb codi real aquesta setmana. I així, de codi en realitat només té un conjunt d'algoritmes a l'interior de la mateixa que saber com convertir les paraules clau especials, com a principal, i printf, i altres que acabem va veure en els patrons de zeros i els que Intel Inside i altres CPU realment entén. Llavors, com fem això? D'on obtenim un compilador? 

La majoria dels que som aquí tenim un Mac o un PC. I s'està executant Mac OS, o Windows o Linux o Solaris, o qualsevol nombre d'una altra sistemes operatius. I, de fet, podríem sortir al web i descarregar un compilador per a la seva Mac o PC per al seu sistema operatiu en particular. No obstant això, tots estaríem en diferents pàgines, per dir-ho. Ens agradaria tenir una mica diferents configuracions. I les coses no funcionarien tot el mateix. I, de fet, en aquests dies molts de nosaltres no utilitzi programari que s'executa només en els nostres ordinadors portàtils. En canvi, fem servir una mica com un navegador que ens permet tenir accés basat en web- aplicacions en el núvol. I a finals d'aquest semestre, farem exactament això. Escriurem aplicacions o programari no usar code-- C, però altres llenguatges com Python i JavaScript-- que s'executen en el núvol. 

I per fer això, nosaltres mateixos durant el semestre en realitat utilitzar un núvol-basat ambient conegut com CS50 IDE. Aquesta és una programació basada en web medi ambient, o el desenvolupament integrat medi ambient, IDE, que està construïda sobre d'alguns programari de codi obert anomenat Cloud 9. I hem fet alguns pedagògica simplificacions en el per tal d'ocultar certes característiques en les primeres setmanes que no necessitem, després de la qual cosa es pot revelar-i fer la major part el que vulgui amb el medi ambient. 

I ens permet, també, per pre-instal·lar cert tipus de programari. Coses com un denominat CS50 biblioteca, que aviat veurem ens proporciona en C amb una mica funcionalitat addicional. Així que si vas a, en última instància, CS50.io, se li demanarà que ingressi, i una vegada que fas i crear un compte de forma gratuïta, vostè serà capaç d'accedir a una ambient que es veu bastant com aquest. 

Ara, això és en el mode per defecte. Tot és agradable i brillant a la pantalla. Molts de nosaltres tenim el costum de treballar en la peça que és CS50 bastant tard a la nit. I pel que alguns de vostès podrien preferir convertir-lo en manera nocturna, per dir-ho. 

Però, en última instància, el que està veurem dins IDE CS50 és de tres areas-- diferent una àrea de l'esquerra on seus arxius van a estar a l' núvol, una àrea en la part superior dreta on el codi serà editable. podràs obrir fitxes individuals per a qualsevol programa que s'escriu dins d'aquest semestre de la cantonada superior dreta. I llavors la majoria arcanamente, i no obstant això de gran abast, serà aquesta cosa al inferior coneguda com una finestra de terminal. 

Aquesta és una vella escola Interfície de línia d'ordres, o CLI, que permet executar ordres al computer-- en aquest cas, l'equip en el cloud-- per fer coses com compilar el codi des del codi font a codi màquina, per executar els seus programes, o per iniciar la seva servidor web, o per accedir a la base de dades, i qualsevol nombre d'altres tècniques que començarem a utilitzar després de poc temps. Però per arribar-hi, estem va a tenir realment anar en línia i començar a jugar. I per fer això, primer anem a començar jugant amb principal, i escriure la part principal d'un programa. I utilitzarem aquesta funció printf, que hem utilitzat anteriorment, simplement per dir alguna cosa. 

Així que aquí estic ja a l'interior de l'IDE CS50. He connectat amb antelació. I m'omple va exhibir la finestra. I així, en última instància, es també en problemes pròxims seguirà els mateixos passos que proporcionarà documentació en línia. Pel que no ha de preocupar sobre absorbint cada petit pas tècnic que faig avui aquí. 

Però obtindrà una pantalla com aquesta. Dóna la casualitat que en la manera nocturn. I es pot il·luminar tot per desactivació de la manera nit. I al final de la dia, vas a veure aquests tres principals areas-- l'arxiu navegador de l'esquerra, les llengüetes de codi sobre de la tapa, i la finestra de terminal a la part inferior. 

Déjame anar endavant i escriure el meu primer programa. Vaig a anar a Arxiu preventivament, Guardar i salvar la meva arxiu com hola.c. De fet, per convenció, qualsevol programa que escriuen que està escrit en el llenguatge C ha de tenir assignat un nom punt c, per convenció. Així que vaig a nomenar-hola.c, perquè Només vull dir hola al món. Ara vaig a enfocar i feu clic a Desa. I tot el que tinc aquí ara és una pestanya en el que puc començar a escriure codi. 

Això no va a compilar. Això no vol dir res. I pel que fins i tot si Vaig convertir això a zeros i uns, la CPU va a tenir cap idea del que està passant al voltant. Però si escric línies que coincideixen amb ser conventions-- C de C, de nou, aquesta language-- amb una sintaxi com això, printf hola món-- i no tinc ha sentit còmoda amb fer a través del temps. Així que no crec que vaig fer els errors tipogràfics. 

Però, invariablement, el primer vegada que ho faci, ho farà. I el que estic a punt de fer podria molt així no funcionar per a vostè la primera vegada. I això és perfectament bé, perquè en aquest moment es només podria veure una gran quantitat de novetat, però amb el temps una vegada que es familiaritzi amb aquest entorn, i aquest llenguatge, i altres, vostè començarà a veure les coses que són correctes o incorrectes. 

I això és el que el companys d'ensenyament i curs assistents es posen tan bo en el transcurs del temps, es la detecció d'errors o fallades en el seu codi. Però sostinc que hi ha hi ha errors en el codi. Així que ara vull per executar aquest programa. 

Ara, en el meu propi PC o Mac, estic en l'hàbit de fer doble clic a les icones quan vull executar algun programa. Però això no és el model aquí. En aquest entorn, que és CS50 IDE. Estem utilitzant un operatiu sistema anomenat Linux. Linux és una reminiscència d'un altre sistema operatiu, conegut generalment com Unix. I Linux és especialment conegut per que té una línia d'ordres per al Medi Ambient, la CLI. Ara, estem utilitzant una específica distribució de Linux anomenada Ubuntu. I Ubuntu és simplement una certa versió de Linux. 

Però d'aquests Linux en aquests dies fan realitat vénen amb interfícies gràfiques d'usuari. I la que ens ha tocat s'utilitza aquí està basat en web. Pel que aquest podria ser fins i tot una mica diferent d'alguna cosa vostè mateix pot ser que tingui vist o córrer en el passat. 

Així que seguiré endavant ara i fer el següent. He guardat aquest arxiu com hola.c. Vaig a seguir endavant i Tipus clanghello.c Així Clang per al llenguatge C és un compilador. És pre-instal lat en CS50 IDE. I es pot descarregar i absolutament instal al seu propi Mac o PC. 

Però, de nou, no tindries tots la configuració prèvia fet per a vostè. Així que per ara, només sóc va a executar clanghello.c. I ara compte aquesta sintaxi aquí amb el temps es compte només vol dir que estic en una carpeta o directori anomenat espai de treball. Aquesta mostra de dòlar és simplement convenció de sentit, escriviu les comandes aquí. 

És el que s'anomena un símbol, simplement per convenció és signe de dòlar. I si segueixo endavant ara i feu clic Introdueixi, res sembla haver succeït. Però això és realment una bona cosa. Si més no això succeeix en la seva pantalla, és més probable el codi és correcte, almenys sintàcticament. 

Així que si vull executar aquest programa, què faig? Doncs bé, resulta que la nom predeterminat per convenció per als programes quan no especifica una nom per al seu programa és només a.out. I aquesta sintaxi també, podràs familiaritzar-se amb poc temps. 

Dot slash només significa, bé, CS50 IDE, executi un programa anomenat a.out això és dins del meu directori actual. Aquest punt correspon al directori actual. I anem a veure quines altres seqüències de caràcters significa abans d'hora. 

Així que aquí anem, Enter, hola món. I es donarà compte, que el que ha passat? No només s'imprimeix hola món. També es va traslladar la cursor a la línia següent. 

I per què va ser això? Quin era el codi que escrivim abans que va assegurar que ho faria el cursor anar en la línia següent? El més graciós d'una equip és que només va fer literalment el que vostè li digui que fer. 

Així que si vostè li diu a printf hola, coma, espai, món, prop de la cita, És, literalment, només es va per imprimir els caràcters. Però tenia aquest caràcter especial al final, el record, la barra invertida n. I això és el que assegura que el caràcter es a la següent línia de la pantalla. 

De fet, em va deixar anar i fer això. Déjame anar per davant i esborrar això. Ara, observi que la la part superior de la pantalla hi ha una mica de llum vermella en la pestanya que indica, bo, no s'ha guardat l'arxiu. Així que seguiré endavant amb el control S o S comando, guardar l'arxiu. Ara goes-- va anar a donar un color verd moment--. I ara és hora de tornar a simplement ser una icona de tancament. 

Si ara corro clanghello.c de nou, Introduir, barra de punts, a.out, Enter, veurà que encara funcionava. Però és sens dubte una mica buggy. En aquest moment, el meu espai de treball prompt--, i després que el signe de dòlar, i després el meu prompt-- real és tot en la mateixa línia. Així que això certament un error estètic, encara que en realitat no és un error lògic. 

Així que vaig a desfer el que acabo de fer. Vaig a tornar a executar a.out. Avís He afegit el tornar caràcter de nova línia. He guardat l'arxiu. 

Així que vaig a tornar a executar a.out, i- maleïda sigui, un error, un error que significa error. Pel que la sentència és que tot i que He afegit la barra invertida n allà, re-guardat, van tornar a realitzar el programa, el comportament va ser el mateix. Per què seria? 

Em cal un pas, oi? Aquest pas clau anterior era que tens A-- quan canviï el seu codi font, Resulta que també funcionen mitjançant el compilador de nou perquè pugui obtenir nou codi màquina. I el codi màquina, els zeros i uns, van a ser gairebé idèntics, però no perfectament així, perquè necessitem, per descomptat, que la nova línia. 

Així que per solucionar aquest problema, vaig a necessitar tornar a executar clanghello.c, introdueixi, punt ratlla vertical, a.out. I ara, hola món està de tornada a on jo esperava que fos. Així que això és tot fi i bo. Però a.out és un nom bastant estúpid per a una programa, tot i que passa a ser, per raons històriques, la default-- significa sortides de muntatge. 

Però m'ho dius a mi anar per davant aquí i fer això de manera diferent. Vull que el meu programa hola món per realment ser anomenat hola. Així que si es tractés d'una icona en la meva escriptori, no es a.out. Es diria hola. 

Així que per fer això, resulta Clang que, igual que molts programes, dóna suport als arguments de línia de comandes, o banderes, o interruptors, que simplement influir en el seu comportament. En concret, So metàl·lic suporta un tauler o bandera, que al seu torn porta a una segona paraula. En aquest cas, em vaig de manera arbitrària, però raonablement, en diuen hola. Però podria anomenar de qualsevol Vull, excepte a.out, que seria més aviat el punt. 

I a continuació, només ha d'especificar el nom l'arxiu si vull compilar. Així que ara tot i que al principi de la comanda encara tinc Clang, al final de la comanda Encara tinc el nom de l'arxiu, Ara tinc aquests línia d'ordres arguments, aquestes banderes que estan dient, Oh, per cert, la producció-o, un arxiu hola trucada, no el a.out per defecte. 

Així que si prem enter ara, res sembla haver passat. I, però, ara que puc fer barra de punts hola. Així que és el mateix programa. Els zeros i uns són idèntics al final del dia. 

Però estan en dos a.out diferent archivos--, que és la primera versió i just anomenat tontament, i ara hola, el que és una gran part nom més convincent per a un programa. Però, honestament, mai estic va a recordar això de nou, i una altra, i una altra. I, en realitat, mentre escrivim programes més complicats, les ordres que vostè està va a haver d'escriure es posarà encara més complicat encara. 

I pel que no es preocupi. Resulta que els humans abans Ens hem adonat que ells també tingut aquest mateix problema. També ells no gaudien d'haver de escriviu les comandes, força llargs arcans, i molt menys recordar. I així els éssers humans que se'ns han fet altres programes que fan que sigui més fàcil per compilar el programari. 

I, de fet, un d'aquests programa es diu Make. Així que vaig a seguir endavant i fer-ho. Vaig a desfer tot el acaba de fer de la següent manera. Permetin-me LS tipus. I es donarà compte de tres coses- a.out, i una estrella, hola i una estrella, i hola.c. Amb sort, això hauria ser una mica intuïtiu, la mesura que anteriorment no havia res en aquest espai de treball. No hi havia res que jo tenia creat fins que vam començar a classe. 

I vaig crear hola.c. llavors jo compili, i el va anomenar a.out. I després he recopilat de nou lleugerament de manera diferent i el va anomenar hola. Així que tinc tres arxius en aquest directori, En aquesta carpeta es diu espai de treball. Ara, puc veure que al seu torn si Allunyar realitat. 

Si Allunyar aquí i mira aquest superior dreta cantonada, com s'havia promès l'esquerra costat de la pantalla sempre va a mostrar el que està en el seu compte, el que és dins de l'IDE CS50. I hi ha tres arxius allà. 

Així que vull per desfer-a.out i hola. I com pot ser que imaginar intuïtivament, es podria tipus de control de clic o feu clic dret sobre aquesta. I aquest petit menú emergent. Podeu descarregar l'arxiu, executi que, vista prèvia, actualitzar, canviar el nom, o el que no. 

I jo només podia eliminar, i se n'aniria. Però anem a fer les coses amb una ordre línia de moment, de manera que se senti còmode amb això, i fer el següent. Vaig a seguir endavant i eliminar a.out escrivint literalment rma.out. Resulta que, la comanda de l'eliminació o eliminació d'alguna cosa, no elimina ni esborra. 

És més succintament RM, només per estalviar que algunes combinacions de tecles i premeu la tecla Enter. Ara anem a ser alguna cosa crípticament eliminar a.out regular. Realment no sé el que és una arxiu irregular seria encara. Però sí vull llevar-ho. 

Així que vaig a escriure i per a si. O podria escriure un cop d'ull, i prem Enter. I, de nou, sembla que no passa res. Però això és, en general, una bona cosa. 

Si escric LS aquest temps, ¿Què he de veure? Amb sort, tot just hola i hola.c. Ara, com un part, se li compte d'aquesta estrella, asterisc, això és al final dels meus programes. I també estan mostrant en color verd. Això és només el camí del CS50 IDE que cluing en el fet que aquest no és el codi font. Això és un executable, un executable programa que en realitat es pot executar fent barra de punts, i després el seu nom. 

Ara, deixa anar per davant i treure això, rm hola, Introduir, eliminar regulars presentar hola, si. I ara si escric LS, estem de tornada a hola.c. Intenta no eliminar el seu codi font real. Tot i que hi ha característiques incorporat a IDE CS50 on vostè pot anar a través del seu historial de revisions i retrocedir en el temps si accidentalment esborrar alguna cosa, fer tenir en compte segons aquestes indicacions si o no, del que realment vol fer. I si em vaig fins al cim cantonada esquerra mà aquí, tot el que queda és hola.c. Així que hi ha raïms de altres comandaments que pot executar en el món de Linux, un dels quals és, de nou, Fes. I farem el meu programa ara de la següent manera. 

En comptes de fer soroll metàl·lic, en lloc de fer soroll metàl·lic-o, Vaig a simplement literalment, tipus, marca hola. I ara noto, jo sóc No escrivint make hola.c. Estic escrivint fan hola. 

I aquest programa Feu aquest ve amb l'IDE CS50, i molt més generalment amb Linux, és un programa que és va a fer un programa anomenat Hola. I que suposarà, per convenció, que si aquest programa es pot fer, que serà a partir d'una font arxiu de codi que acaben en c punt, hola.c. 

Així que si colpeig Entra ara, l'avís que la comanda que s'executa és fins i tot més llarg abans que abans. I això és perquè hem IDE CS50 preconfigurat per tenir algunes característiques addicionals incorporades a aquest no necessitem de moment, però aviat ho farà. Però la clau per adonar és que ara tinc un programa Hola. 

Si escric LS de nou, tenir un programa de hola. I puc executar-lo amb slash dot a.out, no, perquè l'objectiu d'aquest exercici va ser punt hola barra. I ara tinc el meu programa hola món. Així es mou cap endavant, estem gairebé sempre sol va a compilar els nostres programes utilitzant la comanda Crea. I després anem a executar-les punt slash, i el nom del programa. Però adonar-se del que fan està fent per vostè, és que no és en si un compilador. És només un programa de conveniència que sap com activar un compilador per funcionar de manera que vostè mateix pot utilitzar-lo. 

El que hi ha altres comandaments en Linux, i al seu torn l'IDE CS50? Aviat veurem que hi ha una comandament CD, Canviar directori. Això li permet a la interfície de línia d'ordres per seguir endavant i cap enrere, i obrir diferents carpetes sense necessitat d'utilitzar el ratolí. 

LS que vam veure, que significa llista els arxius en el directori actual. Fer Dir, pot probablement començar a deduir el que signifiquen ara-- fer directori, Per crear una carpeta. RM de Remove, RM Dir eliminar directory-- i aquests, de nou, són la línia d'ordres equivalents del que podria fer en CS50 IDE amb el ratolí. No obstant això, aviat es trobarà que de vegades és només molt més ràpid que fer coses amb un teclat, i en última instància molt més potent. 

Però és difícil argumentar que tot el que hem estat fent fins ara és tot el que poderosa, quan tot que hem estat dient és, hola món. I, de fet, la hardcoded paraules hola món en el meu programa. No hi ha dinamisme encara. Scratch va ser un ordre de magnitud més interessant la setmana passada. 

I així anem a arribar-hi. Anem a fer un pas cap a la qual per forma d'algunes d'aquestes funcions. Així que no només vénen amb C printf, i raïms d'altres funcions alguns dels quals ja veurem amb el temps, no ho fa que sigui tan fàcil a la dreta de la porta per aconseguir l'entrada de l'usuari. 

De fet, una de les debilitats de llenguatges com C, i fins i tot Java i, en canvi altres, és que no ho fa fer més fàcil per obtenir només les coses com nombres enters d'usuaris, o cadenes, paraules, i frases, deixar que les coses per si sols com valors de punts o nombres reals flotants amb punts decimals, i realment números llargs, com aviat veurem. Pel que aquesta llista de funcions aquí, aquests són com altres peces del trencaclosques de Scratch que hem pre-instal lat en CS50 IDE que utilitzarem durant unes poques setmanes com rodes d'entrenament de les classes, i finalment treure-se'ls, i buscar sota el capó, potser, per la qual com s'implementen aquestes coses. 

Però per fer això, anem a En realitat escriure un programa. Déjame anar endavant ara. I jo vaig a crear un nou arxiu fent clic en aquest petit plus, i fent clic a Nou arxiu. 

Vaig a guardar aquesta propera un com, diguem, string.c, perquè vull jugar amb cordes. I la cadena en C és només una seqüència de caràcters. Així que ara seguirem endavant i fer el següent. 

Incloure estàndard i IO.h-- Resulta que IO estàndard, IO només significa d'entrada i de sortida. Així resulta que aquesta línia aquí és el són els EUA veïna d'usar printf. Printf, per descomptat, produeix una sortida. Així que per tal d'utilitzar printf, resulta a terme vostè ha de tenir aquesta línia de codi a la part superior del seu arxiu. 

I anem a tornar al que que realment significa en poc temps. Resulta que en qualsevol programa C que escric, He de començar amb codi que s'assembla a això. I vostè notarà CS50 IDE, i una altra de desenvolupament integrat ambients com ella, Anem a tractar de la millor que poden acabar el seu pensament. De fet, fa un moment, si jo desfer el que he fet, em va colpejar Retorn. 

llavors em va colpejar arrissat obert cotilla, premeu la tecla Enter de nou. I es va acabar el meu pensament. Em va donar una nova línia, sangria no menys per raons d'estil agradable ja veurem. I llavors em surt de forma automàtica que claudàtor per acabar el meu pensament. Ara bé, no sempre suposo que el que vol fer. No obstant això, en gran part, ho fa que estalviar una mica les pulsacions de teclat. Així que fa un moment, ens trobem amb aquest program-- hola, món, i després compilat, i després va córrer la mateixa. Però no hi ha dinamisme aquí. El que si volíem fer alguna cosa diferent? Bé, i si jo volia en realitat obtenir una cadena de l'usuari? Vaig a utilitzar una peça del trencaclosques diu exactament això-- aconseguir cadena. 

Resulta que a C que quan vostè no vol per proporcionar informació a una peça del trencaclosques, o més correctament a una funció, literalment només fer parèntesi obert, parèntesi de tancament. Així que és com si hagués cap caixa blanca per escriure en. El bloc dir abans tenia una petita caixa blanca. No tenim aquesta caixa blanca ara. 

Però quan dic cadena GET, em voler posar el resultat en algun lloc. Així que un paradigma molt comú en C és cridar a una funció, com la cadena d'arribar aquí, i després emmagatzemar el seu valor de retorn. És el resultat de la seva esforç en alguna cosa. 

I el que és el construir a la programació, ja sigui en Scratch o C ara, que nosaltres es pot utilitzar per emmagatzemar en realitat alguna cosa? Va cridar una variable, oi? I en Scratch, realment no ho cuidar el que estava passant en les variables. 

Però en aquest cas, que realment fem. Vaig a dir cadena. I llavors jo podria anomenar això el que vulgui. Vaig a dir- nom, aconsegueix arribar cadena. 

I ara, fins i tot si ets una mica nou en això, Noto que em falta algun detall. M'estic oblidant d'un punt i coma. He de acabar aquest pensament. Així que vaig a moure el cursor, i prem punt i coma allà. I el que he acabo de fer? En aquesta línia de codi, el número 5 en el moment, Vaig a trucar a cadena GET sense entrades. Així que no hi ha poc de blanc caixa com el bloc té Desa. 

Només estic dient, hey, equip, porta-me'n una cadena. El signe igual no és realment un signe igual, per se. És l'assignació operador, el que significa, Hey, ordinador, mogui el valor des de la dreta cap a l'esquerra. I a l'esquerra, tinc el següent. 

Hey, ordinador, fes-me un string-- una seqüència de caràcters. I cridar a aquesta cadena Nom. I no tenen ni tan sols dir-Nom. 

Podria anomenar-lo, convencionalment, una mena de S, de la mateixa manera que hem utilitzat per a i trucar a la variable i. Però ara he de fer alguna cosa amb ell. Seria molt estúpid per de compilar el codi, s'executa aquest programa, tot i que Estic rebent una cadena, perquè encara és només dirà hola món. 

Però què passa si vull canviar això. Per què no puc fer això? Percentatge s, s comes. I això és una mica críptic encara. 

Així que permetin-me fer la meva variables més clara. Permetin-me esmentar aquesta variable Nom. I vegem si no podem molestar a part del que està passant aquí. 

Així que en la línia cinc, estic rebent una cadena. I jo estic emmagatzemant aquesta cadena, qualsevol que sigui l'usuari ha escrit a en el seu teclat, en una variable anomenada Nom. I resulta que printf fa no només prendre un argument de doble cites, una entrada entre cometes dobles. 

Pot prendre dues, o tres, o més, tal que la segona, o tercera, o quarta, són tots els noms de les variables, o valors que és propi, que vol connectar a, dinàmicament, aquesta cadena entre cometes. En altres paraules, què seria dolent en això? Si acabo de dir hola nom, la barra invertida n, salvat el meu arxiu, compilat el meu codi, i va córrer això, què passaria? 

És només dirà, hola nom, literalment N-A-M-I, que és una espècie d'estúpida perquè no és diferent del món. Així que qualsevol cosa és entre cometes el que, literalment, s'imprimeix. Així que si vull tenir un marcador de posició allà, En realitat necessito utilitzar una sintaxi especial. I resulta que si vostè llegeix el documentació de la funció printf, se li dirà que si s'utilitza per cent s, es pot substituir un valor de la següent manera. 

Després d'una coma després que cometes dobles, simplement escriure el nom de la variable que es vol per endollar en aquest format codi, o especificador de format, s per cent per a les cordes. I ara si m'he salvat el meu arxiu, Torno al meu terminal. I Tipus Marca de cordes, perquè, de nou, el nom d'aquest arxiu que he triat és string.c abans. 

Així que vaig a dir Prefix, introdueixi. Oh Déu, mira a tots els errors que hem fet ja. I això ho és--, això és realment com un programa de línia de sis 07:00? Així que aquí és on es pot molt obtenir ràpidament aclaparadora. 

Aquesta finestra de terminal té ara només regurgitat un gran nombre de missatges d'error. Sens dubte, no tinc més errors missatges del que tenen línies de codi. Llavors, què està passant? 

Bé, la millor estratègia de fer en qualsevol moment que no trobar-se amb una aclaparadora llista d'errors per l'estil, està desplaçar-se cap enrere, miri per la comanda que acaba d'executar, que en el meu cas és fer cordes. Mira el que fan ho va fer, i això és tot Clang comandament llarga, no és gran cosa allà. 

No obstant això, el vermell és dolent. Verd està tractant de ser gentil i servicial. Però segueix sent dolent, en aquest cas. Però on està el mal? 

String.c, la línia 5, de cinc caràcters. Així que això és només convenció comú. significa alguna cosa de còlon alguna cosa número de línia i el nombre de caràcters. Error, no declarada d'ús cadena d'identificador. Va voler dir estàndard en? 

Així que, per desgràcia, Clang està tractant de ser útil. Però és dolent, en aquest cas. No, Clang, no era la meva intenció IO estàndard. Vull dir que en la línia un, si. 

Però la línia cinc és aquest d'aquí. I Clang no ho fa entendre S-T-R-I-N-G. És un identificador no declarat, un paraula que simplement mai ha vist abans. I això és perquè C, el llenguatge estem creant programes en aquest moment, no té variables anomenades cadenes. 

Altrament, per defecte, el suport cosa que es diu una cadena. Això és un tros de CS50 argot, però molt convencional. Però puc solucionar aquest problema de la següent manera. 

Si afegeixo una línia de codi a la part superior d'aquest programa, incloure CS50.h, que és un altre arxiu en algun lloc dins el CS50 IDE, en algun lloc en el disc dur, per així dir-ho, del sistema operatiu Ubuntu que estic corrent, que és l'arxiu que està va a ensenyar el funcionament sistema del que és una cadena, simplement io.h com a estàndard és l'arxiu en el sistema operatiu que és va a ensenyar el que és printf. 

De fet, hauríem aconseguit un missatge molt similar Si IO havia admès norma Io.h i va tractar d'usar printf. Així que vaig a seguir endavant i just control de la presa L per esborrar la pantalla. O pot escriure clar i ho farà acaba de netejar la finestra del terminal. Però encara es pot desplaçar cap a enrere en el temps. 

I vaig a tornar a executar Fer una cadena. Creuar els dits aquesta vegada, Retorn. Oh, Déu meu, va funcionar. que em mostra una ordre llarg críptica això és el que fa que genera a través de So metàl·lic, però cap missatge d'error. Així adonar-se'n, tot i que podria obtenir per complet aclaparat amb la nombre de missatges d'error, que només podria ser aquest molest en cascada efecte, en Clang no entén una cosa, el que significa que llavors no entén la paraula següent, o la línia següent. I pel que només s'ofega amb el seu codi. No obstant això, la solució pot ser molt senzilla. I pel que sempre es centren en el primera línia de sortida. I si no ho fa comprendre-ho, només cal veure per a les paraules clau que podria ser pistes, i el número de línia, i el caràcter, on aquest error podria ser. 

Ara vaig a seguir endavant i escric punt slash, cadena, introdueixi. Hm, no està dient hola res. Per què? Doncs bé, cal recordar, on està executant? 

Probablement és atrapat de moment en un bucle, si es vol, en la línia 6, Obtenir causa de cadenes per disseny, escrita pel personal CS50, és, literalment, significava per seure no esperar, i esperar, i l'espera d'una cadena. Tot el que entenem per cadena és la intervenció humana. Així que ja saben què? Déjame anar per davant. I només en un caprici, em va deixar escriure el meu nom, David, introdueixi. Ara tinc un programa més dinàmic. Es va dir, hola David. 

Si segueixo endavant i córrer de nou, vaig a tractar de dir el nom Zamila, introdueixi. I ara tenim un programa dinàmic. No he codificat món. No he codificat nomenar, o David, o Zamila. 

Ara és molt més semblant als programes sabem, en la qual si es triga d'entrada, produeix resultats lleugerament diferents. Ara bé, això no és el millor l'experiència de l'usuari, o UX. Puc executar el programa. 

No sé el que se suposa a fer, llevat que en realitat miro o recordar el codi font. Així que farem l'usuari experimentar una mica millor amb el més simple de les coses. Permetin-me tornar a aquest programa, i simplement dir printf. 

I m'ho dius a mi seguir endavant i dir el seu nom, de còlon, i un espai, i després un punt i coma. I només per diversió, sense folgança n. I això és deliberada, perquè jo no vull l'indicador per passar a la següent línia. 

Vull, en canvi, fer això, fer cordes tornar a compilar el codi en la nova màquina codi de punts slash cadena. Ah, això és molt més bonica. Ara sé que en realitat el que l'ordinador vol que posi, donar-li un nom. 

Així que vaig a seguir endavant i escriure en Rob, entrar, i hola, Rob. Per tant, es dóna compte, això segueix sent, al final del dia, només un programa de nou línies. Però hem pres aquests passos de bebè. 

Vam escriure una línia amb la qual ens estaven familiaritzats, printf, hola món. A continuació, ens vam desfer d'una mica d'això. I que en realitat fem servir cadena GET. I tirem aquest valor en una variable. I després vam seguir endavant i millorat encara més amb una tercera línia. I aquest procés iteratiu de l'escriptura de programari és realment la clau. En CS50, i en la vida en general, en general, no ha de seure, tenir un programa en ment, i tractar d'escriptura tota la maleïda cosa alhora. 

Serà, inevitablement, com a resultat de la manera més errors que nosaltres mateixos vam veure aquí. Fins i tot jo, a dia d'avui, en constant fer altres errors estúpids, són errors de fet més dures que són més difícils d'entendre. Però va cometre més errors més línies de codi que escriuen tots alhora. I pel que aquesta pràctica de, escriure una mica de codi que se senti còmode, compila que, executar-lo, provar-ho de forma més general, A continuació, passar pel en-- la mateixa manera que vam mantenir capes i capes de la setmana passada, la construcció d'una cosa molt senzill d'una mica més complex, fer el mateix aquí. No se sent, i tractar de escriure tot un problema. En realitat prendre aquests passos de bebè. 

Ara, les cadenes no són tots tan útil per a si mateixos. Ens havíem fet, idealment, igual que té una mica més a la nostra caixa d'eines. Així que en realitat fan exactament això. 

Déjame anar per davant ara ja aixecar un programa lleugerament diferent. I anem a trucar a aquest Int.C, per sencer. Vaig a, de manera similar, incloure CS550.h. Vaig a incloure IO estàndard. I això va a ser bastant comú en aquests primers dies de la classe. 

I vaig a llistes a mi mateix amb una funció principal. I ara en comptes d'aconseguir una cadena, seguirem endavant i obtenir un int. Diguem que és i, i en diuen arribar int, prop parens, punt i coma. I ara farem alguna cosa amb ell, printf. 

Diguem alguna cosa així com hola, la barra invertida n, i coma. Així que estic més o menys imitant el que vaig fer fa un moment. Tinc aquí un marcador de posició. Heus aquí per comes I, perquè vull per tapar i en què marcador de posició. 

Així que seguirem endavant i tractar l'elaboració d'aquest programa. L'arxiu es diu int.c. Així que vaig a dir, fer int, ingressi. Oh el meu Déu, però no és gran cosa, oi? Hi ha un error. 

Hi ha un error sintàctic aquí de manera que el programa no pot compilar dins Int.C, línia set, 27 caràcters, format d'error especifica tipus char estrella, qualsevol que sigui. Però el tipus d'argument és de tipus int. 

Així que aquí, també, no anem A-- tot i que avui dia és una gran quantitat de material, anem a omplir-te de absolutament totes les característiques de C, i programar de manera més general, en tan sols aquestes primeres setmanes. Sempre hi ha sovint serà l'argot amb el qual no està familiaritzat. I, de fet, estel char és una cosa tornarem a en una setmana o el temps de dos. 

Però per ara, anem a veure si podem analitzar les paraules que són familiars. Formatos-- pel que sentim format especificador, codi de format abans. Això és familiar. Type-- però l'argument té tipus int. Espera un minut, i és un sencer. 

Potser en realitat s per cent té un significat definit. I, de fet, ho fa. Un sencer, si desitja printf per substituir-lo, en realitat s'ha de fer servir una especificador de format diferent. I no vas a saber això llevat que algú li va dir, o si ho havia fet abans. Però per cent i és el pot ser utilitzat comunament en printf per connectar un nombre sencer. També pot usar cent d per un sencer decimal. Però i és agradable i simple aquí. Així que anirem amb això. 

Ara vaig a seguir endavant i torneu a executar make int, Retorn. Això és bo, no hi ha errors. Dot slash OK int--, mala experiència d'usuari, perquè no m'he dit Què fer. Però això està bé. M'estic posant en forma ràpida. 

I ara me n'aniré endavant i escrigui en David, OK, Zamila, Rob. D'acord, pel que aquesta és una bona cosa. Aquest cop, estic fent servir una funció, una peça del trencaclosques, anomenat get int. I resulta out-- i anem a veure això més endavant en el term-- el personal CS50 ha implementat obtenir una cadena de tal manera que ho farà només físicament obtenir una cadena per a vostè. 

S'ha implementat int posar-se en de tal manera que només es obtenir un nombre sencer per a vostè. I si, l'ésser humà, no cooperen, és literalment només va a tornar a intentar dir, tornar a intentar tornar a intentar, literalment assegut en bucle, fins obligar-amb un nombre màgic, així com 50, 50 i hola. 

O si correm això una altra vegada i el tipus en el 42, 42 hola. I així, la funció get int dins d'aquesta peça del trencaclosques és suficient la lògica, prou pensament, d'esbrinar, el que és una paraula? I el que és un nombre? Només acceptant, en última instància, nombres. 

Així que resulta que aquesta No és tot el que expressiva. fins ara. Així, yay, l'última vegada que va ser bastant ràpid en els jocs d'execució, i l'animació, i les obres artístiques a zero. I aquí, estem sent contingut amb el món hola, hola i 50. 

No és tot el que inspirador. I, de fet, aquests primers exemples prendrà algun temps a la rampa sobre de l'emoció. Però tenim molt més controlar ara, de fet. I anem a molt iniciar ràpidament l'estratificació a la part superior d'aquestes primitives bàsiques. 

Però primer, anem a entendre quines són les limitacions. De fet, una de les coses Zero no fa fàcil fem que realment es mira sota de la campana, i entendre el que és una ordinador és, el que pot fer, i quines són les seves limitacions. I, de fet, que la manca de comprensió, potencialment, a llarg termini pot conduir a la nostra pròpia escriptura mistakes-- insectes, escriptura programari insegur que és atacada d'alguna manera. 

Així que anem a donar alguns passos cap entendre això una mica millor per forma de, per exemple, el següent exemple. Vaig a seguir endavant i posar en pràctica molt ràpid un programa anomenat Adder. Igual, anem a afegir alguns números junts. I vaig a codificar alguns revolts aquí, i simplement copiar i enganxar on estava abans, només pel que podem aconseguir que va abans. Així que ara tinc els principis bàsics d'un programa anomenat Adder. 

I seguirem endavant i fer això. Vaig a seguir endavant i per exemple, inTX aconsegueix obtenir int. I saps què? Anem a fer una millor experiència d'usuari. 

Així que diguem que x és, i efectivament demanar a l'usuari que ens dóna x. I després em va deixar anar endavant i dir, printf Què tal que i és, aquesta vegada esperant dos valors de l'usuari. I a continuació, seguirem endavant i per exemple, printf, la suma de x i y és. I ara no vull fer s per cent. Vull fer-ho per cent i, la barra invertida n i, a continuació, connecteu valor de la suma. 

Llavors, com puc anar fent això? Tu saps que? Sé com utilitzar variables. Em van deixar de declarar una nova, int z. 

I vaig a prendre una conjectura aquí. Si hi ha signes iguals en aquest idioma, potser jo puc fer x més i, sempre que terme el meu pensat amb un punt i coma? Ara puc tornar aquí baix, connecti z, acabar aquest pensament amb un punt i coma. I anem a veure ara, si aquests seqüències de x lines-- és aconseguir int. I és aconseguir int. 

Afegir x i y, emmagatzemar el valor en z-- pel que, de nou, recordar el signe igual no és igual. És tasca de dreta a esquerra. I anem a imprimir que la suma de X i Y no és literalment z, però el que hi ha dins de z. Així que farem Negre - agradable, no hi ha errors aquesta vegada. Dot slash Adder, entrar, x serà 1. 

I va a ser 2. I la suma de x i y es 3. Així que això és tot fi i bo. 

Per tant és d'imaginar que les matemàtiques ha de treballar en un programa com aquest. Però saps què? És aquesta variable, la línia 12, fins i tot necessari? No cal entrar en l'hàbit de simplement emmagatzemar coses en les variables només perquè és possible. I, de fet, en general és mal de disseny considerat si crearà una variable, anomenada z en aquest cas, l'emmagatzematge d'alguna cosa en ell, i immediatament després usar-lo, però mai més. Per què donar un nom a alguna cosa z com si estàs literalment que utilitzarà cosa només un cop, i per tant proximal a on va crear en primer lloc, tan a prop en termes de línies de codi? Així que ja saben què? Resulta que C és bastant flexible. Si jo en realitat vull plug-in dels valors aquí, No necessito per declarar una nova variable. Tan sols pogués plug-in de x més I, pel fet que C entén aritmètica i operadors matemàtics. 

Pel que simplement puc dir, fer això de matemàtiques, x més i, el que aquests valors són, connecti el resultant sencer en aquesta cadena. Pel que aquest podria ser, tot i que només una línia més curta, un millor disseny, un programa millor, perquè hi ha menys codi, per tant, menys per a mi entendre. I també és simplement més net, en la mesura que no estem la introducció de noves paraules, nous símbols, com z, tot i que en realitat no servirà molt d'un propòsit. 

Per desgràcia, no és matemàtiques tots els que de vegades fiables. Seguirem endavant i fer això. Vaig a seguir endavant ara i fer el següent. 

Farem printf, i per cent, més cent I, es cent i, n barra invertida. I jo faré això- xix més i. Així que només vaig a reescriure aquesta forma lleugerament diferent aquí. Em van deixar de fer una comprovació de validesa ràpida. Un cop més, no sortirem endavant de nosaltres mateixos. Fer sumador, punt sumador de barra. x és 1, i és 2, 1 més 2 és 3. I això és bo. Però anem a complicar això ara una mica, i crear un nou arxiu. 

Vaig a trucar a aquest, dir, enters, plural per als sencers. Permetin-me començar on era fa un moment. Però ara anem a fer algunes altres línies. Déjame anar endavant i fer el següent, printf, i per cent, menys el percentatge d'i, és cent i, coma x, ix mengi menys i. Així que estic fent una mica diferent matemàtiques allà. Anem a fer un altre. Així per cent i multiplicada per cent I és i cent, la barra invertida n. Anem a plug-in de x i y, i els temps de xi. Utilitzarem l'asterisc en l'equip de vegades. 

No utilitza x. x és un nom de variable aquí. S'utilitza l'estrella per la multiplicació. Anem a fer una més. Printf cent I, dividit per cent i, i és per cent, n barra invertida. xi dividit per I- de manera que utilitzar la barra diagonal en C fer la divisió. I farem un altre. La resta de cent i, dividit per cent i, i és cent. xy-- i ara resta és el que queda. Quan intenta dividir una denominador reduint-los a un numerador, Quant queda més que no es podia dividir a terme? 

Així que no hi ha realment, necessàriament, un símbol que hem utilitzat a l'escola primària per això. Però hi ha en C. Pot dir x mòdul i, on aquest signe de percentatge en aquesta context-- confusament quan estàs dins de les cometes dobles, dins printf, cent s'utilitza com l'especificador de format. 

Quan s'utilitza per cent fora de que, en una expressió matemàtica, és l'operador de mòdul per modular arithmetic-- per als nostres propòsits aquí, només vol dir, quin és la resta de x dividit per i? Així x dividit per i és x barra i. Quin és la resta de X dividit per I? És xi mod, com diria un programador. 

Així que si he comès cap error aquí, em va deixar seguir endavant i fer sencers, plural, agradable, i sencers de la ratlla vertical de punts. I seguirem endavant i fer, diguem, 1, 10. D'acord, 1 més 10 és 11, xec. 1 menys 10 és negativa 9, comprovi. 

1 vegades 10 és 10, xec. 1 dividit per 10 és-- OK, ens saltarem que un. La resta d'1 dividit per 10 és 1. Això és correcte. Però hi ha un error aquí. 

Així que el que jo posar el meu lliurar, no és correcte. És a dir, que està a prop de 0. 1 dividit per 10, ja saps, si estem tallar algunes cantonades, segur, és zero. Però en realitat hauria de ser 1/10, 0,1, o 0,10, 0,1000, o així successivament. 

Realment no hauria de ser zero. Doncs bé, resulta que l'equip està fer literalment el que li vam dir que fes. Estem fent matemàtiques com x dividit per i. I tots dos X i Y, per les línies de codi anterior, són nombres enters. 

D'altra banda, en la línia 15, que som printf dient, hey, printf plug-in un enter, plug-in d'un nombre sencer, plug-in d'un integer-- específicament x, i, a continuació i, a continuació, x dividit per i. x i y són enters. Estem bé. 

Però el que es divideix per x x? x dividit per i hauria de ser, matemàticament, 1/10, o 0,1, que és un nombre real, un nombre real tenir, potencialment, un punt decimal. No és un nombre enter. 

Però el que és el més proper nombre sencer de 1/10, o 0,1? Sí, és com que és igual a zero. 0,1 és com això molt. I 1 és tant. Així desena està més a prop de 0 el que és per a un. 

I així ho està fent per C nosaltres-- tipus de perquè ens van dir que A-- es truncant que sencer. Es tracta de prendre el valor, que és una altra vegada se suposa que és una cosa així com 0,1000, 0 i així successivament. I s'està truncant tot després del punt decimal de manera que tot això coses, perquè no ho fa cabre en la noció d'un nombre enter, el qual és només un nombre negatiu com 1, 0, 1, amunt i avall, es llença a les escombraries tot el després del punt decimal perquè No pot cabre un punt decimal en un nombre sencer per definició. 

Així que la resposta és zero. Llavors, com podem solucionar aquest problema? Necessitem una altra solució tots junts. I podem fer això, de la següent manera. 

Déjame seguir endavant i crear una nova arxiu, aquest crida floats.c. I guardar-aquí al mateix directori, float.c. I m'ho dius a mi anar per davant i copiar alguns que el codi d'abans. 

Però en lloc de 1 int, farem això. Dóna'm un valor de punt flotant anomenada x. on un punt flotant valor és només literalment alguna cosa amb un punt flotant. Pot moure cap a l'esquerra, a la dreta. És un nombre real. 

I no sigui jo dic obtenir int, però arribar flotador, que també estava entre el menú d'opcions a la biblioteca C250. Anem a canviar i a un flotador. Així que això es converteix en aconseguir flotador. 

I ara, no volem que endollar sencers. Resulta que hem de fer servir cent f de flotació, f cent de flotador, i ara guardar-lo. I ara, els dits creuats, fan flotadors, agradable, flotadors de la ratlla vertical de punts. x serà un 1. i Serà 10 una altra vegada. 

I, bé, bé la meva addició és correcta. M'esperava més, però es va oblidar escriure-ho. Així que anirem i corregir aquest error lògic. 

Seguirem endavant i agafar el següent. Només haurem de fer una mica de copiar i enganxar. I diré menys. 

I vaig a vegades dir. I jo vaig a dir dividida. I jo no faré de mòdul, que no és tan pertinent aquí, dividits per f, i els temps Plus-- OK, anem a fer això una altra vegada. 

Fer flotadors, flotadors de la ratlla vertical de punts, i 1, 10, i- agradable, no, OK. Així que sóc un idiota. Així que això és molt comú en ciències de la computació a cometre errors estúpids com aquest. 

Per a fins pedagògics, el que realment volia fer va ser canviar la ciència aquí que a més, com a mínim, de vegades, i per separar, ja que és d'esperar notat durant aquest exercici. Així que ara anem a tornar a compilar aquest programa, fer flotadors de la ratlla vertical de punts. 

I per tercera vegada, anem a veure si compleix amb les meves expectatives. 1, 10, entrar, sí, està bé, 1.000, dividit per 10.000, és 0,100000. I resulta que podem controlar el nombre de nombres són després d'aquests punts decimals. En realitat ho farà. Tornarem a això. 

Però ara, de fet, els càlculs són correctes. Així, de nou, quin és el menjar per emportar en aquesta llista? Resulta que en C, hi ha no només simplement strings-- i, de fet, en realitat no hi ha, perquè afegir els de la biblioteca CS50. Però no són només sencers. 

Hi ha també flota. I resulta que un munt d'altres dades tipus també, que farem servir en poc temps. Resulta que si vols una sola caràcter, no una cadena de caràcters, pot utilitzar simplement un char. 

Resulta que si vols un bool, un valor booleà, veritable o fals només, Gràcies a la biblioteca CS50, hem afegit a C el tipus de dades BOOL també. Però també és present a molts altres idiomes també. I resulta que de vegades necessitarà un nombre més gran que vénen per defecte amb enters i flotadors. 

I, de fet, un doble és un nombre que utilitza no 32 bits, però 64 bits. I un llarg temps és un nombre que no utilitza els bits 32, sinó 64 bits, respectivament, per coma flotant valors i nombres enters, respectivament. Així que anem a realitat ara veure això en acció. 

Vaig a seguir endavant aquí i preparar ràpidament un altre programa. Aquí, seguiré endavant i no incloure CS50.h. I m'ho dius a mi anar, incloure norma io.h. 

I es donarà compte d'una cosa enrotllat està passant aquí. No és de codificació de color a les coses de la mateixa manera com ho va fer abans. I resulta que, això és perquè no han donat la cosa un nom de fitxer. 

Vaig a trucar a aquest sizeof.c, i va colpejar a Desa. I adonar-se del que passa al meu molt codi blanc contra aquest teló de fons negre. Ara, almenys hi ha alguns porpra allà. I és ressaltat de sintaxi. 

Això és perquè, simplement, no tinc va dir l'IDE quin tipus d'arxiu és donant-li un nom, i específicament una extensió d'arxiu. Ara, seguirem endavant i fer això. Vaig a seguir endavant i molt simplement imprimiu el bool following-- és LU cent. 

tornarem a que en un moment. I després vaig a mida d'impressió de bool. I ara, només per estalviar jo algun temps, estic va a fer en el seu conjunt manat d'aquests alhora. I, en concret, vaig a canviar això a un char i la carbonissa. Aquest, canviaré a un doble i un doble. 

Aquest, canviaré a un flotador i un flotador. Aquest, vaig a canviar a un int i un int. I aquest, vaig per canviar a un llarg temps. I encara està tenint molt de temps, molt temps. 

I després, finalment, vaig jo una copa de més, cadena. Resulta que en C, hi ha l'operador especial anomenat mida d'aquest literalment anar a, quan s'executa, dir-nos la mida de cadascuna d'aquestes variables. I aquesta és una manera, ara, podem connectar de nou a la discussió de la setmana passada de les dades i la representació. 

Déjame seguir endavant i compilar mida de mida de barra de punt de. I anem a veure. Resulta que en C, específicament en CS50 IDE, específicament en la sistema operatiu Ubuntu, que és un operatiu de 64 bits sistema en aquest cas, 1 bool va a utilitzar un byte d'espai. Així és com es mesura la grandària, no en bits, però en bytes. I recorden que és un byte de vuit bits. Pel que un bool, tot i que tècnicament només necessita un 0 o 1, que és una mica malgastador la forma en què hem implementat. Que en realitat va a utilitzar en el seu conjunt byte-- el que tots els zeros, són potser tots els estimats, o alguna cosa per l'estil, o només un dels vuit bits 1. 

Un char, per la seva banda, utilitza un caràcter com un caràcter ASCII a la setmana passada, serà un personatge. I que se sincronitza amb la nostra noció de que sigui no més de 256 bits-- més aviat, sincronitza amb ella sense estar més de 8 bits, que ens dóna un màxim de 256 valors. Un doble va ser de 8 bytes o 64 bits. 

Un flotador es 4. Un int es 4. Fa molt, molt és 8. I és una cadena de 8. Però no es preocupi per això. Anem a pelar aquesta capa. Resulta, cordes poden tenir més de 8 bytes. 

I, de fet, hem escrit cordes ja, hola món, més de 8 bytes. Però anem a tornar a que en un moment. Però la presa de distància aquí és la següent. 

Qualsevol equip només té un nombre finit quantitat de memòria i espai. Només es pot emmagatzemar tants arxius en el seu Mac o PC. Només es pot emmagatzemar tants programes en RAM funcionant alhora, necessàriament, fins i tot amb la memòria virtual, perquè vostè té una quantitat finita de memòria RAM. 

I només per picture-- si vostè mai ha obert un ordinador portàtil o ordenat memòria extra per a un ordinador, podria no saber que en l'interior del seu ordinador és una cosa que es veu una mica com això. Així que això és només una empresa comuna anomenada Crucial que fa RAM per a ordinadors. I la memòria RAM és on els programes viure mentre s'estan executant. 

Així que en tots els Mac o PC, quan es fa doble feu clic en un programa, i això s'obre, i s'obre una mica de document de Word o alguna cosa aixi, l'emmagatzema temporalment en RAM, memòria RAM ja que és més ràpid del seu disc dur, o el disc d'estat sòlid. Pel que és just on van els programes per viure quan s'estan executant, o quan s'utilitzen arxius. 

Pel que té coses que es veuen així per dins del seu ordinador portàtil, o coses una mica més gran dins del seu escriptori. Però la clau és que només té una nombre finit d'aquestes coses. I només hi ha una quantitat finita de maquinari assegut en aquesta taula de la dreta aquí. 

Així que, sens dubte, no podem emmagatzemar nombres infinitament llarg. I, però, si vostè pensa de nou a l'escola primària, el nombre de dígits pot vostè té la dreta d'un punt decimal? Per la resta, el nombre de dígits pot vostè té a l'esquerra de la coma decimal? En realitat, infinitament molts. 

Ara, nosaltres, els éssers humans només podria saber com es pronuncia milions, i milers de milions, bilions de dòlars, i quadrilió, i trilions. I estic empenyent els límits de la meva understanding-- o mi-- entenc números, però el meu Pronunciació dels nombres. Però es pot aconseguir amb infinitament gran un nombre infinit de dígits a l'esquerra o a la dreta de la coma decimal. 

Però els ordinadors només tenen una quantitat finita de memòria, un nombre finit de transistors, un nombre finit de bombetes de llum a l'interior. Llavors, què passa quan se li acaba l'espai? En altres paraules, si pensar de nou a la setmana passada quan parlem de nombres que elles mateixes siguin representats en binari, Suposem que tenim aquest valor de 8 bits aquí. 

I tenim gener 7 i un 0. I suposem que volem afegir 1 a aquest valor. Aquest és un nombre molt gran en aquest moment. 

Això és 254, si no recordo els càlculs de l'última setmana de la dreta. Però el que si canvi que més a la dreta 0 d'un 1? El nombre total de Per descomptat, es converteix en vuit 1 de. Així que estem sent bona. 

I que probablement representa 255, encara que depenent del context que en realitat podria representar un nombre negatiu. Però més d'això en un altre moment. Això se sent com es tracta d' tan alt com puc explicar. 

Ara, és només 8 bits. I el meu Mac, sens dubte, té forma més de 8 bits de la memòria. Però té finita. Així mateix argument s'aplica, fins i tot si tenir més d'aquests que estan a la pantalla. 

Però què passa si estàs emmagatzemar aquest número, 255, i que desitja comptar gener mica més alt? Vols anar de 255 a la tecnologia 256. El problema, per descomptat, és que si es començarà a comptar des de zero com la setmana passada, no es pot comptar tan alt com 256, 257 i molt menys, per no parlar de 258, m perquè el que succeeix quan s'agrega 1 gen? Si ho fa la vella escola de grau enfocament, es posa gener 1 aquí, i després 1 més 1 és 2, però això és Realment un zero, que porten l'1, portar a la 1, portar a la 1. Totes aquestes coses, aquests d'1, van a zero. I que acaben, sí, com algú assenyalat, un 1 a la banda esquerra. Però tot el que pugui en realitat veure i cabre en la memòria és tan sols vuit de 0, el que vol dir en algun moment si, un ordinador, intentat explicar prou alt, ets va a embolicar al voltant, segons sembla, a zero, o potser fins i tot negatiu nombres, que són fins i tot inferiors a zero. 

I podem espècie de veure això. Déjame seguir endavant i escriure un veritable programa ràpid aquí. Déjame seguir endavant i escriure un programa anomenat desbordament. Incloure CS50.h, inclogui estàndard IO.h-- oh, Realment estranyava al meu ressaltat de sintaxi. Així que anem a guardar això com overflow.c. 

I ara int void-- principal i en poc temps, anem a tornar a explicar per què seguim escrivint int void main. Però per ara, farem que, donant per fet. Anem a donar a mi mateix 1 int, i inicialitzar a 0. 

Farem a continuació per int i obtenir zero-- En realitat, farem un bucle infinit i veure què passa. Encara que és veritat, llavors anem a imprimir a terme n És per cent i, la barra invertida n, plug-n. Però, ara, farem que n es fa n + 1. 

Així, en altres paraules, en cada iteració d'aquest bucle infinit, prenguem el valor de n, i s'afegeix 1 a la mateixa, i després emmagatzemar el resultat de nou n de l'esquerra. I, de fet, hem vist la sintaxi una mica com això, breument. Un bon truc és en canvi d'escriure tot això a terme, en realitat es pot dir que una més n és igual a 1. 

O si realment vol ser de luxe, es pot dir n plus plus punt i coma. Però aquests dos últims són simplement el que nosaltres anomenem el sucre sintàctica per a la primera cosa. 

El primer és més explícit, totalment bé, tot correcte. Però això és més comú, que vaig a dir. Així que anem a fer això per un moment. 

Ara farem desbordament, que sona en lloc de mal averany, desbordament barra de punts. Anem a veure, n està fent molt gran. Però pensem, el gran que n pot aconseguir? 

n és un enter. Vam veure fa un moment amb la mida de exemple, que un int és de quatre bytes. Sabem de la setmana passada, quatre bytes és 32 bits, ja que 8 vegades 4, això és 32. Això va a ser de 4 milions de dòlars. 

I estem fins a 800.000. Això va a tenir sempre a comptar tan alt com sigui possible. Així que seguiré endavant, com pot ser que després de poc temps, i prem Control de C-- francament, Control C, molt, on el control general C mitjans cancel·len. Desafortunadament, a causa d'aquesta s'està executant en el núvol, De vegades el núvol és escopint tantes coses, tant la producció, que va a prendre una mica de temps per a la meva entrada per arribar al núvol. Així que, tot i que em va colpejar Control C Fa uns pocs segons, aquest és sens dubte el costat efecte d'un bucle infinit. 

I així, en aquests casos, estem deixarà que sigui. I anem a afegir un altre finestra de terminal per aquí amb els pols positiu, que per descomptat no ho fa d'aquesta manera, ja que encara està pensant. I seguirem endavant i estar una mica més raonable. 

Vaig a seguir endavant i fer-ho Això només un nombre finit de vegades. Utilitzarem un bucle for, el que he al·ludit abans. Anem a fer-ho. Dóna'm una altra variable int i aconsegueix 0. i és menor que, diguem, 64 i ++. I ara permetin-me imprimámoslas n és a terme per cent i, la coma n. I a continuació, això segueix sent n- va a prendre per sempre. Anem a fer-ho. 

n es fa n vegades 2. O podríem ser de luxe i fer temps és igual a 2. Però diguem que n és igual a si mateix, els temps 2. En altres paraules, en aquest nova versió del programa, No vull esperar per sempre com de 800.000 a 4 milions d'dòlars. Anem a acabar amb això. 

Anem a duplicar en realitat n cada vegada. El qual, el record, la duplicació és el oposada de tenir, és clar. I mentre que la setmana passada tenim alguna cosa nova, i de nou, i de nou, súper ràpid, duplicació segurament ho faran treure'ns d'1 a la major possible valor que podem comptar fins a amb un int. 

Així que farem exactament això. I anem a tornar a aquest després de poc temps. Però això, de nou, és igual el bloc de repetició en Scratch. I farem servir això en poc temps. 

Això només vol dir recompte de zero fins, però no igual, a 64. I en cada iteració d'aquesta llaç, mantindria incrementant i. Així i ++ - i aquesta construcció en general en la línia 7 és només una manera súper comuna de repetir algunes línies de codi, cert nombre de vegades. Quines línies de codi? Aquestes claus, com es poden haver recollit a partir d'ara, significa, feu el següent. 

És com en Scratch, quan que té els blocs grocs i altres colors que tipus de abraçar o abraçar a altres blocs. Això és el que aquests arrissat aparells ortopèdics estan fent aquí. Així que si em van donar el meu sintaxi que dreta- pot veure el símbol de pastanaga al mig C que és la quantitat de vegades que he estat tractar de resoldre aquest problema. Així que anem a desfer-nos de que un en total, i tancar aquesta finestra. I utilitzarem la nova. Fer desbordament, barra de punts desbordament, Enter, tots els drets, es veu malament al principi. Però anem a retrocedir en el temps, perquè em va fer això 64 vegades. 

I observi la primera vegada, n és 1. La segona vegada, n és 2, després 4, després 8, després 16. I sembla que quan Arribo a més o menys 1 mil milions, si faig doble de nou, que ha me 2000000000. Però resulta, que és just a la cúspide. 

I el que en realitat es desborda un enter de 1000000000 a més o menys 2 negatiu milions de dòlars, a causa d'un nombre sencer, a diferència de la que nombres van ser assumint la setmana passada, pot ser tant positiva com negativa en la realitat i en un ordinador. I així, almenys, un dels els bits són robats eficàcia. Així que realment només tenim 31 bits, o 2 mil milions de valors possibles. 

Però per ara, el menjar per emportar és bastant simplement, siguin quines siguin aquests números són i qualsevol que sigui la matemàtica és, que succeeix una cosa dolenta amb el temps, perquè amb el temps que està intentant permutar els bits massa vegades. I vas efectiva de tot de 1 a 0 potser tots de, o potser simplement algun altre patró que clarament, depenent del context, pot ser interpretat com un nombre negatiu. I pel que sembla el més alt que pot comptar en aquest programa concret és només aproximadament 1 mil milions. Però hi ha una solució parcial aquí. Tu saps que? 

Déjame canviar d'una Int a un llarg temps. I m'ho dius a mi anar per davant aquí i dir-- Vaig a tenir per canviar això a un llarg sense signe. O bé, anem a veure, mai em acord de mi. 

Seguirem endavant i crea desbordament. No, no és això, LLD, gràcies. Així que de vegades pot ser útil Clang. No recordo el que el format especificador va ser durant molt de temps. 

Però, de fet, Clang em va dir. El verd és un tipus de bé, encara vol dir que va cometre un error. Es endevinant que volia dir LLD. 

Per això vull aprofitar és un consell, una llarga nombre decimal de longitud, llevat que. I permetin-me tornar a executar-lo, dot reduir desbordament, Retorn. I ara el que és fresc és això. 

Si em desplaço cap enrere en el temps, encara vam començar comptant al mateix lloc-- 1, 2, 4, 8, 16. Avís, obtenim tota la fins a arribar a 1 mil milions. Però llavors amb seguretat arribar a 2000000000. 

Llavors vam aconseguir a 4 milions de dòlars, a continuació, 8 mil milions, 17000000000. I anem més alt, i més alt, i superior. Amb el temps, això també es trenca. 

Finalment, amb un llarg temps, que és el valor de 64 bits, no un valor de 32 bits, si es compta massa alt, que es col·loca al voltant de 0. I en aquest cas, ens ha tocat acabar amb un nombre negatiu. 

Així que aquest és un problema. I resulta que aquest problema no és tan arcà. Encara que he deliberadament induïda amb aquests errors, Resulta que ho veiem tot tipus de nosaltres, o almenys alguns de nosaltres al voltant de fer-ho. 

Així que en Lego Star Wars, si Alguna vegada has jugat el joc, Resulta que es pot donar la volta trencar les coses en el món de LEGO, i la recollida de monedes, essencialment. I si has jugat alguna vegada aquest joc massa temps, ja que aquest individu no identificat aquí ho va fer, el nombre total de monedes que es poden recollir és, segons sembla, 4 mil milions. 

Ara, amb ell és en realitat arrodonit. Així que estava tractant de LEGO mantenir les coses fàcil d'utilitzar. Ells no ho van fer exactament a 2 el 32 de potència, a la setmana passada. Però 4000000000 és una raó. Sembla, a partir d'aquesta informació, que LEGO, i l'empresa que fet aquest programari real, va decidir que el nombre màxim de monedes l'usuari pot acumular és, de fet, 4 mil milions, perquè van triar en el seu codi utilitzar no molt de temps, pel que sembla, però només un nombre sencer, sense signe nombre sencer, només un nombre enter positiu, el valor màxim més o menys és això. Bé, aquí hi ha un altre divertit. Així que en el joc de la civilització, la qual alguns de vostès podrien estar familiaritzats amb resulta que fa anys es Va ser un error en aquest joc mitjançant el qual si has jugat el paper de Gandhi en el joc, en comptes d'estar molt pacifista, en canvi, va ser molt, molt agressiu, en algunes circumstàncies. En particular, la forma en què la civilització obres és que si vostè, el jugador, adoptar la democràcia, la seva El marcador es posa l'agressivitat decrementa en dos, almenys menys, i després minus. 

Pel que resta 2 seva iteració actual. Desafortunadament, si la seva iteració és inicialment 1, 2 i restar d'ella després d'adoptar la democràcia com Gandhi aquí podria ho han fet, perquè era molt passive-- 1 en l'escala d'agressivitat. Però si s'adopta la democràcia, a continuació, que va d'1 a 1 negatiu. 

Desafortunadament, eren l'ús de nombres sense signe, el que significa que tracten fins i tot negatiu números com si fossin positius. I resulta que la equivalent positiu d'1 negatiu, en programes informàtics típics, és 255. Així que si Gandhi adopta la democràcia té, i per tant la seva puntuació es va reduir l'agressivitat, que en realitat al voltant dels rotllos a 255 i el fa més caràcter agressiu en el joc. Pel que pot buscar a Google en això. I va ser, de fet, una error de programació accidental, però això ha entrat bastant la tradició des de llavors. 

Això és tot diversió i valent. Més alarmant és quan es real dispositius del món real, i no els jocs, tenir aquests mateixos errors. De fet, fa tot just un any un article vi terme sobre el Boeing 787 Dreamliner. 

I l'article en un primer moment mirada llegeix una mica arcà. Però dit això, un programari vulnerabilitat en Boeing nou 787 Dreamliner jet té el potencial per causar pilots perdre el control de l'aeronau, possiblement en ple vol, els funcionaris de la FAA Les aerolínies advertir recentment. Era la determinació que un model 787 avió que ha estat alimentat de forma contínua durant 248 dies poden perdre totalment el corrent altern, CA, energia elèctrica a causa del generador unitats de control, GCU, alhora entrar en mode de seguretat de. És una mena de perdre. No obstant això, la nota s'assenyalava, OK, ara he de, la condició va ser causada per un programari comptador intern de el control del generador unitats que es desbordarà després 248 dies de potència contínua. Estem emetent aquest AVÍS Per evitar la pèrdua de de tots AC elèctric poder, el que podria resultar la pèrdua de control de l'avió. 

Així que, literalment, hi ha un cert nombre sencer, o un cert tipus de dades equivalent, sent utilitzat en programari en un avió real que si manté el seu avió el temps suficient, que pel que sembla pot ser el cas si només està executant ells constantment i mai desconnectar el seu avió, segons sembla, o deixant que els seus bateries s'esgotin, amb el temps es compta ascendent, i fins, i amunt, i amunt i amunt, i cap amunt. 

I, per naturalesa, una quantitat finita de memòria es desbordarà, rodant de nou a zero o un valor negatiu, un efecte secundari que és el la realitat terriblement reals que l'avió podria necessitar ser reiniciat, efectivament, o podria caure, pitjor encara, a mesura que vola. Pel que aquest tipus de problemes segueixen amb nosaltres, even-- aquest era un article de 2015, encara més alarmant quan no ho fa necessàriament entendre, apreciar, o anticipar aquest tipus d'errors. 

Per tant, resulta que hi ha un altre El dolent de representació de dades. Resulta que fins i tot flotadors són tipus de falles, a causa dels flotadors, també, Vaig proposar són de 32 bits, o potser 64 si s'utilitza un doble. Però això és finit. 

I el problema és que si es pot posar un nombre infinit de nombres després del punt decimal, no hi ha manera que pot representar tot el possible nombres que ens van ensenyar en el grau de l'escola pot existir al món. Un equip que, en essència, ha de triar un subconjunt d'aquests números per representar amb precisió. 

Ara, l'equip pot ronda potser una mica, i li pot permetre a aproximadament el magatzem qualsevol nombre que possiblement podria desitjar. Però només intuïtivament, si tenir un nombre finit de bits, només es pot permutar elles de moltes maneres finits. Pel que no pot possiblement utilitzar un nombre finit de permutació de bits, patrons de zeros i uns, per representar un infinit nombre de nombres, el que suggereix que els ordinadors podrien molt bé ser mentint a nosaltres a vegades. 

De fet, farem això. Déjame tornar al IDE CS50. Déjame anar endavant i crear un petit programa La imprecisió trucada, per mostrar que els ordinadors són, de fet, imprecisa. 

I m'ho dius a mi seguir endavant i començar amb alguns que el codi d'abans, i ara acaba de fer el següent. Déjame seguir endavant i fer printf, cent f, la barra invertida n, 1 dividit per 10. En altres paraules, anem a bussejar en la més profunda a 1/10, igual que 1 i dividit per 10. Sens dubte, un ordinador pot representar 1/10. 

Així que seguirem endavant i fer imprecisió. Anem a veure. Format especifica el tipus doble. No obstant això, l'argument té tipus int. Què està passant? 

Oh, interessant, així que és una lliçó apresa d'abans. Jo dic, bé, fira d'informàtica un flotador amb cent f. Però ho estic donant 2 punts. Així que resulta, puc arreglar això en un parell de maneres. 

Tan sols pogués convertir en un 1,0, i 10-10,0, el que, de fet, tenir l'efecte de convertir ells en floats-- encara amb sort el mateix nombre. O resulta que hi ha alguna cosa veurem de nou en poc temps. Es podria emetre els números. 

Pot, l'ús d'aquest parèntesi expressió, es pot dir, Hey, ordinador, pren això 10, que sé que és un int. Però tractar-la, si us plau, com si fos un flotador. Però això se sent innecessàriament complexa. 

Per als nostres propòsits avui, només anem a literalment els fan valors de punt flotant amb un punt decimal, com aquest. Déjame anar endavant i torneu a executar, fer imprecisió, bé, barra de punts imprecisió, introdueixi. OK, estem en bon estat. 

1 dividit per 10, d'acord al meu Mac aquí, és, de fet, 0,100000. Ara, em van ensenyar a l'escola primària allà ha de ser un nombre infinit de 0 de. Així que anem a tractar, almenys, per veure alguns d'ells. Resulta que és una mica printf encara més elegant que hem estat utilitzant. Resulta que vostè no ha d'especificar f just per cent, o simplement per cent i. En realitat es pot especificar algunes opcions de control aquí. 

En concret, vaig a dir, hey, printf, En realitat em mostren 10 punts decimals. Així que sembla una mica estrany. Però vostè diu per cent, punt, la quantitat de nombres desitja veure després de la punt decimal i, a continuació, f per plana, simplement perquè això és el que diu la documentació. Déjame anar per davant i salvament d'aquesta. 

I noto també, que estic rebent cansat de tornar a escriure les coses. Així que estic establint el i fletxa inferior de les meves claus aquí. I si segueixo colpejant cap amunt, vostè pot veure tots els ordres que vaig fer, o mal fet. 

I vaig a seguir endavant i ara en realitat no utilitzar que, pel que sembla. Fer imprecisió, punt reduir de manera imprecision-- el que em van ensenyar a l'escola primària comprova cap a fora. Fins i tot si ho imprimeixo a 10 decimals el situa, de fet, és 0,10000. Però saps què? 

Aconseguirem una mica cobdiciós. Diguem que, igual que, mostreu-me 55 punts després del punt decimal. Anem a prendre això programar a fer un volt. Permetin-me refer amb maquillatge imprecisió, ratlla vertical del punt, la imprecisió. 

I aquí anem. La seva infància va ser una mentida. Pel que sembla, 1 dividit per 10 és de fet 0.100000000000000005551115123-- 

Què està passant? Doncs bé, resulta que, si la classe de mirar prou lluny en el subjacent representació d'aquest nombre, que en realitat no és exactament 1/10, o el 0,1 i el un nombre infinit de zeros. Ara, per què? 

Doncs bé, tot i que això és un simple nombre a nosaltres els éssers humans, 1 dividit per 10, tot i així és un d'un nombre infinit nombres que podrien imaginar. No obstant això, un equip només pot representar un nombre finit de nombres menys. I així, efectivament, el que la equip està mostrant nosaltres és el seu punt més proper aproximació al nombre volem creure és 1/10, o realment 0,10000 ad infinitum. 

Més aviat, però, això és tan a prop com es pot aconseguir. I, de fet, si ens fixem sota de la campana, ja que estem aquí examinat 55 dígits després del punt decimal, que en realitat veiem que la realitat. Ara com un a part, si no tens Alguna vegada has vist la movie-- la majoria de vostès probablement haven't-- però fa alguns anys Superman 3, Richard Pryor apalancat fonamentalment aquest la realitat en la seva companyia per robar una gran quantitat de fraccions i fraccions de centaus, perquè el company-- pel que recordo, que ha estat un Rato-- era essencialment llençar qualsevol cosa que no encaixava en la noció de centaus. 

Però si se sumen tots aquests diminuts, diminuts, diminuts números de nou, i una altra, i una altra, es pot, com en és el cas, fer una bona quantitat de diners. 

Aquesta mateixa idea va ser arrencada per una més recent, però encara ara majors pel·lícula, anomenat espai d'oficina, on els nois d'aquesta pel·lícula, va fer el mateix, ficat la pota per complet, acabat amb massa diners en el seu compte bancari. Tot era molt sospitós. Però al final del dia, imprecisió és tot el que ens envolta. 

I que, també, pot haver És alarmant el cas. Resulta que Superman 3 i espai d'oficina a una banda, hi ha poden ser algunes molt real ramificacions mundials de les realitats de la imprecisa representació de dades que fins i tot els éssers humans a el dia d'avui no necessàriament entendre, així com hauríem, o recordar tan sovint com hauríem. I, de fet, el següent clip és a partir d'una mirada a un món molt real ramificacions del que passa si no aprecien que la imprecisió pot succeir en representació de nombres. 

[REPRODUCCIÓ DE VÍDEO] 

-Informàtica, Tots hem arribat a acceptar els problemes sovint frustrants que anar amb ells-- insectes, virus, i falles en el programari, per als preus de petit a pagar per la comoditat. Però en l'alta tecnologia i d'alta velocitat aplicacions de programes espacials militars i, el més petit problema pot magnificar en el desastre. 

El 4 de juny de 1996, els científics van preparar per llançar un coet no tripulat Ariane 5. portava científica satèl·lits dissenyats establir amb precisió com el interactua camp magnètic de la Terra amb vents solars. El coet va ser construït per l'Agència Espacial Europea, i desenganxar de les seves instal·lacions a la costa de la Guaiana francesa. 

-En Uns 37 segons en el vol, primer adonat que alguna cosa anava malament. Els filtres es gira sobre un eix en de manera que en realitat no hauria. Al voltant de 40 segons de vol, clarament, el vehicle estava en problemes. 

I això és quan van fer una decisió de destruir-lo. L'oficial de seguretat de gamma, amb tremendes ganyes, prem el botó, explotar el coet, abans que pogués convertir-se en un perill per a la seguretat pública. 

-Aquesta Era la donzella viatge de l'Ariane 5. I la seva destrucció es va dur lloc a causa d'un defecte incrustat en el programari del coet. -El Problema va ser en l'Ariane que hi havia un nombre que requereix 64 bits per a expressar. I volien convertir a un nombre de 16 bits. Se suposa que la nombre mai es va a ser molt gran, que la majoria de les dígits en un nombre de 64 bits eren zeros. Estaven equivocats. 

-La Incapacitat d'una programa de programari per acceptar el tipus de nombre generat per una altra va ser la causa de la falla. El desenvolupament de programari s'havia convertit en una part molt costosa de les noves tecnologies. El coet Ariane han estat molt èxit, pel que gran part del programari creat per a ella també era utilitzat en el Ariane 5. 

-El Problema bàsic era que l'Ariane 5 va ser més ràpida, es va accelerar més ràpidament. I el programari no tenia van representar per a això. 

-La Destrucció del coet Va ser un gran desastre financer, tot es deu a un error de programari minut. Però aquesta no va ser la primera problemes de conversió de dades de temps havia plagat la tecnologia de coets moderna. 

-En 1991, amb l'inici de la primera Guerra del Golf, el míssil de patriota experimentat una classe similar del problema de la conversió nombre. I com a resultat, 28 persones, 28 soldats nord-americans, van ser assassinats, i sobre altres 100 ferits, quan el patriota, que se suposava per protegir contra Scuds entrants, deixat de disparar un míssil. 

-Quan L'Iraq va envair Kuwait, i Amèrica Tempesta del Desert llançat a principis de 1991, bateries de míssils Patriot van ser desplegats per protegir Aràbia Saudita i Israel dels atacs de míssils Scud iraquians. El Patriot és un mitjà de rang dels EUA superfície per a sistema d'aire, fabricat per l'empresa Raytheon. 

-El Mida dels interceptors Patriot si està a més o menys 20 peus de llarg. I pesa al voltant de 2.000 lliures. I porta una ogiva de l'entorn, Crec que és més o menys 150 lliures. I el cap de combat en si és un explosiu d'alta potència, que té fragments voltant d'ella. La carcassa del cap de combat és dissenyat per actuar com perdigons. 

-Els Míssils es duen quatre per contenidor, i són transportats per un semiremolc. 

-El Sistema Patriot antimíssils es remunta almenys 20 anys. Va ser dissenyat originalment com un míssil de defensa aèria per enderrocar avions enemics. A la primera guerra del Golf, quan la guerra va arribar, l'Exèrcit volia utilitzar-lo per enderrocar Scuds, no aeroplans. 

La Força Aèria Iraquiana va ser no tant d'un problema. Però l'exèrcit estava preocupat per Scuds. I pel que van tractar de actualitzar el Patriot. 

-Intercepting Un enemic míssil que viatja a Mach 5 que anava a ser un repte suficient. Però quan el Patriot va ser traslladat d'urgència en servei, l'Exèrcit no estava al tant d'una modificació iraquià que va fer seus Scuds gairebé impossible de colpejar. 

-El Que passa és que els Scuds arribaven eren inestables. Van ser desplaçament. La raó d'això era els iraquians, per tal per arribar a 600 quilòmetres fora d'un 300 quilòmetres abast dels míssils, va prendre el pes fora de l'ogiva davant. Van fer l'ogiva més lleuger. 

Així que ara el Patriot és tractant d'arribar a la Scud. I la majoria de les vegades, la immensa majoria de les vegades, seria simplement sortir volant pel Scud. Una vegada que els operadors del sistema Patriot es va adonar de la Patriot no va aconseguir el seu objectiu, detonar l'ogiva de l'Patriota per evitar possibles baixes si es va deixar caure a terra. 

Això va ser el que van veure la majoria de la gent, aquestes grans boles de foc al cel, i malinterpretat com intercepcions de ogives Scud. 

-Encara Que A la nit cels, patriotes aparèixer ser amb èxit la destrucció de míssils Scud, en Dhahran, no podia haver error sobre el seu rendiment. Allà, sistema de radar de la Patriot perdut la pista d'un Scud entrant, i mai posat en marxa a causa a un defecte de programari. Van ser els israelians que es va descobrir per primera vegada que com més temps el sistema estava en marxa, com més gran és la discrepància de temps es va convertir, a causa d'un rellotge incorporat a l'ordinador del sistema. 

-Sobre De dues setmanes abans la tragèdia en Dhahran, els israelians van informar de el Departament de Defensa que el sistema estava perdent el temps. Després de prop de vuit hores o en execució, es van adonar que el sistema de va ser que es vegi amb menys precisa. El Departament de Defensa va respondre dient a totes les bateries Patriot per no deixar els sistemes durant molt de temps. Mai van dir el molt temps era-- vuit hores, 10 hores, 1.000 hores. Ningú sabia. 

-La Bateria Patriot estacionats a les casernes en Dhahran i la seva deficient interna rellotge havia estat en més de 100 hores en la nit del 25 de febrer. 

-És Seguit de temps amb una precisió del voltant d'un dècim d'un segon. Ara, un dècim d'un segon és un nombre interessant, a causa que no es pot expressar en binari exactament, que vol dir que no es pot expressar exactament en qualsevol ordinador digital moderna. És difícil de creure. 

Però utilitzar això com un exemple. Prenguem el nombre d'un terç. Una tercera no pot ser expressat en decimal exactament. Una tercera part és 0,333 passant per l'infinit. 

No hi ha manera de fer això amb la precisió absoluta en decimal. Aquest és exactament el tipus de problema Això va passar al Patriot. Com més llarg sigui el sistema va funcionar, la es va convertir en el pitjor error de temps. 

-Després De 100 hores de funcionament, el d'error en el temps era només al voltant d'un terç d'un segon. Però en termes de focalització 1 míssil que viatja a Mach 5, que va donar lloc a un seguiment d'error de més de 600 metres. Seria un error greu per als soldats en el es va passar una llanxa era Scud detectat pels satèl·lits d'alerta primerenca i sabien que era l'Scud venint en la seva direcció general. Ells no sabien d'on venia. 

-Va Ser Fins ara el radar component del sistema Patriot la defensa de Dhahran per localitzar i mantenir pista de l'míssil enemic entrant. 

-El Radar era molt intel·ligent. Seria realment un seguiment la posició del Scud, i després predir on probablement seria la propera vegada que el radar va enviar Un pols a terme. Que es va cridar una porta de distància. 

-Llavors, Una vegada que el Patriot decideix el temps suficient té va passar a tornar enrere i comprovar la següent ubicació per a aquest objecte detectat, que es remunta. Així que quan es va tornar al mal lloc, a continuació, no veu cap objecte. I decideix que no hi havia objecte, que era una falsa detecció, i deixa caure la pista. 

-La Entrant Scud va desaparèixer des de la pantalla de radar. I segons més tard, va xocar contra la caserna. El Scud va matar a 28, i va ser l'últim 1 disparades durant la primera Guerra del Golf. 

Tràgicament, el programari actualitzat arribat a Dhahran el dia següent. La falla de programari tenia estat fixat, el tancament un capítol en el problemàtic la història del míssil Patriot. 

[REPRODUCCIÓ DE VÍDEO] DAVID J. Malan: Així que això és tot el que dir que aquests problemes de desbordament i imprecisió són massa reals. Llavors, com hem arribat fins aquí? Vam començar amb només parlar d'printf. Un cop més, aquesta funció que imprimeix alguna cosa a la pantalla, i es va introduir a partir de llavors algunes altres funcions de l'anomenada biblioteca d'CS50. I seguirem veure aquests en el moment oportú. I nosaltres, en particular, utilitzem cadena GET, i obtenir int, i ara també obtenir flotador, i no obstant això, altres encara ens trobem amb i l'ús de nosaltres mateixos abans d'hora. 

No obstant això, en ocasions, tenen ja vist una necessitat per emmagatzemar el que aquestes funcions mà cap enrere? Ens tornar una seqüència de la mà, o int o un flotador. I de vegades hem de posar això cadena, o int o float, en algun lloc. 

I per emmagatzemar aquestes coses, recuperar únicament igual que en Scratch, tenim variables. Però a diferència de les ratllades, en C tenim tipus reals de les dades variables-- tipus, més generally-- entre ells, una cadena, un sencer, una surar, i aquests altres encara. 

I així, quan declarem les variables en C, haurem de declarar els tipus de dades. Això no és una cosa que anem a haver de fer més endavant en el semestre a mesura que passem a altres idiomes. Però per ara, ens cal a priori per avançat, explicar a la computadora quin tipus de de la variable que volem que ens donen. 

Ara, mentrestant, per imprimir aquests tipus de tipus de dades, hem de dir-li a printf què esperar. I vam veure cent s per cordes, i el percentatge d'i per sencers, i alguns altres ja. I aquests són només els requisits per a la presentació visual d'aquesta informació. 

I cada un d'aquests pot ser realitat parametritzada o ajustat d'alguna manera, si vol avançar en el control el tipus de sortida que s'obté. I, de fet, resulta que no només ¿Hi ha barra invertida n per a una nova línia. Hi ha una altra cosa anomenada barra invertida r per a un retorn de carro, el qual s'assembla més a una màquina d'escriure vella escola, i també de Windows utilitza per a molts anys. 

Hi ha t barra invertida per les pestanyes. Resulta, que si es vol cometes dobles dins d'una cadena, Recordem que hem utilitzat cometes dobles cotització de l'esquerra i la dreta acaba de les nostres cordes fins al moment. Això sembla confondre les coses. 

Si vostè vol posar una doble cita a el medi d'un string-- i, de fet, és confús per veure. I el que ha de fugir, de manera que parlar, una doble cita amb alguna cosa de la mateixa manera que, literalment, la barra invertida cometes dobles. I hi ha alguns altres encara. I veurem més d'aquests en l'ús real en poc temps. 

Així que ara transició de de dades, i la representació, i operadors aritmètics, tot del que ens va donar algun edifici blocs amb les quals jugar. Però ara anem a donar realitat nosaltres la resta del vocabulari que ja teníem la setmana passada amb les ratllades per fer una ullada a algun altre construccions en C-- no tots ells. Però les idees que estan punt de veure realment només posar l'accent en la traducció de una llengua, Scratch, a un altre, C. 

I amb el temps, anem a recollir més eines per a la nostra caixa d'eines, per així dir-ho, sintàcticament. I, de fet, es veurà que les idees ara són bastant familiar de la setmana passada. Així que anem a fer això. 

Seguirem endavant i preparar ràpidament un programa que realment utilitza algunes expressions, una expressió booleana. Déjame anar per davant aquí i crear un nou arxiu. Vaig a trucar a aquest condition.c. 

Déjame anar endavant i incloure la biblioteca CS50. I em va deixar anar endavant i incloc io.h estàndard per a les nostres funcions, i printf, i molt més, respectivament. Permetin-me que em lliuro repetitiu de int buit principal, l'explicació anem a tornar en el futur. 

Ara vaig a seguir endavant i donar a mi mateix a través d'un int int get. Llavors m'ho dius a mi seguir endavant i fer això. Vull dir, si i és less-- de deixar distingir entre positiu i negatiu, o valors zero. 

Així que si i és menor que zero, em va deixar Només té aquest programa simplement dir, negatiu, barra invertida n, del que Si i és més gran que zero. Ara estic, per descomptat, dirà printf positiu, la barra invertida n. I després una altra cosa si: Jo podria fer això. 

Jo podria fer si i és igual a 0. Però estaria fent en menys un error ja. Recordem que el signe igual és no és igual, ja que els éssers humans ho saben. 

Però és l'operador d'assignació. I nosaltres no volem tenir 0 al la dreta i la va posar en i de l'esquerra. Així que per evitar aquesta confusió, o potser el mal ús del signe igual, els éssers humans van decidir fa alguns anys que en molts llenguatges de programació quan es vol comprovar la igualtat entre l'esquerra i la dreta, en realitat s'utilitza és igual als iguals. De manera que pegar-li el signe igual dues vegades. Quan es vol assignar de dreta a l'esquerra, s'utilitza un sol signe igual. Pel que podíem fer una altra cosa això- Si i és igual a igual a zero. 

Llavors podria anar i obrir les meves claus, i dir, printf 0, la barra invertida n, fet. Però recorda com aquests bifurcacions en el camí poden treballar. I, en realitat, només pensar en la lògica. I és un nombre. És un nombre enter, específicament. I això vol dir que va a ser menys de 0, o més gran que 0, o 0. Així que hi ha una espècie d'aquest cas per defecte implícit. 

I així podríem, igual Zero, prescindir de la persona si, i dir una altra cosa. Lògicament, si el programador sap que només hi tres cubs en què una escenari pot fall-- la primera, la segona, o la tercera en aquest cas-- no fer molestar l'addició de la precisió addicional i la lògica addicional allà. Només seguir endavant amb el cas per defecte aquí d'una altra cosa. 

Ara, seguirem endavant després de salvar això, fer condicions esquitxen reduir conditions-- no una gran interfície d'usuari, perquè no em va portar a la usuari, com he esmentat anteriorment. Però això està bé. Anem a mantenir simple. Intentarem el nombre 42. I això és positiu. Intentarem el nombre 42 negatiu, negatiu. 

Anem a provar el valor 0. I, de fet, funciona. Ara, veurà amb problemes abans de llarg, el que es prova tres vegades, probablement no és suficient. És possible que vulgueu provar alguns nombres més grans, alguns més petits nombres, alguns casos de cantonada, com anem a venir per descriure'ls. 

Però, per ara, es tracta d'una programa bastant simple. I estic bastant segur que, lògicament, que es divideix en tres casos. I, de fet, tot i que només centrat en els aspectes negatius potencials d'imprecisió i de desbordament, en realitat en què molts dels problemes del CS50, nosaltres no ens anem a preocupar sobre, tot el temps, les qüestions de desbordament i imprecisió, perquè, de fet, en C, no és en realitat tot el que fàcil d'evitar aquestes coses. Si desitja comptar fins més gran i més gran, i més gran, Resulta que hi ha tècniques que es pot utilitzar, sovint amb coses trucades biblioteques, col·leccions de codi, que les altres persones van escriure que pot utilitzar, i altres llenguatges com Java i altres, en realitat fer que sigui molt més fàcil a comptar fins i tot més alt. Pel que realment és que alguns d'aquests perills en funció de l'idioma que utilitzi. I en les properes setmanes, anem a veure el perillós C realment pot ser si no s'utilitza correctament. Però a partir d'aquí, i amb Python i JavaScript, es ens capa en algunes proteccions addicionals, i córrer menys d'aquests riscos. 

Així que farem una mica més lògica interessant en el nostre programa. Així que permetin-me seguir endavant i crear un programa anomenat Logical perquè jo pugui jugar amb alguns la lògica real, logical.c. Vaig a copiar i enganxar alguns codi d'abans, així que torni a aquest bonic punt de partida. 

Concedeix-me temps fer C. carbó estic va a donar-li un nom de C només perquè és convencional, obtenir un personatge de l'usuari. I anem a suposar com Estic posant en pràctica part d'aquest programa Rm, el remove programa abans que se li demani a l'usuari per eliminar un arxiu. Com podem fer això? 

Vull dir, si C és igual iguals, entre cometes, i, a continuació, vaig a assumir que l'usuari ha triat si. Jo només vaig a imprimir si. Si veritablement estigués escrivint el programa d'eliminació, podríem treure l'arxiu amb més línies de codi. Però anem a mantenir les coses simples. 

Perquè si c és igual a igual n- i ara aquí, que vaig a dir, l'usuari ha d'haver volgut dir que no. I després una altra cosa, saps què? No sé què més l'usuari va a escriure. Així que només vaig a dir que que és un error, el ell o ella realment escrit. 

Llavors, què està passant aquí? Hi ha una diferència fonamental enfront del que he fet en el passat. Les cometes dobles, cometes dobles, doble cites, i, però, cometes simples, cometes simples. Resulta que en C, que quan voleu escriure una cadena, vostè fa ús de cometes dobles, així com nosaltres hem estat utilitzant tot aquest temps amb printf. 

Però si vostè vol tractar amb només una caràcter individual, una crida char, a continuació, que realment utilitza cometes simples. Aquells de vostès que han programat abans, pot ser que no tingui havia de preocupar per això distinció en determinats idiomes. En C, sí que importa. I així, quan arribi a un char i vull comparar aquest carbó utilitzant iguals és igual a alguna carta com a S o N, faig, de fet, necessita tenir les cometes simples. 

Ara, seguirem endavant i fer això. Seguirem endavant i fer realitza dot lògiques slash lògic. I ara estic que se li demani. Per tant, és de suposar, una millor experiència d'usuari seria en realitat em digui què fer aquí. Però vaig a cegament dir i per a si, bé, bé. 

Anem a córrer de nou, n per no, agradable. Suposem que igual que certes persones que conec, meus bloqueig de majúscules clau està en massa freqüència. Així que faig I majúscula, enter, error. OK, no és exactament el que estic esperant. De fet, l'ordinador està fent literalment el Li vaig dir a fer-- comprovar si hi ha minúscules i i n minúscula. Això no se sent com a bona experiència dels usuaris, però. Déjame demanar i acceptar ja sigui minúscules o majúscules. Així que resulta, és possible que vulgueu dir alguna cosa com a Scratch, com literal o C és igual és igual únic de capitals i citat. Resulta que C no té aquesta paraula clau literal o. 

Però té dues barres verticals. Vostè ha de mantenir Shift general, si està utilitzant un teclat dels EUA, i prem la barra vertical clau per sobre de la tecla de retorn. Però aquesta barra vertical o barra vertical indica. 

Si, per contra, volíem dir i, igual que en Scratch, podríem fer signe de signe. Això no té sentit lògic aquí, perquè un ésser humà no podria han escrit tant i com minúscules i i el capital I com el mateix caràcter. Així que, o és el que ens proposem aquí. 

Així que si faig això en els dos llocs, o c és igual a és igual a N majúscula, ara torni a executar, donar lògica, torneu a executar lògica. Ara, puc escriure i. I puc fer-ho de nou amb I majúscula, o N majúscula I podria afegir a addicional combinacions fixes. 

Així que aquesta és una lògica programa de la mesura en que ara Estic comprovant lògicament per aquest valor o aquest valor. I jo no tinc que, necessàriament, arribar a dues IFS IFS més o en cas contrari. De fet, em puc combinar algunes de les relacionats amb la lògica junts d'aquesta manera. Així que això seria millor dissenyada que simplement a dir, si C és igual a minúscula i, imprimir sí, més si c és igual a I majúscula, imprimir sí, més si c és igual lower-- en altres paraules, vostè no ha de tenir més i més branques. Es poden combinar alguns dels equivalents branques lògicament, com en aquest camí. 

Així que anem a fer una ullada a un sol ingredient final, un últim constructe, que permet C. I anem a tornar al futur a altres encara. I després anem a la conclusió examinat pel que no la correcció de code-- Com obtenir el codi de treball-- però el disseny de codi, i plantar les llavors des del principi. 

Així que permetin-me seguir endavant i obrir un nou arxiu aquí. Tu saps que? Vaig a tornar a posar en pràctica aquest mateix programa, però utilitzant una construcció diferent. 

Així que em va deixar ràpidament lliurar-me accés per incloure CS50.h per a la biblioteca de CS50, Io.h estàndard per printf. Dóna'm la meva void main int. I després per aquí, i molt Em seguir endavant i fer això. 

Char c aconsegueix obtenir char, de la mateixa manera que abans. I vaig a utilitzar una nova construcció ara-- canviar, en què caràcter? Així interruptor és una mena El pas d'un tren pistes. O, en realitat, és una espècie de Si una persona, si una altra persona si, però escrit de manera una mica diferent. 

Un interruptor s'assembla a això. Vostè té interruptor, i després ho caràcter o nombre que voleu veure, a continuació, algunes claus com a Zero, només dir fer aquestes coses. I llavors vostè ha diferents casos. 

No s'utilitza si, i altres. Literalment s'utilitza el cas de textos. I es podria dir alguna cosa com això. 

Així en el cas d'una minúscula i, o en el cas d'una capital I, seguir endavant i imprimir si. I després sortir de l'interruptor. Això és. Hem acabat. 

Perquè si, per així dir-ho, n minúscula o majúscula N, a continuació, seguir endavant i d'impressió fora no, i després trencar. Else-- i aquest tipus és el de cas per defecte indeed-- printf error-- i només per si de cas, tot i que lògicament aquesta ruptura no cal perquè estem al final l'interruptor de totes maneres, Ara estic trencant l'exterior del switch. Pel que aquest es veu una mica diferent. 

Però, lògicament, és en realitat equivalent. I ¿per què fer servir un sobre l'altre? De vegades, només preferència personal, de vegades l'estètica, si Trobo una ullada a aquest Ara, hi ha alguna cosa a dir sobre la llegibilitat d'aquest codi. És a dir, no importa el fet que aquest codi és nou per a molts de nosaltres a l'habitació. 

Però només una mica és bastant. Veus minúscules i, majúscula, n minúscula, per defecte N majúscula, que només tipus de salts a la vista d'una manera que, sens dubte, potser l'exemple anterior a les FI, i les barres verticals, i les FI altres, no podrien tenir. Així que això és realment una qüestió de personal elecció, de veritat, o la llegibilitat, del codi. 

Però en termes de funcionalitat, em va deixar seguir endavant i fer un interruptor, barra de punts interruptor, i ara escrigui en i minúscules, I majúscula, minúscula n, N majúscula, David, perquè això és tornar a intentar ni un sol símbol. Anem a fer x, l'error, com s'esperava. I, logically-- i això és una cosa Jo animaria en general-- fins i tot encara que només ens estem rascant la superfície d'algunes d'aquestes característiques. 

I pot ser que no sigui evident quan es vostè se senti baix en el teclat, Com funciona això? El que faria això? El bonic d'haver un ordinador portàtil o de sobretaula, o l'accés a un ordinador amb un compilador, i amb un editor de codi com aquest, està gairebé sempre es pot respondre a aquestes preguntes per vostè acaba de tractar. 

Per exemple, si la retòrica pregunta en qüestió eren, ¿Què passa si s'oblida seus estats de descans? Que és realment una molt comú que cal fer, ja que no es veu com si realment els necessita. En realitat, no completen la seva pensat com un parèntesi o un arrissat cotilla ho fa. Seguirem endavant i tornar a compilar el codi i veure. Així que l'interruptor, interruptor de barra de punts. Anem escrigui en minúscules i, la caixa superior, Enter. Pel que he escrit i. 

El programa va dir que sí, no, error, com si canviava d'opinió. Però és com que era, perquè el que succeeix amb un interruptor és el primer cas que es partit essencialment vol dir, eh equip, executar tot el codi sota d'ella. I si vostè no diu trenqui, o no digui trenqui, o no diuen descans, l'equip va a bufar a través de totes les línies i executar tots ells fins s'arriba a aquest suport arrissat. Així que els frens són, de fet, cal. Però aquí és un menjar per emportar, quan En cas de dubte, provar alguna cosa. Potser a guardar el programa en primer lloc, o guardar-lo en un arxiu extra si està realment preocupat per fer malbé i haver de recuperar el treball que se sap que funciona. 

Però provar coses. I no tingui por que, potser, del que l'equip pot fer, o que podria trencar alguna cosa. Sempre es pot tornar en certa versió anterior. 

Així que anem a acabar mirant en el disseny de codi. Tenim aquesta facultat ara per escriure condicions i bucles d'escriptura, i variables, i les funcions de trucada. Així que, francament, estem de tornada a la classe de on érem fa una setmana amb Scratch, encara que amb un text menys convincent medi ambient que permet ratllades. 

Però Tingueu en compte la rapidesa amb què hem adquirit que el vocabulari, encara que sigui Va a prendre una mica de temps per assimilar, de manera que ara podem fer servir aquest vocabulari per escriure programes més interessants. I anem a fer un pas de nadó cap que, com segueix. Déjame anar endavant i crear un nou arxiu aquí. 

Vaig a trucar a aquest prototype.c, i introduir per primera vegada, la capacitat per fer les seves pròpies funcions. Alguns de vostès podrien tenir fet això amb Scratch, pel qual vostè pot crear el seu blocs personalitzats propis en zero, i després arrossegar-los en el seu lloc allà on vulgui en C. I en la majoria de programació idiomes, es pot fer exactament que- fer les seves pròpies funcions, si no existeixen ja. 

Així, per exemple, em va deixar anar per davant i incloure CS50.h, i inclouen io.h estàndard, nul·la principal int. I ara tenim una marcador de posició de llest per a funcionar. Guardo coses d'impressió com noms de les persones avui dia. I això se sent com- No seria bo si hi ha eren una funció anomenada en lletra d'impremta? Jo no he de fer servir printf. No he de recordar tots els codis de format. Per què no jo, o per què no ho va fer algú abans que jo, crear una funció anomenada print nom, que donat un nom, simplement ho imprimeix? 

En altres paraules, si dic, hey, ordinador, dóna'm una cadena preguntant a l'usuari per a tal, a través de la funció get cadena de CS50. Hey, ordinador, ja que en la cadena de la variable a la banda esquerra, i en diuen s. I llavors, hey equip, vagi per davant i imprimir que el nom de la persona, fet. 

Ara, seria bo, perquè aquest programa, ben anomenat, em diu el que ha de fer per mitjà dels noms dels de funció. Deixa que vagi a fer prototip, ENTER. I, desafortunadament, això no va a volar. 

Prototype.c, línia 7, caràcter 5, l'error, la declaració implícita Nom de la funció d'impressió és invàlid en C99, C99 és a dir, una versió de C que va sortir el 1999. Això és tot. 

Així que no sé què tot això significa encara. Però sí que reconeix error en vermell. Això és bastant obvi. 

I sembla que amb el caràcter verd aquí, el problema és amb lletra d'impremta, obert parin s, prop parin, punt i coma. Però la declaració implícita d' funció que vam veure breument abans. Això vol dir, simplement, que Clang no sé el que vull dir. 

He utilitzat una paraula del vocabulari que és Mai vist o ha estat ensenyat abans. I així que he de ensenyar el que significa aquesta funció. Així que vaig a seguir endavant i fer això. 

Vaig a seguir endavant i posar en pràctica la meva pròpia funció anomenada Imprimir Nom. I vaig a dir, de la següent manera, que ho fa, printf, hola, cent s, la barra invertida n, nom, punt i coma. Llavors, què acabo de fer? 

Així que resulta, a implementar la seva pròpia funció, quin tipus de prestat alguns la mateixa estructura que principal que simplement hem estat es dóna per fet, i jo saber si el copies i pegant bastant més del que He estat escrivint en el passat. Notar el patró aquí. Int, principal, Buit, anem a esmicolar en poc temps el que això significa en realitat. 

Però per ara, només notar el paral·lelisme. Buit, en lletra d'impremta, nom de la cadena, de manera que cal una paraula clau porpra, que començarem trucar a un tipus de retorn, el nom de la funció, i llavors l'entrada. Així que, en realitat, podem destil·lar aquest tipus de com la setmana passada com, aquest és el nom o la algoritme del codi que estem anar a la write-- algoritme subjacent el codi que anem a escriure. 

Aquesta és la seva entrada. Aquest és la seva sortida. Aquesta funció, el nom d'impressió, és dissenyat per tenir una cadena anomenada nom, o el que sigui, com a entrada, i després buit. No retorna res, com arribar cadena o aconseguir int fa. Pel que em va a lliurar alguna cosa a canvi. Només va a tenir una efecte secundari, per dir-ho així, d'imprimir el nom d'una persona. Així avís, línia 7, I pot trucar en lletra d'impremta. La línia 10, puc definir o posar en pràctica en lletra d'impremta. Però, per desgràcia, això no és suficient. 

Déjame anar endavant i recompilar aquest després de desar. Vaja, ara, ho he fet pitjor encara, semblaria. Així declaració implícita de Nom de la funció d'impressió no és vàlid. I, de nou, no hi ha més errors. Però com jo vaig advertir abans, fins i tot si es deixin confondre amb, o una mica trist veure a tants errors, se centren només en la primera inicialment, a causa que només podria han tingut un efecte en cascada. Així C, o Clang més específicament, Encara no reconeix el nom d'impressió. 

I això és perquè Clang, per disseny, és una mica ximple. Només fa el que li indica que fer. I només ho fa en l'ordre en el qual es digui que faci. 

Així que he definit en la principal línia de quatre, com ho hem fet bastant sovint. He definit en lletra d'impremta en la línia 10. Però estic tractant d'usar Nom d'impressió en línia de set. 

És massa aviat, no existeix encara. Així que podria ser intel·ligent, i ser com, OK, així que anem a tocar en conjunt, i moure el nom d'impressió cap amunt aquí, i tornar a compilar. Oh Déu meu. Ha funcionat. Era tan simple com això. 

Però la lògica és exactament això. Cal ensenyar-li a el que Clang és mitjançant la definició de la funció de primera. A continuació, pot utilitzar-lo. Però, francament, això se sent com un pendent relliscosa. 

Així que cada vegada que funciono en un problema, només sóc va a seleccionar i copiar la Vaig escriure, tallar i enganxar aquí. I, sens dubte, podríem inventar alguns escenaris on una funció podria que hagi de trucar a un altre. I que no es pot posar a cada funció sobre de qualsevol altre. 

Per tant, resulta que hi una solució millor. Podem deixar que això sigui. I, francament, és generalment agradable, i convenient, i el bon disseny posar principal en primer lloc, perquè, de nou, principal de la mateixa manera que quan es fa clic a bandera verda, que és la funció que és executat per defecte. Pel que també podria posar a la part superior de l'arxiu de manera que quan vostè o qualsevol un altre ésser humà es veu a l'arxiu vostè sap el que està passant amb només llegir principal en primer lloc. Així que resulta, podem dir Clang proactiva, hey, Clang, en línia de quatre, Prometo posar en pràctica una funció anomenada Imprimir Nom que pren un nom de cadena anomenat com a entrada i retorna res, el buit. I vaig a moure a a terme més endavant. 

Aquí ve principal. Ara principal en la línia 9 es pot utilitzar Imprimir Nom perquè Clang està confiant que, amb el temps, es trobarà amb la definició de l'aplicació d'impressió Nom. Així que després de guardar el meu arxiu, i molt Em seguir endavant i fer el prototip, es veu bé en aquesta ocasió. Dot slash, prototip, em va deixar seguir endavant i escriure un nom. David, hola David, Zamila, hola Zamila, i, de fet, ara es treballa. 

Així que l'ingredient aquí és que hem fet una funció personalitzada, com un costum bloc de zero ens estem cridant. Però a diferència de les ratllades on es pot acaba de crear i començar a usar-lo, Ara hem de ser una poc més pedant, i en realitat entrenar Clang usar, o per esperar-lo. Ara, com un a part, per què tot aquest temps ha hem estat a cegues en la fe incloent CS50.h, i incloent estàndard io.h? 

Doncs bé, resulta que, entre algunes altres coses, tot el que està en els punts h arxius, que passen a ser els arxius. Hi ha els arxius de capçalera, per dir-ho. Encara estan escrits en C. No obstant això, que són un tipus diferent d'arxiu. 

Per ara, es pot gairebé assumir que tot el que està dins de CS50.h és alguns d'una sola línia d'aquest tipus, no per a les funcions d'impressió anomenats Nom, però per obtenir una cadena de, Get Flotador, i alguns altres. I hi ha prototips similars, traçadors de línies un, dins de l'estàndard io.h per printf, que ara està en la meva pròpia funció d'impressió Nom. Així, en altres paraules, tot aquest temps que hem acaba de ser cegament copiar i enganxar incloure això, inclogui que, què està passant? Aquests són només tipus de pistes al so metàl·lic com a quines funcions són, de fet, implementat, just en diferents arxius en una altra part en un altre lloc en el sistema. 

Així que hem implementat en lletra d'impremta. Es té aquest efecte secundari de imprimir alguna cosa a la pantalla. Però no és així en realitat dóna'm una mica de volta. Com fem per la implementació d'un programa que jo no lliurar alguna cosa a canvi? 

Bé, anem a provar això. Déjame anar per davant i posar en pràctica un arxiu anomenat return.c pel que podem demostrar com alguna cosa Obtenir com cordes, o obtenir Int, és en realitat tornar alguna cosa nova a l'usuari. Seguirem endavant i definir int void main. 

I, de nou, en el futur, anem a explicar el que int i aquest buit és en realitat fent. Però per ara, anem a donar per fet. Vaig a seguir endavant i printf, per a una bona experiència d'usuari, x és. I llavors vaig a esperar que el usuari-me x int amb get. 

I després vaig a seguir endavant i imprimir x al quadrat. Així que quan vostè té només una teclat, la gent comunament utilitzar la petita pastanaga símbol en el teclat per representar la potència de, o l'exponent de. El que x al quadrat és present i. 

I ara vaig a fer això. Tan sols pogués fer-- el que és x al quadrat? x quadrat és x vegades x. 

I ho vam fer alguna Fa temps que ja avui dia. Això no se sent com tot el que molt progrés. Tu saps que? Anem a palanquegen una mica d'aquesta idea des de l'última vegada de l'abstracció. 

¿No seria bo si hi ha una funció anomenada quadrat que fa exactament això? Encara, al final de la dia, fa el mateix matemàtiques. Però anem abstracta lluny la idea de prendre un nombre multiplicat per una altra, i només li donen un nom, com la quadratura d'aquest valor. 

I, en altres paraules, en C, crearem una funció anomenat quadrat que fa exactament això. Serà anomenat quadrat. Es va a prendre un int. I anem a voluntat simplement cridar-n, per defecte. 

Però podria dir que és el que vulguem. I tot el que es va a fer, literalment, és el retorn el resultat de n vegades n. Però com que és tornar alguna cosa, la qual cosa és la paraula clau en la porpra que hem mai havia vist abans, jo, en la línia 11, No es pot dir sense efecte aquest moment. 

Buit, en l'exemple que acabem de veure en lloc del nom d'impressió, només significa, fer quelcom. Però no em lliurar alguna cosa a canvi. En aquest cas, jo vull per tornar n vegades n, o sigui el que sigui, aquest nombre. 

Així que no puc dir, hey, ordinador, Torno res, nul·la. Es va a tornar, per naturalesa, un int. I això és tot el que està passant aquí. 

L'entrada de la quadratura serà un int. I perquè puguem usar-lo, ha de tenir un nom, N. Es va a la sortida 1 int que no necessita un nom. Podem deixem a principal, o qui usarme per recordar aquest valor si voler amb la seva pròpia variable. 

I, de nou, l'únic nou paraula clau aquí és Retorn. I només estic fent una mica de matemàtica. Si jo realment volia ser innecessària, Podria dir producte int n vegades es posa n. 

I llavors jo podria dir, el producte de tornada. Però, de nou, al meu punt anterior de això simplement no és bona design-- de la mateixa manera que, per què introduir un nom, un símbol, com a producte, només per tornar immediatament? És una mica més net, una mica més fort, per la per parlar, només per dir retorn n vegades n, desfer-se d'aquesta línia completament. 

I és només menys codi per llegir, menys possibilitats d'errors. I veurem si aquest En realitat ara treballa. Ara, vaig a anar endavant i fer de retorn. 

Uh-oh, declaració implícita de la funció. Vaig fer aquest error abans, no és gran cosa. Em van deixar de natura, així com ressaltar i copiar, exactament el mateix prototip de funció, o la signatura, de la funció aquí. O podria moure tota la funció. 

Però això és una mica mandrós. Així que no farem això. Ara, vull deixar de retorn de nou, punt de retorn barra. 

x és quadrat 2. x és 4. x és quadrat 3. x és 9. I la funció sembla Ara que està funcionant. Llavors, quin és la diferència aquí? Tinc una funció que es diu quadrat, en aquest cas, que presento una entrada. I jo torni una sortida. I, no obstant això, amb anterioritat, si Obro l'altre exemple d'abans, que va ser cridat prototype.c, Tenia en lletra d'impremta, que retornat buit, per així dir-ho, O es va tornar res, i simplement tenia un efecte secundari. 

Llavors, què està passant aquí? Bé, consideri la funció obtenir la seqüència per un moment. Hem estat utilitzant la funció obtenir cadena de la següent manera. 

Hem tingut una funció get cadena, com són CS50.h, Inclouen estàndard io.h, int, principal, nul·la. I a continuació, cada vegada que he anomenada cadena GET fins al moment, He dit alguna cosa així com: cadena s aconsegueix obtenir la seqüència, ja que vam aconseguir el string-- anem a trucar a aquesta cadena get get.c-- si retorna una cadena que pot llavors utilitzar, i dir hola, coma, s per cent, la barra invertida n, s. 

Així que aquest és el mateix exemple, Realment, que teníem abans. Així que arribar cadena retorna un valor. Però fa un moment, la cadena d'impressió no retorna un valor. Simplement té un efecte secundari. Així que aquesta és una diferència fonamental. Hem vist diferents tipus de funcions que ara, alguns dels quals han tornat valors, alguns dels quals no ho fan. Així que potser és la seqüència, o int o float. O potser és només buit. 

I la diferència és que aquestes funcions que obtenir dades i retornar un valor són en realitat portar alguna cosa nova a la taula, per dir-ho així. Així que seguirem endavant i mirar a un conjunt final d'exemples que dóna un sentit, ara, de la forma en què podria, de fet, abstracta millor, i millor, i millor, o més, i més, i més, per tal per escriure, en última instància, un millor codi. Seguirem endavant, i en l'esperit d'Scratch, feu el següent. 

Déjame anar endavant i incloc CS50.h i l'estàndard io.h. Deixin-me seguir endavant i donar jo una int, principal, nul·la. I m'ho dius a mi anar per davant, dic a això cough.c. 

I em va deixar anar endavant i només com esgarrapades, imprimiu la tos / n. I vull fer això tres vegades. Així que estic, per descomptat, només va copiar i enganxar tres vegades. Ara vaig a fer tos tos barra de punts. Anem a donar a mi mateix una mica més d'espai Aquí es poden introduir, tos, tos, tos. 

Hi ha, òbviament, ia una oportunitat de millora. He copiat i enganxat un parell de vegades avui. Però això només va ser així que no ho vaig fer ha d'escriure tants caràcters. Encara canviat el aquestes línies de codi són. 

Aquestes tres línies són idèntics, que se sent mandrós i, de fet, és a dir, i probablement no és l'enfocament correcte. Així, amb el que l'ingredient podríem millorar aquest codi? No hem de copiar i enganxar el codi. 

I, de fet, cada vegada que se senti a si mateix de copiar i enganxar, i ni tan sols el canvi de codi, probabilitats són que hi ha una millor manera. I, de fet, no ho és. Déjame seguir endavant i fer un bucle, tot i que la sintaxi no podria venir naturalment encara. 

Feu això tres vegades, simplement fent el following-- i m'he assabentat d'això des de la pràctica. Però tenim un nombre d'exemples ara. I veurà en línia més referències fixes. 

Aquesta és la sintaxi de la línia 6, que de la mateixa manera que les ratllades que es repeteix bloc, repetiu els següents tres vegades. És una mica màgica per ara. Però això va a aconseguir més, i més familiar. 

I es va a repetir línia de vuit tres vegades, pel que si puc tornar a compilar la tos maquillatge, slash dot tos, tos, tos, tos. Encara funciona de la mateixa manera. Així que això és tot fi i bo. Però això no és molt abstracta. 

És perfectament correcte. Però sembla que hi ha podria ser una oportunitat, com en el món de Zero, al tipus d'inici afegir alguns termes aquí perquè Jo no només tinc una mica de bucle, i una funció que diu tos, o que tossir. Tu saps que? Vaig a tractar de ser una mica més fresc que això, i en realitat escriure una funció que té alguns efectes secundaris, en diuen la tos. 

I es necessita cap entrada, i retorna cap valor com a sortida. Però vostè sap el que fa? Ho fa això- printf, entre cometes, tossir. 

I ara aquí, vaig per seguir endavant i per int, i resulta en zero, i menys de 3, i més plus. Vaig a fer no printf, que és podria dir-se que una implementació de baix nivell detall. No m'importa com tossir. Només vull utilitzar la funció de la tos. I jo només vaig a trucar a la tos. 

Ara, observi la dicotomia. Quan es crida a una funció, si no ho fa que desitgi donar-li entrades, totalment bé. Només fer parèntesi d'obertura, tancament parin, i ja està. 

Quan es defineix una funció, o declarar el prototip d'una funció, si se sap per endavant que no és va a prendre cap argument, dir nul·la en aquells parèntesi allà. I això fa que la certesa que es no per casualitat es mal ús. Déjame seguir endavant i fer la tos. I, per descomptat, he comès un error. 

Maleïda sigui, cal declaració implícita. Però això està bé. És una solució fàcil. Només necessito el prototip més amunt en el meu arxiu del que estic d'utilitzar-lo. 

Així que ara vull deixar ments de nou, agradable. Ara, funciona. Fer la tos, tos, tos, tos. Així es podria pensar que estem molt poc més de l'enginyeria d'aquest problema. I, de fet, som. Aquest no és un bon candidat d'un programa de en el moment de refactorització, i fer el que és anomenat descomposició jeràrquica, on es pren una mica de codi, i després quin tipus de coses fora de factors, per tal adscriure més semàntica a ells, i reutilitzar-la en última instància, a més llarg termini. Però és un bloc de construcció cap programes més sofisticats que començarem escrit poc temps que ens permet disposar de vocabulari amb el qual escriure millor codi. I, de fet, veurem si ens No es pot generalitzar més a fons. 

Sembla una mica coix que jo, principal, hagi de preocupar per aquest maleït bucle, i cridar a la tos i una altra. Per què no puc simplement dir-li a la tos, Si us plau, tossir tres vegades? En altres paraules, per què no puc simplement donar entrada a tossir i fer això? 

Per què no puc simplement dir, en tos principal tres vegades. I ara, això és una mena de màgic. És molt iteratiu aquí. I és, de fet, un petit pas. 

Però només la capacitat de dir en línia de vuit, tossir tres vegades, és només molt més fàcil de llegir. I, a més, no he de saber ni li importa com s'implementa la tos. I, de fet, més tard en el termini i per a projectes fi de carrera, Si vostè aborda un projecte amb un company de classe o dos companys de classe, s'adonarà que vas a que, o desitja, dividir el treball. 

I vas a voler decidir per endavant, ¿qui va a fer què, i en el qual peces? I no seria agradable si, per exemple, fer-se càrrec de l'escriptura principal, fet. I el seu company de cambra, o el seu soci més en general, s'encarrega de l'aplicació de la tos. 

I aquesta divisió, aquestes parets de l'abstracció, o capes d'abstracció si va, són súper poderós, perquè especialment per a més gran, més programes i sistemes complexos, que permet a diverses persones per construir coses junts, i en última instància puntada seu treball junts d'aquesta manera. Però, és clar, necessitarà establir ara la tos. Hem de dir-li a la tos que, hey, saps què? Vas a haver de prendre una input-- pel que no buida, sinó int i ara. Seguirem endavant i posar en ments de l'int. i resulta en zero. 

i és menor que el nombre de vegades. He dit tres abans. Però això no és el que vull. Em volen tusso a generalitzar-se a suportar qualsevol nombre d'iteracions. 

Així que, de fet, és n que vull, qualsevol que sigui l'usuari em diu. Ara, puc seguir endavant i dir la tos d'impressió. I tant i fa nombre l'usuari passa a, Vaig a repetir moltes vegades. 

Així que al final del dia, programa és idèntic. Però compte totes aquestes coses fins i tot podria ser en un altre arxiu. De fet, no sé al printf moment com s'implementa. 

No sé en aquest moment com arribar cadena, o aconseguir int o float arribar s'implementen. I jo no vull veure'ls en la meva pantalla. Tal com és, estic començant a centrar-se en meu programa, no aquestes funcions. 

I així, de fet, tan aviat com es iniciar la factorització codi com això, podríem fins i tot moure la tos en un arxiu separat? Una altra persona podria posar-lo en pràctica. I vostè i el seu programa es converteix en el molt bonic, i molt fàcil de llegir, podria dir-se que, en realitat quatre programa de línia d'allà mateix. 

Així que seguirem endavant ara i fer un canvi més. Notar que el meu prototip ha de canviar sobre de la tapa. Així que permetin-me arreglar això pel Jo no cridar a. 

Fer la tos, la tos em deixa córrer una vegada A més, segueix fent el mateix. Però ara, explica que tenim una ingredient per a una versió final. Tu saps que? Jo no vull simplement tossir, necessàriament. Vull tenir una mica més general. Així que ja saben què? Vull fer això. Vull tenir, igual que les ratllades fa, un bloc d'exemple, però no només dir alguna cosa cert nombre de vegades. Ho vull dir una cadena molt específica. I, per tant, no ho crec volem que s'acaba de dir la tos. Vull que digui el cadena es passa a. 

Així notar, he generalitzi això perquè ara diguem sent com un bon nom per això, com Scratch, presa dos arguments, a diferència de les ratllades. Una d'elles és una cadena. Un d'ells és un int. 

I podria canviar ells. Jo només una cosa així com la idea de dir la cadena primer, i després quantes vegades posteriors. Void vol dir que encara no torna res. Aquests són només part visual efectes, com amb [? Jordan ,?] un efecte secundari verbal de cridar. Encara fa una mica n vegades, 0 fins, però no és igual a n. Això vol dir vegades n totals. I després simplement imprimir el que és de cadena. Així que en realitat he generalitzi aquesta línia de codi. Així que ara, Com implement la funció de tos? 

Puc fer la tos buit. I encara puc prendre en la forma Moltes vegades es desitja que faci ombra. Però saps què? Ara puc dir en musclera. 

Puc dir amb cridar a la paraula tos, passant n. I si vull aplicar també, només per diversió, una funció esternut, Puc esternudar cert nombre de vegades. I puc seguir reutilitzant n, perquè notar que m en aquest context o abast només existeix dins d'aquesta funció. 

I n en aquest context només existeix dins d'aquesta funció aquí. Així que anem a tornar a aquestes qüestions d'abast. I aquí, només vaig a dir, Achoo, i després n vegades, punt i coma. 

I ara, només cal demanar prestat aquestes funcions Firmes aquí. Així que la tos és correcta. esternut buit és correcta ara. 

I encara només necessito dir. Així que vaig a dir, per exemple cadena s, int n, punt i coma. Així que he més de l'enginyeria del diables d'aquest programa. 

I això no ho fa necessàriament que es tracta d' el que ha de fer l'escriure fins i tot el més simple dels programes. Prendre una cosa que és òbviament molt simple, molt curt, i tornar a posar-lo en pràctica usant manera massa codi. Però en veritat no veus, i en temps de mirar cap enrere en aquests exemples, i s'adonen, oh, aquests són els passos ens va portar a generalitzar en realitat, al factor alguna cosa fora, fins que al final de la dia el meu codi és en realitat bastant raonable. Perquè si vull tossir 3 esternuden vegades i després tres vegades, Simplement vaig a tornar a executar això, programa de fer la tos, la tos i córrer. I tinc tres tos i 3 esternuda. 

I pel que aquest és un bàsic paradigma, si es vol, de com podem anar sobre En realitat la implementació d'un programa. Però anem a veure ara el que és hem estat fent tot aquest temps, i el que algunes de les peces finals estan darrere d'aquest simple comandament. Al final del dia, tenim estat utilitzant Clang com el nostre compilador. Hem estat escrivint font codi, convertint-la a través d'Clang en codi màquina. 

I nosaltres hem estat utilitzant simplement Fer per facilitar les nostres pulsacions de tecles de manera que no hem de recordar els encanteris de si mateix Clang. Però el que és realment fer fent? I, al seu torn, el que és Clang realment fer? 

Resulta, però, hem simplificat la discussió d'avui, dient: es pren el codi font, s'envia com entrada a un compilador, que li dóna de sortida de la màquina codi, resulta que hi ha a uns passos diferents a l'interior hi ha. I compilació passa a ser el paraigua termini per a un munt de passos. Però anem a burlen això molt ràpid. 

Resulta que hem estat fent més coses cada vegada que executi un programa, o cada vegada que compili un programa d'avui. Així preprocessament es refereix a esto-- res en un programa C, com veurem una vegada i una altra, que s'inicia amb aquest símbol de hash, o el símbol hashtag aquí, vol dir es tracta d'una directiva de preprocessador. Això vol dir que, en aquest cas, ei ordinador, fer alguna cosa amb aquesta imatge abans que realment compilar el meu propi codi. 

En aquest cas, el hash inclou és a dir, en essència, forma de dir de C, Hey ordinador, anar a buscar el contingut de CS50.h i enganxar aquí. Hey ordinador, anar a buscar la el contingut de la norma io.h, allà on estigui a la disc dur, pega aquí. Així que aquestes coses passen primer a l'execució prèvia. 

I Clang fa tot això per a nosaltres. I ho fa tan rematadament ràpid, que ni tan sols veure quatre coses diferents que succeeixen. Però aquesta és la primera d'aquestes mesures. 

El que en realitat succeeix després? Així, la propera oficial pas és la compilació. I resulta que compilació d'un programa tècnicament significa que va des codi font, les coses que he estat escrivint avui en dia, a alguna cosa anomenat codi assemblador, alguna cosa que es veu una mica diferent. 

I, de fet, podem veure això molt ràpid. Déjame anar en realitat en el meu IDE. Déjame anar endavant i hola.c obert, la qual cosa és el primer programa amb el qual ens començar avui. I em va deixar anar endavant i corro 1 Clang mica diferent, Clang-s, hola.c, que en realitat es va a dóna'm un altre arxiu hello.s. 

I probablement mai es tornar a veure aquest tipus de codi. Si es pren un nivell més baix classe de sistemes com CS61, veurà molt més d'aquest tipus de codi. Però aquest és el llenguatge assemblador. Aquest és el llenguatge assemblador X86 que la CPU subjacent CS50 IDE entén realment. 

I críptic com ho fa mira, és una cosa l'equip entén bastant bé. Sub q, aquesta és una de resta. Hi ha moviments. 

Hi ha trucant a les funcions aquí, x oring, un moviment, un complement, sense oposició, un retorn. Així que hi ha alguns molt instruccions de baix nivell que entenen que les CPU He al·ludit anteriorment. Això és el que Intel Inside. 

Hi ha patrons de zeros i uns que assignar a aquests redactada arcanamente, però una cosa així-anomenat, instruccions, per dir-ho així. Això és el que passa quan compilar el codi. Vostè aconsegueix el muntatge llengua fora d'ell, la qual cosa significa el tercer pas és acoblar que el codi de muntatge en, en última instància, zeros màquina code-- i uns, no les text que acabem de veure fa un moment. 

Per tant pretractament no que troben i reemplaçar, i algunes altres coses. Compilació pren la seva font codi de C, el codi font que escrivim, per al muntatge codi que acabem va observar el. Muntatge deté acoblament codi per zeros i uns que la CPU realment es comprendre al final del dia. I la vinculació és l'últim pas això succeeix per nosaltres-- de nou, tan ràpid que ni tan sols notice-- que diu: eh equip, prendre totes els zeros i uns que el resultat de la compilació de codi de David, i la seva funció principal en aquest cas. 

I escolta ordinador, anar a buscar tots els zeros i uns que el personal CS50 escriure dins de la biblioteca CS50. Barrejar els de David de. I escolta ordinador, anar a buscar tots els zeros i els que una altra persona va escriure anys Fa de printf. I afegir aquells en el cosa sencera, pel que hem tinc els meus zeros i uns, la zeros i uns del personal CS50, printf els zeros i uns, i qualsevol cosa que estigui utilitzant. 

Tots ells aconsegueixen combinar-se entre si en una sola programa anomenat, en aquest cas, hola. Així que d'ara en endavant, ens limitarem utilitzar la paraula compilació. I donarem per fet que quan diem, compilar el programa, és a dir, Hey fer el pre-processament, muntatge, i la vinculació. Però en realitat hi ha algunes coses sucoses passant allà sota de la campana. I sobretot si sentir curiositat algun temps, es pot començar a jugar al voltant d'aquest nivell inferior. Però per ara, adonar-se que entre els robatoris de pilota per avui són, senzillament, la inici d'un procés, de sentir-se còmode amb una mena hola món. De fet, la major part del que vam fer avui després, no s'enfonsarà en super ràpida. I que prendrà algun temps, i una mica de pràctica. I les probabilitats són, que va a classificar de voler colpejar el teclat o cridar a la pantalla. I tot això està bé. Encara que, potser tracti de no fer-ho a la biblioteca tant. 

I en última instància, se li ser capaços, però, per començar veure patrons, tant en bon codi que has escrit i en errors que vostè ha fet. I de la mateixa manera que el procés de convertint en un TF o una CA és com, vostè començarà a millorar i millor al veure aquests patrons, i acaba de resoldre la seva propis problemes en última instància. Mentrestant, hi haurà un munt de nosaltres per donar-li suport, i aconseguir que a través d'aquest. I en els escriptura-ups per a tots els problemes serà guiat a través de tots els comandaments que per cert, conec de molta pràctica per ara, però podria haver volat sobre del cap per ara. I això és totalment bé. 

Però, en última instància, vas per començar a veure patrons emergeixen. I un cop que passes tota la estúpids detalls, com parèntesis, i claus, i punts i comes, i les coses, francament, que no és en absolut intel·lectualment interessant. I no és l'objectiu de prendre qualsevol classe d'introducció. És les idees que es van a importar. 

És els bucles, i el condicions i les funcions, i amb més força l'abstracció, i la factorització de codi, i el bon disseny i la bona estil, i en última instància la correcció del seu codi, que és en última instància, importarà més. Així que la setmana que ve, anem a prendre aquestes idees que vam veure per primer cop a Scratch i ara s'han traduït a C. I anem a començar per introduir la primera de les dominis del món real del curs. 

Ens centrarem en el món de la seguretat, i més específicament la criptografia, l'art de la codificació de la informació. I entre els primers vostès el problema vostè mateix s'arriba a escriure més enllà jugant amb alguns de la sintaxi i la solució d'alguns lògica problemes, en última instància, en poc temps, és en realitat per convertir o xifrar, i, finalment, desxifrar la informació. I tot el que hem fet avui en dia, ho farà bastant baixa nivell, és només va a permetre que prenguem un, i un, i un pas més cap amunt escriure el codi més interessant encara. 

Per tant més que la setmana que ve. 

[REPRODUCCIÓ DE VÍDEO] 

-Què Pot dir-me de l'última vegada que ho vas veure? -Què Pot dir que, en realitat? Vull dir, era com qualsevol altre assaig de preproducció, excepte que no hi havia alguna cosa que va dir al final que em va quedar gravada. 

-Aquest Va ser CS50. 

-És Un tall de tot el món, gran treball en l'assaig. 

El dinar de -això? 

Sí, vostè i jo podem prendre un entrepà en una estona. Em van deixar amb debrief David molt ràpidament. David? David? 

[FI DE REPRODUCCIÓ] 