[MUSIK AFSPILLER] DAVID J. MALAN: Okay, det er CS50. Og dette er uge én. Så minde om, at sidste gang i uge nul, vi fokuseret på beregningsmæssige tænkning. Og vi gået fra at for at Scratch, en grafisk programmering sprog fra vores venner på MIT Media Lab. 

Og med Scratch, vi udforske ideer som funktioner og betingelser, og loops, og variable, og selv begivenheder og tråde, og meget mere. Og i dag, vi vil fortsætte med at bruge disse idéer, og virkelig tager dem for givet, men oversætte dem til et andet sprog kendt som C. Nu C er en mere traditionel sprog. Det er et lavere niveau sprog, hvis du vil. 

Det er rent tekstmæssige. Og så ved første øjekast, er det alle kommer til at se temmelig kryptisk hvis du aldrig har programmeret før. Vi kommer til at have semikolon og parenteser, og krøllede parenteser, og meget mere. Men indse, at selv selvom syntaksen er om at se lidt uvant til de fleste af jer, se forbi det. Og prøv at se ideerne der er, ja, velkendte, fordi her i uge ét hvad Vi vil begynde at gøre, er at sammenligne, i første omgang, Scratch versus C. 

Så for eksempel huske, at når vi gennemførte den første af vores programmer sidste gang, havde vi en blok, der kiggede lidt noget lignende denne-- når grønne flag klikkede, og derefter havde vi en eller flere puslespilsbrikker under det, i dette tilfælde, siger, hej verden. Så, ja, i Scratch, når jeg klikker det grønne flag at køre mit program, så at tale, disse er de blokke, der bliver udført, eller køre. Og specifikt Scratch sagde goddag, verden. 

Nu, jeg kunne have specificeret forskellige ord her. Men vi vil se, at, ja, mange af disse blocks-- og faktisk, i C mange functions-- kan være parametriseret eller tilpasset at gøre forskellige ting. Faktisk i C, hvis vi vil konvertere, nu, dette Scratch program til dette andet sprog, vi kommer til at skrive en lidt noget som dette. 

Indrømmet, der er nogle ukendte syntaks der mest sandsynligt, int, og parenteser og ugyldig. Men printf-- selvom du ville tror, ​​det ville bare være print. Men print betyder print formateret, da vi snart vil se. Denne bogstaveligt talt vil udskrive til skærmen uanset er inde i disse parenteser, som selvfølgelig i dette tilfælde er, hej verden. 

Men du vil opdage nogle andre syntaks, nogle dobbelte anførselstegn, at parenteserne i slutningen, semikolon og lignende. Så der er lidt af overhead, så at sige, både kognitivt og syntaktisk, at vi vil at skulle huske inden længe. Men indse, at med praksis, dette vil begynde at hoppe ud på dig. 

Faktisk lad os fokusere på at en funktion specifically-- i dette tilfælde, sige goddag verden. Så siger er den funktion. Hello world er dens parameter, eller argument, dens tilpasning. 

Og ækvivalensen i C er bare vil være denne ene linje her, hvor printf svarer til, siger, den dobbelte citeret streng, hej verden er ækvivalent, selvfølgelig, til hvad der er i den hvide boks der. Og omvendt skråstreg n, men lidt mærkeligt og fraværende fra Scratch, blot vil have den virkning, vi får se i en computer, som min Mac eller en pc, for blot at bevæge markøren til den næste linje. Det er ligesom at ramme Enter på tastaturet. 

Så vi vil se det igen inden længe. Men først, lad os tage et kig på denne andet eksempel i tilfældet af løkker. Vi havde denne evigt loop sidste gang, som var en serie af puslespilsbrikker der gjorde noget bogstaveligt forever-- i denne sag, siger, hello verden, hello verden, hej verden, hej verden. Så det er en uendelig løkke ved design. 

I C, hvis vi ønsker at gennemføre denne samme idé, kan vi simpelthen gøre dette. Mens sandt, printf hej verden-nu mens, bare semantisk, sådan fremmaner tanken om at gøre noget igen og igen og igen, og hvor længe? Nå, true-- minde om, at sand er lige på eller én. 

Og sandt er naturligvis altid sandt. Så det er lidt af en meningsløs erklæring bare at sige sandt. Men ja, det er bevidst, fordi hvis sand er bare altid sandt, end mens sand bare antyder, hvis lidt indirekte at følgende linjer kode i mellem disse krøllede parenteser skulle bare udføre igen og igen, og igen, og faktisk aldrig stoppe. 

Men hvis du vil have din løkke til at stoppe, som vi gjorde sidste gang med noget lignende dette, gentag følgende 50 gange, i C kan vi gøre det samme med, hvad der er kaldes en for loop-- nøgleordet ikke at blive, mens, men for. Og så har vi nogle nye syntaks her, med int i er lig med 0, i mindre end 50, Jeg ++. Og vi vil vende tilbage til. Men det er simpelthen, hvordan vi ville oversætte sæt Skrab blokke til et sæt af C linjer kode. 

I mellemtiden overveje variabler. Og i virkeligheden, vi bare så en et øjeblik siden. Og i tilfælde af Scratch, hvis vi ønskede at erklære en variabel kaldet i for jeg bliver heltal, bare et nummer, og vi ønsker at indstille den til en vis værdi, vi ville bruge denne appelsin blokere her-- sat i til 0. 

Og vi vil se i dag, og ud over, ligesom i sidste uge, programmører gøre næsten altid begynde at tælle fra nul, virkelig efter sædvane. Men også fordi tilbagekaldelse fra vores diskussion af binære, det mindste tal, du kan repræsenterer med et vilkårligt antal bits er bare at være 0 selv. Og så vil vi generelt starter initialisering selv vores variabler til 0. 

Og i C at gøre det samme, vi kommer til at sige int for heltal, jeg bare efter sædvane. Jeg kunne have kaldt denne variabel hvad jeg vil, ligesom i Scratch. Og så lig 0 kun tildeler værdien 0 fra højre og sætter det ind i variablen, eller opbevaringsbeholder der, til venstre. Og semikolon som vi vil see-- og Vi har set et par af disse already-- betyder bare slutningen af ​​tanke. Fortsæt at gøre noget andet på de linjer, der følger. 

Nu, hvad booleske udtryk? Husk på, at i Scratch, disse var udtryk der er enten sand eller false-- spørgsmål, virkelig, at enten er sande eller falske. Så i tilfælde af Scratch, måske vi stille et simpelt spørgsmål som dette, er jeg mindre end 50? Så jeg, igen, er et helt tal. Måske vi bruger det i et Scratch program at holde styr på en score eller sådan noget. Så denne syntaks her i Scratch betyder bare, er jeg mindre end 50? Nå, heldigvis, noget er enkel i C. Og at oversætte, dette ville vi blot sige jeg mindre end 50, under anvendelse af velkendte nøgle på tastaturet. 

I mellemtiden, hvis du ville sige noget mere generelt, lignende, godt, er x mindre end y, hvor hver af x og y er selv variabler? Vi kan gøre det samme i C, så længe vi har skabt disse variabler allerede. Og vi vil se, hvordan du gøre det inden længe. Vi vil blot sige x mindre end y. 

Så du begynder at se nogle ligheder. Og de folk, der har foretaget Scratch var bestemt inspireret af nogle af disse grundlæggende ideer. Og du vil se denne form for syntaks i mange languages-- ikke bare Scratch, ikke bare C, men Python, og JavaScript, og andre sprog stadig. 

Lad os overveje en anden konstruktion fra C, begrebet en tilstand, gør noget betinget. Hvis noget er sandt, at gøre dette. Hvis noget andet er sandt, gør det. Det er en slags programmering svarende til en gaffel i vejen. Måske er det en to-vejs gaffel, en tre-vejs gaffel, eller mere. Og i Scratch, kunne vi have set noget som dette. 

Så denne ene er en stor en. Men overveje den relative enkelhed af logik. Hvis x er mindre end y, så siger x er mindre end y, ellers hvis x er større end y, så sige x er større end y. Og så, logisk, hvis du tænker tilbage på Scratch eller bare din egen menneskelige intuition, godt, hvis x ikke er større end y, og x ikke er mindre end y, så selvfølgelig x vil være lig med y. Så i dette tilfælde, ved indlejring disse Skrab blokke, kan vi opnå en tre måde gaffel i vejen? 

I mellemtiden, hvis vi ønsker at gøre det i C, det velsagtens ser lidt simpler-- mindst når du får fortrolig med syntaks. Hvis x er mindre end y, printf x er mindre end y. Ellers hvis x er større end y, printf x er større end y. Else printf x er lig med y-- og, igen, med dem, backslash slutter lige for de nye linjer, så hvis du faktisk løb denne form for program Det ville bare flytte markøren i sidste ende til den næste linje af skærmen. 

Nu, i mellemtiden Scratch havde andre mere avancerede funktioner, kun hvoraf vi vil oprindeligt flytte over til en verden af ​​C. Og en af ​​dem var kaldes en liste i bunden. Og dette var en særlig type variabel, der tilladt dig at gemme flere ting i det tilbage, til tilbage, til tilbage, til at bakke. 

I C, har det ikke lister, per se, men noget der er mere generelt kaldet arrays, selvom vi komme tilbage senere dette semester at se på noget kaldes en liste, eller virkelig en linket liste. Men for nu, det tætteste tilsvarende i C for os kommer til at være noget kaldes et array. Og et array er simpelthen en særlig type variabel der giver dig mulighed for at lagre data tilbage, til tilbage, til tilbage, mod ryg. 

Og, ja, i Scratch, hvis vi ønskede at få adgang til det første element i en matrix eller en list-- og jeg har tænkt mig at kalde det, konventionelt, argv, argument vektor, men mere om det inden længe. Hvis jeg ønsker at få på det første element af argv i verden af ​​Scratch du rent faktisk gør typisk begynde at tælle fra 1. 

Og så jeg kan få punkt 1 i argv. Det er bare hvordan MIT implementeret begrebet lister. Men i C, vil jeg mere simpelthen bare sige, argv, som igen er navnet på min list-- eller for at være klar, et array. Og hvis jeg vil have den første elementer, jeg har tænkt mig at bruge kantede parenteser, som du måske ikke ofte anvendes under et tastatur. 

Men 0 betyder bare, få mig den første. Så på lejlighed og som tiden går, vi vil at begynde at se disse dikotomier mellem Scratch og C, hvorved Scratch bruger et. Vi i C bruger 0 her. Men du vil hurtigt se når du forstår grundlaget for hvert sprog, at disse ting begynder at få alle de mere bekendt gennem praksis og praksis. 

Så lad os faktisk ser nu på et program. Her er den første af vores C kildekoden til komplette programmer. Og det program, vi skal hen at tilbyde til overvejelse er den, der er ækvivalent til dette tidligere Scratch stykke. 

Så her har vi, hvad der er nok den enkleste C-programmet du kan skrive, at faktisk gør noget. Nu vil vi kigge forbi, for nu, er omfatte, standard io.h, og disse vinkel beslag, og int, og ugyldig, og de krøllede parenteser og lignende. 

Og lad os bare fokusere på hvad det mindste intuitivt, kan springe ud på dig allerede. Faktisk vigtigste, det gør jeg ikke nødvendigvis ved, hvad det er, men meget gerne Scratch havde at når grønt flag klikket puslespilsbrik, så gør C som et programmeringssprog har en vigtigste stykke kode, bliver udført som standard. Og faktisk det er bogstaveligt talt kommer til at blive kaldt vigtigste. 

Så vigtigste er en funktion. Og det er en speciel funktion, der eksisterer i C, at når du kører et program, Det er vigtigste, der bliver drevet af misligholdelse. I en verden af ​​Scratch, det var normalt når grønt flag klikkede der fik kørt som standard. 

I mellemtiden har vi set det før, printf eller udskrive formateret, det er kommer til at være en funktion, der kommer med C, sammen med en hel masse andre, denne vilje fra tid og tid igen, for at gøre præcis som navnet antyder, udskrive noget. Hvad ønsker vi at udskrive? Nå, vil vi se, at ved omsluttende tegn ligesom these-- hej verden, omvendt skråstreg n i anførselstegn, vi kan fortælle printf præcis hvad der skal udskrives på skærmen. 

Men for at gøre at vi desværre nødt til at tage noget, der er allerede kryptisk for os mennesker, men i det mindste er det noget readable-- skarp indbefatter standard io.h, int, vigtigste, ugyldig, printf, alle de magiske besværgelser vi lige har set på skærmen. Men vi faktisk nødt til at gå mere mystiske stadig. Vi først nødt til at oversætte koden at vi skriver til maskinkode. Og husker fra sidste uge, at maskiner, mindst dem vi kender her, ved udgangen af ​​dag kun forstå nuller og ettaller. 

Og min Gud, hvis vi skulle skrive disse nuller og ettaller til faktisk program, det ville meget, meget hurtigt tage det sjove ud af noget. Men det viser sig, per sidste uge, at disse mønstre af nuller og ettaller bare har en særlig betydning. I visse sammenhænge, de kan betyde numre. 

I nogle sammenhænge kan de betyde bogstaver, eller farver, eller en række af andre abstraktioner der på. Men ligesom din computer har en CPU, Central Processing Unit, eller hjernen inde i din computer. Det er normalt Intel indeni, fordi det er en af ​​de største virksomheder der gør CPU'er til computere. 

Nå, Intel CPU'er og andre simpelthen har besluttet på forhånd at visse mønstre af nuller og dem forstås specifikke ting. Visse mønstre af nuller og ettaller vil betyde, udskrive denne til skærmen, eller tilføje disse to tal, eller subtrahere disse to tal, eller flytte dette stykke data fra min computers hukommelse herovre, eller en række andre meget lavt niveau, men i sidste ende nyttige operationer. Men heldigvis vi mennesker vil ikke til brug for at vide dette niveau af detaljer. Faktisk ligesom sidste gang, hvor vi indvindes igen og igen og igen, bygning fra meget lavt niveau primitiver som nuller og ettaller til begreber højere niveau lignende tal og bogstaver, og farver, og mere, så kan vi som programmører stå på skuldrene af andre, der er kommet før os og bruge software, som andre folk har skrevet før os-- nemlig programmer kaldet compilere. 

C er et sprog, sædvanligvis kompileret, hvilket betyder konverteret fra kildekoden til maskinkode. , Hvad det betyder især er, at hvis du har fået din kilde kode, som du selv skriver, som vi snart vil i bare et øjeblik på skærmen, og du ønsker at konvertere den sidste ende til maskinen code-- disse nuller og ettaller, der kun din Mac eller din PC understands-- du har fået en første foder denne kildekode i så input til en særlig program kaldet en compiler, hvis udgang vi skal se, er maskinkode. Og, ja, sidste gang vi talte om, virkelig, ved slutningen af ​​dagen, problemløsning. Du har indgange. Og du har udgange. Og du har fået en slags af algoritmen i midten. 

Algoritmer kan helt sikkert være implementeret i software, som vi så med pseudokode sidste uge og som vi vil se med konkrete kode denne uge. Og så en compiler egentlig bare har et sæt algoritmer inde af det, der ved, hvordan man konvertere de særlige søgeord, ligesom vigtigste, og printf, og andre, at vi bare så ind i mønstre af nuller og dem, Intel Inside og andre CPU'er faktisk forstår. Så hvordan gør vi det? Hvor får vi en compiler? 

De fleste af os her har en Mac eller en pc. Og du kører Mac OS, eller Windows eller Linux, eller Solaris, eller en række andre operativsystemer. Og, ja, vi kunne gå ud på nettet og hente en compiler til din Mac eller din PC til netop dit operativsystem. Men vi vil alle være på forskellige sider, så at sige. Vi ville have lidt forskellige konfigurationer. Og tingene ville ikke arbejde alle de samme. Og, ja, i disse dage mange af os ikke bruger software, der kører kun på vores bærbare pc'er. I stedet skal vi bruge noget som en browser, der tillader os at få adgang webbaserede applikationer i skyen. Og senere dette semester, vi vil gøre præcis det. Vi vil skrive applikationer eller software ved hjælp code-- ikke C, men andre sprog som Python og JavaScript--, der kører i skyen. 

Og for at gøre det, vi selv i løbet af semestret rent faktisk vil bruge en cloud-baseret miljø kendt som CS50 IDE. Dette er en webbaseret programmering miljø, eller integreret udvikling miljø, IDE, der er bygget oven på nogle open source software kaldet Cloud 9. Og vi har gjort nogle pædagogiske forenklinger det således at skjule visse funktioner i de første uger, som vi ikke har brug for, hvorefter du kan afsløre dem og gøre de fleste noget, du vil med miljøet. 

Og det giver os også, at præ-installere bestemt software. Ting som en såkaldt CS50 bibliotek, som vi snart vil se giver os i C med nogle yderligere funktionalitet. Så hvis du går til, i sidste ende, CS50.io, vil du blive bedt om at logge ind, og når du gør og skabe en konto gratis, du vil kunne få adgang til en miljø, der ser ganske som denne. 

Nu, dette er i standardtilstanden. Alt er rart og lyse på skærmen. Mange af os har en vane med arbejder på CS50 stykke, der er ganske sent ud på natten. Og så nogle af jer måske foretrække at gøre det til nat-mode, så at sige. 

Men i sidste ende, hvad du er kommer til at se inden CS50 IDE er tre særskilte areas-- et område til venstre, hvor dine filer vil være i sky, et område øverst til højre hvor din kode vil være redigeres. Du vil være i stand til at åbne individuelle faner for ethvert program at du skriver dette semester inde af denne øverste højre hjørne. Og så mest arcanely, og dog stærkt, bliver denne ting på bund kendt som en terminal vindue. 

Dette er en gammel skole Command Line Interface eller CLI, der tillader dig til at udføre kommandoer på computer-- i dette tilfælde computeren i cloud-- at gøre ting som kompilere din kode fra kildekoden til maskinkode, at køre dine programmer, eller at starte din webserver, eller få adgang til din database, og et antal andre teknikker at vi vil begynde at bruge inden længe. Men for at komme dertil, er vi vil faktisk have at gå online og begynde at spille. Og for at gøre det, så lad os først begynde at fifle med de vigtigste, og skriv den vigtigste del af et program. Og lad os bruge denne funktion printf, som vi brugte tidligere, blot at sige noget. 

Så her er jeg allerede inde i CS50 IDE. Jeg har logget på forhånd. Og jeg screenet fuld vinduet. Og så, i sidste ende, du også i kommende problemer vil følge lignende skridt, der vil give online-dokumentation. Så du behøver ikke at bekymre sig om absorbere hvert lille teknisk skridt at jeg gør her i dag. 

Men du får en skærm som denne. Jeg tilfældigvis er i nat-tilstand. Og du kan lysne alt op ved at deaktivere nat mode. Og ved slutningen af ​​den dag, er du nødt til at se disse tre vigtigste areas-- filen browser til venstre, koden faner op toppen, og terminalvinduet nederst. 

Lad mig gå videre og skrive min første program. Jeg har tænkt mig at forebyggende gå til Fil, Gem og gemme min fil som hello.c. Faktisk ved konvention, ethvert program, vi skriver, der er skrevet i C sproget bør navngives noget dot c, efter sædvane. Så jeg har tænkt mig at nævne det hello.c, fordi Jeg vil bare sige hej til verden. Nu vil jeg zoome ud og klik på Gem. Og alt hvad jeg har her nu er en fane hvor kan jeg begynde at skrive kode. 

Dette kommer ikke til at kompilere. Det betyder ikke noget. Og så selvom jeg konverterede dette til nuller og ettaller, CPU'en vil have nogen idé om, hvad der foregår rundt. Men hvis jeg skriver linjer, der matcher op med C'er conventions-- C væsen, igen, denne language-- med syntaks ligesom dette, printf hej verden-og jeg har fået godt med gør dette over tid. Så jeg tror ikke, jeg gjorde eventuelle trykfejl. 

Men, uvægerligt, den allerførste gang du gør dette, vil du. Og hvad jeg er ved at gøre måske meget godt ikke arbejde for dig første gang. Og det er helt OK, fordi lige nu er du kunne bare se en hel masse newness, men over tid, når du blive fortrolig med dette miljø, og dette sprog, og andre, du vil begynde at se ting, er enten rigtige eller forkerte. 

Og det er, hvad det undervisning stipendiater og kursus assistenter får så god til over tid, er spotting fejl eller fejl i din kode. Men jeg hævder, at der er ingen fejl i denne kode. Så jeg ønsker nu at køre dette program. 

Nu på min egen Mac eller pc, jeg er i for vane at dobbeltklikke ikoner når jeg vil køre nogle program. Men det er ikke den model her. I dette miljø, som er CS50 IDE. Vi bruger et operativsystem system kaldet Linux. Linux minder om en anden operativsystem, generelt kendt som Unix. Og Linux er især kendt for have en Command Line Miljø, CLI. Nu, vi bruger en bestemt smag af Linux kaldet Ubuntu. Og Ubuntu er simpelthen en bestemt version af Linux. 

Men disse Linux er i disse dage gør faktisk kommer med grafiske brugergrænseflader. Og den, vi tilfældigvis bruge her er webbaseret. Så dette kunne se endnu en lidt anderledes end noget du selv kan have set eller køre i fortiden. 

Så jeg har tænkt mig at gå videre nu og gøre følgende. Jeg har gemt denne fil som hello.c. Jeg har tænkt mig at gå videre og typen clanghello.c Så Dunk for C-sproget er en compiler. Det er pre-installeret i CS50 IDE. Og du kan absolut hente og installere dette på egen hånd Mac eller pc. 

Men igen, du ville ikke have alle præ-konfiguration gjort for dig. Så for nu, jeg er bare kommer til at køre clanghello.c. Og nu mærke til denne syntaks her vil i sidste ende indse, betyder, at jeg er i en mappe eller mappe kaldet Workspace. Denne dollartegn er bare konvention for mening, skriv dine kommandoer her. 

Det er hvad der kaldes en hurtig, bare ved konventionen er dollartegn. Og hvis jeg gå videre nu og klik Enter, intet synes at være sket. Men det er faktisk en god ting. Jo mindre der sker på skærmen, jo mere sandsynligt din kode er at være korrekt, mindst syntaktisk. 

Så hvis jeg ønsker at køre dette program, hvad gør jeg? Tja, det viser sig, at den standardnavn konventionelt til programmer, når du ikke angiver et navn til dit program er bare a.out. Og denne syntaks også, vil du blive fortrolig med inden længe. 

Dot skråstreg betyder bare, hey, CS50 IDE, køre et program kaldet a.out der er inde min nuværende mappe. Det prik betyder det aktuelle bibliotek. Og vi vil se, hvad andre sådanne sekvenser tegn betyder inden længe. 

Så her går vi, Enter, hej verden. Og du vil opdage, at det, der skete? Ikke kun gjorde det udskriver hej verden. Det flyttede også markøren til den næste linje. 

Og hvorfor var det? Hvad var den kode, vi skrev før der sikrede, at markøren ville gå på den næste linje? Sjove ting om en computer er det kun vil at gøre bogstaveligt hvad du fortæller det til at gøre. 

Så hvis du fortælle det til printf goddag, komma, plads, verden, luk tilbud, det er bogstaveligt talt kun vil at udskrive disse tegn. Men jeg havde denne særlige karakter i slutningen, tilbagekaldelse, backslash n. Og det er, hvad sikres at tegnet gik til den næste linje af skærmen. 

Faktisk lade mig gå og gøre dette. Lad mig gå videre og slette denne. Nu mærke til, at øverst på min skærm er der lidt rødt lys i fanen indikerer, hey, du har ikke gemt din fil. Så jeg har tænkt mig at gå videre med kontrol S eller kommando S, gemme filen. Nu goes-- det gik for en moment-- grøn. Og nu er det tilbage til blot at være en tæt ikon. 

Hvis jeg nu køre clanghello.c igen, Indtast, dot skråstreg, a.out, Enter, vil du se, at det stadig arbejdede. Men det er nok lidt buggy. Lige nu, min prompt-- arbejdsområde, og så er dollartegn, og derefter min faktiske prompt-- er alle på samme linje. Så dette helt sikkert en æstetisk bug, selv om det ikke er virkelig en logisk fejl. 

Så jeg har tænkt mig at fortryde, hvad jeg lige gjorde. Jeg har tænkt mig at kør a.out. Bemærk, at jeg har tilføjet newline tegn tilbage. Jeg har gemt filen. 

Så jeg har tænkt mig at gentages a.out, og-- for fanden, en fejl, en fejl der betyder fejltagelse. Så fejlen er, at selvom Jeg tilføjede omvendt skråstreg n der, re-gemt, re-løb i programmet, adfærden var det samme. Hvorfor skulle det være? 

Jeg mangler et skridt, ikke? Det afgørende skridt tidligere var, at du har at-- når du ændrer din kildekode, det viser sig også køre det gennem compiler igen, så du får ny maskinkode. Og maskinkode, de nuller og ettaller, kommer til at være næsten identiske, men ikke perfekt, fordi vi har brug for, naturligvis, at nye linje. 

Så for at løse dette, jeg har tænkt mig at brug for at køre clanghello.c, indtaste, prik slash, a.out. Og nu, hej verden er tilbage til hvor jeg forventer, at være. Så dette er alt fint og godt. Men a.out er en temmelig dum navn for en program, selvom det sker at være, af historiske grunde, den default-- betyder montage udgange. 

Men lad mig gå videre her og gøre det anderledes. Jeg vil have min hello world program til rent faktisk at blive kaldt hej. Så hvis det var et ikon på min skrivebordet, ville det ikke være a.out. Det ville blive kaldt hej. 

Så for at gøre dette, viser det sig at Dunk, ligesom mange programmer, understøtter kommandolinjeflag, eller flag, eller kontakter, der blot påvirke adfærd. Specifikt Dunk understøtter en bindestreg o flag, som derefter tager et andet ord. I dette tilfælde vil jeg vilkårligt, men rimeligt, kalder det hej. Men jeg kunne kalde det noget Jeg ønsker, undtagen a.out, som ville være ret ud over punktet. 

Og så bare angive navnet af filen jeg ønsker at kompilere. Så nu selvom i begyndelsen af kommandoen Jeg har stadig Dunk, ved slutningen af ​​kommandoen Jeg har stadig filnavnet, Jeg har nu disse kommandolinjen argumenter, disse flag, der siger, Åh, ved den måde, output-o, en fil kaldet hej, ikke standard a.out. 

Så hvis jeg ramte Indtast nu, intet synes at være sket. Og, endnu, nu kan jeg gøre dot skråstreg hej. Så det er det samme program. De nuller og ettaller er identisk i slutningen af ​​dagen. 

Men de er i to forskellige files-- a.out, som er den første version og bare tåbeligt navngivet, og nu hej, som er et meget mere overbevisende navn for et program. Men, helt ærligt, jeg aldrig vil huske dette igen, og igen, og igen. Og, faktisk, da vi skriver mere komplicerede programmer, de kommandoer, du er nødt til at skrive kommer til at få endnu mere kompliceret stadig. 

Og så ikke at bekymre dig. Det viser sig, at mennesker før os har indset de også havde netop dette samme problem. De havde heller ikke nyde at skulle skriv temmelig lange, mystiske kommandoer, endsige huske dem. Og så mennesker før os har gjort andre programmer, der gør det nemmere at kompilere din software. 

Og, ja, en sådan program kaldes Make. Så jeg har tænkt mig at gå videre og gøre dette. Jeg har tænkt mig at fortryde alt, hvad jeg lige gjorde på følgende måde. Lad mig skrive LS. Og du vil opdage tre things-- a.out, og en stjerne, hej og en stjerne, og hello.c. Forhåbentlig dette bør være lidt intuitiv, for så vidt som tidligere var intet i denne arbejdsområde. Der var ikke noget, at jeg havde skabt indtil vi begyndte klasse. 

Og jeg skabte hello.c. Jeg derefter kompileret det, og kaldte det a.out. Og så jeg kompileret det igen lidt anderledes, og kaldte det hej. Så jeg har tre filer i denne mappe, i denne mappe kaldet Workspace. Nu kan jeg se, at så godt hvis jeg zoome ud faktisk. 

Hvis jeg zoome ud her og se på det øverste højre hjørne, som lovet venstre side af skærmen altid vil vise dig hvad der er i din konto, hvad er indersiden af ​​CS50 IDE. Og der er tre filer der. 

Så jeg ønsker at slippe af a.out og goddag. Og som du måske forestille intuitivt, du kunne sortere af kontrol klik eller højreklik på dette. Og denne lille menu dukker op. Du kan downloade filen, køre det, se det, opdatere, omdøbe, eller hvad ikke. 

Og jeg kunne bare slette, og det ville gå væk. Men lad os gøre ting med en kommando linje for nu, så for at få komfortabel med dette, og gøre følgende. Jeg har tænkt mig at gå videre og fjern a.out ved at skrive bogstaveligt rma.out. Det viser sig, kommandoen for fjerne eller slette noget, er ikke fjerne eller slette. 

Det er mere kortfattet RM, blot for at spare dig nogle tastetryk, og tryk Enter. Nu skal vi til at være noget kryptisk fjerne almindelig fil a.out. Jeg ved ikke rigtig, hvad en uregelmæssig fil ville være endnu. Men jeg ønsker at fjerne det. 

Så jeg har tænkt mig at skrive y for ja. Eller jeg kunne skrive det ud, og tryk på Enter. Og igen, intet synes at ske. Men det er generelt en god ting. 

Hvis jeg skriver LS denne gang, hvad skal jeg se? Forhåbentlig bare hej og hello.c. Nu, som en sidebemærkning, vil du bemærke dette stjerne, stjerne, der er i slutningen af ​​mine programmer. Og de er også dukke op i grønt. Det er bare CS50 IDE måde af cluing dig ind det faktum at det ikke er kildekode. Det er en eksekverbar, et runnable program, som du rent faktisk kan køre ved at gøre dot skråstreg, og så er det navn. 

Lad mig gå videre og fjern dette, rm hej, Enter, fjern regelmæssig fil hej, ja. Og nu, hvis jeg skriver LS, vi er tilbage til hello.c. Prøv ikke at slette din faktiske kildekode. Selv om der er funktioner indbygget i CS50 IDE hvor du kan gå gennem din revision historie og tilbage i tid, hvis du ved et uheld slette noget, gør være opmærksomme som pr disse prompter ja eller nej, af, hvad du rent faktisk ønsker at gøre. Og hvis jeg går op til toppen venstre hjørne her, er der kun tilbage hello.c. Så der er klaser af andre kommandoer, som du kan udføre i verden af ​​Linux, hvoraf den ene er, igen, Få. Og vi kommer til at Make mit program nu som følger. 

I stedet for at gøre clang, stedet for at gøre klang-o, Jeg har tænkt mig at blot bogstaveligt skriver, gør hej. Og nu mærke til, er jeg ikke skrive gøre hello.c. Jeg skrive gøre hej. 

Og dette program Gøre, at kommer med CS50 IDE, og mere generelt med Linux, er et program, der er kommer til at lave et program kaldet Hello. Og det kommer til at antage, efter sædvane, at hvis dette program kan foretages, det vil ske fra en kilde kode fil der ender på dot c, hello.c. 

Så hvis jeg ramte Indtast nu, meddelelse om, at kommandoen, der bliver henrettet er faktisk endnu længere før end før. Og det er, fordi vi har prækonfigureret CS50 IDE at have nogle ekstra funktioner indbygget i det Vi har ikke brug for lige nu, men snart vil. Men nøglen ting at indse er nu jeg har en Hello program. 

Hvis jeg skriver LS igen, jeg har en Hej program. Og jeg kan køre det med dot skråstreg a.out, nej, fordi hele pointen med denne øvelse var dot skråstreg hej. Og nu har jeg min hello world program. Så bevæger sig fremad, vi er næsten altid bare kommer til at kompilere vores programmer ved hjælp af kommandoen Make. Og så vil vi køre dem ved dot skråstreg, og programmets navn. Men indse, hvad gør gør for dig, er det i sig selv ikke en compiler. Det er bare en bekvemmelighed program der forstår at udløse en compiler til at køre, så du selv kan bruge den. 

Hvad findes andre kommandoer i Linux, og til gengæld for CS50 IDE? Vi vil snart se, at der er en CD kommando, Change Directory. Dette giver dig mulighed inden din kommandolinjegrænseflade at bevæge sig fremad, og tilbage, og åbne op forskellige mapper uden at bruge musen. 

LS, vi oplevede, som står for liste filerne i det aktuelle bibliotek. Gør Dir, kan du sandsynligvis begynder at udlede hvad disse betyder nu-- gøre biblioteket, Hvis du vil oprette en mappe. RM til fjerne, RM Dir for fjerne directory-- og disse, igen, er kommandolinjen ækvivalenter af hvad du kunne gøre i CS50 IDE med musen. Men du vil snart finde at nogle gange er det bare meget hurtigere at gøre ting med et tastatur, og i sidste ende en meget mere kraftfuld. 

Men det er svært at argumentere for, at noget vi har gjort hidtil er alt, kraftfuld, når alle vi har at sige er, hej verden. Og i virkeligheden, jeg hardcodede den ord hej verden i mit program. Der er ingen dynamik endnu. Scratch var en størrelsesorden mere interessant sidste uge. 

Og så lad os komme der. Lad os tage et skridt mod, at ved måde af nogle af disse funktioner. Så ikke alene C kommer med printf, og klaser af andre funktioner hvoraf vi vil se over tid, gør det ikke gør det så let lige ud af porten i at få brugerinput. 

Faktisk er en af ​​svaghederne af sprog som C, og selv Java og endnu andre, er, at det ikke gør det nemt at bare få ting som heltal fra brugere eller strygere, ord, og sætninger, endsige ting som floating point værdier eller reelle tal med decimaler, og virkelig lange numre, som vi snart vil se. Så denne liste over funktioner her, disse er ligesom andre Scratch puslespilsbrikker at vi har pre-installeret i CS50 IDE, som vi vil bruge til et par uger som uddannelse hjul slags, og i sidste ende tage dem af, og se under emhætten, måske, på hvordan disse ting gennemføres. 

Men for at gøre dette, lad os rent faktisk at skrive et program. Lad mig gå videre nu. Og jeg har tænkt mig at oprette en ny fil ved at klikke på denne lille plus, og klikke på Ny fil. 

Jeg har tænkt mig at gemme denne næste en som, lad os sige, string.c, fordi jeg ønsker at spille med strygere. Og streng i C er bare en sekvens af tegn. Så lad os nu gå videre og gøre følgende. 

Medtag standard IO.h-- og det viser sig standard IO, IO betyder blot input og output. Så det viser sig, at denne linje her er hvad er det nærliggende for os at bruge printf. Printf selvfølgelig frembringer output. Så for at bruge printf, viser det sig ud du nødt til at have denne linje kode i toppen af ​​din fil. 

Og vi vil vende tilbage til det der virkelig betyder inden længe. Det viser sig, at i enhver C-program jeg skriver, Jeg har fået at starte den med kode, der ligner dette. Og du vil opdage CS50 IDE og anden integreret udvikling miljøer som det, vil forsøge så godt de kan for at afslutte din tanke. Faktisk et øjeblik siden, hvis jeg fortryder hvad jeg lige gjorde, jeg ramte på Enter. 

Jeg derefter ramte åben krøllet bandage, tryk Enter igen. Og det færdige min tanke. Det gav mig en ny linje, indrykket ikke mindre for nice stilistiske årsager vil vi se. Og så gav mig automatisk at krøllede tandbøjle til at afslutte min tanke. Nu er det ikke altid gætte, hvad du vil gøre. Men for en stor del, det gør spare dig nogle tastetryk. Så for et øjeblik siden, kørte vi denne program-- hej, verden, og derefter kompileret det, og derefter kørte det. Men der er ingen dynamik her. Hvad hvis vi ønskede at gøre noget anderledes? Nå, hvad hvis jeg ønskede at faktisk få en streng fra brugeren? Jeg har tænkt mig at bruge en puslespilsbrik kaldt præcis at-- få streng. 

Viser sig i C, at når du ikke ønsker at give input til en brik, eller mere korrekt til en funktion, du bogstavelig talt bare gøre åben parentes, tæt parentes. Så det er, som om der er ingen hvide felt til at skrive ind. Det siger blok før havde en lille hvid boks. Vi har ikke den hvide boks nu. 

Men når jeg kalder get streng, jeg ønsker at sætte resultatet et eller andet sted. Så en meget almindelig paradigme i C er at kalde en funktion, ligesom get snor her, og derefter gemme sin tilbagevenden værdi. Det er resultatet af dets indsats i noget. 

Og hvad er konstruere i programmering, enten i bunden eller nu C, at vi kan bruge til rent faktisk at gemme noget? Kaldte det en variabel, ikke? Og i Scratch, gør vi ikke rigtig pleje, hvad der foregik i variabler. 

Men i dette tilfælde, vi rent faktisk gør. Jeg har tænkt mig at sige streng. Og så kunne jeg ringe dette hvad jeg vil. Jeg har tænkt mig at kalde det navn, får få streng. 

Og nu selvom du er lidt ny på dette, bemærke, at jeg mangler nogle detaljer. Jeg glemmer et semikolon. Jeg har brug for at afslutte denne tanke. Så jeg har tænkt mig at flytte min markøren, og ramte semikolon der. Og hvad har jeg lige gjort? I denne linje kode, nummer 5 i det øjeblik, Jeg ringer get snor uden input. Så der er ingen lille hvid boks ligesom Gem blokken har. 

Jeg siger bare, hey, computer, få mig en streng. Den lighedstegnet er ikke rigtig et lighedstegn, per se. Det er opgaven operatør, hvilket betyder, hey, computer, flytte værdien fra højre over til venstre. Og i den venstre, har jeg følgende. 

Hey, computer, giv mig et string-- en sekvens af tegn. Og kalder det string Navn. Og jeg behøver ikke engang at kalde det Navn. 

Jeg kunne kalde det, konventionelt, noget som S, meget gerne vi brugte jeg til kalde variablen i. Men nu har jeg brug for at gøre noget med det. Det ville være temmelig dumt at prøve at oversætte denne kode, der kører dette program, selvom Jeg får en streng, fordi det er stadig lige kommer til at sige goddag verden. 

Men hvad nu, hvis jeg ønsker at ændre dette. Hvorfor kan jeg ikke gøre det? Procent s, komma s. Og dette er en lille kryptisk stadig. 

Så lad mig gøre mine variabler mere klar. Lad mig nævne denne variabel navn. Og lad os se om vi ikke kan drille fra hinanden, hvad der sker her. 

Så på linje fem, jeg får en streng. Og jeg opbevare denne streng, hvad brugeren har indtastet på hans eller hendes tastatur, i en variabel kaldet navn. Og det viser sig, at printf ikke bare tage et argument i dobbelt citater, en indgang i dobbelte anførselstegn. 

Det kan tage to eller tre, eller flere, såsom at den anden eller tredje eller fjerde, er alle de navne på variabler, eller specifikt værdier, at du ønsker at sætte ind, dynamisk, at streng i anførselstegn. Med andre ord, hvad ville være galt med dette? Hvis jeg sagde bare hej navn, omvendt skråstreg n, reddede min fil, kompileret min kode, og kørte det, hvad der ville ske? 

Det er lige til at sige, hej navn, bogstaveligt N-A-M-E, som er form for dumme, fordi Det er ikke anderledes end verden. Så noget i anførselstegn er hvad bogstaveligt bliver udskrevet. Så hvis jeg vil have en pladsholder der, Jeg faktisk nødt til at bruge nogle særlige syntaks. Og det viser sig, hvis du læser dokumentation for printf funktion, Det vil sige, at hvis du bruger procent s, du kan erstatte en værdi på følgende måde. 

Efter et komma efter at dobbelt tilbud, skal du blot skrive navnet på den variabel, du vil at tilslutte i dette format kode, eller format specifier, procent s for strygere. Og nu, hvis jeg har gemt min fil, Jeg går tilbage til min terminal. Og jeg skriver Make String, fordi igen, navnet på denne fil, som jeg valgte før er string.c. 

Så jeg har tænkt mig at sige Make String, indtaste. Åh min godhed, se på alle de fejl, vi har lavet i forvejen. Og dette is-- hvad, dette er virkelig ligesom en seks, syv line program? Så det er her, det kan meget hurtigt få overvældende. 

Denne terminal vindue har nu bare regurgitated et stort antal af fejlmeddelelser. Sikkert, jeg har ikke mere fejl meddelelser, end jeg har linjer kode. Så hvad sker der? 

Nå, den bedste strategi at gøre når som helst du støder en overvældende liste over fejl som dette, er rulle tilbage, kigge efter kommandoen du bare kørte, som i mit tilfælde er at gøre streng. Se på, hvad gør gjorde, og det er, at lang Dunk kommando, nogen big deal der. 

Men den røde er dårlig. Green forsøger at være blid og hjælpsomme. Men det er stadig dårligt, i dette tilfælde. Men hvor er det slemt? 

String.c, linje fem, karakter fem. Så dette er bare almindelig konvention. Noget kolon noget betyder linienummer og karakter nummer. Fejl, brug af sort identifikator streng. Mente du standard i? 

Så desværre, Dunk forsøger at være hjælpsom. Men det er forkert, i dette tilfælde. Nej, Dunk, jeg mente ikke standard IO. Jeg mente, at på linje et, ja. 

Men linie fem er denne ene her. Og Dunk ikke forstå S-T-R-I-N-G. Det er en sort identifikator, en ord har det bare aldrig set før. Og det er fordi C, sproget vi skriver koden i lige nu, ikke har variable kaldes strenge. 

Det gør det ikke, som standard, støtte noget, der hedder en streng. Det er en CS50 stykke jargon, men meget traditionel. Men jeg kan løse dette på følgende måde. 

Hvis jeg tilføjer en linje kode til toppen af ​​dette program, omfatter CS50.h, som er en anden fil et sted inde i CS50 IDE, et sted på harddisken, så at sige, af Ubuntu operativsystem at jeg løber, at er den fil, der er vil lære operativsystemet systemet, hvad en streng er, bare ligesom standard io.h er den fil i operativsystemet, der er kommer til at undervise i det, hvad printf er. 

Faktisk ville vi have fået en meget lignende besked hvis IO havde indrømmet standard IO.h og forsøgte at bruge printf. Så jeg har tænkt mig at gå videre og bare tage kontrol L at rydde min skærm. Eller du kan skrive klart og det vil bare rydde terminalvinduet. Men du kan stadig rulle tilbage i tiden. 

Og jeg har tænkt mig at køres igen Make String. Kryds mine fingre denne gang, Enter. Åh min Gud, det virkede. det viser mig lang kryptisk kommando det er det, Sørg genereres via Dunk, men ingen fejlmeddelelser. Så indse, selv om du får muligvis helt overvældet med antal fejlmeddelelser, det bare kunne være dette irriterende cascading effekt, hvor Dunk ikke forstår én ting, hvilket betyder, at det derefter forstår ikke det næste ord, eller den næste linje. Og så det bare chokes på din kode. Men rettelsen kan være enkel. Og så altid fokusere på allerførste linje af output. Og hvis du ikke gør forstår det, bare se for søgeord, der kunne være spor, og linjenummeret, og art, hvor denne fejl kunne være. 

Lad mig nu gå videre og skrive dot skråstreg, snor, indtaste. Hm, er det ikke at sige hej noget. Hvorfor? Nå, husker, hvor det kører? 

Det er formentlig stukket i øjeblikket i en løkke, hvis du vil, på linje seks, fordi Get String ved design, skrevet af CS50 personale, bogstaveligt betød at bare sidde der venter, og venter, og venter på en streng. Alt, hvad vi mener med strengen er menneskeligt input. Så ved du hvad? Lad mig gå videre. Og bare på et indfald, lad mig skriv mit navn, David, indtaste. Nu har jeg en mere dynamisk program. Det sagde hej David. 

Hvis jeg gå videre og køre dette igen, lad mig prøve sige Zamila navn, indtast. Og nu har vi en dynamisk program. Jeg har ikke svært kodet verden. Jeg har ikke svært kodet navn, eller David eller Zamila. 

Nu er det meget mere som programmerne vi ved, hvor, hvis det tager input, den producerer lidt anderledes output. Nu, dette er ikke den bedste brugeroplevelse, eller UX. Jeg køre programmet. 

Jeg ved ikke, hvad jeg skulle at gøre, medmindre jeg faktisk ser på eller huske kildekoden. Så lad os gøre brugeren opleve lidt bedre med den enkleste af ting. Lad mig gå tilbage til dette program, og blot sige printf. 

Og lad mig gå videre og sige navnet, colon, og et mellemrum og derefter et semikolon. Og bare for sjov, ingen slør n. Og det er bevidst, fordi jeg ikke vil bliver bedt om at flytte til den næste linje. 

Jeg vil, i stedet, gør det, gør streng at kompilere min kode i ny maskine kode dot skråstreg streng. Ah, det er meget pænere. Nu ved jeg rent faktisk ved, hvad computeren vil have mig til at gøre, at give den et navn. 

Så jeg har tænkt mig at gå videre og skrive i Rob, indtaste, og goddag, Rob. Så indse, er det stadig i slutningen af dagen, kun en ni linje program. Men vi har taget disse små skridt. 

Vi skrev en linje, som vi var bekendt, printf, hej verden. Så løste vi en lille smule af det. Og vi faktisk brugt get streng. Og vi kastede denne værdi i en variabel. Og så gik vi videre og forbedret det videre med en tredje linje. Og denne iterative skrive software er virkelig nøglen. I CS50, og i livet i almindelighed, du bør generelt ikke sidde ned, har et program i tankerne, og prøv at skrive det hele helvedes ting på én gang. 

Det vil uundgåeligt resultere i måde flere fejl, end vi selv oplevede her. Selv jeg, den dag i dag, hele tiden gøre andre dumme fejl, er faktisk hårdere fejl der er sværere at regne ud. Men du vil gøre flere fejltagelser mere kodelinjer du skriver på én gang. Og så denne praksis med, skrive en lille smule kode at du er fortrolig med, kompilere det, kører det, teste det mere generelt, derefter flytte on-- så ligesom vi holdt lagdeling og lagdeling i sidste uge, bygning fra noget meget simpelt til noget mere kompleks, gøre det samme her. Må ikke sidde ned, og forsøge at skrive en hel problem. Faktisk tager disse små skridt. 

Nu, strenge er ikke alle at nyttig til sig selv. Vi havde faktisk ideelt set gerne har noget andet i vores værktøjskasse. Så lad os rent faktisk gør præcis det. 

Lad mig gå videre nu, og pisk op en lidt anden program. Og vi vil kalde denne int.c, for heltal. Jeg har tænkt mig at, på samme måde, omfatter CS550.h. Jeg har tænkt mig at inkludere standard IO. Og det kommer til at være temmelig almindelig i disse første par dage af klassen. 

Og jeg har tænkt mig at klar mig med en hovedfunktion. Og nu i stedet for at få en streng, lad os gå videre og få en int. Lad os kalde det jeg, og kalder det får int, tætte parens, semikolon. Og lad os nu gøre noget med det, printf. 

Lad os sige noget lignende hej, omvendt skråstreg n, komma i. Så jeg temmelig meget efterligne hvad jeg gjorde for et øjeblik siden. Jeg har en pladsholder her. Jeg har komma jeg her, fordi jeg ønsker at sætte i ind i denne pladsholder. 

Så lad os gå videre og prøve udarbejdelsen af ​​denne program. Filen hedder int.c. Så jeg har tænkt mig at sige, gøre int, indtaste. Åh min Gud, men nogen big deal, right? Der er en fejl. 

Der er en syntaktisk fejl her sådan, at programmet ikke kan udarbejdes inde int.c, linje syv, karakter 27, fejl format specificerer typen char stjerne, hvad det så er. Men argumentet type er int. 

Så også her, vi vil ikke at-- selvom dag er meget materiale, vi kommer til at overvælde dig med absolut hvert element i C, og programmering mere generelt i netop disse første par uger. Så der er ofte kommer til at være jargon som du ikke kender. Og faktisk char stjerne er noget vi kommer til at vende tilbage til i en uge eller to tid. 

Men for nu, lad os se om vi kan parse ord, der er fortrolige med. Formater-- så vi hørte format specifier, format kode før. Det er velkendt. Motortype- men argumentet har typen int. Vent et øjeblik, jeg er en int. 

Måske procent s faktisk har nogle definerede betydning. Og netop det gør. Et heltal, hvis du ønsker printf at erstatte det, du faktisk nødt til at bruge en andet format specifier. Og du ville ikke vide det medmindre nogen fortalte dig, eller du havde gjort det før. Men procent i er hvad kan almindeligvis anvendes i printf til at tilslutte et heltal. Du kan også bruge procent d til en decimal heltal. Men jeg er nice og enkel her. Så vi vil gå med det. 

Lad mig nu gå videre og gentagelsen make int, Enter. Det er godt, ingen fejl. Dot slash int-- OK, dårlig brugeroplevelse, fordi jeg ikke har fortalt mig selv hvad skal man gøre. Men det er fint. Jeg fange på hurtigt. 

Og lad mig gå videre og skrive i David, OK, Zamila, Rob. OK, så dette er en god ting. Denne gang, jeg bruger en funktion, en brik, kaldet get int. Og det viser out-- og vi vil se denne senere i term-- den CS50 personale har gennemført få strengen på en sådan måde at det vil kun fysisk få en streng til dig. 

Det har implementeret get int i sådan måde, at det kun vil få et heltal for dig. Og hvis du, det menneskelige, ikke samarbejder, er det bogstavelig talt lige til at siger prøve igen, prøve igen, prøve igen, bogstaveligt sidder der looping, indtil du forpligter med nogle magiske tal, ligesom 50, og goddag 50. 

Eller hvis vi kører det igen og skrive i 42, hej 42. Og så get int funktionen indersiden af ​​denne brik er nok logik, nok tanke, at finde ud af, hvad der er et ord? Og hvad er et tal? Kun acceptere, i sidste ende, tal. 

Så det viser sig, at denne er ikke alt, udtryksfulde. indtil nu. Så yay, sidste gang vi gik temmelig hurtigt ind gennemførelsesbestemmelser spil og animation, og kunstneriske værker i Scratch. Og her er vi være tilfreds med hello verden, og goddag 50. 

Det er ikke alt, inspirerende. Og, ja, disse første par eksempler vil tage nogen tid at rampe op i spænding. Men vi har så meget mere kontrollerer nu, faktisk. Og vi vil meget hurtigt begynde lagdeling på toppen af ​​disse grundlæggende primitiver. 

Men først, lad os forstå hvad begrænsningerne er. Faktisk er en af ​​de ting Scratch ikke let Lad os gøre, er virkelig se under emhætten, og forstå, hvad en computer er, hvad det kan gøre, og hvad dens begrænsninger er. Og, ja, at manglende forståelse potentielt langsigtet kan føre til vores egen mistakes-- skrivning bugs, skriveredskaber usikker software, bliver hacket på en eller anden måde. 

Så lad os tage nogle skridt i retning forstå dette lidt bedre ved måde, siger, det følgende eksempel. Jeg har tænkt mig at gå videre og gennemføre rigtig hurtig et program kaldet adder. Ligesom, lad os tilføje nogle tal sammen. Og jeg har tænkt mig at kode nogle hjørner her, og bare kopiere og indsætte hvor jeg var før, bare så vi kan komme i gang hurtigere. Så nu har jeg fået de grundlæggende begyndelser af et program kaldet adder. 

Og lad os gå videre og gøre dette. Jeg har tænkt mig at gå videre og siger, intx får få int. Og ved du hvad? Lad os lave en bedre brugeroplevelse. 

Så lad os bare sige x er, og effektivt bede brugeren om at give os x. Og så lad mig gå videre og sige, printf hvad med y er, denne gang forventer to værdier fra brugeren. Og så lad os bare gå videre og sige, printf, summen af ​​x og y er. Og nu ønsker jeg ikke at gøre procent s. Jeg ønsker at gøre procent i, backslash n, og derefter tilslutte sum værdi. 

Så hvordan kan jeg gå om at gøre dette? Du ved hvad? Jeg ved, hvordan man bruger variablerne. Lad mig blot erklære en ny, int z. 

Og jeg har tænkt mig at tage et gæt her. Hvis der er lighedstegn i dette sprog, måske jeg kan bare gøre x plus y, så længe jeg slutte min tænkte med et semikolon? Nu kan jeg gå tilbage hernede, tilslutte z, afslutte denne tanke med et semikolon. Og lad os nu se, hvis disse sekvenser af lines-- x er få int. Y er få int. 

Tilføj x og y, gemme værdien i z-- så, igen, husk lighedstegnet er ikke lig. Det er opgave fra højre mod venstre. Og lad os udskrive at summen af x og y er ikke bogstaveligt z, men hvad der er inde i z. Så lad os gøre Adder - nice, ingen fejl denne gang. Dot skråstreg Adder, indtaste, x bliver 1. 

Y vil være to. Og summen af ​​x og y er 3. Så det er alt fint og godt. 

Så du ville forestille sig, at matematik bør arbejde i et program som dette. Men ved du hvad? Er denne variabel, linje 12, endog nødvendigt? Du behøver ikke at få for vane af bare at lagre ting i variabler bare fordi du kan. Og i virkeligheden, er det normalt betragtes som dårlig design hvis du opretter en variabel, kaldet z i dette tilfælde, lagring noget i det, og derefter straks at bruge det, men aldrig igen. Hvorfor give noget et navn ligesom z, hvis du er bogstaveligt talt kommer til at bruge det eneste gang, og så proksimalt for hvor du oprettede det i første omgang, så tæt i form af linjer kode? Så ved du hvad? Det viser sig, at C er temmelig fleksibel. Hvis jeg rent faktisk ønsker at plug-in værdier her, Jeg behøver ikke at erklære en ny variabel. Jeg kunne bare plug-in x plus y, fordi C forstår aritmetik, og matematiske operatorer. 

Så jeg kan blot sige, at gøre dette matematik, x plus y, uanset disse værdier, er, plug den resulterende heltal i denne streng. Så dette kan være, men kun én linje kortere, et bedre design, et bedre program, fordi der er mindre kode, derfor mindre for mig at forstå. Og det er også bare renere, så vidt vi er ikke indføre nye ord, nye symboler, ligesom z, selvom de egentlig ikke tjene meget af et formål. 

Desværre, matematik er ikke alle, at pålidelige tider. Lad os gå videre og gøre dette. Jeg har tænkt mig at gå videre nu og gøre følgende. 

Lad os gøre printf, procent i, plus procent i, skal være procent i, backslash n. Og jeg har tænkt mig at gøre denne-- xyx plus y. Så jeg bare at omskrive denne lidt anderledes her. Lad mig bare gøre en hurtig tilregnelighed check. Igen, lad os ikke komme foran os selv. Lav adder, dot skråstreg adder. x er 1, y er 2, 1 plus 2 er 3. Så det er godt. Men lad os komplicere dette nu lidt, og oprette en ny fil. 

Jeg har tænkt mig at kalde denne ene, sige, ints, plural for heltal. Lad mig starte hvor jeg var for et øjeblik siden. Men lad os nu gøre et par andre linjer. Lad mig gå videre og gøre følgende, printf, procent i, minus procent i, er procent i, komma x, komma yx minus y. Så jeg gør lidt anderledes matematik der. Lad os gøre en anden én. Så procent I tider procent Jeg er procent i, backslash n. Lad os plug-in x, og y, og x gange y. Vi bruger stjernen på din computer for tider. 

Du behøver ikke bruge x. x er en variabel navn her. Du bruger stjerne for multiplikation. Lad os gøre en mere. Printf procent I, opdelt ved procent i, er procent i, backslash n. xy divideret med y-- så du bruger skråstreg i C at gøre division. Og lad os gøre en anden. Resten af ​​procent I, opdelt ved procent i, er procent i. xy-- og nu resten er, hvad der er tilovers. Når du prøver at dividere et nævneren i en tælleren, hvor meget der er tilovers, at kunne du ikke opdele ud? 

Så der er ikke rigtig, nødvendigvis, et symbol vi har brugt i folkeskolen til dette. Men der i C. Du kan sige x modulo y, hvor denne procent skilt i denne context-- forvirrende når du er inde af de dobbelte anførselstegn, indersiden af ​​printf, procent anvendes som formateringsanvisning. 

Når du bruger procent uden for at der i et matematisk udtryk, det er den modulo operatør for modulær arithmetic-- til vores formål her, betyder bare, hvad der er den resten af ​​x divideret med y? Så x divideret med y er x skråstreg y. Hvad er resten af ​​x divideret med y? Det er x mod y, som programmør ville sige. 

Så hvis jeg lavede ingen fejl her, lad mig gå videre og gøre ints, plural, nice, og dot skråstreg ints. Og lad os gå videre og gør, lad os sige, 1, 10. Okay, en plus 10 er 11, check. 1 minus 10 er negativ 9, check. 

1 gange 10 er 10, check. 1 divideret med 10 is-- OK, vi vil springe denne ene. Resterende del af 1 divideret med 10 er 1. Det er korrekt. Men der er en fejl i her. 

Så den jeg sætter min udlevere, ikke korrekt. Jeg mener, det er tæt på 0. 1 divideret med 10, du ved, hvis vi er skære nogle hjørner, sikker, det er nul. Men det skal virkelig være 1/10, 0,1, eller 0,10, 0.1000, eller så videre. 

Det burde egentlig ikke være nul. Tja, det viser sig, at computeren er gør bogstaveligt hvad vi fortalte det til at gøre. Vi gør matematik ligesom x divideret med y. Og både x og y, pr linjerne kode tidligere, er hele tal. 

Endvidere på linie 15, er vi fortæller printf, hey, printf plug-in et heltal, plug-in er et heltal, plug-in en integer-- specifikt x, og derefter y, og derefter x divideret med y. x og y er ints. Vi er gode der. 

Men hvad er x divideret med x? x divideret med y burde være, matematisk, 1/10, eller 0,1, der er et reelt tal, et reelt tal have potentielt et komma. Det er ikke et heltal. 

Men hvad er tættest heltal til 1/10 eller 0,1? Ja, den slags er nul. 0.1 er sådan meget. Og en er så meget. Så 1/10 er tættere på 0 end det er at en. 

Og hvad så C gør for os-- slags fordi vi fortalte det at-- er trunkering at heltal. Det tager værdien, som igen er formodes at være noget i retning 0,1000, 0 og så videre. Og det er beskærer alt efter kommaet således at alt dette ting, fordi den ikke passer i begrebet et heltal, som er blot et tal som negativ 1, 0, 1, op og ned, det kaster alt væk efter kommaet, fordi du kan ikke passe et decimaltegn i et helt tal per definition. 

Så svaret her er nul. Så hvordan kan vi løse dette? Vi har brug for en anden løsning alle sammen. Og vi kan gøre det, som følger. 

Lad mig gå videre og skabe en ny fil, denne ene kaldet floats.c. Og gemme det her i samme mappe, float.c. Og lad mig gå videre og kopiere noget af det kode fra tidligere. 

Men i stedet for at få en int, lad os gøre det. Giv mig en decimaltalsværdi kaldet x. hvor en flydende komma værdi er lige bogstaveligt noget med en floating point. Den kan bevæge sig til venstre, til højre. Det er et reelt tal. 

Og lad mig kalde ikke få int, men få float, som også var blandt menuen af muligheder i C250 biblioteket. Lad os ændre y til en flyder. Så det bliver få float. 

Og nu, ønsker vi ikke at tilslutte ints. Det viser sig, vi er nødt til at bruge procent f for float, procent f for float, og nu gemme det. Og nu, krydsede fingre, gøre flåd, nice, dot skråstreg flåd. x bliver en 1. y Kommer til at være 10 igen. 

Og, nice, OK min tilføjelse er korrekt. Jeg håbede på mere, men jeg glemte at skrive det. Så lad os gå og løse dette logisk fejl. 

Lad os gå videre og få fat følgende. Vi vil bare gøre lidt kopiere og indsætte. Og jeg har tænkt mig at sige minus. 

Og jeg har tænkt mig at sige gange. Og jeg har tænkt mig at sige delt. Og jeg har ikke tænkt mig at gøre modulo, som ikke er så germane her, divideret med f, og tider plus-- OK, lad os gøre det igen. 

Gør flåd, dot skråstreg flåd, og 1, 10, og-- nice, nej, OK. Så jeg er en idiot. Så det er meget almindeligt i datalogi at lave dumme fejl som denne. 

For pædagogiske formål, hvad jeg virkelig ønskede at gøre blev ændre videnskab her til plus, minus, til tider, og til at dele, som du forhåbentlig bemærket i løbet af denne øvelse. Så lad os nu re-kompilere dette program, gør dot skråstreg flåd. 

Og for tredje gang, lad os se, om det opfylder mine forventninger. 1, 10, indtast, ja, OK, 1,000, divideret med 10.000, er 0,100 tusind. Og det viser sig, vi kan styre, hvor mange tal er efter disse decimaler. Vi faktisk vil. Vi kommer tilbage til. 

Men nu, i virkeligheden, matematik er korrekt. Så igen, hvad er takeaway her? Det viser sig, at i C, er der ikke kun lige strings-- og faktisk, Der er ikke rigtig, fordi vi tilføje dem med CS50 biblioteket. Men der er ikke kun ints. 

Der er også flyder. Og det viser sig en masse andre data typer også, at vi vil bruge inden længe. Slår ud, hvis du ønsker en enkelt karakter, ikke en streng af tegn, du kan bruge bare en char. 

Viser sig, at hvis du ønsker en bool, en Boolesk værdi, sand eller falsk kun, takket være CS50 bibliotek, vi har føjet til C bool datatypen samt. Men det er også til stede i mange andre sprog. Og det viser sig, at man nogle gange brug for større tal derefter kommer som standard med ints og flåd. 

Og i virkeligheden, en dobbelt er et tal der bruger ikke 32 bit, men 64 bit. Og en lang lang er et nummer, bruger ikke 32, bits, men 64 bit, henholdsvis for floating point værdier og heltal henholdsvis. Så lad os faktisk nu se det i aktion. 

Jeg har tænkt mig at gå videre her og pisk op en anden program. Her jeg har tænkt mig at gå videre og omfatter CS50.h. Og lad mig gå, omfatter standard IO.h. 

Og du vil opdage noget funky der sker her. Det er ikke farvekodning ting i på samme måde, som det gjorde før. Og det viser sig, det er fordi jeg har ikke givet noget et filnavn. 

Jeg har tænkt mig at kalde denne ene sizeof.c, og ramte Gem. Og mærke til, hvad sker der med min meget hvid kode mod den sorte baggrund. Nu, i hvert fald er der nogle lilla derinde. Og det er syntaks fremhævet. 

Det er fordi, ganske enkelt, jeg har fortalte IDE, hvilken type fil det er ved at give den et navn, og specifikt en fil forlængelse. Lad os nu gå videre og gøre dette. Jeg har tænkt mig at gå videre og meget blot udskrive following-- bool er procent LU. 

Vi kommer tilbage til at på bare et øjeblik. Og så jeg har tænkt mig at print størrelse bool. Og nu, bare for at spare mig selv lidt tid, jeg er kommer til at gøre en hel bundt af disse på en gang. Og specifikt jeg vil ændre dette til en char og fjeldørred. Denne ene, jeg har tænkt mig at ændre til en dobbelt og en dobbelt. 

Denne ene, jeg har tænkt mig at ændre til en flyder og en flyder. Denne ene, jeg har tænkt mig at skifte til en int og en int. Og denne ene, jeg har tænkt mig at skifte til en lang lang. Og det er stadig tager lang tid, lang lang. 

Og så endelig, jeg gav mig selv én for meget, streng. Det viser sig, at i C, er der den særlige operatør kaldet størrelsen af ​​det er bogstaveligt talt vil, når det køres, fortælle os størrelsen af hver af disse variabler. Og dette er en måde, nu, vi kan forbinde tilbage til sidste uges diskussion af data og repræsentation. 

Lad mig gå videre og kompilere størrelsen af ​​dot skråstreg størrelse. Og lad os se. Det viser sig, at i C, specifikt på CS50 IDE, specifikt på operativsystem Ubuntu, som er en 64-bit operativsystem Systemet i dette tilfælde, en bool vil bruge en byte af plads. Det er sådan størrelse måles, ikke i bits, men i byte. Og minde om, at en byte er otte bits. Så en bool, selvom du teknisk set kun brug for et 0 eller 1, det er lidt ødsel hvordan vi har implementeret det. Det er faktisk kommer til at bruge en hel byte-- så alle nuller, er måske alle dem, eller noget lignende, eller bare en 1 blandt otte bits. 

En char, i mellemtiden, bruges til et tegn som en ASCII-tegn per sidste uge, kommer til at være et tegn. Og det Herved overføres op med vores opfattelse af det er ikke mere end 256 bits-- snarere, synchs op med at det er uden længere end 8 bit, som giver os så mange som 256 værdier. En dobbelt vil være 8 byte eller 64 bits. 

En flyder er 4. En int er fire. En lang, lang er 8. Og en streng er 8. Men du behøver ikke bekymre dig om det. Vi kommer til at skrælle det lag. Det viser sig, strygere kan være længere end 8 bytes. 

Og, ja, vi har skrevet strygere allerede, hej verden, længere end 8 bytes. Men vi vil vende tilbage til at på bare et øjeblik. Men take væk her er følgende. 

Enhver computer har kun en begrænset mængden af ​​hukommelse og plads. Du kan kun gemme så mange filer på din Mac eller PC. Du kan kun gemme så mange programmer i RAM kører på én gang, nødvendigvis, selv med virtuel hukommelse, fordi du har en begrænset mængde RAM. 

Og bare for at picture-- hvis du aldrig har åbnet en bærbar computer eller bestilles ekstra hukommelse for en computer, du måske ikke ved, at indersiden af ​​din computer er noget, der ser lidt ligesom dette. Så dette er blot en fælles selskab ved navn Afgørende der gør RAM til computere. Og RAM er hvor programmer leve mens de kører. 

Så på hver Mac eller pc, når du fordobler på et program, og det åbner op, og det åbner nogle Word-dokument eller sådan noget, det gemmer det midlertidigt i RAM, fordi RAM er hurtigere end din harddisk, eller din solid state disk. Så det er bare hvor programmer gå at leve, når de kører, eller når der anvendes filer. 

Så du har ting, der ser som denne inde i din bærbare computer, eller lidt større ting indersiden af ​​dit skrivebord. Men nøglen er du kun har en endeligt antal af disse ting. Og der er kun en begrænset mængde hardware sidder på dette skrivebord til højre her. 

Så, helt sikkert, vi kan ikke gemme uendeligt lange numre. Og endnu, hvis du tænker tilbage til folkeskolen, hvor mange cifre kan du har til højre af et komma? For den sags skyld, hvor mange cifre kan du har til venstre for et komma? Virkelig, uendeligt mange. 

Nu, kun kunne vi mennesker hvordan man udtaler million, og milliarder, trillioner, og quadrillion, og quintillion. Og jeg skubber grænserne for min understanding-- eller my-- jeg forstår tal, men min udtale af tal. Men de kan få uendelig stor med uendeligt mange cifre til venstre eller til højre for et komma. 

Men computere har kun en begrænset mængde hukommelse, et endeligt antal transistorer, en endeligt antal pærer indeni. Så hvad sker der, når du løber tør for plads? Med andre ord, hvis du tænke tilbage på sidste uge når vi talte om tal selv er repræsenteret i binær, antage, at vi har fået denne 8-bit værdi her. 

Og vi har syv 1'ere og en 0. Og formoder, at vi ønsker at tilføje 1 til denne værdi. Dette er en virkelig stor antal lige nu. 

Dette er 254, hvis jeg husker matematik fra sidste uge højre. Men hvad hvis jeg ændre at yderst til højre 0 til en 1? Det hele tal, af Selvfølgelig bliver otte 1'er. Så vi er stadig gode. 

Og der sandsynligvis repræsenterer 255, dog afhængig af kontekst det kunne faktisk repræsenterer et negativt tal. Men mere om det en anden gang. Det føles som om det handler om så højt som jeg kan tælle. 

Nu er det kun 8 bit. Og min Mac, helt sikkert, har måde mere end 8 bit hukommelse. Men det har begrænset. Så den samme argument gælder, selv om vi have flere af disse dem på skærmen. 

Men hvad sker der, hvis du er lagring dette nummer, 255, og du vil tælle en smule højere,? Du ønsker at gå fra 255 til 256. Problemet er naturligvis, at hvis man begynde at tælle ved nul ligesom sidste uge, du kan ikke tælle så højt som 256, endsige 257, endsige 258, m fordi hvad sker, når du tilføjer en 1? Hvis du gør det gamle klasse skole tilgang, du sætter en en her, og derefter 1 plus 1 er 2, men det er virkelig et nul, du bærer en, bære 1, bære 1. Alle disse ting, disse 1'ere, gå til nul. Og du afvikle, ja, som en person påpeget, en 1 på venstre side. Men alt, hvad du kan faktisk se og passer i hukommelsen er bare otte 0'er, hvilket vil sige på et tidspunkt, hvis du, en computer, forsøgt at tælle højt nok oppe, du er kommer til at ombryde omkring, synes det, til nul, eller måske endda negativ tal, der er endnu lavere end nul. 

Og vi kan slags se dette. Lad mig gå videre og skrive en rigtig hurtig program her. Lad mig gå videre og skrive et program kaldet Overflow. Indbefatter CS50.h, indbefatter standard IO.h-- åh, Jeg virkelig savnet min syntaksfremhævning. Så lad os gemme denne som overflow.c. 

Og nu int main void-- og inden længe, ​​vil vi komme tilbage til at forklare, hvorfor vi holder skrive int main tomrum. Men for nu, lad os bare gøre det, tager det for givet. Lad os give mig selv en int, og initialisere den til 0. 

Lad os så gøre for int jeg får zero-- faktisk, lad os gøre en uendelig løkke og se hvad der sker. Mens sandt, så lad os udskrive n er procent i, omvendt skråstreg n, plug-in n. Men nu, lad os gøre n får n plus 1. 

Så med andre ord, på hver iteration af dette uendelig løkke, lad os tage n værdi, og der tilsættes 1 til det, og derefter gemme resultatet igen n til venstre. Og i virkeligheden, har vi set syntaks lidt ligesom dette, kortvarigt. En kølig trick er i stedet skrive alt dette, du kan faktisk sige en n plus er lig med 1. 

Eller hvis du virkelig ønsker at være fancy, du kan sige n plus plus semikolon. Men disse to sidstnævnte er blot hvad vi ville kalde syntaktisk sukker for den første ting. 

Den første ting er mere eksplicit, helt fint, helt korrekt. Men det er mere almindeligt, vil jeg sige. Så vi vil gøre dette for bare et øjeblik. 

Lad os nu gøre overløb, som lyder temmelig ildevarslende, dot skråstreg overløb. Lad os se, n er ved at blive temmelig store. Men lad os tænke, hvor stort kan n få? 

n er et int. Vi så for et øjeblik siden med størrelsen af eksempel at en int er fire bytes. Vi ved fra sidste uge, fire bytes er 32 bit, fordi 8 gange 4, der er 32. Det kommer til at være 4 mia. 

Og vi er op til 800.000. Dette kommer til at tage for evigt at tæller så højt som jeg overhovedet kan. Så jeg har tænkt mig at gå videre, som du måske inden længe, og ramte Kontrol C-- ærligt, kontrol C, en masse, hvor Kontrol C generelt midler annullere. Desværre, fordi dette kører i skyen, undertiden skyen er spytte ud, så mange ting, så meget output, vil det tage lidt tid for mit input at komme til skyen. Så selv om jeg ramte Kontrol C få sekunder siden, dette er absolut den side virkning af en uendelig løkke. 

Og så i sådanne tilfælde, er vi vil forlade det være. Og vi kommer til at tilføje en anden terminalvindue herovre med plus, hvilket naturligvis ikke gør sådan, da det er stadig tænker. Og lad os gå videre og være lidt mere rimelig. 

Jeg har tænkt mig at gå videre og gøre dette kun endeligt mange gange. Lad os bruge en for-løkke, som jeg hentydet til tidligere. Lad os gøre det. Giv mig en anden variabel int i får 0. Jeg er mindre end, lad os sige, 64 i ++. Og lad mig gå videre og print ud n er procent i, komma n. Og så n- dette er stadig vil tage for evigt. Lad os gøre det. 

n bliver n gange 2. Eller vi kunne være fancy og gøre gange lig med 2. Men lad os bare sige n lig selv, gange 2. Med andre ord, i denne ny version af programmet, Jeg ønsker ikke at vente for evigt fra ligesom 800.000 til 4 mia. Lad os bare få det overstået med. 

Lad os faktisk fordoble n hver gang. Hvilket, tilbagekaldelse, fordobling er det modsatte af at have, selvfølgelig. Og mens sidste uge har vi noget igen og igen, og igen, super hurtig, fordobling vil sikkert få os fra 1 til størst mulig værdi, som vi kan tælle til med en int. 

Så lad os gøre netop dette. Og vi vil vende tilbage til dette inden længe. Men dette, igen, er ligesom gentagelsen blok i Scratch. Og du vil bruge dette inden længe. 

Det betyder blot tæller fra nul op til, men ikke lige, til 64. Og på hver iteration af dette loop, bare holde forøgelse i. Så jeg ++ - og denne generelle konstruktion på linje 7 er bare en super almindelig måde af at gentage nogle linjer af kode, nogle antal gange. Hvilke kodelinjer? Disse krøllede parenteser, som du kan have udledes nu, betyder, skal du gøre følgende. 

Det er i ligesom Scratch, når det har de gule blokke og andre farver slags omfavne eller kramme andre blokke. Det er, hvad disse krøllet seler gør her. Så hvis jeg fik min syntaks right-- du kan se gulerod symbol i C-midler det er, hvor mange gange jeg var forsøger at løse dette problem. Så lad os slippe af med, at man helt, og luk vinduet. Og vi vil bruge den nye. Lav overløb, dot skråstreg overløb, Enter, okay, det ser slemt i første omgang. Men lad os rulle tilbage i tiden, fordi jeg gjorde dette 64 gange. 

Og bemærke den første gang, n er 1. Anden gang, n er 2, derefter 4, så 8, derefter 16. Og det lader til, at så snart Jeg kommer til omtrent 1 milliard, hvis jeg fordoble det igen, at bør give mig 2 mia. Men det viser sig, er det lige på nippet. 

Og så er det faktisk flyder en int fra 1 mia til ca. negativ 2 mia, fordi et helt tal, i modsætning til numre vi var under forudsætning af sidste uge, kan være både positive og negative i virkeligheden og i en computer. Og så i det mindste en af ​​dem bits effektivt stjålet. Så vi virkelig kun har 31 bit, eller 2 milliarder mulige værdier. 

Men for nu, takeaway er helt simpelthen, uanset disse tal er og uanset matematik er, der sker noget slemt i sidste ende, fordi i sidste ende, du forsøger at permutere bittene en alt for mange gange. Og du effektivt gå fra alle 1 's til måske alle 0 s, eller måske blot nogle andet mønster, at det klart, afhængigt af kontekst, kan tolkes som et negativt tal. Og så det ser ud den højeste I kan tælle i dette særlige program er kun ca. 1 mia. Men der er en delvis løsning her. Du ved hvad? 

Lad mig ændre sig fra en int til en lang lang. Og lad mig gå videre her og say-- Jeg har tænkt mig at have at ændre dette til et usigneret længe. Eller, lad os se, jeg aldrig kan huske mig selv. 

Lad os gå videre og gøre overløb. Nej, det er ikke det, dr.jur, tak. Så nogle gange Dunk kan være nyttig. Jeg havde ikke huske, hvad det format anvisning var for en lang lang. 

Men, ja, Dunk fortalt mig. Green er en slags god, betyder stadig du har lavet en fejl. Det gætte, at jeg mente LLD. 

Så lad mig tage det råd, en lang lang decimaltal, gem det. Og lad mig køres igen det, dot slash overløb, Enter. Og nu, hvad der er cool er det. 

Hvis jeg går tilbage i tiden, vi stadig starte tælle på samme sted-- 1, 2, 4, 8, 16. Bemærk, får vi alle de op til 1 mia. Men så er vi sikkert komme til 2 mia. 

Derefter får vi til 4 milliarder, derefter 8 milliarder, 17 milliarder. Og vi går højere og højere og højere. Til sidst, også dette pauser. 

Til sidst, med en lang lang, som er den 64-bit værdi, ikke en 32-bit værdi, hvis man tæller for højt, du wrap omkring 0. Og i dette tilfælde, sker vi at ender med et negativt tal. 

Så dette er et problem. Og det viser sig, at denne Problemet er ikke så mystiske. Selvom jeg har med vilje inducerede det med disse fejl, det viser sig, vi ser den slags alle omkring os, eller i det mindste nogle af os gør. 

Så i Lego Star Wars, hvis du nogensinde har spillet spillet, det viser sig, du kan gå rundt bryde tingene op i LEGO verden, og indsamle mønter, væsentlige. Og hvis du nogensinde har spillet dette spil alt for meget tid, da denne unavngivne individ her gjorde, det samlede antal af mønter, som du kan indsamle er, synes det, 4 milliarder. 

Nu med det faktisk afrundet. Så LEGO forsøgte at holde tingene brugervenlig. De gjorde det ikke ligefrem 2 til 32 strøm, per sidste uge. Men 4 milliarder er en grund. Det synes, baseret på disse oplysninger, at LEGO, og det selskab, der gjort denne faktiske software, besluttede at det maksimale antal mønter brugeren kan akkumulere er faktisk 4 milliarder, fordi de valgte i deres kode at anvende ikke en lang lang, tilsyneladende, men bare et heltal, en usigneret heltal, kun et positivt heltal, hvis max værdi er nogenlunde det. Nå, her er en anden sjov en. Så i spillet Civilization, der nogle af jer måske være bekendt med det viser sig, at år siden var en fejl i dette spil, hvor hvis du spillede rollen af Gandhi i spillet, i stedet for ham er meget pacifistisk, i stedet var utrolig, utrolig aggressiv, under visse omstændigheder. Især den måde, at Civilization værker er, at hvis du som spiller, vedtage demokrati, din aggressivitet score får reduceres med to, så minus minus, og derefter minus minus. 

Så du trækker 2 fra din faktiske iteration. Desværre, hvis din iteration er oprindeligt en, og du trække 2 fra det efter vedtagelsen af ​​demokratiet som Gandhi her måske har gjort, fordi han var meget passive-- 1 på omfanget af aggressivitet. Men hvis han vedtager demokrati, så han går fra 1 til negativ 1. 

Desværre var de under anvendelse unsigned numre, hvilket betyder, at de behandlede endog negativ numre, som om de var positive. Og det viser sig, at positiv ækvivalent negativ 1, i typiske computerprogrammer, er 255. Så hvis Gandhi vedtager demokrati har, og derfor hans aggressivitet score faldt, det faktisk ruller rundt til 255 og gør ham til den mest aggressive karakter i spillet. Så du kan google op på dette. Og det var faktisk en utilsigtet programmering bug, men der er indtastet helt den lore lige siden. 

Det er alt sjov og nuttet. Mere skræmmende er, når faktiske virkelige verden enheder, og ikke spil, har de samme fejl. I virkeligheden, bare et år siden en artikel kom ud af om Boeing 787. 

Og artiklen først blik læser lidt mystiske. Men det sagde dette, et software sårbarhed i Boeings nye 787 Dreamliner jet har potentiale til at forårsage piloter at miste kontrollen over luftfartøjet, muligvis i midten af ​​flyvningen, FAA embedsmænd advarede flyselskaber nylig. Det var bestemmelsen at en model 787 fly, der har været tændt kontinuerligt i 248 dage kan miste alle vekselstrøm, AC, elektrisk effekt grundet generatoren styreenheder, GCUs, samtidig gå i fejlsikker tilstand. Det er lidt at miste mig. Men notatet anførte, OK, nu fik jeg det, tilstanden var forårsaget af en software imødegå internt til generatoren kontrol enheder, der vil overflow efter 248 dages kontinuerlig strøm. Vi udsteder denne bemærke at forhindre tab af alle AC elektrisk magt, hvilket kan resultere i tab af kontrollen over flyvemaskinen. 

Så bogstaveligt, er der nogle heltal, eller nogle tilsvarende datatype, anvendes i software i en faktiske flyvemaskine at hvis du holder din fly længe nok, som tilsyneladende kan være tilfældet, hvis du bare kører dem konstant og aldrig frakoble din flyvemaskine, synes det, eller lade sine batterier dør, sidste ende vil tælle op, og op, og op og op og op og op. 

Og i sagens natur en begrænset mængde hukommelse vil overflow, rulle tilbage til nul eller nogle negativ værdi, en bivirkning af, som er den skræmmende virkelige virkelighed at flyet måske har brug for skal genstartes, effektivt, eller kan falde, værre, mens den flyver. Så den slags spørgsmål er stadig med os, even-- dette var en 2015 artikel, desto mere skræmmende når du ikke nødvendigvis forstå, værdsætte, eller forudse den slags fejl. 

Så det viser sig der er en anden dårligt om repræsentation af data. Det viser sig, at selv flåd er form for fejlbehæftet, fordi flåd, også, Jeg foreslog er 32 bit, eller måske 64 hvis du bruger en dobbelt. Men det er stadig begrænset. 

Og fangsten er, at hvis du kan sætte et uendeligt antal numre efter kommaet, der er ingen måde, du kan repræsentere alle mulige numre, som vi blev undervist i folkeskolen kan eksistere i verden. En computer, væsentlige, har til vælge en delmængde af disse numre at repræsentere præcist. 

Nu, kan computeren runde måske en lille smule, og kan give dig mulighed for nogenlunde butik vilkårligt antal, du muligvis ønsker. Men bare intuitivt, hvis du har en begrænset antal bit, du kan kun permutere dem på så mange finite måder. Så du kan ikke muligvis bruger et endeligt antal af permutation af bits, mønstre af nuller og ettaller, at repræsentere en uendelig antal numre, hvilket antyder, at computere might meget vel være at lyve for os nogle gange. 

Faktisk, lad os gøre det. Lad mig gå tilbage til CS50 IDE. Lad mig gå videre og skabe et lille program kaldet Unøjagtighed, at vise, at computere er faktisk upræcis. 

Og lad mig gå videre og begynde med noget af det kode fra før, og nu bare gøre følgende. Lad mig gå videre og gøre printf, procent f, omvendt skråstreg n, 1 divideret med 10. Med andre ord, lad os dykke dybere til 1/10, ligesom 1 og divideret med 10. Sikkert, kan en computer repræsentere 1/10. 

Så lad os gå videre og gøre unøjagtighed. Lad os se. Format angiver skrive dobbelt. Men det argument har typen int. Hvad sker der? 

Åh, interessant, så det er en lektion lærte fra før. Jeg siger, hey, computer show mig en float med procent f. Men jeg giver det 2 ints. Så det viser sig, kan jeg lave dette i et par måder. 

Jeg kunne bare vende en i 1,0, og 10 ind 10,0, hvilket ville faktisk have den virkning at omdanne dem i floats-- stadig forhåbentlig det samme antal. Eller det viser sig der er noget vi vil se igen inden længe. Du kunne kaste tallene. 

Man kan, ved hjælp af denne parentetiske udtryk, kan du sige, hey, computer, tage denne 10, som jeg ved er en int. Men behandle det, please, som om det er en float. Men det føles unødvendigt kompliceret. 

Til vores formål i dag, lad os bare bogstaveligt gøre dem floating point-værdier med et komma, som denne. Lad mig gå videre og gentagelsen, gør unøjagtighed, god, dot skråstreg unøjagtighed, indtaste. OK, vi ser gode. 

1 divideret med 10, ifølge min Mac her, er, ja, 0,100 tusind. Nu blev jeg undervist i folkeskolen der bør være et uendeligt antal 0'er. Så lad os i det mindste prøve at se nogle af dem. Det viser sig, at printf er lidt amatør stadig end vi har brugt. Det viser sig, at du ikke behøver at angive bare procent f, eller bare procent i. Du kan faktisk angive nogle kontrolmuligheder her. 

Konkret Jeg har tænkt mig at sige, hey, printf, faktisk vise mig 10 decimaler. Så det ser lidt underligt. Men du siger procent, dot, hvor mange numre du ønsker at se efter komma, og derefter f til flade, bare fordi det er hvad dokumentationen siger. Lad mig gå videre og redde denne. 

Og mærke også, jeg får træt af genindtastning ting. Så jeg bare sætte op og pil ned på mine nøgler her. Og hvis jeg bliver ved at ramme op, du kan se alle de kommandoer at jeg gjorde, eller forkert lavet. 

Og jeg har tænkt mig at gå videre nu, og faktisk ikke bruge det, tilsyneladende. Lav unøjagtigheder, prik skråstreg imprecision-- så hvad jeg blev undervist i lønklasse skole tjekker ud. Selv hvis jeg udskriver det til 10 decimal placerer det, ja, er 0,10 tusind. Men ved du hvad? 

Lad os få lidt grådige. Lad os sige, ligesom, vis mig 55 peger efter kommaet. Lad os virkelig tage dette programmere for et spin. Lad mig omskabe det med make unøjagtighed, dot skråstreg, unøjagtighed. 

Og her går vi. Din barndom var en løgn. Tilsyneladende, 1 divideret med 10 er faktisk 0.100000000000000005551115123-- 

Hvad sker der? Tja, det viser sig, hvis du slags ser langt nok ud i den underliggende repræsentation af dette nummer, det faktisk er ikke nøjagtigt 1/10 eller 0,1 og et uendeligt antal nuller. Nu, hvorfor er det? 

Godt, selvom det er et simpelt nummer til os mennesker, 1 divideret med 10, det er stadig en af ​​uendeligt mange numre, som vi kunne tænke op. Men en computer kan kun repræsentere endeligt mange deromkring numre. Og så effektivt, hvad computer viser os er dens nærmeste tilnærmelse til antallet vi ønsker at tro er 1/10, eller virkelig 0,10 tusind uendelige. 

Snarere, er dette imidlertid så tæt som det kan få. Og, ja, hvis man ser under emhætten, som vi er her ved at se 55 cifre efter kommaet, vi faktisk se, at virkeligheden. Nu som en sidebemærkning, hvis du har nogensinde set movie-- de fleste af jer sikkert haven't-- men Superman 3 for nogle år siden, Richard Pryor væsentlige gearede dette virkelighed i hans selskab til at stjæle en masse af fraktioner og fraktioner af øre, fordi company-- så vidt jeg husker, det har været en while-- var hovedsagelig smide noget, der ikke passede ind i begrebet cents. 

Men hvis du tilføje op alle disse lille, lille, lille tal igen, og igen, og igen, kan du, som i hans sag, gøre en god sum penge. 

Samme idé blev flået af en nyere, men stadig nu ældre film, kaldet Office Space, hvor fyrene i den film, gjorde det samme, skrues det op fuldstændigt, endte med alt for meget penge på deres bankkonto. Det var alle meget mistænkelige. Men i slutningen af ​​dagen, unøjagtighed er overalt omkring os. 

Og det også kan være skræmmende tilfældet. Det viser sig, at Superman 3 og Office Space til side, der kan være nogle meget reelle verdens forgreninger af realiteterne i upræcis repræsentation af data at selv vi mennesker til denne dag ikke nødvendigvis forstå såvel som vi bør, eller huske så ofte som vi burde. Og, ja, den følgende klip er fra et kig på nogle meget virkelige verden udløbere af, hvad der sker, hvis du ikke værdsætter unøjagtigheden som kan ske i tal repræsentation. 

[VIDEO PLAYBACK] 

-Computere, Vi har alle kommet til at acceptere de ofte frustrerende problemer, gå med them-- bugs, vira, og software fejl, for små priser at betale for bekvemmelighed. Men i højteknologiske og høj hastighed militære og plads programansøgninger, den mindste problem kan blive forstørret i katastrofe. 

Den June 4th, 1996 videnskabsfolk forberedt at lancere en ubemandet Ariane 5 raket. Det var i færd videnskabelig satellitter designet at etablere præcist, hvordan Jordens magnetfelt interagerer med sol vind. Raketten blev bygget til Den Europæiske Rumorganisation, og løftes fra sit anlæg på kysten af ​​Fransk Guyana. 

-At Omkring 37 sekunder inde flyvningen, de først bemærket noget gik galt. Dyserne blev drejning i en måde, de burde virkelig ikke. Omkring 40 sekunder inde i flyvningen, klart, at køretøjet var i vanskeligheder. 

Og det er, når de lavede en beslutning om at ødelægge det. Sortimentet sikkerhed officer, med enorme indvolde, trykkede på knappen, sprængte raket, før det kunne bliver en fare for den offentlige sikkerhed. 

-Dette Var jomfru sejlads Ariane 5. Og dens ødelæggelse tog sted på grund af en fejl indlejret i rakettens software. -Den Problem på Ariane var at der var et tal, der kræves 64 bits til at udtrykke. Og de ønskede at konvertere det til et 16-bit tal. De antog, at nummer aldrig vil til at være meget store, at de fleste af dem, cifre i et 64-bit tal var nuller. De var forkert. 

-Den Manglende evne én softwareprogram til at acceptere den form for nummer genereret af en anden var ved roden af ​​fiasko. Softwareudvikling var blevet en meget omkostningskrævende del af ny teknologi. Ariane raket har været meget vellykket, så meget af den software, oprettet til den var også anvendes i Ariane 5. 

-Den Grundlæggende problem var, at Ariane 5 var hurtigere, accelereret hurtigere. Og softwaren ikke havde redegøres for. 

-Den Ødelæggelse af raketten var en enorm økonomisk katastrofe, alle på grund af et minut softwarefejl. Men dette var ikke den første problemer datakonvertering tid havde plaget moderne raket teknologi. 

-I 1991 med start af den første Golfkrig, Patriot missil oplevet en lignende art af antallet konvertering problem. Og som et resultat, 28 personer, 28 amerikanske soldater, blev dræbt, og omkring 100 andre såret, når Patriot, som skulle at beskytte mod indkommende scuds, undladt at affyre et missil. 

-Når Irak invaderede Kuwait, og Amerika lanceret Desert Storm i begyndelsen af ​​1991, Patriot Missile batterier blev indsat at beskytte Saudi-Arabien og Israel fra irakiske Scud missilangreb. The Patriot er et amerikansk medium-range overflade til luftsystem, fremstillet af Raytheon selskab. 

-Den Størrelse Patriot interceptor selv er omkring ca. 20 fod lang. Og det vejer omkring 2.000 pounds. Og det bærer et sprænghoved på omkring, Jeg synes det er omtrent 150 pounds. Og sprćnghovedet selv er en højeksplosive, som har fragmenter omkring det. Foringen af ​​sprænghovedet er beregnet til at fungere som hagl. 

-De Missiler udføres fire pr container, og transporteres af en sættevogn. 

-Den Patriot anti-missil-system går tilbage mindst 20 år nu. Det blev oprindeligt designet som en luft forsvar missil at nedskyde fjendtlige fly. I den første Golfkrig, når at krig kom, hæren ønskede at bruge det til nedskyde scuds, ikke flyvemaskiner. 

Den irakiske luftvåben var ikke så meget et problem. Men hæren var bekymret om scuds. Og så de forsøgte at opgradere Patriot. 

-Intercepting En fjende missil rejser på mach 5 skulle være udfordrende nok. Men da Patriot blev hastet i brug, hæren var ikke klar over en Irakiske modifikation, der gjorde deres scuds næsten umuligt at ramme. 

-Hvad Skete er scuds der kom i var ustabil. De blev slingrende. Grunden til dette var irakerne, for at få 600 km ud af en 300 kilometer rækkevidde missil, tog vægt ud af den forreste sprænghoved. De gjorde sprćnghovedet lysere. 

Så nu patriot er forsøger at komme på Scud. Og det meste af tiden, det overvældende flertal af tiden, Det ville bare flyve af Scud. Når Patriot systemoperatører indså Patriot savnede sit mål, de detonerede Patriots sprænghoved at undgå mulige tab, hvis det fik lov til at falde til jorden. 

-Det Var hvad de fleste mennesker så, disse store ildkugler på himlen, og misforstået som aflytninger af Scud sprænghoveder. 

-Selv Om natten himmel, Patriots dukkede at være vellykket ødelægge Scuds på Dhahran, der kunne være nogen fejl om dens ydeevne. Der, Patriot radar-system mistet overblikket over et indgående Scud, og aldrig lanceret grund til en software fejl. Det var israelerne, der først opdagede at jo længere systemet var på, jo større tidsforskel blev, på grund af et ur indlejret i systemets computer. 

-Om To uger før tragedien i Dhahran, israelerne indberettes til forsvarsministeriet at systemet var ved at miste tid. Efter omkring otte timer eller kører, bemærkede de, at systemet var ved at blive mærkbart mindre nøjagtige. Den forsvarsministerium reagerede ved fortæller alle de Patriot-batterier ikke forlade systemerne i lang tid. De har aldrig sagt, hvad en lang tid was-- otte timer, 10 timer, 1.000 timer. Ingen vidste. 

-Den Patriot batteri stationeret på kasernen på Dhahran og dets mangelfulde interne ur havde været på over 100 timer om natten den 25. februar. 

-Det Spores tid til en nøjagtighed på omkring en tiendedel sekund. Nu, en tiendedel af et sekund er en interessant nummer, fordi det ikke kan udtrykkes i binær nøjagtigt, som betyder det ikke kan udtrykkes præcist i enhver moderne digital computer. Det er svært at tro. 

Men bruge dette som et eksempel. Lad os tage nummer en tredjedel. En tredjedel må ikke være udtrykt i decimal nøjagtigt. En tredjedel er 0,333 stået på i uendelighed. 

Der er ingen måde at gøre det med absolutte nøjagtighed i decimal. Det er præcis den slags problemer der skete i Patriot. Jo længere systemet kørte den værre blev tidsfejl. 

-Efter 100 timers drift, fejl i tid var kun omkring en tredjedel af et sekund. Men med hensyn til at målrette en missil rejser på mach 5, det resulterede i en tracking fejl på over 600 meter. Det ville være en fatal fejl for soldaterne om, hvad skete der en Scud lancering var opdaget af tidlig varsling satellitter og de vidste, at Scud var kommer i deres generelle retning. De vidste ikke, hvor det kommer. 

-Det Var nu op til radaren komponent af Patriot-systemet forsvare Dhahran at finde og holde styr på de indkommende fjendtlige missiler. 

-Den Radar var meget smart. Det ville faktisk spore placeringen af ​​Scud, og derefter forudsige, hvor det sandsynligvis ville være den næste gang radaren sendt en puls ud. Det blev kaldt en række gate. 

-Så, Når Patriot beslutter tid nok har bestået at gå tilbage og tjekke den næste placering for denne detekteret objekt, det går tilbage. Så når det gik tilbage til den forkerte sted, ser det derefter intet objekt. Og det beslutter, at der ikke var nogen objekt, det var en falsk detektion, og taber sporet. 

-Den Indgående Scud forsvandt fra radarskærmen. Og sekunder senere, det smækkede ind i kasernen. Den Scud dræbte 28, og var den sidste man fyret under den første Golfkrig. 

Tragisk, den opdaterede software ankom til Dhahran den følgende dag. Den software fejl havde været fast, lukning et kapitel i den urolige historie Patriot missil. 

[VIDEO PLAYBACK] DAVID J. MALAN: Så det er alt for sige, at disse spørgsmål af overløb og unøjagtighed er alt for virkelige. Så hvordan har vi her? Vi begyndte med bare taler om printf. Igen, denne funktion, udskriver noget til skærmen, og vi indførte derefter et par andre funktioner fra den såkaldte CS50 bibliotek. Og vi vil fortsætte med at se disse i god tid. Og vi, især anvendes get streng, og få int, og nu også få float, og endnu andre stadig vil vi møder og bruge os inden længe. 

Men til tider, har vi allerede set et behov til at gemme, hvad disse funktioner hånd tilbage? De hånd os tilbage en streng, eller en int eller en flyder. Og nogle gange er vi nødt til at sætte det streng, eller int eller float, et sted. 

Og til at gemme de ting, husker bare ligesom i Scratch, har vi variabler. Men i modsætning til i Scratch, i C har vi konkrete typer af variables-- data typer, flere generally-- blandt dem, en snor, en int, et flyde, og disse andre stadig. 

Og så når vi erklærer variable i C, vi bliver nødt til at erklære vores datatyper. Det er ikke noget vi får nødt til at gøre senere i semesteret da vi overgangen til andre sprog. Men for nu, har vi brug for til a priori på forhånd, forklare til computeren, hvilken type variabel vi ønsker at give os. 

Nu, i mellemtiden, for at udskrive den slags datatyper, vi nødt til at fortælle printf hvad forventer. Og vi så procent s for strygere, og procent i for heltal, og et par andre allerede. Og dem er simpelthen krav for den visuelle præsentation af disse oplysninger. 

Og hver af disse kan faktisk være parametriseret eller sammenknebne på en eller anden måde, hvis du ønsker at fremme kontrol den type output, som du får. Og i virkeligheden viser det sig, at ikke kun er der omvendt skråstreg n for en ny linje. Der er noget andet kaldes backslash r for en vognretur, som er mere beslægtet med en gamle skole skrivemaskine, og også Windows anvendt i mange år. 

Der er backslash t til faner. Slår ud, at hvis du ønsker at dobbelt citat inde i en snor, minde om, at vi har brugt dobbelt citat double citat til venstre og højre ender af vores strenge hidtil. Det synes at forvirre tingene. 

Hvis du ønsker at sætte en dobbelt citat i midt i en string-- og faktisk Det er forvirrende at se. Og så er du nødt til at flygte, så at tale, en dobbelt citat med noget lignende, bogstaveligt, backslash dobbelt citat. Og der er et par andre stadig. Og vi vil se mere af dem, i faktiske brug inden længe. 

Så lad os nu overgangen fra data, og repræsentation, og aritmetiske operatorer, alle hvoraf gav os nogle bygning blokke med at spille. Men lad os nu faktisk give os resten af ​​ordforrådet at vi allerede havde sidste uge med Scratch ved at tage et kig på nogle andre konstruktioner i C-- ikke dem alle. Men de idéer, vi er til at se virkelig bare at understrege oversættelse fra et sprog, Scratch, til en anden, C. 

Og over tid, vil vi samle op flere værktøjer til vores værktøjskasse, så at sige, syntaktisk. Og, ja, vil du se, at de ideer, er nu temmelig velkendt fra sidste uge. Så lad os gøre det. 

Lad os gå videre og pisk op et program der rent faktisk bruger nogle udtryk, et boolsk udtryk. Lad mig gå videre her og oprette en ny fil. Jeg ringer denne condition.c. 

Lad mig gå videre og omfatter CS50 bibliotek. Og lad mig gå videre og inkludere standard IO.h for vores funktioner, og printf, og mere hhv. Lad mig give mig selv, at standardtekst af int main tomrum, hvis forklaring vi får vende tilbage til i fremtiden. 

Lad mig nu gå videre og give selv en int via get int. Så lad mig gå videre og gøre dette. Jeg vil sige, hvis jeg er less-- lad os skelne mellem positive, negative, eller nulværdier. 

Så hvis i er mindre end nul, lad mig bare have dette program blot sige, negativ, omvendt skråstreg n, ellers hvis i er større end nul. Nu er jeg selvfølgelig vil sige printf positiv, backslash n. Og så ellers if-- jeg kunne gøre dette. 

Jeg kunne gøre, hvis jeg er lig 0. Men jeg ville være at gøre ved mindst én fejl allerede. Husk på, at lighedstegnet er ikke lige, da vi mennesker kender det. 

Men det er tildelingsoperatoren. Og vi ønsker ikke at tage 0 på højre og sætte det i jeg til venstre. Så for at undgå denne forvirring, eller måske misbrug af lighedstegnet, mennesker besluttede for nogle år siden at i mange programmeringssprog når du ønsker at kontrollere for ligestilling mellem venstre og højre, du rent faktisk bruger lig ligemænd. Så du rammer lighedstegnet to gange. Når du ønsker at tildele fra højre til venstre, du bruger en enkelt lighedstegn. Så vi kunne gøre denne-- andet hvis jeg lig er lig med nul. 

Jeg kunne derefter gå og åbne mine krøllede parenteser, og sige, printf 0, omvendt skråstreg n, gjort. Men husk, hvordan disse gafler i vejen kan arbejde. Og virkelig, bare tænke på logik. i er et tal. Det er et helt tal, specifikt. Og det betyder, at det vil være mindre end 0 eller større end 0, eller 0. Så der er form for dette stiltiende normale tilfælde. 

Og så kunne vi, ligesom Scratch, dispensere fra andet hvis, og bare sige andet. Logisk, hvis du programmør ved, der er kun tre skovle, hvori en scenarie kan fall-- den første, den anden, eller den tredje i dette case-- ikke genere lægge det yderligere præcision og den yderligere logik der. Bare gå videre med standard tilfældet her for andet. 

Lad os nu gå videre efter at have gemt dette, skal betingelser dot skråstreg conditions-- ikke en stor brugerflade, fordi jeg ikke spørge bruger, som jeg nævnte tidligere. Men det er fint. Vi vil holde det simpelt. Lad os prøve nummer 42. Og det er positivt. Lad os prøve det antal negativ 42, negativ. 

Lad os prøve værdien 0. Og netop det fungerer. Nu, vil du se med problemer før lange, prøvning ting tre gange, sandsynligvis ikke tilstrækkeligt. Du ønsker sikkert at afprøve nogle større tal, nogle mindre numre, nogle hjørne sager, som vi vil komme til at beskrive dem. 

Men for nu, er det en temmelig simpelt program. Og jeg er ret sikker på, logisk, at den falder i tre tilfælde. Og, ja, selvom vi bare fokuseret på de potentielle ulemper af manglende præcision og overløb, i virkelighed, hvor mange af CS50 problemer, Vi vil ikke bekymre sig om, hele tiden, disse spørgsmål af overløb og unøjagtigheder, fordi, i virkeligheden, i C, det er faktisk ikke alt, let at undgå disse ting. Hvis du ønsker at tælle op større, og større, og større, det viser sig der er teknikker, du kan bruge, som ofte involverer ting kaldet biblioteker, samlinger af kode, at andre mennesker skrev, at du kan bruge, og andre sprog som Java og andre, der faktisk gør det meget lettere at tælle endnu højere. Så det er virkelig nogle af disse farer en funktion af det sprog, du bruger. Og i de kommende uger, vil vi se, hvor farligt C egentlig kan være, hvis du ikke bruger det ordentligt. Men derfra, og med Python, og JavaScript, vil vi lag på nogle yderligere beskyttelse, og køre færre af disse risici. 

Så lad os gøre lidt mere interessant logik i vores program. Så lad mig gå videre og skabe et program kaldet logisk bare så jeg kan spille med nogle faktiske logik, logical.c. Jeg vil bare kopiere og indsætte nogle kode fra tidligere, så jeg får tilbage til denne nice udgangspunkt. 

Lad mig denne gang gøre char C. jeg vil give det et navn C bare fordi det er konventionelle, få en karakter fra brugeren. Og lad os lade som Jeg gennemføre del af denne Rm program, fjern program før denne bedt brugeren fjerne en fil. Hvordan kunne vi gøre det? 

Jeg ønsker at sige, hvis C er lig lig, citat Citat slut, y, så jeg har tænkt mig at antage at brugeren har valgt ja. Jeg skal bare udskrive ja. Hvis det rent faktisk var at skrive fjernelse program, vi kunne fjerne filen med flere linjer kode. Men vi vil holde det simpelt. 

Else hvis c er lig lig n- og nu her, vil jeg sige, brugeren må have betydet noget. Og så ellers, ved du hvad? Jeg ved ikke, hvad der ellers brugeren kommer til at skrive. Så jeg vil bare sige, at der er en fejl, uanset han eller hun faktisk har skrevet. 

Så hvad sker der her? Der er en grundlæggende forskel kontra hvad jeg har gjort i fortiden. Anførselstegn, dobbelt anførselstegn, dobbelt citater, og, endnu, enkelte anførselstegn, enkelte anførselstegn. Det viser sig i C, at når du ønsker at skrive en streng, du bruger anførselstegn, ligesom vi har brugt al den tid med printf. 

Men hvis du ønsker at beskæftige sig med blot en enkelt tegn, en såkaldt char, så du faktisk bruge enkelte anførselstegn. De af jer, der har programmeret før, du måske ikke har måtte bekymre dig om dette forskel i visse sprog. I C, det betyder noget. Og så når jeg får en char og jeg vil at sammenligne den char hjælp ligeværdige lig med nogle brev som y eller n, jeg gør, ja, skal have de enkelte anførselstegn. 

Lad os nu gå videre og gøre dette. Lad os gå videre og gør logiske prik slash logisk. Og nu er jeg blevet bedt om det. Så formentlig, en bedre brugeroplevelse ville faktisk fortælle mig hvad jeg skal gøre her. Men jeg har tænkt mig at bare blindt siger y for ja, OK, nice. 

Lad os køre den igen, n for nej, nice. Antag ligesom visse mennesker, jeg kender, mine caps lock tasten er tændt alt for ofte. Så jeg gør kapital Y, indtaste, fejl. OK, det er ikke præcis, hvad jeg forventer. Faktisk computeren gør bogstaveligt hvad Jeg fortalte det til do-- kontrollere for små bogstaver y og små bogstaver n. Dette betyder ikke lyst til god brugeroplevelse, selv om. Lad mig bede om og acceptere enten små bogstaver eller store bogstaver. Så det viser sig, kan du at sige noget lignende i Scratch, som bogstaveligt eller C lig lig kapital enkelt citerede y. Slår ud, har C ikke har denne bogstavelige søgeord eller. 

Men det har to lodrette stænger. Du er nødt til at holde Shift normalt, hvis du bruger et amerikansk tastatur, og ramte den lodrette bjælke nøgle over dit afkast nøgle. Men denne vertikale bar lodret streg betyder eller. 

Hvis, derimod, vi ønskede at sige, og ligesom i Scratch, vi kunne gøre tegnet og-tegn. Det giver ingen logisk mening her, fordi et menneske kunne umuligt har skrevet både y og små bogstaver y og kapital Y som den samme karakter. Så eller er, hvad vi agter her. 

Så hvis jeg gør dette i begge steder, eller c lig lig kapital N, nu køres igen, gøre logisk, gentages logisk. Nu kan jeg skrive y. Og jeg kan gøre det igen med hovedstad Y, eller kapitalen N. Og jeg kunne tilføje i ekstra kombinationer stille. 

Så dette er en logisk program omfang nu Jeg tjekker logisk for denne værdi eller denne værdi. Og jeg behøver ikke at nødvendigvis, komme op med to flere hvis'er eller ellers hvis'er. Jeg kan faktisk kombinere nogle af de logik sammen på denne måde. Så det ville være bedre designet end blot sige, hvis C er lig små bogstaver y, udskrive ja, ellers hvis c er lig kapital Y, udskrive ja, ellers hvis c er lig lower-- med andre ord, du behøver ikke at have flere og flere grene. Man kan kombinere nogle af den ækvivalente grene logisk, som på denne måde. 

Så lad os tage et kig på blot én sidste ingrediens, en endelige konstruktion, at C tillader. Og vi vil komme tilbage i fremtiden til atter andre. Og så vil vi slutte af med at kigge ved ikke rigtigheden af ​​code-- få kode til work-- men designet kode, og plante disse frø tidligt. 

Så lad mig gå videre og åbne en ny fil her. Du ved hvad? Jeg har tænkt mig at re-implementere samme program, brug af et andet konstrukt. 

Så lad mig hurtigt give mig selv adgang til at omfatte CS50.h for CS50 bibliotek, standard Io.h for printf. Giv mig min int main tomrum. Og så herovre, lad mig gå videre og gøre dette. 

Char c får få char, ligesom før. Og jeg har tænkt mig at bruge en ny konstruktion nu-- skifte, på hvilke tegn? Så switch er lidt ligesom skifte en toget spor. Eller, virkelig, er den slags en hvis ellers, hvis ellers hvis, men skrevet noget anderledes. 

En switch ser sådan ud. Du har switch, og hvad så tegn eller tal, du ønsker at se på, derefter nogle krøllede parenteser gerne i Scratch, bare sige gøre det her. Og så har du forskellige sager. 

Du behøver ikke bruge, hvis og andet. Du bogstaveligt talt bruge ordet tilfældet. Og du ville sige noget som dette. 

Så i tilfælde af et lille y, eller i tilfælde af et stort Y, gå videre og udskrive ja. Og derefter bryde ud af kontakten. Det er det. Vi er færdige. 

Else hvis, så at sige, små bogstaver n, eller kapitalen N, derefter gå videre og print ud nej, og derefter bryde. Else-- og denne form for er det normale tilfælde indeed-- printf error-- og bare for god foranstaltning, selv om logisk denne pause er ikke nødvendigt fordi vi er ved enden af omskifteren alligevel, Jeg er nu at bryde ud af kontakten. Så dette ser lidt anderledes. 

Men logisk, det er faktisk tilsvarende. Og hvorfor ville du bruge ene frem for den anden? Nogle gange, bare personlig præference, undertiden æstetik, hvis jeg blik på dette nu, er der noget der taler for den læsbarheden af ​​denne kode. Jeg mener, pyt, at dette kode er nyt for mange af os i rummet. 

Men det er bare sådan er smuk. Du ser små bogstaver y, hovedstaden Y, små bogstaver n, kapital N standard det bare sådan hopper ud på dig på en måde at, velsagtens, måske det foregående eksempel med hvis'er, og de lodrette stænger, og ellers hvis'er, måske ikke har. Så det er virkelig et spørgsmål om personlig valg, virkelig, eller læsbarhed, af koden. 

Men med hensyn til funktionalitet, lad mig gå videre og gøre en switch, prik skråstreg switch, og nu skrive små bogstaver y, hovedstad Y, små bogstaver n, hovedstaden N, David, prøv igen, fordi det er ikke et enkelt tegn. Lad os gøre x, fejl, som forventet. Og, logically-- og det er noget Jeg vil opfordre i general-- selv selvom vi kun skrabe overflade af nogle af disse funktioner. 

Og det kan ikke være indlysende, når du selv sidde ned på tastaturet, hvordan fungerer det? Hvad ville det gøre? Den smukke ting om at have en bærbar computer, eller stationær eller adgang til en computer med en compiler, og med en kode editor som dette, er du næsten altid besvare disse spørgsmål til dig selv lige ved at prøve. 

For eksempel, hvis den retoriske spørgsmål ved hånden var, hvad sker der, hvis du glemmer din pause udsagn? Hvilket er faktisk en meget almindelig ting at gøre, fordi det ikke ser ligesom du virkelig har brug for dem. De har ikke rigtig fuldføre din tænkte som en parentes eller en krøllet tandbøjle gør. Lad os gå videre og rekompilere koden og se. Så gør switch, dot skråstreg switch. Lad os skrive med små bogstaver y, den øverste tilfælde Enter. Så jeg har skrevet y. 

Programmet sagde ja, nej, fejl, som om det var ved at skifte mening. Men den slags var, fordi det, der sker med en kontakt er det første tilfælde, at match væsentlige betyder, hey computer, udføre hele koden under den. Og hvis du ikke siger pause, eller siger ikke pause eller ikke siger pause, computeren vil blæse gennem alle disse linjer og udføre dem alle indtil det bliver til det krøllede klammeparentes. Så bremserne er faktisk nødvendigt. Men en takeaway her er, når i tvivl, så prøv noget. Måske gemmer din kode først, eller gemme det i en ekstra fil hvis du er virkelig bekymret rode op og at skulle inddrive det arbejde, som du ved fungerer. 

Men prøv tingene. Og ikke være så bange, måske, af, hvad computeren kan gøre, eller at du måske bryde noget. Du kan altid vende tilbage til nogle tidligere version. 

Så lad os slutte med at kigge ved udformningen af ​​koden. Vi har denne evne nu at skrive betingelser, og skrive loops, og variabler, og opkaldsfunktioner. Så helt ærligt, vi er slags tilbage på hvor vi var en uge siden med Scratch, omend med en mindre overbevisende tekstmæssige miljøet end Scratch tillader. 

Men bemærk, hvor hurtigt vi har erhvervet at ordforråd, selvom det er kommer til at tage lidt tid at synke i, så vi nu kan bruge denne ordforråd at skrive mere interessante programmer. Og lad os tage en baby skridt mod denne, som følger. Lad mig gå videre og oprette en ny fil her. 

Jeg har tænkt mig at kalde denne prototype.c, og indføre for første gang, evnen at lave dine egne funktioner. Nogle af jer har måske gjort dette med Scratch, hvor du kan oprette din egne brugerdefinerede blokke i Scratch, og derefter trække dem på plads hvor du gerne vil have i C. Og i de fleste programmering sprog, kan du gøre præcis at-- lave dine egne funktioner, hvis de ikke allerede findes. 

Så for eksempel, lad mig gå videre og indbefatter CS50.h, og indbefatter standard IO.h, int main tomrum. Og nu har vi en eksempeltekst klar til at gå. Jeg holder udskrivning ting ligesom folks navne i dag. Og det føles like-- ville ikke være rart, hvis der var en funktion kaldet print navn? Jeg behøver ikke at bruge printf. Jeg behøver ikke at huske alle format koder. Hvorfor ikke jeg, eller hvorfor ikke nogen før mig, oprette en funktion kaldet print navn, der givet nogle navn, blot udskriver det ud? 

Med andre ord, hvis jeg siger, hey, computer, giv mig en streng ved at bede brugeren om sådan, via CS50 os få string funktion. Hey, computer, sætte det streng i variablen i venstre side, og kalder det s. Og så, hey computer, gå videre og udskrive personens navn, gjort. 

Nu ville det være rart, fordi dette program, rammende navn, fortæller mig, hvad det er meningen at gøre ved hjælp af de funktionens navne. Lad mig gå hen og gøre prototype, Enter. Og desværre Dette kommer ikke til at flyve. 

Prototype.c, linie 7, karakter 5, fejl, underforstået erklæring af funktion print navn er ugyldigt i C99, C99 betyder en version af C der kom ud i 1999. Det er alt. 

Så jeg ved ikke, hvad Alt dette betyder endnu. Men jeg anerkender fejl i rødt. Det er temmelig indlysende. 

Og det lader til, at med den grønne karakter her, problemet er med print navn, åben paren s, tæt paren, semikolon. Men underforstået erklæring om funktion vi se kort tidligere. Det betyder blot, at Dunk ikke ved, hvad jeg mener. 

Jeg har brugt et ordforråd ord, at det er aldrig set eller lært før. Og så jeg har brug for at lære det hvad denne funktion betyder. Så jeg har tænkt mig at gå videre og gøre det. 

Jeg har tænkt mig at gå videre og gennemføre min egen funktion kaldet Print Navn. Og jeg har tænkt mig at sige, som følger, at det sker, printf, hej, procent s, omvendt skråstreg n, navn, semikolon. Så hvad gjorde jeg bare gøre? 

Så det viser sig, at implementere din egen funktion, vi slags låne nogle af samme struktur som vigtigste at vi bare har været tages for givet, og jeg kender bare at kopiere og indsætte temmelig meget, hvad Jeg har været at skrive i fortiden. Men bemærk mønsteret her. Int, Main, Void, vi drille hinanden inden længe, ​​hvad det egentlig betyder. 

Men for i dag, bare mærke til parallelitet. Void, print navn, string navn, så der er en lilla søgeord, som vi kommer til at starte kalde en returtype, navnet på funktionen, og derefter input. Så faktisk, kan vi destillere denne form for ligesom sidste uge som, det er det navn eller algoritme af koden er vi vil write-- den algoritme underliggende den kode, vi kommer til at skrive. 

Dette er dens indgang. Dette er dens output. Denne funktion, print navn, er designet til at tage en streng kaldet navn, eller hvad, som input, og derefter annulleret. Det betyder ikke returnere noget, gerne få snor eller få int gør. Så det kommer til at give mig noget tilbage. Det er bare vil have en bivirkning, så at sige, at udskrive en persons navn. Så bemærke, linje 7, jeg kan kalde print navn. Linje 10, kan jeg definere eller gennemføre print navn. Men desværre, det er ikke nok. 

Lad mig gå videre og kompilere dette efter at spare. Whoa, nu har jeg gjort det værre, synes det. Så underforstået erklæring om funktion print er ugyldigt. Og igen er der flere fejl. Men som jeg advarede tidligere, selv hvis du får overvældet med, eller lidt trist at se så mange fejl, kun fokusere på den første i første omgang, fordi det måske bare har haft en kaskadevirkning. Så C, eller Dunk mere specifikt, stadig ikke anerkender print navn. 

Og det er fordi Dunk, ved design, er lidt dum. Det gør kun hvad du fortæller det til at gøre. Og det kun gør det i den rækkefølge hvor du fortæller det til at gøre. 

Så jeg har defineret main på linje fire, ligesom vi har gjort temmelig ofte. Jeg har defineret print navn på linje 10. Men jeg forsøger at bruge print navn på linie syv. 

Det er for tidligt, ikke eksisterer endnu. Så jeg kunne være smart, og være ligesom, OK, så lad os bare spille sammen, og flytte print navn op her, og re-kompilere. Åh min Gud. Det virkede. Det var så simpelt er det. 

Men logikken er nøjagtigt. Du er nødt til at undervise i Dunk, hvad det er ved at definere funktionen først. Derefter kan du bruge det. Men helt ærligt, det føles som en glidebane. 

Så hver gang jeg kører ind i et problem, jeg er bare kommer til at markere og kopiere koden Jeg skrev, klippe det og indsætte det op her. Og, helt sikkert, vi kunne udtænke nogle scenarier hvor én funktion might brug for at ringe til en anden. Og du kan bare ikke sætte hver funktion over alle andre. 

Så det viser sig at der er en bedre løsning. Vi kan forlade dette være. Og helt ærligt, det er generelt nice, og praktisk, og godt design at sætte vigtigste først, fordi igen, vigtigste ligesom når grønne flag klikkede, der er den funktion, bliver udført som standard. Så du kan lige så godt sætte det øverst af filen så når du eller nogen andet menneske ser på filen du ved, hvad der foregår blot ved at læse main først. Så det viser sig, kan vi fortælle Dunk proaktivt, hey, Dunk, på linje fire, Jeg lover at gennemføre en funktion kaldet Print Navn, der tager en streng kaldet navn som input, og returnerer ingenting, ugyldig. Og jeg vil komme rundt til gennemføre det senere. 

Her kommer Main. Main nu på linje 9 kan bruge Print navn fordi Dunk er tillid til, at med tiden, det vil støde definitionen af gennemførelsen af ​​Print Navn. Så efter at redde min fil, så lad mig gå videre og gøre prototype, ser godt denne gang. Dot skråstreg, prototype, lad mig gå videre og skrive et navn. David, hej David, Zamila, hej Zamila, og, ja, nu virker det. 

Så ingrediensen her er, at vi har gjort en brugerdefineret funktion, ligesom en brugerdefineret Scratch blok vi kalder det. Men i modsætning til Scratch hvor du kan bare oprette det og begynde at bruge det, nu har vi til at være en lidt mere pedantisk, og faktisk tog Dunk at bruge, eller at forvente det. Nu, som en sidebemærkning, hvorfor al denne tid har vi været bare blindt på tro herunder CS50.h, og med standard IO.h? 

Tja, det viser sig, blandt et par andre ting, alle, der er i dem, dot h filer, som tilfældigvis er filer. De er header-filer, så at sige. De er stadig skrevet i C. Men de er en anden type fil. 

For nu, kan du stort set antage at alt, hvad der er inde i CS50.h er nogle one-liners som denne, ikke for funktioner kaldet Print Navn, men for Get String, Get Float, og et par andre. Og der er lignende prototyper, en liners, inde af standard IO.h for printf, som nu er i min egen Print Name funktion. Så med andre ord, hele denne gang, vi har netop blevet blindt at kopiere og indsætte medtage denne, omfatter at, hvad sker der? Det er bare slags spor til klang, hvad funktioner er, ja, gennemført, bare andetsteds i forskellige filer andetsteds i systemet. 

Så vi har implementeret print navn. Det har denne bivirkning af trykning noget på skærmen. Men det gør faktisk ikke hånd mig noget tilbage. Hvordan kan vi gå om gennemførelsen af ​​et program, som betyder hånd mig noget tilbage? 

Nå, lad os prøve dette. Lad mig gå videre og gennemføre en fil kaldet return.c så vi kan vise, hvordan noget ligesom Få String, eller Få Int, er faktisk vender tilbage noget tilbage til brugeren. Lad os gå videre og definere int main tomrum. 

Og igen, i fremtiden, vil vi forklare, hvad der int og det tomrum er faktisk gør. Men for i dag, vil vi tager det for givet. Jeg har tænkt mig at gå videre og printf, for en god brugeroplevelse, x er. Og så jeg har tænkt mig at vente på bruger til at give mig x med at komme int. 

Og så jeg har tænkt mig at gå videre og udskrive x til pladsen. Så når du kun har en tastatur, mennesker almindeligt bruge lidt gulerod symbol på tastaturet at repræsentere til magten af eller eksponent for. SOx kvadreret er til stede i. 

Og nu vil jeg gøre det. Jeg kunne bare do-- hvad der er x kvadreret? x squared er x gange x. 

Og det gjorde vi nogle tid siden allerede i dag. Dette betyder ikke lyst så meget fremskridt. Du ved hvad? Lad os udnytte nogle af denne idé fra sidste gang abstraktionsniveau. 

Ville det ikke være rart, hvis der er en funktion kaldet firkant, der gør netop dette? Det stadig, ved udgangen af dag, gør det samme matematik. Men lad os abstrakte væk tanken om at tage ét nummer multipliceret med en anden, og bare give den et navn, kvadratisk denne værdi. 

Og, med andre ord, i C, lad os oprette en funktion kaldet firkant, der gør netop dette. Det kommer til at blive kaldt pladsen. Det kommer til at tage en int. Og vi vil vil bare kalder det n, som standard. 

Men vi kunne kalde det noget, vi ønsker. Og alle, at det kommer til at gør, bogstaveligt talt, er afkast resultatet af n gange n. Men fordi det er returnering noget, som er nøgleordet i lilla vi har aldrig set før, jeg, på linje 11, kan ikke bare sige ugyldig denne gang. 

Void, i eksemplet, vi lige har set snarere af print navn, betyder blot, gør noget. Men du behøver ikke udlevere mig noget tilbage. I dette tilfælde vil jeg have at returnere n gange n, eller hvad der er, dette nummer. 

Så jeg kan ikke sige, hey, computer, Jeg vender tilbage ingenting, ugyldig. Det kommer til at vende tilbage, af natur, en int. Og så det er alt, der foregår her. 

Indgangen til firkant vil være en int. Og så vi kan bruge det, skal det har et navn, N. Det kommer til at output en int, der ikke har brug for et navn. Vi kan overlade det til main, eller hvem er hjælp mig til at huske denne værdi, hvis vi ønsker med sin egen variabel. 

Og igen, det eneste nye søgeord her er Return. Og jeg er bare laver nogle matematik. Hvis jeg virkelig ønskede at være unødvendigt, Jeg kunne sige int produkt får n gange n. 

Og så kunne jeg sige, returnere produktet. Men igen, at min pointe tidligere af dette bare ikke at være god design-- lignende, hvorfor indføre et navn, et symbol, samme vare, bare til straks returnere den? Det er lidt renere, lidt strammere, så at tale, bare for at sige tilbagevenden n gange n, slippe af med denne linje helt. 

Og det er bare mindre kode til at læse, mindre mulighed for fejl. Og lad os se, om det faktisk arbejder nu. Nu, jeg har tænkt mig at gå fremad og foretage tilbagevenden. 

Uh-oh, implicitte erklæring af funktionen. Jeg lavede denne fejl før, nogen big deal. Lad mig bare skrive, eller fremhæve og kopiere, nøjagtig samme funktion prototype, eller underskrift, af funktionen heroppe. Eller jeg kunne flytte hele funktionen. 

Men det er lidt doven. Så vi vil ikke gøre det. Nu, lad mig gøre tilbagevenden igen, dot skråstreg tilbagevenden. 

x 2. x kvadreret er 4. x 3. x kvadreret er 9. Og funktionen virker nu til at virke. Så hvad er forskellen her? Jeg har en funktion, der hedder firkantet, i dette tilfælde, som jeg sætter i en indgang. Og jeg kommer tilbage en udgang. Og dog, som tidligere, hvis Jeg åbner den anden eksempel fra tidligere, som var kaldet prototype.c, Jeg havde print navn, som returneret ugyldig, så at sige, Eller det returnerede ingenting, og simpelthen havde en bivirkning. 

Så hvad sker der her? Nå, overveje funktionen få streng for et øjeblik. Vi har været ved hjælp af funktionen få strengen på følgende måde. 

Vi har haft en funktion får streng, ligesom omfatter CS50.h, omfatter standard IO.h, int, vigtigste, ugyldig. Og så hver gang jeg har kaldet get streng hidtil, Jeg har sagt noget lignende, snor s får få snor, fordi get string-- lad os kalde denne get.c-- get streng selv returnerer en streng, som jeg kan derefter bruge, og sige, hej, komma, procent s, omvendt skråstreg n, s. 

Så dette er det samme eksempel, virkelig, at vi havde tidligere. Så få strengen returnerer en værdi. Men for et øjeblik siden, print string ikke returnerer en værdi. Det har simpelthen en bivirkning. Så dette er en grundlæggende forskel. Vi har set anderledes typer af funktioner nu, hvoraf nogle har returneret værdier, hvoraf nogle ikke. Så måske er det streng, eller int eller float. Eller måske er det bare ugyldig. 

Og forskellen er at disse funktioner, få data og returnerer en værdi faktisk bringe noget tilbage til bordet, så at sige. Så lad os gå videre og se på en sidste sæt eksempler, der giver en følelse, nu, af hvordan vi kunne, ja, abstrakt bedre, og bedre og bedre, eller mere, og mere og mere, for at skrive i sidste ende bedre kode. Lad os gå videre, og i den ånd af Scratch, skal du gøre følgende. 

Lad mig gå videre og inkludere CS50.h og standard IO.h. Lad mig gå videre og give mig selv en int, vigtigste, ugyldig. Og lad mig gå videre, kalder dette cough.c. 

Og lad mig gå videre og bare ligesom Scratch, udskrive hoste / n. Og jeg ønsker at gøre dette tre gange. Så jeg selvfølgelig bare at kopiere og indsætte tre gange. Jeg vil nu gøre hoste dot skråstreg hoste. Lad os give mig lidt mere plads her, Enter, hoste, hoste, hoste. 

Der er naturligvis allerede en mulighed for forbedringer. Jeg har kopieret og indsat et par gange i dag. Men det var kun så jeg gjorde ikke nødt til at skrive så mange tegn. Jeg skiftede stadig hvad disse linjer kode er. 

Disse tre linjer er identiske, der føles doven og faktisk er, og er nok ikke den rigtige fremgangsmåde. Så med hvad ingrediens kunne vi forbedre denne kode? Vi behøver ikke at kopiere og indsætte koden. 

Og, ja, helst du føler selv kopiere og indsætte, og ikke engang skiftende kode, odds er der er en bedre måde. Og, ja, der er. Lad mig gå videre og gøre en for-løkke, selvom syntaksen måske ikke kommer naturligt endnu. 

Gør dette tre gange, simpelthen ved at gøre following-- og jeg tilfældigvis kender det fra praksis. Men vi har en række eksempler nu. Og du vil se online flere referencer stille. 

Dette er syntaksen i linje 6, at meget gerne Scratch, der gentager blok, gentag følgende tre gange. Det er lidt magisk for nu. Men dette vil få mere, og mere velkendte. 

Og det kommer til at gentage linje otte tre gange, så hvis jeg re-kompilere make hoste, dot skråstreg hoste, hoste, hoste, hoste. Det fungerer stadig på samme måde. Så det er alt fint og godt. Men det er ikke meget indvindes. 

Det er fuldstændig korrekt. Men det føles som om der kunne være en mulighed, som i verden af Scratch, at slags begyndelse at tilføje nogle semantik her, så Jeg har ikke bare have nogle for-løkke, og en funktion, der siger hoste, eller er hoste. Du ved hvad? Lad mig prøve at være en lidt køligere end det, og faktisk skrive en funktion, har nogle bivirkninger, kalder det hoste. 

Og det tager ingen input og returnerer nogen værdi som output. Men ved du hvad den gør? Det gør denne-- printf, citat Citat slut, hoste. 

Og nu her, jeg vil at gå videre og til int, Jeg får nul, jeg mindre end 3, i plus plus. Jeg har tænkt mig at ikke printf, som er velsagtens en implementering lavt niveau detalje. Jeg er ligeglad med hvor at hoste. Jeg ønsker blot at bruge hoste funktionen. Og jeg bare kalde hoste. 

Nu, bemærk dikotomi. Når du ringer til en funktion, hvis du ikke gør ønsker at give det indgange, helt fint. Bare gør åbne paren tæt parentes, og du er færdig. 

Når du definerer en funktion, eller erklære en funktion prototype, Hvis du på forhånd ved, det er ikke kommer til at tage nogen argumenter, sige tomrum i disse parenteser der. Og det gør sikker på, at du vil ikke ved et uheld at misbruge det. Lad mig gå videre og gøre hoste. Og, selvfølgelig, jeg har lavet en fejl. 

Dammit, der er at implicit erklæring. Men det er fint. Det er en let rettelse. Jeg skal bare have prototypen højere op i min fil, end jeg faktisk bruger det. 

Så nu lad mig gøre hoste igen, nice. Nu, det fungerer. Gør hoste, hoste, hoste, hoste. Så du måske tror, ​​at vi er virkelig lige over engineering dette problem. Og faktisk er vi. Dette er ikke en god kandidat for et program i øjeblikket for refactoring, og gør, hvad der er kaldes hierarkisk nedbrydning, hvor du tager noget kode, og derefter du slags faktor ting ud, så som at tilskrive flere semantik til dem, og genbruge det i sidste ende længere sigt. Men det er en byggesten i retning mere sofistikerede programmer at vi starter skriver inden længe at tillader os at have ordforråd med til at skrive bedre kode. Og, ja, lad os se om vi kan ikke generalisere dette yderligere. 

Det virker en smule halt, at jeg, vigtigste, behøver at bekymre dig om dette darn for løkke, og kalder hoste igen og igen. Hvorfor kan jeg ikke bare fortælle hoste, bedes hoste tre gange? Med andre ord, kan ikke, hvorfor jeg bare giver input til at hoste og gøre det? 

Hvorfor kan jeg ikke bare sige, i vigtigste hoste tre gange. Og nu, det er lidt magisk. Det er meget iterativ her. Og det er, ja, en baby skridt. 

Men kun evnen til at sige på linje otte, hoste tre gange, det er bare så meget mere læsbar. Og, plus, jeg behøver ikke at vide eller pleje hvordan hoste er implementeret. Og faktisk senere i sigt og for de endelige projekter, hvis du tackle et projekt med en klassekammerat eller to klassekammerater, vil du indse, at du kommer til at nødt til, eller vil, opdele arbejdet. 

Og du vil ønsker at beslutte på forhånd, hvem der kommer til at gøre hvad, og i hvilke stykker? Og ville det ikke være rart Hvis du, for eksempel, tage ansvaret for at skrive vigtigste, gjort. Og din værelseskammerat, eller din partner mere generelt, tager sig af gennemførelsen af ​​hoste. 

Og denne opdeling, disse vægge af abstraktion, eller lag af abstraktion, hvis du vil, er super stærk, fordi især for større, mere komplekse programmer og systemer, det tillader flere folk til at bygge ting sammen, og i sidste ende sy deres arbejde sammen på denne måde. Men selvfølgelig, vi nødt til nu reparere hoste. Vi er nødt til at fortælle hoste at, hey, ved du hvad? Du vil få brug for at tage en input-- så ikke ugyldig, men int og nu. Lad os gå videre og sætte i hoste int. Jeg får nul. 

i er mindre end hvor mange gange. Jeg sagde tre før. Men det er ikke hvad jeg vil. Jeg ønsker hoste skal generaliseres til støtte enhver antal iterationer. 

Så, ja, det er n, som jeg ønsker, hvad brugeren fortæller mig. Nu kan jeg gå videre og sige print hoste. Og uanset hvad nummer brugeren passerer, Jeg vil gentage, at mange gange. 

Så ved slutningen af ​​dagen, Programmet er identiske. Men bemærke alt det her kunne endda være i en anden fil. Faktisk ved jeg ikke på det øjeblik, hvor printf er implementeret. 

Jeg ved ikke, i det øjeblik, hvordan får snor, eller få int, eller få float gennemføres. Og jeg ønsker ikke at se dem på min skærm. Som det er, er jeg begyndt at fokusere på mit program, ikke disse funktioner. 

Og så, ja, så snart du begynde factoring kode som denne ud, kunne vi endda flytte hoste til en separat fil? En anden kunne gennemføre den. Og dig og dit program bliver meget smuk, og meget læsbar, velsagtens, virkelig fire line program lige der. 

Så lad os gå videre nu og gøre endnu ændring. Bemærk, at min prototype skal ændres op toppen. Så lad mig ordne, at så Jeg kan ikke få råbte på. 

Lav hoste, lad mig køre hoste en gang mere, stadig gør det samme. Men nu, bemærker vi har en ingrediens til en endelig udgave. Du ved hvad? Jeg ønsker ikke at bare hoste, nødvendigvis. Jeg vil gerne have noget mere generelt. Så ved du hvad? Jeg ønsker at gøre dette. Jeg vil gerne have, meget gerne Scratch gør, indflydelse blok, men ikke bare sige noget nogle antal gange. Jeg vil have det til at sige en meget specifik streng. Og derfor gør jeg ikke ønsker det bare sige hoste. Jeg vil have det til at sige, hvad streng føres ind. 

Så mærke, jeg har generaliseret dette, så nu sige føles et godt navn for dette, ligesom Scratch, tager to argumenter, i modsætning til Scratch. Den ene er en streng. Den ene er en int. 

Og jeg kunne skifte dem. Jeg bare lidt ligesom ideen om sige snoren først, og derefter hvor mange gange senere. Void betyder det stadig vender ikke tilbage noget. Disse er blot visuel side effekter, ligesom med [? Jordan,?] en verbal bivirkning af råben. Det gør stadig noget n gange, 0 op til, men ikke lig med n. Det betyder n total tider. Og så bare udskrive hvad det så streng er. Så jeg har virkelig generaliseret denne linje kode. Så nu, hvordan implementerer jeg hoste funktion? 

Jeg kan gøre ugyldig hoste. Og jeg kan stadig tage på, hvordan mange gange, du ønsker at hoste. Men ved du hvad? Jeg kan nu punt at sige. 

Jeg kan ringe sige med Ordet hoste, passerer i n. Og hvis jeg vil også gennemføre, bare for sjov, et nys funktion, Jeg kan nyse nogle antal gange. Og jeg kan holde genbruge n, fordi Bemærk at m i denne forbindelse eller omfang eksisterer kun inden for denne funktion. 

Og n i denne sammenhæng kun eksisterer inden denne funktion her. Så vi vil vende tilbage til disse spørgsmål til omfang. Og her, jeg vil bare sige, Achoo, og derefter n gange, semikolon. 

Og nu, jeg skal bare låne disse funktioner underskrifter heroppe. Så hoste er korrekt. Void nys er korrekt nu. 

Og jeg stadig bare brug sige. Så jeg har tænkt mig at sige, sige string s, int n, semikolon. Så jeg har over-manipuleret dælen ud af dette program. 

Og dette ikke nødvendigvis, det er hvad du skal gøre, når du skriver selv de enkleste af programmer. Tag noget, der er tydeligvis virkelig simpelt, meget kort, og re-implementere det hjælp alt for meget kode. Men du vil faktisk se, og i tid se tilbage på disse eksempler, og indse, åh, det er de trin vi tog til rent faktisk at generalisere, at faktor noget ud, indtil slutningen af ​​dagen min kode er faktisk temmelig rimelig. Fordi hvis jeg ønsker at hoste tre gange så nyse tre gange, Jeg vil blot køres igen dette, Programmet gør hoste, og køre hoste. Og jeg har tre hoste og tre nyser. 

Og så dette er en grundlæggende paradigme, hvis du vil, for, hvordan vi måske gå om faktisk at gennemføre et program. Men lad os bare se nu, hvad det er Vi har gjort alt dette tid, og hvad nogle af de sidste brikker står bag denne enkle kommando. I slutningen af ​​dagen, har vi brugt Dunk som vores compiler. Vi har været at skrive kilde kode, konvertere den via Dunk til maskinkode. 

Og vi har brugt Make bare at lette vores tastetryk så at vi ikke behøver at huske disse besværgelser af Dunk selv. Men hvad er Make faktisk gør? Og til gengæld, hvad der er Dunk faktisk gør? 

Det viser sig, selvom vi har forenklet dagens diskussion ved at sige, du tager kildekoden, passerer det som input til en compiler, som giver dig produktion af maskinen kode, viser sig at der er et par forskellige skridt inde der. Og kompilering sker for at være paraply betegnelse for en hel masse trin. Men lad os bare drille dette ud virkelig hurtigt. 

Det viser sig, at vi har gjort flere ting hver gang jeg kører et program, eller hver gang jeg kompilere et program i dag. Så forbehandling refererer til her-- noget i et C-program, som vi vil se igen og igen, der starter med dette hash symbol, eller hashtag symbolet her, betyder det er en præprocessor direktiv. Det betyder i dette tilfælde, hey computer, gøre noget med denne fil før du rent faktisk kompilere min egen kode. 

I dette tilfælde, hash omfatte, er, væsentlige, C måde at sige, hey computer, gå få indholdet af CS50.h og indsætte dem her. Hey computer, gå få indholdet af standard IO.h, uanset hvor det er på harddisk, indsæt den her. Så disse ting sker først under forbehandlingsfasen. 

Og Dunk gør alt dette for os. Og det gør det så pokkers hurtigt, ikke gøre dig selv se fire forskellige ting, der sker. Men det er den første af disse trin. 

Hvad der rent faktisk sker der nu? Nå, den næste officielle trin er kompilering. Og det viser sig, at udarbejdelse af et program teknisk betyder at gå fra kildekode, de ting vi har været at skrive i dag, til noget kaldet forsamling kode, noget der ser lidt anderledes. 

Og i virkeligheden, kan vi se dette virkelig hurtigt. Lad mig faktisk gå ind i min IDE. Lad mig gå videre og åbne hello.c, som er det allerførste program, som vi begyndte i dag. Og lad mig gå videre og køre Dunk en lidt anderledes, Dunk-s, hello.c, der rent faktisk vil give mig en anden fil hello.s. 

Og vi vil formentlig aldrig igen se denne form for kode. Hvis du tager et lavere niveau systemer klasse som CS61, du vil se meget mere af denne slags kode. Men det er assembler. Dette er X86 assembler at CPU'en, der ligger til grund CS50 IDE faktisk forstår. 

Og kryptisk som den gør se, det er noget computeren forstår temmelig godt. Sub q, er dette en subtraktion. Der er bevægelser. 

Der ringer af funktioner her, x ORING, en bevægelse, en add, et pop, en tilbagevenden. Så der er nogle meget instruktioner lavt niveau at CPU'er forstå, at Jeg hentydet til tidligere. Det er, hvad Intel Inside. 

Der er mønstre af nuller og ettaller, der kort til disse arcanely formuleret, men noget godt navngivet, instruktion, så at sige. Det er, hvad der sker, når du kompilere din kode. Du får samling sprog ud af det, som betyder det tredje skridt er at samle at montering kode i sidste ende, maskine code-- nuller og ettaller, ikke de tekst, som vi lige har set et øjeblik siden. 

Så forbehandling betyder det finde og erstatte, og et par andre ting. Kompilering tager din kilde kode fra C, kildekode at vi skrev, at samlingen kode, som vi bare kiggede på. Montering tager at montering kode til nuller og ettaller at CPU'en virkelig vil forstå ved udgangen af ​​dagen. Og forbinder er det sidste trin det sker for os-- igen, så hurtigt vi ikke selv notice-- der siger, hey computer, tage alle de nuller og ettaller, der skyldes kompilere Davids kode, og hans vigtigste funktion i dette tilfælde. 

Og hey computer, gå få alle de nuller og ettaller at CS50 personale skrev inde i CS50 bibliotek. Bland dem i med Davids. Og hey computer, gå få alle de nuller og dem, at en anden skrev år siden til printf. Og tilføje dem ind i hele, så vi har fik mine nuller og ettaller, den CS50 personalets nuller og ettaller, printf nuller og ettaller, og noget andet vi bruger. 

De har alle bliver samlet sammen til én program kaldet, i dette tilfælde, hej. Så fra nu af, vil vi blot bruge ordet kompilering. Og vi vil tage for givet, at når vi siger, kompilere dit program, det betyder, hey gøre forbehandling, samling, og forbinder. Men der er faktisk nogle saftige ting foregår der under kølerhjelmen. Og især hvis du få nysgerrige nogen tid, du kan begynde at stikke rundt på dette lavere niveau. Men for nu, indser, at blandt grillbarer til i dag er ganske enkelt den begyndelsen af ​​en proces, for at få komfortable med noget som hej verden. Det meste af det, vi gjorde i dag vil bestemt ikke synke i super hurtigt. Og det vil tage nogle tid, og nogle praksis. Og odds er, vil du sortere af ønsker at ramme dit tastatur eller råbe på skærmen. Og alt det er OK. Men, måske forsøge ikke at gør det i biblioteket så meget. 

Og i sidste ende, vil du være i stand til selv, at starte se mønstre, både i god kode at du har skrevet, og i fejl at du har foretaget. Og meget gerne processen med blive en TF eller en CA er ligesom, vil du begynde at få det bedre og bedre til at se de mønstre, og bare løse dit egne problemer i sidste ende. I mellemtiden vil der være masser af os til at låne dig støtte, og få dig gennem denne. Og i opskrivninger for alle problemerne vil du blive guidet gennem alle kommandoerne at jeg helt sikkert kender fra en masse praksis nu, men måske har fløjet over hovedet for nu. Og det er helt fint. 

Men i sidste ende, er du nødt at begynde at se mønstre dukke op. Og når du kommer forbi alle de dumme detaljer, ligesom parenteser, og krøllede parenteser, og semikolon, og de ting, helt ærligt, det er slet ikke intellektuelt interessant. Og det er ikke formålet med tager nogen indledende klasse. Det er de ideer, der kommer til at noget. 

Det er løkkerne, og betingelser, og de funktioner, og stærkere indvinding, og factoring af koden, og godt design, og den gode stil, og i sidste ende rigtigheden af din kode, det er i sidste ende vil sagen mest. Så næste uge, vil vi tage disse idéer, som vi først så i Scratch og har nu oversat til C. Og vi vil begynde at indføre den første af de kursets virkelige verden domæner. 

Vi fokuserer på verden af ​​sikkerhed, og mere specifikt kryptografi, kunsten scrambling information. Og blandt de første problemer man selv vil komme til at skrive ud leger med nogle af syntaksen og løse nogle logiske problemer, i sidste ende inden længe, er til rent faktisk at forvrænge eller kryptere, og i sidste ende dekryptere information. Og alt, hvad vi har gjort dag, vil forholdsvis lav niveau, er bare at tillade os at tage én, og én, og endnu et skridt ovenfor retning skrive den mest interessante kode endnu. 

Så mere om det i næste uge. 

[VIDEO PLAYBACK] 

-Hvad Kan du fortælle mig om sidste gang du så ham? -Hvad Kan jeg sige, virkelig? Jeg mener, det var ligesom alle andre pre-produktion generalprøve, medmindre der var noget, han sagde til allersidst, der stak med mig. 

-Dette Var CS50. 

-Det Er et snit alle, stort stykke arbejde på generalprøven. 

-Det Frokost? 

-Ja, Du og jeg kan snuppe en sandwich i en bit. Lad mig blot debriefing med David virkelig hurtigt. David? David? 

[END AFSPIL] 