[МУЗИКА] DAVID J. Малан: Добре, це CS50. І це один тиждень. Так Нагадаємо, що в останній раз в нульовий тижня, ми зосередилися на обчислювальної мислення. І ми перейшли від того, щоб Подряпини, графічне програмування мова від наших друзів в медіа-лабораторії Массачусетського технологічного інституту. 

І з нуля, так і ми досліджуємо ідеї, як функції і умови, і петлі, і змінні, і навіть події та теми, і багато іншого. І сьогодні, ми будемо продовжувати використовувати ці ідеї, і дійсно приймаючи їх за як належне, але перевести їх на іншу мову, відомий як C. Тепер, C являє собою більш традиційний мову. Це нижчий рівень мова, якщо ви будете. 

Це чисто текстуально. І так, на перший погляд, це все буде виглядати досить загадковим якщо ви ніколи не програмували раніше. Ми будемо мати крапка з комою, і круглі дужки, і фігурні дужки, і багато іншого. Але зрозумійте, що навіть хоча синтаксис про те, щоб виглядати трохи незнайомій більшості з вас, бачити минуле. І спробувати побачити ідеї що, дійсно, знайомі, тому що тут, в тиждень один, що ми почнемо робити це порівняння, Спочатку, Подряпини в порівнянні з C. 

Так, наприклад, згадати, що, коли ми реалізований перший з наших програм в минулий раз, у нас був блок, який виглядав трохи щось на зразок this-- коли це зелений прапор клацнув, а потім ми мали один або більше частин головоломки під ним, в цьому випадку, скажімо, привіт світ. Так що, насправді, в порожньому місці, коли я натискаю, що зелений прапор щоб запустити свою програму, так говорити, це блоки, які отримують виконуються, або бігти. І, зокрема, до подряпин сказав, привіт, світ. 

Тепер, я міг би уточнили різні слова тут. Але ми бачимо, що, дійсно, багато з цих blocks-- і насправді, в C багато functions-- може бути параметризрвані або замовний робити різні речі. Справді, в C, якщо ми хочете конвертувати, в даний час, ця програма Царапина на цей іншу мову, ми збираємося написати мало щось на зразок цього. 

Звичайно, є деякі незнайомі синтаксис там, швидше за все, Int, і круглі дужки і недійсними. Але printf-- навіть якщо ви б думаю, що це буде просто роздрукувати. Але друк означає друк відформатований, як ми скоро побачимо. Це в буквальному сенсі буде друкувати до екрана незалежно знаходиться всередині цих дужок, яка Звичайно, в даному випадку, привіт світ. 

Але ви помітите деякі інші Синтаксис, деякі подвійні лапки, що круглі дужки в кінці, напів-ободової кишки тощо. Таким чином, є кілька накладних витрат, так би мовити, як пізнавально і синтаксично, що ми збираємося щоб пам'ятати, перш ніж довго. Але розумію, що з практикою, це почне вискакувати на вас. 

Насправді, давайте зосередимося на тому Функція specifically-- в цьому випадку, сказати привіт світ. Так би мовити, це функція. Привіт світ є параметром, або аргумент, його налаштування. 

І еквівалентність в С просто буде це один рядок тут, де Printf еквівалентно, скажімо, подвійної лапки, привіт світ еквівалентно, звичайно ж, до того, що в білій коробці там. І зворотний слеш н, хоч скільки-небудь дивно і відсутній на порожньому місці, просто буде мати ефект, ми будемо см в комп'ютері, як мій Mac або PC, просто переміщуючи курсор на наступний рядок. Це як удар Введіть на клавіатурі. 

Таким чином, ми бачимо, що знову незабаром. Але по-перше, давайте поглянемо на це Інший приклад, в разі петель. Ми повинні були це назавжди петлю в останній раз, який був ряд головоломки що зробив щось в буквальному сенсі forever-- в даному випадку, сказати, привіт світ, привіт світ, привіт світ, привіт світ. Так що це нескінченний цикл, відповідно до проекту. 

У C, якщо ми хочемо, щоб це реалізувати Та ж ідея, ми могли б просто зробити це. У той час як вірно, Printf привіт world-- прямо зараз в той час, як раз семантично, вид навіває думка робити щось знову, і знову, і знову, і як довго? Що ж, нагадаємо, що true-- правда, це тільки на один або. 

І правда, це, звичайно ж, завжди вірно. Так що це свого роду безглузда заяву просто сказати, правда. Але насправді, це навмисне, тому що, якщо правда, то як раз завжди вірно, ніж в той час як вірно якраз має на увазі, якщо трохи побічно, що такі рядки коду між цими фігурними дужками потрібно просто виконати знову, і знову, і знову, і ніколи не зупинятися. 

Але якщо ви хочете, щоб ваші петля, щоб зупинити, як ми в минулий раз з чимось на зразок це, повторіть наступні 50 разів, в С ми можемо зробити те ж саме з тим, що називається для loop-- ключове слово не будучи в той час як, але для. І тоді у нас є деякий новий синтаксис тут, з міжнар я дорівнює 0, я менше, ніж 50, я ++. І ми повернемося до цього. Але це просто як би ми перевести безліч блоків схрестити до набору C рядків коду. 

У той же час, розглядати змінні. І справді, ми просто бачив один хвилину назад. І в разі нуля, якщо ми хотів оголосити змінну I для я бути цілим числом, просто число, і ми хочемо, щоб встановити його до деякого значення, ми будемо використовувати цей помаранчевий блок here-- встановити я до 0. 

І ми бачимо сьогодні і за його межами, так само, як минулого тижня, програмісти роблять майже завжди почати відлік з нуля, насправді відповідно до угоди. А й тому, що відкликає наше обговорення двійковій, найменше число ви можете представляти з будь-якою кількістю бітів тільки збирається бути 0 сама. І тому ми як правило, починають ініціалізувавши навіть наші змінні 0. 

А в С, щоб зробити те ж саме, ми будемо говорити Int для цілого числа, я тільки за згодою. Я міг би назвати цю змінну все, що я хочу, так само, як в порожньому місці. І тоді дорівнює 0 тільки правонаступників значення 0 з правого боку і поміщає його в змінну, або контейнер для зберігання там, на лівій стороні. І напів-ободової кишки, як ми see-- і ми вже бачили деякі з цих already-- просто означає кінець думки. Продовжуйте робити щось інше на лініях, які слідують. 

Тепер, що стосується логічних виразів? Нагадаємо, що в порожньому місці, вони були вираженням які є або істинними або false-- питання, насправді, які є або істинними, або хибними. Таким чином, в разі нуля, ми могли б задати просте запитання, як це, це я менше, ніж 50? Так що я, знову ж таки, є цілим числом. Може бути, ми використовуємо його в програмі Скретч стежити за рахунком або щось в цьому роді. Так що цей синтаксис тут в порожньому місці просто означає, це я менше, ніж 50? Ну, на щастя, щось простий в C. І переводити, це ми б просто сказати, що я менше ніж 50, використовуючи знайомий ключ на клавіатурі. 

У той же час, якщо ви хочете сказати щось більш загальне, як, добре, х менше у, де кожен х і у самі по собі є змінними? Ми можемо зробити те ж саме в С, до тих пір, як ми створили ці змінні вже. І ми побачимо, як зробити це незабаром. Ми просто сказали б х менше у. 

Таким чином, ви починаєте побачити деякі загальні риси. І ті люди, які зробили Подряпини були, звичайно, натхненні деякі з цих основних ідей. І ви побачите, цей вид Синтаксис у багатьох languages-- а не просто на порожньому місці, не просто C, але Python, і JavaScript, і інші мови досі. 

Розглянемо іншу конструкцію від C, поняття стану, робити щось умовно. Якщо щось вірно, то це зробити. Якщо щось ще, правда, зробити це. Це свого роду програмування еквівалент розвилки. Може бути, це двостороння вилка, триходовий вилка, або більше. І в порожньому місці, ми могли б мати бачив щось подібне до цього. 

Так що це одна велика одна. Але розглянемо відносне Простота логіки. Якщо х менше у, то говорять х менше ніж у, інакше, якщо х більше у, то кажуть х більше у. І тоді, за логікою речей, якщо ви згадайте нуля або просто свій власний людської інтуїції, добре, якщо х не більш, ніж у, і х не менш, ніж у, то, звичайно, х буде дорівнює у. Так що в цьому випадку, по вкладеності ці Скретч блоки, ми можемо досягти трьох спосіб розвилка? 

У той же час, якщо ми хочемо зробити це в C, це можливо виглядає трохи simpler-- принаймні, як тільки ви отримаєте знайомі з синтаксисом. Якщо х менше у, Printf х менше у. Інакше, якщо х більше у, Printf х більше у. Інакше Printf х одно y-- і, знову ж таки, з тими, зворотна коса риска закінчується просто для тих нових ліній, так що якщо ви насправді запустили цей вид програми було б просто перемістити курсор в кінцевому рахунку, до наступного рядка екрану. 

Тепер, тим часом Царапина була інша складніші функції, тільки деякі з яких ми збираємося спочатку рухатися по всьому світу, С. І один з них був називається списком в порожньому місці. І це був особливий тип змінної, дозволило зберігати кілька речей в ньому назад, до спини, до спини, до спини. 

У C, він не має списки, самі по собі, але щось які в більш загальному сенсі називається масиви, хоча ми повернутися пізніше в цьому семестрі дивитися на щось називається список, або дійсно пов'язаний список. Але зараз, найближче еквівалент в C для нас буде щось називається масивом. І масив просто особливий тип змінної що дозволяє зберігати дані тому, до спини, до спини, до спини. 

І дійсно, в порожньому місці, якщо ми хочемо отримати доступ перший елемент масиву або list-- і я буду називати його, За угодою, ARGV, аргумент вектор, але про це незабаром. Якщо я хочу, щоб отримати на першому елементі з ARGV, в світі нуля ви насправді, як правило, почати відлік з 1. 

І таким чином я міг би отримати пункт 1 ARGV. Це просто, як реалізується MIT поняття списків. Але в C, я збираюся простіше просто сказати, ARGV, що знову-таки це ім'я мого list-- або бути ясно, масив. А якщо я хочу першим елементи, я збираюся використовувати квадратні дужки, яких ви можливо, не часто використовується під клавіатурою. 

Але 0 просто означає, зрозумійте мене першим. Так що в деяких випадках, і як проходить час, ми будемо щоб почати бачити ці дихотомії між нуля і С, в результаті чого Царапина використовує один. Ми в C використовувати 0 тут. Але ви швидко зрозумієте, як тільки ви розумієте основи кожної мови, тобто ці речі починають ставати все більш знайому по практиці і практиці. 

Так що давайте насправді тепер подивіться на програму. Тут має бути першим з нашої C Вихідний код для повних програм. А програма, яку ми запропонувати для розгляду це той, який еквівалентний до цього раніше Скретч шматок. 

Так що тут, у нас є те, що можливо, найпростіша програма C Ви можете написати, що насправді щось робить. Тепер ми розглянемо минуле, на даний момент, вже включають в себе, стандарт io.h, і ці кут дужки, і INT, і порожнеча, і фігурних дужок, тощо. 

І давайте просто зосередитися на то, що, принаймні, інтуїтивно, може вискочити на тебе вже. Насправді, головним чином, я не обов'язково знати, що це таке, але так само, як було нуля, що, коли зелений прапор клацнув шматок головоломки, так що робить C в якості мови програмування мають основну частину коду, який запускається на виконання за замовчуванням. І дійсно, це в буквальному сенсі буде називатися головною. 

Таким чином, основна функція. І це спеціальна функція, яка існує в C, що при запуску програми, це головний, який отримує у веденні за замовчуванням. У світі нуля, це, як правило, коли зелений прапор натиснув, що отримав за замовчуванням запускається. 

У той же час, ми вже бачили це раніше, Printf або друк відформатований, це буде функція, яка поставляється з C, поряд з цілим букетом інших, що буде час і час від знову ж таки, для того, щоб зробити точно як припускає його назва, надрукувати що-небудь. Що ми хочемо надрукувати? Ну, ми побачимо, що укладаючи символів як these-- привіт світ, зворотна коса п в подвійних лапках, ми можемо сказати точно Printf що друкувати на екрані. 

Але для того, щоб зробити що ми, на жаль, потрібно взяти щось вже загадковим для нас, людей, але принаймні це кілька readable-- гострі включають, стандарт io.h, INT, Основний, недійсним, Printf, всі магічні змови ми тільки що бачили на екрані. Але ми насправді повинні піти більш аркан досі. Спочатку потрібно перевести код що ми пишемо в машинний код. І пам'ятайте з минулого тижня, що машини, по крайней мере, ті, які ми знаємо тут, в кінці дня тільки розуміти, нулі і одиниці. 

І, Боже мій, якби нам довелося писати ці нулі і одиниці насправді програми, це було б дуже, дуже швидко прийняти задоволення від чого-небудь. Але виявляється, за останній тиждень, що ці моделі нулів і одиниць просто мають особливе значення. У деяких контекстах, вони можуть означати число. 

У деяких випадках, вони можуть означати літери, або кольору, або будь-яку кількість інших абстракцій там на. Але так само, як ваш комп'ютер має центральний процесор, центральний процесор, або мізки всередині вашого комп'ютера. Це, як правило, Intel всередині, тому що це одна з найбільших компаній що робить процесори для комп'ютерів. 

Ну, процесори Intel і інші просто вирішили заздалегідь що деякі моделі нулів і з них означають конкретні речі. Деякі моделі нулів і одиниць означатиме, роздрукувати це на екран, або додати ці два числа, або відняти ці два числа, або перемістити цю частину даних з пам'ять мого комп'ютера тут, або будь-яку кількість інших дуже низького рівня, але в кінцевому рахунку, корисно, операції. Але, на щастя, ми, люди не збираються необхідно знати цей рівень деталізації. Справді, так само, як в минулий раз, коли ми абстрагується знову, і знову, і знову, Будівля з дуже низького рівня примітиви як нулів і одиниць до підвищення рівня понять як цифри і букви, і кольору, і багато іншого, так ми можемо як програмісти стояти на плечах інші, які приходять перед нами і використовувати програмне забезпечення, що і інші люди писали раніше us-- а саме програми називається компілятори. 

C є мовою, який як правило, складаються, що означає перетворені з Вихідний код в машинний код. Зокрема, це означає, що в тому, що якщо у вас є своє джерело код, який ви самі пишете, як ми скоро буде через мить на екрані, і ви хочете, щоб перетворити його в кінцевому рахунку, до машини code-- ці нулі і одиниці, які тільки ваш Mac або ваш комп'ютер understands-- ви отримали перший годувати цей вихідний код в якості вхід в спеціальний Програма під назвою компілятор, вихід якого ми побачимо це машинний код. І, дійсно, в минулий раз ми говорили о, насправді, в кінці кінців, вирішення проблем. У вас є входи. І у вас є виходи. І у вас є якісь алгоритму в середині. 

Алгоритми можуть бути, звичайно, реалізовані в програмному забезпеченні, як ми бачили з псевдокоду минулого тижня і, як ми побачимо, з фактичним кодом цього тижня. І тому компілятор насправді просто має набір алгоритмів всередині про це, що знають, як перетворити спеціальні ключові слова, як основний, і Printf, та інші, які ми просто побачив в узорах і нулів ті, що Intel всередині і інші процесори насправді розуміє. Так як же ми це робимо? Звідки ми отримуємо компілятор? 

Більшість з нас тут є Mac або ПК. І ви працюєте Mac OS, або Для Windows або Linux або Solaris, або будь-яку кількість інших операційні системи. І дійсно, ми могли б вийти на мережу і завантажити компілятор для вашого Mac або ПК для конкретної операційної системи. Але ми всі були б на різні сторінки, так би мовити. Ми повинні були б трохи різні конфігурації. І речі не будуть працювати однаково. І, дійсно, в ці дні багато з нас не використовують програмне забезпечення, яке працює тільки на наших ноутбуках. Замість цього ми використовуємо щось як в браузері, дозволяє нам отримати доступ до веб- додатки в хмарі. А пізніше в цьому семестрі, ми будемо робити саме це. Ми будемо писати програми або програмного забезпечення з використанням code-- НЕ C, але й інші мови, такі як Python і JavaScript--, які працюють в хмарі. 

І зробити це, ми самі протягом семестру буде насправді використовувати хмара основі Серед відомих як CS50 IDE. Це веб-програмування охорона навколишнього середовища, або комплексний розвиток среда, язь, який побудований на вершині деяких Програмне забезпечення з відкритим вихідним кодом під назвою Cloud 9. І ми зробили деякі педагогічні спрощень до нього з тим, щоб приховати певні риси перші тижні, які нам не потрібні, після чого ви можете розкрити їх і зробити більшість все, що ви хочете з навколишнім середовищем. 

І це дозволяє нам, теж, щоб попередньо встановити певному програмному забезпеченню. Такі речі, як так званий CS50 бібліотека, яку ми скоро побачимо дає нам в C з деякими додаткові функціональні можливості. Так що якщо ви йдете, в кінцевому рахунку, CS50.io, Вам буде запропоновано увійти в систему, і як тільки ви робите, і створити рахунок безкоштовно, ви будете мати можливість отримання доступу до середовище, яке виглядає зовсім так. 

Тепер, це знаходиться в режимі за замовчуванням. Все красиво і яскраво на екрані. Багато з нас мають звичку працюючих на CS50 шматок, що це досить пізно в ніч. І ось деякі з вас могли б віддати перевагу перетворити його в нічний режим, якщо можна так висловитися. 

Але, в кінцевому рахунку, що ви збирається побачити в CS50 IDE є три різних areas-- область на лівій частині, де ваші файли будуть в хмара, область в правому верхньому куті де ваш код буде редагувати. Ви зможете відкрити окремі вкладки для будь-якої програми що ви пишете в цьому семестрі всередині цього у верхньому правому куті. І тоді самий arcanely, і тим не менше потужно, чи буде це бути на знизу відомий як вікно терміналу. 

Це стара школа Інтерфейс командного рядка, або CLI, що дозволяє виконувати команди на computer-- в даному випадку, комп'ютер в cloud-- робити такі речі, як скомпілювати код з вихідного коду в машинний код, запускати програми, або почати свій веб-сервер, або для доступу до бази даних, і будь-яку кількість інших методів що ми почнемо використовувати незабаром. Але щоб потрапити туди, ми збирається насправді є виходити в інтернет і почати грати. І зробити це, давайте спочатку почати майструвати з головною, і написати основну частину програми. І давайте використовувати цю функцію Printf, який ми використовували раніше, просто щось сказати. 

Так ось я вже всередині CS50 IDE. Я увійшов заздалегідь. І я повний скринінг вікно. І так, в кінцевому рахунку, ви теж в найближчі проблеми слідуватимуть аналогічні кроки, надасть документацію. Так що вам не потрібно турбуватися про поглинаючи кожен маленький технічний крок що я роблю тут сьогодні. 

Але ви отримаєте екран, як це. Я, трапляється в нічному режимі. І ви можете прикрасити все вгору шляхом відключення нічного режиму. І в кінці день, ви будете бачити ці три основних areas-- файлу браузер зліва, кодові вкладки нагорі, і вікно терміналу в нижній частині. 

Дозвольте мені йти вперед і написати свою першу програму. Я збираюся превентивно йти в файл, Зберегти та збережіть свій файл як hello.c. Дійсно, відповідно до угоди, будь-яка програма, яку ми пишуть, що написано на мові C повинен бути названий щось точка с, відповідно до угоди. Так що я збираюся назвати його hello.c, тому що Я просто хочу сказати привіт до світу. Тепер я збираюся збільшити , І натисніть кнопку Зберегти. І все, що я зараз тут вкладка в якому я можу почати писати код. 

Це не буде компілювати. Це нічого не означає. І тому навіть якщо я перетворив це нулів і одиниць, процесор матиме не Ідея, що відбувається навколо. Але якщо я пишу рядки, які відповідають з conventions-- C представляють собою С, в знову ж таки, це language-- з синтаксисом, як це, Printf привіт world-- і я маю отримали комфортно роблячи це протягом довгого часу. Так що я не думаю, що я зробив будь-які друкарські помилки. 

Але незмінно, найперший раз, коли ви зробите це, ви будете. І те, що я збираюся зробити, може дуже а не працювати для вас в перший раз. І це абсолютно нормально, тому що прямо зараз ви може просто побачити цілу багато новизни, але з плином часу, як тільки ви звикнете з цим середовищем, і ця мова, і інші, ви почнете бачити речі, які або правильно або неправильно. 

І це те, що навчання стипендіатів і звичайно помічники отримують так добре протягом довгого часу, є плямистість помилки або помилки в коді. Але я стверджую, що є немає помилок в цьому коді. Так що я тепер хочу, щоб запустити цю програму. 

Тепер на моєму власному Mac або PC, я в звичка подвійних ікон клацаючи коли я хочу, щоб запустити якусь програму. Але це не модель тут. У цьому середовищі, яка є CS50 IDE. Ми використовуємо операційну Система під назвою Linux. Linux нагадує інше операційна система, як правило, відомі в Unix. І Linux особливо відомий має командного рядка з навколишнього середовища, CLI. Тепер ми використовуємо специфічно смак Linux під назвою Ubuntu. І Ubuntu просто певна версія Linux. 

Але ці системи Linux в ці дні роблять насправді поставляються з графічним інтерфейсом користувача. І той, який ми, трапляється, використовувати тут веб-. Так що це може виглядати навіть трохи відрізняється від чогось Ви самі могли б мати бачив або запустити в минулому. 

Так що я збираюся йти вперед Зараз і зробіть наступне. Я зберіг цей файл як hello.c. Я збираюся йти вперед і Тип clanghello.c Так Clang для мови C є компілятор. Це попередньо встановлена ​​в CS50 IDE. І ви можете завантажити і абсолютно встановити це на вашому власному Mac або PC. 

Але, знову ж таки, ви б не все попередня конфігурація робиться для вас. Так що на даний момент, я просто збирається запустити clanghello.c. А тепер зверніть увагу цей синтаксис тут, в кінцевому рахунку розуміють, просто означає, що я перебуваю в папку або каталог з ім'ям робочого простору. Цей знак долара просто конвенція сенсу, введіть ваші команди тут. 

Це те, що називається швидке, просто за угодою є знак долара. І якщо я йду вперед зараз і натисніть Enter, нічого, здається, не відбулося. Але це насправді хороша річ. Чим менше, що відбувається на ваш екран, тим більше ймовірно, ваш код повинен бути правильним, по крайней мере, синтаксично. 

Так що, якщо я хочу, щоб запустити цю програма, що мені робити? Що ж, виходить, що ім'я за замовчуванням відповідно до угоди для програм, коли ви не вкажете Прізвище, ім'я, ваша програма просто a.out. І цей синтаксис теж, ви будете ознайомитися з раніше довго. 

Дот слеш просто означає, агов, CS50 IDE, запустіть програму під назвою a.out що всередині мого поточного каталогу. Це точка означає поточний каталог. І ми подивимося, що інші такі послідовності символів означає, незабаром. 

Так що тут ми йдемо, Enter, привіт світ. І ви помітите, що трапилося? Мало того, що це надрукувати привіт світ. Він також перемістив курсор на наступний рядок. 

І чому це було? Які символи ви бачите, який ми писали раніше що гарантував, що курсор буде перейти на наступний рядок? Забавно, що про комп'ютер це тільки збирається робити буквально те, що ви скажете їй зробити. 

Так що якщо ви скажіть йому PRINTF привіт, кома, пробіл, світ, близько цитати, це буквально тільки збирається друкувати ці символи. Але у мене був цей особливий характер в кінці, нагадаємо, зворотної косої п. І ось що забезпечило що персонаж пішов до наступного рядка екрану. 

Насправді, дозвольте мені піти і зробити це. Дозвольте мені йти вперед і видалити це. Тепер, зверніть увагу, що Верхня частина мого екрану є маленький червоне світло в вкладка із зазначенням, Гей, ви не зберегли файл. Так що я збираюся йти вперед з контролем S або команду S, збережіть файл. Тепер goes-- пішов на moment-- зелений. А тепер він повернувся до просто бути поруч значок. 

Якщо я тепер запустити clanghello.c знову, Enter, точка слеш, a.out, Enter, ви побачите, що вона як і раніше працює. Але це, можливо, трохи глючить. Зараз мій prompt-- робочий простір, а потім, що знак долара, а потім мій фактичний prompt-- все в тому ж рядку. Так що це, звичайно, естетична помилка, навіть якщо це насправді не логічна помилка. 

Так що я збираюся скасувати те, що я тільки що зробив. Я збираюся повторно запустити a.out. Зверніть увагу, я додав символ нового рядка назад. Я зберіг файл. 

Так що я збираюся повторно запустити a.out, і-- Прокляття, помилка, помилка, це означає помилку. Таким чином, помилка в тому, що незважаючи на те, Я додав зворотний слеш н там, повторно збережені, повторно запустив програму, поведінка було те ж саме. Чому б це? 

Я відсутній крок, чи не так? Це ключовий крок раніше було те, що у вас є коли ви, метою яких змінити вихідний код, виявляється також запустити це через компілятор знову так що ви отримаєте новий машинний код. І машинний код, нулі і одиниці, будуть майже ідентичні, але не зовсім так, тому що нам потрібно, звичайно, що нова лінія. 

Таким чином, щоб виправити це, я буду потребувати перезапускати clanghello.c, введіть, точка слеш, a.out. І тепер, привіт світ повернувся туди, де я очікую, що це буде. Так що це все прекрасно і добре. Але a.out це досить дурне ім'я для програма, навіть якщо це трапляється, з історичних причин, default-- означає монтажні виходи. 

Але дозвольте мені йти вперед тут і робити це по-різному. Я хочу, щоб мій привіт світ програма насправді можна назвати привіт. Так що, якщо б це був значок на моєму робочий стіл, він не буде a.out. Це буде називатися привіт. 

Таким чином, щоб зробити це, виявляється, що Clang, як і багато інших програм, підтримує аргументи командного рядка, або прапори, або перемикачі, які просто впливають на його поведінку. Зокрема, Clang підтримує тире O прапор, який потім займає друге слово. У цьому випадку, я буду як завгодно, але розумно, назвати це привіт. Але я міг би назвати це нічого Я хочу, за винятком того, що a.out б швидше до того ж точки. 

А потім просто вказати ім'я файлу я хочу зібрати. Так що тепер, навіть якщо на початку команди я до сих пір є Clang, в кінці команди Я до сих пір ім'я файлу, Тепер у мене є ці командного рядка аргументи, ці прапори, які говорять, ой, до речі, висновок-о, файл називається привіт, а не a.out за замовчуванням. 

Так що, якщо я вдарив Введіть зараз, нічого мабуть, сталося. І, тим не менше, тепер я можу зробити точковий слеш привіт. Так що це та ж програма. Нулі і одиниці ідентичні в кінці дня. 

Але вони в двох різні files-- a.out, яка є першою версією і просто по-дурному імені, і тепер алло, який є набагато більш переконливим назва програми. Але, якщо чесно, я ніколи пам'ятатиме це знову, і знову, і знову. І, насправді, як ми пишемо складніші програми, команди, які ви будете доведеться написати збираються отримати навіть Чим складніше ще. 

І так, щоб не хвилюватися. Виявляється, що люди, перш ніж ми зрозуміли, що вони занадто було це точно така ж проблема. Вони теж не отримали того, щоб типу досить довгі, загадкові команди, не кажучи вже пам'ятаю їх. І так люди перед нами зробили інші програми, які полегшують для компіляції програмного забезпечення. 

І справді, одним з таких Програма називається Make. Так що я збираюся йти вперед і робити це. Я збираюся скасувати всі, що я тільки що зробив такий спосіб. Дозвольте мені типу LS. І ви помітите три things-- a.out, і зірка, привіт і зірка, і hello.c. Будемо сподіватися, що це повинно бути трохи інтуїтивними, оскільки раніше було немає нічого в цьому робочому просторі. Там не було нічого, що у мене було створений, поки ми не почали клас. 

І я створив hello.c. Потім я скомпілював його, і назвав його a.out. А потім я скомпілював його знову злегка по-іншому і назвав його привіт. Тому у мене є три файли в цьому каталозі, в цій папці під назвою Workspace. Тепер я можу бачити, що а якщо я насправді зменшення зображення. 

Якщо я просигналити тут і дивитися на цю верхню праву руку кут, як і обіцяв лівий права частина екрану завжди збирається показати вам, що ваш обліковий запис, що всередині CS50 IDE. І є три файли там. 

Тому я хочу, щоб позбутися від a.out і привіт. І, як ви могли б уявіть собі інтуїтивно, вам може сортувати контрольної миші або натисніть правою кнопкою миші на цьому. І це маленьке спливаюче меню. Ви можете завантажити файл, запустіть вона, переглянути його, оновити, перейменувати, або що немає. 

І я міг би просто видалити, і він піде. Але давайте робити речі з командою лінія на даний момент, з тим, щоб отримати зручний з цим, і зробіть наступне. Я збираюся йти вперед і видалити a.out, ввівши буквально rma.out. Виявляється, команду для видалення або видалення щось, не видалити або видалити. 

Це більш лаконічно RM, щоб заощадити ви кілька натискань клавіш, і натисніть Enter. Тепер ми збираємося бути кілька загадково видалити регулярні a.out файл. Я дійсно не знаю, що таке нерегулярні файл буде ще. Але я хочу, щоб видалити його. 

Так що я збираюся ввести у для да. Або я міг би ввести його, і натиснути клавішу Enter. І, знову ж таки, нічого не здається, трапляється. Але це, як правило, хороша річ. 

Якщо я типу LS на цей раз, що я повинен бачити? Будемо сподіватися, що просто привіт і hello.c. Тепер, як в сторону, ви будете помітити цю зірку, зірочки, що це в кінці моїх програм. І вони також демонструють в зелений колір. Це просто спосіб CS50 середовища IDE з cluing вас в тому, що це не вихідний код. Це виконуваний файл, що запускається програма, яку можна реально працювати роблячи точковий слеш, а потім його ім'я. 

Тепер, дозвольте мені йти вперед і видалити це, гт привіт, Enter, видалити регулярні подати привіт, так. А тепер, якщо я типу LS, ми повернулися до hello.c. Намагайтеся не повністю видалити фактичний вихідний код. Незважаючи на те, є особливості вбудований в CS50 IDE де ви можете пройти через історію змін і тому в часі, якщо ви випадково видалити щось, робити мати на увазі відповідно до цих підказками так чи ні, від того, що ви насправді хочете зробити. І якщо я йду до вершини лівий кут тут, все, що залишається hello.c. Таким чином, є згустки інші команди, які ви може виконувати в світі Linux, один з яких, знову ж таки, зробити. І ми збираємося зробити моя програма в даний час в такий спосіб. 

Замість того щоб робити брязкіт, замість того, щоб робити брязкіт-о, Я збираюся просто в буквальному сенсі типу, зробити привіт. А тепер зверніть увагу, я Не друкує зробити hello.c. Я друкую зробити привіт. 

І ця програма зробити що поставляється з CS50 IDE і багато іншого як правило, з Linux, це програма, яка це збирається зробити програму під назвою Hello. І він збирається взяти на себе, за згодою, що якщо ця програма може бути зроблено, це буде зроблено з джерела код файл, який закінчується на дот с, hello.c. 

Так що, якщо я вдарив Enter Тепер, зверніть увагу, що команда, яка запускається на виконання насправді навіть більше до того, чим раніше. І це тому, що ми попередньо CS50 IDE, щоб мати деякі додаткові функції, вбудовані в тому, що нам не потрібно просто ще, але скоро буде. Але головне, щоб зрозуміти, Тепер у мене є програма Hello. 

Якщо я знову ввести LS, я є програма привітання. І я можу запустити його з точка слеш a.out, немає, так як весь сенс цього вправа була точка слеш привіт. А тепер у мене є свій привіт світ програма. Так рухатися вперед, ми майже завжди тільки збирається зібрати наші програми використовуючи команду Make. І тоді ми будемо запускати їх точка слеш, і назва програми. Але розумію, що робить робить для Ви, це сама не компілятор. Це просто програма зручності що знає, як викликати компілятор бігти так, що ви самі можете використовувати його. 

Які існують інші команди в Linux, і в свою чергу CS50 IDE? Ми скоро побачимо, що є Команда CD, Змінити каталог. Це дозволяє в лічені ваш інтерфейс командного рядка щоб рухатися вперед і назад, і відкрити різні папки без використання миші. 

LS ми бачили, який виступає за список файли в поточному каталозі. Зробіть Dir, ви можете ймовірно, починають виведення що вони означають now-- зробити каталог, якщо ви хочете створити папку. RM для видалити, RM Dir для видалити directory-- і вони, знову ж таки, це командний рядок еквіваленти того, що ви могли б зробити в CS50 IDE за допомогою миші. Але ви скоро знайдете що іноді це просто набагато швидше, щоб зробити речі з клавіатури, і в кінцевому рахунку набагато потужнішим. 

Але це важко стверджувати, що все, що ми робили досі це все, що потужні, коли все ми говорили є привіт світ. І справді, я жорстко закодував Слова вітання світ в моїй програмі. Там немає динамічність ще. Подряпина була на порядок цікавішим минулого тижня. 

І так давайте там. Давайте крок до що шлях деяких з цих функцій. Так що не тільки C поставляються з Printf, і грона інших функцій деякі з яких ми побачимо протягом довгого часу, це не має зробити все, що легко прямо воріт в отриманні введення даних користувачем. 

Насправді, одне зі слабких місць таких мов, як C, і навіть Java і ще інші, в тому, що вона не зробити його легко просто отримати такі речі, як цілі числа від користувачів або рядків, слів, і фрази, не кажучи вже про речі, як значення з плаваючою точкою, або дійсні числа з десятковими точками, і дійсно довгі числа, як ми скоро побачимо. Так що цей список функцій тут, ці , Як і інші шматочки головоломки до подряпин що ми попередньо встановлені в CS50 IDE, який ми будемо використовувати протягом декількох тижнів як тренувальні колеса різного роду, і в кінці кінців, прийняти їх, і дивитися під капотом, можливо, в як ці речі реалізуються. 

Але щоб зробити це, давайте насправді написати програму. Дозвольте мені йти вперед прямо зараз. І я збираюся створити нову файл, натиснувши на цю плюсик, і натиснувши кнопку New File. 

Я збираюся зберегти цей наступний один, як, скажімо, string.c, тому що я хочу, щоб грати з рядками. І рядок в C просто послідовність символів. Так що тепер давайте йти вперед і виконайте наступні дії. 

Включають в себе стандартні IO.h-- і виявляється стандартний введення-виведення, IO просто означає, що вхід і вихід. Так виходить, що ця лінія ось що є сусідній з нами, щоб використовувати Printf. Printf, звичайно, виробляє висновок. Тому для того, щоб використовувати Printf, виходить що Ви повинні мати цей рядок коду у верхній частині файлу. 

І ми повернемося до того, що що насправді означає незабаром. Виявляється, що в будь-яка програма C Я пишу, Я повинен почати це з код, який виглядає наступним чином. І ви помітите CS50 IDE і інше комплексний розвиток середовища, як він, намагатимемося як краще вони можуть закінчити свою думку. Насправді, хвилину назад, якщо я скасувати що я тільки що зробив, я вдарив Enter. 

Потім я потрапив відкритий фігурні дужка, натисніть Enter ще раз. І він закінчив свою думку. Це дало мені нову лінію, що не відступом не менше для хороших стилістичних причин, чому ми будемо бачити. І тоді він автоматично дав мені що фігурної дужки, щоб закінчити свою думку. Тепер, це не завжди вгадати, що ви хочете зробити. Але в більшій частині, це робить зберегти вам кілька натискань клавіш. Так що хвилину назад, ми запустили цей program-- привіт, світ, а потім він був скомпільований, а потім побіг. Але немає тут динамізм. Що робити, якщо ми хочемо робити щось інше? Ну, що якби я хотів насправді отримати рядок від користувача? Я збираюся використовувати шматок головоломки називається саме that-- отримати рядок. 

Виявляється, в C, що, коли ви не хочете внести свій вклад в шматок головоломки, або більш правильно до функції, ви буквально тільки що робити відкриває дужку, закриваючою дужкою. Так що, як ніби є немає білого ящика не вводити в. Скажімо блок перед тим була маленька біла коробка. У нас немає, що біла коробка прямо зараз. 

Але коли я називаю отримання рядки, я хочете помістити результат десь. Таким чином, дуже поширена парадигма в C є виклику функції, як тут отримання рядки, а потім зберегти його значення, що повертається. Це результат його зусилля в чомусь. 

А що таке побудувати в програмуванні, будь то в порожньому місці або в даний час C, що ми можна використовувати насправді зберігати що-небудь? Викликається це змінна, чи не так? А в порожньому місці, ми не дуже-то все одно, що відбувається в змінних. 

Але в даному випадку, ми насправді робимо. Я збираюся сказати рядок. І тоді я міг би назвати це все, що я хочу. Я буду називати його ім'я, отримує отримати рядок. 

І тепер, навіть якщо ви трохи новачок в цьому, зверніть увагу, що я не вистачає якоїсь деталі. Я забув крапка з комою. Мені потрібно, щоб закінчити цю думку. Так що я буду рухати курсор, і вдарив коми там. І що я тільки що зробив? У цьому рядку коду, номер 5 в даний момент, Я дзвоню отримання рядки без будь-яких входів. Так що немає маленький білий як коробка Зберегти блок має. 

Я просто кажу, агов, комп'ютер, отримати мені рядок. Знак рівності не надто знак рівності, саме по собі. це призначення оператор, а це означає, агов, комп'ютер, перемістити значення з правої сторони на ліву. А зліва, у мене є наступне. 

Гей, комп'ютер, дайте мені string-- послідовність символів. І називати цей рядок імені. І я навіть не називати його імені. 

Я міг би назвати це, умовно, щось на зразок S, так само, як ми використовували, щоб я виклику змінної I. Але тепер мені потрібно зробити щось з ним. Було б досить нерозумно спробуйте скомпілювати цей код, біг ця програма, не дивлячись на те, Я отримую рядок, тому що це ще тільки збирається сказати привіт світ. 

Але що, якщо я хочу, щоб змінити це. Чому б мені не зробити це? Відсоток s, кома s. І це трохи загадковими досі. 

Отже, дозвольте мені зробити мої змінні більш ясним. Дозвольте мені назвати ім'я цієї змінної. І давайте подивимося, якщо ми не можемо дражнити крім того, що тут відбувається. 

Так що на лінії п'ять, я отримую рядок. І я зберігати цей рядок, незалежно від того, як користувач ввів на його клавіатурі, в змінної з ім'ям Name. І виходить, що Printf не просто прийняти один аргумент в два рази котирування, один вхід в подвійних лапках. 

Це може зайняти два, або три, або більше, наприклад що другий, або третій, або четвертий, всі імена змінних, або конкретно цінності, що планується отримати доступ до, динамічно, цей рядок в лапках. Іншими словами, те, що було б неправильно з цим? Якщо я тільки що сказав привіт ім'я, зворотний слеш п, врятував мій файл, складений мій код, і побіг це, що б сталося? 

Це просто буде сказати, привіт ім'я, в буквальному сенсі N-А-М-Е, який певною мірою нерозумно, тому що вона нічим не відрізняється від світу. Так що нічого в лапках то, що буквально роздрукована. Так що, якщо я хочу мати заповнювач там, Я насправді потрібно використовувати якийсь особливий синтаксис. І виходить, якщо ви читаєте документація для функції PRINTF, він скаже вам, що якщо ви використовуєте відсотка с, ви можете замінити значення наступним чином. 

Після коми після цього подвійні лапки, ви просто напишіть назву з змінна, яку ви хочете підключити в цей формат коду або специфікатор формату, відсотків s для рядків. І тепер, якщо я зберіг мій файл, Я повертаюся вниз до мого терміналу. І я типу Make String, тому що, знову ж таки, назва цього файл, який я вибрав, перш ніж це string.c. 

Так що я збираюся сказати, зробити рядок, введіть. О боже мій, подивися на все помилки, які ми зробили вже. І це is--, що це насправді як, сім програм шести лінії? Так що це, де це може дуже швидко отримати переважна. 

Це вікно терміналу має тепер просто виплюнув величезну кількість повідомлень про помилки. Звичайно, у мене немає більше помилка повідомлень, ніж у мене є рядки коду. Так що ж відбувається? 

Ну, найкраща стратегія робити в будь-який час ви дійсно стикаються з переважною Список помилок, як, що, буде прокрутити назад, шукати команди ви просто побіг, що в моєму випадку це зробити рядок. Подивіться, що роблять зробив, і це що довго Clang команда, немає нічого особливого там. 

Але червоний погано. Зелений намагається бути ніжний і корисно. Але це все-таки погано, в цьому випадку. Але де ж це погано? 

String.c, лінія п'ять, п'ять символів. Так що це просто загальне угоду. Щось значить щось двокрапка номер рядка і номер символу. Помилка, використання неоголошена Ідентифікатор рядка. Можливо, ви мали на увазі стандарт? 

Так що, на жаль, Clang намагається бути корисним. Але це не так, і в цьому випадку. Ні, Clang, я не мав на увазі стандартне введення-виведення. Я мав на увазі, що на першій лінії, так. 

Але лінія п'ять це один тут. І Clang НЕ розуміти, S-T-R-I-N-G. Це неоголошений ідентифікатор, A Слово це просто ніколи не бачив раніше. І це тому, що C, мова ми пишемо код прямо зараз, немає змінних, званих рядками. 

Це не станеться, за замовчуванням, підтримка то, що називається рядок. Це CS50 шматок жаргон, але є досить умовним. Але я можу виправити це в такий спосіб. 

Якщо додати один рядок коду у верхній частині цієї програми, включають CS50.h, який є інший файл десь всередині CS50 IDE, десь на жорсткому диску, так би мовити, операційної системи Ubuntu що я біжу, що це файл, який збирається вчити операційної Система яка рядок, просто як стандартний io.h є файл в операційній системі, що це вчитиму його, що Printf є. 

Дійсно, ми отримали б дуже схоже повідомлення якщо IO визнав стандарт Io.h і намагався використовувати Printf. Так що я збираюся йти вперед і просто взяти під свій контроль L, щоб очистити екран. Або ви можете ввести ясно, і він буде просто очистити вікно терміналу. Але ви все ще можете прокручувати назад в часі. 

І я буду перезапускати Зробити String. Хрест мої пальці на цей раз, Enter. Боже мій, це спрацювало. він показує мені довгу маскувальну команду тобто те, що робить генеруватися за допомогою Clang, але ніяких повідомлень про помилки. Так розуміють, незважаючи на те, ви можете отримати повністю завалені кількість повідомлень про помилки, він просто може бути це дратує каскадних ефект, де Clang не розуміє одна річ, яка означає, що він тоді не розуміє наступне слово, або наступний рядок. А так він просто задихається від вашого коду. Але виправлення може бути простим. І так завжди зосереджені на Найперша рядок виводу. І якщо ви цього не зробите зрозуміти це, просто подивіться для ключових слів, які могли б бути ключі і номер рядка, і характер, де ця помилка може бути. 

Тепер дозвольте мені йти вперед і ввести точка слеш, рядок, введіть. Хм, це не привітавшись нічого. Чому? Ну, пам'ятаєте, де він працює? 

Це, ймовірно, застряг в даний момент в циклі, якщо ви будете, на шостому рядку, тому Отримати рядок дизайн, написані співробітниками CS50, буквально означало просто сидіти там чекає, і чекає, і очікування рядки. Все, що ми маємо на увазі під рядком введення є людина. Таким чином, ви знаєте, що? Дозвольте мені йти вперед. І тільки з натхнення, дозвольте мені введіть своє ім'я, Девід, введіть. Тепер у мене є більш динамічною програми. Він сказав, привіт Девід. 

Якщо я йду вперед і запустити це знову, дозвольте мені спробувати сказати ім'я Zamila, введіть. І тепер у нас є динамічна програма. Я не жорстко закодовані світ. Я не жорстко закодовані ім'я, або Девід або Zamila. 

Тепер це набагато більше схоже програм ми знаємо, де, якщо приймати вхідний сигнал, він виробляє дещо інший висновок. Тепер, це не найкращий досвід користувача або UX. Я запустити програму. 

Я не знаю, що я повинен робити, якщо я насправді не дивитися на або запам'ятати вихідний код. Так давайте користувачеві досвід трохи краще з найпростіших речей. Дозвольте мені повернутися в цей програми, а просто сказати Printf. 

І дозвольте мені йти вперед і сказати ім'я, двокрапка, і простір, а потім крапка з комою. І якраз для стусанів, не люфтить н. І це навмисне, тому що я не хочу запрошення, щоб перейти до наступного рядка. 

Я хочу, замість того, зробити це, зробити рядок перекомпіліровать свій код в нову машину Код точка слеш рядок. Ах, це набагато симпатичніше. Тепер я насправді знаю, що комп'ютер хоче, щоб я, дати йому ім'я. 

Так що я збираюся йти вперед і ввести в Робі, увійти, і привіт, Роб. Таким чином, розуміють, що це до сих пір, в кінці дня, тільки програма дев'ять ліній. Але ми зробили ці кроки дитини. 

Ми написали один рядок, з якою ми були знайомі, Printf, привіт світ. Тоді ми розстебнула трохи цього. І ми насправді використовували отримання рядка. І ми кинули це значення в змінній. А потім ми пішли вперед і вдосконалюватися Крім того, він з третьою лінією. І цей процес, що повторюється написання програмного забезпечення є дійсно ключем. У CS50, так і в житті в цілому, Ви повинні, як правило, не сісти, мають на увазі програму, і спробуйте писати вся чортівня все відразу. 

Це неминуче буде призводити до шляху більше помилок, ніж ми самі бачили тут. Навіть я, і до цього дня, постійно робити інші дурні помилки, насправді складніше помилки що важче з'ясувати. Але ви будете робити більше помилок, тим більше рядків коду ви пишете все відразу. І тому ця практика, написати трохи коду що ви комфортно, компілювати це, запустити його, протестувати його в більш загальному плані, потім проведіть on-- так само, як ми тримали відводами і відводками минулого тижня, будівництво від чогось дуже просто щось більш складне, зробити те ж саме тут. Не сідайте, і спробувати написати цілу проблему. Насправді ці кроки дитини. 

Тепер, рядки не всі що корисно їм самим. Ми б насправді, в ідеалі, як і в є дещо ще в нашому інструментарії. Так що давайте насправді зробити саме це. 

Дозвольте мені йти вперед зараз і нагнітати трохи інша програма. І ми будемо називати цей int.c, для цілого числа. Я збираюся, так само, включають CS550.h. Я збираюся включати стандартні IO. І це буде досить поширеним в ці перші кілька днів класу. 

І я буду готовий сам з основною функцією. І тепер замість того, щоб отримати рядок, давайте йти вперед і отримати Int. Давайте назвемо це я і називаю це отримати INT, близькі круглі дужки, крапка з комою. А тепер давайте зробимо щось з ним, Printf. 

Скажімо, щось на кшталт привіт, зворотна коса п, кома я. Так що я в значній мірі імітуючи що я зробив тільки хвилину назад. У мене є заповнювач тут. Я кома я тут, тому що я хочу для підключення I в цей заповнювач. 

Так що давайте йти вперед і спробувати компіляції цієї програми. Файл називається int.c. Так що я збираюся сказати, зробити Int, введіть. Боже мій, але не велика справа, чи не так? Там помилка. 

Там в синтаксичну помилку ось така, що програма не може складатися всередині int.c, лінії сім, символ 27, формат помилка визначає тип напівкоксу зірка, що б це ні. Але тип аргументу Int. 

Так що тут теж, ми не збираємося, метою яких навіть якщо сьогодні багато матеріалу, ми будемо придушувати вас з абсолютно кожен ознака C, і програмування в більш загальному сенсі, всього за ці перші кілька тижнів. Так що часто буде жаргон з якими ви не знайомі. І справді, символ зірки щось ми збираємося повернутися до протягом тижня або часу до двох. 

Але зараз, давайте подивимося, якщо ми можемо розібрати слова, які знайомі. Formats-- так що ми чули формат специфікатор, код формату раніше. Це знайоме. Type-- але аргумент має тип Int. Зачекайте, я це Int. 

Може бути, насправді відсотків s має деякий певний сенс. І дійсно, це робить. Ціле число, якщо ви хочете PRINTF, щоб замінити його, ви насправді потрібно використовувати інший формат специфікатор. І ви не знали б це якщо хтось сказав вам, або ви зробили це раніше. Але відсотків я є що може бути широко використовується в Printf для підключення цілого. Ви можете також використовувати відсоток d для десяткового цілого числа. Але я просто і красиво тут. Таким чином, ми будемо йти з цим. 

Тепер дозвольте мені йти вперед і перекладка марка INT, Enter. Це не добре, ніяких помилок. Дот слеш int-- OK, поганий користувальницький досвід, тому що я не сказав собі що робити. Але це нормально. Я швидко завойовують. 

А тепер дозвольте мені йти вперед і ввести Давида, OK, Zamila, Роб. ОК, так що це хороша річ. На цей раз, я використовую функцію, головоломка шматок, який називається Get Int. І виходить out-- і ми см це пізніше в term-- персонал CS50 здійснив отримати рядок таким чином, що вона буде тільки фізично отримати рядок для вас. 

Він реалізований в Int Отримати таким чином, що це буде тільки отримати ціле число для вас. І якщо ви, людина, не співпрацюють, це буквально тільки збирається сказати, повторіть, повторіть, повторіть, буквально сидів там зациклення, поки ви зобов'язують з якимось магічним числом, як 50, і привіт 50. 

Або, якщо ми виконаємо це знову і тип в 42, 42 привіт. І тому функція Get INT всередині цього шматок головоломки досить логіки, досить думка, щоб з'ясувати, що таке слово? А що таке число? Тільки прийняття, в кінцевому рахунку, цифри. 

Так виходить, що це не всі, що виразно. так далеко. Так, яй, останній раз, коли ми пішов досить швидко в виконавців ігр та анімації, і художні твори, в порожньому місці. І ось, ми задовольняючись з привіт світ, і привіт 50. 

Це не все, що надихає. І дійсно, ці перші кілька приклади займе якийсь час сповзати в хвилюванні. Але у нас є так багато більше контролювати зараз, насправді. І ми будемо дуже швидко почати відводами на верхній частині цих основних примітивів. 

Але по-перше, давайте розберемося які обмеження. Насправді, одна з речей, Подряпини не легко давайте зробимо це реально дивитися під капотом, і зрозуміти, що комп'ютер, що він може зробити, і які його обмеження. І дійсно, що відсутність розуміння, потенційно, довгострокове може привести до нашої власної mistakes-- письмовій формі помилок, написання небезпечного програмного забезпечення, отримує зламали в деякому роді. 

Отже, давайте деякі кроки в напрямку розуміючи це трохи краще спосіб, скажімо, такий приклад. Я збираюся йти вперед і реалізувати реальний швидкий програма під назвою Adder. Мовляв, давайте додамо деякі цифри разом. І я збираюся кодувати деякі кути тут, і просто скопіювати і вставити де я був раніше, просто так що ми можемо почати працювати раніше. Так що тепер у мене є основні засади програми під назвою Adder. 

І давайте йти вперед і робити це. Я збираюся йти вперед і скажімо, IntX отримує отримати Int. І ви знаєте, що? Давайте зробимо кращий користувальницький досвід. 

Так що давайте просто скажемо х, і ефективно підказати користувачу, щоб дати нам х. А потім дайте мені йти вперед і сказати, Printf як щодо у є, на цей раз чекаючи два значення від користувача. А потім давайте просто йти вперед і скажімо, Printf, сума х і у. А тепер я не хочу робити відсотків с. Я хочу зробити відсоток I, зворотної косої межі п, а потім підключити значення суми. 

Так як я можу йти про це? Знаєш, що? Я знаю, як використовувати змінні. Дозвольте мені просто оголосити новий, Int р 

І я збираюся зробити припущення тут. Якщо є рівні знаки в цьому мова, може бути, я просто не можу зробити х плюс у, до тих пір, як я закінчу свою думав з коми? Тепер я можу повернутися сюди, підключити г, закінчити цю думку з коми. І давайте подивимося тепер, якщо вони послідовності lines-- х, це отримати Int. Y це отримати Int. 

Додати х і у, зберігають значення в z-- так, знову ж таки, пам'ятайте, знак рівності не дорівнює. Це призначення справа наліво. І давайте друкувати, що сума х і у не буквально г, але що всередині м Так давайте зробимо Adder - не гарно, ніяких помилок в цей раз. Дот слеш Adder, введіть, х буде 1. 

Y буде 2. А сума х і у дорівнює 3. Так що це все прекрасно і добре. 

Таким чином, ви б собі уявити, що математику повинні працювати в програмі, як це. Але ви знаєте, що? Чи є ця змінна, рядок 12, навіть необхідно? Вам не потрібно, щоб стати звичкою просто зберігання речей в змінних тільки тому, що ви можете. І справді, це як правило, вважається поганою дизайн якщо ви створюєте змінну, називається Z в цьому випадку, зберігання щось в ньому, а потім відразу ж використовуючи його, але ніколи. Навіщо давати щось ім'я як г, якщо ви в буквальному сенсі збирається використовувати це предмет тільки один раз, і так проксимальніше де ви створили це, в першу чергу, так близько з точки зору рядків коду? Таким чином, ви знаєте, що? Виявляється, що C є досить гнучким. Якщо я насправді хочу плагін значень тут, Мені не потрібно, щоб оголосити нову змінну. Я міг би просто плагін х плюс у, тому що розуміє, C арифметичні і математичні оператори. 

Так що я можу просто сказати, це зробити математику, х плюс у, якими б ці значення, підключіть результуючий ціле число в цьому рядку. Таким чином, це могло б бути, якби тільки один рядок коротше, кращий дизайн, краща програма, тому що там менше коду, тому менше для мене зрозуміти. І це також просто чистіше, остільки, оскільки ми не вводячи нові слова, нові символи, як і г, навіть якщо вони насправді не служити багато цілі. 

На жаль, математика не є все, що надійні іноді. Давайте йти вперед і робити це. Я збираюся йти вперед Зараз і зробіть наступне. 

Давайте зробимо Printf, відсоток I, плюс відсоток я, повинно бути відсотків я, зворотна коса п. І я збираюся зробити this-- хух плюс у. Так що я просто хочу переписати це трохи по-іншому тут. Дозвольте мені зробити швидку перевірку осудності. Знову ж таки, давайте не будемо забігати вперед. Зробити акумулятор, точка слеш гадюка. х дорівнює 1, у 2, 1 плюс 2 дорівнює 3. Так що це добре. Але давайте ускладнити це зараз трохи, і створити новий файл. 

Я буду називати цей, кажуть, Інтс, множина для цілих чисел. Дозвольте мені почати, де я був хвилину тому. Але тепер давайте зробимо кілька інших ліній. Дозвольте мені йти вперед і робити наступне, Printf, відсоток я, мінус відсоток я, це відсоток я, кома х, кома двох мінус у. Так що я трохи роблю інша математика там. Давайте зробимо ще один. Таким чином, відсоток I рази відсотків я це відсоток я, зворотна коса п. Давайте плагін х і у, і х раз у. Ми будемо використовувати зірочку ваш комп'ютер протягом часу. 

Вам не потрібно використовувати х. х ім'я змінної тут. Ви можете використовувати зірку для множення. Давайте зробимо ще один. Printf відсотка I, розділити на відсоток I, є відсоток я, зворотна коса п. ху, поділена на y-- так що ви використовуєте слеш в C зробити поділ. І давайте зробимо один одного. Remainder відсотка I, розділений на відсоток I, є відсоток я. xy-- і тепер залишилося це те, що залишилося. При спробі поділу знаменника в чисельник, скільки залишилося над цим Ви не могли б розділити поза домом? 

Так що не дуже, обов'язково, символ ми використовували в початковій школі для цього. Але є в C. Ви можете кажуть х по модулю у, де цей знак відсотка в цьому context-- коли ви смутно перебуваєте всередині подвійних лапках, всередині від Printf, відсотків використовується в якості специфікатор формату. 

При використанні відсотків за межами що в математичному вираженні, це оператор по модулю для модульного arithmetic-- для наших цілей тут, просто означає, що таке Інша частина х ділиться на у? Так х ділиться на у є х слеш у. Що решта ділиться на х у? Це х мод у, як програміст міг би сказати. 

Так що, якщо я не зробив жодної помилки тут, дозвольте мені йти вперед і зробити Інтс, множина, приємно, і точка слеш Інтс. І давайте йти вперед і робити, скажімо, 1, 10. Добре, 1 плюс 10 дорівнює 11, перевірка. 1 мінус 10 негативний 9, перевірте. 

1 раз в 10: 10, перевірка. 1 ділиться на 10 is-- Добре, ми пропустимо що один. Залишок 1 ділиться на 10 дорівнює 1. Це правильно. Але є помилка тут. 

Таким чином, той, який я кладу здати, неправильно. Я маю на увазі, що це близько до 0. 1 ділиться на 10, ви знаєте, якщо ми різання деякі кути, звичайно, це нуль. Але це повинно бути дійсно 1/10, 0,1 або 0,10, 0,1000, чи щось таке. 

Вона не повинна дійсно бути дорівнює нулю. Що ж, виходить, що комп'ютер робити буквально те, що ми сказали це зробити. Ми робимо математику як х, поділене на у. І обидва х і у, на лінії коду раніше, є цілими числами. 

Крім того, по лінії 15, ми кажучи Printf, агов, Printf плагін ціле число, вставною ціле число, плагін в integer-- спеціально х, а потім у, а потім х ділиться на у. х і у Інтс. Ми там добре. 

Але що х ділиться на х? х ділиться на у і має бути, математично, 1/10, або 0,1, яка представляє собою дійсне число, дійсне число маючи, потенційно, десяткову точку. Це не є цілим числом. 

Але те, що найближче ціле число, 1/10, або 0,1? Так, це свого роду дорівнює нулю. 0,1, як це багато. І 1 це багато. Таким чином, 1/10 ближче до 0, ніж до одного. 

І так, що C робить для us-- вид, тому що ми сказали це, метою яких є усічення, що ціле число. Він приймає значення, що знову-таки є має бути щось на зразок 0,1000, 0 і так далі. І це все, що усічення після десяткового дробу так що все це матеріал, тому що це не вписується в поняття цілого числа, що це просто число, як негативний 1, 0, 1, вгору і вниз, він відкидає всі після десяткового дробу, тому що ви не може відповідати десяткову точку в ціле число, за визначенням. 

Таким чином, відповідь тут дорівнює нулю. Так як же ми це виправити? Нам потрібно інше рішення все разом. І ми можемо зробити це в такий спосіб. 

Дозвольте мені йти вперед і створити новий Файл, на цей раз називається floats.c. І зберегти його тут, в той же каталог, float.c. І дозвольте мені йти вперед і скопіювати частина цього коду з раніше. 

Але замість того, щоб INT, давайте зробимо це. Дайте мені значення з плаваючою комою називається х. де з плаваючою точкою значення тільки в буквальному сенсі щось з плаваючою точкою. Він може переміщатися вліво, вправо. Це дійсне число. 

І дозвольте мені не називати отримати Int, але отримати з плаваючою точкою, який також був одним з меню опцій в бібліотеці C250. Давайте змінимо у до поплавця. Так що це буде отримати з плаваючою точкою. 

А тепер, ми не хочемо, щоб підключити Інтс. Виявляється, ми повинні використовувати відсотків е для поплавка, відсоток F для поплавка, і тепер зберегти його. А тепер, схрестивши пальці, зробіть поплавці й красиво, точка слеш поплавці. х буде одним 1. у Буде 10 разів. 

І, добре, добре моє додаток є правильним. Я сподівався на більше, але я забув написати. Так що давайте йти і виправити цю логічну помилку. 

Давайте йти вперед і захопити наступне. Ми просто робимо трохи копіювання і вставки. І я хочу сказати, мінус. 

І я хочу сказати, раз. І я хочу сказати, розділилися. І я не буду робити по модулю, яка не є, як релевантний тут, ділиться на F, і раз plus-- Добре, давайте зробимо це знову. 

Зробити поплавці, точка слеш поплавці, і 1, 10, і-- добре, немає, ОК. Так що я ідіот. Так що це дуже поширена в інформатиці щоб зробити дурні помилки, як це. 

Для педагогічних цілей, що я дійсно хотів зробити був змінити науку тут на плюс, в мінус, до часів, і розділити, як ви, сподіваюся, помітили під час цієї вправи. Отже, тепер давайте заново скомпілювати Програма, робити точкові слеш поплавці. 

І в третій раз, давайте побачити, якщо вона відповідає моїм очікуванням. 1, 10, введіть, так, добре, 1.000, розділений на 10000, це 0,100000. І виходить, що ми можемо контролювати, скільки цифри після цих знаків після коми. Ми насправді буде. Ми повернемося до цього. 

Але тепер, по суті, математика є правильним. Так що, знову ж таки, що винос тут? Виявляється, що в C, є не тільки strings-- і, насправді, Тобто не дуже, тому що ми додати ті, з бібліотекою CS50. Але є не тільки Інтс. 

Є також плаває. І виходить, купу інших даних типу також, що ми будемо використовувати незабаром. Виявляється, якщо ви хочете один характер, а не рядок символів, ви можете використовувати тільки символ. 

Виявляється, що якщо ви хочете, логічне значення, логічне значення, істина або брехня тільки, завдяки бібліотеці CS50, ми додається до C типу даних BOOL, а також. Але це також присутній в багатьма іншими мовами, а також. І виходить, що іноді вам потрібні великі цифри, а потім приходять за замовчуванням з Інтс і поплавками. 

І, по суті, подвійний ряд який використовує не 32 біта, але 64 біта. І довго довго це число, використовує не 32, біти, але 64 біта, відповідно, операцій з плаваючою крапкою значення і цілі числа, відповідно. Так що давайте насправді в даний час побачити це в дії. 

Я збираюся йти вперед тут і нагнітати одну іншу програму. Тут я збираюся йти вперед і не включають CS50.h. І дозвольте мені йти, включають в себе стандартні IO.h. 

І ви помітите щось фанки тут відбувається. Це не колірне кодування речі точно так же, як це було раніше. І виявляється, що це тому, що я не дали річ ім'я файлу. 

Я буду називати цей sizeof.c, і натисніть кнопку Зберегти. І зверніть увагу, що відбувається з моєю дуже білий код проти цього чорний фон. Тепер, принаймні є деякі фіолетові там. І це синтаксис виділений. 

Це тому, що досить просто, у мене є розповів, який тип файлу IDE це, даючи йому ім'я, і зокрема, розширення файлу. Тепер, давайте йти вперед і робити це. Я збираюся йти вперед і дуже просто роздрукувати following-- Ьоо це відсоток LU. 

Ми повернемося до що в мить. А потім я збираюся розмір друку BOOL. І тепер, щоб заощадити я якийсь час, я збирається зробити ціле букет з них відразу. І, зокрема, я збираюся змінити це до гольця і ​​голець. Це одне, я збираюся змінити до подвійний і подвійний. 

Це одне, я збираюся змінити до поплавця і поплавком. Це одне, я збираюся зміниться на Int і Int. А це, я збираюся щоб змінити довго довго. І він як і раніше бере довго, довго довго. 

І тоді, нарешті, я дав я занадто багато, рядок. Виявляється, що в C, є спеціальний оператор називається розмір, що буквально збирається, при запуску, скажіть нам розмір кожна з цих змінних. І це шлях, в даний час, ми можемо з'єднатися назад для обговорення на минулому тижні даних та подання. 

Дозвольте мені йти вперед і компілювати розмір точкового розміру Слеш. І давайте подивимося. Виявляється, що в C, зокрема, на CS50 IDE, зокрема, на Операційна система Ubuntu, який є 64-розрядної операційної Система в цьому випадку, логічне значення буде використовувати один байт простору. Ось як вимірюється розмір, не в бітах, а в байтах. І пам'ятайте, що один байт вісім біт. Так BOOL, навіть якщо ви технічно потрібно тільки 0 або 1, це трохи марнотратно як ми реалізували. Це насправді збирається використовувати весь byte-- так все нулі, є, можливо, всі ті, або щось подібне, або тільки один 1 з восьми бітів. 

Напівкоксу, тим часом, використовується для символу як символ Ascii за останній тиждень, буде один символ. І це синхронізується з нашим поняттям не будучи трохи більше 256 bits-- а, синхронізується з ним бути не довше, ніж 8 біт, що дає нам цілих 256 значень. подвійний збирається становить 8 байт або 64 біта. 

Поплавок 4. ІНТ 4. Довгий, довгий 8. І рядок 8. Але не турбуйтеся про це. Ми збираємося відігніть цей шар. Виявляється, рядки можуть бути довше 8 байт. 

І дійсно, ми написали рядки вже, привіт світ, більше, ніж 8 байт. Але ми повернемося до що в мить. Але заберіть тут полягає в наступному. 

Будь-який комп'ютер має тільки кінцеве обсяг пам'яті і простору. Ви можете тільки зберігати так багато файли на вашому Mac або PC. Ви можете тільки зберігати так багато програм RAM працює відразу, обов'язково, навіть з віртуальної пам'яттю, тому що у вас є обмежена кількість оперативної пам'яті. 

І тільки якщо picture-- ви ніколи не відкрили ноутбук або замовити додаткову пам'ять для комп'ютера, ви може не знати, що всередині вашого комп'ютера це те, що виглядає трохи як це. Так що це просто звичайна компанія під назвою Вирішальне значення, що робить оперативної пам'яті для комп'ютерів. І оперативна пам'ять, де програми жити в той час як вони працюють. 

Так що на кожному Mac або PC, при подвійному виберіть програму, і вона відкриває, і це відкриває якийсь документ Word, або щось подібне, він зберігає її на деякий час в RAM, оскільки оперативна пам'ять швидше ніж ваш жорсткий диск, або ваш твердотільний накопичувач. Так що це просто, де програми йдуть жити, коли вони працюють, або коли використовуються файли. 

Так що у вас є речі, які виглядають як це всередині вашого ноутбука, або трохи більше речей всередині вашого робочого столу. Але ключ у вас є тільки кінцеве число цих речей. І є тільки кінцеве кількість апаратне забезпечення, сидячи на цьому столі правою тут. 

Так що, звичайно ж, ми не можемо зберігати нескінченно довгих чисел. І, тим не менше, якщо ви думаєте, назад початкової школи, скільки цифр може ви повинні права з десяткового дробу? В цьому відношенні, скільки цифр може у вас є коду точки? Дійсно, нескінченно багато. 

Тепер ми, люди могли б тільки знаєте, як вимовляється мільйон, і мільярд, трильйон, і квадрильйонів і квінтильйонів. І я розширюють межі мого understanding-- або my-- Я розумію, цифри, але мій вимова чисел. Але вони можуть отримати нескінченно великий з нескінченно багато цифр зліва або праворуч від десяткового дробу. 

Але комп'ютери є тільки кінцеве кількість пам'яті, кінцеве число транзисторів, A кінцеве число лампочок всередині. Так що ж відбувається, коли ви біжите з космосу? Іншими словами, якщо ви думаю, що повернутися до минулого тижня коли ми говорили про цифри Самі представлені в двійковому вигляді, Припустимо, що у нас є це 8-бітове значення тут. 

І у нас є сім 1 і один 0. І припустимо, що ми хочемо додати 1 до цього значення. Це дійсно велике число прямо зараз. 

Це 254, якщо я пам'ятаю математика з минулого тижня справа. Але що, якщо я змінити що крайній праворуч від 0 до 1? Ціле число, з Звичайно, буде вісім 1-х. Таким чином, ми як і раніше добре. 

І це, ймовірно, представляє 255, хоча в залежності від контексту він може насправді представляють негативне число. Але про це іншим разом. Це почуття, що мова йде про настільки ж високо, як я можу розраховувати. 

Тепер, це тільки 8 біт. І мій Mac, звичайно ж, є шлях більше 8 біт пам'яті. Але у нього є кінцеве. Таким чином, той же аргумент застосуємо, навіть якщо ми мають більш з цих одиниць на екрані. 

Але що станеться, якщо ви зберігання цього числа, 255, і ви хочете вважати 1 трохи вище? Ви хочете перейти від 255 до 256. Проблема, звичайно, в тому, що якщо ви почати відлік з нуля, як минулого тижня, ви не можете розраховувати, як високий в 256, не кажучи вже про 257, не кажучи вже про 258, м, тому що відбувається, коли ви додаєте 1? Якщо ви робите стару початкову школу підхід, ви поклали 1 тут, а потім 1 плюс 1 дорівнює 2, але це насправді нуль, ви носите 1, нести 1, нести 1. Всі ці речі, ці 1, перейдіть до нуля. І вітер, так, як хтось вказав, що в 1 на лівій стороні. Але все, що ви можете насправді побачити і поміщається в пам'яті знаходиться всього в восьми 0, який повинен сказати, в якийсь момент, якщо ви, комп'ютер, судимий підрахунку досить високо, ви збирається обернути навколо, здавалося б, до нуля, або, може бути навіть негативним цифри, які навіть нижче нуля. 

І ми можемо роду побачити це. Дозвольте мені йти вперед і написати реальна швидка програма тут. Дозвольте мені йти вперед і написати програма під назвою переливу. Увімкніть CS50.h, включите стандарт IO.h-- про, Я дійсно пропустив мій підсвічування синтаксису. Так давайте збережемо це як overflow.c. 

А тепер головний INT void-- і до тих пір, ми будемо повернутися до пояснення, чому ми продовжуємо писати Int основну порожнечу. Але зараз, давайте просто робити вона, беручи його як само собою зрозуміле. Давайте дати собі Int, і форматувати його до 0. 

Давайте тоді зробити для Int я отримую zero-- насправді, давайте робити нескінченний цикл і подивитися, що відбувається. У той час як вірно, то давайте роздрукувати п це відсоток я, зворотна коса риска п, плагін п. Але тепер, давайте п отримує п плюс 1. 

Отже, іншими словами, на кожен ітерація цього нескінченного циклу, давайте розглянемо значення п, в і додати до нього 1, а потім зберегти результат в п на лівій стороні. І справді, ми вже бачили синтаксис трохи, як це, на короткий час. Прохолодний трюк натомість писати все це, ви можете сказати, п плюс дорівнює 1. 

Або, якщо ви дійсно хочете бути фантазії, Ви можете сказати, п плюс плюс крапка з комою. Але ці останні два просто то, що ми назвали б синтаксичний цукор для першої речі. 

Перше, що є більш явним, абсолютно нормально, абсолютно правильно. Але це частіше, я скажу. Таким чином, ми будемо робити це на мить. 

Давайте тепер зробити переповнення, яка звучить досить зловісно, ​​точка переповнення косою риси. Давайте подивимося, п стає досить великий. Але давайте подумаємо, наскільки велика може отримати п? 

п є Int. Ми бачили хвилину назад з розміром приклад, що INT чотири байти. Ми знаємо, що з минулого тижня, чотири байти є 32 біта, тому що в 8 разів 4, це 32. Це буде 4 млрд. 

І ми до 800,000. Це буде тривати вічно розраховувати так високо, як я, можливо, може. Так що я збираюся йти вперед, як ви могли б незабаром, і вдарив управління c-- відверто, контроль C, багато, де управління C в цілому засіб скасування. На жаль, так як цей працює в хмарі, бувало, що хмара впливів так багато речей, так багато виведення, він збирається зайняти деякий час для мого введення щоб дістатися до хмари. Так що, хоча я вдарив Контроль C кілька секунд тому, це, безумовно, сторона ефект нескінченного циклу. 

І тому в таких випадках, ми збирається залишити це бути. І ми збираємося додати ще вікно терміналу тут з плюсом, який, звичайно, не як це, так як він все ще думає. І давайте йти вперед і бути трохи більш розумним. 

Я збираюся йти вперед і робити це лише кінцеве число раз. Давайте використовувати цикл, які я згадував раніше. Давай зробимо це. Дайте мені іншу змінну Int я отримує 0. я менше, ніж, скажімо, 64 я ++. А тепер дозвольте мені йти вперед і друк з п відсотків я, кома п. І тоді це N-, до сих пір збирається взяти назавжди. Давай зробимо це. 

п отримує п раз 2. Або ми могли б бути фантазії і робити раз дорівнює 2. Але давайте просто скажемо, п одно сама по собі, раз 2. Іншими словами, в цьому Нова версія програми, Я не хочу чекати вічно від 800 000, як до 4 мільярдів. Давайте просто покінчимо з цим. 

Давайте насправді в два рази п кожен раз. Який, нагадаємо, є подвоєнням навпаки того, звичайно. І в той час як минулого тижня у нас є щось знову і знову, і знову, супер швидкий, Подвоєння, безумовно, отримати нас від 1 до найбільшої можливо значення, яке ми можемо розраховувати, щоб з міжнар. 

Так що давайте робити саме це. І ми повернемося до цього незабаром. Але це, знову ж таки, як і повтор блоку в порожньому місці. І ви будете використовувати це до тих пір. 

Це просто означає, що відлік від нуля до, але не рівні, до 64 років. І на кожній ітерації цього цикл, просто тримати збільшенням я. Так що я ++ - і ця загальна конструкція в рядку 7 це просто супер поширений спосіб повторювати кілька рядків код, кілька разів. Які рядки коду? Ці фігурні дужки, як ви можливо, почерпнуті тепер, означає, зробіть наступне. 

Це в такий подряпини, коли він має жовті блоки і інші кольори, вид прийняти або обіймають інші блоки. Ось що ці фігурні брекети роблять тут. Так що, якщо я отримав свій синтаксис right-- вас можна побачити символ морква в засобах C ось скільки разів я був намагаючись вирішити цю проблему. Так що давайте позбутися цього одного в цілому, і закрити це вікно. І ми будемо використовувати новий. Зробити переповнення, точка слеш Переповнення, Enter, все в порядку, це виглядає погано на перший погляд. Але давайте прокручувати назад в часі, тому що я зробив це 64 раз. 

І зауважте, в перший раз, п дорівнює 1. Другий раз, п = 2, потім 4, потім 8, потім 16. І мені здається, що як тільки Я отримую приблизно 1 млрд, якщо я знову подвоїти її, що повинен дати мені 2 мільярди доларів. Але виявляється, це прямо на порозі. 

І це насправді переливається INT з 1 млрд грубо негативне 2 млрд, так як ціле число, на відміну від чисел ми приймають на себе минулого тижня, може бути як позитивним, так і негативним насправді, і в комп'ютері. І так по крайней мере, один з тих, біти ефективно вкрадені. Таким чином, ми дійсно тільки 31 біт, або 2 мільярди можливих значень. 

Але на даний момент, їжа на будинок цілком просто, хоч би якими були ці цифри і незалежно від того математика, щось погане трапляється в кінці кінців, тому що в кінці кінців, ви намагаєтеся переставляють біти занадто багато разів. І ви ефективно перейти від всіх 1-х, може бути, все 0, або, може бути, просто якийсь інший моделі, що воно Очевидно, що в залежності від контексту, може бути витлумачено як негативне число. І ось, здавалося б, найвищий I може розраховувати в цій конкретній програмі складає всього близько 1 млрд. Але є часткове рішення тут. Знаєш, що? 

Дозвольте мені змінити з Int на довгий довго. І дозвольте мені йти вперед тут і say-- я буду мати щоб змінити це без знака довго. Або, давайте подивимося, я ніколи не пам'ятаю себе. 

Давайте йти вперед і зробити переповнення. Ні, це не так, ДНУ, спасибі. Так що іноді Clang може бути корисним. Я не пам'ятаю, який формат Специфікатор був довго довго. 

Але, насправді, Clang сказав мені. Зелений є свого роду добре, як і раніше означає, що ви зробили помилку. Це здогадуючись, що я мав на увазі LLD. 

Отже, дозвольте мені взяти це рада, довгий довгий десяткове число, крім того, що. І дозвольте мені знову запустити його, точка слеш переповнення, Enter. А тепер, що це круто це. 

Якщо я прокручую назад в часі, ми до сих пір почати вважаючи в той же place-- 1, 2, 4, 8, 16. Зверніть увагу, ми отримуємо все аж до 1 млрд. Але тоді ми благополучно дістатися до 2 млрд. 

Тоді ми отримаємо 4 млрд, потім 8 млрд, 17 млрд. І ми йдемо вище, і вище, і вище. Зрештою, це теж ламається. 

Зрештою, з тих пір довго, який є 64-бітове значення, а не 32-бітове значення, якщо вважати занадто високо, ви обтікати 0. І в цьому випадку, ми опинилися в кінцевому підсумку з негативним числом. 

Так що це проблема. І виходить, що це Проблема в тому, що не всі аркан. Навіть якщо я навмисно спонукало його з цими помилками, виходить, ми бачимо, що це начебто все навколо нас, або, принаймні, деякі з нас. 

Так що в Lego Star Wars, якщо ви коли-небудь грали в цю гру, виходить, ви можете ходити ламати речі в LEGO світі, і збирати монети, по суті. І якщо ви коли-небудь грали ця гра дуже багато часу, як це безіменного людини тут же, загальне число монет, які ви можете отримати це, здавалося б, 4 млрд. 

Тепер, коли він насправді закруглені. Так що LEGO намагався тримати речі дружнім до користувача. Вони не робили це точно від 2 до 32 потужності, за останній тиждень. Але 4 млрд причина. Здається, грунтуючись на цій інформації, що LEGO, і компанія, яка зробив це фактичне програмне забезпечення, вирішив що максимальна кількість монет користувач може накопичуватися це, по суті, 4 мільярди, тому що вони вибрали в своєму коді використовувати не довго довго, мабуть, але тільки ціле число, без знака ціле число, тільки натуральне число, чиї максимальне значення становить приблизно це. Ну, ось ще кумедний. Так що в грі Цивілізація, яка деякі з вас можуть бути знайомі з з'ясовується, що кілька років тому там була помилка в цій грі в результаті чого якщо ви грали роль Ганді в грі, замість нього був дуже пацифістом, замість того, щоб було неймовірно, неймовірно агресивний, в деяких обставинах. Зокрема, так, що цивілізація роботи є те, що якщо ви, гравець, прийняти демократію, ваш Агресивність оцінка отримує декрементируется на два, тому мінус мінус, а потім мінус мінус. 

Таким чином, ви відняти 2 з фактична ітерація. На жаль, якщо ваш ітерація є спочатку 1, і відняти від нього 2 після прийняття демократії Ганді, як тут може зробив, тому що він був дуже passive-- 1 за шкалою агресивності. Але якщо він приймає демократію, то він йде від 1 до негативного 1. 

На жаль, вони були за допомогою чисел без знака, що означає, що вони обробляють навіть негативним числа, як якщо б вони були позитивними. І виходить, що позитивний еквівалент негативного 1, в типових комп'ютерних програм, становить 255. Так що якщо Ганді приймає , І, отже, демократія його оцінка агресивності зменшилася, він насправді катається до 255 і робить його самим агресивний характер в грі. Таким чином, ви Google може на цьому. І це було, дійсно, випадкове програмування помилка, але це зовсім увійшов традиційні практичні знання досі. 

Це все весело і мило. Найстрашніше, коли фактична реального світу пристроїв, а не ігри, мають ті ж самі помилки. Насправді, лише рік тому стаття прийшла поза про Boeing 787 Dreamliner. 

І стаття в першій Погляд читає трохи Arcane. Але це сказав, програмне забезпечення Уразливість в Боїнг новий 787 Dreamliner струмінь має потенціал, щоб викликати пілотів втратити контроль над літак, можливо, в середині польоту, чиновники FAA попереджений авіакомпанії останнім часом. Це було визначення що модель 787 літак, який був включений безперервно протягом 248 днів може втратити все змінний струм, змінний струм, електрична потужність через генератора блоки управління, ГПА, одночасно входячи в відмовостійкий режим. Це, як я втратити. Але в меморандумі говориться, добре, тепер я отримав, що, стан був викликаний програмним забезпеченням протистояти внутрішнім по відношенню до управління генератором одиниці, які будуть переповнюватися 248 днів безперервної потужності. Ми випускаємо цей зверніть увагу, щоб запобігти втраті всього змінного електричного потужність, що може привести до у втраті контролю над літаком. 

Таким чином, в буквальному сенсі, є деяке ціле число, або деякий еквівалентний тип даних, використовується в програмному забезпеченні в реальному літаку що якщо ви тримаєте ваш літак досить довго, мабуть може бути в разі, якщо ви просто працюєте вони постійно і ніколи не від'єднавши ваш літак, здається, чи дозволяючи його батареї вмирають, в кінцевому підсумку підрахувати, і вгору, і вище, і вище, і вище, і вище. 

І, по природі, кінцеве кількість пам'яті переповниться, відкат нуль або деякий від'ємне значення, побічним ефектом якого є лякаюче реальна реальність що літак, можливо, буде потрібно бути перезавантажений, ефективно, або може впасти, що ще гірше, так як вона летить. Таким чином, ці види питань все ще з нами, even-- це було 2015 статті, все більше лякає коли ви не обов'язково розуміють, цінують, або передбачити ті види помилок. 

Так виходить, є ще одна Погана річ про подання даних. Виявляється, що навіть поплавці роду недоліки, тому що поплавці теж, Я запропонував 32 біта, або може бути 64, якщо ви використовуєте подвійний. Але це все-таки конечна. 

І улов в тому, що якщо ви можете покласти нескінченне число цифр після десяткового дробу, немає ніякого способу, ви може представляти всі можливі числа, які нас вчили в початковій школі може існувати в світі. Комп'ютер, по суті, повинен вибрати підмножина цих чисел для подання точно. 

Тепер, комп'ютер може раунд може бути, трохи, і може дозволити вам приблизно магазин будь-яке число, яке ви могли б можливо хотіти. Але тільки інтуїтивно, якщо ви мають кінцеве число бітів, ви можете тільки переставляти їх у багатьох кінцевих шляхів. Таким чином, ви не можете, можливо, використовувати кінцеве число перестановки бітів, шаблони нулів і одиниць, представляти нескінченне кількість чисел, який передбачає, що комп'ютери можуть бути дуже добре бути бреше нам іноді. 

Насправді, давайте зробимо це. Дозвольте мені повернутися в CS50 IDE. Дозвольте мені йти вперед і створити невелику програму називається Неточність, щоб показати, що комп'ютери, насправді, неточні. 

І дозвольте мені йти вперед і почати з деякі з цього коду з раніше, і тепер просто зробити наступне. Дозвольте мені йти вперед і робити PRINTF, відсоток е, зворотна коса п, 1 ділиться на 10. Іншими словами, давайте пірнати глибше 1/10, як 1 і ділиться на 10. Звичайно, комп'ютер може представляти 1/10. 

Так що давайте йти вперед і зробити неточностей. Давайте подивимося. Формат задає тип двічі. Але аргумент має тип Int. Що відбувається? 

О, цікаво, так це Урок, витягнутий з раніше. Я кажу, агов, комп'ютер шоу я поплавок з відсотками ф. Але я даю йому 2 Інтс. Так що виходить, що я можу виправити це кількома способами. 

Я міг би просто перетворити один в 1,0 і 10 в 10.0, яка, насправді, мати ефект перетворення їх в floats-- все ще сподіваюся, то ж число. Або виявляється, є дещо ми побачимо знову незабаром. Ви могли б кинути число. 

Ви можете, використовуючи цей вступними вираз, можна сказати, агов, комп'ютер, візьми 10, який я знаю, є Int. Але ставитися до неї, будь ласка, як ніби це поплавок. Але це відчуває себе надмірно складним. 

Для наших цілей сьогодні, давайте просто буквально роблять їх значення з плаваючою точкою з десятковою крапкою, як це. Дозвольте мені йти вперед і перекладка, зробити Неточність, добре, точка слеш Неточність, введіть. Добре, ми добре виглядати. 

1 ділиться на 10, відповідно до мого Mac тут, справді, 0,100000. Тепер, я викладав в початковій школі має бути нескінченне число 0 '. Отже, давайте принаймні спробувати щоб побачити деякі з них. Виявляється, що Printf трохи вправнішим, ніж досі ми використовували. Виявляється, ви не повинні вказувати тільки відсотків е, або просто відсотка я. Можна вказати насправді деякі опції управління тут. 

Зокрема, я збираюся сказати, агов, Printf, на самому ділі показати мені 10 знаків після коми. Так це виглядає трохи дивно. Але ви говорите, відсотків, Дот, скільки чисел ви хочете бачити після того, як десяткового дробу, а потім і для плоских, тільки тому, що це що говорить документація. Дозвольте мені йти вперед і врятувати. 

І зауважте теж, я отримую втомився від передруку речей. Так що я просто встановивши вгору і стрілка вниз на мої ключі тут. І якщо я продовжую бити, ви може бачити все команди що я зробив, чи неправильно зробив. 

І я збираюся йти вперед зараз і насправді не використовувати, що, мабуть. Зробити неточностей, точка слеш imprecision-- так чого мене вчили в клас школи перевіряє. Навіть якщо я друкую його до 10 десяткової ставить його, насправді, це 0,10000. Але ви знаєте, що? 

Давайте трохи жадібний. Скажімо, як, покажи мені 55 вказує після коми. Давайте дійсно прийняти це програмувати для обертання. Дозвольте мені переробити його з макіяж Неточність, точка слеш, неточностей. 

А ось і ми. Ваше дитинство було брехнею. Мабуть, 1 ділиться на 10, дійсно, 0.100000000000000005551115123-- 

Що відбувається? Що ж, виходить, якщо ви вид виглядають досить далеко в основний подання цього номер, він насправді неточно 1/10, або 0,1 і нескінченне число нулів. Тепер, чому це? 

Що ж, не дивлячись на те, що це просто число для нас, людей, 1 ділиться на 10, вона як і раніше один з нескінченно багато цифри, які ми могли б придумати. Але комп'ютер може представляти тільки кінцеве число так чисел. І так, по суті, те, що Комп'ютер показує нам є його найближчим наближення до числа ми хочемо вірити в 1/10, або дійсно 0,10000 нескінченності. 

Швидше за все, однак, це так близько, як він може отримати. І дійсно, якщо подивитися під капотом, як ми тут, дивлячись 55 цифр після коми, ми дійсно бачимо, що реальність. Тепер, як в сторону, якщо ви маєте коли-небудь бачив movie-- більшість з вас, ймовірно, haven't-- але Супермен 3 кілька років тому, Річард Прайор, по суті позикових коштів це на даний момент в його компанії, щоб вкрасти багато фракцій і фракцій гроші, тому що company-- як я пам'ятаю, це було while-- було по суті викидаючи все, що не вкладалося в поняття центів. 

Але якщо скласти всі ці крихітні, крихітні, крихітні числа знову, і знову, і знову, ви можете, як в його справу, зробити гарну суму грошей. 

Це та ж сама ідея була зірвані свіжіша, але до сих пір в даний час старше фільм, який називається Office Space, де хлопці в цьому фільмі, зробив те ж саме, напартачив повністю, в кінцевому підсумку з дуже багато грошей на банківському рахунку. Все це було дуже підозріло. Але врешті-решт, Неточність все навколо нас. 

І це теж може бути Лякає справу. Виявляється, що Супермен 3 і офісні приміщення в сторону, там може бути якийсь дуже реально світові наслідки реалії неточним представлення даних що навіть ми, люди, до У цей день не обов'язково зрозуміти, як ми повинні, або згадати, як часто, як ми повинні. І, дійсно, наступний кліп від погляду на якийсь дуже реальний світ Наслідки того, що станеться, якщо ви не цінують точностей, може статися в поданні чисел. 

[Відеовідтворення] 

-Комп'ютери, Ми всі прийшли, щоб взяти що часто засмучує проблеми, йти з them-- помилки, віруси, і програмні глюки, за невеликі ціни платити для зручності. Але в області високих технологій і високої швидкості військові та космічні програмні додатки, найменша проблема може височенним в лихо. 

4 червня 1996 року, вчені підготували щоб запустити безпілотний Ariane 5 ракети. На його борту науково супутники призначені щоб точно встановити, яким чином взаємодіє магнітне поле Землі з сонячними вітрами. Ракета була побудована для Європейське космічне агентство, і відірвався від свого об'єкта на узбережжі Французької Гвіани. 

-На Близько 37 секунд в політ, вони спочатку помітив, що щось відбувається не так. Форсунки були в поворотне шлях вони насправді не мають. Близько 40 секунд в польоті, ясно, що автомобіль був у біді. 

І ось, коли вони зробили рішення знищити його. Офіцер безпеки по висоті, з величезні кишки, натиснув на кнопку, підірвали ракету, перш ніж вона зможе стати загрозою для суспільної безпеки. 

-Це Була дівоче плавання на Ariane 5. І його руйнування взяв місце через помилки вбудовані в програмне забезпечення ракети. -The Проблема на Ariane була що існує число, потрібно 64 біт, щоб висловити. І вони хотіли, щоб перетворити це до 16-бітного числа. Вони припустили, що номер ніколи не збирався має бути дуже великим, що більшість з тих, цифри в 64-бітного числа були нулі. Вони були не праві. 

-The Нездатність одного програмне забезпечення, щоб прийняти вид номер, який генерується інший був в корені збою. Розробка програмного забезпечення стала дуже витратна частина нової технології. Ariane ракети були дуже успішним, так що велика частина програмного забезпечення створений для нього було також використовуваний в Ariane 5. 

-The Основна проблема полягала в тому, що Ariane 5 був швидше, прискорюється швидше. І програмне забезпечення не було доводилося за це. 

-The Знищення ракети була величезна фінансова катастрофа, все через помилку хвилин програмного забезпечення. Але це був не перший Проблеми перетворення даних про час мучило сучасної ракетної технології. 

-У 1991, с початком першої війни в Перській затоці, патріот Ракетний випробував подібного роду завдання перетворення число. І в результаті, 28 осіб, 28 американських солдатів, були вбиті, і близько 100 осіб отримали поранення, коли Patriot, який повинен був для захисту від вхідних бокоплавів, не вдалося вистрілити ракетою. 

-Коли Ірак вторгся в Кувейт, і Америку Буря в пустелі почав на початку 1991 року, Патріот ракетні батареї були розгорнуті щоб захистити Саудівську Аравію і Ізраїль від іракських ракетних атак Скад. Patriot є американської середньої дальності поверхню повітряної системи, виробництва компанією Raytheon. 

-The Розмір перехоплювача Patriot сама по собі має довжину близько приблизно 20 футів. І важить близько 2000 фунтів. І вона несе боєголовку близько, Я думаю, що це приблизно 150 фунтів. А сама боєголовка є висока вибухової речовини, який є фрагменти навколо нього. корпус боєголовка розроблений, щоб діяти як картеч. 

-The Ракети перевозяться чотири в контейнері, і транспортуються напівпричепом. 

-The Patriot системи ПРО сходить принаймні, 20 років. Спочатку він був розроблений як протиракетна оборона повітряного щоб збивати ворожі літаки. У першій війні в Перській затоці, коли ця війна прийшла разом, Армія хотіла використовувати його збивати бокоплавів, а не літаки. 

ВПС Іраку було не так багато проблем. Але армія хвилювалася про бокоплавів. І таким чином вони намагалися оновити Patriot. 

-Intercepting Ворога Ракета подорожі в 5М збирається бути складним досить. Але коли Patriot був доставлений в експлуатацію, Армія не відомо про Іракський модифікація, яка зробила їх бокоплави майже неможливо потрапити. 

-Що Сталося це бокоплави, що прибували в нестійкі. Вони були погойдуючись. Причиною цього було іракці, в порядку щоб отримати 600 кілометрів з 300 км Ракета діапазон, взяли вагу з передньої боєголовкою. Вони зробили боєголовка світліше. 

Так що тепер Патріот намагаючись прийти в Scud. І більшу частину часу, Переважна більшість часу, було б просто літати на Scud. Після того, як оператори системи Patriot зрозумів, що Patriot пропустив свою мету, вони детонувати боєголовку Патріотичного щоб уникнути можливих втрат, якщо вона було дозволено впасти на землю. 

-Ось Було то, що більшість людей бачили, ці великі вогняні кулі в небі, і не зрозуміли, як перехоплює Скад боєголовок. 

-Хоча В нічний час небо, патріоти з'явилися щоб бути успішно знищуючи Скада, в Дахране, не може бути ніякої помилки про його виконанні. Там, радіолокаційна система Патріотичного втратив слід вхідного Scud, і ніколи не запущений через до програмного вада. Це було ізраїльтян, які вперше виявлений що чим довше система була включена, тим більше час розбіжності стали, через годинами впровадженого в комп'ютері системи. 

-О За два тижні до трагедія в Дахране, ізраїльтяни повідомили Міністерство оборони що система втрачає час. Приблизно через вісім годин або бігу, вони помітили, що система стає помітно менш точним. Міністерство оборони у відповідь кажучи все батарейки Patriot не залишати системи протягом довгого часу. Вони ніколи не говорили, що довгий час was-- вісім годин, 10 годин, 1000 годин. Ніхто не знав. 

-The Батареї Patriot розміщених в казармі в Дахране і його недоліки внутрішньої Годинники були на більш ніж 100 годин в ніч на 25 лютого. 

-Він Відстежувати час з точністю близько однієї десятої частки секунди. Тепер, десяту секунди це цікаве число, так як воно не може бути виражено в двійковій системі точно, що означає, що вона не може бути виражено точно в будь-якому сучасному цифровому комп'ютері. Важко повірити. 

Але використовувати це як приклад. Давайте візьмемо номер на одну третину. Одна третина не може бути виражається в десятковій системі числення в точності. Одна третина є 0,333 відбувається на нескінченності. 

Там немає ніякого способу зробити це з абсолютна точність в десятковій системі числення. Це саме та проблема що сталося в Patriot. Чим довше система побігла, гірше стала помилка часу. 

-Після 100 годин роботи, Помилка в той час був тільки близько однієї третини секунди. Але з точки зору орієнтуєтеся на Ракета подорожі в 5М, це призвело до відстеження Похибка більше 600 метрів. Було б фатальною помилкою для солдатів на те, що відбулося це запуск Scud був детектується ранніх супутників попередження і вони знали, що Scud був приходять в їх загальному напрямку. Вони не знали, звідки він виходить. 

-Це Був тепер до радара компонент системи Patriot захищаючи Дахране, щоб знайти і зберегти слід наближається ракети противника. 

-The Радар був дуже розумний. Це буде насправді трек становище Scud, а потім передбачити, де це можливо буде наступного разу послав радар імпульсу поза. Це називається ряд воріт. 

-Тоді, Як тільки Patriot вирішує досить часу пройшов, щоб повернутися і перевірити наступний місце для цього виявленого об'єкту, воно сходить. Тому, коли він повернувся до неправильного місце, тоді не бачить об'єкт. І це не вирішить, що не було об'єкт, це було помилкове виявлення, і краплі трек. 

-The Вхідний Скад зник з екрану радара. І через кілька секунд, це врізався в казарми. Скад загинули 28 і був останнім один вистрелив під час першої війни в Перській затоці. 

Трагічно, оновлене програмне забезпечення прибув в Дахране на наступний день. Програмне забезпечення помилка була було зафіксовано, закриття одна глава в каламутній Історія ракети Patriot. 

[Відеовідтворення] DAVID J. Малан: Так що це все сказати, що ці питання переповнення і неточностей все занадто реально. Так як же ми сюди потрапили? Ми почали з просто говоримо про Printf. Знову ж таки, ця функція, друкує щось на екрані, і ми ввели в подальшому кілька інших функцій з так званої бібліотеки CS50 в. І ми будемо продовжувати побачити їх свого часу. І ми, зокрема, використовується отримання рядки, і отримати Int, а тепер також отримати з плаваючою точкою, і все ж інші все ще буде ми стикаємося і використовувати себе незабаром. 

Але в деяких випадках, є ми вже бачили необхідність щоб зберегти те, що ці функції руки назад? Вони роздають нас назад рядок, або INT, або з плаваючою точкою. І іноді нам потрібно покласти, що рядок, або INT, або з плаваючою точкою, десь. 

І зберігати ці речі, згадати, як в порожньому місці, у нас є змінні. Але на відміну від нуля, в C ми маємо фактичні типи з даних variables-- типи, більше generally-- серед них, рядок, INT, A плавати, і ці інші досі. 

І тому, коли ми оголошуємо змінні в C, ми повинні оголосити наші типи даних. Це не те, що ми будемо повинні зробити пізніше в семестр як ми перехід на інші мови. Але зараз нам потрібно до апріорно заздалегідь, пояснити комп'ютера, який тип змінної ми хочемо, щоб дати нам. 

Тепер, між тим, щоб надрукувати ті види типів даних, ми повинні сказати PRINTF, чого очікувати. І ми побачили відсоток з для рядків, і відсоток я для цілих чисел, і деякі інші вже. І це просто вимоги для візуального представлення цієї інформації. 

І кожен з них може бути насправді параметризрвані або перероблені, в деякому роді, якщо ви хочете, щоб в подальшому контроль тип виведення, який ви отримаєте. І, насправді, виявляється, що не тільки є зворотна коса п для нової лінії. Там дещо ще називається зворотної косої межі г для повернення каретки, яка це більше схоже на стара школа друкарська машинка, а також для Windows використовується протягом багатьох років. 

Там в зворотної косої межі т для вкладок. Виявляється, що якщо ви хочете подвійні лапки всередині рядка, нагадаємо, що ми використовували подвійні лапки двічі цитата зліва і справа кінці наших рядків досі. Це, здавалося б, все заплутати. 

Якщо ви хочете поставити подвійні лапки в середина string-- і, дійсно, це збиває з пантелику, щоб побачити. І тому ви повинні бігти, так кажуть, подвійні лапки з чимось як, в буквальному сенсі, зворотної косої межі подвійні лапки. І є кілька інших досі. І ми побачимо більше тих, в реальних умовах експлуатації до тих пір. 

Так давайте тепер перехід від даних, а також уявлення, і арифметичні оператори, все з яких дав нам деякі будівлі блоки, з якими грати. Але тепер давайте насправді дати нам інша частина словника що у нас вже було Минулого тижня з нуля приймаючи поглянути на деякі інші Конструкції в C-- не всі з них. Але ідеї ми про те, щоб побачити насправді просто щоб підкреслити переклад з одна мова, до подряпин, до іншого, C. 

І з часом, ми підберемо більше інструментів для нашого інструментарію, так би мовити, синтаксично. І, насправді, ви побачите, що ідеї В даний час досить знайомі з минулого тижня. Так давайте зробимо це. 

Давайте йти вперед і нагнітати програму що насправді використовує деякі вирази, логічний вираз. Дозвольте мені йти вперед тут і створити новий файл. Я буду називати це condition.c. 

Дозвольте мені йти вперед і включають в себе бібліотеку CS50. І дозвольте мені йти вперед і включають в себе стандарт io.h для наших функцій, і Printf, і відповідно більше. Дозвольте мені дати собі, що шаблонного з INT головна порожнеча, чиє пояснення, яке ми будемо повернутися в майбутньому. 

Тепер дозвольте мені йти вперед і дати сам через INT отримаєте Int. Тоді дозвольте мені йти вперед і робити це. Я хочу сказати, якщо я це less-- давайте відмінності між позитивним, негативним, або нульові значення. 

Так що, якщо я менше нуля, дайте мені просто ця програма просто сказати, негативний, зворотна коса риска п, інакше якщо я більше нуля. Зараз я, звичайно, хочу сказати, PRINTF позитивний результат, зворотної косої н. А потім ще if-- я міг би зробити це. 

Я міг би зробити, якщо я дорівнює 0. Але я б робити на хоча б одна помилка вже. Нагадаємо, що знак рівності не дорівнює, як і ми, люди, знаємо це. 

Але це оператор присвоювання. І ми не хочемо приймати 0 на право і покласти його в I на лівій стороні. Таким чином, щоб уникнути плутанини, або можливо зловживання знака рівності, люди вирішили кілька років тому що в багатьох мовах програмування якщо ви хочете, щоб перевірити на рівність між лівими і правими, ви насправді використовувати дорівнює рівних. Таким чином, ви потрапили в знак рівності двічі. Якщо ви хочете призначити справа наліво, використовувати один знак рівності. Таким чином, ми могли б зробити ще this-- якщо я дорівнює дорівнює нулю. 

Тоді я міг би піти і відкрити мої фігурні дужки, і сказати, Printf 0, зворотна коса риска п, зроблено. Але пам'ятайте, що ці розвилок може працювати. І, насправді, просто подумайте про логіку. я це число. Це ціле число, зокрема. І це означає, що вона буде менше, ніж 0 або більше 0, або 0. Таким чином, є вид цього мається на увазі випадок за замовчуванням. 

І таким чином ми могли, так само, як Подряпини, обійтися без іншого, якщо, і просто сказати ще. За логікою речей, якщо ти програміст знаю, що є тільки три відра, в які Сценарій може fall-- перший, другий, або третій в цьому case-- НЕ морочитися додаючи додаткову точність і додаткова логіка там. Просто йти вперед з Справа за замовчуванням тут ще. 

Тепер, давайте йти вперед після збереження цього зробити умови точка слеш conditions-- не великий призначений для користувача інтерфейс, тому що я не спонукало користувач, як я згадував раніше. Але це нормально. Ми будемо тримати його просто. Давайте спробуємо число 42. І це позитивно. Давайте спробуємо номер 42 негативне, негативний. 

Давайте спробуємо значення 0. І дійсно, вона працює. Тепер ви будете бачити проблеми перед довгі, тестування речі в три рази, ймовірно, не є достатнім. Ви, ймовірно, хочете, щоб перевірити деякі великі числа, деякі менше, номера, деякі окремі випадки, як ми приїдемо, щоб описати їх. 

Але на сьогоднішній день це досить проста програма. І я впевнений, що, за логікою речей, що він потрапляє в трьох випадках. І дійсно, навіть якщо ми просто зосереджені на потенційні недоліки неточностей і переповнення, в реальність, де багато хто з проблем CS50, в ми не будемо турбуватися про те, весь час, ці питання переповнення і Неточність, так як, по суті, в C, це насправді не все, що легко уникнути цих речей. Якщо ви хочете, щоб підрахувати більше, і більше, і більше, виявляється, є методи, які Ви можна використовувати, часто за участю речі, звані бібліотеки, колекції коду, що інші люди писали, що ви можете використовувати, і інші мови, такі як Java та інші, насправді зробити це набагато простіше розраховувати ще вище. Так що насправді деякі з цих небезпек функцією використовуваного вами мови. І в найближчі тижні, ми будемо побачити, як небезпечний C дійсно може бути, якщо ви не використовуєте його правильно. Але звідти, і з Python і JavaScript, буде ми шар на деякі додаткові засоби захисту, і запустити менше цих ризиків. 

Так давайте зробимо трохи більше цікава логіка в нашій програмі. Отже, дозвольте мені йти вперед і створити програма під назвою Logical тільки так я можу грати з деякими Фактична логіка, logical.c. Я просто скопіювати і вставити деякі коду з раніше, так що я повернуся до цієї гарною відправною точкою. 

Дозвольте мені на цей раз зробити сЬаг C. Я збирається дати йому ім'я C тільки тому, що звичайні, отримати символ від користувача. А давайте уявимо, як Я частина реалізації з цієї програми Rm, то видалити Програма до цього запиту користувачу для видалення файлу. Як ми можемо це зробити? 

Я хочу сказати, якщо С дорівнює одно, цитата Unquote, у, то я буду вважати, що користувач вибрав так. Я просто хочу, щоб надрукувати так. Якби це було насправді писати програма видалення, ми могли б видалити файл з великою кількістю рядків коду. Але ми будемо тримати його просто. 

Інакше, якщо з одно дорівнює N-, і тепер тут, я збираюся сказати, користувач повинен мати на увазі немає. А потім ще, ви знаєте, що? Я не знаю, що ще користувач збирається ввести. Так що я просто хочу сказати, що тобто помилка, то, він або вона насправді набрали. 

Так що ж тут відбувається? Існує принципова різниця проти того, що я зробив у минулому. Подвійні лапки, подвійні лапки, подвійні котирування, і, тим не менше, використовуйте одиничні лапки, одиничні лапки. Виявляється, в C, що, коли Ви хочете написати рядок, Ви робите подвійні лапки, так само, як ми використовую весь цей час з Printf. 

Але якщо ви хочете мати справу з просто одиночний символ, так званий символ, то ви насправді використовувати одиничні лапки. Ті з вас, хто запрограмований перед тим, ви не могли б доводилося турбуватися про це Різниця в деяких мовах. У C, це дійсно має значення. І тому, коли я отримую напівкоксу і я хочу для порівняння, що символ з використанням рівних дорівнює деякій літери як у чи п, я, насправді, потрібно мати одиничні лапки. 

Тепер, давайте йти вперед і робити це. Давайте йти вперед і роблять логічні точка слеш логічно. І тепер я бути пробуджені. Так що, мабуть, кращий користувальницький досвід буде насправді сказати, що мені робити тут. Але я збираюся просто сліпо скажімо у для да, добре, добре. 

Давайте запустимо його знову, п для немає, добре. Припустимо, наприклад, деякі люди, яких я знаю, мої кришки блокування ключ на занадто часто. Так що я капітал Y, введіть, помилку. Добре, це не зовсім те, що я очікував. Справді, комп'ютер робить те, що в буквальному сенсі Я розповів це do-- перевірити в нижньому регістрі у і малі літери п. Це не відчуває себе добре призначений для користувача інтерфейс, хоча. Дозвольте мені просити і прийняти або в нижньому регістрі або в верхньому регістрі. Так що виходить, ви можете захотіти сказати щось, як в порожньому місці, як буквально або C дорівнює дорівнює капіталу одного цитований у. Виявляється, C не має це ключове слово або буквальним. 

Але у нього є дві вертикальні смуги. Вам необхідно утримувати клавішу Shift, як правило, якщо ви використовуєте США клавіатури, і вдарив вертикальну смугу клавішу, розташовану вище вашого повернення ключа. Але це вертикальна смуга Вертикальна риса означає або. 

Якщо ж, навпаки, ми хочемо сказати, і, як у порожньому місці, ми могли б зробити амперсанд амперсанд. Це не має ніякого логічного сенсу тут, тому що людина не могла набрали як у і в нижньому регістрі у і капітал Y, як той же характер. Так чи то, що ми маємо намір тут. 

Так що, якщо я роблю це в обох місцях, або C дорівнює капіталу дорівнює N, тепер знову запустити, робити логічні, перезапускати логічно. Тепер я можу ввести у. І я можу зробити це знову капітал Y, або капітал N. І я міг би додати в додатковий Комбінації досі. 

Так що це логічно Програма, оскільки в даний час Я перевіряю логічно для це значення або це значення. І я не повинен, обов'язково, придумати ще два МФС чи ж МФС. Я можу насправді об'єднати деякі з пов'язаних з логікою разом таким чином. Так що це було б краще розроблені, ніж просто кажучи, якщо С дорівнює малу у, друк так, інакше, якщо з одно капіталу Y, друк так, інакше, якщо з одно lower-- іншими словами, ви не повинні мати все більше і більше філій. Ви можете об'єднати деякі з еквівалента гілки логічно, так як в цьому шляху. 

Отже, давайте розглянемо тільки один Остаточний інгредієнт, один кінцева конструкція, що C дозволяє. І ми повернемося в майбутнє іншим ще. І тоді ми робимо висновок, подивившись прі не правильності code-- отримання коду work-- але дизайн коду, і посадити ці насіння на ранніх стадіях. 

Отже, дозвольте мені йти вперед і відкрити новий файл тут. Знаєш, що? Я збираюся повторно реалізувати та ж програма, але використовуючи іншу конструкцію. 

Отже, дозвольте мені швидко віддамся доступ до включають CS50.h для бібліотеки CS50, стандарт io.h для Printf. Дайте мені мою INT головну порожнечу. А потім тут, нехай мені йти вперед і робити це. 

Чар з отримує отримати символ, так само, як і раніше. І я збираюся використовувати нову конструкцію now-- перемикач, на який характер? Так перемикач ніби як Перемикання залізничних шляхів. Або, насправді, це свого роду Умовний ще, якщо ще, якщо, але написано трохи інакше. 

Перемикач виглядає наступним чином. У вас є перемикач, і що потім символ або номер, який ви хочете подивитися, то деякі фігурні дужки як в Подряпини, просто скажемо, зробити цей матеріал. І тоді у вас є різні випадки. 

Вам не слід використовувати, якщо і ще. Ви в буквальному сенсі використовувати слово випадок. І ви могли б сказати щось на кшталт цього. 

Так що в разі малої у, або в разі великої літери Y, йти вперед і роздрукувати так. А потім спалахнути перемикача. Це воно. Були зроблені. 

Інакше, якщо, так би мовити, нижній регістр п, або капітал, N, потім йти вперед і друк поза немає, а потім перерва. Else-- і цей вид є кейс за замовчуванням indeed-- Printf error-- і просто для хорошої заходом, хоча логічно ця перерва не потрібен тому що ми знаходимося в кінці перемикача в будь-якому випадку, Я зараз спалахують перемикача. Так це виглядає трохи по-іншому. 

Але, за логікою речей, це насправді еквівалентні. І чому б ви використовувати один над іншим? Іноді, тільки особисті переваги, іноді естетика, якщо я дивлюся на це Тепер, є дещо Треба сказати для читаність коду. Я маю на увазі, не кажучи вже про те, що це код є новим для багатьох з нас в кімнаті. 

Але це тільки почасти досить. Ви бачите в нижньому регістрі у, капіталу Y, нижній регістр N, N капітал за замовчуванням, це тільки частково стрибки на вас в дорозі що, можливо, може бути, попередній приклад з МСФ і вертикальних стрижнів, а решта МФС, не могли б мати. Так що це дійсно питання особистого вибір, насправді, чи читаність, коду. 

Але з точки зору функціональності, дозвольте мені йти вперед і зробити вимикач, точка слеш перемикач, і тепер ввести в нижньому регістрі у, капітал Y, малі літери п, капітал N, Девід, повторити спробу, тому що це жодного символу. Давайте зробимо х, помилка, як і очікувалося. І, logically-- і це те, Я хотів би закликати в general-- навіть хоча ми тільки подряпати Поверхня деяких з цих особливостей. 

І це може бути не очевидно, коли ви самостійно сісти за клавіатуру, як це працює? Що б це зробити? Красива річ про те, ноутбук або настільний комп'ютер, або доступ до комп'ютера за допомогою компілятора, і з редактором коду, як це, це майже завжди можна відповісти на ці питання для себе просто спробувати. 

Наприклад, якщо риторична Питання під рукою були, що станеться, якщо ви забули ваші заяви перерву? Що насправді дуже поширена річ, щоб зробити, тому що він не виглядає як вам дійсно потрібні. Вони не дійсно завершити думали, як круглі дужки або фігурні дужка робить. Давайте йти вперед і перекомпіліровать код і подивитися. Так зробіть вимикач, точка перемикання слеш. Давайте типу в нижньому регістрі у, верхній випадок, Enter. Таким чином, я надрукував у. 

Програма каже, так, ні, помилка, як якщо б це була зміна його розум. Але це частково було, тому що відбувається з перемикачем перший випадок, Матч по суті означає, агов комп'ютер, виконати весь код під ним. І якщо ви не говорите, перерва, або не кажіть, перерва, або не говорять перерву, комп'ютер буде дути через всі ці лінії і не виконувати їх все до він отримує до цього фігурною дужкою. Тому гальма, дійсно, необхідно. Але тут їжа на будинок, коли є сумніви, спробуйте що-небудь. Може бути, зберегти свій код по-перше, або зберегти його в додатковий файл якщо ви дійсно стурбовані Мессінг і того, щоб відновити робота, яку ви знаєте, працює. 

Але спробувати речі. І не так страшно, може бути, про те, що комп'ютер може зробити, або що ви могли б що-небудь зламати. Ви завжди можете повернутися назад в якийсь більш ранній версії. 

Так що давайте закінчимо, дивлячись при проектуванні коду. У нас є ця здатність тепер писати умови і цикли запису, і змінні і функції обробки викликів. Так що, чесно кажучи, ми начебто назад в де ми були тиждень тому з нуля, хоча і з менш переконливим текстуально Понеділок, ніж нуля дозволяє. 

Але зверніть увагу, як швидко ми придбали що словниковий запас, навіть якщо це збирається зайняти деякий час, щоб потонути в, так що тепер ми можемо використовувати цей словник писати більш цікаві програми. І давайте крок дитини до що, як слід. Дозвольте мені йти вперед і створити новий файл тут. 

Я буду називати це prototype.c, і ввести в перший раз, здатність щоб зробити свої власні функції. Деякі з вас, можливо, зробив це з нуля, в якому ви можете створити свій власні блоки нуля, а потім перетягнути їх на місце всюди, де ви хотіли б в C. І в більшості програм мови, ви можете зробити саме that-- зробити свої власні функції, якщо вони вже не існують. 

Так, наприклад, дозвольте мені йти вперед і включають CS50.h, і включають в себе стандарт io.h, INT головний недійсним. І тепер у нас є заповнювач готовий до роботи. Я тримаю друку речі як імена людей сьогодні. І це відчуває себе like-- не було б непогано, якби були функція називається ім'я друку? Я не повинен використовувати Printf. Я не повинен пам'ятати всі коди формату. Чому не я, і чому не зробив хтось переді мною, створити функцію під назвою друку ім'я, що дано якусь назву, просто друкує його? 

Іншими словами, якщо я говорю, агов, комп'ютер, дайте мені рядок питаючи у користувача, наприклад, за допомогою функції отримання рядка CS50 в. Гей, комп'ютер, помістити цей рядок в змінна в лівій частині, і називають це S. А потім, агов комп'ютер, йти вперед і друк, що ім'я людини, зроблено. 

Тепер, було б непогано, тому що ця програма, влучно назвав, каже мені, що він повинен робити шляхом імен тих, функції. Дозвольте мені піти і зробити прототип, Enter. І, на жаль, це не буде літати. 

Prototype.c, рядок 7, характер 5, помилка, неявне оголошення функції друку імені неприпустимий в C99, C99 означає версію C який вийшов в 1999 році. Це все. 

Так що я не знаю, що все це означає, що до сих пір. Але я визнати помилку в червоному кольорі. Це досить очевидно. 

І мені здається, що з зелений символ тут, проблема пов'язана з ім'ям друку, відкрийте PAREN s, близькі PAREN, напівсинтетичні товстої кишки. Але неявне декларація функція, яку ми бачили коротко раніше. Це означає, просто, що Clang не знає, що я маю на увазі. 

Я використовував Кодова слово, що це ніколи не бачив і не вчили раніше. І тому мені потрібно, щоб навчити його що означає ця функція. Так що я збираюся йти вперед і робити це. 

Я збираюся йти вперед і реалізувати моя власна функція називається Print Name. І я буду говорити, як це випливає, що він робить це, PRINTF, привіт, відсотків s, зворотний слеш н, ім'я, крапка з комою. Так що ж я тільки що зробив? 

Так що виходить, щоб реалізувати свою власну функцію, ми якось запозичити деякі з та ж структура, як головний що ми тільки що були щось само собою зрозуміле, і я знаю, просто скопіювати і приклеювання досить багато, що Я писав у минулому. Але зверніть увагу на зразок тут. Int, Main, Пустота, ми будемо дратувати один від одного до того довго, що це насправді означає. 

Але на сьогоднішній день, як раз зверніть увагу на паралелізм. Порожнеча, ім'я друку, ім'я рядка, так що є фіолетове ключове слово, який ми збираємося почати викликаючи тип значення, ім'я функція, а потім введення. Так що, насправді, ми можемо переганяти цей вид, як минулого тижня оскільки це ім'я або алгоритм коду ми знаходимося збирається write-- алгоритм, що лежить в основі код, який ми збираємося написати. 

Це його вхід. Це його вихід. Ця функція, ім'я друку, є розроблений, щоб взяти рядок з ім'ям ім'я, або незалежно від того, в якості вхідних даних, а потім анулюються. Вона не повертає нічого, як отримати рядок або отримати INT робить. Так що він збирається передати мені що-небудь. Це просто буде мати побічний ефект, так би мовити, друкувати ім'я людини. Так зверніть увагу, рядок 7, я можна назвати ім'я друку. Рядок 10, я можу визначити або реалізують ім'я друку. Але, на жаль, цього недостатньо. 

Дозвольте мені йти вперед і перекомпіліровать це після збереження. Вау, тепер, я зробив це гірше, здавалося б. Таким чином, неявне оголошення ім'я функції друку недійсний. І, знову ж таки, є більше помилок. Але, як я попередив раніше, навіть якщо ви отримуєте завалені, або трохи сумно бачити так багато Помилки, зосередитися тільки на перший на початковому етапі, так як це може бути просто мали каскадний ефект. Так C або Clang більш конкретно, до сих пір не визнає ім'я друку. 

І це тому, що Clang, дизайн, це свого роду німий. Це тільки робить те, що ви скажете їй зробити. І це тільки робить це в порядку в якому ви скажете їй зробити. 

Таким чином, я визначив головний на четвертому рядку, як ми робили досить часто. Я визначив ім'я друку в рядку 10. Але я намагаюся використовувати друкувати ім'я на лінії сім. 

Це занадто рано, поки не існує. Так що я міг бути розумним, і бути, як, ОК, так що давайте просто грати разом, і перемістити ім'я друку вгору тут, і пересобрать. Боже мій. Це спрацювало. Це було так просто. 

Але логіка саме це. Ви повинні навчити Clang, що це є шляхом визначення функції першого. Після цього ви можете використовувати його. Але, чесно кажучи, це відчуває як слизького. 

Так що кожен раз, коли я біжу в проблему, я просто збирається виділити і скопіювати код Я написав, вирізати його і вставити його сюди. І, звичайно, ми могли б зуміти деякі сценарії де одна функція може потрібно зателефонувати іншому. І ви просто не можете помістити кожен функція вище будь-який інший. 

Так виходить, що є краще рішення. Ми можемо залишити це бути. І, чесно кажучи, це взагалі приємно, і зручно, і хороший дизайн поставити головний по-перше, тому що, знову ж таки, Головним же, як коли зелений прапор клацнув, тобто функція, запускається на виконання за замовчуванням. Таким чином, ви можете також помістити вона у верхній частині файлу так що, коли ви або будь-який інша людина дивиться на файл Ви знаєте, що відбувається просто прочитавши головний перший. Так що виходить, ми можемо сказати Clang проактивно, агов, Clang, на четвертому рядку, Я обіцяю реалізувати функція називається Print Ім'я, яке приймає рядок називається ім'я в якості вхідних даних і повертає нічого, пустота. І я обійти реалізації його пізніше. 

Тут приходить Main. Головне тепер в рядку 9 можна використовувати Друк імені, тому що Clang хто ж має надію, що, врешті-решт, вона буде стикатися з визначенням здійснення друку Назва. Таким чином, після збереження мій файл, нехай мені йти вперед і зробити прототип, виглядає добре на цей раз. Дот слеш, прототип, дозвольте мені йти вперед і ввести ім'я. Девід, привіт David, Zamila, привіт Zamila, і, насправді, тепер він працює. 

Таким чином, компонент тут є те, що ми в зробив для користувача функцію, як звичай Подряпина блок ми називаємо його. Але на відміну від нуля, де ви можете просто створити його і почати використовувати його, Тепер ми повинні бути трохи більше педантичним, і насправді потяг Clang використовувати, або чекати його. Тепер, як в сторону, чому весь цей час ми були просто сліпо на віру, включаючи CS50.h, і в тому числі стандартних io.h? 

Що ж, виходить, серед кількох інших речей, все, що в цих точок ч файли, які, трапляється, файли. Вони файли заголовків, так би мовити. Вони як і раніше написані на C. Але вони інший тип файлу. 

На даний момент, ви можете в значній мірі припустити, що все, що знаходиться всередині CS50.h Дехто ж дотепами, як це, не для функцій, що викликаються друку Ім'я, але для отримання рядка, отримати Поплавок, і кілька інших. І є подібні прототипи, лайнери, всередині стандартного io.h для Printf, який зараз перебуває в моя власна функція друку Ім'я. Отже, іншими словами, весь цей час ми в просто сліпо скопіювати і вставити включити це, включають в себе що, що відбувається? Це просто вид підказок дзвеніти щодо того, що функції які, дійсно, реалізовані, просто в інших місцях в різних файлах в іншому місці в системі. 

Таким чином, ми реалізували ім'я друку. У нього є цей побічний ефект друк щось на екрані. Але це не насправді передати мені що-небудь. Як ми йти про реалізації програми, яка це передати мені що-небудь? 

Що ж, давайте спробуємо це. Дозвольте мені йти вперед і реалізувати файл з ім'ям return.c так що ми можемо показати, як щось як отримати рядок, або отримати Int, насправді повернення щось назад користувачеві. Давайте йти вперед і визначити Int основну порожнечу. 

І, знову ж таки, в майбутньому, ми будемо пояснити, що це Int і цю порожнечу насправді робить. Але на сьогоднішній день, ми будемо приймають це як належне. Я збираюся йти вперед і Printf, для хорошого користувальницького досвіду, х. А потім я буду чекати Користувач, щоб дати мені х з GET Int. 

А потім я збираюся йти вперед і роздрукувати х на площу. Тому, коли у вас є тільки клавіатура, люди часто використовувати маленьку морква символ на клавіатурі представляти до влади з, або показник. Так що х в квадраті присутній я. 

А тепер я збираюся зробити це. Я міг би просто do-- що х в квадраті? х в квадраті х раз х. 

І ми зробили це деякі давно вже сьогодні. Це не схоже все, що значний прогрес. Знаєш, що? Давайте використовувати деякі з цієї ідеї від останнього часу абстракції. 

Не було б добре, якщо є функція, яка називається квадрат, який робить саме це? Він як і раніше, в кінці день, робить те ж математику. Але давайте абстрактні геть ідея взяття одне число, помножене на інший, а просто дати йому ім'я, як квадрат це значення. 

І, іншими словами, в C, давайте створимо функцію називається квадрат, який робить саме це. Це буде називатися квадрат. Він збирається прийняти Int. І ми будемо просто називати його п, за замовчуванням. 

Але ми могли б назвати це все, що ми хочемо. І все, що він збирається робити, в буквальному сенсі, є повернення результат п раз п. Але так як це повертаючи щось, що є ключовим словом в фіолетовий ми в ніколи не бачив раніше, я, в рядку 11, не може просто сказати, порожнеча на цей раз. 

Порожнеча, в прикладі, який ми тільки що бачили а назви друку, просто означає, робити щось. Але не дай мені що-небудь. У цьому випадку, я хочу для повернення в п раз п, або незалежно від того, що є, це число. 

Так що я не можу сказати, агов, комп'ютер, Я не повернуся нічого, пустота. Це збирається повернутися, за своєю природою, в Int. І так, що це все, що тут відбувається. 

Вхід на площу збирається бути інт. І так, що ми можемо використовувати його, він повинен є ім'я, N. Це збирається виводити INT, який не потрібно ім'я. Ми можемо залишити його на головну, або той, хто використовуючи мене, щоб пам'ятати це значення, якщо ми хоче зі своєю власною змінної. 

І, знову ж таки, тільки новий Ключове слово тут Return. І я просто роблю деякі математики. Якби я дійсно хотів бути непотрібним, Я міг би сказати INT продукт отримує п раз п. 

І тоді я міг би сказати, повернути продукт. Але, знову ж таки, до моєї точки раніше з це просто не бути хорошим design-- як, навіщо вводити ім'я, символ, як продукт, просто негайно повернути його? Це трохи чистіше, трохи жорсткіше, так говорити, просто сказати, повернення п раз п, щоб позбутися від цієї лінії в цілому. 

І це як раз менше коду, щоб читати, менше можливостей для помилок. І давайте подивимося, якщо це насправді в даний час працює. Тепер, я збираюся піти вперед і зробити повернення. 

Ой-ой, неявне оголошення функції. Я зробив цю помилку раніше, не склало великих труднощів. Дозвольте мені просто надрукувати, або виділити і скопіювати, точно такий же прототип функції, або підписи, функції тут. Або я міг би перемістити всю функцію. 

Але це трохи лінивий. Таким чином, ми не будемо цього робити. Тепер, дозвольте мені зробити повернення знову ж, точка повернення косою риси. 

х в квадраті 2. х 4. х квадрат 3. х 9. І функція здається Тепер, щоб працювати. То яка різниця тут? У мене є функція, яка називається квадрат, в цьому випадку, який я поставив в якості внеску. І я отримую назад вихід. І тим не менше, раніше, якщо Я відкриваю ще один приклад від раніше, що був названий prototype.c, У мене було ім'я друку, який повернувся недійсним, якщо можна так висловитися, Або це не дав нічого, і просто мав побічний ефект. 

Так що ж тут відбувається? Що ж, розглянемо функцію отримати рядок на мить. Ми використовуємо функцію отримати рядок наступним чином. 

У нас було функція отримати рядок, як включати CS50.h, включають в себе стандартні io.h, INT, основний, недійсним. І тоді кожен раз, коли я називається отримання рядки досі, Я сказав щось на кшталт, рядок s отримує отримати рядок, тому що string-- Get давайте назвемо цю get.c-- рядок GET сама повертає рядок, я можу потім використовувати, і сказати, привіт, кома, відсотків s, зворотна коса п, з. 

Так що це той же самий приклад, насправді, що у нас було раніше. Так що рядок повертає значення. Але мить назад, рядок для друку не повертає значення. Він просто має побічний ефект. Так що це принципова різниця. Ми бачили різні типи функцій в даний час, деякі з яких повернулися значення, деякі з яких не роблять. Так може бути, це рядок, або INT, або з плаваючою точкою. Або, може бути, це просто порожнеча. 

І різниця що ці функції, отримати дані і повертає значення, насправді в результаті чого-то назад до столу, так би мовити. Так що давайте йти вперед і дивитися на один остаточний набір прикладів, що дає відчуття, тепер, як ми могли б, справді, абстрактні краще, і краще, і краще, або більше, і більше, і більше, для того, писати, в кінцевому рахунку, кращий код. Давайте йти вперед, і в дусі скретч, зробіть наступне. 

Дозвольте мені йти вперед і включають в себе CS50.h і стандарт IO.h. Дозвольте мені йти вперед і дати я INT, головним чином, порожнеча. І дозвольте мені йти вперед, називаємо це cough.c. 

І дозвольте мені йти вперед і просто як подряпина, роздрукувати кашель / п. І я хочу зробити це три рази. Так що я, звичайно, просто збирається скопіювати і вставити три рази. Я зараз збираюся зробити кашель точка слеш кашель. Давайте дамо собі трохи більше місця тут, Enter, кашель, кашель, кашель. 

Там в, очевидно, вже можливість для поліпшення. Я скопіював і вставив кілька разів сьогодні. Але це було тільки тому я не зробив повинні набрати стільки символів. Я до сих пір змінилося, що ці рядки коду. 

Ці три лінії ідентичні, який відчуває себе ледачим і справді є, і, ймовірно, не правильний підхід. Так з якою інгредієнт ми могли б поліпшити цей код? Ми не повинні копіювати код. 

І дійсно, в будь-який час ви відчуваєте самостійно копіювання і вставки, і навіть не змінюючи код, Шанси є кращий спосіб. І, дійсно, є. Дозвольте мені йти вперед і зробити цикл, навіть при тому, що синтаксис не може приходять, природно, поки немає. 

Зробіть це три рази, просто , Роблячи following-- і я знаю це з практики. Але у нас є ряд прикладів, в даний час. І ви побачите онлайн більше посилань досі. 

Це синтаксис в рядку 6, що так само, як нуля, який повторюється блок, повторіть наступні три рази. Це трохи чарівний зараз. Але це буде отримати більше, і більш знайомим. 

І це буде повторюватися лінія вісім три рази, так що якщо я перекомпілюються макіяж кашель, точка слеш кашель, кашель, кашель, кашель. Він як і раніше працює точно так само. Так що це все прекрасно і добре. Але це не дуже абстрактно. 

Це абсолютно правильно. Але він відчуває, як там може бути можливість, як і в світі Подряпини, щоб вид старту щоб додати деяку семантику тут, так що Я не просто якийсь цикл, і функція, яка говорить кашель, або ж кашель. Знаєш, що? Дозвольте мені бути трохи холодніше, ніж, і насправді написати функцію, яка має деякі побічні ефекти, називають його кашель. 

І це не має ніякого введення і не повертає значення в якості висновку. Але ви знаєте, що він робить? Він робить this-- Printf, цитата Unquote, кашель. 

І тепер тут, я збираюся йти вперед і для Int, я отримує нуль, я менше, ніж 3, я плюс плюс. Я збираюся не робити Printf, що можливо, реалізація низького рівня детально. Мене не хвилює, як кашель. Я просто хочу, щоб використовувати функцію від кашлю. І я просто буду називати кашель. 

Тепер зверніть увагу на дихотомії. При виконанні функції, якщо ви цього не зробите хочуть, щоб дати йому входи, абсолютно нормально. Просто зробіть відкриті дужка, близько дужка, і ви зробили. 

При визначенні функції, або оголосити прототип функції у, якщо ви заздалегідь знаєте, це не збирається приймати будь-які аргументи, кажуть, порожнеча в цих дужках там. І це гарантує, що вам не випадково неправильного поводження з ним. Дозвольте мені йти вперед і зробити кашель. І, звичайно ж, я зробив помилку. 

Прокляття, є те, що неявне оголошення. Але це нормально. Це легко виправити. Мені просто потрібно прототип вище в моєму файлі, ніж я насправді використовувати його. 

Так що тепер дозвольте мені зробити кашель знову, приємно. Тепер вона працює. Зробити кашель, кашель, кашель, кашель. Таким чином, ви можете подумати, що ми насправді трохи більше інженерних цю проблему. І дійсно, ми. Це не дуже хороша кандидат програми на даний момент для рефакторінга, і робити те, що називається ієрархічне розкладання, де ви берете якийсь код, а потім ви начебто фактора речі, так що, як приписувати більше семантики до них, і використовувати його в кінцевому рахунку, більш тривалий термін. Але це будівельний блок в сторону складніші програми що ми почнемо письмовій формі до тих пір, що дозволяє нам мати словниковий запас з якої краще писати код. І дійсно, давайте подивимося, якщо ми не може узагальнити це далі. 

Це здається трохи кульгає, що я, головним чином, потрібно турбуватися про це штопати для циклу, і викликаючи кашель знову і знову. Чому я не можу просто сказати кашель, будь ласка, кашель в три рази? Іншими словами, чому я не можу просто дають внесок в кашель і зробити це? 

Чому я не можу просто сказати, в Основний кашель в три рази. І тепер, це свого роду магічне. Це дуже ітераційний тут. І це, дійсно, крок дитини. 

Але тільки здатність говорити на лінія вісім, кашель в три рази, це просто так набагато зручнішим для читання. І, плюс, я не повинен знати або все одно, як здійснюється кашель. І дійсно, пізніше в термін і для остаточних проектів, якщо ви вирішувати проект з однокласник або два однокласники, ви зрозумієте, що ви збираєтеся повинні, або хочете, розділити роботу. 

І ви будете хотіти, щоб вирішити, заздалегідь, хто буде робити те, що, і в які частини? І не було б приємно якщо ви, наприклад, взяти на себе відповідальність написання головним чином, зроблено. А ваш сусід по кімнаті, або ваш партнер в більш загальному плані, піклується про реалізацію кашель. 

І цей поділ, ці стіни абстракції, або шари абстракції якщо ви, супер потужний, тому що особливо для великих, складніші програми і системи, вона дозволяє декільком людям будувати всі разом, і в кінцевому рахунку зшити їх спільну роботу таким чином. Але, звичайно, ми потрібно виправити прямо зараз кашель. Ми повинні сказати кашель що, гей, ви знаєте, що? Ви будете потребувати, щоб взяти input-- тому не пустота, а INT і тепер. Давайте йти вперед і покласти в кашель ІНТ. я отримує нуль. 

я менше, ніж у скільки разів. Я сказав три раніше. Але це не те, що я хочу. Я хочу, щоб кашель бути узагальнена підтримувати будь-яку кількість ітерацій. 

Так що, насправді, це п, що я хочу, все, що користувач говорить мені. Тепер я можу йти вперед і сказати друку кашель. І незалежно від того, який номер користувач переходить в, Я буду повторювати, що у багато разів. 

Таким чином, в кінці кінців, Програма ідентична. Але зверніть увагу на всі ці речі може бути навіть в іншому файлі. Насправді, я не знаю, на Момент, як Printf реалізується. 

Я не знаю, на даний момент, як отримати рядок, або отримати Int, або отримати з плаваючою точкою реалізуються. І я не хочу побачити їх на моєму екрані. Як це, я починаю зосередитися на моя програма, а не ті функції. 

І так, справді, як тільки ви почати факторингу код, як це, ми могли б навіть рухатися кашель в окремий файл? Хтось інший міг би здійснити це. І ви і ваша програма стала дуже красивий, і дуже легко читаються, можливо, насправді чотири лінії програми прямо там. 

Так що давайте йти вперед прямо зараз і зробити ще одну зміну. Зверніть увагу на те, що мій прототип повинен змінитися до вершини. Отже, дозвольте мені виправити що так Я не отримую кричав на. 

Зробити кашель, дозвольте мені бігти кашель один раз Більш того, як і раніше робить те ж саме. Але тепер, зауважте, ми маємо інгредієнт для однієї остаточної версії. Знаєш, що? Я не хочу, щоб просто кашель, обов'язково. Я хочу мати щось більш загальне. Таким чином, ви знаєте, що? Я хочу, щоб це зробити. Я хочу мати, так само, як нуля робить, блок скажімо, але не тільки сказати щось кілька разів. Я хочу сказати, дуже конкретну рядок. І, отже, я не хочу, щоб просто сказати, кашель. Я хочу сказати, що б не рядок передається в. 

Тому зверніть увагу, я узагальнив це так, що в даний час скажімо відчуває себе добре ім'я для цього, як нуля, приймає два аргументи, на відміну від нуля. Одним з них є рядком. Одним з них є Int. 

І я міг перемикатися між ними. Я просто ніби як ідея кажуть рядок, а потім скільки раз пізніше. Порожнеча означає, що він до сих пір нічого не повертає. Це лише візуальна сторона ефекти, як з [? Джордан ,?] словесне побічний ефект кричати. Він як і раніше робить щось п раз, 0 до, але не дорівнює п. Це означає, що загальний час п. А потім просто роздрукувати що б це не рядок. Так що я дійсно узагальнена цей рядок коду. Так що тепер, як я можу реалізувати функція від кашлю? 

Я можу зробити недійсним кашель. І я все ще можу взяти в тому, багато разів ви хочете, щоб кашель. Але ви знаєте, що? Тепер я можу сказати, Пунт. 

Я можу зателефонувати сказати з слово кашель, переходячи в п. І якщо я хочу також здійснити, просто для задоволення, функція чхання, Я можу чхання кілька разів. І я можу багаторазово використовувати п, тому що зверніть увагу, що т в даному контексті або обсягу існує тільки всередині цієї функції. 

І п в цьому контексті тільки існує в рамках цієї функції тут. Таким чином, ми повернемося до ці питання сфери. І ось, я просто хочу сказати, Achoo, а потім п раз, крапка з комою. 

А тепер, мені просто потрібно зайняти ці функції підпису тут. Так що кашель є правильним. Порожнеча чих тепер правильно. 

І я до сих пір просто потрібно сказати. Так що я буду говорити, скажімо рядок s, Int N, крапка з комою. Таким чином, я надмірно спроектували чорт з цієї програми. 

І це не обов'язково означає, що це що ви повинні зробити при написанні навіть найпростіші програми. Візьміть щось, що, очевидно, дуже просто, дуже короткий, і повторно реалізувати його використовуючи надто багато коду. Але ви насправді бачите, і в час озирнутися назад на цих прикладах, і усвідомити, про, це ті кроки ми взяли насправді узагальнювати, фактор щось, до тих пір, поки в кінці дня мій код насправді досить розумно. Тому що, якщо я хочу, щоб кашель три раз потім чхнути три рази, Я просто збираюся запустити повторно, Програма робить кашель, і запустити кашель. І у мене є три кашляє і три чхає. 

І так це основний парадигма, якщо ви будете, за те, як ми могли б йти про насправді реалізації програми. Але давайте просто подивимося, що тепер це ми робимо все це час, і те, що деякі із заключних частин позаду цієї простої команди. Зрештою, ми використовували Clang як нашого компілятора. Ми писали джерело код, перетворюючи його за допомогою Clang в машинний код. 

І ми використовуємо тільки зробити щоб полегшити наші натискання клавіш так що ми не повинні пам'ятати, ці заклинання самого Clang. Але що це зробити насправді робити? І, в свою чергу, є те, що Clang насправді робити? 

Виявляється, хоча ми спростили сьогоднішнє обговорення, сказавши, ви берете вихідний код, передати його в якості вхід компілятора, який дає вам вихід машини код, виявляється, є кілька різних кроків всередині там. І компіляція трапляється парасольку термін для цілого ряду кроків. Але давайте просто дражнити на це дуже швидко. 

Виявляється, що ми робимо більше речей, кожен раз, коли я запустити програму, або кожен раз, коли я скомпілювати програму сьогодні. Таким чином, попередня обробка відноситься до this-- нічого в програмі C, як ми побачимо знову і знову, який починається з цієї хеш-символу, або символ Хештег тут, означає, це директива препроцесора. Це означає, що, в даному випадку, агов комп'ютер, зробити щось з цим файлом перш ніж ви насправді скомпілювати мій власний код. 

У цьому випадку, хеш включають є, по суті, шлях C спосіб сказати, агов комп'ютер, перейдіть отримати вміст з CS50.h і вставити їх тут. Гей комп'ютер, піти отримати зміст стандартного io.h, всюди, де це знаходиться на жорсткий диск, вставити його тут. Так що ці речі трапляються спочатку під час попередньої обробки. 

І Clang робить все це для нас. І це робить це так штопати швидко, ви навіть не побачити чотири різних речей відбувається. Але це перший такий крок. 

Що насправді відбувається далі? Ну, такий офіційний крок компіляції. І виходить, що складання програми технічно означає перехід від вихідний код, то матеріал, який ми писав сьогодні, до чогось називається код збірки, щось що виглядає дещо інакше. 

І справді, ми можемо бачити це дуже швидко. Дозвольте мені насправді піти в мій IDE. Дозвольте мені йти вперед і відкрити hello.c, який найперша програма, з якою ми почався сьогодні. І дозвольте мені йти вперед і запустити Clang A трохи по-іншому, Clang-s, hello.c, яка насправді збирається дайте мені ще один файл hello.s. 

І ми, ймовірно, ніколи знову побачити цей вид коду. Якщо взяти більш низький рівень Системи класу, як CS61, ви побачите набагато більше з такого коду. Але це мова збірки. Це X86 асемблері що процесор, який лежить в основі CS50 IDE насправді розуміє. 

І загадково, як це робить дивіться, це щось комп'ютер розуміє дуже добре. Sub кв, це вичитати. Там в рух. 

Там дзвонить функцій тут, х ORing, рух, надбудова, поп, повернення. Так що є якась дуже інструкції низького рівня що процесори розуміють, що Я згадував раніше. Тобто те, що Intel Inside. 

є моделі нулі і одиниці, що зіставити ці arcanely формулювання, проте кілька добре ім'я, інструкції, так би мовити. Це те, що відбувається, коли компіляції коду. Ви отримуєте збірки мова з нього, який означає, третій крок полягає в складанні що код збірки в кінцевому рахунку, машина code-- нулі і одиниці, а не текст, який ми тільки що бачили хвилину назад. 

Таким чином, попередня обробка робить, що знайти і замінити, і кілька інших речей. Компіляція приймає ваш джерело коду з C, вихідний код що ми вже писали, в зборі код, який ми тільки що подивився на. Збірка займає цю збірку код нулів і одиниць що процесор дійсно буде зрозуміти, в кінці робочого дня. І зв'язування є останнім кроком що відбувається через us-- знову, так швидко ми не робимо навіть notice--, що говорить, агов комп'ютер, взяти все нулі і одиниці, які в результаті компіляції коду Давида, і його основною функцією в цьому випадку. 

І гей комп'ютер, йди всі нулі і одиниці що співробітники CS50 писав всередині бібліотеки CS50. Змішайте ті, з Девіда. І гей комп'ютер, піти отримати все нулі і ті, що хтось написав кілька років тому для Printf. І додати таких пристроїв в Все це, так що ми отримав мої нулі і одиниці, тим нулі і одиниці персоналі CS50, в то PRINTF нулі і одиниці, і все інше, що ми використовуємо. 

Всі вони отримують об'єднані в одну Програма під назвою, в даному випадку, привіт. Так що відтепер ми будемо просто використовувати слово компіляції. І ми вважаємо цілком очевидним, що, коли ми говоримо, скомпілювати програму, то це означає, агов робити попередню обробку, монтаж і зв'язок. Але є насправді деякі соковиті речі там відбувається під капотом. І особливо якщо ви отримати цікаву деякий час, ви можете почати тикати навколо на цьому нижчому рівні. Але зараз розумію, що серед на сьогоднішній день їжі додому досить просто початок процесу, отримання комфортно щось на зразок привіт світ. Дійсно, велика частина того, що ми зробили сьогодні звичайно ж, не буде тонути в супер швидко. І це займе якийсь час, і деякі практики. І шанси, ви будете сортувати від того, хочуть вдарити клавіатури або кричати на екрані. І все це нормально. Хоча, можливо, намагаюся не зробити це в бібліотеці так багато. 

І в кінцевому рахунку, ви будете бути в змозі, хоча, щоб почати бачачи картини, як в хорошому коді що ви написали і в помилках що ви зробили. І так само, як процес ставши TF або СА, як, ви почнете ставати все краще і краще бачити ці моделі, і просто рішення ваших власні проблеми в кінцевому рахунку. У той же час, там буде багато з нас, щоб надати вам підтримку, і ви отримаєте через це. А в запису вікна для всіх проблем, ви будете керуватися через всі команди що я, звичайно, знаю, з багато практики в даний час, але, можливо, прилетів над головою на даний момент. І це абсолютно нормально. 

Але, в кінцевому рахунку, ви збираєтеся щоб почати бачити закономірності. І як тільки ви пройти всі з тупі деталі, такі як круглі дужки, і фігурні дужки і крапки з комою, і речі, чесно кажучи, що не на всіх інтелектуально цікавим. І це не мета приймаючи будь-який вступний клас. Це ідеї, які йдуть до матерії. 

Це петлі, і умов, а також функції, і більш потужно абстракція, і факторингова коду, і хороший дизайн, і гарне стиль, і в кінцевому рахунку правильність вашого коду, що в кінцевому рахунку збирається мати значення найбільше. Так що на наступному тижні, ми будемо приймати ці ідеї, які ми вперше побачили в порожньому місці і тепер переведені до C. І ми почнемо ввести перший з реального світу домени курсу. 

Ми зосередимося на світ безпеки, і більш конкретно криптографія, Мистецтво дертися інформації. І в числі перших проблеми ви самі отримаєте писати далі граючи з деякими з синтаксису і вирішуючи деякі логічні проблеми, в кінцевому рахунку, незабаром, це насправді засекретити, або зашифрувати, і в кінцевому рахунку розшифрувати інформацію. І все, що ми зробили сьогодні, буде досить низьким рівень, тільки збирається, щоб дозволити нам взяти один, і один, і ще один крок в сторону вище написання найцікавіший код ще. 

Так що більше на цьому на наступному тижні. 

[Відеовідтворення] 

Що ви можете розповісти мені про в останній раз ви бачили його? -Що Я можу сказати, насправді? Я маю на увазі, це було як і будь-який інший підготовка виробництва репетиція, за винятком того, що щось було, він сказав: в самому кінці, що застряг зі мною. 

-Це Був CS50. 

-Ось Вирізати все, відмінна робота на репетиції. 

обід -Ось? 

-Так, Ти і я можу захопити бутерброд небагато. Дозвольте мені просто опитувати з Девід дуже швидко. Девід? Девід? 

[КІНЕЦЬ ВОСП] 