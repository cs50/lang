[MUZIK Bermain] DAVID J. MALAN: Baiklah, ini adalah CS50. Dan ini adalah satu minggu. Jadi ingat bahawa kali terakhir pada minggu sifar, kita memberi tumpuan kepada pemikiran pengiraan. Dan kita beralih daripada memahami apa Awal, pengaturcaraan grafik bahasa dari rakan-rakan kami di Media Lab MIT. 

Dan dengan Scratch, adakah kita meneroka idea-idea seperti fungsi, dan syarat-syarat, dan gelung, dan pembolehubah, dan juga peristiwa, dan benang, dan banyak lagi. Dan hari ini, kita akan terus menggunakan idea-idea, dan benar-benar mengambil mereka untuk diberikan, tetapi menterjemahkannya kepada bahasa lain yang dikenali sebagai C. Sekarang, C adalah bahasa yang lebih tradisional. Ia adalah tahap yang lebih rendah bahasa, jika anda akan. 

Ia adalah semata-mata teks. Dan sebagainya pada pandangan pertama, ia semua akan kelihatan agak samar jika anda tidak pernah diprogramkan sebelum. Kami akan mempunyai koma bertindih, dan kurungan, dan pendakap kerinting, dan banyak lagi. Tetapi sedar bahawa walaupun walaupun sintaksis adalah akan kelihatan sedikit tidak dikenali kepada kebanyakan anda, melihat masa lalu itu. Dan cuba untuk melihat idea-idea yang, sememangnya, biasa, kerana di sini pada minggu satu apa kami akan mula lakukan adalah untuk membandingkan, pada mulanya, Scratch berbanding C. 

Maka, misalnya, ingat bahawa apabila kita dilaksanakan pertama program kami Kali terakhir, kami mempunyai blok yang kelihatan sesuatu yang kecil seperti this-- apabila bendera hijau diklik, dan kemudian kita mempunyai satu keping teka-teki atau lebih di bawahnya, dalam kes ini, berkata, hello dunia. Jadi, sesungguhnya, dalam Scratch, apabila saya klik bendera hijau dengan mengendalikan program, jadi untuk bercakap, ini adalah blok yang dapat dilaksanakan, atau berlari. Dan, khususnya, Scratch berkata, hello, dunia. 

Sekarang, saya boleh dinyatakan perkataan yang berbeza di sini. Tetapi kita akan melihat bahawa, sesungguhnya, banyak ini blocks-- dan sesungguhnya, dalam C banyak functions-- boleh parametrized atau disesuaikan untuk melakukan perkara-perkara yang berbeza. Malah, dalam C jika kita mahu menukar, sekarang, program Scratch ini ke bahasa lain ini, kita akan naik sedikit sesuatu seperti ini. 

Diberikan, terdapat beberapa yang tidak dikenali sintaks terdapat kemungkinan besar, int, dan kurungan, dan tidak sah. Tetapi printf-- walaupun anda akan fikir ia hanya akan menjadi cetak. Tetapi cetak bermakna cetak diformat, kerana kita tidak lama lagi akan melihat. Ini benar-benar akan mencetak ke skrin apa sahaja ada di dalam orang-orang kurungan, yang sudah tentu dalam kes ini adalah, hello dunia. 

Tetapi anda akan melihat beberapa lain sintaksis, beberapa petikan berganda, bahawa kurungan pada akhirnya, separuh kolon dan sebagainya. Jadi ada sedikit overhead, boleh dikatakan, kedua-dua kognitif dan sintaksis, yang kita akan untuk perlu ingat tidak lama lagi. Tetapi sedar bahawa dengan amalan, ini akan mula untuk melompat keluar pada anda. 

Malah, mari kita fokus pada yang satu fungsi specifically-- dalam kes ini, bertanya khabar dunia. Jadi katakan adalah fungsi. Hello dunia adalah parameternya, atau hujah, penyesuaian. 

Dan keseimbangan dalam C hanya akan menjadi satu baris ini di sini, mana printf adalah bersamaan dengan, katakan, rentetan dipetik berganda, hello dunia adalah bersamaan, sudah tentu, dengan apa yang ada di dalam kotak putih di sana. Dan garis sendeng terbalik n, walaupun sedikit pelik dan tidak hadir Awal, hanya akan mempunyai kesan yang kita akan lihat di dalam komputer, seperti Mac saya atau PC, hanya menggerakkan kursor ke baris seterusnya. Ia seperti memukul Enter pada papan kekunci anda. 

Oleh itu, kita akan melihat bahawa sekali lagi tidak lama lagi. Tetapi pertama, mari kita lihat ini contoh lain dalam kes itu gelung. Kami mempunyai ini selama-lamanya gelung masa lalu, yang merupakan satu siri kepingan teka-teki yang melakukan sesuatu yang betul-betul forever-- dalam kes ini, berkata, hello dunia, hello dunia, hello dunia, hello dunia. Jadi ia adalah gelung tak terhingga oleh reka bentuk. 

Dalam C, jika kita ingin melaksanakan ini Idea yang sama, kita hanya boleh melakukan ini. Walaupun benar, printf hello world-- sekarang manakala, hanya semantik, jenis arwah idea melakukan sesuatu sekali lagi, dan sekali lagi, dan sekali lagi, dan untuk berapa lama? Nah, ingat true-- yang benar hanya di atas atau satu. 

Dan yang benar adalah, sudah tentu, sentiasa benar. Jadi ia adalah jenis yang tidak bermakna kenyataan hanya untuk mengatakan benar. Tetapi sesungguhnya, ini adalah sengaja, kerana jika benar adalah hanya sentiasa benar, daripada manakala benar hanya membayangkan, jika sedikit tidak langsung, bahawa garis-garis kod berikut di antara orang-orang pendakap kerinting hanya perlu melaksanakan sekali lagi, dan sekali lagi, dan sekali lagi, dan tidak pernah benar-benar berhenti. 

Tetapi jika anda mahu anda gelung untuk berhenti, seperti yang kita lakukan masa lalu dengan sesuatu seperti ini, mengulangi mengikuti 50 kali, dalam C kita boleh melakukan perkara yang sama dengan apa yang dipanggil untuk loop-- kata kunci yang bukan sementara, tetapi untuk. Dan kemudian kita mempunyai beberapa sintaks baru di sini, dengan int i sama dengan 0, i kurang daripada 50, i ++. Dan kami akan kembali kepada itu. Tetapi ini adalah semata-mata bagaimana kita akan menterjemahkan set blok Scratch kepada satu set garis C kod. 

Sementara itu, pertimbangkan pembolehubah. Dan, sebenarnya, kita hanya melihat seorang sebentar tadi. Dan dalam kes Scratch, jika kita mahu mengisytiharkan pembolehubah yang dipanggil i untuk i sebagai integer, hanya nombor, dan kami mahu menetapkan ia untuk beberapa nilai, kita akan menggunakan oren ini menyekat sini-- menetapkan i kepada 0. 

Dan kita akan melihat hari ini dan di luar, sama seperti minggu lepas, pengaturcara melakukan hampir sentiasa mula mengira dari sifar, benar-benar oleh konvensyen. Tetapi juga kerana ingat dari perbincangan kita tentang binari, nombor yang paling kecil yang anda boleh mewakili dengan apa-apa bilangan bit hanya akan menjadi 0 sendiri. Dan supaya kita biasanya akan mula Memulakan walaupun pembolehubah kami kepada 0. 

Dan dalam C untuk melakukan perkara yang sama, kita akan mengatakan int untuk integer, i hanya dengan konvensyen. Saya boleh dipanggil pembolehubah ini apa-apa yang saya mahu, seperti dalam Scratch. Dan kemudian bersamaan dengan 0 hanya penerima serah hak nilai 0 dari kanan dan meletakkan ia ke dalam pembolehubah, atau bekas penyimpanan di sana, di sebelah kiri. Dan koma bertitik seperti yang kita akan see-- dan kita telah melihat beberapa already-- ini hanya bermakna akhir pemikiran. Meneruskan untuk melakukan sesuatu yang lain di barisan yang mengikuti. 

Sekarang, bagaimana pula dengan ungkapan Boolean? Ingat bahawa dalam Scratch, ini adalah ungkapan yang sama ada benar atau soalan false--, benar-benar, yang sama ada benar atau palsu. Jadi dalam kes Awal, kita mungkin bertanya satu soalan yang mudah seperti ini, adalah i kurang daripada 50? Jadi saya, sekali lagi, adalah integer. Mungkin kita menggunakannya dalam program Scratch untuk mengesan skor yang atau sesuatu seperti itu. Jadi sintaks ini di sini dalam Scratch hanya bermakna, adalah i kurang daripada 50? Well, bersyukur, sesuatu yang tidak mudah dalam C. Dan untuk menterjemah, ini kita hanya akan berkata i kurang daripada 50, dengan menggunakan kunci biasa pada papan kekunci anda. 

Sementara itu, jika anda mahu mengatakan sesuatu yang lebih umum, seperti, baik, adalah x kurang daripada y di mana setiap x dan y adalah diri mereka pembolehubah? Kita boleh melakukan perkara yang sama dalam C, selagi kita ada dicipta pembolehubah ini sudah. Dan kita akan melihat bagaimana untuk berbuat demikian tidak lama lagi. Kami hanya akan mengatakan x kurang daripada y. 

Jadi anda mula melihat beberapa persamaan. Dan orang-orang yang membuat Scratch sudah tentu diilhamkan oleh beberapa idea-idea asas. Dan anda akan melihat jenis ini sintaks dalam banyak languages-- bukan hanya Scratch, tidak hanya C, tetapi Python, dan JavaScript, dan bahasa lain masih. 

Mari kita pertimbangkan konstruk lain daripada C, tanggapan keadaan, melakukan sesuatu yang bersyarat. Jika ada sesuatu yang benar, melakukan ini. Jika sesuatu yang lain adalah benar, berbuat demikian. Ia semacam pengaturcaraan bersamaan dengan garpu di jalan raya. Mungkin ia adalah dua hala garpu, tiga hala garpu, atau lebih. Dan dalam Scratch, kita mungkin mempunyai melihat sesuatu seperti ini. 

Jadi yang satu ini adalah satu besar. Tetapi dengan menimbangkan relatif kesederhanaan logik. Jika x kurang daripada y, maka katakanlah x kurang daripada y, lain jika x lebih besar daripada y, maka katakanlah x lebih besar daripada y. Dan kemudian, secara logiknya, jika anda berfikir kembali kepada Scratch atau hanya gerak hati manusia anda sendiri, baik, jika x tidak lebih besar daripada y, dan x tidak kurang daripada y, maka sudah tentu x akan sama dengan y. Jadi dalam kes ini, oleh bersarang orang-orang blok Awal, kita boleh mencapai tiga cara garpu di jalan raya? 

Sementara itu, jika kita mahu melakukannya dalam C, ia boleh dikatakan kelihatan simpler-- sedikit sekurang-kurangnya sebaik sahaja anda mendapatkan biasa dengan sintaks. Jika x kurang daripada y, printf x kurang daripada y. Lain jika x lebih besar daripada y, printf x lebih besar daripada y. Else printf x adalah sama dengan y-- dan, sekali lagi, dengan orang-orang garis sendeng terbalik berakhir hanya bagi mereka barisan baru supaya jika anda sebenarnya berlari jenis ini program ia hanya akan bergerak kursor anda akhirnya ke baris seterusnya skrin. 

Sekarang, sementara itu Scratch memperanakkan ciri yang lebih canggih, hanya ada yang kita akan pada mulanya bergerak ke dunia C. Dan salah seorang daripada mereka adalah dipanggil senarai dalam Scratch. Dan ini adalah khas jenis pembolehubah yang dibenarkan anda untuk menyimpan pelbagai perkara di dalamnya belakang, ke belakang, ke belakang, ke belakang. 

Dalam C, ia tidak mempunyai senarai, per se, tetapi sesuatu yang lebih umum dipanggil array, walaupun kami kembali kemudian semester ini untuk melihat sesuatu dipanggil senarai, atau benar-benar senarai berpaut. Tetapi untuk sekarang, yang paling dekat setara dalam C untuk kita akan menjadi sesuatu dipanggil array. Dan lokasi yang hanya satu jenis khas berubah-ubah yang membolehkan anda untuk menyimpan data belakang, ke belakang, ke belakang, ke belakang. 

Dan, sememangnya, dalam Scratch, jika kita mahu untuk mengakses elemen pertama array atau yang list-- dan saya akan memanggilnya, oleh konvensyen, argv, hujah vektor, tetapi lebih kepada yang tidak lama lagi. Jika saya mahu untuk mendapatkan sekurang-elemen pertama argv, dalam dunia Scratch anda sebenarnya melakukan biasanya mula mengira dari 1. 

Oleh itu, saya mungkin akan mendapat item 1 argv. Itu hanya bagaimana MIT dilaksanakan tanggapan senarai. Tetapi dalam C, saya akan lebih mudah hanya berkata, argv, yang sekali lagi adalah nama saya list-- atau perlu jelas, array. Dan jika saya mahu pertama unsur-unsur, saya akan menggunakan tanda kurung siku, yang anda mungkin tidak sering digunakan di bawah papan kekunci. 

Tetapi 0 hanya bermakna, dapatkan saya yang pertama. Maka pada kesempatan dan sebagai masa berlalu, kita akan untuk mula melihat dikotomi ini antara Gores dan C, mana Scratch menggunakannya. Kami di C menggunakan 0 di sini. Tetapi anda akan melihat dengan cepat sebaik sahaja anda memahami asas-asas setiap bahasa, yang perkara-perkara ini mula mendapat semua lebih biasa melalui amalan dan amalan. 

Jadi mari kita sebenarnya melihat di program. Di sini akan menjadi yang pertama C kami Kod sumber untuk program lengkap. Dan program ini kita akan untuk menawarkan untuk pertimbangan adalah salah satu yang bersamaan untuk sekeping Scratch lebih awal. 

Jadi di sini, kita mempunyai apa yang boleh dikatakan program C yang paling mudah anda boleh menulis bahawa sebenarnya melakukan sesuatu. Sekarang, kita akan melihat masa lalu, buat masa ini, telah termasuk, io.h standard, dan sudut ini kurungan, dan int, dan tidak sah, dan pendakap kerinting, dan sebagainya. 

Dan mari kita hanya memberi tumpuan kepada apa, sekurang-kurangnya secara intuitif, mungkin melompat keluar pada anda sudah. Malah, utama, saya tidak semestinya tahu apa ini, tetapi sama seperti Scratch mempunyai bahawa apabila bendera hijau diklik sekeping teka-teki, begitu juga C sebagai bahasa pengaturcaraan mempunyai sebidang utama kod yang mendapat dilaksanakan secara lalai. Dan, sememangnya, ia secara literal akan dipanggil utama. 

Jadi utama adalah fungsi. Dan ia adalah satu majlis khas yang wujud dalam C yang apabila anda menjalankan program, ia adalah utama yang mendapat dikendalikan oleh lalai. Dalam dunia Awal, ia biasanya apabila bendera hijau klik yang tidak perlu lagi berjalan secara lalai. 

Sementara itu, kita lihat sebelum ini, printf atau cetakan diformat, itu akan menjadi satu fungsi yang datang dengan C, bersama-sama dengan sejumlah besar orang lain, bahawa kehendak dari semasa dan masa lagi, untuk melakukan perkara seperti namanya, mencetak sesuatu. Apa yang kita mahu untuk mencetak? Nah, kita akan melihat bahawa oleh watak-watak melampirkan seperti these-- dunia hello, garis sendeng terbalik n dalam tanda petik, kita boleh memberitahu printf tepat apa untuk mencetak pada skrin. 

Tetapi untuk melakukan itu, kita malangnya perlu sesuatu yang sudah samar kepada kita manusia, tetapi sekurang-kurangnya ia agak readable-- tajam termasuk, io.h standard, int, utama, tidak sah, printf, semua ajaib jampi kita hanya melihat pada skrin. Tetapi kita sebenarnya perlu pergi lebih sukar difahami masih. Mula-mula kita perlu untuk menterjemahkan kod di kita harus menulis surat kepada kod mesin. Dan ingat dari minggu lepas bahawa mesin, sekurang-kurangnya orang-orang yang kita kenali di sini, pada akhir hari sahaja memahami sifar dan satu. 

Allahku, jika kita terpaksa menulis ini sifar dan orang-orang yang sebenarnya program, ia akan sangat, sangat cepat mengambil keseronokan daripada apa-apa. Tetapi ternyata, seminggu lalu, bahawa corak sifar dan satu hanya mempunyai makna khas. Dalam konteks yang tertentu, mereka mungkin bermakna nombor. 

Dalam sesetengah konteks, ia mungkin bermakna huruf, atau warna, atau apa-apa bilangan daripada abstrak lain di sana atas. Tetapi hanya kerana komputer anda mempunyai CPU, Unit Pemprosesan Pusat, atau otak dalam komputer anda. Ia biasanya Intel di dalam, kerana itulah salah satu daripada syarikat terbesar yang membuat CPU untuk komputer. 

Well, CPU Intel dan lain-lain hanya telah membuat keputusan lebih awal bahawa corak tertentu sifar dan yang bermaksud perkara-perkara tertentu. corak tertentu sifar dan satu bermakna, mencetak ini kepada skrin, atau menambah dua nombor, atau tolak dua nombor, atau memindahkan sekeping data dari memori komputer saya di sini, atau apa-apa bilangan tahap yang sangat rendah yang lain, tetapi akhirnya berguna, operasi. Tetapi, bersyukur, kita manusia tidak akan untuk perlu tahu tahap ini lanjut. Malah, sama seperti masa lalu, di mana kita cabutan lagi, dan lagi, dan lagi, bangunan daripada tahap yang sangat rendah primitif seperti sifar dan satu kepada konsep tahap yang lebih tinggi seperti nombor dan huruf, dan warna, dan banyak lagi, supaya boleh kita sebagai pengaturcara berdiri di atas bahu orang lain yang datang sebelum kita dan menggunakan perisian yang lain penulis telah menulis sebelum us-- iaitu program yang dikenali sebagai penyusun. 

C ialah bahasa yang biasanya disusun, yang bermaksud ditukar dari kod sumber kepada kod mesin. Khususnya, apa yang dimaksudkan adalah bahawa jika anda mempunyai sumber anda Kod yang anda sendiri menulis, kerana kita tidak lama lagi akan dalam hanya seketika pada skrin, dan anda mahu menukar akhirnya untuk mesin code-- orang-orang sifar dan orang-orang yang hanya Mac atau PC anda understands-- anda telah mendapat pertama memberi makan kepada kod sumber sebagai input kepada yang istimewa program dipanggil pengkompil, output yang mana kami akan lihat adalah kod mesin. Dan, sememangnya, kali terakhir kita bercakap kira-kira, benar-benar, pada akhir hari, penyelesaian masalah. Anda telah mendapat input. Dan anda telah mendapat output. Dan anda telah mendapat beberapa jenis algoritma di tengah-tengah. 

Algoritma pasti boleh menjadi dilaksanakan dalam perisian, seperti yang kita lihat dengan kod pseudo minggu lepas dan seperti yang kita akan lihat dengan kod sebenar minggu ini. Dan supaya pengkompil benar-benar hanya mempunyai satu set algoritma dalam itu yang tahu bagaimana untuk menukar kata kunci khas, seperti utama, dan printf, dan lain-lain yang kita hanya melihat ke dalam corak sifar dan orang-orang yang Intel dalam dan lain CPU sebenarnya memahami. Jadi bagaimana kita melakukan ini? Di mana kita mendapatkan pengkompil? 

Sebahagian besar daripada kita di sini mempunyai Mac atau PC. Dan anda menjalankan Mac OS, atau Windows atau Linux, atau Solaris, atau apa-apa bilangan lain sistem operasi. Dan, sememangnya, kita boleh pergi keluar ke web dan muat turun pengkompil untuk Mac anda atau PC anda untuk sistem operasi tertentu anda. Tetapi kita semua akan berada di muka surat yang berbeza, jadi untuk bercakap. Kita akan mempunyai sedikit konfigurasi yang berlainan. Dan apa yang akan berhasil semua yang sama. Dan sesungguhnya, hari ini ramai di antara kita tidak menggunakan perisian yang berjalan hanya pada komputer riba kami. Sebaliknya, kita menggunakan sesuatu seperti pelayar yang membolehkan kita untuk mengakses web berasaskan aplikasi dalam awan. Dan kemudian semester ini, kami akan melakukan perkara tersebut. Kami akan menulis aplikasi atau perisian tidak menggunakan code-- C, tetapi bahasa lain seperti Python dan JavaScript-- yang berjalan di awan. 

Dan untuk berbuat demikian, kita sendiri pada semester sebenarnya akan menggunakan awan berasaskan persekitaran dikenali sebagai CS50 IDE. Ini adalah program berasaskan web alam sekitar, atau pembangunan bersepadu alam sekitar, IDE, yang dibina di atas beberapa perisian sumber terbuka yang dikenali sebagai Cloud 9. Dan kita telah membuat beberapa pedagogi pemudahan kepadanya supaya dapat menyembunyikan ciri-ciri tertentu dalam minggu-minggu pertama yang kita tidak perlu, selepas itu anda boleh mendedahkan mereka dan melakukan kebanyakan apa sahaja yang anda mahu dengan alam sekitar. 

Dan ia membolehkan kita, juga, untuk sebelum memasang perisian tertentu. Perkara seperti apa yang dipanggil CS50 perpustakaan, yang kita tidak lama lagi akan melihat menyediakan kami dalam C dengan beberapa fungsi tambahan. Jadi, jika anda pergi ke akhirnya CS50.io, anda akan digesa untuk log masuk, dan sebaik sahaja anda lakukan dan mewujudkan akaun secara percuma, anda akan dapat untuk mengakses yang persekitaran yang kelihatan agak seperti ini. 

Sekarang, ini adalah dalam mod lalai. Segala-galanya adalah baik dan terang pada skrin. Ramai di antara kita mempunyai tabiat bekerja di atas sekeping CS50 itulah agak lewat malam. Dan supaya sebahagian daripada anda mungkin lebih suka untuk mengubahnya menjadi mod malam, jadi untuk bercakap. 

Tetapi, akhirnya, apa yang anda akan melihat dalam CS50 IDE adalah tiga areas-- berbeza kawasan di mana sebelah kiri fail anda akan berada di dalam awan, kawasan di sebelah kanan atas di mana kod anda akan menjadi disunting. Anda akan dapat untuk membuka tab individu untuk mana-mana program yang anda tulis semester ini di dalam itu bahagian atas sebelah kanan. Dan kemudian paling arcanely, dan lagi kuat, akan menjadi perkara ini di bawah dikenali sebagai tetingkap terminal. 

Ini adalah sekolah lama Line Interface perintah, atau CLI, yang membolehkan anda untuk melaksanakan arahan pada computer-- dalam kes ini, komputer dalam cloud-- untuk melakukan perkara seperti menyusun kod anda dari kod sumber kepada kod mesin, untuk menjalankan program anda, atau untuk memulakan anda pelayan web, atau untuk mengakses pangkalan data anda, dan apa-apa bilangan teknik-teknik lain bahawa kita akan mula menggunakan tidak lama lagi. Tetapi untuk sampai ke sana, kami akan benar-benar mempunyai untuk pergi ke dalam talian dan mula bermain. Dan untuk itu, mari kita pertama mula tinkering dengan utama, dan menulis bahagian utama program. Dan mari kita menggunakan fungsi yang printf, yang kita digunakan sebelum ini, semata-mata untuk mengatakan sesuatu. 

Jadi di sini saya sudah di dalam CS50 IDE. Saya sudah log masuk terlebih dahulu. Dan saya penuh ditayangkan tingkap. Dan sebagainya, akhirnya, anda terlalu dalam masalah akan datang akan mengikuti langkah yang sama yang akan menyediakan dokumentasi dalam talian. Jadi anda tidak perlu bimbang tentang menyerap setiap langkah teknikal sedikit yang saya lakukan di sini hari ini. 

Tetapi anda akan mendapat skrin seperti ini. Saya berada dalam mod malam. Dan anda boleh mencerahkan segala-galanya sehingga dengan mematikan mod malam. Dan pada akhir hari, anda akan melihat tiga utama areas-- fail pelayar di sebelah kiri, tab kod sehingga atas, dan tetingkap terminal di bahagian bawah. 

Biar saya pergi ke hadapan dan menulis program pertama saya. Saya akan preemptively pergi ke Fail, Menyimpan, dan simpan fail saya sebagai hello.c. Malah, oleh konvensyen, apa-apa program yang kita menulis yang ditulis dalam bahasa C patut dinamakan sesuatu dot c, oleh konvensyen. Jadi saya akan menamakannya hello.c, kerana Saya hanya mahu mengucapkan salam kepada dunia. Sekarang saya akan untuk zum keluar dan klik Simpan. Dan semua saya ada di sini sekarang ialah tab di mana saya boleh mula kod menulis. 

Ini tidak akan menyusun. Ini bermakna apa-apa. Dan sebagainya walaupun saya ditukar ini kepada sifar dan satu, CPU akan tidak mempunyai idea apa yang berlaku di sekeliling. Tetapi jika saya menulis ayat yang tidak sepadan perkembangan C makhluk conventions-- C, sekali lagi, ini language-- dengan sintaks seperti ini, printf hello world-- dan saya telah mendapat selesa dengan melakukan ini dari masa ke masa. Jadi, saya tidak rasa saya membuat sebarang kesilapan tipografi. 

Tetapi, setiap kali, yang pertama kali anda melakukan ini, anda akan. Dan apa yang saya kira-kira untuk melakukan mungkin sangat baik tidak bekerja untuk anda kali pertama. Dan itu sempurna OK, kerana sekarang anda hanya mungkin melihat banyak keseluruhan kebaharuan, tetapi dari masa ke masa apabila anda membiasakan diri dengan persekitaran ini, dan bahasa ini, dan lain-lain, anda akan mula melihat perkara-perkara yang sama ada betul atau tidak betul. 

Dan ini adalah apa yang felo pengajaran dan kursus pembantu mendapatkan begitu baik pada masa ke masa, adalah mengesan kesilapan atau pepijat dalam kod anda. Tetapi saya mendakwa bahawa terdapat ada bug dalam kod ini. Jadi saya kini mahu menjalankan program ini. 

Sekarang pada Mac saya sendiri atau PC, saya dalam tabiat ikon klik dua kali apabila saya ingin menjalankan beberapa program. Tetapi itu bukan model itu di sini. Dalam persekitaran ini, yang CS50 IDE. Kami menggunakan operasi yang sistem dipanggil Linux. Linux mengingatkan lain sistem operasi, umumnya dikenali sebagai Unix. Dan Linux adalah terutamanya terkenal dengan mempunyai satu line Alam Sekitar Command, CLI. Sekarang, kita menggunakan tertentu yang rasa Linux dipanggil Ubuntu. Dan Ubuntu hanya satu versi tertentu Linux. 

Tetapi hari ini ini Linux buat sebenarnya datang dengan antara muka pengguna grafik. Dan yang kita berlaku menggunakan di sini adalah berasaskan web. Jadi ini mungkin kelihatan walaupun sedikit berbeza daripada sesuatu anda sendiri mungkin mempunyai dilihat atau menjalankan pada masa lalu. 

Jadi, saya akan pergi ke hadapan sekarang dan melakukan yang berikut. Saya telah menyimpan fail ini sebagai hello.c. Saya akan pergi ke hadapan dan jenis clanghello.c Jadi dilafaz untuk bahasa C pengkompil. Ia diprapasang dalam CS50 IDE. Dan anda benar-benar boleh memuat turun dan memasang ini pada Mac anda sendiri atau PC. 

Tetapi, sekali lagi, anda tidak akan mempunyai semua pra-konfigurasi dilakukan untuk anda. Jadi buat masa ini, saya hanya akan berjalan clanghello.c. Dan kini melihat sintaks ini di sini akan akhirnya sedar hanya bermakna bahawa saya dalam satu folder atau direktori dipanggil Workspace. Ini tanda dolar hanya konvensyen makna, taipkan arahan di bandar. 

Ia adalah apa yang dipanggil segera, hanya oleh konvensyen adalah tanda dolar. Dan jika saya pergi ke hadapan sekarang dan klik Enter, tiada apa yang berlaku. Tetapi itu sebenarnya satu perkara yang baik. Yang kurang yang berlaku di skrin anda, semakin besar kemungkinan kod anda adalah sebagai betul, sekurang-kurangnya sintaksis. 

Jadi jika saya mahu menjalankan ini program, apa yang saya lakukan? Nah, ternyata bahawa nama lalai oleh konvensyen untuk program apabila anda tidak menentukan menamakan untuk program anda adalah hanya a.out. Dan sintaks ini juga, anda akan membiasakan diri dengan tidak lama lagi. 

Dot mengurangkan hanya bermakna, hey, CS50 IDE, menjalankan program yang dipanggil a.out yang di dalam direktori semasa saya. dot bermakna direktori semasa. Dan kita akan melihat apa yang lain seperti urutan aksara bermakna tidak lama lagi. 

Jadi di sini kita pergi, Masukkan, hello dunia. Dan anda akan melihat, apa yang berlaku? Bukan sahaja ia mencetak hello dunia. Ia juga berpindah kursor ke baris seterusnya. 

Dan mengapa itu? Apakah kod yang kita menulis sebelum yang memastikan kursor akan pergi pada baris berikutnya? Perkara yang melucukan tentang komputer adalah ia hanya akan lakukan betul-betul apa yang anda beritahu ia lakukan. 

Jadi, jika anda beritahu kepada printf hello, koma, ruang, dunia, quote dekat, ia secara literal hanya akan untuk mencetak mereka watak-watak. Tetapi saya mempunyai watak istimewa ini pada akhir, ingat, garis sendeng terbalik n. Dan itulah yang memastikan bahawa watak pergi ke baris seterusnya skrin. 

Malah, saya pergi dan melakukan ini. Biar saya pergi ke hadapan dan memadam ini. Sekarang, perhatikan bahawa bahagian atas skrin saya ada lampu merah sedikit tab yang menunjukkan, hey, anda telah tidak disimpan fail anda. Jadi, saya akan pergi ke hadapan dengan kawalan S atau perintah S, menyimpan fail. Kini ia goes-- pergi untuk hijau moment--. Dan sekarang ia kembali ke hanya menjadi ikon rapat. 

Jika saya kini menjalankan clanghello.c lagi, Enter, slash dot, a.out, Masukkan, anda akan melihat bahawa ia masih bekerja. Tetapi ia boleh dikatakan kereta kecil. Buat masa ini, ruang kerja prompt-- saya, dan maka itu tanda dolar, dan kemudian prompt-- sebenar saya adalah semua pada baris yang sama. Jadi ini pasti bug estetik, walaupun ia tidak benar-benar bug logik. 

Jadi saya akan membatalkan apa yang saya lakukan. Saya akan menjalankan semula a.out. Notis yang saya telah menambah newline watak kembali. Saya telah menyimpan fail. 

Jadi, saya akan menjalankan semula a.out, dan- keparat, bug, pepijat yang bermaksud tidak sengaja. Jadi bug adalah bahawa walaupun Saya tambah garis sendeng terbalik n di sana, semula disimpan, semula berlari program ini, tingkah laku adalah sama. Mengapa yang akan? 

Saya hilang langkah, bukan? Bahawa langkah utama sebelum ini adalah bahawa anda mempunyai supaya- apabila anda menukar kod sumber anda, ternyata juga menjalankan melalui pengkompil lagi supaya anda mendapat kod mesin baru. Dan kod mesin, sifar dan orang-orang yang, akan menjadi hampir sama, tetapi tidak sempurna begitu, kerana kita perlukan, sudah tentu, bahawa barisan baru. 

Jadi untuk menetapkan ini, saya akan memerlukan untuk menjalankan semula clanghello.c, masukkan, dot slash, a.out. Dan kini, hello dunia kembali di mana saya mengharapkan ia menjadi. Jadi ini adalah semua baik dan baik. Tetapi a.out adalah nama yang cukup bodoh untuk program, walaupun ia berlaku untuk menjadi, atas sebab-sebab sejarah, default-- bermaksud output pemasangan. 

Tetapi biarlah saya pergi ke hadapan di sini dan melakukan ini berbeza. Saya mahu program hello dunia saya untuk benar-benar dipanggil hello. Jadi, jika ia adalah ikon pada saya desktop, ia tidak akan a.out. Ia akan dipanggil hello. 

Jadi untuk melakukan ini, ternyata yang dilafaz, seperti banyak program, menyokong hujah baris arahan, atau bendera, atau suis, yang hanya mempengaruhi tingkah laku. Secara khusus, dilafaz menyokong sengkang o bendera, yang kemudiannya mengambil perkataan kedua. Dalam kes ini, saya sewenang-wenangnya akan, tetapi munasabah, memanggilnya hello. Tetapi saya boleh memanggilnya apa-apa Saya mahu, kecuali a.out, yang akan menjadi agak selain titik. 

Dan kemudian hanya nyatakan nama fail saya ingin menyusun. Jadi sekarang walaupun pada permulaan arahan yang saya masih perlu dilafaz, pada akhir arahan Saya masih mempunyai nama fail, Saya kini mempunyai ini baris arahan hujah, bendera ini yang berkata, oh, dengan cara itu, output-o, fail dipanggil hello, tidak a.out lalai. 

Jadi, jika saya tekan Enter kini, tiada apa yang seolah-olah telah berlaku. Dan, lagi, sekarang saya boleh melakukan slash dot hello. Jadi ia adalah program yang sama. Sifar dan orang-orang yang sama pada akhir hari. 

Tetapi mereka berada dalam dua a.out files-- berbeza, yang merupakan versi pertama dan hanya bodoh dinamakan, dan kini hello, yang merupakan lebih lebih nama yang menarik untuk program. Tetapi, jujur, saya tidak pernah saya sedang akan ingat ini lagi, dan sekali lagi, dan lagi. Dan, sebenarnya, seperti yang kita menulis program yang lebih rumit, arahan anda akan mempunyai untuk menulis akan mendapatkan lebih lebih rumit masih. 

Dan sebagainya tidak perlu bimbang. Ia ternyata bahawa manusia sebelum kami telah sedar mereka juga mempunyai masalah ini sama. Mereka juga tidak menikmati perlu menaip agak panjang, perintah batin, apatah lagi mengingati mereka. Dan supaya manusia sebelum kita telah membuat program lain yang membuat ia lebih mudah untuk menyusun perisian anda. 

Dan, sememangnya, satu itu program dipanggil Make. Jadi, saya akan pergi ke hadapan dan melakukan ini. Saya akan membatalkan semua yang saya hanya melakukan dengan cara yang berikut. Biar saya taip LS. Dan anda akan melihat tiga things-- a.out, dan bintang, hello dan bintang, dan hello.c. Mudah-mudahan, ini sepatutnya menjadi sedikit intuitif, setakat yang sebelum ini terdapat apa-apa dalam ruang kerja ini. Ada apa-apa yang saya ada dicipta sehingga kami mula kelas. 

Dan saya dicipta hello.c. Saya kemudian disusun, dan memanggilnya a.out. Dan kemudian saya disusun sekali lagi sedikit berbeza dan memanggilnya hello. Jadi saya mempunyai tiga fail dalam direktori ini, di dalam folder ini dipanggil Workspace. Sekarang, saya dapat melihat bahawa di samping jika saya zum keluar sebenarnya. 

Jika saya zum keluar di sini dan melihat bahawa tangan kanan atas sudut, seperti yang dijanjikan kiri sebelah atas skrin anda sentiasa akan menunjukkan kepada anda apa yang dalam akaun anda, apa yang bahagian dalam CS50 IDE. Dan ada tiga fail sana. 

Jadi saya mahu menghilangkan a.out dan hello. Dan seperti yang anda mungkin bayangkan intuitif, anda boleh menyusun klik kawalan atau klik kanan pada ini. Dan menu kecil ini timbul. Anda boleh memuat turun fail, jalankan ia, pratonton, muat semula, menamakan semula, atau apa yang tidak. 

Dan saya hanya boleh memadam, dan ia akan pergi. Tetapi mari kita melakukan sesuatu dengan perintah talian buat masa ini, untuk mendapatkan selesa dengan ini, dan melakukan yang berikut. Saya akan pergi ke hadapan dan keluarkan a.out dengan menaip literal rma.out. Ternyata, perintah untuk mengeluarkan atau memadam sesuatu, tidak mengeluarkan atau memadam. 

Ia lebih ringkas RM, hanya untuk menyelamatkan anda beberapa ketukan kekunci, dan tekan Enter. Sekarang kita akan menjadi agak cryptically mengeluarkan a.out fail biasa. Saya tidak benar-benar tahu apa yang fail yang tidak teratur akan menjadi lagi. Tetapi saya mahu mengeluarkannya. 

Jadi, saya akan menaip y bagi ya. Atau saya boleh taipkan ia keluar, dan tekan Enter. Dan, sekali lagi, tiada apa yang berlaku. Tetapi itu adalah, secara umumnya, perkara yang baik. 

Jika saya menaip LS masa ini, apa yang perlu saya lihat? Mudah-mudahan, hanya khabar dan hello.c. Sekarang, sebagai diketepikan, anda akan notis bintang ini, asterisk, itulah pada akhir program saya. Dan mereka juga muncul dalam hijau. Itu baru cara CS50 IDE ini daripada cluing anda ke dalam hakikat bahawa itu bukan kod sumber. Itulah laksana, yang runnable program yang anda sebenarnya boleh menjalankan dengan melakukan slash dot, dan kemudian ia nama. 

Sekarang, biarlah saya pergi ke hadapan dan mengeluarkan ini, rm hello, Masukkan, keluarkan biasa memfailkan hello, ya. Dan sekarang saya menaip LS, kami kembali ke hello.c. Cuba untuk tidak memadam anda kod sumber yang sebenar. Walaupun terdapat ciri-ciri dibina ke CS50 IDE mana anda boleh pergi melalui sejarah semakan anda dan putar balik dalam masa jika anda secara tidak sengaja memadam sesuatu, jangan ingat seperti arahan ini ya atau tidak, apa yang anda benar-benar mahu lakukan. Dan jika saya pergi ke bahagian atas meninggalkan sudut di sini, semua yang tinggal adalah hello.c. Jadi ada tandan arahan lain yang anda boleh melaksanakan dalam dunia Linux, satu daripadanya adalah, sekali lagi, Make. Dan kita akan Selesakan program saya sekarang seperti berikut. 

Daripada melakukan dilafaz, daripada melakukan dilafaz-o, Saya akan hanya literal menaip, membuat hello. Dan kini melihat, saya tidak menaip membuat hello.c. Saya sedang menaip membuat hello. 

Dan program ini Buat yang datang dengan IDE CS50, dan banyak lagi biasanya dengan Linux, adalah satu program yang yang akan membuat program yang dikenali sebagai Hello. Dan ia akan menganggap, oleh konvensyen, bahawa jika program ini boleh dibuat, ia akan dibuat dari sumber yang fail kod yang berakhir dengan dot c, hello.c. 

Jadi, jika saya tekan Enter sekarang, melihat bahawa arahan yang mendapat dilaksanakan sebenarnya lebih lama lagi sebelum daripada sebelum ini. Dan itu kerana kami telah dipratatarajahkan CS50 IDE untuk mempunyai beberapa ciri-ciri tambahan yang dibina pada yang kita tidak perlu lagi, tetapi tidak lama lagi akan. Tetapi perkara utama untuk merealisasikan kini saya mempunyai program Hello. 

Jika saya menaip LS lagi, saya mempunyai program hello. Dan saya boleh berjalan dengan dot slash a.out, tidak, kerana titik keseluruhan ini pelaksanaan adalah dot slash hello. Dan kini saya mempunyai program hello dunia saya. Jadi bergerak ke hadapan, kami hampir sentiasa hanya akan menyusun program kami menggunakan Make arahan. Dan kemudian kita akan menghadapi mereka dengan dot slash, dan nama program. Tetapi sedar apa Make lakukan untuk anda, adalah ia tidak sendiri pengkompil. Ia hanya satu program mudah yang tahu bagaimana untuk mencetuskan pengkompil untuk menjalankan supaya anda sendiri boleh menggunakannya. 

Apa arahan lain wujud dalam Linux, dan seterusnya CS50 IDE? Tidak lama lagi kita akan melihat bahawa terdapat arahan CD, Tukar Directory. Ini membolehkan anda dalam tempoh antara muka baris arahan anda untuk bergerak ke hadapan, dan belakang, dan membuka folder yang berbeza tanpa menggunakan tetikus anda. 

LS kita lihat, yang bermaksud senarai fail-fail dalam direktori semasa. Membuat Dir, anda boleh mungkin mula untuk membuat kesimpulan apa ini bermakna sekarang-- membuat direktori, jika anda mahu mewujudkan folder. RM untuk keluarkan, RM Dir untuk keluarkan directory-- dan ini, lagi, adalah baris arahan setara yang boleh lakukan dalam CS50 IDE dengan tetikus anda. Tetapi anda tidak lama lagi akan yang kadang-kadang ia hanya banyak yang lebih cepat untuk melakukan perkara dengan papan kekunci, dan akhirnya banyak yang lebih kuat. 

Tetapi ia sukar untuk berhujah bahawa apa-apa yang kita telah lakukan setakat ini adalah semua yang berkuasa, apabila semua kita telah berkata iaitu, hello dunia. Dan, sebenarnya, saya dikodkeraskan yang kata-kata hello dunia ke dalam program saya. Tiada dinamik lagi. Scratch adalah suatu perintah magnitud lebih menarik minggu lepas. 

Dan jadi mari kita sampai ke sana. Mari kita langkah ke arah dengan cara beberapa fungsi-fungsi ini. Jadi bukan sahaja C datang dengan printf, dan tandan fungsi lain ada yang kita akan melihat dari masa ke masa, ia tidak membuat ia semua yang mudah hak keluar pintu gerbang dalam mendapatkan input pengguna. 

Malah, salah satu kelemahan bahasa seperti C, dan juga Java dan lagi lain, adalah bahawa ia tidak menjadikannya mudah untuk hanya mendapatkan perkara-perkara seperti integer daripada pengguna, atau tali, kata-kata, dan frasa, membiarkan perkara sahaja seperti terapung mata yang, atau nombor nyata dengan titik perpuluhan, dan benar-benar nombor lama, kerana kita tidak lama lagi akan melihat. Jadi senarai ini fungsi sini, ini seperti kepingan teka-teki Scratch lain bahawa kita mempunyai pra-dipasang di CS50 IDE yang kami akan gunakan untuk beberapa minggu roda latihan pelbagai, dan akhirnya membawa mereka keluar dan melihat di bawah hood, mungkin, di bagaimana perkara-perkara ini dilaksanakan. 

Tetapi untuk melakukan ini, mari kita sebenarnya menulis program. Biar saya pergi ke hadapan sekarang. Dan saya akan untuk mewujudkan baru memfailkan dengan mengklik plus kecil ini, dan mengklik Fail Baru. 

Saya akan menyimpan ini akan datang orang yang demikian, katakan, string.c, kerana saya mahu bermain dengan tali. Dan rentetan dalam C hanya jujukan aksara. Jadi sekarang mari kita pergi ke hadapan dan melakukan yang berikut. 

Termasuk standard IO.h-- dan ternyata standard IO, IO hanya bermakna input dan output. Jadi ia ternyata bahawa garis ini di sini adalah apa yang adalah jiran kita untuk menggunakan printf. Printf, sudah tentu, menghasilkan output. Jadi untuk menggunakan printf, ternyata daripada anda perlu mempunyai baris ini kod di bahagian atas fail anda. 

Dan kita akan kembali kepada apa yang yang benar-benar bermakna tidak lama lagi. Ia ternyata bahawa dalam mana-mana program C I menulis, Saya telah mendapat untuk memulakan dengan kod yang kelihatan seperti ini. Dan anda akan melihat CS50 IDE, dan pembangunan bersepadu yang lain persekitaran seperti itu, akan cuba sebaik mereka boleh untuk menyelesaikan pemikiran anda. Malah, masa yang lalu jika saya membatalkan apa yang saya lakukan, saya tekan Enter. 

Saya kemudian memukul kerinting terbuka brace, tekan Enter lagi. Dan ia selesai pemikiran saya. Ia memberikan saya barisan baru, berengsot tidak kurang atas sebab-sebab gaya yang bagus kita akan melihat. Dan kemudian ia secara automatik memberikan saya yang bersedia kerinting untuk menyelesaikan pemikiran saya. Kini, ia tidak selalu meneka apa yang anda mahu lakukan. Tetapi sebahagian besar, ia menjimatkan beberapa ketukan kekunci. Jadi masa yang lalu, kita berlari program-- ini hello, dunia, dan kemudian disusun ia, dan kemudian berlari. Tetapi tidak ada dinamik di sini. Bagaimana jika kita mahu melakukan sesuatu yang berbeza? Nah, bagaimana jika saya mahu untuk benar-benar mendapatkan rentetan daripada pengguna? Saya akan menggunakan sekeping teka-teki dipanggil tepat bahawa- mendapatkan tali. 

Rupa-rupanya, dalam C yang apabila anda tidak mahu untuk memberi input kepada sekeping teka-teki, atau lebih baik untuk fungsi, anda literal hanya melakukan kurungan terbuka, kurungan rapat. Jadi ia seolah-olah ada tiada kotak putih untuk menaip ke dalam. Blok katakan sebelum mempunyai kotak putih yang kecil. Kami tidak mempunyai bahawa kotak putih sekarang. 

Tetapi apabila saya memanggil mendapatkan tali, saya mahu meletakkan keputusan di suatu tempat. Jadi paradigma yang biasa di C adalah untuk memanggil fungsi, seperti mendapatkan tali sini, dan kemudian menyimpan nilai pulangan. Ia adalah hasil daripada yang usaha dalam sesuatu. 

Dan apakah membina dalam pengaturcaraan, sama ada dalam Scratch atau sekarang C, bahawa kita boleh menggunakan untuk benar-benar menyimpan sesuatu? Dipanggil ia berubah, bukan? Dan dalam Scratch, kita tidak benar-benar mengambil berat apa yang berlaku dalam pembolehubah. 

Tetapi dalam kes ini, kita sebenarnya lakukan. Saya akan katakan tali. Dan kemudian saya boleh memanggil apa-apa ini yang saya mahu. Saya akan memanggilnya nama, mendapat mendapatkan tali. 

Dan kini walaupun anda yang baru sedikit untuk ini, notis bahawa saya kurang terperinci. Saya lupa koma bertitik. Saya perlu menyelesaikan pemikiran ini. Jadi, saya akan untuk menggerakkan kursor saya, dan memukul koma bertitik di sana. Dan apa yang telah saya lakukan? Dalam baris ini kod, nombor 5 pada masa ini, Saya memanggil mendapatkan tali tanpa input. Jadi tidak ada sedikit putih kotak seperti Simpan blok mempunyai. 

Saya hanya berkata, hey, komputer, dapatkan saya rentetan. Tanda sama tidak benar-benar tanda sama, per se. Ia tugasan operator, yang bermaksud, hey, komputer, bergerak nilai dari kanan ke kiri. Dan di sebelah kiri, saya mempunyai yang berikut. 

Hey, komputer, memberi saya string-- yang jujukan aksara. Dan mengatakan Nama tali. Dan saya tidak perlu memanggilnya Nama. 

Saya boleh memanggilnya, konvensional, sesuatu seperti S, sama seperti kita digunakan untuk i memanggil pembolehubah i. Tetapi sekarang saya perlu melakukan sesuatu dengannya. Ia akan cukup bodoh untuk cuba menyusun kod ini, berjalan program ini, walaupun Saya mendapat tali, kerana ia masih hanya akan berkata hello dunia. 

Tetapi bagaimana jika saya ingin menukar ini. Mengapa tidak saya lakukan ini? Peratus s, koma s. Dan ini adalah sedikit samar masih. 

Jadi biarlah saya membuat pembolehubah saya lebih jelas. Biar saya menamakan Nama pembolehubah ini. Dan mari kita lihat jika kita tidak boleh mengusik selain apa yang berlaku di sini. 

Jadi pada baris lima, saya mendapat rentetan. Dan saya menyimpan tali itu, apa sahaja yang pengguna itu telah ditaip dalam di papan kekunci mereka, dalam pembolehubah dipanggil Nama. Dan ternyata bahawa printf tidak hanya mengambil satu hujah dalam dua sebut harga, satu input dalam tanda petik. 

Ia boleh mengambil masa dua, atau tiga, atau lebih, seperti yang kedua, atau ketiga, atau keempat, semua nama-nama pembolehubah, atau khusus menghargai, yang anda mahu untuk dimasukkan ke dalam, dinamik, yang rentetan dalam sebut harga. Dalam erti kata lain, apa yang akan salah dengan ini? Jika saya hanya berkata hello nama, garis sendeng terbalik n, menyimpan fail saya, disusun kod saya, dan berlari ini, apa yang akan berlaku? 

Ia hanya akan berkata, hello menamakan, secara literal N-A-M-E, yang jenis bodoh kerana ia tidak berbeza dari dunia. Jadi apa-apa dalam petikan ialah apa yang benar-benar mendapat dicetak. Jadi, jika saya ingin mempunyai pemegang tempat di sana, Saya benar-benar perlu menggunakan beberapa sintaks khas. Dan ternyata jika anda membaca dokumentasi untuk fungsi printf, ia akan memberitahu anda bahawa jika anda menggunakan peratus s, anda boleh menggantikan nilai seperti berikut. 

Selepas koma selepas itu petikan berganda, anda hanya menulis nama pembolehubah yang anda mahu pasangkan ke dalam format yang kod, atau format specifier, peratus kerana tali. Dan sekarang jika saya telah menyimpan fail saya, Saya kembali ke terminal saya. Dan saya menaip Selesakan String, kerana, sekali lagi, nama ini fail yang saya pilih sebelum ini adalah string.c. 

Jadi, saya akan mengatakan Selesakan String, masukkan. Oh kebaikan saya, melihat semua kesilapan yang telah kami lakukan sudah. Dan ini is-- apa, ini adalah benar-benar seperti enam, tujuh program line? Jadi ini adalah di mana ia boleh sangat cepat mendapatkan yang amat sangat. 

Ini tetingkap terminal mempunyai kini hanya regurgitated sejumlah besar mesej ralat. Sesungguhnya, saya tidak mempunyai lebih ralat mesej daripada saya baris kod. Jadi apa yang berlaku? 

Well, strategi terbaik lakukan bila-bila masa anda yang menghadapi yang menggalakkan senarai kesilapan seperti itu, adalah skrol kembali, mencari arahan anda hanya berlari, yang dalam kes saya adalah membuat tali. Lihatlah apa yang membuat lakukan, dan itulah yang arahan dilafaz panjang, ada masalah besar di sana. 

Tetapi merah itu tidak baik. Green cuba menjadi lembut dan membantu. Tetapi ia masih tidak baik, dalam kes ini. Tetapi di mana ia baik? 

String.c, garis lima, watak lima. Jadi ini adalah hanya konvensyen biasa. Sesuatu kolon sesuatu yang bermakna nombor talian dan nombor watak. Ralat, penggunaan yang tidak diisytiharkan tali pengecam. Adakah anda bermaksud standard dalam? 

Jadi, malangnya, dilafaz cuba untuk membantu. Tetapi ia salah, dalam kes ini. Tiada, dilafaz, saya tidak bermaksud standard IO. Saya bermaksud bahawa pada baris satu, ya. 

Tetapi garis lima adalah salah satu ini di sini. Dan dilafaz tidak memahami S-T-R-I-N-G. Ia merupakan satu pengecam tidak diisytiharkan, yang perkataan ia hanya tidak pernah dilihat sebelum ini. Dan itu kerana C, bahasa kita menulis kod dalam sekarang, tidak mempunyai pembolehubah dipanggil tali. 

Tidak, secara lalai, sokongan sesuatu yang dipanggil rentetan. Itulah sekeping CS50 daripada jargon, tetapi sangat konvensional. Tetapi saya boleh menetapkan ini seperti berikut. 

Jika saya menambah satu baris kod ke atas program ini, termasuk CS50.h, yang merupakan fail lain suatu tempat di dalam CS50 IDE, di suatu tempat pada cakera keras, jadi untuk bercakap, sistem operasi Ubuntu bahawa saya berjalan, yang adalah fail yang yang akan mengajar operasi sistem apa rentetan adalah, hanya seperti io.h standard fail dalam sistem operasi itu akan mengajar ia apa printf adalah. 

Sesungguhnya, kita akan mendapat mesej yang hampir sama jika IO mengaku standard Io.h dan cuba menggunakan printf. Jadi, saya akan pergi ke hadapan dan hanya mengambil kawalan L untuk mengosongkan skrin saya. Atau anda boleh menaip jelas dan ia akan hanya membersihkan tetingkap terminal. Tetapi anda masih boleh memilih kembali semula dalam masa. 

Dan saya akan menjalankan semula Selesakan String. Sila bersabar saya kali ini, Enter. Oh Tuhan saya, ia bekerja. ia menunjukkan saya arahan samar yang panjang itulah yang Membuat dijana melalui dilafaz, tetapi tiada mesej ralat. Jadi sedar, walaupun anda mungkin akan mendapat sepenuhnya terharu dengan beberapa mesej ralat, ia hanya mungkin melata yang menyakitkan hati kesan, di mana dilafaz tidak memahami satu perkara, yang bermakna ia kemudian tidak memahami perkataan seterusnya, atau baris berikutnya. Dan jadi ia hanya menjadikan pemakannya tercekik pada kod anda. Tetapi menetapkan mungkin mudah. Dan supaya sentiasa memberi tumpuan kepada baris pertama output. Dan jika anda tidak melakukan memahaminya, hanya melihat untuk kata kunci yang mungkin petunjuk, dan bilangan garisan, dan watak, di mana kesilapan yang mungkin. 

Sekarang, saya akan pergi ke hadapan dan menaip dot slash, tali, masuk. Hm, ia tidak mengatakan hello apa-apa. Mengapa? Nah, ingat, di mana ia berjalan? 

Ia mungkin terperangkap pada masa ini dalam gelung, jika anda akan, pada baris enam, kerana Dapatkan String oleh reka bentuk, ditulis oleh kakitangan CS50, secara literal bermaksud untuk hanya duduk di sana menunggu, dan menunggu, dan menunggu rentetan. Apa yang kami maksudkan dengan tali adalah input manusia. Jadi, anda tahu apa? Biar saya pergi ke hadapan. Dan hanya pada sesuka hati, biarlah saya taip nama saya, David, masukkan. Sekarang saya mempunyai program yang lebih dinamik. Ia berkata, hello David. 

Jika saya pergi ke hadapan dan menjalankan ini lagi, saya cuba menyebut nama Zamila, masukkan. Dan sekarang kita mempunyai program dinamik. Saya tidak dikodkan dunia. Saya tidak berkod keras nama, atau David, atau Zamila. 

Sekarang ia lebih seperti program yang kita tahu, di mana jika ia mengambil input, ia menghasilkan output yang sedikit berbeza. Sekarang, ini bukan yang terbaik pengalaman pengguna, atau UX. Saya menjalankan program ini. 

Saya tidak tahu apa yang saya sepatutnya yang perlu dilakukan, melainkan jika saya benar-benar melihat atau ingat kod sumber. Jadi mari kita membuat pengguna mengalami sedikit lebih baik dengan yang paling mudah perkara. Biar saya pergi semula ke dalam ini program, dan hanya berkata printf. 

Dan biarlah saya pergi ke hadapan dan menyebut nama, kolon, dan ruang, dan kemudian koma bertitik. Dan hanya untuk tendangan, ada tindak balas n. Dan itu sengaja, kerana saya tidak mahu segera untuk bergerak ke baris seterusnya. 

Saya mahu, sebaliknya, melakukan ini, membuat tali susun semula kod saya ke dalam mesin baru kod dot slash tali. Ah, ini adalah jauh lebih cantik. Sekarang saya benar-benar tahu apa yang komputer mahu saya lakukan, memberikan nama. 

Jadi, saya akan pergi ke hadapan dan menaip dalam Rob maka masuklah dan hello, Rob. Jadi, sedar, ini masih, pada akhir hari, hanya program sembilan garis. Tetapi kami telah mengambil langkah-langkah bayi. 

Kami menulis satu baris yang kita sudah biasa, printf, hello dunia. Kemudian kami undid sedikit itu. Dan kita sebenarnya digunakan mendapatkan tali. Dan kita dilambung bahawa nilai dalam pembolehubah. Dan kemudian kita pergi ke hadapan dan lebih baik lagi dengan garis ketiga. Dan proses lelaran ini menulis perisian benar-benar penting. Dalam CS50, dan dalam kehidupan secara umum, anda sepatutnya tidak duduk, mempunyai program yang dalam fikiran, dan cuba bertulis perkara sialan seluruh sekaligus. 

Ia akan, tidak dapat tidak, menyebabkan cara lebih banyak kesilapan daripada kita sendiri melihat di sini. Malah saya, hingga ke hari ini, sentiasa melakukan kesilapan bodoh yang lain, adalah kesilapan sebenarnya sukar yang sukar untuk memahami. Tetapi anda akan membuat lebih banyak kesilapan yang lebih baris kod anda menulis semua sekali gus. Dan supaya amalan ini, naik sedikit kod yang sesuai dengan anda, menyusun ia, berjalan, menguji ia lebih umum, kemudian bergerak pada-- jadi seperti kami terus lapisan dan lapisan minggu lepas, membina dari sesuatu yang sangat mudah untuk sesuatu yang lebih kompleks, melakukan perkara yang sama di sini. Jangan duduk, dan cuba untuk menulis keseluruhan masalah. Sebenarnya mengambil langkah-langkah bayi. 

Sekarang, tali tidak semua yang berguna kepada diri mereka sendiri. Kita akan sebenarnya, ideal, seperti untuk mempunyai sesuatu yang lain dalam Kit kami. Jadi mari kita sebenarnya melakukan perkara tersebut. 

Biar saya pergi ke hadapan sekarang dan menyiapkan program yang sedikit berbeza. Dan kita akan memanggil int.c ini, bagi integer. Saya akan, begitu juga, termasuk CS550.h. Saya akan termasuk standard IO. Dan itu akan menjadi agak biasa pada hari-hari pertama dalam kelas. 

Dan saya akan bersedia diri saya dengan fungsi utama. Dan sekarang bukannya mendapat tali, mari kita pergi ke hadapan dan mendapatkan int. Mari kita memanggilnya i, dan memanggilnya mendapatkan int, parens rapat, koma bertitik. Dan sekarang mari kita buat sesuatu dengannya, printf. 

Katakan sesuatu seperti hello, garis sendeng terbalik n, koma i. Jadi, saya cukup banyak meniru apa yang saya lakukan hanya seketika lalu. Saya mempunyai pemegang tempat di sini. Saya telah koma i di sini, kerana saya mahu pasangkan i ke dalam pemegang tempat itu. 

Jadi mari kita pergi ke hadapan dan cuba menyusun program ini. fail ini dipanggil int.c. Jadi, saya akan berkata, membuat int, masukkan. Oh Tuhan saya, tetapi ada masalah besar, bukan? Ada kesilapan. 

Ada kesilapan sintaksis di sini seperti bahawa program ini tidak boleh disusun dalam int.c, talian tujuh, watak 27, format ralat menentukan jenis char bintang, apa sahaja yang. Tetapi jenis hujah adalah int. 

Jadi di sini, juga, kita tidak akan supaya- walaupun hari ini adalah banyak bahan, kita akan membanjiri anda dengan benar-benar setiap ciri C, dan pengaturcaraan lebih umum, dalam hanya beberapa minggu pertama. Jadi ada sering akan menjadi jargon yang anda tidak biasa. Dan, sebenarnya, bintang char adalah sesuatu kita akan kembali kepada dalam seminggu atau masa two. 

Tetapi untuk sekarang, mari kita lihat jika kita boleh menghuraikan kata-kata yang biasa. Formats-- supaya kita mendengar format specifier, kod format sebelum ini. Itulah biasa. Type-- tetapi hujah yang mempunyai jenis int. Tunggu satu minit, i adalah int. 

Mungkin s peratus sebenarnya mempunyai maksud tertentu ditakrifkan. Dan, sememangnya, ia tidak. Integer, jika anda mahu printf untuk menggantikannya, anda sebenarnya perlu menggunakan format yang berbeza specifier. Dan anda tidak akan tahu ini melainkan jika seseorang memberitahu anda, atau anda telah melakukannya sebelum ini. Tetapi peratus i adalah apa yang boleh biasa digunakan dalam printf untuk memasang integer. Anda juga boleh menggunakan peratus d untuk integer perpuluhan. Tetapi saya adalah baik dan mudah di sini. Oleh itu, kita akan pergi dengan itu. 

Sekarang, saya akan pergi ke hadapan dan jalankan lagi make int, Enter. Itu baik, tiada kesilapan. Dot mengurangkan OK int--, pengalaman pengguna yang tidak baik, kerana saya tidak memberitahu diri saya Apa nak buat. Tetapi itulah denda. Saya menangkap dengan cepat. 

Dan sekarang mari saya pergi ke hadapan dan menaip David, OK, Zamila, Rob. OK, jadi ini adalah satu perkara yang baik. Kali ini, saya menggunakan fungsi, sekeping teka-teki, dipanggil mendapatkan int. Dan ternyata out-- dan kami akan lihat nanti ini dalam term-- yang kakitangan CS50 telah melaksanakan mendapatkan tali dalam apa-apa cara bahawa ia akan hanya secara fizikal mendapatkan rentetan untuk anda. 

Ia telah melaksanakan mendapatkan int dalam apa-apa cara bahawa ia hanya akan mendapatkan integer untuk anda. Dan jika anda, manusia, tidak bekerjasama, ia literal hanya akan mengatakan mencuba semula, cuba semula, cuba semula, harfiah duduk di sana menggelung, sehingga anda memaksa dengan beberapa nombor ajaib, seperti 50, dan hello 50. 

Atau jika kita menjalankan ini sekali lagi dan taip 42, hello 42. Dan sebagainya fungsi get int bahagian dalam sekeping teka-teki logik cukup, pemikiran yang cukup, untuk memikirkan, apakah perkataan? Dan apa yang nombor? Hanya menerima, akhirnya, nombor. 

Jadi ia ternyata bahawa ini tidak semua yang ekspresif. setakat ini. Jadi, yay, kita masa lalu pergi cukup cepat ke dalam melaksanakan permainan, dan animasi, dan kerja-kerja seni dalam Scratch. Dan di sini, kita yang kandungan dengan dunia hello, dan hello 50. 

Ia bukan semua inspirasi itu. Dan, sememangnya, ini pertama beberapa contoh akan mengambil sedikit masa untuk meningkatkan dalam keseronokan. Tetapi kita mempunyai lebih banyak lagi mengawal sekarang, sebenarnya. Dan kita akan sangat mula lapisan di atas ini primitif asas. 

Tetapi pertama, mari kita memahami apa batasan berada. Malah, salah satu perkara yang Scratch tidak mudah marilah kita lakukan adalah benar-benar kelihatan di bawah hood, dan memahami apa yang komputer, apa yang ia boleh lakukan, dan apa batasannya berada. Dan, sememangnya, bahawa kekurangan pemahaman, berpotensi, jangka panjang boleh membawa kepada penulisan mistakes-- kita sendiri pepijat, menulis perisian tidak selamat yang mendapat digodam dalam beberapa cara. 

Jadi mari kita mengambil beberapa langkah ke arah memahami ini sedikit lebih baik dengan cara, berkata, contoh berikut. Saya akan pergi ke hadapan dan melaksanakan sebenar cepat program yang dikenali sebagai Adder. Seperti, mari kita menambah beberapa nombor bersama-sama. Dan saya akan memberi kod kepada beberapa sudut di sini, dan hanya menyalin dan pes di mana saya sebelum ini, hanya supaya kita boleh mendapatkan pergi lebih awal. Jadi sekarang saya telah mendapat permulaan asas program yang dipanggil Adder. 

Dan mari kita pergi ke hadapan dan melakukan ini. Saya akan pergi ke hadapan dan katakan, intx mendapat mendapatkan int. Dan anda tahu apa? Mari kita membuat pengalaman pengguna yang lebih baik. 

Jadi mari kita hanya mengatakan x, dan berkesan segera pengguna untuk memberi kita x. Dan biarkan saya pergi ke hadapan dan berkata, printf bagaimana pula y adalah, kali ini menjangkakan dua nilai daripada pengguna. Dan kemudian mari kita pergi ke hadapan dan berkata, printf, jumlah x dan y adalah. Dan sekarang saya tidak mahu melakukan peratus s. Saya mahu lakukan peratus i, garis sendeng terbalik n, dan kemudian pasangkan nilai jumlah. 

Jadi bagaimana saya boleh pergi tentang melakukan ini? Awak tahu tak? Saya tahu bagaimana untuk menggunakan pembolehubah. Biar saya mengisytiharkan yang baru, int z. 

Dan saya akan mengambil tekaan di sini. Jika terdapat tanda-tanda yang sama dalam ini bahasa, mungkin saya hanya boleh melakukan x ditambah y, selagi saya mengakhiri saya berfikir dengan koma bertitik? Sekarang saya boleh kembali ke sini, pasangkan z, menyelesaikan pemikiran ini dengan koma bertitik. Dan mari kita lihat sekarang, jika ini urutan lines-- x adalah mendapatkan int. Y adalah mendapatkan int. 

Tambahkan x dan y, menyimpan nilai dalam z-- jadi, sekali lagi, ingat tanda 'sama tidak sama. Ia tugasan dari kanan ke kiri. Dan mari kita mencetak jumlah wang yang x dan y tidak literal z, tetapi apa yang di dalam z. Jadi mari kita membuat Adder - bagus, tiada kesilapan masa ini. Dot mengurangkan Adder, memasuki, x akan menjadi 1. 

Y akan menjadi 2. Dan jumlah x dan y ialah 3. Jadi itu semua baik dan baik. 

Jadi, anda akan membayangkan matematik yang harus bekerja dalam program seperti ini. Tetapi anda tahu apa? Berubah-ubah ini, barisan 12, walaupun perlu? Anda tidak perlu untuk mendapatkan dalam tabiat hanya menyimpan perkara-perkara dalam pembolehubah hanya kerana anda boleh. Dan, sebenarnya, ia biasanya reka bentuk yang tidak terancang jika anda sedang mencipta pembolehubah, yang dipanggil z dalam kes ini, menyimpan sesuatu di dalamnya, dan kemudian segera menggunakannya, tetapi tidak lagi. Mengapa memberikan sesuatu nama seperti z jika anda benar-benar akan menggunakan yang Perkara yang hanya sekali, dan sebagainya proksimal ke mana anda membuat di tempat yang pertama, begitu dekat dari segi baris kod? Jadi, anda tahu apa? Ia ternyata bahawa C adalah cukup fleksibel. Jika saya benar-benar ingin plug-in nilai di sini, Saya tidak perlu untuk mengisytiharkan pembolehubah baru. Saya hanya boleh plug-in x tambah y, kerana C memahami aritmetik, dan pengendali matematik. 

Jadi saya hanya boleh mengatakan, melakukan matematik ini, x ditambah y, apa sahaja yang mereka nilai adalah, plug yang terhasil integer ke dalam tali itu. Jadi ini mungkin, walaupun hanya satu baris lebih pendek, reka bentuk yang lebih baik, program yang lebih baik, kerana ada kurang kod, oleh itu kurang bagi saya untuk memahami. Dan ia juga hanya lebih bersih, sejauh mana kita tidak memperkenalkan perkataan baru, simbol-simbol baru, seperti z, walaupun mereka tidak benar-benar berkhidmat banyak tujuan. 

Malangnya, matematik tidak semua yang kadang-kadang boleh dipercayai. Mari kita pergi ke hadapan dan melakukan ini. Saya akan pergi ke hadapan sekarang dan melakukan yang berikut. 

Mari kita buat printf, peratus i, ditambah peratus i, hendaklah peratus i, garis sendeng terbalik n. Dan saya akan melakukan this-- xyx ditambah y. Jadi saya hanya akan menulis semula ini sedikit berbeza di sini. Biar saya melakukan pemeriksaan kewarasan cepat. Sekali lagi, jangan kita mendapatkan lebih awal daripada diri kita sendiri. Membuat penambah, dot slash penambah. x 1, y ialah 2, 1 tambah 2 ialah 3. Jadi itulah yang baik. Tetapi mari kita merumitkan ini sekarang sedikit, dan membuat fail baru. 

Saya akan memanggil satu ini, berkata, ints, plural bagi integer. Biar saya mulakan di mana saya sebentar tadi. Tetapi sekarang mari kita buat beberapa baris lain. Biar saya pergi ke hadapan dan melakukan yang berikut, printf, peratus i, tolak peratus i, adalah peratus i, koma x, koma yx tolak y. Jadi saya lakukan sedikit matematik berbeza di sana. Mari kita buat satu sama lain. Jadi peratus i kali peratus i adalah peratus i, garis sendeng terbalik n. Mari kita plug-dalam x dan y, dan masa x y. Kami akan menggunakan asterisk pada komputer anda untuk masa. 

Anda tidak menggunakan x. x adalah nama pembolehubah di sini. Anda menggunakan bintang untuk pendaraban. Mari kita buat satu lagi. peratus printf I, dibahagikan dengan peratus i, adalah peratus i, n garis sendeng terbalik. xy dibahagikan dengan y-- supaya anda menggunakan garis italik dalam C untuk melakukan pembahagian. Dan mari kita buat satu yang lain. Baki peratus i, dibahagikan dengan peratus i, adalah peratus i. xy-- dan kini baki adalah apa yang ditinggalkan. Apabila anda cuba membahagikan pembawahnya ke dalam pengangka a, berapa banyak yang tinggal lebih daripada itu anda tidak boleh membahagikan keluar? 

Jadi tidak ada benar-benar, semestinya, simbol kami telah digunakan di sekolah rendah untuk ini. Tetapi ada dalam C. Anda boleh mengatakan x modulo y, di mana ini tanda peratus dalam context-- ini mengelirukan apabila anda berada di dalam daripada petikan berganda, bahagian dalam printf, peratus digunakan sebagai format specifier itu. 

Apabila anda menggunakan peratus di luar yang dalam ungkapan matematik, ia operator modulo untuk modular arithmetic-- untuk tujuan kami di sini, hanya bermakna, apakah baki x dibahagikan dengan y? Jadi x dibahagikan dengan y x slash y. Apa yang baki x dibahagikan dengan y? Ia x mod y, sebagai seorang programmer akan berkata. 

Jadi, jika saya tidak membuat sebarang kesilapan di sini, biarlah saya teruskan dan buat ints, majmuk, nice, dan ints slash dot. Dan mari kita pergi ke hadapan dan lakukan, katakan, 1, 10. Baiklah, 1 campur 10 adalah 11, daftar. 1 tolak 10 adalah negatif 9, cek. 

1 kali 10 adalah 10, daftar. 1 dibahagikan dengan 10 is-- OK, kita akan melangkau satu. Baki 1 dibahagikan dengan 10 adalah 1. Itulah betul. Tetapi ada pepijat di sini. 

Demikian juga saya meletakkan saya menyerahkan, tidak betul. Maksud saya, ia dekat kepada 0. 1 dibahagikan dengan 10, anda tahu, jika kita memotong beberapa sudut, pasti, ia adalah sifar. Tetapi ia benar-benar perlu 1/10, 0,1, atau 0.10, 0,1000, atau sebagainya. 

Ia tidak boleh benar-benar sifar. Nah, ternyata bahawa komputer adalah melakukan literal apa yang kita memberitahu ia lakukan. Kami sedang melakukan matematik seperti x dibahagikan dengan y. Dan kedua-dua x dan y, setiap baris kod sebelum ini, adalah integer. 

Lebih-lebih lagi, pada baris 15, kami memberitahu printf, hey, printf plug-in integer, plug-in integer, plug-in integer-- yang khusus x, dan kemudian y, dan kemudian x dibahagikan dengan y. x dan y adalah ints. Kita baik di sana. 

Tetapi apa yang x dibahagikan dengan x? x dibahagikan dengan y perlu, matematik, 1/10, atau 0.1, yang merupakan nombor sebenar, nombor nyata mempunyai, berpotensi, titik perpuluhan. Ia bukan integer. 

Tetapi apa yang paling dekat integer untuk 1/10, atau 0.1? Ya, ia jenis adalah sifar. 0.1 adalah seperti ini banyak. Dan 1 adalah sebanyak ini. Jadi 1/10 lebih hampir kepada 0 daripada ia adalah untuk satu. 

Dan supaya apa yang C lakukan untuk us-- jenis kerana kami diberitahu ia supaya- adalah memendekkan integer itu. Ia mengambil nilai, yang sekali lagi adalah sepatutnya menjadi sesuatu yang seperti 0,1000, 0 dan sebagainya. Dan ia memendekkan segala-galanya selepas titik perpuluhan supaya semua ini barangan, kerana ia tidak dimuatkan dalam konsep integer, yang hanya beberapa seperti -1, 0, 1, atas dan ke bawah, ia melemparkan segala-galanya selepas titik perpuluhan kerana anda tidak boleh muat titik perpuluhan dalam integer dengan definisi. 

Jadi jawapan di sini adalah sifar. Jadi bagaimana kita menetapkan ini? Kita perlu penyelesaian yang lain bersama-sama. Dan kita boleh melakukan ini, seperti berikut. 

Biar saya pergi ke hadapan dan mencipta yang baru fail, yang satu ini dipanggil floats.c. Dan menyimpannya di sini di direktori yang sama, float.c. Dan biarlah saya pergi ke hadapan dan salinan beberapa kod itu daripada awal. 

Tetapi bukannya mendapat int, mari kita buat ini. Berikan saya nilai mata terapung dipanggil x. di mana titik terapung nilai hanya literal sesuatu dengan titik terapung. Ia boleh bergerak ke kiri, ke kanan. Ia adalah satu nombor nyata. 

Dan biarlah saya tidak memanggil mendapatkan int, tetapi mendapat apungan, yang juga adalah antara menu pilihan di perpustakaan C250 itu. Mari kita mengubah y kepada apungan. Jadi ini menjadi mendapatkan apung. 

Dan kini, kita tidak mahu pasangkan ints. Ternyata kita perlu menggunakan peratus f untuk apungan, peratus f untuk apungan, dan kini menyimpannya. Dan kini, jari bersilang, membuat pelampung, nice, pelampung slash dot. x akan menjadi salah 1. y Akan menjadi 10 lagi. 

Dan, nice, OK samping itu saya adalah betul. Saya berharap untuk lebih, tetapi saya terlupa untuk menulisnya. Jadi mari kita pergi dan menetapkan kesilapan ini logik. 

Mari kita teruskan dan merebut berikut. Kami hanya akan melakukan satu salinan kecil dan tampal. Dan saya akan berkata tolak. 

Dan saya akan berkata kali. Dan saya akan mengatakan dibahagikan. Dan saya tidak akan melakukan modulo, yang tidak begitu germane sini, dibahagikan dengan f, dan masa plus-- OK, mari kita buat ini lagi. 

Membuat pelampung, pelampung slash dot, dan 1, 10, dan- bagus, tidak, OK. Jadi saya bodoh. Jadi ini adalah perkara biasa dalam bidang sains komputer melakukan kesilapan bodoh seperti ini. 

Untuk tujuan pedagogi, apa yang saya benar-benar mahu lakukan telah menukar ilmu di sini untuk tambah, tolak, untuk kali, dan untuk membahagikan, kerana anda diharapkan perasan semasa latihan ini. Jadi sekarang mari kita menyusun semula ini program, melakukan terapung slash dot. 

Dan untuk kali ketiga, mari kita melihat jika ia memenuhi jangkaan saya. 1, 10, memasuki, ya, OK, 1,000, dibahagikan dengan 10,000, adalah 0,100000. Dan ternyata kita boleh mengawal berapa banyak nombor-nombor selepas titik-titik perpuluhan. Kami benar-benar akan. Kami akan kembali kepada itu. 

Tetapi sekarang, sebenarnya, matematik adalah betul. Jadi, sekali lagi, apa yang bisa dibesarkan di sini? Ia ternyata bahawa dalam C, terdapat bukan sahaja hanya strings-- dan, sebenarnya, tidak benar-benar, kerana kita menambah mereka yang mempunyai perpustakaan CS50. Tetapi tidak hanya ints. 

Terdapat juga terapung. Dan ternyata sekumpulan data lain jenis juga, bahawa kami akan menggunakan tidak lama lagi. Rupa-rupanya, jika anda mahu satu watak, bukan rentetan aksara, anda boleh menggunakan hanya char. 

Ternyata bahawa jika anda mahu bool, nilai Boolean, benar atau palsu sahaja, terima kasih kepada perpustakaan CS50, kami telah ditambah kepada C Jenis data bool juga. Tetapi ia juga hadir dalam bahasa-bahasa lain juga. Dan ternyata bahawa kadang-kadang anda perlu nombor yang lebih besar kemudian datang secara lalai dengan ints dan terapung. 

Dan, sebenarnya, dua adalah sebilangan yang menggunakan tidak 32 bit, tetapi 64 bit. Dan panjang panjang adalah nombor yang menggunakan bukan 32, bit tetapi 64 bit, masing-masing, untuk titik terapung nilai-nilai dan bilangan bulat, masing-masing. Jadi mari kita sebenarnya kini melihat ini dalam tindakan. 

Saya akan pergi ke hadapan di sini dan menyiapkan satu program lain. Di sini, saya akan pergi ke hadapan dan boleh dilakukan termasuk CS50.h. Dan biarlah saya pergi, termasuk standard io.h. 

Dan anda akan melihat sesuatu yang funky yang sedang berlaku di sini. Ia bukan warna pengekodan perkara dalam dengan cara yang sama seperti yang berlaku sebelum ini. Dan ternyata, itu kerana saya tidak memberikan perkara yang nama fail. 

Saya akan memanggil satu ini sizeof.c, dan tekan Simpan. Dan perhatikan apa yang berlaku kepada saya sangat kod putih terhadap yang latar belakang hitam. Sekarang, sekurang-kurangnya ada beberapa ungu di sana. Dan ia adalah sintaks diserlahkan. 

Ini kerana, agak mudah, saya telah kepada IDE jenis fail ia adalah dengan memberi nama, dan khusus sambungan fail. Sekarang, mari kita pergi ke hadapan dan melakukan ini. Saya akan pergi ke hadapan dan sangat hanya mencetak bool yang following-- adalah peratus LU. 

Kami akan kembali kepada bahawa dalam hanya seketika. Dan kemudian saya akan saiz cetak bool. Dan sekarang, hanya untuk menyelamatkan diri saya sedikit masa, saya akan melakukan keseluruhannya sekumpulan ini sekaligus. Dan, khususnya, saya akan menukar ini kepada char dan char. Yang ini, saya akan menukar kepada double dan berganda. 

Yang ini, saya akan menukar kepada apungan dan apungan. Yang ini, saya akan menukar kepada int dan int. Dan yang satu ini, saya akan untuk menukar kepada panjang panjang. Dan ia masih mengambil masa yang lama, panjang panjang. 

Dan kemudian, akhir sekali, saya memberi diri saya terlalu banyak, tali. Ia ternyata bahawa dalam C, ada pengendali khas yang dipanggil saiz itu secara literal akan, apabila berjalan, beritahu kami saiz setiap pembolehubah ini. Dan ini adalah cara yang, sekarang, kita boleh menyambung semula untuk perbincangan minggu lepas data dan perwakilan. 

Biar saya pergi ke hadapan dan menyusun saiz saiz slash dot. Dan mari kita lihat. Ia ternyata bahawa dalam C, khusus kepada CS50 IDE, khusus kepada sistem operasi Ubuntu, yang merupakan operasi 64-bit sistem dalam kes ini, bool akan menggunakan satu bait ruang. Itulah bagaimana saiz diukur, tidak dalam bit, tetapi dalam bait. Dan ingat bahawa satu bait adalah lapan bit. Jadi bool, walaupun anda teknikal hanya memerlukan 0 atau 1, ia sedikit membazir bagaimana kami telah melaksanakannya. Ia sebenarnya akan menggunakan keseluruhan byte-- jadi semua sifar, adalah mungkin semua orang, atau sesuatu seperti itu, atau hanya satu 1 antara lapan bit. 

char A, sementara itu, yang digunakan untuk watak seperti watak Ascii seminggu lepas, akan menjadi satu aksara. Dan itu synchs memulakan idea kami ia menjadi tidak lebih daripada 256 bits-- sebaliknya, synchs dengan ia sebenarnya tidak ada lebih lama daripada 8 bit, yang memberikan kita sebanyak 256 nilai. double A akan menjadi 8 bytes atau 64 bit. 

float A ialah 4. Int adalah 4. A panjang, lama adalah 8. Dan tali adalah 8. Tetapi jangan bimbang tentang itu. Kita akan mengupas kembali lapisan itu. Ternyata, tali boleh lebih panjang daripada 8 bait. 

Dan, sesungguhnya, kami telah menulis tali sudah, hello dunia, lebih lama daripada 8 bait. Tetapi kita akan kembali kepada bahawa dalam hanya seketika. Tetapi mengambil yang jauh di sini adalah seperti berikut. 

Mana-mana komputer hanya mempunyai terhingga jumlah memori dan ruang. Anda hanya boleh menyimpan begitu banyak fail pada Mac atau PC anda. Anda hanya boleh menyimpan begitu banyak program di RAM berjalan serentak, semestinya, walaupun dengan ingatan maya, kerana anda mempunyai jumlah yang terhad RAM. 

Dan hanya untuk picture-- jika anda tidak pernah membuka komputer riba atau diperintahkan memori tambahan untuk komputer, anda mungkin tidak tahu bahawa di dalam komputer anda adalah sesuatu yang kelihatan yang kecil seperti ini. Jadi ini adalah hanya sebuah syarikat biasa bernama Penting yang menjadikan RAM untuk komputer. Dan RAM adalah di mana program tinggal semasa mereka berjalan. 

Maka pada setiap Mac atau PC, apabila anda dua kali ganda klik program, dan ia membuka, dan ia membuka beberapa dokumen Word atau sesuatu seperti itu, ia menyimpan buat sementara waktu dalam RAM, kerana RAM adalah lebih cepat daripada cakera keras anda, atau cakera keadaan pepejal anda. Jadi ia hanya di mana program pergi tinggal semasa mereka berjalan, atau apabila fail sedang digunakan. 

Jadi, anda mempunyai perkara-perkara yang kelihatan seperti di dalam ini komputer riba anda, atau perkara-perkara yang lebih besar sedikit bahagian dalam desktop anda. Tetapi yang penting adalah anda hanya mempunyai beberapa terhingga perkara-perkara ini. Dan ada hanya sejumlah terhingga perkakasan duduk di atas meja ini buat di sini. 

Jadi, pasti, kita tidak boleh menyimpan nombor panjang tak terhingga. Dan, lagi, jika anda berfikir kembali kepada sekolah rendah, berapa banyak digit boleh anda perlu ke kanan titik perpuluhan? Untuk itu, berapa banyak digit boleh anda mempunyai di sebelah kiri titik perpuluhan? Betul, tak terhingga banyaknya. 

Sekarang, kita manusia hanya mungkin tahu bagaimana cara mengucapkan juta, dan bilion, trilion, dan quadrillion dan triliun. Dan saya menolak had saya understanding-- atau my-- Saya faham nombor, tetapi saya sebutan nombor. Tetapi mereka boleh mendapatkan besar tak terhingga dengan tak terhingga banyaknya digit ke kiri atau di sebelah kanan titik perpuluhan. 

Tetapi komputer hanya mempunyai jumlah terhingga ingatan, beberapa terhingga transistor, yang beberapa terhingga mentol lampu di dalam. Jadi apa yang berlaku apabila anda kehabisan ruang? Dalam erti kata lain, jika anda berfikir kembali minggu lepas apabila kita bercakap tentang nombor diri mereka diwakili dalam binari, andaikan bahawa kita telah mendapat nilai ini 8-bit di sini. 

Dan kita mempunyai tujuh 1 dan satu 0. Dan andaikan bahawa kita mahu untuk menambah 1 kepada nilai ini. Ini adalah nombor yang sangat besar sekarang. 

Ini adalah 254, jika saya ingat matematik dari minggu lepas betul. Tetapi bagaimana jika saya menukar yang paling kanan 0 kepada 1? Seluruh terhitung banyaknya, dari Sudah tentu, menjadi lapan 1. Oleh itu, kita masih baik. 

Dan itu mungkin mewakili 255, walaupun bergantung kepada konteks ia sebenarnya boleh mewakili nombor negatif. Tetapi lebih kepada yang masa yang lain. Ini berasa seperti ia mengenai setinggi saya boleh mengira. 

Sekarang, ia hanya 8 bit. Dan Mac saya, sesungguhnya mempunyai cara lebih daripada 8 bit memori. Tetapi ia mempunyai terhingga. Jadi hujah yang sama berlaku, walaupun kita mempunyai lebih daripada orang-orang ini pada skrin. 

Tetapi apa yang berlaku jika anda menyimpan nombor ini, 255, dan anda mahu mengira 1 bit yang lebih tinggi? Anda mahu pergi 255-256. Masalahnya, sudah tentu, adalah bahawa jika anda mula mengira pada sifar seperti minggu lepas, anda tidak boleh dikira sebagai tinggi 256, apatah lagi 257, apatah lagi 258, m kerana apa yang berlaku apabila anda menambah 1? Jika anda melakukan sekolah rendah lama pendekatan, anda meletakkan 1 di sini, dan kemudian 1 tambah 1 adalah 2, tetapi itu benar-benar sifar, anda membawa 1, membawa 1, membawa 1. Semua perkara-perkara ini, ini 1, pergi ke sifar. Dan anda menggulung, ya, sebagai seorang menegaskan, 1 di sebelah kiri. Tetapi semua yang anda boleh benar-benar melihat dan dimuatkan dalam memori hanya lapan 0, yang adalah untuk mengatakan pada satu ketika jika anda, komputer, cuba mengira cukup tinggi, anda berada akan membalut di sekitar, ia akan kelihatan, kepada sifar, atau mungkin juga negatif nombor, yang lebih rendah daripada sifar. 

Dan kita jenis boleh melihat ini. Biar saya pergi ke hadapan dan menulis program cepat yang sebenar di sini. Biar saya pergi ke hadapan dan menulis program yang dikenali sebagai limpahan. Termasuk CS50.h, termasuk standard IO.h-- oh, Saya benar-benar terlepas penonjolan sintaks saya. Jadi mari kita menyimpan ini sebagai overflow.c. 

Dan sekarang int void-- utama dan tidak lama, kami akan kembali kepada menjelaskan mengapa kita terus menulis tidak sah utama int. Tetapi untuk sekarang, mari kita hanya melakukan , mengambil ia untuk diberikan. Mari kita memberikan diri saya int, dan memulakan ia pada 0. 

Mari kita kemudian lakukan untuk int i mendapatkan zero-- sebenarnya, mari kita buat gelung tak terhingga dan lihat apa yang berlaku. Walaupun benar, maka mari kita mencetak n adalah peratus i, garis sendeng terbalik n, plug-in n. Tetapi, sekarang, mari kita buat n mendapat n plus 1. 

Jadi dalam erti kata lain, pada setiap lelaran gelung tak terhingga ini, mari kita nilai n ini, dan menambah 1 kepadanya, dan kemudian menyimpan hasil kembali dalam n di sebelah kiri. Dan, sebenarnya, kita telah melihat sintaks sedikit seperti ini, secara ringkas. Satu helah sejuk adalah sebaliknya menulis semua ini, anda benar-benar boleh mengatakan yang plus n sama dengan 1. 

Atau jika anda benar-benar mahu menjadi mewah, anda boleh mengatakan n plus plus koma bertitik. Tetapi dua zaman akhir ini hanya apa yang kita akan memanggil gula sintaktik untuk perkara yang pertama. 

Perkara pertama adalah lebih jelas, betul-betul halus, benar-benar betul. Tetapi ini adalah lebih biasa, saya akan katakan. Oleh itu, kita akan melakukan ini hanya untuk seketika. 

Sekarang mari kita membuat limpahan, yang berbunyi agak menyenangkan, slash limpahan dot. Mari kita lihat, n semakin cukup besar. Tetapi mari kita fikir, berapa besar n boleh dapat? 

n adalah int. Kami melihat masa lalu dengan saiz contoh yang int adalah empat bait. Kita tahu dari minggu lepas, empat bait adalah 32 bit, kerana 8 kali 4, itu 32. Itu akan menjadi 4 bilion. 

Dan kita sehingga 800,000. Ini akan mengambil selama-lamanya untuk mengira setinggi saya mungkin boleh. Jadi, saya akan pergi ke hadapan, kerana anda mungkin tidak lama, dan memukul Kawalan C-- terus-terang, Kawalan C, banyak, di mana Control C umumnya cara membatalkan. Malangnya, kerana ini sedang berjalan di awan, kadang-kadang awan adalah meludah keluar begitu banyak barangan, begitu banyak output, ia akan mengambil sedikit masa untuk input saya untuk sampai ke awan. Jadi, walaupun saya memukul Kawalan C Beberapa saat yang lalu, ini adalah pasti sebelah kesan gelung tak terhingga. 

Dan sebagainya dalam kes-kes tersebut, kami akan meninggalkan yang berkenaan. Dan kita akan menambah satu lagi tetingkap terminal di sini dengan ditambah, yang sudah tentu tidak seperti itu, kerana ia masih berfikir. Dan mari kita pergi ke hadapan dan menjadi sedikit lebih munasabah. 

Saya akan pergi ke hadapan dan melakukan ini hanya terhingga banyak kali. Mari kita gunakan untuk gelung, yang saya katakan sebelum ini. Mari lakukan ini. Berikan saya satu lagi pembolehubah int i mendapat 0. i adalah kurang daripada, katakan, 64 i ++. Dan sekarang mari saya pergi ke hadapan dan cetak keluar n adalah peratus i, koma n. Dan kemudian n-- ini masih akan mengambil selama-lamanya. Mari lakukan ini. 

n mendapat n kali 2. Atau kita boleh menjadi mewah dan melakukan kali bersamaan 2. Tetapi mari kita hanya mengatakan n sama sendiri, kali 2. Dengan kata lain, dalam hal ini versi baru program ini, Saya tidak mahu menunggu selama-lamanya dari seperti 800,000 hingga 4 bilion. Mari kita mendapatkan lebih ini dengan. 

Mari kita sebenarnya menggandakan n setiap kali. Yang, ingat, dua kali ganda adalah bertentangan dengan mempunyai, sudah tentu. Dan bahawasanya minggu lepas kami mempunyai sesuatu sekali lagi, dan sekali lagi, dan sekali lagi, super cepat, dua kali ganda pasti akan membawa kita dari 1 hingga yang paling besar mungkin nilai yang kita boleh bergantung kepada dengan int. 

Jadi mari kita buat betul-betul ini. Dan kami akan kembali kepada ini tidak lama lagi. Tetapi ini, sekali lagi, adalah sama seperti blok berulang dalam Scratch. Dan anda akan menggunakan ini tidak lama lagi. 

Ini hanya bermakna kiraan dari sifar sehingga, tetapi tidak sama, hingga 64. Dan pada setiap lelaran ini gelung, hanya menyimpan menokok i. Jadi i ++ - dan membina umum ini pada baris 7 hanya cara yang super biasa mengulangi beberapa baris kod, beberapa beberapa kali. Yang baris kod? Ini pendakap kerinting, kerana anda mungkin telah dikumpulkan dari sekarang, ertinya, lakukan yang berikut. 

Ada dalam Scratch seperti, apabila ia mempunyai blok kuning dan warna-warna lain yang sejenis memeluk atau memeluk blok lain. Itulah yang mereka kerinting pendakap lakukan di sini. Jadi, jika saya mendapat sintaks saya right-- anda boleh melihat simbol lobak merah dalam cara C itulah berapa kali saya cuba untuk menyelesaikan masalah ini. Jadi mari kita membuang satu yang sama sekali, dan ditutup pada tetingkap. Dan kami akan menggunakan yang baru. Membuat limpahan, slash dot limpahan, Masukkan, semua hak, ia kelihatan buruk pada mulanya. Tetapi mari kita tinjau kembali dalam masa, kerana saya melakukan ini 64 kali. 

Dan perhatikan kali pertama, n ialah 1. kali kedua, n ialah 2, kemudian 4, kemudian 8, kemudian 16. Dan ia seolah-olah bahawa sebaik sahaja Saya dapat kira-kira 1 bilion, jika saya menggandakan lagi, yang perlu memberi saya 2 bilion. Tetapi ternyata, ia adalah betul-betul di puncak itu. 

Dan maka ia sebenarnya melimpah int dari 1 bilion kepada kira-kira negatif 2 bilion, kerana integer, tidak seperti kita nombor telah menganggap minggu lepas, boleh kedua-dua positif dan negatif dalam realiti dan dalam komputer. Dan jadi sekurang-kurangnya salah seorang daripada mereka bit berkesan dicuri. Oleh itu, kita benar-benar hanya mempunyai 31 bit, atau 2 bilion nilai yang mungkin. 

Tetapi untuk sekarang, bawa pulang yang agak semata-mata, apa nombor-nombor ini dan apa sahaja yang matematik adalah, sesuatu yang buruk berlaku akhirnya, lantaran akhirnya kamu cuba untuk abiad bit salah terlalu banyak kali. Dan anda berkesan pergi dari semua 1 untuk mungkin semua 0, atau mungkin hanya beberapa corak lain bahawa ia jelas, bergantung kepada konteks, boleh ditafsirkan sebagai nombor negatif. Dan supaya ia akan kelihatan saya yang paling tinggi boleh mengira dalam program tertentu hanya kira-kira 1 bilion. Tetapi ada penyelesaian separa di sini. Awak tahu tak? 

Biar saya beralih daripada int kepada panjang panjang. Dan biarlah saya pergi ke hadapan di sini dan iaitu- saya akan mempunyai menukar ini kepada yang tidak ditandatangani panjang. Atau, mari kita lihat, saya tidak pernah ingat diri saya sendiri. 

Mari kita pergi ke hadapan dan membuat limpahan. Tidak, itu bukan sahaja, LLD, terima kasih. Jadi kadang-kadang dilafaz boleh membantu. Saya tidak ingat apa format yang specifier adalah untuk panjang panjang. 

Tetapi, sesungguhnya, dilafaz memberitahu saya. Green beberapa jenis yang baik, masih bermakna anda telah membuat kesilapan. Ia meneka bahawa saya maksudkan LLD. 

Jadi biarlah saya mengambil ia nasihat, yang lama nombor perpuluhan lama, simpan itu. Dan biarlah saya jalankan ia, titik mengurangkan limpahan, Enter. Dan sekarang apa yang sejuk adalah ini. 

Jika saya tatal kembali ke masa, kita masih mula mengira pada yang sama place-- 1, 2, 4, 8, 16. Notis, kita akan mendapat semua cara sehingga 1 bilion. Tetapi kita selamat sampai ke 2 bilion. 

Kemudian kita dapat 4 bilion, maka 8 bilion, 17 bilion. Dan kita pergi lebih tinggi, dan yang lebih tinggi, dan lebih tinggi. Akhirnya, ini, juga, rehat. 

Akhirnya, dengan panjang panjang, iaitu nilai 64-bit, tidak nilai 32-bit, jika kamu menghitung terlalu tinggi, anda membungkus 0. Dan dalam kes ini, kita berlaku berakhir dengan nombor negatif. 

Jadi ini adalah satu masalah. Dan ternyata bahawa ini masalah tidak semua yang sukar difahami itu. Walaupun saya telah sengaja mencetuskannya dengan kesilapan-kesilapan ini, ternyata kita melihat ia jenis semua di sekeliling kita, atau sekurang-kurangnya sebahagian daripada kita lakukan. 

Jadi dalam Lego Star Wars, jika anda pernah bermain permainan, ternyata anda boleh pergi sekitar melanggar perkara dalam dunia LEGO, dan mengumpul syiling, pada asasnya. Dan jika anda pernah bermain permainan ini terlalu banyak masa, sebagai individu yang tidak dinamakan ini di sini lakukan, jumlah duit syiling yang anda boleh mengumpul , ia akan kelihatan, 4 bilion. 

Kini, dengan ia sebenarnya bulat. Jadi LEGO cuba menjaga perkara-perkara mesra pengguna. Mereka tidak melakukannya tepat 2 untuk 32 kuasa, seminggu lalu. Tetapi 4 bilion sebab. Ia seolah-olah, berdasarkan maklumat ini, bahawa LEGO, dan syarikat yang membuat perisian sebenar ini, memutuskan bahawa bilangan maksimum syiling pengguna boleh mengumpul adalah, sememangnya, 4 bilion, kerana mereka hak dalam kod mereka untuk menggunakan bukan yang panjang panjang, nampaknya, tetapi hanya satu integer, yang tidak ditandatangani integer, hanya integer positif, yang nilai max adalah lebih kurang itu. Nah, di sini adalah satu lagi salah lucu. Jadi, dalam permainan Tamadun, yang sebahagian dari kamu mungkin biasa, dengan ternyata bahawa tahun lalu ada adalah bug dalam permainan ini di mana jika anda memainkan peranan Gandhi dalam permainan, bagi pihaknya yang sangat damai, sebaliknya adalah sangat, sangat agresif, dalam beberapa keadaan. Khususnya, cara bahawa Tamadun kerja-kerja adalah bahawa jika anda, pemain, mengamalkan demokrasi, anda Rata agresif mendapat decremented oleh dua, jadi tolak tolak, dan kemudian tolak tolak. 

Jadi anda tolak 2 dari mengulanginya sebenar anda. Malangnya, jika mengulanginya adalah mulanya 1, dan anda tolak 2 daripadanya selepas menerima demokrasi sebagai Gandhi di sini mungkin telah dilakukan, kerana dia sangat passive-- 1 pada skala agresif. Tetapi jika dia mengamalkan demokrasi, maka dia pergi dari 1 hingga -1. 

Malangnya, mereka menggunakan nombor yang tidak ditandatangani, yang bermakna mereka dirawat walaupun negatif nombor seolah-olah mereka adalah positif. Dan ternyata bahawa bersamaan positif negatif 1, dalam program-program komputer biasa, 255. Jadi, jika Gandhi mengamalkan demokrasi, dan oleh itu mempunyai Rata agresif beliau menurun, ia sebenarnya gulung di sekeliling kepada 255 dan menjadikan dia yang paling watak agresif dalam permainan. Jadi, anda boleh Google di atas ini. Dan ia adalah, sesungguhnya, yang sengaja program bug, tetapi itu memasuki agak tradisi sejak itu. 

Itu sahaja yang menyeronokkan dan comel. Lebih menakutkan ialah apabila sebenar peranti dunia sebenar, dan bukan permainan, mempunyai ini bug sama. Malah, hanya setahun yang lalu artikel datang maklumat mengenai Dreamliner Boeing 787. 

Dan artikel pada mulanya pandang membaca batin sedikit. Tetapi ia berkata demikian, perisian kelemahan yang terdapat pada Boeing baru 787 Dreamliner jet mempunyai potensi untuk menyebabkan juruterbang hilang kawalan pesawat, mungkin dalam penerbangan, pegawai-pegawai FAA syarikat penerbangan memberi amaran baru-baru ini. Ia adalah penentuan bahawa model 787 kapal terbang yang telah dikuasakan secara berterusan selama 248 hari boleh kehilangan semua arus, AC, kuasa elektrik kerana penjana unit kawalan, GCUs, pada masa yang sama pergi ke gagal mod selamat. Ia adalah jenis kehilangan saya. Tetapi memo yang dinyatakan, OK, sekarang saya mendapat bahawa, keadaan itu disebabkan oleh perisian yang menangkis dalaman untuk kawalan penjana unit yang akan melimpah selepas 248 hari kuasa berterusan. Kami menerbitkan ini notis untuk mengelakkan kehilangan semua AC elektrik kuasa, yang boleh mengakibatkan kehilangan kawalan pesawat tersebut. 

Jadi, secara literal, terdapat beberapa integer, atau beberapa jenis data yang setara, digunakan dalam perisian dalam kapal terbang sebenar bahawa jika anda menyimpan kapal terbang anda cukup lama, yang nampaknya boleh berlaku jika anda hanya berjalan mereka sentiasa dan tidak pernah mencabut plag kapal terbang anda, ia seolah-olah, atau membiarkan baterinya mati, akhirnya akan mengira, dan ke atas, dan ke atas, dan ke atas, dan ke atas, dan ke atas. 

Dan, dengan alam semula jadi, jumlah terhingga memori akan melimpah, bergolek kembali ke sifar atau beberapa nilai negatif, kesan sampingan yang merupakan realiti tampak sebenar bahawa pesawat itu mungkin perlu yang akan reboot, berkesan, atau mungkin jatuh lebih teruk lagi, kerana ia terbang. Jadi ini jenis isu-isu masih dengan kami, even-- ini adalah satu artikel 2015, semua lebih menakutkan apabila anda tidak semestinya memahami, menghargai, atau menjangka orang-orang jenis kesilapan. 

Jadi, ternyata ada satu lain perkara yang buruk tentang perwakilan data. Ia ternyata bahawa walaupun terapung adalah jenis cacat, kerana kereta berhias, juga, Saya dicadangkan adalah 32 bit, atau mungkin 64 jika anda menggunakan dua kali ganda. Tetapi itu masih terbatas. 

Dan tangkapan adalah bahawa jika anda boleh meletakkan nombor terhingga nombor selepas titik perpuluhan, tidak ada cara anda boleh mewakili semua kemungkinan nombor yang kita telah diajar dalam gred sekolah boleh wujud di dunia. Komputer, pada dasarnya, perlu memilih subset daripada nombor-nombor untuk mewakili dengan tepat. 

Sekarang, komputer boleh pusingan mungkin sedikit, dan boleh membolehkan anda untuk secara kasar kedai apa-apa nombor yang anda mungkin mungkin mahu. Tetapi gerak hati, jika anda mempunyai nombor terhingga bit, anda hanya boleh abiad mereka dalam pelbagai cara terhingga. Jadi, anda tidak mungkin boleh menggunakan nombor yang terhad daripada atur bit, corak sifar dan satu, untuk mewakili tidak terhad beberapa nombor, yang menunjukkan bahawa komputer mungkin baik boleh berbohong kepada kami kadang-kadang. 

Malah, mari kita buat ini. Biar saya pergi semula ke dalam CS50 IDE. Biar saya pergi ke hadapan dan mewujudkan program kecil dipanggil ketakpersisan, untuk menunjukkan bahawa komputer adalah, sesungguhnya, tidak tepat. 

Dan biarlah saya pergi ke hadapan dan mula dengan beberapa kod itu daripada sebelum ini, dan kini hanya melakukan yang berikut. Biar saya pergi ke hadapan dan melakukan printf, peratus f, garis sendeng terbalik n, 1 dibahagikan dengan 10. Dalam erti kata lain, mari kita menyelam lebih mendalam dengan 1/10, seperti 1 dan dibahagikan dengan 10. Sesungguhnya, komputer boleh mewakili 1/10. 

Jadi mari kita pergi ke hadapan dan membuat ketakpersisan. Mari kita lihat. Format menentukan jenis kelamin. Tetapi hujah mempunyai jenis int. Apa yang sedang berlaku? 

Oh, menarik, jadi ia adalah satu pengajaran daripada sebelum ini. Saya berkata, hey, pameran komputer saya apungan dengan peratus f. Tetapi saya memberikan 2 ints. Jadi ternyata, saya boleh menetapkan ini dalam beberapa cara. 

Saya hanya boleh bertukar satu ke 1.0, dan 10 ke 10.0, yang akan, sesungguhnya, mempunyai kesan menukar mereka ke dalam floats-- masih diharapkan nombor yang sama. Atau ia ternyata ada sesuatu kita akan melihat sekali lagi tidak lama lagi. Anda boleh membuang nombor. 

Anda boleh, dengan menggunakan kurungan ini ungkapan, anda boleh berkata, hey, komputer, mengambil ini 10, yang saya tahu adalah int. Tetapi merawat, sila, seolah-olah ia apungan. Tetapi ini merasakan tidak perlu kompleks. 

Untuk tujuan kita hari ini, mari kita secara literal membuat mereka terapung mata yang dengan titik perpuluhan, seperti ini. Biar saya pergi ke hadapan dan jalankan lagi, membuat ketakpersisan, baik, slash dot ketakpersisan, masukkan. OK, kita cari yang baik. 

1 dibahagikan dengan 10, menurut saya Mac sini, adalah, sememangnya, 0,100000. Sekarang, saya telah diajar di sekolah rendah terdapat perlu nombor terhingga 0 ini. Jadi mari kita sekurang-kurangnya cuba untuk melihat beberapa daripada mereka. Ia ternyata bahawa printf adalah sedikit masih pelamun daripada kita telah menggunakan. Ia ternyata anda tidak perlu untuk menentukan hanya peratus f, atau hanya peratus i. Anda sebenarnya boleh menentukan beberapa pilihan kawalan di sini. 

Secara khusus, saya akan berkata, hey, printf, sebenarnya menunjukkan saya 10 titik perpuluhan. Jadi ia kelihatan sedikit pelik. Tetapi kamu berkata peratus, dot, berapa banyak nombor anda mahu melihat selepas titik perpuluhan, dan kemudian f untuk rata, hanya kerana itulah apa dokumentasi yang berkata. Biar saya pergi ke hadapan dan menyelamatkan itu. 

Dan perhatikan juga, saya mendapat letih menaip semula perkara. Jadi saya hanya menubuhkan dan turun arrow pada kunci saya di sini. Dan jika saya terus memukul, anda boleh melihat semua arahan yang saya buat, atau tidak betul dibuat. 

Dan saya akan pergi ke hadapan sekarang dan sebenarnya tidak menggunakan bahawa, nampaknya. Membuat ketakpersisan, dot mengurangkan imprecision-- supaya apa yang saya diajar dalam sekolah rendah mendaftar keluar. Walaupun saya mencetak 10 perpuluhan meletakkan ia, sesungguhnya, adalah 0,10000. Tetapi anda tahu apa? 

Mari kita mendapatkan sedikit tamak. Katakan, seperti, menunjukkan kepada saya 55 mata selepas perpuluhan. Mari kita benar-benar mengambil ini program keluar untuk spin. Biar saya membentuk semula dengan make ketakpersisan, slash dot, ketakpersisan. 

Dan di sini kita pergi. zaman kanak-kanak anda adalah satu pembohongan. Rupa-rupanya, 1 dibahagikan dengan 10 memang 0.100000000000000005551115123-- 

Apa yang sedang berlaku? Nah, ternyata, jika anda jenis melihat cukup jauh di dalam asas perwakilan ini nombor, ia sebenarnya tidak betul-betul 1/10, atau 0.1 dan nombor terhingga sifar. Sekarang, mengapa? 

Well, walaupun ini adalah mudah nombor untuk kita manusia, 1 dibahagikan dengan 10, ia masih salah satu daripada banyak tak terhingga nombor yang kita boleh berfikir sehingga. Tetapi komputer hanya boleh mewakili terhingga banyak nombor demikian. Dan sebagainya, berkesan, apa yang komputer menunjukkan kepada kita adalah yang paling hampir yang anggaran bilangan kita mahu untuk mempercayai adalah 1/10, atau benar-benar 0,10000 iklan infinitum. 

Sebaliknya, walaupun, ini adalah sehampir ia boleh mendapatkan. Dan, sememangnya, jika anda melihat di bawah hood, kerana kami di sini dengan melihat 55 digit selepas perpuluhan, kita sebenarnya melihat realiti itu. Sekarang sebagai diketepikan, jika anda telah pernah melihat movie-- sebahagian besar daripada anda mungkin have not tetapi Superman 3 beberapa tahun yang lalu, Richard Pryor dasarnya dimanfaatkan ini realiti dalam syarikatnya untuk mencuri banyak pecahan dan pecahan beberapa sen, kerana company-- seperti yang saya ingat, ia telah while-- pada dasarnya membuang apa-apa yang tidak sesuai ke dalam tanggapan sen. 

Tetapi jika anda menambah semua ini kecil, kecil, nombor kecil lagi, dan sekali lagi, dan sekali lagi, anda boleh, seperti dalam kesnya, membuat jumlah wang yang baik. 

Itu idea yang sama telah ditipu oleh yang lebih baru-baru ini, tetapi masih sekarang lebih tua filem, yang dipanggil Ruang Pejabat, mana lelaki di dalam filem itu, melakukan perkara yang sama, kacau sehingga sepenuhnya, berakhir dengan terlalu banyak wang dalam akaun bank mereka. Ia adalah sangat mencurigakan. Tetapi pada akhir hari, ketakpersisan adalah di sekeliling kita. 

Dan itu juga, boleh menjadi tampak kes itu. Ia ternyata bahawa Superman 3 dan Ruang Pejabat diketepikan, terdapat boleh beberapa amat nyata kesan dunia daripada realiti tidak tepat perwakilan data bahawa walaupun kita manusia untuk hari ini tidak semestinya memahami dan juga kita harus, atau ingat sekerap yang kita sepatutnya. Dan, sememangnya, klip berikut adalah dari melihat beberapa dunia yang amat nyata kesan daripada apa yang berlaku jika anda tidak menghargai ketakpersisan yang boleh berlaku dalam jumlah perwakilan. 

[VIDEO MAIN SEMULA] 

-Computers, Kami semua datang untuk menerima masalah sering mengecewakan pergi dengan mereka, kelak pepijat, virus, dan glitches perisian, untuk harga yang kecil untuk membayar untuk kemudahan. Tetapi dalam teknologi tinggi dan kelajuan tinggi tentera dan program angkasa aplikasi, masalah yang paling kecil boleh akan menjadi besar ke dalam bencana. 

Pada 4 Jun, 1996, ahli-ahli sains yang disediakan untuk melancarkan tanpa pemandu Ariane 5 roket. Ia membawa saintifik satelit direka untuk mewujudkan dengan tepat bagaimana berinteraksi medan magnet bumi dengan angin solar. Roket ini dibina untuk Agensi Angkasa Eropah, dan diangkat dari kemudahannya di pantai Guiana Perancis. 

-at Kira-kira 37 saat ke dalam penerbangan, mereka mula-mula perasan ada sesuatu yang tidak beres. Muncung telah berputar di cara yang mereka benar-benar tidak sepatutnya. Kira-kira 40 saat ke dalam penerbangan, jelas, kenderaan yang dalam kesusahan. 

Dan itulah apabila mereka membuat keputusan untuk memusnahkan ia. Pegawai keselamatan pelbagai, dengan keberanian besar, ditekan butang, meletupkan roket, sebelum ia boleh menjadi bahaya kepada keselamatan awam. 

-Ini Adalah sulung pelayaran Ariane 5. Dan kehancuran mengambil meletakkan kerana kecacatan tertanam dalam perisian roket. -The Masalah pada Ariane adalah bahawa ada sebilangan yang diperlukan 64 bit untuk meluahkan. Dan mereka mahu untuk menukar kepada beberapa 16-bit. Mereka mengandaikan bahawa nombor tidak pernah akan sangat besar, yang kebanyakan mereka digit dalam nombor 64-bit adalah sifar. Mereka adalah salah. 

-The Ketidakupayaan satu program perisian untuk menerima jenis nombor yang dijana oleh lain merupakan punca kegagalan. pembangunan perisian telah menjadi sangat mahal sebahagian daripada teknologi baru. Roket Ariane telah sangat berjaya, jadi banyak perisian dicipta untuk itu juga digunakan dalam Ariane 5. 

-The Masalah asas adalah bahawa Ariane 5 adalah lebih cepat, mempercepatkan lebih cepat. Dan perisian yang tidak mempunyai menyumbang untuk itu. 

-The Kemusnahan roket merupakan satu malapetaka kewangan yang besar, semua kerana kesilapan perisian minit. Tetapi ini bukanlah yang pertama masa masalah penukaran data membelenggu teknologi roket moden. 

-Dalam 1991, dengan permulaan Perang Teluk pertama, Patriot Missile mengalami jenis yang sama masalah jumlah penukaran. Dan hasilnya, 28 orang, 28 tentera Amerika, terbunuh, dan kira-kira 100 yang lain cedera, apabila Patriot, yang sepatutnya untuk melindungi daripada scuds masuk, gagal untuk menembak peluru berpandu. 

-Apabila Iraq menyerang Kuwait, dan Amerika dilancarkan Desert Storm pada awal tahun 1991, bateri Patriot peluru berpandu telah dikerahkan untuk melindungi Arab Saudi dan Israel daripada serangan peluru berpandu Scud Iraq. The Patriot adalah sederhana US permukaan untuk sistem udara, yang dikeluarkan oleh syarikat Raytheon itu. 

-The Saiz pemintas Patriot sendiri adalah kira-kira kira-kira 20 kaki panjang. Dan ia mempunyai berat kira-kira 2,000 pound. Dan ia membawa kepala peledak kira-kira, Saya fikir ia adalah kira-kira 150 pound. Dan kepala peledak itu sendiri adalah letupan yang tinggi, yang mempunyai serpihan di sekitarnya. Sarung kepala peledak adalah direka untuk bertindak seperti peluru. 

-The Peluru berpandu dibawa empat setiap bekas, dan diangkut oleh sebuah treler semi. 

-The Sistem Patriot anti-peluru berpandu kembali sekurang-kurangnya 20 tahun. Ia direka bentuk asalnya sebagai pertahanan peluru berpandu udara untuk menembak jatuh kapal terbang musuh. Dalam Perang Teluk pertama, apabila perang yang datang bersama-sama, Tentera mahu menggunakannya untuk menembak jatuh scuds, bukan kapal terbang. 

Tentera Udara Iraq tidak begitu banyak masalah. Tetapi Tentera bimbang mengenai scuds. Dan kerana itu mereka cuba meningkatkan Patriot. 

-Intercepting Musuh peluru berpandu bergerak pada mach 5 telah pergi untuk mencabar cukup. Tetapi apabila Patriot dikejarkan ke dalam perkhidmatan, Tentera tidak sedar yang pengubahsuaian Iraq yang dibuat scuds mereka hampir mustahil untuk memukul. 

-Apa Yang berlaku adalah scuds yang telah datang tidak stabil. Mereka terumbang-ambing. Sebab untuk ini adalah Iraq, untuk untuk mendapatkan 600 kilometer daripada 300 kilometer peluru berpandu jarak, mengambil berat daripada kepala peledak depan. Mereka membuat kepala peledak yang lebih ringan. 

Jadi sekarang Patriot adalah cuba untuk datang dengan Scud. Dan sebahagian besar dari masa itu, Sebahagian besar masa, ia hanya akan terbang oleh Scud. Apabila pengendali sistem Patriot menyedari Patriot tersasar, mereka meletupkan kepala peledak Patriot untuk mengelakkan mangsa mungkin jika ia telah dibiarkan jatuh ke tanah. 

-Itu Adalah apa yang kebanyakan orang melihat, orang-orang bola api besar di langit, dan disalah anggap sebagai memintas kepala peledak Scud. 

-Although Pada waktu malam langit, Patriots muncul untuk menjadi berjaya memusnahkan Scuds, di Dhahran, mungkin ada kesilapan yang tidak mengenai prestasinya. Di sana, sistem radar Patriot trek kehilangan yang Scud masuk, dan tidak pernah dilancarkan berikutan kepada kecacatan perisian. Ia adalah Israel yang pertama kali ditemui bahawa sistem lagi yang berada di atas, yang lebih besar perbezaan masa yang menjadi, kerana jam tertanam dalam komputer sistem. 

-Kira-Kira dua minggu sebelum tragedi di Dhahran, Israel dilaporkan Jabatan Pertahanan bahawa sistem telah kehilangan masa. Selepas kira-kira lapan jam atau berjalan, mereka menyedari bahawa sistem telah menjadi nyata kurang tepat. Jabatan Pertahanan bertindak balas dengan memberitahu semua bateri Patriot untuk tidak meninggalkan sistem untuk jangka masa yang panjang. Mereka tidak pernah berkata apa masa yang lama was-- lapan jam, 10 jam, 1000 jam. Tiada siapa yang tahu. 

-The Bateri Patriot ditempatkan di berek di Dhahran dan dalaman cacat yang jam telah di lebih 100 jam pada malam 25 Feb. 

-Ia Dikesan semasa ke ketepatan yang kira-kira satu per sepuluh daripada satu saat. Sekarang, satu per sepuluh daripada satu saat adalah nombor menarik, kerana ia tidak boleh dinyatakan dalam binari betul-betul, yang bermakna ia tidak boleh dinyatakan dengan tepat di mana-mana komputer digital moden. Adalah sukar untuk mempercayai. 

Tetapi menggunakan ini sebagai contoh. Mari kita ketiga nombor satu. Satu pertiga tidak boleh dinyatakan dalam perpuluhan dengan tepat. Satu pertiga adalah 0,333 berlaku selama infiniti. 

Tidak ada cara untuk melakukan itu dengan ketepatan mutlak dalam perpuluhan. Itulah jenis masalah yang berlaku di Patriot. Sistem ini lebih panjang itu berlari, yang lebih teruk ralat masa yang menjadi. 

-Selepas 100 jam operasi, kesilapan dalam masa hanya kira-kira satu pertiga saat. Tetapi dari segi menyasarkan peluru berpandu bergerak pada mach 5, ia menyebabkan pengesanan yang kesilapan lebih 600 meter. Ia akan menjadi satu kesilapan yang teramat untuk tentera kepada apa yang berlaku ialah pelancaran Scud adalah dikesan oleh satelit Amaran awal dan mereka tahu bahawa Scud adalah datang dari arah umum mereka. Mereka tidak tahu di mana ia datang. 

-Ia Kini terpulang kepada radar komponen sistem Patriot mempertahankan Dhahran untuk mencari dan menyimpan mengesan peluru berpandu musuh yang datang. 

radar -The sangat pintar. Ia sebenarnya akan mengesan kedudukan Scud, dan kemudian meramalkan di mana ia mungkin akan menjadi masa yang akan datang radar yang dihantar a nadi keluar. Yang dipanggil pintu pelbagai. 

-Kemudian, Sebaik sahaja Patriot memutuskan masa yang cukup mempunyai diluluskan untuk kembali dan memeriksa seterusnya lokasi bagi objek yang dikesan ini, ia kembali. Oleh itu, apabila ia kembali kepada salah tempat, ia kemudian melihat objek tidak. Dan ia memutuskan bahawa tidak ada objek, ia adalah pengesanan palsu, dan jatuh trek. 

-The Scud yang diterima dan hilang dari skrin radar. Dan saat kemudian, ia menyelar ke markas. Scud membunuh 28, dan adalah yang terakhir satu dipecat semasa Perang Teluk pertama. 

Malang sekali, perisian terkini tiba di Dhahran pada hari berikutnya. Perisian kecacatan mempunyai menjadi tetap, tutup salah satu bab dalam bermasalah sejarah peluru berpandu Patriot. 

[VIDEO MAIN SEMULA] DAVID J. MALAN: Jadi ini adalah semua untuk mengatakan bahawa isu-isu ini limpahan dan ketakpersisan adalah terlalu nyata. Jadi, bagaimana kita di sini? Kami bermula dengan hanya bercakap tentang printf. Sekali lagi, fungsi ini, mencetak sesuatu untuk skrin, dan kami diperkenalkan selepas itu beberapa fungsi lain dari perpustakaan dipanggil CS50. Dan kita akan terus melihat ini dalam masa terdekat. Dan kita, khususnya, digunakan mendapatkan tali, dan mendapatkan int, dan kini juga mendapat apungan, dan yang lain lagi masih akan kita temui dan menggunakan diri kita sendiri tidak lama lagi. 

Tetapi kadang-kadang, ada kita telah melihat keperluan untuk menyimpan apa fungsi-fungsi tangan kembali? Mereka menyerahkan kita kembali rentetan, atau int, atau apungan. Dan kadang-kadang kita perlu meletakkan bahawa tali, atau int, atau terapung, di suatu tempat. 

Dan untuk menyimpan perkara-perkara, ingat hanya seperti di Awal, kami mempunyai pembolehubah. Tetapi tidak seperti di Awal, dalam C kita mempunyai jenis yang sebenar data variables-- jenis, lebih generally-- di antara mereka, rentetan, int, yang terapung, dan ini orang lain masih. 

Dan supaya apabila kita mengisytiharkan pembolehubah dalam C, kita akan mempunyai untuk mengisytiharkan jenis data kami. Ini bukanlah sesuatu yang kami akan perlu lakukan kemudian pada semester seperti yang kita beralih ke bahasa lain. Tetapi untuk sekarang, kita perlu kepada priori terlebih dahulu, menjelaskan kepada komputer apa jenis pembolehubah kita mahu ia berikan kepada kami. 

Sekarang, sementara itu, untuk mencetak orang-orang jenis jenis data, kita perlu memberitahu printf apa yang diharapkan. Dan kita melihat peratus kerana tali, dan peratus i untuk integer, dan beberapa yang lain sudah. Dan orang-orang yang hanya keperluan untuk persembahan visual maklumat tersebut. 

Dan masing-masing sebenarnya boleh parametrized atau mengagak dalam beberapa cara, jika anda ingin melanjutkan kawalan jenis output yang anda dapat. Dan, sebenarnya, ternyata bahawa bukan sahaja ada garis sendeng terbalik n untuk barisan baru. Ada sesuatu yang lain dipanggil garis sendeng terbalik r untuk pembawa kembali, yang adalah lebih mirip kepada mesin taip sekolah lama, dan juga Windows digunakan selama bertahun-tahun. 

Ada t garis sendeng terbalik untuk tab. Rupa-rupanya, bahawa jika anda mahu petikan berganda dalam rentetan, ingat bahawa kita telah menggunakan dua petikan berganda quote di sebelah kiri dan kanan berakhir rentetan kami setakat ini. Yang seolah-olah mengelirukan perkara. 

Jika anda mahu meletakkan petikan berganda dalam tengah-tengah string-- dan, sememangnya, ia mengelirukan untuk melihat. Dan supaya anda perlu untuk melarikan diri, jadi untuk bercakap, petikan berganda dengan sesuatu seperti, secara literal, garis sendeng terbalik petikan berganda. Dan ada beberapa tempat lain masih. Dan kita akan melihat lebih banyak dari orang-orang dalam penggunaan sebenar tidak lama lagi. 

Jadi mari kita kini beralih daripada data, dan perwakilan, dan pengendali aritmetik, semua yang memberikan kita beberapa bangunan blok dengan mana untuk bermain. Tetapi sekarang mari kita sebenarnya memberi kami seluruh perbendaharaan kata bahawa kita sudah mempunyai minggu lepas dengan Scratch dengan mengambil lihat beberapa lain konstruk dalam C-- tidak semua daripada mereka. Tetapi idea-idea kita kira-kira untuk melihat benar-benar hanya untuk menekankan terjemahan dari satu bahasa, Awal, yang lain, C. 

Dan dari masa ke masa, kami akan mengambil lebih banyak alat untuk Kit kami, boleh dikatakan, sintaksis. Dan, sememangnya, anda akan melihat bahawa idea-idea kini agak biasa dari minggu lepas. Jadi mari kita buat ini. 

Mari kita pergi ke depan dan menyiapkan program yang benar-benar menggunakan beberapa ungkapan, ungkapan Boolean. Biar saya pergi ke hadapan di sini dan membuat fail baru. Saya akan panggil condition.c ini. 

Biar saya pergi ke hadapan dan termasuk perpustakaan CS50. Dan biarlah saya pergi ke hadapan dan termasuk standard io.h untuk fungsi kami, dan printf, dan banyak lagi masing-masing. Biar saya memberi diri saya sendiri bahawa boilerplate daripada int tidak sah utama, yang penjelasan kami akan kembali pada masa akan datang. 

Sekarang, saya akan pergi ke hadapan dan memberi diri saya int melalui get int. Maka biarlah saya pergi ke hadapan dan melakukan ini. Saya ingin mengatakan jika saya adalah less-- mari membezakan antara positif, negatif, atau nilai sifar. 

Jadi, jika i adalah kurang daripada sifar, biarlah saya hanya mempunyai program ini hanya berkata, negatif, garis sendeng terbalik n, lain jika saya adalah lebih besar daripada sifar. Kini saya, sudah tentu, akan berkata printf positif, garis sendeng terbalik n. Dan kemudian lagi jika- saya boleh melakukan ini. 

Saya boleh lakukan jika i sama dengan 0. Tetapi saya akan membuat sekurang kurangnya satu kesilapan sudah. Ingat bahawa tanda 'sama tidak sama, kerana kita manusia tahu. 

Tetapi ia adalah pengendali tugasan. Dan kita tidak mahu mengambil 0 pada betul dan memasukkannya ke dalam i di sebelah kiri. Jadi untuk mengelakkan kekeliruan ini, atau mungkin penyalahgunaan tanda sama, manusia telah memilih beberapa tahun yang lalu bahawa dalam banyak bahasa pengaturcaraan apabila anda mahu untuk memeriksa untuk kesaksamaan antara kiri dan kanan, anda sebenarnya menggunakan sama sama. Jadi anda memukul tanda sama dua kali. Apabila anda mahu untuk menetapkan dari kanan ke kiri, anda menggunakan tanda sama tunggal. Oleh itu, kita boleh melakukan this-- lagi jika i sama sama dengan sifar. 

Saya kemudian boleh pergi dan membuka pendakap kerinting saya, dan berkata, printf 0, garis sendeng terbalik n, dilakukan. Tetapi ingat bagaimana garpu di jalan raya boleh bekerja. Dan, benar-benar, hanya berfikir tentang logik. i adalah nombor. Ia adalah integer, secara khusus. Dan ini bermakna ia akan menjadi kurang daripada 0, atau lebih besar daripada 0, atau 0. Jadi ada jenis ini kes lalai tersirat. 

Dan supaya kita boleh, sama seperti Awal, mengetepikan lagi jika, dan hanya berkata lagi. Secara logiknya, jika anda programmer tahu ada sahaja tiga baldi ke dalam mana senario boleh fall-- pertama, kedua, atau ketiga dalam ini case-- tidak mengganggu menambah ketepatan tambahan dan logik tambahan di sana. Hanya pergi ke hadapan dengan kes piawai di sini daripada yang lain. 

Sekarang, mari kita pergi ke hadapan selepas menyimpan ini, membuat syarat dot mengurangkan syarat-syarat-- tidak antara muka pengguna yang hebat, kerana saya tidak mendorong pengguna, seperti yang saya nyatakan sebelum ini. Tetapi itulah denda. Kami akan memastikan ia mudah. Mari kita cuba nombor 42. Dan itu positif. Mari kita cuba bilangan negatif 42, negatif. 

Mari kita cuba nilai 0. Dan, sememangnya, ia berfungsi. Sekarang, anda akan dapat melihat dengan masalah sebelum lama, perkara ujian tiga kali, mungkin tidak mencukupi. Anda mungkin mahu menguji beberapa angka yang lebih besar, beberapa yang lebih kecil nombor, beberapa kes sudut, kerana kami akan datang untuk menggambarkan mereka. 

Tetapi buat masa ini, ini adalah satu program agak mudah. Dan saya cukup pasti, secara logik, bahawa ia jatuh ke dalam tiga kes. Dan, sememangnya, walaupun kita hanya memberi tumpuan kepada kelemahan yang berpotensi daripada ketakpersisan dan limpahan, dalam realiti di mana banyak masalah CS50, kita tidak akan bimbang kira-kira, sepanjang masa, isu-isu limpahan dan ketakpersisan, kerana, sebenarnya, dalam C, ia sebenarnya tidak semua yang mudah untuk mengelakkan perkara-perkara. Jika anda ingin mengira sehingga lebih besar, dan lebih besar, dan lebih besar, ternyata ada teknik anda boleh digunakan, selalunya melibatkan perkara yang dipanggil perpustakaan, koleksi kod, yang orang lain menulis bahawa anda boleh menggunakan, dan bahasa lain seperti Java dan lain-lain, sebenarnya membuat ia lebih mudah untuk mengira yang lebih tinggi. Jadi ia adalah sebahagian daripada bahaya ini fungsi bahasa yang anda gunakan. Dan pada minggu-minggu akan datang, kami akan melihat betapa bahayanya C benar-benar boleh jika anda tidak menggunakannya dengan betul. Tetapi dari sana, dan dengan Python, dan JavaScript, akan kita lapisan pada beberapa perlindungan tambahan, dan menjalankan lebih sedikit daripada risiko tersebut. 

Jadi mari kita membuat lebih sedikit logik yang menarik dalam program kami. Jadi biarlah saya pergi ke hadapan dan mencipta program yang dikenali sebagai Logical hanya jadi saya boleh bermain dengan beberapa logik sebenar, logical.c. Saya hanya akan copy dan paste beberapa kod dari awal supaya saya kembali ke titik permulaan ini bagus. 

Biar saya kali ini melakukan C. char Saya akan memberikan nama C hanya kerana ia adalah konvensional, mendapatkan watak dari pengguna. Dan mari kita berpura-pura seperti Saya melaksanakan sebahagian itu program Rm, keluarkan program sebelum yang mendorong pengguna untuk membuang fail. Bagaimana kita boleh melakukan ini? 

Saya ingin mengatakan, jika C sama sama, quote unquote, y, maka saya akan menganggap yang pengguna telah memilih ya. Saya hanya akan mencetak ya. Jika ia sebenarnya menulis program penyingkiran, kita boleh mengeluarkan fail yang dengan lebih baris kod. Tetapi kita akan memastikan ia mudah. 

Lain jika c sama sama n-- dan kini di sini, saya akan berkata, pengguna perlu bermakna tidak. Dan kemudian yang lain, anda tahu apa? Saya tidak tahu apa lagi yang pengguna akan menaip. Jadi saya hanya akan mengatakan bahawa bahawa adalah satu kesilapan, apa sahaja dia sebenarnya ditaip. 

Jadi apa yang berlaku di sini? Terdapat perbezaan asas berbanding apa yang saya lakukan pada masa lalu. tanda petik, petik, double sebut harga, dan, lagi, petikan tunggal, petikan tunggal. Ternyata dalam C, bahawa apabila anda mahu menulis rentetan, anda menggunakan tanda petik, sebagaimana kami telah telah menggunakan semua kali ini dengan printf. 

Tetapi jika anda mahu berurusan dengan hanya watak tunggal, char yang dipanggil, maka anda benar-benar menggunakan petikan tunggal. Orang-orang yang telah diprogramkan sebelum ini, anda mungkin tidak mempunyai mempunyai bimbang tentang perkara ini kepujian dalam bahasa tertentu. Dalam C, ia menjadi persoalan. Dan apabila saya mendapat char dan saya mahu untuk membandingkan char yang menggunakan sama sama dengan beberapa surat seperti y atau n, yang saya lakukan, sesungguhnya, perlu mempunyai petikan tunggal. 

Sekarang, mari kita pergi ke hadapan dan melakukan ini. Mari kita pergi ke hadapan dan jangan membuat dot logik mengurangkan logik. Dan sekarang saya diminta. Jadi, mungkin, pengalaman pengguna yang lebih baik sebenarnya akan memberitahu saya apa yang perlu dilakukan di sini. Tetapi saya akan hanya membuta tuli mengatakan y bagi ya, OK, bagus. 

Mari kita berjalan sekali lagi, n untuk tidak, bagus. Katakan seperti orang-orang tertentu yang saya tahu, topi saya mengunci utama adalah pada semua terlalu kerap. Jadi saya lakukan modal Y, masukkan, kesilapan. OK, ia tidak betul-betul apa yang saya jangkakan. Sesungguhnya, komputer melakukan literal apa Saya diberitahu ia do-- memeriksa huruf kecil dan huruf kecil y n. Ini tidak merasa seperti baik pengalaman pengguna, walaupun. Biar saya meminta dan menerima sama ada kes yang lebih rendah atau huruf besar. Jadi ternyata, anda mungkin mahu untuk mengatakan sesuatu seperti di Awal, seperti literal atau C sama sama dengan ibu tunggal y dipetik. Rupa-rupanya, C tidak mempunyai kata kunci literal ini atau. 

Tetapi ia mempunyai dua bar menegak. Anda perlu memegang Shift biasanya, jika anda menggunakan papan kekunci AS, dan terkena palang menegak utama di atas kekunci kembali anda. Tetapi bar menegak ini bar menegak bermakna atau. 

Jika, sebaliknya, kita mahu katakan dan, seperti di Awal, kita boleh melakukan Ampersand Ampersand. Yang tidak masuk akal logik sini, kerana manusia tidak mungkin boleh telah ditaip kedua-dua y dan huruf kecil y dan modal Y sebagai watak yang sama. Jadi atau apa yang kita berniat di sini. 

Jadi, jika saya melakukan ini dalam kedua-dua tempat, atau c sama dengan sekutu-sekutu modal N, kini menjalankan semula, membuat logik, jalankan lagi logik. Sekarang, saya boleh menaip y. Dan saya boleh melakukannya sekali lagi dengan modal Y atau N. modal Dan saya boleh menambah tambahan gabungan masih. 

Jadi ini adalah satu logik program setakat yang sekarang Saya memeriksa secara logik untuk nilai ini atau nilai ini. Dan saya tidak perlu, semestinya, datang dengan dua IFS lebih lagi yang IFS. Saya sebenarnya boleh menggabungkan beberapa logik yang berkaitan bersama-sama dengan cara ini. Jadi ini akan menjadi lebih baik direka daripada sekadar berkata, jika C sama dengan kes yang lebih rendah y, mencetak ya, lain jika c sama dengan modal Y, mencetak ya, lain jika c sama lower-- dalam erti kata lain, anda tidak perlu mempunyai lebih dan lebih banyak cawangan. Anda boleh menggabungkan beberapa bersamaan cawangan secara logik, kerana dengan cara ini. 

Jadi mari kita lihat pada hanya satu Kandungan terakhir, satu konstruk akhir, bahawa C membolehkan. Dan kita akan kembali dalam masa depan kepada orang lain masih. Dan kemudian kita akan membuat kesimpulan dengan melihat kerana tidak ketepatan code-- mendapat kod untuk work-- tetapi reka bentuk kod, dan menanam mereka benih awal. 

Jadi biarlah saya pergi ke hadapan dan membuka fail baru di sini. Awak tahu tak? Saya akan melaksanakan semula bahawa program sama, tetapi menggunakan konstruk yang berbeza. 

Jadi biarlah saya cepat memberikan diri saya akses untuk memasukkan CS50.h untuk perpustakaan CS50, Io.h standard untuk printf. Berikan saya tidak sah utama int saya. Dan kemudian di sini, mari saya pergi ke hadapan dan melakukan ini. 

Char c mendapat mendapatkan char, sama seperti sebelum ini. Dan saya akan menggunakan konstruk baru sekarang-- menukar, kepada apa yang watak? Jadi suis jenis seperti beralih trek kereta api. Atau, benar-benar, ia adalah jenis jika lain, jika lain jika, tetapi ditulis agak berbeza. 

Suis kelihatan seperti ini. Anda mempunyai suis, dan kemudian apa watak atau nombor yang anda mahu untuk melihat, kemudian beberapa pendakap kerinting suka dalam Awal, hanya mengatakan melakukan barangan ini. Dan kemudian anda mempunyai kes yang berbeza. 

Anda tidak menggunakan jika dan lain. Anda benar-benar menggunakan kes perkataan. Dan anda akan mengatakan sesuatu seperti ini. 

Jadi, dalam hal suatu huruf kecil y, atau dalam hal harta modal Y, teruskan dan mencetak ya. Dan kemudian keluar daripada suis. Itu sahaja. Telah siap. 

Yang lain jika, boleh dikatakan, huruf kecil n, atau modal N, kemudian pergi ke hadapan dan cetak daripada tidak, dan kemudian pecah. Else-- dan ini jenis adalah kes lalai indeed-- printf error-- dan hanya untuk langkah yang baik, walaupun secara logik rehat ini tidak perlu kerana kita berada di akhir suis anyway, Saya kini melanggar suis. Jadi ini kelihatan sedikit berbeza. 

Tetapi, secara logiknya, ia sebenarnya setara. Dan mengapa anda akan menggunakan berbanding dengan yang lain? Kadang-kadang, hanya keutamaan peribadi, kadang-kadang estetika, jika saya pandang pada ini sekarang, ada sesuatu yang boleh dikatakan bagi yang kebolehbacaan kod ini. Maksud saya, tidak pernah pedulikan fakta bahawa ini Kod baru kepada ramai di antara kita di dalam bilik. 

Tetapi ia hanya jenis cantik. Anda lihat huruf kecil y, modal Y, huruf kecil n, lalai modal N, ia hanya jenis melompat keluar pada anda dengan cara yang itu, boleh dikatakan, mungkin contoh sebelumnya dengan IFS, dan bar menegak, dan lain yang IFS, mungkin tidak mempunyai. Jadi ini adalah benar-benar satu perkara peribadi pilihan, benar-benar, atau pembacaan, kod. 

Tetapi dari segi fungsi, biarlah saya pergi ke hadapan dan membuat suis, slash dot suis, dan kini menaip y huruf kecil, modal Y, n huruf kecil, modal N, David, cuba semula kerana itulah tidak bersifat tunggal. Mari kita buat x, kesilapan, seperti yang diharapkan. Dan, logically-- dan ini adalah sesuatu Saya akan menggalakkan dalam general-- walaupun walaupun kita hanya menggaru permukaan beberapa ciri-ciri ini. 

Dan ia mungkin tidak jelas apabila anda diri duduk di papan kekunci, bagaimana ini berfungsi? Apa yang akan anda lakukan? Perkara yang indah tentang mempunyai komputer riba, atau desktop, atau akses ke komputer dengan pengkompil, dan dengan editor kod seperti ini, adalah anda boleh hampir selalu menjawab soalan- soalan untuk diri sendiri hanya dengan mencuba. 

Sebagai contoh, jika retorik Persoalannya adalah, apa yang berlaku jika anda terlupa kenyataan rehat anda? Yang sebenarnya adalah sangat biasa perkara yang perlu dilakukan, kerana ia tidak kelihatan seperti anda benar-benar memerlukannya. Mereka sebenarnya tidak melengkapkan anda berfikir seperti satu kurungan atau kerinting yang pendakap tidak. Mari kita pergi ke hadapan dan susun semula kod dan lihat. Oleh itu, suis, suis slash dot. Mari kita menaip dalam huruf kecil y, kes atas, Enter. Jadi saya menaip y. 

program itu berkata ya, tidak, kesilapan, seolah-olah ia telah berubah fikiran. Tetapi ia jenis itu, kerana apa yang berlaku dengan suis adalah kes pertama yang Perlawanan pada dasarnya bermakna, hey komputer, melaksanakan semua kod di bawahnya. Dan jika anda tidak mengatakan rehat, atau tidak mengatakan rehat, atau tidak berkata rehat, komputer akan meniup melalui semua mereka garis dan melaksanakan mereka semua sehingga ia sampai ke yang pendakap kerinting. Jadi brek adalah yang sebenarnya perlu. Tetapi bisa dibesarkan di sini, apabila ragu-ragu, cuba sesuatu. Mungkin menyelamatkan kod anda terlebih dahulu, atau menyimpannya dalam fail tambahan jika anda benar-benar bimbang tentang main dan perlu pulih kerja yang anda tahu bekerja. 

Tetapi cuba sesuatu. Dan janganlah kamu menjadi seperti takut, mungkin, apa komputer mungkin lakukan, atau bahawa anda mungkin memecahkan sesuatu. Anda sentiasa boleh kembali semula kepada versi beberapa lebih awal. 

Jadi mari kita berakhir dengan melihat di reka bentuk kod. Kami mempunyai keupayaan ini sekarang untuk menulis syarat, dan gelung menulis, dan pembolehubah, dan fungsi panggilan. Jadi, terus-terang, kami jenis kembali di mana kita minggu yang lalu dengan Awal, walaupun dengan teks yang kurang menarik persekitaran daripada Scratch membolehkan. 

Tetapi perhatikan berapa cepat kita telah diperolehi bahawa perbendaharaan kata, walaupun ia akan mengambil sedikit masa untuk tenggelam dalam, supaya kita kini boleh menggunakan perbendaharaan kata ini untuk menulis program lebih menarik. Dan mari kita mengambil langkah bayi ke arah itu, seperti berikut. Biar saya pergi ke hadapan dan membuat fail baru di sini. 

Saya akan memanggil ini prototype.c, dan memperkenalkan buat kali pertama, keupayaan untuk membuat fungsi anda sendiri. Sebahagian daripada anda mungkin mempunyai melakukan ini dengan Awal, di mana anda boleh membuat anda blok adat sendiri di Awal, dan kemudian mengheret mereka ke dalam tempat mana sahaja yang anda mahu dalam C. Dan dalam kebanyakan program bahasa, anda boleh melakukan perkara bahawa- membuat fungsi anda sendiri, jika mereka belum wujud. 

Jadi, sebagai contoh, mari saya pergi ke hadapan dan termasuk CS50.h, dan termasuk standard io.h, int tidak sah utama. Dan sekarang kita mempunyai pemegang tempat bersedia untuk pergi. Saya menjaga perkara-perkara percetakan seperti nama orang hari ini. Dan yang terasa like-- tidak akan lebih baik jika ada adalah fungsi yang dipanggil nama cetak? Saya tidak perlu menggunakan printf. Saya tidak perlu ingat semua kod format. Mengapa tidak saya, atau mengapa tidak seseorang di hadapan saya, membuat cetak fungsi dipanggil nama, yang diberikan beberapa nama, hanya mencetak ia keluar? 

Dalam erti kata lain, jika saya katakan, hey, komputer, memberi saya rentetan dengan meminta pengguna untuk itu, melalui fungsi mendapatkan tali CS50. Hey, komputer, meletakkan tali yang di pembolehubah di sebelah kiri, dan memanggilnya s. Dan kemudian, hey komputer, teruskan dan mencetak nama orang itu, dilakukan. 

Sekarang, ia akan lebih baik, kerana program ini, dinamakan, memberitahu saya apa yang ia sepatutnya lakukan melalui nama-nama orang-orang fungsi ini. Biar saya pergi dan membuat prototaip, Enter. Dan, malangnya, ini tidak akan terbang. 

Prototype.c, talian 7, watak 5, kesilapan, pengakuan tersirat fungsi nama cetak adalah tidak sah di C99, C99 bermaksud versi C yang keluar pada tahun 1999. Itu sahaja. 

Jadi, saya tidak tahu apa yang semua ini bermakna lagi. Tetapi saya menyedari kesilapan dalam merah. Itu cukup jelas. 

Dan nampaknya dengan watak hijau di sini, isu ini adalah dengan nama cetak, terbuka paren s, paren rapat, koma bertitik. Tetapi pengakuan tersirat fungsi, kami pernah secara ringkas sebelum ini. Ini bermakna, hanya, yang dilafaz tidak tahu apa yang saya maksudkan. 

Saya telah menggunakan perkataan perbendaharaan kata bahawa itu pernah melihat atau telah diajar sebelum ini. Oleh itu, saya perlu mengajar apa fungsi ini bermakna. Jadi, saya akan pergi ke hadapan dan melakukan itu. 

Saya akan pergi ke hadapan dan melaksanakan fungsi saya sendiri dipanggil Cetak Nama. Dan saya akan berkata, seperti yang berikut, ia melakukan ini, printf, hello, peratus s, garis sendeng terbalik n, nama, koma bertitik. Jadi apa yang saya lakukan? 

Jadi ternyata, untuk melaksanakan fungsi anda sendiri, kita jenis meminjam beberapa struktur yang sama dengan utama bahawa kita baru sahaja menjadi diambil mudah, dan saya tahu hanya menyalin dan menampal cukup banyak apa Saya telah menulis pada masa lalu. Tetapi perhatikan corak di sini. Int, Main, tidak sah, kami akan mengusik selain tidak lama apa yang benar-benar bermakna. 

Tetapi hari ini, hanya notis keselarian. Tidak sah, nama cetak, nama tali, jadi tidak kata kunci yang ungu, yang kita akan mula memanggil jenis pulangan, nama fungsi, dan kemudian input. Jadi, sebenarnya, kita boleh menyuling jenis ini seperti minggu lepas sebagai, ini adalah nama atau algoritma kod yang kami berada akan write-- yang algoritma asas kod yang kami akan menulis. 

Ini adalah input. Ini adalah output. Fungsi ini, nama cetak, adalah direka untuk mengambil rentetan dipanggil nama, atau apa sahaja, sebagai input, dan kemudian tidak sah. Ia tidak kembali apa-apa, seperti mendapatkan tali atau mendapatkan int tidak. Jadi ia akan menyerahkan aku sesuatu kembali. Ia hanya akan mempunyai kesan sampingan, jadi untuk bercakap, mencetak nama seseorang. Jadi notis, garis 7, saya boleh memanggil nama cetak. Line 10, saya boleh menentukan atau melaksanakan nama cetak. Tetapi, malangnya, itu tidak mencukupi. 

Biar saya pergi ke hadapan dan susun semula ini selepas menyimpan. Wah, sekarang, saya telah membuat ia lebih teruk lagi, ia akan kelihatan. pengisytiharan supaya tersirat nama fungsi cetak adalah tidak sah. Dan, sekali lagi, ada lagi kesilapan. Tetapi seperti yang saya mengingatkan sebelum ini, walaupun jika anda mendapat terharu dengan, atau sedikit sedih melihat begitu ramai kesilapan, memberi tumpuan hanya pada pertama pada mulanya, kerana ia mungkin hanya mempunyai kesan yang melata. Jadi C, atau dilafaz lebih khusus, masih tidak mengenali nama cetak. 

Dan itu kerana dilafaz, dengan reka bentuk, adalah jenis keadaan sihat. Ia hanya melakukan apa yang anda beritahu kepada lakukan. Dan ia hanya berbuat demikian dalam perintah itu di mana anda memberitahu ia lakukan. 

Jadi saya telah ditakrifkan utama pada baris empat, seperti yang kita telah lakukan dengan kerap. Saya telah ditakrifkan nama print on line 10. Tetapi saya cuba untuk menggunakan Nama cetak pada baris tujuh. 

Ia terlalu awal, tidak wujud lagi. Jadi saya boleh menjadi bijak, dan menjadi seperti, OK, jadi mari kita bermain bersama-sama, dan memindahkan nama cetak sehingga di sini, dan menyusun semula. Oh Tuhanku. Ianya berhasil. Ia adalah semudah itu. 

Tetapi logik adalah tepat. Anda perlu mengajar dilafaz apa yang ia adalah dengan menentukan fungsi pertama. Kemudian anda boleh menggunakannya. Tetapi, terus-terang, ini berasa seperti cerun licin. 

Jadi setiap kali saya menjalankan ke dalam masalah, saya hanya akan menyerlahkan dan tulis kod Saya menulis, potong dan tampal di sini. Dan, sudah tentu, kita boleh jayakan beberapa senario mana satu fungsi mungkin perlu memanggil lain. Dan anda tidak boleh meletakkan setiap fungsi di atas setiap lain. 

Jadi ternyata ada yang penyelesaian yang lebih baik. Kami boleh membiarkan bahagian ini menjadi. Dan, terus-terang, ia biasanya baik, dan mudah, dan reka bentuk yang baik untuk meletakkan utama pertama, kerana, sekali lagi, utama seperti apabila bendera hijau diklik, iaitu fungsi yang mendapat dilaksanakan secara lalai. Jadi, anda juga mungkin meletakkan ia di bahagian atas fail supaya apabila anda atau mana-mana manusia lain melihat fail anda tahu apa yang berlaku hanya dengan membaca pertama utama. Jadi ternyata, kita boleh memberitahu dilafaz proaktif, hey, dilafaz, pada baris empat, Saya berjanji untuk melaksanakan fungsi dipanggil Cetak Nama yang mengambil nama rentetan dipanggil sebagai input, dan pulangan apa-apa, tidak sah. Dan saya akan mendapatkan sekitar untuk melaksanakannya kemudian. 

Di sini datang Main. Main sekarang line 9 boleh menggunakan Cetak Nama kerana dilafaz adalah mempercayai bahawa, akhirnya, ia akan menghadapi definisi pelaksanaan Cetak Nama. Jadi selepas menyimpan fail saya, mari saya pergi ke hadapan dan membuat prototaip, kelihatan baik kali ini. Dot slash, prototaip, biarlah saya pergi ke depan dan menaip nama. David, hello David, Zamila, hello Zamila, dan, sememangnya, kini ia berfungsi. 

Jadi bahan di sini adalah bahawa kami telah membuat fungsi adat, seperti adat blok Scratch kami memanggil ia. Tetapi tidak seperti calar di mana anda boleh hanya membuat ia dan mula menggunakannya, sekarang kita perlu menjadi sedikit lebih bengah, dan sebenarnya melatih dilafaz untuk digunakan, atau untuk mengharapkan ia. Sekarang, sebagai diketepikan, mengapa selama ini mempunyai kita telah hanya membuta tuli pada iman termasuk CS50.h, dan termasuk standard io.h? 

Nah, ternyata, antara beberapa perkara lain, semua yang ada di dalam mereka yang dot h fail, yang berada fail. Mereka header fail, jadi untuk bercakap. Mereka masih ditulis dalam C. Tetapi mereka berlainan jenis fail. 

Buat masa ini, anda cukup banyak boleh menganggap bahawa semua yang ada di dalam CS50.h beberapa satu saham berharga seperti ini, tidak untuk fungsi dipanggil Cetak Nama, tetapi untuk Dapatkan String, Dapatkan Float, dan beberapa yang lain. Dan terdapat prototaip yang serupa, satu saham berharga, di dalam io.h standard untuk printf, yang kini berada di sendiri fungsi Cetak Nama saya. Jadi dalam erti kata lain, kali ini keseluruhannya kami telah sahaja secara membuta tuli menyalin dan menampal termasuk ini, termasuk itu, apa yang berlaku? Mereka adalah jenis hanya petunjuk untuk dilafaz apa fungsi adalah, sesungguhnya, dilaksanakan, hanya tempat lain dalam fail yang berbeza di bahagian lain pada sistem. 

Oleh itu, kita telah melaksanakan nama cetak. Ia mempunyai ini kesan sampingan mencetak sesuatu pada skrin. Tetapi ia tidak benar-benar tangan saya sesuatu kembali. Bagaimana kita pergi tentang melaksanakan program yang tidak menyerahkan aku sesuatu kembali? 

Nah, mari kita cuba ini. Biar saya pergi ke hadapan dan melaksanakan yang return.c fail dipanggil supaya kita dapat menunjukkan bagaimana sesuatu seperti Dapatkan String, atau Dapatkan Int, sebenarnya kembali sesuatu kembali kepada pengguna. Mari kita pergi ke hadapan dan menentukan sah utama int. 

Dan, sekali lagi, pada masa akan datang, kita akan menjelaskan apa yang int dan tidak sah yang sebenarnya lakukan. Tetapi hari ini, kita akan mengambil kesempatan. Saya akan pergi ke hadapan dan printf, untuk pengalaman pengguna yang baik, x ialah. Dan kemudian saya akan menunggu pengguna untuk memberi saya x dengan mendapatkan int. 

Dan kemudian saya akan pergi ke hadapan dan mencetak x ke dataran. Oleh itu, apabila anda hanya mempunyai keyboard, orang biasa menggunakan lobak merah kecil simbol pada papan kekunci untuk mewakili kepada kuasa , atau eksponen. Jadi x kuasa dua hadir i. 

Dan sekarang saya akan melakukan ini. Saya hanya boleh do-- apa yang x kuasa dua? x kuasa dua adalah x kali x. 

Dan kita lakukan ini beberapa masa lalu sudah hari ini. Ini tidak berasa seperti semua yang banyak kemajuan. Awak tahu tak? Mari kita memanfaatkan beberapa idea yang dari masa lalu abstraksi. 

Bukankah lebih baik jika ada fungsi yang dipanggil persegi yang tidak tepat itu? Ia masih, pada akhir hari, adakah matematik yang sama. Tetapi mari kita abstrak jauh idea pengambilan satu nombor didarabkan dengan yang lain, dan hanya memberikan nama, seperti mengambil ancang-nilai ini. 

Dan, dalam erti kata lain, C, mari buat majlis dipanggil persegi yang tidak tepat itu. Ia akan dipanggil persegi. Ia akan mengambil int. Dan kami akan akan hanya memanggilnya n, secara lalai. 

Tetapi kita boleh memanggilnya apa-apa yang kita mahu. Dan apa yang ia akan lakukan, secara literal, tempat kembali hasil kali n n. Tetapi kerana ia adalah kembali sesuatu, yang adalah kata kunci ungu kami telah tidak pernah dilihat sebelum ini, saya, pada baris 11, tidak boleh hanya mengatakan tidak sah masa ini. 

Tidak sah, dalam contoh kita hanya melihat dan bukan nama cetak, hanya bermaksud, lakukan sesuatu. Tetapi tidak menyerahkan aku sesuatu kembali. Dalam kes ini, saya mahu untuk kembali n kali n, atau apa sahaja iaitu, nombor itu. 

Jadi saya tidak boleh berkata, hey, komputer, Saya kembali apa-apa, tidak sah. Ia akan kembali, oleh alam semula jadi, int. Dan supaya semua perkara yang berlaku di sini. 

input untuk persegi akan menjadi int. Dan supaya kita boleh menggunakannya, ia perlu mempunyai nama, N. Ia akan output int yang tidak memerlukan nama. Kita boleh serahkan kepada utama, atau sesiapa yang menggunakan saya ingat nilai ini jika kita mahu dengan pembolehubah sendiri. 

Dan, sekali lagi, hanya baru kata kunci di sini adalah Return. Dan saya hanya melakukan beberapa matematik. Jika saya benar-benar mahu menjadi yang tidak perlu, Saya boleh mengatakan produk int mendapat n kali n. 

Dan kemudian saya boleh berkata, kembali produk. Tetapi, sekali lagi, ke titik saya awal design-- ini baik hanya yang bukan seperti, mengapa memperkenalkan nama, simbol, seperti produk, hanya untuk segera mengembalikannya? Ia lebih bersih sedikit, sedikit lebih ketat, jadi untuk bercakap, hanya untuk mengatakan kali pulangan n n, menghilangkan garis ini sama sekali. 

Dan ia hanya kurang kod untuk membaca, kurang peluang untuk kesilapan. Dan mari kita lihat jika ini sebenarnya kini berfungsi. Sekarang, saya akan pergi ke ke hadapan dan membuat kembali. 

Uh-oh, perisytiharan tersirat fungsi. Saya telah membuat kesilapan ini sebelum ini, tiada masalah besar. Biar saya menaip, atau menyerlahkan dan menyalin, tepat sama fungsi prototaip, atau tandatangan, fungsi di sini. Atau saya boleh bergerak keseluruhan fungsi. 

Tetapi itu sedikit malas. Oleh itu, kita tidak akan berbuat demikian. Sekarang, biarlah saya membuat kembali lagi, titik pulangan slash. 

x 2. x kuasa dua ialah 4. x 3. x kuasa dua ialah 9. Dan fungsi itu seolah-olah Masuk untuk bekerja. Jadi apa perbezaan di sini? Saya mempunyai fungsi yang dinamakan persegi, dalam kes ini, yang saya dimasukkan ke dalam input. Dan saya kembali output. Namun, sebelum ini, jika Saya membuka contoh yang lain dari awal, yang adalah dipanggil prototype.c, Saya mempunyai nama cetak, yang kembali tidak sah, jadi untuk bercakap, Atau ia kembali apa-apa, dan hanya mempunyai kesan sampingan. 

Jadi apa yang berlaku di sini? Well, pertimbangkan fungsi mendapatkan tali hanya untuk seketika. Kami telah menggunakan fungsi mendapatkan tali dengan cara yang berikut. 

Kami telah mempunyai fungsi yang mendapatkan string, seperti termasuk CS50.h, termasuk standard io.h, int, utama, tidak sah. Dan kemudian setiap kali saya telah dipanggil mendapatkan tali setakat ini, Saya telah berkata sesuatu seperti, rentetan s mendapat mendapatkan tali, kerana get string-- mari kita memanggil mendapatkan tali get.c-- ini sendiri mengembalikan rentetan yang saya boleh kemudian digunakan, dan berkata, hello, koma, peratus s, garis sendeng terbalik n, s. 

Jadi ini adalah contoh yang sama, benar-benar, bahawa kita sebelum ini. Jadi mendapatkan rentetan mengembalikan nilai. Tetapi masa yang lalu, rentetan cetak tidak mengembalikan nilai. Ia hanya mempunyai kesan sampingan. Jadi ini adalah perbezaan asas. Kami telah melihat yang berbeza jenis fungsi sekarang, ada yang telah kembali nilai, ada yang tidak. Jadi mungkin ia adalah tali, atau int, atau terapung. Atau mungkin ia hanya tidak sah. 

Dan perbezaan itu adalah bahawa fungsi-fungsi ini yang mendapatkan data dan mengembalikan nilai sebenarnya membawa sesuatu kembali ke meja, boleh dikatakan. Jadi mari kita pergi ke hadapan dan melihat satu set akhir contoh yang memberikan rasa yang, sekarang, bagaimana kita mungkin, sesungguhnya, abstrak yang lebih baik, dan lebih baik, dan lebih baik, atau lebih, dan banyak lagi, dan banyak lagi, untuk untuk menulis, akhirnya, kod yang lebih baik. Mari kita pergi ke hadapan, dan dalam semangat daripada Awal, lakukan yang berikut. 

Biar saya pergi ke hadapan dan termasuk CS50.h dan io.h. standard Biar saya pergi ke hadapan dan memberi diri saya int, utama, tidak sah. Dan biarlah saya pergi ke hadapan, memanggil cough.c ini. 

Dan biarlah saya pergi ke hadapan dan hanya seperti Awal, mencetak batuk / n. Dan saya mahu untuk melakukan ini tiga kali. Jadi saya, sudah tentu, hanya akan copy dan paste tiga kali. Saya kini akan membuat batuk slash batuk dot. Mari kita memberikan diri saya bilik yang lebih kecil di sini, Masukkan, batuk, batuk, batuk. 

Ada, jelas, sudah menjadi peluang untuk penambahbaikan. Saya telah disalin dan ditampal beberapa kali hari ini. Tetapi itu adalah hanya supaya saya tidak perlu menaip aksara banyak. Saya masih berubah apa orang-orang baris kod berada. 

Ketiga-tiga baris adalah sama, yang berasa malas dan sebenarnya adalah, dan mungkin tidak pendekatan yang betul. Jadi dengan apa bahan kita boleh meningkatkan kod ini? Kami tidak perlu copy dan paste kod. 

Dan, sememangnya, bila-bila masa anda rasa diri anda menyalin dan menampal, dan tidak menukar kod, Kemungkinan ada cara yang lebih baik. Dan sesungguhnya, ada. Biar saya pergi ke hadapan dan melakukan untuk gelung, walaupun sintaks yang tidak mungkin datang secara semula jadi lagi. 

Adakah ini tiga kali, semata-mata dengan melakukan following-- yang dan saya kebetulan tahu ini daripada amalan. Tetapi kita mempunyai beberapa contoh sekarang. Dan anda akan melihat dalam talian lebih rujukan masih. 

Ini adalah sintaks pada baris 6, yang sama seperti calar yang berulang blok, ulang berikut tiga kali. Ia ajaib sedikit buat masa sekarang. Tetapi ini akan mendapat lebih banyak, dan lebih biasa. 

Dan ia akan mengulangi garis lapan tiga kali, supaya jika saya semula menyusun-make batuk, dot mengurangkan batuk, batuk, batuk, batuk. Ia masih berfungsi dengan cara yang sama. Jadi itu semua baik dan baik. Tetapi itu bukan sangat cabutan. 

Ia sempurna betul. Tetapi ia merasakan seperti ada boleh menjadi peluang, seperti dalam dunia Awal, untuk jenis permulaan untuk menambah beberapa semantik di sini supaya Saya tidak hanya mempunyai beberapa untuk gelung, dan fungsi yang mengatakan batuk, atau adakah batuk. Awak tahu tak? Biar saya cuba untuk menjadi sejuk sedikit daripada itu, dan benar-benar menulis fungsi yang mempunyai beberapa kesan sampingan, memanggilnya batuk. 

Dan ia tidak mengambil input dan mengembalikan tiada nilai sebagai output. Tetapi anda tahu apa yang dilakukan? Ia printf this--, quote unquote, batuk. 

Dan kini di sini, saya akan pergi ke hadapan dan untuk int, i mendapat sifar, i kurang daripada 3, i plus plus. Saya akan tidak printf, yang boleh dikatakan pelaksanaan tahap rendah detail. Saya tidak peduli bagaimana untuk batuk. Saya hanya hendak menggunakan fungsi batuk. Dan saya hanya akan memanggil batuk. 

Sekarang, perhatikan dikotomi. Apabila anda memanggil fungsi, jika anda tidak mahu memberikan input, betul-betul halus. Hanya melakukan paren terbuka, berhampiran paren, dan anda selesai. 

Apabila anda menentukan fungsi, atau mengisytiharkan prototaip fungsi ini, jika anda tahu terlebih dahulu ia bukan akan mengambil apa-apa hujah, mengatakan tidak sah dalam orang-orang kurungan di sana. Dan yang membuat tertentu yang anda tidak akan sengaja menyalahgunakannya. Biar saya pergi ke hadapan dan membuat batuk. Dan, sudah tentu, saya telah membuat kesilapan. 

Keparat, ada yang pengakuan tersirat. Tetapi itulah denda. Ia merupakan satu menetapkan mudah. Saya hanya perlu prototaip lebih tinggi dalam fail saya daripada saya benar-benar menggunakannya. 

Jadi sekarang mari saya membuat batuk lagi, bagus. Kini, ia berfungsi. Membuat batuk, batuk, batuk, batuk. Jadi, anda mungkin berfikir bahawa kita benar-benar hanya lebih kejuruteraan masalah ini. Dan, sememangnya, kita berada. Ini bukan satu yang baik Calon program yang pada masa ini untuk refactoring, dan melakukan apa yang dipanggil penguraian hierarki, di mana anda mengambil beberapa kod, dan kemudian anda jenis faktor perkara keluar, supaya untuk mengada-adakan lebih semantik kepada mereka, dan menggunakannya semula jangka akhirnya lebih lama. Tetapi ia adalah satu blok bangunan ke arah program yang lebih canggih itu kita akan mula menulis sebelum panjang yang membolehkan kita untuk mempunyai perbendaharaan kata yang boleh digunakan untuk menulis kod yang lebih baik. Dan, sememangnya, mari kita lihat jika kita tidak boleh umum ini dengan lebih lanjut. 

Ia seolah-olah lumpuh kecil yang saya, utama, perlu bimbang tentang darn ini untuk gelung, dan memanggil batuk lagi dan lagi. Mengapa saya tidak boleh hanya memberitahu batuk, sila batuk tiga kali? Dalam erti kata lain, mengapa tidak saya memberi input untuk batuk dan melakukan ini? 

Mengapa saya tidak boleh hanya berkata, dalam batuk utama tiga kali. Dan sekarang, ini adalah jenis ajaib. Ia amat lelaran di sini. Dan ia adalah, sememangnya, satu langkah bayi. 

Tetapi hanya keupayaan untuk mengatakan pada garis lapan, batuk tiga kali, ia hanya begitu banyak lebih mudah dibaca. Dan, plus, saya tidak perlu tahu atau mengambil berat bagaimana batuk dilaksanakan. Dan, sememangnya, kemudian dalam jangka dan untuk projek akhir, jika anda menangani projek dengan seorang rakan sekelas atau dua rakan sekelas, anda akan menyedari bahawa anda akan perlu, atau mahu, bahagikan kerja. 

Dan anda akan mahu untuk membuat keputusan terlebih dahulu, siapa yang akan melakukan apa, dan di mana keping? Dan ia tidak akan menjadi baik jika anda, sebagai contoh, mengendalikan bertulis utama, dilakukan. Dan rakan sebilik anda, atau anda rakan kongsi lebih umum, menjaga melaksanakan batuk. 

Dan bahagian ini, ini dinding abstraksi, atau lapisan abstraksi jika anda akan, adalah super kuat, kerana terutamanya untuk lebih besar, lebih banyak program yang kompleks dan sistem, ia membolehkan beberapa orang untuk membina perkara bersama-sama, dan akhirnya menjahit kerja mereka bersama-sama dengan cara ini. Tetapi, sudah tentu, kita perlu kini menetapkan batuk. Kita perlu beritahu batuk itu, hey, anda tahu apa? Anda akan perlu untuk mengambil input-- jadi tidak sah, tetapi int dan kini. Mari kita pergi ke hadapan dan dimasukkan ke dalam batuk int. i mendapat sifar. 

i adalah kurang daripada berapa kali. Saya berkata tiga sebelum ini. Tetapi itu bukan apa yang saya mahu. Saya mahu batuk untuk digeneralisasikan kepada menyokong apa-apa bilangan lelaran. 

Jadi, sesungguhnya, ia n yang saya mahu, apa pengguna memberitahu saya. Sekarang, saya boleh pergi ke hadapan dan berkata cetak batuk. Dan tidak kira apa nombor pengguna lulus dalam, Saya akan melelar bahawa banyak kali. 

Jadi, pada akhir hari, program adalah sama. Tetapi melihat semua barangan ini juga boleh menjadi dalam fail lain. Sesungguhnya, saya tidak tahu di seketika bagaimana printf dilaksanakan. 

Saya tidak tahu pada masa ini bagaimana mendapatkan tali, atau mendapatkan int, atau mendapatkan apungan dilaksanakan. Dan saya tidak mahu melihat mereka pada skrin saya. Oleh kerana, saya mula memberi tumpuan kepada program saya, bukan mereka fungsi. 

Dan sebagainya, sesungguhnya, sebaik sahaja anda mula faktor kod seperti ini keluar, boleh kita bahkan bergerak batuk untuk fail yang berasingan? Orang lain boleh melaksanakannya. Dan anda dan program anda menjadi sangat cantik, dan sangat boleh dibaca, boleh dikatakan, benar-benar empat program garis di sana. 

Jadi mari kita pergi ke hadapan sekarang dan membuat satu lagi perubahan. Perhatikan bahawa prototaip saya perlu berubah sehingga atas. Jadi biarlah saya menetapkan bahawa begitu Saya tidak dapat menjerit. 

Membuat batuk, biarlah aku berlari batuk sekali lanjut, masih melakukan perkara yang sama. Tetapi sekarang, melihat kita mempunyai bahan untuk satu versi akhir. Awak tahu tak? Saya tidak mahu hanya batuk, semestinya. Saya ingin mempunyai sesuatu yang lebih umum. Jadi, anda tahu apa? Saya mahu untuk melakukan ini. Saya ingin mempunyai, sama seperti Scratch tidak, satu blok katakan, tetapi tidak hanya mengatakan sesuatu beberapa beberapa kali. Saya mahu untuk mengatakan rentetan yang sangat khusus. Dan, oleh itu, saya tidak mahu ia untuk hanya mengatakan batuk. Saya mahu untuk mengatakan apa sahaja rentetan diluluskan di. 

Jadi notis, saya telah umum ini supaya sekarang katakan berasa seperti nama yang baik untuk ini, seperti Awal, mengambil masa dua hujah, tidak seperti Scratch. Satu adalah rentetan. Satu adalah int. 

Dan saya boleh menukar mereka. Saya hanya jenis seperti idea berkata rentetan pertama, dan kemudian berapa kali kemudian. Void bermakna ia masih tidak kembali apa-apa. Ini hanya sebelah visual kesan, seperti dengan [? Jordan,?] kesan sampingan lisan menjerit. Ia masih tidak kali sesuatu n, 0 sehingga, tetapi tidak sama dengan n. Ini bermakna kali n total. Dan kemudian hanya mencetak apa sahaja rentetan yang. Jadi saya telah benar-benar umum baris kod. Jadi sekarang, bagaimana saya melaksanakan fungsi batuk? 

Saya mempunyai batuk tidak sah. Dan saya masih boleh menikmati bagaimana banyak kali yang anda mahu untuk batuk. Tetapi anda tahu apa? Saya kini boleh menyepak bola untuk mengatakan. 

Boleh saya hubungi berkata dengan perkataan batuk, lulus dalam n. Dan jika saya ingin juga melaksanakan, hanya untuk keseronokan, fungsi bersin, Saya boleh bersin beberapa beberapa kali. Dan saya boleh menyimpan menggunakan semula n, kerana melihat bahawa m dalam konteks ini atau skop hanya wujud dalam fungsi ini. 

Dan n dalam konteks ini sahaja wujud dalam fungsi ini di sini. Oleh itu, kita akan kembali kepada isu-isu ini skop. Dan di sini, saya hanya akan berkata, achoo, dan kemudian n kali, semi-kolon. 

Dan sekarang, saya hanya perlu meminjam fungsi ini tandatangan di sini. Jadi batuk adalah betul. bersin tidak sah adalah betul sekarang. 

Dan saya masih hanya perlu katakan. Jadi, saya akan katakan, katakan rentetan s, int n, semi-kolon. Jadi saya telah direkayasa over-the palang pintu keluar dari program ini. 

Dan ini tidak bermakna ini adalah apa yang perlu anda lakukan semasa menulis walaupun yang paling mudah program. Mengambil sesuatu yang jelas benar-benar mudah, benar-benar pendek, dan semula melaksanakan-it menggunakan terlalu banyak kod. Tetapi anda sebenarnya akan melihat, dan dalam masa melihat kembali pada contoh-contoh ini, menyedarinya, oh, mereka adalah langkah-langkah kami mengambil untuk benar-benar umum, untuk faktor sesuatu yang keluar, sehingga di akhir hari kod saya sebenarnya cukup munasabah. Kerana jika saya mahu batuk tiga kali kemudian bersin tiga kali, Saya hanya akan menjalankan semula ini, program membuat batuk, dan menjalankan batuk. Dan saya mempunyai tiga batuk dan tiga bersin. 

Dan hal ini adalah asas paradigma, jika anda akan, untuk bagaimana kita boleh pergi tentang sebenarnya melaksanakan program. Tetapi mari kita lihat sekarang apa yang ada kami telah melakukan semua masa ini, dan apa yang beberapa kepingan terakhir berada di belakang arahan ini mudah. Pada akhir hari, kami telah telah menggunakan dilafaz sebagai pengkompil kami. Kami telah menulis sumber kod, ditukarkan melalui dilafaz kepada kod mesin. 

Dan kita telah menggunakan Selesakan hanya untuk memudahkan ketukan kekunci kami supaya bahawa kita tidak perlu ingat mereka penjampian dilafaz sendiri. Tetapi apa yang Selesakan sebenarnya melakukan? Dan, seterusnya, apa yang Dilafaz sebenarnya melakukan? 

Ternyata, walaupun kita telah dipermudahkan perbincangan pada hari ini dengan berkata, anda mengambil kod sumber, lulus ia input kepada pengkompil, yang memberikan anda output mesin kod, ternyata ada yang beberapa langkah yang berbeza di dalam sana. Dan menyusun berlaku untuk menjadi payung istilah untuk sejumlah besar langkah-langkah. Tetapi mari kita hanya mengusik keluar ini benar-benar cepat. 

Ia ternyata bahawa kita telah melakukan lebih banyak perkara setiap kali saya menjalankan program, atau setiap kali saya menyusun program hari ini. Jadi pra pemprosesan merujuk kepada this-- apa-apa dalam program C, seperti yang kita akan melihat lagi dan sekali lagi, yang bermula dengan simbol hash ini, atau simbol hashtag di sini, bermakna ia adalah satu arahan prapemproses. Ini bermakna, dalam kes ini, hey komputer, melakukan sesuatu dengan fail ini sebelum anda sebenarnya menyusun kod saya sendiri. 

Dalam kes ini, hash termasuk iaitu, dasarnya, cara C untuk mengatakan, hey komputer, pergi mendapatkan kandungan daripada CS50.h dan paste di sini. Hey komputer, pergi mendapatkan kandungan standard io.h, di mana sahaja yang ada di atas cakera keras, paste di sini. Jadi perkara-perkara berlaku pertama semasa pra pemprosesan. 

Dan dilafaz melakukan semua ini untuk kita. Dan ia begitu darn cepat, anda tidak walaupun melihat empat perkara berbeza berlaku. Tetapi itu langkah sedemikian yang pertama. 

Apa yang sebenarnya berlaku seterusnya? Well, rasmi seterusnya langkah sedang mengumpul. Dan ternyata bahawa menyusun program teknikal bermakna pergi dari kod sumber, barangan yang kami telah telah menulis hari ini, untuk sesuatu dipanggil kod pemasangan, sesuatu yang kelihatan sedikit berbeza. 

Dan, sebenarnya, kita boleh melihat ini sebenar cepat. Biar saya benar-benar pergi ke IDE saya. Biar saya pergi ke hadapan dan hello.c terbuka, yang adalah program yang pertama yang kita bermula hari ini. Dan biarlah saya pergi ke hadapan dan menjalankan dilafaz yang sedikit berbeza, dilafaz-s, hello.c, yang sebenarnya akan memberi saya satu lagi hello.s fail. 

Dan kita akan mungkin tidak pernah lagi melihat ini jenis kod. Jika anda mengambil tahap yang lebih rendah kelas sistem seperti CS61, anda akan melihat lebih banyak ini jenis kod. Tetapi ini adalah bahasa himpunan. Ini adalah bahasa perhimpunan X86 bahawa CPU yang mendasari CS50 IDE sebenarnya memahami. 

Dan samar kerana ia tidak melihat, ia adalah sesuatu yang komputer memahami dengan baik. Sub q, ini adalah tolak a. Ada pergerakan. 

Terdapat yang memanggil fungsi sini, x Oring, pergerakan, add satu, pop, pulangan. Jadi ada beberapa yang sangat arahan peringkat rendah bahawa CPU faham bahawa Saya katakan sebelum ini. Itulah yang Intel Inside. 

Terdapat corak sifar dan orang-orang yang memetakan ini arcanely worded, tetapi agak yang dinamakan, arahan, boleh dikatakan. Itulah yang berlaku apabila anda menyusun kod anda. Anda mendapatkan pemasangan bahasa daripada itu, yang bermakna langkah ketiga adalah untuk memasang bahawa kod pemasangan ke dalam, akhirnya, mesin sifar code-- dan orang, bukan teks yang kita hanya melihat sebentar tadi. 

Jadi pra-pemprosesan adakah itu mencari dan menggantikan, dan beberapa perkara lain. Mengkompilasi mengambil sumber anda kod dari C, kod sumber bahawa kita menulis, suatu kumpulan kod yang kita hanya mengerling. Memasang mengambil perkumpulan kod untuk sifar dan orang-orang yang bahawa CPU benar-benar akan memahami pada akhir hari. Dan menghubungkan adalah langkah terakhir yang berlaku untuk us-- lagi, begitu pantas kita tidak walaupun notice-- yang mengatakan, hey komputer, mengambil semua sifar dan orang-orang yang hasil daripada menyusun kod Daud, dan fungsi utama beliau dalam kes ini. 

Dan hey komputer, pergi mendapatkan semua sifar dan satu bahawa kakitangan CS50 menulis dalam perpustakaan CS50. Campurkan mereka yang dengan Daud. Dan hey komputer, pergi mendapatkan semua sifar dan orang-orang yang orang lain menulis tahun lalu untuk printf. Dan menambah mereka ke dalam keseluruhan perkara, supaya kita ada mendapat sifar dan satu saya, sifar dan satu kakitangan CS50, sifar printf dan orang-orang yang, dan apa-apa lagi yang kami gunakan. 

Mereka semua mendapat digabungkan bersama-sama ke dalam satu program dipanggil, dalam kes ini, hello. Jadi selepas ini, kita akan hanya menggunakan Mengkompilasi perkataan. Dan kita akan mengambil mudah bahawa apabila kita katakan, menyusun program anda, ia bermakna, hey melakukan pra-pemprosesan, memasang, dan menghubungkan. Tetapi ada sebenarnya beberapa barangan berair berlaku di sana di bawah hood. Dan terutamanya jika anda mendapatkan ingin tahu beberapa waktu, anda boleh mula poking sekitar di peringkat yang lebih rendah ini. Tetapi buat masa ini, menyedari bahawa antara bawa pulang untuk hari ini agak semata-mata bermula daripada proses, untuk mendapatkan selesa dengan sesuatu seperti dunia hello. Malah, sebahagian besar daripada apa yang kita lakukan hari ini pasti tidak akan tenggelam dalam super cepat. Dan ia akan mengambil sedikit masa, dan beberapa amalan. Dan kemungkinan besar, anda akan menyusun daripada mahu memukul keyboard anda atau menjerit pada skrin. Dan semua itu OK. Walaupun, mungkin cuba untuk tidak melakukannya dalam perpustakaan begitu banyak. 

Dan akhirnya, anda akan akan dapat walaupun, untuk memulakan melihat corak, kedua-dua kod baik yang telah anda tulis dan kesilapan yang anda telah dibuat. Dan seperti proses menjadi TF atau yang CA adalah seperti, anda akan mula menjadi lebih baik dan lebih baik melihat mereka corak, dan hanya menyelesaikan anda masalah sendiri akhirnya. Dalam pada itu, akan ada banyak kita untuk memberi sokongan anda, dan mendapatkan anda melalui ini. Dan dalam penulisan untuk semua masalah akan anda dibimbing melalui semua arahan bahawa saya pasti tahu dari banyak amalan sekarang, tetapi mungkin terbang atas kepala seseorang untuk sekarang. Dan itu betul-betul halus. 

Tetapi, akhirnya, anda akan untuk mula melihat corak muncul. Dan sebaik sahaja anda melepasi semua butiran bodoh, seperti kurungan, dan pendakap kerinting, dan koma bertindih, dan barang-barang itu, terus-terang, yang tidak sama sekali intelektual yang menarik. Dan ia bukan objektif mengambil apa-apa kelas pengenalan. Ia adalah idea yang akan perkara itu. 

Ia adalah gelung, dan syarat, dan fungsi, dan lebih kuat pengekstrakan, dan pemfaktoran kod, dan reka bentuk yang baik, dan yang baik gaya, dan akhirnya betulnya kod anda, itu akhirnya akan perkara yang paling. Jadi minggu depan, kami akan mengambil ini idea-idea yang pertama yang kita lihat dalam Scratch dan kini telah diterjemahkan C. Dan kita akan mula untuk memperkenalkan pertama domain dunia sebenar kursus ini. 

Kami akan memberi tumpuan kepada dunia keselamatan, dan lebih khusus kriptografi, seni berebut maklumat. Dan antara yang pertama masalah anda sendiri akan mendapat untuk menulis di luar bermain dengan beberapa sintaks dan menyelesaikan beberapa logik masalah, akhirnya tidak lama, adalah untuk benar-benar berebut, atau menyulitkan, dan akhirnya menyahsulit maklumat. Dan segala-galanya yang kita lakukan hari ini, akan agak rendah peringkat, hanya akan membolehkan kita mengambil satu, dan satu, dan satu lagi langkah ke arah atas menulis kod yang paling menarik lagi. 

Jadi lebih pada minggu depan. 

[VIDEO MAIN SEMULA] 

-Apa Anda boleh beritahu saya tentang kali terakhir anda melihat dia? -Apa Yang boleh saya katakan, benar-benar? Maksud saya, ia adalah seperti yang lain latihan pra-pengeluaran, kecuali ada sesuatu yang dia berkata bagi mereka yang terkemudian yang terperangkap dengan saya. 

-Ini Adalah CS50. 

-Itu Adalah semua orang dipotong, pekerjaan yang besar pada latihan. 

makan tengah hari -Itu ini? 

-Yeah, Anda dan saya boleh merebut sandwic dalam sedikit. Biar saya memberi kata akhir dengan David benar-benar cepat. David? David? 

[AKHIR MAIN SEMULA] 