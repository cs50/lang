[GLASBA] DAVID J. Malan: V redu, to je CS50. In to je en teden. Tako opozarjajo, da je zadnji čas v nič tednu smo se osredotočili na računsko razmišljanje. In smo prešli iz tega, da Scratch, grafično programiranje jezik od naših prijateljev v Media Lab MIT. 

In z nič, pa smo raziskati ideje, kot so funkcije, in pogoje, in zank, in spremenljivke, in celo dogodki, in niti, in še več. In danes, si bomo še naprej uporabljajo te ideje, in res jih vzeli za odobrena, vendar jih prevesti v drug jezik, znan kot C. Now, C je bolj tradicionalna jezik. To je nižja stopnja jezik, če hočete. 

To je zgolj tekstovno. In tako na prvi pogled, da je vse bo videti precej skrivnosten če ste nikoli programirano prej. Bomo imeli podpičji in oklepaji, in zaviti oklepaji, in še več. Toda zavedati, da je tudi čeprav sintaksa je o tem, da si malo poznajo za večino od vas, glejte mimo tega. In skušamo videti ideje da so, res, pozna, ker tukaj v tednu od kar bomo začeli storiti je, za primerjavo, najprej, Scratch primerjavi C. 

Tako, na primer, se spomni, da ko smo izveden prvi od naših programov Zadnjič, ko smo imeli blok, ki je preučevala malo nekaj podobnega this-- kadar kliknili zelene zastave, nato pa smo imeli enega ali več kosov sestavljanke pod njo, V tem primeru, pravijo, zdravo svet. Torej, seveda, v nič, ko kliknem, da zeleno zastavo teči svoj program, tako govoriti, to so bloki, ki se izvršijo, ali teči. In, še posebej, Scratch je dejal, zdravo, svet. 

Zdaj, lahko bi bili določeni z drugimi besedami tukaj. Ampak bomo videli, da je res, veliko teh blocks-- in vsekakor, v C lahko veliko functions-- biti parametriziramo ali po meri narediti različne stvari. V resnici, v C, če mi želite spremeniti, zdaj, To Scratch programa na ta drugi jezik, bomo napisati malo kaj takega. 

Zagotovo obstaja nekaj ne poznajo sintaksa je najbolj verjetno, int, in oklepaji in neveljavne. Toda printf-- čeprav bi jih mislim, da bi bilo samo za tiskanje. Toda print pomeni tiskanje oblikovano, saj bomo kmalu videli. To bo dobesedno tiskanje na zaslonu karkoli je znotraj teh oklepajev, kar Seveda je v tem primeru, zdravo svet. 

Vendar boste opazili kakšno drugo sintaksa, nekatere dvojne kotacije, da oklepaju na koncu semi-debelega črevesa in podobno. Tako da je malo nad glavo, tako rekoč, tako kognitivno in skladenjsko, da bomo morali zapomniti kmalu. Toda zavedati, da s prakso, To se bo začelo, da skoči ven na vas. 

V resnici pa se osredotočajo na to ena Funkcija specifically-- v tem primeru, Pozdravi svet. Tako pravijo, je funkcija. Zdravo svet je njen parameter, ali argument, njena prilagoditev. 

In enakovrednost v C je prav bo to eno vrstico tukaj, kjer je printf enaka, recimo, dvojno kotirajo niz, zdravo svet je enaka, seveda, s tem, kar je v belem polju tam. In poševnica nazaj n, čeprav nekoliko čudno in odsotno iz nič, preprosto se dogaja, da imajo za posledico, da bomo videli v računalniku, kot je moj Mac ali PC, za samo premikanje kazalko v naslednjo vrstico. To je kot hitting Enter na tipkovnici. 

Torej bomo spet videli, da kmalu. Ampak najprej, pa si poglej tole Drugi primer v primeru zank. Imeli smo te za vedno zanko zadnji čas, ki je bila serija koščke da je storil nekaj, kar dobesedno forever-- v tem primeru, pravijo, zdravo svet, zdravo svet, Zdravo svet, zdravo svet. Torej, to je neskončna zanka z zasnovo. 

V C, če želimo, da izvajanje tega Isto idejo, bomo morda le to. Medtem ko je res, world-- printf zdravo zdaj medtem ko je le pomensko, vrsta pričara idejo o tem spet nekaj, in še enkrat in še enkrat, in za koliko časa? No, true-- odpoklic, ki Res je samo ali ena. 

In res je, seveda, vedno res. Torej, to je nekako nesmiselno Izjava samo reči res. Vendar je res, da je to namerno, ker če res je le vedno drži, kot sicer res samo pomeni, če malo posredno da naslednjih vrstic kode med temi zavitimi oklepaji bi samo izvršiti še enkrat in še enkrat, in še enkrat in nikoli ustaviti. 

Toda, če želite, da zanka ustavi, kot smo si zadnjič z nekaj podobnega To ponovite naslednje 50-krat, v C lahko storijo enako s tem, kar je imenuje za loop-- ključno besedo niso hkrati, vendar. In potem imamo nekaj novih sintakso, z int i enak 0, i manj kot 50, i ++. In bomo prišli nazaj na to. Ampak to je samo, kako bi prevesti niz Scratch blokov za sklop C vrstic kode. 

Medtem, menijo spremenljivke. In, v resnici, smo pravkar videl enega pred nekaj trenutki. In v primeru Scratch, če bomo želel razglasi spremenljivko i na i pa celo, samo številka, in želimo, da ga je do neke vrednosti, želimo uporabiti to oranžno blok here-- i nastavljen na 0. 

In bomo videli danes, naprej, tako kot prejšnji teden, programerji storiti skoraj vedno začnemo iz nič, res po dogovoru. Pa tudi zato, ker odpokliče Naša razprava o binarni, najmanjše število, ki ga lahko predstavljata s poljubnim številom bitov je le, da bo treba 0. sama. In tako bomo običajno začnejo inicializacijo tudi naše spremenljivke na 0. 

In v C, da storijo enako, bomo rekli int za celo število, i samo po dogovoru. Lahko bi poklical ta spremenljivka kaj hočem, tako kot v Scratch. In potem je enak 0 samo dodeli vrednost 0 desne in ga postavi v spremenljivko, ali Posoda za shranjevanje je na levi strani. In podpičjem kot bomo see-- in smo videli nekaj teh already-- pomeni le konec misli. Nadaljujemo za nekaj drugega na progah, ki sledijo. 

Zdaj, kaj logičnih izrazov? Spomnimo se, da v nič, to so izrazi ki so bodisi true ali false-- vprašanja Res, da so bodisi resnična ali neresnična. Torej, v primeru Scratch, bomo morda zastaviti preprosto vprašanje, kot je ta, je i manj kot 50? Tako i, spet je celo število. Mogoče smo jo uporabljajo v programu Scratch slediti rezultatom ali nekaj takega. Torej, to sintakso tukaj v Scratch samo pomeni, je i manj kot 50? No, na srečo, kar je preprosto v C. In za prevajanje, to bi preprosto rekel, da sem manj od 50, s pomočjo znane tipke na tipkovnici. 

Medtem, če si hotel reči nekaj bolj splošno, kot dobro, je x manjši kot y, kjer je vsak x in y sta sami spremenljivke? To lahko storimo isto stvar V C, dokler smo jih ustvaril te spremenljivke že. In bomo videli, kako storiti, da kmalu. Mi bi preprosto rekli x manj kot y. 

Torej ste se začne z vidim nekaj podobnosti. In tisti ljudje, ki so postavili Scratch je zagotovo navdihnila nekatere od teh osnovnih idej. In boste videli te vrste sintaksa v mnogih languages-- ne samo Scratch, ne Samo C, vendar Python in JavaScript ter drugi jeziki še. 

Oglejmo si še en konstrukt iz C, pojem pogoj, delaš nekaj pogojno. Če je nekaj res, to storite. Če je nekaj drugega res, to. To je neke vrste programiranja ekvivalent odcepu. Mogoče je dvosmeren vilice tripotni vilice ali več. In v Scratch, lahko imamo videl nekaj takega. 

Torej, ta je velik. Vendar menijo, da je relativno preprostost logike. Če je x manjši kot y, potem pravijo x manj kot y, drugega, če je x večji od y, Nato pravijo x večji od y. In potem, logično, če misliš, da nazaj v Scratch ali pa samo svoj človeška intuicija, tudi, če je x ni večji od y, x ni manjša od y, potem seveda x bo enaka y. Torej, v tem primeru, ki ga gnezdenje te praske bloki, lahko dosežemo tri Tako vilice na cesti? 

Medtem, če želimo to, da v C, je nedvomno izgleda malo simpler-- vsaj ko boste dobili seznanjeni s sintakso. Če je x manjši kot y printf x manjša od y. Drugega, če je x večji od y, printf x večji od y. Drugega printf x je enak y-- in še enkrat, s tistimi, poševnica nazaj konča tik za tiste nove linije, tako da, če ste dejansko tekel te vrste programa da bi samo premaknete kazalec na koncu na naslednji vrstici zaslona. 

Zdaj, medtem Scratch imel drugo bolj prefinjene funkcije, le od katerih so nekatere bomo najprej preiti na svetu C. In eden izmed njih je bil imenuje seznam v Scratch. In to je bil poseben tip spremenljivke, ki dovoljeno, da shranite več stvari v nazaj, nazaj, nazaj, nazaj. 

V C nima Seznami po sebi, ampak nekaj da so bolj splošno imenuje nizi, čeprav bomo prišel nazaj kasneje ta semester da gledamo na nekaj imenuje seznam, ali res povezan seznam. Ampak za zdaj, v katerem je protivrednost v C za nas se bo nekaj imenujemo matrika. In množica je preprosto posebna vrsta spremenljivke ki vam omogoča shranjevanje podatkov nazaj, nazaj, nazaj, na hrbet. 

In res, v nič, če smo želeli dostop Prvi element matrike ali list-- in bom ga poklical, Po dogovoru argv, argument vektor, ampak več o tem kmalu. Če želim, da bi dobili na prvem elementu argv, v svetu Scratch vi dejansko ne običajno začetek štetja od 1. 

In tako sem lahko dobil 1. točke argv. To je samo, kako MIT izvajati pojem seznamov. Toda v C, vam bom bolj enostavno samo reči, argv, kar je spet ime moje list-- ali mora biti jasno, array. In če želim prva elementi, bom za uporabo oglatih oklepajev, ki vas morda ne pogosto uporablja pod tipkovnico. 

Toda 0 pomeni le, daj mi prvi. Tako občasno in kot čas teče, bomo za začetek, da se te dihotomijo med nič in C, pri čemer Scratch uporablja. Mi v C uporabite 0 tukaj. Pa boste hitro videli, ko boste razumeli temelj vsakega jezika, da te stvari začnejo, da bi dobili toliko bolj seznanjeni s prakso in prakso. 

Torej, kaj je dejansko videti sedaj na programu. Tu je prva izmed naših C izvorna koda za popolne programe. In program bomo ponuditi za plačilo je tista, ki je enakovreden omenjenem Scratch kosu. 

Torej, tukaj imamo kaj verjetno najenostavnejši C program lahko pišete, da dejansko naredi nekaj. Zdaj bomo pogledali preteklost, za zdaj, je vključiti, standardna io.h, in to kot nosilci in int in neveljavno, in zaviti oklepaji in podobno. 

In kaj je samo osredotočiti na kaj, vsaj intuitivno, lahko skoči ven na vas že. Dejstvo je, glavno, da ne nujno, da vedo, kaj je to, vendar podobno kot Scratch je bilo, da je pri zelena zastava kliknili kos sestavljanke, tako da ne C kot programskega jezika imajo glavni del kode, ki dobi izvaja privzeto. In, seveda, to je dobesedno dogaja, da se imenuje glavni. 

Tako da glavna funkcija. In to je posebna funkcija, ki obstaja v C, da ko zaženete program, je glavno, da dobi, ki jih vodijo privzeto. V svetu Scratch, to je ponavadi, ko zelena zastava kliknil, ki sem jih vodijo privzeto. 

Medtem, to smo že videli, printf ali tiskanje oblikovano, da je bo funkcija, ki prihaja z C, skupaj z cel kup drugih, da bo od časa in časa Ponovno, da narediti točno kot pove že ime, natisniti nekaj. Kaj želimo natisniti? No, bomo videli, da ki ga obdaja znakov kot these-- Hello World, poševnica nazaj n v dvojnih narekovajih, lahko rečemo printf točno Kaj natisniti na zaslonu. 

Ampak da narediti da, žal morali vzeti nekaj, kar je že Grobni za nas ljudi, ampak vsaj to je nekoliko readable-- oster vključujejo standardno io.h, int, Glavno, nična, printf, vse čarobno zaklinjanjem smo pravkar videli na zaslonu. Vendar smo dejansko morali iti še bolj skrivnostne. Najprej smo morali prevesti kodo da smo napisali v strojno kodo. In odpoklic iz prejšnjega tedna, da stroji, vsaj tisti vemo tod Na koncu dneva le razumeti ničle in narave. 

In moj Bog, če bi moral napisati to ničle in tisti dejansko programa, da bi se zelo, zelo hitro vzemite zabavo iz nič. Ampak se je izkazalo, na zadnji teden, da so ti vzorci ničel in enic samo še poseben pomen. V določenih kontekstih, morda pomenijo številke. 

V nekaterih kontekstih, bi lahko pomenilo pisma, ali barve ali poljubno število drugih odvzemov tam na. Toda tako kot je v računalniku CPU, centralna procesna enota, ali možgani v notranjosti računalnika. To je običajno Intel notri, ker je to eden od največjih podjetij ki omogoča procesorjev za računalnike. 

No, Intel procesorjev in drugi Preprosto so se odločili vnaprej da so nekateri vzorci ničle in tisti pomenijo določene stvari. Nekateri vzorci ničel in enic bo pomenilo, natisnete na zaslon, ali dodajanje teh dveh številk ali odštejemo teh dveh številk, ali premakniti ta podatek iz spomin mojega računalnika tukaj, ali poljubno število drugih zelo nizki ravni, toda na koncu je koristno, operacije. Ampak, na srečo, mi, ljudje ne bodo da je treba vedeti to raven podrobnosti. Dejansko, tako kot zadnjič, kjer smo odvzete še enkrat in še enkrat in še enkrat, stavba iz zelo nizki ravni primitivnih kot ničel in enic višjih konceptov ravni kot številk in črk, in barve, in še več, tako da lahko mi kot programerje stojijo na ramenih drugi, ki so prišli pred nami in uporabo programske opreme, da je druga ljudje so napisali pred us-- in sicer programi imenuje prevajalniki. 

C je jezik, ki se običajno zbirajo, kar pomeni, da pretvori iz Izvorna koda za strojno kodo. Še posebej, kaj to pomeni je, da če imaš svoj vir Koda, ki ste sami napisali, kot smo prej bo čez nekaj trenutkov na zaslonu, in ga želite spremeniti končno stroj code-- tiste ničle in tiste, ki samo vaš Mac ali osebni računalnik understands-- imaš prvi krme, da izvorne kode v kot vhod za poseben Program se imenuje prevajalnik, izhod, ki smo Videli je strojni kodi. In res, zadnjič, ko smo se pogovarjali o, res, na koncu dneva, reševanje problema. Imaš vložke. In imaš izhode. In imaš neko algoritma v sredini. 

Algoritmi lahko zagotovo izvajajo v programski opremi, kot smo videli pri psevdokoda zadnjem tednu in kot bomo videli v dejansko kodo ta teden. In tako prevajalnik res samo ima nabor algoritmov znotraj za to, da vedo, kako pretvorbo posebne besede, kot glavno in printf, in drugi, ki smo pravkar videli v vzorcih ničel in Tisti, ki Intel znotraj in drugih procesorjev dejansko razume. Torej, kako bomo to naredili? Kje bomo dobili prevajalnik? 

Večina nas ima tu Mac ali PC. In ti teče Mac OS, ali Windows ali Linux ali Solaris, ali poljubno število drugih operacijski sistemi. In, seveda, smo lahko iti ven na spletu in prenos prevajalnik za vaš Mac ali osebni računalnik za svoj operacijski sistem. Vendar pa bi bili vsi na različnih strani, tako rekoč. Imeli bi nekoliko različne konfiguracije. In stvari ne delujejo vsi enaki. In res, v teh dneh mnogi od nas ne uporabljajo programska oprema, ki deluje le na naših prenosnih računalnikov. Namesto tega bomo uporabili nekaj kot brskalnik, ki nam omogoča dostop do web-based aplikacije v oblaku. In kasneje ta semester, bomo naredili točno to. Bomo napisali aplikacij ali Programska oprema code-- uporabo ne C, ampak druge jezike, kot so Python in JavaScript--, ki delujejo v oblaku. 

In za to smo sami med semestrom bo dejansko uporabite oblaku- okolju znan kot CS50 IDE. To je spletno programiranje okolje, ali celostni razvoj okolje, IDE, ki je zgrajen na vrhu nekaterih odprtokodna programska oprema se imenuje Cloud 9. In smo naredili nekaj pedagoško poenostavitve njo tako skriti določene funkcije v v prvih tednih, ki jih ne potrebujejo, po katerem lahko razkrivajo jih in ne najbolj kaj želite z okoljem. 

In to nam omogoča tudi, da vnaprej namestiti določeno programsko opremo. Stvari, kot so tako imenovani CS50 Knjižnica, ki ga bomo kmalu videli nam zagotavlja v C z nekaterimi dodatne funkcionalnosti. Torej, če greš v končno CS50.io, boste pozvani, da se prijavite, in ko boste to storili, in ustvariti račun za brezplačno, boste lahko za dostop do okolje, ki izgleda precej takole. 

Zdaj, to je v privzeti način. Vse je lepo in svetlo na zaslonu. Mnogi od nas imajo navado delajo na CS50 kos, ki je precej pozno v noč. In tako nekateri od vas morda raje da se spremeni v nočni način, tako rekoč. 

Ampak, navsezadnje, kaj ste videli v CS50 IDE je tri ločene areas-- območje na levi Kam vaše datoteke se bodo v oblak, območje v zgornjem desnem kjer kodo bo mogoče urejati. Boste mogli odpreti Posamezne kartice za kateri koli program da ste napisali ta semester znotraj te zgornjem desnem kotu. In potem najbolj arcanely, in še močno, se bo ta stvar Na Dno znan kot terminala okno. 

To je stara šola Line Interface ukaz, ali CLI, ki omogoča da se izvajanje ukazov o computer-- v tem primeru, računalnik v cloud-- za stvari kot sestaviti kodo iz izvorne kode za strojno kodo, teči svoje programe, ali pa, da začnete spletni strežnik, ali za dostop do baze podatkov, in poljubno število drugih tehnik da bomo začeli uporabljati kmalu. Ampak do tja, smo dogaja, da dejansko imajo da gredo na spletu in začnite igrati. In za to, kaj je prva začeti krpanje z glavno, in pisati glavni del programa. In kaj je uporabljati to funkcijo printf, ki smo jo uporabili prej, samo nekaj reči. 

Torej, tukaj sem že znotraj CS50 IDE. Sem prijavljeni vnaprej. In sem full pregledani okno. In tako na koncu, si Tudi v prihodnjih težav bodo sledile podobne korake, ki bo zagotovila spletne dokumentacije. Torej vam ni treba skrbeti za absorbira vsako malo tehnično korak da jaz danes tukaj. 

Pa boste dobili zaslon, kot je ta. Slučajno sem v nočni način. In lahko polepšajo vse up onemogočite nočni način. In na koncu izmed dan, boste videli ti trije glavni areas-- datoteke brskalnika na levi strani, oznake, zavihki do vrha, in terminal okno na dnu. 

Naj gredo naprej in pisati svoj prvi program. Bom preemptively pojdite na File, Shranite in shranim sliko kot hello.c. Dejansko, po dogovoru, vsak program smo pisanjem, ki je napisana v jeziku C morajo biti poimenovane nekaj dot c, po dogovoru. Torej bom to ime hello.c, ker Rad bi samo pozdravi svetu. Zdaj bom za povečavo ven in kliknite Shrani. In vse, kar sem zdaj tukaj je zanka v katerem lahko začnem pisati kodo. 

To ne bo zbrati. To ne pomeni nič. In tudi če sem pretvori to ničel in enic, CPU se dogaja, da imajo ne vem, kaj se dogaja okoli. Ampak, če pišem vrstice, ki se ujemajo z conventions-- počutje C C je, še enkrat, to language-- s sintakso, kot so to, printf zdravo world-- in sem gotten všeč tem časom. Torej, jaz ne mislim, da je morebitne tiskovne napake. 

Ampak, vedno je prva Ko boste to storili, boste. In kar sem na tem, da narediti zelo morda tudi ne dela za vas prvič. In to je popolnoma v redu, ker zdaj vas morda le videli cel kup novosti, čez čas, ko se navadim s tem okolju, in ta jezik, in drugi, boste začeli videti stvari, ki so bodisi pravilni ali nepravilni. 

In to je tisto, kar je poučevanje fantje in seveda pomočniki dobili tako dobri v daljšem časovnem obdobju, ki je madeži napake ali napake v kodi. Ampak trdim, da obstaja ni napake v tej kodi. Zato sem zdaj želite zagnati ta program. 

Zdaj pa na svojem Mac ali PC, da sem v navado ikon dvojnim klikom ko hočem zagnati nek program. Ampak to še ni model tukaj. V tem okolju, ki je CS50 IDE. Mi smo z uporabo delovati sistem, imenovan Linux. Linux spominja drugo operacijskega sistema, na splošno znani kot Unix. In je Linux še posebej znana imajo Command Line okolje, CLI. Zdaj smo z uporabo specifičnega okus Linuxa imenovano Ubuntu. In Ubuntu je preprosto nekatere različice Linux. 

Toda ti Linux je v teh dneh, dejansko prihajajo z grafičnimi vmesniki. In ena se zgodi, da uporabljali tukaj je spletna. Torej, to lahko videti celo malo drugačna od nečesa sami morda videli ali vodijo v preteklosti. 

Tako da sem šel naprej zdaj in naredite naslednje. Sem shranil to datoteko kot hello.c. Bom, da gredo naprej in Tip clanghello.c Torej Jek za jezik C je prevajalnik. To je vnaprej nameščen v CS50 IDE. In lahko popolnoma prenesete in namestiti to na svoj Mac ali PC. 

Ampak, še enkrat, ti ne bi imeli vsi pre-konfiguracijo naredil za vas. Za zdaj sem samo tekoč teči clanghello.c. In zdaj opazil to sintakso Tukaj bo sčasoma zavedati, pomeni le, da sem v mapo ali imenik imenuje Workspace. Ta znak za dolar je le konvencija smisla, vnesite vaše ukaze tukaj. 

To je tisto, kar se imenuje hitro, samo po dogovoru je znak za dolar. In če grem naprej zdaj in kliknite Vnesite, nič ne kaže, da se je zgodilo. Ampak to je pravzaprav dobra stvar. Manj se to zgodi na zaslon, bolj verjetno koda je pravilna, vsaj skladenjsko. 

Torej, če želim teči to Program, kaj naj storim? No, se izkaže, da je Privzeto ime po dogovoru za programe, če ne določite ime za vaš program je samo a.out. In ta sintaksa preveč, boste spoznati kmalu. 

Dot poševnica samo pomeni, hej, CS50 IDE, zaženite program, imenovan a.out da je v moji trenutni imenik. Ta pika pomeni trenutni imenik. In bomo videli, kaj drugih takih zaporedij znakov pomeni kmalu. 

Torej, gremo, Enter, zdravo svet. In boste opazili, da to, kar se je zgodilo? Ne le, da je tiskanje Hello World. Prav tako preselil It kazalko v naslednjo vrstico. 

In zakaj je bilo to? Kaj je koda, ki smo pisali pred da je zagotovljeno, da je kazalec bi gredo na naslednjo vrstico? Hecno približno računalnik pa je samo še storiti dobesedno tisto, kar je povedal, da storiti. 

Torej, če je povedal, da printf zdravo, vejica, prostor, svet, blizu citat, to je dobesedno samo še tiskanje teh znakov. Ampak sem imel poseben znak na koncu, odpoklic, poševnica nazaj n. In to je tisto, kar zagotovi da znak šla na naslednji vrstici zaslona. 

Dejstvo je, da mi gre in to. Naj gredo naprej in izbrisati. Zdaj, opazili, da vrh mojega zaslona obstaja malo rdeča luč v zavihek kaže, hej, ste ne shranijo datoteke. Tako da sem šel naprej z nadzorom S ali ukaz S, shranite datoteko. Zdaj goes-- je šlo za moment-- zeleno. In zdaj je nazaj le da blizu ikona. 

Če bi zdaj spet teči clanghello.c, Enter, pika slash, a.out, Enter, boste videli, da je še vedno delal. Ampak to je verjetno malo buggy. Zdaj, moj prompt-- delovni prostor, in potem to znak za dolar, in potem moj dejanski prompt-- je vse na isti liniji. Torej, to zagotovo estetsko napako, čeprav to ni ravno logično napako. 

Torej bom razveljaviti, kar sem storil. Bom ponovila a.out. Obvestilo sem doda Znak za novo vrstico nazaj. Sem shranili datoteko. 

Torej bom a.out ponovi, in-- prekleto, napako, napako pomeni napako. Torej napaka je, da čeprav dodal sem poševnico n tam, ponovno shraniti, ponovno tekel program, obnašanje je bilo enako. Zakaj bi to bilo? 

Mi manjka korak, kajne? To je ključni korak prej, je bila, da imate to-- ko spremenite izvorno kodo, Izkazalo se tudi prost je skozi prevajalnik še enkrat, tako da boste dobili novo strojno kodo. In strojni kodi, ničle in tisti, se bo skoraj identična, vendar ni povsem tako, saj se moramo, Seveda, da je nova proga. 

Torej, da popraviti to, bom potreboval za ponovno clanghello.c, vstop, pika poševnica a.out. In zdaj, zdravo svet se je vrnil , kjer sem pričakoval, da bo. Torej, to je vse lepo in prav. Toda a.out je precej neumno ime za Program, čeprav se zgodi, da bo, zaradi zgodovinskih razlogov default-- pomeni sestavljanje izhode. 

Ampak naj gredo naprej tukaj in to naredili drugače. Hočem Pozdravljen, svet dejansko se imenuje zdravo. Torej, če bi bila ikona na mojem namizje, ne bi bilo a.out. To bi lahko imenovali zdravo. 

Tako, da to stori, se izkaže da Jek, kot mnogi programi, podpira argumente ukazne vrstice, ali zastave ali stikala, ki preprosto vpliva na njegovo obnašanje. Natančneje, Jek podpira dash O zastave, ki nato prevzame drugo besedo. V tem primeru bom samovoljno, vendar je smiselno, da pokličete zdravo. Vendar sem lahko rečejo karkoli Hočem, razen a.out, ki bi raje poleg točke. 

In potem samo navesti ime datoteke mi želijo zbrati. Zdaj, čeprav na začetku ukaza Še vedno imajo Jek, Na koncu ukaza Še vedno imam ime datoteke, Zdaj so te ukazno vrstico argumenti, te oznake, ki pravijo, oh, mimogrede, izhod-o, datoteka imenovano zdravo, ni privzeta a.out. 

Torej, če sem udaril Enter zdaj, nič Zdi se, da se je zgodilo. In še zdaj ne morem storiti dot poševnica zdravo. Torej, to je isti program. Ničle in med njimi so identična ob koncu dneva. 

Ampak oni so v dveh drugačna files-- a.out, kar je prva različica in samo neumno imenom, in zdaj zdravo, ki je veliko bolj prepričljiv ime za program. Ampak, iskreno, sem nikoli bo to še enkrat spomnim, in spet in spet. In, pravzaprav, kot smo napisali bolj zapletene programe, ukazi, s katerimi boste bodo morali napisati bodo dobili še bolj zapleteno vedno. 

In zato ni treba skrbeti. Izkazalo se je, da ljudje pred nam so ugotovili, da preveč imel ta popolnoma enak problem. Tudi oni niso imeli da bi tip precej dolge, Skrivnosten ukazov, kaj šele, da se jih spomnimo. In tako so se ljudje pred nami je druge programe, da bi bilo lažje sestaviti svojo programsko opremo. 

In seveda ena takšna Program se imenuje Znamka. Tako da sem šel naprej in to. Bom razveljaviti vse, kar sem Samo niti na naslednji način. Naj tip LS. In boste opazili tri things-- a.out in zvezda, zdravo in zvezda, in hello.c. Upajmo, to naj se malo intuitivno, če že ni bilo nič v tem delovnem prostoru. Nič ni bilo, da sem imel ustvarjen, dokler ne bomo začeli razred. 

In sem ustvaril hello.c. Nato sem ga sestavila, in ga poimenoval a.out. In potem sem še enkrat zbrati nekoliko drugače in ga poimenoval zdravo. Torej imam tri datoteke v tem imeniku, V tej mapi Workspace. Zdaj pa vidim, da je tudi če sem pomanjšavo pravzaprav. 

Če bi pomanjšati tu in poglej to zgornjem desnem kotiček, kot je bilo obljubljeno levo na desni strani zaslona se vedno dogaja, da ti pokažem kaj je v računu, kar je notranjost CS50 IDE. In tam je tri datoteke tam. 

Torej, želim, da se znebite a.out in zdravo. In kot ste morda zamisliti intuitivno, vas lahko razvrstimo kontrolnega klik ali desni klik na to. In ta mali meni izskoči. Lahko prenesete datoteko, zaženite je, predogled, osvežitev, preimenovati, ali kaj ne. 

In lahko sem samo izbrisati, in bi šel proč. Ampak kaj je stvari z ukazom linija za zdaj, tako da se udobno s tem, in naredite naslednje. Bom, da gredo naprej in odstranite a.out z vnosom dobesedno rma.out. Izkazalo se je, ukaz za odstranitev ali izbris nekaj, ni odstraniti ali izbrisati. 

To je bolj na kratko RM, samo, da shranite si nekaj tipkanja, in pritisnite tipko Enter. Zdaj bomo nekoliko cryptically odstraniti redno datoteke a.out. Res ne vem, kakšna nepravilna datoteka bo še. Ampak jaz ne želim, da ga odstranite. 

Torej bom y tipa za yes. Ali sem lahko tip ven, in pritisnite tipko Enter. In še enkrat, nič ne zgodi. Ampak to je na splošno dobra stvar. 

Če bi ta čas tip LS, kaj naj vidim? Upajmo, samo zdravo in hello.c. Zdaj, kot stran, boste Opazili to zvezdo, zvezdico, da je na koncu svojih programov. In oni so prav tako prikazuje v zeleno. To je samo način CS50 IDE za vas cluing v dejstvu, da to ni izvorno kodo. To je izvedljivo, A loven program, ki lahko dejansko vodijo s tem dot poševnica, in potem je ime. 

Zdaj pa grem naprej in odstranite to, rm zdravo, Enter, odstranite redni datoteko zdravo, ja. In zdaj, če sem tip LS, smo nazaj na hello.c. Poskusi, da ne izbrisati svoj dejanska izvorna koda. Čeprav obstajajo funkcije vgrajen v CS50 IDE kjer lahko greš skozi zgodovino revizije in nazaj v času, če vas slučajno kaj izbrisati, ali se zaveda kot na te pozive DA ali NE, o tem, kaj si dejansko želijo narediti. In če grem na vrh levem kotu tukaj, vse, kar ostane, je hello.c. Torej je grozde drugi ukazi, ki jih lahko izvaja v svetu Linuxa, ena, ki je, spet narediti. In bomo narediti Moj program je sedaj, kot sledi. 

Namesto početje Jek, namesto da bi Jek-o, Bom preprosto dobesedno tip, da zdravo. In sedaj opazili, sem ne tipkate da hello.c. Jaz sem tipkanje, da zdravo. 

In ta program Poskrbite, da prihaja z CS50 IDE, in še več na splošno z Linuxom, je program, ki je dogaja, da program, imenovan Pozdravljeni. In to se dogaja, da prevzame po dogovoru da če se lahko na ta program, to bo treba iz vira koda datoteka konča v dot c, hello.c. 

Torej, če sem udaril Enter zdaj, sporoča, da ukaz, da dobi izvrši je pravzaprav še dlje Prej kot prej. In to zato, ker smo jih prednastavljena CS50 IDE, da imajo nekatere dodatne funkcije, zgrajena po tem, da ne potrebujemo samo še, ampak kmalu bo. Vendar pa je ključna stvar za uresničitev Zdaj imam program Hello. 

Če bi še enkrat tipa LS, I Na programu je zdravo. In sem lahko teči z dot poševnica a.out, ne, ker celotno točko tega Vaja je bila pika poševnica zdravo. In zdaj imam Pozdravljen, svet. Tako napreduje, smo skoraj vedno samo dogaja, da pripravijo svoje programe uporabi ukaz make. In potem bomo jih vodijo dot poševnica in ime programa. Ampak se zavedaš, kaj Poskrbite počne za vi, je, da je sam ni prevajalnik. To je samo program, priročno da ve, kako sprožiti prevajalnik teči, tako da lahko sami uporabljati. 

Kaj obstajajo drugi ukazi v Linux, in v zameno CS50 IDE? Kmalu bomo videli, da je Ukaz CD, Change Directory. To vam omogoča, v Vaše vmesnik z ukazno vrstico , da se premaknete naprej in nazaj, in odprla različne mape ne da bi z miško. 

LS smo jih videli, ki stoji na seznam datoteke v trenutnem imeniku. Naj Dir, lahko verjetno začeli sklepati kaj to pomeni now-- da imenik, Če želite ustvariti mapo. RM za nedosegljive, RM Dir za odstranite directory-- in ti, spet so v ukazni vrstici ekvivalenti kaj vas mogoče storiti v CS50 IDE z miško. Vendar boste kmalu našli da je včasih prav veliko hitreje storiti stvari s tipkovnico, in na koncu veliko močnejši. 

Ampak to je težko trditi, da kaj smo počeli doslej je vse, kar močna, ko so vse smo že rekli, je, zdravo svet. In v resnici, sem hardcoded besede Zdravo svet v mojem programu. Zaenkrat še ni dinamičnost. Scratch je red velikosti bolj zanimivo prejšnji teden. 

In tako da je tja. Oglejmo korak v smeri, ki jo Tako nekaterih od teh funkcij. Torej ne samo, C prihajajo z printf, in grozde drugih funkcij nekateri od njih bomo videli sčasoma pa ne bi bilo vse tako enostavno ven skozi vrata v pridobivanje uporabnik vložek. 

Dejansko je eden od slabosti jezikov, kot so C, in celo Java in še drugi je, da ne bi bilo enostavno samo dobil stvari, kot so cela števila od uporabnikov, ali strune, besed, in stavkov, kaj šele stvari, kot so plavajočo vejico ali realna števila s pikami, in res dolge številke, kot bomo kmalu videli. Torej ta seznam funkcij tukaj, ti tako kot drugi Scratch koščke da smo vnaprej nameščen v CS50 IDE, da bomo uporabili za nekaj tednov kot usposabljanje kolesa vrst, in jih na koncu vzlet, in poglejte Pod pokrovom, morda, na kako se te stvari izvajajo. 

Ampak za to, kaj je dejansko napisati program. Naj gredo naprej zdaj. In bom ustvariti novo datoteko s klikom na to malo plus, in kliknete nove datoteke. 

Bom rešil to naslednji en kot, recimo, string.c, ker sem rad igral z vrvicami. In niz v C je prav zaporedje znakov. Torej, zdaj gremo naprej in naredite naslednje. 

Vključujejo standardno IO.h-- in Izkazalo se standardni IO, IO pomeni le vhod in izhod. Tako se izkaže, da Ta vrstica je tu kaj se nam sosednji uporabiti printf. Printf, seveda, proizvaja izhod. Tako da se lahko uporabi printf, se izkaže ven moraš imeti to vrstico kode na vrhu datoteke. 

In bomo prišli nazaj na to, kar ki v resnici pomeni kmalu. Izkazalo se je, da je v vsak program C pišem, Moram se začne z kodo, ki izgleda takole. In boste opazili CS50 IDE, in drugi celostni razvoj okolja, kot je to, bodo poskušali po svojih najboljših močeh lahko, da konča svoje misli. Dejstvo je, malo prej, če bi razveljavili kaj sem naredil, sem zadeti nastopiti. 

potem sem udaril odprto Curly brace, udaril znova Enter. In končal misel. To mi je dal novo linijo, zamaknjeni nič manj za lepe slogovnih razlogov, bomo videli. In nato samodejno mi je dal da zavit oklepaj, da končam misel. Zdaj, to ni vedno ugibati, kaj želite storiti. Ampak v veliki meri, da naredi vam prihranimo nekaj tipkanja. Torej, pred nekaj trenutki smo izvedli to program-- zdravo, svet, nato pa ga zbirajo, in nato tekel. Vendar ni dinamičnost tukaj. Kaj pa, če smo želeli narediti nekaj drugačnega? No, kaj pa če sem hotel, da dejansko dobili niz s strani uporabnika? Bom uporabiti kos sestavljanke imenuje točno that-- dobili niz. 

Izkazalo se je, v C, če ne želite, da se zagotovi prispevek k puzzle kos, ali natančneje do funkcije, ki jih dobesedno pač oklepaj, blizu oklepaj. Tako je, kot da obstaja no belo polje na vrsto v. Say blok pred imel malo belo škatlo. Nimamo to belo polje zdaj. 

Toda, ko sem poklical get niz, sem želijo dati rezultat nekje. Tako zelo pogosta paradigma v C je klic funkcije, kot so get niz tukaj, in nato shranite njegovo vrnitev vrednosti. To je posledica njene napora v nekaj. 

In kaj je gradnjo v programiranju, bodisi v Scratch ali zdaj C, da smo lahko uporabite za dejansko shranjevanje kaj? Pozval, da spremenljivka, kajne? In v nič, ne bomo res vseeno, kaj se dogaja v spremenljivke. 

Toda v tem primeru, smo dejansko storili. Bom povedal niz. In potem sem lahko pokličete to kaj hočem. Bom, da ga pokličete ime, dobi dobili niz. 

In zdaj tudi če ste malo nov to, opazili, da sem manjka nekaj podrobnosti. Jaz pozabljam podpičjem. Moram končati to misel. Torej bom premakniti svoj kazalec, in udaril podpičjem tam. In kaj sem naredil? V tej vrstici kode, Številka 5 v trenutku, Kličem get niz z brez vložkov. Torej ni malo belo polje, kot je Shrani blok. 

Pravim samo, hej, računalnik, daj mi niz. Enačaj ni res enako znamenje, per se. To je naloga subjekt, kar pomeni, hej, računalnik, premaknite vrednost desne čez levo. In v levo, sem naslednje. 

Hej, računalnik, daj mi string-- zaporedje znakov. In praviš niza ime. In nimam niti, da ga pokličete Ime. 

Lahko bi ga poklical, konvencionalno, nekaj podobnega S, podobno kot smo včasih sem imenujemo spremenljivka i. Toda zdaj moram nekaj storiti z njim. To bi bilo precej neumno poskusite zbiranje to kodo, ki teče ta program, čeprav Dobivam niz, ker je to še vedno samo reči zdravo svet. 

Toda kaj, če ne želim, da se to spremeni. Zakaj ne bi to storim? Odstotek je, vejica s. In to je še vedno nekoliko skrivnosten. 

Torej, dovolite mi, da moje spremenljivke bolj jasno. Naj naštejemo to ime spremenljivke. In da vidimo, če ne moremo draži narazen, kaj se dogaja. 

Torej, na pete, sem dobili niz. In sem shranjevanje ta niz, kar je uporabnik vtipka na svoji tipkovnici, v spremenljivko z imenom ime. In se izkaže, da printf ne samo da en argument v double citati, en vhod v dvojnih narekovajih. 

To lahko traja dva ali tri, ali več, kot da je drugi ali tretji ali četrti, so vsa imena spremenljivk, ali posebej vrednosti, ki jo želite priključiti na, dinamično, da je niz v narekovajih. Z drugimi besedami, kaj bi bilo narobe s tem? Če sem rekel zdravo ime, poševnica nazaj n, rešil datoteke, zbrati svojo kodo, in tekel to, kaj bi se zgodilo? 

To je samo reči, zdravo ime, dobesedno N-A-M-E, ki je nekako neumno, saj ni nič drugačen od sveta. Torej, kaj v narekovajih je kar dobesedno dobi natisnjeno. Torej, če želim imeti ogrado tam, Pravzaprav je treba uporabiti nekaj posebnega sintakso. In se izkaže, če ste prebrali Dokumentacija za funkcijo printf, to vam bo povedal, da je če uporabljate odstotkov s, lahko nadomestite vrednost, kot sledi. 

Po vejico po tem dvojni narekovaj, preprosto napisati ime spremenljivka, ki jo želite priključite v tej obliki koda, ali format določilo, odstotkov je za godala. In zdaj, če sem rešil datoteke, Grem nazaj na moj terminal. In sem tip Naj String, ker, še enkrat, ime tega datoteka, ki sem se odločil pred string.c. 

Tako bom rekel, narediti String, vnesite. Oh moj bog, poglej vse napake smo naredili že. In to is-- kaj, to je res kot šest, sedem programa vrstice? Torej, to je, če je lahko zelo hitro dobili prepričljivo. 

Ta terminal okno ima Zdaj samo izpljune veliko število sporočil o napakah. Zagotovo, nimam več napako sporočila, kot sem jih vrstic kode. Torej, kaj se dogaja? 

No, najboljša strategija storiti kadarkoli se srečujejo velika seznam napak, kot je ta, se pomaknete nazaj, poglej za ukaz si tekel, kar v mojem primeru je, da niz. Poglej, kaj make storil, in to je to dolgo Jek ukaz, ni nič takega ni. 

Toda rdeča je slaba. Green je hotel biti nežen in koristno. Vendar je še vedno slabo, v tem primeru. Ampak, če je to slabo? 

String.c, linija pet, karakter pet. Torej je to samo skupna konvencija. Nekaj ​​debelo črevo kaj pomeni številka vrstice in število znakov. Napaka, uporaba črno identifikator niz. Ali ste mislili standardna? 

Torej, žal, Jek se trudi, da je koristno. Ampak to je narobe, v tem primeru. Ne, Jek, nisem mislil standardnega IO. Mislil sem, da je na liniji, ja. 

Toda linija pet je tale tukaj. In Zvoka ne razumeti S-T-R-I-N-G. To je neprijavljeno identifikator, A Beseda je samo še nikoli ni videl. In to zato, ker C, jezik smo pisno kodo v trenutku, nima spremenljivke, imenovane strune. 

Ne, privzeto, podpore nekaj, kar se imenuje niz. To je CS50 kos žargonu, vendar zelo konvencionalno. Ampak to lahko določi, kakor sledi. 

Če dodam eno vrstico kode na vrh tega programa vključujejo CS50.h, kar je še ena datoteka nekje v notranjosti CS50 IDE, nekje na trdem disku, tako rekoč, operacijskega sistema Ubuntu da tečem, da je datoteka, ki je bo naučiti delovati Sistem kaj niz je, samo kot standardni io.h je datoteka v operacijskem sistemu, ki je bo naučil, kaj printf je. 

Dejansko bi gotten zelo podobno sporočilo če bi IO priznal standarda IO.h in poskušal uporabiti printf. Tako da sem šel naprej in samo Prevzemite nadzor L, da počistite svoj zaslon. Ali lahko napišete jasno in da bo samo jasno terminalsko okno. Ampak še vedno lahko pomikate nazaj v preteklost. 

In bom za ponovno narediti String. Cross moji prsti tokrat Enter. Oh moj bog, je delovalo. to mi kaže dolgo Grobni ukaz to je tisto, zaradi česar nastaja z Jek, vendar ni sporočil o napakah. Tako spoznali, čeprav lahko dobite popolnoma preobremenjeni z Število sporočil o napakah, je lahko samo to nadležno kaskadno učinek, kjer Zvoka ne razume ena stvar, ki jo pomeni potem ne razume naslednje besede, ali naslednjo vrstico. In tako je samo dušilke na svojo kodo. Toda fix je lahko preprosta. In tako vedno osredotočiti na prva linija proizvodnje. In če ne razumem, samo poglej ključne besede, ki bi lahko namige in številko vrstice, in znak, kjer da napaka morda. 

Zdaj pa mi gredo naprej in tip dot poševnica, niz, vnesite. Hm, to ni pozdravljanja ničesar. Zakaj? No, spomnim, kjer se izvaja? 

To je verjetno zaljubljen v trenutku v zanko, če hočete, na vrstnim šestvaljnikom, ker Get String z zasnovo, osebje CS50 napisal, je dobesedno mišljeno samo sedeti tam čaka, in čaka, in čaka na vrvico. Vsi mislimo z vrvico je človeški vložek. Torej, veste kaj? Naj gredo naprej. In samo na muhavosti, naj me vpišite svoje ime, Davida, vnesite. Zdaj imam bolj dinamičen program. To je dejal, zdravo David. 

Če grem naprej in ponovno zagnati to, naj poskusim povedati ime Zamila, vnesite. In zdaj imamo dinamičen program. Nisem težko kodirane svet. Nisem težko kodirane ime ali David, ali Zamila. 

Zdaj je bolj kot programi vemo, kje, če bo prispevek, proizvaja nekoliko drugačen izhod. Zdaj, to ni najboljša uporabniška izkušnja, ali UX. Vodim program. 

Ne vem, kaj moram storiti, če sem dejansko poglej ali pa se spomnimo, da izvorne kode. Torej, kaj je, da uporabniku doživeli malo bolje z najenostavnejši stvari. Naj grem nazaj v ta Program in enostavno reči printf. 

In mi gredo naprej in povedati ime, debelo črevo, in prostor, in nato podpičjem. In samo za brcne, ne zračnost n. In to je namerno, ker nočem poziv, da se premaknete v naslednjo vrstico. 

Rad bi, namesto da bi to storili, bi niz da prevedem kodo v nov stroj Koda dot poševnica niz. Ah, to je precej lepši. Zdaj pa zares ve, kaj računalnik želi od mene, da ga ime. 

Tako da sem šel naprej in tip v Robu, vstopijo in zdravo, Rob. Torej, zavedati, da je to še vedno na koncu na dan, samo program devet linije. Ampak smo izvedli te otroške korake. 

Napisali smo eno vrstico, s katero smo bili seznanjeni, printf, zdravo svet. Potem smo undid malo da. In smo dejansko uporablja get niz. In sva vrgla, da je vrednost v spremenljivki. In potem smo šli naprej in izboljšati nadalje s tretjo linijo. In ta ponavljajoči postopek pisanje programske opreme je resnično ključnega pomena. V CS50, in v življenju nasploh, vam na splošno ne bi smeli sesti, imajo program v mislih, in poskusite pisanje cela prekleta stvar naenkrat. 

To bo neizogibno povzročilo način več napak kot mi sami videli tukaj. Tudi jaz, na ta dan, ki se nenehno še druge neumne napake, dejansko težje napake da jih je težje razbrati. Ampak ti bo več napak več vrstic kode pišete vse naenkrat. In zato je ta praksa, napisati malo kodo da ste zadovoljni s, pripravijo da, prost dostop, je na splošno testiranje, nato pa on--, da tako kot smo ohranili plastenje in plastenje prejšnji teden, gradnjo iz nekaj zelo enostavno za nekaj bolj zapletenega, storijo enako tukaj. Ne sedite, in poskusite napisati celoten problem. Pravzaprav bi te otroške korake. 

Zdaj, strune niso vsi da je koristno sami sebi. Mi bi v resnici, v najboljšem primeru, kot je na nekaj drugega v naši orodij. Torej, kaj je dejansko naredil točno to. 

Naj gredo naprej zdaj in bič gor nekoliko drugačno programa. In bomo to imenujemo int.c, za celo število. Bom, podobno, vključujejo CS550.h. Bom vključujejo standardno IO. In to se dogaja, da je precej pogosti V teh prvih nekaj dneh razreda. 

In bom pripravljen sam z glavno funkcijo. In zdaj namesto da bi dobili niz, gremo naprej in se int. Recimo i in poklical dobil int, blizu parens, podpičjem. In zdaj naredimo kaj z njim, printf. 

Recimo nekaj takega zdravo, poševnica nazaj n, vejica i. Tako da sem precej posnemanjem kar sem pred nekaj trenutki. Imam ogrado tukaj. Sem vejico i tukaj, ker želim da se priključim v to ogrado. 

Torej, gremo naprej in poskusiti pripravo tega programa. Datoteka se imenuje int.c. Tako da sem hotel reči, da int, vnesite. Oh moj bog, vendar ni nič takega, kajne? Tam je napaka. 

Tam je skladenjska napaka Tukaj tako da program ne more je treba urediti znotraj int.c, črte sedem, znak 27, format error določa tip char zvezda, karkoli že to je. Ampak tip argument je int. 

Torej tudi tu, ne bomo to-- čeprav je danes veliko materiala, bomo, da vas preplavijo z absolutno vsak element C, in programiranje na splošno, v samo teh prvih nekaj tednih. Tako da se pogosto dogaja, da se žargon s katerimi niste seznanjeni. In v resnici, znak zvezda je nekaj bomo vrnili v tednu ali dveh v času. 

Ampak za zdaj, da vidimo, če bomo lahko razčleniti besede, ki jih poznate. Formats-- tako smo slišali format določilo, format code prej. To je znano. Type-- vendar argument je tipa int. Čakaj malo, i int. 

Mogoče odstotkov je dejansko ima nekaj definiran pomen. In, seveda, to počne. Celo, če hočeš printf, da ga nadomesti, si dejansko morali uporabiti drugačna oblika določilo. In ne veš, to če nekdo povedal, ali pa je to že počel. Toda odstotkov i kaj lahko pogosto uporabljeni v printf za priklopom na celo število. Lahko uporabite tudi odstotkov d za decimalno celo število. Ampak jaz je lepo in enostavno tukaj. Torej bomo šli s tem. 

Zdaj pa mi gredo naprej in ponovitev make int Enter. To je dobro, brez napak. Dot poševnica int-- OK, slab uporabniško izkušnjo, ker nisem sam povedal kaj storiti. Ampak to je v redu. Bom lov na hitro. 

In zdaj mi gredo naprej in tip v Davida, OK, Zamila, Rob. OK, tako da je to dobra stvar. Tokrat sem z funkcijo, puzzle kos, ki se imenuje get int. In se izkaže out-- in bomo glej to kasneje v term-- osebje CS50 je izvajala priti niti na tak način, da bo le fizično dobili niz za vas. 

Izvedla je get int v tak način, le da bo dobili celo za vas. In če vas je človek, ne sodelujejo, je dobesedno le, da bo pravijo retry, retry, retry, dobesedno sedel tam zanka, dokler si zavezati z nekaj čarobno številko, kot 50, in hello 50. 

Ali pa, če bomo to še enkrat teči in tip v 42, zdravo 42. In tako funkcija get int znotraj te puzzle kosa Dovolj je logika, dovolj misel, da ugotovimo, kaj je beseda? In kakšna je številka? Sprejemamo samo, končno tudi številke. 

Tako se izkaže, da je to ni vse, da izrazna. do sedaj. Torej, yay, zadnjič, ko smo precej hitro odšel v izvedbenih igre in animacije, in umetniška dela v nič. In tu smo pri čemer vsebina Hello svetu in hello 50. 

To pa še ni vse, da je navdihujoča. In, seveda, ti najprej nekaj Primeri bo trajalo nekaj časa na ploščadi v razburjenje. Vendar imamo še veliko več nadzorovati zdaj, v resnici. In bomo zelo hiter začetek plastenje na vrhu teh osnovnih gradnikov. 

Ampak najprej, kaj je razumeti kaj omejitve so. V bistvu, ena od stvari Scratch ne enostavno nam storiti, je res videti pod pokrovom, in razumeti, kaj Računalnik je, kaj lahko stori, in kakšne so njegove omejitve so. In res, da je pomanjkanje razumevanje, potencialno dolgoročno lahko privede do lastnega mistakes-- pisno bugs, pisanje negotov programske opreme, ki dobi kramp na nek način. 

Tako da je lahko nekaj korakov v smeri razumevanju to malo bolje način, pravijo, naslednji primer. Bom, da gredo naprej in izvajanje resnično hitro program, imenovan Adder. Kot, kaj je dodati nekaj številk skupaj. In bom kodo nekaj kotičkov tukaj, in samo kopiraj in prilepi kjer sem bil prej, samo tako da lahko grem prej. Zdaj imam osnovnih začetkov programa imenovanega Adder. 

In gremo naprej in to. Bom, da gredo naprej in recimo, intx dobi dobili int. In veste kaj? Naredimo boljšo uporabniško izkušnjo. 

Torej, recimo x, in učinkovito pozove uporabnika, da nam x. In potem mi gredo naprej in rekli, printf kaj pa je y, tokrat pričakoval dve vrednosti od uporabnika. In potem pa pojdi naprej in recimo, printf, vsota x in y je. In zdaj ne želim narediti odstotkov s. Hočem narediti odstotkov i, poševnica nazaj n in nato plug vsota vrednosti. 

Torej, kako lahko greste o tem? Veš kaj? Vem, kako uporabljati spremenljivk. Naj samo razglasi novega, int z. 

In bom si ugibati tukaj. Če so enake znake v to jezik, morda sem lahko samo naredi x plus y, tako dolgo, kot sem na koncu moje Mislil s podpičjem? Sedaj lahko grem nazaj dol, priključite z, končati to misel s podpičjem. In da vidimo zdaj, če ti zaporedja lines-- x je dobil int. Y je dobil int. 

Dodamo X in Y, shranjevanje vrednosti v z-- tako da, še enkrat, ne pozabite enačaj ni enaka. To je naloga od desne proti levi. In kaj je izpisal, da je vsota x in y ne dobesedno zf ampak kaj je znotraj z. Torej, kaj je narediti Adder - lepo, brez napak tokrat. Dot poševnica Adder, vstop, x se bo 1. 

Y se bo 2. In vsota x in y je 3. Tako, da je vse v redu in prav. 

Tako bi si lahko predstavljate, da je matematika morajo delovati v programu, kot je ta. Ampak veš kaj? Je to spremenljivka, linija 12, čeprav je to potrebno? Saj ni treba, da bi dobili v navado za samo shranjevanje stvari v spremenljivkah samo zato, ker lahko. In v resnici, da je na splošno premišljeno slaba zasnova Če ste ustvarili spremenljivke, ki se imenuje z V tem primeru shranjevanje nekaj v njej, in nato takoj ki ga uporablja, vendar nikoli več. Zakaj dati nekaj ime kot vz če ste dobesedno gre za uporabo, da stvar samo enkrat, in zato proksimalno, kjer ste ustvarili je na prvem mestu, tako blizu v smislu vrstic kode? Torej, veste kaj? Izkazalo se je, da je C precej fleksibilna. Če bi dejansko želijo plug-in vrednot tukaj, Ne potrebujem, da razglasi novo spremenljivko. Jaz lahko samo plug-x plus y, ker C razume aritmetično in matematičnih operaterjev. 

Tako da lahko preprosto reči, to stori matematike, x plus y, ne glede na te vrednosti, vtič nastalo celo v tem nizu. Torej je to lahko, čeprav le eno vrstico krajši, boljši design, boljši program zato, ker je manj kodo, zato manj razumem. In to je tudi samo čistejši, v kolikor nismo uvajanje novih besed, Novi simboli, kot z, čeprav v resnici ne služijo veliko namenom. 

Žal matematike ni vse, da se zanesljive včasih. Gremo naprej in to. Bom, da gredo naprej zdaj in naredite naslednje. 

Naredimo printf, odstotni i, plus odstotkov i, mora biti odstotkov i, poševnica nazaj n. In bom naredil this-- xyx plus y. Tako da sem le, da bo na novo to nekoliko drugače tukaj. Naj pač preverjanje hitro duševno zdravje. Še enkrat, kaj je ne dobijo pred sebe. Naj seštevalnik, pika poševnica seštevalnika. x je 1, y 2, 1 plus 2 je 3. Torej, to je dobro. Ampak kaj je zapletlo to zdaj malo, in ustvariti novo datoteko. 

Bom poklical ta, pravijo, Ints, plural cela števila. Naj začnem, kjer sem bil pred nekaj trenutki. Toda zdaj naredimo nekaj drugih linij. Naj gredo naprej in naredite naslednje, printf, odstotek i, minus odstotkov i, je odstotek i, vejico x, vejica yx minus y. Tako da sem malo delal drugačna math tam. Naredimo še eno. Torej odstotkov i krat odstotkov i odstotkov i, poševnica nazaj n. Oglejmo plug-x in y in x-krat y. Bomo uporabili zvezdico na računalnik za čas. 

Ne uporabljate x. x spremenljivka ime tukaj. Uporabite zvezdo za razmnoževanje. Naredimo še eno. Printf odstotkov I, razdeli z odstotnim i je odstotkov i poševnica nazaj n. xy, deljeno s y-- tako da uporabite poševnico v C storiti delitev. In kaj je naredil eno drugo. Preostanek odstotkov i, razdeljen ga odstotkov i, je odstotkov i. xy-- in zdaj preostanek je tisto, kar je ostalo več. Ko poskusite tako, da se imenovalec v števcu koliko je ostala, da si ne bi mogla deliti ven? 

Torej ni res, nujno, simbol smo se uporablja v osnovni šoli za to. Vendar pa obstaja v C. Lahko pravijo x modulo y, kjer je to znak za odstotek v tem context-- zamenjati, ko ste notri dvojnih narekovajev, znotraj z printf, odstotka Uporablja se kot format določilo. 

Ko uporabljate odstotkov zunaj da se v matematičnem izrazu, je upravljavec modulo za modularno arithmetic-- za naše namene tukaj, pomeni le, kaj je Preostanek x deljeno s y? Tako x deljeno z y x poševnica y. Kaj je preostanek x deljeno s y? To je x mod y, kot bi programer povedati. 

Torej, če sem naredila nobene napake sem, naj me iti naprej in se Ints, plural, lepo, in pika poševnica Ints. In gremo naprej in storiti, recimo, 1, 10. V redu, 1 plus 10 je 11, check. 1 minus 10 negativen 9, preveriti. 

1 krat 10 je 10, check. 1 deljeno z 10 is-- OK, bomo preskočili, da je eden. Preostanek 1 deljeno z 10 je 1. To je pravilno. Ampak tam je napaka tukaj. 

Torej, tisti, ki sem dal moj predati, ni pravilna. Mislim, da je blizu 0. 1 deljeno z 10, saj veš, če smo rezanje nekaj vogali, seveda, to je nič. Vendar pa bi bilo res 1/10, 0.1 ali 0.10, 0,1000, ali tako naprej. 

To ne bi smelo biti res nič. No, izkaže se, da je računalnik gre dobesedno tisto, kar smo povedali, da storiti. Delamo matematiko kot x deljeno s y. In tako x in y, na progah kode prej, so cela števila. 

Poleg tega so na liniji 15, smo povedal printf, hej, printf plug-in celo število, plug-in celo število, plug-in v integer-- posebej x, potem y in nato x deljeno s y. sta x in y Ints. Mi smo dobro tam. 

Toda kaj je x deljeno s x? x deljeno s moral y, matematično, 1/10, 0,1, kar je realno število, realno število ob potencialno decimalno vejico. To ni celo število. 

Toda kaj je najbližje celo do 1/10 ali 0,1? Ja, nekako je nič. 0.1 je tako veliko. In 1, je to veliko. Tako 1/10 bliže 0, kot je na enega. 

In kaj C počne za us-- vrste, saj smo povedali to-- je skrajšano, da je celo število. To je pri vrednosti, ki je spet naj bi bilo nekaj podobnega 0.1000, 0 in tako naprej. In to je med krčenjem vse decimalno vejico tako da vse to stvari, ker ne prilega v pojmu celo število, ki je le nekaj kot negativna 1, 0, 1, gor in dol, da odvrže vse decimalno vejico, ker ste ni mogoče vgraditi decimalno vejico v celo po definiciji. 

Torej je odgovor tukaj ni nič. Torej, kako popraviti to? Potrebujemo še eno rešitev, vse skupaj. In to lahko storimo, kot sledi. 

Naj gredo naprej in ustvariti novo datoteko, ta se imenuje floats.c. In jo shranite tukaj v Enako imenik, float.c. In mi gredo naprej in kopiranje nekaj te kode od prej. 

Toda namesto da bi dobili int, kaj je to. Daj mi plavajočo vejico vrednost imenovano x. kjer plavajočo vejico vrednost je le dobesedno nekaj s plavajočo vejico. To lahko premikate levo, desno. To je realno število. 

In naj me pokliče, ne dobili int, ampak dobil plovec, ki je bila tudi med menija možnosti v knjižnici C250. Spremenimo y, da likvidna sredstva. Torej, to postane dobil plovec. 

In zdaj, ne želimo, da bi zapolnili v ints. Izkazalo se je, da moramo uporabiti odstotkov f za plovcem, odstotka f za float, in zdaj ga shranite. In zdaj, pesti, da boje, lepo, pika poševnica plava. x se bo ena 1. y Se bo 10 znova. 

In, lepo, OK moj dodatek je pravilna. Upal sem več, ampak sem pozabil napisati. Torej, pojdimo in popraviti to logično napako. 

Gremo naprej in zgrabi naslednje. Bomo pač malo kopiraj in prilepi. In bom povedal minus. 

In bom povedal krat. In bom reči deljena. In ne bom storiti modulo, ki ni tako germane tukaj deljeno z f in časi plus-- OK, kaj je to ponovi. 

Znamka boje, pika poševnica boje, in 1, 10, in-- lepo, no, OK. Tako da sem idiot. Torej, to je zelo pogosta v računalništvu da neumne napake, kot je ta. 

Za pedagoške namene, kaj sem res hotel narediti je spremeniti znanost tukaj na plus, da minus, na čase, in razdeliti, kot si upamo opazili pri tej vaji. Torej, zdaj pa je ponovno zbere to Program, ali dot Slash boje. 

In tretjič, kaj je vidim, če izpolnjuje moja pričakovanja. 1, 10, začne, ja, OK, 1.000, deljeno s 10.000 je 0,100000. In se je izkazalo, da lahko nadzorujete, koliko Številke so po teh pikami. Dejansko bo. Vrnili se bomo na to. 

Toda zdaj, v resnici, matematika je pravilna. Torej, še enkrat, kaj je takeaway tukaj? Izkazalo se je, da je v C Ne šele strings-- in dejansko obstajajo ni res, ker smo dodamo tiste s knjižnico CS50. Vendar pa obstajajo ne samo Ints. 

Obstajajo tudi plava. In se izkaže, kup drugih podatkov vrste tudi, da bomo uporabili kmalu. Izkazalo se je, če hočeš eno samo značaja, ni niz znakov, lahko uporabite samo char. 

Izkazalo se je, da če hočeš bool, logično vrednost true ali false le, zahvaljujoč knjižnici CS50, ki smo jih doda C podatkovni tip bool kot dobro. Ampak to je tudi predstaviti številne druge jezike, kot dobro. In se izkaže, da včasih ti Potrebujemo večje število pa prihajajo privzeto z ints in plovci. 

In, v resnici dvojni je številka ki uporablja ne 32 bitov, ampak 64 bitov. In dolgo dolgo je številka, ki uporablja ne 32, bitov pa 64 bitov, oziroma za plavajočo vejico vrednote in cela števila, v tem zaporedju. Torej, kaj je pravzaprav zdaj videti v akciji. 

Bom, da gredo naprej tukaj in bič gor en drug program. Tukaj bom, da gredo naprej in ne vključujejo CS50.h. In mi gre, vsebuje standardne IO.h. 

In boste opazili nekaj funky se dogaja tukaj. To ni barvno kodiranje stvari na enak način, kot je to storila prej. In se je izkazalo, da je zato, ker I niso dale stvar ime datoteke. 

Bom poklical tole sizeof.c, in pritisnite Shrani. In opazil, kaj se dogaja z mojim zelo bela številka zoper to črno ozadje. Zdaj, vsaj tam je nekaj vijolične tam. In to je sintaksa poudaril. 

To je zato, ker, preprosto, Sem povedal IDE kakšno vrsto datoteke je, tako da mu daje ime in natančneje razširitev datoteke. Zdaj pa gremo naprej in to. Bom, da gredo naprej in zelo preprosto natisnete following-- bool je odstotkov LU. 

Vrnili se bomo na da je vsak trenutek. In potem bom velikost tiska bool. In sedaj, samo, da shranite sem nekaj časa, da sem storili celoto kup teh naenkrat. In, še posebej, bom spremenite v char in char. Tale, bom za spremembo za dvojno in dvojno. 

Tale, bom za spremembo s plovcem in likvidna sredstva. Ta je, da bom spremeni v int in notr. In to, jaz grem spremeniti, da dolgo dolgo. In to je še vedno ob Dolgo, dolgo dolgo. 

In potem, na koncu, sem dal Sam eno preveč, niz. Izkazalo se je, da je v C, tam je posebno operator imenuje velikost, ki je dobesedno bo, ko teče, povej nam velikost Vsaka izmed teh spremenljivk. In to je način, zdaj moremo povezati nazaj razprave prejšnji teden podatkov in zastopanja. 

Naj gredo naprej in pripravijo velikost pik velikosti poševnico za. In poglejmo. Izkazalo se je, da je v C, zlasti na CS50 IDE, še posebej na operacijski sistem Ubuntu, ki je 64-bitni operacijski Sistem v tem primeru bool bo uporablja en bajt prostora. To je, kako se meri velikost, Ne v bitih, ampak v bajtov. In opozarjajo, da je en bajt osem bitov. Torej bool, čeprav vas Tehnično potrebujemo samo 0 ali 1, da je malo potratno kako smo ga izvajali. To se dejansko dogaja za uporabo celoto byte-- tako da vse ničle, so morda vsi tisti, ali nekaj takega, ali pa samo en 1 med osem bitov. 

Char, medtem, ki se uporablja za znak kot ASCII znaki na prejšnji teden, se bo en znak. In to synchs z našim pojmom da bi bilo ne več kot 256 bits-- precej, synchs up s čemer ni več kot 8 bitov, ki so nam daje tudi do 256 vrednosti. Dvojno bo je 8 bajtov ali 64 bitov. 

Plovec je 4. Int je 4. Dolgo, dolgo je 8. In niz je 8. Ampak ne skrbi. Bomo lupine nazaj, da je plast. Izkazalo se je, strune lahko biti daljša od 8 bajtov. 

In, seveda, smo pisno že strune, zdravo svet, več kot 8 bajtov. Vendar se bomo vrnili k da je vsak trenutek. Toda vzeti tukaj je naslednji. 

Vsak računalnik ima le omejen količino pomnilnika in prostora. Shranite lahko le toliko datoteke na vašem Mac ali PC. Shranite lahko le toliko programov RAM teče hkrati nujno, celo z navideznega pomnilnika, saj imate končno količino RAM-a. 

In samo picture-- če nisi nikoli odprl laptop ali naročiti dodatnega pomnilnika za računalnik, morda ne vedo, da v notranjosti računalnika je nekaj, kar izgleda malo, kot je ta. Torej je to samo skupno podjetje z imenom Ključno je, da naredi RAM za računalnike. In RAM kjer programi živijo, medtem ko delate. 

Torej, na vsak Mac ali PC, ko se dvakrat kliknite program, in odpira, in odpira nekaj Wordov dokument ali nekaj takega, jo shrani začasno RAM, ker RAM je hitrejši kot trdi disk, ali vaš SSD disk. Torej, to je samo, če programi gredo živeti, ko delate, ali če se uporabljajo datoteke. 

Torej imate stvari, ki izgledajo kot je ta notranjost vašega prenosnika, ali nekoliko večje stvari znotraj namizju. Toda ključ imate samo končno število teh stvari. In tam je le končna količina strojna oprema sedel na mizo prav tukaj. 

Torej, zagotovo ne moremo shraniti neskončno dolgih številk. In vendar, če menite nazaj Šola, koliko številk lahko imate na desni strani za decimalno vejico? Kar se tega tiče, koliko številk lahko moraš levo od decimalne vejice? Res, neskončno veliko. 

Zdaj smo ljudje samo morda znate izgovoriti milijonov, in milijarde, bilijone, in trilijonov in quintillion. In sem premikanje meja moje understanding-- ali my-- razumem številke, ampak moj izgovorjava številk. Vendar pa lahko dobite neskončno velika s neskončno mnogo številke na levi ali na desno od decimalne vejice. 

Ampak računalniki imajo le končno količino pomnilnika, končna število tranzistorjev, A končno število žarnic v notranjosti. Torej, kaj se zgodi, ko vam zmanjka prostora? Z drugimi besedami, če vas pomislite na zadnji teden ko smo govorili o številkah sami, ki so zastopane v binarni, Predpostavimo, da imamo Ta 8-bitna vrednost tukaj. 

In imamo sedem 1 in ena 0. In domnevam, da želimo dodati 1 tej vrednosti. To je res velika številka zdaj. 

To je 254, če se prav spomnim math od zadnjega teden desne. Kaj pa če zamenjam da skrajno desna 0 k 1? Celotno število, iz Seveda, postane osem +1. Torej smo še vedno dobri. 

In to verjetno predstavlja 255, čeprav je odvisno od konteksta da bi lahko dejansko predstavlja negativno število. Ampak več o tem kdaj drugič. To se počuti, kot da je o tako visoko, kot sem lahko računamo. 

Zdaj je samo 8 bitov. In moj Mac, zagotovo, je pot več kot 8 bitov pomnilnika. Vendar pa ima omejen. Torej velja ista trditev, tudi če še več teh tiste na zaslonu. 

Toda kaj se zgodi, če ste shranjevanje to številko, 255, in želite, da računajo 1 bit višja? Hočeš, da gredo od 255 do 256. Problem je seveda, da če ti začnemo na nič, kot prejšnji teden, si ne more računati tako visoka kot 256, kaj šele 257, kaj šele 258, m, ker kaj se zgodi, ko boste dodali 1? Če boste to storili stari osnovni šoli pristop, ki si dal 1 tukaj, in nato 1 plus 1 je 2, ampak to je res nič, nosite za 1, nosijo 1, nosijo 1. Vse te stvari, ti 1 je, pojdite na nič. In ti zaključek, da, kot nekdo, je poudaril, je 1 na levi strani. Ampak vse, kar lahko dejansko videli in se prilega v spomin je le osem 0 je, kar je povedal na neki točki, če vas, računalnik, Poskušali štetje dovolj visoko, ti si tekoč da se ovije okoli se zdi, nič, ali morda celo negativno številke, ki so še nižje od nič. 

In bomo lahko nekako videti. Naj gredo naprej in pisati pravi hitro programa tukaj. Naj gredo naprej in pisati program, imenovan prelivom. Vključi CS50.h, vključujejo standardna IO.h-- oh, Res sem zamudil svoj barvanje sintakse. Torej, kaj je rešiti to kot overflow.c. 

In zdaj int main void-- in pred dolgo, bomo vrnili razloži, zakaj hranimo pisanje int glavno praznino. Ampak za zdaj, kaj je pač to, da se šteje kot samoumevno. Dajmo sam int, in inicializacijo 0. 

Kaj je potem to za int dobim zero-- pravzaprav naredimo neskončno zanko in glej kaj se zgodi. Medtem ko je res, potem pa natisnete n je odstotek i, poševnica nazaj n, plug-n. Ampak, zdaj, naredimo n dobi n plus 1. 

Torej, z drugimi besedami, na vsaki ponovitev te neskončne zanke, vzemimo vrednost N, ki je, in dodamo 1 do nje in nato Rezultat shranite nazaj v n na levi strani. In v resnici, smo videli sintaksa rahlo, kot je ta, na kratko. Cool trik je namesto pisanje vse to ven, lahko dejansko recimo n plus enaka 1. 

Ali pa, če si res želiš biti fancy, lahko rečemo, n plus plus podpičjem. Toda slednje dva sta samo kaj bi imenujemo skladenjska sladkorja za prvo stvar. 

Prva stvar, ki je bolj jasno, povsem v redu, popolnoma pravilna. Toda to je bolj pogosta, bom rekel. Torej bomo to naredili le za trenutek. 

Zdaj pa se bo preliv, ki se sliši precej zlovešč, pika poševnica overflow. Poglejmo, n je že precej velik. Ampak kaj je razmišljati, kako velik je lahko n dobil? 

n je int. Smo videli pred nekaj trenutki z velikostjo na primer, da je int štiri bajte. Vemo, od prejšnjega tedna, štiri bajte je 32 bitov, ker je 8 krat 4, ki je 32. To se dogaja, da je 4 milijarde. 

In mi smo do 800.000. To bo večno trajalo, da štejejo kot visoko, kot sem morebiti lahko. Tako da sem šel naprej, kot si morda kmalu, in zadeti Nadzorna C- odkrito, nadzor C veliko, kjer Control C praviloma pomeni prekinitev. Žal, ker ta teče v oblaku, včasih oblak izpljunil toliko stvari, toliko izhod, da se bo traja nekaj časa za svoj vložek priti v oblak. Torej, čeprav sem udaril Control C pred nekaj sekund, to je definitivno stran Učinek neskončno zanko. 

In zato v teh primerih smo bo zapustil, da bo. In bomo dodali še eno terminal window tukaj s plus, ki pa seveda ne kot je ta, ker je še vedno razmišljam. In gremo naprej in se malo bolj smiselno. 

Bom, da gredo naprej in ne to samo finitely kolikokrat. Uporabimo za zanke, ki sem jo omenili prej. Naredimo to. Daj mi še eno spremenljivko int i dobi 0. i je manj kot, recimo, 64 i ++. In zdaj mi gredo naprej in tisk iz nje odstotkov i vejico n. In potem N- je to še vedno bo trajalo večno. Naredimo to. 

n dobi n krat 2. Ali bi morali biti fancy in ne čas enaka 2. Ampak recimo, n enako sam krat 2. Z drugimi besedami, pri tem Nova različica programa, Ne želim, da večno čakati od kot 800.000 do 4 milijarde. Naj samo že s tem. 

Kaj je pravzaprav dvojno n vsakič. Ki, odpoklic, podvojitev je Nasprotno imajo, seveda. In ker je prejšnji teden imamo spet nekaj, in še enkrat, in še enkrat, super hitro, podvojitev bo zagotovo naju od 1 do največje mogoče vrednost, da lahko računamo, da pri notr. 

Torej, kaj je naredil točno to. In bomo prišli nazaj na to kmalu. Ampak to, še enkrat, je prav tako kot ponavljanja blok v Scratch. In boste to uporabili kmalu. 

To samo pomeni število od nič do, vendar ni enaka do 64. In na vsaki ponovitvi te zanka, samo ne povečevanje i. Torej i ++ - in to splošno konstrukt na liniji 7 je samo super običajen način ponavljanje nekaj vrstic Koda, nekateri večkrat. Kateri vrstic kode? Te zaviti oklepaji, kot vi Morda naberejo od zdaj, pomeni, naredite naslednje. 

To je na podoben Scratch, ko ima rumene bloke in druge barve, ki nekako objemu ali objem drugih blokov. To je tisto, kar ti kodrasti naramnice delaš tukaj. Torej, če imam sintakso right-- vas vidim simbol korenček v C sredstvi to, kolikokrat sem bil poskušajo rešiti ta problem. Torej, kaj je znebiti, da je eden skupaj, in zaprite to okno. In bomo uporabili novo. Poskrbite, pretočni, dot poševnica overflow, Enter, vse v redu, izgleda slabo na prvi. Ampak kaj je pomaknete nazaj v čas, ker sem to 64-krat. 

In opazil prvič, n je 1. Drugič, je n 2, Nato 4, potem 8, nato 16. In zdi se, da v najkrajšem možnem Pridem do približno 1 milijardo, če sem ga ponovno podvojiti, da bi bilo, da mi 2 milijardi. Ampak se je izkazalo, da je prav na pragu. 

In tako je dejansko prestopi int od 1 milijardo za približno negativna 2 milijard, ker je celo število, za razliko od številke mi so ob predpostavki, prejšnji teden, lahko pozitivni in negativni V resnici in v računalniku. In da je vsaj eden izmed tistih bitov učinkovito ukraden. Tako smo v resnici le 31 bitov, ali 2 milijardi možne vrednosti. 

Ampak za zdaj je hrana za s seboj precej Preprosto, ne glede na te številke in ne glede na matematika, kaj slabega zgodi na koncu, ker na koncu ste poskušali permutiranje bite enega preveč krat. In ti dejansko šel od vseh 1, da morda vse 0 je, ali morda samo nekateri drugi vzorec, ki ji jasno, odvisno od okoliščin, mogoče razlagati tako, da z negativnim predznakom. In tako se zdi najvišjo I Lahko računate na tem programu je le približno 1 milijardo. Vendar pa je delna rešitev tukaj. Veš kaj? 

Naj prehod iz int za dolgo dolgo. In mi daj tukaj in say-- bom imela spremeniti to nepodpisano dolgo. Ali pa, da vidimo, sam nikoli ne spomnim. 

Gremo naprej in da overflow. Ne, to ni to, LLD, hvala. Tako da včasih Jek je lahko koristno. Nisem ne spomnim, kaj format Specifier je za dolgo dolgo. 

Ampak, seveda, Jek mi je povedal. Green je neke vrste dobro, še vedno pomeni, da se je zmotil. To je ugibati, da sem mislila LLD. 

Zato mi dovolite, da je nasvet, dolgo dolgo decimalno število, le da. In mi to ponovi, pika poševnica overflow, Enter. In zdaj, kaj je kul je to. 

Če bi se pomaknete nazaj v čas, še vedno začeti štetje hkrati place-- 1, 2, 4, 8, 16. Obvestilo smo dobili vse tja do 1 milijardo. Potem pa smo varno prišli do 2 milijardi. 

Potem pridemo do 4 milijarde, nato 8 milijard, 17 milijard. In gremo višje, in višje in višje. Sčasoma, tudi to, odmori. 

Sčasoma, z dolgo dolgo, ki je 64-bitna vrednost, ne 32-bitna vrednost, če šteješ previsoka, jo ovijte okoli 0. In v tem primeru, se zgodi, da na koncu z negativnim predznakom. 

Torej, to je problem. In se izkaže, da je to Problem je, ni vse tako skrivnostne. Čeprav Sem namenoma je povzročena s temi napakami, Izkazalo se vidimo nekako vse okoli nas, ali vsaj nekateri od nas. 

Torej, v Lego Star Wars, če ste kdaj igral igro, se izkaže, da lahko greš okoli breaking stvari v LEGO svetu, in zbiranje kovancev, v bistvu. In če ste kdaj igral ta igra tako preveč časa, kot je ta neimenovana oseba Tukaj si, skupno število kovancev, ki jih lahko zbirajo je, da se zdi, 4 milijarde. 

Sedaj, ko se je dejansko zaokrožena. Torej LEGO je poskušal da uporabnik stvari prijazen. Niso to ravno od 2 do 32 moči, na prejšnji teden. Ampak 4 milijarde razlog. Zdi se, da na podlagi teh podatkov, da je LEGO, in podjetje, ki je to dejansko programsko opremo, odločila da je največje število kovancev uporabnik lahko kopičijo je res, 4 milijarde, zato, ker so se odločili v svoji kodi Za uporabo ni dolgo dolgo, očitno, ampak samo celo število, nepodpisan celo samo pozitivno celo število, čigar max vrednost je približno to. No, tu je še en smešno eno. Torej igra Civilization, ki nekateri od vas morda pozna, z se izkaže, da je pred leti tam je bila napaka v tej igri, pri čemer če si igral vlogo od Gandhija v igri, namesto njega se zelo pacifist, namesto da bi bilo neverjetno, neverjetno agresiven, v nekaterih okoliščinah. Še posebej, tako da je civilizacija dela je, da če vas, igralec, sprejme demokracijo, si agresivnost rezultat dobi zmanjšamo z dvema, tako minus minus, nato pa minus minus. 

Tako da odštejemo 2 od vaša dejanska ponavljanjem. Na žalost, če je vaša ponavljanjem je najprej 1, in jo odštejemo 2 od nje po sprejetju demokracije kot Gandhi tukaj morda storili, ker je bil zelo passive-- 1 na lestvici od agresivnosti. Če pa sprejema demokracijo, potem gre od 1 do negativnega 1. 

Žal so bili uporabo nepodpisane številke, kar pomeni, da obravnavajo celo negativna številke, kot da bi bili pozitivni. In se izkaže, da je pozitiven enako negativen 1, V tipičnih računalniških programov, je 255. Torej, če Gandhi sprejme demokracija je, in zato njegova ocena agresivnost zmanjšala, dejansko zvitkih okoli 255 in naredi ga je najbolj agresiven lik v igri. Tako si lahko v Google pripravljen na to. In bilo je, res, An naključno programsko napako, ampak to je vstopil precej lore, odkar. 

To je vse zabavno in srčkan. Bolj grozljivo je, ko dejansko realnih naprave, in ne igre, so te iste napake. V resnici, le leto dni članek prišel izvedeti o Boeing 787 Dreamliner. 

In članek na prvi pogled bere malo Arcane. Vendar je to rekel, programska oprema ranljivost v Boeing je Novi 787 Dreamliner jet je potencial, da povzroči pilote izgubite nadzor nad zrakoplova, po možnosti v sredi med letom, je FAA uradniki opozorili letalske družbe v zadnjem času. To je bila določitev da je model 787 letalo, ki je bila sinteza neprekinjeno 248 dni lahko izgubijo vso izmenični tok, AC, električne energije zaradi generator kontrolne enote, GCUs, hkrati dogaja v ne varen način. To je nekako mi izgubili. Toda memo navedel, OK, zdaj sem prišel, da pogoj je bila povzročena s programsko opremo proti notranji nadzor generator enote, ki bo prelivna po 248 dni neprekinjene moči. Mi smo to izdajo opazili, da se prepreči izguba vse AC električne moč, kar bi lahko povzročilo izgubo nadzora nad letalom. 

Torej, dobesedno, je nekaj celo, ali kakšno enakovredno vrsto podatkov, se uporabljajo v programski opremi v letalu da če boste obdržali vaše letalo dovolj dolgo, kar očitno se lahko zgodi, če ste samo vožnjo jih nenehno in nikoli ne izvlečete vaše letalo, se zdi, ali najem njegove baterije umre, bo sčasoma prešteti, in navzdol, in gor in gor in gor in gor. 

In, ki jih narava, končna količina pomnilnika se preliva, valjanje nazaj nič ali nekaj negativno vrednost, stranski učinek, ki je strašljivo resnična resničnost da bi morali letalo da se bo ponovno zagnal, učinkovito, ali lahko pade, še slabše, saj leti. Torej te vrste vprašanj so še vedno z nami, even-- to je bilo 2015 članek, toliko bolj zastrašujoče ko ne nujno razumeti, ceniti, ali predvideti te vrste napak. 

Tako se izkaže, da je ena Slaba stvar predstavitev podatkov. Izkazalo se je, da so celo plava nekako pomanjkljiv, ker plovci, preveč, Predlagal sem se 32 bitov ali morda 64, če uporabljate dvojna. Ampak to je še vedno omejena. 

In ulov je, da če lahko dal neskončno število številk decimalno vejico, ne obstaja način, kako more predstavljati vsi možni številke, ki so nas učili V razredu lahko šola obstaja na svetu. Računalnik, v bistvu, je izberite podskupino teh številk natančno predstavljati. 

Sedaj lahko računalnik krog morda malo, in vam omogočajo, da približno trgovini poljubno število morda morda želeli. Ampak samo intuitivno, če vas imajo končno število bitov, jih lahko permutiranje le v toliko končnih načinov. Tako da ne more uporabljajo končno število za permutacije bitov, vzorci ničel in enic, da predstavlja neskončno število številk, kar kaže, da računalniki morda Zelo dobro je včasih laže nam. 

V bistvu, kaj je to. Naj gre nazaj v CS50 IDE. Naj gredo naprej in ustvariti malo programa imenuje nenatančnost, ki kažejo, da računalniki so dejansko nenatančen. 

In mi gredo naprej in začeti z nekaj te kode od prej, in zdaj pač naslednje. Naj gredo naprej in narediti printf, odstotka f, poševnica nazaj n, 1 deljeno z 10. Z drugimi besedami, kaj je potopite globlje 1/10, kot je 1 in delijo z 10. Seveda, lahko računalnik predstavlja 1/10. 

Torej, gremo naprej in da nenatančnosti. Pa poglejmo. Format določa tip double. Toda argument je tipa int. Kaj se dogaja? 

Oh, zanimiva, tako da je izkušnja od prej. Pravim, hej, računalnik oddaja me plovec z odstotnim f. Ampak jaz sem ji dala 2 ints. Tako se je izkazalo, da lahko popravim To v nekaj načinov. 

Lahko bi šele nato enega v 1,0, in 10 na 10,0, kar bi, seveda, imeti za posledico pretvorbo jih v floats-- še vedno upam, da enako število. Ali pa se izkaže, da je nekaj bomo spet videli kmalu. Lahko odda številke. 

Lahko, z uporabo te oklepajni izraz, lahko rečemo, hej, računalnik, bo to 10, kar vem, je int. Ampak to zdravljenje, prosim, kot da je plovec. Toda ta občutek po nepotrebnem zapletena. 

Za naše namene je danes, kaj je samo dobesedno Naj jim plavajočo vejico z decimalno vejico, kot je ta. Naj gredo naprej in ponovitev, da nenatančnost, dobro, pika poševnica nenatančnost, vnesite. OK, iščemo dobro. 

1 deljeno z 10, po moji Mac tukaj, je, seveda, 0,100000. Zdaj pa sem učil v osnovni šoli je mora biti neskončno število 0-ih. Tako da je vsaj poskusiti videti nekatere od teh. Izkazalo se je, da je printf malo Ljubitelj še vedno, kot smo jih uporabljali. Izkazalo se je, da vam ni treba navesti Samo odstotkov f, ali pa samo odstotka i. Lahko dejansko določiti nekateri kontrolni možnosti tukaj. 

Natančneje, bom reči, hej, printf, dejansko pokaži mi 10 decimalnih mest. Tako da izgleda malo čudno. Ampak praviš odstotkov, pika, koliko številke želite videti po decimalno vejico, nato pa f za stanovanje, samo zato, ker je to kakšna dokumentacija pravi. Naj gredo naprej in rešiti da. 

In opazil tudi, sem že utrujeni od ponovnega pisanja stvari. Tako da sem samo nastavitev gor in dol na moje ključe tukaj. In če bom vedno udaril, ti vidim vse ukaze da sem se, ali nepravilno mrežo. 

In bom, da gredo naprej zdaj in dejansko ne uporabljajo, da je očitno. Poskrbite, nenatančnost, pika poševnica imprecision-- tako kar sem učil v Šola preveri ven. Tudi če bi ga natisnete do 10 decimalko ga postavi, res, je 0,10000. Ampak veš kaj? 

Pojdimo malo požrešen. Recimo, kot je, mi pokaži 55 poudarja po decimalko. Oglejmo res da to programirati ven za spin. Naj remake z znamko nenatančnost, pika poševnica, nenatančnost. 

In gremo. Vaše otroštvo je bilo laž. Očitno je 1 deljeno z 10 je dejansko 0.100000000000000005551115123-- 

Kaj se dogaja? No, se je izkazalo, če nekako videti dovolj daleč v osnovni upodobitev tega številka, dejansko ni ravno 1/10, ali 0,1 in neskončno število ničel. Zdaj, zakaj je to? 

Torej, čeprav je to enostavno Številka za nas ljudi, 1 deljeno z 10, je še vedno ena izmed neskončno mnogo številke, ki bi lahko izmisliti. Vendar računalnik lahko predstavlja le finitely veliko tako številke. In tako učinkovito, kaj je Računalnik je pokazal nam je njena najbližja približevanje števila želimo, da verjamejo, da je 1/10, ali res 0,10000 ad infinitum. 

Prej, čeprav je to tako blizu, kot lahko dobite. In res, če pogledaš pod pokrovom, kot smo tukaj z iskanjem 55 številk po decimalko, bomo dejansko videli, da je realnost. Zdaj kot prahi, če ste kdaj videl movie-- večina od vas verjetno haven't-- vendar pred Superman 3 leti, Richard Pryor bistvu vzvodom to realnost v njegovi družbi ukrasti veliko frakcij in delih penijev, ker je company-- kot se spomnim, to je bilo while-- je v bistvu vrgel proč vse, kar ni ustrezalo v pojem centov. 

Ampak, če dodate do vseh teh drobne, majhne, ​​drobne spet številke, in spet, in spet, lahko, kot v njegov primer, da dober znesek denarja. 

Istega zamisel je odtrgali s novejši, vendar še zdaj starejši Film, ki se imenuje Office Space, kjer so fantje v tem filmu, storil isto stvar, je zasrala v celoti, se je končal s tako preveč denar na njegov bančni račun. Vse je bilo zelo sumljivo. Vendar ob koncu dneva, nenatančnost je povsod okoli nas. 

In da je tudi mogoče strašljivo zadevo. Izkazalo se je, da je Superman 3 in Office Space stran, tam more biti nekaj zelo resnična svetovne posledice od realnosti nenatančen predstavitev podatkov da tudi mi ljudje do ta dan ne nujno razumeti kot bi morali, ali pa se spomnimo tako pogosto, kot bi se morali. In res, naslednji posnetek je s pogledom na neki zelo resničnem svetu Posledice, kaj se zgodi, če ti ne cenijo nenatančnosti, ki se lahko zgodi pri zastopanju številk. 

[VIDEO PREDVAJANJE] 

-Computers, Smo vsi prišli do sprejema so pogosto frustrirajuće težave, ki iti z them-- hroščev, virusi, in programske opreme glitches, za majhne cene za plačilo za udobje. Toda v visokotehnoloških in visoke hitrosti vojaških in prostor programske aplikacije, najmanjša lahko problem se poveča v katastrofo. 

4. junija 1996, pripravili znanstveniki za začetek brez posadke Ariane 5 raketa. To je nosil znanstvena sateliti zasnovan določiti natančno, kako združljiva magnetnega polja Zemlji s solarnimi vetrovi. Raketa je bila zgrajena Evropska vesoljska agencija, in dvignjen od njegovega objekta na obali Francoske Gvajane. 

-Na Približno 37 sekund v let, so najprej opazil, kaj je bilo narobe. Šobe so vrtljiva v način, da res ne bi smeli. Okoli 40 sekund v letalu, jasno je, da je bilo vozilo v težavah. 

In to je, ko so naredili odločitev, da jo uniči. varnostni uradnik za območje, s ogromno poguma, pritisnil na gumb, razneslo raketo, preden se lahko postal nevarnost za javno varnost. 

-To Je bila devica potovanje z Ariane 5. In njegovo uničenje je kraj zaradi napako vgrajeni v programsko opremo Raketin. -V Problem na Ariane je da je bilo število, zahteva 64 bitov, da izrazijo. In so želeli spremeniti je za 16-bitno številko. Domnevali so, da je število se je nikoli ne bo zelo velik, da je večina tistih številke v 64-bitno številko bili ničle. Da je bilo narobe. 

-V Nesposobnost ene program za sprejem vrsta števila ustvari druga pa je bila vzrok za neuspeh. Razvoj programske opreme je postal zelo drag del nove tehnologije. Raketa Ariane so bili zelo uspešna, toliko programske opreme ustvarjena za to je tudi uporablja v Ariane 5. 

-V Osnovni problem je, da je Ariane 5 je bil hitrejši, pospešen hitreje. In programske opreme ni imel predstavljali, da. 

-V Uničenje rakete je bila velika finančna katastrofa, Vse zaradi napake na minuto programske opreme. Vendar to ni bil prvi Težave pretvorbe podatkov čas je pestijo sodobne raketno tehnologijo. 

-v 1991, s pričetkom v prvi zalivski vojni, Patriot raketne doživela podobno vrsto problem številka konverzije. In kot rezultat, 28 ljudi, 28 ameriških vojakov, je bilo ubitih, in o 100 drugih ranjenih, ko Patriot, ki naj za zaščito pred prihajajoče rakete Scud, ni na ogenj izstrelkov. 

Kdaj Irak napadel Kuvajt in Ameriko začela Desert Storm v začetku leta 1991, so razporejene Patriot izstrelkov baterije za zaščito Savdsko Arabijo in Izrael iraških raketnih napadov Oblaki. Patriot je v ZDA srednje območje površina za zračni sistem, izdelan ki jih podjetje Raytheon. 

-V Velikost Patriot prestreznik Sam je dolga približno približno 20 metrov. In tehta približno 2000 kilogramov. In to nosi bojno glavo okoli, Mislim, da je približno 150 funtov. In bojno glavo sama visoko eksplozivne, ki ima delci okoli njega. Ohišje bombo je zasnovan tako, da delujejo kot buckshot. 

-da Rakete izvajajo štiri na posodi in se prenaša po pol prikolico. 

-V Patriot protiraketni sistem sega zdaj vsaj 20 let. Je bila prvotno namenjena kot obrambni projektil zraka sestrelili sovražnik letal. V prvi zalivski vojni, ko je prišel, da je vojna s seboj, Vojska je želel, da ga uporabi za sestrelili rakete Scud, ne letal. 

Iraški Air Force je ne toliko problem. Toda vojska skrbelo rakete Scud. In tako so poskušali nadgraditi Patriot. 

-Intercepting Sovražnika projektil potuje Mach 5 je, da bo dovolj izziv. Toda, ko Patriot je planila v službi, vojska ni vedela Iraški sprememba, ki je njihove rakete Scud skoraj nemogoče zadeti. 

Kaj se je zgodilo, so rakete Scud da so prihajali v bile nestabilne. Bili so wobbling. Razlog za to je Iračani, v red da bi dobili 600 kilometrov od 300 kilometer Razpon projektil, je teža iz sprednje bojno glavo. Naredili so bojne glave vžigalnik. 

Sedaj je Patriot je poskušam priti na Oblaki. In večino časa, Velika večina časa, da bi samo letenje, ki jih Oblaki. Ko sistemskih operaterjev Patriot realiziran Patriot zgrešil svoj cilj, pa eksplodirajo Patriot je bojno glavo da bi se izognili morebitnim žrtev, če je pustimo, da pade na tla. 

-To Je tisto, kar večina ljudi je videlo, tiste velike fireballs na nebu, in napačno razumljen kot prestreže v Oblaki konic. 

-Although V noči nebo, pojavil Patriots da bo uspešno uničuje rakete Scud na Dhahran, ne more biti nobenega napaka o njeni uspešnosti. Tam, radarski sistem Patriot izgubila sled dohodni Oblaki, in nikoli ni začela zaradi za programsko opremo pomanjkljivost. To je bil Izraelci, ki je prvi odkril da je več sistem on, večja čas neskladje postal zaradi uro vgrajenih V računalniku sistema. 

-O Dva tedna pred tragedija v Dhahran, Izraelci poročali, da obrambno ministrstvo da je bil sistem izgublja časa. Po približno osmih urah ali delovanje, so opazili, da je sistem je postala opazno manj natančna. Obrambno ministrstvo odzvala z povedal vse baterije Patriot ne pusti sistemov o za dolgo časa. Oni nikoli rekel kaj dolgo časa was-- osem ur, 10 ur, 1000 ur. Nihče ni vedel. 

-V Patriot baterije nameščene na vojašnici na Dhahran in njegovo neustrezno notranje Ura je bila več kot 100 ur v noči na 25. februar. 

bager -To čas z natančnostjo približno desetinko sekunde. Zdaj, desetinko sekunde je zanimiva številka, saj ne more biti izražena v binarni natančno, kar pomeni, da ne more biti izražena natančno V vsaki sodobni digitalni računalnik. To je težko verjeti. 

Toda ta način uporabljajo kot primer. Vzemimo številka ena tretjina. Ena tretjina ne more biti izraženo v decimalni natančno. Ena tretjina je 0,333 dogaja v neskončnost. 

Ni načina, da to, da z absolutna natančnost na decimalke. To je točno to vrsto problema kar se je zgodilo v Patriot. Dlje sistem tekel je slabše je postala napaka čas. 

-Po 100 urah delovanja se je Napaka v času je bila le približno ena tretjina sekunde. Ampak v smislu ciljanje projektil potuje Mach 5, je povzročilo sledenje Napaka več kot 600 metrov. To bi bila usodna napaka za vojake na kaj zgodilo se začela Scud je bil zazna prvih satelitov opozarjanja in so vedeli, da je Scud ki prihajajo v njihov splošni smeri. Niso vedeli, kje je prišel. 

-To Je sedaj do radarja komponenta sistema Patriot brani Dhahran najti in obdržati steza na dohodne sovražnik izstrelkov. 

-V Radar je bil zelo pameten. To bi dejansko slediti položaj Oblaki, in napovedujejo, kjer verjetno bo naslednjič, ko radarska poslala pulz ven. To je bil imenovan vrsto vrata. 

-Potem, Ko Patriot odloči, dovolj časa je opravil, da se vrnete in preverite naslednji lokacija za to zaznani predmet, gre nazaj. Torej, ko se je vrnil v napačno mesto, potem ne vidi nobenega predmeta. In če se odloči, da ni bilo objekt, je bilo lažno zaznavanje, in pade na stezo. 

-V Dohodni Scud izginil iz radarskega zaslona. In sekund kasneje, je trčil v vojašnice. Scud ubitih 28, je bil zadnji ena odpustili med prvo zalivsko vojno. 

Tragično je, posodobljeno programsko opremo prispel na Dhahran naslednji dan. Napaka programske opreme je imel bil določen, zapiranje eno poglavje v težavah Zgodovina Patriot raket. 

[VIDEO PREDVAJANJE] DAVID J. Malan: Torej, to je vse, da bi pravijo, da teh vprašanj prelivom in nenatančnost so vse preveč resnično. Torej, kako smo tu? Začeli smo s samo govorimo o printf. Tudi ta funkcija natisne nekaj na zaslonu, in smo uvedli pozneje nekaj drugih funkcij Iz tako imenovanega knjižnice CS50 je. In bomo še naprej glej ti pravočasno. In mi, še posebej, ki se uporablja get niz, in dobili int, in zdaj tudi dobili float, in še drugi, še vedno bomo naleteli in uporabiti sami kmalu. 

Ampak včasih, imajo smo že videli potrebo za shranjevanje, kaj te funkcije roko nazaj? Oni izročiti nas zadnji niz, ali int ali plovec. In včasih moramo postaviti, da niz, ali int ali float, nekje. 

In za shranjevanje teh stvari, se spomni samo kot v Scratch, imamo spremenljivke. Toda za razliko od nič, V C smo dejanske vrste od variables-- podatkov vrste, več generally-- med njimi, niz, int, A float, in ti drugi še vedno. 

In tako, ko izjavljamo spremenljivke v C, bomo morali prijaviti svoje vrste podatkov. To ni nekaj, kar bom storiti kasneje v semestru kot smo prehod v druge jezike. Ampak za zdaj, ne potrebujemo da a priori vnaprej, razložiti z računalnikom, kaj tip spremenljivke želimo, da bi nas. 

Zdaj, medtem, tiskanje tiste vrste podatkovnih tipov, moramo povedati, printf, kaj naj pričakujem. In smo videli odstotkov ov za godala, in odstotek i za cela števila, in nekaj je že drugi. In to so samo zahteve za vizualno predstavitev teh informacij. 

In vsak od teh lahko dejansko parametriziramo ali tweaked na nek način, Če želite nadaljnje nadzor tip proizvodnje, da boste dobili. In v resnici, se izkaže, da ni le obstaja poševnica nazaj n za novo linijo. Še nekaj se imenuje poševnica nazaj r za enter, ki bolj spominja na stara šola pisalni stroj, in tudi Windows uporablja že vrsto let. 

Tam je poševnica nazaj t za kartice. Izkazalo se je, da če hočeš dvojni narekovaj znotraj niza, odpoklic, ki smo jih uporablja double double quote quote na levi in ​​desni strani koncih naše strune doslej. Tako se zdi, da motila. 

Če želite, da dvojni narekovaj v Sredi string-- in, seveda, je zmedeno videti. In tako boste morali pobegniti, da bi govorijo, dvojni citat z nečim kot je, dobesedno, poševnica nazaj dvojno ponudbo. In tu je še nekaj drugega. In bomo videli več od tistih, v dejanski uporabi pred dolgo. 

Torej, kaj je zdaj prehod iz podatkov, in zastopanje, in aritmetične izvajalci, vsi katerega nam je dal neko stavbo bloki, s katerimi se igra. Ampak zdaj pa je dejansko dal nam ostali besednjaku da smo že imeli prejšnji teden z Scratch tako, da pogled na nekatere druge konstrukti v C- ne vse od njih. Toda ideje smo nadeja res samo poudariti prevod iz en jezik, Scratch, v drugo, C. 

In čez čas, bomo dvignili več orodij za naše orodij, tako rekoč, sintaktično. In, seveda, boste videli, da so ideje so zdaj precej pozna iz prejšnjega tedna. Torej, kaj je to. 

Gremo naprej in bič gor program da dejansko uporablja nekatere izraze, logično izraz. Naj gredo naprej tukaj in ustvariti novo datoteko. Poklical bom to condition.c. 

Naj gredo naprej in vključujejo knjižnico CS50. In mi gredo naprej in vključujejo Standard IO.h za naše funkcije, in printf in bolj oz. Naj dam to boilerplate za int main praznina, ki razlaga, da bomo vrnil v prihodnosti. 

Zdaj pa mi gredo naprej in da sam int preko get int. Potem pa me je iti naprej in to. Hočem reči, če i less-- dovolimo razlikovati med pozitivno, negativno, ali nič vrednosti. 

Torej, če i je manj kot nič, pusti me samo še ta program preprosto reči, negativen, poševnica nazaj n, ostalo če i je večja od nič. Sedaj sem seveda reči printf pozitivno, poševnice nazaj n. In potem še if-- sem lahko to naredil. 

Lahko bi naredil, če sem enak 0. Ampak sem se kar na Vsaj ena napaka že. Spomnimo se, da je enačaj ni enako, kot smo ljudje vedeli. 

Ampak to je upravljavec naloga. In ne želimo, da se 0 na desno in ga v i na levi strani. Tako bi se izognili te zmede, ali morda zloraba enačaj, ljudje odločili, pred nekaj leti da v številnih programskih jezikih če želite preveriti za enakost med levo in desno, ste dejansko uporabili enaka Rezultat. Torej, ste zadeli v enačajem dvakrat. Ko želite dodeliti iz desne proti levi, uporabljate eno enačaj. Torej, kar lahko storimo this-- ostalo če sem enaka enaka nič. 

Lahko bi potem šel in Odprem zavite oklepaje, in pravijo, printf 0, poševnica nazaj n, storjeno. Ampak zapomni si, kako te vilice v cestnem prometu lahko delo. In, res, samo pomislite logike. i je številka. To je število, posebej. In to pomeni, da se dogaja, da je manj kot 0 ali več kot 0 ali 0. Tako da je nekako to implicitno privzeto tako. 

In tako bi lahko, tako kot Scratch, odpravijo z else if, in samo reči drugega. Logično je, da če vam programer vedeti, da je le Tri žlice v katerem scenarij fall-- prvi, druga ali tretja V case-- to ne ukvarjati z dodajanjem dodatne natančnost in dodatno logika tam. Samo pojdi naprej s privzeto tem primeru od drugega. 

Zdaj pa gremo naprej Po shranjevanju to, da Pogoji dot poševnica conditions-- ni veliko uporabniški vmesnik, ker nisem narekujejo uporabnik, kot sem že prej omenil. Ampak to je v redu. Bomo bo enostavno. Poskusimo številko 42. In to je pozitivno. Poskusimo številko negativno 42, negativni. 

Poskusimo vrednost 0. In, seveda, da deluje. Zdaj, boste videli s težavami pred dolge, testiranje stvari trikrat, Verjetno ne zadošča. Verjetno ste želeli preizkusiti nekatere Večje število nekatere manjše številke, nekatere kotiček primeri, kot je bomo prišli, da jih opisali. 

Vendar za zdaj, to je zelo preprost program. In sem prepričan, logično, da pade v treh primerih. In, seveda, čeprav smo samo osredotočila na morebitne slabosti nenatančen in preliva v realnost, kjer je veliko težav CS50 je, mi ne bo treba skrbeti o, ves čas, ta vprašanja prelivom in nenatančnost, saj je v resnici, v C, da je dejansko ni vse, enostavno bi se izognili te stvari. Če želite prešteti večji in večji in večji, se izkaže, da so vas tehnike Lahko uporabite, ki pogosto vključujejo stvari, imenovane knjižnice, zbirke kode, da druge ljudi, je zapisal, da ga lahko uporabite, in druge jezike, kot Java in drugi, dejansko bi bilo veliko lažje računati še višje. Torej, res je nekatere od teh nevarnosti odvisne od jezika, ki ga uporabljate. In v prihodnjih tednih bomo videli, kako nevarno C res lahko, če ga ne uporablja pravilno. Toda od tam, in z Python in JavaScript bo smo plast na nekatere dodatne zaščite, in vodijo manj teh tveganj. 

Torej, kaj je, da malo bolj Zanimiva logika v našem programu. Zato naj gredo naprej in ustvariti program, imenovan Logična samo zato, da lahko igram z nekaterimi Dejanska logika, logical.c. Bom samo kopirajte in prilepite nekaj koda od prej, tako da sem dobil nazaj za to lepo izhodišče. 

Naj mi tokrat naredil char C. Jaz sem dogaja, da to ime C samo zato, ker je to običajna, dobili znak od uporabnika. In kaj je pretvarjati, da Sem izvedbenih del te Rm programa je odstraniti Program pred tem pozove uporabnika odstraniti datoteko. Kako bi lahko to naredila? 

Hočem reči, če je C enak enaka, citiram konec citata, y, potem pa grem, da prevzame da je uporabnik izbral ja. Jaz sem le, da bo tiskanje ja. Če bi bili dejansko pisanje program odstranitev, bomo mogli odstraniti datoteke z več vrstic kode. Vendar bomo bo enostavno. 

Else if c enaka enaka N- in tukaj, vam bom povedal, Uporabnik mora imeti pomenilo št. In potem pa, veste kaj? Ne vem, kaj Uporabnik bo tip. Tako da sem samo reči, da je da je napaka, ne glede na on ali ona dejansko vnesli. 

Torej, kaj se dogaja? Obstaja bistvena razlika v primerjavi s tisto, kar sem naredil v preteklosti. Dvojni narekovaji, dvojni narekovaji, dvojni citati, in še eno osebo, citati, enojni narekovaji. Izkazalo se je v C, da se pri želite napisati niz, vam uporabite dvojne narekovaje, tako kot smo jih uporabljali ves ta čas z printf. 

Toda, če želite, da se ukvarjajo s samo en znak, tako imenovani char, potem dejansko uporabo enojne narekovaje. Tisti, ki ste že programirana prej, morda nimate moral skrbeti za to Razlika v določenih jezikih. V C, to ne zadeva. In tako, ko sem dobil char in želim za primerjavo, da je char uporabo pogoja je enako enaka do neke pisma kot y ali n, jaz, res, morajo imeti enojne narekovaje. 

Zdaj pa gremo naprej in to. Gremo naprej in ne predstavljajo logične dot poševnica logično. In zdaj sem potrditvi. Torej, verjetno, boljšo uporabniško izkušnjo bi mi dejansko pove, kaj storiti tukaj. Ampak bom le slepo pravijo, y za ja, v redu, lepo. 

Kaj je to spet teči, n za ne, lepo. Recimo tako kot nekatere ljudi, ki jih poznam, moje Caps Lock je na vse prepogosto. Zato sem naredil kapitala Y, vstop, napako. OK, to ni ravno tisto, kar sem pričakoval. Dejansko je računalnik počne dobesedno kaj je rekel, da do-- preverjanje male črke y in male črke n. To ne počutim kot dobro uporabniška izkušnja, čeprav. Naj vprašam in sprejemanje bodisi z malimi črkami ali velikimi črkami. Tako se je izkazalo, boste morda želeli reči nekaj podobnega v Scratch, kot dobesedno ali C enaka enako kapitalsko sam citiran y. Izkazalo se je, C nima to dobesedno ključno besedo ali. 

Vendar pa imajo dve navpični palici. Moraš imeti Shift običajno, Če uporabljate ameriško tipkovnico, in dvignil navpično črto Ključ nad vrnitvi ključa. Toda to navpična vrstica navpična vrstica pomeni ali. 

Če, nasprotno, smo želeli reči in, kot v nič, kar lahko storimo ampersand 'znak. To nima nobenega logičnega smisla tukaj, saj človek ne bi morebiti so vnesli obe y in male črke y in kapitala Y kot enak značaj. Torej, ali je tisto, kar bomo tukaj. 

Torej, če bi to naredili v obeh mestih, ali c enako je enak kapital N, zdaj ponovi, make logično, ponovite logično. Sedaj lahko vnesete y. In lahko še enkrat z kapitala Y, ali kapitala N. In lahko dodam v dodatni kombinacije še. 

Torej, to je logična Program kolikor zdaj Jaz preverjanje logično za Ta vrednost ali ta vrednost. In mi ne bi bilo treba nujno, prišli do dva več investicijskih skladov, ali drugje-jev. Lahko dejansko združujejo nekatere izmed povezane logiko skupaj na ta način. Torej to ne bi bilo bolje namenjen zgolj rekel, če je C enak malo črko y, tiskanje ja, sicer, če c enaka kapitala Y, tiskanje ja, sicer, če c enaka lower-- z drugimi besedami, vam ni treba imeti več veje. Lahko združite ekvivalenta veje logično, so na ta način. 

Tako da je lahko pogled na samo eno Končni sestavino, ena končni konstrukt, da C omogoča. In se bomo vrnili v Prihodnost drugim še vedno. In potem bomo skleniti z iskanjem temperaturo pravilnost code-- dobili kodo work--, vendar se načrt kode in posadili tiste semena že na začetku. 

Zato naj gredo naprej in odpreti novo datoteko tukaj. Veš kaj? Bom ponovno izvajati da isti program, vendar z drugačnim konstrukt. 

Torej, mi naj hitro dal sam dostop do vključiti CS50.h Za knjižnice CS50, Standard Io.h za printf. Daj mi moj int glavni praznino. In potem sem, kaj grem naprej in to. 

Char c dobi dobili char, tako kot prej. In bom uporabiti nov konstrukt now-- stikalo, na kakšen značaj? Tako stikalo je nekako kot preklapljanje vlaku skladbe. Ali pa res, da je vrsta if drugega, če drugega, če vendar napisana nekoliko drugače. 

Stikalo izgleda takole. Imate stikalo, in nato, kaj znak ali številko, ki jo želite pogledati, potem nekateri zaviti oklepaji kot v Scratch, samo reči narediti te stvari. In potem imate različne primere. 

Saj ne uporabljajte, če in drugje. Dobesedno uporabiti primer besedo. In bi rekli kaj takega. 

Torej, v primeru malimi črkami y, ali v primeru Y kapitala, gredo naprej in natisniti ja. In potem izbruhnejo stikala. To je to. Končali smo. 

Else, če se tako izrazim, male črke n, ali kapitala N, potem pa pojdi naprej in tiskanje ven no, nato pa prekinil. Else-- in ta vrsta je privzeto primeru indeed-- printf error-- in samo za dober ukrep, čeprav logično je ta odmor ni potreben zato, ker smo na koncu stikala vseeno, Zdaj sem rešil iz stikala. Torej, to izgleda malo drugače. 

Ampak, je logično, da je dejansko enakovredni. In zakaj bi uporabili eden na drugega? Včasih, samo osebne preference, včasih estetika, Če pogledam na to Zdaj, nekaj treba povedati, da berljivost te kode. Mislim, ne moti dejstvo, da je to koda je novo, da mnogi od nas v sobi. 

Ampak to samo vrsta je precej. Vidiš male y, kapitala Y, male črke n, kapital N privzeto, je le nekako skoči v vas na način, da je verjetno, morda prejšnji primer z investicijskih skladov, vertikalne palice, in else-jev, morda ni. Torej je to res stvar osebne izbira, res, ali berljivost, kode. 

Toda v smislu funkcionalnosti, naj me iti naprej in narediti stikalo, dot poševnica stikalo, zdaj pa tip v male črke y, kapital Y, male črke n, kapital N, David, poskusite znova, saj je to ni en sam znak. Naredimo x, napake, kot je bilo pričakovano. In logically-- in to je nekaj Jaz bi spodbudila v general-- celo čeprav smo le praskanje Površina nekatere od teh funkcij. 

In ne bi bilo očitno, ko vas sami sedli na tipkovnici, kako to deluje? Kaj bi to naredili? Lepa stvar ima prenosnik ali namizni ali dostop z računalnikom prevajalnik, in z urejevalnikom kode, kot je ta, se lahko skoraj vedno odgovoriti na to vprašanja za sebe samo s poskušanjem. 

Na primer, če je retorično vprašanje pri roki so bili, kaj se zgodi, če ste pozabili svoje izjave odmor? Ki je pravzaprav zelo pogosta stvar, ker ne izgleda kot si ti res jih potrebujete. Ti res ne izpolni svoj Mislil kot oklepaju ali Curly brace ne. Gremo naprej in prevesti kodo in videli. Torej bi stikalo, pika poševnica stikalo. Kaj je tip v male črke y, zgornji primer, Enter. Torej sem tipkal y. 

Program je dejal, da, ne, napake, kot da se je spremenilo njeno srce. Ampak to nekako bilo, ker tisto, kar se zgodi s stikalom je prvi primer, da je Tekma se je v bistvu pomeni, hej računalnik, izvesti vse kode pod njo. In če ne boste rekli, break, ali Ne pravim, odmor, ali pa ne reči odmor, računalnik se bo razstrelil skozi vse te linije in izvesti vse od njih, dokler pride do tega kodraste brace. Torej, zavore so seveda potrebni. Toda takeaway tukaj je, ko v dvomih, preizkusite nekaj. Mogoče shraniti kodo prvič, ali ga shranite v dodatno datoteko Če ste res v skrbeh zajebavam in ima za izterjavo delo, ki veste, da deluje. 

Toda poskusiti stvari. In ne bodi tako strah, morda, o tem, kaj bi lahko računalnik storiti, ali da bi lahko prekinil nekaj. Vedno se lahko vrne nazaj do neke prejšnje različice. 

Tako da je na koncu z iskanjem pri oblikovanju kodeksa. Imamo to sposobnost sedaj pisati Pogoji in pisanje zank, in spremenljivke, in klic funkcije. Torej, odkrito povedano, smo nekako nazaj kjer smo bili pred enim tednom z Scratch, čeprav z manj prepričljiv besedilnih okolje kot Scratch omogoča. 

Ampak obvestilo, kako hitro smo pridobili da besednjak, tudi če je bo trajalo nekaj časa, da se potopi v, tako da bomo lahko sedaj uporabljajo to besednjak pisati bolj zanimive programe. In kaj je narediti korak otroka v smeri, kot sledi. Naj gredo naprej in ustvarite novo datoteko tukaj. 

Bom ta poziv prototype.c, in uvesti prvič, zmožnost da svoje funkcije. Nekateri od vas morda to naredil z Scratch, s katerim lahko ustvarite svoj lastni meri bloki v nič, in jih nato povlecite na mesto kamorkoli želite v C. In v večini programiranje jeziki, ki jih lahko naredite točno that-- da svoje funkcije, če se že ne obstaja. 

Tako, na primer, naj gredo naprej in vključujejo CS50.h in vključujejo standardna IO.h, int main nična. In zdaj imamo ograda pripravljena iti. Držim tiskanje stvari kot so imena ljudi danes. In da se počuti like-- ne bi bilo lepo, če obstaja so funkcijo imenovano ime tisk? Nimam uporabiti printf. Nimam, da se spomnimo vse oznake format. Zakaj ne jaz, in zakaj se ni nekdo pred mano, ustvariti funkcijo imenovano tiskanje ime, da zaradi nekaj ime, enostavno natisne? 

Z drugimi besedami, če rečem, hej, računalnik, daj mi niz s uporanikove za to, preko get niza funkcijo CS50 je. Hej, računalnik, dal, da je niz v spremenljivka na levi strani, in call it to. In potem, hej računalnik, pojdi naprej in natisnete to ime osebe, storjeno. 

Zdaj, da bi bilo lepo, ker ta program, aptly imenovan, mi pove, kaj je to moral storiti s pomočjo imen teh dveh funkcija je. Naj gre in se prototip, Enter. In, žal, to ne bo leteti. 

Prototype.c, vrstica 7, karakter 5 napak, implicitno izjavo function imena tiskanja je neveljaven, C99, C99 pomeni različico C ki je izšel leta 1999. To je vse. 

Torej, ne vem, kaj Vse to pomeni še. Ampak jaz priznati napako v rdeči barvi. To je precej očitno. 

In zdi se, da s zeleni znak tukaj, vprašanje je z imenom tiskanja, odprt paren s, v bližini paren, podpičjem. Toda implicitno izjavo o Funkcija smo na kratko že videli. To pomeni, samo, da je Jek ne veš, kaj mislim. 

Uporabil sem besednjaka besedo, da je nikoli ni videl ali je učil prej. In zato jo moram naučiti kaj pomeni ta funkcija. Tako da sem šel naprej in to. 

Bom, da gredo naprej in izvajanje moja funkcija imenuje Print Name. In bom rekel takole, da To počne, printf, zdravo, odstotka s, poševnica nazaj n, ime, podpičjem. Torej, kaj sem naredil? 

Tako se izkaže, da izvajajo svojo funkcijo, smo nekako sposoditi nekaj enako strukturo kot glavno da smo ravnokar samoumevno, in jaz vem, kopiranje in lepljenje precej, kar Sem pisal v preteklosti. Toda opazili vzorec tukaj. Int, Main, odpade, bomo draži narazen kmalu, kaj to pravzaprav pomeni. 

Toda za danes, samo opazili podobnost. Void, ime s tiskanimi črkami, Ime niz, tako da je vijolična ključne besede, ki bomo za začetek kliče vrsto vrnitvi, ime funkcijo, in nato vhod. Torej, dejansko pa lahko strnili takšna, kot je prejšnji teden kot je to ime ali Algoritem kode smo bo write-- algoritem temelji koda bomo napisali. 

To je vložek. To je njena proizvodnja. Ta funkcija, ime s tiskanimi črkami, je zasnovan tako, da niz z imenom ime, ali karkoli, kot vložek, nato pa nična. To ne vrne ničesar, kot bi dobili niz, ali pa int ne. Tako se dogaja, da mi nekaj vrniti. To je le, da bo imela stranski učinek, tako rekoč, tiskanje ime osebe. Torej opazili, vrstica 7, I lahko pokličete ime tiskanja. Linija 10, lahko določite ali izvajajo ime tiskanja. Ampak, žal, to ni dovolj. 

Naj gredo naprej in prevesti to po shranjevanju. Vau, zdaj, sem ga postavil slabše, se zdi. Torej implicitno izjavo o ime funkcije tiskanja je neveljavna. In še enkrat, tam je več napak. Ampak kot sem opozoril že prej, čeprav Če ste preobremenjeni z, ali pa malo žalostno videti toliko napake, se osredotočajo samo na prvi na začetku, saj bi lahko le so imeli kaskadni učinek. Tako C ali Jek natančneje še vedno ne prepozna imena tiskanja. 

In to zato, ker Jek, z zasnovo, je nekako neumno. To počne samo tisto, kar je povedal, da storiti. In to ne samo tako po vrstnem redu v katerem je povedal, da storiti. 

Torej sem opredeljena glavna na liniji štiri, kot smo počeli precej pogosto. Sem opredeljeno ime za tisk na liniji 10. Ampak sem poskušal uporabiti Ime print na spletu sedem. 

To je prezgodaj, še ne obstaja. Tako sem lahko pameten, in se kot, OK, tako da je samo igra skupaj, in premik ime za tiskanje navzgor tukaj, in ponovno sestaviti. O moj bog. Delovalo je. Bilo je tako enostavno, kot da. 

Toda logika je točno to. Moraš se naučiti Jek, kakšna je je s prvim opredeljuje funkcijo. Potem ga lahko uporabite. Ampak, odkrito povedano, ta meni kot spolzkem terenu. 

Torej, vsakič, ko sem teči v težave, sem samo dogaja, da označite in kopirate kodo Napisal sem, da izrežete in prilepite tukaj. In gotovo, smo lahko Naučiti nekaj scenarijev kjer je ena funkcija morda treba poklicati drugo. In si ne more dati vsak Funkcija nad vsako drugo. 

Tako se izkaže, tam je boljša rešitev. Mi lahko pustite to. In, odkrito povedano, to je običajno lepo, in priročno, in dober design dati glavno prvič, ker, še enkrat, Glavni tako kot pri zelena zastava kliku da je funkcija dobi izvaja privzeto. Tako si lahko tudi dal je na vrhu spisa tako da, ko vi ali katerikoli drugi človek gleda datoteke veš, kaj se dogaja samo z branjem glavni prvi. Tako se je izkazalo, da lahko povem, Jek proaktivno, hej, Jek na liniji štiri, Obljubim, da izvajanje funkcija se imenuje tiskanje Ime, ki je niz se imenuje ime kot vhod in vrne nič, nična. In bom okoli njegovo izvajanje kasneje. 

Prihaja Main. Glavna zdaj na spletu 9 lahko uporabite Tiskanje Ime ker Jek je zaupanje, da je na koncu, da bodo imeli definicijo izvajanja Natisni imena. Torej, po shranjevanju mojo kartoteko, naj grem naprej in da prototip, izgleda dobro tokrat. Dot poševnica, prototip, naj me gredo naprej in vnesite ime. David, zdravo David, Zamila, zdravo Zamila, in, seveda, zdaj deluje. 

Torej je sestavina v tem, da smo jih je funkcijo po meri, kot po meri Scratch blok smo ga kliče. Toda za razliko od Scratch, kjer lahko samo ustvarjanje in začetek uporabe, Zdaj moramo biti malo bolj občutljiv, in dejansko vlak Jek za uporabo, ali pa ga pričakujejo. Zdaj, kot prahi, zakaj ves ta čas smo bili le slepo na veri, vključno CS50.h, in vključno s standardnimi IO.h? 

No, se je izkazalo, Med nekaj drugih stvari, vse, kar je v teh dot h datoteke, ki se zgodi, da se datoteke. Oni header datoteke, tako rekoč. Še vedno napisan v C pa oni drugačen tip datoteke. 

Za zdaj lahko precej prevzame da vse, kar je znotraj CS50.h je približno eno-obloge, kot je ta, ne za funkcije imenovane Print Ime, ampak za Get String, Get Float, in nekaj drugih. In tam so podobni prototipi, ena obloge, znotraj standardne IO.h Za printf, ki je sedaj moje Print Ime funkcijo. Torej, z drugimi besedami, ves ta čas, ki smo jih pravkar slepo kopiranje in lepljenje vključujejo to, vključujejo da, kaj se dogaja? To je le vrsta indicev da Jek, kaj funkcije se dejansko izvaja, samo drugje v različnih datotekah drugje v sistemu. 

Tako smo izvajali ime tiskanja. Da ima ta stranski učinek tiskanje nekaj na zaslonu. Ampak to dejansko ne podaj mi nekaj nazaj. Kako bomo lotili izvajanju programa, ki ne nekaj podaj mi nazaj? 

No, poskusimo to. Naj gredo naprej in izvajati datoteka z imenom return.c tako da bomo lahko dokaže, kako nekaj kot Get String, ali Get Int, pravzaprav vračanje Nekaj ​​nazaj uporabniku. Gremo naprej in določiti int glavni praznino. 

In, še enkrat, v prihodnosti, bomo razložiti, kaj to int in to praznino je pravzaprav počne. Ampak danes, bomo je samo po sebi umevno. Bom, da gredo naprej in printf, za dobro uporabniško izkušnjo, x. In potem bom počakati na Uporabnik, da me x s get notr. 

In potem bom šel naprej in natisnete x na kvadrat. Torej, če imate le tipkovnica, ljudje pogosti uporabite malo korenje Simbol na tipkovnici za zastopanje na moč o, ali eksponent. Torej x kvadrat je prisotna i. 

In zdaj bom to naredil. Jaz lahko samo do-- kaj je x kvadrat? x kvadrat je x-krat x. 

In mi je to naredil nekaj Pred časom že danes. To ne počutim kot vse to velik napredek. Veš kaj? Oglejmo vzvoda nekaj te ideje od zadnjič abstrakcije. 

Ali ne bi bilo lepo, če tam je funkcija imenuje kvadrat, da ne točno to? Še vedno na koncu od dan, počne isto matematike. Ampak kaj je abstraktna stran ideja jemanja ena številka pomnoženo s drugo, in daj mu ime, kot kvadratnih to vrednost. 

In, z drugimi besedami, pri C, kaj je ustvariti funkcijo imenujemo kvadrat, da počne ravno to. To se dogaja, da se imenuje kvadrat. To se dogaja, da se int. In bomo bo samo ga imenujejo n, ki ga privzeto. 

Lahko pa bi rekli, da je vse, kar si želimo. In vse, kar se dogaja, da storiti, dobesedno, je donos rezultat n-kratno n. Ampak ker je vrača nekaj, kar je ključna beseda v vijolično, ki smo jih nikoli videl, sem na liniji 11, Ne moreš kar reči, nična tokrat. 

Nična, v primeru smo pravkar videli namesto imena tiskanja, pomeni le, naredi kaj. Ampak mi nekaj ne vrniti. V tem primeru, jaz želim vrne n-krat n, ali karkoli že to je, da je številka. 

Tako da ne morem reči, hej, računalnik, Vrnem nič, nična. To se dogaja, da se vrnejo, po naravi, int. In da je vse, kar se dogaja. 

Vhod na kvadrat se bo int. In tako, da ga lahko uporabljamo, mora imeti ime, N. To se dogaja, da se izhod int ki ne potrebuje ime. Lahko ga pustimo, da se glavna ali kdo je me uporabljajo, da se spomnimo na to vrednost, če bomo ponudbe s svojo spremenljivko. 

In še enkrat, samo novo Ključna beseda tukaj je Return. In sem samo delaš nekaj matematike. Če bi res želel, da ni potrebno, Lahko bi rekel, int pride proizvod n krat n. 

In potem bi lahko rekli, vrne izdelek. Ampak, še enkrat, na mojem zgodnejšem To preprosto ni dobra design-- kot so, zakaj uvesti ime, simbol, kot je izdelek, samo, da takoj vrne? To je malo čistejši, malo močneje, tako govoriti, samo reči vrnitev n-krat n, znebiti tega področja v celoti. 

In to je samo manj kode, da se glasi, manj možnosti za napake. Da vidimo, če je to dejansko zdaj deluje. Zdaj bom šel naprej in da vrnitev. 

Uh-oh, implicitno izjavo funkcije. Naredil sem to napako pred tem, ni nič takega. Naj samo tip, ali označite in kopiranje, točno isto funkcijo prototip, ali podpis, funkcije se tukaj. Ali sem lahko premakne celotno funkcijo. 

Ampak to je malo leni. Torej ne bomo storili. Sedaj pa mi, da vrnitev spet pika vrnitev poševnice. 

x je 2. x kvadrat je 4. x je 3. x kvadrat je 9. In funkcija se zdi Sedaj je treba delati. Torej, kaj je razlika tu? Imam funkcijo, ki je imenovan trg, v tem primeru, ki sem ga dal na vhodu. In dobim nazaj izhod. In še prej, če Odprem drugi primer iz prej, kar je bil imenovan prototype.c, Imel sem ime tiskanja, ki vrnil nična, tako rekoč, Ali je vrnil nič, in preprosto imela stranske učinke. 

Torej, kaj se dogaja? No, menijo funkcijo dobili niz za trenutek. Mi smo bili z uporabo funkcije dobil niz v naslednji način. 

Smo imeli funkcijo dobili niz, kot vključujejo CS50.h, vključujejo standardno IO.h, int, glavno, praznino. In potem vsakič, ko nimam imenovano get niz doslej Sem rekel nekaj podobnega, niz s dobi dobili niz, saj get string-- recimo to get.c-- get niz sama vrne niz, da sem lahko potem uporabo, in pravijo, zdravo, vejica, odstotkov y, Nagibnica n, y. 

Torej je to isti primer, Res, da smo imeli prej. Tako bi dobili niz vrne vrednost. Toda pred nekaj trenutki, tiskanje niz ne vrne vrednosti. To preprosto ima stranski učinek. Torej, to je bistvena razlika. Videli smo drugačni vrste funkcij zdaj, nekateri, ki so se vrnili Vrednosti, nekateri od njih ne. Mogoče je niz, ali int ali float. Ali pa je samo praznina. 

In razlika je da te funkcije, da je pridobiti podatke in vrne vrednost dejansko prinaša nekaj nazaj k mizi, tako rekoč. Torej, gremo naprej in pogled na enega končnega nabora primerov, ki daje občutek, zdaj, od kako smo lahko, seveda, abstract bolje, in bolje in bolje, ali več, in več in več, da bi pisati, nenazadnje, boljšo kodo. Gremo naprej, in v duhu od Scratch, naredite naslednje. 

Naj gredo naprej in vključujejo CS50.h in standardni IO.h. Naj gredo naprej in da sam int, glavno, nična. In mi daj, to imenujemo cough.c. 

In mi gredo naprej in samo kot Scratch, natisnete kašelj / n. In želim narediti to trikrat. Tako da sem, seveda, šele tekoč kopirati in prilepiti trikrat. Jaz sem zdaj dogaja, da kašelj pik poševnica kašelj. Recimo dam malo več prostora tukaj, Enter, kašelj, kašelj, kašelj. 

Tam je, seveda, že priložnost za izboljšanje. Sem kopirali in prilepili nekajkrat danes. Toda to je bilo le, da nisem morali vnesti čim več znakov. Še vedno spremenila teh vrstic kode so. 

Te tri vrstice so enake, ki meni, leni in res je, in verjetno ni pravi pristop. Torej s tem, kar sestavino bi lahko izboljšali to kodo? Nimamo kopirati in prilepiti kodo. 

In, seveda, kadarkoli se počutite sami kopiranjem in lepljenjem, in celo ne spreminja kode verjetnost, da je boljši način. In res, pa je. Naj gredo naprej in ne za zanke, čeprav sintaksa morda ne pridejo še naravno. 

Ali to trikrat, preprosto s tem, da following-- in sem se zgodi, da to vedo iz prakse. Vendar imamo številne primere zdaj. In boste videli na spletu več referenc še. 

To je sintaksa na liniji 6, ki podobno kot Scratch, ki se ponavlja blok, ponovite naslednje trikrat. To je malo čaroben za zdaj. Toda to bo dobil več, in bolj pozna. 

In da se bo ponovil linija osem trikrat, tako da če bom ponovno zbere make kašelj, dot poševnica kašelj, kašelj, kašelj, kašelj. Še vedno deluje na enak način. Tako, da je vse v redu in prav. Ampak to še ni zelo odvzete. 

To je popolnoma pravilna. Vendar se zdi, kot da lahko priložnost, kot v svetu Praske, na vrsto začetek tukaj dodati nekaj semantiko, tako da Ne samo še nekaj za zanke, in funkcija, ki pravi: kašelj, ali pa kašelj. Veš kaj? Naj poskusim biti malo hladnejše kot to, in dejansko napisati funkcijo, ki ima nekaj stranskih učinkov, call it kašelj. 

In to se ne vhod, in vrne nobene vrednosti kot izhod. Ampak veste, kaj počne? To počne this-- printf, quote citata, kašelj. 

In zdaj tukaj, jaz grem da gredo naprej in za int, i dobi nič, sem manj kot 3, i plus plus. Bom ni storil printf, ki je verjetno izvajanje nizka raven detajl. Ni mi mar, kako kašelj. Samo želim uporabiti funkcijo kašelj. In sem le, da bo poklical kašelj. 

Zdaj, opazili dihotomijo. Ko pokličete funkcijo, če ne želijo, da bi postala vhodi, popolnoma v redu. Pač odprte paren, blizu paren, in ste končali. 

Ko določite funkcijo, ali ugotovi, funkcija je prototip, če veš vnaprej, da to ni bo trajalo vse argumente, pravijo v teh oklepajih tam nična. In to zagotavlja, da bodo ti da ne bo slučajno zlorabe. Naj gredo naprej in da kašlja. In, seveda, sem naredil napako. 

Prekleto, da je to implicitno izjavo. Ampak to je v redu. To je enostavno določiti. Rabim prototip višje v svojem spisu, kot sem dejansko uporabo. 

Torej, zdaj pa mi, da kašelj spet lepo. Zdaj deluje. Poskrbite, kašelj, kašelj, kašelj, kašelj. Torej si lahko mislite, da smo res tik nad inženiring ta problem. In seveda smo. To ni dobra Kandidat programa Trenutno za Refactoring, in to, kar je imenovane hierarhično razpada, kjer ste vzeli nekaj kode, nato pa vi nekako faktorja stvari, ter se tako pripisati več semantiko z njimi, in ponovno ji na koncu daljši rok. Ampak to je gradnik proti bolj zapletene programe da bomo začeli pisno pred dolgo, da nam omogoča, da imajo besedišče s katero pisati boljše kodo. In, seveda, da vidimo, če bomo tega ni mogoče posploševati dlje. 

Zdi se malo hromi, da sem glavni, je treba skrbeti za to jebeno za zanke, in znova in znova kliče kašelj. Zakaj ne morem povedati, kašelj, prosim kašelj trikrat? Z drugimi besedami, zakaj ne morem samo dati prispevek k kašljanju in to stori? 

Zakaj ne morem reči, v Glavni kašelj trikrat. In zdaj, to je nekako čarobno. To je zelo ponavljajoč tukaj. In to je seveda korak otroka. 

Ampak sposobnost povedati o linija osem, kašelj trikrat, to je samo toliko bolj berljiva. In, plus, mi ne bi bilo treba vedeti, ali pa zanima, kako je kašelj izvaja. In, seveda, kasneje v Izraz in končnih projektov, če se lotiti projekta z sošolec ali dve sošolci, boste spoznali, da boš morali, ali želijo, razdeliti delo. 

In boste želeli odločiti vnaprej, kdo bo kaj storil, in v katerem kosov? In ne bi bilo lepo, če ste, na primer, prevzame pisanje glavnega, podpisane. In tvoj sostanovalec, ali vaš partner bolj splošno, skrbi za izvajanje kašelj. 

In ta delitev, ti stene abstrakcije, ali plasti abstrakcije če boste, so super močna, ker zlasti za večje, bolj kompleksni programi in sistemi, omogoča več ljudem, da gradijo stvari skupaj, in na koncu stitch svoje delo skupaj na ta način. Ampak, seveda, smo moramo zdaj popraviti kašelj. Moramo povedati, kašelj da, hej, veš kaj? Vi boste morali sprejeti input-- zato ni nična, vendar int in zdaj. Gremo naprej in začnejo kašelj int. i dobi nič. 

i manj kot kolikokrat. Rekel sem tri prej. Ampak to ni tisto, kar hočem. Želim kašelj, da posplošiti na podpira poljubno število iteracij. 

Torej, res, da je n, da želim, ne glede na uporabniški mi pove. Sedaj lahko grem naprej in reči tiskanja kašelj. In ne glede na to, kaj več uporabnik prehaja v, Bom ponovitev, da veliko krat. 

Tako da ob koncu dneva, Program je enak. Toda opazili vse te stvari lahko celo v drugo datoteko. Pravzaprav ne vem Na Trenutek, kako printf se izvaja. 

Ne vem, v tem trenutku, kako priti niz, ali pa int, ali se plovec se izvajajo. In ne želim, da jih vidite na mojem zaslonu. Kot je, sem začel, da se osredotoči na moj program ne te funkcije. 

In tako, seveda, takoj, ko vas začeti faktoring kodo, kot je tole, lahko bi celo premakniti kašelj v ločeno datoteko? Nekdo drug bi jo izvajati. In vi in ​​vaš program postal zelo lepa in zelo berljiva, verjetno, res štiri Program linija tam. 

Torej, gremo naprej zdaj in še eno spremembo. Opazimo, da je moj prototip je treba spremeniti do vrha. Zato naj se določi, da je tako Jaz ne dobijo vpil na. 

Poskrbite, kašelj, naj enkrat mi teče kašelj Še več, še vedno počne isto stvar. Toda zdaj, opazili smo imeti sestavina za eno končno različico. Veš kaj? Nočem samo kašelj, nujno. Rad bi imel kaj bolj splošno. Torej, veste kaj? Želim, da to storijo. Rad bi imel, podobno kot Scratch zgodi, izraziti svoja blok, vendar ne samo nekaj reči nekaj več časa. Želim opozoriti na to zelo specifično niz. In zato ne vem želijo, da samo reči kašelj. Želim opozoriti na to, kar Niz je sprejet. 

Torej opazil sem generalizirana to tako, da je sedaj recimo počuti kot dobro ime za to, kot nič, traja dve trditvi, za razliko od nič. Ena je niz. Ena je int. 

In sem jih lahko stikalo. Sem nekako všeč zamisel pravijo niz, potem pa kolikokrat kasneje. Void to pomeni še ne vrne ničesar. To so le vizualna plat učinki, kot pri [? Jordan,?] besedni stranski učinek kričati. Še vedno pa je nekaj n-krat, 0 do, vendar ne enako n. To pomeni, n skupno krat. In potem samo natisnete karkoli, da niz je. Tako sem res generalizirana ta vrstica kode. Zdaj, kako izvajati kašelj funkcija? 

Lahko storim nična kašelj. In še vedno traja, kako kolikorkrat želite kašelj. Ampak veš kaj? Sedaj lahko punt reči. 

Lahko pokličete reči z Beseda kašelj, ki poteka v n. In če želim izvajati tudi, samo za zabavo, funkcija kihanje, Lahko kihanje določeno število krat. In sem lahko vodijo ponovne n, ker opazili, da m v ​​zvezi s tem, ali obseg obstaja samo v tej funkciji. 

In n pri tem le obstaja v tej funkciji tukaj. Torej bomo vrnili k ta vprašanja področje. In tukaj sem samo reči, achoo in nato n-krat, podpičjem. 

In zdaj moram samo sposoditi ta funkcija podpisi tukaj. Torej, kašelj je pravilen. Void kihanje je pravilen zdaj. 

In še vedno potrebujejo samo reči. Tako da sem hotel reči, recimo niz s, int n, podpičjem. Tako sem preveč inženirstva vraga iz tega programa. 

In to ne pomeni nujno, da je to kaj morate storiti pri pisanju celo najpreprostejši programov. Vzemi nekaj, kar je seveda zelo enostavno, zelo kratka, in ga ponovno izvajati uporabo tako preveč kodo. Vendar boste dejansko videli in Čas pogled nazaj, na teh primerov, in zavedaš, oh, to so koraki smo dejansko posploševati, proti faktorju nekaj ven, dokler na koncu dneva moja koda je pravzaprav zelo smiselno. Ker če hočem kašelj tri krat potem kihanje trikrat, Jaz preprosto bo ponovila to, Program bo kašelj in vodijo kašelj. In imam tri kašelj in tri kihanjem. 

In tako je to temeljna paradigma, če hočete, kako lahko gremo o dejansko izvajanje programa. Ampak kaj je šele zdaj vidim, kaj je to smo počeli ves ta čas, in kar nekaj končnih kosov so za to preprosto ukaz. Na koncu dneva, ki smo jih uporabljali Jek kot naš prevajalnik. Smo pisali vir Koda, pretvorimo preko Jek v strojno kodo. 

In smo bili z uporabo Poskrbite samo olajšati naše tipkanja tako da nam ni treba zapomniti ti zaklinjanjem o Jek samega. Toda kaj je narediti pravzaprav počne? In, po drugi strani, kar je Jek pravzaprav počne? 

Izkazalo se je, čeprav smo poenostavili današnja razprava z besedami, ste vzeli izvorno kodo, jo prenese kot vhod za prevajalnik, ki vam daje izhod stroja kodo, se izkaže, tam je nekaj različnih korakov znotraj tam. Ter izdelava zgodi, da bo krovna izraz za cel kup korakov. Ampak kaj je samo draži tole res hitro. 

Izkazalo se je, da smo počeli več stvari, vsakič, ko sem prost program, ali vsakič, ko sem sestavil program za danes. Tako predobdelava nanaša this-- ničesar v programu C, saj bomo znova videli, ki se začne s tem simbolom hash, ali hashtag simbol tukaj, pomeni to je direktiva Predprocesor. To pomeni, da v tem primeru, hej računalnik, naredite nekaj s to datoteko preden ste dejansko pripravijo svojo kodo. 

V tem primeru, hašiš vključujejo pomeni, v bistvu način C je rekel, hej računalnik, pojdi na vsebino od CS50.h in jih prilepite tukaj. Hej računalnik, pojdite dobili vsebina standardnega IO.h, kjer je to, da je na trdi disk, ga prilepite tukaj. Torej te stvari se dogajajo Prvi med predobdelavo. 

In Zvoka pa vse to za nas. In to počne tako darn hitro, sploh ne glej štiri različne stvari dogajajo. Ampak to je prvi tak korak. 

Kaj se pravzaprav zgodi potem? No, naslednji uradni korak je zbiranje. In se izkaže, da pripravo programa tehnično pomeni, da se iz izvorna koda, stvari, ki smo jih piše danes, da se nekaj imenuje skupščina kodo, nekaj da izgleda malo drugače. 

In v resnici, lahko videli zelo hitro. Naj dejansko šel v mojo IDE. Naj gredo naprej in odprto hello.c, ki je prvi program, s katerim smo se je začela danes. In mi gredo naprej in zagon Jek a malo drugače, Jek-ov, hello.c, ki je pravzaprav bo daj mi še datotek hello.s. 

In bomo verjetno nikoli ne spet videli te vrste kode. Če ste vzeli nižjo raven Sistemi razreda kot CS61, boste videli veliko več tovrstnega kode. Toda to je zbirni jezik. To je X86 zbirni jezik da CPU, ki temelji CS50 IDE dejansko razume. 

In skrivnosten kot to počne videti, da je nekaj Računalnik razume zelo dobro. Sub q, to ​​je odštevanje. Tam je premiki. 

Tam kliče funkcij tukaj, x oring, gibanje, dodatek, pop, vrnitev. Torej je nekaj zelo Navodila nizki ravni da CPU razumeti, da I omenili prej. To je tisto, Intel Inside. 

Obstajajo vzorci ničle in tiste, ki karto za to arcanely določeno, vendar nekoliko tudi imenovan-, navodila, tako rekoč. To je tisto, kar se zgodi, ko vam pripravijo kodo. Dobiš montaža Jezik iz njega, kar pomeni, da je tretji korak je zbrati da skupščina kodo v končni fazi, stroj code-- ničle in tisti, ne pa besedilo, ki smo pravkar videli pred nekaj trenutki. 

Torej predobdelava ne da najti in zamenjavo, in še nekaj drugih stvari. Prevajanje je svoj vir Koda izmed C izvorna koda da smo pisali, da montažo kodo, ki smo pravkar pogledal. Montaža je ta sklop koda za ničel in enic da CPU res bo razumeli ob koncu dneva. In povezovanje je zadnji korak da se zgodi us-- še enkrat, Tako hitro ne bomo niti notice--, ki pravi, hej računalnik, da vse ničle in tiste, ki posledica pripravo kodo Davidovo, in njegova glavna funkcija v tem primeru. 

In hej računalnik, pojdi vse ničel in enic da osebje CS50 napisal znotraj knjižnici CS50. Zmešamo s tistimi s Davida. In hej računalnik, pojdi na vse ničle in tisti, ki je nekdo drug napisal leta Pred za printf. In dodamo tiste v Vse skupaj, tako da smo jih dobil moje ničle in tiste, The ničle in tisti uslužbenec CS50 je, printf ničle in tisti, in kaj smo uporabljali. 

Vsi so dobili skupaj skupaj v eno program, imenovan, v tem primeru, zdravo. Torej odslej, bomo samo uporabiti besedo prevesti. In se nam zdi samoumevno, da ko rečemo, pripravijo svoj program, to pomeni, hej narediti predobdelavo, montaža in povezovanje. Vendar pa je dejansko nekaj sočno stvari tam dogaja pod pokrovom. In še posebej, če vas dobili nenavadno nekaj časa, lahko začnete pikal približno na tej nižji ravni. Ampak za zdaj, zavedajo, da Med takeaways za danes so precej preprosto začetek procesa, dobili udobno s nekaj podobnega Hello World. Dejansko je večina tega, kar smo danes zagotovo ne bo potopi v super hitro. In bo trajalo nekaj čas, in nekaj praksa. In so možnosti, boste razvrstiti od želeli zadeti tipkovnico ali kričati na zaslonu. In vse to je v redu. Čeprav, morda poskusite ne to v knjižnici toliko. 

In na koncu, boste se lahko, čeprav, da začnete vidijo vzorce, tako v dobrem kodo ki ste jih napisal in napak ki ste jih naredili. In podobno kot v procesu postaja TF ali CA je všeč, boste začeli, da bi dobili boljše in bolje videl tiste vzorce, in samo reševanje vaše lastne težave končno. V tem času, bo veliko od nas, da bi nudila vam podporo in dobiš skozi to. In v odpisov ups Za vse probleme bo vas vodi skozi vse ukaze da sem zagotovo vedel, od veliko prakse do sedaj, vendar bi lahko letela nad glavo za zdaj. In to je povsem v redu. 

Ampak na koncu, boste začeti videti vzorci pojavljajo. In ko prideš mimo vse neumne podrobnosti, kot so oklepaji, in zaviti oklepaji in podpičji, in stvari, odkrito povedano, da sploh ni intelektualno zanimivo. In to ni cilj vsakršno uvodni razred. To so ideje, ki se bodo pomembno. 

To je zank, in pogoji, in funkcije, in močneje abstrakcija, in faktoring kode, in dober design in dobro slog, in na koncu pravilnost svoje kode, ki je na koncu dogaja, da je najbolj pomembno. Torej naslednji teden, bomo to ideje, ki smo prvič videli v Scratch in so sedaj prevedene na C. In bomo začeli da uvede prvi izmed Seveda je realnih domenah. 

Osredotočili se bomo na svetu varnosti, natančneje kriptografiji umetnost kodiranja podatkov. In med prvimi Težave si sam bodo dobili pisati izven igranje z nekaj sintakse in reševanje nekaterih logično Težave, na koncu prej ali slej, je dejansko Izokrenuti, ali šifriranje, in končno dešifriranje podatkov. In vse, kar smo naredili, danes bo precej nizka Stopnja je le, da bo omogočilo nam lahko eno, in eno, in še en korak nad k pisanje še najbolj zanimivo kodo. 

Torej, več o tem naslednji teden. 

[VIDEO PREDVAJANJE] 

Kaj mi lahko poveste o tem zadnjič, ko si ga videl? Kaj naj rečem, res? Mislim, da je kot vsaka druga pre-produkcija vaja, razen da je nekaj, kar je rekel čisto na koncu, da je zaljubljen vame. 

-To Je CS50. 

-To Je rez vsi, veliko delo na vaji. 

-To Je kosilo? 

Ja, ti in jaz lahko zgrabi sendvič v bit. Naj samo povzetki obveščata z David res hitro. David? David? 

[END PREDVAJANJE] 