[Speel van musiek] David J. MALAN: Goed, dit is CS50. En dit is week een. So onthou dat dit die laaste keer in week nul, Ons fokus op Rekenaardenke. En ons transitioned van wat om Kras, 'n grafiese programmering taal van ons vriende by MIT se Media Lab. 

En met nuuts af, het ons ontdek idees soos funksies, en toestande, en loops, en veranderlikes, en selfs gebeure, en drade, en nog baie meer. En vandag, ons gaan voortgaan om daardie idees, en regtig om hulle vir toegestaan, maar vertaal na 'n ander taal bekend as C. Nou, C is 'n meer tradisionele taal. Dit is 'n laer vlak taal, as jy wil. 

Dit is suiwer tekstuele. En so met die eerste oogopslag, dit is al gaan eerder kriptiese om te kyk As jy nog nooit voorheen geprogrammeer. Ons gaan hê semi-dubbele punte, en tussen hakies, en krullerige draadjies, en nog baie meer. Maar besef dat selfs al die sintaksis is oor 'n bietjie kyk onbekende om die meeste van julle, sien verby dat. En probeer om die idees te sien wat inderdaad bekend, want hier in week een wat ons sal begin om te doen is om te vergelyk, aanvanklik, kras teenoor C. 

So, byvoorbeeld, onthou dat wanneer ons geïmplementeer om die eerste van ons programme laaste keer, het ons 'n blok wat lyk 'n bietjie iets soos this-- toe groen vlag gekliek, en dan het ons een of meer stukke van die legkaart onder dit, in hierdie geval, sê hello world. So, inderdaad, in Scratch, toe ek op daardie groen vlag om my te laat loop, sodat te praat, dit is die blokke wat kry uitgevoer word, of hardloop. En spesifiek Scratch sê hallo, wêreld. 

Nou, ek kon vermeld verskillende woorde hier. Maar ons sal sien dat, wel, baie van hierdie blocks-- en inderdaad, in C baie functions-- kan wees parametrized of persoonlike om verskillende dinge te doen. Trouens, in C as ons wil omskep, nou, hierdie Scratch-program hierdie ander taal, ons gaan 'n skrywe bietjie so iets. 

Toegegee, daar is 'n paar onbekende sintaksis daar heel waarskynlik, int, en hakies en leeg. Maar printf-- selfs al is jy sou dink dit sal net druk wees. Maar druk beteken druk formaat, soos ons binnekort sal sien. Dit sal letterlik druk om die skerm wat ook al is binnekant van die hakies, wat natuurlik in hierdie geval is, hello world. 

Maar jy sal sien 'n paar ander sintaksis, sommige dubbele aanhalingstekens, dat die hakies aan die einde, die semi-kolon en dies meer. Daar is dus 'n bietjie van oorhoofse, so te sê, beide kognitief en sintakties, dat ons gaan om te onthou voor lank. Maar besef dat met die praktyk, dit sal begin om uit te spring op jou. 

Trouens, kom ons fokus op wat 'n mens funksie specifically-- in hierdie geval, sê hallo wêreld. So sê die funksie. Hello world is sy parameter, of argument, sy aanpassing. 

En die ekwivalensie in C is net gaan hier 'n reël wees, waar printf is gelykstaande aan, sê, die dubbele aangehaal string, hello wêreld is ekwivalent, natuurlik, na wat in die wit blokkie daar. En die agteroorskuinsstreep N, al is 'n bietjie vreemde en afwesig is van nuuts af, eenvoudig gaan die uitwerking Ons sal sien in 'n rekenaar, soos my Mac of 'n rekenaar, van net die verskuiwing van die wyser na die volgende lyn. Dit is soos die slaan Tik op jou sleutelbord. 

So ons sal sien dat weer kort voor lank. Maar eers, laat ons 'n blik op hierdie ander voorbeeld in die geval van lusse. Ons het dit vir ewig lus laaste keer, wat was 'n reeks van die legkaart stukke dat daar iets gedoen letterlik forever-- in hierdie geval, sê hello world, hello world, Hello World, hello world. Dit is dus 'n oneindige lus deur ontwerp. 

In C, as ons wil om dit te implementeer Dieselfde idee, ons kan eenvoudig dit doen. Terwyl ware, printf hallo world-- nou terwyl net semanties, soort roep die idee om dit te doen weer iets, en weer, en weer, en vir hoe lank? Wel, true-- onthou dat ware net op of een. 

En waar is, natuurlik, altyd waar nie. So dit is soort van 'n sinlose verklaring net sê waar nie. Maar ja, dit is doelbewuste, want as ware is net altyd waar, as terwyl ware net impliseer, As 'n bietjie indirek, dat die volgende reëls van die kode tussen diegene krullerige draadjies moet net weer en weer uit te voer, en weer, en nooit werklik stop. 

Maar as jy wil hê dat jou lus om op te hou, soos ons het die vorige keer met iets soos hierdie, herhaal die volgende 50 keer, in C kan ons dieselfde met wat ons doen bekend as 'n vir loop-- die navraag nie terwyl, maar vir. En dan het ons 'n paar nuwe sintaksis hier, met int i gelyk 0, ek minder as 50, I ++. En ons sal terug kom. Maar dit is net hoe ons sou vertaal die stel van Scratch blokke om 'n stel van C reëls van die kode. 

Intussen oorweeg veranderlikes. En, in werklikheid, het ons net sien 'n mens 'n oomblik gelede. En in die geval van nuuts af, as ons wou 'n veranderlike genaamd Ek verklaar want ek word heelgetal, net 'n nommer, en ons wil om dit te stel om 'n bietjie waarde, Ons sal hierdie oranje gebruik blok here-- I by 0. 

En ons sal sien vandag en buite, net soos verlede week, programmeerders doen byna altyd begin tel van nul, regtig deur konvensie. Maar ook omdat herroeping van Die bespreking van binêre, die kleinste getal wat jy kan verteenwoordig met enige aantal bisse is net gaan om te wees 0 self. En so sal ons oor die algemeen begin inisialisering selfs ons veranderlikes tot 0. 

En in C om dieselfde te doen, ons gaan int sê vir heelgetal, ek het net deur konvensie. Ek kon hierdie veranderlike genoem enigiets wat ek wil, net soos in Scratch. En dan is gelyk aan 0 net regverkrygendes die waarde 0 van regs en sit dit in die veranderlike, of die stoor houer daar, aan die linkerkant. En die semi-kolon as ons sal see-- en Ons het 'n paar van hierdie already-- gesien net beteken einde van denke. Gaan voort om iets anders te doen op die lyne wat volg. 

Nou, wat van Boolse uitdrukkings? Onthou dat in Scratch, Dit was uitdrukkings wat óf ware of false-- vrae, regtig, wat is waar of vals is. So in die geval van nuuts af, het ons dalk vra 'n eenvoudige vraag soos hierdie, is ek minder as 50? So ek, weer, is 'n heelgetal. Miskien is ons gebruik dit in 'n skrapie program om tred te hou van 'n telling of iets soos dit. So hierdie sintaksis hier in Scratch net beteken, is ek minder as 50? Wel, gelukkig, iets eenvoudig in C. En om te vertaal, hierdie ons sou net sê ek minder as 50, met behulp van die bekende sleutel op u sleutelbord. 

Intussen, as jy wou sê iets meer algemeen, soos, wel, is x minder as y waar elke van x en y is self veranderlikes? Ons kan dieselfde ding doen in C, so lank as wat ons het geskep hierdie veranderlikes reeds. En ons sal sien hoe om doen wat kort voor lank. Ons wil net sê x minder as y. 

So jy begin sien 'n paar ooreenkomste. En dié mense wat gemaak Kras was beslis geïnspireer deur 'n paar van hierdie basiese idees. En jy sal hierdie soort van sien sintaksis in baie languages-- nie net nuuts af, nie net C, maar Python, en JavaScript, en ander tale steeds. 

Kom ons kyk na 'n ander konstruk uit C, die idee van 'n toestand, om iets te doen voorwaardelik. As daar iets is waar, doen dit. As iets anders is waar, dit doen. Dit is soort van die ontwikkeling ekwivalent van 'n vurk in die pad. Miskien is dit 'n tweerigting-vurk, 'n drie-manier vurk, of meer. En in Scratch, kan ons ' gesien iets soos hierdie. 

So hierdie een is 'n groot een. Maar kyk na die relatiewe eenvoud van die logika. As x minder as y is, dan sê x is minder as y, anders as x groter as y, dan sê x groter as y. En dan, logies, as jy dink terug te krap of net jou eie menslike intuïsie, Wel, as x is nie groter as y en x is nie minder nie as y, dan natuurlik x gaan gelyk aan y wees. So in hierdie geval, deur nes diegene Scratch blokke, kan ons bereik 'n drie manier vurk in die pad? 

Intussen, as ons wil doen wat in C, dit waarskynlik lyk 'n bietjie simpler-- ten minste sodra jy vertroud is met die sintaksis. As x is minder as y, printf x is minder as y. Anders as x groter as y, printf x groter as y. Anders printf x is gelyk aan y-- en, weer met dié agteroorskuinsstreep eindig net vir diegene wat nuut lyne sodat as jy eintlik het hierdie soort van program Dit sou net te beweeg jou muis uiteindelik na die volgende lyn van die skerm. 

Nou, intussen Scratch het ander meer gevorderde funksies, net waarvan sommige ons gaan aanvanklik oor te skuif na die wêreld van C. En een van hulle was bekend as 'n lys in te krap. En dit was 'n spesiale tipe veranderlike wat toegelaat dat jy verskeie dinge te stoor daarin terug, na agter, om terug te ondersteun. 

In C, beteken dit nie lyste, per se nie, maar iets wat meer algemeen is genoem skikkings, hoewel ons sal terug te kom later hierdie semester om te kyk na iets bekend as 'n lys, of eintlik 'n geskakelde lys. Maar vir nou, die naaste ekwivalent in C vir ons gaan iets wees genoem 'n skikking. En 'n verskeidenheid is bloot 'n spesiale tipe veranderlike wat jou toelaat om data te stoor terug, na agter, na agter, om terug te. 

En, inderdaad, in Scratch, As ons wou toegang die eerste element van 'n skikking of 'n list-- en ek gaan om dit te noem, deur konvensie, argv, argument vektor, maar meer oor dit kort voor lank. As ek wil by die eerste element te kry van argv, in die wêreld van Scratch jy eintlik doen tipies begin tel van 1. 

En so het ek kan kry item 1 van argv. Dit is net hoe MIT geïmplementeer die idee van lyste. Maar in C, ek gaan meer eenvoudig net sê, argv, wat weer is die naam van my list-- of duidelik te wees, 'n skikking. En as ek wil die eerste elemente, ek gaan om vierkantige hakies gebruik, wat jy dalk nie dikwels gebruik onder 'n sleutelbord. 

Maar 0 net beteken, kry vir my die eerste. So by geleentheid en as verloop van tyd, ons gaan om te begin om hierdie digotomieë sien tussen Scratch en C, waardeur Scratch gebruik een. Ons in C gebruik 0 hier. Maar jy sal gou sien Sodra jy verstaan die fondamente van elke taal, wat hierdie dinge begin al hoe meer kry vertroud deur oefening en praktyk. 

So laat ons eintlik nou kyk na 'n program. Hier sal die eerste van ons C bron-kode vir volledige programme. En die program gaan ons aan te bied vir oorweging is die een wat ekwivalent om dit vroeër Scratch stuk. 

So hier het ons wat waarskynlik die eenvoudigste C program jy kan skryf wat eintlik nie iets. Nou, sal ons kyk verby, vir nou, het in te sluit, standaard io.h, en hierdie hoek hakies, en int en leeg, en die krullerige draadjies, en dies meer. 

En laat ons net fokus op wat, ten minste intuïtief, dalk uit reeds spring op jou. Trouens, hoof, doen ek nie, noodwendig weet wat dit is, maar baie soos Scratch het dat wanneer groen vlag gekliek legkaart stuk, so ook C as 'n programmeertaal 'n hoof stuk kode wat sal uitgevoer word by verstek. En, inderdaad, dit letterlik gaan belangrikste genoem te word nie. 

So belangrikste is 'n funksie. En dit is 'n spesiale funksie wat bestaan in C dat wanneer jy 'n program uit te voer, Dit is hoof wat kry wat deur verstek. In die wêreld van nuuts af, Dit was gewoonlik wanneer groen vlag gekliek dat het gelei deur verstek. 

Intussen het ons gesien voor, printf of gedrukte formaat, dit is gaan 'n funksie wat kom met wees C, saam met 'n hele klomp van die ander, wat sal dan van tyd en tyd weer, ten einde presies te doen soos sy naam suggereer, druk iets. Wat doen ons wil druk? Wel, sal ons sien dat deur omringende karakters soos these-- hello world, agteroorskuinsstreep N dubbele aanhalingstekens, Ons kan printf presies vertel wat om te druk op die skerm. 

Maar om te doen dat ons ongelukkig nodig het om iets wat neem reeds kriptiese om ons mense, maar ten minste is dit 'n bietjie readable-- skerp sluit, standaard io.h, int, hoof, leemte, printf, al die magiese inkantasies ons sien net op die skerm. Maar ons het eintlik aan gaan nog meer arcane. Eerstens moet ons die kode te vertaal dat ons skryf in masjienkode. En onthou van verlede week dat masjiene, ten minste die wat ons hier ken, aan die einde van die dag net verstaan ​​nulle en ene. 

En my God, as ons moes hierdie skrywe nulle en ene om werklik program, Dit sou baie, baie vinnig neem die pret uit niks. Maar dit blyk, per verlede week, dat hierdie patrone van nulle en ene net het 'n spesiale betekenis. In sekere kontekste, hulle kan beteken getalle. 

In sommige kontekste, kan dit beteken briewe, of kleure, of enige aantal van ander abstraksies daar op. Maar net soos jou rekenaar het 'n CPU, sentrale verwerkingseenheid, of die brein binnekant van jou rekenaar. Dit is gewoonlik Intel binnekant, want dit is een van die grootste maatskappye dit maak CPUs vir rekenaars. 

Wel, Intel CPU en ander eenvoudig besluit by voorbaat dat sekere patrone van nulle en kinders sal spesifieke dinge beteken. Sekere patrone van nulle en ene sal beteken, druk dit na die skerm, of voeg hierdie twee getalle, of trek die twee getalle, of beweeg hierdie stuk van data uit geheue my rekenaar se hier, of enige aantal ander baie lae vlak, maar uiteindelik nuttig, bedrywighede. Maar, gelukkig, ons mense is nie van plan nodig om hierdie vlak van detail te ken nie. Inderdaad, net soos die vorige keer, waar ons onttrek weer, en weer, en weer, gebou van 'n baie lae vlak primitiewes soos nulle en ene om 'n hoër vlak konsepte soos getalle en letters, en kleure, en nog baie meer, so kan ons as programmeerders staan ​​op die skouers van ander wat voor ons gekom het en gebruik sagteware wat ander mense het voor us-- geskryf naamlik programme genoem opstellers. 

C is 'n taal wat word gewoonlik saamgestel, wat beteken bekering uit bronkode te masjienkode. In die besonder, wat dit beteken is dat as jy jou bron het kode wat jy jouself skryf, soos ons gou sal in 'n oomblik op die skerm, en jy wil om dit te omskep uiteindelik masjien code-- diegene nulle en ene wat net jou Mac of jou rekenaar understands-- jy het 'n eerste voed dat bronkode as insette om 'n spesiale program genaamd 'n samesteller, die opbrengs van wat ons sien is masjienkode. En, inderdaad, die laaste keer wat ons gepraat oor, regtig, aan die einde van die dag, probleemoplossing. Jy het insette. En jy het uitgange. En jy het 'n soort het van algoritme in die middel. 

Algoritmes kan sekerlik wees geïmplementeer in sagteware, soos ons gesien het met pseudokode verlede week en as ons sien met werklike kode hierdie week. En so 'n samesteller eintlik net het 'n stel van algoritmes binnekant daarvan dat weet hoe om omskep die spesiale sleutelwoorde, soos belangrikste, en printf, en ander wat ons net sien in die patrone van nulle en Diegene wat Intel binne en ander CPUs eintlik verstaan. So, hoe doen ons dit? Waar kry ons 'n samesteller? 

Die meeste van ons hier 'n Mac of 'n rekenaar. En jy met Mac OS, of Windows, Linux, of Solaris, of enige aantal ander bedryfstelsels. En, inderdaad, ons kon gaan uit op die web en af ​​te laai 'n samesteller vir jou Mac of jou rekenaar vir jou spesifieke bedryfstelsel. Maar ons sal almal op verskillende bladsye, om so te praat. Ons wil 'n bietjie het verskillende konfigurasies. En dinge sou nie almal dieselfde werk. En, inderdaad, deesdae baie van ons gebruik nie sagteware wat loop net op ons skootrekenaars. In plaas daarvan, gebruik ons ​​iets soos 'n leser wat ons toelaat om toegang te verkry tot die web-gebaseerde programme in die wolk. En later hierdie semester, Ons sal presies dit te doen. Ons sal aansoeke skryf of sagteware met behulp van code-- nie C, maar ander tale soos Python en JavaScript-- wat uitgevoer word in die wolk. 

En om dit te doen, ons onsself gedurende die semester sal eintlik gebruik 'n wolk-gebaseerde omgewing bekend as CS50 IO. Dit is 'n web-gebaseerde programme omgewing, of geïntegreerde ontwikkelingsplan omgewing, IDE, wat is gebou bo-op 'n paar open source sagteware genoem Wolk 9. En ons het 'n paar opvoedkundige gemaak vereenvoudigings om dit ten einde sekere funksies in om weg te steek die eerste weke dat ons nie nodig het, waarna jy kan openbaar hulle en doen die meeste enigiets wat jy wil met die omgewing. 

En dit laat ons ook om pre-installeer sekere sagteware. Dinge soos 'n sogenaamde CS50 biblioteek, wat ons binnekort sal sien bied ons in C met 'n paar addisionele funksionaliteit. So as jy gaan na uiteindelik CS50.io, sal jy gevra om aan te meld, en sodra jy dit doen en skep 'n rekening vir gratis, jy in staat is om toegang te verkry tot 'n sal wees omgewing wat lyk baie soos hierdie. 

Nou, dit is in die verstek. Alles is mooi en helder op die skerm. Baie van ons het 'n gewoonte om werk op CS50 stuk wat redelik laat in die nag. En so 'n paar van wat jy dalk verkies om draai dit in die nag af, om so te praat. 

Maar uiteindelik, wat jy gaan om te sien binne CS50 IDE is drie afsonderlike areas-- 'n gebied aan die linkerkant waar jou lêers gaan wees in die wolk, 'n gebied op die regter boonste waar jou kode gaan bewerkbaar te wees. Jy sal in staat wees om oop te maak individuele tabs vir enige program dat jy binne skryf hierdie semester van daardie boonste regterkantste hoek. En dan die meeste arcanely, en tog kragtig, gaan hierdie ding op die wees bodem bekend as 'n terminale venster. 

Dit is 'n ou skool Command line interface, of CLI, wat dit moontlik maak jy opdragte uit te voer op die computer-- in hierdie geval, die rekenaar in die cloud-- om dinge soos stel jou kode te doen vanaf bronkode te masjienkode, om jou programme te hardloop, of om te begin jou webbediener, of toegang tot jou databasis, en 'n aantal ander tegnieke dat ons sal begin om te gebruik kort voor lank. Maar om daar te kom, ons is gaan eintlik om aanlyn te gaan en begin speel. En om dit te doen, laat ons eerste begin geknutsel met hoof, en skryf die belangrikste deel van 'n program. En laat ons gebruik daardie funksie printf, wat ons vroeër gebruik, eenvoudig om iets te sê. 

So hier is ek reeds binnekant van CS50 IO. Ek het aangeteken in advance. En ek volle gekeur by die venster uit. En so, uiteindelik, jy Ook in die komende probleme sal soortgelyke stappe te volg wat sal aanlyn dokumentasie. So jy hoef nie te bekommerd wees oor absorbeer elke klein tegniese stap wat Ek doen vandag. 

Maar jy sal 'n skerm soos hierdie te kry. Ek toevallig in die nag af. En jy kan alles op te kikker deur die aanskakel van die nag af. En aan die einde van die dag, jy gaan om te sien hierdie drie hoof areas-- die lêer leser aan die linkerkant, die kode oortjies op die top, en die terminale venster aan die onderkant. 

Laat my gaan voort en skryf my eerste program. Ek gaan preemptively gaan na File, Slaan, en red my lêer as hello.c. Inderdaad, deur konvensie, 'n program wat ons skryf dit is geskryf in die taal C moet iets genoem dot c, deur konvensie. So ek gaan dit noem hello.c, omdat Ek wil net hallo vir die wêreld sê. Nou gaan ek om te vergroot uit en klik op Save. En al wat ek het hier nou 'n blad waarin ek begin skryf code. 

Dit is nie van plan om op te stel. Dit beteken niks. En sodat selfs wanneer ek tot bekering hierdie om nulle en ene, die SVE gaan nie hê idee wat aangaan rondom. Maar as ek lyne skryf wat nie ooreenstem met met conventions-- C wese C se Weereens, dit language-- met sintaksis soos hierdie, printf hallo world-- en ek het gekry gemaklik met om dit te doen met verloop van tyd. So ek dink nie ek het enige tipografiese foute. 

Maar, sonder uitsondering, die heel eerste keer as jy dit doen, sal jy. En wat ek nou gaan doen dalk baie goed nie werk vir jou die eerste keer. En dit is perfek OK, want nou jou dalk net sien 'n hele klomp van die nuwigheid, maar met verloop van tyd as jy eers vertroud met hierdie omgewing, en hierdie taal, en ander, jy begin om dinge te sien dat is óf reg of verkeerd. 

En dit is wat die onderrig genote en natuurlik assistente kry so goed in die verloop van tyd, is spot foute of foute in jou kode. Maar ek beweer dat daar is geen foute in hierdie kode. So wil ek nou hierdie program uit te voer. 

Nou op my eie Mac of PC, ek is in die gewoonte om dubbel te kliek ikone toe ek wil 'n paar program uit te voer. Maar dit is nie die model hier. In hierdie omgewing, wat is CS50 IO. Ons gebruik 'n bedryfstelsel stelsel genoem Linux. Linux is wat herinner aan 'n ander bedryfstelsel, algemeen bekend as Unix. En Linux is veral bekend vir met 'n command line omgewing, CLI. Nou, ons is met behulp van 'n spesifieke geur van Linux genoem Ubuntu. En Ubuntu is bloot 'n sekere weergawe van Linux. 

Maar hierdie Linux se deesdae doen eintlik kom met grafiese gebruikerskoppelvlakke. En die een wat ons gebeur hier gebruik is web-gebaseerde. So dit kan selfs 'n blik bietjie anders as iets jy jouself kan hê gesien of hardloop in die verlede. 

So ek gaan om voort te gaan nou en doen die volgende. Ek het hierdie lêer as hello.c gered. Ek gaan om voort te gaan en tipe clanghello.c So klang vir die taal C is 'n samesteller. Dit is vooraf geïnstalleer in CS50 IO. En jy kan absoluut aflaai en installeer hierdie op jou eie Mac of PC. 

Maar, weer, jy sal nie al het die pre-opset vir jou gedoen. So vir nou, ek is net gaan clanghello.c hardloop. En nou sien hierdie sintaksis hier sal uiteindelik besef net beteken dat ek in 'n gids of gids genoem Workspace. Dit dollar teken is net konvensie vir betekenis, tik jou opdragte hier. 

Dit is wat genoem word 'n vinnige, net deur konvensie is dollar teken. En as Ek gegaan voor af en klik Gee, blyk niks te gebeur. Maar dit is eintlik 'n goeie ding. Die minder wat gebeur op jou skerm, hoe meer waarskynlik jou kode is korrek te wees, ten minste sintakties. 

So as ek wil hierdie hardloop program, wat moet ek doen? Wel, dit blyk dat die verstek naam deur konvensie vir programme as jy nie spesifiseer 'n naam vir jou program is net a.out. En dit sintaksis ook sal jy kry vertroud is met kort voor lank. 

Dot streep net beteken, hey, CS50 IDE, hardloop 'n program genaamd a.out dit is binne-in my huidige gids. Dit dot beteken die huidige gids. En ons sal sien wat ander sulke reekse karakters beteken kort voor lank. 

So hier gaan ons, Tik, hello world. En jy sal sien dat wat gebeur het? Nie net het dit druk hello world. Dit het ook die wyser na die volgende lyn. 

En hoekom was dit? Wat was die kode wat ons voor geskryf wat verseker dat die wyser sou gaan op die volgende reël? Snaakse ding oor 'n rekenaar is dit net gaan letterlik doen wat jy dit vertel om te doen. 

So as jy dit aan printf hello, komma, ruimte, wêreld, naby kwotasie, dit letterlik net gaan aan dié karakters te druk. Maar ek het hierdie spesiale karakter aan die einde, onthou, agteroorskuinsstreep N. En dit is wat verseker dat die karakter het na die volgende lyn van die skerm. 

Trouens, dat ek kan gaan en dit te doen. Laat my gaan voort en skrap. Nou, sien dat die bo-op my skerm is daar ' 'n bietjie rooi lig in die blad aandui, hey, jy het nie jou lêer gestoor. So ek gaan om voort te gaan met beheer S of opdrag S, stoor die lêer. Nou is dit goes-- het vir 'n moment-- groen. En nou is dit terug na net 'n noue ikoon. 

As ek nou weer uit te voer clanghello.c, Ingaan, dot streep, a.out, Tik, jy sal sien dat dit steeds gewerk. Maar dit is waarskynlik 'n bietjie karretjie. Op die oomblik is, my prompt-- werkplek, en dan is dit dollar teken, en dan my werklike prompt-- is almal op dieselfde lyn. So dit beslis 'n estetiese fout, selfs al is dit nie regtig 'n logiese fout. 

So ek gaan ongedaan te maak wat ek nou net gedoen het. Ek gaan a.out tik. Sien ek het bygevoeg die NEWLINE karakter terug. Ek het die lêer gestoor. 

So ek gaan a.out tik, and-- dammit, 'n fout, 'n fout wat beteken fout. So die fout is dat selfs al Ek het ook die agteroorskuinsstreep N daar, Re-gered, re-hardloop die program, die gedrag was dieselfde. Hoekom sou dit wees? 

Ek mis 'n stap, reg? Dit belangrike stap vroeër was dat jy aan- wanneer jy jou bronkode te verander, dit blyk ook uit te voer dit deur die samesteller weer so jy nuwe masjien kode. En die masjien kode, die nulle en ene, gaan byna identies te wees nie, maar nie heeltemal so, want ons wil hê, natuurlik, wat nuwe lyn. 

So om dit op te los, ek gaan benodig om clanghello.c tik, tik, dot streep, a.out. En nou, hello world is terug na die plek waar ek verwag om dit te wees. So dit is alles goed en wel. Maar a.out is 'n mooi dom naam vir 'n program, selfs al is dit gebeur om te wees, vir historiese redes, die default-- beteken vergadering uitgange. 

Maar laat ek hier voort te gaan en anders doen dit. Ek wil my Hello World-program om werklik word hallo genoem. So asof dit 'n ikoon op my lessenaar, sou dit nie a.out. Dit sou hallo genoem. 

So om dit te doen, dit blyk dat klang, soos baie programme, ondersteun command line argumente, of vlae, of skakel, wat net beïnvloed sy gedrag. Spesifiek, klang ondersteun 'n streep o vlag, wat dan neem 'n tweede woord. In hierdie geval, sal ek na willekeur, maar redelik, noem dit hallo. Maar ek kan dit noem enigiets Ek wil nie, behalwe a.out, wat eerder behalwe die punt sou wees. 

En dan net spesifiseer die naam van die lêer Ek wil stel. So nou al aan die begin van die opdrag Ek het nog klang, aan die einde van die opdrag Ek het nog steeds die lêernaam, Ek het nou hierdie command line argumente, hierdie vlae wat sê: O, by the way, uitset-o, 'n lêer genoem hello, nie die verstek a.out. 

So as ek druk Enter nou, niks blyk te gebeur. En tog, nou kan ek dot streep doen hallo. Dit is dus dieselfde program. Die nulle en ene is identies aan die einde van die dag. 

Maar hulle is in twee verskillende files-- a.out, wat is die eerste weergawe en net so dom genoem, en nou hello, wat 'n baie meer dwingende naam vir 'n program. Maar, eerlik, ek het nooit gaan dit weer onthou, en weer en weer. En eintlik, as ons skrywe meer ingewikkeld programme, die bevele jy gaan hê om te skryf gaan selfs meer ingewikkeld steeds. 

En so nie te bekommer nie. Dit blyk dat die mens voor ons het hulle ook besef het presies dieselfde probleem. Hulle het ook nie geniet om te tik taamlike lang, arcane opdragte, laat staan ​​nog onthou hulle. En so mens voor ons gemaak het ander programme wat dit makliker maak om jou sagteware te stel. 

En, inderdaad, een so 'n program genoem te maak. So ek gaan om voort te gaan en dit te doen. Ek gaan alles ongedaan ek nou net gedoen het in die volgende manier. Laat my tik LS. En jy sal sien drie things-- a.out, en 'n ster, hello en 'n ster, en hello.c. Hopelik, moet dit 'n bietjie intuïtief, sover vroeër was daar Niks in hierdie werkspasie. Daar was niks wat ek moes geskape het tot ons klas begin. 

En ek geskep hello.c. dan het ek opgestel het, en dit genoem a.out. En dan saamgestel ek dit weer effens anders en dit genoem: hallo. So ek het drie lêers in hierdie gids, in hierdie gids met die naam Workspace. Nou kan ek sien dat sowel As ek zoom uit eintlik. 

As ek hier zoom en kyk na wat boonste regterkantste hoek, soos belowe links kant van die skerm is altyd iets om jou te wys Wat is in jou rekening, wat binnekant van CS50 IO. En daar is drie lêers daar. 

So ek wil ontslae te raak van a.out en hallo. En as jy dalk dink intuïtief, jy kon soort van beheer kliek of regs kliek op hierdie punt. En hierdie klein spyskaart verskyn. Jy kan die lêer af te laai, uit te voer dit, 'n voorbeeld van dit, te verfris, te hernoem, of wat nie. 

En ek kon net verwyder, en dit sal weggaan. Maar laat ons dinge doen met 'n opdrag lyn vir nou, ten einde gemaklik te kry met hierdie, en doen die volgende. Ek gaan om voort te gaan en te verwyder a.out deur te tik letterlik rma.out. Dit blyk dat die bevel vir verwydering of iets te skrap, is nie verwyder of verwyder. 

Dit is meer bondig RM, net om te spaar jou 'n paar toetsaanslagen, en druk Enter. Nou gaan ons 'n bietjie wees kripties verwyder gereelde lêer a.out. Ek het nie regtig weet wat 'n onreëlmatige lêer nog wil wees. Maar ek wil om dit te verwyder. 

So ek gaan y tik vir Ja. Of ek kan self een uit, en druk Enter. En, weer, lyk niks gebeur nie. Maar dit is in die algemeen, 'n goeie ding. 

As ek LS tik hierdie tyd, Wat moet ek sien? Hopelik net hallo en hello.c. Nou, as 'n eenkant, sal jy sien hierdie sterre, sterretjie, dit is aan die einde van my programme. En dit is ook vertoon in groen. Dit is net CS50 IDE se manier van cluing jy in die waarheid te sê dat dit nie bronkode. Dit is 'n uitvoerbare, 'n uitvoerbare program wat jy eintlik kan hardloop deur dit te doen dot streep, en dan is dit naam. 

Nou, laat ek gaan voort en verwyder hierdie, RM hello, Tik, verwyder gereelde lêer hello, ja. En nou as ek tik LS, ons is terug na hello.c. Probeer om nie te verwyder jou werklike bron-kode. Selfs al is daar funksies gebou in CS50 IO waar jy kan gaan deur middel van jou hersiening geskiedenis en rewind betyds as jy per ongeluk iets verwyder, doen bedag wees soos per die instruksies ja of nee, van wat jy eintlik wil doen. En as Ek gegaan na die top linkerhoek hier, al wat oorbly is hello.c. Daar is dus trosse van ander opdragte wat jou kan doen in die wêreld van Linux, waarvan een is, weer, maak. En ons gaan Maak my program nou soos volg. 

In plaas daarvan om dit te doen klang, in plaas van om klang-o, Ek gaan net letterlik tik, maak hallo. En nou sien ek nie tik maak hello.c. Ek tik maak hallo. 

En hierdie program Maak dat kom met CS50 IDE, en nog baie meer oor die algemeen met Linux, is 'n program wat gaan 'n program genaamd Hallo maak. En dit gaan om te aanvaar, deur konvensie, dat indien hierdie program kan gedoen word, dit gaan word gemaak van 'n bron -kode lêer eindig in dot c, hello.c. 

So as ek druk Enter nou, kennis dat die opdrag wat sal uitgevoer word is eintlik selfs meer voor as voorheen. En dit is omdat ons het gedefinieerde CS50 IO te hê 'n paar ekstra funksies gebou in daardie Ons weet nog net nie nodig nie, maar gou wil. Maar die belangrikste ding om te besef nou het ek 'n Hallo program. 

As ek tik LS weer, ek 'n hallo program. En ek kan dit uit te voer met dot streep a.out, nee, omdat die hele punt van hierdie oefening was dot streep hallo. En nou het ek my Hello World-program. So 'n stap vorentoe, ons is byna altyd net gaan ons programme op te stel met behulp van die opdrag te maak. En dan gaan ons dit loop deur dot streep, en die naam van die program. Maar besef wat maak, is besig om jy, is dit self nie 'n samesteller. Dis net 'n gerief program wat weet hoe om 'n samesteller aktiveer om dit uit te voer dat jy jouself kan dit gebruik. 

Wat ander opdragte bestaan ​​in Linux, en op sy beurt die CS50 IO? Ons sal gou sien dat daar 'n CD opdrag, Verandering Gids. Dit laat jou toe binne jou command line interface om vorentoe te beweeg, en terug, en oop te stel verskillende dopgehou sonder die gebruik van jou muis. 

LS ons gesien het, wat staan ​​vir 'n lys die lêers in die huidige gids. Maak Dir, kan jy waarskynlik begin om af te lei wat dit beteken now-- gids maak, As jy wil 'n gids te skep. RM onthef, RM Dir vir verwyder directory-- en hierdie, weer, is die command line ekwivalente van wat jy kon doen in CS50 IDE met jou muis. Maar jy sal gou vind wat soms is dit net 'n baie vinniger te doen dinge met 'n sleutelbord, en uiteindelik 'n baie meer kragtig. 

Maar dit is moeilik om te argumenteer dat enigiets wat ons het gedoen tot dusver is al wat 'n kragtige, wanneer al ons het al gesê is, hello world. En, in werklikheid, ek hardcoded die woorde Hello World in my program. Daar is nog geen dinamika. Kras was 'n bevel van die grootte meer interessant verlede week. 

En so kom ons daar uit te kom. Kom ons neem 'n stap in die rigting wat deur manier van sommige van hierdie funksies. So nie net C kom met printf, en trosse van ander funksies waarvan sommige sal ons sien met verloop van tyd, dit nie Maak dit so maklik reg uit van die hek in om die gebruiker se toevoer. 

Trouens, een van die swakhede van tale soos C, en selfs Java en nog ander, is dat dit nie gebeur nie maak dit maklik om net dinge soos heelgetalle van gebruikers, of snare, woorde, en frases, wat nog te sê dinge soos drywende punt waardes, of reële getalle met desimale punte, en regtig lang nommers, soos ons binnekort sal sien. So hierdie lys van funksies hier, hierdie soos ander Scratch stukke van die legkaart dat ons pre-geïnstalleer in CS50 IDE wat ons sal gebruik vir 'n paar weke opleiding wiele van spesies, en uiteindelik neem dit af en kyk onder die enjinkap, miskien, by hoe hierdie dinge geïmplementeer word. 

Maar om dit te doen, laat ons eintlik skryf 'n program. Laat my tog gaan voort. En ek gaan 'n nuwe te skep lêer deur te kliek hierdie klein plus, en kliek nuwe lêer. 

Ek gaan hierdie volgende red een as, kom ons sê, string.c, want ek wil om te speel met snare. En string in C is net 'n reeks van karakters. So nou laat ons gaan voort en doen die volgende. 

Sluit standaard IO.h-- en dit blyk standaard IO, IO beteken net toevoer en afvoer. So dit blyk dat hierdie lyn hier is wat word die naburige ons printf gebruik. Printf, natuurlik, produseer uitset. So ten einde printf gebruik, dit blyk uit moet jy hierdie reël van die kode het aan die bokant van jou lêer. 

En ons sal terug te kom na wat dit beteken regtig kort voor lank. Dit blyk dat in enige C program wat ek skryf, Ek het om dit te begin met kode wat lyk soos volg. En jy sal sien CS50 IDE, en ander geïntegreerde ontwikkelingsplan omgewings soos dit, gaan as die beste probeer hulle kan om jou denke te voltooi. Trouens, 'n oomblik gelede as ek ongedaan wat ek nou net gedoen het, ek druk Enter. 

Ek het toe getref oop krullerige stut, getref in te voer. En dit klaar my gedagte. Dit het my 'n nuwe lyn, ingekeep nie minder vir mooi stilistiese redes sal ons sien. En dan is dit outomaties aan my gegee het dat krullerige brace om my denke te voltooi. Nou, is dit nie altyd raai wat jy wil doen. Maar 'n groot deel, is dit nie red jou 'n paar toetsaanslagen. So 'n oomblik gelede, het ons hierdie program-- hallo, wêreld, en dan saamgestel is, en dan hardloop hy. Maar daar is geen dinamika hier. Wat gebeur as ons wou iets anders te doen? Wel, wat as ek wou eintlik kry 'n string van die gebruiker? Ek gaan 'n legkaart stuk gebruik genoem presies that-- string te kry. 

Blyk in C dat wanneer jy nie wil hê om insette te lewer om 'n legkaart stuk, of meer behoorlik na 'n funksie, jy letterlik net doen oop hakies, naby hakies. Dit is dus asof daar geen wit blokkie te tik in. Die inspraak blok voor het 'n klein wit boks. Ons het nie nou dat wit boks. 

Maar as ek roep get string, ek wil die gevolg iewers sit. So 'n baie algemene paradigma in C is om noem 'n funksie, soos get string hier, en dan slaan sy terugkeer waarde. Dit is die gevolg van sy poging in iets. 

En wat is die bou in programmering, hetsy in Scratch of nou C, dat ons kan gebruik om werklik iets te slaan? Noem dit 'n veranderlike, reg? En in Scratch, doen ons nie regtig omgee wat aangaan in veranderlikes. 

Maar in hierdie geval, ons eintlik doen. Ek gaan string sê. En dan kan ek noem hierdie iets wat ek wil. Ek gaan om dit te noem naam, kry kry string. 

En nou selfs al is jy 'n bietjie nuut is tot hierdie, agterkom dat ek gebrek aan detail. Ek is vergeet 'n kommapunt. Ek nodig het om hierdie gedagte te voltooi. So ek gaan my wyser beweeg, en druk kommapunt daar. En wat het ek net gedoen? In hierdie lyn van kode, nommer 5 op die oomblik, Ek neem Oproep string met geen insette. Daar is dus geen klein wit boks soos die blok Save het. 

Ek sê maar net, hey, rekenaar, kry vir my 'n string. Die gelyk teken is nie regtig 'n gelykaanteken, per se. Dit is die opdrag operateur, wat beteken, hey, rekenaar, beweeg die waarde van die reg oor aan die linkerkant. En in die linker, ek het die volgende. 

Haai, rekenaar, gee my 'n string-- 'n reeks van karakters. En noem dat string Naam. En ek hoef nie eens om dit te noem Naam. 

Ek kon dit noem, konvensioneel, iets soos S, baie soos ons gebruik ek om noem die veranderlike i. Maar nou het ek nodig het om iets te doen met dit. Dit sou redelik dom te wees Probeer die opstel van hierdie kode, hardloop hierdie program, selfs al Ek kry 'n string, want dit is nog steeds net gaan hallo sê wêreld. 

Maar wat as ek wil om dit te verander. Hoekom nie ek dit doen? Persent s, komma s. En dit is nog steeds 'n bietjie kripties. 

So laat ek my veranderlikes meer duidelik te maak. Laat my noem hierdie veranderlike Naam. En laat ons kyk of ons nie kan terg afgesien wat hier gebeur. 

So op die lyn vyf, ek kry 'n string. En ek stoor dit string, ongeag die gebruiker ingetik op sy of haar sleutelbord, in 'n veranderlike genoem Naam. En dit blyk dat printf nie net neem een ​​argument in dubbel aanhalings, een insette in dubbel aanhalings. 

Dit kan twee, of drie, of meer, soos te neem dat die tweede, of derde, of vierde, is al die name van veranderlikes, of spesifiek waardes, wat jy wil aan te sluit in, dinamiese, wat string in aanhalingstekens. Met ander woorde, wat verkeerd met hierdie sou wees? As ek sê net hallo naam, agteroorskuinsstreep N, gered my lêer, saamgestel my kode, en hardloop dit, wat sou gebeur? 

Dit is net gaan om te sê, hello noem, letterlik N-A-M-E, wat is 'n soort van dom omdat dis nie anders as die wêreld. So iets in aanhalingstekens is wat letterlik raak gedruk. So as ek wil hê 'n plekhouer daar, Ek moet eintlik om te gebruik 'n paar spesiale sintaksis. En dit blyk asof jy lees die dokumentasie vir die printf funksie, Dit sal jou vertel dat As jy gebruik persent s, jy kan 'n waarde vervang soos volg. 

Na 'n komma na daardie dubbel kwotasie, jy net skryf die naam van die veranderlike wat jy wil aan te sluit in in daardie formaat kode, of formaat specific, persent s vir snare. En nou as ek het my lêer gered, Ek gaan terug na my terminale. En ek tik Maak String, omdat, weer, die naam van hierdie lêer wat ek gekies het voor is string.c. 

So ek gaan om te sê Maak String, betree. Ag, my goedheid, kyk na al die foute wat ons reeds gemaak het. En dit is-- wat, dit is regtig soos 'n ses, sewe line program? So is dit waar dit baie kan vinnig oorweldigend. 

Dit terminale venster nou net regurgitated 'n groot aantal fout boodskappe. Sekerlik, kan ek nie meer fout boodskappe as wat ek het reëls van die kode. So, wat gaan aan? 

Wel, die beste strategie om enige tyd doen jy moenie teëkom 'n oorweldigende lys van foute soos dié, is terug blaai, kyk uit vir die opdrag jy net hardloop, wat in my geval is maak string. Kyk na wat maak het, en dit is wat lang klang opdrag, geen big deal daar. 

Maar die rooi is sleg. Groen probeer wees sagte en hulpvaardig. Maar dit is nog steeds swak, in hierdie geval. Maar waar is dit sleg? 

String.c, lyn vyf, karakter vyf. So dit is net algemene konvensie. Iets kolon iets beteken lyn nommer en karakter getal. Fout, gebruik van swart identifiseerder string. Het jy standaard in beteken? 

So, ongelukkig, klang probeer om behulpsaam te wees. Maar dit is verkeerd, in hierdie geval. Nee, klang, ek het nie bedoel standaard IO. Ek het beteken dat op die lyn een, ja. 

Maar lyn vyf is hierdie een hier. En klang nie verstaan ​​S-T-R-ek-N-G. Dit is 'n onverklaarde identifiseerder, 'n woord is dit net nog nooit voorheen gesien het. En dit is omdat C, die taal ons wil skryf kode in die oomblik, nie veranderlikes genoem snare het. 

Dit maak nie, by verstek, ondersteuning iets genaamd 'n string. Dit is 'n CS50 stuk jargon, maar baie konvensionele. Maar ek kan dit soos volg op te los. 

As ek voeg 'n reël van die kode na die top van hierdie program, sluit CS50.h, wat ook 'n lêer iewers binnekant van CS50 IDE, iewers op die hardeskyf, so te sê, van die Ubuntu bedryfstelsel dat Ek hardloop, wat is die lêer wat gaan die bedryfstelsel te leer stelsel wat 'n string is, net soos standaard io.h is die lêer in die bedryfstelsel wat gaan dit leer wat printf is. 

Inderdaad, sal ons gekry het 'n baie soortgelyke boodskap As IO standaard het toegelaat IO.h en probeer om printf gebruik. So ek gaan voort en gaan net Neem beheer L om my skerm skoon te maak. Of jy kan duidelik tik en dit sal net duidelik dat die terminale venster. Maar jy kan nog steeds blaai terug in die tyd. 

En ek gaan tik Maak String. Kruis my vingers hierdie keer, Tik. O my God, dit het gewerk. dit wys my 'n lang kriptiese command dit is wat Maak gegenereer via klang, maar geen fout boodskappe. So besef, selfs al jy dalk heeltemal te kry oorweldig met die aantal fout boodskappe, Dit mag dalk net hierdie irriterende waterval wees effek, waar klang nie verstaan een ding wat dit beteken dan verstaan ​​nie die volgende woord, of die volgende lyn. En so is dit net verstik op jou kode. Maar die oplossing kan eenvoudig wees. En so het altyd fokus op die heel eerste lyn van die produksie. En as jy dit nie doen nie verstaan ​​dit, kyk net vir sleutelwoorde wat dalk leidrade, en die lyn nommer, en die karakter, waar wat fout kan wees. 

Nou kan ek gaan voort en tik dot streep, string, betree. Hm, dit is nie te sê hallo enigiets. Hoekom? Wel, onthou, waar is dit loop? 

Dit is waarskynlik vas op die oomblik in 'n lus, as jy wil, op die lyn ses, omdat Kry String deur ontwerp, geskryf deur CS50 personeel, is letterlik bedoel om net te sit daar wag, en wag, en wag vir 'n string. Alle bedoel ons deur string is menslike insette. So jy weet wat? Laat my gaan voort. En net op 'n bevlieging, laat my tik my naam, Dawid, te gaan. Nou het ek 'n meer dinamiese program. Daar word gesê dat, hallo Dawid. 

As ek gaan voort en loop dit weer, laat ek probeer sê Zamila naam, betree. En nou het ons 'n dinamiese program. Ek het nie hard gekodeer wêreld. Ek het nie hard gekodeer noem, of Dawid, of Zamila. 

Nou is dit baie meer soos die programme ons weet, waar as dit neem insette, dit produseer effens anders uitset. Nou, dit is nie die beste gebruikers ervaring, of UX. Ek hardloop die program. 

Ek weet nie wat ek veronderstel om te doen nie, tensy ek eintlik kyk na of onthou die bronkode. So kom ons maak die gebruiker ervaar 'n bietjie beter met die eenvoudigste dinge. Laat my terug te gaan na hierdie program, en net sê printf. 

En laat ek gaan voort en sê naam, kolon, en 'n ruimte, en dan 'n kommapunt. En net vir skoppe, geen teenreaksie N. En dit is doelbewuste, want ek wil nie die vinnige om te skuif na die volgende lyn. 

Ek wil, in plaas daarvan, doen dit, maak string om my kode in nuwe masjien heropstel -kode dot streep string. Ag, dit is baie mooier. Nou ek eintlik weet wat die rekenaar wil hê ek moet doen, gee dit 'n naam. 

So ek gaan om voort te gaan en tik in Rob, betree, en hallo, Rob. So, besef, dit is nog steeds aan die einde van die dag, net 'n nege line program. Maar ons het hierdie baba stappe geneem. 

Ons het 'n reël waarmee ons was bekend, printf, hello world. Dan ongedaan ons 'n bietjie van daardie. En ons eintlik gebruik get string. En ons geteister dat waarde in 'n veranderlike. En dan het ons voort en verbeter dit verder met 'n derde lyn. En dit iteratiewe proses van skryf sagteware is werklik die sleutel. In CS50, en in die lewe in die algemeen, jy moet in die algemeen nie gaan sit, 'n program in gedagte, en probeer skryf die hele damn ding alles op een slag. 

Dit sal onvermydelik lei tot manier meer foute as wat ons onsself hier gesien. Selfs ek, tot vandag toe, voortdurend maak ander dom foute, is eintlik harder foute wat is moeiliker om uit te vind. Maar jy sal meer foute die meer te maak reëls van die kode wat jy skryf alles op een slag. En so hierdie praktyk van, skryf 'n bietjie van die kode waarmee jy gemaklik is, saam te stel dit, hardloop dit, toets dit meer algemeen, dan beweeg is-- sodat net soos ons gehou gelaagdheid en gelaagdheid verlede week, bou van iets baie maklik om iets meer kompleks, doen hier dieselfde. Moenie gaan sit, en probeer om skryf 'n hele probleem. Eintlik neem hierdie baba stappe. 

Nou, snare is nie almal wat nuttig vir hulleself. Ons wil eintlik, ideaal, soos om het iets anders in ons toolkit. So laat ons eintlik presies dit te doen. 

Laat my tog gaan voort en sweep 'n effens ander program. En ons sal dit int.c noem, vir heelgetal. Ek gaan, op soortgelyke wyse, sluit CS550.h. Ek gaan standaard IO sluit. En wat gaan redelik algemeen te wees in hierdie eerste paar dae van die klas. 

En ek gaan gereed myself met 'n hooffunksie. En nou in plaas van om 'n string, Kom ons gaan voort en kry 'n int. Kom ons noem dit miskien ek, en noem dit kry int, naby hakies, kommapunt. En nou kom ons doen iets daarmee, printf. 

Kom ons sê iets soos hello, agteroorskuinsstreep N, komma i. So ek pretty much naboots wat ek gedoen het net 'n oomblik gelede. Ek het 'n plekhouer hier. Ek moet kook Ek hier komma, want ek wil om i prop in daardie plekhouer. 

So laat ons gaan voort en probeer opstel van hierdie program. Die lêer genoem int.c. So ek gaan om te sê, maak int, betree. O my God, maar daar is geen big deal nie, reg? Daar is 'n fout. 

Daar is 'n sintaktiese fout hier so dat die program kan nie saamgestel word binne int.c, lyn sewe, karakter 27, fout-formaat spesifiseer tipe char ster, wat dit ook al is. Maar die argument tipe is Int. 

So hier ook ons ​​gaan nie aan- selfs al is vandag 'n baie materiaal, ons gaan jou oorweldig met absoluut elke kenmerk van C, en programmering meer algemeen, in net hierdie eerste paar weke. Daar is dus dikwels gaan wees jargon waarmee jy nie vertroud is. En, in werklikheid, kar ster is iets ons gaan om terug te kom na in 'n week of twee se tyd. 

Maar vir nou, laat ons kyk of ons kan ontleed woorde wat vertroud is. Formate- so hoor ons formaat specific, formaat kode voor. Dit is bekend. Type-- maar die argument verloor tipe int. Wag 'n bietjie, ek is 'n int. 

Miskien persent s eintlik het 'n paar gedefinieer betekenis. En, inderdaad, dit doen. 'N heelgetal, as jy wil printf om dit te vervang, jy eintlik 'n gebruik verskillende formaat specific. En jy sal nie weet nie tensy iemand jou vertel, of jy het dit voorheen gedoen. Maar persent Ek is wat kan algemeen gebruik word in printf vir die steek in 'n heelgetal. Jy kan ook gebruik persent D vir 'n desimale heelgetal. Maar ek is mooi en eenvoudig hier. So ons gaan met dit. 

Nou kan ek gaan voort en tik maak int, Tik. Dis goed, geen foute. Dot streep int-- OK, slegte gebruikers ervaring, omdat ek myself nie gesê het wat om te doen. Maar dit is goed. Ek vang op vinnig. 

En nou dat ek kan gaan voort en tik in Dawid, OK, Zamila, Rob. OK, so dit is 'n goeie ding. Hierdie keer, ek gebruik 'n funksie, 'n legkaart stuk, genaamd get Int. En dit blyk out-- en ons sal sien dit later in die term-- die CS50 personeel geïmplementeer kry string in so 'n manier dat dit sal eers fisies kry 'n string vir jou. 

Dit het get int geïmplementeer in so 'n manier dat dit sal slegs kry 'n heelgetal vir jou. En as jy, die mens, nie saamwerk nie, dis letterlik net gaan sê weer probeer, weer probeer, weer probeer, letterlik sit daar herhaling, totdat jy dwing met 'n paar magiese getal, soos 50, en hallo 50. 

Of as ons hardloop dit weer en tik 42, hello 42. En so het die get int funksie binnekant van daardie legkaart stuk is genoeg logika, genoeg gedagte, om uit te vind, wat is 'n woord? En wat is 'n nommer? Slegs die aanvaarding uiteindelik getalle. 

So dit blyk dat hierdie is nie alles wat ekspressiewe. sover. So, yay, laaste keer dat ons het redelik vinnig in die uitvoering van speletjies, en animasie, en artistieke werke in Scratch. En hier, ons word inhoud met Hello World, en hallo 50. 

Dit is nie al wat inspirerend. En, inderdaad, hierdie eerste paar voorbeelde sal 'n tyd neem om te oprit in opgewondenheid. Maar ons het soveel meer beheer nou, in werklikheid. En ons gaan baie vinnig begin gelaagdheid op die top van hierdie basiese primitiewes. 

Maar eers, laat ons verstaan wat die beperkings is. Trouens, een van die dinge Kras nie maklik Laat ons doen is regtig kyk onder die enjinkap, en te verstaan ​​wat 'n rekenaar is, wat dit kan doen, en wat sy beperkinge is. En, inderdaad, dat 'n gebrek aan begrip, potensieel, langtermyn kan lei tot ons eie mistakes-- skryf foute, skryf onseker sagteware wat kry gekap in een of ander manier. 

So laat ons neem 'n paar stappe in die rigting van verstaan ​​dit 'n bietjie beter deur manier van sê, die volgende voorbeeld. Ek gaan om voort te gaan en te implementeer werklike vinnige 'n program genaamd basilisk. Soos, laat ons 'n paar nommers saam te voeg. En ek gaan 'n paar hoeke kodeer hier, en net kopieer en plak waar ek was voor, net sodat ons kan kry gouer gaan. So nou het ek die basiese begin het van 'n program genaamd basilisk. 

En laat ons gaan voort en doen dit. Ek gaan om voort te gaan en sê, intx kry kry Int. En weet jy wat? Kom ons maak 'n beter gebruikers ervaring. 

So laat ons net sê x is, en effektief gevra die gebruiker in staat om ons x gee. En dan laat ek gaan voort en sê: printf Hoe gaan dit met y is, hierdie keer verwag twee waardes van die gebruiker. En dan laat ons net voort te gaan en sê, printf, die som van x en y is. En nou weet ek nie wil persent s doen. Ek wil persent ek doen, agteroorskuinsstreep N, en dan prop in som waarde. 

So, hoe kan ek te werk gaan om dit te doen? Jy weet wat? Ek weet hoe om veranderlikes te gebruik. Laat my net te verklaar 'n nuwe een, int Z. 

En ek gaan 'n raaiskoot hier neem. Indien daar gelyke tekens in hierdie taal, miskien kan ek net x plus y doen, so lank as wat ek my gedink met 'n kommapunt? Nou kan ek teruggaan hier af, prop in Z, voltooi hierdie gedagte met 'n kommapunt. En laat ons sien nou, as hierdie rye van lines-- x kry Int. Y is kry Int. 

Voeg x en y, slaan die waarde in z-- so, weer, onthou die gelyk teken is nie reg nie. Dis opdrag van regs na links. En laat ons uit te druk dat die som van x en y is nie letterlik Z, maar wat is binnekant van Z. So kom ons maak Adder - mooi, geen foute hierdie tyd. Dot streep Adder, betree, x gaan wees 1. 

Y gaan wees 2. En die som van x en y is 3. So dit is alles goed en wel. 

So jy sou dink dat wiskunde moet werk in 'n program soos hierdie. Maar jy weet wat? Is dit veranderlike, lyn 12, selfs nodig? Jy hoef nie in die gewoonte te kom van net die stoor van dinge in veranderlikes net omdat jy kan. En, in werklikheid, is dit oor die algemeen beskou as slegte ontwerp As jy is die skep van 'n veranderlike, genoem Z in hierdie geval, die stoor van iets in dit, en dan onmiddellik gebruik dit, maar nooit weer. Hoekom gee iets 'n naam soos Z as jy letterlik gaan gebruik wat ding net een keer, en so proksimaal tot waar jy geskape dit in die eerste plek, so naby in terme van reëls van die kode? So jy weet wat? Dit blyk dat C is redelik buigsaam. As ek wil eintlik aan plug-in waardes hier, Ek het nie nodig om 'n nuwe veranderlike verklaar. Ek kon net plug-in x plus y, want C verstaan rekenkundige en wiskundige operateurs. 

So kan ek net sê, doen dit wiskunde, x plus y, wat ook al die waardes is, prop die gevolglike heelgetal in daardie string. So dit kan wees, maar slegs een lyn korter, 'n beter ontwerp, 'n beter program, want daar is minder kode, dus minder vir my om te verstaan. En dit is ook net skoner, sover ons nie die bekendstelling van nuwe woorde, nuwe simbole, soos Z, selfs al is hulle nie regtig dien veel van 'n doel. 

Ongelukkig wiskunde is nie alles wat betroubaar soms. Kom ons gaan voort en doen dit. Ek gaan om voort te gaan nou en doen die volgende. 

Kom ons doen printf, persent i, plus persent Ek sal persent i, agteroorskuinsstreep N wees. En ek gaan this-- xyx plus y doen. So ek gaan net om te herskryf hierdie effens anders hier. Laat my net te doen 'n vinnige gesonde verstand tjek. Weereens, laat ons nie voor ons kry. Maak adder, dot streep basilisk. x is 1, y is 2, 1 en 2 is 3. So dit is 'n goeie. Maar laat ons nou bemoeilik hierdie 'n bietjie, en die skep van 'n nuwe lêer. 

Ek gaan hierdie een te roep, sê, SY, meervoud vir heelgetalle. Laat my begin waar ek 'n oomblik gelede was. Maar nou kom ons doen 'n paar ander lyne. Laat my gaan voort en doen die volgende, printf, persent i, minus persent i, is persent i, komma x, komma yx minus y. Dus is ek effens doen verskillende wiskunde is daar. Kom ons doen 'n ander een. So persent i keer persent Ek is persent i, agteroorskuinsstreep N. Kom ons plug-in x en y, en x keer y. Ons sal die asterisk gebruik op jou rekenaar vir tye. 

Jy hoef nie te gebruik x. x is 'n veranderlike naam hier. Jy gebruik die ster vir vermenigvuldiging. Kom ons doen 'n baie meer. Printf persent ek, verdeel deur persent i, is persent i, agteroorskuinsstreep N. xy gedeel deur y-- sodat jy die slash in C gebruik om verdeeldheid te doen. En laat ons nie een ander. Res van persent i, verdeel deur persent i, is persent i. xy-- en nou restant is wat oorgebly het. As jy probeer verdeel 'n deler op 'n teller, hoeveel oorbly wat jy kan nie verdeel word? 

Daar is dus nie regtig nie, noodwendig, 'n simbool Ons het in graad skool hiervoor gebruik. Maar daar in C. Jy kan sê x modulo y, waar hierdie persent teken in hierdie context-- verwarrend wanneer jy binne-in van die dubbele aanhalingstekens, binnekant van printf, persent word gebruik as die formaat specific. 

Wanneer jy gebruik persent buite wat in 'n wiskundige uitdrukking, dis die modulo operateur vir modulêre arithmetic-- vir ons doeleindes hier, net beteken, wat is die res van x gedeel deur y? So x gedeel deur y x streep y. Wat is die res van x gedeel deur y? Dis x mod y, as 'n programmeerder sou sê. 

So as ek nie foute hier gemaak, laat my gaan voort en maak SY, meervoud, mooi, en dot streep SY. En laat ons gaan voort en doen, kom ons sê, 1, 10. Goed, 1 plus 10 is 11, tjek. 1 minus 10 negatief 9, na te gaan. 

1 keer 10 10, tjek. 1 gedeel deur 10 is-- OK, ons sal dit een slaan. Restant van 1 gedeel deur 10 is 1. Dit is korrek. Maar daar is 'n fout in hier. 

So het die een wat ek het my oorhandig, nie korrek nie. Ek bedoel, dit is naby aan 0. 1 gedeel deur 10, jy weet, as ons sny 'n paar hoeke, seker, dit is zero. Maar dit moet regtig wees 10/1, 0.1, of 0.10, 0,1000, of dies meer. 

Dit moet regtig nie nul wees. Wel, dit blyk dat die rekenaar is doen letterlik wat ons vertel om dit te doen. Ons doen wiskunde soos x gedeel deur y. En beide x en y, volgens die lyne van-kode vroeër, heelgetalle. 

Verder, op die lyn 15, ons is vertel printf, hey, printf plug-in 'n heelgetal, plug-in 'n heelgetal, plug-in 'n integer-- spesifiek x, en dan y, en dan x gedeel deur y. x en y is SY. Ons is daar 'n goeie. 

Maar wat is x gedeel deur x? x gedeel deur y moet wees, wiskundig, 10/01, of 0.1, wat 'n reële getal, 'n reële getal met, potensieel, 'n desimale punt. Dit is nie 'n heelgetal. 

Maar wat is die naaste heelgetal tot 10/01, of 0.1? Ja, dit soort van nul. 0.1 is soos volg veel. En 1 is dit baie. So 1/10 is nader aan 0 as wat dit is om 'n. 

En so what C doen vir us-- soort, want ons het dit aan- is truncating dat heelgetal. Dit neem die waarde, wat weer is veronderstel om iets soos 0,1000 wees, 0 en dies meer. En dit is truncating alles nadat die desimale punt sodat al hierdie dinge dinge, omdat dit nie gebeur nie pas in die idee van 'n heelgetal, wat is net 'n nommer soos negatiewe 1, 0, 1, op en af, dit gooi alles weg nadat die desimale punt omdat jy kan nie inpas n desimale punt in 'n heelgetal per definisie. 

So die antwoord hier is nul. So hoe kan ons dit regmaak? Ons moet 'n ander oplossing almal saam. En ons kan dit doen, soos volg. 

Laat my gaan voort en 'n nuwe lêer, die een wat geroep is floats.c. En stoor dit hier in die dieselfde gids, float.c. En laat ek gaan voort en kopieer sommige van daardie kode van vroeër. 

Maar in plaas van om 'n int, laat ons dit doen. Gee my 'n drywende punt waarde genoem x. waar 'n drywende punt waarde is net letterlik iets met 'n drywende punt. Dit kan skuif na links, na regs. Dit is 'n reële getal. 

En laat my nie bel kry int, maar kry vlot, wat ook onder die spyskaart van opsies in die C250 biblioteek. Kom ons y verander na 'n float. So dit raak te kry float. 

En nou, ons wil nie aan te sluit in SY. Dit blyk ons ​​persent gebruik f vir float, persent f vir float, en nou stoor dit. En nou, vingers gekruis, maak dryf, mooi, dot streep dryf. x gaan een 1. y Gaan weer 10. 

En, mooi, OK my Daarbenewens is korrek. Ek het gehoop vir meer, maar ek het vergeet om dit te skryf. So laat ons gaan en dit regmaak logiese fout. 

Kom ons gaan voort en gryp die volgende. Ons sal net 'n bietjie kopieer en plak nie. En ek gaan minus sê. 

En ek gaan keer sê. En ek gaan om te sê verdeel. En ek is nie van plan om te doen modulo, wat is nie so related hier, gedeel deur f, en keer plus-- OK, kom ons dit weer doen. 

Maak dryf, dot streep dryf, en 1, 10, and-- mooi, nee, OK. So ek is 'n idioot. So dit is baie algemeen in rekenaarwetenskap om dom foute soos hierdie maak. 

Vir opvoedkundige doeleindes, wat ek regtig wou doen is hier die wetenskap verander om plus, minus, om tye, en om hopelik te verdeel, soos jy opgemerk tydens hierdie oefening. So nou kom ons weer saam te stel hierdie program, doen dot streep dryf. 

En vir die derde keer, kom ons kyk of dit voldoen aan al my verwagtinge. 1, 10, betree, ja, OK, 1.000, gedeel deur 10.000, is 0,100000. En dit blyk ons ​​kan beheer hoeveel getalle is ná dié desimale punte. Ons sal werklik. Ons sal terug kom. 

Maar nou, in werklikheid, die wiskunde is korrek. So, weer, wat is die afhaal hier? Dit blyk dat in C, is daar nie net strings-- en, in werklikheid, Daar is nie regtig nie, want ons voeg diegene met die CS50 biblioteek. Maar daar is nie net SY. 

Daar is ook dryf. En dit blyk 'n klomp van die ander data tipes ook dat ons sal gebruik kort voor lank. Turns out as jy wil 'n enkele karakter, nie 'n string karakters, jy kan net 'n kar gebruik. 

Blyk dat as jy 'n Bool wil, 'n Boole waarde, waar of onwaar is net, te danke aan die CS50 biblioteek, ons het bygevoeg om C die Bool datatipe sowel. Maar dit is ook teenwoordig in baie ander tale. En dit blyk dat jy soms moet groter getalle kom dan by verstek met SY en dryf. 

En, in werklikheid, 'n dubbele is 'n aantal wat gebruik maak van nie 32 stukkies, maar 64 stukkies. En 'n lang lang is 'n getal wat gebruik nie 32, stukkies, maar 64 stukkies, onderskeidelik, vir drywende punt waardes en heelgetalle, onderskeidelik. So laat ons eintlik nou sien dit in aksie. 

Ek gaan hier voort te gaan en sweep een ander program. Hier, ek gaan om voort te gaan en moenie sluit CS50.h. En laat my gaan, sluit in standaard IO.h. 

En jy sal iets sien funky hier gebeur. Dit is nie kleurkodering dinge in op dieselfde manier as dit gedoen het voor. En dit blyk dat dit is omdat ek het die ding 'n lêer naam nie gegee nie. 

Ek gaan hierdie een te roep sizeof.c, en druk Stoor. Kyk wat gebeur met my baie wit-kode teen daardie swart agtergrond. Nou, ten minste is daar ' sommige pers in daar. En dit is sintaksis uitgelig. 

Dit is omdat, heel eenvoudig, ek het vertel die IO watter tipe lêer dit is deur te gee dit 'n naam, en spesifiek 'n lêer uitbreiding. Nou, laat ons gaan voort en doen dit. Ek gaan voort en baie gaan eenvoudig druk die following-- Bool is persent LU. 

Ons sal terugkom na wat in net 'n oomblik. En dan gaan ek Druk grootte van Bool. En nou, net om te spaar myself 'n geruime tyd, ek is gaan 'n hele doen n klomp van hierdie in 'n keer. En, spesifiek, ek gaan verander dit na 'n kar en kar. Hierdie een, ek gaan om te verander 'n dubbel en 'n dubbele. 

Hierdie een, ek gaan om te verander 'n float en 'n float. Hierdie een, ek gaan verander na 'n int en 'n int. En hierdie een, ek gaan om te verander na 'n lang lang. En dit is nog steeds neem 'n lang tyd, lank lank. 

En dan, laastens, het ek myself een te veel, string. Dit blyk dat in C, daar is die spesiale operateur genoem grootte van wat letterlik gaan, wanneer loop, vertel ons die grootte van elk van hierdie veranderlikes. En dit is 'n manier, nou, ons kan terug te koppel om bespreking verlede week se van data en voorstellings. 

Laat my gaan voort en stel grootte van dot streep grootte van. En laat ons sien. Dit blyk dat in C, spesifiek op CS50 IDE, spesifiek op die bedryfstelsel Ubuntu, wat 'n 64-bit operating stelsel in hierdie geval, 'n Bool gaan Gebruik een byte aan ruimte. Dit is hoe grootte word gemeet, nie in stukkies, maar in grepe. En onthou dat een byte is agt stukkies. So 'n Bool, selfs al is jy tegnies net 'n 0 of 1, dit is 'n bietjie verkwistende hoe ons dit het geïmplementeer. Dit is eintlik van plan om 'n hele te gebruik byte-- sodat almal nulle, is miskien al kinders, of iets soos dit, of net 'n 1 onder agt stukkies. 

A kar, intussen, wat gebruik word vir 'n karakter soos 'n ASCII karakter per verlede week, gaan een karakter wees. En dit synchs met ons idee van dat dit nie meer as 256 bits-- eerder, synchs met dit wat nie langer as 8 stukkies, wat gee ons soveel as 256 waardes. 'N Dubbele gaan wees 8 grepe of 64 stukkies. 

'N float is 4. 'N int is 4. 'N Lang, lang is 8. En 'n string is 8. Maar moenie bekommerd wees oor dit. Ons gaan terug skil wat laag. Dit blyk, snare kan langer as 8 grepe. 

En, inderdaad, ons het geskryf snare reeds, hello world, langer as 8 grepe. Maar ons sal terug te kom na wat in net 'n oomblik. Maar die neem weg hier is die volgende. 

Enige rekenaar het slegs 'n beperkte hoeveelheid geheue en ruimte. Jy kan net stoor soveel lêers op jou Mac of PC. Jy kan net soveel programme in te stoor RAM hardloop in 'n keer, noodwendig, selfs met virtuele geheue, want jy het 'n beperkte hoeveelheid RAM. 

En net om picture-- as wat jy nog nooit oopgemaak 'n skootrekenaar of bestel ekstra geheue vir 'n rekenaar, jy dalk nie weet dat binnekant van jou rekenaar is iets wat lyk 'n bietjie soos hierdie. So dit is net 'n gewone maatskappy met die naam Noodsaaklik dat maak RAM vir rekenaars. En RAM is waar programme leef terwyl hulle loop. 

So op elke Mac of PC, wanneer jy dubbel klik op 'n program, en dit maak ', en dit maak 'n paar Word dokument of iets soos dit, dit slaan dit tydelik in RAM, want RAM is vinniger as jou hardeskyf, of jou vaste toestand skyf. So dit is net waar programme gaan om te lewe as hulle loop, of wanneer lêers word gebruik. 

So jy dinge wat lyk soos hierdie binnekant van jou laptop, of effens groter dinge binnekant van jou lessenaar. Maar die belangrikste is jy net 'n eindige aantal van hierdie dinge. En daar is slegs 'n beperkte hoeveelheid hardeware sit op hierdie lessenaar reg hier. 

So, sekerlik, ons kan nie stoor oneindig lang nommers. En tog, as jy dink terug aan graad skool, hoeveel syfers kan jy moet die regte van 'n desimale punt? Vir daardie saak, hoeveel syfers kan jy aan die linkerkant van 'n desimale punt? Regtig, oneindig baie. 

Nou, kan ons net die mens weet hoe om miljoen spreek, en miljard, triljoen, en quadriljoen, en quintillion. En ek stoot die grense van my understanding-- of my-- Ek verstaan getalle, maar my uitspraak van getalle. Maar hulle kan kry oneindig groot met oneindig baie syfers aan die linkerkant of aan die regterkant van 'n desimale punt. 

Maar rekenaars het net 'n eindige hoeveelheid geheue, 'n beperkte aantal transistors, 'n eindige aantal gloeilampe binnekant. So, wat gebeur wanneer jy uit die ruimte uit te voer? Met ander woorde, as jy dink terug aan verlede week toe ons gepraat oor getalle self word verteenwoordig in binêre, veronderstel dat ons het hierdie 8-bit waarde hier. 

En ons het sewe 1 en een 0. En veronderstel dat ons wil 1 by hierdie waarde. Dit is werklik 'n groot aantal nou. 

Dit is 254, as ek reg onthou die wiskunde van verlede week reg. Maar wat as ek verander dat regterkantste 0 tot 'n 1? Die hele getal van Natuurlik word agt 1 se. So ons is nog steeds goed. 

En dit waarskynlik verteenwoordig 255, al na gelang van konteks Dit kan eintlik verteenwoordig 'n negatiewe getal. Maar meer oor dit 'n ander tyd. Dit voel soos dit gaan oor so hoog as wat ek kan tel. 

Nou, dit is net 8 stukkies. En my Mac, sekerlik, het manier meer as 8 stukkies geheue. Maar dit het nie eindig. So het die Dieselfde argument geld, selfs al is ons meer van hierdie mense op die skerm. 

Maar wat gebeur as jy stoor hierdie nommer, 255, en jy wil 1 bietjie hoër tel? Jy wil gaan 255-256. Die probleem is natuurlik dat as jy begin tel op nul soos verlede week, jy kan nie so hoog tel as 256, laat staan ​​257 laat staan ​​nog 258 m want wat gebeur wanneer jy 'n 1 voeg? As jy dit doen die ou laerskool benadering, het jy 'n 1 hier, en dan 1 plus 1 is 2, maar dit is regtig 'n nul, jy dra die 1, voer die 1, dra die 1. Al hierdie dinge, hierdie 1'e, gaan na nul. En jy likwideer, ja, as iemand uitgewys, 'n 1 op die linkerkant. Maar alles wat jy kan eintlik sien en pas in die geheue is net agt 0 se wat om te sê op 'n stadium as jy, 'n rekenaar, probeer tel hoog genoeg op, jy gaan rond draai, wil dit voorkom, aan nul, of dalk selfs negatiewe getalle, wat selfs laer as nul is. 

En ons kan soort van sien. Laat my gaan voort en skryf 'n ware vinnige program hier. Laat my gaan voort en skryf 'n program genaamd oorloop. Sluit CS50.h, sluit standaard IO.h-- O, Ek het regtig gemis my accentuering. So laat ons hierdie save as overflow.c. 

En nou int main void-- en kort voor lank is, sal ons kom terug na wat verduidelik waarom Ons hou skryf int main leemte. Maar vir nou, laat ons net doen dit, neem dit as vanselfsprekend aanvaar. Kom ons gee myself 'n int, en inisialiseer dit tot 0. 

Kom ons doen dan vir int i kry zero-- eintlik, laat ons doen 'n oneindige lus en kyk wat gebeur. Terwyl waar is, dan kom ons N druk is persent i, agteroorskuinsstreep N, plug-in N. Maar, nou, laat ons doen n kry n plus 1. 

So met ander woorde, op elke iterasie van hierdie oneindige lus, Kom ons neem waarde N se en voeg 1 tot dit, en dan stoor die resultaat terug in N aan die linkerkant. En, in werklikheid, ons het sintaksis gesien effens soos hierdie, kortliks. 'N koel truuk is in plaas van al hierdie dinge uitskryf, jy kan eintlik sê 'n N plus gelyk 1. 

Of as jy regtig wil fancy te wees, jy kan sê N plus plus kommapunt. Maar hierdie laaste twee is net wat ons sintaktiese suiker sou noem vir die eerste ding. 

Die eerste ding is meer eksplisiete, heeltemal fyn, heeltemal korrek. Maar dit is meer algemeen, sal ek sê. So sal ons dit vir 'n oomblik doen. 

Kom ons maak oorloop, wat klink nogal onheilspellend, dot streep oorloop. Kom ons kyk, N raak redelik groot. Maar laat ons dink, hoe groot kan N kry? 

N is 'n int. Ons het 'n oomblik gelede met die grootte van voorbeeld wat 'n int is vier grepe. Ons weet uit verlede week, vier grepe is 32 stukkies, want 8 keer 4, dit is 32. Dit gaan wees 4 miljard. 

En ons is tot 800,000. Dit gaan vir ewig neem om tel so hoog as wat ek moontlik kan. So ek gaan om voort te gaan, Soos jy kan kort voor lank, en druk beheer C-- eerlik, beheer C, 'n baie, waar beheer C algemeen middel kanselleer. Ongelukkig, as gevolg van hierdie loop in die wolk, somtyds was die wolk is spoeg uit soveel dinge, soveel uitset, gaan dit neem 'n kort rukkie vir my insette om die wolk te kry. So selfs al het ek getref Beheer C 'n paar sekondes gelede dit is beslis die kant effek van 'n oneindige lus. 

En so in sulke gevalle, ons is gaan laat dit wees. En ons gaan na 'n ander te voeg terminale venster hier met die plus, wat natuurlik nie doen so nie, want dit is nog steeds dink. En laat ons gaan voort en wees 'n bietjie meer redelik is. 

Ek gaan om voort te gaan en te doen dit slegs eindig baie keer. Kom ons gebruik 'n for-lus, wat ek verwys na vroeër. Kom ons doen dit. Gee my 'n ander veranderlike int i kry 0. Ek is minder as, kom ons sê, 64 I ++. Laat My dan nou voort te gaan en uit te druk uit N is persent i, komma N. En dan n-- dit is nog steeds vir ewig gaan neem. Kom ons doen dit. 

N kry n keer 2. Of ons kan fancy wees en doen tye gelyk 2. Maar laat ons net sê N gelyk self, keer 2. Met ander woorde, in hierdie nuwe weergawe van die program, Ek wil nie vir ewig wag uit soos 800,000 tot 4 miljard. Kom ons kry dit oor met. 

Kom ons eintlik dubbel N elke keer. Wat, onthou, verdubbeling is die teenoorgestelde van wat natuurlik. En terwyl verlede week het ons weer iets, en weer, en weer, super vinnig, verdubbeling sal sekerlik kry ons van 1 tot die grootste moontlike waarde wat ons kan reken op 'n int. 

So laat ons doen presies dit. En ons sal terug kom kort voor lank. Maar dit, weer, is net soos die herhaling blok in Scratch. En jy sal dit gebruik voor lank. 

Dit beteken net telling van nul tot, maar nie gelyk aan 64. En op elke iterasie van hierdie lus, hou net die verhoog i. So ek ++ - en hierdie algemene konstruk on line 7 is net 'n super algemene manier herhaal 'n paar lyne van kode, sommige aantal kere. Watter reëls van die kode? Hierdie krullerige draadjies, as jy dalk opgetel van nou af, beteken, doen die volgende. 

Dit is op dieselfde nuuts af, wanneer dit het die geel blokkies en ander kleure wat soort omhels of drukkie ander blokke. Dit is wat die krullerige draadjies hier doen. So as ek my sintaksis right-- jy kan die wortel simbool in C middel sien dis hoeveel keer ek was probeer om hierdie probleem op te los. So laat ons ontslae te raak van daardie een geheel en al, en sluit dit venster. En ons sal die nuwe een te gebruik. Maak oorloop, dot streep oorloop, Tik, alles reg, dit lyk sleg by die eerste. Maar laat ons blaai terug in die tyd, want Ek het dit 64 keer. 

En sien die eerste keer, N is 1. Tweede keer, N is 2, dan 4, dan 8, dan 16. En dit blyk dat sodra Ek kry min of meer 1 miljard, As ek weer verdubbel dit, wat moet my gee 2000000000. Maar dit blyk, is dit reg op die punt. 

En so is dit eintlik oorloop 'n int uit 1000000000 om min of meer negatief 2 miljard, omdat 'n heelgetal, In teenstelling met die getalle wat ons is verlede week in die veronderstelling, kan beide positief en negatief wees in werklikheid en in 'n rekenaar. En so ten minste een van daardie stukkies is effektief gesteel. So het ons regtig net 31 stukkies, of 2000000000 moontlike waardes. 

Maar vir nou, die afhaal is nogal eenvoudig, ongeag hierdie getalle is en alles wat die wiskunde is, iets sleg gebeur uiteindelik, want uiteindelik jy probeer om verwisselen die stukkies een te veel keer. En jy effektief gaan van al 1 se miskien al 0 se, of miskien slegs 'n paar ander patroon dat dit Dit is duidelik dat, afhangende van konteks, kan geïnterpreteer word as 'n negatiewe getal. En so sal dit die hoogste dit lyk asof ek kan reken in hierdie spesifieke program is slegs ongeveer 1000000000. Maar daar is 'n gedeeltelike oplossing hier. Jy weet wat? 

Laat my verander van 'n int om 'n lang lang. En laat my hier gaan voort en say-- ek gaan hê om dit te verander na 'n unsigned long. Of, kom ons kyk, ek onthou nog nooit. 

Kom ons gaan voort en maak oorloop. Nee, dis nie dit, LLD, dankie. So soms klang kan nuttig wees. Ek het nie onthou wat die formaat specific was vir 'n lang lang. 

Maar, inderdaad, klang het vir my gesê. Groen is 'n soort van 'n goeie, steeds beteken dat jy 'n fout gemaak. Dit is aan die raai dat ek bedoel LLD. 

So laat my toe om dit advies, 'n lang lank desimale getal, behalwe dat. En laat ek tik dit, dot streep loop, Tik. En nou wat is cool is dit. 

As ek terug in die tyd te blaai, het ons nog begin tel op dieselfde place-- 1, 2, 4, 8, 16. Let op, kry ons al die pad tot by 1000000000. Maar dan moet ons veilig tot 2 miljard. 

Dan kom ons by 4000000000, dan 8 miljard, 17000000000. En ons gaan hoër en hoër, en hoër. Uiteindelik, dit ook breek. 

Uiteindelik, met 'n lang lang, wat is die 64-bit waarde, nie 'n 32-bit waarde, as jy reken te hoog is, draai jy rond 0. En in hierdie geval, gebeur ons eindig met 'n negatiewe getal. 

So dit is 'n probleem. En dit blyk dat hierdie probleem is nie alles wat arcane. Selfs al het ek het doelbewus veroorsaak dit met hierdie foute, dit blyk ons ​​sien dit soort van alle rondom ons, of ten minste 'n paar van ons doen. 

So in Lego Star Wars, as jy al ooit die spel gespeel het, dit blyk jy kan gaan rond breek dinge in LEGO wêreld, en die invordering van muntstukke, in wese. En as jy al ooit gespeel hierdie wedstryd te veel tyd, aangesien dit naamlose individuele hier het, die totale aantal munte wat jy kan in te samel is, wil dit voorkom asof, 4 miljard. 

Nou, met dit is eintlik afgerond. So LEGO probeer hou dinge gebruikersvriendelik. Hulle het dit nie presies doen 2 tot die 32 krag, per verlede week. Maar 4000000000 is 'n rede. Dit blyk, gebaseer op hierdie inligting, dat LEGO, en die maatskappy wat het hierdie werklike sagteware, besluit dat die maksimum aantal munte die gebruiker kan ophoop is inderdaad, 4 miljard, omdat hulle gekies het in hul kode nie 'n lang lang om te gebruik, glo, maar net 'n heelgetal, 'n ongetekende heelgetal, slegs 'n positiewe heelgetal, wie se Max waarde is min of meer wat. Wel, hier is nog 'n snaakse een. So in die spel Civilization, wat sommige van julle dalk vertroud wees met dit blyk dat jare gelede daar was 'n fout in hierdie wedstryd waarby As jy die rol van Gandhi in die spel, in plaas van hom dat dit baie pasifis, plaas was ongelooflik, ongelooflik aggressiewe, in sekere omstandighede. In die besonder, die manier waarop Civilization werke is dat as jy, die speler, neem demokrasie, jou aggressie telling kry decremented deur twee, so minus minus, en dan minus minus. 

So jy trek 2 uit jou werklike iterating. Ongelukkig, as jou iterating is aanvanklik 1, en jy trek 2 daaruit na die aanneming van demokrasie soos Gandhi hier mag gedoen het, want hy het baie passive-- was 1 op die skaal van aggressie. Maar as hy aanvaar demokrasie, dan Hy gaan van 1 tot negatiewe 1. 

Ongelukkig was hulle gebruik van ongetekende getalle, wat beteken dat hulle behandel selfs negatiewe getalle asof hulle positief. En dit blyk dat die positiewe ekwivalent van negatiewe 1, in tipiese rekenaarprogramme, is 255. So as Gandhi neem demokrasie het, en dus sy aggressie telling verminder, dit eintlik rolle om te 255 en maak hom die mees aggressiewe karakter in die spel. So jy kan Google op hierdie punt. En dit was inderdaad 'n toevallige programmering fout, maar dit is nogal ingevoer die leersaamhede sedertdien. 

Dit is al wat pret en cute. Meer skrikwekkend is wanneer werklike werklike wêreld toestelle, en nie speletjies, het hierdie selfde foute. Trouens, net 'n jaar gelede 'n artikel het uit oor die Boeing 787 Dreamliner. 

En die artikel op die eerste oogopslag lees 'n bietjie arcane. Maar dit gesê het, 'n sagteware kwesbaarheid in Boeing se nuwe 787 Dreamliner straler het die potensiaal om vlieëniers veroorsaak om beheer oor te verloor die vliegtuig, moontlik in die middel van die vlug, die FAA-amptenare gewaarsku aanbied onlangs. Dit was die bepaling dat 'n model 787 vliegtuig wat is aangedryf voortdurend vir 248 dae kan al wisselstroom verloor, AC, elektriese krag as gevolg van die kragopwekker beheer eenhede, GCUs, gelyktydig gaan in gebreke bly veilige modus. Dit is soort van my verloor. Maar die memorandum vermeld, OK, nou het ek dit, die toestand is veroorsaak deur 'n sagteware teen interne om die kragopwekker beheer eenhede wat oorloop na 248 dae van deurlopende krag. Ons is die uitreiking van hierdie kennisgewing aan verlies te voorkom van alle AC elektriese krag, wat tot gevolg kan hê verlies van beheer van die vliegtuig. 

So, letterlik, daar is 'n paar heelgetal, of 'n ekwivalent data tipe, wat gebruik word in sagteware in 'n werklike vliegtuig dat as jy jou vliegtuig te hou lank genoeg, wat blykbaar kan die geval wees as jy net hardloop hulle voortdurend en nooit Skakel jou vliegtuig, dit lyk of laat sy batterye sterf, sal uiteindelik tel op en op, en op, en op, en op, en op. 

En, deur die natuur, 'n eindige hoeveelheid geheue oorloop, om terug te rol tot nul of 'n negatiewe waarde, 'n newe-effek van wat is die skrikwekkend werklike realiteit dat die vliegtuig dalk nodig moet weer begin, effektief, of te laat val, erger, want dit vlieg. So hierdie soort kwessies is nog steeds met ons, even-- dit was 'n 2015 artikel, des te meer vreesaanjaend wanneer jy nie noodwendig verstaan, waardeer, of antisipeer hierdie soort van foute. 

So dit blyk daar is een ander slegte ding oor datavoorstelling. Dit blyk dat selfs dryf is soort gebrekkig, want dryf ook Ek voorgestelde is 32 stukkies, of Miskien 64 As jy 'n dubbele gebruik. Maar dit is nog steeds eindig. 

En die vangs is dat as jy kan sit 'n oneindige aantal getalle nadat die desimale punt daar is geen manier wat jy kan al die moontlike verteenwoordig getalle wat ons geleer in graad skool kan bestaan ​​in die wêreld. 'N Rekenaar, in wese, moet kies 'n subset van die nommers om akkuraat verteenwoordig. 

Nou, die rekenaar kan ronde miskien 'n bietjie, en kan jy toelaat dat rofweg winkel enige nommer wat jy kan moontlik wil. Maar net intuïtief, as jy het 'n beperkte aantal bisse, jy kan dit net verwisselen in so baie beperkte maniere. Sodat jy kan nie moontlik gebruik 'n beperkte aantal van permutasie van stukkies, patrone van nulle en ene, om 'n oneindige verteenwoordig aantal getalle, wat daarop dui dat rekenaars mag baie goed wees lieg vir ons soms. 

Trouens, laat ons dit doen. Laat my terug te gaan na CS50 IO. Laat my gaan voort en skep 'n klein program genoem onakkuraatheid, om te wys dat rekenaars is inderdaad vaag. 

En laat ek gaan voort en begin met sommige van daardie kode voor, en nou net die volgende te doen. Laat my gaan voort en doen printf, persent f, agteroorskuinsstreep N, 1 gedeel deur 10. Met ander woorde, kom ons duik dieper om 10/1, soos 1 en gedeel deur 10. Sekerlik, kan 'n rekenaar verteenwoordig 1/10. 

So laat ons gaan voort en maak onakkuraatheid. Kom ons sien. Formaat spesifiseer tik dubbel. Maar die argument verloor tipe int. Wat gaan aan? 

Ag, interessante, so dit is 'n les geleer uit voor. Ek sê, hey, rekenaar show vir my 'n float met persent f. Maar ek gee dit 2 SY. So dit blyk, kan ek dit regmaak dit in 'n paar maniere. 

Ek kon net draai een in 1.0, en 10 in 10.0, wat, inderdaad, het die uitwerking van die omskakeling hulle in floats-- nog hopelik ewe veel. Of dit blyk daar is iets Ons sal weer sien kort voor lank. Jy kan die getalle gegooi. 

Jy kan, met behulp van hierdie hakies uitdrukking, kan jy sê: hey, rekenaar, neem hierdie 10, wat ek weet, is 'n int. Maar dit te hanteer, asseblief, asof dit 'n float. Maar dit voel onnodig kompleks. 

Vir ons doeleindes vandag, laat ons net letterlik maak hulle swaai punt waardes met 'n desimale punt, soos hierdie. Laat my gaan voort en tik, maak onakkuraatheid, goeie, dot streep onakkuraatheid, betree. OK, ons is op soek goeie. 

1 gedeel deur 10, volgens my Mac hier, is inderdaad 0,100000. Nou, is ek geleer in graad skool daar moet 'n oneindige aantal 0'e wees. So laat ons ten minste probeer om 'n paar van diegene sien. Dit blyk dat printf is 'n bietjie liefhebber steeds as ons het al met behulp. Dit blyk jy hoef nie te spesifiseer net persent f, of net persent i. Jy kan eintlik spesifiseer mate van beheer opsies hier. 

Spesifiek, ek gaan om te sê, hey, printf, eintlik wys my 10 desimale punte. So dit lyk 'n bietjie vreemd. Maar jy sê persent, dot, hoeveel nommers jy wil om te sien na die desimale punt, en dan is f vir plat, net omdat dit is wat die dokumentasie sê. Laat my gaan voort en behalwe dat. 

En sien ook Ek kry moeg van tik dinge. Dus is ek net die opstel van die up en Down Arrow op my sleutels hier. En as ek hou slaan op, jy kan al die gebooie te sien wat ek gemaak het, of verkeerd gemaak. 

En ek gaan nou voort te gaan en nie eintlik gebruik dat, blykbaar. Maak onakkuraatheid, dot streep imprecision-- so wat ek geleer in graad skool tjeks uit. Selfs as ek druk dit tot 10 desimale plaas dit inderdaad is 0,10000. Maar jy weet wat? 

Kom ons kry 'n bietjie gulsig. Kom ons sê, soos, wys my 55 wys na die desimale. Kom ons dit regtig neem program vir 'n spin. Laat my remake met make onakkuraatheid, dot streep, onakkuraatheid. 

En hier gaan ons. Jou kinderdae was 'n leuen. Blykbaar, 1 gedeel deur 10 is inderdaad 0.100000000000000005551115123-- 

Wat gaan aan? Wel, dit blyk dat as jy soort kyk ver genoeg in die onderliggende voorstelling van hierdie nommer, dit eintlik is nie presies 1/10, of 0.1 en 'n oneindige aantal nulle. Nou, hoekom is dit? 

Wel, selfs al is dit 'n eenvoudige aantal vir ons mense, 1 gedeel deur 10, dit is nog steeds een van oneindig baie getalle wat ons kon uitdink. Maar 'n rekenaar kan slegs verteenwoordig eindig baie so nommers. En so, doeltreffend, wat die rekenaar wys ons is sy naaste benadering tot die aantal ons wil om te glo is 10/01, of regtig advertensie 0,10000 infinitum. 

Inteendeel, al is, dit is so na as dit kan kry. En, inderdaad, as jy kyk onder die enjinkap, want ons is hier deur te kyk 55 syfers na die desimale, ons eintlik sien dat die werklikheid. Nou as 'n eenkant, as jy het ' ooit die movie-- gesien die meeste van julle seker haven't-- maar Superman 3 paar jaar gelede, Richard Pryor hierdie wese aged werklikheid in sy maatskappy 'n baie steel van breuke en breuke van pennies, omdat die geselskap as ek reg onthou, dit was 'n while-- wese was weggooi enigiets wat nie pas in die idee van sent. 

Maar as jy optel al hierdie klein, klein, klein getalle weer, en weer, en weer, kan jy, soos in sy saak, maak 'n goeie bedrag van die geld. 

Dieselfde idee is afgeruk deur 'n meer onlangse, maar nog steeds nou ouer fliek, genaamd kantoorruimte, waar die ouens in die fliek, het dieselfde ding, geskroef dit op heeltemal, beland met heeltemal te veel geld in hul bankrekening. Dit was alles baie verdag. Maar aan die einde van die dag, onakkuraatheid is oral om ons. 

En dit is ook kan wees skrikwekkend die geval. Dit blyk dat Superman 3 en kantoorspasie ter syde stel, daar kan 'n paar baie werklike wêreld gevolge van die realiteite van vaag voorstelling van data dat selfs ons mense te vandag beveel nie noodwendig verstaan ​​asook ons ​​moet, of onthou so dikwels as ons moet. En, inderdaad, die volgende clip is uit 'n blik op 'n paar baie werklike wêreld gevolge van wat gebeur as jy nie waardeer die onakkuraatheid wat kan gebeur in getalle verteenwoordiging. 

[Video speel] 

-Computers, Ons het al begin aanvaar die dikwels frustrerende probleme wat saam met toets-- foute, virusse, en sagteware glitches, vir klein pryse te betaal vir die gerief. Maar in 'n hoë-tegnologie en 'n hoë spoed militêre en ruimteprogram aansoeke, die kleinste probleem Groot in die ongeluk. 

Op 4 Junie 1996, wetenskaplikes bereid om 'n onbemande Ariane 5 raket launch. Dit was die uitvoering van wetenskaplike satelliete ontwerp om presies hoe die vestig aarde se magneetveld interaksie met sonkrag winde. Die vuurpyl is gebou vir die Europese Ruimte-agentskap, en gelig van sy fasiliteit aan die kus van Frans-Guyana. 

-Op Sowat 37 sekondes in die vlug, het hulle eerste opgemerk iets verkeerd gaan. Die spuitkoppe is draaibare in 'n manier wat hulle regtig nie. Rondom 40 sekondes in die vlug, Dit is duidelik dat die voertuig was in die moeilikheid. 

En dit is wanneer hulle gemaak 'n besluit om dit te verwoes. Die reeks veiligheidsbeampte, met geweldige guts, druk die knoppie, opgeblaas die vuurpyl voordat dit kon 'n gevaar vir die openbare veiligheid. 

-Dit Was die eerste vaart van die Ariane 5. En sy verwoesting het plaas as gevolg van 'n fout ingebed in sagteware die vuurpyl se. -Die Probleem op die Ariane was dat daar 'n getal wat vereis 64 stukkies uit te druk. En hulle wou omskep dit 'n 16-bis getal. Hulle aanvaar dat die getal is nooit gaan baie groot te wees, dat die meeste van diegene syfers in 'n 64-bis getal was nulle. Hulle was verkeerd. 

-Die Onvermoë van een sagteware program om te aanvaar die aard van die getal wat deur 'n ander was al teen die wortel van die versuim. Sagteware-ontwikkeling het 'n baie duur deel van nuwe tegnologie. Die Ariane vuurpyl het baie gewees suksesvolle, soveel van die sagteware geskep vir dit ook was gebruik in die Ariane 5. 

-Die Basiese probleem is dat die Ariane 5 was vinniger, vinniger vinniger. En die sagteware het nie verantwoordelik vir daardie. 

-Die Vernietiging van die vuurpyl was 'n groot finansiële ramp, al as gevolg van 'n minuut sagteware fout. Maar dit was nie die eerste time data omskakeling probleme het moderne vuurpyl tegnologie geteister. 

-In 1991, met die begin van die eerste Golfoorlog, die Patriot Vuurpyl ervaar 'n soortgelyke soort van getal omskakeling probleem. En as gevolg daarvan, 28 mense, 28 Amerikaanse soldate, gedood, en oor 100 ander gewond, wanneer die Patriot, wat veronderstel was om te beskerm teen die inkomende scuds, versuim het om 'n missiel te vuur. 

-Wanneer Irak Koeweit, en Amerika van stapel gestuur Desert Storm in die vroeë 1991, Patriot missiel batterye ontplooi te beskerm Saoedi-Arabië en Israel uit Irak Scud missiel aanvalle. Die Patriot is 'n Amerikaanse medium-reeks oppervlak te lug stelsel, vervaardig deur die Raytheon maatskappy. 

-Die Grootte van die Patriot Interceptor self is oor ongeveer 20 voet lank. En dit weeg ongeveer 2000 pond. En dit dra 'n plofkop van ongeveer, Ek dink dit is min of meer 150 pond. En die Warhead self is n hoë plofstof, wat het fragmente rondom dit. Die omhulsel van die Warhead is ontwerp om op te tree soos bokhael. 

-Die Missiele gedra vier per houer, en word deur 'n semi sleepwa. 

-Die Patriot anti-missiel-stelsel gaan terug nou ten minste 20 jaar. Dit is oorspronklik ontwerp as 'n lug verdediging missiel skiet vyand vliegtuie. In die eerste Golfoorlog, wanneer die oorlog het saam, die weermag wou om dit te gebruik om skiet scuds, nie vliegtuie. 

Die Irakse lugmag was nie so veel van 'n probleem. Maar die leër was bekommerd oor scuds. En so het hulle probeer om die opgradering van die Patriot. 

-Intercepting 'N vyand missiel wat teen mach 5 gaan word uitdagende genoeg. Maar toe die Patriot is inderhaas na die diens, die weermag was nie bewus van 'n Irakse verandering wat gemaak hul scuds byna onmoontlik om te tref. 

-Wat Gebeur het, is die scuds wat gekom in was onstabiel. Hulle is wiebel. Die rede hiervoor was die Irak, ten einde 600 kilometer te kry uit 'n 300 kilometer afstand missiel, het gewig uit die voorkant Warhead. Hulle het die Warhead ligter. 

So het die Patriot is probeer om die Scud te kom. En die meeste van die tyd, die oorweldigende meerderheid van die tyd, Dit sou net vlieg deur die Scud. Sodra die Patriot-stelsel operateurs besef die Patriot gemis sy teiken, hulle ontplof die Patriot se Warhead om moontlike slagoffers as dit te vermy is toegelaat om op die grond val. 

-dat Was wat die meeste mense sien, die groot vuurballe in die lug, en misverstaan ​​as afsnitte van Scud hoofde. 

-Although In die nag skies, verskyn Patriotte om suksesvol te wees vernietig Scuds, by Dhahran, Daar kan geen fout wees oor sy prestasie. Daar, die Patriot se radarstelsel verlore spoor van 'n inkomende Scud, en nooit van stapel gestuur as gevolg 'n sagteware fout. Dit was die Israeli's wat die eerste keer ontdek dat hoe langer die stelsel was op, hoe groter is die tyd verskil geword het, as gevolg van 'n klok ingesluit in die rekenaar se stelsel. 

-oor Twee weke voor die tragedie in Dhahran, die Israeli's gerapporteer word aan die Departement van verdediging dat die stelsel is tyd verloor. Na ongeveer agt uur of hardloop, Hulle het opgemerk dat die stelsel is besig om merkbaar minder akkuraat. Die Departement van verdediging het gereageer deur vertel al die Patriot batterye om nie die stelsels te verlaat vir 'n lang tyd. Hulle het nooit gesê wat 'n lang tyd was-- agt uur, 10 uur, 1000 ure. Niemand het geweet. 

-Die Patriot battery gestasioneer by die barakke by Dhahran en sy gebrekkige interne klok het meer as 100 uur is op op die aand van 25 Februarie. 

-Dit Nagespoor tyd om 'n akkuraatheid van ongeveer 'n tiende van 'n sekonde. Nou, 'n tiende van 'n sekonde is 'n interessante nommer, want dit kan nie uitgedruk in binêre presies wat beteken dit kan nie presies uitgedruk in enige moderne digitale rekenaar. Dit is moeilik om te glo. 

Maar gebruik dit as 'n voorbeeld. Kom ons neem die nommer een derde plek. Een derde kan nie uitgedruk in desimale presies. Een derde is 0,333 aangaan vir oneindigheid. 

Daar is geen manier om dit te doen met absolute akkuraatheid in desimale. Dit is presies die soort van probleem wat gebeur het in die Patriot. Hoe langer die stelsel hardloop, die erger die tyd fout is. 

-na 100 ure van die operasie, die fout in die tyd was slegs sowat 'n derde van 'n sekonde. Maar in terme van die fokus op 'n missiel wat teen mach 5, Dit het gelei tot 'n dop dwaling van meer as 600 meter. Dit sou 'n fatale fout wees vir die soldate op wat gebeur is 'n Scud bekendstelling was waargeneem deur vroeë waarskuwing satelliete en hulle het geweet dat die Scud was kom in hul algemene rigting. Hulle het nie geweet waar dit vandaan kom. 

-Dit Was nou tot die radar komponent van die Patriot-stelsel verdedig Dhahran op te spoor en te hou spoor van die inkomende vyand missiel. 

-Die Radar was baie slim. Dit sou eintlik dop die posisie van die Scud, en dan voorspel waar dit waarskynlik sou die volgende keer die radar gestuur word 'n pols uit. Dit is 'n reeks hek genoem. 

-Then, Sodra die Patriot besluit genoeg tyd het geslaag om terug te gaan en kyk die volgende plek vir hierdie bespeur voorwerp, Dit gaan terug. So wanneer dit gaan terug na die verkeerde plek, dan sien geen voorwerp. En hy besluit dat daar geen voorwerp, dit was 'n valse opsporing, en daal die spoor. 

-Die Inkomende Scud verdwyn van die radarskerm. En sekondes later, is dit klap in die kamp. Die Scud vermoor 28, en was die laaste een afgevuur tydens die eerste Golfoorlog. 

Dit is tragies dat die opgedateer sagteware aangekom by Dhahran die volgende dag. Die sagteware fout gehad vasgestel, afsluiting een hoofstuk in die onstuimige geskiedenis van die Patriot raket. 

[Video speel] David J. MALAN: So dit is al te sê dat hierdie kwessies van oorloop en onakkuraatheid is al te ware. So, hoe het ons hier? Ons het begin met net praat oor printf. Weereens, dit funksie wat druk iets op die skerm, en ons daarna bekendgestel 'n paar ander funksies van die sogenaamde CS50 se biblioteek. En ons sal voortgaan om te sien hierdie op die regte tyd. En ons, veral, gebruik get string, en kry int, en nou ook vlot, en nog ander nog sal ons teëkom en gebruik onsself voor lank. 

Maar soms, het ons reeds gesien dat 'n behoefte om terug te slaan wat die funksies hand? Hulle oorhandig ons terug 'n string, of 'n int, of 'n float. En soms moet ons dit sit string, of int, of float, iewers. 

En om te hoor slaan, onthou net soos in Scratch, ons het veranderlikes. Maar anders as in Scratch, in C het ons werklike tipes van variables-- data tipes, meer generally-- onder hulle, 'n string, 'n int, 'n dryf, en hierdie ander steeds. 

En so wanneer ons verklaar veranderlikes in C, Ons sal maar moet ons datatipes verklaar. Dit is nie iets wat ons sal moet later doen in die semester as ons die oorgang na ander tale. Maar vir nou, hoef ons 'n priori by voorbaat, verduidelik aan die rekenaar watter tipe veranderlike wil ons dit aan ons gee. 

Nou het intussen te druk diegene soorte datatipes, ons moet vertel printf wat om te verwag. En ons sien persent s vir strykers, en persent ek vir heelgetalle, en 'n paar ander reeds. En dit is net vereistes vir die visuele aanbieding van daardie inligting. 

En elkeen van hierdie kan eintlik wees parametrized of tweaked in een of ander manier, As jy wil beheer te bevorder die tipe uitset wat jy kry. En, in werklikheid, dit blyk dat nie net is daar agteroorskuinsstreep N vir 'n nuwe reël. Daar is iets anders genoem agteroorskuinsstreep r vir 'n return, wat is meer verwant is aan 'n ou skool tikmasjien, en ook Windows gebruik vir baie jare. 

Daar is agteroorskuinsstreep t vir oortjies. Blyk dat as jy wil dubbel kwotasie binnekant van 'n string, Onthou dat ons gebruik dubbel kwotasie dubbel aanhaling op die links en regs eindig van ons snare tot dusver. Dit wil voorkom asof dinge verwar. 

As jy wil 'n dubbel kwotasie in te sit die middel van 'n string-- en, inderdaad, Dit is verwarrend om te sien. En so moet jy om te ontsnap, om so te praat, 'n dubbele kwotasie met iets soos, letterlik, agteroorskuinsstreep dubbel kwotasie. En daar is 'n paar ander nog. En ons sal meer van daardie sien in die werklike gebruik kort voor lank. 

So laat ons nou die oorgang vanaf data, en verteenwoordiging, en rekenkundige operateurs, al waarvan het ons 'n paar gebou blokke waarmee om te speel. Maar nou kom ons eintlik te gee ons die res van die woordeskat dat ons reeds verlede week met Scratch deur die neem van 'n blik op 'n paar ander konstrukte in C-- nie almal van hulle. Maar die idees wat ons is oor te eintlik net sien beklemtoon die vertaling van een taal, Scratch, na 'n ander, C. 

En met verloop van tyd, sal ons haal meer gereedskap vir ons toolkit, so te sê, sintakties. En, inderdaad, sal jy sien dat die idees is nou eerder vertroud van verlede week. So laat ons dit doen. 

Kom ons gaan voort en sweep 'n program wat gebruik maak van eintlik 'n paar uitdrukkings, 'n Boole-uitdrukking. Laat my hier gaan voort en die skep van 'n nuwe lêer. Ek sal hierdie condition.c noem. 

Laat my gaan voort en sluit die CS50 biblioteek. En laat ek gaan voort en sluit standaard IO.h vir ons funksies, en printf, en nog baie meer onderskeidelik. Kom ek gee myself dat boiler van int main leemte, wie se verduideliking ons sal kom terug na die toekoms. 

Nou kan ek gaan voort en gee myself 'n int via get Int. laat my dan voort te gaan en dit te doen. Ek wil om te sê as ek is less-- laat onderskei tussen positiewe, negatiewe, of nul waardes. 

So as ek minder as nul is, laat my moet net hierdie program net sê, negatiewe, agteroorskuinsstreep N, anders As ek is groter as nul. Nou is ek natuurlik gaan om te sê printf positiewe, agteroorskuinsstreep N. En dan anders if-- ek kan dit doen. 

Ek kon doen as ek gelyk 0. Maar ek wil maak op minste een fout reeds. Onthou dat die gelyk teken is nie gelyk, soos ons mense weet dit. 

Maar dit is die opdrag operateur. En ons wil nie te neem 0 op die reg en sit dit in Ek aan die linkerkant. So om hierdie verwarring te voorkom, of miskien misbruik van die gelykaanteken, mense besluit 'n paar jaar gelede wat in baie programmeertale wanneer jy wil om te kyk vir gelykheid tussen die links en regs, jy eintlik gebruik gelyk gelykes. So jy druk op die gelykaanteken twee keer. As jy wil toewys van regs na links, gebruik jy 'n enkele gelykaanteken. So kan ons this-- anders doen As ek gelyk is gelyk aan nul. 

Ek kan dan gaan open my krullerige draadjies, en sê: printf 0, agteroorskuinsstreep N, gedoen. Maar onthou hoe hierdie vurke in die pad kan werk. En regtig, net te dink oor die logika. Ek is 'n aantal. Dit is 'n heelgetal, spesifiek. En dit beteken dat dit gaan minder wees as 0, of groter as 0, of 0. So daar is 'n soort van hierdie geïmpliseerde verstek geval. 

En so kan ons, net soos Kras, wegdoen met die ander as, en net sê anders. Logies, as jy die programmeerder weet daar is net drie emmers waarin 'n scenario kan fall-- die eerste, die tweede, of die derde in hierdie nie case-- doen pla die toevoeging van die bykomende presisie en die addisionele logika daar. Gaan net voort met die standaard geval hier van ander mense. 

Nou, laat ons gaan voort Hierna spaar, maak voorwaardes dot streep conditions-- nie 'n groot gebruikerskoppelvlak, omdat ek nie waarna die gebruiker, soos ek vroeër genoem. Maar dit is goed. Ons sal dit eenvoudig te hou. Kom ons probeer die getal 42. En dit is positief. Kom ons probeer die getal negatiewe 42, negatief. 

Kom ons probeer die waarde 0. En, inderdaad, dit werk. Nou, sal jy sien met probleme voor lang, toetsing dinge drie keer, waarskynlik nie voldoende. Jy wil dalk 'n paar toets groter getalle, 'n kleiner getalle, 'n hoek gevalle, soos ons sal kom om hulle te beskryf. 

Maar vir nou, hierdie is 'n mooi eenvoudige program. En ek is redelik seker dat, logies, dat dit val in drie gevalle. En, inderdaad, selfs al het ons net gefokus op die moontlike nadele van onakkuraatheid en oorloop, in werklikheid waar baie probleme CS50 se ons is nie van plan om te bekommer oor, al die tyd, dié kwessies van oorloop en onakkuraatheid, want, in werklikheid, in C, dit is eintlik nie alles wat maklik om te doen te vermy. As jy wil om te tel tot groter en groter, en groter, dit blyk daar is tegnieke wat jy kan gebruik, wat dikwels dinge genoem biblioteke, versamelings kode, wat ander mense geskryf het wat jy kan gebruik, en ander tale soos Java en ander, eintlik maak dit 'n baie makliker om selfs hoër te tel. So dit is regtig 'n paar van hierdie gevare 'n funksie van die taal wat jy gebruik. En in die komende weke sal ons sien hoe gevaarlik C regtig kan wees as jy dit nie behoorlik gebruik. Maar van daar af, en met Python, en JavaScript, sal Ons laag op 'n paar ekstra beskerming, en loop minder van die risiko's. 

So laat ons 'n bietjie meer interessante logika in ons program. So laat ek gaan voort en skep 'n program genaamd Logiese net sodat ek kan speel met 'n paar werklike logika, logical.c. Ek sal net kopieer en plak 'n paar kode van vroeër so ek terug te kry om hierdie mooi beginpunt. 

Laat my hierdie keer doen char C. Ek is gaan dit 'n naam van C te gee net omdat dit is konvensionele, kry 'n karakter van die gebruiker. En laat ons voorgee soos Ek is die implementering deel van daardie Rm program, die Verwyder program voor wat daartoe gelei dat die gebruiker om 'n lêer te verwyder. Hoe kan ons dit doen? 

Ek wil sê, as C is gelyk aan gelyk, kwotasie unquote, y, dan gaan ek om te aanvaar dat die gebruiker ja gekies. Ek gaan net om te druk ja. As dit is eintlik skryf die verwydering program, Ons kan die lêer verwyder met meer reëls van die kode. Maar ons sal dit eenvoudig te hou. 

Anders as c gelyk gelyk n-- en nou hier, ek gaan om te sê, die gebruiker moet nie beteken het. En dan anders, jy weet wat? Ek weet nie wat anders weet die gebruiker gaan tik. So ek gaan net om te sê dat dit is 'n fout, wat ook al hy of sy eintlik getik. 

So, wat gaan hier aan? Daar is 'n fundamentele verskil teenoor wat ek gedoen het in die verlede. Dubbele aanhalingstekens, dubbele aanhalingstekens, dubbel aanhalings, en, nog, aanhalingstekens, aanhalingstekens. Dit blyk in C, wat toe jy wil 'n string te skryf, jy wel dubbele aanhalingstekens, net soos ons gebruik al die tyd met printf. 

Maar as jy wil om te gaan met net 'n enkele karakter, 'n sogenaamde kar, dan is jy eintlik gebruik aanhalingstekens. Diegene van julle wat het geprogrammeer voor, kan jy nie ' moes bekommer oor hierdie onderskeid in sekere tale. In C, dit maak nie saak. En so toe ek 'n kar te kry en ek wil om daardie kar vergelyk met behulp van gelykes gelyk aan 'n brief soos y of N, ek doen, Inderdaad, moet die aanhalingstekens het. 

Nou, laat ons gaan voort en doen dit. Kom ons gaan voort en maak nie logiese dot streep logies. En nou is ek wat gevra word. So, vermoedelik, 'n beter gebruikers ervaring sou my eintlik sê wat om te doen hier. Maar ek gaan net blindelings sê y vir ja, OK, lekker. 

Kom ons weer uit te voer nie, N vir nee, mooi. Veronderstel soos sekere mense wat ek ken, my Caps Lock is op al te dikwels. So ek doen kapitaal Y, betree, fout. OK, dit is nie presies wat ek verwag het nie. Trouens, die rekenaar is letterlik wat doen Ek het dit aan do-- kyk vir klein y en klein N. Dit voel nie soos 'n goeie gebruikers ervaring, al is. Laat my vra en aanvaar óf kleinletters of hoofletters. So dit blyk, wil jy dalk om iets te sê soos in Scratch, soos letterlik of C is gelyk aan gelyk kapitaal enkele aangehaal y. Blyk, beteken C nie hierdie letterlike navraag of. 

Maar dit het twee vertikale bars. Jy het om te skuif gewoonlik hou, As jy met behulp van 'n Amerikaanse sleutelbord, en druk die vertikale bar sleutel bo jou terugkeer sleutel. Maar hierdie vertikale bar vertikale bar beteken of. 

As, daarenteen, ons wou om te sê en, soos in Scratch, Ons kan ampersand ampersand doen. Dit maak geen logiese sin hier, want 'n mens kan nie moontlik getik beide y en klein y en kapitaal Y as dieselfde karakter. So of is dit wat ons van plan is hier. 

So as ek doen dit in beide plekke, of c gelyk gelyk kapitaal N, nou tik, logiese, tik logies. Nou kan ek y tik. En ek kan dit weer doen met kapitaal Y, of kapitaal N. En ek kon voeg in bykomende kombinasies steeds. 

Dit is dus 'n logiese program sover nou Ek is logies nagaan vir hierdie waarde of hierdie waarde. En ek hoef nie te, noodwendig, kom met nog twee ifs of anders ifs. Ek kan eintlik kombineer sommige van die verwant logika saam op hierdie manier. So sou dit beter wees ontwerp as net en gesê: As C is gelyk aan kleinletters y, druk ja, anders as c gelyk kapitaal Y, druk ja, anders as c gelyk lower-- met ander woorde, jy hoef nie te hê meer en meer takke. Jy kan 'n paar van die ekwivalent kombineer takke logies, soos in hierdie manier. 

So laat ons 'n blik op net een finale bestanddeel, 'n laaste konstruk, dat C laat. En ons sal terug te kom in die toekoms vir ander nog. En dan sal ons die gevolgtrekking deur te kyk by nie die korrektheid van code-- kry-kode vir work-- maar die ontwerp van kode, en plant die saad vroeg. 

So laat ek gaan voort en open 'n nuwe lêer hier. Jy weet wat? Ek gaan weer implementeer dat dieselfde program, maar met 'n ander bou. 

So laat ek gou gee myself toegang tot CS50.h sluit vir die CS50 biblioteek, standaard Io.h vir printf. Gee my int main leemte. En dan hier, laat my gaan voort en doen dit. 

Char c kry kry kar, net soos voorheen. En ek gaan 'n nuwe konstruk gebruik now-- skakel, op watter karakter? So skakelaar is soort van soos skakel 'n treinspoor. Of, regtig, dit is 'n soort van 'n as anders as anders as, maar 'n bietjie anders geskryf. 

'N Skakelaar lyk soos volg. Jy het skakelaar, en dan wat karakter of nommer wat jy wil om te kyk na, dan 'n paar krullerige draadjies graag in Kras, sê net doen hierdie dinge. En dan moet jy verskillende gevalle. 

Jy hoef nie te gebruik as en anders. Jy gebruik letterlik die woord geval. En jy sal so iets sê. 

So in die geval van 'n klein y, of in die geval van 'n kapitale Y, gaan voort en druk ja. En dan breek uit die skakelaar. Dis dit. Ons is klaar. 

Anders as, om so te praat, kleinletters N, of kapitaal N, dan voort te gaan en uit te druk uit nie, en dan breek. Else-- en hierdie soort is die standaard geval indeed-- printf error-- en net vir 'n Goeie maat, alhoewel logies hierdie onderbreking is nie nodig omdat ons aan die einde van die skakelaar in elk geval, Ek is nou uit te breek van die skakelaar. So dit lyk 'n bietjie anders. 

Maar, logies, dis eintlik ekwivalent. En hoekom sou jy gebruik een oor die ander? Soms, net persoonlike voorkeur, Soms is die estetika, As Ek loer na hierdie Nou, daar is iets te sê vir die leesbaarheid van hierdie kode. Ek bedoel, wat nog te sê die feit dat hierdie kode is nuut in baie van ons in die kamer. 

Maar dit net soort is mooi. Jy sien klein y, kapitaal Y, kleinletters N, kapitaal N standaard, dit net soort van spring uit na jou op 'n manier dat, waarskynlik, miskien die vorige voorbeeld met die IFS, en die vertikale bars, en die ander IFS, kan nie. So is dit regtig 'n kwessie van persoonlike keuse, regtig, of leesbaarheid, van die kode. 

Maar in terme van funksionaliteit, laat my gaan voort en maak 'n skakelaar, dot streep skakelaar, en nou tik in klein y, kapitaal Y, klein N, kapitaal N, Dawid weer probeer, want dit is nie 'n enkele karakter. Kom ons doen x, fout, soos verwag. En, logically-- en dit is iets wat Ek sou raai in general-- selfs alhoewel ons net krap die oppervlak van 'n paar van hierdie eienskappe. 

En dit kan nie voor die hand liggend te wees wanneer jy jouself gaan sit by die klavier, hoe werk dit? Wat sou dit doen? Die wonderlike ding oor wat 'n skootrekenaar, of lessenaar, of toegang tot 'n rekenaar met 'n samesteller, en met 'n kode redakteur soos hierdie, is jy kan byna altyd beantwoord hierdie vrae vir jouself net deur te probeer. 

Byvoorbeeld, as die retoriese vraag aan die hand was, Wat gebeur as jy vergeet jou breek stellings? Wat eintlik 'n baie algemene ding om te doen, want dit lyk nie soos jy regtig nodig het. Hulle het nie regtig voltooi jou gedink soos 'n hakies of 'n krullerige stut doen. Kom ons gaan voort en heropstel die kode en sien. So maak skakelaar, dot streep skakelaar. Kom ons tik in kleinletters y, die top geval, Tik. So ek getik y. 

Die program het gesê ja, nee, fout, asof dit die verandering van sy verstand. Maar dit soort was, want wat gebeur met 'n skakelaar is die eerste geval wat wedstryd in wese beteken, hey rekenaar, uit te voer al die kode daaronder. En as jy nie sê breek, of moenie sê breek, of nie breek nie sê: die rekenaar gaan waai deur al die lyne en uit te voer almal van hulle tot dit op daardie krullerige brace. So het die remme is inderdaad nodig. Maar 'n wegneemete hier is, wanneer twyfel, probeer iets. Miskien red eers jou kode, of stoor dit in 'n ekstra lêer as jy regtig bekommerd oor geknoei en om te herstel die werk wat jy weet werk. 

Maar probeer dinge. En moenie so bang wees nie, miskien, van wat die rekenaar kan doen, of dat jy dalk iets breek. Jy kan altyd terugkeer 'n paar vorige weergawe. 

So laat ons eindig deur te kyk by die ontwerp van die kode. Ons het hierdie vermoë nou skryf voorwaardes, en skryf lissies en veranderlikes, en oproep funksies. So, eerlik, ons is soort van terug by waar ons was 'n week gelede met nuuts af, al is dit met 'n minder dwingende tekstuele omgewing as Scratch toelaat. 

Maar let op hoe vinnig ons verkry wat woordeskat, selfs al is dit gaan 'n rukkie neem om te sink in, sodat ons nou hierdie woordeskat kan gebruik meer interessante programme te skryf. En laat ons 'n baba stap rigting wat, soos volg. Laat my gaan voort en 'n nuwe lêer hier. 

Ek gaan hierdie skakel prototype.c, en stel vir die eerste keer, die vermoë om jou eie funksies te maak. Sommige van julle mag hê gedoen met nuuts af, waardeur jy kan skep jou eie persoonlike blokke in Scratch, en dan sleep hulle in plek waar jy wil in C. En in die meeste programme tale, kan jy presies doen that-- maak jou eie funksies, as hulle nie reeds bestaan ​​nie. 

So, byvoorbeeld, laat my gaan voort en sluit CS50.h, en sluit standaard IO.h, int main leemte. En nou het ons 'n place holder gereed om te gaan. Ek hou druk dinge soos mense se name vandag. En dit voel like-- sou nie lekker wees as daar was 'n funksie genoem gedrukte naam? Ek hoef nie te printf gebruik. Ek hoef nie te onthou al formaat kodes die. Hoekom nie ek, of waarom het nie iemand voor my, skep 'n funksie genoem druk naam gegee dat sommige naam, eenvoudig druk dit uit? 

Met ander woorde, as ek sê, hey, rekenaar, gee my 'n string deur die gebruiker te vra vir sulke, via CS50 se get string funksie. Haai, rekenaar, sit dit string in die veranderlike in die linkerkant, en noem dit is. En dan, hey rekenaar, gaan voort en druk wat persoon se naam, gedoen. 

Nou, sou dit lekker wees, want hierdie program, heel gepas genaamd, vertel my wat dit veronderstel is om te doen by wyse van name diegene funksie se. Laat my gaan en maak prototipe, Tik. En, helaas, hierdie is nie van plan om te vlieg. 

Prototype.c, lyn 7, karakter 5, fout, implisiete verklaring funksie gedrukte naam is ongeldig in C99, C99 wat beteken dat 'n weergawe van C wat uitgekom het in 1999. Dis al. 

So ek weet nie wat al hierdie dinge beteken nie. Maar ek doen fout erken in rooi. Dit is redelik voor die hand liggend. 

En dit blyk dat met die groen karakter hier, die probleem is met die naam gedrukte media, oop hakie se naby hakie, kommapunt. Maar implisiete verklaring van funksie wat ons gesien het kortliks vroeër. Dit beteken, eenvoudig, dat klang weet nie wat ek bedoel. 

Ek het 'n woordeskat woord gebruik dat dit nooit gesien of voorheen geleer. En so het ek nodig het om dit te leer wat hierdie funksie beteken. So ek gaan om voort te gaan en dit te doen. 

Ek gaan om voort te gaan en te implementeer my eie funksie genoem Print Naam. En ek gaan om te sê, soos volg, wat doen dit, printf, hello, persent s, agteroorskuinsstreep N, naam, kommapunt. So, wat het ek net doen? 

So dit blyk, na implementeer jou eie funksie, ons soort leen sommige van dieselfde struktuur as hoof dat ons net gewees het as vanselfsprekend aanvaar, en ek weet net kopieer en plak pretty much wat Ek het al skryf in die verlede. Maar hier sien die patroon. Int, Hoofstraat, nietig, ons sal uitmekaar terg kort voor lank wat dit eintlik beteken. 

Maar vir vandag, net let op die parallelisme. Leemte, druk naam, string naam, dus is daar 'n pers navraag, wat ons gaan begin roep 'n terugkeer tipe, die naam van die funksie, en dan die insette. So, eintlik, kan ons distilleer hierdie soort van soos verlede week as dit is die naam of die algoritme van die kode is ons gaan die write-- algoritme onderliggende die kode wat ons gaan skryf. 

Dit is sy insette. Dit is sy produksie. Hierdie funksie, druk naam, is ontwerp om 'n string genoem naam te neem, of wat ook al, as toevoer, en dan nietig. Dit hoef nie iets terug te keer, soos kry string of kry int doen. So dit gaan my hand iets terug. Dit is net gaan om 'n hê newe-effek, om so te praat, van die druk van n persoon se naam. So sien, reël 7, ek kan naam gedrukte noem. Line 10, kan ek definieer of implementeer naam druk. Maar, helaas, dit is nie genoeg nie. 

Laat my gaan voort en heropstel hierdie na te slaan. Whoa, nou, ek het dit gemaak Erger nog, wil dit voorkom asof. So implisiete verklaring van funksie gedrukte naam is ongeldig. En, weer, daar is meer foute. Maar as ek gewaarsku vroeër, selfs As jy oorweldig met te kry, of 'n bietjie hartseer om so baie te sien foute, net fokus op die eerste aanvanklik, want dit mag dalk net 'n waterval effek gehad het. So C, of ​​klang meer spesifiek, nog nie naam gedrukte erken. 

En dit is omdat klang, deur ontwerp, is 'n soort van stom. Dit maak net wat jy dit vertel om te doen. En dit doen net so in die orde waarin jy dit sê om te doen. 

So ek het groot op die lyn vier gedefinieer, soos ons is besig met mooi dikwels. Ek het naam gedrukte gedefinieer op die lyn 10. Maar ek probeer om te gebruik Druk naam op die lyn sewe. 

Dit is nog te vroeg, nie nog bestaan. So kan ek slim wees, en wees soos, OK, so laat ons net saamspeel, en beweeg naam gedrukte up hier, en weer saam te stel. O my God. Dit het gewerk. Dit was so eenvoudig soos dit. 

Maar die logika is presies dit. Jy moet klang leer wat dit is deur die definisie van die funksie eerste. Dan kan jy dit gebruik. Maar, eerlik, dit voel soos 'n glybaan. 

So elke keer as ek hardloop 'n probleem, ek is net gaan na vore te bring en 'n afskrif van die kode Ek skryf, kap dit en plak dit hier. En, waarlik, ons kon bedink 'n paar scenario's waar 'n mens funksie mag nodig om 'n ander te roep. En jy moet net nie kan sit elke funksie bo elke ander. 

dit blyk so daar buite se 'n beter oplossing. Ons kan laat dit wees. En, eerlik, dit is oor die algemeen mooi, en gerieflik, en 'n goeie ontwerp om gevolg, weer belangrikste voorop te stel,, hoof nes toe groen vlag gekliek, dit is die funksie wat sal uitgevoer word by verstek. So jy kan net so goed sit dit aan die bokant van die lêer sodat wanneer jy of enige ander menslike kyk na die lêer jy weet wat aangaan net deur die lees van hoof eerste. So dit blyk, kan ons klang vertel proaktief, hey, klang, On line vier, Ek belowe om te implementeer 'n funksie genoem Print Naam wat 'n string genoem naam neem as invoer, en opbrengste niks, nietig. En ek sal kry om te uitvoering daarvan later. 

Hier kom Main. Main nou op die lyn 9 kan gebruik Print Naam, want klang vertrou dat, uiteindelik, Dit sal die definisie teëkom van die implementering van Print Naam. So na my lêer spaar, laat my gaan voort en maak prototipe, lyk goed hierdie tyd. Dot streep, prototipe, laat my gaan voort en tik in 'n naam. David, hallo Dawid Zamila, hello Zamila, en, inderdaad, nou is dit werk. 

So het die bestanddeel hier is dat ons het het 'n persoonlike funksie, soos 'n persoonlike Scratch blok ons ​​noem dit. Maar in teenstelling met Scratch waar jy kan net skep dit en begin dit te gebruik, nou het ons 'n wees bietjie meer pedanties, en eintlik lei klang te gebruik, of om dit te verwag. Nou, as 'n eenkant, waarom al hierdie tyd het ons net blindelings nie op geloof insluitend CS50.h, en met standaard IO.h? 

Wel, dit blyk, onder 'n paar ander dinge, al is dit in die kol h lêers, wat gebeur met lêers. Hulle is header lêers, om so te praat. Hulle is nog steeds geskryf in C. Maar hulle is 'n ander tipe lêer. 

Vir nou, kan jy pretty much aanvaar dat alles wat binne-in CS50.h is 'n paar one-liners soos hierdie, nie vir funksies genoem Print Naam, maar vir Kry String, Kry Vlot, en 'n paar ander. En daar is soortgelyke prototipes, een liners, binnekant van standaard IO.h vir printf, wat nou in my eie Print Naam funksie. So met ander woorde, die hele tyd wat ons het pas blindelings kopieer en plak sluit dit sluit dat, wat gaan aan? Dit is net soort van leidrade om klang oor wat funksies is inderdaad geïmplementeer, net elders in verskillende lêers Elders op die stelsel. 

So het ons naam gedrukte geïmplementeer. Dit het wel hierdie newe-effek van druk iets op die skerm. Maar dit beteken nie eintlik hand my iets terug. Hoe kan ons te werk gaan implementering van 'n program wat beteken oorhandig my iets terug? 

Wel, laat ons probeer om hierdie. Laat my gaan voort en te implementeer 'n lêer met die naam return.c sodat ons kan demonstreer hoe iets soos Kry String, of Kry Int, is eintlik terugkeer iets terug na die gebruiker. Kom ons gaan voort en definieer int main leemte. 

En, weer, in die toekoms, sal ons verduidelik wat dit int en daardie leemte is eintlik. Maar vir vandag, sal ons neem dit as vanselfsprekend. Ek gaan voort en printf te gaan, vir 'n goeie gebruikers ervaring, x is. En dan gaan ek om te wag vir die gebruiker om my te gee x met get Int. 

En dan gaan ek voort te gaan en druk x om die vierkante. So wanneer jy net 'n sleutelbord, mense wat algemeen gebruik die klein wortel simbool op die sleutelbord om verteenwoordig die krag van, of die eksponent van. So x kwadraat is teenwoordig i. 

En nou gaan ek dit doen. Ek kon net do-- wat x kwadraat? x kwadraat is x keer x. 

En ons het dit 'n paar tyd gelede reeds vandag. Dit voel nie soos alles wat veel vordering. Jy weet wat? Kom ons benut 'n paar van daardie idee van verlede tyd van abstraksie. 

Sou dit nie lekker wees as daar is 'n funksie genoem vierkante wat presies dit doen? Dit nog, aan die einde van die dag, doen dieselfde wiskunde. Maar laat ons abstrakte weg van die idee van die neem een getal vermenigvuldig met 'n ander, en net te gee dit 'n naam, soos vierkante hierdie waarde. 

En, met ander woorde, in C, laat ons 'n funksie genoem vierkante wat presies dit doen. Dit gaan vierkante genoem te word nie. Dit gaan 'n int neem. En ons sal net sal noem dit n, by verstek. 

Maar ons kan dit noem enigiets wat ons wil. En almal wat dit gaan doen, letterlik, is terug die gevolg van n keer n. Maar omdat dit terugkeer iets wat is die sleutelwoord in pers ons het nog nooit tevore gesien het nie, ek, op die lyn 11, kan nie net sê leemte hierdie tyd. 

Leemte in die voorbeeld wat ons nou net gesien het eerder van naam druk, net beteken, doen iets. Maar moenie die hand my iets terug. In hierdie geval, wil ek om terug te keer n keer n, of wat dit ook al is, dat die getal. 

So kan ek nie sê, hey, rekenaar, Ek terugkeer niks, nietig. Dit gaan om terug te keer, deur die natuur, 'n int. En so dit is alles wat hier aangaan. 

Die insette te kwadreer gaan 'n int wees. En sodat ons dit kan gebruik, moet dit 'n naam, N. Dit gaan uitvoer 'n int wat nie 'n naam nie nodig. Ons kan dit laat belangrikste, of wie ook al is die gebruik van my om hierdie waarde as ons onthou wil met sy eie veranderlike. 

En, weer, die enigste nuwe navraag hier is terug. En ek is net besig met 'n wiskunde. As ek wou eintlik onnodig te wees, Ek kan sê int produk kry n keer n. 

En dan kan ek sê: Keer terug produk. Maar, weer, om my punt vroeër van dit net nie goed ontwerp te soos, hoekom stel 'n naam, 'n simbool, soos die produk, net om onmiddellik terug te keer nie? Dit is 'n bietjie skoner, 'n bietjie stywer, sodat te praat, net om terug n keer sê N, ontslae te raak van hierdie lyn geheel en al. 

En dit is net minder-kode te lees, minder geleentheid vir foute. En laat ons kyk of hierdie eintlik nou werk. Nou, ek gaan om te gaan voor en terugkeer maak. 

Uh-oh, implisiete verklaring van funksie. Ek hierdie fout gemaak voor, nie 'n groot deal. Laat my net te tik, of na vore te bring en kopieer, presies dieselfde funksie prototipe, of handtekening, van die funksie hier. Of ek kon die hele funksie te beweeg. 

Maar dit is 'n bietjie lui. So sal ons dit nie doen nie. Nou, laat ek terugkeer maak weer, dot streep terugkeer. 

x is 2. x kwadraat is 4. x is 3. x kwadraat is 9. En die funksie lyk nou om saam te werk. So, wat is die verskil hier? Ek het 'n funksie wat vierkante genoem word, in hierdie geval, wat ek in 'n inset. En ek terug 'n uitset. En tog, wat voorheen as Ek maak die ander voorbeeld van vroeër, wat was genoem prototype.c, Ek het druk naam, wat leemte teruggekeer, om so te praat, Of dit teruggekeer niks, en eenvoudig 'n newe-effek. 

So, wat gaan hier aan? Wel, kyk na die funksie kry string vir net 'n oomblik. Ons het al met behulp van die funksie kry string in die volgende manier. 

Ons het 'n funksie te kry string, soos insluit CS50.h, sluit standaard IO.h, int, hoof, nietig. En dan elke keer as ek het genoem get string tot dusver, Ek het gesê iets soos, string s kry kry string, want get string-- Kom ons noem dit get.c-- get string self terug 'n string wat ek kan dan gebruik, en sê: hello, komma, persent s, agteroorskuinsstreep N, s. 

Dit is dus in dieselfde voorbeeld, werklik, dat ons moes vroeër. So kry string 'n waarde terug. Maar 'n oomblik gelede, druk string nie 'n waarde terugkeer. Dit het net 'n newe-effek. So dit is 'n fundamentele verskil. Ons het verskillende gesien tipes funksies nou, waarvan sommige teruggekeer waardes, waarvan sommige nie. So miskien is dit string, of int, of float. Of miskien is dit net leemte. 

En die verskil is dat hierdie funksies wat kry data en stuur 'n waarde is eintlik bring iets terug na die tafel, By wyse van spreke. So laat ons gaan voort en kyk na 'n laaste stel voorbeelde wat 'n gevoel gee, nou, van hoe ons kan inderdaad abstrakte beter, en beter, en beter, of meer, en nog baie meer, en meer, ten einde om te skryf, uiteindelik, 'n beter kode. Kom ons gaan voort, en in die gees van nuuts af, doen die volgende. 

Laat my gaan voort en sluit CS50.h en standaard IO.h. Laat my gaan voort en gee myself 'n int, hoof, nietig. En laat my voort te gaan, noem dit cough.c. 

En laat ek gaan voort en net soos nuuts af, druk hoes / N. En ek wil dit drie keer te doen. Dus is ek natuurlik net gaan kopieer en plak drie keer. Ek gaan nou om hoes dot streep hoes. Kom ons gee myself 'n bietjie meer ruimte hier, Gee, hoes, hoes, hoes. 

Daar is, natuurlik, reeds 'n geleentheid vir verbetering. Ek het gekopieer en geplak 'n paar keer vandag. Maar dit was net so ek het nie moet soveel karakters tik. Ek het nog verander wat die lyne van kode is. 

Hierdie drie lyne identies, wat voel lui en wel, en is waarskynlik nie die regte benadering. So met dit wat bestanddeel kon ons verbeter die kode? Ons hoef nie te kopieer en plak kode. 

En, inderdaad, enige tyd wat jy voel jouself kopieer en plak, en nie eens die verandering kode, kans is daar 'n beter manier. En, inderdaad, daar is. Laat my gaan voort en doen 'n for-lus, selfs al is die sintaksis dalk nie kom nog natuurlik. 

Doen dit drie keer, net deur dit te doen die following-- en ek toevallig weet uit die praktyk. Maar ons het 'n aantal voorbeelde nou. En jy sal sien aanlyn meer verwysings steeds. 

Dit is die sintaksis op lyn 6, wat baie soos Scratch wat herhaal blok, herhaal die volgende drie keer. Dit is 'n bietjie magiese vir nou. Maar dit sal meer kry, en meer bekend. 

En dit gaan herhaal lyn agt drie keer, sodat as ek weer saam te stel make hoes, dot streep hoes, hoes, hoes, hoes. Dit werk nog steeds op dieselfde manier. So dit is alles goed en wel. Maar dit is nie baie onttrek. 

Dit is perfek korrek. Maar dit voel asof daar 'n geleentheid kan wees, soos in die wêreld van Kras, soort begin 'n paar semantiek hier by te voeg, sodat Ek het nie net 'n paar vir lus, en 'n funksie wat sê hoes, of nie hoes. Jy weet wat? Laat ek probeer om 'n wees bietjie koeler as dit, en eintlik skryf 'n funksie wat het 'n paar newe-effekte, noem dit hoes. 

En dit neem geen insette en terugkeer geen waarde as uitset. Maar jy weet wat dit doen? Dit maak this-- printf, kwotasie unquote, hoes. 

En nou hier, ek gaan om voort te gaan en vir Int gaan, Ek kry nul, ek minder as 3, i plus plus. Ek gaan printf nie doen nie, wat waarskynlik 'n lae implementering vlak detail. Ek gee nie om hoe om te hoes. Ek wil net die hoes funksie gebruik. En ek is net gaan hoes noem. 

Nou, let op die digotomie. Wanneer jy 'n funksie te roep, as jy dit nie doen nie wil gee insette, heeltemal fyn. Doen oop hakie, naby hakie, en jy klaar is. 

Wanneer jy 'n funksie definieer, of verklaar prototipe n funksie se As jy vooraf weet dit is nie van plan om enige argumente te neem, sê leemte in dié tussen hakies daar. En dit maak seker dat jy sal nie per ongeluk misbruik dit. Laat my gaan voort en maak hoes. En, natuurlik, ek het 'n fout gemaak. 

Dammit, daar is dat implisiete verklaring. Maar dit is goed. Dit is 'n maklike oplossing. Ek hoef net die prototipe hoër op in my lêer as ek eintlik wat dit gebruik. 

So nou laat ek maak hoes weer mooi. Nou, dit werk. Maak hoes, hoes, hoes, hoes. So jy dink dat ons regtig net meer as ingenieurswese hierdie probleem. En, inderdaad, ons is. Dit is nie 'n goeie kandidaat van 'n program op die oomblik vir refactoring, en doen wat genoem hiërargiese ontbinding, waar jy 'n paar kode te neem, en dan jy soort van faktor dinge uit, sodat meer semantiek skryf vir hulle en onthou dit uiteindelik langer termyn. Maar dit is 'n boublok in die rigting meer gesofistikeerde programme dat ons sal begin skryf kort voor lank dat laat ons toe om die woordeskat te hê waarmee 'n beter kode te skryf. En, inderdaad, kom ons kyk of ons kan nie verder te veralgemeen. 

Dit lyk 'n bietjie lam dat ek, hoof, hoef te bekommer oor die darn vir lus, en roep hoes weer en weer. Hoekom kan ek nie sê nie net hoes, asseblief hoes drie maal geslaan? Met ander woorde, waarom kan ek net insette te hoes en dit te doen? 

Hoekom kan ek nie sê net, in hoof hoes drie keer. En nou, hierdie is 'n soort van magiese. Dit is hier baie iteratiewe. En dit is inderdaad 'n baba stap. 

Maar net die vermoë om op te sê lyn agt, hoes drie keer, dit is net soveel meer leesbare. En, plus, ek hoef nie te weet of om hoe hoes geïmplementeer word. En, inderdaad, later in die termyn en vir finale projekte, As jy 'n projek met pak 'n klasmaat of twee klasmaats, jy besef dat jy gaan moet, of wil, verdeel die werk. 

En jy gaan wil om te besluit vooruit, wie gaan om te doen wat, en in watter stukke? En sou dit nie lekker wees As jy, byvoorbeeld, neem beheer van die skryf hoof, gedoen. En jou kamermaat, of jou vennoot meer algemeen, sorg vir die implementering van hoes. 

En hierdie afdeling, hierdie mure van onttrekking, of lae onttrekking as jy sal, is super kragtige, want veral vir groter, meer komplekse programme en stelsels, Dit kan verskeie mense op te bou dinge saam, en uiteindelik steek hulle werk saam op hierdie manier. Maar, natuurlik, ons moet nou los hoes. Ons moet hoes vertel dat, hey, jy weet wat? Jy gaan moet 'n te neem input-- so nie nietig nie, maar int en nou. Kom ons gaan voort en in hoes die int. Ek kry nul. 

Ek is minder as hoeveel keer. Ek het drie voor. Maar dit is nie wat ek wil hê. Ek wil hoes te veralgemeen na ondersteun 'n aantal iterasies. 

So, inderdaad, dit is N wat ek wil, ongeag die gebruiker sê vir my. Nou kan ek voort te gaan en sê Druk hoes. En maak nie saak hoeveel die gebruiker gaan in, Ek sal Itereer wat baie keer. 

So aan die einde van die dag, program is identies. Maar let op al hierdie dinge kan selfs in 'n ander lêer. Inderdaad, ek weet nie op die oomblik hoe printf geïmplementeer word. 

Ek weet nie op die oomblik hoe kry string, of kry int, of kry float geïmplementeer word. En ek wil nie hulle sien op my skerm. Soos dit is, ek begin om te fokus op my program, nie daardie funksies. 

En so, wel, so gou as wat jy begin factoring kode soos hierdie uit, kon ons beweeg selfs hoes om 'n aparte lêer? Iemand anders kan dit te implementeer. En jy en jou program word die baie mooi, en baie leesbaar, waarskynlik, regtig vier line program net daar. 

So laat ons nou gaan voort en maak 'n mens meer verandering. Let daarop dat my prototipe moet verander tot bo. So laat ek dit regmaak so Ek kry nie geskree. 

Maak hoes, laat my hoes keer hardloop meer, nog doen dieselfde ding. Maar nou, sien ons 'n bestanddeel vir 'n finale weergawe. Jy weet wat? Ek wil nie net hoes, noodwendig nie. Ek wil iets meer algemeen. So jy weet wat? Ek wil om dit te doen. Ek wil hê, net soos Scratch doen, 'n sê blok, maar nie net sê iets sommige aantal kere. Ek wil hê dit moet 'n baie spesifieke string sê. En daarom doen ek nie, dit wil sê net hoes. Ek wil hê dit moet sê wat string is geslaag in. 

So sien, het ek veralgemeen dit so dat dit nou sê voel soos 'n goeie naam vir hierdie, soos nuuts af, neem twee argumente, in teenstelling met krap. Een daarvan is 'n string. Een daarvan is 'n int. 

En ek kon hulle skakel. Ek het net soort van soos die idee van sê die string eerste, en dan Hoeveel keer later. Leemte beteken dit nog steeds niks terug. Dit is net 'n visuele kant effekte, soos met [? Jordan,?] 'n verbale newe-effek van skree. Dit beteken nog iets N tye, 0 tot, maar nie gelyk aan n. Dit beteken N totale keer. En dan net druk wat dit ook al string is. So ek het regtig veralgemeen hierdie reël van die kode. So nou, hoe kan ek implementeer die hoes funksie? 

Ek kan leemte hoes doen. En ek kan nog steeds in hoe baie keer jy wil hoes. Maar jy weet wat? Ek kan nou liewer sê. 

Ek kan noem sê met die woord hoes, verby in n. En as ek wil ook implementeer, net vir die pret, 'n nies funksie, Ek kan 'n paar aantal kere nies. En ek kan hou hergebruik N, omdat sien dat m in hierdie konteks of omvang net bestaan ​​binne hierdie funksie. 

En N in hierdie konteks net bestaan ​​binne hierdie funksie hier. So sal ons terug te kom hierdie kwessies van omvang. En hier, ek is net gaan om te sê, achoo, en dan n keer, kommapunt. 

En nou, ek het net nodig om te leen hierdie funksie handtekeninge hier. So hoes is korrek. Leemte nies is nou korrek. 

En ek moet nog net sê. So ek gaan om te sê, sê string s, int N, kommapunt. So ek het te veel ontwerp die klink uit hierdie program. 

En dit doen nie noodwendig dit is wat jy moet doen wanneer skryf selfs die eenvoudigste van programme. Neem iets wat natuurlik eintlik eenvoudig, baie kort, en re-implementeer die gebruik van te veel kode. Maar jy eintlik sien, en in tyd terugkyk op hierdie voorbeelde, en besef, o, dit is die stappe Ons het om werklik te veralgemeen, iets faktor uit, totdat aan die einde van die dag my kode is eintlik redelik redelike. Want as ek wil om te hoes drie keer nies dan drie keer, Ek is net gaan om dit te tik, program maak hoes, en hardloop hoes. En ek het drie hoes en drie nies. 

En so dit is 'n basiese paradigma, as jy wil, vir hoe ons kan gaan eintlik die uitvoering van 'n program. Maar laat ons net sien nou hoe dit is Ons het al almal hierdie keer doen, en wat 'n paar van die finale stukke agter hierdie eenvoudige opdrag. Aan die einde van die dag, ons het al met behulp van klang as ons samesteller. Ons het al skryf bron kode, omskakeling dit via klang in masjienkode. 

En ons het al met behulp Maak net ons toetsaanslagen so te fasiliteer dat ons nie hoef te onthou diegene inkantasies van klang self. Maar wat is Maak eintlik? En op sy beurt, wat Klang eintlik? 

Dit blyk egter ons vereenvoudig bespreking vandag deur te sê: jy bronkode te neem, slaag dit as insette om 'n samesteller wat jy gee uitset van masjien kode, blyk daar's 'n paar verskillende stappe in daar. En samestelling gebeur met die sambreel wees term vir 'n hele klomp van die stappe. Maar laat ons net terg dit uit regtig vinnig. 

Dit blyk dat ons is besig met meer dinge elke keer as ek 'n program uit te voer, of elke keer as ek stel 'n program vandag. So preprocessing verwys na this-- enigiets in 'n C program, soos ons sal sien weer en weer, wat begin met hierdie hash simbool, of die hashtag simbool hier, beteken dit is 'n voorverwerker richtlijn. Dit beteken dat, in hierdie geval, hey rekenaar, doen iets met 'n lêer voordat jy eintlik stel my eie kode. 

In hierdie geval, hash sluit is, wese, C se manier om te sê, hey rekenaar, gaan kry die inhoud van CS50.h en plak dit hier. Hey rekenaar, gaan kry die inhoud van standaard IO.h, waar dit is op die hardeskyf, plak dit hier. So die dinge gebeur eerste tydens preprocessing. 

En klang doen al hierdie dinge vir ons. En dit doen dit so darn vinnige, doen jy nie eens sien vier verskillende dinge gebeur. Maar dit is die eerste so 'n stap. 

Wat gebeur eintlik nou? Wel, die volgende amptelike stap is die opstel van. En dit blyk dat samestelling van 'n program tegnies beteken gaan uit bronkode, die dinge wat ons het skryf vandag, iets genoem vergadering kode, iets wat lyk 'n bietjie anders. 

En, in werklikheid, ons kan dit sien baie vinnig. Laat my eintlik in my IDE gaan. Laat my gaan voort en oop hello.c, wat is die heel eerste program waarmee ons begin vandag. En laat ek gaan voort en hardloop klang n bietjie anders, klang-e, hello.c, wat eintlik gaan Gee my 'n ander lêer hello.s. 

En ons sal waarskynlik nooit weer sien hierdie soort kode. As jy 'n laer vlak te neem stelsels klas soos CS61, jy sal 'n baie meer te sien van hierdie soort kode. Maar dit is saamsteltaal. Dit is X86 saamsteltaal dat die SVE wat onderliggende CS50 IO eintlik verstaan. 

En kriptiese as dit nie kyk, dit is iets wat die rekenaar verstaan ​​baie goed. Sub Q, dit is 'n Trek. Daar is bewegings. 

Daar is 'n beroep funksies hier, x oring, 'n beweging, 'n add, 'n pop, 'n terugkeer. Daar is dus 'n paar baie lae instruksies vlak dat CPUs verstaan ​​dat Ek verwys na vroeër. Dit is wat Intel Inside. 

Daar is patrone van nulle en ene wat karteer om hierdie arcanely bewoorde, maar ietwat goed genoem, instruksies, By wyse van spreke. Dit is wat gebeur wanneer jy stel jou kode. Jy kry vergadering taal uit dit uit, wat beteken die derde stap is om te vergader dat die gemeente kode in, uiteindelik, masjien code-- nulle en ene, nie die teks wat ons nou net gesien 'n oomblik gelede. 

So pre-verwerking beteken dat vind en te vervang, en 'n paar ander dinge. Samestelling neem jou bron kode van C, bronkode dat ons geskryf het, te vergadering kode wat ons net kyk na. Bling neem dat die gemeente -kode vir nulle en ene dat die SVE werklik verstaan ​​aan die einde van die dag. En aansluiting is die laaste stap dit gebeur vir us-- weer, so vinnig ons nie stip handel notice-- wat sê: hey rekenaar, neem al die nulle en ene wat gevolg van die samestelling van Dawid se kode, en sy belangrikste funksie in hierdie geval. 

En hey rekenaar, gaan kry al die nulle en ene dat die CS50 personeel geskryf binne-in die CS50 biblioteek. Meng dié in met Dawid se. En hey rekenaar, gaan kry al die nulle en diegene wat iemand anders geskryf jaar gelede vir printf. En voeg diegene in die hele ding, sodat ons het het my nulle en ene, die nulle en ene CS50 personeel se die printf nulle en ene, en enigiets anders wat ons gebruik. 

Hulle het almal bymekaar te kry gekombineer in een program genaamd, in hierdie geval, hallo. So van nou af, sal ons net gebruik die woord opstel. En ons sal as vanselfsprekend aanvaar dat wanneer sê ons, stel jou program, dit beteken, hey doen die pre-verwerking, vervaardiging, en 'n skakel. Maar daar is eintlik 'n paar sappige dinge gaan daar onder die enjinkap. En veral as jy kry nuuskierig 'n geruime tyd, jy kan begin skeer rondom by hierdie laer vlak. Maar vir nou, besef dat onder die wegneemetes vir vandag is eenvoudig die begin van 'n proses, om gemaklik met iets soos hello world. Trouens, die meeste van wat ons vandag het beslis sal nie sink in super vinnig. En dit sal 'n paar te neem tyd, en 'n paar praktyk. En die kans is, sal jy sorteer van wil jou sleutelbord getref of gil op die skerm. En dit alles is OK. Alhoewel, miskien probeer om nie te doen dit in die biblioteek soveel. 

En uiteindelik, sal jy in staat wees al is, om te begin sien patrone, beide in 'n goeie-kode wat jy geskryf het en in foute wat jy gemaak het. En net soos die proses van besig om 'n TF of 'n CA is soos, jy begin om 'n beter en beter te sien wat patrone, en net die oplossing van jou eie probleme uiteindelik. In die tussentyd, sal daar genoeg wees ons vir jou steun, en kry jy deur middel van hierdie. En in die skryf-ups vir al die probleme sal jy gelei word deur al die opdragte dat ek beslis weet uit baie oefening teen hierdie tyd, maar kon gevlieg oor 'n mens se kop vir nou. En dit is heeltemal fyn. 

Maar uiteindelik, jy gaan om te begin om te sien patrone na vore. En sodra jy verby al die dom besonderhede, soos tussen hakies, en krullerige draadjies, en semi-dubbele punte, en die dinge, eerlik, dit is glad nie intellektueel interessant. En dit is nie die doel van enige inleidende klas. Dit is die idees wat gaan saak. 

Dit is die loops, en die voorwaardes, en die funksies, en meer kragtig die onttrekking, en die factoring van kode, en die goeie ontwerp, en die goeie styl, en uiteindelik die korrektheid van jou kode, wat uiteindelik gaan die meeste saak. So volgende week, sal ons hierdie neem idees wat ons die eerste keer gesien in Scratch en het nou vertaal C. En ons sal begin in te voer die eerste van die Natuurlik se werklike wêreld domeine. 

Ons sal fokus op die wêreld van sekuriteit, en meer spesifiek kriptografie, die kuns van skommeling inligting. En een van die eerste probleme wat jy jouself sal kry om verder te skryf speel met 'n paar van die sintaksis en die oplossing van 'n logiese probleme, uiteindelik kort voor lank, is om werklik klouter, of enkripteer, en uiteindelik decrypt inligting. En alles wat ons gedoen het Vandag sal die redelik lae vlak, is net gaan om voorsiening te maak ons een, en een neem, en nog 'n stap in die rigting van bo skryf nog die mees interessante kode. 

So meer oor dit volgende week. 

[Video speel] 

-Wat Kan jy my vertel oor die laaste keer wat jy hom sien? -Wat Kan ek sê, regtig? Ek bedoel, dit was soos enige ander pre-produksie repetisie, behalwe dat daar iets was het hy gesê aan die einde wat vas met my. 

-Dit Was CS50. 

-dat 'N snit almal, groot taak op repetisie. 

middagete -dat se? 

-Yeah, Ek en jy kan gryp 'n broodjie in 'n bietjie. Laat my net evaluate met David regtig vinnig. David? David? 

[Einde TERUGSPEEL] 