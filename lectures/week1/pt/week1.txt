[REPRODUÇÃO DE MÚSICA] DAVID J. MALAN: Tudo bem, isso é CS50. E esta é uma semana. Então lembro da última vez na semana zero, nós nos concentramos em pensamento computacional. E nós a transição de que a Zero, a programação gráfica linguagem de nossos amigos no Media Lab do MIT. 

E com o Scratch, que exploramos idéias como funções e condições, e loops e variáveis, e até mesmo eventos e tópicos, e mais. E hoje, vamos continuar a usar essas idéias, e realmente levá-los para concedido, mas traduzi-las para outro idioma conhecido como C. Agora, C é uma linguagem mais tradicional. É um nível mais baixo a linguagem, se você quiser. 

É puramente textual. E assim, à primeira vista, é tudo vai olhar um pouco críptica se você nunca programou antes. Nós vamos ter ponto e vírgula e parênteses, e chaves, e muito mais. Mas perceber que, mesmo embora a sintaxe seja sobre a olhar um pouco familiarizado a maioria de vocês, ver além disso. E tentar ver as ideias que são, de fato, familiar, porque aqui na semana um o que começaremos a fazer é comparar, Inicialmente, Raspe contra C. 

Assim, por exemplo, recordar que quando implementou o primeiro dos nossos programas última vez, tivemos um bloco que parecia um pouco algo como isto-- quando bandeira verde clicado, e depois tivemos Um ou mais peças do puzzle abaixo dela, neste caso, dizer, Olá mundo. Então, de fato, em risco, quando eu clico que a bandeira verde para executar o meu programa, de modo falar, estes são os blocos que são executadas, ou correr. E, especificamente, risco disse, Olá, mundo. 

Agora, eu poderia ter especificado diferentes palavras aqui. Mas vamos ver que, de fato, muitos destes blocks-- e, na verdade, C em muitas funções no pode ser parametrizada ou personalizado para fazer coisas diferentes. Na verdade, em C se quer converter, agora, este programa Raspadinha a esta outra língua, nós estamos indo para escrever um pouco algo como isto. 

Concedida, há alguma estranha sintaxe há mais provável, int, e parênteses e sem efeito. Mas printf-- mesmo que você faria acho que seria apenas impressão. Mas de impressão significa impressão formatado, como veremos em breve. Esta literalmente irá imprimir para a tela o que quer está dentro desses parênteses, que Claro que neste caso é, Olá mundo. 

Mas você vai notar algumas outras sintaxe, algumas aspas, que os parênteses no final, o-e-vírgula e semelhantes. Portanto, há um pouco de sobrecarga, por assim dizer, cognitivamente tanto e sintaticamente, que vamos ter que lembrar antes de tempo. Mas perceber que com a prática, isso vai começar a saltar para fora em você. 

Na verdade, vamos nos concentrar em que um função specifically-- neste caso, dizer Olá mundo. Então, digamos que é a função. Olá, mundo é seu parâmetro, ou argumento, a sua personalização. 

E a equivalência em C é apenas vai ser esta uma linha aqui, onde printf é equivalente a, digamos, a string entre aspas duplas, Olá mundo é equivalente, é claro, para o que está na caixa branca lá. E a barra invertida n, embora um pouco estranha e ausente a partir do zero, simplesmente vai ter o efeito que vai ver em um computador, como o meu Mac ou um PC, de apenas movendo o cursor para a próxima linha. É como bater Enter no teclado. 

Então, vamos ver isso de novo antes do tempo. Mas, primeiro, vamos dar uma olhada neste outro exemplo, no caso de lacetes. Tivemos esse loop para sempre na última vez, que foi uma série de peças do puzzle que fez algo literalmente sempre-- neste caso, dizer Olá mundo, Olá mundo, Olá mundo, Olá mundo. Portanto, é um loop infinito por design. 

Em C, se queremos implementar este mesma idéia, poderíamos simplesmente fazer isso. Enquanto verdade, printf Olá mundo-- agora enquanto, apenas semanticamente, tipo de evoca a ideia de fazer algo mais uma vez, e de novo, e de novo, e por quanto tempo? Bem, lembre-se que true-- verdade é apenas ou um. 

E verdade é, é claro, sempre verdadeira. Portanto, é uma espécie de sentido declaração apenas para dizer verdade. Mas, na verdade, este é deliberada, porque se for verdade é apenas sempre verdadeiro, que enquanto verdade apenas indica, se um pouco indirectamente, que as seguintes linhas de código entre essas chaves deve apenas executar novamente, e novamente, e de novo, e nunca realmente parar. 

Mas se você quiser que o seu loop para parar, como nós fez da última vez com algo parecido isso, repita as seguintes 50 vezes, no C, podemos fazer o mesmo com o que há de chamado de uma palavra-chave para o loop-- não sendo ao mesmo tempo, mas para. E então nós temos alguma nova sintaxe aqui, com int i é igual a 0, i inferior a 50, i ++. E nós vamos voltar a isso. Mas isso é simplesmente como iríamos traduzir o conjunto de blocos de raspadinhas para um conjunto de linhas de código C. 

Enquanto isso, considere variáveis. E, na verdade, nós apenas vi um um momento atrás. E no caso de zero, se queria declarar uma variável chamada i para i sendo inteiro, apenas um número, e queremos configurá-lo para algum valor, usaríamos esta laranja bloquear aqui-- definir i a 0. 

E vamos ver hoje e além, assim como na semana passada, programadores fazem quase sempre começar a contar a partir de zero, realmente por convenção. Mas também porque recolha junto nossa discussão de binário, o menor número possível representam com qualquer número de bits é apenas vai ser 0 em si. E por isso vamos geralmente começam inicializar mesmo nossas variáveis ​​para 0. 

E em C a fazer o mesmo, vamos dizer int por inteiro, eu apenas por convenção. Eu poderia ter chamado esta variável o que eu quiser, assim como em risco. E então é igual a 0 apenas cessionários o valor 0 da direita e coloca-lo na variável, ou a recipiente de armazenamento há, no lado esquerdo. E o ponto e vírgula como vamos see-- e temos visto alguns desses já-- apenas significa final de pensamento. Avance para fazer outra coisa nas linhas que se seguem. 

Agora, o que acontece com expressões booleanas? Lembre-se que em risco, Estes eram expressões que são verdadeiras ou perguntas false--, realmente, que são verdadeiras ou falsas. Assim, no caso do Scratch, poderíamos fazer uma pergunta simples como este, é i menos de 50? Então eu, mais uma vez, é um inteiro. Talvez nós estamos a usá-lo em um programa de arranhões manter o controle de uma pontuação ou algo assim. Portanto, esta sintaxe aqui em Risco Significa apenas que, é i menos de 50? Bem, felizmente, algo está simples em C. E para traduzir, isso seria simplesmente dizer i menos de 50, utilizando a chave familiarizados no seu teclado. 

Enquanto isso, se você queria dizer algo mais geral, como, bem, é x menos de y onde cada de X e Y são, eles próprios variáveis? Nós podemos fazer a mesma coisa no C, desde que nós temos criou essas variáveis ​​já. E vamos ver como fazer isso antes do tempo. Nós simplesmente diria x inferior a y. 

Então, você está começando a ver algumas semelhanças. E aquelas pessoas que fizeram Zero eram certamente inspirado por algumas dessas idéias básicas. E você vai ver este tipo de sintaxe em muitos languages-- não apenas zero, não apenas C, mas Python, e JavaScript, e outras línguas ainda. 

Vamos considerar uma outra construção de C, a noção de uma condição, fazendo algo condicionalmente. Se algo é verdade, fazer isso. Se alguma coisa é verdade, fazer isso. É uma espécie de programação equivalente a uma bifurcação na estrada. Talvez seja uma de duas vias garfo, um garfo de três vias, ou mais. E em risco, poderíamos ter visto algo assim. 

Então este é um grande problema. Mas considere o parente simplicidade da lógica. Se x é menor que y, em seguida, dizer x é menor do que Y, o resto, se x for maior do que Y, em seguida, dizer que x é maior que y. E, em seguida, logicamente, se você acha que volta a arranhar ou apenas sua própria intuição humana, assim, se x não é maior do que Y, e X não é menos do que Y, então é claro x vai ser igual a y. Portanto, neste caso, por assentamento os blocos de raspadinhas, podemos conseguir um três maneira bifurcação na estrada? 

Enquanto isso, se quisermos fazer isso em C, é indiscutivelmente parece um pouco simpler--, pelo menos, uma vez que você se familiarizar com a sintaxe. Se X for menor que Y, printf x é inferior a y. Senão, se x for maior do que Y, printf x é maior que y. Else printf x é igual a y-- e, mais uma vez, com aqueles barra invertida termina logo para essas novas linhas de modo que se você realmente correu este tipo de programa seria apenas mover o cursor em última análise, para a próxima linha da tela. 

Agora, entretanto risco teve outra recursos mais sofisticados, única alguns dos quais vamos inicialmente passar para o mundo do C. E um deles foi chamado de uma lista em risco. E este foi um especial tipo de variável que permitiu-lhe armazenar várias coisas na volta, para trás, para trás, para trás. 

Em C, que não têm listas, de per si, mas algo que são mais geralmente chamado de matrizes, embora nós vamos voltar mais tarde este semestre a olhar para algo chamado de uma lista, ou realmente uma lista ligada. Mas, por agora, o mais próximo equivalente em C para nós vai ser algo chamado de uma matriz. E uma matriz é simplesmente uma tipo especial de variável que lhe permite armazenar dados para trás, para trás, para trás, para trás. 

E, de fato, em risco, se queríamos para acessar o primeiro elemento de uma matriz ou um lista-- e eu vou chamá-lo, por convenção, argv, o argumento vetor, mas mais sobre isso antes do tempo. Se eu quiser começar no primeiro elemento de argv, no mundo do Scratch você realmente faz normalmente começar a contar a partir de 1. 

E assim eu poderia obter o item 1 da argv. Isso é apenas como MIT implementado a noção de listas. Mas em C, eu vou mais simples apenas dizer, argv, que novamente é o nome do meu lista-- ou para ser claro, uma matriz. E se eu quiser o primeiro elementos, eu vou usar colchetes, o que você pode não freqüentemente usado em um teclado. 

Mas 0 significa apenas, me o primeiro. Então, de vez em quando e como o tempo passa, vamos para começar a ver essas dicotomias entre zero e C, em que zero usa um. Nós em C usam 0 aqui. Mas você vai ver rapidamente depois de entender os fundamentos de cada língua, que essas coisas começam a ficar ainda mais familiarizados com a prática e prática. 

Então vamos realmente olhar agora para um programa. Aqui deve ser o primeiro da nossa C código-fonte de programas completos. E o programa que vamos para oferecer para consideração é o que é equivalente para que no início pedaço zero. 

Então aqui, nós temos o que é sem dúvida, o programa mais simples C você pode escrever que realmente faz alguma coisa. Agora, vamos olhar o passado, por agora, tem incluem, io.h série, e ambos ângulo colchetes, e int e vazia, e as chaves, e assim por diante. 

E vamos apenas focar o que, pelo menos, intuitivamente, pode saltar para fora em você já. Na verdade, o principal, eu não sei necessariamente sabem o que é isso, mas muito parecido com zero tinha que quando bandeira verde clicado parte do enigma, o mesmo acontece com C como linguagem de programação tem uma peça principal de código que é executado por padrão. E realmente, é, literalmente, vai ser chamado principal. 

Assim principal é uma função. E é uma função especial que existe em C que, quando você executar um programa, é principal que é executado por padrão. No mundo do Scratch, era geralmente quando a bandeira verde clicado que foi executado por padrão. 

Enquanto isso, temos visto isso antes, printf ou imprimir formatado, que é vai ser uma função que vem com C, junto com um monte de outros, que a vontade de tempo e tempo de novo, a fim de fazer exatamente como o próprio nome sugere, imprimir algo. O que queremos imprimir? Bem, vamos ver que por personagens que encerram como o mundo these-- Olá, barra invertida n entre aspas duplas, podemos dizer exatamente printf o que imprimir na tela. 

Mas, a fim de fazer que, infelizmente precisa tomar algo que é já enigmática para nós seres humanos, mas pelo menos é um pouco readable-- afiada incluem, io.h standard, int, principal, vazio, printf, toda a mágica encantamentos que acabamos de ver na tela. Mas nós realmente temos que ir mais misterioso ainda. Primeiro precisamos de traduzir o código que escrever em código de máquina. E lembro desde a semana passada que as máquinas, pelo menos os que sabemos aqui, no fim do dia única compreender zeros e uns. 

E, meu Deus, se tivéssemos de escrever estas zeros e uns que realmente programa, que seria muito, muito rapidamente levar a diversão fora de qualquer coisa. Mas acontece que, por semana passada, que esses padrões de zeros e uns só tem significado especial. Em certos contextos, eles podem significar números. 

Em alguns contextos, eles podem significar letras ou cores, ou qualquer número de outras abstrações lá em cima. Mas, assim como o seu computador tem uma CPU, Central Processing Unit, ou o cérebro dentro do seu computador. É geralmente Intel dentro, porque é isso uma das maiores empresas que faz CPUs para computadores. 

Bem, CPUs Intel e outros simplesmente ter decidido antecipadamente que certos padrões de zeros e queridos deve significar coisas específicas. Certos padrões de zeros e uns vai significar, imprimir esta para a tela, ou adicionar esses dois números, ou subtrair esses dois números, ou mover este pedaço de dados de memória do meu computador aqui, ou qualquer número de outras nível muito baixo, mas em última análise útil, operações. Mas, felizmente, nós, humanos, não vão precisar saber esse nível de detalhe. De fato, assim como da última vez, onde nós abstraída de novo, e de novo, e de novo, construção de muito baixo nível primitivos como zeros e uns a conceitos de nível mais alto como números e letras, e cores, e mais, nós também podemos como programadores ficar sobre os ombros de outros que vieram antes de nós e usar o software que outra pessoas têm escrito antes US-- ou seja, programas chamados compiladores. 

C é uma linguagem que geralmente é compilado, o que significa convertido a partir de código fonte para código de máquina. Em particular, o que isso significa é que, se você tem a sua fonte código que você mesmo escreve, como nós em breve vai em apenas um momento na tela, e você quer convertê-lo finalmente, a máquina code-- esses zeros e uns que apenas o seu Mac ou PC understands-- você tem um primeiro alimentar esse código-fonte em como entrada para um especial programa chamado compilador, a saída dos quais nós deve ver é o código de máquina. E, de fato, a última vez que nos falamos sobre, realmente, no final do dia, problema resolvido. Você tem entradas. E você tem saídas. E você tem algum tipo do algoritmo no meio. 

Algoritmos podem certamente ser implementadas em software, como vimos com pseudocódigo na semana passada e, como veremos com código real esta semana. E assim um compilador realmente apenas tem um conjunto de algoritmos dentro de que sabe como converter as palavras-chave especiais, como principal, e printf, e outros que acabamos viu nos padrões de zeros e aqueles que Intel dentro e outras CPUs realmente entende. Então, como fazemos isso? Onde é que vamos obter um compilador? 

A maioria de nós aqui tem um Mac ou um PC. E você está executando o Mac OS, ou Windows ou Linux ou Solaris, ou qualquer número de outras sistemas operacionais. E, de fato, poderíamos sair na web e baixar um compilador para o seu Mac ou PC para o seu sistema operacional em particular. Mas todos nós seria em páginas diferentes, por assim dizer. Nós teríamos um pouco diferentes configurações. E as coisas não funcionam da mesma forma. E, de fato, nos dias de hoje muitos de nós não usam software que é executado somente em nossos laptops. Em vez disso, usamos algo como um navegador que nos permite acessar web-based aplicações na nuvem. E ainda este semestre, vamos fazer exatamente isso. Vamos escrever aplicações ou software usando code-- não C, mas outras linguagens como Python e JavaScript-- que são executados na nuvem. 

E para fazer isso, nós mesmos durante o semestre vai realmente usar uma base de nuvem ambiente conhecido como CS50 IDE. Esta é uma programação baseada em web ambiente ou de desenvolvimento integrado ambiente, IDE, que é construído em cima de alguns software de código aberto chamado Cloud 9. E nós temos feito algum pedagógica simplificações para ele de modo a ocultar determinados recursos no as primeiras semanas que não precisa, Depois que você pode revelá-los e fazer mais o que quiser com o meio ambiente. 

E isso nos permite, também, a pré-instalar determinado software. Coisas como um chamado CS50 biblioteca, que veremos em breve fornece-nos em C com algum funcionalidade adicional. Então, se você vai para, em última instância, CS50.io, você será solicitado a efetuar login, e uma vez que você faz e criar uma conta para livre, você será capaz de acessar um ambiente que parece bastante como este. 

Agora, isso está no modo padrão. Tudo é bom e brilhante na tela. Muitos de nós têm o hábito de trabalhando em peça CS50 que é muito tarde para a noite. E assim alguns de vocês podem preferir transformá-lo em modo noite, por assim dizer. 

Mas, em última análise, o que você está vamos ver dentro CS50 IDE é de três areas-- distinta uma área na qual a esquerda seus arquivos vão ser na nuvem, uma área no canto superior direito onde o código vai ser editável. Você vai ser capaz de abrir guias individuais para qualquer programa que você escrever este semestre dentro desse canto superior direito. E então mais arcanely, e ainda assim poderosa, vai ser essa coisa na bottom conhecido como uma janela de terminal. 

Esta é uma velha escola Interface da Linha de comando, ou o CLI, que permite executar comandos na Computador-- neste caso, o computador no cloud-- para fazer coisas como compilar o código a partir do código fonte para código de máquina, para executar seus programas, ou para iniciar a sua servidor web, ou para acessar seu banco de dados, e qualquer número de outras técnicas que vai começar a usar antes do tempo. Mas para chegar lá, nós estamos vai realmente ter ir online e começar a jogar. E para fazer isso, vamos primeiro começar a mexer com a principal, e escrever a parte principal de um programa. E vamos usar essa função printf, que temos utilizado anteriormente, simplesmente para dizer alguma coisa. 

Então aqui eu já estou dentro de IDE CS50. Eu tenho registrado com antecedência. E eu completo exibido na janela. E assim, em última análise, você também em problemas próximos vai seguir os passos similares que irá fornecer a documentação online. Então você não precisa se preocupar com absorvendo cada etapa técnica pouco o que eu faço aqui hoje. 

Mas você vai ter uma tela como esta. Acontece que eu estar no modo de noite. E você pode iluminar tudo -se desativando o modo de noite. E no final da dia, você vai ver estes três principal areas-- o arquivo navegador à esquerda, as guias de código em cima, e a janela do terminal, na parte inferior. 

Deixe-me ir em frente e escrever o meu primeiro programa. Eu estou indo para ir preventivamente para arquivo, Salvar e salvar meu arquivo como hello.c. Na verdade, por convenção, qualquer que programa gravação que está escrito na linguagem C deve ser nomeado algo dot c, por convenção. Então eu vou nomeá-lo hello.c, porque Eu só quero dizer Olá para o mundo. Agora vou para aumentar fora e clique em Salvar. E tudo o que tenho aqui agora é um guia em que eu possa começar a escrever código. 

Isso não vai compilar. Isso não significa nada. E por isso mesmo que eu converti isso para zeros e uns, a CPU vai ter nenhuma idéia do que está acontecendo ao redor. Mas se eu escrever as linhas que coincidem -se com o ser C conventions-- de C, novamente, desta language-- com sintaxe como isso, printf Olá mundo-- e não tenho sentiram confortáveis ​​com fazendo isso ao longo do tempo. Então eu não acho que fiz quaisquer erros tipográficos. 

Mas, invariavelmente, o primeiro vez que fizer isso, você vai. E o que eu estou prestes a fazer muito pode assim não funcionar para você pela primeira vez. E isso é perfeitamente normal, porque agora você pode apenas ver um monte de novidade, mas ao longo do tempo uma vez que você se familiarizar com este ambiente, e esta linguagem, e outros, você vai começar a ver as coisas que ou são corretas ou incorretas. 

E é isso que o companheiros de ensino e curso assistentes ficar tão bom em ao longo do tempo, é detectar erros ou erros em seu código. Mas afirmam que há há erro neste código. Então agora eu quero executar este programa. 

Agora no meu próprio Mac ou PC, estou em o hábito de ícones duplo clique quando eu quero executar algum programa. Mas isso não é o modelo aqui. Neste ambiente, o que é CS50 IDE. Estamos usando uma operação sistema chamado Linux. Linux é uma reminiscência de uma outra sistema operacional, geralmente conhecido como Unix. E Linux é particularmente conhecido por ter uma linha de comando Ambiente, CLI. Agora, estamos usando uma específica sabor do Linux chamada Ubuntu. E Ubuntu é simplesmente uma determinada versão do Linux. 

Mas estes do Linux nos dias de hoje fazem, na verdade, vêm com interfaces gráficas de usuário. E o que acontecerá com estar usando aqui é baseado na web. Portanto, este pode parecer até mesmo um pouco diferente de algo você mesmo pode ter visto ou executado no passado. 

Então, eu estou indo para ir em frente agora e faça o seguinte. Guardei esse arquivo como hello.c. Eu estou indo para ir em frente e Tipo clanghello.c Então Clang para a linguagem C é um compilador. É pré-instalado no CS50 IDE. E você pode absolutamente fazer download e instalar em seu próprio Mac ou PC. 

Mas, mais uma vez, você não tem todas a pré-configuração feito para você. Então, por agora, eu sou apenas vai correr clanghello.c. E agora perceber esta sintaxe aqui acabará realizar apenas significa que eu estou em um pasta ou diretório chamado Workspace. Este sinal de dólar é apenas uma convenção de sentido, digite os comandos aqui. 

É o que se chama um prompt, basta por convenção é sinal de dólar. E se eu ir em frente agora e clique Enter, nada parece ter acontecido. Mas isso é realmente uma coisa boa. A menos que acontece sobre sua tela, o mais provável seu código é ser correto, pelo menos sintacticamente. 

Então, se eu quiser executar este programa, o que eu faço? Bem, verifica-se que o nome padrão por convenção para os programas quando você não especificar um nomear para o seu programa é apenas a.out. E esta sintaxe também, você vai se familiarizar com antes do tempo. 

Dot cortar apenas significa que, hey, CS50 IDE, executar um programa chamado a.out que está dentro de meu diretório atual. Isso ponto significa o diretório atual. E vamos ver o que outras sequências de caracteres significa antes do tempo. 

Então, vamos lá, Enter, Olá mundo. E você vai notar, que o que aconteceu? Não só imprimir Olá mundo. É também movido a cursor para a próxima linha. 

E por que isso? Qual era o código que escreveu antes que garantir-se que o cursor seria ir para a próxima linha? Coisa engraçada sobre um computador é que só vai para fazer literalmente o que você diga a ele para fazer. 

Então, se você diga a ele para printf Olá, vírgula, espaço, mundo, perto citações, é, literalmente, só vai para imprimir esses caracteres. Mas eu tinha esse caráter especial no final, recall, barra invertida n. E é isso que garantiu que o personagem passou para a próxima linha da tela. 

Na verdade, deixe-me ir e fazer isso. Deixe-me ir em frente e eliminar este. Agora, observe que o topo da minha tela há um pouco de luz vermelha na a guia indicando, hey, você não salvou seu arquivo. Então, eu estou indo para ir em frente com o controle S ou o comando S, salve o arquivo. Agora goes-- fui para um verde moment--. E agora ele está de volta para apenas a ser um ícone de perto. 

Se eu agora executar clanghello.c de novo, Enter, barra ponto, a.out, Enter, você vai ver que ele ainda trabalhava. Mas é, sem dúvida, um pouco buggy. Neste momento, o meu trabalho prompt--, e depois que o sinal de dólar, e depois o meu prompt-- real é tudo na mesma linha. Então, isso certamente um bug estética, mesmo que isso não é realmente um bug lógico. 

Então eu vou para desfazer o que eu fiz. Eu estou indo para executar novamente a.out. Repare que eu adicionar o newline personagem de volta. Eu salvou o arquivo. 

Então, eu estou indo para executar novamente a.out, e- caramba, um erro, um erro que significa erro. Assim, o erro é que, embora Eu adicionei a barra invertida n lá, re-salvos, re-correu o programa, o comportamento era a mesma. Por que isso seria? 

Eu estou faltando uma etapa, certo? Esse passo chave no início foi que você tem a-- quando você alterar seu código-fonte, verifica-se também executar -lo através do compilador novamente de modo a obter um novo código de máquina. E o código de máquina, os zeros e uns, vão ser quase idêntico, mas não perfeitamente assim, porque precisamos, é claro, que a nova linha. 

Então, para corrigir isso, eu vou precisar executar novamente clanghello.c, entrar, dot slash, a.out. E agora, Olá mundo está de volta para onde eu esperava que fosse. Então, isso é tudo muito bem e bom. Mas a.out é um nome muito estúpido para uma programa, mesmo que ele passa a ser, por razões históricas, o default-- significando saídas de montagem. 

Mas deixe-me ir em frente aqui e fazer isso de forma diferente. Eu quero o meu programa Olá mundo para realmente ser chamado Olá. Então, se fosse um ícone no meu desktop, ele não seria a.out. Ele seria chamado Olá. 

Então, para fazer isso, verifica-se que Clang, como muitos programas, suporta os argumentos da linha de comando, ou bandeiras, ou interruptores, que simplesmente influenciar o seu comportamento. Especificamente, Clang suporta um traço o bandeira, que, em seguida, toma uma segunda palavra. Neste caso, eu vou arbitrariamente, mas razoavelmente, chamá-lo Olá. Mas eu poderia chamá-lo de qualquer coisa Eu quero, exceto a.out, que Seria muito além do ponto. 

E depois é só especificar o nome do arquivo que eu quero para compilar. Então, agora mesmo que no início do comando ainda tenho Clang, no final do comando Eu ainda tenho o nome do arquivo, Agora tenho esses linha de comando argumentos, esses sinalizadores que estão dizendo, oh, por sinal, output-o, um arquivo chamado Olá, não o a.out padrão. 

Então, se eu acertar Entre agora, nada parece ter acontecido. E, ainda, agora eu posso fazer barra dot Olá. Portanto, é o mesmo programa. Os zeros e uns são idênticas no final do dia. 

Mas eles estão em dois diferente a.out files--, que é a primeira versão e apenas tolamente nomeado, e agora Olá, que é um tanto nome mais atraente para um programa. Mas, honestamente, eu nunca estou vai se lembrar isso de novo, e novamente, e novamente. E, na verdade, como se escreve programas mais complicados, os comandos que você está vai ter que escrever vão ficar ainda ainda mais complicado. 

E assim não se preocupar. Acontece que os seres humanos antes nós já perceberam que eles também tive esse mesmo problema exato. Eles também não gostava de ter que digitar comandos bastante longos, misterioso, muito menos se lembrar deles. E assim os seres humanos antes de nós fizeram outros programas que tornam mais fácil para compilar o seu software. 

E, de fato, uma tal programa é chamado Marca. Então, eu estou indo para ir em frente e fazer isso. Eu estou indo para desfazer tudo o que eu acabou de fazer da seguinte maneira. Deixe-me escrever LS. E você verá três coisas- a.out, e uma estrela, Olá e uma estrela, e hello.c. Esperemos que este deve ser um pouco intuitivo, na medida em que não havia anteriormente nada neste espaço de trabalho. Não havia nada que eu tinha criado até que começamos a classe. 

E eu criei hello.c. Eu, então, compilou, e chamou-a.out. E então eu compilado-lo novamente ligeiramente diferente e chamou-lhe Olá. Então, eu tenho três arquivos nesse diretório, nesta pasta chamada Workspace. Agora, eu posso ver que bem se eu diminuir o zoom na verdade. 

Se eu aumentar aqui e olhar para esse lado superior direito canto, como prometido à esquerda lado da tela é sempre vai mostrar-lhe o que está na sua conta, o que é dentro de IDE CS50. E há três arquivos lá. 

Então, eu quero me livrar de a.out e Olá. E como você pode imagine intuitivamente, você poderia tipo de controle clique ou clique direito sobre esta. E este pequeno menu aparece. Você pode baixar o arquivo, execute -lo, visualizá-lo, atualizar, renomear, ou que não. 

E eu poderia simplesmente apagar, e ia embora. Mas vamos fazer as coisas com um comando linha por agora, de modo a ficar confortável com isso, e fazer o seguinte. Eu estou indo para ir em frente e remover a.out digitando literalmente rma.out. Acontece que, o comando para remover ou apagar alguma coisa, não é remover ou apagar. 

É mais sucintamente RM, apenas para economizar -lhe algumas teclas, e pressione Enter. Agora vamos ser um pouco enigmaticamente remover a.out arquivo regular. Eu realmente não sei o que é um arquivo irregular seria ainda. Mas eu quero removê-lo. 

Então eu vou para digitar y para sim. Ou eu poderia escrevê-lo para fora, e pressione Enter. E, novamente, nada parece acontecer. Mas isso é, em geral, uma coisa boa. 

Se eu digitar LS desta vez, o que devo ver? Felizmente, apenas Olá e hello.c. Agora, como um aparte, você vai notar esta estrela, asterisco, isso é no final de meus programas. E eles também estão aparecendo em verde. Isso é apenas a maneira da CS50 IDE de cluing-lo para o fato que isso não é código-fonte. Isso é um executável, um executável programa que você pode realmente executar fazendo barra ponto, e então é nome. 

Agora, deixe-me ir em frente e remover isso, rm Olá, Enter, remover regulares arquivo Olá, sim. E agora se eu digitar LS, estamos de volta para hello.c. Tente não excluir seu código-fonte real. Mesmo que haja recursos incorporado IDE CS50 onde você pode passar por seu histórico de revisão e retroceder no tempo, se você acidentalmente apagar alguma coisa, faça estar atento como por esses avisos sim ou não, do que você realmente quer fazer. E se eu for até o topo deixou canto aqui, tudo o que resta é hello.c. Portanto, não há cachos de outros comandos que você pode executar no mundo do Linux, um dos quais é, novamente, Make. E nós estamos indo fazer meu programa agora como se segue. 

Em vez de fazer clang, em vez de fazer clang-o, Vou simplesmente literalmente, tipo, marca Olá. E agora notar, estou não digitando make hello.c. Estou digitando make Olá. 

E este programa Faça esse vem com IDE CS50, e mais geralmente com Linux, é um programa que é vai fazer um programa chamado Olá. E ele vai assumir, por convenção, que se este programa pode ser feita, que vai ser feita a partir de uma fonte arquivo de código que terminam em c ponto, hello.c. 

Então, se eu pressione Enter Agora, observe que o comando que é executado é, na verdade ainda mais antes do que antes. E isso é porque nós temos IDE CS50 pré-configurado para ter alguns recursos adicionais construídos em que nós apenas ainda não precisam, mas em breve. Mas a principal coisa a perceber é agora eu tenho um programa Olá. 

Se eu digitar LS novamente, eu ter um programa Olá. E eu posso executá-lo com dot cortar a.out, não, porque todo o ponto deste exercício foi dot Olá barra. E agora eu tenho meu programa Olá mundo. Então, movendo-se para a frente, estamos quase sempre apenas indo para compilar nossos programas usando o comando make. E então nós estamos indo para executá-los por dot slash, e o nome do programa. Mas percebem o que fazem está fazendo por você, não é por si não é um compilador. É apenas um programa de conveniência que sabe como provocar um compilador para executar para que você mesmo pode usá-lo. 

O que existem outros comandos no Linux, e por sua vez o CS50 IDE? Nós verá logo que há uma comando CD, Change Directory. Isso permite que você dentro sua interface de linha de comando para seguir em frente, e para trás, e abrir pastas diferentes sem usar o mouse. 

LS que vimos, que significa lista os arquivos no diretório atual. Faça Dir, você pode provavelmente começar a inferir o que elas significam agora-- fazer diretório, se você quiser criar uma pasta. RM para remover, RM Dir para remover directory-- e estes, mais uma vez, são a linha de comando equivalentes de o que você poderia fazer em CS50 IDE com o mouse. Mas você vai encontrar em breve que às vezes é apenas muito mais rápido que fazer coisas com um teclado, e, finalmente, uma muito mais poderosa. 

Mas é difícil argumentar que qualquer coisa que tenho feito até agora é tudo o que poderoso, quando tudo temos vindo a dizer é, Olá mundo. E, na verdade, eu codificado a palavras Olá Mundo em meu programa. Não há dinamismo ainda. Scratch foi uma ordem de magnitude mais interessante na semana passada. 

E assim vamos chegar lá. Vamos dar um passo para que, forma de algumas destas funções. Assim, não só C vêm com printf, e cachos de outras funções alguns dos quais vamos ver ao longo do tempo, isso não acontece torná-lo tão fácil para a direita fora do portão no sentido de obter a entrada do usuário. 

Na verdade, um dos pontos fracos de linguagens como C, e até mesmo Java e ainda os outros, é que não faz torná-lo fácil de obter apenas coisas como inteiros de usuários, ou cordas, palavras, e frases, deixar as coisas sozinho como valores de ponto ou números reais flutuante com pontos decimais, e realmente números longos, como veremos em breve. Portanto, esta lista de funções aqui, estes são como outras peças do risco de quebra-cabeça que têm pré-instalado no CS50 IDE que usaremos durante algumas semanas como rodinhas de tipos e eventualmente, levá-los fora, e procurar por baixo da capa, talvez, em como essas coisas são implementadas. 

Mas, para isso, vamos realmente escrever um programa. Deixe-me ir em frente agora. E eu estou indo para criar um novo arquivo clicando neste pouco mais, e clicando em Novo arquivo. 

Eu estou indo para salvar esta próxima um, como, digamos, string.c, porque eu quero jogar com cordas. E string em C é apenas uma sequência de caracteres. Então agora vamos em frente e faça o seguinte. 

Incluir padrão IO.h-- e verifica-se padrão de IO, IO significa apenas entrada e saída. Assim, verifica-se que esta linha aqui é o que são os EUA vizinha de usar printf. Printf, é claro, produz uma saída. Portanto, a fim de usar printf, verifica-se fora você tem que ter esta linha de código na parte superior do seu arquivo. 

E vamos voltar ao que que realmente significa antes do tempo. Acontece que em qualquer programa C que eu escrevo, Eu tenho que iniciá-lo com código que se parece com isso. E você notará CS50 IDE, e outro desenvolvimento integrado ambientes como ele, vão tentar o melhor eles podem terminar o seu pensamento. Na verdade, há um momento se eu desfazer o que eu fiz, eu pressione Enter. 

Eu, então, bateu encaracolados aberta cinta, pressione Enter novamente. E terminei o meu pensamento. Ela me deu uma nova linha, recuado não menos por razões estilísticas agradáveis ​​vamos ver. E então ele automaticamente me deu que chaveta para terminar o meu pensamento. Agora, nem sempre adivinhar o que você quer fazer. Mas, em grande parte, ele faz poupar algumas teclas. Então, há pouco, nós corremos esse program-- Olá, mundo, e então compilou, e, em seguida, ele correu. Mas não há dinamismo aqui. O que se quiséssemos fazer algo diferente? Bem, o que se eu quisesse realmente obter uma seqüência do usuário? Vou usar uma peça do puzzle chamado exatamente isso-- obter string. 

Acontece que em C que, quando você não quer a contribuir para uma parte do enigma, ou mais propriamente a uma função, literalmente apenas fazer parêntese de abertura, perto parênteses. Por isso, é como se houvesse nenhuma caixa branca para digitar em. O bloco de dizer antes tinha uma pequena caixa branca. Não temos essa caixa branca agora. 

Mas quando eu chamo cadeia get, I quer colocar o resultado em algum lugar. Assim, um paradigma muito comum em C é a chamar uma função, como string de chegar aqui, e depois armazenar o valor de retorno. É o resultado de sua esforço em alguma coisa. 

E qual é a construir na programação, se em zero ou empresa C, que nós pode usar para realmente armazenar alguma coisa? Chamou-lhe uma variável, certo? E em risco, nós realmente não importo com o que estava acontecendo em variáveis. 

Mas, neste caso, nós realmente fazem. Eu vou dizer string. E então eu poderia chamar isso o que eu quiser. Vou chamá-lo nome, recebe obter string. 

E agora, mesmo se você estiver um pouco novo para isso, notar que eu estou faltando alguns detalhes. Eu estou esquecendo um ponto e vírgula. Eu preciso terminar este pensamento. Então, eu vou mover meu cursor, e bater ponto e vírgula lá. E o que eu fiz? Nesta linha de código, número 5, no momento, Eu estou chamando cadeia get sem entradas. Portanto, não há pouco de branco caixa como o Save bloco tem. 

Só estou dizendo, hey, computador, me uma corda. O sinal de igual não é realmente um sinal de igual, per se. É a atribuição operador, o que significa, hey, computador, mova o valor da direita para a esquerda. E na esquerda, eu tenho a seguinte. 

Hey, computador, dá-me um string-- uma sequência de caracteres. E chamar esse nome string. E eu nem sequer têm de chamá-lo Name. 

Eu poderia chamá-lo, convencionalmente, algo como S, bem como usamos i para chamar a variável i. Mas agora eu preciso fazer algo com ele. Seria muito estúpido para tente compilar este código, executando este programa, embora Estou recebendo uma corda, porque ainda é apenas vai dizer Olá mundo. 

Mas e se eu quero mudar isso. Por que não fazer isso? Percent s, vírgula s. E isso é um pouco enigmática ainda. 

Então deixe-me fazer o meu variáveis ​​mais clara. Deixe-me citar essa Nome variável. E vamos ver se não podemos provocar além o que está acontecendo aqui. 

Então, na linha de cinco, eu estou recebendo uma string. E eu estou armazenando essa seqüência, tudo o que o usuário digitou no no seu teclado, em uma variável chamada nome. E verifica-se que printf não apenas receber um argumento em dobro citações, uma entrada entre aspas duplas. 

Pode demorar duas, ou três, ou mais, tais que o segundo, ou terceiro, ou quarto, são todos os nomes de variáveis, ou valores especificamente, que pretende ligar a, dinamicamente, essa cadeia entre aspas. Em outras palavras, o que Seria errado com isso? Se eu apenas disse Olá nome, barra invertida n, salvo meu arquivo, compilado meu código, e correu isso, o que aconteceria? 

É só vai dizer, Olá citar, literalmente N-A-M-E, que é uma espécie de idiota, porque não é diferente do mundo. Então, qualquer coisa entre aspas é o que, literalmente, será impresso. Então, se eu quiser ter um espaço reservado lá, Na verdade, eu preciso usar alguma sintaxe especial. E acontece que se você ler o documentação para a função printf, ele irá dizer-lhe que se você usar por cento s, você pode substituir um valor como se segue. 

Depois de uma vírgula depois disso aspas duplas, você simplesmente escrever o nome do variável que você quer para ligar para esse formato código, ou especificador de formato, por cento s para cordas. E agora, se eu tenho guardado o meu arquivo, Eu voltar para o meu terminal. E eu digito Faça String, porque, mais uma vez, o nome do presente arquivo que eu escolhi antes é string.c. 

Então eu vou dizer Faça String, entrar. Oh meu Deus, olhar para todos os erros que já fez. E isso é-- o quê, isso é realmente como um, sete programa de linha de seis? Portanto, este é onde ele pode muito rapidamente obter esmagadora. 

Esta janela de terminal tem agora só regurgitado um grande número de mensagens de erro. Certamente, eu não tenho mais de erro mensagens do que eu tenho linhas de código. Então, o que está acontecendo? 

Bem, a melhor estratégia para fazer a qualquer momento você não encontrar uma esmagadora lista de erros como esse, é rolar para trás, olhar para o comando que acabou de correr que no meu caso é fazer string. Olhe para o que tornam o fez, e que é isso comando longo Clang, não é grande coisa lá. 

Mas o vermelho é ruim. Verde está tentando ser gentil e prestativa. Mas ainda é ruim, nesse caso. Mas onde é ruim? 

String.c, linha de cinco, de cinco caracteres. Portanto, esta é apenas uma convenção comum. Algo cólon algo significa número de linha e número de caracteres. Erro, o uso de não declarado cadeia do identificador. Pensou padrão em? 

Então, infelizmente, Clang está a tentar ser útil. Mas é errado, neste caso. Não, Clang, eu não quis dizer IO padrão. Eu quis dizer que na linha um, sim. 

Mas a linha cinco é este aqui. E Clang não entender S-T-R-I-N-L. É um identificador não declarado, a palavra que nunca viu antes. E isso é porque C, a linguagem estamos escrevendo código no agora, não tem variáveis ​​chamadas cordas. 

Não se trata, por padrão, o suporte algo chamado uma corda. Isso é um pedaço de CS50 jargão, mas muito convencional. Mas eu posso corrigir isso como se segue. 

Se eu adicionar uma linha de código para o início do programa, incluem CS50.h, que é outro arquivo em algum lugar dentro de CS50 IDE, em algum lugar no disco rígido, por assim dizer, do sistema operacional Ubuntu que eu estou correndo, que é o arquivo que é vai ensinar o funcionamento sistema que uma string é, apenas como io.h padrão é o arquivo no sistema operacional que é indo para ensinar-lhe o que printf é. 

Na verdade, teríamos conseguido uma mensagem muito semelhante Se Io tinha admitido padrão Io.h e tentou usar printf. Então, eu estou indo para ir em frente e apenas tomar controle L para limpar a minha tela. Ou você pode digitar clara e vai apenas limpar a janela de terminal. Mas você ainda pode rolar de volta no tempo. 

E eu estou indo para executar novamente Faça cadeia. Cruzar os dedos desta vez, Enter. Oh meu Deus, funcionou. ele me mostra um comando longo críptica que é o que fazem gerado via Clang, mas nenhuma mensagem de erro. Então percebe, embora você pode ficar completamente sobrecarregado com a número de mensagens de erro, ele só poderia ser esta cascata irritante efeito, onde Clang não entende uma coisa, o que significa que, em seguida, não entende a palavra seguinte, ou a linha seguinte. E por isso só engasga com seu código. Mas a correção pode ser simples. E por isso sempre se concentrar no primeira linha de saída. E se não o fizer compreendê-lo, basta olhar para palavras-chave que pode ser pistas, e o número da linha, eo caráter, onde esse erro pode ser. 

Agora deixe-me ir em frente e digite dot slash, corda, entrar. Hm, não está dizendo Olá nada. Por quê? Bem, lembro, onde está a correr? 

Ele provavelmente está preso no momento em um loop, se quiserem, na linha seis, porque Obter Cordas de design, escrito pela equipe CS50, é literalmente significa apenas sentar lá esperando e esperando, e à espera de uma cadeia. Tudo o que quer dizer com cadeia é de entrada humana. Então você sabe o quê? Deixe-me ir em frente. E apenas por um capricho, deixe-me escreva o meu nome, David, entrar. Agora eu tenho um programa mais dinâmico. Ele disse, Olá David. 

Se eu ir em frente e executar isso de novo, deixe-me tentar dizer o nome Zamila, entrar. E agora temos um programa dinâmico. Eu não codificado mundo. Eu não codificado nome, ou Davi, ou Zamila. 

Agora é muito mais parecido com os programas sabemos, em que se tirar a entrada, ele produz saída ligeiramente diferente. Agora, este não é o melhor experiência do usuário, ou UX. Eu executar o programa. 

Eu não sei o que eu deveria a fazer, a menos que eu realmente olhar para ou lembrar o código-fonte. Então, vamos fazer o usuário experimentar um pouco melhor com a mais simples das coisas. Deixe-me voltar a este programa, e simplesmente dizer printf. 

E deixe-me ir em frente e dizer o nome, cólon, e um espaço e, em seguida, um ponto e vírgula. E apenas por diversão, sem folga n. E isso é deliberada, porque eu não quero a solicitação para mover para a próxima linha. 

Quero, em vez disso, fazer isso, faça cadeia recompilar o meu código em nova máquina código dot cortar string. Ah, isso é muito mais bonita. Agora eu realmente sei o que o computador quer que eu faça, dar-lhe um nome. 

Então, eu estou indo para ir em frente e digite em Rob, entrar, e Olá, Rob. Assim, perceber, esta ainda é, no final do dia, somente um programa de nove linha. Mas temos tido esses passos de bebê. 

Nós escrevemos uma linha com a qual estavam familiarizados printf, Olá mundo,. Em seguida, desfez um pouco disso. E nós realmente utilizados cadeia get. E nós jogou esse valor em uma variável. E, em seguida, fomos em frente e melhorado ainda mais com uma terceira linha. E este processo iterativo de escrever software é verdadeiramente chave. Em CS50 e na vida em geral, você geralmente não deve sentar-se, tem um programa em mente, e tentar escrever a coisa toda de uma vez. 

Ele vai, inevitavelmente, resultar em forma mais erros do que nós mesmos vimos aqui. Mesmo eu, até hoje, constantemente fazer outros erros estúpidos, são erros realmente mais difícil que são mais difíceis de descobrir. Mas você vai cometer mais erros mais linhas de código que você escreve tudo de uma vez. E assim esta prática de, escrever um pouco de código que você está confortável, compilar -lo, executá-lo, testá-lo de modo mais geral, em seguida, passar on-- assim como mantivemos camadas e camadas na semana passada, construção de algo muito simples de algo mais complexo, fazer o mesmo aqui. Não se sente, e tentar escrever um problema inteiro. Realmente tomar estes passos de bebê. 

Agora, cordas não são todos tão útil para si mesmos. TEREMOS, na verdade, idealmente, como a têm algo mais em nossa caixa de ferramentas. Então vamos realmente fazer exatamente isso. 

Deixe-me ir em frente agora e chicote de um programa ligeiramente diferente. E nós vamos chamar este int.c, por inteiro. Vou, da mesma forma, incluem CS550.h. Eu estou indo para incluir padrão IO. E isso vai ser bastante comum nestes primeiros dias de aula. 

E eu vou pronto -me com uma função principal. E agora em vez de começar uma corda, vamos em frente e obter um int. Vamos chamá-lo i, e chamá-lo chegar int, parens próximos, ponto e vírgula. E agora vamos fazer algo com ele, printf. 

Vamos dizer algo como Olá, barra invertida n, vírgula i. Então, eu estou muito bem imitando o que eu fiz apenas um momento atrás. Eu tenho um espaço reservado aqui. Tenho vírgula i aqui, porque eu quero para ligar i em que espaço reservado. 

Então, vamos em frente e experimentar compilar este programa. O arquivo é chamado int.c. Então eu vou dizer, fazer int, entrar. Oh meu Deus, mas não é grande coisa, certo? Há um erro. 

Há um erro sintáctico aqui de tal forma que o programa não pode ser compilado dentro int.c, linha sete, caráter 27, o formato de erro especifica tipo char estrela, o que quer que seja. Mas o tipo de argumento é int. 

Então, aqui, também, não vamos a-- mesmo que hoje em dia é um monte de material, nós estamos indo para oprimi-lo com absolutamente todos os recursos do C, e programação de um modo mais geral, em apenas estas primeiras semanas. Portanto, há muitas vezes vai ser jargão com o qual você não está familiarizado. E, de fato, estrela char é algo vamos voltar a em vez de uma semana ou duas de. 

Mas, por agora, vamos ver se podemos analisar as palavras que são familiares. Formatos-- isso ouvimos formato especificador, código de formato antes. Isso é familiar. Type-- mas o argumento tem o tipo int. Espere um minuto, i é um int. 

Talvez por cento s na verdade, tem algum significado definido. E, de fato, ele faz. Um inteiro, se você quiser printf para substituí-lo, você realmente tem que usar um especificador de formato diferente. E você não saberia isso a menos que alguém lhe disse, ou você tinha feito isso antes. Mas o que é por cento de i pode ser utilizada em printf para ligar um inteiro. Você também pode usar cento d para um número inteiro decimal. Mas eu é agradável e simples aqui. Então, vamos ir com isso. 

Agora deixe-me ir em frente e reprise make int, Enter. Isso é bom, sem erros. Dot cortar OK int--, má experiência do usuário, porque eu não disse a mim mesmo o que fazer. Mas isso é bom. Eu estou pegando rapidamente. 

E agora deixe-me ir em frente e digitar David, OK, Zamila, Rob. OK, então isso é uma coisa boa. Desta vez, estou usando uma função, uma peça do puzzle, chamado get int. E acontece out-- e nós vamos ver isso mais tarde no term-- a equipe CS50 implementou obter seqüência de tal forma que ele vai só fisicamente obter uma corda para você. 

Ele implementou get int em de tal forma que ele só irá obter um número inteiro para você. E se você, o ser humano, não cooperar, é literalmente indo só para dizem repetir, repetir, repetir, literalmente sentado lá looping, até você obrigar com algum número mágico, como 50, e Olá 50. 

Ou se executar este novo e digite 42, Olá 42. E assim a função get int dentro desse enigma é a lógica suficiente, o pensamento suficiente, de descobrir, o que é uma palavra? E o que é um número? Apenas aceitar, em última instância, números. 

Assim, verifica-se que esta Não é tudo o que expressivo. tão longe. Então, yay, última vez que passou muito rapidamente em jogos de execução, e animação, e obras artísticas em zero. E aqui, estamos sendo conteúdo com Olá mundo, e Olá 50. 

Não é tudo o que inspirador. E, de fato, estes primeiros exemplos vai levar algum tempo a rampa até em emoção. Mas temos muito mais controlar agora, na verdade. E nós estamos indo muito iniciar rapidamente camadas em cima dessas primitivas básicas. 

Mas, primeiro, vamos entender quais são as limitações. Na verdade, uma das coisas Zero não é fácil vamos fazer é realmente olhar por baixo da capa, e entender o que é um computador é, o que ele pode fazer, e quais são as suas limitações. E, de fato, que a falta de compreensão, potencialmente, a longo prazo pode levar a nossa própria escrita mistakes-- bugs, escrevendo software inseguro que for cortada de alguma forma. 

Então, vamos dar alguns passos em direção a compreender isto um pouco melhor, forma de, digamos, o exemplo a seguir. Eu estou indo para ir em frente e implementar rapidinho um programa chamado Adder. Como, vamos adicionar alguns números juntos. E eu estou indo para codificar alguns cantos aqui, e simplesmente copiar e colar onde eu estava antes, apenas para que possamos ir mais cedo. Então agora eu tenho os princípios básicos de um programa chamado Adder. 

E vamos em frente e fazer isso. Eu estou indo para ir em frente e digamos, IntX recebe obter int. E sabe de uma coisa? Vamos fazer uma melhor experiência do usuário. 

Então, vamos apenas dizer que x é e, efetivamente, solicitar ao usuário a dar-nos x. E, em seguida, deixe-me ir em frente e dizer: printf como sobre y é, desta vez esperando dois valores a partir do utilizador. E então vamos apenas ir em frente e digamos, printf, a soma de x e y é. E agora eu não quero fazer por cento s. Eu quero fazer por cento i, barra invertida n, e em seguida, conecte valor da soma. 

Então, como posso fazer sobre isso? Você sabe o que? Eu sei como usar variáveis. Deixe-me apenas declarar um novo, int z. 

E eu vou dar um palpite aqui. Se houver sinais iguais nesta linguagem, talvez eu só posso fazer x mais y, enquanto eu terminar o meu pensou com um ponto e vírgula? Agora eu posso voltar para cá, conecte z, terminar este pensamento com um ponto e vírgula. E vamos ver agora, se estes sequências de lines-- x é obter int. Y é obter int. 

Adicionar x e y, armazenar o valor em z-- por isso, mais uma vez, lembre-se o sinal de igual não é igual. É atribuição da direita para a esquerda. E vamos imprimir que a soma de X e Y não é literalmente Z, mas o que está dentro de z. Então, vamos fazer Adder - agradáveis, sem erros desta vez. Dot cortar Adder, entrar, x vai ser 1. 

Y vai ser 2. E a soma de x e y é 3. Então, isso é tudo muito bem e bom. 

Então você pode imaginar que a matemática devem trabalhar em um programa como este. Mas você sabe o que? É esta variável, linha 12, mesmo necessário? Você não precisa adquirir o hábito de apenas armazenar coisas em variáveis apenas porque você pode. E, de fato, é geralmente má concepção ponderada se você estiver criando uma variável, chamado z, neste caso, o armazenamento em algo que, e, em seguida, imediatamente usá-lo, mas nunca novamente. Por que dar algo de um nome como z, se você está literalmente vai usar esse coisa apenas uma vez, e assim proximal ao local onde você criou -lo em primeiro lugar, tão perto em termos de linhas de código? Então você sabe o quê? Acontece que C é bastante flexível. Se eu realmente quero plug-in valores aqui, Eu não precisa declarar uma nova variável. Eu poderia apenas plug-in x mais y, porque C entende aritmética e operadores matemáticos. 

Então, eu posso simplesmente dizer, fazer essa matemática, x mais y, o que quer que esses valores são, conecte o resultante inteiro para essa cadeia. Portanto, este pode ser, embora apenas uma linha mais curta, um projeto melhor, um programa melhor, porque há menos código, portanto, menos para mim entender. E também é apenas mais limpo, na medida em que não estamos introdução de novas palavras, novos símbolos, como z, mesmo que eles realmente não servem muito de um propósito. 

Infelizmente, a matemática não é todos os que às vezes confiáveis. Vamos ir em frente e fazer isso. Eu estou indo para ir em frente agora e faça o seguinte. 

Vamos fazer printf, cento i, além de por cento i, será por cento i, barra invertida n. E eu vou fazer isto-- xyx mais y. Então eu só vou reescrever esta um pouco diferente aqui. Deixe-me apenas fazer uma verificação de sanidade rápida. Mais uma vez, não vamos ficar à frente de nós mesmos. Faça víbora, ponto barra víbora. x é 1, y é 2, 1 é mais 2 3. Então, isso é bom. Mas vamos complicar isso agora um pouco, e criar um novo arquivo. 

Eu vou chamar este, dizer, ints, plural para inteiros. Deixe-me começar de onde eu era um momento atrás. Mas agora vamos fazer algumas outras linhas. Deixe-me ir em frente e fazer o seguinte, printf, cento i, menos por cento i, é por cento i, vírgula x, vírgula yx menos y. Então, eu estou fazendo um pouco matemática diferente lá. Vamos fazer outro. Assim por cento de i vezes por cento i é por cento i, barra invertida n. Vamos plug-in x e y, e x vezes y de. Vamos usar o asterisco na o computador para vezes. 

Você não usa x. X é um nome de variável aqui. Você usar a estrela para a multiplicação. Vamos fazer mais um. Printf por cento eu, dividido por cento de i, é por cento de i, n barra invertida. xy dividido por y-- para que você use a barra em C para fazer a divisão. E vamos fazer um outro. Restante por cento i, divididos por cento de i, é por cento eu. xy-- e agora restante é o que sobrou. Quando você tentar dividir um denominador dentro de um numerador, quanto é deixado ao longo desse você não poderia dividir fora? 

Então não há realmente, necessariamente, um símbolo nós usamos na escola por isso. Mas lá em C. Você pode dizem x modulo y, onde este sinal de por cento neste context-- confusa quando você está dentro das aspas duplas, dentro de printf, cento é utilizado como o especificador de formato. 

Quando você usa por cento fora do em que uma expressão matemática, é o operador módulo para modular arithmetic-- para os nossos propósitos aqui, apenas significa, qual é a restante X dividido pelo y? Assim, X dividido pelo y é X Y barra. Qual é o resto de x dividido por y? É x y mod, como um programador diria. 

Então, se eu não cometeu erros aqui, deixe-me vá em frente e fazer ints, plural, agradável, e ints do corte do ponto. E vamos em frente e fazer, digamos, 1, 10. Tudo bem, 1, acrescido de 10 é 11, cheque. 1 menos 10 é negativo 9, confira. 

1 vezes 10 é 10, cheque. 1 dividido por 10 é-- OK, vamos pular essa. Resto de 1 dividido por 10 é 1. Está correto. Mas há um bug aqui. 

Então, o que eu colocar o meu entregar, não é correto. Quero dizer, é próximo de 0. 1 dividido por 10, você sabe, se estivermos cortar alguns cantos, com certeza, é zero. Mas ele realmente deve ser 1/10, 0,1, ou 0,10, 0,1000, ou assim por diante. 

Não deve ser realmente zero. Bem, verifica-se que o computador está fazendo literalmente o que disse para fazer. Estamos fazendo a matemática como x dividido por y. E ambos x e y, por as linhas de código anterior, são números inteiros. 

Além disso, na linha 15, que são dizendo printf, hey, printf plug-in um inteiro, plug-in um número inteiro, ligar um integer-- especificamente x, e, em seguida, y, e, em seguida, x dividido por y. x e y são inteiros. Nós somos bons lá. 

Mas o que é x dividido por x? X dividido pelo y deve ser, Matematicamente, 10/01, ou 0,1, que é um número real, um número real ter, potencialmente, um ponto decimal. Não é um número inteiro. 

Mas o que é o mais próximo número inteiro de 10/01, ou 0,1? Sim, tipo de é zero. 0,1 é assim muito. E 1 é muito presente. Assim, 1/10 está mais perto 0 que é para um. 

E então o que C está fazendo por US-- tipo de porque nós dito que a-- é truncar esse inteiro. É tomar o valor, que novamente é deveria ser algo como 0,1 mil, 0 e assim por diante. E está truncando tudo depois do ponto decimal de modo a que tudo isso material, porque não cabem na noção de um inteiro, que é apenas um número como negativo 1, 0, 1, cima e para baixo, ele joga fora tudo depois do ponto decimal, porque você não pode caber um ponto decimal em um número inteiro, por definição. 

Portanto, a resposta aqui é zero. Então, como podemos corrigir isso? Precisamos de uma outra solução em conjunto. E nós podemos fazer isso, como se segue. 

Deixe-me ir em frente e criar uma nova ficheiro, este chamado floats.c. E guardá-lo aqui no mesmo diretório, float.c. E deixe-me ir em frente e copiar alguns de que o código de mais cedo. 

Mas em vez de ficar um int, vamos fazer isso. Dê-me um valor de ponto flutuante chamado x. onde um ponto flutuante valor é apenas literalmente algo com um ponto flutuante. Ela pode mover-se para a esquerda, para a direita. É um número real. 

E deixe-me não chamar obter int, mas chegar float, que também estava entre o menu de opções na biblioteca C250. Vamos mudar y a uma bóia. Portanto, este torna-se obter float. 

E agora, nós não queremos para ligar ints. Acontece que nós temos que usar cento f para float, por cento f para float, e agora salvá-lo. E agora, dedos cruzados, fazer flutuadores, agradável, flutuadores do corte de ponto. x vai ser um 1. y Vai ser 10 novamente. 

E, bom, OK minha disso está correto. Eu estava esperando por mais, mas eu esqueci de escrever. Então, vamos ir e corrigir este erro lógico. 

Vamos em frente e agarrar o seguinte. Nós vamos apenas fazer um pouco de copiar e colar. E eu vou dizer de menos. 

E eu vou dizer vezes. E eu vou dizer dividida. E eu não vou fazer modulo, que não é tão pertinentes aqui, dividido por f, e vezes plus-- OK, vamos fazer isso novamente. 

Fazem flutuadores, bóias de barra ponto, e 1, 10, e- agradável, não, OK. Então, eu sou um idiota. Então, isso é muito comum em ciência da computação a cometer erros estúpidos como este. 

Para fins pedagógicos, o que eu realmente queria fazer foi mudar a ciência aqui para mais, para menos, à época, e para dividir, como você espera notado durante este exercício. Então agora vamos voltar a compilar este programa, faça flutuadores do corte de ponto. 

E pela terceira vez, vamos ver se ele atende às minhas expectativas. 1, 10, entrar, sim, OK, 1.000, dividido por 10,000, é 0,100000. E acontece que nós podemos controlar quantas números são depois desses pontos decimais. Nós realmente vai. Nós vamos voltar a isso. 

Mas agora, de fato, a matemática está correta. Então, mais uma vez, qual é o takeaway aqui? Acontece que em C, existem não só apenas strings-- e, de fato, não há realmente, porque nós adicionar aqueles com a biblioteca CS50. Mas não são apenas inteiros. 

Há também flutua. E verifica-se um monte de outros dados tipos também, que usaremos em pouco tempo. Acontece que se você quiser um único caráter, e não uma cadeia de caracteres, você pode usar apenas um char. 

Acontece que, se você quer um bool, um valor booleano, único verdadeiro ou falso, graças à biblioteca CS50, nós temos adicionado a C, o tipo de dados boleano bem. Mas também está presente em muitas outras línguas também. E acontece que às vezes você precisam de números maiores, em seguida, vêm por padrão com ints e carros alegóricos. 

E, de fato, um duplo é um número que usa nem 32 bits, mas 64 bits. E um longo tempo é um número que usa nem 32, bits, mas 64 bits, respectivamente, para ponto flutuante valores e inteiros, respectivamente. Então vamos realmente agora ver isso em ação. 

Eu estou indo para ir em frente aqui e chicote de um outro programa. Aqui, eu estou indo para ir em frente e não incluem CS50.h. E deixe-me ir, incluem padrão IO.h. 

E você vai notar algo funky está acontecendo aqui. Não é codificação de cores as coisas em da mesma forma como fazia antes. E ao que parece, isso é porque eu não deram a coisa um nome de arquivo. 

Eu vou chamar este sizeof.c, e bateu em Salvar. E observe o que acontece com o meu muito código de branco contra esse pano de fundo preto. Agora, pelo menos há alguns roxos lá. E é sintaxe destacada. 

Isso é porque, muito simplesmente, não tenho disse ao IDE que tipo de arquivo isso é dando-lhe um nome, e especificamente uma extensão de arquivo. Agora, vamos ir em frente e fazer isso. Eu estou indo para ir em frente e muito simplesmente imprimir o bool following-- é por cento LU. 

Nós vamos voltar a que em apenas um momento. E então eu vou tamanho de impressão de bool. E agora, apenas para economizar -me algum tempo, eu sou vai fazer um todo bando deles ao mesmo tempo. E, especificamente, eu vou alterar isso para um char e carvão. Este, eu vou mudar para um casal e uma de casal. 

Este, eu vou mudar a uma bóia e um flutuador. Este, eu vou mudar para um int e um int. E este, eu vou para mudar para um longo tempo. E ainda está tomando um longo tempo, muito tempo. 

E então, finalmente, dei me um demasiados, corda. Acontece que em C, não há o operador especial chamado tamanho do que é, literalmente, vai, quando executado, diga-nos o tamanho do cada uma destas variáveis. E este é um caminho, agora, podemos ligar de volta a discussão da semana passada de dados e de representação. 

Deixe-me ir em frente e compilar tamanho de tamanho de ponto de corte. E vamos ver. Acontece que em C, especificamente em CS50 IDE, especificamente na sistema operacional Ubuntu, que é um operacional de 64 bits sistema, neste caso, um booleano vai usar um byte de espaço. É assim que o tamanho é medido, não em bits, mas em bytes. E lembrar que um byte é oito bits. Assim, um bool, mesmo que você tecnicamente só precisa de um 0 ou 1, é um pouco desperdício como temos implementado. É realmente vai usar um todo byte-- para que todos os zeros, são talvez todos aqueles, ou algo parecido, ou apenas um 1 entre os oito bits. 

Um char, por sua vez, usado para um personagem como um caractere ASCII por semana passada, vai ser um personagem. E que sincroniza-se com a nossa noção de sendo não mais do que 256 bits-- vez, sincroniza-se com ele havendo mais de 8 bits, que nos dá até 256 valores. A dupla vai ser de 8 bytes ou 64 bits. 

Um flutuador é 4. Um int é de 4. Um longo, longo é 8. E uma corda é 8. Mas não se preocupar com isso. Nós vamos descascar essa camada. Acontece que, cordas podem ter mais de 8 bytes. 

E, de fato, nós escrevemos cordas já, Olá mundo, mais de 8 bytes. Mas vamos voltar a que em apenas um momento. Mas a tomada de distância aqui é o seguinte. 

Qualquer computador só tem uma finita quantidade de memória e espaço. Você só pode armazenar tantos arquivos no seu Mac ou PC. Você só pode armazenar tantos programas em RAM rodando ao mesmo tempo, necessariamente, mesmo com a memória virtual, porque você tem uma quantidade finita de RAM. 

E só para picture-- se você nunca abriu um laptop ou encomendados memória extra para um computador, você pode não saber que interior do seu computador é algo que se parece um pouco como isso. Portanto, esta é apenas uma empresa comum denominado Crucial que faz RAM para computadores. E RAM é onde os programas viver enquanto eles estão correndo. 

Assim, em todos os Mac ou PC, quando você dobrar clique um programa, e abre, e abre algum documento do Word ou algo assim, ele armazena-o temporariamente na RAM, memória RAM porque é mais rápido do que o seu disco rígido, ou o seu disco de estado sólido. Então é só onde os programas ir para viver quando eles estão em execução, ou quando os arquivos estão sendo usados. 

Então você tem coisas que parecem como este dentro do seu laptop, ou coisas um pouco maior dentro da sua área de trabalho. Mas a chave é que você só tem um número finito dessas coisas. E só há uma quantidade finita de hardware sentado nessa mesa direita Aqui. 

Então, com certeza, não podemos armazenar números infinitamente longos. E, ainda, se você acha que volta para escola, quantos dígitos pode você tem à direita de um ponto decimal? Para essa matéria, quantos dígitos podem você tem à esquerda do ponto decimal? Realmente, infinitamente muitos. 

Agora, nós, seres humanos só poderia sabe como se pronuncia milhões, e bilhões, trilhões, e quatrilhões, e quintilhões. E eu estou empurrando os limites do meu understanding-- ou meu-- eu entendo números, mas meu pronúncia dos números. Mas eles podem obter infinitamente grande, com infinitos dígitos à esquerda ou à direita de um ponto decimal. 

Mas os computadores têm apenas um quantidade finita de memória, um número finito de transistores, um número finito de lâmpadas no interior. Então, o que acontece quando você correr para fora do espaço? Em outras palavras, se pensar para trás a semana passada quando falamos sobre números -se a ser representado em binário, suponha que nós temos este valor de 8 bits aqui. 

E nós temos sete 1 e um 0. E suponha que queremos para adicionar 1 a este valor. Este é um número muito grande agora. 

Este é 254, se bem me lembro a matemática da semana passada direita. Mas o que se eu mudar 0 que mais à direita de um 1? O número inteiro, de Naturalmente, torna-se oito 1s. Portanto, ainda é bom. 

E que provavelmente representa 255, embora dependendo do contexto ele poderia realmente representar um número negativo. Mas mais sobre isso outra vez. Este parece que é sobre tão alto quanto eu posso contar. 

Agora, é apenas 8 bits. E o meu Mac, com certeza, tem forma mais de 8 bits de memória. Mas ele tem finito. Assim, o mesmo argumento se aplica, mesmo que temos mais destes queridos na tela. 

Mas o que acontece se você estiver armazenar esse número, 255, e você quer contar um pouco mais alto? Você quer ir de 255 a 256. O problema, é claro, é que se começar a contar do zero como na semana passada, você não pode contar como alta como 256, muito menos 257, muito menos 258, m porque o que acontece quando você adiciona um 1? Se você fizer a escola primária antiga abordagem, você colocar um 1 aqui, e, em seguida, 1 mais 1 é 2, mas isso é realmente um zero, você carrega a 1, transportar a 1, levar a 1. Todas estas coisas, Essas 1, ir para zero. E você acabar, sim, como alguém apontou, a 1 sobre o lado esquerdo. Mas tudo o que puder realmente ver e caber na memória é apenas oito 0 do, o que quer dizer em algum momento, se você, um computador, tentou contagem alta o suficiente, você está vai envolver em torno de, ao que parece, a zero, ou talvez mesmo negativo números, que são ainda mais baixos do que zero. 

E nós pode tipo de ver isso. Deixe-me ir em frente e escrever um verdadeiro programa rápido aqui. Deixe-me ir em frente e escrever um programa chamado estouro. Incluir CS50.h, incluem padrão IO.h-- oh, Eu realmente perdi o meu destaque de sintaxe. Então, vamos guardá-lo como overflow.c. 

E void-- principal agora int e em pouco tempo, vamos voltar a explicar por que nós continuar a escrever void main int. Mas, por enquanto, vamos apenas fazer -lo, levá-lo para concedido. Vamos dar-me um int, e inicialize-o a 0. 

Vamos então fazer por int i obter zero-- na verdade, vamos fazer um loop infinito e ver o que acontece. Enquanto verdade, então vamos imprimir n é por cento i, barra invertida n, plug-in n. Mas, agora, vamos fazer n recebe n + 1. 

Portanto, em outras palavras, em cada iteração deste ciclo infinito, vamos dar o valor de n, e adicionar 1 a ele, e, em seguida, armazenar o resultado em N na esquerda. E, de fato, vimos a sintaxe um pouco como este, brevemente. Um truque legal é, em vez de escrever tudo isso, você pode realmente dizer um n mais é igual a 1. 

Ou se você realmente quer ser extravagante, você pode dizer n plus plus-e-vírgula. Mas estes dois últimos são apenas o que chamaria de açúcar sintático para a primeira coisa. 

A primeira coisa é mais explícito, totalmente bem, totalmente correta. Mas isso é mais comum, eu vou dizer. Então, vamos fazer isso por apenas um momento. 

Vamos agora fazer estouro, o que soa bastante sinistro, estouro de corte de ponto. Vamos ver, n está ficando muito grande. Mas vamos pensar, o quão grande pode n receber? 

n é um inteiro. Vimos há pouco com o tamanho do exemplo, que é um int quatro bytes. Sabemos da semana passada, quatro bytes é 32 bits, pois 8 vezes 4, que tem 32 anos. Isso vai ser de 4 bilhões. 

E somos até 800.000. Isso vai demorar uma eternidade para contar tão alto quanto eu puder. Então, eu estou indo para a frente, como você pode em pouco tempo, e bateu C-- Controle francamente, Controle C, um monte, onde Controle C geral meios cancelar. Infelizmente, porque este está sendo executado na nuvem, por vezes, a nuvem é cuspindo tanta coisa, tanta saída, ele vai demorar um pouco para a minha entrada para chegar à nuvem. Assim, mesmo que eu bati Controle C alguns segundos atrás, este é definitivamente o lado efeito de um loop infinito. 

E assim, em tais casos, estamos vai deixar que seja. E nós estamos indo para adicionar outro janela de terminal aqui com o plus, que naturalmente não faz assim, uma vez que ainda está pensando. E vamos em frente e ser um pouco mais razoável. 

Eu estou indo para ir em frente e fazer esta única um número finito de vezes. Vamos usar um loop for, que aludi anteriormente. Vamos fazer isso. Dê-me outra variável int i recebe 0. i é menor do que, digamos, 64 i ++. E agora deixe-me ir em frente e de impressão a n é por cento i, vírgula n. E então n-- este ainda é vai levar para sempre. Vamos fazer isso. 

n recebe n vezes 2. Ou poderíamos ser extravagante e fazer vezes é igual a 2. Mas vamos apenas dizer que n iguala-se, 2 vezes. Em outras palavras, no presente nova versão do programa, Eu não quero esperar para sempre de como 800.000 para 4 bilhões. Vamos apenas acabar com isso. 

Vamos realmente dobrar n cada vez. Que, recall, duplicação é a oposto de ter, claro. E que na semana passada nós temos algo mais uma vez, e novamente, e, novamente, super rápido, duplicação irá certamente nos levar de 1 a a maior possível valor que podemos contar até com um int. 

Então, vamos fazer exatamente isso. E nós vamos voltar a este antes do tempo. Mas isso, novamente, é como o bloco de repetição em risco. E você vai usar este antes do tempo. 

Isto apenas significa contagem de zero até, mas não igual, a 64. E em cada iteração deste loop, basta manter incrementando i. Então i ++ - e esta construção geral na linha 7 é apenas uma maneira super comum de repetir algumas linhas de código, um certo número de vezes. Quais linhas de código? Estas chaves, como você pode ter adquirida a partir de agora, significa, faça o seguinte. 

É dentro como zero, quando tem os blocos amarelos e outras cores que tipo de abraçar ou abraçar outros blocos. Isso é o que esses encaracolado cintas estão fazendo aqui. Então, se eu tenho o meu sintaxe direita-- você pode ver o símbolo de cenoura no meio C isso é quantas vezes eu estava a tentar resolver este problema. Então, vamos livrar-se de que um completamente, e feche a janela. E nós vamos usar o novo. Faça estouro, Slash dot estouro, Enter, tudo bem, parece ruim no começo. Mas vamos rolar para trás no tempo, porque eu fiz isso 64 vezes. 

E observar pela primeira vez, n é 1. Segundo tempo, o símbolo n representa 2, em seguida, 4, depois 8, então com 16 anos. E parece que assim Eu chegar a cerca de 1 bilhão, se eu dobrá-la novamente, que deveria me dar 2 bilhões. Mas acontece, é direito na cúspide. 

E assim ele realmente transborda um inteiro de 1 bilhão a cerca de 2 negativo bilhões, porque um número inteiro, ao contrário do que números foram assumindo na semana passada, pode ser tanto positiva como negativa na realidade, e em um computador. E assim, pelo menos, um desses bits é eficazmente roubado. Então, nós realmente só tem 31 bits, ou 2 mil milhões de valores possíveis. 

Mas, por agora, o takeaway é bastante simplesmente, quaisquer que sejam esses números são e tudo o que a matemática é, algo ruim acontece, eventualmente, porque eventualmente você está tentando permutar os bits de um muitas vezes. E você efetivamente ir de tudo 1 de talvez para todos os 0 do, ou talvez apenas algum outro padrão que ele Claramente, dependendo do contexto, pode ser interpretada como um número negativo. E assim parece o mais alto I pode contar neste programa específico é apenas a cerca de 1 bilhão. Mas há uma solução parcial aqui. Você sabe o que? 

Deixe-me mudar a partir de um int para um longo tempo. E deixe-me ir em frente aqui e dizer-- eu vou ter para mudar isso para um sem assinatura longo. Ou, vamos ver, eu nunca me lembrar. 

Vamos em frente e fazer transbordar. Não, não é isso, LLD, obrigado. Então, às vezes Clang pode ser útil. Eu não me lembro o que o formato especificador foi por um longo tempo. 

Mas, na verdade, Clang me disse. O verde é uma espécie de bom, ainda significa que você cometeu um erro. É supondo que eu quis dizer LLD. 

Então deixe-me levá-la é um conselho, um longo longa número decimal, salvar isso. E deixe-me executá-lo novamente, dot cortar excesso, Enter. E agora o que é legal é isso. 

Se eu rolar para trás no tempo, nós ainda começar contando ao mesmo Place-- 1, 2, 4, 8, 16. Aviso, temos todo o caminho até 1 bilhão. Mas, então, chegar com segurança ao 2 bilhões. 

Então nós começamos a 4 bilhões, em seguida, 8 bilhões, 17 bilhões. E nós ir mais alto, e mais alto e mais alto. Eventualmente, isso, também, quebras. 

Eventualmente, com um longo tempo, que é o valor de 64 bits, não um valor de 32 bits, se você contar muito alto, você envolver em torno de 0. E, neste caso, nós acontecer acabar com um número negativo. 

Portanto, este é um problema. E verifica-se que este problema não é tudo o que arcano. Mesmo que eu tenha deliberadamente induzida com esses erros, verifica-se vemos que tipo de tudo nós, ou pelo menos alguns de nós em torno de fazer. 

Assim, em Lego Star Wars, se você já jogou o jogo, verifica-se que você pode ir ao redor quebrando as coisas no mundo LEGO, e recolha de moedas, essencialmente. E se você nunca jogou este jogo maneira muito tempo, como este indivíduo não identificado aqui fizeram, o número total de moedas que você pode coletar é, ao que parece, 4 bilhões. 

Agora, com ele é realmente arredondados. Então LEGO estava tentando manter as coisas amigável. Eles não fazê-lo exatamente 2 a a 32 de alimentação, por semana passada. Mas 4 bilhões é uma razão. Parece, com base nessas informações, que LEGO, ea empresa que fez este software real, decidiu que o número máximo de moedas o utilizador pode acumular é, na verdade, 4 bilhões, porque eles escolheram no seu código usar não um longo tempo, aparentemente, mas apenas um inteiro, um sem assinatura número inteiro, apenas a um número inteiro positivo, cuja valor máximo aproximadamente é isso. Bem, aqui está mais um engraçado. Assim, no jogo Civilization, que alguns de vocês podem estar familiarizados com verifica-se que anos atrás não era um bug neste jogo em que se você desempenhou o papel de Gandhi no jogo, em vez de ele ser muito pacifista, em vez disso foi incrivelmente, incrivelmente agressivo, em algumas circunstâncias. Em particular, a forma que a civilização obras é que se você, o jogador, adotar a democracia, o seu escore de agressividade fica diminuído em dois, de modo menos menos, e depois de menos de menos. 

Então você subtrair 2 sua iteração atual. Infelizmente, se a sua iteração é inicialmente 1, e você subtrair 2 a partir dele depois de adotar a democracia como Gandhi aqui pode ter feito, porque ele era muito passive-- 1 na escala de agressividade. Mas se ele adota a democracia, em seguida, ele vai de 1 a 1 negativo. 

Infelizmente, eles eram usando números não assinados, o que significa que eles trataram mesmo negativo números como se fossem positivos. E verifica-se que o equivalente positivo do negativo 1, em programas de computador típicos, é de 255. Então, se Gandhi adota democracia e, portanto, tem sua pontuação agressividade diminuiu, ele realmente rola em torno de 255 e fá-lo o mais caráter agressivo no jogo. Então você pode Google-se sobre este assunto. E foi, de fato, uma bug de programação acidental, mas isso entrou bastante a tradição desde então. 

Isso é todo o divertimento e bonito. Mais assustador é quando real dispositivos do mundo real, e não jogos, ter esses mesmos erros. Na verdade, apenas um ano atrás, um artigo veio -se sobre o Boeing 787 Dreamliner. 

E o artigo em primeiro olhar lê um pouco misterioso. Mas dito isso, um software vulnerabilidade no Boeing novo 787 Dreamliner jato tem o potencial para causar pilotos perder o controle de da aeronave, eventualmente em meados de voo, os funcionários da FAA companhias aéreas advertiu recentemente. Foi a determinação que um modelo 787 avião que tem sido alimentado continuamente durante 248 dias pode perder toda a corrente alternada, AC, energia eléctrica devido ao gerador unidades de controlo, GCUs, simultaneamente indo para deixar modo de segurança. É uma espécie de me perder. Mas o memorando afirmou, OK, agora eu tenho que, a condição foi causado por um software contador interno para o controle do gerador unidades que vai transbordar depois 248 dias de potência contínua. Estamos a emissão do presente aviso para evitar a perda de todos AC eléctricos poder, o que poderia resultar em perda de controle do avião. 

Assim, literalmente, existe algum inteiro, ou algum tipo de dados equivalente, sendo utilizado em software em um avião real que se você manter o seu avião em tempo suficiente, o que, aparentemente, pode ser o caso se você está apenas executando -los constantemente e nunca desligar o seu avião, ao que parece, ou deixando suas baterias morrer, acabará por contar-se, e para cima, e para cima, e para cima, e para cima, e para cima. 

E, por natureza, uma quantidade finita de memória transbordará, rolando de volta para zero ou algum valor negativo, um efeito colateral das quais é a realidade assustadoramente reais que o avião pode precisar de ser reiniciado, efetivamente, ou pode cair, pior, como ele voa. Então, esses tipos de problemas ainda estão entre nós, even-- este foi um artigo de 2015, tudo o mais assustador quando você não faz, necessariamente, entender, apreciar, ou antecipar esses tipos de erros. 

Então não é que há uma outra coisa ruim sobre representação de dados. Acontece que mesmo os carros alegóricos são tipo de falha, porque flutuadores, também, Propus são 32 bits, ou talvez 64 se você usar um casal. Mas isso ainda é finito. 

E o problema é que se você puder colocar um número infinito de números depois do ponto decimal, não há nenhuma maneira que você pode representar todos os possíveis números que nós foram ensinados no grau escola pode existir no mundo. Um computador, essencialmente, tem a escolher um subconjunto desses números para representar com precisão. 

Agora, o computador pode rodada talvez um pouco, e pode permitir-lhe cerca de loja qualquer número que você pode querer. Mas só intuitivamente, se você têm um número finito de bits, você só pode permutar-los em tantas formas finitas. Então você não pode possivelmente têm um número finito de permutação de bits, padrões de zeros e uns, para representar um infinito número de números, o que sugere que computadores podem muito bem ser mentindo para nós às vezes. 

Na verdade, vamos fazer isso. Deixe-me voltar para IDE CS50. Deixe-me ir em frente e criar um pequeno programa chamada imprecisão, para mostrar que os computadores são, de fato, imprecisa. 

E deixe-me ir em frente e começar com alguns de que o código de antes, e agora basta fazer o seguinte. Deixe-me ir em frente e fazer printf, cento f, barra invertida n, 1 dividido por 10. Em outras palavras, vamos mergulhar no mais profundo a 1/10, como 1 e dividida por 10. Certamente, um computador pode representar 1/10. 

Então, vamos em frente e fazer imprecisão. Vamos ver. Format especifica o tipo de casal. Mas o argumento tem o tipo int. O que está acontecendo? 

Oh, interessante, por isso é uma lição aprendida de antes. Eu estou dizendo, hey, feira de informática me um flutuador com cento f. Mas eu estou dando-lhe 2 ints. Assim, ao que parece, posso corrigir isso em um par de formas. 

Eu poderia simplesmente transformar um 1.0, e 10 para 10,0, o que, de fato, tem o efeito de converter -los em floats-- ainda espero o mesmo número. Ou se vê que há algo veremos novamente em pouco tempo. Você poderia lançar os números. 

Você pode, usando este parêntesis expressão, você pode dizer, hey, computador, aproveitar esta 10, que sei que é um int. Mas tratá-lo, por favor, como se fosse uma bóia. Mas isso parece desnecessariamente complexa. 

Para os nossos propósitos hoje, vamos apenas literalmente fazê-los valores de ponto flutuante com um ponto decimal, como este. Deixe-me ir em frente e volte a executar, faça imprecisão, bom, barra dot imprecisão, entrar. OK, nós estamos olhando bom. 

1 dividida por 10, de acordo com o meu Mac aqui, é, de fato, 0,100 mil. Agora, eu fui ensinado na escola há deve ser um número infinito de 0 do. Então, vamos pelo menos tentar para ver algumas delas. Acontece que printf é um pouco ainda mais extravagante do que temos vindo a utilizar. Acontece que você não tem que especificar simplesmente por cento f, ou simplesmente por cento i. Você pode realmente especificar algumas opções de controle aqui. 

Especificamente, eu estou indo para dizer, hey, printf, realmente mostrar-me 10 pontos decimais. Portanto, parece um pouco estranho. Mas você diz por cento, ponto, quantos números você quer ver após o ponto decimal e, em seguida f para plana, só porque é o que diz a documentação. Deixe-me ir em frente e guardar esse. 

E observe também, eu estou recebendo cansado de ter que redigitar as coisas. Então, eu estou apenas definir o para cima e seta para baixo em minhas chaves aqui. E se eu mantenho-me bater-se, você pode ver todos os comandos que eu fiz, ou feita de forma incorreta. 

E eu estou indo para ir em frente agora e Não realmente usar que, aparentemente. Faça imprecisão, dot cortar imprecision-- assim o que foi ensinado na escola primária confere. Mesmo se eu imprimi-lo a 10 decimal coloca, de fato, é 0,10000. Mas você sabe o que? 

Vamos ficar um pouco ganancioso. Digamos que, como, mostre-me 55 pontos após o decimal. Vamos realmente tomar esta programar para dar uma volta. Deixe-me refazê-lo com o make imprecisão, barra ponto, imprecisão. 

E aqui vamos nós. Sua infância foi uma mentira. Aparentemente, 1 dividido por 10 é efectivamente 0.100000000000000005551115123-- 

O que está acontecendo? Bem, ao que parece, se você tipo de olhar longe o suficiente na subjacente representação do presente número, ele realmente não é exactamente 10/01, ou 0,1 e um número infinito de zeros. Agora, por que isso? 

Bem, mesmo que esta é uma simples número para nós seres humanos, 1 dividido por 10, ainda é um dos infinitos números que poderíamos imaginar. Mas um computador só pode representar um número finito de números assim. E assim, de forma eficaz, o que o computador está nos mostrando é o seu mais próximo aproximação para o número queremos acreditar é 1/10, ou realmente 0,10000 ad infinitum. 

Em vez disso, porém, este é tão perto quanto ele pode chegar. E, de fato, se você olhar por baixo da capa, como estamos aqui examinando 55 dígitos após o decimal, realmente vemos que a realidade. Agora, como um aparte, se você tiver já viu o movie-- a maioria de vocês provavelmente haven't-- mas Superman 3 há alguns anos, Richard Pryor essencialmente alavancado este realidade em sua empresa para roubar um monte de frações e as frações de centavos, porque o company-- se bem me lembro, tem sido um while-- era essencialmente jogando fora tudo o que não se encaixava na noção de centavos. 

Mas se você somar todos esses minúsculos, minúsculo, minúsculos números mais uma vez, e de novo, e de novo, você pode, como em seu caso, fazer uma boa quantia de dinheiro. 

Essa mesma ideia foi roubado por uma mais recente, mas ainda agora mais velhos filme, chamado Office Space, onde os caras do que o filme, fez a mesma coisa, estraguei tudo completamente, acabou com a maneira demasiado dinheiro em sua conta bancária. Foi tudo muito suspeito. Contudo, no final do dia, imprecisão está ao nosso redor. 

E que, também, pode ser assustadoramente o caso. Acontece que Superman 3 e espaço de escritórios de lado, há pode haver algum muito real ramificações mundiais das realidades da imprecisa representação de dados que mesmo nós, humanos, a este dia não necessariamente entender bem como deveríamos, ou lembrar tão frequentemente quanto deveria. E, de fato, o clipe seguinte é de uma olhada em alguns mundo muito real ramificações do que acontece se você não apreciam a imprecisão que pode acontecer em números representação. 

[REPRODUÇÃO DE VÍDEO] 

-Computadores, Todos nós temos vindo a aceitar os problemas que muitas vezes frustrante ir com eles-- erros, vírus, e falhas de software, para pequenos preços a pagar para a conveniência. Mas, na alta tecnologia e alta velocidade aplicações do programa espacial e militares, o menor problema pode ser ampliada para o desastre. 

Em 04 de junho de 1996, os cientistas preparados para lançar um não-tripulado Ariane 5 foguete. Ele estava carregando científica satélites projetados para estabelecer com precisão a forma como o interage campo magnético da Terra com ventos solares. O foguete foi construído para a Agência Espacial Europeia, e decolou de sua instalação na costa da Guiana Francesa. 

-No Cerca de 37 segundos para o vôo, eles primeiro notado que algo estava acontecendo de errado. Os bicos foram girando em uma maneira que eles realmente não deveria. Cerca de 40 segundos de vôo, claramente, o veículo estava em apuros. 

E isso é quando eles fizeram a decisão de destruí-lo. O oficial de segurança gama, com tremenda coragem, apertou o botão, explodiu o foguete, antes que pudesse se tornar um perigo para a segurança pública. 

-Este Foi o de solteira viagem do Ariane 5. E sua destruição levou colocar devido a uma falha embutido no software do foguete. -O Problema no Ariane foi que havia um número que 64 bits requerido para expressar. E eles queriam converter -lo para um número de 16 bits. Eles assumiram que o número nunca ia de ser muito grande, que a maior parte daqueles dígitos de um número de 64 bits foram zeros. Eles estavam errados. 

-O Incapacidade de um programa de software para aceitar o tipo de número gerado pela outra estava na origem da falha. desenvolvimento de software tornou-se um parte muito cara de nova tecnologia. O foguete Ariane têm sido muito bem sucedido, tanto do software criado por isso também foi usado no Ariane 5. 

-O Problema básico era que a Ariane 5 foi mais rápido, mais rapidamente acelerada. E o software não tinha que representaram. 

-A Destruição do foguete foi um enorme desastre financeiro, tudo devido a um erro de software minuto. Mas este não foi o primeiro problemas de conversão de dados de tempos havia atormentado a tecnologia de foguetes moderna. 

-Em 1991, com o início da primeira Guerra do Golfo, o Patriot Missile experimentaram um tipo semelhante do problema de conversão de número. E, como resultado, 28 pessoas, 28 soldados norte-americanos, foram mortos, e cerca de 100 ficaram feridas, quando o Patriot, que deveria para proteger contra scuds recebidas, não conseguiu disparar um míssil. 

-Quando O Iraque invadiu o Kuwait, e América lançou Desert Storm no início de 1991, baterias de mísseis Patriot foram implantados para proteger a Arábia Saudita e Israel de ataques de mísseis Scud iraquianos. O Patriot é um médio alcance US superfície de sistema de ar, fabricado pela empresa Raytheon. 

-O Tamanho do interceptor Patriot em si é de cerca de cerca de 20 pés de comprimento. E pesa cerca de 2.000 libras. E carrega uma ogiva de cerca, Eu acho que é mais ou menos 150 libras. E é o próprio ogiva um elevado explosivo, que tem fragmentos em torno dele. O invólucro da ogiva é projetado para agir como chumbo grosso. 

-As Mísseis são realizadas quatro por recipiente, e são transportados por um semi-reboque. 

-O Sistema Patriot anti-míssil remonta pelo menos 20 anos. Ele foi originalmente projetado como um míssil de defesa aérea para abater aviões inimigos. Na primeira Guerra do Golfo, quando a guerra veio, o Exército queria usá-lo para abater scuds, não aviões. 

A Força Aérea iraquiana foi não tanto de um problema. Mas o Exército estava preocupado com scuds. E assim eles tentaram atualizar o Patriot. 

-Intercepting Um inimigo míssil viajando a Mach 5 ia ser bastante difícil. Mas quando o Patriot foi levado às pressas em serviço, o Exército não estava ciente de um modificação iraquiana que fez seus scuds quase impossível de bater. 

-O Que aconteceu é o que scuds estavam chegando eram instáveis. Eles estavam balançando. A razão para isso era os iraquianos, a fim para obter 600 quilômetros fora de um 300 km alcance dos mísseis, tomou peso fora da ogiva frente. Eles fizeram a ogiva mais leve. 

Portanto, agora o Patriot é tentar chegar ao Scud. E a maior parte do tempo, o esmagadora maioria do tempo, seria apenas voar pela Scud. Uma vez que os operadores do sistema Patriot percebeu que o Patriot errou seu alvo, eles detonaram ogiva do Patriot para evitar possíveis acidentes se ele Deixou-se cair ao chão. 

-Isso Era o que a maioria das pessoas viu, esses grandes bolas de fogo no céu, e mal interpretado como intercepta de ogivas Scud. 

-embora Na noite céus, Patriots apareceu para ser com sucesso destruindo Scuds, em Dhahran, pode haver nenhum erro sobre o seu desempenho. Lá, sistema de radar do Patriot perdeu a noção de um Scud de entrada, e nunca lançado devido a uma falha de software. Foram os israelenses que descoberto pela primeira vez que quanto mais tempo o sistema foi ligado, quanto maior for o tempo de discrepância tornou-se, devido a um relógio incorporado no computador do sistema. 

-Cerca De duas semanas antes a tragédia em Dhahran, os israelenses relatado para o Departamento de Defesa que o sistema estava perdendo tempo. Após cerca de oito horas ou em execução, eles notaram que o sistema estava se tornando visivelmente menos precisas. O Departamento de Defesa respondeu contando todas as baterias Patriot para não deixar os sistemas por um longo período de tempo. Eles nunca disseram que um longo tempo foi-- oito horas, 10 horas, 1.000 horas. Ninguém sabia. 

-A Bateria Patriot estacionados no quartel em Dhahran e sua falha interna relógio tinha sido em mais de 100 horas na noite de 25 de fevereiro. 

-É Monitorado o tempo com uma precisão de cerca de um décimo de segundo. Agora, um décimo de segundo é um número interessante, porque não pode ser expressa em binário exatamente, o que significa que não pode ser expresso exactamente em qualquer computador digital moderno. É difícil de acreditar. 

Mas usar isso como um exemplo. Vamos dar o número de um terço. Um terceiro não pode ser expressa em decimal exatamente. Um terço é 0,333 acontecendo para o infinito. 

Não há nenhuma maneira de fazer isso com a precisão absoluta em decimal. Esse é exatamente o tipo de problema que aconteceu no Patriot. Quanto mais tempo o sistema funcionou, o pior o erro de tempo se tornou. 

-Depois De 100 horas de operação, o erro no tempo foi apenas cerca de um terço de um segundo. Mas em termos de como alvo um míssil viajando a Mach 5, resultou em um acompanhamento de erro de mais de 600 metros. Seria um erro fatal para os soldados sobre o que aconteceu é o lançamento de um Scud foi detectados por satélites de alerta precoce e eles sabiam que o Scud foi vindo em sua direção geral. Eles não sabiam de onde vinha. 

-Foi Agora à radar componente do sistema Patriota defendendo Dhahran para localizar e manter trilha do míssil inimigo de entrada. 

-O Radar era muito inteligente. Seria, na verdade, rastrear a posição do Scud, e, em seguida, prever onde ela provavelmente seria a próxima vez que o radar enviado Um pulso para fora. Que foi chamado um portão de gama. 

-Então, Uma vez que o Patriot decide tempo suficiente tem passado para voltar e verificar a próxima localização para este objeto detectado, ele vai voltar. Assim, quando se voltou para o errado lugar, em seguida, vê nenhum objeto. E decide que não houve objeto, ele foi uma falsa detecção, e deixa a pista. 

-O Scud de entrada desapareceu da tela do radar. E segundos depois, se chocou contra o quartel. O Scud matou 28, e foi a última um disparou durante a primeira Guerra do Golfo. 

Tragicamente, o software atualizado Dhahran chegou no dia seguinte. A falha de software teve sido fixada, o fechamento um capítulo na conturbada história do míssil Patriot. 

[REPRODUÇÃO DE VÍDEO] DAVID J. MALAN: Então, isso é tudo para dizem que estas questões de estouro e imprecisão são muito reais. Então, como nós chegamos aqui? Começamos com apenas falando sobre printf. Mais uma vez, esta função que imprime algo para a tela, e nós introduzidas posteriormente algumas outras funções a partir do chamado biblioteca de CS50. E nós vamos continuar a veja estes em devido tempo. E nós, em particular, usado cadeia get, e obter int, e agora também terá float, e ainda outros ainda vamos encontrar e usar-nos antes do tempo. 

Mas de vez em quando, tem visto que já uma necessidade para armazenar o que essas funções mão para trás? Eles nos trás uma cadeia de mão, ou um int ou um float. E às vezes é preciso colocar que string, ou int ou float, em algum lugar. 

E para armazenar essas coisas, lembre-se apenas como em risco, temos variáveis. Mas ao contrário de risco, em C temos tipos reais de dados variables-- tipos, mais generally-- entre eles, uma corda, um int, um flutuar, e esses outros ainda. 

E por isso, quando declarar variáveis ​​em C, vamos ter de declarar os nossos tipos de dados. Isso não é algo que vamos tem que fazer mais tarde no semestre à medida que a transição para outras línguas. Mas, por agora, precisamos para a priori antes, explicar ao computador que tipo da variável que queremos nos dar. 

Agora, entretanto, para imprimir esses tipos de tipos de dados, temos de dizer printf o que esperar. E vimos por cento s para cordas, e cento i para inteiros, e alguns outros já. E esses são apenas requisitos para a apresentação visual dessas informações. 

E cada um destes pode ser realmente parametrizada ou mexido, de alguma forma, se você quiser promover o controle o tipo de saída que você começa. E, de fato, verifica-se que não só há barra invertida n para uma nova linha. Há mais uma coisa chamada barra invertida r para um retorno de carro, o que é mais semelhante a um Máquina de escrever velha escola, e também o Windows usado por muitos anos. 

Há barra invertida t para guias. Acontece que, que se você quiser aspas dentro de uma string, Lembre-se que nós usamos duplo aspas Citação à esquerda e à direita acaba de nossas cordas até agora. Isso parece confundir as coisas. 

Se você quiser colocar uma aspa em no meio de uma string-- e, na verdade, é confuso para ver. E então você tem que escapar, por assim falar, uma aspa com algo como, literalmente, barra invertida aspas duplas. E há algumas outras ainda. E veremos mais desses no uso real em pouco tempo. 

Então, vamos agora a transição de de dados e de representação, e operadores aritméticos, todos dos quais nos deu algum edifício blocos com que a desempenhar. Mas agora vamos realmente dar -nos o resto do vocabulário que já tinha na semana passada com o Scratch dando uma olhada em algum outro construções em C-- não todas elas. Mas as idéias que estamos prestes a ver realmente apenas enfatizar a tradução do uma língua, risco, para outro, C. 

E ao longo do tempo, vamos pegar mais ferramentas para nossa caixa de ferramentas, por assim dizer, sintaticamente. E, de fato, você verá que as ideias agora são bastante familiares da semana passada. Então, vamos fazer isso. 

Vamos em frente e chicote de um programa que realmente usa algumas expressões, uma expressão booleana. Deixe-me ir em frente aqui e criar um novo arquivo. Vou chamar este condition.c. 

Deixe-me ir em frente e incluem a biblioteca CS50. E deixe-me ir em frente e incluem padrão io.h para as nossas funções, e printf, e mais, respectivamente. Deixe-me dar a mim mesmo que clichê de void main int, cuja explicação que vai voltar no futuro. 

Agora deixe-me ir em frente e dar me um int via get int. Então deixe-me ir em frente e fazer isso. Eu quero dizer, se eu é less-- vamos distinguir entre positivo, negativo, ou valores iguais a zero. 

Então, se eu for menor que zero, deixe-me só tem este programa simplesmente dizer: negativo, barra invertida n, outra se i é maior do que zero. Agora eu estou, é claro, vai dizer printf positivo, barra invertida n. E então outra coisa se-- eu poderia fazer isso. 

Eu poderia fazer se eu for igual a 0. Mas eu estaria fazendo em menos um erro já. Lembre-se que o sinal de igual é não é igual, como nós, seres humanos sabem disso. 

Mas é o operador de atribuição. E nós não queremos tomar 0 no direita e colocá-lo em i à esquerda. Então, para evitar esta confusão, ou talvez uso indevido do sinal de igual, os seres humanos decidiram há alguns anos que em muitas linguagens de programação quando você quiser verificar a igualdade entre a esquerda ea direita, você realmente usa é igual iguais. Então você bate o sinal de igual duas vezes. Quando você deseja atribuir a partir da direita para a esquerda, você usar um único sinal de igual. Para que pudéssemos fazer outra coisa isto-- se i é igual a igual a zero. 

Eu poderia, então, ir e abrir os chaves, e dizer: printf 0, barra invertida n, feito. Mas lembre-se como estes garfos na estrada pode funcionar. E, realmente, basta pensar sobre a lógica. i é um número. É um inteiro, especificamente. E isso significa que ele vai ser menos do que 0, ou maior do que 0, ou 0. Portanto, não é uma espécie de presente caso padrão implícito. 

E assim poderíamos, assim como Zero, dispensar o else if, e apenas dizer outra coisa. Logicamente, se o programador sabe que só há três baldes na qual um cenário pode fall-- o primeiro, o segundo, ou terceiro neste case-- não incomoda adicionando a precisão adicional e a lógica adicional ali. Basta ir em frente com a caso padrão aqui de outra pessoa. 

Agora, vamos em frente depois de salvar isso, certifique condições dot cortar conditions-- não uma grande interface de usuário, porque eu não estou levando o usuário, como mencionei anteriormente. Mas isso é bom. Vamos mantê-lo simples. Vamos tentar o número 42. E isso é positivo. Vamos tentar o número negativo 42, negativa. 

Vamos tentar o valor 0. E, na verdade, ele funciona. Agora, você verá com problemas antes longos e testar as coisas três vezes, provavelmente insuficiente. Você provavelmente vai querer testar alguns números maiores, alguns menores números, alguns casos de canto, como nós vamos chegar a descrevê-los. 

Mas, por agora, este é um programa muito simples. E eu tenho certeza que, logicamente, que se divide em três casos. E, de fato, embora nós apenas incidiu sobre os potenciais desvantagens de imprecisão e inundará, em realidade onde muitos dos problemas do CS50, não vamos nos preocupar sobre, todo o tempo, esses problemas de estouro e imprecisão, porque, na verdade, em C, não é realmente tudo o que fácil de evitar essas coisas. Se você deseja contar-se maior, e maior, e maior, acontece que existem técnicas que você pode usar, muitas vezes envolvendo coisas chamadas bibliotecas, coleções de código, que outras pessoas escreveu que você pode usar, e outras linguagens como Java e outros, na verdade, torná-lo muito mais fácil contar ainda maior. Portanto, é realmente alguns desses perigos uma função da linguagem que você usa. E nas próximas semanas, vamos ver o quão perigoso C realmente pode ser, se você não usá-lo corretamente. Mas a partir daí, e com Python e JavaScript, vai nós camada em algumas proteções adicionais, e correr menos desses riscos. 

Então, vamos fazer um pouco mais lógica interessante em nosso programa. Então deixe-me ir em frente e criar um programa chamado lógico só assim eu posso jogar com alguns lógica real, logical.c. Eu só vou copiar e colar algum Código de mais cedo, então eu voltar a este bom ponto de partida. 

Deixe-me desta vez fazer C. de char que eu sou vai dar-lhe um nome de C só porque é convencional, obter um personagem do usuário. E vamos fingir Estou implementando parte desse programa Rm, a retirada programa antes que levou o usuário para remover um arquivo. Como poderíamos fazer isso? 

Quero dizer que, se C é igual a iguais, entre aspas, y, então eu vou assumir que o usuário tenha escolhido sim. Eu só vou para imprimir sim. Se fosse realmente escrever o programa de remoção, poderíamos remover o arquivo com mais linhas de código. Mas nós vamos mantê-lo simples. 

Else if c é igual a igual n-- e agora aqui, eu vou dizer, o usuário deve ter significado nenhum. E então outra coisa, você sabe o quê? Eu não sei o que mais o usuário vai digitar. Então, eu estou indo só para dizer que que é um erro, qualquer que seja ele ou ela realmente digitado. 

Então, o que está acontecendo aqui? Há uma diferença fundamental versus o que eu fiz no passado. aspas, aspas duplas, o dobro citações, e, ainda, aspas simples, aspas simples. Acontece em C, que quando você quer escrever uma corda, você usar aspas duplas, assim como nós temos vindo a utilizar todo esse tempo com printf. 

Mas se você quer lidar com apenas um caractere único, um chamado char, então você realmente usar aspas simples. Aqueles de vocês que tenha programado antes, você pode não ter tinha que se preocupar com isso distinção em certas línguas. Em C, ele não importa. E assim quando eu chegar em um char e eu quero comparar esse caractere usando equals é igual a alguma carta como y ou n, eu faço, na verdade, precisa ter as aspas simples. 

Agora, vamos ir em frente e fazer isso. Vamos ir em frente e fazem dot lógicas cortar lógico. E agora eu estou sendo solicitado. Assim, presumivelmente, uma melhor experiência de usuário seria realmente me dizer o que fazer aqui. Mas eu vou apenas cega dizem y para sim, OK, agradável. 

Vamos executá-lo novamente, n para nenhuma, agradável. Suponha como certas pessoas que conheço, meus tecla Caps Lock está ligado com demasiada frequência. Então eu faço o capital Y, entrar, erro. OK, não é exatamente o que eu estou esperando. Com efeito, o computador está fazendo literalmente o que Eu disse-o para verificar se há fazer-- minúsculas n y e minúsculas. Este não se sente como bom experiência do usuário, embora. Deixe-me pedir e aceitar ambos os casos inferior ou maiúsculas. Assim, verifica-se, você pode querer dizer algo como em risco, como literal ou C é igual a é igual a de capital único y citado. Acontece que, C não tem esta palavra-chave literal ou. 

Mas tem duas barras verticais. Você tem que segurar a tecla Shift normalmente, se você estiver usando um teclado americano, e bateu a barra vertical chave acima de sua tecla de retorno. Mas essa barra vertical barra vertical significa ou. 

Se, pelo contrário, queríamos a dizer e, como em risco, poderíamos fazer comercial e comercial. Isso não faz sentido lógico aqui, porque um humano não poderia possivelmente digitou tanto y e minúsculas y e capital de Y como o mesmo personagem. Assim, ou é o que pretendemos aqui. 

Então, se eu fizer isso em ambos os lugares, ou c é igual é igual a de capital N, agora executar novamente, tornam lógica, execute novamente lógico. Agora, eu posso digitar y. E eu posso fazê-lo novamente com capital de Y ou N. de capital E eu poderia acrescentar no adicional combinações fixas. 

Portanto, esta é uma lógica programa na medida em que agora Estou verificando logicamente para Este valor ou esse valor. E eu não tenho que, necessariamente, vir para cima com mais dois ifs ou então ifs. Eu pode realmente combinam um pouco da Relacionado com lógica em conjunto desta maneira. Portanto, este seria melhor concebido de simplesmente dizendo, se C é igual a menor caso y, imprimir sim, mais se c é igual a capital de Y, imprimir sim, mais se c é igual a lower-- em outras palavras, você não tem que ter mais e mais filiais. É possível combinar algumas das equivalente Logicamente, como ramos desta forma. 

Então, vamos dar uma olhada em apenas um ingrediente final, uma construção final, que permite C. E nós vamos voltar no futuro, para outros ainda. E então nós vamos concluir, olhando por não a correção de code-- como obter o código de trabalho-- mas o design de código, e plantar as sementes no início. 

Então deixe-me ir em frente e abrir um novo arquivo aqui. Você sabe o que? Eu estou indo para reimplementar que mesmo programa, mas utilizando uma construção diferente. 

Então me deixe rapidamente dar-me Acesso para incluir CS50.h para a biblioteca de CS50, Io.h padrão para printf. Dá-me o meu void main int. E então para cá, vamos me ir em frente e fazer isso. 

Char c recebe obter char, como antes. E eu vou usar uma nova construção agora-- mudar, na qual personagem? Então interruptor é tipo como A mudança de um trilhos do trem. Ou, na verdade, é uma espécie de uma se mais, se else if, mas escrito um pouco diferente. 

A chave parece com isso. Você tem switch, e então o que caracteres ou número que deseja para olhar, em seguida, algumas chaves como em Zero, apenas dizer que fazer essas coisas. E então você tem casos diferentes. 

Você não usar if e else. Você literalmente usar o caso da palavra. E você diria algo como isto. 

Assim, no caso de um minúsculas Y, ou no caso de um capital Y, vá em frente e imprimir sim. E, em seguida, sair do switch. É isso aí. Foram realizadas. 

Else if, por assim dizer, minúsculas n, ou de capital N, então vá em frente e imprimir sair, não, e, em seguida, quebrar. Else-- e este tipo de é o caso padrão indeed-- printf error-- e apenas para uma boa medida, embora logicamente esta pausa não é necessário porque nós estamos no fim do interruptor de qualquer maneira, Agora estou quebrando fora do switch. Portanto, este parece um pouco diferente. 

Mas, logicamente, é efectivamente equivalente. E por que você usaria um sobre o outro? Às vezes, apenas preferência pessoal, por vezes, a estética, se eu olho para esta Agora, há algo a ser dito para o legibilidade deste código. Quer dizer, não importa o fato de que este código é novo para muitos de nós no quarto. 

Mas é apenas uma espécie de é bonito. Você vê minúsculas y, capital de Y, minúsculas n, padrão de capital N, ele só tipo de saltos para fora em você de uma maneira que, sem dúvida, talvez o exemplo anterior com as ifs, e as barras verticais, e os ifs outra pessoa, pode não ter. Portanto, esta é realmente uma questão de pessoal escolha, realmente, ou a legibilidade, do código. 

Mas em termos de funcionalidade, deixe-me vá em frente e fazer um interruptor, barra dot switch, e agora digitar y minúsculas, capital de Y, minúsculas n, capital de N, David, tente novamente, porque isso é não um único caractere. Vamos fazer x, erro, como esperado. E, logically-- e isso é algo Gostaria de incentivar em general-- mesmo embora estamos apenas arranhando a superfície de algumas destas características. 

E isso pode não ser óbvio quando você -se sentar no teclado, Como é que isso funciona? O que isso faz? A bela coisa sobre ter um laptop ou desktop, ou o acesso a um computador com um compilador, e com um editor de código como este, é quase sempre você pode responder a estas perguntas para si mesmo apenas tentando. 

Por exemplo, se o retórico questão em apreço foram, o que acontece se você esquecer suas declarações de ruptura? Que é realmente um muito comum coisa a fazer, porque não parece como você realmente precisa deles. Eles realmente não completar o seu pensava como um parêntese ou encaracolado cinta faz. Vamos ir em frente e recompilar o código e ver. Então faça interruptor, interruptor de corte de ponto. Vamos escrever em letras minúsculas y, a top case, Enter. Então eu digitei y. 

O programa disse que sim, não, de erro, como se estivesse mudando sua mente. Mas que tipo de era, porque o que acontece com um interruptor é o primeiro caso que jogo significa, essencialmente, hey computador, executar todo o código abaixo dela. E se você não diz ruptura, ou não digo ruptura, ou não dizem ruptura, o computador vai explodir através de todas as linhas e executar todos eles até chega a esse chaveta. Assim, os freios são, de fato, necessário. Mas um takeaway aqui é, quando Em caso de dúvida, tente algo. Talvez salvar seu código em primeiro lugar, ou salvá-lo em um arquivo extra se você está realmente preocupado com bagunçar e ter que recuperar o trabalho que você sabe que está funcionando. 

Mas tentar coisas. E não ser tão medo, talvez, do que o computador pode fazer, ou que você pode quebrar alguma coisa. Você sempre pode voltar a alguma versão anterior. 

Então vamos acabar vendo para o desenho de código. Nós temos essa capacidade agora de escrever condições e loops de gravação, e variáveis, e funções de chamada. Então, francamente, estamos espécie de volta ao onde estávamos há uma semana com o Scratch, embora com um textuais menos convincentes ambiente do que zero permite. 

Mas note a rapidez com que você adquiriu que o vocabulário, mesmo que seja vai levar um pouco de tempo para afundar, de modo que agora podemos usar esse vocabulário para escrever programas mais interessantes. E vamos dar um passo de bebê para que, como se segue. Deixe-me ir em frente e criar um novo arquivo aqui. 

Vou chamar essa prototype.c, e introduzir pela primeira vez, a capacidade para fazer as suas próprias funções. Alguns de vocês podem ter feito isso com o Scratch, através do qual você pode criar o seu blocos personalizados próprios em zero, e, em seguida, arrastá-los para lugar onde quer que você gostaria em C. E na maior parte da programação idiomas, você pode fazer exatamente isso-- fazer suas próprias funções, se eles já não existem. 

Assim, por exemplo, deixe-me ir em frente e incluem CS50.h, e incluir padrão io.h, int void main. E agora temos uma espaço reservado pronto para ir. I manter as coisas de impressão como os nomes das pessoas hoje. E que se sente como-- Não seria bom se houver eram uma função chamada nome de impressão? Eu não tenho de usar printf. Eu não tenho a lembrar todos os códigos de formato. Por que não eu, ou porque não alguém antes de mim, criar uma função chamada de impressão nome, dado algum nome, simplesmente imprime-lo para fora? 

Em outras palavras, se eu digo, hey, computador, dá-me uma corda pedindo ao usuário para tal, via função de cadeia get de CS50. Hey, computador, colocar essa string no a variável no lado esquerdo, e chamá-lo s. E, em seguida, hey computador, vá em frente e imprimir que o nome de pessoa, feito. 

Agora, seria bom, porque Neste programa, apropriadamente chamado, me diz o que é suposto fazer por meio de nomes daqueles função. Deixe-me ir e fazer protótipo, Enter. E, infelizmente, isso não vai voar. 

Prototype.c, linha 7, personagem 5, de erro, declaração implícita da função nome de impressão é inválido na C99, C99 significa uma versão de C que saiu em 1999. Isso é tudo. 

Então, eu não sei o que tudo isso significa ainda. Mas eu reconheço erro no vermelho. Isso é bastante óbvio. 

E parece que, com o personagem verde aqui, o problema é com o nome de impressão, aberta Paren s, Paren próximos, e vírgula. Mas a declaração implícita de função fizemos ver brevemente mais cedo. Isto significa, simplesmente, que Clang não sabe o que quero dizer. 

Eu usei uma palavra do vocabulário que é nunca vi ou foi ensinado antes. E então eu preciso ensiná-lo o que esta função significa. Então, eu estou indo para ir em frente e fazer isso. 

Eu estou indo para ir em frente e implementar minha própria função chamada Nome Impresso. E eu vou dizer, como se segue, que ele faz isso, printf, Olá, cento s, barra invertida n, nome, ponto e vírgula. Então, o que eu acabei de fazer? 

Então não é que, para implementar sua própria função, que tipo de emprestar alguns dos a mesma estrutura principal que temos sido apenas tida como certa, e eu sabe apenas copiando e colar muito bonito o que Eu tenho escrito no passado. Mas observe o padrão aqui. Int, Main, Vazio, vamos desmembrar em pouco tempo o que isso realmente significa. 

Mas para hoje, apenas notar o paralelismo. Vazio, o nome de impressão, nome de cadeia, por isso há uma palavra-chave roxo, que vamos começar chamando um tipo de retorno, o nome do a função, e depois a entrada. Então, na verdade, podemos destilar este tipo de como na semana passada como, este é o nome ou o algoritmo do código estamos indo o write-- algoritmo subjacente o código que vai escrever. 

Esta é a sua entrada. Esta é a sua saída. Esta função, o nome de impressão, é concebidos para ter uma string chamada nome, ou o que quer, como entrada, e em seguida anuladas. Ela não retorna nada, como obter corda ou obter int faz. Então ele vai me dar algo de volta. É só vai ter um efeito secundário, por assim dizer, de imprimir o nome de uma pessoa. Então, observe, linha 7, I pode chamar o nome de impressão. Linha 10, eu posso definir ou implementar nome de impressão. Mas, infelizmente, isso não é suficiente. 

Deixe-me ir em frente e recompilar isto depois de salvar. Whoa, agora, eu fiz isso pior, ao que parece. declaração de modo implícito de nome da função de impressão é inválido. E, novamente, há mais erros. Mas como eu advertiu anteriormente, mesmo se você ficar sobrecarregado com, ou um pouco triste ver tantos erros, se concentrar apenas no primeiro inicialmente, porque ele só poderia ter tido um efeito em cascata. Assim, C, ou mais especificamente Clang, continua a não reconhecer o nome de impressão. 

E isso é porque Clang, por design, é uma espécie de idiota. Ele só faz o que você diga a ele para fazer. E isso só faz isso na ordem em que você diga a ele para fazer. 

Então, eu tenho definido principal na linha de quatro, como temos vindo a fazer bastante freqüência. Eu defini o nome de impressão na linha 10. Mas eu estou tentando usar nome de impressão on-line sete. 

É muito cedo, ainda não existe. Assim eu poderia ser inteligente, e ser como, OK, então vamos apenas jogar junto, e mover nome de impressão para cima aqui, e recompilar. Meu Deus. Funcionou. Era tão simples como isso. 

Mas a lógica é exatamente isso. Você tem de ensinar o que Clang é definindo a função primeira. Em seguida, você pode usá-lo. Mas, francamente, este se sente como uma ladeira escorregadia. 

Assim, cada vez que eu corro em um problema, eu sou apenas vai destacar e copiar o código Eu escrevi, cortá-lo e colá-lo aqui. E, com certeza, poderíamos inventar alguns cenários onde uma função pode precisa chamar outro. E você simplesmente não pode colocar todos os função acima de qualquer outro. 

Então não é que há uma solução melhor. Nós podemos deixar este ser. E, francamente, é geralmente bom, e conveniente, e um bom design para colocar principal em primeiro lugar, porque, novamente, principal apenas como quando a bandeira verde clicado, que é a função que é executado por padrão. Assim, você pode muito bem colocar -lo na parte superior do arquivo de modo que quando você ou qualquer outro ser humano olha para o arquivo você sabe o que está acontecendo apenas lendo principal em primeiro lugar. Então não é que, podemos dizer Clang proativamente, hey, Clang, na linha quatro, Eu prometo para implementar uma função chamada impressão Nome que leva um nome de cadeia chamada como entrada, e retorna nada, nula. E eu vou dar a volta a implementá-lo mais tarde. 

Aí vem Principal. Principal agora na linha 9 pode usar Imprimir Nome porque Clang é confiar em que, eventualmente, ele irá encontrar a definição da execução da impressão Name. Então, depois de salvar meu arquivo, vamos -me ir em frente e fazer protótipo, parece ser bom neste momento. Dot cortar, protótipo, deixe-me vá em frente e digite um nome. David, Olá David, Zamila, Olá Zamila, e, na verdade, agora ele funciona. 

Assim, o ingrediente aqui é que nós temos fez uma função personalizada, como um costume bloco zero estamos chamando. Mas, ao contrário do risco onde você pode apenas criá-lo e começar a usá-lo, agora temos de ser um pouco mais pedante, e realmente treinar Clang de usar, ou para esperar. Agora, como um aparte, por que todo esse tempo tem temos sido cegamente na fé incluindo CS50.h, e incluindo io.h padrão? 

Bem, ao que parece, entre algumas outras coisas, tudo o que está naqueles dot h arquivos, que acontecerá a ser arquivos. Eles são arquivos de cabeçalho, por assim dizer. Eles estão ainda escrito em C. Mas eles são um tipo diferente de arquivo. 

Por enquanto, você pode muito bem assumir que tudo o que está dentro de CS50.h é alguns one-liners como este, não para funções chamadas Nome Impresso, mas para obter String, Obter Float, e alguns outros. E existem protótipos semelhantes, forros um, dentro de io.h padrão para printf, que está agora em minha própria função Imprimir Nome. Portanto, em outras palavras, todo este tempo nós temos acaba de ser cegamente copiar e colar incluem isso, incluir que, o que está acontecendo? Essas são apenas um tipo de pistas para Clang a que funções são, de fato, implementada, apenas em outras posições diferentes ficheiros em outra parte do sistema. 

Então, nós temos implementado nome de impressão. Ela tem esse efeito colateral de imprimir algo na tela. Mas isso não acontece, na verdade, me dê algo de volta. Como é que vamos a implementação de um programa que não me dar algo de volta? 

Bem, vamos tentar isso. Deixe-me ir adiante e implementar um arquivo chamado return.c para que possamos demonstrar como algo como Get String, ou obter Int, é, na verdade, retornando algo de volta para o usuário. Vamos em frente e definir void main int. 

E, novamente, no futuro, vamos explicar o que isso int e esse vazio é realmente fazendo. Mas para hoje, vamos é um dado adquirido. Eu estou indo para ir em frente e printf, para uma boa experiência do usuário, x é. E então eu vou esperar para o do usuário para me dar x com get int. 

E então eu estou indo para ir em frente e imprimir x ao quadrado. Então, quando você só tem um teclado, as pessoas comumente usar o pouco de cenoura símbolo no teclado para representar o poder , ou o expoente. Então x ao quadrado está presente i. 

E agora eu vou fazer isso. Eu poderia apenas fazer-- que é x quadrado? x quadrado é x vezes x. 

E nós fizemos isso um pouco tempo atrás já hoje. Este não se sente como tudo o que muito progresso. Você sabe o que? Vamos aproveitar um pouco dessa ideia da última vez de abstração. 

Não seria bom se há uma função chamada quadrado que faz exatamente isso? Ainda, no final do dia, faz a mesma matemática. Mas vamos abstrato embora a idéia de tomar um número multiplicado pela outra, e apenas dar-lhe um nome, como conciliar esse valor. 

E, por outras palavras, em C, vamos criar uma função chamado de quadrado que faz exatamente isso. Vai ser chamado quadrado. Ele vai levar um int. E nós vamos será apenas chamá-lo n, por padrão. 

Mas poderíamos chamá-lo de qualquer coisa que quisermos. E tudo o que ele vai fazer, literalmente, é o retorno o resultado de n vezes n. Mas porque é retornando algo, que é a palavra-chave em roxo temos nunca antes visto, I, na linha 11, não pode simplesmente dizer nula neste momento. 

Vazio, no exemplo que acabamos de ver em vez do nome de impressão, significa apenas, faça alguma coisa. Mas não me dê algo de volta. Neste caso, eu quero para retornar N N vezes, ou o que quer que seja, esse número. 

Então eu não posso dizer, hey, computador, I retornar nada, o vazio. Ele vai voltar, por natureza, um int. E então isso é tudo o que está acontecendo aqui. 

A entrada ao quadrado vai ser um int. E para que possamos usá-lo, tem que tem um nome, N. Vai saída um int que não precisa de um nome. Podemos deixá-lo ao principal, ou quem quer que seja utilizando-me a lembrar este valor se quer com a sua própria variável. 

E, mais uma vez, a única nova palavra-chave aqui é Return. E eu estou apenas fazendo um pouco de matemática. Se eu realmente queria ser desnecessário, Eu poderia dizer do produto int recebe n vezes n. 

E então eu poderia dizer, o produto retornar. Mas, novamente, para o meu ponto anterior do isso apenas não ser bom design-- como, por introduzir um nome, um símbolo, como produto, apenas para devolvê-lo imediatamente? É um pouco mais limpo, um pouco mais apertado, por isso, para falar, só para dizer retorno n vezes n, livrar-se desta linha completamente. 

E é apenas menos código para ler, menos oportunidades para erros. E vamos ver se este na verdade, trabalha agora. Agora, eu estou indo para ir em frente e fazer o retorno. 

Uh-oh, declaração implícita da função. Eu cometi este erro antes, não é grande coisa. Deixe-me apenas digitar ou destacar e copiar, exatamente a mesma função protótipo, ou assinatura, da função até aqui. Ou eu poderia mover toda a função. 

Mas isso é um pouco preguiçoso. Portanto, não vamos fazer isso. Agora, deixe-me fazer o retorno mais uma vez, ponto de retorno barra. 

x é 2. x ao quadrado é 4. x é 3. x ao quadrado é 9. E a função parece agora estar funcionando. Então, qual é a diferença aqui? Eu tenho uma função que é chamado de quadrado, neste caso, que eu pus em uma entrada. E eu voltar uma saída. E ainda, anteriormente, se Eu abro outro exemplo de mais cedo, o que foi chamado prototype.c, Eu tinha o nome de impressão, que voltou vazio, por assim dizer, Ou ele retornou nada e simplesmente tinha um efeito colateral. 

Então, o que está acontecendo aqui? Bem, considere a função obter cadeia por apenas um momento. Temos vindo a utilizar a função obter seqüência da seguinte maneira. 

Tivemos uma função de obter corda, como incluir CS50.h, incluem padrão io.h, int, principal, nula. E, em seguida, cada vez que eu tenho chamada cadeia get até agora, Eu disse algo como, corda s recebe obter corda, porque get string-- Vamos chamar essa cadeia get get.c-- -se devolve uma cadeia que posso, então, usar, e dizer, Olá, vírgula, por cento s, barra invertida n, s. 

Portanto, este é o mesmo exemplo, realmente, que tínhamos antes. Portanto, obter seqüência retorna um valor. Mas há pouco, seqüência de impressão não retorna um valor. Simplesmente tem um efeito colateral. Portanto, esta é uma diferença fundamental. Nós vimos diferente tipos de funções agora, alguns dos quais ter retornado valores, alguns dos quais não. Então talvez seja string, ou int ou float. Ou talvez seja apenas vazio. 

E é a diferença que estas funções que obter dados e retornar um valor são realmente trazendo algo de volta para a mesa, por assim dizer. Então, vamos em frente e olhar para um conjunto final de exemplos que dá uma sensação, agora, como podemos, de fato, abstrato melhor, e melhor, e melhor, ou mais, e mais, e mais, a fim para escrever, em última análise, um código melhor. Vamos em frente, e no espírito do Scratch, faça o seguinte. 

Deixe-me ir em frente e incluem CS50.h e IO.h. padrão Deixe-me ir em frente e dar me um int, principal, nula. E deixe-me ir em frente, chame este cough.c. 

E deixe-me ir em frente e apenas como zero, imprima a tosse / n. E eu quero fazer isso três vezes. Então, eu estou, é claro, só vai para copiar e colar três vezes. Estou indo agora para fazer tosse tosse barra de ponto. Vamos dar-me um pouco mais de espaço aqui, Enter, tosse, tosse, tosse. 

Há, obviamente, já um oportunidade de melhoria. Copiei e colei algumas vezes hoje. Mas isso foi só para que eu não fiz tem que digitar quantos caracteres. Eu ainda mudou o que essas linhas de código são. 

Estes três linhas são idênticos, que se sente preguiçoso e de fato é, e provavelmente não é a abordagem correta. Assim, com o ingrediente poderíamos melhorar esse código? Não temos de copiar e colar o código. 

E, na verdade, quando você sente -se copiar e colar, e nem mesmo alterar o código, chances são de que há uma maneira melhor. E, na verdade, não existe. Deixe-me ir em frente e fazer um loop for, mesmo que a sintaxe não pode vem naturalmente ainda. 

Faça isso três vezes, simplesmente fazendo o following-- E acontece que eu sei que isso a partir da prática. Mas temos uma série de exemplos agora. E você vai ver on-line mais referências fixas. 

Esta é a sintaxe na linha 6, que bem como do risco que se repete bloco, repita as seguintes três vezes. É um pouco mágico para agora. Mas isso vai ficar mais, e mais familiar. 

E vai repetir linha de oito por três vezes, de modo que se eu re-compilar make tosse, dot cortar tosse, tosse, tosse, tosse. Ele ainda funciona da mesma maneira. Então, isso é tudo muito bem e bom. Mas isso não é muito abstraída. 

É perfeitamente correto. Mas parece que há poderia ser uma oportunidade, como no mundo de Zero, ao tipo de início adicionar alguns semântica para que Eu não apenas ter algum laço for, e uma função que diz tossir ou não tossir. Você sabe o que? Deixe-me tentar ser um pouco mais frio do que isso, e realmente escrever uma função que tem alguns efeitos colaterais, chamá-lo tossir. 

E ela não tem entrada e não retorna nenhum valor como saída. Mas você sabe o que ele faz? Ele faz isto-- printf, entre aspas, tossir. 

E agora aqui em cima, eu vou ir em frente e para int, i recebe zero, i inferior a 3, i plus plus. Eu estou indo para não fazer printf, que é sem dúvida uma implementação de baixo nível detalhe. Eu não me importo como tossir. Eu só quero usar a função de tosse. E eu estou indo só para chamar tosse. 

Agora, observe a dicotomia. Quando você chamar uma função, se não o fizer quero dar-lhe entradas, totalmente bem. Basta fazer o parêntese aberto, perto parêntese, e está feito. 

Quando você define uma função, ou declarar um protótipo de função, Se você sabe de antemão que não é vai tomar quaisquer argumentos, dizer nula naqueles parênteses lá. E isso faz certeza de que você não acidentalmente abusar dela. Deixe-me ir em frente e fazer tosse. E, claro, eu cometi um erro. 

Droga, há que declaração implícita. Mas isso é bom. É um reparo fácil. Eu só preciso o protótipo mais acima no meu arquivo do que eu estou realmente utilizá-lo. 

Então, agora deixe-me fazer tosse novamente, agradável. Agora, ele funciona. Adicione tosse, tosse, tosse, tosse. Então você pode pensar que estamos realmente pouco mais de engenharia este problema. E, de fato, nós somos. Este não é um bom candidato de um programa no momento de refatoração, e fazer o que é chamado de decomposição hierárquica, onde você toma algum código, e em seguida você tipo de fator de coisas para fora, assim como atribuir mais semântica para eles, e reutilizá-lo em última análise, a longo prazo. Mas é um bloco de construção em direção programas mais sofisticados que vamos começar escrever em pouco tempo que permite-nos ter o vocabulário com o qual a escrever melhor código. E, de fato, vamos ver se nós Não se pode generalizar este projecto. 

Parece um pouco lame que eu, principal, precisa se preocupar com esse danado para loop, e chamando a tosse novamente e novamente. Por que não posso apenas dizer tosse, tussa três vezes? Em outras palavras, por que não posso apenas dar entrada a tossir e fazer isso? 

Por que não posso apenas dizer, em principal tosse três vezes. E agora, este é o tipo de mágica. É muito iterativo aqui. E é, de fato, um pequeno passo. 

Mas apenas a capacidade de dizer sobre linha oito, tosse por três vezes, é apenas muito mais legível. E, além disso, eu não tenho de saber ou cuidado como tosse é implementado. E, de facto, no final do prazo e para projetos finais, Se você enfrentar um projeto com um colega ou dois colegas, você vai perceber que você está indo tem que, ou se quiser, dividir o trabalho. 

E você vai querer decidir de antecedência, quem vai fazer o quê, e em que peças? E não seria bom Se você, por exemplo, assumir o comando da escrita principal, feito. E seu companheiro de quarto, ou o seu parceiro de um modo mais geral, cuida da implementação de tosse. 

E essa divisão, estes paredes de abstração, ou camadas de abstração se você vai, são super poderoso, porque especialmente para maior, mais programas e sistemas complexos, ele permite que várias pessoas para construir coisas em conjunto, e, finalmente costurar seu trabalho em conjunto desta maneira. Mas, é claro, nós precisa agora corrigir tosse. Nós precisamos dizer a tosse que, hey, você sabe o quê? Você vai precisar de tomar um input-- por isso não vazio, mas int e agora. Vamos em frente e colocar em tosse do int. i recebe zero. 

i é menos do que o número de vezes. Eu disse três antes. Mas não é isso que eu quero. Eu quero tossir para ser generalizado para suportar qualquer número de iterações. 

Então, na verdade, é n que eu quero, tudo o que o usuário diz-me. Agora, eu posso ir em frente e dizer tosse impressão. E não importa o número de o usuário passa em, Vou fazer uma iteração que muitas vezes. 

Assim, no final do dia, programa é idêntico. Mas observe todas essas coisas Pode até ser em outro arquivo. Na verdade, eu não sei no momento, como printf é implementado. 

Eu não sei no momento como chegar corda, ou obter int, ou obter flutuador são implementadas. E eu não quero vê-los na tela do meu. Como é, eu estou começando a se concentrar em meu programa, não essas funções. 

E assim, de fato, tão logo você começar factoring código como este para fora, Nós até podia mover tosse para um arquivo separado? Alguém mais poderia implementá-lo. E você e seu programa de tornar-se o muito bonito, e muito legível, sem dúvida, realmente quatro programa de linha ali. 

Então, vamos em frente agora e fazer mais uma mudança. Observe que meu protótipo tem de mudar em cima. Então deixe-me corrigir isso assim Eu não obter gritou. 

Faça tosse, me deixar correr tosse uma vez mais, ainda fazendo a mesma coisa. Mas agora, perceber que temos uma ingrediente para uma versão final. Você sabe o que? Eu não quero apenas tosse, necessariamente. Eu quero ter algo mais geral. Então você sabe o quê? Eu quero fazer isso. Quero ter, bem como do risco faz, um bloco por exemplo, mas não apenas dizer algo um determinado número de vezes. Eu quero dizer uma seqüência muito específica. E, portanto, eu não sei quer que ele acabou de dizer tosse. Eu quero dizer o que quer string é passado. 

Então, observe, eu generalizada isso para que agora digamos se sente como um bom nome para isso, como o risco, leva dois argumentos, ao contrário zero. Um deles é um string. Um deles é um int. 

E eu poderia mudá-los. Eu meio que gosto da idéia de dizem que a corda primeiro, e depois quantas vezes posteriores. Vazio significa ainda não retorna nada. Estes são apenas lado visual efeitos, como com [? Jordan,?] um efeito colateral verbal de gritar. Ele ainda faz algo n vezes, 0 até, mas não igual a n. Isto significa n vezes no total. E depois é só imprimir o que quer que essa cadeia é. Então, eu realmente generalizada esta linha de código. Então, agora, como faço para implementar a função de tosse? 

Eu posso fazer tosse vazio. E eu ainda posso tomar como muitas vezes você quer a tossir. Mas você sabe o que? agora eu posso chutar a dizer. 

Eu posso chamar dizer com o palavra tosse, passando n. E se eu quiser implementar também, apenas por diversão, uma função espirro, I pode espirrar um determinado número de vezes. E eu posso manter reutilizando n, porque notar que m neste contexto ou extensão só existe dentro dessa função. 

E n neste contexto apenas existe dentro desta função aqui. Então, vamos voltar a estas questões de âmbito. E aqui, eu só vou dizer, Achoo e, em seguida n vezes, ponto e vírgula. 

E agora, eu só precisa tomar emprestado estas funções assinaturas até aqui. Então tosse é correto. espirro vazio é correta agora. 

E eu ainda só precisa dizer. Então eu vou dizer, digamos string s, int n, ponto e vírgula. Então, eu tenho mais de engenharia do Parreira fora deste programa. 

E isso não faz significa necessariamente que este é o que deve fazer quando se escreve mesmo o mais simples dos programas. Tome algo que é, obviamente, muito simples, muito curto, e re-lo implementar usando maneira muito código. Mas você vai realmente ver, e em tempo de olhar para trás sobre estes exemplos, e perceber, oh, esses são os passos tomámos para realmente generalizar, fatorar algo fora, até ao final do dia meu código é realmente muito razoável. Porque se eu quiser tossir três vezes, em seguida, espirrar três vezes, Eu estou indo simplesmente para executar novamente este, programa fazer tosse, e executar tosse. E eu tenho três tosses e três espirra. 

E por isso este é um básicos paradigma, se quiserem, de como podemos ir sobre na verdade, a implementação de um programa. Mas vamos ver agora o que é temos vindo a fazer todo este tempo, e que algumas das peças finais estão por trás dessa simples comando. No final do dia, temos vindo a utilizar Clang como nosso compilador. Temos vindo a escrever fonte código, convertendo- via Clang em código de máquina. 

E nós temos vindo a utilizar fazer apenas para facilitar nossas combinações de teclas de modo que não tem que se lembrar esses encantamentos de si Clang. Mas o que é fazer realmente fazendo? E, por sua vez, o que é Clang realmente fazendo? 

Acontece que, embora tenhamos simplificado a discussão de hoje, dizendo: você toma código-fonte, passá-lo como entrada para um compilador, que lhe dá saída da máquina código, acontece que há algumas etapas diferentes dentro lá. E compilação passa a ser o guarda-chuva prazo para todo um conjunto de passos. Mas vamos apenas provocá isso muito rapidamente. 

Acontece que temos vindo a fazer mais coisas cada vez que eu executar um programa, ou cada vez que eu compilar um programa hoje. Assim, o pré-processamento refere-se a isto-- qualquer coisa em um programa C, como veremos de novo e de novo, que começa com este símbolo de hash, ou o símbolo hashtag aqui, significa é um pré-processador diretiva. Isso significa que, neste caso, ei computador, fazer algo com esse arquivo antes de realmente compilar meu próprio código. 

Neste caso, de hash incluem seja, essencialmente, maneira de dizer do C, hey computador, ir buscar o conteúdo de CS50.h e colá-los aqui. Hey computador, ir buscar o conteúdo de io.h padrão, onde quer que seja sobre o disco rígido, colá-lo aqui. Então, essas coisas acontecem pela primeira vez durante o pré-processamento. 

E Clang faz tudo isso para nós. E fá-lo tão danado rápido, você nem sequer ver quatro coisas distintas acontecendo. Mas essa é a primeira tal passo. 

O que realmente acontece em seguida? Bem, o próximo oficial passo é a compilação. E verifica-se que compilar um programa tecnicamente significa que vai de código-fonte, as coisas que tenho sido escrito hoje, para algo chamado de código de montagem, algo que parece um pouco diferente. 

E, de fato, podemos ver isso muito rápido. Deixe-me realmente ir para o meu IDE. Deixe-me ir em frente e hello.c aberta, que é o primeiro programa com o qual nós começou hoje. E deixe-me ir em frente e correr Clang um pouco diferente, Clang-s, hello.c, que está indo realmente para Dê-me outra hello.s de arquivo. 

E nós provavelmente nunca será novamente ver esse tipo de código. Se você tomar um nível mais baixo sistemas de classe como CS61, você vai ver muito mais deste tipo de código. Mas esta é a linguagem assembly. Este é X86 linguagem assembly que a CPU que está subjacente CS50 IDE realmente entende. 

E enigmática como faz olhar, é algo o computador entende muito bem. Sub Q, isto é um substrato. Há movimentos. 

Não está chamando de funções aqui, x oring, um movimento, um complemento, um pop, um retorno. Portanto, há alguns muito instruções de baixo nível que CPUs entender que Aludi anteriormente. Isso é o que Intel Inside. 

Existem padrões de zeros e uns que mapear a estes redigido arcanely, mas um pouco bem-nomeado, instruções, por assim dizer. Isso é o que acontece quando compilar o código. Você começa a montagem língua de fora, o que significa que o terceiro passo é para montar que o código assembly para, em última análise, Máquina de zeros code-- e uns, não os texto que acabamos de ver um momento atrás. 

Assim, pré-processamento que isso encontrar e substituir, e algumas outras coisas. Compilando leva a sua fonte código de C, o código fonte que escreveu, para montagem código que nós apenas olhou. Montagem leva que a montagem código para zeros e uns que o CPU vai realmente compreender, no final do dia. E vinculação é a última etapa que acontece para US-- novamente, tão rápido que nem sequer notice-- que diz: hey computador, tomar todas os zeros e uns que resultou de compilar o código de Davi, e sua principal função neste caso. 

E ei computador, ir buscar todos os zeros e uns que a equipe CS50 escreveu dentro da biblioteca CS50. Misture aqueles com Davi. E ei computador, ir buscar todos os zeros e aqueles que alguém escreveu anos atrás para printf. E adicionar aqueles para o coisa toda, de modo que nós temos tenho meus zeros e uns, a zeros e uns do pessoal CS50, os zeros e uns, printf e qualquer outra coisa que estamos usando. 

Todos eles se combinados em um programa chamado, neste caso, Olá. Então, de agora em diante, vamos apenas usar a palavra compilação. E vamos tomar como certo que, quando dizemos, compilar seu programa, ou seja, hey fazer o pré-processamento, montagem e ligação. Mas há realmente algumas coisas suculenta acontecendo lá debaixo do capô. E especialmente se você ficar curioso algum tempo, você pode começar a picar em torno a este nível inferior. Mas, por agora, perceber que entre os tópicos para hoje são pura e simplesmente o início de um processo, de ficar confortável com algo como Olá mundo. Na verdade, a maioria do que fizemos hoje certamente não vai afundar na super rápido. E isso vai levar algum tempo, e alguma prática. E as probabilidades são, você irá classificar de quer bater o seu teclado ou gritar para a tela. E tudo isso é OK. Embora, talvez tente não fazê-lo na biblioteca tanto. 

E, finalmente, você vai ser capazes, porém, de começar vendo padrões, tanto no bom código que você escreveu e em erros que você fez. E muito parecido com o processo de tornando-se um TF ou uma CA é como, você vai começar a ficar melhor e melhor ao ver esses padrões, e apenas resolver o seu próprios problemas em última instância. Nesse meio tempo, haverá uma abundância de nós para dar-lhe suporte, e levá-lo através disso. E nos write-ups para todos os problemas você será guiado através todos os comandos que eu certamente sabe de muita prática até agora, mas poderia ter voado sobre a cabeça por agora. E isso é totalmente bem. 

Mas, em última análise, você vai para começar a ver surgir padrões. E uma vez que você passar por todo o detalhes estúpidas, como parênteses, e chaves, e ponto e vírgula, e as coisas, francamente, que não é de modo nenhum intelectualmente interessante. E não é o objetivo de tomar qualquer aula introdutória. É as idéias que vão importa. 

São os loops, eo condições e as funções, e mais poderosamente a abstração, eo factoring de código, eo bom projeto, eo bom estilo, e, finalmente, a exactidão do seu código, que é, em última análise vai importar mais. Assim, na próxima semana, iremos tomar estas ideias que vimos pela primeira vez em Risco e agora traduzido a C. E vamos começar para introduzir o primeiro do domínios do mundo real do curso. 

Vamos concentrar-se no mundo da segurança, e mais especificamente criptografia, técnica de codificação da informação. E entre o primeiro problemas que você mesmo vai começar a gravar além jogando com alguma da sintaxe e resolver alguns lógica problemas, em última análise, em pouco tempo, é realmente lutam, ou criptografar, e, finalmente, desencriptar a informação. E tudo o que fizemos Hoje, será bastante baixa nível, é apenas vai permitir -nos a tomar um, e um, e mais um passo acima na direção escrever o código mais interessante ainda. 

Então mais sobre isso na próxima semana. 

[REPRODUÇÃO DE VÍDEO] 

-O Que você pode me dizer sobre a última vez que o viu? -O Que eu posso dizer, realmente? Quero dizer, era como qualquer outra ensaio de pré-produção, exceto que não era algo que ele disse no final que ficou comigo. 

-Este Foi CS50. 

-É Um corte de todos, grande trabalho em ensaio. 

o almoço de -que? 

Sim, você e eu podemos pegar um sanduíche em um pouco. Deixe-me apenas interrogar com David muito rapidamente. David? David? 

[FIM DE REPRODUÇÃO] 