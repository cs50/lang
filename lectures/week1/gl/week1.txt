[Reprodución de música] DAVID J. Malan: Todo ben, iso é CS50. E esta é unha semana. Entón lembro a última vez a semana cero, Nós nos concentrados en pensamento computacional. E a transición de que a Cero, a programación gráfica linguaxe dos nosos amigos no Media Lab do MIT. 

E co Scratch, que exploran ideas como funcións e condicións, e loops e variables, e mesmo eventos e debates, e máis. E hoxe, imos continuar a utilizar estas ideas, e realmente levalos para concedido, pero traducilo las a outro idioma coñecido como C. Agora C é unha linguaxe máis tradicional. É un nivel máis baixo a linguaxe, se quere. 

É puramente textual. E así, a primeira vista, é todo vai mirar un pouco críptica se nunca programou antes. Nós imos ter punto e coma e parénteses, e chaves, e moito máis. Pero entender que, aínda aínda que a sintaxe sexa sobre a mirar un pouco familiarizado a maioría de vós, ver ademais. E tentar ver as ideas que son, de feito, familiar, porque aquí a semana un o que comezaremos a facer é comparar, Inicialmente, Raspe contra C. 

Así, por exemplo, recordar que cando aplicou o primeiro dos nosos programas último, tivemos un bloque que parecía un pouco algo como isto-- cando bandeira verde premendo, e despois tivemos Un ou máis pezas do puzzle, abaixo dela, neste caso, dicir, Ola mundo. Entón, en realidade, en perigo, cando premo que a bandeira verde para realizar o meu programa, de xeito falar, son os bloques que son executadas, ou correr. E, especialmente, risco dixo, Ola, mundo. 

Agora, eu podería especificar diferentes palabras aquí. Pero imos ver que, de feito, moitos destes blocks-- e, en realidade, C en moitas funcións no se pode parametrizada ou personalizado para facer cousas diferentes. De feito, en C Quere converter agora este programa Raspadinha a esta outra lingua, nós estamos indo a escribir un pouco algo así. 

Concedida, hai algunha estraña sintaxe hai máis probable, int, e parénteses e sen efecto. Pero printf-- mesmo que faría creo que sería só impresión. Pero de impresión significa impresión formato, como veremos en breve. Esta literalmente imprimirá para a pantalla que quere está dentro destes parénteses, que Claro que neste caso é, Ola mundo. 

Pero vai notar algunhas outras sintaxe, algunhas comiñas, que os parénteses ao final, o e coma e similares. Polo tanto, hai un pouco de sobrecarga, por así dicir, cognitivamente tanto e sintaticamente, que imos ter que lembrar antes de tempo. Pero entender que coa práctica, iso vai comezar a ir para fóra en ti. 

De feito, imos concentrar no que un función specifically-- neste caso dicir Hola mundo. Entón, digamos que é a función. Ola, mundo é o seu parámetro, ou argumento, a personalización. 

E a equivalencia en C é só será esta unha liña aquí, onde printf equivale a, digamos, a cadea entre comiñas dobres, Ola mundo equivale, por suposto, ao que está no cadro branco alí. E a barra invertida n, aínda que un pouco estraña e ausente a partir de cero, simplemente vai ter o efecto que ver nun ordenador, como o meu Mac ou PC, de só movendo o cursor á seguinte liña. É como bater Intro no teclado. 

Entón, imos ver iso de novo antes de tempo. Pero, primeiro, imos dar un ollo neste outro exemplo, no caso de lacetes. Tivemos este loop para sempre na última vez, que foi unha serie de pezas do puzzle que fixo algo literalmente sempre-- neste caso dicir Hola mundo, Ola mundo, Ola mundo, Ola mundo. Polo tanto, é un loop infinito por deseño. 

C, se queremos aplicar este mesma idea, poderiamos simplemente facelo. Mentres verdade, printf Ola mundo-- agora mentres, só semanticamente, tipo de evoca a idea de facer algo máis dunha vez, e de novo, e de novo, e por canto tempo? Ben, lembre que true-- realidade é só o un. 

Certo é, por suposto, sempre certa. Polo tanto, é unha especie de sentido declaración só para dicir verdade. Pero, en realidade, este é deliberada, porque de ser verdade é só sempre certo, que mentres verdade só indica, Un pouco indirectamente que as liñas de código entre esas claves debe só realizar de novo, e de novo, e de novo, e nunca realmente parar. 

Pero se quere que o seu loop para deixar, como nós fixo a última vez con algo parecido iso, repita os seguintes 50 veces, no C, podemos facer o mesmo co que hai de chama a palabra clave para o loop-- non sendo á vez, pero para. E entón temos algunha nova sintaxe aquí, con int i é igual a 0, i inferior a 50, i ++. E nós imos voltar a iso. Pero iso é simplemente como iríamos traducir o conxunto de bloques de raspadinhas para un conxunto de liñas de código C 

Mentres tanto, considerada variables. E, de feito, nós só vin un un momento atrás. E no caso de cero, se quería declarar unha variable chamada i para i sendo enteiro, só un número, e queremos configuralo para algún valor, usariamos este laranxa bloquear aqui-- establecer i a 0. 

E veremos hoxe e ademais, como a semana pasada, programadores fan case sempre comezar a contar desde cero, realmente por convención. Pero tamén porque recollida xunto nosa discusión de par, o menor número posible representan con calquera número de bits é só será 0 si. E por iso imos xeralmente comezan arrincar mesmo nosas variables a 0. 

E en C a facer o mesmo, imos dicir int por enteiro, eu só por convención. Podería chamar esta variable o que eu queira, así como en perigo. E entón é igual a 0 só cessionários o valor 0 da dereita e poñelas na variable, ou a recipiente de almacenamento fai, na parte esquerda. E o punto e coma como imos see-- e vimos algúns deses já-- só significa final de pensamento. Avance para facer outra cousa nas liñas que seguen. 

Agora, o que pasa con expresións booleanas? Lembre que en risco, Estes eran expresións que son certas ou preguntas false--, Realmente, que son certas ou falsas. Así, no caso do Scratch, poderiamos facer unha pregunta sinxela como este, é i menos de 50? Entón eu, unha vez máis, é un número enteiro. Quizais estamos a usalo nun programa de arañazos manter o control de unha puntuación ou algo así. Polo tanto, esta sintaxe aquí Risco Significa só que, se i menos de 50? Ben, por sorte, algo está simple en C. E para traducir, iso sería simplemente dicir i menos de 50, utilizando a clave familiarizados no teclado. 

Mentres tanto, se quería dicir algo máis xeral, como, ben, é x menos y onde cada de X e Y son, eles mesmos variables? Podemos facer o mesmo no C, desde que temos creou estas variables xa. E veremos como facelo antes de tempo. Simplemente diría x inferior a y. 

Entón, está empezando a ver algunhas semellanzas. E aquelas persoas que fixeron Cero eran certamente inspirado por algunhas destas ideas básicas. E vai ver este tipo de sintaxe en moitos languages-- non só cero, non só C, pero Python, e JavaScript, e outras linguas aínda. 

Imos considerar outra construción de C, a noción dunha condición, facendo algo condicional. Se algo é certo, facelo. Se algo é certo, facelo. É unha especie de programación equivalente a unha bifurcación na estrada. Quizais sexa unha de dúas vías garfo, un garfo de tres vías, ou máis. E en perigo, poderiamos visto algo así. 

Entón que é un gran problema. Pero considere o parente simplicidade da lóxica. Se x é menor que y, a continuación, dicir x é menor que Y, o resto si x é maior que Y, logo dicir que x é maior que y. E, a continuación, loxicamente, se pensas que volta a rabuñar ou só a súa propia intuición humana, así, se x non é maior que Y, e X non é menos que Y, entón está claro x será igual a y. Polo tanto, neste caso, por asentamento os bloques de raspadinhas, podemos conseguir un tres xeito bifurcación na estrada? 

Mentres tanto, se queremos facelo en C, é indiscutibelmente parece un pouco simpler--, polo menos, xa que familiarizarse coa sintaxe. Se X é menor que Y, printf x é inferior a y. Senón, se x é maior que Y, printf x é maior que y. Else printf x é igual a y-- e, unha vez máis, con aqueles barra invertida remata pronto para estas novas liñas de modo que se Realmente foi este tipo de programa sería só mover o cursor ao final, á seguinte liña da pantalla. 

Agora, con todo risco tivo outra recursos máis sofisticados, única algúns dos cales imos inicialmente pasar ao mundo do C. E un deles foi chamado dunha lista en perigo. E este foi un especial tipo de variable que permítelle almacenar moitas cousas na volta, atrás, cara atrás, cara atrás. 

C, que non teñen listas, de per si, pero algo que son máis xeralmente chamado de matrices, aínda imos voltar máis tarde este semestre a ollar para algo chamado dunha lista, ou realmente unha lista ligada. Pero, por agora, o máis próximo equivalente en C para nós Vai ser algo chamado dunha matriz. E unha matriz é simplemente unha tipo especial de variable que lle permite almacenar datos atrás, cara atrás, cara atrás, cara atrás. 

E, de feito, en perigo, se queriamos para acceder o primeiro elemento dunha matriz ou un lista-- e eu vou chamalo, por convención, argv, o argumento vector, pero máis sobre iso antes de tempo. Se eu queira comezar no primeiro elemento de argv, no mundo do scratch realmente fai normalmente comezar a contar a partir do 1. 

E así eu podería obter o elemento 1 da argv. Isto é só como MIT aplicado a noción de listas. Pero en C, vou máis simple só dicir, argv, que de novo é o nome do meu lista-- ou para ser claro, unha matriz. E se eu queira o primeiro elementos, eu vou usar corchetes, o que Pode non frecuentemente usado en un teclado. 

Pero 0 significa só, me o primeiro. Entón, de vez en cando e como o tempo pasa, imos para comezar a ver estas dicotomias entre cero e C, en que cero usa un. Nós en C usan 0 aquí. Pero vai ver rapidamente Despois de entender os fundamentos de cada lingua, que esas cousas comezan a estar aínda máis familiarizado coa práctica e práctica. 

Entón imos realmente ollar agora para un programa. Aquí debería ser o primeiro da nosa C código fonte de programas completos. E o programa que imos para ofrecer a consideración é o que equivale para que no inicio peza cero. 

Entón aquí, temos o que é sen dúbida, o programa máis simple C pode escribir que realmente fai algo. Agora, imos ollar o pasado por agora, ha inclúen, io.h serie, e ambos ángulo corchetes, e int e baleira, e as chaves, e así por diante. 

E imos só centrar o que, polo menos, intuitivamente, Pode ir para fóra en ti xa. De feito, o principal, eu non sei necesariamente saben o que é iso, pero moi parecido cero tiña que cando bandeira verde premendo parte do enigma, o mesmo ocorre con C como linguaxe de programación ten unha peza principal de código que corre por defecto. E, de feito, é, literalmente, será chamado principal. 

Así principal é unha función. E é unha función especial que hai en C que, cando executar un programa, é principal que corre por estándar. No mundo do scratch, era xeralmente cando a bandeira verde premendo que foi executado por defecto. 

Mentres tanto, vimos isto antes, printf ou imprimir formato, que é vai ser unha función que vén con C, xunto con unha morea de outros, que a vontade de tempo e tempo de novo, a fin de facer exactamente como o propio nome suxire, imprimir algo. O que queremos imprimir? Ben, imos ver que por personaxes que encerran como o mundo these-- Ola, barra invertida n entre comiñas dobres, podemos dicir exactamente printf o que imprimir na pantalla. 

Pero, a fin de facer que, por desgraza que tomar algo que é xa enigmática para nós seres humanos, pero polo menos é algo readable-- afiada inclúen, io.h estándar, int, principal, baleiro, printf, toda a maxia encantamentos que acabamos de ver na pantalla. Pero nós realmente temos que ir máis misterioso aínda. Primeiro necesitamos traducir o código que escribir en código máquina. E lembro desde a semana pasada que as máquinas, polo menos os que sabemos aquí, no fin do día única comprender ceros e uns. 

E, meu Deus, se tivésemos que escribir estas ceros e uns que realmente programa, que sería moi, moi rápido levar a diversión fóra de calquera cousa. Pero resulta que, por semana pasada que eses patróns de ceros e uns só ten significado especial. En certos contextos, poden significar números. 

Nalgúns contextos, poden significar letras ou cores, ou calquera número doutras abstraccións alí enriba. Pero, así como o seu ordenador ten unha CPU, Central Processing Unit, ou o cerebro no seu ordenador. É xeralmente Intel dentro, porque iso é unha das maiores empresas que fai CPUs para ordenadores. 

Ben, CPUs Intel e outros simplemente decidir anticipadamente que certos patróns de ceros e queridos debe significar cousas específicas. Certos patróns de ceros e uns significará, imprimir esta a pantalla, ou engadir eses dous números, ou restar eses dous números, ou mover este anaco de datos de memoria do meu ordenador aquí, ou calquera número de outras nivel moi baixo, pero en definitiva útil, operacións. Pero, por sorte, nós, humanos, non van ter saber ese nivel de detalle. De feito, así como a última vez, onde nós abstraída de novo, e de novo, e de novo, construción de moi baixo nivel primitivos como ceros e uns a conceptos de nivel máis alto como números e letras, e cores, e máis, Tamén podemos como programadores estar sobre os ombreiros de outros que viñeron antes de nós e utilizar o software que outra persoas teñen escrito antes US-- é dicir, programas chamados compiladores. 

C é unha linguaxe que xeralmente é compilado, o que significa converter a partir código fonte para código de máquina. En particular, o que significa isto é que, se ten a súa fonte código que mesmo escribe, como nós en breve vai en só un momento na pantalla, e quere convertelo-lo finalmente, a máquina code-- estes ceros e uns que só o seu Mac ou PC understands-- ten un primeiro alimentar ese código fonte en como entrada para un especial programa chamado compilador, a saída dos cales nós que ver é o código de máquina. E, de feito, a última vez que nos falamos sobre, realmente, ao final do día, resolución de problemas. Ten entradas. E ten saídas. E ten algún tipo do algoritmo no medio. 

Algoritmos poden certamente ser aplicadas en software, como vimos con pseudocódigo a semana pasada e, como veremos con código real esta semana. E así un compilador realmente só ten un conxunto de algoritmos dentro de que sabe como converter as palabras clave especiais, como principal, e printf, e outros que acabamos viu nos patróns de ceros e quen Intel dentro e outras CPUs realmente entende. Entón, como imos facelo? Onde é que imos conseguir un compilador? 

A maioría de nós aquí ten un Mac ou PC. E está executando Mac VOS, ou Windows ou Linux ou Solaris, ou calquera número de outras sistemas operativos. E, de feito, poderiamos saír na web e baixar un compilador para o seu Mac ou PC para o seu sistema operativo en particular. Pero todos nós sería en páxinas diferentes, por así dicir. Teriamos algo diferentes opcións. E as cousas non funcionan do mesmo xeito. E, de feito, a día de hoxe moitos de nós non usan programa que se executa só nos nosos portátiles. Pola contra, usan algo como un navegador que permítenos acceder web-based aplicacións na nube. E aínda este semestre, imos facer exactamente isto. Imos escribir aplicacións ou software usando code-- non C, pero outras linguaxes como Python e JavaScript-- que son executados na nube. 

E para facelo, nós mesmos durante o semestre vai realmente usar unha base de nube ambiente coñecido como CS50 IDE. Esta é unha programación baseada en web ambiente ou de desenvolvemento integrado ambiente, IDE, que está construído enriba dalgúns software de código aberto chamado Cloud 9. E nós fixemos algún pedagóxica simplificacións para el para ocultar certos recursos no as primeiras semanas que non precisa, Despois de que pode revelalo-los e facer máis o que quere co medio ambiente. 

E iso nos permite, tamén, a pre-instalar determinado programa. Cousas como un chamado CS50 biblioteca, que veremos en breve ofrece-nos en C con algún funcionalidade adicional. Entón, se vai para, en última instancia, CS50.io, lle será solicitada a entrar, e unha vez que fai e crear unha conta para libre, será capaz de acceder a un ambiente que parece bastante como este. 

Agora, iso está en modo estándar. Todo é bo e brillante na pantalla. Moitos de nós teñen o costume de traballando peza CS50 que é moi tarde para a noite. E así algúns de vostedes poden preferir transformalo en modo noite, por así dicir. 

Pero, en definitiva, o que está veremos dentro CS50 IDE é de tres areas-- distinta unha área na que a esquerda os seus arquivos serán en nube, unha área na esquina superior dereita onde o código será editable. Vai ser capaz de abrir guías individuais para calquera programa que escribir este semestre dentro dese ángulo superior dereito. E entón máis arcanely, e aínda así potente, será esa cousa na bottom coñecido como unha fiestra de terminal. 

Esta é unha vella escola Command Line Interface, ou o CLI, que permite executar comandos na Computador-- neste caso o ordenador no cloud-- para facer cousas como compilar o código dende o código fonte para código de máquina, para realizar os seus programas, ou para comezar a súa servidor web, ou para acceder a base de datos, e calquera número de outras técnicas que vai comezar a usar antes de tempo. Pero para chegar alí, estamos vai realmente ter ir en liña e comezar a xogar. E para facelo, imos primeiro comezar a xogar coa principal, e escribir a parte principal dun programa. E imos usar esta función printf, que temos utilizado anteriormente, simplemente para dicir algo. 

Entón aquí eu xa estou dentro IDE CS50. Teño rexistrado con antelación. E eu completo aparece na ventá. E así, en definitiva, ten tamén en problemas próximos vai seguir os pasos similares que pode fornecer a documentación en liña. Entón non se preocupe absorbendo cada etapa técnica pouco o que fago aquí hoxe. 

Pero vai ter unha pantalla como esta. Acontece que eu estar en modo de noite. E pode iluminar todo -Se desactivando o modo noite. E ao final da día, vai ver estes tres principal areas-- o ficheiro navegador á esquerda, as guías de código enriba, ea fiestra da terminal, na parte inferior. 

Deixe-me ir adiante e escribir o meu primeiro programa. Eu estou indo a ir cautelarmente para arquivo, Gardar e gardar o meu ficheiro como hello.c. En realidade, por convención, calquera que programa gravación que está escrito na linguaxe C debe ser nomeado algo dot c, por convención. Entón eu vou nomealo hello.c porque Eu só quero dicir Hola para o mundo. Agora vou para aumentar fóra e prema Gardar. E todo o que teño aquí agora é unha guía en que eu poida comezar a escribir código. 

Iso non vai compilar. Iso non significa nada. E por iso mesmo que eu convertinme isto para ceros e uns, a CPU terá ningunha idea do que está a ocorrer ao redor. Pero se eu escribir as liñas que coinciden -se co ser C conventions-- de C, de novo, esta language-- con sintaxe como iso, printf Ola mundo-- e non teño sentiron cómodos con facendo iso ao longo do tempo. Entón eu non creo que fixen posibles erros tipográficos. 

Pero, invariablemente, o primeiro xa que fas, vai. E o que eu estou a piques de facer moito pode así non funciona para ti por primeira vez. E iso é perfectamente normal, porque agora pode só ver unha chea de novidade, pero co paso do tempo xa que familiarizarse con este ambiente, e esta linguaxe, e outros, vai comezar a ver as cousas que ou son correctas ou incorrectas. 

E iso é o que o compañeiros de ensino e curso asistentes estar tan bo en ao longo do tempo, é detectar erros ou erros no seu código. Pero aseguran que hai hai erro neste código. Entón agora eu quero facer este programa. 

Agora no meu propio Mac ou PC, estou en o costume de iconas dobre clic cando quero realizar algún programa. Pero iso non é o modelo aquí. Neste ambiente, o que é CS50 IDE. Estamos a usar unha operación sistema chamado Linux. Linux é unha reminiscencia de outra sistema operativo, xeralmente coñecido como Unix. E Linux é particularmente coñecido por ter unha liña de comandos Ambiente, CLI. Agora, estamos a usar unha específica sabor de Linux chamada Ubuntu. E Ubuntu é simplemente unha determinada versión de Linux. 

Pero estes Linux nos días de hoxe fan, en realidade, veñen con interfaces gráficas de usuario. E o que acontecerá co estar a usar aquí está baseado na web. Polo tanto, este pode parecer ata un pouco distinto de algo vostede mesmo pode ter visto ou executado no pasado. 

Entón, eu estou indo a ir adiante agora e faga o seguinte. Gardei este ficheiro como hello.c. Eu estou indo a ir adiante e Tipo clanghello.c Entón Clang á linguaxe C é un compilador. É preinstalado no CS50 IDE. E pode absolutamente descargar e instalar no seu propio Mac ou PC. 

Pero, unha vez máis, non ten todas a preconfiguración feito para ti. Entón, por agora, eu son só correrá clanghello.c. E agora entender esta sintaxe aquí acabará realizar só significa que eu estou nun carpeta ou directorio chamado Workspace. Este sinal de dólar é só unha convención de sentido, escriba os comandos aquí. 

É o que se chama un prompt, pode por convención é sinal de dólar. E se eu ir adiante agora e prema Intro, nada parece acontecer. Pero iso é realmente bo. A menos que pasa sobre pantalla, o máis probable seu código é ser correcto, polo menos sintacticamente. 

Entón, se eu queira executar este programa, o que fago? Ben, parece que o nome por defecto por convención para os programas cando non especificar un nomear ao seu programa só a.out. E esta sintaxe tamén, vai familiarizarse con antes de tempo. 

Dot cortar só significa que, hey, CS50 IDE, executar un programa chamado a.out que está dentro do meu directorio actual. Isto punto significa o directorio actual. E imos ver o que outras secuencias de caracteres significa antes de tempo. 

Entón, imos alí, Intro, Ola mundo. E vai notar, que o que pasou? Non só imprimir Ola mundo. Tamén movido a cursor á seguinte liña. 

E por que isto? Cal era o código que escribiu antes que asegurar-se que o cursor sería ir á seguinte liña? Cousa divertido sobre un ordenador é que só vai para facer literalmente o que diga a el para facer. 

Entón, se diga a el para printf Ola, coma, espacio, mundo, preto citas, é, literalmente, só vai para imprimir estes caracteres. Pero eu tiña ese carácter especial ao final, recall, barra invertida n. E iso é o que garantiu que o personaxe pasou á seguinte liña da pantalla. 

En realidade, deixe-me ir e facelo. Deixe-me ir adiante e eliminar este. Agora, teña en conta que o parte superior da miña pantalla hai un pouco de luz vermella na a guía indica, hey, non salvou o seu arquivo. Entón, eu estou indo a ir adiante co control S ou o comando S, salva o arquivo. Agora goes-- fun a un verde moment--. E agora está de volta para só a ser un icono de preto. 

Se eu agora realizar clanghello.c de novo, Intro, barra punto, a.out, enter, vai ver que aínda traballaba. Pero é, sen dúbida, un pouco buggy. Neste momento, o meu traballo prompt--, e despois de que o sinal de dólar, e despois o meu prompt-- real é todo na mesma liña. Entón, iso certamente un erro estética, aínda que iso non é realmente un erro lóxico. 

Entón eu vou para desfacer o que eu fixen. Eu estou indo a executar de novo a.out. Repare que eu engadir o newline personaxe de volta. Eu salvo o ficheiro. 

Entón, eu estou indo a executar de novo a.out, e- caramba, un erro, un erro que supón erro. Así, o erro é que, aínda que Eu engade a barra invertida n alí, re-gardados, re-correu o programa, o comportamento era a mesma. Por que iso sería? 

Estou falta un paso, non? Ese paso clave no inicio foi que ten a-- cando cambiar o seu código fonte, verifícase tamén realizar Lo través do compilador novo para obter un novo código de máquina. E o código de máquina, os ceros e uns, van ser case idéntico, pero non perfectamente así, porque necesitamos, por suposto, que a nova liña. 

Entón, para corrixir iso, eu vou ter executar novamente clanghello.c, entrar, dot slash, a.out. E agora, Ola mundo está de volta onde eu esperaba que fose. Entón, iso é todo moi ben e bo. Pero a.out é un nome moi estúpido para un programa, aínda que pasa a ser, por razóns históricas, o default-- significando saídas de montaxe. 

Pero deixe-me ir adiante aquí e facelo de forma distinta. Eu quero o meu programa Ola Mundo para realmente ser chamado Ola. Entón, se fose unha icona no meu escritorio, non sería a.out. Sería chamado Ola. 

Entón, para facelo, verifica-se que Clang, como moitos programas, soporta os argumentos da liña de comandos, ou bandeiras, ou interruptores, que simplemente influír no seu comportamento. En concreto, Clang soporta un trazo o bandeira, que, a continuación, toma unha segunda palabra. Neste caso, eu vou arbitrariamente, pero razoablemente, chamalo Ola. Pero eu podería chamalo algo Quero, excepto a.out, que Sería moito máis alá do punto. 

E despois é só especificar o nome do ficheiro que quero para compilar. Entón, agora mesmo que no inicio da orde aínda teño Clang, ao final do comando Eu aínda teño o nome do ficheiro, Agora teño eses liña de comandos argumentos, estes sinalizados que están dicindo, Oh, por certo, output-o, un arquivo chamado Ola, non o a.out estándar. 

Entón, se eu acertar Entre agora, nada parece acontecer. E, ademais, agora podo facer barra dot Ola. Polo tanto, é o mesmo programa. Os ceros e uns son idénticas ao final do día. 

Pero eles están en dous diferente a.out files--, que é a primeira versión e só tolamente nomeado, e agora Ola, que é un tanto nome máis atractivo para un programa. Pero, honestamente, eu nunca estou vai lembrar de novo, e de novo, e de novo. E, de feito, como se escribe programas máis complicados, as ordes que está Vai ter que escribir van estar aínda aínda máis complicado. 

E así non se preocupe. Acontece que os seres humanos antes nós xa viron que eles tamén tiven ese mesmo problema exacto. Eles non me gustaba de ter que escribir ordes moi longos, misterioso, moito menos lembrar deles. E así os humanos antes de nós fixeron outros programas que fan máis doado para compilar o seu programa. 

E, de feito, unha tal programa chámase Marca. Entón, eu estou indo a ir adiante e facelo. Eu estou indo a desfacer todo o que eu acaba de facer do seguinte xeito. Déixeme escribir LS. E verás tres coisas- a.out, e unha estrela, Ola e unha estrela, e hello.c. Esperemos que este debe ser un pouco intuitivo, na medida en que non había anteriormente nada neste espazo de traballo. Non había nada que eu tiña creado ata que comezamos a clase. 

E eu creei hello.c. Eu, entón, compilou, e chamou-a.out. E entón eu compilado de novo lixeiramente diferente e chamou-lle Ola. Entón, eu teño tres arquivos nese directorio, nesta carpeta chamada Workspace. Agora, podo ver que ben se eu reducir en realidade. 

Se eu aumentar aquí e mirar para este lado superior dereito canto, como prometera á esquerda lado da pantalla sempre vai amosar-lle o que está na súa conta, o que é dentro IDE CS50. E hai tres arquivos alí. 

Entón, quero me librar de a.out e Ola. E como pode Imaxina intuitivamente, vostede podería tipo de control prema ou prema co botón dereito sobre esta. E este pequeno menú aparece. Pode descargar o ficheiro, faga Lo, velo, actualizar, eliminar, ou que non. 

E eu podería simplemente eliminar, e ía. Pero imos facer as cousas cun mando liña de momento, para estar cómodo con iso, e facer o seguinte. Eu estou indo a ir adiante e eliminar a.out escribindo literalmente rma.out. Acontece que, a orde para eliminar ou borrar algo, non é eliminar ou borrar. 

É máis brevemente RM, só para aforrar -lle algunhas teclas, e prema Intro. Agora imos ser un pouco enigmaticamente eliminar a.out ficheiro regular. Eu realmente non sei o que é un arquivo irregular sería aínda. Pero quero eliminar-lo. 

Entón eu vou para escribir y para si. Ou eu podería escribir-lo para fóra, e prema Intro. E, de novo, nada parece ocorrer. Pero iso é, en xeral, bo. 

Se eu escribir LS esta vez, o que debo ver? Afortunadamente, só Ola e hello.c. Agora, como un aparte, vai notar esta estrela, asterisco, iso é o final dos meus programas. E tamén están aparecendo en verde. Isto é só a forma da CS50 IDE de cluing-lo para o feito que iso non é o código fonte. Isto é un executable, un executable programa que realmente pode facer facendo barra punto, e entón é nome. 

Agora, deixe-me ir adiante e eliminar iso, rm Ola, Intro, eliminar regulares arquivo Ola, si. E agora si escribir LS, estamos de volta a hello.c. Probe a non eliminar o seu código fonte real. Aínda que haxa recursos incorporado IDE CS50 onde pode pasar polo seu historial de revisión e retroceder no tempo, se accidentalmente borrar algo, faga estar atento por eses avisos si ou non, do que realmente quere facer. E se eu for ata o cumio deixou canto aquí, todo o que queda é hello.c. Polo tanto, non hai acios de outros comandos que Pode realizar no mundo Linux, un dos cales é, de novo, Make. E nós estamos indo facer meu programa agora como segue. 

No canto de facer clang, en vez de facer clang-o, vou simplemente literalmente, tipo, marca Ola. E agora conta, estou non escribindo make hello.c. Estou escribindo make Ola. 

E este programa Fai ese ven con IDE CS50, e máis xeralmente con Linux, é un programa que é Vai facer un programa chamado Ola. E vai asumir, por convención, que se este programa se pode facer, que será feita a partir dunha fonte arquivo de código que terminan en c punto, hello.c. 

Entón, se eu prema Intro Agora, teña en conta que a orde que se executa é, en realidade aínda máis antes do que antes. E iso é porque temos IDE CS50 preconfigurado para ter algunhas características adicionais construídos en que Nós só non teñen, pero en breve. Pero a principal cousa a entender agora eu teño un programa Ola. 

Se eu escribir LS novo, eu ter un programa Ola. E podo executa-lo con dot cortar a.out, non, porque todo o punto deste exercicio foi dot Ola barra. E agora eu teño o meu programa Ola mundo. Entón, movendo-se para adiante, estamos case sempre só indo para compilar os nosos programas mediante o comando make. E entón nós estamos indo a executa-los por dot slash, eo nome do programa. Pero entenden o que fan está facendo por vostede, non é por si non é un compilador. É só un programa de barrio que sabe como provocar un compilador para realizar para que mesmo pode usalo. 

Que hai outros comandos no Linux, e á súa vez o CS50 IDE? Nós verá logo que hai unha mando CD, Change Directory. Isto permite que dentro súa interface de liña de comandos para seguir adiante, e cara atrás, e abrir carpetas diferentes sen usar o rato. 

LS que vimos, que significa lista os arquivos no directorio actual. Fai Dir, pode probablemente comezar a inferir o que elas significan agora-- facer directorio, se quere crear un cartafol. RM para eliminar, RM Dir para eliminar directory-- e estes, unha vez máis, son a liña de comandos equivalentes de o que podería facer en CS50 IDE co rato. Pero vai atopar en breve que ás veces é só moito máis rápido que facer cousas con un teclado, e, finalmente, unha máis poderosa. 

Pero é difícil argumentar que calquera cousa que fixen ata agora é todo o que poderoso, cando todo vimos a dicir é, Ola mundo. E, de feito, eu codificado a palabras Ola Mundo no meu programa. Non hai dinamismo aínda. Scratch foi unha orde de magnitude máis interesante a semana pasada. 

E así imos chegar alí. Imos dar un paso para que, forma de algunhas destas funcións. Así, non só C veñen con printf, e acios de outras funcións algúns dos cales veremos co paso do tempo, iso non acontece facelo tan fácil para a dereita fora da porta no sentido de obter a entrada do usuario. 

De feito, un dos puntos débiles de linguaxes como C, e mesmo Java e aínda os outros, é que non fai facelo doado de obter só cousas como enteiros de usuarios, ou cordas, palabras, e frases, deixar as cousas só como valores de punto ou números reais flotante con puntos decimais, e realmente números longos, como veremos en breve. Polo tanto, esta lista de funcións aquí, estes son como outras pezas do risco de puzzle que teñen pre-instalado no CS50 IDE que usaremos durante algunhas semanas como rodinhas de tipos e finalmente, leva-los fora, e buscar por baixo da capa, quizais, en como estas cousas son aplicadas. 

Pero para iso, imos realmente escribir un programa. Déixeme ir adiante agora. E eu estou indo a crear un novo arquivo premendo nesta pouco máis, e facendo clic en Novo ficheiro. 

Eu estou indo a gardar esta próxima un, como, por exemplo, string.c, porque quero xogar con cordas. E cadea C é só unha secuencia de caracteres. Entón agora imos adiante e faga o seguinte. 

Incluír estándar IO.h-- e verifícase se patrón de IO, IO significa só entrada e saída. Así, verifícase que esta liña aquí é o que son os EUA veciña de usar printf. Printf, por suposto, produce unha saída. Polo tanto, a fin de utilizar printf, verifica-se fóra ten que ter esta liña de código na parte superior do seu arquivo. 

E imos volver ao que que realmente significa antes de tempo. Acontece que en calquera programa C que eu escriba, Teño que inicia-lo con código que se parece con isto. E notará CS50 IDE, e outro desenvolvemento integrado ambientes como el, van tentar o mellor poden rematar o seu pensamento. De feito, hai un momento si desfacer o que eu fixen, eu prema Intro. 

Eu, entón, bateu rizados aberta cinta, prema Intro novamente. E rematei o meu pensamento. Ela me deu unha nova liña, recuado non menos por razóns estilísticas agradables veremos. E entón el automaticamente deume que chaveta para rematar o meu pensamento. Agora, non sempre adiviñar o que quere facer. Pero, en gran parte, fai aforrar algunhas teclas. Entón, hai pouco, nós corremos ese program-- Ola, mundo, e entón compilou, e, a continuación, el foi. Pero non hai dinamismo aquí. O que se quixésemos facer algo diferente? Ben, o que se eu quixese realmente obter unha secuencia de usuario? Vou usar unha peza do puzzle chamado precisamente isso-- obter cadea. 

Acontece que en C que, cando non quere a contribuír a unha parte do enigma, ou máis propiamente a unha función, literalmente só facer paréntese de apertura, preto parénteses. Por iso, é como se houbese ningunha caixa branca para escribir en. O bloque de dicir antes tiña unha pequena caixa branca. Non temos esa caixa branca agora. 

Pero cando eu chamo cadea get, I Quere poñer o resultado en algún lugar. Así, un paradigma moi común en C é a chamar unha función, como cadea de chegar aquí, e despois gardar o valor de retorno. É o resultado da súa esforzo en algo. 

E cal é a construír na programación, en cero ou empresa C, que pode usar para realmente gardar algo? Chamou-lle unha variable, non? E en perigo, nós realmente non importa o que estaba a ocorrer en variables. 

Pero, neste caso, nós realmente fan. Eu vou dicir cadea. E entón eu podería chamar iso o que eu queira. Vou chamalo nome, recibe obter cadea. 

E agora, aínda se está algo novo para iso, ter en conta que eu estou falta algúns detalles. Estou esquecendo un punto e coma. Necesito rematar este pensamento. Entón, eu vou ir meu cursor, e bater punto e coma alí. E o que eu fixen? Nesta liña de código, número 5, no momento, Estou chamando cadea get sen entradas. Polo tanto, non hai pouco de branco caixa como o Save bloque ten. 

Só digo, hey, ordenador, me unha corda. O signo igual non é realmente un signo igual, per se. É atribución operador, o que significa, hey, ordenador, move o valor da dereita á esquerda. E na esquerda, eu teño a seguinte. 

Hey, ordenador, dáme un string-- unha secuencia de caracteres. E chamar ese nome cadea. E eu nin sequera teñen que chamalo Name. 

Podería chamalo, convencionalmente, algo así como S, así como usamos i para chamar a variable i. Pero agora eu teño que facer algo con el. Sería moi parvo para tente compilar este código, executando este programa, aínda que Estou a recibir unha corda, porque aínda é só vai dicir Hola mundo. 

Pero e se quero cambiar isto. Por que non facelo? Percent s, coma s. E iso é algo enigmática aínda. 

Entón deixe-me facer o meu variables máis clara. Déixeme citar esta Nome variable. E imos ver se non podemos provocar ademais o que está pasando aquí. 

Entón, na liña de cinco, eu estou a recibir unha cadea. E eu estou almacenando esta secuencia, todo o que o usuario introduciu no no teclado, nunha variable chamada nome. E verifícase que printf non só recibir un argumento en dobre citas, unha entrada entre comiñas dobres. 

Pode levar dúas ou tres, ou máis, tales que o segundo, ou terceiro, ou cuarto, son todos os nomes de variables, ou valores en concreto, que pretende conectar, dinámica, esta cadea entre comiñas. Noutras palabras, o que Sería malo con iso? Se eu só dixen Ola nome, barra invertida n, salvo o meu arquivo, compilado meu código, e foi iso, o que acontecería? 

É só vai dicir, Ola citar literalmente N-A-M-E, que é unha especie de idiota, porque non é diferente do mundo. Entón, calquera cousa entre comiñas é o que, literalmente, imprimirase. Entón, se eu queira ter un espazo reservado alí, En realidade, eu teño usar algunha sintaxe especial. E resulta que se ler o documentación para a función printf, ha dicirlle que se usa por cento s, pode substituír un valor como segue. 

Tras unha vírgula despois diso comiñas dobres, simplemente escribir o nome do variable que quere para chamar a este formato código, ou especificador de formato, por cento s para cordas. E agora, se eu teño gardado o meu arquivo, Eu voltar o meu terminal. E eu tecleo Fai String, porque, unha vez máis, o nome do presente arquivo que eu escollín antes é string.c. 

Entón eu vou dicir Fai String, entrar. Oh meu Deus, ollar para todos os erros que xa fixo. E iso é-- o que, iso é realmente como un, sete programa de liña de seis? Polo tanto, este é onde pode moi rapidamente obter esmagadora. 

Esta fiestra de terminal ten agora só regurgitado un gran número de mensaxes de erro. Certamente, eu non teño máis de erro mensaxes que teño liñas de código. Entón, o que está a suceder? 

Ben, a mellor estratexia para facer en calquera momento non atopa unha esmagadora lista de erros como este, é rolar para atrás, mirar o comando que acaba de correr que no meu caso é facer cadea. Olle para o que fan que o fixo, e que é iso mando longo Clang, non é gran cousa alí. 

Pero o vermello é malo. Verde está tratando de ser amable e prestativa. Senón que é malo, nese caso. Pero onde está mal? 

String.c, liña de cinco, cinco caracteres. Polo tanto, esta é só unha convención común. Algo colon algo significa número de liña eo número de caracteres. Erro, a utilización de non declarado cadea do identificador. Penso estándar en? 

Entón, por desgraza, Clang está a tentar ser útil. Pero está mal, neste caso. Non, Clang, eu non quería dicir IO estándar. Eu quería dicir que na liña un, si. 

Pero a liña cinco é este aquí. E Clang non entender S-T-R-I-N-L. É un identificador non declarado, a palabra que nunca viu antes. E iso é porque C, a linguaxe estamos escribindo código no momento Non ten variables chamadas cordas. 

Non se trata, por defecto, o soporte algo chamado unha corda. Isto é unha peza de CS50 xerga, pero moi convencional. Pero eu podo solucionar isto como segue. 

Se eu engadir unha liña de código para o inicio do programa, inclúen CS50.h, que é outro arquivo nalgún lugar dentro CS50 IDE, nalgún lugar no disco duro, por así dicir, do sistema operativo Ubuntu que eu estou correndo, que é o ficheiro que é vai ensinar o funcionamento sistema que unha cadea é, só como io.h estándar é o arquivo no sistema operativo que é indo para ensinar-lle o que printf é. 

De feito, teriamos conseguido unha mensaxe moi semellante Se Io tiña admitido estándar Io.h e intentou utilizar printf. Entón, eu estou indo a ir adiante e só tomar control L para limpar a miña pantalla. Ou podes escribir claro e vai só limpar a fiestra de terminal. Pero aínda pode rolar de volta no tempo. 

E eu estou indo a executar de novo Fai cadea. Cruzar os dedos esta vez, Intro. Oh meu Deus, funcionou. me mostra unha orde longo críptica que é o que fan xerado vía Clang, pero ningunha mensaxe de erro. Entón entende, aínda pode estar completamente resaltado coa número de mensaxes de erro, el só podería ser esta fervenza irritante efecto, onde Clang non entende unha cousa, o que significa que, a continuación, non entende a palabra seguinte, ou a liña seguinte. E por iso só engasga co seu código. Pero a corrección pode ser simple. E por iso sempre concentrarse no primeira liña de saída. E se non o fai comprende-lo, só tes que mirar para palabras clave que pode ser pistas, eo número de liña, eo carácter, onde este erro pode ser. 

Agora, deixe-me ir adiante e escribir dot slash, corda, entrar. Hm, non está dicindo Ola nada. Por que? Ben, lembro, onde está a executar? 

Probablemente está preso no momento en un loop, se quixeren, na liña seis, porque Obter Cordas de deseño, escrito polo equipo CS50, é literalmente significa só sentir alí esperando e esperando, e á espera dunha cadea. Todo o que quere dicir con cadea de entrada humana. Entón vostede sabe o que? Déixeme ir adiante. E só por un capricho, déixeme Escribe o meu nome, David, entrar. Agora eu teño un programa máis dinámico. Dixo, Ola David. 

Se eu ir adiante e executar de novo, déixeme probar dicir o nome Zamila, entrar. E agora temos un programa dinámico. Non codificado mundo. Non codificado nome, ou David, ou Zamila. 

Agora é moito máis parecido cos programas sabemos, en que se aproveitar a entrada, produce saída lixeiramente diferente. Agora, este non é o mellor experiencia do usuario, ou UX. Executar o programa. 

Eu non sei o que eu debería a facer, a menos que realmente ollar para ou lembrar o código fonte. Entón, imos facer o usuario probar un pouco mellor coa máis simple das cousas. Déixeme volver a este programa, e simplemente dicir printf. 

E deixe-me ir adiante e dicir o nome, colon, e un espazo e, a continuación, un punto e coma. E só por diversión, sen descanso n. E iso é deliberada, porque eu non quero a solicitude para mover á seguinte liña. 

Quero, en vez diso, facelo, faga cadea recompilar o meu código nova máquina código dot cortar cadea. Ah, iso é moito máis fermosa. Agora eu realmente sei que o ordenador quere que faga, darlle un nome. 

Entón, eu estou indo a ir adiante e escribir en Rob, entrar, e Ola, Rob. Así, entender, esta aínda é, ao final do día, só un programa de nove liña. Pero tivemos estes pasos de bebé. 

Nós escribir unha liña coa que estaban familiarizados printf, Ola mundo ,. Logo desfixo algo diso. E realmente utilizados cadea get. E nós xogou ese valor nunha variable. E, a continuación, fomos adiante e mellorado aínda máis cunha terceira liña. E este proceso iterativo de escribir software é verdadeiramente clave. En CS50 e na vida en xeral, normalmente non debe sentir-se, ten un programa en mente, e tentar escribir a cousa toda dunha vez. 

Vai inevitablemente producir forma máis erros que nós mesmos vimos aquí. Mesmo eu, ata hoxe, constantemente facer outros erros estúpidos, son erros realmente máis difícil que son máis difíciles de descubrir. Pero vai cometer máis erros máis liñas de código que escribe todo dunha vez. E así esta práctica de, escribir un pouco de código que está cómodo, compilar Lo, executa-lo, proba-lo de modo máis xeral, a continuación, pasar on-- así como mantivemos capas e capas a semana pasada, construción de algo moi simple de algo máis complexo, facer o mesmo aquí. Non se sente, e tentar escribir un problema enteiro. Realmente tomar estes pasos de bebé. 

Agora, cordas non son todos tan útil para si mesmos. Teremos, en realidade, ideal, como a teñen algo máis na nosa caixa de ferramentas. Entón imos realmente facer exactamente isto. 

Déixeme ir adiante agora e látego de un programa pouco diferente. E nós imos chamar este int.c, por enteiro. Vou, do mesmo xeito, inclúen CS550.h. Eu estou indo a incluír estándar IO. E iso vai ser moi común nestes primeiros días de clase. 

E eu vou pronto -me cunha función principal. E agora en vez de comezar unha corda, imos adiante e obter un int. Imos chamalo i, e chamalo chegar int, parens próximos, punto e coma. E agora imos facer algo con el, printf. 

Imos dicir algo como Ola, barra invertida n, coma i. Entón, eu estou moi ben imitando o que eu fixen só un momento atrás. Eu teño un espazo reservado aquí. Teño coma i aquí, porque quero para conectar i en que espazo reservado. 

Entón, imos adiante e experimentar compilar este programa. O ficheiro é chamado int.c. Entón eu vou dicir, facer int, entrar. Oh meu Deus, pero non é gran cousa, non? Hai un erro. 

Hai un erro de sintaxe aquí de tal forma que o programa non pode ser compilado dentro int.c, liña sete, carácter 27, o formato de erro especifica tipo char estrela, o que quere que sexa. Pero o tipo de argumento é int. 

Entón, aquí, tamén, non imos a-- aínda que hoxe en día é unha chea de material, nós estamos indo a oprimir-lo con absolutamente todas as características do C, e programación dun xeito máis xeral, en só estas primeiras semanas. Polo tanto, hai moitas veces vai ser xerga co que non está familiarizado. E, de feito, estrela char é algo imos volver en vez de unha semana ou dúas de. 

Pero, por agora, imos ver se podemos analizar as palabras que son familiares. Formatos-- iso escoitamos formato especificador, código de formato antes. Isto é familiar. Type-- pero o argumento ten o tipo int. Agarde un minuto, i é un int. 

Quizais por cento s en realidade, ten algún significado definido. E, de feito, fai. Un enteiro, se quere printf para substituílo, realmente ten que usar un especificador de formato diferente. E non sabería que a menos que alguén lle dixo, ou fixo iso antes. Pero o que é por cento i pode ser utilizada en printf para conectar un enteiro. Tamén pode usar cento d para un número enteiro decimal. Pero é agradable e sinxela aquí. Entón, imos ir con iso. 

Agora, deixe-me ir adiante e reprise make int, Intro. Isto é bo, sen erros. Dot cortar OK int--, mala experiencia do usuario, porque eu non dixen a min mesmo que facer. Pero iso é bo. Estou pegando rapidamente. 

E agora déixeme ir adiante e escribir David, OK, Zamila, Rob. OK, entón iso é unha cousa boa. Esta vez, está a usar unha función, unha peza do puzzle, chamado Get int. E pasa out-- e nós imos ver iso máis tarde no term-- o equipo CS50 aplicou obter secuencia de tal forma que vai só fisicamente obter unha corda para ti. 

El aplicou get int en de tal forma que só pode obter un número enteiro para ti. E se, o ser humano, non cooperar, é literalmente indo só para din repetir, repetir, repetir, literalmente sentado alí looping, ata vostede obrigar con algún número máxico, como 50, e Ola 50. 

Ou se executar esta nova e escriba 42, Ola 42. E así a función get int dentro dese enigma é a lóxica suficiente, o pensamento suficiente, de descubrir, o que é unha palabra? E o que é un número? Só aceptar, en última instancia, números. 

Así, verifícase que esta Non é todo o que expresivo. moi lonxe. Entón, yay, última vez que pasou moi rápido en xogos de execución, e animación, e obras artísticas en cero. E aquí, estamos a ser contido con Ola mundo, e Ola 50. 

Non é todo o que inspirado. E, de feito, estes primeiros exemplos vai levar moito tempo a rampla ata en emoción. Pero temos moito máis controlar o momento, en realidade. E nós estamos indo moi iniciar rapidamente capas enriba destas primitivas básicas. 

Pero, primeiro, imos entender cales son as limitacións. De feito, unha das cousas Cero non é fácil imos facer é realmente ollar por baixo da capa, e entender o que é un ordenador, o que pode facer, e cales son as súas limitacións. E, de feito, que a falta de comprensión, potencialmente, a longo prazo pode levar a nosa propia escrita mistakes-- erros, escribindo software inseguro que for cortada de algunha maneira. 

Entón, imos dar algúns pasos cara a comprender isto un pouco mellor, forma de, digamos, o exemplo a seguir. Eu estou indo a ir adiante e aplicar rapidinho un programa chamado Adder. Como, imos engadir algúns números xuntos. E eu estou indo a codificar algúns cantos aquí, e simplemente copiar e pegar onde estaba antes, só para que poidamos ir máis cedo. Entón agora eu teño os principios básicos dun programa chamado Adder. 

E imos adiante e facelo. Eu estou indo a ir adiante e digamos, IntX recibe obter int. E vostede sabe o que? Imos facer unha mellor experiencia do usuario. 

Entón, imos só dicir que x é e, efectivamente, solicitar ao usuario a darnos x. E, a continuación, deixe-me ir adiante e dicir: printf como sobre y é, desta vez esperando dous valores desde o usuario. E entón imos só ir adiante e digamos, printf, a suma de x e y é. E agora eu non quero facer por cento s. Eu quero facer por cento i, barra invertida n, e logo conecte valor da suma. 

Entón, como podo facer sobre iso? Vostede sabe o que? Sei como usar variables. Déixeme só declarar unha nova, int z. 

E eu vou dar un palpite aquí. Se hai signos iguais nesta linguaxe, quizais eu só podo facer x máis y, mentres eu rematar o meu pensou cun punto e coma? Agora podo volver para acá, Póñase z, rematar este pensamento cun punto e coma. E imos ver agora, se estes secuencias de lines-- x é obter int. Y é obter int. 

Agregar x e y, almacenar o valor en z-- por iso, unha vez máis, lembre o signo igual non é igual. É atribución da dereita á esquerda. E imos imprimir que a suma de X e Y non é literalmente Z, pero o que está dentro z. Entón, imos facer Adder - agradables, sen erros nesta ocasión. Dot cortar Adder, entrar, x será 1. 

Y será 2. E a suma de x e y é 3. Entón, iso é todo moi ben e bo. 

Entón podes imaxinar que a matemática deben traballar nun programa como este. Pero vostede sabe o que? É esta variable, liña 12, aínda necesario? Non precisa adquirir o hábito de só almacenar cousas en variables só porque pode. E, de feito, é xeralmente mala concepción ponderada se está creando unha variable chamada z, neste caso, o almacenamento en algo que, e logo, inmediatamente usalo, pero nunca de novo. Por que dar algo dun nome como z, se está literalmente Vai usar este cousa só unha vez, e así proximal ao lugar onde creou Lo en primeiro lugar, tan preto en termos de liñas de código? Entón vostede sabe o que? Acontece que C é moi flexible. Se realmente quero plugin valores aquí, Non ten declarar unha nova variable. Podería só plugin x máis y porque C entende aritmética e operadores matemáticos. 

Entón, podo simplemente dicir, facer esa matemática, x máis y, o que quere que eses valores son, Conecte o resultante enteiro a esta cadea. Polo tanto, este pode ser, aínda que só unha liña máis curta, un proxecto mellor, un programa mellor, porque hai menos código, polo tanto, menos para min entender. E tamén é só máis limpo, na medida en que non estamos introdución de novas palabras, novos símbolos, como z, aínda que realmente non serven moito dun propósito. 

Desafortunadamente, a matemática non é todos os que ás veces fiables. Imos ir adiante e facelo. Eu estou indo a ir adiante agora e faga o seguinte. 

Imos facer printf, cento i, ademais de por cento i, será por cento i, barra invertida n. E eu vou facer isto-- xyx máis y. Entón eu só vou reescribir esta un pouco diferente aquí. Déixeme só facer unha comprobación de sanidade rápida. Unha vez máis, non imos estar á fronte de nós mesmos. Fai víbora, punto barra víbora. x é 1, y é 2, 1 é máis 2 3. Entón, iso é bo. Pero imos complicar iso agora un pouco, e crear un novo ficheiro. 

Vou chamar esta, dicir, ints, plural para enteiros. Déixeme comezar de onde eu era un momento atrás. Pero agora imos facer algunhas outras liñas. Deixe-me ir adiante e facer o seguinte, printf, cento i, menos por cento i, é por cento i, coma x, coma yx menos y. Entón, eu estou facendo algo matemática diferente alí. Imos facer outro. Así por cento i veces por cento i é por cento i, barra invertida n. Imos plugin x e y, e x veces y de. Imos usar o asterisco na o ordenador para veces. 

Non usa x. X é un nome de variable aquí. Usa a estrela para a multiplicación. Imos facer un. Printf por cento eu, dividido por cento i, é por cento i, n barra invertida. xy dividido por y-- para que use a barra en C para facer a división. E imos facer outro. Resto por cento i, divididos por cento i, é por cento eu. xy-- e agora resta é o que sobrou. Cando tentar dividir un denominador dentro dun numerador, como é deixar ao longo deste non podería dividir fóra? 

Non hai realmente, necesariamente, un símbolo usamos na escola por iso. Pero alí C. Pode din x modulo y, onde este signo por cento neste context-- confusa cando está dentro das comiñas dobres, dentro printf, cento é utilizado como o especificador de formato. 

Cando usa por cento fóra do en que unha expresión matemática, é o operador módulo para modular arithmetic-- para os nosos propósitos aquí, só significa, cal é a resto X dividido polo y? Así, X dividido polo y é X Y barra. Cal é o resto x dividido por y? É x y mod, como un programador diría. 

Entón, se eu non cometeu erros aquí, déixeme dalle facer ints, plural, agradable, e ints da corte do punto. E imos adiante e facer, digamos, 1, 10. Todo ben, 1, acrescido de 10 e 11, cheque. 1 menos 10 é negativo 9, confía. 

1 veces 10 é 10, cheque. 1 dividido por 10 é-- OK, imos saltar esa. Resto de 1 dividido por 10 é 1. Isto é correcto. Pero hai un erro aquí. 

Entón, o que eu poñer a miña entregar, non é correcto. Quero dicir, é próximo a 0. 1 dividido por 10, vostede sabe, se estivermos cortar algúns cantos, con certeza, é cero. Pero realmente debe ser 1/10, 0,1, ou 0,10, 0,1000, ou así por diante. 

Non debe ser realmente cero. Ben, parece que o ordenador está facendo literalmente o que dixo para facer. Estamos facendo a matemática como x dividido por y. E ambos x e y, por liñas de código anterior, son números enteiros. 

Ademais, na liña 15, que son dicindo printf, hey, printf plugin un enteiro, plugin un número enteiro, conectar un integer-- especificamente x, e, a continuación, y, e logo, x dividido por y. x e y son enteiros. Somos bos alí. 

Pero o que é x dividido por x? X dividido polo y debe ser, Matematicamente, 10/01, ou 0,1, que é un número real, un número real ter, potencialmente, un punto decimal. Non é un número enteiro. 

Pero o que é o máis próximo número enteiro de 10/01, ou 0,1? Si, tipo de é cero. 0,1 é así moito. E 1 é moi presente. Así, 1/10 está máis preto 0 que é a un. 

E entón o que C está facendo por US-- tipo de porque dixo que a-- é truncar este completo. É tomar o valor, que de novo é debería ser algo así como 0,1 mil, 0 e así por diante. E está truncando todo despois do punto decimal de xeito que todo isto material, porque non caben na noción dun enteiro, que é só un número como negativo 1, 0, 1, arriba e abaixo, el xoga fóra todo despois do punto decimal porque non pode caber nun punto decimal nun número enteiro, por definición. 

Polo tanto, a resposta aquí é cero. Entón, como podemos solucionar isto? Necesitamos unha outra solución en conxunto. E podemos facer iso, como segue. 

Deixe-me ir adiante e crear unha nova ficheiro, este chamado floats.c. E gardalo aquí no mesmo directorio, float.c. E deixe-me ir adiante e copiar algúns de que o código de antes. 

Pero en vez de estar un int, imos facelo. Dáme un valor de punto flotante chamado x. onde un punto flotante valor é só literalmente algo cun punto flotante. Pode mover-se cara á esquerda, á dereita. É un número real. 

E deixe-me chamar obter int, pero chegar float, que tamén estaba entre o menú de opcións na biblioteca C250. Imos cambiar y a unha boia. Polo tanto, este pasa a ser obter float. 

E agora, nós non queremos para conectar ints. Acontece que temos que usar cento f para float, por cento f para float, e agora salvalo. E agora, dedos cruzados, facer flotadores, agradable, flotadores da corte de punto. x será un 1. y Será 10 de novo. 

E, bo, OK miña banda é correcta. Eu estaba esperando por máis, pero eu esquezo de escribir. Entón, imos ir e corrixir este erro lóxico. 

Imos adiante e coller o seguinte. Nós imos só facer un pouco de copiar e pegar. E eu vou dicir de menos. 

E eu vou dicir veces. E eu vou dicir dividida. E eu non vou facer modulo, que non é tan pertinentes aquí, dividido por f, e veces plus-- OK, imos facelo de novo. 

Fan flotadores, boias de barra punto, e 1, 10, e- agradable, non, OK. Entón, eu son un idiota. Entón, iso é moi común en ciencia da computación cometendo erros estúpidos como este. 

Para fins pedagóxicos, o que realmente quería facer foi cambiar a ciencia aquí para máis, a menos, á época, e para dividir, como espera notado durante este exercicio. Entón agora imos volver compilar este programa, faga flotadores da corte de punto. 

E por terceira vez, imos ver se atende ás miñas expectativas. 1, 10, entrar, si, OK, 1000, dividido por 10,000, é 0,100000. E resulta que podemos controlar cantas números son despois destes puntos decimais. Nós realmente vai. Nós imos voltar a iso. 

Pero agora, de feito, a matemática é correcta. Entón, unha vez máis, que é o takeaway aquí? Acontece que en C, existen non só só strings-- e, de feito, non hai realmente, porque nós engadir aqueles coa biblioteca CS50. Pero non son só números enteiros. 

Tamén flota. E verifícase un monte de outros datos tipo tamén, que usaremos en pouco tempo. Acontece que se quere un único carácter, e non unha cadea de caracteres, pode usar só un char. 

Acontece que, se quere un bool, un valor booleano, único verdadeiro ou falso, grazas á biblioteca CS50, temos engadido a C, o tipo de datos booleano ben. Pero tamén está presente en moitas outras linguas tamén. E resulta que ás veces precisan de números grandes, a continuación, veñen por defecto con ints e Carrozas. 

E, de feito, un dobre é un número que usa nin 32 bits, pero 64 bits. E un longo tempo é un número que usa nin 32, bits, pero 64 bits, respectivamente, para punto flotante valores e enteiros, respectivamente. Entón imos realmente agora ver iso en acción. 

Eu estou indo a ir adiante aquí e látego dun navegador. Aquí, eu estou indo a ir adiante e non inclúen CS50.h. E deixe-me ir, inclúen por defecto IO.h. 

E vai notar algo funky está pasando aquí. Non é codificación de cores as cousas en do mesmo xeito como facía antes. E ao parecer, iso é porque eu non deron a cousa un nome de ficheiro. 

Vou chamar esta sizeof.c, e bateu en Gardar. E teña en conta o que pasa co meu moi código de branco contra este pano de fondo negro. Agora, polo menos hai Nalgúns roxos alí. E é sintaxe destacada. 

Isto é porque, moi simplemente, non teño dixo ao IDE que tipo de ficheiro iso é dándolle un nome, e especialmente unha extensión de arquivo. Agora, imos ir adiante e facelo. Eu estou indo a ir adiante e moi simplemente imprimir o bool following-- é por cento LU. 

Nós imos volver que en só un momento. E entón eu vou tamaño de impresión de bool. E agora, só para aforrar -me un tempo, eu son fará un todo banda deles á vez. E, especialmente, eu vou cambiar isto para un char e carbón. Este, eu vou cambiar para unha parella e unha de matrimonio. 

Este, eu vou cambiar a unha boia e un flotador. Este, eu vou cambiar a un int e un int. E este, eu vou para cambiar a un longo tempo. E aínda está tomando un longo tempo, moito tempo. 

E entón, finalmente, dei me un demasiados, corda. Acontece que en C, non hai o operador especial chamado tamaño do que é, literalmente, Vai, cando se executa, Díganos o tamaño do Cada unha destas variables. E este é un camiño, agora, podemos chamar de volta a discusión da semana pasada de datos e de representación. 

Deixe-me ir adiante e compilar tamaño tamaño de punto de corte. E veremos. Acontece que en C, especialmente en CS50 IDE, especialmente na sistema operativo Ubuntu, que é un operativo de 64 bits sistema, neste caso, un booleano vai usar un byte de espazo. É así que o tamaño é medida, non en bits, pero en bytes. E lembrar que un byte é oito bits. Así, un bool, aínda que tecnicamente só precisa dun 0 ou 1, é un pouco desperdicio como temos implantado. Realmente vai utilizar un todo byte-- para que todos os ceros, son talvez todos aqueles, ou algo así, ou só un 1 entre os oito bits. 

Un char, á súa vez, usado para un personaxe como un carácter ASCII por semana pasada será un personaxe. E que sincroniza-se coa nosa noción de sendo non máis que 256 bits-- vez, sincroniza-se con el habendo máis de 8 bits, que dános ata 256 valores. O dúo vai ser de 8 bytes ou 64 bits. 

Un flotador é 4. Un int é de 4. Un longo, longo é 8. E unha corda é 8. Pero non se preocupe con iso. Nós imos pelar esa capa. Acontece que, cordas poden ter máis de 8 bytes. 

E, de feito, escribimos cordas xa, Ola mundo, máis de 8 bytes. Pero imos voltar a que en só un momento. Pero a toma de distancia aquí é o seguinte. 

Calquera ordenador só ten unha finita cantidade de memoria e espazo. Só podes gardar tantos ficheiros no seu Mac ou PC. Só podes gardar tantos programas RAM funcionando á vez, necesariamente, mesmo coa memoria virtual, porque ten unha cantidade finita de RAM. 

E só para picture-- se nunca abriu un portátil ou encomendados memoria extra para un ordenador, Pode non saber que dentro do seu ordenador é algo que se parece algo como isto. Polo tanto, esta é só unha empresa común denominado Crucial que fai RAM para ordenadores. E RAM é onde os programas vivir mentres eles están executando. 

Así, en todos os Mac ou PC, cando dobrar clic nun programa, e abre, e abre un documento de Word ou algo así, almacena-o temporal na RAM, RAM porque é máis rápido que o seu disco duro, ou o disco de estado sólido. Entón é só onde os programas ir para vivir cando están en execución, ou cando os ficheiros están a ser empregados. 

Entón tes cousas que parecen como este no seu portátil, ou cousas un pouco máis grande dentro da súa área de traballo. Pero a clave é que só ten un número finito destas cousas. E só hai unha cantidade finita de hardware sentado nesa mesa dereita aquí. 

Entón, por suposto, non podemos almacenar números infinitamente longos. E, ademais, se pensas que volta a escola, cantos díxitos pode tes á dereita dun punto decimal? A esta materia, cantos díxitos poden tes á esquerda do punto decimal? Realmente, infinitamente moitos. 

Agora, nós, seres humanos só podería sabe como se pronuncia millóns, e millóns, billóns, e quatrilhões, e quintilhões. E eu estou empurrando os límites do meu understanding-- ou meu-- entendo números, pero o meu pronuncia dos números. Pero poden obter infinitamente grande, con infinitos díxitos á esquerda ou á dereita dun punto decimal. 

Pero os ordenadores teñen só un cantidade finita de memoria, un número finito de transistores, un número finito de lámpadas no interior. Entón, o que ocorre cando executar para fóra do espazo? Noutras palabras, se pensar cara atrás a semana pasada cando falamos números -Se a ser representado en binario, supoñamos que temos este valor de 8 bits aquí. 

E nós temos sete 1 e un 0. E supoña que queremos para engadir 1 a este valor. Este é un número moi grande agora. 

Este é 254, se ben me lembra a matemática da semana pasada dereita. Pero o que se eu cambiar 0 que máis á dereita dun 1? O número enteiro, de Por suposto, se converte oito 1s. Polo tanto, aínda é bo. 

E que probablemente representa 255, aínda que dependendo do contexto podería realmente representar un número negativo. Pero máis sobre iso de novo. Este parece que é tan alto como podo contar. 

Agora é só 8 bits. E o meu Mac, con certeza, ten forma máis de 8 bits de memoria. Pero ten finito. Así, o mesmo argumento aplícase, aínda que temos máis destes queridos na pantalla. 

Pero o que acontece se está almacenar este número, 255, e quere contar un pouco máis alto? Queres ir de 255 a 256. O problema, por suposto, é que se comezar a contar desde cero como a semana pasada, non pode contar como alto como 256, moito menos 257, moito menos 258, m porque o que ocorre cando engade un 1? Se fai a escola primaria antiga visión, pór un 1 aquí, e logo, 1 máis 1 e 2, pero iso é realmente un cero, leva a 1, transportar a 1, levar a 1. Todas estas cousas, Estas 1, ir a cero. E acabar, si, como alguén apuntou, a 1 sobre o lado esquerdo. Pero todo o que poida realmente ver e caber na memoria é só oito 0 do, o que quere dicir nalgún momento, se, un ordenador, intentou conta alta abondo, está vai implicar en torno a, ao parecer, a cero, ou quizais mesmo negativo números, que son aínda máis baixos que cero. 

E pode tipo de ver iso. Deixe-me ir adiante e escribir un verdadeiro programa rápido aquí. Deixe-me ir adiante e escribir un programa chamado estourido. Incluír CS50.h, inclúen estándar IO.h-- oh, Realmente perdín o meu destaque de sintaxe. Entón, imos gardalo como overflow.c. 

E void-- principal agora int e en pouco tempo, imos volver explicar por que nós seguir a escribir void main int. Pero, polo de agora, imos só facer Lo, leva-lo para concedida. Imos dar-me un int, e Inicialize-o a 0. 

Imos entón facer por int i obter zero-- en realidade, imos facer un loop infinito e ver que pasa. Mentres verdade, entón imos imprimir n é por cento i, barra invertida n, plugin n. Pero, agora, imos facer n recibe n + 1. 

Polo tanto, noutras palabras, en cada iteración deste ciclo infinito, imos dar o valor de n, e engadir 1 a el, e, a continuación, almacenar o resultado en N na esquerda. E, de feito, xa vimos a sintaxe algo como este, brevemente. Un truco legal é, en vez de escribir todo isto, realmente pode dicir un n máis é igual a 1. 

Ou se o quere ser extravagante, pode dicir n plus plus e coma. Pero estes dous últimos son só o que chamaría de azucre sintático para o primeiro. 

O primeiro é máis explícito, totalmente ben, totalmente correcta. Pero iso é máis común, eu vou dicir. Entón, imos facelo por só un momento. 

Imos agora facer estourido, o que soa moi sinistro, estourido de corte de punto. Imos ver, n está quedando moi grande. Pero imos pensar, o no; gran pode n recibir? 

n é un número enteiro. Vimos hai pouco co tamaño do exemplo, que é un int catro bytes. Sabemos da semana pasada, catro bytes é 32 bits, xa 8 veces 4, que ten 32 anos. Isto vai ser de 4 millóns. 

E somos ata 800.000. Isto vai levar unha eternidade para contar tan alto como poida. Entón, eu estou indo para adiante, como pode en pouco tempo, e bateu C-- Control francamente, Control C, unha morea, onde Control C xeral medios cancelar. Desafortunadamente, porque este está a ser executado na nube, por veces, a nube é cuspindo tanta cousa, tanta saída, que vai levar un pouco para a miña entrada para chegar á nube. Así, aínda que eu bati Control C uns segundos atrás, este é sempre o lado efecto dun loop infinito. 

E así, en tales casos, estamos vai deixar que sexa. E nós estamos indo para engadir outro fiestra de terminal aquí co plus, que naturalmente non fai así, xa que aínda está a pensar. E imos adiante e ser algo máis razoable. 

Eu estou indo a ir adiante e facer esta única un número finito de veces. Imos usar un loop for, que aludi anteriormente. Imos facelo. Déame outra variable int i recibe 0. i é menor que, digamos, 64 i ++. E agora déixeme ir adiante e de impresión a n é por cento i, coma n. E entón n-- este aínda é vai levar para sempre. Imos facelo. 

n recibe n veces 2. Ou poderiamos ser extravagante e facer veces é igual a 2. Pero imos só dicir que n iguala-se, 2 veces. Noutras palabras, o presente nova versión do programa, Non quero esperar para sempre de como 800.000 para 4 millóns. Nós só acabar con iso. 

Imos realmente dobrar n cada vez. Que, recall, duplicación é a contrario de ter, por suposto. E que a semana pasada temos algo máis dunha vez, e de novo, e, de novo, super rápido, duplicación certamente levar de 1 a maior posible valor que podemos contar ata con un int. 

Entón, imos facer exactamente isto. E nós imos voltar a este antes de tempo. Pero iso, de novo, é como o bloque de repetición en perigo. E vai usar este antes de tempo. 

Isto só significa conta de cero ata, pero non igual, a 64. E en cada iteración deste loop, só manter incrementando i. Entón i ++ - e esta construción xeral na liña 7 é só un xeito super común repetir algunhas liñas de código, un certo número de veces. Cales liñas de código? Estas claves, como Pode ter adquirido a partir de agora, significa, faga o seguinte. 

É dentro como cero, cando ten os bloques amarelos e outras cores que tipo de abrazar ou abrazar outros bloques. Iso é o que estes rizado cintas están facendo aquí. Entón, se eu teño o meu sintaxe direita-- vostede Pode ver o símbolo de cenoria no medio C iso é cantas veces eu estaba intentando solucionar este problema. Entón, imos librar-se de que un por completo, e pecha a fiestra. E nós imos usar o novo. Fai estourido, Slash dot estourido, Intro, todo ben, parece mal no comezo. Pero imos rolar para atrás no tempo, porque eu fixen iso 64 veces. 

E observar por primeira vez, n é 1. Segundo tempo, o símbolo n representa 2, logo, 4, despois 8, entón con 16 anos. E parece que así Chegar a preto de 1 mil millóns, se eu dobre-la de novo, que debería darme 2 millóns. Pero acontece, é dereito na cúspide. 

E así el realmente reborda un enteiro de 1 billón a preto de 2 negativo millóns, porque un número enteiro, ao contrario do que números foron asumindo a semana pasada, pode ser tanto positivo como negativo en realidade, e nun ordenador. E así, polo menos, un destes bits é eficaz roubado. Entón, nós realmente só ten 31 bits, ou 2 mil millóns de valores. 

Pero, por agora, o takeaway é moi simplemente, calquera que sexan estes números son e todo o que a matemática é, algo malo acontece, finalmente, porque finalmente estás permutar os bits dun miúdo. E efectivamente ir de todo 1 de quizais para todo 0 do, ou que só algún outro estándar que Claramente, dependendo do contexto, pode ser interpretado como un número negativo. E así parece o máis alto I pode contar neste programa específico é só a preto de 1 mil millóns. Pero hai unha solución parcial aquí. Vostede sabe o que? 

Déixeme cambiar a partir dun int para un longo tempo. E deixe-me ir adiante aquí e dizer-- eu vou ter para cambiar isto para un sen sinatura longo. Ou, imos ver, eu nunca me lembrar. 

Imos adiante e facer rebosar. Non, non é iso, LLD, grazas. Entón, ás veces Clang pode ser útil. Eu non me lembro o que o formato especificador foi por moito tempo. 

Pero, en realidade, Clang díxome. O verde é unha especie de bo, aínda significa que cometeu un erro. É supoñendo que eu quería dicir LLD. 

Entón deixe-me leva-la é un consello, un longo longa número decimal, gardar isto. E déixeme executa-lo de novo, dot cortar exceso, Intro. E agora o que é legal é iso. 

Se eu rolar para atrás no tempo, aínda comezar contando ao mesmo Place-- 1, 2, 4, 8, 16. Aviso, temos todo o camiño ata 1 billón. Pero, entón, chegar con seguridade ao 2 millóns. 

Entón comezamos a 4 millóns, logo 8 millóns, 17 millóns. E nós ir máis alto, e maior, e máis altos. Finalmente, tanto, tamén, saltos. 

Finalmente, con un longo tempo, que é o valor de 64 bits, non un valor de 32 bits, se contar moi alto, participa en torno a 0. E neste caso, nós pasar acabar con un número negativo. 

Polo tanto, este é un problema. E verifícase que este problema non é todo o que arcano. Aínda que eu teña deliberadamente inducida con estes erros, verifícase se vemos que tipo de todo nós, ou polo menos algúns de nós en torno a facer. 

Así, en Lego Star Wars, se xa xogou o xogo, verifícase que pode ir ao redor rompendo as cousas no mundo LEGO, e recollida de moedas, esencialmente. E se nunca xogou este xogo xeito moito tempo, como este individuo non identificado aquí fixeron, o número total de moedas que pode recoller é, ao parecer, 4 millóns. 

Agora, con el é realmente redondeados. Entón LEGO estaba tentando manter as cousas agradable. Non facelo exactamente 2 a a 32 de alimentación, por semana pasada. Pero 4 millóns é unha razón. Parece, con base nesas informacións, que LEGO, ea empresa que fixo este software real, decidiu que o número máximo de moedas o usuario pode acumular é, en realidade, 4 millóns, porque escolleron o seu código usar non moito tempo, ao parecer, pero só un enteiro, un sen sinatura enteiro, só a un número enteiro positivo, cuxa valor máximo aproximadamente iso. Ben, aquí está un divertido. Así, no xogo Civilization, que algúns de vostedes poden estar familiarizados coa verifícase que anos atrás non era un erro neste partido no que se desempeñou o papel de Gandhi no xogo, no canto de que sexa moi pacifista, no seu lugar foi incrible, incrible agresivo, nalgunhas circunstancias. En particular, a forma que a civilización obras é que se o xogador, adoptar a democracia, o puntuación de agresividade queda diminuíu en dous, de xeito menos menos, e despois de menos de menos. 

Entón restar 2 súa iteración actual. Desafortunadamente, a súa iteración é inicialmente 1, e restar 2 a partir del despois de adoptar a democracia como Gandhi aquí pode ter feito, porque era moi passive-- 1 na escala de agresividade. Pero se adopta a democracia, a continuación, vai de 1 a 1 negativo. 

Desafortunadamente, eles eran usando números non asinados, o que significa que eles trataron mesmo negativo números como se fosen positivos. E verifícase que o equivalente positivo do negativo 1, en programas de ordenador típicos, é de 255. Entón, se Gandhi adopta democracia e, polo tanto, ten súa puntuación agresividade diminuíu, realmente rula ao redor de 255 e faino o máis carácter agresivo no xogo. Entón podes Google-se sobre este asunto. E foi, de feito, unha erro de programación accidental, pero iso entrou moi a tradición desde entón. 

Isto é todo o desfrute e bonito. Máis asustado é cando real dispositivos do mundo real, e non xogos, ter eses mesmos erros. De feito, só un ano, un artigo veu -se sobre o Boeing 787 Dreamliner. 

E o artigo en primeiro ollar le algo misterioso. Pero dito isto, un programa vulnerabilidade no Boeing novo 787 Dreamliner chorro ten o potencial de causar pilotos perder o control de da aeronave, finalmente a mediados de voo, os funcionarios da FAA compañías aéreas advertiu recentemente. Foi a determinación que un modelo 787 avión que foi alimentado continuamente durante 248 días Pode perder toda a corrente alterna, AC, enerxía eléctrica debido ao xerador unidades de control, GCUs, simultaneamente indo para deixar modo de seguridade. É unha especie de me perder. Pero o memorando afirmou, OK, agora eu teño que, a condición foi causado por un programa contador interno para o control do xerador unidades que vai rebosar despois 248 días de potencia continua. Estamos a emisión do presente aviso para evitar a perda de todos AC eléctricos poder, o que podería resultar perda de control do avión. 

Así, literalmente, existe algún enteiro, ou algún tipo de datos equivalente, sendo utilizado en software nun avión real que se manter o seu avión en tempo suficiente, o que, ao parecer, pode ser o caso se está só a executar Los constantemente e nunca apagar o avión, ao parecer, é deixando as súas baterías morrer, acabará contar-se, e para arriba, e cara arriba, e para arriba, e para arriba, e cara arriba. 

E, por natureza, un cantidade finita de memoria transbordára, rolando ao cero ou algún valor negativo, efectos secundarios das cales é a realidade assustadoramente reais que o avión pode ter de reiniciar, efectivamente, ou pode caer, peor, como voa. Entón, eses tipos de problemas aínda están entre nós, even-- este foi un artigo de 2015, todo o máis asustado cando non fai necesariamente entender, apreciar, é anticipar estes tipos de erros. 

Non é que hai outra algo malo sobre representación de datos. Acontece que mesmo os coches alegóricos son tipo de fallo, porque flotadores, tamén, Propuxen son 32 bits, ou quizais 64 se usa unha parella. Pero iso aínda é finito. 

E o problema é que se poida poñer un número infinito de números despois do punto decimal, non hai ningunha maneira que Pode representar as posibles números que foron ensino no grao escola pode existir no mundo. Un ordenador, esencialmente, ten a escoller un subconxunto destes números para representar con precisión. 

Agora, o ordenador pode rolda quizais un pouco, e pode permitir-lle uns tenda calquera número que pode querer. Pero só intuitivamente, se teñen un número finito de bits, só se pode permutar a eles en tantas formas finitas. Entón non pode posiblemente teñen un número finito de intercambio de bits, patróns de ceros e uns, para representar un infinito número de números, o que suxire que computadores poden moi ben ser mentindo para nós ás veces. 

De feito, imos facelo. Déixeme volver IDE CS50. Deixe-me ir adiante e crear un programiña chamada imprecisión, para amosar que os ordenadores son, de feito, imprecisa. 

E deixe-me ir adiante e comezar algúns de que o código de antes, e agora pode facer o seguinte. Deixe-me ir adiante e facer printf, cento f, barra invertida n, 1 dividido por 10. Noutras palabras, imos mergullar no máis profundo a 1/10, como 1 e dividida por 10. Certamente, un ordenador pode representar 1/10. 

Entón, imos adiante e facer imprecisión. Vexamos. Format especifica o tipo de matrimonio. Pero o argumento ten o tipo int. Que está pasando? 

Oh, interesante, polo que é unha lección aprendida de antes. Eu digo, hey, feira de informática me un flotador con cento f. Pero eu estou dándolle 2 ints. Así, ao parecer, podo solucionar isto nun par de formas. 

Podería simplemente transformar un 1.0, e 10 para 10,0, o que, de feito, ten o efecto de converter Los en floats-- aínda espero o mesmo número. Ou se ve que hai algo veremos de novo en pouco tempo. Podería publicar os números. 

Pode, usando este parénteses expresión, pode dicir, hey, ordenador, aproveitar esta 10, que sei que é un int. Pero trata-lo, por favor, como se fose unha boia. Pero iso parece innecesarios complexa. 

Para os nosos propósitos hoxe, imos só literalmente facelos valores de punto flotante cun punto decimal, como este. Deixe-me ir adiante e volva executar, faga imprecisión, bo, barra dot imprecisión, entrar. OK, nós estamos mirando bo. 

1 dividida por 10, segundo o meu Mac aquí, é, de feito, 0,100 mil. Agora, eu fun ensina na escola hai debe ser un número infinito de 0 do. Entón, imos polo menos tentar para ver algunhas delas. Acontece que printf é algo aínda máis extravagante que temos benvida a empregar. Acontece que non ten que especificar simplemente por cento f, ou simplemente por cento i. Realmente pode especificar algunhas opcións de control aquí. 

En concreto, eu estou indo para dicir, hey, printf, realmente amosar-me 10 puntos decimais. Polo tanto, parece un pouco raro. Pero di por cento, punto, cantos números quere ver tralo punto decimal e logo f para plana, só porque é o que di a documentación. Deixe-me ir adiante e gardar ese. 

E teña en conta tamén, eu estou a recibir canso de ter que redigitar as cousas. Entón, eu estou só definir o para arriba e frecha para abaixo en miñas claves aquí. E se eu mantéñome bater-se, Pode ver todos os comandos que eu fixen, ou feita de forma incorrecta. 

E eu estou indo a ir adiante agora e Non realmente usar que, ao parecer. Fai imprecisión, dot cortar imprecision-- así o que se ensina na escola primaria confire. Aínda que eu imprimir lo a 10 decimal pon, de feito, é 0,10000. Pero vostede sabe o que? 

Imos estar un pouco ganancioso. Digamos que, como, mostre-me 55 puntos tras o decimal. Imos realmente tomar esta programar para dar unha volta. Déixeme refacelo lo co make imprecisión, barra punto, imprecisión. 

E aquí imos nós. A súa infancia foi unha mentira. Ao parecer, 1 dividido por 10 é efectivamente 0.100000000000000005551115123-- 

Que pasa? Ben, ao parecer, se tipo de mirar lonxe o suficiente na subxacente representación do presente número, realmente Non é exactamente 10/01, ou 0,1 e un número infinito de ceros. Agora, por que isto? 

Ben, aínda que esta é unha simple número para nós seres humanos, 1 dividido por 10, aínda é un dos infinitos números que poderiamos imaxinar. Pero un ordenador só pode representar un número finito de números así. E así, de forma eficaz, o que o ordenador está nos amosando é o seu máis próximo aproximación ao número queremos crer é 1/10, ou realmente 0,10000 ad infinitum. 

Pola contra, porén, este é tan preto que pode chegar. E, de feito, se ollar por baixo da capa, como estamos aquí examinando 55 díxitos tras o decimal, realmente vemos que a realidade. Agora, como un aparte, se ten Xa viu o movie-- a maioría de vostedes probablemente haven't-- pero Superman 3 hai uns anos, Richard Pryor esencialmente panca este realidade na súa empresa para roubar unha morea de fraccións e as fraccións de centavos, porque o company-- se ben me lembra, foi un while-- era esencialmente xogando fóra todo o que non se encaixa na noción de centavos. 

Pero se sumar todos estes minúsculos, minúsculo, minúsculos números unha vez máis, e de novo, e de novo, pode, como en seu caso, facer unha boa cantidade de diñeiro. 

Esa mesma idea foi roubado por unha última, senón que agora máis vellos película, chamado Office Space, onde os mozos que a película, fixo o mesmo, estraguei todo completo, acabou coa forma demasiado diñeiro da súa conta bancaria. Foi todo moi sospeitoso. Con todo, ao final do día, imprecisión está ao noso arredor. 

E que, ademais, se pode assustadoramente o caso. Acontece que Superman 3 e espazo de oficinas de lado, hai Pode haber algún moi real ramificacións mundiais das realidades da imprecisa representación de datos que mesmo nós, humanos, a este día non necesariamente entender así como deberiamos, ou lembrar tan frecuentemente como debería. E, de feito, o clip seguinte Bótalle un ollo a algúns mundo moi real ramificacións do que pasa se non aprecian a imprecisión que pode ocorrer en números representación. 

[Reprodución de vídeo] 

-Computadores, Todos temos que chegou a aceptar os problemas que moitas veces frustrante ir con eles-- erros, virus, e fallos de software, para pequenos prezos a pagar para o barrio. Pero, en alta tecnoloxía e alta velocidade aplicacións do programa espacial e militares, menor problema pode ser ampliada para o desastre. 

O 04 de xuño de 1996, os científicos preparados para lanzar un non tripulado Ariane 5 foguete. Estaba cargando científica satélites deseñados para establecer con precisión o xeito no que o interactúa campo magnético da Terra con ventos solares. O foguete foi construído para a Axencia Espacial Europea, e despegou da súa instalación na costa de Güiana Francesa. 

-No Uns 37 segundos para o voo, eles primeiro notado que algo estaba a suceder de malo. Os picos foron xirando en un xeito que non debería. Uns 40 segundos de voo, claramente, o vehículo estaba en apuros. 

E iso é cando fixeron a decisión de destruír-lo. O oficial de seguridade gama, con tremenda coraxe, apertou o botón, estoupou o foguete, antes de que puidese facer un perigo para a seguridade pública. 

-Este Foi o de solteira viaxe do Ariane 5. E a súa destrución levou poñer debido a un fallo embutido no programa do foguete. -O Problema no Ariane foi que había un número que 64 bits requirido para expresar. E eles querían converter Lo a un número de 16 bits. Eles asumiron que o número nunca ía de ser moi grande, que a maior parte dos díxitos do número de 64 bits foron ceros. Estaban equivocados. 

-O Incapacidade dun programa de software para aceptar o tipo de número xerado pola outra estaba na orixe do fallo. desenvolvemento de software tornouse un parte moi cara de nova tecnoloxía. O foguete Ariane foron moi exitoso, tanto do software creado por iso tamén se usado no Ariane 5. 

-O Problema básico era que a Ariane 5 foi máis rápido, máis rápido acelerada. E o software non que representaron. 

-A Destrución do foguete foi un enorme desastre financeiro, todo debido a un erro de software minuto. Pero este non foi o primeiro problemas de conversión de datos de tempos había atormentado a tecnoloxía de foguetes moderna. 

-En 1991, co inicio da primeira Guerra do Golfo, o Patriot Missile experimentaron un tipo similar do problema de conversión de número. E, como resultado, 28 persoas, 28 soldados norteamericanos, morreron, e preto de 100 resultaron feridas, cando o Patriot, que debería para protexer contra scuds recibidas, non puido disparar un mísil. 

-Cando Iraq invadiu Kuwait, e América lanzou Desert Storm a principios de 1991, baterías de mísiles Patriot foron implantados para protexer a Arabia Saudita e Israel de ataques de mísiles Scud iraquís. O Patriot é un medio alcance US superficie de sistema de aire, fabricado pola empresa Raytheon. 

-O Tamaño do interceptor Patriot en si é de aproximadamente uns 20 pés de longo. E pesa uns 2.000 quilos. E leva unha ogiva de preto, Creo que é máis ou menos 150 libras. E é o propio ogiva un elevado explosivo, que ten fragmentos en torno a el. O invólucro de ogiva é deseñado para actuar como chumbo groso. 

-As Mísiles realízanse catro por recipiente, e son transportados por un semi-remolque. 

-O Sistema Patriot anti-mísil remonta polo menos 20 anos. Foi orixinalmente deseñado como un mísil de defensa aérea para abater avións inimigos. Na primeira Guerra do Golfo, cando a guerra chegou, Exército quería usalo para abater scuds, non avións. 

A Forza Aérea iraquí foi non tanto dun problema. Pero o Exército estaba preocupado scuds. E así intentaron actualizar o Patriot. 

-Intercepting Un inimigo mísil viaxando a Mach 5 ía ser moi difícil. Pero cando o Patriot foi levado ás présas en servizo, o Exército non estaba ao tanto dun modificación iraquí que fixo seus scuds case imposible de bater. 

-O Que pasou é que scuds estaban chegando eran inestables. Estaban bailando. A razón para iso era os iraquís, a fin para 600 quilómetros fóra dun 300 km alcance dos mísiles, tomou peso fóra da ogiva fronte. Fixeron a ogiva máis lixeiro. 

Polo tanto, agora o Patriot é tentar chegar ao Scud. E a maior parte do tempo, o esmagadora maioría do tempo, sería só voar pola Scuderia. Xa que os operadores do sistema Patriot entender que o Patriot errou o seu obxectivo, eles detonaron ogiva do Patriot para evitar posibles accidentes se Deixouse caer ao chan. 

-Iso Era o que a maioría da xente viu, eses grandes bolas de lume no ceo, e mal interpretado como intercepta de oxivas Scud. 

-aínda Na noite ceos, Patriots apareceu para ser correctamente destruíndo Scuds, en Dhahran, pode haber ningún erro sobre o seu funcionamento. Alí, sistema de radar do Patriot perdeu a noción dun Scud entrada, e nunca lanzado debido a un fallo de software. Foron os israelís que descuberto por primeira vez que canto máis tempo o sistema foi ligado, canto maior sexa o tempo de discrepancia tornouse, debido a un reloxo incorporado no ordenador do sistema. 

-Cerca A dúas semanas antes a traxedia en Dhahran, os israelís informar para o Departamento de Defensa que o sistema estaba perdendo tempo. Despois de preto de oito horas ou en execución, eles notaron que o sistema estaba facendo visiblemente menos precisas. O Departamento de Defensa respondeu contando todas as baterías Patriot para non deixar os sistemas por un longo período de tempo. Nunca dixeron que un longo tempo foi-- oito horas, 10 horas, 1.000 horas. Ninguén sabía. 

-A Batería Patriot estacionados no cuartel en Dhahran ea súa falla interna reloxo fora en máis de 100 horas na noite do 25 de febreiro. 

-É Monitor o tempo con precisión de aproximadamente un décimo de segundo. Agora, unha décima de segundo é un número interesante, por que non pode ser expresada en binario exactamente, o que significa que non pode ser expresado exactamente en calquera ordenador dixital moderno. É difícil de crer. 

Pero usar isto como un exemplo. Imos dar o número de un terzo. Un terceiro non pode ser expresada en decimal exactamente. Un terzo é 0,333 pasando para o infinito. 

Non hai ningunha forma de facelo con a precisión absoluta en decimal. Ese é o tipo de problema que pasou o Patriot. Canto máis tempo o sistema funcionou, o peor o erro de tempo se fixo. 

-Despois De 100 horas de funcionamento, o erro no tempo foi só preto dun terzo dun segundo. Pero en termos de como obxectivo un mísil viaxando a Mach 5, deu lugar a un seguimento de erro de máis de 600 metros. Sería un erro grave para os soldados do que aconteceu é o lanzamento dun Scud foi detectados por satélites de alerta precoz e eles sabían que o Scud foi está na súa dirección xeral. Eles non sabían de onde viña. 

-Foi Agora á radar compoñente do sistema Patriota defendendo Dhahran para localizar e manter Ruta do mísil inimigo de entrada. 

-O Radar era moi intelixente. Sería, de feito, visite a posición do Scud, e logo, prever onde probablemente sería a próxima vez que o radar enviado Un pulso para fóra. Que foi chamado un portón de gama. 

-Entón, Xa que o Patriot decide tempo suficiente ten pasado para volver e comprobar a próxima situación para este obxecto detectado, vai volver. Así, cando se volveu para o mal lugar, a continuación, ve ningún obxecto. E decide que non houbo obxecto, foi unha falsa detección, e deixa a pista. 

-O Scud entrada desapareceu da pantalla do radar. E segundos despois, chocou contra o cuartel. O Scud matou 28, e foi a última un disparou durante a primeira Guerra do Golfo. 

Traxicamente, o software actualizado Dhahran chegou o día seguinte. O fallo de software tivo foi fixada, o peche un capítulo na conturbada historia do mísil Patriot. 

[Reprodución de vídeo] DAVID J. Malan: Entón, iso é todo para din que estas cuestións de estourido e imprecisión son moi reais. Entón, como chegamos aquí? Comezamos con só fala de printf. Unha vez máis, esta función que imprime algo para a pantalla, e nós introducidas posteriormente algunhas outras funcións desde o chamado biblioteca CS50. E nós imos seguir vexa estes en debido tempo. E nós, en particular, usado cadea get, e obter int, e agora tamén terá float, e aínda outros aínda atoparemos e utilizar connosco antes de tempo. 

Pero de cando en vez, ten visto que xa unha necesidade para almacenar o que estas funcións man cara atrás? Eles nos tras unha cadea de man, ou un int ou float. E ás veces hai que poñer que cadea, ou int ou float, en algún lugar. 

E para almacenar estas cousas, lembre-se só como en perigo, temos variables. Pero a diferenza de risco, C temos tipos reais de datos variables-- tipo, máis generally-- entre eles, unha corda, un int, un flotar, e eses outros aínda. 

E por iso, cando declara variables en C, imos ter que declarar os nosos tipos de datos. Isto non é algo que imos Ten que facer máis tarde no semestre A medida que a transición a outras linguas. Pero, por agora, necesitamos para a priori antes, explicar ao ordenador que tipo da variable que queremos dar. 

Agora, con todo, para imprimir estes tipos de tipos de datos, debemos dicir printf o que esperar. E vimos por cento s para cordas, e cento i para enteiros, e algúns outros xa. E estes son só requisitos para a presentación visual desas informacións. 

E cada un destes pode ser realmente parametrizada ou revolto, dalgún xeito, se quere promover o control o tipo de saída que comeza. E, de feito, parece que non só hai barra invertida n para unha nova liña. Hai unha cousa chamada barra invertida r para un retorno de coche, o que é máis semellante a un Máquina de escribir vella escola, e tamén o Windows usado por moitos anos. 

Hai barra invertida ta guías. Acontece que, que se quere comiñas dentro dunha cadea, Lembre que usamos dobre comiñas Cita á esquerda e á dereita acaba de nosas cordas ata agora. Isto parece confundir as cousas. 

Se queres poñer un aspa en no medio dunha string-- e, en realidade, é confuso para ver. E entón ten que escapar, por así falar, unha aspa con algo como literalmente barra invertida comiñas dobres. E hai algunhas outras aínda. E veremos máis destes no uso real en pouco tempo. 

Entón, imos agora a transición de datos e de representación, e operadores aritméticos, todo dos cales nos deu algún edificio bloques que a desempeñar. Pero agora imos realmente dar -Nos resto do vocabulario que xa a semana pasada co Scratch dando un ollo a algún outro construcións en C-- non todas elas. Pero as ideas que estamos a piques de ver realmente só salientar a tradución do unha lingua, risco, a outro, C. 

E co paso do tempo, imos incorporarse máis ferramentas para a nosa caixa de ferramentas, por así dicir, sintaticamente. E, de feito, podes ver que as ideas agora son moi familiares da semana pasada. Entón, imos facelo. 

Imos adiante e látego dun programa que realmente usa algunhas expresións, unha expresión booleana. Déixeme ir adiante aquí e crear un novo ficheiro. Vou chamar este condition.c. 

Deixe-me ir adiante e inclúen a biblioteca CS50. E deixe-me ir adiante e inclúen estándar io.h ás nosas funcións, e printf, e máis, respectivamente. Deixe-me dar a min mesmo que cliché de void main int, cuxa explicación que vai volver no futuro. 

Agora, deixe-me ir adiante e dar me un int vía get int. Entón deixe-me ir adiante e facelo. Quero dicir, se eu é less-- imos distinguir entre positivo, negativo, ou valores iguais a cero. 

Entón, se eu for menor que cero, déixeme só ten este programa simplemente dicir: negativo, barra invertida n, outra i é maior que cero. Agora eu estou, por suposto, vai dicir printf positivo, barra invertida n. E entón algo se-- eu podería facelo. 

Podería facer se eu for igual a 0. Pero eu estaría facendo en menos un erro xa. Lembre que o signo de igualdade é non é igual, como nós, seres humanos saben diso. 

Pero é o operador de asignación. E nós non queremos tomar 0 no dereita e poñelas i á esquerda. Entón, para evitar esta confusión, ou quizais uso indebido do signo igual, os seres humanos decidiron hai uns anos que en moitas linguaxes de programación cando quere comprobar a igualdade entre a esquerda ea dereita, realmente usa é igual iguais. Entón bate o signo igual dúas veces. Cando quere asignar a partir da dereita á esquerda, usa un único signo igual. Para que puidésemos facer outra cousa isto-- i é igual a cero. 

Podería, entón, ir e abrir os chaves, e dicir: printf 0, barra invertida n, feito. Pero lembre-se como estes garfos na estrada pode funcionar. E, realmente, só pensar sobre a lóxica. i é un número. É un enteiro, especialmente. E isto significa que vai ser menos que 0, ou maior que 0, ou 0. Polo tanto, non é unha especie de agasallo caso estándar implícito. 

E así poderiamos, así como Cero, dispensar o else if, e só dicir outra cousa. Loxicamente, o programador sabe que só hai tres baldes na cal un escenario pode fall-- o primeiro, o segundo, ou terceiro neste case-- non molesta engadindo a precisión adicional ea lóxica adicional alí. Só tes que ir adiante coa caso estándar aquí doutra persoa. 

Agora, imos adiante despois de gardar tanto, asegúrese condicións dot cortar conditions-- non unha gran interface de usuario, porque eu non estou levando o usuario, como mencionei anteriormente. Pero iso é bo. Imos mantelo simple. Tentaremos número 42. E iso é positivo. Tentaremos número negativo 42, negativa. 

Tentaremos valor 0. E, de feito, funciona. Agora, podes ver con problemas antes longos e probar as cousas tres veces, probablemente insuficiente. Probablemente vai querer probar algúns números grandes, algúns menores números, nalgúns casos de canto, como nós imos chegar a describilos-los. 

Pero, por agora, esta é unha programa moi sinxelo. E eu estou seguro que, loxicamente, que se divide en tres casos. E, de feito, aínda que só incidir sobre os potenciais inconvenientes de imprecisión e inundará, en realidade onde moitos dos problemas do CS50, Non imos preocuparnos sobre, todo o tempo, estes problemas de estourido e imprecisión, porque, en realidade, en C, non é realmente todo o que doado de evitar isto. Se desexa contar-se maior, e máis, e máis, resulta que existen técnicas que Pode usar a miúdo inclúen cousas chamadas bibliotecas, coleccións de código, que outros escribiu que pode usar, e outras linguaxes como Java e outros, en realidade, facelo moito máis fácil contar aínda maior. Polo tanto, é realmente algúns deses perigos unha función da linguaxe que usa. E nas próximas semanas, imos ver como perigoso C realmente pode ser, se non usalo correctamente. Pero a partir de aí, e con Python e JavaScript, vai nós capa nalgunhas proteccións adicionais, e executar menos deses riscos. 

Entón, imos facer un pouco máis lóxica interesante no noso programa. Entón deixe-me ir adiante e crear un programa chamado lóxico só así podo xogar con algúns lóxica real, logical.c. Eu só vou copiar e pegar algún Código de antes, entón eu volver a este bo punto de partida. 

Déixeme esta vez facer C. de char que eu son vai dar-lle un nome de C só porque é convencional, obter un personaxe do usuario. E imos finxir Estou aplicando parte dese programa Rm, a retirada programa antes que levou ao usuario para eliminar un ficheiro. Como poderiamos facelo? 

Quero dicir que, se C é igual a iguais, entre comiñas, y, entón eu vou asumir que o usuario decide si. Eu só vou para imprimir si. Se fose realmente escribir o programa de eliminación, poderiamos eliminar o ficheiro con máis liñas de código. Pero nós imos mantelo simple. 

Else if c é igual a igual n-- e agora aquí, eu vou dicir, o usuario debe ter significado ningún. E entón algo, vostede sabe o que? Non sei o que máis o usuario vai escribir. Entón, eu estou indo só para dicir que que é un erro, calquera que sexa el ou ela realmente ingresaran. 

Entón, o que está pasando aquí? Hai unha diferenza fundamental versus o que eu fixen no pasado. comiñas, aspas dobres, o dobre citas, e, aínda, aspas, aspas. Acontece en C, que cando quere escribir unha corda, usa comiñas dobres, así como temos benvida a empregar todo este tempo con printf. 

Pero se quere tratar con só un carácter único, un chamado char, entón realmente usar comiñas simples. Aqueles de vós que teña previsto antes, pode non ter tiña que preocuparse con iso distinción en certas linguas. C, non importa. E así cando chegar nun char e quero comparar ese carácter usando equals é igual a algunha carta como y ou n, fago, en realidade, ten que ter as aspas. 

Agora, imos ir adiante e facelo. Imos ir adiante e fan dot lóxicas cortar lóxico. E agora eu estou sendo solicitado. Así, presuntamente, unha mellor experiencia de usuario sería realmente dicir o que facer aquí. Pero eu vou só cega din y para si, OK, agradable. 

Imos executa-lo de novo, n para ningunha, agradable. Supoña como certas persoas que coñezo, meus tecla bloqueo de mayúsculas está conectado con demasiada frecuencia. Entón fago o capital Y, entrar, erro. OK, non é o que eu estou esperando. Efectivamente, o ordenador Está facendo literalmente o que Eu dixen-o para comprobar a fazer-- minúsculas n y e minúsculas. Este non se sente como bo experiencia do usuario, aínda que. Déixeme pedir e aceptar ambos os casos inferior ou maiúsculas. Así, verifícase se, pode querer dicir algo como en perigo, como literal ou C é igual a é igual a de capital único y citado. Acontece que, C non ten esta palabra chave literal ou. 

Pero ten dúas barras verticais. Ten que soster a tecla Maiús normalmente, se está a usar un teclado americano, e bateu a barra vertical clave sobre a súa tecla de retorno. Pero esa barra vertical barra vertical significa ou. 

Se, pola contra, queriamos a dicir, e como en perigo, poderiamos facer comercial e comercial. Isto non ten sentido lóxico aquí, porque un humano non podería posiblemente escribiu tanto y e minúsculas y e capital de Y como o mesmo personaxe. Así, é o que pretendemos aquí. 

Entón, se eu fai iso en ambos os lugares, ou c é igual é igual a de capital N, agora realizar de novo, fan lóxica, executa novo lóxico. Agora, podo escribir y. E podo facelo de novo con capital de Y ou N. de capital E eu podería engadir no adicional combinacións fixas. 

Polo tanto, esta é unha lóxica programa na medida en que agora Estou comprobando loxicamente para Este valor é ese valor. E eu non teño que, necesariamente, vir cara arriba con dous IFS ou entón IFS. Eu realmente combinan un pouco da Relacionado coa lóxica xuntos deste xeito. Polo tanto, este sería mellor deseñado simplemente dicindo si C é igual a menor caso y, imprimir si, máis se c é igual a capital de Y, imprimir si, máis se c é igual a lower-- noutras palabras, Non ten que ter máis e máis filiais. É posible combinar algunhas das equivalente Loxicamente, como ramas deste xeito. 

Entón, imos dar un ollo en só un ingrediente final, unha construción final, que permite C. E nós imos voltar no futuro, a outros aínda. E entón nós imos concluír, mirando por non a corrección de code-- como obter o código de trabalho-- pero o deseño de código, e plantar as sementes no inicio. 

Entón deixe-me ir adiante e abrir un novo ficheiro aquí. Vostede sabe o que? Eu estou indo a reimplementar que mesmo programa, pero utilizando unha construción diferente. 

Entón me deixe rapidamente darme Acceso para incluír CS50.h para a biblioteca de CS50, Io.h estándar para printf. Dáme o meu void main int. E entón para acá, imos me ir adiante e facelo. 

Char c recibe obter char, como antes. E eu vou usar unha nova construción agora-- cambiar, na cal personaxe? Entón chave é tipo como O cambio dun carrís do tren. Ou, en realidade, é unha especie de unha máis, se else if, pero escrito un pouco diferente. 

A clave parece con isto. Ten switch, e entón o que caracteres ou número que quere para ollar, logo dalgunhas claves como en Cero, só dicir que facer estas cousas. E entón tes casos diferentes. 

Non usar if e else. Vostede literalmente usar o caso da palabra. E diría algo así. 

Así, no caso dun minúsculas Y, ou no caso dun capital Y, dalle imprimir si. E, a continuación, saír do switch. É iso aí. Estamos a facer. 

Else if, por así dicir, minúsculas n, ou de capital N, entón vai adiante e imprimir saír, non, e, a continuación, romper. Else-- e este tipo de é o caso estándar indeed-- printf error-- e só para unha boa medida, aínda que loxicamente esta pausa non é necesario porque estamos na fin do interruptor de calquera xeito, Agora estou batendo fóra do switch. Polo tanto, este parece un pouco diferente. 

Pero, loxicamente, é efectivamente equivalente. E por que usaría un sobre o outro? Ás veces, só preferencia persoal, por veces, a estética, se eu ollo para esta Agora, hai algo a ser dito para o lexibilidade deste código. É dicir, non importa o feito de que este código é novo para moitos de nós no cuarto. 

Pero é só unha especie de é bonito. Ve minúsculas y, capital de Y, minúsculas n, patrón de capital N, el só tipo de saltos fóra en ti dunha maneira que, sen dúbida, se cadra o exemplo anterior coas IFS, e as barras verticais, e os IFS outra persoa, pode non ter. Polo tanto, esta é realmente unha cuestión de persoal elección, realmente, é a lexibilidade, do código. 

Pero en termos de funcionalidade, déixeme dalle facer unha chave, barra dot switch, e agora escribir y minúsculas, capital de Y, minúsculas n, capital de N, David, ténteo de novo, porque iso é non un único carácter. Faremos x, erro, como se esperaba. E, logically-- e iso é algo Quere fomentar en general-- mesmo aínda estamos só raiar a superficie dalgunhas destas características. 

E isto pode non ser evidente cando -Se sentir no teclado, como funciona? O que isto fai? A fermosa cousa sobre ter un portátil ou de escritorio, ou o acceso a un ordenador cun compilador, e con un editor de código como este, é case sempre pode responder a estas preguntas a si mesmo só tentando. 

Por exemplo, se o retórico cuestión en apreciado foron, o que pasa se esquecer súas declaracións de ruptura? Que é realmente un moi común que hai que facer, por que non parece como realmente precisa deles. Realmente non completar o seu pensaba como paréntese ou rizado cinta fai. Imos ir adiante e recompilar o código e ver. Entón faga chave, chave de corte de punto. Imos escribir en letras minúsculas y, a top case, Intro. Entón eu escriba y. 

O programa dixo que si, non, de erro, como se está cambiando a súa mente. Pero que tipo de era, xa que o que pasa cun interruptor é o primeiro caso que xogo significa, esencialmente, hey ordenador, realizar todo o código de abaixo dela. E se non se ruptura, ou non digo ruptura, ou non din ruptura, o ordenador vai explotar a través de todas as liñas e realizar todos eles ata chega a ese chaveta. Así, os freos son, de feito, é necesario. Pero un takeaway aquí é cando En caso de dúbida, proba algo. Quizais gardar o código en primeiro lugar, ou garda-lo nun arquivo extra se está realmente preocupado desorde e ter que recuperar o traballo que sabe que funciona. 

Pero tentar cousas. E non ser tan medo, se cadra, que o ordenador pode facer, ou que pode romper algo. Sempre pode volver a algunha versión anterior. 

Entón imos acabar vendo para o deseño de código. Temos esa capacidade agora de escribir condicións e loops de gravación, e variables, e funcións de chamada. Entón, francamente, estamos especie de volta ao onde estabamos hai unha semana co Scratch, aínda que cun textuais menos convincentes ambiente que cero permite. 

Pero teña en conta a rapidez con que adquiriu que o vocabulario, aínda que sexa vai levar un pouco de tempo para afondar, de xeito que agora podemos utilizar este vocabulario para escribir programas máis interesantes. E imos dar un paso de bebé para que, deste xeito. Deixe-me ir adiante e crear un novo arquivo aquí. 

Vou chamar esta prototype.c, e introducir por primeira vez, a capacidade para facer as súas propias funcións. Algúns de vostedes poden ter feito isto co Scratch, a través do cal pode crear o seu bloques individuais propios en cero, e logo, arrastralo los para sitio onde queira que quere en C. E na maior parte da programación idiomas, pode facer exactamente isso-- facer as súas propias funcións, se xa non existen. 

Así, por exemplo, deixe-me ir adiante e inclúen CS50.h, e incluír estándar io.h, int void main. E agora temos unha espazo reservado preparado para ir. I manter as cousas de impresión como os nomes das persoas hoxe. E que se sente como-- Non sería bo se hai eran unha función chamada nome de impresión? Non teño de utilizar printf. Non teño a lembrar todos os códigos de formato. Por que non eu, ou porque non alguén antes de min, crear unha función chamada de impresión nome, dado algún nome, simplemente imprime-lo para fóra? 

Noutras palabras, se eu digo, hey, ordenador, dáme unha corda pedindo ao usuario para tal, vía función de cadea get de CS50. Hey, ordenador, poñer esa cadea en a variable na parte esquerda, e chamalo s. E, a continuación, hey ordenador, vai adiante e imprimir o nome de persoa, feito. 

Agora sería bo, porque Neste programa, apropiadamente chamado, dime o que se quere facer por medio de nomes daqueles función. Deixe-me ir e facer prototipo, Intro. E, por desgraza, iso non vai voar. 

Prototype.c, liña 7, personaxe 5, de erro, declaración implícita da función nome de impresión non é válido na C99, C99 significa unha versión de C que saíu en 1999. Iso é todo. 

Entón, eu non sei o que todo isto significa aínda. Pero eu recoñezo erro en vermello. Isto é moi evidente. 

E parece que, con o personaxe verde aquí, o problema é o nome de impresión, aberta Paren s, paren próximos, e coma. Pero a declaración implícita de función fixemos ver brevemente antes. Isto significa, simplemente, que Clang Non sabe o que quero dicir. 

Eu usei a palabra do vocabulario que se Nunca vin ou foi ensinado antes. E entón eu teño ensino-lo o que esta función significa. Entón, eu estou indo a ir adiante e facelo. 

Eu estou indo a ir adiante e aplicar miña propia función chamada Nome impreso. E eu vou dicir, como segue, que fai iso, printf, Ola, cento s, barra invertida n, nome, punto e coma. Entón, o que eu acabo de facer? 

Non é que, para aplicar a súa propia función, que tipo de prestar algúns dos a mesma estrutura principal que fomos só tida como certa, e eu sabe só copiando e colar moi fermoso o que Teño escrito no pasado. Pero teña en conta o nivel aquí. Int, Main, Baleiro, imos desmembrar en pouco tempo o que iso realmente significa. 

Pero para hoxe, só notar o paralelismo. Baleiro, o nome de impresión, nome de cadea, por iso hai un contrasinal vermello, que comezaremos chamando un tipo de retorno, o nome do a función, e despois da entrada. Entón, en realidade, podemos destilar este tipo de como a semana pasada como, este é o nome ou o algoritmo do código estamos indo a write-- algoritmo subxacente o código que vai escribir. 

Esta é a súa entrada. Esta é a súa saída. Esta función, o nome de impresión, é deseñados para ter unha cadea chamada nome, ou o que quere, como entrada, e logo anuladas. Non volve nada, como obter corda ou obter int fai. El me vai dar algo de volta. É só vai ter un efecto secundario, por así dicir, de imprimir o nome dunha persoa. Entón, teña en conta, liña 7, I Pode chamar o nome de impresión. Liña 10, podo axustar ou aplicar nome de impresión. Pero, desgraciadamente, isto non é suficiente. 

Deixe-me ir adiante e recompilar isto despois de gardar. Whoa, agora, eu fixen iso peor, ao parecer. declaración de xeito implícito de nome da función de impresión non é válido. E, de novo, hai máis erros. Pero como eu advertiu anteriormente, aínda se queda resaltado con, ou un pouco triste ver tantos erros, concentrarse só na primeira inicialmente, porque só podería ter un efecto en fervenza. Así, C, ou máis especificamente Clang, segue a non recoñecer o nome de impresión. 

E iso é porque Clang, por deseño, é unha especie de idiota. El só fai o que diga a el para facer. E iso só fai iso na orde no que diga a el para facer. 

Entón, eu teño definido principal na liña de catro, como vimos facendo bastante frecuencia. Eu define o nome de impresión en liña 10. Pero eu estou tentando usar nome de impresión en liña sete. 

É moi cedo, aínda non existe. Así podería ser intelixente, e ser como, OK, entón imos só xogar xunto, e mover nome de impresión superior aquí, e recompilar. Meu Deus. Funcionou. Era tan simple como iso. 

Pero a lóxica é exactamente iso. Tes de ensinar o que Clang é definindo a función primeira. Logo, pode usalo. Pero, francamente, este se sente como unha ladeira escorregadia. 

Así, cada vez que eu corro nun problema, eu son só vai destacar e copiar o código Escribín, corte-lo e pegalo aquí. E, por suposto, poderiamos inventar uns escenarios onde unha función pode que chamar outra. E simplemente non pode poñer todo función enriba de calquera outro. 

Non é que hai unha solución mellor. Podemos deixar este ser. E, francamente, é xeralmente bo, e cómodo, e un bo deseño para poñer principal en primeiro lugar, porque, de novo, principal só como cando a bandeira verde premendo, que é a función que corre por defecto. Así, pode moi ben poñer Lo na parte superior do ficheiro de xeito que cando ou calquera outro ser humano mira para o arquivo sabe o que está a suceder só lendo principal en primeiro lugar. Non é que podemos dicir Clang Proativo, hey, Clang, na liña catro, Eu prometer para aplicar unha función chamada impresión Nome que leva o nome de cadea chamada como entrada, e devolve nada, nula. E eu vou dar a volta a implementar lo máis tarde. 

Aí vén Principal. Iniciar agora na liña 9 pode usar Imprimir Nombre porque Clang é confiar en que, finalmente, ha atopar a definición da execución da impresión Name. Entón, despois de salvar meu arquivo, imos -me ir adiante e facer prototipo, parece ser bo neste momento. Dot cortar, prototipo, déixeme dalle escriba un nome. David, Ola David, Zamila, Ola Zamila, e, de feito, agora funciona. 

Así, o ingrediente aquí é que temos fixo unha función personalizada, como un costume bloque cero estamos chamando. Pero, a diferenza do risco onde podes só crealo e comezar a usalo, agora temos que ser un pouco máis pedante, e realmente adestrar Clang de usar, ou esperar. Agora, como un aparte, por que todo este tempo ten fomos cegamente na fe incluíndo CS50.h, e incluíndo io.h defecto? 

Ben, ao parecer, entre algunhas outras cousas, todo o que está naqueles dot h arquivos, que terá lugar a ser arquivos. Son arquivos de cabeceira, por así dicir. Están aínda escrito en C. Pero son un tipo de ficheiro. 

De momento, pode moi ben asumir que todo o que está dentro CS50.h é algúns one-liners como este, non para funcións chamadas Nome impreso, pero para obter String, Obter Float, e algúns outros. E hai prototipos similares, forros un, dentro io.h estándar para printf, que está agora en miña propia función Imprimir Nome. Polo tanto, noutras palabras, todo este tempo temos acaba de ser cegamente copiar e pegar inclúen tanto, incluír que, o que está pasando? Estas son só un tipo de pistas para Clang que funcións son, de feito, aplicada, só noutras posicións diferentes ficheiros noutra parte do sistema. 

Entón, nós temos implantado nome de impresión. Ten ese efecto colateral de imprimir algo na pantalla. Pero iso non acontece, en realidade, me dea algo de volta. Como é que imos a posta en marcha dun programa que non me dar algo de volta? 

Ben, imos tentar iso. Deixe-me ir adiante e aplicar un arquivo chamado return.c para que poidamos demostrar como algo como Get String, ou obter Int, é, en realidade, volvendo algo de volta para o usuario. Imos adiante e establecer void main int. 

E, de novo, no futuro, imos explicar o que iso int e ese baleiro é realmente facendo. Pero para hoxe, imos é un dato adquirido. Eu estou indo a ir adiante e printf, para unha boa experiencia do usuario, x é. E entón eu vou esperar a do usuario para darme x con get int. 

E entón eu estou indo a ir adiante e imprimir x ao cadrado. Entón, cando só ten un teclado, a xente comunmente usar o pouco de cenoria símbolo do teclado para representar o poder , Ou o expoñente. Entón x ao cadrado está presente i. 

E agora eu vou facelo. Podería só fazer-- que é x cadrado? x cadrado é x veces x. 

E nós fixemos iso algo tempo xa hoxe. Este non se sente como todo o que moito progreso. Vostede sabe o que? Imos aproveitar algo desa idea a última vez de abstracción. 

Non sería bo se hai unha función chamada cadrado que fai exactamente iso? Aínda, a finais do día, fai o mesmo matemáticas. Pero imos abstracto aínda que a idea de tomar un número multiplicado por outra, e só darlle un nome, como conciliar ese valor. 

E, por outras palabras, en C, imos crear unha función chamado cadrado que fai exactamente iso. Será chamado cadrado. Vai levar un int. E nós imos será só chamalo n, por defecto. 

Pero poderiamos chamalo de calquera cousa que queiramos. E todo o que vai facer, literalmente, é o retorno o resultado n veces n. Senón porque é retornando algo, que é a palabra clave en vermello temos nunca antes visto, I, na liña 11, Non pode simplemente dicir nula neste momento. 

Baleiro, no exemplo que acabamos de ver no canto do nome de impresión, significa só, facer algo. Pero non me deixa algo de volta. Neste caso, quero para volver N N veces, ou o que quere que sexa, este número. 

Entón eu non podo dicir, hey, ordenador, I voltar nada, o baleiro. Vai volver, por natureza, un int. E entón iso é todo o que está pasando aquí. 

A entrada ao cadrado será un int. E para que poidamos usalo, ten que ten un nome, N. Vai saída un int que non precisa dun nome. Podemos deixalo ao principal, ou quen queira que sexa utilizándose me a lembrar este valor quere coa súa propia variable. 

E, unha vez máis, a única nova palabra clave aquí é Return. E eu estou só facendo un pouco de matemáticas. Se realmente quería ser innecesario, Podería dicir do produto int recibe n veces n. 

E entón eu podería dicir, o produto voltar. Pero, de novo, para o meu punto anterior do iso só non ser bo design-- como, por introducir un nome, un símbolo, como produto, só para devolve-lo inmediatamente? É un pouco máis limpo, un pouco máis axustado, polo que para falar, só para dicir retorno n veces n, librar-se desta liña por completo. 

E é só menos código para ler, menos oportunidades para erros. E imos ver se este en realidade, traballa agora. Agora, eu estou indo a ir adiante e facer o retorno. 

Uh-oh, declaración implícita da función. Eu cometín este erro antes, non é gran cousa. Déixeme só escribir ou destacar e copiar, exactamente a mesma función prototipo, ou sinatura, da función ata aquí. Ou eu podería mover toda a función. 

Pero iso é algo perezoso. Polo tanto, non imos facelo. Agora, deixe-me facer o retorno unha vez máis, o punto de retorno barra. 

x é 2. x ao cadrado é 4. x é 3. x ao cadrado é 9. E a función parece agora estar funcionando. Entón, cal é a diferenza aquí? Eu teño unha función que se chama cadrado, neste caso, que me puxen nunha entrada. E eu volver unha saída. E aínda, con anterioridade, se Abro outro exemplo de antes, o que chamouse prototype.c, Eu tiña o nome de impresión, que volveu baleiro, por así dicir, Ou voltou nada e simplemente tiña un efecto colateral. 

Entón, o que está pasando aquí? Ben, considere a función obter cadea por só un momento. Temos benvida a empregar a función obter secuencia do seguinte xeito. 

Tivemos unha función de obter corda, como incluír CS50.h, inclúen estándar io.h, int, principal, nula. E, a continuación, cada vez que eu teño chamada cadea get ata agora, Eu dixen algo, corda s recibe obter corda, porque get string-- Imos chamar esa cadea get get.c-- -Se devolve unha cadea que podo, entón, usar, e dicir, Ola, coma, por cento s, barra invertida n, s. 

Polo tanto, este é o mesmo exemplo, Realmente, que tiñamos antes. Polo tanto, obter secuencia retorna un valor. Pero hai pouco, secuencia de impresión non retorna un valor. Simplemente ten efectos secundarios. Polo tanto, esta é unha diferenza fundamental. Vimos diferente tipo de funcións agora, algúns dos cales retornar valores, algúns dos cales non. Entón quizais sexa cadea, ou int ou float. Ou quizais sexa só en branco. 

E é a diferenza que estas funcións que obter datos e voltar un valor son realmente traendo algo de volta á mesa, por así dicir. Entón, imos adiante e mirar para un conxunto final de exemplos que dá unha sensación, agora, como podemos, de feito, abstracto mellor, e mellor, e mellor, ou máis, e máis, e máis, a fin para escribir, en definitiva, un código mellor. Imos adiante, e no espírito do Scratch, faga o seguinte. 

Deixe-me ir adiante e inclúen CS50.h e IO.h. estándar Deixe-me ir adiante e dar me un int, principal, nula. E deixe-me ir adiante, chame este cough.c. 

E deixe-me ir adiante e só como cero, imprima a tose / n. E quero facelo tres veces. Entón, eu estou, por suposto, só vai para copiar e pegar tres veces. Estou indo agora para facer tos tos barra de punto. Imos dar-me un pouco máis de espazo aquí, Intro, tose, tose, tose. 

Hai, obviamente, xa un oportunidade de mellora. Copiei e colei algunhas veces hoxe. Pero iso foi só para que eu non fixen Ten que escribir cantos caracteres. Eu cambiou o que estas liñas de código son. 

Estes tres liñas son idénticos, que se sente preguiceiro e de feito é, e probablemente non é a visión correcta. Así, co ingrediente poderiamos mellorar este código? Non debemos copiar e pegar o código. 

E, de feito, cando sente -Se copiar e pegar, e nin mesmo cambiar o código, posibilidades son de que hai un xeito mellor. E, de feito, non existe. Deixe-me ir adiante e facer un loop for, aínda que a sintaxe non pode vén naturalmente aínda. 

Faino tres veces, simplemente facendo o following-- E resulta que eu sei que iso a partir da práctica. Pero temos unha serie de exemplos agora. E vai ver en liña máis referencias fixas. 

Esta é a sintaxe en liña 6, que así como do risco que se repite bloque, repita os seguintes tres veces. É un pouco máxico para agora. Pero iso vai ser máis, e máis familiar. 

E vai repetir liña de oito por tres veces, de xeito que se eu re-compilar make tose, dot cortar tose, tose, tose, tose. Aínda funciona do mesmo xeito. Entón, iso é todo moi ben e bo. Pero iso non é moi abstraída. 

É perfectamente correcto. Pero parece que hai podería ser unha oportunidade, como no mundo de Cero, ao tipo de inicio engadir algúns semántica para que Non só ter algún lazo for, e unha función que se tossir ou non tossir. Vostede sabe o que? Déixeme probar ser un pouco máis frío do que iso, e realmente escribir unha función que ten algúns efectos secundarios, chamalo tossir. 

E non ten entrada e non retorna ningún valor como saída. Pero vostede sabe o que fai? Fai isto-- printf, entre comiñas, tossir. 

E agora aquí enriba, eu vou ir adiante e para int, i recibe cero, i inferior a 3, i plus plus. Eu estou indo a non facer printf, que é sen dúbida unha implementación de baixo nivel detalle. Eu non me importa como tusir. Eu só quero usar a función de tose. E eu estou indo só para chamar tose. 

Agora, teña en conta a dicotomía. Cando chamar unha función, se non o fai quero darlle entradas, totalmente ben. Só ten que facer o paréntese aberta, preto paréntese, e está feito. 

Cando define unha función, ou declarar un prototipo de función, Se sabe de antemán que non é Vai tomar calquera argumentos, dicir nula naqueles parénteses alí. E iso fai seguro de que non accidentalmente abusar dela. Deixe-me ir adiante e facer tose. E, por suposto, eu cometín un erro. 

Drogas, hai que declaración implícita. Pero iso é bo. É un reparación doado. Eu só teño o prototipo máis arriba no meu arquivo do que eu estou realmente empregar. 

Entón, agora déixeme facer tose novo, agradable. Agora funciona. Fai tose, tose, tose, tose. Entón pode pensar que estamos realmente pouco máis de enxeñaría este problema. E, de feito, somos. Este non é un bo candidato dun programa no momento de refatoração, e facer o que é chamado de descomposición xerárquica, onde toma un código, e logo vostede tipo de factor de cousas para fóra, así como asignar máis semántica para eles, e reutiliza-lo en definitiva, a longo prazo. Pero é un bloque de construción en dirección programas máis sofisticados que imos comezar escribir en pouco tempo que permítenos ter o vocabulario co cal a escribir mellor código. E, de feito, imos ver se nós Non se pode xeneralizar este proxecto. 

Parece un pouco lame que, de inicio, se preocupe este danado para loop, e chamando a tose novo e de novo. Por que non podo só dicir tose, tussa tres veces? Noutras palabras, por que non podo só dar entrada a tossir e facelo? 

Por que non podo só dicir, en principal tose tres veces. E agora, este é o tipo de maxia. É moi iterativo aquí. E é, de feito, un pequeno paso. 

Pero só a capacidade de dicir liña oito, tose por tres veces, é só moito máis lexible. E, ademais, eu non teño que saber ou coidado como tose é aplicado. E, de feito, a finais do prazo e para proxectos finais, Se afrontar un proxecto con un compañeiro ou dous compañeiros, notarás que está indo Ten que, ou se quere, dividir o traballo. 

E vai querer decidir de antelación, quen vai facer o que, e en que pezas? E non sería bo Se, por exemplo, asumir o mando da escrita principal, feito. E o seu compañeiro de cuarto, ou o seu socio dun modo máis xeral, coida da posta en marcha de tose. 

E esa división, estes paredes de abstracción, ou capas de abstracción se vai, son super poderoso, porque todo para maior, máis programas e sistemas complexos, Permite que varias persoas para construír cousas xuntos, e finalmente coser o seu traballo en conxunto deste xeito. Pero, por suposto, nós Debe agora corrixir tose. Necesitamos dicir a tose que, hey, vostede sabe o que? Vai ter que tomar un input-- por iso non baleiro, pero int e agora. Imos adiante e poñer en tos do int. i recibe cero. 

i é menos que o número de veces. Eu dixen tres antes. Pero non é iso que eu quero. Quero tossir para ser xeneralizado para soportar calquera número de iteracións. 

Entón, en realidade, é n que quero, todo o que o usuario dime. Agora, podo ir adiante e dicir tose impresión. E non importa o número de o usuario pasa, Vou facer unha iteración que moitas veces. 

Así, ao final do día, programa é o mesmo. Pero teña en conta todas estas cousas Pode até ser noutro ficheiro. En realidade, eu non sei o momento, como printf é aplicado. 

Non sei no momento como chegar corda, ou obter int, ou obter flotador son aplicadas. E eu non quero velos na pantalla do meu. Como é, eu estou empezando a se concentrar en meu programa, non estas funcións. 

E así, de feito, tan pronto comezar factoring código como este para fóra, Nós ata podía mover tose a un arquivo separado? Alguén máis podería implementar lo. E vostede eo seu programa de chegar a ser o moi bonito, e moi lexible, sen dúbida, realmente catro programa de liña alí. 

Entón, imos adiante agora e facer unha mudanza. Teña en conta que o meu prototipo ten que cambiar enriba. Entón deixe-me corrixir isto así Non obter berrou. 

Fai tose, deixarme correr tose xa máis, aínda facendo o mesmo. Pero agora, entender que temos unha ingrediente para unha versión final. Vostede sabe o que? Non quero só tose, necesariamente. Eu quero ter algo máis xeral. Entón vostede sabe o que? Eu quero facelo. Quero ter, así como do risco fai, un bloque por exemplo, pero non só dicir algo un determinado número de veces. Quero dicir unha secuencia moi específica. E, polo tanto, non sei queres que acaba de dicir tose. Quero dicir o que quere cadea é pasado. 

Entón, teña en conta, eu xeneralizada isto para que agora digamos se sente como un bo nome para iso, como o risco, leva dous argumentos, ao contrario cero. Un deles é un string. Un deles é un int. 

E eu podería muda-los. Eu medio que me gusta a idea de din que a corda primeiro, e despois cantas veces posteriores. Baleiro significa aínda non retorna nada. Estes son só lado visual efectos, como con [? Jordan ,?] efectos secundarios verbal de berrar. Inda fai algo n veces, 0 ata, pero non igual a n. Isto significa n veces en total. E despois é só imprimir o que quere que esta cadea é. Entón, realmente xeneralizada esta liña de código. Entón, agora, como fago para aplicar a función de tose? 

Podo facer tose baleiro. E eu aínda podo tomar como moitas veces quere a tossir. Pero vostede sabe o que? agora podo chutar a dicir. 

Podo chamar dicir co palabra tose, pasando n. E se eu queira aplicar tamén, só por diversión, unha función espirro, I pode Espirrar un determinado número de veces. E podo manter reutilizando n, porque ter en conta que m neste contexto ou extensión só existe dentro desa función. 

E n neste contexto só existe dentro desta función aquí. Entón, imos volver estas cuestións de ámbito. E aquí, eu só vou dicir, Achoo e logo n veces, punto e coma. 

E agora, eu só precisa tomar prestado estas funcións sinaturas ata aquí. Entón tose é correcto. espirro baleiro é correcta agora. 

E eu aínda só precisa dicir. Entón eu vou dicir, digamos cadea s, int n, punto e coma. Entón, eu teño máis de enxeñaría do Parreira fóra deste programa. 

E iso non fai significa necesariamente que se trata o que debe facer cando se escribe mesmo o máis simple dos programas. Tomé algo que é, obviamente, moi sinxelo, moi curto, e re-lo aplicar usando xeito moi código. Pero vai realmente ver, e en tempo de ollar cara atrás sobre estes exemplos, e entender, oh, estes son os pasos tomamos para realmente xeneralizar, fatorar algo fóra, ata o final do día meu código é realmente moi razoable. Porque se eu queira tossir tres veces, a continuación, espirrar tres veces, Eu estou indo simplemente para realizar de novo este, programa facer tose, e realizar tose. E eu teño tres toses e tres espirra. 

E por iso este é un básicos paradigma, se quixeren, de como podemos ir sobre en realidade, a posta en marcha dun programa. Pero imos ver agora o que é temos está a facer todo este tempo, e que algunhas das pezas finais están detrás desta simple comando. Ao final do día, temos benvida a empregar Clang como o noso compilador. Vimos escribir fonte código, convertendo- vía Clang en código máquina. 

E nós temos que chegou a empregar facer só para facilitar as nosas combinacións de teclas para que non ten que lembrar eses encantamentos de si Clang. Pero o que é facer realmente facendo? E, á súa vez, o que é Clang realmente facendo? 

Acontece que, aínda que simplificado a discusión de hoxe, dicindo: toma código fonte, pasalo como entrada para un compilador, que lle dá saída da máquina código, acontece que hai algúns pasos diferentes dentro alí. E compilación pasa a ser o paraugas prazo para todo un conxunto de pasos. Pero imos só provocalo isto moi rapidamente. 

Acontece que temos está a facer máis cousas cada vez que eu executar un programa, ou cada vez que eu compilar un programa hoxe. Así, o pre-procesamento refírese a isto-- algo nun programa C, como veremos de novo e de novo, que comeza con este símbolo de hash, ou o símbolo hashtag aquí, significa é un pre-procesador directiva. Isto significa que, neste caso, ei ordenador, facer algo con este ficheiro antes de que realmente compilar meu propio código. 

Neste caso, de hash inclúen sexa, esencialmente, forma de dicir do C, hey ordenador, ir buscar o contido de CS50.h e cola-los aquí. Hey ordenador, ir buscar o contido de io.h estándar, onde queira que sexa sobre o disco duro, pegalo aquí. Entón, estas cousas acontecen por primeira vez durante o pre-procesamento. 

E Clang fai todo isto para nós. E faino tan danado rápido, nin sequera ver catro cousas distintas ocorrer. Pero esa é a primeira tal paso. 

O que realmente ocorre logo? Ben, o próximo oficial paso é a compilación. E verifícase que compilar un programa tecnicamente significa que vai de código fonte, as cousas que teño foi escrito hoxe, para algo chamado código de montaxe, algo que parece un pouco diferente. 

E, de feito, podemos ver que moi rápido. Déixeme realmente ir ao meu IDE. Deixe-me ir adiante e hello.c aberta, que é o primeiro programa co que nós comezou hoxe. E deixe-me ir adiante e executar Clang un pouco distinto, Clang-s, hello.c, que está indo realmente para Déame outra hello.s de ficheiro. 

E nós probablemente nunca será novo ver este tipo de código. Se tomar un nivel máis baixo sistemas de clase como CS61, vai ver moito máis deste tipo de código. Pero esta é a linguaxe assembly. Este é X86 linguaxe assembly que a CPU que está subxacente CS50 IDE realmente entende. 

E enigmática como fai ollar, é algo o ordenador entende moi ben. Sub Q, isto é un substrato. Hai movementos. 

Non está chamando de funcións aquí, x oring, un movemento, un complemento, un pop, un retorno. Polo tanto, hai algúns moi instrucións de baixo nivel que CPUs entender que Aludi anteriormente. Iso é o que Intel Inside. 

Existen patróns de ceros e uns que mapear a estes redactado arcanely pero algo así nomeado, instrucións, por así dicir. Isto é o que ocorre cando compilar o código. Comeza a montaxe lingua de fóra, o que significa que o terceiro paso é para montar que o código assembly para, en definitiva, Máquina de ceros code-- e uns, non os texto que acabamos de ver un momento atrás. 

Así, pre-procesamento que iso atopar e substituír, e algunhas outras cousas. Compilando leva a súa fonte código de C, o código fonte que escribiu, para montaxe código que só mirou. Montaxe leva que a montaxe código para ceros e uns que o CPU vai realmente comprender, ao final do día. E vinculación é a última etapa que pasa a US-- novo, tan rápido que nin sequera notice-- que di: hey ordenador, tomar todas os ceros e uns que resultou de compilar o código de David, ea súa principal función neste caso. 

E ei ordenador, ir buscar todo ceros e uns que o equipo CS50 escribiu dentro da biblioteca CS50. Mestura aqueles con David. E ei ordenador, ir buscar todos os ceros e os que alguén escribiu anos atrás para printf. E engadir aqueles para o cousa toda, de xeito que temos teño os meus ceros e uns, a ceros e uns do persoal CS50, os ceros e uns, printf e calquera outra cousa que estamos a usar. 

Todos eles se combinados nun programa chamado neste caso Hola. Entón, de agora en diante, imos só usar a palabra compilación. E imos tomar como certo que, cando dicimos, compilar o seu programa, é dicir, hey facer o pre-procesamento, montaxe e conexión. Pero hai realmente algunhas cousas suculenta pasando alí debaixo do capó. E especialmente se estar curioso algún tempo, pode comezar a picar en torno a este nivel inferior. Pero, por agora, entender que entre os temas para hoxe son pura e simplemente o inicio dun proceso, de estar cómodo con algo así como Ola mundo. En realidade, a maioría do que fixemos hoxe certamente non vai afundir na super rápido. E iso vai levar moito tempo, e algunha práctica. E as probabilidades son, vostede pode clasificar de quere bater o teclado ou berrar para a pantalla. E todo iso é OK. Aínda que, quizais intente non facelo na biblioteca tanto. 

E, finalmente, vai ser capaces, porén, de comezar vendo patróns, tanto no bo código que escribiu e erros que fixo. E moi parecido ao proceso de tornándose un TF ou CA é como, vai comezar a ir mellor e mellor ao ver eses patróns, e só resolver o seu propios problemas en última instancia. Nese medio tempo, haberá unha abundancia de nós para darlle soporte, e levalo por iso. E nos write-ups para todos os problemas será guiado a través todos os comandos que seguramente sabe de moita práctica ata agora, pero podería voar sobre a cabeza de momento. E iso é totalmente ben. 

Pero, en definitiva, vai para comezar a ver xurdir patróns. E unha vez que pasar por todo o detalles estúpidas, como parénteses, e chaves, e punto e coma, e as cousas, a verdade, que non é de ningún xeito intelectualmente interesante. E non é o obxectivo de tomar calquera clase introdutoria. E as ideas que van importa. 

Son os loops, eo condicións e as funcións, e máis poderosamente a abstracción, eo factoring de código, eo bo deseño, eo bo estilo, e, finalmente, a exactitude do seu código, que é, en definitiva Vai descargar máis. Así, a próxima semana, imos tomar estas ideas que vimos por primeira vez en Risco e agora traducido a C. E imos comezar para introducir a primeira do dominios do mundo real do curso. 

Imos concentrar-se no mundo da seguridade, e máis especificamente cifrado, técnica de codificación da información. E entre o primeiro problemas que aínda comezará a gravar ademais xogando con algunha da sintaxe e resolver algúns lóxica problemas, en definitiva, en pouco tempo, é realmente loitan, ou cifrar, e, finalmente, descifrar a información. E todo o que fixemos Hoxe, será moi baixa nivel, é só permitirá -Nos a tomar un, e un, e un paso arriba cara escribir o código máis interesante aínda. 

Entón máis sobre iso a próxima semana. 

[Reprodución de vídeo] 

-O Que me pode dicir sobre a última vez que o viu? -O Que podo dicir, realmente? Quero dicir, era como calquera outra ensaio de pre-produción, agás que non era algo que dixo ao final que quedou comigo. 

-Este Foi CS50. 

-É Un corte de todos, gran traballo en ensaio. 

o xantar de -que? 

Si, e eu podemos incorporarse un bocadillos en algo. Déixeme só interrogar con David moi rapidamente. David? David? 

[FIN DE REPRODUCIÓN] 