1
00:00:00,000 --> 00:00:00,000

2
00:00:00,000 --> 00:00:00,000
[Reprodución de música]

3
00:00:00,000 --> 00:00:13,950

4
00:00:13,950 --> 00:00:16,240
>> DAVID J. Malan: Todo ben, iso é CS50.

5
00:00:16,240 --> 00:00:18,010
E esta é unha semana.

6
00:00:18,010 --> 00:00:22,050
Entón lembro a última vez a semana cero,
Nós nos concentrados en pensamento computacional.

7
00:00:22,050 --> 00:00:25,440
E a transición de que a
Cero, a programación gráfica

8
00:00:25,440 --> 00:00:27,360
linguaxe dos nosos amigos
no Media Lab do MIT.

9
00:00:27,360 --> 00:00:31,730
>> E co Scratch, que exploran
ideas como funcións e condicións,

10
00:00:31,730 --> 00:00:35,210
e loops e variables, e mesmo
eventos e debates, e máis.

11
00:00:35,210 --> 00:00:37,880
E hoxe, imos
continuar a utilizar estas ideas,

12
00:00:37,880 --> 00:00:40,630
e realmente levalos para
concedido, pero traducilo las

13
00:00:40,630 --> 00:00:44,220
a outro idioma coñecido como C. Agora
C é unha linguaxe máis tradicional.

14
00:00:44,220 --> 00:00:46,020
É un nivel máis baixo
a linguaxe, se quere.

15
00:00:46,020 --> 00:00:47,300
>> É puramente textual.

16
00:00:47,300 --> 00:00:49,910
E así, a primeira vista, é
todo vai mirar un pouco críptica

17
00:00:49,910 --> 00:00:51,430
se nunca programou antes.

18
00:00:51,430 --> 00:00:53,530
Nós imos ter
punto e coma e parénteses,

19
00:00:53,530 --> 00:00:55,150
e chaves, e moito máis.

20
00:00:55,150 --> 00:00:57,240
Pero entender que, aínda
aínda que a sintaxe sexa

21
00:00:57,240 --> 00:01:00,600
sobre a mirar un pouco familiarizado
a maioría de vós, ver ademais.

22
00:01:00,600 --> 00:01:03,220
E tentar ver as ideas
que son, de feito, familiar,

23
00:01:03,220 --> 00:01:06,750
porque aquí a semana un o que
comezaremos a facer é comparar,

24
00:01:06,750 --> 00:01:08,980
Inicialmente, Raspe contra C.

25
00:01:08,980 --> 00:01:12,350
>> Así, por exemplo, recordar que cando
aplicou o primeiro dos nosos programas

26
00:01:12,350 --> 00:01:16,220
último, tivemos un bloque que parecía
un pouco algo como isto-- cando

27
00:01:16,220 --> 00:01:19,990
bandeira verde premendo, e despois tivemos
Un ou máis pezas do puzzle, abaixo dela,

28
00:01:19,990 --> 00:01:22,150
neste caso, dicir, Ola mundo.

29
00:01:22,150 --> 00:01:24,870
Entón, en realidade, en perigo,
cando premo que a bandeira verde

30
00:01:24,870 --> 00:01:27,390
para realizar o meu programa, de xeito
falar, son

31
00:01:27,390 --> 00:01:29,520
os bloques que son executadas, ou correr.

32
00:01:29,520 --> 00:01:32,230
E, especialmente, risco
dixo, Ola, mundo.

33
00:01:32,230 --> 00:01:35,377
>> Agora, eu podería especificar
diferentes palabras aquí.

34
00:01:35,377 --> 00:01:37,960
Pero imos ver que, de feito, moitos
destes blocks-- e, en realidade,

35
00:01:37,960 --> 00:01:41,880
C en moitas funcións no se pode
parametrizada ou personalizado

36
00:01:41,880 --> 00:01:43,150
para facer cousas diferentes.

37
00:01:43,150 --> 00:01:45,520
De feito, en C
Quere converter agora

38
00:01:45,520 --> 00:01:47,567
este programa Raspadinha
a esta outra lingua,

39
00:01:47,567 --> 00:01:49,650
nós estamos indo a escribir un
pouco algo así.

40
00:01:49,650 --> 00:01:52,540
>> Concedida, hai algunha estraña
sintaxe hai máis probable, int,

41
00:01:52,540 --> 00:01:54,380
e parénteses e sen efecto.

42
00:01:54,380 --> 00:01:57,740
Pero printf-- mesmo que faría
creo que sería só impresión.

43
00:01:57,740 --> 00:02:00,120
Pero de impresión significa impresión
formato, como veremos en breve.

44
00:02:00,120 --> 00:02:02,140
Esta literalmente imprimirá
para a pantalla que quere

45
00:02:02,140 --> 00:02:05,990
está dentro destes parénteses, que
Claro que neste caso é, Ola mundo.

46
00:02:05,990 --> 00:02:09,290
>> Pero vai notar algunhas outras
sintaxe, algunhas comiñas,

47
00:02:09,290 --> 00:02:11,890
que os parénteses ao final,
o e coma e similares.

48
00:02:11,890 --> 00:02:15,027
Polo tanto, hai un pouco de sobrecarga,
por así dicir, cognitivamente tanto

49
00:02:15,027 --> 00:02:17,860
e sintaticamente, que imos
ter que lembrar antes de tempo.

50
00:02:17,860 --> 00:02:20,720
Pero entender que coa práctica,
iso vai comezar a ir para fóra en ti.

51
00:02:20,720 --> 00:02:24,920
>> De feito, imos concentrar no que un
función specifically-- neste caso

52
00:02:24,920 --> 00:02:26,290
dicir Hola mundo.

53
00:02:26,290 --> 00:02:27,560
Entón, digamos que é a función.

54
00:02:27,560 --> 00:02:31,320
Ola, mundo é o seu parámetro,
ou argumento, a personalización.

55
00:02:31,320 --> 00:02:34,320
>> E a equivalencia en C é só
será esta unha liña aquí,

56
00:02:34,320 --> 00:02:38,710
onde printf equivale a, digamos,
a cadea entre comiñas dobres, Ola

57
00:02:38,710 --> 00:02:41,470
mundo equivale, por suposto,
ao que está no cadro branco alí.

58
00:02:41,470 --> 00:02:45,680
E a barra invertida n, aínda que un pouco
estraña e ausente a partir de cero,

59
00:02:45,680 --> 00:02:49,380
simplemente vai ter o efecto que
ver nun ordenador, como o meu Mac ou PC,

60
00:02:49,380 --> 00:02:51,660
de só movendo o
cursor á seguinte liña.

61
00:02:51,660 --> 00:02:53,970
É como bater
Intro no teclado.

62
00:02:53,970 --> 00:02:55,580
>> Entón, imos ver iso de novo antes de tempo.

63
00:02:55,580 --> 00:02:58,640
Pero, primeiro, imos dar un ollo neste
outro exemplo, no caso de lacetes.

64
00:02:58,640 --> 00:03:02,830
Tivemos este loop para sempre na última vez,
que foi unha serie de pezas do puzzle

65
00:03:02,830 --> 00:03:05,490
que fixo algo literalmente
sempre-- neste caso

66
00:03:05,490 --> 00:03:08,360
dicir Hola mundo, Ola mundo,
Ola mundo, Ola mundo.

67
00:03:08,360 --> 00:03:10,350
Polo tanto, é un loop infinito por deseño.

68
00:03:10,350 --> 00:03:14,580
>> C, se queremos aplicar este
mesma idea, poderiamos simplemente facelo.

69
00:03:14,580 --> 00:03:19,570
Mentres verdade, printf Ola mundo-- agora
mentres, só semanticamente, tipo de

70
00:03:19,570 --> 00:03:23,090
evoca a idea de facer
algo máis dunha vez, e de novo, e de novo,

71
00:03:23,090 --> 00:03:23,980
e por canto tempo?

72
00:03:23,980 --> 00:03:27,990
Ben, lembre que true--
realidade é só o un.

73
00:03:27,990 --> 00:03:30,660
>> Certo é, por suposto, sempre certa.

74
00:03:30,660 --> 00:03:33,060
Polo tanto, é unha especie de sentido
declaración só para dicir verdade.

75
00:03:33,060 --> 00:03:36,890
Pero, en realidade, este é deliberada,
porque de ser verdade é só sempre certo,

76
00:03:36,890 --> 00:03:40,850
que mentres verdade só indica,
Un pouco indirectamente

77
00:03:40,850 --> 00:03:44,070
que as liñas de código
entre esas claves

78
00:03:44,070 --> 00:03:48,320
debe só realizar de novo, e de novo,
e de novo, e nunca realmente parar.

79
00:03:48,320 --> 00:03:50,230
>> Pero se quere que o seu
loop para deixar, como nós

80
00:03:50,230 --> 00:03:54,500
fixo a última vez con algo parecido
iso, repita os seguintes 50 veces,

81
00:03:54,500 --> 00:03:57,700
no C, podemos facer o mesmo co que hai de
chama a palabra clave para o loop--

82
00:03:57,700 --> 00:03:59,330
non sendo á vez, pero para.

83
00:03:59,330 --> 00:04:03,290
E entón temos algunha nova sintaxe aquí,
con int i é igual a 0, i inferior a 50,

84
00:04:03,290 --> 00:04:03,880
i ++.

85
00:04:03,880 --> 00:04:05,430
E nós imos voltar a iso.

86
00:04:05,430 --> 00:04:09,660
Pero iso é simplemente como iríamos
traducir o conxunto de bloques de raspadinhas

87
00:04:09,660 --> 00:04:13,079
para un conxunto de liñas de código C

88
00:04:13,079 --> 00:04:14,450
>> Mentres tanto, considerada variables.

89
00:04:14,450 --> 00:04:16,540
E, de feito, nós só
vin un un momento atrás.

90
00:04:16,540 --> 00:04:21,220
E no caso de cero, se
quería declarar unha variable chamada i

91
00:04:21,220 --> 00:04:24,590
para i sendo enteiro, só un número,
e queremos configuralo para algún valor,

92
00:04:24,590 --> 00:04:28,410
usariamos este laranxa
bloquear aqui-- establecer i a 0.

93
00:04:28,410 --> 00:04:30,800
>> E veremos hoxe e
ademais, como a semana pasada,

94
00:04:30,800 --> 00:04:33,850
programadores fan case sempre
comezar a contar desde cero, realmente

95
00:04:33,850 --> 00:04:34,950
por convención.

96
00:04:34,950 --> 00:04:37,250
Pero tamén porque recollida xunto
nosa discusión de par,

97
00:04:37,250 --> 00:04:39,990
o menor número posible
representan con calquera número de bits

98
00:04:39,990 --> 00:04:41,640
é só será 0 si.

99
00:04:41,640 --> 00:04:45,190
E por iso imos xeralmente comezan
arrincar mesmo nosas variables a 0.

100
00:04:45,190 --> 00:04:47,710
>> E en C a facer o mesmo,
imos dicir int

101
00:04:47,710 --> 00:04:50,110
por enteiro, eu só por convención.

102
00:04:50,110 --> 00:04:53,390
Podería chamar esta variable
o que eu queira, así como en perigo.

103
00:04:53,390 --> 00:04:57,770
E entón é igual a 0 só cessionários
o valor 0 da dereita

104
00:04:57,770 --> 00:05:01,319
e poñelas na variable, ou a
recipiente de almacenamento fai, na parte esquerda.

105
00:05:01,319 --> 00:05:04,360
E o punto e coma como imos see-- e
vimos algúns deses já--

106
00:05:04,360 --> 00:05:06,530
só significa final de pensamento.

107
00:05:06,530 --> 00:05:09,430
Avance para facer outra cousa
nas liñas que seguen.

108
00:05:09,430 --> 00:05:11,330
>> Agora, o que pasa con expresións booleanas?

109
00:05:11,330 --> 00:05:14,320
Lembre que en risco,
Estes eran expresións

110
00:05:14,320 --> 00:05:16,740
que son certas
ou preguntas false--,

111
00:05:16,740 --> 00:05:18,910
Realmente, que son certas ou falsas.

112
00:05:18,910 --> 00:05:21,960
Así, no caso do Scratch, poderiamos
facer unha pregunta sinxela como este,

113
00:05:21,960 --> 00:05:24,586
é i menos de 50?

114
00:05:24,586 --> 00:05:25,710
Entón eu, unha vez máis, é un número enteiro.

115
00:05:25,710 --> 00:05:27,210
Quizais estamos a usalo
nun programa de arañazos

116
00:05:27,210 --> 00:05:29,310
manter o control de unha puntuación
ou algo así.

117
00:05:29,310 --> 00:05:33,810
Polo tanto, esta sintaxe aquí Risco
Significa só que, se i menos de 50?

118
00:05:33,810 --> 00:05:37,330
Ben, por sorte, algo está
simple en C. E para traducir,

119
00:05:37,330 --> 00:05:41,780
iso sería simplemente dicir i menos
de 50, utilizando a clave familiarizados

120
00:05:41,780 --> 00:05:42,850
no teclado.

121
00:05:42,850 --> 00:05:45,141
>> Mentres tanto, se quería
dicir algo máis xeral,

122
00:05:45,141 --> 00:05:49,890
como, ben, é x menos y onde cada
de X e Y son, eles mesmos variables?

123
00:05:49,890 --> 00:05:52,280
Podemos facer o mesmo
no C, desde que temos

124
00:05:52,280 --> 00:05:53,942
creou estas variables xa.

125
00:05:53,942 --> 00:05:55,650
E veremos como
facelo antes de tempo.

126
00:05:55,650 --> 00:05:58,590
Simplemente diría x inferior a y.

127
00:05:58,590 --> 00:06:00,530
>> Entón, está empezando a
ver algunhas semellanzas.

128
00:06:00,530 --> 00:06:03,490
E aquelas persoas que fixeron
Cero eran certamente

129
00:06:03,490 --> 00:06:05,250
inspirado por algunhas destas ideas básicas.

130
00:06:05,250 --> 00:06:10,350
E vai ver este tipo de
sintaxe en moitos languages--

131
00:06:10,350 --> 00:06:12,160
non só cero, non
só C, pero Python,

132
00:06:12,160 --> 00:06:14,790
e JavaScript, e
outras linguas aínda.

133
00:06:14,790 --> 00:06:18,270
>> Imos considerar outra construción
de C, a noción dunha condición,

134
00:06:18,270 --> 00:06:20,370
facendo algo condicional.

135
00:06:20,370 --> 00:06:22,720
Se algo é certo, facelo.

136
00:06:22,720 --> 00:06:24,457
Se algo é certo, facelo.

137
00:06:24,457 --> 00:06:27,040
É unha especie de programación
equivalente a unha bifurcación na estrada.

138
00:06:27,040 --> 00:06:29,730
Quizais sexa unha de dúas vías garfo,
un garfo de tres vías, ou máis.

139
00:06:29,730 --> 00:06:32,800
E en perigo, poderiamos
visto algo así.

140
00:06:32,800 --> 00:06:34,010
>> Entón que é un gran problema.

141
00:06:34,010 --> 00:06:36,750
Pero considere o parente
simplicidade da lóxica.

142
00:06:36,750 --> 00:06:44,010
Se x é menor que y, a continuación, dicir x é menor
que Y, o resto si x é maior que Y,

143
00:06:44,010 --> 00:06:46,230
logo dicir que x é maior que y.

144
00:06:46,230 --> 00:06:48,300
E, a continuación, loxicamente, se
pensas que volta a rabuñar

145
00:06:48,300 --> 00:06:52,610
ou só a súa propia intuición humana,
así, se x non é maior que Y, e X

146
00:06:52,610 --> 00:06:57,000
non é menos que Y, entón está claro
x será igual a y.

147
00:06:57,000 --> 00:06:59,690
Polo tanto, neste caso, por asentamento
os bloques de raspadinhas,

148
00:06:59,690 --> 00:07:02,580
podemos conseguir un tres
xeito bifurcación na estrada?

149
00:07:02,580 --> 00:07:04,980
>> Mentres tanto, se queremos
facelo en C, é indiscutibelmente

150
00:07:04,980 --> 00:07:08,420
parece un pouco simpler--, polo menos,
xa que familiarizarse coa sintaxe.

151
00:07:08,420 --> 00:07:12,050
Se X é menor que Y,
printf x é inferior a y.

152
00:07:12,050 --> 00:07:16,140
Senón, se x é maior que Y,
printf x é maior que y.

153
00:07:16,140 --> 00:07:21,210
Else printf x é igual a y-- e,
unha vez máis, con aqueles barra invertida remata pronto

154
00:07:21,210 --> 00:07:24,160
para estas novas liñas de modo que se
Realmente foi este tipo de programa

155
00:07:24,160 --> 00:07:25,940
sería só mover
o cursor ao final,

156
00:07:25,940 --> 00:07:28,100
á seguinte liña da pantalla.

157
00:07:28,100 --> 00:07:31,270
>> Agora, con todo risco tivo outra
recursos máis sofisticados, única

158
00:07:31,270 --> 00:07:34,320
algúns dos cales imos
inicialmente pasar ao mundo do C.

159
00:07:34,320 --> 00:07:37,010
E un deles foi
chamado dunha lista en perigo.

160
00:07:37,010 --> 00:07:39,100
E este foi un especial
tipo de variable que

161
00:07:39,100 --> 00:07:42,840
permítelle almacenar moitas cousas
na volta, atrás, cara atrás, cara atrás.

162
00:07:42,840 --> 00:07:45,540
>> C, que non teñen
listas, de per si, pero algo

163
00:07:45,540 --> 00:07:48,090
que son máis xeralmente
chamado de matrices, aínda imos

164
00:07:48,090 --> 00:07:50,590
voltar máis tarde este semestre
a ollar para algo

165
00:07:50,590 --> 00:07:52,780
chamado dunha lista, ou realmente unha lista ligada.

166
00:07:52,780 --> 00:07:55,510
Pero, por agora, o máis próximo
equivalente en C para nós

167
00:07:55,510 --> 00:07:57,345
Vai ser algo
chamado dunha matriz.

168
00:07:57,345 --> 00:07:59,740
E unha matriz é simplemente unha
tipo especial de variable

169
00:07:59,740 --> 00:08:03,160
que lle permite almacenar datos
atrás, cara atrás, cara atrás, cara atrás.

170
00:08:03,160 --> 00:08:05,840
>> E, de feito, en perigo,
se queriamos para acceder

171
00:08:05,840 --> 00:08:09,030
o primeiro elemento dunha matriz ou
un lista-- e eu vou chamalo,

172
00:08:09,030 --> 00:08:13,600
por convención, argv, o argumento
vector, pero máis sobre iso antes de tempo.

173
00:08:13,600 --> 00:08:17,090
Se eu queira comezar no primeiro elemento
de argv, no mundo do scratch

174
00:08:17,090 --> 00:08:20,930
realmente fai normalmente
comezar a contar a partir do 1.

175
00:08:20,930 --> 00:08:22,850
>> E así eu podería obter o elemento 1 da argv.

176
00:08:22,850 --> 00:08:26,310
Isto é só como MIT aplicado
a noción de listas.

177
00:08:26,310 --> 00:08:29,860
Pero en C, vou
máis simple só dicir, argv,

178
00:08:29,860 --> 00:08:32,758
que de novo é o nome do meu
lista-- ou para ser claro, unha matriz.

179
00:08:32,758 --> 00:08:34,549
E se eu queira o primeiro
elementos, eu vou

180
00:08:34,549 --> 00:08:37,890
usar corchetes, o que
Pode non frecuentemente usado en un teclado.

181
00:08:37,890 --> 00:08:40,150
>> Pero 0 significa só, me o primeiro.

182
00:08:40,150 --> 00:08:42,160
Entón, de vez en cando e como
o tempo pasa, imos

183
00:08:42,160 --> 00:08:44,570
para comezar a ver estas dicotomias
entre cero e C,

184
00:08:44,570 --> 00:08:46,070
en que cero usa un.

185
00:08:46,070 --> 00:08:47,670
Nós en C usan 0 aquí.

186
00:08:47,670 --> 00:08:49,420
Pero vai ver rapidamente
Despois de entender

187
00:08:49,420 --> 00:08:52,920
os fundamentos de cada lingua, que
esas cousas comezan a estar aínda máis

188
00:08:52,920 --> 00:08:56,860
familiarizado coa práctica e práctica.

189
00:08:56,860 --> 00:08:59,700
>> Entón imos realmente ollar agora para un programa.

190
00:08:59,700 --> 00:09:04,031
Aquí debería ser o primeiro da nosa C
código fonte de programas completos.

191
00:09:04,031 --> 00:09:06,280
E o programa que imos
para ofrecer a consideración

192
00:09:06,280 --> 00:09:09,340
é o que equivale
para que no inicio peza cero.

193
00:09:09,340 --> 00:09:13,210
>> Entón aquí, temos o que é
sen dúbida, o programa máis simple C

194
00:09:13,210 --> 00:09:15,410
pode escribir que
realmente fai algo.

195
00:09:15,410 --> 00:09:18,250
Agora, imos ollar o pasado
por agora, ha inclúen,

196
00:09:18,250 --> 00:09:21,190
io.h serie, e ambos ángulo
corchetes, e int e baleira,

197
00:09:21,190 --> 00:09:22,840
e as chaves, e así por diante.

198
00:09:22,840 --> 00:09:25,390
>> E imos só centrar
o que, polo menos, intuitivamente,

199
00:09:25,390 --> 00:09:26,860
Pode ir para fóra en ti xa.

200
00:09:26,860 --> 00:09:30,300
De feito, o principal, eu non sei
necesariamente saben o que é iso,

201
00:09:30,300 --> 00:09:34,580
pero moi parecido cero tiña que cando
bandeira verde premendo parte do enigma,

202
00:09:34,580 --> 00:09:39,070
o mesmo ocorre con C como linguaxe de programación
ten unha peza principal de código que

203
00:09:39,070 --> 00:09:43,380
corre por defecto. E, de feito,
é, literalmente, será chamado principal.

204
00:09:43,380 --> 00:09:44,720
>> Así principal é unha función.

205
00:09:44,720 --> 00:09:48,720
E é unha función especial que hai
en C que, cando executar un programa,

206
00:09:48,720 --> 00:09:52,720
é principal que corre por
estándar. No mundo do scratch,

207
00:09:52,720 --> 00:09:56,970
era xeralmente cando a bandeira verde
premendo que foi executado por defecto.

208
00:09:56,970 --> 00:10:01,130
>> Mentres tanto, vimos isto antes,
printf ou imprimir formato, que é

209
00:10:01,130 --> 00:10:05,620
vai ser unha función que vén con
C, xunto con unha morea de outros,

210
00:10:05,620 --> 00:10:10,140
que a vontade de tempo e tempo
de novo, a fin de facer exactamente

211
00:10:10,140 --> 00:10:12,450
como o propio nome suxire, imprimir algo.

212
00:10:12,450 --> 00:10:13,500
O que queremos imprimir?

213
00:10:13,500 --> 00:10:15,770
Ben, imos ver que
por personaxes que encerran

214
00:10:15,770 --> 00:10:18,680
como o mundo these-- Ola,
barra invertida n entre comiñas dobres,

215
00:10:18,680 --> 00:10:23,040
podemos dicir exactamente printf
o que imprimir na pantalla.

216
00:10:23,040 --> 00:10:26,430
>> Pero, a fin de facer
que, por desgraza

217
00:10:26,430 --> 00:10:30,010
que tomar algo que é
xa enigmática para nós seres humanos,

218
00:10:30,010 --> 00:10:34,510
pero polo menos é algo readable--
afiada inclúen, io.h estándar, int,

219
00:10:34,510 --> 00:10:39,340
principal, baleiro, printf, toda a maxia
encantamentos que acabamos de ver na pantalla.

220
00:10:39,340 --> 00:10:42,470
Pero nós realmente temos que
ir máis misterioso aínda.

221
00:10:42,470 --> 00:10:47,140
Primeiro necesitamos traducir o código
que escribir en código máquina.

222
00:10:47,140 --> 00:10:51,370
E lembro desde a semana pasada que as máquinas,
polo menos os que sabemos aquí,

223
00:10:51,370 --> 00:10:54,450
no fin do día única
comprender ceros e uns.

224
00:10:54,450 --> 00:10:58,100
>> E, meu Deus, se tivésemos que escribir estas
ceros e uns que realmente programa,

225
00:10:58,100 --> 00:11:01,260
que sería moi, moi rápido
levar a diversión fóra de calquera cousa.

226
00:11:01,260 --> 00:11:05,150
Pero resulta que, por semana pasada
que eses patróns de ceros e uns

227
00:11:05,150 --> 00:11:06,400
só ten significado especial.

228
00:11:06,400 --> 00:11:08,500
En certos contextos,
poden significar números.

229
00:11:08,500 --> 00:11:11,840
>> Nalgúns contextos, poden significar
letras ou cores, ou calquera número

230
00:11:11,840 --> 00:11:14,710
doutras abstraccións alí enriba.

231
00:11:14,710 --> 00:11:18,450
Pero, así como o seu ordenador ten
unha CPU, Central Processing Unit,

232
00:11:18,450 --> 00:11:20,390
ou o cerebro no seu ordenador.

233
00:11:20,390 --> 00:11:22,240
É xeralmente Intel
dentro, porque iso é

234
00:11:22,240 --> 00:11:24,900
unha das maiores empresas
que fai CPUs para ordenadores.

235
00:11:24,900 --> 00:11:28,910
>> Ben, CPUs Intel e outros
simplemente decidir anticipadamente

236
00:11:28,910 --> 00:11:33,970
que certos patróns de ceros e
queridos debe significar cousas específicas.

237
00:11:33,970 --> 00:11:37,040
Certos patróns de ceros e uns
significará, imprimir esta a pantalla,

238
00:11:37,040 --> 00:11:39,710
ou engadir eses dous números, ou
restar eses dous números,

239
00:11:39,710 --> 00:11:43,310
ou mover este anaco de datos de
memoria do meu ordenador aquí,

240
00:11:43,310 --> 00:11:47,870
ou calquera número de outras nivel moi baixo,
pero en definitiva útil, operacións.

241
00:11:47,870 --> 00:11:53,022
Pero, por sorte, nós, humanos, non van
ter saber ese nivel de detalle.

242
00:11:53,022 --> 00:11:56,230
De feito, así como a última vez, onde nós
abstraída de novo, e de novo, e de novo,

243
00:11:56,230 --> 00:11:58,930
construción de moi baixo nivel
primitivos como ceros e uns

244
00:11:58,930 --> 00:12:01,160
a conceptos de nivel máis alto
como números e letras,

245
00:12:01,160 --> 00:12:04,330
e cores, e máis,
Tamén podemos como programadores

246
00:12:04,330 --> 00:12:07,080
estar sobre os ombreiros de
outros que viñeron antes de nós

247
00:12:07,080 --> 00:12:11,260
e utilizar o software que outra
persoas teñen escrito antes US--

248
00:12:11,260 --> 00:12:14,340
é dicir, programas chamados compiladores.

249
00:12:14,340 --> 00:12:17,770
>> C é unha linguaxe que
xeralmente é compilado,

250
00:12:17,770 --> 00:12:22,130
o que significa converter a partir
código fonte para código de máquina.

251
00:12:22,130 --> 00:12:25,230
En particular, o que significa isto
é que, se ten a súa fonte

252
00:12:25,230 --> 00:12:29,530
código que mesmo escribe, como nós en breve
vai en só un momento na pantalla,

253
00:12:29,530 --> 00:12:33,140
e quere convertelo-lo
finalmente, a máquina code--

254
00:12:33,140 --> 00:12:37,100
estes ceros e uns que
só o seu Mac ou PC

255
00:12:37,100 --> 00:12:41,230
understands-- ten un primeiro
alimentar ese código fonte en como

256
00:12:41,230 --> 00:12:46,340
entrada para un especial
programa chamado compilador,

257
00:12:46,340 --> 00:12:48,974
a saída dos cales nós
que ver é o código de máquina.

258
00:12:48,974 --> 00:12:51,890
E, de feito, a última vez que nos falamos
sobre, realmente, ao final do día,

259
00:12:51,890 --> 00:12:52,610
resolución de problemas.

260
00:12:52,610 --> 00:12:53,360
Ten entradas.

261
00:12:53,360 --> 00:12:54,318
E ten saídas.

262
00:12:54,318 --> 00:12:56,560
E ten algún tipo
do algoritmo no medio.

263
00:12:56,560 --> 00:12:59,830
>> Algoritmos poden certamente ser
aplicadas en software,

264
00:12:59,830 --> 00:13:02,900
como vimos con pseudocódigo a semana pasada
e, como veremos con código real

265
00:13:02,900 --> 00:13:03,490
esta semana.

266
00:13:03,490 --> 00:13:06,430
E así un compilador realmente só
ten un conxunto de algoritmos dentro

267
00:13:06,430 --> 00:13:10,060
de que sabe como
converter as palabras clave especiais,

268
00:13:10,060 --> 00:13:12,180
como principal, e printf,
e outros que acabamos

269
00:13:12,180 --> 00:13:17,620
viu nos patróns de ceros e
quen Intel dentro e outras CPUs

270
00:13:17,620 --> 00:13:20,020
realmente entende.

271
00:13:20,020 --> 00:13:22,460
Entón, como imos facelo?

272
00:13:22,460 --> 00:13:24,470
Onde é que imos conseguir un compilador?

273
00:13:24,470 --> 00:13:26,400
>> A maioría de nós aquí ten un Mac ou PC.

274
00:13:26,400 --> 00:13:29,152
E está executando Mac VOS, ou
Windows ou Linux ou Solaris,

275
00:13:29,152 --> 00:13:30,860
ou calquera número de outras
sistemas operativos.

276
00:13:30,860 --> 00:13:32,568
E, de feito, poderiamos
saír na web

277
00:13:32,568 --> 00:13:35,710
e baixar un compilador
para o seu Mac ou PC

278
00:13:35,710 --> 00:13:37,360
para o seu sistema operativo en particular.

279
00:13:37,360 --> 00:13:39,617
Pero todos nós sería en
páxinas diferentes, por así dicir.

280
00:13:39,617 --> 00:13:41,450
Teriamos algo
diferentes opcións.

281
00:13:41,450 --> 00:13:43,210
E as cousas non funcionan do mesmo xeito.

282
00:13:43,210 --> 00:13:45,280
E, de feito, a día de hoxe
moitos de nós non usan

283
00:13:45,280 --> 00:13:47,516
programa que se executa só nos nosos portátiles.

284
00:13:47,516 --> 00:13:49,390
Pola contra, usan algo
como un navegador que

285
00:13:49,390 --> 00:13:52,930
permítenos acceder web-based
aplicacións na nube.

286
00:13:52,930 --> 00:13:55,630
E aínda este semestre,
imos facer exactamente isto.

287
00:13:55,630 --> 00:13:59,660
Imos escribir aplicacións ou
software usando code-- non C,

288
00:13:59,660 --> 00:14:02,860
pero outras linguaxes como Python e
JavaScript-- que son executados na nube.

289
00:14:02,860 --> 00:14:05,860
>> E para facelo, nós mesmos
durante o semestre

290
00:14:05,860 --> 00:14:11,890
vai realmente usar unha base de nube
ambiente coñecido como CS50 IDE.

291
00:14:11,890 --> 00:14:16,030
Esta é unha programación baseada en web
ambiente ou de desenvolvemento integrado

292
00:14:16,030 --> 00:14:20,610
ambiente, IDE, que está construído enriba dalgúns
software de código aberto chamado Cloud 9.

293
00:14:20,610 --> 00:14:22,966
E nós fixemos algún pedagóxica
simplificacións para el

294
00:14:22,966 --> 00:14:25,840
para ocultar certos recursos no
as primeiras semanas que non precisa,

295
00:14:25,840 --> 00:14:27,770
Despois de que pode
revelalo-los e facer máis

296
00:14:27,770 --> 00:14:29,400
o que quere co medio ambiente.

297
00:14:29,400 --> 00:14:32,470
>> E iso nos permite, tamén, a
pre-instalar determinado programa.

298
00:14:32,470 --> 00:14:35,330
Cousas como un chamado CS50
biblioteca, que veremos en breve

299
00:14:35,330 --> 00:14:39,210
ofrece-nos en C con algún
funcionalidade adicional.

300
00:14:39,210 --> 00:14:44,392
Entón, se vai para, en última instancia, CS50.io,
lle será solicitada a entrar,

301
00:14:44,392 --> 00:14:46,350
e unha vez que fai e crear
unha conta para libre,

302
00:14:46,350 --> 00:14:52,150
será capaz de acceder a un
ambiente que parece bastante como este.

303
00:14:52,150 --> 00:14:53,760
>> Agora, iso está en modo estándar.

304
00:14:53,760 --> 00:14:55,650
Todo é bo e
brillante na pantalla.

305
00:14:55,650 --> 00:14:57,941
Moitos de nós teñen o costume de
traballando peza CS50 que é

306
00:14:57,941 --> 00:14:59,150
moi tarde para a noite.

307
00:14:59,150 --> 00:15:02,400
E así algúns de vostedes poden preferir
transformalo en modo noite, por así dicir.

308
00:15:02,400 --> 00:15:05,550
>> Pero, en definitiva, o que está
veremos dentro CS50 IDE

309
00:15:05,550 --> 00:15:08,340
é de tres areas-- distinta
unha área na que a esquerda

310
00:15:08,340 --> 00:15:12,604
os seus arquivos serán en
nube, unha área na esquina superior dereita

311
00:15:12,604 --> 00:15:14,270
onde o código será editable.

312
00:15:14,270 --> 00:15:16,650
Vai ser capaz de abrir
guías individuais para calquera programa

313
00:15:16,650 --> 00:15:19,670
que escribir este semestre dentro
dese ángulo superior dereito.

314
00:15:19,670 --> 00:15:23,070
E entón máis arcanely,
e aínda así potente,

315
00:15:23,070 --> 00:15:26,610
será esa cousa na
bottom coñecido como unha fiestra de terminal.

316
00:15:26,610 --> 00:15:29,450
>> Esta é unha vella escola
Command Line Interface,

317
00:15:29,450 --> 00:15:32,240
ou o CLI, que permite
executar comandos

318
00:15:32,240 --> 00:15:35,260
na Computador-- neste caso
o ordenador no cloud--

319
00:15:35,260 --> 00:15:39,090
para facer cousas como compilar o código
dende o código fonte para código de máquina,

320
00:15:39,090 --> 00:15:43,600
para realizar os seus programas, ou para comezar a súa
servidor web, ou para acceder a base de datos,

321
00:15:43,600 --> 00:15:47,454
e calquera número de outras técnicas
que vai comezar a usar antes de tempo.

322
00:15:47,454 --> 00:15:49,370
Pero para chegar alí, estamos
vai realmente ter

323
00:15:49,370 --> 00:15:51,240
ir en liña e comezar a xogar.

324
00:15:51,240 --> 00:15:54,399
E para facelo, imos primeiro
comezar a xogar coa principal,

325
00:15:54,399 --> 00:15:55,940
e escribir a parte principal dun programa.

326
00:15:55,940 --> 00:15:59,170
E imos usar esta función
printf, que temos utilizado anteriormente,

327
00:15:59,170 --> 00:16:01,050
simplemente para dicir algo.

328
00:16:01,050 --> 00:16:04,910
>> Entón aquí eu xa estou dentro IDE CS50.

329
00:16:04,910 --> 00:16:05,930
Teño rexistrado con antelación.

330
00:16:05,930 --> 00:16:07,360
E eu completo aparece na ventá.

331
00:16:07,360 --> 00:16:09,670
E así, en definitiva, ten
tamén en problemas próximos

332
00:16:09,670 --> 00:16:12,960
vai seguir os pasos similares que
pode fornecer a documentación en liña.

333
00:16:12,960 --> 00:16:16,360
Entón non se preocupe
absorbendo cada etapa técnica pouco

334
00:16:16,360 --> 00:16:17,730
o que fago aquí hoxe.

335
00:16:17,730 --> 00:16:19,222
>> Pero vai ter unha pantalla como esta.

336
00:16:19,222 --> 00:16:20,430
Acontece que eu estar en modo de noite.

337
00:16:20,430 --> 00:16:22,944
E pode iluminar todo
-Se desactivando o modo noite.

338
00:16:22,944 --> 00:16:24,860
E ao final da
día, vai ver

339
00:16:24,860 --> 00:16:30,090
estes tres principal areas-- o ficheiro
navegador á esquerda, as guías de código enriba,

340
00:16:30,090 --> 00:16:32,430
ea fiestra da terminal, na parte inferior.

341
00:16:32,430 --> 00:16:34,890
>> Deixe-me ir adiante e
escribir o meu primeiro programa.

342
00:16:34,890 --> 00:16:42,300
Eu estou indo a ir cautelarmente para arquivo,
Gardar e gardar o meu ficheiro como hello.c.

343
00:16:42,300 --> 00:16:46,850
En realidade, por convención, calquera que programa
gravación que está escrito na linguaxe C

344
00:16:46,850 --> 00:16:49,739
debe ser nomeado algo
dot c, por convención.

345
00:16:49,739 --> 00:16:53,030
Entón eu vou nomealo hello.c porque
Eu só quero dicir Hola para o mundo.

346
00:16:53,030 --> 00:16:54,820
Agora vou para aumentar
fóra e prema Gardar.

347
00:16:54,820 --> 00:16:58,180
E todo o que teño aquí agora é unha guía
en que eu poida comezar a escribir código.

348
00:16:58,180 --> 00:16:59,490
>> Iso non vai compilar.

349
00:16:59,490 --> 00:17:00,300
Iso non significa nada.

350
00:17:00,300 --> 00:17:02,750
E por iso mesmo que eu convertinme
isto para ceros e uns,

351
00:17:02,750 --> 00:17:05,390
a CPU terá ningunha
idea do que está a ocorrer ao redor.

352
00:17:05,390 --> 00:17:14,170
Pero se eu escribir as liñas que coinciden
-se co ser C conventions-- de C,

353
00:17:14,170 --> 00:17:20,150
de novo, esta language-- con sintaxe como
iso, printf Ola mundo-- e non teño

354
00:17:20,150 --> 00:17:22,210
sentiron cómodos con
facendo iso ao longo do tempo.

355
00:17:22,210 --> 00:17:24,510
Entón eu non creo que fixen
posibles erros tipográficos.

356
00:17:24,510 --> 00:17:27,910
>> Pero, invariablemente, o primeiro
xa que fas, vai.

357
00:17:27,910 --> 00:17:31,090
E o que eu estou a piques de facer moito pode
así non funciona para ti por primeira vez.

358
00:17:31,090 --> 00:17:33,610
E iso é perfectamente normal,
porque agora

359
00:17:33,610 --> 00:17:37,662
pode só ver unha chea de novidade,
pero co paso do tempo xa que familiarizarse

360
00:17:37,662 --> 00:17:39,870
con este ambiente, e
esta linguaxe, e outros,

361
00:17:39,870 --> 00:17:42,370
vai comezar a ver as cousas que
ou son correctas ou incorrectas.

362
00:17:42,370 --> 00:17:44,369
>> E iso é o que o
compañeiros de ensino e curso

363
00:17:44,369 --> 00:17:48,780
asistentes estar tan bo en ao longo do tempo, é
detectar erros ou erros no seu código.

364
00:17:48,780 --> 00:17:52,110
Pero aseguran que hai
hai erro neste código.

365
00:17:52,110 --> 00:17:53,990
Entón agora eu quero facer este programa.

366
00:17:53,990 --> 00:17:57,440
>> Agora no meu propio Mac ou PC, estou en
o costume de iconas dobre clic

367
00:17:57,440 --> 00:17:59,350
cando quero realizar algún programa.

368
00:17:59,350 --> 00:18:01,080
Pero iso non é o modelo aquí.

369
00:18:01,080 --> 00:18:04,570
Neste ambiente, o que é CS50 IDE.

370
00:18:04,570 --> 00:18:07,192
Estamos a usar unha operación
sistema chamado Linux.

371
00:18:07,192 --> 00:18:09,900
Linux é unha reminiscencia de outra
sistema operativo, xeralmente coñecido

372
00:18:09,900 --> 00:18:10,850
como Unix.

373
00:18:10,850 --> 00:18:16,340
E Linux é particularmente coñecido por
ter unha liña de comandos Ambiente, CLI.

374
00:18:16,340 --> 00:18:20,070
Agora, estamos a usar unha específica
sabor de Linux chamada Ubuntu.

375
00:18:20,070 --> 00:18:22,770
E Ubuntu é simplemente unha
determinada versión de Linux.

376
00:18:22,770 --> 00:18:27,900
>> Pero estes Linux nos días de hoxe fan, en realidade,
veñen con interfaces gráficas de usuario.

377
00:18:27,900 --> 00:18:30,360
E o que acontecerá co
estar a usar aquí está baseado na web.

378
00:18:30,360 --> 00:18:32,735
Polo tanto, este pode parecer ata un
pouco distinto de algo

379
00:18:32,735 --> 00:18:35,310
vostede mesmo pode ter
visto ou executado no pasado.

380
00:18:35,310 --> 00:18:37,910
>> Entón, eu estou indo a ir adiante
agora e faga o seguinte.

381
00:18:37,910 --> 00:18:40,950
Gardei este ficheiro como hello.c.

382
00:18:40,950 --> 00:18:47,350
Eu estou indo a ir adiante e
Tipo clanghello.c Entón Clang

383
00:18:47,350 --> 00:18:49,850
á linguaxe C é un compilador.

384
00:18:49,850 --> 00:18:51,952
É preinstalado no CS50 IDE.

385
00:18:51,952 --> 00:18:54,910
E pode absolutamente descargar e
instalar no seu propio Mac ou PC.

386
00:18:54,910 --> 00:18:57,910
>> Pero, unha vez máis, non ten todas
a preconfiguración feito para ti.

387
00:18:57,910 --> 00:19:00,940
Entón, por agora, eu son só
correrá clanghello.c.

388
00:19:00,940 --> 00:19:03,240
E agora entender esta sintaxe
aquí acabará

389
00:19:03,240 --> 00:19:06,930
realizar só significa que eu estou nun
carpeta ou directorio chamado Workspace.

390
00:19:06,930 --> 00:19:11,030
Este sinal de dólar é só unha convención
de sentido, escriba os comandos aquí.

391
00:19:11,030 --> 00:19:14,560
>> É o que se chama un prompt, pode
por convención é sinal de dólar.

392
00:19:14,560 --> 00:19:19,130
E se eu ir adiante agora e prema
Intro, nada parece acontecer.

393
00:19:19,130 --> 00:19:20,930
Pero iso é realmente bo.

394
00:19:20,930 --> 00:19:23,650
A menos que pasa sobre
pantalla, o máis probable

395
00:19:23,650 --> 00:19:26,710
seu código é ser correcto,
polo menos sintacticamente.

396
00:19:26,710 --> 00:19:29,120
>> Entón, se eu queira executar este
programa, o que fago?

397
00:19:29,120 --> 00:19:33,770
Ben, parece que o
nome por defecto por convención

398
00:19:33,770 --> 00:19:38,854
para os programas cando non especificar un
nomear ao seu programa só a.out.

399
00:19:38,854 --> 00:19:41,270
E esta sintaxe tamén, vai
familiarizarse con antes de tempo.

400
00:19:41,270 --> 00:19:47,500
>> Dot cortar só significa que, hey, CS50
IDE, executar un programa chamado a.out

401
00:19:47,500 --> 00:19:49,400
que está dentro do meu directorio actual.

402
00:19:49,400 --> 00:19:51,520
Isto punto significa o directorio actual.

403
00:19:51,520 --> 00:19:55,040
E imos ver o que outras secuencias
de caracteres significa antes de tempo.

404
00:19:55,040 --> 00:19:58,430
>> Entón, imos alí, Intro, Ola mundo.

405
00:19:58,430 --> 00:20:00,080
E vai notar, que o que pasou?

406
00:20:00,080 --> 00:20:01,580
Non só imprimir Ola mundo.

407
00:20:01,580 --> 00:20:05,990
Tamén movido a
cursor á seguinte liña.

408
00:20:05,990 --> 00:20:07,160
>> E por que isto?

409
00:20:07,160 --> 00:20:12,400
Cal era o código que escribiu antes
que asegurar-se que o cursor sería

410
00:20:12,400 --> 00:20:14,882
ir á seguinte liña?

411
00:20:14,882 --> 00:20:16,840
Cousa divertido sobre un
ordenador é que só vai

412
00:20:16,840 --> 00:20:18,570
para facer literalmente o que diga a el para facer.

413
00:20:18,570 --> 00:20:26,050
>> Entón, se diga a el para printf Ola,
coma, espacio, mundo, preto citas,

414
00:20:26,050 --> 00:20:29,090
é, literalmente, só vai
para imprimir estes caracteres.

415
00:20:29,090 --> 00:20:31,980
Pero eu tiña ese carácter especial
ao final, recall, barra invertida n.

416
00:20:31,980 --> 00:20:34,230
E iso é o que garantiu
que o personaxe pasou

417
00:20:34,230 --> 00:20:36,570
á seguinte liña da pantalla.

418
00:20:36,570 --> 00:20:38,097
>> En realidade, deixe-me ir e facelo.

419
00:20:38,097 --> 00:20:39,430
Deixe-me ir adiante e eliminar este.

420
00:20:39,430 --> 00:20:41,180
Agora, teña en conta que o
parte superior da miña pantalla hai

421
00:20:41,180 --> 00:20:42,890
un pouco de luz vermella na
a guía indica,

422
00:20:42,890 --> 00:20:45,047
hey, non salvou o seu arquivo.

423
00:20:45,047 --> 00:20:47,880
Entón, eu estou indo a ir adiante co control
S ou o comando S, salva o arquivo.

424
00:20:47,880 --> 00:20:51,130
Agora goes-- fun a un verde moment--.

425
00:20:51,130 --> 00:20:53,760
E agora está de volta para
só a ser un icono de preto.

426
00:20:53,760 --> 00:21:01,860
>> Se eu agora realizar clanghello.c de novo,
Intro, barra punto, a.out, enter,

427
00:21:01,860 --> 00:21:04,110
vai ver que aínda traballaba.

428
00:21:04,110 --> 00:21:06,020
Pero é, sen dúbida, un pouco buggy.

429
00:21:06,020 --> 00:21:08,714
Neste momento, o meu traballo prompt--,
e despois de que o sinal de dólar,

430
00:21:08,714 --> 00:21:10,880
e despois o meu prompt-- real
é todo na mesma liña.

431
00:21:10,880 --> 00:21:14,540
Entón, iso certamente un erro estética,
aínda que iso non é realmente un erro lóxico.

432
00:21:14,540 --> 00:21:16,250
>> Entón eu vou para desfacer o que eu fixen.

433
00:21:16,250 --> 00:21:18,560
Eu estou indo a executar de novo a.out.

434
00:21:18,560 --> 00:21:22,710
Repare que eu engadir o
newline personaxe de volta.

435
00:21:22,710 --> 00:21:24,280
Eu salvo o ficheiro.

436
00:21:24,280 --> 00:21:31,630
>> Entón, eu estou indo a executar de novo a.out, e-
caramba, un erro, un erro que supón erro.

437
00:21:31,630 --> 00:21:35,020
Así, o erro é que, aínda que
Eu engade a barra invertida n alí,

438
00:21:35,020 --> 00:21:41,180
re-gardados, re-correu o programa,
o comportamento era a mesma.

439
00:21:41,180 --> 00:21:42,640
Por que iso sería?

440
00:21:42,640 --> 00:21:43,910
>> Estou falta un paso, non?

441
00:21:43,910 --> 00:21:47,620
Ese paso clave no inicio foi que ten
a-- cando cambiar o seu código fonte,

442
00:21:47,620 --> 00:21:49,610
verifícase tamén realizar
Lo través do compilador

443
00:21:49,610 --> 00:21:51,102
novo para obter un novo código de máquina.

444
00:21:51,102 --> 00:21:52,810
E o código de máquina,
os ceros e uns,

445
00:21:52,810 --> 00:21:56,260
van ser case idéntico, pero
non perfectamente así, porque necesitamos,

446
00:21:56,260 --> 00:21:57,510
por suposto, que a nova liña.

447
00:21:57,510 --> 00:22:02,640
>> Entón, para corrixir iso, eu vou ter
executar novamente clanghello.c, entrar, dot

448
00:22:02,640 --> 00:22:03,800
slash, a.out.

449
00:22:03,800 --> 00:22:08,402
E agora, Ola mundo está de volta
onde eu esperaba que fose.

450
00:22:08,402 --> 00:22:09,610
Entón, iso é todo moi ben e bo.

451
00:22:09,610 --> 00:22:13,150
Pero a.out é un nome moi estúpido para un
programa, aínda que pasa a ser,

452
00:22:13,150 --> 00:22:16,530
por razóns históricas, o
default-- significando saídas de montaxe.

453
00:22:16,530 --> 00:22:20,780
>> Pero deixe-me ir adiante aquí
e facelo de forma distinta.

454
00:22:20,780 --> 00:22:24,760
Eu quero o meu programa Ola Mundo
para realmente ser chamado Ola.

455
00:22:24,760 --> 00:22:28,320
Entón, se fose unha icona no meu
escritorio, non sería a.out.

456
00:22:28,320 --> 00:22:29,730
Sería chamado Ola.

457
00:22:29,730 --> 00:22:33,660
>> Entón, para facelo, verifica-se
que Clang, como moitos programas,

458
00:22:33,660 --> 00:22:37,980
soporta os argumentos da liña de comandos,
ou bandeiras, ou interruptores,

459
00:22:37,980 --> 00:22:39,600
que simplemente influír no seu comportamento.

460
00:22:39,600 --> 00:22:45,160
En concreto, Clang soporta un trazo o
bandeira, que, a continuación, toma unha segunda palabra.

461
00:22:45,160 --> 00:22:48,190
Neste caso, eu vou arbitrariamente,
pero razoablemente, chamalo Ola.

462
00:22:48,190 --> 00:22:50,710
Pero eu podería chamalo algo
Quero, excepto a.out, que

463
00:22:50,710 --> 00:22:52,390
Sería moito máis alá do punto.

464
00:22:52,390 --> 00:22:55,640
>> E despois é só especificar o nome
do ficheiro que quero para compilar.

465
00:22:55,640 --> 00:22:59,190
Entón, agora mesmo que no inicio
da orde aínda teño Clang,

466
00:22:59,190 --> 00:23:01,410
ao final do comando
Eu aínda teño o nome do ficheiro,

467
00:23:01,410 --> 00:23:05,520
Agora teño eses liña de comandos
argumentos, estes sinalizados que están dicindo,

468
00:23:05,520 --> 00:23:11,180
Oh, por certo, output-o, un arquivo
chamado Ola, non o a.out estándar.

469
00:23:11,180 --> 00:23:13,810
>> Entón, se eu acertar Entre agora, nada
parece acontecer.

470
00:23:13,810 --> 00:23:17,900
E, ademais, agora podo facer barra dot Ola.

471
00:23:17,900 --> 00:23:19,089
Polo tanto, é o mesmo programa.

472
00:23:19,089 --> 00:23:21,380
Os ceros e uns son
idénticas ao final do día.

473
00:23:21,380 --> 00:23:24,210
>> Pero eles están en dous
diferente a.out files--,

474
00:23:24,210 --> 00:23:26,490
que é a primeira versión
e só tolamente nomeado,

475
00:23:26,490 --> 00:23:30,250
e agora Ola, que é un tanto
nome máis atractivo para un programa.

476
00:23:30,250 --> 00:23:33,195
Pero, honestamente, eu nunca estou
vai lembrar de novo,

477
00:23:33,195 --> 00:23:34,070
e de novo, e de novo.

478
00:23:34,070 --> 00:23:36,411
E, de feito, como se escribe
programas máis complicados,

479
00:23:36,411 --> 00:23:38,160
as ordes que está
Vai ter que escribir

480
00:23:38,160 --> 00:23:40,920
van estar aínda
aínda máis complicado.

481
00:23:40,920 --> 00:23:41,940
>> E así non se preocupe.

482
00:23:41,940 --> 00:23:46,220
Acontece que os seres humanos antes
nós xa viron que eles tamén

483
00:23:46,220 --> 00:23:47,530
tiven ese mesmo problema exacto.

484
00:23:47,530 --> 00:23:50,900
Eles non me gustaba de ter que
escribir ordes moi longos, misterioso,

485
00:23:50,900 --> 00:23:52,200
moito menos lembrar deles.

486
00:23:52,200 --> 00:23:56,070
E así os humanos antes de nós fixeron
outros programas que fan máis doado

487
00:23:56,070 --> 00:23:57,670
para compilar o seu programa.

488
00:23:57,670 --> 00:24:01,609
>> E, de feito, unha tal
programa chámase Marca.

489
00:24:01,609 --> 00:24:03,150
Entón, eu estou indo a ir adiante e facelo.

490
00:24:03,150 --> 00:24:05,691
Eu estou indo a desfacer todo o que eu
acaba de facer do seguinte xeito.

491
00:24:05,691 --> 00:24:07,690
Déixeme escribir LS.

492
00:24:07,690 --> 00:24:10,980
E verás tres coisas-
a.out, e unha estrela, Ola

493
00:24:10,980 --> 00:24:12,810
e unha estrela, e hello.c.

494
00:24:12,810 --> 00:24:14,730
Esperemos que este debe
ser un pouco intuitivo,

495
00:24:14,730 --> 00:24:18,220
na medida en que non había anteriormente
nada neste espazo de traballo.

496
00:24:18,220 --> 00:24:21,240
Non había nada que eu tiña
creado ata que comezamos a clase.

497
00:24:21,240 --> 00:24:22,840
>> E eu creei hello.c.

498
00:24:22,840 --> 00:24:24,544
Eu, entón, compilou, e chamou-a.out.

499
00:24:24,544 --> 00:24:27,460
E entón eu compilado de novo lixeiramente
diferente e chamou-lle Ola.

500
00:24:27,460 --> 00:24:32,830
Entón, eu teño tres arquivos nese directorio,
nesta carpeta chamada Workspace.

501
00:24:32,830 --> 00:24:35,005
Agora, podo ver que ben
se eu reducir en realidade.

502
00:24:35,005 --> 00:24:37,530
>> Se eu aumentar aquí e
mirar para este lado superior dereito

503
00:24:37,530 --> 00:24:39,940
canto, como prometera á esquerda
lado da pantalla

504
00:24:39,940 --> 00:24:42,990
sempre vai amosar-lle
o que está na súa conta, o que é

505
00:24:42,990 --> 00:24:44,790
dentro IDE CS50.

506
00:24:44,790 --> 00:24:46,680
E hai tres arquivos alí.

507
00:24:46,680 --> 00:24:49,070
>> Entón, quero me librar de a.out e Ola.

508
00:24:49,070 --> 00:24:51,275
E como pode
Imaxina intuitivamente, vostede

509
00:24:51,275 --> 00:24:53,400
podería tipo de control prema
ou prema co botón dereito sobre esta.

510
00:24:53,400 --> 00:24:54,590
E este pequeno menú aparece.

511
00:24:54,590 --> 00:24:57,170
Pode descargar o ficheiro, faga
Lo, velo, actualizar, eliminar,

512
00:24:57,170 --> 00:24:57,700
ou que non.

513
00:24:57,700 --> 00:25:00,260
>> E eu podería simplemente eliminar,
e ía.

514
00:25:00,260 --> 00:25:05,260
Pero imos facer as cousas cun mando
liña de momento, para estar cómodo

515
00:25:05,260 --> 00:25:07,010
con iso, e facer o seguinte.

516
00:25:07,010 --> 00:25:12,345
Eu estou indo a ir adiante e eliminar
a.out escribindo literalmente rma.out.

517
00:25:12,345 --> 00:25:14,890
Acontece que, a orde para
eliminar ou borrar algo,

518
00:25:14,890 --> 00:25:16,280
non é eliminar ou borrar.

519
00:25:16,280 --> 00:25:21,260
>> É máis brevemente RM, só para aforrar
-lle algunhas teclas, e prema Intro.

520
00:25:21,260 --> 00:25:24,707
Agora imos ser un pouco
enigmaticamente eliminar a.out ficheiro regular.

521
00:25:24,707 --> 00:25:27,040
Eu realmente non sei o que é un
arquivo irregular sería aínda.

522
00:25:27,040 --> 00:25:28,660
Pero quero eliminar-lo.

523
00:25:28,660 --> 00:25:30,150
>> Entón eu vou para escribir y para si.

524
00:25:30,150 --> 00:25:31,940
Ou eu podería escribir-lo para fóra, e prema Intro.

525
00:25:31,940 --> 00:25:33,440
E, de novo, nada parece ocorrer.

526
00:25:33,440 --> 00:25:35,840
Pero iso é, en xeral, bo.

527
00:25:35,840 --> 00:25:40,490
>> Se eu escribir LS esta vez,
o que debo ver?

528
00:25:40,490 --> 00:25:44,930
Afortunadamente, só Ola e hello.c.

529
00:25:44,930 --> 00:25:47,286
Agora, como un aparte, vai
notar esta estrela, asterisco,

530
00:25:47,286 --> 00:25:48,660
iso é o final dos meus programas.

531
00:25:48,660 --> 00:25:50,201
E tamén están aparecendo en verde.

532
00:25:50,201 --> 00:25:53,970
Isto é só a forma da CS50 IDE
de cluing-lo para o feito

533
00:25:53,970 --> 00:25:55,280
que iso non é o código fonte.

534
00:25:55,280 --> 00:25:58,880
Isto é un executable, un executable
programa que realmente pode facer

535
00:25:58,880 --> 00:26:01,020
facendo barra punto, e entón é nome.

536
00:26:01,020 --> 00:26:05,860
>> Agora, deixe-me ir adiante e eliminar
iso, rm Ola, Intro, eliminar regulares

537
00:26:05,860 --> 00:26:08,010
arquivo Ola, si.

538
00:26:08,010 --> 00:26:11,180
E agora si escribir LS,
estamos de volta a hello.c.

539
00:26:11,180 --> 00:26:13,917
Probe a non eliminar o seu
código fonte real.

540
00:26:13,917 --> 00:26:16,250
Aínda que haxa recursos
incorporado IDE CS50 onde

541
00:26:16,250 --> 00:26:19,870
pode pasar polo seu historial de revisión
e retroceder no tempo, se accidentalmente

542
00:26:19,870 --> 00:26:23,660
borrar algo, faga estar atento
por eses avisos si ou non,

543
00:26:23,660 --> 00:26:25,381
do que realmente quere facer.

544
00:26:25,381 --> 00:26:27,380
E se eu for ata o cumio
deixou canto aquí,

545
00:26:27,380 --> 00:26:30,696
todo o que queda é hello.c.

546
00:26:30,696 --> 00:26:32,570
Polo tanto, non hai acios de
outros comandos que

547
00:26:32,570 --> 00:26:37,550
Pode realizar no mundo Linux,
un dos cales é, de novo, Make.

548
00:26:37,550 --> 00:26:40,180
E nós estamos indo facer
meu programa agora como segue.

549
00:26:40,180 --> 00:26:43,270
>> No canto de facer clang,
en vez de facer clang-o,

550
00:26:43,270 --> 00:26:45,860
vou simplemente
literalmente, tipo, marca Ola.

551
00:26:45,860 --> 00:26:49,630
E agora conta, estou
non escribindo make hello.c.

552
00:26:49,630 --> 00:26:50,910
Estou escribindo make Ola.

553
00:26:50,910 --> 00:26:54,840
>> E este programa Fai ese
ven con IDE CS50, e máis

554
00:26:54,840 --> 00:26:57,090
xeralmente con Linux,
é un programa que é

555
00:26:57,090 --> 00:26:59,120
Vai facer un programa chamado Ola.

556
00:26:59,120 --> 00:27:03,680
E vai asumir, por convención,
que se este programa se pode facer,

557
00:27:03,680 --> 00:27:09,030
que será feita a partir dunha fonte
arquivo de código que terminan en c punto, hello.c.

558
00:27:09,030 --> 00:27:12,210
>> Entón, se eu prema Intro Agora, teña en conta que
a orde que se executa

559
00:27:12,210 --> 00:27:14,340
é, en realidade aínda máis
antes do que antes.

560
00:27:14,340 --> 00:27:16,670
E iso é porque temos
IDE CS50 preconfigurado para ter

561
00:27:16,670 --> 00:27:19,878
algunhas características adicionais construídos en que
Nós só non teñen, pero en breve.

562
00:27:19,878 --> 00:27:23,470
Pero a principal cousa a entender
agora eu teño un programa Ola.

563
00:27:23,470 --> 00:27:27,080
>> Se eu escribir LS novo, eu
ter un programa Ola.

564
00:27:27,080 --> 00:27:32,070
E podo executa-lo con
dot cortar a.out, non,

565
00:27:32,070 --> 00:27:35,590
porque todo o punto deste
exercicio foi dot Ola barra.

566
00:27:35,590 --> 00:27:38,089
E agora eu teño o meu programa Ola mundo.

567
00:27:38,089 --> 00:27:39,880
Entón, movendo-se para adiante,
estamos case sempre só

568
00:27:39,880 --> 00:27:42,088
indo para compilar os nosos programas
mediante o comando make.

569
00:27:42,088 --> 00:27:45,300
E entón nós estamos indo a executa-los por
dot slash, eo nome do programa.

570
00:27:45,300 --> 00:27:49,610
Pero entenden o que fan está facendo por
vostede, non é por si non é un compilador.

571
00:27:49,610 --> 00:27:53,310
É só un programa de barrio
que sabe como provocar un compilador

572
00:27:53,310 --> 00:27:56,470
para realizar para que mesmo pode usalo.

573
00:27:56,470 --> 00:28:00,220
>> Que hai outros comandos no
Linux, e á súa vez o CS50 IDE?

574
00:28:00,220 --> 00:28:03,107
Nós verá logo que hai unha
mando CD, Change Directory.

575
00:28:03,107 --> 00:28:05,190
Isto permite que dentro
súa interface de liña de comandos

576
00:28:05,190 --> 00:28:07,610
para seguir adiante, e cara atrás,
e abrir carpetas diferentes

577
00:28:07,610 --> 00:28:08,860
sen usar o rato.

578
00:28:08,860 --> 00:28:12,470
>> LS que vimos, que significa lista
os arquivos no directorio actual.

579
00:28:12,470 --> 00:28:14,650
Fai Dir, pode
probablemente comezar a inferir

580
00:28:14,650 --> 00:28:18,150
o que elas significan agora-- facer directorio,
se quere crear un cartafol.

581
00:28:18,150 --> 00:28:21,270
RM para eliminar, RM Dir para
eliminar directory-- e estes,

582
00:28:21,270 --> 00:28:24,160
unha vez máis, son a liña de comandos
equivalentes de o que

583
00:28:24,160 --> 00:28:26,945
podería facer en CS50 IDE co rato.

584
00:28:26,945 --> 00:28:28,820
Pero vai atopar en breve
que ás veces é só

585
00:28:28,820 --> 00:28:30,610
moito máis rápido que facer
cousas con un teclado,

586
00:28:30,610 --> 00:28:33,690
e, finalmente, unha máis poderosa.

587
00:28:33,690 --> 00:28:36,440
>> Pero é difícil argumentar que
calquera cousa que fixen ata agora

588
00:28:36,440 --> 00:28:39,990
é todo o que poderoso, cando todo
vimos a dicir é, Ola mundo.

589
00:28:39,990 --> 00:28:43,740
E, de feito, eu codificado a
palabras Ola Mundo no meu programa.

590
00:28:43,740 --> 00:28:45,530
Non hai dinamismo aínda.

591
00:28:45,530 --> 00:28:49,320
Scratch foi unha orde de magnitude
máis interesante a semana pasada.

592
00:28:49,320 --> 00:28:51,220
>> E así imos chegar alí.

593
00:28:51,220 --> 00:28:55,310
Imos dar un paso para que,
forma de algunhas destas funcións.

594
00:28:55,310 --> 00:28:59,470
Así, non só C veñen con printf,
e acios de outras funcións

595
00:28:59,470 --> 00:29:01,850
algúns dos cales veremos
co paso do tempo, iso non acontece

596
00:29:01,850 --> 00:29:05,760
facelo tan fácil para a dereita fora
da porta no sentido de obter a entrada do usuario.

597
00:29:05,760 --> 00:29:08,140
>> De feito, un dos puntos débiles
de linguaxes como C,

598
00:29:08,140 --> 00:29:10,140
e mesmo Java e aínda
os outros, é que non fai

599
00:29:10,140 --> 00:29:15,860
facelo doado de obter só cousas como
enteiros de usuarios, ou cordas, palabras,

600
00:29:15,860 --> 00:29:19,970
e frases, deixar as cousas só como
valores de punto ou números reais flotante

601
00:29:19,970 --> 00:29:23,240
con puntos decimais, e realmente
números longos, como veremos en breve.

602
00:29:23,240 --> 00:29:27,000
Polo tanto, esta lista de funcións aquí, estes
son como outras pezas do risco de puzzle

603
00:29:27,000 --> 00:29:31,090
que teñen pre-instalado no CS50
IDE que usaremos durante algunhas semanas

604
00:29:31,090 --> 00:29:34,010
como rodinhas de tipos e
finalmente, leva-los fora, e buscar

605
00:29:34,010 --> 00:29:37,210
por baixo da capa, quizais, en
como estas cousas son aplicadas.

606
00:29:37,210 --> 00:29:40,460
>> Pero para iso, imos
realmente escribir un programa.

607
00:29:40,460 --> 00:29:41,770
Déixeme ir adiante agora.

608
00:29:41,770 --> 00:29:44,750
E eu estou indo a crear un novo
arquivo premendo nesta pouco máis,

609
00:29:44,750 --> 00:29:45,970
e facendo clic en Novo ficheiro.

610
00:29:45,970 --> 00:29:49,250
>> Eu estou indo a gardar esta próxima
un, como, por exemplo, string.c,

611
00:29:49,250 --> 00:29:50,750
porque quero xogar con cordas.

612
00:29:50,750 --> 00:29:53,990
E cadea C é só
unha secuencia de caracteres.

613
00:29:53,990 --> 00:29:56,090
Entón agora imos adiante
e faga o seguinte.

614
00:29:56,090 --> 00:30:01,204
>> Incluír estándar IO.h-- e
verifícase se patrón de IO,

615
00:30:01,204 --> 00:30:03,360
IO significa só entrada e saída.

616
00:30:03,360 --> 00:30:05,920
Así, verifícase que
esta liña aquí é o que

617
00:30:05,920 --> 00:30:08,140
son os EUA veciña de usar printf.

618
00:30:08,140 --> 00:30:10,410
Printf, por suposto, produce unha saída.

619
00:30:10,410 --> 00:30:15,000
Polo tanto, a fin de utilizar printf, verifica-se
fóra ten que ter esta liña de código

620
00:30:15,000 --> 00:30:16,040
na parte superior do seu arquivo.

621
00:30:16,040 --> 00:30:18,456
>> E imos volver ao que
que realmente significa antes de tempo.

622
00:30:18,456 --> 00:30:20,400
Acontece que en
calquera programa C que eu escriba,

623
00:30:20,400 --> 00:30:23,640
Teño que inicia-lo con
código que se parece con isto.

624
00:30:23,640 --> 00:30:26,860
E notará CS50 IDE, e
outro desenvolvemento integrado

625
00:30:26,860 --> 00:30:30,050
ambientes como el,
van tentar o mellor

626
00:30:30,050 --> 00:30:31,780
poden rematar o seu pensamento.

627
00:30:31,780 --> 00:30:35,930
De feito, hai un momento si desfacer
o que eu fixen, eu prema Intro.

628
00:30:35,930 --> 00:30:39,160
>> Eu, entón, bateu rizados aberta
cinta, prema Intro novamente.

629
00:30:39,160 --> 00:30:40,430
E rematei o meu pensamento.

630
00:30:40,430 --> 00:30:45,140
Ela me deu unha nova liña, recuado non menos
por razóns estilísticas agradables veremos.

631
00:30:45,140 --> 00:30:48,559
E entón el automaticamente deume
que chaveta para rematar o meu pensamento.

632
00:30:48,559 --> 00:30:50,600
Agora, non sempre
adiviñar o que quere facer.

633
00:30:50,600 --> 00:30:53,620
Pero, en gran parte, fai
aforrar algunhas teclas.

634
00:30:53,620 --> 00:30:59,560
Entón, hai pouco, nós corremos ese program--
Ola, mundo, e entón compilou,

635
00:30:59,560 --> 00:31:00,460
e, a continuación, el foi.

636
00:31:00,460 --> 00:31:01,867
Pero non hai dinamismo aquí.

637
00:31:01,867 --> 00:31:03,700
O que se quixésemos
facer algo diferente?

638
00:31:03,700 --> 00:31:07,630
Ben, o que se eu quixese realmente
obter unha secuencia de usuario?

639
00:31:07,630 --> 00:31:11,250
Vou usar unha peza do puzzle
chamado precisamente isso-- obter cadea.

640
00:31:11,250 --> 00:31:15,860
>> Acontece que en C que, cando non quere
a contribuír a unha parte do enigma,

641
00:31:15,860 --> 00:31:19,360
ou máis propiamente a unha función,
literalmente só facer paréntese de apertura,

642
00:31:19,360 --> 00:31:20,430
preto parénteses.

643
00:31:20,430 --> 00:31:25,540
Por iso, é como se houbese
ningunha caixa branca para escribir en.

644
00:31:25,540 --> 00:31:27,720
O bloque de dicir antes
tiña unha pequena caixa branca.

645
00:31:27,720 --> 00:31:29,660
Non temos esa caixa branca agora.

646
00:31:29,660 --> 00:31:33,310
>> Pero cando eu chamo cadea get, I
Quere poñer o resultado en algún lugar.

647
00:31:33,310 --> 00:31:37,680
Así, un paradigma moi común en C é a
chamar unha función, como cadea de chegar aquí,

648
00:31:37,680 --> 00:31:41,070
e despois gardar o valor de retorno.

649
00:31:41,070 --> 00:31:44,450
É o resultado da súa
esforzo en algo.

650
00:31:44,450 --> 00:31:47,630
>> E cal é a
construír na programación,

651
00:31:47,630 --> 00:31:53,450
en cero ou empresa C, que
pode usar para realmente gardar algo?

652
00:31:53,450 --> 00:31:55,990
Chamou-lle unha variable, non?

653
00:31:55,990 --> 00:32:00,320
E en perigo, nós realmente non
importa o que estaba a ocorrer en variables.

654
00:32:00,320 --> 00:32:02,170
>> Pero, neste caso, nós realmente fan.

655
00:32:02,170 --> 00:32:03,719
Eu vou dicir cadea.

656
00:32:03,719 --> 00:32:05,510
E entón eu podería chamar
iso o que eu queira.

657
00:32:05,510 --> 00:32:08,340
Vou chamalo
nome, recibe obter cadea.

658
00:32:08,340 --> 00:32:10,250
>> E agora, aínda se está
algo novo para iso,

659
00:32:10,250 --> 00:32:11,984
ter en conta que eu estou falta algúns detalles.

660
00:32:11,984 --> 00:32:13,150
Estou esquecendo un punto e coma.

661
00:32:13,150 --> 00:32:14,400
Necesito rematar este pensamento.

662
00:32:14,400 --> 00:32:17,480
Entón, eu vou ir meu cursor,
e bater punto e coma alí.

663
00:32:17,480 --> 00:32:19,130
E o que eu fixen?

664
00:32:19,130 --> 00:32:21,440
Nesta liña de código,
número 5, no momento,

665
00:32:21,440 --> 00:32:23,799
Estou chamando cadea get sen entradas.

666
00:32:23,799 --> 00:32:26,090
Polo tanto, non hai pouco de branco
caixa como o Save bloque ten.

667
00:32:26,090 --> 00:32:28,590
>> Só digo, hey,
ordenador, me unha corda.

668
00:32:28,590 --> 00:32:31,390
O signo igual non é realmente
un signo igual, per se.

669
00:32:31,390 --> 00:32:33,790
É atribución
operador, o que significa,

670
00:32:33,790 --> 00:32:37,860
hey, ordenador, move o valor
da dereita á esquerda.

671
00:32:37,860 --> 00:32:40,480
E na esquerda, eu teño a seguinte.

672
00:32:40,480 --> 00:32:43,580
>> Hey, ordenador, dáme un string--
unha secuencia de caracteres.

673
00:32:43,580 --> 00:32:45,637
E chamar ese nome cadea.

674
00:32:45,637 --> 00:32:47,220
E eu nin sequera teñen que chamalo Name.

675
00:32:47,220 --> 00:32:49,970
>> Podería chamalo, convencionalmente,
algo así como S,

676
00:32:49,970 --> 00:32:52,900
así como usamos i para
chamar a variable i.

677
00:32:52,900 --> 00:32:54,829
Pero agora eu teño que facer algo con el.

678
00:32:54,829 --> 00:32:57,370
Sería moi parvo para
tente compilar este código, executando

679
00:32:57,370 --> 00:32:59,410
este programa, aínda que
Estou a recibir unha corda,

680
00:32:59,410 --> 00:33:01,580
porque aínda é só
vai dicir Hola mundo.

681
00:33:01,580 --> 00:33:06,140
>> Pero e se quero cambiar isto.

682
00:33:06,140 --> 00:33:07,940
Por que non facelo?

683
00:33:07,940 --> 00:33:11,632
Percent s, coma s.

684
00:33:11,632 --> 00:33:13,090
E iso é algo enigmática aínda.

685
00:33:13,090 --> 00:33:15,560
>> Entón deixe-me facer o meu variables máis clara.

686
00:33:15,560 --> 00:33:17,510
Déixeme citar esta Nome variable.

687
00:33:17,510 --> 00:33:20,230
E imos ver se non podemos provocar
ademais o que está pasando aquí.

688
00:33:20,230 --> 00:33:22,770
>> Entón, na liña de cinco, eu estou a recibir unha cadea.

689
00:33:22,770 --> 00:33:25,620
E eu estou almacenando esta secuencia,
todo o que o usuario introduciu no

690
00:33:25,620 --> 00:33:28,430
no teclado,
nunha variable chamada nome.

691
00:33:28,430 --> 00:33:30,590
E verifícase que
printf non só

692
00:33:30,590 --> 00:33:34,220
recibir un argumento en dobre
citas, unha entrada entre comiñas dobres.

693
00:33:34,220 --> 00:33:39,100
>> Pode levar dúas ou tres, ou máis, tales
que o segundo, ou terceiro, ou cuarto,

694
00:33:39,100 --> 00:33:42,320
son todos os nomes de variables,
ou valores en concreto,

695
00:33:42,320 --> 00:33:48,610
que pretende conectar,
dinámica, esta cadea entre comiñas.

696
00:33:48,610 --> 00:33:52,110
Noutras palabras, o que
Sería malo con iso?

697
00:33:52,110 --> 00:33:57,920
Se eu só dixen Ola nome, barra invertida
n, salvo o meu arquivo, compilado meu código,

698
00:33:57,920 --> 00:34:01,660
e foi iso, o que acontecería?

699
00:34:01,660 --> 00:34:05,139
>> É só vai dicir, Ola
citar literalmente N-A-M-E,

700
00:34:05,139 --> 00:34:07,900
que é unha especie de idiota, porque
non é diferente do mundo.

701
00:34:07,900 --> 00:34:10,400
Entón, calquera cousa entre comiñas é
o que, literalmente, imprimirase.

702
00:34:10,400 --> 00:34:12,520
Entón, se eu queira ter
un espazo reservado alí,

703
00:34:12,520 --> 00:34:14,422
En realidade, eu teño usar
algunha sintaxe especial.

704
00:34:14,422 --> 00:34:17,380
E resulta que se ler o
documentación para a función printf,

705
00:34:17,380 --> 00:34:21,320
ha dicirlle que
se usa por cento s,

706
00:34:21,320 --> 00:34:23,920
pode substituír un valor como segue.

707
00:34:23,920 --> 00:34:27,190
>> Tras unha vírgula despois diso
comiñas dobres, simplemente

708
00:34:27,190 --> 00:34:29,179
escribir o nome do
variable que quere

709
00:34:29,179 --> 00:34:33,790
para chamar a este formato
código, ou especificador de formato,

710
00:34:33,790 --> 00:34:35,469
por cento s para cordas.

711
00:34:35,469 --> 00:34:39,190
E agora, se eu teño gardado o meu arquivo,
Eu voltar o meu terminal.

712
00:34:39,190 --> 00:34:42,870
E eu tecleo Fai String,
porque, unha vez máis, o nome do presente

713
00:34:42,870 --> 00:34:45,510
arquivo que eu escollín antes é string.c.

714
00:34:45,510 --> 00:34:48,510
>> Entón eu vou dicir Fai String, entrar.

715
00:34:48,510 --> 00:34:51,550
Oh meu Deus, ollar para todos
os erros que xa fixo.

716
00:34:51,550 --> 00:34:55,540
E iso é-- o que, iso é realmente
como un, sete programa de liña de seis?

717
00:34:55,540 --> 00:34:57,790
Polo tanto, este é onde pode moi
rapidamente obter esmagadora.

718
00:34:57,790 --> 00:35:00,890
>> Esta fiestra de terminal ten
agora só regurgitado

719
00:35:00,890 --> 00:35:03,230
un gran número de mensaxes de erro.

720
00:35:03,230 --> 00:35:07,560
Certamente, eu non teño máis de erro
mensaxes que teño liñas de código.

721
00:35:07,560 --> 00:35:08,680
Entón, o que está a suceder?

722
00:35:08,680 --> 00:35:10,920
>> Ben, a mellor estratexia
para facer en calquera momento

723
00:35:10,920 --> 00:35:13,710
non atopa unha esmagadora
lista de erros como este,

724
00:35:13,710 --> 00:35:16,690
é rolar para atrás, mirar o comando
que acaba de correr que no meu caso

725
00:35:16,690 --> 00:35:18,020
é facer cadea.

726
00:35:18,020 --> 00:35:21,630
Olle para o que fan que o fixo, e que é iso
mando longo Clang, non é gran cousa alí.

727
00:35:21,630 --> 00:35:22,950
>> Pero o vermello é malo.

728
00:35:22,950 --> 00:35:24,750
Verde está tratando de ser
amable e prestativa.

729
00:35:24,750 --> 00:35:26,140
Senón que é malo, nese caso.

730
00:35:26,140 --> 00:35:27,510
Pero onde está mal?

731
00:35:27,510 --> 00:35:31,450
>> String.c, liña de cinco, cinco caracteres.

732
00:35:31,450 --> 00:35:32,930
Polo tanto, esta é só unha convención común.

733
00:35:32,930 --> 00:35:36,060
Algo colon algo significa
número de liña eo número de caracteres.

734
00:35:36,060 --> 00:35:41,080
Erro, a utilización de non declarado
cadea do identificador.

735
00:35:41,080 --> 00:35:42,900
Penso estándar en?

736
00:35:42,900 --> 00:35:45,530
>> Entón, por desgraza, Clang
está a tentar ser útil.

737
00:35:45,530 --> 00:35:46,850
Pero está mal, neste caso.

738
00:35:46,850 --> 00:35:49,350
Non, Clang, eu non quería dicir IO estándar.

739
00:35:49,350 --> 00:35:51,070
Eu quería dicir que na liña un, si.

740
00:35:51,070 --> 00:35:53,420
>> Pero a liña cinco é este aquí.

741
00:35:53,420 --> 00:35:57,040
E Clang non
entender S-T-R-I-N-L.

742
00:35:57,040 --> 00:36:01,490
É un identificador non declarado, a
palabra que nunca viu antes.

743
00:36:01,490 --> 00:36:05,730
E iso é porque C, a linguaxe
estamos escribindo código no momento

744
00:36:05,730 --> 00:36:08,070
Non ten variables chamadas cordas.

745
00:36:08,070 --> 00:36:11,380
>> Non se trata, por defecto, o soporte
algo chamado unha corda.

746
00:36:11,380 --> 00:36:16,750
Isto é unha peza de CS50
xerga, pero moi convencional.

747
00:36:16,750 --> 00:36:18,600
Pero eu podo solucionar isto como segue.

748
00:36:18,600 --> 00:36:22,090
>> Se eu engadir unha liña de código
para o inicio do programa,

749
00:36:22,090 --> 00:36:27,890
inclúen CS50.h, que é outro arquivo
nalgún lugar dentro CS50 IDE, nalgún lugar

750
00:36:27,890 --> 00:36:30,820
no disco duro, por así dicir,
do sistema operativo Ubuntu

751
00:36:30,820 --> 00:36:33,590
que eu estou correndo, que
é o ficheiro que é

752
00:36:33,590 --> 00:36:38,740
vai ensinar o funcionamento
sistema que unha cadea é, só

753
00:36:38,740 --> 00:36:41,930
como io.h estándar é o arquivo
no sistema operativo que é

754
00:36:41,930 --> 00:36:44,430
indo para ensinar-lle o que printf é.

755
00:36:44,430 --> 00:36:46,810
>> De feito, teriamos conseguido
unha mensaxe moi semellante

756
00:36:46,810 --> 00:36:50,600
Se Io tiña admitido estándar
Io.h e intentou utilizar printf.

757
00:36:50,600 --> 00:36:53,632
Entón, eu estou indo a ir adiante e só
tomar control L para limpar a miña pantalla.

758
00:36:53,632 --> 00:36:56,340
Ou podes escribir claro e vai
só limpar a fiestra de terminal.

759
00:36:56,340 --> 00:36:58,020
Pero aínda pode rolar de volta no tempo.

760
00:36:58,020 --> 00:37:01,100
>> E eu estou indo a executar de novo Fai cadea.

761
00:37:01,100 --> 00:37:03,660
Cruzar os dedos esta vez, Intro.

762
00:37:03,660 --> 00:37:05,380
Oh meu Deus, funcionou.

763
00:37:05,380 --> 00:37:09,280
me mostra unha orde longo críptica
que é o que fan xerado vía Clang,

764
00:37:09,280 --> 00:37:10,460
pero ningunha mensaxe de erro.

765
00:37:10,460 --> 00:37:12,460
Entón entende, aínda
pode estar completamente

766
00:37:12,460 --> 00:37:14,480
resaltado coa
número de mensaxes de erro,

767
00:37:14,480 --> 00:37:17,540
el só podería ser esta fervenza irritante
efecto, onde Clang non entende

768
00:37:17,540 --> 00:37:19,620
unha cousa, o que significa que, a continuación,
non entende a palabra seguinte,

769
00:37:19,620 --> 00:37:20,560
ou a liña seguinte.

770
00:37:20,560 --> 00:37:22,850
E por iso só engasga co seu código.

771
00:37:22,850 --> 00:37:24,440
Pero a corrección pode ser simple.

772
00:37:24,440 --> 00:37:27,822
E por iso sempre concentrarse no
primeira liña de saída.

773
00:37:27,822 --> 00:37:29,530
E se non o fai
comprende-lo, só tes que mirar

774
00:37:29,530 --> 00:37:32,480
para palabras clave que pode ser
pistas, eo número de liña,

775
00:37:32,480 --> 00:37:34,650
eo carácter, onde
este erro pode ser.

776
00:37:34,650 --> 00:37:40,328
>> Agora, deixe-me ir adiante e escribir
dot slash, corda, entrar.

777
00:37:40,328 --> 00:37:44,340
Hm, non está dicindo Ola nada.

778
00:37:44,340 --> 00:37:46,210
Por que?

779
00:37:46,210 --> 00:37:48,170
Ben, lembro, onde está a executar?

780
00:37:48,170 --> 00:37:53,730
>> Probablemente está preso no momento
en un loop, se quixeren, na liña seis,

781
00:37:53,730 --> 00:37:56,950
porque Obter Cordas de deseño,
escrito polo equipo CS50,

782
00:37:56,950 --> 00:38:00,350
é literalmente significa só sentir
alí esperando e esperando,

783
00:38:00,350 --> 00:38:01,850
e á espera dunha cadea.

784
00:38:01,850 --> 00:38:03,792
Todo o que quere dicir con cadea de entrada humana.

785
00:38:03,792 --> 00:38:04,500
Entón vostede sabe o que?

786
00:38:04,500 --> 00:38:05,166
Déixeme ir adiante.

787
00:38:05,166 --> 00:38:08,704
E só por un capricho, déixeme
Escribe o meu nome, David, entrar.

788
00:38:08,704 --> 00:38:10,120
Agora eu teño un programa máis dinámico.

789
00:38:10,120 --> 00:38:11,240
Dixo, Ola David.

790
00:38:11,240 --> 00:38:16,280
>> Se eu ir adiante e executar de novo,
déixeme probar dicir o nome Zamila, entrar.

791
00:38:16,280 --> 00:38:17,940
E agora temos un programa dinámico.

792
00:38:17,940 --> 00:38:19,380
Non codificado mundo.

793
00:38:19,380 --> 00:38:21,760
Non codificado
nome, ou David, ou Zamila.

794
00:38:21,760 --> 00:38:25,350
>> Agora é moito máis parecido cos programas
sabemos, en que se aproveitar a entrada,

795
00:38:25,350 --> 00:38:27,870
produce saída lixeiramente diferente.

796
00:38:27,870 --> 00:38:31,020
Agora, este non é o mellor
experiencia do usuario, ou UX.

797
00:38:31,020 --> 00:38:33,000
Executar o programa.

798
00:38:33,000 --> 00:38:35,830
>> Eu non sei o que eu debería
a facer, a menos que realmente ollar para

799
00:38:35,830 --> 00:38:37,290
ou lembrar o código fonte.

800
00:38:37,290 --> 00:38:39,640
Entón, imos facer o usuario
probar un pouco mellor

801
00:38:39,640 --> 00:38:41,240
coa máis simple das cousas.

802
00:38:41,240 --> 00:38:44,782
Déixeme volver a este
programa, e simplemente dicir printf.

803
00:38:44,782 --> 00:38:48,870
>> E deixe-me ir adiante e dicir o nome, colon,
e un espazo e, a continuación, un punto e coma.

804
00:38:48,870 --> 00:38:51,170
E só por diversión, sen descanso n.

805
00:38:51,170 --> 00:38:52,980
E iso é deliberada,
porque eu non quero

806
00:38:52,980 --> 00:38:54,590
a solicitude para mover á seguinte liña.

807
00:38:54,590 --> 00:38:58,800
>> Quero, en vez diso, facelo, faga cadea
recompilar o meu código nova máquina

808
00:38:58,800 --> 00:39:00,980
código dot cortar cadea.

809
00:39:00,980 --> 00:39:02,460
Ah, iso é moito máis fermosa.

810
00:39:02,460 --> 00:39:05,780
Agora eu realmente sei que o ordenador
quere que faga, darlle un nome.

811
00:39:05,780 --> 00:39:10,020
>> Entón, eu estou indo a ir adiante e escribir
en Rob, entrar, e Ola, Rob.

812
00:39:10,020 --> 00:39:13,640
Así, entender, esta aínda é, ao final
do día, só un programa de nove liña.

813
00:39:13,640 --> 00:39:15,090
Pero tivemos estes pasos de bebé.

814
00:39:15,090 --> 00:39:18,380
>> Nós escribir unha liña coa que
estaban familiarizados printf, Ola mundo ,.

815
00:39:18,380 --> 00:39:19,980
Logo desfixo algo diso.

816
00:39:19,980 --> 00:39:21,560
E realmente utilizados cadea get.

817
00:39:21,560 --> 00:39:23,362
E nós xogou ese valor nunha variable.

818
00:39:23,362 --> 00:39:26,070
E, a continuación, fomos adiante e mellorado
aínda máis cunha terceira liña.

819
00:39:26,070 --> 00:39:29,220
E este proceso iterativo de
escribir software é verdadeiramente clave.

820
00:39:29,220 --> 00:39:33,420
En CS50 e na vida en xeral,
normalmente non debe sentir-se,

821
00:39:33,420 --> 00:39:36,800
ten un programa en mente, e tentar escribir
a cousa toda dunha vez.

822
00:39:36,800 --> 00:39:40,810
>> Vai inevitablemente producir forma
máis erros que nós mesmos vimos aquí.

823
00:39:40,810 --> 00:39:44,070
Mesmo eu, ata hoxe, constantemente
facer outros erros estúpidos,

824
00:39:44,070 --> 00:39:47,480
son erros realmente máis difícil
que son máis difíciles de descubrir.

825
00:39:47,480 --> 00:39:52,095
Pero vai cometer máis erros máis
liñas de código que escribe todo dunha vez.

826
00:39:52,095 --> 00:39:54,220
E así esta práctica de,
escribir un pouco de código

827
00:39:54,220 --> 00:39:57,930
que está cómodo, compilar
Lo, executa-lo, proba-lo de modo máis xeral,

828
00:39:57,930 --> 00:40:01,370
a continuación, pasar on-- así como mantivemos
capas e capas a semana pasada,

829
00:40:01,370 --> 00:40:04,190
construción de algo moi
simple de algo máis complexo,

830
00:40:04,190 --> 00:40:05,200
facer o mesmo aquí.

831
00:40:05,200 --> 00:40:08,500
Non se sente, e tentar
escribir un problema enteiro.

832
00:40:08,500 --> 00:40:10,780
Realmente tomar estes pasos de bebé.

833
00:40:10,780 --> 00:40:15,100
>> Agora, cordas non son todos
tan útil para si mesmos.

834
00:40:15,100 --> 00:40:18,210
Teremos, en realidade, ideal, como a
teñen algo máis na nosa caixa de ferramentas.

835
00:40:18,210 --> 00:40:20,990
Entón imos realmente facer exactamente isto.

836
00:40:20,990 --> 00:40:24,900
>> Déixeme ir adiante agora e látego de
un programa pouco diferente.

837
00:40:24,900 --> 00:40:28,320
E nós imos chamar este int.c, por enteiro.

838
00:40:28,320 --> 00:40:30,870
Vou, do mesmo xeito,
inclúen CS550.h.

839
00:40:30,870 --> 00:40:33,060
Eu estou indo a incluír estándar IO.

840
00:40:33,060 --> 00:40:36,630
E iso vai ser moi común
nestes primeiros días de clase.

841
00:40:36,630 --> 00:40:39,050
>> E eu vou pronto
-me cunha función principal.

842
00:40:39,050 --> 00:40:43,370
E agora en vez de comezar unha corda,
imos adiante e obter un int.

843
00:40:43,370 --> 00:40:49,285
Imos chamalo i, e chamalo chegar
int, parens próximos, punto e coma.

844
00:40:49,285 --> 00:40:51,410
E agora imos facer
algo con el, printf.

845
00:40:51,410 --> 00:40:56,190
>> Imos dicir algo como
Ola, barra invertida n, coma i.

846
00:40:56,190 --> 00:41:00,010
Entón, eu estou moi ben imitando
o que eu fixen só un momento atrás.

847
00:41:00,010 --> 00:41:01,660
Eu teño un espazo reservado aquí.

848
00:41:01,660 --> 00:41:05,150
Teño coma i aquí, porque quero
para conectar i en que espazo reservado.

849
00:41:05,150 --> 00:41:07,250
>> Entón, imos adiante e experimentar
compilar este programa.

850
00:41:07,250 --> 00:41:10,060
O ficheiro é chamado int.c.

851
00:41:10,060 --> 00:41:12,920
Entón eu vou dicir, facer int, entrar.

852
00:41:12,920 --> 00:41:16,420
Oh meu Deus, pero non é gran cousa, non?

853
00:41:16,420 --> 00:41:17,230
Hai un erro.

854
00:41:17,230 --> 00:41:19,810
>> Hai un erro de sintaxe
aquí de tal forma que o programa non pode

855
00:41:19,810 --> 00:41:25,460
ser compilado dentro int.c, liña
sete, carácter 27, o formato de erro

856
00:41:25,460 --> 00:41:28,400
especifica tipo char
estrela, o que quere que sexa.

857
00:41:28,400 --> 00:41:30,020
Pero o tipo de argumento é int.

858
00:41:30,020 --> 00:41:33,110
>> Entón, aquí, tamén, non imos a--
aínda que hoxe en día é unha chea de material,

859
00:41:33,110 --> 00:41:35,710
nós estamos indo a oprimir-lo con
absolutamente todas as características do C,

860
00:41:35,710 --> 00:41:38,070
e programación dun xeito máis xeral,
en só estas primeiras semanas.

861
00:41:38,070 --> 00:41:40,400
Polo tanto, hai moitas veces vai ser xerga
co que non está familiarizado.

862
00:41:40,400 --> 00:41:43,350
E, de feito, estrela char é algo
imos volver

863
00:41:43,350 --> 00:41:44,830
en vez de unha semana ou dúas de.

864
00:41:44,830 --> 00:41:47,530
>> Pero, por agora, imos ver se podemos
analizar as palabras que son familiares.

865
00:41:47,530 --> 00:41:50,750
Formatos-- iso escoitamos formato
especificador, código de formato antes.

866
00:41:50,750 --> 00:41:51,840
Isto é familiar.

867
00:41:51,840 --> 00:41:53,840
Type-- pero o argumento ten o tipo int.

868
00:41:53,840 --> 00:41:55,980
Agarde un minuto, i é un int.

869
00:41:55,980 --> 00:41:59,230
>> Quizais por cento s en realidade,
ten algún significado definido.

870
00:41:59,230 --> 00:42:00,230
E, de feito, fai.

871
00:42:00,230 --> 00:42:03,101
Un enteiro, se quere
printf para substituílo,

872
00:42:03,101 --> 00:42:05,350
realmente ten que usar un
especificador de formato diferente.

873
00:42:05,350 --> 00:42:06,890
E non sabería que
a menos que alguén lle dixo,

874
00:42:06,890 --> 00:42:07,973
ou fixo iso antes.

875
00:42:07,973 --> 00:42:10,490
Pero o que é por cento i
pode ser utilizada

876
00:42:10,490 --> 00:42:12,240
en printf para conectar un enteiro.

877
00:42:12,240 --> 00:42:14,920
Tamén pode usar cento
d para un número enteiro decimal.

878
00:42:14,920 --> 00:42:16,490
Pero é agradable e sinxela aquí.

879
00:42:16,490 --> 00:42:17,590
Entón, imos ir con iso.

880
00:42:17,590 --> 00:42:21,160
>> Agora, deixe-me ir adiante e
reprise make int, Intro.

881
00:42:21,160 --> 00:42:23,328
Isto é bo, sen erros.

882
00:42:23,328 --> 00:42:27,260
Dot cortar OK int--, mala experiencia do usuario,
porque eu non dixen a min mesmo

883
00:42:27,260 --> 00:42:27,760
que facer.

884
00:42:27,760 --> 00:42:28,426
Pero iso é bo.

885
00:42:28,426 --> 00:42:29,480
Estou pegando rapidamente.

886
00:42:29,480 --> 00:42:36,260
>> E agora déixeme ir adiante e
escribir David, OK, Zamila, Rob.

887
00:42:36,260 --> 00:42:37,820
OK, entón iso é unha cousa boa.

888
00:42:37,820 --> 00:42:41,710
Esta vez, está a usar unha función,
unha peza do puzzle, chamado Get int.

889
00:42:41,710 --> 00:42:44,230
E pasa out-- e nós imos
ver iso máis tarde no term--

890
00:42:44,230 --> 00:42:47,730
o equipo CS50 aplicou
obter secuencia de tal forma

891
00:42:47,730 --> 00:42:50,350
que vai só fisicamente
obter unha corda para ti.

892
00:42:50,350 --> 00:42:54,340
>> El aplicou get int en
de tal forma que só pode

893
00:42:54,340 --> 00:42:55,590
obter un número enteiro para ti.

894
00:42:55,590 --> 00:42:57,830
E se, o ser humano,
non cooperar, é

895
00:42:57,830 --> 00:43:00,590
literalmente indo só para
din repetir, repetir, repetir,

896
00:43:00,590 --> 00:43:05,200
literalmente sentado alí looping, ata
vostede obrigar con algún número máxico,

897
00:43:05,200 --> 00:43:07,670
como 50, e Ola 50.

898
00:43:07,670 --> 00:43:11,440
>> Ou se executar esta nova
e escriba 42, Ola 42.

899
00:43:11,440 --> 00:43:15,750
E así a función get int
dentro dese enigma

900
00:43:15,750 --> 00:43:19,050
é a lóxica suficiente, o pensamento suficiente,
de descubrir, o que é unha palabra?

901
00:43:19,050 --> 00:43:20,330
E o que é un número?

902
00:43:20,330 --> 00:43:23,165
Só aceptar, en última instancia, números.

903
00:43:23,165 --> 00:43:25,690

904
00:43:25,690 --> 00:43:30,230
>> Así, verifícase que esta
Non é todo o que expresivo.

905
00:43:30,230 --> 00:43:30,910
moi lonxe.

906
00:43:30,910 --> 00:43:33,690
Entón, yay, última vez que
pasou moi rápido

907
00:43:33,690 --> 00:43:38,320
en xogos de execución, e animación,
e obras artísticas en cero.

908
00:43:38,320 --> 00:43:42,260
E aquí, estamos a ser contido
con Ola mundo, e Ola 50.

909
00:43:42,260 --> 00:43:43,696
>> Non é todo o que inspirado.

910
00:43:43,696 --> 00:43:46,070
E, de feito, estes primeiros
exemplos vai levar moito tempo

911
00:43:46,070 --> 00:43:47,510
a rampla ata en emoción.

912
00:43:47,510 --> 00:43:49,854
Pero temos moito máis
controlar o momento, en realidade.

913
00:43:49,854 --> 00:43:51,770
E nós estamos indo moi
iniciar rapidamente capas

914
00:43:51,770 --> 00:43:53,870
enriba destas primitivas básicas.

915
00:43:53,870 --> 00:43:56,370
>> Pero, primeiro, imos entender
cales son as limitacións.

916
00:43:56,370 --> 00:43:58,620
De feito, unha das cousas
Cero non é fácil

917
00:43:58,620 --> 00:44:00,990
imos facer é realmente ollar
por baixo da capa,

918
00:44:00,990 --> 00:44:03,740
e entender o que é un
ordenador, o que pode facer,

919
00:44:03,740 --> 00:44:05,250
e cales son as súas limitacións.

920
00:44:05,250 --> 00:44:08,580
E, de feito, que a falta de
comprensión, potencialmente, a longo prazo

921
00:44:08,580 --> 00:44:12,520
pode levar a nosa propia escrita mistakes--
erros, escribindo software inseguro que

922
00:44:12,520 --> 00:44:13,880
for cortada de algunha maneira.

923
00:44:13,880 --> 00:44:17,130
>> Entón, imos dar algúns pasos cara a
comprender isto un pouco mellor,

924
00:44:17,130 --> 00:44:19,710
forma de, digamos, o exemplo a seguir.

925
00:44:19,710 --> 00:44:23,550
Eu estou indo a ir adiante e aplicar
rapidinho un programa chamado Adder.

926
00:44:23,550 --> 00:44:25,134
Como, imos engadir algúns números xuntos.

927
00:44:25,134 --> 00:44:27,800
E eu estou indo a codificar algúns cantos
aquí, e simplemente copiar e pegar

928
00:44:27,800 --> 00:44:30,270
onde estaba antes, só
para que poidamos ir máis cedo.

929
00:44:30,270 --> 00:44:33,090
Entón agora eu teño os principios básicos
dun programa chamado Adder.

930
00:44:33,090 --> 00:44:34,670
>> E imos adiante e facelo.

931
00:44:34,670 --> 00:44:38,680
Eu estou indo a ir adiante e
digamos, IntX recibe obter int.

932
00:44:38,680 --> 00:44:39,430
E vostede sabe o que?

933
00:44:39,430 --> 00:44:40,990
Imos facer unha mellor experiencia do usuario.

934
00:44:40,990 --> 00:44:45,740
>> Entón, imos só dicir que x é e, efectivamente,
solicitar ao usuario a darnos x.

935
00:44:45,740 --> 00:44:50,600
E, a continuación, deixe-me ir adiante e dicir: printf
como sobre y é, desta vez esperando

936
00:44:50,600 --> 00:44:53,140
dous valores desde o usuario.

937
00:44:53,140 --> 00:44:59,759
E entón imos só ir adiante e
digamos, printf, a suma de x e y é.

938
00:44:59,759 --> 00:45:01,300
E agora eu non quero facer por cento s.

939
00:45:01,300 --> 00:45:09,080
Eu quero facer por cento i, barra invertida
n, e logo conecte valor da suma.

940
00:45:09,080 --> 00:45:10,620
>> Entón, como podo facer sobre iso?

941
00:45:10,620 --> 00:45:11,270
Vostede sabe o que?

942
00:45:11,270 --> 00:45:12,840
Sei como usar variables.

943
00:45:12,840 --> 00:45:15,140
Déixeme só declarar unha nova, int z.

944
00:45:15,140 --> 00:45:16,770
>> E eu vou dar un palpite aquí.

945
00:45:16,770 --> 00:45:21,470
Se hai signos iguais nesta
linguaxe, quizais eu só podo facer x máis y,

946
00:45:21,470 --> 00:45:23,660
mentres eu rematar o meu
pensou cun punto e coma?

947
00:45:23,660 --> 00:45:28,170
Agora podo volver para acá, Póñase z,
rematar este pensamento cun punto e coma.

948
00:45:28,170 --> 00:45:33,160
E imos ver agora, se estes
secuencias de lines-- x é obter int.

949
00:45:33,160 --> 00:45:34,770
Y é obter int.

950
00:45:34,770 --> 00:45:37,980
>> Agregar x e y, almacenar o valor en z--
por iso, unha vez máis, lembre o signo igual

951
00:45:37,980 --> 00:45:38,560
non é igual.

952
00:45:38,560 --> 00:45:41,100
É atribución da dereita á esquerda.

953
00:45:41,100 --> 00:45:45,180
E imos imprimir que a suma
de X e Y non é literalmente Z,

954
00:45:45,180 --> 00:45:46,830
pero o que está dentro z.

955
00:45:46,830 --> 00:45:50,090
Entón, imos facer Adder -
agradables, sen erros nesta ocasión.

956
00:45:50,090 --> 00:45:53,030
Dot cortar Adder, entrar,
x será 1.

957
00:45:53,030 --> 00:45:55,380
>> Y será 2.

958
00:45:55,380 --> 00:45:58,964
E a suma de x e y é 3.

959
00:45:58,964 --> 00:46:00,130
Entón, iso é todo moi ben e bo.

960
00:46:00,130 --> 00:46:03,260
>> Entón podes imaxinar que a matemática
deben traballar nun programa como este.

961
00:46:03,260 --> 00:46:04,040
Pero vostede sabe o que?

962
00:46:04,040 --> 00:46:06,904
É esta variable, liña
12, aínda necesario?

963
00:46:06,904 --> 00:46:09,820
Non precisa adquirir o hábito
de só almacenar cousas en variables

964
00:46:09,820 --> 00:46:10,980
só porque pode.

965
00:46:10,980 --> 00:46:13,550
E, de feito, é xeralmente
mala concepción ponderada

966
00:46:13,550 --> 00:46:18,100
se está creando unha variable chamada
z, neste caso, o almacenamento en algo que,

967
00:46:18,100 --> 00:46:21,390
e logo, inmediatamente
usalo, pero nunca de novo.

968
00:46:21,390 --> 00:46:24,700
Por que dar algo dun nome
como z, se está literalmente

969
00:46:24,700 --> 00:46:26,770
Vai usar este
cousa só unha vez, e así

970
00:46:26,770 --> 00:46:29,380
proximal ao lugar onde creou
Lo en primeiro lugar,

971
00:46:29,380 --> 00:46:31,052
tan preto en termos de liñas de código?

972
00:46:31,052 --> 00:46:31,760
Entón vostede sabe o que?

973
00:46:31,760 --> 00:46:34,480
Acontece que C é moi flexible.

974
00:46:34,480 --> 00:46:36,586
Se realmente quero
plugin valores aquí,

975
00:46:36,586 --> 00:46:38,210
Non ten declarar unha nova variable.

976
00:46:38,210 --> 00:46:41,680
Podería só plugin x máis
y porque C entende

977
00:46:41,680 --> 00:46:43,390
aritmética e operadores matemáticos.

978
00:46:43,390 --> 00:46:47,140
>> Entón, podo simplemente dicir, facer esa matemática,
x máis y, o que quere que eses valores son,

979
00:46:47,140 --> 00:46:50,780
Conecte o resultante
enteiro a esta cadea.

980
00:46:50,780 --> 00:46:53,730
Polo tanto, este pode ser, aínda que
só unha liña máis curta,

981
00:46:53,730 --> 00:46:58,480
un proxecto mellor, un programa mellor,
porque hai menos código, polo tanto,

982
00:46:58,480 --> 00:46:59,921
menos para min entender.

983
00:46:59,921 --> 00:47:01,920
E tamén é só máis limpo,
na medida en que non estamos

984
00:47:01,920 --> 00:47:04,620
introdución de novas palabras,
novos símbolos, como z,

985
00:47:04,620 --> 00:47:07,510
aínda que realmente non
serven moito dun propósito.

986
00:47:07,510 --> 00:47:12,890
>> Desafortunadamente, a matemática non é
todos os que ás veces fiables.

987
00:47:12,890 --> 00:47:15,270
Imos ir adiante e facelo.

988
00:47:15,270 --> 00:47:18,200
Eu estou indo a ir adiante
agora e faga o seguinte.

989
00:47:18,200 --> 00:47:27,650
>> Imos facer printf, cento i, ademais de por cento
i, será por cento i, barra invertida n.

990
00:47:27,650 --> 00:47:32,240
E eu vou facer isto-- xyx máis y.

991
00:47:32,240 --> 00:47:34,821
Entón eu só vou reescribir
esta un pouco diferente aquí.

992
00:47:34,821 --> 00:47:36,320
Déixeme só facer unha comprobación de sanidade rápida.

993
00:47:36,320 --> 00:47:37,986
Unha vez máis, non imos estar á fronte de nós mesmos.

994
00:47:37,986 --> 00:47:41,420
Fai víbora, punto barra víbora.

995
00:47:41,420 --> 00:47:44,950
x é 1, y é 2, 1 é máis 2 3.

996
00:47:44,950 --> 00:47:45,870
Entón, iso é bo.

997
00:47:45,870 --> 00:47:49,060
Pero imos complicar iso agora
un pouco, e crear un novo ficheiro.

998
00:47:49,060 --> 00:47:53,350
>> Vou chamar esta,
dicir, ints, plural para enteiros.

999
00:47:53,350 --> 00:47:55,980
Déixeme comezar de onde eu era un momento atrás.

1000
00:47:55,980 --> 00:47:57,770
Pero agora imos facer algunhas outras liñas.

1001
00:47:57,770 --> 00:48:03,430
Deixe-me ir adiante e facer o seguinte,
printf, cento i, menos por cento i,

1002
00:48:03,430 --> 00:48:08,959
é por cento i, coma x, coma yx menos y.

1003
00:48:08,959 --> 00:48:10,750
Entón, eu estou facendo algo
matemática diferente alí.

1004
00:48:10,750 --> 00:48:11,624
Imos facer outro.

1005
00:48:11,624 --> 00:48:16,610
Así por cento i veces por cento
i é por cento i, barra invertida n.

1006
00:48:16,610 --> 00:48:21,430
Imos plugin x e y, e x veces y de.

1007
00:48:21,430 --> 00:48:24,530
Imos usar o asterisco na
o ordenador para veces.

1008
00:48:24,530 --> 00:48:26,390
>> Non usa x. X é
un nome de variable aquí.

1009
00:48:26,390 --> 00:48:28,270
Usa a estrela para a multiplicación.

1010
00:48:28,270 --> 00:48:29,020
Imos facer un.

1011
00:48:29,020 --> 00:48:34,580
Printf por cento eu, dividido
por cento i, é por cento i,

1012
00:48:34,580 --> 00:48:40,460
n barra invertida. xy dividido por y--
para que use a barra en C

1013
00:48:40,460 --> 00:48:41,502
para facer a división.

1014
00:48:41,502 --> 00:48:42,460
E imos facer outro.

1015
00:48:42,460 --> 00:48:47,920

1016
00:48:47,920 --> 00:48:55,240
Resto por cento i, divididos
por cento i, é por cento eu.

1017
00:48:55,240 --> 00:48:59,550
xy-- e agora resta
é o que sobrou.

1018
00:48:59,550 --> 00:49:02,980
Cando tentar dividir un
denominador dentro dun numerador,

1019
00:49:02,980 --> 00:49:05,570
como é deixar ao longo deste
non podería dividir fóra?

1020
00:49:05,570 --> 00:49:07,910
>> Non hai realmente,
necesariamente, un símbolo

1021
00:49:07,910 --> 00:49:09,470
usamos na escola por iso.

1022
00:49:09,470 --> 00:49:13,830
Pero alí C. Pode
din x modulo y, onde

1023
00:49:13,830 --> 00:49:18,000
este signo por cento neste context--
confusa cando está dentro

1024
00:49:18,000 --> 00:49:20,170
das comiñas dobres,
dentro printf, cento

1025
00:49:20,170 --> 00:49:21,830
é utilizado como o especificador de formato.

1026
00:49:21,830 --> 00:49:25,420
>> Cando usa por cento fóra do
en que unha expresión matemática,

1027
00:49:25,420 --> 00:49:29,910
é o operador módulo para modular
arithmetic-- para os nosos propósitos

1028
00:49:29,910 --> 00:49:33,650
aquí, só significa, cal é a
resto X dividido polo y?

1029
00:49:33,650 --> 00:49:36,130
Así, X dividido polo y é X Y barra.

1030
00:49:36,130 --> 00:49:38,220
Cal é o resto x dividido por y?

1031
00:49:38,220 --> 00:49:41,780
É x y mod, como un programador diría.

1032
00:49:41,780 --> 00:49:48,300
>> Entón, se eu non cometeu erros aquí, déixeme
dalle facer ints, plural, agradable,

1033
00:49:48,300 --> 00:49:50,010
e ints da corte do punto.

1034
00:49:50,010 --> 00:49:55,270
E imos adiante e
facer, digamos, 1, 10.

1035
00:49:55,270 --> 00:49:58,390
Todo ben, 1, acrescido de 10 e 11, cheque.

1036
00:49:58,390 --> 00:50:01,240
1 menos 10 é negativo 9, confía.

1037
00:50:01,240 --> 00:50:03,420
>> 1 veces 10 é 10, cheque.

1038
00:50:03,420 --> 00:50:07,090
1 dividido por 10 é--
OK, imos saltar esa.

1039
00:50:07,090 --> 00:50:09,480
Resto de 1 dividido por 10 é 1.

1040
00:50:09,480 --> 00:50:10,680
Isto é correcto.

1041
00:50:10,680 --> 00:50:12,630
Pero hai un erro aquí.

1042
00:50:12,630 --> 00:50:15,390
>> Entón, o que eu poñer a miña
entregar, non é correcto.

1043
00:50:15,390 --> 00:50:16,670
Quero dicir, é próximo a 0.

1044
00:50:16,670 --> 00:50:20,670
1 dividido por 10, vostede sabe, se estivermos
cortar algúns cantos, con certeza, é cero.

1045
00:50:20,670 --> 00:50:28,050
Pero realmente debe ser 1/10,
0,1, ou 0,10, 0,1000, ou así por diante.

1046
00:50:28,050 --> 00:50:30,600
>> Non debe ser realmente cero.

1047
00:50:30,600 --> 00:50:35,990
Ben, parece que o ordenador está
facendo literalmente o que dixo para facer.

1048
00:50:35,990 --> 00:50:39,460
Estamos facendo a matemática como x dividido por y.

1049
00:50:39,460 --> 00:50:44,680
E ambos x e y, por liñas
de código anterior, son números enteiros.

1050
00:50:44,680 --> 00:50:50,440
>> Ademais, na liña 15, que son
dicindo printf, hey, printf plugin

1051
00:50:50,440 --> 00:50:54,230
un enteiro, plugin un número enteiro,
conectar un integer-- especificamente

1052
00:50:54,230 --> 00:50:57,580
x, e, a continuación, y, e logo, x
dividido por y. x e y son enteiros.

1053
00:50:57,580 --> 00:50:59,060
Somos bos alí.

1054
00:50:59,060 --> 00:51:01,250
>> Pero o que é x dividido por x?

1055
00:51:01,250 --> 00:51:06,790
X dividido polo y debe ser,
Matematicamente, 10/01, ou 0,1,

1056
00:51:06,790 --> 00:51:11,600
que é un número real, un número real
ter, potencialmente, un punto decimal.

1057
00:51:11,600 --> 00:51:13,230
Non é un número enteiro.

1058
00:51:13,230 --> 00:51:18,290
>> Pero o que é o máis próximo
número enteiro de 10/01, ou 0,1?

1059
00:51:18,290 --> 00:51:21,114
Si, tipo de é cero.

1060
00:51:21,114 --> 00:51:22,030
0,1 é así moito.

1061
00:51:22,030 --> 00:51:22,890
E 1 é moi presente.

1062
00:51:22,890 --> 00:51:25,870
Así, 1/10 está máis preto
0 que é a un.

1063
00:51:25,870 --> 00:51:30,800
>> E entón o que C está facendo por US--
tipo de porque dixo que a--

1064
00:51:30,800 --> 00:51:32,600
é truncar este completo.

1065
00:51:32,600 --> 00:51:40,540
É tomar o valor, que de novo é
debería ser algo así como 0,1 mil,

1066
00:51:40,540 --> 00:51:41,800
0 e así por diante.

1067
00:51:41,800 --> 00:51:45,320
E está truncando todo
despois do punto decimal

1068
00:51:45,320 --> 00:51:47,510
de xeito que todo isto
material, porque non

1069
00:51:47,510 --> 00:51:51,910
caben na noción dun enteiro, que
é só un número como negativo 1, 0, 1,

1070
00:51:51,910 --> 00:51:55,830
arriba e abaixo, el xoga fóra todo
despois do punto decimal porque

1071
00:51:55,830 --> 00:51:59,020
non pode caber nun punto decimal
nun número enteiro, por definición.

1072
00:51:59,020 --> 00:52:01,290
>> Polo tanto, a resposta aquí é cero.

1073
00:52:01,290 --> 00:52:02,600
Entón, como podemos solucionar isto?

1074
00:52:02,600 --> 00:52:04,400
Necesitamos unha outra solución en conxunto.

1075
00:52:04,400 --> 00:52:06,880
E podemos facer iso, como segue.

1076
00:52:06,880 --> 00:52:12,820
>> Deixe-me ir adiante e crear unha nova
ficheiro, este chamado floats.c.

1077
00:52:12,820 --> 00:52:16,500
E gardalo aquí no
mesmo directorio, float.c.

1078
00:52:16,500 --> 00:52:19,360

1079
00:52:19,360 --> 00:52:23,260
E deixe-me ir adiante e copiar
algúns de que o código de antes.

1080
00:52:23,260 --> 00:52:27,690
>> Pero en vez de estar
un int, imos facelo.

1081
00:52:27,690 --> 00:52:31,037
Dáme un valor de punto flotante
chamado x. onde un punto flotante

1082
00:52:31,037 --> 00:52:33,370
valor é só literalmente
algo cun punto flotante.

1083
00:52:33,370 --> 00:52:34,410
Pode mover-se cara á esquerda, á dereita.

1084
00:52:34,410 --> 00:52:35,530
É un número real.

1085
00:52:35,530 --> 00:52:38,050
>> E deixe-me chamar
obter int, pero chegar float,

1086
00:52:38,050 --> 00:52:41,420
que tamén estaba entre o menú
de opcións na biblioteca C250.

1087
00:52:41,420 --> 00:52:43,220
Imos cambiar y a unha boia.

1088
00:52:43,220 --> 00:52:45,000
Polo tanto, este pasa a ser obter float.

1089
00:52:45,000 --> 00:52:47,620
>> E agora, nós non queremos para conectar ints.

1090
00:52:47,620 --> 00:52:53,130
Acontece que temos que usar cento
f para float, por cento f para float,

1091
00:52:53,130 --> 00:52:54,560
e agora salvalo.

1092
00:52:54,560 --> 00:53:01,220
E agora, dedos cruzados, facer
flotadores, agradable, flotadores da corte de punto.

1093
00:53:01,220 --> 00:53:04,280
x será un 1. y
Será 10 de novo.

1094
00:53:04,280 --> 00:53:08,240
>> E, bo, OK miña banda é correcta.

1095
00:53:08,240 --> 00:53:10,240
Eu estaba esperando por máis,
pero eu esquezo de escribir.

1096
00:53:10,240 --> 00:53:13,250
Entón, imos ir e corrixir este erro lóxico.

1097
00:53:13,250 --> 00:53:16,280
>> Imos adiante e coller o seguinte.

1098
00:53:16,280 --> 00:53:18,080
Nós imos só facer un pouco de copiar e pegar.

1099
00:53:18,080 --> 00:53:20,080
E eu vou dicir de menos.

1100
00:53:20,080 --> 00:53:21,890
>> E eu vou dicir veces.

1101
00:53:21,890 --> 00:53:24,060
E eu vou dicir dividida.

1102
00:53:24,060 --> 00:53:28,240
E eu non vou facer modulo,
que non é tan pertinentes aquí,

1103
00:53:28,240 --> 00:53:33,690
dividido por f, e veces plus--
OK, imos facelo de novo.

1104
00:53:33,690 --> 00:53:44,210
>> Fan flotadores, boias de barra punto,
e 1, 10, e- agradable, non, OK.

1105
00:53:44,210 --> 00:53:45,250
Entón, eu son un idiota.

1106
00:53:45,250 --> 00:53:47,000
Entón, iso é moi común
en ciencia da computación

1107
00:53:47,000 --> 00:53:49,780
cometendo erros estúpidos como este.

1108
00:53:49,780 --> 00:53:53,100
>> Para fins pedagóxicos,
o que realmente quería facer

1109
00:53:53,100 --> 00:53:57,410
foi cambiar a ciencia aquí
para máis, a menos, á época,

1110
00:53:57,410 --> 00:54:01,140
e para dividir, como espera
notado durante este exercicio.

1111
00:54:01,140 --> 00:54:04,700
Entón agora imos volver compilar este
programa, faga flotadores da corte de punto.

1112
00:54:04,700 --> 00:54:07,950
>> E por terceira vez, imos
ver se atende ás miñas expectativas.

1113
00:54:07,950 --> 00:54:21,480
1, 10, entrar, si, OK, 1000,
dividido por 10,000, é 0,100000.

1114
00:54:21,480 --> 00:54:24,952
E resulta que podemos controlar cantas
números son despois destes puntos decimais.

1115
00:54:24,952 --> 00:54:25,660
Nós realmente vai.

1116
00:54:25,660 --> 00:54:26,790
Nós imos voltar a iso.

1117
00:54:26,790 --> 00:54:28,440
>> Pero agora, de feito, a matemática é correcta.

1118
00:54:28,440 --> 00:54:30,090
Entón, unha vez máis, que é o takeaway aquí?

1119
00:54:30,090 --> 00:54:33,050
Acontece que en C, existen
non só só strings-- e, de feito,

1120
00:54:33,050 --> 00:54:36,120
non hai realmente, porque nós
engadir aqueles coa biblioteca CS50.

1121
00:54:36,120 --> 00:54:37,710
Pero non son só números enteiros.

1122
00:54:37,710 --> 00:54:38,990
>> Tamén flota.

1123
00:54:38,990 --> 00:54:42,810
E verifícase un monte de outros datos
tipo tamén, que usaremos en pouco tempo.

1124
00:54:42,810 --> 00:54:46,270
Acontece que se quere un único
carácter, e non unha cadea de caracteres,

1125
00:54:46,270 --> 00:54:47,610
pode usar só un char.

1126
00:54:47,610 --> 00:54:52,350
>> Acontece que, se quere un bool,
un valor booleano, único verdadeiro ou falso,

1127
00:54:52,350 --> 00:54:56,840
grazas á biblioteca CS50, temos
engadido a C, o tipo de datos booleano ben.

1128
00:54:56,840 --> 00:54:59,180
Pero tamén está presente en
moitas outras linguas tamén.

1129
00:54:59,180 --> 00:55:04,130
E resulta que ás veces
precisan de números grandes, a continuación, veñen por defecto

1130
00:55:04,130 --> 00:55:05,210
con ints e Carrozas.

1131
00:55:05,210 --> 00:55:10,590
>> E, de feito, un dobre é un número
que usa nin 32 bits, pero 64 bits.

1132
00:55:10,590 --> 00:55:14,990
E un longo tempo é un número que
usa nin 32, bits, pero 64 bits,

1133
00:55:14,990 --> 00:55:19,190
respectivamente, para punto flotante
valores e enteiros, respectivamente.

1134
00:55:19,190 --> 00:55:22,780
Entón imos realmente agora
ver iso en acción.

1135
00:55:22,780 --> 00:55:26,150
>> Eu estou indo a ir adiante aquí
e látego dun navegador.

1136
00:55:26,150 --> 00:55:32,020
Aquí, eu estou indo a ir adiante
e non inclúen CS50.h.

1137
00:55:32,020 --> 00:55:34,910
E deixe-me ir, inclúen por defecto IO.h.

1138
00:55:34,910 --> 00:55:37,320
>> E vai notar algo
funky está pasando aquí.

1139
00:55:37,320 --> 00:55:40,592
Non é codificación de cores as cousas en
do mesmo xeito como facía antes.

1140
00:55:40,592 --> 00:55:43,550
E ao parecer, iso é porque eu
non deron a cousa un nome de ficheiro.

1141
00:55:43,550 --> 00:55:47,270
>> Vou chamar esta
sizeof.c, e bateu en Gardar.

1142
00:55:47,270 --> 00:55:51,039
E teña en conta o que pasa co meu moi
código de branco contra este pano de fondo negro.

1143
00:55:51,039 --> 00:55:52,830
Agora, polo menos hai
Nalgúns roxos alí.

1144
00:55:52,830 --> 00:55:54,490
E é sintaxe destacada.

1145
00:55:54,490 --> 00:55:57,700
>> Isto é porque, moi simplemente, non teño
dixo ao IDE que tipo de ficheiro

1146
00:55:57,700 --> 00:56:01,060
iso é dándolle un nome, e
especialmente unha extensión de arquivo.

1147
00:56:01,060 --> 00:56:03,620
Agora, imos ir adiante e facelo.

1148
00:56:03,620 --> 00:56:08,910
Eu estou indo a ir adiante e moi
simplemente imprimir o bool following--

1149
00:56:08,910 --> 00:56:11,080
é por cento LU.

1150
00:56:11,080 --> 00:56:12,950
>> Nós imos volver
que en só un momento.

1151
00:56:12,950 --> 00:56:15,840
E entón eu vou
tamaño de impresión de bool.

1152
00:56:15,840 --> 00:56:18,170
E agora, só para aforrar
-me un tempo, eu son

1153
00:56:18,170 --> 00:56:20,280
fará un todo
banda deles á vez.

1154
00:56:20,280 --> 00:56:24,620
E, especialmente, eu vou
cambiar isto para un char e carbón.

1155
00:56:24,620 --> 00:56:27,760
Este, eu vou cambiar
para unha parella e unha de matrimonio.

1156
00:56:27,760 --> 00:56:31,440
>> Este, eu vou cambiar
a unha boia e un flotador.

1157
00:56:31,440 --> 00:56:35,670
Este, eu vou
cambiar a un int e un int.

1158
00:56:35,670 --> 00:56:38,660
E este, eu vou
para cambiar a un longo tempo.

1159
00:56:38,660 --> 00:56:40,840
E aínda está tomando
un longo tempo, moito tempo.

1160
00:56:40,840 --> 00:56:44,572
>> E entón, finalmente, dei
me un demasiados, corda.

1161
00:56:44,572 --> 00:56:47,030
Acontece que en C, non hai
o operador especial chamado

1162
00:56:47,030 --> 00:56:50,260
tamaño do que é, literalmente,
Vai, cando se executa,

1163
00:56:50,260 --> 00:56:52,099
Díganos o tamaño do
Cada unha destas variables.

1164
00:56:52,099 --> 00:56:53,890
E este é un camiño, agora,
podemos chamar de volta

1165
00:56:53,890 --> 00:56:57,140
a discusión da semana pasada
de datos e de representación.

1166
00:56:57,140 --> 00:57:00,330
>> Deixe-me ir adiante e compilar
tamaño tamaño de punto de corte.

1167
00:57:00,330 --> 00:57:01,210
E veremos.

1168
00:57:01,210 --> 00:57:05,210
Acontece que en C,
especialmente en CS50 IDE,

1169
00:57:05,210 --> 00:57:08,170
especialmente na
sistema operativo Ubuntu,

1170
00:57:08,170 --> 00:57:11,100
que é un operativo de 64 bits
sistema, neste caso,

1171
00:57:11,100 --> 00:57:14,189
un booleano vai
usar un byte de espazo.

1172
00:57:14,189 --> 00:57:16,480
É así que o tamaño é medida,
non en bits, pero en bytes.

1173
00:57:16,480 --> 00:57:18,690
E lembrar que un byte é oito bits.

1174
00:57:18,690 --> 00:57:22,030
Así, un bool, aínda que
tecnicamente só precisa dun 0 ou 1,

1175
00:57:22,030 --> 00:57:24,092
é un pouco desperdicio
como temos implantado.

1176
00:57:24,092 --> 00:57:26,800
Realmente vai utilizar un todo
byte-- para que todos os ceros, son talvez

1177
00:57:26,800 --> 00:57:31,050
todos aqueles, ou algo así,
ou só un 1 entre os oito bits.

1178
00:57:31,050 --> 00:57:34,962
>> Un char, á súa vez, usado para un personaxe
como un carácter ASCII por semana pasada

1179
00:57:34,962 --> 00:57:36,170
será un personaxe.

1180
00:57:36,170 --> 00:57:42,340
E que sincroniza-se coa nosa noción de
sendo non máis que 256 bits-- vez,

1181
00:57:42,340 --> 00:57:45,360
sincroniza-se con el habendo
máis de 8 bits, que

1182
00:57:45,360 --> 00:57:47,450
dános ata 256 valores.

1183
00:57:47,450 --> 00:57:49,680
O dúo vai
ser de 8 bytes ou 64 bits.

1184
00:57:49,680 --> 00:57:50,510
>> Un flotador é 4.

1185
00:57:50,510 --> 00:57:51,690
Un int é de 4.

1186
00:57:51,690 --> 00:57:52,980
Un longo, longo é 8.

1187
00:57:52,980 --> 00:57:54,716
E unha corda é 8.

1188
00:57:54,716 --> 00:57:55,840
Pero non se preocupe con iso.

1189
00:57:55,840 --> 00:57:57,340
Nós imos pelar esa capa.

1190
00:57:57,340 --> 00:57:59,940
Acontece que, cordas poden
ter máis de 8 bytes.

1191
00:57:59,940 --> 00:58:02,310
>> E, de feito, escribimos
cordas xa, Ola mundo,

1192
00:58:02,310 --> 00:58:03,700
máis de 8 bytes.

1193
00:58:03,700 --> 00:58:06,270
Pero imos voltar a
que en só un momento.

1194
00:58:06,270 --> 00:58:09,690
Pero a toma de distancia aquí é o seguinte.

1195
00:58:09,690 --> 00:58:15,320
>> Calquera ordenador só ten unha finita
cantidade de memoria e espazo.

1196
00:58:15,320 --> 00:58:17,860
Só podes gardar tantos
ficheiros no seu Mac ou PC.

1197
00:58:17,860 --> 00:58:23,030
Só podes gardar tantos programas
RAM funcionando á vez, necesariamente, mesmo

1198
00:58:23,030 --> 00:58:26,360
coa memoria virtual, porque
ten unha cantidade finita de RAM.

1199
00:58:26,360 --> 00:58:28,990
>> E só para picture-- se
nunca abriu un portátil

1200
00:58:28,990 --> 00:58:31,300
ou encomendados memoria extra
para un ordenador,

1201
00:58:31,300 --> 00:58:33,670
Pode non saber que
dentro do seu ordenador

1202
00:58:33,670 --> 00:58:36,590
é algo que se parece
algo como isto.

1203
00:58:36,590 --> 00:58:40,540
Polo tanto, esta é só unha empresa común denominado
Crucial que fai RAM para ordenadores.

1204
00:58:40,540 --> 00:58:43,620
E RAM é onde os programas
vivir mentres eles están executando.

1205
00:58:43,620 --> 00:58:46,630
>> Así, en todos os Mac ou PC, cando dobrar
clic nun programa, e abre,

1206
00:58:46,630 --> 00:58:48,921
e abre un documento de Word
ou algo así,

1207
00:58:48,921 --> 00:58:51,764
almacena-o temporal na
RAM, RAM porque é máis rápido

1208
00:58:51,764 --> 00:58:53,680
que o seu disco duro, ou
o disco de estado sólido.

1209
00:58:53,680 --> 00:58:56,600
Entón é só onde os programas ir
para vivir cando están en execución,

1210
00:58:56,600 --> 00:58:58,060
ou cando os ficheiros están a ser empregados.

1211
00:58:58,060 --> 00:59:00,890
>> Entón tes cousas que parecen
como este no seu portátil,

1212
00:59:00,890 --> 00:59:03,320
ou cousas un pouco máis grande
dentro da súa área de traballo.

1213
00:59:03,320 --> 00:59:07,440
Pero a clave é que só ten un
número finito destas cousas.

1214
00:59:07,440 --> 00:59:11,230
E só hai unha cantidade finita de
hardware sentado nesa mesa dereita

1215
00:59:11,230 --> 00:59:11,730
aquí.

1216
00:59:11,730 --> 00:59:15,920
>> Entón, por suposto, non podemos almacenar
números infinitamente longos.

1217
00:59:15,920 --> 00:59:19,030
E, ademais, se pensas que volta a
escola, cantos díxitos pode

1218
00:59:19,030 --> 00:59:21,400
tes á dereita
dun punto decimal?

1219
00:59:21,400 --> 00:59:24,680
A esta materia, cantos díxitos poden
tes á esquerda do punto decimal?

1220
00:59:24,680 --> 00:59:26,300
Realmente, infinitamente moitos.

1221
00:59:26,300 --> 00:59:30,840
>> Agora, nós, seres humanos só podería
sabe como se pronuncia millóns,

1222
00:59:30,840 --> 00:59:34,990
e millóns, billóns, e
quatrilhões, e quintilhões.

1223
00:59:34,990 --> 00:59:39,370
E eu estou empurrando os límites do meu
understanding-- ou meu-- entendo

1224
00:59:39,370 --> 00:59:41,110
números, pero o meu
pronuncia dos números.

1225
00:59:41,110 --> 00:59:44,720
Pero poden obter infinitamente grande, con
infinitos díxitos á esquerda

1226
00:59:44,720 --> 00:59:47,050
ou á dereita dun punto decimal.

1227
00:59:47,050 --> 00:59:50,040
>> Pero os ordenadores teñen só un
cantidade finita de memoria,

1228
00:59:50,040 --> 00:59:53,510
un número finito de transistores, un
número finito de lámpadas no interior.

1229
00:59:53,510 --> 00:59:57,350
Entón, o que ocorre cando
executar para fóra do espazo?

1230
00:59:57,350 --> 00:59:59,620
Noutras palabras, se
pensar cara atrás a semana pasada

1231
00:59:59,620 --> 01:00:03,160
cando falamos números
-Se a ser representado en binario,

1232
01:00:03,160 --> 01:00:05,480
supoñamos que temos
este valor de 8 bits aquí.

1233
01:00:05,480 --> 01:00:08,290
>> E nós temos sete 1 e un 0.

1234
01:00:08,290 --> 01:00:10,827
E supoña que queremos
para engadir 1 a este valor.

1235
01:00:10,827 --> 01:00:12,410
Este é un número moi grande agora.

1236
01:00:12,410 --> 01:00:16,610
>> Este é 254, se ben me lembra
a matemática da semana pasada dereita.

1237
01:00:16,610 --> 01:00:19,480
Pero o que se eu cambiar
0 que máis á dereita dun 1?

1238
01:00:19,480 --> 01:00:22,800
O número enteiro, de
Por suposto, se converte oito 1s.

1239
01:00:22,800 --> 01:00:24,050
Polo tanto, aínda é bo.

1240
01:00:24,050 --> 01:00:27,204
>> E que probablemente representa
255, aínda que dependendo do contexto

1241
01:00:27,204 --> 01:00:29,120
podería realmente representar
un número negativo.

1242
01:00:29,120 --> 01:00:31,240
Pero máis sobre iso de novo.

1243
01:00:31,240 --> 01:00:34,220
Este parece que é
tan alto como podo contar.

1244
01:00:34,220 --> 01:00:35,290
>> Agora é só 8 bits.

1245
01:00:35,290 --> 01:00:38,170
E o meu Mac, con certeza, ten forma
máis de 8 bits de memoria.

1246
01:00:38,170 --> 01:00:39,170
Pero ten finito.

1247
01:00:39,170 --> 01:00:43,230
Así, o mesmo argumento aplícase, aínda que
temos máis destes queridos na pantalla.

1248
01:00:43,230 --> 01:00:47,020
>> Pero o que acontece se está
almacenar este número, 255,

1249
01:00:47,020 --> 01:00:49,290
e quere contar un pouco máis alto?

1250
01:00:49,290 --> 01:00:51,600
Queres ir de 255 a 256.

1251
01:00:51,600 --> 01:00:55,800
O problema, por suposto, é que se
comezar a contar desde cero como a semana pasada,

1252
01:00:55,800 --> 01:00:59,670
non pode contar como alto
como 256, moito menos 257,

1253
01:00:59,670 --> 01:01:02,584
moito menos 258, m porque o que
ocorre cando engade un 1?

1254
01:01:02,584 --> 01:01:05,000
Se fai a escola primaria antiga
visión, pór un 1 aquí,

1255
01:01:05,000 --> 01:01:08,150
e logo, 1 máis 1 e 2, pero iso é
realmente un cero, leva a 1,

1256
01:01:08,150 --> 01:01:09,695
transportar a 1, levar a 1.

1257
01:01:09,695 --> 01:01:12,620
Todas estas cousas,
Estas 1, ir a cero.

1258
01:01:12,620 --> 01:01:17,820
E acabar, si, como alguén
apuntou, a 1 sobre o lado esquerdo.

1259
01:01:17,820 --> 01:01:22,540
Pero todo o que poida
realmente ver e caber na memoria

1260
01:01:22,540 --> 01:01:27,960
é só oito 0 do, o que quere dicir
nalgún momento, se, un ordenador,

1261
01:01:27,960 --> 01:01:32,490
intentou conta alta abondo, está
vai implicar en torno a, ao parecer,

1262
01:01:32,490 --> 01:01:35,850
a cero, ou quizais mesmo negativo
números, que son aínda máis baixos que cero.

1263
01:01:35,850 --> 01:01:37,260
>> E pode tipo de ver iso.

1264
01:01:37,260 --> 01:01:39,900
Deixe-me ir adiante e escribir
un verdadeiro programa rápido aquí.

1265
01:01:39,900 --> 01:01:43,690
Deixe-me ir adiante e escribir
un programa chamado estourido.

1266
01:01:43,690 --> 01:01:49,980
Incluír CS50.h, inclúen
estándar IO.h-- oh,

1267
01:01:49,980 --> 01:01:51,730
Realmente perdín o meu destaque de sintaxe.

1268
01:01:51,730 --> 01:01:54,440
Entón, imos gardalo como overflow.c.

1269
01:01:54,440 --> 01:01:57,084
>> E void-- principal agora int
e en pouco tempo, imos

1270
01:01:57,084 --> 01:01:59,500
volver explicar por que
nós seguir a escribir void main int.

1271
01:01:59,500 --> 01:02:02,080
Pero, polo de agora, imos só facer
Lo, leva-lo para concedida.

1272
01:02:02,080 --> 01:02:06,200
Imos dar-me un int,
e Inicialize-o a 0.

1273
01:02:06,200 --> 01:02:11,716
>> Imos entón facer por int i obter zero--
en realidade, imos facer un loop infinito

1274
01:02:11,716 --> 01:02:12,590
e ver que pasa.

1275
01:02:12,590 --> 01:02:22,440
Mentres verdade, entón imos imprimir n
é por cento i, barra invertida n, plugin n.

1276
01:02:22,440 --> 01:02:27,200
Pero, agora, imos facer n recibe n + 1.

1277
01:02:27,200 --> 01:02:29,660
>> Polo tanto, noutras palabras, en cada
iteración deste ciclo infinito,

1278
01:02:29,660 --> 01:02:32,550
imos dar o valor de n,
e engadir 1 a el, e, a continuación,

1279
01:02:32,550 --> 01:02:34,350
almacenar o resultado en N na esquerda.

1280
01:02:34,350 --> 01:02:37,150
E, de feito, xa vimos a sintaxe
algo como este, brevemente.

1281
01:02:37,150 --> 01:02:39,730
Un truco legal é, en vez
de escribir todo isto,

1282
01:02:39,730 --> 01:02:42,770
realmente pode dicir un n máis é igual a 1.

1283
01:02:42,770 --> 01:02:47,480
>> Ou se o quere ser extravagante,
pode dicir n plus plus e coma.

1284
01:02:47,480 --> 01:02:50,130
Pero estes dous últimos son só
o que chamaría de azucre sintático

1285
01:02:50,130 --> 01:02:50,790
para o primeiro.

1286
01:02:50,790 --> 01:02:53,456
>> O primeiro é máis explícito,
totalmente ben, totalmente correcta.

1287
01:02:53,456 --> 01:02:55,470
Pero iso é máis común, eu vou dicir.

1288
01:02:55,470 --> 01:02:57,210
Entón, imos facelo por só un momento.

1289
01:02:57,210 --> 01:03:01,685
>> Imos agora facer estourido, o que soa
moi sinistro, estourido de corte de punto.

1290
01:03:01,685 --> 01:03:04,380

1291
01:03:04,380 --> 01:03:09,852
Imos ver, n está quedando moi grande.

1292
01:03:09,852 --> 01:03:11,310
Pero imos pensar, o no; gran pode n recibir?

1293
01:03:11,310 --> 01:03:12,870
>> n é un número enteiro.

1294
01:03:12,870 --> 01:03:16,400
Vimos hai pouco co tamaño do
exemplo, que é un int catro bytes.

1295
01:03:16,400 --> 01:03:22,070
Sabemos da semana pasada, catro bytes é
32 bits, xa 8 veces 4, que ten 32 anos.

1296
01:03:22,070 --> 01:03:23,460
Isto vai ser de 4 millóns.

1297
01:03:23,460 --> 01:03:25,802
>> E somos ata 800.000.

1298
01:03:25,802 --> 01:03:28,510
Isto vai levar unha eternidade para
contar tan alto como poida.

1299
01:03:28,510 --> 01:03:30,635
Entón, eu estou indo para adiante,
como pode en pouco tempo,

1300
01:03:30,635 --> 01:03:34,910
e bateu C-- Control francamente, Control
C, unha morea, onde Control C xeral

1301
01:03:34,910 --> 01:03:36,034
medios cancelar.

1302
01:03:36,034 --> 01:03:38,200
Desafortunadamente, porque este
está a ser executado na nube,

1303
01:03:38,200 --> 01:03:41,190
por veces, a nube é
cuspindo tanta cousa,

1304
01:03:41,190 --> 01:03:44,180
tanta saída, que vai
levar un pouco para a miña entrada

1305
01:03:44,180 --> 01:03:45,630
para chegar á nube.

1306
01:03:45,630 --> 01:03:49,240
Así, aínda que eu bati
Control C uns segundos atrás,

1307
01:03:49,240 --> 01:03:53,110
este é sempre o lado
efecto dun loop infinito.

1308
01:03:53,110 --> 01:03:56,070
>> E así, en tales casos, estamos
vai deixar que sexa.

1309
01:03:56,070 --> 01:03:59,050
E nós estamos indo para engadir outro
fiestra de terminal aquí

1310
01:03:59,050 --> 01:04:03,186
co plus, que naturalmente non fai
así, xa que aínda está a pensar.

1311
01:04:03,186 --> 01:04:05,310
E imos adiante e ser
algo máis razoable.

1312
01:04:05,310 --> 01:04:07,768
>> Eu estou indo a ir adiante e facer
esta única un número finito de veces.

1313
01:04:07,768 --> 01:04:10,047
Imos usar un loop for,
que aludi anteriormente.

1314
01:04:10,047 --> 01:04:10,630
Imos facelo.

1315
01:04:10,630 --> 01:04:13,430
Déame outra variable int i recibe 0.

1316
01:04:13,430 --> 01:04:17,430
i é menor que, digamos, 64 i ++.

1317
01:04:17,430 --> 01:04:24,010
E agora déixeme ir adiante e de impresión
a n é por cento i, coma n.

1318
01:04:24,010 --> 01:04:27,547
E entón n-- este aínda é
vai levar para sempre.

1319
01:04:27,547 --> 01:04:28,130
Imos facelo.

1320
01:04:28,130 --> 01:04:30,620
>> n recibe n veces 2.

1321
01:04:30,620 --> 01:04:34,140
Ou poderiamos ser extravagante
e facer veces é igual a 2.

1322
01:04:34,140 --> 01:04:37,120
Pero imos só dicir que n
iguala-se, 2 veces.

1323
01:04:37,120 --> 01:04:39,321
Noutras palabras, o presente
nova versión do programa,

1324
01:04:39,321 --> 01:04:41,820
Non quero esperar para sempre
de como 800.000 para 4 millóns.

1325
01:04:41,820 --> 01:04:43,070
Nós só acabar con iso.

1326
01:04:43,070 --> 01:04:44,920
>> Imos realmente dobrar n cada vez.

1327
01:04:44,920 --> 01:04:47,660
Que, recall, duplicación é a
contrario de ter, por suposto.

1328
01:04:47,660 --> 01:04:50,035
E que a semana pasada temos
algo máis dunha vez, e de novo,

1329
01:04:50,035 --> 01:04:52,200
e, de novo, super rápido,
duplicación certamente

1330
01:04:52,200 --> 01:04:58,080
levar de 1 a maior posible
valor que podemos contar ata con un int.

1331
01:04:58,080 --> 01:04:59,750
>> Entón, imos facer exactamente isto.

1332
01:04:59,750 --> 01:05:01,720
E nós imos voltar a este antes de tempo.

1333
01:05:01,720 --> 01:05:04,180
Pero iso, de novo, é como
o bloque de repetición en perigo.

1334
01:05:04,180 --> 01:05:05,600
E vai usar este antes de tempo.

1335
01:05:05,600 --> 01:05:10,170
>> Isto só significa conta de cero
ata, pero non igual, a 64.

1336
01:05:10,170 --> 01:05:14,285
E en cada iteración deste
loop, só manter incrementando i.

1337
01:05:14,285 --> 01:05:18,990
Entón i ++ - e esta construción xeral
na liña 7 é só un xeito super común

1338
01:05:18,990 --> 01:05:22,290
repetir algunhas liñas de
código, un certo número de veces.

1339
01:05:22,290 --> 01:05:23,362
Cales liñas de código?

1340
01:05:23,362 --> 01:05:25,570
Estas claves, como
Pode ter adquirido a partir de agora,

1341
01:05:25,570 --> 01:05:26,780
significa, faga o seguinte.

1342
01:05:26,780 --> 01:05:29,510
>> É dentro como cero, cando
ten os bloques amarelos

1343
01:05:29,510 --> 01:05:32,680
e outras cores que tipo de
abrazar ou abrazar outros bloques.

1344
01:05:32,680 --> 01:05:34,750
Iso é o que estes rizado
cintas están facendo aquí.

1345
01:05:34,750 --> 01:05:40,200
Entón, se eu teño o meu sintaxe direita-- vostede
Pode ver o símbolo de cenoria no medio C

1346
01:05:40,200 --> 01:05:42,706
iso é cantas veces eu estaba
intentando solucionar este problema.

1347
01:05:42,706 --> 01:05:45,330
Entón, imos librar-se de que un
por completo, e pecha a fiestra.

1348
01:05:45,330 --> 01:05:46,520
E nós imos usar o novo.

1349
01:05:46,520 --> 01:05:51,980
Fai estourido, Slash dot
estourido, Intro, todo ben,

1350
01:05:51,980 --> 01:05:53,090
parece mal no comezo.

1351
01:05:53,090 --> 01:05:56,200
Pero imos rolar para atrás no tempo,
porque eu fixen iso 64 veces.

1352
01:05:56,200 --> 01:05:58,700
>> E observar por primeira vez, n é 1.

1353
01:05:58,700 --> 01:06:03,110
Segundo tempo, o símbolo n representa 2,
logo, 4, despois 8, entón con 16 anos.

1354
01:06:03,110 --> 01:06:09,450
E parece que así
Chegar a preto de 1 mil millóns,

1355
01:06:09,450 --> 01:06:12,800
se eu dobre-la de novo, que
debería darme 2 millóns.

1356
01:06:12,800 --> 01:06:14,980
Pero acontece, é
dereito na cúspide.

1357
01:06:14,980 --> 01:06:18,930
>> E así el realmente reborda
un enteiro de 1 billón

1358
01:06:18,930 --> 01:06:23,514
a preto de 2 negativo
millóns, porque un número enteiro,

1359
01:06:23,514 --> 01:06:25,430
ao contrario do que números
foron asumindo a semana pasada,

1360
01:06:25,430 --> 01:06:28,397
pode ser tanto positivo como negativo
en realidade, e nun ordenador.

1361
01:06:28,397 --> 01:06:30,730
E así, polo menos, un destes
bits é eficaz roubado.

1362
01:06:30,730 --> 01:06:34,190
Entón, nós realmente só ten 31 bits,
ou 2 mil millóns de valores.

1363
01:06:34,190 --> 01:06:38,220
>> Pero, por agora, o takeaway é moi
simplemente, calquera que sexan estes números son

1364
01:06:38,220 --> 01:06:42,280
e todo o que a matemática é,
algo malo acontece, finalmente,

1365
01:06:42,280 --> 01:06:46,980
porque finalmente estás
permutar os bits dun miúdo.

1366
01:06:46,980 --> 01:06:51,060
E efectivamente ir de todo
1 de quizais para todo 0 do, ou que

1367
01:06:51,060 --> 01:06:54,260
só algún outro estándar que
Claramente, dependendo do contexto,

1368
01:06:54,260 --> 01:06:56,342
pode ser interpretado como un número negativo.

1369
01:06:56,342 --> 01:06:59,300
E así parece o máis alto I
pode contar neste programa específico

1370
01:06:59,300 --> 01:07:01,210
é só a preto de 1 mil millóns.

1371
01:07:01,210 --> 01:07:02,760
Pero hai unha solución parcial aquí.

1372
01:07:02,760 --> 01:07:03,480
Vostede sabe o que?

1373
01:07:03,480 --> 01:07:07,600
>> Déixeme cambiar a partir dun
int para un longo tempo.

1374
01:07:07,600 --> 01:07:10,633
E deixe-me ir adiante aquí
e dizer-- eu vou ter

1375
01:07:10,633 --> 01:07:12,290
para cambiar isto para un sen sinatura longo.

1376
01:07:12,290 --> 01:07:16,860
Ou, imos ver, eu nunca me lembrar.

1377
01:07:16,860 --> 01:07:19,920
>> Imos adiante e facer rebosar.

1378
01:07:19,920 --> 01:07:21,860
Non, non é iso, LLD, grazas.

1379
01:07:21,860 --> 01:07:23,430
Entón, ás veces Clang pode ser útil.

1380
01:07:23,430 --> 01:07:27,550
Eu non me lembro o que o formato
especificador foi por moito tempo.

1381
01:07:27,550 --> 01:07:28,950
>> Pero, en realidade, Clang díxome.

1382
01:07:28,950 --> 01:07:31,570
O verde é unha especie de bo,
aínda significa que cometeu un erro.

1383
01:07:31,570 --> 01:07:33,190
É supoñendo que eu quería dicir LLD.

1384
01:07:33,190 --> 01:07:38,750
>> Entón deixe-me leva-la é un consello, un longo
longa número decimal, gardar isto.

1385
01:07:38,750 --> 01:07:43,190
E déixeme executa-lo de novo, dot
cortar exceso, Intro.

1386
01:07:43,190 --> 01:07:45,020
E agora o que é legal é iso.

1387
01:07:45,020 --> 01:07:49,140
>> Se eu rolar para atrás no tempo, aínda comezar
contando ao mesmo Place-- 1, 2, 4,

1388
01:07:49,140 --> 01:07:50,220
8, 16.

1389
01:07:50,220 --> 01:07:54,860
Aviso, temos todo o
camiño ata 1 billón.

1390
01:07:54,860 --> 01:07:57,070
Pero, entón, chegar con seguridade ao 2 millóns.

1391
01:07:57,070 --> 01:08:01,300
>> Entón comezamos a 4 millóns,
logo 8 millóns, 17 millóns.

1392
01:08:01,300 --> 01:08:03,340
E nós ir máis alto, e
maior, e máis altos.

1393
01:08:03,340 --> 01:08:05,740
Finalmente, tanto, tamén, saltos.

1394
01:08:05,740 --> 01:08:09,350
>> Finalmente, con un longo tempo,
que é o valor de 64 bits, non

1395
01:08:09,350 --> 01:08:13,660
un valor de 32 bits, se contar
moi alto, participa en torno a 0.

1396
01:08:13,660 --> 01:08:16,410
E neste caso, nós pasar
acabar con un número negativo.

1397
01:08:16,410 --> 01:08:17,550
>> Polo tanto, este é un problema.

1398
01:08:17,550 --> 01:08:20,439
E verifícase que este
problema non é todo o que arcano.

1399
01:08:20,439 --> 01:08:23,060
Aínda que eu teña deliberadamente
inducida con estes erros,

1400
01:08:23,060 --> 01:08:26,149
verifícase se vemos que tipo de todo
nós, ou polo menos algúns de nós en torno a facer.

1401
01:08:26,149 --> 01:08:28,939
>> Así, en Lego Star Wars, se
xa xogou o xogo,

1402
01:08:28,939 --> 01:08:33,830
verifícase que pode ir ao redor
rompendo as cousas no mundo LEGO,

1403
01:08:33,830 --> 01:08:36,640
e recollida de moedas, esencialmente.

1404
01:08:36,640 --> 01:08:39,200
E se nunca xogou
este xogo xeito moito tempo,

1405
01:08:39,200 --> 01:08:42,630
como este individuo non identificado
aquí fixeron, o número total

1406
01:08:42,630 --> 01:08:46,700
de moedas que pode recoller
é, ao parecer, 4 millóns.

1407
01:08:46,700 --> 01:08:48,240
>> Agora, con el é realmente redondeados.

1408
01:08:48,240 --> 01:08:50,239
Entón LEGO estaba tentando
manter as cousas agradable.

1409
01:08:50,239 --> 01:08:53,779
Non facelo exactamente 2 a
a 32 de alimentación, por semana pasada.

1410
01:08:53,779 --> 01:08:55,310
Pero 4 millóns é unha razón.

1411
01:08:55,310 --> 01:08:58,979
Parece, con base nesas informacións,
que LEGO, ea empresa que

1412
01:08:58,979 --> 01:09:02,624
fixo este software real, decidiu
que o número máximo de moedas

1413
01:09:02,624 --> 01:09:04,540
o usuario pode acumular
é, en realidade, 4 millóns,

1414
01:09:04,540 --> 01:09:12,069
porque escolleron o seu código
usar non moito tempo, ao parecer,

1415
01:09:12,069 --> 01:09:16,140
pero só un enteiro, un sen sinatura
enteiro, só a un número enteiro positivo, cuxa

1416
01:09:16,140 --> 01:09:18,089
valor máximo aproximadamente iso.

1417
01:09:18,089 --> 01:09:19,380
Ben, aquí está un divertido.

1418
01:09:19,380 --> 01:09:23,500
Así, no xogo Civilization, que
algúns de vostedes poden estar familiarizados coa

1419
01:09:23,500 --> 01:09:26,660
verifícase que anos atrás non
era un erro neste partido no que

1420
01:09:26,660 --> 01:09:28,750
se desempeñou o papel
de Gandhi no xogo,

1421
01:09:28,750 --> 01:09:34,020
no canto de que sexa moi pacifista,
no seu lugar foi incrible, incrible

1422
01:09:34,020 --> 01:09:36,399
agresivo, nalgunhas circunstancias.

1423
01:09:36,399 --> 01:09:40,529
En particular, a forma que a civilización
obras é que se o xogador,

1424
01:09:40,529 --> 01:09:44,680
adoptar a democracia, o
puntuación de agresividade queda

1425
01:09:44,680 --> 01:09:48,130
diminuíu en dous, de xeito menos
menos, e despois de menos de menos.

1426
01:09:48,130 --> 01:09:50,569
>> Entón restar 2
súa iteración actual.

1427
01:09:50,569 --> 01:09:56,650
Desafortunadamente, a súa iteración é
inicialmente 1, e restar 2 a partir del

1428
01:09:56,650 --> 01:09:59,050
despois de adoptar a democracia
como Gandhi aquí pode

1429
01:09:59,050 --> 01:10:02,200
ter feito, porque era moi passive--
1 na escala de agresividade.

1430
01:10:02,200 --> 01:10:04,830
Pero se adopta a democracia, a continuación,
vai de 1 a 1 negativo.

1431
01:10:04,830 --> 01:10:11,470
>> Desafortunadamente, eles eran
usando números non asinados,

1432
01:10:11,470 --> 01:10:15,400
o que significa que eles trataron mesmo negativo
números como se fosen positivos.

1433
01:10:15,400 --> 01:10:19,780
E verifícase que o
equivalente positivo do negativo 1,

1434
01:10:19,780 --> 01:10:23,480
en programas de ordenador típicos, é de 255.

1435
01:10:23,480 --> 01:10:27,250
Entón, se Gandhi adopta
democracia e, polo tanto, ten

1436
01:10:27,250 --> 01:10:32,470
súa puntuación agresividade diminuíu,
realmente rula ao redor de 255

1437
01:10:32,470 --> 01:10:35,470
e faino o máis
carácter agresivo no xogo.

1438
01:10:35,470 --> 01:10:36,930
Entón podes Google-se sobre este asunto.

1439
01:10:36,930 --> 01:10:39,380
E foi, de feito, unha
erro de programación accidental,

1440
01:10:39,380 --> 01:10:43,010
pero iso entrou moi
a tradición desde entón.

1441
01:10:43,010 --> 01:10:44,360
>> Isto é todo o desfrute e bonito.

1442
01:10:44,360 --> 01:10:47,760
Máis asustado é cando real
dispositivos do mundo real, e non xogos,

1443
01:10:47,760 --> 01:10:48,820
ter eses mesmos erros.

1444
01:10:48,820 --> 01:10:54,500
De feito, só un ano, un artigo veu
-se sobre o Boeing 787 Dreamliner.

1445
01:10:54,500 --> 01:10:56,850
>> E o artigo en primeiro
ollar le algo misterioso.

1446
01:10:56,850 --> 01:11:01,480
Pero dito isto, un programa
vulnerabilidade no Boeing

1447
01:11:01,480 --> 01:11:04,790
novo 787 Dreamliner chorro ten
o potencial de causar pilotos

1448
01:11:04,790 --> 01:11:07,220
perder o control de
da aeronave, finalmente

1449
01:11:07,220 --> 01:11:11,750
a mediados de voo, os funcionarios da FAA
compañías aéreas advertiu recentemente.

1450
01:11:11,750 --> 01:11:14,520
Foi a determinación
que un modelo 787

1451
01:11:14,520 --> 01:11:19,770
avión que foi alimentado
continuamente durante 248 días

1452
01:11:19,770 --> 01:11:24,880
Pode perder toda a corrente alterna, AC,
enerxía eléctrica debido ao xerador

1453
01:11:24,880 --> 01:11:28,892
unidades de control, GCUs, simultaneamente
indo para deixar modo de seguridade.

1454
01:11:28,892 --> 01:11:29,850
É unha especie de me perder.

1455
01:11:29,850 --> 01:11:35,390
Pero o memorando afirmou, OK, agora eu teño que,
a condición foi causado por un programa

1456
01:11:35,390 --> 01:11:38,590
contador interno para
o control do xerador

1457
01:11:38,590 --> 01:11:44,860
unidades que vai rebosar despois
248 días de potencia continua.

1458
01:11:44,860 --> 01:11:47,070
Estamos a emisión do presente
aviso para evitar a perda

1459
01:11:47,070 --> 01:11:49,300
de todos AC eléctricos
poder, o que podería resultar

1460
01:11:49,300 --> 01:11:50,980
perda de control do avión.

1461
01:11:50,980 --> 01:11:55,380
>> Así, literalmente, existe algún enteiro,
ou algún tipo de datos equivalente,

1462
01:11:55,380 --> 01:11:57,960
sendo utilizado en software
nun avión real

1463
01:11:57,960 --> 01:12:00,756
que se manter o seu avión
en tempo suficiente, o que, ao parecer,

1464
01:12:00,756 --> 01:12:03,880
pode ser o caso se está só a executar
Los constantemente e nunca apagar

1465
01:12:03,880 --> 01:12:06,810
o avión, ao parecer, é
deixando as súas baterías morrer,

1466
01:12:06,810 --> 01:12:09,840
acabará contar-se, e para arriba,
e cara arriba, e para arriba, e para arriba, e cara arriba.

1467
01:12:09,840 --> 01:12:12,150
>> E, por natureza, un
cantidade finita de memoria

1468
01:12:12,150 --> 01:12:15,880
transbordára, rolando ao
cero ou algún valor negativo,

1469
01:12:15,880 --> 01:12:19,920
efectos secundarios das cales é a
realidade assustadoramente reais

1470
01:12:19,920 --> 01:12:23,970
que o avión pode ter
de reiniciar, efectivamente,

1471
01:12:23,970 --> 01:12:27,290
ou pode caer, peor, como voa.

1472
01:12:27,290 --> 01:12:29,230
Entón, eses tipos de problemas
aínda están entre nós,

1473
01:12:29,230 --> 01:12:33,130
even-- este foi un artigo de 2015,
todo o máis asustado

1474
01:12:33,130 --> 01:12:36,100
cando non fai necesariamente
entender, apreciar, é anticipar

1475
01:12:36,100 --> 01:12:38,640
estes tipos de erros.

1476
01:12:38,640 --> 01:12:42,030
>> Non é que hai outra
algo malo sobre representación de datos.

1477
01:12:42,030 --> 01:12:47,080
Acontece que mesmo os coches alegóricos son
tipo de fallo, porque flotadores, tamén,

1478
01:12:47,080 --> 01:12:51,440
Propuxen son 32 bits, ou
quizais 64 se usa unha parella.

1479
01:12:51,440 --> 01:12:53,070
Pero iso aínda é finito.

1480
01:12:53,070 --> 01:12:57,070
>> E o problema é que se poida
poñer un número infinito de números

1481
01:12:57,070 --> 01:12:59,460
despois do punto decimal,
non hai ningunha maneira que

1482
01:12:59,460 --> 01:13:02,690
Pode representar as posibles
números que foron ensino

1483
01:13:02,690 --> 01:13:04,990
no grao escola pode existir no mundo.

1484
01:13:04,990 --> 01:13:08,870
Un ordenador, esencialmente, ten a
escoller un subconxunto destes números

1485
01:13:08,870 --> 01:13:10,200
para representar con precisión.

1486
01:13:10,200 --> 01:13:12,450
>> Agora, o ordenador pode
rolda quizais un pouco,

1487
01:13:12,450 --> 01:13:17,900
e pode permitir-lle uns tenda
calquera número que pode querer.

1488
01:13:17,900 --> 01:13:20,940
Pero só intuitivamente, se
teñen un número finito de bits,

1489
01:13:20,940 --> 01:13:24,560
só se pode permutar a eles
en tantas formas finitas.

1490
01:13:24,560 --> 01:13:26,570
Entón non pode posiblemente
teñen un número finito

1491
01:13:26,570 --> 01:13:29,880
de intercambio de bits,
patróns de ceros e uns,

1492
01:13:29,880 --> 01:13:32,940
para representar un infinito
número de números,

1493
01:13:32,940 --> 01:13:37,370
o que suxire que computadores poden
moi ben ser mentindo para nós ás veces.

1494
01:13:37,370 --> 01:13:38,770
>> De feito, imos facelo.

1495
01:13:38,770 --> 01:13:41,239
Déixeme volver IDE CS50.

1496
01:13:41,239 --> 01:13:43,030
Deixe-me ir adiante e
crear un programiña

1497
01:13:43,030 --> 01:13:47,940
chamada imprecisión, para amosar que
os ordenadores son, de feito, imprecisa.

1498
01:13:47,940 --> 01:13:51,910
>> E deixe-me ir adiante e comezar
algúns de que o código de antes,

1499
01:13:51,910 --> 01:13:53,830
e agora pode facer o seguinte.

1500
01:13:53,830 --> 01:14:03,640
Deixe-me ir adiante e facer printf, cento
f, barra invertida n, 1 dividido por 10.

1501
01:14:03,640 --> 01:14:07,430
Noutras palabras, imos mergullar no máis profundo
a 1/10, como 1 e dividida por 10.

1502
01:14:07,430 --> 01:14:09,760
Certamente, un ordenador pode representar 1/10.

1503
01:14:09,760 --> 01:14:13,620
>> Entón, imos adiante e facer imprecisión.

1504
01:14:13,620 --> 01:14:14,390
Vexamos.

1505
01:14:14,390 --> 01:14:16,210
Format especifica o tipo de matrimonio.

1506
01:14:16,210 --> 01:14:18,160
Pero o argumento ten o tipo int.

1507
01:14:18,160 --> 01:14:19,040
Que está pasando?

1508
01:14:19,040 --> 01:14:21,970
>> Oh, interesante, polo que é unha
lección aprendida de antes.

1509
01:14:21,970 --> 01:14:26,050
Eu digo, hey, feira de informática
me un flotador con cento f.

1510
01:14:26,050 --> 01:14:28,200
Pero eu estou dándolle 2 ints.

1511
01:14:28,200 --> 01:14:31,120
Así, ao parecer, podo solucionar
isto nun par de formas.

1512
01:14:31,120 --> 01:14:38,430
>> Podería simplemente transformar un 1.0, e
10 para 10,0, o que, de feito,

1513
01:14:38,430 --> 01:14:42,390
ten o efecto de converter
Los en floats-- aínda espero

1514
01:14:42,390 --> 01:14:43,180
o mesmo número.

1515
01:14:43,180 --> 01:14:45,880
Ou se ve que hai algo
veremos de novo en pouco tempo.

1516
01:14:45,880 --> 01:14:47,170
Podería publicar os números.

1517
01:14:47,170 --> 01:14:49,880
>> Pode, usando este parénteses
expresión, pode dicir,

1518
01:14:49,880 --> 01:14:52,560
hey, ordenador, aproveitar esta
10, que sei que é un int.

1519
01:14:52,560 --> 01:14:54,660
Pero trata-lo, por favor,
como se fose unha boia.

1520
01:14:54,660 --> 01:14:56,680
Pero iso parece innecesarios complexa.

1521
01:14:56,680 --> 01:14:59,040
>> Para os nosos propósitos hoxe,
imos só literalmente

1522
01:14:59,040 --> 01:15:02,700
facelos valores de punto flotante
cun punto decimal, como este.

1523
01:15:02,700 --> 01:15:07,060
Deixe-me ir adiante e volva executar, faga
imprecisión, bo, barra dot

1524
01:15:07,060 --> 01:15:08,870
imprecisión, entrar.

1525
01:15:08,870 --> 01:15:10,990
OK, nós estamos mirando bo.

1526
01:15:10,990 --> 01:15:18,194
>> 1 dividida por 10, segundo o meu
Mac aquí, é, de feito, 0,100 mil.

1527
01:15:18,194 --> 01:15:21,360
Agora, eu fun ensina na escola hai
debe ser un número infinito de 0 do.

1528
01:15:21,360 --> 01:15:23,151
Entón, imos polo menos tentar
para ver algunhas delas.

1529
01:15:23,151 --> 01:15:26,770
Acontece que printf é algo
aínda máis extravagante que temos benvida a empregar.

1530
01:15:26,770 --> 01:15:30,890
Acontece que non ten que especificar
simplemente por cento f, ou simplemente por cento i.

1531
01:15:30,890 --> 01:15:33,830
Realmente pode especificar
algunhas opcións de control aquí.

1532
01:15:33,830 --> 01:15:36,470
>> En concreto, eu estou indo
para dicir, hey, printf,

1533
01:15:36,470 --> 01:15:39,660
realmente amosar-me 10 puntos decimais.

1534
01:15:39,660 --> 01:15:40,820
Polo tanto, parece un pouco raro.

1535
01:15:40,820 --> 01:15:42,845
Pero di por cento,
punto, cantos números

1536
01:15:42,845 --> 01:15:44,970
quere ver tralo
punto decimal e logo f

1537
01:15:44,970 --> 01:15:48,340
para plana, só porque é
o que di a documentación.

1538
01:15:48,340 --> 01:15:50,080
Deixe-me ir adiante e gardar ese.

1539
01:15:50,080 --> 01:15:52,460
>> E teña en conta tamén, eu estou a recibir
canso de ter que redigitar as cousas.

1540
01:15:52,460 --> 01:15:55,900
Entón, eu estou só definir o para arriba e
frecha para abaixo en miñas claves aquí.

1541
01:15:55,900 --> 01:15:58,710
E se eu mantéñome bater-se,
Pode ver todos os comandos

1542
01:15:58,710 --> 01:16:01,090
que eu fixen, ou feita de forma incorrecta.

1543
01:16:01,090 --> 01:16:04,630
>> E eu estou indo a ir adiante agora e
Non realmente usar que, ao parecer.

1544
01:16:04,630 --> 01:16:11,416
Fai imprecisión, dot
cortar imprecision-- así

1545
01:16:11,416 --> 01:16:13,290
o que se ensina na
escola primaria confire.

1546
01:16:13,290 --> 01:16:19,010
Aínda que eu imprimir lo a 10 decimal
pon, de feito, é 0,10000.

1547
01:16:19,010 --> 01:16:19,840
Pero vostede sabe o que?

1548
01:16:19,840 --> 01:16:21,150
>> Imos estar un pouco ganancioso.

1549
01:16:21,150 --> 01:16:23,990
Digamos que, como, mostre-me 55
puntos tras o decimal.

1550
01:16:23,990 --> 01:16:26,160
Imos realmente tomar esta
programar para dar unha volta.

1551
01:16:26,160 --> 01:16:31,170
Déixeme refacelo lo co make
imprecisión, barra punto, imprecisión.

1552
01:16:31,170 --> 01:16:32,390
>> E aquí imos nós.

1553
01:16:32,390 --> 01:16:34,420
A súa infancia foi unha mentira.

1554
01:16:34,420 --> 01:16:48,410
Ao parecer, 1 dividido por 10 é efectivamente
0.100000000000000005551115123--

1555
01:16:48,410 --> 01:16:49,740
>> Que pasa?

1556
01:16:49,740 --> 01:16:53,360
Ben, ao parecer, se tipo de
mirar lonxe o suficiente na subxacente

1557
01:16:53,360 --> 01:16:55,950
representación do presente
número, realmente

1558
01:16:55,950 --> 01:17:00,400
Non é exactamente 10/01, ou 0,1 e
un número infinito de ceros.

1559
01:17:00,400 --> 01:17:01,630
Agora, por que isto?

1560
01:17:01,630 --> 01:17:06,250
>> Ben, aínda que esta é unha simple
número para nós seres humanos, 1 dividido por 10,

1561
01:17:06,250 --> 01:17:10,910
aínda é un dos infinitos
números que poderiamos imaxinar.

1562
01:17:10,910 --> 01:17:14,490
Pero un ordenador só pode representar
un número finito de números así.

1563
01:17:14,490 --> 01:17:18,710
E así, de forma eficaz, o que o
ordenador está nos amosando é o seu máis próximo

1564
01:17:18,710 --> 01:17:22,940
aproximación ao número
queremos crer é 1/10,

1565
01:17:22,940 --> 01:17:27,760
ou realmente 0,10000 ad infinitum.

1566
01:17:27,760 --> 01:17:30,425
>> Pola contra, porén, este é
tan preto que pode chegar.

1567
01:17:30,425 --> 01:17:32,300
E, de feito, se ollar
por baixo da capa,

1568
01:17:32,300 --> 01:17:37,050
como estamos aquí examinando
55 díxitos tras o decimal,

1569
01:17:37,050 --> 01:17:39,990
realmente vemos que a realidade.

1570
01:17:39,990 --> 01:17:42,610
Agora, como un aparte, se ten
Xa viu o movie--

1571
01:17:42,610 --> 01:17:45,780
a maioría de vostedes probablemente haven't--
pero Superman 3 hai uns anos,

1572
01:17:45,780 --> 01:17:49,500
Richard Pryor esencialmente panca este
realidade na súa empresa para roubar unha morea

1573
01:17:49,500 --> 01:17:53,500
de fraccións e as fraccións de centavos,
porque o company-- se ben me lembra,

1574
01:17:53,500 --> 01:17:57,210
foi un while-- era esencialmente
xogando fóra todo o que non se encaixa

1575
01:17:57,210 --> 01:17:58,790
na noción de centavos.

1576
01:17:58,790 --> 01:18:01,480
>> Pero se sumar todos estes
minúsculos, minúsculo, minúsculos números unha vez máis,

1577
01:18:01,480 --> 01:18:04,960
e de novo, e de novo, pode, como en
seu caso, facer unha boa cantidade de diñeiro.

1578
01:18:04,960 --> 01:18:08,010
>> Esa mesma idea foi roubado por
unha última, senón que agora máis vellos

1579
01:18:08,010 --> 01:18:10,500
película, chamado Office Space,
onde os mozos que a película,

1580
01:18:10,500 --> 01:18:13,501
fixo o mesmo, estraguei todo
completo, acabou coa forma demasiado

1581
01:18:13,501 --> 01:18:14,666
diñeiro da súa conta bancaria.

1582
01:18:14,666 --> 01:18:15,800
Foi todo moi sospeitoso.

1583
01:18:15,800 --> 01:18:19,290
Con todo, ao final do día,
imprecisión está ao noso arredor.

1584
01:18:19,290 --> 01:18:22,240
>> E que, ademais, se pode
assustadoramente o caso.

1585
01:18:22,240 --> 01:18:25,590
Acontece que Superman 3
e espazo de oficinas de lado, hai

1586
01:18:25,590 --> 01:18:28,460
Pode haber algún moi real
ramificacións mundiais

1587
01:18:28,460 --> 01:18:32,290
das realidades da imprecisa
representación de datos

1588
01:18:32,290 --> 01:18:34,770
que mesmo nós, humanos, a
este día non necesariamente

1589
01:18:34,770 --> 01:18:38,230
entender así como deberiamos,
ou lembrar tan frecuentemente como debería.

1590
01:18:38,230 --> 01:18:42,950
E, de feito, o clip seguinte
Bótalle un ollo a algúns mundo moi real

1591
01:18:42,950 --> 01:18:47,730
ramificacións do que pasa se
non aprecian a imprecisión que

1592
01:18:47,730 --> 01:18:50,065
pode ocorrer en números representación.

1593
01:18:50,065 --> 01:18:51,300
>> [Reprodución de vídeo]

1594
01:18:51,300 --> 01:18:55,620
>> -Computadores, Todos temos que chegou a aceptar
os problemas que moitas veces frustrante

1595
01:18:55,620 --> 01:19:00,310
ir con eles-- erros, virus,
e fallos de software,

1596
01:19:00,310 --> 01:19:03,130
para pequenos prezos a pagar
para o barrio.

1597
01:19:03,130 --> 01:19:07,800
Pero, en alta tecnoloxía e alta velocidade
aplicacións do programa espacial e militares,

1598
01:19:07,800 --> 01:19:12,800
menor problema pode
ser ampliada para o desastre.

1599
01:19:12,800 --> 01:19:18,900
>> O 04 de xuño de 1996, os científicos preparados
para lanzar un non tripulado Ariane 5 foguete.

1600
01:19:18,900 --> 01:19:21,220
Estaba cargando científica
satélites deseñados

1601
01:19:21,220 --> 01:19:24,600
para establecer con precisión o xeito no que o
interactúa campo magnético da Terra

1602
01:19:24,600 --> 01:19:27,410
con ventos solares.

1603
01:19:27,410 --> 01:19:30,800
O foguete foi construído para
a Axencia Espacial Europea,

1604
01:19:30,800 --> 01:19:34,370
e despegou da súa instalación
na costa de Güiana Francesa.

1605
01:19:34,370 --> 01:19:37,540
>> -No Uns 37 segundos para
o voo, eles primeiro

1606
01:19:37,540 --> 01:19:39,270
notado que algo estaba a suceder de malo.

1607
01:19:39,270 --> 01:19:42,250
Os picos foron xirando en
un xeito que non debería.

1608
01:19:42,250 --> 01:19:46,580
Uns 40 segundos de voo,
claramente, o vehículo estaba en apuros.

1609
01:19:46,580 --> 01:19:48,850
>> E iso é cando fixeron
a decisión de destruír-lo.

1610
01:19:48,850 --> 01:19:52,780
O oficial de seguridade gama, con
tremenda coraxe, apertou o botón,

1611
01:19:52,780 --> 01:19:58,150
estoupou o foguete, antes de que puidese
facer un perigo para a seguridade pública.

1612
01:19:58,150 --> 01:20:01,060
>> -Este Foi o de solteira
viaxe do Ariane 5.

1613
01:20:01,060 --> 01:20:03,960
E a súa destrución levou
poñer debido a un fallo

1614
01:20:03,960 --> 01:20:05,822
embutido no programa do foguete.

1615
01:20:05,822 --> 01:20:08,280
-O Problema no Ariane foi
que había un número que

1616
01:20:08,280 --> 01:20:10,600
64 bits requirido para expresar.

1617
01:20:10,600 --> 01:20:13,590
E eles querían converter
Lo a un número de 16 bits.

1618
01:20:13,590 --> 01:20:15,610
Eles asumiron que o
número nunca ía

1619
01:20:15,610 --> 01:20:20,980
de ser moi grande, que a maior parte dos
díxitos do número de 64 bits foron ceros.

1620
01:20:20,980 --> 01:20:22,440
Estaban equivocados.

1621
01:20:22,440 --> 01:20:25,060
>> -O Incapacidade dun
programa de software para aceptar

1622
01:20:25,060 --> 01:20:29,510
o tipo de número xerado pola
outra estaba na orixe do fallo.

1623
01:20:29,510 --> 01:20:34,350
desenvolvemento de software tornouse un
parte moi cara de nova tecnoloxía.

1624
01:20:34,350 --> 01:20:38,140
O foguete Ariane foron moi
exitoso, tanto do software

1625
01:20:38,140 --> 01:20:41,550
creado por iso tamén se
usado no Ariane 5.

1626
01:20:41,550 --> 01:20:47,940
>> -O Problema básico era que a Ariane
5 foi máis rápido, máis rápido acelerada.

1627
01:20:47,940 --> 01:20:51,450
E o software non
que representaron.

1628
01:20:51,450 --> 01:20:55,060
>> -A Destrución do foguete
foi un enorme desastre financeiro,

1629
01:20:55,060 --> 01:20:58,790
todo debido a un erro de software minuto.

1630
01:20:58,790 --> 01:21:01,210
Pero este non foi o primeiro
problemas de conversión de datos de tempos

1631
01:21:01,210 --> 01:21:04,820
había atormentado a tecnoloxía de foguetes moderna.

1632
01:21:04,820 --> 01:21:08,050
>> -En 1991, co inicio
da primeira Guerra do Golfo,

1633
01:21:08,050 --> 01:21:10,570
o Patriot Missile
experimentaron un tipo similar

1634
01:21:10,570 --> 01:21:12,800
do problema de conversión de número.

1635
01:21:12,800 --> 01:21:16,090
E, como resultado, 28 persoas,
28 soldados norteamericanos,

1636
01:21:16,090 --> 01:21:19,080
morreron, e preto de
100 resultaron feridas,

1637
01:21:19,080 --> 01:21:22,780
cando o Patriot, que debería
para protexer contra scuds recibidas,

1638
01:21:22,780 --> 01:21:25,830
non puido disparar un mísil.

1639
01:21:25,830 --> 01:21:31,670
>> -Cando Iraq invadiu Kuwait, e América
lanzou Desert Storm a principios de 1991,

1640
01:21:31,670 --> 01:21:35,780
baterías de mísiles Patriot foron implantados
para protexer a Arabia Saudita e Israel

1641
01:21:35,780 --> 01:21:39,230
de ataques de mísiles Scud iraquís.

1642
01:21:39,230 --> 01:21:43,810
O Patriot é un medio alcance US
superficie de sistema de aire, fabricado

1643
01:21:43,810 --> 01:21:45,770
pola empresa Raytheon.

1644
01:21:45,770 --> 01:21:52,340
>> -O Tamaño do interceptor Patriot
en si é de aproximadamente uns 20 pés de longo.

1645
01:21:52,340 --> 01:21:55,230
E pesa uns 2.000 quilos.

1646
01:21:55,230 --> 01:21:59,320
E leva unha ogiva de preto,
Creo que é máis ou menos 150 libras.

1647
01:21:59,320 --> 01:22:03,930
E é o propio ogiva
un elevado explosivo, que

1648
01:22:03,930 --> 01:22:07,330
ten fragmentos en torno a el.

1649
01:22:07,330 --> 01:22:11,680
O invólucro de ogiva é
deseñado para actuar como chumbo groso.

1650
01:22:11,680 --> 01:22:14,110
>> -As Mísiles realízanse
catro por recipiente,

1651
01:22:14,110 --> 01:22:17,130
e son transportados por un semi-remolque.

1652
01:22:17,130 --> 01:22:24,930
>> -O Sistema Patriot anti-mísil
remonta polo menos 20 anos.

1653
01:22:24,930 --> 01:22:28,420
Foi orixinalmente deseñado
como un mísil de defensa aérea

1654
01:22:28,420 --> 01:22:30,720
para abater avións inimigos.

1655
01:22:30,720 --> 01:22:34,500
Na primeira Guerra do Golfo,
cando a guerra chegou,

1656
01:22:34,500 --> 01:22:39,745
Exército quería usalo para
abater scuds, non avións.

1657
01:22:39,745 --> 01:22:43,620
>> A Forza Aérea iraquí foi
non tanto dun problema.

1658
01:22:43,620 --> 01:22:46,670
Pero o Exército estaba preocupado scuds.

1659
01:22:46,670 --> 01:22:50,170
E así intentaron
actualizar o Patriot.

1660
01:22:50,170 --> 01:22:52,800
>> -Intercepting Un inimigo
mísil viaxando a Mach 5

1661
01:22:52,800 --> 01:22:55,830
ía ser moi difícil.

1662
01:22:55,830 --> 01:22:58,490
Pero cando o Patriot
foi levado ás présas en servizo,

1663
01:22:58,490 --> 01:23:02,860
o Exército non estaba ao tanto dun
modificación iraquí que fixo

1664
01:23:02,860 --> 01:23:05,930
seus scuds case imposible de bater.

1665
01:23:05,930 --> 01:23:10,740
>> -O Que pasou é que scuds
estaban chegando eran inestables.

1666
01:23:10,740 --> 01:23:11,692
Estaban bailando.

1667
01:23:11,692 --> 01:23:14,910
A razón para iso era
os iraquís, a fin

1668
01:23:14,910 --> 01:23:18,280
para 600 quilómetros
fóra dun 300 km

1669
01:23:18,280 --> 01:23:21,700
alcance dos mísiles, tomou peso
fóra da ogiva fronte.

1670
01:23:21,700 --> 01:23:23,390
Fixeron a ogiva máis lixeiro.

1671
01:23:23,390 --> 01:23:27,330
>> Polo tanto, agora o Patriot é
tentar chegar ao Scud.

1672
01:23:27,330 --> 01:23:30,230
E a maior parte do tempo, o
esmagadora maioría do tempo,

1673
01:23:30,230 --> 01:23:32,940
sería só voar pola Scuderia.

1674
01:23:32,940 --> 01:23:37,260
Xa que os operadores do sistema Patriot
entender que o Patriot errou o seu obxectivo,

1675
01:23:37,260 --> 01:23:41,690
eles detonaron ogiva do Patriot
para evitar posibles accidentes se

1676
01:23:41,690 --> 01:23:44,570
Deixouse caer ao chan.

1677
01:23:44,570 --> 01:23:48,790
>> -Iso Era o que a maioría da xente viu,
eses grandes bolas de lume no ceo,

1678
01:23:48,790 --> 01:23:54,550
e mal interpretado como
intercepta de oxivas Scud.

1679
01:23:54,550 --> 01:23:56,630
>> -aínda Na noite
ceos, Patriots apareceu

1680
01:23:56,630 --> 01:24:00,370
para ser correctamente
destruíndo Scuds, en Dhahran,

1681
01:24:00,370 --> 01:24:03,360
pode haber ningún erro
sobre o seu funcionamento.

1682
01:24:03,360 --> 01:24:07,970
Alí, sistema de radar do Patriot
perdeu a noción dun Scud entrada,

1683
01:24:07,970 --> 01:24:10,721
e nunca lanzado debido
a un fallo de software.

1684
01:24:10,721 --> 01:24:14,090

1685
01:24:14,090 --> 01:24:18,940
Foron os israelís que descuberto por primeira vez
que canto máis tempo o sistema foi ligado,

1686
01:24:18,940 --> 01:24:22,690
canto maior sexa o tempo de discrepancia
tornouse, debido a un reloxo incorporado

1687
01:24:22,690 --> 01:24:24,810
no ordenador do sistema.

1688
01:24:24,810 --> 01:24:28,210
>> -Cerca A dúas semanas antes
a traxedia en Dhahran,

1689
01:24:28,210 --> 01:24:30,770
os israelís informar para
o Departamento de Defensa

1690
01:24:30,770 --> 01:24:32,590
que o sistema estaba perdendo tempo.

1691
01:24:32,590 --> 01:24:35,360
Despois de preto de oito horas ou en execución,
eles notaron que o sistema

1692
01:24:35,360 --> 01:24:37,720
estaba facendo visiblemente menos precisas.

1693
01:24:37,720 --> 01:24:41,900
O Departamento de Defensa respondeu
contando todas as baterías Patriot

1694
01:24:41,900 --> 01:24:44,950
para non deixar os sistemas
por un longo período de tempo.

1695
01:24:44,950 --> 01:24:49,160
Nunca dixeron que un longo tempo foi--
oito horas, 10 horas, 1.000 horas.

1696
01:24:49,160 --> 01:24:51,360
Ninguén sabía.

1697
01:24:51,360 --> 01:24:53,380
>> -A Batería Patriot
estacionados no cuartel

1698
01:24:53,380 --> 01:24:58,350
en Dhahran ea súa falla interna
reloxo fora en máis de 100 horas

1699
01:24:58,350 --> 01:25:01,670
na noite do 25 de febreiro.

1700
01:25:01,670 --> 01:25:05,917
>> -É Monitor o tempo con precisión
de aproximadamente un décimo de segundo.

1701
01:25:05,917 --> 01:25:08,000
Agora, unha décima de segundo
é un número interesante,

1702
01:25:08,000 --> 01:25:11,920
por que non pode ser expresada
en binario exactamente, o que

1703
01:25:11,920 --> 01:25:16,820
significa que non pode ser expresado exactamente
en calquera ordenador dixital moderno.

1704
01:25:16,820 --> 01:25:18,540
É difícil de crer.

1705
01:25:18,540 --> 01:25:21,210
>> Pero usar isto como un exemplo.

1706
01:25:21,210 --> 01:25:23,540
Imos dar o número de un terzo.

1707
01:25:23,540 --> 01:25:27,350
Un terceiro non pode ser
expresada en decimal exactamente.

1708
01:25:27,350 --> 01:25:32,080
Un terzo é 0,333
pasando para o infinito.

1709
01:25:32,080 --> 01:25:36,480
>> Non hai ningunha forma de facelo con
a precisión absoluta en decimal.

1710
01:25:36,480 --> 01:25:39,560
Ese é o tipo de problema
que pasou o Patriot.

1711
01:25:39,560 --> 01:25:44,100
Canto máis tempo o sistema funcionou, o
peor o erro de tempo se fixo.

1712
01:25:44,100 --> 01:25:48,890
>> -Despois De 100 horas de funcionamento, o
erro no tempo foi só preto dun terzo

1713
01:25:48,890 --> 01:25:50,600
dun segundo.

1714
01:25:50,600 --> 01:25:54,210
Pero en termos de como obxectivo un
mísil viaxando a Mach 5,

1715
01:25:54,210 --> 01:25:58,710
deu lugar a un seguimento
de erro de máis de 600 metros.

1716
01:25:58,710 --> 01:26:02,120
Sería un erro grave
para os soldados do que

1717
01:26:02,120 --> 01:26:08,940
aconteceu é o lanzamento dun Scud foi
detectados por satélites de alerta precoz

1718
01:26:08,940 --> 01:26:12,860
e eles sabían que o Scud foi
está na súa dirección xeral.

1719
01:26:12,860 --> 01:26:15,320
Eles non sabían de onde viña.

1720
01:26:15,320 --> 01:26:18,250
>> -Foi Agora á radar
compoñente do sistema Patriota

1721
01:26:18,250 --> 01:26:23,190
defendendo Dhahran para localizar e manter
Ruta do mísil inimigo de entrada.

1722
01:26:23,190 --> 01:26:24,609
>> -O Radar era moi intelixente.

1723
01:26:24,609 --> 01:26:26,650
Sería, de feito, visite
a posición do Scud,

1724
01:26:26,650 --> 01:26:30,350
e logo, prever onde probablemente
sería a próxima vez que o radar enviado

1725
01:26:30,350 --> 01:26:31,420
Un pulso para fóra.

1726
01:26:31,420 --> 01:26:33,110
Que foi chamado un portón de gama.

1727
01:26:33,110 --> 01:26:37,660
>> -Entón, Xa que o Patriot
decide tempo suficiente ten

1728
01:26:37,660 --> 01:26:42,450
pasado para volver e comprobar a próxima
situación para este obxecto detectado,

1729
01:26:42,450 --> 01:26:43,600
vai volver.

1730
01:26:43,600 --> 01:26:48,650
Así, cando se volveu para o mal
lugar, a continuación, ve ningún obxecto.

1731
01:26:48,650 --> 01:26:52,160
E decide que non houbo
obxecto, foi unha falsa detección,

1732
01:26:52,160 --> 01:26:53,930
e deixa a pista.

1733
01:26:53,930 --> 01:26:57,030
>> -O Scud entrada desapareceu
da pantalla do radar.

1734
01:26:57,030 --> 01:27:00,260
E segundos despois,
chocou contra o cuartel.

1735
01:27:00,260 --> 01:27:06,150
O Scud matou 28, e foi a última
un disparou durante a primeira Guerra do Golfo.

1736
01:27:06,150 --> 01:27:11,960
>> Traxicamente, o software actualizado
Dhahran chegou o día seguinte.

1737
01:27:11,960 --> 01:27:14,930
O fallo de software tivo
foi fixada, o peche

1738
01:27:14,930 --> 01:27:19,806
un capítulo na conturbada
historia do mísil Patriot.

1739
01:27:19,806 --> 01:27:20,729
>> [Reprodución de vídeo]

1740
01:27:20,729 --> 01:27:23,520
DAVID J. Malan: Entón, iso é todo para
din que estas cuestións de estourido

1741
01:27:23,520 --> 01:27:25,860
e imprecisión son moi reais.

1742
01:27:25,860 --> 01:27:26,920
Entón, como chegamos aquí?

1743
01:27:26,920 --> 01:27:28,895
Comezamos con só fala de printf.

1744
01:27:28,895 --> 01:27:31,270
Unha vez máis, esta función que
imprime algo para a pantalla,

1745
01:27:31,270 --> 01:27:33,450
e nós introducidas posteriormente
algunhas outras funcións

1746
01:27:33,450 --> 01:27:34,945
desde o chamado biblioteca CS50.

1747
01:27:34,945 --> 01:27:36,910
E nós imos seguir
vexa estes en debido tempo.

1748
01:27:36,910 --> 01:27:40,760
E nós, en particular, usado cadea get,
e obter int, e agora tamén terá float,

1749
01:27:40,760 --> 01:27:44,410
e aínda outros aínda atoparemos
e utilizar connosco antes de tempo.

1750
01:27:44,410 --> 01:27:47,220
>> Pero de cando en vez, ten
visto que xa unha necesidade

1751
01:27:47,220 --> 01:27:50,520
para almacenar o que estas funcións man cara atrás?

1752
01:27:50,520 --> 01:27:52,920
Eles nos tras unha cadea de man,
ou un int ou float.

1753
01:27:52,920 --> 01:27:56,070
E ás veces hai que poñer que
cadea, ou int ou float, en algún lugar.

1754
01:27:56,070 --> 01:28:00,100
>> E para almacenar estas cousas, lembre-se só
como en perigo, temos variables.

1755
01:28:00,100 --> 01:28:03,260
Pero a diferenza de risco,
C temos tipos reais

1756
01:28:03,260 --> 01:28:05,530
de datos variables--
tipo, máis generally--

1757
01:28:05,530 --> 01:28:08,640
entre eles, unha corda, un int, un
flotar, e eses outros aínda.

1758
01:28:08,640 --> 01:28:12,321
>> E por iso, cando declara variables en C,
imos ter que declarar os nosos tipos de datos.

1759
01:28:12,321 --> 01:28:14,820
Isto non é algo que imos
Ten que facer máis tarde no semestre

1760
01:28:14,820 --> 01:28:16,810
A medida que a transición a outras linguas.

1761
01:28:16,810 --> 01:28:19,610
Pero, por agora, necesitamos
para a priori antes,

1762
01:28:19,610 --> 01:28:24,370
explicar ao ordenador que tipo
da variable que queremos dar.

1763
01:28:24,370 --> 01:28:27,290
>> Agora, con todo, para imprimir
estes tipos de tipos de datos,

1764
01:28:27,290 --> 01:28:29,570
debemos dicir printf o que esperar.

1765
01:28:29,570 --> 01:28:32,450
E vimos por cento s para cordas,
e cento i para enteiros,

1766
01:28:32,450 --> 01:28:33,790
e algúns outros xa.

1767
01:28:33,790 --> 01:28:37,237
E estes son só requisitos
para a presentación visual

1768
01:28:37,237 --> 01:28:38,070
desas informacións.

1769
01:28:38,070 --> 01:28:42,080
>> E cada un destes pode ser realmente
parametrizada ou revolto, dalgún xeito,

1770
01:28:42,080 --> 01:28:45,370
se quere promover o control
o tipo de saída que comeza.

1771
01:28:45,370 --> 01:28:49,604
E, de feito, parece que non só
hai barra invertida n para unha nova liña.

1772
01:28:49,604 --> 01:28:52,520
Hai unha cousa chamada barra invertida
r para un retorno de coche, o que

1773
01:28:52,520 --> 01:28:54,360
é máis semellante a un
Máquina de escribir vella escola,

1774
01:28:54,360 --> 01:28:57,690
e tamén o Windows usado por moitos anos.

1775
01:28:57,690 --> 01:28:59,690
>> Hai barra invertida ta guías.

1776
01:28:59,690 --> 01:29:03,170
Acontece que, que se quere
comiñas dentro dunha cadea,

1777
01:29:03,170 --> 01:29:05,000
Lembre que usamos
dobre comiñas

1778
01:29:05,000 --> 01:29:07,900
Cita á esquerda e á dereita
acaba de nosas cordas ata agora.

1779
01:29:07,900 --> 01:29:09,420
Isto parece confundir as cousas.

1780
01:29:09,420 --> 01:29:12,503
>> Se queres poñer un aspa en
no medio dunha string-- e, en realidade,

1781
01:29:12,503 --> 01:29:13,670
é confuso para ver.

1782
01:29:13,670 --> 01:29:17,120
E entón ten que escapar, por así
falar, unha aspa con algo

1783
01:29:17,120 --> 01:29:18,860
como literalmente barra invertida comiñas dobres.

1784
01:29:18,860 --> 01:29:20,230
E hai algunhas outras aínda.

1785
01:29:20,230 --> 01:29:24,540
E veremos máis destes
no uso real en pouco tempo.

1786
01:29:24,540 --> 01:29:27,930
>> Entón, imos agora a transición
de datos e de representación,

1787
01:29:27,930 --> 01:29:30,820
e operadores aritméticos, todo
dos cales nos deu algún edificio

1788
01:29:30,820 --> 01:29:32,070
bloques que a desempeñar.

1789
01:29:32,070 --> 01:29:34,481
Pero agora imos realmente dar
-Nos resto do vocabulario

1790
01:29:34,481 --> 01:29:36,230
que xa
a semana pasada co Scratch

1791
01:29:36,230 --> 01:29:39,350
dando un ollo a algún outro
construcións en C-- non todas elas.

1792
01:29:39,350 --> 01:29:41,680
Pero as ideas que estamos
a piques de ver realmente só

1793
01:29:41,680 --> 01:29:45,610
salientar a tradución do
unha lingua, risco, a outro, C.

1794
01:29:45,610 --> 01:29:48,470
>> E co paso do tempo, imos incorporarse
máis ferramentas para a nosa caixa de ferramentas,

1795
01:29:48,470 --> 01:29:49,820
por así dicir, sintaticamente.

1796
01:29:49,820 --> 01:29:54,190
E, de feito, podes ver que as ideas
agora son moi familiares da semana pasada.

1797
01:29:54,190 --> 01:29:55,200
Entón, imos facelo.

1798
01:29:55,200 --> 01:29:58,870
>> Imos adiante e látego dun programa
que realmente usa algunhas expresións,

1799
01:29:58,870 --> 01:30:00,720
unha expresión booleana.

1800
01:30:00,720 --> 01:30:02,810
Déixeme ir adiante aquí
e crear un novo ficheiro.

1801
01:30:02,810 --> 01:30:06,090
Vou chamar este condition.c.

1802
01:30:06,090 --> 01:30:09,350
>> Deixe-me ir adiante e
inclúen a biblioteca CS50.

1803
01:30:09,350 --> 01:30:12,640
E deixe-me ir adiante e inclúen
estándar io.h ás nosas funcións,

1804
01:30:12,640 --> 01:30:14,690
e printf, e máis, respectivamente.

1805
01:30:14,690 --> 01:30:18,900
Deixe-me dar a min mesmo que cliché de
void main int, cuxa explicación que vai

1806
01:30:18,900 --> 01:30:20,360
volver no futuro.

1807
01:30:20,360 --> 01:30:23,820
>> Agora, deixe-me ir adiante e dar
me un int vía get int.

1808
01:30:23,820 --> 01:30:25,970
Entón deixe-me ir adiante e facelo.

1809
01:30:25,970 --> 01:30:30,150
Quero dicir, se eu é less-- imos
distinguir entre positivo, negativo,

1810
01:30:30,150 --> 01:30:31,260
ou valores iguais a cero.

1811
01:30:31,260 --> 01:30:36,630
>> Entón, se eu for menor que cero, déixeme
só ten este programa simplemente dicir:

1812
01:30:36,630 --> 01:30:42,370
negativo, barra invertida n, outra
i é maior que cero.

1813
01:30:42,370 --> 01:30:47,030
Agora eu estou, por suposto, vai dicir
printf positivo, barra invertida n.

1814
01:30:47,030 --> 01:30:50,690
E entón algo se-- eu podería facelo.

1815
01:30:50,690 --> 01:30:53,410
>> Podería facer se eu for igual a 0.

1816
01:30:53,410 --> 01:30:55,840
Pero eu estaría facendo en
menos un erro xa.

1817
01:30:55,840 --> 01:30:59,480
Lembre que o signo de igualdade é
non é igual, como nós, seres humanos saben diso.

1818
01:30:59,480 --> 01:31:01,010
>> Pero é o operador de asignación.

1819
01:31:01,010 --> 01:31:05,640
E nós non queremos tomar 0 no
dereita e poñelas i á esquerda.

1820
01:31:05,640 --> 01:31:11,810
Entón, para evitar esta confusión, ou
quizais uso indebido do signo igual,

1821
01:31:11,810 --> 01:31:14,740
os seres humanos decidiron hai uns anos
que en moitas linguaxes de programación

1822
01:31:14,740 --> 01:31:18,000
cando quere comprobar a igualdade
entre a esquerda ea dereita,

1823
01:31:18,000 --> 01:31:19,635
realmente usa é igual iguais.

1824
01:31:19,635 --> 01:31:21,010
Entón bate o signo igual dúas veces.

1825
01:31:21,010 --> 01:31:25,600
Cando quere asignar a partir da dereita
á esquerda, usa un único signo igual.

1826
01:31:25,600 --> 01:31:29,360
Para que puidésemos facer outra cousa isto--
i é igual a cero.

1827
01:31:29,360 --> 01:31:31,710
>> Podería, entón, ir e
abrir os chaves,

1828
01:31:31,710 --> 01:31:36,087
e dicir: printf 0, barra invertida n, feito.

1829
01:31:36,087 --> 01:31:38,170
Pero lembre-se como estes
garfos na estrada pode funcionar.

1830
01:31:38,170 --> 01:31:39,836
E, realmente, só pensar sobre a lóxica.

1831
01:31:39,836 --> 01:31:41,510
i é un número.

1832
01:31:41,510 --> 01:31:43,320
É un enteiro, especialmente.

1833
01:31:43,320 --> 01:31:48,600
E isto significa que vai ser menos
que 0, ou maior que 0, ou 0.

1834
01:31:48,600 --> 01:31:51,600
Polo tanto, non é unha especie de agasallo
caso estándar implícito.

1835
01:31:51,600 --> 01:31:54,920
>> E así poderiamos, así como
Cero, dispensar o else if,

1836
01:31:54,920 --> 01:31:55,747
e só dicir outra cousa.

1837
01:31:55,747 --> 01:31:57,830
Loxicamente, o
programador sabe que só hai

1838
01:31:57,830 --> 01:32:01,635
tres baldes na cal un
escenario pode fall-- o primeiro,

1839
01:32:01,635 --> 01:32:03,510
o segundo, ou terceiro
neste case-- non

1840
01:32:03,510 --> 01:32:07,100
molesta engadindo a precisión adicional
ea lóxica adicional alí.

1841
01:32:07,100 --> 01:32:09,690
Só tes que ir adiante coa
caso estándar aquí doutra persoa.

1842
01:32:09,690 --> 01:32:11,950
>> Agora, imos adiante
despois de gardar tanto, asegúrese

1843
01:32:11,950 --> 01:32:15,760
condicións dot cortar conditions--
non unha gran interface de usuario,

1844
01:32:15,760 --> 01:32:18,914
porque eu non estou levando o
usuario, como mencionei anteriormente.

1845
01:32:18,914 --> 01:32:19,580
Pero iso é bo.

1846
01:32:19,580 --> 01:32:20,454
Imos mantelo simple.

1847
01:32:20,454 --> 01:32:21,890
Tentaremos número 42.

1848
01:32:21,890 --> 01:32:23,240
E iso é positivo.

1849
01:32:23,240 --> 01:32:26,120
Tentaremos número
negativo 42, negativa.

1850
01:32:26,120 --> 01:32:28,244
>> Tentaremos valor 0.

1851
01:32:28,244 --> 01:32:29,160
E, de feito, funciona.

1852
01:32:29,160 --> 01:32:33,900
Agora, podes ver con problemas antes
longos e probar as cousas tres veces,

1853
01:32:33,900 --> 01:32:34,980
probablemente insuficiente.

1854
01:32:34,980 --> 01:32:37,438
Probablemente vai querer probar algúns
números grandes, algúns menores

1855
01:32:37,438 --> 01:32:40,520
números, nalgúns casos de canto, como
nós imos chegar a describilos-los.

1856
01:32:40,520 --> 01:32:42,500
>> Pero, por agora, esta é unha
programa moi sinxelo.

1857
01:32:42,500 --> 01:32:45,160
E eu estou seguro que, loxicamente,
que se divide en tres casos.

1858
01:32:45,160 --> 01:32:49,360
E, de feito, aínda que só
incidir sobre os potenciais inconvenientes

1859
01:32:49,360 --> 01:32:53,480
de imprecisión e inundará, en
realidade onde moitos dos problemas do CS50,

1860
01:32:53,480 --> 01:32:56,000
Non imos preocuparnos
sobre, todo o tempo,

1861
01:32:56,000 --> 01:32:59,050
estes problemas de estourido e
imprecisión, porque, en realidade, en C,

1862
01:32:59,050 --> 01:33:01,889
non é realmente todo o que
doado de evitar isto.

1863
01:33:01,889 --> 01:33:04,180
Se desexa contar-se
maior, e máis, e máis,

1864
01:33:04,180 --> 01:33:07,510
resulta que existen técnicas que
Pode usar a miúdo inclúen cousas chamadas

1865
01:33:07,510 --> 01:33:11,240
bibliotecas, coleccións de código, que
outros escribiu que pode usar,

1866
01:33:11,240 --> 01:33:13,910
e outras linguaxes como
Java e outros, en realidade,

1867
01:33:13,910 --> 01:33:15,800
facelo moito máis fácil
contar aínda maior.

1868
01:33:15,800 --> 01:33:19,810
Polo tanto, é realmente algúns deses perigos
unha función da linguaxe que usa.

1869
01:33:19,810 --> 01:33:22,710
E nas próximas semanas, imos
ver como perigoso C realmente

1870
01:33:22,710 --> 01:33:24,950
pode ser, se non usalo correctamente.

1871
01:33:24,950 --> 01:33:27,610
Pero a partir de aí, e con
Python e JavaScript, vai

1872
01:33:27,610 --> 01:33:32,620
nós capa nalgunhas proteccións adicionais,
e executar menos deses riscos.

1873
01:33:32,620 --> 01:33:35,820
>> Entón, imos facer un pouco máis
lóxica interesante no noso programa.

1874
01:33:35,820 --> 01:33:39,110
Entón deixe-me ir adiante e crear
un programa chamado lóxico

1875
01:33:39,110 --> 01:33:43,804
só así podo xogar con algúns
lóxica real, logical.c.

1876
01:33:43,804 --> 01:33:46,870
Eu só vou copiar e pegar algún
Código de antes, entón eu volver

1877
01:33:46,870 --> 01:33:49,950
a este bo punto de partida.

1878
01:33:49,950 --> 01:33:53,980
>> Déixeme esta vez facer C. de char que eu son
vai dar-lle un nome de C

1879
01:33:53,980 --> 01:33:58,510
só porque é convencional,
obter un personaxe do usuario.

1880
01:33:58,510 --> 01:34:00,730
E imos finxir
Estou aplicando parte

1881
01:34:00,730 --> 01:34:04,130
dese programa Rm, a retirada
programa antes que levou ao usuario

1882
01:34:04,130 --> 01:34:05,400
para eliminar un ficheiro.

1883
01:34:05,400 --> 01:34:06,750
Como poderiamos facelo?

1884
01:34:06,750 --> 01:34:11,090
>> Quero dicir que, se C é igual a
iguais, entre comiñas,

1885
01:34:11,090 --> 01:34:16,304
y, entón eu vou asumir
que o usuario decide si.

1886
01:34:16,304 --> 01:34:17,470
Eu só vou para imprimir si.

1887
01:34:17,470 --> 01:34:19,440
Se fose realmente escribir
o programa de eliminación,

1888
01:34:19,440 --> 01:34:21,420
poderiamos eliminar o ficheiro
con máis liñas de código.

1889
01:34:21,420 --> 01:34:22,461
Pero nós imos mantelo simple.

1890
01:34:22,461 --> 01:34:25,950

1891
01:34:25,950 --> 01:34:31,250
>> Else if c é igual a igual n--
e agora aquí, eu vou dicir,

1892
01:34:31,250 --> 01:34:32,980
o usuario debe ter significado ningún.

1893
01:34:32,980 --> 01:34:34,360
E entón algo, vostede sabe o que?

1894
01:34:34,360 --> 01:34:36,200
Non sei o que máis
o usuario vai escribir.

1895
01:34:36,200 --> 01:34:38,533
Entón, eu estou indo só para dicir que
que é un erro, calquera que sexa

1896
01:34:38,533 --> 01:34:40,070
el ou ela realmente ingresaran.

1897
01:34:40,070 --> 01:34:41,180
>> Entón, o que está pasando aquí?

1898
01:34:41,180 --> 01:34:44,530
Hai unha diferenza fundamental
versus o que eu fixen no pasado.

1899
01:34:44,530 --> 01:34:49,300
comiñas, aspas dobres, o dobre
citas, e, aínda, aspas,

1900
01:34:49,300 --> 01:34:50,170
aspas.

1901
01:34:50,170 --> 01:34:52,860
Acontece en C, que cando
quere escribir unha corda,

1902
01:34:52,860 --> 01:34:56,680
usa comiñas dobres, así como temos
benvida a empregar todo este tempo con printf.

1903
01:34:56,680 --> 01:35:02,030
>> Pero se quere tratar con só un
carácter único, un chamado char,

1904
01:35:02,030 --> 01:35:03,780
entón realmente usar comiñas simples.

1905
01:35:03,780 --> 01:35:05,450
Aqueles de vós que teña previsto
antes, pode non ter

1906
01:35:05,450 --> 01:35:07,850
tiña que preocuparse con iso
distinción en certas linguas.

1907
01:35:07,850 --> 01:35:09,450
C, non importa.

1908
01:35:09,450 --> 01:35:12,560
E así cando chegar nun char e quero
comparar ese carácter usando equals

1909
01:35:12,560 --> 01:35:18,350
é igual a algunha carta como y ou n, fago,
en realidade, ten que ter as aspas.

1910
01:35:18,350 --> 01:35:19,770
>> Agora, imos ir adiante e facelo.

1911
01:35:19,770 --> 01:35:26,180
Imos ir adiante e fan
dot lóxicas cortar lóxico.

1912
01:35:26,180 --> 01:35:27,305
E agora eu estou sendo solicitado.

1913
01:35:27,305 --> 01:35:30,638
Así, presuntamente, unha mellor experiencia de usuario
sería realmente dicir o que facer aquí.

1914
01:35:30,638 --> 01:35:33,030
Pero eu vou só cega
din y para si, OK, agradable.

1915
01:35:33,030 --> 01:35:35,780
>> Imos executa-lo de novo, n para ningunha, agradable.

1916
01:35:35,780 --> 01:35:39,610
Supoña como certas persoas que coñezo,
meus tecla bloqueo de mayúsculas está conectado con demasiada frecuencia.

1917
01:35:39,610 --> 01:35:43,740
Entón fago o capital Y, entrar, erro.

1918
01:35:43,740 --> 01:35:46,130
OK, non é o que eu estou esperando.

1919
01:35:46,130 --> 01:35:48,170
Efectivamente, o ordenador
Está facendo literalmente o que

1920
01:35:48,170 --> 01:35:51,794
Eu dixen-o para comprobar a fazer--
minúsculas n y e minúsculas.

1921
01:35:51,794 --> 01:35:53,960
Este non se sente como bo
experiencia do usuario, aínda que.

1922
01:35:53,960 --> 01:35:59,010
Déixeme pedir e aceptar
ambos os casos inferior ou maiúsculas.

1923
01:35:59,010 --> 01:36:02,090
Así, verifícase se, pode querer
dicir algo como en perigo,

1924
01:36:02,090 --> 01:36:08,150
como literal ou C é igual a
é igual a de capital único y citado.

1925
01:36:08,150 --> 01:36:11,400
Acontece que, C non ten
esta palabra chave literal ou.

1926
01:36:11,400 --> 01:36:12,880
>> Pero ten dúas barras verticais.

1927
01:36:12,880 --> 01:36:15,463
Ten que soster a tecla Maiús normalmente,
se está a usar un teclado americano,

1928
01:36:15,463 --> 01:36:18,910
e bateu a barra vertical
clave sobre a súa tecla de retorno.

1929
01:36:18,910 --> 01:36:22,410
Pero esa barra vertical
barra vertical significa ou.

1930
01:36:22,410 --> 01:36:26,220
>> Se, pola contra, queriamos
a dicir, e como en perigo,

1931
01:36:26,220 --> 01:36:28,180
poderiamos facer comercial e comercial.

1932
01:36:28,180 --> 01:36:31,330
Isto non ten sentido lóxico aquí,
porque un humano non podería posiblemente

1933
01:36:31,330 --> 01:36:37,110
escribiu tanto y e minúsculas y
e capital de Y como o mesmo personaxe.

1934
01:36:37,110 --> 01:36:39,470
Así, é o que pretendemos aquí.

1935
01:36:39,470 --> 01:36:46,280
>> Entón, se eu fai iso en ambos os lugares, ou c
é igual é igual a de capital N, agora realizar de novo,

1936
01:36:46,280 --> 01:36:49,390
fan lóxica, executa novo lóxico.

1937
01:36:49,390 --> 01:36:51,200
Agora, podo escribir y.

1938
01:36:51,200 --> 01:36:53,920
E podo facelo de novo con
capital de Y ou N. de capital

1939
01:36:53,920 --> 01:36:56,630
E eu podería engadir no adicional
combinacións fixas.

1940
01:36:56,630 --> 01:36:58,810
>> Polo tanto, esta é unha lóxica
programa na medida en que agora

1941
01:36:58,810 --> 01:37:01,940
Estou comprobando loxicamente para
Este valor é ese valor.

1942
01:37:01,940 --> 01:37:06,420
E eu non teño que, necesariamente,
vir cara arriba con dous IFS ou entón IFS.

1943
01:37:06,420 --> 01:37:09,960
Eu realmente combinan un pouco da
Relacionado coa lóxica xuntos deste xeito.

1944
01:37:09,960 --> 01:37:11,950
Polo tanto, este sería mellor
deseñado simplemente

1945
01:37:11,950 --> 01:37:17,490
dicindo si C é igual a menor caso y,
imprimir si, máis se c é igual a capital de Y,

1946
01:37:17,490 --> 01:37:20,074
imprimir si, máis se c é igual a
lower-- noutras palabras,

1947
01:37:20,074 --> 01:37:21,990
Non ten que ter
máis e máis filiais.

1948
01:37:21,990 --> 01:37:28,840
É posible combinar algunhas das equivalente
Loxicamente, como ramas deste xeito.

1949
01:37:28,840 --> 01:37:34,150
>> Entón, imos dar un ollo en só un
ingrediente final, unha construción final,

1950
01:37:34,150 --> 01:37:34,847
que permite C.

1951
01:37:34,847 --> 01:37:36,930
E nós imos voltar no
futuro, a outros aínda.

1952
01:37:36,930 --> 01:37:41,400
E entón nós imos concluír, mirando
por non a corrección de code--

1953
01:37:41,400 --> 01:37:46,070
como obter o código de trabalho-- pero o deseño
de código, e plantar as sementes no inicio.

1954
01:37:46,070 --> 01:37:51,337
>> Entón deixe-me ir adiante e
abrir un novo ficheiro aquí.

1955
01:37:51,337 --> 01:37:51,920
Vostede sabe o que?

1956
01:37:51,920 --> 01:37:54,450
Eu estou indo a reimplementar
que mesmo programa,

1957
01:37:54,450 --> 01:37:55,940
pero utilizando unha construción diferente.

1958
01:37:55,940 --> 01:38:00,110
>> Entón me deixe rapidamente darme
Acceso para incluír CS50.h

1959
01:38:00,110 --> 01:38:04,150
para a biblioteca de CS50,
Io.h estándar para printf.

1960
01:38:04,150 --> 01:38:06,510
Dáme o meu void main int.

1961
01:38:06,510 --> 01:38:09,310
E entón para acá, imos
me ir adiante e facelo.

1962
01:38:09,310 --> 01:38:12,010
>> Char c recibe obter char, como antes.

1963
01:38:12,010 --> 01:38:16,770
E eu vou usar unha nova construción
agora-- cambiar, na cal personaxe?

1964
01:38:16,770 --> 01:38:19,820
Entón chave é tipo como
O cambio dun carrís do tren.

1965
01:38:19,820 --> 01:38:22,070
Ou, en realidade, é unha especie de
unha máis, se else if,

1966
01:38:22,070 --> 01:38:23,980
pero escrito un pouco diferente.

1967
01:38:23,980 --> 01:38:25,490
>> A clave parece con isto.

1968
01:38:25,490 --> 01:38:29,060
Ten switch, e entón o que
caracteres ou número que quere para ollar,

1969
01:38:29,060 --> 01:38:32,000
logo dalgunhas claves como en
Cero, só dicir que facer estas cousas.

1970
01:38:32,000 --> 01:38:33,480
E entón tes casos diferentes.

1971
01:38:33,480 --> 01:38:34,830
>> Non usar if e else.

1972
01:38:34,830 --> 01:38:37,050
Vostede literalmente usar o caso da palabra.

1973
01:38:37,050 --> 01:38:38,790
E diría algo así.

1974
01:38:38,790 --> 01:38:43,820
>> Así, no caso dun minúsculas Y,
ou no caso dun capital Y,

1975
01:38:43,820 --> 01:38:47,350
dalle imprimir si.

1976
01:38:47,350 --> 01:38:49,020
E, a continuación, saír do switch.

1977
01:38:49,020 --> 01:38:49,580
É iso aí.

1978
01:38:49,580 --> 01:38:50,880
Estamos a facer.

1979
01:38:50,880 --> 01:38:57,270
>> Else if, por así dicir,
minúsculas n, ou de capital N,

1980
01:38:57,270 --> 01:39:02,560
entón vai adiante e imprimir
saír, non, e, a continuación, romper.

1981
01:39:02,560 --> 01:39:08,022
Else-- e este tipo de é o
caso estándar indeed-- printf error--

1982
01:39:08,022 --> 01:39:10,980
e só para unha boa medida, aínda que
loxicamente esta pausa non é necesario

1983
01:39:10,980 --> 01:39:12,896
porque estamos na fin
do interruptor de calquera xeito,

1984
01:39:12,896 --> 01:39:14,520
Agora estou batendo fóra do switch.

1985
01:39:14,520 --> 01:39:16,280
Polo tanto, este parece un pouco diferente.

1986
01:39:16,280 --> 01:39:18,272
>> Pero, loxicamente, é
efectivamente equivalente.

1987
01:39:18,272 --> 01:39:19,980
E por que usaría
un sobre o outro?

1988
01:39:19,980 --> 01:39:23,220
Ás veces, só preferencia persoal,
por veces, a estética,

1989
01:39:23,220 --> 01:39:25,420
se eu ollo para esta
Agora, hai algo

1990
01:39:25,420 --> 01:39:27,510
a ser dito para o
lexibilidade deste código.

1991
01:39:27,510 --> 01:39:30,690
É dicir, non importa o feito de que este
código é novo para moitos de nós no cuarto.

1992
01:39:30,690 --> 01:39:33,515
>> Pero é só unha especie de é bonito.

1993
01:39:33,515 --> 01:39:37,760
Ve minúsculas y, capital de Y,
minúsculas n, patrón de capital N,

1994
01:39:37,760 --> 01:39:40,150
el só tipo de saltos
fóra en ti dunha maneira

1995
01:39:40,150 --> 01:39:42,200
que, sen dúbida, se cadra
o exemplo anterior

1996
01:39:42,200 --> 01:39:45,780
coas IFS, e as barras verticais,
e os IFS outra persoa, pode non ter.

1997
01:39:45,780 --> 01:39:51,600
Polo tanto, esta é realmente unha cuestión de persoal
elección, realmente, é a lexibilidade,

1998
01:39:51,600 --> 01:39:52,360
do código.

1999
01:39:52,360 --> 01:39:58,230
>> Pero en termos de funcionalidade, déixeme
dalle facer unha chave, barra dot

2000
01:39:58,230 --> 01:40:05,830
switch, e agora escribir y minúsculas,
capital de Y, minúsculas n, capital de N,

2001
01:40:05,830 --> 01:40:09,250
David, ténteo de novo, porque iso é
non un único carácter.

2002
01:40:09,250 --> 01:40:12,050
Faremos x, erro, como se esperaba.

2003
01:40:12,050 --> 01:40:15,640
E, logically-- e iso é algo
Quere fomentar en general-- mesmo

2004
01:40:15,640 --> 01:40:17,790
aínda estamos só raiar a
superficie dalgunhas destas características.

2005
01:40:17,790 --> 01:40:20,560
>> E isto pode non ser evidente cando
-Se sentir no teclado,

2006
01:40:20,560 --> 01:40:21,370
como funciona?

2007
01:40:21,370 --> 01:40:22,240
O que isto fai?

2008
01:40:22,240 --> 01:40:25,630
A fermosa cousa sobre ter
un portátil ou de escritorio, ou o acceso

2009
01:40:25,630 --> 01:40:29,290
a un ordenador cun compilador,
e con un editor de código como este,

2010
01:40:29,290 --> 01:40:32,990
é case sempre pode responder a estas
preguntas a si mesmo só tentando.

2011
01:40:32,990 --> 01:40:36,570
>> Por exemplo, se o retórico
cuestión en apreciado foron,

2012
01:40:36,570 --> 01:40:39,540
o que pasa se esquecer
súas declaracións de ruptura?

2013
01:40:39,540 --> 01:40:41,400
Que é realmente un
moi común que hai que facer,

2014
01:40:41,400 --> 01:40:43,540
por que non parece
como realmente precisa deles.

2015
01:40:43,540 --> 01:40:46,790
Realmente non completar o seu
pensaba como paréntese ou rizado

2016
01:40:46,790 --> 01:40:47,714
cinta fai.

2017
01:40:47,714 --> 01:40:49,630
Imos ir adiante e
recompilar o código e ver.

2018
01:40:49,630 --> 01:40:53,690
Entón faga chave, chave de corte de punto.

2019
01:40:53,690 --> 01:40:56,435
Imos escribir en letras minúsculas
y, a top case, Intro.

2020
01:40:56,435 --> 01:40:59,390

2021
01:40:59,390 --> 01:41:00,700
Entón eu escriba y.

2022
01:41:00,700 --> 01:41:04,420
>> O programa dixo que si, non, de erro,
como se está cambiando a súa mente.

2023
01:41:04,420 --> 01:41:09,280
Pero que tipo de era, xa que o que pasa
cun interruptor é o primeiro caso que

2024
01:41:09,280 --> 01:41:13,899
xogo significa, esencialmente, hey ordenador,
realizar todo o código de abaixo dela.

2025
01:41:13,899 --> 01:41:16,690
E se non se ruptura, ou
non digo ruptura, ou non din ruptura,

2026
01:41:16,690 --> 01:41:19,540
o ordenador vai explotar
a través de todas as liñas

2027
01:41:19,540 --> 01:41:22,779
e realizar todos eles ata
chega a ese chaveta.

2028
01:41:22,779 --> 01:41:24,320
Así, os freos son, de feito, é necesario.

2029
01:41:24,320 --> 01:41:27,120
Pero un takeaway aquí é cando
En caso de dúbida, proba algo.

2030
01:41:27,120 --> 01:41:29,510
Quizais gardar o código en primeiro lugar,
ou garda-lo nun arquivo extra

2031
01:41:29,510 --> 01:41:32,930
se está realmente preocupado
desorde e ter que recuperar

2032
01:41:32,930 --> 01:41:34,430
o traballo que sabe que funciona.

2033
01:41:34,430 --> 01:41:35,410
>> Pero tentar cousas.

2034
01:41:35,410 --> 01:41:38,074
E non ser tan medo, se cadra,
que o ordenador pode facer,

2035
01:41:38,074 --> 01:41:39,490
ou que pode romper algo.

2036
01:41:39,490 --> 01:41:42,790
Sempre pode volver
a algunha versión anterior.

2037
01:41:42,790 --> 01:41:45,640
>> Entón imos acabar vendo
para o deseño de código.

2038
01:41:45,640 --> 01:41:49,020
Temos esa capacidade agora de escribir
condicións e loops de gravación,

2039
01:41:49,020 --> 01:41:50,850
e variables, e funcións de chamada.

2040
01:41:50,850 --> 01:41:54,590
Entón, francamente, estamos especie de volta ao
onde estabamos hai unha semana co Scratch,

2041
01:41:54,590 --> 01:42:00,120
aínda que cun textuais menos convincentes
ambiente que cero permite.

2042
01:42:00,120 --> 01:42:03,990
>> Pero teña en conta a rapidez con que adquiriu
que o vocabulario, aínda que sexa

2043
01:42:03,990 --> 01:42:07,570
vai levar un pouco de tempo para afondar,
de xeito que agora podemos utilizar este vocabulario

2044
01:42:07,570 --> 01:42:10,320
para escribir programas máis interesantes.

2045
01:42:10,320 --> 01:42:12,940
E imos dar un paso de bebé
para que, deste xeito.

2046
01:42:12,940 --> 01:42:14,890
Deixe-me ir adiante e
crear un novo arquivo aquí.

2047
01:42:14,890 --> 01:42:17,750
>> Vou chamar esta
prototype.c, e introducir

2048
01:42:17,750 --> 01:42:20,954
por primeira vez, a capacidade
para facer as súas propias funcións.

2049
01:42:20,954 --> 01:42:22,870
Algúns de vostedes poden ter
feito isto co Scratch,

2050
01:42:22,870 --> 01:42:25,430
a través do cal pode crear o seu
bloques individuais propios en cero,

2051
01:42:25,430 --> 01:42:27,892
e logo, arrastralo los para sitio
onde queira que quere en C.

2052
01:42:27,892 --> 01:42:30,100
E na maior parte da programación
idiomas, pode facer exactamente

2053
01:42:30,100 --> 01:42:33,580
isso-- facer as súas propias funcións,
se xa non existen.

2054
01:42:33,580 --> 01:42:38,660
>> Así, por exemplo, deixe-me ir adiante
e inclúen CS50.h, e incluír

2055
01:42:38,660 --> 01:42:43,110
estándar io.h, int void main.

2056
01:42:43,110 --> 01:42:46,020
E agora temos unha
espazo reservado preparado para ir.

2057
01:42:46,020 --> 01:42:48,550
I manter as cousas de impresión
como os nomes das persoas hoxe.

2058
01:42:48,550 --> 01:42:51,910
E que se sente como--
Non sería bo se hai

2059
01:42:51,910 --> 01:42:53,936
eran unha función chamada nome de impresión?

2060
01:42:53,936 --> 01:42:55,060
Non teño de utilizar printf.

2061
01:42:55,060 --> 01:42:56,976
Non teño a lembrar
todos os códigos de formato.

2062
01:42:56,976 --> 01:43:00,050
Por que non eu, ou porque
non alguén antes de min,

2063
01:43:00,050 --> 01:43:02,980
crear unha función chamada de impresión
nome, dado algún nome,

2064
01:43:02,980 --> 01:43:03,980
simplemente imprime-lo para fóra?

2065
01:43:03,980 --> 01:43:08,700
>> Noutras palabras, se eu digo, hey,
ordenador, dáme unha corda

2066
01:43:08,700 --> 01:43:11,870
pedindo ao usuario para tal,
vía función de cadea get de CS50.

2067
01:43:11,870 --> 01:43:15,090
Hey, ordenador, poñer esa cadea en
a variable na parte esquerda,

2068
01:43:15,090 --> 01:43:16,150
e chamalo s.

2069
01:43:16,150 --> 01:43:22,150
E, a continuación, hey ordenador, vai adiante
e imprimir o nome de persoa, feito.

2070
01:43:22,150 --> 01:43:26,240
>> Agora sería bo, porque
Neste programa, apropiadamente chamado,

2071
01:43:26,240 --> 01:43:29,170
dime o que se quere facer
por medio de nomes daqueles función.

2072
01:43:29,170 --> 01:43:32,930
Deixe-me ir e facer prototipo, Intro.

2073
01:43:32,930 --> 01:43:34,930
E, por desgraza,
iso non vai voar.

2074
01:43:34,930 --> 01:43:39,430
>> Prototype.c, liña 7, personaxe
5, de erro, declaración implícita

2075
01:43:39,430 --> 01:43:42,960
da función nome de impresión
non é válido na C99, C99

2076
01:43:42,960 --> 01:43:45,130
significa unha versión de C
que saíu en 1999.

2077
01:43:45,130 --> 01:43:45,730
Iso é todo.

2078
01:43:45,730 --> 01:43:48,780
>> Entón, eu non sei o que
todo isto significa aínda.

2079
01:43:48,780 --> 01:43:50,810
Pero eu recoñezo erro en vermello.

2080
01:43:50,810 --> 01:43:51,770
Isto é moi evidente.

2081
01:43:51,770 --> 01:43:53,769
>> E parece que, con
o personaxe verde aquí,

2082
01:43:53,769 --> 01:43:57,520
o problema é o nome de impresión, aberta
Paren s, paren próximos, e coma.

2083
01:43:57,520 --> 01:44:01,800
Pero a declaración implícita de
función fixemos ver brevemente antes.

2084
01:44:01,800 --> 01:44:04,880
Isto significa, simplemente, que Clang
Non sabe o que quero dicir.

2085
01:44:04,880 --> 01:44:09,000
>> Eu usei a palabra do vocabulario que se
Nunca vin ou foi ensinado antes.

2086
01:44:09,000 --> 01:44:11,950
E entón eu teño ensino-lo
o que esta función significa.

2087
01:44:11,950 --> 01:44:13,590
Entón, eu estou indo a ir adiante e facelo.

2088
01:44:13,590 --> 01:44:17,970
>> Eu estou indo a ir adiante e aplicar
miña propia función chamada Nome impreso.

2089
01:44:17,970 --> 01:44:24,720
E eu vou dicir, como segue, que
fai iso, printf, Ola, cento

2090
01:44:24,720 --> 01:44:27,760
s, barra invertida n, nome, punto e coma.

2091
01:44:27,760 --> 01:44:29,250
Entón, o que eu acabo de facer?

2092
01:44:29,250 --> 01:44:31,325
>> Non é que, para
aplicar a súa propia función,

2093
01:44:31,325 --> 01:44:33,845
que tipo de prestar algúns dos
a mesma estrutura principal

2094
01:44:33,845 --> 01:44:35,720
que fomos só
tida como certa, e eu

2095
01:44:35,720 --> 01:44:37,730
sabe só copiando e
colar moi fermoso o que

2096
01:44:37,730 --> 01:44:39,170
Teño escrito no pasado.

2097
01:44:39,170 --> 01:44:40,570
Pero teña en conta o nivel aquí.

2098
01:44:40,570 --> 01:44:43,750
Int, Main, Baleiro, imos desmembrar
en pouco tempo o que iso realmente significa.

2099
01:44:43,750 --> 01:44:46,160
>> Pero para hoxe, só
notar o paralelismo.

2100
01:44:46,160 --> 01:44:48,210
Baleiro, o nome de impresión,
nome de cadea, por iso hai

2101
01:44:48,210 --> 01:44:50,310
un contrasinal vermello, que
comezaremos

2102
01:44:50,310 --> 01:44:54,067
chamando un tipo de retorno, o nome do
a función, e despois da entrada.

2103
01:44:54,067 --> 01:44:56,400
Entón, en realidade, podemos destilar
este tipo de como a semana pasada

2104
01:44:56,400 --> 01:44:59,030
como, este é o nome ou o
algoritmo do código estamos

2105
01:44:59,030 --> 01:45:00,761
indo a write--
algoritmo subxacente

2106
01:45:00,761 --> 01:45:02,010
o código que vai escribir.

2107
01:45:02,010 --> 01:45:03,180
>> Esta é a súa entrada.

2108
01:45:03,180 --> 01:45:04,670
Esta é a súa saída.

2109
01:45:04,670 --> 01:45:08,730
Esta función, o nome de impresión, é
deseñados para ter unha cadea chamada nome,

2110
01:45:08,730 --> 01:45:11,350
ou o que quere, como entrada, e logo anuladas.

2111
01:45:11,350 --> 01:45:13,904
Non volve nada,
como obter corda ou obter int fai.

2112
01:45:13,904 --> 01:45:15,570
El me vai dar algo de volta.

2113
01:45:15,570 --> 01:45:17,960
É só vai ter un
efecto secundario, por así dicir,

2114
01:45:17,960 --> 01:45:19,570
de imprimir o nome dunha persoa.

2115
01:45:19,570 --> 01:45:22,260
Entón, teña en conta, liña 7, I
Pode chamar o nome de impresión.

2116
01:45:22,260 --> 01:45:25,920
Liña 10, podo axustar
ou aplicar nome de impresión.

2117
01:45:25,920 --> 01:45:28,450
Pero, desgraciadamente, isto non é suficiente.

2118
01:45:28,450 --> 01:45:31,230
>> Deixe-me ir adiante e
recompilar isto despois de gardar.

2119
01:45:31,230 --> 01:45:33,910
Whoa, agora, eu fixen iso
peor, ao parecer.

2120
01:45:33,910 --> 01:45:37,027
declaración de xeito implícito de
nome da función de impresión non é válido.

2121
01:45:37,027 --> 01:45:38,360
E, de novo, hai máis erros.

2122
01:45:38,360 --> 01:45:41,430
Pero como eu advertiu anteriormente, aínda
se queda resaltado con,

2123
01:45:41,430 --> 01:45:44,850
ou un pouco triste ver tantos
erros, concentrarse só na primeira

2124
01:45:44,850 --> 01:45:47,500
inicialmente, porque só podería
ter un efecto en fervenza.

2125
01:45:47,500 --> 01:45:51,970
Así, C, ou máis especificamente Clang,
segue a non recoñecer o nome de impresión.

2126
01:45:51,970 --> 01:45:54,580
>> E iso é porque Clang,
por deseño, é unha especie de idiota.

2127
01:45:54,580 --> 01:45:56,280
El só fai o que diga a el para facer.

2128
01:45:56,280 --> 01:46:00,950
E iso só fai iso na orde
no que diga a el para facer.

2129
01:46:00,950 --> 01:46:05,270
>> Entón, eu teño definido principal na liña de catro,
como vimos facendo bastante frecuencia.

2130
01:46:05,270 --> 01:46:07,980
Eu define o nome de impresión en liña 10.

2131
01:46:07,980 --> 01:46:11,793
Pero eu estou tentando usar
nome de impresión en liña sete.

2132
01:46:11,793 --> 01:46:13,670
>> É moi cedo, aínda non existe.

2133
01:46:13,670 --> 01:46:19,150
Así podería ser intelixente, e ser como,
OK, entón imos só xogar xunto,

2134
01:46:19,150 --> 01:46:23,680
e mover nome de impresión superior
aquí, e recompilar.

2135
01:46:23,680 --> 01:46:24,550
Meu Deus.

2136
01:46:24,550 --> 01:46:25,260
Funcionou.

2137
01:46:25,260 --> 01:46:26,670
Era tan simple como iso.

2138
01:46:26,670 --> 01:46:28,120
>> Pero a lóxica é exactamente iso.

2139
01:46:28,120 --> 01:46:30,870
Tes de ensinar o que Clang
é definindo a función primeira.

2140
01:46:30,870 --> 01:46:31,920
Logo, pode usalo.

2141
01:46:31,920 --> 01:46:33,940
Pero, francamente, este se sente
como unha ladeira escorregadia.

2142
01:46:33,940 --> 01:46:35,773
>> Así, cada vez que eu corro
nun problema, eu son só

2143
01:46:35,773 --> 01:46:39,450
vai destacar e copiar o código
Escribín, corte-lo e pegalo aquí.

2144
01:46:39,450 --> 01:46:41,370
E, por suposto, poderiamos
inventar uns escenarios

2145
01:46:41,370 --> 01:46:43,286
onde unha función pode
que chamar outra.

2146
01:46:43,286 --> 01:46:46,030
E simplemente non pode poñer todo
función enriba de calquera outro.

2147
01:46:46,030 --> 01:46:47,930
>> Non é que hai
unha solución mellor.

2148
01:46:47,930 --> 01:46:50,100
Podemos deixar este ser.

2149
01:46:50,100 --> 01:46:53,677
E, francamente, é xeralmente bo,
e cómodo, e un bo deseño

2150
01:46:53,677 --> 01:46:56,760
para poñer principal en primeiro lugar, porque, de novo,
principal só como cando a bandeira verde premendo,

2151
01:46:56,760 --> 01:46:59,027
que é a función que
corre por defecto.

2152
01:46:59,027 --> 01:47:01,110
Así, pode moi ben poñer
Lo na parte superior do ficheiro

2153
01:47:01,110 --> 01:47:03,560
de xeito que cando ou calquera
outro ser humano mira para o arquivo

2154
01:47:03,560 --> 01:47:06,360
sabe o que está a suceder
só lendo principal en primeiro lugar.

2155
01:47:06,360 --> 01:47:15,360
Non é que podemos dicir Clang
Proativo, hey, Clang, na liña catro,

2156
01:47:15,360 --> 01:47:17,940
Eu prometer para aplicar
unha función chamada impresión

2157
01:47:17,940 --> 01:47:22,600
Nome que leva o nome de cadea chamada
como entrada, e devolve nada, nula.

2158
01:47:22,600 --> 01:47:24,770
E eu vou dar a volta a
implementar lo máis tarde.

2159
01:47:24,770 --> 01:47:25,680
>> Aí vén Principal.

2160
01:47:25,680 --> 01:47:29,130
Iniciar agora na liña 9 pode usar
Imprimir Nombre porque Clang

2161
01:47:29,130 --> 01:47:32,600
é confiar en que, finalmente,
ha atopar a definición

2162
01:47:32,600 --> 01:47:34,880
da execución da impresión Name.

2163
01:47:34,880 --> 01:47:37,390
Entón, despois de salvar meu arquivo, imos
-me ir adiante e facer prototipo,

2164
01:47:37,390 --> 01:47:38,498
parece ser bo neste momento.

2165
01:47:38,498 --> 01:47:43,470
Dot cortar, prototipo, déixeme
dalle escriba un nome.

2166
01:47:43,470 --> 01:47:48,440
David, Ola David, Zamila, Ola
Zamila, e, de feito, agora funciona.

2167
01:47:48,440 --> 01:47:52,200
>> Así, o ingrediente aquí é que temos
fixo unha función personalizada, como un costume

2168
01:47:52,200 --> 01:47:54,219
bloque cero estamos chamando.

2169
01:47:54,219 --> 01:47:57,010
Pero, a diferenza do risco onde podes
só crealo e comezar a usalo,

2170
01:47:57,010 --> 01:47:59,330
agora temos que ser un
pouco máis pedante,

2171
01:47:59,330 --> 01:48:03,410
e realmente adestrar Clang
de usar, ou esperar.

2172
01:48:03,410 --> 01:48:09,140
Agora, como un aparte, por que todo este tempo ten
fomos cegamente na fe incluíndo

2173
01:48:09,140 --> 01:48:12,170
CS50.h, e incluíndo io.h defecto?

2174
01:48:12,170 --> 01:48:15,190
>> Ben, ao parecer,
entre algunhas outras cousas,

2175
01:48:15,190 --> 01:48:18,550
todo o que está naqueles dot h
arquivos, que terá lugar a ser arquivos.

2176
01:48:18,550 --> 01:48:20,460
Son arquivos de cabeceira, por así dicir.

2177
01:48:20,460 --> 01:48:23,270
Están aínda escrito en C. Pero
son un tipo de ficheiro.

2178
01:48:23,270 --> 01:48:28,690
>> De momento, pode moi ben asumir
que todo o que está dentro CS50.h

2179
01:48:28,690 --> 01:48:33,360
é algúns one-liners como este, non
para funcións chamadas Nome impreso,

2180
01:48:33,360 --> 01:48:36,840
pero para obter String, Obter
Float, e algúns outros.

2181
01:48:36,840 --> 01:48:41,510
E hai prototipos similares,
forros un, dentro io.h estándar

2182
01:48:41,510 --> 01:48:46,241
para printf, que está agora en
miña propia función Imprimir Nome.

2183
01:48:46,241 --> 01:48:49,490
Polo tanto, noutras palabras, todo este tempo temos
acaba de ser cegamente copiar e pegar

2184
01:48:49,490 --> 01:48:51,780
inclúen tanto, incluír
que, o que está pasando?

2185
01:48:51,780 --> 01:48:55,310
Estas son só un tipo de pistas
para Clang que funcións

2186
01:48:55,310 --> 01:49:00,170
son, de feito, aplicada, só
noutras posicións diferentes ficheiros

2187
01:49:00,170 --> 01:49:02,440
noutra parte do sistema.

2188
01:49:02,440 --> 01:49:05,160
>> Entón, nós temos implantado nome de impresión.

2189
01:49:05,160 --> 01:49:07,910
Ten ese efecto colateral de
imprimir algo na pantalla.

2190
01:49:07,910 --> 01:49:10,170
Pero iso non acontece, en realidade,
me dea algo de volta.

2191
01:49:10,170 --> 01:49:12,200
Como é que imos
a posta en marcha dun programa que

2192
01:49:12,200 --> 01:49:14,510
non me dar algo de volta?

2193
01:49:14,510 --> 01:49:15,580
>> Ben, imos tentar iso.

2194
01:49:15,580 --> 01:49:21,360
Deixe-me ir adiante e aplicar
un arquivo chamado return.c

2195
01:49:21,360 --> 01:49:24,530
para que poidamos demostrar como algo
como Get String, ou obter Int,

2196
01:49:24,530 --> 01:49:27,340
é, en realidade, volvendo
algo de volta para o usuario.

2197
01:49:27,340 --> 01:49:29,840
Imos adiante e establecer void main int.

2198
01:49:29,840 --> 01:49:33,230
>> E, de novo, no futuro, imos
explicar o que iso int e ese baleiro

2199
01:49:33,230 --> 01:49:34,090
é realmente facendo.

2200
01:49:34,090 --> 01:49:35,840
Pero para hoxe, imos
é un dato adquirido.

2201
01:49:35,840 --> 01:49:39,970
Eu estou indo a ir adiante e printf,
para unha boa experiencia do usuario, x é.

2202
01:49:39,970 --> 01:49:44,360
E entón eu vou esperar a
do usuario para darme x con get int.

2203
01:49:44,360 --> 01:49:48,459
>> E entón eu estou indo a ir adiante
e imprimir x ao cadrado.

2204
01:49:48,459 --> 01:49:50,500
Entón, cando só ten un
teclado, a xente comunmente

2205
01:49:50,500 --> 01:49:52,600
usar o pouco de cenoria
símbolo do teclado

2206
01:49:52,600 --> 01:49:55,330
para representar o poder
, Ou o expoñente.

2207
01:49:55,330 --> 01:49:58,960
Entón x ao cadrado está presente i.

2208
01:49:58,960 --> 01:50:00,660
>> E agora eu vou facelo.

2209
01:50:00,660 --> 01:50:03,940
Podería só fazer-- que é x
cadrado? x cadrado é x veces x.

2210
01:50:03,940 --> 01:50:06,690
>> E nós fixemos iso algo
tempo xa hoxe.

2211
01:50:06,690 --> 01:50:08,730
Este non se sente como
todo o que moito progreso.

2212
01:50:08,730 --> 01:50:09,570
Vostede sabe o que?

2213
01:50:09,570 --> 01:50:13,100
Imos aproveitar algo desa idea
a última vez de abstracción.

2214
01:50:13,100 --> 01:50:16,080
>> Non sería bo se
hai unha función chamada

2215
01:50:16,080 --> 01:50:18,460
cadrado que fai exactamente iso?

2216
01:50:18,460 --> 01:50:20,640
Aínda, a finais do
día, fai o mesmo matemáticas.

2217
01:50:20,640 --> 01:50:22,410
Pero imos abstracto
aínda que a idea de tomar

2218
01:50:22,410 --> 01:50:25,280
un número multiplicado por
outra, e só darlle un nome,

2219
01:50:25,280 --> 01:50:27,360
como conciliar ese valor.

2220
01:50:27,360 --> 01:50:29,560
>> E, por outras palabras, en
C, imos crear unha función

2221
01:50:29,560 --> 01:50:32,660
chamado cadrado que fai exactamente iso.

2222
01:50:32,660 --> 01:50:34,600
Será chamado cadrado.

2223
01:50:34,600 --> 01:50:35,790
Vai levar un int.

2224
01:50:35,790 --> 01:50:37,820
E nós imos será só
chamalo n, por defecto.

2225
01:50:37,820 --> 01:50:39,403
>> Pero poderiamos chamalo de calquera cousa que queiramos.

2226
01:50:39,403 --> 01:50:42,900
E todo o que vai
facer, literalmente, é o retorno

2227
01:50:42,900 --> 01:50:45,810
o resultado n veces n.

2228
01:50:45,810 --> 01:50:48,980
Senón porque é
retornando algo, que

2229
01:50:48,980 --> 01:50:53,690
é a palabra clave en vermello temos
nunca antes visto, I, na liña 11,

2230
01:50:53,690 --> 01:50:55,410
Non pode simplemente dicir nula neste momento.

2231
01:50:55,410 --> 01:51:01,320
>> Baleiro, no exemplo que acabamos de ver
no canto do nome de impresión, significa só,

2232
01:51:01,320 --> 01:51:02,190
facer algo.

2233
01:51:02,190 --> 01:51:04,170
Pero non me deixa algo de volta.

2234
01:51:04,170 --> 01:51:06,790
Neste caso, quero
para volver N N veces,

2235
01:51:06,790 --> 01:51:08,460
ou o que quere que sexa, este número.

2236
01:51:08,460 --> 01:51:12,460
>> Entón eu non podo dicir, hey, ordenador,
I voltar nada, o baleiro.

2237
01:51:12,460 --> 01:51:16,166
Vai volver, por natureza, un int.

2238
01:51:16,166 --> 01:51:17,790
E entón iso é todo o que está pasando aquí.

2239
01:51:17,790 --> 01:51:20,070
>> A entrada ao cadrado
será un int.

2240
01:51:20,070 --> 01:51:24,760
E para que poidamos usalo, ten que
ten un nome, N. Vai saída

2241
01:51:24,760 --> 01:51:26,240
un int que non precisa dun nome.

2242
01:51:26,240 --> 01:51:29,590
Podemos deixalo ao principal, ou quen queira que sexa
utilizándose me a lembrar este valor

2243
01:51:29,590 --> 01:51:31,120
quere coa súa propia variable.

2244
01:51:31,120 --> 01:51:33,230
>> E, unha vez máis, a única nova
palabra clave aquí é Return.

2245
01:51:33,230 --> 01:51:34,480
E eu estou só facendo un pouco de matemáticas.

2246
01:51:34,480 --> 01:51:41,825
Se realmente quería ser innecesario,
Podería dicir do produto int recibe n veces n.

2247
01:51:41,825 --> 01:51:44,170
>> E entón eu podería dicir, o produto voltar.

2248
01:51:44,170 --> 01:51:47,360
Pero, de novo, para o meu punto anterior do
iso só non ser bo design--

2249
01:51:47,360 --> 01:51:50,060
como, por introducir un nome,
un símbolo, como produto,

2250
01:51:50,060 --> 01:51:51,570
só para devolve-lo inmediatamente?

2251
01:51:51,570 --> 01:51:53,670
É un pouco máis limpo,
un pouco máis axustado, polo que

2252
01:51:53,670 --> 01:51:59,380
para falar, só para dicir retorno n veces
n, librar-se desta liña por completo.

2253
01:51:59,380 --> 01:52:02,860
>> E é só menos código para ler,
menos oportunidades para erros.

2254
01:52:02,860 --> 01:52:05,180
E imos ver se este
en realidade, traballa agora.

2255
01:52:05,180 --> 01:52:09,380
Agora, eu estou indo a ir
adiante e facer o retorno.

2256
01:52:09,380 --> 01:52:11,460
>> Uh-oh, declaración implícita da función.

2257
01:52:11,460 --> 01:52:14,080
Eu cometín este erro antes, non é gran cousa.

2258
01:52:14,080 --> 01:52:18,950
Déixeme só escribir ou destacar e
copiar, exactamente a mesma función prototipo,

2259
01:52:18,950 --> 01:52:21,342
ou sinatura, da función ata aquí.

2260
01:52:21,342 --> 01:52:22,800
Ou eu podería mover toda a función.

2261
01:52:22,800 --> 01:52:23,841
>> Pero iso é algo perezoso.

2262
01:52:23,841 --> 01:52:24,870
Polo tanto, non imos facelo.

2263
01:52:24,870 --> 01:52:27,960
Agora, deixe-me facer o retorno
unha vez máis, o punto de retorno barra.

2264
01:52:27,960 --> 01:52:32,790
>> x é 2. x ao cadrado é 4.
x é 3. x ao cadrado é 9.

2265
01:52:32,790 --> 01:52:35,300
E a función parece
agora estar funcionando.

2266
01:52:35,300 --> 01:52:36,550
Entón, cal é a diferenza aquí?

2267
01:52:36,550 --> 01:52:42,520
Eu teño unha función que se chama cadrado,
neste caso, que me puxen nunha entrada.

2268
01:52:42,520 --> 01:52:43,830
E eu volver unha saída.

2269
01:52:43,830 --> 01:52:46,210
E aínda, con anterioridade, se
Abro outro exemplo

2270
01:52:46,210 --> 01:52:51,640
de antes, o que
chamouse prototype.c,

2271
01:52:51,640 --> 01:52:54,770
Eu tiña o nome de impresión, que
volveu baleiro, por así dicir,

2272
01:52:54,770 --> 01:52:58,730
Ou voltou nada e
simplemente tiña un efecto colateral.

2273
01:52:58,730 --> 01:53:00,230
>> Entón, o que está pasando aquí?

2274
01:53:00,230 --> 01:53:03,520
Ben, considere a función
obter cadea por só un momento.

2275
01:53:03,520 --> 01:53:06,570
Temos benvida a empregar a función
obter secuencia do seguinte xeito.

2276
01:53:06,570 --> 01:53:10,464
>> Tivemos unha función de obter
corda, como incluír CS50.h,

2277
01:53:10,464 --> 01:53:16,624
inclúen estándar io.h, int, principal, nula.

2278
01:53:16,624 --> 01:53:18,790
E, a continuación, cada vez que eu teño
chamada cadea get ata agora,

2279
01:53:18,790 --> 01:53:23,260
Eu dixen algo, corda s
recibe obter corda, porque get string--

2280
01:53:23,260 --> 01:53:27,880
Imos chamar esa cadea get get.c--
-Se devolve unha cadea que podo, entón,

2281
01:53:27,880 --> 01:53:32,050
usar, e dicir, Ola, coma,
por cento s, barra invertida n, s.

2282
01:53:32,050 --> 01:53:35,660
>> Polo tanto, este é o mesmo exemplo,
Realmente, que tiñamos antes.

2283
01:53:35,660 --> 01:53:37,920
Polo tanto, obter secuencia retorna un valor.

2284
01:53:37,920 --> 01:53:41,260
Pero hai pouco, secuencia de impresión
non retorna un valor.

2285
01:53:41,260 --> 01:53:42,721
Simplemente ten efectos secundarios.

2286
01:53:42,721 --> 01:53:44,220
Polo tanto, esta é unha diferenza fundamental.

2287
01:53:44,220 --> 01:53:46,710
Vimos diferente
tipo de funcións agora,

2288
01:53:46,710 --> 01:53:49,490
algúns dos cales retornar
valores, algúns dos cales non.

2289
01:53:49,490 --> 01:53:51,890
Entón quizais sexa cadea, ou int ou float.

2290
01:53:51,890 --> 01:53:53,480
Ou quizais sexa só en branco.

2291
01:53:53,480 --> 01:53:55,710
>> E é a diferenza
que estas funcións que

2292
01:53:55,710 --> 01:53:59,940
obter datos e voltar un valor son realmente
traendo algo de volta á mesa,

2293
01:53:59,940 --> 01:54:01,110
por así dicir.

2294
01:54:01,110 --> 01:54:03,710
Entón, imos adiante e
mirar para un conxunto final

2295
01:54:03,710 --> 01:54:09,129
de exemplos que dá unha sensación, agora,
como podemos, de feito, abstracto mellor,

2296
01:54:09,129 --> 01:54:11,670
e mellor, e mellor, ou máis,
e máis, e máis, a fin

2297
01:54:11,670 --> 01:54:13,810
para escribir, en definitiva, un código mellor.

2298
01:54:13,810 --> 01:54:16,860
Imos adiante, e no espírito
do Scratch, faga o seguinte.

2299
01:54:16,860 --> 01:54:21,700
>> Deixe-me ir adiante e inclúen
CS50.h e IO.h. estándar

2300
01:54:21,700 --> 01:54:24,010
Deixe-me ir adiante e dar
me un int, principal, nula.

2301
01:54:24,010 --> 01:54:27,380
E deixe-me ir adiante, chame este cough.c.

2302
01:54:27,380 --> 01:54:35,510
>> E deixe-me ir adiante e só
como cero, imprima a tose / n.

2303
01:54:35,510 --> 01:54:37,170
E quero facelo tres veces.

2304
01:54:37,170 --> 01:54:39,670
Entón, eu estou, por suposto, só vai
para copiar e pegar tres veces.

2305
01:54:39,670 --> 01:54:46,440
Estou indo agora para facer
tos tos barra de punto.

2306
01:54:46,440 --> 01:54:50,120
Imos dar-me un pouco máis de espazo
aquí, Intro, tose, tose, tose.

2307
01:54:50,120 --> 01:54:53,970
>> Hai, obviamente, xa un
oportunidade de mellora.

2308
01:54:53,970 --> 01:54:55,679
Copiei e colei
algunhas veces hoxe.

2309
01:54:55,679 --> 01:54:58,261
Pero iso foi só para que eu non fixen
Ten que escribir cantos caracteres.

2310
01:54:58,261 --> 01:55:00,250
Eu cambiou o que
estas liñas de código son.

2311
01:55:00,250 --> 01:55:04,240
>> Estes tres liñas son idénticos,
que se sente preguiceiro e de feito é,

2312
01:55:04,240 --> 01:55:07,110
e probablemente non é a visión correcta.

2313
01:55:07,110 --> 01:55:11,029
Así, co ingrediente
poderiamos mellorar este código?

2314
01:55:11,029 --> 01:55:12,570
Non debemos copiar e pegar o código.

2315
01:55:12,570 --> 01:55:15,070
>> E, de feito, cando sente
-Se copiar e pegar,

2316
01:55:15,070 --> 01:55:17,700
e nin mesmo cambiar o código,
posibilidades son de que hai un xeito mellor.

2317
01:55:17,700 --> 01:55:19,470
E, de feito, non existe.

2318
01:55:19,470 --> 01:55:22,510
Deixe-me ir adiante e facer un loop for,
aínda que a sintaxe non pode

2319
01:55:22,510 --> 01:55:24,570
vén naturalmente aínda.

2320
01:55:24,570 --> 01:55:29,494
>> Faino tres veces, simplemente
facendo o following--

2321
01:55:29,494 --> 01:55:31,160
E resulta que eu sei que iso a partir da práctica.

2322
01:55:31,160 --> 01:55:32,810
Pero temos unha serie de exemplos agora.

2323
01:55:32,810 --> 01:55:34,950
E vai ver en liña
máis referencias fixas.

2324
01:55:34,950 --> 01:55:37,790
>> Esta é a sintaxe en liña 6, que
así como do risco que se repite

2325
01:55:37,790 --> 01:55:40,090
bloque, repita os seguintes tres veces.

2326
01:55:40,090 --> 01:55:41,340
É un pouco máxico para agora.

2327
01:55:41,340 --> 01:55:43,050
Pero iso vai ser máis,
e máis familiar.

2328
01:55:43,050 --> 01:55:45,050
>> E vai repetir
liña de oito por tres veces,

2329
01:55:45,050 --> 01:55:52,390
de xeito que se eu re-compilar make tose,
dot cortar tose, tose, tose, tose.

2330
01:55:52,390 --> 01:55:54,030
Aínda funciona do mesmo xeito.

2331
01:55:54,030 --> 01:55:55,550
Entón, iso é todo moi ben e bo.

2332
01:55:55,550 --> 01:55:58,200
Pero iso non é moi abstraída.

2333
01:55:58,200 --> 01:55:59,371
>> É perfectamente correcto.

2334
01:55:59,371 --> 01:56:01,370
Pero parece que hai
podería ser unha oportunidade,

2335
01:56:01,370 --> 01:56:03,750
como no mundo de
Cero, ao tipo de inicio

2336
01:56:03,750 --> 01:56:07,530
engadir algúns semántica para que
Non só ter algún lazo for,

2337
01:56:07,530 --> 01:56:09,867
e unha función que se
tossir ou non tossir.

2338
01:56:09,867 --> 01:56:10,450
Vostede sabe o que?

2339
01:56:10,450 --> 01:56:12,620
Déixeme probar ser un
pouco máis frío do que iso,

2340
01:56:12,620 --> 01:56:16,090
e realmente escribir unha función que
ten algúns efectos secundarios, chamalo tossir.

2341
01:56:16,090 --> 01:56:20,830
>> E non ten entrada e
non retorna ningún valor como saída.

2342
01:56:20,830 --> 01:56:22,680
Pero vostede sabe o que fai?

2343
01:56:22,680 --> 01:56:29,370
Fai isto-- printf,
entre comiñas, tossir.

2344
01:56:29,370 --> 01:56:32,380
>> E agora aquí enriba, eu vou
ir adiante e para int,

2345
01:56:32,380 --> 01:56:36,070
i recibe cero, i inferior a 3, i plus plus.

2346
01:56:36,070 --> 01:56:39,770
Eu estou indo a non facer printf, que é
sen dúbida unha implementación de baixo nivel

2347
01:56:39,770 --> 01:56:40,270
detalle.

2348
01:56:40,270 --> 01:56:41,353
Eu non me importa como tusir.

2349
01:56:41,353 --> 01:56:43,240
Eu só quero usar a función de tose.

2350
01:56:43,240 --> 01:56:44,840
E eu estou indo só para chamar tose.

2351
01:56:44,840 --> 01:56:46,204
>> Agora, teña en conta a dicotomía.

2352
01:56:46,204 --> 01:56:49,370
Cando chamar unha función, se non o fai
quero darlle entradas, totalmente ben.

2353
01:56:49,370 --> 01:56:51,780
Só ten que facer o paréntese aberta, preto
paréntese, e está feito.

2354
01:56:51,780 --> 01:56:56,271
>> Cando define unha función, ou
declarar un prototipo de función,

2355
01:56:56,271 --> 01:56:58,770
Se sabe de antemán que non é
Vai tomar calquera argumentos,

2356
01:56:58,770 --> 01:57:01,170
dicir nula naqueles parénteses alí.

2357
01:57:01,170 --> 01:57:05,660
E iso fai seguro de que
non accidentalmente abusar dela.

2358
01:57:05,660 --> 01:57:07,020
Deixe-me ir adiante e facer tose.

2359
01:57:07,020 --> 01:57:08,540
E, por suposto, eu cometín un erro.

2360
01:57:08,540 --> 01:57:10,410
>> Drogas, hai que
declaración implícita.

2361
01:57:10,410 --> 01:57:11,325
Pero iso é bo.

2362
01:57:11,325 --> 01:57:12,590
É un reparación doado.

2363
01:57:12,590 --> 01:57:18,240
Eu só teño o prototipo máis arriba
no meu arquivo do que eu estou realmente empregar.

2364
01:57:18,240 --> 01:57:20,070
>> Entón, agora déixeme facer tose novo, agradable.

2365
01:57:20,070 --> 01:57:20,790
Agora funciona.

2366
01:57:20,790 --> 01:57:22,930
Fai tose, tose, tose, tose.

2367
01:57:22,930 --> 01:57:25,930
Entón pode pensar que estamos realmente
pouco máis de enxeñaría este problema.

2368
01:57:25,930 --> 01:57:26,763
E, de feito, somos.

2369
01:57:26,763 --> 01:57:28,870
Este non é un bo
candidato dun programa

2370
01:57:28,870 --> 01:57:31,930
no momento de
refatoração, e facer o que é

2371
01:57:31,930 --> 01:57:35,645
chamado de descomposición xerárquica,
onde toma un código, e logo

2372
01:57:35,645 --> 01:57:38,790
vostede tipo de factor de cousas para fóra, así como
asignar máis semántica para eles,

2373
01:57:38,790 --> 01:57:40,930
e reutiliza-lo en definitiva, a longo prazo.

2374
01:57:40,930 --> 01:57:43,490
Pero é un bloque de construción en dirección
programas máis sofisticados

2375
01:57:43,490 --> 01:57:45,600
que imos comezar
escribir en pouco tempo que

2376
01:57:45,600 --> 01:57:50,090
permítenos ter o vocabulario
co cal a escribir mellor código.

2377
01:57:50,090 --> 01:57:52,920
E, de feito, imos ver se nós
Non se pode xeneralizar este proxecto.

2378
01:57:52,920 --> 01:57:57,984
>> Parece un pouco lame que, de inicio,
se preocupe este danado para loop,

2379
01:57:57,984 --> 01:57:59,400
e chamando a tose novo e de novo.

2380
01:57:59,400 --> 01:58:03,050
Por que non podo só dicir tose,
tussa tres veces?

2381
01:58:03,050 --> 01:58:08,170
Noutras palabras, por que non podo só
dar entrada a tossir e facelo?

2382
01:58:08,170 --> 01:58:11,270
>> Por que non podo só dicir, en
principal tose tres veces.

2383
01:58:11,270 --> 01:58:13,150
E agora, este é o tipo de maxia.

2384
01:58:13,150 --> 01:58:14,540
É moi iterativo aquí.

2385
01:58:14,540 --> 01:58:15,940
E é, de feito, un pequeno paso.

2386
01:58:15,940 --> 01:58:19,250
>> Pero só a capacidade de dicir
liña oito, tose por tres veces,

2387
01:58:19,250 --> 01:58:20,730
é só moito máis lexible.

2388
01:58:20,730 --> 01:58:24,210
E, ademais, eu non teño que saber
ou coidado como tose é aplicado.

2389
01:58:24,210 --> 01:58:26,460
E, de feito, a finais do
prazo e para proxectos finais,

2390
01:58:26,460 --> 01:58:29,150
Se afrontar un proxecto con
un compañeiro ou dous compañeiros,

2391
01:58:29,150 --> 01:58:32,370
notarás que está indo
Ten que, ou se quere, dividir o traballo.

2392
01:58:32,370 --> 01:58:34,650
>> E vai querer decidir
de antelación, quen vai facer o que,

2393
01:58:34,650 --> 01:58:35,483
e en que pezas?

2394
01:58:35,483 --> 01:58:37,520
E non sería bo
Se, por exemplo,

2395
01:58:37,520 --> 01:58:40,100
asumir o mando da escrita principal, feito.

2396
01:58:40,100 --> 01:58:43,470
E o seu compañeiro de cuarto, ou o seu
socio dun modo máis xeral,

2397
01:58:43,470 --> 01:58:45,230
coida da posta en marcha de tose.

2398
01:58:45,230 --> 01:58:49,540
>> E esa división, estes
paredes de abstracción,

2399
01:58:49,540 --> 01:58:52,310
ou capas de abstracción se
vai, son super poderoso,

2400
01:58:52,310 --> 01:58:55,480
porque todo para maior,
máis programas e sistemas complexos,

2401
01:58:55,480 --> 01:59:00,070
Permite que varias persoas para construír
cousas xuntos, e finalmente

2402
01:59:00,070 --> 01:59:02,680
coser o seu traballo en conxunto deste xeito.

2403
01:59:02,680 --> 01:59:05,332
Pero, por suposto, nós
Debe agora corrixir tose.

2404
01:59:05,332 --> 01:59:07,290
Necesitamos dicir a tose
que, hey, vostede sabe o que?

2405
01:59:07,290 --> 01:59:11,230
Vai ter que tomar un
input-- por iso non baleiro, pero int e agora.

2406
01:59:11,230 --> 01:59:15,170
Imos adiante e poñer en
tos do int. i recibe cero.

2407
01:59:15,170 --> 01:59:16,890
>> i é menos que o número de veces.

2408
01:59:16,890 --> 01:59:18,550
Eu dixen tres antes.

2409
01:59:18,550 --> 01:59:20,420
Pero non é iso que eu quero.

2410
01:59:20,420 --> 01:59:25,520
Quero tossir para ser xeneralizado para
soportar calquera número de iteracións.

2411
01:59:25,520 --> 01:59:28,800
>> Entón, en realidade, é n que quero,
todo o que o usuario dime.

2412
01:59:28,800 --> 01:59:31,620
Agora, podo ir adiante e dicir tose impresión.

2413
01:59:31,620 --> 01:59:34,750
E non importa o número de
o usuario pasa,

2414
01:59:34,750 --> 01:59:36,890
Vou facer unha iteración que moitas veces.

2415
01:59:36,890 --> 01:59:39,160
>> Así, ao final do día,
programa é o mesmo.

2416
01:59:39,160 --> 01:59:42,820
Pero teña en conta todas estas cousas
Pode até ser noutro ficheiro.

2417
01:59:42,820 --> 01:59:45,620
En realidade, eu non sei o
momento, como printf é aplicado.

2418
01:59:45,620 --> 01:59:47,980
>> Non sei no momento como chegar
corda, ou obter int, ou obter flotador

2419
01:59:47,980 --> 01:59:48,646
son aplicadas.

2420
01:59:48,646 --> 01:59:50,930
E eu non quero
velos na pantalla do meu.

2421
01:59:50,930 --> 01:59:55,320
Como é, eu estou empezando a se concentrar en
meu programa, non estas funcións.

2422
01:59:55,320 --> 01:59:59,070
>> E así, de feito, tan pronto
comezar factoring código como este para fóra,

2423
01:59:59,070 --> 02:00:01,397
Nós ata podía mover tose
a un arquivo separado?

2424
02:00:01,397 --> 02:00:02,730
Alguén máis podería implementar lo.

2425
02:00:02,730 --> 02:00:06,810
E vostede eo seu programa de chegar a ser o
moi bonito, e moi lexible,

2426
02:00:06,810 --> 02:00:10,830
sen dúbida, realmente catro
programa de liña alí.

2427
02:00:10,830 --> 02:00:13,510
>> Entón, imos adiante agora
e facer unha mudanza.

2428
02:00:13,510 --> 02:00:16,180
Teña en conta que o meu prototipo
ten que cambiar enriba.

2429
02:00:16,180 --> 02:00:18,390
Entón deixe-me corrixir isto así
Non obter berrou.

2430
02:00:18,390 --> 02:00:22,580
>> Fai tose, deixarme correr tose xa
máis, aínda facendo o mesmo.

2431
02:00:22,580 --> 02:00:26,010
Pero agora, entender que temos unha
ingrediente para unha versión final.

2432
02:00:26,010 --> 02:00:26,940
Vostede sabe o que?

2433
02:00:26,940 --> 02:00:29,040
Non quero só tose, necesariamente.

2434
02:00:29,040 --> 02:00:30,802
Eu quero ter algo máis xeral.

2435
02:00:30,802 --> 02:00:31,510
Entón vostede sabe o que?

2436
02:00:31,510 --> 02:00:32,450
Eu quero facelo.

2437
02:00:32,450 --> 02:00:37,140
Quero ter, así como do risco
fai, un bloque por exemplo, pero non só

2438
02:00:37,140 --> 02:00:38,680
dicir algo un determinado número de veces.

2439
02:00:38,680 --> 02:00:41,510
Quero dicir unha secuencia moi específica.

2440
02:00:41,510 --> 02:00:43,850
E, polo tanto, non sei
queres que acaba de dicir tose.

2441
02:00:43,850 --> 02:00:47,660
Quero dicir o que quere
cadea é pasado.

2442
02:00:47,660 --> 02:00:49,960
>> Entón, teña en conta, eu xeneralizada
isto para que agora

2443
02:00:49,960 --> 02:00:53,110
digamos se sente como un bo nome
para iso, como o risco,

2444
02:00:53,110 --> 02:00:55,530
leva dous argumentos, ao contrario cero.

2445
02:00:55,530 --> 02:00:56,570
Un deles é un string.

2446
02:00:56,570 --> 02:00:57,300
Un deles é un int.

2447
02:00:57,300 --> 02:00:58,130
>> E eu podería muda-los.

2448
02:00:58,130 --> 02:01:00,713
Eu medio que me gusta a idea de
din que a corda primeiro, e despois

2449
02:01:00,713 --> 02:01:01,940
cantas veces posteriores.

2450
02:01:01,940 --> 02:01:03,970
Baleiro significa aínda
non retorna nada.

2451
02:01:03,970 --> 02:01:06,428
Estes son só lado visual
efectos, como con [? Jordan ,?]

2452
02:01:06,428 --> 02:01:08,240
efectos secundarios verbal de berrar.

2453
02:01:08,240 --> 02:01:12,630
Inda fai algo n veces,
0 ata, pero non igual a n.

2454
02:01:12,630 --> 02:01:14,540
Isto significa n veces en total.

2455
02:01:14,540 --> 02:01:16,540
E despois é só imprimir
o que quere que esta cadea é.

2456
02:01:16,540 --> 02:01:19,060
Entón, realmente xeneralizada
esta liña de código.

2457
02:01:19,060 --> 02:01:22,460
Entón, agora, como fago para aplicar
a función de tose?

2458
02:01:22,460 --> 02:01:25,520
>> Podo facer tose baleiro.

2459
02:01:25,520 --> 02:01:28,501
E eu aínda podo tomar como
moitas veces quere a tossir.

2460
02:01:28,501 --> 02:01:29,250
Pero vostede sabe o que?

2461
02:01:29,250 --> 02:01:31,240
agora podo chutar a dicir.

2462
02:01:31,240 --> 02:01:36,540
>> Podo chamar dicir co
palabra tose, pasando n.

2463
02:01:36,540 --> 02:01:40,410
E se eu queira aplicar tamén,
só por diversión, unha función espirro,

2464
02:01:40,410 --> 02:01:42,290
I pode Espirrar un determinado número de veces.

2465
02:01:42,290 --> 02:01:47,300
E podo manter reutilizando n, porque
ter en conta que m neste contexto ou extensión

2466
02:01:47,300 --> 02:01:49,470
só existe dentro desa función.

2467
02:01:49,470 --> 02:01:52,767
>> E n neste contexto só
existe dentro desta función aquí.

2468
02:01:52,767 --> 02:01:54,600
Entón, imos volver
estas cuestións de ámbito.

2469
02:01:54,600 --> 02:02:01,160
E aquí, eu só vou dicir,
Achoo e logo n veces, punto e coma.

2470
02:02:01,160 --> 02:02:04,340
>> E agora, eu só precisa tomar prestado
estas funcións sinaturas ata aquí.

2471
02:02:04,340 --> 02:02:06,290
Entón tose é correcto.

2472
02:02:06,290 --> 02:02:10,090
espirro baleiro é correcta agora.

2473
02:02:10,090 --> 02:02:12,390
>> E eu aínda só precisa dicir.

2474
02:02:12,390 --> 02:02:18,990
Entón eu vou dicir, digamos
cadea s, int n, punto e coma.

2475
02:02:18,990 --> 02:02:22,010
Entón, eu teño máis de enxeñaría do
Parreira fóra deste programa.

2476
02:02:22,010 --> 02:02:23,760
>> E iso non fai
significa necesariamente que se trata

2477
02:02:23,760 --> 02:02:26,343
o que debe facer cando se escribe
mesmo o máis simple dos programas.

2478
02:02:26,343 --> 02:02:29,280
Tomé algo que é, obviamente,
moi sinxelo, moi curto,

2479
02:02:29,280 --> 02:02:31,800
e re-lo aplicar
usando xeito moi código.

2480
02:02:31,800 --> 02:02:34,560
Pero vai realmente ver, e en
tempo de ollar cara atrás sobre estes exemplos,

2481
02:02:34,560 --> 02:02:38,610
e entender, oh, estes son os pasos
tomamos para realmente xeneralizar,

2482
02:02:38,610 --> 02:02:40,797
fatorar algo fóra,
ata o final do día

2483
02:02:40,797 --> 02:02:42,380
meu código é realmente moi razoable.

2484
02:02:42,380 --> 02:02:45,960
Porque se eu queira tossir tres
veces, a continuación, espirrar tres veces,

2485
02:02:45,960 --> 02:02:50,420
Eu estou indo simplemente para realizar de novo este,
programa facer tose, e realizar tose.

2486
02:02:50,420 --> 02:02:53,620
E eu teño tres toses
e tres espirra.

2487
02:02:53,620 --> 02:02:55,990
>> E por iso este é un básicos
paradigma, se quixeren,

2488
02:02:55,990 --> 02:03:00,110
de como podemos ir sobre
en realidade, a posta en marcha dun programa.

2489
02:03:00,110 --> 02:03:03,220
Pero imos ver agora o que é
temos está a facer todo este tempo,

2490
02:03:03,220 --> 02:03:06,940
e que algunhas das pezas finais
están detrás desta simple comando.

2491
02:03:06,940 --> 02:03:09,620
Ao final do día, temos
benvida a empregar Clang como o noso compilador.

2492
02:03:09,620 --> 02:03:11,494
Vimos escribir fonte
código, convertendo-

2493
02:03:11,494 --> 02:03:12,820
vía Clang en código máquina.

2494
02:03:12,820 --> 02:03:15,540
>> E nós temos que chegou a empregar facer só
para facilitar as nosas combinacións de teclas para

2495
02:03:15,540 --> 02:03:20,740
que non ten que lembrar
eses encantamentos de si Clang.

2496
02:03:20,740 --> 02:03:22,640
Pero o que é facer realmente facendo?

2497
02:03:22,640 --> 02:03:24,750
E, á súa vez, o que é
Clang realmente facendo?

2498
02:03:24,750 --> 02:03:28,790
>> Acontece que, aínda que simplificado
a discusión de hoxe, dicindo:

2499
02:03:28,790 --> 02:03:33,090
toma código fonte, pasalo como
entrada para un compilador, que lle dá

2500
02:03:33,090 --> 02:03:35,750
saída da máquina
código, acontece que hai

2501
02:03:35,750 --> 02:03:37,420
algúns pasos diferentes dentro alí.

2502
02:03:37,420 --> 02:03:41,940
E compilación pasa a ser o paraugas
prazo para todo un conxunto de pasos.

2503
02:03:41,940 --> 02:03:43,970
Pero imos só provocalo
isto moi rapidamente.

2504
02:03:43,970 --> 02:03:48,070
>> Acontece que temos está a facer
máis cousas cada vez que eu executar un programa,

2505
02:03:48,070 --> 02:03:50,990
ou cada vez que eu compilar un programa hoxe.

2506
02:03:50,990 --> 02:03:55,020
Así, o pre-procesamento refírese a
isto-- algo nun programa C,

2507
02:03:55,020 --> 02:03:58,720
como veremos de novo e de novo,
que comeza con este símbolo de hash,

2508
02:03:58,720 --> 02:04:03,320
ou o símbolo hashtag aquí, significa
é un pre-procesador directiva.

2509
02:04:03,320 --> 02:04:07,330
Isto significa que, neste caso, ei
ordenador, facer algo con este ficheiro

2510
02:04:07,330 --> 02:04:09,430
antes de que realmente compilar meu propio código.

2511
02:04:09,430 --> 02:04:15,220
>> Neste caso, de hash inclúen sexa,
esencialmente, forma de dicir do C,

2512
02:04:15,220 --> 02:04:19,325
hey ordenador, ir buscar o contido
de CS50.h e cola-los aquí.

2513
02:04:19,325 --> 02:04:22,170
Hey ordenador, ir buscar o
contido de io.h estándar,

2514
02:04:22,170 --> 02:04:24,690
onde queira que sexa sobre o
disco duro, pegalo aquí.

2515
02:04:24,690 --> 02:04:27,390
Entón, estas cousas acontecen
por primeira vez durante o pre-procesamento.

2516
02:04:27,390 --> 02:04:28,880
>> E Clang fai todo isto para nós.

2517
02:04:28,880 --> 02:04:30,510
E faino tan danado
rápido, nin sequera

2518
02:04:30,510 --> 02:04:32,000
ver catro cousas distintas ocorrer.

2519
02:04:32,000 --> 02:04:34,100
Pero esa é a primeira tal paso.

2520
02:04:34,100 --> 02:04:35,560
>> O que realmente ocorre logo?

2521
02:04:35,560 --> 02:04:38,320
Ben, o próximo oficial
paso é a compilación.

2522
02:04:38,320 --> 02:04:40,385
E verifícase que
compilar un programa

2523
02:04:40,385 --> 02:04:44,060
tecnicamente significa que vai de
código fonte, as cousas que teño

2524
02:04:44,060 --> 02:04:47,890
foi escrito hoxe, para algo
chamado código de montaxe, algo

2525
02:04:47,890 --> 02:04:49,260
que parece un pouco diferente.

2526
02:04:49,260 --> 02:04:51,050
>> E, de feito, podemos ver que moi rápido.

2527
02:04:51,050 --> 02:04:53,890
Déixeme realmente ir ao meu IDE.

2528
02:04:53,890 --> 02:04:58,050
Deixe-me ir adiante e hello.c aberta, que
é o primeiro programa co que nós

2529
02:04:58,050 --> 02:04:59,120
comezou hoxe.

2530
02:04:59,120 --> 02:05:04,130
E deixe-me ir adiante e executar Clang un
pouco distinto, Clang-s, hello.c,

2531
02:05:04,130 --> 02:05:07,720
que está indo realmente para
Déame outra hello.s de ficheiro.

2532
02:05:07,720 --> 02:05:10,330
>> E nós probablemente nunca será
novo ver este tipo de código.

2533
02:05:10,330 --> 02:05:13,030
Se tomar un nivel máis baixo
sistemas de clase como CS61,

2534
02:05:13,030 --> 02:05:14,920
vai ver moito máis
deste tipo de código.

2535
02:05:14,920 --> 02:05:17,020
Pero esta é a linguaxe assembly.

2536
02:05:17,020 --> 02:05:22,050
Este é X86 linguaxe assembly
que a CPU que está subxacente

2537
02:05:22,050 --> 02:05:24,460
CS50 IDE realmente entende.

2538
02:05:24,460 --> 02:05:27,060
>> E enigmática como fai
ollar, é algo

2539
02:05:27,060 --> 02:05:29,180
o ordenador entende moi ben.

2540
02:05:29,180 --> 02:05:30,790
Sub Q, isto é un substrato.

2541
02:05:30,790 --> 02:05:31,660
Hai movementos.

2542
02:05:31,660 --> 02:05:35,730
>> Non está chamando de funcións aquí,
x oring, un movemento, un complemento, un pop,

2543
02:05:35,730 --> 02:05:36,430
un retorno.

2544
02:05:36,430 --> 02:05:38,850
Polo tanto, hai algúns moi
instrucións de baixo nivel

2545
02:05:38,850 --> 02:05:41,280
que CPUs entender que
Aludi anteriormente.

2546
02:05:41,280 --> 02:05:43,100
Iso é o que Intel Inside.

2547
02:05:43,100 --> 02:05:45,030
>> Existen patróns de
ceros e uns que

2548
02:05:45,030 --> 02:05:51,800
mapear a estes redactado arcanely pero
algo así nomeado, instrucións,

2549
02:05:51,800 --> 02:05:52,780
por así dicir.

2550
02:05:52,780 --> 02:05:54,780
Isto é o que ocorre cando
compilar o código.

2551
02:05:54,780 --> 02:05:58,560
Comeza a montaxe
lingua de fóra, o que

2552
02:05:58,560 --> 02:06:04,680
significa que o terceiro paso é para montar
que o código assembly para, en definitiva,

2553
02:06:04,680 --> 02:06:09,080
Máquina de ceros code-- e uns, non os
texto que acabamos de ver un momento atrás.

2554
02:06:09,080 --> 02:06:13,370
>> Así, pre-procesamento que iso atopar
e substituír, e algunhas outras cousas.

2555
02:06:13,370 --> 02:06:16,430
Compilando leva a súa fonte
código de C, o código fonte

2556
02:06:16,430 --> 02:06:18,980
que escribiu, para montaxe
código que só mirou.

2557
02:06:18,980 --> 02:06:22,170
Montaxe leva que a montaxe
código para ceros e uns

2558
02:06:22,170 --> 02:06:24,680
que o CPU vai realmente
comprender, ao final do día.

2559
02:06:24,680 --> 02:06:27,630
E vinculación é a última etapa
que pasa a US-- novo,

2560
02:06:27,630 --> 02:06:29,830
tan rápido que nin sequera
notice-- que di:

2561
02:06:29,830 --> 02:06:32,460
hey ordenador, tomar todas
os ceros e uns que

2562
02:06:32,460 --> 02:06:36,750
resultou de compilar o código de David,
ea súa principal función neste caso.

2563
02:06:36,750 --> 02:06:39,160
>> E ei ordenador, ir buscar
todo ceros e uns

2564
02:06:39,160 --> 02:06:42,180
que o equipo CS50 escribiu
dentro da biblioteca CS50.

2565
02:06:42,180 --> 02:06:43,440
Mestura aqueles con David.

2566
02:06:43,440 --> 02:06:46,648
E ei ordenador, ir buscar todos os ceros
e os que alguén escribiu anos

2567
02:06:46,648 --> 02:06:47,470
atrás para printf.

2568
02:06:47,470 --> 02:06:49,880
E engadir aqueles para o
cousa toda, de xeito que temos

2569
02:06:49,880 --> 02:06:52,870
teño os meus ceros e uns, a
ceros e uns do persoal CS50,

2570
02:06:52,870 --> 02:06:55,370
os ceros e uns, printf
e calquera outra cousa que estamos a usar.

2571
02:06:55,370 --> 02:07:00,410
>> Todos eles se combinados nun
programa chamado neste caso Hola.

2572
02:07:00,410 --> 02:07:03,141
Entón, de agora en diante, imos só
usar a palabra compilación.

2573
02:07:03,141 --> 02:07:06,390
E imos tomar como certo que, cando
dicimos, compilar o seu programa, é dicir,

2574
02:07:06,390 --> 02:07:08,849
hey facer o pre-procesamento,
montaxe e conexión.

2575
02:07:08,849 --> 02:07:11,890
Pero hai realmente algunhas cousas suculenta
pasando alí debaixo do capó.

2576
02:07:11,890 --> 02:07:13,723
E especialmente se
estar curioso algún tempo,

2577
02:07:13,723 --> 02:07:15,900
pode comezar a picar
en torno a este nivel inferior.

2578
02:07:15,900 --> 02:07:19,660
Pero, por agora, entender que
entre os temas para hoxe

2579
02:07:19,660 --> 02:07:23,420
son pura e simplemente o
inicio dun proceso,

2580
02:07:23,420 --> 02:07:26,700
de estar cómodo con
algo así como Ola mundo.

2581
02:07:26,700 --> 02:07:29,575
En realidade, a maioría do que fixemos hoxe
certamente non vai afundir na super rápido.

2582
02:07:29,575 --> 02:07:31,491
E iso vai levar moito
tempo, e algunha práctica.

2583
02:07:31,491 --> 02:07:33,864
E as probabilidades son, vostede pode clasificar
de quere bater o teclado

2584
02:07:33,864 --> 02:07:34,780
ou berrar para a pantalla.

2585
02:07:34,780 --> 02:07:35,880
E todo iso é OK.

2586
02:07:35,880 --> 02:07:38,320
Aínda que, quizais intente non
facelo na biblioteca tanto.

2587
02:07:38,320 --> 02:07:40,820
>> E, finalmente, vai
ser capaces, porén, de comezar

2588
02:07:40,820 --> 02:07:44,580
vendo patróns, tanto no bo código
que escribiu e erros

2589
02:07:44,580 --> 02:07:45,370
que fixo.

2590
02:07:45,370 --> 02:07:48,965
E moi parecido ao proceso de
tornándose un TF ou CA é como,

2591
02:07:48,965 --> 02:07:51,590
vai comezar a ir mellor e
mellor ao ver eses patróns,

2592
02:07:51,590 --> 02:07:53,774
e só resolver o seu
propios problemas en última instancia.

2593
02:07:53,774 --> 02:07:56,940
Nese medio tempo, haberá unha abundancia
de nós para darlle soporte, e levalo

2594
02:07:56,940 --> 02:07:57,481
por iso.

2595
02:07:57,481 --> 02:07:59,450
E nos write-ups
para todos os problemas

2596
02:07:59,450 --> 02:08:01,366
será guiado a través
todos os comandos

2597
02:08:01,366 --> 02:08:05,330
que seguramente sabe de
moita práctica ata agora,

2598
02:08:05,330 --> 02:08:07,380
pero podería voar
sobre a cabeza de momento.

2599
02:08:07,380 --> 02:08:08,580
E iso é totalmente ben.

2600
02:08:08,580 --> 02:08:11,230
>> Pero, en definitiva, vai
para comezar a ver xurdir patróns.

2601
02:08:11,230 --> 02:08:14,260
E unha vez que pasar por todo o
detalles estúpidas, como parénteses,

2602
02:08:14,260 --> 02:08:16,710
e chaves, e punto e coma,
e as cousas, a verdade,

2603
02:08:16,710 --> 02:08:19,360
que non é de ningún xeito
intelectualmente interesante.

2604
02:08:19,360 --> 02:08:22,690
E non é o obxectivo de
tomar calquera clase introdutoria.

2605
02:08:22,690 --> 02:08:24,410
E as ideas que van importa.

2606
02:08:24,410 --> 02:08:26,659
>> Son os loops, eo
condicións e as funcións,

2607
02:08:26,659 --> 02:08:30,552
e máis poderosamente a abstracción,
eo factoring de código,

2608
02:08:30,552 --> 02:08:33,510
eo bo deseño, eo bo
estilo, e, finalmente, a exactitude

2609
02:08:33,510 --> 02:08:37,330
do seu código, que é, en definitiva
Vai descargar máis.

2610
02:08:37,330 --> 02:08:40,925
Así, a próxima semana, imos tomar estas
ideas que vimos por primeira vez en Risco

2611
02:08:40,925 --> 02:08:42,800
e agora traducido
a C. E imos comezar

2612
02:08:42,800 --> 02:08:45,740
para introducir a primeira do
dominios do mundo real do curso.

2613
02:08:45,740 --> 02:08:50,140
>> Imos concentrar-se no mundo da seguridade,
e máis especificamente cifrado,

2614
02:08:50,140 --> 02:08:51,980
técnica de codificación da información.

2615
02:08:51,980 --> 02:08:54,000
E entre o primeiro
problemas que aínda

2616
02:08:54,000 --> 02:08:56,840
comezará a gravar ademais
xogando con algunha da sintaxe

2617
02:08:56,840 --> 02:08:59,880
e resolver algúns lóxica
problemas, en definitiva, en pouco tempo,

2618
02:08:59,880 --> 02:09:03,960
é realmente loitan, ou cifrar,
e, finalmente, descifrar a información.

2619
02:09:03,960 --> 02:09:06,470
E todo o que fixemos
Hoxe, será moi baixa

2620
02:09:06,470 --> 02:09:09,190
nivel, é só permitirá
-Nos a tomar un, e un,

2621
02:09:09,190 --> 02:09:13,550
e un paso arriba cara
escribir o código máis interesante aínda.

2622
02:09:13,550 --> 02:09:15,050
>> Entón máis sobre iso a próxima semana.

2623
02:09:15,050 --> 02:09:17,834

2624
02:09:17,834 --> 02:09:18,762
>> [Reprodución de vídeo]

2625
02:09:18,762 --> 02:09:19,690

2626
02:09:19,690 --> 02:09:22,006
>> -O Que me pode dicir sobre
a última vez que o viu?

2627
02:09:22,006 --> 02:09:26,041

2628
02:09:26,041 --> 02:09:27,040
-O Que podo dicir, realmente?

2629
02:09:27,040 --> 02:09:30,500

2630
02:09:30,500 --> 02:09:35,340
Quero dicir, era como calquera outra
ensaio de pre-produción,

2631
02:09:35,340 --> 02:09:40,510
agás que non era algo que dixo
ao final que quedou comigo.

2632
02:09:40,510 --> 02:09:44,810

2633
02:09:44,810 --> 02:09:46,640
>> -Este Foi CS50.

2634
02:09:46,640 --> 02:09:49,440

2635
02:09:49,440 --> 02:09:52,190
>> -É Un corte de todos,
gran traballo en ensaio.

2636
02:09:52,190 --> 02:09:53,070
>> o xantar de -que?

2637
02:09:53,070 --> 02:09:54,986
>> Si, e eu podemos
incorporarse un bocadillos en algo.

2638
02:09:54,986 --> 02:09:58,380
Déixeme só interrogar con
David moi rapidamente.

2639
02:09:58,380 --> 02:09:59,160
David?

2640
02:09:59,160 --> 02:10:01,260
David?

2641
02:10:01,260 --> 02:10:03,110
>> [FIN DE REPRODUCIÓN]

