[MUSIC nagpe-play] David J. MALAN: Lahat ng karapatan, ito ay CS50. At ito ay kung week isa. Kaya isipin ang na huling oras sa linggo zero, kami ay nakatutok sa computational pag-iisip. At kami transitioned mula sa na kung Scratch, isang graphical programming wika mula sa aming mga kaibigan sa MIT Media Lab. 

At sa pamamagitan Scratch, ay namin galugarin mga ideya tulad ng pag-andar, at mga kondisyon, at mga loop, at mga variable, at kahit na mga kaganapan, at mga thread, at higit pa. At ngayon, kami ay pagpunta sa magpatuloy sa paggamit ng mga ideya, at talagang pagkuha ng mga ito para sa ipinagkaloob, ngunit isalin ang mga ito sa ibang wika na kilala bilang C. Ngayon, C ay isang mas tradisyunal na wika. Ito ay isang mas mababang antas wika, kung ikaw ay. 

Ito ay pulos sa texto. At kaya sa unang tingin, ito ay lahat ng pagpunta sa tumingin sa halip misteriyoso kung hindi mo pa-program bago. Kami ay pagpunta sa may semi-colons, at panaklong, at kulot tirante, at higit pa. Ngunit mapagtanto na kahit na bagaman ang syntax ay tungkol upang tumingin ng kaunti pamilyar sa karamihan sa inyo, makita ang mga nakaraang iyon. At subukan upang makita ang mga ideya na, sa katunayan, pamilyar, dahil dito sa linggo ng isa kung ano ang sisimulan namin na gawin ay upang ihambing, sa una, Kaskasin versus C. 

Kaya, halimbawa, isipin ang na kapag kami ipinatupad ang unang ng aming mga programa huling oras, kami ay nagkaroon ng isang bloke na tumingin isang maliit na bagay tulad ng this-- kapag berdeng bandila click, at pagkatapos ay nagkaroon kami isa o higit pang mga piraso ng puzzle sa ibaba nito, sa kasong ito, sabihin, kumusta mundo. Kaya, sa katunayan, sa simula, kapag nag-click ko na berdeng bandila upang patakbuhin ang aking programa, kaya na magsalita, ang mga ito ay ang mga bloke na makakuha ng executed, o tumakbo. At, partikular, Scratch sinabi, hello, world. 

Ngayon, maaari ba akong magkaroon tinukoy iba't ibang mga salita dito. Ngunit kami ay makita na, sa katunayan, maraming mga sa mga blocks-- at sa katunayan, sa C maraming functions-- maaaring maging parametrized o customized upang gawin ang iba't ibang bagay. Sa katunayan, sa C kung kami nais i-convert, ngayon, ito Scratch program sa ang iba pang mga wika, kami ay pagpunta sa magsulat ng isang maliit na bagay tulad nito. 

Ipinagkaloob, may ilang mga pamilyar syntax doon malamang, int, at panaklong, at walang bisa. Ngunit printf-- kahit gagawin mo tingin ito would makatarungan maaari print. Ngunit print ay nangangahulugan print format, dahil kakailanganin namin sa lalong madaling panahon makita. Ito literal ay i-print sa screen kahit anong ay sa loob ng mga panaklong, na kung saan siyempre sa kasong ito ay, kumusta mundo. 

Ngunit mapapansin mo ang ilang iba pang mga syntax, ang ilang mga double quotes, na ang mga panaklong sa dulo, ang semi-colon at ang gusto. Kaya doon ay isang bit ng overhead, kaya na magsalita, parehong cognitively at syntactically, na kami ay pagpunta sa may sa tandaan bago ang haba. Ngunit mapagtanto na may kasanayan, ito ay simulan upang tumalon out sa iyo. 

Sa katunayan, sabihin tumuon sa isa na function na specifically-- sa kasong ito, kamustahin mundo. Kaya sabihin ay ang function. Hello world ay parameter nito, o argumento, pagpapasadya nito. 

At ang pagkapareho sa C ay lamang pagpunta sa maging ang isang ito linya dito, kung saan printf ay katumbas ng, sabihin, ang double may panipi string, hello mundo ay katumbas, siyempre, sa kung ano ang sa puting kahon doon. At ang backslash n, kahit na isang maliit kakaiba at absent mula sa simula, lamang ay pagpunta sa magkaroon ng epekto bibigyan namin makita sa isang computer, tulad ng aking Mac o isang PC, na lamang ng paggalaw sa cursor sa susunod na linya. Ito ay tulad ng paghagupit Enter sa iyong keyboard. 

Kaya makikita namin makita na muli bago ang haba. Ngunit una, sabihin tumagal ng isang pagtingin sa ito iba pang mga halimbawa sa kaso ng mga loop. Nagkaroon kami ito magpakailanman loop huling oras, kung saan ay isang serye ng mga piraso ng puzzle na ginawang isang bagay na literal forever-- sa kasong ito, sabihin, hello world, kumusta mundo, hello world, hello mundo. Kaya ito ay isang walang-katapusang loop sa pamamagitan ng disenyo. 

Sa C, kung gusto naming ipatupad ito parehong ideya, maaari naming lamang gawin ito. Habang totoo, printf kumusta world-- ngayon habang, lamang semantically, uri ng conjures up ang ideya ng paggawa isang bagay muli, at muli, at muli, at para sa kung gaano katagal? Well, true-- recall na totoo ay lamang sa o isa. 

At ang tunay na ay, siyempre, laging totoo. Kaya ito ay uri ng isang walang kahulugan pahayag lamang upang sabihin totoo. Ngunit sa katunayan, ito ay sinadya, dahil kung totoo ay lamang laging totoo, kaysa habang totoo lang nagpapahiwatig, kung ang isang maliit hindi direkta, na ang mga sumusunod na linya ng code sa pagitan ng mga kulot tirante dapat lamang execute muli, at muli, at muli, at hindi kailanman talagang itigil. 

Ngunit kung mo nais ang iyong loop upang ihinto, bilang namin ang huling oras na may isang bagay tulad ng ito, ulitin ang mga sumusunod na 50 beses, sa C maaari naming gawin ang parehong sa kung ano ang tinatawag na isang para loop-- keyword hindi pagiging habang, ngunit para sa. At pagkatapos ay mayroon kaming ilang mga bagong syntax dito, sa int i katumbas ng 0, i mas mababa sa 50, i ++. At kami ay bumalik sa na. Ngunit ito ay lamang ng kung paano gusto namin isalin ang hanay ng Scratch bloke sa isang hanay ng C linya ng code. 

Samantala, isaalang-alang variable. At, sa katunayan, kami lang nakita ko ang isa sa isang sandali ang nakalipas. At sa kaso ng simula, kung kami nais na idedeklara ng isang variable na tinatawag na i para i pagiging integer, lamang ng isang numero, at gusto naming upang i-set ito sa ilang mga halaga, Gusto naming gamitin ang orange harangan here-- itakda i sa 0. 

At kami makita ngayon at lampas, tulad ng nakaraang linggo, programmers gawin halos palaging magbilangan mula sa zero, really sa pamamagitan ng convention. Ngunit din dahil pagpapabalik mula aming mga talakayan ng binary, ang pinakamaliit na bilang maaari mong kumakatawan sa anumang bilang ng bits ay lamang pagpunta sa maging 0 mismo. At kaya kami ay karaniwang simulan Sinisimulan maging ang aming mga variable sa 0. 

At sa C upang gawin ang parehong, kami ay pagpunta sa sabihin int para integer, i sa pamamagitan lamang ng convention. Maaari ba akong magkaroon na tinatawag na ito variable kahit ano ang gusto ko, tulad ng sa scratch. At pagkatapos ay ay katumbas ng 0 lamang pinaglaanan ang halaga ng 0 mula sa kanan at naglalagay ito sa mga variable, o ang imbakan lalagyan doon, sa kaliwa. At ang semi-colon dahil kakailanganin namin see-- at nasaksihan namin ang ilan sa mga already-- lamang ay nangangahulugan end ng pag-iisip. Magpatuloy upang gawin ang isang bagay sino pa ang paririto sa mga linya na sundin. 

Ngayon, kung ano ang tungkol Boolean expression? Sariwain sa alaala na sa simula, ito'y mga expression na alinman true o false-- katanungan, talaga, na alinman true o false. Kaya sa kaso ng simula, maaari naming magtanong sa isang simpleng tanong na tulad nito, ay i mas mababa sa 50? Kaya ako, muli, ay isang integer. Siguro kami ay gumagamit ng ito sa isang Scratch program upang subaybayan ang isang marka o isang bagay tulad na. Kaya ito syntax dito sa Scratch lamang ay nangangahulugan, ay i mas mababa sa 50? Well, thankfully, ang isang bagay ay simple sa C. At upang isalin, ito ay lamang namin i say mas mababa sa 50, gamit ang mga pamilyar na key sa iyong keyboard. 

Samantala, kung nais mong sabihin ng isang bagay mas pangkalahatang, tulad ng, well, ay x mas mababa sa y kung saan ang bawat ng x at y ay ang kanilang sarili variable? Maaari naming gawin ang parehong bagay sa C, kaya hangga't hindi namin nilikha ang mga variable na. At kami makita kung paano gawin na bago ang haba. Nais naming lamang sabihin x mas mababa sa y. 

Kaya ikaw ay nagsisimula upang makita ang ilang mga pagkakatulad. At ang mga tao na ginawa Scratch ay tiyak inspirasyon sa pamamagitan ng ilan sa mga pangunahing ideya. At makikita mo ang ganitong uri ng syntax sa maraming languages-- hindi lamang scratch, hindi lamang C, ngunit sawa, at JavaScript, at iba pang mga wika pa rin. 

Isaalang-alang natin ang isa pang tayuan Hayaan mula sa C, ang paniwala ng isang kondisyon, paggawa ng isang bagay nang may pasubali. Kung ang isang bagay ay totoo, gawin ito. Kung ibang bagay ay totoo, gawin na. Ito ay uri ng programming katumbas ng isang tinidor sa kalye. Siguro ito ay isang two-way tinidor, isang tatlong-way tinidor, o higit pa. At sa simula, magkaroon tayo ng nakakita ng isang bagay na katulad nito. 

Kaya ang isang ito ay isang malaking isa. Subalit isaalang-alang ang kamag-anak simple ng logic. Kung x ay mas mababa sa y, iyo ngang sabihing x ay mas mababa kaysa y, iba kung x ay mas malaki kaysa y, iyo ngang sabihing x ay mas malaki kaysa y. At pagkatapos, logically, kung sa tingin mo bumalik sa Scratch o lamang ang iyong sariling mga tao intuwisyon, well, kung x ay hindi dakila kay y, at x ay hindi mas mababa kaysa sa y, pagkatapos ng kurso x ay magiging katumbas ng y. Kaya sa kasong ito, sa pamamagitan ng nesting mga Scratch bloke, maaari naming makamit ang isang tatlong paraan tinidor sa kalsada? 

Samantala, kung gusto naming gawin na sa C, ito arguably hitsura ng isang maliit simpler-- hindi bababa sa sandaling makuha pamilyar sa syntax. Kung x ay mas mababa sa y, printf x ay mas mababa sa y. Iba Pa kung ang x ay mas malaki kaysa sa y, printf x ay mas malaki kaysa y. Else printf x ay katumbas ng y-- at, muli, may mga backslash ay nagtatapos lamang para sa mga bagong linya sa gayon ay kung ikaw aktwal na tumakbo sa ganitong uri ng programa ito would makatarungan ilipat ang iyong cursor sa huli sa susunod na linya ng screen. 

Ngayon, samantala Scratch nagkaroon ng iba pang mas sopistikadong mga tampok, lamang ilan sa kung saan kami ay pagpunta sa una ilipat sa ibabaw sa mundo ng C. At isa sa kanila ay tinatawag na isang listahan sa scratch. At ito ay isang espesyal na uri ng variable na pinapayagan ka na mag-imbak ng maramihang mga bagay sa loob nito pabalik, sa likod, sa likod, upang i-back. 

Sa C, ito ay hindi magkaroon mga listahan, per se, ngunit ang isang bagay na higit pa sa pangkalahatan tinatawag arrays, bagaman kami ay bumalik sa ibang pagkakataon ito semestre sa pagtingin sa isang bagay tinatawag na isang listahan, o talagang isang naka-link na listahan. Ngunit sa ngayon, ang pinakamalapit na katumbas sa C para sa amin ay pagpunta sa maging isang bagay tinatawag na isang array. At isang array ay lamang ng isang espesyal na uri ng variable na nagpapahintulot sa iyo upang mag-imbak ng data likod, sa likod, sa likod, sa likod. 

At, sa katunayan, sa simula, kung gusto naming upang ma-access ang unang elemento ng isang array o isang list-- at ako pagpunta sa tumawag ito, sa pamamagitan ng convention, argv, argument vector, ngunit higit pa sa na bago ang haba. Kung gusto kong upang makakuha ng sa unang elemento ng argv, sa mundo ng Scratch aktwal mong gawin ay karaniwang magbilangan mula sa 1. 

At kaya maaari ba akong makakuha item 1 of argv. Iyan na lamang kung paano MIT ipinatupad ang paniwala ng mga listahan. Ngunit sa C, ako pagpunta sa mas lamang lang sabihin, argv, na muli ay ang pangalan ng aking list-- o upang maging malinaw, isang array. At kung gusto ko ang unang elemento, pupuntahan ko gamitin square bracket, kung saan mo maaaring hindi kadalasang ginagamit sa ilalim ng isang keyboard. 

Ngunit 0 lamang ay nangangahulugan, kumuha ako sa una. Kaya kung minsan at bilang pagpasa sa oras, kami ay pagpunta upang simulan upang makita ang mga dichotomies pagitan Scratch at C, kung saan Scratch gumagamit ng isa. Kami ay nasa C gamitin 0 dito. Ngunit makikita mo mabilis na makita sa sandaling maunawaan mo ang pundasyon ng bawat wika, na anopa't mga bagay simulan upang makakuha ng lahat ng mga mas pamilyar sa pamamagitan ng pagsasanay at pagsasanay. 

Kaya sabihin aktwal na hitsura ngayon sa isang programa. Narito ang magiging unang sa aming C source code para sa kumpletong mga programa. At ang program kami ay pagpunta upang mag-alok para sa konsiderasyon ay ang isang bagay na katumbas sa na mas maaga Scratch piraso. 

Kaya sa dito, mayroon kaming kung ano ang arguably ang pinakasimpleng programa C maaari mong isulat na talaga ang isang bagay. Ngayon, kami ay tumingin nakaraan, para sa ngayon, ay kasama, karaniwang io.h, at ang mga anggulo bracket, at int, at walang laman, at ang kulot tirante, at ang gusto. 

At sabihin tumuon lamang sa ano, hindi bababa sa intuitively, maaaring tumalon out sa iyo na. Sa katunayan, main, hindi ko ginagawa kinakailangang malaman kung ano ito ay, ngunit halos tulad Scratch nagkaroon na kapag berdeng bandila click palaisipan piraso, kaya ang ginagawa C bilang isang programming language magkaroon ng isang pangunahing piraso ng code na ay naisakatuparan sa pamamagitan ng default. At walang pag aalinlangan, literal ito ay pagpunta sa ay tinatawag na main. 

Kaya pangunahing ay isang function. At ito ay isang espesyal na function na umiiral sa C na kapag nagpatakbo ka ng isang programa, ito ay pangunahing na ay makakakuha ng tumakbo sa pamamagitan ng default. Sa mundo ng simula, ito ay karaniwang kapag berde bandila nag-click na got tatakbo sa pamamagitan ng default. 

Samantala, nakakita kami ito bago, printf o i-print-format, na ang dahilan pagpunta sa maging isang function na ito ay may C, kasama ang isang buong grupo ng mga iba, na kalooban sa pana at oras muli, upang gawin eksakto bilang ang pangalan nito ay nagpapahiwatig, i-print ang isang bagay. Ano ang gusto naming i-print? Well, kami na sa pamamagitan ng nasasakupang mga letra tulad these-- kumusta mundo, backslash n sa loob ng double quotes, maaari naming sabihin printf eksakto kung ano ang i-print sa screen. 

Ngunit upang gawin na, sa kasamaang-palad namin kailangang gumawa ng isang bagay na ay na cryptic sa amin mga tao, ngunit hindi bababa sa ito ay medyo readable-- matalim isama, karaniwang io.h, int, main, walang bisa, printf, ang lahat ng mga kahima-himala incantations lang namin nakita sa screen. Ngunit namin talagang kung pumunta mas arcane pa rin. unang kailangan namin upang i-translate ang code sumulat tayo sa machine code. At isipin ang mula noong nakaraang linggo na machine, ng hindi bababa sa ang mga alam namin dito, sa pagtatapos ng araw lamang maunawaan zero at mga. 

At ang aking Diyos, kung kami ay upang isulat ang mga zero at mga upang aktwal na programa, gagawin ito napaka, masyadong mabilis tumagal ng kasiyahan sa labas ng kahit ano. Ngunit ito ay lumiliko out, per noong nakaraang linggo, na ang mga pattern ng mga zero at mga na lang ay espesyal na kahulugan. Sa ilang mga konteksto, maaaring sila ibig sabihin ng mga numero. 

Sa ilang mga konteksto, maaari nilang sabihin mga titik, o kulay, o anumang bilang ng iba pang mga abstractions nasasabog sa. Ngunit tulad ng iyong computer ay may isang CPU, Central Processing Unit, o ang talino sa loob ng iyong computer. Ito ay karaniwang Intel sa loob, dahil na isa sa mga pinakamalaking kumpanya na gumagawa ng CPUs para sa mga computer. 

Well, Intel CPUs at iba pa lamang ay nagpasya nang maaga na ang ilang mga pattern ng mga zero at iyan ay mangangahulugang tiyak na mga bagay. Ang ilang mga pattern ng mga zero at mga ay ibig sabihin, i-print ito sa screen, o magdagdag ng mga ito ng dalawang mga numero, o ibawas ang dalawang numero, o galaw ng mga piraso ng data mula sa memorya ng aking computer sa paglipas dito, o anumang bilang ng iba pang mga mababang antas, ngunit sa huli kapaki-pakinabang, mga operasyon. Ngunit, thankfully, namin ang mga tao ay hindi pagpunta sa kailangan upang malaman na ito antas ng detalye. Sa katunayan, gusto lamang noong nakaraang panahon, na kung saan kami lumilipad ang isip muli, at muli, at muli, gusali mula napakababang antas primitives tulad zero at mga sa mas mataas na antas ng konsepto tulad ng mga numero, at mga titik, at mga kulay, at iba pa, upang maaari naming bilang programmer tumayo sa mga balikat ng iba na dumating bago sa amin at gumamit ng software na ang ibang mga tao ay may nakasulat na bago us-- namely mga programa na tinatawag compiler. 

C ay isang wika na ay karaniwang naipon, na nangangahulugan na-convert mula source code sa makina code. Sa partikular, kung ano ang ibig sabihin nito ay na kung mayroon ka sa iyong source code na ikaw mismo sumulat, bilang namin sa lalong madaling panahon ay sa sandali lamang sa screen, at nais mong i-convert ito sa huli sa machine code-- mga zero at mga bago na lamang ang iyong Mac o iyong PC understands-- mayroon ka ng isang unang feed na source code sa bilang input sa isang espesyal na programa na tinatawag na isang tagatala, ang output ng na kung saan namin dapat makita ay machine code. At, sa katunayan, huling oras namin talked tungkol sa, talaga, sa dulo ng araw, pagtugon sa suliranin. Mayroon kayong inputs. At mayroon ka outputs. At mayroon ka ng ilang mga uri ng algorithm sa gitna. 

Algorithm ay maaaring tiyak maging ipinatupad sa software, tulad ng nakita natin sa pseudocode noong nakaraang linggo at dahil kakailanganin namin makita na may aktwal na code ngayong linggo. At sa gayon ang isang compiler talagang lamang ay may isang hanay ng mga algorithm sa loob ng mga ito na malaman kung paano convert ang mga espesyal na mga keyword, tulad main, at printf, at iba pa na kami lang Nakita sa ang mga pattern ng mga zero at mga na Intel loob at iba pang mga CPUs talagang nauunawaan. Kaya kung paano ang gagawin namin ito? Saan kami makakuha ng isang compiler? 

Karamihan sa atin dito ay may isang Mac o isang PC. At ikaw ay nagpapatakbo ng Mac OS, o Windows, o Linux, o Solaris, o anumang bilang ng iba pang mga mga operating system. At, sa katunayan, maaari naming pumunta out papunta sa web at i-download ng isang tagatala para sa iyong Mac o iyong PC para sa iyong partikular na operating system. Ngunit Gusto namin ang lahat ng maging sa iba't ibang mga pahina, kaya na magsalita. Gusto naming magkaroon ng bahagyang iba't ibang mga configuration. At mga bagay ay hindi gumagana sa lahat ng mga parehong. At, sa katunayan, ang mga araw marami sa amin ay hindi gumagamit software na tumatakbo lamang sa aming laptops. Sa halip, gamitin namin ang isang bagay tulad ng isang browser na ay nagbibigay-daan sa amin upang ma-access ang web-based application sa cloud. At sa ibang pagkakataon sa semestre, kami ay gawin eksakto na. Susubukan naming magsulat ng mga aplikasyon o software hindi gumagamit code-- C, ngunit ang iba pang mga wika tulad ng sawa at JavaScript-- na tumakbo sa cloud. 

At upang gawin iyon, tayo mismo sa panahon ng semestre ay tunay na gumamit ng isang ulap-based kapaligiran na kilala bilang CS50 IDE. Ito ay isang web-based programming kapaligiran, o isinama unlad kapaligiran, IDE, na binuo sa ibabaw ng ilang open source software na tinatawag na Cloud 9. At hindi na namin na ginawa ng ilang paturo simplifications dito sa gayon ay upang itago ang ilang mga tampok sa ang unang linggo na hindi namin kailangan, matapos na kung saan maaari mong ipakita ang mga ito at gawin ang karamihan anumang nais mo sa kapaligiran. 

At ito ay nagbibigay-daan sa amin, masyadong, upang pre-install ng ilang mga software. Mga bagay na tulad ng isang tinatawag na CS50 library, na kung saan kami ay sa lalong madaling panahon makita ang ay nagbibigay sa amin sa C na may ilang karagdagang pag-andar. Kaya kung ikaw ay pupunta sa, sa huli, CS50.io, ipo-prompt upang mag-log in, at sa sandaling gawin mo at lumikha ng account para sa libre, ikaw ay maaaring na ang isang kapaligiran na mukhang lubos na tulad nito. 

Ngayon, ito ay sa default mode. Lahat ng bagay ay maganda at maliwanag sa screen. Marami sa atin ay may isang ugali ng nagtatrabaho sa CS50 piraso na medyo late sa gabi. At kaya ang ilan sa inyo ay maaaring ginusto na on ito sa night mode, kaya na magsalita. 

Ngunit, sa huli, ano ang ikaw ay pagpunta upang makita ang loob ng CS50 IDE ay tatlong natatanging mga areas-- isang lugar sa kaliwa kung saan ang iyong mga file ay pagpunta sa maging sa cloud, isang lugar sa kanang tuktok kung saan ang iyong code ay pagpunta sa maging nae-edit. Magagawa mong upang buksan indibidwal na mga tab para sa anumang programa na sinulat mo ito semestre loob ng na tuktok na kanang sulok. At pagkatapos ay pinaka-arcanely, at pa powerfully, ay pagpunta sa maging ang bagay na ito sa bottom kilala bilang isang terminal window. 

Ito ay isang lumang paaralan Command Line Interface, o CLI, na nagbibigay-daan mong execute command sa computer-- sa kasong ito, ang computer sa ang cloud-- gumawa ng mga bagay tulad ng itala ang iyong code mula sa source code sa makina code, upang patakbuhin ang iyong mga programa, o upang simulan ang iyong web server, o i-access ang iyong database, at anumang bilang ng iba pang mga diskarte na magsisimula kami upang gamitin bago ang haba. Ngunit upang makarating doon, hindi namin pagpunta sa aktwal na magkaroon ng upang mag-online at simulan ang paglalaro. At upang gawin iyon, sabihin muna simulan tinkering sa main, at isulat ang mga pangunahing bahagi ng isang programa. At gamitin natin na function printf, na ginamit namin nang mas maaga, lamang sabihin ng isang bagay. 

Kaya dito ako na sa loob ng CS50 IDE. Ko na naka-log in advance. At ako'y puspos screened window. At kaya, sa huli, ikaw masyadong sa pagdating problema ay sundin katulad na hakbang na ay magbibigay ng online na dokumentasyon. Kaya hindi mo na kailangang mag-alala tungkol sa lubhang kaganyak-ganyak ang bawat maliit na teknikal na hakbang ay siya kong ginagawa dito ngayon. 

Ngunit makakakuha ka ng isang screen na tulad nito. Mangyayari kong maging sa gabi mode. At maaari mong magpasaya ang lahat ng bagay up sa pamamagitan ng hindi gabi mode. At sa katapusan ng araw, ikaw ay pagpunta upang makita ang tatlong pangunahing areas-- ang file browser sa kaliwa, ang code ay tabs up tuktok, at ang terminal window sa ibaba. 

Hayaan akong sige at isulat ang aking unang programa. Pupunta ako sa preemptively pumunta sa File, I-save, at i-save ang aking file bilang hello.c. Sa katunayan, sa pamamagitan ng convention, ang anumang mga programa namin isulat na nakasulat sa C wika ay dapat na pinangalanan ng isang bagay dot c, sa pamamagitan ng convention. Kaya ako ng pagpunta upang pangalanan ito hello.c, dahil Gusto ko lang kamustahin sa mundo. Ngayon ako pagpunta upang mag-zoom out at i-click ang I-save. At lahat ng kailangan kong dito ngayon ay isang tab kung saan ang maaari kong simulan ang pagsusulat code. 

Ito ay hindi pagpunta sa sumulat ng libro. Ang ibig sabihin nito wala. At kaya kahit na ako napalitan ito sa mga zero at mga bago, ang CPU ay pagpunta sa magkaroon ng walang ideya kung ano ang nangyayari sa paligid. Ngunit kung ako ay sumulat ng mga linya na tumutugma up gamit ni C conventions-- C pagkatao, muli, ito language-- may syntax tulad ito, printf kumusta world-- at na ako gotten komportable sa paggawa na ito sa paglipas ng panahon. Kaya hindi ko sa tingin ko ginawa anumang mga typographical error. 

Ngunit, walang paltos, ang pinakaunang oras na gawin mo ito, ikaw ay. At kung ano ako tungkol sa upang gawin baka very well hindi gumagana para sa iyo sa unang pagkakataon. At na ay ganap na ganap ang OK, dahil sa ngayon mo maaaring lamang makita ang isang buong pulutong ng kabaguhan, ngunit sa paglipas ng panahon sa sandaling makuha mo pamilyar sa environment na ito, at wikang ito, at iba pa, ikaw ay magsisimulang upang makita ang mga bagay na ay alinman sa tama o hindi tama. 

At ito ay kung ano ang Fellows ng pagtuturo at kurso assistants makakuha kaya magandang sa paglipas ng panahon, ay pagtutuklas mga pagkakamali o mga bug sa iyong code. Ngunit inaangkin ko na Walang mga bug sa code na ito. Kaya ako ngayon ay nais na patakbuhin ang program na ito. 

Ngayon sa aking sariling Mac o PC, ako sa ang ugali ng pag-double click icon kapag gusto kong magpatakbo ng ilang mga programa. Ngunit hindi iyon ang modelo dito. Sa environment na ito, na kung saan ay CS50 IDE. Kami ay gumagamit ng isang operating sistema na tinatawag na Linux. Linux ay nakapagpapaalaala ng isa pang operating system, karaniwang kilala bilang Unix. At Linux ay partikular na kilala para sa pagkakaroon ng isang Command Line Environment, CLI. Ngayon, kami ay gumagamit ng isang tiyak na lasa ng Linux tinatawag Ubuntu. At Ubuntu ay lamang ng isang tiyak na bersyon ng Linux. 

Ngunit ang mga Linux ang ayon sa mga araw na ito gawin ang tunay na sumama sa graphical user interface. At ang isa mangyari namin upang ay gumagamit dito ay web-based. Kaya ito ay maaaring tumingin kahit na isang maliit na naiiba mula sa isang bagay mo ang iyong sarili ay maaaring magkaroon ng nakita o tumakbo sa nakaraan. 

Kaya ako pagpunta sa sige ngayon at gawin ang sumusunod. Ko na naka-save ang file bilang hello.c. Ako pagpunta sa sige at type clanghello.c Kaya Clang para sa C wika ay isang tagatala. Ito ay pre-install sa CS50 IDE. At maaari mong ganap na i-download at i-install ito sa iyong sariling Mac o PC. 

Ngunit, muli, ikaw ay hindi magkaroon ng lahat ng ang pre-configuration ginawa sa inyo. Kaya sa ngayon, ako lang pagpunta sa tumakbo clanghello.c. At ngayon mapansin ang syntax na ito dito ay tuluyang mapagtanto lamang ay nangangahulugan na ako sa isang folder o direktoryo na tinatawag na workspace. Ito dollar sign ay lamang convention para sa kahulugan, i-type ang iyong mga utos dito. 

Ito ay kung ano ang tinatawag na isang prompt, lamang sa pamamagitan ng convention ay dollar sign. At kung pumunta ako magpatuloy ngayon at i-click ang Ipasok, wala tila sa nangyari. Ngunit iyon lamang ang tunay na isang magandang bagay. Ang mas mababa na ang mangyayari sa iyong screen, mas malamang na ang iyong code ay upang maging tama, hindi bababa sa syntactically. 

Kaya kung nais kong patakbuhin ito programa, kung ano ang gagawin ko? Well, ito ay lumiliko out na ang mga default na pangalan sa pamamagitan ng convention para sa mga programa na hindi mo tukuyin ang isang pangalan para sa iyong programa ay lamang a.out. At ito syntax masyadong, bibigyan ka maging pamilyar sa bago ang haba. 

Dot iwa lamang ay nangangahulugan, hey, CS50 IDE, magpatakbo ng isang programa na tinatawag na a.out na sa loob ng aking kasalukuyang direktoryo. dot Ito ay nangangahulugan na ang kasalukuyang direktoryo. At kami makita kung ano ang iba pang tulad sequences ng mga character ay nangangahulugan bago ang haba. 

Kaya dito namin pumunta, Ipasok, kumusta mundo. At mapapansin mo, na kung ano ang nangyari? Hindi lamang i-print ito kumusta mundo. Ito rin ay inilipat ang cursor sa susunod na linya. 

At bakit ay na? Ano ang code na aming sinulat bago na nakasisiguro na ang cursor ng gagawin pumunta sa susunod na linya? Nakakatawang bagay tungkol sa isang computer ay lamang ito ay pagpunta gawin literal kung ano ang iyong sabihin sa ito upang gawin. 

Kaya kung sabihin mo ito sa printf hello, comma, space, world, malapit quote, ito ay literal lamang ang pagpunta upang i-print ang mga character. Ngunit ako ay ang mga espesyal na karakter sa dulo, pagpapabalik, backslash n. At na kung ano nakasisiguro na ang karakter nagpunta sa susunod na linya ng screen. 

Sa katunayan, hayaan mo akong pumunta at gawin ito. Hayaan akong sige at tanggalin ito. Ngayon, mapapansin na ang tuktok ng aking screen mayroong isang maliit na pulang ilaw sa ang tab na nagpapahiwatig, hey, hindi na-save mo ang iyong mga file. Kaya ako pagpunta sa sige sa control S o command S, i-save ang file. Ngayon ito goes-- nagpunta para sa isang moment-- green. At ngayon ito ay bumalik sa lamang ang pagiging isang malapit icon. 

Kung ako ngayon tumakbo clanghello.c muli, Ipasok, tuldok slash, a.out, Ipasok, makikita mo na ito pa rin nagtrabaho. Ngunit ito ay arguably isang maliit na maraming surot. Sa ngayon, ang aking prompt-- workspace, at pagkatapos na dollar sign, at pagkatapos ay ang aking aktwal na prompt-- ay ang lahat sa parehong linya. Kaya ito ay tiyak na isang Aesthetic bug, kahit na ito ay hindi talagang isang lohikal bug. 

Kaya ako pagpunta sa i-undo kung ano ko lang ginawa. Pupunta ako sa muling palabas ng pelikula a.out. Paunawa Idinagdag ko na ang newline character likod. Ko na nai-save ang file. 

Kaya ako ng pagpunta sa gawin uli a.out, at- dammit, isang bug, isang bug na nangangahulugang tama. Kaya ang bug ay na kahit na Idinagdag ko ang backslash n doon, re-save, muling tumakbo ang programa, ang pag-uugali ay ang parehong. Bakit nais na maging? 

Ako nawawala ang isang hakbang, right? Iyon mahalagang hakbang mas maaga ay na ikaw ay may to-- kapag binago mo ang iyong source code, ito ay lumiliko out naman ay iyong patakbuhin ito sa pamamagitan ng compiler muli upang makakuha ka ng mga bagong machine code. At ang machine code, ang mga zero at mga bago, ay pagpunta sa maging halos magkapareho, ngunit hindi ganap na ito, dahil kailangan namin, siyempre, na ang mga bagong linya. 

Kaya upang ayusin ito, ako pagpunta sa kailangan upang muling palabas ng pelikula clanghello.c, ipasok, tuldok slash, a.out. At ngayon, hello world ay bumalik sa kung saan ko inaasahan ito upang maging. Kaya ito ay ang lahat ng fine at mabuti. Ngunit a.out ay isang medyo bobo pangalan para sa isang programa, kahit na ito ang mangyayari sa maging, para sa mga makasaysayang dahilan, ang default-- ibig sabihin assembly outputs. 

Ngunit ipaalam sa akin sige dito at gawin ito sa ibang paraan. Gusto ko ang aking hello world program upang aktwal na tinatawag na kumusta. Kaya kung ito ay isang icon sa aking desktop, hindi na ito ay a.out. Gusto Ito ay tinatawag na hello. 

Kaya upang gawin ito, ito ay lumiliko out na Clang, tulad ng maraming mga programa, sinusuportahan command line argumento, o flags, o switch, na lang maka-impluwensya nito pag-uugali. Sa partikular, Clang ay sumusuporta sa isang gitling o flag, na kung saan pagkatapos ay tumatagal ng isang pangalawang salita. Sa kasong ito, makikita ko nagkataon, ngunit makatwirang, tumawag ito hello. Ngunit maaari kong tumawag ito anumang bagay gusto ko, maliban a.out, na kung saan ay sa halip bukod sa point. 

At pagkatapos lamang tukuyin ang pangalan ng file ang gusto kong sumulat ng libro. Kaya ngayon kahit na sa simula ng utos ko pa rin magkaroon Clang, sa dulo ng command Ako pa rin ay filename, Ako ngayon ay mayroon ang mga command line argumento, ang mga flags na sinasabi, oh, maiba ako, output-o, ang isang file na tinatawag na halo, hindi ang default a.out. 

Kaya kung ako pindutin ang Enter ngayon, wala Parang may nangyari. At, gayon pa man, ngayon ko magagawa dot slash kumusta. Kaya ito ay ang parehong programa. Ang mga zero at mga bago ay magkapareho sa dulo ng araw. 

Ngunit ang mga ito sa loob ng dalawang iba't ibang files-- a.out, kung saan ay ang unang bersyon at lamang maloko pinangalanan, at ngayon hello, na kung saan ay isang mas mas nakakahimok pangalan para sa isang programa. Ngunit, totoo lang, ako ay hindi kailanman pagpunta sa tandaan na ito muli, at muli, at muli. At, talaga, bilang isulat namin mas masalimuot na mga programa, ang mga utos ikaw ay pagpunta sa may sa sumulat ay pagpunta upang makakuha ng kahit mas kumplikado pa rin. 

At kaya hindi mag-alala. Ito ay lumiliko out na ang mga tao bago sa amin ay may natanto sila ay masyadong nagkaroon na ito eksaktong parehong problema. Sila ay masyadong ay hindi mag-enjoy pagkakaroon upang type medyo matagal, arcane utos, pabayaan mag-isa tandaan ang mga ito. At kaya ang mga tao sa harap namin ay may ginawa iba pang mga programa na gawing mas madali upang ipunin ang iyong software. 

At, sa katunayan, isa tulad programa ay tinatawag Make. Kaya ako pagpunta sa sige at gawin ito. Pupunta ako upang i-undo lahat ng bagay ako lang ginawa sa mga sumusunod na paraan. Hayaan akong i-type LS. At mapapansin mo tatlong bagay- a.out, at isang star, hello at isang bituin, at hello.c. Sana, ito ay dapat maging isang maliit na madaling maunawaan, insofar bilang mas maaga nagkaroon wala sa workspace na ito. Nagkaroon walang na ako ay nilikha hanggang sinimulan namin class. 

At ako nilikha hello.c. Ako pagkatapos ay pinagsama-sama ito, at tinawag na a.out. At pagkatapos ay ako compiled ito muli bahagyang sa ibang paraan at tinawag na hello. Kaya Mayroon akong tatlong mga file sa direktoryong ito, sa folder na ito na tinatawag na workspace. Ngayon, maaari ko bang makita na pati na rin kung ako mag-zoom out talaga. 

Kung ako mag-zoom out dito at tumingin sa na tuktok na kanang sulok, tulad ng ipinangako sa kaliwa kamay bahagi ng iyong screen ay palaging pagpunta upang ipakita sa iyo kung ano ang sa iyong account, kung ano ang sa loob ng CS50 IDE. At doon ay tatlong mga file doon. 

Kaya gusto kong kumuha alisan ng a.out at kumusta. At bilang maaari mong isipin intuitively, ikaw maaaring ayusin ng control click o i-right click sa mga ito. At ito maliit na menu nagpa-pop up. Maaari mong i-download ang file, patakbuhin ito, i-preview ito, i-refresh, palitan ang pangalan, o kung ano ang hindi. 

At hindi ko na lang tanggalin, at ito ay pumunta ang layo. Ngunit sabihin gawin mga bagay na may isang command line para sa ngayon, sa gayon ay upang makakuha ng komportable Kaugnay nito, at gawin ang mga sumusunod. Ako pagpunta sa sige at mag-alis a.out sa pamamagitan ng pagtype literal rma.out. Ito ay lumiliko out, ang utos para sa pag-alis o pagtanggal ng isang bagay, ay hindi mag-alis o tanggalin. 

Ito ay higit pa succinctly RM, lamang upang i-save ang sa iyo ng ilang mga keystroke, at pindutin ang Enter. Ngayon kami ay pagpunta sa maging tila cryptically alisin regular file a.out. Hindi ko talaga alam kung ano ang isang irregular file ay magiging pa. Ngunit ko nais na alisin ito. 

Kaya ako pagpunta sa i-type y para sa yes. O maaari kong i-type ito, at pindutin ang Enter. At, muli, wala tila sa mangyayari. Ngunit iyon ay, sa pangkalahatan, isang magandang bagay. 

Kung nagta-type ako LS oras na ito, ano ang dapat kong makita? Sana, lamang hello and hello.c. Ngayon, bilang isang bukod, makikita mo mapansin ito star, asterisk, na sa dulo ng aking mga programa. At sila ay nagpapakita rin up sa berde. Iyon ay lamang CS50 IDE ng paraan ng cluing ka sa ang katunayan na iyan ay hindi source code. Iyan ay isang executable, isang runnable programa na maaari mong aktwal na patakbuhin sa pamamagitan ng paggawa dot slash, at pagkatapos ito ay pangalan. 

Ngayon, ipaalam sa akin sige at mag-alis ito, rm kumusta, Ipasok, alisin regular maghain hello, yes. At ngayon, kung nagta-type ako LS, hindi namin pabalik sa hello.c. Subukan ang hindi upang tanggalin ang iyong aktwal na source code. Kahit na may mga tampok binuo sa CS50 IDE kung saan maaari kang pumunta sa pamamagitan ng iyong kasaysayan ng pagbabago at rewind sa oras kung hindi mo sinasadyang tanggalin ang isang bagay, gawin alintanahin bilang bawat ang mga senyas oo o hindi, ng kung ano ang iyong aktwal na nais na gawin. At kung pumunta ako hanggang sa tuktok kaliwang kamay sulok dito, lahat na nananatiling ay hello.c. Kaya mayroong bunches ng iba pang mga utos na ikaw maaaring magsagawa sa mundo ng Linux, isa rito ay, muli, Makipagkaibigan. At kami ay pagpunta sa Gumawa ang aking mga programa na ngayon bilang mga sumusunod. 

Sa halip ng paggawa kalatungin, sa halip ng paggawa kalatungin-o, Pupunta ako sa kailangan lang literal type, gumawa ng halo. At ngayon mapansin, ako hindi pag-type gumawa hello.c. Ako ay pag-type gumawa ng halo. 

At ang program na ito Gawin na lumapit kumuha CS50 IDE, at higit pa sa pangkalahatan ay may Linux, ay isang programa na ay pagpunta sa gumawa ng isang programa na tinatawag Hello. At ito ay pagpunta sa ipinapalagay, sa pamamagitan ng convention, na kung ang program na ito ay maaaring gawin, ito ay pagpunta sa gawin mula sa isang pinagmulan code file na nagtatapos sa tuldok c, hello.c. 

Kaya kung ako pindutin ang Enter ngayon, mapapansin na ang utos na ay naisakatuparan ay talagang mas mahaba bago kaysa dati. At iyon ay dahil hindi namin preconfigured CS50 IDE na magkaroon ilang karagdagang mga tampok na binuo sa na hindi namin lamang pa kailangan, ngunit sa lalong madaling panahon ay. Ngunit ang pangunahing bagay upang mapagtanto ngayon ay mayroon akong isang Kamusta programa. 

Kung nagta-type ako LS muli, ako magkaroon ng isang kumusta programa. At maaari ba akong magpatakbo ng ito sa dot slash a.out, hindi, dahil ang buong punto ng mga ito exercise ay dot slash kumusta. At ngayon, mayroon ko ang aking hello world program. Kaya ang paglipat ng pasulong, kami ay halos palaging lamang pagpunta sa sumulat ng libro sa aming mga programa paggamit ng command Make. At pagkatapos ay kami ay pagpunta sa patakbuhin ang mga ito sa pamamagitan ng dot slash, at pangalan ng program. Ngunit mapagtanto kung ano Gumawa ginagawa para iyo, ay hindi ito mismo ay isang tagatala. Ito lamang ay isang convenience program na nakakaalam kung paano upang palitawin ang isang compiler na tumakbo sa gayon ay maaari mo ang iyong sarili na gamitin ito. 

Ano ang iba pang mga utos na umiiral sa Linux, at sa turn ang CS50 IDE? Susubukan naming lalong madaling panahon makita na mayroong isang CD command, Baguhin Directory. Ito ay nagpapahintulot sa iyo sa loob ng iyong command line interface upang sumulong, at likod, at buksan up ng iba't ibang mga folder walang gamit ang iyong mouse. 

LS nakita natin, na nakatayo para sa listahan ang mga file sa kasalukuyang directory. Gumawa Dir, maaari mong marahil simulan upang ipahiwatig kung ano ang mga ibig sabihin now-- gumawa direktoryo, kung nais mong lumikha ng isang folder. RM para tanggalin, RM Dir para alisin directory-- at ang mga ito, muli, ang mga command line katumbas ng kung ano ang iyong ay maaaring gawin sa CS50 IDE gamit ang iyong mouse. Ngunit makikita mo sa lalong madaling panahon mahanap na kung minsan ito lamang ay ng maraming mas mabilis na gawin bagay na may isang keyboard, at sa huli ng isang pulutong mas malakas na. 

Ngunit ito ay mahirap na magtaltalan na anumang bagay na-paggawa namin sa ngayon ay ang lahat na malakas, kapag ang lahat ng kami ay sinasabi ay, kumusta mundo. At, sa katunayan, ako hardcoded ang salita hello world sa aking programa. Walang dynamism pa. Scratch ay isang order ng magnitude mas kawili-wiling noong nakaraang linggo. 

At kaya sabihin makakuha ng doon. Tingnan natin ang isang hakbang patungo sa na sa pamamagitan ng paraan ng ilan sa mga pag-andar. Kaya hindi lamang ang C sumama sa printf, at bunches ng iba pang mga function ilan sa kung saan kami ay makita sa paglipas ng panahon, ito ay hindi gawin itong lahat na madali karapatan sa labas ng pintuang-daan sa pagkuha ng user input. 

Sa katunayan, ang isa sa mga kahinaan ng mga wika tulad ng C, at kahit na Java at pa iba, ay na ito ay hindi gawing madali upang makakuha lamang ng mga bagay tulad integers mula sa mga gumagamit, o mga string, mga salita, at mga parirala, pabayaan mag-isa ang mga bagay tulad lumulutang halaga punto, o tunay na mga numero may mga decimal point, at talagang mahaba ang mga numero, dahil kakailanganin namin sa lalong madaling panahon makita. Kaya ito listahan ng mga function dito, ang mga ito ay tulad ng iba pang mga piraso Scratch puzzle na kami ay pre-install sa CS50 IDE na gagamitin namin para sa ilang linggo bilang training wheels ng mga uri, at sa wakas kumuha ng mga ito off, at hanapin sa ilalim ng hood, marahil, sa kung paano ang mga bagay na ito ay ipinatupad. 

Ngunit upang gawin ito, sabihin aktwal na magsulat ng isang programa. Hayaan akong magpatuloy ngayon. At ako pagpunta upang lumikha ng isang bagong maghain iki-click mo ito maliit na plus, at pag-click New File. 

Pupunta ako upang i-save ito sa susunod na isa bilang, sabihin nating, string.c, dahil gusto kong i-play sa mga string. At string sa C ay lamang isang pagkakasunod-sunod ng mga character. Kaya ngayon sabihin sige at gawin ang mga sumusunod. 

Isama ang standard IO.h-- at ito ay lumiliko out standard IO, IO ay nangangahulugan lamang input at output. Kaya ito lumiliko out na ang linyang ito dito ay kung ano ay ang mga karatig sa amin upang gamitin printf. Printf, siyempre, ay gumagawa ng output. Kaya upang magamit printf, ito ay lumiliko out kailangan mong magkaroon ng ito linya ng code sa tuktok ng iyong mga file. 

At kami ay bumalik sa kung ano ang na talagang ay nangangahulugan bago ang haba. Ito ay lumiliko out na sa anumang C program isulat ko, Mayroon akong upang simulan ito sa code na ganito ang hitsura. At mapapansin mo CS50 IDE, at iba pang mga pinagsamang pag-unlad kapaligiran tulad nito, ay pagpunta sa subukan bilang pinakamahusay na maaari nilang upang tapusin ang iyong pag-iisip. Sa katunayan, isang sandali ang nakalipas kung i-undo ko ano ko lang ginawa, ako hit ang Enter. 

Ako pagkatapos ay pindutin open curly suhay, pindutin ang Enter muli. At natapos ang aking pag-iisip. Ito ay ibinigay sa akin ng isang bagong linya, yupi hindi kukulangin for nice pangkakanyahan dahilan kami makita. At pagkatapos ito ay awtomatikong ibinigay sa akin na kulot suhay upang tapusin ang aking pag-iisip. Ngayon, ito ay hindi laging hulaan kung ano ang gusto mong gawin. Ngunit sa malaking bahagi, ginagawa nito save ka ng ilang mga keystroke. Kaya ang isang sandali ang nakalipas, tumakbo namin ito program-- kumusta, mundo, at pagkatapos ay pinagsama-sama ito, at pagkatapos ay tumakbo ito. Ngunit walang dynamism dito. Paano kung gusto naming gawin ang isang bagay naiiba? Well, kung ano kung ako pinaghahanap upang aktwal na makakuha ng isang string mula sa user? Ako pagpunta sa gumamit ng isang piraso puzzle tinatawag eksakto na- makakuha string. 

Lumiliko out sa C na kapag hindi mo nais upang magbigay ng input sa isang piraso puzzle, o mas maayos sa isang function, ikaw literal lamang gawin bukas panaklong, malapit panaklong. Kaya ito ay bilang bagaman diyan ay walang puting kahon upang i-type sa. Ang say bloke bago ay nagkaroon ng isang maliit na puting kahon. Wala kaming na puting kahon na ngayon. 

Ngunit kapag ang tawag ko get string, ako nais na ilagay ang resulta sa isang lugar. Kaya isang napaka-karaniwang paradaym sa C ay upang tumawag sa isang function, tulad ng get string dito, at pagkatapos ay tindahan nito return value. Ito ay ang resulta ng kanyang pagsisikap sa isang bagay. 

At kung ano ang tayuan sa programming, kung sa scratch o ngayon C, na kami ay maaaring gamitin upang aktwal na tindahan ng isang bagay? Tinatawag ito ng isang variable, right? At sa simula, hindi namin talagang pag-aalaga kung ano ang nangyayari sa mga variable. 

Ngunit sa kasong ito, kami talagang gawin. Pupunta ako sa sabihin string. At pagkatapos ay maaari kong tumawag ito kahit ano ang gusto ko. Ako pagpunta sa tumawag ito pangalan, ay makakakuha makakuha string. 

At ngayon kahit na ikaw ay isang maliit na bago sa ito, mapansin na ako ng kulang ilang mga detalye. Ako forgetting isang semi-colon. Kailangan ko upang matapos-iisip na ito. Kaya ako pagpunta sa ilipat ang aking cursor, at pindutin semi-colon doon. At ano ang ko na lang ginawa? Sa ganitong linya ng code, number 5 sa sandaling ito, Ako ng pagtawag get string na walang inputs. Kaya walang maliit na puting kahon tulad ng mga save block ay may. 

Lang ako sa sinasabi, hey, computer, kumuha ako ng isang string. Ang katumbas sign ay hindi tunay equal sign, per se. Ito ay ang assignment operator, na nangangahulugan, hey, computer, ilipat ang halaga mula sa kanan sa ibabaw ng mga kaliwa. At sa kaliwa, mayroon akong mga sumusunod. 

Hey, computer, bigyan ako ng isang string isang pagkakasunod-sunod ng mga character. At tumawag na string Name. At ako ay hindi kahit na sa tawag na ito Name. 

kaya kong tumawag ito, conventionally, isang bagay tulad ng S, marami tulad ng ginamit namin i upang tawagan ang variable i. Ngunit ngayon kailangan kong gawin ang isang bagay sa mga ito. Gusto Ito ay medyo bobo sa subukan kino-compile ang code, tumatakbo ang program na ito, kahit na Nakakakuha ako ng isang string, dahil ito ay pa rin lamang pagpunta sa sabihin kumusta mundo. 

Ngunit paano kung ang gusto kong baguhin ito. Bakit hindi ko ito? Percent s, comma s. At ito ay isang maliit na misteriyoso pa rin. 

Kaya hayaan mo akong gumawa ng aking mga variable mas malinaw. Hayaan akong pangalanan ito variable Name. At sabihin makita kung hindi namin maaaring manunudyo bukod kung ano ang nangyayari dito. 

Kaya sa limang linya, Nakakakuha ako ng isang string. At ako sa pag-iimbak na string, kahit anong ang gumagamit ay nai-type sa sa kanyang keyboard, sa isang variable na tinatawag na Pangalan. At ito ay lumiliko out na printf ay hindi lamang kumuha ng isang argument sa double quotes, isa input sa loob ng double quotes. 

Maaari itong tumagal ng dalawa, o tatlo, o higit pa, tulad na ang pangalawa, o pangatlo, o pang-apat, ay ang lahat ng mga pangalan ng variable, o partikular halaga, na nais mong plug sa, pabago-bago, na string sa mga panipi. Sa ibang salita, kung ano ay mali sa mga ito? Kung sinabi ko lang kumusta pangalan, backslash n, na-save ang aking file, pinagsama-sama ang aking code, at tumakbo ito, ano ang mangyayari? 

Lamang Ito ay pagpunta sa sabihin, hello pangalan, literal N-A-M-E, na kung saan ay uri ng bobo dahil ito ay hindi naiiba mula sa mundo. Kaya kahit ano sa mga panipi ay ano literal ay makakakuha ng naka-print na. Kaya kung nais ko na magkaroon ng isang placeholder doon, Ako tunay na kailangan na gumamit ng ilang mga espesyal na syntax. At ito ay lumiliko out kung basahin mo ang dokumentasyon para sa printf function, ito ay sabihin sa iyo na kung gumagamit ka ng porsiyento s, maaari mong kapalit ang halaga ng isang sumusunod. 

Pagkatapos ng isang comma pagkatapos na double quote, kailangan lang isulat ang pangalan ng variable na nais mong mag-plug in sa format na code, o format specifier, porsiyento s para sa mga string. At ngayon kung ako na-save ang aking file, pumunta ako pabalik pababa sa aking terminal. At i-type Ako Magkakaroon ng String, dahil, muli, ang pangalan ng ito file na pinili ko bago ay string.c. 

Kaya ako pagpunta sa sabihin Gumawa String, ipasok. Oh aking kabutihan, tumingin sa lahat ng ang mga pagkakamali na ginawa namin na. At ito is-- kung ano, ito ay talagang tulad ng isang anim, pitong line program? Kaya ito ay kung saan ito maaari tunay mabilis na makakuha ng napakalaki. 

Ito terminal window ay ngayon lang regurgitated isang malaking bilang ng mga mensahe ng error. Tiyak, hindi ko magkaroon ng higit error mensahe kaysa sa ako ay may linya ng code. Kaya kung ano ang nangyayari? 

Well, ang pinakamahusay na diskarte na gawin sa anumang oras mo magkasalubong ng isang napakalaki listahan ng mga error tulad na, ay mag-scroll pabalik, hanapin ang utos ikaw na lang tumakbo, na kung saan sa aking kaso ay gumawa ng string. Tumingin sa kung ano gumawa did, at na ang dahilan na long Clang command, hindi sang-ayon doon. 

Ngunit ang pulang ay masama. Green ay sinusubukan upang maging magiliw at helpful. Ngunit ito ay pa rin masama, sa kasong ito. Ngunit kung saan ay ito masama? 

String.c, limang linya, character limang. Kaya ito ay lamang ng sentido convention. Something colon isang bagay ay nangangahulugan linya ng numero at karakter number. Error, ang paggamit ng hindi nagbigay-alam identifier string. Ibig mo bang sabihin standard sa? 

Kaya, sa kasamaang-palad, Clang ay sinusubukan upang maging kapaki-pakinabang. Ngunit ito ay mali, sa kasong ito. Hindi, Clang, ako ay hindi ibig sabihin standard IO. sinadya ko na sa linya ng isa, yes. 

Ngunit limang linya ay ito ang isa dito. At Clang ay hindi maunawaan S-T-R-I-N-G. Ito ay isang hindi nagbigay-alam identifier, isang salita ito lamang ay hindi kailanman nakita bago. At iyon ay dahil C, ang wika kami ay sumusulat code sa ngayon, Wala variable na tinatawag na string. 

Ito ay hindi, sa pamamagitan ng default, suporta isang bagay na tinatawag na isang string. Iyan ay isang CS50 piraso ng magulong pag-uusap, ngunit napaka-maginoo. Ngunit maaari kong ayusin ito tulad ng sumusunod. 

Kung idagdag ko isang linya ng code sa tuktok ng programang ito, isama CS50.h, na kung saan ay isa pang file isang lugar sa loob ng CS50 IDE, sa isang lugar sa hard drive, kaya na magsalita, ng Ubuntu operating system na ako sa pagtakbo, na ay ang file na pagpunta sa magturo sa operating sistema kung ano ang isang string ay, lamang tulad ng standard io.h ay ang file sa operating system na pagpunta sa magturo sa mga ito kung ano printf ay. 

Sa katunayan, kami ay may tapat na paraan isang napaka-katulad na mensahe kung IO ay admitido karaniwang Io.h at tried sa gumamit printf. Kaya ako pagpunta sa sige at lamang kumuha Control L upang i-clear ang aking screen. O maaari mong i-type malinaw at ito ay lamang i-clear ang terminal window. Ngunit maaari mo pa ring mag-scroll pabalik sa panahon. 

At ako pagpunta sa muling palabas ng pelikula Gumawa String. Cross ang mga daliri ko oras na ito, ang Enter. Oh Dios ko, ito ay nagtrabaho. ito ay nagpapakita sa akin ng isang mahabang misteriyoso utos iyon ay kung ano Gumawa nabuo sa pamamagitan Clang, ngunit walang mensahe ng error. Kaya Napagtanto, kahit na maaari kang makakuha ng ganap na bumagsak sa bilang ng mga mensahe ng error, ito lamang ay maaaring maging ito nakakainis cascading effect, kung saan Clang ay hindi maunawaan isang bagay, na nangangahulugan na ito pagkatapos ay hindi maunawaan ang susunod na salita, o sa susunod na linya. At kaya ito lamang chokes sa iyong code. Ngunit ang pag-aayos ay maaaring maging simple. At kaya laging tumutok sa mga pinakaunang linya ng output. At kung hindi mo gusto maunawaan ito, tingnan lamang para sa mga keyword na maaaring pahiwatig, at ang linya ng numero, at ang character, kung saan na pagkakamali ay maaaring maging. 

Ngayon hayaan mo akong magpatuloy at i-type dot slash, string, ipasok. Hm, hindi ito saying hello kahit ano. Bakit? Well, isipin ang, kung saan ito ay tumatakbo? 

Marahil ito ay natigil sa sandaling ito sa isang loop, kung ikaw ay, sa linya anim, dahil Kumuha String pamamagitan ng disenyo, nakasulat sa pamamagitan ng CS50 kawani, Literal na sinadya upang lamang umupo may naghihintay, at naghihintay, at naghihintay para sa isang string. Lahat ang ibig sabihin namin sa pamamagitan ng string ay pantao input. Kaya alam mo kung ano? Hayaan akong magpatuloy. At lamang sa isang kapritso, hayaan mo akong type ang aking pangalan, David, ipasok. Ngayon Mayroon akong isang mas dynamic na programa. Sinabi nito, hello David. 

Kung pumunta ako magpatuloy at patakbuhin ito muli, hayaan mo akong subukan sabihin ang pangalan Zamila, ipasok. At ngayon kami ay may isang dynamic na programa. Hindi ko pa hard-code mundo. Hindi ko pa hard-code pangalan, o David, o Zamila. 

Ngayon ito ay mas tulad ng mga programa alam namin, kung saan kung dalhin ito input, ito ang nagbibigay ng bahagyang naiiba output. Ngayon, ito ay hindi ang pinakamahusay na karanasan ng gumagamit, o UX. tumakbo ako sa programa. 

hindi ko alam kung ano ako dapat na maaaring gawin, maliban kung ako talagang tumingin sa o tandaan ang source code. Kaya sabihin gawin ang gumagamit karanasan ng isang maliit na mas mahusay sa pinakasimpleng ng mga bagay. Hayaan akong bumalik sa ito programa, at lang sabihin printf. 

At hayaan mo akong sige at sabihin ang pangalan, colon, at isang puwang, at pagkatapos ay isang semi-colon. At para lamang sa mga kicks, walang sumasagot na hampas n. At iyon ang sinadya, dahil hindi ko gusto ang prompt upang lumipat sa susunod na linya. 

Gusto kong, sa halip, gawin ito, gumawa ng string mag-recompile ang aking code sa bagong machine code dot slash string. Ah, ito ay lubhang mas prettier. Ngayon ko talaga alam kung ano ang computer nais sa akin na gawin, bigyan ito ng isang pangalan. 

Kaya ako pagpunta sa sige at i-type sa Rob, ipasok, at hello, Rob. Kaya, mapagtanto, ito ay pa rin, sa dulo ng araw, lamang ng siyam na linya programa. Ngunit nagsagawa kami ng mga hakbang na sanggol. 

Wrote namin ang isang linya na kung saan kami Pamilyar, printf, kumusta mundo. Pagkatapos namin undid ng kaunting iyon. At hindi na namin talagang ginagamit get string. At kami tossed na halaga sa isang variable. At pagkatapos namin nagpunta maaga at pinahusay ito ng karagdagang na may isang ikatlong linya. At ito umuulit proseso ng pagsulat ng software ay tunay na key. Sa CS50, at sa buhay sa pangkalahatan, dapat mong pangkalahatan ay hindi umupo, magkaroon ng isang programa sa isip, at subukan pagsulat ang buong sumpain bagay ng sabay-sabay. 

Ito, hindi maaaring hindi, magresulta sa paraan higit pang mga error kaysa sa ating sarili nakita dito. Kahit ako, sa araw na ito, patuloy na gumawa ng iba pang bobo pagkakamali, ay talagang mas mahirap pagkakamali na mas mahirap para malaman. Ngunit ikaw ay gumawa ng mas maraming mga pagkakamali ang mas mga linya ng code isulat mo ang lahat nang sabay-sabay. At kaya ito pagsasanay ng, magsulat ng isang maliit na piraso ng code na ikaw ay komportable sa, sumulat ng libro ito, patakbuhin ito, subukan ito mas pangkalahatang paraan, pagkatapos ay ilipat on-- tulad kaya lang namin itinatago layering at layering noong nakaraang linggo, gusali mula sa isang bagay very simple sa isang bagay mas kumplikado, gawin ang parehong dito. Huwag umupo, at subukan upang magsulat ng isang buong problema. Sa totoo lang gawin ang mga hakbang na sanggol. 

Ngayon, mga string ay hindi lahat na kapaki-pakinabang sa kanilang sarili. Gusto namin talagang, sa isip, tulad ng upang may iba pang dahilan sa aming toolkit. Kaya sabihin aktwal na gawin eksakto na. 

Hayaan akong magpatuloy ngayon at gumawa ng isang bahagyang kakaibang programa. At kami ay tumawag ito int.c, para sa integer. Ako pagpunta sa, katulad, isama CS550.h. Ako pagpunta sa isama ang standard IO. At na ay pagpunta sa maging pretty karaniwan sa mga unang ilang araw ng klase. 

At ako pagpunta sa handa aking sarili sa isang pangunahing pag-andar. At ngayon sa halip ng pagkuha ng isang string, sabihin sige at makakuha ng isang int. Sabihin tumawag ito i, at tumawag ito makakuha int, malapit parens, semi-colon. At ngayon sabihin gawin isang bagay na may ito, printf. 

Sabihin natin na isang bagay tulad ng hello, backslash n, comma i. Kaya ako medyo marami paggaya kung ano ako did sa isang sandali lamang ang nakalipas. Mayroon akong isang placeholder dito. Ako ay may kuwit i dito, dahil gusto kong mag-plug i sa placeholder iyon. 

Kaya sabihin sige at subukan ipon programang ito. Ang file ay tinatawag int.c. Kaya ako pagpunta sa sabihin, gumawa ng int, ipasok. Oh Dios ko, ngunit hindi sang-ayon, right? May isang di-tama. 

May isang sintaktik pagkakamali dito tulad na hindi ang programa maaari naipon sa loob int.c, linya pitong, karakter 27, error format tumutukoy type char lagyan ng star, anumang na ay. Ngunit ang argument uri ay int. 

Kaya dito, masyadong, kami ay hindi pagpunta to-- kahit na ngayon ay isang pulutong ng mga materyal, kami ay pagpunta upang mapuspos sa iyo ng absolutely bawat tampok ng C, at programming mas pangkalahatang paraan, sa loob lamang ng mga unang ilang linggo. Kaya doon ay madalas na pagpunta sa maging magulong pag-uusap na kung saan ikaw ay hindi pamilyar. At, sa katunayan, char star ay isang bagay kami ay pagpunta sa bumalik sa sa isang linggo o oras ng dalawang ni. 

Ngunit sa ngayon, sabihin makita kung maaari naming parse ng mga salita na pamilyar. Formats-- kaya narinig namin format specifier, format code bago. Iyan ay pamilyar. Type-- ngunit ang argument ay may type int. Maghintay ng isang minuto, ako ay isang int. 

Siguro porsiyento s aktwal na ay may ilang mga tinukoy kahulugan. At, sa katunayan, ito ay hindi. Isang integer, kung nais mong printf upang palitan ito, aktwal na ikaw ay may sa gumamit ng isang iba't ibang mga format specifier. At hindi mo nais na malaman ito maliban na lamang kung may sinabi sa iyo, o ikaw ay tapos na ito bago. Ngunit porsiyento i ay kung ano ang maaaring karaniwang ginagamit sa printf para i-plug sa isang integer. Maaari mo ring gamitin porsiyento d para sa isang decimal integer. Subalit ako ay maganda at simpleng dito. Kaya makikita namin pumunta sa na. 

Ngayon ipaalam sa akin sige at gawin uli ang make int, ang Enter. Iyan ay mabuti, walang mga error. Dot iwa int OK, masamang karanasan ng gumagamit, dahil hindi ko nasasabi ang aking sarili anong gagawin. Ngunit iyon lamang ang fine. Ako kaakit-akit sa mabilis. 

At ngayon hayaan mo akong sige at type sa David, OK, Zamila, Rob. OK, sa gayon ito ay isang magandang bagay. Oras na ito, gumagamit ako ng isang function, isang palaisipan piraso, na tinatawag na get int. At ito ay lumiliko out-- at kami makita ito sa ibang pagkakataon sa term-- CS50 kawani ay ipinatupad makakuha ng string sa paraan na ito ay lamang pisikal makakuha ng isang string para sa iyo. 

Ito ay ipinatupad ng get int in tulad ng isang paraan na ito ay lamang makakuha ng isang integer para sa iyo. At kung ikaw, ang tao, huwag makipagtulungan, ito ay literal lamang ng pagpunta sa sabihin subukan muli, muling subukan, subukan muli, literal upo doon looping, hanggang utang na loob sa iyo ng ilang mga kahima-himala number, tulad ng 50, at hello 50. 

O kung nagpapatakbo namin ito muli at i-type sa 42, hello 42. At kaya ang get int function na sa loob ng na piraso puzzle ay sapat na logic, sapat-iisip, upang malaman kung, kung ano ang isang salita? At kung ano ang isang numero? Tanging pagtanggap, sa huli, mga numero. 

Kaya ito ay lumiliko out na ito ay hindi lahat na nagpapahayag. so far. Kaya, yay, huling oras namin nagpunta medyo mabilis sa pagpapatupad ng mga laro, at animation, at artistikong gawa sa scratch. At dito, kami ay pagiging nilalaman may hello world, and hello 50. 

Ito ay hindi lahat kagila iyon. At, sa katunayan, ang mga unang ilang halimbawa ay aabot ng ilang oras sa ramp up sa kaguluhan. Ngunit kami ay may kaya marami pang iba kontrolin ngayon, sa katunayan. At kami ay pagpunta sa tunay mabilis na simulan layering sa itaas ng mga pangunahing primitives. 

Ngunit una, sabihin maunawaan kung ano ang mga limitasyon ay. Sa katunayan, isa sa mga bagay Scratch ay hindi madaling ipaalam sa amin gawin ay talagang tumingin ilalim ng hood, at maunawaan kung ano ang isang computer ay, kung ano ang maaari itong gawin, at kung ano ang kanyang mga limitasyon ay. At, sa katunayan, na ang kakulangan ng unawa, potensyal na, pang-matagalang ay maaaring humantong sa aming sariling mistakes-- pagsulat bugs, pagsulat hindi secure na software na ay makakakuha ng hacked sa ilang paraan. 

Kaya ipaalam sa tumagal ng ilang mga hakbang patungo sa unawa ito ng kaunti mas mahusay sa pamamagitan ng paraan ng, sabihin nating, ang mga sumusunod na halimbawa. Ako pagpunta sa sige at ipatupad tunay na mabilis isang programa na tinatawag Adder. Like, sabihin magdagdag ng ilang mga numero ng magkasama. At ako pagpunta sa code ilang mga sulok dito, at kopyahin lamang at i-paste kung saan ako ay bago, lamang upang maaari naming makakuha ng pagpunta nang mas maaga. Kaya ngayon Mayroon akong ang pangunahing beginnings ng isang programa na tinatawag Adder. 

At sabihin sige at gawin ito. Ako pagpunta sa sige at sabihin nating, intx makakakuha makakuha int. At alam mo kung ano? Natin gumawa ng isang mas mahusay na karanasan ng gumagamit Hayaan. 

Kaya sabihin lamang sabihin x ay, at mabisa prompt ng gumagamit upang bigyan kami ng x. At pagkatapos ay hayaan mo akong magpatuloy at sabihin, printf kung paano ang tungkol y ay, oras na ito umaasa dalawang mga halaga mula sa user. At pagkatapos ay sabihin pumunta lamang magpatuloy at sabihin nating, printf, ang kabuuan ng x at y ay. At ngayon hindi ko nais na gawin porsiyento s. Gusto kong gawin porsiyento i, backslash n, at pagkatapos ay plug sa sum na halaga. 

Kaya kung paano ang maaari kong pumunta tungkol sa paggawa nito? Alam mo ba? alam ko kung paano gamitin ang mga variable. Hayaan akong lamang magpahayag ng isang bagong isa, int z. 

At ako pagpunta sa tumagal ng isang hula dito. Kung may mga pantay na mga palatandaan sa wika, marahil lamang ang maaari kong gawin x plus y, kaya hangga't tapusin ko ang aking naisip na may isang semi-colon? Ngayon ay maaari kong bumalik pababa dito, plug sa z, matapos-iisip na ito na may isang semi-colon. At tingnan natin ngayon, kung ang mga pagkakasunud-sunod ng lines-- x ay ang makakuha ng int. Y ay ang makakuha ng int. 

Idagdag x at y, mag-imbak ang halaga sa z-- kaya, muli, tandaan ang katumbas sign ay hindi matuwid. Walang assignment mula sa karapatan sa kaliwa. At sabihin i-print out na ang kabuuan ng x at y ay hindi literal z, ngunit kung ano ang nasa loob ng z. Kaya sabihin gawin Adder - nice, walang pagkakamali ngayon. Dot iwa Adder, ipasok, x ay pagpunta sa maging 1. 

Y ay magiging 2. At ang kabuuan ng x at y ay 3. Kaya na ang lahat ng fine at mabuti. 

Kaya Gusto mong isipin na ang matematika ay dapat na gumana sa isang programa tulad nito. Pero alam mo kung ano? Ito ba ay variable, linya 12, kahit na kinakailangan? Hindi mo na kailangan upang makakuha ng sa ugali na lamang sa pag-iimbak ng mga bagay sa mga variable dahil lang sa maaari mong. At, sa katunayan, ito ay sa pangkalahatan itinuturing masamang disenyo kung ikaw ay ang paglikha ng isang variable, na tinatawag na z sa kasong ito, sa pag-iimbak ng isang bagay sa loob nito, at pagkatapos ay kaagad paggamit nito, ngunit hindi kailanman muli. Bakit magbigay ng isang bagay ng isang pangalan tulad z kung ikaw ay literal pagpunta sa paggamit na bagay nang isang beses lamang, at iba pa proximal sa kung saan mo nilikha ito sa simula pa lamang, kaya malapit sa mga tuntunin ng mga linya ng code? Kaya alam mo kung ano? Ito ay lumiliko out na ang C ay medyo may kakayahang umangkop. Kung ako talagang nais na plug-in mga halaga dito, Hindi ko kailangan na idedeklara ng isang bagong variable. hindi ko na lang plug-in x plus y, dahil C nauunawaan arithmetic, at matematika operator. 

Kaya maaari ko lang sabihin, gawin ito sa matematika, x plus y, kahit anong mga halaga ay, plug ang mga nagresultang integer sa na string. Kaya ito ay maaaring maging, bagaman lamang ng isang linya ng mas maikli, isang mas mahusay na disenyo, ang isang mas mahusay na programa, dahil mayroong mas code, samakatuwid mas mababa para sa akin upang maunawaan. At ito ay din lamang cleaner, insofar bilang hindi kami pagpapasok ng bagong mga salita, bagong mga simbolo, tulad ng z, kahit na hindi sila tunay maglingkod karami ng isang layunin. 

Sa kasamaang palad, matematika ay hindi lahat na maaasahang minsan. Sabihin sige at gawin ito. Ako pagpunta sa sige ngayon at gawin ang sumusunod. 

gawin ni printf, porsiyento i, plus percent Hayaan i, ay magiging porsiyento i, backslash n. At ako pagpunta sa gawin this-- Xyx plus y. Kaya Lamang ako ng pagpunta sa pagsulat na muli ito bahagyang naiiba dito. Hayaan akong lamang gawin ang isang mabilis katinuan check. Muli, sabihin hindi makakuha ng maagang ng ating sarili. Gumawa adder, dot slash adder. x ay 1, y ay 2, 1 plus 2 ay 3. Kaya na mabuti. Ngunit sabihin makapagpalubha ito ngayon ng kaunti, at lumikha ng isang bagong file. 

Ako pagpunta sa tumawag ito ng isa, sabihin, ints, plural para integers. Hayaan ninyo akong magsimula kung saan ako ay isang sandali ang nakalipas. Ngunit ngayon sabihin gawin ng ilang iba pang mga linya. Hayaan akong magpatuloy at gawin ang mga sumusunod, printf, porsiyento i, minus porsiyento i, ay porsiyento i, comma x, comma yx minus y. Kaya ako ng paggawa bahagyang iba't ibang math doon. Tayo'y gawin ang isa pa Hayaan. Kaya porsiyento i beses porsiyento i ay porsiyento i, backslash n. ni plug-in x, at y, at x beses y Hayaan. Gagamitin namin ang asterisk sa ang iyong computer para sa mga oras. 

Hindi mo gamitin x. x ay isang pangalan ng variable dito. Gamitin mo ang star para sa pagpaparami. Natin gawin isa pang Hayaan. Printf percent ko, na hinati sa pamamagitan ng porsiyento i, ay porsiyento i, backslash n. xy hinahati sa pamamagitan y-- kaya mong gamitin ang forward slash sa C gawin division. At sabihin gawin isa isa. Naiwan ng porsiyento i, na hinati sa pamamagitan ng porsiyento i, ay percent i. xy-- at ngayon naiwan ay kung ano ang natira. Kapag sinubukan mong paghahati ng isang denominador sa isang tagabilang, kung magkano na naiwan sa paglipas na hindi mo maaaring hatiin out? 

Kaya doon ay hindi tunay, kinakailangan, isang simbolo namin na nagamit ko sa grade school para sa. Ngunit doon sa C. Maaari kang sabihin x modulo y, kung saan ito porsyento sign in context-- ito confusingly kapag ikaw ay sa loob ng double quotes, sa loob ng printf, porsiyento ay ginagamit bilang ang specifier format. 

Kapag gumamit ka ng porsiyento sa labas ng na sa isang mathematical expression, ito ay ang modulo operator para modular arithmetic-- para sa aming mga layunin dito, lamang ay nangangahulugan na, kung ano ang naiwan ng x hinahati sa pamamagitan ng y? Kaya x hinahati sa pamamagitan ng y ay x slash y. Ano ang ang mga natitira sa x hinahati sa pamamagitan ng y? Walang x mod y, bilang programmer nais sabihin. 

Kaya kung ako ginawa walang pagkakamali dito, hayaan mo akong sige at gumawa ng ints, plural, maganda, at tuldok slash ints. At sabihin sige at gawin, sabihin nating, 1, 10. O sige, 1 plus 10 ay 11, check. 1 minus 10 ay negatibo 9, suriin. 

1 beses 10 ay 10, check. 1 hinati sa 10 is-- OK, kami ay laktawan ang isa. Naiwan ng 1 hinati sa 10 ay 1. Tama iyan. Subalit mayroong isang bug sa dito. 

Kaya ang isa ko bang ilagay ang aking iabot, hindi tama. Ibig kong sabihin, ito ay malapit sa 0. 1 hinati sa 10, alam mo, kung kami ay pagputol ilang mga sulok, sigurado, ito ay zero. Ngunit ito ay dapat talagang maging 1/10, 0.1, o 0.10, .1000, o iba pa. 

hindi talaga ito dapat zero. Well, ito ay lumiliko out na ang computer ay ginagawa literal kung ano ang sinabi namin ito upang gawin. Kami ay gumagawa ng math tulad ng x hinahati sa pamamagitan ng y. At parehong x at y, per ang mga linya ng code ng mas maaga, ay integers. 

Bukod dito, on line 15, kami ay na nagsasabi sa printf, hey, printf plug-in isang integer, mga plug-in sa isang integer, plug-in na ng integer-- partikular x, at pagkatapos ay y, at pagkatapos ay x hinati sa y. x at y ay ints. Humihingi kami ng magandang doon. 

Ngunit kung ano ang x hinahati sa pamamagitan ng x? x hinati sa dapat y maging, mathematically, 1/10, o 0.1, kung saan ay isang tunay na numero, isang tunay na numero pagkakaroon, potensyal na, isang decimal point. Ito ay hindi isang integer. 

Ngunit ano ay ang pinakamalapit na integer sa 1/10, o 0.1? Yeah, ito uri ng ay zero. 0.1 ay tulad nito magkano. At 1 ay ganito karami. Kaya 1/10 ay mas malapit sa 0 kaysa ito ay sa isa. 

At kaya kung ano C ginagawa para us-- uri ng dahil sinabi namin ito to-- ay truncating na integer. Ito ay pagkuha ng halaga, na muli ay dapat na maging isang bagay tulad ng 0.1000, 0 at iba pa. At ito ay ang lahat ng bagay truncating pagkatapos ng decimal point ano pa't ang lahat ng mga ito bagay-bagay, dahil ito ay hindi magkasya sa ang paniwala ng isang integer, na kung saan ay lamang ng isang numero tulad ng mga negatibong 1, 0, 1, pataas at pababa, ito throws ang layo ng lahat ng bagay pagkatapos ng decimal point dahil ikaw ay hindi maaaring magkasya sa isang decimal point sa isang integer sa pamamagitan ng kahulugan. 

Kaya ang sagot dito ay zero. Kaya paano namin ayusin ito? Kailangan namin ng isa pang solusyon ng magkakasama. At maaari naming gawin ito, tulad ng sumusunod. 

Hayaan akong magpatuloy at lumikha ng isang bagong file, ang isang ito na tinatawag floats.c. At i-save ito dito sa parehong directory, float.c. At ipaalam sa akin sige at kopyahin ang ilan sa na code mula sa mas maaga. 

Ngunit sa halip ng pagkuha ng isang int, sabihin gawin ito. Bigyan mo ako ng isang lumulutang na halaga ng point tinatawag na x. kung saan ang isang lumulutang na tuldok halaga ay lamang literal isang bagay na may isang lumulutang point. Maaari itong ilipat sa kaliwa, sa kanan. Ito ay isang tunay na numero. 

At huwag mo akong tawagan makakuha int, ngunit makakuha ng float, na kung saan din ay kabilang sa mga menu ng mga pagpipilian sa C250 library. baguhin ang y sa isang float Hayaan. Kaya ito ay nagiging makakuha float. 

At ngayon, hindi namin nais mag-plug ng ints. Ito ay lumiliko out mayroon kaming upang gamitin porsiyento f para float, porsiyento f para float, at ngayon i-save ito. At ngayon, mga daliri crossed, gumawa kamay, nice, dot slash kamay. x ay pagpunta sa maging isa 1. y Ay pagpunta sa maging 10 ulit. 

At, nice, OK aking karagdagan ay tama. Ako ay umaasa para sa karagdagang, ngunit Nakalimutan ko ang upang isulat ito. Kaya sabihin pumunta at ayusin ito lohikal error. 

Sabihin sige at grab ang mga sumusunod. Susubukan naming lamang gawin ng isang maliit na kopya at i-paste. At ako pagpunta sa sabihin minus. 

At ako pagpunta sa sabihin ng oras. At ako pagpunta sa sabihin hinati. At hindi ako pagpunta sa gawin modulo, na kung saan ay hindi bilang dyermeyn dito, hinati sa f, at oras plus-- OK, sabihin gawin ito muli. 

Gumawa kamay, tuldok slash sa kamay, at 1, 10, at- nice, no, OK. Kaya ako ay isang idiot. Kaya ito ay napaka-pangkaraniwan sa computer science upang gumawa ng tangang pagkakamali tulad nito. 

Para paturo layunin, kung ano ako talagang nais na gawin ay baguhin ang science dito sa plus, sa minus, upang beses, at upang maghiwalay, habang ikaw sana napansin sa panahon ng ehersisyo na ito. Kaya ngayon sabihin muling sumulat ng libro na ito programa, gawin dot slash kamay. 

At para sa pangatlong beses, sabihin makita kung ito ay nakakatugon sa aking mga inaasahan. 1, 10, ipasok, yes, OK, 1.000, hinati sa 10.000, ay 0.100000. At ito ay lumiliko out maaari naming kontrolin kung gaano karaming numerong ito ay pagkatapos ng mga decimal point. Kami ay talagang ay. Susubukan naming bumalik sa na. 

Ngunit ngayon, sa katunayan, ang matematika ay tama. Kaya, muli, ano ang takeaway dito? Ito ay lumiliko out na sa C, may mga hindi lamang lamang strings-- at, sa katunayan, may mga hindi talaga, dahil kami magdagdag ng mga sa CS50 library. Ngunit may mga hindi lamang ints. 

Mayroon ding mga kamay. At ito ay lumiliko out ng grupo ng mga iba pang data uri masyadong, na gagamitin namin bago ang haba. Lumiliko out kung nais mo ang isang solong character, hindi isang string ng mga character, maaari mong gamitin lamang ng isang pansamantalang trabaho. 

Lumiliko out na kung nais mo ang isang bool, isang Boolean halaga, tama o mali lamang, salamat sa CS50 library, na namin idinagdag sa C ang uri bool data pati na rin. Kundi pati na rin ito ay ipakita sa maraming iba pang mga wika pati na rin. At ito ay lumiliko out na kung minsan ka kailangan mas malaking mga numero at pagkatapos ay sa pamamagitan ng default may ints at kamay. 

At, sa katunayan, ang isang double ay isang numero na gumagamit ng hindi 32 bits, ngunit 64 bits. At isang mahabang mahabang ay isang numero na ay gumagamit ng hindi 32, bits ngunit 64 bits, ayon sa pagkakabanggit, para sa mga lumulutang na tuldok halaga at integers, ayon sa pagkakabanggit. Kaya sabihin aktwal na ngayon makita ito sa aksyon. 

Ako pagpunta sa sige dito at gumawa ng isa pang programa. Narito, ako pagpunta sa sige at huwag isama CS50.h. At hayaan mo akong pumunta, ng pamantayang io.h. 

At mapapansin mo ang isang bagay funky ang nangyayari dito. Hindi ito kulayan coding bagay sa sa parehong paraan tulad ng ginawa dati. At ito ay lumiliko out, iyon ay dahil ako hindi binigyan ng bagay na ang isang pangalan ng file. 

Ako pagpunta sa tumawag ang isang ito sizeof.c, at pindutin ang I-save. At pansinin kung ano ang mangyayari sa aking pinaka puting code laban na itim backdrop. Ngayon, hindi bababa sa may ilang mga lilang sa doon. At ito ay syntax-highlight. 

Ito ay dahil, medyo simple, na ako sinabi sa mga IDE kung anong uri ng file ito ay sa pamamagitan ng pagbibigay ito ng isang pangalan, at partikular na ang isang file extension. Ngayon, sabihin sige at gawin ito. Ako pagpunta sa sige at napaka lamang i-print ang following-- bool ay percent LU. 

Darating kami pabalik sa na sa loob lamang ng ilang sandali. At pagkatapos ay ako pagpunta sa print laki ng bool. At ngayon, lamang upang i-save ang ang aking sarili sa ilang oras, ako pagpunta sa gawin ang isang buong grupo ng mga sabay-sabay. At, partikular, ako pagpunta sa baguhin ito sa isang pansamantalang trabaho at pansamantalang trabaho. Isa na ito, ako pagpunta upang baguhin sa isang double at isang double. 

Isa na ito, ako pagpunta upang baguhin sa isang float at isang float. Ang isang ito, ako pagpunta sa baguhin sa isang int at isang int. At ang isang ito, pupuntahan ko upang baguhin sa isang mahabang mahabang. At pa rin ito ay ang pagkuha isang mahabang panahon, matagal na matagal na. 

At pagkatapos, sa wakas, ako nagbigay ang aking sarili ng isa masyadong maraming, string. Ito ay lumiliko out na sa C, may ang mga espesyal na operator na tinatawag na laki ng iyan ay literal pagpunta sa, kapag tumakbo, sabihin sa amin ang laki ng bawat isa sa mga variable. At ito ay isang paraan, ngayon, maaari naming ikonekta likod sa discussion noong nakaraang linggo ng data at representasyon. 

Hayaan akong sige at mag-compile laki ng dot slash laki ng. At sabihin makita. Ito ay lumiliko out na sa C, partikular sa CS50 IDE, partikular sa operating system Ubuntu, kung saan ay isang 64-bit operating sistema sa kasong ito, isang bool ay pagpunta sa gamitin ang isa byte ng espasyo. Iyan ay kung paano ang laki ay sinusukat, hindi sa bits, ngunit sa bytes. At isipin na ang isa byte ay walong bits. Kaya ang isang bool, kahit na kayo technically lamang ang kailangan ng isang 0 o 1, ito ay isang maliit na mapag-aksaya kung paano namin na ipatupad ito. talagang Ito ay pagpunta sa gumamit ng isang buong byte-- kaya lahat ng mga zero, ikaw ay marahil lahat sa buhay, o ng isang bagay tulad na, o isa lamang 1 sa walong bits. 

Ang isang pansamantalang trabaho, samantala, na ginagamit para sa isang character tulad ng isang Ascii karakter bawat noong nakaraang linggo, ay pagpunta sa maging isang character. At na synchs up sa aming paniwala ng ito sa pagiging hindi hihigit sa 256 bits-- sa halip, synchs up sa mga ito sa pagiging walang mas mahaba kaysa sa 8 bits, na kung saan ay nagbibigay sa amin ng maraming mga bilang 256 mga halaga. Ang isang double ay pagpunta sa maging 8 bytes o 64 bits. 

A float ay 4. Isang int ay 4. Ang isang mahaba, mahabang ay 8. At isang string ay 8. Ngunit huwag mag-alala tungkol sa na. Kami ay pagpunta sa alisan ng balat pabalik na layer. Ito ay lumiliko out, mga string Maaari mas mahaba kaysa sa 8 bytes. 

At, sa katunayan, na naisulat namin string na, kumusta mundo, mas mahaba kaysa sa 8 bytes. Ngunit kami ay bumalik sa na sa loob lamang ng ilang sandali. Ngunit ang tumagal ang layo dito ay ang mga sumusunod. 

Anumang computer lamang ay may isang may hangganan halaga ng memorya at espasyo. Maaari ka lamang mag-imbak sa gayon maraming file sa iyong Mac o PC. Maaari ka lamang mag-imbak ng maraming mga programa sa RAM tumatakbo nang sabay-sabay, kinakailangan, kahit na sa virtual memory, dahil mayroon kang isang tiyak na halaga ng RAM. 

At lamang upang ang larawang kung hindi kailanman na iyong binuksan up ng isang laptop o iniutos dagdag memory para sa isang computer, maaari mo maaaring hindi malaman na loob ng iyong computer ay isang bagay na mukhang isang maliit na tulad nito. Kaya ito ay lamang ng isang pangkaraniwang kumpanya pinangalanan Crucial na gumagawa RAM para sa mga computer. At RAM ay kung saan ang mga programa mabuhay habang sila ay tumatakbo. 

Kaya sa bawat Mac o PC, kapag double mo i-click ang isang programa, at ito ay bubukas up, at ito ay bubukas ang ilang dokumento na Word o isang bagay tulad na, ito nag-iimbak ito pansamantala sa RAM, dahil RAM ay mas mabilis kaysa sa iyong hard disk, o iyong solid estado disk. Kaya ito ay lamang kung saan ang mga programa pumunta upang mabuhay kapag sila ay tumatakbo, o kapag ang mga file ay ginagamit. 

Kaya ikaw ay may mga bagay na tumingin tulad nito sa loob ng iyong laptop, o bahagyang mas malaking bagay loob ng iyong desktop. Ngunit ang susi ay mayroon ka lamang ng may hangganan bilang ng mga bagay na ito. At mayroon lamang isang tiyak na halaga ng hardware upo sa ito desk karapatan dito. 

Kaya, tiyak, maaari naming hindi nag-iimbak walang katapusan ang haba numero. At, pa, kung sa tingin mo bumalik sa grade school, kung gaano karaming mga digit Maaari ikaw ay may sa kanan ng isang decimal point? Para sa mga bagay, kung gaano karaming mga digit Maaari ikaw ay may sa kaliwa ng isang decimal point? Talagang, walang hanggan maraming. 

Ngayon, tayong mga tao maaaring lamang alam kung paano ipahayag na milyon, at billion, trillion, at quadrillion, at quintillion. At ako patulak ang mga limitasyon ng aking understanding-- o my-- Naiintindihan ko numero, ngunit ang aking pagbigkas ng mga numero. Ngunit maaari silang makakuha ng walang hanggan malaki sa walang hanggan maraming mga digit sa kaliwa o sa kanan ng decimal point. 

Ngunit computer lamang magkaroon ng isang takda na halaga ng memory, isang may hangganan bilang ng mga transistors, isang may hangganan bilang ng ilaw bombilya sa loob. Kaya kung ano ang mangyayari kapag naubusan ka ng space? Sa ibang salita, kung ikaw sa tingin bumalik sa nakaraang linggo kapag usapan natin ang tungkol sa mga numero kanilang mga sarili na kinakatawan sa binary, ipagpalagay na namin nakuha ito 8-bit halaga dito. 

At kami ay may pitong 1 at isa 0. At ipagpalagay na gusto naming magdagdag ng 1 sa halaga na ito. Ito ay isang talagang malaking bilang ngayon. 

Ito ay 254, kung matandaan ko ang matematika mula noong nakaraang linggo karapatan. Ngunit paano kung baguhin ko na rightmost 0 sa isang 1? Ang kabuoan ng bilang, ng Siyempre, nagiging eight 1 ni. Kaya kami ay pa rin mabuti. 

At na marahil ay kumakatawan sa 255, bagaman depende sa konteksto maaaring ito ang tunay na kumakatawan isang negatibong numero. Ngunit higit pa sa na ibang oras. Ito nararamdaman tulad ng ito ay tungkol sa bilang mataas na bilang maaari kong mabibilang. 

Ngayon, ito ay lamang ng 8 bits. At ang aking Mac, tiyak, ay may paraan higit sa 8 bits ng memorya. Ngunit ito ay hindi magkaroon may hangganan. Kaya ang parehong argument ay sumasaklaw, kahit na kami may higit pa sa mga iyan sa screen. 

Ngunit ano ang mangyayari kung ikaw ay pag-iimbak ang numerong ito, 255, at nais mong bilangin 1 bit mas mataas? Gusto mong pumunta mula sa 255 sa 256. Ang problema, siyempre, ay na kung ikaw magbilangan sa zero tulad noong nakaraang linggo, hindi ka maaaring bilangin bilang mataas bilang 256, pabayaan mag-isa 257, pabayaan mag-isa 258, m dahil kung ano ang mangyayari kapag nagdagdag ka ng isang 1? Kung gagawin mo ang lumang grade school diskarte, kang maglagay ng 1 dito, at pagkatapos ay 1 plus 1 ay 2, ngunit iyan ay talagang isang zero, dalhin mo ang 1, magtataglay ng mga 1, dalhin ang 1. Ang lahat ng mga bagay na ito, mga 1, pumunta sa zero. At hangin mo up, yes, bilang isang tao nakaumang out, ang isang 1 sa kaliwang bahagi. Ngunit lahat ng iyong makakaya aktwal na makita at magkasya sa memory ay lamang ng walong 0, na ang ibig sabihin ay sa ilang mga punto kung ikaw, isang computer, tried pagbibilang sapat na mataas up, ikaw ay pagpunta sa wrapper sa paligid, ito ay tila, sa zero, o marahil kahit na mga negatibong numero, na kung saan ay kahit na mas mababa kaysa sa zero. 

At maaari naming uri ng makita ito. Hayaan akong sige at isulat isang tunay na mabilis na programa dito. Hayaan akong sige at isulat isang programa na tinatawag overflow. Isama CS50.h, isama karaniwang IO.h-- oh, Ko talagang nasagot ang aking syntax highlight. Kaya sabihin i-save ito bilang overflow.c. 

At ngayon int main void-- at di-nagtagal, kami bumalik sa na nagpapaliwanag kung bakit panatilihin namin ang pagsusulat int pangunahing walang bisa. Ngunit sa ngayon, sabihin lamang gawin ito, ang pagkuha ng ito para sa ipinagkaloob. Sabihin bigyan ang aking sarili ng isang int, at initialize ito sa 0. 

ni pagkatapos ay gawin para sa int Hayaan makakuha i zero-- actually, sabihin gawin ang isang walang hanggan loop at makita kung ano ang mangyayari. Habang totoo, pagkatapos ay sabihin i-print out n ay porsiyento i, backslash n, mga plug-in n. Ngunit, ngayon, sabihin gawin n nakakakuha n plus 1. 

Kaya sa ibang salita, sa bawat pag-ulit ng walang-katapusang loop, ipaalam sa tumagal ng halaga ni n, at magdagdag ng 1 sa mga ito, at pagkatapos ay mag-imbak ang mga resulta pabalik sa n sa kaliwa. At, sa katunayan, nasaksihan namin syntax bahagyang tulad nito, sa madaling sabi. Ang isang cool na bilis ng kamay ay sa halip ng pagsulat ang lahat ng ito out, maaari mong talagang sabihin isang n plus ay katumbas ng 1. 

O kung ikaw ay talagang nais na maging fancy, maaari mong sabihin n plus plus semi-colon. Ngunit ang mga huling dalawang ay lamang kung ano ang gusto naming tumawag sintaktik asukal para sa unang bagay. 

Ang unang bagay ay mas malinaw, lubos pinong, lahat-lahat tama. Ngunit ito ay mas karaniwan, kukunin ko na sabihin. Kaya makikita namin gawin ito para sa sandali lamang. 

Sabihin ngayon gumawa overflow, na tunog halip nagbabala, dot slash overflow. Tayo'y makita, n Nagiging medyo malaki Hayaan. Nguni't ni mag-isip, kung paano malaki maaari n makakuha ng? 

n ay isang int. Nakita namin ang isang sandali ang nakalipas sa laki ng halimbawa na isang int ay apat bytes. Alam namin mula sa nakaraang linggo, apat na bytes ay 32 bits, dahil 8 beses 4, na ang 32. Iyon ay magiging 4 na bilyon. 

At kami ng hanggang sa 800,000. Ito ay pagpunta sa tumagal magpakailanman upang mabibilang bilang mataas na bilang ko marahil maaari. Kaya ako pagpunta sa sige, bilang maaari mong bago ang haba, at pindutin Control C-- lantaran, Control C, ang isang pulutong, kung saan Control C pangkalahatan paraan kanselahin. Sa kasamaang palad, dahil ito ay tumatakbo sa ulap, kung minsan ang ulap ay pagsigam out kaya magkano bagay-bagay, so much output, ito ay pagpunta sa tumagal ng ilang sandali para sa aking input upang makakuha ng sa cloud. Kaya kahit na ako hit Control C ng ilang segundo ang nakalipas, ito ay tiyak ang side epekto ng isang walang-katapusang loop. 

At kaya sa ganitong mga kaso, hindi namin pagpunta sa umalis na maging. At kami ay pagpunta sa magdagdag ng isa pang terminal window sa paglipas dito may plus, na siyempre ay hindi tulad na, dahil ito ay pa rin pag-iisip. At sabihin sige at maging isang maliit na mas makatwirang. 

Ako pagpunta sa sige at gawin ito lamang finitely maraming beses. ni gumamit ng isang para sa loop Hayaan, na aking alluded sa mas maaga. Gawin natin ito. Bigyan mo ako ng isa pang variable int i nakakakuha 0. i ay mas mababa sa, sabihin nating, 64 i ++. At ngayon hayaan mo akong magpatuloy at i-print out n ay porsiyento i, kuwit n. At pagkatapos n-- ito ay pa rin pagpunta sa tumagal magpakailanman. Gawin natin ito. 

n ay makakakuha n beses 2. O maaari naming maging fancy at gawin ulit ay katumbas ng 2. Ngunit sabihin lamang sabihin n ay katumbas ng kanyang sarili, beses 2. Sa ibang salita, sa ganitong bagong bersyon ng programa, Hindi ko nais na maghintay magpakailanman mula sa tulad ng 800,000 sa 4 billion. Sabihin lang makakuha ng ito sa paglipas ng sa. 

Natin ang aktwal na double n sa bawat oras. Kung saan, pagpapabalik, pagdodoble ang kabaligtaran ng pagkakaroon, siyempre. At yamang noong nakaraang linggo kami ay may isang bagay muli, at muli, at muli, sobrang bilis, pagdodoble ay tiyak mapahubad kami mula 1 hanggang ang pinakamalaking posibleng halaga na maaari naming bilangin sa na may isang int. 

Kaya sabihin gawin eksakto na ito. At kami ay bumalik sa ito bago ang haba. Ngunit ito, muli, ay tulad ng ang umuulit na block sa scratch. At gagamitin mo ito bago ang haba. 

Ito lamang ay nangangahulugan count mula sa zero hanggang sa, ngunit hindi pantay-pantay, sa 64. At sa bawat pag-ulit ng mga ito loop, lamang panatilihin ang incrementing i. Kaya i ++ - at ito pangkalahatang tayuan on line 7 ay lamang ng isang super-karaniwang paraan ng paulit-ulit ng ilang mga linya ng code, ang ilang bilang ng beses. Aling linya ng code? Ang mga kulot tirante, habang ikaw maaaring may gleaned mula ngayon, ay nangangahulugan, gawin ang mga sumusunod. 

Ito ay sa tulad ng simula, kapag ito ay ang dilaw na bloke at iba pang mga kulay na uri ng yakapin o yakapin iba pang mga bloke. Iyan ay kung ano ang mga kulot braces ang ginagawa dito. Kaya kung ako got ang aking syntax right-- mo maaaring makita ang mga karot simbolo sa C paraan na kung gaano karaming beses ako ay sinusubukan upang malutas ang problemang ito. Kaya sabihin mapupuksa ng walang inaasahan sama-sama, at isara na window. At gagamitin namin ang bagong isa. Gumawa overflow, dot slash overflow, ang Enter, lahat ng karapatan, mukha itong masama sa unang. Ngunit sabihin mag-scroll pabalik sa panahon, sapagka't yao'y ginawa ko ito 64 ulit. 

At mapansin sa unang pagkakataon, n ay 1. Ikalawa, n ay 2, pagkatapos ay 4, pagkatapos ay 8, at pagkatapos 16. At tila na sa lalong madaling nakukuha ko na halos 1 bilyon, kung ako double itong muli, na ay dapat magbigay sa akin 2 bilyon. Ngunit ito ay lumiliko out, ito ay right sa tulis. 

At kaya ito ang tunay na overflows isang int mula sa 1 bilyong sa humigit-kumulang negatibong 2 billion, sapagka't isang integer, hindi katulad ng mga numero namin ay sa pag-aakala noong nakaraang linggo, ay maaaring maging parehong positibo at negatibong sa katotohanan at sa isang computer. At kaya hindi bababa sa isa sa mga bits ay epektibong ninakaw. Kaya kami ay talagang lamang magkaroon 31 bits, o 2 bilyong mga posibleng halaga. 

Ngunit sa ngayon, ang takeaway ay lubos lang, kahit anong mga numerong ito ay at kahit na ano ang matematika ay, may masamang mangyayari sa huli, dahil sa huli ikaw ay sinusubukan upang ibahin ang ayos ang mga bits ng isa masyadong maraming beses. At sa iyo na epektibong pumunta mula sa lahat 1 na siguro lahat ng 0, o marahil lamang sa ilang ibang mga pattern na ito malinaw na, depende sa konteksto, ay maaaring interpreted bilang isang negatibong numero. At kaya ito ay tila ang pinakamataas na ko maaaring bilangin sa ito partikular na programa ay lamang ng humigit-kumulang 1 bilyon. Subalit mayroong isang bahagyang solusyon dito. Alam mo ba? 

Hayaan akong baguhin mula sa isang int sa isang mahaba haba. At hayaan mo akong magpatuloy dito at say-- ako pagpunta sa magkaroon ng upang baguhin ito sa isang hindi linagdaan mahaba. O kaya naman, sabihin makita, hindi ko matandaan ang aking sarili. 

Sabihin sige at gumawa overflow. Hindi, na hindi ito, LLD, salamat. Kaya minsan Clang ay maaaring helpful. Hindi ko matandaan kung ano ang format specifier ay para sa isang mahabang mahabang. 

Ngunit, sa katunayan, Clang sinabi sa akin. Green ay ang ilang mga uri ng mabuti, pa rin ay nangangahulugan na ikaw ay nagkamali. Ito ay guessing na sinadya ko LLD. 

Kaya hayaan mo akong dalhin ito sa payo, sa isang mahabang long decimal na numero, i-save na. At hayaan mo akong muling patakbuhin ito, tuldok slash overflow, ang Enter. At ngayon kung ano ang cool ay na ito. 

Kung mag-scroll ko pabalik sa panahon, kami pa rin simulan pagbibilang sa parehong place-- 1, 2, 4, 8, 16. Notice, makuha namin ang lahat ng mga paraan ng hanggang sa 1 bilyon. Ngunit pagkatapos naming ligtas na makakuha ng sa 2 bilyong. 

Pagkatapos namin makakuha ng sa 4 billion, pagkatapos ay 8 bilyon, 17 billion. At pumunta kami mas mataas, at mas mataas, at mas mataas. Sa kalaunan, ito, masyadong, break. 

Sa kalaunan, may isang mahabang mahaba, kung saan ay ang 64-bit na halaga, hindi isang 32-bit na halaga, kung bilangin mo masyadong mataas, balutin mo sa paligid 0. At sa kasong ito, mangyari namin upang end up na may isang negatibong numero. 

Kaya ito ay isang problema. At ito ay lumiliko out na ito problema ay hindi ang lahat ng arcane iyon. Kahit na hindi ko na sadyang sapilitan ito sa mga pagkakamali, ito ay lumiliko out namin makita ito uri ng lahat sa paligid sa amin, o hindi bababa sa ilan sa amin gawin. 

Kaya sa Lego Star Wars, kung kailanman na-play ang laro, ito ay lumiliko out maaari mong pumunta sa paligid hatiin ang mga bagay sa LEGO mundo, at pagkolekta ng mga barya, mahalagang. At kung sakaling mo na-play ito laro paraan ng masyadong maraming oras, bilang na ito walang pangalan indibidwal dito ay, ang kabuuang bilang ng mga barya na maaari mong mangolekta ay, ito ay tila, 4 bilyon. 

Ngayon, sa mga ito ang tunay na bilugan. Kaya LEGO ay sinusubukan upang panatilihin ang mga bagay user friendly. Hindi nila gawin ito eksakto 2 hanggang ang 32 kapangyarihan, per noong nakaraang linggo. Ngunit 4 billion ay isang dahilan. Tila, batay sa impormasyon na ito, na LEGO, at ang kumpanya na ginawa ito tunay na software, nagpasya na ang maximum na bilang ng mga barya ang user ay maaaring mag-ipon ay, sa katunayan, 4 bilyon, dahil sila ay pinili sa kanilang code gamitin hindi isang long long, tila, ngunit lamang ng isang integer, isang wala pang kontratang integer, lamang ng isang positibong integer, na ang max halaga ay tinatayang na. Well, narito ang isa pang funny isa. Kaya sa laro Civilization, na kung saan ang ilan sa inyo ay maaaring maging pamilyar, na may ito ay lumiliko out na taon na ang nakakaraan nagkaroon ay isang bug sa ito laro kung saan kung i-play ang papel na ginagampanan ng Gandhi sa laro, sa halip na sa kanya pagiging napaka pasipista, sa halip ay hindi kapani-paniwalang, hindi kapani-paniwalang agresibo, sa ilang mga pangyayari. Sa partikular, ang paraan na Civilization gawa ay na kung ikaw, ang player, magpatibay demokrasya, ang iyong handulong iskor ay makakakuha ng decremented sa pamamagitan ng dalawang, kaya minus minus, at pagkatapos minus minus. 

Kaya mo ibawas 2 mula iyong aktwal na iterating. Sa kasamaang palad, kung ang iyong iterating ay una 1, at ikaw ibawas 2 mula sa mga ito pagkatapos adopting demokrasya bilang Gandhi dito baka ginawa, dahil siya ay napaka-passive-- 1 sa ang laki ng handulong. Ngunit kung siya adopts demokrasya, at pagkatapos ay siya napupunta mula sa 1 sa mga negatibong 1. 

Sa kasamaang palad, sila ay gamit unsigned numero, na nangangahulugan na sila ginagamot kahit negatibong numero na tila hayag na positibo. At ito ay lumiliko out na ang mga positive katumbas ng negatibong 1, sa tipikal programa sa computer, ay 255. Kaya kung Gandhi adopts demokrasya, at sa gayon ay kanyang handulong marka nabawasan, ito ang tunay na Rolls sa paligid sa 255 at gumagawa sa kanya ang pinaka agresibo karakter sa laro. Kaya maaari mong Google up sa mga ito. At ito ay, sa katunayan, ang isang aksidenteng programming bug, ngunit iyan ay ipinasok lubos ang tradisyonal na kaalaman mula pa nang. 

Iyon lang ang masaya at cute. Higit pang mga nakakatakot ay kapag aktwal na tunay na mundo ng mga aparato, at hindi games, may mga parehong mga bug. Sa katunayan, lamang ng isang taon na ang nakalipas ng isang artikulo ay dumating nang malapit na ang Boeing 787 Dreamliner. 

At ang mga artikulo sa unang sulyap nagbabasa ng isang maliit na arcane. Ngunit sinabi ito ito, ang isang software kahinaan sa Boeing bagong 787 Dreamliner jet ay potensyal na maging sanhi pilots upang mawalan ng kontrol ng ang sasakyang panghimpapawid, posibleng sa kalagitnaan ng flight, ang mga opisyal FAA Nagbabala airlines nakaraang araw. Ito ay ang pagpapasiya na ang isang model 787 airplane na na-pinapatakbo patuloy na para sa 248 araw maaaring mawala ang lahat ng alternating kasalukuyang, AC, de-koryenteng kapangyarihan dahil sa ang generator control units, GCUs, sabay-sabay pagpunta sa mabibigo safe mode. Ito ay uri ng pagkawala sa akin. Ngunit ang memo nakasaad, OK, ngayon nakuha ko na, ang kalagayan ay sanhi ng isang software kontrahin panloob sa ng generator control yunit na apaw pagkatapos 248 araw ng tuloy-tuloy na kapangyarihan. Kami ay nag-isyu na ito mapansin upang maiwasan ang pagkawala ng lahat ng AC electrical kapangyarihan, na maaaring magresulta sa pagkawala ng kontrol ng eroplano. 

Kaya, literal, may ilang mga integer, o ilang katumbas na uri ng data, ginagamit sa software sa isang aktwal na eroplano na kung ikaw panatilihin ang iyong airplane sa may sapat na katagalan, na tila maaaring ang kaso kung lamang ikaw ay nagpapatakbo ng ito patuloy at hindi kailanman unplugging ang iyong eroplano, tila, o pagpapaalam baterya nito ay mamatay, ay malaon bilangin up, at up, at up, at up, at up, at up. 

At, sa pamamagitan ng kalikasan, isang takda na halaga ng memory ay apaw, lumiligid bumalik sa zero o ilang negatibong halaga, isang pangalawang epekto ng kung saan ay ang frighteningly real katotohanan na ang eroplano ay maaaring kailangan na rebooted, mabisa, o maaaring mahulog, mas masahol pa, tulad ng ito ay lilipad. Kaya ang mga ito uri ng mga isyu pa rin sa amin, even-- ito ay isang 2015 artikulo, ang lahat ng mga mas nakakatakot kapag ginawa mo hindi kinakailangang maunawaan, pahalagahan, o anticipate mga uri ng mga error. 

Kaya ito lumiliko out mayroong isang iba pang mga masamang bagay tungkol sa data na representasyon. Ito ay lumiliko out na kahit na kamay ay uri ng flawed, dahil sa kamay, masyadong, Iminungkahi ko ay 32 bits, o siguro 64 kung gumamit ka ng isang double. Ngunit na pa rin may hangganan. 

At ang catch ay na kung maaari mong maglagay ng isang walang-katapusang bilang ng mga numero pagkatapos ng decimal point, walang paraan ka maaaring kumatawan ang lahat ng posibleng numero na kami ay itinuro sa mababang paaralan ay maaaring umiiral sa mundo. Ang isang computer, mahalagang, ay upang pumili ng isang subset ng mga numero upang kumatawan nang wasto. 

Ngayon, ang computer ay maaaring ikot marahil ng isang maliit na bit, at maaaring magpapahintulot sa inyo na halos store anumang bilang maaari mong marahil gusto. Ngunit lamang intuitively, kung ikaw magkaroon ng isang may hangganan bilang ng bits, maaari ka lamang ibahin ang ayos ng mga ito sa gayon maraming mga may hangganan paraan. Kaya hindi mo maaaring posibleng gumamit ng isang may hangganan bilang ng permutasyon ng bits, pattern ng mga zero at mga bago, upang kumatawan ng isang walang hanggan bilang ng mga numero, na nagmumungkahi na ang mga computer maaaring napakahusay maging namamalagi sa amin paminsan-minsan. 

Sa katunayan, sabihin gawin ito. Hayaan akong bumalik sa CS50 IDE. Hayaan akong sige at lumikha ng isang maliit na programa tinatawag imprecision, upang ipakita na mga computer ay, sa katunayan, imprecise. 

At hayaan mo akong magpatuloy at magsimula sa ang ilan sa na code mula sa harap, at ngayon lamang gawin ang mga sumusunod. Hayaan akong magpatuloy at gawin printf, porsiyento f, backslash n, 1 hinati sa 10. Sa ibang salita, sabihin sumisid sa mas malalim sa 1/10, tulad ng 1 at hinati sa 10. Tiyak, ang isang computer ay maaaring kumatawan sa 1/10. 

Kaya sabihin sige at gumawa imprecision. Tingnan natin. Format tumutukoy type double. Ngunit ang argument ay may type int. Ano ang nangyayari? 

Oh, kawili-wili, kaya ito ay isang aral na natutuhan mula sa bago. Ako sinasabi, hey, computer show ako ng isang float na may porsyento f. Ngunit ako nagbibigay ito ng 2 ints. Kaya ito ay lumiliko out, ang maaari kong ayusin ito sa loob ng ilang mga paraan. 

hindi ko na lang i-isa sa 1.0, at 10 sa 10.0, na kung saan ay, sa katunayan, magkaroon ng epekto ng pag-convert ng ang mga ito sa floats-- pa rin sana sa parehong numero. O ito ay lumiliko out mayroong isang bagay kami makita muli bago ang haba. Maaari mong palayasin ang mga numero. 

Maaari mong, gamit ang parenthetical expression, maaari mong sabihin, hey, computer, kumuha ito 10, na alam ko ay isang int. Ngunit ituring ito, mangyaring, na parang ito ay isang float. Ngunit ito nararamdaman hindi kinakailangan complex. 

Para sa aming mga layunin araw na ito, sabihin lang literal gumawa ng mga ito lumulutang halaga punto na may isang decimal point, tulad nito. Hayaan akong sige at gawin uli, gumawa imprecision, good, dot slash imprecision, ipasok. OK, kami ay naghahanap ng mabuti. 

1 hinati sa 10, ayon sa aking Mac dito, ay, sa katunayan, 0.100000. Ngayon, ako ay itinuro sa mababang paaralan doon ay dapat na isang walang-katapusang bilang ng 0. Kaya sabihin hindi bababa sa subukan upang makita ang ilan sa mga. Ito ay lumiliko out na printf ay isang maliit na may interes pa rin kaysa kami ay gumagamit ng. Ito ay lumiliko out hindi mo na kailangang upang tukuyin lamang porsiyento f, o lamang porsiyento i. Maaari mong aktwal na tukuyin ilang mga pagpipilian control dito. 

Sa partikular, ako pagpunta sabihin, hey, printf, aktwal na ipakita sa akin ang 10 decimal point. Kaya ito ang hitsura ng isang maliit na kakaiba. Gayon ma'y inyong sinasabi porsiyento, tuldok, kung gaano karaming mga numero Gusto mo bang makita pagkatapos ng decimal point, at pagkatapos ay f para sa flat, dahil lang iyon ang ano ang sinasabi ng babasahin. Hayaan akong sige at i-save na. 

At mapansin masyadong, ko natatanggap pagod ng retyping bagay. Kaya lang ako sa pag-set up at down na arrow sa aking mga susi dito. At kung ako panatilihin ang paghagupit up, ikaw maaaring makita ang lahat ng mga utos na ginawa ko, o hindi tama ginawa. 

At ako pagpunta sa sige ngayon at hindi talaga gamitin na, tila. Gumawa imprecision, tuldok slash imprecision-- kaya kung ano ako ay itinuro sa grade school sumusuri out. Kahit na i-print ko ito sa 10 decimal mga lugar na ito, sa katunayan, ay 0.10000. Pero alam mo kung ano? 

Sabihin makakuha ng isang maliit na matakaw. Sabihin natin, tulad ng, ipakita sa akin 55 puntos pagkatapos ng decimal. Sabihin talagang kumuha ito programa para sa isang iikot. Hayaan akong gawing muli ito sa make imprecision, tuldok slash, imprecision. 

At dito namin pumunta. Ang iyong pagkabata ay isang kasinungalingan. Sa malas, 1 hinati sa 10 ay sa katunayan 0.100000000000000005551115123-- 

Ano ang nangyayari? Well, ito ay lumiliko out, kung ikaw uri ng Tumingin malayo sapat out sa ang kalakip na representasyon ng mga ito number, ito ang tunay na ay hindi eksakto 1/10, o 0.1 at isang walang hanggan bilang ng mga zero. Ngayon, kung bakit ay na? 

Well, kahit na ito ay isang simpleng numero sa amin mga tao, 1 hinati sa 10, ito ay pa rin ang isa sa mga walang katapusan maraming mga numero na maaaring sa tingin namin up. Ngunit ang isang computer ay maaaring lamang kumakatawan finitely maraming mga kaya numero. At kaya, mabisa, kung ano ang computer ay nagpapakita sa amin ay ang pinakamalapit approximation sa bilang gusto naming naniniwala ay 1/10, o talagang 0.10000 ad infinitum. 

Sa halip, bagaman, ito ay mas malapit hangga't maaari itong makuha. At, sa katunayan, kung titingnan mo ilalim ng hood, gaya naman natin na dito sa pamamagitan ng pagtingin 55 digit pagkatapos ng decimal, namin talagang na katotohanan. Ngayon bilang isang bukod, kung na sa iyo kailanman makikita ang movie-- karamihan sa inyo malamang haven't-- ngunit Superman 3 ilang taon na nakalipas, Richard Pryor mahalagang leveraged ito katotohanan sa kanyang kumpanya upang magnakaw ng maraming ng mga fraction at fractions ng pennies, dahil ang company-- bilang ko pagpapabalik, ito ay naging isang while-- ay mahalagang itsa anumang bagay na hindi umangkop sa paniwala ng cents. 

Ngunit kung ikaw magdagdag ng hanggang ang lahat ng mga maliit na maliit, maliit na maliit, maliit na maliit mga numero muli, at muli, at muli, maaari mong, tulad ng sa kanyang kaso, gumawa ng isang mahusay na halaga ng pera. 

Na parehong ideya ay natastas off sa pamamagitan isang mas bagong, ngunit pa rin ngayon mas matanda movie, na tinatawag na Office Space, kung saan ang mga guys sa movie na, ginawa ang parehong bagay, screwed up ito ganap, natapos na may paraan ng masyadong maraming pera sa kanilang mga account sa bangko. Ito ay ang lahat ng tunay kahina-hinala. Ngunit sa pagtatapos ng araw, imprecision ay ang lahat sa paligid sa amin. 

At iyon, masyadong, ay maaaring maging frighteningly ang kaso. Ito ay lumiliko out na Superman 3 at Office Space tabi, may ay maaaring maging ng ilang mga napaka-real mundo ramifications ng mga katotohanan ng imprecise representasyon ng data na kahit tayong mga tao sa sa araw na ito ay hindi kinakailangang maunawaan pati na rin ang dapat namin, o tandaan nang mas madalas hangga't dapat namin. At, sa katunayan, ang mga sumusunod na clip ay mula sa isang pagtingin sa ilang mga napaka-tunay na mundo ramifications ng kung ano ang mangyayari kung ikaw ay hindi pinasasalamatan ang imprecision na Maaari itong mangyari sa mga numero na representasyon. 

[Video playback] 

-Computers, Lahat kami dumating upang tanggapin ang madalas na nakakabigo problema na pumunta sa them-- bugs, mga virus, at software glitches, para sa mga maliliit na mga presyo upang bayaran para sa kaginhawahan. Ngunit sa mataas na tech at high speed militar at space program application, ang pinakamaliit na problema Maaari ay Pinalaking sa kalamidad. 

Sa Hunyo 4, 1996, siyentipiko inihanda na maglunsad ng isang unmanned Ariane 5 rocket. Ito ay nagdadala ng pang-agham satellite dinisenyo upang magtatag tiyak kung paano ang magnetic field ng lupa nakikipag-ugnayan may solar na hangin. Rocket ay ginawa para sa European Space Agency, at lifted off mula sa kanyang pasilidad sa baybayin ng French Guiana. 

-Sa Tungkol sa 37 segundo sa ang flight, sila ay unang Napansin ng isang bagay ay pagpunta mali. Ang nozzles ay swiveling sa isang paraan sila ay talagang dapat hindi. Around 40 segundo sa flight, malinaw na, ang sasakyan ay may problema. 

At na kapag ginawa nila isang desisyon upang wasakin ito. Ang safety officer na layo, na matinding lakas ng loob, pinindot ang button, blew up ang rocket, bago ng dati maging isang panganib sa kaligtasan ng publiko. 

-Ito Ay ang maiden paglalayag ng Ariane 5. At nito pagkawasak kinuha ilagay dahil sa isang lamat naka-embed sa software ang rocket ni. -Ang Problema sa Ariane ay na nagkaroon ng isang numero na kinakailangan 64 bits upang ipahayag. At nais nilang i-convert ito sa isang 16-bit na numero. Sila ay ipinapalagay na ang mga numero ay hindi kailanman pagpunta upang maging napaka-malaki, na ang karamihan ng mga digits sa isang 64-bit na numero ay zeroes. Sila ay mali. 

-Ang Kawalan ng kakayahan ng isang software program upang tanggapin ang uri ng numero na nabuo sa pamamagitan isa pang ay sa ugat ng failure. Software development ay naging isang napaka-mahal na bahagi ng mga bagong teknolohiya. Ang Ariane rocket ay lubhang matagumpay, kaya magkano ng software nilikha para sa ito ay din ginagamit sa Ariane 5. 

-Ang Pangunahing problema ay na ang Ariane 5 ay mas mabilis, pinabilis na mas mabilis. At ang software ay hindi accounted para sa. 

-Ang Pagkawasak ng rocket ay isang malaking pinansiyal na kalamidad, lahat dahil sa isang error sa minutong software. Ngunit ito ay hindi ang unang time problema sa data ng conversion ay plagued modernong rocket teknolohiya. 

-Sa 1991, sa simula ng unang Gulf War, ang Patriot misayl nakaranas ng isang katulad na uri ng problema bilang conversion. At bilang isang resulta, 28 tao, 28 mga sundalong Amerikano, ay namatay, at tungkol sa 100 iba pa ang nasugatan, kapag ang Patriot, na kung saan ay dapat upang maprotektahan laban sa mga papasok na scuds, Nabigo sa sunog isang misayl. 

-Kapag Iraq invaded Kuwait, at Amerika inilunsad Desert Storm sa unang bahagi ng 1991, Patriot misayl baterya ay deployed upang protektahan ang Saudi Arabia at Israel mula Iraqi malaking ulan misayl pag-atake. Ang Patriot ay isang medium-range US ibabaw upang air system, manufactured sa pamamagitan ng Raytheon kumpanya. 

-Ang Laki ng Patriot interceptor mismo ay tungkol sa humigit-kumulang 20 talampakan ang haba. At ito weighs tungkol sa 2,000 pounds. At ito ay nagdadala ng isang warhed ng tungkol sa, tingin ko ito ay humigit-kumulang 150 pounds. At ang warhed mismo ay isang mataas na paputok, na kung saan ay fragments sa paligid nito. Ang casing ng warhed ay dinisenyo upang kumilos tulad buckshot. 

-Ang Missiles ay dinala apat bawat lalagyan, at ay transported sa pamamagitan ng isang semi trailer. 

-Ang Patriot anti-misayl sistema napupunta likod ng hindi bababa sa 20 taon na ngayon. Ito ay orihinal na idinisenyo bilang isang air pagtatanggol misayl i-shoot down na kaaway eroplano. Sa unang Gulf War, kapag digmaan na dumating kasama, ang Army nais gamitin ito upang shoot down scuds, hindi eroplano. 

Ang Iraqi Air Force ay hindi kaya magkano ng isang problema. Ngunit ang Army ay nag-aalala tungkol sa scuds. At kaya sila tried sa i-upgrade ang Patriot. 

-Intercepting Isang kaaway misayl na naglalakbay sa Mach 5 ay pagpunta sa maging mahirap sapat. Ngunit kapag ang Patriot ay rushed sa serbisyo, ang Army ay hindi alam ng isang Iraqi pagbabago na ginawa kanilang scuds halos imposible upang maabot. 

-Ano Ang nangyari ay ang scuds na ay darating sa mga hindi matatag. Sila ay wobbling. Ang dahilan sa ito ay ang Iraqis, upang upang makakuha ng 600 kilometro sa labas ng isang 300 kilometro range missile, kinuha timbang sa labas ng front warhed. Sila ay ginawa warhed lighter. 

Kaya ngayon ang Patriot ay sinusubukan na dumating sa malaking ulan. At halos lahat ng oras, ang napakalaki karamihan ng mga oras, ito would makatarungan lumipad sa pamamagitan ng malaking ulan. Sa sandaling ang mga operator Patriot sistema maisasakatuparan ang Patriot hindi natamaan ang target, sila mina Patriot warhed ni upang maiwasan ang posibleng casualties kung ito ay pinapayagan na mahulog sa lupa. 

-Na Ay kung ano ang nakita karamihan ng mga tao, mga malaking fireballs sa kalangitan, at gusot bilang intercepts ng malaking ulan warheads. 

-Kahit sa gabi kalangitan, Patriots lumitaw upang maging matagumpay pagsira Scuds, sa Dhahran, doon ay maaaring walang pagkakamali tungkol sa pagganap nito. Doon, radar system ang Patriot ni nawala subaybayan ng isang papasok na malaking ulan, at hindi kailanman Inilunsad dahil sa isang software kapintasan. Ito ay ang Israelis na unang natuklasan na ang mga na ang sistema ay sa, ang mas malaki ang pagkakaiba sa oras naging, dahil sa isang orasan na naka-embed sa computer system. 

-Tungkol Sa dalawang linggo bago trahedya sa Dhahran, ang Israelis iniulat sa ang Defense Department na ang sistema ay hindi nawawala ang oras. Matapos ang tungkol sa walong oras o tumatakbo, napansin nila na ang sistema ay magiging kapansin-pansing mas tumpak. Ang Defense Department tumugon sa pamamagitan ng na nagsasabi sa lahat ng mga Patriot baterya upang mag-iwan ang mga sistema sa para sa isang mahabang panahon. Sila ay hindi kailanman sinabi kung ano ang isang mahabang panahon was-- walong oras, 10 oras, 1,000 na oras. Hindi ko alam. 

-Ang Patriot baterya stationed sa barracks sa Dhahran at ang mga flawed panloob orasan ay hindi naging sa higit sa 100 oras noong gabi ng Pebrero ika-25. 

-Ito Sinusubaybayan oras sa isang kawastuhan ng tungkol sa isang ikasampu ng isang segundo. Ngayon, ang isang ikasampu ng isang segundo ay isang nakawiwiling number, dahil hindi ito maaaring ipinahayag sa binary eksakto, na kung saan ay nangangahulugan na hindi ito maaaring ipinahayag nang eksakto sa anumang modernong digital computer. Ito ay mahirap na paniwalaan. 

Ngunit gamitin ito bilang isang halimbawa. Tingnan natin ang number one third. Isang-katlo ay hindi maaaring maging ipinahayag sa decimal eksakto. Isang-katlo ay 0.333 pagpunta sa para sa infinity. 

Walang paraan upang gawin iyon na may ganap na kawastuhan sa decimal. Iyan ay eksakto ang uri ng problema na nangyari sa Patriot. Ang mas mahaba ang sistema ay tumakbo, ang mas masahol pa ang naging time error. 

-After 100 oras ng pagpapatakbo, ang error sa oras ay lamang tungkol sa isang-katlo ng isang segundo. Ngunit sa mga tuntunin ng pag-target ng isang misayl na naglalakbay sa Mach 5, ito ay nagdulot ng isang tracking error ng higit sa 600 metro. Gusto Ito ay isang malalang error para sa mga sundalo sa kung ano ang nangyari ay isang malaking ulan launch ay nakita ng maagang babala satellite at alam nila na ang malaking ulan ay darating sa kanilang pangkalahatang direksyon. Hindi nila alam kung saan ito ay darating. 

-Ito Ay ngayon hanggang sa radar bahagi ng sistema ng Patriot pagtatanggol Dhahran upang mahanap at mapanatili ang track ng mga papasok na kaaway misayl. 

-Ang Radar ay napaka smart. gusto talaga itong subaybayan ang posisyon ng malaking ulan, at pagkatapos ay hulaan kung saan ito marahil ay ang susunod na oras na ang radar nagpadala isang pulso out. Iyon ay tinatawag na isang hanay gate. 

-Pagkatapos, Sa sandaling ang Patriot nagpasya sapat na oras ay lumipas upang bumalik at suriin ang susunod na lokasyon para sa Nakita bagay, ito napupunta pabalik. Kaya kapag ito ay bumalik sa maling lugar, ito pagkatapos nakikita walang object. At ito ay nagpasiya na walang bagay, ito ay isang maling detection, at patak ng track. 

-Ang Papasok malaking ulan Naglaho mula sa screen radar. At segundo mamaya, ito slammed sa kuwartel. Ang malaking ulan pumatay 28, at ang huling isa fired sa panahon ng unang Gulf War. 

Tragically, ang na-update software Dumating ito sa Dhahran sa susunod na araw. Ang software flaw nagkaroon naging maayos, pagsasara isang kabanata sa gusot kasaysayan ng Patriot misayl. 

[Video playback] David J. MALAN: Kaya ito ay ang lahat sa sabihin na ang mga isyu ng overflow at imprecision ay ang lahat ng masyadong real. Kaya kung paano did we get here? Sinimulan namin sa pamamagitan lamang ng pakikipag-usap tungkol sa printf. Muli, ito function na Kopya ng isang bagay sa screen, at hindi na namin ipinakilala pagkatapos noon ng ilang iba pang mga function mula sa tinaguriang library CS50. At kami ay patuloy na makita ang mga ito sa angkop na panahon. At kami, lalo na, na ginagamit get string, at makakuha ng int, at ngayon din makakuha float, at pa iba pa rin kami ay magkasalubong at gamitin ang ating mga sarili bago ang haba. 

Ngunit kung minsan, ay may namin na nakita sa isang pangangailangan upang mag-imbak kung ano ang mga pag-andar kamay sa likod? ipasa nila sa amin sa likod ng isang string, o isang int, o isang Float. At kung minsan kailangan namin upang ilagay na string, o int, o float, tabi-tabi. 

At upang mag-imbak ng mga bagay, isipin lamang tulad ng sa simula, kami ay may mga variable. Ngunit hindi tulad ng sa simula, sa C mayroon kaming aktwal na mga uri ng variables-- data uri, mas generally-- kasama ng mga ito, ang isang string, isang int, isang lumutang, at ang mga iba pa rin. 

At kaya kung ating sinasabi variable sa C, kami ay may upang ipahayag ang aming mga uri ng data. Ito ay hindi isang bagay bibigyan namin kailangang gawin sa ibang pagkakataon sa semestre bilang namin paglipat sa ibang mga wika. Ngunit sa ngayon, namin kailangan upang walang pagsubok nang maaga, ipaliwanag sa ang computer kung ano ang uri ng variable gusto naming ito upang ibigay sa amin. 

Ngayon, samantala, i-print mga uri ng mga uri ng data, kami ay may upang sabihin sa printf ano ang aasahan. At nakita natin porsiyento s para sa mga string, at porsyento i para integers, at ng ilang mga iba pa. At ang mga ito ay simpleng mga kinakailangan para sa mga visual na pagtatanghal ng impormasyon na iyon. 

At bawat isa sa mga ito ay maaaring aktwal na maging parametrized o tweaked sa anumang paraan, kung nais mong palawakin control ang uri ng output na iyong makukuha. At, sa katunayan, ito ay lumiliko out na hindi lamang ay diyan backslash n para sa isang bagong linya. Mayroong isang bagay sino pa ang paririto na tinatawag backslash r para sa isang carriage return, na kung saan ay mas kauri sa isang old school makinilya, at din Windows na ginagamit para sa maraming mga taon. 

Mayroong backslash t para sa mga tab. Lumiliko out, na kung nais mong double quote sa loob ng isang string, pagpapabalik na kami ay ginagamit double quote double quote sa kaliwa at kanang nagtatapos ng aming mga string kaya malayo. Iyon ay tila upang lituhin ang mga bagay. 

Kung nais mong ilagay ang isang double quote sa sa gitna ng isang string at, sa katunayan, ito ay nakalilito upang makita. At kaya mayroon kang upang makatakas, kaya na makipag-usap, ang isang double quote sa isang bagay tulad ng, literal, backslash double quote. At mayroong ilang mga iba pang pa rin. At kami makita higit pa sa mga sa aktwal na paggamit bago ang haba. 

Kaya natin ngayon paglipat mula sa data, at representasyon, at aritmetika operator, ang lahat ng isa ay nagbigay sa amin ng ilang mga gusali bloke na kung saan upang i-play. Ngunit ngayon sabihin aktwal bigyan sa amin ang natitirang bahagi ng bokabularyo na kami ay mayroon noong nakaraang linggo na may Scratch sa pamamagitan ng pagkuha ng isang pagtingin sa ilang mga iba pang constructs sa C-- hindi lahat ng mga ito. Ngunit ang mga ideya kami tungkol sa upang makita talagang lamang upang bigyan ng diin ang pagsasalin mula sa isang wika, Scratch, sa iba, C. 

At sa paglipas ng panahon, kami ay pumili ng up higit pang mga tool para sa aming toolkit, kaya na magsalita, syntactically. At, sa katunayan, makikita mo na ang mga ideya ay ngayon sa halip pamilyar mula noong nakaraang linggo. Kaya sabihin gawin ito. 

Sabihin sige at gumawa ng isang program na aktwal na gumagamit ng ilang mga expression, isang Boolean expression. Hayaan akong magpatuloy dito at lumikha ng isang bagong file. Tatawag ako ito condition.c. 

Hayaan akong sige at isama ang CS50 library. At ipaalam sa akin sige at isama karaniwang io.h para sa aming mga pag-andar, at printf, at higit pa ayon sa pagkakabanggit. Hayaan akong magbigay sa sarili ko na boilerplate ng int pangunahing walang bisa, na ang paliwanag bibigyan namin bumalik sa sa hinaharap. 

Ngayon ipaalam sa akin sige at bigyan aking sarili ng isang int sa pamamagitan ng get int. Pagkatapos ay hayaan mo akong magpatuloy at gawin ito. Gusto kong sabihin kung ako ay less-- sabihin makilala sa pagitan ng positibo, negatibo, o zero na halaga. 

Kaya kung ako ay mas mababa sa zero, hayaan mo akong na lang ay ang program na ito lang sabihin, negatibo, backslash n, sino pa ang paririto kung ako ay mas malaki kaysa zero. Ngayon ako, siyempre, pagpunta sa sabihin printf positibong, backslash n. At pagkatapos ay sino pa ang paririto if-- kaya kong gawin ito. 

kaya kong gawin kung ako ay katumbas ng 0. Pero gusto ko ay paggawa sa hindi bababa sa isang pagkakamali na. Sariwain sa alaala na ang katumbas sign ay hindi katumbas, bilang namin ang mga tao na malaman ito. 

Ngunit ito ay ang assignment operator. At hindi namin nais na kumuha ng 0 sa kanan at ilagay ito sa i sa kaliwa. Kaya upang maiwasan ang pagkalito, o marahil maling paggamit ng equals sign, mga kawani na tao ay nagpasya ilang taon na ang nakakaraan na sa maraming mga wika programming kapag gusto mong suriin para sa pagkakapantay-pantay pagitan ng kaliwa at kanan, na aktwal mong gamitin katumbas katumbas. Kaya mo pindutin ang equals sign dalawang beses. Kapag nais mong italaga mula sa kanan sa kaliwa, gumamit ka ng isang solong katumbas sign. Kaya maaari naming gawin this-- sino pa ang paririto kung ako ay katumbas katumbas ng zero. 

Kaya kong pagkatapos ay pumunta at buksan ang aking mga kulot tirante, At iyong sabihin, printf 0, backslash n, tapos na. Ngunit tandaan kung paano ang mga tinidor sa kalsada ay maaaring gumana. At, talaga, sa tingin lamang tungkol sa logic. i ay isang numero. Ito ay isang integer, partikular. At nangangahulugan ito ay pagpunta sa maging mas mababa kaysa sa 0, o mas mataas kaysa sa 0, o 0. Kaya doon ay uri ng ito ipinahiwatig default kaso. 

At kaya kami ay maaaring, gusto lang Scratch, alisin ang ibang tao kung, at sabihin lamang ng iba pa. Logically, kung ikaw ang programmer alam mayroon lamang tatlong mga bucket sa kung saan ang isang sitwasyon maaari fall-- ang una, sa pangalawa, o pangatlong sa ganitong case-- hindi abala ang pagdaragdag ng karagdagang katumpakan at ang karagdagang logic doon. sige lang sa default kaso dito ng ibang tao. 

Ngayon, sabihin sige pagkatapos i-save ito, gumawa kondisyon dot slash conditions-- hindi isang mahusay na user interface, dahil hindi ako pagdikta ang user, tulad ng nabanggit ko mas maaga. Ngunit iyon lamang ang fine. Susubukan naming panatilihin ito simple. Natin subukan ang ang bilang 42 Hayaan. At iyon ang positibo. Natin subukan ang ang bilang Hayaan negatibong 42, negatibo. 

Natin subukan ang ang halaga ng 0 Hayaan. At, sa katunayan, ito ay gumagana. Ngayon, makikita mo na may mga problema bago mahaba, testing bagay ng tatlong beses, marahil ay hindi sapat. Maaring nais na subukan ang ilang mga mas malaking mga numero, ang ilang mga mas maliit na numero, ang ilang mga kaso na sulok, tulad ng kami ay dumating upang ilarawan ang mga ito. 

Ngunit para sa ngayon, ito ay isang pretty simpleng programa. At ako ay medyo sigurado, logically, na ito ay bumaba sa tatlong mga kaso. At, sa katunayan, kahit na kami lang na nakatutok sa ang mga potensyal na downsides ng imprecision at aabot, sa katotohanan kung saan marami sa mga problema sa CS50, hindi namin ay pagpunta sa mag-alala tungkol sa, lahat ng oras, mga isyu ng overflow at imprecision, dahil, sa katunayan, sa C, ito ay talagang hindi lahat na madaling iwasan ang mga bagay na ito. Kung nais mong bilangin up mas malaki, at mas malaki, at mas malaki, ito ay lumiliko out may mga pamamaraan sa iyo maaaring gamitin, madalas na kinasasangkutan bagay na tinatawag na mga aklatan, mga koleksyon ng mga code, na ibang mga tao ay sumulat na maaari mong gamitin, at iba pang mga wika tulad ng Java at iba pa, ang tunay na gawin itong ng maraming mas madali upang mabilang kahit na mas mataas. Kaya ito ay tunay na ang ilan sa mga panganib isang katangian ng ang wika na ginagamit mo. At sa mga darating na linggo, kami ay makita kung paano mapanganib na C talagang ay maaaring maging kung hindi mo gamitin ito ng maayos. Nguni't mula roon, at may Python, at JavaScript, ay namin layer sa ilang karagdagang proteksyon, at magpatakbo ng mas kaunting mga panganib. 

Kaya sabihin gawin ng kaunti pa kagiliw-giliw na lohika sa aming programa. Kaya hayaan mo akong magpatuloy at lumikha ng isang programa na tinatawag Logical lamang kaya maaari kong i-play na may ilang mga aktwal na logic, logical.c. kukunin ko na lang kopyahin at i-paste ang ilang mga code mula sa mas maaga kaya nakukuha ko pabalik sa ito maganda ang panimulang punto. 

Hayaan akong oras na ito gawin char C. Ako pagpunta sa bigyan ito ng isang pangalan ng C lamang dahil ito ay maginoo, makakuha ng isang character mula sa user. At sabihin magpanggap tulad Ako ng pagpapatupad bahagi ng na Rm programa, ang pag-alis programa bago na sinenyasan ang user upang alisin ang isang file. Paano maaari naming gawin ito? 

gusto kong sabihin, kung C ay katumbas ay katumbas ng, quote magpanipi, y, pagkatapos ay ako pagpunta sa ipinapalagay na ang gumagamit ay pinili yes. Lamang ako ng pagpunta upang i-print yes. Kung tunay na ito ay sumusulat ang pag-alis ng programa, maaari naming alisin ang file na may higit pang mga linya ng code. Ngunit kami ay panatilihin ito simple. 

Iba Pa kung c ay katumbas ng katumbas n-- at ngayon dito, ako pagpunta sa sabihin, ang user ay dapat may ibig sabihin no. At pagkatapos ng iba pa, alam mo kung ano? Hindi ko alam kung ano pa ang user ay pagpunta upang i-type. Kaya lang ako sa pagpunta sa sabihin na na ay isang error, kahit anong siya o siya talaga type. 

Kaya kung ano ang nangyayari sa dito? May ay isang pangunahing pagkakaiba kumpara sa kung ano ang aking nagawa sa nakaraan. Double quotes, double quotes, double quotes, at, pa, single quotes, single quotes. Ito ay lumiliko out sa C, na kapag gusto mong magsulat ng isang string, gawin mo gamitin ang double quotes, tulad na namin ay gumagamit ng lahat ng oras na ito sa printf. 

Ngunit kung nais mong upang harapin na may lamang ng solong character, isang tinatawag na pansamantalang trabaho, pagkatapos mo talagang gamitin single quotes. Yaong ng iyo kung sino na programmed bago, hindi ka maaaring magkaroon ng ay mag-alala tungkol sa mga ito pagkakaiba sa ilang mga wika. Sa C, ginagawa nito bagay. At kaya kapag kumuha ako ng isang char at gusto kong upang ihambing na char gamit equals katumbas sa ilang mga sulat tulad y o n, gagawin ko, sa katunayan, kailangan na magkaroon ng single quotes. 

Ngayon, sabihin sige at gawin ito. Sabihin sige at make lohikal dot slash lohikal. At ngayon ako diktahan. So, siguro, isang mas mahusay na karanasan ng user ay tunay na sabihin sa akin kung ano ang gagawin dito. Ngunit ako pagpunta sa lamang nang walang taros sabihin y para sa yes, OK, nice. 

ni patakbuhin itong muli Hayaan, n para sa walang, nice. Ipagpalagay tulad ng ilang mga taong kilala ko, aking caps lock key ay sa lahat ng masyadong madalas. Gayon din ang aking capital Y, ipasok, error. OK, ito ay hindi eksakto kung ano ako umaasa. Sa katunayan, ang computer ginagawa literal kung ano ang Sinabi ko ito sa do-- suriin para lowercase y at lowercase n. Ito ay hindi pakiramdam tulad ng mabuting karanasan ng gumagamit, kahit na. Hayaan akong humingi at tanggapin mag-lower case o upper case. Kaya ito lumiliko out, baka gusto upang sabihin ng isang bagay tulad ng sa simula, tulad literal o C ay katumbas ay katumbas ng capital single quoted y. Lumiliko out, C ay walang ito literal keyword o. 

Ngunit ito ay may dalawang vertical bars. Mayroon kang upang i-hold Shift kadalasan, kung gumagamit ka ng isang US keyboard, at pindutin ang vertical bar key sa itaas ng iyong return key. Ngunit ito vertical bar vertical bar ay nangangahulugan o. 

Kung, sa pamamagitan ng kaibahan, gusto naming sabihin at, tulad ng sa simula, maaari naming gawin ampersand ampersand. Iyon ay hindi gumagawa ng lohikal na kahulugan dito, dahil ang isang tao ay hindi maaaring posibleng nai-type sa parehong y at lowercase y at capital Y bilang ang parehong character. Kaya o ay kung ano ang balak namin dito. 

Kaya kung gagawin ko ito sa parehong mga lugar, oc ay katumbas ng katumbas capital N, ngayon muling palabas ng pelikula, gumawa lohikal, muling palabas ng pelikula lohikal. Ngayon, maaari kong i-type y. At maaari kong gawin ito muli sa capital Y, o capital N. At maaari ba akong magdagdag sa mga karagdagang kumbinasyon pa rin. 

Kaya ito ay isang lohikal na program insofar bilang ngayon Lalabas na ako logically para ang halaga na ito o ang halagang ito. At hindi ko na kailangang, kinakailangan, makabuo ng dalawang higit pang mga ifs o iba ifs. Maaari ko talagang pagsamahin ang ilan sa mga kaugnay logic magkasama sa ganitong paraan. Kaya ito ay magiging mas mahusay dinisenyo na lamang na sinasabi, kung C ay katumbas lower case y, print yes, iba kung c ay katumbas ng capital Y, print yes, iba kung c ay katumbas ng lower-- sa ibang salita, hindi mo na kailangang magkaroon ng higit pa at higit pang mga sanga. Maaari mong pagsamahin ang ilan sa ang katumbas sanga logically, tulad ng sa ganitong paraan. 

Kaya ipaalam sa tumagal ng isang pagtingin sa isa lamang final sahog, isang huling bumuo, na C ay nagbibigay-daan. At kami ay bumalik sa hinaharap sa iba pa rin. At pagkatapos ay gagamitin namin tapusin sa pamamagitan ng pagtingin sa hindi ang kawastuhan ng code-- pagkuha code upang work-- ngunit ang disenyo ng code, at halaman ang mga binhing iyon maaga. 

Kaya hayaan mo akong magpatuloy at buksan up ng isang bagong file dito. Alam mo ba? Pupunta ako upang muling ipatupad na parehong programa, ngunit ang paggamit ng isang iba't ibang mga tayuan. 

Kaya hayaan mo akong mabilis bigyan ang aking sarili access upang isama CS50.h para sa CS50 library, karaniwang io.h para printf. Bigyan mo ako ng aking int pangunahing walang bisa. At pagkatapos ay sa paglipas dito, sabihin mo akong magpatuloy at gawin ito. 

Char c makakakuha makakuha char, tulad ng dati. At ako pagpunta sa gumamit ng isang bagong tayuan now-- lumipat, sa kung ano ang character? Kaya switch ay uri ng tulad paglipat ng mga track ng tren. O kaya naman, talaga, ito ay uri ng isang kung dili, kung sino pa ang paririto kung, ngunit nakasulat medyo naiiba. 

Ang isang pagpapalit ganito ang hitsura. Mayroon kang lumipat, at pagkatapos ay kung ano karakter o numero na gusto mong upang tumingin sa, pagkatapos ng ilang mga kulot tirante gusto in Scratch, sabihin lamang gawin ito bagay-bagay. At pagkatapos ay mayroon kang iba't ibang mga kaso. 

Hindi mo gamitin kung at iba pa. Mong literal gamitin ang salitang kaso. At ang gusto mong sabihin ng isang bagay tulad nito. 

Kaya sa kaso ng isang lowercase y, o sa kaso ng malaking titik Y, sige, at i-print out yes. At pagkatapos ay magsimula ng switch. Ayan yun. Tapos na. 

Else kung, kaya na magsalita, lower case n, o capital N, pagkatapos ay sige at i-print out no, at pagkatapos ay masira. Else-- at ito uri ng ay ang default case indeed-- printf error-- at para lamang sa mabuting pamamaraan, bagaman logically break ay hindi kinakailangan dahil kami sa dulo ng switch anyway, ngayon ako paglabag sa labas ng switch. Kaya ito ang hitsura ng isang maliit na naiiba. 

Ngunit, logically, ito ay aktwal na katumbas. At kung bakit nais mong gamitin isa sa isa? Minsan, kailangan lang personal na kagustuhan, kung minsan ang mga aesthetics, kung sulyap ako sa ito ngayon, mayroong isang bagay na sinabi para sa mga pagiging madaling mabasa ng code na ito. Ibig sabihin ko, hindi bale ang katunayan na ito code ay bago sa marami sa amin sa kuwarto. 

Ngunit ito lamang ang uri ng ay medyo. Ang makikita mo lowercase y, capital Y, lower case n, capital N default, ito lamang ang uri ng jumps out sa iyo sa isang paraan na, arguably, siguro nakaraang halimbawa may ifs, at ang vertical bar, at ang iba ifs, hindi maaaring magkaroon. Kaya ito ay talagang isang bagay ng mga personal na pagpipilian, talaga, o pagiging madaling mabasa, ng code. 

Ngunit sa mga tuntunin ng pag-andar, hayaan mo akong sige, at gumawa ng isang lumipat, dot slash switch, at ngayon i-type sa lowercase y, capital Y, lowercase n, capital N, David, muling subukan dahil na hindi isang solong character. Tayo'y gawin ang x, error, tulad ng inaasahan Hayaan. At, logically-- at ito ay isang bagay Gusto ko hinihikayat sa general-- kahit bagaman lamang kami ay scratching ang ibabaw ng ilan sa mga tampok na ito. 

At hindi ito maaaring maging halata kapag ikaw ang iyong sarili umupo sa keyboard, kung paano ito gumagana? Ano kaya ang gagawin nito? Ang magandang bagay tungkol sa pagkakaroon isang laptop, o desktop, o pag-access sa isang computer na may isang compiler, at may isang code editor tulad nito, ay maaari mong halos palaging sagutin ang mga katanungan para sa iyong sarili sa pamamagitan lamang ng sinusubukan. 

Halimbawa, kung ang retorika tanong sa kamay ay, kung ano ang mangyayari kung nakalimutan mo iyong bakasyon pahayag? Na kung saan ay talagang isang napaka-pangkaraniwan bagay na gawin, dahil ito ay hindi hitsura tulad ng talagang kailangan mo sila. Hindi sila tunay na makumpleto ang iyong naisip tulad ng isang parenthesis o isang kulot suhay ay. Sabihin sige at recompile ang code at makita. Kaya gumawa switch, dot slash lumipat. ni-type sa maliit na titik Hayaan y, tuktok kaso, ang Enter. Kaya ako nag-type y. 

Ang programa ay sinabi oo, hindi, error, na parang ito ay ang pagbabago isip nito. Ngunit ito uri ng ay, dahil kung ano ang mangyayari na may isang lumipat ay ang unang kaso na match mahalagang ay nangangahulugan, hey computer, execute lahat ng code sa ilalim nito. At kung hindi mo sasabihin break, o huwag sabihin break, o huwag sabihin break, ang computer ay pagpunta sa pumutok sa pamamagitan ng lahat ng mga linya at isakatuparan ang lahat ng mga ito hanggang sa ito ay makakakuha ng sa na kulot suhay. Kaya ang preno ay, sa katunayan, kung kinakailangan. Ngunit isang takeaway dito ay, kapag may pagdududa, subukan ang isang bagay. Siguro i-save ang iyong code una, o i-save ito sa extrang file kung ikaw ay talagang nag-aalala tungkol messing up at pagkakaroon upang mabawi ang gawain na alam mo ay gumagana. 

Ngunit subukan ang mga bagay. At huwag maging kasing takot, marahil, ng kung ano ang computer ay maaaring gawin, o na maaari mong lumalabag sa isang bagay. Maaari mong palaging bumalik sa ilang mga mas naunang bersyon. 

Kaya sabihin tapusin sa pamamagitan ng pagtingin sa disenyo ng code. Mayroon kaming kakayahan na ito ngayon upang isulat kondisyon, at write loops, at mga variable, at mga function na tawag. Kaya, lantaran, hindi namin uri ng bumalik sa kung saan kami ay sa isang linggo na ang nakakaraan sa simula, kahit na may isang mas nakakahimok tekstuwal kapaligiran kaysa Scratch nagbibigay-daan. 

Ngunit mapansin kung gaano kabilis namin nakuha na bokabularyo, kahit na ito ay pagpunta sa tumagal ng ilang sandali upang lababo in, upang maaari naming ngayong gamitin ang bokabularyo na magsulat mas kawili-wiling programa. At ipaalam sa tumagal ng isang sanggol na hakbang papunta na, tulad ng mga sumusunod. Hayaan akong sige at lumikha ng isang bagong file dito. 

Ako pagpunta sa tumawag ito prototype.c, at ipakilala sa unang pagkakataon, ang kakayahan gumawa ng iyong sariling mga pag-andar. Ang ilan sa iyo ay maaaring magkaroon ng tapos na ito sa simula, na kung saan maaari kang lumikha ng iyong sariling pasadyang mga bloke sa simula, at pagkatapos ay i-drag ito sa lugar saan man gusto mo sa C. At sa karamihan ng programming wika, maaari mong gawin eksakto na- gumawa ng iyong sariling mga pag-andar, kung sila ay hindi na umiiral. 

Kaya, halimbawa, ipaalam sa akin sige at isama CS50.h, at isama ang karaniwang io.h, int pangunahing walang bisa. At ngayon kami ay may isang placeholder handa na pumunta. Panatilihin ko ang pag-print ng mga bagay tulad ng mga pangalan ng mga tao ngayon. At na nararamdaman like-- hindi magiging maganda kung mayroong ay isang function na tinatawag na print pangalan? Hindi ko na kailangang gumamit ng printf. Hindi ko kailangang tandaan ang lahat ng mga format codes. Bakit hindi ako, o kung bakit ay hindi isang tao sa harap ko, lumikha ng isang function na tinatawag na print pangalan, na ibinigay ng ilang mga pangalan, simpleng mga Kopya ito out? 

Sa ibang salita, kung ang sinasabi ko, hey, computer, bigyan ako ng isang string sa pamamagitan ng pagtatanong sa gumagamit para sa tulad, sa pamamagitan ng get string function CS50. Hey, computer, ilagay na string sa ang mga variable sa kaliwang bahagi, at tumawag ito s. At pagkatapos ay, hey computer, sige at i-print na pangalan ng tao, tapos na. 

Ngayon, ito ay magiging nice, dahil ang program na ito, aptly pinangalanan, ay nagsasabi sa akin kung ano ang dapat na gawin sa pamamagitan ng paraan ng mga pangalan ng mga function. Hayaan akong pumunta at gumawa prototype, ang Enter. At, sa kasamaang palad, ito ay hindi pagpunta sa lumipad. 

Prototype.c, linya 7, karakter 5, error, implicit deklarasyon ng pangalan ng function print ay di-wastong sa C99, C99 ibig sabihin ay isang bersyon ng C na dumating out sa 1999. Iyon lang. 

Kaya hindi ko alam kung ano ang lahat ng ito ay nangangahulugan pa. Ngunit ko makilala error sa pula. Iyan ay medyo halata. 

At ito tila na may ang berdeng karakter dito, ang isyu ay may pangalan print, open paren s, malapit paren, semi-colon. Ngunit implicit deklarasyon ng function na namin nakita sa madaling sabi mas maaga. Ang ibig sabihin nito, kailangan lang, na Clang hindi alam kung ano ang ibig sabihin ko. 

Ginamit ko ang isang bokabularyo salita na ito ay hindi kailanman nakita o na-itinuro bago. At kaya kailangan ko upang magturo ito ano ang function na ito ay nangangahulugan. Kaya ako pagpunta sa sige at gawin iyon. 

Ako pagpunta sa sige at ipatupad ang aking sariling mga function na tinatawag na Print Name. At ako pagpunta sa sabihin, ang mga sumusunod, na ginagawa nito ito, printf, hello, porsiyento s, backslash n, pangalan, semi-colon. Kaya kung ano ang sinabi ko na lang gawin? 

Kaya ito ay lumiliko out, upang ipatupad ang iyong sariling function, namin uri ng hiramin ang ilan sa ang parehong istraktura bilang pangunahing na lamang kami ay kinuha para sa ipinagkaloob, at ako malaman lamang pagkopya at pag-paste medyo marami kung ano Gumagamit ako ng pagsulat sa nakaraan. Ngunit mapansin ang pattern dito. Int, Main, Void, kami manunudyo bukod bago mahaba kung ano na ang tunay na ibig sabihin. 

Ngunit para sa ngayon, lamang mapansin ang paralelismo. Void, print pangalan, string pangalan, kaya may isang purple keyword, na kung saan kami ay pagpunta upang simulan ang pagtawag ng isang uri ng bumalik, ang pangalan ng ang function, at pagkatapos ay ang input. Kaya, talaga, maaari naming magdistila ito uri ng tulad noong nakaraang linggo bilang, ito ay ang pangalan o ang algorithm ng code kami pagpunta sa write-- ang algorithm pinagbabatayan ang code kami ay pagpunta sa magsulat. 

Ito ang input nito. Ito ang output nito. Function na ito, i-print na pangalan, ay dinisenyo upang tumagal ng isang string na tinatawag na pangalan, o ano pa man, tulad ng input, at pagkatapos ay walang bisa. ito ay hindi bumalik anumang bagay, tulad ng makakuha string o makakuha int ginagawa. Kaya ito ay pagpunta sa ipasa akin ng isang bagay likod. Lamang Ito ay pagpunta sa magkaroon ng isang side effect, kaya na magsalita, ng pag-print pangalan ng isang tao. Kaya mapansin, linya 7, ako maaaring tumawag name print. Line 10, ang maaari kong tukuyin o ipatupad name print. Ngunit, sa kasamaang-palad, hindi iyon sapat. 

Hayaan akong sige at recompile ito pagkatapos i-save. Whoa, ngayon, ginawa ko ito mas masahol pa, ito ay tila. Kaya implicit deklarasyon ng function na print pangalan ko ay hindi wasto. At, muli, may higit pang mga error. Ngunit bilang ako cautioned mas maaga, kahit kung ikaw ay makakuha ng bumagsak sa, o isang maliit na malungkot upang makita kaya maraming error, tumutok lamang sa ang unang una, dahil maaaring ito lamang ay nagkaroon ng isang cascading epekto. Kaya C, o Clang higit na partikular, pa rin ay hindi kilala ng pangalan print. 

At iyon ay dahil Clang, sa pamamagitan ng disenyo, ay uri ng pipi. Ginagawa lamang kung ano ang iyong sabihin sa ito upang gawin. At ginagawa nito lamang kaya sa pagkakasunud-sunod kung saan sabihin mo ito gawin. 

Kaya ako ay may tinukoy na pangunahing sa apat na linya, tulad namin ang paggawa medyo madalas. Ko na tinukoy na pangalan print on line 10. Ngunit ako sinusubukan mong gamitin print na pangalan mo sa pitong linya. 

Ito ay masyadong lalong madaling panahon, ay hindi pa umiiral. Pagayon ako ay maging matalino, at maging tulad ng, OK, kaya sabihin lamang i-play kasama, at ilipat name print up dito, at muling sumulat ng libro. Oh aking Dios. Gumana ito. Ito ay bilang simpleng bilang na. 

Ngunit ang lohika ay eksakto na. Mayroon kang upang magturo Clang kung ano ito ay sa pamamagitan ng pagtukoy sa mga function na muna. Pagkatapos ay maaari mong gamitin ito. Ngunit, nang tapat, ito nararamdaman tulad ng isang madulas libis. 

Kaya sa bawat oras na patakbuhin ko sa isang problema, ako lang pagpunta upang i-highlight at kopyahin ang code Ako wrote, i-cut ito at i-paste ito dito. At, tiyak, maaari namin balakin ilang mga pangyayari kung saan ang isa function na maaaring kailangang tumawag sa isa pa. At ikaw lamang ay hindi maaaring ilagay ang bawat function na lalo sa lahat ng iba pang mga. 

Kaya ito ay lumiliko out doon ni isang mas mahusay na solusyon. Maaari naming mag-iwan ito maging. At, lantaran, ito ay sa pangkalahatan nice, at maginhawa, at mahusay na disenyo upang ilagay main una, dahil, muli, main tulad ng kapag berde bandila click, iyon ay ang pag-andar na ay naisakatuparan sa pamamagitan ng default. Kaya maaari mong pati na rin ilagay ito sa tuktok ng file kaya na kapag ikaw o anumang iba pang mga tao ay tumitingin sa file alam mo kung ano ang nangyayari sa pamamagitan lamang ng pagbabasa main muna. Kaya ito ay lumiliko out, maaari naming sabihin sa Clang proactively, hey, Clang, sa apat na linya, pangako ko na ipatupad isang function na tinatawag Print Pangalan na tumatagal ng isang string na tinatawag na pangalan bilang input, at babalik sa wala, walang bisa. At kukunin ko na makakuha ng paligid sa pagpapatupad ng mga ito sa ibang pagkakataon. 

Dito lumapit Main. Main ngayon sa linya 9 ay maaaring gumamit ng Print Name dahil Clang nagtitiwala na, sa huli, ito ay nakatagpo ang kahulugan ng pagpapatupad ng Print Name. Kaya pagkatapos i-save ang aking file, sabihin mo akong magpatuloy at gumawa prototype, asta mabuti oras na ito. Dot iwa, prototype, hayaan mo akong sige, at i-type sa isang pangalan. David, hello David, Zamila, hello Zamila, at, sa katunayan, ngayon ito gumagana. 

Kaya ang sahog dito ay na hindi namin ginawa ng isang pasadyang function, tulad ng isang custom Scratch block kami ay pagtawag ito. Ngunit hindi tulad ng scratch kung saan maaari mong lamang lumikha ng ito at simulan ang paggamit nito, ngayon kami ay may na maging isang kaunti pa pilosopo, at talagang sanayin Clang gamitin, o upang asahan ito. Ngayon, bilang isang bukod, kung bakit ang lahat ng oras na ito ay may kami ay lamang nang walang taros sa pananampalataya kasama CS50.h, at kabilang ang standard io.h? 

Well, ito ay lumiliko out, bukod sa ilang iba pang mga bagay na ito, lahat na nasa mga tuldok h file, na mangyari upang maging mga file. Ang mga ito ay header file, kaya na magsalita. Pa rin nila ay nakasulat sa C. Ngunit ang mga ito ay isang iba't ibang mga uri ng file. 

Sa ngayon, maaari mong medyo marami ipalagay na ang lahat na sa loob ng CS50.h ilang one-liners tulad nito, hindi para sa mga function na tinatawag na Print Name, ngunit para sa Kumuha ng String, Kumuha Float, at ng ilang mga iba. At may mga katulad na mga modelo, isa liners, sa loob ng mga standard io.h para printf, na ngayon ay sa aking sariling Print Pangalan function. Kaya sa ibang salita, ito buong oras na namin lamang ay walang taros pagkopya at pag-paste isama ito, isama na, kung ano kaya ang nangyari? Ang mga ay lamang ang uri ng mga pahiwatig upang Clang bilang sa kung ano ang function ay, sa katunayan, ipinatupad, lamang sa ibang lugar sa iba't ibang mga file sa ibang lugar sa sistema. 

Kaya ipinatupad namin ang pangalan print. Mayroon itong mga ito pangalawang epekto ng pag-print ng isang bagay sa screen. Ngunit ito ay hindi aktwal na kamay sa akin ng isang bagay likod. Paano namin pumunta tungkol sa pagpapatupad ng isang programa na ay kamay sa akin ng isang bagay sa likod? 

Well, sabihin subukan ito. Hayaan akong magpatuloy at ipatupad isang file na tinatawag return.c upang maaari naming ipakita kung paano ang isang bagay tulad Kumuha ng String, o Kumuha Int, ay talagang bumabalik isang bagay na bumalik sa user. Sabihin sige at tukuyin int pangunahing walang bisa. 

At, muli, sa hinaharap, kami ay ipaliwanag kung ano na int at na walang bisa ay aktwal na paggawa. Ngunit para sa ngayon, kami ay dalhin ito para sa ipinagkaloob. Ako pagpunta sa sige at printf, para sa isang mahusay na karanasan ng user, x ay. At pagkatapos ay ako pagpunta sa maghintay para sa mga user upang bigyan ako ng x na may get int. 

At pagkatapos ay ako pagpunta sa sige at i-print out x sa parisukat. Kaya kapag mayroon ka lamang ng keyboard, ang mga tao na karaniwang gamitin ang maliit na karot simbolo sa keyboard upang kumatawan sa kapangyarihan ng, o ang exponent ng. Kaya x squared ay naroroon i. 

At ngayon ako pagpunta sa gawin ito. hindi ko na lang do-- kung ano ang x squared? x squared ay x beses x. 

At ginawa namin ito ng ilang panahon ang nakalipas na araw na ito. Na ito ay hindi pakiramdam tulad ng lahat na marami progreso. Alam mo ba? ni pakikinabangan ang ilan sa na ideya Hayaan mula sa huling oras ng abstraction. 

Hindi ba ito ay nice kung mayroong isang function na tinatawag na square na gumagana nang eksakto na? Ito pa rin, sa dulo ng araw, ay ang mga parehong matematika. Ngunit sabihin abstract layo ang ideya ng pagkuha isang numero multiplied sa pamamagitan ng isa pa, at lang bigyan ito ng isang pangalan, tulad parisukat ang halagang ito. 

At, sa ibang salita, sa C, sabihin lumikha ng isang function tinatawag square na ginagawa eksakto na. Ito ay pagpunta sa ay tinatawag na square. Ito ay pagpunta sa tumagal ng isang int. At bibigyan namin ay lamang tumawag ito n, sa pamamagitan ng default. 

Ngunit maaari naming tumawag ito anumang nais namin. At ang lahat ng ito ay pagpunta sa gawin, literal, ay bumalik ang resulta ng n beses n. Ngunit dahil ito ay bumabalik ang isang bagay, na kung saan ay ang mga keyword sa purple na namin hindi kailanman nakita bago, ako, on line 11, ay hindi maaaring lamang sabihin walang bisa oras na ito. 

Void, sa halimbawa lang namin nakita sa halip ng pangalan print, lamang ay nangangahulugan, gumawa ng paraan. Ngunit huwag mag-kamay sa akin ng isang bagay likod. Sa kasong ito, ang gusto ko upang bumalik n beses n, o ano pa man iyon ay, ang numerong iyon. 

Kaya hindi ko maaaring sabihin, hey, computer, bumalik ako sa wala, walang bisa. Ito ay pagpunta upang bumalik, sa pamamagitan ng likas na katangian, isang int. At sa gayon ay ang lahat na ang nangyayari sa dito. 

input Ang sa parisukat ay pagpunta sa maging isang int. At sa gayon ay maaari naming gamitin ito, ito ay upang magkaroon ng isang pangalan, N. Ito ay pagpunta sa output isang int na hindi kailangan ng isang pangalan. Maaari naming iwanan ito sa main, o sino man ay gamit sa akin na tandaan ang halaga na ito kung kami gusto may sariling variable. 

At, muli, ang tanging bagong keyword dito ay Return. At ako lamang ang paggawa ng ilang mga matematika. Kung ako talagang nais na maging hindi kinakailangan, kaya kong sabihin int produkto ay makakakuha ng n beses n. 

At pagkatapos ay maaari kong sabihin, bumalik produkto. Ngunit, muli, upang ang aking punto ng mas maaga ito hindi lamang mabuting design-- tulad ng, kung bakit kitang ipakilala ang isang pangalan, isang simbolo, tulad ng produkto, lamang upang agad na ibalik ito? Ito ay isang maliit na mas malinis, isang maliit na tighter, kaya na magsalita, just to say return n beses n, kumuha alisan ng linya na ito nang sama-sama. 

At ito ay lamang ng mas mababa code na basahin, mababawasan ang posibilidad ng mga pagkakamali. At sabihin makita kung ito talagang gumagana ngayon. Ngayon, ako pagpunta sa pumunta magpatuloy at gumawa ng return. 

Uh-oh, implicit deklarasyon ng function. Ginawa ko ang pagkakamaling ito bago, hindi sang-ayon. Hayaan akong i-type lamang, o i-highlight at kopyahin, ang eksaktong parehong function prototype, o lagda, ng pag-andar up dito. O maaari ko bang ilipat ang buong function. 

Ngunit iyon lamang ang isang maliit na tamad. Kaya hindi namin ay gawin na. Ngayon, hayaan mo akong gumawa return muli, dot slash return. 

x ay 2. x squared ay 4. x ay 3. x squared ay 9. At ang pag-andar ay tila ngayon na nagtatrabaho. Kaya kung ano ang pagkakaiba dito? Mayroon akong isang function na tinatawag na parisukat, sa kasong ito, na aking ilagay sa isang input. At kumuha ako ng likod ng isang output. At gayon pa man, dati, kung binuksan ko ang iba pang mga halimbawa mula sa mas maaga, na kung saan ay tinatawag prototype.c, Ako ay nagkaroon ng pangalan print, na kung saan bumalik walang bisa, kaya na magsalita, O ito ay bumalik sa wala, at lamang ay nagkaroon ng isang epekto. 

Kaya kung ano ang nangyayari sa dito? Well, isaalang-alang ang pag-andar makakuha ng string para sa sandali lamang. Kami ay gumagamit ng ang pag-andar makakuha ng string sa mga sumusunod na paraan. 

Tumanggap kami ng isang function makakuha string, tulad isama CS50.h, ng pamantayang io.h, int, pangunahing, walang bisa. At pagkatapos ay sa bawat oras na ako tinatawag get string kaya sa ngayon, Ko na sinabi ng isang bagay tulad ng, string s makakakuha makakuha ng string, dahil get string sabihin tumawag sa ito get.c-- get string mismo ay nagbabalik ng isang string na maaari kong pagkatapos ay gamitin, at inyong sabihin, hello, kuwit, porsiyento s, backslash n, s. 

Kaya ito ay ang parehong halimbawa, talaga, isa na hindi nabusog mas maaga. Kaya makakuha ng string ay nagbabalik ng isang halaga. Ngunit isang sandali ang nakalipas, print string hindi nagbabalik ng isang halaga. Ito lamang ay may side effect. Kaya ito ay isang pangunahing pagkakaiba. Nakita namin ang iba't ibang uri ng mga function ngayon, ilan sa kung saan ay may ibabalik mga halaga, ang ilan ay hindi. Kaya marahil ito ay string, o int, o float. O siguro ito lang ang walang bisa. 

At ang pagkakaiba ay na ang mga function na kumuha ng data at ibalik ang halaga ng isang ay aktwal na nagdadala ng isang bagay pabalik sa table, kaya na magsalita. Kaya sabihin sige at tumingin sa isang pangwakas na set ng mga halimbawa na nagbibigay ng isang pakiramdam, ngayon, ng kung paano namin, sa katunayan, abstract mas mahusay, at mas mahusay, at mas mahusay, o higit pa, at higit pa, at higit pa, upang na magsulat, sa huli, mas mahusay na code. Sabihin sige, at sa espiritu ng simula, gawin ang sumusunod. 

Hayaan akong sige at isama CS50.h at standard io.h. Hayaan akong sige at bigyan aking sarili ng isang int, pangunahing, walang bisa. At hayaan mo akong sige, tawag na ito cough.c. 

At ipaalam sa akin sige at lamang tulad Scratch, i-print out ubo / n. At gusto kong gawin ito ng tatlong beses. Kaya ako, siyempre, lamang ang pagpunta upang kopyahin at i-paste ng tatlong beses. ngayon ako pagpunta sa gumawa ng ubo dot slash ubo. Sabihin bigyan ang aking sarili ng kaunti pa kuwarto dito, ang Enter, ubo, ubo, ubo. 

Mayroong, malinaw naman, isa nang pagkakataon para sa pagpapabuti. Ko na kopyahin at ilagay ng ilang beses ngayon. Ngunit iyon ay lamang kaya ako ay hindi kailangang i-type ng maraming mga character. Ako pa rin ang nagbago ng ano mga linya ng code ay. 

Ang mga tatlong linya ay magkapareho, na nararamdaman tamad at sa katunayan ay, at ito ay marahil hindi ang tamang diskarte. Kaya kung anong sahog maaari naming mapabuti ang code na ito? Wala kaming upang kopyahin at i-paste ang code. 

At, sa katunayan, ang anumang oras sa tingin mo ang iyong sarili ng pagkopya at pag-paste, at hindi kahit na ang pagbabago ng code, logro ay may isang mas mahusay na paraan. At, sa katunayan, diyan ay. Hayaan akong magpatuloy at gawin ang isang para sa loop, kahit na ang syntax maaaring hindi dumating natural pa. 

Gawin ito ng tatlong beses, kailangan lang pamamagitan ng paggawa ng following-- at mangyayari kong malaman na ito mula sa pagsasanay. Ngunit kami ay may isang bilang ng mga halimbawa ngayon. At makikita mo ang online higit pang mga sanggunian pa rin. 

Ito ang syntax on line 6, na marami tulad Scratch na uulit block, ulitin ang mga sumusunod na tatlong beses. Ito ay isang maliit mahiwagang para sa ngayon. Ngunit ito ay makakakuha ng higit pa, at mas pamilyar. 

At ito ay pagpunta sa ulitin line walong tatlong beses, kaya na kung ako muling sumulat ng libro make ubo, dot slash ubo, ubo, ubo, ubo. Ito pa rin ay gumagana sa parehong paraan. Kaya na ang lahat ng fine at mabuti. Ngunit iyon lamang ang hindi masyadong abstracted. 

Ito ay ganap na tama. Ngunit ito nararamdaman tulad ng mayroong ay maaaring isang pagkakataon, bilang sa mundo ng Simula, sa uri ng start upang magdagdag ng ilang semantics dito kaya na Hindi ko na lang ay ang ilang para sa loop, at isang function na nagsasabing ubo, o ay ubo. Alam mo ba? Hayaan akong subukan na maging isang maliit na palamigan kaysa sa na, at talagang magsulat ng isang function na ay may ilang mga epekto, tumawag ito ubo. 

At ito ay tumatagal ng walang input, at nagbabalik walang halaga bilang output. Pero alam mo kung ano ang ginagawa nito? Ginagawa this-- printf, quote magpanipi, ubo. 

At ngayon dito, pupuntahan ko sige at para int, i makakakuha ng zero, i mas mababa sa 3, i plus plus. Pupunta ako upang hindi gawin printf, na kung saan ay arguably isang mababang antas ng pagpapatupad detalye. Wala akong pakialam kung paano sa pag-ubo. Gusto ko lang gamitin ang ubo function. At ako lamang ang pagpunta sa tumawag ubo. 

Ngayon, pansinin ang paghihiwalay sa dalawang bahagi. Kapag tumawag ka ng isang function, kung hindi mo gusto nais na bigyan ito inputs, lahat-lahat fine. gawin lamang bukas paren, malapit paren, at tapos ka na. 

Kapag mong tukuyin ang isang function, o Ipinahahayag prototype ng isang function, ang kung alam mo in advance na ito ay hindi pagpunta sa gumawa ng anumang mga argumento, sabihin walang bisa sa mga panaklong doon. At na gumagawa ng mga tiyak na kayo Hindi maa-sinasadyang maling paggamit nito. Hayaan akong sige at gumawa ubo. At, siyempre, ginawa ko ang isang pagkakamali. 

Dammit, may na implicit deklarasyon. Ngunit iyon lamang ang fine. Isa itong madaling ayusin. Kailangan ko lang ang prototype mas mataas na up sa aking file kaysa sa aktwal na gumagamit ako ng ito. 

Kaya ngayon hayaan mo akong gumawa ubo muli, nice. Ngayon, ito ay gumagana. Gumawa ubo, ubo, ubo, ubo. Kaya maaari mong isipin na kami ay talagang lamang sa paglipas ng engineering ang problemang ito. At, sa katunayan, hindi namin. Ito ay hindi isang magandang kandidato ng isang programa sa sandaling ito para sa refactoring, at paggawa ng kung ano ang tinatawag hierarchical agnas, kung saan ka kumuha ng ilang mga code, at pagkatapos ay mong uri ng kadahilanan ng mga bagay out, sa gayon ay idahilan pa semantika sa kanila, at muling gamitin ito sa huli mas mahaba term. Ngunit ito ay isang gusali block papunta mas sopistikadong mga programa na magsisimula kami pagsulat bago ang haba na ay nagbibigay-daan sa amin upang magkaroon ng bokabularyo na kung saan upang sumulat ng mas mahusay code. At, sa katunayan, sabihin makita kung kami ay hindi maaaring ipahayag nang masaklaw ito sa karagdagang. 

Tila isang maliit na pilay na ako, main, kailangang mag-alala tungkol darn ito para sa loop, at pagtawag ubo muli at muli. Bakit hindi ko na lang sabihin ubo, mangyaring ubo makaitlo? Sa ibang salita, kung bakit maaaring hindi ko na lang magbigay ng input sa pag-ubo at gawin ito? 

Bakit hindi ko na lang sabihin, sa main ubo tatlong beses. At ngayon, ito ay uri ng kahima-himala. Ito ay napaka-umuulit dito. At ito ay, sa katunayan, ang isang sanggol na hakbang. 

Ngunit lamang ng kakayahan upang sabihin sa line walo, ubo tatlong beses, ito ay lamang kaya marami pang iba nababasa. At, plus, hindi ko na kailangang malaman o pag-aalaga kung paano ubo ay ipinatupad. At, sa katunayan, sa huling bahagi ng term at para sa pangwakas na proyekto, kung matugunan mo ang isang proyekto na may isang kaklase o dalawang mga kaklase, makikita mo mapagtanto na ikaw ay pagpunta sa kung, o nais na, hatiin ang trabaho. 

At ikaw ay pagpunta sa nais upang magpasya nang maaga, kung sino ang pagpunta sa gawin kung ano ang, at sa kung aling mga piraso? At Gusto hindi ito gandang kung ikaw, halimbawa, mag-alaga sa pagsulat main, tapos na. At ang iyong mga kasama sa kuwarto, o ang iyong partner mas pangkalahatang paraan, ay siyang bahala sa pagpapatupad ubo. 

At ito division, ang mga ito pader ng abstraction, o layer ng abstraction kung Makikita ninyo, hindi kaya sobrang malakas, dahil lalo na para sa mas malaki, mas kumplikadong mga programa at mga sistema, ito ay nagpapahintulot sa maramihang mga tao na bumuo ng mga bagay-sama, at sa huli tahiin ang kanilang trabaho magkasama sa ganitong paraan. Ngunit, siyempre, kami kailangang ngayon ayusin ubo. Kailangan namin upang sabihin sa ubo na, hey, alam mo kung ano? Ikaw ay pagpunta sa kailangan upang kumuha ng isang input-- kaya hindi walang bunga, kundi int at ngayon. Sabihin sige at ilagay sa ubo ang int. i makakakuha ng zero. 

i ay mas mababa sa kung gaano karaming beses. sabi ko tatlong bago. Ngunit iyon ay hindi kung ano ang gusto ko. Gusto ko ubo na generalised sa suportahan ang anumang bilang ng mga iteration. 

Kaya, sa katunayan, ito ay n na gusto ko, kahit anong nagsasabi sa mga gumagamit sa akin. Ngayon, maaari ko sige at sabihin print ubo. At hindi mahalaga kung ano ang numero ang user ay pumasa sa, ako umulit na maraming beses. 

Kaya sa katapusan ng araw, programa ay magkapareho. Ngunit mapansin ang lahat ng ito bagay-bagay maaaring kahit na maging sa isa pang file. Sa katunayan, hindi ko alam kung sa sandali kung paano printf ay ipinatupad. 

Hindi ko alam kung sa sandaling ito kung paano makakuha ng string, o makakuha ng int, o makakuha ng float ay ipinatupad. At hindi ko nais na makita ang mga ito sa aking screen. Bilang ito ay, ako simula mag-focus sa aking mga programa, hindi ang mga pag-andar. 

At sa gayon, sa katunayan, sa lalong madaling mong simulan factoring code tulad nito out, maaari naming kahit na ilipat ubo sa isang hiwalay na file? Ibang tao ay maaaring ipatupad ito. At ikaw at ang iyong programa maging ang very beautiful, at tunay kawili-wili, arguably, talagang apat na line program doon. 

Kaya sabihin sige ngayon at gumawa ng isa pang pagbabago. Pansinin na ang aking prototype ay may upang baguhin up tuktok. Kaya hayaan mo akong ayusin na kaya Hindi ako makapag-yelled sa. 

Gumawa ubo, ako'y tatakbo ubo isang beses higit pa, pa rin ang paggawa ng parehong bagay. Ngunit ngayon, mapansin kami ay may isang sahog para sa isang pangwakas na bersyon. Alam mo ba? Hindi ko nais na lamang umubo, kinakailangan. Gusto kong magkaroon ng isang bagay na mas pangkalahatan. Kaya alam mo kung ano? Gusto kong gawin ito. Gusto kong magkaroon ng, magkano ang gusto Scratch ginagawa nito, isang sabihin block, ngunit hindi lamang sabihin ng isang bagay ng ilang bilang ng beses. Gusto ko ito upang sabihin ng isang napaka-tukoy na string. At, samakatuwid, ako ay hindi nais ito sa makatarungan sabihin ubo. Gusto ko ito upang sabihin ang anumang string ay lumipas in. 

Kaya mapansin, ako pangkalahatan ito kaya na ngayon say nararamdaman tulad ng isang mabuting pangalan para sa mga ito, tulad ng simula, tumatagal ng dalawang argumento, hindi katulad scratch. Ang isa ay isang string. Ang isa ay isang int. 

At maaari ko bang ilipat ang mga ito. Ko lang ang uri ng tulad ng ideya ng sabihin ang string una, at pagkatapos ay kung gaano karaming beses sa ibang pagkakataon. Void nangangahulugan ito pa rin ay hindi bumalik anumang bagay. Ito ay lamang visual na bahagi effects, tulad ng sa [? Jordan,?] isang pandiwang pangalawang epekto ng yelling. ginagawa pa rin ito ng isang bagay n beses, 0 hanggang sa, ngunit hindi katumbas ng n. Ang ibig sabihin nito n kabuuang beses. At pagkatapos lamang i-print out kahit na ano na string ay. Kaya talaga ako generalised ang linyang ito ng code. Kaya ngayon, paano ko ipatupad ang ubo function? 

ang maaari kong gawin walang bisa ubo. At maaari ko pa rin gawin sa kung paano maraming beses na gusto mong pag-ubo. Pero alam mo kung ano? Maaari ko ngayon tumikin sasabihin. 

maaari kong tumawag sa sabihin sa salita ubo, pagpasa sa n. At kung gusto ko na ring ipatupad, katuwaan lang, isang pagbahin function, maaari kong bumahing ilang bilang ng beses. At maaari kong panatilihin reusing n, dahil mapapansin na m sa kontekstong ito o saklaw ay umiiral lamang sa loob ng function. 

At n sa kontekstong ito lamang umiiral sa loob ng function na ito dito. Kaya makikita namin bumalik sa mga isyung ito ng saklaw. At dito, tingin lang ako pagpunta sa sabihin, Achoo, at pagkatapos n beses, semi-colon. 

At ngayon, kailangan ko lang upang humiram mga lagda function up dito. Kaya ubo ay tama. Void pagbahin ay tama ngayon. 

At ako pa rin kailangan lang sabihin. Kaya ako pagpunta sa sabihin, sabihin string s, int n, semi-colon. Kaya ko na over-engineered ang ano ba sa labas ng programang ito. 

At ito ay hindi palaging nangangahulugan na ito ay kung ano ang dapat mong gawin kapag sumusulat kahit na ang pinakasimpleng ng mga programa. Kumuha ng isang bagay na malinaw naman talagang simple, talagang maikli, at muling ipatupad ito gamit paraan ng masyadong maraming code. Ngunit makikita mo aktwal na makita, at sa oras na tumingin pabalik sa mga halimbawang ito, at mapagtanto, oh, ang mga ay ang mga hakbang kinuha namin upang aktwal na magbigay ng tuntuning panlahat, sa kadahilanan ng isang bagay out, hanggang sa dulo ng araw ang aking code ay aktwal na medyo makatwirang. Dahil kung gusto kong ubo tatlong beses pagkatapos bumahing ng tatlong beses, lamang ako ng pagpunta sa muling palabas ng pelikula na ito, program gumawa ubo, at magpatakbo ng ubo. At Mayroon akong tatlong coughs at tatlong bumahin. 

At kaya ito ay isang basic tularan, kung ikaw ay, para sa kung paano namin maaaring pumunta tungkol sa aktwal na pagpapatupad ng isang programa. Ngunit sabihin lamang makita ngayon kung ano ito ay ng paggawa namin ang lahat ng oras na ito, at kung ano ang ilan sa mga huling piraso ay sa likod na ito simpleng command. Sa katapusan ng araw, na namin ay gumagamit Clang bilang aming tagatala. Kami ay sumusulat pinagmulan code, pag-convert ito sa pamamagitan Clang sa machine code. 

At hindi namin ginagamit Gumawa lang upang mapabilis ang aming keystrokes kaya na hindi namin kailangang tandaan mga incantations ng Clang mismo. Ngunit kung ano ang gumawa ng aktwal na paggawa? At ang kapalit, kung ano ang Clang aktwal na paggawa? 

Ito ay lumiliko out; sapagka't kami ay pinasimple discussion ngayon sa pamamagitan ng sinasabi, mong gawin source code, pumasa ito sa lalong input sa isang compiler, na kung saan ay nagbibigay sa iyo output ng machine code, lumiliko out doon ni ng ilang iba't ibang mga hakbang sa loob doon. At compiling mangyayari sa maging ang umbrella term para sa isang buo paglangkay-langkayin ng mga hakbang. Ngunit sabihin lamang mambiro this out talagang mabilis. 

Ito ay lumiliko out na kami ay na-paggawa higit pang mga bagay sa bawat oras na tumakbo ako ng isang programa, o sa tuwing ako ay sumulat ng libro ng isang programa ngayon. Kaya preprocessing ay tumutukoy sa this-- anumang bagay sa isang C programa, dahil kakailanganin namin makita muli at muli, na nagsisimula sa ang simbolong hash, o ang hashtag simbolo dito, nangangahulugan ito ay isang preprocessor direktiba. Ito ay nangangahulugan na, sa kasong ito, hey computer, gawin ang isang bagay sa file na ito bago ka talagang ilista ang aking sariling code. 

Sa kasong ito, hash isama ay, mahalagang, ni C paraan ng sinasabi, hey computer, pumunta makakuha ng ang mga nilalaman ng CS50.h at i-paste ang mga ito dito. Hey computer, pumunta makuha ang mga nilalaman ng standard io.h, kung saan man na nasa hard drive, i-paste ito dito. Kaya ang mga bagay na mangyayari unang panahon preprocessing. 

At Clang ang lahat ng ito para sa amin. At ito ay hindi ito kaya darn mabilis, hindi mo kahit makita ang apat na natatanging mga bagay na nangyayari. Ngunit iyon ang unang tulad hakbang. 

Ano talaga ang mangyayari susunod? Well, ang susunod na opisyal hakbang ay pag-ipon. At ito ay lumiliko out na ipon ng isang programa technically nangangahulugan ng pagpunta mula sa source code, mga bagay-bagay na namin ay sumusulat ngayon, sa isang bagay tinatawag assembly code, isang bagay na mukhang isang maliit na naiiba. 

At, sa katunayan, maaari naming makita na ito tunay na mabilis. Hayaan akong aktwal na pumunta sa aking IDE. Hayaan akong sige at buksan hello.c, na kung saan ay ang pinakaunang program na kung saan kami nagsimula ngayon. At hayaan mo akong magpatuloy at patakbuhin Clang isang maliit na naiiba, Clang-s, hello.c, na kung saan ay aktwal na pagpunta sa bigyan ako ng isa pang file hello.s. 

At marahil kami ay hindi kailanman muli makita ang ganitong uri ng code. Kung magdadala sa iyo ng isang mas mababang antas ng systems klase tulad CS61, makikita mo ang isang pulutong ng higit pa ng ganitong uri ng code. Ngunit ito ay pagtitipon ng wika. Ito ang X86 pagpupulong wika na ang CPU na pinagbabatayan CS50 IDE talagang nauunawaan. 

At misteriyoso bilang ginagawa nito tumingin, ito ay isang bagay ang computer naiintindihan pretty mabuti. Sub q, ito ay isang ibawas. Mayroong mga paggalaw. 

May tumatawag ng mga function dito, x Oring, isang kilusan, isang add, isang pop, isang pagbabalik. Kaya mayroong ilang mga napaka mababang antas mga tagubilin na CPUs maunawaan na I alluded sa mas maaga. Iyon ay kung ano Intel Inside. 

May mga pattern ng zero at mga bago na map sa mga arcanely worded, ngunit medyo well-pinangalanan, mga tagubilin, kaya na magsalita. Iyon ay kung ano ang mangyayari kapag mong itala ang iyong code. Makakakuha ka ng assembly wika sa labas ng ito, na kung saan ay nangangahulugan na ang ikatlong hakbang ay upang mag-ipon na assembly code sa, sa huli, machine code-- zero at mga, hindi ang text na lang nakita namin ang isang sandali ang nakalipas. 

Kaya pre-processing ay na mahanap at palitan, at ng ilang iba pang mga bagay. Ipon tumatagal ng iyong pinagmulan code mula sa C, source code na sumulat kami ay nagsisampa upang assembly code na lang namin glanced sa. Assembling tumatagal na assembly code upang zeroes at mga bago na ang CPU talagang ay maunawaan sa dulo ng araw. At pag-uugnay ay ang huling hakbang na mangyayari para us-- muli, kaya mabilis ang ginagawa namin hindi kahit notice-- na nagsasabing, hey computer, gawin ang lahat ng mga zero at mga bago na nagresulta mula ipon code ni David, at ang kanyang mga pangunahing pag-andar sa kasong ito. 

At hey computer, pumunta makakuha ng ang lahat ng mga zero at mga na ang CS50 kawani sinulat sa loob ng CS50 library. Paghaluin ang mga nasa may David. At hey computer, pumunta makakuha ng lahat ng mga zero at mga bago na ang ibang tao ay sumulat taon na nakalipas para sa printf. At magdagdag ng mga sa buong bagay, nang sa gayon ay hindi namin got ang aking mga zero at mga, ang zero CS50 kawani at mga bago, ang printf mga zero at mga bago, at anumang bagay na aming ginagamit. 

Lahat sila ay makakuha ng pinagsama-sama sa isang programa na tinatawag na, sa kasong ito, hello. Kaya simula ngayon, kami lang gamitin ang salitang ipon. At magsisikuha kami ng para sa ipinagkaloob na kapag sinasabi namin, sumulat ng libro ang iyong programa, ang ibig sabihin nito, hey gawin ang pre-processing, assembling, at pag-link. Ngunit mayroong talagang ilang makatas stuff nangyayari doon sa ilalim ng hood. At lalo na kung ikaw makakuha curious ilang oras, maaari mong simulan poking sa paligid sa ito mas mababang antas. Ngunit sa ngayon, mapagtanto na kabilang sa mga takeaways para sa araw ay lubos na lamang ang simula ng isang proseso, ng pagkuha ng komportable sa isang bagay tulad ng kumusta mundo. Sa katunayan, karamihan sa kung ano ang ginawa namin sa araw tiyak ay hindi lababo sa napakabilis na. At ito ay tumagal ng ilang mga oras, at ng ilang mga kasanayan. At logro ay, ikaw ay-uri-uriin ng nais na maabot ang iyong keyboard o sumigaw sa screen. At ang lahat ng iyan ay OK. Kahit na, marahil subukang huwag gawin ito sa library kaya magkano. 

At sa huli, makikita mo ay magagawang kahit na, upang simulan ang nakakakita ng pattern, parehong sa magandang code na iyong isinulat at sa mga pagkakamali na iyong ginawa. At marami na tulad ng proseso ng pagiging isang TF o isang CA ay tulad ng, ikaw ay magsisimulang upang makakuha ng mas mahusay at mas mahusay sa nakakakita ng mga pattern, at lamang paglutas ng iyong sariling mga problema sa huli. Sa habang panahon, magkakaroon ng maraming sa atin sa bang ipahiram mo ng suporta, at kumuha ka ng sa pamamagitan ng ito. At sa write-ups para sa lahat ng mga problema ikaw ay guided sa pamamagitan ng lahat ng mga utos na ako ay tiyak na alam mula sa isang pulutong ng mga pagsasanay sa pamamagitan ng ngayon, ngunit maaaring flown hindi kaya ng ulo para sa ngayon. At iyon ang lahat-lahat fine. 

Ngunit, sa huli, ikaw ay pagpunta upang simulan upang makita ang mga pattern lumitaw. At sa sandaling makuha mo nakalipas na ang lahat ng bobo mga detalye, tulad ng mga panaklong, at kulot tirante, at semi-colons, at ang mga bagay-bagay, lantaran, na ay hindi sa lahat intellectually kawili-wili. At ito ay hindi ang layunin ng pagkuha ng anumang pambungad klase. Ito ay ang mga ideya na ay pagpunta sa bagay na ito. 

Ito ay ang mga loop, at ang kondisyon, at ang pag-andar, at higit pa powerfully ang abstraction, at ang factoring ng code, at ang magandang disenyo, at ang mabuting estilo, at sa huli ang kawastuhan ng iyong code, na sa huli pagpunta sa mahalaga ang pinaka. Kaya sa susunod na linggo, kami ay kumuha ng mga mga ideya na namin unang nakita sa scratch at ngayon isinalin sa C. At magsisimula kami upang ipakilala ang unang ng tunay na mundo domain ni kurso. 

kami ay tumutok sa mundo ng seguridad, at higit na partikular cryptography, ang sining ng scrambling impormasyon. At kabilang sa mga unang problema mo ang iyong sarili ay makakakuha ng upang isulat lampas naglalaro sa ilan sa mga syntax at paglutas ng ilang mga lohikal na problema, sa huli bago mahaba, ay upang aktwal na mag-agawan, o i-encrypt, at sa huli i-decrypt impormasyon. At lahat ng bagay tapos na namin araw na ito, ay medyo mababa antas, ay lamang pagpunta upang payagan ang sa amin na kumuha ng isa, at isa, at isa pang hakbang sa itaas papunta sa pagsusulat ng mga pinaka-interesante code pa. 

Kaya higit pa sa na sa susunod na linggo. 

[Video playback] 

-Ano Ang maaari mong sabihin sa akin tungkol sa ang huling beses na nakita mo sa kanya? -Ano Ang maaari kong sabihin, talaga? Ibig kong sabihin, ito ay tulad ng anumang iba pang mga pre-production pag-eensayo, maliban nagkaroon ng isang bagay ay sinabi niya sa pinakadulo na natigil sa akin. 

-Ito Ay CS50. 

-Na Ay isang cut sa lahat, mahusay na trabaho sa pag-eensayo. 

lunch ni -Na? 

-Yeah, Ikaw at ako Maaari grab isang sandwich sa isang bit. Hayaan akong lamang debrief may David talagang mabilis. David? David? 

[END-playback] 