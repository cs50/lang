[MUSIK SPIELEN] DAVID J. MALAN: Okay, das ist CS50. Und dies ist ein Woche. So erinnern daran, dass das letzte Mal in der Woche null, Wir konzentrierten uns auf rechnerische Denken. Und wir transitioned aus, dass zu Scratch, eine grafische Programmier Sprache von unseren Freunden bei Media Lab des MIT. 

Und mit Scratch, haben wir erkunden Ideen wie Funktionen und Bedingungen, und Schleifen und Variablen und sogar Ereignisse und Themen und vieles mehr. Und heute werden wir zu weiterhin diese Ideen mit, und unter ihnen wirklich für sie gewährt, sondern übersetzen in eine andere Sprache als C. Jetzt bekannt, C ist eine traditionelle Sprache. Es ist ein niedrigeres Niveau Sprache, wenn man so will. 

Es ist rein textuellen. Und so auf den ersten Blick, ist es gehen zu schauen alle eher kryptischen wenn Sie noch nie programmiert haben. Wir gehen zu müssen, Semikolons und Klammern, und geschweiften Klammern und vieles mehr. Aber erkennen, dass selbst wenn die Syntax über ein wenig ungewohnt aussehen In den meisten von Ihnen, sehen vorbei, dass. Und versuchen, die Ideen zu sehen das sind zwar bekannt, weil hier in der ersten Woche was wir beginnen zu tun zu vergleichen ist, zunächst, Scratch gegen C. 

So zum Beispiel daran erinnern, dass, wenn wir das erste unserer Programme umgesetzt letzte Mal hatten wir einen Block, der aussah, ein wenig so etwas wie this-- wenn grüne Fahne geklickt haben, und dann hatten wir ein oder mehrere Puzzleteile darunter, in diesem Fall sagen, hallo Welt. Also, in der Tat, in Scratch, wenn ich auf diese grüne Fahne mein Programm laufen zu lassen, so zu sprechen, das sind die Blöcke, die ausgeführt werden sollen, oder laufen. Und speziell, Scratch sagte, hallo, Welt. 

Nun, ich hätte angegeben verschiedene Wörter hier. Aber wir werden sehen, dass in der Tat viele dieser blocks-- und in der Tat, in C können viele functions-- sein parametrisiert oder kundenspezifische verschiedene Dinge zu tun. In der Tat, in C, wenn wir konvertieren möchten, jetzt, Dieses Scratch-Programm auf diese andere Sprache, wir gehen ein zu schreiben wenig so etwas wie dieses. 

Zugegeben, es ist etwas ungewohnt Syntax es höchstwahrscheinlich, int, und Klammern und nichtig. Aber printf-- obwohl Sie würde nur denke, es wäre zu drucken. Aber ein Druckmittel Druck formatiert, wie wir bald sehen. Diese buchstäblich druckt auf dem Bildschirm unabhängig ist innerhalb dieser Klammern, die Natürlich ist in diesem Fall, hallo Welt. 

Aber Sie werden einige andere bemerken Syntax, einige doppelte Anführungszeichen, dass die Klammern am Ende, das Semikolon und dergleichen. Also gibt es ein wenig Overhead, so zu sprechen, sowohl kognitiv und syntaktisch, dass wir gehen zu haben, bevor lange zu erinnern. Aber klar, dass mit der Praxis Dies beginnt bei Ihnen zu springen. 

In der Tat, lassen Sie uns auf, dass ein Schwerpunkt Funktion specifically-- in diesem Fall sagen hallo Welt. So heißt die Funktion. Hallo Welt ist seine Parameter, oder Argument, seine Anpassung. 

Und die Gleichwertigkeit in C ist nur sein würde diese eine Zeile hier, wobei printf entspricht, sagen wir, die doppelte Anführungszeichen, hallo Welt entspricht, natürlich, zu dem, was es in den weißen Kasten ist. Und der Backslash n, wenn auch ein wenig seltsam abwesend und von Grund auf neu, einfach wird den Effekt haben wir werden sehen in einem Computer, wie mein Mac oder einem PC, nur bewegt sich die Cursor in die nächste Zeile. Es ist wie das Schlagen Geben Sie auf der Tastatur. 

Also werden wir das noch einmal vor langer sehen. Aber zunächst wollen wir in diesem einen Blick andere Beispiel im Falle von Schleifen. Wir hatten diese immer Schleife beim letzten Mal, das war eine Reihe von Puzzle-Stücke das tat etwas buchstäblich forever-- in diesem Fall sagen, hallo Welt, hallo Welt, Hallo Welt, hallo Welt. So ist es eine Endlosschleife von Entwurf. 

In C, wollen, wenn wir dies umsetzen gleiche Idee, wir könnten einfach das tun. Dies stimmt zwar, printf hallo world-- jetzt während nur semantisch, Art der die Idee zaubert tun etwas wieder und wieder, und wieder, und für wie lange? Nun, true-- Daran erinnern, dass wahr ist, nur auf oder ein. 

Und wahr ist, natürlich immer wahr. Also ist es ein bisschen eine sinnlose Aussage nur zu sagen, wahr. Aber in der Tat ist dies absichtlich, denn wenn sie wahr ist einfach immer wahr, als während wahr nur impliziert, wenn auch ein wenig indirekt, dass die folgenden Zeilen Code zwischen diesen geschweiften Klammern nur ausführen sollte wieder und wieder, und wieder, und nie wirklich zu stoppen. 

Aber wenn Sie möchten, dass Ihre Schleife zu stoppen, wie wir tat das letzte Mal mit so etwas wie dies, wiederholen Sie die folgenden 50-mal, in C können wir das gleiche tun, was mit ein für loop-- das Stichwort genannt Sein nicht während, sondern auch für. Und dann haben wir einige neue Syntax hier, i mit int gleich 0, i weniger als 50, i ++. Und wir werden darauf zurückkommen. Aber das einfach ist, wie würden wir den Satz von Scratch Blöcke übersetzen auf einen Satz von C Codezeilen. 

Inzwischen betrachten Variablen. Und in der Tat, wir haben nur Vor sah man einen Moment. Und im Fall von Scratch, wenn wir wollte eine Variable zu deklarieren, i genannt für i ganze Zahl ist, nur eine Nummer, und wir wollen, dass es auf einen Wert zu setzen, wir würden dieses Orange verwenden Block hier-- gesetzt i auf 0. 

Und wir werden sehen, heute und darüber hinaus, wie letzte Woche, Programmierer tun fast immer Start von Null zu zählen, wirklich vereinbarungs. Aber auch, weil der Rückruf aus unsere Diskussion von binären, die kleinste Zahl, die Sie können dar mit einer beliebigen Anzahl von Bits, wird nur 0 selbst zu sein. Und so werden wir in der Regel beginnen Initialisierung auch unsere Variablen auf 0. 

Und in C, das gleiche zu tun, wir gehen int zu sagen für integer, i nur durch Konvention. Ich hätte diese Variable mit dem Namen was ich will, genau wie in Scratch. Und dann gleich 0 nur Abtretungs der Wert 0 aus dem rechten und legt sie in die Variable oder das Lagerbehälter gibt, auf der linken Seite. Und das Semikolon als wir see-- und wir haben ein paar dieser bereits-- gesehen nur bedeutet Ende des Denkens. Gehen Sie etwas anderes zu tun auf den Linien, die folgen. 

Nun, was ist Booleschen Ausdrücken? Daran erinnern, dass in Scratch, diese waren Ausdrücke , die entweder wahr oder false-- Fragen, wirklich, die entweder wahr oder falsch sind. So im Fall von Scratch, könnten wir stellen eine einfache Frage wie diese, i kleiner als 50? So i, wieder eine ganze Zahl ist. Vielleicht verwenden wir es in einem Scratch-Programm Spur einer Partitur zu halten oder etwas ähnliches. Also diese Syntax hier in Scratch bedeutet nur, i kleiner als 50? Nun, zum Glück, ist etwas in C. einfach und zu übersetzen, dies würden wir einfach sagen, dass ich weniger als 50, über den bekannten Schlüssel auf Ihrer Tastatur. 

Inzwischen wollte, wenn Sie sagen etwas allgemeiner, wie, na ja, ist x kleiner als y ist, wobei jeder von x und y sind Variablen selbst? Wir können das gleiche tun, in C, so lange, wie wir haben diese Variablen bereits erstellt. Und wir werden sehen, wie man tun, dass vor langer. Wir würden einfach sagen, x kleiner als y. 

Also Sie beginnen zu sehen einige Ähnlichkeiten. Und die Leute, die aus Scratch waren sicher von einigen dieser grundlegenden Ideen inspiriert. Und Sie werden sehen, diese Art von Syntax in vielen languages-- Kratzt nicht nur, nicht nur C, aber Python, und JavaScript, und andere Sprachen noch. 

Nehmen wir ein anderes Konstrukt betrachten von C, der Begriff einer Bedingung, tun bedingt etwas. Wenn etwas wahr ist, dies zu tun. Wenn etwas anderes wahr ist, tun. Es ist eine Art der Programmierung Äquivalent einer Gabel in der Straße. Vielleicht ist es ein Zwei-Wege-Gabel, ein Dreiwegegabel oder mehr. Und in Scratch, könnten wir haben so etwas wie dieses gesehen. 

So ist dieses ein großes. Aber betrachten Sie die relative Einfachheit der Logik. Wenn x kleiner als y ist, dann sagen x weniger als y, else if x größer als y ist, dann sagen x größer als y ist. Und dann logisch, wenn Sie denken Sie zurück an Scratch oder einfach nur deine eigene menschliche Intuition, gut, wenn x nicht größer als y, und x nicht kleiner ist als y, dann natürlich x wird gleich y sein. Also in diesem Fall, durch Verschachtelung diese Scratch Blöcke, können wir eine drei erreichen Weg Gabel in der Straße? 

Inzwischen, wenn wir wollen tun, dass in C, es wohl sieht ein wenig simpler-- zumindest sobald Sie mit der Syntax vertraut machen. Wenn x kleiner als y, printf x kleiner ist als y. Sonst, wenn x größer ist als y, printf x größer ist als y. Else printf x gleich Y- und, mit denen Backslash wieder, endet kurz für die neuen Linien, so dass, wenn Sie tatsächlich lief diese Art von Programm es wäre einfach bewegen Ihr Cursor schließlich in die nächste Zeile des Bildschirms. 

Nun, mittlerweile Scratch hatte andere nur anspruchsvollere Funktionen, von denen einige wir werden bewegen zunächst über die Welt von C. Und einer von ihnen war eine Liste in Scratch genannt. Und das war eine besondere Art der Variable, erlaubt Ihnen, mehrere Dinge zu speichern in sie Rücken an Rücken an Rücken an Rücken. 

In C, hat es nicht Listen, per se, sondern etwas, , die allgemeiner Arrays genannt, obwohl wir später kommen in diesem Semester wieder um den Blick auf etwas rief eine Liste, oder wirklich eine verknüpfte Liste. Aber jetzt, die nächste Äquivalent in C für uns wird etwas sein ein Array bezeichnet. Und eine Anordnung ist einfach ein spezielle Art von variablen das es Ihnen ermöglicht, Daten zu speichern Rücken an Rücken an Rücken, an Rücken. 

Und in der Tat, in Scratch, wenn wir wollten zugreifen das erste Element eines Arrays oder ein list-- und ich werde es nennen, Vereinbarungsgemäß argv, Argument Vektor, sondern mehr auf, dass vor langer. Wenn ich will, auf das erste Element zu erhalten von argv, in der Welt von Scratch Sie tun eigentlich typisch Start von 1 zu zählen. 

Und so könnte ich Artikel 1 von argv bekommen. Das ist nur, wie MIT umgesetzt der Begriff der Listen. Aber in C, ich werde mehr einfach nur sagen, argv, die wiederum ist der Name meiner list-- oder klar, ein Array sein. Und wenn ich will, die erste Elemente, ich werde eckigen Klammern zu verwenden, die Sie vielleicht nicht oft unter einer Tastatur verwendet. 

Aber 0 bedeutet nur, hol mich die erste. So gelegentlich und als Zeit vergeht, wir gehen zu beginnen, diese Dichotomien zu sehen zwischen Scratch und C, wobei Scratch verwendet ein. Wir in C verwenden 0 hier. Aber Sie werden schnell sehen, wenn Sie verstehen, die Fundamente jeder Sprache, dass diese Dinge beginnen umso mehr zu bekommen vertraut durch die Praxis und Praxis. 

Also schauen wir uns eigentlich jetzt in einem Programm. Hier ist der erste unserer C Quellcode für vollständige Programme. Und das Programm wir gehen zu bieten für die Prüfung ist derjenige, der ist gleichwertig zu diesem früheren Scratch Stück. 

Also hier haben wir, was wohl die einfachste C-Programm Sie können schreiben, dass tatsächlich etwas tut. Jetzt werden wir vorbei schauen, Denn jetzt hat enthalten, Standard io.h, und diese Winkel Klammern und int, und nichtig, und die geschweiften Klammern und dergleichen. 

Und lassen Sie uns gerade konzentrieren sich auf was zumindest intuitiv, könnte bereits bei Ihnen herausspringen. In der Tat, Haupt, das tue ich nicht wissen müssen, was das ist, aber ähnlich wie Scratch hatte, dass, wenn grüne Fahne geklickt Puzzleteil, so tut C als Programmiersprache haben einen Haupt Stück Code, wird standardmäßig ausgeführt. Und in der Tat, es wird buchstäblich Haupt genannt zu werden. 

So wichtigsten ist eine Funktion. Und es ist eine spezielle Funktion, die es gibt in C, dass, wenn Sie ein Programm ausführen, es ist Haupt, die durch laufen wird Standard. In der Welt der Scratch, es war in der Regel, wenn grüne Fahne geklickt haben, die standardmäßig ausgeführt wurde. 

Inzwischen haben wir schon gesehen, printf oder Druck formatiert, das ist wird eine Funktion sein, die mit kommt C, zusammen mit einer ganzen Reihe von anderen, dass von Zeit und Zeit um wieder zu tun, genau wie der Name schon sagt, drucken Sie etwas. Was wollen wir zu drucken? Nun, wir werden sehen, dass durch Einschließen Zeichen wie these-- Hallo Welt, Backslash n in doppelte Anführungszeichen, wir können printf genau sagen, was auf dem Bildschirm zu drucken. 

Aber um das zu tun dass wir leider brauchen etwas zu nehmen, die ist schon kryptisch für uns Menschen, aber zumindest ist es etwas readable-- scharf sind, standard io.h, int, Haupt, lücke, printf, die alle die magischen Beschwörungen wir sahen nur auf dem Bildschirm. Aber wir haben tatsächlich zu gehen noch mehr obskure. Wir müssen zuerst den Code zu übersetzen dass wir in den Maschinencode schreiben. Und erinnern aus der vergangenen Woche, dass die Maschinen, zumindest wissen die, die wir hier, erst am Ende des Tages verstehen Nullen und Einsen. 

Und mein Gott, wenn wir diese zu schreiben hatte Nullen und Einsen, um tatsächlich Programm, es wäre sehr, sehr schnell nehmen Sie den Spaß aus allem. Aber es stellt sich heraus, pro letzte Woche, daß diese Muster von Nullen und Einsen nur haben eine besondere Bedeutung. In bestimmten Zusammenhängen sie könnten Zahlen bedeuten. 

In einigen Kontexten könnten sie bedeuten Buchstaben oder Farben, oder eine beliebige Anzahl von anderen Abstraktionen dort auf. Aber so, wie Ihr Computer eine CPU, Central Processing Unit, oder das Gehirn innerhalb des Computers. Es ist in der Regel Intel nach innen, denn das ist, eines der größten Unternehmen das macht CPUs für Computer. 

Nun, Intel-CPUs und andere einfach im voraus entschieden dass bestimmte Muster von Nullen und diejenigen sind bestimmte Dinge bedeuten. Bestimmte Muster von Nullen und Einsen bedeuten wird, drucken Sie diese auf dem Bildschirm, oder fügen Sie diese beiden Zahlen, oder subtrahieren diese beiden Zahlen, oder dieses Stück von Daten bewegen sich von mein Speicher des Computers hier, oder eine beliebige Anzahl anderer sehr niedrigen Niveau, aber letztlich nützlich, Operationen. Aber, Gott sei Dank, wir Menschen nicht gehen brauchen diese Detailebene zu kennen. Tatsächlich gerade wie beim letzten Mal, wo wir abstrahiert wieder und wieder und wieder, Gebäude von einem sehr niedrigen Niveau Primitiven, wie Nullen und Einsen auf höherer Ebene Konzepte wie Zahlen und Buchstaben, und Farben, und vieles mehr, so können wir als Programmierer stehen auf den Schultern von andere, die vor uns gekommen sind, und Software verwenden, die andere Menschen, bevor us-- geschrieben nämlich Programme Compiler genannt. 

C ist eine Sprache, wird in der Regel kompiliert, was bedeutet, umgewandelt aus Quellcode in Maschinencode. Insbesondere, was das bedeutet wenn Sie, dass ich Ihre Quelle bekam Code, den Sie selbst schreiben, wie wir bald wird in nur einem Augenblick auf dem Bildschirm, und Sie wollen es zu konvertieren schließlich zur Maschine code-- diese Nullen und Einsen, dass nur Ihren Mac oder PC understands-- Sie haben eine erste bekam füttern diesen Quellcode in als Eingang mit einer speziellen Programm namens einen Compiler, der Ausgang von dem wir sehen werden ist Maschinencode. Und in der Tat, wir das letzte Mal gesprochen über, wirklich, am Ende des Tages, Probleme lösen. Sie haben Eingänge bekam. Und Sie haben Ausgänge bekam. Und Sie haben eine Art bekam der Algorithmus in der Mitte. 

Algorithmen können sicher sein, in Software implementiert ist, wie wir sahen, mit Pseudo-Code der letzten Woche und wie wir mit den tatsächlichen Code zu sehen diese Woche. Und so ein Compiler wirklich nur hat eine Reihe von Algorithmen innerhalb davon, die wissen, wie man die spezielle Schlüsselwörter konvertieren, wie Haupt- und printf, und andere, die wir gerade Säge in die Muster von Nullen und Diejenigen, die Intel im Inneren und anderen CPUs tatsächlich versteht. Also, wie machen wir das? Wo bekommen wir einen Compiler? 

Die meisten von uns haben hier einen Mac oder einen PC. Und Sie sind mit Mac OS oder Windows oder Linux oder Solaris, oder eine beliebige Anzahl anderer Betriebssysteme. Und in der Tat konnten wir gehen auf die Bahn und laden Sie eine Compiler für Ihren Mac oder PC für das jeweilige Betriebssystem. Aber wir würden alle auf sein verschiedene Seiten, sozusagen. Wir hätten leicht verschiedene Konfigurationen. Und es würde nicht alle die gleiche Arbeit. Und in der Tat, in diesen Tagen viele von uns nicht in Anspruch genommen Software, die nur auf unsere Laptops läuft. Stattdessen verwenden wir etwas wie ein Browser, ermöglicht es uns, für den Zugriff auf Web-basierte Anwendungen in der Cloud. Und noch in diesem Semester, wir werden genau das tun. Wir schreiben Anwendungen oder Software code-- nicht C, aber auch andere Sprachen wie Python und JavaScript--, die in der Cloud laufen. 

Und um das zu tun, werden wir uns während des Semesters tatsächlich eine Cloud-basierte verwenden Umwelt als CS50 IDE bekannt. Dies ist eine Web-basierte Programmierung Umwelt oder integrierte Entwicklungs Umwelt, IDE-, ist, dass oben auf einige gebaut Open-Source-Software 9 Wolke genannt. Und wir haben einige pädagogische gemacht Vereinfachungen es um bestimmte Funktionen verstecken die ersten Wochen, die wir nicht brauchen, nach dem Sie offenbaren sie und tun die meisten was Sie wollen mit der Umwelt. 

Und erlaubt es uns, auch zu vorinstallieren bestimmte Software. Dinge wie eine so genannte CS50 Bibliothek, die wir werden bald sehen, mit einigen bietet uns in C zusätzliche Funktionalität. Also, wenn Sie gehen, schließlich CS50.io, Sie werden sich einloggen gefragt, und wenn Sie das tun, und erstellen ein Konto kostenlos, Sie werden in der Lage sein, ein für den Zugriff auf Umgebung, die ganz so aussieht. 

Nun, dies ist im Standardmodus. Alles ist schön und hell auf dem Bildschirm. Viele von uns haben eine Gewohnheit, Arbeiten am CS50 Stück, das ist ziemlich spät in die Nacht. Und so könnten einige von Ihnen es vorziehen, schalten Sie ihn in den Nachtmodus, sozusagen. 

Aber letztlich, was du bist gehen, um zu sehen in CS50 IDE ist drei verschiedene areas-- ein Bereich auf der linken Seite, wo Ihre Dateien werden in der zu sein Wolke, ein Bereich auf der oberen rechten in dem der Code wird editierbar sein. Sie werden in der Lage zu öffnen einzelnen Registerkarten für jedes Programm dass Sie in diesem Semester schreiben innen dieser oberen rechten Ecke. Und dann die meisten arcanely, und doch kraftvoll, wird diese Sache auf die zu sein Boden als Terminal-Fenster bekannt. 

Dies ist eine alte Schule Command Line Interface, oder CLI, das erlaubt Sie solche Befehle auf der computer-- in diesem Fall der Computer in der cloud-- Dinge zu tun, wie Sie Ihren Code kompilieren von Quellcode in Maschinencode, laufen Ihre Programme, oder starten Sie Ihre Web-Server oder die Datenbank zugreifen zu können, und jede Anzahl von anderen Techniken dass wir schon bald zu verwenden beginnen. Aber um dorthin zu kommen, wir sind tatsächlich zu haben online zu gehen und zu spielen beginnen. Und um das zu tun, lassen Sie uns zuerst beginnen mit dem Haupt bastelt, und schreiben Sie den Hauptteil eines Programms. Und lassen Sie uns diese Funktion nutzen printf, die wir früher verwendet, einfach etwas zu sagen. 

Hier bin ich also schon innerhalb von CS50 IDE. Ich habe im Voraus angemeldet. Und ich abgeschirmt voll das Fenster. Und so, schließlich, Sie Auch in den kommenden Probleme folgen ähnliche Schritte, die liefert die Online-Dokumentation. So brauchen Sie nicht zu befürchten jede noch so kleine technische Schritt zu absorbieren dass ich heute hier. 

Aber Sie werden einen Bildschirm wie diese zu erhalten. Ich bin zufällig im Nachtmodus zu sein. Und Sie können alles aufhellen up in der Nacht-Modus zu deaktivieren. Und am Ende der Tag, Sie gehen zu sehen Diese drei Haupt areas-- der Datei Browser auf der linken Seite, die Code-Tabs bis oben, und das Terminal-Fenster am unteren Rand. 

Lassen Sie mich gehen Sie vor und mein erstes Programm schreiben. Ich werde präventiv zu gehen Sie zu Datei, Speichern und meine Datei als hello.c speichern. Tatsächlich durch Konvention, jedes Programm, wir schreiben, das ist in der Programmiersprache C geschrieben sollte etwas genannt werden Punkt c, durch Konvention. Also werde ich es zu nennen hello.c, weil Ich möchte nur sagen, hallo an die Welt. Jetzt werde ich vergrößern und klicken Sie auf Speichern. Und alles, was ich jetzt hier haben, ist eine Registerkarte in dem ich das Schreiben von Code beginnen. 

Das wird nicht kompilieren. Das bedeutet nichts. Und so, auch wenn ich umgewandelt dies zu Nullen und Einsen, die CPU ist zu haben, keine Idee, was los ist um. Aber wenn ich Zeilen schreiben, die passen mit conventions-- C Wesens C, wieder, language-- dies mit Syntax wie dies, printf hallo world-- und ich habe bekommen komfortabel mit tun dies im Laufe der Zeit. Also ich glaube nicht, dass ich gemacht Druckfehler. 

Aber immer zuerst der sehr wenn Sie dies tun, werden Sie. Und was ich vielleicht tun sehr auch nicht das erste Mal für Sie arbeiten. Und das ist völlig in Ordnung, weil Sie jetzt könnte nur eine ganze Menge Neuheit zu sehen, aber im Laufe der Zeit, wenn Sie vertraut mit diesem Umfeld und diese Sprache, und andere, Sie beginnen, Dinge zu sehen, dass entweder richtig oder falsch sind. 

Und das ist es, was die Lehre Stipendiaten und natürlich Assistenten bekommen im Laufe der Zeit so gut ist Fehler oder Fehler in Ihrem Code Spek. Aber ich behaupten, dass es in diesem Code sind keine Fehler. Deshalb möchte ich jetzt dieses Programm auszuführen. 

Jetzt auf meinem eigenen Mac oder PC, ich bin in die Gewohnheit der Doppelklick-Icons wenn ich will einige Programm auszuführen. Aber das ist nicht das Modell. In diesem Umfeld, das CS50 IDE ist. Wir verwenden ein Betriebs System namens Linux. Linux erinnert an eine andere Betriebssystem, das allgemein bekannt ist wie Unix. Und Linux ist vor allem bekannt für Eine Befehlszeilenumgebung, CLI mit. Nun, wir verwenden einen bestimmten Linux-Variante namens Ubuntu. Und Ubuntu ist einfach ein bestimmte Version von Linux. 

Aber diese in diesen Tagen Linux tatsächlich tun kommen mit grafischen Benutzeroberflächen. Und die, die wir passieren werden hier mit web-basiert ist. So könnte dies aussehen sogar ein wenig von etwas Sie selbst haben könnte gesehen oder in der Vergangenheit laufen. 

Also werde ich voran gehen jetzt und gehen Sie wie folgt. Ich habe diese Datei als hello.c gespeichert. Ich gehe voran gehen und Typ clanghello.c So Clang für die C-Sprache ist eine Compiler. Es ist vorinstalliert in CS50-IDE. Und Sie können absolut herunterladen und installieren diese auf Ihrem eigenen Mac oder PC. 

Aber noch einmal, Sie würden nicht alle haben die Vorkonfiguration für Sie erledigt. So jetzt bin ich nur Gehen clanghello.c zu laufen. Und bemerken jetzt diese Syntax hier wird schließlich nur erkennen, bedeutet, dass ich in ein bin Ordner oder Verzeichnis namens Workspace. Das Dollarzeichen ist nur Konvention nach Sinn, Ihre Befehle hier eingeben. 

Es ist, was eine Aufforderung genannt wird, nur durch Konvention ist Dollarzeichen. Und wenn ich vor jetzt gehen und klicken Sie auf Geben Sie scheint nichts passiert zu haben. Aber das ist eigentlich eine gute Sache. Je weniger das geschieht auf Ihr Bildschirm ist, desto wahrscheinlicher Ihr Code korrekt ist, zu sein zumindest syntaktisch. 

Also, wenn ich will, dies zu laufen Programm, was soll ich tun? Nun, es stellt sich heraus, dass die Standardnamen durch Konvention für Programme, wenn Sie eine nicht angeben Namen für das Programm nur a.out ist. Und dies zu Syntax, werden Sie erhalten mit vor langem vertraut. 

Dot Slash bedeutet nur, hey, CS50 IDE, führen Sie ein Programm namens a.out das ist in meinem aktuellen Verzeichnis. Das Punkt bedeutet das aktuelle Verzeichnis. Und wir werden sehen, was andere solche Sequenzen Zeichen bedeutet, es dauerte nicht lange. 

Also hier gehen wir, Enter, hallo Welt. Und Sie werden feststellen, dass das, was passiert ist? drucken Sie es hallo Nicht nur Welt. Es bewegte sich auch die Cursor in die nächste Zeile. 

Und warum war das? Was war der Code, den wir geschrieben haben vor dass dafür gesorgt, dass sich der Cursor würde gehen in der nächsten Zeile? Lustige Sache über ein Computer ist es nur geht zu tun, buchstäblich, was Sie sagen, es zu tun. 

Also, wenn Sie es sagen printf hallo, Komma, Leerzeichen, Welt, in der Nähe Zitat, Es ist buchstäblich nur gehen diese Zeichen zu drucken. Aber ich hatte dieses Sonderzeichen am Ende, Rückruf, Backslash n. Und das ist, was gewährleistet, dass der Charakter ging in die nächste Zeile des Bildschirms. 

In der Tat, lassen Sie mich gehen und zu tun. Lassen Sie mich gehen Sie vor und löschen diese. Jetzt bemerken, dass die oben auf meinem Bildschirm gibt es ein kleines rotes Licht in die Registerkarte anzeigt, hey, Sie haben sich für den nicht gespeichert. Also werde ich mit Kontrolle zu gehen voran S oder Befehl S, speichern Sie die Datei. Jetzt goes-- es ging für ein moment-- grün. Und jetzt ist es zurück zu wobei nur ein Schließen-Symbol. 

Wenn ich mich jetzt clanghello.c wieder, Geben Sie, Punkt slash, a.out, Enter, Sie werden sehen, dass es immer noch gearbeitet. Aber es ist wohl ein wenig fehlerhaft. Gerade jetzt, mein prompt-- Arbeitsplatz, und dann, dass Dollar-Zeichen, und dann meine eigentliche prompt-- ist um auf der gleichen Linie. So dies sicherlich eine ästhetische Fehler, auch wenn es nicht wirklich ein logischer Fehler. 

Also werde ich rückgängig zu machen, was ich gerade tat. Ich werde a.out erneut ausführen. Bemerke ich habe hinzugefügt, die Newline-Zeichen zurück. Ich habe die Datei gespeichert. 

So a.out erneut ausführen Ich werde, und- dammit, um einen Fehler, ein Fehler bedeutet Fehler. So ist der Fehler ist, dass, obwohl Ich habe den Backslash n gibt, Wieder gespeichert, wieder lief das Programm, Das Verhalten war das gleiche. Warum wäre das? 

Ich vermisse einen Schritt, nicht wahr? Das entscheidende Schritt war früher, dass Sie zu--, wenn Sie den Quellcode ändern, es stellt sich auch heraus laufen es durch den Compiler wieder, so dass Sie neue Maschinencode. Und der Maschinencode, die Nullen und Einsen, werden fast identisch sind, aber nicht perfekt, denn wir brauchen, natürlich, dass neue Zeile. 

Also, dies zu beheben, ich werde zu müssen erneut ausführen clanghello.c, geben, Punkt Slash, a.out. Und jetzt, hallo Welt ist zurück , wo ich es erwarten. Also das ist alles schön und gut. Aber a.out ist ein ziemlich dummer Name für ein Programm, obwohl es sein geschieht, aus historischen Gründen, die default-- Montage Ausgänge Bedeutung. 

Aber lassen Sie mich voran gehen hier und tun dies anders. Ich möchte, dass meine Hallo Welt Programm tatsächlich hallo aufgerufen werden. Also wenn es ein Icon auf meinem Desktop, es wäre nicht a.out werden. Es wäre hallo genannt werden. 

Also, dies zu tun, es stellt sich heraus, dass Clang, wie viele Programme, unterstützt die Befehlszeilenargumente, oder Fahnen oder Schalter, die beeinflussen einfach sein Verhalten. Insbesondere unterstützt Clang einen Strich o Flagge, die dann ein zweites Wort nimmt. In diesem Fall werde ich willkürlich, aber vernünftig, nennen Sie es hallo. Aber ich konnte es nennen alles Ich möchte, außer a.out, die eher würde neben den Punkt. 

Und dann geben Sie einfach den Namen der Datei will ich zu kompilieren. So, jetzt, auch wenn am Anfang des Befehls Ich habe noch Clang, am Ende des Befehls Ich habe immer noch den Dateinamen, Ich habe jetzt diese Befehlszeile Argumente, diese Flags, die sagen, oh, übrigens, Output-o, eine Datei hallo, nicht der Standard-a.out genannt. 

Also, wenn ich drücken Sie die Eingabetaste jetzt nichts geschehen scheint. Und doch jetzt kann ich hallo dot slash tun. So ist es das gleiche Programm. Die Nullen und Einsen sind am Ende des Tages identisch. 

Aber sie sind in zwei verschiedene files-- a.out, Das ist die erste Version und nur dummerweise den Namen, und jetzt hallo, das ist eine viel zwingender Name für ein Programm. Aber, ehrlich gesagt, bin ich nie geht dies zu erinnern, wieder, und wieder und wieder. Und tatsächlich, wie wir schreiben komplizierteren Programme, die Befehle du bist gehen zu müssen, zu schreiben gehen sogar zu erhalten mehr noch kompliziert. 

Und so keine Sorgen machen. Es stellt sich heraus, dass die Menschen vor uns haben sie auch realisiert hatte das exakt gleiche Problem. Auch sie nicht genießen zu haben Geben Sie ziemlich lang, obskuren Befehle, geschweige denn an sie erinnern. Und so Menschen vor uns gemacht haben andere Programme, die es einfacher machen, kompilieren Sie die Software. 

Und in der Tat, eine solche Programm Make genannt. Also werde ich voran gehen und das tun. Ich werde alles rückgängig zu machen, ich gerade tat in der folgenden Art und Weise. Lassen Sie mich LS eingeben. Und Sie werden drei bemerken things-- a.out, und ein Stern, hallo und ein Stern, und hello.c. Hoffentlich sollte dies sein ein wenig intuitiv, soweit früher war nichts in diesem Arbeitsbereich. Es gab nichts, was ich hatte erstellt, bis wir Klasse gestartet. 

Und ich erstellt hello.c. Ich kann es dann kompiliert, und nannte es a.out. Und dann habe ich es kompiliert wieder leicht anders und nannte es hallo. Also ich habe drei Dateien in diesem Verzeichnis, in diesem Ordner namens Workspace. Jetzt kann ich das auch sehen wenn ich vergrößern tatsächlich aus. 

Wenn ich hier vergrößern und Blick auf diese oben rechts Ecke, wie versprochen die linke Hand Seite des Bildschirms geht zu zeigen, wird immer Sie was in Ihrem Konto ist, was ist innerhalb von CS50 IDE. Und es gibt drei Dateien gibt. 

Deshalb möchte ich von a.out loszuwerden und hallo. Und wie Sie vielleicht vorstellen, intuitiv, Sie Art von Kontrolle Klick könnte oder direkt auf diese klicken. Und dieses kleine Menü erscheint. Sie können die Datei heruntergeladen haben, führen es, in der Vorschau, aktualisieren, umbenennen, oder was nicht. 

Und ich konnte es einfach zu löschen, und es würde weggehen. Aber lassen Sie uns Dinge tun, mit einem Befehl Linie für jetzt, um sich bequem mit diesem, und gehen Sie wie folgt. Ich gehe voran gehen und entfernen a.out durch buchstäblich rma.out eingeben. Es stellt sich heraus, den Befehl für Entfernen oder etwas zu löschen, ist zu entfernen oder zu löschen nicht. 

Es ist kurz und bündig RM, nur um zu sparen Sie einige Tastenanschläge, und die Eingabetaste drücken. Jetzt werden wir etwas zu sein, entfernen kryptisch reguläre Datei a.out. Ich weiß nicht wirklich, was ein unregelmäßige Datei würde noch sein. Aber ich will es zu entfernen. 

Also werde ich y für Ja zu geben. Oder ich könnte es geben aus, und drücken Sie die Eingabetaste. Und wieder scheint nichts zu passieren. Aber das ist im Allgemeinen eine gute Sache. 

Wenn ich LS dieses Mal eingeben, sehen, was sollte ich? Hoffentlich nur hallo und hello.c. Jetzt, da beiseite ein, werden Sie bemerken diesen Stern, Stern, das ist am Ende meiner Programme. Und sie zeigen auch grün. Das ist nur CS50 IDE Weg von Ihnen in die Tat cluing dass das nicht-Quellcode. Das ist eine ausführbare Datei, ein runnable Programm, das Sie tatsächlich ausführen können durch Punktstrich zu tun, und dann ist es Namen. 

Nun lassen Sie mich gehen Sie vor und entfernen Dazu rm hallo, eingeben, entfernen Sie regelmäßig Datei hallo, ja. Und jetzt, wenn ich Typ LS, wir sind wieder zu hello.c. Versuchen Sie, nicht zu löschen Sie Ihre eigentlichen Quellcode. Obwohl es gibt Funktionen in CS50 IDE gebaut, wo Sie können Ihre Revisionsgeschichte durchlaufen und Zurückspulen in der Zeit, wenn Sie versehentlich löschen etwas, tun bewusst sein, im Sinne dieser Aufforderungen ja oder nein, von dem, was Sie eigentlich tun wollen. Und wenn ich nach oben nach oben Handecke links hier, alles, was bleibt, ist hello.c. Es gibt also Bündel von andere Befehle, die Sie ausführen kann, in der Welt der Linux, einer davon ist, wieder, zu machen. Und wir gehen zu machen mein Programm nun wie folgt. 

Statt Klirren zu tun, anstatt das zu tun Klirren-o, Ich werde einfach zu geben, buchstäblich machen hallo. Und jetzt bemerken, ich bin Eingabe nicht hello.c machen. Ich schreibe hallo machen. 

Und das Programm, das kommt mit CS50 IDE und vieles mehr im Allgemeinen mit Linux, ist ein Programm, das ist werde ein Programm namens Hallo machen. Und es wird zu übernehmen, durch Konvention, dass, wenn dieses Programm durchgeführt werden, es wird von einer Quelle gemacht werden Code-Datei in Punkt c enden, hello.c. 

Also, wenn ich drücken Sie die Eingabetaste jetzt feststellen, dass der Befehl, der ausgeführt wird eigentlich sogar länger vor als zuvor. Und das ist, weil wir haben vorkonfigurierte CS50 IDE zu haben einige zusätzliche Features, dass gebaut wir brauchen nicht nur noch nicht, aber bald werden. Aber der Schlüssel ist daran zu erkennen, jetzt ist ich ein Hallo-Programm. 

Wenn ich erneut ein LS, I haben ein Hallo-Programm. Und ich kann es laufen mit dot slash a.out, nein, denn der ganze Sinn dieser Übung war dot slash hallo. Und jetzt habe ich meine Hallo Welt Programm. Also vorwärts zu bewegen, wir sind fast immer nur gehen unsere Programme kompilieren mit dem Befehl zu machen. Und dann werden wir sie laufen durch dot slash, und den Namen des Programms. Aber klar, was Make tut für Sie ist es selbst kein Compiler. Es ist nur ein Komfort-Programm dass weiß, wie man einen Compiler auslösen laufen kann, so dass Sie selbst verwenden. 

Was andere Befehle existieren in Linux und wiederum die CS50 IDE? Wir werden bald sehen, dass es eine CD-Befehl Change Directory. Auf diese Weise können Sie innerhalb Ihre Befehlszeilenschnittstelle um vorwärts zu bewegen, und zurück, und eröffnen verschiedene Ordner ohne mit der Maus. 

LS wir sahen, die Liste steht die Dateien im aktuellen Verzeichnis. Machen Sie Dir, können Sie wahrscheinlich beginnen zu schließen was diese bedeuten now-- Verzeichnis machen, wenn Sie möchten, um einen Ordner zu erstellen. RM für entfernen, RM Dir für entfernen directory-- und diese, Auch hier sind die Befehlszeile Äquivalenten, was Sie konnte mit der Maus in CS50 IDE tun. Aber Sie werden bald feststellen, dass manchmal ist es einfach viel schneller zu tun Dinge mit einer Tastatur, und letztlich viel stärker. 

Aber es ist schwer zu argumentieren, dass alles, was wir bisher getan , Ist alles, was mächtig, wenn alle wir haben sagen will, ist, hallo Welt. Und in der Tat, ich fest einprogrammiert die Worte hallo in mein Programm Welt. Es gibt keine Dynamik noch. Scratch war eine Größenordnung interessanter letzte Woche. 

Und so lassen Sie uns dort. Lassen Sie uns einen Schritt in Richtung auf das nehmen von haft einige dieser Funktionen. Also nicht nur C kommen mit printf, und Bündeln von anderen Funktionen von denen einige werden wir sehen, Im Laufe der Zeit hat es nicht machen es, dass alle einfach direkt aus des Gatters in eine Benutzereingabe zu bekommen. 

In der Tat, eine der Schwächen von Sprachen wie C, und auch Java und noch andere ist, dass es nicht machen es einfach, nur die Dinge wie ganze Zahlen von Benutzern oder Strings, Wörter, und Phrasen, geschweige denn Dinge wie Gleitkommazahlen oder reelle Zahlen mit Dezimalstellen, und wirklich lange Zahlen, wie wir bald sehen. Also diese Liste der Funktionen, die hier, diese sind wie andere Puzzleteile Scratch dass wir in CS50 vorinstalliert haben IDE, die wir für ein paar Wochen verwenden werden als Stützräder der Art, und schließlich nehmen sie ab, und schauen unter der Haube, vielleicht an wie diese Dinge umgesetzt werden. 

Aber um dies zu tun, lassen Sie uns tatsächlich ein Programm schreiben. Lassen Sie mich voraus jetzt gehen. Und ich werde einen neuen zu erstellen Eine Datei mit diesem kleinen Plus klicken, und klicken Sie auf Neue Datei. 

Ich werde diese neben sparen ein als, sagen wir mal, string.c, weil ich will, mit Streichern zu spielen. Und String in C ist nur eine Folge von Zeichen. So, jetzt gehen wir voran und gehen Sie wie folgt. 

Fügen Standard IO.h-- und es stellt sich heraus, Standard-IO, IO bedeutet nur, Eingang und Ausgang. So stellt sich heraus, dass Diese Linie ist hier, was ist das benachbarte uns printf zu verwenden. Printf, natürlich, erzeugt eine Ausgabe. Um also printf zu verwenden, es stellt sich out müssen Sie diese Zeile Code haben am Anfang der Datei. 

Und wir kommen wieder zu dem, was das bedeutet wirklich vor lang. Es stellt sich heraus, dass in jede C-Programm schreibe ich, Ich habe es für den Anfang Code, der wie folgt aussieht. Und Sie werden CS50 IDE bemerken und andere integrierte Entwicklungs Umgebungen, wie es, werden, wie am besten zu versuchen, sie können Ihre Gedanken zu beenden. In der Tat, vor einem Augenblick, wenn ich rückgängig machen was ich gerade tat, schlug ich ein. 

Ich traf dann offen lockig Klammer, traf wieder ein. Und es fertig mein Gedanke. Es gab mir eine neue Linie, eingekerbt nicht weniger für schöne stilistischen Gründen werden wir sehen. Und dann gab es mir automatisch dass geschweifte Klammer meine Gedanken zu beenden. Nun muss es nicht immer erraten, was Sie tun möchten. Jedoch zu einem großen Teil, tut Speichern Sie einige Tastenanschläge. Also vor einem Augenblick, liefen wir diese program-- hallo, Welt, und dann kompiliert, und lief es dann. Aber es gibt keine Dynamik hier. Was ist, wenn wir wollten etwas anderes zu tun? Nun, was ist, wenn ich wollte eigentlich eine Zeichenfolge vom Benutzer erhalten? Ich werde ein Puzzleteil zu verwenden, genau dass-- bekommen Zeichenfolge genannt. 

Es stellte sich in C aus, dass, wenn Sie nicht wollen, Eingang zu einem Puzzlestück zur Verfügung zu stellen, oder mehr richtig auf eine Funktion, Sie buchstäblich tun, nur offene Klammer, Klammer zu. So ist es, als ob es kein weißer Kasten zu geben in. Das sagen wir Block vor hatte einen kleinen weißen Kasten. Wir haben nicht das weiße Feld jetzt. 

Aber wenn ich String nennen, ich wollen das Ergebnis irgendwo zu setzen. Also ein sehr häufiges Paradigma in C ist rufen Sie eine Funktion, wie der String hier, und speichern Sie dann den Rückgabewert. Es ist das Ergebnis der Anstrengung in etwas. 

Und was ist das konstruieren in der Programmierung, ob in Scratch oder jetzt C, dass wir verwenden können, um tatsächlich etwas zu speichern? Nannte es eine Variable, nicht wahr? Und in Scratch, tun wir nicht wirklich egal, was in Variablen würde. 

Aber in diesem Fall tun wir eigentlich. Ich werde Zeichenfolge zu sagen. Und dann könnte ich nennen dies alles, was ich will. Ich werde es nennen Name, bekommt String zu erhalten. 

Und jetzt, selbst wenn du bist ein wenig neu in diesem, bemerken, dass ich einige Details bin fehlt. Ich vergesse ein Semikolon. Ich brauche diesen Gedanken zu beenden. Also werde ich mein Cursor zu bewegen, und schlug Semikolon dort. Und was habe ich nur getan? In dieser Codezeile, Nummer 5 in dem Moment, Ich rufe get String ohne Eingaben. Also gibt es keine kleinen weißen Feld wie das Speichern Block hat. 

Ich sage nur, hey, Computer, hol mir einen String. Das Gleichheitszeichen ist nicht wirklich ein Gleichheitszeichen, per se. Es ist die Zuordnung Betreiber, was bedeutet, hey, Computer, bewegen Sie den Wert von rechts nach links. Und in der linken Seite, habe ich folgendes. 

Hey, Computer, gib mir ein string-- eine Folge von Zeichen. Und so nennen string Name. Und ich muss es nicht einmal nennen Namen. 

Ich konnte es nennen, konventionell, so etwas wie S, ähnlich wie wir früher i rufen Sie die Variable i. Aber jetzt brauche ich etwas damit zu tun. Es wäre ziemlich dumm versuchen, diesen Code kompilieren, ausführen Dieses Programm, auch wenn Ich erhalte eine Zeichenfolge, noch, weil es nur gehen zu sagen, hallo Welt. 

Aber was, wenn ich will, dies zu ändern. Warum ich das nicht tun? Percent s, Komma s. Und das ist ein wenig noch kryptisch. 

Also lassen Sie mich meine Variablen mehr klar machen. Lassen Sie mich diese Variable Namen nennen. Und lassen Sie uns sehen, ob wir nicht ärgern auseinander, was hier passiert. 

Also auf der Linie fünf, ich bin immer einen String. Und ich bin zu speichern, die Schnur, was hat der Benutzer eingegeben an seinem Tastatur, in einer Variablen namens Namen. Und es stellt sich heraus, dass printf nicht nur nehmen ein Argument in Doppel Zitate, eine Eingabe in Anführungszeichen zu setzen. 

Es kann nehmen zwei oder drei, oder mehr, beispiels daß die zweite oder dritte oder vierte, sind alle Namen von Variablen, oder speziell Werte, dass Sie in verstopfen möchten, dynamisch, dass Zeichenfolge in Anführungszeichen. In anderen Worten, was würde dies falsch sein? Wenn ich gerade gesagt, hallo name, Backslash n, gespeichert meine Datei, mein Code kompiliert, und lief dies, was passieren würde? 

Es wird nur sagen, hallo nennen, buchstäblich N-A-M-E, Das ist ziemlich blöd da es ist nicht anders als Welt. So etwas ist in Anführungszeichen was wörtlich wird gedruckt. Also, wenn ich will haben ein Platzhalter dort, Ich brauche eigentlich zu verwenden einige spezielle Syntax. Und es stellt sich heraus, wenn Sie das lesen Dokumentation für die printf-Funktion, es wird Ihnen sagen, dass wenn Sie verwenden Prozent s, Sie können einen Wert ersetzen wie folgt. 

Nach einem Komma danach doppelte Anführungszeichen, geben Sie einfach schreiben Sie den Namen der Variable, die Sie wollen stecker in diesem Format Code oder Formatangabe, Prozent s für Strings. Und jetzt, wenn ich habe meine Datei gespeichert, Ich gehe zurück nach unten zu meinem Terminal. Und ich tippe Make String, Der Name dieses weil wieder Datei, die ich wählte vor ist string.c. 

Also werde ich String zu sagen, eintragen. Ach du meine Güte, schauen Sie sich alle die Fehler, die wir haben schon gemacht. Und das ist-- was, das ist wirklich wie ein sechs, sieben Zeilenprogramm? Also das ist, wo es kann sehr schnell überwältigend. 

Das Terminal-Fenster hat jetzt nur erbrochen eine Vielzahl von Fehlermeldungen. Sicherlich habe ich nicht mehr Fehler Nachrichten als ich Zeilen Code. Also, was ist los? 

Nun, die beste Strategie zu tun, Sie zu jeder Zeit Sie stoßen auf ein überwältigendes Liste der Fehler so, zurück, suchen Sie nach dem Befehl blättern Sie lief nur, was in meinem Fall ist String machen. Schauen Sie, was machte, und das ist, dass lange Clang Befehl, keine große Sache gibt. 

Aber die rot ist schlecht. Grün versucht, zu sein sanft und hilfsbereit. Aber es ist immer noch schlecht, in diesem Fall. Aber wo ist es schlecht? 

String.c, Zeile fünf, Charakter fünf. So ist dies nur allgemeine Konvention. Etwas Kolon etwas bedeutet Zeilennummer und Zeichennummer. Fehler, die Verwendung von nicht angemeldeter Bezeichnerstring. Meinten Sie Standard in? 

Also leider Clang versucht, hilfreich zu sein. Aber es ist falsch, in diesem Fall. Nein, Clang, ich wollte nicht Standard-IO. Ich meinte, dass auf Leitung eins, ja. 

Aber Linie fünf ist diese hier. Und Clang nicht verstehen, S-T-R-I-N-G. Es ist ein nicht deklarierter Bezeichner, ein Wort hat es nur noch nie gesehen. Und das ist, weil C, die Sprache wir schreiben Code in gerade jetzt, hat keine Variablen genannt Strings. 

Es ist nicht standardmäßig Unterstützung etwas genannt einen String. Das ist ein CS50 Stück Jargon, aber sehr konventionell. Aber ich kann dieses Problem beheben wie folgt. 

Wenn ich hinzufügen, eine Zeile Code an die Spitze dieses Programms, umfassen CS50.h, die eine andere Datei ist irgendwo in der CS50 IDE, irgendwo auf der Festplatte, sozusagen des Ubuntu-Betriebssystem dass ich laufen, dass die Datei ist, die ist geht das Betriebs zu lehren System, was ein String ist, nur wie Standard io.h ist die Datei in dem Betriebssystem, das ist geht es zu lehren, was printf ist. 

Tatsächlich hätten wir bekommen eine sehr ähnliche Meldung wenn IO hatte Standard zugelassen Io.h und versuchte printf zu verwenden. Also werde ich voran gehen und einfach Take Control L mein Bildschirm zu löschen. Oder Sie können klar geben, und es wird Sie einfach das Terminalfenster. Aber man kann immer noch in der Zeit zurückblättern. 

Und ich werde machen String erneut ausführen. Überqueren Sie meine Finger diesmal ein. Oh mein Gott, es hat funktioniert. es zeigt mir einen langen kryptischen Befehl das ist, was über Clang Stellen erzeugt, aber keine Fehlermeldungen. So realisieren, auch wenn Sie könnte bekommen vollständig überwältigt von der Anzahl der Fehlermeldungen, nur könnte es dieses lästige Kaskadierung sein Effekt, wo Clang nicht versteht eine Sache, die es dann bedeutet nicht das nächste Wort zu verstehen, oder die nächste Zeile. Und so würgt es nur auf Ihrem Code. Aber das Update könnte einfach sein. Und so konzentrieren sich immer auf die erste Zeile der Ausgabe. Und wenn Sie dies nicht tun verstehen es, schauen Sie für Keywords, die möglicherweise Hinweise und die Zeilennummer, und das Zeichen, wo dass Fehler sein könnte. 

Nun lassen Sie mich gehen Sie voran und geben Sie dot slash, Schnur, ein. Hm, es sagt nicht hallo nichts. Warum? Nun, erinnern, wo es läuft? 

Es ist wahrscheinlich im Moment stecken in einer Schleife, wenn man so will, auf der Linie sechs, weil der String von Design, geschrieben von CS50 Personal, wörtlich gemeint ist, einfach nur sitzen dort warten, und warten, und wartet auf einen String. Alles, was wir von String meine ist, menschliches Zutun. So wissen Sie was? Lassen Sie mich gehen Sie vor. Und nur aus einer Laune heraus, lassen Sie mich Geben Sie meinen Namen, David, ein. Jetzt habe ich ein dynamisches Programm. Es wird gesagt, hallo David. 

Wenn ich gehe voran und führen diese wieder, lassen Sie mich versuchen Zamila Namen sagen, ein. Und jetzt haben wir ein dynamisches Programm. Ich habe nicht hart Welt codiert. Ich habe nicht hart codiert nennen, oder David oder Zamila. 

Jetzt ist es viel mehr wie die Programme wir wissen, wo, wenn es Eingang nehmen, sie produziert etwas unterschiedlich ausfallen. Nun ist dies nicht die beste User Experience, oder UX. Ich betreibe das Programm. 

Ich weiß nicht, was ich soll zu tun, es sei denn, ich sehe eigentlich oder denken Sie daran, den Quellcode. Also lassen Sie uns den Benutzer machen erleben ein wenig besser mit einfachsten Dingen. Lassen Sie mich in diese zurück Programm und einfach printf sagen. 

Und lassen Sie mich voran gehen und sagen, Namen, Dickdarm-, und ein Raum, und dann ein Semikolon. Und gerade für Tritte, kein Spiel n. Und das ist bewusste, weil ich nicht will die Aufforderung zur nächsten Zeile zu bewegen. 

Ich möchte, dies stattdessen tun, machen Zeichenfolge mein Code in neue Maschine neu zu kompilieren Code dot slash String. Ah, das ist viel schöner. Jetzt weiß ich eigentlich, was der Computer will, dass ich es zu tun, einen Namen geben. 

Also werde ich voran gehen und geben Sie in Rob, eingeben und hallo, Rob. So, zu realisieren, dies ist immer noch, am Ende des Tages, nur neun Zeilenprogramm. Aber wir haben diese kleine Schritte gemacht. 

Wir schrieben eine Zeile, mit denen wir vertraut waren, printf, hallo Welt. Dann knöpfte wir ein wenig davon. Und wir bekommen String tatsächlich verwendet wird. Und wir warf diesen Wert in einer Variablen. Und dann gingen wir weiter und verbessert es weiter mit einer dritten Linie. Und dieser iterative Prozess der Schreiben von Software ist wirklich Schlüssel. In CS50, und das Leben im Allgemeinen, Sie sollten in der Regel sich nicht, haben ein Programm im Auge, und versuchen Sie schriftlich das ganze verdammte Ding auf einmal. 

Es wird zwangsläufig ergeben Weise mehr Fehler als wir uns hier gesehen haben. Selbst ich, bis zum heutigen Tag, ständig machen andere dumme Fehler, tatsächlich schwerer Fehler sind die sind schwerer zu verstehen. Aber Sie werden mehr Fehler zu machen, die mehr Codezeilen schreiben Sie alles auf einmal. Und so diese Praxis, ein wenig Code schreiben dass Sie mit vertraut sind, kompilieren es laufen, testen allgemeiner, bewegen on-- dann so wie wir gehalten Schichtung und Schichtung der letzten Woche, von etwas zu bauen, sehr einfach etwas komplexer, das Gleiche tun hier. Setzen Sie sich nicht nach unten, und versuchen, ein ganzes Problem zu schreiben. Eigentlich nehmen diese Baby-Schritte. 

Nun sind Strings nicht alle dass nützlich zu sich selbst. Wir sollten eigentlich, im Idealfall, wie zu haben etwas anderes in unserem Toolkit. Lassen Sie uns also genau das tun, tatsächlich so. 

Lassen Sie mich voran gehen jetzt und Peitsche ein etwas anderes Programm. Und wir werden diese Int.C nennen, für integer. Ich werde, ähnlich, umfassen CS550.h. Ich werde Standard IO aufzunehmen. Und das wird ziemlich häufig zu sein in diesen ersten Tagen der Klasse. 

Und ich werde bereit selbst mit einer Hauptfunktion. Und nun statt einer Zeichenfolge bekommen, Lassen Sie uns fortfahren und einen int bekommen. Nennen wir es i, und nennen Sie es bekommen int, in der Nähe Pars, Semikolon. Und jetzt wollen wir tun etwas mit ihm, printf. 

Lassen Sie uns sagen, so etwas wie hallo, Backslash n, Komma i. Also ich bin ziemlich viel imitiert was ich getan habe vorhin gerade. Ich habe einen Platzhalter hier. Ich habe ich hier Komma, weil ich will, Plug i in den Platzhalter. 

Lassen Sie uns so weitermachen und versuchen Erstellung dieses Programms. Die Datei heißt int.c. Also werde ich sagen, int machen, geben. Oh mein Gott, aber keine große Sache, nicht wahr? Es ist ein Fehler. 

Es gibt eine syntaktische Fehler hier so, dass das Programm nicht werden innerhalb Int.C, Zeile kompiliert sieben, Zeichen 27, Fehler Format gibt Typ char Star, was auch immer das ist. Aber das Argument Typ int. 

Also auch hier werden wir nicht zu-- obwohl heute eine Menge Material ist, wir gehen Sie zu überwältigen mit absolut jede Funktion von C, und Programmierung allgemeiner gerade in diesen ersten paar Wochen. Also, es geht oft um Jargon mit denen Sie nicht vertraut. Und in der Tat, char Stern ist etwas wir gehen zurück zu kommen in einer Woche oder zwei Zeit. 

Aber jetzt wollen wir mal sehen, ob wir können analysieren Wörter, die vertraut sind. Formats-- so hörten wir Format Bezeich, Format-Code vor. Das ist bekannt. Type-- aber das Argument vom Typ int hat. Warten Sie eine Minute, ich ist ein int. 

Vielleicht Prozent s tatsächlich hat einige definierte Bedeutung. Und in der Tat, es tut. Eine ganze Zahl, wenn Sie möchten, printf es zu ersetzen, Sie haben tatsächlich eine zu verwenden verschiedene Formatangabe. Und Sie würden nicht wissen es sei denn, jemand gesagt, oder Sie hatte es schon getan. Aber Prozent i ist, was werden häufig verwendet in printf in einer ganzen Zahl für die Verstopfung. Sie können auch Prozent verwenden d für eine ganze Dezimalzahl. Aber ich ist schön und einfach hier. Also werden wir mit, dass zu gehen. 

Nun lassen Sie mich gehen Sie vor und Rerun make int, eingeben. Das ist gut, keine Fehler. Dot Slash int-- OK, schlechte Benutzererfahrung, weil ich mich nicht erklärt haben, was ist zu tun. Aber das ist in Ordnung. Ich fange schnell auf. 

Und jetzt lassen Sie mich gehen Sie vor und Geben Sie in David, OK, Zamila, Rob. OK, so ist dies eine gute Sache. Dieses Mal, ich bin mit einer Funktion, ein Puzzle-Stück, get int genannt. Und es stellt sich out-- und wir werden sehen diese später in der term-- das CS50 Personal eingeführt hat erhalten Zeichenfolge so dass es nur körperlich für Sie ein String. 

Es hat int get implementiert in so dass es nur erhalten eine ganze Zahl für Sie. Und wenn Sie, der Mensch, nicht kooperieren, ist es buchstäblich gehen nur zu versuchen Sie es erneut sagen, wiederholen, wiederholen, buchstäblich sitzen Looping, bis Sie verpflichten mit etwas magische Zahl, wie 50, und hallo 50. 

Oder wenn wir laufen auch in diesem und geben Sie in 42, hallo 42. Und so funktionieren die get int innerhalb dieses Puzzleteil ist genug Logik, genug Gedanken, um herauszufinden, was ist ein Wort? Und was ist eine Zahl? Nur die Annahme letztlich Zahlen. 

So stellt sich heraus, dass diese ist gar nicht so ausdrucksstark. bisher. Also, yay, letzte Mal, dass wir ging ziemlich schnell in der Umsetzung Spiele und Animation, und künstlerische Arbeiten in Scratch. Und hier sind wir zufrieden zu sein mit Hallo Welt, und hallo 50. 

Es ist gar nicht so inspirierend. Und in der Tat, diese ersten paar Beispiele wird noch einige Zeit in Anspruch nehmen Rampe in Aufregung auf. Aber wir haben so viel mehr jetzt steuern, in der Tat. Und wir werden sehr Start schnell Schichtung auf dieser grundlegenden Primitiven. 

Aber lassen Sie uns zuerst verstehen wo die Grenzen sind. In der Tat, eines der Dinge, Scratch nicht leicht Lassen Sie uns tun wirklich aussehen unter der Haube, und zu verstehen, was ein Computer ist, was es tun kann, und was ihre Grenzen sind. Und in der Tat, dass der Mangel an Verständnis, möglicherweise, langfristige können unseren eigenen mistakes-- Schreiben führen Bugs, unsichere Software zu schreiben, die wird in irgendeiner Weise gehackt. 

Also lassen Sie uns einige Schritte unternehmen, um zu Verständnis dieser ein wenig besser durch Weg von sagen wir das folgende Beispiel. Ich gehe voran zu gehen und zu implementieren ganz schnell ein Programm namens Adder. Wie, lassen Sie uns gemeinsam ein paar Zahlen addieren. Und ich werde ein paar Ecken zu codieren hier und Kopieren und Einfügen einfach wo ich vorher war, nur so können wir gehen früher zu bekommen. So, jetzt habe ich die grundlegenden Anfänge bekam von einem Programm namens Adder. 

Und lassen Sie uns gehen Sie vor und tun dies. Ich gehe voran gehen und sagen wir, bekommt INTX int bekommen. Und weisst du was? Lassen Sie uns eine bessere Benutzererfahrung zu machen. 

Also lassen Sie uns einfach sagen, x und effektiv den Benutzer auffordern, uns x zu geben. Und dann lassen Sie mich voran gehen und sagen, printf wie etwa y, diesmal erwartet zwei Werte von dem Benutzer. Und dann gehen wir einfach weiter und etwa printf, die Summe von x und y ist. Und jetzt will ich nicht Prozent s zu tun. Ich möchte Prozent ich tun, Backslash n, und schließen Sie dann Summenwert. 

Also, wie kann ich tun, um dies zu tun? Weißt du was? Ich weiß, wie Variablen zu verwenden. Lassen Sie mich erklären, einfach ein neues, int z. 

Und ich werde hier eine Vermutung zu nehmen. Wenn es Gleichheitszeichen in dieser Sprache, vielleicht kann ich nur tun, x plus y, so lange, wie ich mein Ende dachte mit einem Semikolon? Jetzt kann ich dann wieder hier, stecken in z, beenden diesen Gedanken mit einem Semikolon. Und lassen Sie uns jetzt sehen, wenn diese Sequenzen von lines-- x int erhalten. Y int erhalten. 

Add x und y, speichern Sie den Wert in z-- so wieder, denken Sie daran das Gleichheitszeichen ist nicht gleich. Es ist Zuordnung von rechts nach links. Und lassen Sie uns, dass die Summe auszudrucken von x und y nicht buchstäblich z, aber was drin ist z. Also lassen Sie uns Adder machen - schön, diesmal keine Fehler. Dot Slash Adder, geben, x wird 1 sein. 

Y wird 2 sein. Und die Summe von x und y 3 ist. Also das ist alles schön und gut. 

Also würden Sie, dass Mathematik vorstellen sollte wie folgt in einem Programm zu arbeiten. Aber weißt du was? Ist diese Variable, Linie 12, sogar notwendig? Sie müssen nicht in der Gewohnheit, nur die Speicherung Dinge in Variablen nur weil du kannst. Und in der Tat, es ist im Allgemeinen als schlecht Design Wenn Sie eine Variable erstellen, genannt z in diesem Fall, Speicherung etwas darin, und dann sofort mit ihm, aber nie wieder. Warum etwas geben Sie einen Namen wenn Sie wie z sind buchstäblich nicht benutzen wollen, dass Sache nur einmal, und so proximal zu dem Sie erstellt es in erster Linie, so nahe in Bezug auf die Codezeilen? So wissen Sie was? Es stellt sich heraus, dass C ziemlich flexibel ist. Wenn ich will, tatsächlich zu Plug-in-Werten hier, Ich brauche nicht eine neue Variable zu deklarieren. Ich konnte einfach Plug-in-x plus y, weil C versteht Rechnen und mathematische Operatoren. 

So kann ich einfach sagen, tun dies Mathe, x plus y, was diese Werte sind, Stecken Sie das resultierende integer in diesen String. Also könnte dies, obwohl nur eine Zeile kürzer, ein besseres Design, ein besseres Programm, weil es weniger Code, deshalb weniger für mich zu verstehen. Und es ist auch nur sauberer, soweit wir nicht Einführung neuer Wörter, neue Symbole, wie z, obwohl sie nicht wirklich dienen viel von einem Zweck. 

Leider Mathe ist nicht alles, was die zuverlässige manchmal. Fahren wir fort und tun dies. Ich gehe voran gehen jetzt und gehen Sie wie folgt. 

Lassen Sie uns tun printf Prozent i plus Prozent i, soll Prozent i, Backslash n sein. Und ich werde this-- xyx plus y zu tun. Also werde ich einfach neu zu schreiben dies etwas anders hier. Lassen Sie mich nur eine schnelle Plausibilitätsprüfung tun. Auch hier wollen wir nicht vorgreifen. Machen Sie Addierer, Punkt slash Addierer. x 1 ist, y ist 2, 1 plus 2 3 ist. Also das ist gut. Aber lassen Sie uns dies erschweren jetzt ein bisschen, und eine neue Datei erstellen. 

Ich werde diese Frage zu nennen, sagen, Ints, Plural für ganze Zahlen. Lassen Sie mich beginnen, wo ich vor einem Augenblick war. Aber jetzt wollen wir mal ein paar andere Linien zu tun. Lassen Sie mich gehen Sie vor und gehen Sie wie folgt, printf Prozent i, minus Prozent i, ist Prozent i, Komma x, Komma yx minus y. Also ich mache etwas verschiedene Mathematik gibt. Lassen Sie uns ein anderes tun. So Prozent i mal Prozent i Prozent i, Backslash n. Lassen Sie uns Plug-in x und y, und x mal y. Wir werden das Sternchen auf Ihren Computer für Zeiten. 

Sie verwenden x nicht. x ist ein Variablenname hier. Sie verwenden den Stern für die Multiplikation. Lassen Sie uns ein mehr tun. Printf Prozent I, geteilt percent i, ist Prozent i, Backslash n. xy geteilt durch Y- so verwenden Sie den Schrägstrich in C zu tun Division. Und lassen Sie uns einen anderen tun. Der Rest des Prozent i, geteilt percent i, ist Prozent i. xy-- und jetzt Rest ist das, was übrig ist. Wenn Sie versuchen, eine Teilung Nenner in einen Zähler, wie viel übrig bleibt, dass Sie konnte sich nicht teilen aus? 

So gibt es nicht wirklich, notwendigerweise, ein Symbol wir haben für diese in der Grundschule verwendet. Aber es in C können Sie sagen x modulo y, wobei diese Prozentzeichen in diesem context-- verwirrender, wenn Sie im Inneren sind der doppelte Anführungszeichen, innerhalb von printf, Prozent wird als Formatangabe verwendet. 

Wenn Sie Prozent außerhalb daß in einem mathematischen Ausdruck, es ist der Modulo-Operator für modulare arithmetic-- für unsere Zwecke hier bedeutet nur, was ist das Rest von x nach y geteilt? So x durch y geteilt ist x Strich y. Was ist der Rest von x nach y geteilt? Es ist x mod y, wie ein Programmierer sagen würde. 

Also, wenn ich keine Fehler gemacht hier, lassen Sie mich gehen Sie vor und machen Ints, Plural, schön, und Punktstrich ints. Und lassen Sie uns gehen Sie vor und tun, sagen wir mal, 1, 10. In Ordnung, 1 plus 10 11, zu überprüfen. 1 minus 10 ist negativ 9, zu überprüfen. 

1 mal 10 10, zu überprüfen. 1 geteilt durch 10 ist-- OK, wir, dass man überspringen. Restbestände von 1 geteilt durch 10 ist 1. Das ist richtig. Aber es ist ein Fehler in hier. 

Also das eine habe ich meine übergeben, nicht korrekt. Ich meine, es ist nahe 0. 1 durch 10 geteilt, wissen Sie, wenn wir einige Ecken schneiden, sicher, es ist null. Aber es sollte wirklich 1/10 sein, 0,1 oder 0,10, 0,1000, oder so weiter. 

Es sollte wirklich nicht Null sein. Nun, es stellt sich heraus, dass der Computer tun buchstäblich, was wir gesagt, es zu tun. Wir tun Mathe wie x durch y geteilt. Und beide x und y, pro die Leitungen früher von Code, ganze Zahlen sind. 

Außerdem auf der Linie 15, wir sind erzählt printf, hey, printf-Plug-in eine ganze Zahl, Plug-in eine ganze Zahl, Plug-in-einem integer-- speziell x, y, und dann, und dann x geteilt durch y. x und y Ganzzahlen. Wir sind da gut. 

Aber was ist x durch x geteilt? x geteilt durch y sein sollte, mathematisch, 1/10 oder 0,1, die eine reelle Zahl ist, eine reelle Zahl, mit potenziell einen Dezimalpunkt. Es ist nicht eine ganze Zahl ist. 

Aber was ist der nächste integer bis 1/10 oder 0,1? Ja, es ist eine Art von Null. 0,1 ist wie dieser viel. Und 1 ist so viel. So ist 1/10 näher 0, als es ist zu eins. 

Und so was C tut für us-- Art, weil wir es gesagt zu-- diese ganze Zahl ist abgeschnitten. Es dauert den Wert, was wiederum soll so etwas wie 0,1000 zu sein, 0 und so weiter. Und es ist alles Kürzen nach dem Komma so dass dies alles Sachen, weil es nicht tut passen in die Vorstellung von einer ganzen Zahl, die ist nur eine Zahl wie negativ 1, 0, 1, nach oben und unten, wirft sie weg alles nach dem Komma, weil Sie kann kein Komma passen in einem ganzzahligen per Definition. 

Also hier ist die Antwort Null. So, wie wir dieses Problem beheben? Wir brauchen eine andere Lösung alle zusammen. Und wir können dies tun, wie folgt. 

Lassen Sie mich gehen Sie vor und erstellen Sie eine neue Datei mit dem Namen dieses floats.c. Und speichern Sie es hier in der Verzeichnis, float.c. Und lassen Sie mich gehen Sie vor und kopieren einige dieser Code aus früheren. 

Aber anstatt des Erhaltens int, lassen Sie uns dies tun. Gib mir einen Fließkommawert genannt x. wo ein Floating-Point Wert ist nur wörtlich etwas mit einem Floating-Point. Es kann nach links zu bewegen, nach rechts. Es ist eine reelle Zahl. 

Und lassen Sie mich rufen nicht bekommen int, aber bekommen Schwimmer, das war auch unter dem Menü von Optionen in der C250-Bibliothek. Lassen Sie uns y mit einem Schwimmer ändern. So wird dieser Schwimmer bekommen. 

Und jetzt wollen wir nicht in ints zu stopfen. Es stellt sich heraus, dass wir Prozent zu verwenden, haben f für float, Prozent f für Schwimmer, und jetzt speichern. Und jetzt die Daumen, machen Schwimmer, schön, Punkt slash schwimmt. x wird ein 1. y sein Wird 10 wieder zu sein. 

Und schön, OK meine hinaus ist richtig. Ich hatte gehofft, für mehr, aber ich habe vergessen, es zu schreiben. Also lassen Sie uns gehen und diese logische Fehler zu beheben. 

Fahren wir fort und die folgende greifen. Wir tun nur ein wenig zum Kopieren und Einfügen. Und ich werde Minus zu sagen. 

Und ich werde mal zu sagen. Und ich werde geteilt zu sagen. Und ich werde nicht Modulo zu tun, die nicht als Germane hier, dividiert durch f und Zeiten plus-- OK, lassen Sie uns noch einmal tun. 

Machen Sie schwimmt, Punkt slash schwimmt, und 1, 10, und- schön, nein, OK. Also ich bin ein Idiot. So ist dies sehr häufig in der Informatik dumme Fehler wie diese zu machen. 

Für pädagogische Zwecke, was ich wirklich tun wollte Änderung war die Wissenschaft hier zu plus, minus, zu Zeiten, und zu teilen, wie Sie hoffentlich während dieser Übung bemerkt. So, jetzt lassen Sie uns neu kompilieren diese Programm, tun dot slash schwimmt. 

Und zum dritten Mal, lassen Sie uns sehen, ob es meine Erwartungen erfüllt. 1, 10, geben, ja, OK, 1.000, dividiert durch 10.000, ist 0,100000. Und es stellt sich heraus, können wir steuern, wie viele Zahlen sind nach diesen Dezimalstellen. Wir werden tatsächlich. Wir werden darauf zurückkommen. 

Aber jetzt, in der Tat ist die Mathematik richtig. Also, noch einmal, was ist das Mitnehmen hier? Es stellt sich heraus, dass in C gibt es gerade nicht nur strings-- und, in der Tat, gibt es nicht wirklich, weil wir die mit der CS50-Bibliothek hinzufügen. Aber es gibt nicht nur ints. 

Es gibt auch schwimmt. Und es stellt sich ein paar andere Daten aus Arten auch, dass wir schon bald nutzen. Es stellte sich heraus, wenn Sie eine einzelne wollen Charakter, nicht um eine Zeichenfolge, Sie können nur ein Zeichen verwenden. 

Es stellte sich heraus, dass, wenn Sie einen Bool wollen, nur ein boolescher Wert, wahr oder falsch, Dank der CS50-Bibliothek, wir haben als auch auf C den Datentyp bool hinzugefügt. Aber es ist derzeit auch in viele andere Sprachen. Und es stellt sich heraus, dass man manchmal müssen größere Zahlen dann kommen standardmäßig mit ints und schwimmt. 

Und in der Tat ist ein Doppel eine Zahl dass verwendet nicht 32 Bit, sondern 64 Bit. Und eine lange, lange ist eine Zahl, verwendet nicht 32, Bits aber 64 Bits, jeweils für Gleitkomma Werte und ganze Zahlen sind. Also eigentlich lassen Sie uns jetzt In Aktion sehen. 

Ich gehe voran, hier zu gehen und Peitsche ein anderes Programm auf. Hier werde ich voran gehen und beinhalten CS50.h. Und lassen Sie mich gehen, sind Standard-io.h 

Und Sie werden etwas bemerken flippige geschieht hier. Es ist die Farbe nicht Codierung Dinge in auf die gleiche Weise wie vorher. Und es stellt sich heraus, dass, weil ich ist haben nicht die Sache einen Dateinamen gegeben. 

Ich werde diese Frage zu nennen sizeof.c, und drücken Sie auf Speichern. Und bemerken, was mit meinem sehr geschieht weiß Code gegen diese schwarzen Hintergrund. Nun, zumindest gibt es einige dort lila. Und es ist Syntax hervorgehoben. 

Das liegt daran, ganz einfach, ich habe sagte der IDE, welche Art von Datei es ist von ihm einen Namen zu geben, und speziell eine Dateierweiterung. Nun lassen Sie uns gehen Sie vor und tun dies. Ich werde weitermachen und sehr drucken Sie einfach die following-- Bool ist Prozent LU. 

Wir kommen wieder zu dass nur für einen Moment in. Und dann werde ich Druckgröße von Bool. Und jetzt, nur um zu sparen mich einige Zeit, ich bin geht um ein Ganzes zu tun Bündel von diesen auf einmal. Und gesagt, ich werde ändern Sie dies in einem char und char. Dieser, ich werde zu ändern zu einem Doppelbett und ein Doppelzimmer. 

Dieser, ich werde zu ändern mit einem Schwimmer und einem Schwimmer. Dieser, ich werde Wechseln Sie zu einem int und einem int. Und dieser, ich werde auf eine lange, lange zu ändern. Und es ist immer noch unter eine lange Zeit, lange, lange. 

Und dann schließlich gab ich mich einer zu viel, String. Es stellt sich heraus, dass in C, gibt es die speziellen Operator genannt Größe, das ist buchstäblich gehen, wenn laufen, Erklären Sie uns die Größe von jede dieser Variablen. Und dies ist eine Möglichkeit, jetzt wir können wieder verbinden In den letzten Diskussion der Woche von Daten und Darstellung. 

Lassen Sie mich gehen Sie vor und kompilieren Größe der Punktstrich Größe. Und lassen Sie uns sehen. Es stellt sich heraus, dass in C, speziell auf CS50 IDE, speziell auf die Betriebssystem Ubuntu, was ist ein 64-Bit-Betriebs System in diesem Fall ein Bool wird sich ein Byte Speicherplatz verwenden. Das ist, wie Größe gemessen wird, in Bits nicht, aber in Byte. Und daran erinnern, dass ein Byte acht Bit. So ein Bool, obwohl Sie auch technisch nur eine 0 oder 1 benötigen, es ist ein wenig verschwenderisch wie wir haben es umgesetzt. Es geht eigentlich um ein Ganzes zu verwenden byte-- so alle Nullen, sind vielleicht alle diejenigen, oder so ähnlich, oder auch nur eine 1 unter den acht Bits. 

Ein Zeichen, inzwischen für ein Zeichen verwendet wie ein ASCII-Zeichen pro letzte Woche, wird ein Zeichen sein. Und das synchs mit unseren Begriff der wobei nicht mehr als 256 bits-- vielmehr synchs mit es nicht zu sein länger als 8 Bits, die gibt uns so viele wie 256 Werte. Ein Doppel wird sich 8 Byte oder 64 Bit betragen. 

Ein Schwimmer ist 4. Ein int ist 4. Eine lange, lange 8. Und ein String ist 8. Aber keine Sorge darüber. Wir gehen diese Schicht zu schälen zurück. Es stellt sich heraus, Strings können mehr als 8 Bytes sein. 

Und in der Tat haben wir geschrieben Saiten schon, hallo Welt, länger als 8 Bytes. Aber wir kommen wieder zu dass nur für einen Moment in. Aber das Mitnehmen hier ist die folgende. 

Jeder Computer hat nur eine endliche Speichermenge und Raum. Sie können nur speichern, so viele Dateien auf Ihrem Mac oder PC. Sie können nur speichern, so viele Programme in RAM auf einmal läuft, unbedingt, auch mit virtuellen Speicher, weil Sie haben eine begrenzte Menge an RAM. 

Und nur um picture-- wenn Sie geöffnet haben nie einen Laptop bis oder zusätzlichen Speicher bestellt für einen Computer, Sie vielleicht nicht wissen, dass innerhalb des Computers etwas, das aussieht ein wenig wie diese. So ist dies nur ein gemeinsames Unternehmen mit dem Namen Entscheidend, dass macht RAM für Computer. Und RAM ist, wo Programme leben, während sie laufen. 

Also auf jedem Mac oder PC, wenn Sie verdoppeln klicken Sie auf ein Programm, und es öffnet sich, und es öffnet sich eine Word-Dokument oder etwas ähnliches, es speichert sie vorübergehend in RAM, weil RAM ist schneller als Festplatte oder Ihre Solid State Disk. So ist es nur, wo Programme gehen zu leben, wenn sie laufen, oder wenn Dateien verwendet werden. 

So haben Sie die Dinge, die aussehen wie diese im Inneren des Laptops, oder etwas größere Dinge innerhalb des Desktops. Aber der Schlüssel ist, müssen Sie nur eine endliche Anzahl von diesen Dingen. Und es gibt nur eine begrenzte Menge an Hardware auf diesem Schreibtisch sitzen rechts Hier. 

Also, sicher können wir nicht speichern unendlich lange Zahlen. Und doch denken, wenn Sie zurück zu Grundschule, wie viele Stellen können Sie haben auf der rechten Seite eines Komma? Für diese Angelegenheit, wie viele Stellen können Sie haben auf der linken Seite von einem Komma? Wirklich, unendlich viele. 

Jetzt könnten wir Menschen nur wissen, wie Millionen auszusprechen, und Milliarden, Billionen, und Billiarde und Trillionen. Und ich bin an die Grenzen meiner understanding-- oder my-- Ich verstehe, Zahlen, aber mein Aussprache von Zahlen. Aber sie können unendlich groß werden mit unendlich vielen Stellen links oder nach rechts von einem Komma. 

Aber Computer nur ein endliche Menge an Speicher, eine endliche Anzahl von Transistoren, a endliche Anzahl von Glühbirnen im Inneren. Also, was passiert, wenn Sie laufen aus dem Raum? Mit anderen Worten, wenn Sie denken Sie zurück an letzte Woche wenn wir sprachen über Zahlen selbst werden binär dargestellt, nehme an, dass wir haben, 8-Bit-Wert hier. 

Und wir haben sieben 1-en und ein 0. Und angenommen, dass wir wollen, 1 auf diesen Wert hinzuzufügen. Dies ist eine wirklich große Zahl jetzt. 

Das ist 254, wenn ich mich erinnere die Mathematik von der letzten Woche recht. Aber was, wenn ich ändern dass ganz rechts 0 bis 1? Die ganze Zahl, von Natürlich wird acht 1 ist. So sind wir immer noch gut. 

Und das wahrscheinlich repräsentiert obwohl 255, je nach Kontext es könnte tatsächlich darstellen eine negative Zahl. Aber mehr dazu eine andere Zeit. Das fühlt sich an wie es geht um so hoch wie ich zählen kann. 

Jetzt ist es nur 8 Bit. Und mein Mac, sicher, hat Art und Weise mehr als 8 Bit des Speichers. Aber es muss endlich. Also das gleiche Argument gilt, auch wenn wir haben mehrere dieser Einsen auf dem Bildschirm. 

Aber was passiert, wenn Sie Speichern Sie diese Nummer, 255, und Sie möchten zählen 1 Bit höher? Sie wollen 255 bis 256 zu gehen. Das Problem ist natürlich, dass, wenn Sie beginnen bei Null wie letzte Woche zu zählen, Sie können nicht so hoch zählen 256, geschweige denn 257, geschweige denn 258, m, denn was passiert, wenn Sie ein 1 hinzufügen? Wenn Sie das tun, die alte Grundschule Ansatz, setzen Sie hier eine 1, und dann 1 plus 1 gleich 2 ist, aber das ist wirklich eine Null ist, tragen Sie die 1, tragen die 1, tragen die 1. All diese Dinge, diese 1 ist, gehen auf Null zurück. Und Sie wind up, ja, wie jemand eine 1 auf der linken Seite, wies darauf hin,. Aber alles kann man tatsächlich sehen und passen in den Speicher nur acht 0 ist, das heißt, an einem gewissen Punkt, wenn Sie einen Computer, versucht zu zählen hoch genug, du bist gehen um zu wickeln, so scheint es, auf Null, oder vielleicht sogar negativ Zahlen, die sogar niedriger als Null sind. 

Und wir können diese Art von zu sehen. Lassen Sie mich gehen Sie vor und schreiben ein echter Schnellprogramm hier. Lassen Sie mich gehen Sie vor und schreiben ein Programm namens Überlauf. Fügen Sie CS50.h umfassen Standard IO.h-- oh, Ich wirklich meine Syntax-Hervorhebung verpasst. Also lassen Sie uns dies als overflow.c speichern. 

Und jetzt int main void-- und es dauerte nicht lange, wir werden wieder zu erklären, warum wir halten int main nichtig zu schreiben. Aber jetzt lassen Sie uns einfach tun , Nehmen es für selbstverständlich. Lassen Sie uns selbst einen int geben, und initialisieren Sie ihn auf 0. 

Lassen Sie uns dann für int bekomme ich zero-- tatsächlich, lassen Sie uns eine unendliche Schleife tun und sehen, was passiert. Dies stimmt zwar, lassen Sie uns dann n auszudrucken i Prozent, Backslash n, Plug-in n. Aber jetzt wollen wir tun n bekommt n plus 1. 

Also mit anderen Worten, auf jedem Iteration dieser Endlosschleife, Lassen Sie uns n den Wert nehmen, und fügen Sie 1, um es, und dann speichern Sie das Ergebnis zurück in n auf der linken Seite. Und in der Tat haben wir gesehen Syntax etwas wie dieses, kurz. Ein cooler Trick ist, statt des Schreibens dieses alle aus, Sie können tatsächlich ein n plus sagen gleich 1 ist. 

Oder wenn Sie wirklich sein wollen, Phantasie, Sie können n plus plus Semikolon sagen. Aber diese beiden letzteren sind nur was würden wir syntaktischer Zucker nennen für die erste Sache. 

Die erste Sache ist noch deutlicher, völlig in Ordnung, völlig richtig. Aber das ist häufiger, werde ich sagen. Also werden wir dies tun, nur für einen Moment. 

Lassen Sie uns nun Überlauf machen, das klingt eher bedrohlich, Punkt Strich Überlauf. Lassen Sie uns sehen, n ist schon ziemlich groß. Aber lassen Sie uns denken, wie groß kann n bekommen? 

n ist ein int. Wir haben gesehen, vor einem Moment mit der Größe Beispiel, dass ein int vier Bytes. Wir wissen aus der vergangenen Woche, vier Bytes 32 Bits, da 8 mal 4, ist, dass 32. Das wird 4 Milliarden sein. 

Und wir sind bis zu 800.000. Das wird für immer zu ergreifen, um zählen so hoch wie ich nur kann. Also werde ich voran gehen, wie Sie vielleicht schon bald, und drücken Sie Control C-- offen, Kontrolle C, eine Menge, wo Kontrolle C im Allgemeinen Mittel abzubrechen. Unglücklicherweise werden diese wird in der Cloud läuft, manchmal die Wolke so viel Zeug ausspucken, so viel Leistung, es wird zu nehmen Sie ein wenig, während für meine Eingabe in die Cloud zu bekommen. Also auch wenn ich getroffen Kontrolle C ein paar Sekunden, dies ist auf jeden Fall die Seite Wirkung einer Endlosschleife. 

Und so in einem solchen Fall sind wir gehen zu lassen, dass sein. Und wir werden eine neue hinzufügen Terminal-Fenster hier mit dem Plus, was natürlich nicht so, da ich dachte, es ist immer noch. Und lassen Sie uns vorangehen und sein ein wenig mehr zumutbar ist. 

Ich werde weitermachen und tun diese nur endlich viele Male. Lassen Sie uns eine for-Schleife verwenden, die ich zuvor angesprochenen. Lass uns das machen. Gib mir noch eine Variable int i 0 wird. i kleiner als, sagen wir, 64 i ++. Und jetzt lassen Sie mich gehen Sie vor und drucken out n Prozent i ist, Komma n. Und dann n-- ist dies immer noch gehen für immer zu nehmen. Lass uns das machen. 

n wird n-mal 2. Oder wir könnten sein Phantasie und tun mal gleich 2. Aber lassen Sie uns einfach sagen, n 2 gleich selbst mal. Mit anderen Worten, in dieser eine neue Version des Programms, Ich will nicht ewig warten aus wie 800.000 bis 4 Milliarden. Lassen Sie uns gerade diese über bekommen. 

Lassen Sie uns verdoppeln tatsächlich n jedes Mal. Welche, Rückruf, Verdoppelung ist die entgegengesetzt ist, natürlich. Und während der letzten Woche haben wir etwas wieder und wieder, und wieder, super schnell, Verdoppelung wird sicherlich erhalten wir von 1 bis zur größtmöglichen Wert, den wir mit einem int zählen kann. 

Lassen Sie uns also genau das tun. Und wir werden schon bald darauf zurückkommen. Aber dies ist wieder, wie der Wiederholungsblock in Scratch. Und Sie werden diese vor langer verwenden. 

Dies bedeutet nur Zählung von Null bis zu, aber nicht gleich sind, auf 64. Und bei jeder Iteration dieses Schleife, nur halten i erhöht wird. So i ++ - und das allgemeine Konstrukt 7 auf der Leitung ist nur ein super gemeinsamen Weg der Wiederholung ein paar Zeilen von Code, eine bestimmte Anzahl von Malen. Welche Zeilen Code? Diese geschweiften Klammern, wie Sie kann ab sofort aufgelesen haben, bedeutet, gehen Sie wie folgt. 

Es ist in wie Scratch, wenn es hat die gelben Blöcke und andere Farben, die Art von umarmen oder andere Blöcke umarmen. Das ist, was diese geschweiften Klammern tun hier. Also, wenn ich habe meine Syntax right-- Sie siehe die Karotte Symbol in C Mittel das ist, wie oft ich war versucht, dieses Problem zu lösen. Also lassen Sie uns dieses einen loswerden zusammen, und schließen Sie das Fenster. Und wir werden die neuen. Machen Sie Überlauf, Punkt slash Überlauf, Enter, alles in Ordnung, es sieht auf den ersten schlecht. Aber lassen Sie uns in der Zeit zurückblättern, weil ich tat dies 64-mal. 

Und zum ersten Mal bemerken, ist n 1. Das zweite Mal, ist n 2, dann 4, dann 8, dann 16. Und es scheint, dass, sobald Ich bekomme auf rund 1 Milliarde, wenn ich es noch einmal verdoppeln, das gib mir sollte 2 Milliarden. Aber es stellt sich heraus, es ist direkt an der Schwelle. 

Und so es tatsächlich überläuft ein int von 1 Milliarde auf etwa negativ 2 Milliarden, weil eine ganze Zahl ist, im Gegensatz zu den Zahlen, die wir letzte Woche wurden unter der Annahme, kann sowohl positiv als auch negativ sein in Wirklichkeit und in einem Computer. Und so mindestens einer von denen Bits effektiv gestohlen. Also nur haben wir wirklich 31 Bit, oder 2 Milliarden möglichen Werte. 

Aber jetzt ist das Essen zum Mitnehmen ganz einfach, was auch immer diese Zahlen sind und was auch immer die Mathematik ist, etwas Schlimmes passiert schließlich, denn schließlich wollen Sie permutieren die Bits einmal zu oft. Und Sie gehen effektiv aus allen 1 ist, um vielleicht alle 0-en, oder vielleicht nur einige andere Muster, dass es klar, je nach Kontext, kann als negative Zahl interpretiert werden. Und so wäre es die höchste Ich scheine kann in diesem Programm zählen ist nur rund 1 Milliarde. Aber es gibt eine Teillösung hier. Weißt du was? 

Lassen Sie mich von einem ändern int auf eine lange, lange. Und lassen Sie mich voran gehen hier und sagen-- Ich bin zu haben, dies einem unsigned long zu ändern. Oder wollen wir mal sehen, ich mich nie erinnern. 

Fahren wir fort und Überlauf machen. Nein, das ist es nicht, LLD, danke. Also manchmal kann Clang hilfreich sein. Ich habe nicht daran erinnern, was das Format Bezeich war für eine lange lange. 

Aber in der Tat, sagte Clang mich. Grün ist eine Art gut, noch bedeutet, dass Sie einen Fehler gemacht. Es ist zu raten, dass ich LLD gemeint. 

Also lassen Sie mich es ist Beratung, eine lange lange Dezimalzahl, speichern das. Und lassen Sie mich es erneut auszuführen, dot Slash Überlauf, ein. Und nun, was cool ist, ist dies. 

Wenn ich in der Zeit zurück bewegen, beginnen wir noch zur gleichen place-- Zählen 1, 2, 4, 8, 16. Beachten Sie, bekommen wir alle die Art und Weise bis zu 1 Milliarde. Aber dann sicher wir auf 2 Milliarden erhalten. 

Dann kommen wir zu 4 Milliarden, dann 8 Milliarden, 17 Milliarden. Und wir gehen höher und höher und höher. Schließlich auch dies bricht. 

Schließlich, mit einem langen langen, das ist die 64-Bit-Wert, nicht ein 32-Bit-Wert, wenn Sie zählen zu hoch ist, wickeln Sie um 0. Und in diesem Fall passieren wir Ende mit einer negativen Zahl. 

So ist dies ein Problem. Und es stellt sich heraus, dass diese Problem ist nicht so obskur. Obwohl ich habe absichtlich induziert es mit diesen Fehlern, es stellt sich heraus, dass wir es irgendwie alle sehen um uns herum, oder zumindest einige von uns tun. 

So in Lego Star Wars, wenn Sie haben jemals gespielt, das Spiel, es stellt sich heraus, können Sie gehen, um Dinge in LEGO Welt zu brechen, und das Sammeln von Münzen, im Wesentlichen. Und wenn Sie jemals gespielt haben dieses Spiel viel zu viel Zeit, da diese nicht namentlich Einzel hier getan hat, um die Gesamtzahl der Münzen, die Sie sammeln können ist, wäre es, 4 Milliarden scheinen. 

Jetzt, mit ist es tatsächlich abgerundet. So LEGO versuchte die Dinge benutzerfreundlich. Sie taten es nicht genau 2 die 32 Leistung pro letzte Woche. Aber 4 Milliarden ist ein Grund. Es scheint, basierend auf dieser Information, dass LEGO, und das Unternehmen, dass Diese eigentliche Software gemacht, entschieden dass die maximale Anzahl von Münzen, der Benutzer kann akkumulieren ist in der Tat, 4 Milliarden, weil sie beschlossen, ihren Code in zu verwenden offenbar nicht ein langer, langer, aber nur eine ganze Zahl, eine nicht signierte integer, nur eine positive ganze Zahl ist, deren max-Wert ist in etwa das. Nun, hier ist eine andere lustige ein. So in das Spiel Zivilisation, die einige von euch vielleicht bekannt sein, mit es stellt sich die Jahre heraus dort vor um einen Fehler in diesem Spiel, wobei war wenn Sie die Rolle gespielt von Gandhi im Spiel, anstelle von ihm als sehr pazifistisch, stattdessen war unglaublich, unglaublich unter bestimmten Umständen aggressiv. Insbesondere die Art und Weise, dass die Zivilisation Arbeiten ist, dass, wenn Sie, der Spieler, nehmen Demokratie, Ihre Aggressivität Punktzahl bekommt dekrementiert durch zwei, so minus minus, und dann minus minus. 

So subtrahieren Sie 2 von Ihre tatsächliche iterierenden. Leider, wenn Ihr iterierenden ist zunächst auf 1, und Sie 2 davon subtrahieren nach Annahme der Demokratie wie hier Gandhi könnte getan haben, weil er sehr passive-- war 1 auf der Skala von Aggressivität. Aber wenn er nimmt die Demokratie, dann er geht von 1 bis negativ 1. 

Leider waren sie mit Zahlen ohne Vorzeichen, das heißt, sie behandelt sogar negativ Zahlen, als ob sie positiv waren. Und es stellt sich heraus, dass die positive Äquivalent negativ 1, in typischen Computerprogrammen ist 255. Also, wenn Gandhi verabschiedet Demokratie, und deshalb hat seine Aggressivität Punktzahl ab, es rollt tatsächlich um bis 255 und macht ihn am meisten aggressiven Charakter im Spiel. So können Sie sich auf diese Google-up. Und es war in der Tat ein versehentlichen Programmfehler, aber das ist ganz eingegeben die Lore seitdem. 

Das ist alles Spaß und niedlich. Mehr erschreckend ist, wenn die tatsächliche realen Welt-Geräte und nicht Spiele, haben die gleichen Fehler. In der Tat, nur vor einem Jahr ein Artikel kam sich über die Boeing 787 Dreamliner. 

Und der Artikel auf den ersten Blick liest ein wenig obskur. Aber es sagte, dies eine Software Schwachstelle in Boeing neue 787-Jet hat die potenzielle Piloten verursachen verlieren die Kontrolle über das Flugzeug, möglicherweise im Flug, die FAA Beamte warnte Fluggesellschaften vor kurzem. Es war die Bestimmung dass ein Modell 787 Flugzeug, das mit Strom versorgt wurde, kontinuierlich für 248 Tage verlieren alle Wechselstrom, AC, elektrische Leistung durch den Generator Steuergeräte, GCUs, gleichzeitig geht in Fail-Safe-Modus. Es ist eine Art, mich zu verlieren. Aber das Memo erwähnt, OK, jetzt habe ich, dass, der Zustand wurde durch eine Software verursacht Zähler intern die Generatorsteuerung Einheiten, die nach dem überlaufen 248 Tage Dauerleistung. Wir sind die Ausstellung dieser bemerken Verlust zu verhindern aller elektrischen Wechselstrom Macht, die zur Folge haben könnten zu einem Verlust der Kontrolle über das Flugzeug. 

So buchstäblich dass eine ganze Zahl ist, oder einige gleichwertige Datentyp, wird in der Software verwendet in einer tatsächlichen Flugzeug dass, wenn Sie Ihr Flugzeug, auf lange genug, um die scheinbar kann der Fall sein, wenn Sie gerade laufen lassen sie ständig und nie Ausstecken Ihr Flugzeug, wie es scheint, oder Lassen Sie die Batterien sterben, zählen schließlich, und oben, und auf und auf und auf und auf. 

Und von Natur aus eine finite Menge an Speicher, überläuft, um ein Rollback Null oder ein negativer Wert ist, ein Nebeneffekt davon ist die erschreckend reale Realität dass das Flugzeug könnte brauchen neu gestartet werden, effektiv, oder fallen könnte, schlimmer noch, wie es fliegt. Also diese Art von Fragen noch bei uns sind, even-- dies war ein 2015 Artikel, umso erschreckender wenn Sie nicht unbedingt verstehen, zu schätzen wissen, oder antizipieren diese Arten von Fehlern. 

So stellt sich heraus gibt es noch eine andere schlechte Sache über Datendarstellung. Es stellt sich heraus, dass auch Schwimmer sind Art fehlerhaft, da schwimmt auch, Ich schlug vor, 32 Bit, oder vielleicht 64, wenn Sie einen Doppel verwenden. Aber das ist immer noch begrenzt. 

Und der Haken ist, dass, wenn Sie können stellen eine unendliche Anzahl von Nummern nach dem Komma, es gibt keine Möglichkeit, können alle möglichen darstellen Zahlen, die wir gelernt haben in Klasse kann die Schule in der Welt existieren. Ein Computer im Wesentlichen wissen, muss eine Teilmenge dieser Zahlen wählen, repräsentieren genau. 

Nun kann der Computer Runde vielleicht ein bisschen, und können Sie zu grob speichern lassen jede Zahl, die Sie sich nur wünschen könnte. Aber nur intuitiv, wenn Sie eine endliche Anzahl von Bits, Sie können sie nur permute in so vielen endlichen Möglichkeiten. So kann man unmöglich verwenden, um eine endliche Zahl der Permutation der Bits, Muster von Nullen und Einsen, repräsentieren eine unendliche Anzahl der Zahlen, das deutet darauf hin, dass Computer könnte sehr gut sein, manchmal zu uns liegen. 

In der Tat, lassen Sie uns dies tun. Lassen Sie mich zurück in CS50 IDE gehen. Lassen Sie mich gehen Sie vor und erstellen ein kleines Programm Die Ungenauigkeit, genannt zu zeigen, dass Computer sind in der Tat ungenau. 

Und lassen Sie mich gehen Sie vor und beginnen mit einige dieser Code aus der Zeit vor, und jetzt tun, nur die folgenden. Lassen Sie mich gehen Sie vor und tun printf Prozent f, Backslash n, 1 geteilt durch 10. Mit anderen Worten, lassen Sie uns in tiefer tauchen 1/10, wie 1 und dividiert durch 10. Sicherlich kann ein Computer 1/10 darstellen. 

Also lassen Sie uns fortfahren und Unschärfen zu machen. Mal schauen. Format gibt doppelt eingeben. Aber das Argument hat den Typ int. Was ist los? 

Oh, interessant, so ist es ein Lektion gelernt aus der Zeit vor. Ich sage, hey, Computer zeigen mir ein Schwimmer mit Prozent f. Aber ich gebe es zwei ints. So stellt sich heraus, kann ich das beheben dies in einer Reihe von Möglichkeiten. 

Ich konnte einfach drehen Sie einen in 1,0 und 10 in 10,0, die wäre in der Tat, haben die Wirkung des Umwandelns sie in floats-- noch hoffentlich die gleiche Anzahl. Oder es stellt sich heraus, es ist etwas, wir werden sehen, wieder vor lang. Sie könnten die Zahlen werfen. 

Sie können mit dieser klammerten Ausdruck, kann man sagen, hey, Computer, nehmen Sie diese 10, die ich kenne, ist ein int. Aber behandeln es, bitte, als ob es ist ein Schwimmer. Aber das fühlt sich unnötig komplex. 

Für unsere Zwecke heute, lassen Sie uns einfach buchstäblich machen sie schwimmend Punktwerte mit einem Komma, wie diese. Lassen Sie mich gehen Sie vor und erneut ausführen, machen Unschärfen, gut, dot slash Unschärfen, eingeben. OK, wir suchen gut. 

1 von 10, unterteilt nach meiner Mac hier, ist in der Tat, 0.100000. Nun, ich war in der Grundschule lehrte dort sollte eine unendliche Anzahl von 0 sein. Lassen Sie uns also zumindest versuchen, einige von denen zu sehen. Es stellt sich heraus, dass printf ist ein wenig schicker noch als wir verwendet haben. Es stellt sich heraus, Sie müssen nicht angeben nur Prozent f oder einfach Prozent i. Sie können tatsächlich angeben einige Steuerungsmöglichkeiten hier. 

Genauer gesagt, ich werde zu sagen, hey, printf, tatsächlich zeigen Sie mir 10 Dezimalstellen. So sieht es ein wenig seltsam. Aber Sie sagen Prozent, Punkt, wie viele Zahlen Sie wollen nach dem zu sehen Komma, und dann f für flache, nur weil das ist, was die Dokumentation sagt. Lassen Sie mich gehen Sie vor und speichern das. 

Und zu bemerken, ich bin immer müde Dinge für das Abtippen. So bin ich nur das Einrichten und Pfeil nach unten auf meine Schlüssel hier. Und wenn ich behalte das Schlagen auf, du sehen alle Befehle können dass ich gemacht oder falsch gemacht. 

Und ich werde jetzt nach vorne zu gehen und verwenden, die eigentlich nicht, anscheinend. Machen Sie Unschärfen, Punkt Slash imprecision-- so was ich gelehrt wurde, in Grundschule auscheckt. Auch wenn ich es auf 10 dezimal drucken legt es in der Tat, ist 0,10000. Aber weißt du was? 

Lassen Sie uns ein wenig gierig. Lassen Sie uns sagen, wie, zeigen Sie mir 55 Punkte hinter dem Komma. Lassen Sie uns das wirklich nehmen Programm für einen Spin-out. Lassen Sie mich Remake es mit make Unschärfen, Punkt slash, ungenauen. 

Und es geht los. Ihre Kindheit war eine Lüge. Offenbar geteilt durch 10 1 ist in der Tat 0.100000000000000005551115123-- 

Was ist los? Nun, es stellt sich heraus, wenn Sie Art Blick weit genug in der zugrunde liegenden Darstellung dieser Anzahl, es tatsächlich ist nicht genau 1/10 oder 0,1 und eine unendliche Anzahl von Nullen. Nun, warum ist das so? 

Nun, auch wenn dies ist eine einfache Anzahl an uns Menschen, 1 geteilt durch 10, es ist immer noch eine von unendlich vielen Zahlen, die wir denken konnte. Aber ein Computer kann nur bedeuten endlich viele so Zahlen. Und so, effektiv, was die Computer zeigt uns, ist der nächste Angleichung der Anzahl Wir wollen glauben, 1/10, oder wirklich 0,10000 ad infinitum. 

Vielmehr, obwohl, dies ist so nah wie es bekommen kann. Und in der Tat, wenn man sich unter der Haube, wie wir sind hier, indem man 55 Stellen nach dem Komma, wir tatsächlich sehen, dass die Realität. Jetzt als beiseite, wenn Sie noch jemals die movie-- gesehen die meisten von euch wahrscheinlich haven't-- aber Superman 3 vor einigen Jahren, Richard Pryor im Wesentlichen Leveraged diese Realität in seinem Unternehmen eine Menge zu stehlen von Fraktionen und Fraktionen von ein paar Cent, weil die company-- wie ich mich erinnere, es ist ein gewesen while-- im Wesentlichen war alles wegwerfen, die nicht passen in den Begriff der Cent. 

Aber wenn Sie addieren sich alle diese winzig, winzig, winzig Zahlen wieder, und wieder und wieder, können Sie, wie in seinen Fall, machen Sie eine gute Menge an Geld. 

Das gleiche Idee wurde abgezockt durch eine neuere, aber immer noch älter geworden Film, Office Space genannt, wo die Jungs in diesem Film, hat die gleiche Sache, schraubte sie bis vollständig, endete auch mit Weg viel Geld in ihr Bankkonto. Es war alles sehr verdächtig. Aber am Ende des Tages, Unschärfen ist überall um uns herum. 

Und das kann auch sein, Erschreckend der Fall ist. Es stellt sich heraus, dass Superman 3 und beiseite Büroräume gibt kann einige sehr real sein Welt Verzweigungen die besonderen Gegebenheiten der ungenauen Darstellung von Daten, dass auch wir Menschen zu an diesem Tag nicht unbedingt verstehen auch, wie wir sollten, oder denken Sie daran, wie oft, wie wir sollten. Und in der Tat, der folgende Clip von einem Blick auf einige sehr reale Welt Auswirkungen von dem, was passiert, wenn Sie nicht zu schätzen wissen, die sich ergibt geschehen in Zahlen Darstellung kann. 

[VIDEO-WIEDERGABE] 

-Computer, Wir haben alle kommen zu akzeptieren die oft frustrierend Probleme, die gehen mit them-- Bugs, Viren, und Software-Pannen, für kleine Preise zu zahlen für die Bequemlichkeit. Aber in High-Tech und High-Speed Militär- und Raumfahrt-Anwendungen, das kleinste Problem kann vergrößert in eine Katastrophe werden. 

Am 4. Juni 1996 Wissenschaftler vorbereitet eine unbemannte Rakete Ariane 5 zu starten. Es trug wissenschaftliche Satelliten zu etablieren, wie genau die Erdmagnetfeld in Wechselwirkung mit Sonnenwinde. Die Rakete wurde gebaut für der Europäischen Weltraumorganisation, und von seiner Anlage abgehoben an der Küste von Französisch-Guayana. 

-Am Etwa 37 Sekunden in die Flucht, sie zum ersten Mal bemerkte etwas los war falsch. Die Düsen wurden Einschwenken ein Weg, sollten sie wirklich nicht. Etwa 40 Sekunden nach Beginn des Fluges, klar, war das Fahrzeug in Schwierigkeiten. 

Und das ist, wenn sie gemacht eine Entscheidung, es zu zerstören. Der Bereich Sicherheitsbeauftragten, mit enormen Mut, drückte auf den Knopf, die Rakete explodierte, bevor es könnte zu einer Gefahr für die öffentliche Sicherheit. 

-Das War das Mädchen Fahrt der Ariane-5. Und seine Zerstörung nahm Platz aufgrund eines Fehlers in der Software-Rakete eingebettet. -Das Problem auf der Ariane war dass es eine Zahl, erforderlichen 64 Bits auszudrücken. Und sie wollten zu konvertieren es zu einer 16-Bit-Zahl. Sie gingen davon aus, dass die Zahl wurde nie gehen sehr groß zu sein, dass die meisten von denen, Ziffern in einer Reihe 64-Bit waren Nullen. Sie lagen falsch. 

-Die Unfähigkeit eines Software-Programm zu akzeptieren, die Art der Zahl, die durch ein anderer war an der Wurzel des Fehlers. Software-Entwicklung hatte sich ein sehr kostspielig Teil der neuen Technologie. Die Ariane-Rakete waren sehr erfolgreich, so viel von der Software erstellt für sie auch war in der Ariane-5 verwendet. 

-Der Grundproblem war, dass die Ariane 5 war schneller, beschleunigt schneller. Und die Software hatte nicht dafür entfielen. 

-Die Zerstörung der Rakete war eine große finanzielle Katastrophe, alle aufgrund einer Minute Softwarefehler. Aber dies war nicht der erste Zeitdatenkonvertierungsprobleme hatte modernen Raketentechnik geplagt. 

-In 1991 mit dem Start des ersten Golfkriegs, der Patriot Missile erlebt eine ähnliche Art der Anzahl Umwandlung Problem. Und als Ergebnis, 28 Personen, 28 amerikanische Soldaten, wurden getötet, und über 100 weitere verletzt, wenn der Patriot, die angeblich zum Schutz vor eingehenden scuds, versäumt, eine Rakete abzufeuern. 

-Wenn Irak in Kuwait einmarschierte, und Amerika ins Leben gerufen Desert Storm Anfang 1991, Patriot Missile Batterien waren im Einsatz Saudi-Arabien und Israel zu schützen von irakischen Scud-Raketenangriffe. Der Patriot ist ein US-Mittelstrecken Boden-Luft-System, hergestellt von der Raytheon Company. 

-Die Größe des Patriot-Interceptor selbst ist etwa in etwa 20 Meter lang. Und es wiegt etwa 2000 Pfund. Und es trägt einen Gefechtskopf von etwa, Ich denke, es ist ungefähr 150 Pfund. Und der Gefechtskopf selbst ist ein hochexplosiven Sprengstoff, die hat Fragmente herum. Das Gehäuse des Gefechtskopfes ist, entworfen, um wie Schrot zu handeln. 

-Die Raketen durch vier pro Behälter, und durch ein Sattelauflieger transportiert werden. 

-Der Patriot Anti-Raketen-System mindestens 20 Jahren geht nun zurück. Es wurde ursprünglich entworfen als Luftabwehrrakete feindliche Flugzeuge abzuschießen. Im ersten Golfkrieg, wenn dieser Krieg kam, die Armee wollte es verwenden, um abzuschießen scuds, keine Flugzeuge. 

Die irakische Luftwaffe nicht so sehr ein Problem. Aber die Armee über scuds besorgt. Und so versuchten sie zu Upgrade der Patriot. 

-Intercepting Einen Feind Rakete reist mit Mach 5 würde anspruchsvoll genug zu sein. Aber wenn der Patriot wurde in Dienst gehetzt, die Armee war nicht bekannt, ein Irakische Modifikation, die gemacht ihre scuds fast unmöglich zu schlagen. 

-Was Ist passiert die scuds, dass in kamen waren instabil. Sie wurden Wackeln. Der Grund dafür war, die Iraker, um zu bekommen 600 Kilometer aus einer 300 km range missile, nahm Gewicht aus dem vorderen Gefechtskopf. Sie machten der Gefechtskopf leichter. 

So, jetzt die Patriot ist versuchen, an der Scud zu kommen. Und die meiste Zeit, die überwältigende Mehrheit der Zeit, es wäre nur durch die Scud fliegen. Sobald die Patriot Netzbetreiber erkannte der Patriot sein Ziel verfehlt, sie zur Detonation der Gefechtskopf Patriot mögliche Verluste, wenn es zu vermeiden Man ließ den Boden fallen. 

-Das War das, was die meisten Leute sahen, die großen Feuerkugeln in den Himmel, und falsch verstanden als Abschnitte mit Scud Sprengköpfe. 

-Obwohl In der Nacht Himmel, Patriots erschienen um erfolgreich Scud-Raketen, bei Dhahran zu zerstören, es konnte kein Fehler sein über seine Leistung. Dort wird das Radarsystem Patriot Spur eines eingehenden Scud verloren, und nie ins Leben gerufen durch zu einem Software-Fehler. Es waren die Israelis, die zum ersten Mal entdeckt dass je länger war das System, desto größer ist die Zeit Diskrepanz geworden ist, aufgrund eines Takt eingebettet in dem Computer des Systems. 

-Über Zwei Wochen vor die Tragödie in Dhahran, die Israelis berichtet das Verteidigungsministerium , dass das System Zeit zu verlieren. Nach etwa acht Stunden oder Laufen, sie bemerkten, dass das System deutlich weniger genau war immer. Das Verteidigungsministerium reagierte alle der Patriot-Batterien zu sagen zu verlassen, nicht die Systeme für eine lange Zeit. Sie sagten nie, was eine lange Zeit was-- 8 Stunden, 10 Stunden 1.000 Stunden. Niemand wusste. 

-Der Patriot-Batterie in der Kaserne stationiert bei Dhahran und seine fehlerhafte interne Uhr war über 100 Stunden gewesen auf in der Nacht vom 25. Februar. 

-it Nachgeführt Zeit mit einer Genauigkeit von etwa einem Zehntel einer Sekunde. Nun wird eine Zehntelsekunde ist eine interessante Zahl, weil es nicht exprimierenden kann binär genau, was bedeutet, kann es nicht genau ausgedrückt werden in jedem modernen digitalen Computer. Es ist schwer zu glauben. 

Aber dies als ein Beispiel. Lassen Sie uns die Nummer ein Drittel nehmen. Ein Drittel kann nicht sein, genau in dezimal ausgedrückt. Ein Drittel ist 0,333 geht für die Unendlichkeit. 

Es gibt keine Möglichkeit, das zu tun, mit absolute Genauigkeit in dezimal. Das ist genau die Art von Problem das geschah in der Patriot. Je länger das System lief, die schlechter wurde der Zeitfehler. 

-Nach 100 Betriebsstunden, die Fehler in der Zeit war nur etwa ein Drittel einer Sekunde. Aber in Bezug auf eine Ziel Rakete auf mach Reisen 5, es führte zu einer Tracking Fehler von über 600 Metern. Es wäre ein fataler Fehler sein für die Soldaten auf, was passiert ist war eine Scud Start von Frühwarnsatelliten entdeckt und sie wussten, dass die Scud war in ihrer allgemeinen Richtung. Sie wussten nicht, wo es kam. 

-Es War jetzt auf dem Radar nach oben Bestandteil des Patriot-System verteidigen Dhahran zu lokalisieren und zu halten Spur des ankommenden feindlichen Rakete. 

-Der Radar war sehr klug. Es wäre tatsächlich verfolgen die Position des Scud, und dann vorhersagen, wo es wahrscheinlich wäre das Radar das nächste Mal gesendet einen Impuls aus. Das war ein Range-Gate bezeichnet. 

-Dann, Sobald der Patriot entscheidet, genügend Zeit hat, vergangen, die als nächstes gehen Sie zurück und überprüfen Standort für dieses Objekt erkannt, es geht zurück. Also, wenn es ging zurück in die falsche Ort, es sieht dann kein Objekt. Und es entscheidet, dass es keine war Objekt, es war eine falsche Erfassung, und fällt die Spur. 

-Der Eingehenden Scud verschwunden vom Radarschirm. Und Sekunden später, die Kaserne rammte. Die Scud getötet 28 und war der letzte gefeuert während des ersten Golfkriegs. 

Tragisch, die aktualisierte Software kam am nächsten Tag bei Dhahran. Die Software Fehler hatte wurde behoben, Schließen ein Kapitel in der unruhigen Geschichte des Patriot-Rakete. 

[VIDEO-WIEDERGABE] DAVID J. MALAN: Also ist das alles zu sagen, dass diese Fragen von Überlauf und Unschärfen sind nur allzu real. Wie sind wir hierher gekommen? Wir begannen mit nur etwa printf sprechen. Auch diese Funktion, druckt etwas auf den Bildschirm, und wir eingeführt danach einige andere Funktionen von der CS50 der Bibliothek so genannte. Und wir werden auch weiterhin sehen diese zu gegebener Zeit. Und wir, vor allem, get-String, und bekommen int, und jetzt auch Schwimmer bekommen, und noch andere noch werden wir treffen und nutzen, um uns vor lang. 

Aber gelegentlich haben wir bereits eine Notwendigkeit gesehen diese Funktionen Hand zu speichern, was zurück? Sie übergeben uns eine Zeichenfolge zurück, oder ein int oder ein Schwimmer. Und manchmal müssen wir darauf setzen String oder int oder float, irgendwo. 

Und diese Dinge zu speichern, nur daran erinnern, wie in Scratch, haben wir Variablen. Aber anders als in Scratch, in C haben wir tatsächlichen Typen von variables-- Daten Typen, mehr generally-- unter ihnen, ein String, ein int, ein schweben, und diese andere noch. 

Und so, wenn wir Variablen in C erklären, wir werden unsere Datentypen deklarieren müssen. Das ist nicht etwas, wir werden haben später im Semester zu tun wie wir zu anderen Sprachen wechseln. Aber jetzt, wir brauchen a priori im Voraus, erklären auf den Computer, welche Art variabler wollen wir es uns zu geben. 

Nun, inzwischen zu drucken diese Art von Datentypen, wir haben zu sagen, printf, was zu erwarten. Und wir sahen Prozent s für Streicher, und Prozent i für ganze Zahlen, und ein paar andere schon. Und das sind nur Anforderungen für die visuelle Präsentation dieser Informationen. 

Und jedes von diesen kann tatsächlich parametrisiert oder in irgendeiner Weise gezwickt, wenn Sie wollen die Kontrolle zu fördern die Art der Ausgabe, die Sie erhalten. Und in der Tat stellt sich heraus, dass nicht nur ist es für eine neue Zeile Backslash n. Es ist etwas anderes Backslash genannt r für einen Wagenrücklauf, die ist eher an eine alte Schule Schreibmaschine, und auch verwendet, um Windows für viele Jahre. 

Es gibt Backslash t für Tabs. Es stellte sich heraus, dass, wenn Sie möchten, doppelte Anführungszeichen innerhalb eines Strings, Daran erinnern, dass wir verwendet haben Doppel Zitat Doppel Zitat auf der linken und der rechten Seite so weit endet unserer Saiten. Das scheint Dinge zu verwirren. 

Wenn Sie ein doppeltes Anführungszeichen setzen in die Mitte eines string-- und in der Tat, es ist verwirrend zu sehen. Und so müssen Sie entkommen, so zu sprechen, ein doppeltes Anführungszeichen mit etwas wie wahrsten Sinne des Wortes Backslash doppelte Anführungszeichen. Und es gibt noch ein paar andere noch. Und wir werden mehr davon sehen bei der tatsächlichen Verwendung vor lang. 

Also lassen Sie nun den Übergang von Daten und Darstellung, und arithmetische Operatoren, alle von denen gab uns einige Gebäude mit denen Blöcke zu spielen. Aber nun tatsächlich geben uns der Rest des Vokabulars dass wir bereits hatten letzte Woche mit Scratch durch einen Blick auf einige andere nehmen Konstrukte in C-- nicht alle von ihnen. Aber die Ideen, die wir sind über wirklich nur um zu sehen Übersetzung zu betonen, aus eine Sprache, Scratch, zum anderen, C. 

Und im Laufe der Zeit werden wir holen auf Weitere Tools für unser Toolkit, sozusagen syntaktisch. Und in der Tat, werden Sie, dass die Ideen sehen jetzt sind eher bekannt aus der letzten Woche. Also lassen Sie uns dies tun. 

Fahren wir fort und Peitsche ein Programm dass tatsächlich nutzt einige Ausdrücke, ein Boolescher Ausdruck. Lassen Sie mich gehen Sie voran hier und erstellen Sie eine neue Datei. Ich werde diese condition.c nennen. 

Lassen Sie mich gehen Sie vor und die CS50-Bibliothek enthalten. Und lassen Sie mich gehen Sie vor und schließen Standard io.h für unsere Funktionen, und printf und vieles mehr sind. Ich gebe mir diese vorformulierten von int main Leere, deren Erklärung wir werden kommen zurück in die Zukunft. 

Nun lassen Sie mich gehen Sie vor und geben selbst ein int über get int. Dann lassen Sie mich gehen Sie vor und tun dies. Ich möchte sagen, wenn ich das ist less-- lassen unterscheiden zwischen positiv, negativ, oder Null-Werte. 

Also, wenn ich kleiner als Null ist, lassen Sie mich nur dieses Programm haben einfach sagen: negativ, Backslash n, sonst wenn i größer als Null ist. Nun bin ich, natürlich, gehen zu sagen, printf positiv, Backslash n. Und dann sonst if-- ich dies tun könnte. 

Ich konnte tun, wenn ich gleich 0. Aber ich würde auf, mindestens ein Fehler bereits. Daran erinnern, dass das Gleichheitszeichen nicht gleich, wie wir Menschen es kennen. 

Aber es ist der Zuweisungsoperator. Und wir wollen nicht 0 auf die zu nehmen Recht und legte es auf der linken Seite in i. Also diese Verwirrung zu vermeiden, oder vielleicht Missbrauch der Gleichheitszeichen, Menschen entschieden vor einigen Jahren dass in vielen Programmiersprachen wenn Sie möchten, auf Gleichheit zu überprüfen zwischen der linken und der rechten Seite, Sie verwenden eigentlich gleich Gleichen. So schlagen Sie das Gleichheits zweimal unterschreiben. Wenn Sie möchten, von rechts nach zuweisen nach links, verwenden Sie ein einzelnes Gleichheitszeichen. So konnten wir this-- anderes tun wenn i gleich Null ist. 

Ich konnte dann gehen und öffne meine geschweiften Klammern, und sagen: printf 0, Backslash n, fertig. Aber denken Sie daran, wie diese Gabeln in der Straße arbeiten. Und wirklich, man denke nur an die Logik. i eine Zahl ist. Es ist eine ganze Zahl, die speziell. Und das bedeutet, es wird weniger sein als 0 oder größer als 0 ist, oder 0 ist. So ist es Art dieser implizite Standardfall. 

Und so konnten wir, genau wie Scratch, verzichten auf den anderen, wenn, und einfach sagen andere. Logisch, wenn Sie die Programmierer wissen, dass es nur drei Schaufeln in die ein Szenario kann die erste fall--, der zweite oder der dritte in dieser Fall-- nicht Mühe, die zusätzliche Präzision Zugabe und die zusätzliche Logik gibt. Dann nichts wie los mit der Standardfall hier von anderen. 

Nun lassen Sie uns fortfahren danach zu speichern, machen Bedingungen dot slash conditions-- nicht eine große Benutzeroberfläche, weil ich Aufforderung nicht die Benutzer, wie ich bereits erwähnt. Aber das ist in Ordnung. Wir werden es einfach zu halten. Lassen Sie uns versuchen, die Nummer 42. Und das ist positiv. Lassen Sie uns die Nummer versuchen negativ 42 negativ. 

Lassen Sie uns den Wert 0 zu versuchen. Und in der Tat, es funktioniert. Nun, werden Sie mit Problemen sehen vor lange, Prüfung Dinge dreimal, wahrscheinlich nicht ausreichend. Sie wollen wahrscheinlich etwas zu testen größere Zahlen, einige kleinere Zahlen, einige Sonderfälle, wie wir kommen, um sie zu beschreiben. 

Aber jetzt, ist dies ein ziemlich einfaches Programm. Und ich bin mir ziemlich sicher, logisch, dass es sich in drei Fällen. Und in der Tat, auch wenn wir nur auf die möglichen Nachteile konzentriert Unschärfen und Überlauf, in Realität, wo viele von CS50 Probleme, wir werden keine Sorgen zu machen über, die ganze Zeit, diese Fragen von Überlauf und Ungenauigkeit, weil in der Tat in C, es ist eigentlich gar nicht so einfach, diese Dinge zu vermeiden. Wenn Sie möchten, bis zu zählen größer und größer, und größer, es stellt sich heraus, es gibt Techniken, die Sie kann verwendet werden, die oft als denen Dinge Bibliotheken, Sammlungen von Code, dass andere Leute geschrieben, dass Sie verwenden können, und andere Sprachen wie Java und andere, eigentlich machen es viel einfacher zu zählen, sogar noch höher. So ist es wirklich einige dieser Gefahren eine Funktion der Sprache, die Sie verwenden. Und in den kommenden Wochen werden wir sehen, wie gefährlich C wirklich kann sein, wenn Sie es nicht richtig zu verwenden. Aber von dort, und mit Python und JavaScript werden wir Schicht auf einige zusätzliche Schutzmaßnahmen, und laufen weniger dieser Risiken. 

Also lassen Sie uns ein wenig mehr machen interessante Logik in unserem Programm. Also lassen Sie mich gehen Sie vor und erstellen ein Programm namens Logical nur so kann ich mit einigen spielen eigentliche Logik, logical.c. Ich werde einfach kopieren und einige Code aus früheren so komme ich zurück zu diesem schönen Ausgangspunkt. 

Lassen Sie mich diese Zeit tun char C. Ich bin geht es einen Namen von C zu geben, nur weil es konventionell, ein Zeichen von der Benutzer zu bekommen. Und lassen Sie uns so tun, wie Ich bin der Umsetzung Teil dieses Rm Programm, das Entfernen Programm vor, dass aufgefordert, den Benutzer eine Datei zu entfernen. Wie können wir das tun? 

Ich möchte sagen, wenn C gleich entspricht, Zitat Ende des Zitats, y, dann werde ich davon ausgehen, dass der Benutzer hat ja gewählt. Ich werde nur drucken ja. Wenn es tatsächlich zu schreiben das Programm zum Entfernen, wir könnten die Datei entfernen mit mehr Zeilen Code. Aber wir werden es einfach halten. 

Else, wenn c gleich gleich n-- und jetzt hier, ich werde sagen, der Benutzer muss nicht gemeint haben. Und dann anders, weißt du was? Ich weiß nicht, was sonst der Benutzer wird zu tippen. Also werde ich nur sagen, dass, das ist ein Fehler, was auch immer er oder sie tatsächlich eingegeben haben. 

Also, was ist hier los? Es besteht ein grundlegender Unterschied gegenüber, was ich in der Vergangenheit getan haben. Doppelte Anführungszeichen, doppelte Anführungszeichen, doppelte Zitate, und doch einfache Anführungszeichen, einfache Anführungszeichen. Es stellt sich heraus in C, dass, wenn Sie wollen einen String zu schreiben, nur tun Sie doppelte Anführungszeichen verwenden, wie wir haben die ganze Zeit mit printf im Einsatz. 

Aber wenn Sie mit nur einem zu beschäftigen einzelnes Zeichen, ein sogenanntes char, dann tatsächlich Sie einfache Anführungszeichen verwenden. Diejenigen von euch, die programmiert haben vor, könnten Sie nicht haben hatte zu kümmern Unterscheidung in bestimmten Sprachen. In C, es spielt eine Rolle. Und so, wenn ich ein Zeichen bekommen, und ich will dass char equals zu vergleichen bis zu einem gewissen Brief wie y oder n gleich, ich tue, in der Tat, müssen Sie die einfachen Anführungszeichen zu haben. 

Nun lassen Sie uns gehen Sie vor und tun dies. Fahren wir fort und machen logische Punkt Slash logisch. Und jetzt aufgefordert, ich bin zu werden. Also, vermutlich eine bessere Benutzererfahrung würde mir eigentlich sagen, was hier zu tun. Aber ich werde einfach blind sagen y für ja, OK, schön. 

Lassen Sie uns laufen sie wieder, n für nein, schön. Angenommen, wie gewisse Leute, die ich kenne, meine Caps Lock-Taste auf allzu oft ist. Also ich Kapital Y, geben, Fehler. OK, es ist nicht genau das, was ich erwarte. Tatsächlich ist der Computer tut buchstäblich was Ich sagte es zu do-- überprüfen Klein y und Klein n. Das fühlt sich nicht wie gut Benutzererfahrung, aber. Lassen Sie mich fragen Sie nach und akzeptieren entweder Klein- oder Großbuchstaben. So stellt sich heraus, könnten Sie wollen etwas zu sagen wie in Scratch, wie wörtlich oder C gleich gleich Kapital Single zitiert y. Es stellte sich heraus, C nicht über diese wörtliche Schlüsselwort oder. 

Aber es hat zwei vertikale Balken haben. Sie haben die Umschalttaste zu halten in der Regel, wenn Sie eine US-Tastatur verwenden, und drücken Sie die vertikale Leiste Taste über Ihren Return-Taste. Aber diese vertikale Leiste Senkrechtstrich bedeutet oder. 

Wird dagegen wollten wir zu sagen, und, wie in Scratch, wir konnten Ampersand Ampersand tun. Das macht keinen logischen Sinn hier, weil ein Mensch unmöglich eingegeben haben beide y und Klein y und Kapital Y als dem gleichen Charakter. So oder ist das, was wollen wir hier. 

Also, wenn ich das in beiden Orten, oder c gleich ist gleich Kapital N, jetzt erneut auszuführen, machen logisch, erneut ausführen, logisch. Jetzt kann ich geben Sie y ein. Und ich kann es wieder tun mit Hauptstadt Y oder Kapital N. Und ich konnte in weiteren hinzufügen noch Kombinationen. 

Das ist also eine logische Programm soweit jetzt Ich überprüfe logisch für dieser Wert oder dieser Wert. Und ich habe nicht notwendigerweise kommen mit zwei mehr ifs oder sonst ifs. Ich kann tatsächlich etwas von dem Mähdrescher Logik zusammen auf diese Weise zusammen. So wäre dies besser konzipiert als einfach sagen, wenn C niedriger Fall y gleich, drucken ja, sonst, wenn c Kapital Y entspricht, drucken ja, sonst, wenn c gleich lower-- in anderen Worten, Sie müssen nicht haben immer mehr Filialen. Sie können einige der äquivalenten kombinieren Zweige logisch, da auf diese Weise. 

Lassen Sie uns also auf nur einen Blick ein letzte Zutat, eine endgültige Konstrukt, daß C ermöglicht. Und wir werden in die zurückkommen noch andere Zukunft. Und dann werden wir schließen, indem Sie bei nicht die Richtigkeit der code-- immer Code work-- aber das Design von Code und pflanzen früh diese Samen. 

Also lassen Sie mich gehen Sie vor und Öffnen Sie eine neue Datei hier oben. Weißt du was? Ich werde neu implementieren das gleiche Programm, aber mit einem anderen Konstrukt. 

Also lassen Sie mich schnell selbst geben Zugang zu umfassen CS50.h für die CS50-Bibliothek, Standard io.h für printf. Gib mir meine int main nichtig. Und dann hier vorbei, lassen mich voran gehen und tun dies. 

Char c erhält char bekommen, genau wie zuvor. Und ich werde ein neues Konstrukt zu verwenden now-- wechseln, auf welchen Charakter? So Schalter ist eine Art, wie Schalten eines Bahngleisen. Oder wirklich, ist es eine Art von ein, wenn sonst, wenn sonst, wenn, aber etwas anders geschrieben. 

Ein Schalter sieht wie folgt aus. Sie haben Schalter, und dann, was Zeichen oder Nummer, die Sie wollen, zu betrachten, dann wie einige geschweiften Klammern in Scratch, nur sagen, diese Dinge zu tun. Und dann haben Sie verschiedene Fälle. 

Sie nicht, ob und anderes verwenden. Sie verwenden buchstäblich das Wort Fall. Und Sie würden so etwas wie dies sagen. 

So im Fall eines Klein y, oder im Falle einer Kapital Y, gehen Sie vor und drucken ja aus. Und dann brechen aus dem Schalter. Das ist es. Wir sind fertig. 

Else, wenn sozusagen, Kleinbuchstaben n, oder Kapital N, dann gehen Sie vor und drucken out nein, und dann brechen. Else-- und diese Art von ist die Standardfall indeed-- printf error-- und nur für eine gute Maßnahme, obwohl sie logisch dieser Bruch ist nicht notwendig, weil wir am Ende sind des Schalters sowieso, Ich breche jetzt der Schalter aus. So sieht das ein wenig anders. 

Aber logisch, es ist tatsächlich gleichwertig. Und warum würden Sie einen über den anderen? Manchmal nur eine persönliche Vorliebe, manchmal die Ästhetik, wenn ich auf dieser Blick Jetzt gibt es etwas um für die gesagt werden, Lesbarkeit des Codes. Ich meine, dagegen nie die Tatsache, dass diese Code ist neu für viele von uns im Zimmer. 

Aber es ist nur irgendwie hübsch. Sie sehen Klein y, Hauptstadt Y, Kleinbuchstaben n, Hauptstadt N Standard, es ist eine Art von gerade springt out bei Ihnen in einer Weise, dass, wohl, vielleicht Das vorherige Beispiel mit der ifs, und die vertikalen Balken, und die sonst ifs, vielleicht nicht haben. Also das ist wirklich eine Frage des persönlichen Wahl, wirklich, oder Lesbarkeit, des Codes. 

Aber in Bezug auf Funktionalität, lassen Sie mich gehen Sie vor und machen einen Schalter, Punkt slash Schalter und geben Sie jetzt in Klein y, Hauptstadt Y, Klein n, Hauptstadt N, David, versuchen Sie es erneut, denn das ist nicht ein einzelnes Zeichen. Lassen Sie uns tun x, Fehler, wie erwartet. Und logically-- und das ist etwas Ich möchte Sie ermutigen in general-- sogar obwohl wir kratzen nur die Oberfläche einiger dieser Funktionen. 

Und es könnte nicht offensichtlich sein, wenn Sie selbst sitzen auf der Tastatur gedrückt, wie funktioniert das? Was würde das tun? Das Schöne daran, mit ein Laptop oder Desktop oder Zugang an einen Computer mit einem Compiler, und mit einem Code-Editor wie diese, wird Ihnen diese Antwort fast immer kann Fragen nur für sich selbst, indem Sie versuchen. 

Zum Beispiel, wenn die rhetorische Frage bei der Hand waren, was passiert, wenn man vergessen Ihre break-Anweisungen? Was ist eigentlich ein sehr häufig, was zu tun, weil es nicht sieht wie Sie sie wirklich brauchen. Sie nicht ausfüllen wirklich Ihre dachte wie eine Klammer oder eine geschweifte Klammer tut. Fahren wir fort und neu kompilieren den Code und zu sehen. So stellen Sie Schalter, Punkt slash-Schalter. Lassen Sie uns Kleinbuchstaben eingeben y, die obere Fall ein. So tippte ich y. 

Das Programm sagte, ja, nein, Fehler, als ob änderte er seine Meinung. Aber es war eine Art, weil das, was passiert, mit einem Schalter ist der erste Fall, dass Spiel im Wesentlichen bedeutet, hey Computer, der gesamte Code darunter auszuführen. Und wenn Sie nicht sagen, Pause, oder Brechen Sie nicht sagen, oder nicht brechen sagen, der Computer wird die Luft zu sprengen durch alle diese Linien und führen Sie alle von ihnen bis es wird auf diese geschweiften Klammer. So sind die Bremsen sind in der Tat notwendig. Aber ein Essen zum Mitnehmen hier ist, wenn Im Zweifelsfall versuchen, etwas. Vielleicht ersten Code zu speichern, oder es in einer extra Datei speichern wenn Sie wirklich besorgt über vermasselt und mit sich zu erholen die Arbeit, die Sie wissen, arbeitet. 

Aber versuchen, die Dinge. Und seien Sie nicht so ängstlich, vielleicht, von dem, was der Computer tun könnte, oder, dass Sie vielleicht etwas zu Bruch geht. Sie können immer wieder zurück zu einem früheren Version. 

Also lassen Sie uns am Ende, indem Sie bei der Gestaltung des Codes. Wir haben diese Fähigkeit nun zu schreiben Bedingungen und Schreibschlaufen, und Variablen und Anruffunktionen. Also, ehrlich gesagt, sind wir Art zurück an wo wir waren vor einer Woche mit Scratch, wenn auch mit einem weniger überzeugenden Text Umwelt als Scratch ermöglicht. 

Beachten Sie aber, wie schnell haben wir erworben dass Vokabular, auch wenn es geht eine Weile zu nehmen zu sinken, so dass wir jetzt dieses Vokabular verwenden können Weitere interessante Programme zu schreiben. Und lassen Sie uns ein Baby Schritt nehmen auf das, wie folgt. Lassen Sie mich gehen Sie vor und schaffen hier eine neue Datei. 

Ich werde dies zu nennen prototype.c und einführen zum ersten Mal die Fähigkeit Ihre eigenen Funktionen zu machen. Einige von Ihnen haben könnten dies getan mit Scratch, wodurch Sie können erstellen Sie Ihre eigene benutzerdefinierte Blöcke in Scratch, und ziehen Sie sie dann an ihren Platz wo auch immer Sie in C. möchten Und in den meisten Programmierung Sprachen, können Sie genau das tun, dass-- eigene Funktionen machen, wenn sie nicht bereits vorhanden sind. 

So zum Beispiel, lassen Sie mich gehen Sie voran und umfassen CS50.h und umfassen Standard io.h, int main nichtig. Und jetzt haben wir ein Platzhalter bereit zu gehen. Ich halte Druck Dinge wie die Menschen heute die Namen. Und das fühlt sich like-- wäre nicht schön, wenn es waren eine Funktion Druck Namen genannt? Ich muss nicht printf verwenden. Ich muss mich nicht erinnern, alle Formatcodes. Warum kann ich nicht, oder warum hat nicht jemand vor mir, Erstellen Sie eine Funktion namens Druck Name, dass einige Namen, einfach druckt es aus? 

Mit anderen Worten, wenn ich sage, hey, Computer, geben Sie mir eine Zeichenfolge durch den Benutzer für eine solche stellen, über der String-Funktion des CS50. Hey, Computer, setzen Sie diese Zeichenfolge in die Variable in der linken Seite, und nennen es s. Und dann, hey Computer, gehen Sie voran und drucken Sie den Namen der Person, fertig. 

Jetzt wäre es schön sein, denn Dieses Programm, das treffend benannt, sagt mir, was es tun soll ist zu weise der Namen der Funktion. Lassen Sie mich gehen und Prototypen machen, ein. Und leider, das wird nicht fliegen. 

Prototype.c, Zeile 7, Zeichen 5, Fehler, implizite Deklaration Funktionsdruck Name wird in C99, C99 ungültig was bedeutet, eine Version von C das kam im Jahr 1999 heraus. Das ist alles. 

Also ich weiß nicht, was all dies bedeutet vor. Aber ich Fehler erkenne in rot. Das ist ziemlich offensichtlich. 

Und es scheint, dass mit der grüne Charakter hier, das Problem ist, mit Druck Name, offen paren s, in der Nähe paren, Semikolon. Aber implizite Erklärung Funktion haben wir kurz zuvor zu sehen. Das bedeutet einfach, dass Clang weiß nicht, was ich meine. 

Ich habe ein Wort des Vokabulars verwendet, dass es nie zuvor gelehrt gesehen oder wurde. Und so muss ich es lehren was diese Funktion bedeutet. Also werde ich voran gehen und das tun. 

Ich gehe voran zu gehen und zu implementieren meine eigene Funktion Drucken Name genannt. Und ich werde sagen, wie folgt, dass Er tut dies, printf, hallo, Prozent s, Backslash n, Name, Semikolon. So was habe ich gerade? 

So stellt sich heraus, um implementieren eine eigene Funktion, wir leihen Art von einigen die gleiche Struktur wie Haupt dass wir gerade gewesen für selbstverständlich gehalten, und ich weiß nur das Kopieren und Einfügen ziemlich viel, was Ich habe in der Vergangenheit geschrieben. Aber beachten Sie hier das Muster. Int, Main, Void, wir werden auseinander zu necken Es dauerte nicht lange, was das eigentlich bedeutet. 

Aber für heute, nur Beachten Sie die Parallelität. Void, Druckname, string name, so dass es ein lila-Schlüsselwort, das wir gehen zu beginnen Rückgabetyp aufrufen, den Namen die Funktion, und dann wird die Eingabe. Also, eigentlich können wir destillieren diese Art von wie letzte Woche so ist dies der Name oder die Algorithmus des Codes wir sind gehen write-- die Algorithmus zugrunde liegenden der Code wir gehen zu schreiben. 

Dies ist seine Eingabe. Dies ist seine Ausgabe. Diese Funktion, Print-Name ist entworfen, um eine Zeichenfolge zu nehmen genannt Namen, oder was auch immer, als Eingabe und dann nichtig. Es gibt nichts zurück, wie der String-oder bekommen int tut. Also es geht um mich wieder etwas zur Hand. Es ist nur ein zu haben, Nebenwirkung, sozusagen der Druck Namens einer Person. So bemerken, Zeile 7, I rufen Druckname kann. Zeile 10, kann ich definieren oder Druck Namen implementieren. Aber leider ist das nicht genug. 

Lassen Sie mich gehen Sie vor und neu kompilieren diese nach dem Speichern. Whoa, jetzt, ich habe es gemacht schlimmer noch, so scheint es. So implizite Erklärung Funktion Druckname ist ungültig. Und wieder gibt es mehr Fehler. Aber wie ich bereits darauf hingewiesen, auch wenn Sie mit überwältigt, oder ein wenig traurig zu sehen, so viele Fehler, konzentrieren sich nur auf die erste zunächst, weil es könnte haben eine kaskadierende Wirkung hatte. So C oder Clang Spezifischer immer noch nicht erkennt Druck Namen. 

Und das ist, weil Clang, von Design, ist eine Art von dumm. Es tut nur das, was Sie sagen, es zu tun. Und das tut sie nur so in der Reihenfolge in denen Ihnen sagen, es zu tun. 

So habe ich hauptsächlich auf der Linie vier definiert, wie wir haben ziemlich oft getan. Ich habe auf Druck Name definiert Zeile 10. Aber ich versuche zu verwenden, Druck Name auf der Linie sieben. 

Es ist zu früh, gibt es noch nicht. So konnte ich klug sein, und sein wie, OK, also spielen wir zusammen nur, und Druck Namen nach oben hier und neu kompilieren. Oh mein Gott. Es funktionierte. Es war so einfach wie das. 

Aber die Logik ist genau das. Sie müssen Clang lehren, was es zunächst wird durch die Funktion definiert wird. Dann können Sie es verwenden. Aber, ehrlich gesagt, das fühlt sich an wie ein rutschiger Abhang. 

Also jedes Mal, wenn ich laufen in ein Problem bin, ich habe gerade Gehen Sie den Code zu markieren und kopieren Ich schrieb, schneiden Sie es und fügen Sie ihn hier oben. Und sicher, wir könnten ersinnen einige Szenarien wo eine Funktion könnte brauchen eine andere zu nennen. Und man kann einfach nicht alle setzen Funktion über jedes andere. 

So stellt sich dort die aus eine bessere Lösung. Wir können verlassen diese sein. Und, ehrlich gesagt, ist es in der Regel schön, und bequem, und gutes Design setzen Haupt zuerst, weil wieder, wie Haupt wenn grüne Fahne geklickt haben, das ist die Funktion, die wird standardmäßig ausgeführt. So könnte man genauso gut setzen es an der Spitze der Datei, so dass, wenn Sie oder ein andere menschliche schaut auf die Datei Sie wissen, was los ist nur durch die Haupt erster Lesung. So stellt sich heraus, können wir sagen, Clang proaktiv, hey, Clang, auf der Linie vier, Ich verspreche, zu implementieren, eine Funktion namens Drucken Namen, die einen String namens Namen gab als Eingabe und kehrt nichts, Leere. Und ich werde um zu Umsetzung es später. 

Hier kommt Main. Haupt jetzt auf Linie 9 verwenden können Drucken Name weil Clang das heißt zu vertrauen, schließlich, wird sie die Definition begegnen der Umsetzung von Print-Name. Also nach meiner Datei zu speichern, lassen mich voran gehen und machen Prototyp, sieht dieses Mal gut. Dot Slash, Prototyp, lassen Sie mich gehen Sie vor und geben Sie einen Namen in. David, hallo David, Zamila, hallo Zamila, und in der Tat, jetzt funktioniert es. 

So ist die Zutat hier ist, dass wir haben machte eine benutzerdefinierte Funktion, wie eine benutzerdefinierte Scratch Block Wir nennen es. Aber im Gegensatz zu Scratch, wo man schaffen es einfach und starten Sie es, jetzt müssen wir sein, wenig mehr pedantisch, und tatsächlich trainieren Clang zu verwenden, oder es erwarten. Nun, so nebenbei, warum all dieser Zeit haben wir auf den Glauben nur blind gewesen einschließlich CS50.h, einschließlich Standard io.h? 

Nun, es stellt sich heraus, unter ein paar andere Dinge, all das ist in diesen Punkt h Dateien, die Dateien sein passieren. Sie sind Header-Dateien, so zu sprechen. Sie sind immer noch in C geschrieben, aber sie sind eine andere Art von Datei. 

Denn jetzt können Sie ziemlich viel davon ausgehen, dass alles, was im Inneren des CS50.h ist dies ist einige Einzeiler wie, nicht für Funktionen Drucken Name genannt wird, aber für String erhalten, erhalten Float, und ein paar andere. Und es gibt ähnliche Prototypen Einzeiler, innerhalb von Standard-io.h für printf, die jetzt in meine eigene Name in Druckfunktion. Also mit anderen Worten, diese ganze Zeit, die wir haben gerade blind zu kopieren und einfügen umfassen diese, sind dass, was los ist auf? Das sind nur Art von Hinweisen zu klappern, was Funktionen nur sind in der Tat umgesetzt, anderswo in verschiedenen Dateien an anderer Stelle im System. 

Deshalb haben wir Druck Namen umgesetzt. Es hat diese Nebenwirkung von Druck etwas auf dem Bildschirm. Aber es funktioniert nicht wirklich gib mir etwas zurück. Wie gehen wir damit um Umsetzung eines Programms, das nicht gib mir etwas zurück? 

Nun, lassen Sie uns dies versuchen. Lassen Sie mich gehen Sie vor und implementieren eine Datei namens return.c so können wir zeigen, wie etwas wie Get String, oder Get Int, ist eigentlich der Rückkehr etwas zurück an den Benutzer. Fahren wir fort und int main Leere definieren. 

Und wieder in die Zukunft, werden wir erklären, was das int und diese Lücke ist tatsächlich tun. Aber für heute, werden wir ist es selbstverständlich. Ich gehe voran und printf zu gehen, für eine gute User Experience, x. Und dann werde ich für die warten Benutzer geben mir x mit get int. 

Und dann gehe ich voran gehen und ausdrucken x zum Quadrat. Also, wenn Sie nur eine haben Tastatur, Menschen häufig Verwenden Sie die kleine Karotte Symbol auf der Tastatur an die Strom darzustellen von oder der Exponent. So x zum Quadrat vorhanden ist i. 

Und jetzt werde ich das tun. Ich konnte do-- genau das, was ist x kariert? x squared x mal x. 

Und wir haben dies einige Zeit schon vor heute. Das fühlt sich nicht wie alle, die viel Fortschritt. Weißt du was? Lassen Sie uns nutzen einige dieser Idee vom letzten Mal der Abstraktion. 

Wäre es nicht schön, wenn gibt es eine Funktion namens Platz, der genau das tut? Es immer noch am Ende der Tag, hat die gleiche Mathematik. Aber lassen Sie uns abstrakt die Idee der wegzunehmen eine Zahl, multipliziert mit eine andere, und geben Sie es nur einen Namen, wie diesen Wert Quadrat. 

Und, in anderen Worten, in C, lassen Sie uns eine Funktion erstellen, genannt Quadrat, das genau funktioniert das. Es wird Platz genannt zu werden. Es wird ein int zu nehmen. Und wir werden nur wird nennen es n, standardmäßig aktiviert. 

Aber wir konnten es nennen, was wir wollen. Und alles, was es wird tun, buchstäblich, ist Rückkehr das Ergebnis von n mal n. Sondern weil es Rückkehr etwas, was ist das Schlüsselwort in lila wir haben noch nie gesehen, ich, auf der Linie 11, Diese Zeit kann nicht einfach sagen, nichtig. 

Void wir im Beispiel gerade gesehen eher von Druckname, bedeutet nur, mach etwas. Aber gib mir nicht etwas zurück. In diesem Fall, ich will zurückzukehren n mal n, oder was auch immer das ist, wird diese Zahl. 

So kann ich nicht sagen, hey, Computer, Ich kehre nichts, nichtig. Es geht zurück, von der Natur, ein int. Und so ist das alles, was hier los ist. 

Der Eingang zum Quadrat wird ein int sein. Und damit wir es verwenden können, muss es haben einen Namen, gehen Es N. ausgeben ein int, die keinen Namen brauchen. Wir können es zur Haupt verlassen, oder wer auch immer ist mit mir diesen Wert, wenn wir uns erinnern wollen mit einer eigenen Variablen. 

Und wiederum das einzige neue Stichwort hier ist zurück. Und ich mache nur etwas Mathematik. Wenn ich wirklich sein wollte unnötig, Ich könnte sagen, int Produkt wird n mal n. 

Und dann könnte ich sagen, Produkt zurück. Aber noch einmal, um meinen Standpunkt früher von dies einfach nicht gut zu sein design-- wie, warum Sie einen Namen einführen, ein Symbol, wie Produkt, nur, um sofort darauf zurückkommen? Es ist ein wenig sauberer, ein wenig fester, so zu sprechen, nur Rückkehr n-mal zu sagen, n, loszuwerden ganz von dieser Linie. 

Und es ist nur weniger Code zu lesen, weniger Gelegenheit für Fehler. Und lassen Sie uns, wenn diese sehen tatsächlich funktioniert jetzt. Nun, ich werde gehen und im voraus zu machen Rückkehr. 

Uh-oh, implizite Deklaration der Funktion. Ich habe diesen Fehler vor, keine große Sache. Lassen Sie mich nur ein, oder markieren und zu kopieren, die genau die gleiche Funktionsprototyp, oder Unterschrift der Funktion hier oben. Oder ich könnte die ganze Funktion zu bewegen. 

Aber das ist ein wenig faul. So werden wir das nicht tun. Nun lassen Sie mich machen Rückkehr wieder, Dot Slash Rückkehr. 

x 2 x zum Quadrat ist 4. x 3 x zum Quadrat ist 9. Und die Funktion scheint jetzt zu arbeiten. Also, was ist der Unterschied hier? Ich habe eine Funktion, die Platz genannt wird, in diesem Fall, die ich in einem Eingang setzen. Und ich bekomme eine Ausgabe zurück. Und doch vorher, wenn Ich öffne das andere Beispiel von früher, die war genannt prototype.c, Ich hatte Druck Name, der zurück Leere, so zu sprechen, Oder es gab nichts zurück, und einfach hatte einen Nebeneffekt. 

Also, was ist hier los? Nun, betrachten die Funktion erhalten Zeichenfolge nur für einen Moment. Wir haben mit der Funktion erhalten Zeichenfolge in folgender Weise. 

Wir haben eine Funktion hatte bekommen string, wie umfassen CS50.h, gehören Standard-io.h, int, Haupt, nichtig. Und dann jedes Mal, ich habe also der String-weit genannt, Ich habe gesagt, so etwas wie: string s bekommt String zu erhalten, weil get string-- Nennen wir diese get.c-- get-String selbst gibt eine Zeichenfolge, die ich kann, dann verwenden, und sagen, hallo, Komma, Prozent s, Backslash n, s. 

Das ist also das gleiche Beispiel, wirklich, dass wir früher hatten. So erhalten Zeichenfolge einen Wert zurückgibt. Aber einen Moment vor, Druckzeichenfolge keinen Wert zurück. Es hat einfach eine Nebenwirkung. Also das ist ein fundamentaler Unterschied. Wir haben verschiedene gesehen Arten von Funktionen jetzt, einige davon sind zurückgekehrt Werte, zu tun, von denen einige nicht. Also vielleicht ist es ein String oder int oder float. Oder vielleicht ist es nur Leere. 

Und der Unterschied ist, dass diese Funktionen, Abrufen von Daten und einen Wert zurückgeben sind eigentlich etwas zurück an den Tisch zu bringen, sozusagen. Also lassen Sie uns fortfahren und Blick auf einen letzten Satz Beispiele, die einen Sinn gibt, jetzt, von wie wir könnten, ja, abstrakt besser, und besser und besser, oder mehr, und mehr und mehr, um letztlich besseren Code zu schreiben. Fahren wir fort, und im Geiste von Scratch, gehen Sie wie folgt. 

Lassen Sie mich gehen Sie vor und schließen CS50.h und Standard io.h Lassen Sie mich gehen Sie vor und geben selbst ein int, Haupt, nichtig. Und lassen Sie mich gehen Sie vor, um dieses cough.c nennen. 

Und lassen Sie mich voran gehen und einfach wie Scratch, Husten / n ausdrucken. Und ich möchte dies dreimal zu tun. Also habe ich, natürlich, gerade dabei zu kopieren und dreimal einfügen. Ich gehe jetzt zu machen Husten dot slash Husten. Lassen Sie uns geben mir ein wenig mehr Platz Geben Sie hier, Husten, Husten, Husten. 

Es gibt offensichtlich bereits ein Chance für Verbesserungen. Ich habe kopiert und eingefügt ein paar Mal heute. Aber das war nur so habe ich nicht haben so viele Zeichen eingeben. Ich änderte noch was diese Zeilen Code sind. 

Diese drei Leitungen sind identisch, das fühlt sich faul und in der Tat, und ist wahrscheinlich nicht der richtige Ansatz. Also mit welcher Zutat konnten wir diesen Code verbessern? Wir müssen nicht Code kopieren und einfügen. 

Und in der Tat, Sie jederzeit das Gefühl, selbst kopieren und einfügen, und nicht einmal Wechselcode, Chancen gibt es einen besseren Weg gibt. Und in der Tat gibt es. Lassen Sie mich gehen Sie vor und tun eine for-Schleife, obwohl die Syntax möglicherweise nicht kommen natürlich noch. 

Tun Sie dies dreimal, einfach durch die following-- tun und ich geschehe dies aus der Praxis kennen zu lernen. Aber wir haben eine Reihe von Beispielen jetzt. Und Sie werden sehen Online Weitere Referenzen noch. 

Dies ist die Syntax in Zeile 6, dass ähnlich wie Kratzer, der sich wiederholt Block, wiederholen Sie die folgenden drei Mal. Es ist ein wenig magisch für jetzt. Aber das wird mehr bekommen, und mehr vertraut. 

Und es wird zu wiederholen Linie acht dreimal, so dass, wenn ich Make Husten neu kompilieren, dot slash Husten, Husten, Husten, Husten. Es funktioniert immer noch auf die gleiche Weise. Also das ist alles schön und gut. Aber das ist nicht sehr abstrahiert. 

Es ist völlig richtig. Aber es fühlt sich dort wie könnte eine Gelegenheit sein, wie in der Welt der Scratch, um Art von Start einige Semantik hier hinzufügen, so dass Ich habe nicht nur einige for-Schleife, und eine Funktion, die sagt, Husten, oder nicht husten. Weißt du was? Lassen Sie mich versuchen, eine zu sein etwas kühler als das, und schreiben tatsächlich eine Funktion, die einige Nebenwirkungen hat, nennen sie husten. 

Und es braucht keine Eingabe und gibt keinen Wert zurück als Ausgabe. Aber Sie wissen, was es tut? Es tut this-- printf, Zitat unquote, husten. 

Und jetzt hier oben, ich werde voraus und für int zu gehen, i bekommt Null, ich weniger als 3, i plus plus. Ich gehe nicht printf zu tun, das ist wohl eine geringe Umsetzung Detail. Mir ist es egal, wie zu husten. Ich möchte nur die Husten-Funktion zu verwenden. Und ich werde nur Husten zu rufen. 

Nun bemerken die Dichotomie. Wenn Sie eine Funktion aufrufen, wenn Sie nicht tun wollen sie die Eingänge zu geben, völlig in Ordnung. Just do offenen paren, in der Nähe paren, und du bist fertig. 

Wenn Sie eine Funktion definieren, oder deklarieren eine Prototyp der Funktion, Wenn Sie im Voraus wissen, ist es nicht gehen alle Argumente zu nehmen, in diesen Klammern dort nichtig sagen. Und das macht Sie sicher, dass Sie nicht versehentlich missbrauchen. Lassen Sie mich gehen Sie vor und Husten zu machen. Und natürlich, ich habe einen Fehler gemacht. 

Verdammt, es ist das implizite Deklaration. Aber das ist in Ordnung. Es ist eine einfache Lösung. Ich brauche nur der Prototyp höher in meiner Akte, als ich es bin mit wirklich. 

So, jetzt lassen Sie mich Husten wieder machen, nett. Jetzt funktioniert es. Machen Sie Husten, Husten, Husten, Husten. So könnte man denken, dass wir wirklich nur über Engineering dieses Problem. Und in der Tat sind wir. Dies ist keine gute Kandidat eines Programms im Moment für Refactoring, und tun, was genannt hierarchische Zerlegung, wo Sie einen Code nehmen, und dann Sie Art von Faktor Dinge, so wie mehr Semantik ihnen zuschreiben, und wieder verwenden es letztlich längere Sicht. Aber es ist ein Baustein in Richtung anspruchsvollere Programme dass wir beginnen, Schreiben vor lange, dass ermöglicht es uns, das Vokabular zu haben mit dem besseren Code zu schreiben. Und in der Tat, mal sehen, ob wir kann diese nicht weiter verallgemeinern. 

Es scheint ein wenig lahm, dass ich, hauptsächlich, müssen über diese verflixte for-Schleife zu sorgen, und ruft Husten wieder und wieder. Warum kann ich nicht einfach sagen, Husten, bitte Husten dreimal? Mit anderen Worten kann, warum nicht nur ich geben Eingang zu husten und das tun? 

Warum kann ich nicht einfach sagen, in Haupt Husten dreimal. Und nun, dies ist eine Art magisch. Es ist sehr iterative hier. Und es ist tatsächlich ein Baby Schritt. 

Aber nur die Fähigkeit, zu sagen, Linie acht, drei Mal husten, es ist einfach so viel besser lesbar. Und, und, ich muss nicht wissen, oder egal, wie Husten umgesetzt wird. Und in der Tat, später in der Begriff und für Abschlussarbeiten, wenn Sie ein Projekt mit anpacken ein Mitschüler oder zwei Mitschülern, Sie erkennen, dass Sie gehen zu müssen oder wollen, die Arbeit teilen. 

Und Sie gehen zu wollen, um zu entscheiden, im Voraus, was tun wird, die, und in dem Stück? Und wäre es nicht schön, Wenn Sie, zum Beispiel, nehmen Schreibhaupt, fertig. Und Ihre Mitbewohner oder Ihr Partner allgemeiner, kümmert Husten umzusetzen. 

Und diese Spaltung, diese Wände der Abstraktion, oder Abstraktionsebenen, wenn Sie sind superstarken, weil vor allem für größere, komplexeren Programmen und Systemen, es können mehrere Personen zu bauen Dinge zusammen, und schließlich nähen ihre Arbeit auf diese Weise zusammen. Aber natürlich, wir müssen jetzt Husten zu beheben. Wir brauchen Husten zu sagen, dass, hey, weißt du was? Sie gehen ein zu ergreifen müssen, input-- so nicht leer, sondern int und jetzt. Fahren wir fort und in Husten die int. i bekommt Null. 

i kleiner als wie oft. Ich sagte, drei vor. Aber das ist nicht das, was ich will. Ich möchte husten verallgemeinert werden jede Anzahl von Iterationen zu unterstützen. 

Also, ja, es ist n, die ich will, was auch immer der Benutzer sagt mir. Jetzt kann ich voran gehen und Druck Husten sagen. Und egal, welche Zahl der Benutzer übergibt, Ich werde wiederholen, dass viele Male. 

So dass am Ende des Tages, Programm ist identisch. Aber beachten Sie all dieses Zeug könnte sogar in einer anderen Datei sein. Tatsächlich weiß ich nicht, bei der Moment, wie printf implementiert. 

Ich weiß im Moment nicht, wie bekommen String oder int bekommen oder bekommen Schwimmer implementiert. Und ich will nicht sehen, wie sie auf meinem Bildschirm. Wie es ist, beginne ich zu konzentrieren mein Programm, nicht jene Funktionen. 

Und so, in der Tat, sobald Sie Factoring-Code wie folgt beginnen, könnten wir sogar Husten bewegen in einer separaten Datei? Jemand anderes könnte es zu implementieren. Und Sie und Ihr Programm werden die sehr schön, und sehr gut lesbar, wohl, wirklich vier Zeilenprogramm recht. 

Also lassen Sie uns fortfahren jetzt und eine weitere Änderung vornehmen. Beachten Sie, dass mein Prototyp muss bis oben ändern. Lassen Sie mich also, dass beheben, so Ich werde nicht schrie. 

Machen Sie Husten, lassen Sie mich laufen Husten einmal mehr, immer noch tun, die gleiche Sache. Aber jetzt, bemerken wir haben eine Zutat für eine endgültige Version. Weißt du was? Ich will nicht nur Husten, unbedingt. Ich möchte etwas allgemeinere haben. So wissen Sie was? Ich möchte das machen. Ich will haben, ähnlich wie Scratch der Fall ist, ein Mitsprache Block, aber nicht nur etwas sagen, eine bestimmte Anzahl von Zeiten. Ich will es eine ganz bestimmte Zeichenfolge zu sagen. Und deshalb kann ich nicht will es nur Husten sagen. Ich will es sagen, was String wird eingeleitet. 

So bemerken, ich habe verallgemeinert dies so, dass nun sagen wir fühlt sich wie ein guter Name für diese, wie Scratch, nimmt zwei Argumente, im Gegensatz zu Scratch. Eine davon ist eine Zeichenfolge. Einer ist ein int. 

Und ich konnte ihnen wechseln. Ich bin ein bisschen wie die Idee sagen die Zeichenfolge zuerst, und dann wie oft später. Void bedeutet es noch gibt nichts zurück. Dies sind nur visuelle Seite Effekte, wie bei [? Jordan,?] eine mündliche Nebenwirkung von Schreien. Es tut immer noch mal etwas n, 0 bis, aber n nicht gleich. Das bedeutet, n Gesamtzeiten. Und dann drucken gerade aus was auch immer, dass String ist. Also ich habe wirklich generali Diese Codezeile. So, jetzt, wie kann ich umsetzen der Husten-Funktion? 

Ich kann Leere Husten tun. Und ich kann noch dauern, wie oft wollen Sie zu husten. Aber weißt du was? Ich kann jetzt sagen Punt. 

Ich kann mit dem Aufruf sagen Wort Husten, in n übergeben. Und wenn ich möchte auch implementieren, nur zum Spaß, ein Niesen Funktion, Ich kann eine gewisse Anzahl, wie oft niesen. Und ich kann n halten die Wiederverwendung, weil bemerken, dass m in diesem Zusammenhang oder Umfang existiert nur in dieser Funktion. 

Und n nur in diesem Zusammenhang Hier besteht in dieser Funktion. So kommen wir zurück zu diese Fragen Spielraum. Und hier, ich werde einfach sagen, achoo, und dann n-mal, Semikolon. 

Und jetzt, ich muss nur leihen diese Funktion Signaturen hier oben. So ist Husten richtig. Void niesen ist jetzt korrekt. 

Und ich muss immer noch nur sagen. Also werde ich sagen, sagen wir string s, int n, Semikolon. Also ich habe over-engineered die Heck aus diesem Programm. 

Und dies nicht bedeutet notwendigerweise das ist was Sie tun sollten, wenn das Schreiben selbst die einfachsten Programme. Nehmen Sie etwas, das ist offensichtlich wirklich einfach, wirklich kurz, und neu zu implementieren es mit viel zu viel Code. Aber Sie werden tatsächlich sehen, und in Zeit schauen auf diese Beispiele zurück, und erkennen, oh, das sind die Schritte wir haben tatsächlich zu verallgemeinern, Faktor etwas aus, bis zum Ende des Tages mein Code ist eigentlich ziemlich vernünftig. Denn wenn ich will drei husten mal dann dreimal niesen, Ich bin einfach so gehen erneut auszuführen, Programm machen Husten, und führen Sie Husten. Und ich habe drei Husten und drei niest. 

Und so ist dies ein grundlegendes Paradigma, wenn man so will, denn wie wir gehen könnte über Umsetzung tatsächlich ein Programm. Aber lassen Sie uns sehen, gerade jetzt, was es ist wir haben alle von dieser Zeit getan, und was sind einige der letzten Teile diesem einfachen Befehl sind hinter. Am Ende des Tages, haben wir mit Clang als unser Compiler gewesen. Wir haben Quelle schreiben Code, sie zu konvertieren über Clang in Maschinencode. 

Und wir haben gerade machen unter Verwendung von unsere Tastatureingaben zu erleichtern, so dass wir müssen nicht erinnern diese Beschwörungen von Clang selbst. Aber was ist eigentlich machen zu tun? Und wiederum, was Clang tatsächlich tun? 

Es stellt sich heraus, obwohl wir vereinfacht die heutige Diskussion mit den Worten: Sie Quellcode nehmen, übergeben Sie es als Eingang zu einem Compiler, der Sie gibt Ausgabe von Maschinen Code, stellt sich heraus, es gibt ein paar verschiedene Schritte im Inneren befindet. Und Compilierung geschieht der Schirm zu sein Bezeichnung für eine ganze Reihe von Schritten. Aber lassen Sie uns nur ärgern dies heraus wirklich schnell. 

Es stellt sich heraus, dass wir getan haben mehr Dinge jedes Mal wenn ich ein Programm ausführen, oder jedes Mal, wenn ich ein Programm heute kompilieren. So Vorverarbeitung bezieht sich auf this-- alles in einem C-Programm, wie wir sehen immer wieder, das beginnt mit diesem Hash-Symbol, oder das Hashtag Symbol bedeutet hier es ist eine Präprozessordirektive. Das heißt, in diesem Fall He Computer, tun Sie etwas mit dieser Datei bevor Sie meinen eigenen Code tatsächlich kompilieren. 

In diesem Fall Hash umfassen heißt, im Wesentlichen, C Art zu sagen, hey Computer, gehen die Inhalte bekommen von CS50.h und fügen Sie sie hier. Hey Computer, gehen Sie bekommen die Inhalte von Standard io.h, wo immer das auch auf die Festplatte, fügen Sie ihn hier. Also diese Dinge passieren zuerst während der Vorverarbeitung. 

Und Clang tut alles für uns. Und es tut so verdammt schnell, tun Sie nicht einmal sehen vier verschiedene Dinge passiert. Aber das ist der erste derartige Schritt. 

Was passiert eigentlich als nächstes? Nun, die nächste offizielle Schritt kompiliert. Und es stellt sich heraus, dass Kompilieren eines Programms technisch bedeutet, sich aus Quellcode, die Sachen, die wir haben geschrieben heute, etwas zu Assembler-Code genannt wird, etwas das sieht ein wenig anders. 

Und in der Tat, können wir dies wirklich schnell zu sehen. Lassen Sie mich gehen tatsächlich in meine IDE. Lassen Sie mich gehen Sie vor und öffnen hello.c, die ist das erste Programm, mit dem wir heute begann. Und lassen Sie mich voran gehen und laufen Clang ein wenig anders, Clang-s, hello.c, welche ist eigentlich los zu Gib mir noch eine Datei hello.s. 

Und wir werden wahrscheinlich nie wieder sehen diese Art von Code. Wenn Sie eine niedrigere Stufe zu nehmen Systeme Klasse wie CS61, Sie werden viel mehr sehen dieser Art von Code. Aber dies ist in Assemblersprache. Dies ist X86 Assembler-Sprache dass die CPU, die zugrunde liegende CS50 IDE versteht eigentlich. 

Und kryptisch wie es funktioniert aussehen, es ist etwas, der Computer versteht ziemlich gut. Sub q, ist dies ein subtrahieren. Es gibt Bewegungen. 

Es ist hier von Funktionen aufrufen, x oring, eine Bewegung, ein Add, ein Pop, eine Rückgabe. So gibt es einige sehr niedrigen Niveau Anweisungen dass CPUs verstehen, dass Ich spielte auf früher. Das ist, was Intel Inside. 

Es gibt Muster von Nullen und Einsen, dass Karte auf diese arcanely formuliert, aber etwas gut genannt, Anweisungen, sozusagen. Das ist, was passiert, wenn Sie Ihren Code kompilieren. Sie erhalten Montage aus der es die Sprache, die bedeutet, dass der dritte Schritt zu montieren ist, dass Assembler-Code in letztlich Maschine code-- Nullen und Einsen, nicht die Text, den wir noch vor einem Moment sah. 

So Vorverarbeitung bedeutet das finden und ersetzen, und ein paar andere Dinge. Compilieren nimmt Ihre Quelle Code aus C, Quellcode dass wir geschrieben haben, bis hin zur Montage Code, den wir in nur einen Blick zu. Montage nimmt diese Montage Code zu Nullen und Einsen wirklich, dass die CPU verstehen, am Ende des Tages. Und Verknüpfung ist der letzte Schritt das geschieht für us-- wieder, so schnell tun wir nicht einmal notice-- das sagt, hey Computer, nehmen Sie alle die Nullen und Einsen, dass führte Davids Code kompilieren, und seine Hauptfunktion in diesem Fall. 

Und hey Computer, gehen Sie bekommen alle der Nullen und Einsen dass das CS50 Personal schrieb in der CS50-Bibliothek. diejenigen, die in mit Davids mischen. Und hey Computer, gehen alle Nullen erhalten und diejenigen, die jemand anderes geschrieben Jahre vor für printf. Und die in der hinzufügen Ganze, so dass wir haben habe meine Nullen und Einsen, die CS50 Mitarbeiter Nullen und Einsen, die printf Nullen und Einsen, und alles, was wir verwenden. 

Sie alle bekommen kombiniert zusammen in einem Programm genannt, in diesem Fall, hallo. Also von nun an werden wir nur das Wort Compilierung. Und wir werden selbstverständlich ist, dass, wenn wir sagen, kompilieren Ihr Programm, bedeutet dies, hey tun, um die Pre-Processing, Montage und verknüpfen. Aber es gibt tatsächlich einige saftige Zeug geht es unter der Haube. Und vor allem, wenn Sie erhalten neugierig einige Zeit, können Sie beginnen, Stossen um auf diesem niedrigeren Niveau. Aber jetzt erkennen, dass unter den Take-away für heute sind ganz einfach die Beginn eines Prozesses, der, sich mit so etwas wie Hallo Welt. Tatsächlich sind die meisten von dem, was wir haben heute wird sicherlich nicht super schnell sinken in. Und es dauert einige Zeit, und einige Übung. Und Chancen sind, werden Sie sortieren von möchten, dass Ihre Tastatur zu treffen oder schreien auf den Bildschirm. Und all das ist in Ordnung. Obwohl vielleicht versuchen, nicht zu tun sie so viel in der Bibliothek. 

Und schließlich werden Sie obwohl der Lage sein, zu starten Muster, sowohl in guten Code zu sehen dass Sie geschrieben haben und in Fehler dass Sie gemacht haben. Und ähnlich wie der Prozess der ein TF oder ein CA zu werden, ist wie, Sie beginnen, um besser zu werden und besser auf diese Muster zu sehen, und die Lösung einfach Ihre eigene Probleme letztlich. In der Zwischenzeit wird es viel sein von uns, Ihnen Unterstützung zu gewähren, und erhalten Sie durch dies. Und in den Zuschreibungen für alle Probleme werden Sie durch geführt werden alle Befehle dass ich weiß mit Sicherheit aus eine Menge Übung jetzt, aber vielleicht haben geflogen den Kopf über vorerst. Und das ist völlig in Ordnung. 

Aber letztlich, du gehst beginnen Muster zu sehen entstehen. Und wenn Sie all das bekommen Vergangenheit dummen Details, wie Klammern, und geschweiften Klammern und Semikolons, und das Zeug, ehrlich gesagt, das ist nicht bei allen intellektuell interessant. Und es ist nicht das Ziel, jede einleitende Klasse. Es sind die Ideen, die die Materie gehen. 

Es ist die Schleifen und die Bedingungen, und die Funktionen, und stärker die Abstraktion, und das Factoring von Code, und das gute Design und die gute Stil, und schließlich die Richtigkeit schließlich des Codes, das ist gehen die meisten auf die Materie. Also das nächste Woche, werden wir diese Ideen, die wir zum ersten Mal in Scratch sah und haben nun übersetzt C. Und wir beginnen einzuführen, um die erste der Natürlich aus der realen Welt-Domänen. 

Wir werden uns auf die Welt der Sicherheit konzentrieren, und insbesondere die Kryptographie, die Kunst der Informationen kriechen. Und unter den ersten Probleme, die Sie selbst erhalten darüber hinaus zu schreiben mit einigen der Syntax spielen und die Lösung einige logische Probleme, schließlich dauerte nicht lange, ist zu krabbeln tatsächlich, oder zu verschlüsseln, und entschlüsseln letztlich Informationen. Und alles, was wir getan haben, Heute werden ziemlich niedrig Ebene, wird sich nur erlauben uns ein zu nehmen, und eine, und einen weiteren Schritt in Richtung oben Schreiben der interessanteste Code noch. 

Also mehr dazu nächste Woche. 

[VIDEO-WIEDERGABE] 

-Wie Können Sie mir sagen, über das letzte Mal, wenn Sie ihn gesehen? -Wie Kann ich sagen, wirklich? Ich meine, es war wie jedes andere Vorproduktion Probe, außer dass es etwas war, sagte er ganz am Ende, die mit mir stecken. 

-Das War CS50. 

-Das Ist ein Schnitt jeder, gute Arbeit auf Probe. 

-Das Ist das Mittagessen? 

-Ja, Du und ich schnappen Sie sich einen Sandwich in einem Bit. Lassen Sie mich Nachbesprechung nur mit David wirklich schnell. David? David? 

[END WIEDERGABE] 