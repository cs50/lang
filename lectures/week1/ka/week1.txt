[მუსიკის დაკვრა] დევიდ ჯ Malan: ყველა უფლება, ეს არის CS50. და ეს არის კვირაში ერთი. ასე რომ გავიხსენოთ, რომ ბოლო დროს კვირაში ნულოვანი, ჩვენ ორიენტირებულია კომპიუტერული აზროვნება. ჩვენ transitioned საწყისი, რომ ნულიდან, გრაფიკული პროგრამირების ენის ჩვენი მეგობრები at MIT- ის მედია ლაბორატორია. 

და Scratch, ჩვენ არ შეისწავლონ იდეები მოსწონს ფუნქციები და პირობები, და მარყუჟების და ცვლადები, და კიდევ მოვლენები, და თემა, და სხვა. და დღეს ჩვენ ვაპირებთ გაგრძელდება გამოყენებით იმ იდეებს, და მართლაც ხდება მათ თავისთავად, მაგრამ თარგმნა მათ სხვა ენა ცნობილია, როგორც C. ახლა, C არის უფრო ტრადიციული ენაზე. ეს ქვედა დონეზე ენის, თუ გნებავთ. 

ეს არის წმინდა ტექსტური. ასე რომ, ერთი შეხედვით, ეს ყველა აპირებს გამოიყურება საკმაოდ cryptic თუ თქვენ არასდროს დაპროგრამებულია ადრე. ჩვენ ვაპირებთ, რომ აქვს ნახევრად colons და ფრჩხილებში, და Curly braces, და სხვა. მაგრამ გააცნობიეროს, რომ მაშინაც კი, მიუხედავად იმისა, რომ სინტაქსი შესახებ გამოიყურებოდეს ცოტა უცნობ ყველაზე მეტად თქვენ, ვხედავ წარსულში რომ. და ცდილობენ, რომ იდეები რომ, მართლაც, ნაცნობი, იმიტომ, რომ აქ კვირაში ერთი, რა ჩვენ დავიწყოთ უნდა გავაკეთოთ, არის შედარება, თავდაპირველად, Scratch წინააღმდეგ C. 

ასე, მაგალითად, გავიხსენოთ, რომ, როდესაც ჩვენ განხორციელებული პირველი ჩვენი პროგრამების ბოლო დროს, ჩვენ გვქონდა ბლოკი, რომელიც ჩანდა პატარა რაღაც ამას, როდესაც მწვანე დროშა დააწკაპებთ, და მაშინ ჩვენ გვქონდა ერთი ან მეტი თავსატეხი ცალი ქვემოთ, ამ შემთხვევაში, ვთქვათ, hello მსოფლიოში. ასე რომ, მართლაც, Scratch, როდესაც მე დააჭირეთ რომ მწვანე დროშა აწარმოებს ჩემი პროგრამა, ასე რომ, ვთქვათ, ეს არის ბლოკები, რომ შესრულებული, ან აწარმოებს. და, კონკრეტულად, Scratch განაცხადა, hello, world. 

ახლა, მე ვერ მითითებული სხვადასხვა სიტყვა აქ. მაგრამ ჩვენ ვხედავთ, რომ, მართლაც, ბევრი ამ blocks-- და მართლაც, in C მრავალი ფუნქციები შეიძლება იყოს parametrized ან ადრინდელს გავაკეთოთ სხვადასხვა რამ. ფაქტობრივად, C, თუ ჩვენ აკონვერტირებთ, ახლა, ამ Scratch პროგრამა ამ სხვა ენაზე ჩვენ ვაპირებთ, რომ დაწერა პატარა რაღაც მსგავსი. 

უნდა აღინიშნოს, რომ არსებობს გარკვეული უცნობ სინტაქსი არ სავარაუდოდ, int, და ფრჩხილებს და ბათილად. მაგრამ printf-- მიუხედავად იმისა, რომ თქვენ ამას ვფიქრობ, რომ ეს იყოს მხოლოდ ბეჭდვა. მაგრამ ბეჭდვის ნიშნავს ბეჭდვითი დაფორმატდა, როგორც ჩვენ მალე. ეს ფაქტიურად ბეჭდვა ეკრანზე რასაც არის შიგნით იმ ფრჩხილებში, რომელიც რა თქმა უნდა, ამ შემთხვევაში, hello მსოფლიოში. 

მაგრამ თქვენ შეამჩნევთ სხვა სინტაქსი, ორმაგი შეთავაზებები, რომ ფრჩხილებში ბოლოს, ნახევრად მსხვილი ნაწლავის და მოსწონს. ასე რომ, ცოტა ოვერჰედის, ასე ვთქვათ, როგორც კოგნიტიური და სინტაქსურად, რომ ჩვენ ვაპირებთ უნდა გვახსოვდეს, რომ ხანგრძლივი. მაგრამ გვესმის, რომ პრაქტიკაში, ეს დაიწყებს გადმოხტა თქვენ. 

ფაქტობრივად, მოდით ფოკუსირება, რომ ერთი ფუნქცია კონკრეტულად ამ შემთხვევაში, მიესალმები მსოფლიოში. ასე რომ ვთქვათ, არის ფუნქცია. Hello world მისი პარამეტრი, ან არგუმენტი, მისი დაკონფიგურირება. 

და ეკვივალენტურობის C მხოლოდ იქნება ეს ერთი ხაზი აქ, სადაც printf უდრის, ვთქვათ, ორმაგი ციტირებული სტრიქონი, hello მსოფლიოს უდრის, რა თქმა უნდა, რა არის თეთრი ყუთი იქ. და წარმატებული ო, თუმცა ცოტა უცნაური და არ არსებობს Scratch, უბრალოდ აპირებს აქვს ეფექტი ჩვენ გამოგიგზავნით ხედავთ კომპიუტერი, ისევე როგორც ჩემი Mac ან PC, მხოლოდ მოძრავი კურსორი მომდევნო ხაზი. ეს იგივეა, hitting შეიყვანეთ თქვენს კლავიატურაზე. 

ასე რომ, ჩვენ ვხედავთ, რომ კიდევ დიდი ხნის განმავლობაში. მაგრამ პირველი, მოდით შევხედოთ ამ სხვა, მაგალითად, იმ შემთხვევაში, მარყუჟების. ჩვენ გვქონდა ამ სამუდამოდ მარყუჟის ბოლო დროს, რომელიც იყო სერია თავსატეხი ცალი რომ რაღაც გააკეთა ფაქტიურად forever-- ამ შემთხვევაში, , Hello World, Hello World, მშვენიერია, hello მსოფლიოში. ასე რომ, ეს უსასრულო ციკლი დიზაინი. 

In C, თუ ჩვენ გვინდა, რომ შეასრულოს ეს იგივე იდეა, შესაძლოა, უბრალოდ, ამის გაკეთება. მიუხედავად იმისა, რომ მართალია, printf მიესალმები world-- ახლა ხოლო, უბრალოდ სემანტიკურად, სახის წარმოსახავს აკეთებს რაღაც ისევ და ისევ და ისევ, და რამდენ ხანს? ისე, ჭეშმარიტი შეგახსენებთ, რომ ნამდვილი მხოლოდ ან ერთი. 

და ჭეშმარიტი, რა თქმა უნდა, ყოველთვის ასეა. ასე რომ, ეს არის ერთგვარი უაზრო განცხადება უბრალოდ ვთქვა, მართალია. მაგრამ მართლაც, ეს არის მიზანმიმართული, იმიტომ, რომ თუ ნამდვილი მხოლოდ ყოველთვის ასეა, მეტი, ხოლო ჭეშმარიტი მხოლოდ გულისხმობს, თუ ცოტა ირიბად, რომ შემდეგ ხაზი კოდი შორის იმ curly აფრთხილებს უნდა უბრალოდ შეასრულოს ისევ და ისევ, და ისევ, და არასოდეს რეალურად შეწყვიტოს. 

მაგრამ თუ თქვენ გსურთ თქვენი loop შეჩერება, როგორც ჩვენ ბოლო დროს, რაღაც ეს, ვიმეორებ, შემდეგ 50-ჯერ in C, ჩვენ შეგვიძლია გავაკეთოთ იგივე, რაც ე.წ. მარყუჟის სიტყვით არ მიმდინარეობს, ხოლო, მაგრამ. და მაშინ ჩვენ გვაქვს რამდენიმე ახალი სინტაქსი აქ, ერთად int i უდრის 0, i ნაკლებია, ვიდრე 50, i ++. და ჩვენ დავბრუნდებით რომ. მაგრამ ეს არ არის უბრალოდ, თუ ჩვენ გვინდა თარგმნა კომპლექტი Scratch ბლოკები კომპლექტი C ხაზი კოდი. 

იმავდროულად, განიხილოს ცვლადები. და, ფაქტობრივად, ჩვენ უბრალოდ ვნახეთ ერთ მომენტში წინ. და იმ შემთხვევაში, Scratch, თუ ჩვენ უნდოდა განაცხადოს ცვლადში i მე რომ რიცხვი, უბრალოდ ნომერი, და ჩვენ გვინდა, რომ მითითებული, რომ ეს გარკვეული მნიშვნელობა, ჩვენ ვიყენებთ ამ ფორთოხლის ბლოკირება აქ მითითებული i 0. 

და ვნახავთ დღეს და მიღმა, ისევე, როგორც გასულ კვირას, პროგრამისტების თითქმის ყოველთვის დაიწყება დათვლის ნულიდან, ნამდვილად კონვენციას. არამედ იმიტომ, რომ გავიხსენოთ ჩვენი განხილვის ორობითი, ყველაზე პატარა ნომერი შეგიძლიათ წარმოადგენს ნებისმიერი რაოდენობის ბიტი მხოლოდ იქნება 0 თავად. ასე რომ, ჩვენ ზოგადად დაიწყოს ინიციალიზაციისას კი ჩვენი ცვლადები 0. 

და C გავაკეთოთ იგივე, ჩვენ ვაპირებთ, რომ int for რიცხვი, უბრალოდ კონვენციას. მე ვერ მოუწოდა ამ ცვლადის არაფერი მინდა, ისევე, როგორც Scratch. და მაშინ უდრის 0 უბრალოდ ასიგნებების ღირებულების 0 მარჯვენა ფლანგიდან და აყენებს მას ცვლადი, ან შენახვის კონტეინერი იქ, მარცხენა. და ნახევრად მსხვილი ნაწლავის როგორც ჩვენ see-- და ჩვენ ვნახეთ რამდენიმე ამ already-- მხოლოდ იმას ნიშნავს, ბოლომდე აზრის. გაგრძელება უნდა გავაკეთოთ რაღაც ხაზები, რომ დაიცვას. 

ახლა, რაც შეეხება ლოგიკური გამონათქვამები? შეგახსენებთ, რომ Scratch, ეს იყო გამონათქვამები რომ ან ნამდვილი ან false კითხვები, მართლაც, რომ ჭეშმარიტი ან მცდარი. ასე რომ, იმ შემთხვევაში, Scratch, ჩვენ შეგვიძლია ვთხოვთ მარტივი კითხვა, როგორც ეს, არის მე ნაკლები 50? ასე რომ, მე, კიდევ ერთხელ, არის მთელი რიცხვი. იქნებ ჩვენ გამოყენებით, in Scratch პროგრამა შენარჩუნება სიმღერა ქულა ან რამე მაგდაგვარს. ასე რომ, ეს სინტაქსი აქ Scratch მხოლოდ იმას ნიშნავს, არის მე 50-ზე ნაკლები? ისე, საბედნიეროდ, რაღაც მარტივი C. და თარგმნა, ჩვენ, უბრალოდ, ვთქვათ, მე ნაკლებად 50-ზე, გამოიყენოთ ნაცნობი გასაღები თქვენს კლავიატურაზე. 

ამასობაში, თუ თქვენ სურდა ამბობენ, რომ რაღაც უფრო ზოგადი, , ასევე, არის x ნაკლებია ვიდრე Y, სადაც თითოეული x და y თავად არიან ცვლადები? ჩვენ შეგვიძლია გავაკეთოთ იგივე in C, ასე რომ სანამ ჩვენ ის ამ ცვლადების უკვე. ჩვენ დავინახავთ, თუ როგორ უნდა გავაკეთოთ, რომ დიდი ხნის განმავლობაში. ჩვენ, უბრალოდ, აცხადებენ x ნაკლები ვიდრე y. 

ასე, რომ თქვენ ვიწყებთ ვხედავ რაღაც მსგავსება. და ის ხალხი, ვინც გააკეთა Scratch, რა თქმა უნდა შთაგონებული ზოგიერთი ძირითადი იდეები. და დაინახავთ ამ სახის სინტაქსი ბევრ languages-- არა მხოლოდ ნულიდან, არ მხოლოდ C, მაგრამ Python, და JavaScript და სხვა ენებზე მაინც. 

განვიხილოთ კიდევ ერთი მშენებლობა C, ცნება მდგომარეობაში, თავისსავე პირობითად. თუ რაღაც მართალია, ამის გაკეთება. თუ რაღაც მართალია, ამის გაკეთება. ეს ერთგვარი პროგრამირების ეკვივალენტს გზის გასაყარი. იქნებ ეს ორი გზა ჩანგალი, სამი გზა ჩანგალი, ან მეტი. და Scratch, ჩვენ შეიძლება ჩანს რაღაც მსგავსი. 

ასე რომ, ეს ერთ-ერთი დიდი ერთი. მაგრამ ვნახოთ, ნათესავი სიმარტივის ლოგიკა. თუ x არის ნაკლები ვიდრე y, მაშინ ამბობენ x ნაკლებია ვიდრე y სხვაგან, თუ x მეტია y, მაშინ ამბობენ x მეტია y. და მაშინ, ლოგიკურად, თუ თქვენ ფიქრობთ, თავში Scratch ან უბრალოდ საკუთარი ადამიანის ინტუიცია, ასევე, თუ x არ აღემატება y და x არ არის ნაკლები ვიდრე y, მაშინ, რა თქმა უნდა, x იქნება თანაბარი წ. ასე რომ, ამ შემთხვევაში, მობუდარი იმ Scratch ბლოკები, შეგვიძლია მივაღწიოთ სამ გზა გზის გასაყარი? 

ამასობაში, თუ ჩვენ გვინდა, რომ გავაკეთოთ, რომ C, იგი სავარაუდოდ გამოიყურება ცოტა simpler-- მინიმუმ ერთხელ თქვენ იცნობს სინტაქსი. თუ x ნაკლებია ვიდრე Y, printf x არის ნაკლები ვიდრე y. Else თუ x მეტია y, printf x მეტია y. სხვაგან printf x უდრის y-- და, ერთხელ, იმ წარმატებული დამთავრდა მათთვის, ახალი ხაზები, ასე რომ, თუ თქვენ რეალურად გაიქცა ამ სახის პროგრამა ეს იქნებოდა მხოლოდ გადაადგილება კურსორი საბოლოოდ შემდეგი ხაზი ეკრანზე. 

ახლა, იმავდროულად Scratch ჰქონდა სხვა უფრო დახვეწილი ფუნქციები, მხოლოდ ზოგიერთი რომელიც ჩვენ ვაპირებთ თავდაპირველად გადაადგილება მეტი სამყაროში C. ერთ-ერთი მათგანი იყო მოუწოდა სია ნულიდან. და ეს იყო სპეციალური ტიპის ცვლადი, საშუალებას გაძლევთ შეინახოთ სხვადასხვა რამ მას უკან, უკან, უკან, უკან. 

In C, მას არ აქვს სიები, თავისთავად, მაგრამ რაღაც რომ უფრო ზოგადად მოუწოდა მასივები, მიუხედავად იმისა, რომ ჩვენ დავბრუნდებით შემდეგ ამ სემესტრში ეძებს რაღაც მოუწოდა ჩამონათვალი, ან მართლაც უკავშირდება სიაში. მაგრამ ახლა, უახლოესი ექვივალენტი C ჩვენთვის იქნება რაღაც მოუწოდა მასივი. ხოლო მასივი უბრალოდ სპეციალური ტიპის ცვლადი რომელიც საშუალებას გაძლევთ ჩაწეროთ მონაცემები უკან, უკან, უკან, უკან. 

და, მართლაც, Scratch, თუ გვინდოდა, რათა შეამოწმონ პირველ ელემენტს მასივი ან list-- და მე ვაპირებ მოვუწოდო მას, კონვენციის, argv, არგუმენტი ვექტორი, მაგრამ უფრო, რომ ხანგრძლივი. თუ მინდა კიდევ პირველ ელემენტს of argv, მსოფლიოში Scratch თქვენ რეალურად გააკეთებს, როგორც წესი, დაიწყება დათვლის 1. 

ასე რომ, მე შეიძლება მიიღოს ნივთი 1 argv. ეს არის ის, თუ რამდენად MIT ხორციელდება ცნება სიები. მაგრამ C, მე ვაპირებ უფრო მარტივად, უბრალოდ ამბობენ, argv, რაც კიდევ ერთხელ არის სახელი ჩემი list-- ან უნდა იყოს მკაფიო, მასივი. და თუ მე მინდა, რომ პირველი ელემენტები, მე ვაპირებ გამოიყენოს კვადრატულ ფრჩხილებში, რომელიც თქვენ არ შეიძლება ხშირად გამოყენებული ქვეშ კლავიატურაზე. 

მაგრამ 0 უბრალოდ ნიშნავს, ჩემთვის პირველი. ასე რომ ხანდახან და როგორც დრო გადის, ჩვენ ვაპირებთ უნდა დაიწყოს, რომ ამ გაორების შორის Scratch და C, რომლის დროსაც Scratch იყენებს მას. ჩვენ in C გამოიყენოთ 0 აქ. მაგრამ თქვენ სწრაფად ვხედავთ ერთხელ გესმით საფუძვლების თითოეულ ენაზე, რომელიც ეს რამ დაიწყება მიიღოს ყველა სხვა ნაცნობი პრაქტიკა და პრაქტიკა. 

ასე რომ, მოდით რეალურად შევხედოთ ახლა პროგრამა. აქ უნდა იყოს პირველი ჩვენი C კოდის სრული პროგრამების. და პროგრამა, ჩვენ ვაპირებთ შესთავაზოს განსახილველად არის ერთი, რომ ექვივალენტი რომ ადრე Scratch ცალი. 

ასე რომ, აქ, ჩვენ გვაქვს რა არის სავარაუდოდ უმარტივესი C პროგრამის თქვენ შეგიძლიათ დაწეროთ, რომ რეალურად აკეთებს რაღაც. ახლა, ჩვენ შევხედოთ წარსულში, ახლა, უკვე მოიცავს, სტანდარტული io.h და ამ კუთხის ფრჩხილებში და int, და ბათილად, და Curly braces, და ასე შემდეგ. 

და მოდით უბრალოდ ფოკუსირება რა, მინიმუმ ინტუიციურად, შეიძლება გადმოხტა თქვენ უკვე. ფაქტობრივად, მთავარი, მე არ აუცილებლად ვიცი, რა არის ეს, მაგრამ ჰგავს Scratch ჰქონდა, რომ როდესაც მწვანე დროშა დააწკაპებთ თავსატეხი ცალი, ასე აკეთებს C, როგორც პროგრამირების ენა აქვს ძირითადი ნაჭერი კოდი, რომელიც იღებს შესრულებული იყოს. და, მართლაც, ეს ფაქტიურად აპირებს ეწოდოს მთავარი. 

ასე რომ, მთავარი არის ფუნქცია. და ეს არის სპეციალური ფუნქცია, რომელიც არსებობს C რომ, როდესაც თქვენ აწარმოებს პროგრამა, ეს არის მთავარი, რომელიც იღებს მართავენ იყოს. მსოფლიოში Scratch, ეს იყო, როგორც წესი, როდესაც მწვანე დროშა აირჩიეთ, რომ მივიღე აწარმოებს იყოს. 

ამავდროულად, ჩვენ ვნახეთ ადრე, printf და ბეჭდური დაფორმატებას, რომ იქნება ფუნქცია, რომელიც გააჩნია C, ერთად მთელი bunch of სხვები, რომ ნების დრო და დრო ერთხელ, რათა ზუსტად როგორც მისი სახელი ვარაუდობს, ბეჭდვა რაღაც. რა გვინდა ბეჭდვა? ისე, ჩვენ ვხედავთ, რომ მიერ თან ერთვის გმირები როგორიცაა these-- Hello World, წარმატებული ო ორმაგ ბრჭყალებში, ჩვენ შეგვიძლია ვუთხრათ printf ზუსტად რა უნდა ბეჭდვა ეკრანზე. 

მაგრამ იმისათვის, რომ ამის გაკეთება რომ, ჩვენ, სამწუხაროდ, უნდა მიიღოს ის, რაც არის უკვე cryptic ჩვენს ადამიანებში, მაგრამ მაინც ეს გარკვეულწილად readable-- მკვეთრი მოიცავს, სტანდარტული io.h, int, მთავარი, ბათილად, printf, ყველა ჯადოსნური მართლწერის ჩვენ უბრალოდ დაინახა ეკრანზე. მაგრამ ჩვენ რეალურად უნდა წასვლა უფრო arcane მაინც. ჩვენ ჯერ უნდა თარგმნოს კოდი რომ ჩვენ წერენ შევიდა მანქანა კოდი. და გავიხსენოთ, რომ გასულ კვირას მანქანები, მინიმუმ ვინც ვიცით, აქ, ბოლოს დღეს, მხოლოდ მესმის, zeros და პირობა. 

და ღმერთი ჩემი, თუ ჩვენ გვქონდა დაწერა ეს zeros და პირობა, რომ რეალურად პროგრამა, ეს იქნებოდა ძალიან, ძალიან სწრაფად მიიღოს fun გარეთ არაფერი. მაგრამ აღმოჩნდება, ერთ გასულ კვირას, რომ ამ ნიმუშების zeros და პირობა მხოლოდ განსაკუთრებული მნიშვნელობა აქვს. გარკვეულ კონტექსტში, ისინი შეიძლება ნიშნავს ნომრები. 

ზოგიერთ კონტექსტში, ისინი იმას ნიშნავს, წერილები, ან ფერები, ან ნებისმიერი რაოდენობის სხვა აბსტრაქციები არ საფუძველზე. მაგრამ ისევე, როგორც თქვენი კომპიუტერი პროცესორი, ცენტრალური გენერაციის ერთეულის, და ტვინი შიგნით თქვენი კომპიუტერი. ეს, როგორც წესი Intel შიგნით, იმიტომ, რომ ის ერთ-ერთი უმსხვილესი კომპანიები რომელიც იღებს CPUs კომპიუტერები. 

ისე, Intel პროცესორები და სხვები უბრალოდ გადავწყვიტეთ წინასწარ რომ გარკვეული ნიმუშების zeros და პირობა ნიშნავს კონკრეტული რამ. გარკვეული ნიმუშების zeros და პირობა იქნება ეს ბეჭდვა ამ ეკრანზე, ან დაამატოთ ეს ორი ნომერი, ან სხვაობა ამ ორ რიცხვს, ან გადაადგილება ამ ნაჭერი მონაცემები ჩემი კომპიუტერის მეხსიერების მეტი აქ, ან ნებისმიერი რაოდენობის სხვა ძალიან დაბალი დონე, მაგრამ საბოლოო ჯამში, სასარგებლო, ოპერაციებში. მაგრამ, საბედნიეროდ, ჩვენ ადამიანები არ აპირებს უნდა იცოდეს, ამ დონის დეტალურად. მართლაც, ისევე, როგორც ბოლო დროს, სადაც ჩვენ ამოღებული ისევ და ისევ და ისევ, შენობა ძალიან დაბალი დონე primitives მოსწონს zeros და პირობა უმაღლესი დონის ცნებები ნომრები, და წერილები, და ფერები, და სხვა, ასე რომ, შეგვიძლია, როგორც პროგრამისტები დავდგეთ მხრებზე სხვები, ვინც არ მოვა ჩვენს წინაშე და პროგრამული უზრუნველყოფა, რომ სხვა ადამიანი არ წერია, სანამ us-- კერძოდ პროგრამების მოუწოდა compilers. 

C არის ენა, რომელიც როგორც წესი, შედგენილი, რაც იმას ნიშნავს, მოაქცია კოდის მანქანა კოდი. კერძოდ, ეს რას ნიშნავს ის არის, რომ თუ თქვენ მოხვდით თქვენი წყარო კოდი, რომ თქვენ თავს წერენ, როგორც ჩვენ მალე იქნება რაღაც მომენტში ეკრანზე, და გსურთ დააკონვერტიროთ ის საბოლოო ჯამში, მანქანა კოდი იმ zeros და პირობა, რომ მხოლოდ თქვენი Mac ან თქვენი კომპიუტერის understands-- თქვენ მოხვდით პირველი შესანახი რომ კოდის როგორც შეყვანის სპეციალური პროგრამა მოუწოდა შემდგენელი, გამოშვება, რომელიც ჩვენ ვნახოთ მანქანა კოდი. და, მართლაც, ბოლო დროს ჩვენ ვისაუბრეთ შესახებ, მართლაც, ბოლოს დღეს, პრობლემის გადაჭრა. თქვენ მოხვდით საშუალებებით. და თქვენ მოხვდით შედეგები. და თქვენ მოხვდით გარკვეული სახის ალგორითმი შუა. 

ალგორითმები შეიძლება რა თქმა უნდა განხორციელებული პროგრამული უზრუნველყოფა, როგორც ვნახეთ pseudocode გასულ კვირას და, როგორც ვნახავთ, ფაქტობრივი კოდი ამ კვირას. ასე რომ, შემდგენელი ნამდვილად კომპლექტი ალგორითმები შიგნით ის, რომ, თუ როგორ უნდა გარდაქმნას სპეციალური სიტყვა, როგორიცაა ძირითადი და printf, და სხვები, რომ ჩვენ უბრალოდ დაინახა შევიდა ნიმუშების zeros და პირობა, რომ Intel შიგნით და სხვა პროცესორები რეალურად ესმის. ასე რომ, როგორ გავაკეთოთ ეს? სად მივიღებთ შემდგენელი? 

ყველაზე ჩვენგანი აქ აქვს Mac ან PC. და თქვენ გაშვებული Mac OS, ან Windows, ან Linux, ან Solaris, ან ნებისმიერი რაოდენობის სხვა ოპერატიული სისტემა. და, მართლაც, ჩვენ შეგვიძლია გარეთ გადატანა ვებგვერდი და ჩამოტვირთვა შემდგენელი თქვენი Mac ან PC თქვენი კონკრეტული ოპერაციული სისტემა. მაგრამ ჩვენ ყველა უნდა სხვადასხვა გვერდებზე, ასე ვთქვათ. გვსურს აქვს ოდნავ სხვადასხვა კონფიგურაციით. და რამ არ იმუშავებს ყველა იგივე. და, მართლაც, ამ დღეებში ბევრი ჩვენგანი არ იყენებენ პროგრამა, რომელიც გადის მხოლოდ ჩვენს ლაპტოპები. სამაგიეროდ, ჩვენ ვიყენებთ რაღაც როგორც ბრაუზერი, რომელიც საშუალებას გვაძლევს, რათა შეამოწმონ ვებ დაფუძნებული განაცხადების ღრუბელი. და შემდეგ ამ სემესტრში, ჩვენ ყველაფერს გავაკეთებთ, ზუსტად რომ. ჩვენ წერენ განაცხადების ან პროგრამული უზრუნველყოფის გამოყენებით code-- არა C, მაგრამ სხვა ენებზე, როგორიცაა Python და JavaScript-- რომ აწარმოებს მოცული. 

და გავაკეთოთ, რომ, ჩვენ თვითონ დროს სემესტრის რეალურად გამოვიყენოთ Cloud დაფუძნებული გარემოს ცნობილია, როგორც CS50 IDE. ეს არის ვებ დაფუძნებული პროგრამირების გარემოს, ან ინტეგრირებული განვითარება გარემოს, IDE, რომ აგებული ციხის ზოგიერთი ღია პროგრამული მოუწოდა Cloud 9. და ჩვენ გარკვეული პედაგოგიური simplifications მას ისე, რომ დასამალი გარკვეული თვისებები პირველი კვირის განმავლობაში, რომ ჩვენ არ გვჭირდება, მას შემდეგ, რაც თქვენ შეგიძლიათ გამოავლენს მათ და არა უმეტეს არაფერი გსურთ გარემოში. 

და ეს საშუალებას გვაძლევს, ძალიან, წინასწარ დააყენოთ გარკვეული პროგრამული უზრუნველყოფა. რამ, როგორიცაა ე.წ. CS50 ბიბლიოთეკა, რომელიც ჩვენ მალე გვაძლევს in C რამდენიმე დამატებითი ფუნქციები. ასე რომ, თუ მიდიხარ, საბოლოო ჯამში, CS50.io, თქვენ უნდა აიძულა შესვლა, და ერთხელ თქვენ და შექმნას ანგარიში უფასოდ, თქვენ შეძლებთ წვდომისათვის გარემოში, რომელიც გამოიყურება საკმაოდ მოსწონს ეს. 

ახლა, ეს არის ნაგულისხმები რეჟიმში. ყველაფერი ლამაზი და ნათელი ეკრანზე. ბევრ ჩვენგანს აქვს ჩვევა მომუშავე CS50 ცალი, რომელიც არის საკმაოდ გვიან ღამემდე. ასე რომ, ზოგიერთი შეიძლება ურჩევნია გადაქცევას ღამის რეჟიმი, ასე ვთქვათ. 

მაგრამ, საბოლოო ჯამში, თუ რას აპირებს ვხედავ ფარგლებში CS50 IDE არის სამი განსხვავებული areas-- ფართობი მარცხენა, სადაც თქვენი ფაილი ვაპირებთ იყოს ღრუბელი, ფართობი ზედა მარჯვენა სადაც თქვენი კოდი იქნება შეუძლებელია. თქვენ გექნებათ გახსნა ინდივიდუალური ჩანართების ნებისმიერი პროგრამა რომ წერთ ამ სემესტრში შიგნით რომ ზედა მარჯვენა კუთხეში. და მაშინ ყველაზე arcanely, და ჯერ ძლიერი, იქნება ამ რამ ქვედა ცნობილია, როგორც ტერმინალის ფანჯარაში. 

ეს არის ძველი სკოლა სარდლობის ხაზის ინტერფეისი, და CLI, რომელიც საშუალებას თქვენ შეასრულოს ბრძანებები იმ კომპიუტერში ამ შემთხვევაში, კომპიუტერი cloud-- გავაკეთოთ რამ, როგორიცაა კომპილაციის თქვენი კოდი კოდის მანქანა კოდი, აწარმოებს თქვენი პროგრამების, ან, რათა დაიწყოს თქვენი სერვერზე, ან თქვენი მონაცემთა ბაზა, და ნებისმიერი რაოდენობის სხვა ტექნიკა რომ ჩვენ დავიწყებთ გამოიყენოს ადრე ხანგრძლივი. მაგრამ იქ, ჩვენ აპირებს რეალურად წასვლა ონლაინ და დაუკარით. და გავაკეთოთ, რომ, მოდით პირველი დაიწყოს მოუქნელმა მთავარი, და წერა ძირითადი ნაწილი პროგრამა. და მოდით, რომ ფუნქცია printf, რომელიც ჩვენ გამოყენებული ადრე, უბრალოდ ვთქვა რაღაც. 

ასე რომ აქ ვარ უკვე შიგნით CS50 IDE. მე შესული სისტემაში წინასწარ. და მე სრული ნაჩვენები ფანჯარა. ასე რომ, საბოლოო ჯამში, თქვენ ძალიან მოდის პრობლემები მოჰყვება ანალოგიური ნაბიჯები, რომ უზრუნველყოფს ონლაინ დოკუმენტაცია. ასე რომ თქვენ არ უნდა ფიქრი შთამნთქმელი ყველა პატარა ტექნიკური ნაბიჯი რომ გავაკეთო დღეს აქ. 

მაგრამ თქვენ მიიღებთ ეკრანზე მოსწონს ეს. მე არ უნდა იყოს ღამის რეჟიმში. და თქვენ შეგიძლიათ brighten ყველაფერი up გამორთვა ღამის რეჟიმში. და ბოლოს დღეს, თქვენ აპირებს ვხედავ ამ სამი ძირითადი areas-- ფაილი ბრაუზერის მარცხენა კოდი ჩანართების ზევით, და ტერმინალის ფანჯარაში ბოლოში. 

ნება მომეცით წავიდეთ წინ და წერა ჩემი პირველი პროგრამა. მე ვაპირებ წინასწარ გადადით ფაილი, შენახვა და გადარჩენა ჩემი ფაილი hello.c. მართლაც, კონვენცია, ნებისმიერი პროგრამის წერენ, რომ წერია, C ენის უნდა დაასახელა რაღაც dot გ, კონვენციას. ამიტომ, მე ვაპირებ დაარქვით hello.c, რადგან მე უბრალოდ მინდა მიესალმები მსოფლიოში. ახლა მე ვაპირებ, რომ გაადიდოთ და დააჭირეთ Save. და ყველა მაქვს ახლა აქ არის tab სადაც მე შემიძლია წერა კოდი. 

ეს არ აპირებს შეადგინოს. ეს არაფერს ნიშნავს. ასე რომ, მაშინაც კი, თუ მე მოაქცია ეს zeros და პირობა, პროცესორის აპირებს არ ვიცი, რა ხდება გარშემო. მაგრამ თუ ვწერ ხაზები რომ ემთხვევა ერთად C ის conventions-- C ყოფნა, ერთხელ, ეს language-- სინტაქსის მოსწონს ამ, printf მიესალმები world-- და მე მიღებული კომფორტულად ამით დროთა განმავლობაში. ასე რომ, მე არ ვფიქრობ, რომ გააკეთა ნებისმიერი typographical შეცდომები. 

მაგრამ, ყოველთვის, პირველივე დრო თქვენ ამის გაკეთება, თქვენ. და რა ვარ შესახებ უნდა გააკეთოს შეიძლება ძალიან ასევე არ იმუშავებს თქვენთვის პირველად. და რომ შესანიშნავად OK, რადგან ახლა თქვენ შეიძლება მხოლოდ ვხედავ უამრავი სიახლე, მაგრამ დროთა განმავლობაში კიდევ თქვენ იცნობს ამ გარემოს და ამ ენაზე, და სხვები, თქვენ დაიწყება ვხედავთ რამ, რომ ან სწორი ან არასწორი. 

და ეს არის ის, რაც სწავლების პრაქტიკის და რა თქმა უნდა, თანაშემწეები იმდენად კარგი, დროთა განმავლობაში, არის spotting შეცდომები და შეცდომები თქვენს კოდი. მაგრამ მე აცხადებენ, რომ არსებობს შეცდომები ამ კოდი. ასე რომ, ახლა მე მინდა აწარმოებს ამ პროგრამის. 

ახლა ჩემს Mac ან PC, მე ჩვევა ორმაგი დაწკაპვით ხატები როცა მინდა აწარმოებს რამდენიმე პროგრამა. მაგრამ ეს არ არის მოდელი აქ. ამ გარემოში, რომელიც არის CS50 IDE. ჩვენ ვიყენებთ ოპერაციული სისტემა სახელწოდებით Linux. Linux არის თქვენში სხვა ოპერაციული სისტემა, საყოველთაოდ ცნობილია, როგორც Unix. და Linux განსაკუთრებით ცნობილია რომელსაც სარდლობის ხაზი გარემოს, CLI. ახლა, ჩვენ გამოყენებით კონკრეტული გემოს Linux ეწოდება Ubuntu. და Ubuntu არის უბრალოდ გარკვეული მობილური Linux. 

მაგრამ ეს Linux ის ამ დღეებში გააკეთებს რეალურად მოდის გრაფიკული მომხმარებლის ინტერფეისი. და ერთი ჩვენ არ უნდა გამოყენებით აქ არის ვებ დაფუძნებული. ასე რომ, ეს შეიძლება გამოიყურებოდეს კი ცოტა განსხვავებული რაღაც თქვენ თავს ალბათ ჩანს, ან აწარმოებს წარსულში. 

ამიტომ, მე ვაპირებ წავიდეთ წინ ახლა და ამის შემდეგ. მე გადაარჩინა ეს ფაილი hello.c. მე ვაპირებ წავიდეთ წინ და ტიპი clanghello.c ასე Clang for C ენა არის შემდგენელი. ეს წინასწარ დაყენებული CS50 IDE. და თქვენ შეგიძლიათ სრულიად ჩამოტვირთოთ და დააყენოთ ეს თქვენი Mac ან PC. 

მაგრამ, ერთხელ, თქვენ არ გაქვთ ყველა წინასწარ კონფიგურაციის კეთდება თქვენთვის. ასე რომ, ახლა, მე მხოლოდ აპირებს clanghello.c. და ახლა შეამჩნია ეს სინტაქსი აქ საბოლოოდ გააცნობიეროს, იმას ნიშნავს, რომ მე ვარ საქაღალდე ან დირექტორია მოუწოდა სამუშაო გარემოს. ამ დოლარის ნიშანი არის მხოლოდ კონვენციის რაც იმას ნიშნავს, ჩაწერეთ თქვენი ბრძანებები აქ. 

ეს არის ის, რაც ე.წ. სწრაფი, უბრალოდ მიერ კონვენციის დოლარის ნიშანი. და თუ მე წავიდეთ წინ არის და დააჭირეთ შეიყვანეთ, არაფერი ჩანს, რომ არ მოხდა. მაგრამ ეს რეალურად კარგია. ნაკლებია, რაც ხდება თქვენს ეკრანზე, უფრო სავარაუდოა, თქვენი კოდი უნდა იყოს სწორი, მინიმუმ syntactically. 

ასე რომ, თუ მინდა აწარმოებს ამ პროგრამა, რა გავაკეთო? ასევე, ირკვევა, რომ რა სახელი კონვენციის პროგრამები, როდესაც თქვენ არ დააკონკრეტა სახელი თქვენი პროგრამა უბრალოდ a.out. და ეს სინტაქსი ძალიან, თქვენ გაეცნოს ადრე ხანგრძლივი. 

Dot ხაზი მხოლოდ იმას ნიშნავს, hey, CS50 IDE, გაუშვით პროგრამა მოუწოდა a.out რომ შიგნით ჩემი ამჟამინდელი დირექტორია. რომ dot ნიშნავს მიმდინარე დირექტორია. და ჩვენ დავინახავთ, რა სხვა მსგავსი sequences სიმბოლო ნიშნავს, რომ ხანგრძლივი. 

ასე რომ, აქ ჩვენ მივდივართ, შეიყვანეთ hello მსოფლიოში. და თქვენ შეამჩნევთ, რომ ის, რაც მოხდა? არა მხოლოდ ის ბეჭდვა hello მსოფლიოში. იგი ასევე გადავიდა კურსორი მომდევნო ხაზი. 

და რატომ იყო ეს? რა იყო კოდი, რომელიც ჩვენ წერდა ადრე რომ დარწმუნდა, რომ კურსორი გვინდა წასვლა მომდევნო ხაზი? სასაცილო რამ შესახებ კომპიუტერი არის ეს მხოლოდ აპირებს უნდა გავაკეთოთ ფაქტიურად რა გითხრათ, ეს უნდა გააკეთოს. 

ასე რომ, თუ თქვენ გითხრათ, რომ printf hello, მძიმე, სივრცე, სამყარო, ახლო გაცემა, ეს ფაქტიურად მხოლოდ აპირებს ბეჭდვა იმ სიმბოლოს. მაგრამ მე მქონდა ამ სპეციალური ხასიათი ბოლოს, გავიხსენოთ, წარმატებული ო. და ის, რაც უზრუნველყოფილი რომ ხასიათი წავიდა შემდეგი ხაზი ეკრანზე. 

ფაქტობრივად, ნება მომეცით წავიდეთ და ამის გაკეთება. ნება მომეცით წავიდეთ წინ და წაშლა. ახლა შეამჩნია, რომ დაბრუნება ჩემი ეკრანზე არსებობს პატარა წითელი სინათლე ჩანართი მითითებით, hey, თქვენ არ გადაარჩინა თქვენი ფაილი. ამიტომ, მე ვაპირებ წავიდეთ წინ კონტროლის S ან ბრძანების S, ფაილის შენახვა. ახლა ეს goes-- წავიდა ერთი წუთით მწვანე. და ახლა ის დაბრუნდა მხოლოდ ახლო ხატი. 

თუ მე ახლა აწარმოებს clanghello.c ერთხელ, შეიყვანეთ dot ხაზი, a.out, შეიყვანეთ დაინახავთ, რომ ის ჯერ კიდევ მუშაობდა. მაგრამ ეს, ალბათ, ცოტა buggy. ახლა, ჩემი prompt-- სამუშაო გარემოს, და მაშინ, რომ დოლარის ნიშანი, და მაშინ ჩემი ფაქტობრივი prompt-- ყველა იგივე ხაზი. ასე რომ, ეს, რა თქმა უნდა ესთეტიკური bug, მაშინაც კი, თუ ეს არ არის ნამდვილად ლოგიკური შეცდომა. 

ასე რომ, მე ვაპირებ გაუქმება რაც მე უბრალოდ გააკეთეს. მე ვაპირებ გამეორება a.out. შეამჩნია მე დასძინა, რომ newline ხასიათი უკან. მე შენახული ფაილი. 

ამიტომ, მე ვაპირებ გამეორება a.out, and-- dammit, შეცდომაა, შეცდომის, რაც იმას ნიშნავს შეცდომა. ასე რომ შეცდომა ის არის, რომ მიუხედავად იმისა, რომ მე დასძინა წარმატებული ო იქ, ხელახლა გადაარჩინა, ხელახლა გაიქცა პროგრამა, ქცევის იგივე იყო. რატომ უნდა იყოს? 

მე დაკარგული ნაბიჯი, არა? ეს გასაღები ნაბიჯი ადრე იყო, რომ თქვენ გაქვთ რომელთა მიზანია როდესაც თქვენ შეცვლით თქვენი კოდის, გამოდის, ასევე აწარმოებს ის მეშვეობით შემდგენელი ერთხელ, ასე რომ თქვენ ახალი მანქანა კოდი. და მანქანა კოდი, zeros და პირობა, ვაპირებთ, რომ თითქმის იდენტურია, მაგრამ სრულყოფილად არ ჩანს, რადგან ჩვენ გვჭირდება, რა თქმა უნდა, ახალი ხაზი. 

ასე დაფიქსირება ამ, მე ვაპირებ, რომ უნდა გამეორება clanghello.c, შესვლის, dot ხაზი, a.out. და ახლა, hello მსოფლიოში დაბრუნდა სადაც მე ველოდი, რომ იყოს. ასე რომ, ეს არის ყველა კარგი და კეთილი. მაგრამ a.out არის საკმაოდ სულელური სახელი პროგრამა, მიუხედავად იმისა, რომ ეს მოხდება, ისტორიული მიზეზების გამო, რომ იყოს, რაც იმას ნიშნავს ასამბლეის შედეგები. 

მაგრამ ნება მომეცით წავიდეთ წინ აქ და ამის გაკეთება განსხვავებულად. მინდა, რომ ჩემი Hello world პროგრამა რეალურად ეწოდოს hello. ასე რომ, თუ ეს იყო ხატი ჩემს desktop, ეს არ იქნება a.out. ეს იქნებოდა მოუწოდა hello. 

ასე რომ ამის გაკეთება, გამოდის რომ Clang, როგორც ბევრი პროგრამები, მხარს უჭერს ბრძანება ხაზი არგუმენტები, ან დროშები, ან კონცენტრატორები, რომელიც უბრალოდ გავლენა მოახდინოს მისი ქცევა. კერძოდ, Clang მხარს უჭერს dash o დროშა, რომელიც შემდეგ იღებს მეორე სიტყვა. ამ შემთხვევაში, მე თვითნებურად, მაგრამ გონივრულად, ეძახით hello. მაგრამ მე ხომ მას არაფერი მინდა, გარდა a.out, რაც იქნება საკმაოდ გარდა წერტილი. 

და შემდეგ უბრალოდ მიუთითოთ სახელი ფაილი მე მინდა, რომ შეადგინოს. ასე რომ, ახლა მიუხედავად იმისა, რომ დასაწყისში ბრძანების მე მაინც Clang, ბოლოს ბრძანება მე ჯერ კიდევ აქვს filename, მე ახლა ამ ბრძანების არგუმენტები, დროშებით, რომ ამბობენ, oh, სხვათა შორის, გამომავალი-o, ფაილი მოუწოდა hello, არ ნაგულისხმები a.out. 

ასე რომ, თუ მე მოხვდა შეიტანეთ ახლა, არაფერი როგორც ჩანს, არ მოხდა. და, მაინც, ახლა შემიძლია dot slash hello. ასე რომ, ეს არის იგივე პროგრამა. Zeros და პირობა იდენტური დასასრულს დღეში. 

მაგრამ ისინი ორ სხვადასხვა ფაილები a.out, რომელიც არის პირველი ვერსია და მხოლოდ სულელურად დაასახელა, და ახლა hello, რომელიც ბევრად უფრო უფრო მყარი სახელი პროგრამა. მაგრამ, პატიოსნად, მე არასოდეს ვაპირებ გახსოვთ ეს კიდევ ერთხელ, და ისევ და ისევ. და, ფაქტობრივად, როგორც ჩვენ წერენ უფრო რთული პროგრამების, ბრძანებები, თქვენ აპირებს უნდა დაწეროს ვაპირებთ, რომ კიდევ უფრო უფრო რთული მაინც. 

და ასე რომ არ ინერვიულოთ. გამოდის, რომ ადამიანების წინაშე ჩვენთვის არ მიხვდა, რომ ძალიან მქონდა ეს ზუსტად იგივე პრობლემა. ისინი ძალიან არ სარგებლობენ, რომელსაც ჩაწერეთ საკმაოდ ხანგრძლივი, arcane ბრძანებები, რომ აღარაფერი ვთქვათ გვახსოვს. ასე რომ, ადამიანებს ჩვენს წინაშე არ გააკეთა სხვა პროგრამები, რომელიც გაუადვილებს კომპილაციის თქვენი პროგრამული უზრუნველყოფა. 

და, მართლაც, ერთ-ერთი ასეთი პროგრამა ეწოდება გააკეთოს. ამიტომ, მე ვაპირებ წავიდეთ წინ და ამის გაკეთება. მე ვაპირებ გაუქმება ყველაფერი მე უბრალოდ გააკეთეს შემდეგ გზა. ნება მომეცით აკრიფოთ LS. და თქვენ შეამჩნევთ, სამი რამ a.out და ვარსკვლავი, hello და ვარსკვლავი და hello.c. იმედია, ეს უნდა იყოს ცოტა ინტუიციური, იმდენად, რამდენადაც ადრე არ იყო არაფერი ამ გარემოს. არაფერი იყო, რომ მე მქონდა ის სანამ ჩვენ დავიწყეთ კლასში. 

მე და ის hello.c. მე შედგენილი ეს, და მას a.out. და მერე შედგენილი ეს ერთხელ ოდნავ განსხვავებულად და მას hello. ასე რომ, მე სამი ფაილი ამ დირექტორია, ამ საქაღალდეში მოუწოდა სამუშაო გარემოს. ახლა, მე ვხედავ, რომ ისევე, თუ დააშორებს რეალურად. 

თუ მე დააშორებს აქ და შევხედოთ, რომ ზედა მარჯვენა კუთხეში, როგორც დაჰპირდა მარცხენა მხარეს თქვენს ეკრანზე ყოველთვის აპირებს აჩვენებს, თუ რა არის თქვენი ანგარიში, თუ რა არის შიგნით CS50 IDE. და არსებობს სამი ფაილი არსებობს. 

ამიტომ, მე მინდა, რომ თავი დაეღწია a.out და hello. და როგორც თქვენ შეიძლება წარმოიდგინეთ, ინტუიციურად, თუ შეიძლება დასალაგებლად კონტროლის click ან დააწკაპუნეთ ამ. და ამ პატარა მენიუ pops up. შეგიძლიათ ჩამოტვირთოთ ფაილი, გაუშვით მას, წინასწარ ის, ამოცნობა, გადარქმევა, და რა არა. 

და მე ვერ ვშლით, და, რომ ის წავიდეს. მაგრამ მოდით გავაკეთოთ რამ ბრძანება ხაზი ახლა, ისე, რომ კიდევ კომფორტული ეს და ამის შემდეგ. მე ვაპირებ წავიდეთ წინ და ამოიღონ a.out აკრეფით ფაქტიურად rma.out. გამოდის, ბრძანება მოხსნის ან წაშლის რაღაც, არ ამოიღონ ან წაშლა. 

ეს უფრო მოკლედ RM, უბრალოდ გადარჩენა თქვენ რამდენიმე keystrokes, და დააჭიროთ. ახლა ჩვენ ვაპირებთ, გარკვეულწილად cryptically ამოიღონ რეგულარული ფაილი a.out. მე ნამდვილად არ ვიცი, რა არარეგულარული ფაილი იქნება ამჟამად. მაგრამ მე მინდა ამოიღონ იგი. 

ამიტომ, მე ვაპირებ აკრიფოთ Y ამისთვის კი. ან მე ვერ აკრიფოთ ის, და დააჭიროთ. და კიდევ ერთხელ, არაფერი ჩანს, რომ მოხდეს. მაგრამ ეს არის, ზოგადად, კარგია. 

თუ მე აკრიფოთ LS ამ დროს, რა უნდა ნახოთ? იმედია, მხოლოდ მიესალმები და hello.c. ახლა, როგორც განზე, თქვენ შეამჩნია ეს ვარსკვლავი, ვარსკვლავი, ეს არის ის, ბოლოს ჩემი პროგრამები. და ისინი ასევე აჩვენებს up მწვანე. ეს არის მხოლოდ CS50 IDE გზა of cluing თქვენ ფაქტზე რომ ეს არ არის კოდის. ეს არის შემსრულებელი, რომელიც runnable პროგრამა, რომელიც შეგიძლიათ რეალურად აწარმოებს ამით dot ხაზი, და შემდეგ ეს სახელი. 

ახლა, ნება მომეცით წავიდეთ წინ და ამოიღონ ამ, rm hello, შეიტანეთ, ამოიღონ რეგულარული წარადგინოს hello, დიახ. და ახლა თუ მე აკრიფოთ LS, ჩვენ უკან hello.c. შეეცადეთ არ წაშალოთ თქვენი ფაქტობრივი კოდის. მიუხედავად იმისა, რომ არსებობს თვისებები ჩაშენებული CS50 IDE, სადაც თქვენ შეგიძლიათ გაიაროს თქვენი ცვლილებათა ისტორია და გადახვევა დროს თუ შემთხვევით წაშლა რაღაც, ნუ მავიწყდება პოსტი ამ მოთხოვნა დიახ ან არა, ის, რაც თქვენ რეალურად გსურთ. და თუ წასვლა მდე დაბრუნება მარცხენა კუთხეში აქ, ყველა რომ რჩება hello.c. ასე რომ, მტევნების სხვა ბრძანებები, რომ თქვენ შეუძლია შეასრულოს მსოფლიოში Linux, რომელთაგან ერთი არის, კიდევ ერთხელ, მწარმოებელი. ჩვენ ვაპირებთ, რომ ჩემი პროგრამა ახლა ასეთია. 

ნაცვლად იმისა, რომ clang, ნაცვლად აკეთებს clang-o, მე ვაპირებ უბრალოდ ფაქტიურად ტიპის, მიიღოს hello. და ახლა შეამჩნია, მე ვარ არ აკრეფით მიიღოს hello.c. მე აკრეფით მიიღოს hello. 

ეს პროგრამა ჩადება, რომ გააჩნია CS50 IDE, და მეტი ზოგადად Linux, არის პროგრამა, რომელიც ვაპირებ, რომ პროგრამა სახელწოდებით Hello. და ის აპირებს, უნდა ვივარაუდოთ, კონვენციის, იმ შემთხვევაში, თუ ეს პროგრამა შეიძლება გაკეთდეს, ის აპირებს, რათა მოხდეს წყაროდან კოდი ფაილი დამთავრებული dot გ, hello.c. 

ასე რომ, თუ მე მოხვდა შეიტანეთ ახლა შეამჩნია, რომ ბრძანება, რომელიც იღებს შესრულებული რეალურად კი აღარ ადრე, ვიდრე ადრე. და ეს იმიტომ, რომ ჩვენ preconfigured CS50 IDE აქვს რამდენიმე დამატებითი ფუნქციები აგებული, რომ ჩვენ არ გვჭირდება არ არის, თუმცა მალე. მაგრამ მთავარი რამ უნდა გააცნობიეროს ახლა მე მაქვს გაუმარჯოს პროგრამა. 

თუ მე აკრიფოთ LS ერთხელ, მე მიესალმები პროგრამა. და შემიძლია გაუშვით dot slash a.out, არა, იმის გამო, რომ მთელი წერტილი ამ სწავლება იყო dot slash hello. და ახლა მე მაქვს ჩემი Hello world პროგრამა. ასე რომ, წინ მიდის, ჩვენ თითქმის ყოველთვის მხოლოდ აპირებს კომპილაციის ჩვენი პროგრამების გამოყენებით ბრძანება გააკეთოს. და მაშინ ჩვენ ვაპირებთ აწარმოებს მათ მიერ dot ხაზი და პროგრამის სახელი. მაგრამ გააცნობიეროს ის, რაც აკეთებს თქვენ, ეს არის თავად არ არის შემდგენელი. ეს არის მხოლოდ ფონდის პროგრამა რომ იცის, თუ როგორ უნდა გამოიწვიოს შემდგენელი აწარმოებს ისე, რომ თქვენ თავს შეგიძლიათ გამოიყენოთ იგი. 

სხვა რა ბრძანებები არსებობს Linux, და თავის მხრივ CS50 IDE? ჩვენ მალე დავინახავთ, რომ იქ CD ბრძანება, შეცვლა დირექტორია. ეს გაძლევთ ფარგლებში თქვენი ბრძანების ინტერფეისი წინსვლა, და უკან, და ქმნის სხვადასხვა ფოლდერები გარეშე გამოყენებით თქვენი მაუსი. 

LS ჩვენ ვნახეთ, რომელიც დგას სია ფაილი მიმდინარე დირექტორია. ჩადება Dir, შეგიძლიათ სავარაუდოდ, დაიწყება დასკვნის რას ნიშნავს ეს, ახლა მიიღოს დირექტორია, თუ გვინდა, რომ შევქმნათ საქაღალდე. RM for remove, RM Dir for ამოიღონ დირექტორიაში და ეს, ერთხელ, არის ბრძანების ეკვივალენტები, რაც თქვენ შეიძლება გავაკეთოთ CS50 IDE თქვენი მაუსი. მაგრამ თქვენ მალე პოულობენ რომ ზოგჯერ უბრალოდ ბევრი უფრო სწრაფად უნდა გააკეთოს რამ კლავიატურის, და საბოლოო ჯამში უფრო ძლიერი. 

მაგრამ ძნელია იმის მტკიცება, რომ არაფერი ჩვენ უკვე აკეთებს ჯერჯერობით არის ყველა, რომ ძლიერი, როდესაც ყველა ჩვენ ვამბობდით, არის, hello მსოფლიოში. და, ფაქტობრივად, მე hardcoded სიტყვა hello მსოფლიოში ჩემი პროგრამა. არ არსებობს დინამიკას ამჟამად. Scratch იყო ბრძანებით მასშტაბები უფრო საინტერესო გასულ კვირას. 

და მოდით იქ. ავიღოთ ნაბიჯი, რომ გზა ზოგიერთი ფუნქციები. ასე რომ, არა მარტო C მოდის printf, და bunches სხვა ფუნქციები ზოგიერთი რომელიც ჩვენ დავინახავთ დროთა განმავლობაში, ეს არ რათა ის არის, რომ ადვილი უფლება კარიბჭე in მიღების მომხმარებლის შეყვანის. 

ფაქტობრივად, ერთ-ერთი სუსტი მხარეები ენებზე, როგორიცაა C, და კიდევ Java და ჯერ სხვები, არის ის, რომ არ გაუადვილეთ მხოლოდ რამ, როგორიცაა რიცხვებით მომხმარებლებს, ან სიმები, სიტყვა, და ფრაზები, რომ აღარაფერი ვთქვათ რამ, როგორიცაა მცურავი წერტილი ღირებულებები, ან რეალური ციფრები ათობითი ქულა, და მართლაც ხანგრძლივი ნომრები, როგორც ჩვენ მალე. ასე რომ, ეს სია ფუნქციები აქ, ამ ისევე როგორც სხვა Scratch თავსატეხი ცალი რომ ჩვენ წინასწარ დაყენებული CS50 IDE, ჩვენ ვიყენებთ რამდენიმე კვირის განმავლობაში როგორც სასწავლო დისკები ჯიშები, და საბოლოოდ მათ off, და გამოიყურება ქვეშ Hood, ალბათ, იმ როგორ ეს ყველაფერი ხორციელდება. 

მაგრამ ამის გაკეთება, მოდით რეალურად დაწეროს პროგრამა. ნება მომეცით წავიდეთ წინ არის. და მე ვაპირებ, რომ შევქმნათ ახალი ფაილი დაჭერით ამ პატარა plus, და დაჭერით ახალი ფაილი. 

მე ვაპირებ გადარჩენა ეს შემდეგი ერთი, ასე ვთქვათ, string.c, იმიტომ, რომ მე მინდა, რომ ითამაშოს strings. და სიმებიანი C მხოლოდ თანმიმდევრობა გმირები. ასე რომ, ახლა მოდით წავიდეთ წინ და ამის შემდეგ. 

მოიცავს სტანდარტული IO.h-- და გამოდის, სტანდარტული IO, IO მხოლოდ იმას ნიშნავს, შემავალი და გამომავალი. გამოდის, რომ ეს ხაზი აქ არის ის, რაც არის მეზობელი მოგვცემს გამოვიყენოთ printf. Printf, რა თქმა უნდა, აწარმოებს გამომავალი. ასე რომ, იმისათვის, რომ გამოიყენოთ printf, გამოდის out, თქვენ უნდა ჰქონდეს ეს ხაზი კოდი ზედა თქვენი ფაილი. 

და ჩვენ დავბრუნდებით, თუ რა რომ ნამდვილად ნიშნავს, რომ ხანგრძლივი. გამოდის, რომ ამ ნებისმიერი C პროგრამის ვწერ, მაქვს დაიწყოს იგი კოდი, რომელიც ასე გამოიყურება. და თქვენ შეამჩნევთ CS50 IDE და სხვა ინტეგრირებული განვითარება გარემოში, როგორც ეს, ვაპირებთ, რომ ცდილობენ, როგორც საუკეთესო მათ შეუძლიათ დასრულდება თქვენი აზრის. ფაქტობრივად, ერთი წუთით წინ თუ მე გაუქმება რაც მე უბრალოდ გააკეთეს, მე დააჭიროთ. 

მე მაშინ მოხვდა ღია curly გაუწიოს, დააჭიროთ ერთხელ. და ეს დასრულდა ჩემი აზრის. ეს მომცა ახალი ხაზი, დაზუსტებისათვის არანაკლებ ლამაზი სტილისტური მიზეზები ჩვენ დავინახავთ. და მერე ავტომატურად მომცა რომ curly გაუწიოს დასრულდება ჩემი აზრის. ახლა, ეს ყოველთვის არ გამოიცანით რა გსურთ ამის გაკეთება. მაგრამ დიდი ნაწილი, ეს იმას გადარჩენა თქვენ რამდენიმე keystrokes. ასე რომ, ერთი წუთით წინ, ჩვენ გაიქცა ამ პროგრამის hello, world, და შემდეგ შედგენილი ეს, და შემდეგ გაიქცა იგი. მაგრამ არ არსებობს დინამიკას აქ. რა, თუ გვინდოდა რამე განსხვავებული? ისე, რა, მინდოდა რეალურად მიიღოს სიმებიანი საწყისი მომხმარებელი? მე ვაპირებ გამოყენება თავსატეხი ცალი მოუწოდა ზუსტად that-- მიიღოს სიმებიანი. 

თურმე C, რომ როდესაც თქვენ არ მინდა უზრუნველყოს შეყვანის თავსატეხი ცალი, ან უფრო სწორად ფუნქცია, თქვენ ფაქტიურად ღია ფრჩხილებში, ახლო ფრჩხილებში. ასე რომ, ეს, თითქოს არ არის თეთრი ყუთი შეიტანოთ შევიდა. აცხადებენ, რომ ბლოკი ადრე მქონდა პატარა თეთრი ყუთი. ჩვენ არ გვაქვს, რომ თეთრი ყუთი ახლა. 

მაგრამ როდესაც მე მოვუწოდებთ მიიღოს სიმებიანი, მე გსურთ დააყენა შედეგი სადღაც. ასე რომ, ძალიან საერთო პარადიგმის C არის მოვუწოდებთ ფუნქცია, როგორიცაა მიიღოს სიმებიანი აქ, და შემდეგ შესანახად მისი დაბრუნების ღირებულება. ეს არის შედეგი მისი ძალისხმევა რაღაც. 

და რა არის მშენებლობა პროგრამირებაში, თუ არა Scratch და ახლა C, რომ ჩვენ შეგიძლიათ გამოიყენოთ რეალურად შესანახად რაღაც? მას ცვლადი, უფლება? და Scratch, ჩვენ ნამდვილად არ მაინტერესებს, რა ხდებოდა ცვლადები. 

მაგრამ ამ შემთხვევაში, ჩვენ რეალურად. მე ვაპირებ ვთქვა სიმებიანი. და მაშინ მე ვერ მოვუწოდებ ეს არაფერი მინდა. მე ვაპირებ, რომ მას სახელი, იღებს მიიღოს სიმებიანი. 

ახლა კი, თუ თქვენ ცოტა ახალი ამ, შეამჩნია, რომ მე აკლია ზოგიერთი დეტალი. მე დავიწყება ნახევრად მსხვილი ნაწლავის. მე უნდა დაასრულოს ამ აზრის. ამიტომ, მე ვაპირებ, რომ გადავიდეს ჩემი კურსორი, და მოხვდა ნახევრად მსხვილი ნაწლავის არსებობს. და რა არ მე უბრალოდ გაკეთდეს? ამ ხაზი კოდი, ნომერი 5 მომენტში, მე დარეკვით მიიღოს სიმებიანი არ საშუალებებით. ასე რომ არ არსებობს პატარა თეთრი ყუთი, როგორიცაა შენახვა ბლოკი აქვს. 

მე უბრალოდ ვამბობ, hey, კომპიუტერული, ჩემთვის სიმებიანი. თანაბარი ნიშანი არ არის ნამდვილად თანაბარი ნიშანი, თავისთავად. ეს დავალება ოპერატორი, რაც იმას ნიშნავს, hey, კომპიუტერი, გადაადგილება ღირებულება მარჯვენა მეტი მარცხნივ. და მარცხენა, მაქვს შემდეგ. 

Hey, კომპიუტერი, მომეცი სიმებიანი თანმიმდევრობა გმირები. და მოვუწოდებთ, რომ სიმებიანი სახელი. და მე კი არ აქვს, რომ მას სახელი. 

მე ვერ ვუწოდებ, პირობითად, რაღაც S, ჰგავს ჩვენ გამოყენებული ი მოვუწოდებთ ცვლადი i. მაგრამ ახლა მე უნდა გავაკეთოთ რაღაც ეს. ეს იქნება საკმაოდ სულელური ცდილობენ შედგენის ეს კოდი, გაშვებული ეს პროგრამა, მიუხედავად იმისა, რომ მე მიღების სიმებიანი, იმიტომ, რომ ეს ჯერ კიდევ მხოლოდ აპირებს მიესალმები მსოფლიოში. 

მაგრამ რა, თუ მე არ მინდა, რომ შეიცვალოს ეს. რატომ არ გავაკეთო ეს? პროცენტს s, მძიმით s. ეს არის პატარა cryptic მაინც. 

ნება მომეცით, ჩემი ცვლადები უფრო ნათელი. მიადევნე თვალი ასახელებს ამ ცვლადის სახელი. მოდით ვნახოთ, თუ ჩვენ ვერ გაღიზიანება გარდა რა ხდება აქ. 

ასე რომ, ხაზი ხუთ, მე მიღების სიმებიანი. და მე შენახვის, რომ ტექსტი, რასაც მომხმარებელს ჯერ აკრეფილი ერთი მისი კლავიატურის, ცვლადში სახელი. და აღმოჩნდება, რომ printf არ მხოლოდ ერთი არგუმენტი ორმაგი შეთავაზება, ერთი შემავალი ორმაგ ბრჭყალებში. 

მას შეუძლია მიიღოს ორი ან სამი ან მეტი, ასეთი რომ მეორე, ან მესამე, ან მეოთხე, ყველა სახელები ცვლადები, ან კონკრეტულად აფასებს, რომ გსურთ შეაერთედ შევიდა, დინამიურად, რომ სიმებიანი შეთავაზებები. სხვა სიტყვებით, თუ რა არასწორი იქნებოდა ეს? თუ ვთქვი მიესალმები სახელი, წარმატებული n, გადაარჩინა ჩემი ფაილი, შედგენილი ჩემი კოდი, და გაიქცა ეს, რა მოხდებოდა? 

ის უბრალოდ აპირებს ვთქვა, hello ასახელებს, ფაქტიურად N-A-M-E, რომელიც არის ერთგვარი სულელური, რადგან ეს არ განსხვავდება მსოფლიოში. ასე რომ, არაფერი შეთავაზებები არის რა ფაქტიურად იღებს დაბეჭდილი. ასე რომ, თუ მინდა, რომ ეს placeholder იქ, მე რეალურად უნდა გამოვიყენოთ ზოგიერთი სპეციალური სინტაქსი. და აღმოჩნდება, თუ წაიკითხა დოკუმენტაცია printf ფუნქცია ის გეტყვით, რომ თუ თქვენ იყენებთ პროცენტს s, შეგიძლიათ ჩაანაცვლებს მნიშვნელობა ასეთია. 

მას შემდეგ, რაც მძიმე მას შემდეგ, რაც ორმაგი ციტირებით, თქვენ უბრალოდ წერენ სახელი ცვლადი, რომ გსურთ შეაერთედ შევიდა, რომ ფორმატი კოდი, ან ფორმატი specifier, პროცენტი s სიმები. და ახლა თუ მე გადაარჩინა ჩემი ფაილი, მე დაბრუნდეს ქვემოთ ჩემი ტერმინალის. და მე აკრიფოთ ჩადება სიმებიანი, რადგან, კიდევ ერთხელ, სახელი ამ ფაილი, რომელიც მე ავირჩიე, სანამ არის string.c. 

ამიტომ, მე ვაპირებ ვთქვა ჩადება String, შევა. Oh ჩემი სიკეთე, შევხედოთ ყველა შეცდომები, ჩვენ უკვე გავაკეთეთ. და ეს is-- რა არის ეს ნამდვილად მოსწონს ექვსი, შვიდი ხაზი პროგრამა? ასე რომ, ეს არის, სადაც ეს შეიძლება ძალიან სწრაფად აბსოლუტური. 

ამ ტერმინალის ფანჯარაში ახლა მხოლოდ regurgitated დიდი რაოდენობით შეცდომა შეტყობინებები. რა თქმა უნდა, მე არ მაქვს მეტი შეცდომა შეტყობინებები ვიდრე მე მაქვს ხაზი კოდი. ასე რომ, რა ხდება? 

ასევე, საუკეთესო სტრატეგია უნდა გავაკეთოთ ნებისმიერ დროს თქვენ არ ექმნებათ აბსოლუტური სია შეცდომები, როგორც, რომ, არის გადახვევა უკან, ვეძებოთ ბრძანება თქვენ უბრალოდ გაიქცა, რომელიც ჩემს შემთხვევაში არის მიიღოს სიმებიანი. შეხედეთ, რა გააკეთოს გააკეთა და ეს არის ის, რომ ხანგრძლივი Clang ბრძანება, არ არის დიდი გარიგება არსებობს. 

მაგრამ წითელი არის ცუდი. Green ცდილობს იყოს ნაზი და სასარგებლო. მაგრამ მაინც ცუდი, ამ შემთხვევაში. მაგრამ სად არის ამაში ცუდი? 

String.c, ხაზი ხუთ, ხასიათი ხუთ. ასე რომ, ეს მხოლოდ საერთო კონვენციას. რაღაც colon რაღაც იმას ნიშნავს, ხაზის ნომერი და ხასიათი ნომერი. შეცდომა, გამოყენების გამოუცხადებელ იდენტიფიკატორი string. ხომ არ ნიშნავს, სტანდარტული? 

ასე რომ, სამწუხაროდ, Clang ცდილობს იყოს სასარგებლო. მაგრამ ეს არასწორია, ამ შემთხვევაში. არა, Clang, მე არ ნიშნავს, სტანდარტული IO. მე კი იმას ნიშნავდა, რომ ხაზი, დიახ. 

მაგრამ ხაზი ხუთ არის ერთი აქ. და Clang არ მესმის, S-T-R-I-N-G. ეს გამოუცხადებელ იდენტიფიკატორი, სიტყვა, ეს უბრალოდ არასოდეს მინახავს ადრე. და ეს იმიტომ, C, ენა ჩვენ წერილობით კოდი ახლავე, ამჯამად არ აქვს ცვლადები ეწოდება strings. 

ეს არ არის, ცხადია, მხარდაჭერა რაღაც მოუწოდა სიმებიანი. ეს არის CS50 ნაჭერი jargon, მაგრამ ძალიან პირობითი. მაგრამ შემიძლია დაფიქსირება ამ ასეთია. 

თუ დავამატო ერთი ხაზი კოდი ზევით ეს პროგრამა, მოიცავს CS50.h, რომელიც კიდევ ერთი ფაილი სადღაც შიგნით CS50 IDE, სადღაც მყარ დისკზე, ასე ვთქვათ, უბუნტუს ოპერაციული სისტემა რომ მე გაშვებული, რომელიც არის ფაილი, რომელიც არის აპირებს ასწავლიან ოპერაციული სისტემა, თუ რა სიმებიანი, უბრალოდ როგორც სტანდარტული io.h არის ფაილი ოპერაციული სისტემა, რომელიც აპირებს ასწავლიან იმას, რაც printf არის. 

მართლაც, ჩვენ არ მიღებული ძალიან ჰგავს გაგზავნა თუ IO აღიარა სტანდარტული Io.h და ცდილობდა გამოეყენებინა printf. ამიტომ, მე ვაპირებ წავიდეთ წინ და მხოლოდ აღებას L გარკვევა ჩემი ეკრანზე. ან შეგიძლიათ აკრიფოთ ნათელია და ეს უბრალოდ გარკვევა ტერმინალის ფანჯარაში. მაგრამ თქვენ მაინც გადახვევა უკან დრო. 

და მე ვაპირებ გამეორება ჩადება String. გადაკვეთა ჩემი თითები ამ დროს, შეიტანეთ. ღმერთო ჩემო, ის მუშაობდა. ეს გვიჩვენებს, ჩემთვის დიდი cryptic ბრძანება რომ არის ის, რაც გამომუშავებული გავლით Clang, მაგრამ არა შეცდომა შეტყობინებები. ასე რომ გააცნობიეროს, მიუხედავად იმისა, რომ თქვენ შეიძლება მიიღოთ სრულიად overwhelmed ერთად ნომერი შეცდომის შეტყობინებები, უბრალოდ, შეიძლება იყოს ეს შემაშფოთებელი კასკადური ძალაში, სადაც Clang არ ესმის ერთი რამ, რაც იმას ნიშნავს, რომ მაშინ, არ ესმის შემდეგი სიტყვა, ან მომდევნო ხაზი. ასე რომ, ეს უბრალოდ ახრჩობს თქვენი კოდი. მაგრამ სარემონტო შეიძლება იყოს მარტივი. ასე რომ, ყოველთვის ყურადღებას გაამახვილებს ძალიან პირველი ხაზი გამომავალი. და თუ არ მესმის, რომ ეს, უბრალოდ გამოიყურება სიტყვა, რომელიც შეიძლება იყოს წარმოშობა და ხაზის ნომერი, და ხასიათი, სადაც რომ შეცდომა შეიძლება იყოს. 

ახლა ნება მომეცით წავიდეთ წინ და ტიპის dot ხაზი, სიმებიანი, შევა. Hm, ეს არ ამბობდა მიესალმები არაფერი. რატომ? ასევე, გავიხსენოთ, სადაც ის გაშვებული? 

ეს, ალბათ, მოხდა იმ დროს, მარყუჟის, თუ გნებავთ, on line ექვსი, იმიტომ, რომ სიმებიანი დიზაინი, დაწერილი CS50 პერსონალი, ფაქტიურად იმას ნიშნავდა, რომ უბრალოდ იჯდეს იქ ელოდება, და ელოდება, და ელოდება სიმებიანი. ყველა ვგულისხმობთ სიმებიანი ადამიანის შეყვანა. ასე, რომ თქვენ იცით, რა? ნება მომეცით წავიდეთ წინ. და მხოლოდ ახირება, ნება მომეცით აკრიფოთ ჩემი სახელი, დავითი, შევა. ახლა მე მაქვს უფრო დინამიური პროგრამა. მისი თქმით, მიესალმები დავით. 

თუ მე წავიდეთ წინ და აწარმოებს ეს კიდევ ერთხელ, ნება მომეცით ცდილობენ ამბობენ Zamila სახელი, შევა. და ახლა ჩვენ გვაქვს დინამიური პროგრამა. მე არ რთული კოდირებული მსოფლიოში. მე არ რთული კოდირებული სახელი ან David, ან Zamila. 

ახლა ის ბევრად უფრო პროგრამები ჩვენ ვიცით, სადაც, თუ იგი შეიტანენ, იგი აწარმოებს ოდნავ განსხვავებული გამომავალი. ახლა, ეს არ არის საუკეთესო მომხმარებლის, გამოცდილება, ან UX. პროგრამის გაშვება. 

მე არ ვიცი რა მე უნდა უნდა გავაკეთოთ, თუ მე რეალურად შევხედოთ ან გახსოვთ კოდის. მოდით მომხმარებელი განიცდიან ცოტა უკეთესი მარტივი რამ. ნება მომეცით დაბრუნდეს ამ პროგრამა, და უბრალოდ ვთქვა, printf. 

და ნება მომეცით წავიდეთ წინ და აცხადებენ, სახელი, მსხვილი ნაწლავის, და სივრცეში, და შემდეგ ნახევრად მსხვილი ნაწლავის. და მხოლოდ ჩათვლით, არ საწინააღმდეგოდ n. და ეს არის მიზანმიმართული, იმიტომ, რომ მე არ მინდა სწრაფი გადაადგილება, რათა მომდევნო ხაზი. 

მინდა, ნაცვლად, ამისათვის მიიღოს სიმებიანი გადააკომპილეთ ჩემი კოდი შევიდა ახალი მანქანა კოდი dot ხაზი string. Ah, ეს არის ბევრად გალამაზებაში. ახლა ნამდვილად ვიცი, რა კომპიუტერი სურს ჩემგან, მისცეს მას სახელი. 

ასე რომ, მე ვაპირებ წავიდეთ წინ და ტიპის in Rob, შევა, და hello, Rob. ასე რომ, გააცნობიეროს, ეს ჯერ კიდევ, ბოლოს დღეს, მხოლოდ ცხრა ხაზის პროგრამის. მაგრამ ჩვენ აღებული ეს ბავშვი ნაბიჯები. 

ჩვენ ვწერდით, რომ ერთი ხაზი, რომელიც ჩვენ ნაცნობი იყო, printf, hello მსოფლიოში. მაშინ ჩვენ undid ცოტა რომ. და ჩვენ, ფაქტობრივად გამოიყენება მიიღოს სიმებიანი. და ჩვენ არ გაიზიარა, რომ ღირებულების ცვლადი. და მერე წავედით წინ და გაუმჯობესდა ეს კიდევ უფრო მესამე ხაზი. ეს განმეორებადი პროცესი წერა პროგრამული ნამდვილად გასაღები. In CS50, და ცხოვრების კულტურას, თქვენ უნდა საერთოდ არ დასხდნენ, პროგრამა არ აქვს გონება, და ცდილობენ წერა მთელი Damn რამ ერთდროულად. 

ეს იქნება, აუცილებლად, გამოიწვიოს გზა მეტი შეცდომები ვიდრე ჩვენ თვითონ ვნახეთ, აქ. მე, ამ დღეს, მუდმივად სხვა სულელური შეცდომები, რომლებიც, ფაქტობრივად, უფრო შეცდომები რომლებიც რთული გაერკვნენ. მაგრამ თქვენ უფრო შეცდომები უფრო ხაზი კოდი წერთ ერთდროულად. ასე რომ, ეს პრაქტიკა, დაწერა ცოტა კოდი რომ თქვენ კომფორტულად, კომპილაციის ის, რომ აწარმოებს, შეამოწმოთ ის უფრო ზოგადად, მაშინ გადატანა on-- ასე რომ ისევე როგორც ჩვენ ინახება layering და layering გასულ კვირას, მშენებლობის რაღაც ძალიან მარტივი უფრო რთული, იგივე აქ. არ დასხდნენ, და ცდილობენ დაეწერა მთელი პრობლემა. პრაქტიკულად ეს ბავშვი ნაბიჯები. 

ახლა, strings არ არის ყველა რომ სასარგებლო უთხრა თავს. ჩვენ გვინდა რეალურად, იდეალურად, როგორიც უნდა რაღაც ჩვენი ინსტრუმენტარიუმის. მოდით რეალურად ზუსტად რომ. 

ნება მომეცით წავიდეთ წინ ახლა და whip up ოდნავ განსხვავებული პროგრამა. და ჩვენ მოვუწოდებთ ამ int.c, for რიცხვი. მე ვაპირებ, ასევე, მოიცავს CS550.h. მე ვაპირებ მოიცავს სტანდარტული IO. და რომ იქნება საკმაოდ გავრცელებული ამ პირველი რამდენიმე დღის განმავლობაში კლასში. 

და მე ვაპირებ, რომ მზად თავს ერთად მთავარი ფუნქცია. და ახლა ნაცვლად მიღების სიმებიანი, მოდით წავიდეთ წინ და მიიღოს int. მოდით დავარქვათ i, და მას მისაღებად int, მჭიდრო parens, ნახევრად მსხვილი ნაწლავის. და ახლა მოდით რაღაც ეს, printf. 

მოდით, ვთქვათ, რაღაც hello, წარმატებული ო, მძიმე i. ასე რომ, მე საკმაოდ ბევრი ლიმიტირებით რა გავაკეთე მხოლოდ ერთი წუთით წინ. მაქვს placeholder აქ. მე არ მძიმით მე აქ, იმიტომ, რომ მინდა შეაერთედ i შევიდა, რომ placeholder. 

მოდით წავიდეთ წინ და ცდილობენ შედგენა ეს პროგრამა. ფაილი ეწოდება int.c. ამიტომ, მე ვაპირებ ვთქვა, რომ int, შევა. ღმერთო ჩემო, მაგრამ არ არის დიდი გარიგება, არა? აქ არის შეცდომა. 

არსებობს სინტაქსური შეცდომა აქ ისეთი, რომ პროგრამა არ შეუძლია იყოს შედგენილი შიგნით int.c, ხაზი შვიდი, ხასიათი 27 შეცდომა ფორმატი განსაზღვრავს ტიპის char ვარსკვლავი, რასაც არ არის. მაგრამ არგუმენტი ტიპის int. 

ასე რომ, აქ, ძალიან, ჩვენ არ ვაპირებთ, რომელთა მიზანია მიუხედავად იმისა, რომ დღეს არის ბევრი მასალა, ჩვენ ვაპირებთ, რომ overwhelm თქვენ აბსოლუტურად ყველა თვისება C, და პროგრამირების უფრო ზოგადად, მხოლოდ ამ პირველი რამდენიმე კვირის განმავლობაში. ასე რომ, ხშირად იქნება jargon რომლითაც თქვენ არ იცნობს. და, ფაქტობრივად, char ვარსკვლავი არის რაღაც ჩვენ ვაპირებთ, რომ დაბრუნდება ერთი კვირის ან ორი დროს. 

მაგრამ ახლა, ვნახოთ, თუ ჩვენ შეგვიძლია გარჩევის სიტყვა, რომ იცნობს. Formats-- ასე გავიგეთ, ფორმატი specifier, ფორმატი კოდი ადრე. ეს არის ნაცნობი. Type-- მაგრამ არგუმენტი ტიპის int. დაელოდეთ ერთი წუთით, მე int. 

იქნებ პროცენტი რეალურად აქვს განსაზღვრული მნიშვნელობა. და, მართლაც, ეს ასეა. რიცხვი, თუ გსურთ printf ჩაანაცვლებს,, თქვენ რეალურად უნდა გამოვიყენოთ სხვადასხვა ფორმატში specifier. და თქვენ არ ვიცი, ამ თუ ვინმე განუცხადა, და თქვენ კეთდება ეს ადრე. მაგრამ პროცენტს i არის ის, რაც შეიძლება ხშირად გამოყენებული in printf for ჩართვის რიცხვი. თქვენ ასევე შეგიძლიათ გამოიყენოთ პროცენტი დ ამისთვის ათობითი რიცხვი. მაგრამ მე ლამაზი და მარტივი აქ. ასე რომ, ჩვენ წავიდეთ ერთად, რომ. 

ახლა ნება მომეცით წავიდეთ წინ და გამეორება მიიღოს int, შეიტანეთ. ეს არის კარგი, არ შეცდომები. Dot ხაზი გაკეთება int OK, ცუდი მომხმარებლის, გამოცდილება, იმიტომ, რომ მე არ უთხრა თავს რა უნდა ვქნა. მაგრამ ეს ჯარიმა. მე დაჭერა სწრაფად. 

ახლა კი ნება მომეცით წავიდეთ წინ და აკრიფოთ დავით, OK, Zamila, რობ. OK, ასე რომ, ეს კარგია. ამ დროს, მე გამოყენებით ფუნქცია, თავსატეხი ცალი, ე.წ. მისაღებად int. და თურმე out-- და ჩვენ იხილეთ, ამ მოგვიანებით term-- CS50 პერსონალი განხორციელებული სიმებიანი ისე, რომ ეს მხოლოდ ფიზიკურად სიმებიანი თქვენთვის. 

იგი ახორციელებს კიდევ int in ისე, რომ იგი მხოლოდ მიიღოს რიცხვი თქვენთვის. და თუ, ადამიანური, არ თანამშრომლობენ, ეს ფაქტიურად აპირებს ამბობენ გაიმეორეთ, გაიმეორეთ, გაიმეორეთ, ფაქტიურად სხდომაზე ლამაზად, სანამ თქვენ დაავალდებულებს რაღაც ჯადოსნური ნომერი, როგორიცაა 50, და მიესალმები 50. 

თუ ჩვენ აწარმოებს ეს კიდევ ერთხელ და ტიპის 42, hello 42. ასე რომ, კიდევ int ფუნქცია შიგნით რომ თავსატეხი ცალი საკმარისია ლოგიკა, საკმარისი აზრის, გაერკვნენ, რა არის სიტყვა? და რა არის ნომერი? მხოლოდ მიღების, საბოლოო ჯამში, ნომრები. 

გამოდის, რომ ეს არ არის, რომ გამომხატველი. ჯერჯერობით. ასე რომ, yay, ბოლო დროს ჩვენ წავიდა საკმაოდ სწრაფად შევიდა განხორციელების თამაშები, და ანიმაცია, და მხატვრული ნაწარმოებების Scratch. და აქ, ჩვენ რომ შინაარსი ერთად hello მსოფლიოში, და hello 50. 

ეს არ არის ყველა, რომ ინსპირირებით. და, მართლაც, ამ პირველი რამდენიმე მაგალითები გარკვეული დრო დასჭირდება გაეზარდათ შფოთვა. მაგრამ ჩვენ ასე უფრო მეტი კონტროლის ახლა, ფაქტობრივად. და ჩვენ ვაპირებთ, რომ ძალიან სწრაფად დაიწყოს layering თავზე ამ ძირითადი primitives. 

მაგრამ პირველი, მოდით გავიგოთ, რა შეზღუდვები. ფაქტობრივად, ერთი რამ ნაკაწრი არ აქვს ადვილად მოდით გავაკეთოთ არის ნამდვილად ქვეშ Hood, და გაგება, თუ რა კომპიუტერი, რა შეუძლია გააკეთოს, და რა შეზღუდვები. და, მართლაც, რომ ნაკლებობა გაგება, პოტენციურად, გრძელვადიანი შეიძლება გამოიწვიოს ჩვენი mistakes-- წერა შეცდომები, წერილობით არასაიმედო პროგრამა, რომელიც იღებს კალენდარი რამდენიმე გზა. 

ასე რომ, მოდით, გარკვეული ნაბიჯები გაგება ამ ცოტა უკეთესი გზა, ვთქვათ, შემდეგი მაგალითი. მე ვაპირებ წავიდეთ წინ და განახორციელოს რეალური სწრაფი პროგრამა სახელწოდებით Adder. მსგავსად, მოდით დაამატოთ ზოგიერთი ნომრები ერთად. და მე ვაპირებ, რომ კოდი ზოგიერთ კუთხეში აქ, და უბრალოდ დააკოპირეთ და ჩასვით სადაც მე ვიყავი ადრე, უბრალოდ ასე რომ ჩვენ შეგვიძლია აპირებს ადრე. ასე რომ, ახლა მე მაქვს ძირითადი წამოწყება პროგრამა მოუწოდა Adder. 

და მოდით წავიდეთ წინ და ამის გაკეთება. მე ვაპირებ წავიდეთ წინ და ვთქვათ, intx იღებს მიიღოს int. და იცით რა? მოდით, უკეთესი მომხმარებლის, გამოცდილება. 

ასე რომ, მოდით უბრალოდ, ვამბობთ x არის და ეფექტურად შეეკითხება მომხმარებელს მოგვცეს x. და მაშინ ნება მომეცით წავიდეთ წინ და აცხადებენ, printf როგორ შესახებ y არის, ამ დროს ელოდება ორი ღირებულებების შესახებ. და მაშინ მოდით უბრალოდ წავიდეთ წინ და ვთქვათ, printf, თანხა x და y არის. და ახლა მე არ მინდა ამის გაკეთება პროცენტს s. მე მინდა, რომ პროცენტს i, წარმატებული ო, შემდეგ დანამატის თანხა ღირებულება. 

ასე რომ, როგორ შეიძლება მე ამით? იცი რაა? მე ვიცი, თუ როგორ გამოიყენოთ ცვლადები. ნება მომეცით, უბრალოდ აცხადებენ, ახალი, int z. 

და მე ვაპირებ მიიღოს ვხვდები აქ. თუ არსებობს თანაბარი ნიშნები ამ ენის, იქნებ მე შემიძლია უბრალოდ x + y, სანამ მე დავასრულებ ჩემს ეგონა, ნახევრად ნაწლავის? ახლა შემიძლია დაბრუნდეს ქვემოთ აქ, დანამატის z, დასრულდება ამ აზრის ნახევრად მსხვილი ნაწლავის. და ვნახოთ ახლა, თუ ეს sequences of ხაზები x არის int. Y არის int. 

სანიშნეს x და y, შესანახად ღირებულების z-- ასე რომ, კიდევ ერთხელ, მახსოვს თანაბარი ნიშანი არ არის თანაბარი. ეს დავალება მარჯვნიდან მარცხნივ. და მოდით ამობეჭდოთ, რომ თანხა x და y არ არის ფაქტიურად z, მაგრამ რა არის შიგნით z. მოდით Adder - ლამაზი, არ შეცდომები ამ დროს. Dot ხაზი Adder, მიუთითოთ, x იქნება 1. 

Y იქნება 2. და თანხა x და y არის 3. ასე რომ, ყველა კარგი და კეთილი. 

ასე, რომ თქვენ წარმოიდგინეთ, რომ მათემატიკის უნდა იმუშაოს პროგრამა მოსწონს ეს. მაგრამ იცით, რა? ეს არის ცვლადი, ხაზი 12, თუნდაც საჭირო? თქვენ არ უნდა მიიღონ ჩვევა მხოლოდ შენახვის რამ ცვლადები მხოლოდ იმიტომ, რომ თქვენ შეგიძლიათ. და, ფაქტობრივად, ეს ზოგადად განიხილება ცუდი დიზაინი თუ თქვენ შექმნით ცვლადი, მოუწოდა z ამ შემთხვევაში, შენახვის რაღაც, და შემდეგ დაუყოვნებლივ გამოყენებით, მაგრამ აღარასოდეს. რატომ მისცეს რაღაც სახელი როგორიცაა z თუ თქვენ ფაქტიურად აპირებს გამოიყენოს, რომ ის მხოლოდ ერთხელ, და ასე პროქსიმალური სადაც ის ეს, პირველ რიგში, ასე ახლოს თვალსაზრისით ხაზი კოდი? ასე, რომ თქვენ იცით, რა? გამოდის, რომ C საკმაოდ მოქნილი. თუ მე მართლა მინდა დანამატი ღირებულებების აქ, მე არ უნდა განაცხადოს ახალი ცვლადი. მე ვერ უბრალოდ plug-in x + y, რადგან C ესმის არითმეტიკა, და მათემატიკური ოპერატორები. 

ასე რომ, შემიძლია უბრალოდ ვთქვა, ამის გაკეთება მათემატიკის, x + y, რაც იმ ღირებულებები, დანამატის შედეგად მთელი შევიდა, რომ სიმებიანი. ასე რომ, ეს შეიძლება იყოს, თუმცა მხოლოდ ერთი ხაზი მოკლე, უკეთესი დიზაინი, უკეთესი პროგრამა, იმიტომ, რომ იქ ნაკლები კოდი, ამიტომ ნაკლებად ჩემთვის გასაგებია. და ეს ასევე მხოლოდ სუფთა, იმდენად, რამდენადაც ჩვენ არ ვართ ახალი სიტყვა, ახალი სიმბოლოები, როგორიცაა z, მიუხედავად იმისა, რომ ნამდვილად არ ემსახურება დიდი მიზანი. 

სამწუხაროდ, მათემატიკის არ არის ყველა რომ საიმედო ზოგჯერ. მოდით წავიდეთ წინ და ამის გაკეთება. მე ვაპირებ წავიდეთ წინ ახლა და ამის შემდეგ. 

მოდით გავაკეთოთ printf, პროცენტი i, პლუს პროცენტი i, უნდა იყოს პროცენტს i, წარმატებული ო. და მე ვაპირებ უნდა გააკეთოს ამ xyx + y. ასე რომ მე უბრალოდ გადავწერო ეს ოდნავ განსხვავებულად აქ. ნება მომეცით უბრალოდ სწრაფი საღი აზრის ქვითარი. ერთხელ, მოდით არ მიიღონ წინ საკუთარ თავს. ჩადება გველგესლა, dot slash გველგესლა. x 1, y 2, 1 + 2 = 3. ასე რომ, კარგი. მაგრამ მოდით გაართულებს ეს ახლა ცოტა, და შექმნათ ახალი ფაილი. 

მე ვაპირებ მოვუწოდო ამ ერთი, ამბობენ, ints, მრავლობითი მთელი რიცხვები. დავიწყებ, სადაც მე მომენტში წინ. მაგრამ ახლა მოდით გავაკეთოთ რამდენიმე სხვა ხაზები. ნება მომეცით წავიდეთ წინ და ამის შემდეგ, printf, პროცენტი i, მინუს პროცენტს i, არის პროცენტს i, მძიმე x, მძიმე yx y. ასე რომ, მე ვაკეთებ ოდნავ სხვადასხვა მათემატიკის არსებობს. მოდით გავაკეთოთ კიდევ ერთი. ასე პროცენტს i ჯერ პროცენტი მე პროცენტს i, წარმატებული ო. მოდით plug-in x და y და x ჯერ y. ჩვენ ვიყენებთ ვარსკვლავი on თქვენს კომპიუტერში ჯერ. 

თქვენ არ გამოიყენონ x. x არის ცვლადის სახელი აქ. თქვენ იყენებთ ვარსკვლავი გამრავლება. მოდით გავაკეთოთ კიდევ ერთი. Printf პროცენტს I, იყოფა by პროცენტს i, არის პროცენტს i, წარმატებული ო. xy იყოფა y-- ასე რომ თქვენ გამოიყენოთ წინ ხაზი in C უნდა გავაკეთოთ განყოფილება. და მოდით ერთი სხვა. დარჩენილი პროცენტს i, იყოფა by პროცენტს i, არის პროცენტს i. xy-- და ახლა დარჩენილი არის ის, რაც დარჩა. როდესაც თქვენ ცდილობენ გამყოფი მნიშვნელი შევიდა მრიცხველი, რამდენი დარჩა გამო, რომ თქვენ ვერ ყოფს გარეთ? 

ასე ნამდვილად არ არის, აუცილებლად, სიმბოლო ჩვენ გამოიყენება კლასის სკოლის ამ. მაგრამ არსებობს C. თქვენ შეგიძლიათ ამბობენ x modulo y, სადაც ეს პროცენტი ნიშანი ამ კონტექსტში confusingly როცა თქვენ შიგნით ორმაგი შეთავაზება, შიგნით printf, პროცენტი გამოიყენება როგორც ფორმატი specifier. 

როდესაც თქვენ იყენებთ პროცენტი გარეთ რომ მათემატიკური გამოხატვის, ეს modulo ოპერატორი მოდულის არითმეტიკა ჩვენი მიზნებისთვის აქ, მხოლოდ იმას ნიშნავს, რა არის დარჩენილი x გაყოფილი y? ასე რომ, x გაყოფილი y არის x slash y. რა არის დარჩენილი x გაყოფილი y? ეს არის x mod y, როგორც პროგრამისტი ვიტყოდი. 

ასე რომ, თუ მე არ შეცდომები აქ, ნება მომეცით წავიდეთ წინ და მიიღოს ints, მრავლობითი, ლამაზი, და dot slash ints. და მოდით წავიდეთ წინ და ნუ, ვთქვათ, 1, 10. ყველა უფლება, 1 plus 10 11, შემოწმება. 1-10 არის უარყოფითი 9 შემოწმება. 

1-ჯერ 10 არის 10, შემოწმება. 1 იყოფა 10 is-- OK, ჩვენ გამოტოვოთ, რომ ერთი. დარჩენილი 1 იყოფა 10 1. ეს არის სწორი. მაგრამ იქ ხარვეზების აქ. 

ასე რომ, ერთი მე ჩემი გადასცემს, არ არის სწორი. ვგულისხმობ, ეს არის ახლოს 0. 1 იყოფა 10, თქვენ იცით, თუ ჩვენ ჭრის ზოგიერთ კუთხეში, რა თქმა უნდა, ეს არის ნულოვანი. მაგრამ ეს უნდა იყოს ნამდვილად 1/10, 0.1, ან 0.10, 0,1000, ან სხვ. 

ეს ნამდვილად არ იქნება ნულოვანი. ისე, გამოდის, რომ კომპიუტერი ამით ფაქტიურად რა ვუთხარით მას ამის გაკეთება. ჩვენ ყველაფერს ვაკეთებთ მათემატიკის, როგორც x გაყოფილი y. და ორივე x და y, თითო ხაზები კოდი ადრე, რიცხვებით. 

გარდა ამისა, ხაზი 15, ჩვენ ვართ ვეუბნებოდი printf, hey, printf დანამატი რიცხვი, plug-in რიცხვი, plug-in რიცხვი კონკრეტულად x, და შემდეგ y, და x გაყოფილი y. x და y ints. ჩვენ კარგად იქ. 

მაგრამ რა არის x x? x გაყოფილი y უნდა იყოს, მათემატიკურად, 1/10, ან 0.1, რომელიც არის რეალური ნომერი, რეალური რაოდენობა რომელსაც პოტენციურად ათობითი წერტილი. ეს არ არის მთელი რიცხვი. 

მაგრამ რა არის უახლოესი მთელი 1/10, ან 0.1? ჰო, ეს სახის არის ნულოვანი. 0.1 მოსწონს ეს ბევრი. და 1 ეს ბევრად. ასე 1/10 უფრო ახლოსაა 0, ვიდრე ერთი. 

ასე რომ, რა C აკეთებს us-- სახის იმიტომ, რომ ჩვენ განუცხადა, ეს მიზანია: არის truncating რომ რიცხვი. ეს აღების ღირებულება, რაც კიდევ ერთხელ არის უნდა იყოს რაღაც 0,1000, 0 და სხვ. და ეს truncating ყველაფერი შემდეგ ათობითი წერტილი ასე რომ, ყველა ამ პერსონალი, იმიტომ, რომ ეს არ შეესაბამება ცნება მთელი რიცხვი, რომელიც არის მხოლოდ ნომერი, როგორც უარყოფითი 1, 0, 1, და ქვემოთ, ის აგდებს მოშორებით ყველაფერი შემდეგ ათობითი წერტილი იმიტომ, რომ თქვენ ვერ ჯდება ათობითი წერტილი რიცხვი განმარტება. 

ასე რომ, პასუხი აქ არის ნულოვანი. ასე რომ, როგორ მოვაგვაროთ ეს პრობლემა? ჩვენ გვჭირდება სხვა გამოსავალი ყველა ერთად. და ჩვენ შეგვიძლია ამის გაკეთება, ასეთია. 

ნება მომეცით წავიდეთ წინ და შექმნას ახალი ფაილი, ამ ერთი მოუწოდა floats.c. და გადარჩენა მას აქ იგივე დირექტორიაში, float.c. და ნება მომეცით წავიდეთ წინ და კოპირება ზოგიერთი რომ კოდი ადრე. 

მაგრამ ნაცვლად მიღების int, მოდით გავაკეთოთ ეს. მომეცი მცურავი წერტილი ღირებულება მოუწოდა x. სადაც მცურავი წერტილი მნიშვნელობა უბრალოდ სიტყვასიტყვით რაღაც მცურავი წერტილი. მას შეუძლია გადაადგილება მარცხნივ, მარჯვნივ. ეს არის რეალური რაოდენობა. 

და მინდა გითხრათ, არ კიდევ int, მაგრამ კიდევ float, რომელიც ასევე იყო ერთი მენიუ პარამეტრების C250 ბიბლიოთეკა. მოდით შეცვალოს y float. ასე რომ, ეს ხდება მიიღოს float. 

და ახლა, ჩვენ არ გვინდა, რომ დანამატის ints. გამოდის, რომ ჩვენ უნდა გამოვიყენოთ პროცენტი ვ float, პროცენტი ვ float, და ახლა შეინახეთ. და ახლა, თითების გადმოკვეთა, რათა მოძრავი, ლამაზი, dot slash მოძრავი. x იქნება ერთი 1. y იქნება 10 ერთხელ. 

და, ლამაზი, OK ჩემი ამისა არის სწორი. მე იმედი უფრო, მაგრამ დამავიწყდა დაწერა. მოდით წავიდეთ და დაფიქსირება ამ ლოგიკური შეცდომა. 

მოდით წავიდეთ წინ და დაიბრუნოს შემდეგ. ჩვენ უბრალოდ პატარა ასლი და პასტა. და მე ვაპირებ ვთქვა მინუსი. 

და მე ვაპირებ ვთქვა ჯერ. და მე ვაპირებ ვთქვა დაყოფილი. და მე არ ვაპირებ ამის modulo, რომელიც არ არის როგორც გერმანე აქ, გაყოფილი f, და ჯერ plus-- OK, მოდით ეს კიდევ ერთხელ გავაკეთოთ. 

მიიღოს მოძრავი, dot slash მოძრავი, და 1, 10, and-- ლამაზი, არ, OK. ასე რომ, მე იდიოტი. ასე რომ, ეს არის ძალიან გავრცელებული კომპიუტერულ მეცნიერებათა რათა სულელური შეცდომები მოსწონს ეს. 

პედაგოგიური მიზნებისათვის, ის, რაც მე ნამდვილად მინდოდა ამის გაკეთება იყო შეცვალოს მეცნიერების აქ პლუს, მინუს, რომ ჯერ, და დაყოფის, როგორც თქვენ იმედია შენიშნა ამ exercise. ახლა მოდით ხელახლა შედგენა ამ პროგრამა, dot slash მოძრავი. 

და მესამედ, მოდით თუ იგი აკმაყოფილებს ჩემი მოლოდინი. 1, 10, შევა, დიახ, ბატონო, 1.000, იყოფა 10.000, არის 0,100000. და აღმოჩნდება, რომ ჩვენ შეგვიძლია კონტროლი, რამდენი ნომრები შემდეგ იმ ათობითი რაოდენობა. ჩვენ რეალურად. ჩვენ დავბრუნდებით რომ. 

მაგრამ ახლა, ფაქტობრივად, მათემატიკის არის სწორი. ასე რომ, კიდევ ერთხელ, რა takeaway აქ? გამოდის, რომ C, არსებობს არა მხოლოდ strings-- და, ფაქტობრივად, არ არსებობს ნამდვილად, იმიტომ, რომ ჩვენ დაამატოთ იმ CS50 ბიბლიოთეკა. მაგრამ არ არსებობს, უბრალოდ ints. 

ასევე არსებობს მოძრავი. და აღმოჩნდება, რამოდენიმე სხვა მონაცემები სახის ძალიან, რომ ჩვენ ვიყენებთ ადრე ხანგრძლივი. თურმე, თუ გსურთ ერთი ხასიათი, არ სიმებიანი გმირები, თქვენ შეგიძლიათ გამოიყენოთ მხოლოდ char. 

გამოდის, რომ თუ გსურთ bool, ლოგიკური მნიშვნელობა, ჭეშმარიტი ან მცდარი მხოლოდ, მადლობა CS50 ბიბლიოთეკა, ჩვენ დაემატა C, bool მონაცემები ტიპის, ასევე. მაგრამ ასევე წარმოადგინოს ბევრი სხვა ენებზეც. და აღმოჩნდება, რომ ზოგჯერ უნდა უფრო დიდი ციფრები, შემდეგ მოდის ძირითადად ერთად ints და მოძრავი. 

და, ფაქტობრივად, ორმაგი არის ნომერი რომელიც იყენებს არა 32 ბიტი, მაგრამ 64 ბიტი. და ხანგრძლივი ხანგრძლივი არის ნომერი, რომელიც იყენებს არა 32, ბიტი, მაგრამ 64 ბიტი, შესაბამისად, მცურავი წერტილი ღირებულებები და რიცხვებით, შესაბამისად. მოდით რეალურად ახლა ეს მოქმედებაში. 

მე ვაპირებ წავიდეთ წინ აქ და whip up ერთი პროგრამა. აქ, მე ვაპირებ წავიდეთ წინ და არ მოიცავს cs50.h. და ნება მომეცით წავიდეთ, მოიცავს სტანდარტული io.h. 

და თქვენ შეამჩნევთ რაიმე ხმაურიანი ხდება აქ. ეს არ არის ფერადი კოდირების რამ ისევე, როგორც ეს ადრე. და აღმოჩნდება, ეს იმიტომ, რომ არ მიეცა, რაც ფაილის სახელი. 

მე ვაპირებ მოვუწოდო ამ ერთი sizeof.c და ჰიტ შენახვა. და შეამჩნია, რა ხდება, ჩემი ძალიან თეთრი კოდი წინააღმდეგ, რომ შავი ფონზე. ახლა, მაინც არსებობს ზოგიერთი purple არსებობს. და ეს არის სინტაქსის მონიშნულია. 

ეს იმიტომ, რომ, უბრალოდ, მე განუცხადა IDE რა ტიპის ფაილი ეს არის ვაძლევთ მას სახელი და კონკრეტულად ფაილის გაფართოება. ახლა, მოდით, წავიდეთ წინ და ამის გაკეთება. მე ვაპირებ წავიდეთ წინ და ძალიან უბრალოდ ამობეჭდოთ ასეთია bool არის პროცენტს LU. 

ჩვენ დავბრუნდებით რომ რაღაც მომენტში. და შემდეგ მე ვაპირებ ბეჭდვითი ზომის bool. და ახლა, უბრალოდ გადარჩენა თავს გარკვეული დრო, მე ვაპირებ მთელი bunch ამ ერთდროულად. და, კონკრეტულად, მე ვაპირებ შეცვალოს ეს char და char. ეს ერთი, მე ვაპირებ, რომ შეიცვალოს ორმაგი და ორმაგი. 

ეს ერთი, მე ვაპირებ, რომ შეიცვალოს რომ float და float. ეს ერთი, მე ვაპირებ შეცვლის int და int. და ეს ერთი, მე ვაპირებ შეცვლის ხანგრძლივი ხანგრძლივი. და ეს ჯერ კიდევ გრძელდება დიდი ხნის განმავლობაში, ხანგრძლივი ხანგრძლივი. 

და შემდეგ, ბოლოს, მივეცი თავს ერთი ძალიან ბევრი, string. გამოდის, რომ C, იქ სპეციალური ოპერატორი მოუწოდა ზომა ფაქტიურად არის აპირებს, როდესაც აწარმოებს, გვეუბნებიან ზომა თითოეულ ამ ცვლადის. და ეს არის გზა, ახლა, ჩვენ შეგვიძლია დაკავშირება დაბრუნება გასულ კვირას დისკუსია მონაცემები და წარმომადგენლობა. 

ნება მომეცით წავიდეთ წინ და შეადგინონ ზომა dot slash ზომა. და ვნახოთ. გამოდის, რომ C, კონკრეტულად CS50 IDE, კერძოდ, ოპერაციული სისტემა Ubuntu, რომელიც არის 64 ბიტიანი ოპერაციული სისტემა, ამ შემთხვევაში, bool, აპირებს გამოიყენოთ ერთი byte სივრცეში. ეს არის ის, თუ როგორ ზომა იზომება, არ ბიტი, მაგრამ bytes. და გავიხსენოთ, რომ ერთი ბაიტი არის რვა ბიტი. ასე რომ, bool, მიუხედავად იმისა, რომ ტექნიკურად მხოლოდ გჭირდებათ 0 ან 1, ეს არის პატარა არარაციონალური როგორ ჩვენ განახორციელეს. სინამდვილეში ის აპირებს გამოიყენოს მთელი byte-- ასე რომ ყველა zeros, რომლებიც, შესაძლოა, ყველა პირობა, ან რამე მაგდაგვარს, ან მხოლოდ ერთი 1 შორის რვა ბიტი. 

Char, იმავდროულად, გამოიყენება ხასიათი როგორც ASCII ხასიათის პოსტი გასულ კვირას, იქნება ერთი ხასიათი. და რომ synchs ერთად ჩვენი ცნება ის, რომ არაუმეტეს 256 ბიტი, უფრო სწორად, synchs up ერთად იგი არ უმეტეს 8 ბიტი, რაც გვაძლევს, როგორც ბევრი როგორც 256 ღირებულებებს. ორმაგი აპირებს 8 ბაიტი ან 64 ბიტი. 

Float არის 4. Int არის 4. ხანგრძლივი 8. და სიმებიანი 8. მაგრამ არ ინერვიულოთ შესახებ. ჩვენ ვაპირებთ, რომ კანი უკან რომ ფენის. გამოდის, strings შეუძლია უმეტეს 8 ბაიტი. 

და, მართლაც, ჩვენ წერილობითი strings უკვე, Hello World, უმეტეს 8 ბაიტი. მაგრამ ჩვენ დავბრუნდებით რომ რაღაც მომენტში. მაგრამ წართმევას აქ შემდეგ. 

ნებისმიერი კომპიუტერული მხოლოდ სასრულ თანხის მეხსიერება და სივრცეში. თქვენ შეგიძლიათ მხოლოდ მაღაზიაში ამდენი ფაილი თქვენს Mac ან PC. თქვენ შეგიძლიათ მხოლოდ მაღაზიაში ამდენი პროგრამების RAM გაშვებული ერთდროულად, აუცილებლად, კიდევ ვირტუალური მეხსიერება, რადგან თქვენ გაქვთ სასრულ თანხის ოპერატიული. 

და მხოლოდ სურათზე თუ თქვენ არასოდეს გახსნა ლეპტოპი და უბრძანა დამატებითი მეხსიერება კომპიუტერი, თქვენ შესაძლოა, არ ვიცი, რომ შიგნით თქვენი კომპიუტერი არის რაღაც, რომელიც გამოიყურება ცოტა მოსწონს ეს. ასე რომ ეს არის საერთო კომპანია დაასახელა მნიშვნელოვანია, რომ ხდის RAM კომპიუტერები. და RAM სადაც პროგრამების ცხოვრობს, ხოლო ისინი გაშვებული. 

ასე რომ, ყველა Mac ან PC, როდესაც თქვენ ორმაგად დაწკაპეთ პროგრამა, და ეს ხსნის, და ეს ხსნის გარკვეული Word დოკუმენტის ან რამე მაგდაგვარს, იგი ინახავს მას დროებით RAM, რადგან RAM არის სწრაფად ვიდრე თქვენს მყარ დისკზე, ან თქვენი მყარი დისკის სახელმწიფო. ასე რომ, ეს უბრალოდ, სადაც პროგრამების წასვლა ცხოვრება, როდესაც ისინი გაშვებული, ან როდესაც ფაილი გამოიყენება. 

ასე, რომ თქვენ რამ, რომ გამოიყურებოდეს მოსწონს ეს შიგნით თქვენი ნოუთბუქი, ან ოდნავ უფრო დიდი რამ შიგნით თქვენი desktop. მაგრამ გასაღები თქვენ მხოლოდ სასრული რაოდენობის ესე. და იქ მხოლოდ სასრული რაოდენობით ტექნიკა იჯდა მაგიდასთან უფლება აქ. 

ასე რომ, რა თქმა უნდა, ჩვენ არ შეგვიძლია შესანახად უსასრულოდ გრძელი ნომრები. და მაინც, თუ ვფიქრობ, უკან კლასის სკოლა, რამდენი ციფრები შეუძლია თქვენ გაქვთ უფლება ერთი ათობითი წერტილი? ამ საკითხთან დაკავშირებით, რამდენი ციფრები შეუძლია თქვენ უნდა მარცხნივ ათობითი წერტილი? მართლაც, უსასრულოდ ბევრი. 

ახლა, ჩვენ, ადამიანები შეიძლება მხოლოდ იცით როგორ უნდა შეხედულებებსა მილიონი, და მილიარდი, ტრილიონი და კვადრილიონი და quintillion. და მე უბიძგებს ლიმიტები ჩემი understanding-- ან my-- მე მესმის, ნომრები, მაგრამ ჩემი გამოთქმა ნომრები. მაგრამ მათ შეუძლიათ მიიღონ უსასრულოდ დიდი ერთად უსასრულოდ ბევრი ციფრები, რომ მარცხნივ ან მარჯვნივ ათობითი წერტილი. 

მაგრამ კომპიუტერი მხოლოდ სასრული რაოდენობით მეხსიერება, სასრულ ტრანზისტორების რაოდენობა, რომელიც სასრული რაოდენობის ნათურები შიგნით. რა ხდება, როდესაც ამოიწურა სივრცეში? სხვა სიტყვებით, თუ ვფიქრობ, უკან გასულ კვირაში როდესაც ჩვენ ვისაუბრეთ ნომრები თვლიან, რომ წარმოდგენილი ორობითი, ვარაუდობენ, რომ ჩვენ მივიღეთ ამ 8-bit მნიშვნელობა აქ. 

და ჩვენ გვაქვს შვიდი 1 და ერთი 0. და ვფიქრობ, რომ ჩვენ გვინდა რომ დაამატოთ 1 ღირებულება. ეს არის ძალიან დიდი რაოდენობის ახლავე. 

ეს არის 254, თუ კარგად მახსოვს მათემატიკის გასულ კვირას უფლება. მაგრამ რა, თუ შევცვალო რომ rightmost 0 1? მთელი ნომერი, რა თქმა უნდა, ხდება რვა 1 ს. ასე რომ, ჩვენ ჯერ კიდევ კარგი. 

და ეს, ალბათ წარმოადგენს 255, თუმცა დამოკიდებულია კონტექსტში ეს შეიძლება რეალურად წარმოადგენს უარყოფითი რიცხვი. მაგრამ უფრო, რომ სხვა დროს. ეს იგრძნობა ის შესახებ როგორც მაღალი, როგორც შემიძლია ითვლიან. 

ახლა, ეს მხოლოდ 8 ბიტი. და ჩემი Mac, რა თქმა უნდა, აქვს გზა მეტი 8 ბიტი მეხსიერების. მაგრამ ეს არ აქვს სასრული. ასე რომ, იგივე არგუმენტი ესადაგება, მაშინაც კი, თუ ჩვენ უფრო მეტი ამ პირობა ეკრანზე. 

მაგრამ რა მოხდება, თუ თქვენ შენახვის ამ ნომერზე, 255, და გსურთ ითვლიან 1 ოდნავ? გსურთ წავიდეთ 255 256. პრობლემა, რა თქმა უნდა, არის ის, რომ თუ დაიწყება დათვლის დროს ნულოვანი როგორც გასულ კვირას, თქვენ ვერ ითვლიან როგორც მაღალი, როგორც 256, რომ აღარაფერი ვთქვათ 257, რომ აღარაფერი ვთქვათ 258, m, რადგან რა ხდება, როდესაც თქვენ დაამატოთ 1? თუ თქვენ ძველი grade სკოლა მიდგომა, დააყენა 1 აქ, 1 + 1 არის 2, მაგრამ ეს ნამდვილად ნულოვანი, თქვენ განახორციელოს 1, განახორციელოს 1, განახორციელოს 1. ეს ყველაფერი, ეს 1-ის, წასვლა ნულოვანი. და თქვენ wind up, დიახ, როგორც ვინმე აღნიშნა, 1 მარცხენა მხარეს. მაგრამ ყველაფერი შეგიძლიათ რეალურად ვხედავ და შეესაბამება მეხსიერება მხოლოდ რვა 0, რაც უნდა ითქვას, რაღაც მომენტში, თუ თქვენ, კომპიუტერი, სცადა იმედი მაღალი საკმარისი up, თქვენ აპირებს გადაიტანოთ გარშემო, როგორც ჩანს, ნულოვანი, ან თუნდაც უარყოფითი ციფრები, რომლებიც კიდევ უფრო დაბალია, ვიდრე ნულოვანი. 

და ჩვენ შეგვიძლია სახის ეს. ნება მომეცით წავიდეთ წინ და დაწეროთ უძრავი სწრაფი პროგრამა აქ. ნება მომეცით წავიდეთ წინ და დაწეროთ პროგრამას სახელწოდებით Overflow. მოიცავს CS50.h, მოიცავს სტანდარტული IO.h-- oh, მე ნამდვილად გამოტოვებული ჩემი სინტაქსის შეფერადება. მოდით გადარჩენა, როგორც overflow.c. 

და ახლა int ძირითადი void-- და სანამ ხანგრძლივი, ჩვენ დაბრუნდება თუ რატომ ჩვენ შენარჩუნება წერილობით int ძირითადი ბათილად. მაგრამ ახლა, მოდით გავაკეთოთ ის, აღების მას მიანიჭა. მოდით მივცეთ თავს int, და ვრთავ, რომ 0. 

მოდით მაშინ ამის გაკეთება int i მისაღებად ნულოვანი რეალურად, მოდით უსასრულო ციკლი და ვნახოთ, რა მოხდება. მიუხედავად იმისა, რომ მართალია, მაშინ მოდით ამობეჭდოთ n არის პროცენტს i, წარმატებული ო, plug-ო. მაგრამ, ახლა, მოდით, ო იღებს n + 1. 

სხვა სიტყვებით, ყოველ iteration ამ უსასრულო ციკლი, ავიღოთ n ღირებულება, და დაამატეთ 1 და შემდეგ შესანახად შედეგად უკან n მარცხენა. და, ფაქტობრივად, ჩვენ ვნახეთ სინტაქსი ოდნავ როგორც ეს, მოკლედ. მაგარი შეასრულა ნაცვლად წერის ეს ყველაფერი, თქვენ შეგიძლიათ რეალურად აცხადებენ n პლუს უდრის 1. 

და თუ თქვენ ნამდვილად გსურთ იყოს ლამაზი, შეიძლება ითქვას, n plus plus ნახევრად მსხვილი ნაწლავის. მაგრამ ეს უკანასკნელი ორი მხოლოდ ის, რაც ჩვენ გვინდა მოვუწოდებთ სინტაქსური შაქარი პირველად რამ. 

პირველი ის არის, უფრო ზუსტად რომ ვთქვათ, მთლიანად ჯარიმა, სრულიად სწორი. მაგრამ ეს უფრო მეტად არის გავრცელებული, მე ვიტყვი. ასე რომ ჩვენ ყველაფერს გავაკეთებთ, ეს მხოლოდ ერთი წუთით. 

მოდით ახლა overflow, რომელიც ჟღერს საკმაოდ ავის მომასწავებელი, dot slash overflow. ვნახოთ, n მიღების საკმაოდ დიდი. მაგრამ მოდით ვიფიქროთ, თუ როგორ დიდი შეიძლება n მისაღებად? 

n int. ჩვენ ვნახეთ, ერთი წუთით წინ ზომა მაგალითად, რომ int არის ოთხი ბაიტი. ჩვენ ვიცით, რომ გასულ კვირას, ოთხი ბაიტი არის 32 ბიტი, რადგან 8 ჯერ 4, რომ 32. ეს იქნება 4 მილიარდი. 

და ჩვენ მდე 800,000. ეს აპირებს მიიღოს სამუდამოდ ითვლიან როგორც მაღალი, როგორც მე შეგიძლიათ. ამიტომ, მე ვაპირებ წავიდეთ წინ, როგორც თქვენ, შესაძლოა ხანგრძლივი, და მოხვდა კონტროლის, C გულწრფელად, კონტროლის C, ბევრი, სადაც კონტროლის C ზოგადად საშუალებით გააუქმოს. სამწუხაროა, რომ ამ გაშვებული ღრუბელი, ზოგჯერ ღრუბელი იფურთხება out იმდენად პერსონალი, იმდენად გამომავალი, ის აპირებს ცოტა ხნით ჩემი input მისაღებად მოცული. მიუხედავად იმისა, რომ მე მოხვდა კონტროლის C რამდენიმე წუთის წინ, ეს არის ნამდვილად მხარეს ეფექტი უსასრულო ციკლი. 

ასე რომ, ამ შემთხვევაში, ჩვენ წასვლას აპირებს, რომ იყოს. და ჩვენ ვაპირებთ, რომ დაამატოთ სხვა ტერმინალის ფანჯარაში მეტი აქ პლუს, რა თქმა უნდა, არ როგორც, რომ, მას შემდეგ, რაც ჯერ კიდევ ფიქრობს. და მოდით წავიდეთ წინ და იყოს ცოტა უფრო გონივრულად. 

მე ვაპირებ წავიდეთ წინ და ამის ეს მხოლოდ finitely ბევრჯერ. მოდით გამოვიყენოთ ამისთვის მარყუჟის, რომელიც მე გააკეთა მინიშნება ადრე. მოდი გავაკეთოთ ეს. მომეცი კიდევ ერთი ცვლადი int i იღებს 0. i ნაკლებია, ვიდრე, ვთქვათ, 64-i ++. ახლა კი ნება მომეცით წავიდეთ წინ და ბეჭდვითი out n არის პროცენტს i, მძიმე n. და მაშინ N-- ეს არის კიდევ აპირებს სამუდამოდ. მოდი გავაკეთოთ ეს. 

ო იღებს n ჯერ 2. და ჩვენ შეიძლება იყოს ლამაზი და ამის გაკეთება ჯერ უტოლდება 2. მაგრამ მოდით უბრალოდ, ვამბობთ n უდრის თავად, 2-ჯერ. სხვა სიტყვებით, ამ ახალი ვერსია პროგრამის, მე არ მინდა, რომ დაველოდოთ სამუდამოდ საწყისი როგორიცაა 800,000 4 მილიარდი. მოდით უბრალოდ ეს დასრულდა. 

მოდით რეალურად გაორმაგდება N ყოველ ჯერზე. რაც იხსენებენ, გაორმაგება არის პირიქით, რომ, რა თქმა უნდა. და მაშინ, როდესაც გასულ კვირას ჩვენ რაღაც ისევ და ისევ, და კიდევ ერთხელ, სუპერ სწრაფი, გაორმაგება აუცილებლად მიიღოს ჩვენთვის, 1-დან უდიდესი შესაძლო ღირებულება, რომელიც ჩვენ იმედი რომელზეც int. 

მოდით გავაკეთოთ სწორედ ეს არის. და ჩვენ დავბრუნდებით ამ ხნის განმავლობაში. მაგრამ ეს, კიდევ ერთხელ, ისევე, როგორც განმეორებითი ბლოკი ნულიდან. და თქვენ გამოიყენოს ადრე ხანგრძლივი. 

ეს მხოლოდ იმას ნიშნავს ითვლიან ნულიდან მდე, მაგრამ არ უდრის, 64. და თითოეულ iteration ამ loop, უბრალოდ შეინახოს დამატება i. ასე რომ, მე ++ - და ამ ზოგადი მშენებლობა on line 7 არის უბრალოდ სუპერ გავრცელებული გზა იმეორებს რამდენიმე ხაზი კოდი, გარკვეული რაოდენობის ჯერ. რომელიც ხაზების კოდი? ეს Curly braces, როგორც თქვენ შესაძლოა გამომდინარე ახლა, ნიშნავს, ამის შემდეგ. 

ეს არის მსგავსად Scratch, როდესაც მას აქვს ყვითელი ბლოკები და სხვა ფერები, რომ სახის იკისროს ან მოვეფერო სხვა ბლოკები. ეს არის ის რაც იმ curly braces აქ აკეთებენ. ასე რომ, თუ მე მივიღე ჩემი სინტაქსი right-- თქვენ ხედავთ სტაფილოს სიმბოლო C საშუალება რომ არის, რამდენჯერ ვიყავი ცდილობს ამ პრობლემის მოგვარებას. ასე რომ, მოდით, თავი დაეღწია, რომ ერთი საერთოდ, და დახურეთ ეს ფანჯარა. და ჩვენ ვიყენებთ ახალი. ჩადება overflow, dot slash overflow, შეიყვანეთ ყველა უფლება, ეს გამოიყურება ცუდი, პირველ რიგში. მაგრამ მოდით გადახვევა უკან დრო, იმიტომ, რომ მე ამ 64-ჯერ. 

და შენიშნავს, პირველად, n 1. მეორედ, N 2, მაშინ 4, შემდეგ 8, შემდეგ 16. და, როგორც ჩანს, რომ როგორც კი მე კიდევ 1 მილიარდი, თუ მე გაორმაგდება ის კიდევ ერთხელ, რომ უნდა მომეცი 2 მლრდ. მაგრამ აღმოჩნდება, რომ ეს უფლება cusp. 

ასე რომ, ეს რეალურად გადმოედინება int ეხლა 1 მილიარდი უხეშად უარყოფითი 2 მილიარდი, რადგან მთელი რიცხვი, განსხვავებით ნომრები ჩვენ ჩავთვლიდით გასულ კვირას, შეიძლება იყოს როგორც დადებითი და უარყოფითი რეალურად და კომპიუტერი. ასე რომ, სულ მცირე, ერთ-ერთი იმ ბიტი ეფექტურად მოპარული. ასე რომ, ჩვენ მართლაც მხოლოდ 31 ბიტი, ან 2 მილიარდი შესაძლო მნიშვნელობებია. 

მაგრამ ახლა, takeaway საკმაოდ უბრალოდ, რაც ამ ნომრებზე და რაც მათემატიკის, რაღაც ცუდი ხდება, საბოლოო ჯამში, რადგან საბოლოო ჯამში თქვენ ცდილობთ permute ბიტი ერთი ძალიან ბევრჯერ. და თქვენ ეფექტურად წასვლა ყველა 1 ს იქნებ ყველა 0 ს, ან იქნებ უბრალოდ სხვა ნიმუში, რომ იგი აშკარად, დამოკიდებულია კონტექსტში, შეიძლება განიმარტოს, როგორც უარყოფითი რიცხვი. ასე რომ, როგორც ჩანს, ყველაზე მაღალი I შეგიძლიათ იმედი ამ კონკრეტულ პროგრამას მხოლოდ 1 მილიარდი. მაგრამ არსებობს ნაწილობრივი გამოსავალი აქ. იცი რაა? 

ნება მომეცით შეცვლის საწყისი int ხანგრძლივი ხანგრძლივი. და ნება მომეცით წავიდეთ წინ აქ და ამბობენ, რომ მე ვაპირებ აქვს რომ შეიცვალოს ეს ხელმოუწერელი ხანგრძლივი. ან, ვნახოთ, არ მახსოვს, თავს. 

მოდით, წავიდეთ წინ და overflow. არა, ეს არ არის ის, LLD, მადლობა. ასე რომ, ზოგჯერ Clang შეიძლება იყოს სასარგებლო. მე არ მახსოვს, რა ფორმატში specifier იყო ხანგრძლივი ხანგრძლივი. 

მაგრამ, მართლაც, Clang მითხრა. Green არის ერთგვარი კარგი, კიდევ იმას ნიშნავს, თქვენ დაუშვა შეცდომა. ეს გამოცნობა, რომ მე იმას ნიშნავდა, LLD. 

ნება მომეცით მიიღოს ეს რჩევა, ხანგრძლივი ხანგრძლივი ათობითი ნომერი, გადარჩენა რომ. და ნება მომეცით გამეორება ეს, dot slash overflow, შეიტანეთ. და ახლა რა მაგარი არის ეს. 

თუ მე გადახვევა უკან დრო, ჩვენ კვლავ დაიწყოს იმედი ამავე მივალ სოფელში 1, 2, 4, 8, 16. ცნობა, ჩვენ ყველა გზა მდე 1 მლრდ. მაგრამ მაშინ ჩვენ უსაფრთხოდ მისაღებად 2 მლრდ. 

მაშინ მივიღებთ, რომ 4 მილიარდი, შემდეგ 8 მილიარდი, 17 მილიარდი. და ჩვენ წასვლა უმაღლესი და უმაღლესი და უმაღლესი. საბოლოოდ, ეს, ძალიან, შესვენებებით. 

საბოლოოდ, ხანგრძლივი ხანგრძლივი, რომელიც არის 64-bit ღირებულება, არ 32 ბიტიანი მნიშვნელობა, თუ ითვლიან ძალიან მაღალია, გადაიტანოთ გარშემო 0. და ამ შემთხვევაში, ჩვენ არ უნდა დასრულდება up ერთად უარყოფითი რიცხვი. 

ასე რომ, ეს არის პრობლემა. და აღმოჩნდება, რომ ეს პრობლემა არ არის, რომ arcane. მიუხედავად იმისა, რომ მე შეგნებულად გამოწვეული იგი ამ შეცდომებს, გამოდის, ჩვენ ვხედავთ, რომ სახის ყველა ჩვენს გარშემო, ან თუნდაც რამდენიმე ჩვენგანი. 

ასე რომ, Lego Star Wars, თუ თქვენ ოდესმე ითამაშა თამაში, გამოდის, რომ თქვენ შეიძლება გარშემო არღვევს რამ up in LEGO მსოფლიოში, და შეგროვება მონეტები, არსებითად. და თუ თქვენ ოდესმე ითამაშა ეს თამაში ძალიან ბევრი დრო, როგორც ეს უსახელო ინდივიდუალური აქ გავაკეთეთ, რაც საერთო რაოდენობის მონეტები, რომ თქვენ შეგიძლიათ შეაგროვოთ ის არის, რომ როგორც ჩანს, 4 მილიარდი. 

ახლა, ის რეალურად მომრგვალებული. ასე რომ, LEGO ცდილობდა, შენარჩუნება რამ მოსახერხებელი. ისინი არ გავაკეთებთ ზუსტად 2 32 ძალა, ერთ გასულ კვირას. მაგრამ 4 მილიარდი მიზეზი. როგორც ჩანს, ამ ინფორმაციის საფუძველზე, რომ LEGO, და კომპანია, რომელიც ეს გააკეთა ფაქტობრივი პროგრამული უზრუნველყოფა, გადაწყვიტა რომ მაქსიმალური რაოდენობის მონეტები მომხმარებელი შეიძლება დაგროვება არის, მართლაც, 4 მილიარდი, რადგან ისინი აირჩია მათი კოდი გამოიყენოთ არა ხანგრძლივი ხანგრძლივი, როგორც ჩანს, მაგრამ მხოლოდ რიცხვი, ხელმოუწერელი რიცხვი, მხოლოდ დადებითი რიცხვი, რომლის max მნიშვნელობა უხეშად რომ. ისე, აქ არის კიდევ ერთი სასაცილო ერთი. ასე რომ, თამაში Civilization, რომელიც ზოგიერთ თქვენგანს შეიძლება იყოს ნაცნობი, ერთად გამოდის, რომ წლის წინ იყო შეცდომა ამ თამაშში, რომლის დროსაც თუ თქვენ როლი of Gandhi თამაში, მის ნაცვლად იმისა, რომ ძალიან პაციფისტური, ნაცვლად იყო ძალიან, წარმოუდგენლად აგრესიული, ზოგიერთ ვითარებაში. კერძოდ, ისე, რომ ცივილიზაციის სამუშაოები, რომ თუ თქვენ, როგორც მოთამაშე, მიიღოს დემოკრატიისა და თქვენი აგრესია ანგარიშით იღებს decremented ორი, მინუს მინუსი, და შემდეგ მინუს მინუს. 

აკლებთ 2 თქვენი ფაქტობრივი iterating. სამწუხაროდ, თუ თქვენი iterating არის თავდაპირველად 1, და გამოვაკლოთ 2 ის მიღების შემდეგ დემოკრატიის განდი აქ შეიძლება არ კეთდება, იმიტომ, რომ ის იყო ძალიან passive-- 1 მასშტაბის აგრესია. მაგრამ თუ იგი იღებს დემოკრატიის, მაშინ ის მიდის 1 -1. 

სამწუხაროდ, ისინი გამოყენებით unsigned ნომრები, რაც იმას ნიშნავს, ისინი მკურნალობას თუნდაც უარყოფითი ნომრები, თითქოს ისინი დადებითი. და აღმოჩნდება, რომ დადებითი ეკვივალენტს უარყოფითი 1, ტიპიური კომპიუტერულ პროგრამებს, 255. ასე რომ, თუ Gandhi იღებს დემოკრატია, და აქედან გამომდინარე მისი აგრესია ანგარიში შემცირდა, ეს, ფაქტობრივად, Rolls გარშემო 255 და ხდის მას ყველაზე აგრესიული ხასიათი თამაშში. ასე რომ თქვენ შეგიძლიათ Google up ამ. და ეს იყო, მართლაც, შემთხვევითი პროგრამირების bug, მაგრამ, რომ შევიდა საკმაოდ მხარეთმცოდნეობის მას შემდეგ. 

ეს არის ყველა მხიარული და მიმზიდველი. უფრო საშიში არის, როდესაც ფაქტობრივი რეალურ სამყაროში მოწყობილობები, და არა თამაშები, აქვს იგივე შეცდომები. ფაქტობრივად, მხოლოდ ერთი წლის წინ სტატია გამოვიდა ამის შესახებ Boeing 787 Dreamliner. 

და მუხლის პირველი ერთი შეხედვით ნათქვამია ცოტა arcane. მაგრამ მისივე თქმით, ეს, პროგრამული უზრუნველყოფის დაუცველობის ბოინგის ახალი 787 Dreamliner jet აქვს პოტენციალი გამოიწვიოს მფრინავი დაკარგოს კონტროლი თვითმფრინავი, შესაძლოა შუა რიცხვებში ფრენის, FAA ჩინოვნიკები გააფრთხილა ში ცოტა ხნის წინ. ეს იყო განსაზღვრა რომ მოდელი 787 თვითმფრინავი, რომელიც უკვე იკვებება მუდმივად 248 დღის შეიძლება დაკარგოს ყველა ცვლადი დენით, AC, ელექტრო გამო გენერატორი კონტროლის ერთეული, GCUs, ერთდროულად შესვლის ვერ უსაფრთხო რეჟიმში. ეს არის სახის დაკარგვის ჩემთვის. მაგრამ memo განცხადებით, კარგი, ახლა მე მივიღე, რომ, მდგომარეობა გამოწვეული იყო პროგრამული უზრუნველყოფა დავუპირისპირდეთ შიდა გენერატორი კონტროლი ერთეული, რომელიც წალეკავს შემდეგ 248 დღის უწყვეტი დენის. ჩვენ გაცემისას შეამჩნია თავიდან ასაცილებლად ყველა AC ელექტრო ძალა, რომელიც შეიძლება გამოიწვიოს დაკარგვა კონტროლის თვითმფრინავი. 

ასე რომ, ფაქტიურად, არ არის გარკვეული რიცხვი, ან რომელიმე ექვივალენტს მონაცემები ტიპის, გამოიყენება პროგრამული უზრუნველყოფა ფაქტობრივი თვითმფრინავი რომ თუ თქვენ გაქვთ თქვენი თვითმფრინავი ხანგრძლივი საკმარისი, რომელიც, როგორც ჩანს, შეიძლება იყოს იმ შემთხვევაში თუ თქვენ უბრალოდ გაშვებული მათ მუდმივად და არასოდეს unplugging თქვენი თვითმფრინავი, როგორც ჩანს, ან რომ მისი ბატარეები იღუპება, საბოლოოდ დათვლა მდე, და, და, და, და, და. 

და, ბუნებით, სასრული რაოდენობით მეხსიერება იქნება overflow, მოძრავი თავში ნულოვანი ან გარკვეული უარყოფითი ღირებულება, გვერდითი ეფექტი, რომელიც არის საშინლად რეალური რეალობა რომ თვითმფრინავი შეიძლება უნდა უნდა ქსელი, პრაქტიკულად, ან შეიძლება დაეცემა, უარესი, როგორც ეს ფრიალებს. ასე რომ, ამ სახის საკითხები დღესაც ჩვენთან ერთად, even-- ეს იყო 2015-ე მუხლის, ყველა უფრო საშიში როცა არ არის აუცილებელი მესმის, ვაფასებთ, ან მოსალოდნელია იმ სახის შეცდომები. 

გამოდის, რომ არსებობს ერთი ცუდი რამ მონაცემების წარმომადგენლობა. გამოდის, რომ მაშინაც კი, მოძრავი სახის გაყალბდა, რადგან მოძრავი, ძალიან, მე შევთავაზე 32 ბიტი, ან იქნებ 64 თუ თქვენ იყენებთ ორმაგი. მაგრამ ეს ჯერ კიდევ სასრული. 

და დაჭერა არის, რომ თუ შეგიძლია ბოლო უსასრულო რაოდენობის ნომრები შემდეგ ათობითი წერტილი, არ არსებობს გზა შეუძლიათ ყველა შესაძლო ციფრები, რომ გვასწავლიდნენ კლასის სკოლის შეიძლება არსებობდეს მსოფლიოში. კომპიუტერი, არსებითად, აქვს აირჩიეთ subset იმ ნომრები წარმოადგენს ზუსტად. 

ახლა, კომპიუტერი რაუნდი, შესაძლოა, ცოტა, და შეიძლება საშუალებას გაძლევთ უხეშად მაღაზია ნებისმიერი რაოდენობის თქვენ შესაძლოა გსურთ. მაგრამ უბრალოდ ინტუიციურად, თუ გვაქვს სასრული რაოდენობის ბიტი, თქვენ შეგიძლიათ მხოლოდ permute მათ ამდენი სასრულ გზები. ასე რომ, თქვენ არ შეიძლება გამოყენება სასრულ of permutation ბიტი, ნიმუშების zeros და პირობა, წარმოადგენს უსასრულო ნომერი ნომრები, რომელიც ვარაუდობს, რომ კომპიუტერებს შეიძლება ძალიან კარგად იქნება გვატყუებს ზოგჯერ. 

ფაქტობრივად, მოდით გავაკეთოთ ეს. ნება მომეცით წავიდეთ ისევ CS50 IDE. ნება მომეცით წავიდეთ წინ და შექმნა პატარა პროგრამა მოუწოდა ორაზროვნება, აჩვენებს, რომ კომპიუტერები, მართლაც, ბუნდოვანი. 

და ნება მომეცით წავიდეთ წინ და იწყება ზოგიერთი რომ კოდი ადრე, და ახლა მხოლოდ ამის შემდეგ. ნება მომეცით წავიდეთ წინ და ნუ printf, პროცენტი f, წარმატებული ო, 1 იყოფა 10. სხვა სიტყვებით, მოდით ჩაყვინთვის უფრო ღრმა 1/10, როგორც 1 და იყოფა 10. რა თქმა უნდა, კომპიუტერული შეუძლიათ 1/10. 

მოდით, წავიდეთ წინ და ორაზროვნება. მოდი ვნახოთ. ფორმატი განსაზღვრავს ტიპის ორმაგი. მაგრამ არგუმენტი ტიპის int. რა ხდება? 

ოჰ, საინტერესო, ასე რომ, ეს არის გაკვეთილი წლამდე. მე ვამბობ, hey, კომპიუტერული შოუ მე float ერთად პროცენტი ვ. მაგრამ მე რაც 2 ints. გამოდის, რომ შემიძლია დაფიქსირება ეს არის ორი გზა. 

მე მხოლოდ გახდეს ერთი შევიდა 1.0, და 10 შევიდა 10.0, რაც, რა თქმა უნდა, აქვს ეფექტი კონვერტაცია მათ floats-- მაინც იმედია იგივე რაოდენობა. და აღმოჩნდება, რომ არსებობს რაღაც ჩვენ დავინახავთ, კიდევ დიდი ხნის განმავლობაში. თქვენ შეიძლება მიცემული ნომრები. 

თქვენ შეგიძლიათ გამოყენებით ამ ჩართული გამოხატვის, შეიძლება ითქვას, hey, კომპიუტერი, ამ 10, რაც მე ვიცი არის int. მაგრამ მკურნალობა, გთხოვთ, თითქოს ეს არის float. მაგრამ ეს გრძნობს ზედმეტად რთული. 

ჩვენი მიზნებისთვის, დღეს, მოდით უბრალოდ სიტყვასიტყვით რათა მათ მცურავი პუნქტიანი ღირებულებები ერთად ათობითი წერტილი, მოსწონს ეს. ნება მომეცით წავიდეთ წინ და გამეორება, მიიღოს ორაზროვნება, კარგი, dot slash ორაზროვნება, შევა. OK, ჩვენ ვეძებთ კარგი. 

1 იყოფა 10, ჩემი Mac აქ, მართლაც, 0,100000. ახლა, მე ისწავლება grade სკოლაში უნდა იყოს უსასრულო რაოდენობის 0 ს. ასე რომ, მოდით მაინც ცდილობენ იმისათვის, რომ ნახოთ ზოგიერთი ასეთი. გამოდის, რომ printf არის პატარა fancier მაინც, ვიდრე ჩვენ უკვე გამოყენებით. გამოდის, რომ თქვენ არ უნდა განსაზღვროს მხოლოდ პროცენტი ვ, ან უბრალოდ პროცენტს i. თქვენ შეგიძლიათ რეალურად დააკონკრეტა გარკვეული კონტროლი ვარიანტი აქ. 

კერძოდ, მე ვაპირებ ამბობენ, hey, printf, რეალურად ნახოთ, მე 10 ათობითი რაოდენობა. ასე გამოიყურება ცოტა უცნაური. თქვენ კი ამბობთ პროცენტი, dot, რამდენი ნომრები თუ გვინდა, რომ მას შემდეგ, რაც ათობითი წერტილი და შემდეგ f ბინის, მხოლოდ იმიტომ, რომ რა დოკუმენტაცია ამბობს. ნება მომეცით წავიდეთ წინ და გადარჩენა, რომ. 

და შენიშნავს, ძალიან, მე მისაღებად დაიღალა retyping რამ. ასე რომ მე უბრალოდ შექმნის და ქვემოთ arrow ჩემს გასაღებები აქ. და თუ მე შენარჩუნება hitting up, თქვენ შეგიძლიათ ნახოთ ყველა ბრძანებები რომელიც მე მივიღე, ან არასწორად გააკეთა. 

და მე ვაპირებ წავიდეთ წინ არის და რეალურად არ გამოიყენოთ, რომ, როგორც ჩანს. მიიღოს ორაზროვნება, dot slash imprecision-- ასე რა ისწავლება კლასის სკოლის ამოწმებს. მაშინაც კი, თუ მე ბეჭდვა ეს 10 ათობითი განათავსებს მას, მართლაც, არის 0,10000. მაგრამ იცით, რა? 

მოდით, ცოტა ხარბ. ვთქვათ, როგორიცაა, ეჩვენებინა 55 მიუთითებს შემდეგ ათობითი. მოდით ნამდვილად მიიღოს ამ პროგრამა გარეთ spin. ნება მომეცით რიმეიკი იგი, რათა ორაზროვნება, dot ხაზი, ორაზროვნება. 

და აქ ჩვენ მივდივართ. თქვენი ბავშვობის ტყუილი იყო. როგორც ჩანს, 1 იყოფა 10 მართლაც 0.100000000000000005551115123-- 

რა ხდება? ისე, თურმე, თუ სახის გამოიყურება შორს საკმარისი იმ ფუძემდებლური წარმომადგენლობა ამ ნომერი, რეალურად არ არის ზუსტად 1/10, ან 0.1 და უსასრულო რაოდენობის zeros. ახლა, რატომ არის, რომ? 

ისე, მიუხედავად იმისა, რომ ეს არის მარტივი ნომერი ჩვენს ადამიანებში, 1 იყოფა 10, ეს არის კიდევ ერთი უსასრულოდ ბევრი ციფრები, რომ ჩვენ შეგვიძლია ვიფიქროთ up. მაგრამ კომპიუტერი შეიძლება მხოლოდ წარმოადგენს finitely ბევრი ასე ნომრები. ასე რომ, ფაქტობრივად, რა კომპიუტერული გვიჩვენებს მისი უახლოესი დაახლოებას ნომერი ჩვენ გვინდა, რომ გვჯერა არის 1/10, ან მართლაც 0,10000 უსასრულობა. 

უფრო მეტიც, მიუხედავად იმისა, რომ ეს არის ახლოს, რადგან მას შეუძლია მიიღოს. და, მართლაც, თუ გადავხედავთ ქვეშ Hood, როგორც ჩვენ აქ ვართ ეძებს 55 ციფრისგან შემდეგ ათობითი, ჩვენ რეალურად ვხედავთ, რომ რეალობა. ახლა, როგორც განზე, თუ თქვენ ოდესმე მინახავს movie-- ყველაზე მეტად თქვენ ალბათ haven't-- მაგრამ Superman 3 რამდენიმე წლის წინ, Richard Pryor არსებითად სათავისოდ ეს სინამდვილეში მისი კომპანია მოიპაროს ბევრი ფრაქციები და ფრაქციების pennies იმის გამო, რომ company-- როგორც მახსოვს, ეს იყო while-- იყო არსებითად სროლა მოშორებით არაფერი რომ არ ჯდება შევიდა ცნება ცენტი. 

მაგრამ თუ თქვენ დაამატოთ მდე ყველა ამ პატარა, პატარა, პატარა ნომრები ერთხელ, და ისევ და ისევ, შეგიძლიათ, როგორც მისი საქმე, რათა კარგი თანხა. 

ეს იგივე იდეა იყო ამოღებული off მიერ ბოლოდროინდელი, მაგრამ მაინც ახლა უფროსი ფილმი, სახელწოდებით საოფისე ფართი, სადაც ბიჭები, რომ ფილმი, გააკეთა იგივე, ბრალია ეს მთლიანად დასრულდა, გზა ძალიან ბევრი ფული საბანკო ანგარიშზე. ეს ყველაფერი იყო ძალიან საეჭვო. თუმცა, დღის ბოლოს, ორაზროვნება არის ყველა ჩვენს გარშემო. 

და რომ, ძალიან, შეიძლება იყოს საშინლად შემთხვევაში. გამოდის, რომ Superman 3 და საოფისე ფართი განზე, არსებობს შეიძლება ძალიან რეალური მსოფლიოში ramifications რეალობას ბუნდოვანი წარმომადგენლობა მონაცემები რომ თუნდაც ჩვენ, ადამიანებს ამ დღეს არ არის აუცილებელი მესმის, ისევე, როგორც ჩვენ უნდა, და მახსოვს, როგორც ხშირად, როგორც უნდა. და, მართლაც, შემდეგ კლიპი ეხლა შევხედოთ რამდენიმე ძალიან რეალური სამყაროს შედეგების რა მოხდება, თუ არ ვაფასებთ ორაზროვნება რომ შეიძლება მოხდეს ნომრები წარმომადგენლობა. 

[ვიდეო აღწარმოების] 

-Computers, ჩვენ ყველა მოდის მიიღოს ხშირად სამწუხარო პრობლემები რომ წავიდეთ ერთად them-- შეცდომები, ვირუსების, და პროგრამული უზრუნველყოფის საკითხებზე, მცირე ფასები გადაიხადონ ფონდის. მაგრამ მაღალტექნოლოგიური და მაღალი სიჩქარით სამხედრო და სივრცეში პროგრამა პროგრამები, პატარა პრობლემა შეუძლია განდიდდება შევიდა უბედურება. 

4 ივნისს, 1996, მეცნიერები მზად დაიწყოს უპილოტო Ariane 5 რაკეტა. ეს იყო დატვირთული სამეცნიერო თანამგზავრების შექმნილია ჩამოყალიბება, ზუსტად როგორ დედამიწის მაგნიტური ველი ურთიერთქმედებს ერთად მზის ქარი. სარაკეტო აშენდა ევროპის კოსმოსური სააგენტო, და გააუქმა off მისი დაწესებულებაში სანაპიროზე საფრანგეთის გვიანა. 

ზრდილობის დაახლოებით 37 წამი შევიდა ფრენის, ისინი პირველი შენიშნა რაღაც ხდებოდა არასწორია. საქშენები იყო swiveling in ისე, რომ მათ ნამდვილად არ უნდა. დაახლოებით 40 წამი შევიდა ფრენის, ცხადია, მანქანა არ იყო. 

და ეს მაშინ, როდესაც ისინი გააკეთა გადაწყვეტილება გაანადგუროს იგი. სპექტრი უსაფრთხოების ოფიცერი, უზარმაზარი guts, დაპრესილი ღილაკს, ააფეთქეს სარაკეტო, სანამ ეს მოხდებოდა გახდება საშიშროების საზოგადოებრივი უსაფრთხოების. 

-ეს იყო maiden voyage საქართველოს Ariane 5. და მისი განადგურება მიიღო განათავსეთ იმიტომ, რომ ნაკლი ჩართული ამ სარაკეტო ის პროგრამული უზრუნველყოფა. -The პრობლემა Ariane იყო რომ იყო ნომერი, რომელიც საჭირო 64 bits, გამოხატონ. და მათ სურდათ გარდაქმნას მას 16-bit ნომერი. ისინი ფიქრობდნენ, რომ ნომერი, არასდროს ყოფილა უნდა იყოს ძალიან დიდი, რომ უმრავლესობა ციფრები in 64-bit ნომერი იყო ნული. ისინი არასწორია. 

-The უუნარობა ერთ პროგრამული პროგრამა, მიიღოს სახის ნომერი მიერ კიდევ ერთი ქართველი ერთი ძირი უკმარისობა. პროგრამული უზრუნველყოფის დამუშავება გახდა ძალიან ძვირადღირებული ნაწილი ახალი ტექნოლოგიები. საქართველოს Ariane სარაკეტო ძალიან წარმატებული, იმდენად, რამდენადაც პროგრამული უზრუნველყოფა ის, რომ ეს იყო ასევე გამოიყენება Ariane 5. 

-The ძირითადი პრობლემა იყო ის, რომ Ariane 5 იყო სწრაფად, დააჩქარა სწრაფად. და პროგრამული უზრუნველყოფის არ ჰქონდა აღრიცხული, რომ. 

-The განადგურების სარაკეტო იყო დიდი ფინანსური კატასტროფის ყველა გამო წუთი პროგრამული შეცდომა. მაგრამ ეს არ იყო პირველი დრო მონაცემები კონვერტაციის პრობლემები ჰქონდა ხშირია თანამედროვე სარაკეტო ტექნიკა. 

-in 1991 დაწყების პირველი ყურის ომი, პატრიოტის სარაკეტო გამოცდილი მსგავსი პუნქტების კონვერტაციის პრობლემა. და შედეგად, 28 ადამიანი, 28 ამერიკელი ჯარისკაცი, დაიღუპა და დაახლოებით 100 დაიჭრა, როდესაც პატრიოტთა, რომელიც უნდა დაიცვას შემოსულ Scuds, ვერ ცეცხლი სარაკეტო. 

როცა ერაყში შეიჭრა ქუვეითში და ამერიკა დაიწყო უდაბნოს ქარიშხალი დასაწყისში 1991, Patriot სარაკეტო ბატარეები განალაგეს დასაცავად საუდის არაბეთი და ისრაელი ერაყის Scud სარაკეტო თავდასხმები. პატრიოტის არის აშშ საშუალო დიაპაზონი ზედაპირზე ჰაერის სისტემის, წარმოებული მიერ Raytheon კომპანია. 

-The ზომის პატრიოტის interceptor თავისთავად შესახებ დაახლოებით 20 ფუტი სიგრძის. და იგი იწონის დაახლოებით 2,000 ფუნტი. და იგი ახორციელებს ქობინით დაახლოებით, მე ვფიქრობ, რომ დაახლოებით 150 ფუნტი. და ქობინით თავისთავად მაღალი ასაფეთქებელი, რომელიც აქვს ფრაგმენტები გარშემო. გარსაცმის ქობინით განკუთვნილია იმოქმედოს, როგორც buckshot. 

-The რაკეტები ხორციელდება ოთხი თითო კონტეინერი, და ტრანსპორტირება by ნახევრად მისაბმელიანი. 

-The პატრიოტის რაკეტსაწინააღმდეგო სისტემის მიდის უკან მინიმუმ 20 წელია. თავდაპირველად შექმნილია როგორც საჰაერო თავდაცვის სარაკეტო ჩამოაგდებენ მტრის თვითმფრინავები. პირველ ყურის ომი, როდესაც ომი მოვიდა გასწვრივ, არმიის სურდა გამოიყენოთ იგი ჩამოაგდებენ Scuds, არ თვითმფრინავები. 

ერაყის სამხედრო-საჰაერო ძალები, ასე არ არის დიდი პრობლემა. მაგრამ არმია აწუხებს Scuds. ასე რომ, ისინი ცდილობდნენ განახლება პატრიოტთა. 

-Intercepting მტერი სარაკეტო მოგზაურობა at Mach 5 მიდიოდა იწვევს საკმარისი. მაგრამ როდესაც პატრიოტთა იყო შევარდა მომსახურება, არმია არ იცის ერაყის მოდიფიკაცია რომ გააკეთეს Scuds თითქმის შეუძლებელია მოხვდა. 

რა მოხდა არის Scuds, მოდიოდნენ იყო არასტაბილურია. ისინი wobbling. ამის მიზეზი იყო ერაყელები, რათა რომ 600 კილომეტრის გარეთ 300 კილომეტრიანი რაკეტა, აიღო წონა გარეთ წინ ქობინით. ისინი გააკეთა ქობინით მსუბუქია. 

ახლა პატრიოტთა არის ცდილობს მოვა at Scud. და ყველაზე მეტად იმ დროს, აბსოლუტური უმრავლესობა იმ დროს, ის უბრალოდ ფრენა მიერ Scud. ერთხელ პატრიოტის სისტემის ოპერატორები მიხვდა პატრიოტის ხელიდან გაუშვა მისი სამიზნე, მათ აფეთქდა პატრიოტთა ქობინით რათა თავიდან ავიცილოთ შესაძლო მსხვერპლი, თუ იგი ეძლეოდა დაეცემა, რათა ადგილზე. 

-ეს იყო, რაც ყველაზე ხალხი დაინახა, იმ დიდი fireballs ცაში, და არასწორად როგორც საუბრების საქართველოს Scud ქობინი. 

-Although იმ ღამეს ცა, პატრიოტთა აღმოჩნდა წარმატებით განადგურება Scuds საათზე Dhahran, არ შეიძლება იყოს შეცდომა მის შესრულება. იქ, პატრიოტთა სარადარო სისტემის დაკარგა სიმღერა შემომავალი Scud, და არასდროს დაიწყო გამო პროგრამული ხარვეზი. ეს იყო ისრაელის, რომლებიც პირველად აღმოაჩინეს რომ აღარ სისტემა იყო, დიდი დრო განსხვავება გახდა, გამო საათის ჩართული სისტემაში კომპიუტერში. 

-About ორი კვირით ადრე ტრაგედიის Dhahran, ისრაელის იტყობინება თავდაცვის დეპარტამენტის რომ სისტემა დაკარგვის დროს. შემდეგ დაახლოებით რვა საათის ან გაშვებული, მათ შენიშნეს, რომ სისტემა ხდება შესამჩნევად ნაკლები სიზუსტით. თავდაცვის დეპარტამენტის გამოეხმაურა ვეუბნებოდი ყველა პატრიოტის ბატარეები რომ არ დატოვებს სისტემები დიდი ხნის განმავლობაში. ისინი არ ამბობს, რა დიდი დრო was-- რვა საათის განმავლობაში, 10 საათი, 1000 საათი. არავინ იცოდა. 

-The პატრიოტის ბატარეის დისლოცირებული ზე ყაზარმებში at Dhahran და მისი ყალბი შიდა საათის ყოფილა ზე მეტი 100 საათი იმ ღამეს, 25 თებერვალს. 

-ეს დააფიქსირა, დრო სიზუსტით შესახებ მეათე მეორე. ახლა მეათე მეორე საინტერესო ნომერი, იმიტომ, რომ ეს არ შეიძლება იყოს გამოხატული ბინარული ზუსტად, რომელიც იმას ნიშნავს, რომ არ შეიძლება იყოს გამოხატული ზუსტად ნებისმიერ თანამედროვე ციფრული კომპიუტერი. ეს დაუჯერებელია. 

მაგრამ გამოიყენოს ეს როგორც მაგალითი. ავიღოთ ნომერ მესამე. ერთი მესამედი არ შეიძლება იყოს გამოთქმული ათობითი ზუსტად. ერთი მესამე 0,333 გრძელდება უსასრულობამდე. 

არ არსებობს გზა უნდა გააკეთოს, რომ აბსოლუტური სიზუსტით ათობითი. სწორედ სახის პრობლემა რომ მოხდა პატრიოტია. აღარ სისტემა გაიქცა, უარესი დრო შეცდომა გახდა. 

მას შემდეგ რაც 100 საათი ოპერაცია, შეცდომა იყო მხოლოდ დაახლოებით ერთი მესამედი მეორე. მაგრამ თვალსაზრისით გათვლილი სარაკეტო მოგზაურობა at Mach 5, ის შედეგად თვალთვალის შეცდომა მეტი 600 მეტრია. ეს იქნება ფატალური შეცდომა ჯარისკაცი, თუ რა მოხდა არის Scud დაწყებას იყო გამოვლინდა ადრეული გაფრთხილების თანამგზავრების და მათ იცოდნენ, რომ Scud მოდის მათი საერთო მიმართულებით. მათ არ იციან, სადაც იგი მოდიოდა. 

-ეს იყო ახლა მდე სარადარო კომპონენტი პატრიოტის სისტემის იცავდა Dhahran to იქნებიან და შენარჩუნება სიმღერა შემომავალი მტრის რაკეტა. 

-The სარადარო იყო ძალიან ჭკვიანი. ეს რეალურად აკონტროლოთ პოზიცია Scud, და შემდეგ პროგნოზირება, სადაც ეს, ალბათ, იქნება შემდეგი დრო რადარის გაგზავნილი პულსი გარეთ. რომ ერქვა სპექტრი კარიბჭე. 

მერე, ერთხელ პატრიოტის გადაწყვეტს საკმარისი დრო აქვს გავიდა წასვლა უკან და შემოწმება მომდევნო ადგილმდებარეობა ამ აღმოჩენილი ობიექტი, იგი მიდის უკან. ასე რომ, როდესაც იგი დაბრუნდა არასწორი ადგილი, მაშინ ვერ ხედავს ობიექტი. და იგი გადაწყვეტს, რომ არ არსებობს ობიექტი, ეს იყო ყალბი გამოვლენის და წვეთების სიმღერა. 

-The შემომავალი Scud გაქრა სარადარო ეკრანზე. და წამის შემდეგ, ის გააკრიტიკა შევიდა ყაზარმებში. Scud დაიღუპა 28 და იყო ბოლო ერთი გასროლა დროს პირველი ყურის ომი. 

ტრაგიკულია, განახლებული პროგრამული უზრუნველყოფა მივიდა Dhahran მომდევნო დღეს. პროგრამული ხარვეზი ჰქონდა დაფიქსირებული, დახურვის ერთი თავი პრობლემური ისტორიის პატრიოტის სარაკეტო. 

[ვიდეო აღწარმოების] დევიდ ჯ Malan: ასე რომ, ეს არის ყველა ამბობენ, რომ ამ საკითხებზე overflow და ორაზროვნება ყველანი ძალიან რეალური. ასე რომ, რა გამოდის? ჩვენ დავიწყეთ ლაპარაკი printf. ისევ და ისევ, ეს ფუნქცია, რომელიც ბეჭდავს რაღაც ეკრანზე, და ჩვენ გააცნო შემდეგ რამდენიმე სხვა ფუნქციები საწყისი ე.წ. CS50 ბიბლიოთეკაში. და ჩვენ გავაგრძელებთ ვხედავ ამ დროზე. და ჩვენ, კერძოდ, გამოიყენება მიიღოს სიმებიანი, და მიიღეთ int, და ახლა, ასევე float, და კიდევ სხვები მაინც ვხვდებით და გამოიყენოთ საკუთარ თავს დიდი ხნის განმავლობაში. 

მაგრამ ხანდახან, გვაქვს ჩვენ უკვე ვნახეთ, საჭიროება შესანახად, რაც იმ ფუნქციების მხრივ უკან? ისინი გადასცემს us უკან სიმებიანი, ან int ან float. ზოგჯერ ჩვენ უნდა დააყენოს, რომ სიმებიანი, ან int, ან float, სადღაც. 

და შესანახად იმ რამ, გავიხსენოთ მხოლოდ როგორც Scratch, ჩვენ ცვლადები. მაგრამ განსხვავებით Scratch, in C ჩვენ ნამდვილი სახის ცვლადის მონაცემები სახის, ზოგადად მათ შორის, სიმებიანი, int, float, და ეს სხვები მაინც. 

ასე რომ, როდესაც ვაცხადებთ ცვლადები C, ჩვენ უნდა განაცხადოს ჩვენი მონაცემთა ტიპები. ეს არ არის რაღაც ჩვენ უნდა გავაკეთოთ შემდეგ სემესტრში როგორც ჩვენ გადასვლას სხვა ენებზე. მაგრამ ახლა, ჩვენ გვჭირდება რომ აპრიორი წინასწარ, ავუხსნათ კომპიუტერი, თუ რა ტიპის ცვლადი ჩვენ გვინდა, რომ მოგვცეს. 

ახლა კი, ბეჭდვა იმ სახის მონაცემთა ტიპები, ჩვენ უნდა ვუთხრათ printf რა ელის. და ჩვენ ვნახეთ პროცენტი s სიმები, და პროცენტი i მთელი რიცხვები, და რამდენიმე სხვა უკვე. და ეს არის უბრალოდ მოთხოვნები ვიზუალური პრეზენტაცია რომ ინფორმაციას. 

და თითოეული ეს შეიძლება რეალურად იყოს parametrized და tweaked რამდენიმე გზა, თუ გვინდა, რომ შემდგომი კონტროლი ტიპის გამომუშავება, რომ თქვენ. და, ფაქტობრივად, გამოდის, რომ არა მხოლოდ არის წარმატებული ო ახალი ხაზი. არსებობს რაღაც მოუწოდა წარმატებული r for ვაგონი დაბრუნების, რომელიც უფრო akin რომ ძველი სკოლა საბეჭდი მანქანა, და ასევე Windows გამოიყენება მრავალი წლის განმავლობაში. 

არსებობს წარმატებული t for ჩანართი. გამოდის, რომ, თუ გსურთ ორმაგი ციტირებით შიგნით მისაღებად, გავიხსენოთ, რომ ჩვენ გამოყენებული ორმაგი გაცემა ორმაგი პასუხის მარცხენა და მარჯვენა დამთავრდა ჩვენი სიმები დღემდე. რომელიც, როგორც ჩანს აღრეული რამ. 

თუ გსურთ, რომ ორმაგი ციტირებით შუა სიმებიანი და, მართლაც, ეს გაუგებარია ვხედავ. ასე რომ, თქვენ უნდა გაქცევა, ასე ვთქვათ, ორმაგი ციტირებით რაღაც როგორიცაა, ფაქტიურად, წარმატებული ორმაგი გაცემა. და იქ რამდენიმე სხვა მაინც. ჩვენ დავინახავთ, უფრო იმ ფაქტობრივი გამოყენების დიდი ხნის განმავლობაში. 

მოდით ახლა გადასვლას მონაცემები და წარმომადგენლობა, და არითმეტიკული მოქმედებები, ყველა რომელიც მოგვცა რამდენიმე შენობა ბლოკად, რომლითაც უნდა ითამაშოს. მაგრამ ახლა მოდით რეალურად მისცეს us დანარჩენი ლექსიკა რომ ჩვენ უკვე გვქონდა გასულ კვირას Scratch აღების შევხედოთ ზოგიერთი სხვა აშენებს, C არა ყველა მათგანი. მაგრამ იდეები ჩვენ შესახებ, რომ ნახოთ ნამდვილად აღვნიშნო, რომ თარგმანის ერთი ენა, Scratch, სხვა, C. 

და დროთა განმავლობაში, ჩვენ შეარჩიო სხვა ინსტრუმენტები ჩვენი ინსტრუმენტარიუმის, ასე ვთქვათ, syntactically. და, მართლაც, დაინახავთ, რომ იდეები ახლა საკმაოდ ნაცნობი გასულ კვირას. ასე რომ, მოდით ეს. 

მოდით წავიდეთ წინ და whip up პროგრამა რომ რეალურად იყენებს ზოგიერთი გამონათქვამები, ლოგიკური გამოხატულებაა. ნება მომეცით წავიდეთ წინ აქ და შექმნას ახალი ფაილი. მე მოვუწოდებ ამ condition.c. 

ნება მომეცით წავიდეთ წინ და მოიცავს CS50 ბიბლიოთეკა. და ნება მომეცით წავიდეთ წინ და მოიცავს სტანდარტული io.h ჩვენი ფუნქციები, და printf, და უფრო შესაბამისად. ნება მომეცით მისცეს თავს, რომ შაბლონური of int ძირითადი ბათილად, რომლის განმარტებით, ჩვენ გამოგიგზავნით დაბრუნდება მომავალში. 

ახლა ნება მომეცით წავიდეთ წინ და მისცეს თავს int მეშვეობით მისაღებად int. მაშინ ნება მომეცით წავიდეთ წინ და ამის გაკეთება. მე მინდა ვთქვა, თუ არის less-- მოდით განასხვავოს დადებითი, უარყოფითი, ან ნულოვანი ღირებულებები. 

ასე რომ, თუ ნაკლებია, ვიდრე ნულოვანი, ნება მომეცით უბრალოდ ეს პროგრამა უბრალოდ ამბობენ, უარყოფითი, წარმატებული ო, სხვა თუ არის ნულზე მეტი. ახლა მე, რა თქმა უნდა, ვაპირებ ვთქვა printf დადებითი, წარმატებული ო. და მერე სხვას if-- მე შეეძლო ამის გაკეთება. 

მე ვერ გავაკეთებ, თუ მე უდრის 0. მაგრამ მე მინდა იყოს მიღების მინიმუმ ერთი შეცდომა უკვე. შეგახსენებთ, რომ თანაბარი ნიშანი არ არის თანასწორი, როგორც ჩვენ ადამიანები ვიცით. 

მაგრამ ეს დავალება ოპერატორი. და ჩვენ არ გვინდა, რომ 0 შესახებ უფლება და ამას i მარცხენა. ასე რომ, რათა თავიდან ავიცილოთ ამ დაბნეულობა, ან ალბათ ბოროტად გამოყენების ტოლობის ნიშანი, ადამიანები გადაწყვიტა რამდენიმე წლის წინ რომ მრავალი პროგრამირების ენებზე როდესაც გსურთ შემოწმება თანასწორობის შორის მარცხენა და მარჯვენა, თქვენ რეალურად გამოიყენოთ შეადგენს შეადგენს. ასე რომ თქვენ მოხვდა ტოლობის ნიშანი ორჯერ. როდესაც გსურთ დაავალოს მარჯვნიდან მარცხნივ, თქვენ იყენებთ ერთი თანაბარი ნიშანი. ასე რომ, ჩვენ შეგვიძლია ამის გაკეთება სხვა თუ მე ტოლია ნულის ტოლია. 

მე შეიძლება მერე და გახსნა ჩემი Curly braces, და აცხადებენ, printf 0, წარმატებული ო, გაკეთდეს. მაგრამ გახსოვდეთ, თუ როგორ შეიძლება ამ ჩანგლები საგზაო შეუძლია მუშაობა. და, მართლაც, მხოლოდ ფიქრი ლოგიკა. i არის ნომერი. ის რიცხვი, კონკრეტულად. და ეს ნიშნავს, რომ იქნება ნაკლები, ვიდრე 0, და უფრო მეტი ვიდრე 0 ან 0. ასე რომ, არსებობს სახის ამ ნაგულისხმევი რა შემთხვევაში. 

ასე რომ, ჩვენ შეიძლება, ისევე, როგორც Scratch ათავისუფლებენ სხვაგან, თუ და უბრალოდ, ვამბობთ სხვა. ლოგიკურად, თუ თქვენ პროგრამისტი ვიცი, რომ მხოლოდ სამი თაიგულების, რომელშიც სცენარი შეიძლება fall-- პირველი, მეორე, ან მესამე ამ შემთხვევაში არ შეწუხება და დასძინა, დამატებითი სიზუსტით და დამატებითი ლოგიკა არსებობს. უბრალოდ წავიდეთ წინ ერთად რა შემთხვევაში აქ სხვაგან. 

ახლა, მოდით, წავიდეთ წინ შემდეგ გადარჩენა ეს, პირობები dot ხაზი conditions-- არ არის დიდი ინტერფეისი, იმიტომ, რომ მე არ რითაც შესახებ, როგორც ზემოთ აღინიშნა. მაგრამ ეს ჯარიმა. ჩვენ გავაგრძელებთ მარტივი. მოდით ცდილობენ ნომერი 42. და ეს არის დადებითი. მოდით ცდილობენ ნომერი უარყოფითი 42, უარყოფითი. 

მოდით ცდილობენ ღირებულების 0. და, მართლაც, რომ მუშაობს. ახლა, თქვენ ნახავთ პრობლემების წინაშე ხანგრძლივი, ტესტირება რამ სამჯერ, ალბათ, არ არის საკმარისი. თქვენ ალბათ გსურთ შეამოწმოთ გარკვეული დიდი ციფრები, ზოგიერთი პატარა ნომრები, რამდენიმე კუთხეში შემთხვევებში, როგორც ჩვენ მოვალთ აღწერს მათ. 

მაგრამ ახლა, ეს არის საკმაოდ მარტივი პროგრამა. და მე დარწმუნებული ვარ, რომ, ლოგიკურად, რომ იგი იყოფა სამ შემთხვევაში. და მართლაც, მიუხედავად იმისა, რომ ჩვენ უბრალოდ ორიენტირებულია პოტენციალი downsides ორაზროვნება და overflow, in რეალობაში, სადაც ბევრი CS50 პრობლემები, ჩვენ არ ვაპირებთ ფიქრი შესახებ, ყველა დროის, იმ საკითხებზე overflow და ორაზროვნება, რადგან, ფაქტობრივად, C, ეს, ფაქტობრივად, არ არის, რომ ადვილი, რათა თავიდან ავიცილოთ იმ რამ. თუ გსურთ ითვლიან უფრო დიდი და უფრო დიდი და უფრო დიდი, ირკვევა, არსებობს ტექნიკის შეგიძლიათ გამოიყენოთ, ხშირად ჩართვის რამ მოუწოდა ბიბლიოთეკების, კოლექციების კოდი, რომელიც სხვა ადამიანი წერდა, რომელიც შეგიძლიათ გამოიყენოთ, და სხვა ენებზე, როგორიცაა Java და სხვა, რეალურად მას ბევრი ადვილი დათვლა კიდევ უფრო მაღალი. ასე რომ, ეს ნამდვილად არის ზოგიერთი საფრთხეები ფუნქცია ენის გამოიყენოთ. და მომავალ კვირაში, ჩვენ ვხედავ, რამდენად საშიშია C ნამდვილად შეიძლება თუ არ სწორად გამოყენება. მაგრამ არსებობს და Python და JavaScript, რომელიც ჩვენ ფენის ზოგიერთ დამატებითი დაცვის, და აწარმოებს ნაკლები იმ რისკებს. 

მოდით ცოტა მეტი საინტერესო ლოგიკა ჩვენი პროგრამა. ნება მომეცით წავიდეთ წინ და შევქმნათ პროგრამის მოუწოდა ლოგიკური მხოლოდ ასე შემიძლია თამაში ზოგიერთი ფაქტობრივი ლოგიკა, logical.c. მე უბრალოდ დააკოპირეთ და ჩასვით ზოგიერთი კოდი ადრე ისე მივიღებ უკან ამ ლამაზი ამოსავალი წერტილი. 

მიადევნე თვალი ამჯერად ამის char C. ვარ ვაპირებ, რათა ეს სახელი C მხოლოდ იმიტომ, რომ ჩვეულებრივი, მიიღოს ხასიათი შესახებ. და მოდით პრეტენზია მოსწონს მე განხორციელების ნაწილი რომ Rm პროგრამა, remove პროგრამა ადრე, რომ აიძულა შესახებ ამოიღონ ფაილი. როგორ შეიძლება ამის გაკეთება? 

მე მინდა ვთქვა, თუ C ტოლია უდრის, ციტირებით unquote, y, მაშინ მე ვაპირებ ვივარაუდოთ, რომ მომხმარებელმა აირჩია დიახ. მე უბრალოდ აპირებს ბეჭდვა დიახ. თუ ეს იყო რეალურად წერა მოცილება პროგრამა, ჩვენ შეგვიძლია ამოიღონ ფაილი უფრო ხაზი კოდი. მაგრამ ჩვენ გავაგრძელებთ მარტივი. 

სხვაგან, თუ გ უდრის უდრის N-- და ახლა აქ, მე ვაპირებ ვთქვა, მომხმარებელს უნდა იმას ნიშნავდა, არ არსებობს. და მერე სხვას, იცით, რა? მე არ ვიცი, რა მომხმარებლის აპირებს აკრიფოთ. ასე რომ მე უბრალოდ ვაპირებ ვთქვა, რომ რომ არის შეცდომა, რაც იგი რეალურად აკრეფილი. 

ასე რომ, რა ხდება აქ? არსებობს ფუნდამენტური განსხვავება წინააღმდეგ, რასაც მე ვაკეთებ წარსულში. ორმაგი შეთავაზებები, ორმაგი შეთავაზებები, double შეთავაზებები და, ჯერჯერობით, ერთჯერადი შეთავაზებები, ერთჯერადი შეთავაზებები. თურმე C, რომ როდესაც გსურთ დაწეროთ ტექსტი, თქვენ გამოიყენოთ ორმაგი შეთავაზებები, ისევე, როგორც ჩვენ უკვე გამოყენებით ამ დროს printf. 

მაგრამ თუ გვინდა, რომ გაუმკლავდეთ მხოლოდ ერთჯერადი ხასიათი, ე.წ. char, მაშინ თქვენ ნამდვილად გამოიყენოს ერთჯერადი შეთავაზებები. იმ თქვენ, რომლებიც უკვე დაპროგრამებულია ადრე, თქვენ შეიძლება არ აქვს ჰქონდა ფიქრი განსხვავება გარკვეულ ენებზე. In C, არ აქვს მნიშვნელობა. ასე რომ, როდესაც მივიღებ char და მინდა შედარების რომ char გამოყენებით ტოლობის უტოლდება ზოგიერთი წერილი, როგორც Y ან N, მე, მართლაც, უნდა ჰქონდეს ერთჯერადი შეთავაზებები. 

ახლა, მოდით, წავიდეთ წინ და ამის გაკეთება. მოდით წავიდეთ წინ და მიიღოს ლოგიკური dot slash ლოგიკური. და ახლა მე მიმდინარეობს აიძულა. ასე რომ, სავარაუდოდ, უკეთესი მომხმარებლის, გამოცდილება მაგრამ რეალურად, მეუბნებოდა, თუ რა უნდა გავაკეთოთ აქ. მაგრამ მე ვაპირებ უბრალოდ ბრმად ვთქვათ y დიახ, OK, ლამაზი. 

მოდით გაუშვით ერთხელ, ო, არა, კარგია. დავუშვათ, ისევე როგორც გარკვეული ადამიანი ვიცი, ჩემი caps lock გასაღები არის ძალიან ხშირად. ასე რომ დედაქალაქში Y, შევა, შეცდომა. OK, ეს არ არის ზუსტად ის, რაც მე ელოდება. მართლაც, კომპიუტერული აკეთებს ფაქტიურად რა მე ვუთხარი, რომ გააკეთოს შემოწმება ამას y და ამას n. ეს არ იგრძნონ კარგი მომხმარებლის, გამოცდილება, თუმცა. მიადევნე თვალი ითხოვენ და მიიღოს ან ქვედა ან ზედა შემთხვევაში. ასე რომ, თურმე, დაგვჭირდება ამბობენ, რომ რაღაც, როგორც Scratch, როგორიცაა პირდაპირი თუ C ტოლია უდრის დედაქალაქის ერთ სიტყვებზე y. გამოდის, C -ს ჯერ არ შეუყვანია ეს ლიტერატურული სიტყვით ან. 

მაგრამ მას აქვს ორი ვერტიკალური ბარები. თქვენ უნდა გამართავს Shift, როგორც წესი, თუ თქვენ იყენებთ ამერიკული კლავიატურის, და მოხვდა ვერტიკალური ბარი გასაღები ზემოთ თქვენი დაბრუნების გასაღები. მაგრამ ეს ვერტიკალური ბარი ვერტიკალური ბარი ნიშნავს ან. 

თუ, პირიქით, ჩვენ გვინდოდა, ვთქვა და, როგორც Scratch, ჩვენ შეგვიძლია ამის გაკეთება ampersand ampersand. რომელიც არ აკეთებს ლოგიკური აზრი აქ, იმიტომ, რომ ადამიანს შეუძლია არ შეიძლება აკრეფილი ორივე y და ამას y და კაპიტალის Y როგორც იგივე ხასიათი. ასე რომ, თუ არის ის, რაც ჩვენ ვაპირებთ აქ. 

ასე რომ, თუ ამ ორივე ადგილას, ან გ ტოლია ტოლია კაპიტალის N, ახლა გამეორება, ლოგიკური, გამეორება ლოგიკური. ახლა, შემიძლია აკრიფოთ y. და შემიძლია კიდევ ერთხელ დედაქალაქში Y, ან კაპიტალის N. და მე ვერ დაამატოთ დამატებითი კომბინაციები მაინც. 

ასე რომ, ეს არის ლოგიკური პროგრამა იმდენად, რამდენადაც ახლა მე შემოწმების ლოგიკურად ეს მნიშვნელობა და ღირებულება. და მე არ უნდა, აუცილებლად, ამუშავება კიდევ ორი ​​ifs ან სხვაგან IFS. მე შემიძლია რეალურად ზოგი დაკავშირებული ლოგიკა ერთად ამ გზით. ასე რომ, ეს უკეთესი იქნება შემუშავებული, ვიდრე უბრალოდ ამბობდა, თუ C უდრის ქვედა შემთხვევაში y, ბეჭდვა დიახ, სხვა თუ c შეადგენს კაპიტალის Y, ბეჭდვა დიახ, სხვა თუ გ უდრის lower-- სხვა სიტყვებით, თქვენ არ უნდა ჰქონდეს უფრო და უფრო მეტი ფილიალში. თქვენ შეგიძლიათ დააკავშიროთ ზოგიერთი ექვივალენტი ფილიალები ლოგიკურად, რადგან ამ გზით. 

მოდით შევხედოთ მხოლოდ ერთი საბოლოო ნივთიერება, ერთი საბოლოო მშენებლობა, რომ C საშუალებას აძლევს. და ჩვენ დავბრუნდებით მომავალში სხვები მაინც. და მაშინ ჩვენ დავასკვნათ ეძებს დროს არ სისწორის code-- მიღების კოდი work-- მაგრამ დიზაინი კოდი და მცენარეთა იმ თესლი დასაწყისში. 

ნება მომეცით წავიდეთ წინ და გახსენით ახალი ფაილი აქ. იცი რაა? მე ვაპირებ ხელახლა განხორციელება რომ იმავე პროგრამით, მაგრამ გამოყენებით სხვადასხვა შენება. 

ნება მომეცით სწრაფად მისცეს თავს ხელმისაწვდომობა მოიცავს CS50.h for CS50 ბიბლიოთეკა, სტანდარტული io.h printf. მომეცი ჩემი int ძირითადი ბათილად. და მერე აქ, ნება მომეცით წავიდეთ წინ და ამის გაკეთება. 

Char c იღებს მიიღოს char, ისევე როგორც ადრე. და მე ვაპირებ გამოიყენოთ ახალი შენება ახლა კი გადავიდეს, რა ხასიათი? ასე რომ, switch არის სახის მოსწონს გადართვის მატარებელი სიმღერები. და, მართლაც, ეს არის ერთგვარი თუ სხვაგან, თუ სხვაგან, თუ მაგრამ წერილობითი გარკვეულწილად განსხვავებულად. 

შეცვლა გამოიყურება. თქვენ უნდა შეცვლა, და მერე რა ხასიათი და ნომერი გსურთ შევხედოთ, მაშინ ზოგიერთი Curly braces მომწონს Scratch, უბრალოდ ამბობენ, ამისათვის პერსონალი. და მაშინ თქვენ გაქვთ სხვადასხვა შემთხვევებში. 

თქვენ არ გამოიყენონ, თუ სხვაგან. თქვენ ფაქტიურად გამოიყენოს სიტყვა საქმე. და ვიტყოდი, რაღაც მსგავსი. 

ასე რომ, იმ შემთხვევაში, თუ ამას y, და იმ შემთხვევაში, თუ კაპიტალი Y, წავიდეთ წინ და ამობეჭდოთ დიახ. და შემდეგ შესვენება out შეცვლა. ის არის. ჩვენ გავაკეთეთ. 

სხვაგან, თუ ასე ვთქვათ, ქვედა შემთხვევაში n, ან კაპიტალის N, მაშინ წავიდეთ წინ და ბეჭდვითი out არსებობს და შემდეგ შესვენება. Else-- და ამ სახის არის რა შემთხვევაში indeed-- printf შეცდომა და მხოლოდ კარგი ღონისძიება, თუმცა ლოგიკურად ამ შესვენების არ არის საჭირო იმიტომ, რომ ჩვენ ბოლოს შეცვლა მაინც, მე ახლა არღვევს შეცვლა. ასე რომ, ეს გამოიყურება ცოტა განსხვავებული. 

მაგრამ, ლოგიკურად, ეს რეალურად არ ექვივალენტს. და რატომ გამოვიყენოთ ერთი მეტი სხვა? ზოგჯერ, უბრალოდ პირადი უპირატესობა, ზოგჯერ ესთეტიკას, თუ მე ერთი შეხედვით ეს ახლა, რაღაც უნდა ითქვას, რომ readability ეს კოდი. ვგულისხმობ, არ ნიშნავს, რომ ამ კოდი არის ახალი, რომ ბევრი ჩვენგანი ოთახში. 

მაგრამ ეს მხოლოდ სახის საკმაოდ. ხედავთ ამას y, კაპიტალური Y, ქვედა შემთხვევაში n, დედაქალაქში N default, ეს მხოლოდ სახის გადასვლა იმ თქვენ, ისე, რომელიც, სავარაუდოდ, შესაძლოა წინა მაგალითად ერთად ifs, და ვერტიკალური ბარები, და სხვაგან IFS, შესაძლოა, არ აქვს. ასე რომ, ეს მართლაც საკითხია პირადი არჩევანი, ნამდვილად, ან readability, კოდი. 

მაგრამ იმ თვალსაზრისით, ფუნქციონალური, ნება მომეცით წავიდეთ წინ და შეცვლა, dot slash შეცვლა და ახლა აკრიფოთ ამას y, დედაქალაქში Y, ამას n, კაპიტალური N, დავით, გაიმეორეთ იმიტომ, რომ ის არა ერთი ხასიათი. მოდით გავაკეთოთ x, შეცდომა, როგორც მოსალოდნელი იყო. და, logically-- და ეს არის რაღაც მე მოგიწოდებთ in general-- კი მიუხედავად იმისა, რომ ჩვენ მხოლოდ scratching ზედაპირზე ზოგიერთი ფუნქციები. 

და ეს არ უნდა იყოს აშკარა, როდესაც თქვენ თავს დასხდნენ კლავიატურის, როგორ მუშაობს? რას გააკეთებს? ლამაზი რამ, რომელსაც ნოუთბუქი, ან desktop, და ხელმისაწვდომობის კომპიუტერი ერთად შემდგენელი, და კოდი რედაქტორი, როგორც ეს, ეს შეგიძლიათ თითქმის ყოველთვის უპასუხოს ამ კითხვები საკუთარ თავს მხოლოდ ცდილობს. 

მაგალითად, თუ რიტორიკული კითხვა ხელთ იყო, რა მოხდება, თუ თქვენ დაგავიწყდებათ თქვენი შესვენების განცხადებები? რომელიც რეალურად ძალიან გავრცელებული რამ უნდა გააკეთოს, იმიტომ, რომ ეს არ გამოიყურება როგორც თქვენ ნამდვილად გვჭირდება. ისინი ნამდვილად არ შეავსოთ თქვენი ეგონა მოსწონს ფრჩხილებში ან curly გაუწიოს აკეთებს. მოდით წავიდეთ წინ და recompile კოდი და ვნახოთ. ასე რომ, შეცვლა, dot slash შეცვლა. მოდით აკრიფოთ ქვედა შემთხვევაში y, ზედა შემთხვევაში, შეიტანეთ. ასე რომ, მე აკრეფილი y. 

პროგრამა თქმით კი, არსებობს, შეცდომა, თითქოს ეს იყო იცვლება მისი გონება. მაგრამ ეს სახის იყო, იმიტომ, რომ ის, რაც ხდება გადამრთველით არის პირველი შემთხვევა, რომ მატჩი ნიშნავს, hey კომპიუტერი, შეასრულოს ყველა კოდი ქვეშ იგი. და თუ არ ვთქვა შესვენების, ან არ ვამბობ, შესვენების და არ ვამბობ, შესვენების კომპიუტერული აპირებს აფეთქება ყველა იმ ხაზები და შეასრულოს ყველა მათგანი სანამ იგი იღებს, რომ curly გაუწიოს. ასე რომ, მუხრუჭები, მართლაც, აუცილებელია. მაგრამ takeaway აქ არის, როდესაც ეჭვი, ცდილობენ რაღაც. იქნებ შეინახოთ თქვენი კოდი, პირველ რიგში, და გადარჩენა მას დამატებითი ფაილი თუ თქვენ ნამდვილად აწუხებს ძვირფასი და რომელსაც ფეხზე მუშაობა, რომ თქვენ იცით, მუშაობს. 

მაგრამ ცდილობენ რამ. და არ იქნება როგორც ეშინია, ალბათ, რა კომპიუტერი შეიძლება გავაკეთოთ, ან, რომ თქვენ შეიძლება დაარღვიოს რაღაც. თქვენ ყოველთვის შეგიძლიათ აღადგინოთ უკან ზოგიერთი ადრე ვერსია. 

მოდით დასრულდება ეძებს დიზაინის კოდი. ჩვენ გვაქვს ეს შესაძლებლობა ახლა დაწერა პირობები და ჩაწერის მარყუჟების, და ცვლადები, და მოვუწოდებთ ფუნქციები. ასე რომ, სიმართლე გითხრათ, ჩვენ სახის უკან სადაც ჩვენ ვიყავით, ერთი კვირის წინ, რომელზეც Scratch, თუმცა ნაკლებად დამაჯერებელი ტექსტური გარემოს, ვიდრე Scratch საშუალებას აძლევს. 

მაგრამ შეამჩნია, რამდენად სწრაფად ჩვენ შეიძინა რომ ლექსიკა, მაშინაც კი, თუ ის აპირებს ცოტა ხნით ჩაიძიროს წელს, ასე რომ, ჩვენ შეგვიძლია ახლა გამოვიყენოთ ეს ლექსიკა დაწერა უფრო საინტერესო პროგრამები. და მოდით ბავშვის ნაბიჯი მიმართ, რომ ასეთია. ნება მომეცით წავიდეთ წინ და შექმნა ახალი ფაილი აქ. 

მე ვაპირებ მოვუწოდო ამ prototype.c და დანერგვა პირველად, უნარი რათა საკუთარი ფუნქციები. ზოგიერთი ალბათ გაკეთდეს ამ Scratch, რომლის დროსაც თქვენ შეგიძლიათ შექმნათ თქვენი საკუთარი ბლოკები Scratch, და შემდეგ გადაიტანეთ ისინი ადგილზე იქ, სადაც გსურთ in C. და უმეტეს პროგრამირების ენებზე, შეგიძლიათ ზუსტად that-- რათა საკუთარი ფუნქციები, თუ ისინი არ არსებობს. 

ასე, მაგალითად, ნება მომეცით წავიდეთ წინ და მოიცავს CS50.h, და მოიცავს სტანდარტული io.h, int ძირითადი ბათილად. და ახლა ჩვენ გვაქვს ჩანაცვლების მზად ვართ წავიდეთ. მე შენარჩუნება ბეჭდვა რამ როგორიცაა ხალხის სახელები დღეს. და რომ გრძნობს მოსწონს არ იქნება ლამაზი თუ იყო ფუნქცია მოუწოდა ბეჭდვითი სახელი? მე არ უნდა გამოვიყენოთ printf. მე არ უნდა გვახსოვდეს, ყველა ფორმატის კოდები. რატომ არ, ან რატომ არ ვინმე ჩემს წინაშე, შექმნა ფუნქცია მოუწოდა ბეჭდვითი სახელი, რომ გარკვეული სახელი, უბრალოდ ბეჭდავს მას? 

სხვა სიტყვებით, თუ ვიტყვი, hey, კომპიუტერი, მომეცი სიმებიანი ეკითხება შესახებ ასეთი, მეშვეობით CS50 ის მიიღოს სიმებიანი ფუნქცია. Hey, კომპიუტერი, დააყენა, რომ სიმებიანი ცვლადი მარცხენა მხარეს, და მოვუწოდებთ მას s. და მაშინ, hey კომპიუტერი, წავიდეთ წინ და ბეჭდვა, რომ პირის სახელი, გაკეთდეს. 

ახლა, რომ კარგი იქნება, იმიტომ, რომ ეს პროგრამა, aptly დაასახელა, მეუბნება რაც უნდა გააკეთოს გზით იმ ფუნქციის სახელები. ნება მომეცით წავიდეთ და მიიღოს პროტოტიპი, შეიტანეთ. და, სამწუხაროდ, ეს არ აპირებს დაფრინავენ. 

Prototype.c, ხაზის 7, ხასიათი 5 შეცდომა, დაფარული დეკლარაცია ფუნქცია ბეჭდვითი სახელი არასწორი C99, C99 რაც იმას ნიშნავს, მობილური C რომელიც გამოვიდა 1999 წელს. სულ ეს არის. 

ასე რომ, მე არ ვიცი, რა ყველა ეს იმას ნიშნავს, არ არის. მაგრამ მე აღიაროს შეცდომა წითელი. ეს არის საკმაოდ ნათელია. 

და, როგორც ჩანს, რომ მწვანე ხასიათი აქ, საკითხი არის ბეჭდვის სახელი, ღია paren s, close paren, ნახევრად მსხვილი ნაწლავის. მაგრამ დაფარული დეკლარაცია ფუნქცია ჩვენ არ ვხედავთ მოკლედ ადრე. ეს იმას ნიშნავს, უბრალოდ, რომ Clang არ ვიცი, რას ვგულისხმობ. 

მე გამოიყენება ლექსიკონში სიტყვა, რომ ეს მინახავს ან უსწავლებიათ ადრე. ასე რომ, მე უნდა ასწავლოს მას რა ამ ფუნქციის ნიშნავს. ამიტომ, მე ვაპირებ წავიდეთ წინ და ამის გაკეთება. 

მე ვაპირებ წავიდეთ წინ და განახორციელოს ჩემი საკუთარი ფუნქცია მოუწოდა Print სახელი. და მე ვაპირებ ვთქვა, ასეთია, რომ ამას, printf, hello, პროცენტი s, წარმატებული ო, სახელი, ნახევრად მსხვილი ნაწლავის. ასე რომ, რა მე მხოლოდ ამის გაკეთება? 

ასე რომ, თურმე, რომ განახორციელოს საკუთარი ფუნქცია, ჩვენ სახის სესხება ზოგიერთი იგივე სტრუქტურა, როგორც მთავარი რომ ვიყავით თავისთავად, და მე ვიცი მხოლოდ კოპირება და pasting საკმაოდ ბევრი რა მე უკვე წერდა წარსულში. მაგრამ შეამჩნია ნიმუში აქ. Int, მთავარი, ბათილად, ჩვენ აჯავრებენ გარდა სანამ ხანგრძლივი, რა, რომ ფაქტიურად ნიშნავს. 

მაგრამ დღეს, მხოლოდ შეამჩნია პარალელიზმი. Void, ბეჭდვითი სახელი, სიმებიანი სახელი, ასე რომ, მეწამული სიტყვით, რომელიც ჩვენ ვაპირებთ, რომ დაიწყოს მოუწოდებდა დაბრუნების ტიპის, სახელი ფუნქცია, და მაშინ შეყვანის. ასე რომ, ფაქტობრივად, ჩვენ შეგვიძლია გამოიხადოს ამ სახის როგორც გასულ კვირას როგორც, ეს არის სახელის ან ალგორითმი კოდი ჩვენ აპირებს წერა ალგორითმი უდევს კოდი ჩვენ ვაპირებთ დაწერა. 

ეს არის მისი შეყვანის. ეს არის მისი გამომუშავება. ეს ფუნქცია, ბეჭდვითი სახელი, არის შექმნილია მიიღოს სიმებიანი მოუწოდა სახელი, ან რასაც, როგორც შეყვანის და შემდეგ ბათილად. ის არ დაბრუნდება არაფერი, როგორიცაა მიიღოს სიმებიანი ან int აკეთებს. ასე რომ, ის აპირებს გადასცემს ჩემთვის რაღაც უკან. უბრალოდ აპირებს გვერდითი ეფექტი, ასე ვთქვათ, დაბეჭდვის პირის სახელი. ასე რომ შეამჩნია, ხაზის 7, I შეგიძლიათ დარეკოთ ბეჭდვითი სახელი. Line 10, მე შეიძლება განისაზღვროს ან განახორციელოს ბეჭდვითი სახელი. მაგრამ, სამწუხაროდ, ეს არ არის საკმარისი. 

ნება მომეცით წავიდეთ წინ და recompile ამ შემდეგ გადარჩენა. Whoa, ახლა, მე გახადა უარესი, როგორც ჩანს. ასე რომ, დაფარული დეკლარაცია ფუნქცია ბეჭდვითი სახელი არასწორია. და კიდევ ერთხელ, იქ უფრო მეტი შეცდომები. მაგრამ, როგორც მე გააფრთხილა ადრე, მაშინაც კი, თუ თქვენ გაქვთ overwhelmed ერთად, და ცოტა სევდიანი, რომ ამდენი შეცდომები, ფოკუსირება მხოლოდ პირველი თავდაპირველად, რადგან ეს შეიძლება მხოლოდ არ ჰქონდა კასკადური ეფექტი. ასე რომ, C, ან Clang უფრო კონკრეტულად, ჯერ კიდევ არ აღიარებს ბეჭდვითი სახელი. 

და ეს იმიტომ, Clang, დიზაინი, არის სახის მუნჯები. ეს მხოლოდ იმას აკეთებს, რაც თქვენ ვუთხრა მას ამის გაკეთება. და ეს მხოლოდ ასე იქცევა იმ მიზნით რომელშიც თქვენ ვუთხრა მას ამის გაკეთება. 

ასე რომ, მე არ განისაზღვრება ძირითადი on line ოთხი, როგორც ჩვენ უკვე აკეთებს საკმაოდ ხშირად. მე განისაზღვრება ბეჭდვითი სახელი on line 10. მაგრამ ვცდილობ გამოყენება ბეჭდვითი სახელი on line შვიდი. 

ეს ძალიან მალე, ჯერ არ არსებობს. ასე რომ, მე შეიძლება იყოს ჭკვიანი, და მოსწონს, OK, მოდით უბრალოდ ითამაშოს გასწვრივ, და გადაადგილება ბეჭდვითი სახელს აქ, და ხელახლა შედგენა. ღმერთო ჩემო. იგი მუშაობდა. ეს იყო მარტივი, როგორც ეს. 

მაგრამ ლოგიკა არის ზუსტად რომ. თქვენ უნდა ასწავლოს Clang ის, რაც არის განსაზღვრის ფუნქცია პირველი. ამის შემდეგ შეგიძლიათ გამოიყენოთ იგი. მაგრამ, სიმართლე გითხრათ, ამ გრძნობს როგორიცაა მოლიპულ ფერდობზე. 

ასე რომ, ყოველ ჯერზე მე აწარმოებს პრობლემას, მე მხოლოდ აპირებს ხაზი გავუსვა და დააკოპირეთ კოდი მე დავწერე, დაჭრილი და ჩასვით აქ. და, რა თქმა უნდა, ჩვენ შეგვიძლია contrive ზოგიერთი სცენარი სადაც ერთი ფუნქცია შეიძლება უნდა მოვუწოდებთ სხვა. და თქვენ უბრალოდ ვერ დააყენა ყველა ფუნქცია ზემოთ ყველა სხვა. 

ასე რომ, ეს თურმე არსებობს უკეთესი. შეგვიძლია დატოვეთ ეს იყოს. და, სიმართლე გითხრათ, ეს ზოგადად კარგია, და მოსახერხებელი, და კარგი დიზაინი იმისათვის, რომ მთავარი, პირველ რიგში, იმიტომ, რომ, კიდევ ერთხელ, მთავარი, ისევე, როგორც, როდესაც მწვანე დროშა დააწკაპებთ, რომ არის ფუნქცია, რომელიც იღებს შესრულებული იყოს. ასე, რომ თქვენ შეიძლება ასევე დააყენა მას ზედა ფაილი ასე რომ, როდესაც თქვენ ან სხვა ადამიანის უყურებს ფაილი თქვენ იცით, რა ხდება მხოლოდ კითხულობს მთავარ პირველი. ასე რომ, თურმე, ჩვენ შეგვიძლია გითხრათ Clang აქტიურად, hey, Clang, on line ოთხი, მე გპირდებით, რომ განახორციელოს ფუნქცია მოუწოდა Print სახელი, რომელიც იღებს სიმებიანი მოუწოდა სახელი როგორც შეყვანის, და ბრუნდება არაფერი, ბათილად. და მე გარშემო განხორციელების შემდეგ. 

აქ მოდის მთავარი. მთავარი ახლა on line 9 შეგიძლიათ გამოიყენოთ Print სახელი, რადგან Clang არის ვაღიარებთ, რომ, საბოლოო ჯამში, ეს ექმნებათ განმარტება განხორციელების Print სახელი. ასე რომ, შემდეგ გადარჩენა ჩემი ფაილი, ნება მომეცით წავიდეთ წინ და მიიღოს პროტოტიპი, კარგად გამოიყურება ამ დროს. Dot ხაზი, პროტოტიპი, ნება მომეცით წავიდეთ წინ და ჩაწერეთ სახელი. David, გამარჯობა დავით, Zamila, hello Zamila, და, მართლაც, ახლა ის მუშაობს. 

ასე რომ, ნივთიერება, რომელიც აქ არის, რომ ჩვენ გააკეთა საბაჟო ფუნქცია, როგორიცაა საბაჟო Scratch ბლოკი ჩვენ უწოდა. მაგრამ განსხვავებით Scratch, სადაც შეგიძლიათ უბრალოდ შექმნათ და დაიწყოს მისი გამოყენება, ახლა ჩვენ უნდა იყოს ცოტა მეტი pedantic, და რეალურად მოამზადებენ Clang გამოყენება, ან ველოდებით მას. ახლა, როგორც განზე, ამიტომ ყველა ეს დრო უნდა ჩვენ უკვე უბრალოდ ბრმად რწმენა, მათ შორის CS50.h, და მათ შორის სტანდარტული io.h? 

ისე, თურმე, მათ შორის რამდენიმე სხვა რამ, ყველა, რომ იმ dot h ფაილი, რომელიც არ უნდა იყოს, ფაილი. ისინი header ფაილი, ასე ვთქვათ. ისინი ჯერ კიდევ დაწერილი C. მაგრამ ისინი სხვადასხვა ტიპის ფაილი. 

ახლა, თქვენ საკმაოდ ბევრი ვივარაუდოთ, რომ ყველა, რომ არის შიგნით CS50.h რამდენიმე ერთი სამგზავრო, როგორც ეს, არ ფუნქციები მოუწოდა Print სახელი, მაგრამ სიმებიანი, ოჯახის Float და რამდენიმე სხვა. და არსებობს მსგავსი პროტოტიპები, ერთი სამგზავრო, შიგნით სტანდარტული io.h for printf, რომელიც ახლა ჩემი საკუთარი Print სახელი ფუნქცია. ასე რომ, სხვა სიტყვებით, მთელი ამ ხნის ჩვენ უბრალოდ ბრმად კოპირება და pasting მოიცავს ამ, მოიცავს რომ ის, რაც ხდება? ეს არის მხოლოდ სახის clues to Clang, თუ რა ფუნქციები არიან, მართლაც, განხორციელდა, მხოლოდ სხვაგან სხვადასხვა ფაილები სხვაგან სისტემა. 

ასე რომ, ჩვენ განხორციელებული ბეჭდვითი სახელი. მას აქვს ეს გვერდითი ეფექტი ბეჭდვა რაღაც ეკრანზე. მაგრამ ეს იმას არ რეალურად გადასცემს ჩემთვის რაღაც უკან. როგორ წავიდეთ შესახებ ახორციელებს პროგრამას, რომელიც ამჯამად გადასცემს ჩემთვის რაღაც უკან? 

ისე, მოდით ცდილობენ. ნება მომეცით წავიდეთ წინ და განახორციელოს ფაილი სახელად return.c ასე რომ ჩვენ შეგვიძლია ვაჩვენოთ, თუ როგორ რაღაც როგორიცაა მიიღეთ სიმებიანი, ან int, რეალურად დაბრუნების რაღაც თავში შესახებ. მოდით წავიდეთ წინ და განსაზღვროს int ძირითადი ბათილად. 

და კიდევ ერთხელ, მომავალში, ჩვენ ახსნას რა, რომ int და რომ ბათილად რეალურად აკეთებს. მაგრამ დღეს, ჩვენ მას მიანიჭა. მე ვაპირებ წავიდეთ წინ და printf, კარგი მომხმარებლის, გამოცდილება, x არის. და შემდეგ მე ვაპირებ დაველოდოთ შესახებ მომეცი x ერთად მისაღებად int. 

და შემდეგ მე ვაპირებ წავიდეთ წინ და ამობეჭდოთ x მოედანზე. ასე რომ, როდესაც თქვენ მხოლოდ კლავიატურის, ადამიანი ხშირად გამოიყენოთ პატარა სტაფილოს სიმბოლო კლავიატურაზე წარმოადგენს ძალა ან მაჩვენებლებით. ასე რომ x კვადრატი იმყოფება i. 

და ახლა მე ვაპირებ ამის გაკეთება. მე შეიძლება მხოლოდ გავაკეთოთ რა არის x კვადრატში? x კვადრატი x * x. 

და ჩვენ ეს რაღაც ხნის ​​წინ, უკვე დღეს. ეს არ იგრძნონ ყველა რომ ბევრი მიმდინარეობს. იცი რაა? მოდით ბერკეტები ზოგიერთი რომ იდეა ბოლო დროს აბსტრაქცია. 

თუ არ იქნება ლამაზი, თუ არსებობს ფუნქცია მოუწოდა მოედანზე, ზუსტად რომ? ეს მაინც, ბოლოს დღეს, იგივეს მათემატიკის. მაგრამ მოდით აბსტრაქტული მოშორებით იდეა აღების ერთი ნომერი მრავლდება კიდევ ერთი, და მხოლოდ მისთვის სახელი, როგორც კვადრატული მნიშვნელობა. 

და, სხვა სიტყვებით, C, მოდით შევქმნათ ფუნქცია მოუწოდა მოედანზე, რომ ზუსტად რომ. ეს იქნება მოუწოდა მოედანზე. იგი აპირებს მიიღოს int. და ჩვენ უბრალოდ ძალიან ეძახით n, by default. 

მაგრამ ჩვენ შეგვიძლია ეძახით არაფერი გვინდა. და ყველა, რომ ის აპირებს ამის გაკეთება, ფაქტიურად, არის დაბრუნება შედეგი ო ჯერ n. არამედ იმიტომ, რომ ეს არის დაბრუნების რაღაც, რაც არის სიტყვით purple ჩვენ არასოდეს მინახავს ადრე, I, on line 11, ვერ ვიტყვით ბათილად ამ დროს. 

Void, რომ მაგალითად ჩვენ ვნახეთ საკმაოდ ბეჭდვითი სახელი, მხოლოდ იმას ნიშნავს, გააკეთე რამე. მაგრამ არ გადასცემს ჩემთვის რაღაც უკან. ამ შემთხვევაში, მე არ მინდა დაბრუნებას N ჯერ N, და რასაც არ არის, რომ ნომერი. 

ასე რომ, მე ვერ ვიტყვი, hey, კომპიუტერი, მე დაბრუნებას არაფერი, ბათილად. ეს დაბრუნებას აპირებს, ბუნებით, int. და ისე, რომ ყველაფერი, რაც ხდება აქ. 

შეყვანის მოედანზე იქნება int. ასე რომ, ჩვენ შეგვიძლია გამოვიყენოთ, მას აქვს აქვს სახელი, N. იგი აპირებს გამომავალი int, რომ არ უნდა სახელი. ჩვენ შეგვიძლია დატოვოს ის ძირითადი, ან ვინც არის გამოყენებით ჩემთან უნდა გვახსოვდეს ეს მნიშვნელობა, თუ ჩვენ გსურთ საკუთარი ცვლადი. 

და, კიდევ ერთხელ, მხოლოდ ახალი სიტყვით აქ არის დაბრუნება. და მე უბრალოდ აკეთებს რამდენიმე მათემატიკის. თუ მართლა მინდოდა, რომ საჭირო არ არის, მე ვერ ვიტყვი, int პროდუქტი იღებს N ჯერ N. 

და მაშინ მე ვერ ამბობენ, დაბრუნება პროდუქტი. მაგრამ, ერთხელ, ჩემი აზრით ადრე ეს უბრალოდ არ არის, რომ კარგი design-- , რატომ გააცნობს სახელი, სიმბოლო, როგორც პროდუქტი, მხოლოდ დაუყოვნებლივ დაბრუნება? ეს ცოტა სუფთა, ცოტა უფრო მჭიდრო, ასე რომ, ვთქვათ, უბრალოდ ვთქვა დაბრუნებას n ჯერ n, თავი დაეღწია ამ ხაზი საერთოდ. 

და ეს მხოლოდ ნაკლებად კოდი წავიკითხე, ნაკლები შანსი შეცდომები. მოდით ვნახოთ, თუ ეს რეალურად მუშაობს. ახლა, მე ვაპირებ წასვლა წინ და უკან დაბრუნება. 

უი, დაფარული დეკლარაცია ფუნქცია. მე ეს შეცდომა ადრე, არ არის დიდი გარიგება. ნება მომეცით, უბრალოდ აკრიფოთ, ან ხაზი გავუსვა და ასლი, ზუსტად იგივე ფუნქცია პროტოტიპი, ხელმოწერა, ფუნქცია აქ. ან მე ვერ გადავა მთელი ფუნქცია. 

მაგრამ ეს, ცოტა ზარმაცი. ასე რომ, ჩვენ არ გაგვაჩნია. ნება მომეცით, რათა სანაცვლოდ ერთხელ, dot ხაზი დაბრუნებას. 

x არის 2. x კვადრატი არის 4. x 3. x კვადრატი არის 9. და ფუნქცია, როგორც ჩანს, ახლა უნდა მუშაობა. ასე რომ, რა არის განსხვავება აქ? მაქვს ფუნქცია, ე.წ. მოედანზე, ამ შემთხვევაში, რომელიც მე დააყენა შეყვანა. და არ დავიბრუნებ გამომუშავება. და კიდევ, ადრე, თუ გავხსნა მეორე მაგალითი ადრე, რომელიც ეწოდა prototype.c, მე მქონდა ბეჭდვითი სახელი, რომელიც დაბრუნდა ბათილად, ასე ვთქვათ, და იგი დაბრუნდა არაფერი, და უბრალოდ ჰქონდა გვერდითი ეფექტი. 

ასე რომ, რა ხდება აქ? განვიხილოთ ფუნქცია სიმებიანი მხოლოდ ერთი წუთით. ჩვენ უკვე გამოყენებით ფუნქცია სიმებიანი შემდეგ გზა. 

ჩვენ გვქონდა ფუნქცია მისაღებად სიმებიანი, როგორიცაა მოიცავს CS50.h, მოიცავს სტანდარტული io.h, int, მთავარი, ბათილად. და შემდეგ ყოველ ჯერზე მე მოუწოდა მიიღოს სიმებიანი დღემდე, მე განაცხადა, რაღაც, string s იღებს მიიღოს სიმებიანი, რადგან მისაღებად სიმებიანი მოდით მოვუწოდებთ ამ get.c-- მიიღოს სიმებიანი თავად დააბრუნებს სიმებიანი რომ მე მაშინ გამოყენება, და აცხადებენ, მძიმით, პროცენტს s, წარმატებული ო, s. 

ასე რომ, ეს არის იგივე, მაგალითად, მართლაც, რომ ჩვენ გვქონდა ადრე. ასე რომ სიმებიანი ბრუნდება მნიშვნელობა. მაგრამ ერთი წუთით წინ, ბეჭდვითი string არ დაბრუნდება მნიშვნელობა. ეს უბრალოდ გვერდითი ეფექტი. ასე რომ, ეს არის ფუნდამენტური განსხვავება. ჩვენ ვნახეთ სხვადასხვა სახის ფუნქციებს ახლა, რომელთა დაბრუნდა ღირებულებები, რომელთაგან ზოგიერთი არ. ასე რომ, შესაძლოა, ეს ტექსტი, ან int, ან float. ან იქნებ ეს მხოლოდ ბათილად. 

და განსხვავება არის რომ ამ ფუნქციები, მონაცემების მისაღებად და დაბრუნდება მნიშვნელობა, ფაქტობრივად, შემოტანა რაღაც უკან მაგიდასთან, ასე ვთქვათ. მოდით წავიდეთ წინ და შეხედეთ ერთი საბოლოო ნაკრები მაგალითები, რომ აძლევს გრძნობა, ახლა, როგორ შეიძლება, მართლაც, აბსტრაქტული უკეთესი, და უკეთესი და უკეთესი, ან მეტი, და სულ უფრო და უფრო, რათა დაწერა, საბოლოო ჯამში, უკეთესი კოდი. მოდით წავიდეთ წინ და სული of Scratch, ამის შემდეგ. 

ნება მომეცით წავიდეთ წინ და მოიცავს CS50.h და სტანდარტული io.h. ნება მომეცით წავიდეთ წინ და მისცეს თავს int, მთავარი, ბათილად. და ნება მომეცით წავიდეთ წინ, დარეკეთ ამ cough.c. 

და ნება მომეცით წავიდეთ წინ და მხოლოდ როგორც Scratch, ამობეჭდოთ ხველა / ნ. და მე მინდა, რომ ამის გაკეთება სამჯერ. ასე რომ, მე, რა თქმა უნდა, უბრალოდ აპირებს დააკოპირეთ და ჩასვით სამჯერ. მე ახლა აპირებს, რათა ხველა dot slash ხველა. მოდით, თავს ცოტა მეტი ოთახი აქ, შეიყვანეთ, ხველა, ხველა, ხველა. 

იქ, ცხადია, უკვე შესაძლებლობა გაუმჯობესებას. მე გადაწერა და გაკრული რამდენჯერმე დღეს. მაგრამ ეს იყო მხოლოდ მე არ უნდა აკრიფოთ როგორც ბევრი სიმბოლოები. მე მაინც შეცვალა იმ ხაზების კოდი არიან. 

ამ სამი ხაზები იდენტურია, რომელიც გრძნობს ზარმაცი და მართლაც არის, და ალბათ, არ არის სწორი მიდგომა. ასე რომ, რა ნივთიერება შეიძლება გაუმჯობესდეს ეს კოდი? ჩვენ არ უნდა დააკოპირეთ და ჩასვით კოდი. 

და, მართლაც, ნებისმიერ დროს გრძნობთ თავის კოპირება და pasting, და კი არ იცვლება კოდი, შანსი არსებობს უკეთესი გზა. და, მართლაც, არ არსებობს. ნება მომეცით წავიდეთ წინ და ნუ ამისთვის მარყუჟის, მიუხედავად იმისა, რომ სინტაქსი არ შეიძლება მოდის, ბუნებრივია, არ არის. 

ამისათვის სამჯერ, უბრალოდ ამით ასეთია და მე არ უნდა იცოდეს, ეს პრაქტიკა. მაგრამ ჩვენ გვაქვს მთელი რიგი მაგალითები ახლა. და დაინახავთ ონლაინ მეტი ცნობას მაინც. 

ეს არის სინტაქსი on line 6, რომელიც ჰგავს Scratch რომ იმეორებს ბლოკი, ვიმეორებ, შემდეგ სამჯერ. ეს არის პატარა ჯადოსნური ახლა. მაგრამ ეს უფრო, და უფრო იცნობს. 

და ის აპირებს გაიმეოროს ხაზის რვა სამჯერ, ასე რომ, თუ მე ხელახლა შედგენა make ხველა, dot slash ხველა, ხველა, ხველა, ხველა. ეს ჯერ კიდევ მუშაობს იგივე გზით. ასე რომ, ყველა კარგი და კეთილი. მაგრამ ეს არ არის ძალიან ამოღებული. 

ეს შესანიშნავად სწორი. მაგრამ ეს იგრძნობა არსებობს შეიძლება იყოს შესაძლებლობა, როგორც მსოფლიოში Scratch, რომ სახის დაწყება რომ დაამატოთ ზოგიერთი სემანტიკა აქ, ასე რომ მე არ მხოლოდ გარკვეული მარყუჟის, და ფუნქცია, რომელიც ამბობს, ხველა, ან საერთოდ ხველა. იცი რაა? ნება მომეცით ცდილობენ იყოს პატარა ქულერი, ვიდრე, და რეალურად დაწერეთ ფუნქცია, რომელიც აქვს გვერდითი მოვლენები, მას ხველა. 

და სჭირდება შეყვანის და ბრუნდება არ ღირებულება როგორც გამომავალი. მაგრამ თქვენ იცით, რას აკეთებს? ეს აკეთებს ამას printf, ციტირებით unquote, ხველა. 

და ახლა, აქ, მე ვაპირებ წავიდეთ წინ და int, i იღებს ნულოვანი, მე არანაკლებ 3, i plus plus. მე ვაპირებ ამის გაკეთება არ printf, რომელიც სავარაუდოდ დაბალი დონეზე განხორციელების დეტალურად. მე არ მაინტერესებს, როგორ ხველა. მე უბრალოდ მინდა გამოიყენოთ ხველა ფუნქცია. და მე უბრალოდ ვაპირებ მოვუწოდო ხველა. 

ახლა, დიქოტომია. როცა რეკავთ ფუნქცია, თუ არ მინდა ეს საშუალებებით, სრულიად ჯარიმა. მხოლოდ ამის ღია paren ახლოს, paren, და თქვენ კეთდება. 

როდესაც თქვენ განსაზღვრავს ფუნქცია, ან განაცხადოს ფუნქციის პროტოტიპი, თუ იცით წინასწარ, რომ ეს არ აპირებს მიიღოს ნებისმიერი არგუმენტაცია, ამბობენ, ბათილად იმ ფრჩხილებში არსებობს. და, რაც გარკვეული, რომ თქვენ არ შემთხვევით არასწორად იყენებს მას. ნება მომეცით წავიდეთ წინ და ხველა. და, რა თქმა უნდა, მე შეცდომა დაუშვა. 

Dammit, იქ რომ დაფარული დეკლარაცია. მაგრამ ეს ჯარიმა. ეს ადვილი სარემონტო. მე უბრალოდ უნდა პროტოტიპი უმაღლესი ჩემი ფაილი, ვიდრე მე რეალურად გამოყენება. 

ასე რომ, ახლა ნება მომეცით ხველა ერთხელ, ლამაზი. ახლა, მუშაობს. ჩადება ხველა, ხველა, ხველა, ხველა. ასე, რომ თქვენ ალბათ ფიქრობთ, რომ ჩვენ ნამდვილად უბრალოდ მეტი საინჟინრო ეს პრობლემა. და, მართლაც, ჩვენ ვართ. ეს არ არის კარგი კანდიდატი პროგრამა მომენტისათვის Refactoring და აკეთებს რა მოუწოდა იერარქიული რღვევა, სადაც თქვენ მიიღოს რაღაც კოდი, და შემდეგ თქვენ სახის ფაქტორი რამ, ისე, რომ ანიჭებს უფრო სემანტიკა მათ, და reuse ეს, საბოლოო ჯამში, გრძელვადიან პერსპექტივაში. მაგრამ ეს შენობა ბლოკი მიმართ უფრო დახვეწილი პროგრამები რომ ჩვენ დაიწყება წერა ადრე ხანგრძლივი, რომ საშუალებას გვაძლევს, ლექსიკა , რომლის დაწერა უკეთესი კოდი. და, მართლაც, ვნახოთ, თუ ჩვენ ვერ განზოგადება ამ შემდგომი. 

როგორც ჩანს, პატარა კოჭლი რომ მე, ძირითად, არ უნდა ფიქრი, ეს darn მარყუჟის, და მოუწოდებს ხველა ისევ და ისევ. რატომ არ შეიძლება მე უბრალოდ ვუთხრა ხველა, გთხოვთ ხველა სამჯერ? სხვა სიტყვებით, რატომ არ შეიძლება, უბრალოდ მისცეს შეყვანის ხველა და ამის გაკეთება? 

რატომ არ შეიძლება მე უბრალოდ ვამბობ, მთავარი ხველა სამჯერ. და ახლა, ეს არის ერთგვარი ჯადოსნური. ეს არის ძალიან განმეორებითი აქ. და ეს, რა თქმა უნდა, ბავშვი ნაბიჯი. 

მაგრამ მხოლოდ უნარი ვთქვა ხაზის რვა, ხველა სამჯერ, ეს, უბრალოდ, ასე უფრო მეტი იკითხება. და, ასევე, მე არ უნდა იცოდეს და მაინტერესებს, როგორ ხველა ხორციელდება. და, მართლაც, მოგვიანებით ტერმინი და საბოლოო პროექტები, თუ დაძლევის პროექტი კლასელი ან ორი თანაკლასელები, თქვენ გააცნობიეროს, რომ თქვენ აპირებს უნდა, ან გსურთ, გაყოფა მუშაობა. 

და თქვენ აპირებს მინდა გადასაწყვეტია წინასწარ, ვინც აპირებს რა, და სადაც ცალი? და არ იქნება ლამაზი თუ, მაგალითად, მიიღოს ბრალდებით წერილობით მთავარი, რაც გაკეთდა. და თქვენი roommate, ან თქვენი პარტნიორი უფრო ზოგადად, ზრუნავს განხორციელების ხველა. 

და ეს დაყოფა, ეს კედლები აბსტრაქცია, ან ფენების აბსტრაქცია თუ თქვენ, რომლებიც სუპერ ძლიერი, იმიტომ, რომ განსაკუთრებით დიდი, უფრო რთული პროგრამები და სისტემები, ეს საშუალებას იძლევა მრავალი ხალხი აშენება ყველაფერი ერთად, და საბოლოო ჯამში, სტიჩი მათი მუშაობა ერთად ამ გზით. მაგრამ, რა თქმა უნდა, ჩვენ უნდა ახლა დაფიქსირება ხველა. ჩვენ უნდა გითხრათ ხველა რომ, hey, იცით, რა? თქვენ აპირებს უნდა მიიღოს შეყვანის ასე არ ბათილად, მაგრამ int და ახლა. მოდით წავიდეთ წინ და ექსპლუატაციაში შევიდა ხველა int. i იღებს ნულოვანი. 

i ნაკლებია, რამდენჯერ. მე ვთქვი, სამი ადრე. მაგრამ ეს არ არის ის, რაც მე მინდა. მსურს ხველა უნდა განზოგადდეს მხარდაჭერა ნებისმიერი რაოდენობის iterations. 

ასე რომ, მართლაც, ეს n მინდა, მიუხედავად შესახებ მეუბნება. ახლა, შემიძლია წავიდეთ წინ და ვთქვათ ბეჭდვითი ხველა. და არ აქვს მნიშვნელობა, თუ რა რაოდენობის მომხმარებელი გადის, მე iterate, რომ ბევრჯერ. 

ასე რომ, დღის ბოლოს, პროგრამა იდენტურია. მაგრამ შეამჩნია, ყველა ამ პერსონალის შეიძლება იყოს სხვა ფაილი. მართლაც, მე არ ვიცი, იმ როგორ მომენტში printf ხორციელდება. 

მე არ ვიცი, იმ მომენტში, რამდენად მისაღებად სიმებიანი, ან int, ან float ხორციელდება. და მე არ მინდა, რომ ვხედავ მათ ჩემი ეკრანზე. როგორც არის, მე დაწყებული ფოკუსირება ჩემი პროგრამა, არა იმ ფუნქციებს. 

ასე რომ, მართლაც, როგორც კი თქვენ დაიწყოს ფაქტორინგი კოდი მოსწონს ეს out, შეგვიძლია კი გადაადგილება ხველა ცალკე ფაილი? ვინმეს შეეძლო განახორციელოს იგი. თქვენ და თქვენი პროგრამის გახდეს ძალიან ლამაზი და ძალიან იკითხება, სავარაუდოდ, მართლაც ოთხ ხაზის პროგრამის უფლება არსებობს. 

მოდით წავიდეთ წინ არის და კიდევ ერთი ცვლილება. გაითვალისწინეთ, რომ ჩემი პროტოტიპი უნდა შეიცვალოს up დაბრუნება. ნება მომეცით, დაფიქსირება, რომ ასე მე არ დაიყვირა. 

ჩადება ხველა, ნება მომეცით აწარმოებს ხველა ერთხელ მეტი, მაინც აკეთებს იგივე. მაგრამ ახლა, შეამჩნია, რომ ჩვენ გვაქვს ნივთიერება ერთი საბოლოო ვერსია. იცი რაა? მე არ მინდა, რომ მხოლოდ ხველა, აუცილებლად. მე მინდა, რომ რაღაც უფრო ზოგადად. ასე, რომ თქვენ იცით, რა? მე მინდა ამის გაკეთება. მე მინდა, რომ, ჰგავს Scratch აკეთებს, ვთქვათ ბლოკი, მაგრამ არა მხოლოდ ამბობენ, რომ რაღაც გარკვეული რაოდენობის ჯერ. მე მინდა, რომ ვთქვა, ძალიან კონკრეტული სიმებიანი. და, აქედან გამომდინარე, მე არ მინდა, რომ ის, უბრალოდ, ვამბობთ ხველა. მე მინდა, ვთქვა რასაც string გავიდა. 

ასე რომ შეამჩნია, მე გენერალიზებული ეს ისე, რომ ახლა ვთქვათ იგრძნობა კარგი სახელი ამ, ისევე როგორც Scratch, იღებს ორი არგუმენტები, განსხვავებით Scratch. ერთი სიმებიანი. ერთი არის int. 

და მე ვერ გადართოთ მათ. მე უბრალოდ სახის მოსწონს იდეა ამბობენ, რომ string პირველი და შემდეგ , რამდენჯერ შემდეგ. ბათილად ნიშნავს, რომ ჯერ კიდევ არ დაბრუნდება. ეს არის მხოლოდ ვიზუალური მხარე ეფექტი, ისევე, როგორც [? Jordan,?] სიტყვიერი გვერდითი ეფექტი ყვირილი. ეს ჯერ კიდევ რაღაც n ჯერ, 0-მდე, მაგრამ არ უდრის n. ეს იმას ნიშნავს, ო სულ ჯერ. და შემდეგ უბრალოდ ამობეჭდოთ რასაც სტრიქონს. ასე რომ, მე ნამდვილად გენერალიზებული ეს ხაზი კოდი. ასე რომ, ახლა, როგორ უნდა განახორციელოს ხველა ფუნქცია? 

მე შემიძლია ამის ბათილად ხველა. და მე მაინც მიიღოს, თუ როგორ ბევრჯერ გსურთ ხველა. მაგრამ იცით, რა? მე ახლა punt ვთქვა. 

მე მოვუწოდებ ვთქვა, სიტყვა ხველა, გადადის n. და თუ მინდა ასევე განახორციელოს, უბრალოდ for fun, დაცემინების ფუნქცია, შემიძლია sneeze გარკვეული რაოდენობის ჯერ. და შემიძლია შენარჩუნება მეორეული გამოყენება ო, იმიტომ, შეამჩნია, რომ მ ამ კონტექსტში ან ფარგლებში მხოლოდ არსებობს ფარგლებში ამ ფუნქციას. 

და n ამ კონტექსტში მხოლოდ არსებობს ფარგლებში ამ ფუნქციას აქ. ასე რომ, ჩვენ დავბრუნდებით ამ საკითხებზე ფარგლებს. და აქ, მე ვაპირებ ვთქვა, Achoo და შემდეგ ო ჯერ, ნახევრად მსხვილი ნაწლავის. 

და ახლა, უბრალოდ უნდა სესხება ამ ფუნქციის ხელმოწერების აქ. ასე რომ, ხველა არის სწორი. Void sneeze სწორია ახლა. 

და მე კიდევ უბრალოდ უნდა ვთქვა. ამიტომ, მე ვაპირებ ვთქვა, ვთქვათ string s, int n, ნახევრად მსხვილი ნაწლავის. ასე რომ, მე ზედმეტად ტექნოლოგიით heck out ამ პროგრამის. 

და ეს არ არის ნიშნავს იმას, რომ ეს არის რა უნდა გავაკეთოთ, როდესაც წერა კი მარტივი პროგრამების. რაღაც რომ აშკარად მართლაც მარტივი, მართლაც მოკლედ, და ხელახლა განახორციელოს ეს გამოყენებით გზა ძალიან ბევრი კოდი. მაგრამ თქვენ რეალურად ვხედავ, და დრო ვიხსენებთ ამ მაგალითები, და ხვდები, რა, ეს არის ნაბიჯები ავიღეთ რეალურად განზოგადება, ფაქტორი რაღაც, სანამ ბოლოს დღეს ჩემი კოდი არის რეალურად საკმაოდ გონივრული. იმიტომ, რომ თუ მინდა ხველა სამ ჯერ მაშინ sneeze სამჯერ, მე უბრალოდ აპირებს გამეორება ამ, პროგრამის მიიღოს ხველა, და აწარმოებს ხველა. და მაქვს სამი coughs და სამი sneezes. 

ასე რომ, ეს არის ძირითადი პარადიგმა, თუ გნებავთ, როგორ ჩვენ შეიძლება წავიდეთ შესახებ რეალურად განხორციელების პროგრამა. მაგრამ მოდით უბრალოდ ვხედავ ახლა, რა არის ჩვენ უკვე აკეთებს ყველა ამ დროს, და რასაც ზოგიერთი საბოლოო ცალი უკან ეს მარტივი ბრძანება. ბოლოს დღეს, ჩვენ გვაქვს უკვე გამოყენებით Clang როგორც ჩვენი შემდგენელი. ჩვენ უკვე წერილობით წყაროს კოდი, კონვერტაცია გავლით Clang შევიდა მანქანა კოდი. 

ჩვენ უკვე გამოყენებით ჩადება მხოლოდ ხელი შეუწყოს ჩვენი keystrokes ასე რომ ჩვენ არ უნდა გვახსოვდეს, იმ მართლწერის of Clang თავად. მაგრამ რა არის ჩადება რეალურად აკეთებს? და, თავის მხრივ, რა არის Clang რეალურად აკეთებს? 

გამოდის, თუმცა ჩვენ გავამარტივეთ დღევანდელი დისკუსიის განაცხადა, შენ კოდის, გაივლის მას, როგორც შეყვანის შემდგენელი, რომელიც გაძლევთ გამოშვება მანქანა კოდი, თურმე არსებობს რამდენიმე სხვადასხვა ნაბიჯები შიგნით არსებობს. და შედგენა ხდება, რომ ქოლგა ვადა მთელი bunch of ნაბიჯები. მაგრამ მოდით უბრალოდ გაღიზიანება ეს მართლაც სწრაფად. 

გამოდის, რომ ჩვენ ვაკეთებთ უფრო მეტი რამ ყოველ ჯერზე მე აწარმოებს პროგრამა, და ყოველ ჯერზე მე შედგენა პროგრამა დღეს. ასე გაგრძელების ეხება ამას არაფერი C პროგრამა, როგორც ვნახავთ, ისევ და ისევ, რომელიც იწყება ამ hash სიმბოლო, ან hashtag სიმბოლო აქ, იმას ნიშნავს, ეს preprocessor დირექტივა. ეს ნიშნავს, რომ ამ შემთხვევაში, hey კომპიუტერული, რაღაც ეს ფაილი სანამ რეალურად ადგენენ ჩემი საკუთარი კოდი. 

ამ შემთხვევაში, hash მოიცავს არის, არსებითად, C ის გზა და განაცხადა, hey კომპიუტერი, წასვლა შინაარსი of CS50.h და ჩასვით აქ. Hey კომპიუტერი, წავიდეთ მიიღოს შინაარსი სტანდარტული io.h იქ, სადაც, რომ არის მყარ დისკზე, ჩასვით აქ. ასე რომ, ეს ყველაფერი არ მოხდება პირველი დროს preprocessing. 

და Clang ყველა ამ ჩვენთვის. და იგი იმდენად darn სწრაფი, თქვენ კი არ იხილეთ ოთხი განსხვავებული რამ ხდება. მაგრამ ეს არის პირველი ასეთი ნაბიჯი. 

რა ხდება შემდეგი? კარგად, შემდეგი ოფიციალური ნაბიჯი შედგენა. და აღმოჩნდება, რომ შედგენა პროგრამა ტექნიკურად ნიშნავს აპირებს კოდის, პერსონალის, რომ ჩვენ უკვე წერდა, დღეს, რაღაც მოუწოდა ასამბლეის კოდი, რაღაც რომელიც გამოიყურება ცოტა განსხვავებული. 

და, ფაქტობრივად, ჩვენ ვხედავთ, რეალური სწრაფად. ნება მომეცით რეალურად წასვლას ჩემი IDE. ნება მომეცით წავიდეთ წინ და ღია hello.c, რომელიც არის პირველი პროგრამა, რომელიც ჩვენ დღეს დაიწყო. და ნება მომეცით წავიდეთ წინ და აწარმოებს Clang ცოტა განსხვავებულად, Clang-s, hello.c, რომელიც რეალურად აპირებს მომეცი კიდევ ერთი ფაილი hello.s. 

და ჩვენ, ალბათ, არასოდეს ისევ ვხედავ ამ სახის კოდი. თუ თქვენ მიიღოს ქვედა დონეზე სისტემები კლასის მოსწონს CS61, ნახავთ ბევრი სხვა ამ სახის კოდი. მაგრამ ეს არის ასამბლეის ენაზე. ეს არის X86 ასამბლეის ენაზე რომ CPU, რომელიც საფუძვლად უდევს CS50 IDE რეალურად ესმის. 

და cryptic, რადგან არ გამოიყურება, ეს არის ის, კომპიუტერი ესმის კარგად. Sub q, ეს არის სხვაობა. არსებობს მოძრაობები. 

არსებობს მოუწოდებდა ფუნქციები აქ, x Oring, მოძრაობა, Add, პოპ, დაბრუნება. ასე რომ, ძალიან დაბალი დონე მითითებები რომ CPUs გვესმის, რომ მე გააკეთა მინიშნება ადრე. ეს არის ის, რაც Intel Inside. 

არსებობს ნიმუშების zeros და პირობა, რომ რუკაზე ამ arcanely ფორმულირებული, მაგრამ გარკვეულწილად კარგად დაასახელა, ინსტრუქციები, ასე ვთქვათ. ეს არის ის, რაც ხდება, როდესაც თქვენ კომპილაციის თქვენი კოდი. თქვენ მიიღებთ ასამბლეის ენის გარეთ, რომელიც ნიშნავს მესამე ნაბიჯი არის შეიკრიბება რომ ასამბლეის კოდი შევიდა, საბოლოო ჯამში, მანქანა კოდი zeros და პირობა, არ ტექსტი, რომელიც ჩვენ ვნახეთ, ერთი წუთით წინ. 

ასე რომ, წინასწარ დამუშავებას ამჯამად რომ იპოვოს და შეცვლის, და რამდენიმე სხვა რამ. შედგენის იღებს თქვენი წყარო კოდი C, კოდის რომ ჩვენ წერდა, რომ შეკრებისა კოდი, რომ ჩვენ უბრალოდ მოხვდა. შეკრებაზე იღებს, რომ ასამბლეის კოდი zeroes და პირობა რომ CPU ნამდვილად მესმის, ბოლოს დღის განმავლობაში. და აკავშირებს არის ბოლო ნაბიჯი რომ ხდება us-- ერთხელ, ასე სწრაფად, ჩვენ კი არა შეამჩნია, რომელიც ამბობს, hey კომპიუტერი, მიიღოს ყველა zeros და პირობა, რომ შედეგად შედგენა დავით კოდი, და მისი მთავარი ფუნქცია ამ შემთხვევაში. 

და hey კომპიუტერი, წავიდეთ მისაღებად ყველა zeros და პირობა რომ CS50 პერსონალის დაწერა შიგნით CS50 ბიბლიოთეკა. შეურიეთ იმ დავითის. და hey კომპიუტერი, წავიდეთ მისაღებად ყველა zeros და პირობა, რომ ვინმე წერდა წლის წინ printf. და დაამატოთ იმ შევიდა მთელი რამ, რომ ჩვენ მივიღე ჩემი zeros და პირობა, CS50 პერსონალის zeros და პირობა, რომ printf zeros და პირობა, და არაფერი ჩვენ გამოყენებით. 

მათ ყველა მისაღებად კომბინირებული ერთად ერთ პროგრამა მოუწოდა, ამ შემთხვევაში, hello. ასე რომ, ამიერიდან, ჩვენ უბრალოდ გამოიყენოს სიტყვა შედგენა. და ჩვენ, თავისთავად, რომ როდესაც ჩვენ ვამბობთ, კომპილაციის თქვენი პროგრამა, ეს იმას ნიშნავს, hey გააკეთოთ წინასწარ დამუშავებას, იკრიბებიან, და აკავშირებს. მაგრამ რეალურად ზოგიერთი წვნიანი პერსონალი იქ ქვეშ hood. და მით უმეტეს, თუ მიიღოთ საინტერესო გარკვეული დრო, თქვენ შეგიძლიათ დაიწყოს გააღიზიანოს დაახლოებით ამ ქვედა დონეზე. მაგრამ ახლა, გააცნობიეროს, რომ შორის takeaways დღეს საკმაოდ უბრალოდ დაწყებული პროცესი, მიღების კომფორტულად რაღაც მიესალმები მსოფლიოში. მართლაც, რაც ჩვენ გავაკეთეთ დღეს რა თქმა უნდა არ ჩაიძიროს სუპერ სწრაფი. და ეს იქნება გარკვეული დრო და პრაქტიკაში. და შანსები, თქვენ დასალაგებლად მინდა მოხვდა თქვენს კლავიატურაზე ან დაწეროთ ეკრანზე. და ყველა რომ კარგადაა. მიუხედავად იმისა, რომ, ალბათ, ცდილობენ არ ამის გაკეთება ბიბლიოთეკაში იმდენად. 

და საბოლოო ჯამში, თქვენ შეძლებს, თუმცა, უნდა დაიწყოს ხედავს ნიმუშების, როგორც კარგ კოდი რომ თქვენ წერილობითი და შეცდომები რომ თქვენ გააკეთა. და ჰგავს პროცესში ხდება TF ან CA ჰგავს, თქვენ დაიწყოს უკეთ და უკეთ ხედავს იმ ნიმუშების, და მხოლოდ საქმე თქვენი საკუთარი პრობლემების საბოლოოდ. ამასობაში, იქნება უამრავი თითოეული ჩვენგანისთვის, რომ სარგებლის თქვენ მხარდაჭერა, და თქვენ მეშვეობით. და ჩაწერის ups ყველა პრობლემა, თქვენ იხელმძღვანელებენ მეშვეობით ყველა ბრძანებები რომ მე, რა თქმა უნდა ვიცი ბევრი პრაქტიკა ახლა, თუმცა, შესაძლოა, არ მანევრის ზე ერთი თავი ახლა. და რომ სრულიად ჯარიმა. 

მაგრამ, საბოლოო ჯამში, თქვენ აპირებს დაიწყოს, რომ ნახოთ ნიმუშების აღმოცენდეს. და კიდევ თქვენ წარსულში ყველა სულელური დეტალები, როგორიცაა ფრჩხილებში, და Curly braces, და ნახევრად colons, და პერსონალის, სიმართლე გითხრათ, რომ არ არის ინტელექტუალურად საინტერესოა. და ეს არ არის ობიექტური რაიმე გაცნობითი კლასი. ეს იდეები, რომ ვაპირებთ აქვს. 

ეს მარყუჟების, და პირობები და ფუნქციები, და უფრო ძლიერი აბსტრაქცია, და ფაქტორინგი კოდი, და კარგი დიზაინი და კარგი სტილი, და საბოლოო ჯამში სისწორის თქვენი კოდი, რომ საბოლოო ჯამში, აპირებს მნიშვნელობა ყველაზე. ასე რომ, მომავალ კვირას, ჩვენ მიიღებს ამ იდეები, რომ ჩვენ პირველად ვნახე Scratch და ახლა თარგმნა უნდა C. და ჩვენ დავიწყებთ დანერგვა პირველი რა თქმა უნდა, რეალურ სამყაროში დომენები. 

ჩვენ ფოკუსირება სამყაროს უსაფრთხოებას, და უფრო კონკრეტულად კრიპტოგრაფიის, ხელოვნების scrambling ინფორმაციას. და მათ შორის პირველი პრობლემები თქვენ თავს მიიღებს დაწერა მიღმა სათამაშო ზოგიერთი სინტაქსი და გადაჭრის ლოგიკური პრობლემა, რამაც ხანგრძლივი, რეალურად scramble, ან დაშიფვრა, და საბოლოო ჯამში გაშიფვრა ინფორმაცია. და ყველაფერი გავაკეთეთ დღეს, საკმაოდ დაბალი დონეზე, უბრალოდ აპირებს დაუშვას ჩვენთვის მიიღოს და ერთი, და კიდევ ერთი ნაბიჯი ზემოთ მიმართ წერა ყველაზე საინტერესო კოდი ამჟამად. 

ასე უფრო, რომ მომავალ კვირას. 

[ვიდეო აღწარმოების] 

რა შეგიძლიათ მითხრათ ბოლო დროს დაინახა მას? რა შემიძლია ვთქვა, მართლა? ვგულისხმობ, რომ ეს იყო, როგორც ნებისმიერი სხვა წინასწარი წარმოების რეპეტიცია, გარდა იქ იყო რაღაც მან განაცხადა, ძალიან ბოლოს, რომ მოხდა ჩემთან ერთად. 

-ეს იყო CS50. 

-სწორედ დაჭრილი ყველას, დიდი სამუშაო რეპეტიცია. 

-რომ სადილი? 

-ჰო, მე და თქვენ დაიბრუნოს sandwich ცოტა. ნება მომეცით debrief ერთად დავით მართლაც სწრაფად. დავით? დავით? 

[END აღწარმოების] 