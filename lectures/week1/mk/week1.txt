[Музички] Дејвид Џ MALAN: Добро, ова е CS50. И ова е една недела. Значи се потсетиме дека последен пат во нула недела, ние се фокусиравме на компјутерската размислување. И ние се трансформира од тоа да се Нула, графички програмирање јазик од нашите пријатели на Media Lab на МИТ. 

И со нула, не се разгледуваат идеи како функции, како и условите, и петелки, и променливи, па дури и настани и теми, и многу повеќе. И денес, ние се случува да се продолжите со користење на тие идеи, и навистина земајќи ги за готово, но ги преведе на друг јазик познат како C. Сега, C е потрадиционален јазик. Тоа е на пониско ниво јазик, ако сакате. 

Тоа е чисто текстуални. И така на прв поглед, тоа е сите ќе се погледне, а криптичната ако никогаш не сум програмиран порано. Ние се случува да треба полу-запирки, и загради, и големи загради, и многу повеќе. Но сфати дека дури и иако синтаксата е за да се погледне малку непознат на повеќето од вас, да се види минатото тоа. И да се обиде да го видиш идеи кои се, всушност, познати, бидејќи тука во една недела што ќе започне да се направи е да се споредуваат, на почетокот, нула наспроти В. 

Така, на пример, да се потсетиме дека кога ќе се го спроведе првиот од нашите програми Последниот пат, имавме блок кој изгледаше малку нешто како this-- кога зелено знаме кликнато, а потоа моравме едно или повеќе парчиња под него загатка, во овој случај, да се каже, Здраво светот. Значи, навистина, во нула, кога ќе кликнете на тоа зелено знаме да се води програмата, што значи да се каже, тие се блокови кои се извршени или за да ја стартувате. И, посебно, на гребење рече: Здраво, свет. 

Сега, јас би можеле да имаат одреден со други зборови тука. Но, ќе видиме дека, навистина, многу на овие blocks-- и навистина, во C може да биде многу functions-- parametrized или кориснички да направите различни нешта. Всушност, во C ако ние сакате да го конвертирате, сега, оваа нула програма на овој друг јазик, ние ќе треба да се напише малку нешто како ова. 

Се разбира, има некои непознати синтакса таму најверојатно, цел број, и загради, и неважечки. Printf-- Но, и покрај тоа што би дека тоа само ќе биде за печатење. Но печатење значи печатење форматирана, како што наскоро ќе видиме. Ова буквално ќе печати на екранот што е во внатрешноста на овие загради, кои се разбира, во овој случај, Здраво светот. 

Но, ќе забележите дека некои други синтакса, некои двојни наводници, дека заграда на крајот, точка-запирка и слично. Па таму е малку над глава, така да се каже, и когнитивно и синтаксички, дека ние ќе мора да се сеќавам пред долго. Но сфати дека со практиката, ова ќе почне да скокаат на тебе. 

Всушност, да се фокусира на тоа еден функција specifically-- во овој случај, велат Здраво светот. Така велат дека е во функција. Здраво светот е параметар, или аргумент, неговата прилагодување. 

И еквивалентност во C е само ќе биде ова една линија тука, каде printf е еквивалентно на, да речеме, двојното цитиран стринг, здраво светот е еквивалентно, се разбира, на она што е во белата кутија таму. И обратна коса црта n, иако малку чудно и отсутен од нула, едноставно се случува да имаат ефект ние ќе види во компјутер, како и мојот Mac или PC, на само поместување на курсорот на следната линија. Тоа е како притискање Enter на вашата тастатура. 

Па ќе видиме што повторно пред долго. Но, прво, ајде да ги разгледаме во овој друг пример во случај на јамки. Имавме оваа засекогаш јамка за последен пат, кој беше серија на мозаик парчиња дека направиле нешто буквално forever-- во овој случај, каже, Здраво, Здраво светот, Здраво, Здраво светот. Така, тоа е бесконечна јамка страна на дизајнот. 

Во C, ако сакаме да се спроведе оваа истата идеја, ние едноставно може да го направите тоа. Иако е точно, printf здраво world-- сега додека, исто семантички, вид на conjures до идејата за правење нешто повторно, и повторно, и повторно, и за колку време? Па, true-- потсетиме дека вистина е само на или еден. 

И точно е, се разбира, секогаш точно. Така, тоа е вид на бесмислени изјава само да се каже точно. Но, навистина, ова е намерно, затоа што ако вистина е само секогаш точно, отколку додека вистинските само имплицира, ако малку индиректно, дека следниве линии на код помеѓу оние големите загради само треба да се изврши повторно, и повторно, и повторно, и никогаш не запре. 

Но, ако сакате вашиот јамка за да се спречи, како што направи последен пат со нешто како ова, го повтори по 50 пати, во C можеме да го стори истото со што е наречен за loop-- клучниот збор не се време, но за. И тогаш имаме некои нови синтакса тука, со int i е еднаква на 0, јас помалку од 50, i ++. И ние ќе се вратам на тоа. Но, ова е само како би преведе на сет на гребење блокови на сет од С линии на код. 

Во меѓувреме, сметаат променливи. И, всушност, само Видов еден момент пред. И во случај на нула, ако се сакаше да декларирате променлива наречен i за што се број, само еден број, и ние сакаме да го поставите на некои вредност, ние ќе го користи овој портокал блокира here-- постави i 0. 

И ќе видиме денес и надвор од неа, исто како и минатата недела, програмери се речиси секогаш почнат да бројат од нула, навистина од Конвенцијата. Но, исто така, бидејќи се потсетиме од нашата дискусија на бинарни, најмал број може да се претставуваат со било кој број на битови е само ќе биде 0 себе. И така ќе генерално започне иницијализацијата дури и нашите променливи на 0. 

И во C за да го стори истото, ние се случува да се каже int за цел број, јас само од страна на конвенцијата. Јас би можеле да се јави на оваа променлива што сакам, исто како и во Scratch. А потоа е еднакво на 0 само дознаки вредноста 0 од десно и го става во променлива, или сад за чување таму, на левата страна. И точка-запирка како што ќе see-- и видовме неколку од овие already-- само значи крај на мислата. Продолжи да се направи нешто друго на редовите што следуваат. 

Сега, она што за Булова изрази? Потсетиме дека во нула, тие беа изрази кои се или вистинити или false-- прашања, навистина, кои се или вистинити или лажни. Така што во случај на нула, би можеле да поставам едноставно прашање како ова, i е помала од 50? Па јас, пак, е цел број. Можеби и ние го користите во програмата на гребење да ги пратите на резултат или нешто слично. Значи оваа синтакса тука во Скреч само значи, е јас помалку од 50? Па, за среќа, нешто не е во едноставно во C. И да се преведе, ова едноставно ќе кажам дека помалку од 50, со користење на познати клуч на тастатурата. 

Во меѓувреме, ако си сакал да да се каже нешто повеќе општи, како, добро, е помалку од x y каде што секој на x и y се променливи се? Ние можеме да го прават истото во C, се додека ние сме ги создаде овие променливи веќе. И ние ќе видиме како да се го направи тоа пред долго. Ние едноставно би рекол x помалку од y. 

Значи сте почнуваат да се види некои сличности. И оние луѓе кои се направени Нула беа, секако, инспириран од некои од овие основни идеи. И ќе видите дека овој вид на синтаксата во многу languages-- не само почеток, не само Ц, но Пајтон, и JavaScript, и други јазици уште. 

Ајде да се разгледа уште еден конструкт од C, поимот на состојба, прави нешто условно. Ако нешто е точно, го направите тоа. Ако нешто е точно, го направи тоа. Тоа е еден вид на програмирање еквивалент на вилушка во патот. Можеби тоа е двонасочна вилушка, три начин вилушка, или повеќе. И во нула, ние би можеле да имаат види нешто како ова. 

Така што ова е една голема. Но, сметаат дека релативната Едноставноста на логика. Ако X е помалку од y, па кажете x е помала од y, друго, ако X е поголем од y, тогаш велат дека x е поголема од y. И тогаш, логично, ако ќе се сетам на гребење или само вашите сопствени човечки интуиција, и, ако X не е поголема од y и x не е помалку од y, тогаш се разбира, X ќе биде еднаква на y. Значи во овој случај, од страна на гнездење оние гребење блокови, можеме да се постигне три начин вилушка во патот? 

Во меѓувреме, ако сакаме да го направи тоа во C, веројатно изгледа малку simpler-- најмалку откако ќе се запознаат со синтакса. Ако X е помалку од y, printf x е помалку од y. Друго, ако X е поголем од y, printf x е поголема од y. Друго printf x е еднаква на y-- и, повторно, со оние обратна коса црта завршува само за оние кои се нови линии, така што ако всушност трчаше овој вид на програма тоа само ќе се движат курсорот на крајот до следната линија на екранот. 

Сега, пак гребење имаше други повеќе софистицирани карактеристики, само од кои ние ќе треба да првично се движат во текот на светот на В. А еден од нив беше наречен листа во Scratch. И ова е посебен тип на променлива која е дозволено да се сместат повеќе работи во него назад, да се врати, да се врати, да се врати. 

Во C, тоа не мора листи, сама по себе, но нешто кои се поопшто наречен низи, иако ние ќе се врати подоцна овој семестар да се гледа во нешто наречен листа, или навистина листа поврзани. Но, за сега, најблиску еквивалент во C за нас ќе биде нешто наречен низа. И низа е едноставно специјален тип на променлива кој ви овозможува да се сместат податоци назад, да се врати, да се врати, да се врати. 

И, навистина, во нула, ако сакаме да пристапите на првиот елемент на низа или на list-- и јас одам да го наречеме, по конвенција, argv, аргументот вектор, но повеќе за тоа пред долго. Ако сакам да се стигне до првиот елемент на argv, во светот на гребење што навистина знаете обично почнете сметано од 1. 

И така би можел да добие точката 1 од argv. Тоа е само како спроведува МИТ поимот на листи. Но, во C, јас ќе одам да едноставно само да се каже, argv, што повторно е името на мојата list-- или да бидат јасни, низа. И ако сакам првиот елементи, јас ќе одам да го користите квадратни загради, кои ќе често може да не се користи во рамките на тастатурата. 

Но 0 само значи, ме првиот. Па понекогаш и како Со текот на времето, ние ќе да почнат да ги види овие дихотомии меѓу гребење и Ц, при гребење користи. Ние во C користат 0 овде. Но, вие брзо ќе се види откако ќе се разбере основите на секој јазик, кои овие работи почнуваат да се сè повеќе и повеќе запознаени преку пракса и пракса. 

Па ајде да всушност изгледаат сега на програмата. Тука ќе биде прв од нашите C изворниот код за целосна програми. И програмата ние ќе да им понуди на разгледување е оној што е еквивалентно за кои претходно гребење парче. 

Значи тука, имаме што е веројатно најпростиот програмата C можете да напишете дека всушност прави нешто. Сега, ние ќе се погледне минатото, за сега, се вклучуваат, стандард io.h, и овие агол загради, и int, и неважечки, и големи загради, и слично. 

И ајде да се фокусира на што, барем интуитивно, може да скокаат на тебе веќе. Всушност, главната, јас не мора да знаете што е ова, но слично како гребење беше дека кога зелено знаме кликнато загатка парче, така и C како програмски јазик имаат главниот дел од кодот кој добива извршена од стандардните. И, навистина, тоа е буквално случува да се нарече главниот. 

Значи главната е во функција. И тоа е посебна функција која постои во C дека кога ќе ја стартувате програмата, тоа е главната која добива се кандидира од страна на стандардните. Во светот на нула, тоа беше обично кога зелено знаме кликна кои добија работи од стандардните. 

Во меѓувреме, ние го видел ова пред, printf или печатените формат, тоа е ќе биде во функција која доаѓа со Ц, заедно со еден куп други, дека ќе од време и време Повторно, со цел да се направи токму како што сугерира името, печати нешто. Што сакаме да ги испечатите? Па, ние ќе се види дека со приложување на карактери како these-- свет здраво, обратна коса црта n во двојни наводници, може да се каже точно printf она што за печатење на екран. 

Но, со цел да се направи тоа, за жал, треба да се нешто што е веќе криптичната за нас луѓето, но барем тоа е малку readable-- остри вклучуваат, стандард io.h, цел број, Главните, поништена printf, сите на магичен баењата ние само видов на екранот. Но, ние всушност треба да се повеќе arcane уште. Ние прво треба да се преведе на код дека ние пишуваме во машински код. И се сети од минатата недела дека машини, барем оние што знаат тука, на крајот на денот само разбере нули и единици. 

И мојот Бог, ако моравме да пишувам овие нули и единици за да всушност програмата, тоа би многу, многу брзо се на забава надвор од ништо. Но, се покажа, на минатата недела, дека овие модели на нули и единици само имаат посебно значење. Во одредени контексти, би можеле да значат бројките. 

Во некои контексти, би можеле да значат букви, или бои, или било кој број на други апстракции има врз. Но, како што вашиот компјутер има процесорот, централната единица за обработка, или мозокот во внатрешноста на вашиот компјутер. Тоа е обично Интел внатре, затоа што тоа е една од најголемите компании што го прави процесори за компјутери. 

Па, Intel процесори и други едноставно се одлучиле однапред дека одредени модели на нули и единици оние што се подразбира специфични нешта. Одредени модели на нули и единици ќе значи, печати ја оваа на екранот, или да додадете овие два броја, или одземе овие два броја, или да се движат на ова парче на податоците од меморија на компјутерот ми е тука, или било кој број на други многу ниско ниво, но во крајна линија е корисно, операции. Но, за среќа, ние, луѓето не се случува да треба да знаете ова ниво на детали. Всушност, исто како и минатиот пат, каде што црпи повторно, и повторно, и повторно, зграда од многу ниско ниво примитивците како нули и единици на концепти повисоко ниво како броеви и букви, и бои, и повеќе, Значи ние можеме како програмери стои на рамениците на други кои доаѓаат пред нас и користење на софтвер кој друг луѓе го имаат напишано пред us-- имено програми наречени компајлери. 

С е јазик кој обично се составени, што значи да се конвертира од изворниот код на машински код. Особено, што значи тоа е дека ако имате вашиот извор код кој се пишува, како што наскоро ќе во само еден миг на екранот, и ако сакате да го конвертирате на крајот на машина code-- оние нули и оние кои само вашиот Mac или вашиот компјутер understands-- имаш прв се хранат дека изворниот код во што внесување на посебни програма наречена компајлер, на излез од кои ние ќе го видите е машина код. И, навистина, последен пат зборувавме за, навистина, на крајот на денот, решавање на проблем. Имаш влезови. И имаш излези. И имаш некој вид алгоритам во средината. 

Алгоритми сигурно може да биде имплементирани во софтвер, како што видовме со pseudocode минатата недела и како што ќе видиме со реалните код оваа недела. И така на компајлерот навистина само има множество на алгоритми во од него, кој знае како да се претворање на специјални клучни зборови, како главни и printf, и други кои ние едноставно видов во моделите на нули и единици оние кои Интел внатре и други процесори всушност го разбира. Па, како да го направите ова? Каде да се добие компајлер? 

Повеќето од нас тука имаат Mac или PC. И вие ќе бидете трчање Mac OS, или Windows или Linux, или Соларис, или било кој број на други оперативни системи. И, навистина, би можеле да излезе со излез на интернет и преземање на компајлерот за вашиот Mac или вашиот компјутер за вашиот особено оперативен систем. Но, ние сите ќе бидат на различни страни, така да се каже. Ние ќе треба малку различни конфигурации. И работите не ќе работат сите исти. И, навистина, овие денови многу од нас не ги користат софтвер кој работи само на нашите лаптопи. Наместо тоа, ние се користи нешто како интернет пребарувач, кој ни овозможува пристап до веб-базирани апликации во облак. А на крајот на семестарот, ние ќе го стори токму тоа. Ние ќе ја пишува апликации или софтвер со користење на code-- не C, но и други јазици како Пајтон и JavaScript-- кои работат во облакот. 

И да го направите тоа, ние самите во текот на семестарот всушност, ќе го користат облак-базирани животната средина, познат како CS50 ИРО. Ова е веб-базирани програмирање животната средина или интегриран развој животната средина, ИРО, кој е изграден на врвот на некои софтвер со отворен код се нарекува Облак 9. И направивме некои педагошки поедноставувања да го така што за да се скрие одредени функции во првите недели дека ние не треба, по што ќе може да ги открие и да се направи поголемиот дел нешто што сакате со животната средина. 

И тоа ни овозможува, исто така, да инсталираат одредени софтвер. Работи како т.н. CS50 библиотека, која наскоро ќе се види ни дава во C со некои дополнителна функционалност. Значи, ако се оди, во крајна линија, CS50.io, ќе биде побарано да се најавите, и штом еднаш ќе се направи и да се создаде сметка за бесплатно, ќе бидете во можност да пристапите до средина која изгледа доста се допаѓа ова. 

Сега, ова е во стандарден режим. Се што е убаво и светло на екранот. Многу од нас имаат навика работи на CS50 парче што е прилично доцна во ноќта. И така некои од вас може да претпочитаат да ја претвори во ноќен режим, така да се каже. 

Но, на крајот, она што си ќе го видите во CS50 IDE е три различни areas-- со површина од левата страна, каде што Вашите датотеки се случува да бидат во облак, површина на горниот десен агол каде што вашиот код се случува да се уредува. Вие ќе бидете во можност да се отвори индивидуални јазичиња за секоја програма дека ти пишувам овој семестар во на кои во горниот десен агол на екранот. И тогаш повеќето arcanely, а сепак моќно, ќе биде тоа во дното познат како терминален прозорец. 

Ова е една стара училиште Командната линија интерфејс, или CLI, која им овозможува на да се изврши команди на computer-- во овој случај, компјутер во cloud-- да ги правите нештата како компајлирате вашиот код од изворен код за машина код, да се кандидира на вашиот програми, или да ја стартувате вашиот веб сервер, или пристап до вашата база на податоци, и било кој број на други техники дека ќе почне да се користи пред долго. Но, за да одам таму, ние сме ќе всушност имаат да одат на интернет и започнете ја репродукцијата. И да го направат тоа, ајде прво започне tinkering со главниот, и да пишувам на главниот дел на програмата. И ајде да ја користат таа функција printf, кој се користи претходно, едноставно да се каже нешто. 

Па еве јас сум веќе во внатрешноста на CS50 ИРО. Сум најавени однапред. И јас целосно прикажан прозорецот. И така, во крајна линија, ќе исто така и во наредниот проблеми ќе го следат слични чекори кои ќе обезбеди документација. Значи, вие не треба да се грижите апсорпција на секој малку технички чекор што го правам тука и денес. 

Но ќе добиете на екранот се допаѓа ова. Јас се случи да биде во ноќта на владата. И можете да заличи сето од страна на оневозможување на ноќта на владата. И на крајот на ден, си оди за да ја видите овие три главни areas-- датотеката прелистувач на левата страна, код јазичиња до врвот, и на прозорецот на терминалот на дното. 

Дозволете ми да оди напред и да пишувам мојата прва програма. Одам да превентивно одете на датотеката, Спаси, и ја спаси мојата датотека како hello.c. Всушност, по конвенција, секоја програма ние Пишува дека е напишан на јазикот на C треба да биде именуван нешто точка в од Конвенцијата. Па јас ќе одам да го именува hello.c, бидејќи Јас само сакам да кажам здраво на светот. Сега ќе одам да зумирате надвор и кликнете на Save. И сè што имаме сега и тука е јазиче во која ќе можам да почнам да пишувам код. 

Ова не се случува да ги собере. Ова не значи ништо. И така, дури и ако се преобратив тоа да се нули и единици, процесорот ќе немаат идеја што се случува наоколу. Но, ако јас пишувам линии кои се совпаѓаат со conventions-- C суштество Ц, Повторно, ова Language-- со синтаксата како ова, printf здраво world-- и јас сум добивано и удобно со го прават тоа со текот на времето. Па јас не мислам дека сум направил сите печатни грешки. 

Но, секогаш, првиот пат кога ќе го направите ова, ќе. И она што јас сум за да се направи многу на сила и не работат за вас прв пат. И тоа е совршено во ред, затоа што во моментов може само може да се види во целина многу свежина, но со текот на времето откако ќе се запознаат со оваа средина, и овој јазик, и други, ќе започне да ги види работите кои се или точно или неточно. 

И тоа е она што наставата соработници и се разбира асистенти се толку добри во текот на времето, се Анѓелковиќ грешки или грешки во вашиот код. Но тврдам дека има Нема грешки во кодот. Па јас сега сакате да ја извршите оваа програма. 

Сега на мојот Mac или PC, јас сум во навика на двојно кликнување икони кога сакам да се кандидира на некои програма. Но, тоа не е модел тука. Во оваа средина, која е CS50 ИРО. Ние сме со користење на оперативниот систем наречен Линукс. Linux е потсетува на уште еден оперативниот систем, во јавноста познат како Unix. И Linux е особено познат по има командната линија на животната средина, CLI. Сега, ние сме со користење на специфични вкус на Линукс наречена Ubuntu. И Ubuntu е едноставно одредена верзија на Линукс. 

Но, овие Линукс овие денови се всушност доаѓаат со графички кориснички интерфејс. И оној што се случи да се користи тука е веб-базирана. Така што ова може да изгледа дури и малку различен од нешто ќе се може да има види или да работи во минатото. 

Па јас ќе одам да се оди напред сега и да го направите следново. Сум ја спаси оваа датотека како hello.c. Одам да се оди напред и да тип clanghello.c Значи ѕвекот за јазик C е компајлерот. Тоа е пре-инсталиран во CS50 ИРО. И сте апсолутно може да го симнете и се инсталира тоа на свој Mac или PC. 

Но, повторно, не треба да ги имаат сите на пред конфигурација направено за вас. Значи сега за сега, јас сум само ќе се кандидира clanghello.c. И сега се забележи оваа синтакса тука ќе крајот се реализира само значи дека јас сум во папка или директориум наречен работен простор. Ова е само знак за долар конвенција по значење, напишете ја вашата команди. 

Тоа е она што се нарекува брза, само од Конвенцијата е знак за долар. И ако ми да оди напред сега и кликнете Внесете, ништо не чини да се случи. Но, тоа е всушност добра работа. Колку помалку што се случува на вашиот екран, толку е поголема веројатноста вашиот код е да биде точна, најмалку синтаксички. 

Значи, ако сакам да ја извршите оваа програма, она што можам да направам? Па, излегува дека Стандардно име од страна на конвенцијата за програми кога не се определи име за вашата програма е само a.out. И оваа синтакса исто така, ќе се запознаат со пред долго. 

Dot црта само значи дека, еј, CS50 IDE, работи на програма наречена a.out тоа е во рамките на сегашните мојот именик. Тоа значи точка на тековниот директориум. И ние ќе се види она што другите такви низи на карактери значи пред долго. 

Тука ќе одиме, Enter, Здраво светот. И ќе забележите дека она што се случи? Не само што се печати Здраво светот. Таа, исто така се пресели на курсорот на следната линија. 

И зошто е тоа? Она што беше на кодот кој пишувавме пред кој гарантира дека курсорот ќе одат во следната линија? Смешно нешто во врска со компјутер е тоа е само ќе да се направи буквално она што ќе го каже да го стори. 

Значи, ако го кажам printf здраво, запирка, простор, светот, во близина понуда, тоа е буквално само ќе да се печати овие карактери. Но, морав овој специјален карактер на крајот, да се потсетиме, обратна коса црта n. И тоа е она што обезбедува дека карактерот отиде до следната линија на екранот. 

Всушност, дозволете ми да одат и да го направите тоа. Дозволете ми да оди напред и да го избришете ова. Сега, да се забележи дека врвот на мојот екран има малку црвено светло во табот укажува, Еј, вие не сте ги зачувале вашата датотека. Па јас ќе одам да се оди напред со контрола S или команда S, да ја зачувам датотеката. Сега goes-- отиде на moment-- зелена. И сега тоа е назад кон само да се биде блиску икона. 

Ако јас сега повторно се кандидира clanghello.c, Внесете, точка коса црта, a.out, Enter, ќе видите дека се 'уште работел. Но, тоа е веројатно малку кабриолет. Токму сега, мојата prompt-- простор, а потоа дека знакот за долар, а потоа мојот вистински prompt-- е на иста линија. Па тоа сигурно естетски грешки, дури и ако тоа не е навистина логички грешки. 

Па јас ќе одам да го вратите она што го направија. Одам да повторување a.out. Забележи Јас додадов на линија карактер назад. Сум зачувани во датотеката. 

Па јас ќе одам да се повторување a.out, and-- мајката, грешка, грешка значи грешка. Така бубачка е тоа што иако Јас додадов на обратна коса црта n таму, повторно се спаси, повторно истрча на програмата, однесување беше ист. Затоа што ќе биде? 

Јас сум недостасува чекор, нели? Тоа клучен чекор претходно беше дека имате to-- кога ќе се смени вашиот изворен код, излегува исто така, работи тоа преку компајлерот повторно, па ќе го добиете нова машина код. И кодот на машината, на нули и единици, се случува да биде речиси идентични, но не совршено, затоа ни се потребни, се разбира, дека нова линија. 

Значи да го надминете овој, јас ќе одам да треба за повторување clanghello.c, внесете, точка Slash, a.out. И сега, Здраво светот се враќа од каде што се очекува тоа да биде. Значи ова е во ред и добро. Но a.out е прилично глупаво име за програма, иако тоа се случува да биде, од историски причини, default-- значи собранието излези. 

Но, дозволете ми да оди напред тука и го правиме ова поинаку. Сакам моите Здраво светот програма да можат да се вика здраво. Значи, ако тоа беше икона на мојот десктоп, тоа нема да се a.out. Тоа ќе се вика здраво. 

Значи да го направите ова, излегува дека ѕвекот, како и многу други програми, поддржува аргументи на командната линија, или знамиња, или прекинувачи, кои едноставно влијае врз своето однесување. Поточно, ѕвекот поддржува цртичка o знаме, што потоа се втор збор. Во овој случај, ќе се произволно, но разумно, го нарекуваат здраво. Но, јас може да се нарече нешто Сакам, освен a.out, која ќе биде прилично покрај точка. 

А потоа само да го зададете името на датотеката, јас сакам да се состави. Па сега, иако на почетокот на командата јас се уште имаат ѕвекот, на крајот на команда Јас се уште имаат името на датотеката, Јас сега имаат овие командната линија аргументи, овие знамиња што се вели, ох, патем, на излез-о, датотека наречена здраво, не a.out стандардно. 

Значи, ако јас притиснете Enter сега, ништо не чини да се случи. И, сепак, јас сега може да се направи точка коса црта здраво. Така, тоа е истата програма. На нули и единици се идентична на крајот на денот. 

Но, тие се во две различни files-- a.out, која е првата верзија и само глупаво име, и сега hello, што е многу повеќе привлечни име за програмата. Но, искрено, јас никогаш не сум нема да се сеќава на ова, повторно, и повторно, и повторно. И, всушност, како што пишува повеќе сложени програми, командите кои Вие ќе бидете ќе треба да се напише се случува да се добие дури и покомплицирано уште. 

И така да не се грижи. Излегува дека луѓето пред нас сфатија премногу имаше ова точно истиот проблем. Тие, исто така не уживаат да се напишете прилично долго, arcane команди, а камоли да се сеќаваат на нив. И така луѓето пред нас го направиле други програми кои го прават тоа полесно да ги собере вашиот софтвер. 

И, навистина, еден таков програма се нарекува направи. Па јас ќе одам да се оди напред и да го направите тоа. Одам да го вратите сè што само не на следниов начин. Дозволете ми да напишете ЛС. И ќе забележите три things-- a.out, и ѕвезда, здраво и ѕвезда, и hello.c. Се надеваме, ова треба да биде малку интуитивен, доколку порано имаше ништо во овој простор. Немаше ништо што морав создадени се додека не почна класа. 

И направив hello.c. тогаш јас го состави, и го нарече a.out. А потоа го состави повторно малку поинаку и го нарече здраво. Значи имам три датотеки во овој директориум, во оваа папка наречена работен простор. Сега, јас може да се види дека, како и ако јас одзумирате всушност. 

Ако јас одзумирате тука и гледам во тоа горниот десен агол, како што вети од лево страна од вашиот екран секогаш се случува да ви покаже што е во вашиот профил, што е внатрешноста на CS50 ИРО. И таму е три датотеки таму. 

Па сакам да се ослободи од a.out и здраво. И како што може да замисли интуитивно, ќе може да се најде решение за контрола на клик или со десен клик на овој. И ова малку мени се појавува. Може да го симнете датотека, работи тоа, преглед на тоа, освежување, преименување, или она што не. 

И јас само може да го избришете, и дека ќе оди далеку. Но, ајде да се прават работите со командата линија за сега, па како да се чувствуваме удобно со ова, и го направите следново. Одам да се оди напред и извадете a.out со пишување буквално rma.out. Излезе, командата за отстранување или бришење на нешто, не ги избришат или избришете. 

Тоа е повеќе посочно РМ, само за да се спаси вас некои тастатурата, и притиснете ентер. Сега ние се случува да биде малку cryptically отстрани обична датотека a.out. Јас навистина не знаат што е тоа неправилни датотека би бил уште. Но, јас сакам да го отстраните. 

Па јас ќе одам да се Y тип за да. Или би можел да ја напишете надвор, и притиснете Enter. И, повторно, ништо не чини да се случи. Но, тоа е, генерално, е добра работа. 

Ако овој пат сум тип ЛС, што треба да се види? Се надеваме дека, само здраво и hello.c. Сега, како настрана, ќе забележите оваа ѕвезда, ѕвезда, кој е на крајот на мојот програми. И тие исто така се појавува во зелена боја. Тоа е само начин CS50 ИРО од вас cluing во фактот дека тоа не е изворен код. Тоа е извршна, на Runnable програма со која всушност може да се кандидира со правење на точка коса црта, и тогаш тоа е името. 

Сега, дозволете ми да оди напред и да ги отстрани ова, rm здраво, Внесете, отстранете редовно поднесе здраво, да. И сега ако сум тип ЛС, ние сме назад hello.c. Не се обидуваат да ја избришете вашата Крај на изворниот код. Иако постојат можности вградени во CS50 IDE каде можете да одите преку историјата на ревизија и назад во времето ако случајно избришете нешто, да се сетат како на овие инструкциите, да или не, на она што всушност сакате да го направите. И кога ќе отидам до врвот лев агол стои тука, сите што останува е hello.c. Па таму е гроздовете на други команди кои вие може да се изврши во светот на Линукс, од кои една е, пак, се направи. И ние си оди за да се направи мојата програма сега како што следи. 

Наместо да го ѕвекот, наместо да го прават ѕвекот-о, Одам да се едноставно буквално тип, направи здраво. И сега се забележи, јас сум не пишување направи hello.c. Јас сум пишување направи здраво. 

И оваа програма Направете дека доаѓа со CS50 IDE, и повеќе обично со Linux, е програма која е ќе се направи програма наречена Здраво. И тоа се случува да се претпостави, по конвенција, дека ако може да се направи оваа програма, тоа се случува да се направи од извор кодот датотека завршува во dot c, hello.c. 

Значи, ако јас притиснете Enter сега, забележи дека командата која добива се извршува е, всушност, дури и подолго пред отколку порано. И тоа е затоа што ние сме конфигурирани CS50 ИРО да имаат некои дополнителни карактеристики вградени во тој ние едноставно не се потребни, но наскоро ќе. Но клучот нешто да се реализира сега имам програма Здраво. 

Ако јас повторно да ја внесете ЛС, јас има програма здраво. И можам да го стартувате со точка црта a.out, не, бидејќи целата поента на овој Вежбата беше точка коса црта здраво. И сега имам здраво светот програма. Така одат напред, ние сме речиси секогаш само ќе ги собере нашите програми со користење на командата направи. И тогаш ние ќе треба да ги извршувате со точка коса црта, и името на програмата. Но сфати она што се направи е тоа за вас, не е тоа само по себе е компајлерот. Тоа е само една програма погодност кој знае како да предизвика компајлерот да се кандидира, така што можете сами да го користите. 

Што постојат и други команди Linux, и за возврат на CS50 IDE? Наскоро ќе видите дека тоа е CD команда, Промена на директориум. Ова ви овозможува во рамките на вашиот командната линија интерфејс да се движи напред и назад, и да се отвори различни папки без помош на глувчето. 

LS видовме, која се залага за листата датотеки во тековниот директориум. Направете Дир, можете да најверојатно почнат да заклучиме што значат овие now-- направи директориум, ако сакате да креирате папка. РМ за отстранат, РМ Dir за отстрани directory-- и тие, повторно, се командната линија еквиваленти на она што може да се направи во CS50 IDE со вашиот глушец. Но наскоро ќе се најде дека понекогаш тоа е само многу побрзо да се направи работи со тастатура, и на крајот многу помоќна. 

Но, тешко е да се тврди дека нешто што сте го правеле досега е сето она што моќна, кога сите ние сме биле велејќи дека е, Здраво светот. И, всушност, јас Hardcoded на зборовите Здраво светот во мојата програма. Не постои динамика уште. Нула беше редот на големина поинтересна од минатата недела. 

И така, да одам таму. Ајде да направиме еден чекор кон таа страна начин на некои од овие функции. Затоа, не само што C доаѓаат со printf, и гроздовете на други функции од кои некои ќе видиме со текот на времето, тоа не се случи го прават тоа сите така лесно право надвор на портата во добивање на корисник влез. 

Всушност, една од слабостите на јазици како C, па дури и Java и уште другите, е тоа што тој не го прави тоа го прават тоа лесно да се само да работи како броеви од корисниците, или жици, зборови, и фрази, а камоли да работи како подвижна запирка вредности, или реални броеви со децимален поени, и навистина долго броеви, како што наскоро ќе видиме. Значи оваа листа на функции тука, овие се како другите парчиња гребење загатка дека ние сме пре-инсталиран во CS50 IDE дека ние ќе се користи за неколку недели обука тркала на сорти, и на крајот да ги исклучи, и со нетрпение под хаубата, можеби, во како се спроведуваат овие работи. 

Но, за да го направите ова, ајде всушност се напише програма. Дозволете ми да оди напред сега. И јас одам да се создаде нова датотеката со кликнување на оваа мала плус, и кликнете на филтерот. 

Одам да се спаси овој следната еден како, да речеме, string.c, затоа што сакаат да си играат со жици. И низа во C е само низа од карактери. Па сега ајде да одиме напред и да го направите следново. 

Вклучуваат стандардни IO.h-- и излегува стандард IO, IO само значи влез и излез. Значи излегува дека оваа линија, тука е она што е САД соседна да го користите printf. Printf, се разбира, произведува излез. Значи, со цел да го користите printf, што се испоставува од што треба да ја имаат оваа линија код на врвот на вашата датотека. 

И ние ќе се вратам на она што поточно, тоа значи пред долго. Излегува дека во било Ц програма пишувам, Морам да го започнете со код кој изгледа вака. И ќе забележите CS50 IDE, и други интегриран развој средини како него, ќе се обидат најдобро тие може да се заврши вашата мисла. Всушност, пред некој миг, ако јас го вратите она што јас само направив, јас притиснете Enter. 

Тогаш јас хит отворен кадрава голема заграда, притиснете Enter повторно. И заврши мојата мисла. Тоа ми даде нова линија, вовлечен не помалку за убаво стилски причини ќе видиме. А потоа автоматски ми даде дека кадрава голема заграда за да се заврши мојата мисла. Сега, тоа не е секогаш Претпоставувам дека она што сакате да го направите. Но, во голем дел, го прави тоа ќе те спаси некои кратенки. Значи пред еден миг, ние трчаше оваа program-- Здраво, свет, а потоа го состави, а потоа истрча. Но, не постои динамика тука. Што ако сакавме да направи нешто друго? Па, што ако јас сакав да се, всушност, добие стринг од корисникот? Одам да се користи сложувалка наречен точно that-- се стринг. 

Излезе во C, кога не сакате да се обезбеди влез на сложувалка парче, или посоодветно до некоја функција, можете буквално само го прават отворена заграда, затворена заграда. Па тоа е како да има Не белата кутија да напишеш во. блок забелешки пред имаше малку белата кутија. Немаме дека белата кутија сега. 

Но, кога ќе се јавам добие низа, јас сакате да се стави резултат некаде. Значи многу честа парадигма во C е да се јавете се на функција, како и добие тука низа, а потоа и чување на повратната вредност. Тоа е резултат на нејзината напор во нешто. 

И она што е изградба во програмирање, без разлика дали во гребење или сега Ц, кои ги можете да го користите за да всушност складираат нешто? Го нарече променлива, нели? И во нула, ние навистина не е гајле што се случува во променливи. 

Но, во овој случај, ние всушност го направи. Јас ќе одам да се каже стринг. И тогаш јас може да се нарече ова што сакам. Одам да го наречеме име, добива се стринг. 

И сега, дури и ако сте малку нови за ова, се забележи дека јас сум недостигаат некои детали. Јас сум заборавајќи точка-запирка. Јас треба да се заврши оваа мисла. Па јас ќе одам да се движи мојот курсорот, и хит-запирка таму. А што јас само се направи? Во оваа линија код, број 5 во моментот, Се јавувам добие низа без влезови. Така што не постои малку бело кутија како Зачувај блок има. 

Јас сум само велејќи, еј, компјутер, да ме стринг. знакот за еднакво е навистина знак за еднаквост, само по себе. Тоа е задача оператор, што значи, Еј, компјутер, се движат на вредноста по десната страна во текот на левата страна. И во лево, јас го имаат следново. 

Еј, компјутер, дај ми string-- низа од карактери. И повик таа низа име. И јас дури и не мора да го наречеме име. 

Јас би можеле да го наречеме, конвенционално, нешто како S, слично како што се користи од I до повик ì променлива. Но, сега треба да се направи нешто со неа. Тоа ќе биде прилично глупаво да обидете составувањето на овој код, трчање оваа програма, и покрај тоа што Јас сум добивање на стринг, бидејќи тоа е сепак само да се каже Здраво светот. 

Но, што ако јас сакам да го промени тоа. Зошто не можам да го направите ова? Процент s, запирка s. И ова е малку криптичната уште. 

Значи, дозволете ми да ми променливи повеќе јасно. Дозволете ми да се именува оваа променлива име. И да видиме ако не можеме да се закачам освен она што се случува овде. 

Така, на линија на пет, јас сум добивање на стринг. И јас сум со зачувување на таа низа, она што корисникот го внеле во во неговата или нејзината тастатура, во променлива наречена име. И излегува дека printf не само земе еден аргумент во двојен цитати, еден влез во двојни наводници. 

Тоа може да потрае два, или три, или повеќе, како дека во вториот или третиот или четвртиот, се сите имиња на променливи, или посебно вредности, што сакате да го приклучиш во, динамично, тоа стринг во наводници. Со други зборови, она што би било погрешно со ова? Ако јас само се поздравил со името, обратна коса црта n, ми го спаси датотека, составена мојот код, и се стрча тоа, она што ќе се случи? 

Тоа е само случува да се каже, здраво име, буквално N-А-М-Е, кој е глупаво бидејќи тоа е не се разликува од светот. Па ако нешто е во наводници што буквално добива печатени. Значи, ако сакам да имам случаеви таму, Јас всушност треба да се користи некои специјална синтакса. И излегува ако го прочитате документација за функција printf, тоа ќе ви каже дека ако користите проценти s, може да се замени со вредност како што следи. 

По запирка после тоа двојни наводници, можете едноставно напишете го името на променлива што сакате да го приклучиш во тој формат код или формат назначувач, проценти за жици. И сега ако сум ми го спаси датотека, Јас се врати долу на мојот терминал. И јас тип Направете стринг, затоа што, повторно, името на овој датотека што ја одбрав е пред string.c. 

Па јас ќе одам да се каже Направете стринг, влезе. О добрина, се погледне во сите грешките што веќе го направиле. И ова is-- што, ова е навистина како шест, седум линија програма? Значи ова е местото каде што многу да брзо да се добие огромно. 

Овој терминал прозорец има сега само се враќаат голем број на пораки за грешка. Се разбира, немам повеќе грешки пораки отколку што имаат линии на код. Значи она што се случува? 

Па, најдобрата стратегија да се направи во секое време се судрите со големо листата на грешки како што, е дојдете назад, погледнете за команда вие само се стрча, што во мојот случај е да се направи низа. Погледнеме во она што го прават не, и тоа е тоа долго ѕвекот команда, не е голема работа таму. 

Но црвено е лошо. Зелена се обидува да биде нежна и корисни. Но, тоа е уште лошо, во овој случај. Но, каде е лошо? 

String.c алинеја пет, пет карактер. Значи ова е само заеднички конвенцијата. Нешто нешто значи дебелото црево линијата број и бројот карактер. Грешка, употреба на непријавена идентификатор стринг. Дали мислевте стандард во? 

Значи, за жал, ѕвекот се обидува да биде од корист. Но, тоа не е во ред, во овој случај. Не, ѕвекот, јас не значи стандард IO. Мислев дека на линија еден, да. 

Но пет линија е овој овде. И ѕвекот не разбере С-Т-Р-И-Н-G. Тоа е непријавена идентификатор, на зборот едноставно никогаш не видел порано. И тоа е затоа C, јазикот ние сме пишување на код во право сега, нема променливи се нарекува жици. 

Тоа не се случи, по дифолт, поддршка нешто што се нарекува стринг. Тоа е CS50 парче жаргон, но многу конвенционално. Но, можам да го надминете овој, како што следи. 

Ако додадам една линија код на врвот на оваа програма, вклучуваат cs50.h, што е уште една датотека некаде во внатрешноста на CS50 IDE, некаде на хард дискот, така да се каже, на оперативниот систем Ubuntu дека јас се кандидирам, дека е датотека која е ќе учат за работа систем што низа е, само како стандард io.h е датотека во оперативниот систем кој е ќе го учат што printf е. 

Всушност, ние би го добиле многу слична порака ако IO призна стандард Io.h и се обидел да го користите printf. Па јас ќе одам да се оди напред и само ја преземат контролата L да го исчистите мојот екран. Или можете да напишете јасни и дека ќе биде само го исчистите прозорецот на терминалот. Но, сеуште можете да се движите назад во времето. 

И јас одам да повторување Направете стринг. Премине моите прсти овој пат, Enter. О, Боже мој, тој работел. тоа ми е долга криптичната команда тоа е она со што се создава преку ѕвекот, но не и пораките за грешки. Значи се реализира, иако може да се добие целосно обземен со број на пораки за грешки, тоа само може да биде оваа досадни каскадни ефект, каде ѕвекот не разбира една работа, што значи тогаш не се разбере на следниот збор, или на следната линија. И така тоа само пригушници на вашиот код. Но, на фикс може да биде едноставна. И така секогаш се фокусира на првата линија на производство. И ако не се го разбирам, само погледнете за клучни зборови, кои може да бидат индиции, и бројот на линијата, и карактер, каде таа грешка може да биде. 

Сега дозволете ми да оди напред и да напишеш точка црта, стринг, влезе. Хм, тоа не е велејќи здраво ништо. Зошто? Па, да се потсетиме, каде што е тоа трчање? 

Тоа е веројатно заглавени во моментот во еден циклус, ако сакате, на линија шест, бидејќи Земете Стринг страна на дизајнот, напишани од страна на персоналот CS50, е буквално значи само да седи таму те чека, и чекање, и чекање за низа. Сите ние подразбираме под низа е човечки влез. Па да знаете што? Дозволете ми да оди напред. И само за каприц, дозволете ми да тип моето име, Давид, влезе. Сега имам повеќе динамична програма. Тоа, рече, здраво Давид. 

Ако одам напред и да ја стартувате ова, повторно, дозволете ми да се обиде да се каже Zamila име, влезе. И сега имаме динамична програма. Не сум хард кодирани светот. Не сум хард кодирани име или Давид или Zamila. 

Сега е многу повеќе како програми знаеме, каде што ако тоа се влез, го произведува малку поинаква излез. Сега, ова не е најдобар корисник искуство, или UX. Јас ја стартувате програмата. 

Јас не знам што би требало да се направи, ако јас всушност поглед на или се сеќаваат на изворниот код. Значи, да се направи на корисникот искуство малку подобро со наједноставните нешта. Дозволете ми да се вратам во оваа програма, и едноставно да се каже printf. 

И дозволете ми да оди напред и да го изговара името, дебелото црево, и простор, а потоа и точка-запирка. И само за клоци, без реакција n. И тоа е намерно, бидејќи јас не сакам брза да се преселат на следната линија. 

Сакам да се, наместо тоа, да го направите ова, бидете низа повторно да го компајлирате кодот ми во нова машина код точка намали стринг. Ах, ова е многу поубава. Сега јас всушност знам што компјутерот сака мене да се направи, да го даде името. 

Па јас ќе одам да се оди напред и да напишеш во Роб, внесете го и здраво, Роб. Значи, се реализира, тоа е, сепак, на крајот на ден, само програма од девет линија. Но, ги зедовме овие бебешки чекори. 

Ние напиша една линија со која се беа познати, printf, Здраво светот. Тогаш ние undid малку за тоа. И ние всушност се користи добие стринг. И ние го исфрли таа вредност во променлива. А потоа отидовме напред и да се подобри што понатаму со третата линија. И ова итеративен процес на пишување софтвер е навистина клучот. Во CS50, и во животот воопшто, обично не треба да се седне, има програма во умот, и да се обиде пишување целата проклета работа на сите одеднаш. 

Тоа ќе неизбежно резултира со начин повеќе грешки отколку ние самите видов тука. Дури и јас, на овој ден, постојано направи други глупави грешки, се всушност потешко грешки кои се потешко да дознаам. Но, ќе се направи повеќе грешки повеќе линии на код пишувате на сите одеднаш. И така оваа практика, напишете малку на код дека сте удобно со, состави тоа, да го стартуваш, проба поопшто, а потоа се пресели on-- па исто како и ние се чуваат дели и дели минатата недела, зграда од нешто многу едноставно да се нешто повеќе комплекс, го стори истото овде. Не се седне, и обидете се да напишам целиот проблем. Всушност се овие мали чекори. 

Сега, жици не се сите тоа корисно при себе. Ние би всушност, идеално, како да има нешто друго во нашето раководство. Па ајде да всушност го прават токму тоа. 

Дозволете ми да оди напред сега и разбивам малку поинаква програма. И ние ќе го наречеме ова int.c, на цел број. Одам да се, на сличен начин, вклучуваат CS550.h. Одам да вклучуваат стандардни IO. И тоа се случува да биде доста заеднички во овие првите неколку дена од класата. 

И јас одам да се подготвени себеси со главната функција. И сега, наместо на добивање на стринг, ајде да одиме напред и да добиете Инт. Ајде да го наречеме јас, и повик да го добие int, во близина parens, точка-запирка. И сега ајде да го направите нешто со него, printf. 

Да речеме нешто како Здраво, обратна коса црта n, запирка i. Затоа, јас сум доста имитирајќи она што го направив пред само еден миг. Имам случаеви тука. Имам запирка јас тука, затоа што сакам да го приклучиш I во кои случаеви. 

Па ајде да одиме напред и да се обидат составувањето на оваа програма. Датотеката се нарекува int.c. Па јас ќе одам да се каже, се int, влезе. О, боже, но не е голема работа, нели? Има грешка. 

Има еден синтаксичка грешка тука, така што програмата не може да се состави во int.c, линија седум, ликот 27, формат грешка Го одредува видот знак ѕвезда, што и да е. Но, типот на аргумент е Инт. 

Значи тука, исто така, ние не ќе to-- иако денес е многу материјал, ние ќе ви ги победат со апсолутно секоја функција на C, и програмирање поопшто, само овие првите неколку недели. Па таму често се случува да биде жаргон со која не сте запознаени. И, всушност, знак ѕвезда е нешто ние ќе треба да се врати на во една недела или две е време. 

Но, за сега, ајде да видиме дали можеме да анализирам зборови, кои се познати. Formats-- така слушнавме формат спецификациите, формат код пред. Тоа е познато. Type-- но аргументот има int тип. Чекај малку, јас е int. 

Можеби проценти е, всушност, има некои дефинирано значење. И, навистина, го прави тоа. Цел број, ако сакате printf да го замени, што всушност треба да се користи различен формат спецификациите. А ти да не ќе знаат ова освен ако некој ви кажал, или ќе му го направи пред тоа. Но, проценти i е она што може да се најчесто се користи во printf за приклучување на цел број. Вие исто така може да се користи проценти г за децимален број. Но, јас е убав и едноставен тука. Па ние ќе се оди со тоа. 

Сега дозволете ми да оди напред и да прегласувањето направи int, Enter. Тоа е добро, нема грешки. Dot намали int-- ред, лоша корисник искуство, бидејќи не сум си реков што да се прави. Но, тоа е во ред. Јас сум фаќање на брзо. 

А сега дозволете ми да оди напред и да напишете Дејвид, во ред, Zamila, Роб. Добро, така што ова е добра работа. Овој пат, јас сум со користење на функцијата, загатка парче, наречен добие Инт. И излегува out-- и ние ќе види ова подоцна во term-- вработените во CS50 има имплементирано се низа на таков начин дека тоа само физички добие стринг за вас. 

Таа има имплементирано стапите int во на таков начин што тоа само ќе добие цел број за вас. И ако, на човекот, не соработува, тоа е буквално само ќе се велат обидете се повторно, обидете се повторно, обидете се повторно, буквално седи таму looping, додека се обврзат со некои магични број, како 50, 50 и здраво. 

Или ако трчаме тоа повторно и тип во 42, здраво 42. И така функција на се int внатре во тоа сложувалка е доволно логика, доволно мисла, да дознаам, она што е зборот? И она што е бројот? Прифаќање само во крајна линија броеви. 

Значи излегува дека овој не е толку експресивен. до сега. Значи, Yay, последен пат се отиде прилично брзо во игри за спроведување, и анимација, и уметнички дела во Scratch. И тука, ние сме се содржина со здраво светот, и здраво 50. 

Тоа не е сè што инспиративни. И, навистина, овие првите неколку примери ќе потрае некое време на рампата во возбуда. Но, ние имаме толку многу повеќе контролираат сега, во факт. И ние ќе се многу начин почне да дели на врвот на овие основни примитиви. 

Но прво, да се разбере она што ограничувања. Всушност, една од работите Нула не е лесно ајде да направите е да навистина се погледне под капакот на моторот, и да го разбере она што компјутер е, она што може да направи, и кои се нејзините ограничувања. И, навистина, дека недостатокот на разбирање, потенцијално, долгорочните може да доведе до нашите сопствени mistakes-- пишување грешки, пишување несигурен софтвер кој добива пробиени на некој начин. 

Значи, да се преземат некои чекори кон разбирање на овој малку подобро од начин, на пример, следниов пример. Одам да се оди напред и да се спроведе вистински брз програма наречена Гуја. Како, да додадете некои броеви заедно. И јас одам да се кодира некои делови тука, и само копирајте каде што беше досега, само така што може да се случува порано. Па сега имам основни почетоци на програмата наречена Гуја. 

И да одиме напред и да го направите тоа. Одам да се оди напред и да да речеме, intx добива се Инт. И знаете што? Да се ​​направи подобро корисничко искуство. 

Значи, да речеме x е, како и ефикасно го извести корисникот за да ни даде x. И тогаш дозволете ми да оди напред и да каже, printf како за у е, ова време се во очекување две вредности од корисникот. И тогаш ајде да одиме напред и да да речеме, printf, збирот на x и y е. И сега не сакам да се направи отсто s. Сакам да се направи проценти i, обратна коса црта n, а потоа приклучок во вредност сума. 

Па како можам да се обратите за тоа? Знаеш што? Знам како да се користи променливи. Дозволете ми да се изјасни за нова, int z. 

И јас одам да се погоди тука. Еднаквите знаци во оваа јазик, можеби и јас само може да го направи x плус y, толку долго како што крајот на мојата мислев со точка-запирка? Сега можам да се вратам овде, уклучете z, заврши оваа мисла со точка-запирка. И ајде да видиме сега, ако тие секвенци на lines-- x е да се добие Инт. Y е да се добие Инт. 

Додај x и y, чување на вредноста во z-- Значи, повторно, се сеќавам на знак за еднаквост не е еднаква. Тоа е задача од десно кон лево. И ајде да испечатите дека сумата од X и Y не е буквално z, Но, она што е во внатрешноста на ●. Значи, да се направи Гуја - убаво, нема грешки тоа време. Dot намали Гуја, внесете, x се случува да биде 1. 

Y ќе биде 2. И збирот на x и y е 3. Па тоа е во ред и добро. 

Па можете да се замисли дека математиката треба да работат во програма како оваа. Но знаеш што? Дали оваа променлива, линија 12, па дури и е потребно? Вие не треба да се добие во навика на само чување на работи во променливи само затоа што можеш. И, всушност, тоа е генерално смета за лоша дизајн ако се создавање на променлива, наречен z во овој случај, чување нешто во него, а потоа веднаш го користите, но никогаш повеќе. Зошто да се откаже нешто име како z ако сте буквално ке го искористиме работа само еднаш, и така проксимално од каде што сте го креирале се на прво место, толку блиску, во смисла на линии на код? Па да знаете што? Излегува дека C е прилично флексибилни. Ако јас всушност сакаат да plug-in вредности тука, Јас не треба да се изјасни за нова променлива. Јас само може да plug-in-x плус y, бидејќи C разбира аритметика, и математички оператори. 

Па јас едноставно може да се каже, го прават тоа по математика, x плус y, без оглед на тие вредности се, приклучок како резултат на цел број во таа низа. Така што ова може да биде, иако само една линија пократко, подобар дизајн, подобра програма, затоа што има помалку код, затоа помалку за мене да се разбере. И тоа е исто така само почиста, доколку ние не сме воведување на нови зборови, нови симболи, како z, и покрај тоа што не ми се служи многу на таа цел. 

За жал, математика не е сето тоа сигурен понекогаш. Ајде да одиме напред и да го направите тоа. Одам да се оди напред сега и да го направите следново. 

Ајде да го направиме printf, проценти i, плус проценти I, се проценти i, обратна коса црта n. И јас одам да се направи this-- xyx плус y. Па јас сум само ќе го преработи уште еднаш ова малку поинаку тука. Дозволете ми да се направи брза проверка разумност. Повторно, да не се понапред од нас самите. Направете ехидна, точка коса црта ехидна. x е 1, y е 2, 1 плус 2 е 3. Па тоа е добро. Но, ајде да ја комплицира оваа сега малку, и да се создаде нова датотека. 

Јас ќе одам да се јавите на оваа една, велат, ints, множина за цели броеви. Дозволете ми да започнам каде што беше пред една момент. Но, сега ајде да направиме неколку други линии. Дозволете ми да оди напред и да го направите следново, printf, проценти i, минус проценти i, е проценти i, запирка x, y запирка yx минус. Па јас го правам малку различни математика таму. Ајде да го направиме уште еден. Значи проценти i пати проценти i е проценти i, обратна коса црта n. Ајде plug-in-x и y, x и y пати. Ние ќе го користите ѕвездичка на вашиот компјутер за време. 

Не го користите x. x е име на променлива овде. Можете да го користите ѕвезда за множење. Ајде да го направиме уште еден. Printf посто, поделени со проценти јас, проценти i, обратна коса црта n. xy поделено со y-- така да го користите коса црта во C да се направи поделба. И ајде да се направи еден на друг. Остатокот од проценти i, поделени со проценти i, е посто. xy-- и сега остатокот е она што се останати. Кога ќе се обидат делење на именител во броителот, колку е лево во текот на овој не би можел да се подели надвор? 

Па не е, навистина, мора, симбол ние сме се користи во основно училиште за ова. Но, постои во C. Можете велат modulo x y, каде што овој процент знак во оваа context-- збунувачки кога сте внатре на двојни наводници, внатрешноста на printf, проценти се користи како назначувач формат. 

Кога користите проценти надвор од дека во математички израз, тоа е операторот на modulo за модуларна arithmetic-- за нашите цели тука, само значи, она што е остатокот од x поделено со y? Значи x поделено со y е y x коса црта. Што е остатокот од x поделено со y? Тоа е x y МО, како програмер би рекол. 

Значи, ако сум направил ниту една грешка тука, дозволете ми да оди напред и да ints, множина, убаво, и точка коса црта ints. И да одиме напред и да се направи, да речеме, 1, 10. Сите во право, 1 плус 10 е 11, чек. 1 минус 10 е негативен 9, проверете. 

1 пати 10 е 10, чек. 1 поделено со 10 is-- Добро, ќе го прескокне тој. Остатокот од 1 поделено со 10 е 1. Тоа е точно. Но, има грешка во тука. 

Така, оној ставам предаде, не е точно. Мислам, тоа е во близина на 0. 1 поделено со 10, знаеш, ако ние сме намалување на некои делови, да, тоа е нула. Но, тоа навистина треба да биде 1/10, 0.1, или 0,10, 0,1000, и така натаму. 

Тоа навистина не треба да биде нула. Па, излегува дека компјутерот е прави буквално она што го рече да се направи. Ние се прави математика како X поделено со y. И двете x и y, по линиите на код порано, се цели броеви. 

Покрај тоа, на линија 15, ние сме кажува printf, еј, printf plug-in цел број, plug-in-цел број, plug-in-на integer-- посебно x, а потоа и y, а потоа x поделено со y. x и y се ints. Ние сме добро таму. 

Но, она што е x поделено со X? x поделено со y треба да биде, математички, 1/10, или 0.1, кој е вистинскиот број, реален број има, потенцијално, децимална точка. Тоа не е цел број. 

Но, она што е најблиску број на 1/10, или 0,1? Да, тоа е вид на нула. 0.1 е како тоа многу. И 1 е ова многу. Значи 1/10 е поблиску до 0 отколку што е на еден. 

И така она C прави за us-- вид, затоа што тоа го кажа to-- е truncating дека цел број. Тоа е преземање на вредноста, кој повторно е би требало да биде нешто како 0,1000, 0 и така натаму. И тоа е се што truncating по децималната точка така што сите на овој работи, бидејќи тоа не се случи вклопат во поимот на број, кој е само број како негативни 1, 0, 1, нагоре и надолу, го фрла далеку се по децималната точка затоа што не може да се вклопат на децимална точка во целиот број и по дефиниција. 

Значи одговорот тука е нула. Па, како да го надминете овој? Ние треба друго решение, сите заедно. И ние може да го направите ова, како што следи. 

Дозволете ми да оди напред и да се создаде нова датотека, ова се вика floats.c. И зачувајте тука во истиот директориум, float.c. И дозволете ми да оди напред и да ја копирате некои од дека кодот од порано. 

Но, наместо на добивање на int, ајде да го направите тоа. Дај ми децимален број наречен x. каде што со подвижна запирка вредност е само буквално нешто со подвижна запирка. Тоа може да се движи кон лево, на десно. Тоа е вистински број. 

И дозволете ми да не ги нарекуваат се int, но се плови, кој исто така беше еден од менито на опции во библиотеката C250. Ајде y се промени за да се одржи. Значи ова станува се плови. 

И сега, ние не сакаме да го приклучиш во ints. Излегува ние мора да ја користи проценти F за плови, проценти F за плови, и сега да ја зачувате. И сега, прсти ја преминал, бидете плови, убаво, точка коса црта плови. x се случува да биде еден 1. y Ќе биде 10 повторно. 

И, добро, во ред тоа ми е точна. Се надевав на повеќе, но јас заборавив да го пишувам. Па ајде да одиме и да ја поправите оваа логичка грешка. 

Ајде да одиме напред и го имате следново. Ние само ќе се направи малку копирате и залепите. И јас одам да се каже минус. 

И јас одам да се каже пати. И јас одам да се каже поделени. И јас не одам да се направи modulo, кое не е толку germane тука, поделено со F, и времиња plus-- Добро, ајде да го направите ова повторно. 

Направете плови, точка коса црта плови, и 1, 10, and-- убаво, не, во ред. Па јас сум идиот. Значи ова е многу честа по компјутерски науки да се направи глупави грешки како оваа. 

За педагошки цели, она што јас навистина сакав да го направам е промена на науката тука до плус, минус, да пати, и да се подели, како што се надевам дека забележи во текот на оваа вежба. Па сега ајде повторно да ги собере на оваа програма, се направи точка коса црта плови. 

И по трет пат, ајде види дали таа ги исполнува моите очекувања. 1, 10, внесете, да, во ред, 1.000, поделено со 10.000, е 0,100000. И излегува можеме да ги контролираме колку Бројките се по оние децимални места. Ние, всушност, ќе. Ќе се вратам на тоа. 

Но, сега, всушност, математика е точно. Значи, повторно, она што е готова брза тука? Излегува дека во C, постојат не само што strings-- и, всушност, Не постојат навистина, затоа што додадете оние со CS50 библиотека. Но, не се само ints. 

Исто така, постојат плови. И излегува еден куп други податоци видови исто така, дека ние ќе се користи пред долго. Излегува ако сакате еден карактер, не е низа од карактери, можете да го користите само еден знак. 

Излегува дека ако сакате bool, Булова вредност, тоа е вистина или само лажна, благодарение на CS50 библиотека, ние сме додадени на C тип bool податоци. Но, тоа, исто така, е присутна во многу други јазици, како и. И излегува дека понекогаш потребни поголеми броеви потоа се стандардно со ints и плови. 

И, всушност, двојно е број не дека го користи 32-битна, но 64 бита. И долго време е број кој користи не 32, туку 64 битови битови, односно, за подвижна запирка вредности и цели броеви, соодветно. Па ајде, всушност, сега види во акција. 

Одам да се оди напред тука и камшик до една друга програма. Еве, јас ќе одам да се оди напред и ги вклучуваат cs50.h. И дозволете ми да оди, вклучуваат стандардни IO.h. 

И ќе забележите нешто фанки се случува овде. Тоа не е боја кодирање работи во на ист начин како што беше порано. И што излезе, тоа е затоа што не дале нешто името на датотеката. 

Јас ќе одам да се јавите на оваа sizeof.c, и кликнете на Save. И ќе забележите што се случува со мојата бела кодот против таа црна позадина. Сега барем има некои пурпурна таму. И тоа е синтакса истакнат. 

Тоа е затоа што, едноставно, јас сум изјави за IDE тоа каков тип на датотека тоа е со давање на тоа име, и посебно наставката на датотеката. Сега, ајде да одиме напред и да го направите тоа. Одам да се оди напред и многу едноставно печатење на following-- bool е LU проценти. 

Ние ќе се вратам на дека во само еден миг. И тогаш јас ќе одам да големината на печатењето на bool. И сега, само за да се спаси си некое време, јас сум случува да се направи целина куп од нив одеднаш. И, посебно, јас ќе одам да се промените ова во знак и знак. Овој, јас ќе одам да се промени на двојно и двојно. 

Овој, јас ќе одам да се промени да се плови и плови. Овој, јас ќе одам да промена на int и int. И ова, јас ќе одам да се менува во долго долго. И тоа е уште ги долго време, долго долго. 

И тогаш, на крај, јас дадов си еден и премногу, стринг. Излегува дека во C, има посебните оператор наречен големината на таа буквално случува да се, кога се работи, да ни кажете големината на секоја од овие варијабли. И ова е еден начин, сега, можеме да се поврзете назад да се расправа минатата недела на податоци и застапеност. 

Дозволете ми да оди напред и да се изработат големина на dot големина коса црта. И ајде да видиме. Излегува дека во C, посебно на CS50 IDE, посебно на оперативниот систем Ubuntu, која е 64-битен оперативен на систем во овој случај, на bool ќе се користи еден бајт на просторот. Тоа е како се мери големината, не во битови, но во бајти. И се сети дека еден бајт е осум бита. Значи, bool, и покрај тоа што технички треба само 0 или 1, тоа е малку непотребното како ние сме го спроведува. Тоа е, всушност, ќе се користи во целина byte-- па сите нули, можеби се сите оние, или нешто слично, или само еден 1 меѓу осум бита. 

Знак, пак, што се користи за лик како ASCII карактер на минатата недела, се случува да биде еден знак. И тоа synchs со нашиот поим на тоа да биде не повеќе од 256 bits-- подобро, synchs со него бидејќи нема подолго од 8 бита, што ни дава колку што 256 вредности. А двојно ќе се биде 8 бајти или 64 бита. 

Носете е 4. На int е 4. А долго, долго време е 8. И низа е 8. Но, не грижете се за тоа. Ние ќе се лупам назад тој слој. Излезе, жици може да да биде подолг од 8 бајти. 

И, навистина, ние сум напишал жици веќе, здраво светот, подолго од 8 бајти. Но, ние ќе се вратам на дека во само еден миг. Но, да го одземе тука е следниот. 

Секој компјутер има само ограничен количина на меморија и простор. Можете да ги чувате само толку многу додадени фајлови на вашиот Mac или PC. Можете да ги чувате само толку многу програми во RAM работи одеднаш, нужно, дури и со виртуелна меморија, затоа имате ограничен износ на RAM меморија. 

И само да picture-- ако никогаш не сте отвори лаптоп или нареди дополнителна меморија за компјутер, може да не знаат дека внатрешноста на вашиот компјутер е нешто што изгледа малку се допаѓа ова. Значи ова е само една заедничка компанија со име Од клучно значење што го прави RAM меморија за компјутери. И RAM меморија е местото каде што програми живеат, а тие си работи. 

Така, на секој Mac или PC, кога ќе се удвои кликнете на програма, а тоа се отвора, и тоа се отвора некои Word документ или нешто слично, тоа го чува привремено RAM меморија, RAM меморија, бидејќи е побрз од вашиот хард диск, или вашата цврста состојба диск. Па тоа е само во случај кога програмите се да живее, кога тие работи, или кога се користат датотеки. 

Значи мора да работите кои изгледаат како овој во внатрешноста на вашиот лаптоп, или малку поголеми работи во внатрешноста на вашиот десктоп. Но, клучот е дека треба само ограничен број на овие работи. И има само ограничен износ на хардвер седи на маса ова право овде. 

Значи, сигурно, не можеме да ги чувате бескрајно долга броеви. И, сепак, ако се сетам основно училиште, колку може бројки имаш на правото на децимална точка? За таа работа, колку може бројки мора да се од лево на децимална точка? Навистина, бесконечно многу. 

Сега, ние, луѓето само што може да знаат како да го изговара милиони евра, и милијарди, милијарди долари, а квадрилион и квинтилијарди. И јас сум туркање на границите на мојот understanding-- или my-- Разбирам броеви, но ми изговор на броеви. Но, тие може да се добие бесконечно голем со бесконечно многу цифри лево или на правото на децимална точка. 

Но, компјутери имаат само ограничен износ на меморија, ограничен број на транзистори, на ограничен број на светилки во внатрешноста. Значи она што се случува кога ќе снема простор? Со други зборови, ако сетам на минатата недела кога зборувавме за броеви самите може да бидат застапени во бинарна, Претпоставувам дека ние го добивме овој 8-битна вредност тука. 

И ние имаме седум 1 и еден 0. И да претпоставиме дека сакаме да додадете 1 на оваа вредност. Ова е навистина голема бројка во моментов. 

Ова е 254, ако се сеќавам математика од минатата недела во право. Но, што ако јас се промени дека најдесната 0 до 1? Целиот број на Се разбира, станува осум 1 е. Значи ние се уште сме добри. 

И тоа веројатно претставува 255, иако во зависност од контекстот тоа всушност може да претставува негативен број. Но повеќе за тоа друг пат. Ова се чувствува како да е за високо како што може да смета. 

Сега, тоа е само 8 бита. И мојот Mac, секако, има начин повеќе од 8 бита од меморија. Но тоа не се конечни. Значи истиот аргумент се однесува, дури и ако имаат повеќе од овие оние на екранот. 

Но, она што се случува ако сте складирање на овој број, 255, и сакате да се избројат 1 малку повисоки? Сакаш да одиме 255-256. Проблемот, се разбира, е дека ако почне пребројување на нула како и минатата недела, што не може да се смета како високо како 256, а камоли 257, а камоли 258, m, бидејќи она што се случува кога ќе додадете 1? Ако го направите стариот основно училиште пристап, ќе се стави на 1 тука, а потоа 1 плус 1 е 2, но тоа е навистина нула, ти го носиш на 1, носат 1, носат 1. Сите овие работи, овие 1, оди на нула. И ќе навивам, да, како некој посочи, 1 на левата страна. Но, сè може да се всушност гледаат и се вклопуваат во меморијата е само осум 0, што е да се каже во одреден момент, ако, на компјутер, се обиде броење доволно високо, ти си ќе заврши околу, се чини, на нула, или можеби дури и негативен броеви, кои се дури и пониски од нула. 

И ние може да вид на се види тоа. Дозволете ми да оди напред и да пишува вистински брз програмата тука. Дозволете ми да оди напред и да пишува програма наречена прелевање. Вклучуваат cs50.h, вклучуваат стандард IO.h-- ох, Јас навистина промашив означувањето на синтаксата. Значи, да се спаси ова како overflow.c. 

И сега int главната void-- и пред долго време, ние ќе се врати да се објасни зошто ние се задржи пишување int главната неважечки. Но, за сега, ајде да се направи тоа, земајќи го здраво за готово. Ајде да си даде int, и се иницијализира на 0. 

Ајде тогаш да го направите за int i добие zero-- Всушност, ајде да го направите бесконечна јамка и да видиме што се случува. Иако е точно, тогаш ајде да се печати n е проценти i, обратна коса црта n, plug-in-n. Но, сега, да се направи n n добива плус 1. 

Значи со други зборови, на секоја повторување на овој бескрајна јамка, ајде да ги вредност n е, и додадете 1 до неа, а потоа зачувување на резултатот уште во n на левата страна. И, всушност, сме виделе синтакса нешто како ова, за кратко време. А се излади трик е наместо на пишување на сето тоа, всушност, може да се каже еден n плус еднаков на 1. 

Или, пак, ако навистина сакате да биде фенси, може да се каже n плус плус точка-запирка. Но, овие последните две се само она што ние би го нарекуваат синтаксички шеќер за првото нешто. 

Првата работа е поексплицитно, сосема во ред, целосно точни. Но, ова е почест случај, јас ќе кажам. Значи, ние ќе го направи тоа за само еден миг. 

Ајде сега да преливник, што звучи прилично застрашувачки, точка коса црта претекување. Ајде да видиме, n е добивање прилично голема. Но, ајде да размислиме, колку е голема може N добие? 

n е цел број. Видовме еден миг пред со големината на пример за тоа дека на int е четири бајти. Ние знаеме од минатата недела, четири бајти е 32 бита, бидејќи 8 4 пати, тоа е 32. Тоа се случува да биде 4 милијарди долари. 

И ние сме до 800.000. Ова се случува да се засекогаш да се смета како високо како што веројатно може. Па јас ќе одам да се оди напред, Како што можете да пред долго време, и ја погоди контрола C-- искрено, контрола Ц, многу, каде што контролата C генерално средства откажете. За жал, поради ова работи во облакот, Понекогаш облакот е плукање од толку многу работи, толку многу излез, тоа се случува да потрае малку повеќе време за мојот влез да се дојде до облакот. Значи, иако јас хит Контрола C пред неколку секунди, ова е дефинитивно страна Ефектот на бесконечна јамка. 

И така, во тие случаи, ние сме тоа останува да биде. И ние си оди за да додадете друг терминален прозорец овде со плус, што секако не е како што, бидејќи тоа е се уште размислува. И да одиме напред и да биде малку повеќе разумни. 

Одам да се оди напред и да прават ова само finitely многу пати. Ајде да го користите за телефонска линија, што јас се алудира погоре. Ајде да го направиме ова. Дај ми уште една променлива int i добива 0. i е помал од, да речеме, 64 i ++. А сега дозволете ми да оди напред и печатење од n е проценти i, запирка n. И тогаш n-- ова е уште случува да се земе засекогаш. Ајде да го направиме ова. 

n добива n пати 2. Или, пак, може да биде фенси и не е еднакво на 2 пати. Но, ајде да речеме n се еднакви, 2 пати. Со други зборови, во овој новата верзија на програмата, Не сакам да чекаат вечно како од 800.000 до 4 милијарди долари. Ајде да се добие оваа во текот со. 

Ајде да всушност двојно N секој пат. Која, да се потсетиме, а удвојувањето е спротивно на се има, се разбира. И додека минатата недела имаме нешто повторно, и повторно, и повторно, супер брз, удвојување сигурно ќе ни се од 1 до најголем можен вредност што може да се смета да се со int. 

Значи, да го прават токму тоа. И ние ќе се вратам на ова пред долго. Но, ова, повторно, е исто како повторениот блок во Scratch. И ќе го користите овој пред долго. 

Ова само значи Грофот од нула до, но не се еднакви, на 64. И на секој повторување на овој јамка, само продолжи да ја зголемува i. Па јас ++ - и ова општо конструкција на линија 7 е само супер заеднички начин за повторување на некои линии на код, некои број на пати. Кои линии на код? Овие големи загради, како што може да се береше класи од сега, значи, го направите следново. 

Тоа е во како нула, кога што има жолти блокови и други бои тој вид на прифатат или прегрне други блокови. Тоа е она што тие кадрава протези се прави тука. Значи, ако јас добив синтакса мојот right-- вас може да се види симбол на морков во C средства тоа е колку пати сум бил обидуваат да го решат овој проблем. Значи, да се ослободи од тоа еден целосно, и да го затворите прозорецот. И ние ќе го користат новиот еден. Направете преливник, точка коса црта преливник, Enter, сите во право, тоа изгледа лошо во прв план. Но, ајде да дојдете назад во времето, затоа што јас го направи ова 64 пати. 

И информации за прв пат, што n е 1. Втор пат, n е 2, а потоа 4, а потоа 8, а потоа 16. И се чини дека штом Јас се на околу 1 милијарда евра, ако јас го удвои повторно, дека треба да ми даде 2 милијарди долари. Но, се покажа, тоа е право на врвот. 

И така тоа всушност се прелева на int од 1 милијарда на околу негативните 2 милијарди долари, бидејќи цел број, за разлика од броеви што на претпоставуваа минатата недела, може да биде и позитивни и негативни во реалноста и во компјутерот. И така барем еден од оние битови е ефективно украдени. Значи ние навистина треба само 31 бита, или 2 милијарди можни вредности. 

Но, за сега, готова брза е доста едноставно, што бројките се и без оглед на математика е, нешто лошо се случува на крајот, бидејќи на крајот ќе се обидуваат да permute битови еден премногу пати. И ќе можат ефикасно да одат од сите 1 е да можеби ги сите 0, или можеби само некој друг модел кој го Јасно е дека, во зависност од контекстот, може да се толкува како негативен број. И така тоа ќе изгледа на највисоко јас може да се смета во оваа конкретна програма е само околу 1 милијарда долари. Но, има делумно решение овде. Знаеш што? 

Дозволете ми да се промени од int за долго долго. И дозволете ми да оди напред тука и say-- јас ќе одам да се да го промените ова во една непотпишана долго. Или, ајде да видиме, Никогаш не се сеќавам. 

Ајде да одиме напред и да претекување. Не, тоа не е тоа, LLD, ви благодарам. Па понекогаш ѕвекот може да биде корисно. Јас не се сеќавам што формат спецификациите беше порано за долго долго. 

Но, навистина, ѕвекот ми кажа. Зелената е некој вид на добро, сепак значи дека направил грешка. Тоа е Сомневајќи се дека мислев LLD. 

Значи, да ме однесе тоа е совет, долг долго децимален број, освен тоа. И дозволете ми да го повторија, точка намалување на претекување, Enter. И сега што е кул е тоа. 

Ако јас дојдете назад во времето, ние се уште се започне броење во исто place-- 1, 2, 4, 8, 16. Забележуваме, ги добиете сите па се до 1 милијарда долари. Но, тогаш можеме безбедно да се дојде до 2 милијарди долари. 

Тогаш ние се дојде до 4 милијарди долари, од 8 милијарди долари, 17 милијарди долари. И ние се оди повисоко, и повисоки и повисоки. На крајот, тоа, исто така, паузи. 

На крајот, со долго време, која е 64-битна вредност, а не на вредноста на еден 32-битен, ако смета премногу високи, ќе заврши околу 0. И во овој случај, ние се случи да заврши со негативен број. 

Значи ова е проблемот. И излегува дека овој Проблемот не е толку таинствени. Иако сум намерно тоа предизвикана со овие грешки, излегува можеме да го видиме каков вид на сите околу нас, или барем некои од нас. 

Значи во Лего Војна на ѕвездите, ако Дали некогаш сте играле играта, излегува можете да одите околу кршење работи во ЛЕГО светот, и собирање монети, во суштина. И ако сте некогаш играл оваа игра премногу време, како овој неименуван индивидуални овде го направи тоа, вкупниот број на кованите пари што може да се соберат е, се чини, 4 милијарди долари. 

Сега, со тоа е всушност заоблени. Значи ЛЕГО се обидува да задржи нешта корисник пријателски. Тие не го прават токму од 2 до 32 власт, на минатата недела. Но, 4 милијарди е причина. Се чини дека, врз основа на оваа информација, дека LEGO, а компанијата која го направи овој вистински софтвер, одлучи дека максималниот број на монети, корисникот може да се акумулира е, всушност, 4 милијарди долари, затоа што одлучил во нивните код да се користи не долго долго, очигледно, но само цел број, една непотпишана цел број, само позитивен цел број, чија Макс вредност приближно е тоа. Па, еве уште една смешна еден. Значи во играта цивилизација, која Некои од вас може да биде запознаен со излегува дека пред неколку години има беше грешка во оваа игра која Ако сте играле улога на Ганди во играта, наместо него се многу пацифист, наместо тоа беше неверојатно, неверојатно агресивни, во некои околности. Особено, на начинот на кој цивилизација работи е дека ако, на играчот, прифати демократија, вашиот агресивност резултат добива decremented со два, па минус минус, а потоа минус минус. 

Така да одзема 2 од вашиот вистински процесирањето. За жал, ако вашиот процесирањето е првично 1, 2 и ќе се одземе од него по усвојувањето на демократијата како Ганди тука може да да се направи, бидејќи тој беше многу passive-- 1 на скалата на агресивност. Но, ако тој прифаќа демократијата, тогаш тој се движи од 1 до негативни 1. 

За жал, тие беа користење на непотпишана броеви, што значи дека тие се третираат дури и негативен броеви, како и иако тие беа позитивни. И излегува дека позитивни еквивалент на негативни 1, во типичен компјутерски програми, е 255. Значи, ако Ганди прифаќа , А со тоа и демократијата има неговата агресивност резултат намален, тоа всушност се врти 255 и него најмногу го прави агресивен карактер во играта. Па можете на Google врз ова. И тоа беше, всушност, на случајно програмски грешки, но тоа е сосема влезе ученост и оттогаш. 

Тоа е сите забава и симпатична. Повеќе застрашувачки е кога вистинските реалниот свет уреди, и не игри, имаат истите грешки. Всушност, само пред една година дојде една статија дознаете за Боинг 787 Dreamliner. 

И член на прв поглед чита малку таинствени. Но, тоа го рече ова, софтвер ранливост во Боинг нови 787 Dreamliner Џет потенцијал да предизвика пилоти да ја изгуби контролата авионот, можеби во средината на летот, службениците FAA предупреди авиокомпании неодамна. Тоа беше определување Тој модел 787 Авионот кој се напојува постојано за 248 дена да ги изгубите сите наизменична струја, наизменична струја, електрична енергија се должи на генератор контролни единици, GCUs, истовремено ќе успеат во сигурниот режим. Тоа е вид на ме губи. Но, во меморандумот што е наведено, во ред, сега добив дека, состојбата е предизвикана од страна на софтвер се спротивстави на внатрешната контрола на генератор единици кои ќе се прелеваат по 248 дена на континуирано моќ. Ние сме издавање на оваа известување за да се спречи загуба на сите AC електрични моќ, која може да доведе до со губење на контрола на авионот. 

Значи, во буквална смисла, постои некоја цел број, или некоја еквивалентна тип на податоци, се користи во софтвер во вистински авион дека ако се задржи вашиот авион доволно долго, која очигледно може да биде случај ако сте само трчање нив постојано и никогаш не го исклучувате вашиот авион, се чини, или допуштајќи батериите умре, на крајот ќе брои до и горе, и нагоре и нагоре и нагоре и нагоре. 

И, од природата, ограничен износ на меморија ќе претекување, тркалање назад кон нула или некоја негативна вредност, пропратен ефект на која е застрашувачка вистинската реалност дека авионот можеби ќе треба да се рестартира, ефикасно, или може да падне, уште полошо, како што лета. Значи, овие видови на прашања се уште со нас, even-- ова беше 2015 член, сите пострашно кога ќе не мора да се се разбере, цениме, или за предвидување овие видови на грешки. 

Значи излегува дека една друга лоша работа во врска податоци застапеност. Излезе дека дури и плови се вид на недостатоци, затоа што плови, исто така, Предложив се 32 бити, или можеби 64 ако користите двојно. Но тоа е уште конечни. 

И се фати е дека ако може да стави бесконечен број на броеви по децималната точка, не постои начин можете може да ги претставуваат сите можни броеви кои учевме во основно училиште може да постои во светот. А компјутерот, во суштина, мора да изберете подмножество од оние броеви да ги претставуваат точно. 

Сега, компјутерот може да круг можеби малку, и може да ви овозможи да се грубо продавница било кој број ви би можеле да сакаат. Но, само интуитивно, ако имаат ограничен број на битови, можете да ги permute само во многу ограничен начин. Значи, вие не може да се користи конечен број на пермутација на битови, модели на нули и единици, да ја претставува бесконечен број на броеви, што укажува на тоа дека компјутерите можат да многу добро може да лежи на нас понекогаш. 

Всушност, ајде да го направите тоа. Дозволете ми да се врати во CS50 ИРО. Дозволете ми да оди напред и да создаде мала програма наречен непрецизност, да се покаже дека компјутерите се, навистина, непрецизни. 

И дозволете ми да оди напред и да се започне со некои на кои код од порано, и сега само го направите следново. Дозволете ми да оди напред и да прават printf, проценти f, обратна коса црта n, 1 поделено со 10. Со други зборови, да се нурне подлабоко на 1/10, како и 1 поделено со 10. Навистина, компјутерот може да претставуваат 1/10. 

Па ајде да одиме напред и да направат непрецизност. Ајде да видиме. Формат одредува видот двојно. Но аргументот има int тип. Што се случува? 

О, интересни, па тоа е Лекцијата научена од порано. Сакам да кажам дека, еј, компјутерски шоу ми плови со проценти f. Но, јас сум давајќи 2 ints. Значи излегува, јас може да се поправи ова во неколку начини. 

Јас само може да се претвори еден во 1.0, и 10 во 10.0, кој, навистина, да има ефект на конвертирање нив во floats-- уште се надевам на истиот број. Или, пак, излегува дека има нешто ќе видиме повторно пред долго. Вие би можеле да го дадат на броеви. 

Можете да, со користење на овој заграда изразување, може да се каже, Еј, компјутер, земи го ова 10, што знам е int. Но, тоа лекување, ве молам, како да е се одржи. Но, тоа се чувствува непотребно комплексни. 

За нашите цели и денес, ајде да буквално точка вредности да ги направи подвижна со децимална точка, вака. Дозволете ми да оди напред и прегласувањето, бидете непрецизност, добро, точка коса црта непрецизност, влезе. Добро, ние сме во потрага добро. 

1 поделено со 10, според моето Mac тука е, всушност, 0,100000. Сега, ме учеа во основно училиште има треба да биде бесконечен број од 0 е. Значи, да се барем да се обидат за да ја видите некои од нив. Излегува дека printf е малку познавач уште не сме го користеле. Излегува вие не мора да се определи само отсто f, или само посто. Ти всушност може да се определи некои контрола опции тука. 

Поточно, јас ќе одам да се каже, еј, printf, всушност, ми покаже децимални 10 поени. Па тоа изгледа малку чудно. Но, да се каже отсто, точка, колку броеви сакате да се види по децимална точка, и тогаш f за рамен, само затоа што тоа е што вели документација. Дозволете ми да оди напред и да се спаси. 

И ќе забележите исто така, јас сум добивање на уморни прекуцување работи. Па јас сум само поставување на на стрелката надолу за клучеви тука. И ако јас удираш, вие може да се види на сите команди дека не сум направил, или неправилно. 

И јас одам да се оди напред и сега всушност, не го користат, очигледно. Направете непрецизност, точка намали imprecision-- така она што ме учеа во основно училиште проверки. Дури и ако јас го испечатите до 10 децималниот го става, навистина, е 0,10000. Но знаеш што? 

Ајде да се малку алчен. Да речеме, како, покажи ми 55 укажува по децималната. Ајде да навистина се тоа програма надвор за центрифугирање. Дозволете ми да го римејк со шминка непрецизност, точка коса црта, непрецизност. 

И тука ќе одиме. Детството е лага. Очигледно, 1 поделено со 10 е навистина 0.100000000000000005551115123-- 

Што се случува? Па, што се испоставува, ако вид на барате доволно далеку во основната застапеност на овој број, тоа, всушност, не е точно 1/10, или 0,1 и бесконечен број на нули. Сега, зошто е тоа така? 

Па, иако ова е едноставна број за нас луѓето, 1 поделено со 10, тоа е уште една од бесконечно многу броеви кои ние би можеле да смислат. Но, компјутерот може да само што претставуваат finitely толку многу броеви. И така, ефикасно, што компјутер се покажува ни е нејзиниот најблизок приближување на бројот ние сакаме да веруваме дека е 1/10, или навистина 0,10000 бескрајноста. 

Наместо тоа, иако, ова е како блиски, како што може да се добие. И, навистина, ако се погледне под капакот на моторот, како што ние сме тука со гледање 55 цифри по децималната, ние всушност ја гледаат таа реалност. Сега како настрана, ако сте некогаш сте виделе movie-- Повеќето од вас веројатно haven't-- но пред Супермен 3 неколку години, Ричард Pryor суштина балон ова реалност во неговата компанија да украде многу на фракции и ситен дел од парите, бидејќи company-- што се сеќавам, тоа е е while--, во суштина, фрлањето на нешто што не се вклопува во поимот центи. 

Но, ако ги додадете сите овие мали, мали, мали броеви повторно, и повторно, и повторно, може да, како и во неговиот случај, направи добар износ на пари. 

Истата идеја беше горат од понов, но сепак сега постари филм, наречен деловен простор, каде момци во тој филм, го направи истото, тоа зезнав целосно, заврши со премногу пари во нивната банкарска сметка. Сето тоа е многу сомнително. Но, на крајот на денот, непрецизност е насекаде околу нас. 

И тоа, исто така, може да биде застрашувачка случајот. Излегува дека Супермен 3 и деловен простор на страна, има може да има некои многу реална светот последици на реалноста на непрецизни претставување на податоците дека дури и ние, луѓето да овој ден не мора да се разбере како и што и треба, или се сеќавам толку често колку што треба. И, навистина, следниве клип е од разгледаме во некои многу реалниот свет последици од она што се случува ако не го цениме непрецизноста дека може да се случи во бројки застапеност. 

[Видео репродукција] 

-Computers, Ние сме сите доаѓаат да го прифати честопати фрустрирачки проблеми кои оди со them-- грешки, вируси, и софтвер баговите, за мали цени да плати за погодност. Но, во висока технологија и висока брзина воена и вселенска програма апликации, најмалиот проблем може да се зголемува во катастрофа. 

На 4-ти јуни 1996 година, подготвени научници да започне беспилотни Ariane 5 ракета. Тоа беше спроведувањето научни сателити дизајниран прецизно да се утврди како Магнетното поле на Земјата се поврзува со соларни ветрови. Ракетата била изградена за Европската вселенска агенција, и крена надвор од својот објект на брегот на Француска Гвајана. 

-На Околу 37 секунди во на летот, тие прво забележав дека нешто треба да се случи. Млазниците се вртење во начинот на кој тие навистина не треба. Околу 40 секунди во лет, Јасно е дека возилото е во неволја. 

И тоа е кога тие го направија одлука да го уништат. офицер за безбедност опсег, со огромна храброст, притисне копчето, разнесе ракета, пред да може да стане опасност за јавната безбедност. 

-Ова Беше девица патување на Ariane 5. И неговото уништување се место поради недостаток вградени во софтверот на ракетата. -На Проблем на Ariane беше дека има голем број што бара 64 бита за да се изразат. И тие сакаа да конвертирате тоа го бројот за 16-битна. Тие претпоставуваат дека број никогаш не се случува да биде многу голем, дека повеќето од оние бројот на цифри во 64-битна беа нули. Тие беа во право. 

-На Неспособноста на еден софтверска програма да го прифати вид на бројот генериран од уште се во коренот на неуспех. развој на софтвер стана многу скапи дел од новата технологија. На Ariane ракета биле многу успешна, па голем дел од софтверот создадени за тоа беше, исто така, кои се користат во Ariane 5. 

-На Основен проблем беше дека Ariane 5 беше побрз, забрза побрзо. И софтверот не придонеле за тоа. 

-На Уништување на ракетата Беше тоа една огромна финансиска катастрофа, сите поради грешка во минути софтвер. Но, ова не е прв податоци конверзија проблеми време учењето на современи ракетната технологија. 

-Во 1991 година, со почеток на Првата заливска војна, Патриот проектили доживеа сличен вид на проблем број реализација. И како резултат на тоа, 28 лица, 28 американски војници, беа убиени, а околу 100 ранети кога патриот, кој требаше да се заштити од влезните Scuds, не успеа да оган проектили. 

-Кога Ирак го нападна Кувајт и Америка започна Пустинска бура во почетокот на 1991 година, Патриот проектили батерии беа распоредени за заштита на Саудиска Арабија и Израел од ирачките Скад ракетни напади. Патриот е среден дострел САД површина за воздух систем, произведени од страна на компанијата Raytheon. 

-На Големината на пресретнувачи Патриот само по себе е долг околу приближно 20 стапки. И тежи околу 2.000 фунти. И тоа носи боева глава од околу, Мислам дека тоа е околу 150 фунти. И самата боева глава е висок експлозив, кој има фрагменти околу неа. На обвивка на боева глава е со цел да се однесува како buckshot. 

-На Проектили се врши четири од контејнер, и се транспортира со полу приколка. 

-На Систем Патриот анти-ракетен навраќа сега барем 20 години. Првобитно таа беше наменета како ракетна одбрана на воздухот да ги соборат непријател авиони. Во првата Заливска војна, кога таа војна дојдоа заедно, Армијата сакаше да го користите за да соборат Scuds, не авионите. 

Ирачката воздухопловните сили беше не е толку голем проблем. Меѓутоа, армијата е загрижен за Scuds. И така тие се обиделе да надградба на Патриот. 

-Intercepting Непријател проектили патуваат со брзина од Мах 5 требаше да биде предизвик доволно. Но, кога Патриот бил пренесен во употреба, Армијата не беше свесна за Ирачкиот модификација што го направија нивните Scuds речиси невозможно да се погоди. 

-Што Се случи е дека Scuds кои доаѓаат во се нестабилни. Тие се ниша. Причината за ова е Ирачаните, со цел да се добие 600 километри од 300 километар дострел, ја тежината од пред боева глава. Тие направија боева глава полесни. 

Па сега на Патриот е се обидува да дојде на Скад. И поголемиот дел од времето, Најголемиот дел од времето, тоа само ќе лета од страна на Скад. Откако операторите на системот Патриот реализира Патриот пропушти својата цел, тие детонираа боева глава Патриот е да се избегнат можните жртви, ако тоа беше дозволено да падне на земјата. 

-Тоа Е она што го видов повеќето луѓе, тие големи огнени топки на небото, и погрешно разбран како оската на Скад боеви глави. 

-Иако Во текот на ноќта небо, патриоти се појави да биде успешно уништувајќи Scuds, во Дахран, не може да има грешка за својата работа. Таму, радарски систем Патриот е губеше на дојдовен Скад, и никогаш не започна поради на софтвер мааната. Тоа беше Израелци кои за првпат се откриени дека на подолг систем беше, толку е поголема разликата време стана, се должи на часовникот вградени во компјутерот на системот. 

-About Две недели пред трагедијата во Дахран, Израелците пријавен Министерството за одбрана дека системот е губење на време. По околу осум часа или трчање, тие забележале дека системот станува значително помалку точни. Министерството за одбрана одговори кажувам на сите батерии Патриот да не остави на системи за долго време. Тие никогаш не рече дека она што долго време was-- осум часа, 10 часа, 1.000 часа. Никој не знаеше. 

-На Батерии Патриот стационирана во касарната во Дахран и нејзините недостатоци внатрешна часовникот бил на повеќе од 100 часа Во ноќта на 25-ти февруари. 

-Тоа Следи време со точност од околу една десетина од секунда. Сега, една десетина од секунда е интересен број, поради тоа што не може да се изрази во бинарен точно, што значи дека не може да се изрази точно во ниту еден модерен дигитален компјутер. Тешко е да се верува. 

Но, користете го ова како пример. Да го земеме на број еден на третото место. Една третина не може да биде изрази во децимални точно. Една третина е 0.333 случува за бесконечност. 

Не постои начин да го направите тоа со апсолутна точност во децимални. Тоа е токму оној вид на проблем што се случи во Патриот. Колку подолго системот трчаше, на полошо стана време грешка. 

-По 100 часа на работа, грешка во тоа време беше само околу една третина од секунда. Но, во однос на одржување проектили патуваат со брзина од Мах 5, тоа резултираше со следење грешка на повеќе од 600 метри. Тоа ќе биде фатална грешка за војниците за тоа што што се случи е почеток Скад беше откриени од страна на почетокот на сателити Предупредување и тие знаеја дека Скад беше кои доаѓаат во нивната општа насока. Тие не знаев од каде доаѓа. 

-Тоа Беше сега до радарот компонента на системот патриот одбрана Дахран да се лоцираат и да ја задржите пратите на дојдовен непријател проектили. 

-На Радар бил многу паметен. Тоа, всушност, ќе следи позицијата на Скад, а потоа се предвиди каде што тоа веројатно ќе биде следниот пат кога радарот испрати пулс надвор. Кој беше наречен низа портата. 

-Тогаш, Откако Патриот одлучува доволно време донесени се вратиш назад и проверете на следните локација за оваа откриен објект, се враќа назад. Па кога се вратија на ред место, тогаш не гледа објект. И тој одлучува дека не постои објект, тоа беше лажна откривање, и капки на пат. 

-На Дојдовен Скад исчезна од екранот на радар. И секунди подоцна, удри во касарната. На Скад убиени 28, а беше последниот еден отпуштен во текот на Првата заливска војна. 

За жал, ажурирани софтвер пристигна во Дахран наредниот ден. недостаток на софтвер мораше е фиксна, затворање едно поглавје во проблематичниот историјата на проектили Патриот. 

[Видео репродукција] Дејвид Џ MALAN: Значи тоа е сите да се се каже дека овие прашања од претекување и непрецизност се премногу реално. Па како не сме се нашле? Почнавме со само зборуваме за printf. Повторно, ова функција која печати нешто на екранот, и воведовме потоа неколку други функции од т.н. CS50 библиотека е. И ние ќе продолжиме да се види овие во догледно време. И ние, особено, се користат добие стринг, и да добијат int, и сега, исто така, се плови, и уште други се уште ќе се сретнуваме и да се користи пред долго. 

Но, понекогаш, има ние веќе видовме потреба за да ја запази она што рака на тие функции во грбот? Тие ни се врати стринг рака, или цел број, или плови. А понекогаш и ние треба да се стави тоа стринг, или цел број, или плови, некаде. 

И за чување на тие работи, да се потсетиме само како и во нула, имаме променливи. Но, за разлика од нула, во C имаме вистински видови на variables-- податоци видови, повеќе generally-- Меѓу нив, стринг, int, на плови, а овие другите сè уште. 

И така, кога ние се декларираат променливи во C, ние ќе мора да се декларираат нашите типови на податоци. Ова не е нешто ние ќе треба да се направи во текот на семестарот како што транзицијата на други јазици. Но, за сега, ние треба да се а приори однапред, објасни на компјутер кој тип на променлива што сакаме да ни се даде. 

Сега, пак, да се печати оние видови на типови на податоци, ние треба да се каже printf што да очекувам. И видовме проценти за жици, и проценти i за цели броеви, и неколку веќе други. И оние кои се едноставно барања за визуелна презентација на тие информации. 

И секоја од нив, всушност, може да биде parametrized или tweaked на некој начин, Ако сакате да продолжите со контрола видот на производството што ќе добиеш. И, всушност, излегува дека не само што има обратна коса црта n за нов ред. Има нешто друго вика обратна коса црта r за враќање превозот, која е повеќе слично на старата школа машина за пишување, а исто така и на Windows се користи за многу години. 

Има обратна коса црта т за јазичиња. Излегува, дека ако сакате да двојни внатрешноста на стринг, потсетиме дека ние сме се користи двојни двојно понуда на левата и на десната завршува на нашите жици досега. Тоа не е доволно за да ги мешаме работите. 

Ако сакате да се стави во двојни наводници средината на string-- и, навистина, тоа е збунувачки да се види. И така, мора да се избега, така да се каже, двојни наводници со нешто како и, буквално, обратна коса црта двојни наводници. И има неколку други се уште. И ќе видиме повеќе од тие во вистинска употреба пред долго. 

Па ајде сега се транзиција од податоци, и застапување, и аритметичките оператори, сите од кои ни даде некои зграда блокови со која треба да се игра. Но, сега ајде да всушност даде ни остатокот од речник дека ние веќе минатата недела со гребење со преземање на ум на некој друг гради во C-- не сите од нив. Но идеите сме за да се види навистина само да се нагласи превод од еден јазик, гребење, на друг, В. 

И со текот на времето, ќе ги собереш повеќе алатки за нашето раководство, така да се каже, синтаксички. И, навистина, ќе видите дека идеите сега се доста познати од минатата недела. Па ајде да го направите тоа. 

Ајде да одиме напред и да разбивам програма кои, всушност, го користи некои изрази, Булова израз. Дозволете ми да оди напред тука и да се создаде нова датотека. Ќе му се јавам оваа condition.c. 

Дозволете ми да оди напред и да вклучуваат CS50 библиотека. И дозволете ми да оди напред и да се вклучат стандард io.h за нашите функции, и printf, и повеќе, соодветно. Дозволете ми да се откаже од тоа на boilerplate int главната неважечки, чие објаснување ние ќе се врати во иднина. 

Сега дозволете ми да оди напред и да даде сметам int int добие преку. Тогаш дозволете ми да оди напред и да го направите тоа. Сакам да кажам, ако јас се less-- ајде се направи разлика помеѓу позитивни, негативни, или нула вредности. 

Значи, ако јас е помал од нула, дозволете ми да само треба оваа програма едноставно да се каже, негативни, обратна коса црта n, друго ако јас е поголем од нула. Сега сум, се разбира, да се каже printf позитивни, обратна коса црта n. А потоа друг if-- можам да го направите тоа. 

Можев да направам ако е еднаква на 0. Но, јас би се прави во најмалку една веќе грешка. Потсетиме дека знакот за еднакво е не се еднакви, како што луѓето го знаат. 

Но, тоа е оператор на задачата. И ние не сакаме да се земе 0 на право и го стави во I на левата страна. Значи за да се избегне оваа забуна, или можеби злоупотреба на знак за еднаквост, луѓето одлучи пред неколку години дека во многу програмски јазици кога сакате да се провери за еднаквост помеѓу левата и десната страна, што всушност се користи е еднаква на еднаквите. Така да удри во вредноста двапати. Кога ќе сакате да го доделите од десно на лево, ќе се користи еден ист знак. Значи ние не можеше да стори this-- друго ако јас еднакво е еднаква на нула. 

тогаш би можел да оди и отворам големи загради, и да каже, printf 0, обратна коса црта n, направено. Но, се сеќавам како овие вилиците на патот може да работи. И, навистина, само се размислува за логиката. i е број. Тоа е цел број, конкретно. А тоа значи дека нема да биде помалку од 0, или поголема од 0, или 0. Па таму е вид на оваа подразбира случај стандардните. 

И така ние би можеле, исто како и Нула, раздавам со друг, ако, да и каже на друго место. Логично, ако на програмер знам само дека има три кофи во која сценарио може fall-- првиот, втората или третата во овој case-- не мачи додавање на дополнителна прецизност и на дополнителни логика таму. Само напред со стандардно случај тука на друго место. 

Сега, ајде да одиме напред по зачувување на ова, бидете услови точка црта conditions-- не е голема кориснички интерфејс, бидејќи јас не сум се прашува корисникот, како што споменав порано. Но, тоа е во ред. Ние ќе го задржи едноставна. Ајде да се обидеме бројот 42. И тоа е позитивно. Ајде да се обидеме на бројот 42 негативни, негативни. 

Ајде да се обидеме вредноста 0. И, навистина, таа работи. Сега, ќе се види со проблеми пред долго, тестирање работи три пати, најверојатно не е доволно. Веројатно ќе сакате да пробате некои поголеми броеви, некои помали броеви, некои случаи агол, како ќе дојде да ги опише. 

Но, за сега, ова е прилично едноставна програма. И јас сум прилично сигурен, логично, дека тоа спаѓа во три случаи. И, навистина, иако ние само фокусирани на потенцијалните негативни на непрецизност и преливни, во реалност каде што многу од проблемите е CS50, ние не се случува да се грижите за, во секое време, овие прашања на преливник непрецизност, затоа што, всушност, во C, тоа всушност не е сето тоа лесно да се избегне овие работи. Ако сакате да брои до поголеми и поголеми и поголеми, излегува постојат техники може да се користат, кои честопати беа инволвирани нешта наречени библиотеки, збирки на код, други луѓе, пишува дека можете да го користите, и други јазици, како што Јава и други, всушност, се направи тоа многу полесно да се смета дури и повисока. Значи, тоа навистина е дел од овие опасности функција на јазикот кој го користите. И во следните неколку недели, ние ќе види колку опасно C навистина може да биде ако не го користите. Но, од таму, и со Python, и JavaScript, ќе ние слој на некои дополнителни заштитни мерки, и да ја стартувате помалку на тие ризици. 

Значи, да се направи малку повеќе Интересно логика во нашата програма. Значи, дозволете ми да оди напред и да се создаде програма наречена Логичка само така можам да играм со некои Крај на логика, logical.c. Јас само ќе копирате и залепите некои кодот од порано, па ќе се вратам на овој убав почетна точка. 

Дозволете ми тоа време направи знак C. сум ќе го даде името на C само затоа што е конвенционален, добие лик од корисникот. И ајде да се преправаме како Јас сум имплементација на дел на тој Rm програмата, извадете го програма пред што предизвика на корисникот за отстранување на датотека. Како можеме да го направите ова? 

Сакам да кажам, ако C е еднакво на е еднаква на, цитирам unquote, y, тогаш јас ќе одам да се претпостави што корисникот го избра да. Јас сум само се случува да се печати да. Ако тоа се всушност пишување програмата за отстранување, ние може да се отстрани датотеката со повеќе линии на код. Но, ќе биде едноставно. 

Друго, ако в еднаква еднаква n-- а сега тука, јас ќе одам да се каже, корисникот мора да значи бр. А потоа друг, знаеш што? Јас не знам што друго корисникот се случува да напишеш. Па јас сум само ќе кажам дека дека е грешка, без оглед на тој или таа, всушност, го напишале. 

Значи она што се случува овде? Постои фундаментална разлика наспроти она што го направив во минатото. Двојни наводници, двојни наводници, двојно цитати, и, сепак, единечен наводник, единечен наводник. Излезе во C, дека кога сакате да се напише низа, ќе го користат двојни наводници, исто како што сум бил со користење на сите овој пат со printf. 

Но, ако сакате да се справи со само еден лик, таканаречен знак, тогаш вие всушност Користете единечен наводник. Оние од вас кои сте програмирани пред, вие не би можеле да имаат мораше да се грижите за тоа разлика во некои јазици. Во C, тоа не е важно. И така, кога ќе се знак и сакам да се споредат знак дека користење на еднаквите еднаква на некои писмо како Y или N, јас не, навистина, треба да имаат единствена наводници. 

Сега, ајде да одиме напред и да го направите тоа. Ајде да одиме напред и да прават логички точка црта логично. И сега јас сум се известени. Па, веројатно, подобро искуство за корисниците всушност, ќе ми каже што да направите тука. Но, јас ќе одам да се само слепо y за да се каже, во ред, убаво. 

Ајде да се кандидира повторно, n за да нема, убаво. Да претпоставиме како некои луѓе што ги знам, капи мојот Lock копчето е на сите премногу често. Па јас се направи капитал Y, влезе, грешка. Добро, тоа не е точно она што јас го очекував. Всушност, на компјутерот прави буквално она што Јас реков да се провери за do-- мали y и мали n. Ова не се чувствува како добра корисник искуство, иако. Дозволете ми да побара и да се прифати или мали букви или големи букви. Значи излегува, можеби ќе сакате да се каже нешто како во нула, како буквално или C е еднакво на еднаква на капитал една цитираше y. Излегува, C нема овој буквален клучен збор или. 

Но, тоа не имаат две вертикални решетки. Мора да се одржи Shift обично, Ако сте со користење на тастатурата на САД, и хит на вертикалната лента клуч над вашиот клуч за возврат. Но, оваа вертикална лента вертикалната лента значи или. 

Ако, од друга страна, сакавме да се каже, и како и во нула, ние не можеше да стори симболот симболот. Тоа не прави никаква логика тука, бидејќи човек не би можел да го напишале и y и мали y и капитал Y како од ист карактер. Значи или е она што треба тука. 

Значи, ако го направам тоа во двете места, или в еднаква еднаква на капитал N, сега повторување, логичка, повторување логично. Сега, јас да напишете y. И можам да го направи тоа повторно со Y град или град Н. И јас може да го додадете во дополнителни комбинации уште. 

Значи ова е логичен Програмата, доколку сега Јас сум проверка логично за оваа вредност или на таа вредност. И јас не треба да се, значи, излезе со уште две ИЧС или IFS друго. Јас всушност може да се комбинираат некои од поврзани логика заедно на овој начин. Значи ова ќе биде подобро дизајниран од едноставно велејќи: ако C е еднакво мали букви y, печатење ДА, друго ако C е еднакво на капитал Y, печатење ДА, друго ако C е еднакво на lower-- со други зборови, вие не мора да се има се повеќе и повеќе гранки. Може да се комбинираат некои од еквивалент гранки логично, бидејќи на овој начин. 

Па ајде да ги разгледаме во само еден Завршно состојка, една конечна изградба, дека C дозволува. И ние ќе се вратам во иднината на другите уште. А потоа ќе се заклучи со гледање во не исправноста на code-- добивање на кодот да work-- но дизајнот на кодот, и да посадиме тоа семе на почетокот. 

Па дозволете ми да оди напред и да се отвори нова датотека. Знаеш што? Одам да повторно спроведување дека истата програма, но со користење на различни конструкција. 

Па дозволете ми да брзо си даде пристап до вклучуваат cs50.h за CS50 библиотека, стандард io.h за printf. Дај ми int главната неважечки. А потоа во текот тука, ајде ми да оди напред и да го направите тоа. 

Шар в добива се знак, како и порано. И јас одам да се користи нова конструкција now-- префрлат, на она што карактер? Значи прекинувач е вид на како префрлување на пругите. Или, пак, навистина, тоа е вид на ако на друг, ако друго, ако, но напишани малку поинаку. 

Прекинувачот изгледа вака. Мора прекинувач, а потоа она што карактер или бројот што сакате да се погледне, тогаш некои големи загради како во Нула, само велат дека прават овие работи. А потоа ќе имаат различни случаи. 

Не го користите ако и друго. Вие буквално го користи случајот на зборот. И ќе каже нешто како ова. 

Така што во случај на мали y, или, во случај на главниот Y, оди напред и да ги испечатите да. А потоа се пробие на прекинувачот. Тоа е тоа. Ние сме направиле. 

Друго, ако, така да се каже, помал случај n, или капитал N, па ќе одиме напред и печатење надвор, не, а потоа се скрши. Else-- и овој вид на е случај стандардно indeed-- printf error-- и само за добра мерка, иако логично оваа пауза не е потребно бидејќи ние сме на крајот на прекинувачот во секој случај, Јас сум сега кршење на прекинувачот. Значи ова изгледа малку поинаква. 

Но, логично, тоа е всушност еквивалентни. И зошто би го користите еден над друг? Понекогаш, само личен избор, Понекогаш естетика, ако јас поглед во оваа сега, има по нешто да се каже и за читливост на овој законик. Мислам, без оглед на фактот дека оваа код е ново за многумина од нас во собата. 

Но, тоа е само вид на убаво. Гледаш мали y, главниот град на Y, помал случај n, главниот град N стандардно, Тоа само вид на скокови на тебе на начин кои, веројатно, можеби претходниот пример со што IFS и вертикални линии, и IFS на друг, не може да има. Значи ова е навистина е прашање на личен избор, навистина, или читливост, на кодот. 

Но, во однос на функционалноста, дозволете ми да оди напред и да се направи еден гајтан, точка коса црта прекинувач, а сега пишувате со мали букви y, капитал Y, мали n, главниот град на N, Давид, обидете се повторно, бидејќи тоа е не еден лик. Ајде да направите X, грешка, како што се очекуваше. И, logically-- и ова е нешто Јас ќе ги охрабри во general-- дури иако ние сме само гребење на површината на некои од овие карактеристики. 

И тоа не може да биде очигледна кога ќе се си седнат на тастатура, Како го прави ова дело? Што ова би го направил? Позицијата на работа за да има лаптоп или десктоп, или пристап до компјутер со компајлер, и со код едитор како овој, е речиси може да се секогаш да одговори на овие прашања за себе само со обидот. 

На пример, ако реторички прашање во рака беа, што ќе се случи ако заборавите вашиот одмор изјави? Кој е всушност многу честа работа да се направи, поради тоа што не изгледа како навистина им треба. Тие навистина не ја заврши својата мислев како заграда или кадрава голема заграда го прави тоа. Ајде да одиме напред и прекомпајлирате код и да видиме. Така бидете прекинувач, прекинувачот точка коса црта. Ајде да пишувате со мали букви y, на врвот случај, Enter. Па јас ја внеле y. 

Програмата рече да, не, грешка, како и покрај тоа се менуваше својот ум. Но, тоа беше вид, бидејќи она што се случува со прекинувач е прв случај во кој натпревар во основа значи, еј компјутер, изврши сите го кодот под него. И ако не се каже пауза, или не се каже пауза, или не се каже пауза, компјутерот ќе удар преку сите оние линии и извршување на сите од нив, додека таа добива дека кадрава голема заграда. Значи сопирачките се, навистина, е потребно. Но, готова брза тука е, кога двоумите, обидете се нешто. Можеби го спаси вашиот код, прво, или да го зачувате во дополнителен датотека ако сте навистина загрижени за Месинг и ја да се опорави работата што знаете е работа. 

Но, обидете се работи. И не бидете како страв, можеби, на она што може да се направи на компјутерот, или дека може да се скрши нешто. Секогаш можете да се вратите назад на некои претходната верзија. 

Значи, да се заврши со гледање на дизајнот на код. Имаме оваа можност сега да се напише услови и запишување петелки, и променливи и функции повик. Па, искрено, ние сме вид на назад во каде што бевме пред една недела со нула, иако со текстуална помалку привлечни животната средина од гребење дозволува. 

Но забележите колку брзо се стекнавме дека речник, дури и ако тоа е случува да се земе малку време да потоне, така што сега можеме да го користиме овој речник да се напише повеќе интересни програми. И ајде да чекор бебе кон тоа, како што следи. Дозволете ми да оди напред и да се создаде нова датотека. 

Јас ќе одам да се јавите на оваа prototype.c, и да се воведе за прв пат, способноста за да направите свој функции. Некои од вас може да има направено со нула, при што може да се создаде сопствени блокови во нула, а потоа повлечете ги во место каде и да сакате во В. И во повеќето програмирање јазици, можете да го направите токму that-- направите свој функции, ако тие не се веќе постои. 

Така, на пример, дозволете ми да оди напред и вклучуваат cs50.h, и вклучуваат стандард io.h, int главната неважечки. И сега имаме случаеви подготвени да одите. Продолжувам печатење работи како и имињата на луѓето денес. И дека се чувствува like-- не би било убаво ако има беа на функција наречена име печати? Јас не треба да ги користите printf. Јас не треба да се запамети сите кодови формат. Зошто не јас, или зошто не некој пред мене, создаде функција наречена печатење име, со оглед на некои име, едноставно отпечатоци? 

Со други зборови, ако кажам, еј, компјутер, ми даде една низа со поставување на корисникот за такви, преку добие низа функција е CS50. Еј, компјутер, стави тоа во низа променливата на левата страна, и повик е тоа. И тогаш, еј компјутер, да оди напред и печати дека името на лицето, направи. 

Сега, тоа би било убаво, бидејќи оваа програма, наречена, ми кажува она што би требало да се направи по пат на имињата на оние функцијата. Дозволете ми да оди и да се направи прототип, Enter. И, за жал, ова не се случува да лета. 

Prototype.c алинеја 7, карактер 5, грешка, имплицитни декларација на име на функција за печатење не е валиден во C99, C99 што значи верзија на C кој излезе во 1999 година. Тоа е се. 

Па јас не знам што значи сето ова уште. Но, јас не се признае грешка во црвено. Тоа е доста очигледно. 

И се чини дека со зелените карактер тука, прашањето е со името на печатење, отворен заграда е, блиску заграда, точка-запирка. Но имплицитна изјава за функција видовме накратко порано. Ова значи дека, едноставно, дека ѕвекот не се знае на што мислам. 

Јас сум користел речник збор дека тоа е никогаш не видел или се изучува пред. И така јас треба да го учат што значи оваа функција. Па јас ќе одам да се оди напред и да го направи тоа. 

Одам да се оди напред и да се спроведе мојата функција наречена печатење име. И јас одам да се каже, како што следува, дека тоа го прави ова, printf, здраво, проценти ОК, обратна коса црта n, име, точка-запирка. Значи она што јас само го направи? 

Значи излегува, да се спроведе своја функција, ние вид на позајмуваат некои од истата структура како главен дека ние само се зема здраво за готово, и јас знаете само копирање и вметнување доста тоа што Сум бил пишување во минатото. Но забележите шема тука. Int, главно, празнина, ние ќе ги разграничат пред долго што тој всушност значи. 

Но, за денес, само забележи на паралелизам. Празнина, името на печатење, Име на стринг, па постои пурпурна клучни зборови, кои ние се случува да започне повикувајќи еден вид враќање, името на функцијата, а потоа за внесување. Така, всушност, може да се дестилираат овој вид на како и минатата недела како, ова е името или алгоритам од кодот сме ќе write-- на алгоритам основните кодот ние ќе треба да се напише. 

Ова е нејзиниот влез. Ова е производството. Оваа функција, име печатење, е дизајниран да се низа наречен име, или што, како влез, а потоа и неважечки. Тоа не се врати ништо, како да стринг или се int го прави тоа. Така што ќе ме предаде нешто назад. Тоа е само случува да имаат несакани ефекти, така да се каже, на печатење име на една личност. Значи забележите, алинеја 7, јас да се јавите на името на печатачот. Линија 10, јас може да се дефинира или спроведување на името на печатачот. Но, за жал, тоа не е доволно. 

Дозволете ми да оди напред и да прекомпајлирате ова по спасување. Леле, сега, јас сум го направи уште полошо, тоа ќе изгледа. Значи имплицитна изјава за името на функцијата за печатење не е валиден. И, повторно, има повеќе грешки. Но, како што предупреди порано, дури и ако се преоптовари со, или малку тажно да се види толку многу грешки, да се фокусираат само на првата на почетокот, бидејќи тоа само може да имале каскаден ефект. Значи C, или ѕвекот поконкретно, уште не го признава името на печатачот. 

И тоа е затоа ѕвекот, од страна на дизајнот, е вид на нем. Тоа само го прави она што ќе го каже да го стори. И тоа не само тоа во ред во кој ќе го каже да го стори. 

Значи имам дефинирано главната линија на четири, како ние сме биле прави доста често. Сум дефинирано име за печатење на линија 10. Но јас се обидувам да се користи Име на печатење на линија седум. 

Тоа е прерано, сè уште не постои. Па јас би можел да биде умен, и да биде како, Добро, па ајде да играат заедно, и да се движат име на печатење до тука, и повторно да се состави. О Боже. Успеа. Тоа е толку едноставно како што. 

Но, логиката е токму тоа. Мора да ги учат ѕвекот што е со дефинирање на функција во прв план. Потоа можете да го користите. Но, искрено, тоа се чувствува како лизгава патека. 

Па секој пат кога ќе ја стартувате во проблем, јас сум само сакал да нагласам и ископирајте го кодот Јас го напишав, го намали и ставете го тука. И, секако, би можеле да смогвам некои сценарија каде што една функција може треба да се јавите на друг. И едноставно не може да се стави секој функција над секој друг. 

Значи излегува дека е подобро решение. Ние може да го оставите да биде. И, искрено, тоа е обично убаво, и лесен, и добриот дизајн да се стави главен прво, затоа што, повторно, Главната исто како кога зелено знаме кликнато, тоа е функција која добива извршена од стандардните. Така што би можело да се стави тоа на врвот на датотеката така што кога ќе или било други човечки гледа во датотека знаете што се случува само со читање на главната прв план. Значи излегува, може да се каже ѕвекот проактивно, еј, ѕвекот, on-line четири, Јас ветувам дека ќе се спроведе функција наречена печатење Име која се низа наречен име како влез, и се враќа ништо, празнина. И јас ќе добие околу да се спроведување на тоа подоцна. 

Еве доаѓа Мајна. Главната сега на линија 9 може да се користи Верзија за името, бидејќи ѕвекот е верувајќи дека, на крајот, тоа ќе се сретне со дефиниција на спроведувањето на печатење име. Па по заштеда на мојата датотека, да ми да оди напред и да се направи прототип, изгледа добро тоа време. Dot црта, прототип, дозволете ми да оди напред и да напишете име. Дејвид, здраво Давид, Zamila, здраво Zamila, и, навистина, сега таа работи. 

Значи состојка е дека ние сме направени обичај функција, како и сопствен Нула блок ние сме го повикува. Но, за разлика од гребење каде што можете да само да го создаде и да почнете да го користите, ние сега треба да биде малку повеќе педантни, а всушност се обучуваат ѕвекот да се користи, или да го очекував. Сега, како настрана, зошто сето ова време да има сме биле само слепо на верата, вклучувајќи Cs50.h, вклучувајќи стандардни io.h? 

Па, што се испоставува, меѓу неколку други работи, сето она што е во тие точки h датотеки, кои се случи да биде на датотеки. Тие насловот датотеки, така да се каже. Тие се уште се напишани во C. Но, тие се друг тип на датотека. 

За сега, доста може да се претпостави дека сето она што е во внатрешноста на cs50.h е некој една облоги, како таков, не за функции се нарекува печатење име, но за се стрингови, Добиј Плови, и уште неколку други. И таму се слични прототипови, еден облоги, во внатрешноста на стандард io.h за printf, кој сега е во мојата функција за печатење име. Значи со други зборови, целото ова време ние сме само се слепо копирање и вметнување вклучуваат овој, вклучуваат дека, што се случува? Тоа се само вид на индиции да ѕвекот за тоа што функции се, навистина, имплементирани, само на друго место во различни фајлови На друго место на системот. 

Значи ние сме спроведува име печатење. Тоа го прави да овој несакан ефект на печатење нешто на екранот. Но, тоа не се случи, всушност, рака ме нешто назад. Како да одиме за спроведување на програма со која не ме предаде нешто назад? 

Па, ајде да се обидеме ова. Дозволете ми да оди напред и да се спроведе датотека наречена return.c така што може да се покаже како нешто како Добие Стринг, или да се int, е всушност враќање нешто назад до корисникот. Ајде да одиме напред и да ги дефинира int главната неважечки. 

И, повторно, во иднина, ние ќе се објасни она што int и таа празнина е всушност прави. Но, за денес, ние ќе го земам здраво за готово. Одам да се оди напред и да printf, за добар корисник искуство, x е. И тогаш јас ќе одам да се чека за корисникот да ми даде x со стапите Инт. 

И тогаш јас ќе одам да се оди напред и да ги испечатите x на плоштадот. Значи, кога имаш само една тастатура, луѓето најчесто се употреба на малку морков симбол на тастатурата да ги претставуваат на моќта , или за експонент. Значи x квадрат е присутен i. 

И сега јас ќе одам да го направите тоа. Јас само може да do-- што е х на квадрат? х квадрат е x x пати. 

И ние го направи ова некои одамна веќе денес. Ова не се чувствува како сите дека многу напредок. Знаеш што? Ајде да се потпора на некои од таа идеја од последниот пат на апстракција. 

Зарем не би било убаво ако има функција наречена плоштадот што го прави токму тоа? Се уште е, на крајот на ден, истото го прави математика. Но, ајде да апстрактни далеку од идејата за преземање еден број се множи со друг, и само да го даде име, како плоштад на таа вредност. 

И, со други зборови, Ц, ајде да се создаде функција наречен плоштадот што го прави токму тоа. Тоа се случува да се нарече плоштад. Тоа се случува да се земе Инт. И ние ќе сака да го нарекуваат n, по дифолт. 

Но, ние може да се нарече нешто што сакаме. И сето тоа се случува да се направи, буквално, е враќање и резултат од n n пати. Но, бидејќи тоа е враќање на нешто што е клучниот збор во пурпурна имаме никогаш не видел, јас, на линија 11, не може само да се каже празнина тоа време. 

Празнина, во примерот кој го видоа а од името на печатење, само значи, направи нешто. Но, не ми рака нешто назад. Во овој случај, јас сакам да се врати n пати n, или што и да е, тој број. 

Така што не може да се каже, еј, компјутер, Се враќам ништо, празнина. Тоа се случува да се врати, по природа, int. И така тоа е се што се случува овде. 

За внесување на плоштад ќе биде int. И, така што можеме да го употребиме, мора да да има име, Н. Тоа се случува да излез на int, тоа не треба име. Ние можеме да го оставиме тоа за главната, или кој и да е користење на мене да се запамети оваа вредност, ако ние сакаат со свои променлива. 

И, повторно, единственото ново Клучниот збор тука е пријава. И јас сум само ќе го направите некои математика. Ако навистина сака да биде непотребно, Можам да кажам int производот добива n пати n. 

И тогаш јас може да се каже, да се вратите производот. Но, повторно, до мојата поента на почетокот на ова едноставно не се добри design-- како, зошто се воведе име, симбол, како производ, само за да веднаш да се врати? Тоа е малку почиста, малку построги, па да се каже, само да се каже враќање n пати n, да се ослободи од оваа линија заедно. 

И тоа е само помалку код да чита, помалку можност за грешки. И ајде да видиме дали ова всушност, сега работи. Сега, јас ќе одам да си напред и да се вратат. 

Ух-ах, имплицитна изјава на функцијата. Не сум направил оваа грешка пред да, не е голема работа. Дозволете ми да пишувате или да се потенцира и копирате, на иста функција прототип, или потпис, на функцијата тука. Или би можел да се движи целиот функција. 

Но, тоа е малку мрзливи. Значи, ние нема да го стори тоа. Сега, дозволете ми да се врати повторно, точка коса црта враќање. 

x е квадрат 2 x е 4. x е квадрат 3 x е 9. И функцијата чини сега треба да се работи. Значи она што е разликата тука? Имам функција што се вика плоштад, во овој случај, што го стави во влез. И ќе се вратам излез. А сепак, претходно, ако Кога ќе го отворите друг пример од порано, што беше наречен prototype.c, Имав име печати, што врати празен, така да се каже, Или да го врати ништо, и едноставно имаше ефект. 

Значи она што се случува овде? Па, размислете за функцијата се низа за само еден миг. Ние сме биле со користење на функцијата се низа на следниот начин. 

Имавме функција се стринг, како вклучуваат cs50.h, вклучуваат стандардни io.h, int, главно, неважечки. И тогаш секој пат кога сум наречен добие низа досега, Сум рече нешто како: Стринг а добива се стринг, бидејќи добие string-- ајде да се јавите на оваа get.c-- добие низа се враќа стринг што можам потоа користење, и да каже здраво, запирка, проценти s, обратна коса црта n, с. 

Значи ова е истиот пример, навистина, дека сме имале претходно. Па се враќа стринг вредност. Но пред еден миг, печати низа не се врати вредност. Тоа едноставно има несакани ефекти. Значи ова е фундаментална разлика. Видовме различни видови на функции сега, од кои некои се вратија вредности, од кои некои не. Па можеби тоа е стринг, или цел број, или плови. Или можеби тоа е само празнина. 

И разликата е дека овие функции кои добијат податоци и се врати на вредност, всушност, носат нешто назад кон масата, така да се каже. Па ајде да одиме напред и да погледне во едно последниот сет примери кои ја дава чувство, сега, како да, навистина, апстрактен подобро, и подобро и подобро, или повеќе, и повеќе, и повеќе, со цел да се напише, во крајна линија, подобро код. Ајде да одиме напред, а во духот на нула, го направите следново. 

Дозволете ми да оди напред и да се вклучат Cs50.h и стандардни IO.h. Дозволете ми да оди напред и да даде си int, главно, неважечки. И дозволете ми да оди напред, ова го нарекуваат cough.c. 

И дозволете ми да оди напред и само како гребење, печатење кашлица / n. И јас сакам да го направите тоа три пати. Затоа, јас сум, се разбира, само ќе да копирате и залепите три пати. Јас сум сега се случува да се направи кашлица точка коса црта кашлица. Ајде да си даде малку повеќе простор тука, Enter, кашлица, кашлица, кашлица. 

Има, очигледно, веќе можност за подобрување. Јас копирани и атипичен неколку пати денес. Но тоа беше само тоа, јас не треба да напишете што повеќе ликови. Јас се уште смени оние линии на код се. 

Овие три линии се идентични, која се чувствува мрзливи и навистина е, а веројатно и не е вистинскиот пристап. Така е и со она што состојка би можеле да се подобри овој код? Ние не треба да го копирате и залепите кодот. 

И, навистина, во секое време да се чувствувате себе копирање и вметнување, па дури и не се менува кодот, шансите се има подобар начин. И, навистина, постои. Дозволете ми да оди напред и да се направи за телефонска линија, иако синтаксата, можеби и не дојде природно уште. 

Направете го ова три пати, едноставно со правење на following-- и јас се случи да знам од пракса. Но, ние имаме голем број на примери сега. И ќе видите на интернет повеќе референци уште. 

Ова е синтакса на алинеја 6, која слично како гребење што се повторува блок, се повторува три пати. Тоа е малку магичен за сега. Но, ова ќе добиете повеќе, и повеќе познати. 

И тоа се случува да се повторува линија осум три пати, така што ако јас повторно компајлирајте направи кашлица, точка црта кашлица, кашлица, кашлица, кашлица. Таа се уште работи на истиот начин. Па тоа е во ред и добро. Но тоа не е многу апстрактни. 

Тоа е совршено точни. Но тоа се чувствува како да има може да биде можност, како во светот на Нула, да се вид на почеток за да додадете некои семантика тука, така што Не само што има некои за телефонска линија, и функцијата за која се вели кашлица, или не се плаќа. Знаеш што? Дозволете ми да се обиде да биде малку поладна од тоа, и всушност пишува функција која има некои несакани ефекти, го нарекуваат кашлица. 

И тоа не презема влез, и се враќа нема вредност како излез. Но, знаете што го прави тоа? Тоа го прави this-- printf, цитат unquote, кашлица. 

И сега тука, јас ќе одам да се оди напред и за int, i добива нула, јас помалку од 3, јас плус плус. Одам да не printf, што е веројатно спроведување на ниско ниво детали. Не ми е гајле колку да кашла. Јас само сакам да ја користите функцијата за кашлица. И јас сум само ќе се јавите кашлица. 

Сега, забележуваат дихотомија. Кога ќе се јавите на функција, ако не сакате да го даде влезови, сосема во ред. Едноставно направете отворена заграда, во близина заграда, и ќе завршиш. 

Кога ќе се дефинира функција, или прогласи прототип на функцијата, ако се знае однапред дека не е ќе се преземат сите аргументи, велат празнина во овие загради таму. И тоа го прави сигурни дека ќе не случајно ќе ја злоупотребат. Дозволете ми да оди напред и да кашлица. И, се разбира, јас сум направил грешка. 

Мајката, тука е дека имплицитна изјава. Но, тоа е во ред. Тоа е лесен фикс. Јас само треба прототип повисоко во моето досие отколку што сум, всушност, го користи. 

Па сега дозволете ми да кашлица, повторно, убаво. Сега, таа работи. Направете кашлица, кашлица, кашлица, кашлица. Така што може да мислам дека ние сме навистина само во текот на инженеринг овој проблем. И, навистина, ние сме. Ова не е добра кандидат на програмата во моментот за refactoring, и прави она што е се нарекува хиерархиска распаѓање, каде што се дел од кодот, а потоа можете вид на факторот на работите, така што да им ја припишуваме повеќе семантиката на нив, и повторна употреба на крајот подолг рок. Но, тоа е градење на блок кон повеќе софистицирани програми дека ние ќе започнеме писмена форма пред долго што ни овозможува да имаме вокабуларот со што да пишувам подобро код. И, навистина, ајде да видиме дали можеме не може да се генерализира овој понатаму. 

Се чини дека е малку несмасен дека, главно, треба да се грижите за тоа ебам за телефонска линија, и повикувајќи кашлица повторно и повторно. Зошто не можам да кажам само кашлица, Ве молиме да се плаќа три пати? Со други зборови, зошто да не можам само даде свој придонес да кашла и да го направите ова? 

Зошто не можам да кажам, во главната кашлица три пати. И сега, ова е вид на магично. Тоа е многу итеративен тука. И тоа е, навистина, чекор бебе. 

Но, само способноста да се каже на линија осум, кашлица три пати, тоа е само многу повеќе може да се чита. И, плус, јас не треба да се знае или грижа како се спроведува кашлица. И, навистина, подоцна во текот на рок и за конечниот проекти, ако се справи со проектот со соученик или двајца соученици, ќе сфатите дека ви се случува да треба, или сакате да, се подели на работа. 

И ви се случува да сакаат да се одлучи однапред, кој се случува да се направи она што, и во кои парчиња? И не би било убаво ако, на пример, да преземе одговорност за пишување главната, направено. И вашиот цимер, или вашиот партнер поопшто, се грижи за спроведување на кашлица. 

И оваа поделба, овие ѕидовите на апстракција, или слоеви на апстракција ако ќе ви се супер моќен, затоа што особено за поголеми, повеќе комплексни програми и системи, тоа им овозможува на повеќе луѓе да се изгради работи заедно, и во крајна линија бод нивната работа заедно на овој начин. Но, се разбира, ние сега треба да се поправи кашлица. Ние треба да се каже кашлица дека, еј, знаеш што? Ви се случува да треба да се земе input-- па не празнина, но int и сега. Ајде да одиме напред и да се стави во кашлица Инт. i добива нула. 

i е помал од колку пати. Реков пред три. Но, тоа не е она што го сакате. Сакам да се плаќа да се генерализира поддршка на било кој број на повторувања. 

Значи, навистина, тоа е n што сакам, без оглед на корисник ми кажува. Сега, јас може да оди напред и да каже печатење кашлица. И без оглед на тоа што бројот корисникот поминува, Јас ќе iterate дека многу пати. 

Па на крајот на денот, програма е идентичен. Но забележите сите овие работи па дури и може да биде во друга датотека. Всушност, јас не знам на момент како printf се спроведува. 

Не знам во овој момент како да се стринг, или да се int, или да се плови се спроведуваат. И јас не сакам да ги видите на мојот екран. Како и да е, јас сум почнуваат да се фокусираат на мојата програма, а не оние функции. 

И така, навистина, штом ќе се започне факторинг код како ова, дури и да се движиме кашлица на посебна датотека? Некој друг може да се имплементира. И вие и вашата програма да стане многу убава, и многу може да се чита, веројатно, навистина четири лајн програма во право таму. 

Па ајде да одиме напред сега и да се направи уште една промена. Забележете дека моите прототип мора да се промени до врвот. Значи, дозволете ми да го надминете тоа така Јас не се викна. 

Направете кашлица, дозволете ми да се кандидира откако кашлица повеќе, се уште го прават истото. Но, сега, да се забележи имаме состојка за една конечна верзија. Знаеш што? Не сакам да се плаќа само, е задолжително. Сакам да има нешто повеќе воопшто. Па да знаете што? Сакам да го направите тоа. Сакам да имам, многу сличен на гребење не, на пример блокот, но не само каже нешто одреден број на пати. Сакам да кажам многу специфична низа. И, затоа, јас не сакате да речеме кашлица. Сакам да се каже она што стринг е проследена во. 

Значи забележите, јас сум се генерализира ова, така што сега да речеме се чувствува како добра името за ова, како нула, зема два аргументи, за разлика од гребење. Една од нив е стринг. Една од нив е int. 

И би можел да ги префрлат. Јас само вид на се допаѓа идејата на велат дека низа, а потоа колку пати подоцна. Празнината што значи дека се уште не се врати ништо. Овие се само визуелната страна ефекти, како и со [? Јордан?] вербален пропратен ефект на врескаше. Тоа, сепак, не нешто n пати, 0 до, но не е еднаква на n. Ова значи n Вкупно пати. А потоа само се печати што и да е низа. Па јас сум навистина се генерализира оваа линија код. Па сега, како можам да се спроведе функцијата за кашлица? 

Што можам да направам празнина кашлица. И јас се уште може да се земе во колку колку пати сакате да кашла. Но знаеш што? сега можам да залог да се каже. 

Јас може да се јавите каже со зборот кашлица, поминува во n. И ако сакам исто така да се спроведе, само за забава, функција кивавица, Можам да кивнете, неколку број на пати. И можам да го задржи повторната употреба на n, бидејќи се забележи дека метри во овој контекст и обемот постои само во рамките на оваа функција. 

И n во овој контекст само постои во рамките на оваа функција овде. Па ние ќе се вратам на овие прашања од опсегот. И тука, јас сум само се случува да се каже, achoo, а потоа n пати, точка-запирка. 

И сега, јас само треба да позајмите овие функција потписи до тука. Значи кашлица е точно. Празнина кивањето е точно сега. 

И јас се уште само треба да се каже. Па јас ќе одам да се каже, да речеме Стринг а, int n, точка-запирка. Па јас сум над-Инженерните подлец од оваа програма. 

И ова не се мора да значи дека тоа е што треба да направите кога пишувате дури и наједноставните програми. Се земе нешто што е очигледно навистина едноставно, навистина краток, и повторно да се имплементира користење на премногу код. Но, всушност ќе се види, и во време да се погледне назад на овие примери, и реализација, ох, оние кои се чекорите ние почнавме да всушност се генерализира, да се земат нешто, додека на крајот на денот мојот код е всушност прилично разумна. Затоа што ако сакам да кашла три пати, тогаш кивавица три пати, Јас сум едноставно ќе се повторување ова, Програмата се кашлица, и да ја стартувате кашлица. И јас имам три кашлање и три кивање. 

И така ова е основен парадигма, ако сакате, за како да се обратите за всушност спроведување на програмата. Но, ајде да видиме сега што е тоа ние сме прави сето ова време, и она што некои од конечната парчиња стојат зад ова едноставна команда. На крајот на денот, ние сме е користење ѕвекот како што е нашата компајлерот. Ние сме биле пишување на код код, конвертирање на тоа преку ѕвекот во машински код. 

И ние сме биле користење се направи само да се олесни нашата тастатурата, така дека ние не треба да се запамети оние баењата на самата ѕвекот. Но, она што е да се направи, всушност, се прави? И, за возврат, што е Ѕвекот, всушност, се прави? 

Излегува, иако имаат поедноставен денешната дискусија со зборовите: ќе се земе изворниот код, да го давате како влез на компајлерот, кој ви дава производството на машина код, се испоставува дека има неколку различни чекори во таму. И составувањето се случува да биде чадор термин за еден куп на чекори. Но, ајде да се закачам ова навистина брзо. 

Излегува дека ние сме прави повеќе работи секој пат кога ќе ја стартувате програмата, или секој пат кога ќе се состави програма за денес. Значи препроцесирачка се однесува на this-- ништо во програмата C, како што ќе видиме повторно и повторно, која започнува со овој хаш симбол, или симбол хаштагот тука, значи тоа е директива препроцесори. Тоа значи дека, во овој случај, еј компјутер, направи нешто со оваа датотека, пред навистина да сте ги собере мојот код. 

Во овој случај, хаш вклучуваат применува, Во суштина, начин на велејќи Ц, еј компјутер, одам да купам содржината на cs50.h и ставете ги тука. Еј компјутер, одам да купам содржината на стандардни io.h, каде што е на хард диск, ставете го тука. Значи оние работи се случуваат првиот за време препроцесирачка. 

И ѕвекот го прави сето ова за нас. И тоа го прави толку ебам брзо, дури и не види четири различни работи што се случуваат. Но, тоа е прв ваков чекор. 

Што всушност се случува следно? Па, следниот официјален чекор е составувањето. И излегува дека составувањето на програмата технички средства одат од изворен код, работи кои ги имаме пишува денес, на нешто свиканото собрание код, нешто што изгледа малку различен. 

И, всушност, може да се види овој вистински пост. Дозволете ми да се, всушност, оди во мојата ИРО. Дозволете ми да оди напред и отворен hello.c, која е прв програма со која се започна денес. И дозволете ми да оди напред и да се кандидира ѕвекот на малку поинаку, ѕвекот-и, hello.c, што е, всушност, ќе се дај ми друга датотека hello.s. 

А ние веројатно никогаш нема да еднаш да се види овој вид на код. Ако се земе на пониско ниво системи класа како CS61, ќе видите многу повеќе на овој вид на код. Но, ова е асемблер јазикот. Ова е x86 собранието јазик дека процесорот кој е во основата CS50 IDE, всушност, го разбира. 

И криптичната како го прави тоа изгледа, тоа е нешто компјутерот разбира многу добро. Под q, ова е одземање. Има движења. 

Има повикувајќи функции тука, x oring, движење, додаток, поп, враќање. Значи има некои многу инструкции ниско ниво дека процесори се разбере дека Јас се алудира погоре. Тоа е она што Intel Inside. 

Постојат модели на нули и оние кои карта на овие arcanely формулирани, но нешто добро име, упатства, така да се каже. Тоа е она што се случува кога ќе компајлирате вашиот код. Можете да добиете собранието јазик надвор од неа, кое значи третиот чекор е да се соберат дека собранието код во крајна линија, машина code-- нули и единици, а не на текст кој ние само видов пред еден миг. 

Значи пред-обработка, дали тоа да и да ја замени, како и неколку други работи. Компајлирање зема вашиот извор код од C, изворниот код кои ги напишал, до собранието код кој ние само го погледна. Монтажа зема дека собранието кодот на нули и оние дека процесорот навистина ќе се разбере на крајот на денот. И поврзување е последниот чекор Тоа се случува us-- повторно, толку брзо ние дури и не notice-- која се вели: еј компјутер, да ги преземе сите нули и оние кои произлезе од составувањето код Давид, и неговата главна функција во овој случај. 

И еј компјутер, одам да купам сите нули и единици дека вработените CS50 пишува во CS50 библиотека. Се меша оние со Давид. И еј компјутер, одам да купам сите нули и оние кои на некој друг напишал години пред за printf. И да додадете оние во целата работа, така што ние сме добив нули и оние, нули и персонал CS50, нули на printf и оние, и се друго што го користите. 

Сите тие се комбинираат заедно во една програма наречена, во овој случај, здраво. Па сега па натаму, ние само ќе го користат зборот составувањето. И ние ќе се земе здраво за готово дека кога ние велиме, состави својата програма, тоа значи, еј направи пред-обработка, монтажа и поврзување. Но, таму е всушност некои сочни работи се случува таму под хауба. А особено ако се љубопитни за некое време, можете да почнете ѕиркаа околу во овој пониско ниво. Но, за сега, да сфатат дека меѓу takeaways за денес се доста едноставно почеток на еден процес, за добивање удобно со нешто како Здраво светот. Всушност, повеќето од она што ние го направивме денес сигурно нема да потоне во супер брзо. И тоа ќе биде потребно извесно време, и некои пракса. И шансите се, ќе се најде решение на сакаат да се погоди вашиот тастатура или се развикам на екранот. И сето тоа е во ред. Иако, можеби, не се обидуваат да го направи тоа во библиотеката толку многу. 

И на крајот, ќе иако се во можност, да се започне гледајќи модели, и во добар код дека сте го напишале и грешки што сте ги направиле. И многу сличен на процесот на станува ТФ или CA е како, ќе започне да се подобри и подобро да види овие модели, и само решавање на вашите сопствените проблеми на крајот. Во меѓувреме, ќе има многу од нас да ја дадат да ви помогне, и ќе добиете преку ова. И во пишуваат прозорци за сите проблеми ќе ви бидат водени преку сите команди дека јас сигурно знам од многу пракса до сега, но може да се вее над глава за сега. И тоа е сосема во ред. 

Но, на крајот, си оди за да започнете да гледате шеми се појават. И штом еднаш ќе добиете минатото сите глупави детали, како загради, и големи загради, и полу-запирки, и работи, искрено, дека не е на сите интелектуално интересно. И тоа не е целта на преземање на какви било воведен класа. Тоа е на идеи што се случува е важно. 

Тоа е петелките, и услови, како и функции, и уште посилна на апстракција, и факторингот на код, и добриот дизајн и добрата стил, и на крајот на исправноста на вашиот код, тоа е на крајот ќе се најважни. Значи следната недела ќе ги преземат овие идеи кои ние прв пат го виде во Скреч а сега се преведени до В И ние ќе започнеме да се воведе првиот од реалниот свет домени курсот. 

Ќе се фокусира на светот на безбедноста, и поконкретно криптографијата, уметноста на scrambling информации. А меѓу првите проблеми ќе се ќе добиете за да се напише надвор играјќи си со некои од синтаксата и решавање на некои логички проблеми, во крајна линија пред долго време, е всушност да се трка, или шифрирање, и на крајот да ја декриптира информации. И се што сме го направиле денес, прилично ќе ниско ниво, е само ќе се овозможи нас да се земе еден, и еден, и уште еден чекор над кон пишување најинтересните код уште. 

Значи повеќе за тоа следната недела. 

[Видео репродукција] 

-Што Може да ми кажете за последен пат сте го виделе? -Што Да кажам, навистина? Мислам, тоа беше како и секој друг пред-продукција проба, освен дека има нешто што рече На самиот крај што заглавив со мене. 

'Ова е CS50. 

-Тоа Е намалување на сите, одлична работа на проба. 

ручек -Тоа е? 

-Да, И јас може да зграби еден сендвич во малку. Дозволете ми само со debrief Дејвид навистина брзо. Давид? Давид? 

[END репродукција] 