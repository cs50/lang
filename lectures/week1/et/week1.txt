[MUSIC MÄNGIB] DAVID J. Humala: Olgu, see on CS50. Ja see on nädal üks. Nii meenutada, et viimast korda nädalas null, keskendusime arvutuslikke mõtlemist. Ja me siirdatud sellest, et Scratch, graafiline programmeerimine keel meie sõbrad MIT Media Lab. 

Ja Scratch, kas me uurida ideed nagu funktsioonid ja tingimused, ja silmad, ja muutujad, ja isegi sündmusi ja teemasid, ja rohkem. Ja täna me ei kavatse jätkata nende ideede ja tõesti, võttes neid antud, kuid neid tõlkida teise keele tuntakse C. Nüüd C on traditsioonilise keeles. See on madalamal tasemel keeles, kui soovite. 

See on puhtalt tekstiline. Ja nii esmapilgul, et see on kõik läheb otsima pigem segasena Kui olete kunagi programmeeritud enne. Me läheme on semikoolonite ja sulgudes ja looksulg ja rohkem. Aga aru, et isegi kuigi süntaks umbes vaadata veidi harjumatu et enamik teist, vaata varem, et. Ja proovida, et näha ideed mis on tõepoolest tuttav, sest siin nädalal üks, mida hakkame tegema, on võrrelda, Esialgu Scratch versus C. 

Nii näiteks meelde tuletada, et kui me rakendas esimest Meie programmid Viimane kord oli meil plokk, mis nägi natuke midagi see-- kui roheline lipp klõpsatud, siis oli meil ühe või mitme puzzle tükki all, sel juhul öelda, tere. Niisiis, tõepoolest, Scratch, kui ma vajutan, et roheline lipp käivitada oma programmi, nii et rääkida, need on plokid, mis saavad täidetud, või joosta. Ja konkreetselt Scratch ütles tere, maailmas. 

Nüüd ma oleks võinud täpsustada erinevaid sõnu siin. Aga me näeme, et tõepoolest, paljud Nende blocks-- ja tõepoolest, C paljud functions-- võib olla parametriseerisin või kohandatud teha erinevaid asju. Tegelikult C kui me soovite teisendada, nüüd, See Scratch programmiga Selle muud keelt, me ei kavatse kirjutada natuke midagi sellist. 

Tõsi, seal on mõned tuttavad süntaks on kõige tõenäolisem, int, ja sulgudes ja tühine. Aga printf-- kuigi sa oleks arvan, et see oleks lihtsalt printida. Aga print tähendab print vormindatud, nagu me varsti näha. See sõna otseses mõttes prinditakse ekraani iganes on sees need sulgudesse, mis Loomulikult on sel juhul, tere. 

Aga sa märkad mõned muud süntaks, mõned jutumärkide, et sulgudes lõpus, semikoolon jms. Nii et natuke peakohal niiöelda, nii kognitiivselt ja süntaktiliselt, et me ei kavatse on meeles pidada, enne kui kaua. Aga aru, et praktikas, See hakkab välja hüpata sind. 

Tegelikult olgem keskenduda, et üks funktsiooni specifically-- sel juhul, tere öelda maailma. Nii öelda on funktsioon. Tere maailm on selle parameetri või argument, selle kohandamine. 

Ja seda võrdlust C on lihtsalt saab olema see üks rida siin, kus printf on võrdne, ütleme, topelt jutumärkide, tere maailma on samaväärne muidugi mida see valge kast seal. Ja backslash n, kuigi veidi kummaline ja puuduvad nullist, lihtsalt läheb mõjuda jagame vaata oma arvuti, nagu mu Mac või PC, lihtsalt liigutades kursori järgmisele reale. See on nagu pihta Sisesta oma klaviatuuril. 

Nii näeme, et uuesti enne pikk. Aga kõigepealt võtame pilk selle Teine näide puhul silmuseid. Meil oli see igavesti loop viimane kord, mis oli sarja puzzle tükki et tegi midagi sõna otseses mõttes forever-- sel juhul, öelda, tere, tere, tere, tere. Nii et see on lõputu silmuse ette nähtud. 

In C, kui me tahame, et rakendada seda Sama mõte, me võiks lihtsalt teha. Kuigi tõsi, printf tere world-- nüüd samas, just semantiliselt, millist silme mõte teha midagi uuesti ja uuesti ja uuesti, ja kui kaua? Noh, true-- meelde tuletada, et tõsi on lihtsalt või üks. 

Ja tõsi on muidugi alati tõsi. Nii et see on selline mõttetu avalduses lihtsalt öelda tõsi. Aga tõesti, see on tahtlik, sest kui tõsi on lihtsalt alati tõene, kui samas tõsi lihtsalt tähendab, kui vähe kaudselt et järgmine rida koodi nende vahel looksulg tuleb lihtsalt täita uuesti ja uuesti, ja jälle, ja tegelikult ei peatu. 

Aga kui sa ei taha oma loop lõpetada, sest me eelmisel korral koos midagi Selle korrata järgmised 50 korda C saame teha sama, mida on nimetatakse jaoks loop-- märksõna ei ole samas, kuid. Ja siis on meil mõned uued süntaks siin int i võrdub 0, i vähem kui 50, i ++. Ja me tuleme tagasi selle. Aga see on lihtsalt, kuidas oleks tõlkida komplekt Scratch plokid kuni kogum C rida koodi. 

Vahepeal kaaluda muutujaid. Ja tegelikult, me lihtsalt nägin üks hetk tagasi. Ja juhul, Scratch, kui me tahtis kuulutada muutuja nimega i i on täisarv, vaid number, ja me tahame, et seada see mingi väärtus, me kasutame seda oranž blokeerida siin-- seada i kuni 0. 

Ja me näeme täna ja kaugemale, nagu eelmisel nädalal, programmeerijad teha peaaegu alati hakka lugema nullist, tõesti kokkuleppeliselt. Aga ka seetõttu, tagasikutsumise Meie arutelu binaarne, Kõige vähem saab esindavad ühegi bittide arv lihtsalt läheb 0 ise. Ja nii me tavaliselt alustada initializing isegi meie muutujate 0. 

Ja C teha sama, me ei kavatse öelda, int täisarv, ma lihtsalt kombeks. Ma oleks võinud nimetada selle muutuja midagi tahan, just nagu Scratch. Ja siis võrdub 0 lihtsalt tsessionääride väärtus 0 paremalt ja paneb selle muutuja, või hoiuruum seal vasakul. Ja semikoolon, kui me see-- ja oleme näinud mõned neist already-- tähendab lihtsalt lõpuni mõelnud. Jätkake teha midagi muud liinidel, mis järgnevad. 

Nüüd, kuidas Boole'i ​​avaldised? Tuletame meelde, et Scratch, need olid väljendid mis on kas tõene või false-- küsimusi, tõesti, mis on kas tõene või väär. Nii puhul Scratch võiksime küsi lihtsale küsimusele niimoodi, on i alla 50? Nii i jällegi on täisarv. Võib-olla me kasutame seda a Scratch programmiga jälgida skoor või midagi sellist. Nii et see süntaks siin Scratch tähendab lihtsalt, on i alla 50? Noh, õnneks midagi lihtne C. Ja tõlkida, Selle me lihtsalt öelda, et ma vähem kui 50, kasutades tuttav võti klaviatuuril. 

Vahepeal, kui sa tahtsid veel midagi öelda üldiselt nagu, noh, on x vähem kui y, kus iga x ja y on ise muutujaid? Me saame teha sama asja C, nii kaua, kui me oleme loodud nende muutujate juba. Ja me näeme, kuidas teha enne pikk. Me lihtsalt öelda, x on väiksem kui y. 

Nii et sa oled hakanud näha mõningaid sarnasusi. Ja need inimesed, kes on teinud Scratch olid kindlasti inspireeritud mõned neist põhiideed. Ja näete sellist süntaks paljudes languages-- mitte ainult nullist, ei lihtsalt C, kuid Python, ja JavaScript ning teiste keelte ikka. 

Vaatleme teise konstruktsiooniga C, mõiste tingimus, midagi tinglikult. Kui midagi on tõsi, seda teha. Kui midagi on tõsi, seda teha. See on omamoodi programmeerimine samaväärne teelahkmele. Võib-olla see on kahesuunaline kahvel, kolmeastmelise kahvel või rohkem. Ja Scratch, meil oleks näinud midagi sellist. 

Nii see on suur. Aga pean suhteline lihtsus loogika. Kui x on väiksem kui y, siis ütle x on väiksem kui y, else if x on suurem kui y, siis öelda x on suurem kui y. Ja siis loogiliselt kui te arvate tagasi Scratch või lihtsalt oma intuitsioonile, noh, kui x ei ole suurem kui y, ja x ei ole väiksem kui y, siis muidugi x on võrdne y. Nii et selles asjas pesitsevate need Scratch plokid, saame saavutada kolm viis teelahkmele? 

Vahepeal, kui me tahame teha, et C, siis väidetavalt tundub veidi simpler-- vähemalt kui sa saad tuttav süntaks. Kui x on väiksem kui y, printf x on väiksem kui y. Või kui x on suurem kui y, printf x on suurem kui y. Else printf x on võrdne y-- ja jälle omadega backslash lõpeb lihtsalt need uued liinid, nii et kui sa tegelikult jooksis selline programm see oleks lihtsalt liikuda kursor lõpuks järgmisele reale ekraani. 

Nüüd, vahepeal Scratch olid teised keerukamaid funktsioone, vaid millest mõned me ei kavatse esialgu minna üle maailma C. Ja üks neist oli nimetatakse nimekiri Scratch. Ja see oli eriline tüüpi muutuja, mis võimaldas teil salvestada mitu asja ta tagasi, tagasi, tagasi, edasi-tagasi. 

In C, see ei pea nimekirjad, per se, kuid midagi mis on üldisemalt nimetatakse massiivid, kuigi me hiljem tagasi tulla see semester vaadates midagi nimetatakse nimekirja, või tõesti seotud nimekirja. Aga nüüd, lähim samaväärne C juures saab olema midagi nimetatakse massiivi. Ja massiivi on lihtsalt erilist tüüpi muutuja mis võimaldab salvestada andmeid tagasi, tagasi, tagasi, edasi-tagasi. 

Ja tõepoolest, Scratch, Kui me tahame pääseda Esimese massiivi elemendile või list-- ja ma lähen seda kutsuda, Kokkuleppeliselt argv, argument vektor, kuid rohkem, et enne pikk. Kui ma tahan saada esimese elemendi ning argv, maailma Scratch seda tegelikult tavaliselt hakka lugema alates 1.. 

Ja nii ma võiks saada punktis 1 argv. See on lihtsalt, kuidas MIT ellu mõiste nimekirju. Aga C, ma lähen rohkem lihtsalt öelda, argv, mis omakorda on nimi minu list-- või olema selge, massiivi. Ja kui ma tahan esimest elemendid, ma lähen kasutada nurksulgudes, mida ei pruugi sageli all klaviatuuri. 

Aga 0 tähendab lihtsalt, mulle esimene. Nii mõnikord ja Aja möödudes läheme alustada näha neid dichotomies vahel Kraabi ja C, kusjuures Scratch kasutab üks. Me C kasutada 0 siin. Aga saate kiiresti näha kui sa mõistad aluseid iga keele, mis Nende hakkavad asjad enam tuttavad läbi praktika ja praktika. 

Nii saab tegelikult vaadata praegu programm. Siin peab olema esimene meie C lähtekoodi täieliku programmi. Ja programmi läheme pakkuda arutamiseks on üks, mis on samaväärne kui selle varasema Scratch tükk. 

Nii siin, meil on, mida on vaieldamatult kõige lihtsam C programmi võite kirjutada, et tegelikult ei midagi. Nüüd me vaatame minevikku, nüüd on hulka standard io.h ja nende nurk Sulgudes ja int ja tühine, ja looksulg jms. 

Ja olgem keskenduda ainult Mis vähemalt intuitiivselt, Võib välja hüpata sa juba. Tegelikult peamine, ma ei pruugi teada, mis see on, kuid palju nagu Scratch oli, et kui roheline lipp klõpsatud pusletükk, nii ei C programmeerimiskeelt on peamine tükk kood, mis saab teostada vaikimisi. Ja tõepoolest, see on sõna otseses mõttes nimetama hakatakse peamine. 

Nii peamised on funktsioon. Ja see on eriline funktsioon, mis eksisteerib C, et kui sa jooksed programmi see on peamine, et saab juhivad vaikimisi. Tänapäeva maailmas Scratch, see oli tavaliselt siis, kui roheline lipp klõpsatud, et sai joosta vaikimisi. 

Vahepeal oleme näinud seda enne, printf või printida vormindatud, mis on saab olema funktsioon, mis on kaasas C koos terve hulk teisi, See aeg ja aega uuesti, et teha täpselt nagu nimigi ütleb, printida midagi. Mida me tahame, et printida? Noh, eks me näeme, et poolt ümbritseb tähemärki nagu these-- tere, backslash n jutumärkidega, saame öelda printf täpselt mida printida ekraanil. 

Aga selleks, et teha et me kahjuks vaja võtta midagi, mis on juba segasena meile inimestele, aga vähemalt on see mõnevõrra readable-- terav hulka, standard io.h, int, Peamine, tühine, printf kõik maagiline loitsud me lihtsalt nägime ekraanil. Aga me tegelikult on minna enam kauge ikka. Meil on vaja kõigepealt tõlkida koodi et me kirjutame masinkoodiks. Ja mäletate eelmisel nädalal, et masinad, vähemalt need, mida me teame siin, lõpus päeval ainult mõista ühtede ja nullide. 

Ja mu Jumal, kui meil oleks kirjutada neid ühtede ja nullide tegelikult programmi see oleks väga, väga kiiresti võtta lõbus välja midagi. Aga selgub, ühe eelmisel nädalal et need mustrid ühtede ja nullide lihtsalt eriline tähendus. Teatud kontekstides, nad võiks tähendada numbrid. 

Teatud olukordades võib neid võib tähendada tähed või värvi, või mis tahes arvu teiste veevõtu seal peal. Aga nagu arvutis on CPU, Central Processing Unit, või aju sees arvutit. See on tavaliselt Intel sees, sest see on üks suurimaid ettevõtteid mis teeb protsessoriga arvuteid. 

Noh, Intel protsessoriga ja teised lihtsalt on otsustanud ette et teatud mustrid nulli ja need tähendavad konkreetseid asju. Teatud mustrid ühtede ja nullide tähendab, printida seda ekraani, või lisada need kaks numbrit, või lahutada need kaks numbrit, või seda malendit liigutada andmeid minu arvuti mällu siin, või mitmeid teisi väga madal, kuid lõppkokkuvõttes kasulik, operatsioone. Aga õnneks meil inimestel ei lähe et on vaja teada, detailsuse tase. Tõepoolest, nii nagu viimane kord, kus me refereerida uuesti ja uuesti ja uuesti, hoone väga madal primitiivid nagu ühtede ja nullide kõrgema tasandi mõisted nagu numbrid ja tähed, ja värvid, ja rohkem, nii saame meie programmeerijad seista õlgadele teised, kes on tulnud enne meid ja kasutada tarkvara, et teised inimesed on kirjutatud enne us-- nimelt programme nimetatakse koostajad. 

C on keel, mis Tavaliselt koostatakse, mis tähendab ümber lähtekoodi masinkoodi. Eriti, mida see tähendab on see, et kui sul on oma allikas kood, mis te ise kirjutada, nagu me varsti tahe vaid hetkeks ekraanile, ja soovite teisendada see lõpuks masin code-- need nullid ja need, mis ainult Mac või arvuti understands-- sul esimene toita, et lähtekoodi nii sisend eriline programm nimega kompilaator, mille väljundiks me näha on masin koodi. Ja tõesti, viimane kord, kui me rääkisime umbes, tõesti, lõpus päeval, probleemi lahendamine. Sul sisendeid. Ja sul väljundid. Ja sul mingi Algoritmi keskelt. 

Algoritmid saab kindlasti olema rakendada tarkvara nagu nägime pseudokoodi eelmisel nädalal ja nagu me näeme tegeliku koodi see nädal. Ja nii tõlkija tõesti ainult on kogum algoritme sees seda, et teada, kuidas teisendada erilist märksõnu nagu peamine, ja printf, ja teised, et me lihtsalt nägi arvesse mustrid nulli ja need, mis Intel sees ja teised protsessoriga tegelikult aru. Niisiis, kuidas me seda teeme? Kust me tõlkija? 

Enamik meist siin on Mac või PC. Ja sa kasutad Mac OS või Windows või Linux või Solaris, või mõnel teisel operatsioonisüsteemidega. Ja tõesti, saime minema veebi ja alla laadida tõlkija Mac või arvuti just teie operatsioonisüsteemi. Aga me kõik olema erinevatel lehtedel, nii rääkida. Me tahaks olla veidi erinevates koosseisudes. Ja asjad ei tööta kõik sama. Ja tõepoolest, nendel päevadel paljud meist ei kasuta tarkvara, mis töötab ainult meie sülearvutid. Selle asemel kasutada midagi nagu brauserit, mis võimaldab meil veebipõhiste Pilverakendused. Ja sel semestril teeme just nii. Me kirjutada rakendusi või tarkvara abil code-- ole C, kuid teistes keeltes nagu Python ja JavaScript-- mis töötavad pilv. 

Ja seda, et me ise semestri jooksul tegelikult kasutada pilvepõhine keskkond tuntud CS50 IDE. See on veebipõhine programmeerimine keskkonda või integreeritud arendamine keskkond, IDE, mis on ehitatud atop mõned Avatud lähtekoodiga tarkvara nimega Cloud 9. Ja me oleme teinud mõningaid pedagoogilise lihtsustamiseks see et varjata teatud funktsioone Esimestel nädalatel, et meil ei ole vaja, pärast mida saate paljastada ning teevad kõige ükskõik mida tahad keskkonda. 

Ja see võimaldab meil ka, et eelinstallige teatud tarkvara. Asjad nn CS50 raamatukogu, mida me kohe näha, annab meile C mõned lisafunktsioone. Nii et kui te lähete lõpuks CS50.io, palutakse teil sisse logida, ja kui te seda teete ja luua tasuta konto, siis oleks võimalik pääseda keskkond, mis näeb välja üsna niimoodi. 

Nüüd, see on vaikimisi režiim. Kõik on kena ja ere ekraanil. Paljud meist on harjumus töötab CS50 tükk, mis on üsna hilise ööni. Ja nii mõned võid eelistada muuta see öö režiim, nii rääkida. 

Aga lõpuks, mida sa näeme jooksul CS50 IDE on kolm erinevat areas-- ala vasakul, kus faile ei kavatse olla pilv, mille pindala üleval paremal kus oma koodi saab olema muudetav. Sul on võimalik avada üksikud kaardid ühtegi programmi et sa kirjutad selle semestri sees Selle ülemises paremas nurgas. Ja siis kõige arcanely, ja veel võimsalt, läheb see asi on põhja tuntud terminali aknas. 

See on vana kooli Käsurealiides, või CLI, mis võimaldab Teil täita käske kohta computer-- sel juhul, Arvuti on cloud-- teha asju nagu kompileerida koodi alates lähtekoodi masin koodi käivitada oma programme või alustada oma veebiserver või juurdepääsu oma andmebaasi, ja mis tahes arvus muud tehnikat et hakkame kasutama enne pikk. Aga sinna jõuda, me oleme läheb tegelikult minna online ja alustada mängimist. Ja seda, et olgem kõigepealt alustada sisemusse peamine, ja kirjutada peamine osa programmist. Ja olgem kasutada seda funktsiooni printf, mida me varem kasutatud, lihtsalt midagi öelda. 

Nii et siin ma olen juba sees CS50 IDE. Olen logitud ette. Ja ma täis linastub akent. Ja nii lõpuks, siis Ka järgnevatel probleeme jälgib sarnased sammud annab elektroonilist dokumentatsiooni. Nii et sa ei pea muretsema neelavad iga väike tehniline samm mis ma täna siin. 

Aga saad ekraani niimoodi. Ma juhtub olema öö režiim. Ja saab heledaks kõike kuni keelates öö režiim. Ja lõpuks päev, sa lähed, et näha Nende kolme peamise areas-- faili brauseri vasakul, kood kaarte kuni top, ja terminali akna allosas. 

Lubage mul minna ja kirjutada minu esimene programm. Ma lähen ennatlikult minge File, Säästa ja päästa oma faili hello.c. Tõepoolest, kokkuleppeliselt iga programmi me kirjutada, mis on kirjutatud C keeles nimi peaks olema midagi dot c, kokkuleppeliselt. Nii et ma lähen nime hello.c, sest Ma tahan öelda tere tulemast maailma. Nüüd ma lähen suurendamiseks välja ja vajuta Save. Ja kõik, mis mul siin nüüd on sakk kus ma saan alustada kirjalikult koodi. 

See ei lähe kompileerida. See ei tähenda midagi. Ja nii kui ma ümber see ühtede ja nullide, CPU läheb pole Idee, mis toimub ümber. Aga kui ma kirjutan read, mis ei sobi koos C on conventions-- C olend, Ka see language-- süntaksi nagu Selle printf tere world-- ja ma olen saanud rahul Seejuures aja jooksul. Nii et ma ei usu, et ma tegin mis tahes trükivigu. 

Aga alati kõige esimene kord, kui seda teha, siis küll. Ja mida ma teha võiks väga hästi ei tööta esimest korda. Ja see on täiesti OK, sest praegu sa võib lihtsalt näha palju uudsust, kuid aja jooksul kui sa saad tuttav Selle keskkonna ja Selle keele, ja teised, hakkate näha asju, kas õige või vale. 

Ja see on see, mida õpetamise stipendiaatide ja loomulikult assistendid saada nii hea aja jooksul, on määrimine vigu või vigu oma koodi. Aga ma väita, et pole vigu see kood. Nii et ma tahan nüüd programmi käivitada. 

Nüüd on minu enda Mac või PC, ma olen harjumus topeltklõpsu ikoonid kui ma jooksen mingi programmi. Aga see ei ole mudeli siin. Sellises keskkonnas, mis on CS50 IDE. Me kasutame operatsioonisüsteemi süsteemi nimetatakse Linux. Linux meenutab teise operatsioonisüsteemi, üldtuntud Unix. Ja Linux on eriti tuntud võttes käsurea keskkond, CLI. Nüüd me kasutame konkreetse maitse Linux nimega Ubuntu. Ja Ubuntu on lihtsalt Teatud versiooni Linux. 

Aga need Linuxi nendel päevadel teha tegelikult tulevad graafilise kasutajaliidese. Ja üks me juhtumisi kasuta siin on veebipõhine. Nii et see võib tunduda isegi Natuke erinev midagi sa ise võib-olla näinud või käivitada varem. 

Nii et ma lähen edasi minna nüüd ja teha järgmist. Olen salvestanud seda faili hello.c. Ma lähen edasi minna ja tüübist clanghello.c Nii rõkkama jaoks C keel on koostaja. See on eelinstalleeritud CS50 IDE. Ja saab täiesti alla laadida ja paigaldada selle ise Mac või PC. 

Kuid jällegi, sa ei pea kõiki pre-konfiguratsioonis tehtud. Nii et nüüd ma olen lihtsalt kavatse joosta clanghello.c. Ja nüüd seda märgata süntaks Siin lõpuks aru, tähendab, et ma olen oma kausta või kataloogi nimega tööruumi. See dollari märk on lihtsalt konventsiooni tähendust, kirjuta oma käsud siin. 

See, mida nimetatakse kiire, lihtsalt Kokkuleppeliselt on dollari märk. Ja kui ma minna nüüd ja kliki Sisesta miski tundub, et on juhtunud. Aga see on tegelikult hea. Mida vähem, mis juhtub ekraani, seda tõenäolisemalt kood on õige, vähemalt süntaktiliselt. 

Nii et kui ma tahan teha selle Programm, mida ma pean tegema? Noh, selgub, et Vaikimisi nimi kokkuleppeliselt programmide jaoks, kui sa ei täpsusta nimi oma programm on lihtsalt a.out. Ja seda süntaksit liiga, saate tutvuda enne pikk. 

Dot kaldkriips tähendab lihtsalt, hei, CS50 IDE, käivitada programmi nimega a.out see on sees minu praeguse kataloogi. See dot tähendab käesolevat kataloogi. Ja me näeme, mida teised sellised järjestused märkide tähendab enne pikk. 

Nii et siin me läheme, Enter, tere. Ja märkad, et mis juhtus? Mitte üksnes see printida tere. Samuti kolis kursori järgmisele reale. 

Ja miks see oli? Mis oli kood, mis me enne kirjutasin et tagada, et kursor oleks minna järgmisele reale? Naljakas asi arvuti on see läheb teha sõna otseses mõttes, mida sa öelda tahad. 

Nii et kui sa ütled seda printf tere, koma, tühik, maailma, lähedal tsiteerida, see on sõna otseses mõttes vaid läheb printida need märgid. Aga mul oli see eriline tegelane lõpus, meenutada, backslash n. Ja see, mida tagatakse et märk läks järgmisele reale ekraani. 

Tegelikult, las ma lähen ja teen seda. Lubage mul minna ja kustuta see. Nüüd märgata, et peale minu ekraani seal natuke punast valgust tab näitab, Tere, olete ei salvestata faili. Nii et ma lähen edasi minna kontrolli S või käsu S, salvestada faili. Nüüd goes-- läks moment-- roheline. Ja nüüd on see tagasi lihtsalt on tihe ikoon. 

Kui ma nüüd käivitada clanghello.c uuesti Siseneda, dot kaldkriipsuga a.out, Enter, näete, et see ikka töötas. Aga see on vaieldamatult natuke lollakas. Just nüüd, minu prompt-- tööruumis ja siis, et dollari märk, ja siis minu tegelik prompt-- on kõik samal joonel. Nii see kindlasti esteetiline viga, isegi kui see ei ole tõesti loogiline viga. 

Nii et ma lähen tagasi võtta, mida ma just tegin. Ma lähen uuesti, a.out. Teadaanne ma lisanud reavahetuse märk tagasi. Olen salvestatud faili. 

Nii et ma lähen uuesti, a.out, Ja-- kurat võtaks, viga, viga tähendab, eksitus. Nii viga on see, et kuigi Lisasin backslash n seal, uuesti salvestatud, uuesti jooksis programmi käitumist oli sama. Miks oleks? 

Ma puudu samm, eks? See oluline samm varem oli see, et teil on mina-- kui muudad oma lähtekoodi, Selgub ka käivitada läbi koostaja jälle nii saad uue masina koodi. Ja masin koodi nulli ja need, saab olema peaaegu identsed, kuid ei ole täiesti nii, sest meil on vaja, muidugi, et uus liin. 

Nii määrata see, et ma lähen vaja kuni uuesti, clanghello.c, sisestada dot kaldkriips, a.out. Ja nüüd, tere on tagasi kus ma eeldan, et see oleks. Nii et see on kõik hästi ja hea. Aga a.out on päris loll nime jaoks programm, kuigi see juhtub olema, ajaloolistel põhjustel default-- tähendab kokkupanek väljundid. 

Aga lubage mul minna siin ja seda erinevalt. Ma tahan, et mu programmi Hello World tegelikult nimetada tere. Nii oleks see ikoon minu töölaual, siis ei oleks a.out. See oleks nn tere. 

Nii et seda teha, selgub et rõkkama, nagu paljud programmid, toetab käsurea argumente, või lippe või lülitid, mis lihtsalt mõjutada tema käitumist. Täpsemalt rõkkama toetab kriips o lipp, mille võtab siis teine ​​sõna. Sel juhul, ma meelevaldselt, aga mõistlikult, nimetame seda tere. Aga ma võiks seda nimetada midagi Ma tahan, välja arvatud a.out, mis oleks pigem peale punkti. 

Ja siis lihtsalt nimetage faili ma ei taha kompileerida. Nüüd kuigi alguses Käsu mul on veel rõkkama, lõpus käsk Mul on veel failinime, Mul on nüüd need käsurea argumendid, need lipud, mis ütlevad, oh, muide, väljund-o, fail nimetatakse tere, mitte vaikimisi a.out. 

Nii et kui ma Enter nüüd midagi tundub, et on juhtunud. Ja veel, nüüd ma saan teha dot kaldkriipsuga tere. Nii et see on sama programmi. Nulli ja need on identsed lõpus päeval. 

Aga nad on kaks erinevat files-- a.out, mis on esimene versioon ja lihtsalt rumalalt nimega, ja nüüd tere, mis on palju ahvatlevamaks nimi programm. Aga ausalt, ma olen kunagi mäletad seda jälle, ja uuesti ja uuesti. Ja tegelikult, kui me kirjutame keerulisem programmide käsud sul läheb on kirjutada ei hakka isegi keerulisem veel. 

Ja nii ei pea muretsema. Selgub, et inimesel enne meil on mõistnud ka nemad oli see täpselt sama probleem. Ka nemad ei naudi võttes kirjuta üsna pikk, kauge käsud, rääkimata mäleta neid. Ja nii inimestel enne meid teinud muud programmid, mis lihtsustavad koostada oma tarkvara. 

Ja tõepoolest, üks selline Programm nimega Mark. Nii et ma lähen edasi minna ja seda teha. Ma lähen tagasi võtta kõike just tegin järgmisel viisil. Las ma kirjutada LS. Ja märkad kolm things-- a.out ja täht, tere ja täht ning hello.c. Loodan, et see peaks olla natuke intuitiivne, kuivõrd varem oli midagi selles tööruumi. Seal oli midagi, et mul oli loodud kuni hakkasime klassi. 

Ja ma lõin hello.c. Ma siis koostatud, ja nimetas seda a.out. Ja siis ma koostati uuesti kergelt erinevalt ja nimetas seda tere. Nii et mul on kolm faile selles kataloogis, Selle kausta nimega tööruumi. Nüüd ma näen, et ka kui ma välja suumida tegelikult. 

Kui ma välja suumida siin vaadata, et üleval paremal nurgas, nagu lubati vasakul pool ekraani alati saab näidata teile mida teie kontole, mis on sees CS50 IDE. Ja seal on kolm faili seal. 

Nii et ma tahan vabaneda a.out ja tere. Ja kui sa võiksid kujutada, intuitiivselt, siis võiks mingisugune kontroll kliki või paremklõps seda. Ja see väike hüpikmenüü. Võite alla laadida faili käivitada see, vaata see, värskendada, ümber nimetada või mida mitte. 

Ja ma võiks lihtsalt kustutada, ja see ära läheks. Aga teeme asju koos käsuga line nüüd, et saada mugav Selle ja teha järgmist. Ma lähen edasi minna ja eemaldada a.out kirjutades sõna otseses mõttes rma.out. Selgub, käsk eemaldamine või kustutamine midagi, ei ole eemaldada või kustutada. 

See on rohkem tabavalt RM, lihtsalt säästa mõned klahvivajutused ja vajuta Enter. Nüüd me ei kavatse olla mõnevõrra cryptically eemaldada tavaline fail a.out. Ma tõesti ei tea, milline ebaregulaarne fail oleks veel. Aga ma ei taha seda eemaldada. 

Nii et ma lähen kirjuta y jah. Või ma ei kirjuta see välja ja vajuta Enter. Ja veelkord, miski tundub juhtuda. Aga see on üldiselt hea. 

Kui ma tüüpi LS seekord mida ma peaksin? Loodetavasti lihtsalt tere ja hello.c. Nüüd, kui kõrvale, saate märka seda täht, tärniga, see on lõpus oma programmi. Ja nad ka ilmumise roheline. See on lihtsalt CS50 IDE tee ning cluing sind asjaolu et see pole lähtekoodi. See on käivitatav, et runnable programm, mis saab tegelikult sõita tehes dot kaldkriipsuga ja siis on see nimi. 

Nüüd lubage mul minna ja eemaldada see, rm tere, Enter, eemaldada regulaarselt esitada tere, jah. Ja nüüd, kui ma tüüpi LS, me oleme tagasi hello.c. Püüa mitte kustutada oma tegelik lähtekoodi. Kuigi seal on omadused ehitatud CS50 IDE kus võid minna läbi oma redaktsiooniajaloole ja tagasikerimine aega, kui te kogemata kustutada midagi, teha tähelepanelikkusele ühe neist küsib jah või ei, mida sa tegelikult tahad teha. Ja kui ma lähen kuni ülemise vasakus nurgas siin kõik, mis jääb, on hello.c. Nii et kobarad teiste käskude võimalik täita maailma Linux, millest üks on jällegi Tee. Ja me ei kavatse teha minu programm nüüd järgmine. 

Selle asemel, et teeme clang, selle asemel teeme clang-o, Ma lähen lihtsalt sõna otseses mõttes kirjutada, et tere. Ja nüüd märgata, ma olen ei kirjutades teha hello.c. Olen kirjutades teha tere. 

Ja see programm teha, et Kaasas CS50 IDE ja rohkem Üldiselt Linux, on programm, mis on kavatseb teha programmi nimega Tere. Ja see läheb eeldada, Kokkuleppeliselt et kui see programm teha saab, see saab olema allikast koodi faili lõpeb dot c, hello.c. 

Nii et kui ma Enter nüüd teate, et käsk, mis saab täide on tegelikult isegi kauem enne kui enne. Ja see on, sest me oleme eelseadistatud CS50 IDE on mõningaid täiendavaid funktsioone ehitatud, et Me ei vaja veel, aga varsti. Kuid peamine asi realiseerida Nüüd on mul Tere programmi. 

Kui ma tüüpi LS jälle, ma on tere programmi. Ja ma ei saa kasutada seda koos dot kaldkriips a.out, ei, sest mõte sellest Ülesande dot kaldkriipsuga tere. Ja nüüd on mul tere programmi. Nii liigub edasi, Me oleme peaaegu alati lihtsalt läheb kompileerida meie programmid käsuga Mark. Ja siis me läheme sõitma neid dot kärpida, ja programmi nimi. Aga aru, mida teevad on teinud juba sa, on ta ise ei ole tõlkija. See on lihtsalt mugavuse programmi kes teab, kuidas vallandada tõlkija joosta nii, et te ise ei kasuta seda. 

Mida teised käsud on olemas Linux, ning omakorda CS50 IDE? Me kohe näha, et seal on CD käsk Change Directory. See võimaldab jooksul oma käsurida liikuda edasi ja tagasi, ja avada erinevatesse kaustadesse ilma, kasutades oma hiirt. 

LS nägime, mis tähistab nimekirja failid aktiivses kataloogis. Tee Dir, saate Tõenäoliselt hakkavad järeldavad mida need tähendavad now-- teha kataloogi Kui soovite luua kausta. RM kustutamisel, RM dir eemaldada directory-- ja need, uuesti, on käsurea ekvivalente, mida sa võiks teha CS50 IDE hiirega. Aga saate kohe teada et mõnikord on see lihtsalt palju kiiremini teha asjad klaviatuuri, ja lõpuks palju võimsam. 

Aga see on raske väita, et midagi oleme teinud seni on kõik, mida võimsam, kui kõik oleme öelnud tähendab, tere. Ja tegelikult ma kõva kodeeritud sõnad tere minu programm. Ei ole dünaamika veel. Scratch oli suurusjärgus huvitav eelmisel nädalal. 

Ja nii lähme sinna. Võtame samm, et viis mõningate selliste funktsioonidega. Nii et mitte ainult ei C tulevad printf, ja kobarad muid funktsioone millest mõned me näha aja jooksul, see ei ole muuta see kõik nii lihtne kohe Värava saada kasutaja sisend. 

Tegelikult üks nõrkusi keelte nagu C, ja isegi Java ja veel teised, on see, et seda ei juhtu oleks lihtne lihtsalt saada asjad täisarvud kasutajate või stringid, sõnad, ja väljendeid, rääkimata asju ujukoma väärtuste või tegelik arv koos komakohaga, ja tõesti kaua numbrid, kui me kohe näha. Nii et see nimekiri funktsioonid siin, need on sarnaselt teiste Scratch puzzle tükki et meil on eelinstalleeritud CS50 IDE, et me kasutame paar nädalat nagu abirattad kehvasti, ja lõpuks võtab need ära ja vaata all kapuuts, ehk kell kuidas need asjad on rakendatud. 

Aga et seda teha, olgem tegelikult kirjutada programm. Lubage mul minna nüüd. Ja ma lähen, et luua uus fail, klõpsates see väike pluss, ja klõpsates Uus fail. 

Ma lähen, et päästa see järgmine üks nii, oletame, string.c, sest ma tahan mängida stringid. Ja stringi C on lihtsalt märgijada. Nüüd lähme edasi ja teha järgmist. 

Kaasa standard IO.h-- ja Selgub standard IO, IO tähendab lihtsalt sisend ja väljund. Nii selgub, et see rida siin on, mida Kas naaber meil kasutada printf. Printf muidugi toodab väljundit. Nii et kasutada printf, selgub et sa pead olema see rida koodi ülaosas oma faili. 

Ja me tuleme tagasi, mida mis tähendab tegelikult enne pikk. Selgub, et mis tahes C programmi ma kirjutan, Mul hakata seda kood, mis näeb välja selline. Ja märkad CS50 IDE ja muu tervikliku arengu keskkondades nagu see, Üritavad parimaks nad võivad lõpetada oma mõtte. Tegelikult hetk tagasi, kui ma tagasi võtta mida ma tegin, ma Enter. 

Siis tabas avatud lokkis traksidega, Enter uuesti. Ja see valmis minu mõte. See andis mulle uue rea, liigestatud mitte vähem kena stilistiline põhjustel me näeme. Ja siis see automaatselt andis mulle et lokkis traksidega lõpetan oma mõtte. Nüüd, see ei ole alati arvan, mida sa teha tahad. Aga suures osas see säästab klahvivajutusi. Nii hetk tagasi, me jooksime seda program-- tere, maailma ja siis koostatud seda, ja siis jooksis ta. Aga seal ei ole dünaamilisus siin. Mis siis, kui me tahtsime teha midagi erinevat? Noh, mis siis, kui ma tahtsin tegelikult saada string kasutaja? Ma lähen kasutada pusletükk nimetatakse täpselt selle-- saada string. 

Selgub C, et kui sa ei taha anda oma panus puzzle tükk, või õigemini, et funktsioon, siis sõna otseses mõttes lihtsalt ei avatud sulgudes Lõpusulg. Nii et see on, nagu oleks seal no valge karbi tipite. Say plokk enne oli väike valge kast. Meil ei ole seda valget kasti nüüd. 

Aga kui ma helistada get string, ma taha panna tulemus kusagil. Nii väga levinud paradigma C on helistada funktsioon, nagu get string siin ja siis hoidke oma tagastatav väärtus. See on tingitud tema jõupingutusi midagi. 

Ja mis on ehitada programmeerimine, kas nullist või nüüd C, et me saab kasutada tegelikult salvestada midagi? Nimetatakse seda muutuv, eks? Ja Scratch, me tõesti ei huvita, mis toimub muutujad. 

Aga sel juhul me tegelikult teevad. Ma ütlen string. Ja siis ma võiks helistada see midagi, mida ma tahan. Ma kutsun seda nimi, satub saada string. 

Ja nüüd, isegi kui sa oled natuke uus siin, märgata, et ma puuduvad mõned detail. Ma unustan semikooloniga. Mul on vaja lõpetada see mõte. Nii et ma lähen liikuda minu kursori tabas semikoolon seal. Ja mida ma olen lihtsalt teinud? Selles rida koodi, number 5 hetkel Helistan get string ilma sisendeid. Seega puudub väike valge kast nagu Save plokk on. 

Ma lihtsalt ütlen, hei, arvuti, mind string. Võrdusmärki ei ole tegelikult võrdusmärk, per se. See on ülesanne operaator, mis tähendab, hei, arvuti, liikuda väärtus paremale üle vasakule. Ja vasakul, mul on järgmine. 

Hei, arvuti, anna mulle string-- märgijada. Ja helistada, et string nimi. Ja ma ei pea isegi seda kutsuda nimi. 

Ma võiks seda nimetada, Tavapäraselt midagi S, palju nagu me kasutasime I helistada muutuja i. Aga nüüd ma pean sellega midagi teha. Oleks päris loll proovida valmimises koodi, töötab Selles programmis, kuigi Ma saan string, sest see on ikka lihtsalt ei ütle tere. 

Aga mis siis, kui ma ei taha seda muuta. Miks ma ei tee seda? Protsent s, koma s. Ja see on veidi segasena ikka. 

Nii et lubage mul teha minu muutujad selgem. Lubage mul nimetada selle muutuja nimi. Ja vaatame, kui me ei kiusa peale, mis toimub siin. 

Nii on line viis, ma saan string. Ja ma ladustamiseks, et string, Ükskõik, kui kasutaja on sisestanud tema omal klaviatuur, muutujale nimega nimi. Ja selgub, et printf ei ole lihtsalt võta üks argument topelt hinnapakkumisi, üks sisend jutumärkidega. 

See võib võtta kaks või kolm, või enam, näiteks et teisele või kolmandale või neljandale, kõik nimed muutujate või konkreetselt väärtused mida soovite pistik, dünaamiliselt, et string jutumärkides. Teisisõnu, mida Oleks vale seda? Kui ma just ütlesin tere nimi, backslash n, päästis mu faili, mis on koostatud minu kood, ja jooksis see, mis juhtub? 

See on lihtsalt ütlen, tere Nime, sõna otseses mõttes N-A-M-E, mis on tobe, sest see ei erine maailmas. Nii midagi tsitaadid on Mis sõna otseses mõttes saab trükkida. Nii et kui ma tahan olla kohatäide olemas, Ma tegelikult vaja kasutada mõned süntaksit. Ja selgub, kui sa loed dokumentatsiooni printf funktsiooni ta ütleb teile, et kui te kasutate protsenti s, saab asendada väärtus järgmiselt. 

Pärast komaga pärast seda jutumärke, lihtsalt kirjuta nimi muutuja, mida soovite pistik sinna formaadis koodi või vormi spetsifikaatori protsenti s keelpillidele. Ja nüüd, kui ma olen päästis mu faili Ma lähen tagasi alla minu terminal. Ja ma tüüpi Tee String, sest jällegi nimi see fail, mis ma valisin enne on string.c. 

Nii et ma lähen ütlen Tee String, siseneda. Oh jumal, pilk kõik vigu oleme teinud juba. Ja see on-- mida, see on tõesti nagu kuus, seitse line programm? Nii et see on koht, kus ta saab väga kiiresti saada suur. 

See terminalis on nüüd vaid regurgiteeritakse tohutu hulk veateateid. Kindlasti ma ei pea enam viga lugemiseks, kui mul on rida koodi. Mis siis toimub? 

Noh, parim strateegia teha millal ei kohata valdav vigade loetelu niimoodi, on kerida tagasi, otsida käsku sa lihtsalt jooksid, mis minu puhul on teha jada. Vaata, mida teha tegin, ja see on, et kaua rõkkama käsk, ei ole suur asi seal. 

Aga punane on halb. Green üritab olla õrn ja abivalmis. Aga see on ikka halb, sel juhul. Aga kus on see halb? 

String.c, line viis, iseloomu viis. Nii et see on lihtsalt Tavaks. Midagi jämesoole midagi tähendab liini number ja märgi number. Viga kasutamine deklareerimata identifitseerimine string. Kas sa mõtlesid standardiks? 

Nii kahjuks rõkkama üritab olla kasulik. Aga see on vale, antud juhul. Ei, rõkkama, ma ei mõelnud standard IO. Ma mõtlesin, et esimesel liinil, jah. 

Aga line viis on see üks siin. Ja rõkkama ei mõista S-T-R-I-N-G. See on deklareerimata identifitseerimine, et Sõna see lihtsalt pole kunagi näinud. Ja seda sellepärast, C, keele me kirjalikult koodi kohe, ei ole muutujaid nimetatakse stringid. 

See ei ole vaikimisi tugi midagi, mida nimetatakse jada. See on CS50 tükk kõnepruuki, kuid väga tavalised. Aga ma ei saa seda parandada järgmiselt. 

Kui ma lisan ühe rea koodi üles selle programmi lisada CS50.h, mis on teise faili kuskil sees CS50 IDE kusagil kõvakettale, nii et rääkida, Ubuntu operatsioonisüsteemi et mul hakkab, et on fail, mis on lähen õpetada operatsioonisüsteemi süsteem, mida string on, lihtsalt nagu standard io.h on fail operatsioonisüsteemi, mis on lähen õpetada seda, mida printf on. 

Tõepoolest, me oleks saanud väga sarnane sõnum kui IO tunnistas standard IO.h ja proovinud kasutada printf. Nii et ma lähen edasi minna ja lihtsalt Võtta kontrolli L selgeks minu ekraanil. Või saab kirjutada selgeid ja see lihtsalt puhtaks terminali aknas. Siiski saate kerida ajas tagasi. 

Ja ma lähen uuesti, Mark String. Risti mu sõrmed seekord Enter. Oh jumal, see töötas. see näitab mulle pika segasena käsk mis on see, mis teeb tootsid rõkkama, kuid veateateid. Nii mõistame, kuigi võite saada täiesti ülekoormatud arvu veateateid, see lihtsalt olla see tüütu kuhjuvate toime, kui rõkkama ei saa aru Üks asi, mis tähendab, et see siis ei saa aru järgmine sõna, või järgmisele reale. Ja nii see lihtsalt lämmatab oma koodi. Aga fix võiks olla lihtne. Ja nii alati keskenduda Kõige esimene rida väljund. Ja kui sa seda ei tee aru, lihtsalt otsida märksõnad, mis võivad olla vihjed ja liini number, ja iseloomu, kus mis viga võiks olla. 

Nüüd lubage mul minna ja kirjuta dot kaldkriips, string, siseneda. Hm, see ei ütle tere midagi. Miks? Noh, mäletate, kus on see töötab? 

See on ilmselt kinni hetkel tsüklina, kui soovite, real kuus, sest siia String, mille konstruktsioon, kirjutas CS50 personal on sõna otseses mõttes tähendas lihtsalt istuda seal ootab, ja ootab, ja ootab string. Kõik me mõtleme string on inimese sisend. Nii et sa tead, mida? Lubage mul minna. Ja just kapriis, lase mind kirjuta oma nimi, David, siseneda. Nüüd on mul rohkem dünaamiline programm. Ta ütles, tere David. 

Kui ma minna ja käivitada uuesti lubage mul proovida öelda Zamila nimi, siseneda. Ja nüüd on meil dünaamiline programm. Ma ei ole kõva kodeeritud maailmas. Ma ei ole kõva kodeeritud nimi või David või Zamila. 

Nüüd on palju rohkem nagu programmid me teame, kus, kui see sisendiga, see tekitab veidi erinev väljund. Nüüd on see ei ole parim kasutaja kogemus või UX. Ma käivitada programmi. 

Ma ei tea, mida ma peaksin teha, kui ma tegelikult vaadata või mäletan lähtekoodi. Nii saab teha kasutaja kogeda natuke parem lihtsaim asju. Lubage mul minna tagasi sellesse programmi ja lihtsalt öelda printf. 

Ja las ma minna ja öelda nimi, koolon, ja ruumi, ja siis semikoolon. Ja lihtsalt peksab, ei lõtku n. Ja see on tahtlik, sest ma ei taha kiire liikuda järgmisele reale. 

Ma tahan, selle asemel, seda teha, string kompileerima minu kood uue masina kood dot kaldkriips string. Ah, see on palju ilusam. Nüüd ma tegelikult tea, mida arvuti tahab mulle teha, anda talle nimi. 

Nii et ma lähen edasi minna ja kirjuta in Rob, sisestada ja tere, Rob. Niisiis, realiseerida, see on ikka lõpus Päeva ainult üheksa line programmi. Aga me oleme võtnud neid beebi samme. 

Me kirjutasime üks rida, millega me olid tuttavad, printf, tere. Siis undid natuke seda. Ja me tegelikult kasutada get string. Ja me viskad, et väärtus muutuja. Ja siis läksime edasi ja paranenud see edasi kolmandale reale. Ja see iteratsiooniprotsessi kirjutamise tarkvara on tõesti võti. In CS50 ja elu üldiselt, sa ei tohiks üldiselt istuda, on programmi silmas pidades, ja proovige kirjalikult kogu kuradi asi korraga. 

See paratamatult kaasa viis rohkem vigu kui me ise nägin siin. Isegi mina, et see päev, pidevalt teha muid rumalaid vigu, on tegelikult raskem vigu mis on raskem aru saada. Aga siis teeb rohkem vigu rohkem rida koodi kirjutada kõik korraga. Ja nii see praktika, kirjutada natuke koodi et oled rahul, koostada käivita see, katsetada seda üldisemalt seejärel liikuda nüüd-- nii nagu me hoida kihilisus ja kihilisus eelmisel nädalal hoone on midagi väga lihtne midagi keerulisem, teha sama siin. Ära istu, ja proovige kirjutada kogu probleem. Tegelikult võtavad need beebi samme. 

Nüüd, stringid ei ole kõik et kasulik enestele. Me tahame tegelikult ideaalis meeldib midagi muud meie tööriistakomplekt. Nii saab tegelikult teha just nii. 

Lubage mul minna nüüd ja klopsima veidi erinev programm. Ja me nimetame seda int.c, täisarv. Ma lähen samamoodi lisada CS550.h. Ma lähen hulka standard IO. Ja see saab olema päris ühist Nende esimestel päevadel klassi. 

Ja ma lähen valmis mina koos põhiülesanne. Ja nüüd selle asemel, et jada, lähme edasi ja saada int. Kutsume seda i, ja nimetavad seda saada int lähedal Sulgudes, semikoolon. Ja nüüd teeme midagi see, printf. 

Oletame, et midagi sellist tere, backslash n, koma i. Nii et ma olen päris palju imiteerib mida ma tegin hetk tagasi. Mul on kohatäide siin. Olen komaga i siin, sest ma tahan plug i sinna kohatäide. 

Nii saab minna ja proovida koostades programmi. Fail nimega int.c. Nii et ma lähen öelda, et int, siseneda. Oh jumal, kuid ei ole suur asi, eks? Seal on viga. 

Seal on süntaktiline viga siin selline, et programm ei saa koostatakse sees int.c, liin seitse, iseloomu 27, viga formaadis täpsustab tüübist char täht, mis iganes see on. Aga väide, tüüp on int. 

Nii ka siin, me ei kavatse mina-- kuigi täna on palju materjali, läheme uputama teile absoluutselt iga funktsioon C, ja programmeerimine üldisemalt vaid paari esimese nädala jooksul. Nii et sageli saab olema kõnepruuki kellega sa ei ole tuttav. Ja tegelikult, paalia täht on midagi me ei kavatse tagasi tulla nädal või kaks aega. 

Aga nüüd, vaatame, kas me saame sõeluda sõnad, mis on tuttavad. Formats-- nii kuulsime formaadis spetsifikaatori formaadis koodi enne. See on tuttav. Liik-- kuid argument on tüüpi int. Oota, ma ei int. 

Võib-olla protsenti s tegelikult on mõned määratletud tähenduses. Ja tõesti, see teeb. Täisarv, kui soovite printf asendada see, sa tegelikult kasutada erinevas vormis specifier. Ja sa ei tea seda kui keegi teile rääkinud, või siis oli seda teinud enne. Aga protsenti i on see, mida saab levinud aastal printf kõrvaldamine on täisarv. Võite kasutada ka protsenti d ette koma täisarv. Aga ma on ilus ja lihtne siin. Nii et me läheme selle. 

Nüüd lubage mul minna ja kordamisega make int, Enter. See on hea, vigu. Dot kaldkriips int-- OK, halb kasutaja kogemus, sest ma ei ole öelnud, mina mida teha. Aga see on hea. Ma kandepinda kiiresti. 

Ja nüüd lubage mul minna ja kirjuta David, OK, Zamila, Rob. OK, nii et see on hea asi. Seekord ma kasutan funktsiooni puzzle tükk, mida nimetatakse get int. Ja selgub out-- ja me vaata seda hiljem term-- CS50 töötajad on rakendanud saada string selliselt et see ainult füüsiliselt saada stringi. 

See on rakendanud get int sisse sellisel viisil, et see ainult saada täisarv teile. Ja kui sa, inimeste, koostööd ei tee, see on sõna otseses mõttes lihtsalt läheb öelda uuesti, uuesti, uuesti, sõna otseses mõttes istub seal silmukoiminen kuni sa kohustada koos mingi maagiline number, nagu 50, ja tere 50. 

Või kui võtame seda jälle ja kirjuta 42, hello 42. Ja nii get int funktsiooni sees, et pusletükk Piisab loogika piisavalt mõelnud, nuputada, mis on sõna? Ja mis on number? Ainult nõustudes lõpuks numbrid. 

Nii selgub, et see ei ole nii ilmekad. nii kaugel. Niisiis, jess, viimane kord läks päris kiiresti rakendamisse mängud ja animatsioon, ja kunstiteoste Scratch. Ja siin me oleme seda sisu koos hello world, ja tere 50. 

See pole veel kõik, mis inspireerivad. Ja tõesti, need esimese paari näiteid võtab aega ramp üles põnevust. Aga meil on nii palju kontrollida nüüd, tegelikult. Ja me ei kavatse väga kiiresti alustada kihilisus peal need põhilised primitiivid. 

Aga kõigepealt, olgem aru Mis piirangud on. Tegelikult on üks neist asjadest, Scratch kergesti ei tehkem on tõesti vaatama all kapuuts, ja mõista, mida arvuti on, mida ta saab teha, ja mis on selle piirangud. Ja tõepoolest, et vähene arusaam, potentsiaalselt pikaajalist võib kaasa tuua oma mistakes-- kirjalikult vead, kirjutades ohtlik tarkvara, mis häkkimisel mingil moel. 

Võtame mõned sammud mõista seda natuke paremini viis öelda, järgmine näide. Ma lähen edasi minna ja rakendada reaalne kiire programm nimega lisaja. Nagu, lisame mõned numbrid kokku. Ja ma lähen koodi mõned nurgad siin, ja lihtsalt kopeerida ja kleepida kus ma olin enne, lihtsalt nii saame läheb varem. Nüüd on mul põhi algus programmi nimega lisaja. 

Ja olgem minna ja seda teha. Ma lähen edasi minna ja ütleme, intx saab saada int. Ja teate mis? Teeme parem kasutaja kogemus. 

Nii ütleme lihtsalt x on ja tõhusalt palub kasutajal anda meile x. Ja siis lubage mul minna ja öelda, printf kuidas y on seekord oodanud kaks väärtust kasutaja. Ja siis lähme lihtsalt minna ja ütleme, printf, summa x ja y on. Ja nüüd ma ei taha seda teha protsenti s. Ma tahan teha protsenti i, backslash n, ja seejärel ühendage summa väärtuses. 

Niisiis, kuidas ma saan minna seda teed? Tead mida? Ma tean, kuidas kasutada muutujaid. Lubage mul kuulutada uus, int z. 

Ja ma lähen teen oletuse siin. Kui on võrdne märke selle keeles, võibolla ma lihtsalt teha x pluss y, nii kaua kui ma lõpetan oma mõtles semikoolon? Nüüd ma saan minna siia tagasi, ühendage z, lõpetada see mõtte semikooloniga. Ja vaatame nüüd, kui need järjestused lines-- x on saada int. Y on saada int. 

Lisa x ja y, salvestada väärtust · Z- nii meenutage veelkord võrdusmärki ei ole võrdsed. See ülesanne paremalt vasakule. Ja olgem välja printida, et summa x ja y ei ole sõna otseses mõttes z, aga mis sees z. Nii saab teha lisaja - kena, ei ole vigu seekord. Dot kaldkriips lisaja, sisestada x saab olema 1. 

Y saab olema 2. Ja summa x ja y on 3. Nii et kõik on hästi ja hea. 

Nii et sa ei kujuta ette, et matemaatika peaks töötama programmi niimoodi. Aga tead mis? See muutuja rida 12, isegi vajalik? Sa ei pea saada harjumuseks lihtsalt hoidmiseks asju muutujad lihtsalt sellepärast, et saate. Ja tegelikult, see on üldiselt halvaks disain Kui loote muutuja, mida nimetatakse z sel juhul hoidmiseks midagi see, ja siis kohe seda kasutada, kuid mitte kunagi enam. Miks anda midagi nimi nagu z kui sa sõna otseses mõttes kavatsete kasutada mis asi ainult üks kord, ja nii proksimaalne, kuhu loodud see esimene koht, nii lähedal, nii rida koodi? Nii et sa tead, mida? Selgub, et C on üsna paindlik. Kui ma tegelikult tahan plug-in väärtuste siin Ma ei vaja kuulutada uue muutuja. Ma võiks lihtsalt plug-in x pluss y, sest C mõistab aritmeetika ja matemaatilisi tehteid. 

Nii et ma lihtsalt öelda, seda matemaatikat, x pluss y, mis iganes need väärtused, ühendage tulemuseks täisarv sellesse string. Nii et see võib olla, kuigi ainult üks rida lühem, parem disain, parem programm, sest seal on vähem koodi, seega vähem mind mõistma. Ja see on ka lihtsalt puhtamaks, kuivõrd me ei ole uusi sõnu, uued sümbolid, nagu z, kuigi nad tegelikult ei teenida palju eesmärgil. 

Kahjuks matemaatika ei ole kõik, mis usaldusväärne mõnikord. Lähme edasi ja tee seda. Ma lähen edasi minna nüüd ja teha järgmist. 

Teeme printf, protsenti i, pluss protsenti i, peab olema protsenti i, backslash n. Ja ma lähen tegema see-- xyx pluss y. Nii et ma lihtsalt lähen kirjutada see veidi erinevalt siin. Lubage mul teha kiire meelerahu kontrolli. Jällegi, ärme saada enne ise. Tee rästik, dot kaldkriipsuga rästik. x on 1, y on 2, 1 pluss 2 on 3. Nii see on hea. Kuid olgem keeruliseks see nüüd natuke, ja luua uus fail. 

Ma nimetan seda ühte, öelda, ints, mitmuses eest täisarvud. Lubage mul alustada, kui olin hetk tagasi. Kuid nüüd teeme mõned teised read. Lubage mul minna ja teha järgmised printf, protsenti i miinus protsenti i, on protsenti i, koma x, koma yx miinus y. Nii ma teen veidi erinevat matemaatika seal. Teeme veel ühe. Nii protsenti i korda protsenti Ma ei protsendi i, backslash n. Olgem plug-in x ja y ja x korda y. Me kasutame tärn kohta arvuti korda. 

Sa ei kasuta x. x on muutuja nimi. Sa kasutad tähe paljunemist. Teeme veel ühe. Printf protsenti ma, jagatuna poolt protsenti i, on protsenti i, backslash n. xy jagatud y-- Siis kasuta kaldkriipsuga C teha rajoon. Ja teeme veel ühe. Ülejäänud protsenti i jagatud poolt protsenti i, on protsenti i. xy-- ja nüüd ülejäänud on see, mis on üle jäänud. Kui proovite jagamisel nimetaja arvesse lugeja kui palju üle on jäänud sa ei jaga välja? 

Nii et tegelikult ei ole, tingimata, sümbol Me kasutasime algkool seda. Aga seal C. Te saate öelda x moodul y, kus Selle protsenti märk selles context-- äravahetamiseni kui oled sees on jutumärkide, sees printf, protsenti kasutatakse vormi specifier. 

Kui kasutate protsenti väljaspool et tehte, see on mooduli operaator modulaarne arithmetic-- meie eesmärkidel siin, tähendab lihtsalt, milline on Ülejäänud x jagatud y? Nii x jagatud y on x kaldkriipsuga y. Mis on ülejäänud x jagatud y? See on x mod y, programmeerijana ütleks. 

Nii et kui ma ei teinud ühtegi viga siin, las ma minna ja teha ints, mitmuses, kena, ja dot kaldkriipsuga ints. Ja olgem minna ja teha, oletame, 1, 10. Olgu, 1 pluss 10 on 11, check. 1 miinus 10 on negatiivne 9, vaadake. 

1 korda 10 on 10, check. 1 jagatud 10 on-- OK, me vahele, et üks. Ülejäänud 1 jagatud 10 on 1. See on õige. Aga seal on viga siin. 

Nii et üks Panen üle andma, ei ole õige. Ma mõtlen, et see on peaaegu 0. 1 jagatud 10, sa tead, kui me lõigates mõned nurgad, kindel, et see on null. Aga see peaks tõesti olema 1/10, 0,1 või 0,10, 0,1000, või nii edasi. 

See ei tohiks tõesti olla null. Noh, tuleb välja, et arvuti on tehes sõna otseses mõttes, mida me rääkinud seda teha. Me teeme matemaatika nagu x jagatud y. Ja nii x ja y, per read kood varem, on täisarvud. 

Lisaks on line 15 oleme räägib printf, hei, printf plug-in täisarv, plug-in täisarv, plug-ühes integer-- spetsiaalselt x ja siis y ja seejärel x jagatuna y. x ja y on ints. Oleme seal hästi. 

Aga mis on x jagatud x? x jagatud y peaks olema, matemaatiliselt, 1/10 ehk 0,1, mis on tõeline number, tegelik arv võttes potentsiaalselt koma. See ei ole täisarv. 

Aga milline on kõige lähemal täisarvuga 10/01 või 0,1? Jah, see selline on null. 0.1 on niimoodi palju. Ja 1 on see palju. Nii 10/1 on lähemal 0, kui see on üks. 

Ja mis siis C on teinud juba us-- Selline sest me rääkisime see mina-- on kärpimisel, et täisarv. See võtab väärtust, mis omakorda on peaks olema midagi 0,1000, 0 ja nii edasi. Ja see kärpimine kõike pärast koma nii et kõik käesoleva kraami, sest see ei mahub mõiste täisarv, mis on lihtsalt number nagu negatiivne 1, 0, 1, üles ja alla, ta viskab ära kõik pärast koma, sest sa ei sobi koma aastal täisarv definitsiooni. 

Nii et vastus siin on null. Niisiis, kuidas me seda parandada? Me peame teine ​​lahendus kõik koos. Ja me saame seda teha, on järgmine. 

Lubage mul minna ja luua uusi faili, see üks nn floats.c. Ja salvestada see siin samas kataloogis, float.c. Ja las ma minna ja kopeerida mõned, et koodi varem. 

Kuid selle asemel, et int, teeme selle ära. Anna mulle Murdarv nimetatakse x. Kui ujukoma väärtus on lihtsalt sõna otseses mõttes midagi ujuva punkti. See võib liikuda vasakule, paremale. See on tõeline number. 

Ja andke mulle helistada ei saada int, kuid saavad float, mis oli ka üks menüü valikuvarianti C250 raamatukogu. Muudame y sularahaga. Nii et see muutub saada sularahaga. 

Ja nüüd, me ei taha, et pistik ints. Selgub, peame kasutama protsenti f float, protsenti f float, ja nüüd salvestada. Ja nüüd, pöialt, et ujukite, kena, dot kaldkriipsuga ujub. x saab olema üks 1. y Saab olema 10 uuesti. 

Ja kena, OK minu Lisaks on õige. Lootsin rohkem, aga ma unustasin seda kirjutada. Nii lähme ja määrata see loogikaviga. 

Lähme edasi ja ostke järgmine. Me lihtsalt teha väike kopeeri ja kleebi. Ja ma lähen ütlen miinus. 

Ja ma ei ütle korda. Ja ma ütlen lahku. Ja ma ei kavatse seda teha moodul, mis ei ole nii Sobiv siin, jagatud f ja korda pluss-- OK, teeme seda uuesti. 

Tee ujukid, dot kaldkriipsuga ujukid, ja 1, 10, Ja-- kena, ei, OK. Nii et ma olen idioot. Nii et see on väga levinud infotehnoloogia teha rumalaid vigu niimoodi. 

Sest pedagoogilistel eesmärkidel, mida ma tõesti tahtsin teha oli muuta teaduse siin pluss, miinus, et korda, ja jagada, kui sa loodetavasti märganud Selle tegevuse jooksul. Vaatame nüüd uuesti kompileerida seda programmi teha dot kaldkriipsuga ujub. 

Ja kolmandat korda, olgem kas see vastab minu ootustele. 1, 10, siseneda, jah, OK, 1.000, jagatud 10.000, on 0,100000. Ja selgub, et me saame kontrollida, kui palju numbrid on pärast neid komakohani. Me tegelikult on. Me tuleme tagasi, et. 

Aga nüüd, tegelikult matemaatika on õige. Niisiis, jälle, milline on Buffee siin? Selgub, et C on mitte ainult lihtsalt strings-- ja tegelikult seal ei ole tõesti, sest me lisada need koos CS50 raamatukogu. Aga seal ei ole lihtsalt ints. 

On ka hõljub. Ja selgub, hunnik muid andmeid tüüpi ka, et me kasutame enne pikk. Selgub, kui soovite ühte iseloomu, ei märgijada, mida saab kasutada vaid paalia. 

Selgub, et kui sa tahad bool, tõeväärtuse, õige või vale ainult, Tänu CS50 raamatukogu oleme lisada C bool andmete tüübi samuti. Aga see on olemas ka palju ka teistesse keeltesse. Ja selgub, et mõnikord vaja suuremat numbrit siis tulevad vaikimisi koos ints ja ujub. 

Ja tegelikult, topelt on mitmeid mis kasutab ole 32 bitti, kuid 64 bitti. Ja pikk pikk on see arv kasutab ole 32 bitti vaid 64 bitti, vastavalt ujukoma väärtused ja täisarvud, vastavalt. Nii saab tegelikult nüüd vaata seda tegevust. 

Ma lähen edasi minna siin ja klopsima ühe teise programmi. Siin ma lähen edasi minna ja ärge hulka CS50.h. Ja lase mul minna, sisaldavad standard IO.h. 

Ja märkad midagi funky siin toimub. See ei ole värvikoodiga asju samamoodi nagu enne. Ja selgub, et kuna ma ei ole saatnud asi faili nimi. 

Ma nimetan seda ühe sizeof.c ja vajuta Save. Ja pane tähele, mis juhtub minu väga valge koodi vastu, et musta tausta. Nüüd, vähemalt seal mõned lilla seal. Ja see on süntaksit esile. 

Seda sellepärast, et lihtsalt olen ütles IDE millist tüüpi faili see on andes talle nime ja spetsiaalselt faililaiend. Nüüd saab minna ja seda teha. Ma lähen edasi minna ja väga lihtsalt välja printida following-- bool on protsenti LU. 

Me tuleme tagasi et üks hetk. Ja siis ma lähen print suurus bool. Ja nüüd, lihtsalt säästa ise mõnda aega, ma olen kavatsevad teha kogu hunnik neid korraga. Ja eriti, ma lähen muuta see süsi ja süsi. See üks, ma lähen muuta kahekordse ja topelt. 

See üks, ma lähen muuta float ja sularahaga. See üks, ma lähen muuta int ja int. Ja see, et ma lähen muuta, et pikk pikk. Ja see on ikka võtmist pikka aega, kaua kaua. 

Ja siis lõpuks andsin ise liiga palju, string. Selgub, et C, seal on erilist operaator nimetatakse suurus, mis on sõna otseses mõttes läheb, kui joosta, ütle meile, suurus Kõigi nende parameetrite. Ja see on nii, nüüd, saame ühendada tagasi et eelmisel nädalal toimunud arutelu andmete ja esindamine. 

Lubage mul minna ja koostada suurus dot kaldkriipsuga suurus. Ja vaatame. Selgub, et C, konkreetselt CS50 IDE, konkreetselt operatsioonisüsteem Ubuntu, mis on 64-bitise operatsioonisüsteemi süsteem sel juhul bool läheb kasutada ühe baidi ruumi. See, kuidas suurust mõõdetakse, ei bittides, kuid baiti. Ja meenutada, et üks bait on kaheksa bitti. Nii bool, kuigi sa tehniliselt on vaja ainult 0 või 1, see on natuke raiskav kuidas oleme rakendanud. See on tegelikult kavatse kasutada kogu byte-- nii et kõik nullid, on võibolla kõik need, või midagi sellist, või lihtsalt üks 1 hulgast kaheksa bitti. 

Süsi, vahepeal kasutati märk nagu ASCII kohta eelmisel nädalal, saab olema üks märk. Ja et synchs up meie mõiste see on enam kui 256 bits-- pigem synchs üles et oleks mingit pikem kui 8 bitti, mis annab meile nii palju kui 256 väärtused. Topelt läheb 8 baiti ehk 64 bitti. 

Ujuk on 4. Int on 4. Pikk, pikk on 8. Ja string on 8. Aga ei muretse. Me läheme koorida tagasi, et kiht. Selgub, stringid saab olla pikem kui 8 baiti. 

Ja tõesti, me oleme kirjutanud stringid juba, tere, pikem kui 8 baiti. Aga tuleme tagasi et üks hetk. Aga ära võtta siin on järgmine. 

Iga arvuti on ainult piiratud mälu ja ruumi. Saad salvestada nii palju failid Mac või PC. Saad salvestada nii palju programme RAM töötab korraga pruugi isegi virtuaalne mälu, sest sul on piiratud kogus RAM. 

Ja just picture-- kui olete kunagi avanud sülearvuti või tellitud ekstra mälu arvutit, siis ei pruugi teada, et sees arvuti on midagi, mis näeb välja natuke niimoodi. Nii et see on lihtsalt ühise firma nimega Ülioluline mis muudab RAM arvuteid. Ja RAM on koht, kus programmid elame samas nad töötavad. 

Nii et iga Mac või PC, kui kahekordistada Klõpsake programmi, ja see avab, ja see avab mõned Wordi dokumenti või midagi sellist, ta salvestab selle ajutiselt RAM, sest RAM on kiirem kui arvuti kõvakettal või solid state disk. Nii et see on just seal, kus programmid minna elada, kui nad töötavad, või kui failid on kasutatud. 

Nii et teil on asju, mis tunduvad niimoodi sees oma sülearvuti, või veidi suuremad asjad sees oma töölauale. Aga võti on sul on ainult hulga neid asju. Ja seal on ainult piiratud kogus riistvara istub see laua paremale siin. 

Niisiis, kindlasti ei saa me hoida lõpmata kaua numbrid. Ja veel, kui te arvate tagasi algkool, mitu numbrit ei sa pead õige ühe koma? Selles küsimuses, kui palju numbreid saab sul on vasakul koma? Tõesti, lõpmata palju. 

Nüüd inimesed saaksid üksnes tea, kuidas hääldada miljonit ja miljard triljonit ja Kvadriljoona ja kvintiljon. Ja ma surudes piirid minu understanding-- või minu-- ma aru numbrid, kuid minu hääldust numbrid. Aga nad saavad lõpmata suur koos lõpmata palju numbreid vasakule või paremal koma. 

Aga arvutid on ainult piiratud kogus mälu, hulga transistorid, et hulga lambid sees. Mis juhtub, kui sa ruum otsa? Teisisõnu, kui te arvan, et tagasi eelmisel nädalal kui me rääkisime numbrid ise esindab binaarne, Oletame, et meil See 8-bitise väärtuses siin. 

Ja meil on seitse 1-ja üks 0. Ja oletame, et me tahame lisada 1 selle väärtust. See on tõesti suur hulk praegu. 

See on 254, kui ma mäletan matemaatika eelmisel nädalal õigus. Aga mis siis, kui ma saan muuta et kõige parempoolsem 0 kuni 1? Kogu numbri järgi Loomulikult saab kaheksa 1-. Nii et me oleme ikka hea. 

Ja et ilmselt esindab 255, kuigi sõltuvalt kontekstist see võiks tegelikult esindavad negatiivse numbriga. Aga sellest pikemalt mõni teine ​​kord. See kõik tundub nii umbes koguni võin loota. 

Nüüd on ainult 8 bitti. Ja mu Mac, kindlasti, on viis rohkem kui 8 bitti mälu. Aga see ei ole piiratud. Nii sama argument kehtib ka siis, kui me rohkem neist need ekraanile. 

Aga mis juhtub, kui sa oled ladustamiseks see number 255, ja soovite loendada 1 natuke suurem? Sa tahad minna 255-256. Probleem on muidugi see, et kui sa alustada nullist nagu eelmisel nädalal, sa ei saa loendada kui 256, rääkimata 257, rääkimata 258 m, sest mida juhtub, kui lisada 1? Kui sul vana algkool lähenemine, paned siia 1, ja siis 1 pluss 1 on 2, kuid see on tegelikult null, siis kannavad 1 kanda 1, kanda 1. Kõik need asjad, Nende 1-, lähevad nulli. Ja sa likvideerida, jah, kui keegi märkis, 1 vasakul küljel. Aga kõike saab tegelikult näha ja sobivad mälu just kaheksa 0 tema, mis tähendab, mingil hetkel, kui sa, arvuti, Üritasin lugedes piisavalt kõrge up, sa oled läheb ümbritsev tundub, null või isegi negatiivne numbrid, mis on isegi madalam kui null. 

Ja me saame sellist näha. Lubage mul minna ja kirjutada tõeline kiire programm siin. Lubage mul minna ja kirjutada programmi nimega voolata. Kaasa CS50.h sisaldama standard IO.h-- oh, Ma tõesti vastamata minu süntaksi esiletõstmine. Nii saab salvestada seda overflow.c. 

Ja nüüd int main void-- ja enne pikk, jagame tagasi tulla, mis selgitab, miks hoiame kirjalikult int main void. Aga nüüd, lähme lihtsalt teha see, enesestmõistetavalt. Anname endale int, ja initsialiseerida see 0. 

Olgem siis teha int i saada zero-- tegelikult, teeme lõputu silmuse ja vaata, mis juhtub. Kuigi tõsi, siis olgem välja trükkida n on protsenti i, backslash n, plug-in n. Aga nüüd, teeme n saab n + 1. 

Nii teisisõnu, iga iteratsiooni see lõputu silmuse, Võtame n väärtus, ja lisage 1 sellele ja seejärel salvesta tulemus tagasi n vasakul. Ja tegelikult, me oleme näinud süntaks veidi nagu seda lühidalt. Lahe trikk on selle asemel kirjalikult kõik selle läbi, tegelikult võite öelda n pluss võrdub 1. 

Või kui te tõesti tahate olla väljamõeldud, sa ei saa öelda, n pluss pluss semikooloniga. Aga need kaks viimast on vaid mida me tahaks helistada süntaktiline suhkur Esimest asi. 

Esimene asi on selgem, täiesti trahvi, täiesti õige. Aga see on rohkem levinud, ma ütlen. Nii et me teeme seda hetkeks. 

Olgem nüüd teha ülevoolu, mis kõlab üsna kurjakuulutav, dot kaldkriipsuga ülevoolu. Vaatame, n Läheb päris suur. Aga mõtleme, kui suur saab n saada? 

n on int. Nägime hetk tagasi suurusele Näiteks, et int on neli baiti. Me teame eelmisel nädalal neli baiti on 32 bitti, sest 8 korda 4, mis on 32. See saab olema 4 miljardit. 

Ja meil on kuni 800.000. See saab võtta igaveseks loendada ma võib-olla saab. Nii et ma lähen edasi minna, kui sa võiksid enne pikk, tabas kontroll C- ausalt, Control C, palju, kus kontroll C üldiselt vahenditega tühistada. Kahjuks, sest see töötab pilve mõnikord pilved on sülitada välja nii palju asju, nii palju toodangut, see läheb võtta natuke aega minu panus saada pilv. Nii et kuigi ma tabanud Kontroll C mõni sekund tagasi, See on kindlasti pool mõju lõputu silmuse. 

Ja nii, et sellistel juhtudel, me oleme jäta see olla. Ja me ei kavatse lisada veel terminaliaken siia koos pluss, mis muidugi ei niimoodi, sest see on ikka mõelnud. Ja olgem minna ja olla veidi enam mõistlik. 

Ma lähen edasi minna ja teha See ainult Finitely mitu korda. Kasutame jaoks silmus, mida ma vihjas varem. Teeme ära. Anna mulle veel muutuja int i saab 0. i on väiksem kui oletame, 64 i ++. Ja nüüd lubage mul minna ja print välja n protsenti i, koma n. Ja siis n-- see on ikka aega võtab igavesti. Teeme ära. 

n saab n korda 2. Või me võiks olla väljamõeldud ja teha korda võrdub 2. Aga ütleme lihtsalt n võrdub ise korda 2. Teisisõnu, selles uus versioon programmist, Ma ei taha oodata igavesti alates nagu 800,000 kuni 4 miljardit eurot. Lähme lihtsalt selle üle koos. 

Olgem tegelikult topelt n iga kord. Mis meenutavad, kahekordistumine on vastand võttes muidugi. Ja arvestades, et eelmisel nädalal on meil midagi uuesti ja uuesti, ja jälle, super kiire, kahekordistamine kindlasti meid 1 kuni suurima võimaliku väärtus, et me võime loota, et koos int. 

Nii saab seda täpselt. Ja me tuleme tagasi selle enne pikk. Aga see jällegi on nagu korduse ploki nullist. Ja võite kasutada seda enne pikk. 

See tähendab lihtsalt loota nullist kuni, kuid mitte võrdne, kuni 64. Ja iga iteratsiooni Selle loop, muudkui incrementing i. Nii i ++ - ja seda üldiselt ehitada real 7 on lihtsalt super levinum viis korrata mõned read kood, mõned arv kordi. Milline rida koodi? Need looksulg, kui võis väita nüüd, tähendab, tehke järgmist. 

See on nagu Scratch, kui tal on kollane plokid ja teised värvid sellist omaks või kallistada teisi plokke. See, mida need lokkis traksid on siin teed. Nii et kui ma sain oma süntaks right-- sa näen porgand sümbol C vahendid see on mitu korda olin püüab lahendada seda probleemi. Nii saab vabaneda, et üks kokku, ja selle akna sulgeda. Ja me kasutame uuega. Tee ülevoolu, dot kaldkriipsuga ülevoolu, Enter, kõik korras, tundub halb alguses. Kuid olgem kerida ajas tagasi, sest ma tegin seda 64 korda. 

Ja teate esmakordselt n on 1. Teiseks aeg, n on 2, siis 4, siis 8, siis 16. Ja tundub, et niipea kui Ma saan umbes 1 miljard kui ma seda kahekordistada jälle, et peaks mulle 2 miljardit. Aga selgub, et see on õige Ots. 

Ja nii see tegelikult ülevool int alates 1 miljard ümmarguselt negatiivne 2 miljardit, sest täisarv, Erinevalt numbrid me omandasid eelmisel nädalal võib olla nii positiivne kui ka negatiivne tegelikkuses ja arvuti. Ja nii vähemalt üks neist bitti on tegelikult varastatud. Nii et me tõesti ainult 31 bitti, või 2 miljardit võimalikke väärtusi. 

Aga nüüd, Buffee on üsna lihtsalt, mida iganes need numbrid ja mida iganes matemaatika on midagi halba juhtub lõpuks sest lõpuks sa üritad permute bitti liiga palju kordi. Ja sa tegelikult minna kõik 1-äkki kõik 0-ndatel, või äkki lihtsalt mõne muu mustriga, et see selgelt, olenevalt kontekstist, võib tõlgendada kui negatiivset arvu. Ja nii tundub kõrgeim ma võib loota selle konkreetse programmi on ainult umbes 1 miljard. Aga seal on osaline lahendus siin. Tead mida? 

Las ma muuta alates int pikk pikk. Ja las ma minna siin ja say-- ma lähen Selle muutmiseks allkirjastamata pikk. Või vaatame, ma ei mäleta ise. 

Lähme edasi ja teha ülevoolu. Ei, see pole see, Libeeria, aitäh. Nii et mõnikord rõkkama võib olla kasulik. Ma ei mäleta, mis formaadis specifier oli pikka pikk. 

Aga tõepoolest rõkkama ütles mulle. Roheline on mingi hea, ikka tähendab, et sa tegid vea. See on aim, et ma mõtlesin Libeeria. 

Nii et lubage mul võtta seda nõuannet, pikk kaua kümnendnumbrina, salvestada et. Ja andke mulle uuesti, see, dot kaldkriips ülevoolu, Enter. Ja nüüd, mida on lahe on see. 

Kui ma kerida ajas tagasi, me ikka alustada lugedes samal place-- 1, 2, 4, 8, 16. Teade, saame kõiki viis kuni 1 miljard. Aga siis me ohutult saada 2 miljardit. 

Siis saame 4 miljardit, siis 8 miljardit, 17 miljardit. Ja me läheme suurem ja suurem ja kõrgem. Lõpuks ka see puruneb. 

Lõpuks pika pikk, mis on 64-bitine väärtus, ei 32-bitine väärtus, kui loete liiga kõrge, siis ümbritsev 0. Ja sel juhul, me juhtumisi lõpuks negatiivse numbriga. 

Seega on see probleem. Ja selgub, et see Probleem ei ole nii kauge. Kuigi olen teadlikult tekitatud seda neid vigu, Selgub näeme seda liiki kõik meie ümber, või vähemalt mõned meist teha. 

Nii Lego Star Wars, kui olete kunagi mänginud mängu, Selgub võid minna ümber purustamine asju LEGO maailma ja koguda münte, sisuliselt. Ja kui te olete kunagi mänginud Selles mängus liiga palju aega, kuna see nimetu üksikud siin ei koguarv müntide, et saate koguda on, tundub, 4 miljardit. 

Nüüd, see on tegelikult ümardatud. Nii LEGO üritasin hoida asjad kasutajasõbralik. Nad ei teinud seda täpselt 2 32 võimu kohta eelmisel nädalal. Aga 4 miljardit on põhjus. Tundub, selle teabe põhjal, et LEGO ja ettevõtte, et tegi selle tegelik tarkvara, otsustas et maksimaalne arv münte kasutaja võib koguneda on tõepoolest 4 miljardit, sest nad valisid oma koodi kasutada ei ole pikka ilmselt aga lihtsalt täisarv, allkirjastamata täisarv, ainult positiivne täisarv, kelle max väärtus on umbes nii. Noh, siin on veel üks naljakas üks. Nii mängu Civilization, mis mõned võite olla tuttav, kellel Selgub, et aasta tagasi seal oli viga selles mängus, mille kui sa mängisid rolli Gandhi mängu, selle asemel, et teda on väga patsifist, selle asemel oli uskumatult, uskumatult agressiivne mõningatel tingimustel. Eriti nii, et Civilization teosed on see, et kui te, mängija, vastu demokraatia, oma agressiivsus skoor läheb decremented kahte, seega miinus miinus ja siis miinus miinus. 

Nii et sa lahutama 2 alates oma tegelikku itereerimine. Kahjuks, kui teie itereerimine on algselt 1 ja lahutad 2 saada Pärast vastuvõtmist demokraatia nagu Gandhi siin võiks teinud, sest ta oli väga passive-- 1 ulatuse kohta agressiivsus. Aga kui ta võtab vastu demokraatia, siis ta läheb 1 kuni negatiivne 1. 

Kahjuks nad olid kasutades allkirjastamata numbrid, mis tähendab, et nad ravida isegi negatiivne numbreid, nagu nad olid positiivsed. Ja selgub, et positiivne samaväärne negatiivne 1, tüüpiline arvutiprogramme, on 255. Nii et kui Gandhi vastu demokraatia ning seega on tema agressiivsus skoor vähenes see tegelikult rullides ringi 255 ja teeb temast kõige agressiivse iseloomu mängus. Nii saate Google üles selle. Ja see oli tõepoolest juhusliku programmeerimine viga, kuid mis on kantud üsna pärimuse ajast. 

See on kõik tore ja armas. Rohkem hirmutav on see, kui tegelik Reaalses maailmas seadmeid, mitte mänge on need samad vead. Tegelikult just aasta tagasi artikkel tuli välja umbes Boeing 787. 

Ja artikli alguses lühidalt loeb natuke kauge. Aga ta ütles seda, tarkvara haavatavust Boeingu uus 787 Dreamliner jet on võivad põhjustada piloodid kaotada kontrolli õhusõiduki, võimalusel keskel lennu FAA ametnikud hoiatas lennufirmad viimasel ajal. See oli määramist mis mudel 787 lennuk, mis on powered pidevalt 248 päeva võivad kaotada kõik vahelduvvoolu, AC, elektrivoolu tõttu generaator juhtseadmed, GCUs samaaegselt laskumist ei turvarežiimis. See on selline mind kaotamas. Aga teates oli märgitud, OK, nüüd ma sain selle, tingimus oli tingitud tarkvara võidelda sisemise generaator kontrolli üksused, mis ujutab pärast 248 päeva pidevat toidet. Meil on välja käesoleva märgata, et vältida kadu Kõigi vahelduvvoolu elektrivõimsust võim, mis võib põhjustada kaotus kontrolli lennuki. 

Niisiis, sõna otseses mõttes, on mingi täisarv, või samaväärsete andmete tüübi, kasutatakse tarkvara tegelikus lennuk et kui sa hoida oma lennuk piisavalt kaua, mis ilmselt võib juhtuda siis, kui sa oled lihtsalt töötab neid pidevalt ja kunagi pistiku Teie lennuk, tundub, või Lastes oma patareid surra, lõpuks loeb üles ja üles, ja üles ja üles ja üles ja üles. 

Ja olemuselt piiratud kogus mälu ei uputa, nullib null või mõne negatiivse väärtusega, kõrvalnähuna mis on hirmsa tõeline reaalsus et lennuk võib olla vaja tuleb taaskäivitada, tõhusalt, või võivad langeda, mis veel hullem, kui see lendab. Nii selliseid küsimusi on endiselt meiega, even-- see oli 2015. artiklit, enam hirmutav Kui sul ei ole tingimata mõista, mõista, või ennetada seda tüüpi vigu. 

Nii selgub seal on üks teine Halb asi andmete esitamisel. Selgub, et isegi ujukid on Selline ekslik, sest ujukite Ka Pakkusin on 32 bitti või võibolla 64 kui kasutad topelt. Aga see on ikka piiratud. 

Ja saak on, et kui saate pane lõpmatu arv numbrid pärast koma, ei ole nii, sa võib esindada kõiki võimalikke numbrid, mis meile õpetati algkool ei eksisteeri maailmas. Arvuti sisuliselt peab valida alamhulk need numbrid esindada täpselt. 

Nüüd saab arvuti ringi võibolla natuke, ja võimaldab teil umbes poest mis tahes arvu võite tahta. Aga intuitiivselt, kui te on hulga bitti, saab ainult permute neid nii palju piiratud võimalusi. Nii et sa ei saa kuidagi kasutab lõplikku arvu permutatsioon bittide, mustrid ühtede ja nullide, esindada lõpmatu arvu numbrid, mis viitab sellele, et arvutid võiks väga hästi olla pikali meile mõnikord. 

Tegelikult teeme selle ära. Lubage mul minna tagasi CS50 IDE. Lubage mul minna ja luua väike programm nimetatakse ebatäpsus, mis näitab, et arvutid on tõesti ebatäpne. 

Ja las ma minna ja alustada mõned, et koodi enne, ja nüüd lihtsalt teha järgmist. Lubage mul minna ja teha printf, protsenti f, backslash n, 1 jagatud 10. Teisisõnu, olgem sukelduda sügavamale 1/10, nagu 1 ja jagatud 10. Kindlasti saab arvuti esindavad 1/10. 

Nii saab minna ja teha ebatäpsus. Vaatame. Formaat täpsustab Topelt. Aga väide on int. Mis toimub? 

Oh, huvitav, nii et see on õppetund enne. Ma räägin, hei, arvuti näidata mulle ujuki protsenti f. Aga ma andes 2 ints. Nii selgub, võin kinnitada Seda paar võimalust. 

Ma võiks lihtsalt omakorda üks võetud 1,0 ja 10 arvesse 10,0, mis tõepoolest mõjuda teisendades need floats-- ikka loodetavasti sama number. Või selgub, et midagi me näeme jälle enne pikk. Sa võid enamus numbrid. 

Võite kasutada seda Sulgudes väljendus, siis võib öelda, hei, arvuti, seda 10, mis ma tean, on int. Aga seda ravida, siis, nagu ta on sularahaga. Aga see tundub põhjendamatult keeruline. 

Meie eesmärkide täna olgem lihtsalt sõna otseses mõttes tutvustab neid murdarve Kümnendkohaga, niimoodi. Lubage mul minna ja kordamisega, teha ebatäpsuse, hea, dot kaldkriipsuga ebatäpsuse, siseneda. OK, ootame head. 

1 jagatud 10, vastavalt minu Mac siin on tõesti 0,100000. Nüüd olin õpetanud algkool seal peaks olema lõpmatu arv 0 on. Nii saab vähemalt proovida näha mõned neist. Selgub, et printf on vähe Kasvataja veel, kui me olen kasutanud. Selgub, sa ei pea täpsustada lihtsalt protsenti f, või lihtsalt protsenti i. Võite tegelikult täpsustada teatud kontrolli võimalusi siin. 

Täpsemalt, ma lähen öelda, hei, printf, tegelikult näitab mulle 10 kohaga punkti. Nii tundub natuke imelik. Aga sa ütled protsenti, dot, mitu numbrit soovite näha pärast koma ja siis f korter, lihtsalt sellepärast, et see on Mis dokumendid ütleb. Lubage mul minna ja päästa seda. 

Ja teate ka, ma saan väsinud retyping asju. Nii et ma olen lihtsalt seades üles ja noolt minu võtmed siin. Ja kui ma saan pihta üles, saab näha kõiki käske et ma tegin või valesti tehtud. 

Ja ma lähen edasi minna praegu ja tegelikult ei kasuta, et ilmselt. Tee ebatäpsus, dot kaldkriips imprecision-- nii mida ma õpetanud algkool on korras. Isegi kui ma printida kuni 10 kohaga asetab ta tõepoolest on 0,10000. Aga tead mis? 

Lähme natuke ahne. Oletame, nagu näitavad mulle 55 juhib pärast koma. Olgem tõesti seda programmeerida läbi spin. Lubage mul uusversioon seda teha ebatäpsuse, dot kaldkriipsuga ebatäpsus. 

Ja siin me läheme. Teie lapsepõlve oli vale. Ilmselt 1 jagatud 10 on tõepoolest 0.100000000000000005551115123-- 

Mis toimub? Noh, selgub, kui te sellist otsima piisavalt kaugele aluseks oleva esindatuse seda number, siis tegelikult ei ole just 10/01 või 0,1 ja lõpmatu arv nulle. Nüüd, miks see nii on? 

Noh, kuigi see on lihtne number meile inimestele, 1 jagatud 10, see on ikka üks lõpmata palju numbrid, et me võiks mõelda. Aga arvuti saab esindada ainult Finitely palju nii numbreid. Ja nii efektiivselt, mida arvuti näitab meile on lähimate ühtlustamise arvu tahame uskuda on 1/10, või tõesti 0,10000 lõpmatuseni. 

Pigem küll, see on nii lähedal kui saan. Ja tõepoolest, kui te vaatate all kapuuts, sest me oleme siin vaadates 55 numbrit pärast koma, me tegelikult näha, et reaalsus. Nüüd, kui kõrvale, kui olete kunagi näinud movie-- enamik teist ilmselt haven't-- kuid Superman 3 mõned aastad tagasi Richard Pryor sisuliselt võimendatud seda Tegelikkuses oma ettevõte varastada palju fraktsioonide ja fraktsioonid penni, sest company-- nagu ma mäletan, see on olnud while-- oli sisuliselt visata ära midagi, mis ei sobinud sisse mõiste senti. 

Aga kui sa küündivad kõik need väike, väike, väike numbrid uuesti ja uuesti ja uuesti, saate, kui Tema puhul teha hea summa raha. 

Sama idee oli ripitud maha Uuemas, kuid nüüd vanemad filmi, mida nimetatakse kontoriruumid, kus poisid selles filmis, tegi sama asja, keeras ta üles täielikult, sattus liiga palju raha oma pangakontole. See kõik oli väga kahtlane. Aga lõpus päeval, ebatäpsus on kõikjal meie ümber. 

Ja see võib samuti olla hirmsa puhul. Selgub, et Superman 3 ja Office Space kõrvale, seal võivad olla väga reaalne maailma harude tegelikkusega ebatäpne esindatuse andmeid et isegi meie, inimesed, et Sel päeval ei pruugi mõista samuti peaksime või mäletan nii tihti, kui meil peaks. Ja tõesti, järgmine klipp on alates mõningaid väga reaalse maailma mõjusid, mis juhtub, kui sa ei mõista ebatäpsus, et võib juhtuda numbrid esindatus. 

[VIDEO PLAYBACK] 

-Computers, Me kõik oleme tulnud vastu sageli heidutav probleeme, mis täie them-- vead, viirused, ja tarkvara tõrgete väikeste hindadega maksma mugavuse. Aga kõrgtehnoloogilise ja suure kiirusega sõjaväe ja kosmoseprogrammi rakendused väikseim probleem võib suurendatakse sisse katastroof. 

4. juunil, 1996, teadlased valmis käivitada mehitamata Ariane 5 raketi. See vedas teadusliku satelliidid, mille eesmärk täpselt kindlaks, kuidas Maa magnetväljast suhtleb kus päikesetuul. Rakett ehitati Euroopa Kosmoseagentuuri ja välja tõsta selle rajatise rannikul Prantsuse Guajaana. 

-At Umbes 37 sekundit arvesse lend, nad esimest korda märkas, et midagi on valesti. Et pihustid olid pööramisega sisse viisil nad tegelikult ei tohiks. Umbes 40 sekundit arvesse lendu On selge, et sõiduk oli hädas. 

Ja siis nad tegid otsuse hävitada. Vahemikus ohutuse ohvitser, kellel tohutu tahtejõud, vajutas nuppu, õhku rakett, enne kui ta võiks saada ohtu inimeste ohutuse. 

-See Oli neiu reisi Ariane 5. Ja selle hävitamine võttis kuna selleks puudus varjatud raketi tarkvara. -The Probleem Ariane oli et seal oli see arv vaja 64 bitti väljendada. Ja nad tahtsid muuta see 16-bitine number. Eeldati, et number oli kunagi olema väga suur, et enamik neist numbrit 64-bitine arv oli nullidega. Nad olid valed. 

-The Võimetus ühe tarkvara vastu selline number loodud teine ​​oli keskmes rike. Tarkvara arendamine on saanud väga kulukas osa uue tehnoloogia. Ariane raketi on olnud väga edukas, nii palju tarkvara loodud see oli ka kasutatakse Ariane 5. 

-The Põhiline probleem oli see, et Ariane 5 oli kiirem, kiirendatud kiiremini. Ja tarkvara ei olnud moodustasid selle eest. 

-The Hävitamine raketi oli suur rahaline katastroof, kõik tingitud minut tarkvara viga. Aga see ei olnud esimene aega andmete konverteerimise probleeme oli vaevavad moodsa raketi tehnoloogia. 

-Kui 1991. aastal alguse esimese Lahesõja, Patriot rakettide kogenud Samalaadsed arvu muundamise probleemi. Ja tulemus 28 inimest, 28. Ameerika sõdurid, tapeti ja umbes 100 teised haavatud, kui Patriot, mis pidi kaitsta sissetulevad scuds, ei tule rakett. 

-Kui Iraak Kuveiti tungis ja Ameerikas käivitatud Desert Storm alguses 1991. aastal Patriot rakettide patareid lähetati kaitsta Saudi Araabia ja Iisraeli Iraagi Scud rakettide rünnakud. Patriot on USA keskmaarakettide pinna õhku süsteemi, mis on valmistatud poolt Raytheon ettevõte. 

-The Suurus Patriot interceptor ise on umbes umbes 20 jalga pikk. Ja see kaalub umbes 2000 naela. Ja see viib lõhkepea umbes, Ma arvan, et see on umbes 150 naela. Ja lõhkepea ise kõrge plahvatusohtlik, mis on fragmendid ümber. Korpust lõhkepea on mõeldud toimima nagu Jämejahu hallid. 

-The Raketid on läbi nelja konteineri kohta, ja veetakse poolhaagises. 

-The Patriot raketitõrjesüsteemi ulatub vähemalt 20 aastat. See oli algselt mõeldud kui õhutõrje rakettide tulistada alla vaenlase lennukid. Esimeses Lahesõjas, kui see sõda tuli mööda, armee tahtis seda kasutada tulistama scuds, mitte lennukid. 

Iraagi õhujõudude oli ei ole nii suur probleem. Aga sõjaväes oli mures scuds. Ja nii nad üritasid uuendada Patriot. 

-Intercepting Vaenlane rakett liigub mach 5 pidi olema raske piisavalt. Aga kui Patriot oli kiirustades võetud, armee ei olnud teadlik Iraagi muudatustest, mis tehakse oma scuds peaaegu võimatu tabada. 

-Mis Juhtus on scuds et olid tulemas olid ebastabiilsed. Nad olid wobbling. Selle põhjuseks oli iraaklastele, et saada 600 kilomeetri välja 300 kilomeetri vahemikus rakett, võttis kaal välja ees lõhkepea. Nad tegid lõhkepea kergem. 

Nüüd Patriot on püüab tulla juures Scud. Ja enamus aega, Valdav enamus ajast, see oleks lihtsalt lennata poolt Scud. Kui Patriot haldurid realiseeritud Patriot oma eesmärki täitnud, nad lõhkeda Patriot lõhkepea vältida võimalikke kaotusi kui see lubati langevad maapinnale. 

-See Oli see, mida enamik inimesi nägi, need suured fireballs taevas, ja vääriti kui pealtkuulamist Scud lõhkepeade. 

-Although Öösel taevas, patrioodid ilmunud olema edukalt hävitades Scuds, kell Dhahran, ei saa olla viga selle toimivuse. Seal Patriot radarisüsteem kaotanud jälgida sissetuleva Scud, ja kunagi käivitatud tõttu et tarkvara viga. See oli iisraellasi, kes esimesena avastas et enam süsteemi oli, mida pikem on lahknevus sai tänu kella varjatud süsteemis arvutisse. 

-Umbes Kaks nädalat enne tragöödia Dhahran, Iisraeli teatatud kaitseministeeriumil et süsteem oli kaotamas aega. Pärast umbes kaheksa tundi või töötab, nad märkasid, et süsteem oli muutumas märgatavalt vähem täpne. Riigikaitse osakond vastas ütleb kõik Patriot patareid mitte lahkuda süsteemid kohta juba pikka aega. Nad ei ole kunagi öelnud, mida pikka aega was-- kaheksa tundi, 10 tundi, 1000 tundi. Keegi ei teadnud. 

-The Patriot aku seisvad kasarmud kell Dhahran ja selle vigane sisemine Kell oli olnud üle 100 tunni ööl vastu 25. veebruar. 

-See Jälgida aega täpsusega umbes kümnendiku sekundit. Nüüd kümnendik teine on huvitav number, kuna see ei saa väljendada binaarne täpselt, mis tähendab seda ei saa täpselt modelleerida mis tahes kaasaegse digitaalse arvuti. On raske uskuda. 

Aga kasutada seda kui näidet. Võtame number üks kolmandik. Üks kolmandik ei saa väljendatud kohaga täpselt. Üks kolmandik on 0,333 kestnud lõpmatuseni. 

Ei ole nii teha, et absoluutne täpsus kohaga. See on täpselt selline probleem mis juhtus Patriot. Mida pikem on süsteem jooksis, siis hullem aeg viga sai. 

-Pärast 100 töötunni, siis viga ajal oli ainult umbes üks kolmandik sekundit. Aga nii suunatud rakett liigub mach 5, selle tulemuseks oli jälgimise viga üle 600 meetri. Oleks saatuslik viga sõdurite kohta, mida juhtus on Scud käivitamine oli avastatud varajase hoiatamise satelliiti ja nad teadsid, et Scud oli tulevad oma üldise suuna. Nad ei tea, kust see tuli. 

-See Oli nüüd kuni radar komponent Patriot süsteemi kaitsta Dhahran leida ja hoida jälgida sissetulevate vaenlane rakett. 

-The Radar oli väga tark. Oleks tegelikult jälgida asendit Scud, ja siis ennustada, kus see ilmselt oleks järgmine kord radari saata impulsi välja. See kutsuti erinevaid värava. 

-Siis, Kui Patriot otsustab piisavalt aega on edasi minna tagasi ja vaadata järgmise asukoht selle avastatud objekt, see läheb tagasi. Nii et kui ta läks tagasi vale koht, seda siis ei näe objekti. Ja ta otsustab, et ei ole objekt, see oli vale tuvastamise, ja langeb teele. 

-The Sissetulevad Scud kadus radari ekraanilt. Ja sekundit hiljem, rammisid kasarmus. Scud hukkus 28 ja viimane üks vallandati esimese Lahesõja. 

Traagiliselt uuendatud tarkvara saabus Dhahran järgmisel päeval. Tarkvara viga oli fikseeritud, sulgemine üks peatükk rahutu ajalugu Patriot rakett. 

[VIDEO PLAYBACK] DAVID J. Humala: Nii et see on kõik öelda, et need küsimused ülevoolu ja ebatäpsus on liiga reaalne. Nii et kuidas me saame siin? Meil algas räägi printf. Ka see funktsioon, mis trükib midagi ekraanil, ja me hiljem kehtestada mõned muud funktsioonid alates nn CS50 raamatukogu. Ja jätkame vaata neid õigel ajal. Ja meie, eriti, kasutatud get string, ja saada int, ja nüüd ka saada float, ja veel teised ikka kohtame ja kasutada end enne pikk. 

Aga mõnikord, on me juba näinud vajadust talletada, mida need funktsioonid poolt tagasi? Nad käsi meid tagasi string või int või float. Ja mõnikord peame panema, et string või int või float, kusagil. 

Ja salvestada neid asju, meenutavad vaid nagu Scratch, meil on muutujad. Kuid erinevalt Scratch, C on meil tegelik tüüpi ning variables-- andmeid tüüpi, rohkem generally-- nende seas, string, int, et float, ja need teised ikka. 

Ja nii kui me kinnitame muutujad C, me peame kuulutada meie andmetüüpe. See ei ole midagi, jagame pead tegema hiljem semestri nagu me üleminek teistesse keeltesse. Aga nüüd, me peame to a priori ette, selgitada arvuti, mis tüüpi Muutuva me tahame seda meile. 

Nüüd, vahepeal printida sellist liiki andmete liigid, meil öelda printf mida oodata. Ja me nägime protsenti s keelpillidele, ja protsenti i jaoks täisarvud, ja mõned teised juba. Ja need on lihtsalt nõuded visuaalse esitluse Nimetatud teabe. 

Ja kõik need olla tegelikult parametriseerisin või tweaked mingil viisil, Kui soovite täiendavaks kontrollimiseks tüüpi väljund, mis sa saad. Ja tegelikult, selgub, et mitte ainult on olemas backslash n uut liini. Seal on midagi muud nn backslash r reavahetuse, mis on sarnaneda rohkem vana kooli kirjutusmasina ja ka Windows kasutatud juba aastaid. 

Seal backslash t kaartidele. Selgub, et kui sa tahad topeltjutumärkide sees string Tuletame meelde, et oleme kasutanud topeltjutumärkide topelt tsitaat vasakul ja paremal lõpeb meie stringid siiani. See tundub segadusse asju. 

Kui sa tahad panna jutumärgid sisse keset string-- ja tegelikult see on segane näha. Ja et sa pead põgeneda, nii et rääkida, jutumärke midagi nagu, sõna otseses mõttes, kurakaldkriipsuga jutumärke. Ja seal on mõned muud veel. Ja me näeme rohkem neid, Tegelikus kasutuses enne pikk. 

Nii saab nüüd üleminek andmed ja esindamine, ja aritmeetika operaatorite kõik mis andis meile mõned hoone plokid, kellega mängida. Aga nüüd lähme tegelikult annab Meie ülejäänud sõnavara et meil oli juba Viimase nädala Scratch võttes pilk mõned teised konstruktide C- mitte kõik neist. Aga ideid me oleme umbes, et näha tõesti ainult rõhutada tõlge ühes keeles, Scratch, teise, C. 

Ja aja jooksul, me kiirenemist rohkem vahendeid meie tööriistakomplekt, niiöelda süntaktiliselt. Ja tõepoolest, näete, et ideed nüüd pigem tuttav eelmisel nädalal. Nii teeme seda. 

Lähme edasi ja klopsima programmi et tegelikult kasutab mõned väljendid, Boole'i ​​väljendus. Lubage mul minna siin ja luua uus fail. Ma nimetan seda condition.c. 

Lubage mul minna ja sisaldama CS50 raamatukogu. Ja las ma minna ja lisada standard IO.h meie funktsioonid, ja printf ja rohkem võrra. Annan endale, et stereotüüp on int main void, kelle selgituse jagame tagasi tulla tulevikus. 

Nüüd lubage mul minna ja anda mina int kaudu get int. Siis lase mul minna ja seda teha. Ma tahan öelda, kui ma ei less-- olgem eristada positiivne, negatiivne või null väärtused. 

Nii et kui ma on väiksem kui null, lase mind lihtsalt see programm lihtsalt öelda, negatiivne, backslash n, teine kui i on suurem kui null. Nüüd ma muidugi ei ütle printf positiivne, backslash n. Ja siis teine ​​kui-- ma võiks seda teha. 

Ma võiks teha, kui ma võrdub 0. Aga ma oleksin tegemisel Vähemalt üks viga juba. Tuletame meelde, et võrdusmärki on ei ole võrdsed, sest meie, inimesed teavad seda. 

Aga see on omistamisoperaatorile. Ja me ei taha võtta 0 kohta õige ja pane see i vasakul. Nii Selle vältimiseks või võibolla väärkasutamise võrdusmärki, Inimestel otsustas mõned aastad tagasi et paljudes programmeerimiskeeltes kui soovite kontrollida võrdsust vahel vasakul ja paremal, sa tegelikult kasutada võrdne võrdsete. Nii et sa tabanud võrdusmärgi kaks korda. Kui soovite määrata paremalt vasakule, saate ühe võrdusmärk. Nii et me võiks teha see-- mujal kui i võrdub võrdub nulliga. 

Ma võiks siis minna ja avada minu looksulg, ja öelda, printf 0, backslash n, tehtud. Kuid pidage meeles, kuidas need kahvlid maantee saab tööd. Ja tõesti, mõelge loogika. i on mitmeid. On täisarv, konkreetselt. Ja see tähendab, et see saab olema vähem kui 0 või suurem kui 0 või 0. Seega on selline see kaudsete vaikimisi juhul. 

Ja nii me võiks lihtsalt meeldib Scratch, loobuda muud kui, ja lihtsalt öelda muud. Loogiliselt, kui teile programmeerija teada, seal on ainult kolm ämbrid, kuhu stsenaarium võib fall-- esimene, Teise või kolmanda Selles case-- ei viitsinud lisada täiendavaid täpsusega ja täiendavad loogika seal. Lihtsalt edasi minna Vaikimisi juhul on mujal. 

Nüüd saab minna pärast selle salvestamist, teha tingimused dot kaldkriips conditions-- ei ole suur kasutajaliides, sest ma ei ajendades kasutaja, nagu varem mainisin. Aga see on hea. Hoiame seda lihtne. Proovime number 42. Ja see on positiivne. Proovime arv negatiivne 42, negatiivne. 

Proovime väärtus 0. Ja tõepoolest, see toimib. Nüüd näete probleeme enne kaua, katsetamine asju kolm korda ilmselt ei piisa. Sa ilmselt tahad katsetada mõningaid suurem number, mõned väiksemad numbrid, mõnes nurgas juhtudel, kui tuleme neid kirjeldada. 

Aga nüüd, et see on päris lihtne programm. Ja ma olen päris kindel, loogiliselt, et ta kuulub kolm juhtumit. Ja tõepoolest, kuigi me lihtsalt keskendunud võimalike negatiivsete ebatäpsust ja ülevoolu, in Tegelikkuses kus paljud CS50 probleeme, me ei muretse umbes, kogu aeg, neid küsimusi ülevoolu ja laialivalguvus, sest tegelikult in C, see on tegelikult mitte kõik, et lihtne vältida neid asju. Kui soovite loendada üles suurem ja suurem, ja suurem, Selgub on tehnikat saab kasutada, mis tihti hõlmavad asju nimetatakse raamatukogud, kogud kood, mis teised inimesed kirjutasid, mida saab kasutada, ja teiste keeltega, nagu Java ja teised, tegelikult teha palju lihtsam loota isegi suurem. Nii see tõesti on mõned neist ohtudest funktsioon keelt kasutada. Ja lähinädalatel, jagame vaata, kui ohtlik C tõesti võib olla, kui sa ei kasuta seda korralikult. Aga sealt, ja Python ja JavaScript, siis me kihina täiendavat kaitset, ja kestab vähem on neid riske. 

Nii saab teha natuke rohkem Huvitav loogika meie programmi. Nii et lubage mul minna ja luua programmi nimega Loogiline lihtsalt et ma saaks mängida mõned tegelikku loogikat, logical.c. Ma lihtsalt kopeeri ja kleebi mõned koodi varasemate nii et ma saan tagasi Selle kena lähtepunkt. 

Las ma seekord teha char C. Ma annan talle nime C lihtsalt sellepärast, et see on tavalised, saada iseloomu kasutaja. Ja olgem teeselda, nagu Ma rakendamise osas Selle Rm programmi eemaldada Programm enne seda küsitakse kasutaja eemaldada faili. Kuidas me seda teeme? 

Ma tahan öelda, kui C võrdub võrdub, tsitaat lõppeb, y, siis ma lähen eeldada et kasutaja on valinud jah. Ma lihtsalt printida jah. Kui see tegelikult kirjalikult eemaldamise programmi me võiks eemaldada faili rohkem rida koodi. Aga me hoiame see lihtne. 

Või kui c võrdub võrdub n-- ja nüüd siin, ma lähen öelda, Kasutaja peab olema tähendas ole. Ja siis teine, tead mis? Ma ei tea, mida veel kasutaja saab sisestada. Nii et ma lihtsalt ütlen, et mis on viga, mida iganes ta tegelikult kirjutada. 

Mis siin toimub? Seal on põhimõtteline erinevus versus mida ma olen teinud varem. Double hinnapakkumisi, jutumärgid, topelt hinnapakkumisi, ja veel, ülakoma, ülakoma. Selgub, C, et kui soovite kirjutada string, sa kasutada jutumärkide, just nagu me oleme kasutanud kogu aeg koos printf. 

Aga kui sa tahad tegeleda vaid Ühe märgi nn paalia, siis tegelikult kasutada ülakoma. Neile, kes pole programmeeritud Enne, siis ei pruugi olla pidid muretsema selle vahet teatud keeltes. In C, see asi. Ja nii kui ma saan char ja ma tahan võrrelda, et char kasutades võrdsete võrdub mõned kirja nagu y või n, ma teen, tõepoolest, peab olema ülakoma. 

Nüüd saab minna ja seda teha. Lähme edasi ja ei tee loogiline dot kaldkriips loogiline. Ja nüüd ma küsimata. Niisiis, arvatavasti parem kasutaja kogemus tegelikult mulle öelda, mida teha siin. Aga ma lähen lihtsalt pimesi öelda, y jah, OK, kena. 

Laseme selle uuesti, n ilma, kena. Oletame näiteks teatud inimesed, keda ma tean, minu suurtähelukuks on liiga sageli. Nii ma kapitali Y, sisestada viga. OK, see ei ole täpselt, mida ma oodanud. Tõepoolest, arvuti teeb sõna otseses mõttes, mida Ma ütlesin, et see do-- kontrollida väiketähed y ja väiketähed n. See ei tunne hea kasutaja kogemus, kuigi. Lubage mul küsida ja võtta vastu kas väiketähed või suurtähtedega. Nii selgub, võiksite öelda midagi Scratch, nagu sõna otseses mõttes või C võrdub võrdub kapitali ühe tsiteeritud y. Selgub, C ei ole sõnasõnaline märksõna või. 

Aga see ei ole püsttriipudele. Sa pead hoida Shift tavaliselt, kui te kasutate USA klaviatuur, tabas püstribale võtme üle oma klahvi Enter. Aga see püstribale vertikaalne riba näitab või. 

Kui seevastu tahtsime öelda ja nagu Scratch, me võiks teha ampersand ampersand. See teeb mingit loogilist mõtet siin sest inimene ei saanud on kirjutatud nii y ja väiketähed y ja kapitali Y sama iseloomuga. Nii või on see, mida me kavatseme siin. 

Nii et kui ma seda mõlemas kohas või c võrdub võrdub kapitali N, nüüd uuesti,, teevad loogiline, uuesti, loogiline. Nüüd saab kirjutada y. Ja ma ei saa seda teha jälle kapitali Y või kapitali N. Ja ma saaks lisada täiendavaid kombinatsioonid ikka. 

Seega on see loogiline programmi, kuivõrd nüüd Ma kontrollin loogiliselt Selle väärtuse või selle väärtuse. Ja ma ei pea ilmtingimata, tulla veel kaks-sid või siis ifs. Ma ei saa tegelikult ühendada teatud seotud loogika koos sel viisil. Nii et see oleks parem kujundatud kui lihtsalt öeldes, kui C võrdub väiketähti y, printida jah, muidu, kui c on võrdne kapitali Y, printida jah, muidu kui c võrdub lower-- teisisõnu sa ei pea olema rohkem oksad. Võite kombineerida mõne samaväärse oksad loogiliselt, kuna sel viisil. 

Võtame pilk vaid üks viimane komponent, üks lõppkonstruktis et C lubab. Ja me tuleme tagasi tulevikus teised ikka. Ja siis me järeldada vaadates kell ei õigsuse code-- saada koodi work-- kuid projekti koodi ning istutada need seemned varakult. 

Nii et lubage mul minna ja avada uus fail siit. Tead mida? Ma lähen uuesti rakendada Sama programmi aga kasutada teist ehitada. 

Nii et lubage mul kiiresti annan end juurdepääsu hulka CS50.h jaoks CS50 raamatukogu standard Io.h printf. Anna mu int main void. Ja siis siin, las mul minna ja seda teha. 

Char c satub saada char, just nagu enne. Ja ma lähen kasutada uue konstruktsiooniga now-- lülitada, siis millistel iseloomu? Nii lüliti on selline nagu lülitades rongi rajad. Või tõesti, see on selline if muud, kui muidu, kui aga kirjutatud mõnevõrra erinevalt. 

Lüliti näeb välja selline. Sul on lüliti, ja mis siis iseloomu või number, mida soovite vaadata, siis mõned looksulg meeldi Scratch, lihtsalt öelda seda kraami. Ja siis on erinevad juhtumid. 

Sa ei kasuta, kas ja mujal. Sa sõna otseses mõttes kasutada sõna puhul. Ja sa ütleks midagi sellist. 

Nii puhul väikeseks y, või juhul, kui kapitali Y, minna ja välja printida jah. Ja siis murda välja lüliti. Nii see on. Me teha. 

Või kui nii-öelda, väiketähed n, või kapitali N, siis minna ja print out ole, ja seejärel murda. Else-- ja selline on Vaikimisi juhul indeed-- printf error-- ja lihtsalt hea meede, kuigi loogiliselt seda pausi ei ole vajalik sest me oleme lõpuks lüliti niikuinii Ma olen nüüd murrab läbi lüliti. Nii et see tundub veidi erinev. 

Aga loogiliselt, see on tegelikult samaväärsed. Ja miks te kasutate üks teiste üle? Mõnikord lihtsalt isiklik eelistus, mõnikord esteetika, kui ma pilgu sellele Nüüd, seal on midagi Tuleb öelda, et loetavust see kood. Ma mõtlen, rääkimata sellest, et see kood on uus paljud meist ruumis. 

Aga see lihtsalt selline on ilus. Näed väiketähed y, kapitali Y, väiketähed n, kapitali N vaikimisi see lihtsalt selline hüppab läbi olete nii et väidetavalt olla Eelmises näites koos IFS ja vertikaalsete varraste, ja muud ifs, ei pruugi olla. Nii et see on tõesti igaühe isiklik valik, tõesti, ega loetavuse kood. 

Aga nii funktsionaalsust, lase mind minna ja teha lüliti, dot kaldkriipsuga lüliti, ja nüüd kirjuta väiketähed y, kapitali Y, väiketähed n, kapitali N, David, uuesti, sest see on ei üks sümbol. Teeme x, viga, kui oodatud. Ja logically-- ja see on midagi, Ma julgustan ka general-- isegi kuigi me ainult kriimustada pinnal mõned neist omadustest. 

Ja see ei pruugi olla selge, kui ise istuma klaviatuur, kuidas see töötab? Mida see teeb? Ilus asi, millel sülearvuti või lauaarvuti või juurdepääsu arvutiga tõlkija, ja koodiga toimetaja niimoodi, on saate peaaegu alati vastata nendele küsimused ise lihtsalt proovida. 

Näiteks, kui retoorilise Küsimus käepärast olid, Mis juhtub, kui te unustate oma vaheaega väidetega? Mis on tegelikult väga levinud asi, mida teha, sest see ei tundu nagu sa tõesti seda vajavad. Nad ei ole tegelikult täita oma arvasin nagu sulgudes või lokkis traksidega teeb. Lähme edasi ja kompileerida koodi ja vaata. Nii et lüliti dot kaldkriipsuga lüliti. Olgem kirjutada väiketähtedega y, ülemine juhul Enter. Nii ma kirjutada y. 

Programm ütles jah, ei, viga, nagu ta oli muutmas oma meelt. Aga see selline oli, sest mis juhtub lülitiga on esimene juhtum, et match tähendab sisuliselt seda, hei arvuti täita kõik koodi all ta. Ja kui sa ei ütle, break, või ei ütle pausi, või ei ütle, break, arvuti läheb löök läbi kõik need jooned ja täita kõik neist enne see jõuab, et lokkis traksidega. Nii pidurid on tõepoolest vajalik. Aga Buffee siin on, kui Kahtluse korral proovida midagi. Ehk salvestada koodi esimene, või salvestada extra faili kui sa tõesti mures jama ja millel taastuda töö, et sa tead, töötab. 

Aga proovida asju. Ja ei ole nii kartma, võib-olla, mida arvuti võib teha? või, et te võite kaotada midagi. Teil on alati naasta mõne varasema versiooni. 

Nii saab lõpuks vaadates projekteerimise koodi. Meil on see võime nüüd kirjutada tingimused ja kirjuta silmad, ja muutujad, ja kõne funktsioonid. Niisiis, öeldes, et me oleme omamoodi tagasi kus me olime nädal tagasi Scratch, kuigi vähem kaalukad tekstiline keskkonda kui Scratch lubab. 

Aga märka, kui kiiresti me oleme omandanud et sõnavara, isegi kui see on aega võtab natuke aega, valamu, nii et me saame nüüd kasutada seda sõnavara kirjutada rohkem huvitavaid programme. Ja võtame beebi samm poole, et võtta järgmiselt. Lubage mul minna ja luua uus fail siin. 

Ma nimetan seda prototype.c ja tutvustada esmakordselt, võime teha oma funktsioone. Mõned teist võivad olla teha seda Scratch, mille saate luua oma omatehtud plokid Scratch, ja seejärel lohistage need paika kus te soovite C. Ja kõige programmeerimine keeled, mida saate teha täpselt selle-- teha oma funktsioone, kui nad ei ole juba olemas. 

Nii näiteks, lubage mul minna ning sisaldavad CS50.h ja sisaldavad standard IO.h, int main void. Ja nüüd on meil kohatäiteväljaga valmis minema. Hoian trükkimine asju nagu inimeste nimed täna. Ja et tunneb like-- ei oleks hea, kui seal olid funktsioon nimega print nimi? Ma ei pea kasutama printf. Ma ei pea meeles pidama kõik vormi koodid. Miks ma ei või miks ei keegi enne mind, luua funktsioon nimega print nimi, mis antakse mõne nime, lihtsalt trükib välja? 

Teisisõnu, kui ma ütlen, hei, arvuti, anna mulle string paludes kasutaja selliseks, kaudu CS50 s get string funktsiooni. Hei, arvuti, pane seda stringi muutuja vasakul pool, ja nimetavad seda s. Ja siis, hei arvuti, edasi minna ja printida selle isiku nimi, tehtud. 

Nüüd oleks tore, sest Selles programmis, tabavalt nimeks, ütleb mulle, mida ta peaks tegema teel nende funktsioon nimed. Lubage mul minna ja teha prototüüp, Enter. Ja kahjuks see ei kavatse sõita. 

Prototype.c, rida 7, iseloomu 5 viga, kaudne deklaratsiooni funktsiooni print nimi on kehtetu C99, C99 tähendab versiooni C mis tuli välja 1999. aastal. See on kõik. 

Nii et ma ei tea, mida kõik see tähendab veel. Aga ma tunnistama viga punane. See on päris selge. 

Ja tundub, et koos roheline märk siin probleem on print nimi, avatud paren s lähedal paren, semikoolon. Aga kaudne deklaratsiooni funktsiooni me ei vaata korraks tagasi. See tähendab lihtsalt, et rõkkama ei tea, mida ma mõtlen. 

Olen kasutanud sõnavara sõna, et see on kunagi näinud ega õpetatud enne. Ja nii ma vajan seda õpetada mida see funktsioon tähendab. Nii et ma lähen edasi minna ja seda teha. 

Ma lähen edasi minna ja rakendada minu funktsioon nimega Print nimi. Ja ma ütlen, on järgmine, et see teeb seda, printf, tere, protsenti s, backslash n nimi, semikoolon. Niisiis, mida ma teha saan? 

Nii selgub, et rakendada oma funktsiooni, me sellist laenata sama struktuur peamised et oleme lihtsalt olnud iseenesestmõistetav, ja ma tean ainult kopeerimise ja kleepida päris palju, mida Olen kirjalikult varem. Aga märgata muster siin. Keskmine, Main, tühjus, me tease peale Enne pikk, mida see tegelikult tähendab. 

Aga täna, just märgata parallelism. Void, print nimi, string nimi, mistõttu ei lilla märksõna, mis me ei kavatse hakata helistades naasmise tüüp nime funktsioon ja seejärel sisend. Niisiis, tegelikult saame destilleerida selline nagu eelmisel nädalal kui see on nimi või algoritm kood oleme läheb write-- algoritmi aluseks kood läheme kirjutada. 

See on tema panus. See on selle väljundi. See funktsioon, print nimi on eesmärk on võtta string nimega nime, või mis iganes, sisendiks ja siis tühine. See ei tagasta midagi, nagu saada string või saada int teeb. Nii see läheb käsi mulle midagi tagasi. See on lihtsalt läheb on kõrvaltoime, nii et rääkida, trükkima isiku nimi. Nii märkate, rida 7, I võib helistada print nimi. Line 10, võin määratleda või rakendada print nimi. Kuid kahjuks sellest ei piisa. 

Lubage mul minna ja kompileerida selle pärast salvestamist. Oot, nüüd olen teinud hullem, tundub. Nii kaudne deklaratsiooni funktsiooni print nimi on kehtetu. Ja jällegi, seal on rohkem vigu. Aga nagu ma hoiatada varem, isegi kui sa ülekoormatud, või natuke kurb näha nii palju vigu, keskenduda ainult esimene Esialgu sest see võib lihtsalt on olnud doominoefekti. Nii C või Clang täpsemalt ikka ei tunne print nimi. 

Ja et sellepärast rõkkama, mille konstruktsioon on selline loll. See ainult teeb seda, mida sa öelda tahad. Ja see ainult teeb seda, et kus sa öelda tahad. 

Nii olen määratletud peamine liin nelja nagu me oleme teinud päris tihti. Olen määratletud print nimi real 10. Aga ma üritan kasutada print nimi real seitse. 

See on liiga vara, veel ei ole. Nii et ma võiks olla tark ja olla nagu, OK, nii et vaatame lihtsalt mängida koos, ja liikuda print nimi üles siin, ja uuesti kompileerida. Oh mu jumal. Ta töötas. See oli nii lihtne. 

Aga loogika on just nii. Sul on õpetada rõkkama, mida ta on määratledes funktsiooni esimene. Siis saab seda kasutada. Aga ausalt öeldes, see tunneb nagu libe tee. 

Nii et iga kord, kui ma joosta arvesse probleem, ma olen lihtsalt läheb esile ja kopeerida koodi Kirjutasin, lõigata ja kleepida see siia üles. Ja kindlasti, saime leiutama mõned stsenaariumid kus üks funktsioon võiks vaja helistada teisele. Ja sa lihtsalt ei saa panna iga funktsiooni üle kõigi teiste. 

Nii selgub seal on parem lahendus. Me ei jäta seda olla. Ja ausalt öeldes, see on üldiselt kena, ja mugav ja hea disainiga panna peamine esimene, sest jällegi Peamised nagu siis, kui roheline lipp klõpsates mis on funktsioon, mis saab teostada vaikimisi. Nii võite ka panna see ülaosas faili nii, et kui teil või teiste inimeste vaadeldakse faili sa tead, mis toimub lihtsalt lugedes peamine esimene. Nii selgub, saame öelda rõkkama ennetavalt, hei, rõkkama, real neli, Ma luban, et rakendada funktsioon nimega Prindi Nimi, mis võtab stringi nimetatakse nimi sisendiks ja naaseb midagi, tühine. Ja ma saan ümber rakendatakse seda hiljem. 

Siin on peamised. Peamised nüüd real 9 saab kasutada Prindi nimi, sest rõkkama on uskudes, et lõpuks see tekib määratlus rakendamise Prindi nimi. Nii et pärast salvestamist minu faili, las mul minna ja teha prototüüp, näeb hea seekord. Dot kaldkriips, prototüüp, lase mind minna ja kirjuta nimi. David, tere David, Zamila, tere Zamila, ja tõepoolest, nüüd see töötab. 

Nii koostisosa on selles, et me oleme tehtud kohandatud funktsiooni, nagu kohandatud Scratch plokk me nõuame seda. Kuid erinevalt Scratch, kus saab lihtsalt luua seda ja seda kasutama hakata, Nüüd peame olema veidi pedantne, ja tegelikult koolitada rõkkama kasutada, või ootavad seda. Nüüd, kui kõrvale, miks kõik see aeg on meil olnud lihtsalt pimesi usu, sealhulgas CS50.h, kaasa arvatud standard IO.h? 

Noh, selgub, hulgast mõned muud asjad, kõik, mis on nende dot h failid, mis juhtub olema faile. Nad päisefailiga, nii rääkida. Nad ikka kirjutatud C. Aga nad teist tüüpi faili. 

Praegu saab päris palju eeldada et kõik, mis on seestpoolt CS50.h on mõned üks vooderdus niimoodi, ei funktsioonide nimetatakse Prindi nimi, kuid siia String, siia Float, ja mõned teised. Ja seal on sarnased prototüübid, üks vooderdus, sees standard IO.h printf, mis on nüüd minu Prindi Nimi funktsioon. Nii teisisõnu, kogu see aeg me oleme äsja pimesi kopeerides ja kleepides lisada see sisaldama et mis toimub? Need on lihtsalt selline vihjeid kuni rõkkama, millised funktsioonid on tõepoolest ellu, vaid mujal erinevaid faile mujal süsteemi. 

Nii oleme rakendanud print nimi. Tal on see kõrvalmõjuna trükkimine midagi ekraanil. Aga see ei ole tegelikult anda mulle midagi tagasi. Kuidas me minna programmi rakendamise, mis ei anna mulle midagi tagasi? 

Noh, proovime seda. Lubage mul minna ja rakendada fail nimega return.c nii et me saame näidata, kuidas midagi nagu siia String, või siia keskmine, on tegelikult tagasi midagi tagasi kasutaja. Lähme edasi ja määratleda int main void. 

Ja jällegi, et tulevikus jagame selgitada, mida see int ja tühine on tegelikult teevad. Aga täna, jagame enesestmõistetavaks. Ma lähen edasi minna ja printf, hea kasutaja kogemus, x on. Ja siis ma lähen ootama kasutaja anda mulle x get int. 

Ja siis ma lähen edasi minna ja välja printida x ruuduga. Nii et kui sul on ainult klaviatuur, inimesed tavaliselt kasutada vähe porgand sümbolile klaviatuuril esindada võimu eest või astendaja. Nii x ruudus on kohal i. 

Ja nüüd ma lähen seda teha. Ma võiks lihtsalt do-- mis on x ruudus? x ruudus x korda x. 

Ja me tegime seda mõned aega tagasi juba täna. See ei tunne kõik, et palju edu. Tead mida? Lähme ära mõned, et idee viimast korda võtmiseks. 

Kas poleks tore, kui seal on funktsioon nimega ruut, et just selline? See ikka lõpus on päevas, mis teeb sama matemaatika. Kuid olgem abstraktne ära idee võtta üks number korrutatakse teise ja lihtsalt anda talle nimi, nagu selle ruutu väärtus. 

Ning teisisõnu C, loome funktsiooni nimetatakse ruut, et just selline. See saab nimetada ruut. See saab võtta int. Ja me tekitavad lihtsalt nimetame seda n vaikimisi. 

Aga me võime seda kutsuda midagi tahame. Ja kõik see läheb teha, sõna otseses mõttes, on tootlus tulemus n korda n. Aga kuna see on tagasi midagi, mis on märksõna lilla me oleme kunagi näinud, I real 11, ei saa just öelda tühine seekord. 

Void, et näiteks me just nägime pigem print nimi, vaid tähendab, tee midagi. Aga ei anna mulle midagi tagasi. Sel juhul ma ei taha naasta n korda n, või mis iganes see on, et number. 

Nii et ma ei saa öelda, hei, arvuti, Ma tagasi midagi, tühine. See läheb tagasi oma olemuselt int. Ja nii see on kõik, mis siin toimub. 

Sisend ruutu saab olema int. Ja nii, et me ei kasuta seda, see peab on nimi, N. See läheb väljund int, et ei ole vaja nime. Me ei saa jätta see peamine, mis või kes on kasutab mind mäletad seda väärtust, kui me tahan oma muutuv. 

Ja jällegi ainuke uus märksõna on siin Return. Ja ma lihtsalt teeme mõned matemaatika. Kui ma tõesti tahtsin olla tarbetu, Ma võiks öelda, int toodet saab n korda n. 

Ja siis ma võiks öelda, tagastab toode. Kuid jällegi, et minu küsimus on varasem See lihtsalt ei ole hea design-- nagu, miks tutvustada nimi, sümbol, nagu toode, lihtsalt kohe tagastada? See on veidi puhtam, natuke tihedam, mistõttu rääkida, vaid öelda, tagastamise n korda n, vabaneda selle rea kokku. 

Ja see on lihtsalt vähem koodi lugeda, väiksem võimalus vigu. Ja vaatame, kas see tegelikult töötab nüüd. Nüüd ma lähen käia ja tagasipöördumine. 

Uh-oh, kaudne deklaratsiooni funktsioon. Tegin selle vea enne, ei ole suur asi. Lubage mul lihtsalt kirjuta, või tuua ja kopeerida, täpselt sama funktsiooni prototüüp, või allkiri, funktsiooni siin. Või ma võiks liikuda kogu funktsiooni. 

Aga see on natuke laisk. Nii et me ei tee seda. Nüüd lubage mul teha tagasipöördumist jälle dot kaldkriipsuga tagasi. 

x 2. x ruudus on 4. x 3. x ruudus on 9. Ja funktsioon tundub nüüd toimivat. Mis vahet on siin? Mul on funktsioon, mis nimetatakse ruut, sel juhul, mis panin sisend. Ja ma saan tagasi väljund. Ja veel, varem, kui Ma avan teisi näiteks varasematest, mis kutsuti prototype.c, Mul oli print nimi, mis tagasi tühine, kui nii võib öelda, Või siis tagasi midagi, ja lihtsalt oli kõrvalmõjuna. 

Mis siin toimub? Noh, leiavad funktsiooni saada string hetkeks. Oleme kasutanud funktsiooni saada string järgmisel viisil. 

Meil on olnud funktsioon saada string, nagu hulka CS50.h, hulka standard IO.h, int, peamine, tühine. Ja siis iga kord, kui ma olen nimetatakse get string seni Ma olen öelnud midagi, string s saab saada string, sest get string-- olgem nimetame seda get.c-- get string ise tagastab stringi, et saan siis kasutada, ja öelda, tere, koma, protsenti s, backslash n, s. 

Nii et see on sama näiteks tõesti, et meil oli varem. Nii et saada string tagastab väärtuse. Aga hetk tagasi, print stringi ei tagasta väärtust. See lihtsalt on kõrvalnäht. Nii et see on põhimõtteline erinevus. Me oleme näinud erinevat tüüpi funktsioone nüüd, millest mõned on tagastatud väärtused, millest mõned mitte. Ehk see on string või int või float. Või äkki see on lihtsalt tühine. 

Ja vahe on et need funktsioonid, mis saada andmeid ja tagastab väärtuse tegelikult tuua midagi laua juurde tagasi, niiöelda. Nii lähme edasi ja vaadata ühe lõpuosa näiteid, mis annab tunde, nüüd on kuidas me võiksime tõepoolest abstraktne parem, ja parem, ja parem, või rohkem, ja rohkem, ja rohkem, et kirjutada lõppkokkuvõttes parem koodi. Lähme edasi, ja vaimus Scratch, tehke järgmist. 

Lubage mul minna ja lisada CS50.h ja standard IO.h. Lubage mul minna ja anda mina int, peamine, tühine. Ja las ma minna, nimetame seda cough.c. 

Ja las ma minna ja lihtsalt nagu Scratch, välja printida köha / n. Ja ma tahan seda teha kolm korda. Nii et ma muidugi lihtsalt läheb kopeerida ja kleepida kolm korda. Ma nüüd lähen tegema köha dot kaldkriipsuga köha. Anname endale natuke rohkem ruumi Siin Sisesta, köha, köha, köha. 

Seal on ilmselt juba võimaluse parandada. Olen kopeerinud paar korda täna. Aga see oli ainult, et ma ei tuleb kirjutada nii palju märke. Ma ikka muutunud, mida neid ridu koodi on. 

Need kolm rida on identsed, mis tundub laisk ja tõesti tähendab, ja ei ole ilmselt õige lähenemine. Nii, mida koostisosa saaksime parandada selle koodi? Me ei pea kopeeri ja kleebi koodi. 

Ja tõesti, iga kord, kui tunnen ise kopeerimine ja kleepimine ja isegi mitte muutuva koodiga, koefitsiendid on seal parem. Ja tõepoolest, seal on. Lubage mul minna ja teha silmus, kuigi süntaks ei pruugi tulema loomulikult veel. 

Kas see kolm korda, lihtsalt tehes following-- ja ma tean küll, see on praktika. Aga meil on mitmeid näiteid praegu. Ja näete Internetis rohkem viiteid veel. 

See on süntaks real 6, mis palju nagu Scratch et kordub plokk, korrata järgmised kolm korda. See on veidi maagiline nüüd. Aga see saab rohkem, ja rohkem tuttavad. 

Ja see läheb kordama line kaheksa kolm korda, nii et kui ma uuesti kompileerida make köha, dot kaldkriips köha, köha, köha, köha. See töötab samamoodi. Nii et kõik on hästi ja hea. Aga see ei ole väga ammutatud. 

See on täiesti õige. Aga tundub, nagu seal võiks olla võimalus, nagu maailma Scratch, et selline algus lisada mõned semantika siin nii, et Ma ei ole lihtsalt mõned silmus, ja funktsioon, mis ütleb, köha või ei köha. Tead mida? Las ma proovin olla veidi jahedam kui, et ja tegelikult kirjutada funktsioon, mis on mõned kõrvaltoimed, nimetame seda köha. 

Ja see ei võta sisend ja tagasi mingit väärtust väljundiks. Aga sa tead, mida ta teeb? Ta teeb see-- printf, tsitaat lõppeb, köha. 

Ja nüüd siin, ma lähen minna ja int, i saab nulli, i vähem kui 3, i pluss pluss. Ma ei tee printf, mis on väidetavalt madal rakendamine detail. Mind ei huvita, kuidas köha. Ma tahan kasutada köha funktsiooni. Ja ma lihtsalt helistada köha. 

Nüüd märgata dihhotoomia. Kui te helistate funktsiooni, kui te ei tahan anda ta sisestab, täiesti korras. Just do avatud paren lähedal paren, ja sa oled teinud. 

Kui määratleda funktsiooni või Kinnitan funktsiooni prototüüp, kui tead ette et see ei ole kavatseb võtta mingeid argumente, öelda tühine need sulgudes seal. Ja mis teeb kindel, et sa ei kogemata seda valesti. Lubage mul minna ja teha köha. Ja muidugi, ma tegin vea. 

Kurat võtaks, seal on, et kaudne deklaratsiooni. Aga see on hea. See on lihtne lahendus. Ma lihtsalt pean prototüüp kõrgemal minu faili, kui ma olen tegelikult seda kasutada. 

Nüüd lubage mul teha köha taas, kena. Nüüd, see toimib. Tee köha, köha, köha, köha. Nii võiks arvata, et me oleme tõesti veidi üle insener seda probleemi. Ja tõesti, me oleme. See ei ole hea kandidaadi programmi Praegu jaoks refactoring, ja teeme, mis on nimetatakse hierarhiline lagunemise kus te võtate mõnda koodi ja seejärel sa mingi tegur asjad läbi, et omistada rohkem semantika neile, ning uuesti lõpuks pikemas perspektiivis. Aga see on ehituskivi poole keerukamaid programme et hakkame kirjalikult enne kaua, et võimaldab meil sõnavara kellega kirjutama paremaid koodi. Ja tõepoolest, vaatame, kui me ei saa üldistada seda veelgi. 

Tundub natuke lame, et mina, peamine, pea muretsema selle paganama silmus, ja kutsudes köha ja jälle. Miks ma ei saa lihtsalt öelda, köha, palun köha kolm korda? Teisisõnu, miks ma ei saa lihtsalt anda oma panuse köha ja seda teha? 

Miks ma ei saa öelda, et Peamised köha kolm korda. Ja nüüd, see on omamoodi maagiline. See on väga korduv siin. Ja see on tõepoolest laps samm. 

Aga võime öelda line kaheksa, köha kolm korda see on lihtsalt nii palju loetavamaks. Ja pluss, mul ei ole teada või hooli, kui köha on rakendatud. Ja tõepoolest, hiljem Mõiste ja lõplik projekte, kui te lahendada projekti, klassivend või kaks klassikaaslased saate aru, et sa lähed pea, või tahad, jagada töö. 

Ja sa lähed taha otsustada ette, kes läheb tegema seda, mida, ja kus tükid? Ja kas ei oleks tore kui sa näiteks võtta vastutus kirjalikult peamine, tehtud. Ja teie toakaaslane või oma partner üldisemalt hoolitseb rakendamisel köha. 

Ja see jaotus, neid seinte abst- või kihti võtmiseks, kui siis on super võimas, sest eriti suuremad, keerulisem programme ja süsteeme, see võimaldab mitu inimest ehitada asjad kokku ja lõpuks õmblema oma töös kokku niimoodi. Aga muidugi, me pea nüüd parandada köha. Me peame rääkima köha et kuule, tead mis? Sa lähed vaja võtta input-- nii ei tühine, kuid int ja praegu. Lähme edasi ja panna köha int. i saab nulli. 

i on väiksem kui mitu korda. Ütlesin kolm varem. Aga see pole see, mida ma tahan. Ma tahan köha tuleb üldistada Mistahes korduste arvu. 

Niisiis, tõepoolest, see on n, et ma tahan, olenemata kasutaja ütleb mulle. Nüüd saab minna ja öelda print köha. Ja ükskõik mis number kasutaja möödub, Ma itereerima, et mitu korda. 

Nii lõpus päeval, Programm on identsed. Aga märgata kõike seda kraami võiks isegi olla teise faili. Tõepoolest, ma ei tea, on hetk, kuidas printf rakendatakse. 

Ma ei tea hetkel, kuidas saada string või saada int või saada float rakendamine. Ja ma ei taha neid näha minu ekraanil. Mis see on, ma olen hakanud keskenduma minu programm, mitte neid funktsioone. 

Ja nii tõesti, niipea kui alustada faktooring koodi niimoodi välja, kas me isegi liikuda köha eraldi faili? Keegi võiks seda rakendada. Ja teid ja teie programmi saada väga ilus ja kergesti loetav, Väidetavalt on tõesti neli line programm seal. 

Nii lähme edasi nüüd ja teha veel üks muutus. Pange tähele, et minu prototüüp on muuta kuni top. Nii et lubage mul kinnitada, et nii Ma ei pahandada saada. 

Tee köha, lase mind kestab köha kord rohkem, ikka teevad sama asja. Aga nüüd, märgata on meil koostisosa üks lõplik versioon. Tead mida? Ma ei taha lihtsalt köha, tingimata. Ma tahan midagi üldisemat. Nii et sa tead, mida? Ma tahan seda teha. Ma tahan olla palju nagu Scratch ei, rääkida blokeerida, kuid mitte ainult midagi öelda mõned mitu korda. Ma tahan seda öelda väga konkreetne string. Ja seetõttu ma ei tahan seda öelda köha. Ma tahan seda öelda, mida iganes string sooritanud. 

Nii märgata, ma olen üldistatud See, et nüüd ütleme tundub hea nimi Selle, nagu kriimustus, kaht argumenti, erinevalt Scratch. Üks on string. Üks on int. 

Ja ma võiks vahetada saavad. Ma lihtsalt selline nagu idee öelda string esimene ja seejärel mitu korda hiljem. Tühjus tähendab see ikka ei tagasta midagi. Need on vaid visuaalne külg mõju, nagu on [? Jordan,?] verbaalne kõrvaltoime karjuma. See ikka ei midagi n korda, 0 kuni, kuid mitte võrdne n. See tähendab, n kokku korda. Ja siis lihtsalt välja printida mida iganes, et string on. Nii et ma olen tõesti üldistada See rida koodi. Nüüd, kuidas ma ellu köha funktsioon? 

Ma võin teha tühiseks köha. Ja ma ei saa ikka võtta, kuidas mitu korda soovite köha. Aga tead mis? Nüüd saan punt öelda. 

Ma ei helista sõnaõigus Sõna köha, läbides n. Ja kui ma tahan ka rakendada, lihtsalt lõbu pärast, aevastust funktsiooni Ma ei aevastama mõned mitu korda. Ja ma ei saa hoida taaskasutades n, sest märgata, et m selles kontekstis või ulatus eksisteerib ainult selle funktsiooni. 

Ja n selles kontekstis ainult eksisteerib see funktsioon siin. Nii et me tuleme tagasi Nende küsimuste ulatust. Ja siin, ma lihtsalt öelda, achoo ja siis n korda, semikoolon. 

Ja nüüd, ma lihtsalt vaja laenata Nende funktsioon allkirjad siin. Nii köha on õige. Void aevastus on õige nüüd. 

Ja ma ikka lihtsalt vaja öelda. Nii et ma lähen öelda, ütleme string s, int n, semikoolon. Nii et ma olen üle insenerirajatis kuradit välja see programm. 

Ja see ei ole tähenda tingimata seda on mida sa peaksid tegema, kui kirjalikult isegi kõige lihtsamaid programme. Võtke midagi, mis on ilmselt väga lihtne, tõesti lühike, ja uuesti rakendada kasutades liiga palju koodi. Aga sa tegelikult näha, ja aega tagasi vaadata neid näiteid, ja mõistavad, oh, need on sammud võtsime tegelikult üldistada, tegur midagi välja, kuni lõpus päeval minu kood on tegelikult päris mõistlik. Sest kui ma tahan köha kolm korda siis aevastama kolm korda Ma lihtsalt lähen uuesti, see, Programm teha köha ja kestab köha. Ja mul on kolm köha ja kolm aevastab. 

Ja nii see on põhiline paradigma, kui soovite, kuidas me võiks minna tegelikult programmi rakendamise. Kuid olgem lihtsalt näha nüüd, mis see on oleme teinud kõik see aeg, ja mida mõned lõplik tükki Selle taga on lihtne käsk. Lõpus päeval oleme kasutanud rõkkama meie tõlkija. Me oleme olnud kirjalikult allikas koodi, muutub see kaudu rõkkama masinkoodiks. 

Ja me oleme kasutanud Tee lihtsalt hõlbustada meie klahvivajutusi nii et meil ei ole vaja meeles pidada need incantations rõkkama ise. Aga milline on teha tegelikult teeb? Ja omakorda, mida on Rõkkama tegelikult teeb? 

Selgub, kuigi me oleme lihtsustatud tänane arutelu, öeldes, te võtate lähtekoodi, andke seda, kui sisendi koostaja, mis annab teile väljund masin koodi, lülitab seal on vähe erinevaid etappe sees olemas. Ja koostamise juhtub olema katuse tähtaeg terve hulk samme. Kuid olgem lihtsalt kiusupunn see välja tõesti kiiresti. 

Tuleb välja, et me oleme teinud rohkem asju iga kord, kui ma panna programm, või iga kord kui ma koostada programm täna. Nii eeltöötlus viitab see-- midagi C programmi nagu me näeme ikka ja jälle, mis algab käesoleva hash sümbol, või hashtag sümbol siin, tähendab see on eeltöötluse direktiivi. See tähendab, antud juhul, hei arvuti, teha midagi selle faili enne kui tegelikult koostada oma koodi. 

Sel juhul hash hulka tähendab, Sisuliselt C viis öelda, hey arvuti, mine saada sisu ning CS50.h ja kleebi need siin. Hei arvuti käima saada sisu standard IO.h, kus see asub kõvaketas, kleebi see siin. Nii et need asjad juhtuvad Esimene ajal eeltöötlus. 

Ja rõkkama see kõik meile. Ja ta teeb seda nii darn kiire, sa isegi ei vaata neli erinevat asju juhtub. Aga see esimene selline samm. 

Mis tegelikult juhtub? Noh, järgmine ametlik samm on koostamisel. Ja selgub, et koostamise programm tehniliselt tähendab siirdumine lähtekoodi, asju me oleme on kirjalikult täna midagi nimetatakse kokkupanek koodi, midagi mis näeb välja natuke erinev. 

Ja tegelikult, me näeme seda päris kiiresti. Lubage mul tegelikult läheb minu IDE. Lubage mul minna ja avada hello.c, mis on esimene programm, millega me Täna algas. Ja las ma minna ja joosta rõkkama natuke teistmoodi, rõkkama-s, hello.c, mis tegelikult toimub anna mulle veel üks fail hello.s. 

Ja me ilmselt kunagi jälle näha sellist koodi. Kui te võtate madalamal tasemel süsteemid klassi nagu CS61, näed palju rohkem Sedalaadi koodi. Aga see on Assembly. See on X86 Assembly et CPU, mis on aluseks CS50 IDE tegelikult aru. 

Ja segasena, sest see ei otsida, see on midagi arvuti mõistab päris hästi. Sub q, see on lahutama. Seal liigutusi. 

Seal helistab funktsioonide siin x Ohring, liikumine, add, pop, tagasi. Nii et väga madal juhiseid mis protsessoriga aru, et Ma vihjas varem. Seda Intel Inside. 

On mustrid ühtede ja nullide et map nende arcanely sõnastatud, kuid mõnevõrra ka nimega, juhiseid, niiöelda. See juhtub siis, kui kompileerida koodi. Saad kokkupanek keele välja, mis tähendab kolmas samm on koondada et montaaži kood lõpuks masin code-- ühtede ja nullide, mitte teksti, et me just nägin hetk tagasi. 

Nii eeltöötlust ei, et leida ja asendada, ja mõned muud asjad. Koostamine võtab oma allikas koodi C, lähtekoodi et me kirjutasime, montaaži kood, et me lihtsalt vaatas. Kokkupanek võtab selle assamblee koodi nullidega ja need et CPU tõesti mõista lõpus päeval. Ja sidudes on viimane samm mis juhtub us-- uuesti nii kiiresti me isegi ei notice--, mis ütleb, hey arvuti, võtta kõik nulli ja need, mis tulenes koostamisel Davidi koodi ja tema põhiülesanne sel juhul. 

Ja hei arvuti, mine saada kõik ühtede ja nullide et CS50 töötajad kirjutasid sees CS50 raamatukogu. Sega need koos David. Ja hei arvuti käima saada kõik nullid ja need, mis keegi kirjutas aastat tagasi printf. Ja lisada need sisse Kogu asi, et me oleme sain ühtede ja nullide on CS50 töötajate ühtede ja nullide, printf ühtede ja nullide, ja midagi me kasutame. 

Nad kõik saavad koondatakse ühte programmi nimega, antud juhul, tere. Nii edaspidi, me lihtsalt kasutada sõna koostamine. Ja me peame enesestmõistetavaks, et kui ütleme, koostada oma kava, see tähendab, hey teha eeltöötlust, kokkupanek ja sidudes. Aga seal on tegelikult mõned mahlane kraam toimub seal all kapuuts. Ja eriti kui sa saada uudishimulik mõnda aega, võite alustada poking ringi madalamal tasemel. Aga nüüd, mõistavad, et hulgast takeaways täna On üsna lihtsalt protsessi algusega, saada rahul midagi tere. Tõepoolest, kõige kohta, mida me tegime täna kindlasti ei upu super kiire. Ja see võtab ajal ja mõned praktikas. Ja koefitsiendid, siis sorteeri ning tahavad lüüa oma klaviatuuri või kisa ekraani. Ja kõik see on OK. Kuigi, võib-olla proovida ei seda teegi nii palju. 

Ja lõpuks, saate oleks võimalik küll, et alustada nähes mustrid, nii heas koodi et olete kirjutanud ja vead et olete teinud. Ja palju nagu protsessi muutumas TF või CA on nagu, hakkate parem ja parem nähes neid mustreid, ja lihtsalt lahendada oma omad probleemid lõpuks. Vahepeal tekib palju meist laenata teile toetust, ja sulle läbi selle. Ja kirjutada-ups jaoks kõik probleemid sa juhatatakse läbi kõik käsud et ma kindlasti teada palju harjutamist, mida nüüd, aga võiks lennanud üle pea nüüd. Ja see on täiesti korras. 

Aga lõpuks, sa lähed alustada, et näha mustreid tekkima. Ja kui sa varem kõik loll üksikasjad, nagu sulgudes, ja looksulg ja semikoolonite, ja värki, öeldes, see ei ole üldse intellektuaalselt huvitav. Ja see ei ole eesmärki mingeid sissejuhatav klassi. See on ideid, mis hakkavad oluline. 

See on silmad, ja tingimused ning funktsioone, ja jõulisemalt võtmiseks, ja faktooring koodi, ja hea disaini ja hea stiili ja lõpuks õigsust oma koodi, mis on lõppkokkuvõttes läheb asja kõige. Nii et järgmine nädal, võtame need ideed, et me esimest korda nägime Scratch ja on nüüd tõlgitud C. Ja hakkame tutvustada esimene Muidugi on reaalse maailma domeenid. 

Me keskendume maailma julgeolekut, täpsemalt krüptograafiale kunst segunemise teavet. Ja esimeste seas probleemidest ise saavad kirjutada kaugemale mängides mõned süntaks ja lahendada mõned loogilised probleeme, lõpuks enne pikk, on tegelikult rüselus, või krüpteerida, ja lõpuks lahti teavet. Ja kõik, mida me oleme teinud täna, hakkab üsna madal tasandil, lihtsalt läheb lubada meil võtta üks, ja üks, ja veel üks samm eespool suunas kirjalikult kõige huvitavam kood veel. 

Nii enam, et järgmisel nädalal. 

[VIDEO PLAYBACK] 

Mida saab räägi mulle viimane kord, kui teda nägin? Mida ma oskan öelda, kas tõesti? Ma mõtlen, et see oli nagu iga teine pre-production peaproov, va ta midagi ütles päris lõpus, et ummikus mind. 

-See Oli CS50. 

-See Lõigatud kõik, suure töö kohta peaproov. 

-See Lõunasööki? 

Jah, sina ja suudan haarata võileiva natuke. Lubage mul saatkonna koos David tõesti kiiresti. David? David? 

[END PLAYBACK] 