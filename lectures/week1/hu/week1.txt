[ZENE] David J. MALAN: Rendben, ez CS50. És ez első héten. Így emlékeztetni arra, hogy utoljára héten nulla, összpontosítottunk számítógépes gondolkodás. És áttértünk attól, Scratch, egy grafikus programozási nyelvet a barátaink Az MIT Media Lab. 

És Scratch, nem kutatjuk ötletek, mint funkciók és feltételek, és hurkok, és a változók, és még eseményeket, és a szálak, és így tovább. És ma megyünk továbbra is használja ezeket az elképzeléseket, és tényleg figyelembe őket engedélyezett, de lefordítani őket másik nyelvre ismert C. Most C egy hagyományosabb nyelven. Ez egy alacsonyabb szinten nyelv, ha úgy tetszik. 

Ez a tisztán szöveg. És így első ránézésre, hogy minden fog kinézni meglehetősen rejtélyes ha soha nem programozott előtt. Megyünk, hogy félig kettőspont és zárójel, és zárójelekkel, és így tovább. De észre, hogy még bár a szintaxis körülbelül nézni egy kicsit szokatlan a legtöbb van, lásd múlt. És próbálja meg, hogy a gondolatok amelyek valóban ismerős, mert itt az első héten, hogy mit elkezdjük csinálni, hogy hasonlítsa össze, kezdetben Scratch versus C. 

Így például, emlékeztetni arra, hogy amikor hajtották végre az első a programok utoljára volt egy blokk, ami úgy nézett egy kis valamit Így-- amikor zöld zászló kattintott, és aztán egy vagy több puzzle darab alatta, ebben az esetben azt mondják, hello world. Tehát valóban, a Scratch, amikor rákattintok, hogy a zöld zászló futtatni a programot, így beszélni, ezek A blokkok kerül végrehajtásra, vagy futni. És különösen Scratch mondta, hello, világ. 

Most én is meghatározhat más szavakkal itt. De látni fogjuk, hogy valóban sok Ezeknek blocks--, és valóban, C sok functions-- lehet parametrizálhatók vagy testreszabott más dolgokat. Tény, hogy a C, ha szeretnénk váltani, most, ez Scratch programot ezt a másik nyelvet, megyünk levelet kis valamit, mint ez. 

Nyújtott, van néhány ismeretlen szintaxis ott a legvalószínűbb, int, és zárójelben, és érvénytelen. De printf-- még ha lenne úgy gondolja, ez csak nyomtatni. De nyomtatás azt jelenti, nyomtatás formázott, ahogy hamarosan látni. Ez szó szerint fogja nyomtatni A képernyőn bármilyen belsejében van ezek a zárójelek, amelyek Természetesen ebben az esetben is, hello world. 

De észre fogod venni, más szintaxis egyes idézőjel, hogy a zárójelben a végén, a félig vastagbél és hasonlók. Tehát van egy kis rezsi, hogy úgy mondjam, mind a kognitív és nyelvtanilag, hogy megyünk hogy meg kell emlékezni előtt hosszú. De észre, hogy a gyakorlattal, ez kezd ugrani ki rád. 

Sőt, most összpontosítani, hogy az egyik funkció specifically-- Ebben az esetben, köszönni világban. Tehát mondjuk a funkciót. Helló világ a paraméter, vagy érv annak testreszabását. 

És az egyenértékűség C csak lesz ez egy sort itt, ahol printf egyenértékű, mondjuk, A dupla idézőjel, szia világ egyenértékű, természetesen, hogy mi van a fehér doboz van. És a backslash n, bár egy kicsit furcsa és hiányzik a semmiből, egyszerűen megy, hogy a hatás fogunk látnak a számítógép, mint a Mac vagy PC, csak mozog a kurzort a következő sorba. Ez olyan, mint ütő Az Enter billentyűt. 

Szóval majd meglátjuk, hogy ismét nemsokára. De először vessünk egy pillantást a Más példa esetében a hurkok. Mi volt ez örökre hurok utoljára, amely egy sorozat puzzle darab hogy nem valami szó szerint forever-- Ebben az esetben, mondjuk, hello world, Helló világ, hello world, Helló világ. Tehát ez egy végtelen ciklust így. 

A C-ben, ha azt akarjuk, hogy végre ezt a Ugyanez a gondolat, talán csak ezt. Bár igaz, printf szia world-- most míg csak szemantikailag, egyfajta idézi fel az ötlet, hogy valami újra, és újra, és újra, és mennyi ideig? Nos, true-- emlékeztetnek arra, hogy igaz csak vagy egy. 

És igaz, természetesen, mindig igaz. Tehát ez a fajta értelmetlen nyilatkozat csak mondani igaz. De valóban, ez szándékos, mert ha igaz, csak mindig igaz, mint amíg igaz csak azt jelenti, Ha egy kis közvetve, hogy a következő sor kódot között azok kapcsos zárójelek kéne végre újra, és újra, és újra, és soha nem hagyja abba. 

De ha szeretné, hogy a hurok megállítani, mint mi múltkor valami hasonlóra Ezt ismételje meg a következő 50-szer, C tehetünk azonos azzal, ami nevezzük az loop-- kulcsszó hogy nem már, de. És akkor mi van néhány új szintaxis itt, A int i értéke 0, i kevesebb, mint 50, i ++. És mi jön vissza, hogy a. De ez csak, hogyan is kellene lefordítani a készlet Scratch blokkok egy sor C sornyi kódot. 

Közben úgy változókat. És valóban, mi csak láttam egy pár perce. És abban az esetben, Scratch, ha akarta, hogy egy változót, az i mert én, hogy egész, csak egy szám, és szeretnénk beállítani, hogy néhány érték, szeretnénk használni ezt a narancs blokk here-- beállítva i 0. 

És látni fogjuk ma azon túl, mint a múlt héten, programozók csinálni szinte mindig elkezd számolás nullától, tényleg egyezményesen. De azért is, mert visszahívással vitánk a bináris, a legkisebb szám tudsz képviselnek, azzal bármilyen bitszám csak lesz 0 magát. És így fogunk általában kezdeni inicializálás még a változó 0-ra. 

És C, hogy nem ugyanaz, fogunk mondani int az egész, én csak az egyezmény. Tudtam volna hívott ez a változó valamit akarok, csakúgy, mint a Scratch. És akkor értéke 0 csak jogutódai a 0 érték a jobb és hozza azt a változót, vagy a tároló van, a bal oldalon. És a pontosvesszőt mivel mi see-- és láttunk egy pár ilyen already-- Csak azt jelenti, vége a gondolat. Folytassuk valami mást a sorokat, hogy kövesse. 

De mi a helyzet logikai kifejezések? Emlékezzünk vissza, hogy a Scratch, ezek kifejezések amelyek vagy igaz vagy false-- kérdések, tényleg, amelyek igaz vagy hamis. Tehát abban az esetben, Scratch, talán fel egy egyszerű kérdést, mint ez, jelentése i kevesebb, mint 50? Tehát azt, ismét egy egész szám. Talán éppen használja egy Scratch programban nyomon követni a pontszám vagy valami ilyesmi. Tehát ez a szintaxis itt Scratch Csak azt jelenti, van én kevesebb, mint 50? Nos, szerencsére, valami egyszerű C. És lefordítani, Ehhez egyszerűen mondom, kevesebb mint 50, vagyis ismeri a kulcsot a billentyűzeten. 

Addig is, ha akart mondjuk valami általánosabb, mint, nos, az x kisebb mint y, ahol az egyes X és Y maguk változók? Tehetünk ugyanezt C, mindaddig, ahogy már létre ezeket a változókat már. És majd meglátjuk, hogy hogyan Ehhez nemsokára. Mi egyszerűen csak azt mondják x kisebb mint y. 

Szóval kezd lásd bizonyos hasonlóságok. És azok az emberek, akik Scratch biztosan ihlette néhány ilyen alapvető ötleteket. És akkor ez a fajta szintaxis számos languages-- nem csak karcolás, nem Csak C, de a Python, és a JavaScript, és más nyelveken is. 

Nézzük a másik konstrukciót C, a fogalom olyan állapot, csinál valamit feltételesen. Ha valami igaz, erre a célra. Ha valami mást is igaz, erre. Ez a fajta programozási egyenértékű egy villát az úton. Lehet, hogy ez egy kétirányú villa, egy három-utas villa, vagy annál több. És Scratch, talán van láttunk ilyet. 

Tehát ez az ember egy nagyot. De nézzük a relatív egyszerűség a logika. Ha x kisebb, mint Y, akkor mondjuk x kisebb mint Y, mást, ha x nagyobb, mint Y, akkor mondjuk x nagyobb mint y. És akkor logikusan, ha úgy gondolja, vissza Scratch vagy csak a saját emberi intuíció, Nos, ha x nem nagyobb, mint Y, és X nem kevesebb, mint Y, akkor természetesen x lesz egyenlő y. Tehát ebben az esetben, a beágyazott azok Scratch blokkok, érhetjük el három módon útelágazáshoz? 

Közben, ha azt akarjuk, hogy csinálni, hogy a C-hez, vitathatatlanul úgy néz ki, egy kicsit simpler-- legalább ha egyszer kap ismeri a szintaxis. Ha x kisebb, mint Y, printf x kisebb mint y. Else ha x nagyobb, mint Y, printf x nagyobb mint y. Else printf x egyenlő y-- és ismét azokkal backslash fejeződik be ezeket az új sorokat úgy, hogy ha ténylegesen futott ez a fajta program akkor csak mozog a kurzort végül A következő sorban a képernyőn. 

Most, miközben Scratch volt más több kifinomultabb megoldás, csak amelyek közül néhány megyünk kezdetben áttérni a világ C. És egyikük hívott egy listát Scratch. És ez egy különleges típusú változó engedélyezve, hogy tárolja több dolgot a vissza, vissza, vissza, vissza. 

A C-ben, hogy nem rendelkezik listák, önmagában, hanem valami amelyek általánosabban nevű tömböt, bár mi jöjjön vissza később ebben a félévben hogy keres valamit hívott egy listát, vagy tényleg egy láncolt lista. De most, a legközelebbi egyenértékű C számunkra lesz valami nevű tömböt. És egy sor egyszerűen speciális típusú változó amely lehetővé teszi, hogy tárolja az adatokat vissza, vissza, vissza, hogy vissza. 

És valóban, a Scratch, ha azt akartuk elérni Az első elem egy tömb vagy egy list-- és fogom nevezni, egyezményesen argv, érvelés vektor, de erről bővebben nemsokára. Ha azt akarom, hogy az első elem A beállítás az argv, a világon a Scratch Ön ténylegesen jellemzően indul 1-jétől számítva. 

És így lehet, hogy az 1. pont a argv. Ez csak hogyan MIT végrehajtott fogalma listákat. De a C-ben fogok Egyszerűbben csak azt mondják, argv, ami megint a neve a list-- vagy ha világos, egy tömbben. És ha azt szeretné, hogy az első elemek, megyek használható szögletes zárójelben, amit Lehet, hogy nem gyakran használják alatt a billentyűzet. 

De 0 csak azt jelenti, hogy nekem az első. Így alkalmanként és múlik az idő, megyünk kezdeni, hogy ezek a dichotómia között Scratch és C amelynek Scratch használ ilyet. Mi C a 0 itt. De akkor gyorsan látni ha egyszer megérted alapjait minden nyelv, ezek a dolgok kezdenek annál ismerős a gyakorlat és a gyakorlat. 

Úgyhogy valóban meg most a programot. Itt kell lennie az első a mi C forráskód teljes programokat. És a program megyünk hez megfontolásra az egyik, hogy a egyenértékű hogy a korábbi Scratch darab. 

Tehát itt, van mit vitathatatlanul a legegyszerűbb C program írhatunk, hogy valójában csinál valamit. Most azt fogjuk megnézni múlt, most, már tartalmazzák, szabvány io.h, és ezek a szög konzolok, és int, és érvénytelen, és a kapcsos zárójelek, és hasonlók. 

És nézzük csak összpontosítani mi, legalábbis ösztönösen, Lehet ugrik ki már. Sőt, a fő, nem tudom feltétlenül tudja, mi ez, de hasonlóan Scratch volt, hogy amikor zöld zászló kattintott puzzle-darab, így nem C programozási nyelv Van egy fő darab kódot kerül végrehajtásra, alapértelmezés szerint. És valóban, ez szó szerint fogják hívni fő. 

Tehát fő függvénye. És ez egy speciális funkció, ami létezik C, hogy ha egy olyan programot futtat, ez a fő, hogy fusson a alapértelmezett. A világ a Scratch, ez általában akkor, ha zöld zászló kattintott, hogy van az alapértelmezés szerint. 

Közben láttunk ilyet, printf vagy nyomtatott formátumú, ez lesz a funkciója, hogy jön C, valamint egy csomó más, hogy időről időre és ismét, Annak érdekében, hogy pontosan mint a neve is sugallja, nyomtasson valamit. Mit akarunk nyomtatni? Nos, látni fogjuk, hogy bekerítésével karakterek mint these-- hello world, backslash n idézőjelek, azt lehet mondani, hogy pontosan printf mit kell nyomtatni a képernyőn. 

De ahhoz, hogy ezt hogy sajnos kell tennie valamit, ami már rejtélyes, hogy mi emberek, de legalább ez kissé readable-- éles közé, szabványos io.h, int, fő, üres, printf, mind a mágikus ráolvasások láttunk a képernyőn. De valójában meg kell menjen inkább misztikus is. Először azt kell lefordítani a kódot hogy írunk gépi kódra. És emlékszem a múlt héten, hogy a gépek, legalább az is tudjuk itt, a végén a nap csak megérteni nullák. 

És Istenem, ha kellett összerakható nullák, hogy ténylegesen program ez akkor is nagyon, nagyon gyorsan vegye a móka meg semmit. De kiderül, egy a múlt héten, hogy ezeket a mintákat a nullák és egyesek Csak speciális jelentése van. Bizonyos helyzetekben, lehet, hogy azt jelenti, számokat. 

Bizonyos összefüggésekben, lehet, hogy azt jelenti, betűk, vagy a színek, vagy akárhány Más absztrakciók ott hagyják. De ahogy a számítógépben CPU, Central Processing Unit, vagy az agy számítógép belsejében. Ez általában az Intel belsejében, mert ez az egyik legnagyobb cégek ami CPU számítógépek számára. 

Nos, az Intel CPU-k és egyebek egyszerűen úgy döntöttek, előre hogy bizonyos mintákat nullák és azok olyan konkrét dolgokat. Egyes minták nullák azt jelenti, nyomtassa ki ezt a képernyőt, vagy add a két szám, vagy kivonni a két szám, vagy mozgassa a darab adatait a számítógép memóriájában ide, vagy számos más nagyon alacsony szinten, de végül hasznos műveleteket. De, szerencsére, mi emberek nem fognak szüksége, hogy tudja ezt részletességgel. Sőt, mint legutóbb, ahol absztrahált újra, és újra, és újra, épület nagyon alacsony szinten primitívek, mint a nullák és egyesek a magasabb szintű fogalmak mint a számok és betűk, és a színek, és így tovább, Meg tudjuk tenni a programozók állni a vállán mások, akik elénk és olyan szoftvert használ, más emberek előtt írt us-- nevezetesen programok nevezett fordító. 

C egy olyan nyelv, Általában össze, ami azt jelenti, átalakított forráskódot gépi kód. Különösen, hogy ez mit jelent van, hogy ha megvan a forrás kódot, hogy te magad írni, ahogy hamarosan majd egy pillanat múlva a képernyőn, és szeretné átalakítani, végül a gép code-- ezek nullák és egyesek, hogy csak a Mac vagy a PC understands-- van egy első takarmány, hogy a forráskód, mint bemenet egy speciális nevű program egy fordító, amelynek kimenete a mi kell látni gépi kód. És valóban, utoljára beszéltünk körülbelül, tényleg, a végén a nap, problémamegoldás. Megvan bemenet. És megvan kimenettel. És van néhány fajta Az algoritmus a közepén. 

Algoritmusok biztosan megvalósított szoftver, mint láttuk pszeudokód a múlt héten és mint látni fogjuk a tényleges kódot ezen a héten. És így egy fordító tényleg csak egy sor algoritmusok belsejében róla, hogy tudja, hogyan kell átalakítani a speciális kulcsszavak, mint fő, és a printf, és mások, hogy mi csak látta a minták nullák és is, hogy az Intel és belül más CPU ténylegesen meg is érti. Szóval hogyan lehet ezt megtenni? Hová jutunk a fordító? 

A legtöbben itt van egy Mac vagy PC. És te Mac OS, vagy A Windows vagy Linux, vagy Solaris vagy akárhány más operációs rendszer. És valóban, mi lehetett kimegy rá az interneten és töltse le a fordító a Mac vagy a PC az adott operációs rendszer. De mi lenne mind a a különböző oldalakon, hogy úgy mondjam. Mi volna kicsit különböző konfigurációkat. És a dolgok nem működnek mindegy. És valóban, ezekben a napokban sokan nem használják szoftver fut csak a laptopok. Ehelyett használjuk valami mint egy böngésző, amely lehetővé teszi számunkra, hogy hozzáférést a web-alapú alkalmazások a felhőben. És még ebben a félévben, fogjuk csinálni, hogy pontosan. Mi lesz alkalmazásokat írni vagy szoftver segítségével code-- nem C, de más nyelvek, mint a Python és JavaScript-- futnak a felhő. 

És erre mi magunk Évközi fogja használni a felhő-alapú környezet ismert CS50 IDE. Ez egy web-alapú programozás környezet, illetve integrált fejlesztési környezet, IDE, hogy épített tetején néhány nyílt forráskódú szoftver, a Cloud 9. És tettünk néhány pedagógiai egyszerűsítéseket is annak érdekében, hogy elrejtse bizonyos funkciók Az első hetekben, hogy nem kell, ami után felfedi őket, és ahogy a legtöbb amit szeretne a környezettel. 

És ez lehetővé teszi számunkra is, hogy előtelepíthet bizonyos szoftverek. Dolgok, mint egy úgynevezett CS50 könyvtár, amit hamarosan látni biztosítja számunkra a C némi további szolgáltatásokat. Tehát, ha megy, végül CS50.io, a rendszer kérni fogja, hogy jelentkezzen be, és ha egyszer nem, és hozzon létre számlát ingyen, Ön képes lesz hozzáférni egy környezet, amely úgy néz ki, elég, mint ezt. 

Nos, ez az alapértelmezett mód. Minden szép és fényes a képernyőn. Sokunknak van egy szokása, dolgozik CS50 darab, ami egészen késő éjszakáig. És így néhányan talán inkább kapcsolja be éjszakai mód, hogy úgy mondjam. 

De végül is, mi te fogja látni a CS50 IDE három különálló areas-- egy területet a bal hol A fájlok lesznek a felhő, egy olyan területen, a jobb felső sarokban ahol a kód lesz szerkeszthető. Ön képes lesz arra, hogy nyissa egyes fülek minden program hogy írsz ebben a félévben belül Az, hogy a jobb felső sarokban. És akkor a legtöbb arcanely, és mégis erőteljesen, lesz ez a dolog a alsó néven egy terminál ablakot. 

Ez egy régi iskola Command Line Interface, vagy CLI, amely lehetővé teszi, hogy végre parancsokat a computer-- Ebben az esetben, A számítógép a cloud-- a dolgokat, mint az általad beírt kódot forráskódból gépi kód, futtatni a programokat, vagy indítsa el a web szerver, vagy az adatbázis eléréséhez, és tetszőleges számú egyéb technikák hogy elkezdjük használni nemsokára. De, hogy ott vagyunk, fog ténylegesen megy online, és elkezd játszani. És erre, nézzük először kezdeni bütyköl fő, és írni a fő része a programnak. És vegyünk ezt a funkciót printf, amit korábban használt, egyszerűen azt mondani valamit. 

Tehát itt vagyok már benne CS50 IDE. Már bejelentkezett előre. És én teljes árnyékolt ablak. És így, végül, akkor Túl az elkövetkező problémák akkor hasonló lépéseket, hogy nyújt az online dokumentáció. Így nem kell aggódnia elnyelő minden kis technikai lépés hogy én ma itt. 

De kapsz egy képernyőn, mint ez. Én történetesen az éjszakai üzemmódban. És akkor is felderül mindent up letiltásával éjszakai mód. És a végén az nap, fogsz látni E három fő areas-- fájl böngésző bal oldalon, a kód fülek fel tetején, és a terminál ablak alján. 

Hadd menjek előre, és levelet az első programot. Megyek preemptively menjen a File, Mentse, és mentse a fájlt, mint hello.c. Sőt, megállapodás szerint, minden program keretében írják, hogy van írva a C nyelven meg kell nevezni valamit dot c, az egyezmény. Így fogok nevezni azt hello.c, mert Csak azt akarom, hogy köszönjön a világ. Most megyek zoom ki, és kattintson a Mentés gombra. És én itt most egy lapra ahol én indulhat kódot írni. 

Ez nem fog összeállítani. Ez nem jelent semmit. És így még ha átalakítható ezt a nullák és egyesek, A CPU megy, hogy nincs ötlet, hogy mi folyik körül. De ha írok vonalak, amelyek egyeznek fel C- conventions-- C lény, újra, ez language-- szintaxis hasonló Ennek printf szia world-- és én már ütött kényelmes ezt idővel. Szóval nem hiszem, tettem az esetleges gépelési hibákat. 

De mindig, már az első alkalommal, amikor ezt, nem fogsz. És amit most tenni talán igen valamint nem működik az Ön számára az első alkalommal. És ez teljesen rendben van, mert most te Lehet, hogy csak látni egy csomó újdonság, de idővel, ha egyszer kap ismerős ezzel környezet, és ezt a nyelvet, és mások, akkor kezd látni a dolgokat, hogy amelyek vagy helyes vagy helytelen. 

És ez az, amit a tanítás társaival és természetesen asszisztensek kap olyan jó az idő múlásával, a pecsételő hibákat vagy hibák a kódban. De azt állítják, hogy nincsenek hibák ezt a kódot. Úgyhogy most szeretnénk futtatni ezt a programot. 

Most a saját Mac vagy PC, vagyok a szokás dupla kattintással ikonok mikor szeretné futtatni a programot. De nem ez a modell itt. Ebben a környezetben, ami CS50 IDE. Mi használ működési rendszer úgynevezett Linux. Linux emlékeztet egy másik operációs rendszer, általánosan ismert mint a Unix. És a Linux különösen ismert amelynek parancssoros környezetben CLI. Most éppen egy konkrét Linuxoknál nevű Ubuntu. És az Ubuntu egyszerűen egy bizonyos Linux-változatot. 

De ezek a Linux ezekben a napokban nem a ténylegesen jönnek a grafikus felhasználói felületek. És az, amit történetesen használja itt a web-alapú. Tehát ez talán meg még egy kicsit eltér valami te magad talán látott vagy fut a múltban. 

Így fogok menni előre most és tegye a következőket. Tartogattam ezt a fájlt hello.c. Megyek megy előre, és típusú clanghello.c Tehát csenget A C nyelv egy fordító. Ez előre telepített CS50 IDE. És akkor teljesen le és telepíteni ezt a saját Mac vagy PC. 

De megint, akkor nem lett volna minden Az előzetes beállítási tenni az Ön számára. Tehát most, én csak fog futni clanghello.c. És most ezt észre szintaxis Itt végül észre, hogy azt jelenti, hogy én vagyok a mappát vagy könyvtárat nevű munkaterület. Ez dollárjellel csak konvenció az értelmét, írja be a parancsokat itt. 

Ez egy úgynevezett gyors, csak egyezményesen a dollár jel. És ha megyek előre, és most kattintson Enter, semmi sem történt volna. De ez tényleg egy jó dolog. A kisebb, ami történik A képernyő, annál valószínűbb, a kód, hogy helyes, legalább szintaktikailag. 

Tehát, ha azt szeretnénk, hogy futtatni ezt programot, mit tegyek? Nos, kiderült, hogy a alapértelmezett név egyezményesen programokhoz, ha nem adja meg a nevet a program csak a.out. És ez a szintaxis is, akkor megszokni nemsokára. 

Dot perjel csak azt jelenti, hé, CS50 IDE, fut a program az úgynevezett a.out hogy van benne az én aktuális könyvtárban. Hogy pont azt jelenti, az aktuális könyvtárban. És majd meglátjuk, mi más ilyen szekvenciák karakterek jelent nemsokára. 

Tehát itt vagyunk, az Enter, hello world. És akkor veszi észre, hogy mi történt? Nem csak azt nyomtatandó hello world. Azt is kifejti a kurzort a következő sorba. 

És miért volt ez? Mi volt a kód, amit írt, mielőtt hogy biztosította, hogy a kurzor lenne menj a következő sorban? Vicces dolog a számítógép ez csak akkor fog csinálni szó, amit mondani, hogy igen. 

Tehát, ha azt mondja, hogy a printf hello, vessző, szóköz, világ, közel idézet, ez szó szerint csak akkor fog nyomtatni ezeket a karaktereket. De volt ennek a különleges karakter végén, visszahívás, backslash n. És ez az, ami biztosította hogy a karakter ment A következő sorban a képernyőn. 

Sőt, hadd menjen, és erre a célra. Hadd menjek előre, és törölni ezt. Most észre, hogy az tetején a képernyő van egy kis piros fény A lap azt jelzi, hé, te nem mentette a fájlt. Így fogok menni előre ellenőrzés S vagy parancs S mentse a fájlt. Most goes-- ment egy moment-- zöld. És most vissza csak, hogy egy közeli ikonra. 

Ha most fut clanghello.c újra, Írja, pont perjel, a.out, Enter látni fogod, hogy még mindig működött. De ez vitathatatlanul egy kicsit bugos. Most én prompt-- munkaterületet, majd, hogy a dollár jelet, aztán a tényleges prompt-- ez mind ugyanabban a sorban. Tehát ez minden bizonnyal egy esztétikai hiba, akkor is, ha ez nem igazán logikus hiba. 

Így fogok visszavonni, amit én csináltam. Megyek futtassa a.out. Figyeljük adtam a új sor karakter vissza. Már mentette a fájlt. 

Így fogok ujrafuttatni a.out, és-- a fenébe, egy hiba, egy hiba ami azt jelenti, hiba. Tehát a hiba az, hogy bár Én hozzá a backslash n ott, újra megmenekült, újra futott a program, a viselkedés ugyanaz volt. Miért lenne az? 

Hiányzik egy lépést, nem igaz? Ez a legfontosabb lépés a korábbi volt, hogy van alábbiakra: ha megváltoztatja a forráskódot, Kiderült is fut át a fordító újra, így kap új gépi kódot. És a gépi kód, a nullák és egyesek, lesznek majdnem azonos, de Nem teljesen így van, mert szükségünk van, persze, hogy az új vonal. 

Tehát a probléma megoldásán, megyek szüksége ujrafuttatni clanghello.c adja, pont perjel, a.out. És most, hello world vissza ahol elvárom, hogy legyen. Tehát ez mind szép és jó. De a.out egy elég hülye név egy programot, bár előfordul, hogy, történelmi okokból, a default-- jelenti összeszerelés kimenettel. 

De hadd menjen előre ide és ezt másképp. Azt akarom, hello world programot hogy valóban nevezhető szia. Tehát ha ez egy ikont az én desktop, nem lenne a.out. Ez lenne az úgynevezett szia. 

Így kell ezt csinálni, kiderül hogy csenget, mint sok program, támogatja parancssori vagy zászló, vagy kapcsolók, amely egyszerűen befolyásolják a viselkedését. Pontosabban, Clang támogatja egy kötőjel o zászló, amely aztán a második szó. Ebben az esetben, én önkényesen, de ésszerűen, nevezzük szia. De Nevezhetném semmit Azt akarom, kivéve a.out, amely lenne inkább mellett a lényeg. 

És akkor csak adja meg a nevét A fájl akarok fordítani. Tehát most még ha az elején A parancs még mindig van csenget, a végén a parancs Még mindig megvan a fájlnév, Most ezeket a parancssori érveket, ezeket a jelzőket, hogy azt mondják, ó, az úton, a kimeneti-o, a fájl úgynevezett hello, nem az alapértelmezett a.out. 

Tehát, ha én megüt Belép most, sem Úgy tűnik, hogy történt. És mégis, most meg tudom csinálni dot perjel szia. Tehát ugyanaz a program. A nullák és egyesek a azonos a végén a nap. 

De ők két különböző files-- a.out amely az első változat és csak ostoba nevű, és most hello, ami sokkal vonzóbb név egy programot. De őszintén, én soha fog emlékezni ezt újra, és újra és újra. És valóban, ahogy írunk bonyolultabb programok A parancsok te majd meg kell írni mennek, hogy még még bonyolultabbá. 

És így nem kell aggódni. Kiderült, hogy az emberek előtt nekünk rájöttek, hogy túl volt ez pontosan ugyanaz a probléma. Ők is nem élvezik, amelyek a írja meglehetősen hosszú, misztikus parancsok nemhogy emlékeznek. És így az emberek előttünk tettek Más programok, amelyek megkönnyítik összeállításához a szoftvert. 

És valóban, az egyik ilyen program neve Gyártmány. Így fogok menni előre, és erre a célra. Megyek visszavonni mindent, amit Csak nem a következő módon. Hadd írja LS. És észre fogod venni, három things-- a.out, és egy csillag, szia és egy csillag, és hello.c. Remélhetőleg, ez egy kicsit intuitív, amennyiben korábban nem volt semmi a munkaterületen. Nem volt semmi, hogy én jön létre, amíg elkezdtük osztályban. 

És hoztam létre hello.c. Aztán össze, és nevezte a.out. Aztán össze újra enyhén eltérően, és felszólította, hogy helló. Szóval van három fájl ebben a könyvtárban, Ebben a mappában az úgynevezett munkaterület. Most látom, hogy az is ha kicsinyítés valójában. 

Ha kicsinyíteni itt nézd meg, hogy a jobb felső sarok, mint ígérte a bal oldalán a képernyő mindig megy, hogy mutassa meg mi van a számla, mi belsejében CS50 IDE. És van három fájlokat. 

Ezért szeretnék megszabadulni a.out és köszön. És lehet, hogy képzelni ösztönösen, akkor lehetne rendezni az ellenőrzés kattintással vagy kattintson a jobb gombbal ezt. És ez a kis menü jelenik meg. Akkor töltse le a fájlt, fuss azt előnézetben, frissíteni, átnevezni, vagy mit nem. 

És én is csak törölni, és elmegy. De nézzük a dolgokat egy parancs vonal most úgy, hogy kényelmes ezzel, és tegye a következőket. Megyek, hogy menjen előre, és távolítsa a.out beírja szó rma.out. Kiderült, a parancs eltávolítása vagy törlése valami, nem eltávolítani vagy törölni. 

Ez tömörebben RM, csak hogy mentse néhány karakternél, és nyomja meg az Entert. Most megyünk, hogy kissé rejtélyesen A reguláris fájl a.out. Nem igazán tudja, mi az szabálytalan fájl lenne még. De azt akarom, hogy vegye le. 

Így fogok Y számára igen. Vagy tudtam írja ki, és nyomja meg az Entert. És megint semmi sem történik. De ez általában egy jó dolog. 

Ha én írja LS ebben az időben, mit látok? Remélhetőleg csak köszönni és hello.c. Most, hogy félre, akkor észre ez a csillag, csillag, ez a végén a programokat. És ők is felbukkan zöld. Ez csak CS50 IDE módja A cluing akkor az a tény, hogy ez nem a forráskódot. Ez egy végrehajtható, a futtatható program, amely akkor futtathatod ezzel pont perjel, majd azt a neve. 

Most hadd menjen előre, és távolítsa Ennek rm hello, Enter, távolítsa el a rendszeres fájl hello, igen. És ha most írja LS, mi vissza hello.c. Próbálj meg nem törli az forráskódját. Annak ellenére, hogy vannak olyan funkciók épített CS50 IDE ahol akkor megy át a módosítási előzmények és visszatekerés az időben, ha véletlenül törölni valamit, nem kell szem előtt mint egy következő választási igen vagy nem, amit valóban szeretne csinálni. És ha felmegyek a tetejére bal sarokban van, minden marad a hello.c. Tehát van fürtöket Más parancsok hajthat végre a világon a Linux, amelyek közül az egyik, ismét, Make. És megyünk készítsünk a programot most a következőképpen. 

Ahelyett, hogy csörömpölve, ahelyett, hogy csörömpölve-o, Megyek egyszerűen Szó írja, hogy helló. És most észre, én nem gépel hogy hello.c. Én beírni, hogy helló. 

És ez a program Tedd, hogy jön CS50 IDE, és így tovább általában a Linux, egy program, ami megy, hogy a program neve Hello. És ez meg fog vállalni, megállapodás szerint, hogy ha ezt a programot lehet tenni, ez meg fog tenni egy forrásból kódfájlhoz végződő dot c hello.c. 

Tehát, ha én megüt Belép most veszi észre, hogy A parancs kerül végrehajtásra, valójában még hosszabb előtt, mint korábban. És ez azért van, mert előre CS50 IDE, hogy Néhány további funkciók épült, hogy nem kell most még, de hamarosan lesz. De a legfontosabb dolog, hogy észre most már a Hello programban. 

Ha I. típusú LS megint Van egy helló programot. És én is futtatható a dot perjel a.out, nem, mert a lényege ennek a gyakorlat volt, pont perjel szia. És most már az én hello world programot. Így halad előre, vagyunk szinte mindig csak fog fordítani a programok parancs használatával Gyártmány. Aztán megyünk futni őket dot perjel, és a program nevét. De észre, mit csinál tesz az Te vagy az, hogy ez önmagában nem egy fordító. Ez csak egy kényelmi programot hogy tudja, hogyan kell kiváltani egy fordító futtatni úgy, hogy te magad is használni. 

Milyen más parancsok léteznek Linux, és viszont a CS50 IDE? Majd meglátjuk, hogy van egy CD parancs Change Directory. Ez lehetővé teszi a A parancssori felület előrelépni, és vissza, és nyissa fel a különböző mappák az egér használata nélkül. 

LS láttunk, amely áll a lista A fájlok az aktuális könyvtárban. Tedd Dir, akkor valószínűleg kezdeni a következtetés, amit ezek jelent now-- teszik könyvtár, Ha azt szeretnénk, hogy hozzon létre egy mappát. RM az eltávolításra, RM Dir számára távolítsa directory-- és ezeket, ismét, a parancssor ekvivalens, amit tehetett a CS50 IDE az egérrel. De hamarosan találja hogy néha csak sokkal gyorsabb, hogy nem dolgokat a billentyűzet, és végül sokkal erősebb. 

De nehéz azt állítani, hogy bármi, amit csináltam eddig minden, ami erős, ha minden mi már mondani, hello world. És valóban, én beégetett a szavak hello world be a programot. Nincs dinamika még. Scratch volt egy nagyságrenddel sokkal érdekesebb a múlt héten. 

És így menjünk oda. Vessünk egy lépést felé, hogy a módja néhány ilyen funkciókat. Tehát nem csak a C jön printf, és csokor egyéb funkciók amelyek közül néhány majd meglátjuk Idővel, ez nem hogy minden ilyen egyszerű egyenesen A kapu egyre felhasználótól. 

Sőt, az egyik gyenge pontja A nyelvek, mint a C, és még a Java, és mégis mások, hogy ez nem megkönnyíti, hogy csak kap ilyeneket egészek a felhasználók, illetve húrok, szavak, és kifejezéseket, nemhogy ilyeneket lebegőpontos értékek, vagy a valós számok A tizedes pontot, és tényleg hosszú számokat, ahogy azt hamarosan látni. Tehát ez a funkciók listáját itt, ezek olyanok, mint a többi Scratch puzzle-darabokat hogy már előre telepített CS50 IDE, hogy fogjuk használni egy pár hétig a képzés kerekek a fajta, és végül leveszem, és nézd a motorháztető alatt, talán a hogy ezek a dolgok végre. 

De ahhoz, hogy ezt nézzük valójában írni egy programot. Hadd menjek előre most. És megyek, hogy új fájl kattintva ez a kis plusz, , majd az Új fájl. 

Megyek menteni a következő ont, mondjuk, string.c, mert szeretnék játszani a húrok. És string C csak karakterek sorozata. Tehát most menjünk előre és tegye a következőket. 

Közé tartoznak a standard IO.h-- és Kiderült szabvány IO, IO csak azt jelenti, bemeneti és kimeneti. Így kiderül, hogy ez itt az, hogy mi A szomszédos számunkra, hogy használja printf. Printf természetesen kimenetet. Tehát ahhoz, hogy használni printf, kiderül ki van, hogy ezt a kódsort a tetején a fájlt. 

És mi jön vissza, amit hogy valójában azt jelenti, nemsokára. Kiderül, hogy a minden C program írok, Megvan, hogy indítsa el a kód, amely a következőképpen néz ki. És észre fogod venni CS50 IDE és egyéb integrált fejlesztési környezetekben, mint azt, megpróbáljuk a lehető legjobban tudják befejezni a gondolatot. Tény, hogy egy perce, ha kibont amit most tettem, elütöttem az Enter billentyűt. 

Aztán hit nyitott göndör zárójel, nyomd meg ismét. És befejeztem a gondolat. Ez adott nekem egy új vonal, behúzott nem kevesebb A szép stilisztikai okokból fogjuk látni. És akkor automatikusan kaptam hogy zárójel befejezni a gondolatot. Most, hogy nem mindig kitalálni, hogy mit szeretne csinálni. De a nagy részét, ez nem menteni néhány karakternél. Tehát egy perce futott ez program-- hello, world, majd össze azt, majd futott. De nincs dinamizmus itt. Mi van, ha azt akartuk, hogy valami mást csinálni? Nos, mi lenne, ha azt akartam, hogy valóban kap egy húr a felhasználó? Megyek, hogy egy puzzle-darab úgynevezett pontosan hogy-- kap húr. 

Kiderült, C, hogy ha nem akar hogy bemenetet egy puzzle-darab, vagy helyesebben egy funkciót, akkor szó csak nem nyitott zárójel, közel zárójel. Tehát olyan, mintha ott nincs fehér mezőbe írja be. Az mondjuk blokk előtt Volt egy kis fehér doboz. Nem kell, hogy a fehér doboz most. 

De amikor hívom get húr, azt szeretnénk, hogy az eredmény valahol. Tehát egy nagyon gyakori paradigma C a hívja a funkció, mint például a get húr van, majd tárolja a visszatérési értéket. Ez az eredmény a erőkifejtés valamit. 

És mi az konstrukció a programozás, akár Scratch vagy most C, hogy használhatja, hogy ténylegesen készlet valamit? Nevezte a változó, nem igaz? És Scratch, mi nem igazán érdekel, mi folyik a változókat. 

De ebben az esetben, valójában nem. Azt fogom mondani húr. És akkor tudtam hívni ez, amit csak akarok. Megyek nevezni nevét, kap kap húr. 

És most akkor is, ha egy kicsit új ez, észre, hogy én hiányzik néhány részlet. Én felejtés pontosvessző. Be kell fejeznem ezt a gondolatot. Így fogok mozgatni a kurzort, és a hit pontosvessző van. És mi közöm csak tenni? Ebben a kódsort, 5-ös szám abban a pillanatban, Hívom get karakterek nélkül bemenettel. Tehát nincs kis fehér doboz, mint a Save blokk. 

Csak azt mondom, hé, számítógép, hozz egy húr. Az egyenlőségjel nem igazán egyenlőségjel, per se. Ez a feladat operátor, ami azt jelenti, hé, számítógép, vigye át az értéket a jobb át a bal oldalon. És a bal oldalon, én a következőket. 

Hé, számítógép, adj egy string-- karakterek sorozata. És hívja, hogy string. És nem is kell nevezni neve. 

Nevezhetném, hagyományosan, olyasmi, mint az S, hasonlóan szoktuk i hívja az i változóra. De most meg kell tennem valamit. Nem lenne elég hülye, hogy próbálja összeállítása ezt a kódot, futás ez a program, bár Kezdek egy string, mert még mindig csak fog köszönni világban. 

De mi van, ha nem akarjuk, hogy ez megváltozzon. Miért nem tudom ezt megtenni? Százalékos s, vessző s. És ez egy kicsit rejtélyes is. 

Nos, hadd tegyem változók világosabb. Hadd nevezni ezt a változó neve. És lássuk, ha nem tudjuk ugratni eltekintve, hogy mi történik itt. 

Tehát az ötös vonalon, kapok egy string. És én tárolására, hogy a húr, függetlenül a felhasználó beírt A saját billentyűzet, a változó nevű neve. És kiderül, hogy printf nem csak hogy az egyik érv kettős idézetek, egy bemeneti idézőjelek. 

Ez lehet, hogy két, vagy három, vagy több, így hogy a második, vagy harmadik, vagy negyedik, mind a változók neveit, vagy kifejezetten értékeli, kívánt dugót, dinamikusan, hogy a string idézőjelek közé. Más szavakkal, mi lenne baj ezzel? Ha most köszöntem nevét, backslash n, megmentette a fájlt, össze a kód, és futott ez, mi fog történni? 

Ez csak azt fogja mondani, helló név, szó szerint N-a-M-E, ami elég hülye, mert ez nem különbözik a világ. Tehát bármi idézőjelbe is mi szó lett nyomtatva. Tehát, ha azt akarjuk, hogy egy helykitöltő ott, Igazából kell használni néhány speciális szintaxist. És kiderül, ha elolvassa a dokumentáció a printf függvény, megmondja, hogy ha használja százalék s, helyettesítheti egy értéket a következők szerint. 

Miután egy vessző után idézőjel, akkor egyszerűen írja a nevét, a változót, amit akar a dugó be, hogy a formátum kódot vagy formátumleíró, százalék s szálakat. És most, ha már megmentette a fájlt, Megyek vissza az én terminál. És én írja String, mert megint a neve ennek a fájl, hogy én választottam, mielőtt az string.c. 

Így fogok mondani String adja. Ó te jó ég, nézd meg az összes A hibákat csináltunk már. És ez is-- mit, ez nagyon mint egy hat, hét line programot? Tehát ez az, ahol lehet nagyon gyorsan nyomasztó. 

Ez a terminál ablak most csak regurgitated rengeteg hibaüzenetet. Bizonyára nincs több hiba üzenetek, mint én sornyi kódot. Tehát mi folyik itt? 

Nos, a legjobb stratégia tenni, amikor csak nem találkozik elsöprő hibalista így, A görgetés vissza, keresse meg a parancs csak futott, ami az én esetemben a String. Nézd meg mit csinál tett, és kész Hosszú Clang parancs, nem nagy ügy van. 

De a piros rossz. Zöld próbál lenni szelíd és segítőkész. De ez még mindig rossz, ebben az esetben. De hol van ez a rossz? 

String.c, sorban öt, képességgel öt. Tehát ez csak a józan egyezmény. Valami vastagbél valami olyan sorszám és a karakter számát. Hiba, a be nem azonosító karakterlánc. Úgy értette, hogy szabvány? 

Így sajnos csenget próbál hasznos lehet. De ez a baj, ebben az esetben. Nem, csenget, nem jelenti azt, szabványos IO. Úgy értettem, hogy on-line, igen. 

De az ötös vonalon van ez itt. És nem csenget megérteni S-T-R-I-N-G. Ez egy nem bejelentett azonosítót, szó ez csak még soha nem látott. És ez azért van, mert a C, a nyelv írunk kódot most, Nincsenek nevű változókkal szálakat. 

Ez nem alapértelmezés szerint támogatja egy úgynevezett húr. Ez egy CS50 darab zsargon, de nagyon hagyományos. De tudom kijavítani ezt a következőképpen. 

Ha hozzá egy sor kód a tetején a program, közé CS50.h, amely egy másik fájl valahol a CS50 IDE, valahol a merevlemezen, hogy úgy mondjam, Az Ubuntu operációs rendszer hogy rohanok, hogy az a fájl van tanítani fog az operációs rendszer, amit egy karakterlánc, csak mint a szokásos io.h a fájl az operációs rendszert, amely fog tanítani azt, amit ke- rül. 

Sőt, mi ütött volna egy nagyon hasonló üzenet ha IO bevallotta szabvány IO.h és megpróbálta használni printf. Így fogok menni előre, és csak Irányítsd L törölje a képernyő. Vagy akkor írja egyértelműen, és ez lesz éppen elhagyja a terminál ablakban. De akkor is lépjünk vissza az időben. 

És fogok ismételni String. Kereszt ujjaimat ezúttal Enter. Istenem, ez működött. ez azt mutatja nekem egy hosszú rejtélyes parancs ez az, amit Győződjön keresztül generált csenget, de nincs hibaüzenet. Tehát észre, bár akkor lehet, hogy teljesen túlterheltek a számú hibaüzenetek, csak lehet ezt a bosszantó lépcsőzetes hatás, ha csenget nem érti egy dolog, ami azt jelenti, hogy akkor nem érti a következő szót, vagy a következő sorban. És ez így csak fojtó a kódot. De a fix lehet egyszerű. És így mindig elsősorban a Nagyon kimenet első sora. És ha nem értem, csak nézd A kulcsszavak, hogy lehet nyomokat, és a sor számát, és a karakter, ahol ezt a hibát lehet. 

Most hadd menjen előre, és írja dot perjel, string, adja meg. Hm, ez nem köszönés semmit. Miért? Nos, emlékszem, hol van ez futás? 

Ez valószínűleg beragadt a pillanatban a hurok, ha úgy tetszik, a soros hathengeres, mert A string tervezési, írta CS50 személyzet, szó azt jelenti, hogy csak ül ott vár, és vár, és a várakozás egy húr. Minden értünk karaktersorozat emberi bemenet. Szóval tudod mit? Hadd menjek előre. És csak egy szeszély, hadd írja a nevem, Dávid, írja. Most van egy dinamikus programot. Azt mondta, szia David. 

Ha megyek előre, és futtatni ezt újra, hadd próbálja mondani Zamila nevet adja. És most van egy dinamikus programot. Nem nehéz kódolt világban. Nem nehéz kódolni megnevezni, vagy David, vagy Zamila. 

Most már sokkal több, mint a programok tudjuk, hol, ha a bemenet, termel kissé eltérő kimenetet. Nos, ez nem a legjobb felhasználói élmény, vagy UX. Azt a program futtatásához. 

Nem tudom, mit kéne csinálni, ha én tényleg nézd vagy emlékszik a forráskódot. Tehát lássuk, hogy a felhasználó tapasztal egy kicsit jobban a legegyszerűbb dolgokat. Térjünk vissza ebbe programot, és egyszerűen azt mondja printf. 

És hadd menjen előre, és azt mondják nevét, vastagbél, és egy szóközt, majd egy pontosvessző. És csak a hecc kedvéért, nem holtjáték n. És ez szándékos, mert nem akarom A prompt, hogy lépjen a következő sorra. 

Azt akarom, hogy ahelyett, hogy ezt, hogy húr újrafordítani a kód új gép kód dot perjel húr. Ah, ez sokkal szebb. Most már valóban tudja, mi a számítógép azt akarja csinálni, adja meg a nevét. 

Így fogok menni előre, és írja Rob, adja meg, és szia, Rob. Tehát, észre, ez még mindig, a végén A nap, csak kilenc line programot. De megtettük ezeket a baba lépéseket. 

Írtunk egy sort, amivel ismerős volt, printf, hello world. Aztán kinyitotta egy kicsit, hogy. És mi a ténylegesen felhasznált get húr. És mi dobta ezt az értéket egy változó. Aztán mentünk előre, és javítani tovább a harmadik sorban. És ez a megismételt írásban szoftver valóban kulcsfontosságú. A CS50, és az életben általában, akkor általában nem ül le, Van egy program, szem előtt tartva, és próbálja írás Az egész átkozott egyszerre. 

Ez óhatatlanul eredményezhet módon több hiba, mint mi magunk itt látott. Még én, a mai napig, állandóan hogy más hülyeséget, valóban nehezebb a hibákat hogy nehezebb kitalálni. De akkor hibázni a több sornyi kódot írsz egyszerre. És így ez a gyakorlat az, levelet egy kis kód hogy te kényelmes, fordítsd azt, futtatni, tesztelni még általánosabban majd mozgassa on-- így mint mi tartott rétegezés és rétegződés a múlt héten, építkezés valami nagyon egyszerű valami bonyolultabb, ugyanígy van. Ne üljön le, és próbálja írni egy egész probléma. Valójában ezeket baba lépéseket. 

Most, húrok nem minden hogy hasznos maguknak. Mi lenne valóban ideális, mint a van valami más a mi eszköztár. Tehát lássuk valójában pontosan erre. 

Hadd menjen előre, és most felkap egy kicsit más programot. És hívjuk ezt int.c, az egész. Megyek, hasonlóan, tartalmazzák CS550.h. Megyek közé tartoznak a standard IO. És ez lesz elég gyakori ezek az első néhány napon az osztály. 

És fogok kész magam egy fő funkciója. És most ahelyett, hogy egy string, menjünk előre, és kap egy int. Nevezzük i, és hívja meg fog int, közel parens, pontosvessző. És most lássuk a vele valamit, printf. 

Tegyük fel, hogy valami hasonló hello, backslash n, vessző i. Úgyhogy elég sok utánzó amit tettem, csak egy perccel ezelőtt. Van egy helykitöltő itt. Már vesszővel válassza i itt, mert azt akarom, plug i abba a helykitöltő. 

Szóval menjünk előre, és próbálja összeállítása ezt a programot. A fájl neve int.c. Így fogok mondani, hogy int, adja meg. Istenem, de nem nagy ügy, ugye? Van egy hiba. 

Van egy szintaktikai hiba Itt olyan, hogy a program nem tud összeállításának belül int.c, vonal hét, karakter 27, hiba formátum meghatározza típusa char csillag, bármi is legyen az. De az érvelés típus int. 

Tehát itt is, nem fogunk az alábbiakra: noha ma egy csomó anyagot, megyünk eluralkodjon rajtad a feltétlenül minden vonása C, és programozási általánosabban mindössze ezek az első hetekben. Tehát ott gyakran lesz zsargont amellyel Ön nem ismeri. És valóban, char csillag van valami megyünk, hogy jöjjön vissza Egy-két hét múlva. 

De most, lássuk, ha tudjuk elemezni szavak, amelyek ismerősek. Formats-- így hallottuk formátumban specifikátor, formátum kód előtt. Ez ismerős. Type-- de az érv azonban int típusú. Várj egy percet, én egy int. 

Talán százalék s valójában van néhány meghatározott. És valóban, ez nem. Egy egész szám, ha azt szeretné, printf helyettesítjük,, hogy tényleg kell használni különböző formában adja meg. És azt nem tudom, ez a hacsak valaki azt mondta, vagy ha már csinált ilyet. De százalék i mi lehet általánosan használt printf dugulás az egész. Ön is használja százalék d egy decimális egész. De én szép és egyszerű itt. Így megyünk vele. 

Most hadd menjen előre, és ismétlését make int, Enter. Ez jó, nincs hiba. Dot perjel int-- OK, rossz felhasználói élményt, mert én még nem mondtam magamnak mit kell tenni. De ez rendben van. Én fogása a gyorsan. 

És most hadd menjen előre, és írja be David, OK, Zamila, Rob. OK, így ez egy jó dolog. Ezúttal én függvény segítségével, egy puzzle-darab, az úgynevezett get int. És kiderül out-- és mi lásd később a term-- A CS50 személyzet által végrehajtott A string oly módon hogy csak akkor fizikailag kap egy string az Ön számára. 

Végrehajtotta get int oly módon, hogy csak akkor kap egy egész neked. És ha az ember, nem működnek együtt, akkor szó szerint csak megy mondjuk újra, újra, újra, Szó szerint ott ül ciklusok, amíg Ön kötelezi valamilyen mágikus szám, mint 50, és helló 50. 

Vagy ha futtatni ezt újra és írja be a 42, helló 42. És így a get int függvény belsejét, hogy puzzle-darab elég logika, elég a gondolat, kitalálni, mi is az a szó? És mi az a szám? Csak elfogadja végül számokat. 

Így kiderül, hogy ez a egyáltalán nem olyan kifejező. eddig. Tehát, yay, utoljára ment elég gyorsan a végrehajtási játékok és animáció, és művészeti alkotások Scratch. És itt vagyunk, hogy tartalmi A hello world, és helló 50. 

Ez még nem minden, hogy inspiráló. És valóban, ezek az első néhány példák némi időt vesz igénybe hogy a földi fel izgatottan. De van még sok minden más irányítani őt, sőt. És megyünk nagyon gyorsan indul rétegződés Ezen felül az alap primitívek. 

De először nézzük megérteni milyen korlátai vannak. Tény, hogy az egyik dolog, Kaparós könnyen ne tegyük valóban néz a motorháztető alatt, és megérteni, mi a számítógép, mit tehet, és mik a korlátai vannak. És valóban, hogy hiánya megértés, potenciálisan, a hosszú távú vezethet a saját mistakes-- írásban hibákat, írás bizonytalan szoftver meghackelésének valamilyen módon. 

Szóval vessünk néhány lépést felé megértés ez egy kicsit jobban módja, mondjuk, a következő példát. Megyek, hogy menjen előre és végrehajtása tényleg gyorsan a program neve kiegészítőkre. Mint, adjunk néhány számot együtt. És fogok kód Egyes sarkok Itt, és csak a másolás és beillesztés ahol azelőtt voltam, csak így tudjuk majd előbb. Tehát most kaptam az alap kezdetei a program neve kiegészítőkre. 

És menjünk előre, és erre a célra. Megyek megy előre, és mondjuk intx kap kap int. És tudod mit? Csináljunk egy jobb felhasználói élményt. 

Tehát mondjuk, x, és hatékonyan figyelmezteti a felhasználót, hogy nekünk x. És akkor hadd menjen előre, és azt mondják, printf mi lenne, y, ezúttal vár két érték a felhasználó. És akkor nézzük csak megy előre, és mondjuk, printf, az összeget az x és y. És most nem akarok százalék s. Azt akarom, hogy százalék i, backslash n, majd csatlakoztassa összeg értékét. 

Akkor hogyan kezdjen csinálja ezt? Tudod mit? Tudom, hogyan kell használni változók. Hadd nyilvánítja egy újat, int z. 

És én megyek, hogy egy kitalálni itt. Ha vannak egyenlő jelek ebben nyelv, talán csak csinálni x plus y, amíg én véget a gondolta pontosvessző? Most mehetek vissza ide, csatlakoztassa z, befejezni ezt a gondolatot pontosvessző. És nézzük csak, ha ezek a szekvenciák lines-- x kap int. Y kap int. 

Hozzáadása az X és Y, tárolja az értéket z-- így ismét emlékezni az egyenlőségjel nem egyenlő. Ez hozzárendelés jobbról balra. És lássuk kinyomtatni, hogy az összeg X és Y nem szó Z, de mi van benne z. Tehát tegyük Vipera - szép, nincsenek hibák ebben az időben. Dot perjel Vipera, adja meg, x lesz 1. 

Y lesz 2. És az összeg a X és Y jelentése 3. Szóval ez mind szép és jó. 

Tehát azt képzelni, hogy a matematika kellene dolgozni egy programot, mint ez. De tudod mit? Ez változó, vonal 12, még szükség? Nem kell, hogy a szokás csak tárolja a dolgokat változók Csak azért, mert te. És valóban, ez általában tekinthető rossz tervezés ha létrehoz egy változót, az úgynevezett Z Ebben az esetben, tárolása valami benne, majd azonnal használhatja, de soha többé. Miért adnak valamit a neve mint z ha a szó szoros értelmében fogja használni, hogy dolog csak egyszer, és így proximális hol hozta létre ez az első helyen, Olyan közel szempontjából sornyi kódot? Szóval tudod mit? Kiderült, hogy a C elég rugalmas. Ha valóban akar plug-in értékeket itt, Nem kell, hogy állapítsa meg egy új változót. Tudtam csak plug-in x plus y, mert a C megérti számtani és matematikai műveletek. 

Így tudok csak mondani, hogy ezt a matematika, x plus y, amit ezek az értékek, csatlakoztassa a kapott integer be, hogy a húr. Tehát ez lehet, bár csak egy sor rövidebb, egy jobb design, egy jobb program, mert ott kevesebb kódot, ezért kevésbé értem, hogy megértsék. És ez is csak tisztább, amennyiben nem vagyunk hogy új szavakat, új szimbólumok, mint a Z, annak ellenére, hogy nem igazán szolgálhat sok a célját. 

Sajnos, a matematika nem minden megbízható néha. Menjünk előre, és erre a célra. Megyek, hogy menjen előre most és tegye a következőket. 

Csináljuk printf, százalék i, plusz százalék i kell lennie százalék i, backslash n. És én fogom csinálni this-- xyx plusz y. Tehát én csak fog átírni ez kicsit másképp van. Hadd egy gyors biztonsági ellenőrzést. Ismét, ne rohanjunk előre. Tedd összeadó, pont perjel vipera. x értéke 1, y értéke 2, 1 plusz 2 3. Tehát ez jó. De nézzük bonyolítják ezt most egy kicsit, és hozzon létre egy új fájlt. 

Megyek hívás ez, mondjuk, ints, többes egészek. Hadd kezdjem, hol voltam az imént. De most lássuk néhány más vonalakon. Hadd menjek előre, és ezt a következő, printf, százalék i, mínusz százalék i, hány százaléka i, vessző x, vessző yx mínusz y. Tehát csinálok egy kicsit különböző matematikai ott. Csináljunk egy másikat. Tehát százalék i-szer százalék i százalék i, backslash n. Nézzük plug-in x és y és x-szer y. Használni fogjuk a csillag a A számítógép az alkalommal. 

Nem használjuk az x. x értéke egy változó nevét. Ön a csillag a szorzás. Csináljunk még egy. Printf százalék I, osztva százalék szerint i, a százalékos i, backslash n. xy osztva y-- így használja a perjel a C csinálni részlege. És lássuk egymást. Fennmaradó százalék i, osztva százalék szerint i, a százalék i. xy-- és most fennmaradó az, ami maradt. Amikor megpróbál felosztásával nevező egy számláló, mennyi maradt, hogy nem lehetett osztani ki? 

Tehát nincs igazán, szükségszerűen, egy szimbólum már használt az iskolában erre. De a C. Akkor mondjuk x modulo y, ahol ezt százalék jel ebben context-- zavaróan, ha bent Az idézőjel, belsejében printf, százalék használjuk a formátum meghatározásakor. 

Amikor használja százalék kívül hogy egy matematikai kifejezést, ez a modulo operátor a moduláris arithmetic-- céljainknak Itt csak azt jelenti, hogy mi a fennmaradó x osztva y? Tehát x osztva y x y perjel. Mi a maradék x osztva y? Ez x mod y, mint programozó mondaná. 

Tehát, ha én tett hibákat itt, hadd megy előre, és ints, többes szám, szép, és pont perjel ints. És menjünk előre, és igen, mondjuk, 1, 10. Rendben, 1 + 10 11, ellenőrzése. 1 mínusz 10 negatív 9 ellenőrizze. 

1 alkalommal 10 10, ellenőrzése. 1 osztva 10 is-- OK, akkor hagyja, hogy az egyik. Fennmaradó 1 osztva 10 1. Így van. De van egy hiba van. 

Tehát az egyik tettem átadni, nem helyes. Úgy értem, ez közel 0. 1 osztva 10, tudja, ha mi vagyunk vágás néhány sarkok, biztos, hogy ez nulla. De ez tényleg legyen 1/10, 0,1, illetve 0,10, 0,1000, vagy így tovább. 

Meg nem igazán lehet nulla. Nos, kiderült, hogy a számítógép csinál szó, amit mondtunk, hogy igen. Tesszük a matematika, mint x osztva y. És mind a X és Y egy a vonalak A kód a korábbi, egész számok. 

Sőt, on line 15, vagyunk mondja printf, hé, printf plug-in egész, plug-in egy egész, plug-in egy integer-- kifejezetten x, majd y, majd x osztva y. x és y ints. Mi jó van. 

De mi van x osztva x? x osztva y legyen, matematikailag, 1/10, vagy 0,1, ami egy valós szám, valós szám amelynek potenciálisan egy tizedes pontossággal. Ez nem egy egész szám. 

De mi van a legközelebb integer 1/10 vagy 0,1? Igen, ez a fajta nulla. 0.1, mint ez sok. 1 ez sok. Tehát 1/10 közelebb áll 0, mint az, hogy egy. 

És akkor mi van a C tesz az us-- fajta, mert azt mondtuk, hogy az alábbiakra: A csonkított hogy egész. Ez figyelembe az értéket, ami ismét állítólag valami hasonló 0,1000, 0 és így tovább. És ez csonkolása mindent tizedesvessző után úgy, hogy mindez dolog, mert nem illeszkedik a fogalom egy egész, ami csak egy szám, mint a negatív 1, 0, 1, fel és le, akkor dob el mindent a tizedespont után, mert nem fér a tizedesvessző Egy egész definíció szerint. 

Tehát a válasz itt nulla. Szóval hogyan lehet ezen javítani? Szükségünk van egy másik megoldás együtt. És ezt meg tudjuk tenni, a következők szerint. 

Hadd menjen előre, és hozzon létre egy új fájlt, ez az egyik az úgynevezett floats.c. És mentse el itt a Ugyanebben a könyvtárban float.c. És hadd menjen előre, és másolja bizonyos, hogy a kódot korábban. 

De ahelyett, hogy int, csináljuk ezt. Adj egy lebegőpontos értéket úgynevezett x. ahol egy lebegőpontos érték csak a szó szoros értelmében valami egy lebegőpontos. Meg tudja mozgatni a bal oldalon, a jobb oldalon. Ez egy valós szám. 

És hadd hívjam fel nem kap int, de kap úszó, ami szintén egyike volt a menü A lehetőségek a C250 könyvtárban. Változtassunk y egy úszó. Tehát ez lesz kap úszó. 

És most, mi nem akarjuk, hogy csatlakoztassa a ints. Kiderült, mi kell használni százalék f float, százalék f float, és most menteni. És most, drukkolás, hogy úszók, szép, pont perjel úszik. x lesz egy 1 y Lesz 10 újra. 

És szép, OK én kívül helyes. Reméltem, hogy több, de elfelejtettem írni. Szóval menjünk és kijavítani a logikai hiba. 

Menjünk előre, és megragad a következőket. Majd csak egy kis másolás és beillesztés. És én fogom mondani mínusz. 

És én fogom mondani alkalommal. És fogok mondani osztva. És nem fogok csinálni modulo, ami nem olyan illenek ide, osztva f és idők plus-- Oké, ezt újra. 

Tedd úszók, pont perjel úszók, és 1, 10, és-- szép, nem, OK. Tehát egy idióta vagyok. Tehát ez nagyon gyakori számítástechnika hogy ostoba hibákat, mint ez. 

Pedagógiai célokra, amit igazán akartam csinálni volt változtatni a tudomány itt plusz, mínusz, a szer, és osztani, ahogy remélhetőleg észrevette e gyakorlata során. Tehát most nézzük újra összeállítja ezen programban, tegye dot perjel úszik. 

És a harmadik alkalommal, nézzük lásd, ha megfelel az elvárásaimnak. 1., 10., adja, igen, az OK, 1000, osztva 10.000, az 0,100000. És kiderül, tudjuk irányítani, hogy hány számok után azok tizedes pont. Mi valóban lesz. Majd gyere vissza, hogy a. 

De most, sőt, a matek helyes. Szóval, megint mi a elvihető itt? Kiderült, hogy a C-ben vannak nem csak most strings--, és valójában, nincs igazán, mert hozzá ezeket a CS50 könyvtár. De nem csak ints. 

Vannak is úszik. És kiderül, egy csomó más adat típusok is, hogy fel fogjuk használni nemsokára. Kiderült, ha szeretné, hogy egyetlen karakter, nem egy karaktersorozatot, akkor csak egy karakter. 

Kiderült, hogy ha szeretne egy bool, egy logikai érték, igaz vagy hamis, csak köszönhetően a CS50 könyvtár, most már hozzáadott C bool adattípust is. De ez is jelen van Sok más nyelveken is. És kiderül, hogy néha szükség nagyobb számban jönnek majd alapértelmezés szerint A ints és úszik. 

És, sőt, egy dupla egy szám használó nem 32 bit, de 64 bit. És egy hosszú, hosszú az a szám, használ nem 32, hanem 64 bit bit, illetve lebegőpontos értékek és egész számok, ill. Úgyhogy tulajdonképpen most hogy ez a fellépés. 

Megyek, hogy menjen előre itt és felkap egy másik program. Itt fogok menni előre és nem tartalmazzák CS50.h. És hadd menjen, akkor a szokásos IO.h. 

És észre fogod venni valamit funky történik itt. Ez nem színkód- dolgokat ugyanúgy, mint korábban. És kiderül, hogy azért, mert nem adott a dolog egy fájlnevet. 

Azt fogom hívni ezt sizeof.c, és a hit mentése. És vegyük észre, mi történik a nagyon fehér kód ellen, hogy a fekete hátteret. Most legalább van néhány lila ott. És ez szintaxis kiemelve. 

Azért, mert egészen egyszerűen én már mondta az IDE milyen típusú fájlt ez ad neki egy nevet, és konkrétan a fájl kiterjesztését. Most menjünk előre, és erre a célra. Megyek, hogy menjen előre, és nagyon Egyszerűen nyomtassa ki a following-- bool hány százaléka LU. 

Majd jönnek vissza hogy csak egy pillanatra. És akkor megyek nyomtatási méretét bool. És most, csak hogy mentse magam egy ideig, én fog tenni egy egész csomó ilyen egyszerre. És konkrétan fogok megváltoztatni ezt a char és char. Ez az egy, fogok változtatni egy dupla és egy dupla. 

Ez az egy, fogok változtatni az úszó és az úszó. Ez az egy, megyek megváltoztatni egy int és int. És ez, megyek megváltoztatni, hogy egy hosszú, hosszú. És ez még mindig figyelembe hosszú ideig, hosszú, hosszú. 

És akkor végül adtam magam is sok, húr. Kiderült, hogy a C-ott A különleges operátor úgynevezett mérete, ami a szó szoros értelmében megy, ha fut, mondja el nekünk a méret minden egyes ilyen változókat. És ez az egyik módja, most, tudunk kapcsolódni vissza a múlt heti vita Az adatok és a reprezentáció. 

Hadd menjek előre, és összeállítja mérete pont perjel mérete. És lássuk. Kiderült, hogy a C, kifejezetten CS50 IDE, kifejezetten a operációs rendszer Ubuntu, amely egy 64 bites operációs rendszer ebben az esetben A bool fog használja egy bájt helyet. Így méret mérjük, nem bit, de a bájt. És emlékszem, hogy egy bájt nyolc bit. Tehát egy bool, még akkor is, technikailag csak kell egy 0 vagy 1, ez egy kicsit pazarló hogyan mi már meg is valósították. Ez valóban megy, hogy egy egész byte-- így minden nullák vannak talán egyesekből, vagy valami ilyesmi, vagy csak egy 1 között nyolc bit. 

A char, eközben használják a karakter mint egy ASCII karaktert tartalmazó múlt héten, lesz egy karakter. És hogy synchs fel azzal az elképzeléssel, a hogy azt nem több, mint 256 bits-- inkább, synchs fel vele, hogy nem hosszabb, mint 8 bit, amely ad nekünk több mint 256 értékeket. A kettős fog 8 bájt vagy 64 bit. 

Az úszó 4. Int 4. Hosszú, hosszú 8. És egy sor 8. De ne aggódj. Fogunk húzza vissza, hogy a réteg. Kiderült, stringek több, mint 8 bájt. 

És valóban, írtunk húrok már, hello world, hosszabb, mint 8 bájt. De mi jön vissza hogy csak egy pillanatra. De elvenni itt a következő. 

Minden számítógép csak véges memória mennyisége és a tér. Egyszerre csak annyi tárolni fájlokat a Mac vagy PC. Akkor csak tárolni annyi programok RAM fut egyszerre, szükségszerűen, még A virtuális memória, mert van egy véges mennyiségű RAM. 

És csak azért, hogy picture-- ha soha nem nyitotta meg a laptop vagy megrendelt extra memória Egy számítógépre, Lehet, hogy nem tudják, hogy számítógép belsejében van valami, ami úgy néz ki, Egy kicsit olyan, mint ez. Tehát ez csak egy közös cég neve Döntő fontosságú, hogy teszi a RAM számítógépek számára. És a RAM, ahol programok élni, míg ők fut. 

Tehát minden Mac vagy PC, ha megduplázza kattintson a program, és ez megnyitja, és megnyitja néhány Word dokumentum vagy valami ilyesmi, tárolja az átmeneti, RAM, mert a RAM gyorsabb mint a merevlemez, vagy A szilárdtest lemezt. Tehát csak ha a programokra megy élni, ha futsz, vagy ha fájlok használatban vannak. 

Szóval van a dolgok úgy néz mint ez a belsejében a laptop, vagy kissé nagyobb dolgok belsejében az asztalon. De a legfontosabb az, hogy csak egy véges számú ilyen dolgok. És csak véges mennyiségű hardver ül ezen a pult jobb itt. 

Így biztosan nem tudjuk tárolni végtelen hosszú számokat. És mégis, ha úgy gondolja, vissza általános iskola, hány számjegy lehet van, hogy a megfelelő A tizedespont? Ami azt illeti, hány számjegy lehet van, hogy a bal oldalon a tizedesvessző? Valóban, végtelen sok. 

Most, mi emberek talán csak tudja, hogy kell kimondani millió és milliárd billió, és trillió és trillió. És én határainak kitolása én understanding-- vagy my-- Megértem szám, de a kiejtése számok. De vannak végtelenül nagy a végtelen sok számjegyek a bal oldalon vagy jobbra egy tizedes pontossággal. 

De a számítógépek csak egy véges mennyiségű memóriát, véges számú tranzisztorok, egy véges számú izzók benne. Tehát mi történik, ha elfogy a hely? Más szóval, ha gondoljon vissza a múlt héten amikor beszéltünk a számok magukat, hogy binárisan, Tegyük fel, hogy megvan ez 8-bites értéket. 

És mi van a hét 1 és egy 0. És tegyük fel, hogy azt akarjuk, hozzá 1 erre az értékre. Ez egy nagyon nagy szám most. 

Ez 254, ha jól emlékszem A matematika a múlt héten jobb. De mi van, ha én változtatni hogy jobb szélső 0 1? Az egész szám, a Természetesen lesz nyolc 1-eken. Tehát még mindig jó. 

És ez talán jelent 255, bár a környezettől függően ez már valóban képviseli negatív szám. De még az, hogy egy másik alkalommal. Ez olyan, mint ez körülbelül olyan magas, mint tudok számolni. 

Most ez csak 8 bitet. És a Mac, biztosan, van módja több, mint 8 bit memória. De ez nem is véges. Tehát ugyanaz az érv vonatkozik, még akkor is, ha Van több ezek közül a képernyőn. 

De mi történik, ha már tárolására ez a szám, 255, és szeretne számolni 1 bit magasabb? El akar menni 255-256. A probléma persze az, hogy ha elkezd számolás nulla, mint a múlt héten, akkor nem számít nagy 256, nemhogy 257, nemhogy 258, m mert mi történik, ha egy 1? Ha nem a régi általános iskola megközelítés, akkor tesz egy 1 van, majd 1 plusz 1 2, de ez valóban nulla, akkor végezze a 1, hordozzák 1 hordozzák 1. Mindezek a dolgok, ezeket 1-es, megy nullára. És a szél fel, igen, ahogy valaki rámutatott, 1 a bal oldalon. De mindent, amit lehet valóban látni és illik a memóriában csak nyolc 0-k, ami azt egy bizonyos ponton, ha egy számítógép, Próbáltam számolni elég magas fel, akkor majd tekerje körül, úgy tűnik, nullára, vagy talán még negatív számokat, amelyek még alacsonyabbak, mint nulla. 

És mi lehet a fajta látni ezt. Hadd menjek előre, és levelet egy igazi gyors program itt. Hadd menjek előre, és levelet a program neve túlcsordulás. Tartalmazza CS50.h tartalmazzák szabvány IO.h-- ó, Nagyon hiányzott a szintaxis kiemelést. Úgyhogy menteni ezt overflow.c. 

És most int main void-- és hamarosan fogunk jöjjön vissza, hogy miért őrizzük írásban int main semmis. De most, nézzük csak ezt , figyelembe magától értetődőnek. Adjunk magam int, és inicializálása 0-ra. 

Nézzük akkor csinálni int kapok zero-- valójában, csináljuk egy végtelen ciklus és hogy mi történik. Bár igaz, akkor menjünk ki kell nyomtatni n hány százaléka i, backslash n, plug-n. De most, csináljuk n kapja az n + 1. 

Más szóval, az egyes iterációs e végtelen ciklusba, vessünk n értékét, és adjunk hozzá 1-et, majd a tárolja az eredményt vissza n a bal oldalon. És valóban, láttunk szintaxis kissé, mint ez, röviden. A hűvös trükk helyett az írás mindezt ki, akkor valójában azt mondják, egy n plusz 1 egyenlő. 

Vagy ha igazán akar, hogy divatos, azt lehet mondani n plus plus pontosvessző. De ez utóbbi kettő csak amit hívnám szintaktikai cukor Az első dolog. 

Az első dolog, konkrétabb, Teljesen rendben van, teljesen korrekt. De ez sokkal gyakoribb, azt mondom. Tehát mi ezt csak egy pillanatra. 

Nézzük most, hogy túlcsordulás, ami úgy hangzik, meglehetősen baljós, pont perjel túlcsordulás. Lássuk, n kezd elég nagy. De lássuk csak, milyen nagy lehet n kapni? 

n int. Láttunk egy perce a mérete Például, hogy egy int négy bájt. Tudjuk a múlt héten négy bájt 32 bit, mert 8-szor 4, ez a 32. Hogy lesz 4000000000. 

És akár 800.000. Ez fog tartani örökre számítanak olyan magas, mint én csak lehet. Így fogok menni előre, ahogy talán nemsokára, és a hit Ellenőrző C-- őszintén, vezérlés C, egy csomó, ahol kontroll C általánosan eszközökkel megszünteti. Sajnos, mert ez a fut a felhő, Néha a felhő kiköpte annyi cuccot, annyira kimenet, ez lesz a hogy egy kicsit az én bemenet hogy a felhő. Tehát annak ellenére, hogy elérje Kontroll C néhány másodperccel ezelőtt, ez határozottan az oldalsó hatása végtelen ciklust. 

És így ilyen esetekben vagyunk elhagyják azt lehet. És megyünk, hogy egy újabb terminál ablakot ide a plusz, ami természetesen nem így, mivel ez még mindig gondol. És menjünk előre, és egy kicsit ésszerűbb. 

Megyek, hogy menjen előre, és nem ez csak véges sokszor. Vegyünk egy hurok, amely utaltam korábban. Csináljuk. Adj még egy változó int i lesz 0. i-nél kisebb, mondjuk, 64 i ++. És most hadd menjen előre, és a nyomtatási out n százalék i, vessző n. És akkor n-- ez még mindig fog tartani örökre. Csináljuk. 

n lesz n-szer 2. Vagy mi lehet divatos és nem szer értéke 2. De mondjuk, n egyenlő önmagában alkalommal 2. Más szavakkal, ebben a új változata a program, Nem akarok örökké várni től, mint 800.000 4000000000. Essünk túl rajta. 

Nézzük tulajdonképpen kétszeresére n minden alkalommal. Mely, visszahívás, duplázás az ellentéte annak, persze. És mivel az elmúlt héten már valami újra, és újra, és újra, szuper gyors, megduplázása biztosan minket 1-től a lehető legnagyobb érték, hogy tudjuk számolni, hogy egy int. 

Tehát lássuk, pontosan ezt. És mi jön vissza ezt megelőzően hosszú. De ez megint olyan, mint Az ismétlés blokk Scratch. És akkor használja ezt megelőzően hosszú. 

Ez csak azt jelenti száma nullától akár, de nem egyenlő, a 64. És minden egyes iterációs e hurok, csak tartsa megnő i. Tehát i ++ - és ez általános konstrukció on line 7 csak egy szuper közös utat ismétlődő néhány sor kódot, bizonyos számú alkalommal. Melyik sornyi kódot? Ezek zárójelekkel, ahogy Lehet, hogy gyűjtött most, azt jelenti, tegye a következőket. 

Ez az, mint Scratch, amikor azt a sárga blokkok és más színű, hogy a fajta ölelés vagy ölelés más blokkokat. Ez az, amit ezek a göndör támaszra van itt. Tehát, ha kaptam szintaxis right-- te Láthatjuk a sárgarépa szimbólum a C eszköz ez hányszor voltam próbálják megoldani ezt a problémát. Tehát lássuk megszabadulni, hogy az egyik Összesen, és zárja be az ablakot. És mi az újat. Tedd túlcsordulás, pont perjel túlfolyó, Enter, rendben, úgy néz ki rosszul az első. De nézzük lépjünk vissza az időben, mert ezt tettem 64 alkalommal. 

És észre először, n = 1. Másodszor, n értéke 2, majd a 4, akkor 8, majd 16. És úgy tűnik, hogy amint Kapok nagyjából 1 milliárd ha én dupla újra, hogy adj 2000000000. De kiderült, hogy ez közvetlenül a csúcspont. 

És ez így valóban túlcsordul Egy int 1000000000 nagyjából negatív 2 milliárd, hiszen egy egész, ellentétben a számokat mi arra feltételezve a múlt héten, egyaránt lehet pozitív és negatív a valóságban, és a számítógép. És így legalább az egyik az említett bit hatékonyan ellopták. Tehát tényleg csak 31 bitet vagy 2000000000 lehetséges értékeit. 

De most, a elvihető meglehetősen Egyszerűen, bármit ezek a számok és bármi is az matek, valami rossz történik végül, mert végül is próbál permutálni a biteket egy túl sokszor. És akkor hatékonyan megy minden 1-eket, talán az összes 0-k, vagy talán Csak valami más mintát, hogy egyértelműen, a környezettől függően, lehet értelmezni, mint egy negatív szám. És így úgy tűnik, a legmagasabb I számíthat ebben a konkrét programot csak nagyjából 1 milliárd. De van egy részleges megoldást. Tudod mit? 

Hadd változik egy int, hogy egy hosszú, hosszú. És hadd menjen előre ide és say-- megyek, hogy hogy ez megváltozzon, hogy egy aláíratlan hosszú. Vagy nézzük, soha nem emlékszem magam. 

Menjünk előre, és a túlfolyó. Nem, ez nem az, LLD, köszönöm. Így néha Clang hasznos lehet. Nem emlékszem, milyen formátumban specifikátor volt egy hosszú, hosszú. 

De valóban, Clang mondta. Zöld valamilyen jó, még azt jelenti, hogy hibát követett el. Ez találgatás, hogy komolyan gondolom LLD. 

Szóval hadd vigye tanácsát, hosszú hosszú decimális szám, kivéve, hogy. És hadd ismételni azt, pont perjel túlcsordulás, Enter. És most mi jó ez. 

Ha görgetni vissza az időben, még mindig indul számolás ugyanazon a place-- 1, 2, 4, 8, 16. Figyelmeztetés, megkapjuk a egészen 1000000000. De aztán biztonságosan eljutni 2000000000. 

Aztán eljutunk 4000000000, akkor 8000000000, 17000000000. És megyünk a magasabb és magasabb, és a magasabb. Végül is ez is eltörik. 

Végül, hosszú, hosszú, amely a 64-bites érték, nem egy 32 bites érték, ha számít túl magas, akkor átfordul 0. És ebben az esetben, mi történetesen a végén egy negatív szám. 

Tehát ez a probléma. És kiderül, hogy ez a probléma egyáltalán nem olyan bonyolult. Bár én már szándékosan indukált ezekkel a hibákat, kiderül, azt látjuk, hogy a fajta minden körülöttünk, vagy legalábbis néhány ránk. 

Tehát Lego Star Wars, ha amit valaha is játszottam a játékot, kiderül, hogy lehet menni a környéken törés dolgokat LEGO világ, és gyűjtött érmék, lényegében. És ha valaha is játszottam ez a játék túl sok időt, mivel ez nem nevezett egyén itt volt, a teljes száma érmék, amit gyűjteni van, úgy tűnik, 4000000000. 

Most, ez valóban kerekítve. Tehát LEGO próbált dolgokat felhasználóbarát. Azt nem tette meg, pontosan 2 A 32 erő, egy a múlt héten. De 4000000000 oka. Úgy tűnik, ezen információk alapján, hogy LEGO, és a cég tette ezt a szoftver tényleges, úgy döntött, hogy a maximális számú érmék A felhasználó gyűlhet Valóban, 4000000000, mert úgy döntött, saját kód használata nem egy hosszú, hosszú, úgy tűnik, de csak egy egész, egy aláíratlan egész szám, csak egy pozitív egész szám, melynek max érték nagyjából ezt. Nos, itt van egy másik vicces. Tehát a játék Civilization, amely néhány ismerős lehet, a kiderül, hogy évekkel ezelőtt ott Volt egy hiba a játékban, ahol ha játszott szerepét Gandhi a játékban, helyette, hogy nagyon pacifista, ehelyett hihetetlenül, hihetetlenül agresszív, bizonyos körülmények között. Különösen az is, hogy civilizáció úgy működik, hogy ha a játékos, elfogadja a demokrácia, az agresszivitás pontszámot kap csökkentjük két, így mínusz mínusz, majd mínusz mínusz. 

Tehát akkor vonjuk 2 a tényleges iterációjával. Sajnos, ha a iterációjával van kezdetben 1, és akkor vonjuk 2 belőle elfogadása után a demokrácia Gandhi itt talán volna, mert nagyon passive-- 1 a skála az agresszivitás. De ha elfogadja a demokráciát, akkor megy 1-től negatív 1. 

Sajnos, ezek voltak használatával előjel nélküli számok, ami azt jelenti, hogy kezelni akár negatív számokat, mintha pozitív. És kiderül, hogy a pozitív megfelelőjét negatív 1, tipikus számítógépes programok, 255. Tehát, ha Gandhi fogad a demokrácia, és ezért az agresszivitás pontszám csökkent, valójában tekercsek körül 255 és teszi őt a legnagyobb agresszív karakter a játékban. Így Ráguglizhatsz fel ezt. És ez volt, sőt, a véletlen programozás bogár, de ez elég lépett A tan azóta. 

Ez minden szórakoztató és aranyos. További ijesztő az, amikor a tényleges valós eszközök, nem játékok, ezeket ugyanazon hibákat. Tény, hogy egy évvel ezelőtt egy cikket jött ki a Boeing 787. 

És a cikk első pillantásra szól egy kicsit bonyolult. De azt mondta, ez egy szoftver sebezhetőségét Boeing új 787 Dreamliner Jet okozhatnak pilóták elveszíteni az irányítást A repülőgép, esetleg közepén repülés, az FAA hivatalnokok figyelmeztetett légitársaságok közelmúltban. Ez volt a meghatározás hogy a modell 787 repülőgép, amelyet meghajtású folyamatosan 248 napot elveszíthetik minden váltóáram AC, elektromos teljesítmény miatt a generátor vezérlőegységek, GCUs, egyidejűleg megy nem biztos mód. Ez a fajta vesztes rám. De a feljegyzésben kifejtette, OK, most kaptam, hogy Az állapot okozta szoftver számláló belső A generátor vezérlő egységek túlcsordul után 248 napos folyamatos teljesítmény. Mi kiadó ezt észre, hogy megakadályozzák veszteség Az összes elektromos AC erő, ami azt eredményezheti, elvesztése a repülőgép irányítását. 

Tehát, a szó szoros értelmében, van némi értéke, vagy más, hasonló adattípus, használják szoftver Egy valódi repülőgép hogy ha folyamatosan a repülőgép elég hosszú, ami látszólag lehet a helyzet, ha éppen fut őket folyamatosan és soha kihúzásával A repülőgép, úgy tűnik, vagy hagyta az akkumulátorokat meghal, végül számítanak fel, és legfeljebb, és fel, és fel, és fel, és fel. 

És a természet, a véges mennyiségű memóriát kifut, hengerelt vissza nulla vagy egy negatív értéket, mellékhatása, amely az ijesztően valóságos valóság hogy a gép szüksége lehet újra kell indítani, hatékonyan, vagy érinthet, még rosszabb, mint a legyek. Tehát az ilyen jellegű problémák még mindig velünk, even-- ez egy 2015 cikket, annál is inkább ijesztő amikor nem feltétlenül megértésében, értékelésében, vagy előre az ilyen jellegű hibák. 

Így kiderül, van egy másik rossz dolog adatábrázolás. Kiderült, hogy még úszók fajta hibás, mert úszik is, Azt javasolt 32 bit, vagy talán 64 ha egy dupla. De ez még mindig véges. 

És a fogást, hogy ha tudsz tedd végtelen számú számok a tizedespont után, nincs módja is képviseli az összes lehetséges számok azt tanultuk az iskolában is létezik a világon. Egy számítógép, lényegében már válasszon egy részhalmaza a számok képviseletére pontosan. 

Most, a számítógép forduló talán egy kicsit, és lehetővé teszi, hogy durván bolt bármennyi lehet, esetleg akar. De csak ösztönösen, ha van egy véges számú bitet, akkor csak felcserélgette őket oly sok véges módon. Tehát akkor nem is véges számú A permutáció bitek, minták nullák, képviseletére végtelen számok száma, ami arra utal, hogy a számítógépek is nagyon jól lehet hazudik nekünk néha. 

Tény, hogy csináljuk. Hadd menjen vissza CS50 IDE. Hadd menjek előre, és hozzon létre egy kis program úgynevezett pontatlanság, azt mutatják, hogy számítógépek, sőt, pontatlan. 

És hadd menjen előre, és kezdje bizonyos, hogy a kód előtt, és most csak tegye a következőket. Hadd menjek előre, és nem printf, százalék f, backslash n, 1 osztva 10. Más szóval, leheljük mélyebb 1/10, mint az 1. és 10-zel osztani. Bizonyára, a számítógép lehet képviselni 10/01. 

Szóval menjünk előre, és a pontatlanság. Lássuk. Format meghatározza írja dupla. De az érv azonban int típusú. Mi történik? 

Ó, érdekes, így ez egy tanulsága előtt. Azt mondom, hé, számítógép mutat nekem egy úszó százalékos f. De én így ez 2 ints. Így kiderül, tudom javítani ezt egy pár módon. 

Tudtam csak kapcsolja be egy 1,0 és 10. a 10.0, ami valóban, azzal a hatással konvertáló őket floats-- még remélhetőleg ugyanazt a számot. Vagy kiderül, hogy van valami látni fogjuk ismét nemsokára. Lehet öntött a számokat. 

Akkor, ezt a közbevetett kifejezést, akkor lehet mondani, hé, számítógép, hogy ezt 10, ami tudom, hogy van egy int. De kezelje, kérjük, mintha ez egy úszó. De ez olyan, szükségtelenül bonyolult. 

A mi szempontunkból ma, nézzük csak a szó szoros értelmében Hogy azok lebegőpontos értékek tizedespont, mint ez. Hadd menjek előre, és futtassa újra, hogy pontatlanság, jó, pont perjel pontatlanság, adja meg. OK, keresünk jó. 

1 osztva 10, az én Mac itt is, sőt, 0,100000. Most azt tanították az iskolában van kell lennie, végtelen számú 0 években. Úgyhogy legalább próbáljuk hogy néhány ilyen. Kiderül, hogy a printf egy kicsit tenyésztő is, mint a korábban használt. Kiderült, hogy nem kell megadni Csak százalék f, vagy csak százalék i. Akkor valóban meghatározza bizonyos ellenőrzési lehetőség van. 

Pontosabban, megyek mondani, hé, printf, valóban azt mutatják, nekem 10 tizedes pont. Tehát úgy néz ki, egy kicsit furcsa. De azt mondja százalék, dot, hogy hány szám szeretné látni, miután a tizedespont és akkor f lapos, csak azért, mert ez az, amit a dokumentáció szerint. Hadd menjek előre, és mentse ezt. 

És észre is kapok Fáradt beírni a dolgokat. Tehát én csak beállítás a fel és le nyíl a kulcsokat itt. És ha folyton üti fel, akkor Láthatjuk az összes parancs hogy én, vagy helytelenül tette. 

És én megyek előre, és most valójában nem használja, hogy látszólag. Tedd pontatlanság, dot perjel imprecision-- így amit tanítottak, általános iskolában kijelentkezett. Még ha nyomtatni a 10 decimális helyezi, sőt, ez 0,10000. De tudod mit? 

Menjünk egy kicsit kapzsi. Mondjuk, mint, mutasd meg 55 pont után a tizedes. Nézzük tényleg ezt programozni egy körre. Hadd remake make pontatlanság, pont perjel, pontatlanság. 

És kész is van. A gyermekkori hazugság volt. Úgy látszik, 1 osztva 10 valóban 0.100000000000000005551115123-- 

Mi folyik itt? Nos, kiderült, ha a fajta néz elég messzire ki a mögöttes ábrázolása ez a szám, valójában nem pontosan 1/10 vagy 0,1 és végtelen számú nullát. Nos, miért van ez? 

Nos, bár ez egy egyszerű számot, emberekből 1 osztva 10, ez még mindig egy végtelen sok számokat tudtunk kitalálni. De egy számítógép csak képviseli véges sok olyan számokat. És így, hatékonyan, amit a számítógép mutatja nekünk van a legközelebb közelítés a szám akarunk hinni a 10/01, vagy tényleg 0,10000 végtelenségig. 

Inkább, bár ez olyan szoros, mint kap. És valóban, ha megnézi a motorháztető alatt, mint mi itt a keresett 55 tizedesjegy, valójában látni a valóságot. Most, hogy félre, ha már a valaha a movie-- a legtöbb akkor valószínűleg haven't-- de Superman 3 néhány évvel ezelőtt, Richard Pryor lényegében tőkeáttételes ezt valóság a cég ellopni egy csomó A frakciók és frakciói fillérekért, mert a company-- ha jól emlékszem, ez már egy while-- lényegében eldobja, ami nem illik fogalmára osztva cent. 

De ha összeadjuk ezeket apró, pici, apró számok ismét és újra, és újra, akkor, mint a az ő esetében, hogy egy jó adag pénzt. 

Ugyanez a gondolat volt, letépte Egy újabb, de még most idősebb film, az úgynevezett Office Space, ahol a srácok, hogy a film, ugyanezt tette, elszúrta teljesen, végül a túl sok pénzt a bankszámlájára. Ez volt minden, nagyon gyanús. De a végén a nap, pontatlanság körülöttünk. 

És ez is lehet ijesztően esetében. Kiderült, hogy Superman 3 és Office Space félre, ott lehet, hanem valóságos világ szálai A valóság a pontatlan ábrázolása adatok hogy még mi emberek, hogy Ezen a napon nem feltétlenül megérteni és ahogy kell, vagy emlékszik olyan gyakran, mint ahogy kellene. És valóban, a következő klip egy pillantást néhány nagyon is valós világ következményeit, hogy mi történik, ha nem értékelik a pontatlanság, hogy a történhet számok ábrázolása. 

[VIDEO LEJÁTSZÁS] 

-Computers, Mindannyian jönnek, hogy elfogadja A gyakran frusztráló problémák megy them-- hibák, vírusok, és szoftver hibák, kis árakat kell fizetnie a kényelem. De high-tech és a nagy sebességű katonai és űrprogram alkalmazások, A legkisebb hiba is nagyíthatók a katasztrófa. 

Június 4-én, 1996, a tudósok elő indítani egy pilóta nélküli Ariane 5 rakéta. Ez vitt tudományos műholdak tervezett megállapítani pontosan, hogy a Föld mágneses mezeje kölcsönhatásba lép A napszél. A rakéta épült az Európai Űrügynökség, és elemelkedik a létesítmény partján a Francia Guyana. 

-A Körülbelül 37 másodpercet A repülés, először észrevette, hogy valami baj van. A fúvókákat elfordítható a úgy, hogy azok tényleg nem kellene. Mintegy 40 másodperccel a repülés, Egyértelmű, hogy a jármű volt a baj. 

És ez mikor történt döntést, hogy elpusztítsa azt. A tartomány biztonsági tiszt, a óriási belek, megnyomta a gombot, felrobbant a rakéta, mielőtt tudott vált a veszély, hogy a közbiztonság. 

-Ez Volt a leány út az Ariane 5. És pusztítások elhelyezni, mert egy hiba beágyazva a rakéta program. -A Probléma az Ariane volt hogy volt egy szám, amely szükséges 64 bites kifejezni. És azt akarták átalakítani azt egy 16-bites számot. Azt feltételezték, hogy a szám soha nem fog hogy nagyon nagy, hogy a legtöbb ilyen számjegy egy 64 bites szám volt nullák. Tévedtek. 

-A Képtelenség egy szoftver, hogy elfogadja az a fajta által generált Egy másik volt a gyökere a hiba. Szoftverfejlesztés vált nagyon költséges része az új technológia. Az Ariane rakéta már nagyon sikeres, annyira a szoftver létre azt is használt Ariane 5. 

-Az Alapvető probléma az volt, hogy az Ariane 5 gyorsabb volt, felgyorsult gyorsabb. És a szoftver nem volt elszámolni, hogy. 

-A Megsemmisítése a rakéta volt egy hatalmas pénzügyi katasztrófa, minden miatt egy perc szoftver hiba. De nem ez volt az első időadatok konverziós problémák már sújtja a modern rakétatechnika. 

-A 1991-ben, a start Az első Öböl-háború, A Patriot rakéta tapasztalt hasonló jellegű A számkonverzió probléma. És ennek eredményeként, 28 ember, 28 amerikai katonák, öltek meg, és körülbelül 100 sebesült, amikor a Patriot, ami kellett volna, ellen védő bejövő Scuds, nem a tűz egy rakéta. 

-Ha Irak lerohanta Kuvait, és Amerikában indított Desert Storm 1991 elején, Patriot rakéták akkumulátorok vezényeltek védelme Szaúd-Arábia és Izrael az iraki Scud rakéta támadások. A Patriot egy amerikai közepes hatótávolságú föld-levegő rendszer, gyártott A Raytheon cég. 

-A Méret a Patriot elfogó maga körülbelül mintegy 20 láb hosszú. És a súlya körülbelül 2000 fontot. És ez hordozza a robbanófej kb, Azt hiszem, ez nagyjából 150 fontot. És a robbanófej maga nagy robbanó, amely van töredékek körül. A ház a robbanófej van célja, hogy úgy viselkednek, mint sörét. 

-A Rakéták hajtják Négy per konténer, és szállítják a félpótkocsit. 

-A Patriot rakétaelhárító rendszert nyúlik vissza, legalább 20 éve. Eredetileg tervezték mint egy légvédelmi rakéta lő le az ellenséges repülőgépek. Az első Öböl-háború, amikor a háború jött, a hadsereg akarta felhasználni arra, hogy lő le Scuds, nem repülőgépek. 

Az iraki légierő volt nem annyira a probléma. De a hadsereg aggódnak Scuds. És így igyekeztek frissíteni a Patriot. 

-Intercepting Egy ellenséges rakéta utazás Mach 5 volt, lesz elég ambiciózusak. De amikor a Patriot rohant helyezését, A hadsereg nem volt tudatában a Iraki módosítás, amely az azok Scuds szinte lehetetlen eltalálni. 

Mi történt a Scuds hogy jöttek be instabilak voltak. Őket imbolyog. Ennek oka az volt, Az irakiak, annak érdekében, hogy 600 km ki a 300 kilométeres hatótávolságú rakéta került súly ki az első robbanófej. Tették a robbanófej könnyebb. 

Tehát most a Patriot próbál, hogy a Scud. És a legtöbb időt, a túlnyomó többsége az idő, ez csak repül a Scud. Miután a Patriot-üzemeltetők rájött, hogy a Patriot tévesztett célt, úgy felrobbantotta a Patriot robbanófej hogy elkerülje az esetleges baleseteket, ha hagytuk leesik a földre. 

-Ez Volt az, amit a legtöbb ember látta, azokat a nagy tűzgolyó az égen, és félreértik, mint metszetét Scud robbanófejeket. 

-Bár Az éjszaka égbolt, Patriots megjelent hogy sikeresen pusztító Scuds, a Dhahran, nem lehetett tévedés sem a teljesítményt. Ott, a Patriot radarrendszer elveszett nyom a bejövő Scud, és soha nem indított kellő egy szoftver hiba. Ez volt az izraeliek, aki először fedezte hogy minél hosszabb a rendszer volt, annál nagyobb a időeltérés vált, mivel egy órát ágyazott A rendszer számítógépét. 

-közelítòleg Előtt két héttel A tragédia Dhahran, Az izraeliek jelentett A Honvédelmi Minisztérium hogy a rendszer időveszteség. Körülbelül nyolc órát, vagy futás, észrevették, hogy a rendszer vált észrevehetően kevésbé pontos. A Honvédelmi Minisztérium reagált mondja minden a Patriot akkumulátorok hogy ne hagyja el a rendszert a hosszú ideig. Soha nem mondta, amit sokáig was-- nyolc óra, 10 óra, 1000 óra. Senki sem tudta. 

-A Patriot akkumulátor állomásozott a laktanyában A Dhahran és hibás belső óra volt a több mint 100 óra én éjjel február 25. 

-Ez Lánctalpas idő pontossággal A mintegy egy tized másodperc. Most, egy tizedmásodperc egy érdekes szám, mert nem lehet kifejezni bináris pontosan, mely azt jelenti, hogy nem lehet kifejezni pontosan minden modern digitális számítógép. Nehéz elhinni. 

De használja ezt a példát. Nézzük száma egyharmadával. Egy harmadik nem lehet kifejezett tizedes pontosan. Egyharmada 0.333 folyik a végtelenbe. 

Nincs módja, hogy a abszolút pontossága a tizedes. Ez pontosan az a fajta probléma hogy történt a Patriot. Minél hosszabb a rendszer futott, a rosszabb az idő hiba lett. 

-Miután 100 üzemóra, az Hiba az időben még csak mintegy egyharmada a második. De tekintve a célba rakéta utazás Mach 5, azt eredményezte, hogy a nyomkövető hiba több mint 600 méter. Lenne egy végzetes hiba a katonáknak, hogy mit történt egy Scud dob volt által észlelt korai figyelmeztető műholdak és tudták, hogy a Scud volt jön az általános irányt. Nem tudták, hol jön. 

-Ez Most már csak a radar eleme a Patriot rendszer védekező Dhahran hogy keresse meg és tartsa track a bejövő ellenséges rakétát. 

-A Radar nagyon okos. Ez valóban követni a helyzet a Scud, majd megjósolni, ahol valószínűleg lesz a következő alkalommal, amikor a radar küldött egy impulzus ki. Ez volt az úgynevezett egy sor kapu. 

-Akkor, Ha a Patriot úgy dönt, elég időt telt, hogy menjen vissza és ellenőrizze a következő hely erre észlelt objektum, megy vissza. Tehát, ha visszament a rossz helyre, majd nem látja objektumot. És úgy dönt, hogy nem volt tárgy, ez egy hamis felderítése, és eldobja a pályán. 

-A Beérkező Scud eltűnt a radar képernyőjén. És másodperccel később csapódott a laktanyába. A Scud megölte 28, és ez volt az utolsó egy égetett az első Öböl-háború. 

Tragikus, a frissített szoftver megérkezett Dhahran a következő napon. A szoftver hiba volt javítva, záró Egy fejezet a problémás története a Patriot rakéta. 

[VIDEO LEJÁTSZÁS] David J. MALAN: Tehát ez az egész, hogy azt mondják, hogy ezek a kérdések a túlfolyó és pontatlanság túlságosan is valóságos. Tehát hogyan jutottunk el idáig? Kezdtük csak beszélünk printf. Ismét ezt a funkciót, hogy kiírja valamit a képernyőn, és bevezettük azt követően néhány egyéb funkciók Az úgynevezett CS50 könyvtárában. És mi továbbra is ezeket a megfelelő időben. És mi, különösen, használt get húr, és kap int, és most is kap úszó, megint mások még mindig találkozunk és használja magunkat nemsokára. 

Esetenként azonban a már már látja szükségesnek, tárolni, amit azok a funkciók, kéz vissza? Ők adják vissza minket egy string, vagy egy int, vagy float. És néha meg kell tenni, hogy a húr, vagy int, vagy float, valahol. 

És tárolja azokat a dolgokat, emlékszem csak mint Scratch, van változó. De ellentétben a Scratch, C van tényleges típusai A variables-- adatok típusú, több generally-- köztük egy string, int, a lebegnek, és ezek a mások még. 

És amikor kijelentjük változókat C, kénytelenek leszünk kinyilvánítjuk adattípusok. Ez nem valami fogunk kell tennie, később a félévben ahogy átmenet más nyelveken. De most van szükségünk a priori előre, megmagyarázni, hogy a számítógép milyen típusú A változó azt akarjuk, hogy nekünk. 

Most, eközben nyomtatni azok adattípusok, el kell mondanunk printf, mire számíthat. És láttuk százalék s vonósokra, és a százalékos i egész számok, és még néhány más már. És ezek csak a követelmények A vizuális megjelenítés ezt az információt. 

És ezek mindegyikét is lehet parametrizálhatók vagy csípett valamilyen módon, Ha azt szeretnénk, hogy további ellenőrzési a kimenet típusától, amit kap. És, sőt, kiderül, hogy nem csak a van backslash n egy új sort. Van még valami úgynevezett fordított perjel r kocsi vissza, amely ez inkább egy régi iskola írógép, valamint a Windows több éve alkalmazzák. 

Van backslash t fülek. Kiderült, hogy ha azt akarjuk, hogy idézőjel belsejében egy húr, emlékeztet arra, hogy már használt idézőjel kettős idézet a bal és a jobb végződik a mi húrok eddig. Hogy úgy tűnik, hogy megzavarja a dolgokat. 

Ha azt szeretnénk, hogy egy dupla idézet a közepén egy string-- és valóban, ez zavaró, hogy látni. És ezért van, hogy elkerülje, hogy úgy beszél, egy idézőjel valami mint, a szó szoros értelmében, backslash idézőjel. És van néhány más is. És mi többet látni ezeket a a tényleges felhasználás előtt hosszú. 

Úgyhogy most átmenet adatokat, és a képviseletet, és aritmetikai operátorok, mind amelyek adott nekünk néhány épület blokkok, amellyel játszani. De most nézzük valóban ad minket a többi szókincs hogy már volt múlt héten Scratch azáltal, hogy egy pillantást néhány más konstrukciókat C-- nem mindet. De az ötletek vagyunk hamarosan látni tényleg csak hangsúlyozni a fordítást Egy nyelv, Scratch, egy másik, C. 

És idővel, akkor vegye fel További eszközök számára eszközkészlet hogy úgy mondjam, szintaktikailag. És valóban, látni fogja, hogy az ötleteket Most mégis ismerős a múlt héten. Tehát lássuk ezt. 

Menjünk előre, és felkap egy programot hogy valóban használ néhány kifejezést, a logikai kifejezés. Hadd menjen előre ide és hozzon létre egy új fájlt. Hívom ezt condition.c. 

Hadd menjek előre, és tartalmazza a CS50 könyvtár. És hadd menjen előre, és tartalmaznia szabvány IO.h számára funkciók, és a printf, és több volt. Hadd adjak magamnak, hogy boilerplate a int main void, melynek tisztázására fogunk jönnek vissza a jövőben. 

Most hadd menjen előre, és ad magam egy int keresztül get int. Akkor hadd menjen előre, és erre a célra. Azt akarom mondani, ha az i less-- nézzük megkülönböztetni a pozitív, negatív, vagy nulla értéket. 

Tehát ha én kevesebb, mint nulla, hadd Csak ki ez a program egyszerűen azt mondják, negatív, backslash n, máshol ha nagyobb, mint nulla. Most, persze, azt fogja mondani printf pozitív, backslash n. És akkor még if-- tehettem ezt. 

Tehettem, ha i értéke 0. De azt is, hogy a Legalább egy hiba már. Emlékezzünk, hogy az egyenlőségjel van nem egyenlő, mint mi, emberek is tudják. 

De ez az értékadó operátor. És nem akarom, hogy a 0-ta jobbra és betette i a bal oldalon. Így elkerülhető ez zavar, vagy talán visszaélés egyenlőségjel, emberek úgy döntött, néhány évvel ezelőtt hogy sok programozási nyelvek ha azt szeretné, hogy ellenőrizze az egyenlőség a bal és a jobb oldalon, jelenleg használt egyenlő az egyenlők. Tehát bejön egyenlőségjel kétszer. Ha szeretne hozzárendelni jobbról balra, akkor használja egy egyenlőségjel. Így lehet tenni this-- mást ha i értéke zérus. 

Én aztán megy, és Kinyitom a kapcsos zárójelek és azt mondják, printf 0, backslash n, kész. De ne feledjük, hogy ezek a villa az úton tud dolgozni. És tényleg, gondoljunk csak a logika. i egy számot. Ez egy egész, konkrétan. És ez azt jelenti, hogy lesz kevesebb mint 0, vagy nagyobb, mint 0, vagy 0. Tehát van egyfajta ezt hallgatólagos alapértelmezett esetben. 

És így tudtuk, csakúgy, mint Scratch, eltekinthet a else if, és csak azt mondják mást. Logikus, ha a programozó tudja, ott csak három vödör, amelybe egy szcenárió fall-- az első, a második, vagy a harmadik ebben case-- nem zavarja hozzáadjuk a további pontossági és a kiegészítő logika ott. Csak megy előre a Alapesetben itt a mást. 

Most menjünk előre mentése után, hogy feltételek dot perjel conditions-- nem egy nagy felhasználói felület, mert nem kéri a felhasználó, ahogy korábban említettem. De ez rendben van. Majd tartsa egyszerű. Próbáljuk a szám 42. És ez pozitív. Próbáljuk száma negatív 42, negatív. 

Próbáljuk a 0 értéket. És valóban, ez működik. Most látni fogsz a problémákat, mielőtt Hosszú, tesztelés dolog háromszor, valószínűleg nem elegendő. Talán szeretnénk kipróbálni néhány nagyobb számban, néhány kisebb számok, néhány sarok esetekben, fogunk jönni, hogy leírja őket. 

De most, ez egy nagyon egyszerű programot. És biztos vagyok benne, logikusan, hogy beleesik három esetben. És valóban, bár mi csak összpontosított potenciális hátrányai a pontatlansággal és túlfolyó, a valóság, ahol sok CS50 problémáit, nem fogunk aggódni körülbelül, minden alkalommal, ezeket a kérdéseket a túlcsordulás és pontatlanság, mert, sőt, a C, ez valójában egyáltalán nem olyan könnyű elkerülni ezeket a dolgokat. Ha azt szeretnénk, hogy számít fel nagyobb, és nagyobb, és nagyobb, Kiderült vannak technikák használhatják, gyakran olyan dolgokat az úgynevezett könyvtárak, gyűjtemények kódot, hogy mások azt írta, hogy tudod használni, és más nyelvek, mint a Java és mások, valójában hogy sokkal könnyebb számolni még magasabb. Így tényleg néhány ilyen veszélyeket függvényében a használt nyelvtől. És az elkövetkező hetekben lásd, milyen veszélyes C igazán lehet, ha nem megfelelően használják. De onnan, és Python, és a JavaScript, akkor mi réteg néhány további védelmet, és fuss kevesebb ezeknek a kockázatoknak. 

Tehát lássuk, hogy egy kicsit több Érdekes logikai programunk. Tehát hadd menjen előre, és hozzon létre nevű program logikai Csak így tudok játszani néhány tényleges logika, logical.c. Majd csak illessze be néhány kódot korábban ezért kapok vissza hogy ezt a szép kiindulópontja. 

Hadd most nem char C. vagyok majd adja meg a nevét a C csak azért, mert a hagyományos, kap egy karaktert a felhasználótól. És legyen úgy, mintha Én megvalósítjuk E Rm program az eltávolítási programot, mielőtt hogy kéri a felhasználó eltávolítani a fájlt. Hogy mi ez? 

Azt akarom mondani, ha a C egyenlő egyenlő, idézet idézőjel bezárva, y, akkor megyek, hogy vállalja hogy a felhasználó által választott igen. Csak megyek nyomtatni igen. Ha ez valóban az írás Az eltávolító program, tudtuk eltávolítani a fájlt több sornyi kódot. De majd, hogy ez egyszerű. 

Else if c értéke egyenlő n-- és most itt fogok mondani, A felhasználó kötelessége, hogy nem mentek. És akkor még, tudod mit? Nem tudom, mi mást a felhasználó fog írja. Tehát én csak azt fogja mondani, hogy a hogy egy hiba, bármi ő valójában gépelt. 

Tehát, mi folyik itt? Van egy alapvető különbség versus mit tettem a múltban. Dupla idézőjelek, idézőjelek, dupla idézetek, és még egyetlen idézetek, aposztrófot. Kiderült C, hogy amikor Szeretné, hogy írjon egy szöveget, Ön nem használja idézőjelek, ahogy mi már használ minden ezúttal printf. 

De ha azt akarjuk, hogy foglalkozni csak egy egyetlen karakter, egy úgynevezett char, akkor valójában egyszerű idézőjeleket. Azok, akik már programozott előtt, lehet, hogy nem kellett aggódni ezt megkülönböztetés bizonyos nyelveken. A C-ben, ez nem számít. És így, ha kapok egy char és szeretnék összehasonlítani, hogy char segítségével egyenlők megegyezik néhány levelet, mint y, vagy n, én, Valóban, szükség van az egységes idézetek. 

Most menjünk előre, és erre a célra. Menjünk előre, és nem teszik logikai dot perjel logikus. És most én is kéri. Tehát feltehetően a jobb felhasználói élmény valójában mondani, mit kell csinálni itt. De megyek vakon mondjuk y igen, OK, szép. 

Fussunk újra, n nélkül, szép. Tegyük fel, mint egyes ember, akit ismerek, én caps lock be van kapcsolva túl gyakran. Úgyhogy nem tőke Y, adja meg, hiba. OK, ez nem pontosan mit várok. Valóban, a számítógép csinál szó, amit Mondtam, hogy ellenőrizze a do-- kisbetűs y és kisbetűs n. Ez nem érzem jó felhasználói élmény, mégis. Hadd kérdezzem meg és fogadja el vagy kisbetű vagy nagybetű. Így kiderül, érdemes mondani valamit, mint a Scratch, mint a szó szoros értelmében, vagy a C értéke egyenlő tőke egyetlen idézett y. Kiderült, C nem ez a szó kulcsszó vagy. 

De ez van két függőleges rúd. Meg kell tartani a Shift általában, ha használ a US billentyűzet, és nyomja meg a függőleges vonal kulcs felett a vissza gomb. De ez a függőleges vonal függőleges vonal azt jelenti, vagy. 

Ha, ezzel ellentétben, meg akartuk mondani, és mint a Scratch, tudnánk csinálni jelet jelet. Ennek semmi értelme logikai itt, mivel egy emberi nem lehetett gépelt Y és kisbetűs y és a tőke Y ugyanazt a karaktert. Tehát vagy mit szándékozunk itt. 

Tehát, ha én ezt mindkét helyen, vagy c egyenlő tel egyenlõ N betűvel most ismételni, teszik logikai, futtassa logikus. Most azt írja y. És tudom csinálni újra tőke Y vagy N betűvel És azt is hozzá további kombinációk is. 

Tehát ez egy logikus programot, mivel most Én ellenőrzése logikusan ezt az értéket vagy ezt az értéket. És nem kell feltétlenül, felér két IFS IFS különben. Azt valóban kombinálni néhány kapcsolatos logika együtt ezen a módon. Ez lenne tehát a jobb Ajánlott, mint egyszerűen mondván, ha a C egyenlő kisbetűs y, print igen, még ha c egyenlő tőke Y, print igen, még ha c értéke lower-- más szóval, akkor nem kell, hogy legyen egyre több és több ága. Akkor össze néhány egyenértékű ágak logikailag, mint ezen a módon. 

Szóval vessünk egy pillantást csak egy utolsó hozzávaló, egy végső konstrukció, hogy a C lehetővé. És mi jön vissza a jövőben másoknak is. És akkor majd befejezésül keres A nem a helyességét code-- kapok kódot work-- de a design kódot, és növényi azok a magok korán. 

Tehát hadd menjen előre, és nyit egy új fájlt itt. Tudod mit? Megyek újra végrehajtani hogy ugyanaz a program, de egy másik konstrukciót. 

Tehát hadd gyorsan, hogy magam hozzáférés közé CS50.h A CS50 könyvtár, szabvány Io.h a printf. Adj nekem int main semmis. Majd ide, hadd menjek előre, és erre a célra. 

Char c kap kap char, mint azelőtt. És megyek, hogy egy új konstrukció now-- váltani, milyen jellegű? Tehát kapcsoló olyan, mint váltás a síneken. Vagy tényleg, ez a fajta Egy ha más, ha más, ha de írt némileg eltérő. 

A kapcsoló úgy néz ki, mint ez. Van kapcsolót, akkor mi karakter vagy szám szeretne nézni, majd néhány kapcsos zárójelek úgy, mint a Scratch, csak annyit, hogy ezt a cuccot. És akkor már a különböző esetekben. 

Nem használja, és ha mást. Szó szerint használja a szót ügyben. És akkor azt mondják, valami ilyesmit. 

Tehát abban az esetben egy kisbetűs y, vagy abban az esetben, egy tőke Y, megy előre, és nyomtassa ki igen. Aztán kitör a kapcsolót. Ez az. Végeztünk. 

Else if, hogy úgy mondjam, kisbetűs n vagy N betűvel akkor megy előre, és a nyomtatási ki nem, és majd a szünet. Else-- és ez a fajta van a Alapesetben indeed-- printf error-- és csak a jó intézkedés, bár logikusan ez a szünet nem szükséges mert mi vagyunk a végén A kapcsoló egyébként, Én most tört ki a kapcsolót. Tehát ez úgy néz ki, egy kicsit más. 

De logikusan, ez valójában egyenértékű. És miért használ az egyik vagy a másik? Néha, csak személyes preferencia, Néha az esztétika, ha pillantok ezt Most, hogy van valami ki kell mondani a olvashatósága kódot. Úgy értem, nem is beszélve, hogy ez a kód új sokan a szobában. 

De ez csak egyfajta elég. Látod kisbetűs y, a tőke Y, kisbetűs n, N betűvel alapértelmezés ez csak egyfajta ugrik ki téged oly módon hogy vitathatatlanul, talán Az előző példában a az IFS és a függőleges vonalakkal, és a más IFS, lehet, hogy nem. Tehát ez tényleg egy kérdés a személyes választás, tényleg, vagy az olvashatóság, A kód. 

De a funkcionalitás, hadd megy előre, és egy kapcsolót, pont perjel kapcsoló, és most írja kisbetűvel y, tőke Y, kisbetűs n, N betűvel David, újra, mert ez Nem egy karaktert. Csináljuk x, hiba, mint az várható volt. És logically-- és ez olyasvalami, Azt javasoljuk a general-- még bár mi csak vakarja a felülete ezek közül néhány. 

És talán nem is nyilvánvaló, ha magad ül le a billentyűzetet, hogy működik ez? Mi lenne ez csinálni? A gyönyörű dolog, amelynek egy laptop, vagy asztali, vagy a hozzáférési hogy a számítógépet egy fordító, és egy kód szerkesztő, mint ez, van akkor szinte mindig válaszolni ezekre a kérdések magad csak azzal, hogy megpróbálja. 

Például, ha a retorikai kérdés kéznél voltak, mi történik, ha elfelejtjük A szünet állításokkal? Amely tulajdonképpen egy nagyon gyakori dolog, mert nem úgy néz ki mintha tényleg szükség van rájuk. Nem igazán teljes a gondoltam, mint egy zárójel, vagy göndör zárójel nem. Menjünk előre, és újrafordítani a kódot, és látni. Tehát csinál kapcsoló, pont perjel kapcsolót. Nézzük írja kisbetűvel y, a felső helyzet, Enter. Szóval gépelt y. 

A program azt mondta, igen, nem, hiba, mintha azt megváltoztatása előtt tartva. De ez a fajta volt, mert mi egy kapcsolóval az első eset, hogy a mérkőzés lényegében azt jelenti, hé számítógép, végrehajtja az összes kódot alatta. És ha nem mondom szünet, vagy nem mondom szünet, vagy nem mondják szünet, A számítógép fog robbantani az összes ilyen vonal és végrehajtja azokat, amíg ez lesz, hogy zárójel. Tehát a fékek, sőt szükséges. De egy elvihető itt, amikor Kétség, próbálj ki valami. Lehet menteni a kódot az első, vagy elmentheti egy külön fájlban ha igazán aggódik Messiás és miután vissza A munka, amit tudja, hogy működik. 

De próbálja meg a dolgokat. És ne legyen olyan fél, talán, amit a számítógép lehet csinálni, vagy hogy lehet törni valamit. Bármikor visszatér néhány korábbi verzióját. 

Úgyhogy a végén által keresett a tervezési kód. Van ez a képesség most írni, feltételeket, és írási hurkok, és a változók, és hívási funkciók. Tehát, őszintén, mi a fajta vissza ahol voltunk egy héttel ezelőtt a semmiből, bár a kevésbé kényszerítő szöveges környezetre, mint a Scratch lehetővé. 

De vegyük észre, hogy gyorsan általunk megszerzett hogy a szókincs, akkor is, ha fog tartani egy darabig, hogy elsüllyed, így, hogy most már használja ezt a szókincs hogy írjon több érdekes program. És vessünk egy apró lépés felé, hogy a következők szerint. Hadd menjek előre, és hozzon létre egy új fájlt itt. 

Megyek hívják ezt prototype.c, és vezessen be az első alkalommal, a képesség, hogy a saját funkcióit. Néhányan lehet, hogy tette ezt a Scratch, amellyel akkor létrehozhatunk saját egyéni blokkok Scratch, majd húzza őket a helyére bárhol szeretne C. És a legtöbb programozási nyelven, amit tehetünk, hogy pontosan hogy-- hogy a saját funkcióit, ha azok nem léteznek. 

Így például, hadd menjen előre és tartalmazzák CS50.h, és tartalmazza szabvány IO.h, int main semmis. És most van egy helykitöltő kész. Folyton nyomtatás dolgokat mint emberek nevét ma. És, hogy úgy érzi, így: nem lenne jó, ha ott voltak olyan függvény nyomtatási név? Nem kell használni printf. Nem kell emlékezni minden formátum kódok. Miért nem én, vagy miért nem valaki előttem, hozzon létre egy függvényt nevű nyomtatási nevét, hogy mivel néhány nevet, egyszerűen kiírja ki? 

Más szóval, ha azt mondom, hé, számítógép, adj egy húr kérve a felhasználót az ilyen, via CS50 Szerezzünk sztring függvény. Hé, számítógép, tedd azt string a változót a bal oldali, és hívja meg s. És akkor, hé számítógép, megy előre és kinyomtatni az adott személy neve, kész. 

Most jó lenne, mert ez a program, találóan elnevezett, azt mondja, hogy mit is kellene csinálni útján azok függvény nevét. Hadd menjen, és prototípus, Enter. És, sajnos, ez nem fog repülni. 

Prototype.c, 7. sor, karakter 5. hiba implicit nyilatkozat A függvény nyomtatási név érvénytelen C99, C99 vagyis egy változata a C hogy jött ki 1999-ben. Ez minden. 

Szóval nem tudom, mi Mindez azt jelenti, még. De én elismerik hiba piros. Ez elég nyilvánvaló. 

És úgy tűnik, hogy a A zöld karakter van, A kérdés az, hogy a nyomtatandó nevet és nyitott zárójel s, közel zárójel, pontosvessző. De implicit nyilatkozat funkció láttunk röviden korábban. Ez azt jelenti, egyszerűen, hogy Clang nem tudja, hogy mire gondolok. 

Már használt szókincs szó, hogy ez az soha nem látott vagy tanították előtt. És így kell tanítani hogy ez a függvény jelent. Így fogok menni előre, és csinálni. 

Megyek, hogy menjen előre és végrehajtása Saját nevezett funkció Print neve. És fogok mondani, az alábbiak szerint, hogy teszi ezt, printf, hello, százalék s, backslash n, név, pontosvessző. Tehát mi csak én nem? 

Így kiderül, hogy végre a saját funkciója, azt a fajta kölcsön néhány ugyanazt a szerkezetet, mint fő hogy most voltunk magától értetődő, és én tudom, másolás és beillesztés nagyjából mi Már írt a múltban. De észre a minta itt. Int, Main, Void fogunk ugratni egymástól nemsokára, hogy ez mit is jelent valójában. 

De ma, csak észre a párhuzamot. Void, nyomtatott nevét, karakterlánc nevét, így van lila kulcsszó, amely fogunk kezdeni hívás visszatérési típus, a neve a funkciót, majd a bemenet. Tehát, valójában mi is csöpögtet ez olyan, mint a múlt héten mivel ez a név vagy a algoritmus a kód vagyunk fog write-- a algoritmus alapjául szolgáló A kód fogunk írni. 

Ez a bemenet. Ez a kimenet. Ez a funkció, nyomtatott név, célja, hogy egy húr nevű nevet, vagy bármi, a bemenet, majd semmis. Nem ad vissza semmit, mint kap húr, vagy kap int csinál. Így fog átadni nekem valamit. Ez csak megy, hogy egy mellékhatása, hogy úgy mondjam, A nyomtatás egy személy neve. Így észre, 7. sor, I hívhatjuk nyomtatási nevét. 10. sor, tudom meghatározni vagy végrehajtja a nyomtatási nevét. De, sajnos, ez nem elég. 

Hadd menjek előre, és újrafordítani ezt a mentés után. Hú, most csináltam meg rosszabb, úgy tűnik. Így implicit nyilatkozat függvény nyomtatási érvénytelen. És újra, van még hibák. De ahogy figyelmeztetett korábban, még ha kap túlterheltek, vagy egy kicsit szomorú, hogy ennyi hibák, a hangsúly csak az első kezdetben, mert lehet, hogy csak volt egy lépcsőzetes hatás. Tehát a C, vagy Clang pontosabban még mindig nem ismeri a nyomtatási nevét. 

És ez azért van, mert csenget, tervezési, egyfajta néma. Ez csak azt teszi, amit mondani, hogy igen. És ám mindezt csak abban a sorrendben amelyben azt mondja, hogy nem. 

Úgyhogy meghatározott fő vonal négy, mint mi csináltuk, elég gyakran. Már megadott nyomtatási név on line 10. De próbálom használni print név vonalon hét. 

Ez túl korán, még nem létezik. Így tudtam, hogy okos, és mint a OK, úgyhogy csak játszanak együtt, és mozgassa a nyomtatási nevét fel itt, és újra összeállítja. Istenem. Működött. Ez ennyire egyszerű. 

De a logika, hogy pontosan. Meg kell tanítani csenget, amit van meghatározva a függvény először. Akkor tudja használni. De őszintén szólva, ez olyan, mint egy csúszós lejtőn. 

Így minden alkalommal futok egy probléma, én csak megy, hogy kiemelje és másolja be a kódot Írtam, vágott és illessze ide. És bizonyára tudnánk feltalál egyes forgatókönyvek ahol egy funkció esetleg kell hívni a másik. És ha csak nem tesz minden funkció felett, minden más. 

Így kiderül, ott a egy jobb megoldást. Mi lehet hagyni ezt lehet. És, őszintén szólva, ez általában jó, és kényelmes, és a jó design hogy fő az első, mert megint Fő mint amikor a zöld zászló kattintott, ez a funkció, kerül végrehajtásra, alapértelmezés szerint. Így akár meg is tesz ez a tetején a fájl így amikor vagy bármely egyéb humán nézi a fájlt tudja, mi folyik csak, ha elolvassa fő először. Így kiderül, meg tudjuk mondani csenget proaktív, hé, csenget, on-line négy, Ígérem, hogy végre olyan függvény nyomtatása Név, hogy vesz egy húr names a bemenet, és visszatér semmit, semmis. És hozok körül végrehajtási később. 

Itt jön Main. Fő most a 9. sorban használhatja Nyomtatás Név mert csenget bízik, hogy végül, ez a találkozás a meghatározás végrehajtásának Print neve. Tehát miután megmentette az fájlunk, menjek előre, és prototípus, jól néz ki ebben az időben. Dot perjel, prototípus, hadd megy előre, és írja be a nevét. David, szia Dávid Zamila, szia Zamila, és valóban, most már működik. 

Tehát az összetevő az, hogy mi már tett egy egyedi funkció, például az egyéni Scratch blokk vagyunk nevezni. De ellentétben Scratch, ahol lehet Csak akkor hozza létre, és már használhatja is, most már, hogy egy kicsit pedáns, és valóban a vonat csenget használni, vagy elvárni. Most, hogy félre, miért ennyi idő van mi volt, csak vakon hit beleértve CS50.h, és beleértve a standard IO.h? 

Nos, kiderült, között egy pár más dolog, minden, ami azokban a dot h kép, ami történetesen a fájlokat. Ők header fájlokat, hogy úgy mondjam. Még mindig a C nyelven írt, de ők egy másik típusú fájlt. 

Egyelőre akkor nagyjából vállal hogy minden, ami a belsejében CS50.h néhány egysoros, mint ez, nem A funkció az úgynevezett Print neve, de Get String, Get Float, és még néhány más. És vannak hasonló prototípusok, Egy hüvelyek, belső standard IO.h A printf, amely most Saját neve nyomtatott funkciót. Más szóval, ez az egész eset, amikor most vakon másolás és beillesztés tartalmazza ezt, többek között hogy mi folyik itt? Ezek csak ilyen nyomokat a csengés, hogy milyen funkciók vannak, sőt, végre, csak másutt különböző fájlokat máshol a rendszerben. 

Így már végre a nyomtatási nevét. Teszi ezt mellékhatása nyomtatás valamit a képernyőn. De ez valójában nem adja ide valamit. Hogyan érjük el program végrehajtása, amely nem adja ide valamit? 

Nos, próbáljuk meg. Hadd menjek előre, és végrehajtja nevű fájlt return.c így tudjuk bizonyítani, hogy valami mint Get String, vagy a Get Int, tulajdonképpen visszatérés valamit vissza a felhasználónak. Menjünk előre, és meghatározzák int main semmis. 

És ismét, a jövőben fogunk magyaráznia, hogy int és ezt az űrt valójában csinál. De ma, fogunk biztosra veszik. Megyek, hogy menjen előre és printf, Egy jó felhasználói élményt, x. És akkor fogok várni a felhasználót, hogy adjon nekem x get int. 

Aztán megyek előre és nyomtassa ki x a térre. Tehát, ha csak egy billentyűzet, az emberek általában használja a kis sárgarépa szimbólum a billentyűzeten hogy képviselje a teljesítmény , vagy a kitevő. Tehát x négyzeten van jelen i. 

És most fogom ezt tenni. Tudtam csak do-- mi x négyzeten? x négyzet x-szer x. 

És mi ez a néhány ideje már ma. Ez nem érzem hogy sok minden haladás. Tudod mit? Nézzük tőkeáttétel bizonyos, hogy a gondolat az utolsó alkalom az absztrakció. 

Nem lenne jó, ha van olyan függvény négyzet, hogy pontosan ezt teszi? Még mindig, a végén az nap, nem ugyanaz a matematika. De nézzük absztrakt el az ötlet, hogy Egy szám szorozva Egy másik, és csak adja meg a nevét, kockás ezt az értéket. 

És, más szóval, C, hozzunk létre egy függvény az úgynevezett tér, hogy pontosan ezt teszi. Ez lesz a címe téren. Ez fog tartani egy int. És mi lesz most hívják n alapértelmezés szerint. 

De nevezhetjük, amit csak akarunk. És minden, ami meg fog igen, szó szerint, a megtérülés az eredmény a N-szer N. De mivel ez visszatérő valamit, ami az a kulcsszó, lila voltunk soha nem látott, én, a 11. sor, Nem lehet csak mondani void ebben az időben. 

Void, a példában láttunk inkább a nyomtatott nevét, csak azt jelenti, csinálj valamit. De ne adja nekem valamit vissza. Ebben az esetben én szeretnék hogy visszatérjen n-szer n, vagy bármi legyen is az, hogy a szám. 

Így nem tudok mondani, hé, számítógép, Azt vissza semmit, semmis. Meg fog visszatérni, a természet, az int. És így, hogy minden, ami folyik itt. 

A bemeneti tér lesz egy int. És, hogy ki tudjuk használni, akkor azt Van egy név, N. Ez lesz a kimeneti int, hogy nem kell a nevét. Mi lehet hagyni a fő, vagy bárki is használja, hogy emlékezzen ezt az értéket, ha szeretnénk a saját változó. 

És újra, az egyetlen új kulcsszó itt a Return. És én csak csinál valami matek. Ha nagyon akartam, hogy felesleges, Mondhatnám int terméket kapja n-szer n. 

És akkor azt is mondhatnám, vissza terméket. De megint az a lényeg korábbi ez csak nem, hogy a jó design-- mint, hogy miért vezetnek be egy nevet, egy szimbólum, mint a termék, csak azért, hogy azonnal vissza? Ez egy kicsit tisztább, egy kicsit feszesebb, így beszélni, csak azt mondani, visszatérő n-szer n, hogy megszabaduljon ez a vonal teljesen. 

És ez csak kisebb kódot olvasni, kevesebb lehetőséget hibákat. És lássuk, hogy ez a tényleg működik. Most fogok menni előre, és a visszatérést. 

Ajjaj, implicit nyilatkozatot funkciót. Csináltam ezt a hibát korábban, nem nagy ügy. Hadd írja, vagy jelölje ki, és másolni, pontosan ugyanazt a függvény prototípus, vagy aláírás, a függvény itt. Vagy tudtam mozgatni az egész funkciót. 

De ez egy kicsit lusta. Így nem fogunk csinálni. Most, engedjék meg, hogy cserébe újra, pont perjel vissza. 

x 2 x négyzeten 4. x 3 x négyzeten 9. És a funkció úgy tűnik, Most, hogy működik. Tehát mi itt a különbség? Van olyan funkció, amely az úgynevezett tér, Ebben az esetben, amely tettem egy bemenet. És kapok vissza egy kimenetet. És mégis, a korábban, ha Kinyitom a másik példa a korábbi, ami hívták prototype.c, Volt nyomtatott neve, amely visszatért void, hogy úgy mondjam, Vagy vissza semmit, és egyszerűen csak mellékhatás. 

Tehát, mi folyik itt? Nos, úgy a függvény A string egy pillanatra. Mi már nem, a függvény A string a következő módon. 

Már volt egy funkciót kap húr, mint többek között CS50.h, közé tartoznak a standard IO.h, int, fő, semmis. Ezután minden alkalommal, én már úgynevezett get húr eddig, Már valami olyasmit mondott, s karakterlánc kap kap húr, mert get string-- Nevezzük ezt get.c-- get húr Maga visszaadott karakterlánc tudok majd használja, és azt mondják, hello, vessző, százalék s, backslash N, S. 

Tehát ez ugyanaz a példa, igazán, hogy mi volt korábban. Tehát kap karakterláncot ad vissza értéket. De egy pillanattal ezelőtt, nyomtatás húr nem ad vissza értéket. Ez egyszerűen egy mellékhatás. Tehát ez egy alapvető különbség. Láttuk különböző típusú függvények, amelyek közül néhány vissza értékek, amelyek közül néhány nem. Tehát lehet, hogy húr, vagy int, vagy float. Vagy lehet, hogy csak érvénytelen. 

És a különbség hogy ezek a funkciók, hogy kap adatokat, és visszatérési értéke valóban hogy valamit vissza az asztalhoz, hogy úgy mondjam. Szóval menjünk előre, és nézd meg egy utolsó szett A példa, hogy ad egyfajta, most, a hogyan lehet, sőt, absztrakt jobb, és jobb, és jobb, vagy több, és több, és több, annak érdekében, írni, végső soron jobb kódot. Menjünk előre, és a lélek A Scratch, tegye a következőket. 

Hadd menjek előre, és tartalmaznia CS50.h standard IO.h. Hadd menjek előre, és ad magam egy int, fő, semmis. És hadd menjen előre, hívja ezt cough.c. 

És hadd menjen előre, és csak mint Scratch, nyomtassa ki köhögés / n. És azt akarom, hogy ezt háromszor. Úgyhogy, persze, csak megy másolás és beillesztés háromszor. Én most megy, hogy köhögés dot perjel köhögés. Adjunk magam egy kicsit több szoba itt, az Enter, köhögés, köhögés, köhögés. 

Van, nyilván, már egy lehetőséget a fejlődésre. Már a vágólapra másolni egy párszor ma. De ez csak így nem tettem van, hogy írja annyi karaktert. Még mindig változik, hogy mit azok sornyi kódot. 

Ez a három vonal azonos, amely úgy érzi, lusta és tényleg olyan, és valószínűleg nem a helyes megközelítés. Tehát mi összetevő tudnánk javítani ezt a kódot? Nem kell másolni és beilleszteni kódot. 

És valóban, minden alkalommal, amikor úgy érzi, magad a másolás és beillesztés, és nem is változik kódot, esély van egy jobb út. És valóban, van. Hadd menjek előre, és nem egy ciklusban, bár a szintaxis, talán nem természetesen jön még. 

Ezt háromszor, egyszerűen ezzel a following-- és én történetesen tudjuk ezt a gyakorlatot. De van számos példa van. És meglátja az interneten további referenciák is. 

Ez a szintaxis a 6. sorban, hogy hasonlóan Scratch, hogy ismétli blokk, ismételje meg a következő három alkalommal. Ez egy kis mágikus most. De ez még több, és jobban ismerik. 

És ez meg fog ismételni vonal nyolc három alkalommal, így ha újra összeállítja make köhögés, dot perjel köhögés, köhögés, köhögés, köhögés. Még mindig ugyanúgy működik. Szóval ez mind szép és jó. De ez nem nagyon szórakozott. 

Ez teljesen korrekt. De úgy érzi, mintha ott lehetőséget jelenthet, mint a világ Scratch, hogy milyen kezdő hogy adjunk néhány szemantika itt, hogy Nem csak egy kis hurok, és egy függvény, amely azt mondja, köhögés vagy nem köhög. Tudod mit? Engedjék meg, hogy egy kicsit hűvösebb, mint az, és valójában írni egy függvényt, amely van néhány mellékhatása, hívják köhögés. 

És nem veszi input és nem ad vissza értéket a kibocsátás. De tudod, mit csinál? Ez nem this-- printf, idézet idézet vége, köhögés. 

És most itt, megyek hogy menjen előre, és int, i jelentkeznek nulla, azt kevesebb, mint 3, I Plus plusz. Megyek nem printf, mely vitathatatlanul alacsony szintű végrehajtás Részlet. Nem érdekel, hogy köhögni. Csak azt akarom, hogy használja a köhögés funkciót. És én csak fog hívni köhögés. 

Most észre a kettősség. Ha hívja a funkciót, ha nem szeretnénk, hogy ez viszi, teljesen rendben van. Csak nem nyitott zárójel, közel zárójel, és kész. 

Ha meg egy függvényt, vagy állapítsa meg a függvény prototípus, ha előre tudják, hogy ez nem fog tartani olyan érveket, mondjuk void azokban zárójelben van. És, ami biztos, hogy nem véletlenül visszaélni is. Hadd menjek előre, és a köhögés. És, persze, én hibáztam. 

A fenébe is, ott van az a implicit nyilatkozatot. De ez rendben van. Ez egy könnyű megoldás. Csak kell a prototípus feljebb az én file-én ténylegesen használja. 

Tehát most engedjék meg, hogy a köhögés megint szép. Most, hogy működik. Tedd köhögés, köhögés, köhögés, köhögés. Szóval lehet, hogy úgy gondolja, hogy már igazán több mint mérnöki ezt a problémát. És valóban, mi. Ez nem egy jó jelölt program ebben a pillanatban újraírás, és mit csinál úgynevezett hierarchikus lebontás, ahol némi kódot, majd a fajta tényező dolgokat úgy, tulajdonítani több szemantika nekik, és újra meg végül hosszabb távon. De ez egy építőelem felé kifinomultabb programok hogy indul előtt írásban hosszú, hogy lehetővé teszi számunkra, hogy a szókincs amellyel írni jobb kódot. És valóban, lássuk, ha nem lehet általánosítani ezt tovább. 

Úgy tűnik, egy kicsit béna, hogy én, a fő, kell aggódnia ez rohadt a hurok, és hívja köhögés újra és újra. Miért nem tudok csak mondani köhögés, Kérjük köhögés háromszor? Más szóval, miért nem tudok csak járulhatnak köhögni és ezt? 

Miért nem tudok csak mondani, hogy Fő köhögés háromszor. És most ez a fajta mágikus. Ez nagyon iteratív itt. És ez, sőt, egy apró lépés. 

De csak a képesség, hogy mondani vonal nyolc, köhögés három alkalommal, ez csak annyira sokkal olvashatóbb. És plusz, nem kell tudni vagy érdekel, hogy köhögés végrehajtását. És valóban, később a távú és végső projektek Ha kezelni a projekt osztálytársa vagy két osztálytársak, rájössz, hogy meg fogsz kell, vagy szeretné, osztja meg a munkát. 

És fogsz akar dönteni előre, hogy ki fog csinálni, amit, és amelyben darabokat? És nem lenne jó Ha például átvegyék az írás fő, kész. És a szobatársam, vagy az partner általánosabban gondoskodik a végrehajtási köhögés. 

És ezt a felosztást, ezek falai absztrakció, vagy rétegek absztrakció ha akkor, szuper erős, Mivel különösen a nagyobb, bonyolultabb programokat és rendszereket, ez lehetővé teszi, hogy egyszerre több ember is építeni dolgokat együtt, és végül öltés közös munka ezen a módon. De, persze, kell most kijavítani köhögés. El kell mondanunk köhögés hogy, hé, tudod mit? Fogsz kell szednie input-- így nem érvénytelen, de int és most. Menjünk előre, és helyezték köhögés az int. i lesz nulla. 

I-nél kisebb, hányszor. Azt mondtam, három előtt. De ez nem az, amit akarok. Azt akarom, hogy köhögés általánosítható támogat semmilyen iterációk száma. 

Tehát valóban, ez n, amit szeretnék, függetlenül a felhasználó azt mondja. Most már lehet menni előre, és azt mondják, a nyomtatási köhögés. És nem számít, milyen szám a felhasználó halad, Én hajtogat, hogy sokszor. 

Így a végén a nap, program azonos. De észre az összes ezt a cuccot Még az is lehet egy másik fájlt. Valóban, nem tudom, a pillanatban, hogy printf végrehajtását. 

Nem tudom, hogy abban a pillanatban, hogy hogyan kap húr, vagy kap int, vagy kap úszó végrehajtását. És nem akarom, hogy látni őket a monitoron. Ahogy van, kezdek összpontosítani programom, nem ezeket a funkciókat. 

És így, sőt, amint kezdeni faktoring kód, mint ez ki, tudnánk is mozog köhögés külön fájlba? Valaki más is végrehajtja. És te és a programot vált a nagyon szép, és nagyon olvasható, vitathatatlanul, valójában négy line programot ott. 

Tehát menjünk előre most , és még egy változás. Figyeljük meg, hogy a prototípus meg kell változtatni fel tetején. Tehát hadd megoldja, hogy Nem értem kiabált. 

Tedd köhögés, engedik köhögés egyszer több, még ugyanazt a dolgot. De most, észre van egy összetevő egy végleges változat. Tudod mit? Nem akarom, hogy csak köhögés, feltétlenül. Azt szeretnénk, hogy valami sokkal általánosabb. Szóval tudod mit? Azt akarom, hogy ezt. Azt akarom, hogy, akárcsak Scratch igen, egy mondjuk blokk, de nem csak mondani valamit bizonyos számú alkalommal. Azt akarom mondani, hogy nagyon speciális húr. És ezért én nem akarjuk, hogy csak azt a köhögés. Azt akarom, hogy azt mondják, amit karakterláncot továbbít. 

Így észre, amit generalizált ezt úgy, hogy most mondjuk úgy, mint egy jó név erre, mint a Scratch, két argumentuma, ellentétben Scratch. Az egyik egy húr. Az egyik egy int. 

És tudtam váltani őket. Csak olyan, mint azt az elképzelést, mondjuk a sztring első, majd hányszor később. Érvénytelen azt jelenti, hogy még mindig nem tér vissza semmit. Ezek csak látási hatások, mint a [? Jordan,?] szóbeli mellékhatása kiabál. Még mindig csinál valamit n-szer, 0-ig, de nem azonos N. Ez azt jelenti, n teljes idejére. És akkor csak ki kell nyomtatni bármi ez a string. Úgyhogy nagyon általánosított ezt a kódsort. Tehát most, hogyan kell használni A köhögés funkció? 

Meg tudom csinálni void köhögés. És én is venni, hogy hogyan sokszor azt szeretnénk, hogy köhög. De tudod mit? Most már punt mondani. 

Tudok hívni mondani a szó köhögés, átadva n. És ha azt szeretnénk, hogy is végrehajt, csak a móka kedvéért, tüsszentés funkció, Én tüsszentés bizonyos számú alkalommal. És tudom tartani újrahasznosítással n, mert észre, hogy m ebben az összefüggésben, illetve hatályát Csak belül létezik ez a funkció. 

És n ebben az összefüggésben csak belül létezik ez a funkció itt. Így fogunk térni ezeket a kérdéseket a hatálya alá. És itt, én csak azt fogja mondani, achoo, majd n-szer, félig vastagbélben. 

És most, csak meg kell kölcsönkérni ezek a funkciók aláírások itt. Tehát köhögés helyes. Érvénytelen tüsszentés helyes most. 

És még mindig csak meg kell mondani. Így fogok mondani, mondjuk s karakterlánc, int n, pontosvessző. Úgyhogy át megtervezett a fene ki ezt a programot. 

És ez nem feltétlenül jelenti azt, ez mit kell tennie, ha írásban még a legegyszerűbb program. Vegyünk valamit, ami nyilvánvalóan Nagyon egyszerű, nagyon rövid, és újra végrehajtja segítségével túl sok kódot. De akkor valóban látni, és idő tekint vissza ezeket a példákat, és észre, ó, ezek a lépések vettünk, hogy ténylegesen általánosítani, faktor valamit, amíg a végén a nap a kód valójában nagyon ésszerű. Mert, ha azt akarom, hogy köhög három szer majd tüsszentés háromszor, Én egyszerűen megy ujrafuttatni ezt, programot, hogy a köhögés, és futtassa a köhögés. És van három köhögések és három tüsszentés. 

És így ez egy alapvető paradigma, ha úgy tetszik, A hogyan lehet járni valójában program végrehajtása. De nézzük meg, most mi van mi már ennek az összes ebben az időben, és mi néhány végső darab mögött ezt az egyszerű paranccsal. A nap végén, most már használta csenget, mint a mi fordító. Mi már írt forrás kódot, konvertálás via Clang gépi kódra. 

És a korábban használt, hogy csak hogy megkönnyítse a billentyűket, így hogy nem kell emlékezni azok ráolvasások a Clang is. De mi is készítsünk valójában csinál? És viszont, mi Csengés valójában csinál? 

Kiderült, bár már egyszerűsített a mai vita azzal, szedése forráskód, át, mint bemenetet egy fordító, amely megadja kimenete gép kódot, kiderül van Néhány különböző lépések benne van. És összeállítása történik, hogy az esernyő kifejezés egy csomó lépést. De nézzük csak ugratni ezt ki nagyon gyorsan. 

Kiderült, hogy mi már ennek több dolgot minden alkalommal, amikor fut a program, vagy minden alkalommal, amikor összeállítja a mai program. Tehát előfeldolgozás utal this-- semmit egy C program, mint látni fogjuk, újra és újra, hogy indul ez a hash szimbólum, vagy a hashtag szimbólum itt azt jelenti, ez egy előfeldolgozó irányelvet. Ez azt jelenti, ebben az esetben, hé számítógép, valamit tenni ezt a fájlt mielőtt ténylegesen lefordítani a saját kódját. 

Ebben az esetben a hash közé IS, lényegében C- szóval, hé számítógép, menj a tartalom A CS50.h és illessze be őket ide. Hey számítógép, menj a tartalmát szabvány IO.h, bárhol legyen is az merevlemez, másolja be ide. Tehát ezek a dolgok történnek első közben előfeldolgozás. 

És csenget teszi mindezt számunkra. És mindezt olyan rohadt gyors, még csak nem is ha négy különböző dolgok történnek. De ez az első ilyen lépés. 

Hogy valójában mi történik ezután? Nos, a következő hivatalos lépés összeállítása. És kiderül, hogy összeállítása program technikailag azt jelenti, haladva forráskód, a dolgok lettek írogat ma, hogy valami úgynevezett assembly kód, valami úgy néz ki, egy kicsit más. 

És valóban, látjuk ezt a nagyon gyorsan. Hadd valójában bemegy az IDE. Hadd menjek előre, és nyitott hello.c, amely a legelső program, amellyel mi kezdődött ma. És hadd menjen előre, és futtatni csenget egy kicsit másképp, csenget-s, hello.c, amely ténylegesen fog adj egy másik fájl hello.s. 

És valószínűleg soha újra látni ezt a fajta kód. Ha az előírtnál alacsonyabb szinten rendszerek osztály, mint CS61, akkor egy sokkal az ilyen típusú kódot. De ez assembly nyelven. Ez x86 assembly hogy a CPU, ami mögöttes CS50 IDE ténylegesen meg is érti. 

És rejtélyes, ahogyan azt a nézd, ez valami A számítógép megért elég jól. Sub q, ez egy kivonni. Van mozgásokat. 

Ott hívja a funkciók itt, x ORING, a mozgás, egy bővítmény, a pop, visszatérés. Tehát van néhány nagyon alacsony szintű utasítások hogy CPU megérteni, hogy Utaltam korábban. Ez az, amit az Intel Inside. 

Vannak minták nullák és egyesek, hogy Térkép ezekre arcanely szól, de valamelyest jól elemzi, utasítások, hogy úgy mondjam. Ez történik, ha fordítod a kódot. Kapsz összeszerelés nyelv belőle, amely azt jelenti, a harmadik lépés, hogy össze hogy szerelés kódot, végül, gép code-- nullák, nem pedig szöveg, láttunk egy perce. 

Tehát előkezelést jelent megtalálni és cserélje ki, és néhány más dolog. Fordítása veszi a forrás kódot C forráskód hogy írtunk, a gyülekezési kódot, amit csak nézett. Összeszerelése tart, hogy a szerelvény kódot nullák és egyesek hogy a CPU tényleg megérteni a végén a nap. És összekapcsolása az utolsó lépés hogy történik us-- újra, Olyan gyorsan még azt sem notice--, amely azt mondja, hé gépedre, akkor az összes a nullák és egyesek, hogy eredményezett összeállítása Dávid kódot, és a fő funkciója ebben az esetben. 

És hé számítógép, menj mind a nullák és egyesek hogy a CS50 személyzet írta belül a CS50 könyvtár. Keverjük ezeket be Dávid. És hé számítógép, akkor kap az összes nullát és az is, hogy valaki más írta évekkel ezelőtt printf. És hozzá ezeket a egészet, úgy, hogy mi már Megkaptam a nullák és egyesek, a CS50 személyzet nullák és egyesek, A printf nullák és egyesek, és bármi más, amit használ. 

Mindannyian kap összefogása egyetlen nevű program, ebben az esetben, helló. Tehát ezentúl, mi csak használja a szót összeállítására. És mi magától értetődőnek, hogy amikor azt mondjuk, fordítsa le a programot, az azt jelenti, hé nem a pre-feldolgozás, összeszerelés, és összekapcsolása. De van valójában néhány szaftos cucc folyik ott a motorháztető alatt. És főleg, ha kap kíváncsi egy ideig, kezdheti dugta körül ezen az alacsonyabb szinten. De most, hogy észre között elvitelre ma egész egyszerűen a egy folyamat kezdetét, szerzés kényelmes valami hasonló hello world. Sőt, a legtöbb, amit tettünk ma biztosan nem fog süllyedni szupergyors. És ez időbe idő, és némi gyakorlatot. És esély, akkor rendezni Az akarom, hogy elérje a billentyűzetet vagy kiabálni a képernyőn. És mindez nem baj. Bár, talán próbáld meg nem csinálni a könyvtárban annyira. 

És végül, akkor lehet tudni azonban, hogy indul látva minták, mind a jó kódot hogy amit írt, és a hibákat hogy amit tett. És ugyanúgy, mint a folyamat válás TF vagy CA-szerű, kezdesz, hogy jobb és jobban látni azokat a mintákat, és csak megoldani az saját problémáit végül. Addig nem lesz elég bennünket, hogy kölcsön van támogatás, és neked ezen keresztül. És az írási-up minden a problémák lesztek vezetve az összes parancsot hogy én biztosan tudom, honnan sok gyakorlás már, de lehet, hogy már repült több mint egy feje most. És ez teljesen rendben van. 

De végül is, fogsz kezdeni, hogy mintákat. És ha egyszer már az összes buta részletek, mint például a zárójelek és zárójelekkel, és félig kettőspont, és a dolgok, őszintén szólva, hogy egyáltalán nem intellektuálisan érdekes. És ez nem az a célja hogy olyan bevezető osztályban. Ez az ötleteket, hogy fognak számít. 

Ez a hurkokat, és a körülmények között, és a funkciók, és erőteljesebben az absztrakció, és a faktoring a kódot, és a jó design, és a jó stílus, és végső soron a helyességét a kód, ami végső soron fog a leginkább számítanak. Így a jövő héten, megtesszük ezeket ötletek, hogy először láttam a Scratch és most lefordított C. És kezdjük bevezetni az első a Természetesen a valós tartományokat. 

Majd összpontosítani a világ biztonságát, pontosabban kriptográfia, A szakterületen kódolás információ. És az elsők között problémák te magad lesz, hogy írjon túl játszik néhány szintaktikai és megoldása néhány logikai problémák, végül nemsokára, az, hogy valóban zavarják, vagy titkosítása, és végül visszafejteni adatokat. És minden tettünk ma is meglehetősen alacsony szinten, csak megy, hogy a számunkra, hogy egy, egy, és még egy lépést a fenti felé írásban a legérdekesebb kódot sem. 

Így még az, hogy a jövő héten. 

[VIDEO LEJÁTSZÁS] 

-Mit Tudsz mondani nekem utoljára látta? -Mit Mondjak, tényleg? Úgy értem, ez olyan volt, mint bármely más gyártás előtti próba, csak itt nem volt valami azt mondta a legvégén, hogy ragadt rám. 

-Ez Volt CS50. 

-Ez Egy vágás mindenki, remek munkát végzett próba. 

-Ez Ebéd? 

Igen, te és én megragad egy szendvicset egy kicsit. Hadd eligazítást a David nagyon gyorsan. David? David? 

[END LEJÁTSZÁS] 