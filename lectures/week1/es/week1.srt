1
00:00:00,000 --> 00:00:00,000

2
00:00:00,000 --> 00:00:00,000
[REPRODUCIENDO MÚSICA]

3
00:00:00,000 --> 00:00:13,950

4
00:00:13,950 --> 00:00:16,240
>> DAVID J. MALAN: Muy bien, esto es CS50.

5
00:00:16,240 --> 00:00:18,010
Y esta es la semana uno.

6
00:00:18,010 --> 00:00:22,050
Así que recordar que la última vez en la semana cero,
nos hemos centrado en el pensamiento computacional.

7
00:00:22,050 --> 00:00:25,440
Y que la transición de que a
Scratch, una programación gráfica

8
00:00:25,440 --> 00:00:27,360
el lenguaje de nuestros amigos
en el Laboratorio de Medios del MIT.

9
00:00:27,360 --> 00:00:31,730
>> Y con Scratch, nos exploramos
ideas como las funciones y condiciones,

10
00:00:31,730 --> 00:00:35,210
y los bucles y variables, e incluso
eventos, e hilos, y más.

11
00:00:35,210 --> 00:00:37,880
Y hoy, vamos a
seguir utilizando esas ideas,

12
00:00:37,880 --> 00:00:40,630
y realmente tomarlas por
sentado, pero traducirlas

13
00:00:40,630 --> 00:00:44,220
a otro idioma conocido como C. Ahora,
C es un lenguaje más tradicional.

14
00:00:44,220 --> 00:00:46,020
Es un nivel más bajo
idioma, si se quiere.

15
00:00:46,020 --> 00:00:47,300
>> Es puramente textual.

16
00:00:47,300 --> 00:00:49,910
Y así, a primera vista, es
todo va a parecer más bien críptica

17
00:00:49,910 --> 00:00:51,430
si nunca has programado antes.

18
00:00:51,430 --> 00:00:53,530
Vamos a tener
punto y coma, y ​​paréntesis,

19
00:00:53,530 --> 00:00:55,150
y llaves, y más.

20
00:00:55,150 --> 00:00:57,240
Pero darse cuenta de que incluso
aunque la sintaxis es

21
00:00:57,240 --> 00:01:00,600
a punto de mirar un poco familiarizado
para la mayoría de ustedes, ver más allá de eso.

22
00:01:00,600 --> 00:01:03,220
Y tratar de ver las ideas
que son, de hecho, familiar,

23
00:01:03,220 --> 00:01:06,750
porque aquí en la semana uno lo
vamos a empezar a hacer es comparar,

24
00:01:06,750 --> 00:01:08,980
Inicialmente, a los arañazos en comparación con C.

25
00:01:08,980 --> 00:01:12,350
>> Así, por ejemplo, recordar que cuando
implementado el primero de nuestros programas

26
00:01:12,350 --> 00:01:16,220
última vez, tuvimos un bloque que parecía
un poco de algo así- cuando

27
00:01:16,220 --> 00:01:19,990
bandera verde se hace clic, y luego tuvimos
una o más piezas del rompecabezas por debajo de ella,

28
00:01:19,990 --> 00:01:22,150
en este caso, decir, hola mundo.

29
00:01:22,150 --> 00:01:24,870
Así que, de hecho, en Scratch,
al hacer clic en esa bandera verde

30
00:01:24,870 --> 00:01:27,390
para ejecutar mi programa, por lo
hablar, estos son

31
00:01:27,390 --> 00:01:29,520
los bloques que se ejecutan, o correr.

32
00:01:29,520 --> 00:01:32,230
Y, en concreto, Scratch
dijo, hola, mundo.

33
00:01:32,230 --> 00:01:35,377
>> Ahora, podría haber especificado
diferentes palabras aquí.

34
00:01:35,377 --> 00:01:37,960
Pero veremos que, de hecho, muchos
de estos blocks-- y, de hecho,

35
00:01:37,960 --> 00:01:41,880
en C muchas functions-- pueden ser
parametrizada o personalizada

36
00:01:41,880 --> 00:01:43,150
para hacer cosas diferentes.

37
00:01:43,150 --> 00:01:45,520
De hecho, en C si
querer convertir, ahora,

38
00:01:45,520 --> 00:01:47,567
este programa de Scratch
a este otro idioma,

39
00:01:47,567 --> 00:01:49,650
vamos a escribir una
poco algo como esto.

40
00:01:49,650 --> 00:01:52,540
>> Por supuesto, hay alguna desconocida
Sintaxis hay más probable, int,

41
00:01:52,540 --> 00:01:54,380
y los paréntesis y sin efecto.

42
00:01:54,380 --> 00:01:57,740
Pero printf-- a pesar de que lo haría
creo que sería sólo de impresión.

43
00:01:57,740 --> 00:02:00,120
Pero la impresión de impresión significa
formateado, como pronto veremos.

44
00:02:00,120 --> 00:02:02,140
Esto, literalmente, se imprimirá
a la pantalla lo

45
00:02:02,140 --> 00:02:05,990
está dentro de esos paréntesis, que
por supuesto, en este caso es, hola mundo.

46
00:02:05,990 --> 00:02:09,290
>> Sin embargo, se dará cuenta de alguna otra
sintaxis, algunas citas dobles,

47
00:02:09,290 --> 00:02:11,890
que los paréntesis al final,
el punto y coma y similares.

48
00:02:11,890 --> 00:02:15,027
Así que hay un poco de sobrecarga,
por así decirlo, tanto cognitivamente

49
00:02:15,027 --> 00:02:17,860
y sintácticamente, que vamos
tener que recordar en poco tiempo.

50
00:02:17,860 --> 00:02:20,720
Pero darse cuenta de que con la práctica,
esto comenzará a saltar a la vista.

51
00:02:20,720 --> 00:02:24,920
>> De hecho, vamos a centrarnos en que uno
función specifically-- en este caso,

52
00:02:24,920 --> 00:02:26,290
saludar mundo.

53
00:02:26,290 --> 00:02:27,560
Así es decir la función.

54
00:02:27,560 --> 00:02:31,320
Hola mundo es su parámetro,
o argumento, su personalización.

55
00:02:31,320 --> 00:02:34,320
>> Y la equivalencia en C es sólo
esto va a ser una línea aquí,

56
00:02:34,320 --> 00:02:38,710
donde printf es equivalente a, por ejemplo,
la cadena entre comillas dobles, hola

57
00:02:38,710 --> 00:02:41,470
mundo es equivalente, por supuesto,
a lo que hay en la caja blanca allí.

58
00:02:41,470 --> 00:02:45,680
Y la barra invertida n, aunque un poco
extraña y ausente de Scratch,

59
00:02:45,680 --> 00:02:49,380
simplemente va a tener el efecto que vamos a
ver en una computadora, como mi Mac o un PC,

60
00:02:49,380 --> 00:02:51,660
de tan sólo mover el
cursor a la siguiente línea.

61
00:02:51,660 --> 00:02:53,970
Es como golpear
Intro en el teclado.

62
00:02:53,970 --> 00:02:55,580
>> Así que veremos de nuevo en poco tiempo.

63
00:02:55,580 --> 00:02:58,640
Pero primero, vamos a echar un vistazo a este
otro ejemplo en el caso de los bucles.

64
00:02:58,640 --> 00:03:02,830
Hemos tenido este bucle infinito última vez,
que era una serie de piezas de un rompecabezas

65
00:03:02,830 --> 00:03:05,490
que hicieron algo, literalmente,
forever-- en este caso,

66
00:03:05,490 --> 00:03:08,360
decir hola mundo, Hello World,
hola mundo, hola mundo.

67
00:03:08,360 --> 00:03:10,350
Así que es un bucle infinito por diseño.

68
00:03:10,350 --> 00:03:14,580
>> En C, si queremos poner en práctica este
misma idea, que podría simplemente hacer esto.

69
00:03:14,580 --> 00:03:19,570
Aunque es verdad, printf hola mundo-- ahora
mientras que, al igual semánticamente, tipo de

70
00:03:19,570 --> 00:03:23,090
evoca la idea de hacer
algo otra vez, y otra vez, y otra vez,

71
00:03:23,090 --> 00:03:23,980
¿y por cuánto tiempo?

72
00:03:23,980 --> 00:03:27,990
Bueno, recuerdo que cierto--
es cierto sólo en o uno.

73
00:03:27,990 --> 00:03:30,660
>> Y es cierto, por supuesto, siempre es cierto.

74
00:03:30,660 --> 00:03:33,060
Así que es una especie de sentido
declaración que acaba de decir verdad.

75
00:03:33,060 --> 00:03:36,890
Pero de hecho, esto es deliberado,
porque si es cierto es justo siempre es cierto,

76
00:03:36,890 --> 00:03:40,850
que mientras que la verdadera simplemente implica,
si un poco indirectamente,

77
00:03:40,850 --> 00:03:44,070
que las siguientes líneas de código
entre esas llaves

78
00:03:44,070 --> 00:03:48,320
sólo debe ejecutar de nuevo, y de nuevo,
y otra vez, y en realidad nunca parar.

79
00:03:48,320 --> 00:03:50,230
>> Pero si usted quiere que su
bucle para detener, ya que

80
00:03:50,230 --> 00:03:54,500
fue la última vez con algo así como
esto, repita los siguientes 50 veces,

81
00:03:54,500 --> 00:03:57,700
en C podemos hacer lo mismo con lo que hay
llamado para loop-- la palabra clave

82
00:03:57,700 --> 00:03:59,330
no siendo tiempo, pero para.

83
00:03:59,330 --> 00:04:03,290
Y entonces tenemos una nueva sintaxis aquí,
con int i es igual a 0, i de menos de 50,

84
00:04:03,290 --> 00:04:03,880
i ++.

85
00:04:03,880 --> 00:04:05,430
Y vamos a volver a eso.

86
00:04:05,430 --> 00:04:09,660
Pero esto es simplemente la forma en que lo haría
traducir el conjunto de bloques de Scratch

87
00:04:09,660 --> 00:04:13,079
a un conjunto de líneas C de código.

88
00:04:13,079 --> 00:04:14,450
>> Mientras tanto, considerar variables.

89
00:04:14,450 --> 00:04:16,540
Y, de hecho, sólo
vi uno hace un momento.

90
00:04:16,540 --> 00:04:21,220
Y en el caso de Scratch, si
querido declarar una variable llamada i

91
00:04:21,220 --> 00:04:24,590
para i ser entero, sólo un número,
y queremos ponerlo en algún valor,

92
00:04:24,590 --> 00:04:28,410
usaríamos esta naranja
bloquear aquí-- i establece en 0.

93
00:04:28,410 --> 00:04:30,800
>> Y vamos a ver hoy y
más allá, al igual que la semana pasada,

94
00:04:30,800 --> 00:04:33,850
programadores hacen casi siempre
empezará a contar a partir de cero, de verdad

95
00:04:33,850 --> 00:04:34,950
por convención.

96
00:04:34,950 --> 00:04:37,250
Pero también porque el recuerdo de
nuestra discusión de la binaria,

97
00:04:37,250 --> 00:04:39,990
el más pequeño número que puede
representar con cualquier número de bits

98
00:04:39,990 --> 00:04:41,640
es sólo va a ser 0 en sí.

99
00:04:41,640 --> 00:04:45,190
Y así vamos a empezar por lo general
inicializar incluso nuestras variables a 0.

100
00:04:45,190 --> 00:04:47,710
>> Y en C para hacer lo mismo,
vamos a decir int

101
00:04:47,710 --> 00:04:50,110
por entero, sólo por convención.

102
00:04:50,110 --> 00:04:53,390
Podría haber llamado a esta variable
lo que quiera, al igual que en Scratch.

103
00:04:53,390 --> 00:04:57,770
Y entonces es igual a 0 cesionarios
el valor 0 por la derecha

104
00:04:57,770 --> 00:05:01,319
y la coloca en la variable, o el
contenedor de almacenamiento de allí, a la izquierda.

105
00:05:01,319 --> 00:05:04,360
Y el punto y coma como vamos a ver-- y
hemos visto algunos de estos ya--

106
00:05:04,360 --> 00:05:06,530
Sólo significa fin del pensamiento.

107
00:05:06,530 --> 00:05:09,430
Procederá a hacer otra cosa
en las líneas que siguen.

108
00:05:09,430 --> 00:05:11,330
>> Ahora, ¿qué pasa con las expresiones booleanas?

109
00:05:11,330 --> 00:05:14,320
Recordemos que en Scratch,
éstas eran expresiones

110
00:05:14,320 --> 00:05:16,740
que son verdaderas
o preguntas false--,

111
00:05:16,740 --> 00:05:18,910
Realmente, que son verdaderas o falsas.

112
00:05:18,910 --> 00:05:21,960
Así, en el caso de los arañazos, podríamos
hacer una pregunta tan simple como este,

113
00:05:21,960 --> 00:05:24,586
i es menor que 50?

114
00:05:24,586 --> 00:05:25,710
Así que, de nuevo, es un número entero.

115
00:05:25,710 --> 00:05:27,210
Tal vez lo estamos utilizando
en un programa de Scratch

116
00:05:27,210 --> 00:05:29,310
hacer un seguimiento de una puntuación
o algo así.

117
00:05:29,310 --> 00:05:33,810
Así que esta sintaxis aquí en Scratch
Sólo significa, i es inferior a 50?

118
00:05:33,810 --> 00:05:37,330
Bueno, por suerte, es algo
simple en C. Y para traducir,

119
00:05:37,330 --> 00:05:41,780
esto sería simplemente decir que menos
de 50, utilizando la clave familiarizado

120
00:05:41,780 --> 00:05:42,850
en su teclado.

121
00:05:42,850 --> 00:05:45,141
>> Mientras tanto, si usted quiere
decir algo más general,

122
00:05:45,141 --> 00:05:49,890
como, bueno, es x menor que y donde cada uno
de X e Y son ellos mismos variables?

123
00:05:49,890 --> 00:05:52,280
Podemos hacer la misma cosa
en C, tanto tiempo como hemos

124
00:05:52,280 --> 00:05:53,942
creado estas variables ya.

125
00:05:53,942 --> 00:05:55,650
Y veremos cómo
hacer que en poco tiempo.

126
00:05:55,650 --> 00:05:58,590
Nos gustaría decir simplemente x menor que y.

127
00:05:58,590 --> 00:06:00,530
>> Así que usted está comenzando a
ver algunas similitudes.

128
00:06:00,530 --> 00:06:03,490
Y aquellas personas que hicieron
Scratch fueron sin duda

129
00:06:03,490 --> 00:06:05,250
inspirado en algunas de estas ideas básicas.

130
00:06:05,250 --> 00:06:10,350
Y verá este tipo de
Las Lenguas de sintaxis en muchos

131
00:06:10,350 --> 00:06:12,160
No sólo rascar, no
simplemente C, pero Python,

132
00:06:12,160 --> 00:06:14,790
y JavaScript, y
otros idiomas aún.

133
00:06:14,790 --> 00:06:18,270
>> Vamos a considerar otra construcción
de C, la noción de una condición,

134
00:06:18,270 --> 00:06:20,370
hacer algo de forma condicional.

135
00:06:20,370 --> 00:06:22,720
Si algo es cierto, hacer esto.

136
00:06:22,720 --> 00:06:24,457
Si hay algo más es cierto, hacer eso.

137
00:06:24,457 --> 00:06:27,040
Es una especie de la programación
equivalente a un tenedor en la carretera.

138
00:06:27,040 --> 00:06:29,730
Tal vez sea un tenedor de dos vías,
una de tres vías tenedor, o más.

139
00:06:29,730 --> 00:06:32,800
Y en Scratch, podríamos tener
visto algo como esto.

140
00:06:32,800 --> 00:06:34,010
>> Así que éste es un grande.

141
00:06:34,010 --> 00:06:36,750
Pero tenga en cuenta la relativa
simplicidad de la lógica.

142
00:06:36,750 --> 00:06:44,010
Si x es menor que y, a continuación, decir x es menor
que y, más si x es mayor que y,

143
00:06:44,010 --> 00:06:46,230
luego decir x es mayor que y.

144
00:06:46,230 --> 00:06:48,300
Y entonces, lógicamente, si
piensa volver a los arañazos

145
00:06:48,300 --> 00:06:52,610
o simplemente su propia intuición humana,
así, si x no es mayor que y, y x

146
00:06:52,610 --> 00:06:57,000
no es menor que y, a continuación, por supuesto
x va a ser igual a y.

147
00:06:57,000 --> 00:06:59,690
Así pues, en este caso, por la jerarquización
esos bloques de Scratch,

148
00:06:59,690 --> 00:07:02,580
podemos lograr un período de tres
tenedor camino en el camino?

149
00:07:02,580 --> 00:07:04,980
>> Mientras tanto, si queremos
hacer que en C, podría decirse que

150
00:07:04,980 --> 00:07:08,420
se ve un poco simpler-- al menos
Una vez que se familiarice con la sintaxis.

151
00:07:08,420 --> 00:07:12,050
Si x es menor que y,
printf x es menor que y.

152
00:07:12,050 --> 00:07:16,140
Else si x es mayor que y,
printf x es mayor que y.

153
00:07:16,140 --> 00:07:21,210
Else printf x es igual a Y- y,
de nuevo, con los extremos de barra invertida solo

154
00:07:21,210 --> 00:07:24,160
para esas nuevas líneas de modo que si
actualmente se encontró este tipo de programa

155
00:07:24,160 --> 00:07:25,940
que sería sólo mover
el cursor en última instancia,

156
00:07:25,940 --> 00:07:28,100
a la siguiente línea de la pantalla.

157
00:07:28,100 --> 00:07:31,270
>> Ahora, por su parte arañazos tenía otra
características más sofisticadas, solamente

158
00:07:31,270 --> 00:07:34,320
algunos de los cuales vamos a
Inicialmente moverse hacia el mundo de la C.

159
00:07:34,320 --> 00:07:37,010
Y uno de ellos era
llama una lista en Scratch.

160
00:07:37,010 --> 00:07:39,100
Y esto era un especial
tipo de variable que

161
00:07:39,100 --> 00:07:42,840
permitió que le permite almacenar múltiples cosas
en ella hacia atrás, hacia atrás, hacia atrás, hacia atrás.

162
00:07:42,840 --> 00:07:45,540
>> En C, que no tiene
listas, per se, pero algo

163
00:07:45,540 --> 00:07:48,090
que son más generalmente
llamada matrices, a pesar de que va

164
00:07:48,090 --> 00:07:50,590
volver más tarde este semestre
que mira algo

165
00:07:50,590 --> 00:07:52,780
llama una lista, o en realidad una lista enlazada.

166
00:07:52,780 --> 00:07:55,510
Pero por ahora, el más cercano
equivalente en C para nosotros

167
00:07:55,510 --> 00:07:57,345
va a ser algo
denominado matriz.

168
00:07:57,345 --> 00:07:59,740
Y una matriz es simplemente una
tipo especial de variable

169
00:07:59,740 --> 00:08:03,160
que le permite almacenar datos
hacia atrás, hacia atrás, hacia atrás, hacia atrás.

170
00:08:03,160 --> 00:08:05,840
>> Y, de hecho, en Scratch,
si queríamos acceder

171
00:08:05,840 --> 00:08:09,030
el primer elemento de una matriz o
un películas-- y voy a llamarlo,

172
00:08:09,030 --> 00:08:13,600
por convención, argv, el argumento
vector, pero más de eso en poco tiempo.

173
00:08:13,600 --> 00:08:17,090
Si quiero conseguir en el primer elemento
de argv, en el mundo de los arañazos

174
00:08:17,090 --> 00:08:20,930
que realmente hacen típicamente
empezará a contar a partir del 1.

175
00:08:20,930 --> 00:08:22,850
>> Y por lo que podría conseguir el artículo 1 de argv.

176
00:08:22,850 --> 00:08:26,310
Así es como el MIT implementado
la noción de listas.

177
00:08:26,310 --> 00:08:29,860
Pero en C, voy a
más simplemente decir, argv,

178
00:08:29,860 --> 00:08:32,758
que a su vez es el nombre de mi
películas-- o para ser claros, una matriz.

179
00:08:32,758 --> 00:08:34,549
Y si quiero que la primera
elementos, voy

180
00:08:34,549 --> 00:08:37,890
utilizar corchetes, que se
puede que no se utiliza a menudo en un teclado.

181
00:08:37,890 --> 00:08:40,150
>> Pero a 0 significa, me la primera.

182
00:08:40,150 --> 00:08:42,160
Así que de vez en cuando y como
el tiempo pasa, nos vamos

183
00:08:42,160 --> 00:08:44,570
para empezar a ver estas dicotomías
entre cero y C,

184
00:08:44,570 --> 00:08:46,070
mediante el cual los arañazos utiliza uno.

185
00:08:46,070 --> 00:08:47,670
Nosotros utilizamos en C 0 aquí.

186
00:08:47,670 --> 00:08:49,420
Pero que da gusto ver
una vez que entienda

187
00:08:49,420 --> 00:08:52,920
los fundamentos de cada idioma, que las
estas cosas se ponen aún más

188
00:08:52,920 --> 00:08:56,860
familiar a través de la práctica y la práctica.

189
00:08:56,860 --> 00:08:59,700
>> Así que realmente se ven ahora en un programa.

190
00:08:59,700 --> 00:09:04,031
Aquí será el primero de nuestra C
código fuente de programas completos.

191
00:09:04,031 --> 00:09:06,280
Y el programa que vamos
para ofrecer a la consideración

192
00:09:06,280 --> 00:09:09,340
es la que es equivalente
a ese pedazo de Scratch anterior.

193
00:09:09,340 --> 00:09:13,210
>> Así que aquí, tenemos lo que es
sin duda el programa más simple C

194
00:09:13,210 --> 00:09:15,410
que se puede escribir
En realidad hace algo.

195
00:09:15,410 --> 00:09:18,250
Ahora, vamos a ver más allá,
por ahora, se ha incluir,

196
00:09:18,250 --> 00:09:21,190
io.h estándar, y éstos ángulo
corchetes, y int, y sin efecto,

197
00:09:21,190 --> 00:09:22,840
y las llaves, y similares.

198
00:09:22,840 --> 00:09:25,390
>> Y vamos a centrarnos en
lo que, al menos intuitivamente,

199
00:09:25,390 --> 00:09:26,860
podría saltan a la vista ya.

200
00:09:26,860 --> 00:09:30,300
De hecho, la principal, no lo creo
necesariamente sabe lo que es esto,

201
00:09:30,300 --> 00:09:34,580
pero al igual que los arañazos que cuando tenían
bandera verde clic pieza del rompecabezas,

202
00:09:34,580 --> 00:09:39,070
lo mismo ocurre con C como un lenguaje de programación
tener una pieza principal de código que

203
00:09:39,070 --> 00:09:43,380
es ejecutado por defecto. Y de hecho,
Es, literalmente, va a ser llamado principal.

204
00:09:43,380 --> 00:09:44,720
>> Así principal es una función.

205
00:09:44,720 --> 00:09:48,720
Y es una función especial que existe
en C que cuando se ejecuta un programa,

206
00:09:48,720 --> 00:09:52,720
es principal que es atropellado por
defecto. En el mundo de los arañazos,

207
00:09:52,720 --> 00:09:56,970
que era por lo general cuando la bandera verde
hecho clic que consiguió funcionamiento por defecto.

208
00:09:56,970 --> 00:10:01,130
>> Mientras tanto, hemos visto esto antes,
printf o de impresión con formato, eso es

209
00:10:01,130 --> 00:10:05,620
va a ser una función que viene con
C, junto con un montón de otros,

210
00:10:05,620 --> 00:10:10,140
que la voluntad del tiempo y el tiempo
de nuevo, con el fin de hacer exactamente

211
00:10:10,140 --> 00:10:12,450
como su nombre indica, imprimir algo.

212
00:10:12,450 --> 00:10:13,500
¿Qué queremos para imprimir?

213
00:10:13,500 --> 00:10:15,770
Bueno, veremos que
por caracteres que encierran

214
00:10:15,770 --> 00:10:18,680
como these-- hola mundo,
n barra invertida entre comillas dobles,

215
00:10:18,680 --> 00:10:23,040
podemos decir exactamente printf
Lo que hay que imprimir en la pantalla.

216
00:10:23,040 --> 00:10:26,430
>> Sin embargo, con el fin de hacer
que, por desgracia

217
00:10:26,430 --> 00:10:30,010
necesitará tomar algo que es
Ya críptica para nosotros los seres humanos,

218
00:10:30,010 --> 00:10:34,510
pero al menos es algo readable--
agudo incluyen, io.h estándar, int,

219
00:10:34,510 --> 00:10:39,340
principal, nula, printf, toda la mágica
encantamientos que acabamos de ver en la pantalla.

220
00:10:39,340 --> 00:10:42,470
Pero en realidad tenemos que
ir más arcano todavía.

221
00:10:42,470 --> 00:10:47,140
Primero tenemos que traducir el código
que se escribe en código máquina.

222
00:10:47,140 --> 00:10:51,370
Y recordar a la semana pasada que las máquinas,
al menos los que saben que aquí,

223
00:10:51,370 --> 00:10:54,450
al final de la día solamente
entender ceros y unos.

224
00:10:54,450 --> 00:10:58,100
>> Y mi Dios, si tuviéramos que escribir estos
ceros y unos a realidad el programa,

225
00:10:58,100 --> 00:11:01,260
que sería muy, muy rápidamente
eliminar la diversión de nada.

226
00:11:01,260 --> 00:11:05,150
Pero resulta que, a la semana pasada,
que estos patrones de ceros y unos

227
00:11:05,150 --> 00:11:06,400
sólo tienen un significado especial.

228
00:11:06,400 --> 00:11:08,500
En ciertos contextos,
que pueden significar números.

229
00:11:08,500 --> 00:11:11,840
>> En algunos contextos, que pueden significar
letras o colores, o cualquier número

230
00:11:11,840 --> 00:11:14,710
de otras abstracciones allí sobre.

231
00:11:14,710 --> 00:11:18,450
Pero al igual que el equipo tiene
una CPU, Central Processing Unit,

232
00:11:18,450 --> 00:11:20,390
o el cerebro en el interior de su ordenador.

233
00:11:20,390 --> 00:11:22,240
Por lo general es Intel
en el interior, porque eso es

234
00:11:22,240 --> 00:11:24,900
una de las mayores empresas
que hace que las CPU de los ordenadores.

235
00:11:24,900 --> 00:11:28,910
>> Pues bien, las CPU Intel y otros
simplemente han decidido de antemano

236
00:11:28,910 --> 00:11:33,970
que ciertos patrones de ceros y
las cosas se entenderá específicos.

237
00:11:33,970 --> 00:11:37,040
Ciertos patrones de ceros y unos
significará, imprimir esta a la pantalla,

238
00:11:37,040 --> 00:11:39,710
o añadir estos dos números, o
restar estos dos números,

239
00:11:39,710 --> 00:11:43,310
o mover esta pieza de datos de
la memoria de mi ordenador a través de aquí,

240
00:11:43,310 --> 00:11:47,870
o cualquier otro número de muy bajo nivel,
pero en última instancia útil, operaciones.

241
00:11:47,870 --> 00:11:53,022
Pero, por suerte, los humanos no van
a necesitar saber este nivel de detalle.

242
00:11:53,022 --> 00:11:56,230
De hecho, como la última vez, en la que
abstraído de nuevo, y otra vez, y otra vez,

243
00:11:56,230 --> 00:11:58,930
edificio de muy bajo nivel
primitivas como ceros y unos

244
00:11:58,930 --> 00:12:01,160
a los conceptos de más alto nivel
como números y letras,

245
00:12:01,160 --> 00:12:04,330
y los colores, y mucho más,
por lo que podemos, como programadores

246
00:12:04,330 --> 00:12:07,080
de pie sobre los hombros de
otros que han venido antes que nosotros

247
00:12:07,080 --> 00:12:11,260
y utilizar el software que otra
personas han escrito antes de nosotros--

248
00:12:11,260 --> 00:12:14,340
a saber, los programas llamados compiladores.

249
00:12:14,340 --> 00:12:17,770
>> C es un lenguaje que
por lo general se compila,

250
00:12:17,770 --> 00:12:22,130
lo que significa convertido de
código fuente a código máquina.

251
00:12:22,130 --> 00:12:25,230
En particular, lo que esto significa
es que si usted tiene su fuente

252
00:12:25,230 --> 00:12:29,530
código que se escribe a sí mismo, como pronto
lo hará en un momento en la pantalla,

253
00:12:29,530 --> 00:12:33,140
y quiere convertirlo
en última instancia, a la máquina code--

254
00:12:33,140 --> 00:12:37,100
esos ceros y unos que
Sólo tu Mac o PC

255
00:12:37,100 --> 00:12:41,230
understands-- usted tiene una primera
alimentar a que el código fuente como en

256
00:12:41,230 --> 00:12:46,340
de entrada a una especial
programa llamado un compilador,

257
00:12:46,340 --> 00:12:48,974
la salida de la cual
verá es el código máquina.

258
00:12:48,974 --> 00:12:51,890
Y, de hecho, la última vez que hablamos
aproximadamente, en realidad, al final del día,

259
00:12:51,890 --> 00:12:52,610
la resolución de problemas.

260
00:12:52,610 --> 00:12:53,360
Tienes entradas.

261
00:12:53,360 --> 00:12:54,318
Y usted tiene salidas.

262
00:12:54,318 --> 00:12:56,560
Y usted tiene algún tipo
de algoritmo en el medio.

263
00:12:56,560 --> 00:12:59,830
>> Los algoritmos pueden ser sin duda
implementado en software,

264
00:12:59,830 --> 00:13:02,900
como hemos visto con pseudocódigo la semana pasada
y como veremos con código real

265
00:13:02,900 --> 00:13:03,490
esta semana.

266
00:13:03,490 --> 00:13:06,430
Y así, un compilador en realidad sólo
tiene un conjunto de algoritmos en el interior

267
00:13:06,430 --> 00:13:10,060
de la misma que saber cómo
convertir las palabras clave especiales,

268
00:13:10,060 --> 00:13:12,180
como principal, y printf,
y otros que acabamos

269
00:13:12,180 --> 00:13:17,620
vio en los patrones de ceros y
los que Intel Inside y otras CPU

270
00:13:17,620 --> 00:13:20,020
realmente entiende.

271
00:13:20,020 --> 00:13:22,460
¿Entonces como hacemos esto?

272
00:13:22,460 --> 00:13:24,470
¿De dónde obtenemos un compilador?

273
00:13:24,470 --> 00:13:26,400
>> La mayoría de los que estamos aquí tenemos un Mac o un PC.

274
00:13:26,400 --> 00:13:29,152
Y se está ejecutando Mac OS, o
Windows o Linux o Solaris,

275
00:13:29,152 --> 00:13:30,860
o cualquier número de otra
sistemas operativos.

276
00:13:30,860 --> 00:13:32,568
Y, de hecho, podríamos
salir a la web

277
00:13:32,568 --> 00:13:35,710
y descargar un compilador
para su Mac o PC

278
00:13:35,710 --> 00:13:37,360
para su sistema operativo en particular.

279
00:13:37,360 --> 00:13:39,617
Sin embargo, todos estaríamos en
diferentes páginas, por así decirlo.

280
00:13:39,617 --> 00:13:41,450
Nos gustaría tener un poco
diferentes configuraciones.

281
00:13:41,450 --> 00:13:43,210
Y las cosas no funcionarían todo lo mismo.

282
00:13:43,210 --> 00:13:45,280
Y, de hecho, en estos días
muchos de nosotros no utilice

283
00:13:45,280 --> 00:13:47,516
software que se ejecuta sólo en nuestros ordenadores portátiles.

284
00:13:47,516 --> 00:13:49,390
En cambio, usamos algo
como un navegador que

285
00:13:49,390 --> 00:13:52,930
nos permite tener acceso basado en web-
aplicaciones en la nube.

286
00:13:52,930 --> 00:13:55,630
Y a finales de este semestre,
vamos a hacer exactamente eso.

287
00:13:55,630 --> 00:13:59,660
Vamos a escribir aplicaciones o
software no usar code-- C,

288
00:13:59,660 --> 00:14:02,860
pero otros lenguajes como Python y
JavaScript-- que se ejecutan en la nube.

289
00:14:02,860 --> 00:14:05,860
>> Y para hacer eso, nosotros mismos
durante el semestre

290
00:14:05,860 --> 00:14:11,890
en realidad utilizar una nube-basado
ambiente conocido como CS50 IDE.

291
00:14:11,890 --> 00:14:16,030
Esta es una programación basada en web
medio ambiente, o el desarrollo integrado

292
00:14:16,030 --> 00:14:20,610
medio ambiente, IDE, que está construida encima de algunos
software de código abierto llamado Cloud 9.

293
00:14:20,610 --> 00:14:22,966
Y hemos hecho algunos pedagógica
simplificaciones en lo

294
00:14:22,966 --> 00:14:25,840
con el fin de ocultar ciertas características en
las primeras semanas que no necesitamos,

295
00:14:25,840 --> 00:14:27,770
después de lo cual se puede
revelarlas y hacer la mayor parte

296
00:14:27,770 --> 00:14:29,400
lo que quiera con el medio ambiente.

297
00:14:29,400 --> 00:14:32,470
>> Y nos permite, también, para
pre-instalar cierto tipo de software.

298
00:14:32,470 --> 00:14:35,330
Cosas como un denominado CS50
biblioteca, que pronto veremos

299
00:14:35,330 --> 00:14:39,210
nos proporciona en C con un poco
funcionalidad adicional.

300
00:14:39,210 --> 00:14:44,392
Así que si vas a, en última instancia, CS50.io,
se le pedirá que ingrese,

301
00:14:44,392 --> 00:14:46,350
y una vez que haces y crear
una cuenta de forma gratuita,

302
00:14:46,350 --> 00:14:52,150
usted será capaz de acceder a una
ambiente que se ve bastante como éste.

303
00:14:52,150 --> 00:14:53,760
>> Ahora, esto es en el modo por defecto.

304
00:14:53,760 --> 00:14:55,650
Todo es agradable y
brillante en la pantalla.

305
00:14:55,650 --> 00:14:57,941
Muchos de nosotros tenemos la costumbre de
trabajar en la pieza que es CS50

306
00:14:57,941 --> 00:14:59,150
bastante tarde en la noche.

307
00:14:59,150 --> 00:15:02,400
Y por lo que algunos de ustedes podrían preferir
convertirlo en modo nocturno, por así decirlo.

308
00:15:02,400 --> 00:15:05,550
>> Pero, en última instancia, lo que está
vamos a ver dentro IDE CS50

309
00:15:05,550 --> 00:15:08,340
es de tres areas-- distinta
un área de la izquierda donde

310
00:15:08,340 --> 00:15:12,604
sus archivos van a estar en el
nube, un área en la parte superior derecha

311
00:15:12,604 --> 00:15:14,270
donde el código va a ser editable.

312
00:15:14,270 --> 00:15:16,650
Podrás abrir
fichas individuales para cualquier programa

313
00:15:16,650 --> 00:15:19,670
que se escribe dentro de este semestre
de la esquina superior derecha.

314
00:15:19,670 --> 00:15:23,070
Y entonces la mayoría arcanamente,
y sin embargo de gran alcance,

315
00:15:23,070 --> 00:15:26,610
va a ser esta cosa en el
inferior conocida como una ventana de terminal.

316
00:15:26,610 --> 00:15:29,450
>> Esta es una vieja escuela
Interfaz de línea de comando,

317
00:15:29,450 --> 00:15:32,240
o CLI, que permite
ejecutar comandos

318
00:15:32,240 --> 00:15:35,260
en el computer-- en este caso,
el equipo en el cloud--

319
00:15:35,260 --> 00:15:39,090
para hacer cosas como compilar el código
desde el código fuente a código máquina,

320
00:15:39,090 --> 00:15:43,600
para ejecutar sus programas, o para iniciar su
servidor web, o para acceder a su base de datos,

321
00:15:43,600 --> 00:15:47,454
y cualquier número de otras técnicas
que vamos a empezar a utilizar después de poco tiempo.

322
00:15:47,454 --> 00:15:49,370
Pero para llegar allí, estamos
va a tener realmente

323
00:15:49,370 --> 00:15:51,240
ir en línea y empezar a jugar.

324
00:15:51,240 --> 00:15:54,399
Y para hacer eso, primero vamos a
empezar jugando con principal,

325
00:15:54,399 --> 00:15:55,940
y escribir la parte principal de un programa.

326
00:15:55,940 --> 00:15:59,170
Y vamos a utilizar esa función
printf, que hemos utilizado anteriormente,

327
00:15:59,170 --> 00:16:01,050
simplemente para decir algo.

328
00:16:01,050 --> 00:16:04,910
>> Así que aquí estoy ya en el interior del IDE CS50.

329
00:16:04,910 --> 00:16:05,930
He conectado con antelación.

330
00:16:05,930 --> 00:16:07,360
Y me llena exhibió la ventana.

331
00:16:07,360 --> 00:16:09,670
Y así, en última instancia, se
también en problemas próximos

332
00:16:09,670 --> 00:16:12,960
seguirá los mismos pasos que
proporcionará documentación en línea.

333
00:16:12,960 --> 00:16:16,360
Por lo que no tiene que preocuparse acerca
absorbiendo cada pequeño paso técnico

334
00:16:16,360 --> 00:16:17,730
que hago hoy aquí.

335
00:16:17,730 --> 00:16:19,222
>> Pero obtendrá una pantalla como esta.

336
00:16:19,222 --> 00:16:20,430
Da la casualidad que en el modo nocturno.

337
00:16:20,430 --> 00:16:22,944
Y se puede iluminar todo
por desactivación del modo noche.

338
00:16:22,944 --> 00:16:24,860
Y al final de la
día, vas a ver

339
00:16:24,860 --> 00:16:30,090
estos tres principales areas-- el archivo
navegador de la izquierda, las lengüetas de código encima de la tapa,

340
00:16:30,090 --> 00:16:32,430
y la ventana de terminal en la parte inferior.

341
00:16:32,430 --> 00:16:34,890
>> Déjame ir adelante y
escribir mi primer programa.

342
00:16:34,890 --> 00:16:42,300
Voy a ir a Archivo preventivamente,
Guardar y salvar mi archivo como hola.c.

343
00:16:42,300 --> 00:16:46,850
De hecho, por convención, cualquier programa que
escriben que está escrito en el lenguaje C

344
00:16:46,850 --> 00:16:49,739
debe tener asignado un nombre
punto c, por convención.

345
00:16:49,739 --> 00:16:53,030
Así que voy a nombrarlo hola.c, porque
Sólo quiero decir hola al mundo.

346
00:16:53,030 --> 00:16:54,820
Ahora voy a enfocar
y haga clic en Guardar.

347
00:16:54,820 --> 00:16:58,180
Y todo lo que tengo aquí ahora es una pestaña
en el que puedo empezar a escribir código.

348
00:16:58,180 --> 00:16:59,490
>> Esto no va a compilar.

349
00:16:59,490 --> 00:17:00,300
Esto no significa nada.

350
00:17:00,300 --> 00:17:02,750
Y por lo que incluso si Convertí
esto a ceros y unos,

351
00:17:02,750 --> 00:17:05,390
la CPU va a tener ningún
idea de lo que está pasando alrededor.

352
00:17:05,390 --> 00:17:14,170
Pero si escribo líneas que coinciden
con ser conventions-- C de C,

353
00:17:14,170 --> 00:17:20,150
de nuevo, esta language-- con una sintaxis como
esto, printf hola mundo-- y no tengo

354
00:17:20,150 --> 00:17:22,210
ha sentido cómoda con
hacer esto con el tiempo.

355
00:17:22,210 --> 00:17:24,510
Así que no creo que hice
los errores tipográficos.

356
00:17:24,510 --> 00:17:27,910
>> Pero, invariablemente, el primer
vez que lo haga, lo hará.

357
00:17:27,910 --> 00:17:31,090
Y lo que estoy a punto de hacer podría muy
así no funcionar para usted la primera vez.

358
00:17:31,090 --> 00:17:33,610
Y eso es perfectamente bien,
porque en este momento se

359
00:17:33,610 --> 00:17:37,662
sólo podría ver una gran cantidad de novedad,
pero con el tiempo una vez que se familiarice

360
00:17:37,662 --> 00:17:39,870
con este entorno, y
este lenguaje, y otros,

361
00:17:39,870 --> 00:17:42,370
usted comenzará a ver las cosas que
son correctas o incorrectas.

362
00:17:42,370 --> 00:17:44,369
>> Y esto es lo que el
compañeros de enseñanza y curso

363
00:17:44,369 --> 00:17:48,780
asistentes se ponen tan bueno en el transcurso del tiempo, se
la detección de errores o fallos en su código.

364
00:17:48,780 --> 00:17:52,110
Pero sostengo que hay
hay errores en el código.

365
00:17:52,110 --> 00:17:53,990
Así que ahora quiero para ejecutar este programa.

366
00:17:53,990 --> 00:17:57,440
>> Ahora, en mi propio PC o Mac, estoy en
el hábito de hacer doble clic en los iconos

367
00:17:57,440 --> 00:17:59,350
cuando quiero ejecutar algún programa.

368
00:17:59,350 --> 00:18:01,080
Pero eso no es el modelo aquí.

369
00:18:01,080 --> 00:18:04,570
En este entorno, que es CS50 IDE.

370
00:18:04,570 --> 00:18:07,192
Estamos utilizando un operativo
sistema llamado Linux.

371
00:18:07,192 --> 00:18:09,900
Linux es una reminiscencia de otro
sistema operativo, conocido generalmente

372
00:18:09,900 --> 00:18:10,850
como Unix.

373
00:18:10,850 --> 00:18:16,340
Y Linux es especialmente conocido por
que tiene una línea de comandos para el Medio Ambiente, la CLI.

374
00:18:16,340 --> 00:18:20,070
Ahora, estamos utilizando una específica
distribución de Linux llamada Ubuntu.

375
00:18:20,070 --> 00:18:22,770
Y Ubuntu es simplemente una
cierta versión de Linux.

376
00:18:22,770 --> 00:18:27,900
>> Pero de éstos Linux en estos días hacen realidad
vienen con interfaces gráficas de usuario.

377
00:18:27,900 --> 00:18:30,360
Y la que nos ha tocado
se utiliza aquí está basado en web.

378
00:18:30,360 --> 00:18:32,735
Por lo que este podría ser incluso una
poco diferente de algo

379
00:18:32,735 --> 00:18:35,310
usted mismo puede ser que tenga
visto o correr en el pasado.

380
00:18:35,310 --> 00:18:37,910
>> Así que voy a seguir adelante
ahora y hacer lo siguiente.

381
00:18:37,910 --> 00:18:40,950
He guardado este archivo como hola.c.

382
00:18:40,950 --> 00:18:47,350
Voy a seguir adelante y
Tipo clanghello.c Así Clang

383
00:18:47,350 --> 00:18:49,850
para el lenguaje C es un compilador.

384
00:18:49,850 --> 00:18:51,952
Es pre-instalado en CS50 IDE.

385
00:18:51,952 --> 00:18:54,910
Y se puede descargar y absolutamente
instalarlo en su propio Mac o PC.

386
00:18:54,910 --> 00:18:57,910
>> Pero, de nuevo, no tendrías todos
la preconfiguración hecho para usted.

387
00:18:57,910 --> 00:19:00,940
Así que por ahora, sólo soy
va a ejecutar clanghello.c.

388
00:19:00,940 --> 00:19:03,240
Y ahora cuenta esta sintaxis
aquí con el tiempo se

389
00:19:03,240 --> 00:19:06,930
cuenta sólo significa que estoy en una
carpeta o directorio llamado espacio de trabajo.

390
00:19:06,930 --> 00:19:11,030
Esta muestra de dólar es simplemente convención
de sentido, escriba los comandos aquí.

391
00:19:11,030 --> 00:19:14,560
>> Es lo que se llama un símbolo, simplemente
por convención es signo de dólar.

392
00:19:14,560 --> 00:19:19,130
Y si sigo adelante ahora y haga clic
Introduzca, nada parece haber sucedido.

393
00:19:19,130 --> 00:19:20,930
Pero eso es realmente una buena cosa.

394
00:19:20,930 --> 00:19:23,650
Cuanto menos eso sucede en
su pantalla, es más probable

395
00:19:23,650 --> 00:19:26,710
el código es correcto,
al menos sintácticamente.

396
00:19:26,710 --> 00:19:29,120
>> Así que si quiero ejecutar este
programa, ¿qué hago?

397
00:19:29,120 --> 00:19:33,770
Pues bien, resulta que la
nombre predeterminado por convención

398
00:19:33,770 --> 00:19:38,854
para los programas cuando no se especifica una
nombre para su programa es sólo a.out.

399
00:19:38,854 --> 00:19:41,270
Y esta sintaxis también, podrás
familiarizarse con poco tiempo.

400
00:19:41,270 --> 00:19:47,500
>> Dot slash sólo significa, bueno, CS50
IDE, ejecute un programa llamado a.out

401
00:19:47,500 --> 00:19:49,400
eso es dentro de mi directorio actual.

402
00:19:49,400 --> 00:19:51,520
Ese punto se refiere al directorio actual.

403
00:19:51,520 --> 00:19:55,040
Y vamos a ver qué otras secuencias
de caracteres significa antes de tiempo.

404
00:19:55,040 --> 00:19:58,430
>> Así que aquí vamos, Enter, hola mundo.

405
00:19:58,430 --> 00:20:00,080
Y se dará cuenta, que lo que ha pasado?

406
00:20:00,080 --> 00:20:01,580
No sólo se imprime hola mundo.

407
00:20:01,580 --> 00:20:05,990
También se trasladó la
cursor a la siguiente línea.

408
00:20:05,990 --> 00:20:07,160
>> Y por qué fue eso?

409
00:20:07,160 --> 00:20:12,400
¿Cuál era el código que escribimos antes
que aseguró que lo haría el cursor

410
00:20:12,400 --> 00:20:14,882
ir en la línea siguiente?

411
00:20:14,882 --> 00:20:16,840
Lo más gracioso de una
equipo es que sólo va

412
00:20:16,840 --> 00:20:18,570
hacer literalmente lo que usted le diga que hacer.

413
00:20:18,570 --> 00:20:26,050
>> Así que si usted le dice a printf hola,
coma, espacio, mundo, cerca de la cita,

414
00:20:26,050 --> 00:20:29,090
Es, literalmente, sólo se va
para imprimir los caracteres.

415
00:20:29,090 --> 00:20:31,980
Pero tenía este carácter especial
al final, el recuerdo, la barra invertida n.

416
00:20:31,980 --> 00:20:34,230
Y eso es lo que asegura
que el carácter se

417
00:20:34,230 --> 00:20:36,570
a la siguiente línea de la pantalla.

418
00:20:36,570 --> 00:20:38,097
>> De hecho, me dejó ir y hacer esto.

419
00:20:38,097 --> 00:20:39,430
Déjame ir por delante y borrar esto.

420
00:20:39,430 --> 00:20:41,180
Ahora, observe que la
la parte superior de la pantalla hay

421
00:20:41,180 --> 00:20:42,890
un poco de luz roja en
la pestaña que indica,

422
00:20:42,890 --> 00:20:45,047
bueno, no se ha guardado el archivo.

423
00:20:45,047 --> 00:20:47,880
Así que voy a seguir adelante con el control
S o S comando, guardar el archivo.

424
00:20:47,880 --> 00:20:51,130
Ahora goes-- fue a dar un color verde moment--.

425
00:20:51,130 --> 00:20:53,760
Y ahora es hora de volver a
simplemente ser un icono de cierre.

426
00:20:53,760 --> 00:21:01,860
>> Si ahora corro clanghello.c de nuevo,
Introducir, barra de puntos, a.out, Enter,

427
00:21:01,860 --> 00:21:04,110
verá que todavía funcionaba.

428
00:21:04,110 --> 00:21:06,020
Pero es sin duda un poco buggy.

429
00:21:06,020 --> 00:21:08,714
En este momento, mi espacio de trabajo prompt--,
y después de que el signo de dólar,

430
00:21:08,714 --> 00:21:10,880
y luego mi prompt-- real
es todo en la misma línea.

431
00:21:10,880 --> 00:21:14,540
Así que esto ciertamente un error estético,
aunque en realidad no es un error lógico.

432
00:21:14,540 --> 00:21:16,250
>> Así que voy a deshacer lo que acabo de hacer.

433
00:21:16,250 --> 00:21:18,560
Voy a volver a ejecutar a.out.

434
00:21:18,560 --> 00:21:22,710
Aviso He añadido el
volver carácter de nueva línea.

435
00:21:22,710 --> 00:21:24,280
He guardado el archivo.

436
00:21:24,280 --> 00:21:31,630
>> Así que voy a volver a ejecutar a.out, y-
maldita sea, un error, un error que significa error.

437
00:21:31,630 --> 00:21:35,020
Por lo que el fallo es que a pesar de que
He añadido la barra invertida n allí,

438
00:21:35,020 --> 00:21:41,180
re-guardado, volvieron a realizar el programa,
el comportamiento fue el mismo.

439
00:21:41,180 --> 00:21:42,640
¿Por qué sería?

440
00:21:42,640 --> 00:21:43,910
>> Me falta un paso, ¿verdad?

441
00:21:43,910 --> 00:21:47,620
Ese paso clave anterior era que tienes
a-- cuando cambie su código fuente,

442
00:21:47,620 --> 00:21:49,610
Resulta que también funcionan
a través del compilador

443
00:21:49,610 --> 00:21:51,102
de nuevo para que pueda obtener nuevo código máquina.

444
00:21:51,102 --> 00:21:52,810
Y el código máquina,
los ceros y unos,

445
00:21:52,810 --> 00:21:56,260
van a ser casi idénticos, pero
no perfectamente así, porque necesitamos,

446
00:21:56,260 --> 00:21:57,510
por supuesto, que la nueva línea.

447
00:21:57,510 --> 00:22:02,640
>> Así que para solucionar este problema, voy a necesitar
volver a ejecutar clanghello.c, introduzca, punto

448
00:22:02,640 --> 00:22:03,800
raya vertical, a.out.

449
00:22:03,800 --> 00:22:08,402
Y ahora, hola mundo está de vuelta
a donde yo esperaba que fuera.

450
00:22:08,402 --> 00:22:09,610
Así que esto es todo fino y bueno.

451
00:22:09,610 --> 00:22:13,150
Pero a.out es un nombre bastante estúpido para una
programa, a pesar de que pasa a ser,

452
00:22:13,150 --> 00:22:16,530
por razones históricas, la
default-- significa salidas de montaje.

453
00:22:16,530 --> 00:22:20,780
>> Pero déjame ir por delante aquí
y hacer esto de manera diferente.

454
00:22:20,780 --> 00:22:24,760
Quiero que mi programa hola mundo
para realmente ser llamado hola.

455
00:22:24,760 --> 00:22:28,320
Así que si se tratara de un icono en mi
escritorio, no se a.out.

456
00:22:28,320 --> 00:22:29,730
Se llamaría hola.

457
00:22:29,730 --> 00:22:33,660
>> Así que para hacer esto, resulta
Clang que, al igual que muchos programas,

458
00:22:33,660 --> 00:22:37,980
apoya los argumentos de línea de comandos,
o banderas, o interruptores,

459
00:22:37,980 --> 00:22:39,600
que simplemente influir en su comportamiento.

460
00:22:39,600 --> 00:22:45,160
En concreto, Sonido metálico soporta un tablero o
bandera, que a su vez lleva a una segunda palabra.

461
00:22:45,160 --> 00:22:48,190
En este caso, me voy de manera arbitraria,
pero razonablemente, lo llaman hola.

462
00:22:48,190 --> 00:22:50,710
Pero podría llamar de cualquier
Quiero, excepto a.out, que

463
00:22:50,710 --> 00:22:52,390
sería más bien el punto.

464
00:22:52,390 --> 00:22:55,640
>> Y a continuación, sólo tiene que especificar el nombre
del archivo sí quiero compilar.

465
00:22:55,640 --> 00:22:59,190
Así que ahora a pesar de que al principio
del comando todavía tengo Clang,

466
00:22:59,190 --> 00:23:01,410
al final del comando
Todavía tengo el nombre del archivo,

467
00:23:01,410 --> 00:23:05,520
Ahora tengo estos línea de comandos
argumentos, estas banderas que están diciendo,

468
00:23:05,520 --> 00:23:11,180
Oh, por cierto, la producción-o, un archivo
hola llamada, no el a.out por defecto.

469
00:23:11,180 --> 00:23:13,810
>> Así que si pulsa enter ahora, nada
parece haber ocurrido.

470
00:23:13,810 --> 00:23:17,900
Y, sin embargo, ahora que puedo hacer barra de puntos hola.

471
00:23:17,900 --> 00:23:19,089
Así que es el mismo programa.

472
00:23:19,089 --> 00:23:21,380
Los ceros y unos son
idénticos al final del día.

473
00:23:21,380 --> 00:23:24,210
>> Pero están en dos
a.out diferente archivos--,

474
00:23:24,210 --> 00:23:26,490
que es la primera versión
y justo llamado tontamente,

475
00:23:26,490 --> 00:23:30,250
y ahora hola, lo que es una gran parte
nombre más convincente para un programa.

476
00:23:30,250 --> 00:23:33,195
Pero, honestamente, nunca estoy
va a recordar esto de nuevo,

477
00:23:33,195 --> 00:23:34,070
y otra vez, y otra vez.

478
00:23:34,070 --> 00:23:36,411
Y, en realidad, mientras escribimos
programas más complicados,

479
00:23:36,411 --> 00:23:38,160
los comandos que usted está
va a tener que escribir

480
00:23:38,160 --> 00:23:40,920
se va a poner aún
más complicado aún.

481
00:23:40,920 --> 00:23:41,940
>> Y por lo que no se preocupe.

482
00:23:41,940 --> 00:23:46,220
Resulta que los humanos antes
Nos hemos dado cuenta de que ellos también

483
00:23:46,220 --> 00:23:47,530
tenido este mismo problema.

484
00:23:47,530 --> 00:23:50,900
También ellos no disfrutaban de tener que
escriba los comandos, bastante largos arcanos,

485
00:23:50,900 --> 00:23:52,200
y mucho menos recordar.

486
00:23:52,200 --> 00:23:56,070
Y así los seres humanos que se nos han hecho
otros programas que hacen que sea más fácil

487
00:23:56,070 --> 00:23:57,670
para compilar el software.

488
00:23:57,670 --> 00:24:01,609
>> Y, de hecho, uno de estos
programa se llama Make.

489
00:24:01,609 --> 00:24:03,150
Así que voy a seguir adelante y hacerlo.

490
00:24:03,150 --> 00:24:05,691
Voy a deshacer todo lo
acaba de hacer de la siguiente manera.

491
00:24:05,691 --> 00:24:07,690
Permítanme LS tipo.

492
00:24:07,690 --> 00:24:10,980
Y se dará cuenta de tres cosas-
a.out, y una estrella, hola

493
00:24:10,980 --> 00:24:12,810
y una estrella, y hola.c.

494
00:24:12,810 --> 00:24:14,730
Con suerte, esto debería
ser un poco intuitivo,

495
00:24:14,730 --> 00:24:18,220
la medida en que anteriormente no había
nada en este espacio de trabajo.

496
00:24:18,220 --> 00:24:21,240
No había nada que yo tenía
creado hasta que empezamos a clase.

497
00:24:21,240 --> 00:24:22,840
>> Y creé hola.c.

498
00:24:22,840 --> 00:24:24,544
entonces yo compilé, y lo llamó a.out.

499
00:24:24,544 --> 00:24:27,460
Y luego he recopilado de nuevo ligeramente
de manera diferente y lo llamó hola.

500
00:24:27,460 --> 00:24:32,830
Así que tengo tres archivos en este directorio,
En esta carpeta se llama espacio de trabajo.

501
00:24:32,830 --> 00:24:35,005
Ahora, puedo ver que a su vez
si Alejar realidad.

502
00:24:35,005 --> 00:24:37,530
>> Si Alejar aquí y
mira ese superior derecha

503
00:24:37,530 --> 00:24:39,940
esquina, como se había prometido la izquierda
lado de la pantalla

504
00:24:39,940 --> 00:24:42,990
siempre va a mostrar
lo que está en su cuenta, lo que es

505
00:24:42,990 --> 00:24:44,790
dentro del IDE CS50.

506
00:24:44,790 --> 00:24:46,680
Y hay tres archivos allí.

507
00:24:46,680 --> 00:24:49,070
>> Así que quiero para deshacerse de a.out y hola.

508
00:24:49,070 --> 00:24:51,275
Y como puede ser que
imaginar intuitivamente, se

509
00:24:51,275 --> 00:24:53,400
podría tipo de control de clic
o haga clic derecho sobre esta.

510
00:24:53,400 --> 00:24:54,590
Y este pequeño menú emergente.

511
00:24:54,590 --> 00:24:57,170
Puede descargar el archivo, ejecute
que, vista previa, actualizar, cambiar el nombre,

512
00:24:57,170 --> 00:24:57,700
o lo que no.

513
00:24:57,700 --> 00:25:00,260
>> Y yo sólo podía eliminar,
y se iría.

514
00:25:00,260 --> 00:25:05,260
Pero vamos a hacer las cosas con un comando
línea de momento, de manera que se sienta cómodo

515
00:25:05,260 --> 00:25:07,010
con esto, y hacer lo siguiente.

516
00:25:07,010 --> 00:25:12,345
Voy a seguir adelante y eliminar
a.out escribiendo literalmente rma.out.

517
00:25:12,345 --> 00:25:14,890
Resulta que, el comando de
la eliminación o eliminación de algo,

518
00:25:14,890 --> 00:25:16,280
no elimina ni borra.

519
00:25:16,280 --> 00:25:21,260
>> Es más sucintamente RM, sólo para ahorrar
que algunas combinaciones de teclas y pulse la tecla Enter.

520
00:25:21,260 --> 00:25:24,707
Ahora vamos a ser algo
crípticamente eliminar a.out regular.

521
00:25:24,707 --> 00:25:27,040
Realmente no sé lo que es una
archivo irregular sería aún.

522
00:25:27,040 --> 00:25:28,660
Pero sí quiero quitarlo.

523
00:25:28,660 --> 00:25:30,150
>> Así que voy a escribir y para sí.

524
00:25:30,150 --> 00:25:31,940
O podría escribir un vistazo, y pulsa Enter.

525
00:25:31,940 --> 00:25:33,440
Y, de nuevo, parece que nada sucede.

526
00:25:33,440 --> 00:25:35,840
Pero eso es, en general, una buena cosa.

527
00:25:35,840 --> 00:25:40,490
>> Si escribo LS este tiempo,
¿qué debo ver?

528
00:25:40,490 --> 00:25:44,930
Con suerte, apenas hola y hola.c.

529
00:25:44,930 --> 00:25:47,286
Ahora, como un aparte, se le
cuenta de esta estrella, asterisco,

530
00:25:47,286 --> 00:25:48,660
eso es al final de mis programas.

531
00:25:48,660 --> 00:25:50,201
Y también están mostrando en color verde.

532
00:25:50,201 --> 00:25:53,970
Eso es sólo el camino del CS50 IDE
de que cluing en el hecho

533
00:25:53,970 --> 00:25:55,280
que ese no es el código fuente.

534
00:25:55,280 --> 00:25:58,880
Eso es un ejecutable, un ejecutable
programa que en realidad se puede ejecutar

535
00:25:58,880 --> 00:26:01,020
haciendo barra de puntos, y luego su nombre.

536
00:26:01,020 --> 00:26:05,860
>> Ahora, déjame ir por delante y quitar
esto, rm hola, Introducir, eliminar regulares

537
00:26:05,860 --> 00:26:08,010
presentar hola, sí.

538
00:26:08,010 --> 00:26:11,180
Y ahora si escribo LS,
estamos de vuelta a hola.c.

539
00:26:11,180 --> 00:26:13,917
Trate de no eliminar su
código fuente real.

540
00:26:13,917 --> 00:26:16,250
A pesar de que existen características
incorporado en IDE CS50 donde

541
00:26:16,250 --> 00:26:19,870
usted puede ir a través de su historial de revisiones
y retroceder en el tiempo si accidentalmente

542
00:26:19,870 --> 00:26:23,660
borrar algo, hacer tener en cuenta
según estas indicaciones sí o no,

543
00:26:23,660 --> 00:26:25,381
de lo que realmente quiere hacer.

544
00:26:25,381 --> 00:26:27,380
Y si me voy hasta la cima
esquina izquierda mano aquí,

545
00:26:27,380 --> 00:26:30,696
todo lo que queda es hola.c.

546
00:26:30,696 --> 00:26:32,570
Así que hay racimos de
otros comandos que se

547
00:26:32,570 --> 00:26:37,550
puede ejecutar en el mundo de Linux,
uno de los cuales es, de nuevo, Haz.

548
00:26:37,550 --> 00:26:40,180
Y vamos a hacer
mi programa ahora de la siguiente manera.

549
00:26:40,180 --> 00:26:43,270
>> En vez de hacer ruido metálico,
en lugar de hacer ruido metálico-o,

550
00:26:43,270 --> 00:26:45,860
Voy a simplemente
literalmente, tipo, marca hola.

551
00:26:45,860 --> 00:26:49,630
Y ahora noto, yo soy
No escribiendo make hola.c.

552
00:26:49,630 --> 00:26:50,910
Estoy escribiendo hacen hola.

553
00:26:50,910 --> 00:26:54,840
>> Y este programa Haga ese
viene con el IDE CS50, y mucho más

554
00:26:54,840 --> 00:26:57,090
generalmente con Linux,
es un programa que es

555
00:26:57,090 --> 00:26:59,120
va a hacer un programa llamado Hola.

556
00:26:59,120 --> 00:27:03,680
Y que va a suponer, por convención,
que si este programa se puede hacer,

557
00:27:03,680 --> 00:27:09,030
que va a ser a partir de una fuente
archivo de código que terminan en c punto, hola.c.

558
00:27:09,030 --> 00:27:12,210
>> Así que si golpeo Entra ahora, el aviso de que
el comando que se ejecuta

559
00:27:12,210 --> 00:27:14,340
es incluso más largo
antes de que antes.

560
00:27:14,340 --> 00:27:16,670
Y eso es porque hemos
IDE CS50 preconfigurado para tener

561
00:27:16,670 --> 00:27:19,878
algunas características adicionales incorporadas en ese
no necesitamos por el momento, pero pronto lo hará.

562
00:27:19,878 --> 00:27:23,470
Pero la clave para darse cuenta
es que ahora tengo un programa Hola.

563
00:27:23,470 --> 00:27:27,080
>> Si escribo LS de nuevo,
tener un programa de hola.

564
00:27:27,080 --> 00:27:32,070
Y puedo ejecutarlo con
slash dot a.out, no,

565
00:27:32,070 --> 00:27:35,590
porque el objetivo de este
ejercicio fue punto hola barra.

566
00:27:35,590 --> 00:27:38,089
Y ahora tengo mi programa hola mundo.

567
00:27:38,089 --> 00:27:39,880
Así se mueve hacia adelante,
estamos casi siempre solo

568
00:27:39,880 --> 00:27:42,088
va a compilar nuestros programas
utilizando el comando Crear.

569
00:27:42,088 --> 00:27:45,300
Y luego vamos a ejecutarlas
punto slash, y el nombre del programa.

570
00:27:45,300 --> 00:27:49,610
Pero darse cuenta de lo que hacen está haciendo para
usted, es que no es en sí un compilador.

571
00:27:49,610 --> 00:27:53,310
Es sólo un programa de conveniencia
que sabe cómo activar un compilador

572
00:27:53,310 --> 00:27:56,470
para funcionar de modo que usted mismo puede utilizarlo.

573
00:27:56,470 --> 00:28:00,220
>> Lo que existen otros comandos en
Linux, ya su vez el IDE CS50?

574
00:28:00,220 --> 00:28:03,107
Pronto veremos que hay una
comando CD, Cambiar directorio.

575
00:28:03,107 --> 00:28:05,190
Esto le permite a
la interfaz de línea de comandos

576
00:28:05,190 --> 00:28:07,610
para seguir adelante y hacia atrás,
y abrir diferentes carpetas

577
00:28:07,610 --> 00:28:08,860
sin necesidad de utilizar el ratón.

578
00:28:08,860 --> 00:28:12,470
>> LS que vimos, que significa lista
los archivos en el directorio actual.

579
00:28:12,470 --> 00:28:14,650
Hacer Dir, puede
probablemente empezar a deducir

580
00:28:14,650 --> 00:28:18,150
lo que significan ahora-- hacer directorio,
Si desea crear una carpeta.

581
00:28:18,150 --> 00:28:21,270
RM de Remove, RM Dir
eliminar directory-- y éstos,

582
00:28:21,270 --> 00:28:24,160
de nuevo, son la línea de comandos
equivalentes de lo que

583
00:28:24,160 --> 00:28:26,945
podría hacer en CS50 IDE con el ratón.

584
00:28:26,945 --> 00:28:28,820
Sin embargo, pronto se encontrará
que a veces es sólo

585
00:28:28,820 --> 00:28:30,610
mucho más rápido que hacer
cosas con un teclado,

586
00:28:30,610 --> 00:28:33,690
y en última instancia mucho más potente.

587
00:28:33,690 --> 00:28:36,440
>> Pero es difícil argumentar que
todo lo que hemos estado haciendo hasta ahora

588
00:28:36,440 --> 00:28:39,990
es todo lo que poderosa, cuando todo
que hemos estado diciendo es, hola mundo.

589
00:28:39,990 --> 00:28:43,740
Y, de hecho, la hardcoded
palabras hola mundo en mi programa.

590
00:28:43,740 --> 00:28:45,530
No hay dinamismo aún.

591
00:28:45,530 --> 00:28:49,320
Scratch fue un orden de magnitud
más interesante la semana pasada.

592
00:28:49,320 --> 00:28:51,220
>> Y así vamos a llegar allí.

593
00:28:51,220 --> 00:28:55,310
Vamos a dar un paso hacia la que por
forma de algunas de estas funciones.

594
00:28:55,310 --> 00:28:59,470
Así que no sólo vienen con C printf,
y racimos de otras funciones

595
00:28:59,470 --> 00:29:01,850
algunos de los cuales ya veremos
con el tiempo, no lo hace

596
00:29:01,850 --> 00:29:05,760
que sea tan fácil a la derecha
de la puerta para conseguir la entrada del usuario.

597
00:29:05,760 --> 00:29:08,140
>> De hecho, una de las debilidades
de lenguajes como C,

598
00:29:08,140 --> 00:29:10,140
e incluso Java y, sin embargo
otros, es que no lo hace

599
00:29:10,140 --> 00:29:15,860
hacer más fácil para obtener sólo las cosas como
números enteros de usuarios, o cadenas, palabras,

600
00:29:15,860 --> 00:29:19,970
y frases, dejar que las cosas por sí solos como
valores de puntos o números reales flotantes

601
00:29:19,970 --> 00:29:23,240
con puntos decimales, y realmente
números largos, como pronto veremos.

602
00:29:23,240 --> 00:29:27,000
Por lo que esta lista de funciones aquí, éstos
son como otras piezas del rompecabezas de Scratch

603
00:29:27,000 --> 00:29:31,090
que hemos pre-instalado en CS50
IDE que vamos a utilizar durante unas pocas semanas

604
00:29:31,090 --> 00:29:34,010
como ruedas de entrenamiento de las clases, y
finalmente quitárselos, y buscar

605
00:29:34,010 --> 00:29:37,210
debajo del capó, tal vez, por lo
cómo se implementan estas cosas.

606
00:29:37,210 --> 00:29:40,460
>> Pero para hacer esto, vamos a
En realidad escribir un programa.

607
00:29:40,460 --> 00:29:41,770
Déjame ir adelante ahora.

608
00:29:41,770 --> 00:29:44,750
Y yo voy a crear un nuevo
archivo haciendo clic en este pequeño plus,

609
00:29:44,750 --> 00:29:45,970
y haciendo clic en Nuevo archivo.

610
00:29:45,970 --> 00:29:49,250
>> Voy a guardar esta próxima
uno como, digamos, string.c,

611
00:29:49,250 --> 00:29:50,750
porque quiero jugar con cuerdas.

612
00:29:50,750 --> 00:29:53,990
Y la cadena en C es sólo
una secuencia de caracteres.

613
00:29:53,990 --> 00:29:56,090
Así que ahora vamos a seguir adelante
y hacer lo siguiente.

614
00:29:56,090 --> 00:30:01,204
>> Incluir estándar y IO.h--
Resulta que IO estándar,

615
00:30:01,204 --> 00:30:03,360
IO sólo significa de entrada y de salida.

616
00:30:03,360 --> 00:30:05,920
Así resulta que
esta línea aquí es lo

617
00:30:05,920 --> 00:30:08,140
son los EE.UU. vecina de usar printf.

618
00:30:08,140 --> 00:30:10,410
Printf, por supuesto, produce una salida.

619
00:30:10,410 --> 00:30:15,000
Así que con el fin de utilizar printf, resulta
a cabo usted tiene que tener esta línea de código

620
00:30:15,000 --> 00:30:16,040
en la parte superior de su archivo.

621
00:30:16,040 --> 00:30:18,456
>> Y vamos a volver a lo
que realmente significa en poco tiempo.

622
00:30:18,456 --> 00:30:20,400
Resulta que en
cualquier programa C que escribo,

623
00:30:20,400 --> 00:30:23,640
Tengo que empezar con
código que se parece a esto.

624
00:30:23,640 --> 00:30:26,860
Y usted notará CS50 IDE, y
otra de desarrollo integrado

625
00:30:26,860 --> 00:30:30,050
ambientes como ella,
Vamos a tratar de la mejor

626
00:30:30,050 --> 00:30:31,780
que pueden terminar su pensamiento.

627
00:30:31,780 --> 00:30:35,930
De hecho, hace un momento, si yo deshacer
lo que he hecho, me golpeó Intro.

628
00:30:35,930 --> 00:30:39,160
>> entonces me golpeó rizado abierto
corsé, pulse la tecla Enter de nuevo.

629
00:30:39,160 --> 00:30:40,430
Y se terminó mi pensamiento.

630
00:30:40,430 --> 00:30:45,140
Me dio una nueva línea, sangría no menos
por razones de estilo agradable ya veremos.

631
00:30:45,140 --> 00:30:48,559
Y entonces se me dio de forma automática
que corchete para terminar mi pensamiento.

632
00:30:48,559 --> 00:30:50,600
Ahora bien, no siempre
supongo que lo que quiere hacer.

633
00:30:50,600 --> 00:30:53,620
Sin embargo, en gran parte, lo hace
que ahorrar un poco las pulsaciones de teclado.

634
00:30:53,620 --> 00:30:59,560
Así que hace un momento, nos encontramos con este program--
hola, mundo, y luego compilado,

635
00:30:59,560 --> 00:31:00,460
y luego corrió la misma.

636
00:31:00,460 --> 00:31:01,867
Pero no hay dinamismo aquí.

637
00:31:01,867 --> 00:31:03,700
Lo que si queríamos
¿hacer algo diferente?

638
00:31:03,700 --> 00:31:07,630
Bueno, ¿y si yo quería en realidad
obtener una cadena del usuario?

639
00:31:07,630 --> 00:31:11,250
Voy a utilizar una pieza del rompecabezas
llama exactamente eso-- conseguir cadena.

640
00:31:11,250 --> 00:31:15,860
>> Resulta que en C que cuando usted no quiere
para proporcionar información a una pieza del rompecabezas,

641
00:31:15,860 --> 00:31:19,360
o más correctamente a una función,
literalmente sólo hacer paréntesis abierto,

642
00:31:19,360 --> 00:31:20,430
paréntesis de cierre.

643
00:31:20,430 --> 00:31:25,540
Así que es como si hubiera
ninguna caja blanca para escribir en.

644
00:31:25,540 --> 00:31:27,720
El bloque decir antes
tenía una pequeña caja blanca.

645
00:31:27,720 --> 00:31:29,660
No tenemos esa caja blanca ahora.

646
00:31:29,660 --> 00:31:33,310
>> Pero cuando llamo cadena GET, me
querer poner el resultado en alguna parte.

647
00:31:33,310 --> 00:31:37,680
Así que un paradigma muy común en C es
llamar a una función, como la cadena de llegar aquí,

648
00:31:37,680 --> 00:31:41,070
y luego almacenar su valor de retorno.

649
00:31:41,070 --> 00:31:44,450
Es el resultado de su
esfuerzo en algo.

650
00:31:44,450 --> 00:31:47,630
>> Y lo que es lo
construir en la programación,

651
00:31:47,630 --> 00:31:53,450
ya sea en Scratch o C ahora, que nosotros
se puede utilizar para almacenar en realidad algo?

652
00:31:53,450 --> 00:31:55,990
Llamó una variable, ¿verdad?

653
00:31:55,990 --> 00:32:00,320
Y en Scratch, realmente no lo
cuidar lo que estaba pasando en las variables.

654
00:32:00,320 --> 00:32:02,170
>> Pero en este caso, que realmente hacemos.

655
00:32:02,170 --> 00:32:03,719
Voy a decir cadena.

656
00:32:03,719 --> 00:32:05,510
Y entonces yo podría llamar
esto lo que quiera.

657
00:32:05,510 --> 00:32:08,340
Voy a llamarlo
nombre, consigue llegar cadena.

658
00:32:08,340 --> 00:32:10,250
>> Y ahora, incluso si eres
un poco nuevo en esto,

659
00:32:10,250 --> 00:32:11,984
Noto que me falta algún detalle.

660
00:32:11,984 --> 00:32:13,150
Me estoy olvidando de un punto y coma.

661
00:32:13,150 --> 00:32:14,400
Tengo que terminar este pensamiento.

662
00:32:14,400 --> 00:32:17,480
Así que voy a mover el cursor,
y pulsa punto y coma allí.

663
00:32:17,480 --> 00:32:19,130
Y lo que he acabo de hacer?

664
00:32:19,130 --> 00:32:21,440
En esta línea de código,
el número 5 en el momento,

665
00:32:21,440 --> 00:32:23,799
Voy a llamar a cadena GET sin entradas.

666
00:32:23,799 --> 00:32:26,090
Así que no hay poco de blanco
caja como el bloque tiene Guardar.

667
00:32:26,090 --> 00:32:28,590
>> Sólo estoy diciendo, hey,
equipo, tráeme una cadena.

668
00:32:28,590 --> 00:32:31,390
El signo igual no es realmente
un signo igual, per se.

669
00:32:31,390 --> 00:32:33,790
Es la asignación
operador, lo que significa,

670
00:32:33,790 --> 00:32:37,860
Hey, ordenador, mueva el valor
desde la derecha hacia la izquierda.

671
00:32:37,860 --> 00:32:40,480
Y en la izquierda, tengo el siguiente.

672
00:32:40,480 --> 00:32:43,580
>> Hey, ordenador, dame un string--
una secuencia de caracteres.

673
00:32:43,580 --> 00:32:45,637
Y llamar a esa cadena Nombre.

674
00:32:45,637 --> 00:32:47,220
Y no tienen ni siquiera llamarlo Nombre.

675
00:32:47,220 --> 00:32:49,970
>> Podría llamarlo, convencionalmente,
algo así como S,

676
00:32:49,970 --> 00:32:52,900
al igual que hemos utilizado para i
llamar a la variable i.

677
00:32:52,900 --> 00:32:54,829
Pero ahora tengo que hacer algo con él.

678
00:32:54,829 --> 00:32:57,370
Sería muy estúpido para
tratar de compilar el código, se ejecuta

679
00:32:57,370 --> 00:32:59,410
este programa, aunque
Estoy recibiendo una cadena,

680
00:32:59,410 --> 00:33:01,580
porque todavía es sólo
va a decir hola mundo.

681
00:33:01,580 --> 00:33:06,140
>> Pero ¿qué pasa si quiero cambiar esto.

682
00:33:06,140 --> 00:33:07,940
¿Por qué no puedo hacer esto?

683
00:33:07,940 --> 00:33:11,632
Porcentaje s, s comas.

684
00:33:11,632 --> 00:33:13,090
Y esto es un poco críptico todavía.

685
00:33:13,090 --> 00:33:15,560
>> Así que déjame hacer mi variables más clara.

686
00:33:15,560 --> 00:33:17,510
Permítanme mencionar esta variable Nombre.

687
00:33:17,510 --> 00:33:20,230
Y veamos si no podemos molestar
aparte de lo que está pasando aquí.

688
00:33:20,230 --> 00:33:22,770
>> Así que en la línea cinco, estoy recibiendo una cadena.

689
00:33:22,770 --> 00:33:25,620
Y yo estoy almacenando esa cadena,
cualquiera que sea el usuario ha escrito en

690
00:33:25,620 --> 00:33:28,430
en su teclado,
en una variable llamada Nombre.

691
00:33:28,430 --> 00:33:30,590
Y resulta que
printf hace no sólo

692
00:33:30,590 --> 00:33:34,220
tomar un argumento de doble
citas, una entrada entre comillas dobles.

693
00:33:34,220 --> 00:33:39,100
>> Puede tomar dos, o tres, o más, tal
que la segunda, o tercera, o cuarta,

694
00:33:39,100 --> 00:33:42,320
son todos los nombres de las variables,
o valores que es propio,

695
00:33:42,320 --> 00:33:48,610
que desea conectar a,
dinámicamente, esa cadena entre comillas.

696
00:33:48,610 --> 00:33:52,110
En otras palabras, ¿qué
sería malo en esto?

697
00:33:52,110 --> 00:33:57,920
Si acabo de decir hola nombre, la barra invertida
n, salvado mi archivo, compilado mi código,

698
00:33:57,920 --> 00:34:01,660
y corrió esto, ¿qué pasaría?

699
00:34:01,660 --> 00:34:05,139
>> Es sólo va a decir, hola
nombre, literalmente N-A-M-E,

700
00:34:05,139 --> 00:34:07,900
que es una especie de estúpida porque
no es diferente del mundo.

701
00:34:07,900 --> 00:34:10,400
Así que cualquier cosa es entre comillas
lo que, literalmente, se imprime.

702
00:34:10,400 --> 00:34:12,520
Así que si quiero tener
un marcador de posición allí,

703
00:34:12,520 --> 00:34:14,422
En realidad necesito usar
una sintaxis especial.

704
00:34:14,422 --> 00:34:17,380
Y resulta que si usted lee el
documentación de la función printf,

705
00:34:17,380 --> 00:34:21,320
se le dirá que
si se utiliza por ciento s,

706
00:34:21,320 --> 00:34:23,920
se puede sustituir un valor de la siguiente manera.

707
00:34:23,920 --> 00:34:27,190
>> Después de una coma después de que
comillas dobles, simplemente

708
00:34:27,190 --> 00:34:29,179
escribir el nombre de la
variable que se quiere

709
00:34:29,179 --> 00:34:33,790
para enchufar en ese formato
código, o especificador de formato,

710
00:34:33,790 --> 00:34:35,469
s por ciento para las cuerdas.

711
00:34:35,469 --> 00:34:39,190
Y ahora si me he salvado mi archivo,
Vuelvo a mi terminal.

712
00:34:39,190 --> 00:34:42,870
Y Tipo Marca de cuerdas,
porque, de nuevo, el nombre de este

713
00:34:42,870 --> 00:34:45,510
archivo que he elegido es string.c antes.

714
00:34:45,510 --> 00:34:48,510
>> Así que voy a decir Prefijo, introduzca.

715
00:34:48,510 --> 00:34:51,550
¡Oh Dios, mira a todos
los errores que hemos hecho ya.

716
00:34:51,550 --> 00:34:55,540
Y esto lo es--, esto es realmente
como un programa de línea de seis siete?

717
00:34:55,540 --> 00:34:57,790
Así que aquí es donde se puede muy
obtener rápidamente abrumadora.

718
00:34:57,790 --> 00:35:00,890
>> Esta ventana de terminal tiene
ahora sólo regurgitado

719
00:35:00,890 --> 00:35:03,230
un gran número de mensajes de error.

720
00:35:03,230 --> 00:35:07,560
Sin duda, no tengo más errores
mensajes de lo que tienen líneas de código.

721
00:35:07,560 --> 00:35:08,680
¿Entonces qué está pasando?

722
00:35:08,680 --> 00:35:10,920
>> Bueno, la mejor estrategia
que hacer en cualquier momento que

723
00:35:10,920 --> 00:35:13,710
no encontrarse con una abrumadora
lista de errores por el estilo,

724
00:35:13,710 --> 00:35:16,690
está desplazarse hacia atrás, mire para el comando
que acaba de ejecutar, que en mi caso

725
00:35:16,690 --> 00:35:18,020
es hacer cuerdas.

726
00:35:18,020 --> 00:35:21,630
Mira lo que hacen lo hizo, y eso es todo
Clang comando larga, no es gran cosa allí.

727
00:35:21,630 --> 00:35:22,950
>> Sin embargo, el rojo es malo.

728
00:35:22,950 --> 00:35:24,750
Verde está tratando de ser
gentil y servicial.

729
00:35:24,750 --> 00:35:26,140
Pero sigue siendo malo, en este caso.

730
00:35:26,140 --> 00:35:27,510
Pero ¿dónde está el mal?

731
00:35:27,510 --> 00:35:31,450
>> String.c, la línea cinco, de cinco caracteres.

732
00:35:31,450 --> 00:35:32,930
Así que esto es sólo convención común.

733
00:35:32,930 --> 00:35:36,060
significa algo de colon algo
número de línea y el número de caracteres.

734
00:35:36,060 --> 00:35:41,080
Error, no declarada de uso
cadena de identificador.

735
00:35:41,080 --> 00:35:42,900
Quiso decir estándar en?

736
00:35:42,900 --> 00:35:45,530
>> Así que, por desgracia, Clang
está tratando de ser útil.

737
00:35:45,530 --> 00:35:46,850
Pero es malo, en este caso.

738
00:35:46,850 --> 00:35:49,350
No, Clang, no era mi intención IO estándar.

739
00:35:49,350 --> 00:35:51,070
Quiero decir que en la línea uno, sí.

740
00:35:51,070 --> 00:35:53,420
>> Pero la línea cinco es este de aquí.

741
00:35:53,420 --> 00:35:57,040
Y Clang no lo hace
entender S-T-R-I-N-G.

742
00:35:57,040 --> 00:36:01,490
Es un identificador no declarado, una
palabra que simplemente nunca ha visto antes.

743
00:36:01,490 --> 00:36:05,730
Y eso es porque C, el lenguaje
estamos escribiendo código en este momento,

744
00:36:05,730 --> 00:36:08,070
no tiene variables denominadas cadenas.

745
00:36:08,070 --> 00:36:11,380
>> De lo contrario, por defecto, el soporte
algo que se llama una cadena.

746
00:36:11,380 --> 00:36:16,750
Eso es un pedazo de CS50
jerga, pero muy convencional.

747
00:36:16,750 --> 00:36:18,600
Pero puedo solucionar este problema de la siguiente manera.

748
00:36:18,600 --> 00:36:22,090
>> Si añado una línea de código
a la parte superior de este programa,

749
00:36:22,090 --> 00:36:27,890
incluir CS50.h, que es otro archivo
en algún lugar dentro del CS50 IDE, en alguna parte

750
00:36:27,890 --> 00:36:30,820
en el disco duro, por así decirlo,
del sistema operativo Ubuntu

751
00:36:30,820 --> 00:36:33,590
que estoy corriendo, que
es el archivo que está

752
00:36:33,590 --> 00:36:38,740
va a enseñar el funcionamiento
sistema de lo que es una cadena, simplemente

753
00:36:38,740 --> 00:36:41,930
io.h como estándar es el archivo
en el sistema operativo que es

754
00:36:41,930 --> 00:36:44,430
va a enseñar lo que es printf.

755
00:36:44,430 --> 00:36:46,810
>> De hecho, habríamos conseguido
un mensaje muy similar

756
00:36:46,810 --> 00:36:50,600
Si IO había admitido norma
Io.h y trató de usar printf.

757
00:36:50,600 --> 00:36:53,632
Así que voy a seguir adelante y justo
control de la toma L para borrar la pantalla.

758
00:36:53,632 --> 00:36:56,340
O puede escribir claro y lo hará
acaba de limpiar la ventana del terminal.

759
00:36:56,340 --> 00:36:58,020
Pero todavía se puede desplazar hacia atrás en el tiempo.

760
00:36:58,020 --> 00:37:01,100
>> Y voy a volver a ejecutar Hacer una cadena.

761
00:37:01,100 --> 00:37:03,660
Cruzar los dedos esta vez, Intro.

762
00:37:03,660 --> 00:37:05,380
Oh, Dios mío, funcionó.

763
00:37:05,380 --> 00:37:09,280
que me muestra un comando largo críptica
esto es lo que hace que genera a través de Sonido metálico,

764
00:37:09,280 --> 00:37:10,460
pero ningún mensaje de error.

765
00:37:10,460 --> 00:37:12,460
Así darse cuenta, a pesar de
que podría obtener por completo

766
00:37:12,460 --> 00:37:14,480
abrumado con la
número de mensajes de error,

767
00:37:14,480 --> 00:37:17,540
que sólo podría ser este molesto en cascada
efecto, en Clang no entiende

768
00:37:17,540 --> 00:37:19,620
una cosa, lo que significa que entonces
no entiende la palabra siguiente,

769
00:37:19,620 --> 00:37:20,560
o la línea siguiente.

770
00:37:20,560 --> 00:37:22,850
Y por lo que sólo se ahoga con su código.

771
00:37:22,850 --> 00:37:24,440
Sin embargo, la solución puede ser muy sencilla.

772
00:37:24,440 --> 00:37:27,822
Y por lo que siempre se centran en el
primera línea de salida.

773
00:37:27,822 --> 00:37:29,530
Y si no lo hace
comprenderlo, basta con ver

774
00:37:29,530 --> 00:37:32,480
para las palabras clave que podría ser
pistas, y el número de línea,

775
00:37:32,480 --> 00:37:34,650
y el carácter, donde
ese error podría ser.

776
00:37:34,650 --> 00:37:40,328
>> Ahora voy a seguir adelante y escribo
punto slash, cadena, introduzca.

777
00:37:40,328 --> 00:37:44,340
Hm, no está diciendo hola nada.

778
00:37:44,340 --> 00:37:46,210
¿Por qué?

779
00:37:46,210 --> 00:37:48,170
Pues bien, hay que recordar, ¿dónde está ejecutando?

780
00:37:48,170 --> 00:37:53,730
>> Probablemente es atrapado por el momento
en un bucle, si se quiere, en la línea seis,

781
00:37:53,730 --> 00:37:56,950
Obtener debido a cadenas por diseño,
escrita por el personal CS50,

782
00:37:56,950 --> 00:38:00,350
es, literalmente, significaba para sentarse
no esperar, y esperar,

783
00:38:00,350 --> 00:38:01,850
y la espera de una cadena.

784
00:38:01,850 --> 00:38:03,792
Todo lo que entendemos por cadena es la intervención humana.

785
00:38:03,792 --> 00:38:04,500
Así que ya saben qué?

786
00:38:04,500 --> 00:38:05,166
Déjame ir por delante.

787
00:38:05,166 --> 00:38:08,704
Y sólo en un capricho, me dejó
escribir mi nombre, David, introduzca.

788
00:38:08,704 --> 00:38:10,120
Ahora tengo un programa más dinámico.

789
00:38:10,120 --> 00:38:11,240
Se dijo, hola David.

790
00:38:11,240 --> 00:38:16,280
>> Si sigo adelante y correr de nuevo,
voy a tratar de decir el nombre Zamila, introduzca.

791
00:38:16,280 --> 00:38:17,940
Y ahora tenemos un programa dinámico.

792
00:38:17,940 --> 00:38:19,380
No he codificado mundo.

793
00:38:19,380 --> 00:38:21,760
No he codificado
nombrar, o David, o Zamila.

794
00:38:21,760 --> 00:38:25,350
>> Ahora es mucho más parecido a los programas
sabemos, en la que si se tarda de entrada,

795
00:38:25,350 --> 00:38:27,870
produce resultados ligeramente distintos.

796
00:38:27,870 --> 00:38:31,020
Ahora bien, esto no es el mejor
la experiencia del usuario, o UX.

797
00:38:31,020 --> 00:38:33,000
Puedo ejecutar el programa.

798
00:38:33,000 --> 00:38:35,830
>> No sé lo que se supone
a hacer, a menos que en realidad miro

799
00:38:35,830 --> 00:38:37,290
o recordar el código fuente.

800
00:38:37,290 --> 00:38:39,640
Así que vamos a hacer el usuario
experimentar un poco mejor

801
00:38:39,640 --> 00:38:41,240
con el más simple de las cosas.

802
00:38:41,240 --> 00:38:44,782
Permítanme volver a este
programa, y ​​simplemente decir printf.

803
00:38:44,782 --> 00:38:48,870
>> Y déjame seguir adelante y decir su nombre, de colon,
y un espacio, y luego un punto y coma.

804
00:38:48,870 --> 00:38:51,170
Y sólo por diversión, sin holgura n.

805
00:38:51,170 --> 00:38:52,980
Y eso es deliberada,
porque yo no quiero

806
00:38:52,980 --> 00:38:54,590
el indicador para pasar a la siguiente línea.

807
00:38:54,590 --> 00:38:58,800
>> Quiero, en cambio, hacer esto, hacer cuerdas
volver a compilar el código en la nueva máquina

808
00:38:58,800 --> 00:39:00,980
código de puntos slash cadena.

809
00:39:00,980 --> 00:39:02,460
Ah, esto es mucho más bonita.

810
00:39:02,460 --> 00:39:05,780
Ahora sé que en realidad lo que la computadora
quiere que ponga, darle un nombre.

811
00:39:05,780 --> 00:39:10,020
>> Así que voy a seguir adelante y escribir
en Rob, entrar, y hola, Rob.

812
00:39:10,020 --> 00:39:13,640
Por lo tanto, se da cuenta, esto sigue siendo, al final
del día, solamente un programa de nueve líneas.

813
00:39:13,640 --> 00:39:15,090
Pero hemos tomado estos pasos de bebé.

814
00:39:15,090 --> 00:39:18,380
>> Escribimos una línea con la que nos
estaban familiarizados, printf, hola mundo.

815
00:39:18,380 --> 00:39:19,980
A continuación, nos deshicimos de un poco de eso.

816
00:39:19,980 --> 00:39:21,560
Y que en realidad utilizamos cadena GET.

817
00:39:21,560 --> 00:39:23,362
Y tiramos ese valor en una variable.

818
00:39:23,362 --> 00:39:26,070
Y luego seguimos adelante y mejorado
aún más con una tercera línea.

819
00:39:26,070 --> 00:39:29,220
Y este proceso iterativo de
la escritura de software es realmente la clave.

820
00:39:29,220 --> 00:39:33,420
En CS50, y en la vida en general,
por lo general, no debe sentarse,

821
00:39:33,420 --> 00:39:36,800
tener un programa en mente, y tratar de escritura
toda la maldita cosa a la vez.

822
00:39:36,800 --> 00:39:40,810
>> Será, inevitablemente, como resultado de la manera
más errores que nosotros mismos vimos aquí.

823
00:39:40,810 --> 00:39:44,070
Incluso yo, a día de hoy, en constante
hacer otros errores estúpidos,

824
00:39:44,070 --> 00:39:47,480
son errores de hecho más duras
que son más difíciles de entender.

825
00:39:47,480 --> 00:39:52,095
Pero va a cometer más errores más
líneas de código que escriben todos a la vez.

826
00:39:52,095 --> 00:39:54,220
Y por lo que esta práctica de,
escribir un poco de código

827
00:39:54,220 --> 00:39:57,930
que se sienta cómodo, compila
que, ejecutarlo, probarlo de forma más general,

828
00:39:57,930 --> 00:40:01,370
A continuación, pasar por lo en-- al igual que mantuvimos
capas y capas de la semana pasada,

829
00:40:01,370 --> 00:40:04,190
la construcción de algo muy
sencillo de algo más complejo,

830
00:40:04,190 --> 00:40:05,200
hacer lo mismo aquí.

831
00:40:05,200 --> 00:40:08,500
No se siente, y tratar de
escribir todo un problema.

832
00:40:08,500 --> 00:40:10,780
En realidad tomar estos pasos de bebé.

833
00:40:10,780 --> 00:40:15,100
>> Ahora, las cadenas no son todos
tan útil para sí mismos.

834
00:40:15,100 --> 00:40:18,210
Nos habíamos hecho, idealmente, al igual que
tiene algo más en nuestra caja de herramientas.

835
00:40:18,210 --> 00:40:20,990
Así que en realidad hacen exactamente eso.

836
00:40:20,990 --> 00:40:24,900
>> Déjame ir por delante ahora ya levantar
un programa ligeramente diferente.

837
00:40:24,900 --> 00:40:28,320
Y vamos a llamar a este Int.C, por entero.

838
00:40:28,320 --> 00:40:30,870
Voy a, de manera similar,
incluir CS550.h.

839
00:40:30,870 --> 00:40:33,060
Voy a incluir IO estándar.

840
00:40:33,060 --> 00:40:36,630
Y eso va a ser bastante común
en estos primeros días de la clase.

841
00:40:36,630 --> 00:40:39,050
>> Y voy a listas
a mí mismo con una función principal.

842
00:40:39,050 --> 00:40:43,370
Y ahora en vez de conseguir una cadena,
vamos a seguir adelante y obtener un int.

843
00:40:43,370 --> 00:40:49,285
Digamos que es i, y lo llaman llegar
int, cerca parens, punto y coma.

844
00:40:49,285 --> 00:40:51,410
Y ahora vamos a hacer
algo con él, printf.

845
00:40:51,410 --> 00:40:56,190
>> Digamos algo así como
hola, la barra invertida n, i coma.

846
00:40:56,190 --> 00:41:00,010
Así que estoy más o menos imitando
lo que hice hace un momento.

847
00:41:00,010 --> 00:41:01,660
Tengo aquí un marcador de posición.

848
00:41:01,660 --> 00:41:05,150
He aquí por comas i, porque quiero
para tapar i en que marcador de posición.

849
00:41:05,150 --> 00:41:07,250
>> Así que vamos a seguir adelante y tratar
la elaboración de este programa.

850
00:41:07,250 --> 00:41:10,060
El archivo se llama int.c.

851
00:41:10,060 --> 00:41:12,920
Así que voy a decir, hacer int, ingrese.

852
00:41:12,920 --> 00:41:16,420
Oh mi Dios, pero no es gran cosa, ¿verdad?

853
00:41:16,420 --> 00:41:17,230
Hay un error.

854
00:41:17,230 --> 00:41:19,810
>> Hay un error sintáctico
aquí de tal manera que el programa no puede

855
00:41:19,810 --> 00:41:25,460
compilarse dentro Int.C, línea
siete, 27 caracteres, formato de error

856
00:41:25,460 --> 00:41:28,400
especifica tipo char
estrella, cualquiera que sea.

857
00:41:28,400 --> 00:41:30,020
Pero el tipo de argumento es de tipo int.

858
00:41:30,020 --> 00:41:33,110
>> Así que aquí, también, no vamos a--
a pesar de que hoy en día es una gran cantidad de material,

859
00:41:33,110 --> 00:41:35,710
vamos a llenarte de
absolutamente todas las características de C,

860
00:41:35,710 --> 00:41:38,070
y programar de manera más general,
en tan sólo estas primeras semanas.

861
00:41:38,070 --> 00:41:40,400
Siempre hay a menudo va a ser la jerga
con el que no está familiarizado.

862
00:41:40,400 --> 00:41:43,350
Y, de hecho, estrella char es algo
vamos a volver a

863
00:41:43,350 --> 00:41:44,830
en una semana o el tiempo de dos.

864
00:41:44,830 --> 00:41:47,530
>> Pero por ahora, vamos a ver si podemos
analizar las palabras que son familiares.

865
00:41:47,530 --> 00:41:50,750
Formatos-- por lo que oímos formato
especificador, código de formato antes.

866
00:41:50,750 --> 00:41:51,840
Eso es familiar.

867
00:41:51,840 --> 00:41:53,840
Type-- pero el argumento tiene tipo int.

868
00:41:53,840 --> 00:41:55,980
Espera un minuto, i es un entero.

869
00:41:55,980 --> 00:41:59,230
>> Tal vez en realidad s por ciento
tiene un significado definido.

870
00:41:59,230 --> 00:42:00,230
Y, de hecho, lo hace.

871
00:42:00,230 --> 00:42:03,101
Un entero, si desea
printf para sustituirlo,

872
00:42:03,101 --> 00:42:05,350
en realidad se tiene que utilizar una
especificador de formato diferente.

873
00:42:05,350 --> 00:42:06,890
Y no vas a saber esto
a menos que alguien le dijo,

874
00:42:06,890 --> 00:42:07,973
o si lo había hecho antes.

875
00:42:07,973 --> 00:42:10,490
Pero por ciento i es lo
puede ser utilizado comúnmente

876
00:42:10,490 --> 00:42:12,240
en printf para conectar un número entero.

877
00:42:12,240 --> 00:42:14,920
También puede usar ciento
d para un entero decimal.

878
00:42:14,920 --> 00:42:16,490
Pero i es agradable y simple aquí.

879
00:42:16,490 --> 00:42:17,590
Así que vamos a ir con eso.

880
00:42:17,590 --> 00:42:21,160
>> Ahora voy a seguir adelante y
vuelva a ejecutar make int, Intro.

881
00:42:21,160 --> 00:42:23,328
Eso es bueno, no hay errores.

882
00:42:23,328 --> 00:42:27,260
Dot slash OK int--, mala experiencia de usuario,
porque no me he dicho

883
00:42:27,260 --> 00:42:27,760
qué hacer.

884
00:42:27,760 --> 00:42:28,426
Pero eso está bien.

885
00:42:28,426 --> 00:42:29,480
Me estoy poniendo en forma rápida.

886
00:42:29,480 --> 00:42:36,260
>> Y ahora déjame ir adelante y
escriba en David, OK, Zamila, Rob.

887
00:42:36,260 --> 00:42:37,820
Aceptar, por lo que esta es una buena cosa.

888
00:42:37,820 --> 00:42:41,710
Esta vez, estoy usando una función,
una pieza del rompecabezas, llamado get int.

889
00:42:41,710 --> 00:42:44,230
Y resulta out-- y vamos a
ver esto más adelante en el term--

890
00:42:44,230 --> 00:42:47,730
el personal CS50 ha implementado
obtener una cadena de tal manera

891
00:42:47,730 --> 00:42:50,350
que lo hará sólo físicamente
obtener una cadena para usted.

892
00:42:50,350 --> 00:42:54,340
>> Se ha implementado int ponerse en
de tal manera que sólo se

893
00:42:54,340 --> 00:42:55,590
obtener un número entero para usted.

894
00:42:55,590 --> 00:42:57,830
Y si, el ser humano,
no cooperan, es

895
00:42:57,830 --> 00:43:00,590
literalmente sólo va a
reintentar decir, volver a intentar volver a intentar,

896
00:43:00,590 --> 00:43:05,200
literalmente sentado en bucle, hasta
obligarle con un número mágico,

897
00:43:05,200 --> 00:43:07,670
así como 50, 50 y hola.

898
00:43:07,670 --> 00:43:11,440
>> O si corremos esto otra vez
y el tipo en el 42, 42 hola.

899
00:43:11,440 --> 00:43:15,750
Y así, la función get int
dentro de esa pieza del rompecabezas

900
00:43:15,750 --> 00:43:19,050
es suficiente la lógica, lo suficientemente pensamiento,
de averiguar, lo que es una palabra?

901
00:43:19,050 --> 00:43:20,330
Y lo que es un número?

902
00:43:20,330 --> 00:43:23,165
Sólo aceptando, en última instancia, números.

903
00:43:23,165 --> 00:43:25,690

904
00:43:25,690 --> 00:43:30,230
>> Así que resulta que esta
No es todo lo que expresiva.

905
00:43:30,230 --> 00:43:30,910
hasta aquí.

906
00:43:30,910 --> 00:43:33,690
Así, yay, la última vez que
fue bastante rápido

907
00:43:33,690 --> 00:43:38,320
en los juegos de ejecución, y la animación,
y las obras artísticas en cero.

908
00:43:38,320 --> 00:43:42,260
Y aquí, estamos siendo contenido
con el mundo hola, hola y 50.

909
00:43:42,260 --> 00:43:43,696
>> No es todo lo que inspirador.

910
00:43:43,696 --> 00:43:46,070
Y, de hecho, estos primeros
ejemplos tomará algún tiempo

911
00:43:46,070 --> 00:43:47,510
a la rampa encima de la emoción.

912
00:43:47,510 --> 00:43:49,854
Pero tenemos mucho más
controlar ahora, de hecho.

913
00:43:49,854 --> 00:43:51,770
Y vamos a muy
iniciar rápidamente la estratificación

914
00:43:51,770 --> 00:43:53,870
en la parte superior de estas primitivas básicas.

915
00:43:53,870 --> 00:43:56,370
>> Pero primero, vamos a entender
cuáles son las limitaciones.

916
00:43:56,370 --> 00:43:58,620
De hecho, una de las cosas
Cero no hace fácil

917
00:43:58,620 --> 00:44:00,990
hagamos que realmente se mira
debajo de la campana,

918
00:44:00,990 --> 00:44:03,740
y entender lo que es una
computadora es, lo que puede hacer,

919
00:44:03,740 --> 00:44:05,250
y cuáles son sus limitaciones.

920
00:44:05,250 --> 00:44:08,580
Y, de hecho, que la falta de
comprensión, potencialmente, a largo plazo

921
00:44:08,580 --> 00:44:12,520
puede conducir a nuestra propia escritura mistakes--
insectos, escritura software inseguro que

922
00:44:12,520 --> 00:44:13,880
es atacada de alguna manera.

923
00:44:13,880 --> 00:44:17,130
>> Así que vamos a dar algunos pasos hacia
entender esto un poco mejor por

924
00:44:17,130 --> 00:44:19,710
forma de, por ejemplo, el siguiente ejemplo.

925
00:44:19,710 --> 00:44:23,550
Voy a seguir adelante y poner en práctica
muy rápido un programa llamado Adder.

926
00:44:23,550 --> 00:44:25,134
Al igual, vamos a añadir algunos números juntos.

927
00:44:25,134 --> 00:44:27,800
Y voy a codificar algunas curvas
aquí, y simplemente copiar y pegar

928
00:44:27,800 --> 00:44:30,270
donde estaba antes, sólo
por lo que podemos conseguir que va antes.

929
00:44:30,270 --> 00:44:33,090
Así que ahora tengo los principios básicos
de un programa llamado Adder.

930
00:44:33,090 --> 00:44:34,670
>> Y vamos a seguir adelante y hacer esto.

931
00:44:34,670 --> 00:44:38,680
Voy a seguir adelante y
por ejemplo, inTX consigue obtener int.

932
00:44:38,680 --> 00:44:39,430
¿Y sabes qué?

933
00:44:39,430 --> 00:44:40,990
Vamos a hacer una mejor experiencia de usuario.

934
00:44:40,990 --> 00:44:45,740
>> Así que digamos que x es, y efectivamente
pedir al usuario que nos da x.

935
00:44:45,740 --> 00:44:50,600
Y luego me dejó ir adelante y decir, printf
¿qué tal que y es, esta vez esperando

936
00:44:50,600 --> 00:44:53,140
dos valores del usuario.

937
00:44:53,140 --> 00:44:59,759
Y a continuación, vamos a seguir adelante y
por ejemplo, printf, la suma de x e y es.

938
00:44:59,759 --> 00:45:01,300
Y ahora no quiero hacer s por ciento.

939
00:45:01,300 --> 00:45:09,080
Quiero hacerlo por ciento i, la barra invertida
n y, a continuación, conecte valor de la suma.

940
00:45:09,080 --> 00:45:10,620
>> Entonces, ¿cómo puedo ir haciendo esto?

941
00:45:10,620 --> 00:45:11,270
¿Sabes que?

942
00:45:11,270 --> 00:45:12,840
Sé cómo utilizar variables.

943
00:45:12,840 --> 00:45:15,140
Me dejaron de declarar una nueva, int z.

944
00:45:15,140 --> 00:45:16,770
>> Y voy a tomar una conjetura aquí.

945
00:45:16,770 --> 00:45:21,470
Si hay signos iguales en este
idioma, tal vez yo puedo hacer x más y,

946
00:45:21,470 --> 00:45:23,660
siempre y cuando termino mi
pensado con un punto y coma?

947
00:45:23,660 --> 00:45:28,170
Ahora puedo volver aquí abajo, conecte z,
terminar este pensamiento con un punto y coma.

948
00:45:28,170 --> 00:45:33,160
Y vamos a ver ahora, si éstos
secuencias de x lines-- es conseguir int.

949
00:45:33,160 --> 00:45:34,770
Y es conseguir int.

950
00:45:34,770 --> 00:45:37,980
>> Añadir x e y, almacenar el valor en z--
por lo que, de nuevo, recordar el signo igual

951
00:45:37,980 --> 00:45:38,560
no es igual.

952
00:45:38,560 --> 00:45:41,100
Es tarea de derecha a izquierda.

953
00:45:41,100 --> 00:45:45,180
Y vamos a imprimir que la suma
de X e Y no es literalmente z,

954
00:45:45,180 --> 00:45:46,830
pero lo que hay dentro de z.

955
00:45:46,830 --> 00:45:50,090
Así que vamos a hacer Adder -
agradable, no hay errores esta vez.

956
00:45:50,090 --> 00:45:53,030
Dot slash Adder, entrar,
x va a ser 1.

957
00:45:53,030 --> 00:45:55,380
>> Y va a ser 2.

958
00:45:55,380 --> 00:45:58,964
Y la suma de x e y es 3.

959
00:45:58,964 --> 00:46:00,130
Así que eso es todo fino y bueno.

960
00:46:00,130 --> 00:46:03,260
>> Por lo tanto es de imaginar que las matemáticas
debe trabajar en un programa como este.

961
00:46:03,260 --> 00:46:04,040
¿Pero sabes que?

962
00:46:04,040 --> 00:46:06,904
¿Es esta variable, la línea
12, incluso necesario?

963
00:46:06,904 --> 00:46:09,820
No es necesario entrar en el hábito
de simplemente almacenar cosas en las variables

964
00:46:09,820 --> 00:46:10,980
sólo porque es posible.

965
00:46:10,980 --> 00:46:13,550
Y, de hecho, por lo general es
mal de diseño considerado

966
00:46:13,550 --> 00:46:18,100
si va a crear una variable, llamada
z en este caso, el almacenamiento de algo en él,

967
00:46:18,100 --> 00:46:21,390
e inmediatamente después
usarlo, pero nunca más.

968
00:46:21,390 --> 00:46:24,700
¿Por qué dar un nombre a algo
z como si estás literalmente

969
00:46:24,700 --> 00:46:26,770
que va a utilizar
cosa solamente una vez, y por lo tanto

970
00:46:26,770 --> 00:46:29,380
proximal a donde creó
en primer lugar,

971
00:46:29,380 --> 00:46:31,052
tan cerca en términos de líneas de código?

972
00:46:31,052 --> 00:46:31,760
Así que ya saben qué?

973
00:46:31,760 --> 00:46:34,480
Resulta que C es bastante flexible.

974
00:46:34,480 --> 00:46:36,586
Si yo en realidad quiero
plug-in de los valores aquí,

975
00:46:36,586 --> 00:46:38,210
No necesito para declarar una nueva variable.

976
00:46:38,210 --> 00:46:41,680
Tan sólo pudiera plug-in de x más
Y, debido a que C entiende

977
00:46:41,680 --> 00:46:43,390
aritmética y operadores matemáticos.

978
00:46:43,390 --> 00:46:47,140
>> Por lo que simplemente puedo decir, hacer esto de matemáticas,
x más y, lo que esos valores son,

979
00:46:47,140 --> 00:46:50,780
conecte el resultante
entero en esa cadena.

980
00:46:50,780 --> 00:46:53,730
Por lo que este podría ser, aunque
sólo una línea más corta,

981
00:46:53,730 --> 00:46:58,480
un mejor diseño, un programa mejor,
porque hay menos código, por lo tanto,

982
00:46:58,480 --> 00:46:59,921
menos para mí entender.

983
00:46:59,921 --> 00:47:01,920
Y también es simplemente más limpio,
en la medida en que no estamos

984
00:47:01,920 --> 00:47:04,620
la introducción de nuevas palabras,
nuevos símbolos, como z,

985
00:47:04,620 --> 00:47:07,510
a pesar de que en realidad no
servirá mucho de un propósito.

986
00:47:07,510 --> 00:47:12,890
>> Por desgracia, no es matemáticas
todos los que a veces confiables.

987
00:47:12,890 --> 00:47:15,270
Vamos a seguir adelante y hacer esto.

988
00:47:15,270 --> 00:47:18,200
Voy a seguir adelante
ahora y hacer lo siguiente.

989
00:47:18,200 --> 00:47:27,650
>> Vamos a hacer printf, i por ciento, más ciento
I, se ciento i, n barra invertida.

990
00:47:27,650 --> 00:47:32,240
Y yo voy a hacer esto- xyx más y.

991
00:47:32,240 --> 00:47:34,821
Así que sólo voy a reescribir
esta forma ligeramente diferente aquí.

992
00:47:34,821 --> 00:47:36,320
Me dejaron de hacer una comprobación de validez rápida.

993
00:47:36,320 --> 00:47:37,986
Una vez más, no vamos a salir adelante de nosotros mismos.

994
00:47:37,986 --> 00:47:41,420
Hacer sumador, punto sumador de barra.

995
00:47:41,420 --> 00:47:44,950
x es 1, y es 2, 1 más 2 es 3.

996
00:47:44,950 --> 00:47:45,870
Y eso es bueno.

997
00:47:45,870 --> 00:47:49,060
Pero vamos a complicar esto ahora
un poco, y crear un nuevo archivo.

998
00:47:49,060 --> 00:47:53,350
>> Voy a llamar a éste,
decir, enteros, plural para los enteros.

999
00:47:53,350 --> 00:47:55,980
Permítanme comenzar donde estaba hace un momento.

1000
00:47:55,980 --> 00:47:57,770
Pero ahora vamos a hacer algunas otras líneas.

1001
00:47:57,770 --> 00:48:03,430
Déjame ir adelante y hacer lo siguiente,
printf, i por ciento, menos el porcentaje de i,

1002
00:48:03,430 --> 00:48:08,959
es ciento i, coma x, yx coma menos y.

1003
00:48:08,959 --> 00:48:10,750
Así que estoy haciendo un poco
diferente matemáticas allí.

1004
00:48:10,750 --> 00:48:11,624
Vamos a hacer otro.

1005
00:48:11,624 --> 00:48:16,610
Así por ciento i multiplicada por ciento
i es i ciento, la barra invertida n.

1006
00:48:16,610 --> 00:48:21,430
Vamos a plug-in de x e y, y los tiempos de x y.

1007
00:48:21,430 --> 00:48:24,530
Vamos a utilizar el asterisco en
el equipo de veces.

1008
00:48:24,530 --> 00:48:26,390
>> No utiliza x. x es
un nombre de variable aquí.

1009
00:48:26,390 --> 00:48:28,270
Se utiliza la estrella para la multiplicación.

1010
00:48:28,270 --> 00:48:29,020
Vamos a hacer una más.

1011
00:48:29,020 --> 00:48:34,580
Printf ciento I, dividido
por ciento i, i es por ciento,

1012
00:48:34,580 --> 00:48:40,460
n barra invertida. xy dividido por Y-
por lo que utilizar la barra diagonal en C

1013
00:48:40,460 --> 00:48:41,502
hacer la división.

1014
00:48:41,502 --> 00:48:42,460
Y vamos a hacer otro.

1015
00:48:42,460 --> 00:48:47,920

1016
00:48:47,920 --> 00:48:55,240
El resto de ciento i, dividido
por ciento i, i es ciento.

1017
00:48:55,240 --> 00:48:59,550
xy-- y ahora resto
es lo que queda.

1018
00:48:59,550 --> 00:49:02,980
Cuando intenta dividir una
denominador reduciéndolos a un numerador,

1019
00:49:02,980 --> 00:49:05,570
¿Cuánto queda más que
no se podía dividir a cabo?

1020
00:49:05,570 --> 00:49:07,910
>> Así que no hay realmente,
necesariamente, un símbolo

1021
00:49:07,910 --> 00:49:09,470
que hemos utilizado en la escuela primaria para esto.

1022
00:49:09,470 --> 00:49:13,830
Pero hay en C. Puede
decir x módulo y, donde

1023
00:49:13,830 --> 00:49:18,000
este signo de porcentaje en esta context--
confusamente cuando estás dentro

1024
00:49:18,000 --> 00:49:20,170
de las comillas dobles,
dentro de printf, ciento

1025
00:49:20,170 --> 00:49:21,830
se utiliza como el especificador de formato.

1026
00:49:21,830 --> 00:49:25,420
>> Cuando se utiliza por ciento fuera de
que, en una expresión matemática,

1027
00:49:25,420 --> 00:49:29,910
es el operador de módulo para modular
arithmetic-- para nuestros propósitos

1028
00:49:29,910 --> 00:49:33,650
aquí, sólo quiere decir, ¿cuál es la
resto de x dividido por y?

1029
00:49:33,650 --> 00:49:36,130
Así x dividido por y es x barra y.

1030
00:49:36,130 --> 00:49:38,220
¿Cuál es el resto de X dividido por Y?

1031
00:49:38,220 --> 00:49:41,780
Es x y mod, como diría un programador.

1032
00:49:41,780 --> 00:49:48,300
>> Así que si he cometido ningún error aquí, me dejó
seguir adelante y hacer enteros, plural, agradable,

1033
00:49:48,300 --> 00:49:50,010
y enteros de la raya vertical de puntos.

1034
00:49:50,010 --> 00:49:55,270
Y vamos a seguir adelante y
hacer, digamos, 1, 10.

1035
00:49:55,270 --> 00:49:58,390
De acuerdo, 1 más 10 es 11, cheque.

1036
00:49:58,390 --> 00:50:01,240
1 menos 10 es negativa 9, compruebe.

1037
00:50:01,240 --> 00:50:03,420
>> 1 veces 10 es 10, cheque.

1038
00:50:03,420 --> 00:50:07,090
1 dividido por 10 es--
OK, nos saltaremos que uno.

1039
00:50:07,090 --> 00:50:09,480
El resto de 1 dividido por 10 es 1.

1040
00:50:09,480 --> 00:50:10,680
Eso es correcto.

1041
00:50:10,680 --> 00:50:12,630
Pero hay un error aquí.

1042
00:50:12,630 --> 00:50:15,390
>> Así que el que yo poner mi
entregar, no es correcto.

1043
00:50:15,390 --> 00:50:16,670
Es decir, que está cerca de 0.

1044
00:50:16,670 --> 00:50:20,670
1 dividido por 10, ya sabes, si estamos
cortar algunas esquinas, seguro, es cero.

1045
00:50:20,670 --> 00:50:28,050
Pero en realidad debería ser 1/10,
0,1, o 0,10, 0,1000, o así sucesivamente.

1046
00:50:28,050 --> 00:50:30,600
>> Realmente no debería ser cero.

1047
00:50:30,600 --> 00:50:35,990
Pues bien, resulta que el equipo está
hacer literalmente lo que le dijimos que hiciera.

1048
00:50:35,990 --> 00:50:39,460
Estamos haciendo matemáticas como x dividido por y.

1049
00:50:39,460 --> 00:50:44,680
Y ambos X e Y, por las líneas
de código anterior, son números enteros.

1050
00:50:44,680 --> 00:50:50,440
>> Por otra parte, en la línea 15, que somos
printf diciendo, hey, printf plug-in

1051
00:50:50,440 --> 00:50:54,230
un entero, plug-in de un número entero,
plug-in de un integer-- específicamente

1052
00:50:54,230 --> 00:50:57,580
x, y, a continuación y, a continuación, x
dividido por y. x e y son enteros.

1053
00:50:57,580 --> 00:50:59,060
Estamos bien allí.

1054
00:50:59,060 --> 00:51:01,250
>> Pero lo que se divide por x x?

1055
00:51:01,250 --> 00:51:06,790
x dividido por y debería ser,
matemáticamente, 1/10, ó 0,1,

1056
00:51:06,790 --> 00:51:11,600
que es un número real, un número real
tener, potencialmente, un punto decimal.

1057
00:51:11,600 --> 00:51:13,230
No es un número entero.

1058
00:51:13,230 --> 00:51:18,290
>> Pero lo que es el más cercano
número entero de 1/10, o 0,1?

1059
00:51:18,290 --> 00:51:21,114
Sí, es como que es igual a cero.

1060
00:51:21,114 --> 00:51:22,030
0,1 es como esto mucho.

1061
00:51:22,030 --> 00:51:22,890
Y 1 es tanto.

1062
00:51:22,890 --> 00:51:25,870
Así décima está más cerca de
0 lo que es para uno.

1063
00:51:25,870 --> 00:51:30,800
>> Y así lo está haciendo por C nosotros--
tipo de porque nos dijeron que a--

1064
00:51:30,800 --> 00:51:32,600
se truncando que entero.

1065
00:51:32,600 --> 00:51:40,540
Se trata de tomar el valor, que es otra vez
se supone que es algo así como 0,1000,

1066
00:51:40,540 --> 00:51:41,800
0 y así sucesivamente.

1067
00:51:41,800 --> 00:51:45,320
Y se está truncando todo
después del punto decimal

1068
00:51:45,320 --> 00:51:47,510
de manera que todo esto
cosas, porque no lo hace

1069
00:51:47,510 --> 00:51:51,910
caber en la noción de un número entero, el cual
es sólo un número negativo como 1, 0, 1,

1070
00:51:51,910 --> 00:51:55,830
arriba y abajo, se tira a la basura todo lo
después del punto decimal porque

1071
00:51:55,830 --> 00:51:59,020
No puede caber un punto decimal
en un número entero por definición.

1072
00:51:59,020 --> 00:52:01,290
>> Así que la respuesta es cero.

1073
00:52:01,290 --> 00:52:02,600
Entonces, ¿cómo podemos solucionar este problema?

1074
00:52:02,600 --> 00:52:04,400
Necesitamos otra solución todos juntos.

1075
00:52:04,400 --> 00:52:06,880
Y podemos hacer esto, de la siguiente manera.

1076
00:52:06,880 --> 00:52:12,820
>> Déjame seguir adelante y crear una nueva
archivo, éste llama floats.c.

1077
00:52:12,820 --> 00:52:16,500
Y guardarlo aquí en el
mismo directorio, float.c.

1078
00:52:16,500 --> 00:52:19,360

1079
00:52:19,360 --> 00:52:23,260
Y déjame ir por delante y copiar
algunos de que el código de antes.

1080
00:52:23,260 --> 00:52:27,690
>> Pero en lugar de
un int, vamos a hacer esto.

1081
00:52:27,690 --> 00:52:31,037
Dame un valor de punto flotante
llamada x. donde un punto flotante

1082
00:52:31,037 --> 00:52:33,370
valor es sólo literalmente
algo con un punto flotante.

1083
00:52:33,370 --> 00:52:34,410
Puede moverse hacia la izquierda, a la derecha.

1084
00:52:34,410 --> 00:52:35,530
Es un número real.

1085
00:52:35,530 --> 00:52:38,050
>> Y no sea yo llamo
obtener int, pero llegar flotador,

1086
00:52:38,050 --> 00:52:41,420
que también estaba entre el menú
de opciones en la biblioteca C250.

1087
00:52:41,420 --> 00:52:43,220
Vamos a cambiar y a un flotador.

1088
00:52:43,220 --> 00:52:45,000
Así que esto se convierte en conseguir flotador.

1089
00:52:45,000 --> 00:52:47,620
>> Y ahora, no queremos que enchufar enteros.

1090
00:52:47,620 --> 00:52:53,130
Resulta que tenemos que usar ciento
f de flotación, f ciento de flotador,

1091
00:52:53,130 --> 00:52:54,560
y ahora guardarlo.

1092
00:52:54,560 --> 00:53:01,220
Y ahora, los dedos cruzados, hacen
flotadores, agradable, flotadores de la raya vertical de puntos.

1093
00:53:01,220 --> 00:53:04,280
x va a ser uno 1. y
Va a ser 10 otra vez.

1094
00:53:04,280 --> 00:53:08,240
>> Y, bien, bien mi adición es correcta.

1095
00:53:08,240 --> 00:53:10,240
Me esperaba más,
pero se me olvidó escribirlo.

1096
00:53:10,240 --> 00:53:13,250
Así que vamos a ir y corregir este error lógico.

1097
00:53:13,250 --> 00:53:16,280
>> Vamos a seguir adelante y agarrar el siguiente.

1098
00:53:16,280 --> 00:53:18,080
Sólo tendremos que hacer un poco de copiar y pegar.

1099
00:53:18,080 --> 00:53:20,080
Y voy a decir menos.

1100
00:53:20,080 --> 00:53:21,890
>> Y voy a veces decir.

1101
00:53:21,890 --> 00:53:24,060
Y yo voy a decir dividida.

1102
00:53:24,060 --> 00:53:28,240
Y yo no voy a hacer de módulo,
que no es tan pertinente aquí,

1103
00:53:28,240 --> 00:53:33,690
divididos por f, y los tiempos plus--
OK, vamos a hacer esto otra vez.

1104
00:53:33,690 --> 00:53:44,210
>> Hacer flotadores, flotadores de la raya vertical de puntos,
y 1, 10, y- agradable, no, OK.

1105
00:53:44,210 --> 00:53:45,250
Así que soy un idiota.

1106
00:53:45,250 --> 00:53:47,000
Así que esto es muy común
en ciencias de la computación

1107
00:53:47,000 --> 00:53:49,780
a cometer errores estúpidos como este.

1108
00:53:49,780 --> 00:53:53,100
>> Para fines pedagógicos,
lo que realmente quería hacer

1109
00:53:53,100 --> 00:53:57,410
fue cambiar la ciencia aquí
que además, al menos, a veces,

1110
00:53:57,410 --> 00:54:01,140
y para separar, ya que es de esperar
notado durante este ejercicio.

1111
00:54:01,140 --> 00:54:04,700
Así que ahora vamos a volver a compilar este
programa, hacer flotadores de la raya vertical de puntos.

1112
00:54:04,700 --> 00:54:07,950
>> Y por tercera vez, vamos a
ver si cumple con mis expectativas.

1113
00:54:07,950 --> 00:54:21,480
1, 10, entrar, sí, está bien, 1.000,
dividido por 10.000, es 0,100000.

1114
00:54:21,480 --> 00:54:24,952
Y resulta que podemos controlar el número de
números son después de esos puntos decimales.

1115
00:54:24,952 --> 00:54:25,660
En realidad lo hará.

1116
00:54:25,660 --> 00:54:26,790
Volveremos a eso.

1117
00:54:26,790 --> 00:54:28,440
>> Pero ahora, de hecho, los cálculos son correctos.

1118
00:54:28,440 --> 00:54:30,090
Así, de nuevo, ¿cuál es la comida para llevar en esta lista?

1119
00:54:30,090 --> 00:54:33,050
Resulta que en C, hay
no sólo simplemente strings-- y, de hecho,

1120
00:54:33,050 --> 00:54:36,120
en realidad no hay, porque
añadir los de la biblioteca CS50.

1121
00:54:36,120 --> 00:54:37,710
Pero no son sólo enteros.

1122
00:54:37,710 --> 00:54:38,990
>> Hay también flota.

1123
00:54:38,990 --> 00:54:42,810
Y resulta que un montón de otros datos
tipos también, que utilizaremos en poco tiempo.

1124
00:54:42,810 --> 00:54:46,270
Resulta que si quieres una sola
carácter, no una cadena de caracteres,

1125
00:54:46,270 --> 00:54:47,610
puede utilizar simplemente un char.

1126
00:54:47,610 --> 00:54:52,350
>> Resulta que si quieres un bool,
un valor booleano, verdadero o falso solamente,

1127
00:54:52,350 --> 00:54:56,840
Gracias a la biblioteca CS50, hemos
añadido a C el tipo de datos BOOL también.

1128
00:54:56,840 --> 00:54:59,180
Pero también está presente en
muchos otros idiomas también.

1129
00:54:59,180 --> 00:55:04,130
Y resulta que a veces
necesitará un número más grande que vienen por defecto

1130
00:55:04,130 --> 00:55:05,210
con enteros y flotadores.

1131
00:55:05,210 --> 00:55:10,590
>> Y, de hecho, un doble es un número
que utiliza no 32 bits, pero 64 bits.

1132
00:55:10,590 --> 00:55:14,990
Y un largo tiempo es un número que
no utiliza los bits 32, sino 64 bits,

1133
00:55:14,990 --> 00:55:19,190
respectivamente, para coma flotante
valores y números enteros, respectivamente.

1134
00:55:19,190 --> 00:55:22,780
Así que vamos a realidad ahora
ver esto en acción.

1135
00:55:22,780 --> 00:55:26,150
>> Voy a seguir adelante aquí
y preparar rápidamente otro programa.

1136
00:55:26,150 --> 00:55:32,020
Aquí, voy a seguir adelante
y no incluir CS50.h.

1137
00:55:32,020 --> 00:55:34,910
Y déjame ir, incluir norma io.h.

1138
00:55:34,910 --> 00:55:37,320
>> Y se dará cuenta de algo
enrrollado está pasando aquí.

1139
00:55:37,320 --> 00:55:40,592
No es de codificación de color en las cosas
de la misma manera como lo hizo antes.

1140
00:55:40,592 --> 00:55:43,550
Y resulta que, eso es porque
no han dado la cosa un nombre de archivo.

1141
00:55:43,550 --> 00:55:47,270
>> Voy a llamar a éste
sizeof.c, y golpeó en Guardar.

1142
00:55:47,270 --> 00:55:51,039
Y darse cuenta de lo que sucede a mi muy
código blanco contra este telón de fondo negro.

1143
00:55:51,039 --> 00:55:52,830
Ahora, al menos hay
algunos púrpura allí.

1144
00:55:52,830 --> 00:55:54,490
Y es resaltado de sintaxis.

1145
00:55:54,490 --> 00:55:57,700
>> Eso es porque, simplemente, no tengo
dijo el IDE qué tipo de archivo

1146
00:55:57,700 --> 00:56:01,060
es dándole un nombre, y
específicamente una extensión de archivo.

1147
00:56:01,060 --> 00:56:03,620
Ahora, vamos a seguir adelante y hacer esto.

1148
00:56:03,620 --> 00:56:08,910
Voy a seguir adelante y muy
simplemente imprima el bool following--

1149
00:56:08,910 --> 00:56:11,080
es LU ciento.

1150
00:56:11,080 --> 00:56:12,950
>> Volveremos a
que en un momento.

1151
00:56:12,950 --> 00:56:15,840
Y luego voy a
tamaño de impresión de bool.

1152
00:56:15,840 --> 00:56:18,170
Y ahora, sólo para ahorrar
yo algún tiempo, estoy

1153
00:56:18,170 --> 00:56:20,280
va a hacer en su conjunto
manojo de estos a la vez.

1154
00:56:20,280 --> 00:56:24,620
Y, en concreto, voy a
cambiar esto a un char y la carbonilla.

1155
00:56:24,620 --> 00:56:27,760
Éste, voy a cambiar
a un doble y un doble.

1156
00:56:27,760 --> 00:56:31,440
>> Éste, voy a cambiar
a un flotador y un flotador.

1157
00:56:31,440 --> 00:56:35,670
Éste, voy a
cambiar a un int y un int.

1158
00:56:35,670 --> 00:56:38,660
Y éste, voy
para cambiar a un largo tiempo.

1159
00:56:38,660 --> 00:56:40,840
Y todavía está teniendo
un largo tiempo, mucho tiempo.

1160
00:56:40,840 --> 00:56:44,572
>> Y luego, por último, di
yo una copa de más, cadena.

1161
00:56:44,572 --> 00:56:47,030
Resulta que en C, hay
el operador especial llamado

1162
00:56:47,030 --> 00:56:50,260
tamaño de ese literalmente
ir a, cuando se ejecuta,

1163
00:56:50,260 --> 00:56:52,099
decirnos el tamaño de
cada una de estas variables.

1164
00:56:52,099 --> 00:56:53,890
Y esta es una manera, ahora,
podemos conectar de nuevo

1165
00:56:53,890 --> 00:56:57,140
a la discusión de la semana pasada
de los datos y la representación.

1166
00:56:57,140 --> 00:57:00,330
>> Déjame seguir adelante y compilar
tamaño de tamaño de barra de punto de.

1167
00:57:00,330 --> 00:57:01,210
Y vamos a ver.

1168
00:57:01,210 --> 00:57:05,210
Resulta que en C,
específicamente en CS50 IDE,

1169
00:57:05,210 --> 00:57:08,170
específicamente en la
sistema operativo Ubuntu,

1170
00:57:08,170 --> 00:57:11,100
que es un operativo de 64 bits
sistema en este caso,

1171
00:57:11,100 --> 00:57:14,189
un bool va a
utilizar un byte de espacio.

1172
00:57:14,189 --> 00:57:16,480
Así es como se mide el tamaño,
no en bits, pero en bytes.

1173
00:57:16,480 --> 00:57:18,690
Y recuerdan que es un byte de ocho bits.

1174
00:57:18,690 --> 00:57:22,030
Por lo que un bool, a pesar de que
técnicamente sólo necesita un 0 o 1,

1175
00:57:22,030 --> 00:57:24,092
que es un poco derrochador
la forma en que hemos implementado.

1176
00:57:24,092 --> 00:57:26,800
Que en realidad va a usar en su conjunto
byte-- lo que todos los ceros, son tal vez

1177
00:57:26,800 --> 00:57:31,050
todos los queridos, o algo por el estilo,
o sólo uno de los ocho bits 1.

1178
00:57:31,050 --> 00:57:34,962
>> Un char, por su parte, utiliza un carácter
como un carácter ASCII a la semana pasada,

1179
00:57:34,962 --> 00:57:36,170
va a ser un personaje.

1180
00:57:36,170 --> 00:57:42,340
Y que se sincroniza con nuestra noción de
que sea no más de 256 bits-- más bien,

1181
00:57:42,340 --> 00:57:45,360
sincroniza con ella sin estar
más de 8 bits, que

1182
00:57:45,360 --> 00:57:47,450
nos da un máximo de 256 valores.

1183
00:57:47,450 --> 00:57:49,680
Un doble va a
ser de 8 bytes o 64 bits.

1184
00:57:49,680 --> 00:57:50,510
>> Un flotador es 4.

1185
00:57:50,510 --> 00:57:51,690
Un int es 4.

1186
00:57:51,690 --> 00:57:52,980
Hace mucho, mucho es 8.

1187
00:57:52,980 --> 00:57:54,716
Y es una cadena de 8.

1188
00:57:54,716 --> 00:57:55,840
Pero no se preocupe por eso.

1189
00:57:55,840 --> 00:57:57,340
Vamos a pelar esa capa.

1190
00:57:57,340 --> 00:57:59,940
Resulta, cuerdas pueden
tener más de 8 bytes.

1191
00:57:59,940 --> 00:58:02,310
>> Y, de hecho, hemos escrito
cuerdas ya, hola mundo,

1192
00:58:02,310 --> 00:58:03,700
más de 8 bytes.

1193
00:58:03,700 --> 00:58:06,270
Pero vamos a volver a
que en un momento.

1194
00:58:06,270 --> 00:58:09,690
Pero la toma de distancia aquí es la siguiente.

1195
00:58:09,690 --> 00:58:15,320
>> Cualquier equipo sólo tiene un número finito
cantidad de memoria y espacio.

1196
00:58:15,320 --> 00:58:17,860
Sólo se puede almacenar tantos
archivos en su Mac o PC.

1197
00:58:17,860 --> 00:58:23,030
Sólo se puede almacenar tantos programas en
RAM funcionando a la vez, necesariamente, incluso

1198
00:58:23,030 --> 00:58:26,360
con la memoria virtual, porque
usted tiene una cantidad finita de memoria RAM.

1199
00:58:26,360 --> 00:58:28,990
>> Y sólo para picture-- si
usted nunca ha abierto una computadora portátil

1200
00:58:28,990 --> 00:58:31,300
u ordenado memoria extra
para un ordenador,

1201
00:58:31,300 --> 00:58:33,670
podría no saber que
en el interior de su ordenador

1202
00:58:33,670 --> 00:58:36,590
es algo que se ve
un poco como esto.

1203
00:58:36,590 --> 00:58:40,540
Así que esto es sólo una empresa común llamada
Crucial que hace RAM para ordenadores.

1204
00:58:40,540 --> 00:58:43,620
Y la memoria RAM es donde los programas
vivir mientras se están ejecutando.

1205
00:58:43,620 --> 00:58:46,630
>> Así que en todos los Mac o PC, cuando se hace doble
haga clic en un programa, y ​​esto se abre,

1206
00:58:46,630 --> 00:58:48,921
y se abre un poco de documento de Word
o algo así,

1207
00:58:48,921 --> 00:58:51,764
lo almacena temporalmente en
RAM, memoria RAM ya que es más rápido

1208
00:58:51,764 --> 00:58:53,680
de su disco duro, o
el disco de estado sólido.

1209
00:58:53,680 --> 00:58:56,600
Por lo que es justo donde van los programas
para vivir cuando se están ejecutando,

1210
00:58:56,600 --> 00:58:58,060
o cuando se utilizan archivos.

1211
00:58:58,060 --> 00:59:00,890
>> Por lo que tiene cosas que se ven
así por dentro de su computadora portátil,

1212
00:59:00,890 --> 00:59:03,320
o cosas un poco más grande
dentro de su escritorio.

1213
00:59:03,320 --> 00:59:07,440
Pero la clave es que sólo tiene una
número finito de estas cosas.

1214
00:59:07,440 --> 00:59:11,230
Y sólo hay una cantidad finita de
hardware sentado en esta mesa de la derecha

1215
00:59:11,230 --> 00:59:11,730
aquí.

1216
00:59:11,730 --> 00:59:15,920
>> Así que, sin duda, no podemos almacenar
números infinitamente largo.

1217
00:59:15,920 --> 00:59:19,030
Y, sin embargo, si usted piensa de nuevo a
la escuela primaria, el número de dígitos puede

1218
00:59:19,030 --> 00:59:21,400
usted tiene la derecha
de un punto decimal?

1219
00:59:21,400 --> 00:59:24,680
Por lo demás, el número de dígitos puede
usted tiene a la izquierda de la coma decimal?

1220
00:59:24,680 --> 00:59:26,300
En realidad, infinitamente muchos.

1221
00:59:26,300 --> 00:59:30,840
>> Ahora, nosotros, los seres humanos sólo podría
saber cómo se pronuncia millones,

1222
00:59:30,840 --> 00:59:34,990
y miles de millones, billones de dólares, y
cuatrillón, y trillones.

1223
00:59:34,990 --> 00:59:39,370
Y estoy empujando los límites de mi
understanding-- o mi-- entiendo

1224
00:59:39,370 --> 00:59:41,110
números, pero mi
Pronunciación de los números.

1225
00:59:41,110 --> 00:59:44,720
Pero se puede conseguir con infinitamente grande
un número infinito de dígitos a la izquierda

1226
00:59:44,720 --> 00:59:47,050
o a la derecha de la coma decimal.

1227
00:59:47,050 --> 00:59:50,040
>> Pero los ordenadores sólo tienen una
cantidad finita de memoria,

1228
00:59:50,040 --> 00:59:53,510
un número finito de transistores, una
número finito de bombillas de luz en el interior.

1229
00:59:53,510 --> 00:59:57,350
Entonces, ¿qué sucede cuando
se le acaba el espacio?

1230
00:59:57,350 --> 00:59:59,620
En otras palabras, si
pensar de nuevo a la semana pasada

1231
00:59:59,620 --> 01:00:03,160
cuando hablamos de números
que ellas mismas sean representados en binario,

1232
01:00:03,160 --> 01:00:05,480
Supongamos que tenemos
este valor de 8 bits aquí.

1233
01:00:05,480 --> 01:00:08,290
>> Y tenemos siete de 1 y un 0.

1234
01:00:08,290 --> 01:00:10,827
Y supongamos que queremos
añadir 1 a este valor.

1235
01:00:10,827 --> 01:00:12,410
Este es un número muy grande en este momento.

1236
01:00:12,410 --> 01:00:16,610
>> Esto es 254, si no recuerdo
los cálculos de la última semana de la derecha.

1237
01:00:16,610 --> 01:00:19,480
Pero lo que si cambio
que más a la derecha 0 a un 1?

1238
01:00:19,480 --> 01:00:22,800
El número total de
Por supuesto, se convierte en ocho 1 de.

1239
01:00:22,800 --> 01:00:24,050
Así que estamos siendo buena.

1240
01:00:24,050 --> 01:00:27,204
>> Y que probablemente representa
255, aunque dependiendo del contexto

1241
01:00:27,204 --> 01:00:29,120
que en realidad podría representar
un número negativo.

1242
01:00:29,120 --> 01:00:31,240
Pero más de eso en otro momento.

1243
01:00:31,240 --> 01:00:34,220
Esto se siente como se trata de
tan alto como puedo contar.

1244
01:00:34,220 --> 01:00:35,290
>> Ahora, es sólo 8 bits.

1245
01:00:35,290 --> 01:00:38,170
Y mi Mac, sin duda, tiene forma
más de 8 bits de la memoria.

1246
01:00:38,170 --> 01:00:39,170
Pero tiene finita.

1247
01:00:39,170 --> 01:00:43,230
Así mismo argumento se aplica, incluso si
tener más de estos que están en la pantalla.

1248
01:00:43,230 --> 01:00:47,020
>> ¿Pero qué sucede si estás
almacenar este número, 255,

1249
01:00:47,020 --> 01:00:49,290
y que desea contar 1 poco más alto?

1250
01:00:49,290 --> 01:00:51,600
¿Quieres ir de 255 a la tecnología 256.

1251
01:00:51,600 --> 01:00:55,800
El problema, por supuesto, es que si se
comenzará a contar desde cero como la semana pasada,

1252
01:00:55,800 --> 01:00:59,670
no se puede contar tan alto
como 256, 257 y mucho menos,

1253
01:00:59,670 --> 01:01:02,584
por no hablar de 258, m porque lo
que sucede cuando se agrega un 1?

1254
01:01:02,584 --> 01:01:05,000
Si lo hace la vieja escuela de grado
enfoque, se pone un 1 aquí,

1255
01:01:05,000 --> 01:01:08,150
y luego 1 más 1 es 2, pero eso es
Realmente un cero, que llevan el 1,

1256
01:01:08,150 --> 01:01:09,695
llevar a la 1, llevar a la 1.

1257
01:01:09,695 --> 01:01:12,620
Todas estas cosas,
estos de 1, van a cero.

1258
01:01:12,620 --> 01:01:17,820
Y que terminan, sí, como alguien
señalado, un 1 en el lado izquierdo.

1259
01:01:17,820 --> 01:01:22,540
Pero todo lo que pueda
en realidad ver y caber en la memoria

1260
01:01:22,540 --> 01:01:27,960
es tan sólo ocho de 0, lo que quiere decir
en algún momento si, una computadora,

1261
01:01:27,960 --> 01:01:32,490
intentado contar lo suficientemente alto, eres
va a envolver alrededor, al parecer,

1262
01:01:32,490 --> 01:01:35,850
a cero, o tal vez incluso negativo
números, que son incluso inferiores a cero.

1263
01:01:35,850 --> 01:01:37,260
>> Y podemos especie de ver esto.

1264
01:01:37,260 --> 01:01:39,900
Déjame seguir adelante y escribir
un verdadero programa rápido aquí.

1265
01:01:39,900 --> 01:01:43,690
Déjame seguir adelante y escribir
un programa llamado desbordamiento.

1266
01:01:43,690 --> 01:01:49,980
Incluir CS50.h, incluya
estándar IO.h-- oh,

1267
01:01:49,980 --> 01:01:51,730
Realmente extrañaba a mi resaltado de sintaxis.

1268
01:01:51,730 --> 01:01:54,440
Así que vamos a guardar esto como overflow.c.

1269
01:01:54,440 --> 01:01:57,084
>> Y ahora int void-- principal
y en poco tiempo, vamos a

1270
01:01:57,084 --> 01:01:59,500
volver a explicar por qué
seguimos escribiendo int void main.

1271
01:01:59,500 --> 01:02:02,080
Pero por ahora, vamos a hacer
que, dando por sentado.

1272
01:02:02,080 --> 01:02:06,200
Vamos a dar a mí mismo un int,
e inicializar a 0.

1273
01:02:06,200 --> 01:02:11,716
>> Vamos a hacer a continuación para int i obtener zero--
En realidad, vamos a hacer un bucle infinito

1274
01:02:11,716 --> 01:02:12,590
y ver qué pasa.

1275
01:02:12,590 --> 01:02:22,440
Aunque es verdad, entonces vamos a imprimir a cabo n
Es por ciento i, la barra invertida n, plug-n.

1276
01:02:22,440 --> 01:02:27,200
Pero, ahora, vamos a hacer que n se hace n + 1.

1277
01:02:27,200 --> 01:02:29,660
>> Así, en otras palabras, en cada
iteración de este bucle infinito,

1278
01:02:29,660 --> 01:02:32,550
tomemos el valor de n,
y se añade 1 a la misma, y ​​luego

1279
01:02:32,550 --> 01:02:34,350
almacenar el resultado de nuevo n de la izquierda.

1280
01:02:34,350 --> 01:02:37,150
Y, de hecho, hemos visto la sintaxis
un poco como esto, brevemente.

1281
01:02:37,150 --> 01:02:39,730
Un buen truco es en cambio
de escribir todo esto a cabo,

1282
01:02:39,730 --> 01:02:42,770
en realidad se puede decir que una más n es igual a 1.

1283
01:02:42,770 --> 01:02:47,480
>> O si realmente quiere ser de lujo,
se puede decir n plus plus punto y coma.

1284
01:02:47,480 --> 01:02:50,130
Pero estos dos últimos son simplemente
lo que nosotros llamamos el azúcar sintáctica

1285
01:02:50,130 --> 01:02:50,790
para la primera cosa.

1286
01:02:50,790 --> 01:02:53,456
>> Lo primero es más explícito,
totalmente bien, todo correcto.

1287
01:02:53,456 --> 01:02:55,470
Pero esto es más común, que voy a decir.

1288
01:02:55,470 --> 01:02:57,210
Así que vamos a hacer esto por un momento.

1289
01:02:57,210 --> 01:03:01,685
>> Ahora vamos a hacer desbordamiento, que suena
en lugar de mal agüero, desbordamiento barra de puntos.

1290
01:03:01,685 --> 01:03:04,380

1291
01:03:04,380 --> 01:03:09,852
Vamos a ver, n está haciendo muy grande.

1292
01:03:09,852 --> 01:03:11,310
Pero pensemos, lo grande que n puede conseguir?

1293
01:03:11,310 --> 01:03:12,870
>> n es un entero.

1294
01:03:12,870 --> 01:03:16,400
Vimos hace un momento con el tamaño de
ejemplo, que un int es de cuatro bytes.

1295
01:03:16,400 --> 01:03:22,070
Sabemos de la semana pasada, cuatro bytes es
32 bits, ya que 8 veces 4, eso es 32.

1296
01:03:22,070 --> 01:03:23,460
Eso va a ser de 4 millones de dólares.

1297
01:03:23,460 --> 01:03:25,802
>> Y estamos hasta 800.000.

1298
01:03:25,802 --> 01:03:28,510
Esto va a tener siempre a
contar tan alto como sea posible.

1299
01:03:28,510 --> 01:03:30,635
Así que voy a seguir adelante,
como puede ser que después de poco tiempo,

1300
01:03:30,635 --> 01:03:34,910
y pulsa Control de C-- francamente, Control
C, mucho, donde el control general C

1301
01:03:34,910 --> 01:03:36,034
medios cancelan.

1302
01:03:36,034 --> 01:03:38,200
Desafortunadamente, debido a esta
se está ejecutando en la nube,

1303
01:03:38,200 --> 01:03:41,190
A veces la nube es
escupiendo tantas cosas,

1304
01:03:41,190 --> 01:03:44,180
tanto la producción, que va a
tomar un poco de tiempo para mi entrada

1305
01:03:44,180 --> 01:03:45,630
para llegar a la nube.

1306
01:03:45,630 --> 01:03:49,240
Así que, aunque me golpeó
Control C Hace unos pocos segundos,

1307
01:03:49,240 --> 01:03:53,110
este es sin duda el lado
efecto de un bucle infinito.

1308
01:03:53,110 --> 01:03:56,070
>> Y así, en estos casos, estamos
va a dejar que sea.

1309
01:03:56,070 --> 01:03:59,050
Y vamos a añadir otro
ventana de terminal por aquí

1310
01:03:59,050 --> 01:04:03,186
con los polos positivo, que por supuesto no lo hace
de esa manera, ya que todavía está pensando.

1311
01:04:03,186 --> 01:04:05,310
Y vamos a seguir adelante y estar
un poco más razonable.

1312
01:04:05,310 --> 01:04:07,768
>> Voy a seguir adelante y hacerlo
Esto sólo un número finito de veces.

1313
01:04:07,768 --> 01:04:10,047
Vamos a utilizar un bucle for,
lo que he aludido antes.

1314
01:04:10,047 --> 01:04:10,630
Hagámoslo.

1315
01:04:10,630 --> 01:04:13,430
Dame otra variable int i consigue 0.

1316
01:04:13,430 --> 01:04:17,430
i es menor que, digamos, 64 i ++.

1317
01:04:17,430 --> 01:04:24,010
Y ahora permítanme imprimámoslas
n es a cabo por ciento i, la coma n.

1318
01:04:24,010 --> 01:04:27,547
Y a continuación, esto sigue siendo n-
va a tomar para siempre.

1319
01:04:27,547 --> 01:04:28,130
Hagámoslo.

1320
01:04:28,130 --> 01:04:30,620
>> n se hace n veces 2.

1321
01:04:30,620 --> 01:04:34,140
O podríamos ser de lujo
y hacer tiempos es igual a 2.

1322
01:04:34,140 --> 01:04:37,120
Pero digamos que n
es igual a sí mismo, los tiempos 2.

1323
01:04:37,120 --> 01:04:39,321
En otras palabras, en este
nueva versión del programa,

1324
01:04:39,321 --> 01:04:41,820
No quiero esperar por siempre
como de 800.000 a 4 millones de dólares.

1325
01:04:41,820 --> 01:04:43,070
Vamos a acabar con esto.

1326
01:04:43,070 --> 01:04:44,920
>> Vamos a duplicar en realidad n cada vez.

1327
01:04:44,920 --> 01:04:47,660
El cual, el recuerdo, la duplicación es el
opuesta de tener, por supuesto.

1328
01:04:47,660 --> 01:04:50,035
Y mientras que la semana pasada tenemos
algo nuevo, y de nuevo,

1329
01:04:50,035 --> 01:04:52,200
y de nuevo, súper rápido,
duplicación seguramente lo harán

1330
01:04:52,200 --> 01:04:58,080
sacarnos de 1 a la mayor posible
valor que podemos contar hasta con un int.

1331
01:04:58,080 --> 01:04:59,750
>> Así que vamos a hacer exactamente esto.

1332
01:04:59,750 --> 01:05:01,720
Y vamos a volver a este después de poco tiempo.

1333
01:05:01,720 --> 01:05:04,180
Pero esto, de nuevo, es igual
el bloque de repetición en Scratch.

1334
01:05:04,180 --> 01:05:05,600
Y vamos a usar esto en poco tiempo.

1335
01:05:05,600 --> 01:05:10,170
>> Esto sólo significa recuento de cero
hasta, pero no igual, a 64.

1336
01:05:10,170 --> 01:05:14,285
Y en cada iteración de esta
lazo, mantendría incrementando i.

1337
01:05:14,285 --> 01:05:18,990
Así i ++ - y esta construcción en general
en la línea 7 es sólo una manera súper común

1338
01:05:18,990 --> 01:05:22,290
de repetir algunas líneas de
código, cierto número de veces.

1339
01:05:22,290 --> 01:05:23,362
¿Qué líneas de código?

1340
01:05:23,362 --> 01:05:25,570
Estas llaves, como se
pueden haber recogido a partir de ahora,

1341
01:05:25,570 --> 01:05:26,780
significa, haga lo siguiente.

1342
01:05:26,780 --> 01:05:29,510
>> Es como en Scratch, cuando
que tiene los bloques amarillos

1343
01:05:29,510 --> 01:05:32,680
y otros colores que tipo de
abrazar o abrazar a otros bloques.

1344
01:05:32,680 --> 01:05:34,750
Eso es lo que esos rizado
aparatos ortopédicos están haciendo aquí.

1345
01:05:34,750 --> 01:05:40,200
Así que si me dieron mi sintaxis que derecha-
puede ver el símbolo de zanahoria en el medio C

1346
01:05:40,200 --> 01:05:42,706
que es la cantidad de veces que he estado
tratar de resolver este problema.

1347
01:05:42,706 --> 01:05:45,330
Así que vamos a deshacernos de que uno
en total, y cerrar esa ventana.

1348
01:05:45,330 --> 01:05:46,520
Y vamos a utilizar la nueva.

1349
01:05:46,520 --> 01:05:51,980
Hacer desbordamiento, barra de puntos
desbordamiento, Enter, todos los derechos,

1350
01:05:51,980 --> 01:05:53,090
se ve mal al principio.

1351
01:05:53,090 --> 01:05:56,200
Pero vamos a retroceder en el tiempo,
porque me hizo esto 64 veces.

1352
01:05:56,200 --> 01:05:58,700
>> Y observe la primera vez, n es 1.

1353
01:05:58,700 --> 01:06:03,110
La segunda vez, n es 2,
luego 4, luego 8, luego 16.

1354
01:06:03,110 --> 01:06:09,450
Y parece que en cuanto
Llego a más o menos 1 mil millones,

1355
01:06:09,450 --> 01:06:12,800
si hago doble de nuevo, que
debe dame 2 mil millones.

1356
01:06:12,800 --> 01:06:14,980
Pero resulta, que es
justo en la cúspide.

1357
01:06:14,980 --> 01:06:18,930
>> Y lo que en realidad se desborda
un entero de 1 mil millones

1358
01:06:18,930 --> 01:06:23,514
a más o menos 2 negativo
millones de dólares, debido a un número entero,

1359
01:06:23,514 --> 01:06:25,430
a diferencia de la que números
fueron asumiendo la semana pasada,

1360
01:06:25,430 --> 01:06:28,397
puede ser tanto positiva como negativa
en la realidad y en un ordenador.

1361
01:06:28,397 --> 01:06:30,730
Y así, al menos, uno de los
los bits son robados eficacia.

1362
01:06:30,730 --> 01:06:34,190
Así que realmente sólo tenemos 31 bits,
o 2 mil millones de valores posibles.

1363
01:06:34,190 --> 01:06:38,220
>> Pero por ahora, la comida para llevar es bastante
simplemente, sean cuales sean estos números son

1364
01:06:38,220 --> 01:06:42,280
y cualquiera que sea la matemática es,
que sucede algo malo con el tiempo,

1365
01:06:42,280 --> 01:06:46,980
porque con el tiempo que está intentando
permutar los bits demasiadas veces.

1366
01:06:46,980 --> 01:06:51,060
Y vas efectiva de todo
de 1 a 0 tal vez todos de, o tal vez

1367
01:06:51,060 --> 01:06:54,260
simplemente algún otro patrón que
claramente, dependiendo del contexto,

1368
01:06:54,260 --> 01:06:56,342
puede ser interpretado como un número negativo.

1369
01:06:56,342 --> 01:06:59,300
Y por lo que parece el más alto que
puede contar en este programa concreto

1370
01:06:59,300 --> 01:07:01,210
es sólo aproximadamente 1 mil millones.

1371
01:07:01,210 --> 01:07:02,760
Pero hay una solución parcial aquí.

1372
01:07:02,760 --> 01:07:03,480
¿Sabes que?

1373
01:07:03,480 --> 01:07:07,600
>> Déjame cambiar de una
Int a un largo tiempo.

1374
01:07:07,600 --> 01:07:10,633
Y déjame ir por delante aquí
y decir-- Voy a tener

1375
01:07:10,633 --> 01:07:12,290
para cambiar esto a un largo sin signo.

1376
01:07:12,290 --> 01:07:16,860
O bien, vamos a ver, nunca me acuerdo de mí.

1377
01:07:16,860 --> 01:07:19,920
>> Vamos a seguir adelante y crea desbordamiento.

1378
01:07:19,920 --> 01:07:21,860
No, no es eso, LLD, gracias.

1379
01:07:21,860 --> 01:07:23,430
Así que a veces puede ser útil Clang.

1380
01:07:23,430 --> 01:07:27,550
No recuerdo lo que el formato
especificador fue durante mucho tiempo.

1381
01:07:27,550 --> 01:07:28,950
>> Pero, de hecho, Clang me dijo.

1382
01:07:28,950 --> 01:07:31,570
El verde es un tipo de bien,
todavía significa que cometió un error.

1383
01:07:31,570 --> 01:07:33,190
Se adivinando que quería decir LLD.

1384
01:07:33,190 --> 01:07:38,750
>> Por eso quiero aprovechar es un consejo, una larga
número decimal de longitud, salvo que.

1385
01:07:38,750 --> 01:07:43,190
Y permítanme volver a ejecutarlo, dot
reducir desbordamiento, Intro.

1386
01:07:43,190 --> 01:07:45,020
Y ahora lo que es fresco es esto.

1387
01:07:45,020 --> 01:07:49,140
>> Si me desplazo hacia atrás en el tiempo, todavía empezamos
contando al mismo lugar-- 1, 2, 4,

1388
01:07:49,140 --> 01:07:50,220
8, 16.

1389
01:07:50,220 --> 01:07:54,860
Aviso, obtenemos toda la
hasta llegar a 1 mil millones.

1390
01:07:54,860 --> 01:07:57,070
Pero entonces con seguridad llegar a 2 mil millones.

1391
01:07:57,070 --> 01:08:01,300
>> Entonces conseguimos a 4 millones de dólares,
a continuación, 8 mil millones, 17 mil millones.

1392
01:08:01,300 --> 01:08:03,340
Y vamos más alto, y
alto y más alto.

1393
01:08:03,340 --> 01:08:05,740
Con el tiempo, esto también se rompe.

1394
01:08:05,740 --> 01:08:09,350
>> Finalmente, con un largo tiempo,
que es el valor de 64 bits, no

1395
01:08:09,350 --> 01:08:13,660
un valor de 32 bits, si se cuenta
demasiado alto, que se coloca alrededor de 0.

1396
01:08:13,660 --> 01:08:16,410
Y en este caso, nos ha tocado
terminar con un número negativo.

1397
01:08:16,410 --> 01:08:17,550
>> Así que este es un problema.

1398
01:08:17,550 --> 01:08:20,439
Y resulta que este
problema no es tan arcano.

1399
01:08:20,439 --> 01:08:23,060
Aunque he deliberadamente
inducida con estos errores,

1400
01:08:23,060 --> 01:08:26,149
Resulta que lo vemos todo tipo de
nosotros, o al menos algunos de nosotros alrededor de hacerlo.

1401
01:08:26,149 --> 01:08:28,939
>> Así que en Lego Star Wars, si
¿Alguna vez has jugado el juego,

1402
01:08:28,939 --> 01:08:33,830
Resulta que se puede dar la vuelta
romper las cosas en el mundo de LEGO,

1403
01:08:33,830 --> 01:08:36,640
y la recogida de monedas, esencialmente.

1404
01:08:36,640 --> 01:08:39,200
Y si has jugado alguna vez
este juego demasiado tiempo,

1405
01:08:39,200 --> 01:08:42,630
ya que este individuo no identificado
aquí lo hizo, el número total

1406
01:08:42,630 --> 01:08:46,700
de monedas que se pueden recoger
es, al parecer, 4 mil millones.

1407
01:08:46,700 --> 01:08:48,240
>> Ahora, con él es en realidad redondeado.

1408
01:08:48,240 --> 01:08:50,239
Así que estaba tratando de LEGO
mantener las cosas fácil de usar.

1409
01:08:50,239 --> 01:08:53,779
Ellos no lo hicieron exactamente a 2
el 32 de potencia, a la semana pasada.

1410
01:08:53,779 --> 01:08:55,310
Pero 4 mil millones es una razón.

1411
01:08:55,310 --> 01:08:58,979
Parece, a partir de esta información,
que LEGO, y la empresa que

1412
01:08:58,979 --> 01:09:02,624
hecho este software real, decidió
que el número máximo de monedas

1413
01:09:02,624 --> 01:09:04,540
el usuario puede acumular
es, de hecho, 4 mil millones,

1414
01:09:04,540 --> 01:09:12,069
porque eligieron en su código
utilizar no mucho tiempo, al parecer,

1415
01:09:12,069 --> 01:09:16,140
pero sólo un número entero, sin signo
número entero, solamente un número entero positivo, cuyo

1416
01:09:16,140 --> 01:09:18,089
valor máximo más o menos es eso.

1417
01:09:18,089 --> 01:09:19,380
Bueno, aquí hay otro divertido.

1418
01:09:19,380 --> 01:09:23,500
Así que en el juego de la civilización, la cual
algunos de ustedes podrían estar familiarizados con

1419
01:09:23,500 --> 01:09:26,660
resulta que hace años se
Fue un error en este juego mediante el cual

1420
01:09:26,660 --> 01:09:28,750
si has jugado el papel
de Gandhi en el juego,

1421
01:09:28,750 --> 01:09:34,020
en vez de estar muy pacifista,
en cambio, fue muy, muy

1422
01:09:34,020 --> 01:09:36,399
agresivo, en algunas circunstancias.

1423
01:09:36,399 --> 01:09:40,529
En particular, la forma en que la civilización
obras es que si usted, el jugador,

1424
01:09:40,529 --> 01:09:44,680
adoptar la democracia, su
El marcador se pone la agresividad

1425
01:09:44,680 --> 01:09:48,130
decrementa en dos, por lo menos
menos, y luego minus.

1426
01:09:48,130 --> 01:09:50,569
>> Por lo que resta 2
su iteración actual.

1427
01:09:50,569 --> 01:09:56,650
Desafortunadamente, si su iteración es
inicialmente 1, 2 y restar de ella

1428
01:09:56,650 --> 01:09:59,050
después de adoptar la democracia
como Gandhi aquí podría

1429
01:09:59,050 --> 01:10:02,200
lo han hecho, porque era muy passive--
1 en la escala de agresividad.

1430
01:10:02,200 --> 01:10:04,830
Pero si se adopta la democracia, a continuación,
que va de 1 a 1 negativo.

1431
01:10:04,830 --> 01:10:11,470
>> Desafortunadamente, eran
el uso de números sin signo,

1432
01:10:11,470 --> 01:10:15,400
lo que significa que tratan incluso negativo
números como si fueran positivos.

1433
01:10:15,400 --> 01:10:19,780
Y resulta que la
equivalente positivo de 1 negativo,

1434
01:10:19,780 --> 01:10:23,480
en programas informáticos típicos, es 255.

1435
01:10:23,480 --> 01:10:27,250
Así que si Gandhi adopta
la democracia tiene, y por lo tanto

1436
01:10:27,250 --> 01:10:32,470
su puntuación se redujo la agresividad,
que en realidad alrededor de los rollos a 255

1437
01:10:32,470 --> 01:10:35,470
y lo hace más
carácter agresivo en el juego.

1438
01:10:35,470 --> 01:10:36,930
Por lo que puede buscar en Google en esto.

1439
01:10:36,930 --> 01:10:39,380
Y fue, de hecho, una
error de programación accidental,

1440
01:10:39,380 --> 01:10:43,010
pero eso ha entrado bastante
la tradición desde entonces.

1441
01:10:43,010 --> 01:10:44,360
>> Eso es todo diversión y lindo.

1442
01:10:44,360 --> 01:10:47,760
Más alarmante es cuando se real
dispositivos del mundo real, y no los juegos,

1443
01:10:47,760 --> 01:10:48,820
tener estos mismos errores.

1444
01:10:48,820 --> 01:10:54,500
De hecho, hace apenas un año un artículo vino
cabo sobre el Boeing 787 Dreamliner.

1445
01:10:54,500 --> 01:10:56,850
>> Y el artículo en un primer momento
mirada lee un poco arcano.

1446
01:10:56,850 --> 01:11:01,480
Pero dicho esto, un software
vulnerabilidad en Boeing

1447
01:11:01,480 --> 01:11:04,790
nuevo 787 Dreamliner jet tiene
el potencial para causar pilotos

1448
01:11:04,790 --> 01:11:07,220
perder el control de
la aeronave, posiblemente

1449
01:11:07,220 --> 01:11:11,750
en pleno vuelo, los funcionarios de la FAA
Las aerolíneas advirtió recientemente.

1450
01:11:11,750 --> 01:11:14,520
Era la determinación
que un modelo 787

1451
01:11:14,520 --> 01:11:19,770
avión que ha sido alimentado
de forma continua durante 248 días

1452
01:11:19,770 --> 01:11:24,880
pueden perder totalmente la corriente alterna, CA,
energía eléctrica debido al generador

1453
01:11:24,880 --> 01:11:28,892
unidades de control, GCU, a la vez
entrar en modo de seguridad de.

1454
01:11:28,892 --> 01:11:29,850
Es una especie de perderme.

1455
01:11:29,850 --> 01:11:35,390
Sin embargo, la nota se señalaba, OK, ahora tengo que,
la condición fue causada por un software

1456
01:11:35,390 --> 01:11:38,590
contador interno de
el control del generador

1457
01:11:38,590 --> 01:11:44,860
unidades que se desbordará después
248 días de potencia continua.

1458
01:11:44,860 --> 01:11:47,070
Estamos emitiendo este
AVISO Para evitar la pérdida de

1459
01:11:47,070 --> 01:11:49,300
de todos AC eléctrico
poder, lo que podría resultar

1460
01:11:49,300 --> 01:11:50,980
la pérdida de control del avión.

1461
01:11:50,980 --> 01:11:55,380
>> Así que, literalmente, hay un cierto número entero,
o un cierto tipo de datos equivalente,

1462
01:11:55,380 --> 01:11:57,960
siendo utilizado en software
en un avión real

1463
01:11:57,960 --> 01:12:00,756
que si mantiene su avión
el tiempo suficiente, que al parecer

1464
01:12:00,756 --> 01:12:03,880
puede ser el caso si sólo está ejecutando
ellos constantemente y nunca desconectar

1465
01:12:03,880 --> 01:12:06,810
su avión, al parecer, o
dejando que sus baterías se agoten,

1466
01:12:06,810 --> 01:12:09,840
con el tiempo se cuenta ascendente, y hasta,
y arriba, y arriba y arriba, y hacia arriba.

1467
01:12:09,840 --> 01:12:12,150
>> Y, por naturaleza, una
cantidad finita de memoria

1468
01:12:12,150 --> 01:12:15,880
se desbordará, rodando de nuevo a
cero o un valor negativo,

1469
01:12:15,880 --> 01:12:19,920
un efecto secundario de que es el
la realidad terriblemente reales

1470
01:12:19,920 --> 01:12:23,970
que el avión podría necesitar
ser reiniciado, efectivamente,

1471
01:12:23,970 --> 01:12:27,290
o podría caer, peor aún, a medida que vuela.

1472
01:12:27,290 --> 01:12:29,230
Por lo que este tipo de problemas
siguen con nosotros,

1473
01:12:29,230 --> 01:12:33,130
even-- este era un artículo de 2015,
aún más alarmante

1474
01:12:33,130 --> 01:12:36,100
cuando no lo hace necesariamente
entender, apreciar, o anticipar

1475
01:12:36,100 --> 01:12:38,640
ese tipo de errores.

1476
01:12:38,640 --> 01:12:42,030
>> Por lo tanto, resulta que hay otro
Lo malo de representación de datos.

1477
01:12:42,030 --> 01:12:47,080
Resulta que incluso flotadores son
tipo de fallas, debido a los flotadores, también,

1478
01:12:47,080 --> 01:12:51,440
Propuse son de 32 bits, o
quizá 64 si se utiliza un doble.

1479
01:12:51,440 --> 01:12:53,070
Pero eso es finito.

1480
01:12:53,070 --> 01:12:57,070
>> Y el problema es que si se puede
poner un número infinito de números

1481
01:12:57,070 --> 01:12:59,460
después del punto decimal,
no hay manera de que

1482
01:12:59,460 --> 01:13:02,690
puede representar todo lo posible
números que nos enseñaron

1483
01:13:02,690 --> 01:13:04,990
en el grado de la escuela puede existir en el mundo.

1484
01:13:04,990 --> 01:13:08,870
Un equipo que, en esencia, tiene que
elegir un subconjunto de esos números

1485
01:13:08,870 --> 01:13:10,200
para representar con precisión.

1486
01:13:10,200 --> 01:13:12,450
>> Ahora, el equipo puede
ronda tal vez un poco,

1487
01:13:12,450 --> 01:13:17,900
y le puede permitir a aproximadamente el almacén
cualquier número que posiblemente podría desear.

1488
01:13:17,900 --> 01:13:20,940
Pero sólo intuitivamente, si
tener un número finito de bits,

1489
01:13:20,940 --> 01:13:24,560
sólo se puede permutar ellas
de muchas maneras finitos.

1490
01:13:24,560 --> 01:13:26,570
Por lo que no puede posiblemente
utilizar un número finito

1491
01:13:26,570 --> 01:13:29,880
de permutación de bits,
patrones de ceros y unos,

1492
01:13:29,880 --> 01:13:32,940
para representar un infinito
número de números,

1493
01:13:32,940 --> 01:13:37,370
lo que sugiere que los ordenadores podrían
muy bien ser mintiendo a nosotros a veces.

1494
01:13:37,370 --> 01:13:38,770
>> De hecho, vamos a hacer esto.

1495
01:13:38,770 --> 01:13:41,239
Déjame volver al IDE CS50.

1496
01:13:41,239 --> 01:13:43,030
Déjame ir adelante y
crear un pequeño programa

1497
01:13:43,030 --> 01:13:47,940
La imprecisión llamada, para mostrar que
las computadoras son, de hecho, imprecisa.

1498
01:13:47,940 --> 01:13:51,910
>> Y déjame seguir adelante y comenzar con
algunos de que el código de antes,

1499
01:13:51,910 --> 01:13:53,830
y ahora acaba de hacer lo siguiente.

1500
01:13:53,830 --> 01:14:03,640
Déjame seguir adelante y hacer printf, ciento
f, la barra invertida n, 1 dividido por 10.

1501
01:14:03,640 --> 01:14:07,430
En otras palabras, vamos a bucear en la más profunda
a 1/10, al igual que 1 y dividido por 10.

1502
01:14:07,430 --> 01:14:09,760
Sin duda, una computadora puede representar 1/10.

1503
01:14:09,760 --> 01:14:13,620
>> Así que vamos a seguir adelante y hacer imprecisión.

1504
01:14:13,620 --> 01:14:14,390
Veamos.

1505
01:14:14,390 --> 01:14:16,210
Formato especifica el tipo doble.

1506
01:14:16,210 --> 01:14:18,160
Sin embargo, el argumento tiene tipo int.

1507
01:14:18,160 --> 01:14:19,040
¿Que esta pasando?

1508
01:14:19,040 --> 01:14:21,970
>> Oh, interesante, así que es una
lección aprendida de antes.

1509
01:14:21,970 --> 01:14:26,050
Yo digo, bueno, feria de informática
un flotador con ciento f.

1510
01:14:26,050 --> 01:14:28,200
Pero lo estoy dando 2 enteros.

1511
01:14:28,200 --> 01:14:31,120
Así que resulta, puedo arreglar
esto en un par de maneras.

1512
01:14:31,120 --> 01:14:38,430
>> Tan sólo pudiera convertir en un 1,0, y
10 a 10,0, lo que, de hecho,

1513
01:14:38,430 --> 01:14:42,390
tener el efecto de convertir
ellos en floats-- todavía con suerte

1514
01:14:42,390 --> 01:14:43,180
el mismo numero.

1515
01:14:43,180 --> 01:14:45,880
O resulta que hay algo
veremos de nuevo en poco tiempo.

1516
01:14:45,880 --> 01:14:47,170
Se podría emitir los números.

1517
01:14:47,170 --> 01:14:49,880
>> Puede, el uso de este paréntesis
expresión, se puede decir,

1518
01:14:49,880 --> 01:14:52,560
Hey, ordenador, toma esto
10, que sé que es un int.

1519
01:14:52,560 --> 01:14:54,660
Pero tratarla, por favor,
como si fuera un flotador.

1520
01:14:54,660 --> 01:14:56,680
Pero esto se siente innecesariamente compleja.

1521
01:14:56,680 --> 01:14:59,040
>> Para nuestros propósitos hoy,
sólo vamos a literalmente

1522
01:14:59,040 --> 01:15:02,700
los hacen valores de punto flotante
con un punto decimal, como este.

1523
01:15:02,700 --> 01:15:07,060
Déjame ir adelante y vuelva a ejecutar, hacer
imprecisión, bueno, barra de puntos

1524
01:15:07,060 --> 01:15:08,870
imprecisión, introduzca.

1525
01:15:08,870 --> 01:15:10,990
OK, estamos en buen estado.

1526
01:15:10,990 --> 01:15:18,194
>> 1 dividido por 10, de acuerdo a mi
Mac aquí, es, de hecho, 0,100000.

1527
01:15:18,194 --> 01:15:21,360
Ahora, me enseñaron en la escuela primaria allí
debe ser un número infinito de 0 de.

1528
01:15:21,360 --> 01:15:23,151
Así que vamos a tratar, al menos,
para ver algunos de ellos.

1529
01:15:23,151 --> 01:15:26,770
Resulta que es un poco printf
aún más elegante que hemos estado utilizando.

1530
01:15:26,770 --> 01:15:30,890
Resulta que usted no tiene que especificar
f justo por ciento, o simplemente por ciento i.

1531
01:15:30,890 --> 01:15:33,830
En realidad se puede especificar
algunas opciones de control aquí.

1532
01:15:33,830 --> 01:15:36,470
>> En concreto, voy
decir, hey, printf,

1533
01:15:36,470 --> 01:15:39,660
En realidad me muestran 10 puntos decimales.

1534
01:15:39,660 --> 01:15:40,820
Así que parece un poco raro.

1535
01:15:40,820 --> 01:15:42,845
Pero usted dice por ciento,
punto, la cantidad de números

1536
01:15:42,845 --> 01:15:44,970
desea ver después de la
punto decimal y, a continuación, f

1537
01:15:44,970 --> 01:15:48,340
para plana, simplemente porque eso es
lo que dice la documentación.

1538
01:15:48,340 --> 01:15:50,080
Déjame ir por delante y salvamento de dicha.

1539
01:15:50,080 --> 01:15:52,460
>> Y noto también, que estoy recibiendo
cansado de volver a escribir las cosas.

1540
01:15:52,460 --> 01:15:55,900
Así que estoy estableciendo el y
flecha inferior de mis llaves aquí.

1541
01:15:55,900 --> 01:15:58,710
Y si sigo golpeando para arriba, usted
puede ver todos los comandos

1542
01:15:58,710 --> 01:16:01,090
que hice, o mal hecho.

1543
01:16:01,090 --> 01:16:04,630
>> Y voy a seguir adelante y ahora
en realidad no utilizar que, al parecer.

1544
01:16:04,630 --> 01:16:11,416
Hacer imprecisión, punto
reducir de manera imprecision--

1545
01:16:11,416 --> 01:16:13,290
lo que me enseñaron en
la escuela primaria comprueba hacia fuera.

1546
01:16:13,290 --> 01:16:19,010
Incluso si lo imprimo a 10 decimales
lo sitúa, de hecho, es 0.10000.

1547
01:16:19,010 --> 01:16:19,840
¿Pero sabes que?

1548
01:16:19,840 --> 01:16:21,150
>> Vamos a conseguir un poco codicioso.

1549
01:16:21,150 --> 01:16:23,990
Digamos que, al igual que, muéstrame 55
puntos después del punto decimal.

1550
01:16:23,990 --> 01:16:26,160
Vamos a tomar esto
programar a dar una vuelta.

1551
01:16:26,160 --> 01:16:31,170
Permítanme rehacerla con maquillaje
imprecisión, raya vertical del punto, la imprecisión.

1552
01:16:31,170 --> 01:16:32,390
>> Y aquí vamos.

1553
01:16:32,390 --> 01:16:34,420
Su infancia fue una mentira.

1554
01:16:34,420 --> 01:16:48,410
Al parecer, 1 dividido por 10 es de hecho
0.100000000000000005551115123--

1555
01:16:48,410 --> 01:16:49,740
>> ¿Qué está pasando?

1556
01:16:49,740 --> 01:16:53,360
Pues bien, resulta que, si la clase de
mirar lo suficientemente lejos en el subyacente

1557
01:16:53,360 --> 01:16:55,950
representación de este
número, que en realidad

1558
01:16:55,950 --> 01:17:00,400
no es exactamente 1/10, o el 0,1 y el
un número infinito de ceros.

1559
01:17:00,400 --> 01:17:01,630
Ahora, ¿por qué?

1560
01:17:01,630 --> 01:17:06,250
>> Pues bien, a pesar de que esto es un simple
número a nosotros los seres humanos, 1 dividido por 10,

1561
01:17:06,250 --> 01:17:10,910
aún así es uno de un número infinito
números que podrían imaginar.

1562
01:17:10,910 --> 01:17:14,490
Sin embargo, un equipo sólo puede representar
un número finito de números menos.

1563
01:17:14,490 --> 01:17:18,710
Y así, efectivamente, lo que la
equipo está mostrando nosotros es su punto más cercano

1564
01:17:18,710 --> 01:17:22,940
aproximación al número
queremos creer es 1/10,

1565
01:17:22,940 --> 01:17:27,760
o realmente 0.10000 ad infinitum.

1566
01:17:27,760 --> 01:17:30,425
>> Más bien, sin embargo, esto es
tan cerca como se puede conseguir.

1567
01:17:30,425 --> 01:17:32,300
Y, de hecho, si nos fijamos
debajo de la campana,

1568
01:17:32,300 --> 01:17:37,050
ya que estamos aquí examinado
55 dígitos después del punto decimal,

1569
01:17:37,050 --> 01:17:39,990
que en realidad vemos que la realidad.

1570
01:17:39,990 --> 01:17:42,610
Ahora como un aparte, si no tienes
Alguna vez has visto la movie--

1571
01:17:42,610 --> 01:17:45,780
la mayoría de ustedes probablemente haven't--
pero hace algunos años Superman 3,

1572
01:17:45,780 --> 01:17:49,500
Richard Pryor apalancado fundamentalmente este
la realidad en su compañía para robar una gran cantidad

1573
01:17:49,500 --> 01:17:53,500
de fracciones y fracciones de centavos,
porque el company-- por lo que recuerdo,

1574
01:17:53,500 --> 01:17:57,210
que ha sido un rato-- era esencialmente
tirar cualquier cosa que no encajaba

1575
01:17:57,210 --> 01:17:58,790
en la noción de centavos.

1576
01:17:58,790 --> 01:18:01,480
>> Pero si se suman todos estos
diminutos, diminutos, diminutos números de nuevo,

1577
01:18:01,480 --> 01:18:04,960
y otra vez, y otra vez, se puede, como en
su caso, hacer una buena cantidad de dinero.

1578
01:18:04,960 --> 01:18:08,010
>> Esa misma idea fue arrancada por
una más reciente, pero aún ahora mayores

1579
01:18:08,010 --> 01:18:10,500
película, llamado espacio de oficina,
donde los chicos de esa película,

1580
01:18:10,500 --> 01:18:13,501
hizo lo mismo, metido la pata
por completo, terminado con demasiada

1581
01:18:13,501 --> 01:18:14,666
dinero en su cuenta bancaria.

1582
01:18:14,666 --> 01:18:15,800
Todo era muy sospechoso.

1583
01:18:15,800 --> 01:18:19,290
Pero al final del día,
imprecisión es todo lo que nos rodea.

1584
01:18:19,290 --> 01:18:22,240
>> Y que, también, puede haber
Es alarmante el caso.

1585
01:18:22,240 --> 01:18:25,590
Resulta que Superman 3
y espacio de oficina a un lado, hay

1586
01:18:25,590 --> 01:18:28,460
pueden ser algunas muy real
ramificaciones mundiales

1587
01:18:28,460 --> 01:18:32,290
de las realidades de la imprecisa
representación de datos

1588
01:18:32,290 --> 01:18:34,770
que incluso los seres humanos a
el día de hoy no necesariamente

1589
01:18:34,770 --> 01:18:38,230
entender, así como deberíamos,
o recordar tan a menudo como deberíamos.

1590
01:18:38,230 --> 01:18:42,950
Y, de hecho, el siguiente clip es
a partir de una mirada a un mundo muy real

1591
01:18:42,950 --> 01:18:47,730
ramificaciones de lo que sucede si
no aprecian que la imprecisión

1592
01:18:47,730 --> 01:18:50,065
puede suceder en representación de números.

1593
01:18:50,065 --> 01:18:51,300
>> [REPRODUCCIÓN DE VÍDEO]

1594
01:18:51,300 --> 01:18:55,620
>> -Informática, Todos hemos llegado a aceptar
los problemas a menudo frustrantes que

1595
01:18:55,620 --> 01:19:00,310
ir con ellos-- insectos, virus,
y fallas en el software,

1596
01:19:00,310 --> 01:19:03,130
para los precios de pequeño a pagar
por la comodidad.

1597
01:19:03,130 --> 01:19:07,800
Pero en la alta tecnología y de alta velocidad
aplicaciones de programas espaciales militares y,

1598
01:19:07,800 --> 01:19:12,800
el más pequeño problema puede
magnificarse en el desastre.

1599
01:19:12,800 --> 01:19:18,900
>> El 4 de junio de 1996, los científicos prepararon
para lanzar un cohete no tripulado Ariane 5.

1600
01:19:18,900 --> 01:19:21,220
Llevaba científica
satélites diseñados

1601
01:19:21,220 --> 01:19:24,600
establecer con precisión cómo el
interactúa campo magnético de la Tierra

1602
01:19:24,600 --> 01:19:27,410
con vientos solares.

1603
01:19:27,410 --> 01:19:30,800
El cohete fue construido para
la Agencia Espacial Europea,

1604
01:19:30,800 --> 01:19:34,370
y despegó de sus instalaciones
en la costa de la Guayana francesa.

1605
01:19:34,370 --> 01:19:37,540
>> -En Unos 37 segundos en
el vuelo, primero

1606
01:19:37,540 --> 01:19:39,270
dado cuenta de que algo iba mal.

1607
01:19:39,270 --> 01:19:42,250
Las boquillas se gira sobre un eje en
de manera que en realidad no debería.

1608
01:19:42,250 --> 01:19:46,580
Alrededor de 40 segundos de vuelo,
claramente, el vehículo estaba en problemas.

1609
01:19:46,580 --> 01:19:48,850
>> Y eso es cuando hicieron
una decisión de destruirlo.

1610
01:19:48,850 --> 01:19:52,780
El oficial de seguridad de gama, con
tremendas agallas, pulsa el botón,

1611
01:19:52,780 --> 01:19:58,150
explotó el cohete, antes de que pudiera
convertirse en un peligro para la seguridad pública.

1612
01:19:58,150 --> 01:20:01,060
>> -Esta Era la doncella
viaje del Ariane 5.

1613
01:20:01,060 --> 01:20:03,960
Y su destrucción se llevó
lugar debido a un defecto

1614
01:20:03,960 --> 01:20:05,822
incrustado en el software del cohete.

1615
01:20:05,822 --> 01:20:08,280
-El Problema fue en el Ariane
que había un número que

1616
01:20:08,280 --> 01:20:10,600
requiere 64 bits para expresar.

1617
01:20:10,600 --> 01:20:13,590
Y querían convertir
a un número de 16 bits.

1618
01:20:13,590 --> 01:20:15,610
Se supone que la
número nunca se va

1619
01:20:15,610 --> 01:20:20,980
a ser muy grande, que la mayoría de las
dígitos en un número de 64 bits eran ceros.

1620
01:20:20,980 --> 01:20:22,440
Ellos estaban equivocados.

1621
01:20:22,440 --> 01:20:25,060
>> -La Incapacidad de una
programa de software para aceptar

1622
01:20:25,060 --> 01:20:29,510
el tipo de número generado por
otra fue la causa de la falla.

1623
01:20:29,510 --> 01:20:34,350
El desarrollo de software se había convertido en una
parte muy costosa de las nuevas tecnologías.

1624
01:20:34,350 --> 01:20:38,140
El cohete Ariane han sido muy
éxito, por lo que gran parte del software

1625
01:20:38,140 --> 01:20:41,550
creado para ella también era
utilizado en el Ariane 5.

1626
01:20:41,550 --> 01:20:47,940
>> -El Problema básico era que el Ariane
5 fue más rápida, se aceleró más rápidamente.

1627
01:20:47,940 --> 01:20:51,450
Y el software no tenía
representaron para eso.

1628
01:20:51,450 --> 01:20:55,060
>> -La Destrucción del cohete
Fue un gran desastre financiero,

1629
01:20:55,060 --> 01:20:58,790
todo se debe a un error de software minuto.

1630
01:20:58,790 --> 01:21:01,210
Pero esta no fue la primera
problemas de conversión de datos de tiempo

1631
01:21:01,210 --> 01:21:04,820
había plagado la tecnología de cohetes moderna.

1632
01:21:04,820 --> 01:21:08,050
>> -En 1991, con el inicio
de la primera Guerra del Golfo,

1633
01:21:08,050 --> 01:21:10,570
el misil de patriota
experimentado una clase similar

1634
01:21:10,570 --> 01:21:12,800
del problema de la conversión número.

1635
01:21:12,800 --> 01:21:16,090
Y como resultado, 28 personas,
28 soldados estadounidenses,

1636
01:21:16,090 --> 01:21:19,080
fueron asesinados, y sobre
otros 100 heridos,

1637
01:21:19,080 --> 01:21:22,780
cuando el patriota, que se suponía
para proteger contra scuds entrantes,

1638
01:21:22,780 --> 01:21:25,830
dejado de disparar un misil.

1639
01:21:25,830 --> 01:21:31,670
>> -Cuando Irak invadió Kuwait, y América
Tormenta del Desierto lanzado a principios de 1991,

1640
01:21:31,670 --> 01:21:35,780
baterías de misiles Patriot fueron desplegados
para proteger a Arabia Saudita e Israel

1641
01:21:35,780 --> 01:21:39,230
de los ataques de misiles Scud iraquíes.

1642
01:21:39,230 --> 01:21:43,810
El Patriot es un medio de rango de EE.UU.
superficie para sistema de aire, fabricado

1643
01:21:43,810 --> 01:21:45,770
por la empresa Raytheon.

1644
01:21:45,770 --> 01:21:52,340
>> -El Tamaño de los interceptores Patriot
sí está a más o menos 20 pies de largo.

1645
01:21:52,340 --> 01:21:55,230
Y pesa alrededor de 2.000 libras.

1646
01:21:55,230 --> 01:21:59,320
Y lleva una ojiva de alrededor,
Creo que es más o menos 150 libras.

1647
01:21:59,320 --> 01:22:03,930
Y la cabeza de combate en sí es
un explosivo de alta potencia, que

1648
01:22:03,930 --> 01:22:07,330
tiene fragmentos alrededor de ella.

1649
01:22:07,330 --> 01:22:11,680
La carcasa de la cabeza de combate es
diseñado para actuar como perdigones.

1650
01:22:11,680 --> 01:22:14,110
>> -Los Misiles se llevan
cuatro por contenedor,

1651
01:22:14,110 --> 01:22:17,130
y son transportados por un semi-remolque.

1652
01:22:17,130 --> 01:22:24,930
>> -El Sistema Patriot antimisiles
se remonta por lo menos 20 años.

1653
01:22:24,930 --> 01:22:28,420
Fue diseñado originalmente
como un misil de defensa aérea

1654
01:22:28,420 --> 01:22:30,720
para derribar aviones enemigos.

1655
01:22:30,720 --> 01:22:34,500
En la primera guerra del Golfo,
cuando la guerra llegó,

1656
01:22:34,500 --> 01:22:39,745
el Ejército quería utilizarlo para
derribar scuds, no aeroplanos.

1657
01:22:39,745 --> 01:22:43,620
>> La Fuerza Aérea Iraquí fue
no tanto de un problema.

1658
01:22:43,620 --> 01:22:46,670
Pero el ejército estaba preocupado por scuds.

1659
01:22:46,670 --> 01:22:50,170
Y por lo que trataron de
actualizar el Patriot.

1660
01:22:50,170 --> 01:22:52,800
>> -Intercepting Un enemigo
misil que viaja a Mach 5

1661
01:22:52,800 --> 01:22:55,830
que iba a ser un reto suficiente.

1662
01:22:55,830 --> 01:22:58,490
Pero cuando el Patriot
fue trasladado de urgencia en servicio,

1663
01:22:58,490 --> 01:23:02,860
el Ejército no estaba al tanto de una
modificación iraquí que hizo

1664
01:23:02,860 --> 01:23:05,930
sus scuds casi imposible de golpear.

1665
01:23:05,930 --> 01:23:10,740
>> -Lo Que pasa es que los scuds
llegaban eran inestables.

1666
01:23:10,740 --> 01:23:11,692
Fueron desplazamiento.

1667
01:23:11,692 --> 01:23:14,910
La razón de esto era
los iraquíes, con el fin

1668
01:23:14,910 --> 01:23:18,280
para llegar a 600 kilómetros
fuera de un 300 kilometros

1669
01:23:18,280 --> 01:23:21,700
alcance de los misiles, tomó el peso
fuera de la ojiva delantera.

1670
01:23:21,700 --> 01:23:23,390
Hicieron la ojiva más ligero.

1671
01:23:23,390 --> 01:23:27,330
>> Así que ahora el Patriot es
tratando de llegar a la Scud.

1672
01:23:27,330 --> 01:23:30,230
Y la mayoría de las veces, la
inmensa mayoría de las veces,

1673
01:23:30,230 --> 01:23:32,940
sería simplemente salir volando por el Scud.

1674
01:23:32,940 --> 01:23:37,260
Una vez que los operadores del sistema Patriot
se dio cuenta de la Patriot no alcanzó su objetivo,

1675
01:23:37,260 --> 01:23:41,690
detonar la ojiva del Patriota
para evitar posibles bajas si

1676
01:23:41,690 --> 01:23:44,570
se dejó caer al suelo.

1677
01:23:44,570 --> 01:23:48,790
>> Eso fue lo que vieron la mayoría de la gente,
esas grandes bolas de fuego en el cielo,

1678
01:23:48,790 --> 01:23:54,550
y malinterpretado como
intercepciones de ojivas Scud.

1679
01:23:54,550 --> 01:23:56,630
>> -Aunque En la noche
cielos, patriotas apareció

1680
01:23:56,630 --> 01:24:00,370
ser con éxito
la destrucción de misiles Scud, en Dhahran,

1681
01:24:00,370 --> 01:24:03,360
no podía haber error
sobre su rendimiento.

1682
01:24:03,360 --> 01:24:07,970
Allí, sistema de radar de la Patriot
perdido la pista de un Scud entrante,

1683
01:24:07,970 --> 01:24:10,721
y nunca puesto en marcha debido
a un defecto de software.

1684
01:24:10,721 --> 01:24:14,090

1685
01:24:14,090 --> 01:24:18,940
Fueron los israelíes que se descubrió por primera vez
que cuanto más tiempo el sistema estaba en marcha,

1686
01:24:18,940 --> 01:24:22,690
cuanto mayor es la discrepancia de tiempo
se convirtió, debido a un reloj incorporado

1687
01:24:22,690 --> 01:24:24,810
en el ordenador del sistema.

1688
01:24:24,810 --> 01:24:28,210
>> -Acerca De dos semanas antes
la tragedia en Dhahran,

1689
01:24:28,210 --> 01:24:30,770
los israelíes informaron de
el Departamento de Defensa

1690
01:24:30,770 --> 01:24:32,590
que el sistema estaba perdiendo el tiempo.

1691
01:24:32,590 --> 01:24:35,360
Después de cerca de ocho horas o en ejecución,
se dieron cuenta de que el sistema de

1692
01:24:35,360 --> 01:24:37,720
fue que se vea con menos precisa.

1693
01:24:37,720 --> 01:24:41,900
El Departamento de Defensa respondió
diciendo a todas las baterías Patriot

1694
01:24:41,900 --> 01:24:44,950
para no dejar los sistemas
durante mucho tiempo.

1695
01:24:44,950 --> 01:24:49,160
Nunca dijeron lo mucho tiempo era--
ocho horas, 10 horas, 1.000 horas.

1696
01:24:49,160 --> 01:24:51,360
Nadie sabía.

1697
01:24:51,360 --> 01:24:53,380
>> -La Batería Patriot
estacionados en los cuarteles

1698
01:24:53,380 --> 01:24:58,350
en Dhahran y su deficiente interna
reloj había estado en más de 100 horas

1699
01:24:58,350 --> 01:25:01,670
en la noche del 25 de febrero.

1700
01:25:01,670 --> 01:25:05,917
>> -Es Seguido de tiempo con una precisión
de alrededor de un décimo de un segundo.

1701
01:25:05,917 --> 01:25:08,000
Ahora, un décimo de un segundo
es un número interesante,

1702
01:25:08,000 --> 01:25:11,920
debido a que no se puede expresar
en binario exactamente, que

1703
01:25:11,920 --> 01:25:16,820
significa que no se puede expresar exactamente
en cualquier computadora digital moderna.

1704
01:25:16,820 --> 01:25:18,540
Es difícil de creer.

1705
01:25:18,540 --> 01:25:21,210
>> Pero utilizar esto como un ejemplo.

1706
01:25:21,210 --> 01:25:23,540
Tomemos el número de un tercio.

1707
01:25:23,540 --> 01:25:27,350
Una tercera no puede ser
expresado en decimal exactamente.

1708
01:25:27,350 --> 01:25:32,080
Una tercera parte es 0,333
pasando por el infinito.

1709
01:25:32,080 --> 01:25:36,480
>> No hay manera de hacer eso con
la precisión absoluta en decimal.

1710
01:25:36,480 --> 01:25:39,560
Ese es exactamente el tipo de problema
Eso ocurrió en el Patriot.

1711
01:25:39,560 --> 01:25:44,100
Cuanto más largo sea el sistema funcionó, la
se convirtió en el peor error de tiempo.

1712
01:25:44,100 --> 01:25:48,890
>> -Después De 100 horas de funcionamiento, el
de error en el tiempo era sólo alrededor de un tercio

1713
01:25:48,890 --> 01:25:50,600
de un segundo.

1714
01:25:50,600 --> 01:25:54,210
Pero en términos de focalización una
misil que viaja a Mach 5,

1715
01:25:54,210 --> 01:25:58,710
que dio lugar a un seguimiento
de error de más de 600 metros.

1716
01:25:58,710 --> 01:26:02,120
Sería un error grave
para los soldados en lo

1717
01:26:02,120 --> 01:26:08,940
se pasó una lancha era Scud
detectado por los satélites de alerta temprana

1718
01:26:08,940 --> 01:26:12,860
y sabían que era el Scud
viniendo en su dirección general.

1719
01:26:12,860 --> 01:26:15,320
Ellos no sabían de dónde venía.

1720
01:26:15,320 --> 01:26:18,250
>> -Fue Hasta ahora el radar
componente del sistema Patriot

1721
01:26:18,250 --> 01:26:23,190
la defensa de Dhahran para localizar y mantener
pista del misil enemigo entrante.

1722
01:26:23,190 --> 01:26:24,609
>> -El Radar era muy inteligente.

1723
01:26:24,609 --> 01:26:26,650
Sería realmente un seguimiento
la posición del Scud,

1724
01:26:26,650 --> 01:26:30,350
y luego predecir donde probablemente
sería la próxima vez que el radar envió

1725
01:26:30,350 --> 01:26:31,420
Un pulso a cabo.

1726
01:26:31,420 --> 01:26:33,110
Que se llamó una puerta de distancia.

1727
01:26:33,110 --> 01:26:37,660
>> -Entonces, Una vez que el Patriot
decide el tiempo suficiente tiene

1728
01:26:37,660 --> 01:26:42,450
pasó a volver atrás y comprobar la siguiente
ubicación para este objeto detectado,

1729
01:26:42,450 --> 01:26:43,600
que se remonta.

1730
01:26:43,600 --> 01:26:48,650
Así que cuando se volvió al mal
lugar, a continuación, no ve ningún objeto.

1731
01:26:48,650 --> 01:26:52,160
Y decide que no había
objeto, que era una falsa detección,

1732
01:26:52,160 --> 01:26:53,930
y deja caer la pista.

1733
01:26:53,930 --> 01:26:57,030
>> -La Entrante Scud desapareció
desde la pantalla de radar.

1734
01:26:57,030 --> 01:27:00,260
Y segundos más tarde,
chocó contra el cuartel.

1735
01:27:00,260 --> 01:27:06,150
El Scud mató a 28, y fue el último
uno disparadas durante la primera Guerra del Golfo.

1736
01:27:06,150 --> 01:27:11,960
>> Trágicamente, el software actualizado
llegado a Dhahran el día siguiente.

1737
01:27:11,960 --> 01:27:14,930
La falla de software tenía
sido fijado, el cierre

1738
01:27:14,930 --> 01:27:19,806
un capítulo en el problemático
la historia del misil Patriot.

1739
01:27:19,806 --> 01:27:20,729
>> [REPRODUCCIÓN DE VÍDEO]

1740
01:27:20,729 --> 01:27:23,520
DAVID J. MALAN: Así que esto es todo lo que
decir que estos problemas de desbordamiento

1741
01:27:23,520 --> 01:27:25,860
e imprecisión son demasiado reales.

1742
01:27:25,860 --> 01:27:26,920
Entonces ... ¿cómo fue que llegamos aquí?

1743
01:27:26,920 --> 01:27:28,895
Comenzamos con sólo hablar de printf.

1744
01:27:28,895 --> 01:27:31,270
Una vez más, esta función que
imprime algo a la pantalla,

1745
01:27:31,270 --> 01:27:33,450
y se introdujo a partir de entonces
algunas otras funciones

1746
01:27:33,450 --> 01:27:34,945
de la llamada biblioteca de CS50.

1747
01:27:34,945 --> 01:27:36,910
Y vamos a seguir
ver éstos a su debido tiempo.

1748
01:27:36,910 --> 01:27:40,760
Y nosotros, en particular, utilizamos cadena GET,
y obtener int, y ahora también obtener flotador,

1749
01:27:40,760 --> 01:27:44,410
y sin embargo, otros todavía nos encontramos con
y el uso de nosotros mismos antes de tiempo.

1750
01:27:44,410 --> 01:27:47,220
>> Sin embargo, en ocasiones, tienen
ya visto una necesidad

1751
01:27:47,220 --> 01:27:50,520
para almacenar lo que esas funciones mano hacia atrás?

1752
01:27:50,520 --> 01:27:52,920
Nos volver una secuencia de la mano,
o un int o un flotador.

1753
01:27:52,920 --> 01:27:56,070
Y a veces tenemos que poner eso
cadena, o int o float, en alguna parte.

1754
01:27:56,070 --> 01:28:00,100
>> Y para almacenar esas cosas, recuperar únicamente
al igual que en Scratch, tenemos variables.

1755
01:28:00,100 --> 01:28:03,260
Pero a diferencia de los arañazos,
en C tenemos tipos reales

1756
01:28:03,260 --> 01:28:05,530
de los datos variables--
tipos, más generally--

1757
01:28:05,530 --> 01:28:08,640
entre ellos, una cadena, un entero, una
flotar, y estos otros aún.

1758
01:28:08,640 --> 01:28:12,321
>> Y así, cuando declaramos las variables en C,
tendremos que declarar los tipos de datos.

1759
01:28:12,321 --> 01:28:14,820
Esto no es algo que vamos a
tener que hacer más adelante en el semestre

1760
01:28:14,820 --> 01:28:16,810
a medida que pasamos a otros idiomas.

1761
01:28:16,810 --> 01:28:19,610
Pero por ahora, necesitamos
a a priori por adelantado,

1762
01:28:19,610 --> 01:28:24,370
explicar a la computadora qué tipo de
de la variable que queremos que nos dan.

1763
01:28:24,370 --> 01:28:27,290
>> Ahora, mientras tanto, para imprimir
esos tipos de tipos de datos,

1764
01:28:27,290 --> 01:28:29,570
tenemos que decirle a printf qué esperar.

1765
01:28:29,570 --> 01:28:32,450
Y vimos ciento s para cuerdas,
y el porcentaje de i para enteros,

1766
01:28:32,450 --> 01:28:33,790
y algunos otros ya.

1767
01:28:33,790 --> 01:28:37,237
Y esos son sólo los requisitos
para la presentación visual

1768
01:28:37,237 --> 01:28:38,070
de esa información.

1769
01:28:38,070 --> 01:28:42,080
>> Y cada uno de estos puede ser realidad
parametrizada o ajustado de alguna manera,

1770
01:28:42,080 --> 01:28:45,370
si desea avanzar en el control
el tipo de salida que se obtiene.

1771
01:28:45,370 --> 01:28:49,604
Y, de hecho, resulta que no sólo
¿hay barra invertida n para una nueva línea.

1772
01:28:49,604 --> 01:28:52,520
Hay otra cosa llamada barra invertida
r para un retorno de carro, el cual

1773
01:28:52,520 --> 01:28:54,360
se parece más a una
máquina de escribir vieja escuela,

1774
01:28:54,360 --> 01:28:57,690
y también de Windows utiliza para muchos años.

1775
01:28:57,690 --> 01:28:59,690
>> Hay t barra invertida para las pestañas.

1776
01:28:59,690 --> 01:29:03,170
Resulta, que si se quiere
comillas dobles dentro de una cadena,

1777
01:29:03,170 --> 01:29:05,000
Recordemos que hemos utilizado
doble comillas dobles

1778
01:29:05,000 --> 01:29:07,900
cotización de la izquierda y la derecha
termina de nuestras cuerdas hasta el momento.

1779
01:29:07,900 --> 01:29:09,420
Esto parece confundir las cosas.

1780
01:29:09,420 --> 01:29:12,503
>> Si usted quiere poner una doble cita en
el medio de un string-- y, de hecho,

1781
01:29:12,503 --> 01:29:13,670
es confuso para ver.

1782
01:29:13,670 --> 01:29:17,120
Y lo que tiene que escapar, por lo que
hablar, una doble cita con algo

1783
01:29:17,120 --> 01:29:18,860
al igual que, literalmente, la barra invertida comillas dobles.

1784
01:29:18,860 --> 01:29:20,230
Y hay algunos otros todavía.

1785
01:29:20,230 --> 01:29:24,540
Y veremos más de esos
en el uso real en poco tiempo.

1786
01:29:24,540 --> 01:29:27,930
>> Así que ahora transición de
de datos, y la representación,

1787
01:29:27,930 --> 01:29:30,820
y operadores aritméticos, todo
de lo que nos dio algún edificio

1788
01:29:30,820 --> 01:29:32,070
bloques con las cuales jugar.

1789
01:29:32,070 --> 01:29:34,481
Pero ahora vamos a dar realidad
nosotros el resto del vocabulario

1790
01:29:34,481 --> 01:29:36,230
que ya teníamos
la semana pasada con los arañazos

1791
01:29:36,230 --> 01:29:39,350
por echar un vistazo en algún otro
construcciones en C-- no todos ellos.

1792
01:29:39,350 --> 01:29:41,680
Pero las ideas que están
punto de ver realmente sólo

1793
01:29:41,680 --> 01:29:45,610
hacer hincapié en la traducción de
un idioma, Scratch, a otro, C.

1794
01:29:45,610 --> 01:29:48,470
>> Y con el tiempo, vamos a recoger
más herramientas para nuestra caja de herramientas,

1795
01:29:48,470 --> 01:29:49,820
por así decirlo, sintácticamente.

1796
01:29:49,820 --> 01:29:54,190
Y, de hecho, se verá que las ideas
ahora son bastante familiar de la semana pasada.

1797
01:29:54,190 --> 01:29:55,200
Así que vamos a hacer esto.

1798
01:29:55,200 --> 01:29:58,870
>> Vamos a seguir adelante y preparar rápidamente un programa
que realmente utiliza algunas expresiones,

1799
01:29:58,870 --> 01:30:00,720
una expresión booleana.

1800
01:30:00,720 --> 01:30:02,810
Déjame ir por delante aquí
y crear un nuevo archivo.

1801
01:30:02,810 --> 01:30:06,090
Voy a llamar a este condition.c.

1802
01:30:06,090 --> 01:30:09,350
>> Déjame ir adelante y
incluir la biblioteca CS50.

1803
01:30:09,350 --> 01:30:12,640
Y me dejó ir adelante y incluyo
io.h estándar para nuestras funciones,

1804
01:30:12,640 --> 01:30:14,690
y printf, y mucho más, respectivamente.

1805
01:30:14,690 --> 01:30:18,900
Permítanme que me entrego repetitivo de
int vacío principal, cuya explicación vamos a

1806
01:30:18,900 --> 01:30:20,360
volver en el futuro.

1807
01:30:20,360 --> 01:30:23,820
>> Ahora voy a seguir adelante y dar
a mí mismo a través de un int int get.

1808
01:30:23,820 --> 01:30:25,970
Entonces déjame seguir adelante y hacer esto.

1809
01:30:25,970 --> 01:30:30,150
Quiero decir, si i es less-- de dejar
distinguir entre positivo y negativo,

1810
01:30:30,150 --> 01:30:31,260
o valores cero.

1811
01:30:31,260 --> 01:30:36,630
>> Así que si i es menor que cero, me dejó
Sólo tiene este programa simplemente decir,

1812
01:30:36,630 --> 01:30:42,370
negativo, barra invertida n, de lo
Si i es mayor que cero.

1813
01:30:42,370 --> 01:30:47,030
Ahora estoy, por supuesto, va a decir
printf positivo, la barra invertida n.

1814
01:30:47,030 --> 01:30:50,690
Y luego otra cosa si: Yo podría hacer esto.

1815
01:30:50,690 --> 01:30:53,410
>> Yo podría hacer si i es igual a 0.

1816
01:30:53,410 --> 01:30:55,840
Pero estaría haciendo en
menos un error ya.

1817
01:30:55,840 --> 01:30:59,480
Recordemos que el signo igual es
no es igual, ya que los seres humanos lo saben.

1818
01:30:59,480 --> 01:31:01,010
>> Pero es el operador de asignación.

1819
01:31:01,010 --> 01:31:05,640
Y nosotros no queremos tener 0 en el
la derecha y la puso en i de la izquierda.

1820
01:31:05,640 --> 01:31:11,810
Así que para evitar esta confusión, o
quizá el mal uso del signo igual,

1821
01:31:11,810 --> 01:31:14,740
los seres humanos decidieron hace algunos años
que en muchos lenguajes de programación

1822
01:31:14,740 --> 01:31:18,000
cuando se quiere comprobar la igualdad
entre la izquierda y la derecha,

1823
01:31:18,000 --> 01:31:19,635
en realidad se utiliza es igual a los iguales.

1824
01:31:19,635 --> 01:31:21,010
De manera que pegarle el signo igual dos veces.

1825
01:31:21,010 --> 01:31:25,600
Cuando se desea asignar de derecha
a la izquierda, se utiliza un solo signo igual.

1826
01:31:25,600 --> 01:31:29,360
Por lo que podíamos hacer otra cosa esto-
Si i es igual a igual a cero.

1827
01:31:29,360 --> 01:31:31,710
>> Entonces podría ir y
abrir mis llaves,

1828
01:31:31,710 --> 01:31:36,087
y decir, printf 0, la barra invertida n, hecho.

1829
01:31:36,087 --> 01:31:38,170
Pero recuerda cómo estos
bifurcaciones en el camino pueden trabajar.

1830
01:31:38,170 --> 01:31:39,836
Y, en realidad, sólo pensar en la lógica.

1831
01:31:39,836 --> 01:31:41,510
i es un número.

1832
01:31:41,510 --> 01:31:43,320
Es un número entero, específicamente.

1833
01:31:43,320 --> 01:31:48,600
Y eso significa que va a ser menos
de 0, o mayor que 0, o 0.

1834
01:31:48,600 --> 01:31:51,600
Así que hay una especie de este
caso por defecto implícito.

1835
01:31:51,600 --> 01:31:54,920
>> Y así podríamos, al igual
Cero, prescindir de la persona si,

1836
01:31:54,920 --> 01:31:55,747
y decir otra cosa.

1837
01:31:55,747 --> 01:31:57,830
Lógicamente, si el
programador sabe que sólo hay

1838
01:31:57,830 --> 01:32:01,635
tres cubos en los que una
escenario puede fall-- la primera,

1839
01:32:01,635 --> 01:32:03,510
la segunda, o la tercera
en este caso-- no hacer

1840
01:32:03,510 --> 01:32:07,100
molestar a la adición de la precisión adicional
y la lógica adicional allí.

1841
01:32:07,100 --> 01:32:09,690
Sólo seguir adelante con el
caso por defecto aquí de otra cosa.

1842
01:32:09,690 --> 01:32:11,950
>> Ahora, vamos a seguir adelante
después de salvar esto, hacer

1843
01:32:11,950 --> 01:32:15,760
condiciones salpican reducir conditions--
no una gran interfaz de usuario,

1844
01:32:15,760 --> 01:32:18,914
porque no me llevó a la
usuario, como he mencionado anteriormente.

1845
01:32:18,914 --> 01:32:19,580
Pero eso está bien.

1846
01:32:19,580 --> 01:32:20,454
Vamos a mantenerlo simple.

1847
01:32:20,454 --> 01:32:21,890
Vamos a intentar el número 42.

1848
01:32:21,890 --> 01:32:23,240
Y eso es positivo.

1849
01:32:23,240 --> 01:32:26,120
Vamos a intentar el número
42 negativo, negativo.

1850
01:32:26,120 --> 01:32:28,244
>> Vamos a probar el valor 0.

1851
01:32:28,244 --> 01:32:29,160
Y, de hecho, funciona.

1852
01:32:29,160 --> 01:32:33,900
Ahora, verá con problemas antes
de largo, lo que se prueba tres veces,

1853
01:32:33,900 --> 01:32:34,980
probablemente no es suficiente.

1854
01:32:34,980 --> 01:32:37,438
Es posible que desee probar algunos
números más grandes, algunos más pequeños

1855
01:32:37,438 --> 01:32:40,520
números, algunos casos de esquina, como
vamos a venir para describirlos.

1856
01:32:40,520 --> 01:32:42,500
>> Pero, por ahora, se trata de una
programa bastante simple.

1857
01:32:42,500 --> 01:32:45,160
Y estoy bastante seguro de que, lógicamente,
que se divide en tres casos.

1858
01:32:45,160 --> 01:32:49,360
Y, de hecho, a pesar de que sólo
centrado en los aspectos negativos potenciales

1859
01:32:49,360 --> 01:32:53,480
de imprecisión y de desbordamiento, en
realidad en la que muchos de los problemas del CS50,

1860
01:32:53,480 --> 01:32:56,000
nosotros no nos vamos a preocupar
sobre, todo el tiempo,

1861
01:32:56,000 --> 01:32:59,050
las cuestiones de desbordamiento y
imprecisión, porque, de hecho, en C,

1862
01:32:59,050 --> 01:33:01,889
no es en realidad todo lo que
fácil de evitar esas cosas.

1863
01:33:01,889 --> 01:33:04,180
Si desea contar hasta
más grande y más grande, y más grande,

1864
01:33:04,180 --> 01:33:07,510
Resulta que hay técnicas que
se puede utilizar, a menudo con cosas llamadas

1865
01:33:07,510 --> 01:33:11,240
bibliotecas, colecciones de código, que las
otras personas escribieron que puede utilizar,

1866
01:33:11,240 --> 01:33:13,910
y otros lenguajes como
Java y otros, en realidad

1867
01:33:13,910 --> 01:33:15,800
hacer que sea mucho más fácil
a contar incluso más alto.

1868
01:33:15,800 --> 01:33:19,810
Por lo que realmente es que algunos de estos peligros
en función del idioma que utilice.

1869
01:33:19,810 --> 01:33:22,710
Y en las próximas semanas, vamos a
ver lo peligroso C realmente

1870
01:33:22,710 --> 01:33:24,950
puede ser si no se utiliza correctamente.

1871
01:33:24,950 --> 01:33:27,610
Pero a partir de ahí, y con
Python y JavaScript, se

1872
01:33:27,610 --> 01:33:32,620
nos capa en algunas protecciones adicionales,
y correr menos de esos riesgos.

1873
01:33:32,620 --> 01:33:35,820
>> Así que vamos a hacer un poco más
lógica interesante en nuestro programa.

1874
01:33:35,820 --> 01:33:39,110
Así que permítanme seguir adelante y crear
un programa llamado Logical

1875
01:33:39,110 --> 01:33:43,804
para que yo pueda jugar con algunos
la lógica real, logical.c.

1876
01:33:43,804 --> 01:33:46,870
Voy a copiar y pegar algunos
código de antes, así que regrese

1877
01:33:46,870 --> 01:33:49,950
a este bonito punto de partida.

1878
01:33:49,950 --> 01:33:53,980
>> Concédeme tiempo hacer C. carbón estoy
va a darle un nombre de C

1879
01:33:53,980 --> 01:33:58,510
sólo porque es convencional,
obtener un personaje del usuario.

1880
01:33:58,510 --> 01:34:00,730
Y vamos a suponer como
Estoy poniendo en práctica parte

1881
01:34:00,730 --> 01:34:04,130
de ese programa Rm, el remove
programa antes de que se le solicite al usuario

1882
01:34:04,130 --> 01:34:05,400
para eliminar un archivo.

1883
01:34:05,400 --> 01:34:06,750
¿Cómo podemos hacer esto?

1884
01:34:06,750 --> 01:34:11,090
>> Quiero decir, si C es igual
iguales, entre comillas,

1885
01:34:11,090 --> 01:34:16,304
y, a continuación, voy a asumir
que el usuario ha elegido sí.

1886
01:34:16,304 --> 01:34:17,470
Yo sólo voy a imprimir sí.

1887
01:34:17,470 --> 01:34:19,440
Si verdaderamente estuviera escribiendo
el programa de eliminación,

1888
01:34:19,440 --> 01:34:21,420
podríamos quitar el archivo
con más líneas de código.

1889
01:34:21,420 --> 01:34:22,461
Pero vamos a mantener las cosas simples.

1890
01:34:22,461 --> 01:34:25,950

1891
01:34:25,950 --> 01:34:31,250
>> Porque si c es igual a igual n-
y ahora aquí, que voy a decir,

1892
01:34:31,250 --> 01:34:32,980
el usuario debe haber querido decir que no.

1893
01:34:32,980 --> 01:34:34,360
Y luego otra cosa, ¿sabes qué?

1894
01:34:34,360 --> 01:34:36,200
No sé qué otra cosa
el usuario va a escribir.

1895
01:34:36,200 --> 01:34:38,533
Así que sólo voy a decir que
que es un error, lo

1896
01:34:38,533 --> 01:34:40,070
él o ella realmente escrito.

1897
01:34:40,070 --> 01:34:41,180
>> Entonces, ¿qué está pasando aquí?

1898
01:34:41,180 --> 01:34:44,530
Existe una diferencia fundamental
frente a lo que he hecho en el pasado.

1899
01:34:44,530 --> 01:34:49,300
Las comillas dobles, comillas dobles, doble
citas, y, sin embargo, comillas simples,

1900
01:34:49,300 --> 01:34:50,170
comillas simples.

1901
01:34:50,170 --> 01:34:52,860
Resulta que en C, que cuando
desea escribir una cadena,

1902
01:34:52,860 --> 01:34:56,680
usted hace uso de comillas dobles, así como nosotros hemos
estado usando todo este tiempo con printf.

1903
01:34:56,680 --> 01:35:02,030
>> Pero si usted quiere tratar con sólo una
carácter individual, un llamado char,

1904
01:35:02,030 --> 01:35:03,780
a continuación, que realmente utiliza comillas simples.

1905
01:35:03,780 --> 01:35:05,450
Aquellos de ustedes que han programado
antes, puede que no tenga

1906
01:35:05,450 --> 01:35:07,850
tenía que preocuparse por esto
distinción en determinados idiomas.

1907
01:35:07,850 --> 01:35:09,450
En C, sí importa.

1908
01:35:09,450 --> 01:35:12,560
Y así, cuando llegue a un char y quiero
comparar ese carbón utilizando iguales

1909
01:35:12,560 --> 01:35:18,350
es igual a alguna carta como S o N, hago,
de hecho, necesita tener las comillas simples.

1910
01:35:18,350 --> 01:35:19,770
>> Ahora, vamos a seguir adelante y hacer esto.

1911
01:35:19,770 --> 01:35:26,180
Vamos a seguir adelante y hacer realiza
dot lógicas slash lógico.

1912
01:35:26,180 --> 01:35:27,305
Y ahora estoy que se le pida.

1913
01:35:27,305 --> 01:35:30,638
Por lo tanto, es de suponer, una mejor experiencia de usuario
sería en realidad me diga qué hacer aquí.

1914
01:35:30,638 --> 01:35:33,030
Pero voy a ciegamente
decir y para sí, bien, bien.

1915
01:35:33,030 --> 01:35:35,780
>> Vamos a correr de nuevo, n para no, agradable.

1916
01:35:35,780 --> 01:35:39,610
Supongamos que al igual que ciertas personas que conozco,
mis bloqueo de mayúsculas clave está en demasiada frecuencia.

1917
01:35:39,610 --> 01:35:43,740
Así que hago Y mayúscula, enter, error.

1918
01:35:43,740 --> 01:35:46,130
OK, no es exactamente lo que estoy esperando.

1919
01:35:46,130 --> 01:35:48,170
De hecho, el ordenador
está haciendo literalmente lo

1920
01:35:48,170 --> 01:35:51,794
Le dije a hacer-- comprobar si hay
minúsculas y y n minúscula.

1921
01:35:51,794 --> 01:35:53,960
Esto no se siente como buena
experiencia de los usuarios, sin embargo.

1922
01:35:53,960 --> 01:35:59,010
Déjame pedir y aceptar
ya sea minúsculas o mayúsculas.

1923
01:35:59,010 --> 01:36:02,090
Así que resulta, es posible que desee
decir algo como en Scratch,

1924
01:36:02,090 --> 01:36:08,150
como literal o C es igual
es igual único de capitales y citado.

1925
01:36:08,150 --> 01:36:11,400
Resulta que C no tiene
esta palabra clave literal o.

1926
01:36:11,400 --> 01:36:12,880
>> Pero tiene dos barras verticales.

1927
01:36:12,880 --> 01:36:15,463
Usted tiene que mantener Shift general,
si está utilizando un teclado de EE.UU.,

1928
01:36:15,463 --> 01:36:18,910
y pulsa la barra vertical
clave por encima de la tecla de retorno.

1929
01:36:18,910 --> 01:36:22,410
Pero esta barra vertical
o barra vertical indica.

1930
01:36:22,410 --> 01:36:26,220
>> Si, por el contrario, queríamos
decir y, al igual que en Scratch,

1931
01:36:26,220 --> 01:36:28,180
podríamos hacer signo de signo.

1932
01:36:28,180 --> 01:36:31,330
Eso no tiene sentido lógico aquí,
porque un ser humano no podría

1933
01:36:31,330 --> 01:36:37,110
han escrito tanto y como minúsculas y
y el capital Y como el mismo carácter.

1934
01:36:37,110 --> 01:36:39,470
Así que, o es lo que nos proponemos aquí.

1935
01:36:39,470 --> 01:36:46,280
>> Así que si hago esto en ambos lugares, oc
es igual a es igual a N mayúscula, ahora vuelva a ejecutar,

1936
01:36:46,280 --> 01:36:49,390
dar lógica, vuelva a ejecutar lógica.

1937
01:36:49,390 --> 01:36:51,200
Ahora, puedo escribir y.

1938
01:36:51,200 --> 01:36:53,920
Y puedo hacerlo de nuevo con
Y mayúscula, o N mayúscula

1939
01:36:53,920 --> 01:36:56,630
Y podría añadir en adicional
combinaciones fijas.

1940
01:36:56,630 --> 01:36:58,810
>> Así que esta es una lógica
programa de la medida en que ahora

1941
01:36:58,810 --> 01:37:01,940
Estoy comprobando lógicamente para
este valor o este valor.

1942
01:37:01,940 --> 01:37:06,420
Y yo no tengo que, necesariamente,
llegar a dos IFS IFS más o de lo contrario.

1943
01:37:06,420 --> 01:37:09,960
De hecho, me puedo combinar algunas de las
relacionados con la lógica juntos de esta manera.

1944
01:37:09,960 --> 01:37:11,950
Así que esto sería mejor
diseñada que simplemente

1945
01:37:11,950 --> 01:37:17,490
decir, si C es igual a minúscula y,
imprimir sí, más si c es igual a Y mayúscula,

1946
01:37:17,490 --> 01:37:20,074
imprimir sí, más si c es igual
lower-- en otras palabras,

1947
01:37:20,074 --> 01:37:21,990
usted no tiene que tener
más y más ramas.

1948
01:37:21,990 --> 01:37:28,840
Se pueden combinar algunos de los equivalentes
ramas lógicamente, como en este camino.

1949
01:37:28,840 --> 01:37:34,150
>> Así que vamos a echar un vistazo a un solo
ingrediente final, un último constructo,

1950
01:37:34,150 --> 01:37:34,847
que permite C.

1951
01:37:34,847 --> 01:37:36,930
Y vamos a volver en el
futuro a otros aún.

1952
01:37:36,930 --> 01:37:41,400
Y luego vamos a la conclusión examinado
por lo que no la corrección de code--

1953
01:37:41,400 --> 01:37:46,070
Cómo obtener el código de trabajo-- pero el diseño
de código, y plantar las semillas desde el principio.

1954
01:37:46,070 --> 01:37:51,337
>> Así que permítanme seguir adelante y
abrir un nuevo archivo aquí.

1955
01:37:51,337 --> 01:37:51,920
¿Sabes que?

1956
01:37:51,920 --> 01:37:54,450
Voy a volver a poner en práctica
ese mismo programa,

1957
01:37:54,450 --> 01:37:55,940
pero utilizando una construcción diferente.

1958
01:37:55,940 --> 01:38:00,110
>> Así que me dejó rápidamente entregarme
acceso para incluir CS50.h

1959
01:38:00,110 --> 01:38:04,150
para la biblioteca de CS50,
Io.h estándar para printf.

1960
01:38:04,150 --> 01:38:06,510
Dame mi void main int.

1961
01:38:06,510 --> 01:38:09,310
Y luego por aquí, y mucho
Me seguir adelante y hacer esto.

1962
01:38:09,310 --> 01:38:12,010
>> Char c consigue obtener char, al igual que antes.

1963
01:38:12,010 --> 01:38:16,770
Y voy a usar una nueva construcción
ahora-- cambiar, en qué carácter?

1964
01:38:16,770 --> 01:38:19,820
Así interruptor es algo así como
El paso de un tren pistas.

1965
01:38:19,820 --> 01:38:22,070
O, en realidad, es una especie de
Si una persona, si otra persona si,

1966
01:38:22,070 --> 01:38:23,980
pero escrito de manera algo diferente.

1967
01:38:23,980 --> 01:38:25,490
>> Un interruptor se parece a esto.

1968
01:38:25,490 --> 01:38:29,060
Usted tiene interruptor, y luego lo
carácter o número que desea ver,

1969
01:38:29,060 --> 01:38:32,000
a continuación, algunas llaves como en
Cero, sólo decir hacer estas cosas.

1970
01:38:32,000 --> 01:38:33,480
Y entonces usted tiene diferentes casos.

1971
01:38:33,480 --> 01:38:34,830
>> No se utiliza si, y demás.

1972
01:38:34,830 --> 01:38:37,050
Literalmente se utiliza el caso de textos.

1973
01:38:37,050 --> 01:38:38,790
Y se podría decir algo como esto.

1974
01:38:38,790 --> 01:38:43,820
>> Así en el caso de una minúscula y,
o en el caso de una capital Y,

1975
01:38:43,820 --> 01:38:47,350
seguir adelante e imprimir sí.

1976
01:38:47,350 --> 01:38:49,020
Y luego salir del interruptor.

1977
01:38:49,020 --> 01:38:49,580
Eso es.

1978
01:38:49,580 --> 01:38:50,880
Hemos terminado.

1979
01:38:50,880 --> 01:38:57,270
>> Porque si, por así decirlo,
n minúscula o mayúscula N,

1980
01:38:57,270 --> 01:39:02,560
a continuación, seguir adelante y de impresión
fuera no, y luego romper.

1981
01:39:02,560 --> 01:39:08,022
Else-- y este tipo es el de
caso por defecto indeed-- printf error--

1982
01:39:08,022 --> 01:39:10,980
y sólo por si acaso, aunque
lógicamente esta ruptura no es necesario

1983
01:39:10,980 --> 01:39:12,896
porque estamos al final
del interruptor de todos modos,

1984
01:39:12,896 --> 01:39:14,520
Ahora estoy rompiendo el exterior del switch.

1985
01:39:14,520 --> 01:39:16,280
Por lo que este se ve un poco diferente.

1986
01:39:16,280 --> 01:39:18,272
>> Pero, lógicamente, es
en realidad equivalente.

1987
01:39:18,272 --> 01:39:19,980
Y ¿para qué usar
uno sobre el otro?

1988
01:39:19,980 --> 01:39:23,220
A veces, sólo preferencia personal,
a veces la estética,

1989
01:39:23,220 --> 01:39:25,420
si Echo un vistazo a este
Ahora, hay algo

1990
01:39:25,420 --> 01:39:27,510
que decir acerca de la
legibilidad de este código.

1991
01:39:27,510 --> 01:39:30,690
Es decir, no importa el hecho de que este
código es nuevo para muchos de nosotros en la habitación.

1992
01:39:30,690 --> 01:39:33,515
>> Pero sólo un poco es bastante.

1993
01:39:33,515 --> 01:39:37,760
Ves minúsculas y, mayúscula,
n minúscula, por defecto N mayúscula,

1994
01:39:37,760 --> 01:39:40,150
que sólo tipo de saltos
a la vista de una manera

1995
01:39:40,150 --> 01:39:42,200
que, sin duda, tal vez
el ejemplo anterior

1996
01:39:42,200 --> 01:39:45,780
a las FI, y las barras verticales,
y las FI demás, no podrían tener.

1997
01:39:45,780 --> 01:39:51,600
Así que esto es realmente una cuestión de personal
elección, de verdad, o la legibilidad,

1998
01:39:51,600 --> 01:39:52,360
del código.

1999
01:39:52,360 --> 01:39:58,230
>> Pero en términos de funcionalidad, me dejó
seguir adelante y hacer un interruptor, barra de puntos

2000
01:39:58,230 --> 01:40:05,830
interruptor, y ahora escriba en y minúsculas,
Y mayúscula, minúscula n, N mayúscula,

2001
01:40:05,830 --> 01:40:09,250
David, porque eso es reintentar
ni un solo símbolo.

2002
01:40:09,250 --> 01:40:12,050
Vamos a hacer x, el error, como se esperaba.

2003
01:40:12,050 --> 01:40:15,640
Y, logically-- y esto es algo
Yo animaría en general-- incluso

2004
01:40:15,640 --> 01:40:17,790
aunque sólo nos estamos rascando la
superficie de algunas de estas características.

2005
01:40:17,790 --> 01:40:20,560
>> Y puede que no sea evidente cuando se
usted se sienta abajo en el teclado,

2006
01:40:20,560 --> 01:40:21,370
¿como funciona esto?

2007
01:40:21,370 --> 01:40:22,240
Lo que haría esto?

2008
01:40:22,240 --> 01:40:25,630
Lo bonito de tener
un ordenador portátil o de sobremesa, o el acceso

2009
01:40:25,630 --> 01:40:29,290
a un ordenador con un compilador,
y con un editor de código como este,

2010
01:40:29,290 --> 01:40:32,990
está casi siempre se puede responder a estas
preguntas para usted acaba de tratar.

2011
01:40:32,990 --> 01:40:36,570
>> Por ejemplo, si la retórica
pregunta en cuestión eran,

2012
01:40:36,570 --> 01:40:39,540
¿qué ocurre si se olvida
sus estados de descanso?

2013
01:40:39,540 --> 01:40:41,400
Que es realmente una
muy común que hay que hacer,

2014
01:40:41,400 --> 01:40:43,540
ya que no se ve
como si realmente los necesita.

2015
01:40:43,540 --> 01:40:46,790
En realidad, no completan su
pensado como un paréntesis o un rizado

2016
01:40:46,790 --> 01:40:47,714
corsé lo hace.

2017
01:40:47,714 --> 01:40:49,630
Vamos a seguir adelante y
volver a compilar el código y ver.

2018
01:40:49,630 --> 01:40:53,690
Así que el interruptor, interruptor de barra de puntos.

2019
01:40:53,690 --> 01:40:56,435
Vamos escriba en minúsculas
y, la caja superior, Enter.

2020
01:40:56,435 --> 01:40:59,390

2021
01:40:59,390 --> 01:41:00,700
Por lo que he escrito y.

2022
01:41:00,700 --> 01:41:04,420
>> El programa dijo que sí, no, error,
como si cambiaba de opinión.

2023
01:41:04,420 --> 01:41:09,280
Pero es como que era, porque lo que sucede
con un interruptor es el primer caso que se

2024
01:41:09,280 --> 01:41:13,899
partido esencialmente significa, eh equipo,
ejecutar todo el código debajo de ella.

2025
01:41:13,899 --> 01:41:16,690
Y si usted no dice rompa, o
no diga rompa, o no dicen descanso,

2026
01:41:16,690 --> 01:41:19,540
el equipo va a soplar
a través de todas las líneas

2027
01:41:19,540 --> 01:41:22,779
y ejecutar todos ellos hasta
se llega a ese apoyo rizado.

2028
01:41:22,779 --> 01:41:24,320
Así que los frenos son, de hecho, es necesario.

2029
01:41:24,320 --> 01:41:27,120
Pero aquí es una comida para llevar, cuando
En caso de duda, probar algo.

2030
01:41:27,120 --> 01:41:29,510
Quizás guardar su código en primer lugar,
o guardarlo en un archivo extra

2031
01:41:29,510 --> 01:41:32,930
si está realmente preocupado por
echar a perder y tener que recuperar

2032
01:41:32,930 --> 01:41:34,430
el trabajo que se sabe que funciona.

2033
01:41:34,430 --> 01:41:35,410
>> Pero probar cosas.

2034
01:41:35,410 --> 01:41:38,074
Y no tenga miedo de que, tal vez,
de lo que el equipo puede hacer,

2035
01:41:38,074 --> 01:41:39,490
o que podría romper algo.

2036
01:41:39,490 --> 01:41:42,790
Siempre se puede volver
en cierta versión anterior.

2037
01:41:42,790 --> 01:41:45,640
>> Así que vamos a terminar mirando
en el diseño de código.

2038
01:41:45,640 --> 01:41:49,020
Tenemos esta facultad ahora para escribir
condiciones y bucles de escritura,

2039
01:41:49,020 --> 01:41:50,850
y variables, y las funciones de llamada.

2040
01:41:50,850 --> 01:41:54,590
Así que, francamente, estamos de vuelta en la clase de
donde estábamos hace una semana con Scratch,

2041
01:41:54,590 --> 01:42:00,120
aunque con un texto menos convincente
medio ambiente que permite arañazos.

2042
01:42:00,120 --> 01:42:03,990
>> Pero Tenga en cuenta la rapidez con que hemos adquirido
que el vocabulario, aunque sea

2043
01:42:03,990 --> 01:42:07,570
Va a tomar un poco de tiempo para asimilar,
por lo que ahora podemos usar este vocabulario

2044
01:42:07,570 --> 01:42:10,320
para escribir programas más interesantes.

2045
01:42:10,320 --> 01:42:12,940
Y vamos a dar un paso de bebé
hacia que, como sigue.

2046
01:42:12,940 --> 01:42:14,890
Déjame ir adelante y
crear un nuevo archivo aquí.

2047
01:42:14,890 --> 01:42:17,750
>> Voy a llamar a este
prototype.c, e introducir

2048
01:42:17,750 --> 01:42:20,954
por primera vez, la capacidad
para hacer sus propias funciones.

2049
01:42:20,954 --> 01:42:22,870
Algunos de ustedes podrían tener
hecho esto con Scratch,

2050
01:42:22,870 --> 01:42:25,430
por el que usted puede crear su
bloques personalizados propios en cero,

2051
01:42:25,430 --> 01:42:27,892
y luego arrastrarlos en su sitio
allí donde desee en C.

2052
01:42:27,892 --> 01:42:30,100
Y en la mayoría de programación
idiomas, se puede hacer exactamente

2053
01:42:30,100 --> 01:42:33,580
que- hacer sus propias funciones,
si no existen ya.

2054
01:42:33,580 --> 01:42:38,660
>> Así, por ejemplo, me dejó ir por delante
e incluir CS50.h, e incluyen

2055
01:42:38,660 --> 01:42:43,110
io.h estándar, nula principal int.

2056
01:42:43,110 --> 01:42:46,020
Y ahora tenemos una
marcador de posición de listo para funcionar.

2057
01:42:46,020 --> 01:42:48,550
Guardo cosas de impresión
como nombres de las personas hoy en día.

2058
01:42:48,550 --> 01:42:51,910
Y eso se siente como-
No sería bueno si hay

2059
01:42:51,910 --> 01:42:53,936
eran una función llamada en letra de imprenta?

2060
01:42:53,936 --> 01:42:55,060
Yo no tengo que usar printf.

2061
01:42:55,060 --> 01:42:56,976
No tengo que recordar
todos los códigos de formato.

2062
01:42:56,976 --> 01:43:00,050
¿Por qué no yo, o por qué
no lo hizo alguien antes que yo,

2063
01:43:00,050 --> 01:43:02,980
crear una función llamada print
nombre, que dado un nombre,

2064
01:43:02,980 --> 01:43:03,980
simplemente lo imprime?

2065
01:43:03,980 --> 01:43:08,700
>> En otras palabras, si digo, hey,
computadora, dame una cadena

2066
01:43:08,700 --> 01:43:11,870
preguntando al usuario para tal,
a través de la función get cadena de CS50.

2067
01:43:11,870 --> 01:43:15,090
Hey, ordenador, puesto que en la cadena de
la variable en el lado izquierdo,

2068
01:43:15,090 --> 01:43:16,150
y lo llaman s.

2069
01:43:16,150 --> 01:43:22,150
Y entonces, hey equipo, vaya por delante
e imprimir que el nombre de la persona, hecho.

2070
01:43:22,150 --> 01:43:26,240
>> Ahora, sería bueno, porque
este programa, bien llamado,

2071
01:43:26,240 --> 01:43:29,170
me dice lo que tiene que hacer
por medio de los nombres de los de función.

2072
01:43:29,170 --> 01:43:32,930
Deja que vaya a hacer prototipo, ENTER.

2073
01:43:32,930 --> 01:43:34,930
Y desafortunadamente,
esto no va a volar.

2074
01:43:34,930 --> 01:43:39,430
>> Prototype.c, línea 7, carácter
5, el error, la declaración implícita

2075
01:43:39,430 --> 01:43:42,960
Nombre de la función de impresión
es inválido en C99, C99

2076
01:43:42,960 --> 01:43:45,130
es decir, una versión de C
que salió en 1999.

2077
01:43:45,130 --> 01:43:45,730
Eso es todo.

2078
01:43:45,730 --> 01:43:48,780
>> Así que no sé qué
todo esto significa todavía.

2079
01:43:48,780 --> 01:43:50,810
Pero sí reconoce error en rojo.

2080
01:43:50,810 --> 01:43:51,770
Eso es bastante obvio.

2081
01:43:51,770 --> 01:43:53,769
>> Y parece que con
el carácter verde aquí,

2082
01:43:53,769 --> 01:43:57,520
el problema es con letra de imprenta, abierto
paren s, cerca paren, punto y coma.

2083
01:43:57,520 --> 01:44:01,800
Pero la declaración implícita de
función que vimos brevemente antes.

2084
01:44:01,800 --> 01:44:04,880
Esto significa, simplemente, que Clang
no sé lo que quiero decir.

2085
01:44:04,880 --> 01:44:09,000
>> He utilizado una palabra del vocabulario que es
Nunca visto o ha sido enseñado antes.

2086
01:44:09,000 --> 01:44:11,950
Y así que tengo que enseñarlo
lo que significa esta función.

2087
01:44:11,950 --> 01:44:13,590
Así que voy a seguir adelante y hacer eso.

2088
01:44:13,590 --> 01:44:17,970
>> Voy a seguir adelante y poner en práctica
mi propia función llamada Imprimir Nombre.

2089
01:44:17,970 --> 01:44:24,720
Y voy a decir, de la siguiente manera, que
lo hace, printf, hola, ciento

2090
01:44:24,720 --> 01:44:27,760
s, la barra invertida n, nombre, punto y coma.

2091
01:44:27,760 --> 01:44:29,250
Entonces, ¿Qué acabo de hacer?

2092
01:44:29,250 --> 01:44:31,325
>> Así que resulta, a
implementar su propia función,

2093
01:44:31,325 --> 01:44:33,845
que tipo de prestado algunos de
la misma estructura que principal

2094
01:44:33,845 --> 01:44:35,720
que simplemente hemos sido
se da por sentado, y yo

2095
01:44:35,720 --> 01:44:37,730
saber simplemente copiando y
pegando bastante más de lo

2096
01:44:37,730 --> 01:44:39,170
He estado escribiendo en el pasado.

2097
01:44:39,170 --> 01:44:40,570
Notar el patrón aquí.

2098
01:44:40,570 --> 01:44:43,750
Int, principal, Vacío, vamos a desmenuzar
en poco tiempo lo que eso significa en realidad.

2099
01:44:43,750 --> 01:44:46,160
>> Pero por hoy, solo
notar el paralelismo.

2100
01:44:46,160 --> 01:44:48,210
Vacío, en letra de imprenta,
nombre de la cadena, por lo que hay

2101
01:44:48,210 --> 01:44:50,310
una palabra clave púrpura, que
vamos a empezar

2102
01:44:50,310 --> 01:44:54,067
llamar a un tipo de retorno, el nombre de
la función, y entonces la entrada.

2103
01:44:54,067 --> 01:44:56,400
Así que, en realidad, podemos destilar
este tipo de como la semana pasada

2104
01:44:56,400 --> 01:44:59,030
como, este es el nombre o la
algoritmo del código que estamos

2105
01:44:59,030 --> 01:45:00,761
ir a la write--
algoritmo subyacente

2106
01:45:00,761 --> 01:45:02,010
el código que vamos a escribir.

2107
01:45:02,010 --> 01:45:03,180
>> Esta es su entrada.

2108
01:45:03,180 --> 01:45:04,670
Este es su salida.

2109
01:45:04,670 --> 01:45:08,730
Esta función, el nombre de impresión, es
diseñado para tener una cadena denominada nombre,

2110
01:45:08,730 --> 01:45:11,350
o lo que sea, como entrada, y luego vacío.

2111
01:45:11,350 --> 01:45:13,904
No devuelve nada,
como llegar cadena o conseguir int hace.

2112
01:45:13,904 --> 01:45:15,570
Por lo que me va a entregar algo a cambio.

2113
01:45:15,570 --> 01:45:17,960
Sólo va a tener una
efecto secundario, por decirlo así,

2114
01:45:17,960 --> 01:45:19,570
de imprimir el nombre de una persona.

2115
01:45:19,570 --> 01:45:22,260
Así aviso, línea 7, I
puede llamar en letra de imprenta.

2116
01:45:22,260 --> 01:45:25,920
La línea 10, puedo definir
o poner en práctica en letra de imprenta.

2117
01:45:25,920 --> 01:45:28,450
Pero, por desgracia, eso no es suficiente.

2118
01:45:28,450 --> 01:45:31,230
>> Déjame ir adelante y
recompilar este después de guardar.

2119
01:45:31,230 --> 01:45:33,910
Vaya, ahora, lo he hecho
peor aún, parecería.

2120
01:45:33,910 --> 01:45:37,027
Así declaración implícita de
Nombre de la función de impresión no es válido.

2121
01:45:37,027 --> 01:45:38,360
Y, de nuevo, no hay más errores.

2122
01:45:38,360 --> 01:45:41,430
Pero como yo advertí antes, incluso
si se dejen confundir con,

2123
01:45:41,430 --> 01:45:44,850
o un poco triste ver a tantos
errores, se centran sólo en la primera

2124
01:45:44,850 --> 01:45:47,500
inicialmente, debido a que sólo podría
han tenido un efecto en cascada.

2125
01:45:47,500 --> 01:45:51,970
Así C, o Clang más específicamente,
Todavía no reconoce el nombre de impresión.

2126
01:45:51,970 --> 01:45:54,580
>> Y eso es porque Clang,
por diseño, es un poco tonto.

2127
01:45:54,580 --> 01:45:56,280
Sólo hace lo que le indica que hacer.

2128
01:45:56,280 --> 01:46:00,950
Y sólo lo hace en el orden
en el que se diga que haga.

2129
01:46:00,950 --> 01:46:05,270
>> Así que he definido en la principal línea de cuatro,
como lo hemos hecho bastante a menudo.

2130
01:46:05,270 --> 01:46:07,980
He definido en letra de imprenta en la línea 10.

2131
01:46:07,980 --> 01:46:11,793
Pero estoy tratando de usar
Nombre de impresión en línea de siete.

2132
01:46:11,793 --> 01:46:13,670
>> Es demasiado pronto, no existe todavía.

2133
01:46:13,670 --> 01:46:19,150
Así que podría ser inteligente, y ser como,
OK, así que vamos a tocar en conjunto,

2134
01:46:19,150 --> 01:46:23,680
y mover el nombre de impresión hacia arriba
aquí, y volver a compilar.

2135
01:46:23,680 --> 01:46:24,550
Oh Dios mío.

2136
01:46:24,550 --> 01:46:25,260
Funcionó.

2137
01:46:25,260 --> 01:46:26,670
Era tan simple como eso.

2138
01:46:26,670 --> 01:46:28,120
>> Pero la lógica es exactamente eso.

2139
01:46:28,120 --> 01:46:30,870
Hay que enseñarle a lo que Clang
es mediante la definición de la función de primera.

2140
01:46:30,870 --> 01:46:31,920
A continuación, puede utilizarlo.

2141
01:46:31,920 --> 01:46:33,940
Pero, francamente, esto se siente
como una pendiente resbaladiza.

2142
01:46:33,940 --> 01:46:35,773
>> Así que cada vez que funciono
en un problema, sólo soy

2143
01:46:35,773 --> 01:46:39,450
va a seleccionar y copiar el código
Escribí, cortar y pegar aquí.

2144
01:46:39,450 --> 01:46:41,370
Y, sin duda, podríamos
inventar algunos escenarios

2145
01:46:41,370 --> 01:46:43,286
donde una función podría
que tenga que llamar a otro.

2146
01:46:43,286 --> 01:46:46,030
Y que no se puede poner a cada
función encima de cualquier otro.

2147
01:46:46,030 --> 01:46:47,930
>> Por lo tanto, resulta que hay
una solución mejor.

2148
01:46:47,930 --> 01:46:50,100
Podemos dejar que esto sea.

2149
01:46:50,100 --> 01:46:53,677
Y, francamente, es generalmente agradable,
y conveniente, y el buen diseño

2150
01:46:53,677 --> 01:46:56,760
poner principal en primer lugar, porque, de nuevo,
principal al igual que cuando se hace clic en bandera verde,

2151
01:46:56,760 --> 01:46:59,027
que es la función que
es ejecutado por defecto.

2152
01:46:59,027 --> 01:47:01,110
Por lo que también podría poner
en la parte superior del archivo

2153
01:47:01,110 --> 01:47:03,560
de modo que cuando usted o cualquier
otro ser humano se ve en el archivo

2154
01:47:03,560 --> 01:47:06,360
usted sabe lo que está pasando
con sólo leer principal en primer lugar.

2155
01:47:06,360 --> 01:47:15,360
Así que resulta, podemos decir Clang
proactiva, hey, Clang, en línea de cuatro,

2156
01:47:15,360 --> 01:47:17,940
Prometo poner en práctica
una función llamada Imprimir

2157
01:47:17,940 --> 01:47:22,600
Nombre que toma un nombre de cadena llamado
como entrada y devuelve nada, el vacío.

2158
01:47:22,600 --> 01:47:24,770
Y voy a moverse a
a cabo más adelante.

2159
01:47:24,770 --> 01:47:25,680
>> Aquí viene principal.

2160
01:47:25,680 --> 01:47:29,130
Ahora principal en la línea 9 se puede utilizar
Imprimir Nombre porque Clang

2161
01:47:29,130 --> 01:47:32,600
está confiando en que, con el tiempo,
se encontrará con la definición

2162
01:47:32,600 --> 01:47:34,880
de la aplicación de impresión Nombre.

2163
01:47:34,880 --> 01:47:37,390
Así que después de guardar mi archivo, y mucho
Me seguir adelante y hacer el prototipo,

2164
01:47:37,390 --> 01:47:38,498
se ve bien en esta ocasión.

2165
01:47:38,498 --> 01:47:43,470
Dot slash, prototipo, me dejó
seguir adelante y escribir un nombre.

2166
01:47:43,470 --> 01:47:48,440
David, hola David, Zamila, hola
Zamila, y, de hecho, ahora se trabaja.

2167
01:47:48,440 --> 01:47:52,200
>> Así que el ingrediente aquí es que hemos
hecho una función personalizada, como una costumbre

2168
01:47:52,200 --> 01:47:54,219
bloque de cero nos estamos llamando.

2169
01:47:54,219 --> 01:47:57,010
Pero a diferencia de los arañazos donde se puede
acaba de crear y comenzar a usarlo,

2170
01:47:57,010 --> 01:47:59,330
Ahora tenemos que ser una
poco más pedante,

2171
01:47:59,330 --> 01:48:03,410
y en realidad entrenar Clang
usar, o para esperarlo.

2172
01:48:03,410 --> 01:48:09,140
Ahora, como un aparte, ¿por qué todo este tiempo tiene
hemos estado a ciegas en la fe incluyendo

2173
01:48:09,140 --> 01:48:12,170
CS50.h, e incluyendo estándar io.h?

2174
01:48:12,170 --> 01:48:15,190
>> Pues bien, resulta que,
entre algunas otras cosas,

2175
01:48:15,190 --> 01:48:18,550
todo lo que está en los puntos h
archivos, que pasan a ser los archivos.

2176
01:48:18,550 --> 01:48:20,460
Están los archivos de cabecera, por así decirlo.

2177
01:48:20,460 --> 01:48:23,270
Todavía están escritos en C. Sin embargo,
que son un tipo diferente de archivo.

2178
01:48:23,270 --> 01:48:28,690
>> Por ahora, se puede casi asumir
que todo lo que está dentro de CS50.h

2179
01:48:28,690 --> 01:48:33,360
es algunos de una sola línea de este tipo, no
para las funciones de impresión llamados Nombre,

2180
01:48:33,360 --> 01:48:36,840
pero para obtener una cadena de, Get
Flotador, y algunos otros.

2181
01:48:36,840 --> 01:48:41,510
Y hay prototipos similares,
trazadores de líneas uno, dentro del estándar io.h

2182
01:48:41,510 --> 01:48:46,241
para printf, que ahora está en
mi propia función de impresión Nombre.

2183
01:48:46,241 --> 01:48:49,490
Así, en otras palabras, todo este tiempo que hemos
acaba de ser ciegamente copiar y pegar

2184
01:48:49,490 --> 01:48:51,780
incluir esto, incluya
que, ¿qué está pasando?

2185
01:48:51,780 --> 01:48:55,310
Esos son sólo tipo de pistas
al sonido metálico como a qué funciones

2186
01:48:55,310 --> 01:49:00,170
son, de hecho, implementado, justo
en diferentes archivos en otra parte

2187
01:49:00,170 --> 01:49:02,440
en otro lugar en el sistema.

2188
01:49:02,440 --> 01:49:05,160
>> Así que hemos implementado en letra de imprenta.

2189
01:49:05,160 --> 01:49:07,910
Se tiene este efecto secundario de
imprimir algo en la pantalla.

2190
01:49:07,910 --> 01:49:10,170
Pero no es así en realidad
dame algo de vuelta.

2191
01:49:10,170 --> 01:49:12,200
¿Cómo hacemos para
la implementación de un programa que

2192
01:49:12,200 --> 01:49:14,510
yo no entregar algo a cambio?

2193
01:49:14,510 --> 01:49:15,580
>> Bueno, vamos a probar esto.

2194
01:49:15,580 --> 01:49:21,360
Déjame ir por delante y poner en práctica
un archivo llamado return.c

2195
01:49:21,360 --> 01:49:24,530
por lo que podemos demostrar cómo algo
Obtener como cuerdas, u obtener Int,

2196
01:49:24,530 --> 01:49:27,340
es en realidad volver
algo nuevo al usuario.

2197
01:49:27,340 --> 01:49:29,840
Vamos a seguir adelante y definir int void main.

2198
01:49:29,840 --> 01:49:33,230
>> Y, de nuevo, en el futuro, vamos a
explicar lo que int y ese vacío

2199
01:49:33,230 --> 01:49:34,090
es en realidad haciendo.

2200
01:49:34,090 --> 01:49:35,840
Pero por hoy, vamos a
dar por sentado.

2201
01:49:35,840 --> 01:49:39,970
Voy a seguir adelante y printf,
para una buena experiencia de usuario, x es.

2202
01:49:39,970 --> 01:49:44,360
Y entonces voy a esperar a que el
usuario dame x int con get.

2203
01:49:44,360 --> 01:49:48,459
>> Y luego voy a seguir adelante
e imprimir x al cuadrado.

2204
01:49:48,459 --> 01:49:50,500
Así que cuando usted tiene solamente una
teclado, la gente comúnmente

2205
01:49:50,500 --> 01:49:52,600
utilizar la pequeña zanahoria
símbolo en el teclado

2206
01:49:52,600 --> 01:49:55,330
para representar a la potencia
de, o el exponente de.

2207
01:49:55,330 --> 01:49:58,960
Lo que x al cuadrado está presente i.

2208
01:49:58,960 --> 01:50:00,660
>> Y ahora voy a hacer esto.

2209
01:50:00,660 --> 01:50:03,940
Tan sólo pudiera hacer-- lo que es x
al cuadrado? x cuadrado es x veces x.

2210
01:50:03,940 --> 01:50:06,690
>> Y lo hicimos alguna
Hace tiempo que ya hoy en día.

2211
01:50:06,690 --> 01:50:08,730
Esto no se siente como
todo lo que mucho progreso.

2212
01:50:08,730 --> 01:50:09,570
¿Sabes que?

2213
01:50:09,570 --> 01:50:13,100
Vamos a apalancan algo de esa idea
desde la última vez de la abstracción.

2214
01:50:13,100 --> 01:50:16,080
>> ¿No sería bueno si
hay una función llamada

2215
01:50:16,080 --> 01:50:18,460
cuadrado que hace exactamente eso?

2216
01:50:18,460 --> 01:50:20,640
Todavía, al final de la
día, hace lo mismo matemáticas.

2217
01:50:20,640 --> 01:50:22,410
Pero vamos abstracta
lejos la idea de tomar

2218
01:50:22,410 --> 01:50:25,280
un número multiplicado por
otra, y sólo le dan un nombre,

2219
01:50:25,280 --> 01:50:27,360
como la cuadratura de este valor.

2220
01:50:27,360 --> 01:50:29,560
>> Y, en otras palabras, en
C, vamos a crear una función

2221
01:50:29,560 --> 01:50:32,660
llamado cuadrado que hace exactamente eso.

2222
01:50:32,660 --> 01:50:34,600
Va a ser llamado cuadrado.

2223
01:50:34,600 --> 01:50:35,790
Se va a tomar un int.

2224
01:50:35,790 --> 01:50:37,820
Y vamos a voluntad simplemente
llamarlo n, de forma predeterminada.

2225
01:50:37,820 --> 01:50:39,403
>> Pero podría decir que es lo que queramos.

2226
01:50:39,403 --> 01:50:42,900
Y todo lo que se va a
hacer, literalmente, es el regreso

2227
01:50:42,900 --> 01:50:45,810
el resultado de n veces n.

2228
01:50:45,810 --> 01:50:48,980
Pero debido a que es
devolver algo, lo cual

2229
01:50:48,980 --> 01:50:53,690
es la palabra clave en la púrpura que hemos
nunca había visto antes, yo, en la línea 11,

2230
01:50:53,690 --> 01:50:55,410
No se puede decir sin efecto este momento.

2231
01:50:55,410 --> 01:51:01,320
>> Vacío, en el ejemplo que acabamos de ver
en lugar del nombre de impresión, sólo significa,

2232
01:51:01,320 --> 01:51:02,190
hacer algo.

2233
01:51:02,190 --> 01:51:04,170
Pero no me entregar algo a cambio.

2234
01:51:04,170 --> 01:51:06,790
En este caso, yo quiero
para volver n veces n,

2235
01:51:06,790 --> 01:51:08,460
o sea lo que sea, ese número.

2236
01:51:08,460 --> 01:51:12,460
>> Así que no puedo decir, hey, ordenador,
Vuelvo nada, nula.

2237
01:51:12,460 --> 01:51:16,166
Se va a volver, por naturaleza, un int.

2238
01:51:16,166 --> 01:51:17,790
Y eso es todo lo que está pasando aquí.

2239
01:51:17,790 --> 01:51:20,070
>> La entrada de la cuadratura
va a ser un int.

2240
01:51:20,070 --> 01:51:24,760
Y para que podamos usarlo, tiene que
tener un nombre, N. Se va a la salida

2241
01:51:24,760 --> 01:51:26,240
un int que no necesita un nombre.

2242
01:51:26,240 --> 01:51:29,590
Podemos dejamos a principal, o quien
usarme para recordar este valor si

2243
01:51:29,590 --> 01:51:31,120
querer con su propia variable.

2244
01:51:31,120 --> 01:51:33,230
>> Y, de nuevo, el único nuevo
palabra clave aquí es Retorno.

2245
01:51:33,230 --> 01:51:34,480
Y sólo estoy haciendo un poco de matemática.

2246
01:51:34,480 --> 01:51:41,825
Si yo realmente quería ser innecesaria,
Podría decir producto int n veces se pone n.

2247
01:51:41,825 --> 01:51:44,170
>> Y entonces yo podría decir, el producto de regreso.

2248
01:51:44,170 --> 01:51:47,360
Pero, de nuevo, a mi punto anterior de
esto simplemente no es buena design--

2249
01:51:47,360 --> 01:51:50,060
al igual que, ¿por qué introducir un nombre,
un símbolo, como producto,

2250
01:51:50,060 --> 01:51:51,570
sólo para volver de inmediato?

2251
01:51:51,570 --> 01:51:53,670
Es un poco más limpio,
un poco más fuerte, por lo

2252
01:51:53,670 --> 01:51:59,380
para hablar, sólo para decir retorno n veces
n, deshacerse de esta línea por completo.

2253
01:51:59,380 --> 01:52:02,860
>> Y es sólo menos código para leer,
menos posibilidades de errores.

2254
01:52:02,860 --> 01:52:05,180
Y vamos a ver si este
En realidad ahora trabaja.

2255
01:52:05,180 --> 01:52:09,380
Ahora, voy a ir
adelante y hacer de retorno.

2256
01:52:09,380 --> 01:52:11,460
>> Uh-oh, declaración implícita de la función.

2257
01:52:11,460 --> 01:52:14,080
Hice este error antes, no es gran cosa.

2258
01:52:14,080 --> 01:52:18,950
Me dejaron de naturaleza, así como resaltar y
copiar, exactamente el mismo prototipo de función,

2259
01:52:18,950 --> 01:52:21,342
o la firma, de la función aquí.

2260
01:52:21,342 --> 01:52:22,800
O podría mover toda la función.

2261
01:52:22,800 --> 01:52:23,841
>> Pero eso es un poco perezoso.

2262
01:52:23,841 --> 01:52:24,870
Así que no vamos a hacer eso.

2263
01:52:24,870 --> 01:52:27,960
Ahora, quiero dejar de retorno
de nuevo, punto de retorno barra.

2264
01:52:27,960 --> 01:52:32,790
>> x es cuadrado 2. x es 4.
x es cuadrado 3. x es 9.

2265
01:52:32,790 --> 01:52:35,300
Y la función parece
Ahora que está funcionando.

2266
01:52:35,300 --> 01:52:36,550
Entonces, ¿cuál es la diferencia aquí?

2267
01:52:36,550 --> 01:52:42,520
Tengo una función que se llama cuadrado,
en este caso, que presento una entrada.

2268
01:52:42,520 --> 01:52:43,830
Y yo vuelva una salida.

2269
01:52:43,830 --> 01:52:46,210
Y, sin embargo, con anterioridad, si
Abro el otro ejemplo

2270
01:52:46,210 --> 01:52:51,640
de antes, que
fue llamado prototype.c,

2271
01:52:51,640 --> 01:52:54,770
Tenía en letra de imprenta, que
devuelto vacío, por así decirlo,

2272
01:52:54,770 --> 01:52:58,730
O se volvió nada, y
simplemente tenía un efecto secundario.

2273
01:52:58,730 --> 01:53:00,230
>> Entonces, ¿qué está pasando aquí?

2274
01:53:00,230 --> 01:53:03,520
Bien, considere la función
obtener la secuencia para un momento.

2275
01:53:03,520 --> 01:53:06,570
Hemos estado usando la función
obtener cadena de la siguiente manera.

2276
01:53:06,570 --> 01:53:10,464
>> Hemos tenido una función get
cadena, como son CS50.h,

2277
01:53:10,464 --> 01:53:16,624
Incluyen estándar io.h, int, principal, nula.

2278
01:53:16,624 --> 01:53:18,790
Y a continuación, cada vez que he
llamada cadena GET hasta el momento,

2279
01:53:18,790 --> 01:53:23,260
He dicho algo así como: cadena s
consigue obtener la secuencia, ya que conseguimos el string--

2280
01:53:23,260 --> 01:53:27,880
vamos a llamar a esta cadena get get.c--
sí devuelve una cadena que puede entonces

2281
01:53:27,880 --> 01:53:32,050
utilizar, y decir hola, coma,
s por ciento, la barra invertida n, s.

2282
01:53:32,050 --> 01:53:35,660
>> Así que este es el mismo ejemplo,
Realmente, que teníamos antes.

2283
01:53:35,660 --> 01:53:37,920
Así que llegar cadena devuelve un valor.

2284
01:53:37,920 --> 01:53:41,260
Pero hace un momento, la cadena de impresión
no devuelve un valor.

2285
01:53:41,260 --> 01:53:42,721
Simplemente tiene un efecto secundario.

2286
01:53:42,721 --> 01:53:44,220
Así que esta es una diferencia fundamental.

2287
01:53:44,220 --> 01:53:46,710
Hemos visto diferentes
tipos de funciones que ahora,

2288
01:53:46,710 --> 01:53:49,490
algunos de los cuales han regresado
valores, algunos de los cuales no lo hacen.

2289
01:53:49,490 --> 01:53:51,890
Así que tal vez es la secuencia, o int o float.

2290
01:53:51,890 --> 01:53:53,480
O tal vez es sólo vacío.

2291
01:53:53,480 --> 01:53:55,710
>> Y la diferencia es
que estas funciones que

2292
01:53:55,710 --> 01:53:59,940
obtener datos y devolver un valor son en realidad
traer algo nuevo a la mesa,

2293
01:53:59,940 --> 01:54:01,110
por así decirlo.

2294
01:54:01,110 --> 01:54:03,710
Así que vamos a seguir adelante y
mirar a un conjunto final

2295
01:54:03,710 --> 01:54:09,129
de ejemplos que da un sentido, ahora, de
la forma en que podría, de hecho, abstracta mejor,

2296
01:54:09,129 --> 01:54:11,670
y mejor, y mejor, o más,
y más, y más, con el fin

2297
01:54:11,670 --> 01:54:13,810
para escribir, en última instancia, un mejor código.

2298
01:54:13,810 --> 01:54:16,860
Vamos a seguir adelante, y en el espíritu
de Scratch, haga lo siguiente.

2299
01:54:16,860 --> 01:54:21,700
>> Déjame ir adelante y incluyo
CS50.h y el estándar io.h.

2300
01:54:21,700 --> 01:54:24,010
Déjenme seguir adelante y dar
yo un int, principal, nula.

2301
01:54:24,010 --> 01:54:27,380
Y déjame ir por delante, llamo a esto cough.c.

2302
01:54:27,380 --> 01:54:35,510
>> Y me dejó ir adelante y sólo
como arañazos, imprima la tos / n.

2303
01:54:35,510 --> 01:54:37,170
Y quiero hacer esto tres veces.

2304
01:54:37,170 --> 01:54:39,670
Así que estoy, por supuesto, sólo va
copiar y pegar tres veces.

2305
01:54:39,670 --> 01:54:46,440
Ahora voy a hacer
tos tos barra de puntos.

2306
01:54:46,440 --> 01:54:50,120
Vamos a dar a mí mismo un poco más de espacio
Aquí se pueden introducir, tos, tos, tos.

2307
01:54:50,120 --> 01:54:53,970
>> Hay, obviamente, ya una
oportunidad para mejora.

2308
01:54:53,970 --> 01:54:55,679
He copiado y pegado
un par de veces hoy.

2309
01:54:55,679 --> 01:54:58,261
Pero eso sólo fue así que no lo hice
tiene que escribir tantos caracteres.

2310
01:54:58,261 --> 01:55:00,250
Todavía cambiado lo
esas líneas de código son.

2311
01:55:00,250 --> 01:55:04,240
>> Estas tres líneas son idénticos,
que se siente perezoso y, de hecho, es decir,

2312
01:55:04,240 --> 01:55:07,110
y probablemente no es el enfoque correcto.

2313
01:55:07,110 --> 01:55:11,029
Así, con lo que el ingrediente
podríamos mejorar este código?

2314
01:55:11,029 --> 01:55:12,570
No tenemos que copiar y pegar el código.

2315
01:55:12,570 --> 01:55:15,070
>> Y, de hecho, cada vez que se sienta
a sí mismo de copiar y pegar,

2316
01:55:15,070 --> 01:55:17,700
y ni siquiera el cambio de código,
probabilidades son que hay una mejor manera.

2317
01:55:17,700 --> 01:55:19,470
Y, de hecho, no lo es.

2318
01:55:19,470 --> 01:55:22,510
Déjame seguir adelante y hacer un bucle,
a pesar de que la sintaxis no podría

2319
01:55:22,510 --> 01:55:24,570
venir naturalmente todavía.

2320
01:55:24,570 --> 01:55:29,494
>> Haga esto tres veces, simplemente
haciendo lo following--

2321
01:55:29,494 --> 01:55:31,160
y me he enterado de esto desde la práctica.

2322
01:55:31,160 --> 01:55:32,810
Pero tenemos un número de ejemplos ahora.

2323
01:55:32,810 --> 01:55:34,950
Y verá en línea
más referencias fijas.

2324
01:55:34,950 --> 01:55:37,790
>> Esta es la sintaxis de la línea 6, que
al igual que los arañazos que se repite

2325
01:55:37,790 --> 01:55:40,090
bloque, repita los siguientes tres veces.

2326
01:55:40,090 --> 01:55:41,340
Es un poco mágica por ahora.

2327
01:55:41,340 --> 01:55:43,050
Pero esto va a conseguir más,
y más familiar.

2328
01:55:43,050 --> 01:55:45,050
>> Y se va a repetir
línea de ocho tres veces,

2329
01:55:45,050 --> 01:55:52,390
por lo que si puedo volver a compilar la tos maquillaje,
slash dot tos, tos, tos, tos.

2330
01:55:52,390 --> 01:55:54,030
Todavía funciona de la misma manera.

2331
01:55:54,030 --> 01:55:55,550
Así que eso es todo fino y bueno.

2332
01:55:55,550 --> 01:55:58,200
Pero eso no es muy abstracta.

2333
01:55:58,200 --> 01:55:59,371
>> Es perfectamente correcto.

2334
01:55:59,371 --> 01:56:01,370
Pero parece que hay
podría ser una oportunidad,

2335
01:56:01,370 --> 01:56:03,750
como en el mundo de
Cero, al tipo de inicio

2336
01:56:03,750 --> 01:56:07,530
añadir algunos términos aquí para que
Yo no sólo tengo un poco de bucle,

2337
01:56:07,530 --> 01:56:09,867
y una función que dice
tos, o que toser.

2338
01:56:09,867 --> 01:56:10,450
¿Sabes que?

2339
01:56:10,450 --> 01:56:12,620
Voy a tratar de ser una
poco más fresco que eso,

2340
01:56:12,620 --> 01:56:16,090
y en realidad escribir una función que
tiene algunos efectos secundarios, lo llaman la tos.

2341
01:56:16,090 --> 01:56:20,830
>> Y se necesita ninguna entrada, y
devuelve ningún valor como salida.

2342
01:56:20,830 --> 01:56:22,680
Pero usted sabe lo que hace?

2343
01:56:22,680 --> 01:56:29,370
Lo hace esto- printf,
entre comillas, toser.

2344
01:56:29,370 --> 01:56:32,380
>> Y ahora aquí, voy
para seguir adelante y para int,

2345
01:56:32,380 --> 01:56:36,070
i resulta en cero, i menos de 3, i plus plus.

2346
01:56:36,070 --> 01:56:39,770
Voy a hacer no printf, que es
podría decirse que una implementación de bajo nivel

2347
01:56:39,770 --> 01:56:40,270
detalle.

2348
01:56:40,270 --> 01:56:41,353
No me importa cómo toser.

2349
01:56:41,353 --> 01:56:43,240
Sólo quiero utilizar la función de la tos.

2350
01:56:43,240 --> 01:56:44,840
Y yo sólo voy a llamar a la tos.

2351
01:56:44,840 --> 01:56:46,204
>> Ahora, observe la dicotomía.

2352
01:56:46,204 --> 01:56:49,370
Cuando se llama a una función, si no lo hace
que desee darle entradas, totalmente bien.

2353
01:56:49,370 --> 01:56:51,780
Sólo hacer paréntesis de apertura, cierre
paren, y ya está.

2354
01:56:51,780 --> 01:56:56,271
>> Cuando se define una función, o
declarar el prototipo de una función,

2355
01:56:56,271 --> 01:56:58,770
si se sabe de antemano que no es
va a tomar ningún argumento,

2356
01:56:58,770 --> 01:57:01,170
decir nula en aquellos paréntesis allí.

2357
01:57:01,170 --> 01:57:05,660
Y eso hace que la certeza de que se
no por casualidad se mal uso de ella.

2358
01:57:05,660 --> 01:57:07,020
Déjame seguir adelante y hacer la tos.

2359
01:57:07,020 --> 01:57:08,540
Y, por supuesto, he cometido un error.

2360
01:57:08,540 --> 01:57:10,410
>> Maldita sea, hay que
declaración implícita.

2361
01:57:10,410 --> 01:57:11,325
Pero eso está bien.

2362
01:57:11,325 --> 01:57:12,590
Es una solución fácil.

2363
01:57:12,590 --> 01:57:18,240
Sólo necesito el prototipo más arriba
en mi archivo de lo que estoy de utilizarlo.

2364
01:57:18,240 --> 01:57:20,070
>> Así que ahora quiero dejar tos de nuevo, agradable.

2365
01:57:20,070 --> 01:57:20,790
Ahora funciona.

2366
01:57:20,790 --> 01:57:22,930
Hacer la tos, tos, tos, tos.

2367
01:57:22,930 --> 01:57:25,930
Así se podría pensar que estamos muy
poco más de la ingeniería de este problema.

2368
01:57:25,930 --> 01:57:26,763
Y, de hecho, somos.

2369
01:57:26,763 --> 01:57:28,870
Este no es un buen
candidato de un programa de

2370
01:57:28,870 --> 01:57:31,930
en el momento de
refactorización, y hacer lo que es

2371
01:57:31,930 --> 01:57:35,645
llamado descomposición jerárquica,
donde se toma algo de código, y luego

2372
01:57:35,645 --> 01:57:38,790
que tipo de cosas fuera de factores, con el fin
adscribir más semántica a ellos,

2373
01:57:38,790 --> 01:57:40,930
y reutilizarla en última instancia, a más largo plazo.

2374
01:57:40,930 --> 01:57:43,490
Pero es un bloque de construcción hacia
programas más sofisticados

2375
01:57:43,490 --> 01:57:45,600
que vamos a empezar
escrito poco tiempo que

2376
01:57:45,600 --> 01:57:50,090
nos permite disponer de vocabulario
con el que escribir mejor código.

2377
01:57:50,090 --> 01:57:52,920
Y, de hecho, vamos a ver si nos
No se puede generalizar más a fondo.

2378
01:57:52,920 --> 01:57:57,984
>> Parece un poco cojo que yo, principal,
tenga que preocuparse por este maldito bucle,

2379
01:57:57,984 --> 01:57:59,400
y llamar a la tos y otra vez.

2380
01:57:59,400 --> 01:58:03,050
¿Por qué no puedo simplemente decirle a la tos,
Por favor, toser tres veces?

2381
01:58:03,050 --> 01:58:08,170
En otras palabras, ¿por qué no puedo simplemente
dar entrada a toser y hacer esto?

2382
01:58:08,170 --> 01:58:11,270
>> ¿Por qué no puedo simplemente decir, en
tos principal tres veces.

2383
01:58:11,270 --> 01:58:13,150
Y ahora, esto es una especie de mágico.

2384
01:58:13,150 --> 01:58:14,540
Es muy iterativo aquí.

2385
01:58:14,540 --> 01:58:15,940
Y es, de hecho, un pequeño paso.

2386
01:58:15,940 --> 01:58:19,250
>> Pero sólo la capacidad de decir en
línea de ocho, toser tres veces,

2387
01:58:19,250 --> 01:58:20,730
es sólo mucho más fácil de leer.

2388
01:58:20,730 --> 01:58:24,210
Y, además, no tengo que saber
ni le importa cómo se implementa la tos.

2389
01:58:24,210 --> 01:58:26,460
Y, de hecho, más tarde en el
plazo y para proyectos fin de carrera,

2390
01:58:26,460 --> 01:58:29,150
Si usted aborda un proyecto con
un compañero de clase o dos compañeros de clase,

2391
01:58:29,150 --> 01:58:32,370
se dará cuenta de que vas a
que, o desea, dividir el trabajo.

2392
01:58:32,370 --> 01:58:34,650
>> Y vas a querer decidir
de antemano, ¿quién va a hacer qué,

2393
01:58:34,650 --> 01:58:35,483
y en el que piezas?

2394
01:58:35,483 --> 01:58:37,520
Y no sería agradable
si, por ejemplo,

2395
01:58:37,520 --> 01:58:40,100
hacerse cargo de la escritura principal, hecho.

2396
01:58:40,100 --> 01:58:43,470
Y su compañero de cuarto, o su
socio más en general,

2397
01:58:43,470 --> 01:58:45,230
se encarga de la aplicación de la tos.

2398
01:58:45,230 --> 01:58:49,540
>> Y esta división, éstas
paredes de la abstracción,

2399
01:58:49,540 --> 01:58:52,310
o capas de abstracción si
va, son súper poderoso,

2400
01:58:52,310 --> 01:58:55,480
porque especialmente para más grande,
más programas y sistemas complejos,

2401
01:58:55,480 --> 01:59:00,070
que permite a varias personas para construir
cosas juntos, y en última instancia

2402
01:59:00,070 --> 01:59:02,680
puntada su trabajo juntos de esta manera.

2403
01:59:02,680 --> 01:59:05,332
Pero, por supuesto,
necesitará fijar ahora la tos.

2404
01:59:05,332 --> 01:59:07,290
Tenemos que decirle a la tos
que, hey, ¿sabes qué?

2405
01:59:07,290 --> 01:59:11,230
Vas a tener que tomar una
input-- por lo que no vacía, sino int y ahora.

2406
01:59:11,230 --> 01:59:15,170
Vamos a seguir adelante y poner en
tos del int. i resulta en cero.

2407
01:59:15,170 --> 01:59:16,890
>> i es menor que el número de veces.

2408
01:59:16,890 --> 01:59:18,550
He dicho tres antes.

2409
01:59:18,550 --> 01:59:20,420
Pero eso no es lo que quiero.

2410
01:59:20,420 --> 01:59:25,520
Me quieren toso a generalizarse a
soportar cualquier número de iteraciones.

2411
01:59:25,520 --> 01:59:28,800
>> Así que, de hecho, es n que quiero,
cualquiera que sea el usuario me dice.

2412
01:59:28,800 --> 01:59:31,620
Ahora, puedo seguir adelante y decir la tos de impresión.

2413
01:59:31,620 --> 01:59:34,750
Y no importa qué número
el usuario pasa en,

2414
01:59:34,750 --> 01:59:36,890
Voy a repetir muchas veces.

2415
01:59:36,890 --> 01:59:39,160
>> Así que al final del día,
programa es idéntico.

2416
01:59:39,160 --> 01:59:42,820
Pero cuenta todas estas cosas
incluso podría ser en otro archivo.

2417
01:59:42,820 --> 01:59:45,620
De hecho, no sé en el
printf momento cómo se implementa.

2418
01:59:45,620 --> 01:59:47,980
>> No sé en este momento cómo llegar
cadena, o conseguir int o float llegar

2419
01:59:47,980 --> 01:59:48,646
se implementan.

2420
01:59:48,646 --> 01:59:50,930
Y yo no quiero
verlos en mi pantalla.

2421
01:59:50,930 --> 01:59:55,320
Tal como es, estoy empezando a centrarse en
mi programa, no esas funciones.

2422
01:59:55,320 --> 01:59:59,070
>> Y así, de hecho, tan pronto como se
iniciar la factorización código como esto,

2423
01:59:59,070 --> 02:00:01,397
podríamos incluso mover la tos
en un archivo separado?

2424
02:00:01,397 --> 02:00:02,730
Otra persona podría ponerlo en práctica.

2425
02:00:02,730 --> 02:00:06,810
Y usted y su programa se convierte en el
muy bonito, y muy fácil de leer,

2426
02:00:06,810 --> 02:00:10,830
podría decirse que, en realidad cuatro
programa de línea de allí mismo.

2427
02:00:10,830 --> 02:00:13,510
>> Así que vamos a seguir adelante ahora
y hacer un cambio más.

2428
02:00:13,510 --> 02:00:16,180
Notar que mi prototipo
tiene que cambiar encima de la tapa.

2429
02:00:16,180 --> 02:00:18,390
Así que déjame arreglar eso por lo
Yo no gritar en.

2430
02:00:18,390 --> 02:00:22,580
>> Hacer la tos, la tos me deja correr una vez
Además, sigue haciendo lo mismo.

2431
02:00:22,580 --> 02:00:26,010
Pero ahora, cuenta que tenemos una
ingrediente para una versión final.

2432
02:00:26,010 --> 02:00:26,940
¿Sabes que?

2433
02:00:26,940 --> 02:00:29,040
Yo no quiero simplemente toser, necesariamente.

2434
02:00:29,040 --> 02:00:30,802
Quiero tener algo más general.

2435
02:00:30,802 --> 02:00:31,510
Así que ya saben qué?

2436
02:00:31,510 --> 02:00:32,450
Quiero hacer esto.

2437
02:00:32,450 --> 02:00:37,140
Quiero tener, al igual que los arañazos
hace, un bloque de ejemplo, pero no sólo

2438
02:00:37,140 --> 02:00:38,680
decir algo cierto número de veces.

2439
02:00:38,680 --> 02:00:41,510
Lo quiero decir una cadena muy específica.

2440
02:00:41,510 --> 02:00:43,850
Y, por lo tanto, no lo creo
queremos que se acaba de decir la tos.

2441
02:00:43,850 --> 02:00:47,660
Quiero que diga lo
cadena se pasa en.

2442
02:00:47,660 --> 02:00:49,960
>> Así notar, he generalicé
esto para que ahora

2443
02:00:49,960 --> 02:00:53,110
digamos siente como un buen nombre
para esto, como Scratch,

2444
02:00:53,110 --> 02:00:55,530
toma dos argumentos, a diferencia de los arañazos.

2445
02:00:55,530 --> 02:00:56,570
Una de ellas es una cadena.

2446
02:00:56,570 --> 02:00:57,300
Uno de ellos es un int.

2447
02:00:57,300 --> 02:00:58,130
>> Y podría cambiar ellos.

2448
02:00:58,130 --> 02:01:00,713
Yo sólo algo así como la idea de
decir la cadena primero, y luego

2449
02:01:00,713 --> 02:01:01,940
cuántas veces posteriores.

2450
02:01:01,940 --> 02:01:03,970
Void significa que todavía
no devuelve nada.

2451
02:01:03,970 --> 02:01:06,428
Estos son sólo parte visual
efectos, como con [? Jordan,?]

2452
02:01:06,428 --> 02:01:08,240
un efecto secundario verbal de gritar.

2453
02:01:08,240 --> 02:01:12,630
Todavía hace algo n veces,
0 hasta, pero no es igual a n.

2454
02:01:12,630 --> 02:01:14,540
Esto significa veces n totales.

2455
02:01:14,540 --> 02:01:16,540
Y luego simplemente imprimir
lo que es de cadena.

2456
02:01:16,540 --> 02:01:19,060
Así que en realidad he generalicé
esta línea de código.

2457
02:01:19,060 --> 02:01:22,460
Así que ahora, ¿Cómo implemento
la función de tos?

2458
02:01:22,460 --> 02:01:25,520
>> Puedo hacer la tos vacío.

2459
02:01:25,520 --> 02:01:28,501
Y todavía puedo tomar en la forma
Muchas veces se desea que tosa.

2460
02:01:28,501 --> 02:01:29,250
¿Pero sabes que?

2461
02:01:29,250 --> 02:01:31,240
Ahora puedo decir en batea.

2462
02:01:31,240 --> 02:01:36,540
>> Puedo decir con llamar a la
palabra tos, pasando n.

2463
02:01:36,540 --> 02:01:40,410
Y si quiero aplicar también,
sólo por diversión, una función estornudo,

2464
02:01:40,410 --> 02:01:42,290
Puedo estornudar cierto número de veces.

2465
02:01:42,290 --> 02:01:47,300
Y puedo seguir reutilizando n, porque
notar que m en este contexto o alcance

2466
02:01:47,300 --> 02:01:49,470
sólo existe dentro de esta función.

2467
02:01:49,470 --> 02:01:52,767
>> Y n en este contexto sólo
existe dentro de esta función aquí.

2468
02:01:52,767 --> 02:01:54,600
Así que vamos a volver a
estas cuestiones de alcance.

2469
02:01:54,600 --> 02:02:01,160
Y aquí, sólo voy a decir,
Achoo, y luego n veces, punto y coma.

2470
02:02:01,160 --> 02:02:04,340
>> Y ahora, sólo hay que pedir prestado
estas funciones Firmas aquí.

2471
02:02:04,340 --> 02:02:06,290
Así que la tos es correcta.

2472
02:02:06,290 --> 02:02:10,090
estornudo vacío es correcta ahora.

2473
02:02:10,090 --> 02:02:12,390
>> Y todavía sólo necesito decir.

2474
02:02:12,390 --> 02:02:18,990
Así que voy a decir, por ejemplo
cadena s, int n, punto y coma.

2475
02:02:18,990 --> 02:02:22,010
Así que he más de la ingeniería del
diablos de este programa.

2476
02:02:22,010 --> 02:02:23,760
>> Y esto no lo hace
necesariamente que se trata de

2477
02:02:23,760 --> 02:02:26,343
lo que debe hacer al escribir
incluso el más simple de los programas.

2478
02:02:26,343 --> 02:02:29,280
Tomar algo que es obviamente
muy simple, muy corto,

2479
02:02:29,280 --> 02:02:31,800
y volver a ponerlo en práctica
usando manera demasiado código.

2480
02:02:31,800 --> 02:02:34,560
Pero en verdad no ves, y en
tiempo de mirar hacia atrás en estos ejemplos,

2481
02:02:34,560 --> 02:02:38,610
y se dan cuenta, oh, esos son los pasos
nos llevó a generalizar en realidad,

2482
02:02:38,610 --> 02:02:40,797
al factor algo fuera,
hasta que al final de la día

2483
02:02:40,797 --> 02:02:42,380
mi código es en realidad bastante razonable.

2484
02:02:42,380 --> 02:02:45,960
Porque si quiero toser tres
estornudan veces y luego tres veces,

2485
02:02:45,960 --> 02:02:50,420
Simplemente voy a volver a ejecutar esto,
programa de hacer la tos, la tos y correr.

2486
02:02:50,420 --> 02:02:53,620
Y tengo tres tos
y tres estornuda.

2487
02:02:53,620 --> 02:02:55,990
>> Y por lo que este es un básico
paradigma, si se quiere,

2488
02:02:55,990 --> 02:03:00,110
de cómo podemos ir sobre
En realidad la implementación de un programa.

2489
02:03:00,110 --> 02:03:03,220
Pero vamos a ver ahora lo que es
hemos estado haciendo todo este tiempo,

2490
02:03:03,220 --> 02:03:06,940
y lo que algunas de las piezas finales
están detrás de este simple comando.

2491
02:03:06,940 --> 02:03:09,620
Al final del día, tenemos
estado utilizando Clang como nuestro compilador.

2492
02:03:09,620 --> 02:03:11,494
Hemos estado escribiendo fuente
código, convirtiéndola

2493
02:03:11,494 --> 02:03:12,820
a través de Clang en código máquina.

2494
02:03:12,820 --> 02:03:15,540
>> Y nosotros hemos estado usando simplemente Hacer
para facilitar nuestras pulsaciones de teclas de modo

2495
02:03:15,540 --> 02:03:20,740
que no tenemos que recordar
los encantamientos de sí mismo Clang.

2496
02:03:20,740 --> 02:03:22,640
Pero lo que es realmente hacer haciendo?

2497
02:03:22,640 --> 02:03:24,750
Y, a su vez, lo que es
Clang realmente hacer?

2498
02:03:24,750 --> 02:03:28,790
>> Resulta, sin embargo, hemos simplificado
la discusión de hoy, diciendo:

2499
02:03:28,790 --> 02:03:33,090
se toma el código fuente, se envia como
entrada a un compilador, que le da

2500
02:03:33,090 --> 02:03:35,750
de salida de la máquina
código, resulta que hay

2501
02:03:35,750 --> 02:03:37,420
a unos pasos diferentes en el interior hay.

2502
02:03:37,420 --> 02:03:41,940
Y compilación pasa a ser el paraguas
plazo para un montón de pasos.

2503
02:03:41,940 --> 02:03:43,970
Pero vamos a burlan
esto muy rápido.

2504
02:03:43,970 --> 02:03:48,070
>> Resulta que hemos estado haciendo
más cosas cada vez que ejecute un programa,

2505
02:03:48,070 --> 02:03:50,990
o cada vez que compile un programa de hoy.

2506
02:03:50,990 --> 02:03:55,020
Así preprocesamiento se refiere a
esto-- nada en un programa C,

2507
02:03:55,020 --> 02:03:58,720
como veremos una y otra vez,
que se inicia con este símbolo de hash,

2508
02:03:58,720 --> 02:04:03,320
o el símbolo hashtag aquí, significa
se trata de una directiva de preprocesador.

2509
02:04:03,320 --> 02:04:07,330
Eso significa que, en este caso, hey
computadora, hacer algo con este archivo

2510
02:04:07,330 --> 02:04:09,430
antes de que realmente compilar mi propio código.

2511
02:04:09,430 --> 02:04:15,220
>> En este caso, el hash incluye es decir,
en esencia, forma de decir de C,

2512
02:04:15,220 --> 02:04:19,325
Hey ordenador, ir a buscar el contenido
de CS50.h y pegar aquí.

2513
02:04:19,325 --> 02:04:22,170
Hey ordenador, ir a buscar la
el contenido de la norma io.h,

2514
02:04:22,170 --> 02:04:24,690
donde quiera que esté en la
disco duro, pega aquí.

2515
02:04:24,690 --> 02:04:27,390
Así que esas cosas pasan
primero en la ejecución previa.

2516
02:04:27,390 --> 02:04:28,880
>> Y Clang hace todo esto para nosotros.

2517
02:04:28,880 --> 02:04:30,510
Y lo hace tan rematadamente
rápido, que ni siquiera

2518
02:04:30,510 --> 02:04:32,000
ver cuatro cosas distintas que suceden.

2519
02:04:32,000 --> 02:04:34,100
Pero esa es la primera de esas medidas.

2520
02:04:34,100 --> 02:04:35,560
>> Lo que en realidad sucede después?

2521
02:04:35,560 --> 02:04:38,320
Así, la próxima oficial
paso es la compilación.

2522
02:04:38,320 --> 02:04:40,385
Y resulta que
compilación de un programa

2523
02:04:40,385 --> 02:04:44,060
técnicamente significa que va desde
código fuente, las cosas que he

2524
02:04:44,060 --> 02:04:47,890
estado escribiendo hoy en día, a algo
llamado código ensamblador, algo

2525
02:04:47,890 --> 02:04:49,260
que se ve un poco diferente.

2526
02:04:49,260 --> 02:04:51,050
>> Y, de hecho, podemos ver esto muy rápido.

2527
02:04:51,050 --> 02:04:53,890
Déjame ir en realidad en mi IDE.

2528
02:04:53,890 --> 02:04:58,050
Déjame ir adelante y hola.c abierto, lo cual
es el primer programa con el que nos

2529
02:04:58,050 --> 02:04:59,120
comenzó hoy.

2530
02:04:59,120 --> 02:05:04,130
Y me dejó ir adelante y corro un Clang
poco diferente, Clang-s, hola.c,

2531
02:05:04,130 --> 02:05:07,720
que en realidad se va a
dame otro archivo hello.s.

2532
02:05:07,720 --> 02:05:10,330
>> Y probablemente nunca se
volver a ver este tipo de código.

2533
02:05:10,330 --> 02:05:13,030
Si se toma un nivel más bajo
clase de sistemas como CS61,

2534
02:05:13,030 --> 02:05:14,920
verá mucho más
de este tipo de código.

2535
02:05:14,920 --> 02:05:17,020
Pero este es el lenguaje ensamblador.

2536
02:05:17,020 --> 02:05:22,050
Este es el lenguaje ensamblador X86
que la CPU que subyace

2537
02:05:22,050 --> 02:05:24,460
CS50 IDE entiende realmente.

2538
02:05:24,460 --> 02:05:27,060
>> Y críptico como lo hace
mira, es algo

2539
02:05:27,060 --> 02:05:29,180
el equipo entiende bastante bien.

2540
02:05:29,180 --> 02:05:30,790
Sub q, esta es una de resta.

2541
02:05:30,790 --> 02:05:31,660
Hay movimientos.

2542
02:05:31,660 --> 02:05:35,730
>> Hay llamando a las funciones aquí,
x oring, un movimiento, un complemento, sin oposición,

2543
02:05:35,730 --> 02:05:36,430
un retorno.

2544
02:05:36,430 --> 02:05:38,850
Así que hay algunos muy
instrucciones de bajo nivel

2545
02:05:38,850 --> 02:05:41,280
que entienden que las CPU
He aludido anteriormente.

2546
02:05:41,280 --> 02:05:43,100
Eso es lo que Intel Inside.

2547
02:05:43,100 --> 02:05:45,030
>> Hay patrones de
ceros y unos que

2548
02:05:45,030 --> 02:05:51,800
asignar a éstos redactada arcanamente, pero
algo así-llamado, instrucciones,

2549
02:05:51,800 --> 02:05:52,780
por así decirlo.

2550
02:05:52,780 --> 02:05:54,780
Eso es lo que sucede cuando
compilar el código.

2551
02:05:54,780 --> 02:05:58,560
Usted consigue el montaje
lengua fuera de él, lo cual

2552
02:05:58,560 --> 02:06:04,680
significa el tercer paso es ensamblar
que el código de montaje en, en última instancia,

2553
02:06:04,680 --> 02:06:09,080
ceros máquina code-- y unos, no las
texto que acabamos de ver hace un momento.

2554
02:06:09,080 --> 02:06:13,370
>> Por lo tanto pre-tratamiento no que encuentran
y reemplazar, y algunas otras cosas.

2555
02:06:13,370 --> 02:06:16,430
Compilación toma su fuente
código de C, el código fuente

2556
02:06:16,430 --> 02:06:18,980
que escribimos, para el montaje
código que acabamos echó un vistazo a.

2557
02:06:18,980 --> 02:06:22,170
Montaje detiene ensamblaje
código para ceros y unos

2558
02:06:22,170 --> 02:06:24,680
que la CPU realmente se
comprender al final del día.

2559
02:06:24,680 --> 02:06:27,630
Y la vinculación es el último paso
eso sucede para nosotros-- de nuevo,

2560
02:06:27,630 --> 02:06:29,830
tan rápido que ni siquiera
notice-- que dice:

2561
02:06:29,830 --> 02:06:32,460
eh equipo, tomar todas
los ceros y unos que

2562
02:06:32,460 --> 02:06:36,750
el resultado de la compilación de código de David,
y su función principal en este caso.

2563
02:06:36,750 --> 02:06:39,160
>> Y oye ordenador, ir a buscar
todos los ceros y unos

2564
02:06:39,160 --> 02:06:42,180
que el personal CS50 escribió
dentro de la biblioteca CS50.

2565
02:06:42,180 --> 02:06:43,440
Mezclar los de David de.

2566
02:06:43,440 --> 02:06:46,648
Y oye ordenador, ir a buscar todos los ceros
y los que otra persona escribió años

2567
02:06:46,648 --> 02:06:47,470
Hace de printf.

2568
02:06:47,470 --> 02:06:49,880
Y añadir aquellos en el
cosa entera, por lo que hemos

2569
02:06:49,880 --> 02:06:52,870
tengo mis ceros y unos, la
ceros y unos del personal CS50,

2570
02:06:52,870 --> 02:06:55,370
printf los ceros y unos,
y cualquier cosa que esté utilizando.

2571
02:06:55,370 --> 02:07:00,410
>> Todos ellos consiguen combinarse entre sí en una sola
programa llamado, en este caso, hola.

2572
02:07:00,410 --> 02:07:03,141
Así que de ahora en adelante, nos limitaremos
utilizar la palabra compilación.

2573
02:07:03,141 --> 02:07:06,390
Y vamos a dar por sentado que cuando
decimos, compilar el programa, es decir,

2574
02:07:06,390 --> 02:07:08,849
Hey hacer el pre-procesamiento,
montaje, y la vinculación.

2575
02:07:08,849 --> 02:07:11,890
Pero en realidad hay algunas cosas jugosas
pasando allí debajo de la campana.

2576
02:07:11,890 --> 02:07:13,723
Y sobre todo si
sentir curiosidad algún tiempo,

2577
02:07:13,723 --> 02:07:15,900
se puede empezar a jugar
en torno a este nivel inferior.

2578
02:07:15,900 --> 02:07:19,660
Pero por ahora, darse cuenta de que
entre los robos de balón para hoy

2579
02:07:19,660 --> 02:07:23,420
son, sencillamente, la
inicio de un proceso,

2580
02:07:23,420 --> 02:07:26,700
de sentirse cómodo con
algo así como hola mundo.

2581
02:07:26,700 --> 02:07:29,575
De hecho, la mayor parte de lo que hicimos hoy
luego, no se hundirá en super rápida.

2582
02:07:29,575 --> 02:07:31,491
Y que tomará algún
tiempo, y algo de práctica.

2583
02:07:31,491 --> 02:07:33,864
Y las probabilidades son, que va a clasificar
de querer golpear el teclado

2584
02:07:33,864 --> 02:07:34,780
o gritar a la pantalla.

2585
02:07:34,780 --> 02:07:35,880
Y todo eso está bien.

2586
02:07:35,880 --> 02:07:38,320
Aunque, tal vez trate de no
hacerlo en la biblioteca tanto.

2587
02:07:38,320 --> 02:07:40,820
>> Y en última instancia, se le
ser capaces, sin embargo, para empezar

2588
02:07:40,820 --> 02:07:44,580
ver patrones, tanto en buen código
que has escrito y en errores

2589
02:07:44,580 --> 02:07:45,370
que usted ha hecho.

2590
02:07:45,370 --> 02:07:48,965
Y al igual que el proceso de
convirtiendo en un TF o una CA es como,

2591
02:07:48,965 --> 02:07:51,590
usted comenzará a mejorar y
mejor al ver a esos patrones,

2592
02:07:51,590 --> 02:07:53,774
y acaba de resolver su
propios problemas en última instancia.

2593
02:07:53,774 --> 02:07:56,940
Mientras tanto, habrá un montón
de nosotros para prestarle apoyo, y conseguir que

2594
02:07:56,940 --> 02:07:57,481
a través de esto.

2595
02:07:57,481 --> 02:07:59,450
Y en los escritura-ups
para todos los problemas

2596
02:07:59,450 --> 02:08:01,366
va a ser guiado a través de
todos los comandos

2597
02:08:01,366 --> 02:08:05,330
que por cierto, conozco de
mucha práctica por ahora,

2598
02:08:05,330 --> 02:08:07,380
pero podría haber volado
encima de la cabeza por ahora.

2599
02:08:07,380 --> 02:08:08,580
Y eso es totalmente bien.

2600
02:08:08,580 --> 02:08:11,230
>> Pero, en última instancia, vas
para empezar a ver patrones emergen.

2601
02:08:11,230 --> 02:08:14,260
Y una vez que pasas toda la
estúpidos detalles, como paréntesis,

2602
02:08:14,260 --> 02:08:16,710
y llaves, y puntos y comas,
y las cosas, francamente,

2603
02:08:16,710 --> 02:08:19,360
que no es en absoluto
intelectualmente interesante.

2604
02:08:19,360 --> 02:08:22,690
Y no es el objetivo de
tomar cualquier clase de introducción.

2605
02:08:22,690 --> 02:08:24,410
Es las ideas que se van a importar.

2606
02:08:24,410 --> 02:08:26,659
>> Es los bucles, y el
condiciones y las funciones,

2607
02:08:26,659 --> 02:08:30,552
y con más fuerza la abstracción,
y la factorización de código,

2608
02:08:30,552 --> 02:08:33,510
y el buen diseño y la buena
estilo, y en última instancia la corrección

2609
02:08:33,510 --> 02:08:37,330
de su código, que es en última instancia,
va a importar más.

2610
02:08:37,330 --> 02:08:40,925
Así que la próxima semana, vamos a tomar estas
ideas que vimos por primera vez en Scratch

2611
02:08:40,925 --> 02:08:42,800
y ahora se han traducido
a C. Y vamos a empezar

2612
02:08:42,800 --> 02:08:45,740
para introducir la primera de las
dominios del mundo real del curso.

2613
02:08:45,740 --> 02:08:50,140
>> Nos centraremos en el mundo de la seguridad,
y más específicamente la criptografía,

2614
02:08:50,140 --> 02:08:51,980
el arte de la codificación de la información.

2615
02:08:51,980 --> 02:08:54,000
Y entre los primeros
ustedes el problema usted mismo

2616
02:08:54,000 --> 02:08:56,840
se llega a escribir más allá
jugando con algunos de la sintaxis

2617
02:08:56,840 --> 02:08:59,880
y la solución de algunos lógica
problemas, en última instancia, en poco tiempo,

2618
02:08:59,880 --> 02:09:03,960
es en realidad para codificar o encriptar,
y, finalmente, descifrar la información.

2619
02:09:03,960 --> 02:09:06,470
Y todo lo que hemos hecho
hoy en día, lo hará bastante baja

2620
02:09:06,470 --> 02:09:09,190
nivel, es sólo va a permitir
que tomemos uno, y uno,

2621
02:09:09,190 --> 02:09:13,550
y un paso más hacia arriba
escribir el código más interesante aún.

2622
02:09:13,550 --> 02:09:15,050
>> Por lo tanto más en que la próxima semana.

2623
02:09:15,050 --> 02:09:17,834

2624
02:09:17,834 --> 02:09:18,762
>> [REPRODUCCIÓN DE VÍDEO]

2625
02:09:18,762 --> 02:09:19,690

2626
02:09:19,690 --> 02:09:22,006
>> -¿Qué Puede decirme de
la última vez que lo viste?

2627
02:09:22,006 --> 02:09:26,041

2628
02:09:26,041 --> 02:09:27,040
-¿Qué Puede decir que, en realidad?

2629
02:09:27,040 --> 02:09:30,500

2630
02:09:30,500 --> 02:09:35,340
Quiero decir, era como cualquier otro
ensayo de pre-producción,

2631
02:09:35,340 --> 02:09:40,510
excepto que no había algo que dijo
al final que me quedó grabada.

2632
02:09:40,510 --> 02:09:44,810

2633
02:09:44,810 --> 02:09:46,640
>> -Este Fue CS50.

2634
02:09:46,640 --> 02:09:49,440

2635
02:09:49,440 --> 02:09:52,190
>> -Es Un corte de todo el mundo,
gran trabajo en el ensayo.

2636
02:09:52,190 --> 02:09:53,070
>> El almuerzo de -esto?

2637
02:09:53,070 --> 02:09:54,986
>> Sí, usted y yo podemos
tomar un bocadillo en un rato.

2638
02:09:54,986 --> 02:09:58,380
Me dejaron con Debrief
David muy rápidamente.

2639
02:09:58,380 --> 02:09:59,160
David?

2640
02:09:59,160 --> 02:10:01,260
David?

2641
02:10:01,260 --> 02:10:03,110
>> [FIN DE REPRODUCCIÓN]

