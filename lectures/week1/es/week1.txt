[REPRODUCIENDO MÚSICA] DAVID J. MALAN: Muy bien, esto es CS50. Y esta es la semana uno. Así que recordar que la última vez en la semana cero, nos hemos centrado en el pensamiento computacional. Y que la transición de que a Scratch, una programación gráfica el lenguaje de nuestros amigos en el Laboratorio de Medios del MIT. 

Y con Scratch, nos exploramos ideas como las funciones y condiciones, y los bucles y variables, e incluso eventos, e hilos, y más. Y hoy, vamos a seguir utilizando esas ideas, y realmente tomarlas por sentado, pero traducirlas a otro idioma conocido como C. Ahora, C es un lenguaje más tradicional. Es un nivel más bajo idioma, si se quiere. 

Es puramente textual. Y así, a primera vista, es todo va a parecer más bien críptica si nunca has programado antes. Vamos a tener punto y coma, y ​​paréntesis, y llaves, y más. Pero darse cuenta de que incluso aunque la sintaxis es a punto de mirar un poco familiarizado para la mayoría de ustedes, ver más allá de eso. Y tratar de ver las ideas que son, de hecho, familiar, porque aquí en la semana uno lo vamos a empezar a hacer es comparar, Inicialmente, a los arañazos en comparación con C. 

Así, por ejemplo, recordar que cuando implementado el primero de nuestros programas última vez, tuvimos un bloque que parecía un poco de algo así- cuando bandera verde se hace clic, y luego tuvimos una o más piezas del rompecabezas por debajo de ella, en este caso, decir, hola mundo. Así que, de hecho, en Scratch, al hacer clic en esa bandera verde para ejecutar mi programa, por lo hablar, estos son los bloques que se ejecutan, o correr. Y, en concreto, Scratch dijo, hola, mundo. 

Ahora, podría haber especificado diferentes palabras aquí. Pero veremos que, de hecho, muchos de estos blocks-- y, de hecho, en C muchas functions-- pueden ser parametrizada o personalizada para hacer cosas diferentes. De hecho, en C si querer convertir, ahora, este programa de Scratch a este otro idioma, vamos a escribir una poco algo como esto. 

Por supuesto, hay alguna desconocida Sintaxis hay más probable, int, y los paréntesis y sin efecto. Pero printf-- a pesar de que lo haría creo que sería sólo de impresión. Pero la impresión de impresión significa formateado, como pronto veremos. Esto, literalmente, se imprimirá a la pantalla lo está dentro de esos paréntesis, que por supuesto, en este caso es, hola mundo. 

Sin embargo, se dará cuenta de alguna otra sintaxis, algunas citas dobles, que los paréntesis al final, el punto y coma y similares. Así que hay un poco de sobrecarga, por así decirlo, tanto cognitivamente y sintácticamente, que vamos tener que recordar en poco tiempo. Pero darse cuenta de que con la práctica, esto comenzará a saltar a la vista. 

De hecho, vamos a centrarnos en que uno función specifically-- en este caso, saludar mundo. Así es decir la función. Hola mundo es su parámetro, o argumento, su personalización. 

Y la equivalencia en C es sólo esto va a ser una línea aquí, donde printf es equivalente a, por ejemplo, la cadena entre comillas dobles, hola mundo es equivalente, por supuesto, a lo que hay en la caja blanca allí. Y la barra invertida n, aunque un poco extraña y ausente de Scratch, simplemente va a tener el efecto que vamos a ver en una computadora, como mi Mac o un PC, de tan sólo mover el cursor a la siguiente línea. Es como golpear Intro en el teclado. 

Así que veremos de nuevo en poco tiempo. Pero primero, vamos a echar un vistazo a este otro ejemplo en el caso de los bucles. Hemos tenido este bucle infinito última vez, que era una serie de piezas de un rompecabezas que hicieron algo, literalmente, forever-- en este caso, decir hola mundo, Hello World, hola mundo, hola mundo. Así que es un bucle infinito por diseño. 

En C, si queremos poner en práctica este misma idea, que podría simplemente hacer esto. Aunque es verdad, printf hola mundo-- ahora mientras que, al igual semánticamente, tipo de evoca la idea de hacer algo otra vez, y otra vez, y otra vez, ¿y por cuánto tiempo? Bueno, recuerdo que cierto-- es cierto sólo en o uno. 

Y es cierto, por supuesto, siempre es cierto. Así que es una especie de sentido declaración que acaba de decir verdad. Pero de hecho, esto es deliberado, porque si es cierto es justo siempre es cierto, que mientras que la verdadera simplemente implica, si un poco indirectamente, que las siguientes líneas de código entre esas llaves sólo debe ejecutar de nuevo, y de nuevo, y otra vez, y en realidad nunca parar. 

Pero si usted quiere que su bucle para detener, ya que fue la última vez con algo así como esto, repita los siguientes 50 veces, en C podemos hacer lo mismo con lo que hay llamado para loop-- la palabra clave no siendo tiempo, pero para. Y entonces tenemos una nueva sintaxis aquí, con int i es igual a 0, i de menos de 50, i ++. Y vamos a volver a eso. Pero esto es simplemente la forma en que lo haría traducir el conjunto de bloques de Scratch a un conjunto de líneas C de código. 

Mientras tanto, considerar variables. Y, de hecho, sólo vi uno hace un momento. Y en el caso de Scratch, si querido declarar una variable llamada i para i ser entero, sólo un número, y queremos ponerlo en algún valor, usaríamos esta naranja bloquear aquí-- i establece en 0. 

Y vamos a ver hoy y más allá, al igual que la semana pasada, programadores hacen casi siempre empezará a contar a partir de cero, de verdad por convención. Pero también porque el recuerdo de nuestra discusión de la binaria, el más pequeño número que puede representar con cualquier número de bits es sólo va a ser 0 en sí. Y así vamos a empezar por lo general inicializar incluso nuestras variables a 0. 

Y en C para hacer lo mismo, vamos a decir int por entero, sólo por convención. Podría haber llamado a esta variable lo que quiera, al igual que en Scratch. Y entonces es igual a 0 cesionarios el valor 0 por la derecha y la coloca en la variable, o el contenedor de almacenamiento de allí, a la izquierda. Y el punto y coma como vamos a ver-- y hemos visto algunos de estos ya-- Sólo significa fin del pensamiento. Procederá a hacer otra cosa en las líneas que siguen. 

Ahora, ¿qué pasa con las expresiones booleanas? Recordemos que en Scratch, éstas eran expresiones que son verdaderas o preguntas false--, Realmente, que son verdaderas o falsas. Así, en el caso de los arañazos, podríamos hacer una pregunta tan simple como este, i es menor que 50? Así que, de nuevo, es un número entero. Tal vez lo estamos utilizando en un programa de Scratch hacer un seguimiento de una puntuación o algo así. Así que esta sintaxis aquí en Scratch Sólo significa, i es inferior a 50? Bueno, por suerte, es algo simple en C. Y para traducir, esto sería simplemente decir que menos de 50, utilizando la clave familiarizado en su teclado. 

Mientras tanto, si usted quiere decir algo más general, como, bueno, es x menor que y donde cada uno de X e Y son ellos mismos variables? Podemos hacer la misma cosa en C, tanto tiempo como hemos creado estas variables ya. Y veremos cómo hacer que en poco tiempo. Nos gustaría decir simplemente x menor que y. 

Así que usted está comenzando a ver algunas similitudes. Y aquellas personas que hicieron Scratch fueron sin duda inspirado en algunas de estas ideas básicas. Y verá este tipo de Las Lenguas de sintaxis en muchos No sólo rascar, no simplemente C, pero Python, y JavaScript, y otros idiomas aún. 

Vamos a considerar otra construcción de C, la noción de una condición, hacer algo de forma condicional. Si algo es cierto, hacer esto. Si hay algo más es cierto, hacer eso. Es una especie de la programación equivalente a un tenedor en la carretera. Tal vez sea un tenedor de dos vías, una de tres vías tenedor, o más. Y en Scratch, podríamos tener visto algo como esto. 

Así que éste es un grande. Pero tenga en cuenta la relativa simplicidad de la lógica. Si x es menor que y, a continuación, decir x es menor que y, más si x es mayor que y, luego decir x es mayor que y. Y entonces, lógicamente, si piensa volver a los arañazos o simplemente su propia intuición humana, así, si x no es mayor que y, y x no es menor que y, a continuación, por supuesto x va a ser igual a y. Así pues, en este caso, por la jerarquización esos bloques de Scratch, podemos lograr un período de tres tenedor camino en el camino? 

Mientras tanto, si queremos hacer que en C, podría decirse que se ve un poco simpler-- al menos Una vez que se familiarice con la sintaxis. Si x es menor que y, printf x es menor que y. Else si x es mayor que y, printf x es mayor que y. Else printf x es igual a Y- y, de nuevo, con los extremos de barra invertida solo para esas nuevas líneas de modo que si actualmente se encontró este tipo de programa que sería sólo mover el cursor en última instancia, a la siguiente línea de la pantalla. 

Ahora, por su parte arañazos tenía otra características más sofisticadas, solamente algunos de los cuales vamos a Inicialmente moverse hacia el mundo de la C. Y uno de ellos era llama una lista en Scratch. Y esto era un especial tipo de variable que permitió que le permite almacenar múltiples cosas en ella hacia atrás, hacia atrás, hacia atrás, hacia atrás. 

En C, que no tiene listas, per se, pero algo que son más generalmente llamada matrices, a pesar de que va volver más tarde este semestre que mira algo llama una lista, o en realidad una lista enlazada. Pero por ahora, el más cercano equivalente en C para nosotros va a ser algo denominado matriz. Y una matriz es simplemente una tipo especial de variable que le permite almacenar datos hacia atrás, hacia atrás, hacia atrás, hacia atrás. 

Y, de hecho, en Scratch, si queríamos acceder el primer elemento de una matriz o un películas-- y voy a llamarlo, por convención, argv, el argumento vector, pero más de eso en poco tiempo. Si quiero conseguir en el primer elemento de argv, en el mundo de los arañazos que realmente hacen típicamente empezará a contar a partir del 1. 

Y por lo que podría conseguir el artículo 1 de argv. Así es como el MIT implementado la noción de listas. Pero en C, voy a más simplemente decir, argv, que a su vez es el nombre de mi películas-- o para ser claros, una matriz. Y si quiero que la primera elementos, voy utilizar corchetes, que se puede que no se utiliza a menudo en un teclado. 

Pero a 0 significa, me la primera. Así que de vez en cuando y como el tiempo pasa, nos vamos para empezar a ver estas dicotomías entre cero y C, mediante el cual los arañazos utiliza uno. Nosotros utilizamos en C 0 aquí. Pero que da gusto ver una vez que entienda los fundamentos de cada idioma, que las estas cosas se ponen aún más familiar a través de la práctica y la práctica. 

Así que realmente se ven ahora en un programa. Aquí será el primero de nuestra C código fuente de programas completos. Y el programa que vamos para ofrecer a la consideración es la que es equivalente a ese pedazo de Scratch anterior. 

Así que aquí, tenemos lo que es sin duda el programa más simple C que se puede escribir En realidad hace algo. Ahora, vamos a ver más allá, por ahora, se ha incluir, io.h estándar, y éstos ángulo corchetes, y int, y sin efecto, y las llaves, y similares. 

Y vamos a centrarnos en lo que, al menos intuitivamente, podría saltan a la vista ya. De hecho, la principal, no lo creo necesariamente sabe lo que es esto, pero al igual que los arañazos que cuando tenían bandera verde clic pieza del rompecabezas, lo mismo ocurre con C como un lenguaje de programación tener una pieza principal de código que es ejecutado por defecto. Y de hecho, Es, literalmente, va a ser llamado principal. 

Así principal es una función. Y es una función especial que existe en C que cuando se ejecuta un programa, es principal que es atropellado por defecto. En el mundo de los arañazos, que era por lo general cuando la bandera verde hecho clic que consiguió funcionamiento por defecto. 

Mientras tanto, hemos visto esto antes, printf o de impresión con formato, eso es va a ser una función que viene con C, junto con un montón de otros, que la voluntad del tiempo y el tiempo de nuevo, con el fin de hacer exactamente como su nombre indica, imprimir algo. ¿Qué queremos para imprimir? Bueno, veremos que por caracteres que encierran como these-- hola mundo, n barra invertida entre comillas dobles, podemos decir exactamente printf Lo que hay que imprimir en la pantalla. 

Sin embargo, con el fin de hacer que, por desgracia necesitará tomar algo que es Ya críptica para nosotros los seres humanos, pero al menos es algo readable-- agudo incluyen, io.h estándar, int, principal, nula, printf, toda la mágica encantamientos que acabamos de ver en la pantalla. Pero en realidad tenemos que ir más arcano todavía. Primero tenemos que traducir el código que se escribe en código máquina. Y recordar a la semana pasada que las máquinas, al menos los que saben que aquí, al final de la día solamente entender ceros y unos. 

Y mi Dios, si tuviéramos que escribir estos ceros y unos a realidad el programa, que sería muy, muy rápidamente eliminar la diversión de nada. Pero resulta que, a la semana pasada, que estos patrones de ceros y unos sólo tienen un significado especial. En ciertos contextos, que pueden significar números. 

En algunos contextos, que pueden significar letras o colores, o cualquier número de otras abstracciones allí sobre. Pero al igual que el equipo tiene una CPU, Central Processing Unit, o el cerebro en el interior de su ordenador. Por lo general es Intel en el interior, porque eso es una de las mayores empresas que hace que las CPU de los ordenadores. 

Pues bien, las CPU Intel y otros simplemente han decidido de antemano que ciertos patrones de ceros y las cosas se entenderá específicos. Ciertos patrones de ceros y unos significará, imprimir esta a la pantalla, o añadir estos dos números, o restar estos dos números, o mover esta pieza de datos de la memoria de mi ordenador a través de aquí, o cualquier otro número de muy bajo nivel, pero en última instancia útil, operaciones. Pero, por suerte, los humanos no van a necesitar saber este nivel de detalle. De hecho, como la última vez, en la que abstraído de nuevo, y otra vez, y otra vez, edificio de muy bajo nivel primitivas como ceros y unos a los conceptos de más alto nivel como números y letras, y los colores, y mucho más, por lo que podemos, como programadores de pie sobre los hombros de otros que han venido antes que nosotros y utilizar el software que otra personas han escrito antes de nosotros-- a saber, los programas llamados compiladores. 

C es un lenguaje que por lo general se compila, lo que significa convertido de código fuente a código máquina. En particular, lo que esto significa es que si usted tiene su fuente código que se escribe a sí mismo, como pronto lo hará en un momento en la pantalla, y quiere convertirlo en última instancia, a la máquina code-- esos ceros y unos que Sólo tu Mac o PC understands-- usted tiene una primera alimentar a que el código fuente como en de entrada a una especial programa llamado un compilador, la salida de la cual verá es el código máquina. Y, de hecho, la última vez que hablamos aproximadamente, en realidad, al final del día, la resolución de problemas. Tienes entradas. Y usted tiene salidas. Y usted tiene algún tipo de algoritmo en el medio. 

Los algoritmos pueden ser sin duda implementado en software, como hemos visto con pseudocódigo la semana pasada y como veremos con código real esta semana. Y así, un compilador en realidad sólo tiene un conjunto de algoritmos en el interior de la misma que saber cómo convertir las palabras clave especiales, como principal, y printf, y otros que acabamos vio en los patrones de ceros y los que Intel Inside y otras CPU realmente entiende. ¿Entonces como hacemos esto? ¿De dónde obtenemos un compilador? 

La mayoría de los que estamos aquí tenemos un Mac o un PC. Y se está ejecutando Mac OS, o Windows o Linux o Solaris, o cualquier número de otra sistemas operativos. Y, de hecho, podríamos salir a la web y descargar un compilador para su Mac o PC para su sistema operativo en particular. Sin embargo, todos estaríamos en diferentes páginas, por así decirlo. Nos gustaría tener un poco diferentes configuraciones. Y las cosas no funcionarían todo lo mismo. Y, de hecho, en estos días muchos de nosotros no utilice software que se ejecuta sólo en nuestros ordenadores portátiles. En cambio, usamos algo como un navegador que nos permite tener acceso basado en web- aplicaciones en la nube. Y a finales de este semestre, vamos a hacer exactamente eso. Vamos a escribir aplicaciones o software no usar code-- C, pero otros lenguajes como Python y JavaScript-- que se ejecutan en la nube. 

Y para hacer eso, nosotros mismos durante el semestre en realidad utilizar una nube-basado ambiente conocido como CS50 IDE. Esta es una programación basada en web medio ambiente, o el desarrollo integrado medio ambiente, IDE, que está construida encima de algunos software de código abierto llamado Cloud 9. Y hemos hecho algunos pedagógica simplificaciones en lo con el fin de ocultar ciertas características en las primeras semanas que no necesitamos, después de lo cual se puede revelarlas y hacer la mayor parte lo que quiera con el medio ambiente. 

Y nos permite, también, para pre-instalar cierto tipo de software. Cosas como un denominado CS50 biblioteca, que pronto veremos nos proporciona en C con un poco funcionalidad adicional. Así que si vas a, en última instancia, CS50.io, se le pedirá que ingrese, y una vez que haces y crear una cuenta de forma gratuita, usted será capaz de acceder a una ambiente que se ve bastante como éste. 

Ahora, esto es en el modo por defecto. Todo es agradable y brillante en la pantalla. Muchos de nosotros tenemos la costumbre de trabajar en la pieza que es CS50 bastante tarde en la noche. Y por lo que algunos de ustedes podrían preferir convertirlo en modo nocturno, por así decirlo. 

Pero, en última instancia, lo que está vamos a ver dentro IDE CS50 es de tres areas-- distinta un área de la izquierda donde sus archivos van a estar en el nube, un área en la parte superior derecha donde el código va a ser editable. Podrás abrir fichas individuales para cualquier programa que se escribe dentro de este semestre de la esquina superior derecha. Y entonces la mayoría arcanamente, y sin embargo de gran alcance, va a ser esta cosa en el inferior conocida como una ventana de terminal. 

Esta es una vieja escuela Interfaz de línea de comando, o CLI, que permite ejecutar comandos en el computer-- en este caso, el equipo en el cloud-- para hacer cosas como compilar el código desde el código fuente a código máquina, para ejecutar sus programas, o para iniciar su servidor web, o para acceder a su base de datos, y cualquier número de otras técnicas que vamos a empezar a utilizar después de poco tiempo. Pero para llegar allí, estamos va a tener realmente ir en línea y empezar a jugar. Y para hacer eso, primero vamos a empezar jugando con principal, y escribir la parte principal de un programa. Y vamos a utilizar esa función printf, que hemos utilizado anteriormente, simplemente para decir algo. 

Así que aquí estoy ya en el interior del IDE CS50. He conectado con antelación. Y me llena exhibió la ventana. Y así, en última instancia, se también en problemas próximos seguirá los mismos pasos que proporcionará documentación en línea. Por lo que no tiene que preocuparse acerca absorbiendo cada pequeño paso técnico que hago hoy aquí. 

Pero obtendrá una pantalla como esta. Da la casualidad que en el modo nocturno. Y se puede iluminar todo por desactivación del modo noche. Y al final de la día, vas a ver estos tres principales areas-- el archivo navegador de la izquierda, las lengüetas de código encima de la tapa, y la ventana de terminal en la parte inferior. 

Déjame ir adelante y escribir mi primer programa. Voy a ir a Archivo preventivamente, Guardar y salvar mi archivo como hola.c. De hecho, por convención, cualquier programa que escriben que está escrito en el lenguaje C debe tener asignado un nombre punto c, por convención. Así que voy a nombrarlo hola.c, porque Sólo quiero decir hola al mundo. Ahora voy a enfocar y haga clic en Guardar. Y todo lo que tengo aquí ahora es una pestaña en el que puedo empezar a escribir código. 

Esto no va a compilar. Esto no significa nada. Y por lo que incluso si Convertí esto a ceros y unos, la CPU va a tener ningún idea de lo que está pasando alrededor. Pero si escribo líneas que coinciden con ser conventions-- C de C, de nuevo, esta language-- con una sintaxis como esto, printf hola mundo-- y no tengo ha sentido cómoda con hacer esto con el tiempo. Así que no creo que hice los errores tipográficos. 

Pero, invariablemente, el primer vez que lo haga, lo hará. Y lo que estoy a punto de hacer podría muy así no funcionar para usted la primera vez. Y eso es perfectamente bien, porque en este momento se sólo podría ver una gran cantidad de novedad, pero con el tiempo una vez que se familiarice con este entorno, y este lenguaje, y otros, usted comenzará a ver las cosas que son correctas o incorrectas. 

Y esto es lo que el compañeros de enseñanza y curso asistentes se ponen tan bueno en el transcurso del tiempo, se la detección de errores o fallos en su código. Pero sostengo que hay hay errores en el código. Así que ahora quiero para ejecutar este programa. 

Ahora, en mi propio PC o Mac, estoy en el hábito de hacer doble clic en los iconos cuando quiero ejecutar algún programa. Pero eso no es el modelo aquí. En este entorno, que es CS50 IDE. Estamos utilizando un operativo sistema llamado Linux. Linux es una reminiscencia de otro sistema operativo, conocido generalmente como Unix. Y Linux es especialmente conocido por que tiene una línea de comandos para el Medio Ambiente, la CLI. Ahora, estamos utilizando una específica distribución de Linux llamada Ubuntu. Y Ubuntu es simplemente una cierta versión de Linux. 

Pero de éstos Linux en estos días hacen realidad vienen con interfaces gráficas de usuario. Y la que nos ha tocado se utiliza aquí está basado en web. Por lo que este podría ser incluso una poco diferente de algo usted mismo puede ser que tenga visto o correr en el pasado. 

Así que voy a seguir adelante ahora y hacer lo siguiente. He guardado este archivo como hola.c. Voy a seguir adelante y Tipo clanghello.c Así Clang para el lenguaje C es un compilador. Es pre-instalado en CS50 IDE. Y se puede descargar y absolutamente instalarlo en su propio Mac o PC. 

Pero, de nuevo, no tendrías todos la preconfiguración hecho para usted. Así que por ahora, sólo soy va a ejecutar clanghello.c. Y ahora cuenta esta sintaxis aquí con el tiempo se cuenta sólo significa que estoy en una carpeta o directorio llamado espacio de trabajo. Esta muestra de dólar es simplemente convención de sentido, escriba los comandos aquí. 

Es lo que se llama un símbolo, simplemente por convención es signo de dólar. Y si sigo adelante ahora y haga clic Introduzca, nada parece haber sucedido. Pero eso es realmente una buena cosa. Cuanto menos eso sucede en su pantalla, es más probable el código es correcto, al menos sintácticamente. 

Así que si quiero ejecutar este programa, ¿qué hago? Pues bien, resulta que la nombre predeterminado por convención para los programas cuando no se especifica una nombre para su programa es sólo a.out. Y esta sintaxis también, podrás familiarizarse con poco tiempo. 

Dot slash sólo significa, bueno, CS50 IDE, ejecute un programa llamado a.out eso es dentro de mi directorio actual. Ese punto se refiere al directorio actual. Y vamos a ver qué otras secuencias de caracteres significa antes de tiempo. 

Así que aquí vamos, Enter, hola mundo. Y se dará cuenta, que lo que ha pasado? No sólo se imprime hola mundo. También se trasladó la cursor a la siguiente línea. 

Y por qué fue eso? ¿Cuál era el código que escribimos antes que aseguró que lo haría el cursor ir en la línea siguiente? Lo más gracioso de una equipo es que sólo va hacer literalmente lo que usted le diga que hacer. 

Así que si usted le dice a printf hola, coma, espacio, mundo, cerca de la cita, Es, literalmente, sólo se va para imprimir los caracteres. Pero tenía este carácter especial al final, el recuerdo, la barra invertida n. Y eso es lo que asegura que el carácter se a la siguiente línea de la pantalla. 

De hecho, me dejó ir y hacer esto. Déjame ir por delante y borrar esto. Ahora, observe que la la parte superior de la pantalla hay un poco de luz roja en la pestaña que indica, bueno, no se ha guardado el archivo. Así que voy a seguir adelante con el control S o S comando, guardar el archivo. Ahora goes-- fue a dar un color verde moment--. Y ahora es hora de volver a simplemente ser un icono de cierre. 

Si ahora corro clanghello.c de nuevo, Introducir, barra de puntos, a.out, Enter, verá que todavía funcionaba. Pero es sin duda un poco buggy. En este momento, mi espacio de trabajo prompt--, y después de que el signo de dólar, y luego mi prompt-- real es todo en la misma línea. Así que esto ciertamente un error estético, aunque en realidad no es un error lógico. 

Así que voy a deshacer lo que acabo de hacer. Voy a volver a ejecutar a.out. Aviso He añadido el volver carácter de nueva línea. He guardado el archivo. 

Así que voy a volver a ejecutar a.out, y- maldita sea, un error, un error que significa error. Por lo que el fallo es que a pesar de que He añadido la barra invertida n allí, re-guardado, volvieron a realizar el programa, el comportamiento fue el mismo. ¿Por qué sería? 

Me falta un paso, ¿verdad? Ese paso clave anterior era que tienes a-- cuando cambie su código fuente, Resulta que también funcionan a través del compilador de nuevo para que pueda obtener nuevo código máquina. Y el código máquina, los ceros y unos, van a ser casi idénticos, pero no perfectamente así, porque necesitamos, por supuesto, que la nueva línea. 

Así que para solucionar este problema, voy a necesitar volver a ejecutar clanghello.c, introduzca, punto raya vertical, a.out. Y ahora, hola mundo está de vuelta a donde yo esperaba que fuera. Así que esto es todo fino y bueno. Pero a.out es un nombre bastante estúpido para una programa, a pesar de que pasa a ser, por razones históricas, la default-- significa salidas de montaje. 

Pero déjame ir por delante aquí y hacer esto de manera diferente. Quiero que mi programa hola mundo para realmente ser llamado hola. Así que si se tratara de un icono en mi escritorio, no se a.out. Se llamaría hola. 

Así que para hacer esto, resulta Clang que, al igual que muchos programas, apoya los argumentos de línea de comandos, o banderas, o interruptores, que simplemente influir en su comportamiento. En concreto, Sonido metálico soporta un tablero o bandera, que a su vez lleva a una segunda palabra. En este caso, me voy de manera arbitraria, pero razonablemente, lo llaman hola. Pero podría llamar de cualquier Quiero, excepto a.out, que sería más bien el punto. 

Y a continuación, sólo tiene que especificar el nombre del archivo sí quiero compilar. Así que ahora a pesar de que al principio del comando todavía tengo Clang, al final del comando Todavía tengo el nombre del archivo, Ahora tengo estos línea de comandos argumentos, estas banderas que están diciendo, Oh, por cierto, la producción-o, un archivo hola llamada, no el a.out por defecto. 

Así que si pulsa enter ahora, nada parece haber ocurrido. Y, sin embargo, ahora que puedo hacer barra de puntos hola. Así que es el mismo programa. Los ceros y unos son idénticos al final del día. 

Pero están en dos a.out diferente archivos--, que es la primera versión y justo llamado tontamente, y ahora hola, lo que es una gran parte nombre más convincente para un programa. Pero, honestamente, nunca estoy va a recordar esto de nuevo, y otra vez, y otra vez. Y, en realidad, mientras escribimos programas más complicados, los comandos que usted está va a tener que escribir se va a poner aún más complicado aún. 

Y por lo que no se preocupe. Resulta que los humanos antes Nos hemos dado cuenta de que ellos también tenido este mismo problema. También ellos no disfrutaban de tener que escriba los comandos, bastante largos arcanos, y mucho menos recordar. Y así los seres humanos que se nos han hecho otros programas que hacen que sea más fácil para compilar el software. 

Y, de hecho, uno de estos programa se llama Make. Así que voy a seguir adelante y hacerlo. Voy a deshacer todo lo acaba de hacer de la siguiente manera. Permítanme LS tipo. Y se dará cuenta de tres cosas- a.out, y una estrella, hola y una estrella, y hola.c. Con suerte, esto debería ser un poco intuitivo, la medida en que anteriormente no había nada en este espacio de trabajo. No había nada que yo tenía creado hasta que empezamos a clase. 

Y creé hola.c. entonces yo compilé, y lo llamó a.out. Y luego he recopilado de nuevo ligeramente de manera diferente y lo llamó hola. Así que tengo tres archivos en este directorio, En esta carpeta se llama espacio de trabajo. Ahora, puedo ver que a su vez si Alejar realidad. 

Si Alejar aquí y mira ese superior derecha esquina, como se había prometido la izquierda lado de la pantalla siempre va a mostrar lo que está en su cuenta, lo que es dentro del IDE CS50. Y hay tres archivos allí. 

Así que quiero para deshacerse de a.out y hola. Y como puede ser que imaginar intuitivamente, se podría tipo de control de clic o haga clic derecho sobre esta. Y este pequeño menú emergente. Puede descargar el archivo, ejecute que, vista previa, actualizar, cambiar el nombre, o lo que no. 

Y yo sólo podía eliminar, y se iría. Pero vamos a hacer las cosas con un comando línea de momento, de manera que se sienta cómodo con esto, y hacer lo siguiente. Voy a seguir adelante y eliminar a.out escribiendo literalmente rma.out. Resulta que, el comando de la eliminación o eliminación de algo, no elimina ni borra. 

Es más sucintamente RM, sólo para ahorrar que algunas combinaciones de teclas y pulse la tecla Enter. Ahora vamos a ser algo crípticamente eliminar a.out regular. Realmente no sé lo que es una archivo irregular sería aún. Pero sí quiero quitarlo. 

Así que voy a escribir y para sí. O podría escribir un vistazo, y pulsa Enter. Y, de nuevo, parece que nada sucede. Pero eso es, en general, una buena cosa. 

Si escribo LS este tiempo, ¿qué debo ver? Con suerte, apenas hola y hola.c. Ahora, como un aparte, se le cuenta de esta estrella, asterisco, eso es al final de mis programas. Y también están mostrando en color verde. Eso es sólo el camino del CS50 IDE de que cluing en el hecho que ese no es el código fuente. Eso es un ejecutable, un ejecutable programa que en realidad se puede ejecutar haciendo barra de puntos, y luego su nombre. 

Ahora, déjame ir por delante y quitar esto, rm hola, Introducir, eliminar regulares presentar hola, sí. Y ahora si escribo LS, estamos de vuelta a hola.c. Trate de no eliminar su código fuente real. A pesar de que existen características incorporado en IDE CS50 donde usted puede ir a través de su historial de revisiones y retroceder en el tiempo si accidentalmente borrar algo, hacer tener en cuenta según estas indicaciones sí o no, de lo que realmente quiere hacer. Y si me voy hasta la cima esquina izquierda mano aquí, todo lo que queda es hola.c. Así que hay racimos de otros comandos que se puede ejecutar en el mundo de Linux, uno de los cuales es, de nuevo, Haz. Y vamos a hacer mi programa ahora de la siguiente manera. 

En vez de hacer ruido metálico, en lugar de hacer ruido metálico-o, Voy a simplemente literalmente, tipo, marca hola. Y ahora noto, yo soy No escribiendo make hola.c. Estoy escribiendo hacen hola. 

Y este programa Haga ese viene con el IDE CS50, y mucho más generalmente con Linux, es un programa que es va a hacer un programa llamado Hola. Y que va a suponer, por convención, que si este programa se puede hacer, que va a ser a partir de una fuente archivo de código que terminan en c punto, hola.c. 

Así que si golpeo Entra ahora, el aviso de que el comando que se ejecuta es incluso más largo antes de que antes. Y eso es porque hemos IDE CS50 preconfigurado para tener algunas características adicionales incorporadas en ese no necesitamos por el momento, pero pronto lo hará. Pero la clave para darse cuenta es que ahora tengo un programa Hola. 

Si escribo LS de nuevo, tener un programa de hola. Y puedo ejecutarlo con slash dot a.out, no, porque el objetivo de este ejercicio fue punto hola barra. Y ahora tengo mi programa hola mundo. Así se mueve hacia adelante, estamos casi siempre solo va a compilar nuestros programas utilizando el comando Crear. Y luego vamos a ejecutarlas punto slash, y el nombre del programa. Pero darse cuenta de lo que hacen está haciendo para usted, es que no es en sí un compilador. Es sólo un programa de conveniencia que sabe cómo activar un compilador para funcionar de modo que usted mismo puede utilizarlo. 

Lo que existen otros comandos en Linux, ya su vez el IDE CS50? Pronto veremos que hay una comando CD, Cambiar directorio. Esto le permite a la interfaz de línea de comandos para seguir adelante y hacia atrás, y abrir diferentes carpetas sin necesidad de utilizar el ratón. 

LS que vimos, que significa lista los archivos en el directorio actual. Hacer Dir, puede probablemente empezar a deducir lo que significan ahora-- hacer directorio, Si desea crear una carpeta. RM de Remove, RM Dir eliminar directory-- y éstos, de nuevo, son la línea de comandos equivalentes de lo que podría hacer en CS50 IDE con el ratón. Sin embargo, pronto se encontrará que a veces es sólo mucho más rápido que hacer cosas con un teclado, y en última instancia mucho más potente. 

Pero es difícil argumentar que todo lo que hemos estado haciendo hasta ahora es todo lo que poderosa, cuando todo que hemos estado diciendo es, hola mundo. Y, de hecho, la hardcoded palabras hola mundo en mi programa. No hay dinamismo aún. Scratch fue un orden de magnitud más interesante la semana pasada. 

Y así vamos a llegar allí. Vamos a dar un paso hacia la que por forma de algunas de estas funciones. Así que no sólo vienen con C printf, y racimos de otras funciones algunos de los cuales ya veremos con el tiempo, no lo hace que sea tan fácil a la derecha de la puerta para conseguir la entrada del usuario. 

De hecho, una de las debilidades de lenguajes como C, e incluso Java y, sin embargo otros, es que no lo hace hacer más fácil para obtener sólo las cosas como números enteros de usuarios, o cadenas, palabras, y frases, dejar que las cosas por sí solos como valores de puntos o números reales flotantes con puntos decimales, y realmente números largos, como pronto veremos. Por lo que esta lista de funciones aquí, éstos son como otras piezas del rompecabezas de Scratch que hemos pre-instalado en CS50 IDE que vamos a utilizar durante unas pocas semanas como ruedas de entrenamiento de las clases, y finalmente quitárselos, y buscar debajo del capó, tal vez, por lo cómo se implementan estas cosas. 

Pero para hacer esto, vamos a En realidad escribir un programa. Déjame ir adelante ahora. Y yo voy a crear un nuevo archivo haciendo clic en este pequeño plus, y haciendo clic en Nuevo archivo. 

Voy a guardar esta próxima uno como, digamos, string.c, porque quiero jugar con cuerdas. Y la cadena en C es sólo una secuencia de caracteres. Así que ahora vamos a seguir adelante y hacer lo siguiente. 

Incluir estándar y IO.h-- Resulta que IO estándar, IO sólo significa de entrada y de salida. Así resulta que esta línea aquí es lo son los EE.UU. vecina de usar printf. Printf, por supuesto, produce una salida. Así que con el fin de utilizar printf, resulta a cabo usted tiene que tener esta línea de código en la parte superior de su archivo. 

Y vamos a volver a lo que realmente significa en poco tiempo. Resulta que en cualquier programa C que escribo, Tengo que empezar con código que se parece a esto. Y usted notará CS50 IDE, y otra de desarrollo integrado ambientes como ella, Vamos a tratar de la mejor que pueden terminar su pensamiento. De hecho, hace un momento, si yo deshacer lo que he hecho, me golpeó Intro. 

entonces me golpeó rizado abierto corsé, pulse la tecla Enter de nuevo. Y se terminó mi pensamiento. Me dio una nueva línea, sangría no menos por razones de estilo agradable ya veremos. Y entonces se me dio de forma automática que corchete para terminar mi pensamiento. Ahora bien, no siempre supongo que lo que quiere hacer. Sin embargo, en gran parte, lo hace que ahorrar un poco las pulsaciones de teclado. Así que hace un momento, nos encontramos con este program-- hola, mundo, y luego compilado, y luego corrió la misma. Pero no hay dinamismo aquí. Lo que si queríamos ¿hacer algo diferente? Bueno, ¿y si yo quería en realidad obtener una cadena del usuario? Voy a utilizar una pieza del rompecabezas llama exactamente eso-- conseguir cadena. 

Resulta que en C que cuando usted no quiere para proporcionar información a una pieza del rompecabezas, o más correctamente a una función, literalmente sólo hacer paréntesis abierto, paréntesis de cierre. Así que es como si hubiera ninguna caja blanca para escribir en. El bloque decir antes tenía una pequeña caja blanca. No tenemos esa caja blanca ahora. 

Pero cuando llamo cadena GET, me querer poner el resultado en alguna parte. Así que un paradigma muy común en C es llamar a una función, como la cadena de llegar aquí, y luego almacenar su valor de retorno. Es el resultado de su esfuerzo en algo. 

Y lo que es lo construir en la programación, ya sea en Scratch o C ahora, que nosotros se puede utilizar para almacenar en realidad algo? Llamó una variable, ¿verdad? Y en Scratch, realmente no lo cuidar lo que estaba pasando en las variables. 

Pero en este caso, que realmente hacemos. Voy a decir cadena. Y entonces yo podría llamar esto lo que quiera. Voy a llamarlo nombre, consigue llegar cadena. 

Y ahora, incluso si eres un poco nuevo en esto, Noto que me falta algún detalle. Me estoy olvidando de un punto y coma. Tengo que terminar este pensamiento. Así que voy a mover el cursor, y pulsa punto y coma allí. Y lo que he acabo de hacer? En esta línea de código, el número 5 en el momento, Voy a llamar a cadena GET sin entradas. Así que no hay poco de blanco caja como el bloque tiene Guardar. 

Sólo estoy diciendo, hey, equipo, tráeme una cadena. El signo igual no es realmente un signo igual, per se. Es la asignación operador, lo que significa, Hey, ordenador, mueva el valor desde la derecha hacia la izquierda. Y en la izquierda, tengo el siguiente. 

Hey, ordenador, dame un string-- una secuencia de caracteres. Y llamar a esa cadena Nombre. Y no tienen ni siquiera llamarlo Nombre. 

Podría llamarlo, convencionalmente, algo así como S, al igual que hemos utilizado para i llamar a la variable i. Pero ahora tengo que hacer algo con él. Sería muy estúpido para tratar de compilar el código, se ejecuta este programa, aunque Estoy recibiendo una cadena, porque todavía es sólo va a decir hola mundo. 

Pero ¿qué pasa si quiero cambiar esto. ¿Por qué no puedo hacer esto? Porcentaje s, s comas. Y esto es un poco críptico todavía. 

Así que déjame hacer mi variables más clara. Permítanme mencionar esta variable Nombre. Y veamos si no podemos molestar aparte de lo que está pasando aquí. 

Así que en la línea cinco, estoy recibiendo una cadena. Y yo estoy almacenando esa cadena, cualquiera que sea el usuario ha escrito en en su teclado, en una variable llamada Nombre. Y resulta que printf hace no sólo tomar un argumento de doble citas, una entrada entre comillas dobles. 

Puede tomar dos, o tres, o más, tal que la segunda, o tercera, o cuarta, son todos los nombres de las variables, o valores que es propio, que desea conectar a, dinámicamente, esa cadena entre comillas. En otras palabras, ¿qué sería malo en esto? Si acabo de decir hola nombre, la barra invertida n, salvado mi archivo, compilado mi código, y corrió esto, ¿qué pasaría? 

Es sólo va a decir, hola nombre, literalmente N-A-M-E, que es una especie de estúpida porque no es diferente del mundo. Así que cualquier cosa es entre comillas lo que, literalmente, se imprime. Así que si quiero tener un marcador de posición allí, En realidad necesito usar una sintaxis especial. Y resulta que si usted lee el documentación de la función printf, se le dirá que si se utiliza por ciento s, se puede sustituir un valor de la siguiente manera. 

Después de una coma después de que comillas dobles, simplemente escribir el nombre de la variable que se quiere para enchufar en ese formato código, o especificador de formato, s por ciento para las cuerdas. Y ahora si me he salvado mi archivo, Vuelvo a mi terminal. Y Tipo Marca de cuerdas, porque, de nuevo, el nombre de este archivo que he elegido es string.c antes. 

Así que voy a decir Prefijo, introduzca. ¡Oh Dios, mira a todos los errores que hemos hecho ya. Y esto lo es--, esto es realmente como un programa de línea de seis siete? Así que aquí es donde se puede muy obtener rápidamente abrumadora. 

Esta ventana de terminal tiene ahora sólo regurgitado un gran número de mensajes de error. Sin duda, no tengo más errores mensajes de lo que tienen líneas de código. ¿Entonces qué está pasando? 

Bueno, la mejor estrategia que hacer en cualquier momento que no encontrarse con una abrumadora lista de errores por el estilo, está desplazarse hacia atrás, mire para el comando que acaba de ejecutar, que en mi caso es hacer cuerdas. Mira lo que hacen lo hizo, y eso es todo Clang comando larga, no es gran cosa allí. 

Sin embargo, el rojo es malo. Verde está tratando de ser gentil y servicial. Pero sigue siendo malo, en este caso. Pero ¿dónde está el mal? 

String.c, la línea cinco, de cinco caracteres. Así que esto es sólo convención común. significa algo de colon algo número de línea y el número de caracteres. Error, no declarada de uso cadena de identificador. Quiso decir estándar en? 

Así que, por desgracia, Clang está tratando de ser útil. Pero es malo, en este caso. No, Clang, no era mi intención IO estándar. Quiero decir que en la línea uno, sí. 

Pero la línea cinco es este de aquí. Y Clang no lo hace entender S-T-R-I-N-G. Es un identificador no declarado, una palabra que simplemente nunca ha visto antes. Y eso es porque C, el lenguaje estamos escribiendo código en este momento, no tiene variables denominadas cadenas. 

De lo contrario, por defecto, el soporte algo que se llama una cadena. Eso es un pedazo de CS50 jerga, pero muy convencional. Pero puedo solucionar este problema de la siguiente manera. 

Si añado una línea de código a la parte superior de este programa, incluir CS50.h, que es otro archivo en algún lugar dentro del CS50 IDE, en alguna parte en el disco duro, por así decirlo, del sistema operativo Ubuntu que estoy corriendo, que es el archivo que está va a enseñar el funcionamiento sistema de lo que es una cadena, simplemente io.h como estándar es el archivo en el sistema operativo que es va a enseñar lo que es printf. 

De hecho, habríamos conseguido un mensaje muy similar Si IO había admitido norma Io.h y trató de usar printf. Así que voy a seguir adelante y justo control de la toma L para borrar la pantalla. O puede escribir claro y lo hará acaba de limpiar la ventana del terminal. Pero todavía se puede desplazar hacia atrás en el tiempo. 

Y voy a volver a ejecutar Hacer una cadena. Cruzar los dedos esta vez, Intro. Oh, Dios mío, funcionó. que me muestra un comando largo críptica esto es lo que hace que genera a través de Sonido metálico, pero ningún mensaje de error. Así darse cuenta, a pesar de que podría obtener por completo abrumado con la número de mensajes de error, que sólo podría ser este molesto en cascada efecto, en Clang no entiende una cosa, lo que significa que entonces no entiende la palabra siguiente, o la línea siguiente. Y por lo que sólo se ahoga con su código. Sin embargo, la solución puede ser muy sencilla. Y por lo que siempre se centran en el primera línea de salida. Y si no lo hace comprenderlo, basta con ver para las palabras clave que podría ser pistas, y el número de línea, y el carácter, donde ese error podría ser. 

Ahora voy a seguir adelante y escribo punto slash, cadena, introduzca. Hm, no está diciendo hola nada. ¿Por qué? Pues bien, hay que recordar, ¿dónde está ejecutando? 

Probablemente es atrapado por el momento en un bucle, si se quiere, en la línea seis, Obtener debido a cadenas por diseño, escrita por el personal CS50, es, literalmente, significaba para sentarse no esperar, y esperar, y la espera de una cadena. Todo lo que entendemos por cadena es la intervención humana. Así que ya saben qué? Déjame ir por delante. Y sólo en un capricho, me dejó escribir mi nombre, David, introduzca. Ahora tengo un programa más dinámico. Se dijo, hola David. 

Si sigo adelante y correr de nuevo, voy a tratar de decir el nombre Zamila, introduzca. Y ahora tenemos un programa dinámico. No he codificado mundo. No he codificado nombrar, o David, o Zamila. 

Ahora es mucho más parecido a los programas sabemos, en la que si se tarda de entrada, produce resultados ligeramente distintos. Ahora bien, esto no es el mejor la experiencia del usuario, o UX. Puedo ejecutar el programa. 

No sé lo que se supone a hacer, a menos que en realidad miro o recordar el código fuente. Así que vamos a hacer el usuario experimentar un poco mejor con el más simple de las cosas. Permítanme volver a este programa, y ​​simplemente decir printf. 

Y déjame seguir adelante y decir su nombre, de colon, y un espacio, y luego un punto y coma. Y sólo por diversión, sin holgura n. Y eso es deliberada, porque yo no quiero el indicador para pasar a la siguiente línea. 

Quiero, en cambio, hacer esto, hacer cuerdas volver a compilar el código en la nueva máquina código de puntos slash cadena. Ah, esto es mucho más bonita. Ahora sé que en realidad lo que la computadora quiere que ponga, darle un nombre. 

Así que voy a seguir adelante y escribir en Rob, entrar, y hola, Rob. Por lo tanto, se da cuenta, esto sigue siendo, al final del día, solamente un programa de nueve líneas. Pero hemos tomado estos pasos de bebé. 

Escribimos una línea con la que nos estaban familiarizados, printf, hola mundo. A continuación, nos deshicimos de un poco de eso. Y que en realidad utilizamos cadena GET. Y tiramos ese valor en una variable. Y luego seguimos adelante y mejorado aún más con una tercera línea. Y este proceso iterativo de la escritura de software es realmente la clave. En CS50, y en la vida en general, por lo general, no debe sentarse, tener un programa en mente, y tratar de escritura toda la maldita cosa a la vez. 

Será, inevitablemente, como resultado de la manera más errores que nosotros mismos vimos aquí. Incluso yo, a día de hoy, en constante hacer otros errores estúpidos, son errores de hecho más duras que son más difíciles de entender. Pero va a cometer más errores más líneas de código que escriben todos a la vez. Y por lo que esta práctica de, escribir un poco de código que se sienta cómodo, compila que, ejecutarlo, probarlo de forma más general, A continuación, pasar por lo en-- al igual que mantuvimos capas y capas de la semana pasada, la construcción de algo muy sencillo de algo más complejo, hacer lo mismo aquí. No se siente, y tratar de escribir todo un problema. En realidad tomar estos pasos de bebé. 

Ahora, las cadenas no son todos tan útil para sí mismos. Nos habíamos hecho, idealmente, al igual que tiene algo más en nuestra caja de herramientas. Así que en realidad hacen exactamente eso. 

Déjame ir por delante ahora ya levantar un programa ligeramente diferente. Y vamos a llamar a este Int.C, por entero. Voy a, de manera similar, incluir CS550.h. Voy a incluir IO estándar. Y eso va a ser bastante común en estos primeros días de la clase. 

Y voy a listas a mí mismo con una función principal. Y ahora en vez de conseguir una cadena, vamos a seguir adelante y obtener un int. Digamos que es i, y lo llaman llegar int, cerca parens, punto y coma. Y ahora vamos a hacer algo con él, printf. 

Digamos algo así como hola, la barra invertida n, i coma. Así que estoy más o menos imitando lo que hice hace un momento. Tengo aquí un marcador de posición. He aquí por comas i, porque quiero para tapar i en que marcador de posición. 

Así que vamos a seguir adelante y tratar la elaboración de este programa. El archivo se llama int.c. Así que voy a decir, hacer int, ingrese. Oh mi Dios, pero no es gran cosa, ¿verdad? Hay un error. 

Hay un error sintáctico aquí de tal manera que el programa no puede compilarse dentro Int.C, línea siete, 27 caracteres, formato de error especifica tipo char estrella, cualquiera que sea. Pero el tipo de argumento es de tipo int. 

Así que aquí, también, no vamos a-- a pesar de que hoy en día es una gran cantidad de material, vamos a llenarte de absolutamente todas las características de C, y programar de manera más general, en tan sólo estas primeras semanas. Siempre hay a menudo va a ser la jerga con el que no está familiarizado. Y, de hecho, estrella char es algo vamos a volver a en una semana o el tiempo de dos. 

Pero por ahora, vamos a ver si podemos analizar las palabras que son familiares. Formatos-- por lo que oímos formato especificador, código de formato antes. Eso es familiar. Type-- pero el argumento tiene tipo int. Espera un minuto, i es un entero. 

Tal vez en realidad s por ciento tiene un significado definido. Y, de hecho, lo hace. Un entero, si desea printf para sustituirlo, en realidad se tiene que utilizar una especificador de formato diferente. Y no vas a saber esto a menos que alguien le dijo, o si lo había hecho antes. Pero por ciento i es lo puede ser utilizado comúnmente en printf para conectar un número entero. También puede usar ciento d para un entero decimal. Pero i es agradable y simple aquí. Así que vamos a ir con eso. 

Ahora voy a seguir adelante y vuelva a ejecutar make int, Intro. Eso es bueno, no hay errores. Dot slash OK int--, mala experiencia de usuario, porque no me he dicho qué hacer. Pero eso está bien. Me estoy poniendo en forma rápida. 

Y ahora déjame ir adelante y escriba en David, OK, Zamila, Rob. Aceptar, por lo que esta es una buena cosa. Esta vez, estoy usando una función, una pieza del rompecabezas, llamado get int. Y resulta out-- y vamos a ver esto más adelante en el term-- el personal CS50 ha implementado obtener una cadena de tal manera que lo hará sólo físicamente obtener una cadena para usted. 

Se ha implementado int ponerse en de tal manera que sólo se obtener un número entero para usted. Y si, el ser humano, no cooperan, es literalmente sólo va a reintentar decir, volver a intentar volver a intentar, literalmente sentado en bucle, hasta obligarle con un número mágico, así como 50, 50 y hola. 

O si corremos esto otra vez y el tipo en el 42, 42 hola. Y así, la función get int dentro de esa pieza del rompecabezas es suficiente la lógica, lo suficientemente pensamiento, de averiguar, lo que es una palabra? Y lo que es un número? Sólo aceptando, en última instancia, números. 

Así que resulta que esta No es todo lo que expresiva. hasta aquí. Así, yay, la última vez que fue bastante rápido en los juegos de ejecución, y la animación, y las obras artísticas en cero. Y aquí, estamos siendo contenido con el mundo hola, hola y 50. 

No es todo lo que inspirador. Y, de hecho, estos primeros ejemplos tomará algún tiempo a la rampa encima de la emoción. Pero tenemos mucho más controlar ahora, de hecho. Y vamos a muy iniciar rápidamente la estratificación en la parte superior de estas primitivas básicas. 

Pero primero, vamos a entender cuáles son las limitaciones. De hecho, una de las cosas Cero no hace fácil hagamos que realmente se mira debajo de la campana, y entender lo que es una computadora es, lo que puede hacer, y cuáles son sus limitaciones. Y, de hecho, que la falta de comprensión, potencialmente, a largo plazo puede conducir a nuestra propia escritura mistakes-- insectos, escritura software inseguro que es atacada de alguna manera. 

Así que vamos a dar algunos pasos hacia entender esto un poco mejor por forma de, por ejemplo, el siguiente ejemplo. Voy a seguir adelante y poner en práctica muy rápido un programa llamado Adder. Al igual, vamos a añadir algunos números juntos. Y voy a codificar algunas curvas aquí, y simplemente copiar y pegar donde estaba antes, sólo por lo que podemos conseguir que va antes. Así que ahora tengo los principios básicos de un programa llamado Adder. 

Y vamos a seguir adelante y hacer esto. Voy a seguir adelante y por ejemplo, inTX consigue obtener int. ¿Y sabes qué? Vamos a hacer una mejor experiencia de usuario. 

Así que digamos que x es, y efectivamente pedir al usuario que nos da x. Y luego me dejó ir adelante y decir, printf ¿qué tal que y es, esta vez esperando dos valores del usuario. Y a continuación, vamos a seguir adelante y por ejemplo, printf, la suma de x e y es. Y ahora no quiero hacer s por ciento. Quiero hacerlo por ciento i, la barra invertida n y, a continuación, conecte valor de la suma. 

Entonces, ¿cómo puedo ir haciendo esto? ¿Sabes que? Sé cómo utilizar variables. Me dejaron de declarar una nueva, int z. 

Y voy a tomar una conjetura aquí. Si hay signos iguales en este idioma, tal vez yo puedo hacer x más y, siempre y cuando termino mi pensado con un punto y coma? Ahora puedo volver aquí abajo, conecte z, terminar este pensamiento con un punto y coma. Y vamos a ver ahora, si éstos secuencias de x lines-- es conseguir int. Y es conseguir int. 

Añadir x e y, almacenar el valor en z-- por lo que, de nuevo, recordar el signo igual no es igual. Es tarea de derecha a izquierda. Y vamos a imprimir que la suma de X e Y no es literalmente z, pero lo que hay dentro de z. Así que vamos a hacer Adder - agradable, no hay errores esta vez. Dot slash Adder, entrar, x va a ser 1. 

Y va a ser 2. Y la suma de x e y es 3. Así que eso es todo fino y bueno. 

Por lo tanto es de imaginar que las matemáticas debe trabajar en un programa como este. ¿Pero sabes que? ¿Es esta variable, la línea 12, incluso necesario? No es necesario entrar en el hábito de simplemente almacenar cosas en las variables sólo porque es posible. Y, de hecho, por lo general es mal de diseño considerado si va a crear una variable, llamada z en este caso, el almacenamiento de algo en él, e inmediatamente después usarlo, pero nunca más. ¿Por qué dar un nombre a algo z como si estás literalmente que va a utilizar cosa solamente una vez, y por lo tanto proximal a donde creó en primer lugar, tan cerca en términos de líneas de código? Así que ya saben qué? Resulta que C es bastante flexible. Si yo en realidad quiero plug-in de los valores aquí, No necesito para declarar una nueva variable. Tan sólo pudiera plug-in de x más Y, debido a que C entiende aritmética y operadores matemáticos. 

Por lo que simplemente puedo decir, hacer esto de matemáticas, x más y, lo que esos valores son, conecte el resultante entero en esa cadena. Por lo que este podría ser, aunque sólo una línea más corta, un mejor diseño, un programa mejor, porque hay menos código, por lo tanto, menos para mí entender. Y también es simplemente más limpio, en la medida en que no estamos la introducción de nuevas palabras, nuevos símbolos, como z, a pesar de que en realidad no servirá mucho de un propósito. 

Por desgracia, no es matemáticas todos los que a veces confiables. Vamos a seguir adelante y hacer esto. Voy a seguir adelante ahora y hacer lo siguiente. 

Vamos a hacer printf, i por ciento, más ciento I, se ciento i, n barra invertida. Y yo voy a hacer esto- xyx más y. Así que sólo voy a reescribir esta forma ligeramente diferente aquí. Me dejaron de hacer una comprobación de validez rápida. Una vez más, no vamos a salir adelante de nosotros mismos. Hacer sumador, punto sumador de barra. x es 1, y es 2, 1 más 2 es 3. Y eso es bueno. Pero vamos a complicar esto ahora un poco, y crear un nuevo archivo. 

Voy a llamar a éste, decir, enteros, plural para los enteros. Permítanme comenzar donde estaba hace un momento. Pero ahora vamos a hacer algunas otras líneas. Déjame ir adelante y hacer lo siguiente, printf, i por ciento, menos el porcentaje de i, es ciento i, coma x, yx coma menos y. Así que estoy haciendo un poco diferente matemáticas allí. Vamos a hacer otro. Así por ciento i multiplicada por ciento i es i ciento, la barra invertida n. Vamos a plug-in de x e y, y los tiempos de x y. Vamos a utilizar el asterisco en el equipo de veces. 

No utiliza x. x es un nombre de variable aquí. Se utiliza la estrella para la multiplicación. Vamos a hacer una más. Printf ciento I, dividido por ciento i, i es por ciento, n barra invertida. xy dividido por Y- por lo que utilizar la barra diagonal en C hacer la división. Y vamos a hacer otro. El resto de ciento i, dividido por ciento i, i es ciento. xy-- y ahora resto es lo que queda. Cuando intenta dividir una denominador reduciéndolos a un numerador, ¿Cuánto queda más que no se podía dividir a cabo? 

Así que no hay realmente, necesariamente, un símbolo que hemos utilizado en la escuela primaria para esto. Pero hay en C. Puede decir x módulo y, donde este signo de porcentaje en esta context-- confusamente cuando estás dentro de las comillas dobles, dentro de printf, ciento se utiliza como el especificador de formato. 

Cuando se utiliza por ciento fuera de que, en una expresión matemática, es el operador de módulo para modular arithmetic-- para nuestros propósitos aquí, sólo quiere decir, ¿cuál es la resto de x dividido por y? Así x dividido por y es x barra y. ¿Cuál es el resto de X dividido por Y? Es x y mod, como diría un programador. 

Así que si he cometido ningún error aquí, me dejó seguir adelante y hacer enteros, plural, agradable, y enteros de la raya vertical de puntos. Y vamos a seguir adelante y hacer, digamos, 1, 10. De acuerdo, 1 más 10 es 11, cheque. 1 menos 10 es negativa 9, compruebe. 

1 veces 10 es 10, cheque. 1 dividido por 10 es-- OK, nos saltaremos que uno. El resto de 1 dividido por 10 es 1. Eso es correcto. Pero hay un error aquí. 

Así que el que yo poner mi entregar, no es correcto. Es decir, que está cerca de 0. 1 dividido por 10, ya sabes, si estamos cortar algunas esquinas, seguro, es cero. Pero en realidad debería ser 1/10, 0,1, o 0,10, 0,1000, o así sucesivamente. 

Realmente no debería ser cero. Pues bien, resulta que el equipo está hacer literalmente lo que le dijimos que hiciera. Estamos haciendo matemáticas como x dividido por y. Y ambos X e Y, por las líneas de código anterior, son números enteros. 

Por otra parte, en la línea 15, que somos printf diciendo, hey, printf plug-in un entero, plug-in de un número entero, plug-in de un integer-- específicamente x, y, a continuación y, a continuación, x dividido por y. x e y son enteros. Estamos bien allí. 

Pero lo que se divide por x x? x dividido por y debería ser, matemáticamente, 1/10, ó 0,1, que es un número real, un número real tener, potencialmente, un punto decimal. No es un número entero. 

Pero lo que es el más cercano número entero de 1/10, o 0,1? Sí, es como que es igual a cero. 0,1 es como esto mucho. Y 1 es tanto. Así décima está más cerca de 0 lo que es para uno. 

Y así lo está haciendo por C nosotros-- tipo de porque nos dijeron que a-- se truncando que entero. Se trata de tomar el valor, que es otra vez se supone que es algo así como 0,1000, 0 y así sucesivamente. Y se está truncando todo después del punto decimal de manera que todo esto cosas, porque no lo hace caber en la noción de un número entero, el cual es sólo un número negativo como 1, 0, 1, arriba y abajo, se tira a la basura todo lo después del punto decimal porque No puede caber un punto decimal en un número entero por definición. 

Así que la respuesta es cero. Entonces, ¿cómo podemos solucionar este problema? Necesitamos otra solución todos juntos. Y podemos hacer esto, de la siguiente manera. 

Déjame seguir adelante y crear una nueva archivo, éste llama floats.c. Y guardarlo aquí en el mismo directorio, float.c. Y déjame ir por delante y copiar algunos de que el código de antes. 

Pero en lugar de un int, vamos a hacer esto. Dame un valor de punto flotante llamada x. donde un punto flotante valor es sólo literalmente algo con un punto flotante. Puede moverse hacia la izquierda, a la derecha. Es un número real. 

Y no sea yo llamo obtener int, pero llegar flotador, que también estaba entre el menú de opciones en la biblioteca C250. Vamos a cambiar y a un flotador. Así que esto se convierte en conseguir flotador. 

Y ahora, no queremos que enchufar enteros. Resulta que tenemos que usar ciento f de flotación, f ciento de flotador, y ahora guardarlo. Y ahora, los dedos cruzados, hacen flotadores, agradable, flotadores de la raya vertical de puntos. x va a ser uno 1. y Va a ser 10 otra vez. 

Y, bien, bien mi adición es correcta. Me esperaba más, pero se me olvidó escribirlo. Así que vamos a ir y corregir este error lógico. 

Vamos a seguir adelante y agarrar el siguiente. Sólo tendremos que hacer un poco de copiar y pegar. Y voy a decir menos. 

Y voy a veces decir. Y yo voy a decir dividida. Y yo no voy a hacer de módulo, que no es tan pertinente aquí, divididos por f, y los tiempos plus-- OK, vamos a hacer esto otra vez. 

Hacer flotadores, flotadores de la raya vertical de puntos, y 1, 10, y- agradable, no, OK. Así que soy un idiota. Así que esto es muy común en ciencias de la computación a cometer errores estúpidos como este. 

Para fines pedagógicos, lo que realmente quería hacer fue cambiar la ciencia aquí que además, al menos, a veces, y para separar, ya que es de esperar notado durante este ejercicio. Así que ahora vamos a volver a compilar este programa, hacer flotadores de la raya vertical de puntos. 

Y por tercera vez, vamos a ver si cumple con mis expectativas. 1, 10, entrar, sí, está bien, 1.000, dividido por 10.000, es 0,100000. Y resulta que podemos controlar el número de números son después de esos puntos decimales. En realidad lo hará. Volveremos a eso. 

Pero ahora, de hecho, los cálculos son correctos. Así, de nuevo, ¿cuál es la comida para llevar en esta lista? Resulta que en C, hay no sólo simplemente strings-- y, de hecho, en realidad no hay, porque añadir los de la biblioteca CS50. Pero no son sólo enteros. 

Hay también flota. Y resulta que un montón de otros datos tipos también, que utilizaremos en poco tiempo. Resulta que si quieres una sola carácter, no una cadena de caracteres, puede utilizar simplemente un char. 

Resulta que si quieres un bool, un valor booleano, verdadero o falso solamente, Gracias a la biblioteca CS50, hemos añadido a C el tipo de datos BOOL también. Pero también está presente en muchos otros idiomas también. Y resulta que a veces necesitará un número más grande que vienen por defecto con enteros y flotadores. 

Y, de hecho, un doble es un número que utiliza no 32 bits, pero 64 bits. Y un largo tiempo es un número que no utiliza los bits 32, sino 64 bits, respectivamente, para coma flotante valores y números enteros, respectivamente. Así que vamos a realidad ahora ver esto en acción. 

Voy a seguir adelante aquí y preparar rápidamente otro programa. Aquí, voy a seguir adelante y no incluir CS50.h. Y déjame ir, incluir norma io.h. 

Y se dará cuenta de algo enrrollado está pasando aquí. No es de codificación de color en las cosas de la misma manera como lo hizo antes. Y resulta que, eso es porque no han dado la cosa un nombre de archivo. 

Voy a llamar a éste sizeof.c, y golpeó en Guardar. Y darse cuenta de lo que sucede a mi muy código blanco contra este telón de fondo negro. Ahora, al menos hay algunos púrpura allí. Y es resaltado de sintaxis. 

Eso es porque, simplemente, no tengo dijo el IDE qué tipo de archivo es dándole un nombre, y específicamente una extensión de archivo. Ahora, vamos a seguir adelante y hacer esto. Voy a seguir adelante y muy simplemente imprima el bool following-- es LU ciento. 

Volveremos a que en un momento. Y luego voy a tamaño de impresión de bool. Y ahora, sólo para ahorrar yo algún tiempo, estoy va a hacer en su conjunto manojo de estos a la vez. Y, en concreto, voy a cambiar esto a un char y la carbonilla. Éste, voy a cambiar a un doble y un doble. 

Éste, voy a cambiar a un flotador y un flotador. Éste, voy a cambiar a un int y un int. Y éste, voy para cambiar a un largo tiempo. Y todavía está teniendo un largo tiempo, mucho tiempo. 

Y luego, por último, di yo una copa de más, cadena. Resulta que en C, hay el operador especial llamado tamaño de ese literalmente ir a, cuando se ejecuta, decirnos el tamaño de cada una de estas variables. Y esta es una manera, ahora, podemos conectar de nuevo a la discusión de la semana pasada de los datos y la representación. 

Déjame seguir adelante y compilar tamaño de tamaño de barra de punto de. Y vamos a ver. Resulta que en C, específicamente en CS50 IDE, específicamente en la sistema operativo Ubuntu, que es un operativo de 64 bits sistema en este caso, un bool va a utilizar un byte de espacio. Así es como se mide el tamaño, no en bits, pero en bytes. Y recuerdan que es un byte de ocho bits. Por lo que un bool, a pesar de que técnicamente sólo necesita un 0 o 1, que es un poco derrochador la forma en que hemos implementado. Que en realidad va a usar en su conjunto byte-- lo que todos los ceros, son tal vez todos los queridos, o algo por el estilo, o sólo uno de los ocho bits 1. 

Un char, por su parte, utiliza un carácter como un carácter ASCII a la semana pasada, va a ser un personaje. Y que se sincroniza con nuestra noción de que sea no más de 256 bits-- más bien, sincroniza con ella sin estar más de 8 bits, que nos da un máximo de 256 valores. Un doble va a ser de 8 bytes o 64 bits. 

Un flotador es 4. Un int es 4. Hace mucho, mucho es 8. Y es una cadena de 8. Pero no se preocupe por eso. Vamos a pelar esa capa. Resulta, cuerdas pueden tener más de 8 bytes. 

Y, de hecho, hemos escrito cuerdas ya, hola mundo, más de 8 bytes. Pero vamos a volver a que en un momento. Pero la toma de distancia aquí es la siguiente. 

Cualquier equipo sólo tiene un número finito cantidad de memoria y espacio. Sólo se puede almacenar tantos archivos en su Mac o PC. Sólo se puede almacenar tantos programas en RAM funcionando a la vez, necesariamente, incluso con la memoria virtual, porque usted tiene una cantidad finita de memoria RAM. 

Y sólo para picture-- si usted nunca ha abierto una computadora portátil u ordenado memoria extra para un ordenador, podría no saber que en el interior de su ordenador es algo que se ve un poco como esto. Así que esto es sólo una empresa común llamada Crucial que hace RAM para ordenadores. Y la memoria RAM es donde los programas vivir mientras se están ejecutando. 

Así que en todos los Mac o PC, cuando se hace doble haga clic en un programa, y ​​esto se abre, y se abre un poco de documento de Word o algo así, lo almacena temporalmente en RAM, memoria RAM ya que es más rápido de su disco duro, o el disco de estado sólido. Por lo que es justo donde van los programas para vivir cuando se están ejecutando, o cuando se utilizan archivos. 

Por lo que tiene cosas que se ven así por dentro de su computadora portátil, o cosas un poco más grande dentro de su escritorio. Pero la clave es que sólo tiene una número finito de estas cosas. Y sólo hay una cantidad finita de hardware sentado en esta mesa de la derecha aquí. 

Así que, sin duda, no podemos almacenar números infinitamente largo. Y, sin embargo, si usted piensa de nuevo a la escuela primaria, el número de dígitos puede usted tiene la derecha de un punto decimal? Por lo demás, el número de dígitos puede usted tiene a la izquierda de la coma decimal? En realidad, infinitamente muchos. 

Ahora, nosotros, los seres humanos sólo podría saber cómo se pronuncia millones, y miles de millones, billones de dólares, y cuatrillón, y trillones. Y estoy empujando los límites de mi understanding-- o mi-- entiendo números, pero mi Pronunciación de los números. Pero se puede conseguir con infinitamente grande un número infinito de dígitos a la izquierda o a la derecha de la coma decimal. 

Pero los ordenadores sólo tienen una cantidad finita de memoria, un número finito de transistores, una número finito de bombillas de luz en el interior. Entonces, ¿qué sucede cuando se le acaba el espacio? En otras palabras, si pensar de nuevo a la semana pasada cuando hablamos de números que ellas mismas sean representados en binario, Supongamos que tenemos este valor de 8 bits aquí. 

Y tenemos siete de 1 y un 0. Y supongamos que queremos añadir 1 a este valor. Este es un número muy grande en este momento. 

Esto es 254, si no recuerdo los cálculos de la última semana de la derecha. Pero lo que si cambio que más a la derecha 0 a un 1? El número total de Por supuesto, se convierte en ocho 1 de. Así que estamos siendo buena. 

Y que probablemente representa 255, aunque dependiendo del contexto que en realidad podría representar un número negativo. Pero más de eso en otro momento. Esto se siente como se trata de tan alto como puedo contar. 

Ahora, es sólo 8 bits. Y mi Mac, sin duda, tiene forma más de 8 bits de la memoria. Pero tiene finita. Así mismo argumento se aplica, incluso si tener más de estos que están en la pantalla. 

¿Pero qué sucede si estás almacenar este número, 255, y que desea contar 1 poco más alto? ¿Quieres ir de 255 a la tecnología 256. El problema, por supuesto, es que si se comenzará a contar desde cero como la semana pasada, no se puede contar tan alto como 256, 257 y mucho menos, por no hablar de 258, m porque lo que sucede cuando se agrega un 1? Si lo hace la vieja escuela de grado enfoque, se pone un 1 aquí, y luego 1 más 1 es 2, pero eso es Realmente un cero, que llevan el 1, llevar a la 1, llevar a la 1. Todas estas cosas, estos de 1, van a cero. Y que terminan, sí, como alguien señalado, un 1 en el lado izquierdo. Pero todo lo que pueda en realidad ver y caber en la memoria es tan sólo ocho de 0, lo que quiere decir en algún momento si, una computadora, intentado contar lo suficientemente alto, eres va a envolver alrededor, al parecer, a cero, o tal vez incluso negativo números, que son incluso inferiores a cero. 

Y podemos especie de ver esto. Déjame seguir adelante y escribir un verdadero programa rápido aquí. Déjame seguir adelante y escribir un programa llamado desbordamiento. Incluir CS50.h, incluya estándar IO.h-- oh, Realmente extrañaba a mi resaltado de sintaxis. Así que vamos a guardar esto como overflow.c. 

Y ahora int void-- principal y en poco tiempo, vamos a volver a explicar por qué seguimos escribiendo int void main. Pero por ahora, vamos a hacer que, dando por sentado. Vamos a dar a mí mismo un int, e inicializar a 0. 

Vamos a hacer a continuación para int i obtener zero-- En realidad, vamos a hacer un bucle infinito y ver qué pasa. Aunque es verdad, entonces vamos a imprimir a cabo n Es por ciento i, la barra invertida n, plug-n. Pero, ahora, vamos a hacer que n se hace n + 1. 

Así, en otras palabras, en cada iteración de este bucle infinito, tomemos el valor de n, y se añade 1 a la misma, y ​​luego almacenar el resultado de nuevo n de la izquierda. Y, de hecho, hemos visto la sintaxis un poco como esto, brevemente. Un buen truco es en cambio de escribir todo esto a cabo, en realidad se puede decir que una más n es igual a 1. 

O si realmente quiere ser de lujo, se puede decir n plus plus punto y coma. Pero estos dos últimos son simplemente lo que nosotros llamamos el azúcar sintáctica para la primera cosa. 

Lo primero es más explícito, totalmente bien, todo correcto. Pero esto es más común, que voy a decir. Así que vamos a hacer esto por un momento. 

Ahora vamos a hacer desbordamiento, que suena en lugar de mal agüero, desbordamiento barra de puntos. Vamos a ver, n está haciendo muy grande. Pero pensemos, lo grande que n puede conseguir? 

n es un entero. Vimos hace un momento con el tamaño de ejemplo, que un int es de cuatro bytes. Sabemos de la semana pasada, cuatro bytes es 32 bits, ya que 8 veces 4, eso es 32. Eso va a ser de 4 millones de dólares. 

Y estamos hasta 800.000. Esto va a tener siempre a contar tan alto como sea posible. Así que voy a seguir adelante, como puede ser que después de poco tiempo, y pulsa Control de C-- francamente, Control C, mucho, donde el control general C medios cancelan. Desafortunadamente, debido a esta se está ejecutando en la nube, A veces la nube es escupiendo tantas cosas, tanto la producción, que va a tomar un poco de tiempo para mi entrada para llegar a la nube. Así que, aunque me golpeó Control C Hace unos pocos segundos, este es sin duda el lado efecto de un bucle infinito. 

Y así, en estos casos, estamos va a dejar que sea. Y vamos a añadir otro ventana de terminal por aquí con los polos positivo, que por supuesto no lo hace de esa manera, ya que todavía está pensando. Y vamos a seguir adelante y estar un poco más razonable. 

Voy a seguir adelante y hacerlo Esto sólo un número finito de veces. Vamos a utilizar un bucle for, lo que he aludido antes. Hagámoslo. Dame otra variable int i consigue 0. i es menor que, digamos, 64 i ++. Y ahora permítanme imprimámoslas n es a cabo por ciento i, la coma n. Y a continuación, esto sigue siendo n- va a tomar para siempre. Hagámoslo. 

n se hace n veces 2. O podríamos ser de lujo y hacer tiempos es igual a 2. Pero digamos que n es igual a sí mismo, los tiempos 2. En otras palabras, en este nueva versión del programa, No quiero esperar por siempre como de 800.000 a 4 millones de dólares. Vamos a acabar con esto. 

Vamos a duplicar en realidad n cada vez. El cual, el recuerdo, la duplicación es el opuesta de tener, por supuesto. Y mientras que la semana pasada tenemos algo nuevo, y de nuevo, y de nuevo, súper rápido, duplicación seguramente lo harán sacarnos de 1 a la mayor posible valor que podemos contar hasta con un int. 

Así que vamos a hacer exactamente esto. Y vamos a volver a este después de poco tiempo. Pero esto, de nuevo, es igual el bloque de repetición en Scratch. Y vamos a usar esto en poco tiempo. 

Esto sólo significa recuento de cero hasta, pero no igual, a 64. Y en cada iteración de esta lazo, mantendría incrementando i. Así i ++ - y esta construcción en general en la línea 7 es sólo una manera súper común de repetir algunas líneas de código, cierto número de veces. ¿Qué líneas de código? Estas llaves, como se pueden haber recogido a partir de ahora, significa, haga lo siguiente. 

Es como en Scratch, cuando que tiene los bloques amarillos y otros colores que tipo de abrazar o abrazar a otros bloques. Eso es lo que esos rizado aparatos ortopédicos están haciendo aquí. Así que si me dieron mi sintaxis que derecha- puede ver el símbolo de zanahoria en el medio C que es la cantidad de veces que he estado tratar de resolver este problema. Así que vamos a deshacernos de que uno en total, y cerrar esa ventana. Y vamos a utilizar la nueva. Hacer desbordamiento, barra de puntos desbordamiento, Enter, todos los derechos, se ve mal al principio. Pero vamos a retroceder en el tiempo, porque me hizo esto 64 veces. 

Y observe la primera vez, n es 1. La segunda vez, n es 2, luego 4, luego 8, luego 16. Y parece que en cuanto Llego a más o menos 1 mil millones, si hago doble de nuevo, que debe dame 2 mil millones. Pero resulta, que es justo en la cúspide. 

Y lo que en realidad se desborda un entero de 1 mil millones a más o menos 2 negativo millones de dólares, debido a un número entero, a diferencia de la que números fueron asumiendo la semana pasada, puede ser tanto positiva como negativa en la realidad y en un ordenador. Y así, al menos, uno de los los bits son robados eficacia. Así que realmente sólo tenemos 31 bits, o 2 mil millones de valores posibles. 

Pero por ahora, la comida para llevar es bastante simplemente, sean cuales sean estos números son y cualquiera que sea la matemática es, que sucede algo malo con el tiempo, porque con el tiempo que está intentando permutar los bits demasiadas veces. Y vas efectiva de todo de 1 a 0 tal vez todos de, o tal vez simplemente algún otro patrón que claramente, dependiendo del contexto, puede ser interpretado como un número negativo. Y por lo que parece el más alto que puede contar en este programa concreto es sólo aproximadamente 1 mil millones. Pero hay una solución parcial aquí. ¿Sabes que? 

Déjame cambiar de una Int a un largo tiempo. Y déjame ir por delante aquí y decir-- Voy a tener para cambiar esto a un largo sin signo. O bien, vamos a ver, nunca me acuerdo de mí. 

Vamos a seguir adelante y crea desbordamiento. No, no es eso, LLD, gracias. Así que a veces puede ser útil Clang. No recuerdo lo que el formato especificador fue durante mucho tiempo. 

Pero, de hecho, Clang me dijo. El verde es un tipo de bien, todavía significa que cometió un error. Se adivinando que quería decir LLD. 

Por eso quiero aprovechar es un consejo, una larga número decimal de longitud, salvo que. Y permítanme volver a ejecutarlo, dot reducir desbordamiento, Intro. Y ahora lo que es fresco es esto. 

Si me desplazo hacia atrás en el tiempo, todavía empezamos contando al mismo lugar-- 1, 2, 4, 8, 16. Aviso, obtenemos toda la hasta llegar a 1 mil millones. Pero entonces con seguridad llegar a 2 mil millones. 

Entonces conseguimos a 4 millones de dólares, a continuación, 8 mil millones, 17 mil millones. Y vamos más alto, y alto y más alto. Con el tiempo, esto también se rompe. 

Finalmente, con un largo tiempo, que es el valor de 64 bits, no un valor de 32 bits, si se cuenta demasiado alto, que se coloca alrededor de 0. Y en este caso, nos ha tocado terminar con un número negativo. 

Así que este es un problema. Y resulta que este problema no es tan arcano. Aunque he deliberadamente inducida con estos errores, Resulta que lo vemos todo tipo de nosotros, o al menos algunos de nosotros alrededor de hacerlo. 

Así que en Lego Star Wars, si ¿Alguna vez has jugado el juego, Resulta que se puede dar la vuelta romper las cosas en el mundo de LEGO, y la recogida de monedas, esencialmente. Y si has jugado alguna vez este juego demasiado tiempo, ya que este individuo no identificado aquí lo hizo, el número total de monedas que se pueden recoger es, al parecer, 4 mil millones. 

Ahora, con él es en realidad redondeado. Así que estaba tratando de LEGO mantener las cosas fácil de usar. Ellos no lo hicieron exactamente a 2 el 32 de potencia, a la semana pasada. Pero 4 mil millones es una razón. Parece, a partir de esta información, que LEGO, y la empresa que hecho este software real, decidió que el número máximo de monedas el usuario puede acumular es, de hecho, 4 mil millones, porque eligieron en su código utilizar no mucho tiempo, al parecer, pero sólo un número entero, sin signo número entero, solamente un número entero positivo, cuyo valor máximo más o menos es eso. Bueno, aquí hay otro divertido. Así que en el juego de la civilización, la cual algunos de ustedes podrían estar familiarizados con resulta que hace años se Fue un error en este juego mediante el cual si has jugado el papel de Gandhi en el juego, en vez de estar muy pacifista, en cambio, fue muy, muy agresivo, en algunas circunstancias. En particular, la forma en que la civilización obras es que si usted, el jugador, adoptar la democracia, su El marcador se pone la agresividad decrementa en dos, por lo menos menos, y luego minus. 

Por lo que resta 2 su iteración actual. Desafortunadamente, si su iteración es inicialmente 1, 2 y restar de ella después de adoptar la democracia como Gandhi aquí podría lo han hecho, porque era muy passive-- 1 en la escala de agresividad. Pero si se adopta la democracia, a continuación, que va de 1 a 1 negativo. 

Desafortunadamente, eran el uso de números sin signo, lo que significa que tratan incluso negativo números como si fueran positivos. Y resulta que la equivalente positivo de 1 negativo, en programas informáticos típicos, es 255. Así que si Gandhi adopta la democracia tiene, y por lo tanto su puntuación se redujo la agresividad, que en realidad alrededor de los rollos a 255 y lo hace más carácter agresivo en el juego. Por lo que puede buscar en Google en esto. Y fue, de hecho, una error de programación accidental, pero eso ha entrado bastante la tradición desde entonces. 

Eso es todo diversión y lindo. Más alarmante es cuando se real dispositivos del mundo real, y no los juegos, tener estos mismos errores. De hecho, hace apenas un año un artículo vino cabo sobre el Boeing 787 Dreamliner. 

Y el artículo en un primer momento mirada lee un poco arcano. Pero dicho esto, un software vulnerabilidad en Boeing nuevo 787 Dreamliner jet tiene el potencial para causar pilotos perder el control de la aeronave, posiblemente en pleno vuelo, los funcionarios de la FAA Las aerolíneas advirtió recientemente. Era la determinación que un modelo 787 avión que ha sido alimentado de forma continua durante 248 días pueden perder totalmente la corriente alterna, CA, energía eléctrica debido al generador unidades de control, GCU, a la vez entrar en modo de seguridad de. Es una especie de perderme. Sin embargo, la nota se señalaba, OK, ahora tengo que, la condición fue causada por un software contador interno de el control del generador unidades que se desbordará después 248 días de potencia continua. Estamos emitiendo este AVISO Para evitar la pérdida de de todos AC eléctrico poder, lo que podría resultar la pérdida de control del avión. 

Así que, literalmente, hay un cierto número entero, o un cierto tipo de datos equivalente, siendo utilizado en software en un avión real que si mantiene su avión el tiempo suficiente, que al parecer puede ser el caso si sólo está ejecutando ellos constantemente y nunca desconectar su avión, al parecer, o dejando que sus baterías se agoten, con el tiempo se cuenta ascendente, y hasta, y arriba, y arriba y arriba, y hacia arriba. 

Y, por naturaleza, una cantidad finita de memoria se desbordará, rodando de nuevo a cero o un valor negativo, un efecto secundario de que es el la realidad terriblemente reales que el avión podría necesitar ser reiniciado, efectivamente, o podría caer, peor aún, a medida que vuela. Por lo que este tipo de problemas siguen con nosotros, even-- este era un artículo de 2015, aún más alarmante cuando no lo hace necesariamente entender, apreciar, o anticipar ese tipo de errores. 

Por lo tanto, resulta que hay otro Lo malo de representación de datos. Resulta que incluso flotadores son tipo de fallas, debido a los flotadores, también, Propuse son de 32 bits, o quizá 64 si se utiliza un doble. Pero eso es finito. 

Y el problema es que si se puede poner un número infinito de números después del punto decimal, no hay manera de que puede representar todo lo posible números que nos enseñaron en el grado de la escuela puede existir en el mundo. Un equipo que, en esencia, tiene que elegir un subconjunto de esos números para representar con precisión. 

Ahora, el equipo puede ronda tal vez un poco, y le puede permitir a aproximadamente el almacén cualquier número que posiblemente podría desear. Pero sólo intuitivamente, si tener un número finito de bits, sólo se puede permutar ellas de muchas maneras finitos. Por lo que no puede posiblemente utilizar un número finito de permutación de bits, patrones de ceros y unos, para representar un infinito número de números, lo que sugiere que los ordenadores podrían muy bien ser mintiendo a nosotros a veces. 

De hecho, vamos a hacer esto. Déjame volver al IDE CS50. Déjame ir adelante y crear un pequeño programa La imprecisión llamada, para mostrar que las computadoras son, de hecho, imprecisa. 

Y déjame seguir adelante y comenzar con algunos de que el código de antes, y ahora acaba de hacer lo siguiente. Déjame seguir adelante y hacer printf, ciento f, la barra invertida n, 1 dividido por 10. En otras palabras, vamos a bucear en la más profunda a 1/10, al igual que 1 y dividido por 10. Sin duda, una computadora puede representar 1/10. 

Así que vamos a seguir adelante y hacer imprecisión. Veamos. Formato especifica el tipo doble. Sin embargo, el argumento tiene tipo int. ¿Que esta pasando? 

Oh, interesante, así que es una lección aprendida de antes. Yo digo, bueno, feria de informática un flotador con ciento f. Pero lo estoy dando 2 enteros. Así que resulta, puedo arreglar esto en un par de maneras. 

Tan sólo pudiera convertir en un 1,0, y 10 a 10,0, lo que, de hecho, tener el efecto de convertir ellos en floats-- todavía con suerte el mismo numero. O resulta que hay algo veremos de nuevo en poco tiempo. Se podría emitir los números. 

Puede, el uso de este paréntesis expresión, se puede decir, Hey, ordenador, toma esto 10, que sé que es un int. Pero tratarla, por favor, como si fuera un flotador. Pero esto se siente innecesariamente compleja. 

Para nuestros propósitos hoy, sólo vamos a literalmente los hacen valores de punto flotante con un punto decimal, como este. Déjame ir adelante y vuelva a ejecutar, hacer imprecisión, bueno, barra de puntos imprecisión, introduzca. OK, estamos en buen estado. 

1 dividido por 10, de acuerdo a mi Mac aquí, es, de hecho, 0,100000. Ahora, me enseñaron en la escuela primaria allí debe ser un número infinito de 0 de. Así que vamos a tratar, al menos, para ver algunos de ellos. Resulta que es un poco printf aún más elegante que hemos estado utilizando. Resulta que usted no tiene que especificar f justo por ciento, o simplemente por ciento i. En realidad se puede especificar algunas opciones de control aquí. 

En concreto, voy decir, hey, printf, En realidad me muestran 10 puntos decimales. Así que parece un poco raro. Pero usted dice por ciento, punto, la cantidad de números desea ver después de la punto decimal y, a continuación, f para plana, simplemente porque eso es lo que dice la documentación. Déjame ir por delante y salvamento de dicha. 

Y noto también, que estoy recibiendo cansado de volver a escribir las cosas. Así que estoy estableciendo el y flecha inferior de mis llaves aquí. Y si sigo golpeando para arriba, usted puede ver todos los comandos que hice, o mal hecho. 

Y voy a seguir adelante y ahora en realidad no utilizar que, al parecer. Hacer imprecisión, punto reducir de manera imprecision-- lo que me enseñaron en la escuela primaria comprueba hacia fuera. Incluso si lo imprimo a 10 decimales lo sitúa, de hecho, es 0.10000. ¿Pero sabes que? 

Vamos a conseguir un poco codicioso. Digamos que, al igual que, muéstrame 55 puntos después del punto decimal. Vamos a tomar esto programar a dar una vuelta. Permítanme rehacerla con maquillaje imprecisión, raya vertical del punto, la imprecisión. 

Y aquí vamos. Su infancia fue una mentira. Al parecer, 1 dividido por 10 es de hecho 0.100000000000000005551115123-- 

¿Qué está pasando? Pues bien, resulta que, si la clase de mirar lo suficientemente lejos en el subyacente representación de este número, que en realidad no es exactamente 1/10, o el 0,1 y el un número infinito de ceros. Ahora, ¿por qué? 

Pues bien, a pesar de que esto es un simple número a nosotros los seres humanos, 1 dividido por 10, aún así es uno de un número infinito números que podrían imaginar. Sin embargo, un equipo sólo puede representar un número finito de números menos. Y así, efectivamente, lo que la equipo está mostrando nosotros es su punto más cercano aproximación al número queremos creer es 1/10, o realmente 0.10000 ad infinitum. 

Más bien, sin embargo, esto es tan cerca como se puede conseguir. Y, de hecho, si nos fijamos debajo de la campana, ya que estamos aquí examinado 55 dígitos después del punto decimal, que en realidad vemos que la realidad. Ahora como un aparte, si no tienes Alguna vez has visto la movie-- la mayoría de ustedes probablemente haven't-- pero hace algunos años Superman 3, Richard Pryor apalancado fundamentalmente este la realidad en su compañía para robar una gran cantidad de fracciones y fracciones de centavos, porque el company-- por lo que recuerdo, que ha sido un rato-- era esencialmente tirar cualquier cosa que no encajaba en la noción de centavos. 

Pero si se suman todos estos diminutos, diminutos, diminutos números de nuevo, y otra vez, y otra vez, se puede, como en su caso, hacer una buena cantidad de dinero. 

Esa misma idea fue arrancada por una más reciente, pero aún ahora mayores película, llamado espacio de oficina, donde los chicos de esa película, hizo lo mismo, metido la pata por completo, terminado con demasiada dinero en su cuenta bancaria. Todo era muy sospechoso. Pero al final del día, imprecisión es todo lo que nos rodea. 

Y que, también, puede haber Es alarmante el caso. Resulta que Superman 3 y espacio de oficina a un lado, hay pueden ser algunas muy real ramificaciones mundiales de las realidades de la imprecisa representación de datos que incluso los seres humanos a el día de hoy no necesariamente entender, así como deberíamos, o recordar tan a menudo como deberíamos. Y, de hecho, el siguiente clip es a partir de una mirada a un mundo muy real ramificaciones de lo que sucede si no aprecian que la imprecisión puede suceder en representación de números. 

[REPRODUCCIÓN DE VÍDEO] 

-Informática, Todos hemos llegado a aceptar los problemas a menudo frustrantes que ir con ellos-- insectos, virus, y fallas en el software, para los precios de pequeño a pagar por la comodidad. Pero en la alta tecnología y de alta velocidad aplicaciones de programas espaciales militares y, el más pequeño problema puede magnificarse en el desastre. 

El 4 de junio de 1996, los científicos prepararon para lanzar un cohete no tripulado Ariane 5. Llevaba científica satélites diseñados establecer con precisión cómo el interactúa campo magnético de la Tierra con vientos solares. El cohete fue construido para la Agencia Espacial Europea, y despegó de sus instalaciones en la costa de la Guayana francesa. 

-En Unos 37 segundos en el vuelo, primero dado cuenta de que algo iba mal. Las boquillas se gira sobre un eje en de manera que en realidad no debería. Alrededor de 40 segundos de vuelo, claramente, el vehículo estaba en problemas. 

Y eso es cuando hicieron una decisión de destruirlo. El oficial de seguridad de gama, con tremendas agallas, pulsa el botón, explotó el cohete, antes de que pudiera convertirse en un peligro para la seguridad pública. 

-Esta Era la doncella viaje del Ariane 5. Y su destrucción se llevó lugar debido a un defecto incrustado en el software del cohete. -El Problema fue en el Ariane que había un número que requiere 64 bits para expresar. Y querían convertir a un número de 16 bits. Se supone que la número nunca se va a ser muy grande, que la mayoría de las dígitos en un número de 64 bits eran ceros. Ellos estaban equivocados. 

-La Incapacidad de una programa de software para aceptar el tipo de número generado por otra fue la causa de la falla. El desarrollo de software se había convertido en una parte muy costosa de las nuevas tecnologías. El cohete Ariane han sido muy éxito, por lo que gran parte del software creado para ella también era utilizado en el Ariane 5. 

-El Problema básico era que el Ariane 5 fue más rápida, se aceleró más rápidamente. Y el software no tenía representaron para eso. 

-La Destrucción del cohete Fue un gran desastre financiero, todo se debe a un error de software minuto. Pero esta no fue la primera problemas de conversión de datos de tiempo había plagado la tecnología de cohetes moderna. 

-En 1991, con el inicio de la primera Guerra del Golfo, el misil de patriota experimentado una clase similar del problema de la conversión número. Y como resultado, 28 personas, 28 soldados estadounidenses, fueron asesinados, y sobre otros 100 heridos, cuando el patriota, que se suponía para proteger contra scuds entrantes, dejado de disparar un misil. 

-Cuando Irak invadió Kuwait, y América Tormenta del Desierto lanzado a principios de 1991, baterías de misiles Patriot fueron desplegados para proteger a Arabia Saudita e Israel de los ataques de misiles Scud iraquíes. El Patriot es un medio de rango de EE.UU. superficie para sistema de aire, fabricado por la empresa Raytheon. 

-El Tamaño de los interceptores Patriot sí está a más o menos 20 pies de largo. Y pesa alrededor de 2.000 libras. Y lleva una ojiva de alrededor, Creo que es más o menos 150 libras. Y la cabeza de combate en sí es un explosivo de alta potencia, que tiene fragmentos alrededor de ella. La carcasa de la cabeza de combate es diseñado para actuar como perdigones. 

-Los Misiles se llevan cuatro por contenedor, y son transportados por un semi-remolque. 

-El Sistema Patriot antimisiles se remonta por lo menos 20 años. Fue diseñado originalmente como un misil de defensa aérea para derribar aviones enemigos. En la primera guerra del Golfo, cuando la guerra llegó, el Ejército quería utilizarlo para derribar scuds, no aeroplanos. 

La Fuerza Aérea Iraquí fue no tanto de un problema. Pero el ejército estaba preocupado por scuds. Y por lo que trataron de actualizar el Patriot. 

-Intercepting Un enemigo misil que viaja a Mach 5 que iba a ser un reto suficiente. Pero cuando el Patriot fue trasladado de urgencia en servicio, el Ejército no estaba al tanto de una modificación iraquí que hizo sus scuds casi imposible de golpear. 

-Lo Que pasa es que los scuds llegaban eran inestables. Fueron desplazamiento. La razón de esto era los iraquíes, con el fin para llegar a 600 kilómetros fuera de un 300 kilometros alcance de los misiles, tomó el peso fuera de la ojiva delantera. Hicieron la ojiva más ligero. 

Así que ahora el Patriot es tratando de llegar a la Scud. Y la mayoría de las veces, la inmensa mayoría de las veces, sería simplemente salir volando por el Scud. Una vez que los operadores del sistema Patriot se dio cuenta de la Patriot no alcanzó su objetivo, detonar la ojiva del Patriota para evitar posibles bajas si se dejó caer al suelo. 

Eso fue lo que vieron la mayoría de la gente, esas grandes bolas de fuego en el cielo, y malinterpretado como intercepciones de ojivas Scud. 

-Aunque En la noche cielos, patriotas apareció ser con éxito la destrucción de misiles Scud, en Dhahran, no podía haber error sobre su rendimiento. Allí, sistema de radar de la Patriot perdido la pista de un Scud entrante, y nunca puesto en marcha debido a un defecto de software. Fueron los israelíes que se descubrió por primera vez que cuanto más tiempo el sistema estaba en marcha, cuanto mayor es la discrepancia de tiempo se convirtió, debido a un reloj incorporado en el ordenador del sistema. 

-Acerca De dos semanas antes la tragedia en Dhahran, los israelíes informaron de el Departamento de Defensa que el sistema estaba perdiendo el tiempo. Después de cerca de ocho horas o en ejecución, se dieron cuenta de que el sistema de fue que se vea con menos precisa. El Departamento de Defensa respondió diciendo a todas las baterías Patriot para no dejar los sistemas durante mucho tiempo. Nunca dijeron lo mucho tiempo era-- ocho horas, 10 horas, 1.000 horas. Nadie sabía. 

-La Batería Patriot estacionados en los cuarteles en Dhahran y su deficiente interna reloj había estado en más de 100 horas en la noche del 25 de febrero. 

-Es Seguido de tiempo con una precisión de alrededor de un décimo de un segundo. Ahora, un décimo de un segundo es un número interesante, debido a que no se puede expresar en binario exactamente, que significa que no se puede expresar exactamente en cualquier computadora digital moderna. Es difícil de creer. 

Pero utilizar esto como un ejemplo. Tomemos el número de un tercio. Una tercera no puede ser expresado en decimal exactamente. Una tercera parte es 0,333 pasando por el infinito. 

No hay manera de hacer eso con la precisión absoluta en decimal. Ese es exactamente el tipo de problema Eso ocurrió en el Patriot. Cuanto más largo sea el sistema funcionó, la se convirtió en el peor error de tiempo. 

-Después De 100 horas de funcionamiento, el de error en el tiempo era sólo alrededor de un tercio de un segundo. Pero en términos de focalización una misil que viaja a Mach 5, que dio lugar a un seguimiento de error de más de 600 metros. Sería un error grave para los soldados en lo se pasó una lancha era Scud detectado por los satélites de alerta temprana y sabían que era el Scud viniendo en su dirección general. Ellos no sabían de dónde venía. 

-Fue Hasta ahora el radar componente del sistema Patriot la defensa de Dhahran para localizar y mantener pista del misil enemigo entrante. 

-El Radar era muy inteligente. Sería realmente un seguimiento la posición del Scud, y luego predecir donde probablemente sería la próxima vez que el radar envió Un pulso a cabo. Que se llamó una puerta de distancia. 

-Entonces, Una vez que el Patriot decide el tiempo suficiente tiene pasó a volver atrás y comprobar la siguiente ubicación para este objeto detectado, que se remonta. Así que cuando se volvió al mal lugar, a continuación, no ve ningún objeto. Y decide que no había objeto, que era una falsa detección, y deja caer la pista. 

-La Entrante Scud desapareció desde la pantalla de radar. Y segundos más tarde, chocó contra el cuartel. El Scud mató a 28, y fue el último uno disparadas durante la primera Guerra del Golfo. 

Trágicamente, el software actualizado llegado a Dhahran el día siguiente. La falla de software tenía sido fijado, el cierre un capítulo en el problemático la historia del misil Patriot. 

[REPRODUCCIÓN DE VÍDEO] DAVID J. MALAN: Así que esto es todo lo que decir que estos problemas de desbordamiento e imprecisión son demasiado reales. Entonces ... ¿cómo fue que llegamos aquí? Comenzamos con sólo hablar de printf. Una vez más, esta función que imprime algo a la pantalla, y se introdujo a partir de entonces algunas otras funciones de la llamada biblioteca de CS50. Y vamos a seguir ver éstos a su debido tiempo. Y nosotros, en particular, utilizamos cadena GET, y obtener int, y ahora también obtener flotador, y sin embargo, otros todavía nos encontramos con y el uso de nosotros mismos antes de tiempo. 

Sin embargo, en ocasiones, tienen ya visto una necesidad para almacenar lo que esas funciones mano hacia atrás? Nos volver una secuencia de la mano, o un int o un flotador. Y a veces tenemos que poner eso cadena, o int o float, en alguna parte. 

Y para almacenar esas cosas, recuperar únicamente al igual que en Scratch, tenemos variables. Pero a diferencia de los arañazos, en C tenemos tipos reales de los datos variables-- tipos, más generally-- entre ellos, una cadena, un entero, una flotar, y estos otros aún. 

Y así, cuando declaramos las variables en C, tendremos que declarar los tipos de datos. Esto no es algo que vamos a tener que hacer más adelante en el semestre a medida que pasamos a otros idiomas. Pero por ahora, necesitamos a a priori por adelantado, explicar a la computadora qué tipo de de la variable que queremos que nos dan. 

Ahora, mientras tanto, para imprimir esos tipos de tipos de datos, tenemos que decirle a printf qué esperar. Y vimos ciento s para cuerdas, y el porcentaje de i para enteros, y algunos otros ya. Y esos son sólo los requisitos para la presentación visual de esa información. 

Y cada uno de estos puede ser realidad parametrizada o ajustado de alguna manera, si desea avanzar en el control el tipo de salida que se obtiene. Y, de hecho, resulta que no sólo ¿hay barra invertida n para una nueva línea. Hay otra cosa llamada barra invertida r para un retorno de carro, el cual se parece más a una máquina de escribir vieja escuela, y también de Windows utiliza para muchos años. 

Hay t barra invertida para las pestañas. Resulta, que si se quiere comillas dobles dentro de una cadena, Recordemos que hemos utilizado doble comillas dobles cotización de la izquierda y la derecha termina de nuestras cuerdas hasta el momento. Esto parece confundir las cosas. 

Si usted quiere poner una doble cita en el medio de un string-- y, de hecho, es confuso para ver. Y lo que tiene que escapar, por lo que hablar, una doble cita con algo al igual que, literalmente, la barra invertida comillas dobles. Y hay algunos otros todavía. Y veremos más de esos en el uso real en poco tiempo. 

Así que ahora transición de de datos, y la representación, y operadores aritméticos, todo de lo que nos dio algún edificio bloques con las cuales jugar. Pero ahora vamos a dar realidad nosotros el resto del vocabulario que ya teníamos la semana pasada con los arañazos por echar un vistazo en algún otro construcciones en C-- no todos ellos. Pero las ideas que están punto de ver realmente sólo hacer hincapié en la traducción de un idioma, Scratch, a otro, C. 

Y con el tiempo, vamos a recoger más herramientas para nuestra caja de herramientas, por así decirlo, sintácticamente. Y, de hecho, se verá que las ideas ahora son bastante familiar de la semana pasada. Así que vamos a hacer esto. 

Vamos a seguir adelante y preparar rápidamente un programa que realmente utiliza algunas expresiones, una expresión booleana. Déjame ir por delante aquí y crear un nuevo archivo. Voy a llamar a este condition.c. 

Déjame ir adelante y incluir la biblioteca CS50. Y me dejó ir adelante y incluyo io.h estándar para nuestras funciones, y printf, y mucho más, respectivamente. Permítanme que me entrego repetitivo de int vacío principal, cuya explicación vamos a volver en el futuro. 

Ahora voy a seguir adelante y dar a mí mismo a través de un int int get. Entonces déjame seguir adelante y hacer esto. Quiero decir, si i es less-- de dejar distinguir entre positivo y negativo, o valores cero. 

Así que si i es menor que cero, me dejó Sólo tiene este programa simplemente decir, negativo, barra invertida n, de lo Si i es mayor que cero. Ahora estoy, por supuesto, va a decir printf positivo, la barra invertida n. Y luego otra cosa si: Yo podría hacer esto. 

Yo podría hacer si i es igual a 0. Pero estaría haciendo en menos un error ya. Recordemos que el signo igual es no es igual, ya que los seres humanos lo saben. 

Pero es el operador de asignación. Y nosotros no queremos tener 0 en el la derecha y la puso en i de la izquierda. Así que para evitar esta confusión, o quizá el mal uso del signo igual, los seres humanos decidieron hace algunos años que en muchos lenguajes de programación cuando se quiere comprobar la igualdad entre la izquierda y la derecha, en realidad se utiliza es igual a los iguales. De manera que pegarle el signo igual dos veces. Cuando se desea asignar de derecha a la izquierda, se utiliza un solo signo igual. Por lo que podíamos hacer otra cosa esto- Si i es igual a igual a cero. 

Entonces podría ir y abrir mis llaves, y decir, printf 0, la barra invertida n, hecho. Pero recuerda cómo estos bifurcaciones en el camino pueden trabajar. Y, en realidad, sólo pensar en la lógica. i es un número. Es un número entero, específicamente. Y eso significa que va a ser menos de 0, o mayor que 0, o 0. Así que hay una especie de este caso por defecto implícito. 

Y así podríamos, al igual Cero, prescindir de la persona si, y decir otra cosa. Lógicamente, si el programador sabe que sólo hay tres cubos en los que una escenario puede fall-- la primera, la segunda, o la tercera en este caso-- no hacer molestar a la adición de la precisión adicional y la lógica adicional allí. Sólo seguir adelante con el caso por defecto aquí de otra cosa. 

Ahora, vamos a seguir adelante después de salvar esto, hacer condiciones salpican reducir conditions-- no una gran interfaz de usuario, porque no me llevó a la usuario, como he mencionado anteriormente. Pero eso está bien. Vamos a mantenerlo simple. Vamos a intentar el número 42. Y eso es positivo. Vamos a intentar el número 42 negativo, negativo. 

Vamos a probar el valor 0. Y, de hecho, funciona. Ahora, verá con problemas antes de largo, lo que se prueba tres veces, probablemente no es suficiente. Es posible que desee probar algunos números más grandes, algunos más pequeños números, algunos casos de esquina, como vamos a venir para describirlos. 

Pero, por ahora, se trata de una programa bastante simple. Y estoy bastante seguro de que, lógicamente, que se divide en tres casos. Y, de hecho, a pesar de que sólo centrado en los aspectos negativos potenciales de imprecisión y de desbordamiento, en realidad en la que muchos de los problemas del CS50, nosotros no nos vamos a preocupar sobre, todo el tiempo, las cuestiones de desbordamiento y imprecisión, porque, de hecho, en C, no es en realidad todo lo que fácil de evitar esas cosas. Si desea contar hasta más grande y más grande, y más grande, Resulta que hay técnicas que se puede utilizar, a menudo con cosas llamadas bibliotecas, colecciones de código, que las otras personas escribieron que puede utilizar, y otros lenguajes como Java y otros, en realidad hacer que sea mucho más fácil a contar incluso más alto. Por lo que realmente es que algunos de estos peligros en función del idioma que utilice. Y en las próximas semanas, vamos a ver lo peligroso C realmente puede ser si no se utiliza correctamente. Pero a partir de ahí, y con Python y JavaScript, se nos capa en algunas protecciones adicionales, y correr menos de esos riesgos. 

Así que vamos a hacer un poco más lógica interesante en nuestro programa. Así que permítanme seguir adelante y crear un programa llamado Logical para que yo pueda jugar con algunos la lógica real, logical.c. Voy a copiar y pegar algunos código de antes, así que regrese a este bonito punto de partida. 

Concédeme tiempo hacer C. carbón estoy va a darle un nombre de C sólo porque es convencional, obtener un personaje del usuario. Y vamos a suponer como Estoy poniendo en práctica parte de ese programa Rm, el remove programa antes de que se le solicite al usuario para eliminar un archivo. ¿Cómo podemos hacer esto? 

Quiero decir, si C es igual iguales, entre comillas, y, a continuación, voy a asumir que el usuario ha elegido sí. Yo sólo voy a imprimir sí. Si verdaderamente estuviera escribiendo el programa de eliminación, podríamos quitar el archivo con más líneas de código. Pero vamos a mantener las cosas simples. 

Porque si c es igual a igual n- y ahora aquí, que voy a decir, el usuario debe haber querido decir que no. Y luego otra cosa, ¿sabes qué? No sé qué otra cosa el usuario va a escribir. Así que sólo voy a decir que que es un error, lo él o ella realmente escrito. 

Entonces, ¿qué está pasando aquí? Existe una diferencia fundamental frente a lo que he hecho en el pasado. Las comillas dobles, comillas dobles, doble citas, y, sin embargo, comillas simples, comillas simples. Resulta que en C, que cuando desea escribir una cadena, usted hace uso de comillas dobles, así como nosotros hemos estado usando todo este tiempo con printf. 

Pero si usted quiere tratar con sólo una carácter individual, un llamado char, a continuación, que realmente utiliza comillas simples. Aquellos de ustedes que han programado antes, puede que no tenga tenía que preocuparse por esto distinción en determinados idiomas. En C, sí importa. Y así, cuando llegue a un char y quiero comparar ese carbón utilizando iguales es igual a alguna carta como S o N, hago, de hecho, necesita tener las comillas simples. 

Ahora, vamos a seguir adelante y hacer esto. Vamos a seguir adelante y hacer realiza dot lógicas slash lógico. Y ahora estoy que se le pida. Por lo tanto, es de suponer, una mejor experiencia de usuario sería en realidad me diga qué hacer aquí. Pero voy a ciegamente decir y para sí, bien, bien. 

Vamos a correr de nuevo, n para no, agradable. Supongamos que al igual que ciertas personas que conozco, mis bloqueo de mayúsculas clave está en demasiada frecuencia. Así que hago Y mayúscula, enter, error. OK, no es exactamente lo que estoy esperando. De hecho, el ordenador está haciendo literalmente lo Le dije a hacer-- comprobar si hay minúsculas y y n minúscula. Esto no se siente como buena experiencia de los usuarios, sin embargo. Déjame pedir y aceptar ya sea minúsculas o mayúsculas. Así que resulta, es posible que desee decir algo como en Scratch, como literal o C es igual es igual único de capitales y citado. Resulta que C no tiene esta palabra clave literal o. 

Pero tiene dos barras verticales. Usted tiene que mantener Shift general, si está utilizando un teclado de EE.UU., y pulsa la barra vertical clave por encima de la tecla de retorno. Pero esta barra vertical o barra vertical indica. 

Si, por el contrario, queríamos decir y, al igual que en Scratch, podríamos hacer signo de signo. Eso no tiene sentido lógico aquí, porque un ser humano no podría han escrito tanto y como minúsculas y y el capital Y como el mismo carácter. Así que, o es lo que nos proponemos aquí. 

Así que si hago esto en ambos lugares, oc es igual a es igual a N mayúscula, ahora vuelva a ejecutar, dar lógica, vuelva a ejecutar lógica. Ahora, puedo escribir y. Y puedo hacerlo de nuevo con Y mayúscula, o N mayúscula Y podría añadir en adicional combinaciones fijas. 

Así que esta es una lógica programa de la medida en que ahora Estoy comprobando lógicamente para este valor o este valor. Y yo no tengo que, necesariamente, llegar a dos IFS IFS más o de lo contrario. De hecho, me puedo combinar algunas de las relacionados con la lógica juntos de esta manera. Así que esto sería mejor diseñada que simplemente decir, si C es igual a minúscula y, imprimir sí, más si c es igual a Y mayúscula, imprimir sí, más si c es igual lower-- en otras palabras, usted no tiene que tener más y más ramas. Se pueden combinar algunos de los equivalentes ramas lógicamente, como en este camino. 

Así que vamos a echar un vistazo a un solo ingrediente final, un último constructo, que permite C. Y vamos a volver en el futuro a otros aún. Y luego vamos a la conclusión examinado por lo que no la corrección de code-- Cómo obtener el código de trabajo-- pero el diseño de código, y plantar las semillas desde el principio. 

Así que permítanme seguir adelante y abrir un nuevo archivo aquí. ¿Sabes que? Voy a volver a poner en práctica ese mismo programa, pero utilizando una construcción diferente. 

Así que me dejó rápidamente entregarme acceso para incluir CS50.h para la biblioteca de CS50, Io.h estándar para printf. Dame mi void main int. Y luego por aquí, y mucho Me seguir adelante y hacer esto. 

Char c consigue obtener char, al igual que antes. Y voy a usar una nueva construcción ahora-- cambiar, en qué carácter? Así interruptor es algo así como El paso de un tren pistas. O, en realidad, es una especie de Si una persona, si otra persona si, pero escrito de manera algo diferente. 

Un interruptor se parece a esto. Usted tiene interruptor, y luego lo carácter o número que desea ver, a continuación, algunas llaves como en Cero, sólo decir hacer estas cosas. Y entonces usted tiene diferentes casos. 

No se utiliza si, y demás. Literalmente se utiliza el caso de textos. Y se podría decir algo como esto. 

Así en el caso de una minúscula y, o en el caso de una capital Y, seguir adelante e imprimir sí. Y luego salir del interruptor. Eso es. Hemos terminado. 

Porque si, por así decirlo, n minúscula o mayúscula N, a continuación, seguir adelante y de impresión fuera no, y luego romper. Else-- y este tipo es el de caso por defecto indeed-- printf error-- y sólo por si acaso, aunque lógicamente esta ruptura no es necesario porque estamos al final del interruptor de todos modos, Ahora estoy rompiendo el exterior del switch. Por lo que este se ve un poco diferente. 

Pero, lógicamente, es en realidad equivalente. Y ¿para qué usar uno sobre el otro? A veces, sólo preferencia personal, a veces la estética, si Echo un vistazo a este Ahora, hay algo que decir acerca de la legibilidad de este código. Es decir, no importa el hecho de que este código es nuevo para muchos de nosotros en la habitación. 

Pero sólo un poco es bastante. Ves minúsculas y, mayúscula, n minúscula, por defecto N mayúscula, que sólo tipo de saltos a la vista de una manera que, sin duda, tal vez el ejemplo anterior a las FI, y las barras verticales, y las FI demás, no podrían tener. Así que esto es realmente una cuestión de personal elección, de verdad, o la legibilidad, del código. 

Pero en términos de funcionalidad, me dejó seguir adelante y hacer un interruptor, barra de puntos interruptor, y ahora escriba en y minúsculas, Y mayúscula, minúscula n, N mayúscula, David, porque eso es reintentar ni un solo símbolo. Vamos a hacer x, el error, como se esperaba. Y, logically-- y esto es algo Yo animaría en general-- incluso aunque sólo nos estamos rascando la superficie de algunas de estas características. 

Y puede que no sea evidente cuando se usted se sienta abajo en el teclado, ¿como funciona esto? Lo que haría esto? Lo bonito de tener un ordenador portátil o de sobremesa, o el acceso a un ordenador con un compilador, y con un editor de código como este, está casi siempre se puede responder a estas preguntas para usted acaba de tratar. 

Por ejemplo, si la retórica pregunta en cuestión eran, ¿qué ocurre si se olvida sus estados de descanso? Que es realmente una muy común que hay que hacer, ya que no se ve como si realmente los necesita. En realidad, no completan su pensado como un paréntesis o un rizado corsé lo hace. Vamos a seguir adelante y volver a compilar el código y ver. Así que el interruptor, interruptor de barra de puntos. Vamos escriba en minúsculas y, la caja superior, Enter. Por lo que he escrito y. 

El programa dijo que sí, no, error, como si cambiaba de opinión. Pero es como que era, porque lo que sucede con un interruptor es el primer caso que se partido esencialmente significa, eh equipo, ejecutar todo el código debajo de ella. Y si usted no dice rompa, o no diga rompa, o no dicen descanso, el equipo va a soplar a través de todas las líneas y ejecutar todos ellos hasta se llega a ese apoyo rizado. Así que los frenos son, de hecho, es necesario. Pero aquí es una comida para llevar, cuando En caso de duda, probar algo. Quizás guardar su código en primer lugar, o guardarlo en un archivo extra si está realmente preocupado por echar a perder y tener que recuperar el trabajo que se sabe que funciona. 

Pero probar cosas. Y no tenga miedo de que, tal vez, de lo que el equipo puede hacer, o que podría romper algo. Siempre se puede volver en cierta versión anterior. 

Así que vamos a terminar mirando en el diseño de código. Tenemos esta facultad ahora para escribir condiciones y bucles de escritura, y variables, y las funciones de llamada. Así que, francamente, estamos de vuelta en la clase de donde estábamos hace una semana con Scratch, aunque con un texto menos convincente medio ambiente que permite arañazos. 

Pero Tenga en cuenta la rapidez con que hemos adquirido que el vocabulario, aunque sea Va a tomar un poco de tiempo para asimilar, por lo que ahora podemos usar este vocabulario para escribir programas más interesantes. Y vamos a dar un paso de bebé hacia que, como sigue. Déjame ir adelante y crear un nuevo archivo aquí. 

Voy a llamar a este prototype.c, e introducir por primera vez, la capacidad para hacer sus propias funciones. Algunos de ustedes podrían tener hecho esto con Scratch, por el que usted puede crear su bloques personalizados propios en cero, y luego arrastrarlos en su sitio allí donde desee en C. Y en la mayoría de programación idiomas, se puede hacer exactamente que- hacer sus propias funciones, si no existen ya. 

Así, por ejemplo, me dejó ir por delante e incluir CS50.h, e incluyen io.h estándar, nula principal int. Y ahora tenemos una marcador de posición de listo para funcionar. Guardo cosas de impresión como nombres de las personas hoy en día. Y eso se siente como- No sería bueno si hay eran una función llamada en letra de imprenta? Yo no tengo que usar printf. No tengo que recordar todos los códigos de formato. ¿Por qué no yo, o por qué no lo hizo alguien antes que yo, crear una función llamada print nombre, que dado un nombre, simplemente lo imprime? 

En otras palabras, si digo, hey, computadora, dame una cadena preguntando al usuario para tal, a través de la función get cadena de CS50. Hey, ordenador, puesto que en la cadena de la variable en el lado izquierdo, y lo llaman s. Y entonces, hey equipo, vaya por delante e imprimir que el nombre de la persona, hecho. 

Ahora, sería bueno, porque este programa, bien llamado, me dice lo que tiene que hacer por medio de los nombres de los de función. Deja que vaya a hacer prototipo, ENTER. Y desafortunadamente, esto no va a volar. 

Prototype.c, línea 7, carácter 5, el error, la declaración implícita Nombre de la función de impresión es inválido en C99, C99 es decir, una versión de C que salió en 1999. Eso es todo. 

Así que no sé qué todo esto significa todavía. Pero sí reconoce error en rojo. Eso es bastante obvio. 

Y parece que con el carácter verde aquí, el problema es con letra de imprenta, abierto paren s, cerca paren, punto y coma. Pero la declaración implícita de función que vimos brevemente antes. Esto significa, simplemente, que Clang no sé lo que quiero decir. 

He utilizado una palabra del vocabulario que es Nunca visto o ha sido enseñado antes. Y así que tengo que enseñarlo lo que significa esta función. Así que voy a seguir adelante y hacer eso. 

Voy a seguir adelante y poner en práctica mi propia función llamada Imprimir Nombre. Y voy a decir, de la siguiente manera, que lo hace, printf, hola, ciento s, la barra invertida n, nombre, punto y coma. Entonces, ¿Qué acabo de hacer? 

Así que resulta, a implementar su propia función, que tipo de prestado algunos de la misma estructura que principal que simplemente hemos sido se da por sentado, y yo saber simplemente copiando y pegando bastante más de lo He estado escribiendo en el pasado. Notar el patrón aquí. Int, principal, Vacío, vamos a desmenuzar en poco tiempo lo que eso significa en realidad. 

Pero por hoy, solo notar el paralelismo. Vacío, en letra de imprenta, nombre de la cadena, por lo que hay una palabra clave púrpura, que vamos a empezar llamar a un tipo de retorno, el nombre de la función, y entonces la entrada. Así que, en realidad, podemos destilar este tipo de como la semana pasada como, este es el nombre o la algoritmo del código que estamos ir a la write-- algoritmo subyacente el código que vamos a escribir. 

Esta es su entrada. Este es su salida. Esta función, el nombre de impresión, es diseñado para tener una cadena denominada nombre, o lo que sea, como entrada, y luego vacío. No devuelve nada, como llegar cadena o conseguir int hace. Por lo que me va a entregar algo a cambio. Sólo va a tener una efecto secundario, por decirlo así, de imprimir el nombre de una persona. Así aviso, línea 7, I puede llamar en letra de imprenta. La línea 10, puedo definir o poner en práctica en letra de imprenta. Pero, por desgracia, eso no es suficiente. 

Déjame ir adelante y recompilar este después de guardar. Vaya, ahora, lo he hecho peor aún, parecería. Así declaración implícita de Nombre de la función de impresión no es válido. Y, de nuevo, no hay más errores. Pero como yo advertí antes, incluso si se dejen confundir con, o un poco triste ver a tantos errores, se centran sólo en la primera inicialmente, debido a que sólo podría han tenido un efecto en cascada. Así C, o Clang más específicamente, Todavía no reconoce el nombre de impresión. 

Y eso es porque Clang, por diseño, es un poco tonto. Sólo hace lo que le indica que hacer. Y sólo lo hace en el orden en el que se diga que haga. 

Así que he definido en la principal línea de cuatro, como lo hemos hecho bastante a menudo. He definido en letra de imprenta en la línea 10. Pero estoy tratando de usar Nombre de impresión en línea de siete. 

Es demasiado pronto, no existe todavía. Así que podría ser inteligente, y ser como, OK, así que vamos a tocar en conjunto, y mover el nombre de impresión hacia arriba aquí, y volver a compilar. Oh Dios mío. Funcionó. Era tan simple como eso. 

Pero la lógica es exactamente eso. Hay que enseñarle a lo que Clang es mediante la definición de la función de primera. A continuación, puede utilizarlo. Pero, francamente, esto se siente como una pendiente resbaladiza. 

Así que cada vez que funciono en un problema, sólo soy va a seleccionar y copiar el código Escribí, cortar y pegar aquí. Y, sin duda, podríamos inventar algunos escenarios donde una función podría que tenga que llamar a otro. Y que no se puede poner a cada función encima de cualquier otro. 

Por lo tanto, resulta que hay una solución mejor. Podemos dejar que esto sea. Y, francamente, es generalmente agradable, y conveniente, y el buen diseño poner principal en primer lugar, porque, de nuevo, principal al igual que cuando se hace clic en bandera verde, que es la función que es ejecutado por defecto. Por lo que también podría poner en la parte superior del archivo de modo que cuando usted o cualquier otro ser humano se ve en el archivo usted sabe lo que está pasando con sólo leer principal en primer lugar. Así que resulta, podemos decir Clang proactiva, hey, Clang, en línea de cuatro, Prometo poner en práctica una función llamada Imprimir Nombre que toma un nombre de cadena llamado como entrada y devuelve nada, el vacío. Y voy a moverse a a cabo más adelante. 

Aquí viene principal. Ahora principal en la línea 9 se puede utilizar Imprimir Nombre porque Clang está confiando en que, con el tiempo, se encontrará con la definición de la aplicación de impresión Nombre. Así que después de guardar mi archivo, y mucho Me seguir adelante y hacer el prototipo, se ve bien en esta ocasión. Dot slash, prototipo, me dejó seguir adelante y escribir un nombre. David, hola David, Zamila, hola Zamila, y, de hecho, ahora se trabaja. 

Así que el ingrediente aquí es que hemos hecho una función personalizada, como una costumbre bloque de cero nos estamos llamando. Pero a diferencia de los arañazos donde se puede acaba de crear y comenzar a usarlo, Ahora tenemos que ser una poco más pedante, y en realidad entrenar Clang usar, o para esperarlo. Ahora, como un aparte, ¿por qué todo este tiempo tiene hemos estado a ciegas en la fe incluyendo CS50.h, e incluyendo estándar io.h? 

Pues bien, resulta que, entre algunas otras cosas, todo lo que está en los puntos h archivos, que pasan a ser los archivos. Están los archivos de cabecera, por así decirlo. Todavía están escritos en C. Sin embargo, que son un tipo diferente de archivo. 

Por ahora, se puede casi asumir que todo lo que está dentro de CS50.h es algunos de una sola línea de este tipo, no para las funciones de impresión llamados Nombre, pero para obtener una cadena de, Get Flotador, y algunos otros. Y hay prototipos similares, trazadores de líneas uno, dentro del estándar io.h para printf, que ahora está en mi propia función de impresión Nombre. Así, en otras palabras, todo este tiempo que hemos acaba de ser ciegamente copiar y pegar incluir esto, incluya que, ¿qué está pasando? Esos son sólo tipo de pistas al sonido metálico como a qué funciones son, de hecho, implementado, justo en diferentes archivos en otra parte en otro lugar en el sistema. 

Así que hemos implementado en letra de imprenta. Se tiene este efecto secundario de imprimir algo en la pantalla. Pero no es así en realidad dame algo de vuelta. ¿Cómo hacemos para la implementación de un programa que yo no entregar algo a cambio? 

Bueno, vamos a probar esto. Déjame ir por delante y poner en práctica un archivo llamado return.c por lo que podemos demostrar cómo algo Obtener como cuerdas, u obtener Int, es en realidad volver algo nuevo al usuario. Vamos a seguir adelante y definir int void main. 

Y, de nuevo, en el futuro, vamos a explicar lo que int y ese vacío es en realidad haciendo. Pero por hoy, vamos a dar por sentado. Voy a seguir adelante y printf, para una buena experiencia de usuario, x es. Y entonces voy a esperar a que el usuario dame x int con get. 

Y luego voy a seguir adelante e imprimir x al cuadrado. Así que cuando usted tiene solamente una teclado, la gente comúnmente utilizar la pequeña zanahoria símbolo en el teclado para representar a la potencia de, o el exponente de. Lo que x al cuadrado está presente i. 

Y ahora voy a hacer esto. Tan sólo pudiera hacer-- lo que es x al cuadrado? x cuadrado es x veces x. 

Y lo hicimos alguna Hace tiempo que ya hoy en día. Esto no se siente como todo lo que mucho progreso. ¿Sabes que? Vamos a apalancan algo de esa idea desde la última vez de la abstracción. 

¿No sería bueno si hay una función llamada cuadrado que hace exactamente eso? Todavía, al final de la día, hace lo mismo matemáticas. Pero vamos abstracta lejos la idea de tomar un número multiplicado por otra, y sólo le dan un nombre, como la cuadratura de este valor. 

Y, en otras palabras, en C, vamos a crear una función llamado cuadrado que hace exactamente eso. Va a ser llamado cuadrado. Se va a tomar un int. Y vamos a voluntad simplemente llamarlo n, de forma predeterminada. 

Pero podría decir que es lo que queramos. Y todo lo que se va a hacer, literalmente, es el regreso el resultado de n veces n. Pero debido a que es devolver algo, lo cual es la palabra clave en la púrpura que hemos nunca había visto antes, yo, en la línea 11, No se puede decir sin efecto este momento. 

Vacío, en el ejemplo que acabamos de ver en lugar del nombre de impresión, sólo significa, hacer algo. Pero no me entregar algo a cambio. En este caso, yo quiero para volver n veces n, o sea lo que sea, ese número. 

Así que no puedo decir, hey, ordenador, Vuelvo nada, nula. Se va a volver, por naturaleza, un int. Y eso es todo lo que está pasando aquí. 

La entrada de la cuadratura va a ser un int. Y para que podamos usarlo, tiene que tener un nombre, N. Se va a la salida un int que no necesita un nombre. Podemos dejamos a principal, o quien usarme para recordar este valor si querer con su propia variable. 

Y, de nuevo, el único nuevo palabra clave aquí es Retorno. Y sólo estoy haciendo un poco de matemática. Si yo realmente quería ser innecesaria, Podría decir producto int n veces se pone n. 

Y entonces yo podría decir, el producto de regreso. Pero, de nuevo, a mi punto anterior de esto simplemente no es buena design-- al igual que, ¿por qué introducir un nombre, un símbolo, como producto, sólo para volver de inmediato? Es un poco más limpio, un poco más fuerte, por lo para hablar, sólo para decir retorno n veces n, deshacerse de esta línea por completo. 

Y es sólo menos código para leer, menos posibilidades de errores. Y vamos a ver si este En realidad ahora trabaja. Ahora, voy a ir adelante y hacer de retorno. 

Uh-oh, declaración implícita de la función. Hice este error antes, no es gran cosa. Me dejaron de naturaleza, así como resaltar y copiar, exactamente el mismo prototipo de función, o la firma, de la función aquí. O podría mover toda la función. 

Pero eso es un poco perezoso. Así que no vamos a hacer eso. Ahora, quiero dejar de retorno de nuevo, punto de retorno barra. 

x es cuadrado 2. x es 4. x es cuadrado 3. x es 9. Y la función parece Ahora que está funcionando. Entonces, ¿cuál es la diferencia aquí? Tengo una función que se llama cuadrado, en este caso, que presento una entrada. Y yo vuelva una salida. Y, sin embargo, con anterioridad, si Abro el otro ejemplo de antes, que fue llamado prototype.c, Tenía en letra de imprenta, que devuelto vacío, por así decirlo, O se volvió nada, y simplemente tenía un efecto secundario. 

Entonces, ¿qué está pasando aquí? Bien, considere la función obtener la secuencia para un momento. Hemos estado usando la función obtener cadena de la siguiente manera. 

Hemos tenido una función get cadena, como son CS50.h, Incluyen estándar io.h, int, principal, nula. Y a continuación, cada vez que he llamada cadena GET hasta el momento, He dicho algo así como: cadena s consigue obtener la secuencia, ya que conseguimos el string-- vamos a llamar a esta cadena get get.c-- sí devuelve una cadena que puede entonces utilizar, y decir hola, coma, s por ciento, la barra invertida n, s. 

Así que este es el mismo ejemplo, Realmente, que teníamos antes. Así que llegar cadena devuelve un valor. Pero hace un momento, la cadena de impresión no devuelve un valor. Simplemente tiene un efecto secundario. Así que esta es una diferencia fundamental. Hemos visto diferentes tipos de funciones que ahora, algunos de los cuales han regresado valores, algunos de los cuales no lo hacen. Así que tal vez es la secuencia, o int o float. O tal vez es sólo vacío. 

Y la diferencia es que estas funciones que obtener datos y devolver un valor son en realidad traer algo nuevo a la mesa, por así decirlo. Así que vamos a seguir adelante y mirar a un conjunto final de ejemplos que da un sentido, ahora, de la forma en que podría, de hecho, abstracta mejor, y mejor, y mejor, o más, y más, y más, con el fin para escribir, en última instancia, un mejor código. Vamos a seguir adelante, y en el espíritu de Scratch, haga lo siguiente. 

Déjame ir adelante y incluyo CS50.h y el estándar io.h. Déjenme seguir adelante y dar yo un int, principal, nula. Y déjame ir por delante, llamo a esto cough.c. 

Y me dejó ir adelante y sólo como arañazos, imprima la tos / n. Y quiero hacer esto tres veces. Así que estoy, por supuesto, sólo va copiar y pegar tres veces. Ahora voy a hacer tos tos barra de puntos. Vamos a dar a mí mismo un poco más de espacio Aquí se pueden introducir, tos, tos, tos. 

Hay, obviamente, ya una oportunidad para mejora. He copiado y pegado un par de veces hoy. Pero eso sólo fue así que no lo hice tiene que escribir tantos caracteres. Todavía cambiado lo esas líneas de código son. 

Estas tres líneas son idénticos, que se siente perezoso y, de hecho, es decir, y probablemente no es el enfoque correcto. Así, con lo que el ingrediente podríamos mejorar este código? No tenemos que copiar y pegar el código. 

Y, de hecho, cada vez que se sienta a sí mismo de copiar y pegar, y ni siquiera el cambio de código, probabilidades son que hay una mejor manera. Y, de hecho, no lo es. Déjame seguir adelante y hacer un bucle, a pesar de que la sintaxis no podría venir naturalmente todavía. 

Haga esto tres veces, simplemente haciendo lo following-- y me he enterado de esto desde la práctica. Pero tenemos un número de ejemplos ahora. Y verá en línea más referencias fijas. 

Esta es la sintaxis de la línea 6, que al igual que los arañazos que se repite bloque, repita los siguientes tres veces. Es un poco mágica por ahora. Pero esto va a conseguir más, y más familiar. 

Y se va a repetir línea de ocho tres veces, por lo que si puedo volver a compilar la tos maquillaje, slash dot tos, tos, tos, tos. Todavía funciona de la misma manera. Así que eso es todo fino y bueno. Pero eso no es muy abstracta. 

Es perfectamente correcto. Pero parece que hay podría ser una oportunidad, como en el mundo de Cero, al tipo de inicio añadir algunos términos aquí para que Yo no sólo tengo un poco de bucle, y una función que dice tos, o que toser. ¿Sabes que? Voy a tratar de ser una poco más fresco que eso, y en realidad escribir una función que tiene algunos efectos secundarios, lo llaman la tos. 

Y se necesita ninguna entrada, y devuelve ningún valor como salida. Pero usted sabe lo que hace? Lo hace esto- printf, entre comillas, toser. 

Y ahora aquí, voy para seguir adelante y para int, i resulta en cero, i menos de 3, i plus plus. Voy a hacer no printf, que es podría decirse que una implementación de bajo nivel detalle. No me importa cómo toser. Sólo quiero utilizar la función de la tos. Y yo sólo voy a llamar a la tos. 

Ahora, observe la dicotomía. Cuando se llama a una función, si no lo hace que desee darle entradas, totalmente bien. Sólo hacer paréntesis de apertura, cierre paren, y ya está. 

Cuando se define una función, o declarar el prototipo de una función, si se sabe de antemano que no es va a tomar ningún argumento, decir nula en aquellos paréntesis allí. Y eso hace que la certeza de que se no por casualidad se mal uso de ella. Déjame seguir adelante y hacer la tos. Y, por supuesto, he cometido un error. 

Maldita sea, hay que declaración implícita. Pero eso está bien. Es una solución fácil. Sólo necesito el prototipo más arriba en mi archivo de lo que estoy de utilizarlo. 

Así que ahora quiero dejar tos de nuevo, agradable. Ahora funciona. Hacer la tos, tos, tos, tos. Así se podría pensar que estamos muy poco más de la ingeniería de este problema. Y, de hecho, somos. Este no es un buen candidato de un programa de en el momento de refactorización, y hacer lo que es llamado descomposición jerárquica, donde se toma algo de código, y luego que tipo de cosas fuera de factores, con el fin adscribir más semántica a ellos, y reutilizarla en última instancia, a más largo plazo. Pero es un bloque de construcción hacia programas más sofisticados que vamos a empezar escrito poco tiempo que nos permite disponer de vocabulario con el que escribir mejor código. Y, de hecho, vamos a ver si nos No se puede generalizar más a fondo. 

Parece un poco cojo que yo, principal, tenga que preocuparse por este maldito bucle, y llamar a la tos y otra vez. ¿Por qué no puedo simplemente decirle a la tos, Por favor, toser tres veces? En otras palabras, ¿por qué no puedo simplemente dar entrada a toser y hacer esto? 

¿Por qué no puedo simplemente decir, en tos principal tres veces. Y ahora, esto es una especie de mágico. Es muy iterativo aquí. Y es, de hecho, un pequeño paso. 

Pero sólo la capacidad de decir en línea de ocho, toser tres veces, es sólo mucho más fácil de leer. Y, además, no tengo que saber ni le importa cómo se implementa la tos. Y, de hecho, más tarde en el plazo y para proyectos fin de carrera, Si usted aborda un proyecto con un compañero de clase o dos compañeros de clase, se dará cuenta de que vas a que, o desea, dividir el trabajo. 

Y vas a querer decidir de antemano, ¿quién va a hacer qué, y en el que piezas? Y no sería agradable si, por ejemplo, hacerse cargo de la escritura principal, hecho. Y su compañero de cuarto, o su socio más en general, se encarga de la aplicación de la tos. 

Y esta división, éstas paredes de la abstracción, o capas de abstracción si va, son súper poderoso, porque especialmente para más grande, más programas y sistemas complejos, que permite a varias personas para construir cosas juntos, y en última instancia puntada su trabajo juntos de esta manera. Pero, por supuesto, necesitará fijar ahora la tos. Tenemos que decirle a la tos que, hey, ¿sabes qué? Vas a tener que tomar una input-- por lo que no vacía, sino int y ahora. Vamos a seguir adelante y poner en tos del int. i resulta en cero. 

i es menor que el número de veces. He dicho tres antes. Pero eso no es lo que quiero. Me quieren toso a generalizarse a soportar cualquier número de iteraciones. 

Así que, de hecho, es n que quiero, cualquiera que sea el usuario me dice. Ahora, puedo seguir adelante y decir la tos de impresión. Y no importa qué número el usuario pasa en, Voy a repetir muchas veces. 

Así que al final del día, programa es idéntico. Pero cuenta todas estas cosas incluso podría ser en otro archivo. De hecho, no sé en el printf momento cómo se implementa. 

No sé en este momento cómo llegar cadena, o conseguir int o float llegar se implementan. Y yo no quiero verlos en mi pantalla. Tal como es, estoy empezando a centrarse en mi programa, no esas funciones. 

Y así, de hecho, tan pronto como se iniciar la factorización código como esto, podríamos incluso mover la tos en un archivo separado? Otra persona podría ponerlo en práctica. Y usted y su programa se convierte en el muy bonito, y muy fácil de leer, podría decirse que, en realidad cuatro programa de línea de allí mismo. 

Así que vamos a seguir adelante ahora y hacer un cambio más. Notar que mi prototipo tiene que cambiar encima de la tapa. Así que déjame arreglar eso por lo Yo no gritar en. 

Hacer la tos, la tos me deja correr una vez Además, sigue haciendo lo mismo. Pero ahora, cuenta que tenemos una ingrediente para una versión final. ¿Sabes que? Yo no quiero simplemente toser, necesariamente. Quiero tener algo más general. Así que ya saben qué? Quiero hacer esto. Quiero tener, al igual que los arañazos hace, un bloque de ejemplo, pero no sólo decir algo cierto número de veces. Lo quiero decir una cadena muy específica. Y, por lo tanto, no lo creo queremos que se acaba de decir la tos. Quiero que diga lo cadena se pasa en. 

Así notar, he generalicé esto para que ahora digamos siente como un buen nombre para esto, como Scratch, toma dos argumentos, a diferencia de los arañazos. Una de ellas es una cadena. Uno de ellos es un int. 

Y podría cambiar ellos. Yo sólo algo así como la idea de decir la cadena primero, y luego cuántas veces posteriores. Void significa que todavía no devuelve nada. Estos son sólo parte visual efectos, como con [? Jordan,?] un efecto secundario verbal de gritar. Todavía hace algo n veces, 0 hasta, pero no es igual a n. Esto significa veces n totales. Y luego simplemente imprimir lo que es de cadena. Así que en realidad he generalicé esta línea de código. Así que ahora, ¿Cómo implemento la función de tos? 

Puedo hacer la tos vacío. Y todavía puedo tomar en la forma Muchas veces se desea que tosa. ¿Pero sabes que? Ahora puedo decir en batea. 

Puedo decir con llamar a la palabra tos, pasando n. Y si quiero aplicar también, sólo por diversión, una función estornudo, Puedo estornudar cierto número de veces. Y puedo seguir reutilizando n, porque notar que m en este contexto o alcance sólo existe dentro de esta función. 

Y n en este contexto sólo existe dentro de esta función aquí. Así que vamos a volver a estas cuestiones de alcance. Y aquí, sólo voy a decir, Achoo, y luego n veces, punto y coma. 

Y ahora, sólo hay que pedir prestado estas funciones Firmas aquí. Así que la tos es correcta. estornudo vacío es correcta ahora. 

Y todavía sólo necesito decir. Así que voy a decir, por ejemplo cadena s, int n, punto y coma. Así que he más de la ingeniería del diablos de este programa. 

Y esto no lo hace necesariamente que se trata de lo que debe hacer al escribir incluso el más simple de los programas. Tomar algo que es obviamente muy simple, muy corto, y volver a ponerlo en práctica usando manera demasiado código. Pero en verdad no ves, y en tiempo de mirar hacia atrás en estos ejemplos, y se dan cuenta, oh, esos son los pasos nos llevó a generalizar en realidad, al factor algo fuera, hasta que al final de la día mi código es en realidad bastante razonable. Porque si quiero toser tres estornudan veces y luego tres veces, Simplemente voy a volver a ejecutar esto, programa de hacer la tos, la tos y correr. Y tengo tres tos y tres estornuda. 

Y por lo que este es un básico paradigma, si se quiere, de cómo podemos ir sobre En realidad la implementación de un programa. Pero vamos a ver ahora lo que es hemos estado haciendo todo este tiempo, y lo que algunas de las piezas finales están detrás de este simple comando. Al final del día, tenemos estado utilizando Clang como nuestro compilador. Hemos estado escribiendo fuente código, convirtiéndola a través de Clang en código máquina. 

Y nosotros hemos estado usando simplemente Hacer para facilitar nuestras pulsaciones de teclas de modo que no tenemos que recordar los encantamientos de sí mismo Clang. Pero lo que es realmente hacer haciendo? Y, a su vez, lo que es Clang realmente hacer? 

Resulta, sin embargo, hemos simplificado la discusión de hoy, diciendo: se toma el código fuente, se envia como entrada a un compilador, que le da de salida de la máquina código, resulta que hay a unos pasos diferentes en el interior hay. Y compilación pasa a ser el paraguas plazo para un montón de pasos. Pero vamos a burlan esto muy rápido. 

Resulta que hemos estado haciendo más cosas cada vez que ejecute un programa, o cada vez que compile un programa de hoy. Así preprocesamiento se refiere a esto-- nada en un programa C, como veremos una y otra vez, que se inicia con este símbolo de hash, o el símbolo hashtag aquí, significa se trata de una directiva de preprocesador. Eso significa que, en este caso, hey computadora, hacer algo con este archivo antes de que realmente compilar mi propio código. 

En este caso, el hash incluye es decir, en esencia, forma de decir de C, Hey ordenador, ir a buscar el contenido de CS50.h y pegar aquí. Hey ordenador, ir a buscar la el contenido de la norma io.h, donde quiera que esté en la disco duro, pega aquí. Así que esas cosas pasan primero en la ejecución previa. 

Y Clang hace todo esto para nosotros. Y lo hace tan rematadamente rápido, que ni siquiera ver cuatro cosas distintas que suceden. Pero esa es la primera de esas medidas. 

Lo que en realidad sucede después? Así, la próxima oficial paso es la compilación. Y resulta que compilación de un programa técnicamente significa que va desde código fuente, las cosas que he estado escribiendo hoy en día, a algo llamado código ensamblador, algo que se ve un poco diferente. 

Y, de hecho, podemos ver esto muy rápido. Déjame ir en realidad en mi IDE. Déjame ir adelante y hola.c abierto, lo cual es el primer programa con el que nos comenzó hoy. Y me dejó ir adelante y corro un Clang poco diferente, Clang-s, hola.c, que en realidad se va a dame otro archivo hello.s. 

Y probablemente nunca se volver a ver este tipo de código. Si se toma un nivel más bajo clase de sistemas como CS61, verá mucho más de este tipo de código. Pero este es el lenguaje ensamblador. Este es el lenguaje ensamblador X86 que la CPU que subyace CS50 IDE entiende realmente. 

Y críptico como lo hace mira, es algo el equipo entiende bastante bien. Sub q, esta es una de resta. Hay movimientos. 

Hay llamando a las funciones aquí, x oring, un movimiento, un complemento, sin oposición, un retorno. Así que hay algunos muy instrucciones de bajo nivel que entienden que las CPU He aludido anteriormente. Eso es lo que Intel Inside. 

Hay patrones de ceros y unos que asignar a éstos redactada arcanamente, pero algo así-llamado, instrucciones, por así decirlo. Eso es lo que sucede cuando compilar el código. Usted consigue el montaje lengua fuera de él, lo cual significa el tercer paso es ensamblar que el código de montaje en, en última instancia, ceros máquina code-- y unos, no las texto que acabamos de ver hace un momento. 

Por lo tanto pre-tratamiento no que encuentran y reemplazar, y algunas otras cosas. Compilación toma su fuente código de C, el código fuente que escribimos, para el montaje código que acabamos echó un vistazo a. Montaje detiene ensamblaje código para ceros y unos que la CPU realmente se comprender al final del día. Y la vinculación es el último paso eso sucede para nosotros-- de nuevo, tan rápido que ni siquiera notice-- que dice: eh equipo, tomar todas los ceros y unos que el resultado de la compilación de código de David, y su función principal en este caso. 

Y oye ordenador, ir a buscar todos los ceros y unos que el personal CS50 escribió dentro de la biblioteca CS50. Mezclar los de David de. Y oye ordenador, ir a buscar todos los ceros y los que otra persona escribió años Hace de printf. Y añadir aquellos en el cosa entera, por lo que hemos tengo mis ceros y unos, la ceros y unos del personal CS50, printf los ceros y unos, y cualquier cosa que esté utilizando. 

Todos ellos consiguen combinarse entre sí en una sola programa llamado, en este caso, hola. Así que de ahora en adelante, nos limitaremos utilizar la palabra compilación. Y vamos a dar por sentado que cuando decimos, compilar el programa, es decir, Hey hacer el pre-procesamiento, montaje, y la vinculación. Pero en realidad hay algunas cosas jugosas pasando allí debajo de la campana. Y sobre todo si sentir curiosidad algún tiempo, se puede empezar a jugar en torno a este nivel inferior. Pero por ahora, darse cuenta de que entre los robos de balón para hoy son, sencillamente, la inicio de un proceso, de sentirse cómodo con algo así como hola mundo. De hecho, la mayor parte de lo que hicimos hoy luego, no se hundirá en super rápida. Y que tomará algún tiempo, y algo de práctica. Y las probabilidades son, que va a clasificar de querer golpear el teclado o gritar a la pantalla. Y todo eso está bien. Aunque, tal vez trate de no hacerlo en la biblioteca tanto. 

Y en última instancia, se le ser capaces, sin embargo, para empezar ver patrones, tanto en buen código que has escrito y en errores que usted ha hecho. Y al igual que el proceso de convirtiendo en un TF o una CA es como, usted comenzará a mejorar y mejor al ver a esos patrones, y acaba de resolver su propios problemas en última instancia. Mientras tanto, habrá un montón de nosotros para prestarle apoyo, y conseguir que a través de esto. Y en los escritura-ups para todos los problemas va a ser guiado a través de todos los comandos que por cierto, conozco de mucha práctica por ahora, pero podría haber volado encima de la cabeza por ahora. Y eso es totalmente bien. 

Pero, en última instancia, vas para empezar a ver patrones emergen. Y una vez que pasas toda la estúpidos detalles, como paréntesis, y llaves, y puntos y comas, y las cosas, francamente, que no es en absoluto intelectualmente interesante. Y no es el objetivo de tomar cualquier clase de introducción. Es las ideas que se van a importar. 

Es los bucles, y el condiciones y las funciones, y con más fuerza la abstracción, y la factorización de código, y el buen diseño y la buena estilo, y en última instancia la corrección de su código, que es en última instancia, va a importar más. Así que la próxima semana, vamos a tomar estas ideas que vimos por primera vez en Scratch y ahora se han traducido a C. Y vamos a empezar para introducir la primera de las dominios del mundo real del curso. 

Nos centraremos en el mundo de la seguridad, y más específicamente la criptografía, el arte de la codificación de la información. Y entre los primeros ustedes el problema usted mismo se llega a escribir más allá jugando con algunos de la sintaxis y la solución de algunos lógica problemas, en última instancia, en poco tiempo, es en realidad para codificar o encriptar, y, finalmente, descifrar la información. Y todo lo que hemos hecho hoy en día, lo hará bastante baja nivel, es sólo va a permitir que tomemos uno, y uno, y un paso más hacia arriba escribir el código más interesante aún. 

Por lo tanto más en que la próxima semana. 

[REPRODUCCIÓN DE VÍDEO] 

-¿Qué Puede decirme de la última vez que lo viste? -¿Qué Puede decir que, en realidad? Quiero decir, era como cualquier otro ensayo de pre-producción, excepto que no había algo que dijo al final que me quedó grabada. 

-Este Fue CS50. 

-Es Un corte de todo el mundo, gran trabajo en el ensayo. 

El almuerzo de -esto? 

Sí, usted y yo podemos tomar un bocadillo en un rato. Me dejaron con Debrief David muy rápidamente. David? David? 

[FIN DE REPRODUCCIÓN] 