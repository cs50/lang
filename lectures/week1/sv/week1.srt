1
00:00:00,000 --> 00:00:00,000

2
00:00:00,000 --> 00:00:00,000
[Musik spelar]

3
00:00:00,000 --> 00:00:13,950

4
00:00:13,950 --> 00:00:16,240
>> DAVID J. MALAN: Okej, är detta CS50.

5
00:00:16,240 --> 00:00:18,010
Och detta är vecka ett.

6
00:00:18,010 --> 00:00:22,050
Så ihåg att sista gången i veckan noll,
Vi fokuserade på beräkningstänkande.

7
00:00:22,050 --> 00:00:25,440
Och vi gått från det att
Scratch, en grafisk programmering

8
00:00:25,440 --> 00:00:27,360
språk från våra vänner
vid MIT Media Lab.

9
00:00:27,360 --> 00:00:31,730
>> Och med Scratch, vi utforska
idéer som funktioner och villkor,

10
00:00:31,730 --> 00:00:35,210
och loopar, och variabler, och även
händelser, och tråd och mycket mer.

11
00:00:35,210 --> 00:00:37,880
Och i dag, kommer vi att
fortsätta att använda dessa idéer,

12
00:00:37,880 --> 00:00:40,630
och verkligen tar dem för
beviljas, men översätta dem

13
00:00:40,630 --> 00:00:44,220
till ett annat språk som kallas C. Nu
C är en mer traditionell språk.

14
00:00:44,220 --> 00:00:46,020
Det är en lägre nivå
språk, om man så vill.

15
00:00:46,020 --> 00:00:47,300
>> Det är rent text.

16
00:00:47,300 --> 00:00:49,910
Och så vid första anblicken, är det
alla kommer att se ganska kryptiska

17
00:00:49,910 --> 00:00:51,430
Om du har aldrig programmerat förut.

18
00:00:51,430 --> 00:00:53,530
Vi kommer att ha
semikolon, och parenteser,

19
00:00:53,530 --> 00:00:55,150
och klamrar, och mycket mer.

20
00:00:55,150 --> 00:00:57,240
Men inse att även
men syntaxen är

21
00:00:57,240 --> 00:01:00,600
på väg att titta lite obekant
de flesta av er, se förbi det.

22
00:01:00,600 --> 00:01:03,220
Och försöka se idéerna
som är verkligen bekant,

23
00:01:03,220 --> 00:01:06,750
för här i veckan ett vad
Vi kommer att börja göra är att jämföra,

24
00:01:06,750 --> 00:01:08,980
initialt, Scratch kontra C.

25
00:01:08,980 --> 00:01:12,350
>> Så, till exempel, minns att när vi
genomförde den första av våra program

26
00:01:12,350 --> 00:01:16,220
förra gången hade vi ett block som såg
en liten sak som this-- när

27
00:01:16,220 --> 00:01:19,990
grön flagga klickade, och sedan hade vi
en eller flera pusselbitar under det,

28
00:01:19,990 --> 00:01:22,150
i det här fallet, säger, hej världen.

29
00:01:22,150 --> 00:01:24,870
Så, ja, i Scratch,
när jag klickar det gröna flaggan

30
00:01:24,870 --> 00:01:27,390
att köra mitt program, så
att tala, dessa är

31
00:01:27,390 --> 00:01:29,520
block som får utförda, eller springa.

32
00:01:29,520 --> 00:01:32,230
Och särskilt Scratch
sade, hallå, världen.

33
00:01:32,230 --> 00:01:35,377
>> Nu kunde jag har angett
olika ord här.

34
00:01:35,377 --> 00:01:37,960
Men vi ser att, faktiskt, många
av dessa blocks-- och faktiskt,

35
00:01:37,960 --> 00:01:41,880
i C många functions-- kan vara
parametrized eller anpassad

36
00:01:41,880 --> 00:01:43,150
att göra olika saker.

37
00:01:43,150 --> 00:01:45,520
I själva verket, i C om vi
vill konvertera, nu,

38
00:01:45,520 --> 00:01:47,567
detta Skrapa programmet
till detta andra språk,

39
00:01:47,567 --> 00:01:49,650
vi kommer att skriva en
lite ungefär så här.

40
00:01:49,650 --> 00:01:52,540
>> Visst, det finns en viss obekant
syntax där mest troligt, int,

41
00:01:52,540 --> 00:01:54,380
och parenteser och ogiltiga.

42
00:01:54,380 --> 00:01:57,740
Men printf-- även om du skulle
tror att det bara skulle vara tryck.

43
00:01:57,740 --> 00:02:00,120
Men utskriftsorgan print
formaterade, som vi snart kommer att se.

44
00:02:00,120 --> 00:02:02,140
Detta bokstavligen ut
till skärmen oavsett

45
00:02:02,140 --> 00:02:05,990
är inne i dessa parenteser, som
naturligtvis i detta fall är, hallå världen.

46
00:02:05,990 --> 00:02:09,290
>> Men du kommer att märka några andra
syntax, några citattecken,

47
00:02:09,290 --> 00:02:11,890
att parenteserna i slutet,
semikolon och liknande.

48
00:02:11,890 --> 00:02:15,027
Så det finns lite overhead,
så att säga, både kognitivt

49
00:02:15,027 --> 00:02:17,860
och syntaktiskt, att vi ska
att komma ihåg innan lång.

50
00:02:17,860 --> 00:02:20,720
Men inser att med praktiken,
Detta kommer att börja hoppa ut på dig.

51
00:02:20,720 --> 00:02:24,920
>> I själva verket, låt oss fokusera på att en
Funktionen specifically-- i detta fall,

52
00:02:24,920 --> 00:02:26,290
säga hej världen.

53
00:02:26,290 --> 00:02:27,560
Så säger är funktionen.

54
00:02:27,560 --> 00:02:31,320
Hej världen är dess parameter,
eller argument, dess anpassning.

55
00:02:31,320 --> 00:02:34,320
>> Och likvärdighet i C är bara
kommer att vara så här en rad här,

56
00:02:34,320 --> 00:02:38,710
där printf är ekvivalent med att säga,
dubbel citerade strängen, hej

57
00:02:38,710 --> 00:02:41,470
material är ekvivalent, naturligtvis,
till vad som finns i den vita rutan där.

58
00:02:41,470 --> 00:02:45,680
Och omvänt snedstreck n, men lite
konstigt och frånvarande från Scratch,

59
00:02:45,680 --> 00:02:49,380
helt enkelt kommer att ha effekt vi ska
se i en dator, som min Mac eller PC,

60
00:02:49,380 --> 00:02:51,660
för att bara flytta
markören till nästa rad.

61
00:02:51,660 --> 00:02:53,970
Det är som att slå
Retur på tangentbordet.

62
00:02:53,970 --> 00:02:55,580
>> Så vi får se det igen snart.

63
00:02:55,580 --> 00:02:58,640
Men först, låt oss ta en titt på denna
andra exempel i fallet med öglor.

64
00:02:58,640 --> 00:03:02,830
Vi hade det alltid slinga förra gången,
som var en rad pusselbitar

65
00:03:02,830 --> 00:03:05,490
som gjorde något bokstavligen
forever-- i detta fall,

66
00:03:05,490 --> 00:03:08,360
säga hej världen, hallå världen,
hello world, hello world.

67
00:03:08,360 --> 00:03:10,350
Så det är en oändlig loop av design.

68
00:03:10,350 --> 00:03:14,580
>> I C, om vi vill genomföra detta
samma idé, kan vi helt enkelt göra detta.

69
00:03:14,580 --> 00:03:19,570
Medan sant, printf hello world-- nu
medan bara semantiskt, typ av

70
00:03:19,570 --> 00:03:23,090
väcker tanken på att göra
något igen, och igen, och igen,

71
00:03:23,090 --> 00:03:23,980
och hur länge?

72
00:03:23,980 --> 00:03:27,990
Tja, true-- minns att
sant är bara på eller en.

73
00:03:27,990 --> 00:03:30,660
>> Och sant är naturligtvis alltid sant.

74
00:03:30,660 --> 00:03:33,060
Så det är lite av en meningslös
uttalande bara säga sant.

75
00:03:33,060 --> 00:03:36,890
Men i själva verket är detta avsiktligt,
eftersom om sant är bara alltid sant,

76
00:03:36,890 --> 00:03:40,850
än medan sant bara antyder,
om lite indirekt,

77
00:03:40,850 --> 00:03:44,070
att följande kodrader
mellan dessa klammerparenteser

78
00:03:44,070 --> 00:03:48,320
ska bara köra igen, och igen,
och igen, och aldrig sluta.

79
00:03:48,320 --> 00:03:50,230
>> Men om du vill att
slinga för att sluta, som vi

80
00:03:50,230 --> 00:03:54,500
gjorde förra gången med något liknande
detta, upprepa följande 50 gånger,

81
00:03:54,500 --> 00:03:57,700
i C kan vi göra samma sak med vad som är
kallas en för loop-- sökordet

82
00:03:57,700 --> 00:03:59,330
inte vara tag, men för.

83
00:03:59,330 --> 00:04:03,290
Och sedan har vi några nya syntax här,
med int i lika med 0, i mindre än 50,

84
00:04:03,290 --> 00:04:03,880
i ++.

85
00:04:03,880 --> 00:04:05,430
Och vi ska återkomma till det.

86
00:04:05,430 --> 00:04:09,660
Men detta är bara hur vi skulle
översätta uppsättning Scratch block

87
00:04:09,660 --> 00:04:13,079
till en uppsättning av C rader kod.

88
00:04:13,079 --> 00:04:14,450
>> Samtidigt anser variabler.

89
00:04:14,450 --> 00:04:16,540
Och, faktiskt, vi bara
såg en en stund sedan.

90
00:04:16,540 --> 00:04:21,220
Och i fallet med Scratch, om vi
ville deklarera en variabel som heter i

91
00:04:21,220 --> 00:04:24,590
för i är heltal, bara ett nummer,
och vi vill ställa in den till ett visst värde,

92
00:04:24,590 --> 00:04:28,410
vi skulle använda denna orange
blockera här-- satt i till 0.

93
00:04:28,410 --> 00:04:30,800
>> Och vi kommer att se i dag och
bortom, precis som förra veckan,

94
00:04:30,800 --> 00:04:33,850
programmerare gör nästan alltid
börja räkna från noll, verkligen

95
00:04:33,850 --> 00:04:34,950
konventionellt.

96
00:04:34,950 --> 00:04:37,250
Men också på grund återkallande från
vår diskussion av binär,

97
00:04:37,250 --> 00:04:39,990
det minsta antalet du kan
representerar med vilken som helst antal bitar

98
00:04:39,990 --> 00:04:41,640
bara kommer att bli 0 själv.

99
00:04:41,640 --> 00:04:45,190
Och så kommer vi i allmänhet börjar
initiera även våra variabler till 0.

100
00:04:45,190 --> 00:04:47,710
>> Och i C att göra detsamma,
vi kommer att säga int

101
00:04:47,710 --> 00:04:50,110
för heltal, jag bara av konventionen.

102
00:04:50,110 --> 00:04:53,390
Jag kunde ha ringt denna variabel
vad jag vill, precis som i Scratch.

103
00:04:53,390 --> 00:04:57,770
Och sedan lika 0 bara delar
värdet 0 från höger

104
00:04:57,770 --> 00:05:01,319
och sätter det i variabeln, eller
lagringsbehållare där, till vänster.

105
00:05:01,319 --> 00:05:04,360
Och semikolon som vi ska see-- och
vi har sett några av dessa already--

106
00:05:04,360 --> 00:05:06,530
betyder bara slutet av tanken.

107
00:05:06,530 --> 00:05:09,430
Fortsätt att göra något annat
på de linjer som följer.

108
00:05:09,430 --> 00:05:11,330
>> Nu, hur booleska uttryck?

109
00:05:11,330 --> 00:05:14,320
Minns att i Scratch,
dessa var uttryck

110
00:05:14,320 --> 00:05:16,740
som är antingen sant
eller false-- frågor,

111
00:05:16,740 --> 00:05:18,910
verkligen, som är antingen sant eller falskt.

112
00:05:18,910 --> 00:05:21,960
Så i fallet med Scratch, vi kanske
ställa en enkel fråga som denna,

113
00:05:21,960 --> 00:05:24,586
är jag mindre än 50?

114
00:05:24,586 --> 00:05:25,710
Så jag återigen är ett heltal.

115
00:05:25,710 --> 00:05:27,210
Kanske vi använder den
i ett Scratch program

116
00:05:27,210 --> 00:05:29,310
att hålla reda på en poäng
eller något sådant.

117
00:05:29,310 --> 00:05:33,810
Så här syntaxen här i Scratch
betyder bara är jag mindre än 50?

118
00:05:33,810 --> 00:05:37,330
Jo, tack och lov, är något
enkel i C. Och att översätta,

119
00:05:37,330 --> 00:05:41,780
detta skulle vi helt enkelt säga att jag mindre
än 50, med det välbekanta nyckel

120
00:05:41,780 --> 00:05:42,850
på tangentbordet.

121
00:05:42,850 --> 00:05:45,141
>> Under tiden, om du ville
säga något mer allmänt,

122
00:05:45,141 --> 00:05:49,890
som, ja, är x mindre än y där varje
x och y är själva variabler?

123
00:05:49,890 --> 00:05:52,280
Vi kan göra samma sak
i C, så länge som vi har

124
00:05:52,280 --> 00:05:53,942
skapat dessa variabler redan.

125
00:05:53,942 --> 00:05:55,650
Och vi får se hur man
göra det inom kort.

126
00:05:55,650 --> 00:05:58,590
Vi skulle helt enkelt säga x mindre än y.

127
00:05:58,590 --> 00:06:00,530
>> Så du börjar
se vissa likheter.

128
00:06:00,530 --> 00:06:03,490
Och dessa folks som gjorde
Scratch var säkert

129
00:06:03,490 --> 00:06:05,250
inspirerad av några av dessa grundläggande idéer.

130
00:06:05,250 --> 00:06:10,350
Och du ser den här typen av
syntax i många languages--

131
00:06:10,350 --> 00:06:12,160
inte bara Scratch, inte
bara C, men Python,

132
00:06:12,160 --> 00:06:14,790
och JavaScript, och
andra språk fortfarande.

133
00:06:14,790 --> 00:06:18,270
>> Låt oss betrakta en annan konstruktion
från C, begreppet tillstånd,

134
00:06:18,270 --> 00:06:20,370
göra något villkorligt.

135
00:06:20,370 --> 00:06:22,720
Om något är sant, gör detta.

136
00:06:22,720 --> 00:06:24,457
Om något annat är sant, gör det.

137
00:06:24,457 --> 00:06:27,040
Det är typ av program
ekvivalent av en gaffel i vägen.

138
00:06:27,040 --> 00:06:29,730
Kanske är det en tvåvägs gaffel,
ett tre-vägs gaffel, eller mer.

139
00:06:29,730 --> 00:06:32,800
Och i Scratch, kan vi ha
sett något liknande.

140
00:06:32,800 --> 00:06:34,010
>> Så här är en stor en.

141
00:06:34,010 --> 00:06:36,750
Men anser den relativa
enkelheten i logik.

142
00:06:36,750 --> 00:06:44,010
Om x är mindre än y, sedan säga x är mindre
än y, annars om x är större än y,

143
00:06:44,010 --> 00:06:46,230
sedan säga x är större än y.

144
00:06:46,230 --> 00:06:48,300
Och sedan, logiskt, om
du tänker tillbaka på Scratch

145
00:06:48,300 --> 00:06:52,610
eller bara din egen mänskliga intuition,
väl, om x inte är större än y, och x

146
00:06:52,610 --> 00:06:57,000
inte är mindre än y, då naturligtvis
x kommer att vara lika med y.

147
00:06:57,000 --> 00:06:59,690
Så i detta fall, genom att bygga bo
dessa Skrap block,

148
00:06:59,690 --> 00:07:02,580
kan vi uppnå en tre
sätt vägskäl?

149
00:07:02,580 --> 00:07:04,980
>> Under tiden, om vi vill
göra det i C, det utan tvekan

150
00:07:04,980 --> 00:07:08,420
ser lite simpler-- åtminstone
När du bekanta dig med syntax.

151
00:07:08,420 --> 00:07:12,050
Om x är mindre än y,
printf x är mindre än y.

152
00:07:12,050 --> 00:07:16,140
Annars om x är större än y,
printf x är större än y.

153
00:07:16,140 --> 00:07:21,210
Else printf x är lika med y-- och,
igen, med de som omvänt snedstreck slutar strax

154
00:07:21,210 --> 00:07:24,160
för de nya linjer så att om du
faktiskt sprang denna typ av program

155
00:07:24,160 --> 00:07:25,940
det skulle bara flytta
markören i slutändan

156
00:07:25,940 --> 00:07:28,100
till nästa rad på skärmen.

157
00:07:28,100 --> 00:07:31,270
>> Nu hade tiden Scratch andra
mer sofistikerade funktioner, endast

158
00:07:31,270 --> 00:07:34,320
något som vi ska
initialt flytta över till en värld av C.

159
00:07:34,320 --> 00:07:37,010
Och en av dem var
kallas en lista i Scratch.

160
00:07:37,010 --> 00:07:39,100
Och detta var en speciell
typ av variabel som

161
00:07:39,100 --> 00:07:42,840
tillåtit att lagra flera saker
i det tillbaka, att backa, backa, backa.

162
00:07:42,840 --> 00:07:45,540
>> I C, har den inte
listor, i sig, men något

163
00:07:45,540 --> 00:07:48,090
som är mer allmänt
kallade matriser, även om vi kommer

164
00:07:48,090 --> 00:07:50,590
komma tillbaka senare denna termin
att titta på något

165
00:07:50,590 --> 00:07:52,780
kallas en lista, eller egentligen en länkad lista.

166
00:07:52,780 --> 00:07:55,510
Men nu, närmast
motsvarande i C för oss

167
00:07:55,510 --> 00:07:57,345
kommer att bli något
kallas en array.

168
00:07:57,345 --> 00:07:59,740
Och en mängd är helt enkelt en
speciell typ av variabel

169
00:07:59,740 --> 00:08:03,160
som tillåter dig att lagra data
tillbaka mot rygg, mot rygg, mot rygg.

170
00:08:03,160 --> 00:08:05,840
>> Och faktiskt, i Scratch,
om vi ville komma åt

171
00:08:05,840 --> 00:08:09,030
det första elementet i en matris eller
en list-- och jag kommer att kalla det,

172
00:08:09,030 --> 00:08:13,600
Av konvention argv, argument
vektor, men mer om det inom kort.

173
00:08:13,600 --> 00:08:17,090
Om jag vill komma åt det första elementet
av ArGV, i en värld av Scratch

174
00:08:17,090 --> 00:08:20,930
du faktiskt gör vanligtvis
börja räkna från ett.

175
00:08:20,930 --> 00:08:22,850
>> Och så jag kan få punkt 1 i argv.

176
00:08:22,850 --> 00:08:26,310
Det är bara hur MIT förs
begreppet listor.

177
00:08:26,310 --> 00:08:29,860
Men i C, jag kommer att
mer helt enkelt bara säga, argv,

178
00:08:29,860 --> 00:08:32,758
som återigen är namnet på min
list-- eller för att vara tydlig, en array.

179
00:08:32,758 --> 00:08:34,549
Och om jag vill först
element, jag ska

180
00:08:34,549 --> 00:08:37,890
att använda hakparenteser, som du
kanske inte ofta används under ett tangentbord.

181
00:08:37,890 --> 00:08:40,150
>> Men 0 betyder bara får mig först.

182
00:08:40,150 --> 00:08:42,160
Så ibland och som
tiden går, vi kommer

183
00:08:42,160 --> 00:08:44,570
att börja se dessa dikotomier
mellan Scratch och C,

184
00:08:44,570 --> 00:08:46,070
varvid Scratch använder ett.

185
00:08:46,070 --> 00:08:47,670
Vi i C använder 0 här.

186
00:08:47,670 --> 00:08:49,420
Men du kommer snabbt se
när du förstår

187
00:08:49,420 --> 00:08:52,920
grunderna för varje språk, som
dessa saker börjar bli allt mer

188
00:08:52,920 --> 00:08:56,860
bekant genom praktik och praktik.

189
00:08:56,860 --> 00:08:59,700
>> Så låt oss faktiskt tittar nu på ett program.

190
00:08:59,700 --> 00:09:04,031
Här skall vara den första av vår C
källkoden för kompletta program.

191
00:09:04,031 --> 00:09:06,280
Och det program som vi ska
att erbjuda för behandling

192
00:09:06,280 --> 00:09:09,340
är den som är ekvivalent
som tidigare Scratch pjäs.

193
00:09:09,340 --> 00:09:13,210
>> Så här har vi vad som är
utan tvekan den enklaste C-program

194
00:09:13,210 --> 00:09:15,410
du kan skriva att
faktiskt gör något.

195
00:09:15,410 --> 00:09:18,250
Nu kommer vi att titta förbi,
för nu har omfatta

196
00:09:18,250 --> 00:09:21,190
standard io.h, och dessa vinkel
konsoler, och int och tom,

197
00:09:21,190 --> 00:09:22,840
och klammerparenteserna, och liknande.

198
00:09:22,840 --> 00:09:25,390
>> Och låt oss bara fokusera på
vad, åtminstone intuitivt,

199
00:09:25,390 --> 00:09:26,860
kan hoppa ut på dig redan.

200
00:09:26,860 --> 00:09:30,300
I själva verket, huvudsakligt, det gör jag inte
nödvändigtvis vet vad detta är,

201
00:09:30,300 --> 00:09:34,580
men likt Scratch hade att när
grön flagga klickade pusselbit,

202
00:09:34,580 --> 00:09:39,070
så gör C såsom ett programmeringsspråk
har en huvud bit kod som

203
00:09:39,070 --> 00:09:43,380
blir verk som standard. Och faktiskt,
Det är bokstavligen kommer att kallas huvud.

204
00:09:43,380 --> 00:09:44,720
>> Så huvud är en funktion.

205
00:09:44,720 --> 00:09:48,720
Och det är en speciell funktion som finns
i C att när du kör ett program,

206
00:09:48,720 --> 00:09:52,720
Det är huvud som blir drivs av
standard. I en värld av Scratch,

207
00:09:52,720 --> 00:09:56,970
det var oftast när grön flagg
klickade som fick köras som standard.

208
00:09:56,970 --> 00:10:01,130
>> Samtidigt har vi sett det här förut,
printf eller skriva ut formaterad, det är

209
00:10:01,130 --> 00:10:05,620
kommer att vara en funktion som kommer med
C, tillsammans med en massa andra,

210
00:10:05,620 --> 00:10:10,140
att vilja från gång
igen, för att göra exakt

211
00:10:10,140 --> 00:10:12,450
som namnet antyder, skriva ut något.

212
00:10:12,450 --> 00:10:13,500
Vad vill vi skriva ut?

213
00:10:13,500 --> 00:10:15,770
Tja, vi får se att
Genom att innesluta tecken

214
00:10:15,770 --> 00:10:18,680
som these-- hello world,
snedstreck n inom citationstecken,

215
00:10:18,680 --> 00:10:23,040
Vi kan tala om printf exakt
Vad som ska skrivas på skärmen.

216
00:10:23,040 --> 00:10:26,430
>> Men för att göra
att vi tyvärr

217
00:10:26,430 --> 00:10:30,010
behöver ta något som är
redan kryptiska för oss människor,

218
00:10:30,010 --> 00:10:34,510
men det är åtminstone något readable--
skarp inkluderar standard io.h, int

219
00:10:34,510 --> 00:10:39,340
Huvud, tomrum, printf alla magiska
besvärjelsear såg vi bara på skärmen.

220
00:10:39,340 --> 00:10:42,470
Men vi har faktiskt
gå mer svårbegripliga fortfarande.

221
00:10:42,470 --> 00:10:47,140
måste vi först översätta koden
att vi skriver till maskinkod.

222
00:10:47,140 --> 00:10:51,370
Och minns från förra veckan att maskiner,
åtminstone de som vi känner här,

223
00:10:51,370 --> 00:10:54,450
i slutet av dagen bara
förstå nollor och ettor.

224
00:10:54,450 --> 00:10:58,100
>> Och min Gud, om vi var tvungna att skriva dessa
nollor och ettor till faktiskt program,

225
00:10:58,100 --> 00:11:01,260
Det skulle mycket, mycket snabbt
ta det roliga ur något.

226
00:11:01,260 --> 00:11:05,150
Men det visar sig, per förra veckan,
att dessa mönster av nollor och ettor

227
00:11:05,150 --> 00:11:06,400
bara har speciell betydelse.

228
00:11:06,400 --> 00:11:08,500
I vissa sammanhang,
de kan betyda siffror.

229
00:11:08,500 --> 00:11:11,840
>> I vissa sammanhang kan de innebära
bokstäver eller färger, eller vilket som helst antal

230
00:11:11,840 --> 00:11:14,710
andra abstraktioner det på.

231
00:11:14,710 --> 00:11:18,450
Men precis som datorn har
en CPU, Central Processing Unit,

232
00:11:18,450 --> 00:11:20,390
eller hjärnan inuti datorn.

233
00:11:20,390 --> 00:11:22,240
Det är oftast Intel
inuti, eftersom det är

234
00:11:22,240 --> 00:11:24,900
ett av de största företagen
som gör processorer för datorer.

235
00:11:24,900 --> 00:11:28,910
>> Tja, Intel-processorer och andra
helt enkelt har beslutat i förväg

236
00:11:28,910 --> 00:11:33,970
att vissa mönster av nollor och
som avses specifika saker.

237
00:11:33,970 --> 00:11:37,040
Vissa mönster av ettor och nollor
kommer att innebära, skriva detta på skärmen,

238
00:11:37,040 --> 00:11:39,710
eller lägga till dessa två siffror, eller
subtrahera dessa två siffror,

239
00:11:39,710 --> 00:11:43,310
eller flytta denna del av data från
datorns minne hit,

240
00:11:43,310 --> 00:11:47,870
eller valfritt antal andra mycket låg nivå,
men i slutändan bra, verksamheten.

241
00:11:47,870 --> 00:11:53,022
Men, tack och lov, vi människor inte kommer
att behöva känna denna detaljnivå.

242
00:11:53,022 --> 00:11:56,230
I själva verket, precis som förra gången, där vi
abstraherad igen, och igen, och igen,

243
00:11:56,230 --> 00:11:58,930
byggnad från mycket låg nivå
primitiver som nollor och ettor

244
00:11:58,930 --> 00:12:01,160
begrepp högre nivå
som siffror och bokstäver,

245
00:12:01,160 --> 00:12:04,330
färger och mer,
så kan vi som programmerare

246
00:12:04,330 --> 00:12:07,080
stå på axlarna av
andra som har kommit före oss

247
00:12:07,080 --> 00:12:11,260
och använda programvara som andra
människor har skrivit innan oss--

248
00:12:11,260 --> 00:12:14,340
nämligen program som kallas kompilatorer.

249
00:12:14,340 --> 00:12:17,770
>> C är ett språk som
vanligen samman,

250
00:12:17,770 --> 00:12:22,130
vilket innebär omvandlas från
källkod till maskinkod.

251
00:12:22,130 --> 00:12:25,230
Framför allt vad detta innebär
är att om du har din källa

252
00:12:25,230 --> 00:12:29,530
kod som du själv skriver, som vi snart
kommer i ett ögonblick på skärmen,

253
00:12:29,530 --> 00:12:33,140
och du vill konvertera det
slutligen till maskinen code--

254
00:12:33,140 --> 00:12:37,100
dessa nollor och ettor som
bara din Mac eller PC

255
00:12:37,100 --> 00:12:41,230
understands-- du har en första
foder som källkod i så

256
00:12:41,230 --> 00:12:46,340
insignal till en speciell
program som kallas en kompilator,

257
00:12:46,340 --> 00:12:48,974
vars utgång vi
skall se är maskinkod.

258
00:12:48,974 --> 00:12:51,890
Och faktiskt, sista gången vi pratade
om, egentligen, i slutet av dagen,

259
00:12:51,890 --> 00:12:52,610
problemlösning.

260
00:12:52,610 --> 00:12:53,360
Du har ingångar.

261
00:12:53,360 --> 00:12:54,318
Och du har utgångar.

262
00:12:54,318 --> 00:12:56,560
Och du har fått någon form
av algoritmen i mitten.

263
00:12:56,560 --> 00:12:59,830
>> Algoritmer kan säkert vara
implementeras i programvara,

264
00:12:59,830 --> 00:13:02,900
som vi såg med pseudokod förra veckan
och som vi ser med faktiska koden

265
00:13:02,900 --> 00:13:03,490
Denna vecka.

266
00:13:03,490 --> 00:13:06,430
Och så en kompilator egentligen bara
har en uppsättning av algoritmer inuti

267
00:13:06,430 --> 00:13:10,060
av det som vet hur man
omvandla de särskilda nyckelord,

268
00:13:10,060 --> 00:13:12,180
liknande huvud och printf,
och andra som vi just

269
00:13:12,180 --> 00:13:17,620
såg in i mönster av nollor och
Sådana som Intel Inside och andra processorer

270
00:13:17,620 --> 00:13:20,020
faktiskt förstår.

271
00:13:20,020 --> 00:13:22,460
Så hur gör vi det?

272
00:13:22,460 --> 00:13:24,470
Var får vi en kompilator?

273
00:13:24,470 --> 00:13:26,400
>> De flesta av oss här har en Mac eller en PC.

274
00:13:26,400 --> 00:13:29,152
Och du kör Mac OS, eller
Windows eller Linux eller Solaris,

275
00:13:29,152 --> 00:13:30,860
eller valfritt antal andra
operativsystem.

276
00:13:30,860 --> 00:13:32,568
Och faktiskt, vi kunde
gå ut på banan

277
00:13:32,568 --> 00:13:35,710
och ladda ner en kompilator
för din Mac eller PC

278
00:13:35,710 --> 00:13:37,360
för just ditt operativsystem.

279
00:13:37,360 --> 00:13:39,617
Men vi skulle alla vara på
olika sidor, så att säga.

280
00:13:39,617 --> 00:13:41,450
Vi skulle ha något
olika konfigurationer.

281
00:13:41,450 --> 00:13:43,210
Och det skulle inte fungera i alla fall.

282
00:13:43,210 --> 00:13:45,280
Och, faktiskt, i dessa dagar
många av oss använder inte

283
00:13:45,280 --> 00:13:47,516
programvara som körs bara på våra bärbara datorer.

284
00:13:47,516 --> 00:13:49,390
Istället använder vi något
som en webbläsare som

285
00:13:49,390 --> 00:13:52,930
tillåter oss att komma åt webbaserade
applikationer i molnet.

286
00:13:52,930 --> 00:13:55,630
Och senare den här terminen,
vi kommer att göra just detta.

287
00:13:55,630 --> 00:13:59,660
Vi kommer att skriva program eller
programvara med code-- inte C,

288
00:13:59,660 --> 00:14:02,860
men andra språk som Python och
JavaScript-- som körs i molnet.

289
00:14:02,860 --> 00:14:05,860
>> Och att göra det vi själva
under terminen

290
00:14:05,860 --> 00:14:11,890
faktiskt kommer att använda en molnbaserad
miljö kallas CS50 IDE.

291
00:14:11,890 --> 00:14:16,030
Detta är en webb-baserad programmering
miljö, eller integrerad utveckling

292
00:14:16,030 --> 00:14:20,610
miljö, IDE, som är byggd ovanpå några
öppen källkod kallas Cloud 9.

293
00:14:20,610 --> 00:14:22,966
Och vi har gjort några pedagogiska
förenklingar till det

294
00:14:22,966 --> 00:14:25,840
så att dölja vissa funktioner i
de första veckorna som vi inte behöver,

295
00:14:25,840 --> 00:14:27,770
varefter du kan
avslöjar dem och göra de flesta

296
00:14:27,770 --> 00:14:29,400
vad du vill med miljön.

297
00:14:29,400 --> 00:14:32,470
>> Och det gör oss också till
förinstallera vissa program.

298
00:14:32,470 --> 00:14:35,330
Saker som en så kallad CS50
bibliotek, som vi snart kommer att se

299
00:14:35,330 --> 00:14:39,210
ger oss i C med vissa
ytterligare funktioner.

300
00:14:39,210 --> 00:14:44,392
Så om du går till, i slutändan, CS50.io,
du blir ombedd att logga in,

301
00:14:44,392 --> 00:14:46,350
och när du gör och skapa
ett konto gratis,

302
00:14:46,350 --> 00:14:52,150
du kommer att kunna få tillgång till en
miljö som ser ganska så här.

303
00:14:52,150 --> 00:14:53,760
>> Nu är det i standardläget.

304
00:14:53,760 --> 00:14:55,650
Allt är trevligt och
ljusa på skärmen.

305
00:14:55,650 --> 00:14:57,941
Många av oss har en vana att
arbetar på CS50 pjäs som är

306
00:14:57,941 --> 00:14:59,150
ganska sent in på natten.

307
00:14:59,150 --> 00:15:02,400
Och så några av er kanske föredrar att
förvandla det till nattläge, så att säga.

308
00:15:02,400 --> 00:15:05,550
>> Men i slutändan, vad du är
kommer att se inom CS50 IDE

309
00:15:05,550 --> 00:15:08,340
är tre distinkta areas--
ett område på vänster där

310
00:15:08,340 --> 00:15:12,604
dina filer kommer att vara i
moln, ett område på upp till höger

311
00:15:12,604 --> 00:15:14,270
där koden kommer att vara redigerbara.

312
00:15:14,270 --> 00:15:16,650
Du kommer att kunna öppna
enskilda flikar för alla program

313
00:15:16,650 --> 00:15:19,670
att du skriver den här terminen inne
av det övre högra hörnet.

314
00:15:19,670 --> 00:15:23,070
Och sedan mest arcanely,
och ändå kraftfullt,

315
00:15:23,070 --> 00:15:26,610
kommer att bli den här saken på
botten kallas ett terminalfönster.

316
00:15:26,610 --> 00:15:29,450
>> Detta är en gammal skola
Command Line Interface,

317
00:15:29,450 --> 00:15:32,240
eller CLI tillåter att
du att utföra kommandon

318
00:15:32,240 --> 00:15:35,260
på computer-- i detta fall,
datorn i cloud--

319
00:15:35,260 --> 00:15:39,090
att göra saker som kompilera koden
från källkod till maskinkod,

320
00:15:39,090 --> 00:15:43,600
att köra dina program, eller att starta
webbserver, eller att få tillgång till databasen,

321
00:15:43,600 --> 00:15:47,454
och ett antal andra tekniker
att vi kommer att börja använda kort.

322
00:15:47,454 --> 00:15:49,370
Men för att komma dit, vi är
kommer att faktiskt ha

323
00:15:49,370 --> 00:15:51,240
att gå online och börja spela.

324
00:15:51,240 --> 00:15:54,399
Och att göra det, låt oss först
börja mixtra med huvud,

325
00:15:54,399 --> 00:15:55,940
och skriva den huvudsakliga delen av ett program.

326
00:15:55,940 --> 00:15:59,170
Och låt oss använda denna funktion
printf, som vi använde tidigare,

327
00:15:59,170 --> 00:16:01,050
helt enkelt att säga något.

328
00:16:01,050 --> 00:16:04,910
>> Så här är jag redan inne i CS50 IDE.

329
00:16:04,910 --> 00:16:05,930
Jag har loggat in förväg.

330
00:16:05,930 --> 00:16:07,360
Och jag fullt skärmad fönstret.

331
00:16:07,360 --> 00:16:09,670
Och så slutligen, du
även i kommande problem

332
00:16:09,670 --> 00:16:12,960
kommer att följa liknande steg som
kommer att ge online-dokumentation.

333
00:16:12,960 --> 00:16:16,360
Så du behöver inte oroa sig för
absorbera varje liten teknisk steg

334
00:16:16,360 --> 00:16:17,730
att jag gör här i dag.

335
00:16:17,730 --> 00:16:19,222
>> Men du får en skärm som denna.

336
00:16:19,222 --> 00:16:20,430
Jag råkar vara i nattläge.

337
00:16:20,430 --> 00:16:22,944
Och du kan lysa allt
upp genom att inaktivera nattläge.

338
00:16:22,944 --> 00:16:24,860
Och vid slutet av
dag, du kommer att se

339
00:16:24,860 --> 00:16:30,090
dessa tre huvud areas-- filen
webbläsare till vänster, koden flikar uppe,

340
00:16:30,090 --> 00:16:32,430
och terminalfönstret längst ned.

341
00:16:32,430 --> 00:16:34,890
>> Låt mig gå vidare och
skriva min första program.

342
00:16:34,890 --> 00:16:42,300
Jag ska preemptively gå till Arkiv,
Spara och spara min fil som hej.c.

343
00:16:42,300 --> 00:16:46,850
I själva verket, enligt praxis, ett program vi
skriver som är skrivet i C-språket

344
00:16:46,850 --> 00:16:49,739
ska heta något
dot c, enligt konvention.

345
00:16:49,739 --> 00:16:53,030
Så jag kommer att nämna det hej.c, eftersom
Jag vill bara säga hej till världen.

346
00:16:53,030 --> 00:16:54,820
Nu kommer jag att zooma
ut och klicka på Spara.

347
00:16:54,820 --> 00:16:58,180
Och allt jag har här nu är en flik
där kan jag börja skriva kod.

348
00:16:58,180 --> 00:16:59,490
>> Detta kommer inte att kompilera.

349
00:16:59,490 --> 00:17:00,300
Detta betyder ingenting.

350
00:17:00,300 --> 00:17:02,750
Och så även om jag konverterade
detta till nollor och ettor,

351
00:17:02,750 --> 00:17:05,390
CPU: n kommer att ha någon
aning om vad som händer runt.

352
00:17:05,390 --> 00:17:14,170
Men om jag skriver rader som matchar
med C: s conventions-- C varelse,

353
00:17:14,170 --> 00:17:20,150
igen, language-- detta med syntax som
detta printf hej world-- och jag har

354
00:17:20,150 --> 00:17:22,210
blivit bekväm med
att göra detta över tiden.

355
00:17:22,210 --> 00:17:24,510
Så jag tror inte att jag gjort
eventuella tryckfel.

356
00:17:24,510 --> 00:17:27,910
>> Men alltid, den allra första
gång du gör det, kommer du.

357
00:17:27,910 --> 00:17:31,090
Och vad jag ska göra kan mycket
väl inte fungerar för dig första gången.

358
00:17:31,090 --> 00:17:33,610
Och det är helt OK,
eftersom just nu du

359
00:17:33,610 --> 00:17:37,662
kan bara se en hel del av nyheten,
men med tiden när du bekanta

360
00:17:37,662 --> 00:17:39,870
med denna miljö, och
detta språk, och andra,

361
00:17:39,870 --> 00:17:42,370
du kommer att börja se saker som
är antingen rätt eller fel.

362
00:17:42,370 --> 00:17:44,369
>> Och detta är vad
undervisningsassistenter och kurs

363
00:17:44,369 --> 00:17:48,780
assistenter får så bra på tiden, är
observation misstag eller fel i koden.

364
00:17:48,780 --> 00:17:52,110
Men jag hävdar att det
finns inga fel i denna kod.

365
00:17:52,110 --> 00:17:53,990
Så jag vill nu att köra det här programmet.

366
00:17:53,990 --> 00:17:57,440
>> Nu på min egen Mac eller PC, jag är i
för vana att dubbelklicka på ikonerna

367
00:17:57,440 --> 00:17:59,350
när jag vill köra något program.

368
00:17:59,350 --> 00:18:01,080
Men det är inte modellen här.

369
00:18:01,080 --> 00:18:04,570
I denna miljö, som är CS50 IDE.

370
00:18:04,570 --> 00:18:07,192
Vi använder ett operativsystem
system som kallas Linux.

371
00:18:07,192 --> 00:18:09,900
Linux är påminner om en annan
operativsystem, är allmänt känd

372
00:18:09,900 --> 00:18:10,850
som Unix.

373
00:18:10,850 --> 00:18:16,340
Och Linux är särskilt känd för
med en kommandorad miljö, CLI.

374
00:18:16,340 --> 00:18:20,070
Nu, vi använder en specifik
smak av Linux kallas Ubuntu.

375
00:18:20,070 --> 00:18:22,770
Och Ubuntu är helt enkelt en
viss version av Linux.

376
00:18:22,770 --> 00:18:27,900
>> Men dessa Linux dessa dagar gör faktiskt
komma med grafiska användargränssnitt.

377
00:18:27,900 --> 00:18:30,360
Och vi råkar
att använda här är webbaserat.

378
00:18:30,360 --> 00:18:32,735
Så det kan se ännu en
lite annorlunda från något

379
00:18:32,735 --> 00:18:35,310
du kanske själv har
sett eller köra i det förflutna.

380
00:18:35,310 --> 00:18:37,910
>> Så jag kommer att gå vidare
nu och gör följande.

381
00:18:37,910 --> 00:18:40,950
Jag har sparat den här filen som hej.c.

382
00:18:40,950 --> 00:18:47,350
Jag kommer att gå vidare och
Typ clanghello.c Så Clang

383
00:18:47,350 --> 00:18:49,850
för C-språket är en kompilator.

384
00:18:49,850 --> 00:18:51,952
Det är förinstallerad i CS50 IDE.

385
00:18:51,952 --> 00:18:54,910
Och du kan helt ladda ner och
installera på din egen Mac eller PC.

386
00:18:54,910 --> 00:18:57,910
>> Men, återigen, du skulle inte ha alla
förkonfigurationen gjort för dig.

387
00:18:57,910 --> 00:19:00,940
Så nu är jag bara
kommer att köra clanghello.c.

388
00:19:00,940 --> 00:19:03,240
Och nu märker denna syntax
här kommer så småningom

389
00:19:03,240 --> 00:19:06,930
inse betyder bara att jag är i en
mapp eller katalog som heter arbetsyta.

390
00:19:06,930 --> 00:19:11,030
Denna dollartecken är bara konvention
efter mening, skriver dina kommandon här.

391
00:19:11,030 --> 00:19:14,560
>> Det är vad som kallas en snabb, precis
enligt praxis är dollartecken.

392
00:19:14,560 --> 00:19:19,130
Och om jag går vidare nu och klicka
Ange, inget verkar ha hänt.

393
00:19:19,130 --> 00:19:20,930
Men det är faktiskt en bra sak.

394
00:19:20,930 --> 00:19:23,650
Ju mindre som händer på
skärmen, desto mer sannolikt

395
00:19:23,650 --> 00:19:26,710
koden är att vara korrekt,
åtminstone syntaktiskt.

396
00:19:26,710 --> 00:19:29,120
>> Så om jag vill köra
program, vad ska jag göra?

397
00:19:29,120 --> 00:19:33,770
Tja, visar det sig att den
standardnamn genom konventionen

398
00:19:33,770 --> 00:19:38,854
för program när du inte anger en
namn på programmet är bara a.out.

399
00:19:38,854 --> 00:19:41,270
Och denna syntax också, du
bekanta med kort.

400
00:19:41,270 --> 00:19:47,500
>> Dot slash betyder bara, hej, CS50
IDE, köra ett program som heter a.out

401
00:19:47,500 --> 00:19:49,400
det är i min nuvarande katalog.

402
00:19:49,400 --> 00:19:51,520
Det prick betyder den aktuella katalogen.

403
00:19:51,520 --> 00:19:55,040
Och vi får se vad andra sådana sekvenser
tecken betyder kort.

404
00:19:55,040 --> 00:19:58,430
>> Så här går vi, Enter, hallå världen.

405
00:19:58,430 --> 00:20:00,080
Och du kommer att märka, att det som hände?

406
00:20:00,080 --> 00:20:01,580
Inte bara gjorde det ut Hello World.

407
00:20:01,580 --> 00:20:05,990
Den rörde sig också
markören till nästa rad.

408
00:20:05,990 --> 00:20:07,160
>> Och varför var det?

409
00:20:07,160 --> 00:20:12,400
Vad var den kod som vi skrev innan
att se till att markören skulle

410
00:20:12,400 --> 00:20:14,882
gå på nästa rad?

411
00:20:14,882 --> 00:20:16,840
Lustiga en
dator är det bara att gå

412
00:20:16,840 --> 00:20:18,570
att göra bokstavligen vad du berätta det att göra.

413
00:20:18,570 --> 00:20:26,050
>> Så om du berättar det att printf hej,
kommatecken, utrymme, värld, nära citat,

414
00:20:26,050 --> 00:20:29,090
det är bokstavligen bara gå
att skriva dessa tecken.

415
00:20:29,090 --> 00:20:31,980
Men jag hade denna speciella karaktär
i slutet, minns, bakstreck n.

416
00:20:31,980 --> 00:20:34,230
Och det är vad säker
att karaktären gick

417
00:20:34,230 --> 00:20:36,570
till nästa rad på skärmen.

418
00:20:36,570 --> 00:20:38,097
>> I själva verket, låt mig gå och göra det.

419
00:20:38,097 --> 00:20:39,430
Låt mig gå vidare och radera detta.

420
00:20:39,430 --> 00:20:41,180
Nu märker att
högst upp på skärmen finns

421
00:20:41,180 --> 00:20:42,890
lite rött ljus i
fliken anger,

422
00:20:42,890 --> 00:20:45,047
Hej, har du inte sparat filen.

423
00:20:45,047 --> 00:20:47,880
Så jag kommer att gå vidare med kontroll
S eller kommandot S, spara filen.

424
00:20:47,880 --> 00:20:51,130
Nu goes-- gick för en moment-- grön.

425
00:20:51,130 --> 00:20:53,760
Och nu är det tillbaka till
bara vara en nära ikon.

426
00:20:53,760 --> 00:21:01,860
>> Om jag kör nu clanghello.c igen,
Ange, pricka snedstreck, a.out, Enter,

427
00:21:01,860 --> 00:21:04,110
ser du att det fortfarande fungerade.

428
00:21:04,110 --> 00:21:06,020
Men det är utan tvekan en liten buggy.

429
00:21:06,020 --> 00:21:08,714
Just nu, mitt prompt-- arbetsyta,
och då dollartecken,

430
00:21:08,714 --> 00:21:10,880
och sedan min faktiska prompt--
är alla på samma linje.

431
00:21:10,880 --> 00:21:14,540
Så detta verkligen en estetisk bugg,
även om det är egentligen inte en logisk bugg.

432
00:21:14,540 --> 00:21:16,250
>> Så jag kommer att ångra vad jag gjorde bara.

433
00:21:16,250 --> 00:21:18,560
Jag kommer att köra a.out.

434
00:21:18,560 --> 00:21:22,710
Märker jag har lagt till
radmatningstecken tillbaka.

435
00:21:22,710 --> 00:21:24,280
Jag har sparat filen.

436
00:21:24,280 --> 00:21:31,630
>> Så jag kommer att köra a.out, och--
dammit, en bugg, ett fel som betyder misstag.

437
00:21:31,630 --> 00:21:35,020
Så felet är att även om
Jag har lagt det omvända snedstrecket n där,

438
00:21:35,020 --> 00:21:41,180
re sparade, åter körde programmet,
beteendet var densamma.

439
00:21:41,180 --> 00:21:42,640
Varför skulle det vara?

440
00:21:42,640 --> 00:21:43,910
>> Jag saknar ett steg, eller hur?

441
00:21:43,910 --> 00:21:47,620
Det avgörande steg tidigare var att du har
att-- när du ändrar källkoden,

442
00:21:47,620 --> 00:21:49,610
det visar sig också att köra
det genom kompilatorn

443
00:21:49,610 --> 00:21:51,102
igen så att du får ny maskinkod.

444
00:21:51,102 --> 00:21:52,810
Och maskinkoden,
nollor och ettor,

445
00:21:52,810 --> 00:21:56,260
kommer att vara nästan identiska, men
inte perfekt så, eftersom vi behöver,

446
00:21:56,260 --> 00:21:57,510
naturligtvis, att ny rad.

447
00:21:57,510 --> 00:22:02,640
>> Så för att åtgärda detta, jag kommer att behöva
att köra clanghello.c anger, dot

448
00:22:02,640 --> 00:22:03,800
snedstreck, a.out.

449
00:22:03,800 --> 00:22:08,402
Och nu, hallå världen är tillbaka
där jag förväntar mig att vara.

450
00:22:08,402 --> 00:22:09,610
Så det här är alla fina och bra.

451
00:22:09,610 --> 00:22:13,150
Men a.out är en ganska dum namn för en
programmet, även om det råkar vara,

452
00:22:13,150 --> 00:22:16,530
av historiska skäl
default-- menande monterings utgångar.

453
00:22:16,530 --> 00:22:20,780
>> Men låt mig gå vidare här
och gör detta på olika sätt.

454
00:22:20,780 --> 00:22:24,760
Jag vill ha min Hello World
faktiskt kallas hej.

455
00:22:24,760 --> 00:22:28,320
Så om det vore en ikon på min
skrivbord, skulle det inte vara a.out.

456
00:22:28,320 --> 00:22:29,730
Det skulle kallas hej.

457
00:22:29,730 --> 00:22:33,660
>> Så för att göra detta, visar det sig
att Clang, liksom många program,

458
00:22:33,660 --> 00:22:37,980
stöder kommandoradsargument,
eller flaggor, eller växlar,

459
00:22:37,980 --> 00:22:39,600
som helt enkelt påverka dess beteende.

460
00:22:39,600 --> 00:22:45,160
Specifikt Clang stöder ett streck o
flagga, som sedan tar ett andra ord.

461
00:22:45,160 --> 00:22:48,190
I det här fallet, jag ska godtyckligt,
men rimligen, kalla det hej.

462
00:22:48,190 --> 00:22:50,710
Men jag kan kalla det något
Jag vill, utom a.out, som

463
00:22:50,710 --> 00:22:52,390
skulle vara ganska förutom punkten.

464
00:22:52,390 --> 00:22:55,640
>> Och sedan bara ange namnet
på filen jag vill kompilera.

465
00:22:55,640 --> 00:22:59,190
Så nu även i början
av kommandot jag har fortfarande klang,

466
00:22:59,190 --> 00:23:01,410
i slutet av kommandot
Jag har fortfarande filnamnet,

467
00:23:01,410 --> 00:23:05,520
Jag har nu dessa kommandoraden
argument, dessa flaggor som säger,

468
00:23:05,520 --> 00:23:11,180
Åh, förresten, output-o, en fil
heter hej, inte standard a.out.

469
00:23:11,180 --> 00:23:13,810
>> Så om jag slog in nu, ingenting
verkar ha hänt.

470
00:23:13,810 --> 00:23:17,900
Och ändå, nu kan jag göra punkt snedstreck hej.

471
00:23:17,900 --> 00:23:19,089
Så det är samma program.

472
00:23:19,089 --> 00:23:21,380
De nollor och ettor är
identiska vid slutet av dagen.

473
00:23:21,380 --> 00:23:24,210
>> Men de är i två
annorlunda files-- a.out,

474
00:23:24,210 --> 00:23:26,490
som är den första versionen
och bara dåraktigt namnges,

475
00:23:26,490 --> 00:23:30,250
och nu hej, vilket är en mycket
mer övertygande namn för ett program.

476
00:23:30,250 --> 00:23:33,195
Men, ärligt talat, jag är aldrig
kommer att minnas detta igen,

477
00:23:33,195 --> 00:23:34,070
och igen, och igen.

478
00:23:34,070 --> 00:23:36,411
Och, faktiskt, som vi skriver
mer komplicerade program,

479
00:23:36,411 --> 00:23:38,160
kommandon du är
kommer att behöva skriva

480
00:23:38,160 --> 00:23:40,920
kommer att bli ännu
mer komplicerat fortfarande.

481
00:23:40,920 --> 00:23:41,940
>> Och så att inte oroa dig.

482
00:23:41,940 --> 00:23:46,220
Det visar sig att människor innan
vi har insett att de också

483
00:23:46,220 --> 00:23:47,530
hade denna exakt samma problem.

484
00:23:47,530 --> 00:23:50,900
Även de inte tyckte att behöva
skriver ganska långa, svårbegripliga kommandon,

485
00:23:50,900 --> 00:23:52,200
tala minns dem.

486
00:23:52,200 --> 00:23:56,070
Och så människor före oss har gjort
andra program som gör det lättare

487
00:23:56,070 --> 00:23:57,670
att kompilera programmet.

488
00:23:57,670 --> 00:24:01,609
>> Och, ja, en sådan
Programmet kallas Make.

489
00:24:01,609 --> 00:24:03,150
Så jag kommer att gå vidare och göra det.

490
00:24:03,150 --> 00:24:05,691
Jag kommer att ångra allt jag
bara gjorde på följande sätt.

491
00:24:05,691 --> 00:24:07,690
Låt mig typ LS.

492
00:24:07,690 --> 00:24:10,980
Och du kommer att märka tre saker--
a.out och en stjärna, hej

493
00:24:10,980 --> 00:24:12,810
och en stjärna, och hej.c.

494
00:24:12,810 --> 00:24:14,730
Förhoppningsvis ska detta
vara lite intuitivt,

495
00:24:14,730 --> 00:24:18,220
i den mån som tidigare fanns
ingenting i denna arbetsyta.

496
00:24:18,220 --> 00:24:21,240
Det fanns ingenting som jag hade
skapas förrän vi började klass.

497
00:24:21,240 --> 00:24:22,840
>> Och jag skapade hej.c.

498
00:24:22,840 --> 00:24:24,544
Jag sammanställt sedan, och kallade det a.out.

499
00:24:24,544 --> 00:24:27,460
Och då jag sammanställt det igen något
annorlunda och kallade det hej.

500
00:24:27,460 --> 00:24:32,830
Så jag har tre filer i den här katalogen,
i denna mapp som heter arbetsyta.

501
00:24:32,830 --> 00:24:35,005
Nu kan jag se att såväl
om jag zoomar ut faktiskt.

502
00:24:35,005 --> 00:24:37,530
>> Om jag zoomar ut här och
titta på den övre högra

503
00:24:37,530 --> 00:24:39,940
hörn, som utlovat vänster
sidan av skärmen

504
00:24:39,940 --> 00:24:42,990
alltid kommer att visa dig
vad som finns i ditt konto, vad är

505
00:24:42,990 --> 00:24:44,790
insidan av CS50 IDE.

506
00:24:44,790 --> 00:24:46,680
Och det finns tre filer där.

507
00:24:46,680 --> 00:24:49,070
>> Så jag vill bli av med a.out och hej.

508
00:24:49,070 --> 00:24:51,275
Och som ni kanske
föreställa sig intuitivt, du

509
00:24:51,275 --> 00:24:53,400
kan sortera kontroll klick
eller högerklicka på denna.

510
00:24:53,400 --> 00:24:54,590
Och denna lilla meny dyker upp.

511
00:24:54,590 --> 00:24:57,170
Du kan ladda ner filen, kör
det, förhandsgranska det, uppdatera, byta namn,

512
00:24:57,170 --> 00:24:57,700
eller vad inte.

513
00:24:57,700 --> 00:25:00,260
>> Och jag kan bara ta bort,
och det skulle försvinna.

514
00:25:00,260 --> 00:25:05,260
Men låt oss göra saker med ett kommando
linje för nu, så att få bekväm

515
00:25:05,260 --> 00:25:07,010
med detta, och gör följande.

516
00:25:07,010 --> 00:25:12,345
Jag kommer att gå vidare och ta bort
a.out genom att skriva bokstavligen rma.out.

517
00:25:12,345 --> 00:25:14,890
Det visar sig, kommandot för
ta bort eller radera något,

518
00:25:14,890 --> 00:25:16,280
är inte bort eller radera.

519
00:25:16,280 --> 00:25:21,260
>> Det är mer kortfattat RM, bara för att spara
dig några tangenttryckningar, och tryck på Retur.

520
00:25:21,260 --> 00:25:24,707
Nu ska vi vara något
kryptiskt avlägsna vanlig fil a.out.

521
00:25:24,707 --> 00:25:27,040
Jag vet inte riktigt vad en
oregelbunden fil skulle vara ännu.

522
00:25:27,040 --> 00:25:28,660
Men jag vill ta bort det.

523
00:25:28,660 --> 00:25:30,150
>> Så jag kommer att skriva y för ja.

524
00:25:30,150 --> 00:25:31,940
Eller jag kunde skriva ut, och tryck på Retur.

525
00:25:31,940 --> 00:25:33,440
Och återigen, ingenting verkar hända.

526
00:25:33,440 --> 00:25:35,840
Men det är i allmänhet en bra sak.

527
00:25:35,840 --> 00:25:40,490
>> Om jag skriver LS här gången,
vad ska jag se?

528
00:25:40,490 --> 00:25:44,930
Förhoppningsvis bara hej och hej.c.

529
00:25:44,930 --> 00:25:47,286
Nu, som en sidoreplik, du
märka detta stjärna, asterisk,

530
00:25:47,286 --> 00:25:48,660
det är i slutet av mina program.

531
00:25:48,660 --> 00:25:50,201
Och de visar också upp i grönt.

532
00:25:50,201 --> 00:25:53,970
Det är bara CS50 IDE sätt
av cluing dig till det faktum

533
00:25:53,970 --> 00:25:55,280
att det inte är källkoden.

534
00:25:55,280 --> 00:25:58,880
Det är en körbar, ett körbart
program som du faktiskt kan köra

535
00:25:58,880 --> 00:26:01,020
genom att göra punkt snedstreck, och då är det namn.

536
00:26:01,020 --> 00:26:05,860
>> Låt mig nu gå vidare och ta bort
detta rm hello, Enter, ta bort regelbundna

537
00:26:05,860 --> 00:26:08,010
fil hej, ja.

538
00:26:08,010 --> 00:26:11,180
Och nu om jag skriver LS,
Vi är tillbaka till hej.c.

539
00:26:11,180 --> 00:26:13,917
Försök att inte ta bort din
källkod.

540
00:26:13,917 --> 00:26:16,250
Även om det finns funktioner
inbyggd i CS50 IDE där

541
00:26:16,250 --> 00:26:19,870
Du kan gå igenom din versionshistoriken
och bakåt i tiden om du av misstag

542
00:26:19,870 --> 00:26:23,660
ta bort något, gör vara uppmärksam
enligt dessa uppmaningar ja eller nej,

543
00:26:23,660 --> 00:26:25,381
av vad du verkligen vill göra.

544
00:26:25,381 --> 00:26:27,380
Och om jag går upp till toppen
vänstra hörnet här,

545
00:26:27,380 --> 00:26:30,696
allt som återstår är hej.c.

546
00:26:30,696 --> 00:26:32,570
Så det finns knippen av
andra kommandon som du

547
00:26:32,570 --> 00:26:37,550
kan utföra i en värld av Linux,
varav en är, återigen, Gör.

548
00:26:37,550 --> 00:26:40,180
Och vi kommer att göra
mitt program nu på följande sätt.

549
00:26:40,180 --> 00:26:43,270
>> Istället för att göra klang,
istället för att göra klang-o,

550
00:26:43,270 --> 00:26:45,860
Jag ska helt enkelt
bokstavligen skriver gör hej.

551
00:26:45,860 --> 00:26:49,630
Och nu märker jag
inte skriva göra hej.c.

552
00:26:49,630 --> 00:26:50,910
Jag skriver att hej.

553
00:26:50,910 --> 00:26:54,840
>> Och detta program Gör att
levereras med CS50 IDE, och mer

554
00:26:54,840 --> 00:26:57,090
i allmänhet med Linux,
är ett program som är

555
00:26:57,090 --> 00:26:59,120
kommer att göra ett program som heter Hej.

556
00:26:59,120 --> 00:27:03,680
Och det kommer att ta, enligt konvention,
att om kan göras detta program,

557
00:27:03,680 --> 00:27:09,030
det kommer att göras från en källa
kod fil som slutar i dot c, hej.c.

558
00:27:09,030 --> 00:27:12,210
>> Så om jag slog in nu, märker att
kommandot som blir verk

559
00:27:12,210 --> 00:27:14,340
är faktiskt ännu längre
innan än tidigare.

560
00:27:14,340 --> 00:27:16,670
Och det beror på att vi har
förkonfigurerad CS50 IDE att ha

561
00:27:16,670 --> 00:27:19,878
några extra funktioner inbyggda i det
vi behöver inte ännu, men snart kommer.

562
00:27:19,878 --> 00:27:23,470
Men det viktigaste att inse
är nu jag har en Hello program.

563
00:27:23,470 --> 00:27:27,080
>> Om jag skriver LS igen, jag
har ett hej program.

564
00:27:27,080 --> 00:27:32,070
Och jag kan köra den med
dot slash a.out, nej,

565
00:27:32,070 --> 00:27:35,590
eftersom hela poängen med detta
övningen var dot slash hej.

566
00:27:35,590 --> 00:27:38,089
Och nu har jag min Hello World.

567
00:27:38,089 --> 00:27:39,880
Så framåt,
Vi är nästan alltid bara

568
00:27:39,880 --> 00:27:42,088
kommer att sammanställa våra program
med kommandot Make.

569
00:27:42,088 --> 00:27:45,300
Och sedan ska vi köra dem genom
dot snedstreck, och programmets namn.

570
00:27:45,300 --> 00:27:49,610
Men inse vad som gör gör för
du, är det i sig är inte en kompilator.

571
00:27:49,610 --> 00:27:53,310
Det är bara en bekvämlighet program
som vet hur man utlösa en kompilator

572
00:27:53,310 --> 00:27:56,470
att köra så att du själv kan använda den.

573
00:27:56,470 --> 00:28:00,220
>> Vilka andra kommandon finns i
Linux, och i sin tur CS50 IDE?

574
00:28:00,220 --> 00:28:03,107
Vi kommer snart att se att det finns en
CD kommandot Ändra Directory.

575
00:28:03,107 --> 00:28:05,190
Detta gör att du inom
din kommandoradsgränssnitt

576
00:28:05,190 --> 00:28:07,610
att gå framåt, och tillbaka,
och öppna upp olika mappar

577
00:28:07,610 --> 00:28:08,860
utan att använda musen.

578
00:28:08,860 --> 00:28:12,470
>> LS vi såg, som står för listan
filerna i den aktuella katalogen.

579
00:28:12,470 --> 00:28:14,650
Gör Dir, kan du
nog börja att sluta

580
00:28:14,650 --> 00:28:18,150
vad dessa betyder now-- göra katalog,
Om du vill skapa en mapp.

581
00:28:18,150 --> 00:28:21,270
RM för bort, RM Dir för
avlägsna directory-- och dessa,

582
00:28:21,270 --> 00:28:24,160
igen, är kommandoraden
ekvivalenter av vad du

583
00:28:24,160 --> 00:28:26,945
skulle kunna göra i CS50 IDE med musen.

584
00:28:26,945 --> 00:28:28,820
Men du kommer snart att finna
som ibland är det bara

585
00:28:28,820 --> 00:28:30,610
en mycket snabbare att göra
saker med ett tangentbord,

586
00:28:30,610 --> 00:28:33,690
och i slutändan en mycket mer kraftfull.

587
00:28:33,690 --> 00:28:36,440
>> Men det är svårt att hävda att
allt vi har gjort hittills

588
00:28:36,440 --> 00:28:39,990
är allt som kraftfull, när alla
vi har sagt är, hallå världen.

589
00:28:39,990 --> 00:28:43,740
Och, faktiskt, hårdkodad jag den
ord hej världen i mitt program.

590
00:28:43,740 --> 00:28:45,530
Det finns ingen dynamik ännu.

591
00:28:45,530 --> 00:28:49,320
Scratch var en storleksordning
mer intressant förra veckan.

592
00:28:49,320 --> 00:28:51,220
>> Och så låt oss komma dit.

593
00:28:51,220 --> 00:28:55,310
Låt oss ta ett steg mot att genom
sätt att en del av dessa funktioner.

594
00:28:55,310 --> 00:28:59,470
Så inte bara C kommer med printf,
och klasar av andra funktioner

595
00:28:59,470 --> 00:29:01,850
varav en del kan vi se
över tiden, det gör det inte

596
00:29:01,850 --> 00:29:05,760
göra det så lätt rätt ut
av grinden i att få användarinmatning.

597
00:29:05,760 --> 00:29:08,140
>> I själva verket en av svagheterna
av språk som C,

598
00:29:08,140 --> 00:29:10,140
och även Java och ändå
andra, är att den inte

599
00:29:10,140 --> 00:29:15,860
gör det lätt att bara få saker som
heltal från användare, eller strängar, ord,

600
00:29:15,860 --> 00:29:19,970
och fraser, för att inte tala saker som
flyttalsvärden, eller reella tal

601
00:29:19,970 --> 00:29:23,240
med decimaler, och verkligen
långa tal, som vi snart kommer att se.

602
00:29:23,240 --> 00:29:27,000
Så denna lista över funktioner här, dessa
är som andra Scratch pusselbitar

603
00:29:27,000 --> 00:29:31,090
att vi har förinstallerade i CS50
IDE som vi kommer att använda för ett par veckor

604
00:29:31,090 --> 00:29:34,010
som stödhjul av olika slag, och
så småningom ta bort dem, och se

605
00:29:34,010 --> 00:29:37,210
under huven, kanske, vid
hur dessa saker genomförs.

606
00:29:37,210 --> 00:29:40,460
>> Men för att göra detta, låt oss
faktiskt skriva ett program.

607
00:29:40,460 --> 00:29:41,770
Låt mig gå vidare nu.

608
00:29:41,770 --> 00:29:44,750
Och jag kommer att skapa en ny
fil genom att klicka på denna lilla plus,

609
00:29:44,750 --> 00:29:45,970
och klicka på Ny fil.

610
00:29:45,970 --> 00:29:49,250
>> Jag kommer att spara nästa
en som, låt oss säga, string.c,

611
00:29:49,250 --> 00:29:50,750
eftersom jag vill spela med strängar.

612
00:29:50,750 --> 00:29:53,990
Och sträng i C är bara
en sekvens av tecken.

613
00:29:53,990 --> 00:29:56,090
Så låt oss nu gå vidare
och gör följande.

614
00:29:56,090 --> 00:30:01,204
>> Inkludera standard IO.h-- och
det visar sig standard IO,

615
00:30:01,204 --> 00:30:03,360
IO är bara ingång och utgång.

616
00:30:03,360 --> 00:30:05,920
Så visar det sig att
denna linje här är vad

617
00:30:05,920 --> 00:30:08,140
är grann oss att använda printf.

618
00:30:08,140 --> 00:30:10,410
Printf naturligtvis producerar utgång.

619
00:30:10,410 --> 00:30:15,000
Så för att använda printf, visar det
ut måste du ha den här kodraden

620
00:30:15,000 --> 00:30:16,040
högst upp på filen.

621
00:30:16,040 --> 00:30:18,456
>> Och vi ska återkomma till vad
som verkligen betyder inom kort.

622
00:30:18,456 --> 00:30:20,400
Det visar sig att i
någon C-program jag skriver,

623
00:30:20,400 --> 00:30:23,640
I got att starta den med
kod som ser ut så här.

624
00:30:23,640 --> 00:30:26,860
Och du kommer att märka CS50 IDE, och
andra integrerad utveckling

625
00:30:26,860 --> 00:30:30,050
miljöer som det,
kommer att försöka så gott

626
00:30:30,050 --> 00:30:31,780
de kan för att avsluta din tanke.

627
00:30:31,780 --> 00:30:35,930
I själva verket, en stund sedan om jag ångra
vad jag gjorde, jag trycker på Retur.

628
00:30:35,930 --> 00:30:39,160
>> Jag sedan slog öppna lockigt
stag, tryck på Retur igen.

629
00:30:39,160 --> 00:30:40,430
Och det slutade min tanke.

630
00:30:40,430 --> 00:30:45,140
Det gav mig en ny linje, indragen inte mindre
för fina stilistiska skäl som vi får se.

631
00:30:45,140 --> 00:30:48,559
Och sedan gav mig automatiskt
att klammerparentes att avsluta min tanke.

632
00:30:48,559 --> 00:30:50,600
Nu gör det inte alltid
gissa vad du vill göra.

633
00:30:50,600 --> 00:30:53,620
Men till stor del, gör det
spara några knapptryckningar.

634
00:30:53,620 --> 00:30:59,560
Så för en stund sedan, körde vi här program--
hej, värld, och sedan sammanställt det,

635
00:30:59,560 --> 00:31:00,460
och sedan körde den.

636
00:31:00,460 --> 00:31:01,867
Men det finns ingen dynamik här.

637
00:31:01,867 --> 00:31:03,700
Vad händer om vi ville
göra något annat?

638
00:31:03,700 --> 00:31:07,630
Tja, vad händer om jag ville faktiskt
få en sträng från användaren?

639
00:31:07,630 --> 00:31:11,250
Jag kommer att använda en pusselbit
kallas exakt that-- få sträng.

640
00:31:11,250 --> 00:31:15,860
>> Det visade sig i C att när du inte vill
att bidra till en pusselbit,

641
00:31:15,860 --> 00:31:19,360
eller mer korrekt till en funktion, du
bokstavligen bara göra öppna parentes,

642
00:31:19,360 --> 00:31:20,430
nära parentes.

643
00:31:20,430 --> 00:31:25,540
Så det är som om det finns
ingen vit ruta för att skriva in.

644
00:31:25,540 --> 00:31:27,720
Den säga blocket före
hade en liten vit ruta.

645
00:31:27,720 --> 00:31:29,660
Vi har inte den vita rutan nu.

646
00:31:29,660 --> 00:31:33,310
>> Men när jag ringer få sträng, jag
vill sätta resultatet någonstans.

647
00:31:33,310 --> 00:31:37,680
Så ett mycket vanligt paradigm i C är att
anropa en funktion, som få sträng här,

648
00:31:37,680 --> 00:31:41,070
och sedan lagra dess returvärde.

649
00:31:41,070 --> 00:31:44,450
Det är resultatet av sin
ansträngning i något.

650
00:31:44,450 --> 00:31:47,630
>> Och vad är det
konstruera i programmering,

651
00:31:47,630 --> 00:31:53,450
vare sig början eller nu C, att vi
kan använda för att faktiskt lagra något?

652
00:31:53,450 --> 00:31:55,990
Kallade det en variabel, eller hur?

653
00:31:55,990 --> 00:32:00,320
Och i Scratch, gör vi inte riktigt
bry sig om vad som pågick i variabler.

654
00:32:00,320 --> 00:32:02,170
>> Men i det här fallet, vi faktiskt gör.

655
00:32:02,170 --> 00:32:03,719
Jag kommer att säga sträng.

656
00:32:03,719 --> 00:32:05,510
Och då kunde jag ringa
detta vad jag vill.

657
00:32:05,510 --> 00:32:08,340
Jag kommer att kalla det
namn, blir få sträng.

658
00:32:08,340 --> 00:32:10,250
>> Och nu även om du är
lite ny på detta,

659
00:32:10,250 --> 00:32:11,984
märker att jag saknar någon detalj.

660
00:32:11,984 --> 00:32:13,150
Jag glömmer ett semikolon.

661
00:32:13,150 --> 00:32:14,400
Jag måste avsluta denna tanke.

662
00:32:14,400 --> 00:32:17,480
Så jag kommer att flytta min markör,
och slog semikolon där.

663
00:32:17,480 --> 00:32:19,130
Och vad har jag just gjort?

664
00:32:19,130 --> 00:32:21,440
I den här kodraden,
nummer fem just nu,

665
00:32:21,440 --> 00:32:23,799
Jag ringer få sträng utan ingångar.

666
00:32:23,799 --> 00:32:26,090
Så det finns ingen liten vit
rutan som Spara blocket har.

667
00:32:26,090 --> 00:32:28,590
>> Jag säger bara, hej,
dator, ge mig en sträng.

668
00:32:28,590 --> 00:32:31,390
Likhetstecknet är inte riktigt
ett likhetstecken, per se.

669
00:32:31,390 --> 00:32:33,790
Det är uppdraget
operatör, vilket innebär,

670
00:32:33,790 --> 00:32:37,860
hej, dator, flytta värdet
från höger åt vänster.

671
00:32:37,860 --> 00:32:40,480
Och i den vänstra, jag har följande.

672
00:32:40,480 --> 00:32:43,580
>> Hej, dator, ge mig en string--
en sekvens av tecken.

673
00:32:43,580 --> 00:32:45,637
Och kalla det strängnamn.

674
00:32:45,637 --> 00:32:47,220
Och jag behöver inte ens kalla det namn.

675
00:32:47,220 --> 00:32:49,970
>> Jag skulle kunna kalla det konventionellt,
något i stil med S,

676
00:32:49,970 --> 00:32:52,900
mycket som vi brukade jag
call variabeln i.

677
00:32:52,900 --> 00:32:54,829
Men nu måste jag göra något med det.

678
00:32:54,829 --> 00:32:57,370
Det skulle vara ganska dumt att
försöka sammanställa denna kod körs

679
00:32:57,370 --> 00:32:59,410
detta program, även om
Jag får en sträng,

680
00:32:59,410 --> 00:33:01,580
eftersom det är fortfarande bara
kommer att säga hej världen.

681
00:33:01,580 --> 00:33:06,140
>> Men vad händer om jag vill ändra på detta.

682
00:33:06,140 --> 00:33:07,940
Varför gör jag inte det?

683
00:33:07,940 --> 00:33:11,632
Procent s, kommatecken s.

684
00:33:11,632 --> 00:33:13,090
Och detta är en liten kryptisk stilla.

685
00:33:13,090 --> 00:33:15,560
>> Så låt mig göra mina variabler tydligare.

686
00:33:15,560 --> 00:33:17,510
Låt mig nämna detta variabelnamn.

687
00:33:17,510 --> 00:33:20,230
Och låt oss se om vi inte kan reta
förutom vad som händer här.

688
00:33:20,230 --> 00:33:22,770
>> Så på linje fem, jag får en sträng.

689
00:33:22,770 --> 00:33:25,620
Och jag lagra strängen,
vad användaren har skrivit i

690
00:33:25,620 --> 00:33:28,430
på hans eller hennes tangentbord,
i en variabel som heter namn.

691
00:33:28,430 --> 00:33:30,590
Och det visar sig att
printf inte bara

692
00:33:30,590 --> 00:33:34,220
ta ett argument i dubbel
citationstecken, en ingång i citattecken.

693
00:33:34,220 --> 00:33:39,100
>> Det kan ta två eller tre, eller mer, till exempel
att den andra, eller tredje, eller fjärde,

694
00:33:39,100 --> 00:33:42,320
är alla namn på variabler,
eller specifikt värden,

695
00:33:42,320 --> 00:33:48,610
som du vill ansluta till,
dynamiskt, att sträng inom citationstecken.

696
00:33:48,610 --> 00:33:52,110
Med andra ord, vad
skulle vara fel med detta?

697
00:33:52,110 --> 00:33:57,920
Om jag sa bara hej namn, bakstreck
n, räddade min fil, sammanställt min kod,

698
00:33:57,920 --> 00:34:01,660
och sprang detta, vad skulle hända?

699
00:34:01,660 --> 00:34:05,139
>> Det är bara att säga, hej
namnge, bokstavligen N-A-M-E,

700
00:34:05,139 --> 00:34:07,900
som är typ av dum eftersom
det är inte skiljer sig från världen.

701
00:34:07,900 --> 00:34:10,400
Så allt inom citationstecken är
vad bokstavligen blir tryckt.

702
00:34:10,400 --> 00:34:12,520
Så om jag vill ha
en platshållare där,

703
00:34:12,520 --> 00:34:14,422
Jag behöver faktiskt använda
några speciella syntax.

704
00:34:14,422 --> 00:34:17,380
Och det visar sig om man läser
dokumentation för printf funktion,

705
00:34:17,380 --> 00:34:21,320
Det kommer att säga att
om du använder procent s,

706
00:34:21,320 --> 00:34:23,920
du kan ersätta ett värde enligt följande.

707
00:34:23,920 --> 00:34:27,190
>> Efter ett kommatecken efter det
dubbla citattecken, du helt enkelt

708
00:34:27,190 --> 00:34:29,179
skriva namnet på
variabel som du vill

709
00:34:29,179 --> 00:34:33,790
att ansluta till det formatet
kod, eller format specifice,

710
00:34:33,790 --> 00:34:35,469
procent är för stråkar.

711
00:34:35,469 --> 00:34:39,190
Och nu om jag har sparat min fil,
Jag går tillbaka till min terminal.

712
00:34:39,190 --> 00:34:42,870
Och jag skriver Gör String,
eftersom, återigen, namnet på denna

713
00:34:42,870 --> 00:34:45,510
fil som jag valde tidigare är string.c.

714
00:34:45,510 --> 00:34:48,510
>> Så jag kommer att säga Gör String anger.

715
00:34:48,510 --> 00:34:51,550
Åh herregud, titta på alla
de misstag vi har gjort redan.

716
00:34:51,550 --> 00:34:55,540
Och detta är-- vad detta är verkligen
som en sex, sju linje program?

717
00:34:55,540 --> 00:34:57,790
Så det är där det kan mycket
snabbt få överväldigande.

718
00:34:57,790 --> 00:35:00,890
>> Denna terminalfönster har
nu bara regurgitated

719
00:35:00,890 --> 00:35:03,230
ett stort antal felmeddelanden.

720
00:35:03,230 --> 00:35:07,560
Visst, jag har inte mer fel
meddelanden än jag har rader kod.

721
00:35:07,560 --> 00:35:08,680
Så vad är det som händer?

722
00:35:08,680 --> 00:35:10,920
>> Tja, den bästa strategin
att göra när du

723
00:35:10,920 --> 00:35:13,710
inte stöter på ett överväldigande
lista över fel som detta,

724
00:35:13,710 --> 00:35:16,690
är rulla tillbaka, leta efter kommandot
du bara sprang, som i mitt fall

725
00:35:16,690 --> 00:35:18,020
är att göra sträng.

726
00:35:18,020 --> 00:35:21,630
Titta på vad gör gjorde, och det är att
lång klang kommando, no big deal där.

727
00:35:21,630 --> 00:35:22,950
>> Men den röda är dåligt.

728
00:35:22,950 --> 00:35:24,750
Grön försöker vara
mild och hjälpsam.

729
00:35:24,750 --> 00:35:26,140
Men det är fortfarande dåligt, i det här fallet.

730
00:35:26,140 --> 00:35:27,510
Men där är det dåligt?

731
00:35:27,510 --> 00:35:31,450
>> String.c, linje fem, tecken fem.

732
00:35:31,450 --> 00:35:32,930
Så det här är bara sunt konvention.

733
00:35:32,930 --> 00:35:36,060
Något kolon något betyder
radnummer och teckennummer.

734
00:35:36,060 --> 00:35:41,080
Fel användning av odeklarerat
identifierarsträng.

735
00:35:41,080 --> 00:35:42,900
Menade du standard?

736
00:35:42,900 --> 00:35:45,530
>> Så tyvärr Clang
försöker vara till hjälp.

737
00:35:45,530 --> 00:35:46,850
Men det är fel, i det här fallet.

738
00:35:46,850 --> 00:35:49,350
Nej, Clang, jag menade inte standard IO.

739
00:35:49,350 --> 00:35:51,070
Jag menade att på linje ett, ja.

740
00:35:51,070 --> 00:35:53,420
>> Men linjen fem är detta en här.

741
00:35:53,420 --> 00:35:57,040
Och Clang inte
förstå S-T-R-I-N-G.

742
00:35:57,040 --> 00:36:01,490
Det är en svart identifierare, en
Ordet det bara aldrig har sett förut.

743
00:36:01,490 --> 00:36:05,730
Och det beror på C språk
vi skriver kod i just nu,

744
00:36:05,730 --> 00:36:08,070
inte har variabler som kallas strängar.

745
00:36:08,070 --> 00:36:11,380
>> Det gör inte som standard, stöd
något som kallas en sträng.

746
00:36:11,380 --> 00:36:16,750
Det är en CS50 bit
jargong, men mycket vanlig.

747
00:36:16,750 --> 00:36:18,600
Men jag kan fixa detta på följande sätt.

748
00:36:18,600 --> 00:36:22,090
>> Om jag lägger en kodrad
till toppen av detta program,

749
00:36:22,090 --> 00:36:27,890
inkluderar CS50.h, som är en annan fil
någonstans inne i CS50 IDE, någonstans

750
00:36:27,890 --> 00:36:30,820
på hårddisken, så att säga,
av operativsystemet Ubuntu

751
00:36:30,820 --> 00:36:33,590
att jag kör, att
är den fil som är

752
00:36:33,590 --> 00:36:38,740
ska lära drifts
systemet vad en sträng är bara

753
00:36:38,740 --> 00:36:41,930
som standard io.h är filen
i operativsystemet som är

754
00:36:41,930 --> 00:36:44,430
kommer att lära den vad printf är.

755
00:36:44,430 --> 00:36:46,810
>> I själva verket skulle vi ha fått
en mycket liknande meddelande

756
00:36:46,810 --> 00:36:50,600
om IO hade erkänt standard
Io.h och försökte använda printf.

757
00:36:50,600 --> 00:36:53,632
Så jag kommer att gå vidare och bara
ta kontroll L att rensa skärmen.

758
00:36:53,632 --> 00:36:56,340
Eller du kan skriva klart och det kommer
bara rensa terminalfönstret.

759
00:36:56,340 --> 00:36:58,020
Men du kan fortfarande bläddra tillbaka i tiden.

760
00:36:58,020 --> 00:37:01,100
>> Och jag kommer att köra Gör String.

761
00:37:01,100 --> 00:37:03,660
Tummarna den här gången, Enter.

762
00:37:03,660 --> 00:37:05,380
Herregud, det fungerade.

763
00:37:05,380 --> 00:37:09,280
Det visar mig en lång kryptisk kommando
det är vad som gör genereras via klang,

764
00:37:09,280 --> 00:37:10,460
men inga felmeddelanden.

765
00:37:10,460 --> 00:37:12,460
Så inser, trots att
du kan få helt

766
00:37:12,460 --> 00:37:14,480
överväldigad med
antal felmeddelanden,

767
00:37:14,480 --> 00:37:17,540
det bara kan vara så här irriterande cascading
effekt, där klang inte förstår

768
00:37:17,540 --> 00:37:19,620
en sak, vilket betyder att det därefter
förstår inte nästa ord,

769
00:37:19,620 --> 00:37:20,560
eller på nästa rad.

770
00:37:20,560 --> 00:37:22,850
Och så bara drosslar på din kod.

771
00:37:22,850 --> 00:37:24,440
Men fix kan vara enkelt.

772
00:37:24,440 --> 00:37:27,822
Och så alltid fokusera på
allra första raden av produktionen.

773
00:37:27,822 --> 00:37:29,530
Och om du inte
förstår det, titta bara

774
00:37:29,530 --> 00:37:32,480
för sökord som kan vara
ledtrådar, och linjenummer,

775
00:37:32,480 --> 00:37:34,650
och karaktär, där
det misstaget kan vara.

776
00:37:34,650 --> 00:37:40,328
>> Låt mig nu gå vidare och skriva
dot slash, sträng, anger.

777
00:37:40,328 --> 00:37:44,340
Hm, det är inte att säga hej någonting.

778
00:37:44,340 --> 00:37:46,210
Varför?

779
00:37:46,210 --> 00:37:48,170
Tja, minns, var det igång?

780
00:37:48,170 --> 00:37:53,730
>> Det är antagligen fastnat för tillfället
i en slinga, om man så vill, på rad sex,

781
00:37:53,730 --> 00:37:56,950
eftersom Få String av design,
skriven av CS50 personal,

782
00:37:56,950 --> 00:38:00,350
bokstavligen tänkt att bara sitta
det väntar och väntar,

783
00:38:00,350 --> 00:38:01,850
och väntar på en sträng.

784
00:38:01,850 --> 00:38:03,792
Allt vi menar med sträng är mänskligt ingång.

785
00:38:03,792 --> 00:38:04,500
Så du vet vad?

786
00:38:04,500 --> 00:38:05,166
Låt mig gå vidare.

787
00:38:05,166 --> 00:38:08,704
Och bara på ett infall, låt mig
skriver mitt namn, David, anger.

788
00:38:08,704 --> 00:38:10,120
Nu har jag ett mer dynamiskt program.

789
00:38:10,120 --> 00:38:11,240
Det sade hej David.

790
00:38:11,240 --> 00:38:16,280
>> Om jag går vidare och köra igen,
Låt mig försöka säga Zamila namn anger.

791
00:38:16,280 --> 00:38:17,940
Och nu har vi ett dynamiskt program.

792
00:38:17,940 --> 00:38:19,380
Jag har inte hårdkodad världen.

793
00:38:19,380 --> 00:38:21,760
Jag har inte hårdkodad
namn, eller David, eller Zamila.

794
00:38:21,760 --> 00:38:25,350
>> Nu är det mycket mer som programmen
vi vet, där om det ta input,

795
00:38:25,350 --> 00:38:27,870
den producerar något annorlunda utgång.

796
00:38:27,870 --> 00:38:31,020
Nu är detta inte den bästa
användarupplevelse, eller UX.

797
00:38:31,020 --> 00:38:33,000
Jag kör programmet.

798
00:38:33,000 --> 00:38:35,830
>> Jag vet inte vad jag ska
att göra, om jag ser faktiskt på

799
00:38:35,830 --> 00:38:37,290
eller komma ihåg källkoden.

800
00:38:37,290 --> 00:38:39,640
Så låt oss göra användaren
upplever lite bättre

801
00:38:39,640 --> 00:38:41,240
med de enklaste av saker.

802
00:38:41,240 --> 00:38:44,782
Låt mig gå tillbaka till detta
program, och helt enkelt säga printf.

803
00:38:44,782 --> 00:38:48,870
>> Och låt mig gå vidare och säga namn, kolon,
och ett utrymme, och sedan ett semikolon.

804
00:38:48,870 --> 00:38:51,170
Och bara för sparkar, inget glapp n.

805
00:38:51,170 --> 00:38:52,980
Och det är avsiktligt,
eftersom jag inte vill

806
00:38:52,980 --> 00:38:54,590
uppmaningen att flytta till nästa rad.

807
00:38:54,590 --> 00:38:58,800
>> Jag vill i stället göra detta, gör sträng
kompilera min kod till ny maskin

808
00:38:58,800 --> 00:39:00,980
kod dot slash sträng.

809
00:39:00,980 --> 00:39:02,460
Ah, det är mycket sötare.

810
00:39:02,460 --> 00:39:05,780
Nu vet jag faktiskt vad datorn
vill att jag ska göra, ge den ett namn.

811
00:39:05,780 --> 00:39:10,020
>> Så jag kommer att gå vidare och skriva
i Rob, komma in, och hej, Rob.

812
00:39:10,020 --> 00:39:13,640
Så, inser, detta är fortfarande, i slutet
av dagen, endast en nio raden program.

813
00:39:13,640 --> 00:39:15,090
Men vi har tagit dessa baby steg.

814
00:39:15,090 --> 00:39:18,380
>> Vi skrev en linje som vi
var bekant, printf, hallå världen.

815
00:39:18,380 --> 00:39:19,980
Sedan knäppte vi en liten bit av det.

816
00:39:19,980 --> 00:39:21,560
Och vi faktiskt används get sträng.

817
00:39:21,560 --> 00:39:23,362
Och vi kastade detta värde i en variabel.

818
00:39:23,362 --> 00:39:26,070
Och sedan gick vi vidare och förbättras
det ytterligare med en tredje linje.

819
00:39:26,070 --> 00:39:29,220
Och detta iterativ process av
skriva programvara är verkligen nyckeln.

820
00:39:29,220 --> 00:39:33,420
I CS50 och i livet i allmänhet,
du bör i allmänhet inte sitta ner,

821
00:39:33,420 --> 00:39:36,800
har ett program i åtanke, och försök att skriva
hela jävla sak på en gång.

822
00:39:36,800 --> 00:39:40,810
>> Det kommer oundvikligen att leda till sätt
fler fel än vad vi själva såg här.

823
00:39:40,810 --> 00:39:44,070
Även jag, i dag, hela tiden
göra andra dumma misstag,

824
00:39:44,070 --> 00:39:47,480
är faktiskt hårdare misstag
som är svårare att räkna ut.

825
00:39:47,480 --> 00:39:52,095
Men du kommer att göra fler misstag desto mer
rader kod du skriver på en gång.

826
00:39:52,095 --> 00:39:54,220
Och så denna praxis,
skriva lite kod

827
00:39:54,220 --> 00:39:57,930
att du känner dig bekväm med, sammanställa
det, kör den, testa den mer allmänt,

828
00:39:57,930 --> 00:40:01,370
sedan flytta on-- så precis som vi höll
skiktning och skiktning i förra veckan,

829
00:40:01,370 --> 00:40:04,190
byggnad från något mycket
enkel att något mer komplext,

830
00:40:04,190 --> 00:40:05,200
göra samma sak här.

831
00:40:05,200 --> 00:40:08,500
Inte sitta ner och försöka
skriva en hel problem.

832
00:40:08,500 --> 00:40:10,780
Faktiskt ta dessa små steg.

833
00:40:10,780 --> 00:40:15,100
>> Nu, strängar är inte alla
att användbara sig själva.

834
00:40:15,100 --> 00:40:18,210
Vi skulle faktiskt, helst som till
har något annat i vår verktygslåda.

835
00:40:18,210 --> 00:40:20,990
Så låt oss faktiskt göra just detta.

836
00:40:20,990 --> 00:40:24,900
>> Låt mig gå vidare nu och piska upp
något annat program.

837
00:40:24,900 --> 00:40:28,320
Och vi kallar detta int.c för heltal.

838
00:40:28,320 --> 00:40:30,870
Jag ska, på samma sätt,
inkluderar CS550.h.

839
00:40:30,870 --> 00:40:33,060
Jag kommer att inkludera standard IO.

840
00:40:33,060 --> 00:40:36,630
Och det kommer att bli ganska vanligt
i de första dagarna av klassen.

841
00:40:36,630 --> 00:40:39,050
>> Och jag ska redo
själv med en huvudfunktion.

842
00:40:39,050 --> 00:40:43,370
Och nu i stället för att få en sträng,
låt oss gå vidare och få en int.

843
00:40:43,370 --> 00:40:49,285
Låt oss kalla det i, och kallar det får
int, nära parens, semikolon.

844
00:40:49,285 --> 00:40:51,410
Och nu ska vi göra
något med det, printf.

845
00:40:51,410 --> 00:40:56,190
>> Låt oss säga något i stil
hello, omvänt snedstreck n, komma i.

846
00:40:56,190 --> 00:41:00,010
Så jag ganska mycket härma
vad jag gjorde nyss.

847
00:41:00,010 --> 00:41:01,660
Jag har en platshållare här.

848
00:41:01,660 --> 00:41:05,150
Jag har kommatecken jag här, eftersom jag vill
att plugga i in i den platshållare.

849
00:41:05,150 --> 00:41:07,250
>> Så låt oss gå vidare och prova
sammanställa detta program.

850
00:41:07,250 --> 00:41:10,060
Filen heter int.c.

851
00:41:10,060 --> 00:41:12,920
Så jag kommer att säga, gör int anger.

852
00:41:12,920 --> 00:41:16,420
Herregud, men ingen big deal, rätt?

853
00:41:16,420 --> 00:41:17,230
Det är ett misstag.

854
00:41:17,230 --> 00:41:19,810
>> Det finns en syntaktisk misstag
här så att programmet kan inte

855
00:41:19,810 --> 00:41:25,460
sammanställas i int.c, linje
sju, tecken 27, fel format

856
00:41:25,460 --> 00:41:28,400
anger typ char
stjärna, vad det nu är.

857
00:41:28,400 --> 00:41:30,020
Men typ argumentet är int.

858
00:41:30,020 --> 00:41:33,110
>> Så även här, vi kommer inte att--
även om dagens är en hel del material,

859
00:41:33,110 --> 00:41:35,710
vi kommer att överväldiga dig med
absolut alla funktioner i C,

860
00:41:35,710 --> 00:41:38,070
och programmering mer generellt,
i just dessa första veckorna.

861
00:41:38,070 --> 00:41:40,400
Så det är ofta kommer att vara jargong
som du inte känner.

862
00:41:40,400 --> 00:41:43,350
Och, i själva verket är char stjärn något
vi kommer att komma tillbaka till

863
00:41:43,350 --> 00:41:44,830
om en vecka eller två tid.

864
00:41:44,830 --> 00:41:47,530
>> Men nu, låt oss se om vi kan
tolka ord som är bekanta.

865
00:41:47,530 --> 00:41:50,750
Format-- så vi hört format
specifice, format kod innan.

866
00:41:50,750 --> 00:41:51,840
Det är välbekant.

867
00:41:51,840 --> 00:41:53,840
Motortyp- men argumentet har typen int.

868
00:41:53,840 --> 00:41:55,980
Vänta en minut, är i en int.

869
00:41:55,980 --> 00:41:59,230
>> Kanske procent s faktiskt
har vissa definierade betydelsen.

870
00:41:59,230 --> 00:42:00,230
Och faktiskt, det gör det.

871
00:42:00,230 --> 00:42:03,101
Ett heltal, om du vill
printf att ersätta det,

872
00:42:03,101 --> 00:42:05,350
du faktiskt måste använda en
olika format specifikation.

873
00:42:05,350 --> 00:42:06,890
Och du skulle inte veta detta
såvida inte någon sagt,

874
00:42:06,890 --> 00:42:07,973
eller om du hade gjort det tidigare.

875
00:42:07,973 --> 00:42:10,490
Men procent i är vad
kan vanligen används

876
00:42:10,490 --> 00:42:12,240
i printf för att koppla in ett heltal.

877
00:42:12,240 --> 00:42:14,920
Du kan också använda procent
d för decimal heltal.

878
00:42:14,920 --> 00:42:16,490
Men jag är trevlig och enkel här.

879
00:42:16,490 --> 00:42:17,590
Så vi ska gå med det.

880
00:42:17,590 --> 00:42:21,160
>> Låt mig nu gå vidare och
repris gör int, Enter.

881
00:42:21,160 --> 00:42:23,328
Det är bra, inga fel.

882
00:42:23,328 --> 00:42:27,260
Dot slash int-- OK, dålig användarupplevelse,
eftersom jag inte har sagt mig

883
00:42:27,260 --> 00:42:27,760
vad ska man göra.

884
00:42:27,760 --> 00:42:28,426
Men det är bra.

885
00:42:28,426 --> 00:42:29,480
Jag fånga den snabbt.

886
00:42:29,480 --> 00:42:36,260
>> Och låt mig nu gå vidare och
skriver i David, OK, Zamila, Rob.

887
00:42:36,260 --> 00:42:37,820
OK, så det är en bra sak.

888
00:42:37,820 --> 00:42:41,710
Den här gången, jag använder en funktion,
en pusselbit, som kallas få int.

889
00:42:41,710 --> 00:42:44,230
Och det visar out-- och vi ska
se detta senare i term--

890
00:42:44,230 --> 00:42:47,730
den CS50 personal har genomfört
få sträng på ett sådant sätt

891
00:42:47,730 --> 00:42:50,350
att det kommer bara fysiskt
få en sträng för dig.

892
00:42:50,350 --> 00:42:54,340
>> Det har genomfört get int i
ett sådant sätt att det kommer bara

893
00:42:54,340 --> 00:42:55,590
få ett heltal för dig.

894
00:42:55,590 --> 00:42:57,830
Och om du är människa,
inte samarbetar, är det

895
00:42:57,830 --> 00:43:00,590
bokstavligen bara gå till
säger försöka igen, försöka igen, försöka igen,

896
00:43:00,590 --> 00:43:05,200
bokstavligen sitter där looping, tills
du tvinga med något magiskt nummer,

897
00:43:05,200 --> 00:43:07,670
som 50, och hej 50.

898
00:43:07,670 --> 00:43:11,440
>> Eller om vi köra igen
och skriv in 42, hello 42.

899
00:43:11,440 --> 00:43:15,750
Och så get int
insidan av att pusselbit

900
00:43:15,750 --> 00:43:19,050
är tillräckligt logik, tillräckligt tanke,
att räkna ut, vad är ett ord?

901
00:43:19,050 --> 00:43:20,330
Och vad är ett nummer?

902
00:43:20,330 --> 00:43:23,165
Endast acceptera, i slutändan, siffror.

903
00:43:23,165 --> 00:43:25,690

904
00:43:25,690 --> 00:43:30,230
>> Så visar det sig att detta
är inte så uttrycksfull.

905
00:43:30,230 --> 00:43:30,910
än så länge.

906
00:43:30,910 --> 00:43:33,690
Så, yay, sista gången vi
gick ganska snabbt

907
00:43:33,690 --> 00:43:38,320
i genomförande spel och animering,
och konstnärliga verk i Scratch.

908
00:43:38,320 --> 00:43:42,260
Och här är vi är innehåll
med Hello World, och hej 50.

909
00:43:42,260 --> 00:43:43,696
>> Det är inte så inspirerande.

910
00:43:43,696 --> 00:43:46,070
Och faktiskt, dessa första få
exempel kommer att ta tid

911
00:43:46,070 --> 00:43:47,510
ramp upp i spänning.

912
00:43:47,510 --> 00:43:49,854
Men vi har så mycket mer
kontrollerar nu, faktiskt.

913
00:43:49,854 --> 00:43:51,770
Och vi kommer att mycket
snabbt börja skiktning

914
00:43:51,770 --> 00:43:53,870
ovanpå dessa grundläggande primitiver.

915
00:43:53,870 --> 00:43:56,370
>> Men först, låt oss förstå
vad begränsningarna är.

916
00:43:56,370 --> 00:43:58,620
I själva verket en av de saker
Scratch inte lätt

917
00:43:58,620 --> 00:44:00,990
Låt oss göra är att verkligen se
under huven,

918
00:44:00,990 --> 00:44:03,740
och förstå vad en
dator är, vad det kan göra,

919
00:44:03,740 --> 00:44:05,250
och vad dess begränsningar är.

920
00:44:05,250 --> 00:44:08,580
Och faktiskt, att bristen på
förståelse, potentiellt, långsiktig

921
00:44:08,580 --> 00:44:12,520
kan leda till vår egen mistakes-- skrivande
buggar, skriver osäker programvara som

922
00:44:12,520 --> 00:44:13,880
hackas på något sätt.

923
00:44:13,880 --> 00:44:17,130
>> Så låt oss ta några steg mot
förstå detta lite bättre genom

924
00:44:17,130 --> 00:44:19,710
sätt, säger följande exempel.

925
00:44:19,710 --> 00:44:23,550
Jag kommer att gå vidare och genomföra
riktigt snabbt ett program som heter Adder.

926
00:44:23,550 --> 00:44:25,134
Liksom, låt oss lägga till några siffror tillsammans.

927
00:44:25,134 --> 00:44:27,800
Och jag kommer att koda vissa hörn
här och bara kopiera och klistra in

928
00:44:27,800 --> 00:44:30,270
där jag var innan, bara
så att vi kan komma igång tidigare.

929
00:44:30,270 --> 00:44:33,090
Så nu har jag grund början
av ett program som heter Adder.

930
00:44:33,090 --> 00:44:34,670
>> Och låt oss gå vidare och göra det.

931
00:44:34,670 --> 00:44:38,680
Jag kommer att gå vidare och
säg, blir intx få int.

932
00:44:38,680 --> 00:44:39,430
Och vet du vad?

933
00:44:39,430 --> 00:44:40,990
Låt oss göra en bättre användarupplevelse.

934
00:44:40,990 --> 00:44:45,740
>> Så låt oss bara säga x är, och på ett effektivt sätt
uppmana användaren att ge oss x.

935
00:44:45,740 --> 00:44:50,600
Och låt mig gå vidare och säga, printf
vad sägs om y är, den här gången väntar

936
00:44:50,600 --> 00:44:53,140
två värden från användaren.

937
00:44:53,140 --> 00:44:59,759
Och låt oss gå vidare och
säg, printf, är summan av x och y.

938
00:44:59,759 --> 00:45:01,300
Och nu vill jag inte att göra procent s.

939
00:45:01,300 --> 00:45:09,080
Jag vill göra procent i, bakstreck
n, och sedan koppla in summavärde.

940
00:45:09,080 --> 00:45:10,620
>> Så hur kan jag gå om att göra detta?

941
00:45:10,620 --> 00:45:11,270
Vet du vad?

942
00:45:11,270 --> 00:45:12,840
Jag vet hur man använder variabler.

943
00:45:12,840 --> 00:45:15,140
Låt mig bara förklara en ny, int z.

944
00:45:15,140 --> 00:45:16,770
>> Och jag kommer att ta en gissning här.

945
00:45:16,770 --> 00:45:21,470
Om det finns likhetstecken i detta
språk, kanske jag kan bara göra x plus y,

946
00:45:21,470 --> 00:45:23,660
så länge jag avsluta min
tänkte med ett semikolon?

947
00:45:23,660 --> 00:45:28,170
Nu kan jag gå tillbaka hit ner, koppla in z,
avsluta denna tanke med ett semikolon.

948
00:45:28,170 --> 00:45:33,160
Och låt oss se nu, om dessa
sekvenser av lines-- x är få int.

949
00:45:33,160 --> 00:45:34,770
Y är få int.

950
00:45:34,770 --> 00:45:37,980
>> Lägg x och y, lagra värdet i z--
Så, återigen, kom ihåg likhetstecknet

951
00:45:37,980 --> 00:45:38,560
är inte lika.

952
00:45:38,560 --> 00:45:41,100
Det är uppdrag från höger till vänster.

953
00:45:41,100 --> 00:45:45,180
Och låt oss skriva ut att summan
av x och y är inte bokstav z,

954
00:45:45,180 --> 00:45:46,830
men vad som finns inuti z.

955
00:45:46,830 --> 00:45:50,090
Så låt oss göra Adder -
trevliga, inga misstag den här gången.

956
00:45:50,090 --> 00:45:53,030
Dot snedstreck Adder, in,
x kommer att bli en.

957
00:45:53,030 --> 00:45:55,380
>> Y kommer att bli två.

958
00:45:55,380 --> 00:45:58,964
Och summan av x och y är 3.

959
00:45:58,964 --> 00:46:00,130
Så det är alla fina och bra.

960
00:46:00,130 --> 00:46:03,260
>> Så du kan tänka mig att matte
bör arbeta i ett program som detta.

961
00:46:03,260 --> 00:46:04,040
Men vet du vad?

962
00:46:04,040 --> 00:46:06,904
Är denna variabel linje
12, ens nödvändigt?

963
00:46:06,904 --> 00:46:09,820
Du behöver inte ta för vana
för att bara lagra saker i variabler

964
00:46:09,820 --> 00:46:10,980
bara för att du kan.

965
00:46:10,980 --> 00:46:13,550
Och i själva verket är det i allmänhet
genomtänkt dålig design

966
00:46:13,550 --> 00:46:18,100
Om du skapar en variabel som kallas
z i detta fall, lagra något i det,

967
00:46:18,100 --> 00:46:21,390
och sedan omedelbart
använda den, men aldrig igen.

968
00:46:21,390 --> 00:46:24,700
Varför ge något namn
som z om du är bokstavligen

969
00:46:24,700 --> 00:46:26,770
kommer att använda som
sak endast en gång, och så

970
00:46:26,770 --> 00:46:29,380
proximal där du skapat
det i första hand,

971
00:46:29,380 --> 00:46:31,052
så nära i termer av rader kod?

972
00:46:31,052 --> 00:46:31,760
Så du vet vad?

973
00:46:31,760 --> 00:46:34,480
Det visar sig att C är ganska flexibel.

974
00:46:34,480 --> 00:46:36,586
Om jag verkligen vill
plug-in värden här,

975
00:46:36,586 --> 00:46:38,210
Jag behöver inte förklara en ny variabel.

976
00:46:38,210 --> 00:46:41,680
Jag kunde bara plug-in x plus
y, eftersom C förstår

977
00:46:41,680 --> 00:46:43,390
aritmetik, och matematiska operatorer.

978
00:46:43,390 --> 00:46:47,140
>> Så jag kan bara säga, gör det math,
x plus y, oavsett dessa värden,

979
00:46:47,140 --> 00:46:50,780
anslut den resulterande
heltal i den strängen.

980
00:46:50,780 --> 00:46:53,730
Så detta kan vara, men
endast en rad kortare,

981
00:46:53,730 --> 00:46:58,480
en bättre konstruktion, ett bättre program,
eftersom det finns mindre kod, därför

982
00:46:58,480 --> 00:46:59,921
mindre för mig att förstå.

983
00:46:59,921 --> 00:47:01,920
Och det är också bara renare,
mån vi inte

984
00:47:01,920 --> 00:47:04,620
införande av nya ord,
nya symboler, som z,

985
00:47:04,620 --> 00:47:07,510
även om de inte riktigt
tjäna mycket av ett syfte.

986
00:47:07,510 --> 00:47:12,890
>> Tyvärr är inte matematik
allt som tillförlitliga ibland.

987
00:47:12,890 --> 00:47:15,270
Låt oss gå vidare och göra det.

988
00:47:15,270 --> 00:47:18,200
Jag kommer att gå vidare
nu och gör följande.

989
00:47:18,200 --> 00:47:27,650
>> Låt oss göra printf, procent i, plus procent
Jag ska vara procent i, bakstreck n.

990
00:47:27,650 --> 00:47:32,240
Och jag kommer att göra this-- XYX plus y.

991
00:47:32,240 --> 00:47:34,821
Så jag ska bara skriva
denna något annorlunda här.

992
00:47:34,821 --> 00:47:36,320
Låt mig bara göra en snabb kontroll förstånd.

993
00:47:36,320 --> 00:47:37,986
Återigen, låt oss inte komma före oss.

994
00:47:37,986 --> 00:47:41,420
Gör huggorm, dot slash huggorm.

995
00:47:41,420 --> 00:47:44,950
x är 1, y är 2, 1 plus 2 är 3.

996
00:47:44,950 --> 00:47:45,870
Så det är bra.

997
00:47:45,870 --> 00:47:49,060
Men låt oss komplicera detta nu
en bit, och skapa en ny fil.

998
00:47:49,060 --> 00:47:53,350
>> Jag kommer att kalla detta en,
säga, Ints, plural för heltal.

999
00:47:53,350 --> 00:47:55,980
Låt mig börja där jag var för en stund sedan.

1000
00:47:55,980 --> 00:47:57,770
Men nu ska vi göra några andra linjer.

1001
00:47:57,770 --> 00:48:03,430
Låt mig gå vidare och göra följande,
printf, procent i, minus procent i,

1002
00:48:03,430 --> 00:48:08,959
är procent i, komma x, komma yx minus y.

1003
00:48:08,959 --> 00:48:10,750
Så jag gör något
olika matematik där.

1004
00:48:10,750 --> 00:48:11,624
Låt oss göra en annan.

1005
00:48:11,624 --> 00:48:16,610
Så procent i gånger procent
i är procent i, omvänt snedstreck n.

1006
00:48:16,610 --> 00:48:21,430
Låt oss plug-in x och y, och x gånger y.

1007
00:48:21,430 --> 00:48:24,530
Vi kommer att använda asterisk på
datorn för tider.

1008
00:48:24,530 --> 00:48:26,390
>> Du behöver inte använda x. x är
ett variabelnamn här.

1009
00:48:26,390 --> 00:48:28,270
Du använder stjärnan för multiplikation.

1010
00:48:28,270 --> 00:48:29,020
Låt oss göra en till.

1011
00:48:29,020 --> 00:48:34,580
Printf procent I, uppdelat
genom procent i, är procent i,

1012
00:48:34,580 --> 00:48:40,460
bakåtstreck n. xy dividerat med y--
så du använda snedstreck i C

1013
00:48:40,460 --> 00:48:41,502
att göra division.

1014
00:48:41,502 --> 00:48:42,460
Och låt oss göra en annan.

1015
00:48:42,460 --> 00:48:47,920

1016
00:48:47,920 --> 00:48:55,240
Återstoden av procent i, uppdelat
genom procent i, är procent i.

1017
00:48:55,240 --> 00:48:59,550
xy-- och nu resten
är vad som finns kvar över.

1018
00:48:59,550 --> 00:49:02,980
När du försöker dela en
nämnare i en täljare,

1019
00:49:02,980 --> 00:49:05,570
hur mycket är kvar att
Du kan inte dela ut?

1020
00:49:05,570 --> 00:49:07,910
>> Så det finns egentligen inte,
nödvändigtvis, en symbol

1021
00:49:07,910 --> 00:49:09,470
vi har använt i grundskolan för detta.

1022
00:49:09,470 --> 00:49:13,830
Men det i C. Du kan
säga x modulo y, där

1023
00:49:13,830 --> 00:49:18,000
denna procenttecknet i denna context--
förvirrande när du är inne

1024
00:49:18,000 --> 00:49:20,170
av citationstecken,
insidan av printf, procent

1025
00:49:20,170 --> 00:49:21,830
används som format specifikation.

1026
00:49:21,830 --> 00:49:25,420
>> När du använder procent utanför
att i ett matematiskt uttryck,

1027
00:49:25,420 --> 00:49:29,910
det är modulooperatorn för modul
arithmetic-- för våra ändamål

1028
00:49:29,910 --> 00:49:33,650
här, betyder bara, vad är det
återstoden av x delat med y?

1029
00:49:33,650 --> 00:49:36,130
Så x dividerat med y x snedstreck y.

1030
00:49:36,130 --> 00:49:38,220
Vad är resten av x delat med y?

1031
00:49:38,220 --> 00:49:41,780
Det är x mod y, som programmerare skulle säga.

1032
00:49:41,780 --> 00:49:48,300
>> Så om jag gjorde inga misstag här, låt mig
gå vidare och göra Ints, plural, trevlig,

1033
00:49:48,300 --> 00:49:50,010
och dot slash ints.

1034
00:49:50,010 --> 00:49:55,270
Och låt oss gå vidare och
gör, låt oss säga, en 10.

1035
00:49:55,270 --> 00:49:58,390
Okej, är ett plus 10 11, check.

1036
00:49:58,390 --> 00:50:01,240
1 minus 10 är -9, kontrollera.

1037
00:50:01,240 --> 00:50:03,420
>> 1 gånger 10 är 10, check.

1038
00:50:03,420 --> 00:50:07,090
1 dividerat med 10 är--
OK, vi hoppar över den.

1039
00:50:07,090 --> 00:50:09,480
Återstoden av en delat med 10 är ett.

1040
00:50:09,480 --> 00:50:10,680
Det stämmer.

1041
00:50:10,680 --> 00:50:12,630
Men det finns ett fel i här.

1042
00:50:12,630 --> 00:50:15,390
>> Så jag lägger min
lämna över, inte är korrekt.

1043
00:50:15,390 --> 00:50:16,670
Jag menar, det är nära till 0.

1044
00:50:16,670 --> 00:50:20,670
1 dividerat med 10, du vet, om vi
styckning vissa hörn, säker, det är noll.

1045
00:50:20,670 --> 00:50:28,050
Men det borde verkligen vara 1/10,
0,1 eller 0,10, 0,1000, eller så vidare.

1046
00:50:28,050 --> 00:50:30,600
>> Det borde egentligen inte vara noll.

1047
00:50:30,600 --> 00:50:35,990
Tja, visar det sig att datorn är
gör bokstavligen vad vi veta det att göra.

1048
00:50:35,990 --> 00:50:39,460
Vi gör matematik som x dividerat med y.

1049
00:50:39,460 --> 00:50:44,680
Och både x och y, per linjerna
kod tidigare är heltal.

1050
00:50:44,680 --> 00:50:50,440
>> Dessutom, på linje 15, är vi
berättar printf, hej, printf plug-in

1051
00:50:50,440 --> 00:50:54,230
ett heltal, plug-in ett heltal,
plug-in en integer-- specifikt

1052
00:50:54,230 --> 00:50:57,580
x, och sedan y och sedan x
dividerat med y. x och y är ints.

1053
00:50:57,580 --> 00:50:59,060
Vi är bra där.

1054
00:50:59,060 --> 00:51:01,250
>> Men vad är x dividerat med x?

1055
00:51:01,250 --> 00:51:06,790
x dividerat med y borde vara,
matematiskt, 1/10, eller 0,1,

1056
00:51:06,790 --> 00:51:11,600
som är ett reellt tal, ett reellt tal
med potentiellt ett decimalkomma.

1057
00:51:11,600 --> 00:51:13,230
Det är inte ett heltal.

1058
00:51:13,230 --> 00:51:18,290
>> Men vad är det närmaste
heltal till 1/10, eller 0,1?

1059
00:51:18,290 --> 00:51:21,114
Ja, typ av är det noll.

1060
00:51:21,114 --> 00:51:22,030
0,1 är så här mycket.

1061
00:51:22,030 --> 00:51:22,890
Och en är detta mycket.

1062
00:51:22,890 --> 00:51:25,870
Så 1/10 är närmare
0 än det är att en.

1063
00:51:25,870 --> 00:51:30,800
>> Och så vad C gör för oss--
typ av eftersom vi fick höra det att--

1064
00:51:30,800 --> 00:51:32,600
är trunkera som heltal.

1065
00:51:32,600 --> 00:51:40,540
Det tar värdet, vilket återigen är
tänkt att vara något som 0,1000,

1066
00:51:40,540 --> 00:51:41,800
0 och så vidare.

1067
00:51:41,800 --> 00:51:45,320
Och det trunke allt
efter decimalkommat

1068
00:51:45,320 --> 00:51:47,510
så att allt detta
saker, eftersom det inte gör det

1069
00:51:47,510 --> 00:51:51,910
passa in i begreppet ett heltal, som
är bara ett nummer som -1, 0, 1,

1070
00:51:51,910 --> 00:51:55,830
upp och ner, kastar bort allt
efter decimalkommat eftersom du

1071
00:51:55,830 --> 00:51:59,020
kan inte passa en decimal
i ett heltal per definition.

1072
00:51:59,020 --> 00:52:01,290
>> Så svaret här är noll.

1073
00:52:01,290 --> 00:52:02,600
Så hur ska vi åtgärda detta?

1074
00:52:02,600 --> 00:52:04,400
Vi behöver en annan lösning tillsammans.

1075
00:52:04,400 --> 00:52:06,880
Och vi kan göra detta, enligt följande.

1076
00:52:06,880 --> 00:52:12,820
>> Låt mig gå vidare och skapa en ny
fil, som kallas detta en floats.c.

1077
00:52:12,820 --> 00:52:16,500
Och spara den här i
samma katalog, float.c.

1078
00:52:16,500 --> 00:52:19,360

1079
00:52:19,360 --> 00:52:23,260
Och låt mig gå vidare och kopiera
en del av denna kod från tidigare.

1080
00:52:23,260 --> 00:52:27,690
>> Men i stället för att få
en int, låt oss göra detta.

1081
00:52:27,690 --> 00:52:31,037
Ge mig ett flyttalsvärde
kallas x. där en flyttals

1082
00:52:31,037 --> 00:52:33,370
Värdet är bara bokstavligen
något med ett flyttal.

1083
00:52:33,370 --> 00:52:34,410
Det kan röra sig åt vänster, till höger.

1084
00:52:34,410 --> 00:52:35,530
Det är ett reellt tal.

1085
00:52:35,530 --> 00:52:38,050
>> Och låt mig kalla inte
få int, men få flyta,

1086
00:52:38,050 --> 00:52:41,420
som också var bland menyn
alternativ i C250-biblioteket.

1087
00:52:41,420 --> 00:52:43,220
Låt oss ändra y till en flottör.

1088
00:52:43,220 --> 00:52:45,000
Så det här blir få flyta.

1089
00:52:45,000 --> 00:52:47,620
>> Och nu vill vi inte att koppla in Ints.

1090
00:52:47,620 --> 00:52:53,130
Det visar sig att vi måste använda procent
f för flyta, procent f för flottören,

1091
00:52:53,130 --> 00:52:54,560
och nu spara den.

1092
00:52:54,560 --> 00:53:01,220
Och nu, tummarna, göra
flottar, fina, dot slash flyter.

1093
00:53:01,220 --> 00:53:04,280
x kommer att bli en 1. y
Kommer att vara 10 igen.

1094
00:53:04,280 --> 00:53:08,240
>> Och är trevligt, OK mitt tillägg korrekt.

1095
00:53:08,240 --> 00:53:10,240
Jag hoppades för mer,
men jag glömde att skriva det.

1096
00:53:10,240 --> 00:53:13,250
Så låt oss gå och fixa detta logiskt fel.

1097
00:53:13,250 --> 00:53:16,280
>> Låt oss gå vidare och ta följande.

1098
00:53:16,280 --> 00:53:18,080
Vi ska bara göra en liten kopiera och klistra in.

1099
00:53:18,080 --> 00:53:20,080
Och jag kommer att säga minus.

1100
00:53:20,080 --> 00:53:21,890
>> Och jag kommer att säga gånger.

1101
00:53:21,890 --> 00:53:24,060
Och jag ska säga delas.

1102
00:53:24,060 --> 00:53:28,240
Och jag tänker inte göra modulo,
som inte är så förbunden här,

1103
00:53:28,240 --> 00:53:33,690
dividerat med f, och tider plus--
OK, låt oss göra detta igen.

1104
00:53:33,690 --> 00:53:44,210
>> Gör flottar, dot slash flottar,
och 1, 10, och-- trevligt, nej, OK.

1105
00:53:44,210 --> 00:53:45,250
Så jag är en idiot.

1106
00:53:45,250 --> 00:53:47,000
Så detta är mycket vanligt
i datavetenskap

1107
00:53:47,000 --> 00:53:49,780
att göra dumma misstag som detta.

1108
00:53:49,780 --> 00:53:53,100
>> Av pedagogiska skäl,
vad jag verkligen ville göra

1109
00:53:53,100 --> 00:53:57,410
var ändra vetenskapen här
till plus, minus, till tider,

1110
00:53:57,410 --> 00:54:01,140
och att dela, som ni förhoppningsvis
märkt under denna övning.

1111
00:54:01,140 --> 00:54:04,700
Så nu ska vi åter sammanställa denna
program, gör dot slash flyter.

1112
00:54:04,700 --> 00:54:07,950
>> Och för tredje gången, låt oss
se om det uppfyller mina förväntningar.

1113
00:54:07,950 --> 00:54:21,480
1, 10, in, ja, OK, 1,000,
dividerat med 10,000, är ​​0,100000.

1114
00:54:21,480 --> 00:54:24,952
Och det visar sig att vi kan kontrollera hur många
nummer är ute efter de decimaler.

1115
00:54:24,952 --> 00:54:25,660
Vi kommer faktiskt.

1116
00:54:25,660 --> 00:54:26,790
Vi ska återkomma till det.

1117
00:54:26,790 --> 00:54:28,440
>> Men nu, i själva verket är matematik korrekt.

1118
00:54:28,440 --> 00:54:30,090
Så, återigen, vad är takeaway här?

1119
00:54:30,090 --> 00:54:33,050
Det visar sig att i C, finns det
inte bara bara strings-- och, faktiskt,

1120
00:54:33,050 --> 00:54:36,120
Det finns egentligen inte, eftersom vi
lägga till dem med CS50 biblioteket.

1121
00:54:36,120 --> 00:54:37,710
Men det finns inte bara Ints.

1122
00:54:37,710 --> 00:54:38,990
>> Det finns också flyter.

1123
00:54:38,990 --> 00:54:42,810
Och det visar sig en massa andra uppgifter
typer också att vi kommer att använda kort.

1124
00:54:42,810 --> 00:54:46,270
Det visade sig att om du vill ha en enda
karaktär, inte en teckensträng,

1125
00:54:46,270 --> 00:54:47,610
du kan använda bara en röding.

1126
00:54:47,610 --> 00:54:52,350
>> Det visade sig att om du vill ha en bool,
ett booleskt värde, sant eller falskt bara,

1127
00:54:52,350 --> 00:54:56,840
Tack vare CS50 biblioteket, vi har
adderas till C typen bool uppgifter också.

1128
00:54:56,840 --> 00:54:59,180
Men det är också närvarande i
många andra språk.

1129
00:54:59,180 --> 00:55:04,130
Och det visar sig att ibland
behöver större siffror sedan kommer som standard

1130
00:55:04,130 --> 00:55:05,210
med Ints och flottar.

1131
00:55:05,210 --> 00:55:10,590
>> Och, i själva verket en dubbel är ett tal
som använder inte 32 bitar, men 64 bitar.

1132
00:55:10,590 --> 00:55:14,990
Och en lång lång är ett nummer som
använder inte 32, bitar men 64 bitar,

1133
00:55:14,990 --> 00:55:19,190
respektive, för flyttal
värderingar och heltal, respektive.

1134
00:55:19,190 --> 00:55:22,780
Så låt oss faktiskt nu
se detta i aktion.

1135
00:55:22,780 --> 00:55:26,150
>> Jag kommer att gå vidare här
och piska upp ett annat program.

1136
00:55:26,150 --> 00:55:32,020
Här kommer jag att gå vidare
och inkluderar CS50.h.

1137
00:55:32,020 --> 00:55:34,910
Och låt mig gå, omfattar standard IO.h.

1138
00:55:34,910 --> 00:55:37,320
>> Och du kommer att märka något
funky som händer här.

1139
00:55:37,320 --> 00:55:40,592
Det är inte färgkodning saker i
på samma sätt som den gjorde tidigare.

1140
00:55:40,592 --> 00:55:43,550
Och det visar sig, det är därför jag
har inte gett saken ett filnamn.

1141
00:55:43,550 --> 00:55:47,270
>> Jag kommer att kalla detta en
sizeof.c, och klicka på Spara.

1142
00:55:47,270 --> 00:55:51,039
Och lägg märke till vad som händer med min mycket
vit kod mot den svarta bakgrunden.

1143
00:55:51,039 --> 00:55:52,830
Nu, åtminstone det finns
några lila där.

1144
00:55:52,830 --> 00:55:54,490
Och det är syntax markerat.

1145
00:55:54,490 --> 00:55:57,700
>> Det beror helt enkelt, jag har
berättade IDE vilken typ av fil

1146
00:55:57,700 --> 00:56:01,060
Det är genom att ge den ett namn, och
specifikt ett filnamnstillägg.

1147
00:56:01,060 --> 00:56:03,620
Nu ska vi gå vidare och göra det.

1148
00:56:03,620 --> 00:56:08,910
Jag kommer att gå vidare och mycket
helt enkelt skriva ut following-- bool

1149
00:56:08,910 --> 00:56:11,080
är procent LU.

1150
00:56:11,080 --> 00:56:12,950
>> Vi ska återkomma till
att på bara ett ögonblick.

1151
00:56:12,950 --> 00:56:15,840
Och då kommer jag att
utskriftsstorlek bool.

1152
00:56:15,840 --> 00:56:18,170
Och nu, bara för att spara
mig lite tid, jag är

1153
00:56:18,170 --> 00:56:20,280
kommer att göra en hel
gäng av dessa på en gång.

1154
00:56:20,280 --> 00:56:24,620
Och särskilt jag ska
ändra detta till en röding och röding.

1155
00:56:24,620 --> 00:56:27,760
Den här kommer jag att ändra
till en dubbel och en dubbel.

1156
00:56:27,760 --> 00:56:31,440
>> Den här kommer jag att ändra
till ett flöte och en flottör.

1157
00:56:31,440 --> 00:56:35,670
Den här, kommer jag att
byta till en int och en int.

1158
00:56:35,670 --> 00:56:38,660
Och här kommer jag
att ändra till en lång lång.

1159
00:56:38,660 --> 00:56:40,840
Och det är fortfarande ta
en lång tid, lång lång.

1160
00:56:40,840 --> 00:56:44,572
>> Och sedan, slutligen, gav jag
själv en alltför många, sträng.

1161
00:56:44,572 --> 00:56:47,030
Det visar sig att i C, det finns
den speciella operatören kallas

1162
00:56:47,030 --> 00:56:50,260
Storleken på det är bokstavligt talat
kommer att, när det körs,

1163
00:56:50,260 --> 00:56:52,099
berätta storleken på
var och en av dessa variabler.

1164
00:56:52,099 --> 00:56:53,890
Och detta är ett sätt, nu,
vi kan koppla tillbaka

1165
00:56:53,890 --> 00:56:57,140
till förra veckans diskussion
av data och representation.

1166
00:56:57,140 --> 00:57:00,330
>> Låt mig gå vidare och sammanställa
Storleken på punkt snedstreck storlek.

1167
00:57:00,330 --> 00:57:01,210
Och låt oss se.

1168
00:57:01,210 --> 00:57:05,210
Det visar sig att i C,
specifikt på CS50 IDE,

1169
00:57:05,210 --> 00:57:08,170
specifikt på
operativsystemet Ubuntu,

1170
00:57:08,170 --> 00:57:11,100
som är en 64-bitars operativsystem
systemet i detta fall,

1171
00:57:11,100 --> 00:57:14,189
en bool kommer att
använda en bitgrupp av rymden.

1172
00:57:14,189 --> 00:57:16,480
Det är hur storleken mäts,
inte i bitar, men i byte.

1173
00:57:16,480 --> 00:57:18,690
Och minns att ett byte är åtta bitar.

1174
00:57:18,690 --> 00:57:22,030
Så en bool, även om du
tekniskt bara behöver en 0 eller 1,

1175
00:57:22,030 --> 00:57:24,092
det är lite slösaktigt
hur vi har genomfört det.

1176
00:57:24,092 --> 00:57:26,800
Det är faktiskt kommer att använda en hel
byte-- så alla nollor, är kanske

1177
00:57:26,800 --> 00:57:31,050
alla ettor, eller något liknande,
eller bara en en bland åtta bitar.

1178
00:57:31,050 --> 00:57:34,962
>> En röding, under tiden, som används för ett tecken
som en ASCII-tecken per förra veckan,

1179
00:57:34,962 --> 00:57:36,170
kommer att vara ett tecken.

1180
00:57:36,170 --> 00:57:42,340
Och det synchs med vår uppfattning om
det är inte mer än 256 bits-- snarare

1181
00:57:42,340 --> 00:57:45,360
synchs upp med det är ingen
längre än 8 bitar, som

1182
00:57:45,360 --> 00:57:47,450
ger oss så många som 256 värden.

1183
00:57:47,450 --> 00:57:49,680
En dubbel kommer att
vara 8 byte eller 64 bitar.

1184
00:57:49,680 --> 00:57:50,510
>> En flottör är fyra.

1185
00:57:50,510 --> 00:57:51,690
En int är fyra.

1186
00:57:51,690 --> 00:57:52,980
En lång, är lång 8.

1187
00:57:52,980 --> 00:57:54,716
Och en sträng är åtta.

1188
00:57:54,716 --> 00:57:55,840
Men oroa dig inte om det.

1189
00:57:55,840 --> 00:57:57,340
Vi kommer att dra tillbaka det lagret.

1190
00:57:57,340 --> 00:57:59,940
Det visar sig, strängar kan
vara längre än 8 byte.

1191
00:57:59,940 --> 00:58:02,310
>> Och faktiskt, vi har skrivit
strängar redan, hallå världen,

1192
00:58:02,310 --> 00:58:03,700
längre än 8 byte.

1193
00:58:03,700 --> 00:58:06,270
Men vi kommer tillbaka till
att på bara ett ögonblick.

1194
00:58:06,270 --> 00:58:09,690
Men ta bort här är följande.

1195
00:58:09,690 --> 00:58:15,320
>> Alla datorer har bara en ändlig
mängd minne och utrymme.

1196
00:58:15,320 --> 00:58:17,860
Du kan bara lagra så många
filer på din Mac eller PC.

1197
00:58:17,860 --> 00:58:23,030
Du kan bara lagra så många program i
RAM körs på en gång, med nödvändighet, även

1198
00:58:23,030 --> 00:58:26,360
med virtuellt minne, eftersom
du har en ändlig mängd RAM.

1199
00:58:26,360 --> 00:58:28,990
>> Och bara för att picture-- om
du aldrig har öppnat upp en bärbar dator

1200
00:58:28,990 --> 00:58:31,300
eller beställas extra minne
för en dator, du

1201
00:58:31,300 --> 00:58:33,670
kanske inte vet att
insidan av din dator

1202
00:58:33,670 --> 00:58:36,590
är något som ser
lite som det här.

1203
00:58:36,590 --> 00:58:40,540
Så det här är bara ett gemensamt bolag som heter
Avgörande som gör RAM för datorer.

1204
00:58:40,540 --> 00:58:43,620
Och RAM är där program
leva medan de kör.

1205
00:58:43,620 --> 00:58:46,630
>> Så på varje Mac eller PC, vid dubbel
Klicka på ett program, och det öppnar upp,

1206
00:58:46,630 --> 00:58:48,921
och det öppnar några Word-dokument
eller något sådant,

1207
00:58:48,921 --> 00:58:51,764
lagrar den tillfälligt i
RAM, eftersom RAM är snabbare

1208
00:58:51,764 --> 00:58:53,680
än hårddisken, eller
din solid state disk.

1209
00:58:53,680 --> 00:58:56,600
Så det är bara där program går
att leva när de kör,

1210
00:58:56,600 --> 00:58:58,060
eller när filerna används.

1211
00:58:58,060 --> 00:59:00,890
>> Så du har saker som ser
som detta i din bärbara dator,

1212
00:59:00,890 --> 00:59:03,320
eller något större saker
inne på skrivbordet.

1213
00:59:03,320 --> 00:59:07,440
Men nyckeln är du bara har en
ändligt antal av dessa saker.

1214
00:59:07,440 --> 00:59:11,230
Och det finns bara en begränsad mängd
maskinvara sitter på detta skrivbord höger

1215
00:59:11,230 --> 00:59:11,730
här.

1216
00:59:11,730 --> 00:59:15,920
>> Så säkert, vi kan inte lagra
oändligt långa nummer.

1217
00:59:15,920 --> 00:59:19,030
Och ändå, om du tänker tillbaka på
grundskola, hur många siffror kan

1218
00:59:19,030 --> 00:59:21,400
du har till höger
av ett decimalkomma?

1219
00:59:21,400 --> 00:59:24,680
För den delen, hur många siffror kan
du har till vänster om ett decimalkomma?

1220
00:59:24,680 --> 00:59:26,300
Verkligen, oändligt många.

1221
00:59:26,300 --> 00:59:30,840
>> Nu, vi människor bara kanske
hur man uttalar miljoner,

1222
00:59:30,840 --> 00:59:34,990
och miljarder biljoner, och
quadrillion och kvintiljon.

1223
00:59:34,990 --> 00:59:39,370
Och jag vidga gränserna för min
understanding-- eller my-- jag förstår

1224
00:59:39,370 --> 00:59:41,110
siffror, men min
uttalet av siffror.

1225
00:59:41,110 --> 00:59:44,720
Men de kan få oändligt stora med
oändligt många Siffrorna till vänster

1226
00:59:44,720 --> 00:59:47,050
eller till höger om ett decimalkomma.

1227
00:59:47,050 --> 00:59:50,040
>> Men datorer har bara en
begränsad mängd minne,

1228
00:59:50,040 --> 00:59:53,510
ett ändligt antal transistorer, en
ändligt antal glödlampor inuti.

1229
00:59:53,510 --> 00:59:57,350
Så vad händer när
du får slut på utrymme?

1230
00:59:57,350 --> 00:59:59,620
Med andra ord, om du
tänka tillbaka på förra veckan

1231
00:59:59,620 --> 01:00:03,160
när vi pratade om siffror
sig representeras i binär,

1232
01:00:03,160 --> 01:00:05,480
Anta att vi har
Detta 8-bitars värde här.

1233
01:00:05,480 --> 01:00:08,290
>> Och vi har sju 1: or och en 0.

1234
01:00:08,290 --> 01:00:10,827
Och anta att vi vill
för att lägga till ett till detta värde.

1235
01:00:10,827 --> 01:00:12,410
Detta är en riktigt stor antal just nu.

1236
01:00:12,410 --> 01:00:16,610
>> Detta är 254, om jag minns
matten från förra veckan höger.

1237
01:00:16,610 --> 01:00:19,480
Men vad händer om jag ändrar
att högra 0 till 1?

1238
01:00:19,480 --> 01:00:22,800
Hela antal, av
Naturligtvis blir åtta 1: or.

1239
01:00:22,800 --> 01:00:24,050
Så vi är fortfarande bra.

1240
01:00:24,050 --> 01:00:27,204
>> Och som förmodligen representerar
255, men beroende på sammanhang

1241
01:00:27,204 --> 01:00:29,120
det faktiskt kan utgöra
ett negativt tal.

1242
01:00:29,120 --> 01:00:31,240
Men mer om det en annan gång.

1243
01:00:31,240 --> 01:00:34,220
Det känns som om det handlar om
så högt som jag kan räkna.

1244
01:00:34,220 --> 01:00:35,290
>> Nu är det bara 8 bitar.

1245
01:00:35,290 --> 01:00:38,170
Och min Mac, säkert, har sätt
mer än 8 bitar av minnet.

1246
01:00:38,170 --> 01:00:39,170
Men det har ändlig.

1247
01:00:39,170 --> 01:00:43,230
Så samma argument gäller, även om vi
har flera av dessa de på skärmen.

1248
01:00:43,230 --> 01:00:47,020
>> Men vad händer om du är
lagra detta nummer, 255,

1249
01:00:47,020 --> 01:00:49,290
och du vill räkna en lite högre?

1250
01:00:49,290 --> 01:00:51,600
Du vill gå 255-256.

1251
01:00:51,600 --> 01:00:55,800
Problemet är naturligtvis att om du
börja räkna på noll som förra veckan,

1252
01:00:55,800 --> 01:00:59,670
du kan inte räknas som hög
som 256, för att inte tala 257,

1253
01:00:59,670 --> 01:01:02,584
än mindre 258, m eftersom det som
händer när du lägger till en 1?

1254
01:01:02,584 --> 01:01:05,000
Om du gör den gamla grundskolan
tillvägagångssätt, sätta dig en en här,

1255
01:01:05,000 --> 01:01:08,150
och sedan ett plus ett är två, men det är
verkligen en nolla, bär du en,

1256
01:01:08,150 --> 01:01:09,695
bära en, bära ett.

1257
01:01:09,695 --> 01:01:12,620
Alla dessa saker,
dessa 1 s, gå till noll.

1258
01:01:12,620 --> 01:01:17,820
Och man hamnar, ja, som någon
påpekade, en 1 på vänster sida.

1259
01:01:17,820 --> 01:01:22,540
Men allt du kan
faktiskt se och passar i minnet

1260
01:01:22,540 --> 01:01:27,960
är bara åtta 0-talet, det vill säga
någon gång om du, en dator,

1261
01:01:27,960 --> 01:01:32,490
försökte räkna tillräckligt högt upp, du är
kommer att svepa runt, verkar det,

1262
01:01:32,490 --> 01:01:35,850
till noll, eller kanske till och med negativ
nummer, som är ännu lägre än noll.

1263
01:01:35,850 --> 01:01:37,260
>> Och vi kan slags se detta.

1264
01:01:37,260 --> 01:01:39,900
Låt mig gå vidare och skriva
en riktig snabb program här.

1265
01:01:39,900 --> 01:01:43,690
Låt mig gå vidare och skriva
ett program som kallas Overflow.

1266
01:01:43,690 --> 01:01:49,980
Inkluderar CS50.h, inkluderar
standard IO.h-- oh,

1267
01:01:49,980 --> 01:01:51,730
Jag missade verkligen min syntaxmarkering.

1268
01:01:51,730 --> 01:01:54,440
Så låt oss spara som overflow.c.

1269
01:01:54,440 --> 01:01:57,084
>> Och nu int main void--
och snart kommer vi

1270
01:01:57,084 --> 01:01:59,500
komma tillbaka till att förklara varför
vi fortsätta skriva int main tomrum.

1271
01:01:59,500 --> 01:02:02,080
Men nu, låt oss bara göra
det, ta det för givet.

1272
01:02:02,080 --> 01:02:06,200
Låt oss ge mig en int,
och initiera den till 0.

1273
01:02:06,200 --> 01:02:11,716
>> Låt oss då göra för int jag får zero--
faktiskt, låt oss göra en oändlig loop

1274
01:02:11,716 --> 01:02:12,590
och se vad som händer.

1275
01:02:12,590 --> 01:02:22,440
Även sant, så låt oss skriva ut n
är procent i, bakstreck n, plug-in n.

1276
01:02:22,440 --> 01:02:27,200
Men nu, låt oss göra n blir n plus 1.

1277
01:02:27,200 --> 01:02:29,660
>> Så med andra ord, på varje
variant av denna oändlig slinga,

1278
01:02:29,660 --> 01:02:32,550
låt oss ta n värde,
och tillsätt 1 till den, och sedan

1279
01:02:32,550 --> 01:02:34,350
lagra tillbaka i n resultatet till vänster.

1280
01:02:34,350 --> 01:02:37,150
Och i själva verket har vi sett syntax
något som detta kort.

1281
01:02:37,150 --> 01:02:39,730
En cool trick är istället
att skriva ut allt detta,

1282
01:02:39,730 --> 01:02:42,770
du faktiskt kan säga en n plus lika med 1.

1283
01:02:42,770 --> 01:02:47,480
>> Eller om du verkligen vill vara snygga,
du kan säga n plus plus semikolon.

1284
01:02:47,480 --> 01:02:50,130
Men de två sistnämnda är bara
vad vi skulle kalla syntaktiskt socker

1285
01:02:50,130 --> 01:02:50,790
för det första.

1286
01:02:50,790 --> 01:02:53,456
>> Det första är tydligare,
helt bra, helt korrekt.

1287
01:02:53,456 --> 01:02:55,470
Men det är vanligare, ska jag säga.

1288
01:02:55,470 --> 01:02:57,210
Så vi kommer att göra detta för ett ögonblick.

1289
01:02:57,210 --> 01:03:01,685
>> Låt oss nu göra spill, vilket låter
ganska illavarslande, dot slash spill.

1290
01:03:01,685 --> 01:03:04,380

1291
01:03:04,380 --> 01:03:09,852
Låt oss se, n blir ganska stor.

1292
01:03:09,852 --> 01:03:11,310
Men låt oss tänka, hur stor kan n få?

1293
01:03:11,310 --> 01:03:12,870
>> n är ett int.

1294
01:03:12,870 --> 01:03:16,400
Vi såg en stund sedan med storleken på
exempel att en int är fyra byte.

1295
01:03:16,400 --> 01:03:22,070
Vi vet från förra veckan, är fyra byte
32 bitar, eftersom 8 gånger 4, det är 32.

1296
01:03:22,070 --> 01:03:23,460
Det kommer att vara 4 miljarder.

1297
01:03:23,460 --> 01:03:25,802
>> Och vi är upp till 800.000.

1298
01:03:25,802 --> 01:03:28,510
Detta kommer att ta evigheter att
räknas som högt som jag kan.

1299
01:03:28,510 --> 01:03:30,635
Så jag kommer att gå framåt,
som ni kanske snart,

1300
01:03:30,635 --> 01:03:34,910
och slå kontroll C- ärligt talat, kontroll
C, en hel del, där Kontroll C i allmänhet

1301
01:03:34,910 --> 01:03:36,034
medel avbryta.

1302
01:03:36,034 --> 01:03:38,200
Tyvärr, eftersom detta
körs i molnet,

1303
01:03:38,200 --> 01:03:41,190
ibland molnet är
spotta ut så mycket grejer,

1304
01:03:41,190 --> 01:03:44,180
så mycket produktion, det kommer att
ta en liten stund för min ingång

1305
01:03:44,180 --> 01:03:45,630
för att komma till molnet.

1306
01:03:45,630 --> 01:03:49,240
Så även om jag slog
Kontroll C några sekunder sedan,

1307
01:03:49,240 --> 01:03:53,110
Detta är definitivt sidan
effekten av en oändlig slinga.

1308
01:03:53,110 --> 01:03:56,070
>> Och så i sådana fall, vi är
kommer att lämna det vara.

1309
01:03:56,070 --> 01:03:59,050
Och vi kommer att lägga till en annan
terminalfönster hit

1310
01:03:59,050 --> 01:04:03,186
med plus, vilket naturligtvis inte
så, eftersom det är fortfarande tänker.

1311
01:04:03,186 --> 01:04:05,310
Och låt oss gå vidare och vara
lite mer rimlig.

1312
01:04:05,310 --> 01:04:07,768
>> Jag kommer att gå vidare och göra
detta endast ändligt många gånger.

1313
01:04:07,768 --> 01:04:10,047
Låt oss använda en for-loop,
som jag nämnt tidigare.

1314
01:04:10,047 --> 01:04:10,630
Nu gör vi det.

1315
01:04:10,630 --> 01:04:13,430
Ge mig en annan variabel int i blir 0.

1316
01:04:13,430 --> 01:04:17,430
Jag är mindre än, låt oss säga, 64 i ++.

1317
01:04:17,430 --> 01:04:24,010
Och låt mig nu gå vidare och skriva ut
ut n är procent i, komma n.

1318
01:04:24,010 --> 01:04:27,547
Och sedan n-- detta är fortfarande
kommer att ta för evigt.

1319
01:04:27,547 --> 01:04:28,130
Nu gör vi det.

1320
01:04:28,130 --> 01:04:30,620
>> n blir n gånger 2.

1321
01:04:30,620 --> 01:04:34,140
Eller vi kan vara snygga
och göra gånger är lika med två.

1322
01:04:34,140 --> 01:04:37,120
Men låt oss bara säga n
lika sig gånger 2.

1323
01:04:37,120 --> 01:04:39,321
Med andra ord, i detta
ny version av programmet,

1324
01:04:39,321 --> 01:04:41,820
Jag vill inte vänta för evigt
från som 800.000 till 4 miljarder.

1325
01:04:41,820 --> 01:04:43,070
Låt oss bara få det överstökat.

1326
01:04:43,070 --> 01:04:44,920
>> Låt oss faktiskt dubbla n varje gång.

1327
01:04:44,920 --> 01:04:47,660
Vilket minns, är en fördubbling av
motsatsen till att ha, naturligtvis.

1328
01:04:47,660 --> 01:04:50,035
Och medan förra veckan vi har
något igen, och igen,

1329
01:04:50,035 --> 01:04:52,200
och igen, supersnabb,
fördubbling kommer säkert

1330
01:04:52,200 --> 01:04:58,080
få oss från en till största möjliga
värde som vi kan räkna till med en int.

1331
01:04:58,080 --> 01:04:59,750
>> Så låt oss göra just detta.

1332
01:04:59,750 --> 01:05:01,720
Och vi kommer att återkomma till detta kort.

1333
01:05:01,720 --> 01:05:04,180
Men detta, återigen, är precis som
upprepningsblocket i Scratch.

1334
01:05:04,180 --> 01:05:05,600
Och du kommer att använda detta inom kort.

1335
01:05:05,600 --> 01:05:10,170
>> Detta betyder bara räkna från noll
upp till, men inte lika, till 64.

1336
01:05:10,170 --> 01:05:14,285
Och på varje variant av denna
loop, bara hålla uppräkning i.

1337
01:05:14,285 --> 01:05:18,990
Så jag ++ - och denna allmänna konstruktion
på ledningen 7 är bara en super vanligt sätt

1338
01:05:18,990 --> 01:05:22,290
att upprepa några rader av
kod, en del antal gånger.

1339
01:05:22,290 --> 01:05:23,362
Vilka kodrader?

1340
01:05:23,362 --> 01:05:25,570
Dessa klamrar, som ni
kan ha samlats in från nu,

1341
01:05:25,570 --> 01:05:26,780
innebär, gör följande.

1342
01:05:26,780 --> 01:05:29,510
>> Det är på liknande Scratch, när
det har de gula blocken

1343
01:05:29,510 --> 01:05:32,680
och andra färger som typ av
omfamna eller krama andra block.

1344
01:05:32,680 --> 01:05:34,750
Det är vad dessa lockiga
hängslen gör här.

1345
01:05:34,750 --> 01:05:40,200
Så om jag fick min syntax right-- du
kan se morot symbolen i C medel

1346
01:05:40,200 --> 01:05:42,706
det är hur många gånger jag var
försöker att lösa detta problem.

1347
01:05:42,706 --> 01:05:45,330
Så låt oss bli av med det en
helt och hållet, och stäng fönstret.

1348
01:05:45,330 --> 01:05:46,520
Och vi kommer att använda den nya.

1349
01:05:46,520 --> 01:05:51,980
Gör overflow, pricka snedstreck
spill, Enter, okej,

1350
01:05:51,980 --> 01:05:53,090
Det ser illa först.

1351
01:05:53,090 --> 01:05:56,200
Men låt oss bläddra tillbaka i tiden,
eftersom jag gjorde detta 64 gånger.

1352
01:05:56,200 --> 01:05:58,700
>> Och lägg märke till första gången, är n 1.

1353
01:05:58,700 --> 01:06:03,110
Andra gången, är n 2,
sedan fyra, sedan åtta, sedan 16.

1354
01:06:03,110 --> 01:06:09,450
Och det verkar som så snart som
Jag får ungefär 1 miljard,

1355
01:06:09,450 --> 01:06:12,800
om jag dubbla det igen, som
borde ge mig 2 miljarder.

1356
01:06:12,800 --> 01:06:14,980
Men det visar sig, är det
rätt på gränsen.

1357
01:06:14,980 --> 01:06:18,930
>> Och så det faktiskt flödar
en int från 1 miljard

1358
01:06:18,930 --> 01:06:23,514
till ungefär negativ 2
miljarder, eftersom ett heltal,

1359
01:06:23,514 --> 01:06:25,430
Till skillnad från siffrorna vi
räknade förra veckan,

1360
01:06:25,430 --> 01:06:28,397
kan vara både positiv och negativ
i verkligheten och i en dator.

1361
01:06:28,397 --> 01:06:30,730
Och så åtminstone en av dem
bitarna är effektivt stulen.

1362
01:06:30,730 --> 01:06:34,190
Så vi egentligen bara har 31 bitar,
eller 2 miljarder möjliga värden.

1363
01:06:34,190 --> 01:06:38,220
>> Men nu är takeaway ganska
helt enkelt, oavsett dessa siffror är

1364
01:06:38,220 --> 01:06:42,280
och vad matte är,
något dåligt händer så småningom,

1365
01:06:42,280 --> 01:06:46,980
eftersom så småningom du försöker
permutera bitarna en alltför många gånger.

1366
01:06:46,980 --> 01:06:51,060
Och du faktiskt gå från alla
1 s till kanske alla 0: or, eller kanske

1367
01:06:51,060 --> 01:06:54,260
bara något annat mönster som det
klart, beroende på sammanhanget,

1368
01:06:54,260 --> 01:06:56,342
kan tolkas som ett negativt tal.

1369
01:06:56,342 --> 01:06:59,300
Och så verkar det högsta jag
kan räkna i detta program

1370
01:06:59,300 --> 01:07:01,210
är bara ungefär 1 miljard.

1371
01:07:01,210 --> 01:07:02,760
Men det finns en dellösning här.

1372
01:07:02,760 --> 01:07:03,480
Vet du vad?

1373
01:07:03,480 --> 01:07:07,600
>> Låt mig byta från en
int till en lång lång.

1374
01:07:07,600 --> 01:07:10,633
Och låt mig gå vidare här
och säga-- jag kommer att ha

1375
01:07:10,633 --> 01:07:12,290
att ändra detta till en osignerad länge.

1376
01:07:12,290 --> 01:07:16,860
Eller, låt oss se, jag minns aldrig själv.

1377
01:07:16,860 --> 01:07:19,920
>> Låt oss gå vidare och göra overflow.

1378
01:07:19,920 --> 01:07:21,860
Nej, det är inte det, LLD, tack.

1379
01:07:21,860 --> 01:07:23,430
Så ibland Clang kan vara till hjälp.

1380
01:07:23,430 --> 01:07:27,550
Jag minns inte vad format
specifice var för en lång lång.

1381
01:07:27,550 --> 01:07:28,950
>> Men, ja, klang berättade.

1382
01:07:28,950 --> 01:07:31,570
Grönt är någon typ av bra,
fortfarande innebär att du gjort ett misstag.

1383
01:07:31,570 --> 01:07:33,190
Det gissar att jag menade LLD.

1384
01:07:33,190 --> 01:07:38,750
>> Så låt mig ta det råd, en lång
lång decimaltal, spara det.

1385
01:07:38,750 --> 01:07:43,190
Och låt mig köra den, dot
slash spill, Enter.

1386
01:07:43,190 --> 01:07:45,020
Och nu vad är hett är detta.

1387
01:07:45,020 --> 01:07:49,140
>> Om jag bläddra tillbaka i tiden, vi ändå starta
räkna på samma plats-- 1, 2, 4,

1388
01:07:49,140 --> 01:07:50,220
8, 16.

1389
01:07:50,220 --> 01:07:54,860
Meddelande, får vi alla
upp till 1 miljard.

1390
01:07:54,860 --> 01:07:57,070
Men då vi säkert komma till 2 miljarder.

1391
01:07:57,070 --> 01:08:01,300
>> Då får vi till 4 miljarder,
då 8 miljarder, 17 miljarder.

1392
01:08:01,300 --> 01:08:03,340
Och vi gå högre, och
högre och högre.

1393
01:08:03,340 --> 01:08:05,740
Så småningom, även detta avbrott.

1394
01:08:05,740 --> 01:08:09,350
>> Så småningom, med en lång lång,
som är den 64-bitars värde, inte

1395
01:08:09,350 --> 01:08:13,660
en 32-bitars värde, om man räknar
för högt, du linda runt 0.

1396
01:08:13,660 --> 01:08:16,410
Och i detta fall, råkar vi
sluta med ett negativt tal.

1397
01:08:16,410 --> 01:08:17,550
>> Så detta är ett problem.

1398
01:08:17,550 --> 01:08:20,439
Och det visar sig att detta
Problemet är inte så svårbegripliga.

1399
01:08:20,439 --> 01:08:23,060
Även om jag har medvetet
inducerade det med dessa misstag,

1400
01:08:23,060 --> 01:08:26,149
det visar sig vi ser det slags allt
omkring oss, eller åtminstone en del av oss gör.

1401
01:08:26,149 --> 01:08:28,939
>> Så i Lego Star Wars, om
du någonsin spelat spelet,

1402
01:08:28,939 --> 01:08:33,830
det visar sig att du kan gå runt
bryta upp saker i LEGO världen,

1403
01:08:33,830 --> 01:08:36,640
och samla mynt, i huvudsak.

1404
01:08:36,640 --> 01:08:39,200
Och om du någonsin spelat
detta spel alldeles för mycket tid,

1405
01:08:39,200 --> 01:08:42,630
eftersom detta unnamed individ
här gjorde det totala antalet

1406
01:08:42,630 --> 01:08:46,700
mynt som du kan samla
är, det verkar, 4 miljarder.

1407
01:08:46,700 --> 01:08:48,240
>> Nu, med den faktiskt är rundad.

1408
01:08:48,240 --> 01:08:50,239
Så LEGO försökte
hålla saker användarvänliga.

1409
01:08:50,239 --> 01:08:53,779
De gjorde inte det exakt två till
32 kraft per förra veckan.

1410
01:08:53,779 --> 01:08:55,310
Men 4000 miljoner är en anledning.

1411
01:08:55,310 --> 01:08:58,979
Det verkar, baserat på denna information,
att LEGO, och det företag som

1412
01:08:58,979 --> 01:09:02,624
gjorde detta själva mjukvaran, beslutade
att det maximala antalet mynt

1413
01:09:02,624 --> 01:09:04,540
användaren kan ackumuleras
är verkligen 4 miljarder,

1414
01:09:04,540 --> 01:09:12,069
eftersom de valde i sin kod
att använda inte en lång lång, tydligen,

1415
01:09:12,069 --> 01:09:16,140
men bara ett heltal, en osignerad
heltal, endast ett positivt heltal, vars

1416
01:09:16,140 --> 01:09:18,089
maxvärdet är ungefär det.

1417
01:09:18,089 --> 01:09:19,380
Tja, här är en annan rolig en.

1418
01:09:19,380 --> 01:09:23,500
Så i spelet Civilization, som
några av er kanske känner, med

1419
01:09:23,500 --> 01:09:26,660
det visar sig att år sedan fanns
var en bugg i detta spel där

1420
01:09:26,660 --> 01:09:28,750
om du spelat rollen
av Gandhi i spelet,

1421
01:09:28,750 --> 01:09:34,020
i stället för att han var mycket pacifist,
i stället var otroligt, otroligt

1422
01:09:34,020 --> 01:09:36,399
aggressiv, under vissa omständigheter.

1423
01:09:36,399 --> 01:09:40,529
I synnerhet det sätt som Civilization
verk är att om du, spelaren,

1424
01:09:40,529 --> 01:09:44,680
anta demokrati, din
aggressivitet poängen blir

1425
01:09:44,680 --> 01:09:48,130
minskas med två, så minus
minus, och sedan minus minus.

1426
01:09:48,130 --> 01:09:50,569
>> Så du subtrahera två från
din faktiska iteration.

1427
01:09:50,569 --> 01:09:56,650
Tyvärr, om din iteration är
initialt en, och du subtrahera två från det

1428
01:09:56,650 --> 01:09:59,050
efter antagandet av demokrati
som Gandhi här är kanske

1429
01:09:59,050 --> 01:10:02,200
har gjort, eftersom han var mycket passive--
1 på skalan av aggressivitet.

1430
01:10:02,200 --> 01:10:04,830
Men om han antar demokrati, då
Han går från 1 till -1.

1431
01:10:04,830 --> 01:10:11,470
>> Tyvärr var de
användning av osignerade nummer,

1432
01:10:11,470 --> 01:10:15,400
vilket innebär att de behandlas med negativ
siffror som om de var positiva.

1433
01:10:15,400 --> 01:10:19,780
Och det visar sig att
positiv ekvivalent negativ 1,

1434
01:10:19,780 --> 01:10:23,480
i typiska datorprogram, är 255.

1435
01:10:23,480 --> 01:10:27,250
Så om Gandhi antar
demokrati har, och därför

1436
01:10:27,250 --> 01:10:32,470
hans aggressivitet poäng minskat,
det faktiskt rullar runt till 255

1437
01:10:32,470 --> 01:10:35,470
och gör honom mest
aggressiv karaktär i spelet.

1438
01:10:35,470 --> 01:10:36,930
Så du kan googla upp på detta.

1439
01:10:36,930 --> 01:10:39,380
Och det var faktiskt en
oavsiktlig bug programmering,

1440
01:10:39,380 --> 01:10:43,010
men som anges ganska
lore sedan dess.

1441
01:10:43,010 --> 01:10:44,360
>> Det är allt roligt och söt.

1442
01:10:44,360 --> 01:10:47,760
Mer skrämmande är när den faktiska
verkliga enheter, och inte spel,

1443
01:10:47,760 --> 01:10:48,820
har dessa samma buggar.

1444
01:10:48,820 --> 01:10:54,500
I själva verket bara ett år sedan en artikel kom
reda på Boeing 787 Dreamliner.

1445
01:10:54,500 --> 01:10:56,850
>> Och artikeln först
blick läser lite svårbegripliga.

1446
01:10:56,850 --> 01:11:01,480
Men det sagt detta, en programvara
sårbarhet i Boeings

1447
01:11:01,480 --> 01:11:04,790
nya 787 Dreamliner jet har
potential att orsaka piloter

1448
01:11:04,790 --> 01:11:07,220
att förlora kontrollen över
flygplanet, eventuellt

1449
01:11:07,220 --> 01:11:11,750
i mitten av flygning, FAA tjänstemän
varnade flygbolag nyligen.

1450
01:11:11,750 --> 01:11:14,520
Det var bestämn
att en modell 787

1451
01:11:14,520 --> 01:11:19,770
flygplan som har varit i drift
kontinuerligt under 248 dagar

1452
01:11:19,770 --> 01:11:24,880
kan förlora all växelström, AC,
elektrisk effekt på grund av att generatorn

1453
01:11:24,880 --> 01:11:28,892
styrenheter, GCUs, samtidigt
gå in felsäkert läge.

1454
01:11:28,892 --> 01:11:29,850
Det finns en slags förlora mig.

1455
01:11:29,850 --> 01:11:35,390
Men PM anges OK, nu fick jag det,
villkoret orsakades av en programvara

1456
01:11:35,390 --> 01:11:38,590
motverka interna
generatorstyrning

1457
01:11:38,590 --> 01:11:44,860
enheter som kommer att flöda efter
248 dagar av kontinuerlig effekt.

1458
01:11:44,860 --> 01:11:47,070
Vi utfärdar denna
märker att förhindra förlust

1459
01:11:47,070 --> 01:11:49,300
av all växelströms
makt, vilket kan leda till

1460
01:11:49,300 --> 01:11:50,980
förlust av kontroll över flygplanet.

1461
01:11:50,980 --> 01:11:55,380
>> Så, bokstavligen, det finns något heltal,
eller någon typ motsvarande uppgifter,

1462
01:11:55,380 --> 01:11:57,960
används i programvara
i en verklig flygplan

1463
01:11:57,960 --> 01:12:00,756
att om du håller ditt flygplan
på tillräckligt länge, som uppenbarligen

1464
01:12:00,756 --> 01:12:03,880
kan vara fallet om du bara kör
dem hela tiden och aldrig koppla ur

1465
01:12:03,880 --> 01:12:06,810
ditt flygplan, verkar det, eller
låta batterierna dör,

1466
01:12:06,810 --> 01:12:09,840
så småningom kommer att räkna upp, och upp,
och upp, och upp, och upp, och upp.

1467
01:12:09,840 --> 01:12:12,150
>> Och till sin natur, en
ändlig mängd minne

1468
01:12:12,150 --> 01:12:15,880
kommer att flöda, rulla tillbaka till
noll eller något negativt värde,

1469
01:12:15,880 --> 01:12:19,920
en bieffekt av vilket är den
skrämmande verkliga verkligheten

1470
01:12:19,920 --> 01:12:23,970
att planet kan behöva
startas om, effektivt,

1471
01:12:23,970 --> 01:12:27,290
eller kan falla ännu värre, eftersom den flyger.

1472
01:12:27,290 --> 01:12:29,230
Så dessa typer av frågor
är fortfarande med oss,

1473
01:12:29,230 --> 01:12:33,130
even-- detta var en 2015 artikel,
desto mer skrämmande

1474
01:12:33,130 --> 01:12:36,100
när du inte nödvändigtvis
förstå, uppskatta, eller förutse

1475
01:12:36,100 --> 01:12:38,640
dessa typer av fel.

1476
01:12:38,640 --> 01:12:42,030
>> Så det visar sig att det finns en annan
dåligt om datarepresentation.

1477
01:12:42,030 --> 01:12:47,080
Det visar sig att även flottörer är
typ av bristfällig, eftersom flöten också,

1478
01:12:47,080 --> 01:12:51,440
Jag föreslog är 32 bitar, eller
kanske 64 om du använder en dubbel.

1479
01:12:51,440 --> 01:12:53,070
Men det är fortfarande begränsad.

1480
01:12:53,070 --> 01:12:57,070
>> Och fångsten är att om du kan
sätta ett oändligt antal siffror

1481
01:12:57,070 --> 01:12:59,460
efter decimalkommat,
Det finns inget sätt du

1482
01:12:59,460 --> 01:13:02,690
kan representera alla möjliga
siffror som vi undervisade

1483
01:13:02,690 --> 01:13:04,990
i grundskolan kan existera i världen.

1484
01:13:04,990 --> 01:13:08,870
En dator i huvudsak måste
välja en delmängd av dessa siffror

1485
01:13:08,870 --> 01:13:10,200
att representera exakt.

1486
01:13:10,200 --> 01:13:12,450
>> Nu, att datorn kan
runda kanske lite,

1487
01:13:12,450 --> 01:13:17,900
och kan tillåta dig att ungefär lagra
valfritt antal du kan tänkas vilja.

1488
01:13:17,900 --> 01:13:20,940
Men bara intuitivt, om du
har ett ändligt antal bitar,

1489
01:13:20,940 --> 01:13:24,560
du kan bara permutera dem
i så många ändliga sätt.

1490
01:13:24,560 --> 01:13:26,570
Så du kan omöjligen
använder ett ändligt antal

1491
01:13:26,570 --> 01:13:29,880
av permutation av bitar,
mönster nollor och ettor,

1492
01:13:29,880 --> 01:13:32,940
för att representera en oändlig
antal siffror,

1493
01:13:32,940 --> 01:13:37,370
vilket tyder på att datorer kan
mycket väl vara att ljuga för oss ibland.

1494
01:13:37,370 --> 01:13:38,770
>> I själva verket, låt oss göra detta.

1495
01:13:38,770 --> 01:13:41,239
Låt mig gå tillbaka till CS50 IDE.

1496
01:13:41,239 --> 01:13:43,030
Låt mig gå vidare och
skapa ett litet program

1497
01:13:43,030 --> 01:13:47,940
kallas Imprecision, för att visa att
datorer är, faktiskt, oprecisa.

1498
01:13:47,940 --> 01:13:51,910
>> Och låt mig gå vidare och börja med
en del av denna kod från tidigare,

1499
01:13:51,910 --> 01:13:53,830
och nu bara göra följande.

1500
01:13:53,830 --> 01:14:03,640
Låt mig gå vidare och göra printf, procent
f, bakstreck n, ett dividerat med 10.

1501
01:14:03,640 --> 01:14:07,430
Med andra ord, låt oss dyka djupare
1/10, som en och dividerat med 10.

1502
01:14:07,430 --> 01:14:09,760
Visst kan en dator representera 1/10.

1503
01:14:09,760 --> 01:14:13,620
>> Så låt oss gå vidare och göra imprecision.

1504
01:14:13,620 --> 01:14:14,390
Låt oss se.

1505
01:14:14,390 --> 01:14:16,210
Format anger typ dubbel.

1506
01:14:16,210 --> 01:14:18,160
Men argumentet har typen int.

1507
01:14:18,160 --> 01:14:19,040
Vad pågår?

1508
01:14:19,040 --> 01:14:21,970
>> Åh, intressant, så det är en
lärdom från tidigare.

1509
01:14:21,970 --> 01:14:26,050
Jag säger, hej, dator show
mig en flottör med procent f.

1510
01:14:26,050 --> 01:14:28,200
Men jag ger det 2 Ints.

1511
01:14:28,200 --> 01:14:31,120
Så visar det sig, kan jag fixa
detta på ett par olika sätt.

1512
01:14:31,120 --> 01:14:38,430
>> Jag kunde bara vända ett till 1,0, och
10 i 10,0, vilket skulle faktiskt

1513
01:14:38,430 --> 01:14:42,390
innebära att omvandla
dem i floats-- fortfarande förhoppningsvis

1514
01:14:42,390 --> 01:14:43,180
samma nummer.

1515
01:14:43,180 --> 01:14:45,880
Eller det visar sig att det finns något
vi får se igen snart.

1516
01:14:45,880 --> 01:14:47,170
Du kan kasta siffrorna.

1517
01:14:47,170 --> 01:14:49,880
>> Du kan med hjälp av denna parentes
uttryck, kan man säga,

1518
01:14:49,880 --> 01:14:52,560
hej, dator, ta
10, som jag vet är en int.

1519
01:14:52,560 --> 01:14:54,660
Men behandla det, snälla,
som om det är en flottör.

1520
01:14:54,660 --> 01:14:56,680
Men det känns onödigt komplicerade.

1521
01:14:56,680 --> 01:14:59,040
>> För våra syften i dag,
Låt oss bara bokstavligen

1522
01:14:59,040 --> 01:15:02,700
gör dem flyttal värden
med decimalkomma, som den här.

1523
01:15:02,700 --> 01:15:07,060
Låt mig gå vidare och repris, göra
vaghet, bra, pricka snedstreck

1524
01:15:07,060 --> 01:15:08,870
vaghet anger.

1525
01:15:08,870 --> 01:15:10,990
OK, vi ser bra ut.

1526
01:15:10,990 --> 01:15:18,194
>> 1 dividerat med 10, i enlighet med min
Mac här, är faktiskt 0,100 tusen.

1527
01:15:18,194 --> 01:15:21,360
Nu fick jag lära mig i grundskolan där
bör vara ett oändligt antal 0: or.

1528
01:15:21,360 --> 01:15:23,151
Så låt oss åtminstone försöka
att se några av dessa.

1529
01:15:23,151 --> 01:15:26,770
Det visar sig att printf är lite
snyggare fortfarande än vi har använt.

1530
01:15:26,770 --> 01:15:30,890
Det visar sig att du inte behöver ange
bara procent f, eller bara procent i.

1531
01:15:30,890 --> 01:15:33,830
Du kan faktiskt ange
några kontrollmöjligheter här.

1532
01:15:33,830 --> 01:15:36,470
>> Specifikt, jag ska
att säga, hej, printf,

1533
01:15:36,470 --> 01:15:39,660
faktiskt visa mig 10 decimaler.

1534
01:15:39,660 --> 01:15:40,820
Så det ser lite konstigt.

1535
01:15:40,820 --> 01:15:42,845
Men du säger procent,
pricka, hur många siffror

1536
01:15:42,845 --> 01:15:44,970
du vill se efter
decimalkomma och sedan f

1537
01:15:44,970 --> 01:15:48,340
för platt, bara för att det är
vad dokumentationen säger.

1538
01:15:48,340 --> 01:15:50,080
Låt mig gå vidare och spara det.

1539
01:15:50,080 --> 01:15:52,460
>> Och märker också, jag får
trött på att skriva om saker.

1540
01:15:52,460 --> 01:15:55,900
Så jag bara sätta upp och
nedåtpilen på mina nycklar här.

1541
01:15:55,900 --> 01:15:58,710
Och om jag fortsätter att slå upp, du
kan se alla kommandon

1542
01:15:58,710 --> 01:16:01,090
som jag gjorde, eller felaktigt gjord.

1543
01:16:01,090 --> 01:16:04,630
>> Och jag kommer att gå vidare nu och
faktiskt inte använda det, tydligen.

1544
01:16:04,630 --> 01:16:11,416
Gör vaghet dot
slash imprecision-- så

1545
01:16:11,416 --> 01:16:13,290
vad jag lärdes ut i
grundskolan checkar ut.

1546
01:16:13,290 --> 01:16:19,010
Även om jag ut det till 10 decimal
placerar den faktiskt är 0,10 tusen.

1547
01:16:19,010 --> 01:16:19,840
Men vet du vad?

1548
01:16:19,840 --> 01:16:21,150
>> Låt oss få lite girig.

1549
01:16:21,150 --> 01:16:23,990
Låt oss säga, som visar mig 55
Parlamentet efter decimalkommat.

1550
01:16:23,990 --> 01:16:26,160
Låt oss verkligen ta detta
programmera ut på en tur.

1551
01:16:26,160 --> 01:16:31,170
Låt mig göra om den med make
vaghet, pricka snedstreck, otydligheter.

1552
01:16:31,170 --> 01:16:32,390
>> Och nu kör vi.

1553
01:16:32,390 --> 01:16:34,420
Din barndom var en lögn.

1554
01:16:34,420 --> 01:16:48,410
Uppenbarligen, ett delat med 10 är verkligen
0.100000000000000005551115123--

1555
01:16:48,410 --> 01:16:49,740
>> Vad händer?

1556
01:16:49,740 --> 01:16:53,360
Tja, visar det sig, om du typ av
tittar tillräckligt långt ut i den underliggande

1557
01:16:53,360 --> 01:16:55,950
representation av denna
nummer, det faktiskt

1558
01:16:55,950 --> 01:17:00,400
är inte exakt 1/10, eller 0,1 och
ett oändligt antal nollor.

1559
01:17:00,400 --> 01:17:01,630
Nu, varför är det?

1560
01:17:01,630 --> 01:17:06,250
>> Tja, även om detta är en enkel
nummer till oss människor, en dividerat med 10,

1561
01:17:06,250 --> 01:17:10,910
det är fortfarande en av oändligt många
siffror som vi kunde tänka upp.

1562
01:17:10,910 --> 01:17:14,490
Men en dator kan endast representera
ändligt många så tal.

1563
01:17:14,490 --> 01:17:18,710
Och så, på ett effektivt sätt, vad
dator visar oss är dess närmaste

1564
01:17:18,710 --> 01:17:22,940
approximation till det antal
Vi vill tro är 1/10,

1565
01:17:22,940 --> 01:17:27,760
eller egentligen 0,10000 oändlighet.

1566
01:17:27,760 --> 01:17:30,425
>> Snarare är dock detta
så nära som det kan få.

1567
01:17:30,425 --> 01:17:32,300
Och faktiskt, om man tittar
under huven,

1568
01:17:32,300 --> 01:17:37,050
som vi är här genom att titta
55 siffror efter decimalkommat,

1569
01:17:37,050 --> 01:17:39,990
vi faktiskt se att verkligheten.

1570
01:17:39,990 --> 01:17:42,610
Nu som en sidoreplik, om du har
någonsin sett movie--

1571
01:17:42,610 --> 01:17:45,780
de flesta av er förmodligen haven't--
men Superman 3 några år sedan,

1572
01:17:45,780 --> 01:17:49,500
Richard Pryor väsentligen utnyttjas detta
verklighet i hans företag att stjäla en hel del

1573
01:17:49,500 --> 01:17:53,500
av fraktioner och fraktioner av pennies,
eftersom company-- som jag minns,

1574
01:17:53,500 --> 01:17:57,210
det har varit en while-- var i huvudsak
kasta bort allt som inte passar

1575
01:17:57,210 --> 01:17:58,790
i begreppet cent.

1576
01:17:58,790 --> 01:18:01,480
>> Men om du lägger upp alla dessa
små, små, små siffror igen,

1577
01:18:01,480 --> 01:18:04,960
och igen, och igen, kan du, som i
hans fall, göra en bra summa pengar.

1578
01:18:04,960 --> 01:18:08,010
>> Samma idé var rippat av
en senare, men ändå nu äldre

1579
01:18:08,010 --> 01:18:10,500
film, kallad Office Space,
där killarna i den filmen,

1580
01:18:10,500 --> 01:18:13,501
gjorde samma sak, skruvas upp
helt slutade med alldeles för mycket

1581
01:18:13,501 --> 01:18:14,666
pengar på sitt bankkonto.

1582
01:18:14,666 --> 01:18:15,800
Det var alla mycket misstänksam.

1583
01:18:15,800 --> 01:18:19,290
Men i slutet av dagen,
imprecision är runt omkring oss.

1584
01:18:19,290 --> 01:18:22,240
>> Och det också kan vara
skrämmande fallet.

1585
01:18:22,240 --> 01:18:25,590
Det visar sig att Superman 3
och Kontor åt sidan, där

1586
01:18:25,590 --> 01:18:28,460
kan vara någon mycket verklig
världs förgreningar

1587
01:18:28,460 --> 01:18:32,290
av verkligheten i oprecis
representation av data

1588
01:18:32,290 --> 01:18:34,770
att även vi människor till
denna dag inte nödvändigtvis

1589
01:18:34,770 --> 01:18:38,230
förstå liksom vi borde,
eller komma ihåg så ofta som vi borde.

1590
01:18:38,230 --> 01:18:42,950
Och faktiskt, är följande klipp
från en titt på några mycket verkliga världen

1591
01:18:42,950 --> 01:18:47,730
förgreningar vad händer om du
inte uppskattar vaghet som

1592
01:18:47,730 --> 01:18:50,065
kan hända i antal representation.

1593
01:18:50,065 --> 01:18:51,300
>> [VIDEOUPPSPELNING]

1594
01:18:51,300 --> 01:18:55,620
>> -Datorer, Vi har alla kommit att acceptera
de ofta frustrerande problem som

1595
01:18:55,620 --> 01:19:00,310
gå med them-- buggar, virus,
och programvara glapp,

1596
01:19:00,310 --> 01:19:03,130
för små priser för att betala
för att underlätta.

1597
01:19:03,130 --> 01:19:07,800
Men i högteknologiska och hög hastighet
militära och rymdprogram applikationer,

1598
01:19:07,800 --> 01:19:12,800
den minsta problemet kan
förstoras till katastrof.

1599
01:19:12,800 --> 01:19:18,900
>> Den 4 juni 1996, forskare beredd
att lansera en obemannad Ariane 5-raketen.

1600
01:19:18,900 --> 01:19:21,220
Det bar vetenskaplig
satelliter utformade

1601
01:19:21,220 --> 01:19:24,600
att fastställa exakt hur
jordens magnetfält samverkar

1602
01:19:24,600 --> 01:19:27,410
med solvinden.

1603
01:19:27,410 --> 01:19:30,800
Raketen byggdes för
Europeiska rymdorganisationen,

1604
01:19:30,800 --> 01:19:34,370
och lyfte från sin anläggning
vid kusten i Franska Guyana.

1605
01:19:34,370 --> 01:19:37,540
>> -at Ca 37 sekunder in
flygningen, de först

1606
01:19:37,540 --> 01:19:39,270
märkt något gick fel.

1607
01:19:39,270 --> 01:19:42,250
Munstyckena var svängbar i
ett sätt som de borde verkligen inte.

1608
01:19:42,250 --> 01:19:46,580
Omkring 40 sekunder in i flygningen,
klart, fordonet var i trubbel.

1609
01:19:46,580 --> 01:19:48,850
>> Och det är när de gjorde
ett beslut att förstöra det.

1610
01:19:48,850 --> 01:19:52,780
Utbudet säkerhetsansvarige, med
enorma tarmar, tryckte på knappen,

1611
01:19:52,780 --> 01:19:58,150
blåste upp raketen, innan den kunde
blivit en fara för den allmänna säkerheten.

1612
01:19:58,150 --> 01:20:01,060
>> -detta Var jungfrun
resan av Ariane 5.

1613
01:20:01,060 --> 01:20:03,960
Och dess förstörelse tog
placera beror på ett fel

1614
01:20:03,960 --> 01:20:05,822
inbäddad i raketens programvara.

1615
01:20:05,822 --> 01:20:08,280
-Den Problem på Ariane var
att det fanns ett antal som

1616
01:20:08,280 --> 01:20:10,600
krävs 64 bitar för att uttrycka.

1617
01:20:10,600 --> 01:20:13,590
Och de ville konvertera
den till en 16-bitars nummer.

1618
01:20:13,590 --> 01:20:15,610
De antog att
antal aldrig gå

1619
01:20:15,610 --> 01:20:20,980
att vara mycket stor, att de flesta av dem
siffror i en 64-bitars tal var nollor.

1620
01:20:20,980 --> 01:20:22,440
De hade fel.

1621
01:20:22,440 --> 01:20:25,060
>> -Den Oförmåga en
mjukvaruprogram för att acceptera

1622
01:20:25,060 --> 01:20:29,510
den typ av antalet som genereras av
en annan var vid roten av misslyckande.

1623
01:20:29,510 --> 01:20:34,350
Mjukvaruutveckling hade blivit en
mycket kostsam del av ny teknik.

1624
01:20:34,350 --> 01:20:38,140
Ariane raketen har varit mycket
framgångsrik, så mycket av programvaran

1625
01:20:38,140 --> 01:20:41,550
skapas för det var också
används i Ariane 5.

1626
01:20:41,550 --> 01:20:47,940
>> -Den Grundläggande problemet var att Ariane
5 var snabbare, accelereras snabbare.

1627
01:20:47,940 --> 01:20:51,450
Och programmet inte hade
stod för det.

1628
01:20:51,450 --> 01:20:55,060
>> -Den Förstörelse av raketen
var en enorm ekonomisk katastrof,

1629
01:20:55,060 --> 01:20:58,790
allt på grund av en minut programfel.

1630
01:20:58,790 --> 01:21:01,210
Men detta var inte den första
tidsproblem omvandlingsdata

1631
01:21:01,210 --> 01:21:04,820
hade plågat modern raketteknik.

1632
01:21:04,820 --> 01:21:08,050
>> -I 1991, med start
av det första Gulfkriget,

1633
01:21:08,050 --> 01:21:10,570
Patriot Missile
upplevt en liknande typ

1634
01:21:10,570 --> 01:21:12,800
av antalet konvertering problem.

1635
01:21:12,800 --> 01:21:16,090
Och som ett resultat, 28 personer,
28 amerikanska soldater,

1636
01:21:16,090 --> 01:21:19,080
dödades, och omkring
100 andra skadades,

1637
01:21:19,080 --> 01:21:22,780
när Patriot, som var tänkt
för att skydda mot inkommande Scuds,

1638
01:21:22,780 --> 01:21:25,830
misslyckades med att avfyra en missil.

1639
01:21:25,830 --> 01:21:31,670
>> -När Irak invaderade Kuwait, och Amerika
lanserades Desert Storm i början av 1991,

1640
01:21:31,670 --> 01:21:35,780
Patriot Missile batterier utplacerades
att skydda Saudi Arabien och Israel

1641
01:21:35,780 --> 01:21:39,230
från irakiska Scud missiler.

1642
01:21:39,230 --> 01:21:43,810
Patriot är en amerikansk medium-range
yta för att luftsystemet, tillverkat

1643
01:21:43,810 --> 01:21:45,770
från Raytheon företaget.

1644
01:21:45,770 --> 01:21:52,340
>> -Den Storlek Patriot jaktplan
själv är om ungefär 20 fot lång.

1645
01:21:52,340 --> 01:21:55,230
Och den väger omkring 2000 pounds.

1646
01:21:55,230 --> 01:21:59,320
Och det bär en stridsspets av ca,
Jag tror att det är ungefär 150 pounds.

1647
01:21:59,320 --> 01:22:03,930
Och stridsspetsen i sig är
ett sprängämne, som

1648
01:22:03,930 --> 01:22:07,330
har fragment runt den.

1649
01:22:07,330 --> 01:22:11,680
Höljet av stridsspetsen är
utformad för att agera som hagel.

1650
01:22:11,680 --> 01:22:14,110
>> -de Missiler genom
fyra per container,

1651
01:22:14,110 --> 01:22:17,130
och transporteras genom ett semitrailer.

1652
01:22:17,130 --> 01:22:24,930
>> -Den Patriot anti-missilsystem
går tillbaka åtminstone 20 år nu.

1653
01:22:24,930 --> 01:22:28,420
Den var ursprungligen avsedd
som ett luftvärnsrobot

1654
01:22:28,420 --> 01:22:30,720
att skjuta ner fientliga flygplan.

1655
01:22:30,720 --> 01:22:34,500
I det första Gulfkriget,
när detta krig kom,

1656
01:22:34,500 --> 01:22:39,745
armén ville använda den för att
skjuta ner Scuds, inte flygplan.

1657
01:22:39,745 --> 01:22:43,620
>> Den irakiska flygvapnet var
inte så mycket av ett problem.

1658
01:22:43,620 --> 01:22:46,670
Men armén var orolig Scuds.

1659
01:22:46,670 --> 01:22:50,170
Och så försökte de att
uppgradera Patriot.

1660
01:22:50,170 --> 01:22:52,800
>> -Intercepting En fiende
missil reser på mach 5

1661
01:22:52,800 --> 01:22:55,830
skulle vara utmanande nog.

1662
01:22:55,830 --> 01:22:58,490
Men när Patriot
fördes i bruk,

1663
01:22:58,490 --> 01:23:02,860
armén var inte medveten om en
Iraks ändring som gjorde

1664
01:23:02,860 --> 01:23:05,930
deras Scuds nästan omöjligt att slå.

1665
01:23:05,930 --> 01:23:10,740
>> -Vad Hände är Scuds som
kom in var instabil.

1666
01:23:10,740 --> 01:23:11,692
De vinglar.

1667
01:23:11,692 --> 01:23:14,910
Anledningen till detta var
irakierna, i syfte

1668
01:23:14,910 --> 01:23:18,280
att få 600 kilometer
ut ur en 300 kilometer

1669
01:23:18,280 --> 01:23:21,700
missiler, tog vikt
ut ur den främre stridsspetsen.

1670
01:23:21,700 --> 01:23:23,390
De gjorde stridsspetsen lättare.

1671
01:23:23,390 --> 01:23:27,330
>> Så nu Patriot är
försöker komma på Scud.

1672
01:23:27,330 --> 01:23:30,230
Och för det mesta, det
överväldigande majoritet av tiden,

1673
01:23:30,230 --> 01:23:32,940
det skulle bara flyga av Scud.

1674
01:23:32,940 --> 01:23:37,260
När Patriot systemansvariga
insåg Patriot missade sitt mål,

1675
01:23:37,260 --> 01:23:41,690
de detonerade Patriot stridsspets
att undvika eventuella förluster om det

1676
01:23:41,690 --> 01:23:44,570
tilläts att falla till marken.

1677
01:23:44,570 --> 01:23:48,790
>> -Det Var vad de flesta människor såg,
de stora eldklot på himlen,

1678
01:23:48,790 --> 01:23:54,550
och missförstås som
avlyssningar av Scud stridsspetsar.

1679
01:23:54,550 --> 01:23:56,630
>> -Även I natt
himmel, verkade Patriots

1680
01:23:56,630 --> 01:24:00,370
vara framgångsrikt
förstöra Scuds, på Dhahran,

1681
01:24:00,370 --> 01:24:03,360
det kan finnas några misstag
om dess prestanda.

1682
01:24:03,360 --> 01:24:07,970
Där Patriot radarsystem
förlorat kontakten med en inkommande Scud,

1683
01:24:07,970 --> 01:24:10,721
och aldrig lanserats på grund
till en programvara fel.

1684
01:24:10,721 --> 01:24:14,090

1685
01:24:14,090 --> 01:24:18,940
Det var israelerna som först upptäcktes
att ju längre systemet var på,

1686
01:24:18,940 --> 01:24:22,690
Ju större skillnaden
blev, på grund av att en klocka inbäddad

1687
01:24:22,690 --> 01:24:24,810
i systemets dator.

1688
01:24:24,810 --> 01:24:28,210
>> -Om Två veckor före
tragedin i Dhahran,

1689
01:24:28,210 --> 01:24:30,770
israel rapporteras till
Försvarsdepartementet

1690
01:24:30,770 --> 01:24:32,590
att systemet skulle förlora tid.

1691
01:24:32,590 --> 01:24:35,360
Efter cirka åtta timmar eller löpning,
de märkte att systemet

1692
01:24:35,360 --> 01:24:37,720
blev märkbart mindre exakt.

1693
01:24:37,720 --> 01:24:41,900
Försvarsdepartementet svarade med
berättar alla Patriot batterier

1694
01:24:41,900 --> 01:24:44,950
att inte lämna systemen
på under en lång tid.

1695
01:24:44,950 --> 01:24:49,160
De sa aldrig vad en lång tid was--
åtta timmar, 10 timmar, 1000 timmar.

1696
01:24:49,160 --> 01:24:51,360
Ingen visste.

1697
01:24:51,360 --> 01:24:53,380
>> -Den Patriot batteri
stationerade vid barackerna

1698
01:24:53,380 --> 01:24:58,350
vid Dhahran och dess bristfälliga inre
klocka hade varit på över 100 timmar

1699
01:24:58,350 --> 01:25:01,670
på kvällen den 25 februari.

1700
01:25:01,670 --> 01:25:05,917
>> -det Spårade tid med en noggrannhet
på ungefär en tiondels sekund.

1701
01:25:05,917 --> 01:25:08,000
Nu, en tiondels sekund
är ett intressant,

1702
01:25:08,000 --> 01:25:11,920
eftersom det kan inte uttryckas
i binär exakt, vilket

1703
01:25:11,920 --> 01:25:16,820
betyder det inte kan uttryckas exakt
i varje modern digital dator.

1704
01:25:16,820 --> 01:25:18,540
Det är svårt att tro.

1705
01:25:18,540 --> 01:25:21,210
>> Men använder detta som ett exempel.

1706
01:25:21,210 --> 01:25:23,540
Låt oss ta nummer tredjedel.

1707
01:25:23,540 --> 01:25:27,350
En tredjedel kan inte vara
uttrycks i decimal exakt.

1708
01:25:27,350 --> 01:25:32,080
En tredjedel är 0,333
pågått i oändlighet.

1709
01:25:32,080 --> 01:25:36,480
>> Det finns inget sätt att göra det med
absolut noggrannhet i decimal.

1710
01:25:36,480 --> 01:25:39,560
Det är precis den typ av problem
som hände i Patriot.

1711
01:25:39,560 --> 01:25:44,100
Ju längre systemet sprang, den
värre tidsfelet blev.

1712
01:25:44,100 --> 01:25:48,890
>> -Efter 100 timmars drift
fel i tiden var endast omkring en tredjedel

1713
01:25:48,890 --> 01:25:50,600
av en sekund.

1714
01:25:50,600 --> 01:25:54,210
Men när det gäller att rikta en
missil färdas i Mach 5,

1715
01:25:54,210 --> 01:25:58,710
Det resulterade i en spårning
fel på över 600 meter.

1716
01:25:58,710 --> 01:26:02,120
Det skulle vara ett allvarligt fel
för soldaterna på vad

1717
01:26:02,120 --> 01:26:08,940
hände är en Scud lansering var
detekteras genom tidig varning satelliter

1718
01:26:08,940 --> 01:26:12,860
och de visste att Scud var
kommer i sin allmänna riktning.

1719
01:26:12,860 --> 01:26:15,320
De visste inte var det var på väg.

1720
01:26:15,320 --> 01:26:18,250
>> -Det Var nu upp till radarn
komponent i Patriot-systemet

1721
01:26:18,250 --> 01:26:23,190
försvara Dhahran att lokalisera och hålla
koll på inkommande fientliga missiler.

1722
01:26:23,190 --> 01:26:24,609
>> -Den Radar var mycket smart.

1723
01:26:24,609 --> 01:26:26,650
Det skulle faktiskt spåra
positionen av Scud,

1724
01:26:26,650 --> 01:26:30,350
och sedan förutsäga var det förmodligen
skulle bli nästa gång radarn skickas

1725
01:26:30,350 --> 01:26:31,420
en puls ut.

1726
01:26:31,420 --> 01:26:33,110
Som kallades en avståndsfålla.

1727
01:26:33,110 --> 01:26:37,660
>> -Då, När Patriot
beslutar tillräckligt med tid har

1728
01:26:37,660 --> 01:26:42,450
passerade att gå tillbaka och kontrollera nästa
Platsen för denna detekterade objektet,

1729
01:26:42,450 --> 01:26:43,600
det går tillbaka.

1730
01:26:43,600 --> 01:26:48,650
Så när det gick tillbaka till fel
plats, då ser det inget objekt.

1731
01:26:48,650 --> 01:26:52,160
Och det beslutar att det inte fanns någon
objekt, var det en falsk detektering,

1732
01:26:52,160 --> 01:26:53,930
och droppar spåret.

1733
01:26:53,930 --> 01:26:57,030
>> -Den Inkommande Scud försvann
från radarskärmen.

1734
01:26:57,030 --> 01:27:00,260
Och sekunder senare, det
smällde in i baracker.

1735
01:27:00,260 --> 01:27:06,150
Den Scud dödade 28, och var den sista
en sköt under det första Gulfkriget.

1736
01:27:06,150 --> 01:27:11,960
>> Tragiskt nog, den uppdaterade programvaran
anlände till Dhahran följande dag.

1737
01:27:11,960 --> 01:27:14,930
Programvaran fel hade
varit fast, stängning

1738
01:27:14,930 --> 01:27:19,806
ett kapitel i den oroliga
historia Patriot missil.

1739
01:27:19,806 --> 01:27:20,729
>> [VIDEOUPPSPELNING]

1740
01:27:20,729 --> 01:27:23,520
DAVID J. MALAN: Så detta är allt för
säger att dessa frågor av spill

1741
01:27:23,520 --> 01:27:25,860
och vaghet är alltför verkliga.

1742
01:27:25,860 --> 01:27:26,920
Så hur kom vi hit?

1743
01:27:26,920 --> 01:27:28,895
Vi började med att bara prata om printf.

1744
01:27:28,895 --> 01:27:31,270
Återigen, den här funktionen som
skriver något på skärmen,

1745
01:27:31,270 --> 01:27:33,450
och vi införde därefter
några andra funktioner

1746
01:27:33,450 --> 01:27:34,945
från den så kallade CS50 bibliotek.

1747
01:27:34,945 --> 01:27:36,910
Och vi kommer att fortsätta att
se dessa i sinom tid.

1748
01:27:36,910 --> 01:27:40,760
Och vi, i synnerhet, används get sträng,
och få int, och nu också få flyta,

1749
01:27:40,760 --> 01:27:44,410
och ytterligare andra kommer fortfarande att vi möter
och använda oss snart.

1750
01:27:44,410 --> 01:27:47,220
>> Men ibland, har
vi redan sett ett behov

1751
01:27:47,220 --> 01:27:50,520
att lagra vad dessa funktioner handen tillbaka?

1752
01:27:50,520 --> 01:27:52,920
De lämnar oss tillbaka en sträng,
eller en int eller en flottör.

1753
01:27:52,920 --> 01:27:56,070
Och ibland måste vi sätta det
sträng, eller int eller float, någonstans.

1754
01:27:56,070 --> 01:28:00,100
>> Och lagra dessa saker, minns bara
som i Scratch, har vi variabler.

1755
01:28:00,100 --> 01:28:03,260
Men till skillnad från i Scratch,
i C vi har typerna

1756
01:28:03,260 --> 01:28:05,530
av variables-- uppgifter
typer, mera generally--

1757
01:28:05,530 --> 01:28:08,640
bland dem, en sträng, en int en
flyta, och dessa andra fortfarande.

1758
01:28:08,640 --> 01:28:12,321
>> Och så när vi deklarerar variabler i C,
vi måste förklara våra datatyper.

1759
01:28:12,321 --> 01:28:14,820
Detta är inte något vi ska
måste göra senare i terminen

1760
01:28:14,820 --> 01:28:16,810
som vi övergången till andra språk.

1761
01:28:16,810 --> 01:28:19,610
Men nu behöver vi
till a priori i förväg,

1762
01:28:19,610 --> 01:28:24,370
förklara till datorn vilken typ
variabel vi vill att det ska ge oss.

1763
01:28:24,370 --> 01:28:27,290
>> Nu, under tiden, för att skriva ut
dessa typer av datatyper,

1764
01:28:27,290 --> 01:28:29,570
Vi måste tala om printf vad som väntar.

1765
01:28:29,570 --> 01:28:32,450
Och vi såg procent s för strängar,
och procent i för heltal,

1766
01:28:32,450 --> 01:28:33,790
och några andra redan.

1767
01:28:33,790 --> 01:28:37,237
Och de är helt enkelt krav
för visuell presentation

1768
01:28:37,237 --> 01:28:38,070
av denna information.

1769
01:28:38,070 --> 01:28:42,080
>> Och var och en av dessa kan faktiskt vara
parametrized eller fixade på något sätt,

1770
01:28:42,080 --> 01:28:45,370
Om du vill att ytterligare kontroll
den typ av produktion som du får.

1771
01:28:45,370 --> 01:28:49,604
Och i själva verket visar det sig att det inte bara
är det omvända sned n för en ny rad.

1772
01:28:49,604 --> 01:28:52,520
Det finns något annat som kallas backslash
r för en vagnretur, som

1773
01:28:52,520 --> 01:28:54,360
är mer besläktad med en
old school skrivmaskin,

1774
01:28:54,360 --> 01:28:57,690
och även Windows använts under många år.

1775
01:28:57,690 --> 01:28:59,690
>> Det finns bakåtstreck t för flikar.

1776
01:28:59,690 --> 01:29:03,170
Det visade sig, att om du vill
dubbla citattecken inne i en sträng,

1777
01:29:03,170 --> 01:29:05,000
Minns att vi har använt
dubbla citat dubbel

1778
01:29:05,000 --> 01:29:07,900
citationstecken på vänster och höger
ändarna av våra strängar hittills.

1779
01:29:07,900 --> 01:29:09,420
Som verkar för att förvirra saker.

1780
01:29:09,420 --> 01:29:12,503
>> Om du vill lägga en dubbel citat i
mitt i en string-- och, faktiskt,

1781
01:29:12,503 --> 01:29:13,670
Det är förvirrande att se.

1782
01:29:13,670 --> 01:29:17,120
Och så du måste fly, så att
tala, en dubbel citat med något

1783
01:29:17,120 --> 01:29:18,860
som, bokstavligen, bakstreck citat.

1784
01:29:18,860 --> 01:29:20,230
Och det finns några andra fortfarande.

1785
01:29:20,230 --> 01:29:24,540
Och vi kommer att se mer av dem
vid verklig användning inom kort.

1786
01:29:24,540 --> 01:29:27,930
>> Så låt oss nu övergå från
data och representation,

1787
01:29:27,930 --> 01:29:30,820
och aritmetiska operatorer, alla
varav gav oss några byggnad

1788
01:29:30,820 --> 01:29:32,070
block som man kan spela.

1789
01:29:32,070 --> 01:29:34,481
Men nu ska vi faktiskt ge
oss resten av vokabulären

1790
01:29:34,481 --> 01:29:36,230
att vi redan hade
förra veckan med Scratch

1791
01:29:36,230 --> 01:29:39,350
genom att ta en titt på några andra
konstruktioner i C- inte alla av dem.

1792
01:29:39,350 --> 01:29:41,680
Men de idéer som vi är
på väg att se egentligen bara

1793
01:29:41,680 --> 01:29:45,610
att betona översättning från
ett språk, Scratch, till en annan, C.

1794
01:29:45,610 --> 01:29:48,470
>> Och under tiden kommer vi plocka upp
fler verktyg för vår verktygslåda,

1795
01:29:48,470 --> 01:29:49,820
så att säga, syntaktiskt.

1796
01:29:49,820 --> 01:29:54,190
Och faktiskt, ser du att de idéer
är nu ganska bekant från förra veckan.

1797
01:29:54,190 --> 01:29:55,200
Så låt oss göra detta.

1798
01:29:55,200 --> 01:29:58,870
>> Låt oss gå vidare och piska upp ett program
som faktiskt använder vissa uttryck,

1799
01:29:58,870 --> 01:30:00,720
ett booleskt uttryck.

1800
01:30:00,720 --> 01:30:02,810
Låt mig gå vidare här
och skapa en ny fil.

1801
01:30:02,810 --> 01:30:06,090
Jag kallar detta condition.c.

1802
01:30:06,090 --> 01:30:09,350
>> Låt mig gå vidare och
inkludera CS50 biblioteket.

1803
01:30:09,350 --> 01:30:12,640
Och låt mig gå vidare och inkludera
standard io.h för våra funktioner,

1804
01:30:12,640 --> 01:30:14,690
och printf och mer respektive.

1805
01:30:14,690 --> 01:30:18,900
Låt mig ge mig själv att text av
int main tomrum, vars förklaring vi ska

1806
01:30:18,900 --> 01:30:20,360
komma tillbaka till i framtiden.

1807
01:30:20,360 --> 01:30:23,820
>> Låt mig nu gå vidare och ge
själv en int via get int.

1808
01:30:23,820 --> 01:30:25,970
Låt mig gå vidare och göra det.

1809
01:30:25,970 --> 01:30:30,150
Jag vill säga om jag är less-- låt oss
skilja mellan positiv, negativ,

1810
01:30:30,150 --> 01:30:31,260
eller nollvärden.

1811
01:30:31,260 --> 01:30:36,630
>> Så om jag är mindre än noll, låt mig
bara har detta program helt enkelt säga,

1812
01:30:36,630 --> 01:30:42,370
negativ, omvänt snedstreck n, annars
om i är större än noll.

1813
01:30:42,370 --> 01:30:47,030
Nu är jag naturligtvis kommer att säga
printf positiv, omvänt snedstreck n.

1814
01:30:47,030 --> 01:30:50,690
Och då annars if-- jag kunde göra detta.

1815
01:30:50,690 --> 01:30:53,410
>> Jag skulle kunna göra om jag är lika med 0.

1816
01:30:53,410 --> 01:30:55,840
Men jag skulle göra på
minst ett misstag redan.

1817
01:30:55,840 --> 01:30:59,480
Minns att likhetstecknet är
inte lika, eftersom vi människor vet det.

1818
01:30:59,480 --> 01:31:01,010
>> Men det är uppdraget operatör.

1819
01:31:01,010 --> 01:31:05,640
Och vi vill inte ta 0 på
höger och placerade den i i till vänster.

1820
01:31:05,640 --> 01:31:11,810
Så för att undvika förvirring, eller
kanske missbruk av likhetstecknet,

1821
01:31:11,810 --> 01:31:14,740
människor beslutade för några år sedan
att i många programmeringsspråk

1822
01:31:14,740 --> 01:31:18,000
när du vill kontrollera för jämställdhet
mellan vänster och höger,

1823
01:31:18,000 --> 01:31:19,635
du faktiskt använder lika jämlikar.

1824
01:31:19,635 --> 01:31:21,010
Så du träffa likhetstecknet två gånger.

1825
01:31:21,010 --> 01:31:25,600
När du vill tilldela från höger
till vänster, använder du en enda likhetstecken.

1826
01:31:25,600 --> 01:31:29,360
Så vi kunde göra this-- annat
om jag är lika är lika med noll.

1827
01:31:29,360 --> 01:31:31,710
>> Jag kunde gå och
öppna mina klammerparenteser,

1828
01:31:31,710 --> 01:31:36,087
och säga, printf 0, bakstreck n, gjort.

1829
01:31:36,087 --> 01:31:38,170
Men kom ihåg hur dessa
gafflar i vägen kan fungera.

1830
01:31:38,170 --> 01:31:39,836
Och egentligen, bara tänka på logik.

1831
01:31:39,836 --> 01:31:41,510
i är ett tal.

1832
01:31:41,510 --> 01:31:43,320
Det är ett heltal, specifikt.

1833
01:31:43,320 --> 01:31:48,600
Och det betyder att det kommer att bli mindre
än 0 eller större än 0, eller 0.

1834
01:31:48,600 --> 01:31:51,600
Så det är typ av detta
underförstådd normalfallet.

1835
01:31:51,600 --> 01:31:54,920
>> Och så vi kunde, precis som
Scratch, avstå från else if,

1836
01:31:54,920 --> 01:31:55,747
och bara säga annat.

1837
01:31:55,747 --> 01:31:57,830
Logiskt, om du
programmerare vet att det finns bara

1838
01:31:57,830 --> 01:32:01,635
tre skopor i vilken en
scenario kan fall-- den första,

1839
01:32:01,635 --> 01:32:03,510
den andra, eller den tredje
i detta case-- inte

1840
01:32:03,510 --> 01:32:07,100
bry lägga till ytterligare precision
och den ytterligare logiken där.

1841
01:32:07,100 --> 01:32:09,690
Bara gå vidare med
normalfallet här om annat.

1842
01:32:09,690 --> 01:32:11,950
>> Nu ska vi gå vidare
efter att ha sparat detta gör

1843
01:32:11,950 --> 01:32:15,760
betingelser dot slash conditions--
inte en stor användargränssnitt,

1844
01:32:15,760 --> 01:32:18,914
eftersom jag inte föranledde
användare, som jag nämnde tidigare.

1845
01:32:18,914 --> 01:32:19,580
Men det är bra.

1846
01:32:19,580 --> 01:32:20,454
Vi kommer att hålla det enkelt.

1847
01:32:20,454 --> 01:32:21,890
Låt oss försöka nummer 42.

1848
01:32:21,890 --> 01:32:23,240
Och det är positivt.

1849
01:32:23,240 --> 01:32:26,120
Låt oss försöka antalet
negativ 42, negativt.

1850
01:32:26,120 --> 01:32:28,244
>> Låt oss försöka värdet 0.

1851
01:32:28,244 --> 01:32:29,160
Och faktiskt, det fungerar.

1852
01:32:29,160 --> 01:32:33,900
Nu ser du med problem innan
långa test saker tre gånger,

1853
01:32:33,900 --> 01:32:34,980
förmodligen inte tillräckliga.

1854
01:32:34,980 --> 01:32:37,438
Du vill förmodligen testa några
större siffror, några mindre

1855
01:32:37,438 --> 01:32:40,520
siffror, några hörn fall, som
vi kommer att beskriva dem.

1856
01:32:40,520 --> 01:32:42,500
>> Men nu, är detta en
ganska enkelt program.

1857
01:32:42,500 --> 01:32:45,160
Och jag är ganska säker, logiskt,
att den faller i tre fall.

1858
01:32:45,160 --> 01:32:49,360
Och faktiskt, trots att vi bara
fokuserade på de potentiella nackdelar

1859
01:32:49,360 --> 01:32:53,480
av brist på precision och spill, i
verklighet där många av CS50 problem,

1860
01:32:53,480 --> 01:32:56,000
Vi kommer inte att oroa
om, hela tiden,

1861
01:32:56,000 --> 01:32:59,050
dessa frågor av spill och
imprecision, därför att, i själva verket, i C,

1862
01:32:59,050 --> 01:33:01,889
det är faktiskt inte så
lätt att undvika dessa saker.

1863
01:33:01,889 --> 01:33:04,180
Om du vill räkna upp
större, och större, och större,

1864
01:33:04,180 --> 01:33:07,510
Det visar sig att det finns tekniker som du
kan använda, ofta med saker som kallas

1865
01:33:07,510 --> 01:33:11,240
bibliotek, samlingar av kod, som
andra människor skrev att du kan använda,

1866
01:33:11,240 --> 01:33:13,910
och andra språk som
Java och andra, faktiskt

1867
01:33:13,910 --> 01:33:15,800
göra det mycket lättare
att räkna ännu högre.

1868
01:33:15,800 --> 01:33:19,810
Så det är verkligen en del av dessa faror
en funktion av det språk du använder.

1869
01:33:19,810 --> 01:33:22,710
Och under de kommande veckorna kommer vi
se hur farligt C verkligen

1870
01:33:22,710 --> 01:33:24,950
kan vara om du inte använder den på rätt sätt.

1871
01:33:24,950 --> 01:33:27,610
Men därifrån, och med
Python och JavaScript kommer

1872
01:33:27,610 --> 01:33:32,620
Vi lager på några ytterligare skydd,
och köra färre av dessa risker.

1873
01:33:32,620 --> 01:33:35,820
>> Så låt oss göra lite mer
intressant logik i vårt program.

1874
01:33:35,820 --> 01:33:39,110
Så låt mig gå vidare och skapa
ett program som kallas Logical

1875
01:33:39,110 --> 01:33:43,804
bara så att jag kan spela med några
faktiska logik, logical.c.

1876
01:33:43,804 --> 01:33:46,870
Jag ska bara kopiera och klistra in några
kod från tidigare så jag kommer tillbaka

1877
01:33:46,870 --> 01:33:49,950
till denna fina utgångspunkten.

1878
01:33:49,950 --> 01:33:53,980
>> Låt mig den här gången göra char C. jag
kommer att ge den ett namn C

1879
01:33:53,980 --> 01:33:58,510
bara för att det är konventionellt,
får ett tecken från användaren.

1880
01:33:58,510 --> 01:34:00,730
Och låt oss låtsas som
Jag genomföra en del

1881
01:34:00,730 --> 01:34:04,130
av det Rm program, ta bort
programmet innan det meddelade användaren

1882
01:34:04,130 --> 01:34:05,400
för att ta bort en fil.

1883
01:34:05,400 --> 01:34:06,750
Hur kan vi göra detta?

1884
01:34:06,750 --> 01:34:11,090
>> Jag vill säga, om C är lika med
lika, citationstecken unquote,

1885
01:34:11,090 --> 01:34:16,304
y, då jag kommer att anta
att användaren har valt ja.

1886
01:34:16,304 --> 01:34:17,470
Jag kommer bara att skriva ut ja.

1887
01:34:17,470 --> 01:34:19,440
Om det faktiskt skriva
borttagning programmet,

1888
01:34:19,440 --> 01:34:21,420
vi kunde ta bort filen
med fler rader kod.

1889
01:34:21,420 --> 01:34:22,461
Men vi kommer att hålla det enkelt.

1890
01:34:22,461 --> 01:34:25,950

1891
01:34:25,950 --> 01:34:31,250
>> Annars om c är lika med lika n--
och nu här, jag kommer att säga,

1892
01:34:31,250 --> 01:34:32,980
användaren måste ha inneburit någon.

1893
01:34:32,980 --> 01:34:34,360
Och då annars, vet du vad?

1894
01:34:34,360 --> 01:34:36,200
Jag vet inte vad
användaren kommer att skriva.

1895
01:34:36,200 --> 01:34:38,533
Så jag ska bara säga att
det är ett fel, oavsett

1896
01:34:38,533 --> 01:34:40,070
han eller hon faktiskt skrivit.

1897
01:34:40,070 --> 01:34:41,180
>> Så vad händer här?

1898
01:34:41,180 --> 01:34:44,530
Det finns en grundläggande skillnad
kontra vad jag har gjort tidigare.

1899
01:34:44,530 --> 01:34:49,300
Citationstecken, citationstecken, dubbel
citat, och ändå enkla citationstecken,

1900
01:34:49,300 --> 01:34:50,170
apostrof.

1901
01:34:50,170 --> 01:34:52,860
Det visar sig i C, att när
du vill skriva en sträng,

1902
01:34:52,860 --> 01:34:56,680
du använder citationstecken, precis som vi har
använt hela tiden med printf.

1903
01:34:56,680 --> 01:35:02,030
>> Men om du vill ta itu med bara en
enstaka tecken, en så kallad röding,

1904
01:35:02,030 --> 01:35:03,780
då du faktiskt använder apostrof.

1905
01:35:03,780 --> 01:35:05,450
De av er som har programmerat
innan, kanske du inte har

1906
01:35:05,450 --> 01:35:07,850
var tvungen att oroa sig för detta
åtskillnad på vissa språk.

1907
01:35:07,850 --> 01:35:09,450
I C, spelar det någon roll.

1908
01:35:09,450 --> 01:35:12,560
Och så när jag får en röding och jag vill
att jämföra det röding med hjälp av jämlikar

1909
01:35:12,560 --> 01:35:18,350
lika med några brev som y eller n, gör jag,
faktiskt måste ha enkla citattecken.

1910
01:35:18,350 --> 01:35:19,770
>> Nu ska vi gå vidare och göra det.

1911
01:35:19,770 --> 01:35:26,180
Låt oss gå vidare och gör
logiska dot slash logiskt.

1912
01:35:26,180 --> 01:35:27,305
Och nu är jag som efterfrågas.

1913
01:35:27,305 --> 01:35:30,638
Så, förmodligen, en bättre användarupplevelse
skulle faktiskt säga vad jag ska göra här.

1914
01:35:30,638 --> 01:35:33,030
Men jag ska bara blint
säger y för ja, OK, trevligt.

1915
01:35:33,030 --> 01:35:35,780
>> Låt oss köra den igen, n för nej, trevlig.

1916
01:35:35,780 --> 01:35:39,610
Antag som vissa människor jag känner,
mina skiftlåstangenten på alltför ofta.

1917
01:35:39,610 --> 01:35:43,740
Så jag gör huvudstad Y anger, fel.

1918
01:35:43,740 --> 01:35:46,130
OK, det är inte precis vad jag förväntat mig.

1919
01:35:46,130 --> 01:35:48,170
Faktum är att datorn
gör bokstavligen vad

1920
01:35:48,170 --> 01:35:51,794
Jag sa det till do-- leta efter
gemener y och gemener n.

1921
01:35:51,794 --> 01:35:53,960
Detta känns inte som bra
användarupplevelse, men.

1922
01:35:53,960 --> 01:35:59,010
Låt mig be om och ta emot
antingen gemener eller versaler.

1923
01:35:59,010 --> 01:36:02,090
Så visar det sig, kanske du vill
att säga något i stil i Scratch,

1924
01:36:02,090 --> 01:36:08,150
som bokstavligt eller C är lika med
lika kapital enda noterade y.

1925
01:36:08,150 --> 01:36:11,400
Det visade sig, inte C inte har
detta bokstav sökord eller.

1926
01:36:11,400 --> 01:36:12,880
>> Men det har två vertikala streck.

1927
01:36:12,880 --> 01:36:15,463
Du måste hålla Shift vanligtvis
Om du använder ett amerikanskt tangentbord,

1928
01:36:15,463 --> 01:36:18,910
och slog det lodräta strecket
nyckel ovanför returtangenten.

1929
01:36:18,910 --> 01:36:22,410
Men denna lodrätt streck
vertikalt streck betyder eller.

1930
01:36:22,410 --> 01:36:26,220
>> Om däremot, vi ville
att säga och liksom i Scratch,

1931
01:36:26,220 --> 01:36:28,180
vi kunde göra-tecken et-tecken.

1932
01:36:28,180 --> 01:36:31,330
Det gör ingen logisk mening här,
eftersom en människa kunde omöjligen

1933
01:36:31,330 --> 01:36:37,110
har skrivit både y och gemener y
och kapital Y som samma karaktär.

1934
01:36:37,110 --> 01:36:39,470
Så eller är vad vi tänker här.

1935
01:36:39,470 --> 01:36:46,280
>> Så om jag gör det på båda ställena, eller c
lika är lika huvudstad N, nu kör,

1936
01:36:46,280 --> 01:36:49,390
göra logiska, kör logiskt.

1937
01:36:49,390 --> 01:36:51,200
Nu kan jag skriva y.

1938
01:36:51,200 --> 01:36:53,920
Och jag kan göra det igen med
huvudstad Y, eller kapital N.

1939
01:36:53,920 --> 01:36:56,630
Och jag skulle kunna lägga till ytterligare
kombinationer fortfarande.

1940
01:36:56,630 --> 01:36:58,810
>> Så det här är en logisk
program i den mån nu

1941
01:36:58,810 --> 01:37:01,940
Jag kollar logiskt för
detta värde eller detta värde.

1942
01:37:01,940 --> 01:37:06,420
Och jag behöver inte nödvändigtvis
komma upp med ytterligare två IFS eller annars IFS.

1943
01:37:06,420 --> 01:37:09,960
Jag kan faktiskt kombinera några av de
relaterade logik tillsammans på detta sätt.

1944
01:37:09,960 --> 01:37:11,950
Så det skulle vara bättre
utformad än att bara

1945
01:37:11,950 --> 01:37:17,490
sade om C är lika med gemener y,
ut ja, annars om c är lika med kapital Y,

1946
01:37:17,490 --> 01:37:20,074
ut ja, annars om c är lika med
lower-- med andra ord,

1947
01:37:20,074 --> 01:37:21,990
du behöver inte ha
fler och fler grenar.

1948
01:37:21,990 --> 01:37:28,840
Du kan kombinera några av motsvarande
grenar logiskt, som på detta sätt.

1949
01:37:28,840 --> 01:37:34,150
>> Så låt oss ta en titt på bara ett
sista ingrediensen, ett slutliga konstruktionen,

1950
01:37:34,150 --> 01:37:34,847
att C tillåter.

1951
01:37:34,847 --> 01:37:36,930
Och vi kommer att komma tillbaka i
framtid till andra fortfarande.

1952
01:37:36,930 --> 01:37:41,400
Och då kommer vi konstatera genom att titta
på inte riktigheten av code--

1953
01:37:41,400 --> 01:37:46,070
att få koden att work-- men designen
kod, och plantera dessa frön tidigt.

1954
01:37:46,070 --> 01:37:51,337
>> Så låt mig gå vidare och
öppna upp en ny fil här.

1955
01:37:51,337 --> 01:37:51,920
Vet du vad?

1956
01:37:51,920 --> 01:37:54,450
Jag kommer att åter genomföra
samma program,

1957
01:37:54,450 --> 01:37:55,940
men med användning av en annan konstruktion.

1958
01:37:55,940 --> 01:38:00,110
>> Så låt mig snabbt ge mig
tillgång till inkluderar CS50.h

1959
01:38:00,110 --> 01:38:04,150
för CS50 biblioteket
standard io.h för printf.

1960
01:38:04,150 --> 01:38:06,510
Ge mig min int main tomrum.

1961
01:38:06,510 --> 01:38:09,310
Och sedan över här, låt
mig gå vidare och göra det.

1962
01:38:09,310 --> 01:38:12,010
>> Char c blir få röding, precis som förut.

1963
01:38:12,010 --> 01:38:16,770
Och jag kommer att använda en ny konstruktion
now-- slå på vilken karaktär?

1964
01:38:16,770 --> 01:38:19,820
Så switch är ungefär som
växla ett tåg spår.

1965
01:38:19,820 --> 01:38:22,070
Eller, egentligen, är det slags
ett om annat, om else if,

1966
01:38:22,070 --> 01:38:23,980
men skriven något annorlunda.

1967
01:38:23,980 --> 01:38:25,490
>> En omkopplare ser ut så här.

1968
01:38:25,490 --> 01:38:29,060
Du har switch, och sedan vad
tecken eller nummer som du vill titta på,

1969
01:38:29,060 --> 01:38:32,000
sedan några klammerparenteser som i
Scratch, bara säga göra det här.

1970
01:38:32,000 --> 01:38:33,480
Och så har du olika fall.

1971
01:38:33,480 --> 01:38:34,830
>> Du behöver inte använda om och annat.

1972
01:38:34,830 --> 01:38:37,050
Du använder bokstavligen ordet fallet.

1973
01:38:37,050 --> 01:38:38,790
Och du skulle säga något sådant.

1974
01:38:38,790 --> 01:38:43,820
>> Så i fallet med ett gement y,
eller i fallet med en kapital Y,

1975
01:38:43,820 --> 01:38:47,350
gå vidare och skriva ut ja.

1976
01:38:47,350 --> 01:38:49,020
Och sedan bryta ut av omkopplaren.

1977
01:38:49,020 --> 01:38:49,580
Det är allt.

1978
01:38:49,580 --> 01:38:50,880
Var gjort.

1979
01:38:50,880 --> 01:38:57,270
>> Else if, så att säga,
gemener n, eller huvudstad N,

1980
01:38:57,270 --> 01:39:02,560
sedan gå vidare och skriva ut
ut nej, och sedan bryta.

1981
01:39:02,560 --> 01:39:08,022
Else-- och denna typ av är den
default case indeed-- printf error--

1982
01:39:08,022 --> 01:39:10,980
och bara för bra åtgärd, men
logiskt denna brytning är inte nödvändigt

1983
01:39:10,980 --> 01:39:12,896
eftersom vi är i slutet
av omkopplaren i alla fall,

1984
01:39:12,896 --> 01:39:14,520
Jag är nu bryta sig ur växeln.

1985
01:39:14,520 --> 01:39:16,280
Så här ser lite annorlunda.

1986
01:39:16,280 --> 01:39:18,272
>> Men logiskt är det
faktiskt motsvarande.

1987
01:39:18,272 --> 01:39:19,980
Och varför skulle du använda
ovanpå varandra?

1988
01:39:19,980 --> 01:39:23,220
Ibland, bara personliga preferenser,
ibland estetik,

1989
01:39:23,220 --> 01:39:25,420
om jag blick på denna
nu, det finns något

1990
01:39:25,420 --> 01:39:27,510
sägas för
läsbarhet av denna kod.

1991
01:39:27,510 --> 01:39:30,690
Jag menar, never mind det faktum att detta
kod är nytt för många av oss i rummet.

1992
01:39:30,690 --> 01:39:33,515
>> Men det är bara typ av är ganska.

1993
01:39:33,515 --> 01:39:37,760
Du ser gemener y, huvudstad Y,
gemener n, huvudstad N standard

1994
01:39:37,760 --> 01:39:40,150
det bara typ av hopp
ut på dig på ett sätt

1995
01:39:40,150 --> 01:39:42,200
att, utan tvekan, kanske
det tidigare exemplet

1996
01:39:42,200 --> 01:39:45,780
med ifs, och de vertikala staplarna,
och else IFS, kanske inte har.

1997
01:39:45,780 --> 01:39:51,600
Så det här är verkligen en fråga om personlig
val, verkligen, eller läsbarhet,

1998
01:39:51,600 --> 01:39:52,360
av koden.

1999
01:39:52,360 --> 01:39:58,230
>> Men när det gäller funktionalitet, låt mig
gå vidare och göra en switch, pricka snedstreck

2000
01:39:58,230 --> 01:40:05,830
switch, och nu skriva med gemener y,
huvudstad Y, gemener n, huvudstad N,

2001
01:40:05,830 --> 01:40:09,250
David, försöka igen eftersom det är
inte ett enda tecken.

2002
01:40:09,250 --> 01:40:12,050
Låt oss göra x, fel, som förväntat.

2003
01:40:12,050 --> 01:40:15,640
Och logically-- och detta är något
Jag skulle uppmuntra general-- även

2004
01:40:15,640 --> 01:40:17,790
även om vi bara repa
yta av några av dessa funktioner.

2005
01:40:17,790 --> 01:40:20,560
>> Och det kanske inte är uppenbart när du
själv sitta vid tangentbordet,

2006
01:40:20,560 --> 01:40:21,370
hur fungerar detta?

2007
01:40:21,370 --> 01:40:22,240
Vad skulle det göra?

2008
01:40:22,240 --> 01:40:25,630
Den vackra sak om att ha
en bärbar eller stationär, eller tillgång

2009
01:40:25,630 --> 01:40:29,290
till en dator med en kompilator,
och med en kod redaktör som denna,

2010
01:40:29,290 --> 01:40:32,990
är du nästan alltid besvara dessa
frågor för dig själv bara genom att försöka.

2011
01:40:32,990 --> 01:40:36,570
>> Till exempel, om det retoriska
fråga till hands var,

2012
01:40:36,570 --> 01:40:39,540
vad händer om du glömmer
din bryta uttalanden?

2013
01:40:39,540 --> 01:40:41,400
Som egentligen är en
mycket vanlig sak att göra,

2014
01:40:41,400 --> 01:40:43,540
eftersom det inte ser
som du verkligen behöver dem.

2015
01:40:43,540 --> 01:40:46,790
De vet inte riktigt slutföra
tänkte som en parentes eller en lockig

2016
01:40:46,790 --> 01:40:47,714
stag gör.

2017
01:40:47,714 --> 01:40:49,630
Låt oss gå vidare och
kompilera koden och se.

2018
01:40:49,630 --> 01:40:53,690
Så gör switch, dot slash switch.

2019
01:40:53,690 --> 01:40:56,435
Låt oss skriva in gemener
y, den översta fallet, Enter.

2020
01:40:56,435 --> 01:40:59,390

2021
01:40:59,390 --> 01:41:00,700
Så jag skrev y.

2022
01:41:00,700 --> 01:41:04,420
>> Programmet sade ja, nej, fel,
som om det var ändra uppfattning.

2023
01:41:04,420 --> 01:41:09,280
Men det slags var, eftersom det händer
med en switch är det första fallet som

2024
01:41:09,280 --> 01:41:13,899
match innebär i huvudsak, hej dator,
verkställa all kod under den.

2025
01:41:13,899 --> 01:41:16,690
Och om du inte säger paus, eller
säg inte bryta, eller inte säga paus,

2026
01:41:16,690 --> 01:41:19,540
datorn kommer att blåsa
genom alla dessa linjer

2027
01:41:19,540 --> 01:41:22,779
och utföra alla dem tills
det blir till att klammerparentes.

2028
01:41:22,779 --> 01:41:24,320
Så bromsarna är verkligen nödvändigt.

2029
01:41:24,320 --> 01:41:27,120
Men en takeaway här är, när
osäker, prova något.

2030
01:41:27,120 --> 01:41:29,510
Kanske spara koden först,
eller spara den i en extra fil

2031
01:41:29,510 --> 01:41:32,930
om du verkligen orolig
stöka och med att återhämta sig

2032
01:41:32,930 --> 01:41:34,430
det arbete som du vet fungerar.

2033
01:41:34,430 --> 01:41:35,410
>> Men prova saker.

2034
01:41:35,410 --> 01:41:38,074
Och inte vara så rädd, kanske,
av vad datorn kan göra,

2035
01:41:38,074 --> 01:41:39,490
eller att du kan bryta något.

2036
01:41:39,490 --> 01:41:42,790
Du kan alltid återgå
till någon tidigare version.

2037
01:41:42,790 --> 01:41:45,640
>> Så låt oss avsluta genom att titta
vid utformningen av koden.

2038
01:41:45,640 --> 01:41:49,020
Vi har denna förmåga nu att skriva
villkor och skriv loopar,

2039
01:41:49,020 --> 01:41:50,850
och variabler och samtalsfunktioner.

2040
01:41:50,850 --> 01:41:54,590
Så ärligt talat, vi är typ av tillbaka på
där vi var för en vecka sedan med Scratch,

2041
01:41:54,590 --> 01:42:00,120
om än med en mindre övertygande text
miljö än Scratch tillåter.

2042
01:42:00,120 --> 01:42:03,990
>> Men märker hur snabbt vi har förvärvat
att vokabulär, även om det är

2043
01:42:03,990 --> 01:42:07,570
kommer att ta ett tag att sjunka in,
så att vi nu kan använda denna vokabulär

2044
01:42:07,570 --> 01:42:10,320
att skriva mer intressanta program.

2045
01:42:10,320 --> 01:42:12,940
Och låt oss ta en baby steg
mot det, enligt följande.

2046
01:42:12,940 --> 01:42:14,890
Låt mig gå vidare och
skapa en ny fil här.

2047
01:42:14,890 --> 01:42:17,750
>> Jag kommer att kalla detta
prototype.c, och införa

2048
01:42:17,750 --> 01:42:20,954
för första gången, förmågan
att göra egna funktioner.

2049
01:42:20,954 --> 01:42:22,870
Några av er kanske har
gjort detta med Scratch,

2050
01:42:22,870 --> 01:42:25,430
där du kan skapa din
egna anpassade block i Scratch,

2051
01:42:25,430 --> 01:42:27,892
och sedan dra dem på plats
varhelst du vill i C.

2052
01:42:27,892 --> 01:42:30,100
Och i de flesta programmering
språk, kan du göra exakt

2053
01:42:30,100 --> 01:42:33,580
that-- göra egna funktioner,
om de inte redan finns.

2054
01:42:33,580 --> 01:42:38,660
>> Så, till exempel, låt mig gå vidare
och innefattar CS50.h, och innefattar

2055
01:42:38,660 --> 01:42:43,110
standard io.h, int main tomrum.

2056
01:42:43,110 --> 01:42:46,020
Och nu har vi en
placeholder redo att gå.

2057
01:42:46,020 --> 01:42:48,550
Jag håller tryck saker
som personers namn idag.

2058
01:42:48,550 --> 01:42:51,910
Och det känns like--
skulle inte vara trevligt om det

2059
01:42:51,910 --> 01:42:53,936
var en funktion som kallas utskrifts namn?

2060
01:42:53,936 --> 01:42:55,060
Jag behöver inte använda printf.

2061
01:42:55,060 --> 01:42:56,976
Jag behöver inte komma ihåg
alla formatkoder.

2062
01:42:56,976 --> 01:43:00,050
Varför inte jag, eller varför
inte någon före mig,

2063
01:43:00,050 --> 01:43:02,980
skapa en funktion som kallas print
namn, som ges något namn,

2064
01:43:02,980 --> 01:43:03,980
helt enkelt skriver ut?

2065
01:43:03,980 --> 01:43:08,700
>> Med andra ord, om jag säger hej,
dator, ge mig en sträng

2066
01:43:08,700 --> 01:43:11,870
genom att be användaren om ett sådant,
via CS50: s get sträng funktion.

2067
01:43:11,870 --> 01:43:15,090
Hej, dator, lägga den sträng i
variabeln i den vänstra sidan,

2068
01:43:15,090 --> 01:43:16,150
och kallar det är.

2069
01:43:16,150 --> 01:43:22,150
Och då, hej dator, gå vidare
och skriva ut den personens namn, gjort.

2070
01:43:22,150 --> 01:43:26,240
>> Nu skulle det vara trevligt, eftersom
detta program, passande namnet,

2071
01:43:26,240 --> 01:43:29,170
berättar vad det är tänkt att göra
med hjälp av de funktionens namn.

2072
01:43:29,170 --> 01:43:32,930
Låt mig gå och göra prototyp, Enter.

2073
01:43:32,930 --> 01:43:34,930
Och, tyvärr,
Detta kommer inte att flyga.

2074
01:43:34,930 --> 01:43:39,430
>> Prototype.c, linje 7, tecken
5, fel, implicit deklaration

2075
01:43:39,430 --> 01:43:42,960
Funktions print namn
är ogiltig i C99, C99

2076
01:43:42,960 --> 01:43:45,130
innebärande en version av C
som kom ut 1999.

2077
01:43:45,130 --> 01:43:45,730
Det är allt.

2078
01:43:45,730 --> 01:43:48,780
>> Så jag vet inte vad
Allt detta innebär ännu.

2079
01:43:48,780 --> 01:43:50,810
Men jag känner igen fel i rött.

2080
01:43:50,810 --> 01:43:51,770
Det är ganska uppenbart.

2081
01:43:51,770 --> 01:43:53,769
>> Och det verkar som med
den gröna karaktär här,

2082
01:43:53,769 --> 01:43:57,520
problemet är med tryck namn, öppna
Paren s, nära Paren, semikolon.

2083
01:43:57,520 --> 01:44:01,800
Men underförstått förklaring
funktion vi såg i korthet tidigare.

2084
01:44:01,800 --> 01:44:04,880
Detta innebär helt enkelt, att Clang
inte vet vad jag menar.

2085
01:44:04,880 --> 01:44:09,000
>> Jag har använt ett ordförråd ord som det är
aldrig sett eller undervisats tidigare.

2086
01:44:09,000 --> 01:44:11,950
Och så jag måste lära den
vad denna funktion innebär.

2087
01:44:11,950 --> 01:44:13,590
Så jag kommer att gå vidare och göra det.

2088
01:44:13,590 --> 01:44:17,970
>> Jag kommer att gå vidare och genomföra
min egen funktion som kallas ut namn.

2089
01:44:17,970 --> 01:44:24,720
Och jag kommer att säga, enligt följande, som
det gör det, printf, hej, procent

2090
01:44:24,720 --> 01:44:27,760
s, bakstreck n, namn, semikolon.

2091
01:44:27,760 --> 01:44:29,250
Så vad gjorde jag göra?

2092
01:44:29,250 --> 01:44:31,325
>> Så visar det sig, att
implementera egen funktion,

2093
01:44:31,325 --> 01:44:33,845
vi typ av låna några av
samma struktur som huvud

2094
01:44:33,845 --> 01:44:35,720
att vi bara har varit
tas för givet, och jag

2095
01:44:35,720 --> 01:44:37,730
vet bara att kopiera och
klistra ganska mycket vad

2096
01:44:37,730 --> 01:44:39,170
Jag har skrivit tidigare.

2097
01:44:39,170 --> 01:44:40,570
Men märker mönster här.

2098
01:44:40,570 --> 01:44:43,750
Int, Main, Void, vi retas isär
snart vad det egentligen betyder.

2099
01:44:43,750 --> 01:44:46,160
>> Men i dag, bara
märka parallellism.

2100
01:44:46,160 --> 01:44:48,210
Void, tryck namn,
string namn, så det finns

2101
01:44:48,210 --> 01:44:50,310
en lila sökord, vilket
Vi ska börja

2102
01:44:50,310 --> 01:44:54,067
ringer en returtyp, namnet på
funktionen, och sedan ingången.

2103
01:44:54,067 --> 01:44:56,400
Så egentligen kan vi destillera
denna typ av som förra veckan

2104
01:44:56,400 --> 01:44:59,030
som är det namn eller
algoritm av koden vi

2105
01:44:59,030 --> 01:45:00,761
kommer att write-- den
algoritmen som är grunden

2106
01:45:00,761 --> 01:45:02,010
koden vi ska skriva.

2107
01:45:02,010 --> 01:45:03,180
>> Detta är dess ingång.

2108
01:45:03,180 --> 01:45:04,670
Detta är dess utgång.

2109
01:45:04,670 --> 01:45:08,730
Denna funktion, tryck namn, är
utformad för att ta en sträng som kallas namn,

2110
01:45:08,730 --> 01:45:11,350
eller vad som helst, som indata, och sedan tomrum.

2111
01:45:11,350 --> 01:45:13,904
Det inte tillbaka något,
som får sträng eller få int gör.

2112
01:45:13,904 --> 01:45:15,570
Så det kommer att ge mig något tillbaka.

2113
01:45:15,570 --> 01:45:17,960
Det kommer bara att ha en
bieffekt, så att säga,

2114
01:45:17,960 --> 01:45:19,570
att skriva en persons namn.

2115
01:45:19,570 --> 01:45:22,260
Så märker, linje 7, jag
kan ringa utskriftsnamn.

2116
01:45:22,260 --> 01:45:25,920
Linje 10, kan jag definiera
eller genomföra utskriftsnamn.

2117
01:45:25,920 --> 01:45:28,450
Men tyvärr, det är inte tillräckligt.

2118
01:45:28,450 --> 01:45:31,230
>> Låt mig gå vidare och
kompilera detta efter att ha sparat.

2119
01:45:31,230 --> 01:45:33,910
Whoa, nu, jag har gjort det
värre, verkar det.

2120
01:45:33,910 --> 01:45:37,027
Så implicit deklaration av
Funktionen print namn är ogiltigt.

2121
01:45:37,027 --> 01:45:38,360
Och, återigen, det finns fler fel.

2122
01:45:38,360 --> 01:45:41,430
Men som jag varnade tidigare även
om du får överväldigad med,

2123
01:45:41,430 --> 01:45:44,850
eller lite sorgligt att se så många
fel, bara fokusera på den första

2124
01:45:44,850 --> 01:45:47,500
initialt, eftersom det kanske bara
har haft en kaskadeffekt.

2125
01:45:47,500 --> 01:45:51,970
Så C eller Clang mer specifikt,
fortfarande inte känner igen utskriftsnamn.

2126
01:45:51,970 --> 01:45:54,580
>> Och det beror på klang,
genom design, är ganska dum.

2127
01:45:54,580 --> 01:45:56,280
Det gör bara vad du säger den att göra.

2128
01:45:56,280 --> 01:46:00,950
Och det bara gör det i den ordning
där du berättar det att göra.

2129
01:46:00,950 --> 01:46:05,270
>> Så jag har definierat huvud på linje fyra,
som vi har gjort ganska ofta.

2130
01:46:05,270 --> 01:46:07,980
Jag har definierat utskrifts namn på rad 10.

2131
01:46:07,980 --> 01:46:11,793
Men jag försöker att använda
print namn på rad sju.

2132
01:46:11,793 --> 01:46:13,670
>> Det är för tidigt, inte finns ännu.

2133
01:46:13,670 --> 01:46:19,150
Så jag kunde vara smart, och vara som,
OK, så låt oss bara spela tillsammans,

2134
01:46:19,150 --> 01:46:23,680
och flytta utskrifts namn upp
här och åter kompilera.

2135
01:46:23,680 --> 01:46:24,550
Herregud.

2136
01:46:24,550 --> 01:46:25,260
Det fungerade.

2137
01:46:25,260 --> 01:46:26,670
Det var så enkelt är det.

2138
01:46:26,670 --> 01:46:28,120
>> Men logiken är just detta.

2139
01:46:28,120 --> 01:46:30,870
Du måste lära klang vad det
är genom att definiera funktionen först.

2140
01:46:30,870 --> 01:46:31,920
Sedan kan du använda den.

2141
01:46:31,920 --> 01:46:33,940
Men, ärligt talat, känns detta
som en hal backe.

2142
01:46:33,940 --> 01:46:35,773
>> Så varje gång jag kör
i ett problem, jag är bara

2143
01:46:35,773 --> 01:46:39,450
kommer att markera och kopiera koden
Jag skrev, skär den och klistra in den här.

2144
01:46:39,450 --> 01:46:41,370
Och säkert, vi kunde
contrive vissa scenarier

2145
01:46:41,370 --> 01:46:43,286
där en funktion kanske
behöver ringa en annan.

2146
01:46:43,286 --> 01:46:46,030
Och du bara inte kan sätta alla
funktion över alla andra.

2147
01:46:46,030 --> 01:46:47,930
>> Så visar det sig att det finns
en bättre lösning.

2148
01:46:47,930 --> 01:46:50,100
Vi kan lämna detta vara.

2149
01:46:50,100 --> 01:46:53,677
Och, ärligt talat, är det allmänt trevligt,
och bekvämt, och god design

2150
01:46:53,677 --> 01:46:56,760
att sätta huvud först, eftersom, återigen,
Huvud precis som när grön flagg klickade,

2151
01:46:56,760 --> 01:46:59,027
som är den funktion som
blir verk som standard.

2152
01:46:59,027 --> 01:47:01,110
Så du kan lika gärna sätta
den när upp i filen

2153
01:47:01,110 --> 01:47:03,560
så att när du eller någon
annan människa ser på filen

2154
01:47:03,560 --> 01:47:06,360
du vet vad som händer
bara genom att läsa huvud först.

2155
01:47:06,360 --> 01:47:15,360
Så visar det sig, kan vi tala om klang
proaktivt, hej, klang, på linje fyra,

2156
01:47:15,360 --> 01:47:17,940
Jag lovar att genomföra
en funktion som kallas Print

2157
01:47:17,940 --> 01:47:22,600
Namn som tar en sträng som kallas namn
som indata och returnerar ingenting, tomrum.

2158
01:47:22,600 --> 01:47:24,770
Och jag ska komma runt till
genomföra den senare.

2159
01:47:24,770 --> 01:47:25,680
>> Här kommer Main.

2160
01:47:25,680 --> 01:47:29,130
Huvud nu på rad 9 kan använda
Skriv namn eftersom klang

2161
01:47:29,130 --> 01:47:32,600
är litar på att så småningom,
det kommer att stöta definitionen

2162
01:47:32,600 --> 01:47:34,880
genomförandet av Print namn.

2163
01:47:34,880 --> 01:47:37,390
Så efter att ha sparat min fil, låt
mig gå vidare och göra prototyp,

2164
01:47:37,390 --> 01:47:38,498
ser bra denna gång.

2165
01:47:38,498 --> 01:47:43,470
Dot snedstreck, prototyp, låt mig
gå vidare och skriva in ett namn.

2166
01:47:43,470 --> 01:47:48,440
David, hej David, Zamila, hej
Zamila, och, faktiskt, nu fungerar.

2167
01:47:48,440 --> 01:47:52,200
>> Så ingrediensen här är att vi har
gjorde en anpassad funktion, som en anpassad

2168
01:47:52,200 --> 01:47:54,219
Scratch blocket vi kallar det.

2169
01:47:54,219 --> 01:47:57,010
Men till skillnad från Scratch där du kan
bara skapa det och börja använda den,

2170
01:47:57,010 --> 01:47:59,330
Nu måste vi vara en
lite mer pedantisk,

2171
01:47:59,330 --> 01:48:03,410
och faktiskt utbilda Clang
att använda, eller att förvänta sig det.

2172
01:48:03,410 --> 01:48:09,140
Nu, som en sidoreplik, varför hela tiden har
vi varit bara blint på tro inklusive

2173
01:48:09,140 --> 01:48:12,170
CS50.h, och med standard io.h?

2174
01:48:12,170 --> 01:48:15,190
>> Tja, det visar sig,
bland några andra saker,

2175
01:48:15,190 --> 01:48:18,550
allt som är i dem dot h
filer, som råkar vara filer.

2176
01:48:18,550 --> 01:48:20,460
De är header filer, så att säga.

2177
01:48:20,460 --> 01:48:23,270
De är fortfarande skrivet i C. Men
de är en annan typ av fil.

2178
01:48:23,270 --> 01:48:28,690
>> För nu kan du ganska mycket antar
att allt som är inne i CS50.h

2179
01:48:28,690 --> 01:48:33,360
är några one-liners som denna, inte
för funktioner som kallas ut namn,

2180
01:48:33,360 --> 01:48:36,840
men för Get String, Get
Float, och några andra.

2181
01:48:36,840 --> 01:48:41,510
Och det finns liknande prototyper,
eyeliner, insidan av standard io.h

2182
01:48:41,510 --> 01:48:46,241
för printf, som nu är i
min egen Print Namn funktion.

2183
01:48:46,241 --> 01:48:49,490
Så med andra ord, hela tiden vi har
just blint kopiera och klistra in

2184
01:48:49,490 --> 01:48:51,780
inkludera denna, inkluderar
att vad som händer?

2185
01:48:51,780 --> 01:48:55,310
De är bara typ av ledtrådar
att klang vad funktioner

2186
01:48:55,310 --> 01:49:00,170
är verkligen genomförs, precis
på andra ställen i olika filer

2187
01:49:00,170 --> 01:49:02,440
på andra ställen i systemet.

2188
01:49:02,440 --> 01:49:05,160
>> Så vi har implementerat utskriftsnamn.

2189
01:49:05,160 --> 01:49:07,910
Det har denna bieffekt av
utskrift något på skärmen.

2190
01:49:07,910 --> 01:49:10,170
Men det gör faktiskt inte
ge mig något tillbaka.

2191
01:49:10,170 --> 01:49:12,200
Hur ska vi gå tillväga
genomföra ett program som

2192
01:49:12,200 --> 01:49:14,510
inte ge mig något tillbaka?

2193
01:49:14,510 --> 01:49:15,580
>> Nåväl, låt oss försöka detta.

2194
01:49:15,580 --> 01:49:21,360
Låt mig gå vidare och genomföra
en fil som heter return.c

2195
01:49:21,360 --> 01:49:24,530
så att vi kan visa hur något
gillar Få String, eller hämta Int,

2196
01:49:24,530 --> 01:49:27,340
är faktiskt återvänder
något tillbaka till användaren.

2197
01:49:27,340 --> 01:49:29,840
Låt oss gå vidare och definiera int main tomrum.

2198
01:49:29,840 --> 01:49:33,230
>> Och, igen, i framtiden kommer vi
förklara vad som int och det tomrum

2199
01:49:33,230 --> 01:49:34,090
är faktiskt gör.

2200
01:49:34,090 --> 01:49:35,840
Men för idag, vi ska
ta det för givet.

2201
01:49:35,840 --> 01:49:39,970
Jag kommer att gå vidare och printf,
för en bra användarupplevelse, är x.

2202
01:49:39,970 --> 01:49:44,360
Och då kommer jag att vänta på
användaren att ge mig x med get int.

2203
01:49:44,360 --> 01:49:48,459
>> Och då kommer jag att gå vidare
och skriva ut x till torget.

2204
01:49:48,459 --> 01:49:50,500
Så när du bara har en
tangentbord, människor vanligen

2205
01:49:50,500 --> 01:49:52,600
använda den lilla morot
symbol på tangentbordet

2206
01:49:52,600 --> 01:49:55,330
att representera strömmen
av, eller exponent av.

2207
01:49:55,330 --> 01:49:58,960
Så xi kvadrat är närvarande i.

2208
01:49:58,960 --> 01:50:00,660
>> Och nu ska jag göra detta.

2209
01:50:00,660 --> 01:50:03,940
Jag kunde bara do-- vad är x
kvadrat? x kvadrat är x gånger x.

2210
01:50:03,940 --> 01:50:06,690
>> Och vi gjorde detta några
tid sedan redan idag.

2211
01:50:06,690 --> 01:50:08,730
Detta känns inte som
så mycket framsteg.

2212
01:50:08,730 --> 01:50:09,570
Vet du vad?

2213
01:50:09,570 --> 01:50:13,100
Låt oss utnyttja en del av denna idé
från förra gången av abstraktion.

2214
01:50:13,100 --> 01:50:16,080
>> Skulle det inte vara trevligt om
Det finns en funktion som kallas

2215
01:50:16,080 --> 01:50:18,460
torg som gör just detta?

2216
01:50:18,460 --> 01:50:20,640
Det fortfarande, i slutet av den
dag, gör samma matematik.

2217
01:50:20,640 --> 01:50:22,410
Men låt oss abstrakt
bort tanken på att

2218
01:50:22,410 --> 01:50:25,280
ett antal multiplicerat med
en annan, och bara ge den ett namn,

2219
01:50:25,280 --> 01:50:27,360
som square detta värde.

2220
01:50:27,360 --> 01:50:29,560
>> Och, med andra ord, i
C, låt oss skapa en funktion

2221
01:50:29,560 --> 01:50:32,660
kallas torg som gör just detta.

2222
01:50:32,660 --> 01:50:34,600
Det kommer att kallas kvadrat.

2223
01:50:34,600 --> 01:50:35,790
Det kommer att ta en int.

2224
01:50:35,790 --> 01:50:37,820
Och vi kommer kommer bara
kalla det n som standard.

2225
01:50:37,820 --> 01:50:39,403
>> Men vi kan kalla det vad vi vill.

2226
01:50:39,403 --> 01:50:42,900
Och allt som det kommer att
göra, bokstavligen, är avkastningen

2227
01:50:42,900 --> 01:50:45,810
resultatet av n gånger n.

2228
01:50:45,810 --> 01:50:48,980
Men eftersom det är
tillbaka något, vilket

2229
01:50:48,980 --> 01:50:53,690
är nyckelordet i lila vi har
aldrig sett förut, jag, på linje 11,

2230
01:50:53,690 --> 01:50:55,410
kan inte bara säga ogiltig den här gången.

2231
01:50:55,410 --> 01:51:01,320
>> Void, i exemplet vi såg bara
snarare utskrifts namn betyder just,

2232
01:51:01,320 --> 01:51:02,190
göra någonting.

2233
01:51:02,190 --> 01:51:04,170
Men inte ge mig något tillbaka.

2234
01:51:04,170 --> 01:51:06,790
I det här fallet vill jag
för att gå tillbaka n gånger n,

2235
01:51:06,790 --> 01:51:08,460
eller vad det nu är, det numret.

2236
01:51:08,460 --> 01:51:12,460
>> Så jag kan inte säga, hej, dator,
Jag åter ingenting, tomrum.

2237
01:51:12,460 --> 01:51:16,166
Det kommer att återvända till sin natur en int.

2238
01:51:16,166 --> 01:51:17,790
Och så det är allt som händer här.

2239
01:51:17,790 --> 01:51:20,070
>> Ingången till ruta
kommer att bli en int.

2240
01:51:20,070 --> 01:51:24,760
Och så att vi kan använda det, måste det
har ett namn, N. Det kommer att mata

2241
01:51:24,760 --> 01:51:26,240
en int som inte behöver ett namn.

2242
01:51:26,240 --> 01:51:29,590
Vi kan lämna det till huvud, eller vem är
använder mig att komma ihåg detta värde om vi

2243
01:51:29,590 --> 01:51:31,120
vill med sin egen variabel.

2244
01:51:31,120 --> 01:51:33,230
>> Och, återigen, det enda nya
nyckelord här är Return.

2245
01:51:33,230 --> 01:51:34,480
Och jag bara göra lite matte.

2246
01:51:34,480 --> 01:51:41,825
Om jag ville verkligen vara onödigt,
Jag kunde säga int produkt blir n gånger n.

2247
01:51:41,825 --> 01:51:44,170
>> Och då kunde jag säga, tillbaka produkten.

2248
01:51:44,170 --> 01:51:47,360
Men, återigen, min poäng tidigare av
detta bara inte är bra design--

2249
01:51:47,360 --> 01:51:50,060
Liksom, varför införa ett namn,
en symbol, som produkt,

2250
01:51:50,060 --> 01:51:51,570
bara för att omedelbart återlämna det?

2251
01:51:51,570 --> 01:51:53,670
Det är en lite renare,
lite hårdare, så

2252
01:51:53,670 --> 01:51:59,380
att tala, bara för att säga retur n gånger
n, bli av med denna linje helt och hållet.

2253
01:51:59,380 --> 01:52:02,860
>> Och det är bara mindre kod för att läsa,
mindre möjlighet för misstag.

2254
01:52:02,860 --> 01:52:05,180
Och låt oss se om detta
faktiskt fungerar nu.

2255
01:52:05,180 --> 01:52:09,380
Nu, jag kommer att gå
framåt och göra retur.

2256
01:52:09,380 --> 01:52:11,460
>> Uh-oh, implicit deklaration av funktionen.

2257
01:52:11,460 --> 01:52:14,080
Jag gjorde detta misstag innan, no big deal.

2258
01:52:14,080 --> 01:52:18,950
Låt mig bara skriva, eller markera och
kopiera, exakt samma prototyp funktion,

2259
01:52:18,950 --> 01:52:21,342
eller underskrift av funktionen upp här.

2260
01:52:21,342 --> 01:52:22,800
Eller jag kunde flytta hela funktionen.

2261
01:52:22,800 --> 01:52:23,841
>> Men det är lite lat.

2262
01:52:23,841 --> 01:52:24,870
Så vi inte kommer att göra det.

2263
01:52:24,870 --> 01:52:27,960
Nu, låt mig göra retur
igen, dot snedstreck avkastning.

2264
01:52:27,960 --> 01:52:32,790
>> x 2. xi kvadrat är fyra.
x 3. xi kvadrat är nio.

2265
01:52:32,790 --> 01:52:35,300
Och funktionen verkar
nu att arbeta.

2266
01:52:35,300 --> 01:52:36,550
Så vad är skillnaden här?

2267
01:52:36,550 --> 01:52:42,520
Jag har en funktion som kallas torg,
i det här fallet, som jag lade i en ingång.

2268
01:52:42,520 --> 01:52:43,830
Och jag får tillbaka en utgång.

2269
01:52:43,830 --> 01:52:46,210
Och ändå, tidigare, om
Jag öppnar det andra exemplet

2270
01:52:46,210 --> 01:52:51,640
från tidigare, vilket
kallades prototype.c,

2271
01:52:51,640 --> 01:52:54,770
Jag hade utskriftsnamn, som
åter tomrum, så att säga,

2272
01:52:54,770 --> 01:52:58,730
Eller det återvände ingenting, och
helt enkelt hade en bieffekt.

2273
01:52:58,730 --> 01:53:00,230
>> Så vad händer här?

2274
01:53:00,230 --> 01:53:03,520
Tja, anser funktionen
få sträng för ett ögonblick.

2275
01:53:03,520 --> 01:53:06,570
Vi har använt funktionen
hämta sträng på följande sätt.

2276
01:53:06,570 --> 01:53:10,464
>> Vi har haft en funktion får
sträng, som innefattar CS50.h,

2277
01:53:10,464 --> 01:53:16,624
inkluderar standard io.h, int, huvudsakligt, tomrum.

2278
01:53:16,624 --> 01:53:18,790
Och sedan varje gång jag har
kallad få sträng hittills,

2279
01:53:18,790 --> 01:53:23,260
Jag har sagt något i stil med sträng s
blir få sträng, eftersom få string--

2280
01:53:23,260 --> 01:53:27,880
låt oss kalla detta get.c-- get sträng
själv returnerar en sträng som jag kan sedan

2281
01:53:27,880 --> 01:53:32,050
använda och säga, hej, kommatecken,
procent s, omvänt snedstreck n, s.

2282
01:53:32,050 --> 01:53:35,660
>> Så detta är samma exempel,
verkligen att vi hade tidigare.

2283
01:53:35,660 --> 01:53:37,920
Så får sträng returnerar ett värde.

2284
01:53:37,920 --> 01:53:41,260
Men en stund sedan, tryck sträng
inte returnera ett värde.

2285
01:53:41,260 --> 01:53:42,721
Det har helt enkelt en bieffekt.

2286
01:53:42,721 --> 01:53:44,220
Så detta är en fundamental skillnad.

2287
01:53:44,220 --> 01:53:46,710
Vi har sett olika
typer av funktioner nu,

2288
01:53:46,710 --> 01:53:49,490
varav en del har återvänt
värden, av vilka vissa inte gör det.

2289
01:53:49,490 --> 01:53:51,890
Så kanske det är sträng, eller int eller float.

2290
01:53:51,890 --> 01:53:53,480
Eller kanske är det bara ogiltig.

2291
01:53:53,480 --> 01:53:55,710
>> Och skillnaden är
att dessa funktioner som

2292
01:53:55,710 --> 01:53:59,940
hämta data och returnera ett värde faktiskt
föra något tillbaka till bordet,

2293
01:53:59,940 --> 01:54:01,110
så att säga.

2294
01:54:01,110 --> 01:54:03,710
Så låt oss gå vidare och
titta på en slutlig uppsättning

2295
01:54:03,710 --> 01:54:09,129
exempel som ger en känsla, nu, om
hur vi kanske faktiskt abstrakt bättre,

2296
01:54:09,129 --> 01:54:11,670
och bättre, och bättre, eller mer,
och mer och mer, i syfte

2297
01:54:11,670 --> 01:54:13,810
att skriva, i slutändan, bättre kod.

2298
01:54:13,810 --> 01:54:16,860
Låt oss gå vidare, och i en anda
av Scratch, gör följande.

2299
01:54:16,860 --> 01:54:21,700
>> Låt mig gå vidare och inkludera
CS50.h och standard IO.h.

2300
01:54:21,700 --> 01:54:24,010
Låt mig gå vidare och ge
själv en int, huvudsakligt, tomrum.

2301
01:54:24,010 --> 01:54:27,380
Och låt mig gå vidare, kalla detta cough.c.

2302
01:54:27,380 --> 01:54:35,510
>> Och låt mig gå vidare och bara
som Scratch, skriva ut hosta / n.

2303
01:54:35,510 --> 01:54:37,170
Och jag vill göra detta tre gånger.

2304
01:54:37,170 --> 01:54:39,670
Så jag naturligtvis bara gå
att kopiera och klistra in tre gånger.

2305
01:54:39,670 --> 01:54:46,440
Jag kommer nu att göra
hosta dot slash hosta.

2306
01:54:46,440 --> 01:54:50,120
Låt oss ge mig lite mer utrymme
här, Enter, hosta, hosta, hosta.

2307
01:54:50,120 --> 01:54:53,970
>> Det finns, naturligtvis, redan en
möjlighet till förbättring.

2308
01:54:53,970 --> 01:54:55,679
Jag har kopierat och klistrat
ett par gånger i dag.

2309
01:54:55,679 --> 01:54:58,261
Men det var bara så jag inte
måste skriva så många tecken.

2310
01:54:58,261 --> 01:55:00,250
Jag fortfarande ändrat vad
dessa rader kod är.

2311
01:55:00,250 --> 01:55:04,240
>> Dessa tre linjer är identiska,
vilket känns lat och faktiskt är,

2312
01:55:04,240 --> 01:55:07,110
och är förmodligen inte rätt metod.

2313
01:55:07,110 --> 01:55:11,029
Så vad ingrediens
kan vi förbättra denna kod?

2314
01:55:11,029 --> 01:55:12,570
Vi behöver inte kopiera och klistra in koden.

2315
01:55:12,570 --> 01:55:15,070
>> Och faktiskt, varje gång du känner
själv kopiera och klistra in,

2316
01:55:15,070 --> 01:55:17,700
och inte ens ändra kod,
oddsen är att det finns ett bättre sätt.

2317
01:55:17,700 --> 01:55:19,470
Och, ja, det finns.

2318
01:55:19,470 --> 01:55:22,510
Låt mig gå vidare och göra en for-loop,
trots att syntaxen kanske inte

2319
01:55:22,510 --> 01:55:24,570
kommer naturligtvis ännu.

2320
01:55:24,570 --> 01:55:29,494
>> Gör detta tre gånger, helt enkelt
genom att göra den following--

2321
01:55:29,494 --> 01:55:31,160
och jag råkar veta detta från praktiken.

2322
01:55:31,160 --> 01:55:32,810
Men vi har ett antal exempel nu.

2323
01:55:32,810 --> 01:55:34,950
Och du ser på nätet
fler referenser fortfarande.

2324
01:55:34,950 --> 01:55:37,790
>> Detta är syntaxen på linje 6, som
ungefär som Scratch som upprepas

2325
01:55:37,790 --> 01:55:40,090
blocket, upprepa följande tre gånger.

2326
01:55:40,090 --> 01:55:41,340
Det är en liten magisk nu.

2327
01:55:41,340 --> 01:55:43,050
Men detta kommer att få mer,
och mer bekant.

2328
01:55:43,050 --> 01:55:45,050
>> Och det kommer att upprepa
linjen åtta tre gånger,

2329
01:55:45,050 --> 01:55:52,390
så att om jag åter sammanställa make hosta,
dot slash hosta, hosta, hosta, hosta.

2330
01:55:52,390 --> 01:55:54,030
Den fungerar fortfarande på samma sätt.

2331
01:55:54,030 --> 01:55:55,550
Så det är alla fina och bra.

2332
01:55:55,550 --> 01:55:58,200
Men det är inte mycket abstraherade.

2333
01:55:58,200 --> 01:55:59,371
>> Det är helt korrekt.

2334
01:55:59,371 --> 01:56:01,370
Men det känns som om det
skulle kunna vara en möjlighet,

2335
01:56:01,370 --> 01:56:03,750
som i världen av
Scratch, till typ av start

2336
01:56:03,750 --> 01:56:07,530
att lägga till några semantik här så att
Jag har inte bara en del för slinga,

2337
01:56:07,530 --> 01:56:09,867
och en funktion som säger
hosta, eller inte hosta.

2338
01:56:09,867 --> 01:56:10,450
Vet du vad?

2339
01:56:10,450 --> 01:56:12,620
Låt mig försöka vara en
lite svalare än så,

2340
01:56:12,620 --> 01:56:16,090
och faktiskt skriva en funktion som
har vissa biverkningar, kalla det hosta.

2341
01:56:16,090 --> 01:56:20,830
>> Och det tar ingen ingång, och
returnerar inget värde som produktion.

2342
01:56:20,830 --> 01:56:22,680
Men vet du vad det gör?

2343
01:56:22,680 --> 01:56:29,370
Det gör this-- printf,
citat unquote, hosta.

2344
01:56:29,370 --> 01:56:32,380
>> Och nu upp här, kommer jag
att gå vidare och för int,

2345
01:56:32,380 --> 01:56:36,070
Jag blir noll, i mindre än tre, i plus plus.

2346
01:56:36,070 --> 01:56:39,770
Jag ska inte göra printf, som är
utan tvekan en implementering låg nivå

2347
01:56:39,770 --> 01:56:40,270
detalj.

2348
01:56:40,270 --> 01:56:41,353
Jag bryr mig inte hur man hosta.

2349
01:56:41,353 --> 01:56:43,240
Jag vill bara använda hosta funktionen.

2350
01:56:43,240 --> 01:56:44,840
Och jag ska bara ringa hosta.

2351
01:56:44,840 --> 01:56:46,204
>> Nu märker dikotomi.

2352
01:56:46,204 --> 01:56:49,370
När du ringer en funktion, om du inte
vill ge det ingångar, helt bra.

2353
01:56:49,370 --> 01:56:51,780
Gör öppna Paren, nära
Paren, och du är klar.

2354
01:56:51,780 --> 01:56:56,271
>> När du definierar en funktion, eller
deklarera en funktion prototyp,

2355
01:56:56,271 --> 01:56:58,770
Om du vet i förväg är det inte
kommer att ta några argument,

2356
01:56:58,770 --> 01:57:01,170
säger tomrum i dessa parenteser där.

2357
01:57:01,170 --> 01:57:05,660
Och det gör säker på att du
inte av misstag missbruka det.

2358
01:57:05,660 --> 01:57:07,020
Låt mig gå vidare och göra hosta.

2359
01:57:07,020 --> 01:57:08,540
Och, naturligtvis, har jag gjort ett misstag.

2360
01:57:08,540 --> 01:57:10,410
>> Helvete, det är det
implicit deklaration.

2361
01:57:10,410 --> 01:57:11,325
Men det är bra.

2362
01:57:11,325 --> 01:57:12,590
Det är en enkel fix.

2363
01:57:12,590 --> 01:57:18,240
Jag behöver bara en prototyp högre upp
i min fil än jag faktiskt använder det.

2364
01:57:18,240 --> 01:57:20,070
>> Så nu vill jag göra hosta igen, trevlig.

2365
01:57:20,070 --> 01:57:20,790
Nu fungerar det.

2366
01:57:20,790 --> 01:57:22,930
Gör hosta, hosta, hosta, hosta.

2367
01:57:22,930 --> 01:57:25,930
Så du kanske tror att vi är riktigt
drygt engineering detta problem.

2368
01:57:25,930 --> 01:57:26,763
Och faktiskt, vi är.

2369
01:57:26,763 --> 01:57:28,870
Detta är inte en bra
kandidat för ett program

2370
01:57:28,870 --> 01:57:31,930
just nu för
refactoring, och gör vad som är

2371
01:57:31,930 --> 01:57:35,645
kallad hierarkisk nedbrytning,
där du tar lite kod, och sedan

2372
01:57:35,645 --> 01:57:38,790
du typ av faktor saker ut, så som
att tillskriva fler semantik till dem,

2373
01:57:38,790 --> 01:57:40,930
och återanvända det i slutändan längre sikt.

2374
01:57:40,930 --> 01:57:43,490
Men det är en byggsten mot
mer sofistikerade program

2375
01:57:43,490 --> 01:57:45,600
att vi kommer att börja
skriver inom kort att

2376
01:57:45,600 --> 01:57:50,090
tillåter oss att ha ordförråd
som man kan skriva bättre kod.

2377
01:57:50,090 --> 01:57:52,920
Och faktiskt, låt oss se om vi
kan inte generalisera detta ytterligare.

2378
01:57:52,920 --> 01:57:57,984
>> Det verkar lite lam som jag, huvudsakligt,
behöver oroa dig för detta darn för slinga,

2379
01:57:57,984 --> 01:57:59,400
och ringer hosta och om igen.

2380
01:57:59,400 --> 01:58:03,050
Varför kan jag inte säga just hosta,
vänligen hosta tre gånger?

2381
01:58:03,050 --> 01:58:08,170
Med andra ord, varför kan inte jag bara
ge bidrag till hosta och göra detta?

2382
01:58:08,170 --> 01:58:11,270
>> Varför kan inte jag bara säga, i
Huvud hosta tre gånger.

2383
01:58:11,270 --> 01:58:13,150
Och nu är den här typen av magiska.

2384
01:58:13,150 --> 01:58:14,540
Det är väldigt iterativ här.

2385
01:58:14,540 --> 01:58:15,940
Och det är faktiskt en baby steg.

2386
01:58:15,940 --> 01:58:19,250
>> Men bara möjligheten att säga om
linjen åtta, hosta tre gånger,

2387
01:58:19,250 --> 01:58:20,730
det är bara så mycket mer lättläst.

2388
01:58:20,730 --> 01:58:24,210
Och plus, jag behöver inte veta
eller bryr sig om hur hosta genomförs.

2389
01:58:24,210 --> 01:58:26,460
Och faktiskt, senare i
sikt och för slutprojekt,

2390
01:58:26,460 --> 01:58:29,150
Om du ta itu med ett projekt med
en klasskamrat eller två klasskamrater,

2391
01:58:29,150 --> 01:58:32,370
kommer du att inse att du kommer att
måste, eller vill, dela upp arbetet.

2392
01:58:32,370 --> 01:58:34,650
>> Och du kommer att vilja bestämma
i förväg, som kommer att göra vad,

2393
01:58:34,650 --> 01:58:35,483
och i vilka delar?

2394
01:58:35,483 --> 01:58:37,520
Och skulle det inte vara trevligt
om du till exempel,

2395
01:58:37,520 --> 01:58:40,100
ta hand om skrivhuvud, gjort.

2396
01:58:40,100 --> 01:58:43,470
Och din kamrat, eller din
partner mer generellt,

2397
01:58:43,470 --> 01:58:45,230
tar hand om genomförandet av hosta.

2398
01:58:45,230 --> 01:58:49,540
>> Och denna uppdelning, dessa
väggar av abstraktion,

2399
01:58:49,540 --> 01:58:52,310
eller lager av abstraktion förekommande
du kommer är super kraftfull,

2400
01:58:52,310 --> 01:58:55,480
eftersom i synnerhet för större,
mer komplexa program och system,

2401
01:58:55,480 --> 01:59:00,070
Det gör att flera personer att bygga
saker tillsammans, och slutligen

2402
01:59:00,070 --> 01:59:02,680
sy sitt arbete tillsammans på det här sättet.

2403
01:59:02,680 --> 01:59:05,332
Men, naturligtvis, vi
måste nu rätta hosta.

2404
01:59:05,332 --> 01:59:07,290
Vi måste tala om hosta
att hej, vet du vad?

2405
01:59:07,290 --> 01:59:11,230
Du kommer att behöva ta en
input-- så inte ogiltig, men int och nu.

2406
01:59:11,230 --> 01:59:15,170
Låt oss gå vidare och sätta in
hosta int. Jag blir noll.

2407
01:59:15,170 --> 01:59:16,890
>> i är mindre än hur många gånger.

2408
01:59:16,890 --> 01:59:18,550
Jag sa tre innan.

2409
01:59:18,550 --> 01:59:20,420
Men det är inte vad jag vill.

2410
01:59:20,420 --> 01:59:25,520
Jag vill hosta att generaliseras till
stödja vilket som helst antal iterationer.

2411
01:59:25,520 --> 01:59:28,800
>> Så, ja, det är n som jag vill,
vad användaren säger.

2412
01:59:28,800 --> 01:59:31,620
Nu kan jag gå vidare och säga utskrifts hosta.

2413
01:59:31,620 --> 01:59:34,750
Och oavsett hur många
användaren passerar,

2414
01:59:34,750 --> 01:59:36,890
Jag kommer att upprepa det många gånger.

2415
01:59:36,890 --> 01:59:39,160
>> Så i slutet av dagen,
Programmet är identiska.

2416
01:59:39,160 --> 01:59:42,820
Men märker allt det här
kan även vara i en annan fil.

2417
01:59:42,820 --> 01:59:45,620
I själva verket vet jag inte på
ögonblick hur printf genomförs.

2418
01:59:45,620 --> 01:59:47,980
>> Jag vet inte just nu hur får
sträng, eller få int, eller få flyta

2419
01:59:47,980 --> 01:59:48,646
genomförs.

2420
01:59:48,646 --> 01:59:50,930
Och jag vill inte
se dem på min skärm.

2421
01:59:50,930 --> 01:59:55,320
Som det är, jag börjar att fokusera på
mitt program, inte dessa funktioner.

2422
01:59:55,320 --> 01:59:59,070
>> Och så, ja, så fort du
börja facto kod som detta,

2423
01:59:59,070 --> 02:00:01,397
kunde vi flytta även hosta
till en separat fil?

2424
02:00:01,397 --> 02:00:02,730
Någon annan skulle kunna genomföra det.

2425
02:00:02,730 --> 02:00:06,810
Och du och ditt program blir det
mycket vacker, och mycket läsvärd,

2426
02:00:06,810 --> 02:00:10,830
utan tvekan, verkligen fyra
line program direkt.

2427
02:00:10,830 --> 02:00:13,510
>> Så låt oss gå vidare nu
och göra en mer förändring.

2428
02:00:13,510 --> 02:00:16,180
Lägg märke till att min prototyp
måste förändras uppe.

2429
02:00:16,180 --> 02:00:18,390
Så låt mig fixa det så
Jag inte får skrek åt.

2430
02:00:18,390 --> 02:00:22,580
>> Gör hosta, låt mig köra hosta gång
mer, fortfarande gör samma sak.

2431
02:00:22,580 --> 02:00:26,010
Men nu märker vi har en
ingrediens för en slutlig version.

2432
02:00:26,010 --> 02:00:26,940
Vet du vad?

2433
02:00:26,940 --> 02:00:29,040
Jag vill inte bara hosta, nödvändigtvis.

2434
02:00:29,040 --> 02:00:30,802
Jag vill ha något mer allmänt.

2435
02:00:30,802 --> 02:00:31,510
Så du vet vad?

2436
02:00:31,510 --> 02:00:32,450
Jag vill göra detta.

2437
02:00:32,450 --> 02:00:37,140
Jag vill ha, mycket som Scratch
gör, något att säga blocket, men inte bara

2438
02:00:37,140 --> 02:00:38,680
säga något några antal gånger.

2439
02:00:38,680 --> 02:00:41,510
Jag vill att det ska säga en mycket specifik sträng.

2440
02:00:41,510 --> 02:00:43,850
Och därför gör jag inte
vill att det ska bara säga hosta.

2441
02:00:43,850 --> 02:00:47,660
Jag vill att det ska säga vad
sträng ledes in.

2442
02:00:47,660 --> 02:00:49,960
>> Så märker har jag generaliserat
detta så att nu

2443
02:00:49,960 --> 02:00:53,110
säg känns som ett bra namn
för detta, som Scratch,

2444
02:00:53,110 --> 02:00:55,530
tar två argument, till skillnad från Scratch.

2445
02:00:55,530 --> 02:00:56,570
Den ena är en sträng.

2446
02:00:56,570 --> 02:00:57,300
Den ena är en int.

2447
02:00:57,300 --> 02:00:58,130
>> Och jag kunde byta dem.

2448
02:00:58,130 --> 02:01:00,713
Jag ungefär som tanken på
säga strängen först, och sedan

2449
02:01:00,713 --> 02:01:01,940
hur många gånger senare.

2450
02:01:01,940 --> 02:01:03,970
Void betyder det fortfarande
inte tillbaka något.

2451
02:01:03,970 --> 02:01:06,428
Dessa är bara visuella sidan
effekter, som med [? Jordan,?]

2452
02:01:06,428 --> 02:01:08,240
en verbal bieffekt av skrika.

2453
02:01:08,240 --> 02:01:12,630
Det gör fortfarande något n gånger,
0 upp till, men inte lika med n.

2454
02:01:12,630 --> 02:01:14,540
Detta innebär n totaltider.

2455
02:01:14,540 --> 02:01:16,540
Och sedan bara skriva ut
vad den strängen är.

2456
02:01:16,540 --> 02:01:19,060
Så jag har verkligen gener
denna kodrad.

2457
02:01:19,060 --> 02:01:22,460
Så nu, hur använder jag
hosta funktion?

2458
02:01:22,460 --> 02:01:25,520
>> Jag kan göra void hosta.

2459
02:01:25,520 --> 02:01:28,501
Och jag kan fortfarande ta in hur
många gånger du vill hosta.

2460
02:01:28,501 --> 02:01:29,250
Men vet du vad?

2461
02:01:29,250 --> 02:01:31,240
Jag kan nu punt att säga.

2462
02:01:31,240 --> 02:01:36,540
>> Jag kan ringa säga med
Ordet hosta, passerar n.

2463
02:01:36,540 --> 02:01:40,410
Och om jag vill också genomföra,
bara för skojs skull, en nysning funktion,

2464
02:01:40,410 --> 02:01:42,290
Jag kan nysa viss antal gånger.

2465
02:01:42,290 --> 02:01:47,300
Och jag kan hålla åter n, eftersom
märka att m i detta sammanhang eller omfattning

2466
02:01:47,300 --> 02:01:49,470
endast existerar inom denna funktion.

2467
02:01:49,470 --> 02:01:52,767
>> Och n i detta sammanhang endast
existerar inom denna funktion här.

2468
02:01:52,767 --> 02:01:54,600
Så vi kommer tillbaka till
dessa frågor om räckvidd.

2469
02:01:54,600 --> 02:02:01,160
Och här, jag kommer bara att säga,
Achoo, och sedan n gånger, semikolon.

2470
02:02:01,160 --> 02:02:04,340
>> Och nu, jag behöver bara låna
dessa funktion signaturer upp här.

2471
02:02:04,340 --> 02:02:06,290
Så hosta är korrekt.

2472
02:02:06,290 --> 02:02:10,090
Void nysning är rätt nu.

2473
02:02:10,090 --> 02:02:12,390
>> Och jag fortfarande behöver bara säga.

2474
02:02:12,390 --> 02:02:18,990
Så jag kommer att säga, säg
string s, int n, semikolon.

2475
02:02:18,990 --> 02:02:22,010
Så jag har över iscensatte
fan av detta program.

2476
02:02:22,010 --> 02:02:23,760
>> Och detta inte
nödvändigtvis är

2477
02:02:23,760 --> 02:02:26,343
vad du ska göra när du skriver
även den enklaste av program.

2478
02:02:26,343 --> 02:02:29,280
Ta något som är självklart
verkligen enkelt, riktigt kort,

2479
02:02:29,280 --> 02:02:31,800
och åter genomföra den
använder alldeles för mycket kod.

2480
02:02:31,800 --> 02:02:34,560
Men du faktiskt se, och i
tid ser tillbaka på dessa exempel,

2481
02:02:34,560 --> 02:02:38,610
och inser, oh, det är de steg
Vi tog faktiskt generalisera,

2482
02:02:38,610 --> 02:02:40,797
faktor ut något,
tills vid slutet av dagen

2483
02:02:40,797 --> 02:02:42,380
min kod är faktiskt ganska rimlig.

2484
02:02:42,380 --> 02:02:45,960
För om jag vill hosta tre
gånger nys sedan tre gånger,

2485
02:02:45,960 --> 02:02:50,420
Jag kommer helt enkelt att köra detta,
Programmet gör hosta och köra hosta.

2486
02:02:50,420 --> 02:02:53,620
Och jag har tre hosta
och tre nysningar.

2487
02:02:53,620 --> 02:02:55,990
>> Och så detta är en grundläggande
paradigm, om man så vill,

2488
02:02:55,990 --> 02:03:00,110
för hur vi kan gå om
faktiskt genomföra ett program.

2489
02:03:00,110 --> 02:03:03,220
Men låt oss bara se nu vad det är
vi har gjort hela denna tid,

2490
02:03:03,220 --> 02:03:06,940
och vad några av de slutliga bitarna
ligger bakom denna enkla kommando.

2491
02:03:06,940 --> 02:03:09,620
Vid slutet av dagen, vi har
använt Clang som vår kompilator.

2492
02:03:09,620 --> 02:03:11,494
Vi har skrivit källa
kod, omvandla den

2493
02:03:11,494 --> 02:03:12,820
via Clang till maskinkod.

2494
02:03:12,820 --> 02:03:15,540
>> Och vi har använt Gör bara
för att underlätta våra tangenttryckningar så

2495
02:03:15,540 --> 02:03:20,740
att vi inte behöver komma ihåg
dessa besvärjelsear av Clang självt.

2496
02:03:20,740 --> 02:03:22,640
Men vad är Gör egentligen gör?

2497
02:03:22,640 --> 02:03:24,750
Och i sin tur, vad som är
Clang faktiskt gör?

2498
02:03:24,750 --> 02:03:28,790
>> Det visar sig, även om vi har förenklat
dagens diskussion genom att säga,

2499
02:03:28,790 --> 02:03:33,090
du ta källkoden, skicka den som
ingång till en kompilator, som ger dig

2500
02:03:33,090 --> 02:03:35,750
utgången från maskinen
kod, visar sig att det är

2501
02:03:35,750 --> 02:03:37,420
några olika steg inuti det.

2502
02:03:37,420 --> 02:03:41,940
Och sammanställa råkar vara paraplyet
term för en massa steg.

2503
02:03:41,940 --> 02:03:43,970
Men låt oss bara retas
detta ut riktigt snabbt.

2504
02:03:43,970 --> 02:03:48,070
>> Det visar sig att vi har gjort
fler saker varje gång jag kör ett program,

2505
02:03:48,070 --> 02:03:50,990
eller varje gång jag kompilera ett program i dag.

2506
02:03:50,990 --> 02:03:55,020
Så förbehandling avser
this-- något i ett C-program,

2507
02:03:55,020 --> 02:03:58,720
som vi ser om och om igen,
som börjar med denna hash symbol,

2508
02:03:58,720 --> 02:04:03,320
eller hashtaggen symbolen här betyder
Det är ett direktiv preprocessor.

2509
02:04:03,320 --> 02:04:07,330
Det betyder i detta fall, hej
dator, göra något med den här filen

2510
02:04:07,330 --> 02:04:09,430
innan du faktiskt kompilera min egen kod.

2511
02:04:09,430 --> 02:04:15,220
>> I det här fallet, hash inkluderar vill säga,
i huvudsak, C: s sätt att säga,

2512
02:04:15,220 --> 02:04:19,325
hej dator, gå och hämta innehållet
av CS50.h och klistra in dem här.

2513
02:04:19,325 --> 02:04:22,170
Hej dator, gå och hämta den
Innehållet i standard io.h,

2514
02:04:22,170 --> 02:04:24,690
överallt där det är på
hårddisk, klistra in den här.

2515
02:04:24,690 --> 02:04:27,390
Så dessa saker händer
först under förbehandlingen.

2516
02:04:27,390 --> 02:04:28,880
>> Och Clang gör allt detta för oss.

2517
02:04:28,880 --> 02:04:30,510
Och det gör det så jäkla
snabb, du behöver inte ens

2518
02:04:30,510 --> 02:04:32,000
se fyra olika saker som händer.

2519
02:04:32,000 --> 02:04:34,100
Men det är den första steget.

2520
02:04:34,100 --> 02:04:35,560
>> Vad som egentligen händer härnäst?

2521
02:04:35,560 --> 02:04:38,320
Tja, nästa officiella
steg sammanställer.

2522
02:04:38,320 --> 02:04:40,385
Och det visar sig att
sammanställa ett program

2523
02:04:40,385 --> 02:04:44,060
tekniskt innebär att gå från
källkod, de saker som vi har

2524
02:04:44,060 --> 02:04:47,890
skrivit i dag, något
kallas assemblerkod, något

2525
02:04:47,890 --> 02:04:49,260
som ser lite annorlunda.

2526
02:04:49,260 --> 02:04:51,050
>> Och i själva verket kan vi se detta riktigt snabbt.

2527
02:04:51,050 --> 02:04:53,890
Låt mig faktiskt gå in i min IDE.

2528
02:04:53,890 --> 02:04:58,050
Låt mig gå vidare och öppna hej.c, som
är det allra första program med vilket vi

2529
02:04:58,050 --> 02:04:59,120
började idag.

2530
02:04:59,120 --> 02:05:04,130
Och låt mig gå vidare och köra klang en
lite annorlunda, klang-s, hej.c,

2531
02:05:04,130 --> 02:05:07,720
som faktiskt kommer att
ge mig en annan fil hello.s.

2532
02:05:07,720 --> 02:05:10,330
>> Och vi kommer förmodligen aldrig
igen se denna typ av kod.

2533
02:05:10,330 --> 02:05:13,030
Om du tar en lägre nivå
system av klass som CS61,

2534
02:05:13,030 --> 02:05:14,920
du kommer att se en mycket mer
av denna typ av kod.

2535
02:05:14,920 --> 02:05:17,020
Men detta är assembler.

2536
02:05:17,020 --> 02:05:22,050
Detta är X86 assembler
att processorn som underliggande

2537
02:05:22,050 --> 02:05:24,460
CS50 IDE faktiskt förstår.

2538
02:05:24,460 --> 02:05:27,060
>> Och kryptiska som det gör
se, det är något

2539
02:05:27,060 --> 02:05:29,180
datorn förstår ganska bra.

2540
02:05:29,180 --> 02:05:30,790
Sub q, detta är en subtrahera.

2541
02:05:30,790 --> 02:05:31,660
Det finns rörelser.

2542
02:05:31,660 --> 02:05:35,730
>> Det ringer funktioner här,
x oring, en rörelse, ett tillägg, en pop,

2543
02:05:35,730 --> 02:05:36,430
avkastning.

2544
02:05:36,430 --> 02:05:38,850
Så det finns några mycket
instruktioner låg nivå

2545
02:05:38,850 --> 02:05:41,280
att processorer förstår att
Jag hänvisade till tidigare.

2546
02:05:41,280 --> 02:05:43,100
Det är vad Intel Inside.

2547
02:05:43,100 --> 02:05:45,030
>> Det finns mönster av
nollor och ettor som

2548
02:05:45,030 --> 02:05:51,800
mappas till dessa arcanely formulerad, men
något väl namnges, instruktioner,

2549
02:05:51,800 --> 02:05:52,780
så att säga.

2550
02:05:52,780 --> 02:05:54,780
Det är vad som händer när
du kompilera koden.

2551
02:05:54,780 --> 02:05:58,560
Du får montering
språk av det, som

2552
02:05:58,560 --> 02:06:04,680
betyder det tredje steget är att montera
att assemblerkod i slutändan,

2553
02:06:04,680 --> 02:06:09,080
maskin code-- nollor och ettor, inte
text som vi såg bara en liten stund sedan.

2554
02:06:09,080 --> 02:06:13,370
>> Så förbearbetning gör att hitta
och byt ut, och några andra saker.

2555
02:06:13,370 --> 02:06:16,430
Sammanställa tar din källa
kod från C, källkod

2556
02:06:16,430 --> 02:06:18,980
att vi skrev, till montering
kod som vi bara såg på.

2557
02:06:18,980 --> 02:06:22,170
Montering tar att monteringen
kod till ettor och nollor

2558
02:06:22,170 --> 02:06:24,680
att processorn verkligen kommer
förstå i slutet av dagen.

2559
02:06:24,680 --> 02:06:27,630
Och länkning är det sista steget
det händer för oss-- igen,

2560
02:06:27,630 --> 02:06:29,830
så fort vi inte ens
notice-- som säger,

2561
02:06:29,830 --> 02:06:32,460
hej dator, ta alla
nollor och ettor som

2562
02:06:32,460 --> 02:06:36,750
berodde på att sammanställa Davids kod,
och hans huvudsakliga funktion i det här fallet.

2563
02:06:36,750 --> 02:06:39,160
>> Och hey dator, gå och hämta
alla nollor och ettor

2564
02:06:39,160 --> 02:06:42,180
att CS50 personal skrev
inne i CS50 biblioteket.

2565
02:06:42,180 --> 02:06:43,440
Blanda dem in med Davids.

2566
02:06:43,440 --> 02:06:46,648
Och hey dator, gå och hämta alla nollor
och de som någon annan skrev år

2567
02:06:46,648 --> 02:06:47,470
sedan för printf.

2568
02:06:47,470 --> 02:06:49,880
Och lägga till dem i
hela, så att vi har

2569
02:06:49,880 --> 02:06:52,870
fick mina nollor och ettor, den
CS50 personalens nollor och ettor,

2570
02:06:52,870 --> 02:06:55,370
printf nollor och ettor,
och allt annat vi använder.

2571
02:06:55,370 --> 02:07:00,410
>> Alla får kombineras ihop till en
program som kallas, i detta fall, hej.

2572
02:07:00,410 --> 02:07:03,141
Så hädanefter kommer vi bara
använda ordet sammanställningen.

2573
02:07:03,141 --> 02:07:06,390
Och vi kommer att ta för givet att när
vi säger, kompilera program, det betyder,

2574
02:07:06,390 --> 02:07:08,849
hej gör förbehandling,
montering, och länkning.

2575
02:07:08,849 --> 02:07:11,890
Men det finns faktiskt några saftiga saker
händer där under huven.

2576
02:07:11,890 --> 02:07:13,723
Och speciellt om du
få veta lite tid,

2577
02:07:13,723 --> 02:07:15,900
du kan börja peta
runt på denna lägre nivå.

2578
02:07:15,900 --> 02:07:19,660
Men nu, inser att
bland hämtställen för idag

2579
02:07:19,660 --> 02:07:23,420
är helt enkelt
i början av en process,

2580
02:07:23,420 --> 02:07:26,700
att få bekväm med
något liknande hello world.

2581
02:07:26,700 --> 02:07:29,575
I själva verket de flesta av vad vi gjorde i dag
säkerligen inte kommer att sjunka i supersnabb.

2582
02:07:29,575 --> 02:07:31,491
Och det kommer att dröja
tid och lite övning.

2583
02:07:31,491 --> 02:07:33,864
Och oddsen är, kommer du sortera
av vill träffa tangentbordet

2584
02:07:33,864 --> 02:07:34,780
eller skrika på skärmen.

2585
02:07:34,780 --> 02:07:35,880
Och allt detta är OK.

2586
02:07:35,880 --> 02:07:38,320
Men kanske försöka att inte
gör det i biblioteket så mycket.

2587
02:07:38,320 --> 02:07:40,820
>> Och i slutändan kommer du
Kunna dock att starta

2588
02:07:40,820 --> 02:07:44,580
se mönster, både i bra kod
att du har skrivit och misstag

2589
02:07:44,580 --> 02:07:45,370
att du har gjort.

2590
02:07:45,370 --> 02:07:48,965
Och likt processen för
blir en TF eller en CA är,

2591
02:07:48,965 --> 02:07:51,590
du börjar bli bättre och
bättre på att se dessa mönster,

2592
02:07:51,590 --> 02:07:53,774
och bara lösa ditt
egna problem i slutändan.

2593
02:07:53,774 --> 02:07:56,940
Under tiden kommer det att finnas gott
av oss att ge dig stöd, och få dig

2594
02:07:56,940 --> 02:07:57,481
genom detta.

2595
02:07:57,481 --> 02:07:59,450
Och i uppskrivningar
för alla de problem

2596
02:07:59,450 --> 02:08:01,366
kommer du att guidas genom
alla kommandon

2597
02:08:01,366 --> 02:08:05,330
att jag vet säkert från
en hel del övning nu,

2598
02:08:05,330 --> 02:08:07,380
men kanske har flugit
över huvudet för nu.

2599
02:08:07,380 --> 02:08:08,580
Och det är helt bra.

2600
02:08:08,580 --> 02:08:11,230
>> Men i slutändan, du kommer
att börja se mönster växa fram.

2601
02:08:11,230 --> 02:08:14,260
Och när du komma förbi alla
dumma detaljer, som parenteser,

2602
02:08:14,260 --> 02:08:16,710
och klamrar, och semikolon,
och saker, ärligt talat,

2603
02:08:16,710 --> 02:08:19,360
det är inte alls
intellektuellt intressant.

2604
02:08:19,360 --> 02:08:22,690
Och det är inte syftet med
tar något inledande klass.

2605
02:08:22,690 --> 02:08:24,410
Det är idéerna som kommer spela någon roll.

2606
02:08:24,410 --> 02:08:26,659
>> Det är loopar, och
villkor, och funktioner,

2607
02:08:26,659 --> 02:08:30,552
och mer kraftfullt uttag,
och factoring av koden,

2608
02:08:30,552 --> 02:08:33,510
och god design, och den goda
stil, och i slutändan riktigheten

2609
02:08:33,510 --> 02:08:37,330
av din kod, det är i slutändan
kommer att fråga mest.

2610
02:08:37,330 --> 02:08:40,925
Så nästa vecka kommer vi att ta dessa
idéer som vi först såg i Scratch

2611
02:08:40,925 --> 02:08:42,800
och har nu översatts
C. Och vi börjar

2612
02:08:42,800 --> 02:08:45,740
att införa den första av
kursens verkliga världen domäner.

2613
02:08:45,740 --> 02:08:50,140
>> Vi ska fokusera på världen av säkerhet,
och mer specifikt kryptografi,

2614
02:08:50,140 --> 02:08:51,980
konsten att förvrängningsinformation.

2615
02:08:51,980 --> 02:08:54,000
Och bland de första
problem man själv

2616
02:08:54,000 --> 02:08:56,840
kommer att få skriva längre
leker med några av syntaxen

2617
02:08:56,840 --> 02:08:59,880
och lösa några logiska
problem i slutändan snart,

2618
02:08:59,880 --> 02:09:03,960
är att faktiskt klättra, eller kryptera,
och slutligen dekryptera information.

2619
02:09:03,960 --> 02:09:06,470
Och allt vi har gjort
idag, ganska kommer låg

2620
02:09:06,470 --> 02:09:09,190
nivå, bara kommer att tillåta
oss att ta en och en,

2621
02:09:09,190 --> 02:09:13,550
och ett steg ovan mot
skriver de mest intressanta koden ännu.

2622
02:09:13,550 --> 02:09:15,050
>> Så mer om det nästa vecka.

2623
02:09:15,050 --> 02:09:17,834

2624
02:09:17,834 --> 02:09:18,762
>> [VIDEOUPPSPELNING]

2625
02:09:18,762 --> 02:09:19,690

2626
02:09:19,690 --> 02:09:22,006
>> -Vad Kan du berätta om
den sista gången du såg honom?

2627
02:09:22,006 --> 02:09:26,041

2628
02:09:26,041 --> 02:09:27,040
-Vad Kan jag säga, egentligen?

2629
02:09:27,040 --> 02:09:30,500

2630
02:09:30,500 --> 02:09:35,340
Jag menar, det var som alla andra
förproduktion repetition,

2631
02:09:35,340 --> 02:09:40,510
utom fanns något sade han
i slutet som fastnat med mig.

2632
02:09:40,510 --> 02:09:44,810

2633
02:09:44,810 --> 02:09:46,640
>> -detta Var CS50.

2634
02:09:46,640 --> 02:09:49,440

2635
02:09:49,440 --> 02:09:52,190
>> -Det Är ett snitt alla,
bra jobb på repetition.

2636
02:09:52,190 --> 02:09:53,070
>> -Det Lunch?

2637
02:09:53,070 --> 02:09:54,986
>> -Ja, Du och jag kan
ta en smörgås i en bit.

2638
02:09:54,986 --> 02:09:58,380
Låt mig bara debriefing med
David riktigt snabbt.

2639
02:09:58,380 --> 02:09:59,160
David?

2640
02:09:59,160 --> 02:10:01,260
David?

2641
02:10:01,260 --> 02:10:03,110
>> [END SPELA]

