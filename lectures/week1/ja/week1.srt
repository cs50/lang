1
00:00:00,000 --> 00:00:00,000

2
00:00:00,000 --> 00:00:00,000
[MUSICのPLAYING]

3
00:00:00,000 --> 00:00:13,950

4
00:00:13,950 --> 00:00:16,240
>> DAVID J.マラン：すべての権利、これはCS50です。

5
00:00:16,240 --> 00:00:18,010
そしてこれは1週間です。

6
00:00:18,010 --> 00:00:22,050
だから、0週目でその最後の時間を思い出します
我々は、計算の考え方に焦点を当てました。

7
00:00:22,050 --> 00:00:25,440
そして、我々はそれからに移行しました
スクラッチ、グラフィカルプログラミング

8
00:00:25,440 --> 00:00:27,360
私たちの友人から言語
MITのメディアラボで。

9
00:00:27,360 --> 00:00:31,730
>> そして、スクラッチで、我々は探検でした
機能、および条件などのアイデア、

10
00:00:31,730 --> 00:00:35,210
偶数とループ、変数、
イベント、スレッド、およびより多くの。

11
00:00:35,210 --> 00:00:37,880
そして今日、私たちはするつもりです
これらのアイデアを使用し続けます、

12
00:00:37,880 --> 00:00:40,630
本当にためにそれらを取ります
付与されたが、それらを翻訳

13
00:00:40,630 --> 00:00:44,220
C.今として知られている他の言語に、
Cは、より伝統的な言語です。

14
00:00:44,220 --> 00:00:46,020
これは、より低いレベルです
言語、可能ならば。

15
00:00:46,020 --> 00:00:47,300
>> それは純粋なテキストです。

16
00:00:47,300 --> 00:00:49,910
だから一見、それはです
すべてむしろ不可解見に行きます

17
00:00:49,910 --> 00:00:51,430
あなたは以前にプログラムされたことがない場合。

18
00:00:51,430 --> 00:00:53,530
我々は、必要があるとしています
セミコロン、括弧、

19
00:00:53,530 --> 00:00:55,150
そして、中括弧、およびより多くの。

20
00:00:55,150 --> 00:00:57,240
しかし、それさえ実現
構文は次のとおりですが、

21
00:00:57,240 --> 00:01:00,600
少し不慣れに見えることを約
あなたのほとんどに、その過ぎ参照してください。

22
00:01:00,600 --> 00:01:03,220
やアイデアを参照してみてください
それは、確かに、おなじみの、

23
00:01:03,220 --> 00:01:06,750
ここでは週に1どのような理由
我々は、比較することです行うことから始めましょう

24
00:01:06,750 --> 00:01:08,980
当初、C.対スクラッチ

25
00:01:08,980 --> 00:01:12,350
>> そのように、例えば、そのときに我々リコール
我々のプログラムの最初の実装

26
00:01:12,350 --> 00:01:16,220
最後の時間、私たちは見てのブロックを持っていました
this--ときのような小さなもの

27
00:01:16,220 --> 00:01:19,990
緑の旗をクリックし、次に我々が持っていました
その下の1以上のパズルのピース、

28
00:01:19,990 --> 00:01:22,150
この場合には、Hello Worldの、と言います。

29
00:01:22,150 --> 00:01:24,870
だから、確かに、スクラッチで、
私は緑色の旗をクリックしたとき

30
00:01:24,870 --> 00:01:27,390
そう、私のプログラムを実行します
これらは、話すこと

31
00:01:27,390 --> 00:01:29,520
実行されるブロック、または実行。

32
00:01:29,520 --> 00:01:32,230
そして、具体的には、スクラッチ
こんにちは、世界、と述べました。

33
00:01:32,230 --> 00:01:35,377
>> 今、私は指定されている可能性が
ここでは異なる言葉。

34
00:01:35,377 --> 00:01:37,960
しかし、我々は確かに、その多くが表示されます
確かにこれらのblocks--との、

35
00:01:37,960 --> 00:01:41,880
C言語で多くのfunctions--をすることができます
パラメータ化またはカスタマイズ

36
00:01:41,880 --> 00:01:43,150
異なるものを行います。

37
00:01:43,150 --> 00:01:45,520
実際には、我々の場合C言語で
今、変換したいです、

38
00:01:45,520 --> 00:01:47,567
このスクラッチプログラム
この他の言語に、

39
00:01:47,567 --> 00:01:49,650
我々は書くつもりです
このような少し何か。

40
00:01:49,650 --> 00:01:52,540
>> 確かに、いくつかのなじみのない存在であります
そこ構文ほとんどの場合、int型、

41
00:01:52,540 --> 00:01:54,380
括弧、ボイド。

42
00:01:54,380 --> 00:01:57,740
しかしprintf--も、あなたはでしょうが
それだけで印刷になると思います。

43
00:01:57,740 --> 00:02:00,120
しかし、印刷は印刷を意味します
我々はすぐにわかりますように、フォーマットされています。

44
00:02:00,120 --> 00:02:02,140
これは文字通り、印刷されます
画面に何でも

45
00:02:02,140 --> 00:02:05,990
、それらの括弧の内側にあります
もちろん、この場合には、ハロー世界です。

46
00:02:05,990 --> 00:02:09,290
>> しかし、あなたはいくつかの他のことに気づくでしょう
構文、いくつかの二重引用符、

47
00:02:09,290 --> 00:02:11,890
その末尾に括弧、
セミコロンなどが挙げられます。

48
00:02:11,890 --> 00:02:15,027
だから、オーバーヘッドのビットがあります、
いわば、両方の認知します

49
00:02:15,027 --> 00:02:17,860
そして、文法的に、我々が行っていること
ずっと前に覚えておく必要があります。

50
00:02:17,860 --> 00:02:20,720
しかし、実際にそれを実現
これはあなたに飛び出すを開始します。

51
00:02:20,720 --> 00:02:24,920
>> 実際には、のは、その1に焦点を当ててみましょう
関数は、この場合、specifically--

52
00:02:24,920 --> 00:02:26,290
こんにちは世界を言います。

53
00:02:26,290 --> 00:02:27,560
だから関数であると言います。

54
00:02:27,560 --> 00:02:31,320
こんにちは、世界はそのパラメータであり、
または引数、そのカスタマイズ。

55
00:02:31,320 --> 00:02:34,320
>> そして、Cでの等価性だけです
ここでは、この1行になるだろう、

56
00:02:34,320 --> 00:02:38,710
printf関数は、たとえば、に相当するものであるときは
二重引用符で囲まれた文字列、ハロー

57
00:02:38,710 --> 00:02:41,470
世界は、当然のことながら、同等です
そこに白いボックスに何を。

58
00:02:41,470 --> 00:02:45,680
そして、少しかかわらず、バックスラッシュnを、
不思議と最初から存在しません、

59
00:02:45,680 --> 00:02:49,380
単に私たちはよ効果を持ってしようとしています
私のMacまたはPCのように、コンピュータに表示、

60
00:02:49,380 --> 00:02:51,660
ちょうど移動
次の行にカーソル。

61
00:02:51,660 --> 00:02:53,970
それは打つようなものです
キーボードのEnter。

62
00:02:53,970 --> 00:02:55,580
>> だから私たちはずっと前にそれを再度表示されます。

63
00:02:55,580 --> 00:02:58,640
しかし、最初のは、このを見てみましょう
ループの場合の他の例。

64
00:02:58,640 --> 00:03:02,830
私たちは、前回この永遠にループしていました
パズルのピースのシリーズでした

65
00:03:02,830 --> 00:03:05,490
それは文字通り何かをしました
この場合にはforever--、

66
00:03:05,490 --> 00:03:08,360
世界こんにちは、世界こんにちは、と言います、
世界こんにちは、世界こんにちは。

67
00:03:08,360 --> 00:03:10,350
だから、設計によって無限ループです。

68
00:03:10,350 --> 00:03:14,580
>> Cでは、私たちはこれを実装したい場合
同じアイデアは、我々は単純にこれを行う可能性があります。

69
00:03:14,580 --> 00:03:19,570
今真一方、ハローprintfのworld--
しばらく、ちょうど意味的に、種類の

70
00:03:19,570 --> 00:03:23,090
やっての考えを想起させます
何か再び、そして再び、そして再び、

71
00:03:23,090 --> 00:03:23,980
そしてどのくらいか？

72
00:03:23,980 --> 00:03:27,990
まあ、true--リコールその
真のは、ちょうど上または1です。

73
00:03:27,990 --> 00:03:30,660
>> そして、真のは、常に、もちろん、本当です。

74
00:03:30,660 --> 00:03:33,060
だから、無意味のようなものです
ちょうど真と言って声明。

75
00:03:33,060 --> 00:03:36,890
しかし、確かに、これは意図的であり、
真がちょうど常に真である場合ので、

76
00:03:36,890 --> 00:03:40,850
真はちょうど意味している間よりも、
少し間接的であれば、

77
00:03:40,850 --> 00:03:44,070
次のコード行こと
これらの中括弧の間にあります

78
00:03:44,070 --> 00:03:48,320
もう一度、再度実行する必要があり、
そして再び、実際に停止することはありません。

79
00:03:48,320 --> 00:03:50,230
>> しかし、あなたが望むならば、あなたの
私たちのように、停止するループ

80
00:03:50,230 --> 00:03:54,500
以下のようなもので最後の時間をしました
これは、次の50回繰り返し

81
00:03:54,500 --> 00:03:57,700
C言語で、私たちは何で同じことを行うことができます
キーワードをloop--を呼びかけ

82
00:03:57,700 --> 00:03:59,330
しばらく、しかしためのものではありません。

83
00:03:59,330 --> 00:04:03,290
そして、我々はここでいくつかの新しい構文を持って、
int型で私は、私が50未満、0に等しいです

84
00:04:03,290 --> 00:04:03,880
私は++します。

85
00:04:03,880 --> 00:04:05,430
そして、我々は戻ってそれに来ます。

86
00:04:05,430 --> 00:04:09,660
どのように我々はだろうが、これは単にです
スクラッチ・ブロックのセットを変換

87
00:04:09,660 --> 00:04:13,079
符号のCラインのセットです。

88
00:04:13,079 --> 00:04:14,450
>> 一方、変数を考慮してください。

89
00:04:14,450 --> 00:04:16,540
そして、実際には、我々だけ
一瞬前に見ました。

90
00:04:16,540 --> 00:04:21,220
そして、スクラッチの場合には、我々の場合
私と呼ばれる変数を宣言したかったです

91
00:04:21,220 --> 00:04:24,590
iは整数、ちょうど数であるため、
そして、我々はいくつかの値に設定したいです、

92
00:04:24,590 --> 00:04:28,410
私たちは、このオレンジ色を使用します
ブロックhere-- iが0に設定してください。

93
00:04:28,410 --> 00:04:30,800
>> そして、私たちは今日見るだろうと
超えて、ちょうど先週のように、

94
00:04:30,800 --> 00:04:33,850
プログラマはほとんど常に行います
本当に、ゼロからカウントを開始

95
00:04:33,850 --> 00:04:34,950
慣例により。

96
00:04:34,950 --> 00:04:37,250
しかし、また、リコールの理由
バイナリの議論、

97
00:04:37,250 --> 00:04:39,990
最小数のことができます。
任意のビット数で表します

98
00:04:39,990 --> 00:04:41,640
ちょうど0そのものになるだろう。

99
00:04:41,640 --> 00:04:45,190
そして、私たちは一般的に開始します
0にしても私達の変数を初期化します。

100
00:04:45,190 --> 00:04:47,710
>> そして、C言語で同じことを行うには、
我々はint型を言おうとしています

101
00:04:47,710 --> 00:04:50,110
整数のための、私だけの慣例により。

102
00:04:50,110 --> 00:04:53,390
私は、この変数と呼ばれている可能性が
私が欲しいものは、単にスクラッチで好きです。

103
00:04:53,390 --> 00:04:57,770
そして、0だけ割り当てに等しいです
右から値0

104
00:04:57,770 --> 00:05:01,319
変数に格納します、または
左側の存在貯蔵容器、。

105
00:05:01,319 --> 00:05:04,360
そして、セミコロン我々はsee--ますように
我々はこれらのalready--のいくつかを見てきました

106
00:05:04,360 --> 00:05:06,530
ちょうど思考の終わりを意味します。

107
00:05:06,530 --> 00:05:09,430
何かを行うに進みます
続く行に。

108
00:05:09,430 --> 00:05:11,330
>> さて、どのようなブール式は？

109
00:05:11,330 --> 00:05:14,320
スクラッチでそれを思い出し、
これらは表現しました

110
00:05:14,320 --> 00:05:16,740
いずれかの真であること
またはfalse--質問、

111
00:05:16,740 --> 00:05:18,910
本当に、trueまたはfalseのいずれかであること。

112
00:05:18,910 --> 00:05:21,960
だから、スクラッチの場合、我々はかもしれません
このような単純な質問をし、

113
00:05:21,960 --> 00:05:24,586
iが50未満ですか？

114
00:05:24,586 --> 00:05:25,710
だから私は、再び、整数です。

115
00:05:25,710 --> 00:05:27,210
多分、我々はそれを使用しています
スクラッチプログラムで

116
00:05:27,210 --> 00:05:29,310
スコアを追跡するために
またはそのような何か。

117
00:05:29,310 --> 00:05:33,810
ここではスクラッチでだからこの構文
ちょうど私が50未満である、ことを意味？

118
00:05:33,810 --> 00:05:37,330
まあ、ありがたいことに、何かがあります
C.が簡単で翻訳し、

119
00:05:37,330 --> 00:05:41,780
これは、私たちは私がそれほど単純に言うだろう
50よりも、使い慣れたキーを使用して、

120
00:05:41,780 --> 00:05:42,850
キーボードの。

121
00:05:42,850 --> 00:05:45,141
>> 一方、あなたがしたい場合
、より一般的な何かを言います

122
00:05:45,141 --> 00:05:49,890
ここで、各ような、よく、yよりもX以下であります
xとyの自身の変数がありますか？

123
00:05:49,890 --> 00:05:52,280
私たちは同じことを行うことができます
Cには、あまりにも長い間、私たちはきたように

124
00:05:52,280 --> 00:05:53,942
すでにこれらの変数を作成しました。

125
00:05:53,942 --> 00:05:55,650
そして、私たちはどのように表示されます
前に長いことを行います。

126
00:05:55,650 --> 00:05:58,590
私たちは、単純にyよりxが小さいと言うでしょう。

127
00:05:58,590 --> 00:06:00,530
>> だから、に開始しています
いくつかの類似点を参照してください。

128
00:06:00,530 --> 00:06:03,490
作られ、それらの人々
スクラッチは確かにありま​​した

129
00:06:03,490 --> 00:06:05,250
これらの基本的ないくつかのアイデアに触発さ。

130
00:06:05,250 --> 00:06:10,350
そして、あなたは、この種のを見ることができます
多くのlanguages​​--内の構文

131
00:06:10,350 --> 00:06:12,160
だけではなく、ない傷
ちょうどCが、Pythonの、

132
00:06:12,160 --> 00:06:14,790
そして、JavaScript、および
まだ他の言語。

133
00:06:14,790 --> 00:06:18,270
>> のは、別の構造体を考えてみましょう
C、条件の概念から、

134
00:06:18,270 --> 00:06:20,370
条件付きで何かをします。

135
00:06:20,370 --> 00:06:22,720
何かが真である場合、これを行います。

136
00:06:22,720 --> 00:06:24,457
何か他のものがtrueの場合、それを行います。

137
00:06:24,457 --> 00:06:27,040
これは、プログラミングの一種です
道路の分岐点に相当します。

138
00:06:27,040 --> 00:06:29,730
多分それは、双方向のフォークです、
三方フォーク、以上。

139
00:06:29,730 --> 00:06:32,800
そしてスクラッチで、我々が持っているかもしれません
このようなものを見たこと。

140
00:06:32,800 --> 00:06:34,010
>> したがって、この1は大きな一つです。

141
00:06:34,010 --> 00:06:36,750
しかし、相対を考えます
ロジックのシンプルさ。

142
00:06:36,750 --> 00:06:44,010
xがyよりも小さい場合には、xが小さくなると言います
yより、xがyよりも大きい他の場合には、

143
00:06:44,010 --> 00:06:46,230
その後、xがyよりも大きいと言います。

144
00:06:46,230 --> 00:06:48,300
その後、論理的に、もし
あなたがスクラッチに戻って考えます

145
00:06:48,300 --> 00:06:52,610
またはちょうどあなた自身の人間の直感、
よく、xがyより大きくない場合、そしてx

146
00:06:52,610 --> 00:06:57,000
その後もちろん、Y以上であります
xがyに等しいことになるだろう。

147
00:06:57,000 --> 00:06:59,690
この場合は、入れ子にすることで、だから、
それらのスクラッチ・ブロック、

148
00:06:59,690 --> 00:07:02,580
我々は3を達成することができます
道路の道フォーク？

149
00:07:02,580 --> 00:07:04,980
>> 一方、我々がしたい場合は
それは間違いなく、C言語でそれを行います

150
00:07:04,980 --> 00:07:08,420
少なくとも少しsimpler--に見えます
あなたは構文に慣れる回。

151
00:07:08,420 --> 00:07:12,050
xがyよりも小さい場合、
printf関数xがyよりも小さいです。

152
00:07:12,050 --> 00:07:16,140
他xがyよりも大きい場合、
printfのxはyよりも大きいです。

153
00:07:16,140 --> 00:07:21,210
エルスのprintf xは-Y-に等しいと、
再び、これらのバックスラッシュでちょうど終わります

154
00:07:21,210 --> 00:07:24,160
これらの新しい行のため、もしので
実際にこの種のプログラムを実行しました

155
00:07:24,160 --> 00:07:25,940
それだけで移動します
カーソル最終的に

156
00:07:25,940 --> 00:07:28,100
画面の次の行に。

157
00:07:28,100 --> 00:07:31,270
>> さて、その間スクラッチは、他のを持っていました
唯一のより洗練された機能、

158
00:07:31,270 --> 00:07:34,320
そのうちのいくつかは我々がしようとしています
最初はCの世界に上に移動

159
00:07:34,320 --> 00:07:37,010
その一つでした
スクラッチ内のリストと呼ばれます。

160
00:07:37,010 --> 00:07:39,100
そして、これは特別なものでした
変数の型もの

161
00:07:39,100 --> 00:07:42,840
あなたは複数のものを保存することができ
戻ってそれで、背中合わせにするために、バックアップします。

162
00:07:42,840 --> 00:07:45,540
>> Cでは、それは持っていません
リスト、それ自体が、何か

163
00:07:45,540 --> 00:07:48,090
より一般的であること
我々はよものの、アレイと呼ばれます

164
00:07:48,090 --> 00:07:50,590
この後学期に戻ってきます
何かを見に

165
00:07:50,590 --> 00:07:52,780
リスト、または実際にリンクされたリストと呼ばれます。

166
00:07:52,780 --> 00:07:55,510
しかし今のところ、最も近いです
私たちのためにC言語で同等

167
00:07:55,510 --> 00:07:57,345
何かになるだろう
配列と呼ばれます。

168
00:07:57,345 --> 00:07:59,740
そして、配列は単純です
変数の特殊なタイプ

169
00:07:59,740 --> 00:08:03,160
それは、あなたがデータを保存することができます
バック、背中合わせにするために、バックアップします。

170
00:08:03,160 --> 00:08:05,840
>> そして、確かに、スクラッチで、
私たちは、アクセスしたい場合

171
00:08:05,840 --> 00:08:09,030
配列の最初の要素や
list--と私はそれを呼び出すつもりです、

172
00:08:09,030 --> 00:08:13,600
大会、ARGV、引数によって
ベクトルが、よりその上に長い前。

173
00:08:13,600 --> 00:08:17,090
私は最初の要素を取得したい場合
ARGVの、スクラッチの世界では

174
00:08:17,090 --> 00:08:20,930
あなたが実際に一般的に行います
1からカウントを開始します。

175
00:08:20,930 --> 00:08:22,850
>> そして私はARGVの項目1を得る可能性があります。

176
00:08:22,850 --> 00:08:26,310
それはMITの実装方法だけです
リストの概念。

177
00:08:26,310 --> 00:08:29,860
しかし、C言語で、私はするつもりです
もっと単純に言う、ARGV、

178
00:08:29,860 --> 00:08:32,758
私の名前、再びこれは
list--またはクリアされるように、配列。

179
00:08:32,758 --> 00:08:34,549
そして、私が最初にしたい場合
要素は、私が行きますよ

180
00:08:34,549 --> 00:08:37,890
あなた角括弧を使用するには
多くの場合、キーボードの下に使用されない場合があります。

181
00:08:37,890 --> 00:08:40,150
>> しかし、0がちょうどいい、私に最初に取得します。

182
00:08:40,150 --> 00:08:42,160
だから機会にとなど
時間が経過し、我々が行っています

183
00:08:42,160 --> 00:08:44,570
これらの二分法を見ることが開始します
スクラッチとCの間、

184
00:08:44,570 --> 00:08:46,070
これによりスクラッチは1を使用しています。

185
00:08:46,070 --> 00:08:47,670
C言語で私たちはここに0を使用します。

186
00:08:47,670 --> 00:08:49,420
しかし、あなたはすぐに表示されます
あなたが理解すれば

187
00:08:49,420 --> 00:08:52,920
その各言語の基礎、
これらの事はすべての多くを得るために開始します

188
00:08:52,920 --> 00:08:56,860
練習と実践を通しておなじみ。

189
00:08:56,860 --> 00:08:59,700
>> それでは、実際にプログラムを今すぐ見てみましょう。

190
00:08:59,700 --> 00:09:04,031
ここに私たちのCの最初のものでなければなりません
完全なプログラムのソースコード。

191
00:09:04,031 --> 00:09:06,280
そして、プログラムは、我々が行っています
検討のために提供します

192
00:09:06,280 --> 00:09:09,340
同等なものです
その先にスクラッチピースへ。

193
00:09:09,340 --> 00:09:13,210
>> だからここでは、我々は何を持っています
間違いなく最も簡単なCプログラム

194
00:09:13,210 --> 00:09:15,410
あなたはそれを書くことができます
実際に何かを行います。

195
00:09:15,410 --> 00:09:18,250
今、私たちは過去を見ていきます、
今のところ、含まれています、

196
00:09:18,250 --> 00:09:21,190
標準io.h、およびこれらの角度
ブラケット、およびint型、及びボイド、

197
00:09:21,190 --> 00:09:22,840
そして、中括弧、などが挙げられます。

198
00:09:22,840 --> 00:09:25,390
>> そして、ちょうどに集中しましょう
少なくとも直感的にどのような、

199
00:09:25,390 --> 00:09:26,860
すでにあなたに飛び出す可能性があります。

200
00:09:26,860 --> 00:09:30,300
実際には、主に、私はしないでください
必ずしもこれが何であるかを知っています、

201
00:09:30,300 --> 00:09:34,580
しかし、スクラッチなどの多くが持っていたときに
緑色のフラグがパズルのピースをクリックし、

202
00:09:34,580 --> 00:09:39,070
そのようにプログラミング言語としてCを行います
コー​​ドの主な部分を持っています

203
00:09:39,070 --> 00:09:43,380
デフォルトで実行されます。そして、確かに、
文字通り、メインと呼ばれるようになるだろう。

204
00:09:43,380 --> 00:09:44,720
>> そう主な機能です。

205
00:09:44,720 --> 00:09:48,720
そして、それは存在する特殊機能です
C言語でプログラムを実行するときに、

206
00:09:48,720 --> 00:09:52,720
それはによって実行されることを主です
デフォルト。スクラッチの世界では、

207
00:09:52,720 --> 00:09:56,970
それはときにグリーンフラッグ通常ました
デフォルトでは動作し得たことをクリックしました。

208
00:09:56,970 --> 00:10:01,130
>> 一方、我々は前にこれを見てきました、
printf関数または印刷フォーマットされ、それはです

209
00:10:01,130 --> 00:10:05,620
に付属している機能になるだろう
C、他人の全体の束と一緒に、

210
00:10:05,620 --> 00:10:10,140
時間と時間からその意志
再び、正確に行うために、

211
00:10:10,140 --> 00:10:12,450
その名の通り、何かを印刷します。

212
00:10:12,450 --> 00:10:13,500
私たちは、印刷したいですか？

213
00:10:13,500 --> 00:10:15,770
まあ、我々はそれを参照してくださいよ
囲み文字によって

214
00:10:15,770 --> 00:10:18,680
these--ハローワールドのような、
バックスラッシュnは二重引用符で、

215
00:10:18,680 --> 00:10:23,040
我々は正確にprintf関数を伝えることができます
画面上に何を印刷します。

216
00:10:23,040 --> 00:10:26,430
>> しかし、行うために、
つまり、我々は、残念ながら

217
00:10:26,430 --> 00:10:30,010
何かをする必要があります
私たち人間にはすでに謎めきました、

218
00:10:30,010 --> 00:10:34,510
しかし、少なくともそれはややreadable--です
シャープは、標準io.h、int型を含みます、

219
00:10:34,510 --> 00:10:39,340
メイン、ボイド、printfの、魔法のすべて
私たちはただ、画面で見た呪文。

220
00:10:39,340 --> 00:10:42,470
しかし、我々は実際に持っています
さらにより難解に行きます。

221
00:10:42,470 --> 00:10:47,140
私たちは、最初のコードを変換する必要があります
我々はマシンコードに記述すること。

222
00:10:47,140 --> 00:10:51,370
そして、先週からリコールマシンという、
少なくとも私たちがここで知っているもの、

223
00:10:51,370 --> 00:10:54,450
一日の終わりに
0と1を理解しています。

224
00:10:54,450 --> 00:10:58,100
>> そして、私の神、私たちはこれらを書かなければならなかった場合
実際にプログラムに0と1、

225
00:10:58,100 --> 00:11:01,260
それは非常に、非常に迅速だろう
何から楽しみを取ります。

226
00:11:01,260 --> 00:11:05,150
しかし、それは、最後の週、判明します
その0と1のこれらのパターン

227
00:11:05,150 --> 00:11:06,400
ただ特別な意味を持っています。

228
00:11:06,400 --> 00:11:08,500
特定の文脈においては、
彼らは数字を意味するかもしれません。

229
00:11:08,500 --> 00:11:11,840
>> いくつかの文脈では、彼らが意味するかもしれません
文字、または色、または任意の数

230
00:11:11,840 --> 00:11:14,710
そこの際に他の抽象化。

231
00:11:14,710 --> 00:11:18,450
しかし、コンピュータに搭載されているだけのように
CPU、中央処理装置、

232
00:11:18,450 --> 00:11:20,390
またはお使いのコンピュータの内部頭脳。

233
00:11:20,390 --> 00:11:22,240
これは通常、インテルの
それだから、内部

234
00:11:22,240 --> 00:11:24,900
最大の企業の1
それは、コンピュータ用のCPUを作ります。

235
00:11:24,900 --> 00:11:28,910
>> さて、IntelのCPUとその他
単に事前に決定しました

236
00:11:28,910 --> 00:11:33,970
そのゼロの特定のパターンと
ものは特定の事柄を意味するものとします。

237
00:11:33,970 --> 00:11:37,040
0と1の特定のパターン
、画面に印刷このことを意味します、

238
00:11:37,040 --> 00:11:39,710
またはこれら2つの数値を追加したり、
これら2つの数値を減算し、

239
00:11:39,710 --> 00:11:43,310
またはからのデータのこの部分を移動
こちらに私のコンピュータのメモリ、

240
00:11:43,310 --> 00:11:47,870
または他の非常に低レベルの任意の数の
しかし、最終的に有用な操作。

241
00:11:47,870 --> 00:11:53,022
しかし、ありがたいことに、私たち人間は進んでいません
このレベルの詳細を知る必要があります。

242
00:11:53,022 --> 00:11:56,230
確かに、ちょうど最後の時間のように、どこ
再び抽象化、そして再び、そして再び、

243
00:11:56,230 --> 00:11:58,930
非常に低いレベルから建物
0と1のようなプリミティブ

244
00:11:58,930 --> 00:12:01,160
より高いレベルの概念に
数字、文字など、

245
00:12:01,160 --> 00:12:04,330
そして、色、そしてより多くの、
私たちは、プログラマとして缶

246
00:12:04,330 --> 00:12:07,080
の肩の上に立ちます
私たちの前に来た他の人

247
00:12:07,080 --> 00:12:11,260
および他のそのソフトウェアを使用します
人々はus--前に書かれています

248
00:12:11,260 --> 00:12:14,340
すなわち、プログラムはコンパイラと呼ばれます。

249
00:12:14,340 --> 00:12:17,770
>> Cは、その言語であります
通常はコンパイルされ、

250
00:12:17,770 --> 00:12:22,130
から変換を意味しています
マシンコードのソースコード。

251
00:12:22,130 --> 00:12:25,230
特に、これが意味
あなたがソースを持っている場合ということです

252
00:12:25,230 --> 00:12:29,530
あなた自身がすぐに我々のように、記述するコード
画面上に一瞬であろう、

253
00:12:29,530 --> 00:12:33,140
そしてあなたはそれを変換したいです
最終的にマシンにcode--

254
00:12:33,140 --> 00:12:37,100
これらの0と1という
お使いのMacまたはお使いのPCのみ

255
00:12:37,100 --> 00:12:41,230
あなたが最初に持っていますunderstands--
以下のように、そのソースコードを供給する

256
00:12:41,230 --> 00:12:46,340
特別に入力します
プログラムは、コンパイラと呼ばれます、

257
00:12:46,340 --> 00:12:48,974
我々の出力
参照しなければならないマシンコードです。

258
00:12:48,974 --> 00:12:51,890
そして、確かに、最後の時間は、我々が話をしました
本当に、一日の終わりに、約、

259
00:12:51,890 --> 00:12:52,610
問題解決。

260
00:12:52,610 --> 00:12:53,360
あなたが入力を持っています。

261
00:12:53,360 --> 00:12:54,318
そして、あなたは出力を持っています。

262
00:12:54,318 --> 00:12:56,560
そして、あなたはいくつかの種類を持っています
真ん中のアルゴリズムの。

263
00:12:56,560 --> 00:12:59,830
>> アルゴリズムは、確実にすることができます
ソフトウェアで実装、

264
00:12:59,830 --> 00:13:02,900
我々は先週擬似コードで見たように
私たちは実際のコードで表示されますように

265
00:13:02,900 --> 00:13:03,490
今週。

266
00:13:03,490 --> 00:13:06,430
だからコンパイラ本当にただ
内部アルゴリズムのセットを持っています

267
00:13:06,430 --> 00:13:10,060
それをどのように知っています
特別なキーワードを変換し、

268
00:13:10,060 --> 00:13:12,180
メイン、およびprintfのような、
その他、我々だけ

269
00:13:12,180 --> 00:13:17,620
ゼロのパターンに見て、
ものの内部インテルと他のCPU

270
00:13:17,620 --> 00:13:20,020
実際に理解しています。

271
00:13:20,020 --> 00:13:22,460
だから我々はこれをどのように行うのですか？

272
00:13:22,460 --> 00:13:24,470
どこでコンパイラを得るのですか？

273
00:13:24,470 --> 00:13:26,400
>> ここで私たちのほとんどは、MacまたはPCを持っています。

274
00:13:26,400 --> 00:13:29,152
そして、あなたは、Mac OSを実行している、またはしています
Windows、またはLinux、またはSolaris、

275
00:13:29,152 --> 00:13:30,860
または他の任意の数
オペレーティングシステム。

276
00:13:30,860 --> 00:13:32,568
そして、確かに、我々は可能性
ウェブ上に出て行きます

277
00:13:32,568 --> 00:13:35,710
そして、コンパイラをダウンロード
お使いのMacまたはお使いのPCのための

278
00:13:35,710 --> 00:13:37,360
特定のオペレーティングシステム用の。

279
00:13:37,360 --> 00:13:39,617
しかし、我々はすべての上だろう
別のページ、いわば。

280
00:13:39,617 --> 00:13:41,450
私たちは少し必要があるだろう
異なる構成。

281
00:13:41,450 --> 00:13:43,210
そして、物事はすべて同じように動作しません。

282
00:13:43,210 --> 00:13:45,280
そして、確かに、これらの日
私たちの多くは使用しないでください

283
00:13:45,280 --> 00:13:47,516
唯一の私たちのラップトップ上で動作するソフトウェア。

284
00:13:47,516 --> 00:13:49,390
その代わりに、私たちは何かを使用します
そのブラウザのような

285
00:13:49,390 --> 00:13:52,930
私たちは、Webベースにアクセスすることを可能にします
クラウド内のアプリケーション。

286
00:13:52,930 --> 00:13:55,630
そして、この後学期、
私たちはまさにそれを行います。

287
00:13:55,630 --> 00:13:59,660
私たちは、アプリケーションを作成しますか
code--ないCを使用してソフトウェア、

288
00:13:59,660 --> 00:14:02,860
しかし、Pythonのような他の言語と
クラウドで実行JavaScript--。

289
00:14:02,860 --> 00:14:05,860
>> そして私たち自身、それをします
学期中

290
00:14:05,860 --> 00:14:11,890
実際にクラウドベースを使用します。
CS50 IDEとして知られている環境。

291
00:14:11,890 --> 00:14:16,030
これは、Webベースのプログラミングで
環境、または統合開発

292
00:14:16,030 --> 00:14:20,610
いくつかの上に構築されています環境、IDE、
クラウド9と呼ばれるオープンソースソフトウェア。

293
00:14:20,610 --> 00:14:22,966
そして、我々はいくつかの教育学を作りました
それへの単純化

294
00:14:22,966 --> 00:14:25,840
で特定の機能を非表示にするように、
我々が必要としない最初の数週間、

295
00:14:25,840 --> 00:14:27,770
することができますし、その後、
それらを明らかにし、ほとんどの操作を行います

296
00:14:27,770 --> 00:14:29,400
あなたは環境にしたいもの。

297
00:14:29,400 --> 00:14:32,470
>> そして、それはに、あまりにも、私たちを可能にします
特定のソフトウェアをプレインストールします。

298
00:14:32,470 --> 00:14:35,330
いわゆるCS50のようなもの
我々はすぐにわかりますライブラリ、

299
00:14:35,330 --> 00:14:39,210
いくつかとCで私たちを提供します
追加機能。

300
00:14:39,210 --> 00:14:44,392
だから、あなたが行く場合に、最終的には、CS50.io、
あなたはログインを求めるメッセージが表示されます、

301
00:14:44,392 --> 00:14:46,350
一度あなたが行うと作成します
無料のアカウント、

302
00:14:46,350 --> 00:14:52,150
あなたがアクセスできるようになります
非常にこのようになります環境。

303
00:14:52,150 --> 00:14:53,760
>> 今、これがデフォルトモードです。

304
00:14:53,760 --> 00:14:55,650
すべてがいいですし、
画面上に明るいです。

305
00:14:55,650 --> 00:14:57,941
私たちの多くは、習慣を持っています
だCS50ピースに取り組んで

306
00:14:57,941 --> 00:14:59,150
かなり夜遅くまで。

307
00:14:59,150 --> 00:15:02,400
だから、あなたのいくつかはに好むかもしれません
いわば、ナイトモードに変換します。

308
00:15:02,400 --> 00:15:05,550
>> しかし、最終的に、何をしています
CS50 IDE内で見に行きます

309
00:15:05,550 --> 00:15:08,340
三つの異なるareas--です
左の場所の面積

310
00:15:08,340 --> 00:15:12,604
あなたのファイルは、であることを行っています
クラウド、右上のエリア

311
00:15:12,604 --> 00:15:14,270
ここで、あなたのコードが編集可能になるだろう。

312
00:15:14,270 --> 00:15:16,650
あなたが開くことができるようになります
任意のプログラムのための個々のタブ

313
00:15:16,650 --> 00:15:19,670
あなたは内部のこの学期を書くこと
その右上隅の。

314
00:15:19,670 --> 00:15:23,070
そして最もarcanely、
まだ力強く、

315
00:15:23,070 --> 00:15:26,610
で、この事になるだろう
ターミナルウィンドウとして知られている一番下。

316
00:15:26,610 --> 00:15:29,450
>> これは、古い学校です
コマンドラインインタフェース、

317
00:15:29,450 --> 00:15:32,240
またはCLIは、それが可能に
あなたのコマンドを実行します

318
00:15:32,240 --> 00:15:35,260
この場合computer--に、
cloud--コンピュータ

319
00:15:35,260 --> 00:15:39,090
あなたのコードをコンパイルするようなことを行うには
ソースコードからマシンコードへ、

320
00:15:39,090 --> 00:15:43,600
あなたのプログラムを実行するために、またはあなたを開始します
Webサーバ、またはデータベースにアクセスするために、

321
00:15:43,600 --> 00:15:47,454
および他の技術の任意の数
私たちはずっと前から使用を開始するだろうと。

322
00:15:47,454 --> 00:15:49,370
しかし、そこに到達するために、我々はしています
実際に持っているつもり

323
00:15:49,370 --> 00:15:51,240
オンライン行くと再生を開始します。

324
00:15:51,240 --> 00:15:54,399
そして、それを行うには、最初にしてみましょう
メインいじり始めます、

325
00:15:54,399 --> 00:15:55,940
プログラムの主要部分を記述します。

326
00:15:55,940 --> 00:15:59,170
とのは、その機能を使ってみましょう
我々は以前に使用printf関数、

327
00:15:59,170 --> 00:16:01,050
単に何かを言うために。

328
00:16:01,050 --> 00:16:04,910
>> だからここに私はCS50 IDEの内部ですでにです。

329
00:16:04,910 --> 00:16:05,930
私は事前に記録されてきました。

330
00:16:05,930 --> 00:16:07,360
そして、私は完全なウィンドウをスクリーニングしました。

331
00:16:07,360 --> 00:16:09,670
だから、最終的に、あなた
あまりにも来る問題で

332
00:16:09,670 --> 00:16:12,960
その類似の手順に従います
オンラインドキュメントを提供します。

333
00:16:12,960 --> 00:16:16,360
だから、心配する必要はありません
どんな小さな技術的ステップを吸収

334
00:16:16,360 --> 00:16:17,730
今日はここで行うこと。

335
00:16:17,730 --> 00:16:19,222
>> しかし、あなたは、このような画面が得られます。

336
00:16:19,222 --> 00:16:20,430
私はナイトモードであることが起こります。

337
00:16:20,430 --> 00:16:22,944
そして、あなたはすべてを明るくすることができます
ナイトモードを無効にすることにより、アップ。

338
00:16:22,944 --> 00:16:24,860
との終わりに
日、次のように表示するつもりです

339
00:16:24,860 --> 00:16:30,090
ファイルareas--これらの三つの主要な
左側のブラウザ、トップアップコード、タブ、

340
00:16:30,090 --> 00:16:32,430
そして、下部のターミナルウィンドウ。

341
00:16:32,430 --> 00:16:34,890
>> 私は先に行ってみようと
私の最初のプログラムを書きます。

342
00:16:34,890 --> 00:16:42,300
私は、先制ファイルに行くつもりです
保存し、hello.cのように私のファイルを保存します。

343
00:16:42,300 --> 00:16:46,850
確かに、慣例により、任意のプログラムの我々
C言語で書かれている書き込み

344
00:16:46,850 --> 00:16:49,739
何かを命名する必要があります
慣例によりドットC、。

345
00:16:49,739 --> 00:16:53,030
だから私はので、それをhello.cの名前を付けるつもりです
私は世界に挨拶したいと思います。

346
00:16:53,030 --> 00:16:54,820
今、私はズームするつもりです
アウト、[保存]をクリックします。

347
00:16:54,820 --> 00:16:58,180
そして、私は今ここにあるすべてのタブです
ここで私は、コードを書き始めることができます。

348
00:16:58,180 --> 00:16:59,490
>> これは、コンパイルするつもりはありません。

349
00:16:59,490 --> 00:17:00,300
これは何を意味します。

350
00:17:00,300 --> 00:17:02,750
だから、私は変換した場合でも
この0と1に、

351
00:17:02,750 --> 00:17:05,390
CPUはありません持ってしようとしています
周りに何が起こっているのか考え。

352
00:17:05,390 --> 00:17:14,170
しかし、私は試合を行う行を記述する場合
Cのconventions-- Cのビーイングとアップ、

353
00:17:14,170 --> 00:17:20,150
再び、これは次のような構文でlanguage--
この、world--ハローのprintfとIました

354
00:17:20,150 --> 00:17:22,210
と快適得
時間をかけてこれを行います。

355
00:17:22,210 --> 00:17:24,510
だから私は、私が作ったとは思いません
任意のタイプミス。

356
00:17:24,510 --> 00:17:27,910
>> しかし、常に、非常に最初の
あなたがこれを行う時間は、必要になります。

357
00:17:27,910 --> 00:17:31,090
そして、何私は非常に威力を行うことについての思い
よくあなたのために初めて動作しません。

358
00:17:31,090 --> 00:17:33,610
そして、それは完全にOKですが、
今あなたのために

359
00:17:33,610 --> 00:17:37,662
ちょうど新しさの全体の多くが表示されることがあり、
しかし、時間をかけて、あなたは慣れたら

360
00:17:37,662 --> 00:17:39,870
この環境で、と
この言語、およびその他、

361
00:17:39,870 --> 00:17:42,370
あなたはその物事を見ることから始めましょう
正しいか、間違っています。

362
00:17:42,370 --> 00:17:44,369
>> そして、これは何ですか
指導員とコース

363
00:17:44,369 --> 00:17:48,780
アシスタントは、オーバー時にとても良いされ得ます
あなたのコード内のミスやバグをスポッティング。

364
00:17:48,780 --> 00:17:52,110
しかし、私はそれがあると主張します
このコードにはバグがありません。

365
00:17:52,110 --> 00:17:53,990
だから私は今、このプログラムを実行したいです。

366
00:17:53,990 --> 00:17:57,440
>> 今、自分のMacやPC上で、私がいますよ
ダブルクリックアイコンの習慣

367
00:17:57,440 --> 00:17:59,350
私はいくつかのプログラムを実行したいとき。

368
00:17:59,350 --> 00:18:01,080
しかし、それはこちらのモデルはありません。

369
00:18:01,080 --> 00:18:04,570
CS50 IDEです。この環境では。

370
00:18:04,570 --> 00:18:07,192
私たちは、動作を使用しています
Linuxのと呼ばれるシステム。

371
00:18:07,192 --> 00:18:09,900
Linuxは、別のを彷彿とさせます
オペレーティングシステムは、一般に知られています

372
00:18:09,900 --> 00:18:10,850
Unixのよう。

373
00:18:10,850 --> 00:18:16,340
およびLinuxは、特にために知られています
コマンドライン環境、CLIを持ちます。

374
00:18:16,340 --> 00:18:20,070
今、私たちは特定のを使用しています
リナックスの風味は、Ubuntuのと呼ばれます。

375
00:18:20,070 --> 00:18:22,770
そして、Ubuntuは単純です
Linuxの特定のバージョンの。

376
00:18:22,770 --> 00:18:27,900
>> しかし、これらのLinuxのこれらの日は、実際に行います
グラフィカルユーザインタフェースが付属しています。

377
00:18:27,900 --> 00:18:30,360
そして、我々が起こる1
ここで使用することは、Webベースです。

378
00:18:30,360 --> 00:18:32,735
だから、これはさえ見え​​るかもしれません
何かとは少し違います

379
00:18:32,735 --> 00:18:35,310
あなたは自分が持っているかもしれません
見たり、過去に実行します。

380
00:18:35,310 --> 00:18:37,910
>> だから私は先に行くつもりです
今と次の手順を実行します。

381
00:18:37,910 --> 00:18:40,950
私はのhello.cとしてこのファイルを保存しました。

382
00:18:40,950 --> 00:18:47,350
私は先に行くつもりだと
型clanghello.cだからクラン

383
00:18:47,350 --> 00:18:49,850
C言語のコンパイラです。

384
00:18:49,850 --> 00:18:51,952
これは、CS50 IDEにプリインストールされます。

385
00:18:51,952 --> 00:18:54,910
そして、あなたは絶対にダウンロードすることができ、
あなた自身のMacやPC上でこれをインストールします。

386
00:18:54,910 --> 00:18:57,910
>> しかし、再び、あなたはすべてを持っていません
事前設定が自動的に行わ。

387
00:18:57,910 --> 00:19:00,940
だから今のところ、私はちょうどよ
clanghello.cを実行するつもり。

388
00:19:00,940 --> 00:19:03,240
そして今、この構文に気付きます
ここでは最終的に

389
00:19:03,240 --> 00:19:06,930
ちょうど私がにいることを意味実現
ワークスペースと呼ばれるフォルダまたはディレクトリ。

390
00:19:06,930 --> 00:19:11,030
このドル記号は単なる慣習です
意味については、ここにあなたのコマンドを入力します。

391
00:19:11,030 --> 00:19:14,560
>> それはちょうど、プロンプトと呼ばれるものです
慣例により、ドル記号です。

392
00:19:14,560 --> 00:19:19,130
そして、私は今、先に行くと、クリックした場合
入力し、何が起こっていないようです。

393
00:19:19,130 --> 00:19:20,930
しかし、それは実際には良いことです。

394
00:19:20,930 --> 00:19:23,650
以下のことに起こります
画面、より多くの可能性が高いです

395
00:19:23,650 --> 00:19:26,710
あなたのコードが正しいとされ、
少なくとも構文的。

396
00:19:26,710 --> 00:19:29,120
>> だから私はこれを実行する場合
プログラム、私は何をしますか？

397
00:19:29,120 --> 00:19:33,770
まあ、それはことが判明
慣例により、デフォルトの名前

398
00:19:33,770 --> 00:19:38,854
プログラムのためにあなたが指定されていないとき
ちょうどa.outですあなたのプログラムのために名前を付けます。

399
00:19:38,854 --> 00:19:41,270
あまりにもこの構文と、あなたはよ
ずっと前に慣れます。

400
00:19:41,270 --> 00:19:47,500
>> ドットはただ、ちょっと、CS50を意味スラッシュ
IDE、a.outのと呼ばれるプログラムを実行します

401
00:19:47,500 --> 00:19:49,400
それは私の現在のディレクトリ内です。

402
00:19:49,400 --> 00:19:51,520
つまり、ドットはカレントディレクトリを意味します。

403
00:19:51,520 --> 00:19:55,040
そして、我々はどのような他のそのような配列が表示されます
文字のずっと前を意味します。

404
00:19:55,040 --> 00:19:58,430
>> そこでここでは、Hello Worldの、入力し、行きます。

405
00:19:58,430 --> 00:20:00,080
そして、あなたは何が起こっていること、わかりますか？

406
00:20:00,080 --> 00:20:01,580
だけでなく、それはHello Worldのを印刷しました。

407
00:20:01,580 --> 00:20:05,990
また、移動
次の行にカーソル。

408
00:20:05,990 --> 00:20:07,160
>> そして、なぜそれがでしたか？

409
00:20:07,160 --> 00:20:12,400
私たちは前に書いたコードは何でしたか
それは、カーソルがあろうことを保証しました

410
00:20:12,400 --> 00:20:14,882
次の行に行きますか？

411
00:20:14,882 --> 00:20:16,840
約面白いです
コンピュータはそれだけで起こっているのです

412
00:20:16,840 --> 00:20:18,570
あなたはそれが何を言うこと文字通り行います。

413
00:20:18,570 --> 00:20:26,050
>> ですから、ハローのprintfにそれを伝える場合、
カンマ、スペース、世界、近くの引用、

414
00:20:26,050 --> 00:20:29,090
それは文字通りだけで起こっています
これらの文字を印刷します。

415
00:20:29,090 --> 00:20:31,980
しかし、私はこの特殊文字を持っていました
終わりに、リコール、バックスラッシュn個。

416
00:20:31,980 --> 00:20:34,230
そして、それは確実に何
文字が行ったこと

417
00:20:34,230 --> 00:20:36,570
画面の次の行に。

418
00:20:36,570 --> 00:20:38,097
>> 実際には、私が行くと、これをやらせます。

419
00:20:38,097 --> 00:20:39,430
私が先に行くと、これを削除してみましょう。

420
00:20:39,430 --> 00:20:41,180
さて、ということに気づきます
私の画面の上部にあります

421
00:20:41,180 --> 00:20:42,890
小さな赤い光の中で
タブを示し、

422
00:20:42,890 --> 00:20:45,047
ねえ、あなたはあなたのファイルを保存していませんでした。

423
00:20:45,047 --> 00:20:47,880
だから私は、コントロールを進めるつもりです
SまたはコマンドS、ファイルを保存します。

424
00:20:47,880 --> 00:20:51,130
今ではmoment--緑のために行ってきましたgoes--。

425
00:20:51,130 --> 00:20:53,760
そして今、それはに戻ってです
ちょうど近くにアイコンです。

426
00:20:53,760 --> 00:21:01,860
>> 私は今、再びclanghello.cを実行すると、
、入力し、ドットスラッシュ、a.outの、入力してください

427
00:21:01,860 --> 00:21:04,110
あなたはそれがまだ働いていることがわかります。

428
00:21:04,110 --> 00:21:06,020
しかし、それは間違いなく少しバギーです。

429
00:21:06,020 --> 00:21:08,714
今、私のprompt--ワークスペース、
そして、そのドル記号、

430
00:21:08,714 --> 00:21:10,880
そしてその後、私の実際のprompt--
すべての同一線上にあります。

431
00:21:10,880 --> 00:21:14,540
だから、これは確か美的バグ、
場合でも、それは本当に論理的なバグではありません。

432
00:21:14,540 --> 00:21:16,250
>> だから、私はちょうど何をしたか元に戻すつもりです。

433
00:21:16,250 --> 00:21:18,560
私はa.outを再実行するつもりです。

434
00:21:18,560 --> 00:21:22,710
私が追加した注意してください
改行文字のバック。

435
00:21:22,710 --> 00:21:24,280
私は、ファイルを保存しました。

436
00:21:24,280 --> 00:21:31,630
>> だから私は、a.outの再実行するつもりですand--
くそ、バグ、ミスを意味するバグ。

437
00:21:31,630 --> 00:21:35,020
だから、バグがあってもかかわらずです
私は、nはそこにバックスラッシュを追加しました

438
00:21:35,020 --> 00:21:41,180
再保存し、プログラムを再実行し、
動作は同じでした。

439
00:21:41,180 --> 00:21:42,640
それはなぜでしょうか？

440
00:21:42,640 --> 00:21:43,910
>> 私は右のステップを、欠けていますか？

441
00:21:43,910 --> 00:21:47,620
以前そのキーのステップは、あなたが持っているということでした
あなたがソースコードを変更すると、to--

442
00:21:47,620 --> 00:21:49,610
それはまた、実行判明します
それコンパイラを通して

443
00:21:49,610 --> 00:21:51,102
再び、あなたは新しいマシンコードを取得します。

444
00:21:51,102 --> 00:21:52,810
マシンコード
0と1、

445
00:21:52,810 --> 00:21:56,260
、ほぼ同一であることを行っているが、
ない完全ので、私たちが必要とするため、

446
00:21:56,260 --> 00:21:57,510
もちろん、その新しいライン。

447
00:21:57,510 --> 00:22:02,640
>> だから、この問題を解決するために、私が必要とするつもりです
、入力し、ドットをclanghello.cを再実行します

448
00:22:02,640 --> 00:22:03,800
スラッシュ、a.outの。

449
00:22:03,800 --> 00:22:08,402
そして今、こんにちは世界が帰ってきました
私はそれがあることを期待した場所に。

450
00:22:08,402 --> 00:22:09,610
だから、これはすべての罰金と良いです。

451
00:22:09,610 --> 00:22:13,150
しかし、a.outがためにかなり愚かな名前です。
プログラム、それがあることを起こるにもかかわらず、

452
00:22:13,150 --> 00:22:16,530
歴史的な理由のために、
アセンブリ出力を意味default--。

453
00:22:16,530 --> 00:22:20,780
>> しかし、私はここに先に行かせ
そして、異なってこれを行います。

454
00:22:20,780 --> 00:22:24,760
私は私のハローワールドプログラムをしたいです
実際にハローと呼ばれていました。

455
00:22:24,760 --> 00:22:28,320
だから、私の上のアイコンだったら
デスクトップ、それはa.outということはないだろう。

456
00:22:28,320 --> 00:22:29,730
それは、ハローと呼ばれることになります。

457
00:22:29,730 --> 00:22:33,660
>> だから、これを行うには、それが判明します
クランこと、多くのプログラムのように、

458
00:22:33,660 --> 00:22:37,980
コマンドライン引数をサポートし、
またはフラグ、またはスイッチ、

459
00:22:37,980 --> 00:22:39,600
単にその動作に影響を与えています。

460
00:22:39,600 --> 00:22:45,160
具体的には、クランはダッシュOをサポートしています
その後、2番目の単語を取るフラグ、。

461
00:22:45,160 --> 00:22:48,190
この場合、私は任意よ、
しかし、合理的、こんにちはそれを呼び出します。

462
00:22:48,190 --> 00:22:50,710
しかし、私は何もそれを呼び出すことができます
私はa.outの、を除いて、対象となります

463
00:22:50,710 --> 00:22:52,390
むしろポイント以外になります。

464
00:22:52,390 --> 00:22:55,640
>> そして、名前だけを指定
ファイルの私がコンパイルしたいん。

465
00:22:55,640 --> 00:22:59,190
だから今でも、冒頭にかかわらず、
私はまだクランを持っているコマンドの、

466
00:22:59,190 --> 00:23:01,410
コマンドの最後に
私はまだ、ファイル名を持っています、

467
00:23:01,410 --> 00:23:05,520
私は今、これらのコマンドラインを持っています
引数、言っているこれらのフラグ、

468
00:23:05,520 --> 00:23:11,180
ああ、ところで、出力-O、ファイル
ないデフォルトのa.out、ハローと呼ばれます。

469
00:23:11,180 --> 00:23:13,810
>> だから私は、今、何も入力しないヒットした場合
起こっているようです。

470
00:23:13,810 --> 00:23:17,900
そして、まだ、今私はハロードットスラッシュを行うことができます。

471
00:23:17,900 --> 00:23:19,089
だから、同じプログラムです。

472
00:23:19,089 --> 00:23:21,380
0と1であります
一日の終わりに同一。

473
00:23:21,380 --> 00:23:24,210
>> しかし、彼らは2にしています
異なるfiles-- a.outの、

474
00:23:24,210 --> 00:23:26,490
これは最初のバージョンです
ちょうど愚かという名前の、

475
00:23:26,490 --> 00:23:30,250
そして今こんにちは、ずっとあります
プログラムのためのより魅力的な名前。

476
00:23:30,250 --> 00:23:33,195
しかし、正直なところ、私は決して午前
再びこれを覚えて行きます、

477
00:23:33,195 --> 00:23:34,070
そして再び、再び。

478
00:23:34,070 --> 00:23:36,411
そして、実際に、私たちが書いています
より複雑なプログラム、

479
00:23:36,411 --> 00:23:38,160
あなたがしているコマンド
書き込みしているつもり

480
00:23:38,160 --> 00:23:40,920
でも得ようとしています
まだまだ複雑。

481
00:23:40,920 --> 00:23:41,940
>> そして、そのように心配する必要はありません。

482
00:23:41,940 --> 00:23:46,220
それは人間の前にいることが判明します
私たちはあまりにも彼らを実現しています

483
00:23:46,220 --> 00:23:47,530
これと同じ問題を抱えていました。

484
00:23:47,530 --> 00:23:50,900
彼らはあまりにもを有する楽しみませんでした
かなり長い、難解なコマンドを入力し、

485
00:23:50,900 --> 00:23:52,200
おろか、それらを覚えています。

486
00:23:52,200 --> 00:23:56,070
そして、そのように私たちの前に人間が作りました
それを容易にする他のプログラム

487
00:23:56,070 --> 00:23:57,670
お使いのソフトウェアをコンパイルします。

488
00:23:57,670 --> 00:24:01,609
>> そして、確かに、そのような
プログラムはメイクと呼ばれています。

489
00:24:01,609 --> 00:24:03,150
だから私は先に行くと、これを実行するつもりです。

490
00:24:03,150 --> 00:24:05,691
私は、私はすべてを元に戻すつもりです
ただ、次のようにしました。

491
00:24:05,691 --> 00:24:07,690
私はLSを入力してみましょう。

492
00:24:07,690 --> 00:24:10,980
そして、あなたは3 things--に気付くでしょう
a.outの、星、ハロー

493
00:24:10,980 --> 00:24:12,810
星、とのhello.c。

494
00:24:12,810 --> 00:24:14,730
うまくいけば、これはすべき
少し直感的、

495
00:24:14,730 --> 00:24:18,220
以前に存在したものであれば
このワークスペースでは何もありません。

496
00:24:18,220 --> 00:24:21,240
私が持っていたものは何もありませんでした
私たちはクラスを始めるまで作成しました。

497
00:24:21,240 --> 00:24:22,840
>> そして、私はhello.cのを作成しました。

498
00:24:22,840 --> 00:24:24,544
私はそれをコンパイルし、それをするa.outと呼ばれます。

499
00:24:24,544 --> 00:24:27,460
そして、私は少しそれを再度コンパイル
異なるとハローそれを呼びました。

500
00:24:27,460 --> 00:24:32,830
だから私は、このディレクトリ内の3つのファイルを持っています、
このフォルダにワークスペースと呼ばれます。

501
00:24:32,830 --> 00:24:35,005
さて、私もそれを見ることができます
私は実際にズームアウトした場合。

502
00:24:35,005 --> 00:24:37,530
>> 私はここでズームアウトした場合と
その右上を見て

503
00:24:37,530 --> 00:24:39,940
コー​​ナー、約束どおり左
画面の左側

504
00:24:39,940 --> 00:24:42,990
いつもお見せしようとしています
何、あなたのアカウントに何

505
00:24:42,990 --> 00:24:44,790
CS50 IDEの内部。

506
00:24:44,790 --> 00:24:46,680
そして、そこに3つのファイルがあります。

507
00:24:46,680 --> 00:24:49,070
>> だから私はハローとするa.outを取り除きたいです。

508
00:24:49,070 --> 00:24:51,275
そして、あなたがかもしれないとして、
、直感的にあなたを想像します

509
00:24:51,275 --> 00:24:53,400
制御クリックで並べ替えることができ
または右これをクリック。

510
00:24:53,400 --> 00:24:54,590
そして、この小さなメニューがポップアップ表示されます。

511
00:24:54,590 --> 00:24:57,170
あなたがファイルをダウンロードすることができ、実行
それは、それをプレビューし、リフレッシュし、名前の変更、

512
00:24:57,170 --> 00:24:57,700
またはものではありません。

513
00:24:57,700 --> 00:25:00,260
>> そして私はちょうど削除することができ、
それは離れて行くだろう。

514
00:25:00,260 --> 00:25:05,260
しかし、ここでは、コマンドで物事をやらせます
今のライン、快適な取得するように、

515
00:25:05,260 --> 00:25:07,010
これで、そして次の手順を実行します。

516
00:25:07,010 --> 00:25:12,345
私は先に行くと、削除するつもりです
文字通りrma.out入力して、a.outという。

517
00:25:12,345 --> 00:25:14,890
これは、ためのコマンドが判明します
取り外したり、何かを削除します、

518
00:25:14,890 --> 00:25:16,280
削除するか、削除されていません。

519
00:25:16,280 --> 00:25:21,260
>> それはちょうど節約するために、より簡潔RMです
もしいくつかのキーストローク、およびEnt​​erキーを押します。

520
00:25:21,260 --> 00:25:24,707
今、私たちは多少あることになるだろう
ひそか正規のファイルa.outを削除します。

521
00:25:24,707 --> 00:25:27,040
私は本当にわかりません
不規則なファイルはまだだろう。

522
00:25:27,040 --> 00:25:28,660
しかし私はそれを削除したいです。

523
00:25:28,660 --> 00:25:30,150
>> だから私はイエスを表すyを入力するつもりです。

524
00:25:30,150 --> 00:25:31,940
または私はそれを入力し、Enterキーを押しことができます。

525
00:25:31,940 --> 00:25:33,440
そして、再び、何も起きていないようにみえます。

526
00:25:33,440 --> 00:25:35,840
しかし、それは、一般的に、良いことです。

527
00:25:35,840 --> 00:25:40,490
>> 私はこの時間LSを入力した場合、
私は何を参照する必要がありますか？

528
00:25:40,490 --> 00:25:44,930
うまくいけば、単にこんにちはとのhello.c。

529
00:25:44,930 --> 00:25:47,286
さて、余談、あなたとわかるように
この星、アスタリスクに気づきます、

530
00:25:47,286 --> 00:25:48,660
それは私のプログラムの終了時です。

531
00:25:48,660 --> 00:25:50,201
そして、彼らはまた、緑色に見せています。

532
00:25:50,201 --> 00:25:53,970
それはちょうどCS50 IDEの方法です
実際にあなたをcluingの

533
00:25:53,970 --> 00:25:55,280
ことそれはソースコードではありません。

534
00:25:55,280 --> 00:25:58,880
つまり、実行可能な実行可能です
あなたが実際に実行することができますプログラム

535
00:25:58,880 --> 00:26:01,020
ドットの操作を実行してスラッシュ、そしてそれが名前です。

536
00:26:01,020 --> 00:26:05,860
>> 今、私は先に行くと、削除しましょう
この、こんにちはRM、入力して、定期的に削除します

537
00:26:05,860 --> 00:26:08,010
はい、こんにちはファイル。

538
00:26:08,010 --> 00:26:11,180
そして今、私はLSを入力した場合、
我々は戻ってのhello.cにしています。

539
00:26:11,180 --> 00:26:13,917
あなたを削除しないようにしてください
実際のソースコード。

540
00:26:13,917 --> 00:26:16,250
特徴があるにもかかわらず
ここで、CS50 IDEに組み込まれて

541
00:26:16,250 --> 00:26:19,870
あなたの改訂履歴を介して行くことができます
そして、誤ってあれば、時間に巻き戻し

542
00:26:19,870 --> 00:26:23,660
何かを削除し、注意してください
これらのプロンプトyesまたはnoあたりなど、

543
00:26:23,660 --> 00:26:25,381
あなたが実際に何をしたいの。

544
00:26:25,381 --> 00:26:27,380
そして、私はトップに上がる場合
ここの隅を残し、

545
00:26:27,380 --> 00:26:30,696
hello.cは、すべてのことが残っています。

546
00:26:30,696 --> 00:26:32,570
だからの房があります
そのあなたの他のコマンド

547
00:26:32,570 --> 00:26:37,550
Linuxの世界で実行することができ、
あるのは、再び、メイク。

548
00:26:37,550 --> 00:26:40,180
そして、私たちはするつもりです
私のプログラムは、現在は以下の通り。

549
00:26:40,180 --> 00:26:43,270
>> 代わりに打ち鳴らすを行うための、
代わりにクラング-Oを行うための、

550
00:26:43,270 --> 00:26:45,860
私は単純に行きますよ
文字通り入力し、ハロー作ります。

551
00:26:45,860 --> 00:26:49,630
そして今、私は、気付きます
hello.cを作る入力していません。

552
00:26:49,630 --> 00:26:50,910
私はハローをmakeと入力しています。

553
00:26:50,910 --> 00:26:54,840
>> そして、このプログラムは、ことを確認してください
CS50 IDEが付属しており、より多くの

554
00:26:54,840 --> 00:26:57,090
一般的にLinuxで、
なプログラムです

555
00:26:57,090 --> 00:26:59,120
ハローと呼ばれるプログラムを作るつもり。

556
00:26:59,120 --> 00:27:03,680
そして、慣例により、前提となるだろう
このプログラムを行うことができる場合に、

557
00:27:03,680 --> 00:27:09,030
ソースから作ることになるだろう
ドット（c）に終わるコードファイル、hello.cで。

558
00:27:09,030 --> 00:27:12,210
>> だから私は今入力してヒットした場合、通知はその
実行されますコマンド

559
00:27:12,210 --> 00:27:14,340
さらに長い実際にあります
以前よりも前。

560
00:27:14,340 --> 00:27:16,670
私たちがきたので、それはです
持っている事前設定されたCS50 IDE

561
00:27:16,670 --> 00:27:19,878
その中に組み込まれていくつかの追加機能
我々はまだ必要があるが、すぐに意志はありません。

562
00:27:19,878 --> 00:27:23,470
しかし、重要なのは、実現するために、
私はハロープログラムを持っている今です。

563
00:27:23,470 --> 00:27:27,080
>> 私は再びLSを入力した場合、I
ハロープログラムを持っています。

564
00:27:27,080 --> 00:27:32,070
そして、私はそれを実行することができます
ドットスラッシュa.outの、いや、

565
00:27:32,070 --> 00:27:35,590
このの全体のポイントので、
演習では、ドットスラッシュこんにちはでした。

566
00:27:35,590 --> 00:27:38,089
そして今、私は私のハローワールドプログラムを持っています。

567
00:27:38,089 --> 00:27:39,880
だから前進し、
私たちは、ほとんど常にしています

568
00:27:39,880 --> 00:27:42,088
私たちのプログラムをコンパイルしようとして
コマンドメイクを使用。

569
00:27:42,088 --> 00:27:45,300
そして、我々は、それらを実行するつもりです
ドットスラッシュ、およびプログラムの名前。

570
00:27:45,300 --> 00:27:49,610
しかし、のために何をしているかメイクを実現
もし、それがコンパイラ自体ではないです。

571
00:27:49,610 --> 00:27:53,310
それだけで便利なプログラムです
それは、コンパイラをトリガする方法を知っています

572
00:27:53,310 --> 00:27:56,470
あなた自身がそれを使用できるように実行します。

573
00:27:56,470 --> 00:28:00,220
>> で、他にどのようなコマンドが存在します
Linux、および順番にCS50 IDE？

574
00:28:00,220 --> 00:28:03,107
我々はすぐそこだことがわかります
CDコマンド、ディレクトリ変更。

575
00:28:03,107 --> 00:28:05,190
これが内ことができます
あなたのコマンドラインインタフェース

576
00:28:05,190 --> 00:28:07,610
フォワード、バック移動し、
そして、別のフォルダを開きます

577
00:28:07,610 --> 00:28:08,860
あなたのマウスを使用せず。

578
00:28:08,860 --> 00:28:12,470
>> リストの略で、私たちが見たLS、
現在のディレクトリ内のファイル。

579
00:28:12,470 --> 00:28:14,650
ディレクトリを作成し、次のことができます
おそらく推測するために開始

580
00:28:14,650 --> 00:28:18,150
これらのディレクトリを作るnow--何を意味しますか、
あなたは、フォルダを作成したい場合。

581
00:28:18,150 --> 00:28:21,270
削除のためのRM、RMディレクトリ用
、directory--を削除し、これらの

582
00:28:21,270 --> 00:28:24,160
再び、コマンドラインであります
何の当

583
00:28:24,160 --> 00:28:26,945
マウスでCS50 IDEで行うことができます。

584
00:28:26,945 --> 00:28:28,820
しかし、あなたはすぐに見つけることができます
その時々それだけです

585
00:28:28,820 --> 00:28:30,610
やるべきことがたくさん速いです
キーボードとの事、

586
00:28:30,610 --> 00:28:33,690
そして最終的に、より多くの強力な。

587
00:28:33,690 --> 00:28:36,440
>> しかし、それは、と主張するのは難しいです
我々はこれまでに行ってきたもの

588
00:28:36,440 --> 00:28:39,990
ときにすべてのすべてのことは、強力です
我々はこんにちは、世界を言ってきました。

589
00:28:39,990 --> 00:28:43,740
そして、実際に、私はハードコード
私のプログラムへのHello Worldの言葉。

590
00:28:43,740 --> 00:28:45,530
まだダイナミズムはありません。

591
00:28:45,530 --> 00:28:49,320
スクラッチは、大きさの順でした
もっと面白い先週。

592
00:28:49,320 --> 00:28:51,220
>> それで者が取得してみましょう。

593
00:28:51,220 --> 00:28:55,310
のは、そのことによって一歩を見てみましょう
これらの機能のいくつかの方法。

594
00:28:55,310 --> 00:28:59,470
だからだけでなく、Cは、printfのが付属していません
他の機能のと房

595
00:28:59,470 --> 00:29:01,850
そのうちのいくつかは我々が表示されます
時間をかけて、それはしていません

596
00:29:01,850 --> 00:29:05,760
右のアウトすべてのことが簡単にそれを作ります
ユーザー入力を取得中にゲートの。

597
00:29:05,760 --> 00:29:08,140
>> 弱点の事実、1
Cのような言語の、

598
00:29:08,140 --> 00:29:10,140
まだ、さらにはJavaと
他の人、そうでないということです

599
00:29:10,140 --> 00:29:15,860
ちょうどのようなものを取得することが容易に
ユーザーからの整数、または文字列、単語、

600
00:29:15,860 --> 00:29:19,970
やフレーズ、などだけでは物事を聞かせて
ポイント値、または実数浮動

601
00:29:19,970 --> 00:29:23,240
本当に小数点、および付き
我々はすぐにわかるように長い数字、。

602
00:29:23,240 --> 00:29:27,000
そこでここでは関数のこのリストは、これらの
他のスクラッチパズルのピースのようなものです

603
00:29:27,000 --> 00:29:31,090
私たちは、CS50にプリインストールされていること
我々は数週間のために使用しますIDE

604
00:29:31,090 --> 00:29:34,010
各種の補助輪のように、と
最終的にはそれらを脱いで、と見て

605
00:29:34,010 --> 00:29:37,210
フード、おそらく、で下に
これらの事をどのように実装されています。

606
00:29:37,210 --> 00:29:40,460
>> しかし、これを行うには、してみましょう
実際にプログラムを書きます。

607
00:29:40,460 --> 00:29:41,770
私は今、先に行ってみましょう。

608
00:29:41,770 --> 00:29:44,750
そして、私は新しいを作成するつもりです
この小さなプラスをクリックしてファイルを、

609
00:29:44,750 --> 00:29:45,970
新しいファイルをクリックしてください。

610
00:29:45,970 --> 00:29:49,250
>> 私はこの次を保存するつもりです
string.c、の言わせ、として1、

611
00:29:49,250 --> 00:29:50,750
私は文字列でプレーしたいので。

612
00:29:50,750 --> 00:29:53,990
そして、Cの文字列だけです
文字のシーケンス。

613
00:29:53,990 --> 00:29:56,090
それでは先に進みましょう
そして次の操作を行います。

614
00:29:56,090 --> 00:30:01,204
>> 標準IO.h--を含めると、
それは、標準IOが判明します

615
00:30:01,204 --> 00:30:03,360
IOだけ入出力を意味します。

616
00:30:03,360 --> 00:30:05,920
だから、ことが判明します
ここでは、この行は何ですか

617
00:30:05,920 --> 00:30:08,140
printfのを使用するために私達に隣接されています。

618
00:30:08,140 --> 00:30:10,410
printf関数は、もちろん、出力を生成します。

619
00:30:10,410 --> 00:30:15,000
そうprintf関数を使用するためには、オン
あなたは、このコード行を持っている必要が出

620
00:30:15,000 --> 00:30:16,040
あなたのファイルの先頭に。

621
00:30:16,040 --> 00:30:18,456
>> そして、我々はに戻ってくるもの
それは本当に長い前を意味します。

622
00:30:18,456 --> 00:30:20,400
それはでていることが判明します
私が書く任意のCプログラム、

623
00:30:20,400 --> 00:30:23,640
私はそれを開始するんです
このようなコード。

624
00:30:23,640 --> 00:30:26,860
そして、あなたはCS50 IDEに気づくと、よ
他の統合開発

625
00:30:26,860 --> 00:30:30,050
それのような環境では、
最善しようとしています

626
00:30:30,050 --> 00:30:31,780
彼らはあなたの思考を終了することができます。

627
00:30:31,780 --> 00:30:35,930
実際には、先ほど私は元に戻す場合
私は何をしたか、私はEnterキーを押します。

628
00:30:35,930 --> 00:30:39,160
>> 私は、オープンカーリーを打ちます
ブレース、もう一度Enterキーを押します。

629
00:30:39,160 --> 00:30:40,430
そして、それは私の考えを終えました。

630
00:30:40,430 --> 00:30:45,140
それは私にインデント劣らず、新しい行を与えました
素敵な文体の理由のために我々が表示されます。

631
00:30:45,140 --> 00:30:48,559
そして、それは自動的に私を与えました
その中カッコは私の思考を終了します。

632
00:30:48,559 --> 00:30:50,600
今、それは常にありません
あなたが何をしたいかと思います。

633
00:30:50,600 --> 00:30:53,620
しかし、大部分は、それはありません
あなたにいくつかのキーストロークを保存します。

634
00:30:53,620 --> 00:30:59,560
だから一瞬前、我々はこのprogram--を走りました
こんにちは、世界、それをコンパイルし、

635
00:30:59,560 --> 00:31:00,460
し、それを実行しました。

636
00:31:00,460 --> 00:31:01,867
しかし、ここで何のダイナミズムはありません。

637
00:31:01,867 --> 00:31:03,700
我々が望んでいた場合はどう
別の何かをしますか？

638
00:31:03,700 --> 00:31:07,630
まあ、私は実際に何を望んでいた場合
ユーザーから文字列を取得しますか？

639
00:31:07,630 --> 00:31:11,250
私は、パズルのピースを使用するつもりです
正確に文字列を取得しthat--と呼ばれます。

640
00:31:11,250 --> 00:31:15,860
>> Cで判明したくないときに
パズルピースへの入力を提供するために、

641
00:31:15,860 --> 00:31:19,360
またはより適切に機能するには、
文字通り、開き括弧を行います

642
00:31:19,360 --> 00:31:20,430
閉じ括弧。

643
00:31:20,430 --> 00:31:25,540
ありますかのようだからです
入力する白い箱はありません。

644
00:31:25,540 --> 00:31:27,720
前の発言ブロック
小さな白いボックスを持っていました。

645
00:31:27,720 --> 00:31:29,660
私たちは今、その白いボックスを持っていません。

646
00:31:29,660 --> 00:31:33,310
>> しかし、私は、get文字列を呼び出し、I
どこかの結果を載せていきたいと思います。

647
00:31:33,310 --> 00:31:37,680
だからCで非常に一般的なパラダイムはにあります
ここに来る文字列のような関数を呼び出し、

648
00:31:37,680 --> 00:31:41,070
そして、その戻り値を格納します。

649
00:31:41,070 --> 00:31:44,450
それは、その結果です
何かで努力。

650
00:31:44,450 --> 00:31:47,630
>> そして、何です
プログラミングで構築し、

651
00:31:47,630 --> 00:31:53,450
C今スクラッチまたはかどうか、私たちはその
実際に何かを格納するために使用することができますか？

652
00:31:53,450 --> 00:31:55,990
それは右、変数と呼ばれますか？

653
00:31:55,990 --> 00:32:00,320
そしてスクラッチで、私たちは本当にしないでください
変数に何が起こっていたか気になります。

654
00:32:00,320 --> 00:32:02,170
>> しかし、このケースでは、我々は実際に行います。

655
00:32:02,170 --> 00:32:03,719
私は、文字列を言うつもりです。

656
00:32:03,719 --> 00:32:05,510
そして私は呼び出すことができます
この私が欲しいもの。

657
00:32:05,510 --> 00:32:08,340
私はそれを呼び出すつもりです
名前は、文字列を取得します。

658
00:32:08,340 --> 00:32:10,250
>> そして今、あなたがしている場合でも、
これに少し新しいです、

659
00:32:10,250 --> 00:32:11,984
私はいくつかの詳細を欠いていることに気づきます。

660
00:32:11,984 --> 00:32:13,150
私はセミコロンを忘れています。

661
00:32:13,150 --> 00:32:14,400
私はこの考えを完了する必要があります。

662
00:32:14,400 --> 00:32:17,480
だから私は、私のカーソルを移動するつもりです
そしてそこにセミコロンを打ちました。

663
00:32:17,480 --> 00:32:19,130
そして私はちょうど何をしましたか？

664
00:32:19,130 --> 00:32:21,440
このコード行では、
現時点では数5、

665
00:32:21,440 --> 00:32:23,799
ノー入力してget文字列を呼んでいます。

666
00:32:23,799 --> 00:32:26,090
だから、何の小さな白いはありません
保存ブロックが持っているようボックス。

667
00:32:26,090 --> 00:32:28,590
>> 私は、ちょっと、言っています
コンピュータは、私の文字列を取得します。

668
00:32:28,590 --> 00:32:31,390
等号は本当にありません
等号は、それ自体が。

669
00:32:31,390 --> 00:32:33,790
それは割り当てです
オペレータ手段、

670
00:32:33,790 --> 00:32:37,860
ちょっと、コンピュータ、値を移動
左の上右から。

671
00:32:37,860 --> 00:32:40,480
そして左に、私は次のように持っています。

672
00:32:40,480 --> 00:32:43,580
>> ねえ、コンピュータ、私にstring--を与えます
文字のシーケンス。

673
00:32:43,580 --> 00:32:45,637
その文字列の名前を呼びます。

674
00:32:45,637 --> 00:32:47,220
そして、私も名前、それを呼び出す必要はありません。

675
00:32:47,220 --> 00:32:49,970
>> 私は従来から、それを呼び出すことができ、
Sのようなもの、

676
00:32:49,970 --> 00:32:52,900
私たちは、私が使用するのと同じよう
私は、変数を呼び出します。

677
00:32:52,900 --> 00:32:54,829
しかし、今、私はそれで何かをする必要があります。

678
00:32:54,829 --> 00:32:57,370
〜するのはかなり愚かなことだろう
実行中、このコードをコンパイルしてみてください

679
00:32:57,370 --> 00:32:59,410
このプログラム、たとえ
私は、文字列を取得しています、

680
00:32:59,410 --> 00:33:01,580
それだけではまだですので、
こんにちは、世界を言うつもり。

681
00:33:01,580 --> 00:33:06,140
>> しかし、私はこれを変更するには何をしたいならば。

682
00:33:06,140 --> 00:33:07,940
なぜ私はこれをしませんか？

683
00:33:07,940 --> 00:33:11,632
パーセントの、コンマ秒。

684
00:33:11,632 --> 00:33:13,090
そして、これはまだ少し不可解です。

685
00:33:13,090 --> 00:33:15,560
>> だから私は、私の変数をより明確にしましょう​​。

686
00:33:15,560 --> 00:33:17,510
私はこの変数名に名前を付けましょう。

687
00:33:17,510 --> 00:33:20,230
そして、我々はいじめることができない場合を見てみましょう
ここで何が起こっているか離れて。

688
00:33:20,230 --> 00:33:22,770
>> だからライン5に、私は文字列を取得しています。

689
00:33:22,770 --> 00:33:25,620
そして、私はその文字列を格納しています、
ユーザーがで入力したものは何でも

690
00:33:25,620 --> 00:33:28,430
彼または彼女のキーボードでは、
名前と呼ばれる変数インチ

691
00:33:28,430 --> 00:33:30,590
そして、それはことが判明します
printf関数だけではなくありません

692
00:33:30,590 --> 00:33:34,220
二重に一つの引数を取ります
引用符、二重引用符内の1つの入力。

693
00:33:34,220 --> 00:33:39,100
>> それは、2つ、または3つ、またはそれ以上を取ることができます
、第2、または第3の、または第4のこと

694
00:33:39,100 --> 00:33:42,320
変数のすべての名前であり、
または具体的には、値

695
00:33:42,320 --> 00:33:48,610
あなたがにプラグインすることを、
動的に、引用符でその文字列。

696
00:33:48,610 --> 00:33:52,110
言い換えれば、どのような
これで間違っているでしょうか？

697
00:33:52,110 --> 00:33:57,920
私は言った場合こんにちは名、バックスラッシュ
nは、私のコードをコンパイルし、私のファイルを保存しました

698
00:33:57,920 --> 00:34:01,660
この走り、何が起こるのでしょうか？

699
00:34:01,660 --> 00:34:05,139
>> ちょうどこんにちは、言おうとしています
名前、文字通りN-A-M-E、

700
00:34:05,139 --> 00:34:07,900
どの種類の愚かな理由であります
それは世界と何ら変わりません。

701
00:34:07,900 --> 00:34:10,400
だから、引用符で囲まれたものであり、
何文字通り印刷されます。

702
00:34:10,400 --> 00:34:12,520
だから私は持っているしたい場合
そこにプレースホルダ、

703
00:34:12,520 --> 00:34:14,422
私は実際に使用する必要があります
いくつかの特別な構文。

704
00:34:14,422 --> 00:34:17,380
あなたが読めば、それが判明します
printf関数のドキュメント、

705
00:34:17,380 --> 00:34:21,320
それがいることを教えてくれます
あなたは、パーセント秒を使用している場合、

706
00:34:21,320 --> 00:34:23,920
次のように値を代入することができます。

707
00:34:23,920 --> 00:34:27,190
>> その後のコンマの後に
二重引用符、単にあなた

708
00:34:27,190 --> 00:34:29,179
の名前を書きます
あなたがしたい変数

709
00:34:29,179 --> 00:34:33,790
その形式にプラグインします
コー​​ド、または書式指定子、

710
00:34:33,790 --> 00:34:35,469
パーセントの文字列の。

711
00:34:35,469 --> 00:34:39,190
そして今、私は私のファイルを保存した場合、
私は自分の端末にダウンして戻ってください。

712
00:34:39,190 --> 00:34:42,870
そして、私は文字列を作成し入力し、
再び、ため、この名

713
00:34:42,870 --> 00:34:45,510
私は前に選択したファイルがstring.cです。

714
00:34:45,510 --> 00:34:48,510
>> だから私は、文字列は、入力してくださいと言うつもりです。

715
00:34:48,510 --> 00:34:51,550
善良私のああ、のすべてを見て
ミス我々はすでに行われてきました。

716
00:34:51,550 --> 00:34:55,540
そして、これはこれは本当に何ですか、is--
6、7行のプログラムのような？

717
00:34:55,540 --> 00:34:57,790
ここで、それは非常にすることができますので、これはです
すぐに圧倒的な取得。

718
00:34:57,790 --> 00:35:00,890
>> このターミナルウィンドウが持っています
今だけの逆流

719
00:35:00,890 --> 00:35:03,230
エラーメッセージの膨大な数。

720
00:35:03,230 --> 00:35:07,560
確かに、私はより多くのエラーを持っていません
私はコードの行を持っているよりもメッセージ。

721
00:35:07,560 --> 00:35:08,680
だから何が起こっているの？

722
00:35:08,680 --> 00:35:10,920
>> まあ、最善の戦略
あなたはいつでも行うには

723
00:35:10,920 --> 00:35:13,710
圧倒的に遭遇ん
そのようなエラーのリスト、

724
00:35:13,710 --> 00:35:16,690
バックスクロールされ、コマンドを探します
あなただけの私の場合には、実行しました

725
00:35:16,690 --> 00:35:18,020
文字列を作るです。

726
00:35:18,020 --> 00:35:21,630
何をしたかのメイクを見て、それはそれです
長いクランコマンド、そこに大したことありません。

727
00:35:21,630 --> 00:35:22,950
>> しかし、赤が悪いです。

728
00:35:22,950 --> 00:35:24,750
緑があることしようとしています
穏やかで親切。

729
00:35:24,750 --> 00:35:26,140
しかし、それはこの場合には、まだ悪いです。

730
00:35:26,140 --> 00:35:27,510
しかし、ここでそれは悪いのですか？

731
00:35:27,510 --> 00:35:31,450
>> String.c、ライン5、文字5。

732
00:35:31,450 --> 00:35:32,930
だから、これは単に一般的な慣例です。

733
00:35:32,930 --> 00:35:36,060
何かコロン何か手段
行番号や文字番号。

734
00:35:36,060 --> 00:35:41,080
エラー、未宣言の使用
識別子の文字列。

735
00:35:41,080 --> 00:35:42,900
あなたは、標準的なことですか？

736
00:35:42,900 --> 00:35:45,530
>> だから、残念ながら、クラン
参考にしようとしています。

737
00:35:45,530 --> 00:35:46,850
しかし、それはこの場合には、間違っています。

738
00:35:46,850 --> 00:35:49,350
いいえ、クランは、私は標準的なIOを意味するものではありませんでした。

739
00:35:49,350 --> 00:35:51,070
私ははい、行1であることを意味しました。

740
00:35:51,070 --> 00:35:53,420
>> しかし、ライン5は、ここではこの1です。

741
00:35:53,420 --> 00:35:57,040
そして、クランはしていません
S-T-R-I-N-Gを理解しています。

742
00:35:57,040 --> 00:36:01,490
これは未宣言の識別子、Aの
それだけで前に見たことのない言葉。

743
00:36:01,490 --> 00:36:05,730
そして、それは、Cのため、言語です
我々は、今でコードを書いています

744
00:36:05,730 --> 00:36:08,070
文字列と呼ばれる変数を持っていません。

745
00:36:08,070 --> 00:36:11,380
>> これはサポート、デフォルトでは、しません
文字列と呼ばれるもの。

746
00:36:11,380 --> 00:36:16,750
それはのCS50作品です
専門用語が、非常に従来の。

747
00:36:16,750 --> 00:36:18,600
次のようにしかし、私はこの問題を解決することができます。

748
00:36:18,600 --> 00:36:22,090
>> 私は、コードの1行を追加した場合
このプログラムの先頭に、

749
00:36:22,090 --> 00:36:27,890
別のファイルであるCS50.hを含み、
どこかCS50 IDE、どこかの内部

750
00:36:27,890 --> 00:36:30,820
ハードドライブ上に、いわば、
Ubuntuのオペレーティングシステムの

751
00:36:30,820 --> 00:36:33,590
私が実行していることを、その
だファイルがあります

752
00:36:33,590 --> 00:36:38,740
操作を教えるつもり
文字列が何であるかをシステム、ちょうど

753
00:36:38,740 --> 00:36:41,930
標準io.hのようなファイルです。
オペレーティングシステムで

754
00:36:41,930 --> 00:36:44,430
何であるかのprintfそれを教えるつもり。

755
00:36:44,430 --> 00:36:46,810
>> 実際、我々が得ているだろう
非常に同様のメッセージ

756
00:36:46,810 --> 00:36:50,600
IOは標準を認めていた場合
IO.hはとのprintfを使用しようとしました。

757
00:36:50,600 --> 00:36:53,632
だから私は先に、ちょうど行くつもりです
私の画面をクリアするには、コントロールLを取ります。

758
00:36:53,632 --> 00:36:56,340
それとも、明確な入力することができますし、それはなります
ただ、ターミナルウィンドウをクリアします。

759
00:36:56,340 --> 00:36:58,020
しかし、あなたはまだ時間に戻ってスクロールすることができます。

760
00:36:58,020 --> 00:37:01,100
>> そして、私は文字列を作成し再実行するつもりです。

761
00:37:01,100 --> 00:37:03,660
この時に私の指を渡り、入力します。

762
00:37:03,660 --> 00:37:05,380
私の神ああ、それが働きました。

763
00:37:05,380 --> 00:37:09,280
それは私に長い不可解なコマンドを示しています
それは、どのようなクランを経由して生成されたことを確認しています

764
00:37:09,280 --> 00:37:10,460
しかし、エラーメッセージなし。

765
00:37:10,460 --> 00:37:12,460
だからにもかかわらず、実現
あなたは完全になるかもしれません

766
00:37:12,460 --> 00:37:14,480
と圧倒
エラーメッセージの数、

767
00:37:14,480 --> 00:37:17,540
それだけで、この迷惑なカスケードであるかもしれません
クランは理解していない効果、

768
00:37:17,540 --> 00:37:19,620
それを意味する一つのこと、
次の単語を理解していません、

769
00:37:19,620 --> 00:37:20,560
または次の行。

770
00:37:20,560 --> 00:37:22,850
そしてそれはちょうどあなたのコードにチョーク。

771
00:37:22,850 --> 00:37:24,440
しかし、この修正は簡単かもしれません。

772
00:37:24,440 --> 00:37:27,822
だからいつもに焦点を当てます
出力の最初の行。

773
00:37:27,822 --> 00:37:29,530
そして、あなたがいない場合
それを理解し、ちょうど見て

774
00:37:29,530 --> 00:37:32,480
かもしれないキーワードの
手がかり、および行番号、

775
00:37:32,480 --> 00:37:34,650
文字、どこ
その間違いがあるかもしれません。

776
00:37:34,650 --> 00:37:40,328
>> 今、私は先に行くと入力してみましょう
ドットスラッシュ、文字列、入力します。

777
00:37:40,328 --> 00:37:44,340
フム、それはハロー何も言っていません。

778
00:37:44,340 --> 00:37:46,210
どうして？

779
00:37:46,210 --> 00:37:48,170
それが実行されているまあ、リコール、？

780
00:37:48,170 --> 00:37:53,730
>> それはおそらく、現時点で立ち往生しています
ループで、ライン6上、可能ならば、

781
00:37:53,730 --> 00:37:56,950
設計によって文字列を取得しているため、
CS50のスタッフによって書かれました、

782
00:37:56,950 --> 00:38:00,350
文字通り座ることを意味しています
そこに待っている、と待っています、

783
00:38:00,350 --> 00:38:01,850
文字列を待っています。

784
00:38:01,850 --> 00:38:03,792
私たちは、文字列の意味はすべて、人間が入力されます。

785
00:38:03,792 --> 00:38:04,500
だからあなたは何を知っていますか？

786
00:38:04,500 --> 00:38:05,166
私は先に行ってみよう。

787
00:38:05,166 --> 00:38:08,704
そして、ちょうど気まぐれで、私を聞かせて
私の名前、デビッドを入力し、入力します。

788
00:38:08,704 --> 00:38:10,120
今、私はよりダイナミックなプログラムを持っています。

789
00:38:10,120 --> 00:38:11,240
それはデビッドこんにちは、と述べました。

790
00:38:11,240 --> 00:38:16,280
>> 私は先に行くと、再びこれを実行すると、
私が入力し、Zamila名を言ってみましょう。

791
00:38:16,280 --> 00:38:17,940
そして今、我々は動的なプログラムを持っています。

792
00:38:17,940 --> 00:38:19,380
私は、ハードの世界をコーディングしていません。

793
00:38:19,380 --> 00:38:21,760
私は、ハードコーディングしていません
名前、またはデビッド、またはZamila。

794
00:38:21,760 --> 00:38:25,350
>> 今でははるかにプログラムのようです
それが入力を取る場合、私たちは、どこに、知っています

795
00:38:25,350 --> 00:38:27,870
それがわずかに異なる出力を生成します。

796
00:38:27,870 --> 00:38:31,020
さて、これが最善ではありません
ユーザーエクスペリエンス、またはUX。

797
00:38:31,020 --> 00:38:33,000
私はプログラムを実行します。

798
00:38:33,000 --> 00:38:35,830
>> 私はなってるかわかりません
私は実際に見ていない限り、行うには

799
00:38:35,830 --> 00:38:37,290
またはソースコードを覚えています。

800
00:38:37,290 --> 00:38:39,640
それでは、ユーザーを作ってみましょう
少し良く経験します

801
00:38:39,640 --> 00:38:41,240
物事の最も簡単なと。

802
00:38:41,240 --> 00:38:44,782
私はこの中に戻りましょう
プログラムは、単にprintfのを言います。

803
00:38:44,782 --> 00:38:48,870
>> そして、私が先に行くと名前、コロンを言わせて、
そして、空間、次にセミコロン。

804
00:38:48,870 --> 00:38:51,170
そして、ちょうど蹴りのため、ノーバックラッシュのn。

805
00:38:51,170 --> 00:38:52,980
そして、それは意図的ですが、
私はしたくないので、

806
00:38:52,980 --> 00:38:54,590
プロンプトが次の行に移動します。

807
00:38:54,590 --> 00:38:58,800
>> 私は、代わりに、これをやってみたい、文字列を作ります
新しいマシンに私のコードを再コンパイルするには

808
00:38:58,800 --> 00:39:00,980
スラッシュ文字列のドットコード。

809
00:39:00,980 --> 00:39:02,460
ああ、これははるかにきれいです。

810
00:39:02,460 --> 00:39:05,780
今、私は実際にどのようなコンピュータを知っています
私が何をしたい、それに名前を付けます。

811
00:39:05,780 --> 00:39:10,020
>> だから私は先に行くと入力するつもりです
ロブで、ハローロブを入力し、。

812
00:39:10,020 --> 00:39:13,640
そこで、最後に、これはまだ実現
その日の、唯一の9ラインプログラム。

813
00:39:13,640 --> 00:39:15,090
しかし、我々は、これらの赤ちゃんの措置を講じてきました。

814
00:39:15,090 --> 00:39:18,380
>> 私達は私達との1行を書きました
おなじみの、printf関数、こんにちは世界でした。

815
00:39:18,380 --> 00:39:19,980
その後、我々はそれを少し元に戻しました。

816
00:39:19,980 --> 00:39:21,560
そして、我々は実際のget文字列を使用していました。

817
00:39:21,560 --> 00:39:23,362
そして、我々は変数にその値を投げました。

818
00:39:23,362 --> 00:39:26,070
そして、我々は先に行って、改善されました
さらに三行目でそれ。

819
00:39:26,070 --> 00:39:29,220
そして、この反復プロセス
ソフトウェアを書くことは本当にキーです。

820
00:39:29,220 --> 00:39:33,420
CS50では、と一般的に生活の中で、
あなたは一般的に、座ってはいけません

821
00:39:33,420 --> 00:39:36,800
心の中でプログラムを持っている、と書き込みをしてみてください
すべてを一度に全体こいつ。

822
00:39:36,800 --> 00:39:40,810
>> これは、必然的に、のようになります
私たち自身がここで見たよりも多くのエラー。

823
00:39:40,810 --> 00:39:44,070
でも私は、この日に、絶えず
他の愚かな間違いを犯します、

824
00:39:44,070 --> 00:39:47,480
実際には困難ミスです
それは把握することが困難です。

825
00:39:47,480 --> 00:39:52,095
しかし、あなたはより多くの間違いがより多くを行います
コー​​ドの行は、あなたが一度にすべてを書きます。

826
00:39:52,095 --> 00:39:54,220
だからのこのような行為、
コー​​ドを少し書きます

827
00:39:54,220 --> 00:39:57,930
あなたがに慣れていることを、コンパイル
それは、それを実行し、より一般的にそれをテストし、

828
00:39:57,930 --> 00:40:01,370
その後、我々は保ただけのようなので、on--移動
先週階層化と階層化、

829
00:40:01,370 --> 00:40:04,190
非常に何かからビルド
より複雑なものに簡単な、

830
00:40:04,190 --> 00:40:05,200
ここで同じことを行います。

831
00:40:05,200 --> 00:40:08,500
座って、とにしようとしないでください
全体の問題を記述します。

832
00:40:08,500 --> 00:40:10,780
実際にこれらの赤ちゃんの手順を実行します。

833
00:40:10,780 --> 00:40:15,100
>> さて、文字列がすべてではありません
自分自身にむかっその有用。

834
00:40:15,100 --> 00:40:18,210
我々はしたいと、理想的には、実際にいただきたいです
私たちのツールキットで何かを持っています。

835
00:40:18,210 --> 00:40:20,990
それでは、実際に正確にそれをやらせます。

836
00:40:20,990 --> 00:40:24,900
>> 私は今、先に行くとかき立てるしてみましょう
わずかに異なるプログラム。

837
00:40:24,900 --> 00:40:28,320
そして、我々は整数のために、このint.cと呼ぶことにします。

838
00:40:28,320 --> 00:40:30,870
私は、同様に、するつもりです、
CS550.hが含まれます。

839
00:40:30,870 --> 00:40:33,060
私は、標準的なIOを含めるつもりです。

840
00:40:33,060 --> 00:40:36,630
そして、それはかなり一般的になるだろう
クラスのこれらの最初の数日間インチ

841
00:40:36,630 --> 00:40:39,050
>> そして、私は準備ができに行きますよ
自分のメイン機能を持ちます。

842
00:40:39,050 --> 00:40:43,370
そして今、代わりに文字列を取得します、
それでは、先に行くと、int型を取得してみましょう。

843
00:40:43,370 --> 00:40:49,285
のは、私にそれを呼ぶことにしましょう​​、と得るそれを呼び出します
int型、クローズ括弧、セミコロン。

844
00:40:49,285 --> 00:40:51,410
そして今のはやらせます
それで何か、printf関数。

845
00:40:51,410 --> 00:40:56,190
>> 以下のようなものを言ってみましょう
こんにちは、バックスラッシュnは、カンマ私。

846
00:40:56,190 --> 00:41:00,010
だから私はかなり模倣しています
私はちょっと前にやりました。

847
00:41:00,010 --> 00:41:01,660
私はここで、プレースホルダを持っています。

848
00:41:01,660 --> 00:41:05,150
私が欲しいので、私は、ここで私をカンマいます
私は、そのプレースホルダに差し込むします。

849
00:41:05,150 --> 00:41:07,250
>> それでは、先に行くと試してみましょう
このプログラムをコンパイル。

850
00:41:07,250 --> 00:41:10,060
ファイルが呼び出されint.c.

851
00:41:10,060 --> 00:41:12,920
だから私は入力して、int型を作る、と言うつもりです。

852
00:41:12,920 --> 00:41:16,420
ああ私の神が、大したことないですよね？

853
00:41:16,420 --> 00:41:17,230
間違いがあります。

854
00:41:17,230 --> 00:41:19,810
>> 構文上の誤りがあります
ここでは、そのようなプログラムができないこと

855
00:41:19,810 --> 00:41:25,460
int.c、線の内側にコンパイルします
7、文字27、エラーフォーマット

856
00:41:25,460 --> 00:41:28,400
char型を指定します
星、それがされているもの。

857
00:41:28,400 --> 00:41:30,020
しかし、引数の型はintです。

858
00:41:30,020 --> 00:41:33,110
>> そこでここでは、あまりにも、私たちはto--つもりはありません
今日は、材料がたくさんあるにもかかわらず、

859
00:41:33,110 --> 00:41:35,710
私たちはであなたを圧倒するつもりです
絶対にCのすべての機能、

860
00:41:35,710 --> 00:41:38,070
そして、より一般的にプログラミング
ただ、これらの最初の数週間インチ

861
00:41:38,070 --> 00:41:40,400
だから、多くの場合、専門用語があるように起こっています
これであなたが慣れていません。

862
00:41:40,400 --> 00:41:43,350
そして、実際には、char型の星は何かであります
我々は戻ってくるつもりです

863
00:41:43,350 --> 00:41:44,830
週または2の時間インチ

864
00:41:44,830 --> 00:41:47,530
>> しかし今のところ、私達ができる場合を見てみましょう
よく知られている単語を解析します。

865
00:41:47,530 --> 00:41:50,750
フォーマット - 私たちは形式を聞きました
指定子、書式コードの前に。

866
00:41:50,750 --> 00:41:51,840
それはお馴染みです。

867
00:41:51,840 --> 00:41:53,840
Type--しかし、引数はint型を持っています。

868
00:41:53,840 --> 00:41:55,980
ちょっと待って、私はintです。

869
00:41:55,980 --> 00:41:59,230
>> たぶんパーセントの実際
いくつかの定義された意味を持っています。

870
00:41:59,230 --> 00:42:00,230
そして、確かに、それはありません。

871
00:42:00,230 --> 00:42:03,101
整数、あなたがしたい場合
それを代用するのprintf、

872
00:42:03,101 --> 00:42:05,350
あなたが実際に使用する必要があります
異なる書式指定子。

873
00:42:05,350 --> 00:42:06,890
そして、あなたはこのことを知っているだろう
誰かがあなたに言っていない限り、

874
00:42:06,890 --> 00:42:07,973
またはあなたが前にそれを行っていました。

875
00:42:07,973 --> 00:42:10,490
しかしパーセントiは何ですか
一般的に使用されることができます

876
00:42:10,490 --> 00:42:12,240
整数をプラグインするためのprintfインチ

877
00:42:12,240 --> 00:42:14,920
またパーセントを使用することができます
10進整数のためのD。

878
00:42:14,920 --> 00:42:16,490
しかし、私はここでいいと簡単です。

879
00:42:16,490 --> 00:42:17,590
だから我々はそれで行くつもりです。

880
00:42:17,590 --> 00:42:21,160
>> 今、私は先に行くとしましょう
再放送はint型を作り、入力します。

881
00:42:21,160 --> 00:42:23,328
つまり、エラー良いです。

882
00:42:23,328 --> 00:42:27,260
ドットは、int-- OK、ユーザーエクスペリエンスを大幅に削減します
私は自分自身に語っていないので、

883
00:42:27,260 --> 00:42:27,760
何をすべきか。

884
00:42:27,760 --> 00:42:28,426
しかし、それは大丈夫です。

885
00:42:28,426 --> 00:42:29,480
私はすぐにキャッチしています。

886
00:42:29,480 --> 00:42:36,260
>> そして今、私が先に行くとしましょう
デビッド、[OK]を、Zamila、ロブを入力します。

887
00:42:36,260 --> 00:42:37,820
OK、これは良いことです。

888
00:42:37,820 --> 00:42:41,710
今回、私は、関数を使用しています
GET int型と呼ばれるパズルのピース、。

889
00:42:41,710 --> 00:42:44,230
そして、それはout--になり、私たちはよ
term--でこの以降を参照してください。

890
00:42:44,230 --> 00:42:47,730
CS50のスタッフが実施しています
このように文字列を取得

891
00:42:47,730 --> 00:42:50,350
それだけで物理的になりますこと
あなたのための文字列を取得します。

892
00:42:50,350 --> 00:42:54,340
>> これは、中のget int型を実装しています
それが唯一のような方法

893
00:42:54,340 --> 00:42:55,590
あなたのための整数値を取得します。

894
00:42:55,590 --> 00:42:57,830
そして、あなたの場合、人間、
協力しない、それはです

895
00:42:57,830 --> 00:43:00,590
文字通りに行きます
、再試行し、再試行し、再試行言います

896
00:43:00,590 --> 00:43:05,200
文字通りまで、ループそこに座っ
あなたはいくつかの魔法の数字で義務付けます、

897
00:43:05,200 --> 00:43:07,670
50 50のような、およびこんにちは。

898
00:43:07,670 --> 00:43:11,440
>> または我々は再びこれを実行する場合
そして、タイプ42で、42こんにちは。

899
00:43:11,440 --> 00:43:15,750
そのためのget int型の関数
そのパズルのピースの内側

900
00:43:15,750 --> 00:43:19,050
十分なロジックがあり、十分に考え、
把握するために、言葉は何ですか？

901
00:43:19,050 --> 00:43:20,330
その数は何ですか？

902
00:43:20,330 --> 00:43:23,165
のみ、最終的に、数値を受け付けます。

903
00:43:23,165 --> 00:43:25,690

904
00:43:25,690 --> 00:43:30,230
>> だから、このことが判明します
すべてのことの表現ではありません。

905
00:43:30,230 --> 00:43:30,910
これまでのところ。

906
00:43:30,910 --> 00:43:33,690
だから、イェーイ、最後の時間、私たち
かなり迅速に行ってきました

907
00:43:33,690 --> 00:43:38,320
ゲーム、アニメーションを実装するに、
そして、スクラッチで芸術作品。

908
00:43:38,320 --> 00:43:42,260
そしてここで、我々はコンテンツつつあります
こんにちはと世界、そしてハロー50。

909
00:43:42,260 --> 00:43:43,696
>> これは、すべてその感動はありません。

910
00:43:43,696 --> 00:43:46,070
そして、確かに、これらの最初の数
例としては、ある程度の時間がかかります

911
00:43:46,070 --> 00:43:47,510
興奮状態で上昇します。

912
00:43:47,510 --> 00:43:49,854
しかし、我々はそんなに多くを持っています
実際には、今制御します。

913
00:43:49,854 --> 00:43:51,770
そして、我々は非常にしようとしています
すぐに重ね着を開始

914
00:43:51,770 --> 00:43:53,870
これらの基本的なプリミティブの上に。

915
00:43:53,870 --> 00:43:56,370
>> しかし、最初のは理解してみましょう
どのような制限があります。

916
00:43:56,370 --> 00:43:58,620
物事の実際には、1
スクラッチは簡単にしません

917
00:43:58,620 --> 00:44:00,990
見て本当に私たちが行うさせて
ボンネットの下に、

918
00:44:00,990 --> 00:44:03,740
とを理解
コンピュータは、それが何ができるか、です

919
00:44:03,740 --> 00:44:05,250
そしてその限界は何ですか。

920
00:44:05,250 --> 00:44:08,580
そして、確かに、その不足の
理解、潜在的に、長期的

921
00:44:08,580 --> 00:44:12,520
私たち自身のmistakes--書き込みにつながることができます
安全でないソフトウェアを書くバグ、その

922
00:44:12,520 --> 00:44:13,880
何らかの方法でハッキングされます。

923
00:44:13,880 --> 00:44:17,130
>> それでは向けていくつかの手順を実行してみましょう
によってこれは少し良く理解します

924
00:44:17,130 --> 00:44:19,710
方法は、次の例を言います。

925
00:44:19,710 --> 00:44:23,550
私は先に行くと、実装するつもりです
実際に素早く加算器と呼ばれるプログラム。

926
00:44:23,550 --> 00:44:25,134
同様に、ご一緒にいくつかの数字を追加してみましょう。

927
00:44:25,134 --> 00:44:27,800
そして、私はいくつかのコーナーをコーディングするつもりです
ここでは、ちょうどコピーして貼り付けます

928
00:44:27,800 --> 00:44:30,270
私は、前にあった場所
私たちはすぐに軌道に乗ることができます。

929
00:44:30,270 --> 00:44:33,090
だから今、私は基本的な始まりを持っています
加算器と呼ばれるプログラムの。

930
00:44:33,090 --> 00:44:34,670
>> とのは、先に行くと、これを実行しましょう​​。

931
00:44:34,670 --> 00:44:38,680
私は先に行くつもりだと
たとえば、INTXはint型を取得します。

932
00:44:38,680 --> 00:44:39,430
そして、あなたは何を知っていますか？

933
00:44:39,430 --> 00:44:40,990
のは、優れたユーザーエクスペリエンスを作ってみましょう。

934
00:44:40,990 --> 00:44:45,740
>> それでは、ちょうどxがあり、かつ効果的に言わせて
私たちのxを与えるためにユーザに促します。

935
00:44:45,740 --> 00:44:50,600
そして、私が先に行くとprintfの、としましょう
どのようにyがあるについて、この時間は期待

936
00:44:50,600 --> 00:44:53,140
ユーザーからの二つの値。

937
00:44:53,140 --> 00:44:59,759
そして、ちょうど先に行くとしましょう
たとえば、printf関数、xとyの和です。

938
00:44:59,759 --> 00:45:01,300
そして今、私は、パーセント秒を行うにはしたくありません。

939
00:45:01,300 --> 00:45:09,080
私は、パーセントの私をしたい、バックスラッシュ
nは、その後、合計値をプラグイン。

940
00:45:09,080 --> 00:45:10,620
>> だから、どのように私はこれをやって行くことができますか？

941
00:45:10,620 --> 00:45:11,270
あのね？

942
00:45:11,270 --> 00:45:12,840
私は、変数を使用する方法を知っています。

943
00:45:12,840 --> 00:45:15,140
私はちょうど新しいもの、int型zを宣言してみましょう。

944
00:45:15,140 --> 00:45:16,770
>> そして、私はここで推測を取るつもりです。

945
00:45:16,770 --> 00:45:21,470
この中で等号がある場合
言語は、多分私は、xプラスyはちょうど行うことができ、

946
00:45:21,470 --> 00:45:23,660
長い間、私は私のエンドとして
セミコロンで思いましたか？

947
00:45:23,660 --> 00:45:28,170
今私は、zのプラグイン、ダウンここに戻って行くことができます
セミコロンでこの考えを終えます。

948
00:45:28,170 --> 00:45:33,160
そして、これらの場合、それでは見てみましょう
lines--のxの配列はint型を取得することです。

949
00:45:33,160 --> 00:45:34,770
Yはint型を取得することです。

950
00:45:34,770 --> 00:45:37,980
>> X及びYを追加し、z--に値を格納
そう、再び、等号を覚えています

951
00:45:37,980 --> 00:45:38,560
等しくありません。

952
00:45:38,560 --> 00:45:41,100
これは、右から左への割り当てです。

953
00:45:41,100 --> 00:45:45,180
そして、の和ことをプリントアウトしてみましょう
xとyのは、文字通りzのではありません

954
00:45:45,180 --> 00:45:46,830
しかしZの中です。

955
00:45:46,830 --> 00:45:50,090
それでは、加算器を作ってみましょう -
素敵な、間違いない今回。

956
00:45:50,090 --> 00:45:53,030
ドットは、加算器は、入力スラッシュ
xは1になるだろう。

957
00:45:53,030 --> 00:45:55,380
>> Yは2になるだろう。

958
00:45:55,380 --> 00:45:58,964
xとyの和は3です。

959
00:45:58,964 --> 00:46:00,130
だから、すべての罰金と良いです。

960
00:46:00,130 --> 00:46:03,260
>> だから、その数学を想像するだろう
このようなプログラムで動作するはずです。

961
00:46:03,260 --> 00:46:04,040
しかし、あなたは何を知っていますか？

962
00:46:04,040 --> 00:46:06,904
この変数、行があります
12、であっても必要？

963
00:46:06,904 --> 00:46:09,820
あなたが習慣に取得する必要はありません。
変数だけで物事を保存します

964
00:46:09,820 --> 00:46:10,980
ちょうどすることができますので。

965
00:46:10,980 --> 00:46:13,550
そして、実際に、それは一般的な
悪いデザインと見なさ

966
00:46:13,550 --> 00:46:18,100
あなたは、変数を作成している場合、呼ばれます
この場合のzは、それに何かを格納し、

967
00:46:18,100 --> 00:46:21,390
その直後
それを使用して、決して再び。

968
00:46:21,390 --> 00:46:24,700
なぜ何かに名前を付けます
zのように、あなたは文字通りなら

969
00:46:24,700 --> 00:46:26,770
それを使用するつもり
事は一度だけ、など

970
00:46:26,770 --> 00:46:29,380
あなたが作成した場所への近位
その最初の場所で、

971
00:46:29,380 --> 00:46:31,052
コー​​ドの行の点で非常に近いですか？

972
00:46:31,052 --> 00:46:31,760
だからあなたは何を知っていますか？

973
00:46:31,760 --> 00:46:34,480
これは、Cはかなり柔軟であることが判明しました。

974
00:46:34,480 --> 00:46:36,586
私は実際にしたい場合
プラグインの値ここで、

975
00:46:36,586 --> 00:46:38,210
私は、新しい変数を宣言する必要はありません。

976
00:46:38,210 --> 00:46:41,680
私はプラグインの可能性がXプラス
Y、Cは理解しているため

977
00:46:41,680 --> 00:46:43,390
算術演算、および算術演算子。

978
00:46:43,390 --> 00:46:47,140
>> だから私は単純に、この計算を行う、と言うことができます
xプラスyの、それらの値が何であれ、

979
00:46:47,140 --> 00:46:50,780
その結果プラグ
その文字列に整数。

980
00:46:50,780 --> 00:46:53,730
だから、これはしかし、可能性があります
一行だけ短く、

981
00:46:53,730 --> 00:46:58,480
優れたデザイン、より良いプログラム、
以下のコードがありますので、したがって、

982
00:46:58,480 --> 00:46:59,921
私が理解するために以下です。

983
00:46:59,921 --> 00:47:01,920
そしてそれは、また、単にクリーナーです
私たちではない限り、

984
00:47:01,920 --> 00:47:04,620
新しい単語を導入し、
新しいシンボル、zのように、

985
00:47:04,620 --> 00:47:07,510
彼らは本当にないにもかかわらず、
目的の多くを提供しています。

986
00:47:07,510 --> 00:47:12,890
>> 残念ながら、数学ではありません
時にはすべてのことは、信頼性の高いです。

987
00:47:12,890 --> 00:47:15,270
それでは、先に行くと、これを実行してみましょう。

988
00:47:15,270 --> 00:47:18,200
私は先に行くつもりです
今と次の手順を実行します。

989
00:47:18,200 --> 00:47:27,650
>> のは、printfの、パーセントの私、プラスパーセントをやってみましょう
私は、パーセントの私は、バックスラッシュnをしなければなりません。

990
00:47:27,650 --> 00:47:32,240
そして、私はthis-- XYXプラス、yをするつもりです。

991
00:47:32,240 --> 00:47:34,821
だから、僕はリライトするつもりです
この若干異なるここに。

992
00:47:34,821 --> 00:47:36,320
私はちょうど迅速な健全性チェックをしましょう​​。

993
00:47:36,320 --> 00:47:37,986
ここでも、のは、先に自分の取得しないようにしましょう​​。

994
00:47:37,986 --> 00:47:41,420
加算器、ドットスラッシュ加算を行います。

995
00:47:41,420 --> 00:47:44,950
xが1であり、yは2,1プラス2は3です。

996
00:47:44,950 --> 00:47:45,870
だから、それは良いことです。

997
00:47:45,870 --> 00:47:49,060
しかし、今度はこれを複雑にしてみましょう
ビット、および新しいファイルを作成します。

998
00:47:49,060 --> 00:47:53,350
>> 私はこの1つを呼び出すするつもりです、
int型、整数の複数の、と言います。

999
00:47:53,350 --> 00:47:55,980
私は一瞬前にあった場所に私は見てみましょう。

1000
00:47:55,980 --> 00:47:57,770
しかし、今のは、他のいくつかの行をしましょう​​。

1001
00:47:57,770 --> 00:48:03,430
、私が先に行くと、以下のことをやってみましょう
printf関数、パーセント私、マイナスパーセント私、

1002
00:48:03,430 --> 00:48:08,959
パーセントの私は、カンマのx、コンマYXマイナスyがあります。

1003
00:48:08,959 --> 00:48:10,750
だから私は少しやっています
そこに別の数学。

1004
00:48:10,750 --> 00:48:11,624
のは、別のものをやってみましょう。

1005
00:48:11,624 --> 00:48:16,610
だからパーセント私回パーセント
私は、パーセント私、バックスラッシュnです。

1006
00:48:16,610 --> 00:48:21,430
プラグインでのx、およびy、およびx回のyましょう。

1007
00:48:21,430 --> 00:48:24,530
私たちは、上のアスタリスクを使用します
時間のコンピュータ。

1008
00:48:24,530 --> 00:48:26,390
>> あなたは、xを使用しません。 xは
ここでは変数名。

1009
00:48:26,390 --> 00:48:28,270
あなたは乗算の星を使用します。

1010
00:48:28,270 --> 00:48:29,020
のは、1以上をやってみましょう。

1011
00:48:29,020 --> 00:48:34,580
printfの％のI、分割
パーセントによって私は、私％で、

1012
00:48:34,580 --> 00:48:40,460
バックスラッシュn個。 XY-Y-で割った値
あなたがC言語でスラッシュを使用します

1013
00:48:40,460 --> 00:48:41,502
除算を行います。

1014
00:48:41,502 --> 00:48:42,460
とのは、他のいずれかの操作を実行してみましょう。

1015
00:48:42,460 --> 00:48:47,920

1016
00:48:47,920 --> 00:48:55,240
パーセントiの残り、分割
パーセントのiで、パーセントの私です。

1017
00:48:55,240 --> 00:48:59,550
xy--、今残り
余っているものです。

1018
00:48:59,550 --> 00:49:02,980
あなたは、分裂しようとすると
分子への分母、

1019
00:49:02,980 --> 00:49:05,570
ことをどのくらい残されています
あなたはアウト分けることができませんでしたか？

1020
00:49:05,570 --> 00:49:07,910
>> だから、実際にはありません
必ずしも、シンボル

1021
00:49:07,910 --> 00:49:09,470
我々はこのために小学校に使用しました。

1022
00:49:09,470 --> 00:49:13,830
しかし、そこにあなたがすることができますC.で
ここで、xをyで割った剰余を言います

1023
00:49:13,830 --> 00:49:18,000
このcontext--でこのパーセント記号
紛らわしいあなたの中にいるとき

1024
00:49:18,000 --> 00:49:20,170
二重引用符の、
printf関数の内部に、パーセント

1025
00:49:20,170 --> 00:49:21,830
書式指定子として使用されています。

1026
00:49:21,830 --> 00:49:25,420
>> あなたは外のパーセントを使用する場合
数学的な表現でその、

1027
00:49:25,420 --> 00:49:29,910
それは、モジュラーのための剰余演算子です
私たちの目的のためにarithmetic--

1028
00:49:29,910 --> 00:49:33,650
ここでは、ちょうど何であるか、意味
xの残りの部分をyで割りましたか？

1029
00:49:33,650 --> 00:49:36,130
このため、xスラッシュyはyで割っxは。

1030
00:49:36,130 --> 00:49:38,220
yで割ったxの残りの部分は何ですか？

1031
00:49:38,220 --> 00:49:41,780
プログラマが言うように、それは、モッズyのXの。

1032
00:49:41,780 --> 00:49:48,300
>> 私はここにはミスを犯していないのであれば、私を聞かせて
、先に行くとint型を作る、複数の、素敵な

1033
00:49:48,300 --> 00:49:50,010
ドットスラッシュint型。

1034
00:49:50,010 --> 00:49:55,270
とのは、先に行くとしましょう
行う、のは、1、10をしましょう​​。

1035
00:49:55,270 --> 00:49:58,390
すべての権利は​​、1プラス10は、チェック、11です。

1036
00:49:58,390 --> 00:50:01,240
1マイナス10がマイナス9で、確認してください。

1037
00:50:01,240 --> 00:50:03,420
>> 1回10チェック、10です。

1038
00:50:03,420 --> 00:50:07,090
10 is--で割った1
[OK]を、私たちはその1をスキップします。

1039
00:50:07,090 --> 00:50:09,480
10で割った1の残りの部分は1です。

1040
00:50:09,480 --> 00:50:10,680
そのとおりです。

1041
00:50:10,680 --> 00:50:12,630
しかし、ここでバグがあります。

1042
00:50:12,630 --> 00:50:15,390
>> だから1私は私を入れて
正しくない、手渡します。

1043
00:50:15,390 --> 00:50:16,670
私が意味する、それが0に近いです。

1044
00:50:16,670 --> 00:50:20,670
私たちがしている場合は10で割った1、あなたが知っています、
いくつかのコーナーをカット、必ず、それはゼロです。

1045
00:50:20,670 --> 00:50:28,050
しかし、それは本当に1/10にする必要があり、
0.1、または0.10、0.1000、または等々。

1046
00:50:28,050 --> 00:50:30,600
>> それは本当にゼロであってはなりません。

1047
00:50:30,600 --> 00:50:35,990
まあ、それはコンピュータであることが判明します
文字通りやって我々が行うには、それを言いました。

1048
00:50:35,990 --> 00:50:39,460
私たちは、yで割ったXのような数学をやっています。

1049
00:50:39,460 --> 00:50:44,680
そして、ラインごとにxとyの両方、
以前のコードで、整数です。

1050
00:50:44,680 --> 00:50:50,440
>> また、15行目に、私たちはあります
printf関数を語って、ちょっと、printfのプラグイン

1051
00:50:50,440 --> 00:50:54,230
整数は、プラグインの整数、
プラグインinteger--特異的に

1052
00:50:54,230 --> 00:50:57,580
その後、X、次にY、およびX
yで割りました。 xとyはint型です。

1053
00:50:57,580 --> 00:50:59,060
私たちはそこに良いです。

1054
00:50:59,060 --> 00:51:01,250
>> しかし、xはxで何を分けているのですか？

1055
00:51:01,250 --> 00:51:06,790
x、yがあるべきであるで割りました、
数学的に、1月10日、または0.1、

1056
00:51:06,790 --> 00:51:11,600
これは実数、実数であります
、潜在的に、小数点を持ちます。

1057
00:51:11,600 --> 00:51:13,230
これは整数ではありません。

1058
00:51:13,230 --> 00:51:18,290
>> しかし、最も近いものです
1/10、または0.1の整数？

1059
00:51:18,290 --> 00:51:21,114
ええ、それは一種のゼロです。

1060
00:51:21,114 --> 00:51:22,030
0.1は、これだけのようなものです。

1061
00:51:22,030 --> 00:51:22,890
そして、図1は、このくらいです。

1062
00:51:22,890 --> 00:51:25,870
だから1/10に近いです
それは一つにあるよりも0。

1063
00:51:25,870 --> 00:51:30,800
>> だからCはus--のために何をしていますか
種類の我々はそれを言ったので、to--

1064
00:51:30,800 --> 00:51:32,600
その整数を切り捨てています。

1065
00:51:32,600 --> 00:51:40,540
それは再び値を取っています
0.1000のようなものであると考え、

1066
00:51:40,540 --> 00:51:41,800
0など。

1067
00:51:41,800 --> 00:51:45,320
そして、それはすべてのものを切り捨てています
小数点以下

1068
00:51:45,320 --> 00:51:47,510
このように、すべて
もの、そうでないので、

1069
00:51:47,510 --> 00:51:51,910
これは、整数の概念に適合
1、0、1、負のようなだけの数であり、

1070
00:51:51,910 --> 00:51:55,830
上下、それはすべてを捨てます
あなたのため小数点以下

1071
00:51:55,830 --> 00:51:59,020
小数点をフィットすることはできません
定義により、整数インチ

1072
00:51:59,020 --> 00:52:01,290
>> そこでここでは答えはゼロです。

1073
00:52:01,290 --> 00:52:02,600
だから、どのように我々はこれを修正しますか？

1074
00:52:02,600 --> 00:52:04,400
我々は、すべて一緒に別のソリューションが必要です。

1075
00:52:04,400 --> 00:52:06,880
以下のように、私たちは、これを行うことができます。

1076
00:52:06,880 --> 00:52:12,820
>> 私が先に行くと、新しいを作成してみましょう
ファイル、この1はfloats.cと呼ばれます。

1077
00:52:12,820 --> 00:52:16,500
そして、ここでそれを保存
同じディレクトリに、float.c。

1078
00:52:16,500 --> 00:52:19,360

1079
00:52:19,360 --> 00:52:23,260
そして、私が先に行くと、コピーしてみましょう
以前からそのコードの一部。

1080
00:52:23,260 --> 00:52:27,690
>> しかし、その代わりに取得します
int型は、はこのやろう。

1081
00:52:27,690 --> 00:52:31,037
私に浮動小数点値を与えます
Xと呼ばれます。ここで、浮動小数点

1082
00:52:31,037 --> 00:52:33,370
値は文字通りです
浮動小数点で何か。

1083
00:52:33,370 --> 00:52:34,410
それは右に、左に移動することができます。

1084
00:52:34,410 --> 00:52:35,530
それは実数です。

1085
00:52:35,530 --> 00:52:38,050
>> そして、私がいないと呼びましょう
int型を得るが、フロートを取得し、

1086
00:52:38,050 --> 00:52:41,420
また、メニューの中でした
C250ライブラリのオプション。

1087
00:52:41,420 --> 00:52:43,220
フロートにyと変更してみましょう。

1088
00:52:43,220 --> 00:52:45,000
これはfloatを得るになります。

1089
00:52:45,000 --> 00:52:47,620
>> そして今、我々はint型をプラグインする必要はありません。

1090
00:52:47,620 --> 00:52:53,130
それは我々がパーセントを使用する必要が判明します
フロートのためのF、フロートのパーセントF、

1091
00:52:53,130 --> 00:52:54,560
そして今、それを保存します。

1092
00:52:54,560 --> 00:53:01,220
そして今、指が交差し、作ります
山車、素敵な、ドットスラッシュ山車。

1093
00:53:01,220 --> 00:53:04,280
xは1 1のyになるだろう
10もう一度になるだろう。

1094
00:53:04,280 --> 00:53:08,240
>> そして、素敵な、[OK]を私の添加が正しいです。

1095
00:53:08,240 --> 00:53:10,240
私はより多くを期待していました、
私はそれを書くのを忘れていました。

1096
00:53:10,240 --> 00:53:13,250
それでは、行くとこの論理エラーを修正しましょう​​。

1097
00:53:13,250 --> 00:53:16,280
>> それでは、先に行くと、次のをつ​​かむしてみましょう。

1098
00:53:16,280 --> 00:53:18,080
私たちは、ほんの少しのコピーと貼り付けを行います。

1099
00:53:18,080 --> 00:53:20,080
そして、私はマイナスを言うつもりです。

1100
00:53:20,080 --> 00:53:21,890
>> そして、私は時間を言うつもりです。

1101
00:53:21,890 --> 00:53:24,060
そして私は、分割されたと言うつもりです。

1102
00:53:24,060 --> 00:53:28,240
そして、私は、剰余をするつもりはありませんよ
これは、ここのようなゲルマンではありません

1103
00:53:28,240 --> 00:53:33,690
F、および時間で割っplus--
OK、それでは、再びこれをしましょう​​。

1104
00:53:33,690 --> 00:53:44,210
>> 山車を作り、ドットスラッシュ山車、
1、10、and--素敵な、いや、[OK]をクリックします。

1105
00:53:44,210 --> 00:53:45,250
だから私は馬鹿です。

1106
00:53:45,250 --> 00:53:47,000
だから、これは非常に一般的です
コンピュータサイエンスの

1107
00:53:47,000 --> 00:53:49,780
このような愚かな間違いを犯しました。

1108
00:53:49,780 --> 00:53:53,100
>> 教育的な目的のために、
私が本当にやりたいこと

1109
00:53:53,100 --> 00:53:57,410
ここで科学を変更しました。
プラス、マイナスに、倍に、

1110
00:53:57,410 --> 00:54:01,140
うまくいけば、あなたのように、分割します
この運動中に気づきました。

1111
00:54:01,140 --> 00:54:04,700
だから今のは、これを再コンパイルしてみましょう
プログラムは、ドットスラッシュ山車を行います。

1112
00:54:04,700 --> 00:54:07,950
>> そして三度目の、みましょう
それは私の期待を満たしているかどうかを確認します。

1113
00:54:07,950 --> 00:54:21,480
1、10、1.000、OK、はい、入力し、
10.000で割った、0.100000です。

1114
00:54:21,480 --> 00:54:24,952
そしてそれはどのように多くの私たちが制御でき判明します
数字は、それらの小数点の後にあります。

1115
00:54:24,952 --> 00:54:25,660
私たちは、実際になります。

1116
00:54:25,660 --> 00:54:26,790
我々は戻ってそれに来ます。

1117
00:54:26,790 --> 00:54:28,440
>> しかし、今、実際には、数学が正しいです。

1118
00:54:28,440 --> 00:54:30,090
だから、もう一度、ここでお持ち帰りは何ですか？

1119
00:54:30,090 --> 00:54:33,050
それはCであることが判明します
ただ、strings--と、実際にだけでなく、

1120
00:54:33,050 --> 00:54:36,120
我々ので、実際にそこではありません
CS50ライブラリを持つものを追加します。

1121
00:54:36,120 --> 00:54:37,710
しかし、単にint型はありません。

1122
00:54:37,710 --> 00:54:38,990
>> 山車もあります。

1123
00:54:38,990 --> 00:54:42,810
そして、それは他のデータの束が判明します
種類はあまりにも、私たちはずっと前に使用しますことを。

1124
00:54:42,810 --> 00:54:46,270
あなたは、単一たい場合判明
文字の文字、文字列ではありません、

1125
00:54:46,270 --> 00:54:47,610
あなただけの文字を使用することができます。

1126
00:54:47,610 --> 00:54:52,350
>> あなたはブール値が必要な場合ことが判明し、
ブール値trueまたはfalseのみ、

1127
00:54:52,350 --> 00:54:56,840
CS50ライブラリのおかげで、我々はしました
同様にCにブールデータ型を追加しました。

1128
00:54:56,840 --> 00:54:59,180
しかし、それはまた、中に存在します
他の多くの言語にも。

1129
00:54:59,180 --> 00:55:04,130
そして、それはその時々判明します
デフォルトで来るより大きな番号が必要

1130
00:55:04,130 --> 00:55:05,210
int型とフロートと。

1131
00:55:05,210 --> 00:55:10,590
>> そして、実際には、二重の数であります
それはない32ビットが、64ビットを使用します。

1132
00:55:10,590 --> 00:55:14,990
そして、長い長いその数はあります
ない32、ビットが、64ビットを使用し、

1133
00:55:14,990 --> 00:55:19,190
それぞれ、浮動小数点のために
それぞれの値と整数、。

1134
00:55:19,190 --> 00:55:22,780
だから今、実際にしてみましょう
この動作を確認。

1135
00:55:22,780 --> 00:55:26,150
>> 私はここで先に行くつもりです
一他のプログラムをかき立てます。

1136
00:55:26,150 --> 00:55:32,020
ここでは、私が先に行くつもりです
そして、CS50.h.が含まれません

1137
00:55:32,020 --> 00:55:34,910
そして、私が行くよう、標準IO.h.を含みます

1138
00:55:34,910 --> 00:55:37,320
>> そして、あなたは何かに気付くでしょう
ファンキーはここに起こっています。

1139
00:55:37,320 --> 00:55:40,592
それはで物事をカラーコーディングいません
それは以前と同じように。

1140
00:55:40,592 --> 00:55:43,550
そして、それは私ので、それはだ、判明します
事にファイル名を与えられていません。

1141
00:55:43,550 --> 00:55:47,270
>> 私はこの1つを呼び出すつもりです
sizeof.cは、保存を押してください。

1142
00:55:47,270 --> 00:55:51,039
そして、私は非常に何が起こるか気づきます
その黒の背景に白のコード。

1143
00:55:51,039 --> 00:55:52,830
今、少なくともあります
そこにいくつかの紫色。

1144
00:55:52,830 --> 00:55:54,490
そして、それは構文が強調表示されています。

1145
00:55:54,490 --> 00:55:57,700
>> 、非常に単純に、私はきたからです
ファイルの種類をIDEに語りました

1146
00:55:57,700 --> 00:56:01,060
それはそれに名前を与えることであり、
具体的には、ファイルの拡張子。

1147
00:56:01,060 --> 00:56:03,620
さて、先に行くと、これを実行しましょう​​。

1148
00:56:03,620 --> 00:56:08,910
私は先に、非常に行くつもりです
単にfollowing--ブール値をプリントアウト

1149
00:56:08,910 --> 00:56:11,080
パーセントLUです。

1150
00:56:11,080 --> 00:56:12,950
>> 我々は戻ってくるだろう
一瞬のもの。

1151
00:56:12,950 --> 00:56:15,840
そして、私はするつもりです
ブール値のプリントサイズ。

1152
00:56:15,840 --> 00:56:18,170
そして今、ちょうど保存します
自分自身いくつかの時間、私はよ

1153
00:56:18,170 --> 00:56:20,280
全体をするつもり
一度にこれらの束。

1154
00:56:20,280 --> 00:56:24,620
そして、具体的には、私はするつもりです
チャーチャーに変更。

1155
00:56:24,620 --> 00:56:27,760
この1、私は変更するつもりです
ダブル、ダブルへ。

1156
00:56:27,760 --> 00:56:31,440
>> この1、私は変更するつもりです
フロートとフロートへ。

1157
00:56:31,440 --> 00:56:35,670
この1、私はするつもりです
int型とintに変更します。

1158
00:56:35,670 --> 00:56:38,660
そして、この1、私は行きますよ
長い長いに変更します。

1159
00:56:38,660 --> 00:56:40,840
そして、それはまだ取っています
長い時間、長い長いです。

1160
00:56:40,840 --> 00:56:44,572
>> そして、最後に、私が与えました
私自身は、1あまりにも多く、文字列。

1161
00:56:44,572 --> 00:56:47,030
これは、Cには、があることが判明します
呼ばれる特別なオペレータ

1162
00:56:47,030 --> 00:56:50,260
その大きさは、文字通りです
、ときに実行しようとして、

1163
00:56:50,260 --> 00:56:52,099
私たちのサイズを教えて
これらの変数のそれぞれ。

1164
00:56:52,099 --> 00:56:53,890
そして、これは、今、方法です
我々は戻って接続することができます

1165
00:56:53,890 --> 00:56:57,140
先週の議論に
データ及び表現の。

1166
00:56:57,140 --> 00:57:00,330
>> 私が先に行くと、コンパイルしてみましょう
のドットスラッシュサイズの大きさ。

1167
00:57:00,330 --> 00:57:01,210
そして、見てみましょう。

1168
00:57:01,210 --> 00:57:05,210
これは、C言語でいることが判明し、
具体的にCS50 IDE上で、

1169
00:57:05,210 --> 00:57:08,170
具体的に
オペレーティングシステムUbuntuの、

1170
00:57:08,170 --> 00:57:11,100
64ビットオペレーティングこれは
この場合のシステム、

1171
00:57:11,100 --> 00:57:14,189
ブール値に起こっています
スペースの1バイトを使用します。

1172
00:57:14,189 --> 00:57:16,480
それはサイズを測定する方法です、
ないビットではなく、バイトインチ

1173
00:57:16,480 --> 00:57:18,690
そして、1バイトは8ビットであることを思い出してください。

1174
00:57:18,690 --> 00:57:22,030
だからブール値、も、あなたかかわらず、
技術的にのみ、0または1を必要とします

1175
00:57:22,030 --> 00:57:24,092
それは少し無駄です
どのように我々はそれを実装しました。

1176
00:57:24,092 --> 00:57:26,800
実際に全体を使用するように起こっています
byte--ので、すべてのゼロは、多分あります

1177
00:57:26,800 --> 00:57:31,050
すべてのもの、またはそのような何か、
またはちょうど1 1 8ビットのうち。

1178
00:57:31,050 --> 00:57:34,962
>> チャーは、また、文字に使用されます
先週あたりのASCII文字のように、

1179
00:57:34,962 --> 00:57:36,170
1文字にな​​るだろう。

1180
00:57:36,170 --> 00:57:42,340
そして、それは私たちの概念とアップsynchs
それは、むしろせいぜい256 bits--されていません

1181
00:57:42,340 --> 00:57:45,360
それはなしであるとsynchsアップ
8ビット、これよりも長いです

1182
00:57:45,360 --> 00:57:47,450
私たちのように多くの256のような値を与えます。

1183
00:57:47,450 --> 00:57:49,680
ダブルはに起こっています
8バイトまたは64ビットです。

1184
00:57:49,680 --> 00:57:50,510
>> フロートは4です。

1185
00:57:50,510 --> 00:57:51,690
intが4です。

1186
00:57:51,690 --> 00:57:52,980
、長い長いは8です。

1187
00:57:52,980 --> 00:57:54,716
そして、文字列が8です。

1188
00:57:54,716 --> 00:57:55,840
しかし、それについては心配しないでください。

1189
00:57:55,840 --> 00:57:57,340
私たちは、その層をバック剥離するつもりです。

1190
00:57:57,340 --> 00:57:59,940
これは、文字列ができ、判明します
8バイトより長くすること。

1191
00:57:59,940 --> 00:58:02,310
>> そして、確かに、私たちは書きました
既に文字列、Hello Worldの、

1192
00:58:02,310 --> 00:58:03,700
8バイトより長いです。

1193
00:58:03,700 --> 00:58:06,270
しかし、我々は戻ってくるだろう
一瞬のもの。

1194
00:58:06,270 --> 00:58:09,690
しかし、ここで持ち帰りは以下の通りです。

1195
00:58:09,690 --> 00:58:15,320
>> 任意のコンピュータが唯一の有限を持っています
メモリとスペースの量。

1196
00:58:15,320 --> 00:58:17,860
あなただけの非常に多くの保存することができます
お使いのMacまたはPC上のファイル。

1197
00:58:17,860 --> 00:58:23,030
あなただけで非常に多くのプログラムを格納することができます
RAMはあっても、必ずしも、一度に実行されています

1198
00:58:23,030 --> 00:58:26,360
仮想メモリと、理由
あなたはRAMの有限量を持っています。

1199
00:58:26,360 --> 00:58:28,990
>> そして、ちょうど場合picture--します
あなたがラップトップを開いたことがありません

1200
00:58:28,990 --> 00:58:31,300
または余分なメモリを命じました
コンピュータのための、あなた

1201
00:58:31,300 --> 00:58:33,670
それを知らないかもしれません
お使いのコンピュータの内部

1202
00:58:33,670 --> 00:58:36,590
見えるものです
このような小さな。

1203
00:58:36,590 --> 00:58:40,540
だから、これはという名前だけの一般的な会社です
コンピュータ用のRAMを作ることが重要。

1204
00:58:40,540 --> 00:58:43,620
そして、RAMはどこのプログラムであります
彼らが実行している間住んでいます。

1205
00:58:43,620 --> 00:58:46,630
>> だから、あなたが倍増すべてのMacやPC、上
プログラムをクリックして、それが開き、

1206
00:58:46,630 --> 00:58:48,921
そして、それはいくつかのWord文書を開きます
またはそのような何か、

1207
00:58:48,921 --> 00:58:51,764
それは一時的に格納します
RAM、RAMは高速であるため、

1208
00:58:51,764 --> 00:58:53,680
あなたのハードディスクよりも、または
あなたのソリッドステートディスク。

1209
00:58:53,680 --> 00:58:56,600
プログラムはどこに行くので、それはちょうどです
彼らが実行しているときに生きて、

1210
00:58:56,600 --> 00:58:58,060
またはファイルが使用されている場合。

1211
00:58:58,060 --> 00:59:00,890
>> だから、見るものを持っています
あなたのラップトップのこの内部のように、

1212
00:59:00,890 --> 00:59:03,320
またはわずかに大きいもの
デスクトップの内部。

1213
00:59:03,320 --> 00:59:07,440
しかし、キーはあなたしかいないのさ
これらの事の有限数。

1214
00:59:07,440 --> 00:59:11,230
との唯一の有限量があります
ハードウェアは、この机の上に座って右側

1215
00:59:11,230 --> 00:59:11,730
ここに。

1216
00:59:11,730 --> 00:59:15,920
>> だから、きっと、私たちは保存できません
無限に長い数字。

1217
00:59:15,920 --> 00:59:19,030
そして、まだ、あなたが戻って考える場合
小学校、どのように多くの桁ができます

1218
00:59:19,030 --> 00:59:21,400
あなたが右に持っています
小数点の？

1219
00:59:21,400 --> 00:59:24,680
そのことについては、どのように多くの桁ができます
あなたは、小数点の左側にありますか？

1220
00:59:24,680 --> 00:59:26,300
本当に、無限に多くの。

1221
00:59:26,300 --> 00:59:30,840
>> 今、私たち人間だけかもしれません
百万の発音を知って、

1222
00:59:30,840 --> 00:59:34,990
10億、兆、および
兆、そして京。

1223
00:59:34,990 --> 00:59:39,370
そして、私は私の限界に挑戦しています
understanding--またはmy--私は理解して

1224
00:59:39,370 --> 00:59:41,110
数字が、私の
数字の発音。

1225
00:59:41,110 --> 00:59:44,720
しかし、彼らはとの無限大得ることができます
左に無限に多くの桁数

1226
00:59:44,720 --> 00:59:47,050
または小数点の右側にあります。

1227
00:59:47,050 --> 00:59:50,040
>> しかし、コンピュータしかいません
メモリの有限量、

1228
00:59:50,040 --> 00:59:53,510
トランジスタの有限数、A
内部の電球の有限数。

1229
00:59:53,510 --> 00:59:57,350
だから何が起こるとき、
あなたは、スペースを使い果たし？

1230
00:59:57,350 --> 00:59:59,620
言い換えれば、あなたの場合
バック先週に思います

1231
00:59:59,620 --> 01:00:03,160
我々は数字について話したとき、
自体は、バイナリで表現されています

1232
01:00:03,160 --> 01:00:05,480
我々が持っていると仮定
ここでは、この8ビットの値。

1233
01:00:05,480 --> 01:00:08,290
>> そして、私たちは7の1と1 0を持っています。

1234
01:00:08,290 --> 01:00:10,827
そして、私たちが望むと仮定
この値に1を追加します。

1235
01:00:10,827 --> 01:00:12,410
これは、今本当に大きな数です。

1236
01:00:12,410 --> 01:00:16,610
>> 私が覚えている場合、これは、254であります
先週の右から数学。

1237
01:00:16,610 --> 01:00:19,480
しかし、私は何を変更した場合
右端の0から1の？

1238
01:00:19,480 --> 01:00:22,800
全体数の
コー​​スは、8 1のになります。

1239
01:00:22,800 --> 01:00:24,050
だから我々はまだ良いです。

1240
01:00:24,050 --> 01:00:27,204
>> そしてそれはおそらく表し
255、文脈にもよるが

1241
01:00:27,204 --> 01:00:29,120
それは実際に表すことができ
負の数。

1242
01:00:29,120 --> 01:00:31,240
しかし、それ別の時間の詳細。

1243
01:00:31,240 --> 01:00:34,220
それは程度だようにこれは感じています
私は数えることができるほど高いです。

1244
01:00:34,220 --> 01:00:35,290
>> 今、それは8ビットのみです。

1245
01:00:35,290 --> 01:00:38,170
そして、私のMacは、確かに、方法を持っています
メモリの8ビット以上。

1246
01:00:38,170 --> 01:00:39,170
しかし、それは有限持っています。

1247
01:00:39,170 --> 01:00:43,230
だから、同じ引数があっても、適用され、私たち
画面上でこれらのものの多くを持っています。

1248
01:00:43,230 --> 01:00:47,020
>> あなたがしている場合はどうなります
この数、255を格納し、

1249
01:00:47,020 --> 01:00:49,290
あなたは1ビット高いカウントするようにしたいですか？

1250
01:00:49,290 --> 01:00:51,600
あなたは255から256に行きたいです。

1251
01:00:51,600 --> 01:00:55,800
この問題は、もちろんであるあなたなら
先週のようにゼロからカウントを開始し、

1252
01:00:55,800 --> 01:00:59,670
あなたは、高カウントすることはできません
、256のように、おろか257

1253
01:00:59,670 --> 01:01:02,584
一人で258、メートルどのような理由ましょう
あなたは1を追加するとどうなりますか？

1254
01:01:02,584 --> 01:01:05,000
古い小学校を行​​う場合
アプローチは、あなたがここに1を入れて、

1255
01:01:05,000 --> 01:01:08,150
そしてその後、1プラス1が2であるが、それはです
本当にゼロは、あなたは、1を運びます

1256
01:01:08,150 --> 01:01:09,695
1を運ぶ、1を運びます。

1257
01:01:09,695 --> 01:01:12,620
これらの事のすべて、
これらの1ののは、ゼロになります。

1258
01:01:12,620 --> 01:01:17,820
そして、あなたは誰かのように、はい、羽目になる
左側に、1を指摘し​​ました。

1259
01:01:17,820 --> 01:01:22,540
しかし、すべては、次のことができます
実際に見ると、メモリ内に収まります

1260
01:01:22,540 --> 01:01:27,960
言うことですちょうど8 0の、あります
いくつかの点でよろしければ、コンピュータ、

1261
01:01:27,960 --> 01:01:32,490
十分に高いカウントアップしようとした、あなたがしています
ラップアラウンドに行く、それが思われます、

1262
01:01:32,490 --> 01:01:35,850
ゼロへ、または多分負
ゼロよりもさらに低い数字。

1263
01:01:35,850 --> 01:01:37,260
>> そして、我々は一種のこれを見ることができます。

1264
01:01:37,260 --> 01:01:39,900
私が先に行くと書いてみましょう
ここで実際に素早くプログラム。

1265
01:01:39,900 --> 01:01:43,690
私が先に行くと書いてみましょう
オーバーフローと呼ばれるプログラム。

1266
01:01:43,690 --> 01:01:49,980
含まれ、CS50.hを含みます
標準IO.h--ああ、

1267
01:01:49,980 --> 01:01:51,730
私は本当に私のシンタックスハイライ​​トを逃しました。

1268
01:01:51,730 --> 01:01:54,440
それではoverflow.cとしてこれを保存してみましょう。

1269
01:01:54,440 --> 01:01:57,084
>> そして今、int型メインvoid--
そして、長い前に、私たちはよ

1270
01:01:57,084 --> 01:01:59,500
理由を説明に戻ってきます
我々はint型の主な空隙を書いておきます。

1271
01:01:59,500 --> 01:02:02,080
しかし、今のところ、ちょうどやらせます
当然だが、それを取って。

1272
01:02:02,080 --> 01:02:06,200
のは、自分自身のintを与えてみましょう、
そしてそれを0に初期化します。

1273
01:02:06,200 --> 01:02:11,716
>> 私はzero--を取得するのは、その後、int型のためにやってみましょう
実際に、の無限ループをやらせます

1274
01:02:11,716 --> 01:02:12,590
そして、何が起こるかを参照してください。

1275
01:02:12,590 --> 01:02:22,440
真の間、その後のnをプリントアウトしてみましょう
％は私、バックスラッシュnは、プラグインnです。

1276
01:02:22,440 --> 01:02:27,200
しかし、今、のは、nは、nに1を加えますしましょう​​。

1277
01:02:27,200 --> 01:02:29,660
>> 言い換えれば、それぞれにそのように
この無限ループの反復、

1278
01:02:29,660 --> 01:02:32,550
のは、nの値をみましょう、
し、それに1を追加し、

1279
01:02:32,550 --> 01:02:34,350
左側の背中のnに結果を格納。

1280
01:02:34,350 --> 01:02:37,150
そして、実際には、我々は次の構文を見てきました
わずかにこのような、簡単に。

1281
01:02:37,150 --> 01:02:39,730
クールなトリックではなく、あります
このすべてを書き出します、

1282
01:02:39,730 --> 01:02:42,770
あなたは、実際には、n個のプラス1に等しいと言うことができます。

1283
01:02:42,770 --> 01:02:47,480
>> それとも、本当に空想になりたい場合は、
あなたは、nプラスプラスセミコロン言うことができます。

1284
01:02:47,480 --> 01:02:50,130
しかし、これら後者の二つだけです
私たちは糖衣構文を呼びたいです

1285
01:02:50,130 --> 01:02:50,790
最初のもののために。

1286
01:02:50,790 --> 01:02:53,456
>> まず最初に、より明示的です
完全に罰金、完全に正しいです。

1287
01:02:53,456 --> 01:02:55,470
しかし、これはより一般的ですが、私は言うでしょう。

1288
01:02:55,470 --> 01:02:57,210
だから我々は、ちょっとこれをやります。

1289
01:02:57,210 --> 01:03:01,685
>> 音のが今作ろうオーバーフロー、
むしろ不吉な、ドットスラッシュオーバーフロー。

1290
01:03:01,685 --> 01:03:04,380

1291
01:03:04,380 --> 01:03:09,852
どれどれ、nはかなり大きななってきました。

1292
01:03:09,852 --> 01:03:11,310
しかし、nは得ることができますどのように大きな、のは、考えてみましょうか？

1293
01:03:11,310 --> 01:03:12,870
>> nがintです。

1294
01:03:12,870 --> 01:03:16,400
私たちは、の大きさに一瞬前に見ました
例intが4バイトであること。

1295
01:03:16,400 --> 01:03:22,070
私たちは、4バイトがあり、先週から知っています
32ビットため8倍4は、それが32です。

1296
01:03:22,070 --> 01:03:23,460
それは40億になるだろう。

1297
01:03:23,460 --> 01:03:25,802
>> そして、我々は800,000までです。

1298
01:03:25,802 --> 01:03:28,510
これはに永遠に取るために起こっています
私はおそらくできるだけ高く数えます。

1299
01:03:28,510 --> 01:03:30,635
だから私は、先に行くつもりです
あなたが前に長いかもしれませんが、

1300
01:03:30,635 --> 01:03:34,910
そして、率直に言ってコントロールをコントロールC--を打ちます
C、コントロールC一般的に多く、

1301
01:03:34,910 --> 01:03:36,034
手段はキャンセル。

1302
01:03:36,034 --> 01:03:38,200
残念ながら、このため
クラウドで実行されています、

1303
01:03:38,200 --> 01:03:41,190
時々雲があります
そんなにものを吐き出し、

1304
01:03:41,190 --> 01:03:44,180
そんなに出力は、それがために起こっています
私の入力のために少し時間がかかります

1305
01:03:44,180 --> 01:03:45,630
クラウドに取得します。

1306
01:03:45,630 --> 01:03:49,240
だから私はヒットにもかかわらず、
数秒前にコントロールC、

1307
01:03:49,240 --> 01:03:53,110
これは間違いなく側であります
無限ループの効果。

1308
01:03:53,110 --> 01:03:56,070
>> そのため、このようなケースでは、我々はしています
であることを残して行きます。

1309
01:03:56,070 --> 01:03:59,050
そして、私たちは別のものを追加するつもりです
こっちターミナルウィンドウ

1310
01:03:59,050 --> 01:04:03,186
もちろんないプラス、と
そのように、それはまだ考えているので。

1311
01:04:03,186 --> 01:04:05,310
とのは、先に行くとなりましょう
もう少し合理的。

1312
01:04:05,310 --> 01:04:07,768
>> 私は先に行くと何をするつもりです
この唯一の有限個の回。

1313
01:04:07,768 --> 01:04:10,047
のは、forループを使用してみましょう、
これは私が以前に言及しました。

1314
01:04:10,047 --> 01:04:10,630
これをやろう。

1315
01:04:10,630 --> 01:04:13,430
私が0の修整を受ける別の変数はintを与えます。

1316
01:04:13,430 --> 01:04:17,430
私は、私は++ 64のは言わせて、より少ないです。

1317
01:04:17,430 --> 01:04:24,010
そして今、私が先に行くと印刷しましょう
nは外パーセント私、コンマnです。

1318
01:04:24,010 --> 01:04:27,547
そして、これはまだありますN--
永遠に連れて行きます。

1319
01:04:27,547 --> 01:04:28,130
これをやろう。

1320
01:04:28,130 --> 01:04:30,620
>> nが2の修整を受けるn回。

1321
01:04:30,620 --> 01:04:34,140
それとも私たちは空想かもしれません
そして時間が2に等しい行います。

1322
01:04:34,140 --> 01:04:37,120
しかし、ちょうどn個としましょう
2倍、それ自体に等しいです。

1323
01:04:37,120 --> 01:04:39,321
換言すれば、この中
プログラムの新バージョン、

1324
01:04:39,321 --> 01:04:41,820
私は永遠に待ちたくありません
80万などから40億に。

1325
01:04:41,820 --> 01:04:43,070
ちょうどこのオーバーを取得してみましょう。

1326
01:04:43,070 --> 01:04:44,920
>> それでは、実際にnは、それぞれの時間を倍にしてみましょう。

1327
01:04:44,920 --> 01:04:47,660
これは、リコール、倍増があります
もちろん、持っていることの反対。

1328
01:04:47,660 --> 01:04:50,035
そして、先週のに対し、我々が持っています
何か再び、そして再び、

1329
01:04:50,035 --> 01:04:52,200
そして再び、超高速、
確かだろう倍増

1330
01:04:52,200 --> 01:04:58,080
最大の可能性への1から私たちを取得します
我々はint型とに数えることができる値。

1331
01:04:58,080 --> 01:04:59,750
>> それでは、まさにこれを実行しましょう​​。

1332
01:04:59,750 --> 01:05:01,720
そして、私たちはずっと前に戻ってこれに来ます。

1333
01:05:01,720 --> 01:05:04,180
しかし、これは、再び、ちょうどのようなものです
スクラッチでリピートブロック。

1334
01:05:04,180 --> 01:05:05,600
そして、あなたはずっと前にこれを使用します。

1335
01:05:05,600 --> 01:05:10,170
>> これは単に、ゼロからカウントを意味します
64、まで、しかし、等しくありません。

1336
01:05:10,170 --> 01:05:14,285
そして、これが繰り返されるたびに
ループは、ちょうど私をインクリメント保ちます。

1337
01:05:14,285 --> 01:05:18,990
だから私は++  - と、この一般的な構文
7行目だけの超一般的な方法です

1338
01:05:18,990 --> 01:05:22,290
のいくつかの行を繰り返します
コー​​ド、何回か。

1339
01:05:22,290 --> 01:05:23,362
どのコードの行？

1340
01:05:23,362 --> 01:05:25,570
これらの中括弧、あなたと
今から収集している可能性があり、

1341
01:05:25,570 --> 01:05:26,780
手段は、次の手順を実行します。

1342
01:05:26,780 --> 01:05:29,510
>> それはときに、のようなスクラッチにです
それは黄色のブロックを有しています

1343
01:05:29,510 --> 01:05:32,680
他の色その種類の
他のブロックを受け入れるか、抱擁。

1344
01:05:32,680 --> 01:05:34,750
それはどのようなものを巻き毛です
ブレースは、ここでやっています。

1345
01:05:34,750 --> 01:05:40,200
だから、私は構文を得た場合right--あなたを
C手段にニンジンシンボルを見ることができます

1346
01:05:40,200 --> 01:05:42,706
それは私がした回数です
この問題を解決しようとします。

1347
01:05:42,706 --> 01:05:45,330
それでははその1を取り除くましょう
完全に、そのウィンドウを閉じます。

1348
01:05:45,330 --> 01:05:46,520
そして、我々は新しいものを使用します。

1349
01:05:46,520 --> 01:05:51,980
オーバーフロー、ドットスラッシュを作ります
オーバーフロー、入力して、すべての権利、

1350
01:05:51,980 --> 01:05:53,090
それは最初に悪い見えます。

1351
01:05:53,090 --> 01:05:56,200
しかし、のが時間内に戻ってスクロールさせ、
私はこの64倍をしたので。

1352
01:05:56,200 --> 01:05:58,700
>> そして、初めて気づく、nは1です。

1353
01:05:58,700 --> 01:06:03,110
二度目は、nが、2であります
その後4、その後、8、次に16。

1354
01:06:03,110 --> 01:06:09,450
そして、それはできるだけ早くようです
私は、およそ10億を取得します

1355
01:06:09,450 --> 01:06:12,800
私は再びそれを倍にすると、その
私に20億を与える必要があります。

1356
01:06:12,800 --> 01:06:14,980
しかし、それは結局のところ、それはです
カスプ上の権利。

1357
01:06:14,980 --> 01:06:18,930
>> そしてそれは実際にオーバーフロー
10億からint型

1358
01:06:18,930 --> 01:06:23,514
2おおよそ負へ
億、整数ので、

1359
01:06:23,514 --> 01:06:25,430
数字の私たちとは異なり、
先週と仮定しました、

1360
01:06:25,430 --> 01:06:28,397
正と負の両方であることができます
現実には、コンピュータインチ

1361
01:06:28,397 --> 01:06:30,730
そして、それらのように、少なくとも1
ビットが効果的に盗まれました。

1362
01:06:30,730 --> 01:06:34,190
だから我々は本当に唯一の31ビットを持って、
または20億可能な値。

1363
01:06:34,190 --> 01:06:38,220
>> しかし、今のところ、お持ち帰りはかなりあります
単に、どのようなこれらの数字は、

1364
01:06:38,220 --> 01:06:42,280
そして、数学は、あるものは何でも
悪い何かが、最終的に起こります

1365
01:06:42,280 --> 01:06:46,980
最終的にはあなたがしようとしているため、
ビットを1何回も並べ替えます。

1366
01:06:46,980 --> 01:06:51,060
そして、あなたは効果的にすべてから行きます
1のに多分すべて0、または多分

1367
01:06:51,060 --> 01:06:54,260
そのそれだけで他のいくつかのパターン
明らかに、文脈に応じて、

1368
01:06:54,260 --> 01:06:56,342
負の数として解釈することができます。

1369
01:06:56,342 --> 01:06:59,300
そしてそれは、最高の私を思わ
この特定のプログラムで数えることができます

1370
01:06:59,300 --> 01:07:01,210
大まかにしか10億です。

1371
01:07:01,210 --> 01:07:02,760
しかし、ここでは部分的な解決策があります。

1372
01:07:02,760 --> 01:07:03,480
あのね？

1373
01:07:03,480 --> 01:07:07,600
>> 私はから変更してみましょう
長い長いのint型。

1374
01:07:07,600 --> 01:07:10,633
そして、私がここで先に行ってみましょう
そして、私が持っているつもりですsay--

1375
01:07:10,633 --> 01:07:12,290
unsigned long型に変更します。

1376
01:07:12,290 --> 01:07:16,860
それとも、私は自分自身を覚えたことがない、見てみましょう。

1377
01:07:16,860 --> 01:07:19,920
>> それでは、先に行くと、オーバーフローしてみましょう。

1378
01:07:19,920 --> 01:07:21,860
いいえ、それはできません、LLDは、ありがとうございました。

1379
01:07:21,860 --> 01:07:23,430
だから時々クランに役立ちます。

1380
01:07:23,430 --> 01:07:27,550
私はどのような形式を覚えていませんでした
指定子は、long long型のためでした。

1381
01:07:27,550 --> 01:07:28,950
>> しかし、確かに、クランは私に言いました。

1382
01:07:28,950 --> 01:07:31,570
グリーンは、良いのいくつかの種類であります
まだあなたがミスを犯したことを意味します。

1383
01:07:31,570 --> 01:07:33,190
私がLLDを意味していることを推測しています。

1384
01:07:33,190 --> 01:07:38,750
>> 限り、私はそれはアドバイスだてみましょう
長い進数は、それを保存します。

1385
01:07:38,750 --> 01:07:43,190
ドット、私はそれを再実行してみましょう
オーバーフローをスラッシュ、入力します。

1386
01:07:43,190 --> 01:07:45,020
そして今、どのようなクールなのはこれです。

1387
01:07:45,020 --> 01:07:49,140
>> 私が時間内に戻ってスクロールすると、我々はまだ開始します
同じplace--でカウント1、2、4、

1388
01:07:49,140 --> 01:07:50,220
8、16。

1389
01:07:50,220 --> 01:07:54,860
通知は、我々はすべての取得します
10億までの道。

1390
01:07:54,860 --> 01:07:57,070
しかし、その後、私たちは安全に20億に到達します。

1391
01:07:57,070 --> 01:08:01,300
>> その後、我々は40億に到達します、
その後、80億、170億。

1392
01:08:01,300 --> 01:08:03,340
そして、我々はより高い行くと、
高く、より高いです。

1393
01:08:03,340 --> 01:08:05,740
結局、この、あまりにも、休憩。

1394
01:08:05,740 --> 01:08:09,350
>> 結局、長い長いと、
64ビットの値ではなく、これは

1395
01:08:09,350 --> 01:08:13,660
あなたはカウント場合は32ビット値、
高すぎると、あなたは0を包み込みます。

1396
01:08:13,660 --> 01:08:16,410
そして、この場合には、我々が起こります
負の数で終わります。

1397
01:08:16,410 --> 01:08:17,550
>> これは問題があります。

1398
01:08:17,550 --> 01:08:20,439
そして、それは、このことが判明します
問題はすべてのこと難解ではありません。

1399
01:08:20,439 --> 01:08:23,060
私は意図的にしたにも関わらず、
これらのミスでそれを誘導し、

1400
01:08:23,060 --> 01:08:26,149
それは、我々はすべての種類のそれを見る判明します
私たちの私たちの周り、または少なくともいくつか行います。

1401
01:08:26,149 --> 01:08:28,939
>> レゴスターウォーズで、もしそうであれば
あなたは今までゲームをプレイしましたが、

1402
01:08:28,939 --> 01:08:33,830
それはあなたの周りに行くことができ判明します
LEGOの世界で物事を壊します、

1403
01:08:33,830 --> 01:08:36,640
本質的に、コインを集めます。

1404
01:08:36,640 --> 01:08:39,200
そして、あなたが今までプレイした場合
このゲームあまりにも多くの時間、

1405
01:08:39,200 --> 01:08:42,630
この無名の個人として
ここでは、総数をしました

1406
01:08:42,630 --> 01:08:46,700
あなたが収集することができコインの
それは、40億を思わ、です。

1407
01:08:46,700 --> 01:08:48,240
>> さて、それは実際に丸みを帯びていて。

1408
01:08:48,240 --> 01:08:50,239
だから、LEGOをしようとしていました
フレンドリーな物事のユーザーを保持します。

1409
01:08:50,239 --> 01:08:53,779
彼らはに正確に2をそれをしませんでした
先週あたり32電源、。

1410
01:08:53,779 --> 01:08:55,310
しかし、40億は理由があります。

1411
01:08:55,310 --> 01:08:58,979
それは、この情報に基づいて、と思われます、
そのLEGO、および会社

1412
01:08:58,979 --> 01:09:02,624
、この実際のソフトウェアを作ったことを決めました
そのコインの最大数

1413
01:09:02,624 --> 01:09:04,540
ユーザーが蓄積することができます
で、確かに、40億、

1414
01:09:04,540 --> 01:09:12,069
彼らは自分のコードで選択したので、
どうやら、長い長いませんを使用するには、

1415
01:09:12,069 --> 01:09:16,140
ちょうど整数、符号なし
整数、その​​唯一の正の整数、

1416
01:09:16,140 --> 01:09:18,089
最大値は、おおよそです。

1417
01:09:18,089 --> 01:09:19,380
さて、ここでもう一つの面白い一つです。

1418
01:09:19,380 --> 01:09:23,500
ゲーム文明におけるだから、どの
あなたのいくつかはと、見覚えがあるかもしれません

1419
01:09:23,500 --> 01:09:26,660
それは数年前にあっていることが判明します
このゲームができるのバグでした

1420
01:09:26,660 --> 01:09:28,750
あなたが役割を果たした場合
ガンジーのゲームで、

1421
01:09:28,750 --> 01:09:34,020
代わりに、彼は非常に平和であることの、
代わりに、信じられないほど、信じられないほどでした

1422
01:09:34,020 --> 01:09:36,399
いくつかの状況で、積極的な。

1423
01:09:36,399 --> 01:09:40,529
具体的には、方法その文明
作品であれば、あなた、プレイヤーということです、

1424
01:09:40,529 --> 01:09:44,680
民主主義を採用し、あなたの
攻撃性スコアが取得します

1425
01:09:44,680 --> 01:09:48,130
2ので、マイナスデクリメント
マイナス、その後マイナスマイナス。

1426
01:09:48,130 --> 01:09:50,569
>> だから、から2を引きます
あなたの実際の反復。

1427
01:09:50,569 --> 01:09:56,650
残念ながら、あなたの反復がある場合
最初は1、あなたはそれから2を引きます

1428
01:09:56,650 --> 01:09:59,050
民主主義を採用した後、
ここかもしれないガンジーなど

1429
01:09:59,050 --> 01:10:02,200
彼は非常にpassive--だったので、行ってきました
攻撃性のスケールで1。

1430
01:10:02,200 --> 01:10:04,830
しかし、彼はその後、民主主義を採用している場合
彼は1から負の1に行きます。

1431
01:10:04,830 --> 01:10:11,470
>> 残念ながら、それらはありました
符号なしの数字を使用して、

1432
01:10:11,470 --> 01:10:15,400
それらがあっても負扱わ意味
数字彼らが陽性であったかのように。

1433
01:10:15,400 --> 01:10:19,780
そして、それはことが判明
1負の正同等、

1434
01:10:19,780 --> 01:10:23,480
典型的なコンピュータプログラムにおいて、255です。

1435
01:10:23,480 --> 01:10:27,250
ガンジーが採用しているのであれば
民主主義、したがってました

1436
01:10:27,250 --> 01:10:32,470
彼の攻撃性のスコアが減少し、
それは実際に255に周りロール

1437
01:10:32,470 --> 01:10:35,470
彼最大限に活用
ゲームで攻撃的な性格。

1438
01:10:35,470 --> 01:10:36,930
ですから、この上にGoogleにすることができます。

1439
01:10:36,930 --> 01:10:39,380
そしてそれは、確かに、でした
不慮のプログラミングのバグ、

1440
01:10:39,380 --> 01:10:43,010
それはかなり入っています
以来伝承。

1441
01:10:43,010 --> 01:10:44,360
>> つまり、すべての楽しさとかわいいです。

1442
01:10:44,360 --> 01:10:47,760
ときに、実際もっと恐ろしいです
現実世界のデバイスではなく、ゲーム、

1443
01:10:47,760 --> 01:10:48,820
これらの同じバグを持っています。

1444
01:10:48,820 --> 01:10:54,500
実際には、ちょうど1年前の記事が来ました
ボーイング787についてアウト。

1445
01:10:54,500 --> 01:10:56,850
>> そして、最初に記事
一見は少し難解を読み込みます。

1446
01:10:56,850 --> 01:11:01,480
しかし、それは言った、この、ソフトウェア
ボーイング社の脆弱性

1447
01:11:01,480 --> 01:11:04,790
新しい787ドリームライナージェット持ちます
パイロットを引き起こす可能性

1448
01:11:04,790 --> 01:11:07,220
のコントロールを失います
おそらく航空機、

1449
01:11:07,220 --> 01:11:11,750
半ば飛行中、FAAの職員
最近の航空会社に警告しました。

1450
01:11:11,750 --> 01:11:14,520
それは決意しました
そのモデル787

1451
01:11:14,520 --> 01:11:19,770
電源が入ってきた飛行機
連続248日間

1452
01:11:19,770 --> 01:11:24,880
すべての交流、交流を失うことができます、
発電機による電力

1453
01:11:24,880 --> 01:11:28,892
同時に制御ユニット、GCUs、
フェイルセーフモードに入ります。

1454
01:11:28,892 --> 01:11:29,850
それは私を失うようなものです。

1455
01:11:29,850 --> 01:11:35,390
しかし述べたメモは、[OK]を、今私はそれを持って、
条件は、ソフトウェアによって引き起こされました

1456
01:11:35,390 --> 01:11:38,590
にカウンタ内部
発電機制御

1457
01:11:38,590 --> 01:11:44,860
後にオーバーフローするユニット
連続電力の248日間。

1458
01:11:44,860 --> 01:11:47,070
私たちは、これを発行しています
損失を防ぐために通知

1459
01:11:47,070 --> 01:11:49,300
すべてのAC電気の
つながる可能性があり、電力、

1460
01:11:49,300 --> 01:11:50,980
飛行機の制御の喪失インチ

1461
01:11:50,980 --> 01:11:55,380
>> だから、文字通り、いくつかの整数であり、
またはいくつかの同等のデータ型

1462
01:11:55,380 --> 01:11:57,960
ソフトウェアで使用されています
実際の飛行機の中で

1463
01:11:57,960 --> 01:12:00,756
あなたの飛行機を保つ場合に
これは明らかに、十分な長さに

1464
01:12:00,756 --> 01:12:03,880
あなただけ実行している場合場合することができます
彼らは常に、決して抜きます

1465
01:12:03,880 --> 01:12:06,810
あなたの飛行機は、それが思われる、または
そのバッテリーが死ぬせ、

1466
01:12:06,810 --> 01:12:09,840
最終的にはアップカウントアップ、となります、
そして、アップし、アップ、最大、およびアップ。

1467
01:12:09,840 --> 01:12:12,150
>> そして、本質的に、A
メモリの有限量

1468
01:12:12,150 --> 01:12:15,880
、オーバーフローにロールバックされます
ゼロまたはいくつかの負の値、

1469
01:12:15,880 --> 01:12:19,920
副作用があります
驚くほど本物の現実

1470
01:12:19,920 --> 01:12:23,970
飛行機が必要になる場合がありますことを
効果的に、再起動します、

1471
01:12:23,970 --> 01:12:27,290
それが飛ぶように、または落ちるかもしれないが、悪化。

1472
01:12:27,290 --> 01:12:29,230
問題のため、これらの種類
私たちと一緒に残っています、

1473
01:12:29,230 --> 01:12:33,130
even--これは、2015年の記事でした
すべてもっと恐ろしいです

1474
01:12:33,130 --> 01:12:36,100
あなたは必ずしもないとき
、理解に感謝、または予想

1475
01:12:36,100 --> 01:12:38,640
エラーのそれらの種類。

1476
01:12:38,640 --> 01:12:42,030
>> だから、他の1があると判明します
データ表現についての悪い事。

1477
01:12:42,030 --> 01:12:47,080
それも、浮動小数点数であることが判明します
種類の欠陥のある、フロートので、あまりにも、

1478
01:12:47,080 --> 01:12:51,440
私は32ビットで提案された、または
多分64あなたは二重を使用している場合。

1479
01:12:51,440 --> 01:12:53,070
しかし、それはまだ有限です。

1480
01:12:53,070 --> 01:12:57,070
>> そして、キャッチは、あなたができればということです
数字の無限の数を置きます

1481
01:12:57,070 --> 01:12:59,460
小数点以下、
ない方法はありません

1482
01:12:59,460 --> 01:13:02,690
すべての可能を表すことができます
私たちが教えられた番号

1483
01:13:02,690 --> 01:13:04,990
小学校で世界に存在することができます。

1484
01:13:04,990 --> 01:13:08,870
コンピュータは、本質的に有しています
これらの数字のサブセットを選択します

1485
01:13:08,870 --> 01:13:10,200
正確に表現します。

1486
01:13:10,200 --> 01:13:12,450
>> 今、コンピュータができます
ラウンド多分少し、

1487
01:13:12,450 --> 01:13:17,900
あなたはおおよそストアに許可することができます
あなたはおそらく場合があります任意の数。

1488
01:13:17,900 --> 01:13:20,940
しかし、単に直感的に、あなたの場合
ビットの有限数を有し、

1489
01:13:20,940 --> 01:13:24,560
あなただけそれらを並べ替えることができます
非常に多くの有限な方法インチ

1490
01:13:24,560 --> 01:13:26,570
だから、おそらくできません
有限数を使用します

1491
01:13:26,570 --> 01:13:29,880
ビットの順列の、
0と1のパターン、

1492
01:13:29,880 --> 01:13:32,940
無限を表現します
番号の数、

1493
01:13:32,940 --> 01:13:37,370
どのコンピュータがかもしれないことを示唆しています
非常によく、時々私たちにうそになります。

1494
01:13:37,370 --> 01:13:38,770
>> 実際には、はこのやろう。

1495
01:13:38,770 --> 01:13:41,239
私はCS50のIDEに戻りましょう。

1496
01:13:41,239 --> 01:13:43,030
私は先に行ってみようと
小さなプログラムを作成

1497
01:13:43,030 --> 01:13:47,940
ことを示すために、不正確と呼ばれます
コンピュータは、確かに、不正確です。

1498
01:13:47,940 --> 01:13:51,910
>> そして、私が先に行くと、始めましょう
前からそのコードの一部、

1499
01:13:51,910 --> 01:13:53,830
そして今ちょうど次の操作を行います。

1500
01:13:53,830 --> 01:14:03,640
私が先に行くとprintfのをやってみましょう、パーセント
F、バックスラッシュnは、10で割った1。

1501
01:14:03,640 --> 01:14:07,430
言い換えれば、のは、深くにダイブしましょう
1と10で割ったような、1月10日まで。

1502
01:14:07,430 --> 01:14:09,760
確かに、コンピュータは1月10日を表すことができます。

1503
01:14:09,760 --> 01:14:13,620
>> それでは、先に行くと不正確さを作ってみましょう。

1504
01:14:13,620 --> 01:14:14,390
どれどれ。

1505
01:14:14,390 --> 01:14:16,210
形式は、double型を指定します。

1506
01:14:16,210 --> 01:14:18,160
しかし、引数はint型を持っています。

1507
01:14:18,160 --> 01:14:19,040
どうしたの？

1508
01:14:19,040 --> 01:14:21,970
>> ああ、面白いので、それはです
レッスンでは、前から学びました。

1509
01:14:21,970 --> 01:14:26,050
私はちょっと、コンピュータショー、言っています
私パーセントfのフロート。

1510
01:14:26,050 --> 01:14:28,200
しかし、私はそれを2 int型を与えています。

1511
01:14:28,200 --> 01:14:31,120
だから結局、私が修正することができます
いくつかの方法でこの。

1512
01:14:31,120 --> 01:14:38,430
>> 私はちょうど1.0に1を回すことができる、と
10.0に10、これだろう、確かに、

1513
01:14:38,430 --> 01:14:42,390
変換の効果を有します
それらflo​​ats--にまだうまくいけば

1514
01:14:42,390 --> 01:14:43,180
同じ番号。

1515
01:14:43,180 --> 01:14:45,880
それとも、何かがありますが判明します
私たちは、長い前に再度表示されます。

1516
01:14:45,880 --> 01:14:47,170
あなたは数字を唱えられます。

1517
01:14:47,170 --> 01:14:49,880
>> あなたは、この括弧内のを使用することができます
式は、あなたが言うことができます、

1518
01:14:49,880 --> 01:14:52,560
ちょっと、コンピュータは、これを取ります
私が知っている10は、intです。

1519
01:14:52,560 --> 01:14:54,660
しかし、それをしてください、治療、
ているかのようにそれがフロートです。

1520
01:14:54,660 --> 01:14:56,680
しかし、これは不必要に複雑に感じています。

1521
01:14:56,680 --> 01:14:59,040
>> 私たちの目的のために、今日、
文字通りみましょう

1522
01:14:59,040 --> 01:15:02,700
それらは、浮動小数点値を作ります
このような小数点を持ちます。

1523
01:15:02,700 --> 01:15:07,060
私が先に行くと再実行してみましょう、作ります
不正確、良い、ドットスラッシュ

1524
01:15:07,060 --> 01:15:08,870
不正確、入力します。

1525
01:15:08,870 --> 01:15:10,990
[OK]を、我々は良い探しています。

1526
01:15:10,990 --> 01:15:18,194
>> 1は私によると、10で割った値
ここではMacが、確かに、0.100000です。

1527
01:15:18,194 --> 01:15:21,360
今、私はそこに小学校で教えられました
0の無限の数でなければなりません。

1528
01:15:21,360 --> 01:15:23,151
それでは、少なくとも試してみましょう
それらのいくつかを確認します。

1529
01:15:23,151 --> 01:15:26,770
これは、printfのが少しあることが判明します
手の込んだ、まだ私たちが使用してきたよりも。

1530
01:15:26,770 --> 01:15:30,890
それはあなたが指定する必要はありませんが判明します
ちょうど％のF、または単にパーセントの私。

1531
01:15:30,890 --> 01:15:33,830
あなたが実際に指定することができます
ここにいくつかのコントロールオプション。

1532
01:15:33,830 --> 01:15:36,470
>> 具体的には、私が行きますよ
言って、ちょっと、printf関数、

1533
01:15:36,470 --> 01:15:39,660
実際に私に10小数点を示します。

1534
01:15:39,660 --> 01:15:40,820
だから、それは少し奇妙に見えます。

1535
01:15:40,820 --> 01:15:42,845
しかし、あなたはパーセントを言います、
ドット、どのように多くの数字

1536
01:15:42,845 --> 01:15:44,970
あなたは後に見たいです
その後、小数点、およびf

1537
01:15:44,970 --> 01:15:48,340
フラットのために、それはちょうどので、
ドキュメントは言います。

1538
01:15:48,340 --> 01:15:50,080
私が先に行くとそれを保存してみましょう。

1539
01:15:50,080 --> 01:15:52,460
>> そして、あまりにも気づく私が取得しています
物事を再入力するのに疲れ。

1540
01:15:52,460 --> 01:15:55,900
だから、僕はアップの設定だし、
ダウンここに私のキーに矢印。

1541
01:15:55,900 --> 01:15:58,710
そして、私は、あなたを打つ続ければ
コマンドのすべてを見ることができます

1542
01:15:58,710 --> 01:16:01,090
私が作った、または正しく行われています。

1543
01:16:01,090 --> 01:16:04,630
>> そして、私は今、先に行くつもりだし、
実際に明らかに、それを使用しません。

1544
01:16:04,630 --> 01:16:11,416
不正確、ドットを作ります
そうimprecision--スラッシュ

1545
01:16:11,416 --> 01:16:13,290
私はで教えられました
小学校は、チェックアウトされます。

1546
01:16:13,290 --> 01:16:19,010
私は、10進にそれを印刷する場合でも、
場所それは、確かに、0.10000です。

1547
01:16:19,010 --> 01:16:19,840
しかし、あなたは何を知っていますか？

1548
01:16:19,840 --> 01:16:21,150
>> のは少し貪欲取得してみましょう。

1549
01:16:21,150 --> 01:16:23,990
私は55を示し、のように、言ってみましょう
小数点以下のポイント。

1550
01:16:23,990 --> 01:16:26,160
それでは、実際にこれを見てみましょう
スピンのためのプログラムアウト。

1551
01:16:26,160 --> 01:16:31,170
私はメイクでそれをリメイクしてみましょう
不正確、ドットスラッシュ、不正確。

1552
01:16:31,170 --> 01:16:32,390
>> さあ、いくぞ。

1553
01:16:32,390 --> 01:16:34,420
あなたの子供の頃は嘘でした。

1554
01:16:34,420 --> 01:16:48,410
どうやら、10で割った1は確かにありま​​す
0.100000000000000005551115123--

1555
01:16:48,410 --> 01:16:49,740
>> 何が起こっている？

1556
01:16:49,740 --> 01:16:53,360
あなたの種類の場合まあ、それは、判明します
根底にある外に十分に見えます

1557
01:16:53,360 --> 01:16:55,950
この表現
数、それ実際に

1558
01:16:55,950 --> 01:17:00,400
正確に1/10、または0.1ではなく、
ゼロの無限数。

1559
01:17:00,400 --> 01:17:01,630
さて、それはなぜですか？

1560
01:17:01,630 --> 01:17:06,250
>> まあ、これは単純であるにもかかわらず、
私たち人間の数は、図1に示すように、10で除します

1561
01:17:06,250 --> 01:17:10,910
それはまだ無限に多くの一つです
私たちが考え出すことができ数字。

1562
01:17:10,910 --> 01:17:14,490
しかし、コンピュータは表すことができます
有限個のように数字。

1563
01:17:14,490 --> 01:17:18,710
だから、効果的に、どのような
コンピュータは、私たちは、その最も近い表示されています

1564
01:17:18,710 --> 01:17:22,940
数への近似
私たちは、1月10日であると信じたいです

1565
01:17:22,940 --> 01:17:27,760
または本当に0.10000際限。

1566
01:17:27,760 --> 01:17:30,425
>> そうではなく、しかし、これは
それが得ることができるように近いです。

1567
01:17:30,425 --> 01:17:32,300
そして、確かに、あなたが見てみると
ボンネットの下に、

1568
01:17:32,300 --> 01:17:37,050
我々は見ることによって、ここにあるように
小数点以下55桁、

1569
01:17:37,050 --> 01:17:39,990
私たちは、実際にその現実を参照してください。

1570
01:17:39,990 --> 01:17:42,610
さて余談として、あなたがしている場合
今までmovie--を見ました

1571
01:17:42,610 --> 01:17:45,780
あなたのほとんどは、おそらくhaven't--
しかし、スーパーマン3何年か前に、

1572
01:17:45,780 --> 01:17:49,500
リチャード・プライヤーは、基本的にこれを活用します
多くを盗むために彼の会社で現実

1573
01:17:49,500 --> 01:17:53,500
ペニーの分画と画分の、
私が思い出すようcompany--ので、

1574
01:17:53,500 --> 01:17:57,210
それは本質的だったwhile--されています
合わないものを捨てます

1575
01:17:57,210 --> 01:17:58,790
セントの概念に。

1576
01:17:58,790 --> 01:18:01,480
>> しかし、あなたは、これらすべてのを追加した場合
再び小さな、小さな、小さな数字、

1577
01:18:01,480 --> 01:18:04,960
そして再び、そして再び、あなたはのように、することができます
彼の場合は、お金の良い量を作ります。

1578
01:18:04,960 --> 01:18:08,010
>> 同様の考え方は、以下によって食い物にされたこと
より最近、それでも今、古いです

1579
01:18:08,010 --> 01:18:10,500
オフィススペースと呼ばれる映画、
ここで、その映画の中の男、

1580
01:18:10,500 --> 01:18:13,501
それを台無しに、同じ事をしました
完全に、あまりにも多くの方法になってしまいました

1581
01:18:13,501 --> 01:18:14,666
自分の銀行口座にお金。

1582
01:18:14,666 --> 01:18:15,800
それはすべての非常に疑わしいでした。

1583
01:18:15,800 --> 01:18:19,290
しかし、一日の終わりに、
不正確さが私たちの周りのすべてです。

1584
01:18:19,290 --> 01:18:22,240
>> あまりにも、それは、とすることができます
ケースを驚くほど。

1585
01:18:22,240 --> 01:18:25,590
それが判明しているスーパーマン3
そこ脇やオフィススペース、

1586
01:18:25,590 --> 01:18:28,460
いくつかの非常に現実をすることができます
世界の波及効果

1587
01:18:28,460 --> 01:18:32,290
不正確なの現実の
データの表現

1588
01:18:32,290 --> 01:18:34,770
それさえも私たち人間に
この日は、必ずしもん

1589
01:18:34,770 --> 01:18:38,230
同様に、我々がすべきのように理解し、
またはとして頻繁に私達がすべきのように覚えています。

1590
01:18:38,230 --> 01:18:42,950
そして、確かに、以下のクリップがあります
いくつかの非常に現実の世界を見てから

1591
01:18:42,950 --> 01:18:47,730
あなたならば何が起こるかの影響
その不正確さを理解していません

1592
01:18:47,730 --> 01:18:50,065
数値表現で発生する可能性があります。

1593
01:18:50,065 --> 01:18:51,300
>> [ビデオ再生]

1594
01:18:51,300 --> 01:18:55,620
>> -Computers、我々はすべて受け入れるようになってきました
多くの場合、イライラの問題という

1595
01:18:55,620 --> 01:19:00,310
them--バグ、ウイルスに行きます、
およびソフトウェアの不具合、

1596
01:19:00,310 --> 01:19:03,130
小さな価格が支払うために
利便性のために。

1597
01:19:03,130 --> 01:19:07,800
しかし、ハイテク、高速で
軍事や宇宙プログラムアプリケーション、

1598
01:19:07,800 --> 01:19:12,800
最小の問題ことができます
災​​害に拡大します。

1599
01:19:12,800 --> 01:19:18,900
>> 6月4日、1996年には、科学者たちは準備します
無人アリアン5ロケットを起動します。

1600
01:19:18,900 --> 01:19:21,220
それは科学的運んでいました
衛星設計

1601
01:19:21,220 --> 01:19:24,600
正確にどのように確立します
地球磁場の相互作用

1602
01:19:24,600 --> 01:19:27,410
太陽風と。

1603
01:19:27,410 --> 01:19:30,800
ロケットがために建てられました
欧州宇宙機関、

1604
01:19:30,800 --> 01:19:34,370
その施設からリフトオフ
フランス領ギアナの海岸に。

1605
01:19:34,370 --> 01:19:37,540
>> 約37秒-atへ
飛行、まず彼ら

1606
01:19:37,540 --> 01:19:39,270
何かが間違っているのに気づきました。

1607
01:19:39,270 --> 01:19:42,250
ノズルは、中に旋回しました。
方法彼らは本当にいけません。

1608
01:19:42,250 --> 01:19:46,580
飛行中に40秒付近、
明らかに、車両がトラブルにありました。

1609
01:19:46,580 --> 01:19:48,850
>> 彼らが作ったとき、それはです
それを破壊することを決定。

1610
01:19:48,850 --> 01:19:52,780
と範囲の安全管理者、
驚異的な根性は、ボタンを押し、

1611
01:19:52,780 --> 01:19:58,150
それができたの前に、ロケットを爆破しました
公共の安全に危険になります。

1612
01:19:58,150 --> 01:20:01,060
>>  - これは処女でした
アリアン5の航海。

1613
01:20:01,060 --> 01:20:03,960
そして、その破壊がかかりました
なぜなら傷の場所

1614
01:20:03,960 --> 01:20:05,822
ロケットのソフトウェアに組み込まれて。

1615
01:20:05,822 --> 01:20:08,280
アリアン上-The問題がありました
その数があったこと

1616
01:20:08,280 --> 01:20:10,600
表現するために64ビットを必要としました。

1617
01:20:10,600 --> 01:20:13,590
そして、彼らは変換したかったです
その16ビットの数値です。

1618
01:20:13,590 --> 01:20:15,610
彼らは、と仮定しました
番号は行くことはありませんでした

1619
01:20:15,610 --> 01:20:20,980
それらのほとんどのことは、非常に大きなものとします
64ビットの数値の桁はゼロでした。

1620
01:20:20,980 --> 01:20:22,440
彼らは間違っていました。

1621
01:20:22,440 --> 01:20:25,060
>> 1の-Theできません
受け入れるためのソフトウェアプログラム

1622
01:20:25,060 --> 01:20:29,510
によって生成された番号の種類
他には、障害の根本にありました。

1623
01:20:29,510 --> 01:20:34,350
ソフトウェア開発はなっていました
新技術の非常に高価な部分。

1624
01:20:34,350 --> 01:20:38,140
アリアンロケットは非常にされています
ソフトウェアの成功、そんなに

1625
01:20:38,140 --> 01:20:41,550
それもあったために作成さ
アリアン5で使用されます。

1626
01:20:41,550 --> 01:20:47,940
>> -The基本的な問題はアリアンということでした
図5は、速かったより速く加速しました。

1627
01:20:47,940 --> 01:20:51,450
そして、ソフトウェアはいませんでした
そのために占めています。

1628
01:20:51,450 --> 01:20:55,060
>> ロケットの-The破壊
巨大な金融災害でした、

1629
01:20:55,060 --> 01:20:58,790
微小なソフトウェアエラーに起因するすべて。

1630
01:20:58,790 --> 01:21:01,210
しかし、これは初めてではなかったです
時間データ変換の問題

1631
01:21:01,210 --> 01:21:04,820
現代のロケット技術を悩ませていました。

1632
01:21:04,820 --> 01:21:08,050
>> 開始と、1991 -in
第一次湾岸戦争の、

1633
01:21:08,050 --> 01:21:10,570
パトリオットミサイル
同様の種類を経験しました

1634
01:21:10,570 --> 01:21:12,800
番号変換の問題。

1635
01:21:12,800 --> 01:21:16,090
その結果、28人、
28アメリカ兵、

1636
01:21:16,090 --> 01:21:19,080
殺され、約ました
100他の人が負傷し、

1637
01:21:19,080 --> 01:21:22,780
ときになっていたパトリオット、
着信scudsから保護するために、

1638
01:21:22,780 --> 01:21:25,830
ミサイルを発射することができませんでした。

1639
01:21:25,830 --> 01:21:31,670
>> -Whenイラクはクウェート、そしてアメリカを侵略しました
初期の1991年に砂漠の嵐を立ち上げ、

1640
01:21:31,670 --> 01:21:35,780
パトリオットミサイルの電池が配備されました
サウジアラビアとイスラエルを守るために

1641
01:21:35,780 --> 01:21:39,230
イラクのスカッドミサイル攻撃から。

1642
01:21:39,230 --> 01:21:43,810
パトリオットは、米国の中​​距離であります
空気システムに面、製造

1643
01:21:43,810 --> 01:21:45,770
レイセオン社によります。

1644
01:21:45,770 --> 01:21:52,340
>> パトリオット迎撃の-Theサイズ
自身についてのおおよそ20フィートの長さです。

1645
01:21:52,340 --> 01:21:55,230
そして、それは、約2000ポンドの重さ。

1646
01:21:55,230 --> 01:21:59,320
そしてそれは、程度の弾頭を運びます
私はそれが約150ポンドだと思います。

1647
01:21:59,320 --> 01:22:03,930
そして弾頭自体はあります
高性能爆薬、その

1648
01:22:03,930 --> 01:22:07,330
その周りの断片を持っています。

1649
01:22:07,330 --> 01:22:11,680
弾頭の筐体であります
散弾のよ​​うに行動するように設計されています。

1650
01:22:11,680 --> 01:22:14,110
>> -Theミサイルを搭載しています
コンテナあたり4、

1651
01:22:14,110 --> 01:22:17,130
そして、セミトレーラーによって輸送されます。

1652
01:22:17,130 --> 01:22:24,930
>> -Theパトリオット対ミサイルシステム
今、少なくとも20年以上さかのぼります。

1653
01:22:24,930 --> 01:22:28,420
これはもともと設計されました
防空ミサイルなど

1654
01:22:28,420 --> 01:22:30,720
敵の飛行機を撃墜します。

1655
01:22:30,720 --> 01:22:34,500
第一次湾岸戦争では、
その戦争が一緒に来たときに、

1656
01:22:34,500 --> 01:22:39,745
陸軍はそれを使用したいです
scuds、ない飛行機を撃墜。

1657
01:22:39,745 --> 01:22:43,620
>> イラク空軍がありました
問題のあまりありません。

1658
01:22:43,620 --> 01:22:46,670
しかし、陸軍はscuds心配していました。

1659
01:22:46,670 --> 01:22:50,170
それで、彼らがしようとしました
パトリオットをアップグレードします。

1660
01:22:50,170 --> 01:22:52,800
>> 敵を-Intercepting
マッハ5で走行ミサイル

1661
01:22:52,800 --> 01:22:55,830
十分に挑戦するつもりでした。

1662
01:22:55,830 --> 01:22:58,490
しかし、時パトリオット
サービスに突入して、

1663
01:22:58,490 --> 01:23:02,860
陸軍は知りませんでした
作られたイラクの変更

1664
01:23:02,860 --> 01:23:05,930
そのscudsヒットすることはほぼ不可能。

1665
01:23:05,930 --> 01:23:10,740
>>  - 何が起こったことはscudsであります
不安定であったで来ていました。

1666
01:23:10,740 --> 01:23:11,692
彼らはゆらゆらました。

1667
01:23:11,692 --> 01:23:14,910
この理由はありました
イラク人、順番に

1668
01:23:14,910 --> 01:23:18,280
600キロを取得します
300キロのうち

1669
01:23:18,280 --> 01:23:21,700
ミサイル、重量を取りました
フロント弾頭のうち。

1670
01:23:21,700 --> 01:23:23,390
彼らは、弾頭を軽量化。

1671
01:23:23,390 --> 01:23:27,330
>> だから今パトリオットです
スカッドに来るしようとしています。

1672
01:23:27,330 --> 01:23:30,230
そして、ほとんどの時間、
時間の圧倒的多数、

1673
01:23:30,230 --> 01:23:32,940
それだけでスカッドによって飛んでいくのです。

1674
01:23:32,940 --> 01:23:37,260
パトリオットシステム・オペレータに一度
パトリオットは、その目標を逃した実現し、

1675
01:23:37,260 --> 01:23:41,690
彼らは、パトリオットの弾頭を起爆
それならば可能な死傷者を避けるために、

1676
01:23:41,690 --> 01:23:44,570
地面に落下させました。

1677
01:23:44,570 --> 01:23:48,790
>>  - つまりは、ほとんどの人が見たものでした
空にはそれらの大きい火の玉、

1678
01:23:48,790 --> 01:23:54,550
とと誤解
スカッド弾頭のインターセプト。

1679
01:23:54,550 --> 01:23:56,630
>> 夜に-Although
空、ペイトリオッツが登場しました

1680
01:23:56,630 --> 01:24:00,370
成功したことにします
ダーランで、Scudsを破壊し、

1681
01:24:00,370 --> 01:24:03,360
間違いがありませんでした
その性能について。

1682
01:24:03,360 --> 01:24:07,970
そこでは、パトリオットのレーダーシステム
着信スカッドのトラックを失いました、

1683
01:24:07,970 --> 01:24:10,721
そして、により発足することはありません
ソフトウェアの欠陥に。

1684
01:24:10,721 --> 01:24:14,090

1685
01:24:14,090 --> 01:24:18,940
これは、最初に発見イスラエル人でした
長いシステムが上であったこと、

1686
01:24:18,940 --> 01:24:22,690
長い時間の不一致
、埋め込まれたクロックに起因になりました

1687
01:24:22,690 --> 01:24:24,810
システムのコンピュータインチ

1688
01:24:24,810 --> 01:24:28,210
>> -About 2週間前
ダーランで悲劇、

1689
01:24:28,210 --> 01:24:30,770
イスラエルはに報告しました
国防総省

1690
01:24:30,770 --> 01:24:32,590
システムは時間を失っていたこと。

1691
01:24:32,590 --> 01:24:35,360
約8時間後、または実行されています、
彼らは、システムということに気づきました

1692
01:24:35,360 --> 01:24:37,720
著しく少ない正確​​になっていました。

1693
01:24:37,720 --> 01:24:41,900
国防総省は、によって答え
パトリオット電池のすべてを伝えます

1694
01:24:41,900 --> 01:24:44,950
システムのままにしないように
長い時間のために。

1695
01:24:44,950 --> 01:24:49,160
彼らはどのような長い時間言ったことはありませんwas--
八時間、10時間、1000時間。

1696
01:24:49,160 --> 01:24:51,360
誰も知りませんでした。

1697
01:24:51,360 --> 01:24:53,380
>> -Theパトリオットバッテリー
兵舎に駐屯

1698
01:24:53,380 --> 01:24:58,350
ダーランとその欠陥のある内部に
クロックは100時間以上でした

1699
01:24:58,350 --> 01:25:01,670
2月25日の夜に。

1700
01:25:01,670 --> 01:25:05,917
>>  - それは正確さに時間を追跡しました
10分の1秒程度。

1701
01:25:05,917 --> 01:25:08,000
第二の今、第十
興味深いの数であり、

1702
01:25:08,000 --> 01:25:11,920
それは表現できないので、
バイナリで正確に、どの

1703
01:25:11,920 --> 01:25:16,820
それは正確に表現できないことを意味
任意の現代のデジタルコンピュータインチ

1704
01:25:16,820 --> 01:25:18,540
それは信じがたいです。

1705
01:25:18,540 --> 01:25:21,210
>> しかし、一例として、これを使用しています。

1706
01:25:21,210 --> 01:25:23,540
番号三分の一を見てみましょう。

1707
01:25:23,540 --> 01:25:27,350
三分の一にすることはできません
正確に小数で表しました。

1708
01:25:27,350 --> 01:25:32,080
三分の一は0.333であり、
無限大のために起こっています。

1709
01:25:32,080 --> 01:25:36,480
>> でそれをする方法はありません
小数で絶対精度。

1710
01:25:36,480 --> 01:25:39,560
それはまさに問題のようなものです
それは愛国者で起こりました。

1711
01:25:39,560 --> 01:25:44,100
システムは、走った長いです
悪化時エラーになりました。

1712
01:25:44,100 --> 01:25:48,890
>> 操作の100時間、-after
時間の誤差はわずか約三分の一でした

1713
01:25:48,890 --> 01:25:50,600
第二の。

1714
01:25:50,600 --> 01:25:54,210
しかし、ターゲットとの観点から
ミサイルマッハ5で走行し、

1715
01:25:54,210 --> 01:25:58,710
それは追跡をもたらしました
600メートル以上のエラー。

1716
01:25:58,710 --> 01:26:02,120
それは致命的なエラーになります
何の上の兵士のため

1717
01:26:02,120 --> 01:26:08,940
起こったスカッド発射です
早期警戒衛星が検出さ

1718
01:26:08,940 --> 01:26:12,860
彼らはスカッドがあったことを知っていました
彼らの一般的な方向に来ます。

1719
01:26:12,860 --> 01:26:15,320
それは来ていたどこに彼らは知りませんでした。

1720
01:26:15,320 --> 01:26:18,250
>>  - それは、レーダーまでになりました
パトリオットシステムの構成要素

1721
01:26:18,250 --> 01:26:23,190
見つけて保つためにダーランを擁護
着信敵のミサイルの軌道。

1722
01:26:23,190 --> 01:26:24,609
>> -Theレーダーは非常にスマートでした。

1723
01:26:24,609 --> 01:26:26,650
これは、実際に追跡するだろう
スカッドの位置、

1724
01:26:26,650 --> 01:26:30,350
そして、次にどこおそらくそれを予測
レーダーが送信され、次回になります

1725
01:26:30,350 --> 01:26:31,420
パルス出力。

1726
01:26:31,420 --> 01:26:33,110
それはレンジゲートと呼ばれていました。

1727
01:26:33,110 --> 01:26:37,660
>> パトリオット一度-Then、
十分な時間をしていることを決定

1728
01:26:37,660 --> 01:26:42,450
戻って、次を確認するために渡されます
この検出された物体の位置、

1729
01:26:42,450 --> 01:26:43,600
それが戻って行きます。

1730
01:26:43,600 --> 01:26:48,650
だから、間違ったに戻ったとき、
場所は、それが次に何のオブジェクトを見ません。

1731
01:26:48,650 --> 01:26:52,160
そして、それはありませんがあったと判断しました
オブジェクト、それが誤検出でした、

1732
01:26:52,160 --> 01:26:53,930
トラックを削除します。

1733
01:26:53,930 --> 01:26:57,030
>> -The着信スカッドは姿を消しました
レーダー画面から。

1734
01:26:57,030 --> 01:27:00,260
そして秒後、それを
兵舎に激突。

1735
01:27:00,260 --> 01:27:06,150
スカッドは28を殺し、そして最後でした
1は、第一次湾岸戦争中に発射しました。

1736
01:27:06,150 --> 01:27:11,960
>> 悲劇的に、更新されたソフトウェア
翌日ダーランに到着しました。

1737
01:27:11,960 --> 01:27:14,930
ソフトウェアの欠陥がありました
、閉鎖を修正されて

1738
01:27:14,930 --> 01:27:19,806
問題を抱えた中1章
パトリオットミサイルの歴史。

1739
01:27:19,806 --> 01:27:20,729
>> [ビデオ再生]

1740
01:27:20,729 --> 01:27:23,520
DAVID J.マラン：これはすべてにあります
オーバーフローの、これらの問題と言います

1741
01:27:23,520 --> 01:27:25,860
そして、不正確さがあまりにも本物です。

1742
01:27:25,860 --> 01:27:26,920
だから、どのように我々はここに来たのですか？

1743
01:27:26,920 --> 01:27:28,895
私達はちょうどのprintfの話から始まりました。

1744
01:27:28,895 --> 01:27:31,270
ここでも、この関数こと
画面に何かを印刷し、

1745
01:27:31,270 --> 01:27:33,450
私たちは、その後、導入しました
他のいくつかの機能

1746
01:27:33,450 --> 01:27:34,945
いわゆるCS50のライブラリから。

1747
01:27:34,945 --> 01:27:36,910
そして、我々は、に進みます
期限内にこれらを参照してください。

1748
01:27:36,910 --> 01:27:40,760
そして、我々は、特に、GET文字列を使用し、
そして、、int型を取得し、今もフロートを取得

1749
01:27:40,760 --> 01:27:44,410
そして、まだ他の人はまだ我々が発生します
やがて自分自身を使用します。

1750
01:27:44,410 --> 01:27:47,220
>> しかし機会に、持っています
我々はすでに必要性を見て

1751
01:27:47,220 --> 01:27:50,520
これらの機能が戻って手何を格納するには？

1752
01:27:50,520 --> 01:27:52,920
彼らは私たちのバック文字列を渡し、
またはint型、またはフロート。

1753
01:27:52,920 --> 01:27:56,070
そして、時には我々はそれを配置する必要があります
どこかの文字列、またはint型、またはフロート、。

1754
01:27:56,070 --> 01:28:00,100
>> そして、それらの事を格納するために、ちょうどリコール
スクラッチのように、我々は変数を持っています。

1755
01:28:00,100 --> 01:28:03,260
しかし、スクラッチとは異なり、
C言語で、私たちは実際の型を持っています

1756
01:28:03,260 --> 01:28:05,530
variables--データの
種類、よりgenerally--

1757
01:28:05,530 --> 01:28:08,640
その中で、文字列、int型、A
これらの他のものはまだ浮く、と。

1758
01:28:08,640 --> 01:28:12,321
>> だから、我々はC言語で変数を宣言するときに、
我々は、我々のデータ型を宣言する必要があります。

1759
01:28:12,321 --> 01:28:14,820
これは、我々がよものではありません
学期の後半で行う必要があります

1760
01:28:14,820 --> 01:28:16,810
私たちは他の言語への移行など。

1761
01:28:16,810 --> 01:28:19,610
しかし、今のところ、我々は必要なのですか
事前に先験的に、

1762
01:28:19,610 --> 01:28:24,370
コンピュータどのタイプに説明
変数の我々はそれが私たちを与えたいです。

1763
01:28:24,370 --> 01:28:27,290
>> さて、一方、印刷するには
データ・タイプのもの種類

1764
01:28:27,290 --> 01:28:29,570
私たちは何を期待するのprintfを伝える必要があります。

1765
01:28:29,570 --> 01:28:32,450
そして、我々は、文字列のパーセントのを見ました
そして、整数のパーセント私、

1766
01:28:32,450 --> 01:28:33,790
すでに、いくつかの他のもの。

1767
01:28:33,790 --> 01:28:37,237
そして、それらは単に要件です
視覚的なプレゼンテーションのため

1768
01:28:37,237 --> 01:28:38,070
その情報の。

1769
01:28:38,070 --> 01:28:42,080
>> そして、これらのそれぞれは、実際にすることができます
何らかの方法でパラメータ化または微調整、

1770
01:28:42,080 --> 01:28:45,370
あなたがコントロールを促進したい場合
あなたが得る出力のタイプ。

1771
01:28:45,370 --> 01:28:49,604
そして、実際に、それだけではないことが判明します
新しいラインのバックスラッシュnがあります。

1772
01:28:49,604 --> 01:28:52,520
バックスラッシュと呼ばれる何か他のものがあります
キャリッジリターンのためのrを、その

1773
01:28:52,520 --> 01:28:54,360
に、より似ています
古い学校のタイプライター、

1774
01:28:54,360 --> 01:28:57,690
また、Windowsは、長年にわたって使用しました。

1775
01:28:57,690 --> 01:28:59,690
>> タブのバックスラッシュトンがあります。

1776
01:28:59,690 --> 01:29:03,170
あなたがしたい場合はこと、が判明
文字列の内側に二重引用符、

1777
01:29:03,170 --> 01:29:05,000
我々が使用したリコール
二重引用符、二重

1778
01:29:05,000 --> 01:29:07,900
左右の引用
これまで私たちの文字列の両端。

1779
01:29:07,900 --> 01:29:09,420
それは物事を混同しているように見えるだろう。

1780
01:29:09,420 --> 01:29:12,503
>> あなたは二重引用符を入れたい場合
確かに、string--との中間の、

1781
01:29:12,503 --> 01:29:13,670
見て混乱しています。

1782
01:29:13,670 --> 01:29:17,120
とになるので、あなたは、エスケープする必要が
、何かで二重引用符を話します

1783
01:29:17,120 --> 01:29:18,860
以下のような、文字通り、二重引用符をバックスラッシュ。

1784
01:29:18,860 --> 01:29:20,230
そして、いくつかの他はまだあります。

1785
01:29:20,230 --> 01:29:24,540
そして、我々はそれらの多くを参照してくださいよ
実際に使用する前に長いです。

1786
01:29:24,540 --> 01:29:27,930
>> それでは、今から移行してみましょう
データ、および表現、

1787
01:29:27,930 --> 01:29:30,820
そして、算術演算子、すべての
私たちにいくつかの建物を与えたの

1788
01:29:30,820 --> 01:29:32,070
再生するとブロック。

1789
01:29:32,070 --> 01:29:34,481
しかし、今のは、実際に与えてみましょう
私たちの語彙の残りの部分

1790
01:29:34,481 --> 01:29:36,230
我々はすでに持っていたこと
スクラッチとの最後の週

1791
01:29:36,230 --> 01:29:39,350
いくつかの他のを見てとることにより、
C--中の構築物ではないそれらのすべて。

1792
01:29:39,350 --> 01:29:41,680
しかし、アイデアは我々です
本当にただ見てについて

1793
01:29:41,680 --> 01:29:45,610
からの翻訳を強調します
別の言語、スクラッチ、C.

1794
01:29:45,610 --> 01:29:48,470
>> そして時間をかけて、我々は拾いますよ
私たちのツールキットのためのより多くのツール、

1795
01:29:48,470 --> 01:29:49,820
そう構文的に、話します。

1796
01:29:49,820 --> 01:29:54,190
そして、確かに、あなたはそのアイデアが表示されます
今先週からかなり精通しています。

1797
01:29:54,190 --> 01:29:55,200
それでは、これを実行しましょう​​。

1798
01:29:55,200 --> 01:29:58,870
>> それでは、先に行くと、プログラムをかき立てるしてみましょう
それは実際にいくつかの表現を使用し、

1799
01:29:58,870 --> 01:30:00,720
ブール式。

1800
01:30:00,720 --> 01:30:02,810
私はここで先に行ってみよう
新しいファイルを作成します。

1801
01:30:02,810 --> 01:30:06,090
私はこのcondition.cと呼ぶことにします。

1802
01:30:06,090 --> 01:30:09,350
>> 私は先に行ってみようと
CS50ライブラリが含まれています。

1803
01:30:09,350 --> 01:30:12,640
そして、私が先に行くと含ませて
我々の機能のための標準IO.h、

1804
01:30:12,640 --> 01:30:14,690
そしてより多くのそれぞれのprintf、と。

1805
01:30:14,690 --> 01:30:18,900
私は自分自身の決まり文句を挙げてみましょう
その説明我々はよint型メインボイド、

1806
01:30:18,900 --> 01:30:20,360
戻って将来的に来ます。

1807
01:30:20,360 --> 01:30:23,820
>> 今、私は先に行くと与えてみましょう
自分GET INTを介してint型。

1808
01:30:23,820 --> 01:30:25,970
そして、私が先に行くと、これを実行しましょう​​。

1809
01:30:25,970 --> 01:30:30,150
私はみましょうless--ある場合、私は言いたいです
負、正の区別、

1810
01:30:30,150 --> 01:30:31,260
またはゼロ値。

1811
01:30:31,260 --> 01:30:36,630
>> iがゼロより小さい場合だから、私を聞かせて
ただ、このプログラムは単純に言って持っています

1812
01:30:36,630 --> 01:30:42,370
他の負の、バックスラッシュnは、
iがゼロよりも大きい場合。

1813
01:30:42,370 --> 01:30:47,030
今私は、もちろん、言うつもりです
printfの正、バックスラッシュn個。

1814
01:30:47,030 --> 01:30:50,690
そして、他の私はこれを行うことができますif--。

1815
01:30:50,690 --> 01:30:53,410
>> iが0に等しい場合、私は行うことができます。

1816
01:30:53,410 --> 01:30:55,840
しかし、私はで作ることにしたいです
すでに少なくとも1ミス。

1817
01:30:55,840 --> 01:30:59,480
等号があることを思い出してください
私たち人間はそれを知っているように、等しくありません。

1818
01:30:59,480 --> 01:31:01,010
>> しかし、それは代入演算子です。

1819
01:31:01,010 --> 01:31:05,640
そして、我々は上の0を取るにしたくありません
右と左の私にそれを置きます。

1820
01:31:05,640 --> 01:31:11,810
したがって、この混乱を避けるために、または
おそらく、等号の誤用は、サインイン

1821
01:31:11,810 --> 01:31:14,740
人間は何年か前に決めました
その多くのプログラミング言語で

1822
01:31:14,740 --> 01:31:18,000
あなたは等価性をチェックしたいとき
左と右の間、

1823
01:31:18,000 --> 01:31:19,635
あなたが実際に相当します使用しています。

1824
01:31:19,635 --> 01:31:21,010
だから、等号は二回に署名ヒット。

1825
01:31:21,010 --> 01:31:25,600
あなたは右から割り当てたいとき
左に、あなたは、単一の等号を使用します。

1826
01:31:25,600 --> 01:31:29,360
だから我々はthis--他に何ができます
iが等しい場合にゼロに等しいです。

1827
01:31:29,360 --> 01:31:31,710
>> 私は、行くことができると
私の中括弧を開き、

1828
01:31:31,710 --> 01:31:36,087
そして、行われ、printfの0、バックスラッシュnは、言います。

1829
01:31:36,087 --> 01:31:38,170
しかし、どのようにこれらのを覚えています
道路のフォークが動作することができます。

1830
01:31:38,170 --> 01:31:39,836
そして、実際には、ちょうどロジックについて考えます。

1831
01:31:39,836 --> 01:31:41,510
私は数値です。

1832
01:31:41,510 --> 01:31:43,320
それは具体的には、整数です。

1833
01:31:43,320 --> 01:31:48,600
そして、それは少なくなるだろうことを意味します
0、0以上、または0より。

1834
01:31:48,600 --> 01:31:51,600
だから、これのようなものがあります
暗黙のデフォルトのケース。

1835
01:31:51,600 --> 01:31:54,920
>> そして私たちは、ただ好きでした
スクラッチ、それ以外の場合で済まします

1836
01:31:54,920 --> 01:31:55,747
ちょうど他に言います。

1837
01:31:55,747 --> 01:31:57,830
論理的には、あなたの場合
プログラマはそこだけ知っています

1838
01:31:57,830 --> 01:32:01,635
3つのバケットいるAへ
シナリオは、最初のfall--することができます

1839
01:32:01,635 --> 01:32:03,510
第二、または第三
このcase--でありません

1840
01:32:03,510 --> 01:32:07,100
追加の精度を追加する気に
そしてそこに追加のロジック。

1841
01:32:07,100 --> 01:32:09,690
ちょうどを進めます
ここでは、他のデフォルトの場合。

1842
01:32:09,690 --> 01:32:11,950
>> さて、先に行きましょう
これを保存した後、作ります

1843
01:32:11,950 --> 01:32:15,760
条件は、スラッシュドットconditions--
ない優れたユーザーインターフェース、

1844
01:32:15,760 --> 01:32:18,914
私はプロンプトいないよので、
ユーザ、私は先に述べたように。

1845
01:32:18,914 --> 01:32:19,580
しかし、それは大丈夫です。

1846
01:32:19,580 --> 01:32:20,454
私たちはそれをシンプルにしておこう。

1847
01:32:20,454 --> 01:32:21,890
のは、数42を試してみましょう。

1848
01:32:21,890 --> 01:32:23,240
そして、それはポジティブです。

1849
01:32:23,240 --> 01:32:26,120
番号を試してみましょう
負、42負。

1850
01:32:26,120 --> 01:32:28,244
>> のは、値0を試してみましょう。

1851
01:32:28,244 --> 01:32:29,160
そして、確かに、それは動作します。

1852
01:32:29,160 --> 01:32:33,900
さて、あなたは前に問題に表示されます
長い、テスト物事3回、

1853
01:32:33,900 --> 01:32:34,980
おそらく十分ではありません。

1854
01:32:34,980 --> 01:32:37,438
あなたは、おそらくいくつかをテストします
大きな数字、いくつかの小さいです

1855
01:32:37,438 --> 01:32:40,520
数字、いくつかのコーナーケース、など
私たちはそれらを記述するために来ます。

1856
01:32:40,520 --> 01:32:42,500
>> しかし今のところ、これは
かなり簡単なプログラム。

1857
01:32:42,500 --> 01:32:45,160
そして、私は、論理的に、かなり確信しています
それは3つのケースに収まります。

1858
01:32:45,160 --> 01:32:49,360
そして、確かに、たとえ私たちは
潜在的な弱点に焦点を当てました

1859
01:32:49,360 --> 01:32:53,480
不正確とオーバーフローの、で
現実CS50の問題の多く、

1860
01:32:53,480 --> 01:32:56,000
我々が心配するつもりはありません
すべての時間、約、

1861
01:32:56,000 --> 01:32:59,050
オーバーフローのそれらの問題と
不正確、なぜなら、実際には、Cで、

1862
01:32:59,050 --> 01:33:01,889
それは実際にすべてではないこと
それらの事を避けるのは簡単。

1863
01:33:01,889 --> 01:33:04,180
あなたがカウントアップしたい場合
大きな、そしてより大きな、そしてより大きな、

1864
01:33:04,180 --> 01:33:07,510
それは技術はあなたがそこにある判明します
しばしば呼ばれるものを含む、使用することができます

1865
01:33:07,510 --> 01:33:11,240
ライブラリ、コードのコレクション、その
他の人々はあなたが使用できることを書いて、

1866
01:33:11,240 --> 01:33:13,910
などと他の言語
実際にJavaおよび他、

1867
01:33:13,910 --> 01:33:15,800
それは非常に簡単にします
さらに高いカウントします。

1868
01:33:15,800 --> 01:33:19,810
だから、本当にこれらの危険の一部であります
あなたが使用している言語の関数。

1869
01:33:19,810 --> 01:33:22,710
そして、今後数週間以内に、我々はよ
本当にどのように危険なCを参照してください

1870
01:33:22,710 --> 01:33:24,950
あなたはそれを正しく使用しない場合することができます。

1871
01:33:24,950 --> 01:33:27,610
しかし、そこから、とと
Pythonの、およびJavaScript、意志

1872
01:33:27,610 --> 01:33:32,620
我々はいくつかの追加の保護を上の層、
そしてそれらのリスクの少ないを実行します。

1873
01:33:32,620 --> 01:33:35,820
>> それでは、もう少し作ってみましょう
私たちのプログラムで興味深いロジック。

1874
01:33:35,820 --> 01:33:39,110
だから私は先に行くと作成してみましょう
論理と呼ばれるプログラム

1875
01:33:39,110 --> 01:33:43,804
ちょうどので、私はいくつかで遊ぶことができます
実際のロジック、logical.c。

1876
01:33:43,804 --> 01:33:46,870
私はいくつかをコピーして貼り付けます
以前からコードので、私は戻って取得

1877
01:33:46,870 --> 01:33:49,950
この素敵な出発点に。

1878
01:33:49,950 --> 01:33:53,980
>> 私にこの時間をしてみましょう私はやるchar型のC.
それをCの名前を提供するつもり

1879
01:33:53,980 --> 01:33:58,510
それは従来のだという理由だけで、
ユーザーから文字を取得します。

1880
01:33:58,510 --> 01:34:00,730
とののようなふりをしましょう
私は部品を実装しています

1881
01:34:00,730 --> 01:34:04,130
そのRmのプログラムの、削除
その前に、プログラムは、ユーザを促しました

1882
01:34:04,130 --> 01:34:05,400
ファイルを削除します。

1883
01:34:05,400 --> 01:34:06,750
我々はこれをどのように行うことができますか？

1884
01:34:06,750 --> 01:34:11,090
>> Cが等しい場合、私は、言いたいです
、引用引用終わり、等しいです

1885
01:34:11,090 --> 01:34:16,304
yが、その後、私が仮定するつもりです
ユーザーは、はい選択したこと。

1886
01:34:16,304 --> 01:34:17,470
私はイエス印刷するつもりです。

1887
01:34:17,470 --> 01:34:19,440
それは実際に書いていた場合
除去プログラム、

1888
01:34:19,440 --> 01:34:21,420
我々は、ファイルを削除することができ
コー​​ドの複数行で。

1889
01:34:21,420 --> 01:34:22,461
しかし、我々はそれをシンプルにしておこう。

1890
01:34:22,461 --> 01:34:25,950

1891
01:34:25,950 --> 01:34:31,250
>> そうでcが等しい場合N--等しいです
そして今ここで、私は言うつもりです、

1892
01:34:31,250 --> 01:34:32,980
ユーザーは無いことを意味している必要があります。

1893
01:34:32,980 --> 01:34:34,360
そして他に、あなたは何を知っていますか？

1894
01:34:34,360 --> 01:34:36,200
私は他に何かわかりません
ユーザーが入力しようとしています。

1895
01:34:36,200 --> 01:34:38,533
だから、僕はそれを言うつもりです
それが誤りである、何でも

1896
01:34:38,533 --> 01:34:40,070
彼または彼女は実際に型指定されました。

1897
01:34:40,070 --> 01:34:41,180
>> それでは、ここで起こっているの？

1898
01:34:41,180 --> 01:34:44,530
根本的な違いがあります
私が過去にやった対。

1899
01:34:44,530 --> 01:34:49,300
二重引用符、二重引用符、二重
引用符、および、まだ、単一引用符、

1900
01:34:49,300 --> 01:34:50,170
単一引用符。

1901
01:34:50,170 --> 01:34:52,860
それはときにすることを、C言語で判明します
あなたは、文字列を書きたいです、

1902
01:34:52,860 --> 01:34:56,680
あなたは私たちがきたと同じように、二重引用符を使用しています
printf関数ですべてのこの時間を使って。

1903
01:34:56,680 --> 01:35:02,030
>> しかし、あなただけに対処したい場合
単一の文字、いわゆるチャー、

1904
01:35:02,030 --> 01:35:03,780
あなたは実際には単一引用符を使用します。

1905
01:35:03,780 --> 01:35:05,450
プログラムされてきたあなたの人々の
前に、あなたが持っていない可能性があります

1906
01:35:05,450 --> 01:35:07,850
このことを心配していました
特定の言語で区別。

1907
01:35:07,850 --> 01:35:09,450
Cでは、それは問題ありません。

1908
01:35:09,450 --> 01:35:12,560
だから、私はchar型を取得し、私が欲しいとき
equalsを使ってその文字を比較します

1909
01:35:12,560 --> 01:35:18,350
YまたはNのようないくつかの文字に等しく、私は、
確かに、単一引用符を持っている必要があります。

1910
01:35:18,350 --> 01:35:19,770
>> さて、先に行くと、これを実行しましょう​​。

1911
01:35:19,770 --> 01:35:26,180
それでは、先に行くと作るのですかしてみましょう
論理ドットが論理スラッシュ。

1912
01:35:26,180 --> 01:35:27,305
そして今、私は、プロンプトが表示されています。

1913
01:35:27,305 --> 01:35:30,638
だから、おそらく、より良いユーザーエクスペリエンス
実際に何がここで行うように私に言うだろう。

1914
01:35:30,638 --> 01:35:33,030
しかし、私はちょうど盲目的に行きますよ
素敵な、[OK]を、イエスのために、yを言います。

1915
01:35:33,030 --> 01:35:35,780
>> nは素敵な、ないために、のは再びそれを実行してみましょう。

1916
01:35:35,780 --> 01:35:39,610
私が知っている特定の人のように仮定し、
私のキャップはキーがあまりにも頻繁にすべての上にあるロック。

1917
01:35:39,610 --> 01:35:43,740
だから私は、首都Yは、入力エラーを行います。

1918
01:35:43,740 --> 01:35:46,130
OK、それは私が期待していまさにではありません。

1919
01:35:46,130 --> 01:35:48,170
確かに、コンピュータ
文字通り何をやっています

1920
01:35:48,170 --> 01:35:51,794
私はのためにチェックdo--するためにそれを言いました
小文字のyと小文字のn。

1921
01:35:51,794 --> 01:35:53,960
これは良いように感じることはありません
ユーザーエクスペリエンス、しかし。

1922
01:35:53,960 --> 01:35:59,010
私はのために聞いてみようと受け入れ
小文字または大文字のいずれか。

1923
01:35:59,010 --> 01:36:02,090
だから結局、あなたがしたいことがあります
スクラッチのような何かを言うために、

1924
01:36:02,090 --> 01:36:08,150
文字通りまたはCイコールのような
資本単一引用符で囲まれたyは等しいです。

1925
01:36:08,150 --> 01:36:11,400
結局のところ、Cは持っていません
このリテラルキーワードまたは。

1926
01:36:11,400 --> 01:36:12,880
>> しかし、それは2つの垂直バーを持っています。

1927
01:36:12,880 --> 01:36:15,463
あなたは、通常、Shiftキーを保持する必要が
あなたはUSキーボードを使用している場合、

1928
01:36:15,463 --> 01:36:18,910
そして、垂直バーをヒット
あなたのリターンキーの上のキー。

1929
01:36:18,910 --> 01:36:22,410
しかし、この垂直バー
垂直バーは、意味や。

1930
01:36:22,410 --> 01:36:26,220
>> 場合は、対照的に、我々が望んでいました
言うと、スクラッチのようにするために、

1931
01:36:26,220 --> 01:36:28,180
我々はアンパサンドアンパサンドを行うことができます。

1932
01:36:28,180 --> 01:36:31,330
つまり、ここには論理的な意味がありません
人間ではない可能性がなかったため、

1933
01:36:31,330 --> 01:36:37,110
yおよび小文字のyの両方を入力しました
そして、同じ文字として資本Y。

1934
01:36:37,110 --> 01:36:39,470
だからかである私たちはここで何を意図しています。

1935
01:36:39,470 --> 01:36:46,280
>> だから私は両方の場所でこれを行う場合、またはc
、首都N、今再実行するに等しい等しいです

1936
01:36:46,280 --> 01:36:49,390
論理作る、論理再実行してください。

1937
01:36:49,390 --> 01:36:51,200
今、私は、yを入力することができます。

1938
01:36:51,200 --> 01:36:53,920
そして、私は再びそれを行うことができます
首都Y、または資本N.

1939
01:36:53,920 --> 01:36:56,630
そして、私は、追加で追加することもできます
まだ組み合わせ。

1940
01:36:56,630 --> 01:36:58,810
>> だから、これは論理的です
限り、今のようなプログラム

1941
01:36:58,810 --> 01:37:01,940
私はのために論理的にチェックしています
この値またはこの値。

1942
01:37:01,940 --> 01:37:06,420
そして、私は、必ずしも、する必要はありません
2以上のIFSまたは他のIFSを思い付きます。

1943
01:37:06,420 --> 01:37:09,960
私は実際のいくつかを組み合わせることができます
このように一緒にロジックを関連。

1944
01:37:09,960 --> 01:37:11,950
だから、これは良いだろう
単により設計

1945
01:37:11,950 --> 01:37:17,490
Cは小文字のyに等しい場合、言って、
cは資本Yに等しい場合、それ以外の、はい印刷

1946
01:37:17,490 --> 01:37:20,074
cが等しい場合、他の、はい印刷
他の言葉でlower--、

1947
01:37:20,074 --> 01:37:21,990
あなたが持っている必要はありません
より多くの枝。

1948
01:37:21,990 --> 01:37:28,840
あなたは同等のいくつかを組み合わせることができます
このように論理的に分岐します。

1949
01:37:28,840 --> 01:37:34,150
>> それでは、ちょうど1を見てみましょう
最終的な成分、1最終構築物、

1950
01:37:34,150 --> 01:37:34,847
そのCができます。

1951
01:37:34,847 --> 01:37:36,930
そして、我々は中に戻ってきます
まだ他の人に未来。

1952
01:37:36,930 --> 01:37:41,400
そして、我々は見ることによって結論付けます
code--のない正確さで

1953
01:37:41,400 --> 01:37:46,070
work--するためのコードが、設計を取得
コー​​ドの、と早い段階でこれらの種を植えます。

1954
01:37:46,070 --> 01:37:51,337
>> だから私は先に行くとしましょう
ここで新しいファイルを開きます。

1955
01:37:51,337 --> 01:37:51,920
あのね？

1956
01:37:51,920 --> 01:37:54,450
私は再実装するつもりです
その同じプログラム、

1957
01:37:54,450 --> 01:37:55,940
しかし、別の構成要素を使って。

1958
01:37:55,940 --> 01:38:00,110
>> だから私はすぐに自分自身を与えてみましょう
CS50.hを含むようにアクセス

1959
01:38:00,110 --> 01:38:04,150
CS50ライブラリの、
printfのための標準的なIo.h。

1960
01:38:04,150 --> 01:38:06,510
私に私のint主な空隙を与えます。

1961
01:38:06,510 --> 01:38:09,310
そして、ここの上、みましょう
私は先に行くとこれを行います。

1962
01:38:09,310 --> 01:38:12,010
>> シャアcは、直前のように、文字を取得します。

1963
01:38:12,010 --> 01:38:16,770
そして、私は新しい構文を使用するつもりです
どのような文字で、スイッチnow--？

1964
01:38:16,770 --> 01:38:19,820
だから、スイッチは一種のようなものです
列車のトラックを切り替えます。

1965
01:38:19,820 --> 01:38:22,070
それとも、本当に、それは一種のです
それ以外の場合、もし他にあれば、

1966
01:38:22,070 --> 01:38:23,980
しかし多少異なる書かれて。

1967
01:38:23,980 --> 01:38:25,490
>> スイッチは次のようになります。

1968
01:38:25,490 --> 01:38:29,060
あなたはスイッチがあり、その後、どのような
文字や数字、あなたが見てみたいです、

1969
01:38:29,060 --> 01:38:32,000
のように、その後いくつかの中括弧
スクラッチ、ちょうどこのようなものをやると言います。

1970
01:38:32,000 --> 01:38:33,480
そして、あなたは異なる場合があります。

1971
01:38:33,480 --> 01:38:34,830
>> あなたがあれば、他は使用しないでください。

1972
01:38:34,830 --> 01:38:37,050
あなたは文字通り単語のケースを使用しています。

1973
01:38:37,050 --> 01:38:38,790
そして、あなたはこのような何かを言うでしょう。

1974
01:38:38,790 --> 01:38:43,820
>> だから、小文字のyの場合には、
または資本Yの場合には、

1975
01:38:43,820 --> 01:38:47,350
先に行くと、イエスをプリントアウト。

1976
01:38:47,350 --> 01:38:49,020
そして、スイッチから抜け出します。

1977
01:38:49,020 --> 01:38:49,580
それでおしまい。

1978
01:38:49,580 --> 01:38:50,880
もう終わった。

1979
01:38:50,880 --> 01:38:57,270
>> いわば、場合そうで、
小文字のn、または資本N、

1980
01:38:57,270 --> 01:39:02,560
その後、先に行くと印刷
アウトなし、その後破ります。

1981
01:39:02,560 --> 01:39:08,022
Else--とされ、この種の
デフォルトの場合indeed--のprintf error--

1982
01:39:08,022 --> 01:39:10,980
ちょうど良い測定のために、しかし
論理的に、このブレークは必要ありません

1983
01:39:10,980 --> 01:39:12,896
我々は終わりにしているので、
とにかくスイッチの、

1984
01:39:12,896 --> 01:39:14,520
私は今スイッチを抜け出しています。

1985
01:39:14,520 --> 01:39:16,280
だから、これは少し違って見えます。

1986
01:39:16,280 --> 01:39:18,272
>> しかし、論理的に、それはです
実際に同等。

1987
01:39:18,272 --> 01:39:19,980
そして、なぜあなたは使用します
一方が他方の上？

1988
01:39:19,980 --> 01:39:23,220
時には、単に個人的な好み、
時には美学、

1989
01:39:23,220 --> 01:39:25,420
私はこの一目場合
今、何かがあります

1990
01:39:25,420 --> 01:39:27,510
以下のために言うことにします
このコードの可読性。

1991
01:39:27,510 --> 01:39:30,690
私はこの事実を気にしない、意味します
コー​​ドは部屋に私たちの多くの新機能です。

1992
01:39:30,690 --> 01:39:33,515
>> しかし、それはちょうど種類のかわいいです。

1993
01:39:33,515 --> 01:39:37,760
あなたは、小文字のY、資本Yを参照してください
小文字のn、資本Nのデフォルト、

1994
01:39:37,760 --> 01:39:40,150
それだけの種類のジャンプ
方法であなたにアウト

1995
01:39:40,150 --> 01:39:42,200
間違いなく、多分、その
前の例

1996
01:39:42,200 --> 01:39:45,780
IFS、縦棒と、
そして、それ以外のIFSは、持っていない可能性があります。

1997
01:39:45,780 --> 01:39:51,600
だから、これは本当に個人的な問題です
選択、本当に、または読みやすさ、

1998
01:39:51,600 --> 01:39:52,360
コー​​ドの。

1999
01:39:52,360 --> 01:39:58,230
>> しかし、機能性の面で、私を聞かせて
先に行くとスイッチを作る、ドットスラッシュ

2000
01:39:58,230 --> 01:40:05,830
スイッチは、今、小文字のyを入力します
首都Y、小文字のnは、資本N、

2001
01:40:05,830 --> 01:40:09,250
それだからダビデは、再試行します
ない単一の文字。

2002
01:40:09,250 --> 01:40:12,050
期待通りのは、X、エラーをしましょう​​。

2003
01:40:12,050 --> 01:40:15,640
そして、logically--これは何かであります
私もgeneral--に励まします

2004
01:40:15,640 --> 01:40:17,790
我々は唯一の引っ掻きているものの
これらの機能のいくつかの面。

2005
01:40:17,790 --> 01:40:20,560
>> ときに、それは明白ではないかもしれません
自分では、キーボードで座ります

2006
01:40:20,560 --> 01:40:21,370
これはどのように作動しますか？

2007
01:40:21,370 --> 01:40:22,240
これは何をしますか？

2008
01:40:22,240 --> 01:40:25,630
持っていることについて美しいもの
ラップトップ、またはデスクトップ、またはアクセス

2009
01:40:25,630 --> 01:40:29,290
コンパイラを使用して、コンピュータに、
そして、このようなコードエディタで、

2010
01:40:29,290 --> 01:40:32,990
あなたはほとんど常にこれらに答えることができますされています
ちょうどしようとすることによってあなた自身のための質問。

2011
01:40:32,990 --> 01:40:36,570
>> 例えば、修辞場合
手元の質問があったが、

2012
01:40:36,570 --> 01:40:39,540
あなたが忘れてしまった場合何が起こります
あなたのbreak文？

2013
01:40:39,540 --> 01:40:41,400
これは実際に
行うには非常に一般的なもの、

2014
01:40:41,400 --> 01:40:43,540
それは見ていないので、
あなたのように実際にそれらを必要としています。

2015
01:40:43,540 --> 01:40:46,790
彼らは本当にあなたを完了しません
カッコやカーリーのように思いました

2016
01:40:46,790 --> 01:40:47,714
ブレースはありません。

2017
01:40:47,714 --> 01:40:49,630
それでは、先に行こうと
コー​​ドを再コンパイルし、参照してください。

2018
01:40:49,630 --> 01:40:53,690
だからスイッチ、ドットスラッシュスイッチを作ります。

2019
01:40:53,690 --> 01:40:56,435
小文字を入力してみましょう
yは、トップケースは、入力します。

2020
01:40:56,435 --> 01:40:59,390

2021
01:40:59,390 --> 01:41:00,700
だから私は、yを入力しました。

2022
01:41:00,700 --> 01:41:04,420
>> プログラムは、はい、いいえ、エラーと述べ、
あるかのように、その心を変えました。

2023
01:41:04,420 --> 01:41:09,280
何が起こるので、しかし、それは一種の、でした
スイッチとその最初のケースであります

2024
01:41:09,280 --> 01:41:13,899
試合は、本質的にちょっと、コンピュータを意味し、
その下のすべてのコードを実行します。

2025
01:41:13,899 --> 01:41:16,690
そして、あなたは休憩を言っていない場合、または
休憩を言っていない、または休憩を言うことはありません、

2026
01:41:16,690 --> 01:41:19,540
コンピュータが吹くために起こっています
これらの行のすべてを介して、

2027
01:41:19,540 --> 01:41:22,779
そして、まではそれらのすべてを実行します
その中括弧になります。

2028
01:41:22,779 --> 01:41:24,320
だからブレーキは、確かに、必要です。

2029
01:41:24,320 --> 01:41:27,120
しかし、ここでお持ち帰りは場合には、
疑いで、何かを試してみてください。

2030
01:41:27,120 --> 01:41:29,510
たぶん、最初のコードを保存し、
または余分なファイルに保存します

2031
01:41:29,510 --> 01:41:32,930
あなたはについては本当に心配している場合
めちゃくちゃし、回復すること

2032
01:41:32,930 --> 01:41:34,430
あなたが知っている仕事が働いています。

2033
01:41:34,430 --> 01:41:35,410
>> しかし、物事を試してみてください。

2034
01:41:35,410 --> 01:41:38,074
そして、おそらく、など恐れることはありません
コンピュータが行うかもしれないものの、

2035
01:41:38,074 --> 01:41:39,490
またはあなたが何かを壊すかもしれません。

2036
01:41:39,490 --> 01:41:42,790
あなたは、常に戻すことができます
いくつかの以前のバージョンに。

2037
01:41:42,790 --> 01:41:45,640
>> それでは、見ることによって終了してみましょう
コー​​ドのデザインで。

2038
01:41:45,640 --> 01:41:49,020
我々は書くために今、この能力を持っています
条件、書き込みループ

2039
01:41:49,020 --> 01:41:50,850
そして、変数、および通話機能。

2040
01:41:50,850 --> 01:41:54,590
だから、率直に言って、私たちは、背面の一種です
ここで我々は、スクラッチで週間前でした

2041
01:41:54,590 --> 01:42:00,120
あまり説得力のあるテキストとはいえ
スクラッチよりも環境ができます。

2042
01:42:00,120 --> 01:42:03,990
>> しかし、我々は取得してきたどのように迅速に気付きます
それはだ場合であっても、その語彙、

2043
01:42:03,990 --> 01:42:07,570
でシンクする少しの間を取るつもり、
我々は今、この語彙を使用できるように、

2044
01:42:07,570 --> 01:42:10,320
もっと面白いプログラムを書き込みます。

2045
01:42:10,320 --> 01:42:12,940
そして、の赤ちゃんのステップを見てみましょう
それに向かって、は以下の通り。

2046
01:42:12,940 --> 01:42:14,890
私は先に行ってみようと
ここで新しいファイルを作成します。

2047
01:42:14,890 --> 01:42:17,750
>> 私はこれをコールするつもりです
prototype.c、と紹介

2048
01:42:17,750 --> 01:42:20,954
初めて、能力
独自の関数を作ります。

2049
01:42:20,954 --> 01:42:22,870
あなたのいくつかは持っている可能性があります
スクラッチでこれを行って、

2050
01:42:22,870 --> 01:42:25,430
あなたを作成することができます
スクラッチで独自のカスタムブロック、

2051
01:42:25,430 --> 01:42:27,892
そしてその後、所定の位置にドラッグします
あなたは、Cでみたいところはどこでも

2052
01:42:27,892 --> 01:42:30,100
そして、ほとんどのプログラミングで
言語は、あなたが正確に行うことができます

2053
01:42:30,100 --> 01:42:33,580
that--独自の関数を作ります、
彼らはすでに存在していない場合。

2054
01:42:33,580 --> 01:42:38,660
>> だから、例えば、私は先に行ってみましょう
そして、CS50.hを含み、および含まれます

2055
01:42:38,660 --> 01:42:43,110
標準IO.h、int型メインボイド。

2056
01:42:43,110 --> 01:42:46,020
そして今、我々は持っています
行く準備ができてプレースホルダー。

2057
01:42:46,020 --> 01:42:48,550
私は印刷物事を保ちます
人の名前、今日のように。

2058
01:42:48,550 --> 01:42:51,910
そしてそれはlike--感じ
そこにあれば素敵ではないでしょう

2059
01:42:51,910 --> 01:42:53,936
印刷nameという関数がありましたか？

2060
01:42:53,936 --> 01:42:55,060
私はprintfのを使用する必要はありません。

2061
01:42:55,060 --> 01:42:56,976
私が覚えておく必要はありません
すべての書式コード。

2062
01:42:56,976 --> 01:43:00,050
なぜない私、またはなぜ
、私の前に誰かがしませんでした

2063
01:43:00,050 --> 01:43:02,980
印刷と呼ばれる関数を作成
名前、いくつかの名前を与えられたことを、

2064
01:43:02,980 --> 01:43:03,980
単にそれをプリントアウト？

2065
01:43:03,980 --> 01:43:08,700
>> 言い換えれば、私は、ちょっと、言うなら
コンピュータは、私の文字列を与えます

2066
01:43:08,700 --> 01:43:11,870
そのようなのためにユーザに尋ねることで、
CS50のget文字列関数を介して。

2067
01:43:11,870 --> 01:43:15,090
ねえ、コンピュータにその文字列を入れて
左手側の変数

2068
01:43:15,090 --> 01:43:16,150
とだそれを呼び出します。

2069
01:43:16,150 --> 01:43:22,150
そして、コンピュータちょっと、先に行きます
そして、行って、その人の名前を印刷します。

2070
01:43:22,150 --> 01:43:26,240
>> 今、それはので、いいだろう
このプログラムは、適切に、命名します

2071
01:43:26,240 --> 01:43:29,170
行うことになっているものを私に伝えます
これらの関数の名前を介して。

2072
01:43:29,170 --> 01:43:32,930
私が行ってみようとプロトタイプを作成し、入力します。

2073
01:43:32,930 --> 01:43:34,930
そして、残念ながら、
これは、飛行するつもりはありません。

2074
01:43:34,930 --> 01:43:39,430
>> Prototype.c、7行目、キャラクター
5、エラー、暗黙の宣言

2075
01:43:39,430 --> 01:43:42,960
機能印刷名の
C99、C99に無効です

2076
01:43:42,960 --> 01:43:45,130
Cのバージョンを意味します
それは1999年に出てきました。

2077
01:43:45,130 --> 01:43:45,730
それで全部です。

2078
01:43:45,730 --> 01:43:48,780
>> だから私は何を知りません
このすべては、まだ意味します。

2079
01:43:48,780 --> 01:43:50,810
しかし、私は赤でエラーを認識しません。

2080
01:43:50,810 --> 01:43:51,770
それはかなり明白です。

2081
01:43:51,770 --> 01:43:53,769
>> そして、それはとのようです
ここでは緑の文字、

2082
01:43:53,769 --> 01:43:57,520
問題は、印刷名でオープンしています
括弧秒、クローズ括弧、セミコロン。

2083
01:43:57,520 --> 01:44:01,800
しかし、の暗黙的な宣言
先ほど簡単に参照した機能。

2084
01:44:01,800 --> 01:44:04,880
これは、単に、そのクラン手段
私が何を意味するか知っていません。

2085
01:44:04,880 --> 01:44:09,000
>> 私はそれがだと語彙を使用しました
見られないか、または以前に教示されていません。

2086
01:44:09,000 --> 01:44:11,950
そして、私はそれを教える必要があります
この関数は何を意味するのか。

2087
01:44:11,950 --> 01:44:13,590
だから私は先に行くとそれを行うつもりです。

2088
01:44:13,590 --> 01:44:17,970
>> 私は先に行くと、実装するつもりです
私自身の機能は、Print名前を呼ばれます。

2089
01:44:17,970 --> 01:44:24,720
そして、私は、次のように言おうとしているんです
それがこの、printf関数、こんにちは、パーセントを行います

2090
01:44:24,720 --> 01:44:27,760
秒、バックスラッシュnは、名前、セミコロン。

2091
01:44:27,760 --> 01:44:29,250
だから、僕は何をしましたか？

2092
01:44:29,250 --> 01:44:31,325
>> だから、に、判明します
独自の機能を実装し、

2093
01:44:31,325 --> 01:44:33,845
私たちは、この種のいくつかを借ります
メインと同じ構造

2094
01:44:33,845 --> 01:44:35,720
私たちはしてきたこと
当たり前の、そして私

2095
01:44:35,720 --> 01:44:37,730
知っているだけでコピーして
ほとんど何を貼り付けます

2096
01:44:37,730 --> 01:44:39,170
私は過去に書いてきました。

2097
01:44:39,170 --> 01:44:40,570
しかし、ここでのパターンに気づきます。

2098
01:44:40,570 --> 01:44:43,750
int型、メイン、ボイド、我々は離れていじめるだろう
やがてそれが実際に何を意味するのか。

2099
01:44:43,750 --> 01:44:46,160
>> しかし、今日のために、ちょうど
並列性に気付きます。

2100
01:44:46,160 --> 01:44:48,210
ボイド、印刷名
文字列名は、とてもあります

2101
01:44:48,210 --> 01:44:50,310
紫色のキーワード、その
我々が開始するつもりです

2102
01:44:50,310 --> 01:44:54,067
戻り値の型の名前を呼んで
機能し、入力。

2103
01:44:54,067 --> 01:44:56,400
だから、実際には、我々は蒸留することができます
先週のようなこの種の

2104
01:44:56,400 --> 01:44:59,030
、これは名前またはあるとして
私たちがしているコードのアルゴリズム

2105
01:44:59,030 --> 01:45:00,761
write--に行きます
基礎となるアルゴリズム

2106
01:45:00,761 --> 01:45:02,010
コー​​ドは、我々は書くつもりです。

2107
01:45:02,010 --> 01:45:03,180
>> これは、入力されます。

2108
01:45:03,180 --> 01:45:04,670
これは、出力されます。

2109
01:45:04,670 --> 01:45:08,730
この機能は、印刷名は、あります
名前と呼ばれる文字列を取るように設計されました、

2110
01:45:08,730 --> 01:45:11,350
または何でも、入力として、及びボイド。

2111
01:45:11,350 --> 01:45:13,904
それは、何も返しません
以下のような文字列を取得したり、intはありません取得します。

2112
01:45:13,904 --> 01:45:15,570
だから、戻って私に何かを手に起こっています。

2113
01:45:15,570 --> 01:45:17,960
ちょうど持っているために起こっています
副作用、いわば、

2114
01:45:17,960 --> 01:45:19,570
人の名前を印刷します。

2115
01:45:19,570 --> 01:45:22,260
だから私は、7行目、気付きます
印刷名を呼び出すことができます。

2116
01:45:22,260 --> 01:45:25,920
10行目、私が定義することができます
または印刷名を実装します。

2117
01:45:25,920 --> 01:45:28,450
しかし、残念ながら、それは十分ではありません。

2118
01:45:28,450 --> 01:45:31,230
>> 私は先に行ってみようと
保存した後、これを再コンパイルします。

2119
01:45:31,230 --> 01:45:33,910
おっと、今、私はそれを作りました
悪いことに、それは思われます。

2120
01:45:33,910 --> 01:45:37,027
のだから、暗黙的な宣言
機能印刷名が無効です。

2121
01:45:37,027 --> 01:45:38,360
そして、再び、多くの誤りがあります。

2122
01:45:38,360 --> 01:45:41,430
しかし、私も、以前の警告として
あなたがに圧倒取得する場合、

2123
01:45:41,430 --> 01:45:44,850
または少し悲しいほど多くを見るために
エラーは、最初に焦点を当て

2124
01:45:44,850 --> 01:45:47,500
最初に、それは可能性があるため、単に
カスケード効果を有していました。

2125
01:45:47,500 --> 01:45:51,970
より具体的にはC、またはクランそう
まだ印刷名を認識しません。

2126
01:45:51,970 --> 01:45:54,580
>> そして、それはクランためです、
設計によって、一種のダムです。

2127
01:45:54,580 --> 01:45:56,280
それは、あなたがそれを行うには言うことありません。

2128
01:45:56,280 --> 01:46:00,950
そして、それは唯一のためにそうします
あなたは何をすることを教えています。

2129
01:46:00,950 --> 01:46:05,270
>> だから私は、ライン4上の主な定義されています
以下のような私たちはかなり頻繁に行ってきました。

2130
01:46:05,270 --> 01:46:07,980
私はライン10上の印刷名を定義しました。

2131
01:46:07,980 --> 01:46:11,793
しかし、私は使用しようとしています
ライン7上の印刷名。

2132
01:46:11,793 --> 01:46:13,670
>> それは早すぎる、まだ存在していません。

2133
01:46:13,670 --> 01:46:19,150
だから私は賢いこと、などが挙げられるかもしれません、
[OK]を、ので、ちょうど一緒に演奏しましょう​​、

2134
01:46:19,150 --> 01:46:23,680
印刷名を上に移動
ここで、再度コンパイルします。

2135
01:46:23,680 --> 01:46:24,550
何てことだ。

2136
01:46:24,550 --> 01:46:25,260
出来た。

2137
01:46:25,260 --> 01:46:26,670
それはそれと同じくらい簡単でした。

2138
01:46:26,670 --> 01:46:28,120
>> しかし論理はまさにそれです。

2139
01:46:28,120 --> 01:46:30,870
あなたはクランを教えるために持っているもの、それ
最初の関数を定義することです。

2140
01:46:30,870 --> 01:46:31,920
次に、あなたがそれを使用することができます。

2141
01:46:31,920 --> 01:46:33,940
しかし、率直に言って、これは感じています
滑りやすい坂道などです。

2142
01:46:33,940 --> 01:46:35,773
>> だから毎回私が実行します
問題の中に、私はちょうどよ

2143
01:46:35,773 --> 01:46:39,450
強調表示し、コードをコピーしよう
私はそれをカットし、ここでそれを貼り付けて、書いています。

2144
01:46:39,450 --> 01:46:41,370
そして、確かに、我々は可能性
いくつかのシナリオを工夫

2145
01:46:41,370 --> 01:46:43,286
ここで、一つの機能の​​かもしれません
別のを呼び出す必要があります。

2146
01:46:43,286 --> 01:46:46,030
そして、あなたは、単にすべての置くことができません
他のすべてのような機能。

2147
01:46:46,030 --> 01:46:47,930
>> だから、それはありますが判明します
よりよい解決策。

2148
01:46:47,930 --> 01:46:50,100
私たちは、これがすることが残すことができます。

2149
01:46:50,100 --> 01:46:53,677
そして、率直に言って、それは、一般的にうれしいです
そして、便利で、良いデザイン

2150
01:46:53,677 --> 01:46:56,760
なぜなら、再び、第一主置くために、
ちょうど緑のフラグがクリックされたときのように、メイン、

2151
01:46:56,760 --> 01:46:59,027
それは、その関数であります
デフォルトで実行されます。

2152
01:46:59,027 --> 01:47:01,110
だからあなたにも置くことがあるかもしれません
そのファイルの先頭に

2153
01:47:01,110 --> 01:47:03,560
そのため、ユーザーまたは任意の時
他の人間には、ファイルを見て

2154
01:47:03,560 --> 01:47:06,360
あなたは何が起こっているのか知っています
ちょうどメイン1を読み取ることで。

2155
01:47:06,360 --> 01:47:15,360
だから結局、私たちは、クランを伝えることができます
積極的に、ちょっと、クラン、ライン4に、

2156
01:47:15,360 --> 01:47:17,940
私が実装することを約束します
印刷と呼ばれる機能

2157
01:47:17,940 --> 01:47:22,600
名前と呼ばれる文字列を受け取り名前
入力として、ボイド何も返しません。

2158
01:47:22,600 --> 01:47:24,770
そして、私はに周りを取得します
後でそれを実装します。

2159
01:47:24,770 --> 01:47:25,680
>> ここでは主な付属しています。

2160
01:47:25,680 --> 01:47:29,130
主は現在、9行目で使用することができます
印刷名クラン理由

2161
01:47:29,130 --> 01:47:32,600
最終的には、それを信頼され、
それは定義が発生します

2162
01:47:32,600 --> 01:47:34,880
印刷名の実装の。

2163
01:47:34,880 --> 01:47:37,390
だから私のファイルを保存した後、しましょう
私は先に行くと、プロトタイプを作成し、

2164
01:47:37,390 --> 01:47:38,498
今回はよさそうです。

2165
01:47:38,498 --> 01:47:43,470
ドットスラッシュ、プロトタイプ、私を聞かせて
先に行くと名前を入力します。

2166
01:47:43,470 --> 01:47:48,440
デイヴィッド、こんにちはデビッド、Zamila、ハロー
Zamila、そして、確かに、今それが動作します。

2167
01:47:48,440 --> 01:47:52,200
>> だからここ成分は、私たちがしたことです
カスタムのように、カスタム関数を作りました

2168
01:47:52,200 --> 01:47:54,219
スクラッチブロック我々はそれを呼んでいます。

2169
01:47:54,219 --> 01:47:57,010
しかし、スクラッチとは違ってどこにすることができます
ちょうどそれを作成し、それを使用して起動し、

2170
01:47:57,010 --> 01:47:59,330
今、私たちはしなければなりません
もう少し知識をひけらかします、

2171
01:47:59,330 --> 01:48:03,410
実際クランを訓練
使用する、またはそれを期待します。

2172
01:48:03,410 --> 01:48:09,140
さて、余談として、なぜこのすべての時間を持っています
我々は、以下を含む信仰にやみくもになって

2173
01:48:09,140 --> 01:48:12,170
標準IO.h含むCS50.h、と？

2174
01:48:12,170 --> 01:48:15,190
>> まあ、それは結局のところ、
いくつか他のものの中で、

2175
01:48:15,190 --> 01:48:18,550
すべてのことは、これらのドット時間でです
ファイルことが起こるのファイル、。

2176
01:48:18,550 --> 01:48:20,460
彼らはいわば、ファイルヘッダいます。

2177
01:48:20,460 --> 01:48:23,270
彼らはまだCで書かれている。しかし
彼らは、ファイルの異なる種類です。

2178
01:48:23,270 --> 01:48:28,690
>> 今のところ、あなたはかなり仮定することができます
CS50.hの内側にあるものすべてのこと

2179
01:48:28,690 --> 01:48:33,360
このようないくつかのワンライナー、ではありません
印刷名と呼ばれる機能のため、

2180
01:48:33,360 --> 01:48:36,840
しかし、文字列を取得するためには、Get
フロート、およびいくつかの他。

2181
01:48:36,840 --> 01:48:41,510
そして、同様のプロトタイプがあり、
1ライナー、標準IO.hの内側

2182
01:48:41,510 --> 01:48:46,241
に今あるのprintf、用
私自身の印刷名機能。

2183
01:48:46,241 --> 01:48:49,490
だから、他の言葉で、この全体の時間、私たちはしました
やみくもにコピーして貼り付けられて

2184
01:48:49,490 --> 01:48:51,780
含む、これを含みます
つまり、何が起こっているの？

2185
01:48:51,780 --> 01:48:55,310
これらは、手がかりのちょうど一種であります
どのような機能をとして打ち鳴らすします

2186
01:48:55,310 --> 01:49:00,170
、確かに、ちょうど、実装されています
別の場所で別のファイルで

2187
01:49:00,170 --> 01:49:02,440
システムの他の場所に。

2188
01:49:02,440 --> 01:49:05,160
>> だから我々は、印刷名を実装しました。

2189
01:49:05,160 --> 01:49:07,910
それは、この副作用を持っています
画面上で何かを印刷します。

2190
01:49:07,910 --> 01:49:10,170
しかし、それは実際にはしません
私に何かをバック手。

2191
01:49:10,170 --> 01:49:12,200
どうやって行くのです
そのプログラムを実施

2192
01:49:12,200 --> 01:49:14,510
バック私に何かを手渡していますか？

2193
01:49:14,510 --> 01:49:15,580
>> さて、これを試してみましょう。

2194
01:49:15,580 --> 01:49:21,360
私が先に行くと実装してみましょう
return.cと呼ばれるファイル

2195
01:49:21,360 --> 01:49:24,530
私たちはどのように何かを証明することができます
以下のような文字列を取得し、またはINTを取得し、

2196
01:49:24,530 --> 01:49:27,340
実際に戻っています
戻ってユーザーに何か。

2197
01:49:27,340 --> 01:49:29,840
それでは、先に行くと、int型の主な空隙を定義してみましょう。

2198
01:49:29,840 --> 01:49:33,230
>> そして、再び、将来的には、よ
そのint型とその空隙何を説明

2199
01:49:33,230 --> 01:49:34,090
実際にやっています。

2200
01:49:34,090 --> 01:49:35,840
しかし、今日のために、我々はよ
当然だと思う。

2201
01:49:35,840 --> 01:49:39,970
私は先に行くと、printfのつもりです、
優れたユーザーエクスペリエンスのために、xがあります。

2202
01:49:39,970 --> 01:49:44,360
そして私は待つつもりです
私を与えるために、ユーザは、get int型を持つX。

2203
01:49:44,360 --> 01:49:48,459
>> そして、私は先に行くつもりです
正方形にXをプリントアウト。

2204
01:49:48,459 --> 01:49:50,500
だから、あなたが唯一持っているとき
一般的に、キーボード、人々

2205
01:49:50,500 --> 01:49:52,600
少しニンジンを使用
キーボード上のシンボル

2206
01:49:52,600 --> 01:49:55,330
電源に表現します
のの、または指数。

2207
01:49:55,330 --> 01:49:58,960
だから私は、二乗が存在しているxは。

2208
01:49:58,960 --> 01:50:00,660
>> そして今、私はこれを行うつもりです。

2209
01:50:00,660 --> 01:50:03,940
私はちょうど、xが何do--でした
乗？ xの2乗をx倍のxです。

2210
01:50:03,940 --> 01:50:06,690
>> そして、我々はいくつかのこれをしませんでした
今日既に前の時間。

2211
01:50:06,690 --> 01:50:08,730
これは、ように感じることはありません
すべてのその多くの進歩。

2212
01:50:08,730 --> 01:50:09,570
あのね？

2213
01:50:09,570 --> 01:50:13,100
のは、そのアイデアの一部を活用してみましょう
抽象化の最後の時間から。

2214
01:50:13,100 --> 01:50:16,080
>> それがあれば素晴らしいと思いません
呼び出された関数があります

2215
01:50:16,080 --> 01:50:18,460
まさにその正方形の？

2216
01:50:18,460 --> 01:50:20,640
の終わりに、まだそれ、
日、同じ数学を行います。

2217
01:50:20,640 --> 01:50:22,410
しかし、の抽象ましょう
離れて撮影のアイデア

2218
01:50:22,410 --> 01:50:25,280
1数を乗じました
別の、そしてちょうどそれに名前を付け、

2219
01:50:25,280 --> 01:50:27,360
この値は、正方形のような。

2220
01:50:27,360 --> 01:50:29,560
>> そして、換言すれば、内
Cは、の関数を作成してみましょう

2221
01:50:29,560 --> 01:50:32,660
まさにその正方形と呼ばれます。

2222
01:50:32,660 --> 01:50:34,600
正方形と呼ばれるようになるだろう。

2223
01:50:34,600 --> 01:50:35,790
int型を取るために起こっています。

2224
01:50:35,790 --> 01:50:37,820
そして、我々はよだけでしょう
デフォルトでは、nはそれを呼び出します。

2225
01:50:37,820 --> 01:50:39,403
>> しかし、我々は、我々は何でもそれを呼び出すことができます。

2226
01:50:39,403 --> 01:50:42,900
そして、すべてのそれはに起こっていること
、文字通り、リターンですか

2227
01:50:42,900 --> 01:50:45,810
n回nの結果。

2228
01:50:45,810 --> 01:50:48,980
しかし、それはですので、
何かを返す、その

2229
01:50:48,980 --> 01:50:53,690
私たちがきた紫色のキーワードです
私は、11行目に、前に見たことがありません

2230
01:50:53,690 --> 01:50:55,410
ちょうどこの時間を失うと言うことはできません。

2231
01:50:55,410 --> 01:51:01,320
>> 私達はちょうど見た例では、ボイド
むしろ印刷名、ちょうど手段の、

2232
01:51:01,320 --> 01:51:02,190
何かをします。

2233
01:51:02,190 --> 01:51:04,170
しかし、私に何かをバック手はありません。

2234
01:51:04,170 --> 01:51:06,790
この場合、私がしたいですか
n回のn戻り、

2235
01:51:06,790 --> 01:51:08,460
またはそれが何であれ、その数。

2236
01:51:08,460 --> 01:51:12,460
>> だから私は、ちょっと、コンピュータを言うことはできませんが、
私は、ボイド、何も返しません。

2237
01:51:12,460 --> 01:51:16,166
自然によって、int型を返すようになるだろう。

2238
01:51:16,166 --> 01:51:17,790
そして、そのためには、ここで起こっていることすべてです。

2239
01:51:17,790 --> 01:51:20,070
>> 正方形への入力
int型になるだろう。

2240
01:51:20,070 --> 01:51:24,760
我々はそれを使用できるように、そして、それはしてい
これは、出力に起こっているの名称、Nを持っています

2241
01:51:24,760 --> 01:51:26,240
名前を必要としないint型。

2242
01:51:26,240 --> 01:51:29,590
私たちは、主にそれを残すことができ、または誰があります
我々場合は、この値を覚えて私を使用して、

2243
01:51:29,590 --> 01:51:31,120
独自の変数を使用して欲しいです。

2244
01:51:31,120 --> 01:51:33,230
>> そして、再び、唯一の新しいです
ここでのキーワードは戻ります。

2245
01:51:33,230 --> 01:51:34,480
そして、私はいくつかの数学をやっています。

2246
01:51:34,480 --> 01:51:41,825
私は本当に不要になりたかった場合は、
私はint型の製品がn回のnなると言えるでしょう。

2247
01:51:41,825 --> 01:51:44,170
>> そして、私は、製品を返す、と言うことができます。

2248
01:51:44,170 --> 01:51:47,360
しかし、再び、以前の私のポイントに
これはちょうど良いdesign--されていません

2249
01:51:47,360 --> 01:51:50,060
以下のような、なぜ名前を紹介し、
シンボル、製品のように、

2250
01:51:50,060 --> 01:51:51,570
ただ、すぐにそれを返すには？

2251
01:51:51,570 --> 01:51:53,670
それは、少しクリーナーです
そう、少しタイト

2252
01:51:53,670 --> 01:51:59,380
、話すだけのリターンを言うためにn回
nは、完全にこの行を取り除きます。

2253
01:51:59,380 --> 01:52:02,860
>> そして、それは読むためだけ少ないコードです、
間違いのためのより少ないチャンス。

2254
01:52:02,860 --> 01:52:05,180
そして、この場合を見てみましょう
実際に機能するようになりました。

2255
01:52:05,180 --> 01:52:09,380
今、私は行くつもりです
前方と復帰を実行してください。

2256
01:52:09,380 --> 01:52:11,460
>> おっと、関数の暗黙的な宣言。

2257
01:52:11,460 --> 01:52:14,080
私は、前に大したを、このミスを犯していません。

2258
01:52:14,080 --> 01:52:18,950
私はちょうど入力してみましょう、またはハイライト表示して、
コピー、まったく同じ関数プロトタイプ、

2259
01:52:18,950 --> 01:52:21,342
または署名、ここまで機能。

2260
01:52:21,342 --> 01:52:22,800
それとも私は、全体の機能を移動することができます。

2261
01:52:22,800 --> 01:52:23,841
>> しかし、それは少し怠け者です。

2262
01:52:23,841 --> 01:52:24,870
だから我々はそれを行うことはありません。

2263
01:52:24,870 --> 01:52:27,960
今、私はリターンを作ってみましょう
もう一度、スラッシュリターンに点在しています。

2264
01:52:27,960 --> 01:52:32,790
>> xは2 xは4である乗です。
xは3 xは9乗です。

2265
01:52:32,790 --> 01:52:35,300
そして、この関数は思わ
今作業します。

2266
01:52:35,300 --> 01:52:36,550
だから、ここでの違いは何ですか？

2267
01:52:36,550 --> 01:52:42,520
私は、正方形と呼ばれる機能を持っています
私は入力に入れ、この場合、インチ

2268
01:52:42,520 --> 01:52:43,830
そして、私は出力を取り戻します。

2269
01:52:43,830 --> 01:52:46,210
そして、まだ、以前に、もし
私は他の例を開きます

2270
01:52:46,210 --> 01:52:51,640
以前から、その
prototype.cと呼ばれていました、

2271
01:52:51,640 --> 01:52:54,770
I印刷名を有していました
いわば、void型の戻り、

2272
01:52:54,770 --> 01:52:58,730
それとも、何も返されず、
単に副作用を持っていました。

2273
01:52:58,730 --> 01:53:00,230
>> それでは、ここで起こっているの？

2274
01:53:00,230 --> 01:53:03,520
まあ、機能を考えます
ちょっと文字列を取得します。

2275
01:53:03,520 --> 01:53:06,570
私たちは、関数を使用してきました
以下の方法で文字列を取得します。

2276
01:53:06,570 --> 01:53:10,464
>> 私たちは、関数が取得しなければなりませんでした
CS50.hを含むような文字列、

2277
01:53:10,464 --> 01:53:16,624
標準IO.h、int型、メイン、空隙を含みます。

2278
01:53:16,624 --> 01:53:18,790
そして、私がしたすべての時間を
これまでのget文字列と呼ばれ、

2279
01:53:18,790 --> 01:53:23,260
私は、文字列s、のようなものを言いました
取得string--ので、文字列を取得します

2280
01:53:23,260 --> 01:53:27,880
それでは、このget.c-- GET文字列を呼びましょう
それ自体、私はそれからできた文字列を返します。

2281
01:53:27,880 --> 01:53:32,050
カンマ、使用、およびこんにちは、言います、
パーセント秒、バックスラッシュN、S。

2282
01:53:32,050 --> 01:53:35,660
>> だから、これは同じ例で、
本当に、私たちは以前持っていたこと。

2283
01:53:35,660 --> 01:53:37,920
だから、文字列が値を返す取得します。

2284
01:53:37,920 --> 01:53:41,260
しかし、先ほど、印字文字列
値を返しません。

2285
01:53:41,260 --> 01:53:42,721
単に副作用を有します。

2286
01:53:42,721 --> 01:53:44,220
これは根本的な違いがあります。

2287
01:53:44,220 --> 01:53:46,710
我々は、さまざまな見てきました
今機能の種類、

2288
01:53:46,710 --> 01:53:49,490
そのうちのいくつかは戻ってきました
値は、そのうちのいくつかにはありません。

2289
01:53:49,490 --> 01:53:51,890
だから、多分それは、文字列、またはint型、またはフロートです。

2290
01:53:51,890 --> 01:53:53,480
それともそれだけで無効です。

2291
01:53:53,480 --> 01:53:55,710
>> そして、の差であります
これらの機能は、そのこと

2292
01:53:55,710 --> 01:53:59,940
データを取得し、値を返す実際にあります
テーブルに戻って何かをもたらし、

2293
01:53:59,940 --> 01:54:01,110
いわば。

2294
01:54:01,110 --> 01:54:03,710
それでは、先に行くとしましょう
1最終セットを見て

2295
01:54:03,710 --> 01:54:09,129
今、感覚を与える例の、の
どのように我々はかもしれないが、確かに、抽象的、より良いです、

2296
01:54:09,129 --> 01:54:11,670
より良い、より良い、またはそれ以上、
順番に、そしてより多くの、そしてより

2297
01:54:11,670 --> 01:54:13,810
、最終的には、より良いコードを書くため。

2298
01:54:13,810 --> 01:54:16,860
のは、先に行ってみよう、と精神で
スクラッチの、次の操作を行います。

2299
01:54:16,860 --> 01:54:21,700
>> 私は先に行ってみようと含み
CS50.hと標準IO.h.

2300
01:54:21,700 --> 01:54:24,010
私が先に行くと挙げてみましょう
自分のint、メイン、ボイド。

2301
01:54:24,010 --> 01:54:27,380
そして、このcough.cを呼び出し、私は先に行ってみましょう。

2302
01:54:27,380 --> 01:54:35,510
>> そして、私が先にだけ行ってみよう
スクラッチのように、咳/ Nをプリントアウト。

2303
01:54:35,510 --> 01:54:37,170
そして、私はこの3回やってみたいです。

2304
01:54:37,170 --> 01:54:39,670
だから私は、もちろん、ちょうどつもりです
3回をコピーして貼り付けます。

2305
01:54:39,670 --> 01:54:46,440
私は今作るつもりです
ドットスラッシュ咳を咳。

2306
01:54:46,440 --> 01:54:50,120
のは、自分自身に少しより多くの部屋を与えてみましょう
ここでは、咳、咳、咳、入力します。

2307
01:54:50,120 --> 01:54:53,970
>> すでに、明らかに、あります
改善の機会。

2308
01:54:53,970 --> 01:54:55,679
私はコピーして貼り付けました
数回今日。

2309
01:54:55,679 --> 01:54:58,261
しかし、それはだけなので、私はしませんでした
など、多くの文字を入力する必要があります。

2310
01:54:58,261 --> 01:55:00,250
私はまだ何が変わっ
コー​​ドのこれらの行があります。

2311
01:55:00,250 --> 01:55:04,240
>> これらの3行は同一であり、
これは実際に怠惰な感じていると、

2312
01:55:04,240 --> 01:55:07,110
そしておそらく正しいアプローチではありません。

2313
01:55:07,110 --> 01:55:11,029
どのような成分とだから
私たちは、このコードを改善することができますか？

2314
01:55:11,029 --> 01:55:12,570
私たちは、コピー＆ペーストコードする必要はありません。

2315
01:55:12,570 --> 01:55:15,070
>> そして、確かに、あなたが感じるあらゆる時間
自分がコピー＆ペースト、

2316
01:55:15,070 --> 01:55:17,700
さらには、コードを変更しません
オッズは良い方法はあります。

2317
01:55:17,700 --> 01:55:19,470
そして、実際に、存在します。

2318
01:55:19,470 --> 01:55:22,510
私が先に行くと、forループをやってみましょう、
でも、構文はないかもしれないが

2319
01:55:22,510 --> 01:55:24,570
まだ自然に来ます。

2320
01:55:24,570 --> 01:55:29,494
>> 単純に、この3回の操作を行います
following--を実行して、

2321
01:55:29,494 --> 01:55:31,160
そして、私は練習からこれを知ることが起こります。

2322
01:55:31,160 --> 01:55:32,810
しかし、我々は今の例の数を持っています。

2323
01:55:32,810 --> 01:55:34,950
そして、あなたは、オンラインで表示されます
まだ複数の参照。

2324
01:55:34,950 --> 01:55:37,790
>> これはことを、6行目の構文です
繰り返されるスクラッチのような多くの

2325
01:55:37,790 --> 01:55:40,090
ブロックは、次の3回繰り返します。

2326
01:55:40,090 --> 01:55:41,340
それは、今のところ少し魔法です。

2327
01:55:41,340 --> 01:55:43,050
しかし、これは多くを得るだろう、
そしてもっと身近。

2328
01:55:43,050 --> 01:55:45,050
>> そして、繰り返しになるだろう
ライン8 3回、

2329
01:55:45,050 --> 01:55:52,390
私があればメイク咳を再コンパイルするように、
ドットスラッシュ咳、咳、咳、咳。

2330
01:55:52,390 --> 01:55:54,030
それはまだ同じように動作します。

2331
01:55:54,030 --> 01:55:55,550
だから、すべての罰金と良いです。

2332
01:55:55,550 --> 01:55:58,200
しかし、それは非常に抽象化ではありません。

2333
01:55:58,200 --> 01:55:59,371
>> それは完全に正しいです。

2334
01:55:59,371 --> 01:56:01,370
しかし、それはそこのように感じています
機会かもしれません、

2335
01:56:01,370 --> 01:56:03,750
の世界のように、
開始の種類にスクラッチ、

2336
01:56:03,750 --> 01:56:07,530
ように、ここでいくつかのセマンティクスを追加します
私は、ループのためのいくつかを持っていません

2337
01:56:07,530 --> 01:56:09,867
言うと機能
咳、または咳ありません。

2338
01:56:09,867 --> 01:56:10,450
あのね？

2339
01:56:10,450 --> 01:56:12,620
私はあることを試してみましょう
それより少しクーラー

2340
01:56:12,620 --> 01:56:16,090
そして、実際にその機能を書きます
いくつかの副作用があり、それは咳を呼び出します。

2341
01:56:16,090 --> 01:56:20,830
>> そして、それは何の入力を取らず、
出力として値を返しません。

2342
01:56:20,830 --> 01:56:22,680
しかし、あなたはそれが何を知っていますか？

2343
01:56:22,680 --> 01:56:29,370
それはthis--のprintfを行い、
引用終わり、咳を引用。

2344
01:56:29,370 --> 01:56:32,380
>> そして今ここに、私が行きますよ
先に行くと、int型のためにするために、

2345
01:56:32,380 --> 01:56:36,070
私は、私プラスプラス、ゼロを取得し、私未満3。

2346
01:56:36,070 --> 01:56:39,770
私はある、のprintfをしないつもりです
間違いなく、低レベルの実装

2347
01:56:39,770 --> 01:56:40,270
詳細。

2348
01:56:40,270 --> 01:56:41,353
私は咳をする方法を気にしません。

2349
01:56:41,353 --> 01:56:43,240
私は咳の機能を使用したいです。

2350
01:56:43,240 --> 01:56:44,840
そして私はちょうど咳を呼ぶつもりです。

2351
01:56:44,840 --> 01:56:46,204
>> 今、二分法に注目してください。

2352
01:56:46,204 --> 01:56:49,370
そうしない場合は、関数を呼び出すとき
それは完全に罰金、入力与えたいです。

2353
01:56:49,370 --> 01:56:51,780
ちょうど近くに、オープン括弧を行います
括弧、とすれば完了です。

2354
01:56:51,780 --> 01:56:56,271
>> あなたは、関数を定義するとき、または
関数のプロトタイプを宣言し、

2355
01:56:56,271 --> 01:56:58,770
あなたが事前に知っていればそうではありません
任意の引数を取るつもり、

2356
01:56:58,770 --> 01:57:01,170
そこにそれらの括弧内のボイドと言います。

2357
01:57:01,170 --> 01:57:05,660
そして、それはある種のあなたのことになります
誤ってそれを悪用しません。

2358
01:57:05,660 --> 01:57:07,020
私が先に行くと咳をしてみましょう。

2359
01:57:07,020 --> 01:57:08,540
そして、もちろん、私はミスを犯しました。

2360
01:57:08,540 --> 01:57:10,410
>> くそ、ということがあります
暗黙的な宣言。

2361
01:57:10,410 --> 01:57:11,325
しかし、それは大丈夫です。

2362
01:57:11,325 --> 01:57:12,590
それは簡単な修正です。

2363
01:57:12,590 --> 01:57:18,240
私はちょうど高いプロトタイプを必要とします
私のファイルに私は実際にそれを使用していますより。

2364
01:57:18,240 --> 01:57:20,070
>> だから今素敵な、私は再び咳をしてみましょう。

2365
01:57:20,070 --> 01:57:20,790
今、それは動作します。

2366
01:57:20,790 --> 01:57:22,930
咳、咳、咳、咳をしてください。

2367
01:57:22,930 --> 01:57:25,930
だから、私たちは本当にだと思うかもしれません
ただ、この問題は過剰性能。

2368
01:57:25,930 --> 01:57:26,763
そして、確かに、私たちはあります。

2369
01:57:26,763 --> 01:57:28,870
これは良いではありません
プログラムの候補

2370
01:57:28,870 --> 01:57:31,930
以下のため現時点では
リファクタリング、そして何やって

2371
01:57:31,930 --> 01:57:35,645
階層的な分解と呼ばれます
どこにいくつかのコードを取り、その後、

2372
01:57:35,645 --> 01:57:38,790
ようにあなたの種類の因子物事うち、
彼らにもっと意味を帰するために、

2373
01:57:38,790 --> 01:57:40,930
それ最終的に長期的な再利用します。

2374
01:57:40,930 --> 01:57:43,490
しかし、それは向かってビルディングブロックです
より洗練されたプログラム

2375
01:57:43,490 --> 01:57:45,600
我々が開始されること
やがてその書き込み

2376
01:57:45,600 --> 01:57:50,090
私たちは語彙を持つことができます
これでより良いコードを書くため。

2377
01:57:50,090 --> 01:57:52,920
そして、確かに、私たちどうかを見てみましょう
これをさらに一般化することはできません。

2378
01:57:52,920 --> 01:57:57,984
>> それは、そのI、主少しラメようです
ループのために、このくそを心配する必要があり、

2379
01:57:57,984 --> 01:57:59,400
そして、何度も何度も咳を呼び出します。

2380
01:57:59,400 --> 01:58:03,050
なぜ私は、咳を伝えることはできません
3回咳してください？

2381
01:58:03,050 --> 01:58:08,170
ただ言い換えれば、なぜできない私
咳とこれを行うための入力を与えますか？

2382
01:58:08,170 --> 01:58:11,270
>> なぜ私だけでは、と言うことはできません
メイン咳3回。

2383
01:58:11,270 --> 01:58:13,150
そして今、これは一種の魔法です。

2384
01:58:13,150 --> 01:58:14,540
ここは非常に反復的です。

2385
01:58:14,540 --> 01:58:15,940
そしてそれは、確かに、赤ちゃんのステップです。

2386
01:58:15,940 --> 01:58:19,250
>> しかし、単に能力が上と言って
ライン8、3回の咳、

2387
01:58:19,250 --> 01:58:20,730
それはちょうどそんなにより読みやすいです。

2388
01:58:20,730 --> 01:58:24,210
そして、プラス、私が知っている必要はありません
または咳がどのように実装されるか気になります。

2389
01:58:24,210 --> 01:58:26,460
そして、確かに、それ以降で
用語と最終プロジェクトのため、

2390
01:58:26,460 --> 01:58:29,150
あなたがプロジェクトに取り組む場合
同級生または2クラスメート、

2391
01:58:29,150 --> 01:58:32,370
あなたがしようとしていることを実現します
持っている、または、作業を分割したいです。

2392
01:58:32,370 --> 01:58:34,650
>> そして、あなたが決めたいとしています
事前に、誰が何をするつもりです、

2393
01:58:34,650 --> 01:58:35,483
どの作品で？

2394
01:58:35,483 --> 01:58:37,520
そして、それは素晴らしいではないでしょう
あなたの場合、例えば、

2395
01:58:37,520 --> 01:58:40,100
行われ、メインの書き込みを担当します。

2396
01:58:40,100 --> 01:58:43,470
そして、あなたのルームメイト、またはあなたの
相手より一般的には、

2397
01:58:43,470 --> 01:58:45,230
咳を実装するの面倒を見ます。

2398
01:58:45,230 --> 01:58:49,540
>> そして、この部門は、これらの
抽象化の壁、

2399
01:58:49,540 --> 01:58:52,310
抽象または層の場合
あなたは、超強力であります、

2400
01:58:52,310 --> 01:58:55,480
特に大規模用のため、
より複雑なプログラムやシステム、

2401
01:58:55,480 --> 01:59:00,070
それは、複数の人が構築することができます
物事一緒に、そして最終的に

2402
01:59:00,070 --> 01:59:02,680
このように一緒に自分の仕事をステッチ。

2403
01:59:02,680 --> 01:59:05,332
しかし、当然のことながら、我々
今咳を修正する必要があります。

2404
01:59:05,332 --> 01:59:07,290
私たちは、咳を指示する必要があります
その、ちょっと、あなたは何を知っていますか？

2405
01:59:07,290 --> 01:59:11,230
あなたが取る必要があるとしています
そう空洞ではないが、今はint型とinput--。

2406
01:59:11,230 --> 01:59:15,170
それでは、先に行くと中に入れてみましょう
int型を咳。私はゼロを取得します。

2407
01:59:15,170 --> 01:59:16,890
>> 私は何回未満です。

2408
01:59:16,890 --> 01:59:18,550
私は3を前に述べました。

2409
01:59:18,550 --> 01:59:20,420
しかし、それは私が欲しいものではありません。

2410
01:59:20,420 --> 01:59:25,520
私は咳がに一般化することにしたいです
任意の回数の反復をサポートしています。

2411
01:59:25,520 --> 01:59:28,800
>> だから、確かに、それは、私が欲しいのnです
どのようなユーザーが私に語りました。

2412
01:59:28,800 --> 01:59:31,620
今、私は先に行くと、印刷咳を言うことができます。

2413
01:59:31,620 --> 01:59:34,750
そして、何があっ番号
ユーザーは渡し、

2414
01:59:34,750 --> 01:59:36,890
私は何度も繰り返されます。

2415
01:59:36,890 --> 01:59:39,160
>> だから一日の終わりに、
プログラムは同じです。

2416
01:59:39,160 --> 01:59:42,820
しかし、このようなもののすべてに気づきます
でも、別のファイルである可能性があります。

2417
01:59:42,820 --> 01:59:45,620
確かに、私はで知りません
printf関数がどのように実装されるかの瞬間。

2418
01:59:45,620 --> 01:59:47,980
>> 私が取得する方法現時点では分かりません
文字列、またはint型を取得、またはフロートを取得

2419
01:59:47,980 --> 01:59:48,646
実装されています。

2420
01:59:48,646 --> 01:59:50,930
そして、私はしたくありません
私の画面上でそれらを参照してください。

2421
01:59:50,930 --> 01:59:55,320
それがあるように、私が注力し始めています
私のプログラムではなく、それらの機能。

2422
01:59:55,320 --> 01:59:59,070
>> そしてそう、確かに、できるだけ早くあなたのような
このようなコードを因数分解開始、

2423
01:59:59,070 --> 02:00:01,397
私たちも、咳を移動することができます
別のファイルへ？

2424
02:00:01,397 --> 02:00:02,730
他の誰かがそれを実装することができます。

2425
02:00:02,730 --> 02:00:06,810
そして、あなたとあなたのプログラムになっ
非常に美しく、そして非常に読みやすいです、

2426
02:00:06,810 --> 02:00:10,830
間違いなく、本当に4
右がラインプログラム。

2427
02:00:10,830 --> 02:00:13,510
>> それでは、今先に行きましょう
そしてもう一つの変更を行います。

2428
02:00:13,510 --> 02:00:16,180
お知らせ私のプロトタイプ
トップを変更する必要があります。

2429
02:00:16,180 --> 02:00:18,390
だから私は非常にこれを修正しましょう
私は怒鳴られません。

2430
02:00:18,390 --> 02:00:22,580
>> 咳を行い、私は一度咳を実行してみましょう
より、まだ同じことをやって。

2431
02:00:22,580 --> 02:00:26,010
しかし、今、私たちが持って気付きます
1最終バージョンのための成分。

2432
02:00:26,010 --> 02:00:26,940
あのね？

2433
02:00:26,940 --> 02:00:29,040
私は必ずしも、咳する必要はありません。

2434
02:00:29,040 --> 02:00:30,802
私はより一般的な何かを持っていると思います。

2435
02:00:30,802 --> 02:00:31,510
だからあなたは何を知っていますか？

2436
02:00:31,510 --> 02:00:32,450
私はこれをやってみたいです。

2437
02:00:32,450 --> 02:00:37,140
私は多くのスクラッチのように、持っていたいです
、たとえばブロックを行い、それだけではありません

2438
02:00:37,140 --> 02:00:38,680
何か何回か言います。

2439
02:00:38,680 --> 02:00:41,510
私はそれが非常に特定の文字列を言いたいです。

2440
02:00:41,510 --> 02:00:43,850
そして、そのため、私はしないでください
それだけで咳を言いたいです。

2441
02:00:43,850 --> 02:00:47,660
私はそれが何でも言いたいです
文字列が渡されます。

2442
02:00:47,660 --> 02:00:49,960
>> だから私は一般ましたが、気付きます
このように今では

2443
02:00:49,960 --> 02:00:53,110
良い名前のように感じていると言います
このため、スクラッチのような、

2444
02:00:53,110 --> 02:00:55,530
スクラッチとは異なり、2つの引数をとります。

2445
02:00:55,530 --> 02:00:56,570
一つは文字列です。

2446
02:00:56,570 --> 02:00:57,300
一つはintです。

2447
02:00:57,300 --> 02:00:58,130
>> そして、私はそれらを切り替えることができます。

2448
02:00:58,130 --> 02:01:00,713
私だけの種類のアイデアのように
その後、最初の文字列を言うと、

2449
02:01:00,713 --> 02:01:01,940
何回以降。

2450
02:01:01,940 --> 02:01:03,970
ボイドがまだそれを意味します
何も返しません。

2451
02:01:03,970 --> 02:01:06,428
これらは、単に視覚的な側面であります
【持つような効果、？ヨルダン、？]

2452
02:01:06,428 --> 02:01:08,240
叫んでの口頭副作用。

2453
02:01:08,240 --> 02:01:12,630
それでも、何かn回行い
0までが、nと等しくありません。

2454
02:01:12,630 --> 02:01:14,540
これは、n個の合計時間を意味します。

2455
02:01:14,540 --> 02:01:16,540
そして、ちょうどプリントアウト
どのような文字列があります。

2456
02:01:16,540 --> 02:01:19,060
だから私は本当に一般化しました
このコード行。

2457
02:01:19,060 --> 02:01:22,460
だから今、どのように私は実装しません
咳機能？

2458
02:01:22,460 --> 02:01:25,520
>> 私は、ボイド咳を行うことができます。

2459
02:01:25,520 --> 02:01:28,501
そして、私はまだどのように取り込むことができます
何回あなたが咳をしたいです。

2460
02:01:28,501 --> 02:01:29,250
しかし、あなたは何を知っていますか？

2461
02:01:29,250 --> 02:01:31,240
私は今言うことをパントすることができます。

2462
02:01:31,240 --> 02:01:36,540
>> 私はと言う呼び出すことができます
ワード咳、n個を渡します。

2463
02:01:36,540 --> 02:01:40,410
そして、私はまた、実装したい場合は、
ちょうど楽しみのために、くしゃみ機能、

2464
02:01:40,410 --> 02:01:42,290
私は何回かくしゃみすることができます。

2465
02:01:42,290 --> 02:01:47,300
そして、私はので、n個を再利用し続けることができます
このコンテキストまたはスコープでそのメートルに気付きます

2466
02:01:47,300 --> 02:01:49,470
この関数内でのみ存在します。

2467
02:01:49,470 --> 02:01:52,767
>> そして、nはこの文脈でのみ
ここでは、この関数内に存在します。

2468
02:01:52,767 --> 02:01:54,600
だから我々は戻ってくるだろう
スコープのこれらの問題。

2469
02:01:54,600 --> 02:02:01,160
そしてここで、私は言うつもりです、
アチュー、次にn回、セミコロン。

2470
02:02:01,160 --> 02:02:04,340
>> そして今、私はちょうど借りる必要が
これらの機能は、ここにシグネチャ。

2471
02:02:04,340 --> 02:02:06,290
だから咳が正しいです。

2472
02:02:06,290 --> 02:02:10,090
ボイドくしゃみは正しくなりました。

2473
02:02:10,090 --> 02:02:12,390
>> そして、私はまだちょうど言う必要があります。

2474
02:02:12,390 --> 02:02:18,990
だから私は言う、と言うつもりです
文字列s、int型のn、セミコロン。

2475
02:02:18,990 --> 02:02:22,010
だから私は過剰設計されました
このプログラムのうち一体。

2476
02:02:22,010 --> 02:02:23,760
>> そして、これはそうではありません
必ずしもこれがある意味

2477
02:02:23,760 --> 02:02:26,343
書くとき、あなたは何をすべきか
プログラムの最も単純な。

2478
02:02:26,343 --> 02:02:29,280
明らかに何かを取ります
本当に短い、本当に簡単、

2479
02:02:29,280 --> 02:02:31,800
それを再実装
あまりにも多くのコードを使用して。

2480
02:02:31,800 --> 02:02:34,560
しかし、あなたが実際に見て、でます
時間は、これらの例を振り返ります

2481
02:02:34,560 --> 02:02:38,610
とまあ、それらはステップであり、実現
私たちは、実際に一般化するのにかかりました

2482
02:02:38,610 --> 02:02:40,797
何かを考慮するために、
一日の終わりまで

2483
02:02:40,797 --> 02:02:42,380
私のコードは実際にはかなり合理的です。

2484
02:02:42,380 --> 02:02:45,960
私は3を咳したい場合ので、
時間はその後、三回くしゃみ

2485
02:02:45,960 --> 02:02:50,420
私は単にこれを再実行するつもりです、
プログラムは、咳をする、と咳を実行します。

2486
02:02:50,420 --> 02:02:53,620
そして、私は3咳を持っています
そして3くしゃみ。

2487
02:02:53,620 --> 02:02:55,990
>> そして、これは基本的なもの
パラダイム、可能ならば、

2488
02:02:55,990 --> 02:03:00,110
私たちが行くかもしれない方法について
実際にプログラムを実装します。

2489
02:03:00,110 --> 02:03:03,220
しかし、ちょうどそれが何であるかを見てみましょう
我々は、この時間のすべてを行ってきました

2490
02:03:03,220 --> 02:03:06,940
そして、どのような最終的な作品の一部
この単純なコマンドの背後にあります。

2491
02:03:06,940 --> 02:03:09,620
一日の終わりに、我々はしました
私たちのコンパイラとしてクランを使用して。

2492
02:03:09,620 --> 02:03:11,494
私たちは、ソースを書いてきました
コー​​ドは、それを変換します

2493
02:03:11,494 --> 02:03:12,820
クラン経由して機械語コードに変換します。

2494
02:03:12,820 --> 02:03:15,540
>> そして、私たちはただ作る使用してきました
そう私達のキーストロークを容易にするために、

2495
02:03:15,540 --> 02:03:20,740
私たちは覚えておく必要はありません
クラン自体のもの呪文。

2496
02:03:20,740 --> 02:03:22,640
しかし、実際にやってください何ですか？

2497
02:03:22,640 --> 02:03:24,750
そして、今度は、何ですか
クランは、実際にやって？

2498
02:03:24,750 --> 02:03:28,790
>> 我々は単純化していてもそれは、判明します
言うことで、今日の議論、

2499
02:03:28,790 --> 02:03:33,090
あなたは、ソースコードを取るようにそれを渡します
あなたを与えるコンパイラに入力

2500
02:03:33,090 --> 02:03:35,750
マシンの出力
コー​​ドは、そこのが判明します

2501
02:03:35,750 --> 02:03:37,420
そこに内部のいくつかの異なるステップ。

2502
02:03:37,420 --> 02:03:41,940
そして、コンパイルは傘であることを起こります
手順の全体の束のための用語。

2503
02:03:41,940 --> 02:03:43,970
しかし、ちょうどからかうてみましょう
このうち本当にすぐ。

2504
02:03:43,970 --> 02:03:48,070
>> それは我々が行ってきたことが判明します
より多くのもの、私はプログラムを実行するたびに、

2505
02:03:48,070 --> 02:03:50,990
または私は今日のプログラムをコンパイルするたびに。

2506
02:03:50,990 --> 02:03:55,020
だから、前処理はを指し、
Cプログラムには何もthis--、

2507
02:03:55,020 --> 02:03:58,720
私たちは何度も何度もわかるように、
それは、このハッシュ記号で始まります

2508
02:03:58,720 --> 02:04:03,320
または、ここでハッシュタグ記号は、意味します
それは、プリプロセッサ指令です。

2509
02:04:03,320 --> 02:04:07,330
それはちょっと、この場合には、意味します
コンピュータは、このファイルを使用して何かを行います

2510
02:04:07,330 --> 02:04:09,430
あなたが実際に自分自身のコードをコンパイルする前に。

2511
02:04:09,430 --> 02:04:15,220
>> この場合には、ハッシュが含まれ、
のは、本質的に、Cの方法、

2512
02:04:15,220 --> 02:04:19,325
ちょっとコンピュータ、内容を取りに行きます
CS50.hのとそれらをここに貼り付けます。

2513
02:04:19,325 --> 02:04:22,170
ねえ、コンピュータ、取りに行きます
標準IO.hの内容、

2514
02:04:22,170 --> 02:04:24,690
どこそれがオン
ハードドライブ、それをここに貼り付けます。

2515
02:04:24,690 --> 02:04:27,390
だから、これらのことが起こります
前処理時に最初に。

2516
02:04:27,390 --> 02:04:28,880
>> そして、クランは私たちのためにこのすべてを行います。

2517
02:04:28,880 --> 02:04:30,510
そして、それはとてもくそそれをしません
速い、あなたもありません

2518
02:04:30,510 --> 02:04:32,000
4つの異なる事が起こって参照してください。

2519
02:04:32,000 --> 02:04:34,100
しかし、それは最初のような工程です。

2520
02:04:34,100 --> 02:04:35,560
>> 何が実際に次に起こりますか？

2521
02:04:35,560 --> 02:04:38,320
さて、次の公式
ステップがコンパイルされています。

2522
02:04:38,320 --> 02:04:40,385
そして、それはことが判明します
プログラムをコンパイル

2523
02:04:40,385 --> 02:04:44,060
技術的に行くから意味
ソースコード、私たちがきたもの

2524
02:04:44,060 --> 02:04:47,890
何かに、今日書いて
何か、アセンブリコードと呼ばれます

2525
02:04:47,890 --> 02:04:49,260
それは少し違って見えます。

2526
02:04:49,260 --> 02:04:51,050
>> そして、実際には、我々は本当に速いこれを見ることができます。

2527
02:04:51,050 --> 02:04:53,890
私は実際に私のIDEに行ってみましょう。

2528
02:04:53,890 --> 02:04:58,050
私は先に行ってみようとオープンのhello.c、その
私たちと非常に最初のプログラムです

2529
02:04:58,050 --> 02:04:59,120
今日始まりました。

2530
02:04:59,120 --> 02:05:04,130
そして、私が先に行くとクランaを実行してみましょう
少し違った、クラン-S、hello.cに、

2531
02:05:04,130 --> 02:05:07,720
実際にしようとしています
私は別のファイルhello.sを与えます。

2532
02:05:07,720 --> 02:05:10,330
>> そして、我々は、おそらく決して
再び、この種のコードを参照してください。

2533
02:05:10,330 --> 02:05:13,030
あなたは、より低いレベルをとる場合
CS61のようなシステムクラス、

2534
02:05:13,030 --> 02:05:14,920
あなたがより多く表示されます
この種のコードの。

2535
02:05:14,920 --> 02:05:17,020
しかし、これはアセンブリ言語です。

2536
02:05:17,020 --> 02:05:22,050
これは、X86アセンブリ言語であります
その根底にされるCPU

2537
02:05:22,050 --> 02:05:24,460
CS50 IDEが実際に理解しています。

2538
02:05:24,460 --> 02:05:27,060
>> そして、それは不可解そうであるよう
それは何かである、見て

2539
02:05:27,060 --> 02:05:29,180
コンピュータはかなりよく理解しています。

2540
02:05:29,180 --> 02:05:30,790
サブqが、これは減算です。

2541
02:05:30,790 --> 02:05:31,660
動きがあります。

2542
02:05:31,660 --> 02:05:35,730
>> ここでは関数の呼び出しがあります、
X OR演算、移動、追加、ポップ、

2543
02:05:35,730 --> 02:05:36,430
リターン。

2544
02:05:36,430 --> 02:05:38,850
だから、いくつかは非常にあります
低レベル命令

2545
02:05:38,850 --> 02:05:41,280
CPUはことを理解していること
私は以前に言及しました。

2546
02:05:41,280 --> 02:05:43,100
それはどのようなインテルインサイドです。

2547
02:05:43,100 --> 02:05:45,030
>> のパターンがあります
0と1という

2548
02:05:45,030 --> 02:05:51,800
これらarcanely言葉遣いにマップが、
幾分よく名前の、命令、

2549
02:05:51,800 --> 02:05:52,780
いわば。

2550
02:05:52,780 --> 02:05:54,780
それはときに起こることです
あなたのコードをコンパイルします。

2551
02:05:54,780 --> 02:05:58,560
あなたは、アセンブリを取得します
それのうち、言語、どの

2552
02:05:58,560 --> 02:06:04,680
第三段階は、組み立てることであることを意味します
そのアセンブリコードに、最終的には、

2553
02:06:04,680 --> 02:06:09,080
0と1 code--マシンではなく、
私たちはちょっと前に見たテキスト。

2554
02:06:09,080 --> 02:06:13,370
>> だから、前処理、それは見つけるん
そして、交換して、いくつか他のもの。

2555
02:06:13,370 --> 02:06:16,430
コンパイルは、ソースを取ります
Cソースコードからコード

2556
02:06:16,430 --> 02:06:18,980
我々は、アセンブリに、書きました
私たちはちらっと見コード。

2557
02:06:18,980 --> 02:06:22,170
組み立ては、そのアセンブリを取り
0と1のコード

2558
02:06:22,170 --> 02:06:24,680
CPU本当に意志います
一日の終わりに理解しています。

2559
02:06:24,680 --> 02:06:27,630
そして、リンクは最後のステップです
それは、再びus--ために起こります

2560
02:06:27,630 --> 02:06:29,830
そんなに早く私たちもしません
言いますnotice--、

2561
02:06:29,830 --> 02:06:32,460
ちょっとコンピュータは、すべてを取ります
0と1という

2562
02:06:32,460 --> 02:06:36,750
ダビデのコードをコンパイルから生じました、
この場合の彼の主な機能。

2563
02:06:36,750 --> 02:06:39,160
>> そしてちょっとコンピュータ、取りに行きます
0と1のすべて

2564
02:06:39,160 --> 02:06:42,180
CS50のスタッフが書きました
CS50ライブラリの内部。

2565
02:06:42,180 --> 02:06:43,440
ダビデの持つもので混ぜます。

2566
02:06:43,440 --> 02:06:46,648
そして、ちょっとコンピュータは、すべてゼロを取りに行きます
他の誰かが年に書いたことを、どれ

2567
02:06:46,648 --> 02:06:47,470
printfのための前。

2568
02:06:47,470 --> 02:06:49,880
とにそれらを追加します。
全部、私たちがきたように、

2569
02:06:49,880 --> 02:06:52,870
、私の0と1を得ました
CS50スタッフの0と1、

2570
02:06:52,870 --> 02:06:55,370
printf関数の0と1、
そして何か他のものは、我々が使用しています。

2571
02:06:55,370 --> 02:07:00,410
>> 彼らはすべて1にまとめます
プログラムは、こんにちは、この場合には、と呼ばれます。

2572
02:07:00,410 --> 02:07:03,141
だから今後、私達はちょうどます
単語のコンパイルを使用しています。

2573
02:07:03,141 --> 02:07:06,390
そして、私たちは与えられたとき、そのためになります
我々は、それが意味する、あなたのプログラムをコンパイルし、言います

2574
02:07:06,390 --> 02:07:08,849
ちょっと前処理を行い、
組み立て、およびリンク。

2575
02:07:08,849 --> 02:07:11,890
しかし、実際にいくつかのジューシーなものがあります
ボンネットの下にそこに起こっています。

2576
02:07:11,890 --> 02:07:13,723
そして、特にあなたの場合
好奇心旺盛ないくつかの時間を取得し、

2577
02:07:13,723 --> 02:07:15,900
あなたが突っつい開始することができます
この下位レベルの周り。

2578
02:07:15,900 --> 02:07:19,660
しかし、今のところ、それを実現します
今日のために持ち帰りうち、

2579
02:07:19,660 --> 02:07:23,420
非常に単純です
プロセスの始まり、

2580
02:07:23,420 --> 02:07:26,700
に慣れるの
ハロー世界のようなもの。

2581
02:07:26,700 --> 02:07:29,575
実際、我々が今日やったことのほとんど
確かに超高速に沈むことはありません。

2582
02:07:29,575 --> 02:07:31,491
そして、それはいくつかかかります
時間、およびいくつかの練習。

2583
02:07:31,491 --> 02:07:33,864
そして、オッズは、あなたがソートされ、あります
キーボードを打つしたいです

2584
02:07:33,864 --> 02:07:34,780
または、画面で叫びます。

2585
02:07:34,780 --> 02:07:35,880
そして、それのすべてがOKです。

2586
02:07:35,880 --> 02:07:38,320
しかし、おそらくしないようにしよう
そんなにライブラリでそれを行います。

2587
02:07:38,320 --> 02:07:40,820
>> そして最終的に、あなたはよ
開始するには、しかしことができます

2588
02:07:40,820 --> 02:07:44,580
パターンを見て、両方の良いコードに
あなたが書いたことやミスで

2589
02:07:44,580 --> 02:07:45,370
あなたが行ったこと。

2590
02:07:45,370 --> 02:07:48,965
とのプロセスのような多くの
TFになってきまたはCAが似ています、

2591
02:07:48,965 --> 02:07:51,590
あなたが良くなってから始めましょうと
これらのパターンを見てでは、より良いです、

2592
02:07:51,590 --> 02:07:53,774
そしてちょうどあなたを解きます
最終的に自身の問題。

2593
02:07:53,774 --> 02:07:56,940
一方で、たくさんあるだろう
あなたのサポートを貸す、とあなたを得るために私達の

2594
02:07:56,940 --> 02:07:57,481
これを通して。

2595
02:07:57,481 --> 02:07:59,450
そして、書き込みアップで
問題のすべてのために

2596
02:07:59,450 --> 02:08:01,366
あなたが通って案内されます
すべてのコマンド

2597
02:08:01,366 --> 02:08:05,330
私は確かに知っていること
今ではたくさんの練習、

2598
02:08:05,330 --> 02:08:07,380
しかし飛行している可能性があります
今の頭の上に。

2599
02:08:07,380 --> 02:08:08,580
そして、それは完全に罰金です。

2600
02:08:08,580 --> 02:08:11,230
>> しかし、最終的に、あなたが行っています
見に開始するパターンが出現します。

2601
02:08:11,230 --> 02:08:14,260
そして、あなたはすべてを乗り越える度
愚かな詳細、括弧のような、

2602
02:08:14,260 --> 02:08:16,710
そして、中括弧、およびセミコロン、
とか、率直に言って、

2603
02:08:16,710 --> 02:08:19,360
それがすべてではありません
知的興味深いです。

2604
02:08:19,360 --> 02:08:22,690
そして、それはの目的ではありません
任意の入門クラスを取ります。

2605
02:08:22,690 --> 02:08:24,410
それは問題ではしようとしているのアイデアです。

2606
02:08:24,410 --> 02:08:26,659
>> それはループだし、
条件、および機能、

2607
02:08:26,659 --> 02:08:30,552
そしてより強力に抽象化、
そして、コードのファクタリング、

2608
02:08:30,552 --> 02:08:33,510
そして、優れたデザイン、そして良いです
スタイル、そして最終的に正し

2609
02:08:33,510 --> 02:08:37,330
あなたのコードの、それは最終的です
最も重要になるだろう。

2610
02:08:37,330 --> 02:08:40,925
だから来週、我々はこれらがかかります
我々は最初のスクラッチで見たアイデア

2611
02:08:40,925 --> 02:08:42,800
そして今翻訳しました
Cにそして、私たちは始めましょう

2612
02:08:42,800 --> 02:08:45,740
の最初に紹介しま​​す
コー​​スの実世界のドメイン。

2613
02:08:45,740 --> 02:08:50,140
>> 私たちは、セキュリティの世界に焦点を当てます
より具体的には、暗号化

2614
02:08:50,140 --> 02:08:51,980
情報をスクランブリングの芸術。

2615
02:08:51,980 --> 02:08:54,000
そして、最初のうち、
問題あなた自身を

2616
02:08:54,000 --> 02:08:56,840
超えて書き込むようになるだろう
構文の一部と一緒に遊ん

2617
02:08:56,840 --> 02:08:59,880
そして、いくつかの論理を解きます
問題、最終的に前に長いです、

2618
02:08:59,880 --> 02:09:03,960
、実際にスクランブル、または暗号化することです
そして最終的に情報を解読します。

2619
02:09:03,960 --> 02:09:06,470
そして、すべては我々がやりました
今日、かなり低くなります

2620
02:09:06,470 --> 02:09:09,190
レベルは、単に可能にするために起こっています
私たちは、1、および1を取ります

2621
02:09:09,190 --> 02:09:13,550
上記に向かって一歩
まだ最も興味深いコードを書きます。

2622
02:09:13,550 --> 02:09:15,050
>> だから、より多くのその次の週に。

2623
02:09:15,050 --> 02:09:17,834

2624
02:09:17,834 --> 02:09:18,762
>> [ビデオ再生]

2625
02:09:18,762 --> 02:09:19,690

2626
02:09:19,690 --> 02:09:22,006
>>  - どのようなあなたはについての私に言うことができます
あなたが彼を見た最後の時間？

2627
02:09:22,006 --> 02:09:26,041

2628
02:09:26,041 --> 02:09:27,040
私は本当に、 - 何を言うことができますか？

2629
02:09:27,040 --> 02:09:30,500

2630
02:09:30,500 --> 02:09:35,340
私が意味する、それは他のどのようなものでした
プリプロダクションリハーサル、

2631
02:09:35,340 --> 02:09:40,510
彼が言った何かがあった以外
私と一緒に立ち往生非常に終わりに。

2632
02:09:40,510 --> 02:09:44,810

2633
02:09:44,810 --> 02:09:46,640
>>  - これはCS50ました。

2634
02:09:46,640 --> 02:09:49,440

2635
02:09:49,440 --> 02:09:52,190
>>  - つまりは、カット誰です
リハーサルに素晴らしい仕事。

2636
02:09:52,190 --> 02:09:53,070
>>  - つまりのランチ？

2637
02:09:53,070 --> 02:09:54,986
>> -Yeah、あなたと私がすることができます
ビットでサンドイッチをつかみます。

2638
02:09:54,986 --> 02:09:58,380
私はちょうどで結果を聞くみよう
デビッド本当にすぐ。

2639
02:09:58,380 --> 02:09:59,160
デビッド？

2640
02:09:59,160 --> 02:10:01,260
デビッド？

2641
02:10:01,260 --> 02:10:03,110
>> [END PLAYBACK]

