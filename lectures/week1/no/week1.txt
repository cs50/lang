[MUSIKK] DAVID J. MALAN: Greit, dette er CS50. Og dette er første uken. Så husker at siste gang i uke null, fokuserte vi på beregningsorientert tenkning. Og vi gått fra det å Scratch, et grafisk programmerings språk fra våre venner ved MIT Media Lab. 

Og med Scratch, gjorde vi utforske ideer som fungerer, og forhold, og looper og variabler, og selv hendelser og tråder, og mer. Og i dag, skal vi fortsette å bruke disse ideene, og virkelig ta dem for gitt, men oversette dem til et annet språk kjent som C. Nå C er en mer tradisjonell språk. Det er et lavere nivå språk, hvis du vil. 

Det er rent tekstlig. Og så ved første øyekast, er det alle kommer til å se ganske kryptisk hvis du aldri har programmert før. Vi kommer til å ha semikolon og parenteser, og klammeparentes, og mer. Men innser at selv men syntaksen er om å se litt uvant for de fleste av dere, se forbi det. Og prøv å se ideene det er faktisk kjent, fordi her i uke en hvilken Vi vil begynne å gjøre er å sammenligne, utgangspunktet, Skrap versus C. 

Så, for eksempel, husker at når vi gjennomført den første av våre programmer siste gang, hadde vi en blokk som så litt noe som dette-- når grønt flagg klikket, og da vi hadde ett eller flere puslebiter under den, i dette tilfellet, sier hello world. Så, ja, i Scratch, når jeg klikker det grønne flagget å kjøre mitt program, så å snakke, disse er blokkene som blir utført, eller løpe. Og spesielt Scratch sa, hallo, verden. 

Nå kunne jeg ha spesifisert forskjellige ord her. Men vi får se at, ja, mange av disse blocks-- og faktisk, i C mange functions-- kan være parametrized eller tilpasset å gjøre forskjellige ting. Faktisk, i C hvis vi ønsker å konvertere, nå, dette Scratch program til denne andre språk, vi kommer til å skrive et litt noe som dette. 

Riktignok er det noen ukjente syntaks det mest sannsynlig, int, og parentes, og ugyldig. Men printf-- selv om du ville tror det ville bare være print. Men print betyr print formatert, så vi vil snart se. Denne bokstavelig talt vil skrive ut til skjermen uansett er på innsiden av de parenteser, hvilken selvfølgelig i dette tilfellet er, hallo verden. 

Men du vil merke noen andre syntaks, noen doble anførselstegn, at de parenteser på slutten, den semikolon og lignende. Så det er en bit av overhead, så å si, både kognitivt og syntaktisk, at vi kommer til å huske lenge. Men innser at med praksis, dette vil begynne å hoppe ut på deg. 

Faktisk, la oss fokusere på at en funksjon specifically-- i dette tilfellet si hei verden. Så si er funksjonen. Hei, verden er dens parameter, eller argument, sin tilpasning. 

Og likeverdighet i C er bare kommer til å være denne linjen her, hvor printf tilsvarer, si, dobbelt sitert streng, hallo verden er ekvivalent selvsagt til hva som er i den hvite boksen der. Og backslash n, men litt merkelig og fraværende fra Scratch, rett og slett kommer til å ha den effekten vi vil se i en datamaskin, som min Mac eller en PC, for bare å flytte markøren til neste linje. Det er som å trykke Enter på tastaturet. 

Så får vi se det igjen før lenge. Men først, la oss ta en titt på denne annet eksempel i tilfellet med løkker. Vi hadde denne evig løkke siste gang, som var en rekke puslespillbrikker det gjorde noe bokstavelig talt forever-- i dette tilfellet si, hallo verden, hallo verden, hallo verden, hallo verden. Så det er en uendelig løkke av design. 

I C, hvis vi ønsker å implementere dette samme ideen, kan vi bare gjøre dette. Mens sant, printf hallo world-- nå stund, bare semantisk, type maner frem ideen om å gjøre noe igjen, og igjen, og igjen, og hvor lenge? Vel, true-- huske at sant er bare på eller én. 

Og sant er, selvfølgelig, alltid sant. Så det er litt av en meningsløs uttalelse bare si sant. Men ja, dette er bevisst, fordi hvis sant er bare alltid sant, enn mens sant bare antyder, hvis en litt indirekte, at følgende linjer med kode i mellom disse klammeparentes skulle bare kjøre igjen, og igjen, og igjen, og aldri stoppe. 

Men hvis du vil at sløyfe for å stoppe, så vi gjorde sist gang med noe sånt dette, gjentar følgende 50 ganger, i C kan vi gjøre det samme med hva som er kalt en for loop-- nøkkelordet ikke å være stund, men for. Og så har vi noen nye syntaks her, med int i lik 0, jeg mindre enn 50, i ++. Og vi vil komme tilbake til det. Men dette er rett og slett hvordan vi ville sette sett Scratch blokker til et sett av linjer med kode C. 

I mellomtiden, kan du vurdere variabler. Og, faktisk, vi bare så en et øyeblikk siden. Og i tilfelle av Scratch, hvis vi ønsket å erklære en variabel kalt jeg for å være i heltall, bare et nummer, og vi ønsker å sette den til en viss verdi, vi ville bruke denne oransje blokkere her-- satt jeg til 0. 

Og vi får se i dag og utover, akkurat som forrige uke, programmerere gjør nesten alltid begynne å telle fra null, egentlig av konvensjonen. Men også fordi tilbakekalling fra vår diskusjon av binære, færrest mulig representerer sammen med hvilket som helst antall bits bare kommer til å være 0 selv. Og så vil vi vanligvis starter initialisering selv våre variabler til 0. 

Og i C å gjøre det samme, vi kommer til å si int for heltall, jeg bare av konvensjonen. Jeg kunne ha kalt denne variabelen noe jeg vil, akkurat som i Scratch. Og så lik 0 bare fortredere verdien 0 fra høyre og setter den i variabelen, eller oppbevaringsboksen der, på venstre side. Og semikolon som vi vil see-- og vi har sett noen av disse already-- bare betyr slutten av tanken. Fortsett å gjøre noe annet på linjene som følger. 

Nå, hva om boolske uttrykk? Husk at i Scratch, disse var uttrykk som er enten sann eller false-- spørsmål, virkelig, som enten er sant eller usant. Så i tilfelle av Scratch, kanskje vi spørre et enkelt spørsmål som dette, er i mindre enn 50? Så i, igjen, er et helt tall. Kanskje vi bruker det i et skrape program å holde styr på en score eller noe sånt. Så denne syntaksen her i Scratch bare betyr, er jeg mindre enn 50? Vel, heldigvis, er noe enkel i C. Og for å oversette, dette vil vi bare si jeg mindre enn 50, ved hjelp av den kjente nøkkel på tastaturet. 

I mellomtiden, hvis du ønsket å si noe mer generelt, som, vel, er x mindre enn y der hver av x og y er i seg selv variabler? Vi kan gjøre det samme i C, så lenge vi har skapte disse variablene allerede. Og vi får se hvordan du gjøre det før lenge. Vi ville bare si x mindre enn y. 

Så du begynner å se noen likheter. Og de folkene som gjorde Scratch var sikkert inspirert av noen av disse grunnleggende ideer. Og du vil se denne typen Syntaksen i mange languages-- ikke bare Scratch, ikke bare C, men Python, og Javascript, og andre språk fortsatt. 

La oss vurdere en annen konstruksjon fra C, tanken om en tilstand, gjøre noe betinget. Hvis noe er sant, gjør dette. Hvis noe annet er sant, gjør det. Det er liksom programmerings tilsvarer et veiskille. Kanskje det er en to-veis gaffel, en tre-veis gaffel, eller mer. Og i Scratch, kan vi ha sett noe som dette. 

Så dette er en stor en. Men vurdere den relative Enkelheten av den logikk. Dersom x er mindre enn y, så si x er mindre enn y, annet hvis x er større enn y, så si x er større enn y. Og så, logisk, hvis du tenker tilbake til Scratch eller bare din egen menneskelige intuisjon, vel, hvis x er ikke større enn y og x er ikke mindre enn y, da selvfølgelig x kommer til å være lik y. Så i dette tilfellet ved hekke disse Skrape blokker, kan vi oppnå en tre måte veiskille? 

I mellomtiden, hvis vi ønsker å gjøre det i C, det uten tvil ser litt simpler-- minst når du blir kjent med syntaksen. Dersom x er mindre enn y, printf x er mindre enn y. Else if x er større enn y, printf x er større enn y. Else printf x er lik Y- og, igjen, med de skråstrek ender like for de nye linjene slik at hvis du faktisk kjørte denne typen program det ville bare flytte markøren til slutt til neste linje på skjermen. 

Nå, i mellomtiden Scratch hadde andre mer avanserte funksjoner, bare noen som vi kommer til å utgangspunktet flytte over til en verden av C. Og en av dem var kalt en liste i Scratch. Og dette var en spesiell type variabel som tillatt å lagre flere ting i den tilbake, mot rygg, og bakover, til rygg. 

I C, betyr det ikke har lister, per se, men noe som er mer generelt kalt arrays, selv om vi vil komme tilbake senere i semesteret å se på noe kalt en liste, eller egentlig en lenket liste. Men for nå, det nærmeste tilsvarende i C for oss kommer til å være noe kalles en matrise. Og en rekke er rett og slett en spesiell type av variabel som lar deg lagre data tilbake, til rygg, og bakover, mot rygg. 

Og, ja, i Scratch, hvis vi ønsket å få tilgang det første elementet i en matrise eller en list-- og jeg kommer til å kalle det, av konvensjonen, argv, argument vektor, men mer om det før lenge. Hvis jeg ønsker å få på det første elementet av argv, i en verden av Scratch du faktisk gjør vanligvis begynne å telle fra 1. 

Og så jeg kan få punkt 1 i argv. Det er bare hvordan MIT implementert oppfatningen av lister. Men i C, kommer jeg til å mer rett og slett bare si, argv, som igjen er navnet på mitt list-- eller for å være klar, en matrise. Og hvis jeg vil det første elementer, jeg kommer å bruke hakeparentes, som du kanskje ikke kan brukes under et tastatur. 

Men 0 betyr bare får meg først. Så på anledning og som tiden går, vi skal å begynne å se disse dikotomier mellom Scratch og C, hvor Scratch bruker det. Vi i C bruker 0 her. Men du vil raskt se når du forstår grunnlaget for hvert språk, at disse ting begynner å bli enda mer kjent gjennom praksis og praksis. 

Så la oss faktisk ser nå på et program. Her skal være den første av våre C kildekode for fullstendige programmer. Og programmet vi skal å tilby for vurdering er det en som er tilsvarende til at tidligere Scratch stykke. 

Så her har vi det er uten tvil den enkleste C program du kan skrive at faktisk gjør noe. Nå vil vi se fortiden, for nå har inkludere, standard io.h, og disse vinkel parentes, og int, og ugyldig, og klammeparentes og lignende. 

Og la oss bare fokusere på hvilken, i det minste intuitivt kan hoppe ut på deg allerede. Faktisk, viktigste, vet jeg ikke nødvendigvis vet hva dette er, men mye som Scratch hadde det da grønne flagget klikket puslespill brikke, så gjør C som programmeringsspråk har en hoved stykke kode som blir utført som standard. Og, ja, Det er bokstavelig talt kommer til å bli kalt hoved. 

Så hoved er en funksjon. Og det er en spesiell funksjon som eksisterer i C at når du kjører et program, det er hoved som blir drevet av misligholde. I en verden av Scratch, det var som regel når grønt flagg klikket som fikk kjøre som standard. 

I mellomtiden har vi sett dette før, printf eller print formatert, det er kommer til å være en funksjon som følger med C, sammen med en hel haug med andre, som vil fra tid og tid igjen, for å gjøre nøyaktig som navnet antyder, skrive ut noe. Hva ønsker vi å skrive ut? Vel, vil vi se at av omsluttende tegn som these-- hallo verden, backslash n i anførselstegn, vi kan fortelle printf nøyaktig hva du skal skrive ut på skjermen. 

Men for å gjøre som vi dessverre trenger å ta noe som er allerede kryptisk til oss mennesker, men minst det er noe readable-- skarp omfatter standard io.h, int, Hoved, ugyldig printf, all den magiske besvergelser vi nettopp så på skjermen. Men vi har faktisk til gå mer uforståelige likevel. Vi må først oversette koden at vi skriver til maskinkode. Og husker fra forrige uke at maskiner, minst de vi kjenner her, på slutten av dagen bare forstå nuller og enere. 

Og min Gud, hvis vi måtte skrive disse nuller og enere til faktisk program, det vil veldig, veldig raskt ta moro ut av noe. Men det viser seg, per i forrige uke, at disse mønstrene av nuller og enere bare har en spesiell betydning. I visse sammenhenger de kan bety tall. 

I noen sammenhenger kan de bety bokstaver eller farger, eller hvilket som helst antall andre abstraksjoner der på. Men akkurat som datamaskinen har en CPU, Central Processing Unit, eller hjernen i datamaskinen. Det er vanligvis Intel inne, fordi det er en av de største selskapene som gjør CPUer for datamaskiner. 

Vel, Intel prosessorer og andre rett og slett har bestemt på forhånd at visse mønstre av nuller og de skal bety konkrete ting. Visse mønstre av nuller og enere vil bety, skrive ut denne til skjermen, eller legge til disse to tallene, eller trekke disse to tallene, eller flytte denne delen av data fra min maskinens minne over her, eller hvilket som helst antall av andre meget lavt nivå, men til slutt nyttig, operasjoner. Men, heldigvis, vi mennesker ikke kommer til å trenge å vite dette detaljnivået. Faktisk, akkurat som forrige gang, der vi informasjon hentet igjen, og igjen, og igjen, bygning av meget lavt nivå primitiver som nuller og enere til høyere nivå konsepter som tall og bokstaver, og farger, og mer, så kan vi som programmerere stå på skuldrene til andre som har kommet før oss og bruke programvare som andre folk har skrevet før us-- nemlig programmer kalt kompilatorer. 

C er et språk som vanligvis utarbeidet, som betyr konvertert fra kildekoden til maskinkode. Spesielt hva dette betyr er at hvis du har din kilde kode som du selv skriver, så vi snart vil i løpet av et øyeblikk på skjermen, og du ønsker å konvertere den slutt til maskin code-- disse nuller og enere som bare din Mac eller PC understands-- du har en første mate at kildekoden i så inngang til en spesiell program kalt en kompilator, hvis utgang vi skal se er maskinkode. Og, ja, sist gang vi snakket om, virkelig, på slutten av dagen, problemløsning. Du har innganger. Og du har utganger. Og du har fått noen slag av algoritmen i midten. 

Algoritmer kan sikkert være implementert i software, som vi så med pseudo forrige uke og som vi vil se med selve koden denne uka. Og så en kompilator egentlig bare har et sett med algoritmer inne av det som vet hvordan de skal konvertere de spesielle søkeord, som hoved, og printf, og andre som vi bare så inn i mønstre av nuller og de som Intel Inside og andre CPUer faktisk forstår. Så hvordan gjør vi dette? Hvor får vi en kompilator? 

De fleste av oss her har en Mac eller en PC. Og du kjører Mac OS, eller Windows eller Linux eller Solaris, eller hvilket som helst antall annen operativsystemer. Og, ja, vi kunne gå ut på nettet og laste ned en kompilator for Mac eller PC for ditt operativsystem. Men vi vil alle være på forskjellige sider, så å si. Vi ville ha litt forskjellige konfigurasjoner. Og det ville ikke fungere likevel. Og, ja, i disse dager mange av oss ikke bruker programvare som kjører bare på våre bærbare datamaskiner. I stedet bruker vi noe som en nettleser som tillater oss å få tilgang til web-baserte applikasjoner i skyen. Og senere i semesteret, vi vil gjøre akkurat det. Vi vil skrive søknader eller programvare ved hjelp code-- ikke C, men andre språk som Python og JavaScript-- som kjører i skyen. 

Og for å gjøre det, vi oss selv i løpet av semesteret vil faktisk bruke en skybasert miljøet kjent som CS50 IDE. Dette er en web-basert programmering miljø, eller integrert utvikling miljø, IDE, som er bygget på toppen av noen åpen kildekode programvare kalt Cloud 9. Og vi har gjort noen pedagogisk forenklinger i det slik som å skjule visse funksjoner i de første ukene som vi ikke trenger, etter som du kan avsløre dem og gjøre mest alt du vil med miljøet. 

Og det gir oss også, til pre-installere bestemt programvare. Ting som en såkalt CS50 bibliotek, som vi vil snart se gir oss i C med noen tilleggsfunksjonalitet. Så hvis du går til, til slutt, CS50.io, vil du bli bedt om å logge inn, og når du gjør det og opprette en konto gratis, du vil være i stand til å få tilgang til en miljø som ser ut som dette. 

Nå er dette i standardmodus. Alt er fint og lys på skjermen. Mange av oss har en vane arbeider på CS50 stykke som er ganske sent i natt. Og så noen av dere kanskje foretrekker å slå den inn i nattmodus, så å si. 

Men, til slutt, hva du er kommer til å se i løpet av CS50 IDE er tre distinkte areas-- et område på venstre der filene dine kommer til å være i sky, et område øverst til høyre hvor koden skal være redigerbare. Du vil være i stand til å åpne enkelte kategoriene for ethvert program at du skriver dette semesteret inne av det øvre høyre hjørne. Og da mest arcanely, og likevel kraftfullt, kommer til å være denne tingen på bunn kjent som en terminalvindu. 

Dette er en gammel skole Command Line Interface, eller CLI, som gjør at du å utføre kommandoer på computer-- i dette tilfellet datamaskinen i cloud-- å gjøre ting som å kompilere koden din fra kildekoden til maskinkode, å kjøre programmer, eller for å starte web server, eller for å få tilgang til databasen, og en rekke andre teknikker at vi vil begynne å bruke før lenge. Men for å komme dit, er vi kommer til å faktisk ha å gå online og begynne å spille. Og for å gjøre det, la oss først begynne fiksing og triksing med hoved, og skrive den viktigste del av et program. Og la oss bruke denne funksjonen printf, som vi brukte tidligere, bare for å si noe. 

Så her er jeg allerede inne i CS50 IDE. Jeg har logget på forhånd. Og jeg fullstendig skjermet vinduet. Og så, til slutt, du også i kommende problemer vil følge tilsvarende trinn som vil gi elektronisk dokumentasjon. Så du trenger ikke å bekymre deg for absorberende hver lille tekniske trinn som jeg gjør her i dag. 

Men du vil få en skjerm som dette. Jeg måtte være i nattmodus. Og du kan lyse alt opp ved å deaktivere nattmodus. Og ved slutten av dag, kommer du til å se disse tre hoved areas-- filen Nettleseren til venstre, kode fanene opp toppen, og terminalvinduet på bunnen. 

La meg gå videre og skrive min første program. Jeg kommer til å preemptively gå til Fil, Lagre, og lagre filen min som hello.c. Faktisk, etter konvensjonen, et program vi skrive som er skrevet i C-språk skal hete noe dot c, etter konvensjonen. Så jeg kommer til å nevne det hello.c, fordi Jeg vil bare si hei til verden. Nå kommer jeg til å zoome ut og klikk på Lagre. Og alt jeg har her nå er en fane hvor kan jeg begynne å skrive kode. 

Dette er ikke til å kompilere. Det betyr ingenting. Og så selv om jeg konvertert dette til nuller og enere, CPU kommer til å ha noen anelse om hva som skjer rundt. Men hvis jeg skriver linjer som samsvarer opp med Cs conventions-- C vesen, igjen, language-- dette med syntaks som dette, printf hallo world-- og jeg har fått komfortabel med å gjøre dette over tid. Så jeg tror ikke jeg har gjort eventuelle skrivefeil. 

Men, uten unntak, den aller første gang du gjør dette, vil du. Og det jeg er i ferd med å gjøre kanskje veldig vel ikke fungere for deg første gang. Og det er helt OK, fordi akkurat nå kan bare se en hel masse newness, men over tid når du blir kjent med dette miljøet, og dette språket, og andre, vil du begynne å se ting som er enten riktig eller feil. 

Og dette er hva undervisning stipendiater og kurs assistenter får så god på over tid, er spotting feil eller feil i koden din. Men jeg hevder at det er ingen feil i denne koden. Så jeg ønsker nå å kjøre dette programmet. 

Nå på min egen Mac eller PC, jeg er i vane å dobbeltklikke ikoner når jeg ønsker å kjøre noen program. Men det er ikke den modellen her. I dette miljøet, som er CS50 IDE. Vi bruker en drifts system kalt Linux. Linux er minner om en annen operativsystem, generelt kjent som Unix. Og Linux er spesielt kjent for å ha en kommandolinje miljø, CLI. Nå, vi bruker en bestemt smaken av Linux kalt Ubuntu. Og Ubuntu er rett og slett en viss versjon av Linux. 

Men disse Linux er i disse dager gjør faktisk kommer med grafiske brukergrensesnitt. Og den vi tilfeldigvis skal bruke her er web-basert. Så dette kan se enda en litt forskjellig fra noe du selv kan ha sett eller kjøre i det siste. 

Så jeg kommer til å gå videre nå og gjøre følgende. Jeg har lagret filen som hello.c. Jeg kommer til å gå videre og typen clanghello.c Så klang for C-språk er en kompilator. Det er forhåndsinstallert i CS50 IDE. Og du kan absolutt laste ned og installere dette på din egen Mac eller PC. 

Men, igjen, ville du ikke ha alle pre-konfigurasjon gjort for deg. Så for nå, jeg er bare kommer til å kjøre clanghello.c. Og nå legger merke til denne syntaksen her vil til slutt skjønner bare si at jeg er i en mappe eller katalog som heter arbeidsområde. Dette dollartegn er bare konvensjonen etter mening, skriver dine kommandoer her. 

Det er det som kalles en rask, bare etter konvensjonen er dollartegn. Og hvis jeg går videre nå og klikk Skriv inn, ingenting synes å ha skjedd. Men det er faktisk en god ting. Jo mindre det skjer på skjermen, jo mer sannsynlig koden er riktig, minst syntaktisk. 

Så hvis jeg vil kjøre denne program, hva gjør jeg? Vel, det viser seg at Standard navn etter konvensjonen for programmer når du ikke angir et navn på programmet er bare a.out. Og denne syntaksen også, vil du bli kjent med før lenge. 

Dot slash bare betyr, hei, CS50 IDE, kjøre et program som heter a.out som er inne i min nåværende katalog. Det prikk betyr gjeldende katalog. Og vi får se hva andre slike sekvenser tegn betyr før lenge. 

Så her går vi, Enter, hallo verden. Og du vil legge merke til, at det som skjedde? Ikke bare gjorde det skrive ut hello world. Det er også flyttet markøren til neste linje. 

Og hvorfor var det? Hva var koden som vi skrev før som sørget for at markøren ville gå på neste linje? Morsom ting om en datamaskin er det bare kommer å gjøre bokstavelig det du ber den om. 

Så hvis du forteller det til printf hallo, komma, mellomrom, verden, tett sitat, Det er bokstavelig talt bare kommer å skrive ut disse tegnene. Men jeg hadde denne spesielle karakter på slutten, husker, backslash n. Og det er det sikret at karakteren gikk til neste linje på skjermen. 

Faktisk, la meg gå og gjøre dette. La meg gå videre og slett dette. Legg nå merke til at toppen av skjermen min er det litt rødt lys i fanen indikerer, hei, du har ikke lagret filen. Så jeg kommer til å gå videre med kontroll S eller kommando S, lagre filen. Nå goes-- det gikk for en moment-- grønn. Og nå er det tilbake til bare å være en nær ikon. 

Hvis jeg nå kjøre clanghello.c igjen, Enter, dot slash, a.out, Enter, vil du se at det fortsatt arbeidet. Men det er kanskje litt buggy. Akkurat nå, min prompt-- arbeidsområde, og da at dollartegn, og deretter min faktiske prompt-- er alle på samme linje. Så dette er absolutt en estetisk feil, selv om det er egentlig ikke en logisk feil. 

Så jeg kommer til å angre det jeg nettopp gjorde. Jeg kommer til å kjøre a.out. Merke til at jeg har lagt til linjeskift karakter tilbake. Jeg har lagret filen. 

Så jeg kommer til å kjøre a.out, og-- faen, en bug, en bug som betyr feil. Så feilen er at selv om Jeg har lagt den backslash n der, re-lagret, re-løp i programmet, virkemåten var den samme. Hvorfor skulle det være? 

Jeg mangler et skritt, ikke sant? Det viktig skritt tidligere var at du har to-- når du endrer kildekoden, det viser seg også kjøre den gjennom kompilatoren igjen slik at du får ny maskin kode. Og maskinkode, nuller og enere, kommer til å være nesten identiske, men ikke perfekt, fordi vi trenger, selvfølgelig, at ny linje. 

Så for å fikse dette, jeg kommer til å trenge å kjøre clanghello.c, enter, dot slash, a.out. Og nå, hallo verden er tilbake der jeg forventer at det skal være. Så dette er alt fint og bra. Men a.out er en ganske dum navn for en program, selv om det nå måtte være, for historiske grunner, default-- betyr montering utganger. 

Men la meg gå videre her og gjøre dette på en annen måte. Jeg vil ha min hello world program å faktisk bli kalt hei. Så hvis det var et ikon på min desktop, ville det ikke være a.out. Det ville bli kalt hei. 

Så for å gjøre dette, viser det seg som klang, som mange programmer, støtter kommandolinje argumenter, eller flagg, eller brytere, som bare påvirker dens adferd. Spesielt støtter klang en dash o flagg, som deretter tar en andre ord. I dette tilfellet, vil jeg vilkårlig, men rimelig, kaller det hallo. Men jeg kan kalle det noe Jeg vil, bortsett fra a.out, som ville være ganske tillegg til punktet. 

Og så bare oppgi navnet på filen jeg ønsker å kompilere. Så nå selv om i begynnelsen av kommandoen jeg har fortsatt klang, ved slutten av kommandoen Jeg har fortsatt filnavnet, Jeg har nå disse kommandolinje argumenter, disse flaggene som sier, oh, forresten, utgang-o, en fil kalt hallo, ikke standard a.out. 

Så hvis jeg trykker Enter nå, ingenting synes å ha skjedd. Og ennå, nå kan jeg gjøre dot slash hei. Så det er det samme programmet. De nuller og enere er identisk på slutten av dagen. 

Men de er i to annerledes files-- a.out, som er den første versjonen og bare tåpelig navngitt, og nå hei, som er en mye mer overbevisende navn på et program. Men, ærlig talt, jeg er aldri kommer til å huske dette igjen, og igjen, og igjen. Og, faktisk, som vi skriver mer kompliserte programmer, kommandoene du er nødt til å skrive kommer til å få enda mer komplisert likevel. 

Og ikke å bekymre deg. Det viser seg at mennesker før oss har innsett at de også hadde dette nøyaktig samme problem. Også de ikke liker å måtte skriver ganske lange, uforståelige kommandoer, enn si huske dem. Og så mennesker før oss har gjort andre programmer som gjør det enklere å kompilere programvare. 

Og, ja, en slik Programmet heter Make. Så jeg kommer til å gå videre og gjøre dette. Jeg kommer til å angre alt jeg gjorde på følgende måte. La meg skrive LS. Og du vil legge merke til tre things-- a.out, og en stjerne, hallo og en stjerne, og hello.c. Forhåpentligvis, bør dette være litt intuitiv, i den grad tidligere var det ingenting i dette arbeidsområdet. Det var ingenting som jeg hadde opprettet før vi startet klassen. 

Og jeg opprettet hello.c. Jeg deretter utarbeidet det, og kalte det a.out. Og da jeg samlet det igjen litt annerledes og kalte det hei. Så jeg har tre filer i denne katalogen, i denne mappen som heter arbeidsområde. Nå kan jeg se at så vel hvis jeg zoome ut faktisk. 

Hvis jeg zoomer ut her og se på det øverste høyre hjørne, som lovet venstre side av skjermen er alltid kommer til å vise deg hva som er i kontoen din, hva er innsiden av CS50 IDE. Og det er tre filer der. 

Så jeg ønsker å bli kvitt a.out og hei. Og som du kanskje forestille intuitivt, du kunne sortere av kontroll klikk eller høyreklikk på dette. Og denne lille menyen spretter opp. Du kan laste ned filen, kjører det, forhåndsvise det, oppdatere, endre navn, eller hva ikke. 

Og jeg kunne bare slette, og det ville gå bort. Men la oss gjøre ting med en kommando linjen for nå, for å få komfortable med dette, og gjøre følgende. Jeg kommer til å gå videre og ta a.out ved å skrive bokstavelig rma.out. Det viser seg, er kommandoen for fjerne eller slette noe, ikke fjerne eller slette. 

Det er mer konsist RM, bare for å spare deg noen tastetrykk, og trykk Enter. Nå skal vi være litt cryptically fjerne vanlig fil a.out. Jeg vet egentlig ikke hva en uregelmessig fil ville være enda. Men jeg ønsker ikke å fjerne det. 

Så jeg kommer til å skrive y for ja. Eller jeg kunne skrive det ut, og trykk Enter. Og, igjen, ingenting synes å skje. Men det er generelt en god ting. 

Hvis jeg skriver LS denne gangen, hva bør jeg se? Forhåpentligvis bare hei og hello.c. Nå, som en side, vil du merke dette stjerne, stjerne, det er på slutten av mine programmer. Og de er også dukke opp i grønt. Det er bare CS50 IDE måte av cluing deg inn i faktum at det ikke er kildekoden. Det er en kjørbar, et kjørbart program som du faktisk kan kjøre ved å gjøre dot slash, og da er det navnet. 

Nå, la meg gå videre og ta dette, rm hallo, Enter, fjerne vanlig fil hei, ja. Og nå hvis jeg skriver LS, vi er tilbake til hello.c. Prøv ikke å slette selve kildekoden. Selv om det er funksjoner bygget inn CS50 IDE der du kan gå gjennom revisjonshistorie og spole tilbake i tid hvis du ved et uhell slette noe, gjøre være oppmerksom som per disse meldingene ja eller nei, av hva du faktisk ønsker å gjøre. Og hvis jeg går opp til toppen venstre hjørne her, alt som gjenstår er hello.c. Så det er bunter av andre kommandoer som du kan utføre i verden av Linux, hvorav den ene er, igjen, Make. Og vi kommer til å gjøre mitt program nå som følger. 

I stedet for å gjøre klang, stedet for å gjøre klang-o, Jeg kommer til å rett og slett bokstavelig skriver, gjør hallo. Og nå legger merke til, er jeg ikke å skrive gjøre hello.c. Jeg skriver lage hei. 

Og dette programmet Gjør det kommer med CS50 IDE, og mer generelt med Linux, er et program som er kommer til å lage et program som heter Hallo. Og det kommer til å anta, etter konvensjonen, at hvis dette programmet kan bli gjort, det kommer til å bli gjort fra en kilde kode fil som slutter på dot c, hello.c. 

Så hvis jeg trykker Enter nå, merker at kommandoen som blir henrettet er faktisk enda lenger før enn før. Og det er fordi vi har forhåndskonfigurert CS50 IDE å ha noen ekstra funksjoner innebygd som vi trenger ikke ennå, men snart vil. Men det viktigste for å realisere Nå er jeg en Hei program. 

Hvis jeg skriver LS igjen, jeg ha en god dag program. Og jeg kan kjøre den med dot slash a.out, nei, fordi hele poenget med denne øvelsen var dot slash hei. Og nå har jeg min hello world program. Så fremover, vi er nesten alltid bare kommer til å kompilere våre programmer ved hjelp av kommandoen Make. Og så skal vi kjøre dem av dot slash, og programmet navn. Men skjønner det som gjør gjør for deg, er det i seg selv er ikke en kompilator. Det er bare en praktisk program som vet å utløse en kompilator å kjøre slik at du selv kan bruke den. 

Hvilke andre kommandoer eksisterer i Linux, og i sin tur CS50 IDE? Vi vil snart se at det er en CD-kommandoen Change Directory. Dette gjør at du i løpet av din kommandolinjegrensesnitt å bevege seg fremover, og tilbake, og åpne opp forskjellige mapper uten å bruke musen. 

LS vi så, som står for liste filene i gjeldende katalog. Gjør Dir, kan du sannsynligvis begynne å antyde hva disse betyr now-- lage katalog, Hvis du ønsker å opprette en mappe. RM for remove, RM Dir for fjerne directory-- og disse, igjen, er kommandolinjen ekvivalenter av hva du kunne gjøre i CS50 IDE med musen. Men du vil snart finne at noen ganger er det bare mye raskere å gjøre ting med et tastatur, og til slutt en mye kraftigere. 

Men det er vanskelig å argumentere for at noe vi har gjort så langt er alt som kraftig, når alle vi har sagt er, hallo verden. Og, faktisk, hardkodet jeg ord hallo verden inn i mitt program. Det er ingen dynamikk ennå. Scratch var en størrelsesorden mer interessant i forrige uke. 

Og så la oss komme dit. La oss ta et skritt mot at ved hjelp av noen av disse funksjonene. Så ikke bare C kommer med printf, og bunter av andre funksjoner noen som vi får se over tid, det gjør det ikke gjør det så lett rett ut av porten i å få brukerundersøkelser. 

Faktisk er en av svakhetene av språk som C, og selv Java og ennå andre, er at den ikke gjør det lett å bare få ting som heltall fra brukere eller strenger, ord, og uttrykk, enn si ting som flyt verdier eller reelle tall med desimaler, og virkelig lange tall, som vi snart se. Så denne listen over funksjoner her, disse er som andre Scratch brikkene at vi har forhåndsinstallert i CS50 IDE som vi vil bruke for et par uker som trening hjul slags, og slutt ta dem av, og se under panseret, kanskje, på hvordan disse tingene blir gjennomført. 

Men for å gjøre dette, la oss faktisk skrive et program. La meg gå videre nå. Og jeg kommer til å lage en ny fil ved å klikke på denne lille pluss, og klikke Ny fil. 

Jeg kommer til å spare dette neste en som, la oss si, string.c, fordi jeg ønsker å spille med strenger. Og streng i C er bare en sekvens av tegn. Så nå la oss gå videre og gjøre følgende. 

Inkluder standard IO.h-- og det viser seg standard IO, IO betyr bare inngang og utgang. Så det viser seg at denne linjen her er hva er det nærliggende for oss å bruke printf. Printf, selvfølgelig, produserer utdata. Så for å bruke printf, viser det ut må du ha denne linjen med kode på toppen av filen. 

Og vi vil komme tilbake til hva som virkelig betyr før lenge. Det viser seg at i noen C-program jeg skriver, Jeg har til å starte den med kode som ser slik ut. Og du vil legge merke til CS50 IDE, og annet integrert utvikling miljøer som det, skal prøve så godt de kan for å fullføre din tanke. Faktisk en stund siden om jeg angre hva jeg gjorde, jeg trykker på Enter. 

Jeg deretter traff åpent krøllete brace, trykk Enter igjen. Og det ferdig med min tanke. Det ga meg en ny linje, rykket ikke mindre for fine stilistiske grunner får vi se. Og da er det automatisk ga meg at klammeparentes å fullføre min tanke. Nå gjør det ikke alltid gjette hva du vil gjøre. Men i stor grad, gjør det spare deg noen tastetrykk. Så et øyeblikk siden, kjørte vi denne program-- hallo, verden, og deretter satt sammen det, og så løp den. Men det er ingen dynamikk her. Hva hvis vi ønsket å gjøre noe annerledes? Vel, hva om jeg ønsket å faktisk får en streng fra brukeren? Jeg kommer til å bruke et puslespill brikke heter nøyaktig at-- få streng. 

Det viser seg i C at når du ikke vil å gi innspill til en puslespill brikke, eller mer riktig til en funksjon, du bokstavelig talt bare gjøre åpen parentes, sluttparentes. Så det er som om det er ingen hvit boks til å skrive inn. Den sier blokken før hadde en liten hvit boks. Vi har ikke den hvite boksen nå. 

Men når jeg ringer get streng, jeg ønsker å sette resultatet et sted. Så en veldig vanlig paradigme i C er å kalle en funksjon, som få streng her, og deretter lagre returverdien. Det er resultatet av dens innsats i noe. 

Og hva er konstruere i programmering, enten i Scratch eller nå C, som vi kan bruke til å faktisk lagre noe? Kalte det en variabel, ikke sant? Og i Scratch, gjør vi ikke egentlig bryr seg hva som foregikk i variabler. 

Men i dette tilfellet, vi faktisk gjør. Jeg kommer til å si streng. Og så jeg kunne ringe dette noe jeg vil. Jeg kommer til å kalle det navn, får få streng. 

Og nå selv om du er litt ny på dette, merker at jeg mangler noen detaljer. Jeg glemmer et semikolon. Jeg trenger å fullføre denne tanken. Så jeg kommer til å flytte min markør, og traff semikolon der. Og hva har jeg nettopp gjort? I denne linjen med kode, nummer fem i øyeblikket, Jeg ringer get streng uten innganger. Så det er ingen liten hvit boksen som Lagre blokken har. 

Jeg sier bare, hei, datamaskin, få meg en streng. Likhetstegnet er egentlig ikke et likhetstegn, per se. Det er oppdraget operatør, noe som betyr, hei, datamaskin, flytte verdien fra høyre mot venstre. Og i den venstre, har jeg følgende. 

Hei, datamaskin, gi meg en string-- en sekvens av tegn. Og kaller den strengen navn. Og jeg trenger ikke engang å kalle det navn. 

Jeg kan kalle det, konvensjonelt, noe som S, mye som vi pleide jeg å kalle variabelen i. Men nå trenger jeg å gjøre noe med det. Det ville være ganske dumt å prøve å kompilere denne koden, kjører dette programmet, selv om Jeg får en streng, fordi det er fortsatt bare kommer til å si hei verden. 

Men hva om jeg ønsker å endre dette. Hvorfor jeg ikke gjøre dette? Prosent s, komma s. Og dette er en litt kryptisk likevel. 

Så la meg gjøre mine variabler mer tydelig. La meg nevne denne variabelen navn. Og la oss se om vi ikke kan erte hverandre hva som skjer her. 

Så på linje fem, jeg får en streng. Og jeg lagre denne strengen, hva brukeren har skrevet inn på hans eller hennes tastatur, i en variabel kalt navn. Og det viser seg at printf ikke bare ta ett argument i dobbeltrom sitater, en inngang i anførselstegn. 

Det kan ta to eller tre, eller flere, for eksempel at den andre eller tredje eller fjerde er alle navn på variabler, eller spesifikt verdier, som du ønsker å koble til, dynamisk, at strengen i anførselstegn. Med andre ord, hva ville være galt med dette? Hvis jeg bare sa hei navn, skråstrek n, lagres filen min, kompilert koden min, og kjørte dette, hva ville skje? 

Det er bare kommer til å si, hallo navn, bokstavelig talt N-A-M-E, som er litt dumt fordi det er ikke forskjellig fra verden. Så alt i anførselstegn er hva bokstavelig talt blir skrevet ut. Så hvis jeg vil ha en plassholder der, Jeg faktisk trenger å bruke noen spesiell syntaks. Og det viser seg hvis du leser dokumentasjon for printf-funksjonen, det vil fortelle deg at hvis du bruker prosent s, du kan erstatte en verdi som følger. 

Etter et komma etter det dobbel sitat, du bare skrive navnet på variabel som du vil å plugge inn i dette formatet kode, eller format Specifier, prosent er for strenger. Og nå hvis jeg har lagret filen min, Jeg går tilbake til min terminal. Og jeg skriver Gjør String, fordi, igjen, navnet på denne fil som jeg valgte før er string.c. 

Så jeg kommer til å si Gjør String, skriv. Oh my godhet, se på alle feilene vi har gjort allerede. Og dette er-- hva, dette er virkelig som en seks, syv linje program? Så det er her det kan veldig raskt bli overveldende. 

Denne terminalvindu har nå bare gulpe opp et stort antall feilmeldinger. Sikkert, jeg har ikke mer feil meldinger enn jeg har linjer med kode. Så hva er det som skjer? 

Vel, den beste strategien å gjøre når du støter en overveldende liste over feil som det, er bla tilbake, se etter kommandoen du bare løp, som i mitt tilfelle er å få streng. Se på hva gjør gjorde, og det er det lang klang kommando, ingen big deal der. 

Men den røde er dårlig. Grønn prøver å være milde og nyttig. Men det er fortsatt dårlig, i dette tilfellet. Men hvor er det ille? 

String.c, linje fem, karakter fem. Så dette er bare sunn konvensjonen. Noe kolon noe betyr linjenummer og tegnnummer. Feil bruk av svart identifikator streng. Mente du standard i? 

Så dessverre, klang prøver å være nyttig. Men det er feil, i dette tilfellet. Nei, klang, jeg mente ikke standard IO. Jeg mente at på linje en, ja. 

Men linjen fem er denne her. Og klang ikke forstå S-T-R-I-N-G. Det er en svart identifikator, en ord det bare aldri har sett før. Og det er fordi C, språket vi skriver kode i akkurat nå, ikke har variable kalles strenger. 

Det gjør ikke som standard støtte noe som kalles en streng. Det er en CS50 stykke slang, men meget vanlig. Men jeg kan fikse dette på følgende måte. 

Hvis jeg legger til en linje med kode til toppen av dette programmet, inkluderer CS50.h, som er en annen fil et eller annet sted inne i CS50 IDE, et sted på harddisken, så å si, av Ubuntu operativsystem at jeg kjører, som er filen som er skal lære drifts Systemet hva en streng er, bare som standard io.h er filen i operativsystemet som er kommer til å lære det hva printf er. 

Ja, vi ville ha fått en veldig lignende melding Hvis IO hadde innrømmet standard IO.h og prøvde å bruke printf. Så jeg kommer til å gå videre og bare Ta kontroll L for å tømme skjermen min. Eller du kan skrive klart og det vil bare fjerne terminalvinduet. Men du kan fortsatt bla tilbake i tid. 

Og jeg kommer til å kjøre Gjør String. Krysse fingrene denne gangen, Enter. Herregud, det fungerte. det viser meg en lang kryptisk kommando det er det som gjør generert via klang, men ingen feilmeldinger. Så skjønner, selv om kan du få helt overveldet med antall feilmeldinger, det bare kan være denne irriterende brus effekt, der klang ikke forstår en ting, noe som betyr at det da ikke forstår det neste ordet, eller neste linje. Og slik er det bare choker på koden din. Men fix kan være enkel. Og så alltid fokusere på aller første linje av produksjonen. Og hvis du ikke forstår det, bare se for søkeord som kan være ledetråder, og linjenummer, og tegnet, der at feilen kan være. 

Nå la meg gå videre og skrive dot slash, streng, skriv. Hm, det er ikke si hallo noe. Hvorfor? Vel, husker, der er det i gang? 

Det er nok fast i øyeblikket i en loop, om du vil, på linje seks, fordi Få String av design, skrevet av CS50 ansatte, er bokstavelig ment å bare sitte der venter, og venter, og venter på en streng. Alt vi mener med streng er menneskelig input. Så vet du hva? La meg gå videre. Og bare på et innfall, la meg skriver navnet mitt, David, skriv. Nå har jeg en mer dynamisk program. Det sa, hallo David. 

Hvis jeg går videre og kjøre dette igjen, la meg prøve si Zamila navn, skriv. Og nå har vi et dynamisk program. Jeg har ikke hard kodet verden. Jeg har ikke hardkodet navn eller David, eller Zamila. 

Nå er det mye mer som programmene vi vet, der hvis det ta innspill, det gir litt annen utgang. Nå, dette er ikke den beste brukeropplevelse, eller UX. Jeg kjører programmet. 

Jeg vet ikke hva jeg skal å gjøre, med mindre jeg faktisk se på eller huske kildekoden. Så la oss gjøre brukeren oppleve litt bedre med de enkleste ting. La meg gå tilbake til denne program, og bare si printf. 

Og la meg gå videre og si navn, tykktarm, og et mellomrom, og deretter et semikolon. Og bare for morro skyld, ingen tilbakeslag n. Og det er bevisst, fordi jeg ikke vil ha blir bedt om å gå til neste linje. 

Jeg vil i stedet gjøre dette, må strengen å rekompilere koden min til ny maskin kode dot slash streng. Ah, dette er mye penere. Nå har jeg faktisk vet hva maskinen vil jeg skal gjøre, gi den et navn. 

Så jeg kommer til å gå videre og skriv i Rob, enter, og hallo, Rob. Så, innser, dette er fortsatt, i enden av dagen, bare en ni linje program. Men vi har tatt disse baby trinn. 

Vi skrev en linje med hvilken vi var kjent, printf, hallo verden. Da vi løste en liten bit av det. Og vi faktisk brukt get streng. Og vi kastet den verdien i en variabel. Og da vi gikk videre og forbedret det videre med en tredje linje. Og dette iterativ prosess med skrive programvare er virkelig nøkkelen. I CS50, og i livet generelt, du bør generelt ikke sitte ned, har et program i tankene, og prøv å skrive hele greia på en gang. 

Den vil uunngåelig resultere i veien flere feil enn vi selv så her. Selv jeg, til denne dag, hele tiden gjøre andre dumme feil, er faktisk vanskeligere feil som er vanskeligere å finne ut. Men du vil gjøre flere feil desto mer linjer med kode du skriver på en gang. Og så denne praksisen med, skrive en liten bit av koden at du er komfortabel med, kompilere den, kjøre den, teste det mer generelt, deretter flytte on-- så akkurat som vi holdt lagdeling og lagdeling i forrige uke, å bygge fra noe veldig enkle til noe mer komplisert, gjøre det samme her. Ikke sitte ned, og prøver å skrive en hel problem. Egentlig ta disse baby trinn. 

Nå strenger er ikke alt at nyttig for seg selv. Vi hadde faktisk, ideelt sett, som å har noe annet i vår verktøykasse. Så la oss faktisk gjør akkurat det. 

La meg gå videre nå og piske opp et litt annet program. Og vi vil kalle dette int.c, for heltall. Jeg kommer til, på samme måte, inkluderer CS550.h. Jeg kommer til å omfatte standard IO. Og det kommer til å bli ganske vanlig i disse første dagene av klassen. 

Og jeg kommer til å klare meg selv med en hovedfunksjon. Og nå i stedet for å få en streng, la oss gå videre og få en int. La oss kalle det jeg, og kaller det få int, nære parens, semikolon. Og nå la oss gjøre noe med det, printf. 

La oss si noe sånt hei, backslash n, komma i. Så jeg ganske mye etterligne hva jeg gjorde bare et øyeblikk siden. Jeg har en plassholder her. Jeg har komma jeg her, fordi jeg vil ha å plugge jeg inn som plassholder. 

Så la oss gå videre og prøve kompilere dette programmet. Filen heter int.c. Så jeg kommer til å si, gjøre int, skriv. Oh my God, men ikke så farlig, ikke sant? Det er en feil. 

Det er en syntaktisk feil her slik at programmet ikke kan kompileres inne int.c, linje sju, karakter 27, feil format spesifiserer typen char stjerners, uansett hva det er. Men argumentet typen er int. 

Så også her, vi kommer ikke til to-- selv om i dag er mye av materialet, vi kommer til å overvelde deg med absolutt alle funksjonene til C, og programmering mer generelt, på bare disse første ukene. Så det er ofte kommer til å bli sjargong som du ikke er kjent. Og, faktisk er noe røye stjerne vi kommer til å komme tilbake til i en uke eller to tid. 

Men for nå, la oss se om vi kan analysere ord som er kjent. Formater-- så vi hørte format Specifier, format kode før. Det er velkjent. Type-- men argumentet har type int. Vent litt, er jeg en int. 

Kanskje prosent er faktisk har noen definert betydning. Og, ja, det gjør det. Et heltall, hvis du vil printf å erstatte det, du faktisk nødt til å bruke en annet format Specifier. Og du vil ikke vite dette med mindre noen fortalte deg, eller du hadde gjort det før. Men prosent i er hva kan være vanlige i printf for plugging i et heltall. Du kan også bruke prosent d for en desimal heltall. Men jeg er fin og enkel her. Så vi kommer til å gå med det. 

Nå la meg gå videre og reprise make int, Enter. Det er bra, ingen feil. Dot slash int-- OK, dårlig brukeropplevelse, fordi jeg ikke har fortalt meg selv hva å gjøre. Men det er fint. Jeg fanger på raskt. 

Og nå la meg gå videre og skriver i David, OK, Zamila, Rob. OK, så dette er en god ting. Denne gangen, jeg bruker en funksjon, en puslespillbrikke, kalt get int. Og det viser out-- og vi vil ser dette senere i term-- den CS50 ansatte har gjennomført få strengen på en slik måte at det vil bare fysisk få en streng for deg. 

Det har implementert get int i en slik måte at det bare vil få et heltall for deg. Og hvis du, det menneskelige, ikke samarbeider, er det bokstavelig talt bare kommer til å sier prøve, prøve, prøve på nytt, bokstavelig talt sitter der looping, inntil du tvinge med noen magiske tall, som 50, og hallo 50. 

Eller hvis vi kjører dette igjen og skriv inn 42, hallo 42. Og så get int funksjon innsiden av det puslebrikke er nok logikk, nok tanke, å finne ut, hva er et ord? Og hva er et tall? Bare akseptere, til slutt, tall. 

Så det viser seg at dette er ikke alle som uttrykksfulle. så langt. Så, yay, sist gang vi gikk ganske raskt i gjennomførings spill og animasjon, og kunstneriske verk i bunnen av. Og her er vi være fornøyd med Hello World, og hallo 50. 

Det er ikke alle som inspirerende. Og, ja, disse første par eksempler vil ta litt tid å rampen opp i spenning. Men vi har så mye mer kontroll nå, faktisk. Og vi kommer til veldig raskt begynne lagdeling på toppen av disse grunnleggende primitive. 

Men først, la oss forstå hva begrensningene er. Faktisk er en av de tingene Scratch ikke lett la oss gjøre er å virkelig se under panseret, og forstå hva en datamaskinen er, hva den kan gjøre, og hva dens begrensninger er. Og, ja, at mangel på forståelse, potensielt, langsiktig kan føre til vår egen mistakes-- skriving bugs, skriving usikker programvare som blir hacket på noen måte. 

Så la oss ta noen skritt mot forstå denne litt bedre etter måte, sier følgende eksempel. Jeg kommer til å gå videre og implementere virkelig rask et program som heter Adder. Liker, la oss legge noen tall sammen. Og jeg kommer til å kode noen hjørner her, og bare kopiere og lime inn der jeg var før, bare slik at vi kan komme i gang raskere. Så nå har jeg fått de grunnleggende begynnelse av et program kalt Adder. 

Og la oss gå videre og gjøre dette. Jeg kommer til å gå videre og si, får intx få int. Og vet du hva? La oss gjøre en bedre brukeropplevelse. 

Så la oss bare si x er, og effektivt be brukeren om å gi oss x. Og så la meg gå videre og si, printf hva y er, denne gangen venter to verdier fra brukeren. Og så la oss bare gå videre og si, printf, er summen av x og y. Og nå har jeg ikke lyst til å gjøre prosent s. Jeg ønsker å gjøre prosent i, skråstrek n, og deretter plugge i sum verdi. 

Så hvordan kan jeg gå om du gjør dette? Vet du hva? Jeg vet hvordan du bruker variabler. La meg bare erklære en ny en, int z. 

Og jeg kommer til å ta en gjetning her. Hvis det er likhetstegn i denne språk, kanskje jeg kan bare gjøre x pluss y, så lenge jeg avslutte mitt tenkte med et semikolon? Nå kan jeg gå tilbake hit ned, koble z, føre denne tanken med et semikolon. Og la oss se nå, om disse sekvenser av lines-- x er få int. Y er få int. 

Legg til x og y, lagre verdien i z-- så, igjen, husk likhetstegnet er ikke lik. Det er oppdrag fra høyre til venstre. Og la oss skrive ut at summen av x og y er ikke bokstavelig z, men hva som er inne i z. Så la oss gjøre Adder - fine, ingen feil denne gangen. Dot slash Adder, skriv, x kommer til å være en. 

Y kommer til å være to. Og summen av x og y er 3. Så det er alt fint og bra. 

Så du kan tenke at matematikk bør arbeide i et program som dette. Men vet du hva? Er denne variabelen, linje 12, selv nødvendig? Du trenger ikke å komme i vane for bare å lagre ting på variabler bare fordi du kan. Og, faktisk, er det vanligvis anses som dårlig konstruksjon hvis du oppretter en variabel, kalt z i dette tilfellet, lagre noe i det, og deretter umiddelbart bruke det, men aldri igjen. Hvorfor gi noe navn som z hvis du er bokstavelig talt kommer til å bruke den ting bare en gang, og så proksimale til der du opprettet det i første omgang, så tett i form av linjer med kode? Så vet du hva? Det viser seg at C er ganske fleksibel. Hvis jeg faktisk ønsker å plug-in verdier her, Jeg trenger ikke å erklære en ny variabel. Jeg kunne bare plug-in x pluss y, fordi C forstår aritmetikk, og matematiske operatorer. 

Så jeg kan bare si, gjøre dette regnestykket, x pluss y, uansett hva disse verdiene er, plugge den resulterende heltall inn i strengen. Så dette kan være, men bare en linje kortere, en bedre utforming, et bedre program, fordi det er mindre kode, derfor mindre for meg å forstå. Og det er også bare renere, i den grad vi er ikke introdusere nye ord, nye symboler, som z, selv om de egentlig ikke tjene mye av en hensikt. 

Dessverre er ikke matematikk alle som pålitelige noen ganger. La oss gå videre og gjøre dette. Jeg kommer til å gå videre nå og gjøre følgende. 

La oss gjøre printf, prosent i pluss prosent Jeg skal være prosent i, backslash n. Og jeg kommer til å gjøre dette-- xyx pluss y. Så jeg skal bare skrive dette litt annerledes her. La meg bare gjøre en rask mental helse sjekk. Igjen, la oss ikke komme i forkant av oss selv. Gjør huggorm, dot slash huggorm. x er 1, y er 2, 1 pluss 2 er tre. Så det er bra. Men la oss komplisere dette nå litt, og opprette en ny fil. 

Jeg kommer til å kalle dette en, si, ints, flertall for heltall. La meg starte hvor jeg var et øyeblikk siden. Men nå la oss gjøre et par andre linjer. La meg gå videre og gjøre følgende, printf, prosent i minus prosent i, er prosent i, komma x, komma yx minus y. Så jeg gjør noe annerledes matematikk der. La oss gjøre en annen. Så prosent I tider prosent Jeg er prosent i, backslash n. La oss plug-in x og y, og x ganger y. Vi bruker stjerne på datamaskinen for tiden. 

Du trenger ikke bruke x. x er variabelnavn her. Du bruker stjernen for multiplikasjon. La oss gjøre en mer. Printf prosent jeg, fordelt med prosent i, er prosent i, backslash n. xy delt på Y- så du bruker skråstrek i C å gjøre divisjon. Og la oss gjøre en annen. Resten av prosent i, fordelt med prosent i, er prosent i. xy-- og nå resten er det som er igjen. Når du prøver å dele en Nevner i en teller, hvor mye som er til overs som du kan ikke dele ut? 

Så det er egentlig ikke, nødvendigvis, et symbol vi har brukt i grunnskolen for dette. Men det i C. Du kan si x modulo y, der denne prosenttegn i denne context-- forveksling når du er inne av doble anførselstegn, innsiden av printf, prosent brukes som format Specifier. 

Når du bruker prosent utenfor at i et matematisk uttrykk det er modulo operatør for modulær arithmetic-- for vårt formål her, betyr bare, hva er Resten av x delt på y? Så x delt på y er x slash y. Hva er resten av x dividert med y? Det er x mod y, som programmerer ville si. 

Så hvis jeg gjorde ingen feil her, la meg gå videre og gjøre ints, flertall, hyggelig, og dot slash ints. Og la oss gå videre og gjør, la oss si, 1, 10. Greit, en pluss 10 er 11, sjekk. 1 minus 10 er negativ 9, sjekk. 

1 ganger 10 er 10, sjekk. 1 dividert med 10 er-- OK, vi hopper som en. Resten av 1 dividert med 10 er en. Det er riktig. Men det er en feil her. 

Så jeg satte min overlevere, ikke riktig. Jeg mener, det er nær 0. 1 dividert med 10, du vet, hvis vi er kutte noen hjørner, sikker, er det null. Men det burde egentlig være 1/10, 0,1 eller 0,10, 0,1000, og så videre. 

Det burde egentlig ikke være null. Vel, det viser seg at maskinen er gjør bokstavelig talt hva vi fortalte det til å gjøre. Vi gjør regnestykket som x dividert med y. Og både x og y, per linjene kode tidligere, er heltall. 

Dessuten, på linje 15, er vi forteller printf, hei, printf plug-in et heltall, plug-in et heltall, plug-in en integer-- spesifikt x, og deretter y, og deretter x dividert med y. x og y er ints. Vi er bra det. 

Men hva er x dividert med x? x dividert med y bør være, matematisk, 1/10, eller 0,1, som er et reelt tall, et reelt tall ha potensielt desimaltegn. Det er ikke et heltall. 

Men hva er det nærmeste heltall til 1/10 eller 0.1? Ja, den slags er null. 0.1 er som dette mye. Og en er dette mye. Så 1/10 er nærmere 0 enn det er til en. 

Og så hva C gjør for us-- slags fordi vi fortalte det to-- er avkorting som heltall. Det tar verdien, som igjen er ment å være noe sånt som 0,1000, 0 og så videre. Og det er avkorting alt etter desimaltegnet slik at hele denne ting, fordi det ikke passer inn i forestillingen om et heltall som er bare et tall som negativ 1, 0, 1, opp og ned, kaster den bort alt etter desimaltegnet fordi du kan ikke passe desimaltegn i et heltall per definisjon. 

Så svaret her er null. Så hvordan løser vi dette? Vi trenger en annen løsning alle sammen. Og vi kan gjøre dette, som følger. 

La meg gå videre og opprette en ny fil, dette kalles floats.c. Og lagre det her i samme katalog, float.c. Og la meg gå videre og kopiere noen av koden fra tidligere. 

Men i stedet for å få en int, la oss gjøre dette. Gi meg en flyttall kalt x. hvor et flyt Verdien er bare bokstavelig noe med en flytende punkt. Det kan flytte til venstre, til høyre. Det er et reelt tall. 

Og la meg kalle ikke få int, men får flyte, som også var blant menyen alternativer i C250 biblioteket. La oss endre y til en flåte. Så dette blir får flyte. 

Og nå, ønsker vi ikke å koble ints. Det viser seg at vi må bruke prosent f for float, prosent f for float, og nå lagrer det. Og nå, fingrene krysset, gjøre flyter, fine, dot slash flyter. x kommer til å være en 1. y Kommer til å være 10 igjen. 

Og, er hyggelig, OK min tillegg riktig. Jeg hadde håpet på mer, men jeg glemte å skrive det. Så la oss gå og fikse dette logisk feil. 

La oss gå videre og ta tak i følgende. Vi må bare gjøre litt kopiere og lime. Og jeg kommer til å si minus. 

Og jeg kommer til å si tider. Og jeg kommer til å si delt. Og jeg har ikke tenkt å gjøre modulo, som ikke er så germane her, delt på f, og ganger plus-- OK, la oss gjøre dette igjen. 

Gjør flyter, dot slash flyter, og 1, 10, og-- fin, nei, OK. Så jeg er en idiot. Så dette er veldig vanlig i informatikk å gjøre dumme feil som dette. 

For pedagogiske formål, hva jeg egentlig ønsket å gjøre ble endre vitenskap her til pluss, minus, til tider, og å dele, som du forhåpentligvis lagt merke til under denne øvelsen. Så nå kan vi re-kompilere dette program, gjør dot slash flyter. 

Og for tredje gang, la oss se om den oppfyller mine forventninger. 1, 10, enter, ja, OK, 1.000, delt på 10.000, er 0,100000. Og det viser seg at vi kan kontrollere hvor mange Tallene er etter disse desimaler. Vi har faktisk vil. Vi vil komme tilbake til det. 

Men nå, faktisk, er regnestykket riktig. Så, igjen, hva er takeaway her? Det viser seg at i C, er det ikke bare strings-- og faktisk det er egentlig ikke, fordi vi legger de med CS50 biblioteket. Men det er ikke bare ints. 

Det er også flyter. Og det viser seg en haug med andre data typer også, at vi vil bruke før lenge. Det viser seg at hvis du ønsker et enkelt karakter, ikke en streng med tegn, du kan bruke bare en røye. 

Det viser seg at hvis du ønsker en bool, en boolsk verdi, sant eller usant bare, takket være CS50 biblioteket, har vi tilsatt til C bool datatype i tillegg. Men det er også til stede i mange andre språk også. Og det viser seg at noen ganger trenger større tall da kommer som standard med ints og flyter. 

Og i virkeligheten er en dobbel et antall som bruker ikke 32 bits, men 64 bits. Og en lang lang er et nummer som bruker ikke 32, bits, men 64 bits, henholdsvis for flyttall verdier og heltall, henholdsvis. Så la oss faktisk nå se dette i aksjon. 

Jeg kommer til å gå videre her og piske opp en annen program. Her kommer jeg til å gå videre og inkluderer CS50.h. Og la meg gå, inkluderer standard IO.h. 

Og du vil merke noe funky som skjer her. Det er ikke fargekoding ting på samme måte som det gjorde før. Og det viser seg, det er fordi jeg har ikke gitt noe et filnavn. 

Jeg kommer til å kalle dette en sizeof.c, og traff Lagre. Og legg merke til hva som skjer med min veldig hvit kode mot den sorte bakgrunnen. Nå, i hvert fall det er noen lilla der inne. Og det er syntaks markert. 

Det er fordi, ganske enkelt, jeg har fortalte IDE hvilken type fil det er ved å gi den et navn, og spesielt en filtype. Nå, la oss gå videre og gjøre dette. Jeg kommer til å gå videre og meget bare skrive ut following-- bool er prosent LU. 

Vi vil komme tilbake til som i løpet av et øyeblikk. Og så kommer jeg til å utskriftsstørrelsen bool. Og nå, bare for å spare meg selv litt tid, jeg er kommer til å gjøre en hel haug av disse på en gang. Og spesielt, jeg kommer til å endre dette til en char og røye. Denne, kommer jeg til å endre til en dobbeltseng og en dobbel. 

Denne, kommer jeg til å endre til en flåte og en flåte. Denne, kommer jeg til å endre til en int og en int. Og dette skal jeg å bytte til en lang lang. Og det er fortsatt tar lang tid, lang lang. 

Og så, til slutt, jeg ga meg selv én for mye, streng. Det viser seg at i C, er det den spesielle operatør kalles Størrelsen på det er bokstavelig talt skal, når det kjøres, fortelle oss størrelsen på hver av disse variablene. Og dette er en måte, nå, vi kan koble tilbake til forrige ukes diskusjon av data og representasjon. 

La meg gå videre og kompilere Størrelsen på dot slash størrelse. Og la oss se. Det viser seg at i C, spesifikt på CS50 IDE, spesielt på operativsystemet Ubuntu, som er en 64-bits operativsystem Systemet i dette tilfellet en bool kommer til å bruker en byte av plass. Det er slik størrelse måles, ikke i biter, men i byte. Og husker at en byte er åtte bits. Så en bool, selv om du teknisk bare trenger en 0 eller 1, det er litt bortkastet hvordan vi har implementert det. Det er faktisk kommer til å bruke en hel byte-- så nuller, er kanskje alle de, eller noe sånt, eller bare en en blant åtte bits. 

En røye, i mellomtiden, som brukes for en karakter som en Ascii tegn per forrige uke, kommer til å være ett tegn. Og som synkroniserer med våre forestillinger om det er ikke mer enn 256 bits-- snarere synkroniserer opp med at det er ingen lengre enn 8 bits, som gir oss så mange som 256 verdier. En dobbel kommer til å være 8 byte eller 64 biter. 

En flottør er 4. En int er 4. En lang, er lang 8. Og en streng er åtte. Men ikke bekymre deg for det. Vi kommer til å skrelle tilbake det laget. Det viser seg, strenger kan være lenger enn 8 byte. 

Og, ja, vi har skrevet strenger allerede, hallo verden, lenger enn 8 byte. Men vi vil komme tilbake til som i løpet av et øyeblikk. Men take away her er følgende. 

Enhver datamaskin har bare en begrenset mye minne og plass. Du kan bare lagre så mange filer på din Mac eller PC. Du kan bare lagre så mange programmer i RAM som kjører på en gang, nødvendigvis, selv med virtuelt minne, fordi du har en begrenset mengde RAM. 

Og bare for å picture-- hvis du har aldri åpnet en laptop eller bestilles ekstra minne for en datamaskin, du kanskje ikke vet at Innsiden av datamaskinen er noe som ser litt som dette. Så dette er bare et vanlig selskap kalt Crucial som gjør RAM for datamaskiner. Og RAM er der programmene leve mens de kjører. 

Så på alle Mac eller PC, når du dobbelt Klikk et program, og det åpner opp, og det åpner noen Word-dokument eller noe sånt, den lagrer den midlertidig i RAM, fordi RAM er raskere enn harddisken, eller din solid state disk. Så det er bare der programmene gå å leve når de kjører, eller når det er i bruk filer. 

Så du har ting som ser som dette innsiden av den bærbare datamaskinen, eller litt større ting innsiden av skrivebordet ditt. Men nøkkelen er at du bare har en endelig antall av disse tingene. Og det er bare en begrenset mengde maskinvare sitter på denne pult rett her. 

Så, sikkert, vi kan ikke lagre uendelig lange tall. Og likevel, hvis du tenker tilbake til grunnskolen, hvor mange siffer kan du må rett av et punktum? For den saks skyld, hvor mange siffer kan du har til venstre for et desimaltegn? Virkelig, uendelig mange. 

Nå, vi mennesker kanskje bare vet hvordan å uttale millioner, og milliarder, billion, og kvadrillion, og quintillion. Og jeg presser grensene for min understanding-- eller my-- jeg forstår tall, men min uttale av tall. Men de kan få uendelig stor med uendelig mange Sifrene til venstre eller til høyre for et desimaltegn. 

Men datamaskiner har bare en begrenset mengde minne, et endelig antall transistorer, en endelig antall lyspærer inne. Så hva skjer når du går tom for plass? Med andre ord, hvis du tenker tilbake til forrige uke når vi snakket om tall seg å være representert i binær, anta at vi har fått denne 8-bits verdi her. 

Og vi har syv en og en 0. Og anta at vi ønsker å legge en til denne verdien. Dette er et virkelig stort tall akkurat nå. 

Dette er 254, hvis jeg husker matematikk fra forrige uke rett. Men hva hvis jeg endrer det lengst til høyre 0 til en 1? Det hele tall, av Selvfølgelig blir åtte 1-tallet. Så vi er fortsatt god. 

Og som sannsynligvis representerer 255, men avhengig av kontekst det kan faktisk representere et negativt tall. Men mer om det en annen gang. Dette føles som det er om så høyt som jeg kan telle. 

Nå er det bare 8 bits. Og min Mac, sikkert, har veien mer enn 8 biter av minne. Men det har endelig. Slik at den samme argument gjelder, selv om vi har flere av disse seg på skjermen. 

Men hva skjer hvis du er lagre dette nummeret, 255, og du vil telle en litt høyere? Du ønsker å gå 255-256. Problemet er selvfølgelig at hvis du begynne å telle på null som forrige uke, du kan ikke telle så høyt 256, enn si 257, enn si 258, m fordi det skjer når du legger til en 1? Hvis du gjør den gamle barneskolen tilnærming, sette deg en 1 her, og deretter en pluss en er to, men det er virkelig en null, bære deg på en, bære en, bærer en. Alle disse tingene, disse 1-tallet, gå til null. Og du ender opp med, ja, som noen påpekt, en 1 på venstre side. Men alt du kan faktisk ser og passer i minnet er bare åtte 0-er, som er å si på et tidspunkt hvis du, en datamaskin, prøvde å telle høyt nok opp, er du kommer til å vikle rundt, det ville virke, til null, eller kanskje til og med negativ tall, som er enda mindre enn null. 

Og vi kan slags se dette. La meg gå videre og skrive en virkelig rask program her. La meg gå videre og skrive et program som heter Flow. Inkluder CS50.h inkluderer standard IO.h-- oh, Jeg virkelig savnet min syntax highlighting. Så la oss lagre dette som overflow.c. 

Og nå int main void-- og før lenge, vil vi komme tilbake til å forklare hvorfor vi holde skrive int main annullert. Men for nå, la oss bare gjøre det, tar det for gitt. La oss gi meg selv en int, og initialisere den til 0. 

La oss da gjøre for int jeg få zero-- faktisk, la oss gjøre en uendelig loop og se hva som skjer. Mens sant, så la oss skrive ut n er prosent i, backslash n, plug-in n. Men nå, la oss gjøre n får n pluss en. 

Så med andre ord, på hvert gjentakelse av denne uendelig loop, la oss ta n verdi, og legge en til det, og deretter lagre resultatet tilbake i n til venstre. Og, faktisk, har vi sett syntaks noe som dette, en kort stund. En kul Trikset er stedet for å skrive ut alt dette, du kan faktisk si en n pluss er lik en. 

Eller hvis du virkelig ønsker å være fancy, du kan si n pluss pluss semikolon. Men disse to sistnevnte er bare hva vi vil kalle syntaktisk sukker for det første. 

Det første er mer eksplisitt, helt greit, helt riktig. Men dette er mer vanlig, vil jeg si. Så vil vi gjøre dette for bare et øyeblikk. 

La oss nå gjøre overløp, som lyder heller illevarslende, dot slash overløp. La oss se, n begynner å bli ganske stor. Men la oss tenke, hvor stor kan n få? 

n er et int. Vi så et øyeblikk siden med størrelsen på eksempel at en int er fire byte. Vi vet fra forrige uke, er fire byte 32 biter, fordi 8 ganger 4, som er 32. Det kommer til å bli 4 milliarder. 

Og vi er opptil 800.000. Dette kommer til å ta en evighet å telle så høyt som jeg muligens kan. Så jeg kommer til å gå videre, som du kanskje før lenge, og traff kontroll C-- ærlig, Kontroll C, mye, hvor kontroll C vanligvis midler avbryte. Dessverre, fordi denne kjører i skyen, noen ganger skyen er spytter ut så mye ting, så mye utgang, kommer det til å ta en liten stund for mine innspill for å komme til nettskyen. Så selv om jeg traff Kontroll C et par sekunder siden, Dette er definitivt den siden Effekten av en uendelig loop. 

Og så i slike tilfeller, er vi kommer til å la det være. Og vi kommer til å legge til en annen terminalvindu over her med pluss, som selvfølgelig ikke sånn, siden det er fortsatt tenker. Og la oss gå videre og være litt mer fornuftig. 

Jeg kommer til å gå videre og gjøre dette bare begrenset mange ganger. La oss bruke en for loop, som jeg antydet tidligere. La oss gjøre dette. Gi meg en annen variabel int jeg får 0. Jeg er mindre enn, la oss si, 64 i ++. Og nå la meg gå videre og print ut n er prosent i, komma n. Og så N- dette er fortsatt kommer til å ta en evighet. La oss gjøre dette. 

n blir n ganger 2. Eller vi kan være fancy og gjøre tider lik 2. Men la oss bare si n er lik seg selv, ganger 2. Med andre ord, i denne ny versjon av programmet, Jeg ønsker ikke å vente for alltid fra lignende 800 000 til 4000 millioner. La oss bare få dette overstått. 

La oss faktisk dobbelt n hver gang. Som, husker, er dobling av det motsatte av ha, selvfølgelig. Og mens forrige uke har vi noe igjen, og igjen, og igjen, super rask, dobling vil sikkert få oss fra en til størst mulig verdi som vi kan telle til med en int. 

Så la oss gjøre akkurat dette. Og vi vil komme tilbake til dette før lenge. Men dette, igjen, er akkurat som gjentakelses blokken i Scratch. Og du vil bruke dette før lenge. 

Dette betyr bare telle fra null opp til, men ikke like, til 64. Og på hver iterasjon av dette loop, bare holde økes i. Så i ++ - og denne generelle konstruksjon på linje 7 er bare en super vanlig måte for å gjenta noen linjer av kode, et antall ganger. Hvilke linjer med kode? Disse klammeparentes, som du kan ha sanket fra nå, betyr, gjør du følgende. 

Det er i like Scratch, når den har den gule blokkene og andre farger den slags omfavne eller klem andre blokker. Det er det de krøllete bukseseler gjør her. Så hvis jeg fikk min syntaks right-- deg kan se gulrot symbol i C midler det er hvor mange ganger jeg var prøver å løse dette problemet. Så la oss bli kvitt det en helt, og lukk det vinduet. Og vi kommer til å bruke den nye. Gjør overløp, dot slash overløp, Enter, all right, det ser dårlig i begynnelsen. Men la oss bla tilbake i tid, fordi jeg gjorde dette 64 ganger. 

Og legg merke til første gang, er n 1. Andre gang, er n 2, deretter 4, deretter 8, deretter 16. Og det virker som snarest Jeg får omtrent 1 milliard, hvis jeg doble det igjen, at bør gi meg 2 milliarder. Men det viser seg, er det rett på cusp. 

Og slik er det faktisk renner over en int fra 1 milliard til omtrent negative 2 milliarder, fordi et heltall, i motsetning til tallene vi var forutsatt i forrige uke, kan være både positiv og negativ i virkeligheten og i en datamaskin. Og slik at i det minste en av disse biter effektivt stjålet. Så vi egentlig bare har 31 bits, eller 2 milliarder mulige verdier. 

Men for nå, er det takeaway ganske enkelt, uansett disse tallene er og hva matematikk er, noe dårlig skjer til slutt, fordi slutt du prøver å permutere biter en for mange ganger. Og du effektivt gå fra alt En er å kanskje alle 0-tallet, eller kanskje bare noen andre mønster som det klart, avhengig av sammenhengen, kan tolkes som et negativt tall. Og så vil det synes den høyeste jeg kan telle i dette spesielle programmet er bare om lag 1 milliard. Men det er en delvis løsning her. Vet du hva? 

La meg endre seg fra en int til en lang lang. Og la meg gå videre her og say-- jeg kommer til å ha å endre dette til en usignert lang. Eller, la oss se, jeg aldri huske meg selv. 

La oss gå videre og gjøre overløp. Nei, det er ikke det, LLD, takk. Så noen ganger klang kan være nyttig. Jeg husker ikke hva formatet Specifier var i lang lang. 

Men, ja, fortalte klang meg. Green er en slags god, fortsatt betyr at du har gjort en feil. Det gjetter at jeg mente LLD. 

Så la meg ta det råd, en lang lange desimaltall, lagre det. Og la meg kjøre den, dot slash overløp, Enter. Og nå hva som er kult er dette. 

Hvis jeg blar tilbake i tid, vil vi likevel starte telling på samme sted-- 1, 2, 4, 8, 16. Legg merke til, får vi alle helt opp til 1 milliard. Men da vi trygt komme til 2 milliarder. 

Så får vi til 4 milliarder kroner, deretter 8 milliarder kroner, 17 milliarder. Og vi går høyere, og høyere, og høyere. Til slutt, dette også, pauser. 

Til slutt, med en lang lang, som er den 64-bits verdi, ikke en 32-biters verdi, hvis du teller for høyt, du vikle rundt 0. Og i dette tilfelle skje til vi ende opp med et negativt tall. 

Så dette er et problem. Og det viser seg at dette Problemet er ikke alle som uforståelige. Selv om jeg har bevisst indusert det med disse feilene, det viser seg at vi ser det slags alt rundt oss, eller i det minste noen av oss gjør. 

Så i Lego Star Wars, hvis du noen gang har spilt spillet, det viser seg at du kan gå rundt bryte opp ting i LEGO verden, og samle mynter, egentlig. Og hvis du noen gang har spilt dette spillet altfor mye tid, da dette ikke navngitte personen her gjorde, det totale antallet mynter som du kan samle er, det ville virke, 4 milliarder. 

Nå, med det er faktisk avrundet. Så LEGO prøvde å holde ting brukervennlig. De gjorde ikke det nøyaktig to til 32 makt, per i forrige uke. Men 4000000000 er en grunn. Det virker, basert på denne informasjonen, som LEGO, og selskapet som gjort dette selve programvaren, besluttet at det maksimale antall mynter brukeren kan akkumulere er faktisk 4 milliarder kroner, fordi de valgte i koden sin å bruke ikke en lang lang, tilsynelatende, men bare et tall, en usignert heltall, bare et positivt heltall, hvis max verdi er omtrent det. Vel, her er en annen morsom en. Så i spillet Civilization, som noen av dere kan bli kjent med det viser seg at år siden det var en feil i dette spillet der hvis du har spilt rollen av Gandhi i spillet, i stedet for ham å være veldig pasifist, stedet var utrolig, utrolig aggressiv, i enkelte tilfeller. Spesielt den måten at Civilization verker er at hvis du, spilleren, vedta demokrati, din aggressivitet poengsum blir dekrementert med to, så minus minus, og deretter minus minus. 

Så du trekker 2 fra faktiske itera. Dessverre, hvis din itera er innledningsvis en, og du trekker 2 fra det etter å vedta demokrati som Gandhi her kanskje har gjort, fordi han var veldig passive-- 1 på skalaen av aggressivitet. Men om han vedtar demokrati, deretter han går fra en negativ en. 

Dessverre var de ved hjelp av usignerte tall, som betyr at de behandles med negativ tall som om de var positive. Og det viser seg at positiv tilsvarende negativ en, i typiske dataprogrammer, er 255. Så hvis Gandhi vedtar demokrati har, og derfor hans aggressivitet poengsum redusert, det faktisk ruller rundt til 255 og gjør ham til den mest aggressive karakter i spillet. Så du kan google opp på dette. Og det var faktisk en utilsiktet programmering bug, men det er inngått helt lore siden den gang. 

Det er alt morsomme og søte. Mer skremmende er når selve virkelige verden enheter, og ikke spill, har de samme feilene. Faktisk bare et år siden kom en artikkel ut om Boeing 787 Dreamliner. 

Og artikkelen først blikk leser litt uforståelige. Men det sa dette, en programvare sårbarhet i Boeings nye 787 Dreamliner jet har potensial til å forårsake piloter å miste kontrollen over luftfartøyet, eventuelt i mid-flight, de FAA tjenestemenn advart flyselskaper nylig. Det var bestemmelsen som en modell 787 fly som har blitt drevet kontinuerlig i 248 dager kan miste all vekselstrøm, AC, elektrisk kraft på grunn av generatoren kontrollenheter, GCUs, samtidig går inn fail safe mode. Det er litt for å miste meg. Men memo oppgitt, OK, nå fikk jeg det, tilstanden var forårsaket av en programvare motvirke interne til generatoren styre enheter som vil overløp etter 248 dager med kontinuerlig strøm. Vi foretar denne varsel for å hindre tap av alle AC elektrisk makt, noe som kan resultere i tap av kontroll over flyet. 

Så, bokstavelig talt, er det noen heltall, eller noen tilsvarende datatype, brukes i programvare i en faktisk fly at hvis du holder flyet på lenge nok, som tilsynelatende kan være tilfelle hvis du bare kjører dem hele tiden og aldri frakobling flyet, synes det, eller la batteriene dør, vil til slutt telle opp, og opp, og opp, og opp, og opp, og opp. 

Og, av natur, en begrenset mengde minne vil renne over, rulle tilbake til null eller noen negativ verdi, en bivirkning av dette er det skremmende realistisk virkelighet at flyet måtte trenge startes på nytt, effektivt, eller kan falle enda verre, som den flyr. Så slike problemer er fortsatt med oss, even-- dette var en 2015 artikkel, desto mer skremmende når du ikke nødvendigvis forstå, verdsette, eller forutse slike feil. 

Så det viser seg at det finnes en annen dårlig ting om data representasjon. Det viser seg at selv flyter er slags feil, fordi flyter, også, Jeg foreslo er 32 biter, eller kanskje 64 hvis du bruker en dobbel. Men det er fortsatt begrenset. 

Og fangsten er at hvis du kan sette et uendelig antall tall etter desimaltegnet, det er ingen måte du kan representere alle mulige tall som vi ble undervist i grunnskolen kan eksistere i verden. En datamaskin, i hovedsak, må velge et delsett av disse tallene å representere nøyaktig. 

Nå kan datamaskinen runde kanskje litt, og kan tillate deg å omtrent butikken så mange du kan ønske deg. Men akkurat intuitivt, hvis du ha et endelig antall biter, du kan bare permutere dem i så mange begrensede måter. Så du kan ikke muligens bruke et endelig antall av permutasjon av biter, mønstre av nuller og enere, for å representere en uendelig antall tall, noe som antyder at datamaskiner kanskje meget vel være å lyve for oss noen ganger. 

Faktisk, la oss gjøre dette. La meg gå tilbake til CS50 IDE. La meg gå videre og lage et lite program kalt upresisjon, for å vise at datamaskiner er faktisk upresis. 

Og la meg gå videre og begynne med noe av det koden fra før, og nå bare gjøre følgende. La meg gå videre og gjøre printf, prosent f, backslash n, 1 delt på 10. Med andre ord, la oss dykke i dypere 1/10, som en og delt på 10. Sikkert, kan en datamaskin representerer 1/10. 

Så la oss gå videre og gjøre unøyaktighet. La oss se. Format angir Double. Men argumentet har type int. Hva skjer? 

Åh, det er interessant så en lekse lært fra før. Jeg sier hei, datamaskin showet meg en flåte med prosent f. Men jeg gir det 2 ints. Så det viser seg, kan jeg fikse dette i et par måter. 

Jeg kunne bare slå ett til 1.0, og 10 til 10,0, noe som ville faktisk har effekten av å konvertere dem inn floats-- fortsatt forhåpentligvis samme nummer. Eller det viser seg at det er noe vi vil se igjen før lenge. Du kan kaste tallene. 

Du kan bruke denne parentes uttrykk, kan du si, hei, datamaskin, ta denne 10, som jeg vet er en int. Men behandle den, vær så snill, som om det er en flåte. Men dette føles unødvendig komplisert. 

For vårt formål i dag, la oss bare bokstavelig gjør dem flytende punkt verdier med et desimaltegn som dette. La meg gå videre og reprise, gjør upresishet, god, dot slash unøyaktighet, skriv. OK, vi ser bra. 

1 delt på 10, ifølge min Mac her, er faktisk 0,100000. Nå ble jeg undervist i grunnskolen der bør være et uendelig antall 0-er. Så la oss i det minste prøve for å se noen av dem. Det viser seg at printf er litt avansert fremdeles enn vi har brukt. Det viser seg at du ikke trenger å spesifisere bare prosent f, eller bare prosent i. Du kan faktisk spesifisere noen kontroll alternativer her. 

Nærmere bestemt, jeg kommer å si hei, printf, faktisk vise meg 10 desimaler. Så det ser litt rart. Men du sier prosent, dot, hvor mange tall du ønsker å se etter desimaltegn og deretter f for flat, bare fordi det er hva dokumentasjonen sier. La meg gå videre og lagre det. 

Og legg merke til også, jeg får lei av å måtte skrive ting. Så jeg bare sette den opp og pil ned på mine nøkler her. Og hvis jeg fortsetter å trykke opp, kan se alle kommandoene som jeg gjorde, eller feil gjort. 

Og jeg kommer til å gå videre nå og faktisk ikke bruke det, tydeligvis. Gjør unøyaktig, dot slash imprecision-- så hva jeg ble undervist i grunnskolen sjekker ut. Selv om jeg skriver det ut til 10 desimal plasserer den faktisk er 0,10000. Men vet du hva? 

La oss få litt grådig. La oss si, for eksempel, vis meg 55 poeng etter desimaltegnet. La oss virkelig ta dette programmere for en snurr. La meg remake det med make upresishet, dot slash, unøyaktighet. 

Og her går vi. Barndommen var en løgn. Tilsynelatende, 1 dividert med 10 er faktisk 0.100000000000000005551115123-- 

Hva skjer? Vel, det viser seg, hvis du slags se langt nok ut i den underliggende representasjon av dette nummer, er det faktisk er ikke akkurat 1/10, eller 0,1 og et uendelig antall nuller. Nå, hvorfor er det? 

Også, selv om dette er en enkel nummer til oss mennesker, en delt med 10, det er fortsatt en av uendelig mange tall som vi kunne tenke seg. Men en datamaskin kan bare representere begrenset mange så tall. Og så, effektivt, hva Datamaskinen viser oss er dens nærmeste tilnærming til antall vi ønsker å tro er 1/10, eller egentlig 0,10000 ad infinitum. 

Snarere, skjønt, er dette så nær som det kan få. Og, ja, hvis du ser under panseret, som vi er her ved å se 55 sifre etter desimaltegnet, vi faktisk se at virkeligheten. Nå som en side, hvis du har noensinne sett movie-- de fleste av dere sikkert haven't-- men Superman 3 for noen år siden, Richard Pryor i hovedsak utnyttes dette realitet i hans selskap å stjele mye av fraksjoner og fraksjoner av pennies, fordi company-- som jeg husker, det har vært en while-- var i hovedsak kaste vekk alt som ikke passet inn begrepet cent. 

Men hvis du legger opp alle disse bitte, bitte små, små tall igjen, og igjen, og igjen, kan du, som i hans tilfelle, gjør en god sum penger. 

Den samme ideen ble dratt ut av en nyere, men likevel nå eldre film, kalt Office Space, hvor gutta i den filmen, gjorde det samme, skrudd den opp helt, endte opp med altfor mye penger i sin bankkonto. Det var veldig mistenkelig. Men ved slutten av dagen, unøyaktighet er alt rundt oss. 

Og som også kan være skremmende tilfelle. Det viser seg at Superman 3 og Office Space til side, det kan være noen svært reell verdens ramifications av realitetene i upresise representasjon av data at selv vi mennesker til denne dagen ikke nødvendigvis forstår så godt som vi burde, eller husker så ofte som vi burde. Og, ja, er følgende klipp fra en titt på noen svært virkelige verden konsekvensene av hva som skjer hvis du ikke setter pris på unøyaktighet som kan skje i tall representasjon. 

[VIDEO PLAYBACK] 

-Computers, Vi har alle kommet til å akseptere de ofte frustrerende problemer som gå med mer testing bugs, virus, og programvare glitches, for liten pris å betale for enkelhets skyld. Men i high tech og høy hastighet militære og romprogram applikasjoner, den minste kan problemet foredles til katastrofe. 

På den 4 juni 1996, forskere forberedt å lansere en ubemannet Ariane 5 rakett. Det var bærer vitenskapelig satellitter konstruert å etablere nøyaktig hvordan Jordens magnetfelt samhandler med solvind. Raketten ble bygget for European Space Agency, og løftet av fra sitt anlegg på kysten av Fransk Guyana. 

-På Ca 37 sekunder inn flyturen, de første la merke til noe gikk galt. Dysene ble svinge i en måte de egentlig ikke burde. Rundt 40 sekunder inn i fly, klart, bilen var i trøbbel. 

Og det er når de har gjort en beslutning om å ødelegge det. Utvalget verneleder, med enorm guts, trykket på knappen, blåste opp raketten, før det kunne bli en fare for offentlig sikkerhet. 

-Dette Var jomfru reise Ariane 5. Og dens ødeleggelse tok sted på grunn av en feil innebygd i raketten programvare. -Den Problem på Ariane var at det var et tall som kreves 64 bits for å uttrykke. Og de ønsket å konvertere det til en 16-bits nummer. De antok at nummer ble aldri kommer å være meget stor, at de fleste sifre i en 64-bits tall var nuller. De var galt. 

-Den Manglende evne til en program for å ta imot den type tall som genereres av en annen var ved roten av svikt. Programvareutvikling hadde blitt en svært kostbare delen av ny teknologi. Ariane rakett har vært veldig vellykket, så mye av programvaren opprettet for den ble også brukes i Ariane 5. 

-Den Grunnleggende problemet var at Ariane 5 var raskere, akselerert raskere. Og programvaren hadde ikke sto for det. 

-Den Ødeleggelse av raketten var en stor økonomisk katastrofe, alt på grunn av en liten programvarefeil. Men dette var ikke den første data konvertering problemer tids hadde plaget moderne rakett-teknologi. 

-I 1991, med start av den første Gulf-krigen, patriot Missile opplevd en lignende type av antall konvertering problem. Og som et resultat av 28 personer, 28 amerikanske soldater, ble drept, og om 100 andre såret, når Patriot, som var ment for å beskytte mot innkommende scuds, ikke klarte å avfyre ​​en rakett. 

-Når Irak invaderte Kuwait, og Amerika lansert Desert Storm i begynnelsen av 1991, Patriot Missile batteriene ble utplassert å beskytte Saudi Arabia og Israel fra irakiske Scud rakettangrep. The Patriot er en amerikansk mellomdistanse overflaten til luftsystem, produsert av Raytheon selskapet. 

-Den Størrelsen på Patriot interceptor selv er ca omtrent 20 fot lang. Og den veier ca 2000 pounds. Og det bærer et stridshode av om, Jeg tror det er omtrent 150 pounds. Og stridshodet i seg selv en høy eksplosiv, som har fragmenter rundt det. Hylsteret av stridshodet er laget for å fungere som haggel. 

-De Missiler er gjennomført fire per container, og transporteres av en semitrailer. 

-The Patriot anti-missilsystem går tilbake minst 20 år nå. Det ble opprinnelig utviklet som et luftforsvar rakett å skyte ned fiendtlige fly. I den første Gulf-krigen, når den krigen kom, Hæren ønsket å bruke den til å skyte ned scuds, ikke fly. 

Den irakiske Air Force var ikke så mye av et problem. Men hæren ble bekymret scuds. Og så de prøvde å oppgradere Patriot. 

-Intercepting En fiende rakett reiser på mach 5 skulle være utfordrende nok. Men da Patriot ble styrtet inn i tjeneste, Hæren var ikke klar over en Irakiske modifikasjon som gjorde sine scuds nesten umulig å treffe. 

-Hva Skjedde er scuds som skulle komme inn var ustabil. De ble vingler. Grunnen til dette var irakerne, for å få 600 kilometer ut av en 300 kilometer range rakett, tok vekt ut av frontstridshode. De gjorde stridshodet lettere. 

Så nå patriot er prøver å komme på Scud. Og mesteparten av tiden, overveldende flertall av tiden, det ville bare fly av Scud. Når systemoperatørene Patriot innså Patriot savnet sitt mål, de detonerte Patriot stridshode for å unngå mulige tap hvis det ble tillatt å falle ned på bakken. 

-Det Var hva folk flest så, de store ildkuler på himmelen, og misforstått som avskjærer av Scud-stridshoder. 

-Selv Om i natt himmel, Patriots dukket å være vellykket ødelegge scuds, i Dhahran, det kan være noen feil om ytelsen. Der patriot radar system mistet oversikten over innkommende Scud, og aldri lansert på grunn til en programvare feil. Det var israelerne som først oppdaget at jo lenger var systemet på, jo større tidsavvik ble, på grunn av en klokke innleiret i systemet datamaskin. 

-Om To uker før tragedien i Dhahran, israelerne rapportert til Forsvarsdepartementet at systemet var å miste tid. Etter ca åtte timer eller løping, de la merke til at systemet var blitt merkbart mindre nøyaktig. Forsvarsdepartementet svarte med å fortelle alle Patriot batterier å ikke la systemene på for en lang tid. De sa aldri hva en lang tid var-- åtte timer, 10 timer, 1.000 timer. Ingen visste. 

-The Patriot batteri stasjonert ved brakkene på Dhahran og dens feil interne klokke hadde vært på over 100 timer på natten av 25 februar. 

-Det Spores tid med en nøyaktighet av omtrent en tiendedel av et sekund. Nå, en tidel av et sekund er et interessant tall, fordi det ikke kan uttrykkes i binær nøyaktig som betyr det ikke kan uttrykkes nøyaktig i enhver moderne digital datamaskin. Det er vanskelig å tro. 

Men bruker dette som et eksempel. La oss ta nummer én tredjedel. En tredjedel kan ikke bli uttrykt i desimal nøyaktig. En tredjedel er 0,333 pågått i det uendelige. 

Det er ingen måte å gjøre det med absolutt nøyaktighet i desimal. Det er akkurat den type problem som skjedde i Patriot. Jo lenger systemet løp, den verre tiden feilen ble. 

-Etter 100 timers drift, feil i tiden var bare om lag en tredel sekund. Men når det gjelder å målrette en rakett reiser på mach 5, Det resulterte i en relativ feil på over 600 meter. Det ville være en fatal feil for soldatene på hva skjedde det en Scud lansering var oppdaget av tidlig varsling satellitter og de visste at Scud var Kommer i sin generelle retningen. De visste ikke hvor det kom. 

-Det Var nå opp til radaren komponent av Patriot-systemet forsvare Dhahran å finne og holde spor av den innkommende fiendtlige missilet. 

-Den Radar var veldig smart. Det ville faktisk spore posisjonen til Scud, og deretter forutse hvor det sannsynligvis vil være det neste gang radaren sendt en puls ut. Det ble kalt en rekke gate. 

-Da, Når Patriot bestemmer nok tid har vedtatt å gå tilbake og sjekke neste plassering for denne oppdagede objektet, det går tilbake. Så når det gikk tilbake til feil sted, ser det da ingen objekt. Og det bestemmer seg for at det ikke var noen objekt, det var en falsk deteksjon, og faller sporet. 

-Den Innkommende Scud forsvant fra radarskjermen. Og sekunder senere, slengte inn i festningen. Den Scud drepte 28, og var den siste en avfyrt under den første Golfkrigen. 

Tragisk nok den oppdaterte programvaren kom til Dhahran neste dag. Programvaren feil hadde vært fast, lukking ett kapittel i den urolige Historien om Patriot rakett. 

[VIDEO PLAYBACK] DAVID J. MALAN: Så dette er alt for si at disse problemene av overløp og unøyaktighet er altfor reell. Så hvordan kom vi hit? Vi begynte med bare snakker om printf. Igjen, denne funksjon som skriver noe til skjermen, og vi introduserte etterpå noen andre funksjoner fra den såkalte CS50 bibliotek. Og vi vil fortsette å se disse i rett tid. Og vi, spesielt brukt get streng, og få int, og nå får også flyte, og atter andre fortsatt vil vi møte og bruker oss selv før lenge. 

Men til tider, har vi allerede sett et behov til å lagre hva disse funksjonene hånd tilbake? De gi oss tilbake en streng, eller en int, eller en flåte. Og noen ganger trenger vi å sette det streng, eller int eller float, et sted. 

Og for å lagre disse tingene, husker bare som i Scratch, har vi variabler. Men i motsetning til i Scratch, i C har vi faktiske typer av variables-- data typer, flere generally-- blant dem, en streng, en int, en flyte, og disse andre fortsatt. 

Og så når vi erklære variabler i C, vi må erklære våre datatyper. Dette er ikke noe vi vil må gjøre senere i semesteret som vi overgangen til andre språk. Men for nå, trenger vi til a priori på forhånd, forklare til datamaskinen hva slags av variable ønsker vi å gi oss. 

Nå, i mellomtiden, for å skrive ut slike datatyper, vi har å fortelle printf hva du kan forvente. Og vi så prosent s for strykere, og prosent i for heltall, og noen få andre allerede. Og de er rett og slett krav for visuell presentasjon av denne informasjonen. 

Og hver av disse kan faktisk være parametrized eller forskjøvet på noen måte, Hvis du ønsker å ytterligere kontroll av utskriftstypen som du får. Og, faktisk, viser det seg at ikke bare er det backslash n for en ny linje. Det er noe annet som kalles omvendt skråstrek r for et linjeskift, som er mer beslektet med en old school skrivemaskin, og også Windows brukt i mange år. 

Det er backslash t for faner. Det viser seg at hvis du ønsker å dobbel sitat inne i en streng, Husk at vi har brukt double quote dobbel sitat på venstre og høyre ender av de strenger hittil. Det ville synes å forvirre ting. 

Hvis du ønsker å sette en dobbel sitat i midt i en string-- og, faktisk, det er forvirrende å se. Og så må du rømme, så å snakke, en dobbel sitat med noe som, bokstavelig talt, backslash dobbel sitat. Og det er noen andre fortsatt. Og vi vil se mer av dem i faktisk bruk før lenge. 

Så la oss nå overgang fra data, og representasjon, og aritmetiske operatører, alle som ga oss noen bygning blokker med å spille. Men la oss nå faktisk gi oss resten av vokabular at vi allerede hadde forrige uke med Scratch ved å ta en titt på noen andre konstruksjoner i C-- ikke alle av dem. Men ideene vi er om å se egentlig bare å understreke oversettelsen fra ett språk, Scratch, til en annen, C. 

Og over tid, vil vi plukke opp flere verktøy for vår verktøykasse, så å si, syntaktisk. Og, ja, vil du se at ideene er nå ganske kjent fra forrige uke. Så la oss gjøre dette. 

La oss gå videre og piske opp et program som faktisk bruker noen uttrykk, en boolsk uttrykk. La meg gå videre her og opprette en ny fil. Jeg vil kalle dette condition.c. 

La meg gå videre og inkluderer CS50 biblioteket. Og la meg gå videre og omfatte standard IO.h for våre funksjoner, og printf, og henholdsvis mer. La meg gi meg selv at standardtekst av int main ugyldig, hvis forklaring vi vil komme tilbake til i fremtiden. 

Nå la meg gå videre og gi meg selv en int via get int. Så la meg gå videre og gjøre dette. Jeg ønsker å si om jeg er less-- la oss skille mellom positive, negative eller nullverdier. 

Så hvis jeg er mindre enn null, la meg bare har dette programmet bare si: negativ, backslash n, annet hvis jeg er større enn null. Nå er jeg selvsagt kommer til å si printf positiv, backslash n. Og så ellers if-- jeg kunne gjøre dette. 

Jeg kunne gjøre hvis jeg er lik 0. Men jeg vil være å gjøre på Minst en feil allerede. Husker at likhetstegnet er ikke lik, som vi mennesker vet det. 

Men det er oppdraget operatør. Og vi ønsker ikke å ta 0 på høyre og sette den i jeg til venstre. Så for å unngå denne forvirringen, eller kanskje misbruk av likhetstegnet, mennesker bestemte seg for noen år siden at i mange programmeringsspråk når du ønsker å sjekke for likestilling mellom venstre og høyre, du faktisk bruker lik likemenn. Så du treffer likhetstegnet to ganger. Når du vil tilordne fra høyre til venstre, bruker du et enkelt likhetstegn. Så vi kunne gjøre dette-- annet hvis jeg er lik lik null. 

Jeg kunne da gå og åpne mine klammeparentes, og si: printf 0, backslash n, gjort. Men husk hvordan disse gafler i veien kan fungere. Og, egentlig, bare tenke på logikk. i er et tall. Det er et heltall, spesielt. Og det betyr at det kommer til å bli mindre enn 0 eller større enn 0, eller 0. Så det er litt av denne implisitt standard sak. 

Og så vi kunne, akkurat som Scratch, dispensere med annet hvis, og bare si annet. Logisk, hvis du programmerer vet det er bare tre bøtter inn som en scenario kan fall-- den første, den andre eller den tredje i denne case-- ikke gidder å legge den ekstra presisjon og den ytterligere logikk der. Bare gå videre med Standard tilfelle her av andre. 

Nå, la oss gå videre etter lagring dette, må forhold dot slash conditions-- ikke en stor brukergrensesnitt, fordi jeg ikke spørre bruker, som jeg nevnte tidligere. Men det er fint. Vi vil holde det enkelt. La oss prøve nummer 42. Og det er positivt. La oss prøve nummer negativ 42, negativ. 

La oss prøve verdien 0. Og, ja, det fungerer. Nå vil du se med problemer før lange, testing ting tre ganger, sannsynligvis ikke tilstrekkelig. Du har sannsynligvis vil teste noen større tall, noen mindre tall, noen hjørne tilfeller, for eksempel vi vil komme til å beskrive dem. 

Men for nå, er dette en ganske enkelt program. Og jeg er ganske sikker på, logisk, at den faller inn i tre tilfeller. Og, ja, selv om vi bare fokusert på de potensielle negative av upresishet og overløp, i virkelighet der mange av CS50 problemer, Vi kommer ikke til å bekymre om, hele tiden, disse spørsmålene av overløp og unøyaktig, fordi, i virkeligheten, i C, det er faktisk ikke alle som lett å unngå disse tingene. Hvis du ønsker å telle opp større, og større, og større, det viser seg at det er teknikker du kan bruke, ofte med ting som kalles biblioteker, samlinger av kode, som andre skrev som du kan bruke, og andre språk som Java og andre, faktisk gjøre det mye enklere å telle enda høyere. Så det virkelig er noen av disse farene en funksjon av språket du bruker. Og i de kommende ukene, vil vi se hvor farlig C egentlig kan være hvis du ikke bruker den riktig. Men derfra, og med Python, og Javascript, vil vi lag på noen ekstra beskyttelse, og kjøre færre av disse risikoene. 

Så la oss gjøre litt mer interessant logikk i vårt program. Så la meg gå videre og skape et program som heter Logical bare så jeg kan spille med noen Selve logikk, logical.c. Jeg skal bare kopiere og lime inn noen kode fra tidligere slik at jeg får tilbake til dette fint utgangspunkt. 

La meg denne gangen gjør char C. Jeg er kommer til å gi det et navn på C bare fordi det er vanlig, får en karakter fra brukeren. Og la oss late som Jeg gjennomføre en del av at Rm programmet, remove program før det blir bedt om brukeren å fjerne en fil. Hvordan kan vi gjøre dette? 

Jeg vil si, hvis C er lik lik, sitat unquote, y, så jeg kommer til å anta som brukeren har valgt ja. Jeg skal bare skrive ut ja. Hvis det var faktisk skriver fjerning program, vi kunne fjerne filen med flere linjer med kode. Men vi vil holde det enkelt. 

Else hvis c er lik lik N- og nå her, kommer jeg til å si, brukeren må ha betydd noe. Og så ellers, vet du hva? Jeg vet ikke hva annet brukeren kommer til å skrive. Så jeg skal bare si at det er en feil, uansett han eller hun faktisk skrevet. 

Så hva er det som skjer her? Det er en fundamental forskjell i motsetning til hva jeg har gjort i fortiden. Doble anførselstegn, anførselstegn, dobbel sitater, og ennå, enkle anførselstegn, apostrof. Det viser seg i C, at når du ønsker å skrive en streng, du bruker doble anførselstegn, akkurat som vi har brukt hele denne tiden med printf. 

Men hvis du ønsker å forholde seg til bare en enkelt tegn, en såkalt røye, så du faktisk bruke enkle anførselstegn. De av dere som har programmert før, kan du ikke ha måtte bekymre deg for dette skillet på enkelte språk. I C, gjør det noe. Og så når jeg får en røye og jeg ønsker å sammenligne det røye bruker likemenn lik til noen brev som y eller n, det gjør jeg, ja, må ha enkle anførselstegn. 

Nå, la oss gå videre og gjøre dette. La oss gå videre og gjør logiske dot slash logisk. Og nå er jeg blir bedt om det. Så, formodentlig, en bedre brukeropplevelse ville faktisk fortelle meg hva jeg skal gjøre her. Men jeg kommer til å bare blindt si y for ja, OK, hyggelig. 

La oss kjøre den igjen, n for nei, hyggelig. Anta at visse folk jeg kjenner, mine Caps Lock-tasten er på altfor ofte. Så jeg gjør hovedstaden Y, enter, feil. OK, det er ikke akkurat hva jeg forventet. Faktisk, datamaskinen gjør bokstavelig talt hva Jeg fortalte det til do-- se etter små bokstaver y og små bokstaver n. Dette føles ikke som god brukeropplevelse, skjønt. La meg spørre for og imot enten små bokstaver eller store bokstaver. Så det viser seg, kan det være lurt å si noe sånt i Scratch, som bokstavelig eller C er lik tilsvarer kapital enkelt sitert y. Slår ut, ikke C ikke har dette bokstavelig søkeord eller. 

Men det har to loddrette streker. Du må holde Shift vanligvis, hvis du bruker et amerikansk tastatur, og traff den vertikale linjen Nøkkelen over avkastningen nøkkelen. Men denne vertikale linjen vertikale linjen betyr eller. 

Hvis, derimot, ønsket vi å si, og som i Scratch, vi kunne gjøre ampersand-tegn. Det gir ingen logisk mening her, fordi et menneske ikke kunne muligens har skrevet både y og små bokstaver y og kapital Y som samme karakter. Så eller er det vi har tenkt her. 

Så hvis jeg gjør dette på begge steder, eller c tilsvarer tilsvarer kapital N, nå kjøre, gjør logisk, kjør logisk. Nå, jeg kan skrive y. Og jeg kan gjøre det igjen med kapital Y eller kapital N. Og jeg kunne legge inn ekstra kombinasjoner fortsatt. 

Så dette er en logisk Programmet i den utstrekning nå Jeg sjekker logisk for denne verdien eller denne verdien. Og jeg trenger ikke å nødvendigvis, komme opp med to ifs eller annet ifs. Jeg kan faktisk kombinere noen av relaterte logikk sammen på denne måten. Så dette ville være bedre utformet enn bare si, hvis C er lik små bokstaver y, skrive ut ja, annet hvis c er lik kapital Y, skrive ut ja, annet hvis c er lik lower-- med andre ord du trenger ikke å ha flere og flere grener. Du kan kombinere noen av de tilsvarende grener logisk, som på denne måten. 

Så la oss ta en titt på bare ett endelig ingrediens, en endelig konstruksjon, at C tillater. Og vi vil komme tilbake i fremtiden til andre fortsatt. Og så får vi konkludere ved å se ved ikke riktigheten av code-- å få kode til work-- men design kode, og plante disse frøene tidlig. 

Så la meg gå videre og åpne opp en ny fil her. Vet du hva? Jeg kommer til å re-implementere det samme programmet, men med en annen konstruksjon. 

Så la meg raskt gi meg selv tilgang til å omfatte CS50.h for CS50 bibliotek, standard Io.h for printf. Gi meg int main annullert. Og så over her, la meg gå videre og gjøre dette. 

Char c får få røye, akkurat som før. Og jeg kommer til å bruke en ny konstruksjon now-- slå, på hva karakter? Så bryter er typen som bytte et tog spor. Eller, egentlig, er det slags en om annet, hvis annet hvis, men skrevet noe annerledes. 

En bryter ser slik ut. Du har bryteren, og hva tegn eller nummer du ønsker å se på, så noen klammeparentes som i Scratch, bare si gjøre denne ting. Og da har du forskjellige tilfeller. 

Du trenger ikke bruke hvis og annet. Du bokstavelig talt bruke ordet saken. Og du ville si noe sånt som dette. 

Slik at i tilfelle av en liten bokstav y, eller i tilfelle av en kapital Y, gå videre og skrive ut ja. Og deretter bryte ut av bryteren. Det er det. Vi er ferdige. 

Annet hvis, så å si, små bokstaver n, eller kapital N, deretter gå videre og print ut nei, og deretter bryte. Else-- og denne type er Standard tilfelle indeed-- printf error-- og bare for godt mål, men logisk denne pausen er ikke nødvendig fordi vi er på slutten av bryteren uansett, Jeg er nå å bryte ut av bryteren. Så dette ser litt annerledes ut. 

Men, logisk, er det faktisk tilsvarende. Og hvorfor ville du bruke en over den andre? Noen ganger bare personlig preferanse, noen ganger estetikk, hvis jeg kikker på nå, det er noe å si for den lesbarheten av denne koden. Jeg mener, never mind det faktum at denne Koden er nytt for mange av oss i rommet. 

Men det bare slags er pen. Du ser små bokstaver y, kapital Y, små bokstaver n, kapital N standard det bare slags hopp ut på deg på en måte som, uten tvil, kanskje det foregående eksempelet med IFS, og de vertikale stolpene, og annet ifs, kanskje ikke. Så dette er egentlig et spørsmål om personlig valg, egentlig, eller lesbarhet, av koden. 

Men når det gjelder funksjonalitet, la meg gå videre og gjøre en bryter, dot slash bryteren, og nå skrive med små bokstaver y, kapital Y, små bokstaver n, kapital N, David, prøv på nytt fordi det er ikke et enkelt tegn. La oss gjøre x, feil, som forventet. Og logically-- og dette er noe Jeg vil oppfordre i general-- selv selv om vi bare skrape overflaten av noen av disse funksjonene. 

Og det kan ikke være opplagt når du selv sitte ned på tastaturet, hvordan virker dette? Hva ville dette gjøre? Den vakre ting om å ha en bærbar PC, eller skrivebordet, eller tilgang til en datamaskin med en kompilator, og med en kode editor som dette, er du nesten alltid svare på disse spørsmål til deg selv bare ved å prøve. 

For eksempel, hvis det retoriske Spørsmålet dreier var, hva skjer hvis du glemmer break uttalelser? Som faktisk er en veldig vanlig ting å gjøre, fordi det ikke ser som du virkelig trenger dem. De har egentlig ikke fullføre tenkte som en parentes eller en krøllete brace gjør. La oss gå videre og rekompilere koden og se. Så gjør bryteren, dot slash bryteren. La oss skrive med små bokstaver y, den øverste saken, Enter. Så jeg skrev y. 

Programmet sa ja, nei, feil, som om det var å endre sin mening. Men den slags var, fordi det som skjer med en bryter er den første som tilfellet kamp egentlig betyr, hei datamaskin, utføre alle av koden under den. Og hvis du ikke sier pause, eller ikke si pause, eller ikke si pause, maskinen kommer til å blåse gjennom alle disse linjene og utføre dem inntil det blir til at curly brace. Så bremsene er faktisk nødvendig. Men en takeaway her er, når i tvil, prøv noe. Kanskje spare koden først, eller lagre den i en ekstra fil hvis du er veldig bekymret rote opp og måtte gjenopprette det arbeidet som du vet fungerer. 

Men prøv ting. Og ikke være så redd for, kanskje, av hva maskinen kan gjøre, eller at du kan ødelegge noe. Du kan alltid gå tilbake til noen tidligere versjon. 

Så la oss slutte med å se ved utformingen av kode. Vi har denne muligheten nå til å skrive forhold, og skrive looper, og variabler, og samtalefunksjoner. Så, for å være ærlig, vi er litt tilbake på hvor vi var for en uke siden med Scratch, riktignok med en mindre overbevisende tekstlig miljø enn Scratch tillater. 

Men legg merke til hvor raskt vi har kjøpt som ordforråd, selv om det er kommer til å ta litt tid å synke inn, slik at vi nå kan bruke denne vokabular å skrive mer interessante programmer. Og la oss ta en baby skritt mot denne, som følger. La meg gå videre og opprette en ny fil her. 

Jeg kommer til å kalle dette prototype.c, og introdusere for første gang, evnen å lage dine egne funksjoner. Noen av dere har kanskje gjort dette med Scratch, der du kan lage dine egne blokker i Scratch, og deretter dra dem på plass uansett hvor du vil i C. Og i de fleste programmerings språk, kan du gjøre akkurat at-- lage dine egne funksjoner, hvis de ikke allerede eksisterer. 

Så, for eksempel, la meg gå videre og inkluderer CS50.h, og inkluderer standard IO.h, int main annullert. Og nå har vi en plassholder klar til å gå. Jeg holder utskrift ting som folks navn i dag. Og det føles like-- ville ikke være fint hvis det var en funksjon kalt print navn? Jeg trenger ikke å bruke printf. Jeg trenger ikke å huske alle format koder. Hvorfor ikke jeg, eller hvorfor gjorde ikke noen før meg, lage en funksjon kalt print navn, som fikk noen navn, bare skrives det ut? 

Med andre ord, hvis jeg sier hei, datamaskin, gi meg en streng ved å spørre brukeren for eksempel, via CS50 get streng funksjonen. Hei, datamaskin, sette strengen i variabelen i venstre side, og kaller det s. Og så, hei datamaskinen, gå videre og skrive personens navn, gjort. 

Nå ville det være fint, fordi dette programmet, treffende navn, forteller meg hva det er ment å gjøre ved hjelp av de funksjonsenes navn. La meg gå og gjøre prototype, Enter. Og, dessverre, dette ikke kommer til å fly. 

Prototype.c, linje 7, karakter 5, feil, implisitt erklæring av funksjon print navn er ugyldig i C99, C99 betyr en versjon av C- som kom ut i 1999. Det er alt. 

Så jeg vet ikke hva alt dette betyr enda. Men jeg erkjenner feil i rødt. Det er ganske opplagt. 

Og det virker som med den grønne karakter her, problemet er med print navn, åpen paren s, nær paren, semi-kolon. Men implisitt erklæring funksjon vi fikk se kort tidligere. Dette betyr ganske enkelt at klang vet ikke hva jeg mener. 

Jeg har brukt et vokabular ord at det er aldri sett eller blitt lært før. Og så jeg trenger å lære det hva denne funksjonen innebærer. Så jeg kommer til å gå videre og gjøre det. 

Jeg kommer til å gå videre og implementere min egen funksjon kalt ut navn. Og jeg kommer til å si, slik at den gjør dette, printf, hallo, prosent s, backslash n, navn, semikolon. Så hva gjorde jeg bare gjøre? 

Så det viser seg, til implementere din egen funksjon, vi slags låne noen av den samme struktur som hoved som vi har nettopp vært tatt for gitt, og jeg vet bare å kopiere og lime ganske mye hva Jeg har skrevet tidligere. Men legg merke til mønsteret her. Int, Main, Void, vi vil erte hverandre før lenge hva det egentlig betyr. 

Men for i dag, bare merke parallellitet. Void, print navn, string navn, så det er en lilla søkeord, som vi kommer til å starte ringer en returtype, navnet på funksjonen, og deretter input. Så, faktisk, kan vi destillere denne typen som i forrige uke som, er dette navnet eller algoritme av koden vi er kommer til å write-- den algoritme underliggende koden vi kommer til å skrive. 

Dette er sine innspill. Dette er dens utgang. Denne funksjonen, print navn, er utformet for å ta en streng kalt navn, eller hva, som input, og deretter annullert. Det går ikke tilbake noe, som får streng eller få int gjør. Så det kommer til å gi meg noe tilbake. Det er bare kommer til å ha en bivirkning, så å si, skrive ut en persons navn. Så legger merke til, linje 7, jeg kan kalle print navn. Linje 10, kan jeg definere eller implementere print navn. Men, dessverre, det er ikke nok. 

La meg gå videre og rekompilere dette etter lagring. Jøss, nå har jeg gjort det verre, vil det synes. Så implisitt erklæring funksjonsskrivernavnet er ugyldig. Og igjen, det er flere feil. Men som jeg advarte tidligere, selv Hvis du bli overveldet med, eller litt trist å se så mange feil, bare fokusere på den første utgangspunktet, fordi det kan bare har hatt en gjennomgripende effekt. Så C, eller klang mer spesifikt, fortsatt ikke gjenkjenner print navn. 

Og det er fordi klang, av design, er litt dum. Det gjør bare det du ber den om. Og det bare gjør det i den rekkefølgen der du ber den om. 

Så jeg har definert hoved på linje fire, som vi har gjort ganske ofte. Jeg har definert print navn på linje 10. Men jeg prøver å bruke print navn på linje sju. 

Det er for tidlig, ikke finnes ennå. Så jeg kan være flink, og være like, OK, så la oss bare spille sammen, og flytte print navn opp her, og re-kompilere. Herregud. Det funket. Det var så enkelt som det. 

Men logikken er akkurat det. Du må lære klang hva det er ved å definere funksjonen første. Deretter kan du bruke den. Men, ærlig, føles dette som en glatt skråning. 

Så hver gang jeg kjører inn i et problem, jeg er bare kommer til å markere og kopiere koden Jeg skrev, klippe det og lime det opp her. Og sikkert, vi kunne pønsker noen scenarier hvor en funksjon makt trenger å ringe en annen. Og du bare ikke kan sette alle funksjon over alle andre. 

Så det viser seg at det er en bedre løsning. Vi kan la dette være. Og ærlig talt, det er vanligvis fint, og praktisk, og god design for å sette hoved første, fordi, igjen, Hoved akkurat som når grønne flagget klikket, det er den funksjon at blir utført som standard. Så du kan like godt sette den på toppen av filen slik at når du eller noen annet menneske ser på filen du vet hva som skjer bare ved å lese hoved først. Så det viser seg, kan vi fortelle klang proaktivt, hei, klang, på linje fire, Jeg lover å implementere en funksjon som heter Print Navn som tar en streng kalt navn som input, og returnerer ingenting, tomrom. Og jeg vil komme til å implementere det senere. 

Her kommer Main. Hoved nå på linje 9 kan bruke Skriv navn fordi klang er å stole på at, til slutt, det vil støte definisjonen av gjennomføringen av Print navn. Så etter du har lagret filen min, la meg gå videre og gjøre prototype, ser bra denne gangen. Dot slash, prototype, la meg gå videre og skrive inn et navn. David, hallo David, Zamila, hallo Zamila, og, ja, nå fungerer det. 

Så ingrediensen her er at vi har gjort en egendefinert funksjon, som en egendefinert Scratch blokken vi kaller det. Men i motsetning til Scratch hvor du kan bare lage den og begynne å bruke den, nå må vi være en litt mer pedantisk, og faktisk trene klang å bruke, eller du kan forvente det. Nå, som en side, hvorfor hele denne tiden har vi vært bare blindt på tro inkludert CS50.h, og med standard IO.h? 

Vel, det viser seg, blant et par andre ting, alt som er i dem dot h filer, som tilfeldigvis er filer. De er header-filer, så å si. De er fortsatt skrevet i C. Men de er en annen type fil. 

For nå, kan du ganske mye anta at alt som er inne i CS50.h er noen one-liners som dette, ikke for funksjoner kalt ut navn, men for få String, Get Float, og noen få andre. Og det finnes lignende prototyper, en liners, innsiden av standard IO.h for printf, som nå er i min egen Print Navn funksjon. Så med andre ord, hele denne tiden har vi nettopp blitt blindt kopiere og lime inkludere dette, inkluderer det, hva skjer? De er bare slags hint til klang som til hvilke funksjoner er faktisk gjennomført, bare andre steder i forskjellige filer et annet sted i systemet. 

Så vi har implementert print navn. Den har denne bivirkning av skriver noe på skjermen. Men det gjør faktisk ikke gi meg noe tilbake. Hvordan går vi om benytter et program som ikke gi meg noe tilbake? 

Vel, la oss prøve dette. La meg gå videre og implementere en fil som heter return.c slik at vi kan vise hvordan noe liker Få String, eller få Int, er faktisk retur noe tilbake til brukeren. La oss gå videre og definere int main annullert. 

Og, igjen, i fremtiden, vil vi forklare hva som int og det tomrommet er faktisk gjør. Men for i dag, vil vi ta det for gitt. Jeg kommer til å gå videre og printf, for en god brukeropplevelse, er x. Og så kommer jeg til å vente på bruker å gi meg x med komme int. 

Og så kommer jeg til å gå videre og skrive ut x til torget. Så når du bare har en tastatur, folk vanligvis bruke litt gulrot symbol på tastaturet å representere til strøm av eller eksponent for. Så x squared er til stede i. 

Og nå kommer jeg til å gjøre dette. Jeg kunne bare do-- hva er x squared? x squared er x ganger x. 

Og vi gjorde dette noen tid siden allerede i dag. Dette føles ikke som så mye fremgang. Vet du hva? La oss utnytte noe av den tanken fra forrige gang av abstraksjon. 

Ville det ikke vært fint om det er en funksjon som heter firkantet som gjør akkurat det? Det fortsatt, ved slutten av dag, gjør det samme regnestykket. Men la oss abstrakte bort ideen om å ta ett tall multiplisert med en annen, og bare gi den et navn, lignende firkant denne verdien. 

Og, med andre ord, i C, la oss lage en funksjon heter plassen som gjør akkurat det. Det kommer til å bli kalt torget. Det kommer til å ta en int. Og vi vil vil bare kalle det n, som standard. 

Men vi kan kalle det noe vi ønsker. Og alt som det kommer til å gjør det, bokstavelig talt, er tilbake resultatet av n ganger n. Men fordi det er retur noe som er nøkkelordet i lilla vi har aldri sett før, jeg, på linje 11, kan ikke bare si tomrommet denne gangen. 

Void, i eksempelet nettopp så vi snarere print navn, betyr bare, gjør noe. Men ikke gi meg noe tilbake. I dette tilfellet vil jeg for å gå tilbake n ganger n, eller hva det er, det tallet. 

Så jeg kan ikke si hei, datamaskin, Jeg kommer tilbake ingenting, tomrom. Det kommer til å gå tilbake, av natur, en int. Og så det er alt som skjer her. 

Inngangen til torget kommer til å bli en int. Og slik at vi kan bruke det, har det å har et navn, N. Det kommer til utgang en int som ikke trenger et navn. Vi kan overlate til hoved, eller den som er hjelp meg å huske denne verdien hvis vi vil med sin egen variabel. 

Og, igjen, den eneste nye nøkkelordet her er Return. Og jeg bare gjør litt matematikk. Hvis jeg virkelig ønsket å være unødvendig, Jeg kan si int produktet kommer n ganger n. 

Og da kunne jeg si, returnere produktet. Men, igjen, til poenget mitt tidligere av dette bare ikke å være god design-- som, hvorfor innføre et navn, et symbol, som produkt, bare for å umiddelbart returnere den? Det er litt renere, litt strammere, så å snakke, bare for å si retur n ganger n, bli kvitt denne linjen helt. 

Og det er bare mindre kode å lese, mindre mulighet for feil. Og la oss se om dette faktisk nå fungerer. Nå kommer jeg til å gå videre og gjøre gjengjeld. 

Uh-oh, implisitt erklæring av funksjon. Jeg har gjort denne feilen før, ingen big deal. La meg bare skrive, eller markere og kopiere, nøyaktig samme funksjon prototype, eller signatur, av funksjonen her oppe. Eller jeg kunne flytte hele funksjonen. 

Men det er litt lat. Så vi vil ikke gjøre det. Nå, la meg gjøre retur igjen, dot slash retur. 

x er 2. x squared er 4. x er 3. x squared er ni. Og funksjonen virker nå ut til å virke. Så hva er forskjellen her? Jeg har en funksjon som heter kvadrat, i dette tilfellet, som jeg satt på en inngang. Og jeg kommer tilbake en utgang. Og likevel, som tidligere, hvis Jeg åpner den andre eksemplet fra tidligere, som var kalt prototype.c, Jeg hadde print navn, som returnert ugyldig, så å si, Eller den returnerte ingenting, og bare hadde en bivirkning. 

Så hva er det som skjer her? Vel, vurdere funksjonen få streng for bare et øyeblikk. Vi har brukt funksjonen få streng på følgende måte. 

Vi har hatt en funksjon får streng, som inkluderer CS50.h, inkluderer standard IO.h, int, main, annullert. Og så hver gang jeg har heter get streng så langt, Jeg har sagt noe sånt, string s får få streng, fordi get string-- la oss kalle dette get.c-- get streng selv returnerer en streng som jeg kan deretter bruke, og si hei, komma, prosent s, backslash n, s. 

Så dette er det samme eksempelet, virkelig, at vi hadde tidligere. Så får streng returnerer en verdi. Men en stund siden, print string returnerer ikke en verdi. Den har bare en bivirkning. Så dette er en fundamental forskjell. Vi har sett annerledes typer funksjoner nå, hvorav noen har returnert verdier, hvorav noen ikke. Så kanskje det er streng, eller int eller float. Eller kanskje det bare er ugyldig. 

Og forskjellen er at disse funksjonene få data og returnere en verdi er faktisk bringe noe tilbake til bordet, så å si. Så la oss gå videre og ser på en endelig sett eksempler som gir en følelse nå, av hvordan vi kan, faktisk, abstrakt bedre, og bedre og bedre eller mer, og mer og mer, for å skrive, til slutt, bedre kode. La oss gå videre, og i ånden av Scratch, gjør følgende. 

La meg gå videre og omfatte CS50.h og standard IO.h. La meg gå videre og gi meg selv en int, viktigste, annullert. Og la meg gå videre, kaller dette cough.c. 

Og la meg gå videre og bare som Scratch, skrive ut hoste / n. Og jeg ønsker å gjøre dette tre ganger. Så jeg, selvfølgelig, bare gå kopiere og lime inn tre ganger. Jeg er nå kommer til å gjøre hoste dot slash hoste. La oss gi meg selv litt mer plass her, Enter, hoste, hoste, hoste. 

Det er, selvsagt, allerede en mulighet for forbedring. Jeg har kopiert og limt et par ganger i dag. Men det var bare så jeg gjorde ikke må du skrive så mange tegn. Jeg fortsatt endret hva disse linjene med kode er. 

Disse tre linjene er identiske, som føles lat og faktisk er, og er sannsynligvis ikke den rette tilnærmingen. Så med det som ingrediens kan vi forbedre denne koden? Vi trenger ikke å kopiere og lime inn koden. 

Og, ja, helst du føler selv å kopiere og lime inn, og ikke selv endre koden, oddsen er det en bedre måte. Og, ja, det er. La meg gå videre og gjøre en for loop, selv om syntaksen kanskje ikke komme naturlig ennå. 

Gjør dette tre ganger, rett og slett ved å gjøre following-- og jeg tilfeldigvis vet dette fra praksis. Men vi har en rekke eksempler nå. Og du vil se online flere referanser fortsatt. 

Dette er syntaksen på linje 6, som mye som Scratch som gjentar blokk, gjenta følgende tre ganger. Det er litt magisk for nå. Men dette vil få mer, og mer kjent. 

Og det kommer til å gjenta linje åtte tre ganger, slik at hvis jeg re-kompilere make hoste, dot slash hoste, hoste, hoste, hoste. Det fungerer fortsatt på samme måte. Så det er alt fint og bra. Men det er ikke veldig abstrahert. 

Det er helt riktig. Men det føles som om det kan være en mulighet, som i verden Scratch, til slags start å legge til noen semantikk her, slik at Jeg har ikke bare ha litt for loop, og en funksjon som sier hoste, eller ikke hoste. Vet du hva? La meg prøve å være en litt kulere enn det, og faktisk skrive en funksjon som har noen bivirkninger, kaller det hoste. 

Og det tar ingen innspill, og returnerer ingen verdi som utgang. Men vet du hva det betyr? Det gjør dette-- printf, quote unquote, hoste. 

Og nå opp her, skal jeg å gå videre og for int, Jeg får null, jeg mindre enn tre, jeg pluss pluss. Jeg skal ikke gjøre printf, som er uten tvil en lav implementering nivå detalj. Jeg bryr meg ikke om hvordan å hoste. Jeg vil bare bruke hoste funksjonen. Og jeg skal bare ringe hoste. 

Nå merke motsetningen. Når du ringer en funksjon, hvis du ikke ønsker å gi det innganger, helt fint. Bare gjør åpne paren, nær paren, og du er ferdig. 

Når du definerer en funksjon, eller erklære en funksjon prototype, hvis du vet på forhånd er det ikke kommer til å ta noen argumenter, si tomrommet i disse parentes der. Og det gjør sikker på at du vil ikke tilfeldigvis misbruke den. La meg gå videre og gjøre hoste. Og, selvfølgelig, jeg har gjort en feil. 

Faen, det er det implisitt erklæring. Men det er fint. Det er lett å fikse. Jeg trenger bare prototypen høyere opp i filen min enn jeg faktisk bruker det. 

Så nå la meg gjøre hoste igjen, hyggelig. Nå fungerer det. Gjør hoste, hoste, hoste, hoste. Så du kanskje tror at vi er veldig drøyt ingeniør dette problemet. Og, ja, vi er. Dette er ikke en god kandidaten av et program i øyeblikket for ommøblerer, og gjøre det som er kalt hierarkisk nedbryting, hvor du tar noen kode, og deretter du slags faktor ting ut, så som å tillegge flere semantikk til dem, og bruke det til slutt lengre sikt. Men det er en byggestein mot mer avanserte programmer at vi vil starte skrive før lenge at tillater oss å ha vokabularet med å skrive bedre kode. Og, ja, la oss se om vi kan ikke generalisere dette nærmere. 

Det virker litt halt som jeg, viktigste, trenger å bekymre deg for dette darn for loop, og ringer hoste igjen og igjen. Hvorfor kan jeg ikke bare fortelle hoste, kan hoste tre ganger? Med andre ord, hvorfor kan jeg ikke bare gi innspill til hoste og gjøre dette? 

Hvorfor kan jeg ikke bare si, i Hoved hoste tre ganger. Og nå, dette er slags magisk. Det er veldig iterativ her. Og det er faktisk en baby trinn. 

Men bare muligheten til å si videre linje åtte, hoste tre ganger, det er bare så mye mer lesbar. Og pluss, jeg trenger ikke å vite eller bryr seg hvordan hoste er implementert. Og, ja, senere i sikt og for siste prosjekter, hvis du takle et prosjekt med en klassekamerat eller to klassekamerater, vil du innse at du kommer til å må, eller vil, dele arbeidet. 

Og du kommer til å ønske å bestemme på forhånd, som kommer til å gjøre det, og i hvilken stykker? Og ville det ikke vært fint Hvis du, for eksempel, ta ansvar for å skrive hoved, gjort. Og romkameraten din, eller din partner mer generelt, sørger for å implementere hoste. 

Og denne divisjonen, disse vegger av abstraksjon, eller lag av abstraksjon hvis du vil, er super kraftig, fordi spesielt for større mer komplekse programmer og systemer, det gjør at flere folk til å bygge ting sammen, og til slutt sy sitt arbeid sammen på denne måten. Men, selvfølgelig, vi må nå fikse hoste. Vi må fortelle hoste at, hei, vet du hva? Du kommer til å trenge å ta en input-- så ikke tomrom, men int og nå. La oss gå videre og sette inn hoste int. jeg får null. 

Jeg er mindre enn hvor mange ganger. Jeg sa tre før. Men det er ikke det jeg vil. Jeg ønsker hoste å generaliseres til støtter en rekke iterasjoner. 

Så, ja, det er n som jeg ønsker, hva brukeren forteller meg. Nå kan jeg gå videre og si print hoste. Og uansett hvilket nummer brukeren går inn, Jeg vil gjenta at mange ganger. 

Så på slutten av dagen, Programmet er identiske. Men legg merke til alt dette ting kan til og med være i en annen fil. Ja, jeg vet ikke på øyeblikk hvor printf er implementert. 

Jeg vet ikke i øyeblikket hvordan får streng, eller få int, eller få flyte blir gjennomført. Og jeg ønsker ikke å se dem på skjermen min. Som det er, jeg begynner å fokusere på mitt program, ikke disse funksjonene. 

Og så, ja, så snart du starte facto kode som dette ut, kunne vi til og med flytte hoste til en egen fil? Noen andre kunne gjennomføre det. Og du og din programmet bli veldig vakker, og svært lesbar, uten tvil, egentlig fire tråd program der. 

Så la oss gå videre nå og gjør en mer endring. Legg merke til at min prototype har til å endre opp toppen. Så la meg fikse det så Jeg får ikke skrek til. 

Gjør hoste, la meg kjøre hoste gang mer, fortsatt gjør det samme. Men nå ser vi har en ingrediens for en endelig versjon. Vet du hva? Jeg ønsker ikke å bare hoste, nødvendigvis. Jeg vil ha noe mer generelt. Så vet du hva? Jeg ønsker å gjøre dette. Jeg ønsker å ha, mye som Scratch gjør, å si blokk, men ikke bare si noe viss antall ganger. Jeg ønsker å si en veldig spesifikk streng. Og derfor gjør jeg ikke vil den skal bare si hoste. Jeg ønsker å si hva string er gått i. 

Så legger merke til, har jeg generalisert dette slik at nå si føles som et godt navn for dette, som Scratch, tar to argumenter, i motsetning til Scratch. Den ene er en streng. Den ene er en int. 

Og jeg kunne bytte dem. Jeg bare slags liker tanken på si strengen først, og deretter hvor mange ganger senere. Void betyr det likevel returnerer ikke noe. Dette er bare visuelle side effekter, som med [? Jordan,?] en verbal bivirkning av roping. Det gjør fortsatt noe n ganger, 0 opp til, men ikke lik n. Dette betyr n totaltid. Og så bare skrive ut hva som strengen er. Så jeg har egentlig generalisert denne linjen med kode. Så nå, hvordan bruker jeg hoste funksjon? 

Jeg kan gjøre ugyldig hoste. Og jeg kan fortsatt ta i hvordan mange ganger du ønsker å hoste. Men vet du hva? Jeg kan nå punt å si. 

Jeg kan ringe si med Ordet hoste, passerer i n. Og hvis jeg vil også implementere, bare for moro, et nys funksjon, Jeg kan nyse noen flere ganger. Og jeg kan holde gjenbruk n, fordi Legg merke til at m i denne sammenheng eller omfang bare eksisterer innenfor denne funksjonen. 

Og n i denne sammenheng bare eksisterer innenfor denne funksjonen her. Så vi vil komme tilbake til disse problemene i omfang. Og her, jeg bare kommer til å si, Achoo, og deretter n ganger, semikolon. 

Og nå, jeg trenger bare å låne disse fungerer signaturer opp her. Så hoste er riktig. Void nys er riktig nå. 

Og jeg trenger fortsatt bare si. Så jeg kommer til å si, si string s, int n, semikolon. Så jeg har over-konstruert på pokker ut av dette programmet. 

Og dette betyr ikke nødvendigvis at dette er hva du bør gjøre når du skriver selv de enkleste programmer. Ta noe som er åpenbart veldig enkelt, veldig kort, og re-implementere det bruker altfor mye kode. Men vil du faktisk se, og i gang se tilbake på disse eksemplene, og innser, oh, de er fremgangsmåten vi tok å faktisk generalisere, faktor noe ut, inntil på slutten av dagen koden min er faktisk ganske rimelig. Fordi hvis jeg ønsker å hoste tre ganger så nyse tre ganger, Jeg bare kommer til å kjøre dette, Programmet gjør hoste, og kjøre hoste. Og jeg har tre hoste og tre nyser. 

Og så dette er en grunnleggende paradigme, om du vil, for hvordan vi kan gå om faktisk implementering av et program. Men la oss bare se nå hva det er Vi har gjort alt dette tidspunktet, og hva noen av de siste bitene står bak denne enkle kommandoen. På slutten av dagen, har vi brukt klang som vår kompilatoren. Vi har skrevet kilde kode, omdanning av det via klang til maskinkode. 

Og vi har brukt Gjør bare å legge til rette for våre tastetrykk så at vi ikke trenger å huske disse besvergelser av klang selv. Men hva er Make faktisk gjør? Og, i sin tur, hvilken er Klang faktisk gjør? 

Det viser seg, selv om vi har forenklet dagens diskusjon ved å si: du tar kildekoden, går det som innspill til en kompilator, som gir deg produksjon av maskin kode, viser seg det er noen forskjellige skritt inne der. Og kompilering skjer for å være paraplyen betegnelse for en hel haug med trinn. Men la oss bare erte dette ut veldig raskt. 

Det viser seg at vi har gjort flere ting hver gang jeg kjører et program, eller hver gang jeg kompilere et program i dag. Så forbehandling refererer til dette-- noe i et C-program, som vi vil se igjen og igjen, som starter med denne hash symbol, eller hashtag symbol her, betyr det er en preprosessor direktivet. Det betyr at, i dette tilfellet, hei datamaskin, gjøre noe med denne filen før du faktisk lage min egen kode. 

I dette tilfellet omfatter nummerverdien er, hovedsak, C måte å si, hei datamaskin, går du få innholdet av CS50.h og lime dem her. Hei datamaskin, går du få Innholdet i standard IO.h, uansett hvor det er på harddisk, lim den inn her. Så disse tingene skje først under forbehandling. 

Og klang gjør alt dette for oss. Og det gjør det så darn rask, trenger du ikke engang se fire forskjellige ting som skjer. Men det er den første slike skritt. 

Hva skjer egentlig nå? Vel, den neste offisielle trinnet er kompilering. Og det viser seg at kompilere et program teknisk betyr å gå fra kildekode, ting vi har vært å skrive i dag, til noe kalt forsamlingen kode, noe som ser litt annerledes ut. 

Og, faktisk, kan vi se dette virkelig fort. La meg faktisk gå inn i min IDE. La meg gå videre og åpne hello.c, som er den aller første programmet som vi begynte i dag. Og la meg gå videre og kjøre klang en litt annerledes, klang-s, hello.c, som faktisk kommer til å gi meg en annen fil hello.s. 

Og vi vil sannsynligvis aldri igjen se denne typen kode. Hvis du tar et lavere nivå systemer klasse som CS61, du vil se mye mer av denne type kode. Men dette er assembly. Dette er X86 assembly at den CPU som er underliggende CS50 IDE faktisk forstår. 

Og kryptisk da det gjør se, det er noe datamaskinen forstår ganske godt. Sub q, er dette en subtrahere. Det er bevegelser. 

Det ringer av funksjoner her, x-øringen, en bevegelse, et tillegg, en pop, en retur. Så det er noen veldig lave instruksjoner nivå at CPUer forstår at Jeg antydet tidligere. Det er det Intel Inside. 

Det er mønstre av nuller og enere som kart til disse arcanely formulert, men noe godt navngitt, instruksjoner, så å si. Det er hva som skjer når du kompilere koden din. Du får montering språket ut av det, som betyr det tredje trinnet er å montere at forsamlingen kode inn, til slutt, maskin code-- nuller og enere, ikke tekst som vi nettopp så et øyeblikk siden. 

Så pre-prosessering gjør at finne og erstatte, og et par andre ting. Kompilering tar din kilde kode fra C, kildekode som vi skrev, til montering kode som vi bare kikket på. Montering hadde forsamlingen koden til nuller og enere at CPU virkelig vil forstå på slutten av dagen. Og linking er det siste trinnet det skjer for us-- igjen, så fort vi ikke selv notice-- som sier: hei datamaskin, ta alle nuller og enere som resulterte fra kompilering Davids kode, og hans viktigste funksjonen i dette tilfellet. 

Og hei datamaskin, går du få alle de nuller og enere at CS50 ansatte skrev inne i CS50 biblioteket. Bland de i med Davids. Og hei datamaskin, går du få alle nullene og de som noen andre skrev år siden for printf. Og legg dem inn i hele greia, slik at vi har fikk min nuller og enere, den CS50 ansattes nuller og enere, printf nuller og enere, og alt annet vi bruker. 

De blir kombinert sammen til ett Programmet heter, i dette tilfellet, hallo. Så fra nå av, vil vi bare bruke ordet kompilering. Og vi vil ta for gitt at når vi sier, kompilere programmet, det vil si, hei gjøre pre-prosessering, montering, og linking. Men det er faktisk noen saftig ting skjer der under panseret. Og spesielt hvis du få nysgjerrig litt tid, du kan begynne poking rundt på dette lavere nivå. Men for nå, skjønner at blant gatekjøkken for i dag er ganske enkelt begynnelsen av en prosess, for å få komfortable med noe som hello world. Ja, det meste av det vi gjorde i dag absolutt ikke vil synke i super rask. Og det vil ta litt tid, og litt øvelse. Og oddsen er, vil du sortere av ønsker å treffe tastaturet eller kjefte på skjermen. Og alt dette er OK. Skjønt, kanskje prøve å ikke gjøre det i biblioteket så mye. 

Og til slutt, vil du være i stand til selv å starte se mønstre, både i god kode at du har skrevet og i feil som du har gjort. Og mye som fremgangs bli en TF eller en CA er like, du begynner å bli bedre og flinkere til å se disse mønstrene, og bare løse din egne problemer slutt. I mellomtiden vil det være nok av oss å låne deg støtte, og få deg gjennom dette. Og i skrive-ups for alle problemene vil du bli guidet gjennom alle kommandoene at jeg sikkert vet fra mye trening nå, men kan ha flydd over hodet for nå. Og det er helt greit. 

Men, til slutt, du kommer å begynne å se mønstre dukker opp. Og når du kommer forbi alle dumme detaljer, som parenteser, og klammeparentes, og semikolon, og ting, ærlig, det er ikke i det hele tatt intellektuelt interessant. Og det er ikke målet for tar noen innledende klasse. Det er de ideer som kommer til å spille noen rolle. 

Det er looper, og forhold, og de funksjoner, og mer kraftfullt abstraksjon, og factoring av kode, og god design, og den gode stil, og til slutt riktig av koden din, det er slutt skal saken mest. Så neste uke, vil vi ta disse ideer som vi først så i Scratch og har nå oversatt til C. Og vi starter å introdusere den første av de kursets virkelige verden domener. 

Vi vil fokusere på verden av sikkerhet, og mer spesifikt kryptografi, kunsten scrambling informasjon. Og blant de første problemer du selv vil komme til å skrive ut spille med noen av syntaks og løse noen logisk problemer, slutt før lang, er å faktisk rykke ut, eller kryptere, og til slutt dekryptere informasjon. Og alt vi har gjort i dag, vil ganske lav nivå, er bare kommer til å tillate oss å ta en og en, og ett skritt over mot skriver de mest interessante koden ennå. 

Så mer om det i neste uke. 

[VIDEO PLAYBACK] 

-Hva Kan du fortelle meg om siste gang du så ham? -Hva Kan jeg si, egentlig? Jeg mener, det var som alle andre pre-produksjon øving, bortsett fra det var noe han sa helt på slutten som stakk med meg. 

-Dette Var CS50. 

-Det Er et kutt alle, god jobb på øving. 

-Det Er lunsj? 

-Ja, Du og jeg kan ta en sandwich i en bit. La meg bare debrief med David veldig raskt. David? David? 

[END PLAYBACK] 