[Musik spelar] DAVID J. MALAN: Okej, är detta CS50. Och detta är vecka ett. Så ihåg att sista gången i veckan noll, Vi fokuserade på beräkningstänkande. Och vi gått från det att Scratch, en grafisk programmering språk från våra vänner vid MIT Media Lab. 

Och med Scratch, vi utforska idéer som funktioner och villkor, och loopar, och variabler, och även händelser, och tråd och mycket mer. Och i dag, kommer vi att fortsätta att använda dessa idéer, och verkligen tar dem för beviljas, men översätta dem till ett annat språk som kallas C. Nu C är en mer traditionell språk. Det är en lägre nivå språk, om man så vill. 

Det är rent text. Och så vid första anblicken, är det alla kommer att se ganska kryptiska Om du har aldrig programmerat förut. Vi kommer att ha semikolon, och parenteser, och klamrar, och mycket mer. Men inse att även men syntaxen är på väg att titta lite obekant de flesta av er, se förbi det. Och försöka se idéerna som är verkligen bekant, för här i veckan ett vad Vi kommer att börja göra är att jämföra, initialt, Scratch kontra C. 

Så, till exempel, minns att när vi genomförde den första av våra program förra gången hade vi ett block som såg en liten sak som this-- när grön flagga klickade, och sedan hade vi en eller flera pusselbitar under det, i det här fallet, säger, hej världen. Så, ja, i Scratch, när jag klickar det gröna flaggan att köra mitt program, så att tala, dessa är block som får utförda, eller springa. Och särskilt Scratch sade, hallå, världen. 

Nu kunde jag har angett olika ord här. Men vi ser att, faktiskt, många av dessa blocks-- och faktiskt, i C många functions-- kan vara parametrized eller anpassad att göra olika saker. I själva verket, i C om vi vill konvertera, nu, detta Skrapa programmet till detta andra språk, vi kommer att skriva en lite ungefär så här. 

Visst, det finns en viss obekant syntax där mest troligt, int, och parenteser och ogiltiga. Men printf-- även om du skulle tror att det bara skulle vara tryck. Men utskriftsorgan print formaterade, som vi snart kommer att se. Detta bokstavligen ut till skärmen oavsett är inne i dessa parenteser, som naturligtvis i detta fall är, hallå världen. 

Men du kommer att märka några andra syntax, några citattecken, att parenteserna i slutet, semikolon och liknande. Så det finns lite overhead, så att säga, både kognitivt och syntaktiskt, att vi ska att komma ihåg innan lång. Men inser att med praktiken, Detta kommer att börja hoppa ut på dig. 

I själva verket, låt oss fokusera på att en Funktionen specifically-- i detta fall, säga hej världen. Så säger är funktionen. Hej världen är dess parameter, eller argument, dess anpassning. 

Och likvärdighet i C är bara kommer att vara så här en rad här, där printf är ekvivalent med att säga, dubbel citerade strängen, hej material är ekvivalent, naturligtvis, till vad som finns i den vita rutan där. Och omvänt snedstreck n, men lite konstigt och frånvarande från Scratch, helt enkelt kommer att ha effekt vi ska se i en dator, som min Mac eller PC, för att bara flytta markören till nästa rad. Det är som att slå Retur på tangentbordet. 

Så vi får se det igen snart. Men först, låt oss ta en titt på denna andra exempel i fallet med öglor. Vi hade det alltid slinga förra gången, som var en rad pusselbitar som gjorde något bokstavligen forever-- i detta fall, säga hej världen, hallå världen, hello world, hello world. Så det är en oändlig loop av design. 

I C, om vi vill genomföra detta samma idé, kan vi helt enkelt göra detta. Medan sant, printf hello world-- nu medan bara semantiskt, typ av väcker tanken på att göra något igen, och igen, och igen, och hur länge? Tja, true-- minns att sant är bara på eller en. 

Och sant är naturligtvis alltid sant. Så det är lite av en meningslös uttalande bara säga sant. Men i själva verket är detta avsiktligt, eftersom om sant är bara alltid sant, än medan sant bara antyder, om lite indirekt, att följande kodrader mellan dessa klammerparenteser ska bara köra igen, och igen, och igen, och aldrig sluta. 

Men om du vill att slinga för att sluta, som vi gjorde förra gången med något liknande detta, upprepa följande 50 gånger, i C kan vi göra samma sak med vad som är kallas en för loop-- sökordet inte vara tag, men för. Och sedan har vi några nya syntax här, med int i lika med 0, i mindre än 50, i ++. Och vi ska återkomma till det. Men detta är bara hur vi skulle översätta uppsättning Scratch block till en uppsättning av C rader kod. 

Samtidigt anser variabler. Och, faktiskt, vi bara såg en en stund sedan. Och i fallet med Scratch, om vi ville deklarera en variabel som heter i för i är heltal, bara ett nummer, och vi vill ställa in den till ett visst värde, vi skulle använda denna orange blockera här-- satt i till 0. 

Och vi kommer att se i dag och bortom, precis som förra veckan, programmerare gör nästan alltid börja räkna från noll, verkligen konventionellt. Men också på grund återkallande från vår diskussion av binär, det minsta antalet du kan representerar med vilken som helst antal bitar bara kommer att bli 0 själv. Och så kommer vi i allmänhet börjar initiera även våra variabler till 0. 

Och i C att göra detsamma, vi kommer att säga int för heltal, jag bara av konventionen. Jag kunde ha ringt denna variabel vad jag vill, precis som i Scratch. Och sedan lika 0 bara delar värdet 0 från höger och sätter det i variabeln, eller lagringsbehållare där, till vänster. Och semikolon som vi ska see-- och vi har sett några av dessa already-- betyder bara slutet av tanken. Fortsätt att göra något annat på de linjer som följer. 

Nu, hur booleska uttryck? Minns att i Scratch, dessa var uttryck som är antingen sant eller false-- frågor, verkligen, som är antingen sant eller falskt. Så i fallet med Scratch, vi kanske ställa en enkel fråga som denna, är jag mindre än 50? Så jag återigen är ett heltal. Kanske vi använder den i ett Scratch program att hålla reda på en poäng eller något sådant. Så här syntaxen här i Scratch betyder bara är jag mindre än 50? Jo, tack och lov, är något enkel i C. Och att översätta, detta skulle vi helt enkelt säga att jag mindre än 50, med det välbekanta nyckel på tangentbordet. 

Under tiden, om du ville säga något mer allmänt, som, ja, är x mindre än y där varje x och y är själva variabler? Vi kan göra samma sak i C, så länge som vi har skapat dessa variabler redan. Och vi får se hur man göra det inom kort. Vi skulle helt enkelt säga x mindre än y. 

Så du börjar se vissa likheter. Och dessa folks som gjorde Scratch var säkert inspirerad av några av dessa grundläggande idéer. Och du ser den här typen av syntax i många languages-- inte bara Scratch, inte bara C, men Python, och JavaScript, och andra språk fortfarande. 

Låt oss betrakta en annan konstruktion från C, begreppet tillstånd, göra något villkorligt. Om något är sant, gör detta. Om något annat är sant, gör det. Det är typ av program ekvivalent av en gaffel i vägen. Kanske är det en tvåvägs gaffel, ett tre-vägs gaffel, eller mer. Och i Scratch, kan vi ha sett något liknande. 

Så här är en stor en. Men anser den relativa enkelheten i logik. Om x är mindre än y, sedan säga x är mindre än y, annars om x är större än y, sedan säga x är större än y. Och sedan, logiskt, om du tänker tillbaka på Scratch eller bara din egen mänskliga intuition, väl, om x inte är större än y, och x inte är mindre än y, då naturligtvis x kommer att vara lika med y. Så i detta fall, genom att bygga bo dessa Skrap block, kan vi uppnå en tre sätt vägskäl? 

Under tiden, om vi vill göra det i C, det utan tvekan ser lite simpler-- åtminstone När du bekanta dig med syntax. Om x är mindre än y, printf x är mindre än y. Annars om x är större än y, printf x är större än y. Else printf x är lika med y-- och, igen, med de som omvänt snedstreck slutar strax för de nya linjer så att om du faktiskt sprang denna typ av program det skulle bara flytta markören i slutändan till nästa rad på skärmen. 

Nu hade tiden Scratch andra mer sofistikerade funktioner, endast något som vi ska initialt flytta över till en värld av C. Och en av dem var kallas en lista i Scratch. Och detta var en speciell typ av variabel som tillåtit att lagra flera saker i det tillbaka, att backa, backa, backa. 

I C, har den inte listor, i sig, men något som är mer allmänt kallade matriser, även om vi kommer komma tillbaka senare denna termin att titta på något kallas en lista, eller egentligen en länkad lista. Men nu, närmast motsvarande i C för oss kommer att bli något kallas en array. Och en mängd är helt enkelt en speciell typ av variabel som tillåter dig att lagra data tillbaka mot rygg, mot rygg, mot rygg. 

Och faktiskt, i Scratch, om vi ville komma åt det första elementet i en matris eller en list-- och jag kommer att kalla det, Av konvention argv, argument vektor, men mer om det inom kort. Om jag vill komma åt det första elementet av ArGV, i en värld av Scratch du faktiskt gör vanligtvis börja räkna från ett. 

Och så jag kan få punkt 1 i argv. Det är bara hur MIT förs begreppet listor. Men i C, jag kommer att mer helt enkelt bara säga, argv, som återigen är namnet på min list-- eller för att vara tydlig, en array. Och om jag vill först element, jag ska att använda hakparenteser, som du kanske inte ofta används under ett tangentbord. 

Men 0 betyder bara får mig först. Så ibland och som tiden går, vi kommer att börja se dessa dikotomier mellan Scratch och C, varvid Scratch använder ett. Vi i C använder 0 här. Men du kommer snabbt se när du förstår grunderna för varje språk, som dessa saker börjar bli allt mer bekant genom praktik och praktik. 

Så låt oss faktiskt tittar nu på ett program. Här skall vara den första av vår C källkoden för kompletta program. Och det program som vi ska att erbjuda för behandling är den som är ekvivalent som tidigare Scratch pjäs. 

Så här har vi vad som är utan tvekan den enklaste C-program du kan skriva att faktiskt gör något. Nu kommer vi att titta förbi, för nu har omfatta standard io.h, och dessa vinkel konsoler, och int och tom, och klammerparenteserna, och liknande. 

Och låt oss bara fokusera på vad, åtminstone intuitivt, kan hoppa ut på dig redan. I själva verket, huvudsakligt, det gör jag inte nödvändigtvis vet vad detta är, men likt Scratch hade att när grön flagga klickade pusselbit, så gör C såsom ett programmeringsspråk har en huvud bit kod som blir verk som standard. Och faktiskt, Det är bokstavligen kommer att kallas huvud. 

Så huvud är en funktion. Och det är en speciell funktion som finns i C att när du kör ett program, Det är huvud som blir drivs av standard. I en värld av Scratch, det var oftast när grön flagg klickade som fick köras som standard. 

Samtidigt har vi sett det här förut, printf eller skriva ut formaterad, det är kommer att vara en funktion som kommer med C, tillsammans med en massa andra, att vilja från gång igen, för att göra exakt som namnet antyder, skriva ut något. Vad vill vi skriva ut? Tja, vi får se att Genom att innesluta tecken som these-- hello world, snedstreck n inom citationstecken, Vi kan tala om printf exakt Vad som ska skrivas på skärmen. 

Men för att göra att vi tyvärr behöver ta något som är redan kryptiska för oss människor, men det är åtminstone något readable-- skarp inkluderar standard io.h, int Huvud, tomrum, printf alla magiska besvärjelsear såg vi bara på skärmen. Men vi har faktiskt gå mer svårbegripliga fortfarande. måste vi först översätta koden att vi skriver till maskinkod. Och minns från förra veckan att maskiner, åtminstone de som vi känner här, i slutet av dagen bara förstå nollor och ettor. 

Och min Gud, om vi var tvungna att skriva dessa nollor och ettor till faktiskt program, Det skulle mycket, mycket snabbt ta det roliga ur något. Men det visar sig, per förra veckan, att dessa mönster av nollor och ettor bara har speciell betydelse. I vissa sammanhang, de kan betyda siffror. 

I vissa sammanhang kan de innebära bokstäver eller färger, eller vilket som helst antal andra abstraktioner det på. Men precis som datorn har en CPU, Central Processing Unit, eller hjärnan inuti datorn. Det är oftast Intel inuti, eftersom det är ett av de största företagen som gör processorer för datorer. 

Tja, Intel-processorer och andra helt enkelt har beslutat i förväg att vissa mönster av nollor och som avses specifika saker. Vissa mönster av ettor och nollor kommer att innebära, skriva detta på skärmen, eller lägga till dessa två siffror, eller subtrahera dessa två siffror, eller flytta denna del av data från datorns minne hit, eller valfritt antal andra mycket låg nivå, men i slutändan bra, verksamheten. Men, tack och lov, vi människor inte kommer att behöva känna denna detaljnivå. I själva verket, precis som förra gången, där vi abstraherad igen, och igen, och igen, byggnad från mycket låg nivå primitiver som nollor och ettor begrepp högre nivå som siffror och bokstäver, färger och mer, så kan vi som programmerare stå på axlarna av andra som har kommit före oss och använda programvara som andra människor har skrivit innan oss-- nämligen program som kallas kompilatorer. 

C är ett språk som vanligen samman, vilket innebär omvandlas från källkod till maskinkod. Framför allt vad detta innebär är att om du har din källa kod som du själv skriver, som vi snart kommer i ett ögonblick på skärmen, och du vill konvertera det slutligen till maskinen code-- dessa nollor och ettor som bara din Mac eller PC understands-- du har en första foder som källkod i så insignal till en speciell program som kallas en kompilator, vars utgång vi skall se är maskinkod. Och faktiskt, sista gången vi pratade om, egentligen, i slutet av dagen, problemlösning. Du har ingångar. Och du har utgångar. Och du har fått någon form av algoritmen i mitten. 

Algoritmer kan säkert vara implementeras i programvara, som vi såg med pseudokod förra veckan och som vi ser med faktiska koden Denna vecka. Och så en kompilator egentligen bara har en uppsättning av algoritmer inuti av det som vet hur man omvandla de särskilda nyckelord, liknande huvud och printf, och andra som vi just såg in i mönster av nollor och Sådana som Intel Inside och andra processorer faktiskt förstår. Så hur gör vi det? Var får vi en kompilator? 

De flesta av oss här har en Mac eller en PC. Och du kör Mac OS, eller Windows eller Linux eller Solaris, eller valfritt antal andra operativsystem. Och faktiskt, vi kunde gå ut på banan och ladda ner en kompilator för din Mac eller PC för just ditt operativsystem. Men vi skulle alla vara på olika sidor, så att säga. Vi skulle ha något olika konfigurationer. Och det skulle inte fungera i alla fall. Och, faktiskt, i dessa dagar många av oss använder inte programvara som körs bara på våra bärbara datorer. Istället använder vi något som en webbläsare som tillåter oss att komma åt webbaserade applikationer i molnet. Och senare den här terminen, vi kommer att göra just detta. Vi kommer att skriva program eller programvara med code-- inte C, men andra språk som Python och JavaScript-- som körs i molnet. 

Och att göra det vi själva under terminen faktiskt kommer att använda en molnbaserad miljö kallas CS50 IDE. Detta är en webb-baserad programmering miljö, eller integrerad utveckling miljö, IDE, som är byggd ovanpå några öppen källkod kallas Cloud 9. Och vi har gjort några pedagogiska förenklingar till det så att dölja vissa funktioner i de första veckorna som vi inte behöver, varefter du kan avslöjar dem och göra de flesta vad du vill med miljön. 

Och det gör oss också till förinstallera vissa program. Saker som en så kallad CS50 bibliotek, som vi snart kommer att se ger oss i C med vissa ytterligare funktioner. Så om du går till, i slutändan, CS50.io, du blir ombedd att logga in, och när du gör och skapa ett konto gratis, du kommer att kunna få tillgång till en miljö som ser ganska så här. 

Nu är det i standardläget. Allt är trevligt och ljusa på skärmen. Många av oss har en vana att arbetar på CS50 pjäs som är ganska sent in på natten. Och så några av er kanske föredrar att förvandla det till nattläge, så att säga. 

Men i slutändan, vad du är kommer att se inom CS50 IDE är tre distinkta areas-- ett område på vänster där dina filer kommer att vara i moln, ett område på upp till höger där koden kommer att vara redigerbara. Du kommer att kunna öppna enskilda flikar för alla program att du skriver den här terminen inne av det övre högra hörnet. Och sedan mest arcanely, och ändå kraftfullt, kommer att bli den här saken på botten kallas ett terminalfönster. 

Detta är en gammal skola Command Line Interface, eller CLI tillåter att du att utföra kommandon på computer-- i detta fall, datorn i cloud-- att göra saker som kompilera koden från källkod till maskinkod, att köra dina program, eller att starta webbserver, eller att få tillgång till databasen, och ett antal andra tekniker att vi kommer att börja använda kort. Men för att komma dit, vi är kommer att faktiskt ha att gå online och börja spela. Och att göra det, låt oss först börja mixtra med huvud, och skriva den huvudsakliga delen av ett program. Och låt oss använda denna funktion printf, som vi använde tidigare, helt enkelt att säga något. 

Så här är jag redan inne i CS50 IDE. Jag har loggat in förväg. Och jag fullt skärmad fönstret. Och så slutligen, du även i kommande problem kommer att följa liknande steg som kommer att ge online-dokumentation. Så du behöver inte oroa sig för absorbera varje liten teknisk steg att jag gör här i dag. 

Men du får en skärm som denna. Jag råkar vara i nattläge. Och du kan lysa allt upp genom att inaktivera nattläge. Och vid slutet av dag, du kommer att se dessa tre huvud areas-- filen webbläsare till vänster, koden flikar uppe, och terminalfönstret längst ned. 

Låt mig gå vidare och skriva min första program. Jag ska preemptively gå till Arkiv, Spara och spara min fil som hej.c. I själva verket, enligt praxis, ett program vi skriver som är skrivet i C-språket ska heta något dot c, enligt konvention. Så jag kommer att nämna det hej.c, eftersom Jag vill bara säga hej till världen. Nu kommer jag att zooma ut och klicka på Spara. Och allt jag har här nu är en flik där kan jag börja skriva kod. 

Detta kommer inte att kompilera. Detta betyder ingenting. Och så även om jag konverterade detta till nollor och ettor, CPU: n kommer att ha någon aning om vad som händer runt. Men om jag skriver rader som matchar med C: s conventions-- C varelse, igen, language-- detta med syntax som detta printf hej world-- och jag har blivit bekväm med att göra detta över tiden. Så jag tror inte att jag gjort eventuella tryckfel. 

Men alltid, den allra första gång du gör det, kommer du. Och vad jag ska göra kan mycket väl inte fungerar för dig första gången. Och det är helt OK, eftersom just nu du kan bara se en hel del av nyheten, men med tiden när du bekanta med denna miljö, och detta språk, och andra, du kommer att börja se saker som är antingen rätt eller fel. 

Och detta är vad undervisningsassistenter och kurs assistenter får så bra på tiden, är observation misstag eller fel i koden. Men jag hävdar att det finns inga fel i denna kod. Så jag vill nu att köra det här programmet. 

Nu på min egen Mac eller PC, jag är i för vana att dubbelklicka på ikonerna när jag vill köra något program. Men det är inte modellen här. I denna miljö, som är CS50 IDE. Vi använder ett operativsystem system som kallas Linux. Linux är påminner om en annan operativsystem, är allmänt känd som Unix. Och Linux är särskilt känd för med en kommandorad miljö, CLI. Nu, vi använder en specifik smak av Linux kallas Ubuntu. Och Ubuntu är helt enkelt en viss version av Linux. 

Men dessa Linux dessa dagar gör faktiskt komma med grafiska användargränssnitt. Och vi råkar att använda här är webbaserat. Så det kan se ännu en lite annorlunda från något du kanske själv har sett eller köra i det förflutna. 

Så jag kommer att gå vidare nu och gör följande. Jag har sparat den här filen som hej.c. Jag kommer att gå vidare och Typ clanghello.c Så Clang för C-språket är en kompilator. Det är förinstallerad i CS50 IDE. Och du kan helt ladda ner och installera på din egen Mac eller PC. 

Men, återigen, du skulle inte ha alla förkonfigurationen gjort för dig. Så nu är jag bara kommer att köra clanghello.c. Och nu märker denna syntax här kommer så småningom inse betyder bara att jag är i en mapp eller katalog som heter arbetsyta. Denna dollartecken är bara konvention efter mening, skriver dina kommandon här. 

Det är vad som kallas en snabb, precis enligt praxis är dollartecken. Och om jag går vidare nu och klicka Ange, inget verkar ha hänt. Men det är faktiskt en bra sak. Ju mindre som händer på skärmen, desto mer sannolikt koden är att vara korrekt, åtminstone syntaktiskt. 

Så om jag vill köra program, vad ska jag göra? Tja, visar det sig att den standardnamn genom konventionen för program när du inte anger en namn på programmet är bara a.out. Och denna syntax också, du bekanta med kort. 

Dot slash betyder bara, hej, CS50 IDE, köra ett program som heter a.out det är i min nuvarande katalog. Det prick betyder den aktuella katalogen. Och vi får se vad andra sådana sekvenser tecken betyder kort. 

Så här går vi, Enter, hallå världen. Och du kommer att märka, att det som hände? Inte bara gjorde det ut Hello World. Den rörde sig också markören till nästa rad. 

Och varför var det? Vad var den kod som vi skrev innan att se till att markören skulle gå på nästa rad? Lustiga en dator är det bara att gå att göra bokstavligen vad du berätta det att göra. 

Så om du berättar det att printf hej, kommatecken, utrymme, värld, nära citat, det är bokstavligen bara gå att skriva dessa tecken. Men jag hade denna speciella karaktär i slutet, minns, bakstreck n. Och det är vad säker att karaktären gick till nästa rad på skärmen. 

I själva verket, låt mig gå och göra det. Låt mig gå vidare och radera detta. Nu märker att högst upp på skärmen finns lite rött ljus i fliken anger, Hej, har du inte sparat filen. Så jag kommer att gå vidare med kontroll S eller kommandot S, spara filen. Nu goes-- gick för en moment-- grön. Och nu är det tillbaka till bara vara en nära ikon. 

Om jag kör nu clanghello.c igen, Ange, pricka snedstreck, a.out, Enter, ser du att det fortfarande fungerade. Men det är utan tvekan en liten buggy. Just nu, mitt prompt-- arbetsyta, och då dollartecken, och sedan min faktiska prompt-- är alla på samma linje. Så detta verkligen en estetisk bugg, även om det är egentligen inte en logisk bugg. 

Så jag kommer att ångra vad jag gjorde bara. Jag kommer att köra a.out. Märker jag har lagt till radmatningstecken tillbaka. Jag har sparat filen. 

Så jag kommer att köra a.out, och-- dammit, en bugg, ett fel som betyder misstag. Så felet är att även om Jag har lagt det omvända snedstrecket n där, re sparade, åter körde programmet, beteendet var densamma. Varför skulle det vara? 

Jag saknar ett steg, eller hur? Det avgörande steg tidigare var att du har att-- när du ändrar källkoden, det visar sig också att köra det genom kompilatorn igen så att du får ny maskinkod. Och maskinkoden, nollor och ettor, kommer att vara nästan identiska, men inte perfekt så, eftersom vi behöver, naturligtvis, att ny rad. 

Så för att åtgärda detta, jag kommer att behöva att köra clanghello.c anger, dot snedstreck, a.out. Och nu, hallå världen är tillbaka där jag förväntar mig att vara. Så det här är alla fina och bra. Men a.out är en ganska dum namn för en programmet, även om det råkar vara, av historiska skäl default-- menande monterings utgångar. 

Men låt mig gå vidare här och gör detta på olika sätt. Jag vill ha min Hello World faktiskt kallas hej. Så om det vore en ikon på min skrivbord, skulle det inte vara a.out. Det skulle kallas hej. 

Så för att göra detta, visar det sig att Clang, liksom många program, stöder kommandoradsargument, eller flaggor, eller växlar, som helt enkelt påverka dess beteende. Specifikt Clang stöder ett streck o flagga, som sedan tar ett andra ord. I det här fallet, jag ska godtyckligt, men rimligen, kalla det hej. Men jag kan kalla det något Jag vill, utom a.out, som skulle vara ganska förutom punkten. 

Och sedan bara ange namnet på filen jag vill kompilera. Så nu även i början av kommandot jag har fortfarande klang, i slutet av kommandot Jag har fortfarande filnamnet, Jag har nu dessa kommandoraden argument, dessa flaggor som säger, Åh, förresten, output-o, en fil heter hej, inte standard a.out. 

Så om jag slog in nu, ingenting verkar ha hänt. Och ändå, nu kan jag göra punkt snedstreck hej. Så det är samma program. De nollor och ettor är identiska vid slutet av dagen. 

Men de är i två annorlunda files-- a.out, som är den första versionen och bara dåraktigt namnges, och nu hej, vilket är en mycket mer övertygande namn för ett program. Men, ärligt talat, jag är aldrig kommer att minnas detta igen, och igen, och igen. Och, faktiskt, som vi skriver mer komplicerade program, kommandon du är kommer att behöva skriva kommer att bli ännu mer komplicerat fortfarande. 

Och så att inte oroa dig. Det visar sig att människor innan vi har insett att de också hade denna exakt samma problem. Även de inte tyckte att behöva skriver ganska långa, svårbegripliga kommandon, tala minns dem. Och så människor före oss har gjort andra program som gör det lättare att kompilera programmet. 

Och, ja, en sådan Programmet kallas Make. Så jag kommer att gå vidare och göra det. Jag kommer att ångra allt jag bara gjorde på följande sätt. Låt mig typ LS. Och du kommer att märka tre saker-- a.out och en stjärna, hej och en stjärna, och hej.c. Förhoppningsvis ska detta vara lite intuitivt, i den mån som tidigare fanns ingenting i denna arbetsyta. Det fanns ingenting som jag hade skapas förrän vi började klass. 

Och jag skapade hej.c. Jag sammanställt sedan, och kallade det a.out. Och då jag sammanställt det igen något annorlunda och kallade det hej. Så jag har tre filer i den här katalogen, i denna mapp som heter arbetsyta. Nu kan jag se att såväl om jag zoomar ut faktiskt. 

Om jag zoomar ut här och titta på den övre högra hörn, som utlovat vänster sidan av skärmen alltid kommer att visa dig vad som finns i ditt konto, vad är insidan av CS50 IDE. Och det finns tre filer där. 

Så jag vill bli av med a.out och hej. Och som ni kanske föreställa sig intuitivt, du kan sortera kontroll klick eller högerklicka på denna. Och denna lilla meny dyker upp. Du kan ladda ner filen, kör det, förhandsgranska det, uppdatera, byta namn, eller vad inte. 

Och jag kan bara ta bort, och det skulle försvinna. Men låt oss göra saker med ett kommando linje för nu, så att få bekväm med detta, och gör följande. Jag kommer att gå vidare och ta bort a.out genom att skriva bokstavligen rma.out. Det visar sig, kommandot för ta bort eller radera något, är inte bort eller radera. 

Det är mer kortfattat RM, bara för att spara dig några tangenttryckningar, och tryck på Retur. Nu ska vi vara något kryptiskt avlägsna vanlig fil a.out. Jag vet inte riktigt vad en oregelbunden fil skulle vara ännu. Men jag vill ta bort det. 

Så jag kommer att skriva y för ja. Eller jag kunde skriva ut, och tryck på Retur. Och återigen, ingenting verkar hända. Men det är i allmänhet en bra sak. 

Om jag skriver LS här gången, vad ska jag se? Förhoppningsvis bara hej och hej.c. Nu, som en sidoreplik, du märka detta stjärna, asterisk, det är i slutet av mina program. Och de visar också upp i grönt. Det är bara CS50 IDE sätt av cluing dig till det faktum att det inte är källkoden. Det är en körbar, ett körbart program som du faktiskt kan köra genom att göra punkt snedstreck, och då är det namn. 

Låt mig nu gå vidare och ta bort detta rm hello, Enter, ta bort regelbundna fil hej, ja. Och nu om jag skriver LS, Vi är tillbaka till hej.c. Försök att inte ta bort din källkod. Även om det finns funktioner inbyggd i CS50 IDE där Du kan gå igenom din versionshistoriken och bakåt i tiden om du av misstag ta bort något, gör vara uppmärksam enligt dessa uppmaningar ja eller nej, av vad du verkligen vill göra. Och om jag går upp till toppen vänstra hörnet här, allt som återstår är hej.c. Så det finns knippen av andra kommandon som du kan utföra i en värld av Linux, varav en är, återigen, Gör. Och vi kommer att göra mitt program nu på följande sätt. 

Istället för att göra klang, istället för att göra klang-o, Jag ska helt enkelt bokstavligen skriver gör hej. Och nu märker jag inte skriva göra hej.c. Jag skriver att hej. 

Och detta program Gör att levereras med CS50 IDE, och mer i allmänhet med Linux, är ett program som är kommer att göra ett program som heter Hej. Och det kommer att ta, enligt konvention, att om kan göras detta program, det kommer att göras från en källa kod fil som slutar i dot c, hej.c. 

Så om jag slog in nu, märker att kommandot som blir verk är faktiskt ännu längre innan än tidigare. Och det beror på att vi har förkonfigurerad CS50 IDE att ha några extra funktioner inbyggda i det vi behöver inte ännu, men snart kommer. Men det viktigaste att inse är nu jag har en Hello program. 

Om jag skriver LS igen, jag har ett hej program. Och jag kan köra den med dot slash a.out, nej, eftersom hela poängen med detta övningen var dot slash hej. Och nu har jag min Hello World. Så framåt, Vi är nästan alltid bara kommer att sammanställa våra program med kommandot Make. Och sedan ska vi köra dem genom dot snedstreck, och programmets namn. Men inse vad som gör gör för du, är det i sig är inte en kompilator. Det är bara en bekvämlighet program som vet hur man utlösa en kompilator att köra så att du själv kan använda den. 

Vilka andra kommandon finns i Linux, och i sin tur CS50 IDE? Vi kommer snart att se att det finns en CD kommandot Ändra Directory. Detta gör att du inom din kommandoradsgränssnitt att gå framåt, och tillbaka, och öppna upp olika mappar utan att använda musen. 

LS vi såg, som står för listan filerna i den aktuella katalogen. Gör Dir, kan du nog börja att sluta vad dessa betyder now-- göra katalog, Om du vill skapa en mapp. RM för bort, RM Dir för avlägsna directory-- och dessa, igen, är kommandoraden ekvivalenter av vad du skulle kunna göra i CS50 IDE med musen. Men du kommer snart att finna som ibland är det bara en mycket snabbare att göra saker med ett tangentbord, och i slutändan en mycket mer kraftfull. 

Men det är svårt att hävda att allt vi har gjort hittills är allt som kraftfull, när alla vi har sagt är, hallå världen. Och, faktiskt, hårdkodad jag den ord hej världen i mitt program. Det finns ingen dynamik ännu. Scratch var en storleksordning mer intressant förra veckan. 

Och så låt oss komma dit. Låt oss ta ett steg mot att genom sätt att en del av dessa funktioner. Så inte bara C kommer med printf, och klasar av andra funktioner varav en del kan vi se över tiden, det gör det inte göra det så lätt rätt ut av grinden i att få användarinmatning. 

I själva verket en av svagheterna av språk som C, och även Java och ändå andra, är att den inte gör det lätt att bara få saker som heltal från användare, eller strängar, ord, och fraser, för att inte tala saker som flyttalsvärden, eller reella tal med decimaler, och verkligen långa tal, som vi snart kommer att se. Så denna lista över funktioner här, dessa är som andra Scratch pusselbitar att vi har förinstallerade i CS50 IDE som vi kommer att använda för ett par veckor som stödhjul av olika slag, och så småningom ta bort dem, och se under huven, kanske, vid hur dessa saker genomförs. 

Men för att göra detta, låt oss faktiskt skriva ett program. Låt mig gå vidare nu. Och jag kommer att skapa en ny fil genom att klicka på denna lilla plus, och klicka på Ny fil. 

Jag kommer att spara nästa en som, låt oss säga, string.c, eftersom jag vill spela med strängar. Och sträng i C är bara en sekvens av tecken. Så låt oss nu gå vidare och gör följande. 

Inkludera standard IO.h-- och det visar sig standard IO, IO är bara ingång och utgång. Så visar det sig att denna linje här är vad är grann oss att använda printf. Printf naturligtvis producerar utgång. Så för att använda printf, visar det ut måste du ha den här kodraden högst upp på filen. 

Och vi ska återkomma till vad som verkligen betyder inom kort. Det visar sig att i någon C-program jag skriver, I got att starta den med kod som ser ut så här. Och du kommer att märka CS50 IDE, och andra integrerad utveckling miljöer som det, kommer att försöka så gott de kan för att avsluta din tanke. I själva verket, en stund sedan om jag ångra vad jag gjorde, jag trycker på Retur. 

Jag sedan slog öppna lockigt stag, tryck på Retur igen. Och det slutade min tanke. Det gav mig en ny linje, indragen inte mindre för fina stilistiska skäl som vi får se. Och sedan gav mig automatiskt att klammerparentes att avsluta min tanke. Nu gör det inte alltid gissa vad du vill göra. Men till stor del, gör det spara några knapptryckningar. Så för en stund sedan, körde vi här program-- hej, värld, och sedan sammanställt det, och sedan körde den. Men det finns ingen dynamik här. Vad händer om vi ville göra något annat? Tja, vad händer om jag ville faktiskt få en sträng från användaren? Jag kommer att använda en pusselbit kallas exakt that-- få sträng. 

Det visade sig i C att när du inte vill att bidra till en pusselbit, eller mer korrekt till en funktion, du bokstavligen bara göra öppna parentes, nära parentes. Så det är som om det finns ingen vit ruta för att skriva in. Den säga blocket före hade en liten vit ruta. Vi har inte den vita rutan nu. 

Men när jag ringer få sträng, jag vill sätta resultatet någonstans. Så ett mycket vanligt paradigm i C är att anropa en funktion, som få sträng här, och sedan lagra dess returvärde. Det är resultatet av sin ansträngning i något. 

Och vad är det konstruera i programmering, vare sig början eller nu C, att vi kan använda för att faktiskt lagra något? Kallade det en variabel, eller hur? Och i Scratch, gör vi inte riktigt bry sig om vad som pågick i variabler. 

Men i det här fallet, vi faktiskt gör. Jag kommer att säga sträng. Och då kunde jag ringa detta vad jag vill. Jag kommer att kalla det namn, blir få sträng. 

Och nu även om du är lite ny på detta, märker att jag saknar någon detalj. Jag glömmer ett semikolon. Jag måste avsluta denna tanke. Så jag kommer att flytta min markör, och slog semikolon där. Och vad har jag just gjort? I den här kodraden, nummer fem just nu, Jag ringer få sträng utan ingångar. Så det finns ingen liten vit rutan som Spara blocket har. 

Jag säger bara, hej, dator, ge mig en sträng. Likhetstecknet är inte riktigt ett likhetstecken, per se. Det är uppdraget operatör, vilket innebär, hej, dator, flytta värdet från höger åt vänster. Och i den vänstra, jag har följande. 

Hej, dator, ge mig en string-- en sekvens av tecken. Och kalla det strängnamn. Och jag behöver inte ens kalla det namn. 

Jag skulle kunna kalla det konventionellt, något i stil med S, mycket som vi brukade jag call variabeln i. Men nu måste jag göra något med det. Det skulle vara ganska dumt att försöka sammanställa denna kod körs detta program, även om Jag får en sträng, eftersom det är fortfarande bara kommer att säga hej världen. 

Men vad händer om jag vill ändra på detta. Varför gör jag inte det? Procent s, kommatecken s. Och detta är en liten kryptisk stilla. 

Så låt mig göra mina variabler tydligare. Låt mig nämna detta variabelnamn. Och låt oss se om vi inte kan reta förutom vad som händer här. 

Så på linje fem, jag får en sträng. Och jag lagra strängen, vad användaren har skrivit i på hans eller hennes tangentbord, i en variabel som heter namn. Och det visar sig att printf inte bara ta ett argument i dubbel citationstecken, en ingång i citattecken. 

Det kan ta två eller tre, eller mer, till exempel att den andra, eller tredje, eller fjärde, är alla namn på variabler, eller specifikt värden, som du vill ansluta till, dynamiskt, att sträng inom citationstecken. Med andra ord, vad skulle vara fel med detta? Om jag sa bara hej namn, bakstreck n, räddade min fil, sammanställt min kod, och sprang detta, vad skulle hända? 

Det är bara att säga, hej namnge, bokstavligen N-A-M-E, som är typ av dum eftersom det är inte skiljer sig från världen. Så allt inom citationstecken är vad bokstavligen blir tryckt. Så om jag vill ha en platshållare där, Jag behöver faktiskt använda några speciella syntax. Och det visar sig om man läser dokumentation för printf funktion, Det kommer att säga att om du använder procent s, du kan ersätta ett värde enligt följande. 

Efter ett kommatecken efter det dubbla citattecken, du helt enkelt skriva namnet på variabel som du vill att ansluta till det formatet kod, eller format specifice, procent är för stråkar. Och nu om jag har sparat min fil, Jag går tillbaka till min terminal. Och jag skriver Gör String, eftersom, återigen, namnet på denna fil som jag valde tidigare är string.c. 

Så jag kommer att säga Gör String anger. Åh herregud, titta på alla de misstag vi har gjort redan. Och detta är-- vad detta är verkligen som en sex, sju linje program? Så det är där det kan mycket snabbt få överväldigande. 

Denna terminalfönster har nu bara regurgitated ett stort antal felmeddelanden. Visst, jag har inte mer fel meddelanden än jag har rader kod. Så vad är det som händer? 

Tja, den bästa strategin att göra när du inte stöter på ett överväldigande lista över fel som detta, är rulla tillbaka, leta efter kommandot du bara sprang, som i mitt fall är att göra sträng. Titta på vad gör gjorde, och det är att lång klang kommando, no big deal där. 

Men den röda är dåligt. Grön försöker vara mild och hjälpsam. Men det är fortfarande dåligt, i det här fallet. Men där är det dåligt? 

String.c, linje fem, tecken fem. Så det här är bara sunt konvention. Något kolon något betyder radnummer och teckennummer. Fel användning av odeklarerat identifierarsträng. Menade du standard? 

Så tyvärr Clang försöker vara till hjälp. Men det är fel, i det här fallet. Nej, Clang, jag menade inte standard IO. Jag menade att på linje ett, ja. 

Men linjen fem är detta en här. Och Clang inte förstå S-T-R-I-N-G. Det är en svart identifierare, en Ordet det bara aldrig har sett förut. Och det beror på C språk vi skriver kod i just nu, inte har variabler som kallas strängar. 

Det gör inte som standard, stöd något som kallas en sträng. Det är en CS50 bit jargong, men mycket vanlig. Men jag kan fixa detta på följande sätt. 

Om jag lägger en kodrad till toppen av detta program, inkluderar CS50.h, som är en annan fil någonstans inne i CS50 IDE, någonstans på hårddisken, så att säga, av operativsystemet Ubuntu att jag kör, att är den fil som är ska lära drifts systemet vad en sträng är bara som standard io.h är filen i operativsystemet som är kommer att lära den vad printf är. 

I själva verket skulle vi ha fått en mycket liknande meddelande om IO hade erkänt standard Io.h och försökte använda printf. Så jag kommer att gå vidare och bara ta kontroll L att rensa skärmen. Eller du kan skriva klart och det kommer bara rensa terminalfönstret. Men du kan fortfarande bläddra tillbaka i tiden. 

Och jag kommer att köra Gör String. Tummarna den här gången, Enter. Herregud, det fungerade. Det visar mig en lång kryptisk kommando det är vad som gör genereras via klang, men inga felmeddelanden. Så inser, trots att du kan få helt överväldigad med antal felmeddelanden, det bara kan vara så här irriterande cascading effekt, där klang inte förstår en sak, vilket betyder att det därefter förstår inte nästa ord, eller på nästa rad. Och så bara drosslar på din kod. Men fix kan vara enkelt. Och så alltid fokusera på allra första raden av produktionen. Och om du inte förstår det, titta bara för sökord som kan vara ledtrådar, och linjenummer, och karaktär, där det misstaget kan vara. 

Låt mig nu gå vidare och skriva dot slash, sträng, anger. Hm, det är inte att säga hej någonting. Varför? Tja, minns, var det igång? 

Det är antagligen fastnat för tillfället i en slinga, om man så vill, på rad sex, eftersom Få String av design, skriven av CS50 personal, bokstavligen tänkt att bara sitta det väntar och väntar, och väntar på en sträng. Allt vi menar med sträng är mänskligt ingång. Så du vet vad? Låt mig gå vidare. Och bara på ett infall, låt mig skriver mitt namn, David, anger. Nu har jag ett mer dynamiskt program. Det sade hej David. 

Om jag går vidare och köra igen, Låt mig försöka säga Zamila namn anger. Och nu har vi ett dynamiskt program. Jag har inte hårdkodad världen. Jag har inte hårdkodad namn, eller David, eller Zamila. 

Nu är det mycket mer som programmen vi vet, där om det ta input, den producerar något annorlunda utgång. Nu är detta inte den bästa användarupplevelse, eller UX. Jag kör programmet. 

Jag vet inte vad jag ska att göra, om jag ser faktiskt på eller komma ihåg källkoden. Så låt oss göra användaren upplever lite bättre med de enklaste av saker. Låt mig gå tillbaka till detta program, och helt enkelt säga printf. 

Och låt mig gå vidare och säga namn, kolon, och ett utrymme, och sedan ett semikolon. Och bara för sparkar, inget glapp n. Och det är avsiktligt, eftersom jag inte vill uppmaningen att flytta till nästa rad. 

Jag vill i stället göra detta, gör sträng kompilera min kod till ny maskin kod dot slash sträng. Ah, det är mycket sötare. Nu vet jag faktiskt vad datorn vill att jag ska göra, ge den ett namn. 

Så jag kommer att gå vidare och skriva i Rob, komma in, och hej, Rob. Så, inser, detta är fortfarande, i slutet av dagen, endast en nio raden program. Men vi har tagit dessa baby steg. 

Vi skrev en linje som vi var bekant, printf, hallå världen. Sedan knäppte vi en liten bit av det. Och vi faktiskt används get sträng. Och vi kastade detta värde i en variabel. Och sedan gick vi vidare och förbättras det ytterligare med en tredje linje. Och detta iterativ process av skriva programvara är verkligen nyckeln. I CS50 och i livet i allmänhet, du bör i allmänhet inte sitta ner, har ett program i åtanke, och försök att skriva hela jävla sak på en gång. 

Det kommer oundvikligen att leda till sätt fler fel än vad vi själva såg här. Även jag, i dag, hela tiden göra andra dumma misstag, är faktiskt hårdare misstag som är svårare att räkna ut. Men du kommer att göra fler misstag desto mer rader kod du skriver på en gång. Och så denna praxis, skriva lite kod att du känner dig bekväm med, sammanställa det, kör den, testa den mer allmänt, sedan flytta on-- så precis som vi höll skiktning och skiktning i förra veckan, byggnad från något mycket enkel att något mer komplext, göra samma sak här. Inte sitta ner och försöka skriva en hel problem. Faktiskt ta dessa små steg. 

Nu, strängar är inte alla att användbara sig själva. Vi skulle faktiskt, helst som till har något annat i vår verktygslåda. Så låt oss faktiskt göra just detta. 

Låt mig gå vidare nu och piska upp något annat program. Och vi kallar detta int.c för heltal. Jag ska, på samma sätt, inkluderar CS550.h. Jag kommer att inkludera standard IO. Och det kommer att bli ganska vanligt i de första dagarna av klassen. 

Och jag ska redo själv med en huvudfunktion. Och nu i stället för att få en sträng, låt oss gå vidare och få en int. Låt oss kalla det i, och kallar det får int, nära parens, semikolon. Och nu ska vi göra något med det, printf. 

Låt oss säga något i stil hello, omvänt snedstreck n, komma i. Så jag ganska mycket härma vad jag gjorde nyss. Jag har en platshållare här. Jag har kommatecken jag här, eftersom jag vill att plugga i in i den platshållare. 

Så låt oss gå vidare och prova sammanställa detta program. Filen heter int.c. Så jag kommer att säga, gör int anger. Herregud, men ingen big deal, rätt? Det är ett misstag. 

Det finns en syntaktisk misstag här så att programmet kan inte sammanställas i int.c, linje sju, tecken 27, fel format anger typ char stjärna, vad det nu är. Men typ argumentet är int. 

Så även här, vi kommer inte att-- även om dagens är en hel del material, vi kommer att överväldiga dig med absolut alla funktioner i C, och programmering mer generellt, i just dessa första veckorna. Så det är ofta kommer att vara jargong som du inte känner. Och, i själva verket är char stjärn något vi kommer att komma tillbaka till om en vecka eller två tid. 

Men nu, låt oss se om vi kan tolka ord som är bekanta. Format-- så vi hört format specifice, format kod innan. Det är välbekant. Motortyp- men argumentet har typen int. Vänta en minut, är i en int. 

Kanske procent s faktiskt har vissa definierade betydelsen. Och faktiskt, det gör det. Ett heltal, om du vill printf att ersätta det, du faktiskt måste använda en olika format specifikation. Och du skulle inte veta detta såvida inte någon sagt, eller om du hade gjort det tidigare. Men procent i är vad kan vanligen används i printf för att koppla in ett heltal. Du kan också använda procent d för decimal heltal. Men jag är trevlig och enkel här. Så vi ska gå med det. 

Låt mig nu gå vidare och repris gör int, Enter. Det är bra, inga fel. Dot slash int-- OK, dålig användarupplevelse, eftersom jag inte har sagt mig vad ska man göra. Men det är bra. Jag fånga den snabbt. 

Och låt mig nu gå vidare och skriver i David, OK, Zamila, Rob. OK, så det är en bra sak. Den här gången, jag använder en funktion, en pusselbit, som kallas få int. Och det visar out-- och vi ska se detta senare i term-- den CS50 personal har genomfört få sträng på ett sådant sätt att det kommer bara fysiskt få en sträng för dig. 

Det har genomfört get int i ett sådant sätt att det kommer bara få ett heltal för dig. Och om du är människa, inte samarbetar, är det bokstavligen bara gå till säger försöka igen, försöka igen, försöka igen, bokstavligen sitter där looping, tills du tvinga med något magiskt nummer, som 50, och hej 50. 

Eller om vi köra igen och skriv in 42, hello 42. Och så get int insidan av att pusselbit är tillräckligt logik, tillräckligt tanke, att räkna ut, vad är ett ord? Och vad är ett nummer? Endast acceptera, i slutändan, siffror. 

Så visar det sig att detta är inte så uttrycksfull. än så länge. Så, yay, sista gången vi gick ganska snabbt i genomförande spel och animering, och konstnärliga verk i Scratch. Och här är vi är innehåll med Hello World, och hej 50. 

Det är inte så inspirerande. Och faktiskt, dessa första få exempel kommer att ta tid ramp upp i spänning. Men vi har så mycket mer kontrollerar nu, faktiskt. Och vi kommer att mycket snabbt börja skiktning ovanpå dessa grundläggande primitiver. 

Men först, låt oss förstå vad begränsningarna är. I själva verket en av de saker Scratch inte lätt Låt oss göra är att verkligen se under huven, och förstå vad en dator är, vad det kan göra, och vad dess begränsningar är. Och faktiskt, att bristen på förståelse, potentiellt, långsiktig kan leda till vår egen mistakes-- skrivande buggar, skriver osäker programvara som hackas på något sätt. 

Så låt oss ta några steg mot förstå detta lite bättre genom sätt, säger följande exempel. Jag kommer att gå vidare och genomföra riktigt snabbt ett program som heter Adder. Liksom, låt oss lägga till några siffror tillsammans. Och jag kommer att koda vissa hörn här och bara kopiera och klistra in där jag var innan, bara så att vi kan komma igång tidigare. Så nu har jag grund början av ett program som heter Adder. 

Och låt oss gå vidare och göra det. Jag kommer att gå vidare och säg, blir intx få int. Och vet du vad? Låt oss göra en bättre användarupplevelse. 

Så låt oss bara säga x är, och på ett effektivt sätt uppmana användaren att ge oss x. Och låt mig gå vidare och säga, printf vad sägs om y är, den här gången väntar två värden från användaren. Och låt oss gå vidare och säg, printf, är summan av x och y. Och nu vill jag inte att göra procent s. Jag vill göra procent i, bakstreck n, och sedan koppla in summavärde. 

Så hur kan jag gå om att göra detta? Vet du vad? Jag vet hur man använder variabler. Låt mig bara förklara en ny, int z. 

Och jag kommer att ta en gissning här. Om det finns likhetstecken i detta språk, kanske jag kan bara göra x plus y, så länge jag avsluta min tänkte med ett semikolon? Nu kan jag gå tillbaka hit ner, koppla in z, avsluta denna tanke med ett semikolon. Och låt oss se nu, om dessa sekvenser av lines-- x är få int. Y är få int. 

Lägg x och y, lagra värdet i z-- Så, återigen, kom ihåg likhetstecknet är inte lika. Det är uppdrag från höger till vänster. Och låt oss skriva ut att summan av x och y är inte bokstav z, men vad som finns inuti z. Så låt oss göra Adder - trevliga, inga misstag den här gången. Dot snedstreck Adder, in, x kommer att bli en. 

Y kommer att bli två. Och summan av x och y är 3. Så det är alla fina och bra. 

Så du kan tänka mig att matte bör arbeta i ett program som detta. Men vet du vad? Är denna variabel linje 12, ens nödvändigt? Du behöver inte ta för vana för att bara lagra saker i variabler bara för att du kan. Och i själva verket är det i allmänhet genomtänkt dålig design Om du skapar en variabel som kallas z i detta fall, lagra något i det, och sedan omedelbart använda den, men aldrig igen. Varför ge något namn som z om du är bokstavligen kommer att använda som sak endast en gång, och så proximal där du skapat det i första hand, så nära i termer av rader kod? Så du vet vad? Det visar sig att C är ganska flexibel. Om jag verkligen vill plug-in värden här, Jag behöver inte förklara en ny variabel. Jag kunde bara plug-in x plus y, eftersom C förstår aritmetik, och matematiska operatorer. 

Så jag kan bara säga, gör det math, x plus y, oavsett dessa värden, anslut den resulterande heltal i den strängen. Så detta kan vara, men endast en rad kortare, en bättre konstruktion, ett bättre program, eftersom det finns mindre kod, därför mindre för mig att förstå. Och det är också bara renare, mån vi inte införande av nya ord, nya symboler, som z, även om de inte riktigt tjäna mycket av ett syfte. 

Tyvärr är inte matematik allt som tillförlitliga ibland. Låt oss gå vidare och göra det. Jag kommer att gå vidare nu och gör följande. 

Låt oss göra printf, procent i, plus procent Jag ska vara procent i, bakstreck n. Och jag kommer att göra this-- XYX plus y. Så jag ska bara skriva denna något annorlunda här. Låt mig bara göra en snabb kontroll förstånd. Återigen, låt oss inte komma före oss. Gör huggorm, dot slash huggorm. x är 1, y är 2, 1 plus 2 är 3. Så det är bra. Men låt oss komplicera detta nu en bit, och skapa en ny fil. 

Jag kommer att kalla detta en, säga, Ints, plural för heltal. Låt mig börja där jag var för en stund sedan. Men nu ska vi göra några andra linjer. Låt mig gå vidare och göra följande, printf, procent i, minus procent i, är procent i, komma x, komma yx minus y. Så jag gör något olika matematik där. Låt oss göra en annan. Så procent i gånger procent i är procent i, omvänt snedstreck n. Låt oss plug-in x och y, och x gånger y. Vi kommer att använda asterisk på datorn för tider. 

Du behöver inte använda x. x är ett variabelnamn här. Du använder stjärnan för multiplikation. Låt oss göra en till. Printf procent I, uppdelat genom procent i, är procent i, bakåtstreck n. xy dividerat med y-- så du använda snedstreck i C att göra division. Och låt oss göra en annan. Återstoden av procent i, uppdelat genom procent i, är procent i. xy-- och nu resten är vad som finns kvar över. När du försöker dela en nämnare i en täljare, hur mycket är kvar att Du kan inte dela ut? 

Så det finns egentligen inte, nödvändigtvis, en symbol vi har använt i grundskolan för detta. Men det i C. Du kan säga x modulo y, där denna procenttecknet i denna context-- förvirrande när du är inne av citationstecken, insidan av printf, procent används som format specifikation. 

När du använder procent utanför att i ett matematiskt uttryck, det är modulooperatorn för modul arithmetic-- för våra ändamål här, betyder bara, vad är det återstoden av x delat med y? Så x dividerat med y x snedstreck y. Vad är resten av x delat med y? Det är x mod y, som programmerare skulle säga. 

Så om jag gjorde inga misstag här, låt mig gå vidare och göra Ints, plural, trevlig, och dot slash ints. Och låt oss gå vidare och gör, låt oss säga, en 10. Okej, är ett plus 10 11, check. 1 minus 10 är -9, kontrollera. 

1 gånger 10 är 10, check. 1 dividerat med 10 är-- OK, vi hoppar över den. Återstoden av en delat med 10 är ett. Det stämmer. Men det finns ett fel i här. 

Så jag lägger min lämna över, inte är korrekt. Jag menar, det är nära till 0. 1 dividerat med 10, du vet, om vi styckning vissa hörn, säker, det är noll. Men det borde verkligen vara 1/10, 0,1 eller 0,10, 0,1000, eller så vidare. 

Det borde egentligen inte vara noll. Tja, visar det sig att datorn är gör bokstavligen vad vi veta det att göra. Vi gör matematik som x dividerat med y. Och både x och y, per linjerna kod tidigare är heltal. 

Dessutom, på linje 15, är vi berättar printf, hej, printf plug-in ett heltal, plug-in ett heltal, plug-in en integer-- specifikt x, och sedan y och sedan x dividerat med y. x och y är ints. Vi är bra där. 

Men vad är x dividerat med x? x dividerat med y borde vara, matematiskt, 1/10, eller 0,1, som är ett reellt tal, ett reellt tal med potentiellt ett decimalkomma. Det är inte ett heltal. 

Men vad är det närmaste heltal till 1/10, eller 0,1? Ja, typ av är det noll. 0,1 är så här mycket. Och en är detta mycket. Så 1/10 är närmare 0 än det är att en. 

Och så vad C gör för oss-- typ av eftersom vi fick höra det att-- är trunkera som heltal. Det tar värdet, vilket återigen är tänkt att vara något som 0,1000, 0 och så vidare. Och det trunke allt efter decimalkommat så att allt detta saker, eftersom det inte gör det passa in i begreppet ett heltal, som är bara ett nummer som -1, 0, 1, upp och ner, kastar bort allt efter decimalkommat eftersom du kan inte passa en decimal i ett heltal per definition. 

Så svaret här är noll. Så hur ska vi åtgärda detta? Vi behöver en annan lösning tillsammans. Och vi kan göra detta, enligt följande. 

Låt mig gå vidare och skapa en ny fil, som kallas detta en floats.c. Och spara den här i samma katalog, float.c. Och låt mig gå vidare och kopiera en del av denna kod från tidigare. 

Men i stället för att få en int, låt oss göra detta. Ge mig ett flyttalsvärde kallas x. där en flyttals Värdet är bara bokstavligen något med ett flyttal. Det kan röra sig åt vänster, till höger. Det är ett reellt tal. 

Och låt mig kalla inte få int, men få flyta, som också var bland menyn alternativ i C250-biblioteket. Låt oss ändra y till en flottör. Så det här blir få flyta. 

Och nu vill vi inte att koppla in Ints. Det visar sig att vi måste använda procent f för flyta, procent f för flottören, och nu spara den. Och nu, tummarna, göra flottar, fina, dot slash flyter. x kommer att bli en 1. y Kommer att vara 10 igen. 

Och är trevligt, OK mitt tillägg korrekt. Jag hoppades för mer, men jag glömde att skriva det. Så låt oss gå och fixa detta logiskt fel. 

Låt oss gå vidare och ta följande. Vi ska bara göra en liten kopiera och klistra in. Och jag kommer att säga minus. 

Och jag kommer att säga gånger. Och jag ska säga delas. Och jag tänker inte göra modulo, som inte är så förbunden här, dividerat med f, och tider plus-- OK, låt oss göra detta igen. 

Gör flottar, dot slash flottar, och 1, 10, och-- trevligt, nej, OK. Så jag är en idiot. Så detta är mycket vanligt i datavetenskap att göra dumma misstag som detta. 

Av pedagogiska skäl, vad jag verkligen ville göra var ändra vetenskapen här till plus, minus, till tider, och att dela, som ni förhoppningsvis märkt under denna övning. Så nu ska vi åter sammanställa denna program, gör dot slash flyter. 

Och för tredje gången, låt oss se om det uppfyller mina förväntningar. 1, 10, in, ja, OK, 1,000, dividerat med 10,000, är ​​0,100000. Och det visar sig att vi kan kontrollera hur många nummer är ute efter de decimaler. Vi kommer faktiskt. Vi ska återkomma till det. 

Men nu, i själva verket är matematik korrekt. Så, återigen, vad är takeaway här? Det visar sig att i C, finns det inte bara bara strings-- och, faktiskt, Det finns egentligen inte, eftersom vi lägga till dem med CS50 biblioteket. Men det finns inte bara Ints. 

Det finns också flyter. Och det visar sig en massa andra uppgifter typer också att vi kommer att använda kort. Det visade sig att om du vill ha en enda karaktär, inte en teckensträng, du kan använda bara en röding. 

Det visade sig att om du vill ha en bool, ett booleskt värde, sant eller falskt bara, Tack vare CS50 biblioteket, vi har adderas till C typen bool uppgifter också. Men det är också närvarande i många andra språk. Och det visar sig att ibland behöver större siffror sedan kommer som standard med Ints och flottar. 

Och, i själva verket en dubbel är ett tal som använder inte 32 bitar, men 64 bitar. Och en lång lång är ett nummer som använder inte 32, bitar men 64 bitar, respektive, för flyttal värderingar och heltal, respektive. Så låt oss faktiskt nu se detta i aktion. 

Jag kommer att gå vidare här och piska upp ett annat program. Här kommer jag att gå vidare och inkluderar CS50.h. Och låt mig gå, omfattar standard IO.h. 

Och du kommer att märka något funky som händer här. Det är inte färgkodning saker i på samma sätt som den gjorde tidigare. Och det visar sig, det är därför jag har inte gett saken ett filnamn. 

Jag kommer att kalla detta en sizeof.c, och klicka på Spara. Och lägg märke till vad som händer med min mycket vit kod mot den svarta bakgrunden. Nu, åtminstone det finns några lila där. Och det är syntax markerat. 

Det beror helt enkelt, jag har berättade IDE vilken typ av fil Det är genom att ge den ett namn, och specifikt ett filnamnstillägg. Nu ska vi gå vidare och göra det. Jag kommer att gå vidare och mycket helt enkelt skriva ut following-- bool är procent LU. 

Vi ska återkomma till att på bara ett ögonblick. Och då kommer jag att utskriftsstorlek bool. Och nu, bara för att spara mig lite tid, jag är kommer att göra en hel gäng av dessa på en gång. Och särskilt jag ska ändra detta till en röding och röding. Den här kommer jag att ändra till en dubbel och en dubbel. 

Den här kommer jag att ändra till ett flöte och en flottör. Den här, kommer jag att byta till en int och en int. Och här kommer jag att ändra till en lång lång. Och det är fortfarande ta en lång tid, lång lång. 

Och sedan, slutligen, gav jag själv en alltför många, sträng. Det visar sig att i C, det finns den speciella operatören kallas Storleken på det är bokstavligt talat kommer att, när det körs, berätta storleken på var och en av dessa variabler. Och detta är ett sätt, nu, vi kan koppla tillbaka till förra veckans diskussion av data och representation. 

Låt mig gå vidare och sammanställa Storleken på punkt snedstreck storlek. Och låt oss se. Det visar sig att i C, specifikt på CS50 IDE, specifikt på operativsystemet Ubuntu, som är en 64-bitars operativsystem systemet i detta fall, en bool kommer att använda en bitgrupp av rymden. Det är hur storleken mäts, inte i bitar, men i byte. Och minns att ett byte är åtta bitar. Så en bool, även om du tekniskt bara behöver en 0 eller 1, det är lite slösaktigt hur vi har genomfört det. Det är faktiskt kommer att använda en hel byte-- så alla nollor, är kanske alla ettor, eller något liknande, eller bara en en bland åtta bitar. 

En röding, under tiden, som används för ett tecken som en ASCII-tecken per förra veckan, kommer att vara ett tecken. Och det synchs med vår uppfattning om det är inte mer än 256 bits-- snarare synchs upp med det är ingen längre än 8 bitar, som ger oss så många som 256 värden. En dubbel kommer att vara 8 byte eller 64 bitar. 

En flottör är fyra. En int är fyra. En lång, är lång 8. Och en sträng är åtta. Men oroa dig inte om det. Vi kommer att dra tillbaka det lagret. Det visar sig, strängar kan vara längre än 8 byte. 

Och faktiskt, vi har skrivit strängar redan, hallå världen, längre än 8 byte. Men vi kommer tillbaka till att på bara ett ögonblick. Men ta bort här är följande. 

Alla datorer har bara en ändlig mängd minne och utrymme. Du kan bara lagra så många filer på din Mac eller PC. Du kan bara lagra så många program i RAM körs på en gång, med nödvändighet, även med virtuellt minne, eftersom du har en ändlig mängd RAM. 

Och bara för att picture-- om du aldrig har öppnat upp en bärbar dator eller beställas extra minne för en dator, du kanske inte vet att insidan av din dator är något som ser lite som det här. Så det här är bara ett gemensamt bolag som heter Avgörande som gör RAM för datorer. Och RAM är där program leva medan de kör. 

Så på varje Mac eller PC, vid dubbel Klicka på ett program, och det öppnar upp, och det öppnar några Word-dokument eller något sådant, lagrar den tillfälligt i RAM, eftersom RAM är snabbare än hårddisken, eller din solid state disk. Så det är bara där program går att leva när de kör, eller när filerna används. 

Så du har saker som ser som detta i din bärbara dator, eller något större saker inne på skrivbordet. Men nyckeln är du bara har en ändligt antal av dessa saker. Och det finns bara en begränsad mängd maskinvara sitter på detta skrivbord höger här. 

Så säkert, vi kan inte lagra oändligt långa nummer. Och ändå, om du tänker tillbaka på grundskola, hur många siffror kan du har till höger av ett decimalkomma? För den delen, hur många siffror kan du har till vänster om ett decimalkomma? Verkligen, oändligt många. 

Nu, vi människor bara kanske hur man uttalar miljoner, och miljarder biljoner, och quadrillion och kvintiljon. Och jag vidga gränserna för min understanding-- eller my-- jag förstår siffror, men min uttalet av siffror. Men de kan få oändligt stora med oändligt många Siffrorna till vänster eller till höger om ett decimalkomma. 

Men datorer har bara en begränsad mängd minne, ett ändligt antal transistorer, en ändligt antal glödlampor inuti. Så vad händer när du får slut på utrymme? Med andra ord, om du tänka tillbaka på förra veckan när vi pratade om siffror sig representeras i binär, Anta att vi har Detta 8-bitars värde här. 

Och vi har sju 1: or och en 0. Och anta att vi vill för att lägga till ett till detta värde. Detta är en riktigt stor antal just nu. 

Detta är 254, om jag minns matten från förra veckan höger. Men vad händer om jag ändrar att högra 0 till 1? Hela antal, av Naturligtvis blir åtta 1: or. Så vi är fortfarande bra. 

Och som förmodligen representerar 255, men beroende på sammanhang det faktiskt kan utgöra ett negativt tal. Men mer om det en annan gång. Det känns som om det handlar om så högt som jag kan räkna. 

Nu är det bara 8 bitar. Och min Mac, säkert, har sätt mer än 8 bitar av minnet. Men det har ändlig. Så samma argument gäller, även om vi har flera av dessa de på skärmen. 

Men vad händer om du är lagra detta nummer, 255, och du vill räkna en lite högre? Du vill gå 255-256. Problemet är naturligtvis att om du börja räkna på noll som förra veckan, du kan inte räknas som hög som 256, för att inte tala 257, än mindre 258, m eftersom det som händer när du lägger till en 1? Om du gör den gamla grundskolan tillvägagångssätt, sätta dig en en här, och sedan ett plus ett är två, men det är verkligen en nolla, bär du en, bära en, bära ett. Alla dessa saker, dessa 1 s, gå till noll. Och man hamnar, ja, som någon påpekade, en 1 på vänster sida. Men allt du kan faktiskt se och passar i minnet är bara åtta 0-talet, det vill säga någon gång om du, en dator, försökte räkna tillräckligt högt upp, du är kommer att svepa runt, verkar det, till noll, eller kanske till och med negativ nummer, som är ännu lägre än noll. 

Och vi kan slags se detta. Låt mig gå vidare och skriva en riktig snabb program här. Låt mig gå vidare och skriva ett program som kallas Overflow. Inkluderar CS50.h, inkluderar standard IO.h-- oh, Jag missade verkligen min syntaxmarkering. Så låt oss spara som overflow.c. 

Och nu int main void-- och snart kommer vi komma tillbaka till att förklara varför vi fortsätta skriva int main tomrum. Men nu, låt oss bara göra det, ta det för givet. Låt oss ge mig en int, och initiera den till 0. 

Låt oss då göra för int jag får zero-- faktiskt, låt oss göra en oändlig loop och se vad som händer. Även sant, så låt oss skriva ut n är procent i, bakstreck n, plug-in n. Men nu, låt oss göra n blir n plus 1. 

Så med andra ord, på varje variant av denna oändlig slinga, låt oss ta n värde, och tillsätt 1 till den, och sedan lagra tillbaka i n resultatet till vänster. Och i själva verket har vi sett syntax något som detta kort. En cool trick är istället att skriva ut allt detta, du faktiskt kan säga en n plus lika med 1. 

Eller om du verkligen vill vara snygga, du kan säga n plus plus semikolon. Men de två sistnämnda är bara vad vi skulle kalla syntaktiskt socker för det första. 

Det första är tydligare, helt bra, helt korrekt. Men det är vanligare, ska jag säga. Så vi kommer att göra detta för ett ögonblick. 

Låt oss nu göra spill, vilket låter ganska illavarslande, dot slash spill. Låt oss se, n blir ganska stor. Men låt oss tänka, hur stor kan n få? 

n är ett int. Vi såg en stund sedan med storleken på exempel att en int är fyra byte. Vi vet från förra veckan, är fyra byte 32 bitar, eftersom 8 gånger 4, det är 32. Det kommer att vara 4 miljarder. 

Och vi är upp till 800.000. Detta kommer att ta evigheter att räknas som högt som jag kan. Så jag kommer att gå framåt, som ni kanske snart, och slå kontroll C- ärligt talat, kontroll C, en hel del, där Kontroll C i allmänhet medel avbryta. Tyvärr, eftersom detta körs i molnet, ibland molnet är spotta ut så mycket grejer, så mycket produktion, det kommer att ta en liten stund för min ingång för att komma till molnet. Så även om jag slog Kontroll C några sekunder sedan, Detta är definitivt sidan effekten av en oändlig slinga. 

Och så i sådana fall, vi är kommer att lämna det vara. Och vi kommer att lägga till en annan terminalfönster hit med plus, vilket naturligtvis inte så, eftersom det är fortfarande tänker. Och låt oss gå vidare och vara lite mer rimlig. 

Jag kommer att gå vidare och göra detta endast ändligt många gånger. Låt oss använda en for-loop, som jag nämnt tidigare. Nu gör vi det. Ge mig en annan variabel int i blir 0. Jag är mindre än, låt oss säga, 64 i ++. Och låt mig nu gå vidare och skriva ut ut n är procent i, komma n. Och sedan n-- detta är fortfarande kommer att ta för evigt. Nu gör vi det. 

n blir n gånger 2. Eller vi kan vara snygga och göra gånger är lika med två. Men låt oss bara säga n lika sig gånger 2. Med andra ord, i detta ny version av programmet, Jag vill inte vänta för evigt från som 800.000 till 4 miljarder. Låt oss bara få det överstökat. 

Låt oss faktiskt dubbla n varje gång. Vilket minns, är en fördubbling av motsatsen till att ha, naturligtvis. Och medan förra veckan vi har något igen, och igen, och igen, supersnabb, fördubbling kommer säkert få oss från en till största möjliga värde som vi kan räkna till med en int. 

Så låt oss göra just detta. Och vi kommer att återkomma till detta kort. Men detta, återigen, är precis som upprepningsblocket i Scratch. Och du kommer att använda detta inom kort. 

Detta betyder bara räkna från noll upp till, men inte lika, till 64. Och på varje variant av denna loop, bara hålla uppräkning i. Så jag ++ - och denna allmänna konstruktion på ledningen 7 är bara en super vanligt sätt att upprepa några rader av kod, en del antal gånger. Vilka kodrader? Dessa klamrar, som ni kan ha samlats in från nu, innebär, gör följande. 

Det är på liknande Scratch, när det har de gula blocken och andra färger som typ av omfamna eller krama andra block. Det är vad dessa lockiga hängslen gör här. Så om jag fick min syntax right-- du kan se morot symbolen i C medel det är hur många gånger jag var försöker att lösa detta problem. Så låt oss bli av med det en helt och hållet, och stäng fönstret. Och vi kommer att använda den nya. Gör overflow, pricka snedstreck spill, Enter, okej, Det ser illa först. Men låt oss bläddra tillbaka i tiden, eftersom jag gjorde detta 64 gånger. 

Och lägg märke till första gången, är n 1. Andra gången, är n 2, sedan fyra, sedan åtta, sedan 16. Och det verkar som så snart som Jag får ungefär 1 miljard, om jag dubbla det igen, som borde ge mig 2 miljarder. Men det visar sig, är det rätt på gränsen. 

Och så det faktiskt flödar en int från 1 miljard till ungefär negativ 2 miljarder, eftersom ett heltal, Till skillnad från siffrorna vi räknade förra veckan, kan vara både positiv och negativ i verkligheten och i en dator. Och så åtminstone en av dem bitarna är effektivt stulen. Så vi egentligen bara har 31 bitar, eller 2 miljarder möjliga värden. 

Men nu är takeaway ganska helt enkelt, oavsett dessa siffror är och vad matte är, något dåligt händer så småningom, eftersom så småningom du försöker permutera bitarna en alltför många gånger. Och du faktiskt gå från alla 1 s till kanske alla 0: or, eller kanske bara något annat mönster som det klart, beroende på sammanhanget, kan tolkas som ett negativt tal. Och så verkar det högsta jag kan räkna i detta program är bara ungefär 1 miljard. Men det finns en dellösning här. Vet du vad? 

Låt mig byta från en int till en lång lång. Och låt mig gå vidare här och säga-- jag kommer att ha att ändra detta till en osignerad länge. Eller, låt oss se, jag minns aldrig själv. 

Låt oss gå vidare och göra overflow. Nej, det är inte det, LLD, tack. Så ibland Clang kan vara till hjälp. Jag minns inte vad format specifice var för en lång lång. 

Men, ja, klang berättade. Grönt är någon typ av bra, fortfarande innebär att du gjort ett misstag. Det gissar att jag menade LLD. 

Så låt mig ta det råd, en lång lång decimaltal, spara det. Och låt mig köra den, dot slash spill, Enter. Och nu vad är hett är detta. 

Om jag bläddra tillbaka i tiden, vi ändå starta räkna på samma plats-- 1, 2, 4, 8, 16. Meddelande, får vi alla upp till 1 miljard. Men då vi säkert komma till 2 miljarder. 

Då får vi till 4 miljarder, då 8 miljarder, 17 miljarder. Och vi gå högre, och högre och högre. Så småningom, även detta avbrott. 

Så småningom, med en lång lång, som är den 64-bitars värde, inte en 32-bitars värde, om man räknar för högt, du linda runt 0. Och i detta fall, råkar vi sluta med ett negativt tal. 

Så detta är ett problem. Och det visar sig att detta Problemet är inte så svårbegripliga. Även om jag har medvetet inducerade det med dessa misstag, det visar sig vi ser det slags allt omkring oss, eller åtminstone en del av oss gör. 

Så i Lego Star Wars, om du någonsin spelat spelet, det visar sig att du kan gå runt bryta upp saker i LEGO världen, och samla mynt, i huvudsak. Och om du någonsin spelat detta spel alldeles för mycket tid, eftersom detta unnamed individ här gjorde det totala antalet mynt som du kan samla är, det verkar, 4 miljarder. 

Nu, med den faktiskt är rundad. Så LEGO försökte hålla saker användarvänliga. De gjorde inte det exakt två till 32 kraft per förra veckan. Men 4000 miljoner är en anledning. Det verkar, baserat på denna information, att LEGO, och det företag som gjorde detta själva mjukvaran, beslutade att det maximala antalet mynt användaren kan ackumuleras är verkligen 4 miljarder, eftersom de valde i sin kod att använda inte en lång lång, tydligen, men bara ett heltal, en osignerad heltal, endast ett positivt heltal, vars maxvärdet är ungefär det. Tja, här är en annan rolig en. Så i spelet Civilization, som några av er kanske känner, med det visar sig att år sedan fanns var en bugg i detta spel där om du spelat rollen av Gandhi i spelet, i stället för att han var mycket pacifist, i stället var otroligt, otroligt aggressiv, under vissa omständigheter. I synnerhet det sätt som Civilization verk är att om du, spelaren, anta demokrati, din aggressivitet poängen blir minskas med två, så minus minus, och sedan minus minus. 

Så du subtrahera två från din faktiska iteration. Tyvärr, om din iteration är initialt en, och du subtrahera två från det efter antagandet av demokrati som Gandhi här är kanske har gjort, eftersom han var mycket passive-- 1 på skalan av aggressivitet. Men om han antar demokrati, då Han går från 1 till -1. 

Tyvärr var de användning av osignerade nummer, vilket innebär att de behandlas med negativ siffror som om de var positiva. Och det visar sig att positiv ekvivalent negativ 1, i typiska datorprogram, är 255. Så om Gandhi antar demokrati har, och därför hans aggressivitet poäng minskat, det faktiskt rullar runt till 255 och gör honom mest aggressiv karaktär i spelet. Så du kan googla upp på detta. Och det var faktiskt en oavsiktlig bug programmering, men som anges ganska lore sedan dess. 

Det är allt roligt och söt. Mer skrämmande är när den faktiska verkliga enheter, och inte spel, har dessa samma buggar. I själva verket bara ett år sedan en artikel kom reda på Boeing 787 Dreamliner. 

Och artikeln först blick läser lite svårbegripliga. Men det sagt detta, en programvara sårbarhet i Boeings nya 787 Dreamliner jet har potential att orsaka piloter att förlora kontrollen över flygplanet, eventuellt i mitten av flygning, FAA tjänstemän varnade flygbolag nyligen. Det var bestämn att en modell 787 flygplan som har varit i drift kontinuerligt under 248 dagar kan förlora all växelström, AC, elektrisk effekt på grund av att generatorn styrenheter, GCUs, samtidigt gå in felsäkert läge. Det finns en slags förlora mig. Men PM anges OK, nu fick jag det, villkoret orsakades av en programvara motverka interna generatorstyrning enheter som kommer att flöda efter 248 dagar av kontinuerlig effekt. Vi utfärdar denna märker att förhindra förlust av all växelströms makt, vilket kan leda till förlust av kontroll över flygplanet. 

Så, bokstavligen, det finns något heltal, eller någon typ motsvarande uppgifter, används i programvara i en verklig flygplan att om du håller ditt flygplan på tillräckligt länge, som uppenbarligen kan vara fallet om du bara kör dem hela tiden och aldrig koppla ur ditt flygplan, verkar det, eller låta batterierna dör, så småningom kommer att räkna upp, och upp, och upp, och upp, och upp, och upp. 

Och till sin natur, en ändlig mängd minne kommer att flöda, rulla tillbaka till noll eller något negativt värde, en bieffekt av vilket är den skrämmande verkliga verkligheten att planet kan behöva startas om, effektivt, eller kan falla ännu värre, eftersom den flyger. Så dessa typer av frågor är fortfarande med oss, even-- detta var en 2015 artikel, desto mer skrämmande när du inte nödvändigtvis förstå, uppskatta, eller förutse dessa typer av fel. 

Så det visar sig att det finns en annan dåligt om datarepresentation. Det visar sig att även flottörer är typ av bristfällig, eftersom flöten också, Jag föreslog är 32 bitar, eller kanske 64 om du använder en dubbel. Men det är fortfarande begränsad. 

Och fångsten är att om du kan sätta ett oändligt antal siffror efter decimalkommat, Det finns inget sätt du kan representera alla möjliga siffror som vi undervisade i grundskolan kan existera i världen. En dator i huvudsak måste välja en delmängd av dessa siffror att representera exakt. 

Nu, att datorn kan runda kanske lite, och kan tillåta dig att ungefär lagra valfritt antal du kan tänkas vilja. Men bara intuitivt, om du har ett ändligt antal bitar, du kan bara permutera dem i så många ändliga sätt. Så du kan omöjligen använder ett ändligt antal av permutation av bitar, mönster nollor och ettor, för att representera en oändlig antal siffror, vilket tyder på att datorer kan mycket väl vara att ljuga för oss ibland. 

I själva verket, låt oss göra detta. Låt mig gå tillbaka till CS50 IDE. Låt mig gå vidare och skapa ett litet program kallas Imprecision, för att visa att datorer är, faktiskt, oprecisa. 

Och låt mig gå vidare och börja med en del av denna kod från tidigare, och nu bara göra följande. Låt mig gå vidare och göra printf, procent f, bakstreck n, ett dividerat med 10. Med andra ord, låt oss dyka djupare 1/10, som en och dividerat med 10. Visst kan en dator representera 1/10. 

Så låt oss gå vidare och göra imprecision. Låt oss se. Format anger typ dubbel. Men argumentet har typen int. Vad pågår? 

Åh, intressant, så det är en lärdom från tidigare. Jag säger, hej, dator show mig en flottör med procent f. Men jag ger det 2 Ints. Så visar det sig, kan jag fixa detta på ett par olika sätt. 

Jag kunde bara vända ett till 1,0, och 10 i 10,0, vilket skulle faktiskt innebära att omvandla dem i floats-- fortfarande förhoppningsvis samma nummer. Eller det visar sig att det finns något vi får se igen snart. Du kan kasta siffrorna. 

Du kan med hjälp av denna parentes uttryck, kan man säga, hej, dator, ta 10, som jag vet är en int. Men behandla det, snälla, som om det är en flottör. Men det känns onödigt komplicerade. 

För våra syften i dag, Låt oss bara bokstavligen gör dem flyttal värden med decimalkomma, som den här. Låt mig gå vidare och repris, göra vaghet, bra, pricka snedstreck vaghet anger. OK, vi ser bra ut. 

1 dividerat med 10, i enlighet med min Mac här, är faktiskt 0,100 tusen. Nu fick jag lära mig i grundskolan där bör vara ett oändligt antal 0: or. Så låt oss åtminstone försöka att se några av dessa. Det visar sig att printf är lite snyggare fortfarande än vi har använt. Det visar sig att du inte behöver ange bara procent f, eller bara procent i. Du kan faktiskt ange några kontrollmöjligheter här. 

Specifikt, jag ska att säga, hej, printf, faktiskt visa mig 10 decimaler. Så det ser lite konstigt. Men du säger procent, pricka, hur många siffror du vill se efter decimalkomma och sedan f för platt, bara för att det är vad dokumentationen säger. Låt mig gå vidare och spara det. 

Och märker också, jag får trött på att skriva om saker. Så jag bara sätta upp och nedåtpilen på mina nycklar här. Och om jag fortsätter att slå upp, du kan se alla kommandon som jag gjorde, eller felaktigt gjord. 

Och jag kommer att gå vidare nu och faktiskt inte använda det, tydligen. Gör vaghet dot slash imprecision-- så vad jag lärdes ut i grundskolan checkar ut. Även om jag ut det till 10 decimal placerar den faktiskt är 0,10 tusen. Men vet du vad? 

Låt oss få lite girig. Låt oss säga, som visar mig 55 Parlamentet efter decimalkommat. Låt oss verkligen ta detta programmera ut på en tur. Låt mig göra om den med make vaghet, pricka snedstreck, otydligheter. 

Och nu kör vi. Din barndom var en lögn. Uppenbarligen, ett delat med 10 är verkligen 0.100000000000000005551115123-- 

Vad händer? Tja, visar det sig, om du typ av tittar tillräckligt långt ut i den underliggande representation av denna nummer, det faktiskt är inte exakt 1/10, eller 0,1 och ett oändligt antal nollor. Nu, varför är det? 

Tja, även om detta är en enkel nummer till oss människor, en dividerat med 10, det är fortfarande en av oändligt många siffror som vi kunde tänka upp. Men en dator kan endast representera ändligt många så tal. Och så, på ett effektivt sätt, vad dator visar oss är dess närmaste approximation till det antal Vi vill tro är 1/10, eller egentligen 0,10000 oändlighet. 

Snarare är dock detta så nära som det kan få. Och faktiskt, om man tittar under huven, som vi är här genom att titta 55 siffror efter decimalkommat, vi faktiskt se att verkligheten. Nu som en sidoreplik, om du har någonsin sett movie-- de flesta av er förmodligen haven't-- men Superman 3 några år sedan, Richard Pryor väsentligen utnyttjas detta verklighet i hans företag att stjäla en hel del av fraktioner och fraktioner av pennies, eftersom company-- som jag minns, det har varit en while-- var i huvudsak kasta bort allt som inte passar i begreppet cent. 

Men om du lägger upp alla dessa små, små, små siffror igen, och igen, och igen, kan du, som i hans fall, göra en bra summa pengar. 

Samma idé var rippat av en senare, men ändå nu äldre film, kallad Office Space, där killarna i den filmen, gjorde samma sak, skruvas upp helt slutade med alldeles för mycket pengar på sitt bankkonto. Det var alla mycket misstänksam. Men i slutet av dagen, imprecision är runt omkring oss. 

Och det också kan vara skrämmande fallet. Det visar sig att Superman 3 och Kontor åt sidan, där kan vara någon mycket verklig världs förgreningar av verkligheten i oprecis representation av data att även vi människor till denna dag inte nödvändigtvis förstå liksom vi borde, eller komma ihåg så ofta som vi borde. Och faktiskt, är följande klipp från en titt på några mycket verkliga världen förgreningar vad händer om du inte uppskattar vaghet som kan hända i antal representation. 

[VIDEOUPPSPELNING] 

-Datorer, Vi har alla kommit att acceptera de ofta frustrerande problem som gå med them-- buggar, virus, och programvara glapp, för små priser för att betala för att underlätta. Men i högteknologiska och hög hastighet militära och rymdprogram applikationer, den minsta problemet kan förstoras till katastrof. 

Den 4 juni 1996, forskare beredd att lansera en obemannad Ariane 5-raketen. Det bar vetenskaplig satelliter utformade att fastställa exakt hur jordens magnetfält samverkar med solvinden. Raketen byggdes för Europeiska rymdorganisationen, och lyfte från sin anläggning vid kusten i Franska Guyana. 

-at Ca 37 sekunder in flygningen, de först märkt något gick fel. Munstyckena var svängbar i ett sätt som de borde verkligen inte. Omkring 40 sekunder in i flygningen, klart, fordonet var i trubbel. 

Och det är när de gjorde ett beslut att förstöra det. Utbudet säkerhetsansvarige, med enorma tarmar, tryckte på knappen, blåste upp raketen, innan den kunde blivit en fara för den allmänna säkerheten. 

-detta Var jungfrun resan av Ariane 5. Och dess förstörelse tog placera beror på ett fel inbäddad i raketens programvara. -Den Problem på Ariane var att det fanns ett antal som krävs 64 bitar för att uttrycka. Och de ville konvertera den till en 16-bitars nummer. De antog att antal aldrig gå att vara mycket stor, att de flesta av dem siffror i en 64-bitars tal var nollor. De hade fel. 

-Den Oförmåga en mjukvaruprogram för att acceptera den typ av antalet som genereras av en annan var vid roten av misslyckande. Mjukvaruutveckling hade blivit en mycket kostsam del av ny teknik. Ariane raketen har varit mycket framgångsrik, så mycket av programvaran skapas för det var också används i Ariane 5. 

-Den Grundläggande problemet var att Ariane 5 var snabbare, accelereras snabbare. Och programmet inte hade stod för det. 

-Den Förstörelse av raketen var en enorm ekonomisk katastrof, allt på grund av en minut programfel. Men detta var inte den första tidsproblem omvandlingsdata hade plågat modern raketteknik. 

-I 1991, med start av det första Gulfkriget, Patriot Missile upplevt en liknande typ av antalet konvertering problem. Och som ett resultat, 28 personer, 28 amerikanska soldater, dödades, och omkring 100 andra skadades, när Patriot, som var tänkt för att skydda mot inkommande Scuds, misslyckades med att avfyra en missil. 

-När Irak invaderade Kuwait, och Amerika lanserades Desert Storm i början av 1991, Patriot Missile batterier utplacerades att skydda Saudi Arabien och Israel från irakiska Scud missiler. Patriot är en amerikansk medium-range yta för att luftsystemet, tillverkat från Raytheon företaget. 

-Den Storlek Patriot jaktplan själv är om ungefär 20 fot lång. Och den väger omkring 2000 pounds. Och det bär en stridsspets av ca, Jag tror att det är ungefär 150 pounds. Och stridsspetsen i sig är ett sprängämne, som har fragment runt den. Höljet av stridsspetsen är utformad för att agera som hagel. 

-de Missiler genom fyra per container, och transporteras genom ett semitrailer. 

-Den Patriot anti-missilsystem går tillbaka åtminstone 20 år nu. Den var ursprungligen avsedd som ett luftvärnsrobot att skjuta ner fientliga flygplan. I det första Gulfkriget, när detta krig kom, armén ville använda den för att skjuta ner Scuds, inte flygplan. 

Den irakiska flygvapnet var inte så mycket av ett problem. Men armén var orolig Scuds. Och så försökte de att uppgradera Patriot. 

-Intercepting En fiende missil reser på mach 5 skulle vara utmanande nog. Men när Patriot fördes i bruk, armén var inte medveten om en Iraks ändring som gjorde deras Scuds nästan omöjligt att slå. 

-Vad Hände är Scuds som kom in var instabil. De vinglar. Anledningen till detta var irakierna, i syfte att få 600 kilometer ut ur en 300 kilometer missiler, tog vikt ut ur den främre stridsspetsen. De gjorde stridsspetsen lättare. 

Så nu Patriot är försöker komma på Scud. Och för det mesta, det överväldigande majoritet av tiden, det skulle bara flyga av Scud. När Patriot systemansvariga insåg Patriot missade sitt mål, de detonerade Patriot stridsspets att undvika eventuella förluster om det tilläts att falla till marken. 

-Det Var vad de flesta människor såg, de stora eldklot på himlen, och missförstås som avlyssningar av Scud stridsspetsar. 

-Även I natt himmel, verkade Patriots vara framgångsrikt förstöra Scuds, på Dhahran, det kan finnas några misstag om dess prestanda. Där Patriot radarsystem förlorat kontakten med en inkommande Scud, och aldrig lanserats på grund till en programvara fel. Det var israelerna som först upptäcktes att ju längre systemet var på, Ju större skillnaden blev, på grund av att en klocka inbäddad i systemets dator. 

-Om Två veckor före tragedin i Dhahran, israel rapporteras till Försvarsdepartementet att systemet skulle förlora tid. Efter cirka åtta timmar eller löpning, de märkte att systemet blev märkbart mindre exakt. Försvarsdepartementet svarade med berättar alla Patriot batterier att inte lämna systemen på under en lång tid. De sa aldrig vad en lång tid was-- åtta timmar, 10 timmar, 1000 timmar. Ingen visste. 

-Den Patriot batteri stationerade vid barackerna vid Dhahran och dess bristfälliga inre klocka hade varit på över 100 timmar på kvällen den 25 februari. 

-det Spårade tid med en noggrannhet på ungefär en tiondels sekund. Nu, en tiondels sekund är ett intressant, eftersom det kan inte uttryckas i binär exakt, vilket betyder det inte kan uttryckas exakt i varje modern digital dator. Det är svårt att tro. 

Men använder detta som ett exempel. Låt oss ta nummer tredjedel. En tredjedel kan inte vara uttrycks i decimal exakt. En tredjedel är 0,333 pågått i oändlighet. 

Det finns inget sätt att göra det med absolut noggrannhet i decimal. Det är precis den typ av problem som hände i Patriot. Ju längre systemet sprang, den värre tidsfelet blev. 

-Efter 100 timmars drift fel i tiden var endast omkring en tredjedel av en sekund. Men när det gäller att rikta en missil färdas i Mach 5, Det resulterade i en spårning fel på över 600 meter. Det skulle vara ett allvarligt fel för soldaterna på vad hände är en Scud lansering var detekteras genom tidig varning satelliter och de visste att Scud var kommer i sin allmänna riktning. De visste inte var det var på väg. 

-Det Var nu upp till radarn komponent i Patriot-systemet försvara Dhahran att lokalisera och hålla koll på inkommande fientliga missiler. 

-Den Radar var mycket smart. Det skulle faktiskt spåra positionen av Scud, och sedan förutsäga var det förmodligen skulle bli nästa gång radarn skickas en puls ut. Som kallades en avståndsfålla. 

-Då, När Patriot beslutar tillräckligt med tid har passerade att gå tillbaka och kontrollera nästa Platsen för denna detekterade objektet, det går tillbaka. Så när det gick tillbaka till fel plats, då ser det inget objekt. Och det beslutar att det inte fanns någon objekt, var det en falsk detektering, och droppar spåret. 

-Den Inkommande Scud försvann från radarskärmen. Och sekunder senare, det smällde in i baracker. Den Scud dödade 28, och var den sista en sköt under det första Gulfkriget. 

Tragiskt nog, den uppdaterade programvaran anlände till Dhahran följande dag. Programvaran fel hade varit fast, stängning ett kapitel i den oroliga historia Patriot missil. 

[VIDEOUPPSPELNING] DAVID J. MALAN: Så detta är allt för säger att dessa frågor av spill och vaghet är alltför verkliga. Så hur kom vi hit? Vi började med att bara prata om printf. Återigen, den här funktionen som skriver något på skärmen, och vi införde därefter några andra funktioner från den så kallade CS50 bibliotek. Och vi kommer att fortsätta att se dessa i sinom tid. Och vi, i synnerhet, används get sträng, och få int, och nu också få flyta, och ytterligare andra kommer fortfarande att vi möter och använda oss snart. 

Men ibland, har vi redan sett ett behov att lagra vad dessa funktioner handen tillbaka? De lämnar oss tillbaka en sträng, eller en int eller en flottör. Och ibland måste vi sätta det sträng, eller int eller float, någonstans. 

Och lagra dessa saker, minns bara som i Scratch, har vi variabler. Men till skillnad från i Scratch, i C vi har typerna av variables-- uppgifter typer, mera generally-- bland dem, en sträng, en int en flyta, och dessa andra fortfarande. 

Och så när vi deklarerar variabler i C, vi måste förklara våra datatyper. Detta är inte något vi ska måste göra senare i terminen som vi övergången till andra språk. Men nu behöver vi till a priori i förväg, förklara till datorn vilken typ variabel vi vill att det ska ge oss. 

Nu, under tiden, för att skriva ut dessa typer av datatyper, Vi måste tala om printf vad som väntar. Och vi såg procent s för strängar, och procent i för heltal, och några andra redan. Och de är helt enkelt krav för visuell presentation av denna information. 

Och var och en av dessa kan faktiskt vara parametrized eller fixade på något sätt, Om du vill att ytterligare kontroll den typ av produktion som du får. Och i själva verket visar det sig att det inte bara är det omvända sned n för en ny rad. Det finns något annat som kallas backslash r för en vagnretur, som är mer besläktad med en old school skrivmaskin, och även Windows använts under många år. 

Det finns bakåtstreck t för flikar. Det visade sig, att om du vill dubbla citattecken inne i en sträng, Minns att vi har använt dubbla citat dubbel citationstecken på vänster och höger ändarna av våra strängar hittills. Som verkar för att förvirra saker. 

Om du vill lägga en dubbel citat i mitt i en string-- och, faktiskt, Det är förvirrande att se. Och så du måste fly, så att tala, en dubbel citat med något som, bokstavligen, bakstreck citat. Och det finns några andra fortfarande. Och vi kommer att se mer av dem vid verklig användning inom kort. 

Så låt oss nu övergå från data och representation, och aritmetiska operatorer, alla varav gav oss några byggnad block som man kan spela. Men nu ska vi faktiskt ge oss resten av vokabulären att vi redan hade förra veckan med Scratch genom att ta en titt på några andra konstruktioner i C- inte alla av dem. Men de idéer som vi är på väg att se egentligen bara att betona översättning från ett språk, Scratch, till en annan, C. 

Och under tiden kommer vi plocka upp fler verktyg för vår verktygslåda, så att säga, syntaktiskt. Och faktiskt, ser du att de idéer är nu ganska bekant från förra veckan. Så låt oss göra detta. 

Låt oss gå vidare och piska upp ett program som faktiskt använder vissa uttryck, ett booleskt uttryck. Låt mig gå vidare här och skapa en ny fil. Jag kallar detta condition.c. 

Låt mig gå vidare och inkludera CS50 biblioteket. Och låt mig gå vidare och inkludera standard io.h för våra funktioner, och printf och mer respektive. Låt mig ge mig själv att text av int main tomrum, vars förklaring vi ska komma tillbaka till i framtiden. 

Låt mig nu gå vidare och ge själv en int via get int. Låt mig gå vidare och göra det. Jag vill säga om jag är less-- låt oss skilja mellan positiv, negativ, eller nollvärden. 

Så om jag är mindre än noll, låt mig bara har detta program helt enkelt säga, negativ, omvänt snedstreck n, annars om i är större än noll. Nu är jag naturligtvis kommer att säga printf positiv, omvänt snedstreck n. Och då annars if-- jag kunde göra detta. 

Jag skulle kunna göra om jag är lika med 0. Men jag skulle göra på minst ett misstag redan. Minns att likhetstecknet är inte lika, eftersom vi människor vet det. 

Men det är uppdraget operatör. Och vi vill inte ta 0 på höger och placerade den i i till vänster. Så för att undvika förvirring, eller kanske missbruk av likhetstecknet, människor beslutade för några år sedan att i många programmeringsspråk när du vill kontrollera för jämställdhet mellan vänster och höger, du faktiskt använder lika jämlikar. Så du träffa likhetstecknet två gånger. När du vill tilldela från höger till vänster, använder du en enda likhetstecken. Så vi kunde göra this-- annat om jag är lika är lika med noll. 

Jag kunde gå och öppna mina klammerparenteser, och säga, printf 0, bakstreck n, gjort. Men kom ihåg hur dessa gafflar i vägen kan fungera. Och egentligen, bara tänka på logik. i är ett tal. Det är ett heltal, specifikt. Och det betyder att det kommer att bli mindre än 0 eller större än 0, eller 0. Så det är typ av detta underförstådd normalfallet. 

Och så vi kunde, precis som Scratch, avstå från else if, och bara säga annat. Logiskt, om du programmerare vet att det finns bara tre skopor i vilken en scenario kan fall-- den första, den andra, eller den tredje i detta case-- inte bry lägga till ytterligare precision och den ytterligare logiken där. Bara gå vidare med normalfallet här om annat. 

Nu ska vi gå vidare efter att ha sparat detta gör betingelser dot slash conditions-- inte en stor användargränssnitt, eftersom jag inte föranledde användare, som jag nämnde tidigare. Men det är bra. Vi kommer att hålla det enkelt. Låt oss försöka nummer 42. Och det är positivt. Låt oss försöka antalet negativ 42, negativt. 

Låt oss försöka värdet 0. Och faktiskt, det fungerar. Nu ser du med problem innan långa test saker tre gånger, förmodligen inte tillräckliga. Du vill förmodligen testa några större siffror, några mindre siffror, några hörn fall, som vi kommer att beskriva dem. 

Men nu, är detta en ganska enkelt program. Och jag är ganska säker, logiskt, att den faller i tre fall. Och faktiskt, trots att vi bara fokuserade på de potentiella nackdelar av brist på precision och spill, i verklighet där många av CS50 problem, Vi kommer inte att oroa om, hela tiden, dessa frågor av spill och imprecision, därför att, i själva verket, i C, det är faktiskt inte så lätt att undvika dessa saker. Om du vill räkna upp större, och större, och större, Det visar sig att det finns tekniker som du kan använda, ofta med saker som kallas bibliotek, samlingar av kod, som andra människor skrev att du kan använda, och andra språk som Java och andra, faktiskt göra det mycket lättare att räkna ännu högre. Så det är verkligen en del av dessa faror en funktion av det språk du använder. Och under de kommande veckorna kommer vi se hur farligt C verkligen kan vara om du inte använder den på rätt sätt. Men därifrån, och med Python och JavaScript kommer Vi lager på några ytterligare skydd, och köra färre av dessa risker. 

Så låt oss göra lite mer intressant logik i vårt program. Så låt mig gå vidare och skapa ett program som kallas Logical bara så att jag kan spela med några faktiska logik, logical.c. Jag ska bara kopiera och klistra in några kod från tidigare så jag kommer tillbaka till denna fina utgångspunkten. 

Låt mig den här gången göra char C. jag kommer att ge den ett namn C bara för att det är konventionellt, får ett tecken från användaren. Och låt oss låtsas som Jag genomföra en del av det Rm program, ta bort programmet innan det meddelade användaren för att ta bort en fil. Hur kan vi göra detta? 

Jag vill säga, om C är lika med lika, citationstecken unquote, y, då jag kommer att anta att användaren har valt ja. Jag kommer bara att skriva ut ja. Om det faktiskt skriva borttagning programmet, vi kunde ta bort filen med fler rader kod. Men vi kommer att hålla det enkelt. 

Annars om c är lika med lika n-- och nu här, jag kommer att säga, användaren måste ha inneburit någon. Och då annars, vet du vad? Jag vet inte vad användaren kommer att skriva. Så jag ska bara säga att det är ett fel, oavsett han eller hon faktiskt skrivit. 

Så vad händer här? Det finns en grundläggande skillnad kontra vad jag har gjort tidigare. Citationstecken, citationstecken, dubbel citat, och ändå enkla citationstecken, apostrof. Det visar sig i C, att när du vill skriva en sträng, du använder citationstecken, precis som vi har använt hela tiden med printf. 

Men om du vill ta itu med bara en enstaka tecken, en så kallad röding, då du faktiskt använder apostrof. De av er som har programmerat innan, kanske du inte har var tvungen att oroa sig för detta åtskillnad på vissa språk. I C, spelar det någon roll. Och så när jag får en röding och jag vill att jämföra det röding med hjälp av jämlikar lika med några brev som y eller n, gör jag, faktiskt måste ha enkla citattecken. 

Nu ska vi gå vidare och göra det. Låt oss gå vidare och gör logiska dot slash logiskt. Och nu är jag som efterfrågas. Så, förmodligen, en bättre användarupplevelse skulle faktiskt säga vad jag ska göra här. Men jag ska bara blint säger y för ja, OK, trevligt. 

Låt oss köra den igen, n för nej, trevlig. Antag som vissa människor jag känner, mina skiftlåstangenten på alltför ofta. Så jag gör huvudstad Y anger, fel. OK, det är inte precis vad jag förväntat mig. Faktum är att datorn gör bokstavligen vad Jag sa det till do-- leta efter gemener y och gemener n. Detta känns inte som bra användarupplevelse, men. Låt mig be om och ta emot antingen gemener eller versaler. Så visar det sig, kanske du vill att säga något i stil i Scratch, som bokstavligt eller C är lika med lika kapital enda noterade y. Det visade sig, inte C inte har detta bokstav sökord eller. 

Men det har två vertikala streck. Du måste hålla Shift vanligtvis Om du använder ett amerikanskt tangentbord, och slog det lodräta strecket nyckel ovanför returtangenten. Men denna lodrätt streck vertikalt streck betyder eller. 

Om däremot, vi ville att säga och liksom i Scratch, vi kunde göra-tecken et-tecken. Det gör ingen logisk mening här, eftersom en människa kunde omöjligen har skrivit både y och gemener y och kapital Y som samma karaktär. Så eller är vad vi tänker här. 

Så om jag gör det på båda ställena, eller c lika är lika huvudstad N, nu kör, göra logiska, kör logiskt. Nu kan jag skriva y. Och jag kan göra det igen med huvudstad Y, eller kapital N. Och jag skulle kunna lägga till ytterligare kombinationer fortfarande. 

Så det här är en logisk program i den mån nu Jag kollar logiskt för detta värde eller detta värde. Och jag behöver inte nödvändigtvis komma upp med ytterligare två IFS eller annars IFS. Jag kan faktiskt kombinera några av de relaterade logik tillsammans på detta sätt. Så det skulle vara bättre utformad än att bara sade om C är lika med gemener y, ut ja, annars om c är lika med kapital Y, ut ja, annars om c är lika med lower-- med andra ord, du behöver inte ha fler och fler grenar. Du kan kombinera några av motsvarande grenar logiskt, som på detta sätt. 

Så låt oss ta en titt på bara ett sista ingrediensen, ett slutliga konstruktionen, att C tillåter. Och vi kommer att komma tillbaka i framtid till andra fortfarande. Och då kommer vi konstatera genom att titta på inte riktigheten av code-- att få koden att work-- men designen kod, och plantera dessa frön tidigt. 

Så låt mig gå vidare och öppna upp en ny fil här. Vet du vad? Jag kommer att åter genomföra samma program, men med användning av en annan konstruktion. 

Så låt mig snabbt ge mig tillgång till inkluderar CS50.h för CS50 biblioteket standard io.h för printf. Ge mig min int main tomrum. Och sedan över här, låt mig gå vidare och göra det. 

Char c blir få röding, precis som förut. Och jag kommer att använda en ny konstruktion now-- slå på vilken karaktär? Så switch är ungefär som växla ett tåg spår. Eller, egentligen, är det slags ett om annat, om else if, men skriven något annorlunda. 

En omkopplare ser ut så här. Du har switch, och sedan vad tecken eller nummer som du vill titta på, sedan några klammerparenteser som i Scratch, bara säga göra det här. Och så har du olika fall. 

Du behöver inte använda om och annat. Du använder bokstavligen ordet fallet. Och du skulle säga något sådant. 

Så i fallet med ett gement y, eller i fallet med en kapital Y, gå vidare och skriva ut ja. Och sedan bryta ut av omkopplaren. Det är allt. Var gjort. 

Else if, så att säga, gemener n, eller huvudstad N, sedan gå vidare och skriva ut ut nej, och sedan bryta. Else-- och denna typ av är den default case indeed-- printf error-- och bara för bra åtgärd, men logiskt denna brytning är inte nödvändigt eftersom vi är i slutet av omkopplaren i alla fall, Jag är nu bryta sig ur växeln. Så här ser lite annorlunda. 

Men logiskt är det faktiskt motsvarande. Och varför skulle du använda ovanpå varandra? Ibland, bara personliga preferenser, ibland estetik, om jag blick på denna nu, det finns något sägas för läsbarhet av denna kod. Jag menar, never mind det faktum att detta kod är nytt för många av oss i rummet. 

Men det är bara typ av är ganska. Du ser gemener y, huvudstad Y, gemener n, huvudstad N standard det bara typ av hopp ut på dig på ett sätt att, utan tvekan, kanske det tidigare exemplet med ifs, och de vertikala staplarna, och else IFS, kanske inte har. Så det här är verkligen en fråga om personlig val, verkligen, eller läsbarhet, av koden. 

Men när det gäller funktionalitet, låt mig gå vidare och göra en switch, pricka snedstreck switch, och nu skriva med gemener y, huvudstad Y, gemener n, huvudstad N, David, försöka igen eftersom det är inte ett enda tecken. Låt oss göra x, fel, som förväntat. Och logically-- och detta är något Jag skulle uppmuntra general-- även även om vi bara repa yta av några av dessa funktioner. 

Och det kanske inte är uppenbart när du själv sitta vid tangentbordet, hur fungerar detta? Vad skulle det göra? Den vackra sak om att ha en bärbar eller stationär, eller tillgång till en dator med en kompilator, och med en kod redaktör som denna, är du nästan alltid besvara dessa frågor för dig själv bara genom att försöka. 

Till exempel, om det retoriska fråga till hands var, vad händer om du glömmer din bryta uttalanden? Som egentligen är en mycket vanlig sak att göra, eftersom det inte ser som du verkligen behöver dem. De vet inte riktigt slutföra tänkte som en parentes eller en lockig stag gör. Låt oss gå vidare och kompilera koden och se. Så gör switch, dot slash switch. Låt oss skriva in gemener y, den översta fallet, Enter. Så jag skrev y. 

Programmet sade ja, nej, fel, som om det var ändra uppfattning. Men det slags var, eftersom det händer med en switch är det första fallet som match innebär i huvudsak, hej dator, verkställa all kod under den. Och om du inte säger paus, eller säg inte bryta, eller inte säga paus, datorn kommer att blåsa genom alla dessa linjer och utföra alla dem tills det blir till att klammerparentes. Så bromsarna är verkligen nödvändigt. Men en takeaway här är, när osäker, prova något. Kanske spara koden först, eller spara den i en extra fil om du verkligen orolig stöka och med att återhämta sig det arbete som du vet fungerar. 

Men prova saker. Och inte vara så rädd, kanske, av vad datorn kan göra, eller att du kan bryta något. Du kan alltid återgå till någon tidigare version. 

Så låt oss avsluta genom att titta vid utformningen av koden. Vi har denna förmåga nu att skriva villkor och skriv loopar, och variabler och samtalsfunktioner. Så ärligt talat, vi är typ av tillbaka på där vi var för en vecka sedan med Scratch, om än med en mindre övertygande text miljö än Scratch tillåter. 

Men märker hur snabbt vi har förvärvat att vokabulär, även om det är kommer att ta ett tag att sjunka in, så att vi nu kan använda denna vokabulär att skriva mer intressanta program. Och låt oss ta en baby steg mot det, enligt följande. Låt mig gå vidare och skapa en ny fil här. 

Jag kommer att kalla detta prototype.c, och införa för första gången, förmågan att göra egna funktioner. Några av er kanske har gjort detta med Scratch, där du kan skapa din egna anpassade block i Scratch, och sedan dra dem på plats varhelst du vill i C. Och i de flesta programmering språk, kan du göra exakt that-- göra egna funktioner, om de inte redan finns. 

Så, till exempel, låt mig gå vidare och innefattar CS50.h, och innefattar standard io.h, int main tomrum. Och nu har vi en placeholder redo att gå. Jag håller tryck saker som personers namn idag. Och det känns like-- skulle inte vara trevligt om det var en funktion som kallas utskrifts namn? Jag behöver inte använda printf. Jag behöver inte komma ihåg alla formatkoder. Varför inte jag, eller varför inte någon före mig, skapa en funktion som kallas print namn, som ges något namn, helt enkelt skriver ut? 

Med andra ord, om jag säger hej, dator, ge mig en sträng genom att be användaren om ett sådant, via CS50: s get sträng funktion. Hej, dator, lägga den sträng i variabeln i den vänstra sidan, och kallar det är. Och då, hej dator, gå vidare och skriva ut den personens namn, gjort. 

Nu skulle det vara trevligt, eftersom detta program, passande namnet, berättar vad det är tänkt att göra med hjälp av de funktionens namn. Låt mig gå och göra prototyp, Enter. Och, tyvärr, Detta kommer inte att flyga. 

Prototype.c, linje 7, tecken 5, fel, implicit deklaration Funktions print namn är ogiltig i C99, C99 innebärande en version av C som kom ut 1999. Det är allt. 

Så jag vet inte vad Allt detta innebär ännu. Men jag känner igen fel i rött. Det är ganska uppenbart. 

Och det verkar som med den gröna karaktär här, problemet är med tryck namn, öppna Paren s, nära Paren, semikolon. Men underförstått förklaring funktion vi såg i korthet tidigare. Detta innebär helt enkelt, att Clang inte vet vad jag menar. 

Jag har använt ett ordförråd ord som det är aldrig sett eller undervisats tidigare. Och så jag måste lära den vad denna funktion innebär. Så jag kommer att gå vidare och göra det. 

Jag kommer att gå vidare och genomföra min egen funktion som kallas ut namn. Och jag kommer att säga, enligt följande, som det gör det, printf, hej, procent s, bakstreck n, namn, semikolon. Så vad gjorde jag göra? 

Så visar det sig, att implementera egen funktion, vi typ av låna några av samma struktur som huvud att vi bara har varit tas för givet, och jag vet bara att kopiera och klistra ganska mycket vad Jag har skrivit tidigare. Men märker mönster här. Int, Main, Void, vi retas isär snart vad det egentligen betyder. 

Men i dag, bara märka parallellism. Void, tryck namn, string namn, så det finns en lila sökord, vilket Vi ska börja ringer en returtyp, namnet på funktionen, och sedan ingången. Så egentligen kan vi destillera denna typ av som förra veckan som är det namn eller algoritm av koden vi kommer att write-- den algoritmen som är grunden koden vi ska skriva. 

Detta är dess ingång. Detta är dess utgång. Denna funktion, tryck namn, är utformad för att ta en sträng som kallas namn, eller vad som helst, som indata, och sedan tomrum. Det inte tillbaka något, som får sträng eller få int gör. Så det kommer att ge mig något tillbaka. Det kommer bara att ha en bieffekt, så att säga, att skriva en persons namn. Så märker, linje 7, jag kan ringa utskriftsnamn. Linje 10, kan jag definiera eller genomföra utskriftsnamn. Men tyvärr, det är inte tillräckligt. 

Låt mig gå vidare och kompilera detta efter att ha sparat. Whoa, nu, jag har gjort det värre, verkar det. Så implicit deklaration av Funktionen print namn är ogiltigt. Och, återigen, det finns fler fel. Men som jag varnade tidigare även om du får överväldigad med, eller lite sorgligt att se så många fel, bara fokusera på den första initialt, eftersom det kanske bara har haft en kaskadeffekt. Så C eller Clang mer specifikt, fortfarande inte känner igen utskriftsnamn. 

Och det beror på klang, genom design, är ganska dum. Det gör bara vad du säger den att göra. Och det bara gör det i den ordning där du berättar det att göra. 

Så jag har definierat huvud på linje fyra, som vi har gjort ganska ofta. Jag har definierat utskrifts namn på rad 10. Men jag försöker att använda print namn på rad sju. 

Det är för tidigt, inte finns ännu. Så jag kunde vara smart, och vara som, OK, så låt oss bara spela tillsammans, och flytta utskrifts namn upp här och åter kompilera. Herregud. Det fungerade. Det var så enkelt är det. 

Men logiken är just detta. Du måste lära klang vad det är genom att definiera funktionen först. Sedan kan du använda den. Men, ärligt talat, känns detta som en hal backe. 

Så varje gång jag kör i ett problem, jag är bara kommer att markera och kopiera koden Jag skrev, skär den och klistra in den här. Och säkert, vi kunde contrive vissa scenarier där en funktion kanske behöver ringa en annan. Och du bara inte kan sätta alla funktion över alla andra. 

Så visar det sig att det finns en bättre lösning. Vi kan lämna detta vara. Och, ärligt talat, är det allmänt trevligt, och bekvämt, och god design att sätta huvud först, eftersom, återigen, Huvud precis som när grön flagg klickade, som är den funktion som blir verk som standard. Så du kan lika gärna sätta den när upp i filen så att när du eller någon annan människa ser på filen du vet vad som händer bara genom att läsa huvud först. Så visar det sig, kan vi tala om klang proaktivt, hej, klang, på linje fyra, Jag lovar att genomföra en funktion som kallas Print Namn som tar en sträng som kallas namn som indata och returnerar ingenting, tomrum. Och jag ska komma runt till genomföra den senare. 

Här kommer Main. Huvud nu på rad 9 kan använda Skriv namn eftersom klang är litar på att så småningom, det kommer att stöta definitionen genomförandet av Print namn. Så efter att ha sparat min fil, låt mig gå vidare och göra prototyp, ser bra denna gång. Dot snedstreck, prototyp, låt mig gå vidare och skriva in ett namn. David, hej David, Zamila, hej Zamila, och, faktiskt, nu fungerar. 

Så ingrediensen här är att vi har gjorde en anpassad funktion, som en anpassad Scratch blocket vi kallar det. Men till skillnad från Scratch där du kan bara skapa det och börja använda den, Nu måste vi vara en lite mer pedantisk, och faktiskt utbilda Clang att använda, eller att förvänta sig det. Nu, som en sidoreplik, varför hela tiden har vi varit bara blint på tro inklusive CS50.h, och med standard io.h? 

Tja, det visar sig, bland några andra saker, allt som är i dem dot h filer, som råkar vara filer. De är header filer, så att säga. De är fortfarande skrivet i C. Men de är en annan typ av fil. 

För nu kan du ganska mycket antar att allt som är inne i CS50.h är några one-liners som denna, inte för funktioner som kallas ut namn, men för Get String, Get Float, och några andra. Och det finns liknande prototyper, eyeliner, insidan av standard io.h för printf, som nu är i min egen Print Namn funktion. Så med andra ord, hela tiden vi har just blint kopiera och klistra in inkludera denna, inkluderar att vad som händer? De är bara typ av ledtrådar att klang vad funktioner är verkligen genomförs, precis på andra ställen i olika filer på andra ställen i systemet. 

Så vi har implementerat utskriftsnamn. Det har denna bieffekt av utskrift något på skärmen. Men det gör faktiskt inte ge mig något tillbaka. Hur ska vi gå tillväga genomföra ett program som inte ge mig något tillbaka? 

Nåväl, låt oss försöka detta. Låt mig gå vidare och genomföra en fil som heter return.c så att vi kan visa hur något gillar Få String, eller hämta Int, är faktiskt återvänder något tillbaka till användaren. Låt oss gå vidare och definiera int main tomrum. 

Och, igen, i framtiden kommer vi förklara vad som int och det tomrum är faktiskt gör. Men för idag, vi ska ta det för givet. Jag kommer att gå vidare och printf, för en bra användarupplevelse, är x. Och då kommer jag att vänta på användaren att ge mig x med get int. 

Och då kommer jag att gå vidare och skriva ut x till torget. Så när du bara har en tangentbord, människor vanligen använda den lilla morot symbol på tangentbordet att representera strömmen av, eller exponent av. Så xi kvadrat är närvarande i. 

Och nu ska jag göra detta. Jag kunde bara do-- vad är x kvadrat? x kvadrat är x gånger x. 

Och vi gjorde detta några tid sedan redan idag. Detta känns inte som så mycket framsteg. Vet du vad? Låt oss utnyttja en del av denna idé från förra gången av abstraktion. 

Skulle det inte vara trevligt om Det finns en funktion som kallas torg som gör just detta? Det fortfarande, i slutet av den dag, gör samma matematik. Men låt oss abstrakt bort tanken på att ett antal multiplicerat med en annan, och bara ge den ett namn, som square detta värde. 

Och, med andra ord, i C, låt oss skapa en funktion kallas torg som gör just detta. Det kommer att kallas kvadrat. Det kommer att ta en int. Och vi kommer kommer bara kalla det n som standard. 

Men vi kan kalla det vad vi vill. Och allt som det kommer att göra, bokstavligen, är avkastningen resultatet av n gånger n. Men eftersom det är tillbaka något, vilket är nyckelordet i lila vi har aldrig sett förut, jag, på linje 11, kan inte bara säga ogiltig den här gången. 

Void, i exemplet vi såg bara snarare utskrifts namn betyder just, göra någonting. Men inte ge mig något tillbaka. I det här fallet vill jag för att gå tillbaka n gånger n, eller vad det nu är, det numret. 

Så jag kan inte säga, hej, dator, Jag åter ingenting, tomrum. Det kommer att återvända till sin natur en int. Och så det är allt som händer här. 

Ingången till ruta kommer att bli en int. Och så att vi kan använda det, måste det har ett namn, N. Det kommer att mata en int som inte behöver ett namn. Vi kan lämna det till huvud, eller vem är använder mig att komma ihåg detta värde om vi vill med sin egen variabel. 

Och, återigen, det enda nya nyckelord här är Return. Och jag bara göra lite matte. Om jag ville verkligen vara onödigt, Jag kunde säga int produkt blir n gånger n. 

Och då kunde jag säga, tillbaka produkten. Men, återigen, min poäng tidigare av detta bara inte är bra design-- Liksom, varför införa ett namn, en symbol, som produkt, bara för att omedelbart återlämna det? Det är en lite renare, lite hårdare, så att tala, bara för att säga retur n gånger n, bli av med denna linje helt och hållet. 

Och det är bara mindre kod för att läsa, mindre möjlighet för misstag. Och låt oss se om detta faktiskt fungerar nu. Nu, jag kommer att gå framåt och göra retur. 

Uh-oh, implicit deklaration av funktionen. Jag gjorde detta misstag innan, no big deal. Låt mig bara skriva, eller markera och kopiera, exakt samma prototyp funktion, eller underskrift av funktionen upp här. Eller jag kunde flytta hela funktionen. 

Men det är lite lat. Så vi inte kommer att göra det. Nu, låt mig göra retur igen, dot snedstreck avkastning. 

x 2. xi kvadrat är fyra. x 3. xi kvadrat är nio. Och funktionen verkar nu att arbeta. Så vad är skillnaden här? Jag har en funktion som kallas torg, i det här fallet, som jag lade i en ingång. Och jag får tillbaka en utgång. Och ändå, tidigare, om Jag öppnar det andra exemplet från tidigare, vilket kallades prototype.c, Jag hade utskriftsnamn, som åter tomrum, så att säga, Eller det återvände ingenting, och helt enkelt hade en bieffekt. 

Så vad händer här? Tja, anser funktionen få sträng för ett ögonblick. Vi har använt funktionen hämta sträng på följande sätt. 

Vi har haft en funktion får sträng, som innefattar CS50.h, inkluderar standard io.h, int, huvudsakligt, tomrum. Och sedan varje gång jag har kallad få sträng hittills, Jag har sagt något i stil med sträng s blir få sträng, eftersom få string-- låt oss kalla detta get.c-- get sträng själv returnerar en sträng som jag kan sedan använda och säga, hej, kommatecken, procent s, omvänt snedstreck n, s. 

Så detta är samma exempel, verkligen att vi hade tidigare. Så får sträng returnerar ett värde. Men en stund sedan, tryck sträng inte returnera ett värde. Det har helt enkelt en bieffekt. Så detta är en fundamental skillnad. Vi har sett olika typer av funktioner nu, varav en del har återvänt värden, av vilka vissa inte gör det. Så kanske det är sträng, eller int eller float. Eller kanske är det bara ogiltig. 

Och skillnaden är att dessa funktioner som hämta data och returnera ett värde faktiskt föra något tillbaka till bordet, så att säga. Så låt oss gå vidare och titta på en slutlig uppsättning exempel som ger en känsla, nu, om hur vi kanske faktiskt abstrakt bättre, och bättre, och bättre, eller mer, och mer och mer, i syfte att skriva, i slutändan, bättre kod. Låt oss gå vidare, och i en anda av Scratch, gör följande. 

Låt mig gå vidare och inkludera CS50.h och standard IO.h. Låt mig gå vidare och ge själv en int, huvudsakligt, tomrum. Och låt mig gå vidare, kalla detta cough.c. 

Och låt mig gå vidare och bara som Scratch, skriva ut hosta / n. Och jag vill göra detta tre gånger. Så jag naturligtvis bara gå att kopiera och klistra in tre gånger. Jag kommer nu att göra hosta dot slash hosta. Låt oss ge mig lite mer utrymme här, Enter, hosta, hosta, hosta. 

Det finns, naturligtvis, redan en möjlighet till förbättring. Jag har kopierat och klistrat ett par gånger i dag. Men det var bara så jag inte måste skriva så många tecken. Jag fortfarande ändrat vad dessa rader kod är. 

Dessa tre linjer är identiska, vilket känns lat och faktiskt är, och är förmodligen inte rätt metod. Så vad ingrediens kan vi förbättra denna kod? Vi behöver inte kopiera och klistra in koden. 

Och faktiskt, varje gång du känner själv kopiera och klistra in, och inte ens ändra kod, oddsen är att det finns ett bättre sätt. Och, ja, det finns. Låt mig gå vidare och göra en for-loop, trots att syntaxen kanske inte kommer naturligtvis ännu. 

Gör detta tre gånger, helt enkelt genom att göra den following-- och jag råkar veta detta från praktiken. Men vi har ett antal exempel nu. Och du ser på nätet fler referenser fortfarande. 

Detta är syntaxen på linje 6, som ungefär som Scratch som upprepas blocket, upprepa följande tre gånger. Det är en liten magisk nu. Men detta kommer att få mer, och mer bekant. 

Och det kommer att upprepa linjen åtta tre gånger, så att om jag åter sammanställa make hosta, dot slash hosta, hosta, hosta, hosta. Den fungerar fortfarande på samma sätt. Så det är alla fina och bra. Men det är inte mycket abstraherade. 

Det är helt korrekt. Men det känns som om det skulle kunna vara en möjlighet, som i världen av Scratch, till typ av start att lägga till några semantik här så att Jag har inte bara en del för slinga, och en funktion som säger hosta, eller inte hosta. Vet du vad? Låt mig försöka vara en lite svalare än så, och faktiskt skriva en funktion som har vissa biverkningar, kalla det hosta. 

Och det tar ingen ingång, och returnerar inget värde som produktion. Men vet du vad det gör? Det gör this-- printf, citat unquote, hosta. 

Och nu upp här, kommer jag att gå vidare och för int, Jag blir noll, i mindre än tre, i plus plus. Jag ska inte göra printf, som är utan tvekan en implementering låg nivå detalj. Jag bryr mig inte hur man hosta. Jag vill bara använda hosta funktionen. Och jag ska bara ringa hosta. 

Nu märker dikotomi. När du ringer en funktion, om du inte vill ge det ingångar, helt bra. Gör öppna Paren, nära Paren, och du är klar. 

När du definierar en funktion, eller deklarera en funktion prototyp, Om du vet i förväg är det inte kommer att ta några argument, säger tomrum i dessa parenteser där. Och det gör säker på att du inte av misstag missbruka det. Låt mig gå vidare och göra hosta. Och, naturligtvis, har jag gjort ett misstag. 

Helvete, det är det implicit deklaration. Men det är bra. Det är en enkel fix. Jag behöver bara en prototyp högre upp i min fil än jag faktiskt använder det. 

Så nu vill jag göra hosta igen, trevlig. Nu fungerar det. Gör hosta, hosta, hosta, hosta. Så du kanske tror att vi är riktigt drygt engineering detta problem. Och faktiskt, vi är. Detta är inte en bra kandidat för ett program just nu för refactoring, och gör vad som är kallad hierarkisk nedbrytning, där du tar lite kod, och sedan du typ av faktor saker ut, så som att tillskriva fler semantik till dem, och återanvända det i slutändan längre sikt. Men det är en byggsten mot mer sofistikerade program att vi kommer att börja skriver inom kort att tillåter oss att ha ordförråd som man kan skriva bättre kod. Och faktiskt, låt oss se om vi kan inte generalisera detta ytterligare. 

Det verkar lite lam som jag, huvudsakligt, behöver oroa dig för detta darn för slinga, och ringer hosta och om igen. Varför kan jag inte säga just hosta, vänligen hosta tre gånger? Med andra ord, varför kan inte jag bara ge bidrag till hosta och göra detta? 

Varför kan inte jag bara säga, i Huvud hosta tre gånger. Och nu är den här typen av magiska. Det är väldigt iterativ här. Och det är faktiskt en baby steg. 

Men bara möjligheten att säga om linjen åtta, hosta tre gånger, det är bara så mycket mer lättläst. Och plus, jag behöver inte veta eller bryr sig om hur hosta genomförs. Och faktiskt, senare i sikt och för slutprojekt, Om du ta itu med ett projekt med en klasskamrat eller två klasskamrater, kommer du att inse att du kommer att måste, eller vill, dela upp arbetet. 

Och du kommer att vilja bestämma i förväg, som kommer att göra vad, och i vilka delar? Och skulle det inte vara trevligt om du till exempel, ta hand om skrivhuvud, gjort. Och din kamrat, eller din partner mer generellt, tar hand om genomförandet av hosta. 

Och denna uppdelning, dessa väggar av abstraktion, eller lager av abstraktion förekommande du kommer är super kraftfull, eftersom i synnerhet för större, mer komplexa program och system, Det gör att flera personer att bygga saker tillsammans, och slutligen sy sitt arbete tillsammans på det här sättet. Men, naturligtvis, vi måste nu rätta hosta. Vi måste tala om hosta att hej, vet du vad? Du kommer att behöva ta en input-- så inte ogiltig, men int och nu. Låt oss gå vidare och sätta in hosta int. Jag blir noll. 

i är mindre än hur många gånger. Jag sa tre innan. Men det är inte vad jag vill. Jag vill hosta att generaliseras till stödja vilket som helst antal iterationer. 

Så, ja, det är n som jag vill, vad användaren säger. Nu kan jag gå vidare och säga utskrifts hosta. Och oavsett hur många användaren passerar, Jag kommer att upprepa det många gånger. 

Så i slutet av dagen, Programmet är identiska. Men märker allt det här kan även vara i en annan fil. I själva verket vet jag inte på ögonblick hur printf genomförs. 

Jag vet inte just nu hur får sträng, eller få int, eller få flyta genomförs. Och jag vill inte se dem på min skärm. Som det är, jag börjar att fokusera på mitt program, inte dessa funktioner. 

Och så, ja, så fort du börja facto kod som detta, kunde vi flytta även hosta till en separat fil? Någon annan skulle kunna genomföra det. Och du och ditt program blir det mycket vacker, och mycket läsvärd, utan tvekan, verkligen fyra line program direkt. 

Så låt oss gå vidare nu och göra en mer förändring. Lägg märke till att min prototyp måste förändras uppe. Så låt mig fixa det så Jag inte får skrek åt. 

Gör hosta, låt mig köra hosta gång mer, fortfarande gör samma sak. Men nu märker vi har en ingrediens för en slutlig version. Vet du vad? Jag vill inte bara hosta, nödvändigtvis. Jag vill ha något mer allmänt. Så du vet vad? Jag vill göra detta. Jag vill ha, mycket som Scratch gör, något att säga blocket, men inte bara säga något några antal gånger. Jag vill att det ska säga en mycket specifik sträng. Och därför gör jag inte vill att det ska bara säga hosta. Jag vill att det ska säga vad sträng ledes in. 

Så märker har jag generaliserat detta så att nu säg känns som ett bra namn för detta, som Scratch, tar två argument, till skillnad från Scratch. Den ena är en sträng. Den ena är en int. 

Och jag kunde byta dem. Jag ungefär som tanken på säga strängen först, och sedan hur många gånger senare. Void betyder det fortfarande inte tillbaka något. Dessa är bara visuella sidan effekter, som med [? Jordan,?] en verbal bieffekt av skrika. Det gör fortfarande något n gånger, 0 upp till, men inte lika med n. Detta innebär n totaltider. Och sedan bara skriva ut vad den strängen är. Så jag har verkligen gener denna kodrad. Så nu, hur använder jag hosta funktion? 

Jag kan göra void hosta. Och jag kan fortfarande ta in hur många gånger du vill hosta. Men vet du vad? Jag kan nu punt att säga. 

Jag kan ringa säga med Ordet hosta, passerar n. Och om jag vill också genomföra, bara för skojs skull, en nysning funktion, Jag kan nysa viss antal gånger. Och jag kan hålla åter n, eftersom märka att m i detta sammanhang eller omfattning endast existerar inom denna funktion. 

Och n i detta sammanhang endast existerar inom denna funktion här. Så vi kommer tillbaka till dessa frågor om räckvidd. Och här, jag kommer bara att säga, Achoo, och sedan n gånger, semikolon. 

Och nu, jag behöver bara låna dessa funktion signaturer upp här. Så hosta är korrekt. Void nysning är rätt nu. 

Och jag fortfarande behöver bara säga. Så jag kommer att säga, säg string s, int n, semikolon. Så jag har över iscensatte fan av detta program. 

Och detta inte nödvändigtvis är vad du ska göra när du skriver även den enklaste av program. Ta något som är självklart verkligen enkelt, riktigt kort, och åter genomföra den använder alldeles för mycket kod. Men du faktiskt se, och i tid ser tillbaka på dessa exempel, och inser, oh, det är de steg Vi tog faktiskt generalisera, faktor ut något, tills vid slutet av dagen min kod är faktiskt ganska rimlig. För om jag vill hosta tre gånger nys sedan tre gånger, Jag kommer helt enkelt att köra detta, Programmet gör hosta och köra hosta. Och jag har tre hosta och tre nysningar. 

Och så detta är en grundläggande paradigm, om man så vill, för hur vi kan gå om faktiskt genomföra ett program. Men låt oss bara se nu vad det är vi har gjort hela denna tid, och vad några av de slutliga bitarna ligger bakom denna enkla kommando. Vid slutet av dagen, vi har använt Clang som vår kompilator. Vi har skrivit källa kod, omvandla den via Clang till maskinkod. 

Och vi har använt Gör bara för att underlätta våra tangenttryckningar så att vi inte behöver komma ihåg dessa besvärjelsear av Clang självt. Men vad är Gör egentligen gör? Och i sin tur, vad som är Clang faktiskt gör? 

Det visar sig, även om vi har förenklat dagens diskussion genom att säga, du ta källkoden, skicka den som ingång till en kompilator, som ger dig utgången från maskinen kod, visar sig att det är några olika steg inuti det. Och sammanställa råkar vara paraplyet term för en massa steg. Men låt oss bara retas detta ut riktigt snabbt. 

Det visar sig att vi har gjort fler saker varje gång jag kör ett program, eller varje gång jag kompilera ett program i dag. Så förbehandling avser this-- något i ett C-program, som vi ser om och om igen, som börjar med denna hash symbol, eller hashtaggen symbolen här betyder Det är ett direktiv preprocessor. Det betyder i detta fall, hej dator, göra något med den här filen innan du faktiskt kompilera min egen kod. 

I det här fallet, hash inkluderar vill säga, i huvudsak, C: s sätt att säga, hej dator, gå och hämta innehållet av CS50.h och klistra in dem här. Hej dator, gå och hämta den Innehållet i standard io.h, överallt där det är på hårddisk, klistra in den här. Så dessa saker händer först under förbehandlingen. 

Och Clang gör allt detta för oss. Och det gör det så jäkla snabb, du behöver inte ens se fyra olika saker som händer. Men det är den första steget. 

Vad som egentligen händer härnäst? Tja, nästa officiella steg sammanställer. Och det visar sig att sammanställa ett program tekniskt innebär att gå från källkod, de saker som vi har skrivit i dag, något kallas assemblerkod, något som ser lite annorlunda. 

Och i själva verket kan vi se detta riktigt snabbt. Låt mig faktiskt gå in i min IDE. Låt mig gå vidare och öppna hej.c, som är det allra första program med vilket vi började idag. Och låt mig gå vidare och köra klang en lite annorlunda, klang-s, hej.c, som faktiskt kommer att ge mig en annan fil hello.s. 

Och vi kommer förmodligen aldrig igen se denna typ av kod. Om du tar en lägre nivå system av klass som CS61, du kommer att se en mycket mer av denna typ av kod. Men detta är assembler. Detta är X86 assembler att processorn som underliggande CS50 IDE faktiskt förstår. 

Och kryptiska som det gör se, det är något datorn förstår ganska bra. Sub q, detta är en subtrahera. Det finns rörelser. 

Det ringer funktioner här, x oring, en rörelse, ett tillägg, en pop, avkastning. Så det finns några mycket instruktioner låg nivå att processorer förstår att Jag hänvisade till tidigare. Det är vad Intel Inside. 

Det finns mönster av nollor och ettor som mappas till dessa arcanely formulerad, men något väl namnges, instruktioner, så att säga. Det är vad som händer när du kompilera koden. Du får montering språk av det, som betyder det tredje steget är att montera att assemblerkod i slutändan, maskin code-- nollor och ettor, inte text som vi såg bara en liten stund sedan. 

Så förbearbetning gör att hitta och byt ut, och några andra saker. Sammanställa tar din källa kod från C, källkod att vi skrev, till montering kod som vi bara såg på. Montering tar att monteringen kod till ettor och nollor att processorn verkligen kommer förstå i slutet av dagen. Och länkning är det sista steget det händer för oss-- igen, så fort vi inte ens notice-- som säger, hej dator, ta alla nollor och ettor som berodde på att sammanställa Davids kod, och hans huvudsakliga funktion i det här fallet. 

Och hey dator, gå och hämta alla nollor och ettor att CS50 personal skrev inne i CS50 biblioteket. Blanda dem in med Davids. Och hey dator, gå och hämta alla nollor och de som någon annan skrev år sedan för printf. Och lägga till dem i hela, så att vi har fick mina nollor och ettor, den CS50 personalens nollor och ettor, printf nollor och ettor, och allt annat vi använder. 

Alla får kombineras ihop till en program som kallas, i detta fall, hej. Så hädanefter kommer vi bara använda ordet sammanställningen. Och vi kommer att ta för givet att när vi säger, kompilera program, det betyder, hej gör förbehandling, montering, och länkning. Men det finns faktiskt några saftiga saker händer där under huven. Och speciellt om du få veta lite tid, du kan börja peta runt på denna lägre nivå. Men nu, inser att bland hämtställen för idag är helt enkelt i början av en process, att få bekväm med något liknande hello world. I själva verket de flesta av vad vi gjorde i dag säkerligen inte kommer att sjunka i supersnabb. Och det kommer att dröja tid och lite övning. Och oddsen är, kommer du sortera av vill träffa tangentbordet eller skrika på skärmen. Och allt detta är OK. Men kanske försöka att inte gör det i biblioteket så mycket. 

Och i slutändan kommer du Kunna dock att starta se mönster, både i bra kod att du har skrivit och misstag att du har gjort. Och likt processen för blir en TF eller en CA är, du börjar bli bättre och bättre på att se dessa mönster, och bara lösa ditt egna problem i slutändan. Under tiden kommer det att finnas gott av oss att ge dig stöd, och få dig genom detta. Och i uppskrivningar för alla de problem kommer du att guidas genom alla kommandon att jag vet säkert från en hel del övning nu, men kanske har flugit över huvudet för nu. Och det är helt bra. 

Men i slutändan, du kommer att börja se mönster växa fram. Och när du komma förbi alla dumma detaljer, som parenteser, och klamrar, och semikolon, och saker, ärligt talat, det är inte alls intellektuellt intressant. Och det är inte syftet med tar något inledande klass. Det är idéerna som kommer spela någon roll. 

Det är loopar, och villkor, och funktioner, och mer kraftfullt uttag, och factoring av koden, och god design, och den goda stil, och i slutändan riktigheten av din kod, det är i slutändan kommer att fråga mest. Så nästa vecka kommer vi att ta dessa idéer som vi först såg i Scratch och har nu översatts C. Och vi börjar att införa den första av kursens verkliga världen domäner. 

Vi ska fokusera på världen av säkerhet, och mer specifikt kryptografi, konsten att förvrängningsinformation. Och bland de första problem man själv kommer att få skriva längre leker med några av syntaxen och lösa några logiska problem i slutändan snart, är att faktiskt klättra, eller kryptera, och slutligen dekryptera information. Och allt vi har gjort idag, ganska kommer låg nivå, bara kommer att tillåta oss att ta en och en, och ett steg ovan mot skriver de mest intressanta koden ännu. 

Så mer om det nästa vecka. 

[VIDEOUPPSPELNING] 

-Vad Kan du berätta om den sista gången du såg honom? -Vad Kan jag säga, egentligen? Jag menar, det var som alla andra förproduktion repetition, utom fanns något sade han i slutet som fastnat med mig. 

-detta Var CS50. 

-Det Är ett snitt alla, bra jobb på repetition. 

-Det Lunch? 

-Ja, Du och jag kan ta en smörgås i en bit. Låt mig bara debriefing med David riktigt snabbt. David? David? 

[END SPELA] 