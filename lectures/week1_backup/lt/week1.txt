[GROJA MUZIKA] David J. Malan: Gerai, tai yra CS50. Ir tai yra viena savaitę. Taigi priminti, kad paskutinį kartą nulinis savaitę mes sutelktas į skaičiavimo mąstymo. Ir mes perkėlėme iš kad Nulio, grafinis programavimas kalba iš mūsų draugų ne MIT Media Lab. 

Ir su nulio, tai mes ištirti idėjos, kaip funkcijų, ir sąlygos, ir kilpos, ir kintamieji, ir net įvykiai ir siūlai, ir dar daugiau. Ir šiandien, mes ketiname toliau naudoti šias idėjas, ir tikrai vartojate juos suteikta, tačiau paversti juos į kitą kalbą, žinomas kaip C. dabar C yra labiau tradicinis kalba. Tai žemesnio lygio kalba, jei bus. 

Tai grynai tekstinę. Ir taip iš pirmo žvilgsnio, tai visi ketiname ieškoti gana paslaptingas jei jūs niekada užprogramuotas anksčiau. Mes ketiname turėti kabliataškiai ir skliaustai, ir garbanotas petnešos, ir dar daugiau. Bet suprantu, kad net nors sintaksė apie atrodyti šiek tiek susipažinę dauguma iš jūsų, matyti anksčiau, kad. Ir pabandyti pamatyti idėjas kad yra, iš tiesų, žino, nes čia savaitę vienas ką pradėsime daryti yra palyginti, Iš pradžių, Scratch, palyginti su C 

Taigi, pavyzdžiui, prisimena, kad kai mes įgyvendinti pirmasis mūsų programos Paskutinį kartą mes turėjome bloką, kad atrodė šiek tiek kažkas panašaus this-- kada Žaliosios vėliavos paspausti, o tada mes turėjome vienas ar daugiau įspūdį po juo, šiuo atveju, tarkim, Hello world. Taigi, iš tiesų, nulio, Kai paspaudžiu, kad žalioji vėliava paleisti savo programą, todėl kalbėti, tai yra blokų, kad gauti įvykdytas, arba paleisti. Ir būtent, įbrėžimams sakė, Labas, pasauli. 

Dabar, aš galėjo nustatyti skirtingi žodžiai čia. Bet mes matome, kad, tiesą sakant, daugelis Šių blocks-- Ir iš tiesų, C daug functions-- gali būti Parametrizuotieji ar individualų daryti skirtingus dalykus. Iš tiesų, į C temperatūroje, jei mes norite konvertuoti, dabar tai įbrėžimams programa šios kita kalba, mes ketiname parašyti tiek kažkas panašaus į tai. 

Natūralu, kad yra kai nepažįstamas sintaksė yra labiausiai tikėtina, INT, ir skliaustai ir tuščia. Bet printf--, net jei būtų manau, kad tai būtų tik spausdinti. Bet Spausdinti reiškia Spausdinti suformatuotas, kaip mes greitai pamatyti. Tai tiesiog spausdinti į ekraną kokia yra viduje tų skliausteliuose, kuris Žinoma, šiuo atveju yra hello world. 

Tačiau jūs pastebėsite, kai kurie kiti sintaksė, kai kabutes, kad tuo tikslu skliaustai, pusiau-gaubtinės žarnos ir pan. Taigi ten yra pridėtinių tiek, taip sakant, tiek pažintinių ir sintaksiškai, kad mes ketiname turėti prisiminti prieš ilgas. Bet suprantu, kad su praktika, tai pradės iššokti į tave. 

Iš tiesų, tegul dėmesį, kad vienas funkcija specifically-- šiuo atveju, sako hello world. Taigi pasakyti, kad funkcija. Sveiki pasaulis yra jos parametras, arba argumentas, jo pritaikymas. 

Ir C lygiavertiškumas yra tik bus šį vieną eilutę čia kur printf yra lygiavertis, tarkim, dvigubas cituojamas virvutė, labas pasaulyje yra lygiavertis, žinoma, į tai, kas į baltą dėžutę ten. Ir Backslash N, nors šiek tiek keista ir nėra nuo nulio, tiesiog ketina turėti poveikį mes matyti kompiuterio, kaip mano Mac arba PC, tiesiog judinant žymeklį į kitą eilutę. Tai kaip pataikyti Įveskite savo klaviatūroje. 

Taigi mes matome, kad vėl prieš ilgas. Bet pirmiausia, tegul tai žiūrėti Kitas pavyzdys vyrių atveju. Mes turėjome šį amžinai kilpa paskutinį kartą, kuris buvo įspūdį serija kad padarė kažką pažodžiui forever-- šiuo atveju, pasakyti, Hello world, Hello world, Hello world, Hello world. Taigi, tai begalinis ciklas dizainas. 

C, jei norime įgyvendinti šią pačią idėją, mes galime tiesiog tai padaryti. Nors tiesa, printf Sveiki world-- dabar o, tik semantiškai, rūšies asocijuosis su daro idėja kažkas ir vėl, ir vėl, ir vėl, ir kaip ilgai? Na, true-- Prisiminkite, kad tiesa yra tik arba viena. 

Ir tiesa, žinoma, visuomet tiesa. Taigi tai tipo beprasmė pareiškimas tiesiog pasakyti tiesa. Bet iš tikrųjų, tai yra sąmoningas, nes jei tiesa yra tik visada teisinga, nei, o tiesa tiesiog reiškia, jei šiek tiek netiesiogiai, kad šių eilučių kodo tarp tų garbanotas petnešos tiesiog reikia atlikti iš naujo, ir vėl, ir vėl, ir iš tikrųjų niekada sustoti. 

Bet jei jūs norite, kad jūsų kilpa sustoti, kaip mes darė paskutinį kartą kažką panašaus tai, pakartoti šiuos 50 kartų, C galėsime daryti tą patį, ką tai vadinamas už loop-- raktažodį nėra, o, bet. Ir tada mes turime keletą naujų sintaksė čia su int i lygu 0, I mažiau nei 50 metų, i ++. Ir mes grįžti prie to. Bet tai yra tiesiog kaip mes norėtume išversti nulio blokų rinkinys iki C eilučių kodo rinkinys. 

Tuo tarpu, mano kintamuosius. Ir, tiesą sakant, mes tiesiog mačiau vieną prieš momentas. Ir iš nulio atveju, jei mes norėjau paskelbti kintamąjį vadinamą i Aš būdamas sveikas, tiesiog skaičius, ir mes norime jį tam tikru vertės, mes naudoti šį apelsiną blokuoti here-- nustatyti i 0. 

Ir mes matome šiandien ir už jos ribų, kaip praeitą savaitę, programuotojai padaryti beveik visada pradėti skaičiuoti nuo nulio, tikrai pagal susitarimą. Bet taip pat, nes susigrąžinimas iš Mūsų diskusija dvejetainis, mažiausias kiekis, kurį galite atstovauti su bet bitų skaičius tiesiog bus 0. pati. Ir todėl mes paprastai prasideda Inicijuojama net mūsų kintamuosius 0. 

Ir C padaryti tą patį, mes ketiname pasakyti, int už sveikojo skaičiaus, aš tiesiog pagal susitarimą. Galėjau vadinamas šis kintamasis ką aš noriu, kaip ir nulio. Ir tada yra lygus 0 tik priskiria vertė 0 iš dešinės ir įdėkite jį į kintamąjį arba saugojimo konteineris yra, kairėje pusėje. Ir kabliataškis, kaip mes see-- ir mes matėme keletą šių already-- tiesiog reiškia galą minties. Tęskite daryti ką nors kita linijose, kurie seka. 

Dabar, ką apie Būlio išraiškos? Prisiminkite, kad nulio, tai buvo išraiška kad yra arba tiesa arba false-- klausimai, tikrai, kad yra arba true arba false. Taigi iš nulio atveju, mes galime užduoti paprastą klausimą, kaip tai, yra man mažiau nei 50? Todėl aš, dar kartą, yra sveikas skaičius. Gal mes jį naudoti į Scratch programos sekti dviejų dešimčių arba kažkas panašaus. Taigi tai sintaksė čia Scratch tiesiog reiškia, yra i mažiau nei 50? Na, laimei, kad kažkas yra paprastas C. Ir versti, tai mes tiesiog pasakyti, kad aš mažiau nei 50, naudojant pažįstamą raktą klaviatūroje. 

Tuo tarpu, jei norite pasakyti kažką apskritai kaip gerai, yra x mažiau nei y, kur kiekvienas iš X ir Y yra tokie, patys kintamieji? Mes galime padaryti tą patį C, tol, kol mes sukurta šiuos kintamuosius jau. Ir mes pamatyti, kaip padaryti, kad prieš ilgas. Mes tiesiog pasakyti x mažiau nei m. 

Taigi jūs pradedate matyti tam tikrų panašumų. Ir tie žmonės, kurie pagaminti Įbrėžimams buvo tikrai įkvėpė kai kurie iš šių pagrindinių idėjų. Ir pamatysite šios rūšies sintaksė daugelyje languages-- ne tik nulio, ne tik C, bet Python ir "JavaScript", ir Kitos kalbos dar. 

Apsvarstykite vieną konstruktą iš C, iš būklės sąvoka, daro kažką lygtinai. Jei kažkas yra tiesa, tai padaryti. Jei kažkas yra tiesa, tai padaryti. Tai tarsi programavimo ekvivalentas į kelio šakute. Gal tai dvipusis šakutė, trijų-būdas šakutė, arba daugiau. Ir nulio, mes galime turėti matyti kažką panašaus į tai. 

Taigi tai vienas didelis vienas. Tačiau mano, santykinis paprastumas logika. Jei x yra mažiau nei y, tada pasakyti x yra mažiau nei y, kitas, jei x yra didesnis nei y, tada pasakyti x yra didesnis nei m. Ir tada, logiškai, jei manote atgal į nulio ar tik savo žmogaus intuicija, gerai, jei x yra ne didesnis nei y, ir x yra ne mažesnis kaip y, tada, žinoma, x bus lygus y. Šiuo atveju taip, pagal lizdus tie Scratch blokai, mes galime pasiekti trys būdas kelio išsišakojimas? 

Tuo tarpu, jei norime padaryti, kad C, tai, be abejo, atrodo šiek tiek simpler-- bent kai gausite susipažinę su sintakse. Jei x yra mažiau nei Y, printf x yra mažiau nei m. Kitas, jei x yra didesnis nei y, printf x yra didesnis nei m. Kita printf x yra lygus y-- ir vėl su tais, Backslash baigiasi tik už tų naujų linijų, kad jei iš tikrųjų vyko šią programą natūra tai tiesiog perkelti kursorius galiausiai į kitą eilutę ekrano. 

Dabar, tuo tarpu "Scratch turėjo kitą daugiau sudėtingų funkcijų, tik kai kurie iš jų mes ketiname iš pradžių pereiti prie C pasaulyje Ir vienas iš jų buvo vadinamas sąrašas nulio. Ir tai buvo ypatinga tipo kintamasis, kuris leido jums laikyti kelis dalykus į jį atgal, atgal, atgal, atgal. 

C, ji neturi sąrašai, per se, bet kažkas kad yra daugiau paprastai vadinamas matricos, nors mes grįžti vėliau šį semestrą į žiūri kažką vadinamas sąrašą ar tikrai susietą sąrašą. Bet dabar, arčiausiai ekvivalentas C mus bus kažkas vadinamas masyvo. Ir masyvas yra tiesiog specialaus tipo kintamojo kuri leidžia jums saugoti duomenis atgal, atgal, atgal, į nugarą. 

Ir, iš tiesų, nulio, jei mes norėjome pasiekti pirmasis elementas masyvo arba list-- ir aš ruošiuosi jį vadiname, pagal susitarimą argv, argumentas vektorius, bet daugiau apie tai prieš ilgas. Jei aš noriu gauti pirmo elemento iš argv, į nulio pasaulyje Jūs iš tikrųjų paprastai pradėti skaičiuoti nuo 1. 

Ir todėl aš gali gauti iš argv 1 punktą. Tai tiesiog kaip MIT įgyvendinti Sąrašų sąvoka. Tačiau C, aš ruošiuosi daugiau tiesiog tiesiog pasakyti, argv, kuris vėl yra pavadinti savo list-- arba būti aišku, masyvas. O jei aš noriu pirmas elementai, aš ruošiuosi naudoti skliaustus,, kuris jus gali ne dažnai naudojamas pagal klaviatūra. 

Bet 0 tiesiog reiškia, gauti man pirmas. Taigi kartais, ir kaip laikas eina, mes ketiname pradėti žiūrėti šiuos dichotomijas tarp nulio ir C, kuriuo įbrėžimams naudoja vieną. Mes C naudoti 0 čia. Bet jūs greitai pamatyti kai jūs suprantate, kiekvienos kalbos pamatus, šie dalykai pradeda gauti dar susipažinę per praktiką ir praktikos. 

Tad tikrai atrodo dabar programai. Čia turi būti pirmasis mūsų C kodo sukomplektuotų programas. Ir programa mes ketiname pasiūlyti apsvarstyti yra vienas, kad yra lygiavertis tai anksčiau Scratch gabalas. 

Taigi čia mes turime tai, kas be abejo, paprasčiausias, C programa galite parašyti, kad tikrai daro kažką. Dabar, mes pažvelgti praeitį, dabar, jau yra, standartinis io.h, ir tai kampas skliausteliuose, ir INT ir tuščia, ir klamrami, ir pan. 

Ir tegul tik sutelkti dėmesį į kas, bent jau intuityviai, gali iššokti į tave jau. Iš tiesų, pagrindinis, aš ne visada žino, kas tai yra, bet panašiai kaip Scratch turėjo, kad kai Žaliosios vėliavos paspausti įspūdį, todėl nėra C kaip programavimo kalba turėti pagrindinį kodo fragmentą, kad paleidžiama vykdyti pagal nutylėjimą. Ir, tiesą sakant, tai tiesiog bus vadinamas pagrindinis. 

Taigi pagrindinis yra funkcija. Ir tai speciali funkcija, kuri egzistuoja C, kad paleidus programą, tai pagrindinis, kad gauna valdo numatytas. Atsižvelgiant į nulio pasaulyje, ji paprastai buvo, kai žalia vėliava paspaudėte, kad gavo paleisti pagal nutylėjimą. 

Tuo tarpu, mes matėme prieš tai, printf ar spausdinimo formato, tai bus funkcija, kuri ateina su C, kartu su visa krūva kitų, kad valia laiko ir laiko nuo vėl, tam, kad padaryti tiksliai kaip rodo jo pavadinimas, spausdinti kažką. Ką mes norime spausdinti? Na, mes matome, kad iki apsupimo simbolių kaip these-- hello world, Backslash n dvigubų kabučių, mes galime pasakyti printf tiksliai Ką spausdinti ekrane. 

Tačiau, norint tai padaryti kad mes, deja, reikia imtis kažką, kad yra jau paslaptingas į mus žmonių, bet bent jau tai šiek tiek readable-- SHARP apima, standartinis io.h, INT, Pagrindinis, tuščia, printf, visi stebuklinga užkalbėjimai mes tik pamačiau ekrane. Bet mes iš tikrųjų turi eiti daugiau paslaptingą dar. Mes pirmiausia reikia išversti kodą kad mes rašome į mašininį kodą. Ir prisiminti, nuo praeitos savaitės, kad mašinos, bent tie žinome čia ne dienos pabaigoje tik suprasti nulių ir. 

Ir mano Dieve, jei mes turėjome rašyti tai nulių ir faktiškai programos tai būtų labai, labai greitai imtis įdomus iš nieko. Bet pasirodo, už praeitą savaitę, kad šie nulių ir modeliai tiesiog ypatingą reikšmę. Tam tikrais kontekstuose, jie gali reikšti numerius. 

Kai kontekstuose, jie gali reikšti laiškus ar spalvos, ar bet koks skaičius Kitų abstrakcijų ten ant. Bet kaip kompiuteris yra CPU, centrinis apdorojimo blokas, arba viduje kompiuterio smegenys. Tai paprastai "Intel" viduje, nes tai viena iš didžiausių bendrovių kad daro procesorius kompiuteriams. 

Na, "Intel" procesoriai ir kiti tiesiog nusprendė iš anksto kad tam tikri modeliai nuliai ir tie tai konkrečių dalykų. Kai kurie modeliai nulių ir reikš, atspausdinti į ekraną, arba pridėti šiuos du numerius arba atimti šiuos du skaičius, arba perkelti šį duomenų gabalas iš Mano kompiuteris atminties daugiau nei čia arba bet kurį kitą labai žemo lygio numeris, bet galiausiai naudinga, operacijų. Bet, laimei, mes, žmonės nesiruošia to reikia žinoti, kad šis išsamumo lygį. Iš tiesų, kaip ir paskutinį kartą, kur mes išgaunamo vėl, ir vėl, ir vėl, Pastatas nuo labai žemo lygio primityvai kaip nulių ir Į aukštesnį lygį sąvokų kaip skaičiai ir raidės, ir spalvos, ir daugiau, taip mes galime programuotojais stovi ant pečių kiti, kurie atvyko prieš mus ir naudoti programinę įrangą, kad kiti žmonės parašyta prieš us-- ty programos vadinamas kompiliatoriai. 

C yra kalba, kuri paprastai parengta, o tai reiškia, konvertuoti iš kodą į mašininį kodą. Visų pirma, ką tai reiškia yra tai, kad jei jūs turite savo šaltinį kodą, kurį sau rašyti, kaip mes greitai bus vos akimirką ekrane, ir norite jį paversti galiausiai mašina code-- tie nuliai ir tie, kurie tik jūsų Mac arba jūsų kompiuteris understands-- jūs turite pirmas pašarus, šaltinio kodą, kaip indėlis į ypatingas programa, vadinama sudarytojas, įtaisas, kurio išėjimas mes regės yra mašina kodą. Ir, tiesą sakant, paskutinį kartą mes kalbėjome apie, tikrai, bent dienos pabaigoje, problemų sprendimas. Jūs turite įėjimai. Ir jūs turite rezultatus. Ir jūs turite šiek tiek natūra algoritmas viduryje. 

Algoritmai tikrai gali būti įgyvendinama programa, kaip matėme su Pseudocode paskutinę savaitę ir kaip matysime su faktine kodas šią savaitę. Ir todėl kompiliatorius tikrai tik turi algoritmų rinkinį viduje tai, kad nežino, kaip konvertuoti specialius žodžius, kaip pagrindinio ir printf, ir kiti, kad mes tiesiog pamačiau į nulius modelius ir tie, kurie "Intel viduje ir kiti procesorius iš tikrųjų supranta. Taigi, kaip mes tai darome? Kur mes gauti kompiliatorių? 

Daugelis iš mūsų čia turite Mac ar PC. Ir jūs naudojate Mac OS, arba "Windows" arba "Linux arba Solaris arba bet kitas numeris Operacinės sistemos. Ir, iš tiesų, mes galime išeiti į internetą ir atsisiųsti kompiliatorių Jūsų Mac ar kompiuteryje savo pirma operacinę sistemą. Bet mes visi būti skirtingi puslapiai, taip sakant. Mes norime šiek tiek turi skirtingų konfigūracijų. Ir viskas nebūtų dirbti visi tą patį. Ir, iš tiesų, šių dienų Daugeliui iš mūsų nereikia naudoti programinė įranga, kuri veikia tik ant mūsų nešiojamieji kompiuteriai. Vietoj to, mes naudojame kažką kaip naršyklę, kuri leidžia mums naudotis interneto pagrindu paraiškas debesyje. Ir vėliau šį semestrą, mes padarysime lygiai taip pat. Mes parašyti programas ar programinė įranga, naudojant code-- ne C bet kitos kalbos kaip Python ir JavaScript--, kad paleisti į debesis. 

Ir tai padaryti, mes patys semestro metu bus iš tikrųjų naudoti debesis pagrįstas aplinka žinomas kaip CS50 IDE. Tai internetinė programavimas aplinka, arba integruotas vystymas aplinka, IDE, kad pastatytas ant kai atviro kodo programinė įranga vadinama Debesis 9. Ir mes padarėme kai pedagoginė supaprastinimai į jį taip, kad paslėpti tam tikri elementai Pirmosiomis savaitėmis, kad mums nereikia, po kurio galite atskleisti juos ir padaryti dauguma Viskas, ką norite su aplinka. 

O tai leidžia mus, taip pat, kad iš anksto įdiegti tam tikrą programinę įrangą. Dalykų, pavyzdžiui, vadinamasis CS50 biblioteka, kurią mes netrukus pamatysite suteikia mums C su kai Papildomos funkcijos. Taigi, jei jūs einate į galiausiai CS50.io, būsite paraginti prisijungti, ir kai jūs darote ir sukurti paraiška nemokamą paskyrą, galėsite prieiti prie aplinka, kuri atrodo gana panašus į šį. 

Dabar, tai yra numatytąją režimu. Viskas yra gražus ir šviesus ekrane. Daugelis iš mūsų turime įprotį darbo CS50 gabalas tai gana vėlyvos nakties. Ir taip kai kurie iš jūsų norėti paversti jį nakties režimą, taip sakant. 

Bet, galų gale, ką jūs ketiname pamatyti per CS50 IDE yra tris skirtingas areas-- sritis, kairėje ir tais failai bus į debesis, sritis, viršutiniame dešiniajame kur jūsų kodas bus redaguojami. Galėsite atidaryti individualūs skirtukai bet kurią programą kad rašote šį semestrą viduje tos viršutiniame dešiniajame kampe. Ir tada pats arcanely, ir dar stipriai, bus šis dalykas ne iš apačios į žinomas kaip terminalo lange. 

Tai senosios mokyklos Komandinės eilutės sąsaja, arba CLI, kuri leidžia jums vykdyti komandas dėl šiuo atveju computer--, tačiau prasidėjusi cloud-- kompiuteris daryti tokius dalykus kaip kaupti kodą iš išeities kodo į mašininį kodą, paleisti savo programas, arba pradėti savo žiniatinklio serveris, ar prieiti prie jūsų duomenų bazės, ir bet kurį iš kitų metodų numeris kad mes pradėsime naudoti prieš ilgai. Bet ten, mes ketina iš tikrųjų turi prie interneto ir pradėti žaisti. Ir tai padaryti, tegul pirmas pradėti skardinimo su pagrindiniu, ir rašyti pagrindinį programos dalis. Ir tegul naudoti šią funkciją printf, kurį mes naudojamas anksčiau, tiesiog pasakyti kažką. 

Taigi čia aš jau viduje CS50 IDE. Aš prisijungęs anksto. Ir aš visiškai patikrintas langą. Ir taip, galiausiai jums per ateinančiais problemų seks panašius veiksmus, teiks internetu dokumentaciją. Taigi jums nereikia jaudintis sugeria kas mažai techninę žingsnis kad aš čia šiandien. 

Bet jūs gausite panašaus ekraną. Aš atsitikti, kad naktiniu režimu. Ir jūs galite pašviesinti viską iki išjungti naktinį režimą. Ir galutinio dieną, jūs ketinate pamatyti tai trys pagrindinės areas-- failą Naršyklė kairėje, kodų skirtukai iki viršaus, ir terminalo langą apačioje. 

Leiskite man eiti į priekį ir rašyti savo pirmąją programą. Aš ruošiuosi Preemptively eikite į File, Išsaugoti ir išsaugoti savo failą taip hello.c. Iš tiesų, pagal susitarimą, bet programa, kurią mes parašyti, kad parašyta C kalba turėtų būti pavadintas kažką taškas c, pagal susitarimą. Taigi, aš ruošiuosi pavadinkite jį hello.c, nes Aš tik noriu pasakyti labas pasaulyje. Dabar aš ruošiuosi padidinti iš ir spustelėkite Įrašyti. Ir viskas, ką turiu čia dabar yra skirtukas į kurį galiu pradėti rašyti kodą. 

Tai nesiruošia sudaryti. Tai reiškia, nieko. Ir net jei aš konvertuoti tai nulių ir, CPU teks ne idėja, kas vyksta aplink. Bet jei aš rašau linijas, kurios atitiktų su C anketa conventions-- C būties, Vėlgi, tai language-- su sintakse, kaip tai, printf Sveiki world-- ir aš Dotarłeś patogiai Tokiu būdu per tam tikrą laiką. Taigi, aš nemanau, kad aš padariau bet tipografijos klaidų. 

Bet visada, pats pirmas laikas tai padaryti, jums bus. Ir ką aš esu apie tai galėtų labai gerai neveikia už jus pirmą kartą. Ir tai puikiai Gerai, nes dabar tu gali tik pamatyti visai daug naujumo, tačiau laikui bėgant kai gausite susipažinę su šioje aplinkoje, ir Ši kalba, o kiti, Jūs pradėsite matyti dalykus, kurie yra arba teisingas, arba klaidingas. 

Ir tai, ką Mokymo bičiuliai ir žinoma padėjėjai gauti taip gerai per tam tikrą laiką, yra tepimas klaidų ar klaidų savo kodą. Bet aš teigti, kad egzistuoja nėra šio Kodekso klaidas. Taigi, aš dabar norite paleisti šią programą. 

Dabar ant mano paties Mac arba PC, aš dvigubų Paspaudę piktogramos įprotis kai noriu paleisti kai programą. Bet tai dar ne modelis čia. Šioje aplinkoje, kuri yra CS50 IDE. Mes naudojame vykdantis sistema, vadinama "Linux". Linux yra primenantis kitą operacinė sistema, visuotinai žinoma kaip Unix. Ir Linux ypač žinomas dėl turintys Komandinės eilutės aplinka, CLI. Dabar, mes naudojant specialias skonio Linux vadinamas Ubuntu. Ir Ubuntu yra tiesiog tikra versija Linux. 

Tačiau šie Linux šių dienų tai tikrai ateiti su grafinės vartotojo sąsajos. Ir viena, mes atsitikti naudojate čia yra žiniatinklio. Taigi tai gali atrodyti net šiek tiek skiriasi nuo kažko tu gali turėti matyti arba paleisti praeityje. 

Taigi, aš ruošiuosi eiti į priekį dabar ir atlikite šiuos veiksmus. Aš išgelbėti šį failą kaip hello.c. Aš ruošiuosi eiti į priekį ir tipo clanghello.c Taigi žvangėjimas už C kalba yra kompiliatorius. Tai iš anksto įdiegta į CS50 IDE. Ir jūs galite atsisiųsti ir visiškai įdiegti šią savo Mac arba PC. 

Bet, vėlgi, jums nereikės visi iš anksto konfigūracija padaryta už jus. Taigi dabar, aš tiesiog ketina paleisti clanghello.c. Ir dabar pastebėsite šį sintaksė čia galų gale suprasti, tiesiog reiškia, kad aš esu A aplankas arba katalogas vadinamas Workspace. Tai dolerio ženklas yra tik konvencija prasmės, įveskite savo komandas čia. 

Tai, kas vadinama greitai, tik pagal susitarimą yra dolerio ženklas. Ir jei aš einu į priekį dabar ir spustelėkite Įveskite, nieko, atrodo, atsitiko. Bet tai tikrai geras dalykas. Kuo mažiau, kad vyksta Jūsų ekranas, tuo labiau tikėtina, Jūsų kodas turi būti teisinga, bent sintaksiškai. 

Taigi, jei aš noriu paleisti tai Programa, ką man daryti? Na, tai paaiškėja, kad Numatytasis vardas pagal susitarimą programas, kai jūs nenurodote vardą savo programa yra tik a.out. Ir tai sintaksė taip pat jums susipažinti su prieš ilgas. 

Dot velniop tiesiog reiškia, ei, CS50 IDE, paleisti programą, pavadintą a.out kad viduje mano dabartinis kataloge. Kad taškas reiškia einamą aplanką. Ir mes pamatyti, ką kiti tokias sekas simbolių reiškia prieš ilgas. 

Taigi čia mes einame, Enter hello world. Ir jūs pastebėsite, kad tai, kas atsitiko? nebuvo tik ji spausdinti hello world. Ji taip pat persikėlė žymeklį į kitą eilutę. 

Ir kodėl tai buvo? Koks buvo kodas, rašėme prieš kad užtikrinti, kad žymeklis būtų eiti į kitą eilutę? Įdomiausia maždaug Kompiuteris tai tik ketina daryti tiesiog ką pasakyti, daryti. 

Taigi, jei jūs pasakyti, kad printf Sveiki, kablelis, tarpas, pasaulis, netoli citata, tai tiesiog tik ketina spausdinti tuos simbolius. Bet aš turėjau šią ypatingą charakterį pabaigoje Prisiminkite, pasvirąjį n. Ir tai, kas užtikrino kad charakteris išvyko į kitą eilutę ekrano. 

Tiesą sakant, leiskite man eiti ir tai padaryti. Leiskite man eiti į priekį ir ištrinti. Dabar, pastebėsite, kad Į viršų mano ekrano ten šiek tiek raudonos šviesos skirtukas nurodant, Ei, jūs išsaugojote failą. Taigi, aš ruošiuosi eiti į priekį su kontrolės S arba komandų S išsaugoti failą. Dabar goes-- išvyko moment-- žalia. Ir dabar jis vėl tiesiog yra artimas ikona. 

Jei aš dabar paleisti clanghello.c vėl Įveskite, taškas velniop, a.out, Enter pamatysite, kad ji vis dar dirbo. Bet tai, be abejo, šiek tiek Buggy. Dabar, mano prompt-- Workspace, ir tada, kad dolerio ženklas, ir tada mano tikrasis prompt-- yra visi toje pačioje eilutėje. Taigi, tai, žinoma, estetinis klaidą, net jei tai tikrai nėra logiška klaidą. 

Taigi, aš ruošiuosi atšaukti ką tik padarė. Aš ruošiuosi pakartotas a.out. Pranešimo I pridėjome naujos eilutės simbolis atgal. Aš išsaugoti failą. 

Taigi, aš ruošiuosi pakartotas a.out, and-- Dammit, klaida, klaida reiškia klaidą. Taigi klaida yra tai, kad nors Aš pridėjo kairinį brūkšnį, n ten, Re išsaugotas, vėl bėgo programą, elgesį buvo tas pats. Kodėl tai būtų? 

Aš trūksta žingsnį, tiesa? Tai svarbus žingsnis anksčiau buvo, kad jūs turite to--, kai jūs pakeičiate savo kodą, paaiškėja, taip pat paleisti tai per sudarytojas vėl taip gausite naują mašininį kodą. Ir mašina kodas, kad nulių ir, ketinate būti beveik identiški, tačiau nėra visiškai taip, nes mes turime, Žinoma, kad nauja linija. 

Taigi, norint išspręsti šią problemą, aš ruošiuosi reikia Pakartotinas clanghello.c, įveskite, taškas velniop, a.out. Ir dabar, Hello world atgal kur aš tikėtis, kad ji bus. Taigi tai yra viskas gerai ir gerai. Bet a.out yra gana kvailas vardas dėl programa, nors tai atsitinka būti, dėl istorinių priežasčių default-- reiškia surinkimo rezultatus. 

Bet leiskite man eiti į priekį čia ir tai padaryti kitaip. Aš noriu, kad mano hello world programa kad iš tikrųjų galima pavadinti labas. Taigi, jei ji būtų piktogramą ant mano darbastalio, tai nebūtų a.out. Tai būtų galima pavadinti labas. 

Taigi, norint tai padaryti, ji Pasirodo, kad žvangėjimas, kaip ir daugelis programų, palaiko komandinės eilutės argumentus, arba vėliavos, ar jungiklių, kuris tiesiog paveikti jo elgesį. Tiksliau, klingsėti palaiko brūkšnelį o vėliava, kuris vėliau į antrą žodį. Šiuo atveju, aš savavališkai, bet protingai, ją vadina labas. Bet galėčiau jį pavadinti nieko Noriu, išskyrus a.out, kuris būtų gana be taško. 

Ir tada tiesiog nurodykite vardą Bylos aš noriu rinkti. Todėl dabar, nors šiuo metu pradžioje apie komandą dar turiu žvangėjimas, ties komandos pabaigoje Aš vis dar turiu failo pavadinimą, dabar turiu šias komandų eilutę argumentai, šios vėliavos, kad sako, Oh, beje, išėjimas-O, byla vadinamas Sveiki, nėra numatytoji a.out. 

Taigi, jei nukentėjo Aš Įveskite dabar nieko Panašu, kad atsitiko. Ir dar, dabar galiu padaryti dot velniop labas. Taigi, tai tą pačią programą. Į nulių ir yra identiški dienos pabaigoje. 

Bet jie į dvi skiriasi files-- a.out, kuri yra pirmoji versija ir tiesiog kvailai pavadintas, o dabar labas, kuri yra daug patrauklesnės pavadinimas programą. Tačiau, sąžiningai, aš esu niekada ketina prisiminti tai vėl, ir vėl, ir vėl. Ir, iš tikrųjų, kaip mes rašome daugiau sudėtingas programas, komandas esate teks rašyti ketinate gauti net daugiau sudėtinga dar. 

Ir taip nesijaudinti. Pasirodo, kad žmonės prieš mums jau supratau, jie taip pat turėjo būtent šį tą pačią problemą. Jie taip pat neturėjo būtinybės įrašykite gana ilgas, paslaptingų komandas, jau nekalbant apie juos prisimename. Ir taip žmonės prieš mus padarė Kitos programos, kad būtų lengviau sudaryti savo programinę įrangą. 

Ir, tiesą sakant, vienas iš tokių Programa vadinama padaryti. Taigi, aš ruošiuosi eiti į priekį ir tai padaryti. Aš ruošiuosi atšaukti viską, Aš tiesiog padarė taip. Leiskite tipo LS. Ir jūs pastebėsite trijų Quake a.out ir žvaigždė, labas ir žvaigždė, ir hello.c. Tikimės, kad tai turėtų būti šiek tiek paprastesnis, kiek anksčiau ten buvo niekas šioje darbo vietos. Nebuvo nieko, kad man teko sukurta kol mes pradėjo klasę. 

Ir aš sukūriau hello.c. tada aš surinkti jį ir pavadino jį a.out. Ir tada aš surinkti jį vėl šiek tiek skirtingai ir pavadino jį labas. Taigi turiu tris failus šiame kataloge, šiame aplanke vadinamas darbo vietos. Dabar matau, kad taip pat jei aš nutolinti tikrųjų. 

Jei aš nutolinti čia ir pažvelgti, kad viršutiniame dešiniajame kampe, kaip buvo žadėta kairė pus ekrano visada bus parodyti jums kas savo sąskaitoje, kas viduje CS50 IDE. Ir yra trys failai ten. 

Taigi noriu atsikratyti a.out ir labas. Ir kaip jums gali įsivaizduoti, intuityviai, jums gali rūšiuoti valdymo paspaudimu arba dešiniuoju pelės mygtuku spustelėkite šią. Ir tai mažai meniu pasirodo. Galite atsisiųsti failą, paleiskite IT, peržiūrėti jį, atnaujinkite, pervardyti, ar kas ne. 

Ir aš galėčiau tiesiog ištrinti, ir ji neišnyks. Bet darykime ką su komanda linija dabar, taip, kad būtų gauti patogi su tuo, ir atlikite šiuos veiksmus. Aš ruošiuosi eiti į priekį ir išimkite a.out įvesdami pažodžiui rma.out. Pasirodo, kad komandą pašalinti ar ištrinti kažką nėra pašalinti ar ištrinti. 

Tai daugiau glaustai RM, tik sutaupyti jums keletą klavišų, ir paspauskite "Enter". Dabar mes ketiname būti šiek tiek cryptically pašalinti reguliariai failo a.out. Aš tikrai nežino, kas yra nereguliarus failas būtų dar. Bet aš noriu jį pašalinti. 

Taigi, aš ruošiuosi Y tipo už "taip". Arba galėčiau įrašyti jį iš, ir paspauskite "Enter". Ir, vėlgi, nieko atrodo, kad taip atsitiktų. Bet tai, paprastai, yra geras dalykas. 

Jei aš tipo LS šį kartą, ką turėčiau pamatyti? Tikimės, tik labas ir hello.c. Dabar, kaip panaikinti, jums pastebėti šį žvaigždė, pažymėtus žvaigždute, tai ne mano programų pabaigoje. Ir jie taip pat rodo žalia spalva. Tai tiesiog CS50 IDE būdas iš cluing jus į tai, kad tai ne kodo. Štai vykdomąjį A Runnable programa, kad jūs iš tikrųjų galite paleisti daro dot velniop, tada tai vardas. 

Dabar leiskite man eiti į priekį ir išimkite tai, RM Sveiki, Enter pašalinti reguliariai file Sveiki, taip. Ir dabar, jei aš tipo LS, mes grįžome į hello.c. Stenkitės ne ištrinti savo Tikrasis kodo. Nors yra funkcijos pastatytas į CS50 IDE kur galite eiti per savo peržiūros istorija ir atgal laiku, jei jūs netyčia ištrinti kažką daryti nepamiršti kaip už šių raginimų TAIP arba NE, ką jūs iš tikrųjų norite daryti. Ir jei man eiti į viršų kairiajame kampe čia belieka hello.c. Taigi ten kekių kitas komandas, kad jūs gali vykdyti, Linux pasaulyje, iš kurių vienas yra, vėlgi, Make. Ir mes ketiname padaryti mano programa dabar taip. 

Užuot žvangėjimas, užuot žvangėjimas-o, Aš ruošiuosi tiesiog tiesiog tipą, markę Hello. Ir dabar pastebėsite, aš esu ne rašyti, kad hello.c. Aš rašyti padaryti Hello. 

Ir ši programa Padaryti, kad ateina su CS50 IDE, ir dar daugiau paprastai su Linux, yra programa, kuri yra ketina padaryti programą, pavadintą Sveiki. Ir jis ketina prisiimti, pagal susitarimą, kad, jei ši programa gali būti, jis ketina būti pagaminti iš šaltinio kodas failas baigiasi dot C, hello.c. 

Taigi, jei nukentėjo Aš Įveskite dabar, pranešęs, kad komanda, kad paleidžiama vykdyti yra iš tikrųjų net ilgiau Prieš nei anksčiau. Ir tai todėl, kad mes sukonfigūruotas CS50 IDE turi keletas papildomų funkcijų pastatytas, kad mums nereikia, tik dar, bet greitai bus. Bet pagrindinis dalykas suvokti dabar turiu Hello programą. 

Jei aš tipo LS vėl, aš turi Hello programą. Ir aš galiu paleisti jį su taškas velniop a.out, ne, nes visa šios pratybos buvo taškas velniop labas. Ir dabar turiu hello world programa. Taigi juda į priekį, mes beveik visada tik ketina sudaryti mūsų programas naudojant komandų padaryti. Ir tada mes ketiname paleisti juos taškas velniop, ir programa vardas. Bet suprasti, ką padaryti yra darai tu, tai yra pati ne kompiliatorius. Tai tiesiog patogumo programa kad žino, kaip sukelti kompiliatorių paleisti, kad tu gali ją naudoti. 

Kas kitas komandas egzistuoja "Linux", ir, savo ruožtu CS50 IDE? Mes netrukus pamatysite, kad ten Kompaktinių diskų komandą, Pakeisti katalogas. Tai leidžia jums per Jūsų komandų eilutės sąsaja judėti į priekį ir atgal, ir atverti skirtingus aplankus nenaudojant pelę. 

LS matėme, kuris reiškia sąrašą Į einamojo katalogo failus. Padaryti Dir, galite tikriausiai pradėti daryti išvadą, kas tai reiškia now-- padaryti katalogas, Jei norite sukurti aplanką. RM už pašalinti RM Rež už pašalinti directory-- ir tai, vėl yra komandų eilutės ekvivalentai, ką gali daryti CS50 IDE su pele. Bet jūs netrukus rasite kad kartais tai tiesiog greičiau reikia daug padaryti dalykus su klaviatūra, ir galiausiai daug daugiau galingas. 

Bet tai sunku ginčytis, kad ką mes jau darome iki šiol yra viskas, galingas, kai visi mes jau sakoma, Hello world. Ir, tiesą sakant, aš kieta žodžiai Sveiki pasaulį į mano programą. Nėra dinamiškumas dar. Įbrėžimams buvo dydžio, kad įdomiau praėjusią savaitę. 

Ir taip galime gauti ten. Paimkime žingsnį link, kad būdas kai kurie iš šių funkcijų. Taigi ne tik C ateiti su printf, ir kekių kitų funkcijų kai kurie iš jų matysime laikui bėgant, ji nėra kad visa tai taip paprasta tiesiai iš iš gauti vartotojo įvesties vartų. 

Iš tiesų, vienas iš trūkumų kalbų kaip C, ir net "Java" ir dar kiti, yra tai, kad jis nėra kad būtų lengva tiesiog gauti dalykų, pavyzdžiui, sveikieji skaičiai iš vartotojų, arba stygos, tariant, ir frazės, jau nekalbant apie tokius dalykus kaip slankiojo kablelio reikšmes ar realieji skaičiai su dešimtųjų kiekis, ir tikrai ilgi numeriai, kaip mes greitai pamatyti. Taigi tai funkcijų sąrašas čia, tai yra kaip ir kiti įbrėžimams įspūdį kad mes turime iš anksto įdiegta į CS50 IDE, kad mes naudosime keletą savaičių kaip mokymo ratų rūšių ir galiausiai juos išjungti, ir surasti po kapotu, ko gero, ne kaip šie dalykai būtų įgyvendintos. 

Tačiau tai padaryti, tegul realiai parašyti programą. Leiskite man eiti į priekį dabar. Ir aš ruošiuosi kurti naujas failą spustelėdami šį mažą pliusą, ir paspauskite New file. 

Aš ruošiuosi išsaugoti tai kitas vienas kaip, tarkim, string.c, nes aš noriu žaisti su stygos. Ir styginių C yra tik simbolių seka. Taigi, dabar galime eiti į priekį ir atlikite šiuos veiksmus. 

Įtraukti standartas IO.h-- ir paaiškėja, standartinis IO, IO reiškia tiesiog įvesties ir išvesties. Todėl Pasirodo, kad Ši linija čia yra ką yra kaimyninių mums naudoti printf. Printf, žinoma, gamina išvestį. Taip kad būtų galima panaudoti printf, ji virsta iš jūs turite turėti šią eilutę kodo ne jūsų failo viršuje. 

Ir mes grįžti į tai, kas kad iš tikrųjų reiškia prieš ilgas. Ji Pasirodo, kad bet C programą, rašau, Aš turiu jį paleisti su kodas, kuris atrodo taip. Ir jūs pastebėsite CS50 IDE ir kita integruota kūrimo aplinka patinka, ketiname bandyti kaip geriausias jie gali baigti savo mintis. Tiesą sakant, akimirką prieš, jei aš atšaukti ką aš ką tik padariau, aš paspauskite Enter. 

tada aš paspauskite atvirą garbanotas petnešomis, paspauskite Enter dar kartą. Ir tai baigiau savo mintis. Jis davė man naują liniją, atitraukiama ne mažiau for nice stilistinių priežasčių mes pamatysime. Ir tada jis automatiškai man davė kad garbanotas petnešomis baigti savo mintis. Dabar ji ne visada atspėti, ką norite daryti. Bet didele dalimi, ji sutaupyti keletą klavišų. Taigi prieš momentas, nubėgome šį program-- Sveikas, pasauli, o tada surinkti jį, ir tada bėgo. Tačiau nėra dinamiškumas čia. Ką daryti, jei mes norėjome daryti kažką kitą? Na, ką, jei aš norėjau, kad iš tikrųjų gauti eilutę iš vartotojas? Aš ruošiuosi naudoti įspūdį vadinamas tiksliai that-- gauti eilutę. 

Pasirodo, C, kad, kai jūs nenorite siekiant prisidėti prie dėlionės gabalas, ar daugiau tinkamai funkcija, galite tiesiog tiesiog padaryti atvirą skliaustų, Uždaryti skliausteliuose. Taigi, tai, kaip nors ten ne baltas langas įvesti į. Tarkim blokas prieš turėjo mažai baltas langas. Neturime kad baltas langas dabar. 

Bet kai aš skambutis Gauti eilutę, aš norite įdėti rezultatą kažkur. Taigi labai dažna paradigma C yra skambinti funkciją, pavyzdžiui, get eilutę čia ir tada laikyti savo sugrįžimo vertę. Tai rezultatas jo pastangos kažką. 

Ir kas yra statyti programavimo, ar tai naujo ar dabar C, kad mes galima naudoti iš tikrųjų laikyti kažką? Vadinamas jis kintamas, tiesa? Ir nulio, mes tikrai ne rūpintis, kas vyksta per kintamuosius. 

Tačiau šiuo atveju, mes iš tikrųjų. Aš ruošiuosi pasakyti eilutę. Ir tada aš galėčiau skambinti tai ką aš noriu. Aš ruošiuosi ją vadina vardas, gauna gauti eilutę. 

Ir dabar, net jei esate šiek tiek nauja tai, pastebėsite, kad aš trūksta šiek tiek detalių. Aš pamiršta kabliataškiu. Man reikia baigti šį minties. Taigi, aš ruošiuosi perkelti savo žymeklį, ir paspauskite kabliataškį ten. Ir ką aš ką tik padariau? Šiame kodo eilutę, numeris 5 šiuo metu, Aš skambina get eilutę su be įėjimai. Taigi nėra tiek balta Lauke kaip Išsaugoti blokas turi. 

Aš tiesiog pasakyti, ei, kompiuteris, gauti man eilutę. Lygybės ženklo yra tai tikrai ne lygybės ženklas per se. Tai užduotis operatorius, o tai reiškia,, ei, kompiuteris, perkelti vertę iš daugiau nei į kairę dešinėje. Ir kairėje, turiu taip. 

Ei, kompiuteris, duok man string-- simbolių seka. Ir skambinti, kad string vardas. Ir aš nemanau, net jį vadinti vardu. 

Galėčiau jį pavadinti, tradiciškai, kažkas panašaus į S panašiai kaip mes naudojome i į skambinti kintamasis i. Bet dabar man reikia kažką daryti su juo. Būtų gana kvaila išbandyti šį kodą sudarymą, ir veikia ši programa, nors Gaunu eilutę, nes tai dar tik ketinate pasakyti labas pasaulį. 

Bet kas, jei aš noriu tai pakeisti. Kodėl ne aš tai padaryti? Proc S, kablelis Š. Ir tai yra šiek tiek paslaptingas dar. 

Taigi leiskite man padaryti, kad mano kintamieji labiau aišku. Leiskite pavadinti šį Kintamojo pavadinimas. Ir tegul pamatyti, jei mes negalime erzinti išskyrus tai, kas vyksta čia. 

Taigi on-line penkių, gaunu eilutę. Ir aš saugoti, kad eilutę, kokia vartotojas įvedėte jo ar jos klaviatūrą, į kintamąjį vadinamą pavadinimą. Ir paaiškėja, kad printf ne tik išgerkite vieną argumentą dvigubai Citatos, vienas įėjimas į kabutes. 

Ji gali imtis dviem arba trimis, ar daugiau, pavyzdžiui kad antrasis, arba trečioji arba ketvirtoji, yra visi kintamieji vardai arba specialiai vertybes, kad norite prijungti prie, dinamiškai, kad eilutė į kabutes. Kitaip tariant, kas Būtų negerai su tai? Jei aš ką tik pasakė labas vardas, Backslash N, išgelbėjo mano byla, vedama savo kodą, ir vyko tai, kas nutiktų? 

Tai tiesiog ketinate pasakyti, labas vardas, pažodžiui N A M E kuris yra tipo kvaila, nes tai nesiskiria nuo pasaulio. Taigi nieko kabučių yra kas pažodžiui bus atspausdintas. Taigi, jei aš noriu turėti rezervuota vieta ten, Aš iš tikrųjų reikia naudoti kai specialią sintaksę. Ir it turns out, jei jūs skaityti dokumentacija printf funkcijai, jis jums pasakys, kad jei naudojate proc s, Jūs vertę gali pakeisti taip. 

Po kablelio po to dvigubas citata, tiesiog rašyti vardo kintamasis, kurį norite prijungti į tą formatu kodas, arba formatas specifikatorius, proc s stygos. Ir dabar, jei aš išgelbėjo mano bylą, Aš einu atgal į mano terminalo. Ir aš tipo Padaryti eilutę, nes, vėlgi, kad šis pavadinimas failą, kad aš pasirinkau prieš string.c. 

Taigi, aš ruošiuosi pasakyti Padaryti String, įveskite. Oh my gerumas, pažvelgti visus klaidos mes padarėme jau. Ir tai is-- ką, tai yra tikrai kaip šešis, septynis eilutės programa? Taigi, tai yra ten, kur jis gali labai greitai gauti didele. 

Šis terminalas langas turi dabar tik atryjama labai daug klaidų pranešimus. Žinoma, aš neturiu daugiau klaidą pranešimai nei aš eilučių kodo. Taigi, kas vyksta? 

Na, geriausia strategija daryti bet kada Ar susidūrėte su didele sąrašas klaidų, kaip kad, yra slinkti atgal, ieškoti komandą jūs tiesiog bėgo, o mano atveju yra padaryti eilutę. Pažvelkite, ką padaryti ir padariau, tai, kad ilgai klingsėti komandą, ne big deal ten. 

Bet raudona yra blogai. Žalioji bando būti švelnus ir naudinga. Bet tai vis tiek blogai, ir šiuo atveju. Bet kur tai blogai? 

String.c, linija penkių, charakteris penki. Taigi tai yra tik bendras konvencijos. Kažkas dvitaškis kažkas tai eilutės numeris ir pobūdis, skaičius. Klaida, naudojimas nedeklaruota identifikatorius eilutė. Ar Jūs turėjote galvoje standartas? 

Taigi, deja, klingsėti bando būti naudinga. Bet tai yra negerai, ir šiuo atveju. Ne, klingsėti, nenorėjau standartinį IO. Aš norėjau, kad on-line vieno, taip. 

Bet linija penkių tai vienas čia. Ir klingsėti nėra suprasti S-t-R-i-N-G. Tai nedeklaruota identifikatorius A Žodis ji tiesiog niekada matęs. Ir tai todėl, kad C kalba mes rašote kodą dabar, neturi kintamieji vadinami eilutes. 

Tai nereiškia, pagal nutylėjimą, paramos kažkas vadinamas eilutę. Tai yra CS50 gabalas žargonu, bet labai tradicinis. Bet aš galiu išspręsti šią problemą taip. 

Jei aš pridėti vieną eilutę kodo į šios programos viršuje, įtraukti CS50.h, kuris yra kito failo kažkur viduje CS50 IDE, kažkur kietajame diske, taip sakant, iš Ubuntu operacinės sistemos kad Bėgu, kad yra failas tai einu išmokyti operacinės sistema, kas yra eilutė, tiesiog kaip standartinis io.h yra failas operacinė sistema ŠTAI ketina mokyti ką printf yra. 

Iš tiesų, mes Dotarłeś labai panaši žinutė jei IO prisipažino standartą IO.h ir bandė naudoti printf. Taigi, aš ruošiuosi eiti į priekį ir tik Imkis L išvalyti savo ekraną. Arba galite įvesti aiškus ir jis bus tiesiog išvalyti terminalo langą. Tačiau jūs vis dar galite slinkti atgal laiku. 

Ir aš ruošiuosi pakartotas Padaryti eilutę. Kirsti mano pirštai šį kartą, "Enter". Oh my God, jis dirbo. tai rodo, man ilgą paslaptingas komandą tai ką daryti sugeneruotas per žvangėjimas, bet nėra klaidų pranešimų. Taigi suprantame, nors galite gauti visiškai užvaldo su skaičius klaidų pranešimų, jis tiesiog gali būti tai erzina pakopinių efektas, kur klingsėti nesupranta vienas dalykas, o tai reiškia, kad tada nesupranta kitą žodį, arba kitą eilutę. Ir taip jis tiesiog droseliai ant jūsų kodu. Tačiau nustatyti gali būti paprastas. Ir taip visada sutelkti dėmesį į Pats pirmasis linijos produkcija. Ir jei jūs neturite suprantu, tiesiog ieškoti raktažodžius, kurie gali būti užuominos, o eilutės numeris, ir simbolis, kur kad klaida gali būti. 

Dabar leiskite man eiti į priekį ir įveskite taškas velniop, eilutę, įveskite. Hm, tai ne saying hello nieko. Kodėl? Na, žinote, kur jis veikia? 

Tai tikriausiai įstrigo metu kilpa, jei bus, on-line šešių, nes Gauk String konstrukcijos, parašyta CS50 darbuotojų, yra tiesiog reiškė tiesiog sėdėti ten laukia, ir laukia, ir laukia eilutę. Visi mes vadiname eilutę yra žmogaus įėjimo. Taigi jūs žinote, ką? Leiskite man eiti į priekį. Ir tik dėl užgaidos, leiskite man įrašykite savo vardą, Dovydą, įveskite. Dabar turiu daugiau dinamišką programą. Jis sakė, labas Davidas. 

Jeigu aš eiti į priekį ir vėl paleisti tai, leiskite man pabandyti pasakyti Zamila vardą, įveskite. Ir dabar mes turime dinamišką programą. Aš ne sunku koduojami pasaulį. Aš ne sunku koduojami pavadinimas arba Deividai, ar Zamila. 

Dabar tai daug labiau patinka programų mes žinome, kur, jei reikia, įvesties, ji gamina šiek tiek kitokią produkciją. Dabar, tai nėra geriausias vartotojo patirtį, arba UX. Aš paleisti programą. 

Aš nežinau, ką aš turėtų daryti, jei aš iš tikrųjų pažvelgti ar prisiminti kodą. Taigi padarykime vartotojui patirti šiek tiek geriau su paprasčiausias dalykų. Leiskite man eiti atgal į tai programa, ir tiesiog pasakyti printf. 

Ir leiskite man eiti į priekį ir pasakyti vardą, dvitaškis, ir erdvė, ir tada pusiau-gaubtinės žarnos. Ir tik prasideda ne tarpelis N. Ir tai sąmoningas, nes aš nenoriu operatyvus perkelti į kitą eilutę. 

Noriu, vietoj to, tai padaryti, eilutę perkompiliuoti savo kodą į naują mašiną kodas taškas velniop eilutę. Ak, tai daug gražiau. Dabar aš tikrai žinau, ką kompiuteris nori man padaryti, suteikti jai pavadinimą. 

Taigi, aš ruošiuosi eiti į priekį ir įveskite į Rob, įveskite ir labas, Rob. Taip, reikia suprasti,, tai yra vis dar, pabaigoje dienos, tik devynios eilutės programa. Bet mes atlikome šiuos kūdikių veiksmus. 

Mes rašė vieną liniją, su kuria mes buvo pažįstamas, printf, Hello world. Tada mes undid truputį, kad. Ir mes iš tikrųjų naudoti get eilutę. Ir mes blaškoma šią vertę į kintamąjį. Ir tada mes nuėjome į priekį ir pagerino Be to, su trečiąja linija. Ir tai iteracinis procesas Rašymas Software tikrai raktas. Be CS50 ir gyvenime apskritai, Jūs paprastai neturėtų atsisėsti, turėti programą galvoje, ir bandyti rašyti visa velniškai dalykas visus iš karto. 

Jis bus neišvengiamai sukelti būdu daugiau klaidų nei mes patys čia matė. Net aš, iki šios dienos, nuolat atlikti kitus kvailus klaidų, yra tikrai sunkiau klaidų kad yra sunkiau išsiaiškinti. Bet jūs padaryti daugiau klaidų daugiau eilučių kodo rašote visi iškart. Ir todėl šis praktika, rašyti truputį kodas kad esate patenkintas, kaupia tai, paleiskite jį, išbandyti jį apskritai tada pereiti on-- taip kaip mes nuolat sluoksniavimasis ir sluoksniavimasis praėjusią savaitę, statybos nuo kažko labai paprasta kažką sudėtingesnio, daryti tą patį čia. Nesisėskite, ir bandyti rašyti visą problemą. Tiesą sakant imtis šių kūdikių veiksmus. 

Dabar, stygos ne visi kad naudinga pas save. Mes norime iš tikrųjų, idealiu atveju, kaip į turi kažkas mūsų priemonių rinkinį. Taigi leiskite tikrųjų būtent tai. 

Leiskite man eiti į priekį ir dabar pakelti šiek tiek kitokią programą. Ir mes tai vadiname int.c, už sveikojo skaičiaus. Aš ruošiuosi panašiai įtraukti CS550.h. Aš ruošiuosi būti standartinis IO. Ir tai bus gana dažnai šiose pirmas kelias dienas po klasės. 

Ir aš ruošiuosi pasiruošę aš su pagrindinės funkcijos. O dabar vietoj gauti eilutę, eikime į priekį ir gauti int. Leiskite ją vadina aš ir vadina tai gauti INT, artimi skliaustų, kabliataškis. O dabar padarykime kažkas su juo, printf. 

Tarkime, kad kažką panašaus Sveiki, Backslash N, kablelis aš. Taigi, aš gana daug mėgdžiodami ką aš padariau vos prieš akimirką. Turiu rezervuotą vietą čia. Aš kableliu Aš čia, nes noriu prijungti i į tą rezervuotą vietą. 

Taigi eikime į priekį ir pabandyti Sudarant šią programą. Šis failas yra vadinamas int.c. Taigi, aš ruošiuosi pasakyti, kad int, įveskite. Oh my God, bet nieko baisaus, tiesa? Yra klaida. 

Yra sintaksės klaida čia toks, kad programa negali būti rengiami viduje int.c, linijos septyni, charakteris 27, klaidų formatas nurodoma tipo char žvaigždė, nepaisant, kad yra. Tačiau šis argumentas tipas int. 

Taigi čia taip pat mes neketiname to-- nors šiandien yra daug medžiagos, mes ketiname sukrėsti tave su absoliučiai kiekvienas C funkcija, ir programavimo apskritai vos šių pirmąsias kelias savaites. Taigi ten dažnai bus žargonu su kuria nesate susipažinę. Ir, iš tiesų, simbolis žvaigždė yra kažkas mes ketiname grįžti į per savaitę arba du laiko. 

Bet dabar, pažiūrėkime, jei mes galime apdoroti žodžius, kurie yra susipažinę. Skirtingus formatus taip išgirdome formatą specifikatorius, formatas kodas anksčiau. Štai pažįstamas. Type-- bet argumentas tipo int. Palaukit, i int. 

Gal proc -ai tikrųjų turi apibrėžtą prasmę. Ir, iš tiesų, ji daro. Sveikas, jei norite printf jį pakeisti, jūs iš tikrųjų turite naudoti skiriasi formatas specifikatorius. Ir jūs nežinote tai nebent kas nors Jums sakė, ar jums buvo prieš tai padarė. Bet proc i ką gali būti visuotinai naudojamas į printf įkišant į sveikojo skaičiaus. Taip pat galite naudoti procentų D dešimtainis sveikasis skaičius. Bet aš tai gražus ir paprastas čia. Taigi mes eiti su tuo. 

Dabar leiskite man eiti į priekį ir pakartotinis makiažo INT, Enter. Tai gerai, jokių klaidų. Dot velniop int-- Ok, blogas vartotojo patirtį, nes aš nepasakiau sau ką daryti. Bet tai gerai. Aš gaudyti ant greitai. 

O dabar leiskite man eiti į priekį ir įveskite Dovydą, OK, Zamila, Rob. Gerai, kad tai yra geras dalykas. Šį kartą, aš naudoju funkciją, Dėlionė gabalas, vadinamas Gauti int. Ir paaiškėja out-- ir mes pamatyti šį Vėliau term-- CS50 darbuotojai įdiegė gauti eilutę tokiu būdu, kad tai bus tik fiziškai gauti eilutę jums. 

Ji įgyvendino get int į tokiu būdu, kad tik jis bus gauti sveikąjį skaičių už jus. Ir jei jūs, žmogaus, nebendradarbiauja, tai tiesiog tik ketina pasakyti pakartoti, pakartoti, pakartoti, tiesiog sėdi ten apsisukimo, kol Jūs įpareigoti su kai magišką skaičių, kaip 50, and hello 50. 

Arba, jei mes paleisti tai vėl ir tipo 42, labas 42. Ir taip GET INT funkcija viduje tą įspūdį yra pakankamai logika, pakankamai mintis, išsiaiškinti, kas yra žodis? Ir kas yra skaičius? Tik priimdamas galiausiai numeriai. 

Todėl Pasirodo, kad tai yra ne visi, kad išraiškingas. iki šiol. Taigi, Yay, paskutinį kartą mes ėjo gana greitai į įgyvendinimo žaidimai, ir animacija, ir meniniai darbai nulio. Ir čia mes yra turinys su hello world, and hello 50. 

Tai dar ne viskas, kad įkvepiantis. Ir, iš tiesų, tai pirmas kelias pavyzdžiai užtruks šiek tiek laiko kelią iki visų įspūdžių. Bet mes turime daug daugiau kontroliuoti dabar, iš tikrųjų. Ir mes ketiname labai greitai pradėti sluoksniavimasis ant šių pagrindinių primityvų. 

Bet pirmiausia, tegul supranta ką apribojimai. Iš tiesų, vienas iš dalykų, Įbrėžimams nėra lengvai darykime tai tikrai atrodo po gaubtu, ir suprasti, kas yra kompiuteris, ką ji gali padaryti, ir ką jos apribojimai yra. Ir, tiesą sakant, kad trūksta supratimas, potencialiai ilgalaikis gali sukelti mūsų mistakes-- raštu klaidas, rašymo nesaugus programinę įrangą, kuri laužiami tam tikru būdu. 

Taigi leiskite šiek tiek žingsnių suprasti tai šiek tiek geriau būdas, tarkim, tokį pavyzdį. Aš ruošiuosi eiti į priekį ir įgyvendinti nekilnojamojo greitai programa, vadinama padidinimai. Kaip, Pridėkime keletą numerius kartu. Ir aš ruošiuosi kodą keletą kampus čia, ir tiesiog nukopijuokite ir įklijuokite kur buvau anksčiau, tiesiog todėl mes galime pradėti žaisti greičiau. Taigi dabar aš turiu pagrindinius pradžią apie programą "angis. 

Ir eikime į priekį ir tai padaryti. Aš ruošiuosi eiti į priekį ir tarkim, intx gauna gauti int. Ir žinote ką? Kurkime geresnį vartotojų patirtį. 

Taigi galime tik pasakyti, x yra, ir efektyviai raginimas vartotojui suteikia mums x. Ir tada leiskite man eiti į priekį ir pasakyti, printf kaip apie y, šį kartą laukiasi Abu šie dydžiai nuo naudotojo. Ir tada tegul tiesiog eiti į priekį ir tarkim, printf, X ir y suma yra. Ir dabar aš nenoriu daryti proc s. Noriu daryti proc i, Backslash N, o tada prijunkite suma vertę. 

Taigi, kaip aš galiu eiti apie tai daryti? Zinai ka? Aš žinau, kaip naudoti kintamuosius. Leiskite man tiesiog paskelbti naują, int z. 

Ir aš ruošiuosi imtis atspėti čia. Jei yra lygios ženklai tai kalba, o gal galiu tiesiog x plus y tol, kol aš galų mano maniau su kabliataškiu? Dabar galiu eiti atgal čia, prijunkite z, baigti šį minties su kabliataškiu. Ir pažiūrėkime dabar, jei jie sekos lines-- X yra gauti int. Y yra gauti int. 

Pridėti x ir y, saugoti vertės z-- Taigi, vėl prisiminti lygybės ženklą nėra lygus. Tai užduotis iš dešinės į kairę. Ir tegul atsispausdinti, kad suma iš X ir Y yra ne pažodžiui Z, bet kas viduje Ž. Taigi padarykime padidinimai - gražus, jokių klaidų šiuo metu. Dot velniop padidinimai, įveskite, x bus 1 d. 

Metai bus 2. Ir x ir y suma yra 3. Taigi, kad viskas gerai ir gerai. 

Taigi jums būtų įsivaizduoti, kad matematikos turėtų dirbti programą, kaip šis. Bet žinote ką? Ar šis kintamasis, linija 12, netgi būtina? Jums nereikia gauti į įpročiai tiesiog laikyti dalykų kintamųjų tik todėl, kad jūs galite. Ir, iš tiesų, tai paprastai apgalvoto blogas dizainas jeigu kuriate kintamąjį, vadinamas Z šiuo atveju, saugoti kažką į jį, ir tada iš karto naudojant jį, bet niekada vėl. Kodėl ką nors duoti vardą kaip z, jei esate tiesiog ketinate naudoti, kad dalykas tik vieną kartą, ir taip proksimalinio, kur jūs sukūrėte ji į pirmąją vietą, taip arti požiūriu eilučių kodo? Taigi jūs žinote, ką? Pasirodo, kad C yra gana lanksti. Jei aš iš tikrųjų noriu plug-in vertybių čia Man nereikia deklaruoti naują kintamąjį. Galėčiau tik plug-in x plius Y, nes C supranta aritmetika, ir matematiniai operatoriai. 

Taigi aš galiu tiesiog pasakyti, tai padaryti matematiką, x plius Y, nepriklausomai nuo tos vertės, prijunkite gautas sveikasis skaičius į tą eilutę. Taigi, tai gali būti, nors tik viena eilutė trumpesnė, geriau dizainas, geresnis programa, nes ten mažiau kodas, todėl mažiau už mane suprasti. Ir tai taip pat tik siurblys, kiek mes ne naujų žodžių, naujus simbolius, kaip z, nors jie nelabai tarnauti daug tikslu. 

Deja, matematika nėra Visa tai patikimi kartais. Vykime į priekį ir tai padaryti. Aš ruošiuosi eiti į priekį dabar ir atlikite šiuos veiksmus. 

Darom printf, proc I, plius proc i turi būti procentų i Backslash N. Ir aš ruošiuosi daryti this-- xyx plius m. Taigi, aš tik ketina perrašyti tai šiek tiek kitaip čia. Leiskite tai padaryti greitai naudojama logiškai patikrinimą. Vėlgi, tegul ne gauti prieš save. Padaryti padidinimas, DOT velniop angis. x yra 1, y yra 2, 1 plius 2 yra 3. Taigi, kad gerai. Bet tegul komplikuoti tai dabar šiek tiek, ir sukurti naują failą. 

Aš ruošiuosi skambinti šį vieną, pasakyti, ints, Val už sveikieji skaičiai. Leiskite man pradėti, kur buvau prieš momentas. Bet dabar padarykime keletą kitų linijų. Leiskite man eiti į priekį ir atlikite šiuos veiksmus, printf, proc i atėmus proc i yra procentai i kablelis x kablelis yx atėmus m. Taigi darau šiek tiek skiriasi matematikos ten. Darom kitą. Taigi proc i karto proc i proc i Backslash N. Leiskite plug-in X ir Y ir X kartų y. Mes naudosime žvaigždutę ant Jūsų kompiuteris kartus. 

Jūs negalite naudoti x. x yra kintamojo vardas čia. Galite naudoti dauginimo žvaigždė. Darom vienas. Printf proc aš, padalintas iki proc i, yra procentai i Backslash N. XY, padalytą iš y-- todėl jūs naudojate įstrižas brūkšnys į C daryti padalinys. Ir darykime vienas kitas. Likęs proc i, padalintas iki proc i, yra procentai aš. xy-- ir dabar likusi yra tai, kas liko. Kai bandote dalijant vardiklis į skaitiklį, kiek yra likę, kad tu negali padalinti iš kitų? 

Taigi ten tikrai ne, nebūtinai, simbolis mes naudojamas pradinėje mokykloje už tai. Bet ten C. Galite pasakyti x modulį y kur Tai procento ženklas šioje context-- klaidinančiai, kai esate viduje dvigubų kabučių, Viduje printf, proc naudojamas kaip formato specyfikator. 

Kai naudojate proc ribų kad matematinė išraiška, tai tas modulį operatorius modulinės arithmetic-- mūsų tikslais čia tiesiog reiškia, kas yra Likusi x padalytą y? Taigi x padalytą y yra x velniop m. Kokia x likusi padalytą Y? Tai x mod y, kaip programuotojas pasakytų. 

Taigi, jei aš padariau ne klaidų čia, leiskite man eiti į priekį ir padaryti ints, Val, gražus, ir taškas pasvirasis brūkšnys ints. Ir eikime į priekį ir padaryti, tarkim, 1, 10. Gerai, 1 plius 10 yra 11, patikrinimas. 1 minus 10 yra neigiamas 9, patikrinkite. 

1 kartų 10 10, patikrinimas. 1, padalytą iš 10 is-- Gerai, mes praleisti, kad vienas. Likusi 1, padalytą iš 10 yra 1. Teisingai. Bet ten klaida čia. 

Taigi vienas aš įdėti savo perduoti, nėra teisinga. Aš turiu galvoje, tai artimas 0. 1, padalytą iš 10, žinote, jei mes pjovimo keletą kampus, tikrai, tai nulis. Bet tai tikrai turėtų būti 1/10, 0,1 arba 0,10, 0.1000, ar kt. 

Tai tikrai neturėtų būti lygus nuliui. Na, it turns out, kad kompiuteris yra daro tiesiog tai, ką mes papasakojo daryti. Mes darome matematikos kaip apskaičiuojamas dalijant x iš y. Ir abu x ir y, per linijų kodo anksčiau, yra sveikieji skaičiai. 

Be to, on-line 15, mes esame sakau printf, ei, printf Plug-in sveikasis skaičius, plug-in sveikasis skaičius, plug-in yra integer-- specialiai x, ir tada Y, ir tada x padalytą m. X ir Y yra ints. Mes gerai ten. 

Bet kas yra x, padalytą iš X? x, padalytą iš Y turėtų būti, matematiškai, 1/10 arba 0,1, kuris yra tikras skaičius, realus skaičius turintys, gal net kablelio. Tai nėra sveikasis skaičius. 

Bet kas yra arčiausiai sveikasis skaičius 1/10, arba 0,1? Taip, tai rūšies yra lygus nuliui. 0,1 yra tokia daug. Ir 1 tai daug. Taigi 1/10 yra arčiau 0, nei ji yra viena. 

Ir taip kas C darai us-- rūšies, nes mes papasakojo to-- yra trumpinamas, kad sveikasis skaičius. Tai atsižvelgiant į vertę, kuri vėl yra turėtų būti kažkas panašaus į 0.1000, 0 ir taip toliau. Ir tai nutraukiant viską po kablelio taip, kad visa tai Daiktai, nes ji nėra tilptų į sveikojo skaičiaus sąvoką, kuri yra tik kaip neigiamas 1, 0, 1 numeris aukštyn ir žemyn, jis išmeta viską po kablelio, nes jūs netelpa kablelio į pagal apibrėžimą sveikojo skaičiaus. 

Todėl čia atsakymas yra lygus nuliui. Taigi, kaip mes išspręsti šią problemą? Mes turime kitą sprendimą visi kartu. Ir mes galime tai padaryti, taip. 

Leiskite man eiti į priekį ir kurti naujas failą, tai vienas vadinamas floats.c. Ir išsaugokite jį čia į pats katalogas, float.c. Ir leiskite man eiti į priekį ir kopijuoti kai tos kodą iš anksčiau. 

Bet užuot int, tegul tai padaryti. Duok man slankiojo kablelio skaičius vadinamas x. kai slankiojo kablelio vertė yra tik pažodžiui kažkas su kintamomis kablelio. Jis gali judėti į kairę, į dešinę. Tai realus skaičius. 

Ir leiskite man skambinti ne gauti int, bet ir gauti plūdę, kuris taip pat buvo tarp meniu iš variantų C250 bibliotekoje. Keiskime Y trintuve. Taigi tai tampa gauti plūdę. 

Ir dabar, mes nenorime prijungti int. Pasirodo, mes turime naudoti procentų F plūdės, proc F plūdės, ir dabar išsaugokite jį. Ir dabar, kumščius, kad plūdės, Nica, dot pasvirasis brūkšnys plūdės. x bus vienas 1. Y Bus 10 dar kartą. 

Ir gražus, gerai mano papildymas yra teisinga. Aš tikėjausi daugiau, bet aš pamiršau parašyti. Taigi eikime ir išspręsti šią loginę klaidą. 

Vykime į priekį ir patraukti toliau. Mes tiesiog padaryti šiek tiek kopijuoti ir įklijuoti. Ir aš ruošiuosi pasakyti minusas. 

Ir aš ruošiuosi pasakyti kartus. Ir aš ruošiuosi pasakyti padalintas. Ir aš neketinu daryti modulo, kuris yra ne kaip Germane čia, padalytą iš F ir laikai plus-- Gerai, tegul tai padaryti dar kartą. 

Padaryti plūdes, dot pasvirasis brūkšnys plūdes, ir 1, 10, and-- gražus, ne, Gerai. Taigi, aš idiotas. Taigi tai yra labai dažnas kompiuterių mokslo padaryti kvailų klaidų kaip šis. 

Dėl švietimo tikslais, ką aš tikrai norėjau padaryti buvo pakeisti mokslą čia į pliuso, minusas, kad kartais, ir padalinti, kaip jūs, tikiuosi, pastebėjau per šį pratimą. Taigi, dabar tegul iš naujo kompiliuoti tai programa, tai dot velniop plūdės. 

Ir trečią kartą, tegul pamatyti, jei ji atitinka mano lūkesčius. 1, 10, įvesti, taip, gerai, 1.000, padalytą iš 10000, yra 0,100000. Ir paaiškėja, mes galime kontroliuoti, kiek numeriai yra po šių ženklų po kablelio tikslumu. Mes iš tikrųjų bus. Mes grįžti prie to. 

Bet dabar, iš tiesų, matematika yra teisinga. Taigi, vėl, kas yra Takeaway čia? Pasirodo, kad C, yra ne tik tiesiog strings-- ir, tiesą sakant, ten tikrai ne, nes mes pridėti tiems, su CS50 bibliotekoje. Tačiau yra ne tik ints. 

Taip pat yra plūdės. Ir paaiškėja, daug kitų duomenų krūva rūšys taip pat, kad mes naudosime prieš ilgas. Pasirodo, jei norite vieno charakteris, o ne simbolių eilutė, galite naudoti tik char. 

Pasirodo, kad jei norite Bool, Būlio vertė, true arba false tik dėka CS50 bibliotekoje, mes įtraukta į C bool tipo duomenų, taip pat. Bet jis taip pat pristatyti daugelis kitų kalbų, taip pat. Ir paaiškėja, kad kartais jums reikia didesnių numerius tada ateis pagal nutylėjimą su int ir plūdės. 

Ir, iš tikrųjų, dvigubas yra skaičius kad naudoja ne 32 bitų, bet 64 bitus. Ir gana ilgo yra skaičius, kuris naudoja ne 32, bitai, bet 64 bitus, atitinkamai, už slankiojo kablelio vertybės ir sveikieji skaičiai, atitinkamai. Tad tikrai dabar pamatyti šį veiksmą. 

Aš ruošiuosi eiti į priekį čia ir pakelti vieną kitą programą. Čia aš ruošiuosi eiti į priekį o yra CS50.h. Ir leiskite man eiti, apima standartinį IO.h. 

Ir jūs pastebėsite kažką funky, kas vyksta čia. Tai ne spalvine dalykų taip pat, kaip tai darė anksčiau. Ir it turns out, kad todėl, kad aš nedavė dalykas failo pavadinimą. 

Aš ruošiuosi skambinti šį vieną sizeof.c ir paspauskite Saugoti. Ir pastebėti, kas atsitinka su mano labai balta kodas prieš tą juodą foną. Dabar, bent jau ten kai violetinė ten. Ir tai yra sintaksė paryškintas. 

Tai todėl, kad, paprasčiausiai, aš sakė IDE kokio tipo failą tai suteikiant jam pavadinimą ir specialiai failo plėtinį. Dabar galime eiti į priekį ir tai padaryti. Aš ruošiuosi eiti į priekį ir labai tiesiog atsispausdinti following-- bool yra proc GV. 

Mes grįžti į kad vos akimirką. Ir tada aš ruošiuosi spausdinimo dydį bool. Ir dabar, tik sutaupyti aš šiek tiek laiko, aš ketinate daryti vieną visumą krūva iš jų vienu metu. Ir būtent, aš ruošiuosi pakeisti į char ir char. Tai vienas, aš ruošiuosi keisti dvigubo ir dvigubai. 

Tai vienas, aš ruošiuosi keisti į plūdę ir plūdės. Tai vienas, aš ruošiuosi pakeisti į int ir int. Ir tai viena, aš ruošiuosi pakeisti į ilgas ilgas. Ir tai dar vartojate ilgą laiką, kol ilgai. 

Ir tada, pagaliau, daviau pats vienas per daug, eilutė. Pasirodo, kad C, ten specialus operatorius vadinamas dydis tai tiesiog ketina, kai paleisti, pasakyti mums dydį kiekvienas iš šių kintamųjų. Ir tai yra būdas, dabar, galime prijungti atgal į praėjusios savaitės diskusijų Duomenų ir atstovavimo. 

Leiskite man eiti į priekį ir kaupia dydis dot slash dydžio. Ir pažiūrėkime. Pasirodo, kad C, konkrečiai CS50 IDE, specialiai dėl Operacinė sistema Ubuntu, kuris yra 64-bitų operacinėje sistema šiuo atveju, bool ketina naudoti vieną baitą erdvėje. Štai kaip dydis matuojamas, ne bitais, bet baitais. Ir prisiminti, kad vienas baitas yra aštuoni bitai. Taigi bool, net jei techniškai reikia tik 0 arba 1, tai šiek tiek kainuojančio kaip mes ją įgyvendino. Tai iš tikrųjų ketinate naudoti vieną visumą byte-- todėl visi nuliai, yra gal visi tie, ar kažkas panašaus, ar tik vienas 1 tarp aštuonių bitų. 

Char, tuo tarpu, naudojamas pobūdžio kaip ASCII simbolių per paskutinę savaitę, bus vienas simbolis. Ir tai synchs su mūsų samprata jis yra ne daugiau nei 256 bits-- o, synchs su juo nesant ilgiau nei 8 bitai, kurie suteikia mums daugiau kaip 256 vertybes. Dvigubas ketina būti 8 baitų arba 64 bitų. 

Plūduras yra 4. Int yra 4. Ilgas, ilgas yra 8. Ir eilutė yra 8. Bet nesijaudinkite apie tai. Mes ketiname žievelės atgal, kad sluoksnis. Pasirodo, stygos gali būti ilgesnis nei 8 baitai. 

Ir, tiesą sakant, mes parašiau Stygos jau Hello world, ilgiau nei 8 baitai. Bet mes grįžti į kad vos akimirką. Bet atimti čia yra tokia. 

Kiekvienas kompiuteris turi tik ribotas atminties kiekis ir erdvėje. Galite tik saugoti tiek daug failai jūsų Mac arba PC. Galite išsaugoti tik tiek daug programas RAM veikia vienu metu, nebūtinai, net su virtualios atminties, nes turite baigtinių sumą RAM. 

Ir tik picture-- jei Jūs niekada atvėrė nešiojamas arba užsisakyti papildomą atminties už kompiuterio, jums gali nežinoti, kad viduje kompiuterio yra kažkas, kad atrodo kaip ši mažai. Taigi tai yra tik bendras įmonės pavadinimą Svarbu, kad daro RAM kompiuterius. Ir RAM Kai programos gyventi, o jie veikia. 

Taigi kiekvienu Mac arba PC, kai dukart spustelėkite programą, ir tai atveria, ir ji atveria šiek Word dokumentas arba kažkas panašaus, ji saugo ją laikinai RAM, nes RAM greičiau nei kietajame diske, arba Jūsų kietojo disko. Taigi, tai tik ten, kur programos eiti gyventi, kai jie veikia, arba kai yra naudojami failai. 

Taigi jūs turite tai, kas atrodo kaip šis jūsų nešiojamojo kompiuterio viduje, ar šiek tiek didesni dalykai viduje darbalaukyje. Bet svarbiausia yra jūs turite tik baigtinis skaičius šių dalykų. Ir yra tik baigtinis dydis aparatūros sėdi ant šio stalo teisė čia. 

Taigi, žinoma, mes negalime laikyti be galo ilgi numeriai. Ir dar, jei jūs manote, grįžti į Mokyklos, kiek skaitmenų gali jūs turite dešinę iš dešimtainio taško? Šiuo klausimu, kiek skaitmenų gali turite prie kairę nuo dešimtainio kablelio? Tikrai, be galo daug. 

Dabar, mes, žmonės, tik galėtų žinoti, kaip ištarti milijonai ir milijardus, trilijonus ir Kwadrylion ir kvintilijonas. Ir aš stumti ribas Mano understanding-- arba my-- suprantu numeriai, bet mano tarimas numerius. Tačiau jie gali gauti be galo didelio su galo daug skaitmenų kairėje arba prie dešimtainio taško teisę. 

Bet kompiuteriai turi tik ribinis dydis atminties, baigtinis skaičius tranzistorių A baigtinis skaičius lemputes viduje. Taigi, kas atsitinka, kai paleisti iš vietos? Kitaip tariant, jei tau prisiminkite paskutinę savaitę kai mes kalbėjome apie skaičių patys yra atstovaujama dvejetainis, Tarkime, kad mes turime tai 8 bitų vertė čia. 

Ir mes turime septynis 1 "ir vieną 0. Ir manau, kad mes norime pridėti 1 iki šios vertės. Tai tikrai didelis skaičius dabar. 

Tai 254, jei aš atsimenu matematikos nuo praėjusią savaitę dešinėje. Bet kas, jei aš pakeisiu kad dešinė 0 į 1? Sveikasis skaičius, iš Žinoma, tampa aštuonių 1 s. Taigi mes vis dar geras. 

Ir tai tikriausiai yra 255, nors priklauso nuo konteksto ir ji iš tikrųjų gali atstovauti neigiamas skaičius. Bet daugiau apie tai kitą kartą. Tai jaučiasi tai apie kaip aukštas, kaip aš galiu pasitikėti. 

Dabar, tai tik 8 bitus. Ir mano Mac ", žinoma, yra būdas daugiau nei 8 bitai atminties. Bet ji turi ribotas. Taip tas pats argumentas taikomas, net jei mes turėti daugiau iš šių tie ekrane. 

Bet kas atsitinka, jei esate saugoti šį numerį 255, ir norite skaičiuoti 1 šiek tiek didesnis? Jūs norite eiti nuo 255 iki 256. Problema, žinoma, yra, kad jei pradėti skaičiuoti iki nulio, kaip praeitą savaitę, Jums negali tikėtis tokio pat aukščio kaip 256, jau nekalbant apie 257, jau nekalbant apie 258 m, nes tai, ką atsitinka, kai jūs pridėti 1? Jei seną pradinėje mokykloje požiūris, jūs įtraukėte 1 čia ir tada 1 plius 1 yra 2, bet tai tikrai nulis, nešiodami 1, atlikti 1, nešti 1 d. Visi šie dalykai, Šios 1 s, eikite iki nulio. Ir jūs baigti taip, kaip kažkas nurodė, a 1 kairėje pusėje. Bet viskas, ko jums gali realiai pamatyti ir tilptų atmintyje yra tik aštuoni 0 ųjų, kuri yra pasakyti tam tikru momentu, jei jus, kompiuteris, Bandžiau skaičiuoti pakankamai aukštai, jūs vyksta į kuriuos vyniojami aplink, atrodo, nuliui, o gal net neigiamas numeriai, kurie yra dar mažesnis už nulį. 

Ir mes galime rūšies pamatyti tai. Leiskite man eiti į priekį ir rašyti nekilnojamojo greitai programa čia. Leiskite man eiti į priekį ir rašyti programa, vadinama Perpildyta. Įtraukti CS50.h, apima standartinis IO.h-- oh, Aš tikrai praleidau savo sintaksės. Taigi leiskite Išsaugoti kaip overflow.c. 

Ir dabar int main void-- ir prieš ilgas, mes grįžti į paaiškinti, kodėl mes nuolat raštu int main negaliojančiu. Bet dabar, tegul tiesiog padaryti jis, atsižvelgiant savaime suprantamu dalyku. Duokime sau int, inicijuoti ir ją iki 0. 

Tegul tada s padaryti int gaunu zero-- Tiesą sakant, darykime begalinis ciklas ir pamatyti, kas atsitiks. Nors tiesa, tada tegul atsispausdinti N yra procentai i Backslash N, plug-n. Bet dabar, darykime N gauna n plius 1. 

Taigi, kitaip tariant, kiekvienas iteracijos šio begalinis ciklas, Paimkime N vertę, ir pridėti 1 į jį, ir tada saugoti rezultatą atgal į n kairėje pusėje. Ir, tiesą sakant, mes matėme sintaksė šiek tiek panašaus į tai, trumpai. Cool Apgaulė yra vietoj rašyti visa tai iš, jūs iš tikrųjų galite pasakyti N plius lygus 1. 

Arba, jei jūs tikrai norite būti išgalvotas, galite pasakyti n plius plius kabliataškis. Tačiau pastarieji du yra tiesiog ką mes norime paraginti sintaksinis cukraus pirmą dalykas. 

Pirmas dalykas yra aiškesnis, visiškai gerai, visiškai teisinga. Bet tai yra daugiau bendro, aš pasakyti. Taigi mes padarysime tai už tik akimirkai. 

Leiskite dabar padaryti perpildymo, kuris skamba o grėsmingas, taškas velniop perpildymo. Pažiūrėkime, N manimi gauti gana didelis. Bet pagalvokime, kaip didelis gali N gauti? 

n yra tarpinis junginys. Mes matėme prieš akimirka su dydžiu pavyzdys, kad int yra keturi baitai. Mes žinome iš praeitą savaitę, keturi baitai yra 32 bitų, nes 8 kartus 4, tai 32. Štai bus 4 mlrd. 

Ir mes iki 800,000. Tai ketina imtis amžinai tikėtis tokio pat aukščio kaip aš galbūt galite. Taigi, aš ruošiuosi eiti į priekį, kaip jums gali, prieš ilgą, ir paspauskite Control C-- atvirai, kontrolės C daug, kai kontrolės, C paprastai priemonės atšaukti. Deja, nes tai veikia debesyje, kartais debesis spjaudė iš tiek daug dalykų, tiek daug produkcijos, jis ketina užtrukti mano indėlis patekti į debesis. Taigi, nors aš paspauskite Valdymo C prieš kelias sekundes, tai tikrai pusė poveikis begalinis ciklas. 

Ir taip tokiais atvejais mes ketina palikti, kad būtų. Ir mes ketiname pridėti dar terminalo langą per čia su pliuso, kuris, žinoma, ne panašaus, nes jis vis dar galvoju. Ir eikime į priekį ir būti šiek tiek labiau pagrįsta. 

Aš ruošiuosi eiti į priekį ir daryti tai tik žinoma daug kartų. Leiskite naudoti for ciklas, kurį aš užsiminiau anksčiau. Padarykime tai. Duok man dar vieną kintamąjį int i gauna 0. i yra mažiau nei, tarkim, 64 i ++. O dabar leiskite man eiti į priekį ir spausdinti iš n proc i kableliu N. Ir tada n-- tai dar ketina imtis amžinai. Padarykime tai. 

N gauna n kartų 2. Arba galėtume būti išgalvotas ir daryti kartų lygus 2. Bet tegul tiesiog pasakyti n lygi pati laikai 2. Kitaip tariant, į tai nauja versija programos, Aš nenoriu laukti amžinai iš, kaip 800,000 iki 4 mlrd. Tegul tik gauti šią per su. 

Leiskite tikrųjų dvigubai N kiekvieną kartą. Kuris, prisiminti, dvejinimo yra priešais turėti, žinoma. Ir kadangi praėjusią savaitę turime kažkas ir vėl, ir vėl, ir vėl, super greitai, padvigubinti, be abejo, gauti mus nuo 1 iki galimas didžiausias vertė, galime tikėtis, kad su tarpt. 

Taigi darykime tiksliai tai. Ir mes grįžti prie šio prieš ilgas. Tačiau tai, dar kartą, yra tik kaip kartojimo blokas nulio. Ir jūs naudojate tai prieš ilgai. 

Tai tiesiog reiškia skaičių nuo nulio iki, bet nėra lygus, iki 64. Ir kiekviename Šiam iteracijos kilpa, tiesiog laikyti incrementing i. Taigi i ++ - ir tai apskritai konstruktas on-line 7 yra tiesiog super paplitęs būdas kartoti keletą eilučių kodas, kai kurie iš karto. Kuris eilučių kodo? Šie garbanotas petnešos, kaip jūs galėjo surinktą iš dabar reiškia, atlikite šiuos veiksmus. 

Jis yra kaip naujo, kai ji turi geltona blokų ir kitos spalvos, kad šios rūšies priimti ar apkabinti kitus blokus. Štai ką tie garbanoti petnešos darai čia. Taigi, jei aš gavau mano sintaksė right-- jus galite pamatyti morkų simbolį C priemonėmis tai kiek kartų buvau bando išspręsti šią problemą. Taigi galime atsikratyti, kad vienas apskritai, ir uždaryti šį langą. Ir mes naudosime naują. Padaryti perpildymo, dot velniop perpildymo, "Enter", visos teisės, atrodo neblogai pirmas. Bet tegul slinkti atgal laiku, nes Aš tai 64 kartų. 

Ir pranešimas pirmą kartą, n yra 1. Antrą kartą, n yra 2, tada 4, tada 8, tada 16. Ir atrodo, kad kuo greičiau Gaunu maždaug 1 mlrd, jei aš dvigubai jį dar kartą, kad turėtų duoti man 2 mlrd. Bet pasirodo, tai tiesiai ant smaigalys. 

Ir taip iš tikrųjų perpildymo int nuo 1 mlrd iki maždaug neigiamas 2 milijardų, nes sveikasis skaičius, skirtingai skaičius, kurių buvo prisiimti praėjusią savaitę, gali būti tiek teigiamas ir neigiamas iš tikrųjų ir į kompiuterį. Ir todėl bent vienas iš tų, bitai yra veiksmingai pavogtas. Taigi mes tikrai turime tik 31 bitai, arba 2 mlrd galimos reikšmės. 

Bet dabar, Takeaway yra gana tiesiog, nepriklausomai šie skaičiai yra ir kokia matematika yra, kažkas blogo atsitiks, galų gale, nes galiausiai bandote Iškeisti bitai vienas per daug kartų. Ir jūs efektyviai eiti iš visų 1 s gal visi 0 s, o gal tiesiog kai kurie kiti rašto, kad jo aiškiai, priklauso nuo konteksto ir, gali būti aiškinama kaip neigiamas skaičius. Ir taip atrodytų aukščiausią I gali tikėtis šioje konkrečioje programoje yra tik maždaug 1 mlrd. Bet yra dalinis sprendimas čia. Zinai ka? 

Leiskite keisti iš int į ilgas ilgas. Ir leiskite man eiti į priekį čia ir say-- Aš ruošiuosi pakeisti tai nepasirašytas ilgai. Arba pažiūrėkime, aš niekada prisiminti save. 

Vykime į priekį ir padaryti perpildymo. Ne, tai ne tai, LLD, ačiū. Taigi kartais klingsėti gali būti naudingas. Aš neprisimenu, ką formatą specifikatorius buvo ilgą laiko. 

Bet, tiesą sakant, klingsėti man pasakė. Žalioji yra kai geras Geras, dar reiškia, kad jūs padarėte klaidą. Tai atspėti, kad aš reiškė LLD. 

Taigi leiskite man pasinaudoti, tai patarimas, ilgas ilgas Dešimtainis skaičius, išskyrus tai, kad. Ir leiskite man pakartotas ją, dot Slash perpildymo, Enter. O dabar kas kietas tai. 

Jei aš slinkti atgal laiku, mes vis dar pradėti skaičiuojant tuo pačiu place-- 1, 2, 4, 8, 16. Atkreipkite dėmesį, mes visi kelią iki 1 mlrd. Bet tada mes saugiai gauti 2 mlrd. 

Tada mes gauti iki 4 mlrd, tada 8 mlrd, 17 mlrd. Ir mes einame didesnis, o aukščiau ir aukščiau. Galų gale, tai irgi pertraukos. 

Galų gale, su ilga ilga, kuris yra 64-bitų reikšmės, o ne 32 bitų vertė, jei skaičiuoti per didelis, jums wrap aplink 0. Ir šiuo atveju, mes atsitikti galų gale su neigiamas skaičius. 

Todėl tai yra problema. Ir ji Pasirodo, kad tai Problema yra ne visi, kad paslaptinga. Nors aš sąmoningai sukeltas jį su šių klaidų, paaiškėja, matome kokios visi aplink mus, arba bent jau kai kurie iš mūsų padaryti. 

Taigi Lego Star Wars, jei jūs kada nors grojo žaidimą, paaiškėja, galite eiti aplink nesilaikantiems viską į LEGO pasaulyje ir rinkti monetas, esmės. Ir jei jūs kada nors grojo Šis žaidimas taip per daug laiko, kaip šis bevardis individo čia padarė, iš viso monetų, kad jūs galite gauti yra, atrodytų, 4 mlrd. 

Dabar, tai tikrai apvali. Taigi Lego bandžiau išlaikyti dalykų patogi. Jie neturėjo daryti tiksliai 2 iki 32 galia, už praeitą savaitę. Bet 4 mlrd yra priežastis. Atrodo, remiantis šia informacija, kad Lego ir kompanija, padarė šį faktinį programinę įrangą, nusprendė kad kuo daugiau monetų vartotojas gali kauptis yra, iš tiesų, 4 milijardus, nes jie pasirinko savo kodą naudoti nėra ilgas ilgas, matyt, bet tik sveikas, nepasirašytas sveikasis skaičius, tik teigiamas sveikasis skaičius, kurio Max vertė yra maždaug tai. Na, čia dar vienas juokingas vienas. Taigi žaidimas Civilizacija, kuri kai kurie iš jūsų gali būti susipažinę su paaiškėja, kad prieš keletą metų ten buvo šiame žaidime, kuriuo klaidą jei suvaidino vaidmenį Gandhi į žaidimą, vietoj jo yra labai pacifistas, o buvo neįtikėtinai, neįtikėtinai agresyvi, esant tam tikroms aplinkybėms. Visų pirma, taip, kad civilizacija darbai, kad jei jūs, žaidėjas, priimti demokratiją, jūsų agresyvumas rezultatas pasireiškia mažėjančią reikšmę iš dviejų, todėl minusas atėmus, tada minusas minuso. 

Taigi jūs atimti 2 nuo Jūsų tikrasis Iteracja. Deja, jei jūsų Iteracja yra Iš pradžių 1, ir jūs atimti 2 iš jos priėmus demokratiją kaip Gandhi čia galėtų padariau, nes jis buvo labai passive-- 1 dėl agresyvumo mastu. Bet jei jis priima demokratiją, tada jis eina nuo 1 iki neigiamo 1 d. 

Deja, jie buvo naudojant nepasirašytas numerius, tai reiškia, jie gydomi net neigiamas numeriai taip, lyg jie buvo teigiami. Ir paaiškėja, kad teigiamas ekvivalentas neigiamas 1, tipiškų kompiuterinių programų, yra 255. Taigi, jei Gandis priima , Todėl demokratija jo agresyvumas rezultatas sumažėjo, ji iš tikrųjų ritininis aplink 255 ir daro jį labiausiai agresyvus charakteris žaidime. Taigi galite google ant tai. Ir tai buvo, Iš tiesų, atsitiktinis programavimo klaida, bet tai įrašyta gana kraštotyros šiol. 

Tai viskas, įdomus ir mielas. Daugiau bauginantis, kai faktinis nekilnojamojo pasaulio įrenginiai, o ne žaidimai, turi tas pačias klaidas. Iš tiesų, vos prieš metus gaminys atėjo sužinoti apie Boeing 787 Dreamliner. 

Ir ne pirmas straipsnis Žvilgsnis skaito mažai slaptas. Bet jis pasakė tai, programinė įranga pažeidžiamumas "Boeing" Naujas 787 Dreamliner srove turi gali sukelti pilotai prarasti kontrolę orlaivis, galbūt viduryje skrydžio, FAA pareigūnai įspėjo oro linijų neseniai. Tai buvo nustatymas kad modelis 787 kad lėktuvas, kuriuo buvo varomas nepertraukiamai 248 dienų gali prarasti visą kintamoji elektros srovė, srovės, elektros energijos dėl to, kad generatoriaus valdymo blokai, GCUs, tuo pačiu metu vyksta į nepavyks saugiuoju režimu. Tai tipo prarasti mane. Tačiau pranešime buvo nurodyta, Gerai, dabar aš turiu, kad sąlyga sukėlė programinė įranga kovoti su vidiniais generatorius kontrolė vienetų, kurie bus perkrautas po 248 dienų nepertraukiamo galią. Mes išdavimo ši pastebėti, kad neprarastumėte Visų kintamosios srovės elektros galia, kuri galėtų sukelti nevaldoma lėktuvo. 

Taigi, pažodžiui, yra tam tikrų sveikasis skaičius, arba kai lygiaverčių duomenų tipas, naudojamas programinės įrangos į faktinį lėktuvo kad jei norite išsaugoti savo lėktuvą pakankamai ilgai, o, matyt, gali būti tuo atveju, jei jūs tiesiog veikia juos nuolat ir niekada išjungiant Jūsų lėktuvas, atrodo, arba nuomos jos baterijos mirti, ilgainiui suskaičiuoti, ir daugiau, ir daugiau, ir daugiau, ir daugiau, ir daugiau. 

Ir gamta A ribinis dydis atminties bus perkrautas, riedėjimo atgal nulis arba kai neigiama reikšmė, šalutinis poveikis, kuris yra grėsmingai nekilnojamojo realybė kad lėktuvas gali prireikti turi būti paleistas, efektyviai, ar gali kristi, dar blogiau, nes jis skrenda. Taigi šie klausimai rūšių vis dar su mumis, even-- tai buvo 2015 straipsnis, tuo labiau bauginantis kai jūs nebūtinai suprasti, vertinti, ar numatyti tie rūšių klaidų. 

Taigi paaiškėja, ten vienas kitas blogas dalykas, apie duomenų pateikimo. Pasirodo, kad net plūdės yra rūšies ydingas, nes plūdės, taip pat, Aš pasiūliau yra 32 bitai, arba gal 64, jei jūs naudojate dvigubai. Bet tai vis tiek ribotas. 

Ir laimikis, kad jei galite įdėti begalę numerių po kablelio, nėra jokio būdo galite gali atstovauti visus galima numeriai, kad mes buvo mokomi lygiui mokykla gali egzistuoti pasaulyje. Kompiuteris, iš esmės, turi pasirinkti iš šių skaičių poaibis atstovauti tiksliai. 

Dabar, kompiuteris gali apvalios gal šiek tiek, ir gali leisti jums maždaug parduotuvėje bet koks skaičius galbūt galbūt nori. Bet tik intuityviai, jei jums turi baigtinį skaičių bitų, galite sukeisti tik juos tiek daug baigtinių būdais. Taigi, jūs negalite galbūt naudoti baigtinio skaičiaus iš kombinacija bitų, modeliai nulių ir, atstovauti begalinė skaičius numerius, Tai rodo, kad kompiuteriai galėtų labai gerai būti gulėti mums kartais. 

Iš tiesų, tegul tai padaryti. Leiskite grįžti į CS50 IDE. Leiskite man eiti į priekį ir sukurti mažai programą vadinamas paklaidos, rodo, kad kompiuteriai, tiesą sakant, netikslus. 

Ir leiskite man eiti į priekį ir pradėti kai šio kodekso iš anksčiau, o dabar tiesiog atlikite šiuos veiksmus. Leiskite man eiti į priekį ir daryti printf, proc F, Backslash n 1 padalytą iš 10. Kitaip tariant, galime pasinerti giliau 1/10, kaip 1 ir dalijami iš 10. Žinoma, kompiuteris gali atstovauti 1/10. 

Taigi eikime į priekį ir padaryti netikslumų. Pažiūrėkime. Formatas nurodoma tipo dvigubai. Tačiau šis argumentas yra tipo int. Kas vyksta? 

O, įdomu, todėl tai pasimokyta iš anksčiau. Aš sakau, ei, kompiuteris rodo man plūdė su f proc. Bet aš suteikti jai 2 int. Taigi paaiškėja, galiu sutvarkyti tai įvairiais būdais pora. 

Galėčiau tiesiog pasukite vienas į 1,0, o 10 į 10,0, kuri, tiesą sakant, turi galimybę konvertuoti poveikį juos į floats-- dar tikiuosi tas pats numeris. Arba it turns out, kad kažkas matysime vėl prieš ilgas. Jūs galite atiduoti numerius. 

Galite, naudojant šią suskliaustos išraiška, galima sakyti, ei, kompiuteris, į tai 10, kurį aš žinau, yra int. Bet su ja elgiamasi, prašome taip, tarsi tai plūdė. Bet tai jaučiasi pernelyg sudėtingos. 

Mūsų tikslams šiandien tegul tik pažodžiui padėti jiems slankiojo kablelio vertybes su dešimtainio taško, kaip šis. Leiskite man eiti į priekį ir pakartotinis, kad netikslumas, gera, taškas velniop netikslumas, įveskite. Gerai, mes ieškome gerai. 

1, padalytą iš 10, pagal mano "Mac" čia yra, iš tiesų, 0,100000. Dabar aš buvo mokoma pradinėje mokykloje yra turėtų būti begalinis skaičius 0 aisiais. Taigi leiskite bent pabandyti pamatyti kai iš tų. Pasirodo, kad printf yra šiek tiek mėgėjas dar nei mes jau naudojate. Pasirodo, jūs neturite nurodyti tiesiog proc F, arba tiesiog proc aš. Jūs iš tikrųjų galite nurodyti kai kurios kontrolės parinktis. 

Tiksliau, aš ruošiuosi pasakyti, ei, printf, iš tikrųjų rodo, man 10 dešimtainių taškų. Taigi atrodo šiek tiek keistai. Bet tu sakai procentų, DOT, kiek numeriai Norite pamatyti po kablelio, tada f vienodo, tik todėl, kad tai ką dokumentacija sako. Leiskite man eiti į priekį ir išsaugoti, kad. 

Ir pastebėsite per daug, aš gaunu pavargau perspausdinimas dalykų. Taigi, aš tiesiog nustatant aukštyn ir rodyklę žemyn ant mano raktus čia. Ir jei aš nuolat pataikyti, jūs gali matyti visi iš komandų kad aš padariau, ar neteisingai padarė. 

Ir aš ruošiuosi eiti į priekį ir dabar ne iš tikrųjų naudoti, kad, matyt. Padaryti netikslumą, DOT Slash imprecision-- taip kas man buvo mokoma Mokyklos patikrinimus iš. Net jei aš jį atspausdinti iki 10 dešimtosios Kavinės, tai, tiesą sakant, yra 0,10000. Bet žinote ką? 

Leiskite gauti šiek tiek godus. Tarkime, pavyzdžiui, parodykite man 55 atkreipia po dešimtainio. Leiskite tikrai imtis šio programuoti iš už nugaros. Leiskite perdaryti jį su modelio netikslumas, taškas velniop, netikslumai. 

Ir čia mes einame. Jūsų vaikystės buvo melas. Matyt, 1, padalytą iš 10 iš tikrųjų yra 0.100000000000000005551115123-- 

Kas vyksta? Na, it turns out, jei rūšies atrodo pakankamai toli į pagrindinių atstovavimas tai skaičius, iš tikrųjų nėra tiksliai 1/10 arba 0,1 ir begalinis skaičius nulių. Dabar, kodėl taip yra? 

Na, nors tai paprastas skaičius mus žmonės, 1, padalytą iš 10 tai dar vienas be galo daug numeriai, kad galėtume sugalvoti. Bet kompiuteris gali atstovauti tik žinoma daug todėl numeriai. Ir taip, efektyviai, ką kompiuteris rodo mums yra jo artimiausi Įstatymų į numerį norime tikėti yra 1/10, ar tikrai 0,10000 ad infinitum. 

O, nors, tai yra taip arti, kaip jis gali gauti. Ir, iš tiesų, jei jums atrodo po gaubtu, nes mes esame čia, žiūrėdamas 55 ženklų po kablelio, mes iš tikrųjų matyti, kad tikrovę. Dabar, kaip panaikinti, jei jūs nors matė movie-- dauguma iš jūsų tikriausiai haven't-- bet prieš Supermenas 3 kelerius metus, Richardas Pryor esmės skolintomis tai Realybė jo bendrovė pavogti daug frakcijų ir frakcijų centus, nes draugija, kaip prisimenu, tai buvo while-- buvo iš esmės mesti toli nieko, kad netilpo į centų sąvoka. 

Bet jei jūs pridėti iki visa tai maža, maža, maža numeriai vėl ir vėl, ir vėl, jūs galite, kaip jo byla, padaryti gerą pinigų sumą. 

Tą pačią idėją apiplėšti naujesnis, bet vis tiek dabar vyresni Filmas, pavadintas biurų patalpos, jeigu tame filme vaikinai, padarė tą patį, prisukamas jį visiškai baigėsi taip per daug pinigų į savo banko sąskaitą. Visa tai buvo labai įtartinas. Tačiau tuo dienos pabaigoje, netikslumas yra visur aplink mus. 

Ir kad, taip pat gali būti Baugina bylą. Pasirodo, kad supermenas 3 ir biuro erdvė žemę, ten gali būti kai labai reali pasaulio pasekmių iš netikslaus realijas atstovavimas duomenų kad net mes, žmonės į ši diena nebūtinai suprasti taip pat turėtume ar prisiminti, kaip dažnai, kaip turėtume. Ir, tiesą sakant, taip klipas nuo tam tikru labai realaus pasaulio išvaizdą pasekmių, kas atsitiks, jei nereikia vertiname netikslumą, kad gali atsitikti skaičiais atstovavimo. 

[Vaizdo įrašų atkuriamų] 

-Computers, Mes visi ateiti sutikti kad dažnai nelinksma problemų, kurios eiti su, išbandyti klaidų, virusai, ir programinės įrangos trikdžių, mažoms kainos mokėti nes patogu. Tačiau aukštųjų technologijų ir didelės spartos karinių ir kosmoso programos paraiškas, mažiausia problema gali Tebūna išaukštintas į katastrofą. 

Birželio 4, 1996, mokslininkai parengė pradėti nepilotuojamas "Ariane 5 raketų. Jis nešėsi mokslo palydovai skirta nustatyti tiksliai, kaip Žemės magnetinio lauko sąveikauja su saulės vėjų. Raketa buvo pastatyta Europos kosmoso agentūra, ir pakilo iš savo įrenginio nuo Prancūzijos Gvianos priekrantės. 

-At Apie 37 sekundžių į skrydis, jie pirmą kartą pastebėjau, kad kažkas negerai. Purkštukai buvo pakreipti į būdas jie tikrai neturėtų. Maždaug 40 sekundžių į skrydžio Akivaizdu, kad transporto priemonė buvo bėdų. 

Ir tai, kai jie padarė sprendimas jį sunaikinti. Asortimentas saugos pareigūnas, su milžiniškas viduriai, spaudžiamas mygtukas, susprogdino raketų, kol jis galėtų tapti pavojaus į visuomenės saugumui. 

-Tai Buvo mergautinė kelionė į Ariane 5 d. Ir jos naikinimo veiksmai buvo padėkite, nes škvalas įdėta į raketą programinės įrangos. -The Problema ant Ariane buvo kad ten buvo skaičius, kuris reikia 64 bitus išreikšti. Ir jie norėjo atsiversti jį į 16-bitų skaičių. Jie prielaida, kad skaičius buvo niekada būti labai didelis, kad dauguma tų skaičiai 64 bitų skaičius buvo nuliais. Jie buvo neteisūs. 

-The Vienos nesugebama programa sutikti numeris, nurodytas rūšies generuoja kitą buvo tuo, kad nebuvo šaknies. Programinės įrangos kūrimas tapo labai brangus dalis naujos technologijos. "Ariane" raketa buvo labai sėkmingas, todėl daug programinės įrangos sukurta ji taip pat buvo naudojamas Ariane 5 d. 

-The Pagrindinė problema buvo tai, kad "Ariane 5 buvo greitesnis, pagreitinto greičiau. Ir programinę įrangą, turėjo ne sudarė tai. 

-Iš Raketų sunaikinimo buvo didžiulė finansinė katastrofa, visi dėl į minutę programinės įrangos klaidos. Bet tai buvo ne pirmas laiko duomenų konvertavimo problemos buvo kentėjo modernią raketų technologiją. 

-in 1991, su pradžios pirmojo Persijos įlankos karo, Patriot raketų patyrė panašų natūra skaičiaus perskaičiavimo problema. Ir kaip rezultatas, 28 žmonės, 28 amerikiečių karių, žuvo, o apie 100 žaizdos, kai Patriot, kuris turėjo apsaugoti nuo gaunamų scuds, nepavyko ugnį raketa. 

-Kai Irakas įsiveržė Kuveitas, ir Amerikoje pradėjo Desert Storm 1991 pradžioje, Patriotas raketų baterijos buvo dislokuota apsaugoti Saudo Arabija ir Izraeliu iš Irako Skadi raketų atakų. Patriot yra JAV vidutinio nuotolio paviršiaus oro sistemos, pagaminti pagal Raytheon kompanijos. 

-Iš Patriot Interceptor dydis pati yra apie maždaug 20 pėdų ilgio. Ir ji sveria apie 2000 svarų. Ir ji vykdo daug apie galvutę, Manau, kad tai maždaug 150 svarų. Ir pati užtaisą yra aukštos sprogmenį, kuris turi fragmentus aplink jį. Iš galvutės korpusas sukurta veikti kaip šautuvo šratai. 

-The Raketų atliekami keturi už konteinerį, ir yra gabenami pusiau priekaba. 

-The Patriot "priešraketinės gynybos sistemą nueina ne mažiau kaip 20 metų. Iš pradžių buvo sukurta kaip oro gynybos raketų nušauti priešo lėktuvus. Per pirmąjį Persijos įlankos karą, kai, kad karas atėjo kartu, armija norėjo jį naudoti numušti scuds, o ne lėktuvais. 

Irako oro pajėgų buvo ne tiek daug problemų. Bet armija buvo neramu apie scuds. Ir taip jie bandė atnaujinti Patriot. 

-Intercepting Priešą raketa keliaujant mach 5 ketino būti pakankamai sudėtinga. Bet kai Patriot buvo skubėjome eksploatuoti, armija nieko nežinojo apie Irako modifikacija, kad padarė jų scuds beveik neįmanoma pataikyti. 

-Kas Atsitiko yra scuds kad ateidavo į buvo nestabili. Jie buvo Įtaka. Dėl šios priežasties buvo irakiečiai, kad gauti 600 kilometrų iš 300 km diapazonas raketa, paėmė svorį iš priekinės galvutės. Jie padarė užtaisą lengvesni. 

Taigi dabar Patriot yra bando ateiti Skadi. Ir didžiąją dalį metu, Dauguma laiko, tai tiesiog skristi iš Skadi. Kai Patriot sistemos operatoriais supratau Patriot praleido savo tikslą, jie susprogdino Patriot anketa kovinę galvutę išvengti galimų aukų, jei jis buvo leista patenka į žemę. 

-Tai Buvo ką dauguma žmonių matė, tie dideli ugnies į dangų, ir nesuprato, kaip ašyje Skadi galvučių. 

-Although Naktį dangus, patriotai atsirado būti sėkmingai sunaikinti Scuds, bent Dhahran, ten gali būti ne klaida apie jos veiklą. Ten, Patriot radaras sistema neteko stebėti priimamą Skadi, ir niekada pradėjo dėl į programinės įrangos trūkumas. Tai buvo Izraelio, kuris pirmą kartą atrado , kad kuo ilgiau sistema buvo įjungtas, tuo didesnis laiko skirtumas tapo, nes laikrodis įterptųjų Šioje sistemoje kompiuteryje. 

-About Prieš dvi savaites iki Į Dhahran tragedija, Izraelis pranešė, kad Gynybos departamentas , kad sistema buvo prarasti laiko. Po maždaug aštuonias valandas iš eilės, jie pastebėjo, kad sistema buvo vis pastebimai mažiau tiksli. Gynybos departamentas atsakė sakau visi Patriot baterijų ne palikti sistemas dėl ilgą laiką. Jie niekada sakė, kas ilgą laiką was-- aštuonias valandas, 10 valandų, 1000 val. Niekas nežinojo. 

-The Patriot "baterija dislokuota kareivinėse ne Dhahran ir jos trūkumų vidaus laikrodis Buvo daugiau nei 100 valandų dėl vasario 25 naktį. 

-Tai Stebimi laiko tikslumu apie sekundės dešimtoji. Dabar, per sekundės dešimtoji yra įdomi numeris nes ji negali būti išreikšta dvejetainiu tiksliai, kuris išteklius ji negali būti išreikšta tiksliai į bet kurios šiuolaikinės skaitmeninio kompiuterio. Sunku tikėti. 

Bet tai naudoti kaip pavyzdys. Paimkime skaičių trečdalį. Trečdalis negali būti išreikštas dešimtaine tiksliai. Trečdalis yra 0,333 vyksta už begalybę. 

Nėra jokio būdo, kaip tai padaryti su absoliutus tikslumas po kablelio. Štai tiksliai tokios problemos kad atsitiko Patriot. Kuo ilgiau sistema bėgo, The blogiau tapo laikas klaida. 

-Po 100 valandų operaciją, klaida metu buvo tik apie trečdalis sekundės. Bet kalbant apie skirtomis raketa keliaujant mach 5 ji lėmė sekimo paklaida daugiau nei 600 metrų. Būtų lemtinga klaida kariams apie tai, ką atsitiko yra Skadi paleidimas buvo aptikta išankstinio perspėjimo palydovai ir jie žinojo, kad Skadi buvo ateina jų bendrą kryptį. Jie nežinojo, kur ji atėjo. 

-Tai Buvo dabar iki radaro komponentas Patriot sistemos ginti Dhahranas surasti ir išlaikyti kelio nuo gaunamus priešų raketos. 

-The Radaras buvo labai protingas. Tai iš tikrųjų būtų sekti Iš Skadi pozicija, ir tada numatyti, kur jis tikriausiai būtų kitą kartą radaro siunčiami impulsas iš. Tai buvo vadinama asortimentas vartai. 

-Tada, Kai į "Patriot" nusprendžia pakankamai laiko turi praėjo grįžti ir patikrinti kitą vieta šio aptikto objekto, jis eina atgal. Taigi, kai jis grįžo į tą vieta, tai tada nemato objektą. Ir ji nusprendžia, kad nebuvo objektas, tai buvo klaidinga aptikimo, ir lašai takelį. 

-The Priimamojo Skadi dingo iš radaro ekrano. vėliau ir sekundes, ją pateko į kareivines. Skadi žuvo 28 ir buvo paskutinis viena kūrenama per pirmąjį Persijos įlankos karą. 

Tragiška, atnaujinta programinė įranga atvyko Dhahran kitą dieną. Programinė įranga škvalas turėjo buvo fiksuota, uždarymas vienas skyrius neramus istorija Patriot raketos. 

[Vaizdo įrašų atkuriamų] David J. Malan: Taigi visa tai, kad pasakyti, kad šių perpildymo problemas ir visi netikslumai yra labai reali. Taigi, kaip mes ten patekome? Mes pradėjome su tik kalbame apie printf. Vėlgi, tai funkcija, kuri spausdina kažką ekrane, ir mes po to pristatė keletas kitų funkcijų iš vadinamojo CS50 bibliotekoje. Ir mes toliau pamatyti tai laiku. Ir mes, ypač, naudojamas get eilutę, ir gauti int, ir dabar taip pat gauti plūdę, ir dar kiti vis dar susiduriame su ir naudoti save prieš ilgas. 

Bet kartais turi mes jau matėme, kad reikia saugoti, kas tas funkcijas ranka atgal? Jie perduoti mums atgal eilutę, arba LC, arba flotacinio. Ir kartais mums reikia įdėti, kad eilutė, ar INT, ar plūdė, kažkur. 

Ir saugoti tuos dalykus, prisiminti tik kaip ir nulio ", mes turime kintamuosius. Tačiau skirtingai nei nulio, C turime faktinius tipai iš variables-- duomenų tipai, daugiau generally-- tarp jų eilutė, int A plūduriuoti, ir šie kiti dar. 

Ir todėl, kai mes pareiškiame kintamuosius C, mes turime pripažinti mūsų duomenų tipus. Tai nėra kažkas, mes daryti vėliau semestro kaip mes pereiti į kitas kalbas. Bet dabar, mes turime į iš anksto priori paaiškinti prie kompiuterio, kokio tipo kintamojo mes norime, kad ji mums duoda. 

Dabar, tuo tarpu, spausdinti tie rūšių duomenų tipų, mes turime pasakyti printf, ko tikėtis. Ir mes matėme proc s stygos, ir procentai I sveikieji skaičiai, ir keli kiti jau. Ir tie, kurie paprasčiausiai reikalavimai už vizualinio pateikimo tos informacijos. 

Ir kiekvienas iš jų gali būti iš tiesų Parametrizuotieji arba nežymiai tam tikru būdu, jei norite toliau kontroliuoti produkcijos tipą, kuris jums. Ir, iš tiesų, paaiškėja, kad ne tik yra ten Backslash N naują eilutę. Yra kažkas pavadino Backslash R už vežimo grįžti, kuris yra labiau panašus į senosios mokyklos rašomųjų mašinėlių, ir taip pat langai naudojamas daugelį metų. 

Yra Backslash t skirtukus. Pasirodo, kad jei norite, kad dvigubas citata viduje eilutę, Prisiminkite, kad mes naudojamas dvigubas citata dvigubai citata kairėje ir dešinėje baigiasi mūsų stygas iki šiol. Tai, atrodo, painioja dalykus. 

Jei norite įdėti dvigubą citata iš administracine arba string-- ir, tiesą sakant viduryje, tai paini pamatyti. Ir todėl jūs turite pabėgti, taip sakant, dvigubos kabutės su kažkuo patinka, tiesiog, backslash dvigubos kabutės. Ir yra keletas kitų dar. Ir mes pamatysime daugiau tų faktinio naudojimo prieš ilgas. 

Taigi leiskite dabar pereiti nuo duomenys, ir atstovavimas, ir aritmetines operacijas, visa kurios davė mums šiek tiek pastatą blokai, su kuriomis groti. Bet dabar tegul iš tikrųjų duoti mums žodyno poilsio kad mes jau Praėjusią savaitę su Scratch imant pažvelgti kita stato į C-- ne visi iš jų. Tačiau idėjos mes Apie pamatyti tikrai tik pabrėžti vertimą iš viena kalba, įbrėžimams, į kitą C. 

Ir laikui bėgant, mes pasiimti daugiau įrankių mūsų priemonių rinkinį, taip sakant, sintaksiškai. Ir, tiesą sakant, jūs pamatysite, kad idėjos dabar yra gana pažįstamas iš praeitą savaitę. Taigi leiskite tai padaryti. 

Vykime į priekį ir pakelti programą kad iš tikrųjų naudoja kai išraiškas, Būlio išraiška. Leiskite man eiti į priekį čia ir sukurti naują failą. Aš tai vadina condition.c. 

Leiskite man eiti į priekį ir įtraukti CS50 biblioteką. Ir leiskite man eiti į priekį ir taip pat standartinis IO.h mūsų funkcijų, ir printf, ir daugiau atitinkamai. Leiskite man duoti sau, kad Standartiniai int main negaliojančiu, kurio paaiškinimas mes grįžti į ateityje. 

Dabar leiskite man eiti į priekį ir suteikti aš int per get tarpt. Tada leiskite man eiti į priekį ir tai padaryti. Aš noriu pasakyti, jei i less-- tegul atskirti teigiamas, neigiamas, arba nulines vertes. 

Taigi, jei i yra mažiau nei nulis, leiskite man tiesiog ši programa tiesiog pasakyti, neigiamas, Backslash N, kita jei i yra didesnis už nulį. Dabar aš, žinoma, ketina pasakyti printf teigiamą, backslash n. Ir tada dar if-- galėčiau tai padaryti. 

Aš galėčiau padaryti, jei aš lygus 0. Bet aš būčiau priėmimo metu bent vienas jau klaida. Prisiminkite, kad lygybės ženklas yra nėra lygūs, nes mes, žmonės jį žinome. 

Bet tai perleidimas operatorius. Ir mes nenorime imtis 0 Į teisė ir įdėti jį į i kairėje. Taigi, norint išvengti šios painiavos, arba gal netinkamas lygybės ženklą, žmonės nusprendė prieš keletą metų kad daugeliu programavimo kalbų kai norite patikrinti lygybės tarp kairės ir dešinės, jūs iš tikrųjų naudoti lygus lygių. Taigi jūs nukentėjo lygybės ženklą du kartus. Kai norite priskirti iš dešinės į kairę, naudokite vieną lygybės ženklą. Taigi, mes galime padaryti this-- kitur jei aš lygus lygus nuliui. 

tada galėčiau eiti ir atidaryti savo garbanotas petnešos, ir pasakyti, printf 0, Backslash n padaryta. Bet atsiminkite, kaip jie šakės kelyje gali dirbti. Ir, tikrai, tiesiog galvoti apie logika. i yra skaičius. Tai sveikas, specialiai. Ir tai reiškia, kad jis bus mažiau už 0 arba didesnė už 0, arba 0. Taigi yra natūra tai numanoma numatytąją atveju. 

Ir taip galėtume, kaip ir Įbrėžimams, apsieiti su kita, jei ir tiesiog pasakyti kitur. Logiškai mąstant, jei Jums programuotojas žino, yra tik trys kibirai, į kurią scenarijus fall-- pirmas, antra, ar trečioji šiame case-- ne vargintis pridedant papildomą tikslumą ir papildomas logika ten. Tiesiog eiti į priekį su Numatytasis atveju iš kitur. 

Dabar galime eiti į priekį Įrašę šią, kad sąlygos dot velniop conditions-- nėra labai vartotojo sąsaja, nes aš nesu paskatino vartotojas, kaip jau minėjau anksčiau. Bet tai gerai. Mes keep it simple. Pabandykime skaičių 42. Ir tai teigiamas. Pabandykime numerį neigiamas 42, neigiamas. 

Pabandykime vertę 0. Ir, iš tiesų, ji veikia. Dabar, pamatysite su problemomis prieš ilgio, testavimo dalykų tris kartus, tikriausiai nepakanka. Jūs tikriausiai norite išbandyti kai Didesnės numeriai, kai mažesni numeriai, kai kampiniai atvejais, mes ateiti į juos apibūdinti. 

Bet dabar, tai yra gana paprasta programa. Ir aš esu gana įsitikinęs, logiškai, kad jis patenka į tris atvejus. Ir iš tiesų, nors mes tiesiog orientuota į potencialius praradimas netikslumu ir perpildymo, į Realybė kur daugelis CS50 problemas, mes neketiname jaudintis apie, visą laiką, tie perpildymo problemos ir netikslumas, nes, iš tiesų, C, tai tikrai ne viskas, kad lengva išvengti šių dalykų. Jei norite suskaičiuoti iki didesnis ir didesnis, ir daugiau, paaiškėja, yra būdų jums galima naudoti, dažnai įtraukiant dalykus, vadinamus bibliotekos, kolekcijos kodą, kad kiti žmonės rašė, kad galite naudoti, ir kitomis kalbomis, pavyzdžiui, Java ir kiti, iš tikrųjų padaryti daug lengviau skaičiuoti dar didesnis. Taigi ji tikrai yra kai kurie iš šių pavojų iš naudojamą kalbą funkcija. Ir per ateinančias savaites, mes pamatyti, kaip pavojingą C tikrai gali būti, jei nenorite naudoti tinkamai. Bet iš ten, ir su Python ir "JavaScript", bus mes sluoksnis keletą papildomų apsaugų, ir paleisti mažiau iš tų pavojų. 

Taigi padarykime šiek tiek daugiau įdomus logika mūsų programoje. Taigi leiskite man eiti į priekį ir kurti programa, vadinama Loginiai tiesiog, kad aš galiu žaisti su kai Tikrasis logika, logical.c. Aš tiesiog nukopijuokite ir įklijuokite kai Kodas iš anksčiau, kad aš grįšiu į šį gražus atspirties taškas. 

Leiskite man šį kartą padaryti char C. Aš tikiu ketina suteikti jai iš C vardą tik todėl, kad tradicinių, gauti simbolį iš vartotojo. Ir tegul apsimeta kaip Aš įgyvendinimo dalis tos Rm programa, pašalinti programa prieš tai paskatino vartotoją pašalinti failą. Kaip mes galime tai padaryti? 

Aš noriu pasakyti, jei C yra lygi lygus, citata citatos pabaiga, Y, tada aš ruošiuosi daryti prielaidą, kad vartotojas pasirinko taip. Aš tik ketina spausdinti taip. Jei jis iš tikrųjų buvo raštu pašalinimo programa, galėtume pašalinti failą daugiau eilučių kodo. Bet mes keep it simple. 

Else if c lygu lygu n-- o dabar čia, aš ruošiuosi pasakyti, vartotojas turi reiškė, Nr. Ir tada kitas, žinote ką? Aš nežinau, ką dar vartotojas ketina įvesti. Taigi, aš tiesiog norėčiau pasakyti, kad kad yra klaida, nepriklausomai jis ar ji iš tikrųjų įvedėte. 

Taigi, kas čia vyksta? Yra esminis skirtumas palyginti, ką aš padariau praeityje. Dvigubas kabutes, kabutes, dvigubas citatos, ir dar, Viengubomis kabutėmis, Viengubomis kabutėmis. Pasirodo, C, kad kai norite parašyti eilutę, jums naudoti kabutes, kaip mes naudoju visą šį laiką su printf. 

Bet jei norite susidoroti su tik vienas simbolis, vadinamasis simbolis, tada jūs iš tikrųjų naudoti kabutes. Tie iš jūsų, kurie jau užprogramuotas anksčiau, galbūt ne turėjo jaudintis atskirti tam tikromis kalbomis. C, ji dalykas. Ir todėl, kai aš gauti char ir aš noriu palyginti, kad char naudojant lygu lygus Some Like Y arba N raide, aš, Iš tiesų, reikia turėti Viengubomis kabutėmis. 

Dabar galime eiti į priekį ir tai padaryti. Vykime į priekį ir padarysiu loginiai taškas velniop logiška. Ir dabar aš raginami. Taigi, matyt, geriau naudoti patirtis iš tikrųjų man pasakyti, ką daryti čia. Bet aš ruošiuosi tik aklai pasakyti Y taip, gerai, gražus. 

Leiskite paleisti jį iš naujo, n ne, gražus. Tarkime, pavyzdžiui, tam tikrų žmonių, aš žinau, mano kepurės lock yra pernelyg dažnai. Taigi darau kapitalo Y atvykti, klaidą. Gerai, tai ne ką aš laukiu. Iš tiesų, kompiuteris daro pažodžiui, ką Pasakiau jai do-- patikrinti mažosiomis raidėmis y ir mažosiomis raidėmis N. Tai neturi jaustis kaip gera vartotojo patirtį, nors. Leiskite paklausti, ir priimti arba mažosiomis raidėmis, arba didžiosios. Taigi paaiškėja, galbūt norėsite pasakyti kažką panašaus į nulio, kaip pažodžiui arba C lygu lygus kapitalo vieną cituojamą m. Pasirodo, C neturi tai pažodinis reikšminį žodį arba. 

Bet ji turi du vertikalūs stulpeliai. Turite turėti Shift paprastai, jei jūs naudojate JAV klaviatūra, ir paspauskite vertikalią juostą raktas aukščiau grąžą raktu. Bet tai vertikali juosta vertikali juosta reiškia, arba. 

Jei, priešingai, norėjome pasakyti ir, kaip ir nulio, mes galime padaryti ampersendo konjunkcijos. Tai daro ne logine prasme čia nes žmogus negalėjo įvedėte tiek y ir mažosiomis raidėmis Y ir kapitalo Metai kaip to paties pobūdžio. Taigi ar tai, ką mes ketiname čia. 

Taigi, jei aš tai padaryti abiejose vietose arba C lygi lygu kapitalo N dabar pakartotas, markę logiška, pakartotas logiška. Dabar galiu įrašyti m. Ir aš galiu tai padaryti dar kartą su kapitalo Y arba kapitalo N. Ir galėčiau pridėti papildomas deriniai ramiai. 

Taigi tai yra logiška programa, kiek dabar Aš patikrinti logiškai už ši vertė arba ši vertė. Ir aš neturiu, būtinai sugalvoti dar du IF arba dar IFS. Aš iš tikrųjų galite sujungti kai kurie iš susijusios logika kartu tokiu būdu. Taigi tai būtų geresnis sukurta nei tiesiog sakydamas: Jei c yra lygus mažąją y, spausdinti taip, kitur Jei c yra lygus kapitalo Y, spausdinti taip, kitur Jei c yra lygus lower-- kitaip tariant, Jums nereikia turėti vis daugiau ir daugiau šakų. Galite derinti kai kurių lygiavertis filialai Logiškai mąstant, kaip šiuo būdu. 

Taigi leiskite pažvelgti tik vienas galutinis komponentas, vienas galutinis konstruktas, kad C leidžia. Ir mes grįžti į ateitis kiti vis dar. Ir tada mes sudaryti, žiūrėdamas ne ne su code-- teisingumą gauti kodą work-- bet dizainas kodo ir pasodinsi tas sėklas anksti. 

Taigi leiskite man eiti į priekį ir atverti naują failą čia. Zinai ka? Aš ruošiuosi vėl įgyvendinti kad pati programa, tačiau naudojant kitą konstruktą. 

Taigi leiskite man greitai duoti save prieiga įtraukti CS50.h už CS50 bibliotekoje, standartinis Io.h už printf. Duok man mano int main negaliojančiu. Ir tada per čia, leiskite man eiti į priekį ir tai padaryti. 

Char c gauna gauti char, kaip anksčiau. Ir aš ruošiuosi naudoti naują konstruktą now-- pereiti, kokiu charakterio? Taigi jungiklis yra lyg perjungimo traukinio takelius. Arba, iš tikrųjų, ji yra rūšies IF kitur, jei kitur, jei bet parašyta šiek tiek kitaip. 

Jungiklis atrodo taip. Jūs turite pereiti, o kas tada raidės arba skaitmens norite ieškoti, tada kai garbanotas petnešos patinka Nulio, tik pasakyti tai padaryti stuff. Ir tada jūs turite skirtingus atvejus. 

Jūs negalite naudoti ar ir kitur. Jūs tiesiog naudoti žodį bylą. Ir jūs sakyčiau kažką panašaus į tai. 

Taigi į mažosiomis y atveju arba kapitalo Y atveju eiti į priekį ir atsispausdinti Taip. Ir tada išeiti iš jungiklio. Viskas. Mes padaryti. 

Else if, taip sakant, mažesnis Byla N arba kapitalo N tada eiti į priekį ir spausdinti iš ne, ir tada pertrauka. Else-- ir šios rūšies yra Numatytasis atveju indeed-- printf error-- ir tiesiog gera priemonė, nors Logiškai mąstant, tai pertrauka nebūtina nes mes pabaigoje jungiklio bet kokiu atveju, Aš dabar išeities iš jungiklio. Taigi, tai atrodo šiek tiek kitokia. 

Bet, logiškai, tai tikrai lygiaverčiai. Ir kodėl gi jūs naudojate vienas per kitą? Kartais, tiesiog asmeninio skonio, kartais estetika, jei aš pažiūrėjus į tai dabar yra kažkas galima pasakyti, kad skaitomumas šį kodą. Aš turiu galvoje, niekada omenyje tai, kad ši kodas yra nauja daugelis iš mūsų į kambarį. 

Bet tai tiesiog rūšies yra gana. Jūs matote mažosiomis raidėmis y kapitalo Y, mažoji n kapitalo N. nutylėjimą, tai tiesiog rūšies šuoliai į tave taip, kad, be abejo, gal ankstesnis pavyzdys su IFS, ir vertikalių strypų, ir kitur IFS, gali neturėti. Taigi tai tikrai priklauso nuo asmeninio nesvarbu pasirinkimas, tikrai, ar skaitomumas, kodo. 

Bet kalbant apie funkcionalumą, leiskite man eiti į priekį ir padaryti jungiklis, dot velniop jungiklis, o dabar tipo mažosiomis y, kapitalo Y mažosios n kapitalo N Dovydas bandykite dar kartą, nes tai ne vienas simbolis. Darom x, klaidą, kaip ir tikėtasi. Ir logically-- ir tai yra kažkas Norėčiau paskatinti į general-- net nors mes tik įbrėžimas paviršius kai kurie iš šių funkcijų. 

Ir tai gali būti ne akivaizdu, kai jums Būk susėsti prie klaviatūros, Kaip tai veikia? Ką tai daryti? Gražus dalykas, apie kurių nešiojamas ar stalinis, ar prieigos prie kompiuterio su kompiliatorių, ir su kodiniu redaktorius panašaus į tai, yra galima beveik visada atsakyti į šiuos Klausimai sau, tiesiog bando. 

Pavyzdžiui, jei retorinis klausimas po ranka buvo, kas atsitiks, jei pamiršti Jūsų pertrauka teiginiais? Kuris iš tiesų yra labai dažnas dalykas daryti, nes ji neatrodo kaip jūs tikrai jų reikia. Jie tikrai ne baigti savo maniau kaip skliaustuose ar garbanotieji įtvaras veikia. Vykime į priekį ir perkompiliuoti kodą ir pamatyti. Todėl įsitikinkite, jungiklis, taškas velniop jungiklį. Leiskite įvesti mažosiomis raidėmis y top atveju Enter. Taigi, aš įvedėte m. 

Programa pasakė "taip, ne, klaida, taip, tarsi tai buvo keisti savo mintis. Bet tai kokios buvo, nes tai, kas vyksta su jungikliu yra pirmas atvejis, kad Rungtynės iš esmės reiškia, ei kompiuteris, vykdyti visų kodą po juo. Ir jei jūs neturite pasakyti pertrauka, arba nesakau pertrauką, arba nesakyk pertraukos, kompiuteris ketina smūgis per visus tuos linijų ir vykdyti juos visus, kol jis gauna tai garbanotais petnešomis. Taigi stabdžiai, iš tiesų, reikia. Bet Takeaway čia yra, kai abejojate, pabandykite kažką. Gal išsaugoti savo kodą, pirma, arba išsaugokite jį papildomą failą Jei esate tikrai susirūpinęs Messing ir turintys susigrąžinti darbas, kurį jūs žinote, yra darbo. 

Bet pabandykite dalykų. Ir nereikia būti bijo, ko gero, ką kompiuteris gali padaryti, arba, kad jums gali sulaužyti kažką. Jūs visada galite grįžti atgal tam tikru ankstesnę versiją. 

Tad pabaigoje, žiūrėdamas tuo kodo dizainą. Mes turime šį gebėjimą dabar rašyti sąlygos, ir rašyti kilpos, ir kintamieji, ir skambučių funkcijos. Taigi, tiesą sakant, mes rūšies atgal kur buvome prieš savaitę su nulio, nors ir su mažiau įtikinamų tekstinės aplinka nei nulio leidžia. 

Tačiau pastebėti, kaip greitai mes įsigijo kad Žodynas, net jei tai ketina imtis šiek tiek laiko kriaukle, taip, kad dabar mes galime naudoti šį žodyną rašyti daugiau įdomių programų. Ir tegul kūdikio žingsnis link, kad, kaip nurodyta toliau. Leiskite man eiti į priekį ir sukurti naują failą čia. 

Aš ruošiuosi skambinti šiuo prototype.c ir pristatyti pirmą kartą, gebėjimas padaryti savo funkcijas. Kai kurie iš jūsų gali turėti padaryta tai su nulio, kuriuo galite sukurti jūsų individualizuotos blokų nulio, ir tada vilkite juos į vietą kur norėtumėte C Ir daugumoje programavimo kalbos, tai galite padaryti būtent that-- padaryti savo funkcijas, jei jie dar nėra. 

Taigi, pavyzdžiui, leiskite man eiti į priekį ir apima CS50.h, ir apima standartinis IO.h, int main negaliojančiu. Ir dabar mes turime rezervuotos vietos pasiruošę eiti. Aš nuolat spausdinimo dalykus kaip žmonių vardais šiandien. Ir tai jaučiasi like-- nebūtų malonu, jei ten buvo funkcija vadinama Spausdinti vardas? Aš neturiu naudoti printf. Aš neturiu prisiminti visi formato kodai. Kodėl ne aš, arba kodėl nebuvo ką nors prieš mane, sukurti funkciją vadinama Spausdinti vardas, kad suteikta tam tikra vardą, tiesiog spausdina jį? 

Kitaip tariant, jei aš sakau, ei, kompiuteris, duok man eilutę klausia vartotoją, pavyzdžiui, per CS50 get styginių funkcija. Ei, kompiuteris, padėkite tą eilutę kairiojoje pusėje kintamasis, ir vadina tai ai. Ir tada, ei kompiuteris, eiti į priekį ir spausdinti, kad asmens vardas, padaryta. 

Dabar, tai būtų malonu, nes Ši programa, taikliai pavadinta, man sako, ką jis turėtų daryti būdu šiuos funkcinius vardų. Leiskite man eiti ir padaryti prototipą, "Enter". Ir, deja, tai nesiruošia skristi. 

Prototype.c, linija 7, charakteris 5, klaida, numanomas pareiškimas Funkcijų spausdinimo pavadinimas negalioja C99, C99 reiškia iš C versiją kad išėjo 1999 m. Tai viskas. 

Taigi, aš nežinau, ką Visa tai reiškia, dar. Bet aš pripažinti klaidą raudonai. Tai gana akivaizdu. 

Ir atrodo, kad su žalia charakteris čia klausimas yra su spausdinimo vardu, atvira paren S, artimi paren, kabliataškis. Tačiau numanomas deklaracija funkcija mes padarėme trumpai anksčiau pamatyti. Tai reiškia, kad tiesiog, kad klingsėti nežino, ką turiu galvoje. 

Aš naudojau žodyną žodį, kad tai niekada arba buvo mokoma anksčiau. Ir todėl man reikia mokyti jį ką ši funkcija reiškia. Taigi, aš ruošiuosi eiti į priekį ir daryti. 

Aš ruošiuosi eiti į priekį ir įgyvendinti mano paties funkcija vadinama Spausdinti vardas. Ir aš ruošiuosi pasakyti, taip, kad Jis tai daro, printf, hello, proc ai, Backslash N, vardas, kabliataškis. Taigi, ką aš tiesiog padaryti? 

Taigi paaiškėja, kad įgyvendinti savo funkciją, mes rūšies skolintis kai tos pačios struktūros, kaip pagrindinis kad mes ką tik buvo savaime suprantamu dalyku, o aš žinau tik kopijavimo ir įdėjimą gana daug, ką Aš rašyti praeityje. Bet pastebėsite modelis čia. Žiniasklaida, Maino, atkrenta, mes erzinti išskyrus prieš ilgas, ką tai iš tikrųjų reiškia. 

Tačiau šiandien, tiesiog pastebėti paralelių. Atkrenta, spausdinti vardas string vardas, todėl nėra raudonos raktažodis, kuris mes ketiname pradėti paskambinę grąžinimo rūšį, pavadinimą funkcija, ir tada įvesties. Taigi, iš tikrųjų, mes galime distiliuoti tai tipo kaip paskutinę savaitę kaip, tai yra pavadinimas arba algoritmas kodas einame ketina write-- algoritmas pagrindinės kodas mes ketiname rašyti. 

Tai jo indėlis. Tai jos produkcija. Ši funkcija, spausdinti pavadinimas, yra sukurtas užtrukti eilutę, pavadintą vardas ar kas, kaip pirkimo, tada negaliojančiu. Tai negrąžina nieko, kaip gauti eilutę arba gauti int daro. Taigi jis ketina perduoti man kažką atgal. Tai tiesiog teks šalutinis poveikis, taip sakant, spausdinti asmens vardą. Taigi pastebėti, linija 7, aš galite skambinti spausdinimo vardą. 10 linija, galiu apibrėžti arba įgyvendinti spausdinimo vardą. Bet, deja, tai nėra pakankamai. 

Leiskite man eiti į priekį ir perkompiliuoti tai po taupymas. Oho, dabar, aš padariau tai Blogiau, atrodytų. Taigi numanoma deklaracija funkcija spausdinti pavadinimas yra neteisingas. Ir, vėlgi, ten daugiau klaidų. Bet kaip aš įspėjo anksčiau, net Jei gauti užvaldo su, arba šiek tiek liūdna matyti tiek daug klaidų, sutelkti dėmesį tik į pirmą iš pradžių, nes tai gali būti tiesiog turėjo domino efektą. Taigi C arba žvangėjimas konkrečiau, dar neatpažįsta spausdintuvo pavadinimą. 

Ir tai todėl, kad klingsėti, konstrukcijos, yra natūra kvailas. Ji tik ką galite pasakyti daryti. Ir tai daro tik todėl tvarka kurioje galite pasakyti tai daryti. 

Taigi aš apibrėžta pagrindinė on-line keturių, kaip mes darome gana dažnai. Aš apibrėžta spausdinimo vardą on-line 10 d. Bet aš stengiuosi naudoti Spausdinti vardas on-line septyni. 

Tai per anksti, dar neegzistuoja. Taigi, aš gali būti protingas, ir būti kaip, Gerai, kad tegul tiesiog žaisti kartu, ir perkelti spausdinimo vardą iki čia, ir iš naujo kompiliuoti. O Dieve. Pavyko. Tai buvo taip paprasta, kaip kad. 

Tačiau logika yra būtent tai. Jūs turite mokyti žvangėjimas, kur yra apibrėžiant funkciją pirmas. Tada galite jį naudoti. Bet, tiesą sakant, tai jaučiasi kaip slidaus šlaito. 

Taigi kiekvieną kartą, kai aš paleisti į problemą, aš tiesiog ketina pabrėžti ir nukopijuokite kodą Parašiau, nukopijuokite jį ir įklijuokite jį čia. Ir, be abejo, mes galime Sugalvoti kai scenarijus kur viena funkcija galėtų reikia paskambinti kitą. Ir jūs tiesiog negalite įdėti kiekvieną funkcija virš visos kitos. 

Taigi paaiškėja, ten geresnis sprendimas. Galime palikti tai bus. Ir, tiesą sakant, tai paprastai gražus, ir patogu, ir geras dizainas įdėti pagrindinė sritis, nes, vėlgi, Pagrindinis tiesiog patinka, kai žalia vėliava paspaudėte, kad yra funkcija, kuri paleidžiama vykdyti pagal nutylėjimą. Taigi jūs galite taip pat įdėti ji tuo failo viršuje taip, kad, kai jūs ar Kiti žmogiškieji žiūri į failą žinote, kas vyksta tiesiog skaitant pagrindinė pirmas. Taigi paaiškėja, mes galime pasakyti, žvangėjimas aktyviai, ei, klingsėti, on-line keturių, Pažadu įgyvendinti funkcija vadinama Spausdinti Vardas kad mano string vadinamas vardą kaip indėlį ir grąžina nieko, tuštuma. Ir aš gausiu aplink ją įgyvendinant vėliau. 

Čia ateina Main. Pagrindinė dabar on line 9, galite naudoti Spausdinti pavadinimą, nes klingsėti yra pasitikėti, kad galiausiai jis iškils apibrėžimo apie Spausdinti pavadinimas įgyvendinimą. Taigi, po išgelbėdamas mano bylą, tegul man eiti į priekį ir padaryti prototipą, gera šį kartą atrodo. Dot velniop, prototipas, leiskite man eiti į priekį ir įveskite pavadinimą. Dovydas Sveiki Dovydas Zamila, labas Zamila, ir, tiesą sakant, dabar ji veikia. 

Taigi čia ingredientas yra tai, kad mes padarė užsakymą funkciją, kaip papročio Įbrėžimams blokas mes vadiname tai. Tačiau skirtingai nuo nulio, kur Jūs galite tiesiog sukurti ir pradėti jį naudoti, dabar turime būti šiek tiek daugiau pedantiškas, ir iš tikrųjų mokyti žvangėjimas naudoti, arba jį tikėtis. Dabar, kaip panaikinti, kodėl visą tą laiką turi mes buvo tiesiog aklai tikėjimu, įskaitant CS50.h, įskaitant standartinio IO.h? 

Na, it turns out, tarp kelių kitų dalykų, visi tai tose dot h failus, kurie atsitiktų būti failus. Jie header failus, taip sakant. Jie vis dar parašyta C Bet jie skirtingo tipo failą. 

Nes dabar, jums gana daug galima daryti prielaidą, kad viskas, kas yra viduje CS50.h yra keletas vienas ūdomis žvejojantys laivai kaip šis, ne funkcijas, vadinamas Spausdinti vardas, bet Gauk String, gauti Plūdės, ir keletas kitų. Ir yra panašūs prototipai, vienas įdėklai, viduje standartinio IO.h už printf, kuris dabar yra mano paties Spausdinti vardas funkcija. Taigi, kitaip tariant, visas šis laikas mes tik buvo aklai kopijuodami įtraukti tai, apima tai, kas vyksta? Tai yra tik rūšies įkalčiais į žvangėjimas, ką funkcijų yra, iš tiesų, įgyvendino tik kitur skirtingus failus kitur sistemoje. 

Taigi, mes įdiegėme spausdinimo vardą. Ji turi šį šalutinį poveikį spausdinti kažką ekrane. Bet tai iš tikrųjų nėra ranka man kažką atgal. Kaip mes eiti apie Įgyvendinant programą, kuri ar ranka man ką nors atgal? 

Na, pabandykime tai. Leiskite man eiti į priekį ir įgyvendinti failas vadinamas return.c kad galėtume parodyti, kaip kažką kaip gauti eilutę, arba gauti Int, yra iš tikrųjų grįžta kažką atgal vartotojui. Vykime į priekį ir nustatyti int main negaliojančiu. 

Ir vėl, ir ateityje, mes paaiškinti, kas tai int ir kad tuščia yra iš tikrųjų daro. Bet šiandien mes laikyti savaime suprantamu dalyku. Aš ruošiuosi eiti į priekį ir printf, už gerą vartotojo patirtį, x yra. Ir tada aš ruošiuosi laukti vartotojui duoti man x su get tarpt. 

Ir tada aš ruošiuosi eiti į priekį ir atsispausdinti X aikštėje. Taigi, kai jūs turite tik klaviatūra, žmonės paplitusios naudoti tiek morkų Simbolis ant klaviatūros atstovauti į valdžią d arba eksponentė. Taigi x kvadratu yra dovana, kurią aš. 

Ir dabar aš ruošiuosi tai padaryti. Galėčiau tik do-- kas x kvadrato? x kvadratu yra X kartų x. 

Ir mes tai padarė kai prieš laikas jau šiandien. Tai neturi jaustis kaip visi, kad daug pažangos. Zinai ka? Leiskite sverto kai tos idėjos nuo paskutinio karto abstrakcijos. 

Ar nebūtų puiku, jei ten yra funkcija vadinama kvadratinių, kad būtent tai? Jis vis dar tuo galutinio dieną, daro tą matematiką. Bet tegul abstraktūs atstumu nuo priėmimo idėja vienas skaičius, padaugintas iš kitą, ir tiesiog suteikti jai pavadinimą, kaip aikštė šią vertę. 

Ir, kitaip tariant, C kurkime funkcija vadinama aikštė kad daro būtent tai. Jis bus vadinamas kv. Ji ketina imtis int. Ir mes tiesiog jį vadiname n pagal nutylėjimą. 

Tačiau mes galime jį vadinti ką mes norime. Ir visa tai jis ketina padaryti, tiesiog, yra grąža n kartų n rezultatas. Bet kadangi ji yra grįžti kažką, kuris yra purpuru mes raktažodžių niekada anksčiau, aš, on-line 11 negali tiesiog pasakyti negaliojančiu šį kartą. 

Atkrenta, pavyzdyje mes tik pamačiau o iš spausdinimo vardu, tiesiog reiškia, kažką daryti. Tačiau nereikia ranka man kažką atgal. Šiuo atveju, aš noriu grįžti n kartų n ar kas tai yra, kad skaičius. 

Taigi, aš negaliu pasakyti, ei, kompiuteris, Grįšiu nieko, tuščia. Jis ketina grįžti iš prigimties, int. Ir taip, kad viskas, kas vyksta čia. 

Įvesties kvadratinių bus int. Ir, kad galėtume jį naudoti, ji turi turėti pavadinimą N. Ji ketina produkcijos int, kad nereikia vardą. Galime palikti pagrindinė, ar kas yra naudojant mane prisiminti šią vertę, jei mes nori su savo kintamasis. 

Ir, vėlgi, vienintelis naujas raktažodžių čia yra grąžinimas. Ir aš tiesiog daro kai matematiką. Jei aš tikrai norėjau būti nereikalingas, Galėčiau pasakyti, INT Produktui patekus n kartų n. 

Ir tada galėčiau pasakyti, grąžinti produktą. Bet vėl gi, mano taško ankstesnė tai tik nėra geras design-- kaip, kodėl įvesti vardą, simbolis, kaip ir produktas, tiesiog iš karto ją grąžinti? Tai šiek tiek švaresnis, šiek tiek griežtesnė, todėl kalbėti, tiesiog pasakyti grąža n kartų n atsikratyti šios linijos apskritai. 

Ir tai tik mažiau kodas skaityti, mažiau galimybė klaidų. Ir pažiūrėkime, jei tai realiai dabar dirba. Dabar aš ruošiuosi eiti į priekį ir padaryti grąžinimą. 

Uh-oh, numanoma deklaracija funkcija. Aš padariau šią klaidą anksčiau, ne big deal. Leiskite tiesiog įveskite arba pažymėkite ir kopijuoti, lygiai toks pats funkcija prototipas, arba parašas, iš funkcijos čia. Arba galėčiau judėti visą funkciją. 

Bet tai šiek tiek tingus. Taigi, mes to nedarys. Dabar leiskite man padaryti grąžinimą vėl dot velniop grąžą. 

x yra 2 x kvadratu yra 4. x yra 3 x kvadratu yra 9. Ir ši funkcija atrodo dabar, kad reikia dirbti. Taigi koks skirtumas čia? Turiu funkciją, kuri vadinama aikštė, šiuo atveju, kurį aš įdėti į vieną iš įvesties duomenų. Ir aš grįšiu išėjimą. Ir dar, anksčiau, jei Aš atidaryti kitą pavyzdį iš anksčiau, kuris buvo vadinamas prototype.c, Turėjau spausdinimo vardą, kuris grįžo negaliojančiu, taip sakant, Arba jis grįžo nieko, ir tiesiog turėjo šalutinį poveikį. 

Taigi, kas čia vyksta? Na, mano funkcija gauti eilutę tik už momentu. Mes jau naudojant funkciją gauti eilutę tokiu būdu:. 

Mes turėjome funkcija gauti eilutė, kaip įtraukti CS50.h, įtraukti standartinę IO.h, INT, Main, negaliojančiu. Ir tada kiekvieną kartą aš vadinamas Gauti eilutė iki šiol, Sakiau kažkas panašaus, styginių -ai gauna gauti eilutę, nes vakaronė string-- tegul vadina get.c-- get eilutę pati grąžina eilutę, kad aš galiu tada naudoti, ir sako, labas, kablelis, proc S, Backslash N, S. 

Taip tai yra tas pats pavyzdys, tikrai, kad mes turėjome anksčiau. Taigi gauti eilutė grąžina vertę. Tačiau prieš akimirką, spausdinti eilutė negrąžina vertę. Ji tiesiog turi šalutinį poveikį. Taigi tai yra esminis skirtumas. Mes matėme skiriasi tipų funkcijas dabar, kai kurios iš jų grąžintas vertybes, iš kurių kai kurie ne. Taigi gal tai virvutė, ar INT, ar plūdė. O gal tai tiesiog tuščia. 

Ir skirtumas yra kad šios funkcijos, kad gauti duomenis ir grąžina reikšmę iš tikrųjų yra pareikšti kažką atgal prie stalo, taip sakant. Taigi eikime į priekį ir pažvelgti vieną galutinį rinkinys pavyzdžių, kad įprasmina, dabar iš kaip mes galime, tiesą sakant, abstraktus geriau, ir geriau, ir geriau, ar daugiau, ir daugiau, ir daugiau, tam, rašyti, galiausiai geriau kodą. Vykime į priekį, ir dvasia nuo nulio, atlikite šiuos veiksmus. 

Leiskite man eiti į priekį ir taip pat CS50.h ir standartinė IO.h. Leiskite man eiti į priekį ir suteikti aš int, pagrindinė, negaliojančia. Ir leiskite man eiti į priekį, tai vadiname cough.c. 

Ir leiskite man eiti į priekį ir tik kaip nulio, atsispausdinti kosulio / n. Ir aš noriu tai padaryti tris kartus. Taigi, aš, žinoma, tik ketina nukopijuoti ir įklijuoti tris kartus. Aš dabar ketina padaryti kosulys dot velniop kosulys. Duokime sau šiek tiek daugiau vietos čia Įveskite, kosulys, kosulys, kosulys. 

Yra, žinoma, jau yra galimybė tobulinti. Aš nukopijuoti ir įklijuoti kelis kartus šiandien. Bet tai buvo tik todėl aš ne turite įvesti kaip daug simbolių. Aš vis dar pasikeitė, ką tie eilučių kodo yra. 

Šie trys geležinkelio linijos yra identiški, kuris jaučiasi tingus ir iš tiesų yra, ir tikriausiai nėra teisingas požiūris. Taigi, ką ingredientas galėtume pagerinti šį kodą? Neturime kopijuoti ir įklijuoti kodą. 

Ir, iš tiesų, bet kuriuo metu galite jaustis Būk kopijuodami, ir net ne keisti kodą, šansai yra ten geriau. Ir, iš tiesų, yra. Leiskite man eiti į priekį ir daryti už kilpos, nors sintaksė gali ne ateiti natūraliai dar. 

Ar tai tris kartus, tiesiog atlikdami following-- ir aš atsitikti žinau, tai iš praktikos. Bet mes turime pavyzdžių dabar. Ir pamatysite internete daugiau nuorodos ramiai. 

Tai yra sintaksė 6 linija, kad panašiai kaip nulio, kad kartoja blokas, pakartoti šiuos tris kartus. Tai šiek tiek magiška dabar. Bet tai gaus daugiau, ir labiau susipažinę. 

Ir tai vyksta pakartoti linija aštuonių tris kartus, taip, kad jei aš iš naujo kompiliuoti makiažo kosulys, taškas velniop kosulys, kosulys, kosulys, kosulys. Jis vis dar veikia taip pat. Taigi, kad viskas gerai ir gerai. Bet tai nėra labai abstrakti. 

Tai visiškai teisinga. Tačiau ji mano, kaip ten galėtų būti galimybė, kaip ir pasaulyje Nulio, kad rūšies pradžios Tam tikru semantiką įtraukti čia, kad Nemanau, tiesiog kai už kilpos, ir funkcija, kuri sako kosulys, ar nėra kosulys. Zinai ka? Leiskite man pabandyti būti tiek žemesnė nei, kad ir iš tikrųjų parašyti funkciją, kuri turi keletą šalutinį poveikį, vadina tai kosulys. 

Ir tai trunka ne įvestį ir grįžta jokios vertės, nes produkcijos. Bet žinote, ką ji daro? Ji this-- printf, citata citatos pabaiga, kosulys. 

Ir dabar čia, aš ruošiuosi eiti į priekį ir int, Aš gauna nulį, aš mažiau nei 3, I plius plius. Aš ruošiuosi negali padaryti printf, kuris yra be abejo lygio įgyvendinimas mažas detalė. Man nerūpi, kaip kosulys. Aš tik noriu naudoti kosulys funkciją. Ir aš tik ketina skambinti kosulys. 

Dabar, pastebėsite dichotomiją. Kai skambinate funkciją, jei jūs neturite noriu duoti tai įėjimai, visiškai gerai. Just do atviros paren, netoli paren ir baigsite. 

Kai jūs nustatote funkciją arba paskelbti funkcija anketa prototipas, jei iš anksto žinoti, kad tai ne ketina imtis jokių argumentų, pasakyti negalioja tose skliausteliuose ten. Ir tai daro tam, kad jūs nebus netyčia netinkamai ją. Leiskite man eiti į priekį ir padaryti kosulys. Ir, žinoma, aš padariau klaidą. 

Po perkūnais, ten, kad numanomas pareiškimas. Bet tai gerai. Tai lengva nustatyti. Aš tiesiog reikia prototipas aukščiau mano failo nei aš iš tikrųjų jį naudoti. 

Taigi dabar leiskite man padaryti kosulys vėl gražus. Dabar ji veikia. Padaryti kosulį, kosulys, kosulys, kosulys. Taigi jūs manote, kad mes tikrai tik per inžinerija šią problemą. Ir, tiesą sakant, mes esame. Tai nėra geras kandidatas programos metu ir yra skirti metu Pertvarkymas, ir daro tai, kas vadinama hierarchinė, skilimas, kur jūs imtis tam tikrą kodą, tada jums rūšies faktorius dalykų, ir todėl kaip priskirti daugiau semantiką jiems ir pakartotinai jį galiausiai ilguoju laikotarpiu. Bet tai statybinis blokas link sudėtingesnių programų kad mes pradėsime raštu prieš ilgas, kad leidžia mums turėti žodyną su kuriuo būtų galima rašyti geriau kodą. Ir, iš tiesų, galime pamatyti, jei mes negali apibendrinti tai toliau. 

Atrodo šiek tiek chromo, kad aš, pagrindinė, reikia nerimauti šio darn už kilpos, ir vėl ir vėl skambina kosulys. Kodėl aš negaliu tiesiog pasakykite kosulys, Prašome kosulys tris kartus? Kitaip tariant, kodėl negaliu aš tiesiog duoti prisidėti prie kosulys ir tai padaryti? 

Kodėl aš negaliu tiesiog pasakyti, kad Pagrindinis kosulys tris kartus. O dabar, tai yra rūšies stebuklinga. Tai labai pasikartojantis čia. Ir tai, tiesą sakant, kūdikis žingsnis. 

Bet tik gebėjimas pasakyti linija aštuoni, kosulys tris kartus, tai tik tiek daug skaityti. Ir plius, aš neturiu žinoti ar rūpintis, kaip kosulys yra įgyvendinama. Ir, tiesą sakant, vėliau į Terminas ir galutinių projektų, jei jums spręsti projektą su klasiokas ar du klasiokai, jūs suprasite, kad jūs ketinate turi, ar nori, padalinti darbą. 

Ir jūs ketinate norite nuspręsti iš anksto, kas vyksta ką daryti, ir kurioje vienetų? Ir ar nebūtų malonu jei jums, pavyzdžiui, pasirūpinti rašymo Main, padaryti. Ir jūsų draugas, ar jūsų partneris apskritai rūpinasi įgyvendinimo kosulys. 

Ir šis skyrius, tai sienos imti, ar sluoksniai abstrakcijos jei jūs, yra super galingas, nes ypač didesni, daugiau sudėtingų programų ir sistemų, tai leidžia keliems žmonėms kurti viskas kartu, ir galiausiai dygsnio savo darbą kartu šiuo būdu. Bet, žinoma, mes reikia dabar nustatyti kosulys. Turime pasakyti, kosulys kad, ei, jūs žinote, ką? Jūs ketinate reikia vartoti input-- todėl ne tuščias, bet int ir dabar. Vykime į priekį ir įdėti į kosulys Int. Aš gauna nulį. 

i yra mažiau nei kaip daug kartų. Pasakiau tris anksčiau. Bet tai nėra tai, ką aš noriu. Noriu kosulys turi būti apibendrinti remti bet kokią iteracijų skaičių. 

Taigi, iš tiesų, tai N, kad aš noriu, kokia vartotojas man sako. Dabar galiu eiti į priekį ir pasakyti spausdinimo kosulys. Ir nesvarbu, ką numeris vartotojas pereina į, Aš pakartoti, kad daug kartų. 

Būdamas dienos pabaigoje, Programa yra identiški. Tačiau pastebėti visą šį stuff netgi gali būti kitoje byloje. Iš tiesų, aš nežinau, ne momentas, kaip printf yra įgyvendinama. 

Aš nežinau, šiuo metu, kaip gauti eilutė, arba gauti int, arba gauti plūdę būtų įgyvendintos. Ir aš nenoriu matyti mano ekrane. Kadangi tai yra, aš pradedu sutelkti dėmesį į mano programa, o ne tas funkcijas. 

Ir taip, iš tiesų, kaip tik Jums pradėti faktoringo kodą panašaus į tai dėmesį, gal mes net judėti kosulys į atskirą failą? Kažkas gali ją įgyvendinti. Ir jūs, ir jūsų programa tapo labai graži, ir labai skaitoma, be abejo, tikrai keturi eilutės programa teisę ten. 

Taigi eikime į priekį dabar ir padaryti dar vieną pakeitimą. Atkreipkite dėmesį, kad mano prototipas turi pakeisti iki viršaus. Taigi leiskite man nustatyti, kad tiek I do not get rėkė ne. 

Padaryti kosulys, leiskite man paleisti kosulys kartą daugiau, vis dar daro tą patį. Bet dabar, pastebėsite, mes turime ingredientas vieną galutinę versiją. Zinai ka? Aš nenoriu tiesiog kosulys, nebūtinai. Noriu turėti kažką bendresnio pobūdžio. Taigi jūs žinote, ką? Noriu tai padaryti. Noriu turėti, panašiai kaip nulio daro A tarkim blokas, bet ne tik pasakyti kažką šiek kartų. Noriu pasakyti, labai konkrečią eilutę. Ir todėl aš ne nori, kad ji tiesiog pasakyti kosulys. Noriu pasakyti, kokia eilutė praėjo. 

Taigi pastebėti, aš apibendrinti tai, kad dabar tarkim jaučiasi gerą vardą už tai, kaip nulio, trunka du argumentus, skirtingai nuo nulio. Vienas iš jų yra eilutė. Vienas iš jų yra int. 

Ir aš galėčiau juos pereiti. Aš tiesiog lyg idėjos pasakyti eilutę, ir tada kiek kartų vėliau. Tuštuma reiškia, kad jis vis dar negrąžina nieko. Tai tik vizualus pusė poveikis, pavyzdžiui, su [? Jordanija,?] žodinis šalutinis poveikis šaukti. Jis vis dar daro kažką n kartų, 0 iki, bet nėra lygus n. Tai reiškia, N bendras kartus. Ir tada tiesiog atsispausdinti kad ir ką eilutė yra. Taigi aš tikrai apibendrintas Ši eilutė kodo. Taigi, dabar, kaip man įgyvendinti kosulys funkcija? 

Galiu padaryti void kosulys. Ir aš vis dar galite imtis, kaip daug kartų norite kosulys. Bet žinote ką? Dabar galiu punktas turi pasakyti. 

Galiu skambinti pasakyti su Žodis kosulys, einančios į n. O jei aš noriu taip pat įgyvendinti tiesiog for fun, čiaudant funkcija, Galiu čiaudėti tam tikrą skaičių kartų. Ir galiu laikyti pakartotinai n, nes pastebėti, kad M Šiame kontekste arba taikymo srities egzistuoja tik per šią funkciją. 

Ir n šiuo atveju tik egzistuoja per šią funkciją čia. Taigi mes grįžti į Šie apimties klausimus. Ir čia, aš tik norėčiau pasakyti, achoo, tada n kartų, kabliataškis. 

Ir dabar, aš tiesiog reikia skolintis tai funkcija parašai čia. Taigi kosulys yra teisinga. Atkrenta čiaudėti yra teisinga dabar. 

Ir aš vis dar tiesiog reikia pasakyti. Taigi, aš ruošiuosi pasakyti, tarkim eilutė S, int n, kabliataškis. Taigi aš per Inžinerijos gi iš šios programos. 

Ir tai daro ne nebūtinai reiškia tai ką daryti, kai raštu net programas Paprasčiausias. Imtis ko nors tai akivaizdžiai tikrai paprasta, tikrai trumpas, ir ją iš naujo įdiegti naudojant taip per daug kodą. Bet jūs iš tikrųjų pamatysite ir laikas atsigręžti į šiuos pavyzdžius, ir suvokti, oi, tai yra žingsniai mes priėmėme, kad iš tikrųjų apibendrinti, veiksnys kažką iš, kol ne dienos pabaigoje mano kodas yra iš tikrųjų labai protinga. Nes jei aš noriu kosulys trys kartų tada čiaudėti tris kartus, Aš tiesiog ketinate pakartotas tai, Programa padaryti kosulį, ir paleisti kosulys. Ir aš turiu tris kosulys ir trys čiaudint. 

Ir todėl tai yra pagrindinis paradigma, jei norite, kiek mes galime eiti apie realiai įgyvendinti programą. Bet tegul tik pamatyti, ką tai mes darome visą šį laiką, ir ką kai kurie iš galutinių gabalus yra už šią paprastą komandą. Tuo dienos pabaigos, mes buvo naudojant žvangėjimas, kaip mūsų kompiliatorių. Mes jau raštu šaltinį kodas, konvertuoti jį per žvangėjimas į mašininį kodą. 

Ir mes jau naudojate Padaryti tik siekiant palengvinti mūsų klavišų taip kad mes neturime prisiminti tie užkalbėjimai apie pati žvangėjimas. Bet kas yra Padaryti tikrųjų daro? Ir, savo ruožtu, kas yra Žvangėjimas tikrųjų daro? 

Pasirodo, nors mes supaprastinta Šiandienos diskusija, sakydamas, vartojate kodą, perduoti ją kaip įėjimo į kompiliatorių, kuris suteikia jums galingumas mašina kodas, paaiškėja, ten keletas skirtingų žingsnių viduje ten. Bei rengiant atsitinka būti skėtis terminas, visa krūva žingsnius. Bet tegul tiesiog erzinti tai iš tikrųjų greitai. 

Pasirodo, kad mes darome daugiau dalykų, kiekvieną kartą, kai aš paleisti programą, arba kiekvieną kartą aš parengia programą šiandien. Taigi pirminio apdorojimo remiasi this-- nieko C programa, kaip matysime vėl ir vėl, kad prasideda šio grotelėmis, arba hashtag simbolis čia reiškia tai Preprocesorius direktyva. Tai reiškia, kad, šiuo atveju, ei kompiuteris, kažką daryti su šiuo failu kol jūs iš tikrųjų kaupia savo nuosavą kodą. 

Šiuo atveju, maišos apima yra, iš esmės, C anketa būdas pasakyti, ei kompiuteris, eikite gauti turinį iš CS50.h ir įklijuokite jį čia. Ei kompiuteryje, eikite gauti turinys standartinio IO.h, kur, kad yra dėl kietąjį diską, įdėkite jį čia. Taigi tie dalykai atsitiks Pirmasis pirminio apdorojimo metu. 

Ir klingsėti daro visa tai mums. Ir ji ją taip adyti greitai, jums net nereikia matyti keturis skirtingus dalykus vyksta. Bet tai pirmas toks žingsnis. 

Kas iš tikrųjų vyksta toliau? Na, kitą oficialus žingsnis yra sudarymą. Ir paaiškėja, kad Sudarant programą techniškai tai vyksta nuo kodo, stuff mes buvo raštu šiandien kažką vadinamas surinkimo kodas, kažkas kad atrodo šiek tiek kitoks. 

Ir, iš tiesų, galime pamatyti tai labai greitai. Leiskite tikrųjų eiti į mano IDE. Leiskite man eiti į priekį ir atvira hello.c, kuris yra pirmasis programa, su kuria mes prasidėjo šiandien. Ir leiskite man eiti į priekį ir paleisti žvangėjimas A šiek tiek kitaip, klingsėti-S, hello.c, kuris yra iš tikrųjų ketiname duok man kitą failą hello.s. 

Ir mes tikriausiai niekada vėl pamatyti šį kodą natūra. Pavartojus žemesnio lygio sistemos klasė kaip CS61, pamatysite daug daugiau Šio kodo rūšies. Bet tai asemblerio kalba. Tai X86 asemblerio kalba kad CPU, kuris yra grindžiamas CS50 IDE tiesų supranta. 

Ir paslaptingas, kaip ji veikia atrodo, kad yra kažkas kompiuteris supranta gana gerai. Q punktas tai yra atimties. Yra judesiai. 

Yra skambina funkcijų čia x oring, judėjimas, add, pop, grįžti. Taigi yra keletas labai žemo lygio instrukcijos kad procesorius suprantu, kad Aš užsiminiau anksčiau. Tai yra tai, ką "Intel" viduje. 

Yra modeliai nuliai ir tie, kurie žemėlapį į juos arcanely suformuluotas, tačiau šiek tiek gerai pavadinta, instrukcijos, taip sakant. Tai yra tai, kas atsitinka, kai Jūs kaupia kodą. Jūs gaunate surinkimas kalba iš jo, kuris reiškia, kad Trečiasis žingsnis yra surinkti kad surinkimas kodą į galiausiai mašina code-- nulių ir, ne tekstas, kad mes tik pamačiau prieš momentas. 

Taigi iš anksto apdorojimas ar tai rasite ir pakeisti, ir keletas kitų dalykų. Kaupimas trunka jūsų šaltinis Kodas iš C kodo kad mes rašė, kad susirinkimų kodas, kad mes tiesiog žvilgtelėjau. Montavimas trunka šioje asamblėjoje kodas nulių ir tie kad CPU tikrai bus suprasti tuo dienos pabaigoje. Ir susiejimas yra paskutinis žingsnis kad atsitinka us-- vėl taip greitai mes net notice--, kad sako, ei kompiuteris, imtis visų NULIUS ir tie, kurie lėmė sudarymo Dovydo kodą ir jo pagrindinė funkcija šiuo atveju. 

Ir ei kompiuteris, eikite gauti visi nulių ir kad CS50 darbuotojai rašė viduje CS50 bibliotekoje. Sumaišykite tie su Dovydo. Ir ei kompiuteryje, eikite gauti visus nulius ir tie, kurie kažkas rašė metų prieš už printf. Ir pridėti tuos Into the Visa tai, kad mes gavau mano nulių ir The CS50 štabo nulių ir, kad printf nulių ir, ir visa kita mes naudojame. 

Jie visi gauti sujungti kartu į vieną programa, vadinama, šiuo atveju, labas. Taigi nuo šiol, mes tiesiog naudoti žodį sudarymą. Ir mes priimame kaip savaime, kad kai mes sakome, sudaryti savo programą, tai reiškia, ei padaryti pirminį tvarkymą, montavimas, ir susiejimas. Bet ten tikrai kai sultingas Daiktai ten vyksta po gaubtu. Ir ypač jei gauti smalsu šiek tiek laiko, galite pradėti išnyra aplink šio žemesnio lygio. Bet dabar, suprantu, kad tarp šiandienos takeaways yra gana tiesiog pradžioje proceso, gauti patogi su kažkas panašaus hello world. Iš tiesų, dauguma, ką mes padarėme šiandien tikrai nebus kriaukle super greitai. Ir tai bus šiek tiek laikas, o kai praktika. Ir šansai yra, jūs rūšiuoti iš norime, kad pasiektų savo klaviatūra arba klykauti į ekraną. Ir visa tai Gerai. Nors, galbūt bandyti ne tai padaryti bibliotekoje tiek daug. 

Ir galiausiai, jūs Gebėti nors pradėti matome modelius, tiek geros kodas kad rašėte ir klaidų kad jūs atlikote. Ir panašiai kaip proceso tampa TF arba CA yra panašus, Jūs pradėsite geriau ir geriau pamatyti tuos modelius, ir tik sprendžiant savo savo problemas galiausiai. Tuo tarpu, ten bus daug mums skolinti jums paramą ir jums per tai. Ir rašymo langų už visų problemų jums reikia vadovautis per visi iš komandų kad aš tikrai žinau iš daug praktikos dabar, bet galėjo nuskraidinti virš galvos dabar. Ir tai visiškai gerai. 

Bet, galų gale, jūs ketinate pradėti pamatyti modeliai atsirasti. Ir kai jūs saves palikti visas kvailas detalės, pavyzdžiui, skliausteliuose, ir garbanotas petnešos, ir kabliataškiai, ir stuff, tiesą sakant, kad yra ne visi intelektualiai įdomu. Ir ji yra ne tikslas vartojant bet kokį įvadinio užsiėmimo. Tai idėjos, kurios ketina pailsėti. 

Tai kilpos, o sąlygos, ir funkcijos, kurios, ir galingiau abstrakcija, ir kodas faktoringas, ir geras dizainas ir gera stiliaus, ir galiausiai teisingumas Jūsų kodas, tai galiausiai ketina klausimas labiausiai. Taigi, kitą savaitę, mes imsimės juos idėjos, kad mes pirmą kartą pamačiau per Scratch ir dabar išversti C. Ir mes pradėsime pasirinkti pirmąją iš Žinoma nekilnojamojo pasaulio domenai. 

Mes sutelkti dėmesį į saugumą pasaulyje, o konkrečiau kriptografijos, iš kodavimo informacijos str. Ir vienas iš pirmųjų problemos tu gaus rašyti ne tik žaisti su kai kurių sintaksė ir sprendžiant kai logiška problemos, galiausiai prieš ilgas, yra iš tikrųjų peštynės arba užšifruoti, ir galiausiai iššifruoti informaciją. Ir viskas, ką padarei Šiandien bus gana žemas lygis, yra tik ketina leisti mums imtis vieno, ir vienas, ir dar vienas žingsnis link aukščiau raštu įdomiausią kodą dar. 

Taigi daugiau apie tai kitą savaitę. 

[Vaizdo įrašų atkuriamų] 

-Kas Gali man pasakyti apie paskutinį kartą matėte jį? -Kas Aš galiu pasakyti, tikrai? Aš turiu galvoje, tai buvo kaip ir visi kiti prieš gamybą repeticija, išskyrus ten buvo kažkas pasakė pačioje pabaigoje, kad pakimba su manimi. 

-Tai Buvo CS50. 

-Tai Yra supjaustyti visi, puikus darbas ant repeticija. 

-Tai Pietums? 

-Yeah, Tu ir aš galiu patraukti sumuštinį truputį. Leiskite aptarime su Davidas tikrai greitai. Dovydas? Dovydas? 

[PABAIGA PLAYBACK] 