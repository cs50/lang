1
00:00:00,000 --> 00:00:00,500

2
00:00:00,500 --> 00:00:02,490
[MUSIC PLAYING]

3
00:00:02,490 --> 00:00:16,950

4
00:00:16,950 --> 00:00:19,240
>> DAVID J. Malan: Très bien, cela est CS50.

5
00:00:19,240 --> 00:00:21,010
Et ceci est la première semaine.

6
00:00:21,010 --> 00:00:25,050
Donc, rappeler que la dernière fois dans la semaine zéro,
nous nous sommes concentrés sur la pensée de calcul.

7
00:00:25,050 --> 00:00:28,440
Et nous sommes passés de celui
Scratch, une programmation graphique

8
00:00:28,440 --> 00:00:30,360
la langue de nos amis
au Media Lab du MIT.

9
00:00:30,360 --> 00:00:34,730
>> Et avec Scratch, ne nous explorons
des idées comme les fonctions et les conditions,

10
00:00:34,730 --> 00:00:38,210
et les boucles et les variables, et même
les événements et les discussions, et plus encore.

11
00:00:38,210 --> 00:00:40,880
Et aujourd'hui, nous allons
continuer à utiliser ces idées,

12
00:00:40,880 --> 00:00:43,630
et vraiment les prendre pour
acquis, mais les traduire

13
00:00:43,630 --> 00:00:47,220
à une autre langue connue sous le nom C. Maintenant,
C est un langage plus traditionnel.

14
00:00:47,220 --> 00:00:49,020
Il est un niveau inférieur
la langue, si vous voulez.

15
00:00:49,020 --> 00:00:50,300
>> Il est purement textuel.

16
00:00:50,300 --> 00:00:52,910
Et donc, à première vue, il est
tout va regarder plutôt cryptique

17
00:00:52,910 --> 00:00:54,430
si vous ne l'avez jamais programmé auparavant.

18
00:00:54,430 --> 00:00:56,530
Nous allons avoir
points-virgules et les parenthèses,

19
00:00:56,530 --> 00:00:58,150
et accolades, et plus encore.

20
00:00:58,150 --> 00:01:00,240
Mais se rendre compte que même
si la syntaxe est

21
00:01:00,240 --> 00:01:03,600
sur le point de regarder un peu familier
à la plupart d'entre vous, voir passé.

22
00:01:03,600 --> 00:01:06,220
Et essayer de voir les idées
qui sont, en effet, familier,

23
00:01:06,220 --> 00:01:09,750
car ici en première semaine ce
nous allons commencer à faire est de comparer,

24
00:01:09,750 --> 00:01:11,980
initialement, Scratch contre C.

25
00:01:11,980 --> 00:01:15,350
>> Ainsi, par exemple, rappeler que lorsque nous
mis en œuvre le premier de nos programmes

26
00:01:15,350 --> 00:01:19,220
la dernière fois, nous avions un bloc qui avait l'air
un petit quelque chose comme this-- quand

27
00:01:19,220 --> 00:01:22,990
drapeau vert cliqué, et puis nous avons eu
une ou plusieurs pièces de puzzle en dessous,

28
00:01:22,990 --> 00:01:25,150
dans ce cas, dire bonjour monde.

29
00:01:25,150 --> 00:01:27,870
Donc, en effet, dans Scratch,
lorsque je clique sur le drapeau vert

30
00:01:27,870 --> 00:01:30,390
pour exécuter mon programme, de sorte
de parler, ce sont

31
00:01:30,390 --> 00:01:32,520
les blocs qui s'exécutés, ou l'exécution.

32
00:01:32,520 --> 00:01:35,230
Et, plus précisément, Scratch
dit, bonjour, monde.

33
00:01:35,230 --> 00:01:38,377
>> Maintenant, je pourrais avoir spécifié
différents mots ici.

34
00:01:38,377 --> 00:01:40,960
Mais nous verrons que, en effet, beaucoup
de ces blocks-- et, en fait,

35
00:01:40,960 --> 00:01:44,880
en C beaucoup functions-- peuvent être
paramétrés ou personnalisés

36
00:01:44,880 --> 00:01:46,150
faire des choses différentes.

37
00:01:46,150 --> 00:01:48,520
En effet, si l'on en C
voulez convertir, maintenant,

38
00:01:48,520 --> 00:01:50,567
ce programme de Scratch
à cette autre langue,

39
00:01:50,567 --> 00:01:52,650
nous allons écrire un
petit quelque chose comme ça.

40
00:01:52,650 --> 00:01:55,540
>> Certes, il y a une certaine inconnue
syntaxe il le plus probable, int,

41
00:01:55,540 --> 00:01:57,380
et entre parenthèses, et non avenu.

42
00:01:57,380 --> 00:02:00,740
Mais printf-- même si vous le feriez
pense que ce serait tout simplement l'impression.

43
00:02:00,740 --> 00:02:03,120
Mais l'impression des moyens d'impression
formaté, comme nous le verrons bientôt.

44
00:02:03,120 --> 00:02:05,140
Cela va littéralement imprimer
à l'écran quelle que soit

45
00:02:05,140 --> 00:02:08,990
est à l'intérieur de ces parenthèses, qui
bien sûr, dans ce cas est, bonjour monde.

46
00:02:08,990 --> 00:02:12,290
>> Mais vous remarquerez une autre
syntaxe, certains guillemets doubles,

47
00:02:12,290 --> 00:02:14,890
que les parenthèses à la fin,
le point-virgule et analogues.

48
00:02:14,890 --> 00:02:18,027
Donc, il y a un peu de frais généraux,
pour ainsi dire, à la fois cognitivement

49
00:02:18,027 --> 00:02:20,860
et syntaxiquement, que nous allons
d'avoir à se rappeler avant longtemps.

50
00:02:20,860 --> 00:02:23,720
Mais se rendre compte que la pratique,
cela va commencer à sauter à vous.

51
00:02:23,720 --> 00:02:27,920
>> En fait, nous allons concentrer sur celui-là
fonction specifically-- dans ce cas,

52
00:02:27,920 --> 00:02:29,290
dire bonjour monde.

53
00:02:29,290 --> 00:02:30,560
Donc, dire est la fonction.

54
00:02:30,560 --> 00:02:34,320
Bonjour tout le monde est son paramètre,
ou un argument, sa personnalisation.

55
00:02:34,320 --> 00:02:37,320
>> Et l'équivalence en C est juste
va être cette seule ligne ici,

56
00:02:37,320 --> 00:02:41,710
où printf est équivalent à, disons,
la chaîne entre guillemets, bonjour

57
00:02:41,710 --> 00:02:44,470
monde est équivalent, bien sûr,
à ce qui est dans la boîte blanche là-bas.

58
00:02:44,470 --> 00:02:48,680
Et le backslash n, bien qu'un peu
étrange et absent à partir de zéro,

59
00:02:48,680 --> 00:02:52,380
tout simplement va avoir l'effet nous allons
voir dans un ordinateur, comme mon Mac ou un PC,

60
00:02:52,380 --> 00:02:54,660
de simplement déplacer le
curseur à la ligne suivante.

61
00:02:54,660 --> 00:02:56,970
Il est comme frapper
Entrée de votre clavier.

62
00:02:56,970 --> 00:02:58,580
>> Donc, nous allons voir que de nouveau avant longtemps.

63
00:02:58,580 --> 00:03:01,640
Mais d'abord, nous allons jeter un oeil à cette
un autre exemple dans le cas de boucles.

64
00:03:01,640 --> 00:03:05,830
Nous avons eu cette boucle pour toujours la dernière fois,
qui était une série de pièces de puzzle

65
00:03:05,830 --> 00:03:08,490
qui a fait quelque chose littéralement
forever-- dans ce cas,

66
00:03:08,490 --> 00:03:11,360
dire bonjour monde, bonjour monde,
Bonjour tout le monde, bonjour monde.

67
00:03:11,360 --> 00:03:13,350
Il est donc une boucle infinie par la conception.

68
00:03:13,350 --> 00:03:17,580
>> En C, si l'on veut mettre en œuvre cette
même idée, nous pourrions simplement faire ceci.

69
00:03:17,580 --> 00:03:22,570
Bien vrai, printf bonjour monde-- maintenant
tandis que, juste sémantiquement, sorte de

70
00:03:22,570 --> 00:03:26,090
évoque l'idée de faire
quelque chose de nouveau, et encore, et encore,

71
00:03:26,090 --> 00:03:26,980
et pour combien de temps?

72
00:03:26,980 --> 00:03:30,990
Eh bien, le rappel true-- que
vrai est juste ou un.

73
00:03:30,990 --> 00:03:33,660
>> Et vrai est, bien sûr, toujours vrai.

74
00:03:33,660 --> 00:03:36,060
Donc, il est une sorte de sens
déclaration juste pour dire vrai.

75
00:03:36,060 --> 00:03:39,890
Mais en effet, ceci est délibéré,
parce que si vrai est juste toujours vrai,

76
00:03:39,890 --> 00:03:43,850
que tout vrai implique juste,
si un peu indirectement,

77
00:03:43,850 --> 00:03:47,070
que les lignes de code suivantes
entre ces accolades

78
00:03:47,070 --> 00:03:51,320
devrait simplement exécuter à nouveau, et encore,
et encore, et ne jamais cesser réellement.

79
00:03:51,320 --> 00:03:53,230
>> Mais si vous ne voulez que votre
boucle pour arrêter, comme nous

80
00:03:53,230 --> 00:03:57,500
a fait la dernière fois avec quelque chose comme
cela, répéter les 50 heures suivantes,

81
00:03:57,500 --> 00:04:00,700
en C, nous pouvons faire la même chose avec ce qui est
appelé le mot-clé pour loop--

82
00:04:00,700 --> 00:04:02,330
ne pas être tout, mais pour.

83
00:04:02,330 --> 00:04:06,290
Et puis nous avons une nouvelle syntaxe ici,
avec un entier i est égal à 0, i inférieur à 50,

84
00:04:06,290 --> 00:04:06,880
i ++.

85
00:04:06,880 --> 00:04:08,430
Et nous reviendrons à cela.

86
00:04:08,430 --> 00:04:12,660
Mais cela est tout simplement la façon dont nous le ferions
traduire l'ensemble des blocs de grattage

87
00:04:12,660 --> 00:04:16,079
à un ensemble de lignes de code C.

88
00:04:16,079 --> 00:04:17,450
>> Pendant ce temps, tenir compte des variables.

89
00:04:17,450 --> 00:04:19,540
Et, en fait, nous avons juste
vu un il y a un moment.

90
00:04:19,540 --> 00:04:24,220
Et dans le cas de Scratch, si nous
voulu déclarer une variable appelée i

91
00:04:24,220 --> 00:04:27,590
pour i étant entier, juste un nombre,
et nous voulons le mettre à une certaine valeur,

92
00:04:27,590 --> 00:04:31,410
nous devrions utiliser cette orange
bloquer ici-- i mis à 0.

93
00:04:31,410 --> 00:04:33,800
>> Et nous allons voir aujourd'hui et
au-delà, tout comme la semaine dernière,

94
00:04:33,800 --> 00:04:36,850
programmeurs font presque toujours
commencer à compter à partir de zéro, vraiment

95
00:04:36,850 --> 00:04:37,950
par convention.

96
00:04:37,950 --> 00:04:40,250
Mais aussi parce que le rappel de
notre discussion de binaire,

97
00:04:40,250 --> 00:04:42,990
le plus petit nombre possible
représenter avec un nombre quelconque de bits

98
00:04:42,990 --> 00:04:44,640
va tout simplement être 0 lui-même.

99
00:04:44,640 --> 00:04:48,190
Et donc nous allons généralement commencer
initialisant même nos variables à 0.

100
00:04:48,190 --> 00:04:50,710
>> Et en C pour faire la même chose,
nous allons dire int

101
00:04:50,710 --> 00:04:53,110
pour entier, je viens par convention.

102
00:04:53,110 --> 00:04:56,390
Je aurais pu appeler cette variable
tout ce que je veux, comme dans Scratch.

103
00:04:56,390 --> 00:05:00,770
Et puis est égal à 0 seulement ayants droit
la valeur 0 de la droite

104
00:05:00,770 --> 00:05:04,319
et le met dans la variable, ou
Récipient de stockage bas, sur la gauche.

105
00:05:04,319 --> 00:05:07,360
Et le point-virgule comme nous allons see-- et
nous avons vu quelques-unes de ces already--

106
00:05:07,360 --> 00:05:09,530
signifie simplement la fin de la pensée.

107
00:05:09,530 --> 00:05:12,430
Passez à faire autre chose
sur les lignes qui suivent.

108
00:05:12,430 --> 00:05:14,330
>> Maintenant, qu'en est-il des expressions booléennes?

109
00:05:14,330 --> 00:05:17,320
Rappelons que dans Scratch,
ceux-ci étaient des expressions

110
00:05:17,320 --> 00:05:19,740
qui sont soit vrai
ou des questions false--,

111
00:05:19,740 --> 00:05:21,910
vraiment, qui sont soit vrai ou faux.

112
00:05:21,910 --> 00:05:24,960
Donc, dans le cas de Scratch, nous pourrions
poser une question simple comme ça,

113
00:05:24,960 --> 00:05:27,586
est i moins de 50?

114
00:05:27,586 --> 00:05:28,710
Donc je, encore une fois, est un nombre entier.

115
00:05:28,710 --> 00:05:30,210
Peut-être que nous l'utiliser
dans un programme de Scratch

116
00:05:30,210 --> 00:05:32,310
de garder une trace d'une partition
ou quelque chose comme ça.

117
00:05:32,310 --> 00:05:36,810
Donc, cette syntaxe ici Scratch
signifie simplement, est i moins de 50?

118
00:05:36,810 --> 00:05:40,330
Eh bien, heureusement, quelque chose est
simple C. Et à traduire,

119
00:05:40,330 --> 00:05:44,780
cela nous serait tout simplement dire que je moins
à 50, en utilisant la clé familière

120
00:05:44,780 --> 00:05:45,850
sur votre clavier.

121
00:05:45,850 --> 00:05:48,141
>> Pendant ce temps, si vous vouliez
dire quelque chose de plus général,

122
00:05:48,141 --> 00:05:52,890
comme, bien, est x moins y où chaque
x et y sont eux-mêmes des variables?

123
00:05:52,890 --> 00:05:55,280
Nous pouvons faire la même chose
en C, aussi longtemps que nous avons

124
00:05:55,280 --> 00:05:56,942
créé déjà ces variables.

125
00:05:56,942 --> 00:05:58,650
Et nous allons voir comment
faire avant longtemps.

126
00:05:58,650 --> 00:06:01,590
Nous dirions simplement x moins y.

127
00:06:01,590 --> 00:06:03,530
>> Donc, vous commencez à
voir quelques similitudes.

128
00:06:03,530 --> 00:06:06,490
Et ces gens qui ont fait
Scratch étaient certainement

129
00:06:06,490 --> 00:06:08,250
inspiré par certaines de ces idées de base.

130
00:06:08,250 --> 00:06:13,350
Et vous verrez ce genre de
syntaxe dans un grand nombre languages--

131
00:06:13,350 --> 00:06:15,160
pas seulement Scratch, pas
juste C, mais Python,

132
00:06:15,160 --> 00:06:17,790
et JavaScript, et
d'autres langues encore.

133
00:06:17,790 --> 00:06:21,270
>> Considérons une autre construction
de C, la notion d'une condition,

134
00:06:21,270 --> 00:06:23,370
faire quelque chose de manière conditionnelle.

135
00:06:23,370 --> 00:06:25,720
Si quelque chose est vrai, faire cela.

136
00:06:25,720 --> 00:06:27,457
Si quelque chose est vrai, faire cela.

137
00:06:27,457 --> 00:06:30,040
Il est en quelque sorte de la programmation
équivalent d'une bifurcation de la route.

138
00:06:30,040 --> 00:06:32,730
Peut-être qu'il est une fourche à deux voies,
une fourchette à trois voies ou plus.

139
00:06:32,730 --> 00:06:35,800
Et dans Scratch, nous pourrions avoir
vu quelque chose comme ça.

140
00:06:35,800 --> 00:06:37,010
>> Donc, celui-ci est un grand.

141
00:06:37,010 --> 00:06:39,750
Mais considérer le rapport
la simplicité de la logique.

142
00:06:39,750 --> 00:06:47,010
Si x est inférieur à y, dites x est moins
à y, sinon si x est supérieur à y,

143
00:06:47,010 --> 00:06:49,230
dire alors x est supérieur à y.

144
00:06:49,230 --> 00:06:51,300
Et puis, logiquement, si
vous repensez à Scratch

145
00:06:51,300 --> 00:06:55,610
ou tout simplement votre propre intuition humaine,
De plus, si x est inférieure ou égale à y, et x

146
00:06:55,610 --> 00:07:00,000
est pas inférieur à y, alors bien sûr
x va être égal à y.

147
00:07:00,000 --> 00:07:02,690
Donc dans ce cas, par emboîtement
ces blocs de Scratch,

148
00:07:02,690 --> 00:07:05,580
pouvons-nous atteindre trois
fourche chemin dans la route?

149
00:07:05,580 --> 00:07:07,980
>> Pendant ce temps, si nous voulons
faire que, dans C, il sans doute

150
00:07:07,980 --> 00:07:11,420
regarde un peu simpler-- au moins
une fois que vous vous familiariser avec la syntaxe.

151
00:07:11,420 --> 00:07:15,050
Si x est inférieur à y,
printf x est inférieur à y.

152
00:07:15,050 --> 00:07:19,140
Sinon, si x est supérieur à y,
printf x est supérieur à y.

153
00:07:19,140 --> 00:07:24,210
Else printf x est égal à Y- et,
encore une fois, avec les backslash se termine juste

154
00:07:24,210 --> 00:07:27,160
pour les nouvelles lignes de telle sorte que si vous
effectivement couru ce genre de programme

155
00:07:27,160 --> 00:07:28,940
il suffit de déplacer
votre curseur en fin de compte

156
00:07:28,940 --> 00:07:31,100
à la ligne suivante de l'écran.

157
00:07:31,100 --> 00:07:34,270
>> Maintenant, quant à lui Scratch avait d'autres
des fonctionnalités plus sophistiquées, seulement

158
00:07:34,270 --> 00:07:37,320
dont certains que nous allons
déplacer d'abord vers le monde de C.

159
00:07:37,320 --> 00:07:40,010
Et l'un d'entre eux était
appelé une liste dans Scratch.

160
00:07:40,010 --> 00:07:42,100
Et ce fut une spéciale
le type de variable

161
00:07:42,100 --> 00:07:45,840
vous a permis de stocker plusieurs choses
à revenir, à dos, à dos, à l'arrière.

162
00:07:45,840 --> 00:07:48,540
>> En C, il n'a pas
listes, en soi, mais quelque chose

163
00:07:48,540 --> 00:07:51,090
qui sont généralement plus
appelé tableaux, bien que nous allons

164
00:07:51,090 --> 00:07:53,590
revenir plus tard ce semestre
à regarder quelque chose

165
00:07:53,590 --> 00:07:55,780
appelé une liste, ou vraiment une liste liée.

166
00:07:55,780 --> 00:07:58,510
Mais pour l'instant, le plus proche
équivalent en C pour nous

167
00:07:58,510 --> 00:08:00,345
va être quelque chose
appelé un tableau.

168
00:08:00,345 --> 00:08:02,740
Et un tableau est tout simplement un
type spécial de la variable

169
00:08:02,740 --> 00:08:06,160
qui vous permet de stocker des données
dos, à dos, à dos, à dos.

170
00:08:06,160 --> 00:08:08,840
>> Et, en effet, dans Scratch,
si nous voulions accéder

171
00:08:08,840 --> 00:08:12,030
le premier élément d'un tableau ou
un films-- et je vais l'appeler,

172
00:08:12,030 --> 00:08:16,600
par convention, argv argument
vecteur, mais plus sur cela avant longtemps.

173
00:08:16,600 --> 00:08:20,090
Si je veux obtenir le premier élément
de argv, dans le monde du Scratch

174
00:08:20,090 --> 00:08:23,930
vous faites en fait généralement
commencer à compter du 1er.

175
00:08:23,930 --> 00:08:25,850
>> Et donc je pourrais obtenir le point 1 de argv.

176
00:08:25,850 --> 00:08:29,310
C'est juste comment MIT mis en œuvre
la notion de listes.

177
00:08:29,310 --> 00:08:32,860
Mais en C, je vais
plus simplement dire simplement, argv,

178
00:08:32,860 --> 00:08:35,758
qui est à nouveau le nom de mon
films-- ou pour être clair, un tableau.

179
00:08:35,758 --> 00:08:37,549
Et si je veux la première
éléments, je vais

180
00:08:37,549 --> 00:08:40,890
d'utiliser des crochets, que vous
peut-être pas souvent utilisé sous un clavier.

181
00:08:40,890 --> 00:08:43,150
>> Mais 0 signifie juste, me faire le premier.

182
00:08:43,150 --> 00:08:45,160
Donc, à l'occasion, et comme
le temps passe, nous allons

183
00:08:45,160 --> 00:08:47,570
pour commencer à voir ces dichotomies
entre zéro et C,

184
00:08:47,570 --> 00:08:49,070
lequel Scratch utilise un.

185
00:08:49,070 --> 00:08:50,670
Nous en C utilisons 0 ici.

186
00:08:50,670 --> 00:08:52,420
Mais vous verrez rapidement
une fois que vous comprenez

187
00:08:52,420 --> 00:08:55,920
les fondements de chaque langue, que
ces choses commencent à devenir d'autant plus

188
00:08:55,920 --> 00:08:59,860
familiers par la pratique et la pratique.

189
00:08:59,860 --> 00:09:02,700
>> Donc, nous allons effectivement maintenant regarder un programme.

190
00:09:02,700 --> 00:09:07,031
Ici sera la première de notre C
code source de programmes complets.

191
00:09:07,031 --> 00:09:09,280
Et le programme que nous allons
à offrir pour examen

192
00:09:09,280 --> 00:09:12,340
est celui qui est l'équivalent
à ce morceau de Scratch plus tôt.

193
00:09:12,340 --> 00:09:16,210
>> Donc, ici, nous avons ce qui est
sans doute le programme le plus simple C

194
00:09:16,210 --> 00:09:18,410
vous pouvez écrire que
ne fait quelque chose.

195
00:09:18,410 --> 00:09:21,250
Maintenant, nous allons regarder passé,
pour l'instant, a inclure,

196
00:09:21,250 --> 00:09:24,190
io.h standard, et ceux-ci angle
entre parenthèses, et int, et non avenu,

197
00:09:24,190 --> 00:09:25,840
et les accolades, et similaires.

198
00:09:25,840 --> 00:09:28,390
>> Et nous allons nous concentrer sur
ce qui, au moins intuitivement,

199
00:09:28,390 --> 00:09:29,860
pourrait sauter à vous déjà.

200
00:09:29,860 --> 00:09:33,300
En fait, le principal, je ne
savoir nécessairement ce que cela est,

201
00:09:33,300 --> 00:09:37,580
mais beaucoup comme Scratch avait que lorsque
drapeau vert cliqué morceau de puzzle,

202
00:09:37,580 --> 00:09:42,070
il en va de C comme un langage de programmation
avoir un morceau principal de code

203
00:09:42,070 --> 00:09:46,380
est exécuté par défaut. Et en effet,
il est littéralement va être appelé principal.

204
00:09:46,380 --> 00:09:47,720
>> Si principale est une fonction.

205
00:09:47,720 --> 00:09:51,720
Et il est une fonction spéciale qui existe
en C que lorsque vous exécutez un programme,

206
00:09:51,720 --> 00:09:55,720
il est le principal qui obtient géré par
défaut. Dans le monde du Scratch,

207
00:09:55,720 --> 00:09:59,970
il était généralement lorsque le drapeau vert
cliqué qui a obtenu exécuter par défaut.

208
00:09:59,970 --> 00:10:04,130
>> Pendant ce temps, nous avons vu cela avant,
printf ou imprimer au format, qui est

209
00:10:04,130 --> 00:10:08,620
va être une fonction qui vient avec
C, ainsi que tout un tas d'autres,

210
00:10:08,620 --> 00:10:13,140
cette volonté de temps et le temps
encore une fois, afin de faire exactement

211
00:10:13,140 --> 00:10:15,450
comme son nom l'indique, imprimer quelque chose.

212
00:10:15,450 --> 00:10:16,500
Que voulons-nous imprimer?

213
00:10:16,500 --> 00:10:18,770
Eh bien, nous allons voir que
par des caractères enserrant

214
00:10:18,770 --> 00:10:21,680
comme these-- monde bonjour,
backslash n entre guillemets,

215
00:10:21,680 --> 00:10:26,040
nous pouvons dire exactement printf
ce que pour imprimer sur l'écran.

216
00:10:26,040 --> 00:10:29,430
>> Mais pour faire
que nous avons malheureusement

217
00:10:29,430 --> 00:10:33,010
besoin de prendre quelque chose qui est
déjà cryptique pour nous les humains,

218
00:10:33,010 --> 00:10:37,510
mais au moins il est un peu readable--
forte comprennent, io.h standard, int,

219
00:10:37,510 --> 00:10:42,340
principale, vide, printf, toute la magie
incantations nous venons de voir à l'écran.

220
00:10:42,340 --> 00:10:45,470
Mais nous avons effectivement
aller plus mystérieux encore.

221
00:10:45,470 --> 00:10:50,140
Nous devons d'abord traduire le code
que nous écrivons en code machine.

222
00:10:50,140 --> 00:10:54,370
Et rappeler de la semaine dernière que les machines,
au moins ceux que nous connaissons ici,

223
00:10:54,370 --> 00:10:57,450
à la fin de la journée seulement
comprendre zéros et des uns.

224
00:10:57,450 --> 00:11:01,100
>> Et mon Dieu, si nous devions écrire ces
zéros et des uns à fait le programme,

225
00:11:01,100 --> 00:11:04,260
il serait très, très rapidement
prendre du plaisir sur quoi que ce soit.

226
00:11:04,260 --> 00:11:08,150
Mais il se trouve, par la semaine dernière,
que ces schémas de zéros et

227
00:11:08,150 --> 00:11:09,400
juste avoir une signification particulière.

228
00:11:09,400 --> 00:11:11,500
Dans certains contextes,
ils pourraient signifier des chiffres.

229
00:11:11,500 --> 00:11:14,840
>> Dans certains contextes, ils pourraient signifier
lettres ou couleurs, ou un nombre quelconque

230
00:11:14,840 --> 00:11:17,710
d'autres abstractions là sur.

231
00:11:17,710 --> 00:11:21,450
Mais tout comme votre ordinateur
une CPU, Central Processing Unit,

232
00:11:21,450 --> 00:11:23,390
ou le cerveau à l'intérieur de votre ordinateur.

233
00:11:23,390 --> 00:11:25,240
Il est généralement Intel
à l'intérieur, parce que ce

234
00:11:25,240 --> 00:11:27,900
l'une des plus grandes entreprises
qui rend les processeurs pour les ordinateurs.

235
00:11:27,900 --> 00:11:31,910
>> Eh bien, les processeurs Intel et d'autres
ont tout simplement décidé à l'avance

236
00:11:31,910 --> 00:11:36,970
que certains modèles de zéros et
ceux entend des choses spécifiques.

237
00:11:36,970 --> 00:11:40,040
Certains modèles de zéros et
signifiera, imprimer à l'écran,

238
00:11:40,040 --> 00:11:42,710
ou ajouter ces deux nombres, ou
soustraire ces deux nombres,

239
00:11:42,710 --> 00:11:46,310
ou déplacer ce morceau de données à partir
la mémoire de mon ordinateur ici,

240
00:11:46,310 --> 00:11:50,870
ou un nombre quelconque d'autres très bas niveau,
mais finalement utile opérations.

241
00:11:50,870 --> 00:11:56,022
Mais, heureusement, nous, les humains ne vont pas
avoir besoin de connaître ce niveau de détail.

242
00:11:56,022 --> 00:11:59,230
En effet, tout comme la dernière fois, où nous
Abstraite encore, et encore, et encore,

243
00:11:59,230 --> 00:12:01,930
bâtiment de très faible niveau
primitives comme zéros et des uns

244
00:12:01,930 --> 00:12:04,160
à la hausse des concepts de niveau
comme les numéros et les lettres,

245
00:12:04,160 --> 00:12:07,330
et les couleurs, et plus encore,
donc pouvons-nous en tant que programmeurs

246
00:12:07,330 --> 00:12:10,080
se tenir debout sur les épaules de
d'autres qui nous ont précédés

247
00:12:10,080 --> 00:12:14,260
et utiliser des logiciels que d'autres
les gens ont écrit avant us--

248
00:12:14,260 --> 00:12:17,340
à savoir les programmes appelés compilateurs.

249
00:12:17,340 --> 00:12:20,770
>> C est une langue
est habituellement compilé,

250
00:12:20,770 --> 00:12:25,130
ce qui veut dire convertie à partir
le code source en code machine.

251
00:12:25,130 --> 00:12:28,230
En particulier, ce que cela signifie
est que si vous avez la source

252
00:12:28,230 --> 00:12:32,530
code qui vous vous écrivez, comme nous bientôt
sera dans un instant sur l'écran,

253
00:12:32,530 --> 00:12:36,140
et que vous voulez convertir
en fin de compte à la machine code--

254
00:12:36,140 --> 00:12:40,100
ces zéros et ceux qui
seulement votre Mac ou votre PC

255
00:12:40,100 --> 00:12:44,230
understands-- vous avez une première
nourrir que le code source en tant

256
00:12:44,230 --> 00:12:49,340
entrée à une spéciale
programme appelé un compilateur,

257
00:12:49,340 --> 00:12:51,974
la sortie de laquelle nous
doit voir est le code machine.

258
00:12:51,974 --> 00:12:54,890
Et, en effet, la dernière fois nous avons parlé
environ, en fait, à la fin de la journée,

259
00:12:54,890 --> 00:12:55,610
résolution de problème.

260
00:12:55,610 --> 00:12:56,360
Vous avez entrées.

261
00:12:56,360 --> 00:12:57,318
Et vous avez sorties.

262
00:12:57,318 --> 00:12:59,560
Et vous avez une sorte
de l'algorithme dans le milieu.

263
00:12:59,560 --> 00:13:02,830
>> Les algorithmes peuvent sûrement
mis en œuvre dans le logiciel,

264
00:13:02,830 --> 00:13:05,900
comme nous l'avons vu avec pseudocode la semaine dernière
et comme nous le verrons avec le code réel

265
00:13:05,900 --> 00:13:06,490
cette semaine.

266
00:13:06,490 --> 00:13:09,430
Et donc un compilateur vraiment juste
a un ensemble d'algorithmes intérieur

267
00:13:09,430 --> 00:13:13,060
de celui qui sait comment
convertir les mots-clés spéciaux,

268
00:13:13,060 --> 00:13:15,180
comme principal et printf,
et d'autres que nous venons

269
00:13:15,180 --> 00:13:20,620
a vu dans les modèles de zéros et
ceux qui Intel à l'intérieur et d'autres processeurs

270
00:13:20,620 --> 00:13:23,020
comprend réellement.

271
00:13:23,020 --> 00:13:25,460
Alors, comment faisons-nous cela?

272
00:13:25,460 --> 00:13:27,470
Où pouvons-nous obtenir un compilateur?

273
00:13:27,470 --> 00:13:29,400
>> La plupart d'entre nous ont un Mac ou un PC.

274
00:13:29,400 --> 00:13:32,152
Et vous êtes sous Mac OS, ou
Windows ou Linux ou Solaris,

275
00:13:32,152 --> 00:13:33,860
ou un nombre quelconque d'autres
systèmes d'exploitation.

276
00:13:33,860 --> 00:13:35,568
Et, en effet, nous avons pu
aller sur le web

277
00:13:35,568 --> 00:13:38,710
et télécharger un compilateur
pour votre Mac ou votre PC

278
00:13:38,710 --> 00:13:40,360
pour votre système d'exploitation particulier.

279
00:13:40,360 --> 00:13:42,617
Mais nous serions tous sur
différentes pages, pour ainsi dire.

280
00:13:42,617 --> 00:13:44,450
Nous aurions légèrement
différentes configurations.

281
00:13:44,450 --> 00:13:46,210
Et les choses ne fonctionneraient pas tous les mêmes.

282
00:13:46,210 --> 00:13:48,280
Et, en effet, ces jours-ci
beaucoup d'entre nous ne pas utiliser

283
00:13:48,280 --> 00:13:50,516
logiciel qui ne fonctionne que sur nos ordinateurs portables.

284
00:13:50,516 --> 00:13:52,390
Au lieu de cela, nous utilisons quelque chose
comme un navigateur

285
00:13:52,390 --> 00:13:55,930
nous permet d'accès Web
applications dans le nuage.

286
00:13:55,930 --> 00:13:58,630
Et plus tard ce semestre,
nous allons faire exactement cela.

287
00:13:58,630 --> 00:14:02,660
Nous allons écrire des applications ou
logiciel en utilisant code-- pas C,

288
00:14:02,660 --> 00:14:05,860
mais d'autres langages comme Python et
JavaScript-- qui courent dans le nuage.

289
00:14:05,860 --> 00:14:08,860
>> Et pour ce faire, nous nous
au cours du semestre

290
00:14:08,860 --> 00:14:14,890
sera effectivement utiliser un basé sur un nuage
environnement connu sous le nom CS50 IDE.

291
00:14:14,890 --> 00:14:19,030
Ceci est une programmation basée sur le Web
environnement ou développement intégré

292
00:14:19,030 --> 00:14:23,610
environnement, IDe, qui est construit au sommet d'une certaine
logiciel open source appelé Cloud 9.

293
00:14:23,610 --> 00:14:25,966
Et nous avons fait des pédagogique
simplifications à ce

294
00:14:25,966 --> 00:14:28,840
afin de cacher certaines caractéristiques
les premières semaines que nous ne devons,

295
00:14:28,840 --> 00:14:30,770
après quoi vous pouvez
les révéler et faire plus

296
00:14:30,770 --> 00:14:32,400
tout ce que vous voulez avec l'environnement.

297
00:14:32,400 --> 00:14:35,470
>> Et cela nous permet, aussi, de
pré-installer certains logiciels.

298
00:14:35,470 --> 00:14:38,330
Des choses comme un soi-disant CS50
bibliothèque, que nous verrons bientôt

299
00:14:38,330 --> 00:14:42,210
nous fournit en C avec une certaine
des fonctionnalités supplémentaires.

300
00:14:42,210 --> 00:14:47,392
Donc, si vous allez à, finalement, CS50.io,
vous serez invité à vous connecter,

301
00:14:47,392 --> 00:14:49,350
et une fois que vous faites et créer
un compte gratuitement,

302
00:14:49,350 --> 00:14:55,150
vous serez en mesure d'accéder à un
environnement qui semble tout à fait comme ça.

303
00:14:55,150 --> 00:14:56,760
>> Or, ceci est dans le mode par défaut.

304
00:14:56,760 --> 00:14:58,650
Tout est agréable et
lumineux sur l'écran.

305
00:14:58,650 --> 00:15:00,941
Beaucoup d'entre nous ont l'habitude de
travailler sur le morceau de CS50 qui est

306
00:15:00,941 --> 00:15:02,150
assez tard dans la nuit.

307
00:15:02,150 --> 00:15:05,400
Et certains d'entre vous pourraient préférer
transformer en mode nuit, pour ainsi dire.

308
00:15:05,400 --> 00:15:08,550
>> Mais, en fin de compte, ce que vous êtes
aller voir dans les CS50 IDE

309
00:15:08,550 --> 00:15:11,340
est trois areas-- distincte
une zone sur la gauche où

310
00:15:11,340 --> 00:15:15,604
vos fichiers vont être dans la
nuage, une zone en haut à droite

311
00:15:15,604 --> 00:15:17,270
où votre code va être modifiable.

312
00:15:17,270 --> 00:15:19,650
Vous serez en mesure d'ouvrir
onglets individuels pour tout programme

313
00:15:19,650 --> 00:15:22,670
que vous écrivez ce semestre à l'intérieur
de ce coin en haut à droite.

314
00:15:22,670 --> 00:15:26,070
Et puis plus arcanely,
et pourtant puissamment,

315
00:15:26,070 --> 00:15:29,610
va être cette chose à la
bas connu comme une fenêtre de terminal.

316
00:15:29,610 --> 00:15:32,450
>> Ceci est une ancienne école
Command Line Interface,

317
00:15:32,450 --> 00:15:35,240
ou CLI, qui permet
d'exécuter des commandes

318
00:15:35,240 --> 00:15:38,260
sur le computer-- dans ce cas,
l'ordinateur dans le cloud--

319
00:15:38,260 --> 00:15:42,090
à faire des choses comme compiler votre code
à partir du code source en code machine,

320
00:15:42,090 --> 00:15:46,600
pour exécuter vos programmes, ou pour commencer votre
serveur web, ou pour accéder à votre base de données,

321
00:15:46,600 --> 00:15:50,454
et un certain nombre d'autres techniques
que nous allons commencer à utiliser avant longtemps.

322
00:15:50,454 --> 00:15:52,370
Mais pour y arriver, nous sommes
va avoir effectivement

323
00:15:52,370 --> 00:15:54,240
d'aller en ligne et commencer à jouer.

324
00:15:54,240 --> 00:15:57,399
Et pour ce faire, nous allons d'abord
commencer à bricoler avec principale,

325
00:15:57,399 --> 00:15:58,940
et écrire la partie principale d'un programme.

326
00:15:58,940 --> 00:16:02,170
Et nous allons utiliser cette fonction
printf, que nous avons utilisé plus tôt,

327
00:16:02,170 --> 00:16:04,050
tout simplement pour dire quelque chose.

328
00:16:04,050 --> 00:16:07,910
>> Donc ici, je suis déjà à l'intérieur du CS50 IDE.

329
00:16:07,910 --> 00:16:08,930
Je suis connecté à l'avance.

330
00:16:08,930 --> 00:16:10,360
Et je complète DEPISTAGE la fenêtre.

331
00:16:10,360 --> 00:16:12,670
Et donc, en fin de compte, vous
trop de problèmes à venir

332
00:16:12,670 --> 00:16:15,960
suivra les étapes similaires
fournira la documentation en ligne.

333
00:16:15,960 --> 00:16:19,360
Donc, vous ne devez pas vous inquiéter au sujet
absorber chaque petite étape technique

334
00:16:19,360 --> 00:16:20,730
que je fais ici aujourd'hui.

335
00:16:20,730 --> 00:16:22,222
>> Mais vous obtiendrez un écran comme celui-ci.

336
00:16:22,222 --> 00:16:23,430
Je me trouve être en mode nuit.

337
00:16:23,430 --> 00:16:25,944
Et vous pouvez égayer tout
par désactivation du mode nuit.

338
00:16:25,944 --> 00:16:27,860
Et à la fin de la
jour, vous allez voir

339
00:16:27,860 --> 00:16:33,090
ces trois principaux areas-- le fichier
navigateur à gauche, les onglets de code en haut,

340
00:16:33,090 --> 00:16:35,430
et la fenêtre du terminal vers le bas.

341
00:16:35,430 --> 00:16:37,890
>> Laissez-moi aller de l'avant et
écrire mon premier programme.

342
00:16:37,890 --> 00:16:45,300
Je vais aller préemptive dans un fichier,
Enregistrer et enregistrer mon fichier comme hello.c.

343
00:16:45,300 --> 00:16:49,850
En effet, par convention, tout ce que nous programme
écriture qui est écrit dans le langage C

344
00:16:49,850 --> 00:16:52,739
devrait être nommé quelque chose
point c, par convention.

345
00:16:52,739 --> 00:16:56,030
Donc, je vais le nommer hello.c, parce
Je veux juste dire bonjour au monde.

346
00:16:56,030 --> 00:16:57,820
Maintenant, je vais faire un zoom
out et cliquez sur Enregistrer.

347
00:16:57,820 --> 00:17:01,180
Et tout ce que j'ai ici maintenant est un onglet
dans lequel je peux commencer à écrire du code.

348
00:17:01,180 --> 00:17:02,490
>> Cela ne va pas à compiler.

349
00:17:02,490 --> 00:17:03,300
Cela n'a aucun sens.

350
00:17:03,300 --> 00:17:05,750
Et même si je me suis converti
cela zéros et des uns,

351
00:17:05,750 --> 00:17:08,390
la CPU va avoir aucun
idée de ce qui se passe autour.

352
00:17:08,390 --> 00:17:17,170
Mais si j'écris les lignes qui ne correspondent
avec conventions-- C étant de C,

353
00:17:17,170 --> 00:17:23,150
à nouveau, cette language-- avec la syntaxe comme
cela, printf bonjour monde-- et je l'ai

354
00:17:23,150 --> 00:17:25,210
obtenu à l'aise avec
faisant cela au fil du temps.

355
00:17:25,210 --> 00:17:27,510
Donc, je ne pense pas que je fait
toute erreur typographique.

356
00:17:27,510 --> 00:17:30,910
>> Mais, invariablement, la première
fois que vous faites cela, vous.

357
00:17:30,910 --> 00:17:34,090
Et ce que je vais faire pourrait très
bien fonctionne pas pour vous la première fois.

358
00:17:34,090 --> 00:17:36,610
Et c'est parfaitement OK,
parce que maintenant vous

359
00:17:36,610 --> 00:17:40,662
pourrait bien voir un tas de nouveauté,
mais au fil du temps une fois que vous familiariser

360
00:17:40,662 --> 00:17:42,870
avec cet environnement, et
ce langage, et d'autres,

361
00:17:42,870 --> 00:17:45,370
vous allez commencer à voir des choses qui
sont soit correcte ou incorrecte.

362
00:17:45,370 --> 00:17:47,369
>> Et voici ce que le
boursiers d'enseignement et bien sûr

363
00:17:47,369 --> 00:17:51,780
assistants sont tellement bons au fil du temps, est
repérer des erreurs ou des bugs dans votre code.

364
00:17:51,780 --> 00:17:55,110
Mais je prétends qu'il y
n'y a pas de bugs dans ce code.

365
00:17:55,110 --> 00:17:56,990
Je veux maintenant exécuter ce programme.

366
00:17:56,990 --> 00:18:00,440
>> Maintenant, sur mon propre Mac ou PC, je suis en
l'habitude de doubles icônes de cliquetis

367
00:18:00,440 --> 00:18:02,350
quand je veux lancer un programme.

368
00:18:02,350 --> 00:18:04,080
Mais ce n'est pas le modèle ici.

369
00:18:04,080 --> 00:18:07,570
Dans cet environnement, qui est CS50 IDE.

370
00:18:07,570 --> 00:18:10,192
Nous utilisons une exploitation
système appelé Linux.

371
00:18:10,192 --> 00:18:12,900
Linux rappelle une autre
système d'exploitation, généralement connu

372
00:18:12,900 --> 00:18:13,850
comme Unix.

373
00:18:13,850 --> 00:18:19,340
Et Linux est particulièrement connu pour
ayant une ligne de commande de l'environnement, CLI.

374
00:18:19,340 --> 00:18:23,070
Maintenant, nous utilisons un particulier
saveur de Linux appelée Ubuntu.

375
00:18:23,070 --> 00:18:25,770
Et Ubuntu est tout simplement un
certaine version de Linux.

376
00:18:25,770 --> 00:18:30,900
>> Mais de ces Linux ces jours-ci font réellement
venir avec des interfaces utilisateur graphiques.

377
00:18:30,900 --> 00:18:33,360
Et celui que nous arrive de
être en utilisant ici est basé sur le Web.

378
00:18:33,360 --> 00:18:35,735
Donc, cela pourrait regarder même un
peu différent de quelque chose

379
00:18:35,735 --> 00:18:38,310
vous vous pourriez avoir
vu ou courir dans le passé.

380
00:18:38,310 --> 00:18:40,910
>> Je vais donc aller de l'avant
maintenant et faire ce qui suit.

381
00:18:40,910 --> 00:18:43,950
J'ai sauvé ce fichier comme hello.c.

382
00:18:43,950 --> 00:18:50,350
Je vais aller de l'avant et
Type clanghello.c Alors Clang

383
00:18:50,350 --> 00:18:52,850
pour le langage C est un compilateur.

384
00:18:52,850 --> 00:18:54,952
Il est pré-installé dans CS50 IDE.

385
00:18:54,952 --> 00:18:57,910
Et vous ne pouvez absolument télécharger et
installer sur votre propre Mac ou PC.

386
00:18:57,910 --> 00:19:00,910
>> Mais, encore une fois, il n'y aurait pas tous
la pré-configuration fait pour vous.

387
00:19:00,910 --> 00:19:03,940
Donc pour l'instant, je suis juste
va courir clanghello.c.

388
00:19:03,940 --> 00:19:06,240
Et maintenant remarquer cette syntaxe
ici finira

389
00:19:06,240 --> 00:19:09,930
réalise signifie juste que je suis dans un
dossier ou un répertoire appelé espace de travail.

390
00:19:09,930 --> 00:19:14,030
Ce signe dollar est juste convention
de sens, tapez vos commandes ici.

391
00:19:14,030 --> 00:19:17,560
>> Il est ce qu'on appelle une invite, juste
par convention est le signe dollar.

392
00:19:17,560 --> 00:19:22,130
Et si j'aller de l'avant maintenant et cliquez sur
Entrez, rien ne semble s'être produit.

393
00:19:22,130 --> 00:19:23,930
Mais c'est en fait une bonne chose.

394
00:19:23,930 --> 00:19:26,650
Le moins ce qui se passe sur
votre écran, plus il est probable

395
00:19:26,650 --> 00:19:29,710
votre code est d'être correct,
au moins syntaxiquement.

396
00:19:29,710 --> 00:19:32,120
>> Donc, si je veux courir ce
programme, que dois-je faire?

397
00:19:32,120 --> 00:19:36,770
Eh bien, il se trouve que la
le nom par défaut, par convention,

398
00:19:36,770 --> 00:19:41,854
pour les programmes lorsque vous ne spécifiez pas de
le nom de votre programme est juste a.out.

399
00:19:41,854 --> 00:19:44,270
Et cette syntaxe aussi, vous aurez
se familiariser avec avant longtemps.

400
00:19:44,270 --> 00:19:50,500
>> Dot slash signifie juste, hé, CS50
IDE, exécutez un programme appelé a.out

401
00:19:50,500 --> 00:19:52,400
qui est dans mon répertoire en cours.

402
00:19:52,400 --> 00:19:54,520
Ce point signifie le répertoire courant.

403
00:19:54,520 --> 00:19:58,040
Et nous allons voir ce que d'autres telles séquences
de caractères signifie avant longtemps.

404
00:19:58,040 --> 00:20:01,430
>> Alors on y va, Entrée, bonjour monde.

405
00:20:01,430 --> 00:20:03,080
Et vous remarquerez, que ce qui est arrivé?

406
00:20:03,080 --> 00:20:04,580
Non seulement at-il imprimer bonjour monde.

407
00:20:04,580 --> 00:20:08,990
Il a également proposé la
curseur à la ligne suivante.

408
00:20:08,990 --> 00:20:10,160
>> Et pourquoi était-ce?

409
00:20:10,160 --> 00:20:15,400
Quel était le code que nous avons écrit avant
qui veillé à ce que le curseur serait

410
00:20:15,400 --> 00:20:17,882
aller sur la ligne suivante?

411
00:20:17,882 --> 00:20:19,840
Chose drôle au sujet d'un
ordinateur est il va seulement

412
00:20:19,840 --> 00:20:21,570
de faire littéralement ce que vous lui demandez de faire.

413
00:20:21,570 --> 00:20:29,050
>> Donc, si vous le dites à printf bonjour,
virgule, espace, monde, près devis,

414
00:20:29,050 --> 00:20:32,090
il est littéralement ne va
d'imprimer ces caractères.

415
00:20:32,090 --> 00:20:34,980
Mais j'ai eu ce caractère spécial
à la fin, le rappel, backslash n.

416
00:20:34,980 --> 00:20:37,230
Et voilà ce qui assure
que le caractère a

417
00:20:37,230 --> 00:20:39,570
à la ligne suivante de l'écran.

418
00:20:39,570 --> 00:20:41,097
>> En fait, laissez-moi aller et le faire.

419
00:20:41,097 --> 00:20:42,430
Laissez-moi aller de l'avant et de supprimer cela.

420
00:20:42,430 --> 00:20:44,180
Maintenant, notez que la
haut de mon écran, il est

421
00:20:44,180 --> 00:20:45,890
un peu de lumière rouge
l'onglet indiquant,

422
00:20:45,890 --> 00:20:48,047
hey, vous avez pas enregistré votre fichier.

423
00:20:48,047 --> 00:20:50,880
Je vais donc aller de l'avant avec le contrôle
S ou commande S, enregistrez le fichier.

424
00:20:50,880 --> 00:20:54,130
Maintenant, il goes-- est allé pour un vert moment--.

425
00:20:54,130 --> 00:20:56,760
Et maintenant il est de retour à
juste être une icône proche.

426
00:20:56,760 --> 00:21:04,860
>> Si je lance maintenant clanghello.c à nouveau,
Entrez, slash dot, a.out, Entrée,

427
00:21:04,860 --> 00:21:07,110
vous verrez que cela a fonctionné encore.

428
00:21:07,110 --> 00:21:09,020
Mais il est sans doute un peu buggé.

429
00:21:09,020 --> 00:21:11,714
En ce moment, mon espace de travail prompt--,
puis ce signe de dollar,

430
00:21:11,714 --> 00:21:13,880
et puis mon prompt-- réelle
est le tout sur la même ligne.

431
00:21:13,880 --> 00:21:17,540
Donc, cela a certainement un bug esthétique,
même si elle est pas vraiment un bug logique.

432
00:21:17,540 --> 00:21:19,250
>> Donc, je vais défaire ce que je viens de faire.

433
00:21:19,250 --> 00:21:21,560
Je vais relancer a.out.

434
00:21:21,560 --> 00:21:25,710
Remarquez que j'ai ajouté la
newline retour de caractère.

435
00:21:25,710 --> 00:21:27,280
Je l'ai enregistré le fichier.

436
00:21:27,280 --> 00:21:34,630
>> Donc, je vais relancer a.out, et--
dammit, un bogue, un bogue qui signifie erreur.

437
00:21:34,630 --> 00:21:38,020
Ainsi, le bug est que même si
J'ai ajouté le backslash n là,

438
00:21:38,020 --> 00:21:44,180
re-enregistré, re-dirigé le programme,
le comportement était le même.

439
00:21:44,180 --> 00:21:45,640
Pourquoi serait-ce?

440
00:21:45,640 --> 00:21:46,910
>> Il me manque une étape, non?

441
00:21:46,910 --> 00:21:50,620
Cette étape clé a été plus tôt que vous avez
to-- lorsque vous modifiez votre code source,

442
00:21:50,620 --> 00:21:52,610
il se trouve aussi fonctionner
par l'intermédiaire du compilateur

443
00:21:52,610 --> 00:21:54,102
à nouveau de sorte que vous obtenez le nouveau code de la machine.

444
00:21:54,102 --> 00:21:55,810
Et le code de la machine,
les zéros et les uns,

445
00:21:55,810 --> 00:21:59,260
vont être à peu près identique, mais
pas parfaitement, parce que nous avons besoin,

446
00:21:59,260 --> 00:22:00,510
bien sûr, que la nouvelle ligne.

447
00:22:00,510 --> 00:22:05,640
>> Donc, pour résoudre ce problème, je vais avoir besoin
réexécuter clanghello.c, entrez, dot

448
00:22:05,640 --> 00:22:06,800
slash, a.out.

449
00:22:06,800 --> 00:22:11,402
Et maintenant, bonjour tout le monde est de retour
là où je pense qu'elle doit être.

450
00:22:11,402 --> 00:22:12,610
Donc, tout cela est bel et bon.

451
00:22:12,610 --> 00:22:16,150
Mais a.out est un nom assez stupide pour un
programme, même si elle se trouve être,

452
00:22:16,150 --> 00:22:19,530
pour des raisons historiques, la
default-- signifie sorties d'assemblage.

453
00:22:19,530 --> 00:22:23,780
>> Mais laissez-moi aller de l'avant ici
et cela différemment.

454
00:22:23,780 --> 00:22:27,760
Je veux que mon programme bonjour mondial
effectivement être appelé bonjour.

455
00:22:27,760 --> 00:22:31,320
Donc, si elle était une icône sur mon
bureau, il ne serait pas a.out.

456
00:22:31,320 --> 00:22:32,730
Il serait appelé bonjour.

457
00:22:32,730 --> 00:22:36,660
>> Donc, pour ce faire, il se trouve
que Clang, comme de nombreux programmes,

458
00:22:36,660 --> 00:22:40,980
soutient les arguments de ligne de commande,
ou des drapeaux, ou des commutateurs,

459
00:22:40,980 --> 00:22:42,600
qui influencent simplement son comportement.

460
00:22:42,600 --> 00:22:48,160
Plus précisément, Clang prend en charge un tiret o
drapeau, qui prend alors un second mot.

461
00:22:48,160 --> 00:22:51,190
Dans ce cas, je vais arbitrairement,
mais raisonnablement, appeler bonjour.

462
00:22:51,190 --> 00:22:53,710
Mais je pourrais appeler ça
Je veux, sauf a.out, qui

463
00:22:53,710 --> 00:22:55,390
serait plutôt d'ailleurs le point.

464
00:22:55,390 --> 00:22:58,640
>> Et puis il suffit de spécifier le nom
du fichier que je ne veux compiler.

465
00:22:58,640 --> 00:23:02,190
Alors maintenant, même si au début
de la commande, je dois encore Clang,

466
00:23:02,190 --> 00:23:04,410
à la fin de la commande
J'ai encore le nom du fichier,

467
00:23:04,410 --> 00:23:08,520
J'ai maintenant ces lignes de commande
arguments, ces drapeaux qui disent,

468
00:23:08,520 --> 00:23:14,180
oh, en passant, la sortie-o, un fichier
appelé bonjour, pas le a.out par défaut.

469
00:23:14,180 --> 00:23:16,810
>> Donc, si je frappe maintenant entrer, rien
semble s'être produit.

470
00:23:16,810 --> 00:23:20,900
Et pourtant, maintenant, je peux faire slash dot bonjour.

471
00:23:20,900 --> 00:23:22,089
Il est donc le même programme.

472
00:23:22,089 --> 00:23:24,380
Les zéros et les uns sont
identique à la fin de la journée.

473
00:23:24,380 --> 00:23:27,210
>> Mais ils sont en deux
différente a.out files--,

474
00:23:27,210 --> 00:23:29,490
qui est la première version
et juste bêtement nommé,

475
00:23:29,490 --> 00:23:33,250
et maintenant bonjour, qui est un bien
nom de plus convaincant pour un programme.

476
00:23:33,250 --> 00:23:36,195
Mais, honnêtement, je ne suis jamais
va se souvenir de ce nouveau,

477
00:23:36,195 --> 00:23:37,070
et encore et encore.

478
00:23:37,070 --> 00:23:39,411
Et, en fait, que nous écrivons
programmes plus complexes,

479
00:23:39,411 --> 00:23:41,160
les commandes que vous êtes
allez avoir à écrire

480
00:23:41,160 --> 00:23:43,920
vont devenir encore
plus compliqué encore.

481
00:23:43,920 --> 00:23:44,940
>> Et ne vous inquiétez pas.

482
00:23:44,940 --> 00:23:49,220
Il se trouve que les humains avant
nous avons réalisé eux aussi

483
00:23:49,220 --> 00:23:50,530
eu ce même problème.

484
00:23:50,530 --> 00:23:53,900
Ils ne bénéficient pas non plus avoir à
tapez assez longues, les commandes ésotériques,

485
00:23:53,900 --> 00:23:55,200
et encore moins en souvenir.

486
00:23:55,200 --> 00:23:59,070
Et les humains qui nous ont fait
d'autres programmes qui facilitent

487
00:23:59,070 --> 00:24:00,670
pour compiler votre logiciel.

488
00:24:00,670 --> 00:24:04,609
>> Et, en effet, un tel
programme est appelé Marque.

489
00:24:04,609 --> 00:24:06,150
Je vais donc aller de l'avant et de le faire.

490
00:24:06,150 --> 00:24:08,691
Je vais défaire tout ce que je
vient de le faire de la manière suivante.

491
00:24:08,691 --> 00:24:10,690
Permettez-moi de taper LS.

492
00:24:10,690 --> 00:24:13,980
Et vous remarquerez trois things--
a.out, et une étoile, bonjour

493
00:24:13,980 --> 00:24:15,810
et une étoile, et hello.c.

494
00:24:15,810 --> 00:24:17,730
Espérons que cela devrait
être un peu intuitive,

495
00:24:17,730 --> 00:24:21,220
dans la mesure où il y avait précédemment
rien dans cet espace de travail.

496
00:24:21,220 --> 00:24:24,240
Il n'y avait rien que je devais
créé jusqu'à ce que nous avons commencé la classe.

497
00:24:24,240 --> 00:24:25,840
>> Et je créé hello.c.

498
00:24:25,840 --> 00:24:27,544
Je puis compilé, et l'a appelé a.out.

499
00:24:27,544 --> 00:24:30,460
Et puis je compilé à nouveau légèrement
différemment et appelé bonjour.

500
00:24:30,460 --> 00:24:35,830
J'ai trois fichiers dans ce répertoire,
dans ce dossier appelé espace de travail.

501
00:24:35,830 --> 00:24:38,005
Maintenant, je peux voir cela aussi
si je zoome sur réellement.

502
00:24:38,005 --> 00:24:40,530
>> Si je zoome ici et
regarder cette main en haut à droite

503
00:24:40,530 --> 00:24:42,940
coin, comme promis la gauche
côté de votre écran

504
00:24:42,940 --> 00:24:45,990
va toujours vous montrer
ce qui est dans votre compte, ce qui est

505
00:24:45,990 --> 00:24:47,790
intérieur du CS50 IDE.

506
00:24:47,790 --> 00:24:49,680
Et il y a trois fichiers.

507
00:24:49,680 --> 00:24:52,070
>> Donc, je veux me débarrasser de a.out et bonjour.

508
00:24:52,070 --> 00:24:54,275
Et comme vous pouvez
imaginer intuitivement, vous

509
00:24:54,275 --> 00:24:56,400
pourrait trier du contrôle cliquez
ou un clic droit sur ce point.

510
00:24:56,400 --> 00:24:57,590
Et ce petit menu apparaît.

511
00:24:57,590 --> 00:25:00,170
Vous pouvez télécharger le fichier, exécutez
elle, prévisualiser, rafraîchir, renommer,

512
00:25:00,170 --> 00:25:00,700
ou de ce pas.

513
00:25:00,700 --> 00:25:03,260
>> Et je ne pouvais tout simplement supprimer,
et il irait.

514
00:25:03,260 --> 00:25:08,260
Mais nous allons faire les choses avec une commande
ligne pour le moment, de manière à mettre à l'aise

515
00:25:08,260 --> 00:25:10,010
avec cela, et faire ce qui suit.

516
00:25:10,010 --> 00:25:15,345
Je vais aller de l'avant et retirer
a.out en tapant littéralement rma.out.

517
00:25:15,345 --> 00:25:17,890
Il se trouve, la commande pour
la suppression ou la suppression de quelque chose,

518
00:25:17,890 --> 00:25:19,280
est pas retirer ou supprimer.

519
00:25:19,280 --> 00:25:24,260
>> Il est plus succinctement RM, juste pour sauver
vous quelques frappes, et appuyez sur Entrée.

520
00:25:24,260 --> 00:25:27,707
Maintenant, nous allons être un peu
supprimer énigmatiquement a.out fichier régulier.

521
00:25:27,707 --> 00:25:30,040
Je ne sais pas vraiment ce qu'est un
fichier irrégulière serait encore.

522
00:25:30,040 --> 00:25:31,660
Mais je ne veux l'enlever.

523
00:25:31,660 --> 00:25:33,150
>> Donc, je vais y entrer pour oui.

524
00:25:33,150 --> 00:25:34,940
Ou je pourrais taper sur, et appuyez sur Entrée.

525
00:25:34,940 --> 00:25:36,440
Et, encore une fois, rien ne semble se produire.

526
00:25:36,440 --> 00:25:38,840
Mais cela est, en général, une bonne chose.

527
00:25:38,840 --> 00:25:43,490
>> Si je tape LS cette fois,
Que dois-je voir?

528
00:25:43,490 --> 00:25:47,930
Espérons juste bonjour et hello.c.

529
00:25:47,930 --> 00:25:50,286
Maintenant, en passant, vous aurez
remarquer cette étoile, astérisque,

530
00:25:50,286 --> 00:25:51,660
qui est à la fin de mes programmes.

531
00:25:51,660 --> 00:25:53,201
Et ils sont également montrant en vert.

532
00:25:53,201 --> 00:25:56,970
C'est juste moyen de CS50 IDE
vous cluing dans le fait

533
00:25:56,970 --> 00:25:58,280
que ce n'est pas le code source.

534
00:25:58,280 --> 00:26:01,880
C'est un exécutable, un runnable
programme que vous pouvez réellement exécuter

535
00:26:01,880 --> 00:26:04,020
en faisant slash dot, puis son nom.

536
00:26:04,020 --> 00:26:08,860
>> Maintenant, laissez-moi aller de l'avant et de supprimer
cela, rm bonjour, Entrez, enlever régulièrement

537
00:26:08,860 --> 00:26:11,010
déposer bonjour, oui.

538
00:26:11,010 --> 00:26:14,180
Et maintenant, si je tape LS,
nous sommes de retour à hello.c.

539
00:26:14,180 --> 00:26:16,917
Essayez de ne pas supprimer votre
code source.

540
00:26:16,917 --> 00:26:19,250
Même si il y a des caractéristiques
intégré dans CS50 IDE où

541
00:26:19,250 --> 00:26:22,870
vous pouvez passer par votre historique de révision
et revenir en arrière dans le temps si vous avez accidentellement

542
00:26:22,870 --> 00:26:26,660
supprimer quelque chose, faire garder à l'esprit
selon ces invites oui ou non,

543
00:26:26,660 --> 00:26:28,381
de ce que vous voulez réellement faire.

544
00:26:28,381 --> 00:26:30,380
Et si je monte vers le haut
coin gauche de la main ici,

545
00:26:30,380 --> 00:26:33,696
tout ce qui reste est hello.c.

546
00:26:33,696 --> 00:26:35,570
Donc, il y a des grappes de
d'autres commandes que vous

547
00:26:35,570 --> 00:26:40,550
peut exécuter dans le monde de Linux,
dont l'un est, encore une fois, Make.

548
00:26:40,550 --> 00:26:43,180
Et nous allons faire
mon programme maintenant comme suit.

549
00:26:43,180 --> 00:26:46,270
>> Au lieu de faire clang,
au lieu de faire clang-o,

550
00:26:46,270 --> 00:26:48,860
Je vais tout simplement
taper littéralement, faire bonjour.

551
00:26:48,860 --> 00:26:52,630
Et maintenant remarqué, je suis
pas tapant make hello.c.

552
00:26:52,630 --> 00:26:53,910
Je tape faire bonjour.

553
00:26:53,910 --> 00:26:57,840
>> Et ce programme Faire que
est livré avec CS50 IDE, et plus

554
00:26:57,840 --> 00:27:00,090
généralement avec Linux,
est un programme qui est

555
00:27:00,090 --> 00:27:02,120
va faire un programme appelé Bonjour.

556
00:27:02,120 --> 00:27:06,680
Et il va supposer, par convention,
que si ce programme peut être faite,

557
00:27:06,680 --> 00:27:12,030
il va être fait à partir d'une source
fichier de code se terminant par c dot, hello.c.

558
00:27:12,030 --> 00:27:15,210
>> Donc, si je frappe Entrez maintenant, notez que
la commande qui est exécuté

559
00:27:15,210 --> 00:27:17,340
est en fait encore plus longtemps
avant qu'auparavant.

560
00:27:17,340 --> 00:27:19,670
Et c'est parce que nous avons
préconfiguré CS50 IDE pour avoir

561
00:27:19,670 --> 00:27:22,878
quelques fonctionnalités supplémentaires intégrées dans ce
on n'a pas besoin pour l'instant, mais bientôt.

562
00:27:22,878 --> 00:27:26,470
Mais l'élément clé pour réaliser
est maintenant j'ai un programme Bonjour.

563
00:27:26,470 --> 00:27:30,080
>> Si je tape à nouveau LS, je
avoir un programme de bonjour.

564
00:27:30,080 --> 00:27:35,070
Et je peux courir avec
dot slash a.out, non,

565
00:27:35,070 --> 00:27:38,590
parce que le point entier de cette
exercice était dot slash bonjour.

566
00:27:38,590 --> 00:27:41,089
Et maintenant je dois mon programme bonjour mondial.

567
00:27:41,089 --> 00:27:42,880
Donc, aller de l'avant,
nous sommes presque toujours juste

568
00:27:42,880 --> 00:27:45,088
va compiler nos programmes
en utilisant la commande Marque.

569
00:27:45,088 --> 00:27:48,300
Et puis nous allons les exécuter par
dot slash et le nom du programme.

570
00:27:48,300 --> 00:27:52,610
Mais réaliser ce que font est fait pour
vous, est-ce est pas lui-même un compilateur.

571
00:27:52,610 --> 00:27:56,310
Il est juste un programme de commodité
qui sait comment déclencher un compilateur

572
00:27:56,310 --> 00:27:59,470
pour exécuter de telle sorte que vous vous pouvez l'utiliser.

573
00:27:59,470 --> 00:28:03,220
>> Quelles autres commandes existent dans
Linux, et à son tour le CS50 IDE?

574
00:28:03,220 --> 00:28:06,107
Nous verrons bientôt qu'il ya un
commande CD, Changer de répertoire.

575
00:28:06,107 --> 00:28:08,190
Cela vous permet dans les
votre interface de ligne de commande

576
00:28:08,190 --> 00:28:10,610
pour aller de l'avant et en arrière,
et d'ouvrir des dossiers différents

577
00:28:10,610 --> 00:28:11,860
sans utiliser votre souris.

578
00:28:11,860 --> 00:28:15,470
>> LS nous avons vu, qui signifie la liste
les fichiers dans le répertoire en cours.

579
00:28:15,470 --> 00:28:17,650
Faire Dir, vous pouvez
probablement commencer à déduire

580
00:28:17,650 --> 00:28:21,150
ce que cela signifie maintenant-- créer le répertoire,
si vous voulez créer un dossier.

581
00:28:21,150 --> 00:28:24,270
RM pour supprimer, RM Dir
supprimer directory-- et ceux-ci,

582
00:28:24,270 --> 00:28:27,160
à nouveau, sont la ligne de commande
équivalents de ce que vous

583
00:28:27,160 --> 00:28:29,945
pourrait faire CS50 IDE avec votre souris.

584
00:28:29,945 --> 00:28:31,820
Mais vous trouverez bientôt
que parfois il est juste

585
00:28:31,820 --> 00:28:33,610
beaucoup plus rapide à faire
les choses avec un clavier,

586
00:28:33,610 --> 00:28:36,690
et, finalement, beaucoup plus puissant.

587
00:28:36,690 --> 00:28:39,440
>> Mais il est difficile de faire valoir que
tout ce que nous avons fait jusqu'à présent

588
00:28:39,440 --> 00:28:42,990
est tout ce que puissant, quand tout
nous disons est, bonjour monde.

589
00:28:42,990 --> 00:28:46,740
Et, en fait, je l'Hardcoded
mots bonjour monde dans mon programme.

590
00:28:46,740 --> 00:28:48,530
Il n'y a pas encore de dynamisme.

591
00:28:48,530 --> 00:28:52,320
Scratch est un ordre de grandeur
plus intéressante la semaine dernière.

592
00:28:52,320 --> 00:28:54,220
>> Et donc nous allons y arriver.

593
00:28:54,220 --> 00:28:58,310
Prenons un pas vers ce que par
mode de certaines de ces fonctions.

594
00:28:58,310 --> 00:29:02,470
Donc, non seulement C viennent avec printf,
et des grappes d'autres fonctions

595
00:29:02,470 --> 00:29:04,850
dont certains que nous allons voir
au fil du temps, il n'a pas

596
00:29:04,850 --> 00:29:08,760
faire tout ce qui facile dès la sortie
de la porte d'entrée dans l'obtention de l'utilisateur.

597
00:29:08,760 --> 00:29:11,140
>> En effet, une des lacunes
des langages comme C,

598
00:29:11,140 --> 00:29:13,140
et même Java et encore
d'autres, est que cela ne

599
00:29:13,140 --> 00:29:18,860
le rendre facile à obtenir juste des choses comme
entiers des utilisateurs, ou des chaînes, des mots,

600
00:29:18,860 --> 00:29:22,970
et les phrases, laisser les choses comme seul
valeurs à virgule flottante ou nombres réels

601
00:29:22,970 --> 00:29:26,240
avec des points décimaux, et vraiment
numéros longs, comme nous le verrons bientôt.

602
00:29:26,240 --> 00:29:30,000
Donc, cette liste de fonctions ici, ceux-ci
sont comme les autres pièces de puzzle Scratch

603
00:29:30,000 --> 00:29:34,090
que nous avons pré-installé dans CS50
IDE que nous allons utiliser pour quelques semaines

604
00:29:34,090 --> 00:29:37,010
comme des roues de formation de toutes sortes, et
éventuellement les enlever, et de regarder

605
00:29:37,010 --> 00:29:40,210
sous le capot, peut-être,
comment ces choses sont mises en œuvre.

606
00:29:40,210 --> 00:29:43,460
>> Mais pour ce faire, nous allons
en fait écrire un programme.

607
00:29:43,460 --> 00:29:44,770
Laissez-moi aller de l'avant maintenant.

608
00:29:44,770 --> 00:29:47,750
Et je vais créer un nouveau
déposer en cliquant sur ce petit plus,

609
00:29:47,750 --> 00:29:48,970
et en cliquant sur Nouveau fichier.

610
00:29:48,970 --> 00:29:52,250
>> Je vais enregistrer cette prochaine
un comme, disons, string.c,

611
00:29:52,250 --> 00:29:53,750
parce que je veux jouer avec des cordes.

612
00:29:53,750 --> 00:29:56,990
Et chaîne dans C est juste
une séquence de caractères.

613
00:29:56,990 --> 00:29:59,090
Alors maintenant, nous allons aller de l'avant
et procédez comme suit.

614
00:29:59,090 --> 00:30:04,204
>> Inclure la norme IO.h-- et
il se trouve la norme IO,

615
00:30:04,204 --> 00:30:06,360
IO signifie simplement entrée et de sortie.

616
00:30:06,360 --> 00:30:08,920
Ainsi, il apparaît que
cette ligne ici est ce que

617
00:30:08,920 --> 00:30:11,140
est le voisin de nous d'utiliser printf.

618
00:30:11,140 --> 00:30:13,410
Printf, bien entendu, produit de sortie.

619
00:30:13,410 --> 00:30:18,000
Ainsi, afin d'utiliser printf, il se
out, vous devez avoir cette ligne de code

620
00:30:18,000 --> 00:30:19,040
en haut de votre fichier.

621
00:30:19,040 --> 00:30:21,456
>> Et nous reviendrons sur ce
cela signifie vraiment avant longtemps.

622
00:30:21,456 --> 00:30:23,400
Il se trouve que, dans
tout programme de C je vous écris,

623
00:30:23,400 --> 00:30:26,640
Je dois commencer avec
code qui ressemble à ceci.

624
00:30:26,640 --> 00:30:29,860
Et vous remarquerez CS50 IDE et
autre développement intégré

625
00:30:29,860 --> 00:30:33,050
environnements comme elle,
vont essayer mieux

626
00:30:33,050 --> 00:30:34,780
ils peuvent terminer votre pensée.

627
00:30:34,780 --> 00:30:38,930
En fait, il y a un instant si j'Annuler
ce que je viens de faire, je frappe sur Entrée.

628
00:30:38,930 --> 00:30:42,160
>> Je me suis alors frappé bouclés ouverte
brace, appuyez sur Entrée à nouveau.

629
00:30:42,160 --> 00:30:43,430
Et il a fini ma pensée.

630
00:30:43,430 --> 00:30:48,140
Il m'a donné une nouvelle ligne, en retrait pas moins
pour de belles raisons stylistiques que nous allons voir.

631
00:30:48,140 --> 00:30:51,559
Et puis il m'a donné automatiquement
qui accolade pour terminer ma pensée.

632
00:30:51,559 --> 00:30:53,600
Or, il n'a pas toujours
devinez ce que vous voulez faire.

633
00:30:53,600 --> 00:30:56,620
Mais en grande partie, il ne
vous faire économiser quelques frappes.

634
00:30:56,620 --> 00:31:02,560
Donc, il y a un instant, nous avons couru cette program--
bonjour, monde, puis compilé,

635
00:31:02,560 --> 00:31:03,460
puis il a couru.

636
00:31:03,460 --> 00:31:04,867
Mais il n'y a pas de dynamisme ici.

637
00:31:04,867 --> 00:31:06,700
Que faire si nous voulions
faire quelque chose de différent?

638
00:31:06,700 --> 00:31:10,630
Eh bien, si je voulais réellement
obtenir une chaîne de l'utilisateur?

639
00:31:10,630 --> 00:31:14,250
Je vais utiliser un morceau de puzzle
appelé exactement that-- obtenir chaîne.

640
00:31:14,250 --> 00:31:18,860
>> Active en C que lorsque vous ne voulez pas
de contribuer à une pièce de puzzle,

641
00:31:18,860 --> 00:31:22,360
ou plus exactement à une fonction, vous
littéralement juste faire parenthèse ouverte,

642
00:31:22,360 --> 00:31:23,430
étroite entre parenthèses.

643
00:31:23,430 --> 00:31:28,540
Donc, il est comme si il y a
aucune boîte blanche à taper dans.

644
00:31:28,540 --> 00:31:30,720
Le bloc de dire avant
avait une petite boîte blanche.

645
00:31:30,720 --> 00:31:32,660
Nous ne disposons pas que la boîte blanche maintenant.

646
00:31:32,660 --> 00:31:36,310
>> Mais quand je l'appelle chaîne get, je
vouloir mettre le résultat quelque part.

647
00:31:36,310 --> 00:31:40,680
Donc, un paradigme très répandu dans C est de
appeler une fonction, comme la chaîne get ici,

648
00:31:40,680 --> 00:31:44,070
puis stocker sa valeur de retour.

649
00:31:44,070 --> 00:31:47,450
Il est le résultat de son
effort dans quelque chose.

650
00:31:47,450 --> 00:31:50,630
>> Et quelle est la
construire dans la programmation,

651
00:31:50,630 --> 00:31:56,450
que ce soit dans Scratch ou maintenant C, que nous
peut utiliser pour réellement stocker quelque chose?

652
00:31:56,450 --> 00:31:58,990
Appelé il une variable, à droite?

653
00:31:58,990 --> 00:32:03,320
Et dans Scratch, nous ne sommes pas vraiment
soin ce qui se passait dans les variables.

654
00:32:03,320 --> 00:32:05,170
>> Mais dans ce cas, nous faisons réellement.

655
00:32:05,170 --> 00:32:06,719
Je vais dire chaîne.

656
00:32:06,719 --> 00:32:08,510
Et puis je pourrais appeler
ce que je veux.

657
00:32:08,510 --> 00:32:11,340
Je vais l'appeler
nom, obtient obtenir chaîne.

658
00:32:11,340 --> 00:32:13,250
>> Et maintenant, même si vous êtes
un peu de nouveau à cela,

659
00:32:13,250 --> 00:32:14,984
remarque que je manque quelques détails.

660
00:32:14,984 --> 00:32:16,150
J'oublie un point-virgule.

661
00:32:16,150 --> 00:32:17,400
Je dois terminer cette pensée.

662
00:32:17,400 --> 00:32:20,480
Donc, je vais passer mon curseur,
et appuyez sur point-virgule là.

663
00:32:20,480 --> 00:32:22,130
Et qu'est-ce que je viens de faire?

664
00:32:22,130 --> 00:32:24,440
Dans cette ligne de code,
numéro 5 à l'heure actuelle,

665
00:32:24,440 --> 00:32:26,799
Je vous appelle chaîne get sans entrées.

666
00:32:26,799 --> 00:32:29,090
Donc, il n'y a pas peu de blanc
boîte comme le bloc Save a.

667
00:32:29,090 --> 00:32:31,590
>> Je dis simplement que, hé,
ordinateur, get me une chaîne.

668
00:32:31,590 --> 00:32:34,390
Le signe égal est pas vraiment
un signe égal, en soi.

669
00:32:34,390 --> 00:32:36,790
Il est l'affectation
opérateur, ce qui signifie,

670
00:32:36,790 --> 00:32:40,860
hey, ordinateur, déplacer la valeur
de la droite vers la gauche.

671
00:32:40,860 --> 00:32:43,480
Et dans la gauche, je dois le suivant.

672
00:32:43,480 --> 00:32:46,580
>> Hey, ordinateur, donne-moi un string--
une séquence de caractères.

673
00:32:46,580 --> 00:32:48,637
Et appeler cette chaîne Nom.

674
00:32:48,637 --> 00:32:50,220
Et je ne même pas l'appeler Nom.

675
00:32:50,220 --> 00:32:52,970
>> Je pourrais l'appeler, de façon classique,
quelque chose comme S,

676
00:32:52,970 --> 00:32:55,900
un peu comme nous l'habitude d'i
appeler la variable i.

677
00:32:55,900 --> 00:32:57,829
Mais maintenant, je dois faire quelque chose avec elle.

678
00:32:57,829 --> 00:33:00,370
Il serait assez stupide pour
essayez de compiler ce code, en cours d'exécution

679
00:33:00,370 --> 00:33:02,410
ce programme, même si
Je reçois une chaîne,

680
00:33:02,410 --> 00:33:04,580
car il est encore juste
va dire bonjour monde.

681
00:33:04,580 --> 00:33:09,140
>> Mais si je ne veux changer cela.

682
00:33:09,140 --> 00:33:10,940
Pourquoi dois-je faire ce pas?

683
00:33:10,940 --> 00:33:14,632
Pour cent s, comma s.

684
00:33:14,632 --> 00:33:16,090
Et cela est un peu cryptique encore.

685
00:33:16,090 --> 00:33:18,560
>> Alors permettez-moi de faire mes variables plus clair.

686
00:33:18,560 --> 00:33:20,510
Permettez-moi de nommer ce nom variable.

687
00:33:20,510 --> 00:33:23,230
Et nous allons voir si nous ne pouvons pas taquiner
à part ce qui se passe ici.

688
00:33:23,230 --> 00:33:25,770
>> Donc, sur la ligne de cinq, je reçois une chaîne.

689
00:33:25,770 --> 00:33:28,620
Et je stocker cette chaîne,
quel que soit l'utilisateur a tapé dans

690
00:33:28,620 --> 00:33:31,430
à son clavier,
dans une variable appelée Nom.

691
00:33:31,430 --> 00:33:33,590
Et il se trouve que
printf n'a pas seulement

692
00:33:33,590 --> 00:33:37,220
prendre un argument dans le double
citations, une entrée entre guillemets.

693
00:33:37,220 --> 00:33:42,100
>> Elle peut prendre deux ou trois, ou plus, par exemple
que la seconde, troisième ou quatrième,

694
00:33:42,100 --> 00:33:45,320
sont tous les noms de variables,
ou des valeurs spécifiquement,

695
00:33:45,320 --> 00:33:51,610
que vous souhaitez brancher,
dynamique, cette chaîne entre guillemets.

696
00:33:51,610 --> 00:33:55,110
En d'autres termes, ce qui
serait mal à cela?

697
00:33:55,110 --> 00:34:00,920
Si je viens de dire bonjour nom, backslash
n, a sauvé mon dossier, compilé mon code,

698
00:34:00,920 --> 00:34:04,660
et a couru cela, ce qui se passerait?

699
00:34:04,660 --> 00:34:08,139
>> Il va juste dire bonjour
nom, littéralement N-A-M-E,

700
00:34:08,139 --> 00:34:10,900
qui est une sorte de stupide parce que
il est pas différent de monde.

701
00:34:10,900 --> 00:34:13,400
Donc, quoi que ce soit entre guillemets est
ce qui littéralement est imprimé.

702
00:34:13,400 --> 00:34:15,520
Donc, si je veux avoir
un espace réservé là-bas,

703
00:34:15,520 --> 00:34:17,422
En fait, je dois utiliser
une syntaxe spéciale.

704
00:34:17,422 --> 00:34:20,380
Et il se trouve si vous lisez le
documentation de la fonction printf,

705
00:34:20,380 --> 00:34:24,320
il vous dira que
si vous utilisez pour cent s,

706
00:34:24,320 --> 00:34:26,920
vous pouvez substituer une valeur comme suit.

707
00:34:26,920 --> 00:34:30,190
>> Après une virgule après cela
guillemet double, il vous suffit

708
00:34:30,190 --> 00:34:32,179
écrire le nom de la
variable que vous voulez

709
00:34:32,179 --> 00:34:36,790
brancher dans ce format
code, ou spécificateur de format,

710
00:34:36,790 --> 00:34:38,469
pour cent s pour les chaînes.

711
00:34:38,469 --> 00:34:42,190
Et maintenant, si je l'ai sauvé mon dossier,
Je redescends à mon terminal.

712
00:34:42,190 --> 00:34:45,870
Et je tape Faire String,
parce que, encore une fois, le nom de cette

713
00:34:45,870 --> 00:34:48,510
fichier que j'ai choisi avant est string.c.

714
00:34:48,510 --> 00:34:51,510
>> Donc, je vais dire Faire chaîne, entrez.

715
00:34:51,510 --> 00:34:54,550
Oh mon Dieu, regardez tous
les erreurs que nous avons déjà fait.

716
00:34:54,550 --> 00:34:58,540
Et ce est-- quoi, ce qui est vraiment
comme un, sept programme de ligne de six?

717
00:34:58,540 --> 00:35:00,790
Donc, ceci est où il peut très
obtenir rapidement écrasante.

718
00:35:00,790 --> 00:35:03,890
>> Cette fenêtre de terminal a
maintenant juste régurgité

719
00:35:03,890 --> 00:35:06,230
un grand nombre de messages d'erreur.

720
00:35:06,230 --> 00:35:10,560
Certes, je n'ai pas plus d'erreur
messages que j'ai lignes de code.

721
00:35:10,560 --> 00:35:11,680
Alors, quoi de neuf?

722
00:35:11,680 --> 00:35:13,920
>> Eh bien, la meilleure stratégie
à faire quand vous

723
00:35:13,920 --> 00:35:16,710
ne rencontrent une écrasante
liste des erreurs comme ça,

724
00:35:16,710 --> 00:35:19,690
est revenir en arrière, recherchez la commande
vous venez de courir, qui dans mon cas

725
00:35:19,690 --> 00:35:21,020
est de faire la chaîne.

726
00:35:21,020 --> 00:35:24,630
Regardez ce make a fait, et que ce que
commande longue Clang, pas grand-chose là-bas.

727
00:35:24,630 --> 00:35:25,950
>> Mais le rouge est mauvais.

728
00:35:25,950 --> 00:35:27,750
Vert essaie d'être
douce et serviable.

729
00:35:27,750 --> 00:35:29,140
Mais il est encore mauvais, dans ce cas.

730
00:35:29,140 --> 00:35:30,510
Mais où est-il mauvais?

731
00:35:30,510 --> 00:35:34,450
>> String.c, ligne de cinq, cinq caractères.

732
00:35:34,450 --> 00:35:35,930
Donc, ceci est juste convention commune.

733
00:35:35,930 --> 00:35:39,060
Quelque chose signifie quelque chose du côlon
numéro de ligne et le nombre de caractères.

734
00:35:39,060 --> 00:35:44,080
Erreur, l'utilisation du noir
chaîne d'identification.

735
00:35:44,080 --> 00:35:45,900
Vouliez-vous dire standard?

736
00:35:45,900 --> 00:35:48,530
>> Donc, malheureusement, Clang
est d'essayer d'être utile.

737
00:35:48,530 --> 00:35:49,850
Mais il ne va pas, dans ce cas.

738
00:35:49,850 --> 00:35:52,350
Non, Clang, je ne voulais pas la norme IO.

739
00:35:52,350 --> 00:35:54,070
Je voulais dire que sur une seule ligne, oui.

740
00:35:54,070 --> 00:35:56,420
>> Mais la ligne de cinq ans est celui-là.

741
00:35:56,420 --> 00:36:00,040
Et ne Clang
comprendre S-T-R-I-N-G.

742
00:36:00,040 --> 00:36:04,490
Il est un identificateur non déclaré, un
mot, il a tout simplement jamais vu auparavant.

743
00:36:04,490 --> 00:36:08,730
Et c'est parce que C, la langue
nous écrivons le code dans ce moment,

744
00:36:08,730 --> 00:36:11,070
n'a pas variables appelées chaînes.

745
00:36:11,070 --> 00:36:14,380
>> Il ne fait pas, par défaut, le support
ce qu'on appelle une chaîne.

746
00:36:14,380 --> 00:36:19,750
C'est un morceau de la CS50
jargon, mais très classique.

747
00:36:19,750 --> 00:36:21,600
Mais je peux résoudre ce problème de la manière suivante.

748
00:36:21,600 --> 00:36:25,090
>> Si j'ajouter une ligne de code
au début de ce programme,

749
00:36:25,090 --> 00:36:30,890
inclure CS50.h, qui est un autre fichier
quelque part à l'intérieur du CS50 IDE, quelque part

750
00:36:30,890 --> 00:36:33,820
sur le disque dur, pour ainsi dire,
du système d'exploitation Ubuntu

751
00:36:33,820 --> 00:36:36,590
que je suis en cours d'exécution, que
est le fichier qui est

752
00:36:36,590 --> 00:36:41,740
va enseigner l'exploitation
système quelle chaîne est, juste

753
00:36:41,740 --> 00:36:44,930
comme io.h standard est le fichier
dans le système d'exploitation qui est

754
00:36:44,930 --> 00:36:47,430
va enseigner ce que printf est.

755
00:36:47,430 --> 00:36:49,810
>> En effet, nous aurions obtenu
un message très similaire

756
00:36:49,810 --> 00:36:53,600
si IO avait admis la norme
Io.h et a essayé d'utiliser printf.

757
00:36:53,600 --> 00:36:56,632
Je vais donc aller de l'avant et juste
Prenez le contrôle L pour effacer mon écran.

758
00:36:56,632 --> 00:36:59,340
Ou vous pouvez taper clair et il sera
décochez simplement la fenêtre du terminal.

759
00:36:59,340 --> 00:37:01,020
Mais vous pouvez toujours revenir en arrière dans le temps.

760
00:37:01,020 --> 00:37:04,100
>> Et je vais relancer Faire String.

761
00:37:04,100 --> 00:37:06,660
Traversez mes doigts cette fois, Entrée.

762
00:37:06,660 --> 00:37:08,380
Oh mon Dieu, il a travaillé.

763
00:37:08,380 --> 00:37:12,280
il me montre une longue commande cryptique
qui est ce qui fait généré par Clang,

764
00:37:12,280 --> 00:37:13,460
mais aucun message d'erreur.

765
00:37:13,460 --> 00:37:15,460
Donc réaliser, même si
vous pourriez obtenir complètement

766
00:37:15,460 --> 00:37:17,480
dépassés par la
nombre de messages d'erreur,

767
00:37:17,480 --> 00:37:20,540
ça pourrait être cette cascade ennuyeux
effet, où Clang ne comprend pas

768
00:37:20,540 --> 00:37:22,620
une chose, ce qui signifie alors
ne comprend pas le mot suivant,

769
00:37:22,620 --> 00:37:23,560
ou la ligne suivante.

770
00:37:23,560 --> 00:37:25,850
Et il étouffe tout simplement sur votre code.

771
00:37:25,850 --> 00:37:27,440
Mais la solution pourrait être simple.

772
00:37:27,440 --> 00:37:30,822
Et toujours se concentrer sur la
première ligne de sortie.

773
00:37:30,822 --> 00:37:32,530
Et si vous ne le faites pas
comprendre, il suffit de regarder

774
00:37:32,530 --> 00:37:35,480
pour les mots clés qui pourraient être
indices, et le numéro de ligne,

775
00:37:35,480 --> 00:37:37,650
et le personnage, où
cette erreur pourrait être.

776
00:37:37,650 --> 00:37:43,328
>> Maintenant, laissez-moi aller de l'avant et tapez
dot slash, string, entrez.

777
00:37:43,328 --> 00:37:47,340
Hm, il ne dit pas bonjour quoi que ce soit.

778
00:37:47,340 --> 00:37:49,210
Pourquoi?

779
00:37:49,210 --> 00:37:51,170
Eh bien, rappelons-le, où est-il en cours d'exécution?

780
00:37:51,170 --> 00:37:56,730
>> Il est probablement coincé au moment
dans une boucle, si vous voulez, en ligne six,

781
00:37:56,730 --> 00:37:59,950
parce Obtenez chaîne par la conception,
écrite par le personnel CS50,

782
00:37:59,950 --> 00:38:03,350
est littéralement destiné à rester assis
là à attendre, et attendre,

783
00:38:03,350 --> 00:38:04,850
et en attente d'une chaîne.

784
00:38:04,850 --> 00:38:06,792
Tout ce que nous entendons par chaîne est entrée humaine.

785
00:38:06,792 --> 00:38:07,500
Donc, vous savez quoi?

786
00:38:07,500 --> 00:38:08,166
Laissez-moi aller de l'avant.

787
00:38:08,166 --> 00:38:11,704
Et sur un coup de tête, laissez-moi
tapez mon nom, David, entrez.

788
00:38:11,704 --> 00:38:13,120
Maintenant, j'ai un programme plus dynamique.

789
00:38:13,120 --> 00:38:14,240
Il dit bonjour David.

790
00:38:14,240 --> 00:38:19,280
>> Si je vais de l'avant et lance ce nouveau,
laissez-moi essayer dire le nom Zamila, entrez.

791
00:38:19,280 --> 00:38:20,940
Et maintenant, nous avons un programme dynamique.

792
00:38:20,940 --> 00:38:22,380
Je ne l'ai pas codé en dur monde.

793
00:38:22,380 --> 00:38:24,760
Je ne l'ai pas codé en dur
nom, ou David ou Zamila.

794
00:38:24,760 --> 00:38:28,350
>> Maintenant, il est beaucoup plus comme les programmes
nous le savons, où si elle prend entrée,

795
00:38:28,350 --> 00:38:30,870
il produit une sortie légèrement différente.

796
00:38:30,870 --> 00:38:34,020
Or, ce ne sont pas les meilleurs
expérience utilisateur ou UX.

797
00:38:34,020 --> 00:38:36,000
Je lance le programme.

798
00:38:36,000 --> 00:38:38,830
>> Je ne sais pas ce que je suis censé
à faire, à moins que je regarde effectivement à

799
00:38:38,830 --> 00:38:40,290
ou de se rappeler le code source.

800
00:38:40,290 --> 00:38:42,640
Faisons donc l'utilisateur
l'expérience d'un peu mieux

801
00:38:42,640 --> 00:38:44,240
avec le plus simple des choses.

802
00:38:44,240 --> 00:38:47,782
Permettez-moi de revenir dans cette
programme, et simplement dire printf.

803
00:38:47,782 --> 00:38:51,870
>> Et laissez-moi aller de l'avant et de dire le nom, du côlon,
et un espace, puis un point-virgule.

804
00:38:51,870 --> 00:38:54,170
Et juste pour le plaisir, pas de jeu n.

805
00:38:54,170 --> 00:38:55,980
Et c'est délibéré,
parce que je ne veux pas

806
00:38:55,980 --> 00:38:57,590
l'invite à passer à la ligne suivante.

807
00:38:57,590 --> 00:39:01,800
>> Je veux, à la place, faire, faire chaîne
recompiler mon code en nouvelle machine

808
00:39:01,800 --> 00:39:03,980
Code dot slash chaîne.

809
00:39:03,980 --> 00:39:05,460
Ah, ce qui est beaucoup plus jolie.

810
00:39:05,460 --> 00:39:08,780
Maintenant, je sais réellement ce que l'ordinateur
veut que je fasse, lui donner un nom.

811
00:39:08,780 --> 00:39:13,020
>> Je vais donc aller de l'avant et tapez
à Rob, entrez, et bonjour, Rob.

812
00:39:13,020 --> 00:39:16,640
Donc, se rendre compte, cela est encore, à la fin
de la journée, seulement un programme neuf de ligne.

813
00:39:16,640 --> 00:39:18,090
Mais nous avons pris ces mesures de bébé.

814
00:39:18,090 --> 00:39:21,380
>> Nous avons écrit une ligne avec laquelle nous
étaient familiers, printf, bonjour monde.

815
00:39:21,380 --> 00:39:22,980
Ensuite, nous défaisions un peu de cela.

816
00:39:22,980 --> 00:39:24,560
Et nous avons utilisé la chaîne get.

817
00:39:24,560 --> 00:39:26,362
Et nous tournions cette valeur dans une variable.

818
00:39:26,362 --> 00:39:29,070
Et puis nous sommes allés de l'avant et amélioré
davantage avec une troisième ligne.

819
00:39:29,070 --> 00:39:32,220
Et ce processus itératif de
logiciel d'écriture est vraiment la clé.

820
00:39:32,220 --> 00:39:36,420
En CS50, et dans la vie en général,
vous devriez généralement pas asseoir,

821
00:39:36,420 --> 00:39:39,800
avoir un programme à l'esprit, et essayer l'écriture
toute fichue chose à la fois.

822
00:39:39,800 --> 00:39:43,810
>> Il sera, inévitablement, entraîner de manière
plus d'erreurs que nous nous avons vu ici.

823
00:39:43,810 --> 00:39:47,070
Même moi, à ce jour, en permanence
faire d'autres erreurs stupides,

824
00:39:47,070 --> 00:39:50,480
sont des erreurs effectivement plus difficile
qui sont plus difficiles à comprendre.

825
00:39:50,480 --> 00:39:55,095
Mais vous allez faire plus d'erreurs plus
lignes de code que vous écrivez tout à la fois.

826
00:39:55,095 --> 00:39:57,220
Et cette pratique,
écrire un petit morceau de code

827
00:39:57,220 --> 00:40:00,930
que vous êtes à l'aise avec, compilez
elle, exécuter, tester de façon plus générale,

828
00:40:00,930 --> 00:40:04,370
puis passer on-- donc tout comme nous avons gardé
marcottage et marcottage la semaine dernière,

829
00:40:04,370 --> 00:40:07,190
la construction de quelque chose de très
simple à quelque chose de plus complexe,

830
00:40:07,190 --> 00:40:08,200
faire la même chose ici.

831
00:40:08,200 --> 00:40:11,500
Ne vous asseyez pas, et essayer de
écrire tout un problème.

832
00:40:11,500 --> 00:40:13,780
En fait, prendre ces mesures de bébé.

833
00:40:13,780 --> 00:40:18,100
>> Maintenant, les chaînes ne sont pas tous
qui utiles à eux-mêmes.

834
00:40:18,100 --> 00:40:21,210
Nous avions en fait, idéalement, comme à
quelque chose d'autre dans notre boîte à outils.

835
00:40:21,210 --> 00:40:23,990
Donc, nous allons effectivement faire exactement cela.

836
00:40:23,990 --> 00:40:27,900
>> Laissez-moi aller de l'avant maintenant et fouetter
un programme légèrement différent.

837
00:40:27,900 --> 00:40:31,320
Et nous appelons cela int.c, pour entier.

838
00:40:31,320 --> 00:40:33,870
Je vais, de même,
inclure CS550.h.

839
00:40:33,870 --> 00:40:36,060
Je vais inclure la norme IO.

840
00:40:36,060 --> 00:40:39,630
Et cela va être assez commun
dans ces premiers jours de la classe.

841
00:40:39,630 --> 00:40:42,050
>> Et je vais prêt
moi-même avec une fonction principale.

842
00:40:42,050 --> 00:40:46,370
Et maintenant, au lieu d'obtenir une chaîne,
nous allons aller de l'avant et obtenir un int.

843
00:40:46,370 --> 00:40:52,285
Appelons-i, et appellent obtenir
int, proches parens, point-virgule.

844
00:40:52,285 --> 00:40:54,410
Et maintenant, nous allons faire
quelque chose avec elle, printf.

845
00:40:54,410 --> 00:40:59,190
>> Disons que quelque chose comme
bonjour, backslash n, i virgule.

846
00:40:59,190 --> 00:41:03,010
Donc, je suis à peu près imitant
ce que je faisais il y a un instant.

847
00:41:03,010 --> 00:41:04,660
J'ai un espace réservé ici.

848
00:41:04,660 --> 00:41:08,150
Je Comma i ici, parce que je veux
i brancher dans cette espace réservé.

849
00:41:08,150 --> 00:41:10,250
>> Donc, nous allons aller de l'avant et essayer
la compilation de ce programme.

850
00:41:10,250 --> 00:41:13,060
Le fichier est appelé int.c.

851
00:41:13,060 --> 00:41:15,920
Donc, je vais dire, faire int, entrez.

852
00:41:15,920 --> 00:41:19,420
Oh mon Dieu, mais pas grand-chose, non?

853
00:41:19,420 --> 00:41:20,230
Il y a une erreur.

854
00:41:20,230 --> 00:41:22,810
>> Il y a une erreur syntaxique
ici, tels que le programme ne peut pas

855
00:41:22,810 --> 00:41:28,460
être compilé intérieur int.c, ligne
sept ans, caractère 27, le format d'erreur

856
00:41:28,460 --> 00:41:31,400
spécifie type char
étoiles, quelle qu'elle soit.

857
00:41:31,400 --> 00:41:33,020
Mais le type d'argument est int.

858
00:41:33,020 --> 00:41:36,110
>> Donc, là aussi, on ne va pas to--
même si aujourd'hui est un lot de matériel,

859
00:41:36,110 --> 00:41:38,710
nous allons vous submerger avec
absolument toutes les fonctionnalités de C,

860
00:41:38,710 --> 00:41:41,070
et la programmation de façon plus générale,
en seulement ces quelques premières semaines.

861
00:41:41,070 --> 00:41:43,400
Donc, il y a souvent va être le jargon
avec lequel vous n'êtes pas familier.

862
00:41:43,400 --> 00:41:46,350
Et, en fait, char étoiles est quelque chose
nous allons revenir à

863
00:41:46,350 --> 00:41:47,830
dans une semaine ou le temps de deux.

864
00:41:47,830 --> 00:41:50,530
>> Mais pour l'instant, nous allons voir si nous pouvons
analyser les mots qui sont familiers.

865
00:41:50,530 --> 00:41:53,750
Formats-- donc nous avons entendu le format
spécificateur, le code de format avant.

866
00:41:53,750 --> 00:41:54,840
C'est familier.

867
00:41:54,840 --> 00:41:56,840
Bien-- mais l'argument est de type int.

868
00:41:56,840 --> 00:41:58,980
Attendez une minute, i est un int.

869
00:41:58,980 --> 00:42:02,230
>> Peut-être pour cent s en fait
a un sens défini.

870
00:42:02,230 --> 00:42:03,230
Et, en effet, il le fait.

871
00:42:03,230 --> 00:42:06,101
Un entier, si vous voulez
printf de lui substituer,

872
00:42:06,101 --> 00:42:08,350
vous avez réellement à utiliser un
différente spécificateur de format.

873
00:42:08,350 --> 00:42:09,890
Et vous ne seriez pas le savoir
à moins que quelqu'un vous a dit,

874
00:42:09,890 --> 00:42:10,973
ou si vous l'aviez fait auparavant.

875
00:42:10,973 --> 00:42:13,490
Mais pour cent i est ce que
peut être utilisée par

876
00:42:13,490 --> 00:42:15,240
dans printf pour brancher un entier.

877
00:42:15,240 --> 00:42:17,920
Vous pouvez également utiliser pour cent
d un entier décimal.

878
00:42:17,920 --> 00:42:19,490
Mais i est agréable et simple ici.

879
00:42:19,490 --> 00:42:20,590
Nous allons donc avec cela.

880
00:42:20,590 --> 00:42:24,160
>> Maintenant, laissez-moi aller de l'avant et
relancez make int, Entrée.

881
00:42:24,160 --> 00:42:26,328
C'est bon, pas d'erreurs.

882
00:42:26,328 --> 00:42:30,260
Dot slash OK int--, mauvaise expérience de l'utilisateur,
parce que je ne me suis pas dit

883
00:42:30,260 --> 00:42:30,760
Que faire.

884
00:42:30,760 --> 00:42:31,426
Mais ça va.

885
00:42:31,426 --> 00:42:32,480
J'attraper rapidement.

886
00:42:32,480 --> 00:42:39,260
>> Et maintenant, laissez-moi aller de l'avant et
tapez David, OK, Zamila, Rob.

887
00:42:39,260 --> 00:42:40,820
OK, donc ceci est une bonne chose.

888
00:42:40,820 --> 00:42:44,710
Cette fois, je suis en utilisant une fonction,
un morceau de puzzle, appelé get int.

889
00:42:44,710 --> 00:42:47,230
Et il se out-- et nous
voir plus tard dans le term--

890
00:42:47,230 --> 00:42:50,730
le personnel de CS50 a mis en œuvre
obtenir la chaîne de telle manière

891
00:42:50,730 --> 00:42:53,350
que ce sera seulement physiquement
obtenir une chaîne pour vous.

892
00:42:53,350 --> 00:42:57,340
>> Il a mis en œuvre get int dans
de telle sorte qu'il ne sera que

893
00:42:57,340 --> 00:42:58,590
obtenir un nombre entier pour vous.

894
00:42:58,590 --> 00:43:00,830
Et si vous, l'humain,
ne coopèrent pas, il est

895
00:43:00,830 --> 00:43:03,590
littéralement juste aller
dire relancez, relancez, relancez,

896
00:43:03,590 --> 00:43:08,200
littéralement assis là en boucle, jusqu'à ce que
vous obligez avec un certain nombre magique,

897
00:43:08,200 --> 00:43:10,670
comme 50, et bonjour 50.

898
00:43:10,670 --> 00:43:14,440
>> Ou si nous courons ce nouveau
et tapez 42, bonjour 42.

899
00:43:14,440 --> 00:43:18,750
Et donc la fonction get int
à l'intérieur de cette pièce de puzzle

900
00:43:18,750 --> 00:43:22,050
est assez logique, assez pensée,
de comprendre, ce qui est un mot?

901
00:43:22,050 --> 00:43:23,330
Et qu'est-ce qu'un nombre?

902
00:43:23,330 --> 00:43:26,165
accepter seulement, en fin de compte, numéros.

903
00:43:26,165 --> 00:43:28,690

904
00:43:28,690 --> 00:43:33,230
>> Donc, il se trouve que ce
est pas tout à fait expressif.

905
00:43:33,230 --> 00:43:33,910
jusque là.

906
00:43:33,910 --> 00:43:36,690
Donc, yay, nous la dernière fois
est allé assez rapidement

907
00:43:36,690 --> 00:43:41,320
dans les jeux de mise en œuvre et l'animation,
et des œuvres artistiques dans Scratch.

908
00:43:41,320 --> 00:43:45,260
Et ici, nous faisons preuve de contenu
avec Bonjour tout le monde, et bonjour 50.

909
00:43:45,260 --> 00:43:46,696
>> Il est pas tout à fait inspirant.

910
00:43:46,696 --> 00:43:49,070
Et, en effet, ces quelques premiers
exemples prendra un certain temps

911
00:43:49,070 --> 00:43:50,510
à la rampe dans l'excitation.

912
00:43:50,510 --> 00:43:52,854
Mais nous avons tellement plus
contrôler maintenant, en fait.

913
00:43:52,854 --> 00:43:54,770
Et nous allons très
commencer rapidement marcottage

914
00:43:54,770 --> 00:43:56,870
au-dessus de ces primitives de base.

915
00:43:56,870 --> 00:43:59,370
>> Mais d'abord, nous allons comprendre
quelles sont les limites.

916
00:43:59,370 --> 00:44:01,620
En fait, l'une des choses
Scratch ne facilement

917
00:44:01,620 --> 00:44:03,990
laissez-nous faire est vraiment regarder
sous le capot,

918
00:44:03,990 --> 00:44:06,740
et comprendre ce qu'est un
ordinateur est, ce qu'il peut faire,

919
00:44:06,740 --> 00:44:08,250
et quelles sont ses limites.

920
00:44:08,250 --> 00:44:11,580
Et, en effet, que le manque de
compréhension, potentiellement, à long terme

921
00:44:11,580 --> 00:44:15,520
peut conduire à notre propre écriture mistakes--
bogues, l'écriture des logiciels que l'insécurité

922
00:44:15,520 --> 00:44:16,880
est piraté en quelque sorte.

923
00:44:16,880 --> 00:44:20,130
>> Prenons donc quelques pas vers
comprendre cela un peu mieux par

924
00:44:20,130 --> 00:44:22,710
manière de, disons, l'exemple suivant.

925
00:44:22,710 --> 00:44:26,550
Je vais aller de l'avant et mettre en œuvre
réel rapide d'un programme appelé Adder.

926
00:44:26,550 --> 00:44:28,134
Comme, nous allons ajouter quelques chiffres ensemble.

927
00:44:28,134 --> 00:44:30,800
Et je vais coder certains coins
ici, et il suffit de copier et coller

928
00:44:30,800 --> 00:44:33,270
où je me trouvais avant, juste
afin que nous puissions aller plus vite.

929
00:44:33,270 --> 00:44:36,090
Alors maintenant, j'ai les débuts de base
d'un programme appelé Adder.

930
00:44:36,090 --> 00:44:37,670
>> Et nous allons aller de l'avant et à faire cela.

931
00:44:37,670 --> 00:44:41,680
Je vais aller de l'avant et
disons, INTX obtient obtenir int.

932
00:44:41,680 --> 00:44:42,430
Et tu sais quoi?

933
00:44:42,430 --> 00:44:43,990
Faisons une meilleure expérience utilisateur.

934
00:44:43,990 --> 00:44:48,740
>> Donc, disons simplement que x est, et efficacement
invite l'utilisateur à nous donner x.

935
00:44:48,740 --> 00:44:53,600
Et puis laissez-moi aller de l'avant et de dire, printf
que diriez-vous y est, cette fois-ci attend

936
00:44:53,600 --> 00:44:56,140
deux valeurs de l'utilisateur.

937
00:44:56,140 --> 00:45:02,759
Et puis nous allons simplement aller de l'avant et
disons, printf, la somme de x et y est.

938
00:45:02,759 --> 00:45:04,300
Et maintenant, je ne veux pas faire pour cent s.

939
00:45:04,300 --> 00:45:12,080
Je veux faire pour cent i, backslash
n, puis brancher valeur de somme.

940
00:45:12,080 --> 00:45:13,620
>> Alors, comment puis-je m'y prendre?

941
00:45:13,620 --> 00:45:14,270
Vous savez quoi?

942
00:45:14,270 --> 00:45:15,840
Je sais comment utiliser les variables.

943
00:45:15,840 --> 00:45:18,140
Permettez-moi de déclarer une nouvelle, int z.

944
00:45:18,140 --> 00:45:19,770
>> Et je vais faire une supposition ici.

945
00:45:19,770 --> 00:45:24,470
S'il y a des signes égaux dans ce
la langue, peut-être que je peux juste faire x plus y,

946
00:45:24,470 --> 00:45:26,660
tant que je termine mon
pensée avec un point-virgule?

947
00:45:26,660 --> 00:45:31,170
Maintenant, je peux revenir ici, branchez z,
terminer cette pensée avec un point-virgule.

948
00:45:31,170 --> 00:45:36,160
Et nous allons voir maintenant, si ceux-ci
séquences de lines-- x est obtenir int.

949
00:45:36,160 --> 00:45:37,770
Y est d'obtenir int.

950
00:45:37,770 --> 00:45:40,980
>> Ajouter x et y, stocker la valeur dans Z-
donc, encore une fois, rappelez-vous le signe égal

951
00:45:40,980 --> 00:45:41,560
est pas égale.

952
00:45:41,560 --> 00:45:44,100
Il est l'affectation de droite à gauche.

953
00:45:44,100 --> 00:45:48,180
Et nous allons imprimer que la somme
de x et y est pas littéralement z,

954
00:45:48,180 --> 00:45:49,830
mais ce qui est à l'intérieur de z.

955
00:45:49,830 --> 00:45:53,090
Faisons donc Adder -
nice, aucune erreur cette fois.

956
00:45:53,090 --> 00:45:56,030
Dot slash Adder, entrez,
x va être 1.

957
00:45:56,030 --> 00:45:58,380
>> Y va être 2.

958
00:45:58,380 --> 00:46:01,964
Et la somme de x et y est 3.

959
00:46:01,964 --> 00:46:03,130
Donc, c'est tout beau et bon.

960
00:46:03,130 --> 00:46:06,260
>> Donc, vous imaginez que les mathématiques
devraient travailler dans un tel programme.

961
00:46:06,260 --> 00:46:07,040
Mais tu sais quoi?

962
00:46:07,040 --> 00:46:09,904
Est-ce variable ligne
12, voire nécessaire?

963
00:46:09,904 --> 00:46:12,820
Vous ne devez pas prendre l'habitude
de simplement stocker des choses dans les variables

964
00:46:12,820 --> 00:46:13,980
juste parce que vous pouvez.

965
00:46:13,980 --> 00:46:16,550
Et, en fait, il est généralement
mauvaise conception réfléchie

966
00:46:16,550 --> 00:46:21,100
si vous créez une variable, appelée
z dans ce cas, le stockage en elle quelque chose,

967
00:46:21,100 --> 00:46:24,390
puis immédiatement
l'utiliser, mais jamais plus.

968
00:46:24,390 --> 00:46:27,700
Pourquoi donner quelque chose d'un nom
comme z si vous êtes littéralement

969
00:46:27,700 --> 00:46:29,770
va utiliser
chose qu'une seule fois, et ainsi

970
00:46:29,770 --> 00:46:32,380
proximale à l'endroit où vous avez créé
en premier lieu,

971
00:46:32,380 --> 00:46:34,052
si proche en termes de lignes de code?

972
00:46:34,052 --> 00:46:34,760
Donc, vous savez quoi?

973
00:46:34,760 --> 00:46:37,480
Il se trouve que C est assez flexible.

974
00:46:37,480 --> 00:46:39,586
Si je veux vraiment
plug-in ici les valeurs,

975
00:46:39,586 --> 00:46:41,210
Je ne ai pas besoin de déclarer une nouvelle variable.

976
00:46:41,210 --> 00:46:44,680
Je ne pouvais tout simplement plug-in x plus
y, parce que C comprend

977
00:46:44,680 --> 00:46:46,390
arithmétique et opérateurs mathématiques.

978
00:46:46,390 --> 00:46:50,140
>> Donc, je peux simplement dire, faire les mathématiques,
x plus y, quels que soient ces valeurs sont,

979
00:46:50,140 --> 00:46:53,780
branchez le résultat
entier dans cette chaîne.

980
00:46:53,780 --> 00:46:56,730
Donc, ce serait peut-être, bien que
une seule ligne plus courte,

981
00:46:56,730 --> 00:47:01,480
une meilleure conception, un meilleur programme,
parce qu'il ya moins de code, donc

982
00:47:01,480 --> 00:47:02,921
moins pour moi de comprendre.

983
00:47:02,921 --> 00:47:04,920
Et il est aussi tout simplement plus propre,
dans la mesure où nous ne sommes pas

984
00:47:04,920 --> 00:47:07,620
l'introduction de nouveaux mots,
de nouveaux symboles, comme z,

985
00:47:07,620 --> 00:47:10,510
même si elles ne sont pas vraiment
servira beaucoup d'un but.

986
00:47:10,510 --> 00:47:15,890
>> Malheureusement, les mathématiques ne sont pas
tout ce que parfois fiables.

987
00:47:15,890 --> 00:47:18,270
Allons de l'avant et faire cela.

988
00:47:18,270 --> 00:47:21,200
Je vais aller de l'avant
maintenant et faire ce qui suit.

989
00:47:21,200 --> 00:47:30,650
>> Faisons printf, pour cent i, plus pour cent
i, i serai pour cent, backslash n.

990
00:47:30,650 --> 00:47:35,240
Et je vais faire this-- xyx plus y.

991
00:47:35,240 --> 00:47:37,821
Donc, je vais juste réécrire
ce peu différemment ici.

992
00:47:37,821 --> 00:47:39,320
Permettez-moi de faire une vérification de la santé mentale rapide.

993
00:47:39,320 --> 00:47:40,986
Encore une fois, il ne faut pas prendre de l'avance de nous-mêmes.

994
00:47:40,986 --> 00:47:44,420
Faire additionneur, point barre oblique additionneur.

995
00:47:44,420 --> 00:47:47,950
x vaut 1, y vaut 2, 1 + 2 est égal à 3.

996
00:47:47,950 --> 00:47:48,870
Donc, ce qui est bon.

997
00:47:48,870 --> 00:47:52,060
Mais nous allons compliquer cela maintenant
un peu, et créer un nouveau fichier.

998
00:47:52,060 --> 00:47:56,350
>> Je vais appeler celui-ci,
dire, ints, pluriel pour les entiers.

999
00:47:56,350 --> 00:47:58,980
Permettez-moi de commencer où je me trouvais il y a un instant.

1000
00:47:58,980 --> 00:48:00,770
Mais maintenant, nous allons faire quelques autres lignes.

1001
00:48:00,770 --> 00:48:06,430
Laissez-moi aller de l'avant et de faire ce qui suit,
printf, pour cent i, moins pour cent i,

1002
00:48:06,430 --> 00:48:11,959
est pour cent i, virgule x, virgule yx moins y.

1003
00:48:11,959 --> 00:48:13,750
Je suis donc un peu faire
mathématiques différent là-bas.

1004
00:48:13,750 --> 00:48:14,624
Faisons un autre.

1005
00:48:14,624 --> 00:48:19,610
Donc, cent pour cent i fois
i est pour cent i, backslash n.

1006
00:48:19,610 --> 00:48:24,430
Voyons plug-in x et y, et x fois y.

1007
00:48:24,430 --> 00:48:27,530
Nous allons utiliser l'astérisque sur
votre ordinateur pour les temps.

1008
00:48:27,530 --> 00:48:29,390
>> Vous n'utilisez pas x. x est
un nom de variable ici.

1009
00:48:29,390 --> 00:48:31,270
Vous utilisez l'étoile pour la multiplication.

1010
00:48:31,270 --> 00:48:32,020
Faisons un de plus.

1011
00:48:32,020 --> 00:48:37,580
Printf pour cent I, divisée
en pour cent i, est pour cent i,

1012
00:48:37,580 --> 00:48:43,460
backslash n. xy divisé par Y-
de sorte que vous utilisez la barre oblique en C

1013
00:48:43,460 --> 00:48:44,502
de faire la division.

1014
00:48:44,502 --> 00:48:45,460
Et nous allons faire un autre.

1015
00:48:45,460 --> 00:48:50,920

1016
00:48:50,920 --> 00:48:58,240
Reste de pour cent i, divisé
en pour cent i, est pour cent i.

1017
00:48:58,240 --> 00:49:02,550
xy-- et maintenant reste
est ce qui reste.

1018
00:49:02,550 --> 00:49:05,980
Lorsque vous essayez diviser un
le dénominateur dans un numérateur,

1019
00:49:05,980 --> 00:49:08,570
combien il en reste plus que
vous ne pouviez pas diviser out?

1020
00:49:08,570 --> 00:49:10,910
>> Donc, il n'y a pas vraiment,
nécessairement, un symbole

1021
00:49:10,910 --> 00:49:12,470
nous avons utilisé à l'école primaire pour cela.

1022
00:49:12,470 --> 00:49:16,830
Mais il y en C. Vous pouvez
dire x modulo y, où

1023
00:49:16,830 --> 00:49:21,000
ce signe pour cent dans ce context--
prêter à confusion lorsque vous êtes à l'intérieur

1024
00:49:21,000 --> 00:49:23,170
des guillemets doubles,
intérieur de printf, pour cent

1025
00:49:23,170 --> 00:49:24,830
est utilisé comme indicateur de format.

1026
00:49:24,830 --> 00:49:28,420
>> Lorsque vous utilisez pour cent à l'extérieur de
que, dans une expression mathématique,

1027
00:49:28,420 --> 00:49:32,910
il est l'opérateur modulo modulaire
arithmetic-- pour nos besoins

1028
00:49:32,910 --> 00:49:36,650
ici, signifie simplement, quelle est la
reste de x divisée par y?

1029
00:49:36,650 --> 00:49:39,130
Si x est divisé par y x y slash.

1030
00:49:39,130 --> 00:49:41,220
Quel est le reste de x divisé par y?

1031
00:49:41,220 --> 00:49:44,780
Il est x y mod, en tant que programmeur dirait.

1032
00:49:44,780 --> 00:49:51,300
>> Donc, si je faisais pas d'erreur ici, laissez-moi
aller de l'avant et de faire ints, pluriel, gentil,

1033
00:49:51,300 --> 00:49:53,010
et dot ints slash.

1034
00:49:53,010 --> 00:49:58,270
Et allons-y et
faire, disons, 1, 10.

1035
00:49:58,270 --> 00:50:01,390
Tout droit, 1 plus 10 est 11, chèque.

1036
00:50:01,390 --> 00:50:04,240
1 moins 10 est négative 9, vérifier.

1037
00:50:04,240 --> 00:50:06,420
>> 1 fois 10 est 10, chèque.

1038
00:50:06,420 --> 00:50:10,090
1 divisé par 10 est--
OK, nous allons sauter celui-là.

1039
00:50:10,090 --> 00:50:12,480
Le reste de 1 divisé par 10 est égal à 1.

1040
00:50:12,480 --> 00:50:13,680
C'est correct.

1041
00:50:13,680 --> 00:50:15,630
Mais il y a un bug ici.

1042
00:50:15,630 --> 00:50:18,390
>> Donc, celui que je mets ma
remettre, pas correct.

1043
00:50:18,390 --> 00:50:19,670
Je veux dire, il est proche de 0.

1044
00:50:19,670 --> 00:50:23,670
1 divisé par 10, vous savez, si nous sommes
couper quelques coins, bien sûr, il est nul.

1045
00:50:23,670 --> 00:50:31,050
Mais il devrait vraiment être 1/10,
0,1 ou 0,10, 0,1000, ou ainsi de suite.

1046
00:50:31,050 --> 00:50:33,600
>> Il ne devrait pas vraiment être nul.

1047
00:50:33,600 --> 00:50:38,990
Eh bien, il se trouve que l'ordinateur est
faire littéralement ce que nous avons dit de faire.

1048
00:50:38,990 --> 00:50:42,460
Nous faisons des mathématiques comme x divisé par y.

1049
00:50:42,460 --> 00:50:47,680
Et x et y, par les lignes
du code précédent, sont des nombres entiers.

1050
00:50:47,680 --> 00:50:53,440
>> En outre, sur la ligne 15, nous sommes
dire printf, hé, printf plug-in

1051
00:50:53,440 --> 00:50:57,230
un nombre entier, plug-in un nombre entier,
plug-in un integer-- spécifiquement

1052
00:50:57,230 --> 00:51:00,580
x, puis y, puis x
divisé par y. x et y sont des entiers.

1053
00:51:00,580 --> 00:51:02,060
Nous sommes bien là.

1054
00:51:02,060 --> 00:51:04,250
>> Mais ce qui est x divisé par x?

1055
00:51:04,250 --> 00:51:09,790
x divisé par y devrait être,
mathématiquement, 1/10, ou 0,1,

1056
00:51:09,790 --> 00:51:14,600
qui est un nombre réel, un nombre réel
ayant, potentiellement, un point décimal.

1057
00:51:14,600 --> 00:51:16,230
Il est pas un entier.

1058
00:51:16,230 --> 00:51:21,290
>> Mais ce qui est le plus proche
entier à 10/01, ou 0,1?

1059
00:51:21,290 --> 00:51:24,114
Oui, ce genre de zéro.

1060
00:51:24,114 --> 00:51:25,030
0.1 est comme ça beaucoup.

1061
00:51:25,030 --> 00:51:25,890
Et 1 est autant.

1062
00:51:25,890 --> 00:51:28,870
Donc 1/10 est plus proche de
0 qu'il est à un.

1063
00:51:28,870 --> 00:51:33,800
>> Et donc ce que C est fait pour us--
sorte de parce que nous lui avons dit to--

1064
00:51:33,800 --> 00:51:35,600
est tronquant cet entier.

1065
00:51:35,600 --> 00:51:43,540
Il prend la valeur, qui est à nouveau
censé être quelque chose comme 0.1000,

1066
00:51:43,540 --> 00:51:44,800
0 et ainsi de suite.

1067
00:51:44,800 --> 00:51:48,320
Et il est tout tronquant
après la virgule

1068
00:51:48,320 --> 00:51:50,510
de sorte que tout cela
choses, parce qu'il ne

1069
00:51:50,510 --> 00:51:54,910
intégrer la notion d'un nombre entier, qui
est juste un nombre comme négatif 1, 0, 1,

1070
00:51:54,910 --> 00:51:58,830
de haut en bas, il jette tout
après le point parce que vous décimales

1071
00:51:58,830 --> 00:52:02,020
ne peut pas adapter à un point décimal
en un nombre entier par définition.

1072
00:52:02,020 --> 00:52:04,290
>> Donc, la réponse est ici zéro.

1073
00:52:04,290 --> 00:52:05,600
Alors, comment pouvons-nous résoudre ce problème?

1074
00:52:05,600 --> 00:52:07,400
Nous avons besoin d'une autre solution tous ensemble.

1075
00:52:07,400 --> 00:52:09,880
Et nous pouvons le faire, comme suit.

1076
00:52:09,880 --> 00:52:15,820
>> Laissez-moi aller de l'avant et de créer une nouvelle
fichier, celui-ci a appelé floats.c.

1077
00:52:15,820 --> 00:52:19,500
Et enregistrez-le ici dans le
même répertoire, float.c.

1078
00:52:19,500 --> 00:52:22,360

1079
00:52:22,360 --> 00:52:26,260
Et laissez-moi aller de l'avant et copier
une partie de ce code à partir plus tôt.

1080
00:52:26,260 --> 00:52:30,690
>> Mais au lieu d'obtenir
un int, faisons cela.

1081
00:52:30,690 --> 00:52:34,037
Donnez-moi une valeur à virgule flottante
appelé x. où un point flottant

1082
00:52:34,037 --> 00:52:36,370
la valeur est juste littéralement
quelque chose avec un point flottant.

1083
00:52:36,370 --> 00:52:37,410
Il peut se déplacer vers la gauche, vers la droite.

1084
00:52:37,410 --> 00:52:38,530
Il est un nombre réel.

1085
00:52:38,530 --> 00:52:41,050
>> Et laissez-moi appeler pas
obtenir int, mais obtenir flotteur,

1086
00:52:41,050 --> 00:52:44,420
qui a également été parmi le menu
des options de la bibliothèque C250.

1087
00:52:44,420 --> 00:52:46,220
Nous allons y changer à un flotteur.

1088
00:52:46,220 --> 00:52:48,000
Donc, cela devient obtenir flotteur.

1089
00:52:48,000 --> 00:52:50,620
>> Et maintenant, nous ne voulons pas brancher ints.

1090
00:52:50,620 --> 00:52:56,130
Il se trouve que nous devons utiliser pour cent
f pour float, pour cent f pour flotteur,

1091
00:52:56,130 --> 00:52:57,560
et maintenant il sauver.

1092
00:52:57,560 --> 00:53:04,220
Et maintenant, les doigts croisés, faire
flotteurs, gentil, flotteurs slash dot.

1093
00:53:04,220 --> 00:53:07,280
x va être un 1. y
Va être 10 à nouveau.

1094
00:53:07,280 --> 00:53:11,240
>> Et, bien, OK mon addition est correcte.

1095
00:53:11,240 --> 00:53:13,240
J'espérais plus,
mais j'oublié de l'écrire.

1096
00:53:13,240 --> 00:53:16,250
Allons donc et corriger cette erreur logique.

1097
00:53:16,250 --> 00:53:19,280
>> Allons de l'avant et de saisir ce qui suit.

1098
00:53:19,280 --> 00:53:21,080
Nous allons juste faire un petit copier-coller.

1099
00:53:21,080 --> 00:53:23,080
Et je vais dire moins.

1100
00:53:23,080 --> 00:53:24,890
>> Et je vais dire fois.

1101
00:53:24,890 --> 00:53:27,060
Et je vais dire divisée.

1102
00:53:27,060 --> 00:53:31,240
Et je ne vais pas faire modulo,
qui ne sont pas aussi germane ici,

1103
00:53:31,240 --> 00:53:36,690
divisé par f, et les temps plus--
OK, nous allons le faire à nouveau.

1104
00:53:36,690 --> 00:53:47,210
>> Faire des flotteurs, flotteurs slash dot,
et 1, 10, et-- agréable, non, OK.

1105
00:53:47,210 --> 00:53:48,250
Donc, je suis un idiot.

1106
00:53:48,250 --> 00:53:50,000
Donc, ce qui est très commun
en informatique

1107
00:53:50,000 --> 00:53:52,780
de faire des erreurs stupides comme ça.

1108
00:53:52,780 --> 00:53:56,100
>> Pour des fins pédagogiques,
ce que je voulais vraiment faire

1109
00:53:56,100 --> 00:54:00,410
a été changer science ici
pour atteindre plus, à moins, à l'époque,

1110
00:54:00,410 --> 00:54:04,140
et de diviser, comme vous nous l'espérons
remarqué au cours de cet exercice.

1111
00:54:04,140 --> 00:54:07,700
Alors maintenant, nous allons re-compiler cette
programme, faire des flotteurs slash dot.

1112
00:54:07,700 --> 00:54:10,950
>> Et pour la troisième fois, nous allons
voir si elle répond à mes attentes.

1113
00:54:10,950 --> 00:54:24,480
1, 10, entrez, oui, OK, 1.000,
divisé par 10,000, est 0,100000.

1114
00:54:24,480 --> 00:54:27,952
Et il se trouve que nous pouvons contrôler le nombre
chiffres sont après ces chiffres après la virgule.

1115
00:54:27,952 --> 00:54:28,660
En fait, nous le ferons.

1116
00:54:28,660 --> 00:54:29,790
Nous reviendrons à cela.

1117
00:54:29,790 --> 00:54:31,440
>> Mais maintenant, en fait, le calcul est correct.

1118
00:54:31,440 --> 00:54:33,090
Donc, encore une fois, quelle est la livraison ici?

1119
00:54:33,090 --> 00:54:36,050
Il se trouve que, dans C, il y a
non seulement juste strings-- et, en fait,

1120
00:54:36,050 --> 00:54:39,120
il n'y a pas vraiment, parce que nous
ajouter ceux avec la bibliothèque CS50.

1121
00:54:39,120 --> 00:54:40,710
Mais il n'y a pas seulement ints.

1122
00:54:40,710 --> 00:54:41,990
>> Il existe également des flotteurs.

1123
00:54:41,990 --> 00:54:45,810
Et il se trouve un tas d'autres données
types aussi, que nous allons utiliser avant longtemps.

1124
00:54:45,810 --> 00:54:49,270
Active si vous voulez un seul
caractère, pas une chaîne de caractères,

1125
00:54:49,270 --> 00:54:50,610
vous pouvez simplement utiliser un caractère.

1126
00:54:50,610 --> 00:54:55,350
>> Avère que si vous voulez un bool,
une valeur booléenne, vrai ou faux seulement,

1127
00:54:55,350 --> 00:54:59,840
grâce à la bibliothèque de CS50, nous avons
ajouté à C le type de données bool ainsi.

1128
00:54:59,840 --> 00:55:02,180
Mais il est présent aussi dans
beaucoup d'autres langues.

1129
00:55:02,180 --> 00:55:07,130
Et il se trouve que, parfois, vous
besoin de plus grands nombres puis viennent par défaut

1130
00:55:07,130 --> 00:55:08,210
avec ints et flotteurs.

1131
00:55:08,210 --> 00:55:13,590
>> Et, en fait, un double est un nombre
qui utilise non pas 32 bits, mais 64 bits.

1132
00:55:13,590 --> 00:55:17,990
Et un long est un nombre qui
utilise pas 32, les bits, mais 64 bits,

1133
00:55:17,990 --> 00:55:22,190
respectivement, pour virgule flottante
des valeurs et des nombres entiers, respectivement.

1134
00:55:22,190 --> 00:55:25,780
Donc, nous allons effectivement maintenant
voir en action.

1135
00:55:25,780 --> 00:55:29,150
>> Je vais aller de l'avant ici
et concocter un autre programme.

1136
00:55:29,150 --> 00:55:35,020
Ici, je vais aller de l'avant
et ne comprennent CS50.h.

1137
00:55:35,020 --> 00:55:37,910
Et laissez-moi aller, inclure la norme io.h.

1138
00:55:37,910 --> 00:55:40,320
>> Et vous remarquerez quelque chose
génial qui se passe ici.

1139
00:55:40,320 --> 00:55:43,592
Il est pas le codage couleur des choses dans
de la même manière comme avant.

1140
00:55:43,592 --> 00:55:46,550
Et il se trouve, c'est parce que je
ont pas donné la chose un nom de fichier.

1141
00:55:46,550 --> 00:55:50,270
>> Je vais appeler celui-ci
sizeof.c, et cliquez sur Enregistrer.

1142
00:55:50,270 --> 00:55:54,039
Et remarquez ce qui arrive à mon très
Code blanc sur cette toile de fond noir.

1143
00:55:54,039 --> 00:55:55,830
Maintenant, au moins, il y a
certains pourpre là-dedans.

1144
00:55:55,830 --> 00:55:57,490
Et il est la syntaxe en surbrillance.

1145
00:55:57,490 --> 00:56:00,700
>> C'est parce que, tout simplement, je l'ai
dit l'IDE quel type de fichier

1146
00:56:00,700 --> 00:56:04,060
il est en lui donnant un nom, et
spécifiquement une extension de fichier.

1147
00:56:04,060 --> 00:56:06,620
Maintenant, nous allons aller de l'avant et de faire cela.

1148
00:56:06,620 --> 00:56:11,910
Je vais aller de l'avant et très
il suffit d'imprimer le bool following--

1149
00:56:11,910 --> 00:56:14,080
est pour cent LU.

1150
00:56:14,080 --> 00:56:15,950
>> Nous y reviendrons
que, dans un instant.

1151
00:56:15,950 --> 00:56:18,840
Et puis je vais
taille d'impression de bool.

1152
00:56:18,840 --> 00:56:21,170
Et maintenant, juste pour sauver
moi un peu de temps, je suis

1153
00:56:21,170 --> 00:56:23,280
va faire ensemble
tas de cela à la fois.

1154
00:56:23,280 --> 00:56:27,620
Et, précisément, je vais
changer à un omble chevalier et l'omble.

1155
00:56:27,620 --> 00:56:30,760
Celui-ci, je vais changer
à un double et un double.

1156
00:56:30,760 --> 00:56:34,440
>> Celui-ci, je vais changer
à un flotteur et un flotteur.

1157
00:56:34,440 --> 00:56:38,670
Celui-ci, je vais
changer pour un int et un int.

1158
00:56:38,670 --> 00:56:41,660
Et celui-ci, je vais
pour passer à un long.

1159
00:56:41,660 --> 00:56:43,840
Et il est toujours prendre
depuis longtemps, bien longtemps.

1160
00:56:43,840 --> 00:56:47,572
>> Et puis, enfin, je donnai
moi-même un trop grand nombre, chaîne.

1161
00:56:47,572 --> 00:56:50,030
Il se trouve que dans C, il y a
l'opérateur spécial appelé

1162
00:56:50,030 --> 00:56:53,260
taille qui est littéralement
va, lorsqu'il est exécuté,

1163
00:56:53,260 --> 00:56:55,099
nous dire la taille de
chacune de ces variables.

1164
00:56:55,099 --> 00:56:56,890
Et cela est une façon, maintenant,
nous pouvons nous connecter de retour

1165
00:56:56,890 --> 00:57:00,140
à la discussion de la semaine dernière
des données et de la représentation.

1166
00:57:00,140 --> 00:57:03,330
>> Laissez-moi aller de l'avant et de compiler
la taille de la taille de slash dot de.

1167
00:57:03,330 --> 00:57:04,210
Et nous allons voir.

1168
00:57:04,210 --> 00:57:08,210
Il se trouve que, dans C,
spécifiquement sur CS50 IDE,

1169
00:57:08,210 --> 00:57:11,170
plus précisément sur la
système d'exploitation Ubuntu,

1170
00:57:11,170 --> 00:57:14,100
qui est une exploitation 64 bits
système dans ce cas,

1171
00:57:14,100 --> 00:57:17,189
un bool va
utiliser un octet d'espace.

1172
00:57:17,189 --> 00:57:19,480
Voilà comment la taille est mesurée,
pas en bits, mais en octets.

1173
00:57:19,480 --> 00:57:21,690
Et rappeler qu'un octet est de huit bits.

1174
00:57:21,690 --> 00:57:25,030
Ainsi, un bool, même si vous
techniquement seulement besoin d'un 0 ou 1,

1175
00:57:25,030 --> 00:57:27,092
il est un peu inutile
comment nous avons implémenté.

1176
00:57:27,092 --> 00:57:29,800
Il va réellement utiliser ensemble
byte-- donc tous les zéros, sont peut-être

1177
00:57:29,800 --> 00:57:34,050
tous ceux, ou quelque chose comme ça,
ou juste un 1 parmi les huit bits.

1178
00:57:34,050 --> 00:57:37,962
>> Un char, quant à lui, utilisé pour un caractère
comme un caractère Ascii par la semaine dernière,

1179
00:57:37,962 --> 00:57:39,170
va être un caractère.

1180
00:57:39,170 --> 00:57:45,340
Et ce synchs avec notre notion de
étant pas plus de 256 bits-- plutôt,

1181
00:57:45,340 --> 00:57:48,360
synchs avec elle étant pas
plus de 8 bits,

1182
00:57:48,360 --> 00:57:50,450
nous donne jusqu'à 256 valeurs.

1183
00:57:50,450 --> 00:57:52,680
Un double va
être de 8 octets ou 64 bits.

1184
00:57:52,680 --> 00:57:53,510
>> Un flotteur est 4.

1185
00:57:53,510 --> 00:57:54,690
Un int est 4.

1186
00:57:54,690 --> 00:57:55,980
Une longue, est longue 8.

1187
00:57:55,980 --> 00:57:57,716
Et une chaîne est 8.

1188
00:57:57,716 --> 00:57:58,840
Mais ne vous inquiétez pas à ce sujet.

1189
00:57:58,840 --> 00:58:00,340
Nous allons décoller cette couche.

1190
00:58:00,340 --> 00:58:02,940
Il se trouve, les chaînes peuvent
être supérieure à 8 octets.

1191
00:58:02,940 --> 00:58:05,310
>> Et, en effet, nous avons écrit
cordes déjà, bonjour monde,

1192
00:58:05,310 --> 00:58:06,700
plus de 8 octets.

1193
00:58:06,700 --> 00:58:09,270
Mais nous y reviendrons
que, dans un instant.

1194
00:58:09,270 --> 00:58:12,690
Mais la prise de distance ici est le suivant.

1195
00:58:12,690 --> 00:58:18,320
>> Tout ordinateur ne dispose que d'un fini
la quantité de mémoire et de l'espace.

1196
00:58:18,320 --> 00:58:20,860
Vous ne pouvez stocker autant de
fichiers sur votre Mac ou PC.

1197
00:58:20,860 --> 00:58:26,030
Vous ne pouvez stocker autant de programmes
RAM en cours d'exécution à la fois, nécessairement, même

1198
00:58:26,030 --> 00:58:29,360
avec de la mémoire virtuelle, parce
vous avez une quantité finie de RAM.

1199
00:58:29,360 --> 00:58:31,990
>> Et juste pour picture-- si
vous ne l'avez jamais ouvert un ordinateur portable

1200
00:58:31,990 --> 00:58:34,300
ou ordonné mémoire supplémentaire
pour un ordinateur, vous

1201
00:58:34,300 --> 00:58:36,670
pourrait ne pas savoir que
à l'intérieur de votre ordinateur

1202
00:58:36,670 --> 00:58:39,590
est quelque chose qui ressemble
un peu comme ça.

1203
00:58:39,590 --> 00:58:43,540
Donc, ceci est juste une société commune nommée
Crucial qui fait RAM pour les ordinateurs.

1204
00:58:43,540 --> 00:58:46,620
Et RAM est le cas des programmes
vivre pendant qu'ils courent.

1205
00:58:46,620 --> 00:58:49,630
>> Ainsi, sur chaque Mac ou PC, lorsque vous double
cliquez sur un programme, et il ouvre,

1206
00:58:49,630 --> 00:58:51,921
et il ouvre un certain document Word
ou quelque chose comme ça,

1207
00:58:51,921 --> 00:58:54,764
il stocke temporairement dans
RAM, parce que la RAM est plus rapide

1208
00:58:54,764 --> 00:58:56,680
que votre disque dur, ou
votre disque d'état solide.

1209
00:58:56,680 --> 00:58:59,600
Donc, il est juste là où les programmes vont
pour vivre quand ils sont en cours d'exécution,

1210
00:58:59,600 --> 00:59:01,060
ou lorsque les fichiers sont utilisés.

1211
00:59:01,060 --> 00:59:03,890
>> Donc, vous avez des choses qui ressemblent
comme celui-ci à l'intérieur de votre ordinateur portable,

1212
00:59:03,890 --> 00:59:06,320
ou légèrement plus grandes choses
à l'intérieur de votre bureau.

1213
00:59:06,320 --> 00:59:10,440
Mais la clé est que vous avez seulement
nombre fini de ces choses.

1214
00:59:10,440 --> 00:59:14,230
Et il y a seulement une quantité finie de
matériel assis sur ce bureau droit

1215
00:59:14,230 --> 00:59:14,730
ici.

1216
00:59:14,730 --> 00:59:18,920
>> Alors, sûrement, nous ne pouvons pas stocker
infiniment longs numéros.

1217
00:59:18,920 --> 00:59:22,030
Et pourtant, si vous pensez revenir à
école primaire, le nombre de chiffres peut

1218
00:59:22,030 --> 00:59:24,400
vous avez le droit
d'un point décimal?

1219
00:59:24,400 --> 00:59:27,680
Pour cette question, combien de chiffres peut
vous avez à la gauche d'un point décimal?

1220
00:59:27,680 --> 00:59:29,300
Vraiment, infiniment nombreux.

1221
00:59:29,300 --> 00:59:33,840
>> Maintenant, nous, les humains pourraient seulement
savoir comment prononcer millions,

1222
00:59:33,840 --> 00:59:37,990
et milliards, billions de dollars, et
quadrillions et quintillion.

1223
00:59:37,990 --> 00:59:42,370
Et je pousse les limites de mon
understanding-- ou my-- Je comprends

1224
00:59:42,370 --> 00:59:44,110
numéros, mais mon
Prononciation de nombres.

1225
00:59:44,110 --> 00:59:47,720
Mais ils peuvent obtenir infiniment grand avec
un nombre infini de chiffres à gauche

1226
00:59:47,720 --> 00:59:50,050
ou à droite d'un point décimal.

1227
00:59:50,050 --> 00:59:53,040
>> Mais les ordinateurs ont seulement
quantité finie de mémoire,

1228
00:59:53,040 --> 00:59:56,510
un nombre fini de transistors, un
nombre fini d'ampoules à l'intérieur.

1229
00:59:56,510 --> 01:00:00,350
Alors qu'est-ce qui se passe quand
vous manquez d'espace?

1230
01:00:00,350 --> 01:00:02,620
En d'autres termes, si vous
penser à la semaine dernière

1231
01:00:02,620 --> 01:00:06,160
lorsque nous avons parlé des numéros
étant eux-mêmes représentés en binaire,

1232
01:00:06,160 --> 01:00:08,480
supposons que nous avons
cette valeur de 8 bits ici.

1233
01:00:08,480 --> 01:00:11,290
>> Et nous avons sept de 1 et un 0.

1234
01:00:11,290 --> 01:00:13,827
Et supposons que nous voulons
à ajouter 1 à cette valeur.

1235
01:00:13,827 --> 01:00:15,410
Ceci est un très grand nombre en ce moment.

1236
01:00:15,410 --> 01:00:19,610
>> Ceci est 254, si je me souviens
le calcul de la semaine dernière à droite.

1237
01:00:19,610 --> 01:00:22,480
Mais si je change
que l'extrême droite 0 à 1?

1238
01:00:22,480 --> 01:00:25,800
Le nombre entier, de
Bien sûr, devient huit des 1.

1239
01:00:25,800 --> 01:00:27,050
Nous sommes donc toujours bon.

1240
01:00:27,050 --> 01:00:30,204
>> Et cela représente probablement
255, selon que le contexte

1241
01:00:30,204 --> 01:00:32,120
il pourrait en fait représenter
un nombre négatif.

1242
01:00:32,120 --> 01:00:34,240
Mais plus sur une autre fois.

1243
01:00:34,240 --> 01:00:37,220
Cela se sent comme il est à propos de
aussi haut que je peux compter.

1244
01:00:37,220 --> 01:00:38,290
>> Maintenant, il est seulement 8 bits.

1245
01:00:38,290 --> 01:00:41,170
Et mon Mac, sûrement, a ainsi
plus de 8 bits de mémoire.

1246
01:00:41,170 --> 01:00:42,170
Mais il n'a fini.

1247
01:00:42,170 --> 01:00:46,230
Ainsi, le même argument vaut, même si nous
avoir plus de celles-ci sur l'écran.

1248
01:00:46,230 --> 01:00:50,020
>> Mais ce qui se passe si vous êtes
stocker ce nombre, 255,

1249
01:00:50,020 --> 01:00:52,290
et vous voulez compter 1 peu plus élevé?

1250
01:00:52,290 --> 01:00:54,600
Vous voulez aller 255-256.

1251
01:00:54,600 --> 01:00:58,800
Le problème, bien sûr, est que si vous
commencer à compter à zéro comme la semaine dernière,

1252
01:00:58,800 --> 01:01:02,670
vous ne pouvez pas compter aussi élevé
comme 256, et encore moins 257,

1253
01:01:02,670 --> 01:01:05,584
et encore moins 258, m parce que
qui se passe lorsque vous ajoutez un 1?

1254
01:01:05,584 --> 01:01:08,000
Si vous faites l'ancienne école primaire
approche, vous mettez un 1 ici,

1255
01:01:08,000 --> 01:01:11,150
puis 1 plus 1 est 2, mais c'est
vraiment un zéro, vous portez le 1,

1256
01:01:11,150 --> 01:01:12,695
porter le 1, porter le 1.

1257
01:01:12,695 --> 01:01:15,620
Toutes ces choses,
ces 1 de, aller à zéro.

1258
01:01:15,620 --> 01:01:20,820
Et vous vous retrouvez, oui, comme quelqu'un
souligné, un 1 sur le côté gauche.

1259
01:01:20,820 --> 01:01:25,540
Mais tout ce que vous pouvez
en fait voir et tenir en mémoire

1260
01:01:25,540 --> 01:01:30,960
est seulement huit des 0, ce qui est à dire
à un moment donné si vous, un ordinateur,

1261
01:01:30,960 --> 01:01:35,490
essayé de compter assez haut, vous êtes
va enrouler autour, il semblerait,

1262
01:01:35,490 --> 01:01:38,850
à zéro, ou peut-être même négative
numéros, qui sont encore plus bas que zéro.

1263
01:01:38,850 --> 01:01:40,260
>> Et nous pouvons sorte de voir cela.

1264
01:01:40,260 --> 01:01:42,900
Laissez-moi aller de l'avant et d'écrire
un véritable programme rapide ici.

1265
01:01:42,900 --> 01:01:46,690
Laissez-moi aller de l'avant et d'écrire
un programme appelé débordement.

1266
01:01:46,690 --> 01:01:52,980
Inclure CS50.h, comprennent
norme IO.h-- oh,

1267
01:01:52,980 --> 01:01:54,730
J'ai vraiment raté ma coloration syntaxique.

1268
01:01:54,730 --> 01:01:57,440
Donc, nous allons l'enregistrer comme overflow.c.

1269
01:01:57,440 --> 01:02:00,084
>> Et void-- principale maintenant int
et avant longtemps, nous allons

1270
01:02:00,084 --> 01:02:02,500
revenir à expliquer pourquoi
nous continuons à écrire void main int.

1271
01:02:02,500 --> 01:02:05,080
Mais pour l'instant, nous allons faire tout
elle, en prenant pour acquis.

1272
01:02:05,080 --> 01:02:09,200
Allons me donner un int,
et l'initialiser à 0.

1273
01:02:09,200 --> 01:02:14,716
>> Nous allons ensuite faire pour int i obtenir zero--
en fait, nous allons faire une boucle infinie

1274
01:02:14,716 --> 01:02:15,590
et de voir ce qui se passe.

1275
01:02:15,590 --> 01:02:25,440
Bien vrai, alors nous allons imprimer n
est pour cent i, backslash n, plug-in n.

1276
01:02:25,440 --> 01:02:30,200
Mais, maintenant, nous allons faire n obtient n + 1.

1277
01:02:30,200 --> 01:02:32,660
>> En d'autres termes, à chaque
itération de cette boucle infinie,

1278
01:02:32,660 --> 01:02:35,550
Prenons la valeur de n,
et ajouter 1 à elle, puis

1279
01:02:35,550 --> 01:02:37,350
stocker le résultat de retour n sur la gauche.

1280
01:02:37,350 --> 01:02:40,150
Et, en fait, nous avons vu la syntaxe
légèrement comme cela, brièvement.

1281
01:02:40,150 --> 01:02:42,730
Une astuce est cool place
d'écrire tout ça,

1282
01:02:42,730 --> 01:02:45,770
vous pouvez réellement dire un n plus égal à 1.

1283
01:02:45,770 --> 01:02:50,480
>> Ou si vous voulez vraiment être de fantaisie,
vous pouvez dire n plus plus point-virgule.

1284
01:02:50,480 --> 01:02:53,130
Mais ces deux derniers sont juste
ce que nous appellerions le sucre syntaxique

1285
01:02:53,130 --> 01:02:53,790
pour la première chose.

1286
01:02:53,790 --> 01:02:56,456
>> La première chose est plus explicite,
tout à fait bien, tout à fait correct.

1287
01:02:56,456 --> 01:02:58,470
Mais ce qui est plus commun, je vais le dire.

1288
01:02:58,470 --> 01:03:00,210
Donc, nous allons faire cela pour un instant.

1289
01:03:00,210 --> 01:03:04,685
>> Nous allons maintenant faire trop-plein, qui sonne
plutôt inquiétant, débordement de slash dot.

1290
01:03:04,685 --> 01:03:07,380

1291
01:03:07,380 --> 01:03:12,852
Voyons voir, n commence à faire assez grand.

1292
01:03:12,852 --> 01:03:14,310
Mais nous allons réfléchir, la taille peut n obtenir?

1293
01:03:14,310 --> 01:03:15,870
>> n est un entier.

1294
01:03:15,870 --> 01:03:19,400
Nous avons vu il y a quelques instants avec la taille de
exemple qu'un int est de quatre octets.

1295
01:03:19,400 --> 01:03:25,070
Nous savons depuis la semaine dernière, quatre octets est
32 bits, parce que 8 fois 4, c'est 32.

1296
01:03:25,070 --> 01:03:26,460
Cela va être de 4 milliards de dollars.

1297
01:03:26,460 --> 01:03:28,802
>> Et nous sommes jusqu'à 800.000.

1298
01:03:28,802 --> 01:03:31,510
Cela va prendre une éternité pour
compter aussi haut que je le peux.

1299
01:03:31,510 --> 01:03:33,635
Je vais donc aller de l'avant,
comme vous pouvez avant longtemps,

1300
01:03:33,635 --> 01:03:37,910
et appuyez sur Commande C-- franchement, Contrôle
C, beaucoup, où le contrôle C généralement

1301
01:03:37,910 --> 01:03:39,034
des moyens d'annuler.

1302
01:03:39,034 --> 01:03:41,200
Malheureusement, parce que cette
est en cours d'exécution dans le nuage,

1303
01:03:41,200 --> 01:03:44,190
parfois le nuage est
cracher tellement de choses,

1304
01:03:44,190 --> 01:03:47,180
tellement sortie, ça va
prendre un peu de temps pour mon entrée

1305
01:03:47,180 --> 01:03:48,630
pour obtenir le nuage.

1306
01:03:48,630 --> 01:03:52,240
Donc, même si je frappe
Contrôle C il y a quelques secondes,

1307
01:03:52,240 --> 01:03:56,110
c'est certainement le côté
effet d'une boucle infinie.

1308
01:03:56,110 --> 01:03:59,070
>> Et dans ce cas, nous sommes
va laisser ce soit.

1309
01:03:59,070 --> 01:04:02,050
Et nous allons ajouter un autre
fenêtre de terminal ici

1310
01:04:02,050 --> 01:04:06,186
avec le plus, qui bien sûr ne
comme ça, car il est toujours penser.

1311
01:04:06,186 --> 01:04:08,310
Et nous allons aller de l'avant et être
un peu plus raisonnable.

1312
01:04:08,310 --> 01:04:10,768
>> Je vais aller de l'avant et de faire
ce qu'un nombre fini de fois.

1313
01:04:10,768 --> 01:04:13,047
Nous allons utiliser une boucle,
dont je parlais tout à l'heure.

1314
01:04:13,047 --> 01:04:13,630
Faisons cela.

1315
01:04:13,630 --> 01:04:16,430
Donnez-moi une autre variable int i obtient 0.

1316
01:04:16,430 --> 01:04:20,430
i est inférieur à, disons, 64 i ++.

1317
01:04:20,430 --> 01:04:27,010
Et maintenant, laissez-moi aller de l'avant et d'imprimer
out n est pour cent i, virgule n.

1318
01:04:27,010 --> 01:04:30,547
Et puis n-- cela est encore
va prendre une éternité.

1319
01:04:30,547 --> 01:04:31,130
Faisons cela.

1320
01:04:31,130 --> 01:04:33,620
>> n obtient n fois 2.

1321
01:04:33,620 --> 01:04:37,140
Ou nous pourrions être de fantaisie
et font parfois égale 2.

1322
01:04:37,140 --> 01:04:40,120
Mais disons simplement que n
lui-même égal à égal, 2 fois.

1323
01:04:40,120 --> 01:04:42,321
En d'autres termes, dans ce
la nouvelle version du programme,

1324
01:04:42,321 --> 01:04:44,820
Je ne veux pas attendre indéfiniment
à partir comme 800.000 à 4 milliards.

1325
01:04:44,820 --> 01:04:46,070
Finissons-en avec.

1326
01:04:46,070 --> 01:04:47,920
>> Disons en fait le double n à chaque fois.

1327
01:04:47,920 --> 01:04:50,660
Ce qui, le rappel, le doublement est le
en face d'avoir, bien sûr.

1328
01:04:50,660 --> 01:04:53,035
Et alors que la semaine dernière, nous avons
quelque chose de nouveau, et encore,

1329
01:04:53,035 --> 01:04:55,200
et encore une fois, super rapide,
doublement va sûrement

1330
01:04:55,200 --> 01:05:01,080
nous faire de 1 à la plus grande possible
valeur que nous pouvons compter pour int.

1331
01:05:01,080 --> 01:05:02,750
>> Donc, nous allons faire exactement cela.

1332
01:05:02,750 --> 01:05:04,720
Et nous reviendrons à cela avant longtemps.

1333
01:05:04,720 --> 01:05:07,180
Mais cela, encore une fois, est tout comme
le bloc de répétition dans Scratch.

1334
01:05:07,180 --> 01:05:08,600
Et vous utilisez cette avant longtemps.

1335
01:05:08,600 --> 01:05:13,170
>> Cela signifie simplement le nombre de zéro
jusqu'à, mais pas égale, à 64 ans.

1336
01:05:13,170 --> 01:05:17,285
Et à chaque itération de cet
boucle, gardez simplement incrémenter i.

1337
01:05:17,285 --> 01:05:21,990
Donc i ++ - et cette construction générale
sur la ligne 7 est juste un moyen super commun

1338
01:05:21,990 --> 01:05:25,290
de répéter quelques lignes de
code, un certain nombre de fois.

1339
01:05:25,290 --> 01:05:26,362
Quelles lignes de code?

1340
01:05:26,362 --> 01:05:28,570
Ces accolades, comme vous
peut-être glanées à partir de maintenant,

1341
01:05:28,570 --> 01:05:29,780
moyens, procédez comme suit.

1342
01:05:29,780 --> 01:05:32,510
>> Il est dans Scratch comme, quand
il a les blocs jaunes

1343
01:05:32,510 --> 01:05:35,680
et d'autres couleurs ce genre de
embrasser ou serrer les autres blocs.

1344
01:05:35,680 --> 01:05:37,750
Voilà ce que ces bouclés
accolades font ici.

1345
01:05:37,750 --> 01:05:43,200
Donc, si je suis ma syntaxe droite- vous
peut voir le symbole de la carotte en C des moyens

1346
01:05:43,200 --> 01:05:45,706
c'est combien de fois je suis
essayer de résoudre ce problème.

1347
01:05:45,706 --> 01:05:48,330
Donc, nous allons débarrasser de celui-là
tout à fait, et fermer cette fenêtre.

1348
01:05:48,330 --> 01:05:49,520
Et nous allons utiliser la nouvelle.

1349
01:05:49,520 --> 01:05:54,980
Faire débordement, slash dot
débordement, Entrez, tout droit,

1350
01:05:54,980 --> 01:05:56,090
il est mauvais au premier abord.

1351
01:05:56,090 --> 01:05:59,200
Mais nous allons revenir en arrière dans le temps,
parce que je l'ai fait 64 fois.

1352
01:05:59,200 --> 01:06:01,700
>> Et remarquez la première fois, n est 1.

1353
01:06:01,700 --> 01:06:06,110
Une deuxième fois, n est égal à 2,
puis 4, puis 8, puis 16.

1354
01:06:06,110 --> 01:06:12,450
Et il semble que, dès que
Je reçois à peu près 1 milliard,

1355
01:06:12,450 --> 01:06:15,800
si je double encore une fois, que
devrait me donner 2 milliards.

1356
01:06:15,800 --> 01:06:17,980
Mais il se trouve, il est
à droite sur le point.

1357
01:06:17,980 --> 01:06:21,930
>> Et il déborde effectivement
un int de 1 milliard

1358
01:06:21,930 --> 01:06:26,514
à peu près négatif 2
milliards, en raison d'un nombre entier,

1359
01:06:26,514 --> 01:06:28,430
à la différence du nombre nous
ont été en supposant que la semaine dernière,

1360
01:06:28,430 --> 01:06:31,397
peut être à la fois positif et négatif
dans la réalité et dans un ordinateur.

1361
01:06:31,397 --> 01:06:33,730
Et si au moins un de ces
bits est effectivement volés.

1362
01:06:33,730 --> 01:06:37,190
Donc, nous avons vraiment avons seulement 31 bits,
ou 2 milliards de valeurs possibles.

1363
01:06:37,190 --> 01:06:41,220
>> Mais pour l'instant, les plats à emporter est tout à fait
tout simplement, quelles que soient ces chiffres sont

1364
01:06:41,220 --> 01:06:45,280
et quel que soit le calcul est,
quelque chose de mauvais arrive à terme,

1365
01:06:45,280 --> 01:06:49,980
parce que finalement vous essayez de
permuter les bits une fois de trop.

1366
01:06:49,980 --> 01:06:54,060
Et vous allez effectivement de tous
de 1 à peut-être tous les 0, ou peut-être

1367
01:06:54,060 --> 01:06:57,260
juste un autre motif que ce
De toute évidence, selon le contexte,

1368
01:06:57,260 --> 01:06:59,342
peut être interprété comme un nombre négatif.

1369
01:06:59,342 --> 01:07:02,300
Et il semblerait que le plus élevé que je
peut compter dans ce programme particulier

1370
01:07:02,300 --> 01:07:04,210
est seulement environ 1 milliard.

1371
01:07:04,210 --> 01:07:05,760
Mais il y a une solution partielle ici.

1372
01:07:05,760 --> 01:07:06,480
Vous savez quoi?

1373
01:07:06,480 --> 01:07:10,600
>> Permettez-moi de changer d'un
int à un long long.

1374
01:07:10,600 --> 01:07:13,633
Et laissez-moi aller de l'avant ici
et say-- je vais avoir

1375
01:07:13,633 --> 01:07:15,290
de changer cela à un unsigned long.

1376
01:07:15,290 --> 01:07:19,860
Ou, voyons, je ne me souviens moi-même.

1377
01:07:19,860 --> 01:07:22,920
>> Allons de l'avant et de faire déborder.

1378
01:07:22,920 --> 01:07:24,860
Non, c'est pas, LLD, je vous remercie.

1379
01:07:24,860 --> 01:07:26,430
Alors parfois Clang peut être utile.

1380
01:07:26,430 --> 01:07:30,550
Je ne me souviens pas ce que le format
spécificateur était pendant une longue période.

1381
01:07:30,550 --> 01:07:31,950
>> Mais, en effet, Clang m'a dit.

1382
01:07:31,950 --> 01:07:34,570
Le vert est une sorte de bon,
signifie encore que vous avez fait une erreur.

1383
01:07:34,570 --> 01:07:36,190
Il est devine que je voulais dire LLD.

1384
01:07:36,190 --> 01:07:41,750
>> Alors laissez-moi prendre c'est des conseils, une longue
longue nombre décimal, sauf que.

1385
01:07:41,750 --> 01:07:46,190
Et permettez-moi de le relancer, dot
slash débordement, Entrée.

1386
01:07:46,190 --> 01:07:48,020
Et maintenant, ce qui est cool est la suivante.

1387
01:07:48,020 --> 01:07:52,140
>> Si je fais défiler dans le temps, nous commençons toujours
comptage au même place-- 1, 2, 4,

1388
01:07:52,140 --> 01:07:53,220
8, 16.

1389
01:07:53,220 --> 01:07:57,860
Remarquez, nous obtenons tous les
chemin jusqu'à 1 milliard.

1390
01:07:57,860 --> 01:08:00,070
Mais alors nous obtenons en toute sécurité à 2 milliards.

1391
01:08:00,070 --> 01:08:04,300
>> Puis nous arrivons à 4 milliards,
puis 8 milliards, 17 milliards.

1392
01:08:04,300 --> 01:08:06,340
Et nous allons plus haut, et
de plus en plus haut.

1393
01:08:06,340 --> 01:08:08,740
Finalement, cela, aussi, les pauses.

1394
01:08:08,740 --> 01:08:12,350
>> Finalement, avec un long temps,
qui est la valeur de 64 bits, non

1395
01:08:12,350 --> 01:08:16,660
une valeur 32 bits, si vous comptez
trop élevé, vous enveloppez autour de 0.

1396
01:08:16,660 --> 01:08:19,410
Et dans ce cas, nous nous trouvons
se retrouver avec un nombre négatif.

1397
01:08:19,410 --> 01:08:20,550
>> Donc, cela est un problème.

1398
01:08:20,550 --> 01:08:23,439
Et il se trouve que cette
problème est pas tout à fait mystérieux.

1399
01:08:23,439 --> 01:08:26,060
Même si je l'ai délibérément
induite avec ces erreurs,

1400
01:08:26,060 --> 01:08:29,149
il se trouve que nous le voyons genre de tous
autour de nous, ou du moins certains d'entre nous.

1401
01:08:29,149 --> 01:08:31,939
>> Donc, dans Lego Star Wars, si
vous avez déjà joué le jeu,

1402
01:08:31,939 --> 01:08:36,830
il se trouve que vous pouvez faire le tour
briser les choses dans LEGO monde,

1403
01:08:36,830 --> 01:08:39,640
et la collecte des pièces, essentiellement.

1404
01:08:39,640 --> 01:08:42,200
Et si vous avez déjà joué
ce jeu beaucoup trop de temps,

1405
01:08:42,200 --> 01:08:45,630
que cet individu sans nom
ici a fait, le nombre total

1406
01:08:45,630 --> 01:08:49,700
des pièces de monnaie que vous pouvez recueillir
est, il semblerait, 4 milliards.

1407
01:08:49,700 --> 01:08:51,240
>> Maintenant, avec il est effectivement arrondi.

1408
01:08:51,240 --> 01:08:53,239
Donc, LEGO a essayé de
garder les choses convivial.

1409
01:08:53,239 --> 01:08:56,779
Ils ne le font pas exactement 2 à
la puissance 32, par la semaine dernière.

1410
01:08:56,779 --> 01:08:58,310
Mais 4 milliards est une raison.

1411
01:08:58,310 --> 01:09:01,979
Il semble, sur la base de cette information,
que LEGO, et l'entreprise qui

1412
01:09:01,979 --> 01:09:05,624
fait de ce logiciel lui-même, a décidé
que le nombre maximal de pièces de monnaie

1413
01:09:05,624 --> 01:09:07,540
l'utilisateur peut accumuler
est, en effet, 4 milliards,

1414
01:09:07,540 --> 01:09:15,069
parce qu'ils ont choisi dans leur code
de ne pas utiliser un long, apparemment,

1415
01:09:15,069 --> 01:09:19,140
mais juste un nombre entier, un unsigned
nombre entier, seul un nombre entier positif, dont

1416
01:09:19,140 --> 01:09:21,089
valeur max est à peu près cela.

1417
01:09:21,089 --> 01:09:22,380
Eh bien, voici un autre drôle.

1418
01:09:22,380 --> 01:09:26,500
Ainsi, dans la civilisation de jeu, qui
certains d'entre vous connaissent peut-être, avec

1419
01:09:26,500 --> 01:09:29,660
il se trouve qu'il ya quelques années, il
avait un bug dans ce jeu dans lequel

1420
01:09:29,660 --> 01:09:31,750
si vous avez joué le rôle
de Gandhi dans le jeu,

1421
01:09:31,750 --> 01:09:37,020
au lieu de lui être très pacifiste,
la place était incroyablement, incroyablement

1422
01:09:37,020 --> 01:09:39,399
agressif, dans certaines circonstances.

1423
01:09:39,399 --> 01:09:43,529
En particulier, la façon dont la civilisation
œuvres est que si vous, le joueur,

1424
01:09:43,529 --> 01:09:47,680
adopter la démocratie, votre
Le score agressivité obtient

1425
01:09:47,680 --> 01:09:51,130
décrémenté par deux, donc moins
moins, puis minus.

1426
01:09:51,130 --> 01:09:53,569
>> Donc, vous soustrayez 2 de
votre itérer réelle.

1427
01:09:53,569 --> 01:09:59,650
Malheureusement, si votre itérer est
initialement 1, et vous soustraire 2 de celui-ci

1428
01:09:59,650 --> 01:10:02,050
après l'adoption de la démocratie
comme Gandhi ici pourrait

1429
01:10:02,050 --> 01:10:05,200
ont fait, parce qu'il était très passive--
1 sur l'échelle de l'agressivité.

1430
01:10:05,200 --> 01:10:07,830
Mais s'il adopte la démocratie, puis
il va de 1 à 1 négative.

1431
01:10:07,830 --> 01:10:14,470
>> Malheureusement, ils étaient
en utilisant des nombres non signés,

1432
01:10:14,470 --> 01:10:18,400
ce qui signifie qu'ils traitaient même négative
numéros comme si elles étaient positives.

1433
01:10:18,400 --> 01:10:22,780
Et il se trouve que la
équivalent positif de négatif 1,

1434
01:10:22,780 --> 01:10:26,480
dans des programmes informatiques typiques, est 255.

1435
01:10:26,480 --> 01:10:30,250
Donc, si Gandhi adopte
la démocratie a, et donc

1436
01:10:30,250 --> 01:10:35,470
son score d'agressivité a diminué,
il roule en fait autour de 255

1437
01:10:35,470 --> 01:10:38,470
et lui le plus fait
caractère agressif dans le jeu.

1438
01:10:38,470 --> 01:10:39,930
Donc, vous pouvez Google sur ce sujet.

1439
01:10:39,930 --> 01:10:42,380
Et ce fut, en effet, un
bug de programmation accidentelle,

1440
01:10:42,380 --> 01:10:46,010
mais ce n'est entré tout à fait
la tradition depuis.

1441
01:10:46,010 --> 01:10:47,360
>> C'est tout amusant et mignon.

1442
01:10:47,360 --> 01:10:50,760
Plus effrayant est quand même
dispositifs du monde réel, et non pas des jeux,

1443
01:10:50,760 --> 01:10:51,820
avoir ces mêmes insectes.

1444
01:10:51,820 --> 01:10:57,500
En fait, il y a un an un article est venu
à propos du Boeing 787 Dreamliner.

1445
01:10:57,500 --> 01:10:59,850
>> Et l'article au premier
coup d'oeil lit un peu mystérieux.

1446
01:10:59,850 --> 01:11:04,480
Mais il a dit cela, un logiciel
vulnérabilité dans Boeing

1447
01:11:04,480 --> 01:11:07,790
nouveau Dreamliner jet 787 a
le potentiel de causer des pilotes

1448
01:11:07,790 --> 01:11:10,220
perdre le contrôle de
l'aéronef, le cas échéant

1449
01:11:10,220 --> 01:11:14,750
à la mi-vol, les fonctionnaires de la FAA
compagnies aériennes a récemment averti.

1450
01:11:14,750 --> 01:11:17,520
Ce fut la détermination
qu'un modèle 787

1451
01:11:17,520 --> 01:11:22,770
avion qui a été alimenté
en continu pendant 248 jours

1452
01:11:22,770 --> 01:11:27,880
peut perdre tout courant alternatif, AC,
puissance électrique due au générateur

1453
01:11:27,880 --> 01:11:31,892
des unités de commande, CGU, simultanément
entrer dans le mode sans échec échec.

1454
01:11:31,892 --> 01:11:32,850
Il est une sorte de me perdre.

1455
01:11:32,850 --> 01:11:38,390
Mais le mémo a déclaré, OK, maintenant je suis que,
la condition est provoquée par un logiciel

1456
01:11:38,390 --> 01:11:41,590
Le compteur interne de
le contrôle du générateur

1457
01:11:41,590 --> 01:11:47,860
unités qui débordera après
248 jours de puissance continue.

1458
01:11:47,860 --> 01:11:50,070
Nous publions cette
remarquer pour prévenir la perte

1459
01:11:50,070 --> 01:11:52,300
Tout courant alternatif électrique
puissance, ce qui pourrait entraîner

1460
01:11:52,300 --> 01:11:53,980
la perte de contrôle de l'avion.

1461
01:11:53,980 --> 01:11:58,380
>> Donc, littéralement, il y a un certain nombre entier,
ou un certain type de données équivalent,

1462
01:11:58,380 --> 01:12:00,960
utilisé dans les logiciels
dans un avion réel

1463
01:12:00,960 --> 01:12:03,756
que si vous gardez votre avion
assez longtemps, qui, apparemment,

1464
01:12:03,756 --> 01:12:06,880
peut être le cas si vous êtes juste en cours d'exécution
les débrancher constamment et jamais

1465
01:12:06,880 --> 01:12:09,810
votre avion, il semble, ou
laissant ses batteries meurent,

1466
01:12:09,810 --> 01:12:12,840
finira par compter, et jusqu'à,
et, et, et, et vers le haut.

1467
01:12:12,840 --> 01:12:15,150
>> Et, par nature, un
quantité finie de mémoire

1468
01:12:15,150 --> 01:12:18,880
débordera, le retour à
zéro ou une valeur négative,

1469
01:12:18,880 --> 01:12:22,920
un effet secondaire qui est le
effroyablement réalité réelle

1470
01:12:22,920 --> 01:12:26,970
que le plan pourrait avoir besoin
être redémarré, efficacement,

1471
01:12:26,970 --> 01:12:30,290
ou pourrait tomber, pire, comme il vole.

1472
01:12:30,290 --> 01:12:32,230
Donc, ce genre de questions
sont toujours avec nous,

1473
01:12:32,230 --> 01:12:36,130
even-- ce fut un article 2015,
d'autant plus effrayant

1474
01:12:36,130 --> 01:12:39,100
quand vous faites pas nécessairement
comprendre, apprécier, ou d'anticiper

1475
01:12:39,100 --> 01:12:41,640
ces types d'erreurs.

1476
01:12:41,640 --> 01:12:45,030
>> Donc, il se trouve qu'il ya un autre
mauvaise chose à propos de la représentation des données.

1477
01:12:45,030 --> 01:12:50,080
Il se trouve que même les flotteurs sont
genre de défauts, parce que les flotteurs, aussi,

1478
01:12:50,080 --> 01:12:54,440
Je proposai de 32 bits, ou
peut-être 64 si vous utilisez un double.

1479
01:12:54,440 --> 01:12:56,070
Mais c'est encore finie.

1480
01:12:56,070 --> 01:13:00,070
>> Et le problème est que si vous le pouvez
mettre un nombre infini de nombres

1481
01:13:00,070 --> 01:13:02,460
après la virgule décimale,
il n'y a aucun moyen que vous

1482
01:13:02,460 --> 01:13:05,690
peut représenter tout le possible
chiffres qui nous ont appris

1483
01:13:05,690 --> 01:13:07,990
dans le grade école peut exister dans le monde.

1484
01:13:07,990 --> 01:13:11,870
Un ordinateur, en substance, doit
choisir un sous-ensemble de ces chiffres

1485
01:13:11,870 --> 01:13:13,200
pour représenter avec précision.

1486
01:13:13,200 --> 01:13:15,450
>> Maintenant, l'ordinateur peut
rond peut-être un peu,

1487
01:13:15,450 --> 01:13:20,900
et peut vous permettre d'environ magasin
tout numéro que vous pourriez probablement vouloir.

1488
01:13:20,900 --> 01:13:23,940
Mais intuitivement, si vous
un nombre fini de bits,

1489
01:13:23,940 --> 01:13:27,560
vous ne pouvez les permuter
à bien des égards finis.

1490
01:13:27,560 --> 01:13:29,570
Donc, vous ne pouvez pas peut-être
utiliser un nombre fini

1491
01:13:29,570 --> 01:13:32,880
de permutation de bits,
motifs de zéros et de uns,

1492
01:13:32,880 --> 01:13:35,940
pour représenter un infini
nombre de numéros,

1493
01:13:35,940 --> 01:13:40,370
ce qui suggère que les ordinateurs pourraient
très bien être de nous mentir parfois.

1494
01:13:40,370 --> 01:13:41,770
>> En fait, nous allons le faire.

1495
01:13:41,770 --> 01:13:44,239
Permettez-moi de revenir en CS50 IDE.

1496
01:13:44,239 --> 01:13:46,030
Laissez-moi aller de l'avant et
créer un petit programme

1497
01:13:46,030 --> 01:13:50,940
appelé Imprécision, pour montrer que
les ordinateurs sont, en effet, imprécis.

1498
01:13:50,940 --> 01:13:54,910
>> Et laissez-moi aller de l'avant et commencer par
une partie de ce code à partir d'avant,

1499
01:13:54,910 --> 01:13:56,830
et maintenant il suffit de faire ce qui suit.

1500
01:13:56,830 --> 01:14:06,640
Laissez-moi aller de l'avant et faire printf, pour cent
f, backslash n, 1 divisé par 10.

1501
01:14:06,640 --> 01:14:10,430
En d'autres termes, nous allons plonger plus profondément
à 1/10, comme 1 et divisé par 10.

1502
01:14:10,430 --> 01:14:12,760
Certes, un ordinateur peut représenter 1/10.

1503
01:14:12,760 --> 01:14:16,620
>> Donc, nous allons aller de l'avant et de faire l'imprécision.

1504
01:14:16,620 --> 01:14:17,390
Voyons voir.

1505
01:14:17,390 --> 01:14:19,210
Format spécifie le type double.

1506
01:14:19,210 --> 01:14:21,160
Mais l'argument est de type int.

1507
01:14:21,160 --> 01:14:22,040
Qu'est-ce qui se passe?

1508
01:14:22,040 --> 01:14:24,970
>> Oh, intéressant, il est donc un
leçon de devant.

1509
01:14:24,970 --> 01:14:29,050
Je veux dire, hé, salon de l'informatique
moi un flotteur avec pour cent f.

1510
01:14:29,050 --> 01:14:31,200
Mais je lui donne 2 ints.

1511
01:14:31,200 --> 01:14:34,120
Donc, il se trouve, je peux fixer
cela dans un couple des manières.

1512
01:14:34,120 --> 01:14:41,430
>> Je ne pouvais tout simplement tourner un dans 1.0, et
10 dans 10,0, ce qui serait, en effet,

1513
01:14:41,430 --> 01:14:45,390
ont pour effet de convertir
les en floats-- encore, espérons

1514
01:14:45,390 --> 01:14:46,180
le même numéro.

1515
01:14:46,180 --> 01:14:48,880
Ou il se trouve qu'il ya quelque chose
nous verrons à nouveau avant longtemps.

1516
01:14:48,880 --> 01:14:50,170
Vous pourriez lancer les numéros.

1517
01:14:50,170 --> 01:14:52,880
>> Vous pouvez, en utilisant cette parenthèse
expression, vous pouvez dire,

1518
01:14:52,880 --> 01:14:55,560
hey, ordinateur, prendre cette
10, que je connais est un int.

1519
01:14:55,560 --> 01:14:57,660
Mais le traiter, s'il vous plaît,
comme si elle est un flotteur.

1520
01:14:57,660 --> 01:14:59,680
Mais cela se sent inutilement complexe.

1521
01:14:59,680 --> 01:15:02,040
>> Pour nos besoins d'aujourd'hui,
disons simplement littéralement

1522
01:15:02,040 --> 01:15:05,700
rendent les valeurs à virgule flottante
avec un point décimal, comme celui-ci.

1523
01:15:05,700 --> 01:15:10,060
Laissez-moi aller de l'avant et relancez, fais
imprécision, bon, slash dot

1524
01:15:10,060 --> 01:15:11,870
imprécision, entrez.

1525
01:15:11,870 --> 01:15:13,990
OK, nous sommes à la recherche bonne.

1526
01:15:13,990 --> 01:15:21,194
>> 1 divisé par 10, selon mon
Mac ici, est, en effet, 0,100000.

1527
01:15:21,194 --> 01:15:24,360
Maintenant, on m'a enseigné à l'école primaire, il
devrait être un nombre infini de 0 de.

1528
01:15:24,360 --> 01:15:26,151
Donc, nous allons au moins essayer
de voir certains de ceux-ci.

1529
01:15:26,151 --> 01:15:29,770
Il se trouve que printf est un peu
encore plus sophistiqué que nous utilisons.

1530
01:15:29,770 --> 01:15:33,890
Il se trouve que vous ne devez pas spécifier
juste pour cent f, ou tout simplement pour cent i.

1531
01:15:33,890 --> 01:15:36,830
Vous pouvez réellement spécifier
certaines options de contrôle ici.

1532
01:15:36,830 --> 01:15:39,470
>> Plus précisément, je vais
à-dire, hé, printf,

1533
01:15:39,470 --> 01:15:42,660
me montrer en fait 10 points décimaux.

1534
01:15:42,660 --> 01:15:43,820
Donc, il semble un peu bizarre.

1535
01:15:43,820 --> 01:15:45,845
Mais vous dites pour cent,
point, combien de numéros

1536
01:15:45,845 --> 01:15:47,970
Voulez-vous voir après la
point décimal, puis f

1537
01:15:47,970 --> 01:15:51,340
pour plat, juste parce que ce
ce que dit la documentation.

1538
01:15:51,340 --> 01:15:53,080
Laissez-moi aller de l'avant et sauver ça.

1539
01:15:53,080 --> 01:15:55,460
>> Et remarque aussi, je suis en train de
fatigué de retaper les choses.

1540
01:15:55,460 --> 01:15:58,900
Donc, je suis juste mise en place et la
flèche vers le bas sur mes clés ici.

1541
01:15:58,900 --> 01:16:01,710
Et si je continue à frapper, vous
peut voir toutes les commandes

1542
01:16:01,710 --> 01:16:04,090
que je fait, ou mal fait.

1543
01:16:04,090 --> 01:16:07,630
>> Et je vais aller de l'avant dès maintenant et
pas vraiment l'utiliser, apparemment.

1544
01:16:07,630 --> 01:16:14,416
Faire imprécision, dot
slash imprecision-- donc

1545
01:16:14,416 --> 01:16:16,290
ce qu'on m'a appris à
l'école primaire vérifie.

1546
01:16:16,290 --> 01:16:22,010
Même si je l'imprime à 10 décimales
le place, en effet, est 0,10000.

1547
01:16:22,010 --> 01:16:22,840
Mais tu sais quoi?

1548
01:16:22,840 --> 01:16:24,150
>> Allons un peu gourmand.

1549
01:16:24,150 --> 01:16:26,990
Disons que, comme, montrez-moi 55
points après la virgule.

1550
01:16:26,990 --> 01:16:29,160
Nous allons vraiment prendre cette
programmer pour une rotation.

1551
01:16:29,160 --> 01:16:34,170
Permettez-moi de le refaire avec make
imprécision, slash dot, l'imprécision.

1552
01:16:34,170 --> 01:16:35,390
>> Et c'est reparti.

1553
01:16:35,390 --> 01:16:37,420
Votre enfance a été un mensonge.

1554
01:16:37,420 --> 01:16:51,410
Apparemment, 1 divisé par 10 est en effet
0.100000000000000005551115123--

1555
01:16:51,410 --> 01:16:52,740
>> Que se passe-t-il?

1556
01:16:52,740 --> 01:16:56,360
Eh bien, il se trouve, si vous genre de
regarder assez loin dans le sous-jacent

1557
01:16:56,360 --> 01:16:58,950
représentation de cette
nombre, il fait

1558
01:16:58,950 --> 01:17:03,400
est pas exactement 1/10, ou 0,1 et
un nombre infini de zéros.

1559
01:17:03,400 --> 01:17:04,630
Maintenant, pourquoi est-ce?

1560
01:17:04,630 --> 01:17:09,250
>> Eh bien, même si cela est un simple
numéro pour nous les humains, 1 divisé par 10,

1561
01:17:09,250 --> 01:17:13,910
il est toujours l'un des nombreux infiniment
numéros que nous pourrions imaginer.

1562
01:17:13,910 --> 01:17:17,490
Mais un ordinateur ne peut représenter
un nombre fini de nombres ainsi.

1563
01:17:17,490 --> 01:17:21,710
Et donc, effectivement, ce que le
ordinateur montre nous est son plus proche

1564
01:17:21,710 --> 01:17:25,940
approximation du nombre
nous voulons croire est 1/10,

1565
01:17:25,940 --> 01:17:30,760
ou vraiment ad infinitum 0,10000.

1566
01:17:30,760 --> 01:17:33,425
>> Au contraire, cependant, ceci est
aussi proche qu'il peut obtenir.

1567
01:17:33,425 --> 01:17:35,300
Et, en effet, si vous regardez
sous le capot,

1568
01:17:35,300 --> 01:17:40,050
que nous sommes ici en regardant
55 chiffres après la virgule,

1569
01:17:40,050 --> 01:17:42,990
on voit en fait que la réalité.

1570
01:17:42,990 --> 01:17:45,610
Maintenant, en passant, si vous avez
jamais vu le movie--

1571
01:17:45,610 --> 01:17:48,780
la plupart d'entre vous avez probablement haven't--
mais il y a Superman 3 quelques années,

1572
01:17:48,780 --> 01:17:52,500
Richard Pryor essentiellement exploité cette
la réalité dans son entreprise pour voler beaucoup

1573
01:17:52,500 --> 01:17:56,500
des fractions et des fractions de centimes,
parce que le company-- je me souviens bien,

1574
01:17:56,500 --> 01:18:00,210
il a été un while-- était essentiellement
jeter tout ce qui ne correspondait pas

1575
01:18:00,210 --> 01:18:01,790
dans la notion de cents.

1576
01:18:01,790 --> 01:18:04,480
>> Mais si vous ajoutez tous ces
minuscules, minuscules, chiffres minuscules encore,

1577
01:18:04,480 --> 01:18:07,960
et encore, et encore, vous pouvez, comme dans
son cas, faire un bon montant d'argent.

1578
01:18:07,960 --> 01:18:11,010
>> Cette même idée a été arraché par
une plus récente, mais encore maintenant plus âgés

1579
01:18:11,010 --> 01:18:13,500
film, appelé Office Space,
où les gars dans ce film,

1580
01:18:13,500 --> 01:18:16,501
fait la même chose, vissé vers le haut
complètement fini avec beaucoup trop

1581
01:18:16,501 --> 01:18:17,666
l'argent dans leur compte bancaire.

1582
01:18:17,666 --> 01:18:18,800
Tout cela était très suspect.

1583
01:18:18,800 --> 01:18:22,290
Mais à la fin de la journée,
imprécision est tout autour de nous.

1584
01:18:22,290 --> 01:18:25,240
>> Et cela, aussi, peut être
effroyablement le cas.

1585
01:18:25,240 --> 01:18:28,590
Il se trouve que Superman 3
et l'espace de bureau à part, il

1586
01:18:28,590 --> 01:18:31,460
peut être une très réelle
ramifications mondiales

1587
01:18:31,460 --> 01:18:35,290
des réalités imprécises
représentation des données

1588
01:18:35,290 --> 01:18:37,770
que même nous, les humains à
ce jour-là ne le font pas nécessairement

1589
01:18:37,770 --> 01:18:41,230
comprendre aussi bien que nous le devrions,
ou de se rappeler aussi souvent que nous le devrions.

1590
01:18:41,230 --> 01:18:45,950
Et, en effet, le clip suivant est
à partir d'un regard sur un monde très réel

1591
01:18:45,950 --> 01:18:50,730
ramifications de ce qui se passe si vous
ne pas apprécier l'imprécision

1592
01:18:50,730 --> 01:18:53,065
peut se produire dans la représentation des nombres.

1593
01:18:53,065 --> 01:18:54,300
>> [LECTURE VIDÉO]

1594
01:18:54,300 --> 01:18:58,620
>> -Ordinateurs, Nous avons tous appris à accepter
les problèmes souvent frustrant que

1595
01:18:58,620 --> 01:19:03,310
aller avec eux-- insectes, virus,
et des pépins logiciels,

1596
01:19:03,310 --> 01:19:06,130
pour les petits prix à payer
pour la commodité.

1597
01:19:06,130 --> 01:19:10,800
Mais dans la haute technologie et à haute vitesse
applications programme spatial militaire et,

1598
01:19:10,800 --> 01:19:15,800
le plus petit problème peut
être agrandie en cas de catastrophe.

1599
01:19:15,800 --> 01:19:21,900
>> Le 4 Juin 1996, les scientifiques préparés
de lancer une fusée Ariane 5 sans pilote.

1600
01:19:21,900 --> 01:19:24,220
Il transportait scientifique
satellites conçus

1601
01:19:24,220 --> 01:19:27,600
d'établir avec précision comment le
interagit champ magnétique terrestre

1602
01:19:27,600 --> 01:19:30,410
avec des vents solaires.

1603
01:19:30,410 --> 01:19:33,800
La fusée a été construit pour
l'Agence spatiale européenne,

1604
01:19:33,800 --> 01:19:37,370
et a décollé de son installation
sur la côte de la Guyane française.

1605
01:19:37,370 --> 01:19:40,540
>> -Au Environ 37 secondes dans
le vol, ils ont d'abord

1606
01:19:40,540 --> 01:19:42,270
quelque chose remarqué allait mal.

1607
01:19:42,270 --> 01:19:45,250
Les buses sont orientables dans
une façon qu'ils ne devraient pas vraiment.

1608
01:19:45,250 --> 01:19:49,580
Environ 40 secondes de vol,
clairement, le véhicule était en difficulté.

1609
01:19:49,580 --> 01:19:51,850
>> Et c'est quand ils ont fait
une décision de la détruire.

1610
01:19:51,850 --> 01:19:55,780
L'agent de sécurité de gamme, avec
d'énormes tripes, appuyé sur le bouton,

1611
01:19:55,780 --> 01:20:01,150
fait exploser la fusée, avant qu'il ne pourrait
devenir un danger pour la sécurité publique.

1612
01:20:01,150 --> 01:20:04,060
>> -Ce Était la jeune fille
voyage d'Ariane 5.

1613
01:20:04,060 --> 01:20:06,960
Et sa destruction a
placer en raison d'un défaut

1614
01:20:06,960 --> 01:20:08,822
intégré dans le logiciel de la fusée.

1615
01:20:08,822 --> 01:20:11,280
-Le Problème sur le lanceur Ariane était
qu'il y avait un nombre qui

1616
01:20:11,280 --> 01:20:13,600
64 bits requis pour exprimer.

1617
01:20:13,600 --> 01:20:16,590
Et ils ont voulu convertir
à un certain nombre de 16 bits.

1618
01:20:16,590 --> 01:20:18,610
Ils ont supposé que le
nombre n'a jamais été va

1619
01:20:18,610 --> 01:20:23,980
être très grand, que la plupart de ceux
chiffres dans un nombre de 64 bits sont des zéros.

1620
01:20:23,980 --> 01:20:25,440
Ils avaient tord.

1621
01:20:25,440 --> 01:20:28,060
>> -la Une incapacité
Programme logiciel pour accepter

1622
01:20:28,060 --> 01:20:32,510
le genre de numéro généré par
un autre était à l'origine de l'échec.

1623
01:20:32,510 --> 01:20:37,350
Le développement de logiciels était devenu un
partie très coûteuse de la nouvelle technologie.

1624
01:20:37,350 --> 01:20:41,140
La fusée Ariane a été très
couronnée de succès, tant du logiciel

1625
01:20:41,140 --> 01:20:44,550
créé pour elle était aussi
utilisé dans l'Ariane 5.

1626
01:20:44,550 --> 01:20:50,940
>> -Le Problème de base est que le lanceur Ariane
5 était plus rapide, accéléré plus rapidement.

1627
01:20:50,940 --> 01:20:54,450
Et le logiciel avait pas
comptabilisés pour cela.

1628
01:20:54,450 --> 01:20:58,060
>> -La Destruction de la fusée
a été un énorme désastre financier,

1629
01:20:58,060 --> 01:21:01,790
dû à une erreur logicielle minutes.

1630
01:21:01,790 --> 01:21:04,210
Mais ce ne fut pas le premier
temps des problèmes de conversion de données

1631
01:21:04,210 --> 01:21:07,820
avait en proie à la technologie des fusées modernes.

1632
01:21:07,820 --> 01:21:11,050
>> -En 1991, avec le début
de la première guerre du Golfe,

1633
01:21:11,050 --> 01:21:13,570
le Patriot missiles
connu le même genre

1634
01:21:13,570 --> 01:21:15,800
du problème de conversion de nombre.

1635
01:21:15,800 --> 01:21:19,090
Et en conséquence, 28 personnes,
28 soldats américains,

1636
01:21:19,090 --> 01:21:22,080
ont été tués et environ
100 autres blessés,

1637
01:21:22,080 --> 01:21:25,780
lorsque le Patriot, qui était censé
pour protéger contre les gammares entrants,

1638
01:21:25,780 --> 01:21:28,830
pas tirer un missile.

1639
01:21:28,830 --> 01:21:34,670
>> -Lorsque L'Irak a envahi le Koweït, et en Amérique
lancé Desert Storm au début de 1991,

1640
01:21:34,670 --> 01:21:38,780
batteries Patriot missiles ont été déployés
pour protéger l'Arabie Saoudite et Israël

1641
01:21:38,780 --> 01:21:42,230
d'Irak des attaques de missiles Scud.

1642
01:21:42,230 --> 01:21:46,810
Le Patriot est un milieu de gamme US
surface à système d'air, fabriqué

1643
01:21:46,810 --> 01:21:48,770
par la société Raytheon.

1644
01:21:48,770 --> 01:21:55,340
>> -La Taille de l'intercepteur Patriot
lui-même est d'environ environ 20 pieds de long.

1645
01:21:55,340 --> 01:21:58,230
Et il pèse environ 2000 livres.

1646
01:21:58,230 --> 01:22:02,320
Et il porte une ogive d'environ,
Je pense qu'il est à peu près 150 livres.

1647
01:22:02,320 --> 01:22:06,930
Et la charge militaire est lui-même
un explosif, qui

1648
01:22:06,930 --> 01:22:10,330
a des fragments autour de lui.

1649
01:22:10,330 --> 01:22:14,680
L'enveloppe de la tête militaire est
conçu pour agir comme chevrotines.

1650
01:22:14,680 --> 01:22:17,110
>> -Les Missiles sont portés
quatre par conteneur,

1651
01:22:17,110 --> 01:22:20,130
et sont transportés par une semi-remorque.

1652
01:22:20,130 --> 01:22:27,930
>> -Le Système Patriot anti-missile
remonte au moins 20 ans.

1653
01:22:27,930 --> 01:22:31,420
Il a été conçu à l'origine
comme un missile de défense aérienne

1654
01:22:31,420 --> 01:22:33,720
pour abattre des avions ennemis.

1655
01:22:33,720 --> 01:22:37,500
Dans la première guerre du Golfe,
lorsque cette guerre est arrivée,

1656
01:22:37,500 --> 01:22:42,745
l'armée voulait l'utiliser pour
abattre gammares, pas des avions.

1657
01:22:42,745 --> 01:22:46,620
>> La Force aérienne irakienne était
non pas tant d'un problème.

1658
01:22:46,620 --> 01:22:49,670
Mais l'armée était inquiet à propos de gammares.

1659
01:22:49,670 --> 01:22:53,170
Et donc ils ont essayé de
mettre à niveau le Patriot.

1660
01:22:53,170 --> 01:22:55,800
>> -Intercepting Un ennemi
missile voyage à mach 5

1661
01:22:55,800 --> 01:22:58,830
allait être assez difficile.

1662
01:22:58,830 --> 01:23:01,490
Mais quand le Patriot
a été transporté en service,

1663
01:23:01,490 --> 01:23:05,860
l'armée n'a pas connaissance d'un
modification irakienne qui a fait

1664
01:23:05,860 --> 01:23:08,930
leurs gammares presque impossible de frapper.

1665
01:23:08,930 --> 01:23:13,740
>> -Quel Est arrivé les gammares que
venaient en étaient instables.

1666
01:23:13,740 --> 01:23:14,692
Ils ont été vacillant.

1667
01:23:14,692 --> 01:23:17,910
La raison de ceci était
les Irakiens, afin

1668
01:23:17,910 --> 01:23:21,280
pour obtenir 600 kilomètres
sur un 300 km

1669
01:23:21,280 --> 01:23:24,700
missile à portée, a pris du poids
de la tête militaire avant.

1670
01:23:24,700 --> 01:23:26,390
Ils ont fait l'ogive plus léger.

1671
01:23:26,390 --> 01:23:30,330
>> Alors maintenant, le Patriot est
en essayant de venir au Scud.

1672
01:23:30,330 --> 01:23:33,230
Et la plupart du temps, la
écrasante majorité du temps,

1673
01:23:33,230 --> 01:23:35,940
il serait juste voler par le Scud.

1674
01:23:35,940 --> 01:23:40,260
Une fois que les opérateurs du système Patriot
a réalisé le Patriot a raté sa cible,

1675
01:23:40,260 --> 01:23:44,690
ils ont fait exploser la tête du Patriot
pour éviter les pertes possibles si elle

1676
01:23:44,690 --> 01:23:47,570
a été autorisé à tomber sur le sol.

1677
01:23:47,570 --> 01:23:51,790
>> -Que Est ce que la plupart des gens ont vu,
ces grosses boules de feu dans le ciel,

1678
01:23:51,790 --> 01:23:57,550
et mal compris, comme
intercepts d'ogives Scud.

1679
01:23:57,550 --> 01:23:59,630
>> -Bien Dans la nuit
ciel, Patriots est apparu

1680
01:23:59,630 --> 01:24:03,370
être avec succès
détruire Scuds, à Dhahran,

1681
01:24:03,370 --> 01:24:06,360
il pourrait y avoir aucune erreur
sur ses performances.

1682
01:24:06,360 --> 01:24:10,970
Là, le système radar de la Patriot
perdu la trace d'un Scud entrant,

1683
01:24:10,970 --> 01:24:13,721
et jamais lancé en raison
à un défaut de logiciel.

1684
01:24:13,721 --> 01:24:17,090

1685
01:24:17,090 --> 01:24:21,940
Ce sont les Israéliens qui découvrit le premier
que plus le système était allumé,

1686
01:24:21,940 --> 01:24:25,690
plus l'écart de temps
est devenue, grâce à une horloge incorporée

1687
01:24:25,690 --> 01:24:27,810
dans l'ordinateur du système.

1688
01:24:27,810 --> 01:24:31,210
>> -Environ Deux semaines avant
la tragédie à Dhahran,

1689
01:24:31,210 --> 01:24:33,770
les Israéliens ont déclaré à
le Département de la Défense

1690
01:24:33,770 --> 01:24:35,590
que le système était en train de perdre du temps.

1691
01:24:35,590 --> 01:24:38,360
Après environ huit heures ou en cours d'exécution,
ils ont remarqué que le système

1692
01:24:38,360 --> 01:24:40,720
devenait nettement moins précis.

1693
01:24:40,720 --> 01:24:44,900
Le Département de la Défense a répondu par
dire toutes les batteries Patriot

1694
01:24:44,900 --> 01:24:47,950
de ne pas laisser les systèmes
pendant une longue période.

1695
01:24:47,950 --> 01:24:52,160
Ils ne disaient jamais ce que longtemps était--
huit heures, 10 heures, 1000 heures.

1696
01:24:52,160 --> 01:24:54,360
Personne ne savait.

1697
01:24:54,360 --> 01:24:56,380
>> -La Batterie Patriot
stationné à la caserne

1698
01:24:56,380 --> 01:25:01,350
à Dhahran et ses défauts internes
horloge avait été sur plus de 100 heures

1699
01:25:01,350 --> 01:25:04,670
dans la nuit du 25 Février.

1700
01:25:04,670 --> 01:25:08,917
>> -Il Suivis le temps d'une précision
d'environ un dixième de seconde.

1701
01:25:08,917 --> 01:25:11,000
Or, un dixième de seconde,
est un nombre intéressant,

1702
01:25:11,000 --> 01:25:14,920
parce qu'il ne peut pas être exprimé
exactement en binaire, qui

1703
01:25:14,920 --> 01:25:19,820
signifie qu'il ne peut pas être exprimé exactement
dans un ordinateur numérique moderne.

1704
01:25:19,820 --> 01:25:21,540
C'est dur à croire.

1705
01:25:21,540 --> 01:25:24,210
>> Mais l'utiliser comme un exemple.

1706
01:25:24,210 --> 01:25:26,540
Prenons le numéro un tiers.

1707
01:25:26,540 --> 01:25:30,350
Un tiers ne peut pas être
exprimée en décimal exactement.

1708
01:25:30,350 --> 01:25:35,080
Un tiers est 0,333
passe pour l'infini.

1709
01:25:35,080 --> 01:25:39,480
>> Il n'y a aucun moyen de le faire avec
précision absolue en décimal.

1710
01:25:39,480 --> 01:25:42,560
Voilà exactement le genre de problème
cela est arrivé dans le Patriot.

1711
01:25:42,560 --> 01:25:47,100
Plus le système a la
pire erreur de temps est devenu.

1712
01:25:47,100 --> 01:25:51,890
>> -Après 100 heures de fonctionnement, la
erreur dans le temps était seulement environ un tiers

1713
01:25:51,890 --> 01:25:53,600
d'une seconde.

1714
01:25:53,600 --> 01:25:57,210
Mais en termes de ciblage d'un
missile se déplaçant à mach 5,

1715
01:25:57,210 --> 01:26:01,710
il a donné lieu à un suivi
erreur de plus de 600 mètres.

1716
01:26:01,710 --> 01:26:05,120
Ce serait une erreur fatale
pour les soldats sur ce

1717
01:26:05,120 --> 01:26:11,940
des événements est un lancement Scud était
détecté par les satellites d'alerte précoce

1718
01:26:11,940 --> 01:26:15,860
et ils savaient que le Scud était
venant dans leur direction générale.

1719
01:26:15,860 --> 01:26:18,320
Ils ne savaient pas d'où il venait.

1720
01:26:18,320 --> 01:26:21,250
>> -C'était Maintenant au radar
composant du système Patriot

1721
01:26:21,250 --> 01:26:26,190
défendre Dhahran pour localiser et garder
piste du missile ennemi entrant.

1722
01:26:26,190 --> 01:26:27,609
>> -Le Radar était très intelligent.

1723
01:26:27,609 --> 01:26:29,650
Il serait en fait suivre
la position du Scud,

1724
01:26:29,650 --> 01:26:33,350
puis prédire où il a probablement
serait la prochaine fois que le radar envoyé

1725
01:26:33,350 --> 01:26:34,420
une impulsion sur.

1726
01:26:34,420 --> 01:26:36,110
Cela a été appelé une porte de gamme.

1727
01:26:36,110 --> 01:26:40,660
>> -Ensuite, Une fois que le Patriot
décide assez de temps a

1728
01:26:40,660 --> 01:26:45,450
passé à revenir en arrière et vérifier le prochain
emplacement pour cet objet détecté,

1729
01:26:45,450 --> 01:26:46,600
il remonte.

1730
01:26:46,600 --> 01:26:51,650
Alors, quand il est retourné à la mauvaise
lieu, il voit alors aucun objet.

1731
01:26:51,650 --> 01:26:55,160
Et il décide qu'il n'y a pas
objet, il était une fausse détection,

1732
01:26:55,160 --> 01:26:56,930
et laisse tomber la piste.

1733
01:26:56,930 --> 01:27:00,030
>> -Le Entrant Scud a disparu
à partir de l'écran radar.

1734
01:27:00,030 --> 01:27:03,260
Et quelques secondes plus tard, il
claqué dans les casernes.

1735
01:27:03,260 --> 01:27:09,150
Le Scud a tué 28, et a été le dernier
un tiré au cours de la première guerre du Golfe.

1736
01:27:09,150 --> 01:27:14,960
>> Tragiquement, le logiciel mis à jour
arrivé à Dhahran le lendemain.

1737
01:27:14,960 --> 01:27:17,930
La faille du logiciel avait
été fixée, la fermeture

1738
01:27:17,930 --> 01:27:22,806
un chapitre dans le trouble
l'histoire du missile Patriot.

1739
01:27:22,806 --> 01:27:23,729
>> [LECTURE VIDÉO]

1740
01:27:23,729 --> 01:27:26,520
DAVID J. Malan: Donc, tout cela est à
dire que ces questions de débordement

1741
01:27:26,520 --> 01:27:28,860
et l'imprécision sont trop réel.

1742
01:27:28,860 --> 01:27:29,920
Alors, comment sommes-nous arrivés là?

1743
01:27:29,920 --> 01:27:31,895
Nous avons commencé avec juste parler de printf.

1744
01:27:31,895 --> 01:27:34,270
Encore une fois, cette fonction
imprime quelque chose à l'écran,

1745
01:27:34,270 --> 01:27:36,450
et nous avons introduit la suite
quelques autres fonctions

1746
01:27:36,450 --> 01:27:37,945
de la bibliothèque que l'on appelle de CS50.

1747
01:27:37,945 --> 01:27:39,910
Et nous allons continuer à
voir ces en temps voulu.

1748
01:27:39,910 --> 01:27:43,760
Et nous, en particulier, utilisé chaîne get,
et obtenir int, et maintenant également obtenir flotteur,

1749
01:27:43,760 --> 01:27:47,410
et d'autres encore seront toujours nous rencontrer
et de nous utiliser avant longtemps.

1750
01:27:47,410 --> 01:27:50,220
>> Mais à l'occasion,
nous avons déjà vu un besoin

1751
01:27:50,220 --> 01:27:53,520
pour stocker ce que ces fonctions main en arrière?

1752
01:27:53,520 --> 01:27:55,920
Ils nous renvoient une chaîne part,
ou un int, ou un flotteur.

1753
01:27:55,920 --> 01:27:59,070
Et parfois, nous avons besoin de mettre ce
string ou int, ou float, quelque part.

1754
01:27:59,070 --> 01:28:03,100
>> Et pour stocker ces choses, rappeler simplement
comme dans Scratch, nous avons des variables.

1755
01:28:03,100 --> 01:28:06,260
Mais contrairement à Scratch,
en C, nous avons les types réels

1756
01:28:06,260 --> 01:28:08,530
des données variables--
types, plus generally--

1757
01:28:08,530 --> 01:28:11,640
parmi eux, une chaîne, un int, un
flotter, et ces autres encore.

1758
01:28:11,640 --> 01:28:15,321
>> Et donc quand nous déclarons variables C,
nous devons déclarer nos types de données.

1759
01:28:15,321 --> 01:28:17,820
Cela ne veut pas quelque chose que nous
avoir à faire plus tard dans le semestre

1760
01:28:17,820 --> 01:28:19,810
que nous passons à d'autres langues.

1761
01:28:19,810 --> 01:28:22,610
Mais pour l'instant, nous devons
a priori à l'avance,

1762
01:28:22,610 --> 01:28:27,370
expliquer à l'ordinateur quel type
de la variable que nous voulons qu'elle nous donne.

1763
01:28:27,370 --> 01:28:30,290
>> Maintenant, quant à lui, d'imprimer
ce genre de types de données,

1764
01:28:30,290 --> 01:28:32,570
nous devons dire printf à quoi nous attendre.

1765
01:28:32,570 --> 01:28:35,450
Et nous avons vu pour cent s pour les chaînes,
et pour les nombres entiers i pour cent,

1766
01:28:35,450 --> 01:28:36,790
et quelques autres déjà.

1767
01:28:36,790 --> 01:28:40,237
Et ce sont tout simplement les exigences
pour la présentation visuelle

1768
01:28:40,237 --> 01:28:41,070
de cette information.

1769
01:28:41,070 --> 01:28:45,080
>> Et chacun d'eux peut effectivement être
paramétrés ou tordu d'une certaine façon,

1770
01:28:45,080 --> 01:28:48,370
si vous voulez poursuivre le contrôle
le type de sortie que vous obtenez.

1771
01:28:48,370 --> 01:28:52,604
Et, en fait, il se trouve que non seulement
est là backslash n pour une nouvelle ligne.

1772
01:28:52,604 --> 01:28:55,520
Il y a quelque chose d'autre appelé backslash
r pour un retour chariot, qui

1773
01:28:55,520 --> 01:28:57,360
est plus proche d'un
vieille machine à écrire à l'école,

1774
01:28:57,360 --> 01:29:00,690
ainsi que Windows utilisé depuis de nombreuses années.

1775
01:29:00,690 --> 01:29:02,690
>> Il y a t backslash pour les onglets.

1776
01:29:02,690 --> 01:29:06,170
Il s'avère, que si vous voulez
guillemet à l'intérieur d'une chaîne,

1777
01:29:06,170 --> 01:29:08,000
rappel que nous avons utilisé
guillemets doubles

1778
01:29:08,000 --> 01:29:10,900
devis sur la gauche et la droite
les extrémités de nos cordes jusqu'ici.

1779
01:29:10,900 --> 01:29:12,420
Cela semble confondre les choses.

1780
01:29:12,420 --> 01:29:15,503
>> Si vous voulez mettre une double citation dans
au milieu d'une string-- et, en fait,

1781
01:29:15,503 --> 01:29:16,670
il est déroutant de voir.

1782
01:29:16,670 --> 01:29:20,120
Et donc vous devez échapper, pour ainsi
dire, une double citation avec quelque chose

1783
01:29:20,120 --> 01:29:21,860
comme, littéralement, backslasher guillemets doubles.

1784
01:29:21,860 --> 01:29:23,230
Et il y a quelques autres encore.

1785
01:29:23,230 --> 01:29:27,540
Et nous allons voir plus de ceux
en utilisation réelle avant longtemps.

1786
01:29:27,540 --> 01:29:30,930
>> Donc, nous allons maintenant de transition
données, et la représentation,

1787
01:29:30,930 --> 01:29:33,820
et les opérateurs arithmétiques, tous
qui nous a donné un certain bâtiment

1788
01:29:33,820 --> 01:29:35,070
blocs avec lesquels jouer.

1789
01:29:35,070 --> 01:29:37,481
Mais maintenant, nous allons donner effectivement
nous le reste du vocabulaire

1790
01:29:37,481 --> 01:29:39,230
que nous avions déjà
la semaine dernière avec Scratch

1791
01:29:39,230 --> 01:29:42,350
en prenant un coup d'oeil à un autre
constructions en C-- pas tous d'entre eux.

1792
01:29:42,350 --> 01:29:44,680
Mais les idées nous sommes
sur le point de voir vraiment juste

1793
01:29:44,680 --> 01:29:48,610
mettre l'accent sur la traduction de
une langue, Scratch, à un autre, C.

1794
01:29:48,610 --> 01:29:51,470
>> Et au fil du temps, nous allons chercher
plus d'outils pour notre boîte à outils,

1795
01:29:51,470 --> 01:29:52,820
pour ainsi dire, syntaxiquement.

1796
01:29:52,820 --> 01:29:57,190
Et, en effet, vous verrez que les idées
sont maintenant plutôt familiers de la semaine dernière.

1797
01:29:57,190 --> 01:29:58,200
Donc, nous allons le faire.

1798
01:29:58,200 --> 01:30:01,870
>> Allons de l'avant et de concocter un programme
qui utilise effectivement quelques expressions,

1799
01:30:01,870 --> 01:30:03,720
une expression booléenne.

1800
01:30:03,720 --> 01:30:05,810
Laissez-moi aller de l'avant ici
et de créer un nouveau fichier.

1801
01:30:05,810 --> 01:30:09,090
Je vais appeler ce condition.c.

1802
01:30:09,090 --> 01:30:12,350
>> Laissez-moi aller de l'avant et
inclure la bibliothèque CS50.

1803
01:30:12,350 --> 01:30:15,640
Et laissez-moi aller de l'avant et inclure
norme io.h pour nos fonctions,

1804
01:30:15,640 --> 01:30:17,690
et printf, et plus, respectivement.

1805
01:30:17,690 --> 01:30:21,900
Permettez-moi de me donner que des passe-partout
void main int, dont l'explication nous allons

1806
01:30:21,900 --> 01:30:23,360
revenir à l'avenir.

1807
01:30:23,360 --> 01:30:26,820
>> Maintenant, laissez-moi aller de l'avant et donner
moi un int via get int.

1808
01:30:26,820 --> 01:30:28,970
Alors laissez-moi aller de l'avant et de faire cela.

1809
01:30:28,970 --> 01:30:33,150
Je veux dire si i est less-- nous allons
distinction entre positif, négatif,

1810
01:30:33,150 --> 01:30:34,260
ou des valeurs nulles.

1811
01:30:34,260 --> 01:30:39,630
>> Donc, si i est inférieur à zéro, laissez-moi
ont tout simplement ce programme simplement dire,

1812
01:30:39,630 --> 01:30:45,370
négative, backslash n, d'autre
si i est supérieur à zéro.

1813
01:30:45,370 --> 01:30:50,030
Maintenant, je suis, bien sûr, va dire
printf positif, backslash n.

1814
01:30:50,030 --> 01:30:53,690
Et puis d'autre si-- je pouvais le faire.

1815
01:30:53,690 --> 01:30:56,410
>> Je pourrais faire si i est égal à 0.

1816
01:30:56,410 --> 01:30:58,840
Mais je serais fais à
moins une erreur déjà.

1817
01:30:58,840 --> 01:31:02,480
Rappelons que le signe égal est
pas égaux, que nous, les humains le savent.

1818
01:31:02,480 --> 01:31:04,010
>> Mais il est l'opérateur d'affectation.

1819
01:31:04,010 --> 01:31:08,640
Et nous ne voulons pas prendre 0 sur le
droit et le mettre dans i à gauche.

1820
01:31:08,640 --> 01:31:14,810
Donc, pour éviter cette confusion, ou
peut-être une mauvaise utilisation du signe égal,

1821
01:31:14,810 --> 01:31:17,740
l'homme a décidé il y a quelques années
que dans de nombreux langages de programmation

1822
01:31:17,740 --> 01:31:21,000
lorsque vous souhaitez vérifier l'égalité
entre la gauche et la droite,

1823
01:31:21,000 --> 01:31:22,635
vous utilisez réellement égal à égal.

1824
01:31:22,635 --> 01:31:24,010
Donc, vous frappez le signe égal à deux reprises.

1825
01:31:24,010 --> 01:31:28,600
Lorsque vous souhaitez affecter de droite
à gauche, vous utilisez un seul signe égal.

1826
01:31:28,600 --> 01:31:32,360
Donc, nous pourrions faire d'autre this--
si i est égal à égal à zéro.

1827
01:31:32,360 --> 01:31:34,710
>> Je pourrais alors aller
ouvrir mes accolades,

1828
01:31:34,710 --> 01:31:39,087
et dire, printf 0, backslash n, fait.

1829
01:31:39,087 --> 01:31:41,170
Mais rappelez-vous comment ces
bifurcations peuvent travailler.

1830
01:31:41,170 --> 01:31:42,836
Et, vraiment, il suffit de penser à la logique.

1831
01:31:42,836 --> 01:31:44,510
i est un nombre.

1832
01:31:44,510 --> 01:31:46,320
Il est un entier, en particulier.

1833
01:31:46,320 --> 01:31:51,600
Et cela signifie que ça va être moins
à 0 ou supérieur à 0, ou 0.

1834
01:31:51,600 --> 01:31:54,600
Donc, il est en quelque sorte de cette
cas de défaut implicite.

1835
01:31:54,600 --> 01:31:57,920
>> Et pour que nous puissions, juste comme
Scratch, passer de l'autre si,

1836
01:31:57,920 --> 01:31:58,747
et juste dire d'autre.

1837
01:31:58,747 --> 01:32:00,830
Logiquement, si vous le
programmeur sais qu'il ya seulement

1838
01:32:00,830 --> 01:32:04,635
trois godets dans lesquels un
scénario peut fall-- la première,

1839
01:32:04,635 --> 01:32:06,510
le deuxième, le troisième ou
dans ce case-- ne le font pas

1840
01:32:06,510 --> 01:32:10,100
la peine d'ajouter la précision supplémentaire
et la logique supplémentaire là.

1841
01:32:10,100 --> 01:32:12,690
Il suffit d'aller de l'avant avec la
cas ici d'autre par défaut.

1842
01:32:12,690 --> 01:32:14,950
>> Maintenant, nous allons aller de l'avant
après avoir enregistré cela, assurez

1843
01:32:14,950 --> 01:32:18,760
conditions dot slash conditions--
pas une grande interface utilisateur,

1844
01:32:18,760 --> 01:32:21,914
parce que je ne suis pas incité le
utilisateur, comme je l'ai mentionné plus tôt.

1845
01:32:21,914 --> 01:32:22,580
Mais ça va.

1846
01:32:22,580 --> 01:32:23,454
Nous allons garder les choses simples.

1847
01:32:23,454 --> 01:32:24,890
Essayons le nombre 42.

1848
01:32:24,890 --> 01:32:26,240
Et c'est positif.

1849
01:32:26,240 --> 01:32:29,120
Essayons le nombre
négative 42, négative.

1850
01:32:29,120 --> 01:32:31,244
>> Essayons la valeur 0.

1851
01:32:31,244 --> 01:32:32,160
Et, en effet, cela fonctionne.

1852
01:32:32,160 --> 01:32:36,900
Maintenant, vous verrez des problèmes avant
longues, des choses de test à trois reprises,

1853
01:32:36,900 --> 01:32:37,980
probablement pas suffisante.

1854
01:32:37,980 --> 01:32:40,438
Vous voudrez probablement tester certains
plus grand nombre, certains petits

1855
01:32:40,438 --> 01:32:43,520
numéros, certains cas de coin, comme
nous venons de les décrire.

1856
01:32:43,520 --> 01:32:45,500
>> Mais pour l'instant, ceci est un
assez simple programme.

1857
01:32:45,500 --> 01:32:48,160
Et je suis assez sûr, logiquement,
qu'il tombe dans trois cas.

1858
01:32:48,160 --> 01:32:52,360
Et, en effet, même si nous venons de
mis l'accent sur les inconvénients potentiels

1859
01:32:52,360 --> 01:32:56,480
d'imprécision et de débordement,
réalité où de nombreux problèmes de CS50,

1860
01:32:56,480 --> 01:32:59,000
on ne va pas à vous soucier
à propos, tout le temps,

1861
01:32:59,000 --> 01:33:02,050
ces questions de débordement et
imprécision, parce que, en fait, en C,

1862
01:33:02,050 --> 01:33:04,889
il est en fait pas du tout
facile d'éviter ces choses.

1863
01:33:04,889 --> 01:33:07,180
Si vous voulez compter jusqu'à
plus grand, et plus grand, et plus grand,

1864
01:33:07,180 --> 01:33:10,510
il se trouve qu'il existe des techniques vous
peut utiliser, impliquant souvent des choses appelées

1865
01:33:10,510 --> 01:33:14,240
bibliothèques, collections de code, que
d'autres personnes ont écrit que vous pouvez utiliser,

1866
01:33:14,240 --> 01:33:16,910
et d'autres langues comme
Java et autres, en fait

1867
01:33:16,910 --> 01:33:18,800
rendre beaucoup plus facile
compter encore plus élevé.

1868
01:33:18,800 --> 01:33:22,810
Donc, il est vraiment certains de ces dangers
en fonction de la langue que vous utilisez.

1869
01:33:22,810 --> 01:33:25,710
Et dans les prochaines semaines, nous allons
voir comment dangereux C vraiment

1870
01:33:25,710 --> 01:33:27,950
peut être si vous ne l'utilisez pas correctement.

1871
01:33:27,950 --> 01:33:30,610
Mais à partir de là, et
Python et JavaScript, sera

1872
01:33:30,610 --> 01:33:35,620
nous couche sur des protections supplémentaires,
et courir moins de ces risques.

1873
01:33:35,620 --> 01:33:38,820
>> Faisons donc un peu plus
logique intéressant dans notre programme.

1874
01:33:38,820 --> 01:33:42,110
Alors laissez-moi aller de l'avant et de créer
un programme appelé logique

1875
01:33:42,110 --> 01:33:46,804
juste pour que je peux jouer avec certains
la logique réelle logical.c.

1876
01:33:46,804 --> 01:33:49,870
Je vais copier et coller un peu
code à partir plus tôt afin que je revienne

1877
01:33:49,870 --> 01:33:52,950
à ce joli point de départ.

1878
01:33:52,950 --> 01:33:56,980
>> Permettez-moi de faire cette fois C. omble Je suis
va lui donner un nom de C

1879
01:33:56,980 --> 01:34:01,510
juste parce qu'il est classique,
obtenir un personnage de l'utilisateur.

1880
01:34:01,510 --> 01:34:03,730
Et supposons que
Je suis en œuvre une partie

1881
01:34:03,730 --> 01:34:07,130
de ce programme de Rm, le supprimer
programme avant qui a incité l'utilisateur

1882
01:34:07,130 --> 01:34:08,400
de supprimer un fichier.

1883
01:34:08,400 --> 01:34:09,750
Comment pourrions-nous faire cela?

1884
01:34:09,750 --> 01:34:14,090
>> Je veux dire, si C est égal à
égal à égal, entre guillemets,

1885
01:34:14,090 --> 01:34:19,304
y, alors je vais assumer
que l'utilisateur a choisi oui.

1886
01:34:19,304 --> 01:34:20,470
Je vais juste imprimer oui.

1887
01:34:20,470 --> 01:34:22,440
Si elle était effectivement en train d'écrire
le programme d'enlèvement,

1888
01:34:22,440 --> 01:34:24,420
nous pourrions supprimer le fichier
avec plus de lignes de code.

1889
01:34:24,420 --> 01:34:25,461
Mais nous allons garder les choses simples.

1890
01:34:25,461 --> 01:34:28,950

1891
01:34:28,950 --> 01:34:34,250
>> Sinon, si c est égal à égal à n--
et maintenant ici, je vais dire,

1892
01:34:34,250 --> 01:34:35,980
l'utilisateur doit avoir signifié pas.

1893
01:34:35,980 --> 01:34:37,360
Et puis d'autre, vous savez quoi?

1894
01:34:37,360 --> 01:34:39,200
Je ne sais pas quoi d'autre
l'utilisateur va taper.

1895
01:34:39,200 --> 01:34:41,533
Donc, je vais juste dire que
qui est une erreur, quelle que soit

1896
01:34:41,533 --> 01:34:43,070
il ou elle a effectivement tapé.

1897
01:34:43,070 --> 01:34:44,180
>> Alors qu'est-ce qui se passe ici?

1898
01:34:44,180 --> 01:34:47,530
Il y a une différence fondamentale
par rapport à ce que je l'ai fait dans le passé.

1899
01:34:47,530 --> 01:34:52,300
Les guillemets doubles, guillemets doubles, double
citations, et, pourtant, des guillemets simples,

1900
01:34:52,300 --> 01:34:53,170
apostrophes.

1901
01:34:53,170 --> 01:34:55,860
Il se trouve en C, que lorsque
vous voulez écrire une chaîne,

1902
01:34:55,860 --> 01:34:59,680
vous utilisez des guillemets, tout comme nous avons
été en utilisant tout ce temps avec printf.

1903
01:34:59,680 --> 01:35:05,030
>> Mais si vous voulez traiter avec juste un
seul caractère, un caractère soi-disant,

1904
01:35:05,030 --> 01:35:06,780
alors vous utilisez réellement des guillemets simples.

1905
01:35:06,780 --> 01:35:08,450
Ceux d'entre vous qui ont programmé
avant, vous pourriez ne pas avoir

1906
01:35:08,450 --> 01:35:10,850
eu à se soucier de cette
distinction dans certaines langues.

1907
01:35:10,850 --> 01:35:12,450
En C, il importe.

1908
01:35:12,450 --> 01:35:15,560
Et quand je reçois un caractère et je veux
pour comparer ce que l'omble utilisant égaux

1909
01:35:15,560 --> 01:35:21,350
équivaut à quelque lettre comme y ou n, je fais,
en effet, besoin d'avoir les guillemets simples.

1910
01:35:21,350 --> 01:35:22,770
>> Maintenant, nous allons aller de l'avant et de faire cela.

1911
01:35:22,770 --> 01:35:29,180
Allons de l'avant et ne font
dot logiques slash logique.

1912
01:35:29,180 --> 01:35:30,305
Et maintenant, je suis être invité.

1913
01:35:30,305 --> 01:35:33,638
Alors, sans doute, une meilleure expérience utilisateur
serait en fait me dire ce qu'il faut faire ici.

1914
01:35:33,638 --> 01:35:36,030
Mais je vais aveuglément
y dire pour oui, OK, bien.

1915
01:35:36,030 --> 01:35:38,780
>> Courons à nouveau, n pour non, agréable.

1916
01:35:38,780 --> 01:35:42,610
Supposons que certaines personnes que je connais,
mes verrouillage des majuscules est trop souvent.

1917
01:35:42,610 --> 01:35:46,740
Donc, je fais le capital Y, entrez, erreur.

1918
01:35:46,740 --> 01:35:49,130
OK, il est pas exactement ce que j'attends.

1919
01:35:49,130 --> 01:35:51,170
En effet, l'ordinateur
est de faire littéralement ce que

1920
01:35:51,170 --> 01:35:54,794
Je l'ai dit à do-- vérifier
minuscules y et minuscules n.

1921
01:35:54,794 --> 01:35:56,960
Cela ne se sent pas comme bon
expérience utilisateur, cependant.

1922
01:35:56,960 --> 01:36:02,010
Permettez-moi de demander et d'accepter
soit minuscules ou majuscules.

1923
01:36:02,010 --> 01:36:05,090
Donc, il se trouve, vous voudrez peut-être
dire quelque chose comme dans Scratch,

1924
01:36:05,090 --> 01:36:11,150
comme littéralement ou C est égal à
est égal à capitaux unique y citée.

1925
01:36:11,150 --> 01:36:14,400
Tours dehors, C n'a pas
ce mot-clé littéral ou.

1926
01:36:14,400 --> 01:36:15,880
>> Mais il a deux barres verticales.

1927
01:36:15,880 --> 01:36:18,463
Vous devez tenir Maj habituellement,
si vous utilisez un clavier américain,

1928
01:36:18,463 --> 01:36:21,910
et appuyez sur la barre verticale
clé ci-dessus la clé de votre retour.

1929
01:36:21,910 --> 01:36:25,410
Mais cette barre verticale
signifie barre verticale ou.

1930
01:36:25,410 --> 01:36:29,220
>> Si, au contraire, nous avons voulu
à dire et, comme dans Scratch,

1931
01:36:29,220 --> 01:36:31,180
nous pourrions faire esperluette esperluette.

1932
01:36:31,180 --> 01:36:34,330
Cela n'a aucun sens logique ici,
parce qu'un homme ne pouvait pas

1933
01:36:34,330 --> 01:36:40,110
ont tapé y et minuscules y
et le capital Y comme le même caractère.

1934
01:36:40,110 --> 01:36:42,470
Donc, ou est ce que nous entendons ici.

1935
01:36:42,470 --> 01:36:49,280
>> Donc, si je fais cela dans les deux endroits, ou c
est égal à equals N majuscule, maintenant rediffuser,

1936
01:36:49,280 --> 01:36:52,390
make logique, relancez logique.

1937
01:36:52,390 --> 01:36:54,200
Maintenant, je peux taper y.

1938
01:36:54,200 --> 01:36:56,920
Et je peux le faire à nouveau avec
capitale Y ou N. de capital

1939
01:36:56,920 --> 01:36:59,630
Et je pourrais ajouter en plus
combinaisons fixes.

1940
01:36:59,630 --> 01:37:01,810
>> Donc, cela est logique
programme dans la mesure où maintenant

1941
01:37:01,810 --> 01:37:04,940
Je vérifie logiquement pour
cette valeur ou cette valeur.

1942
01:37:04,940 --> 01:37:09,420
Et je ne dois pas, nécessairement,
venir avec deux ifs ou bien des ifs.

1943
01:37:09,420 --> 01:37:12,960
Je peux effectivement combiner une partie de la
une logique liée ensemble de cette façon.

1944
01:37:12,960 --> 01:37:14,950
Donc, ce serait mieux
conçu que simplement

1945
01:37:14,950 --> 01:37:20,490
dire, si C est égal à minuscules y,
imprimer oui, autre si c est égal à Y majuscule,

1946
01:37:20,490 --> 01:37:23,074
imprimer oui, autre si c est égal à
lower-- en d'autres termes,

1947
01:37:23,074 --> 01:37:24,990
vous ne devez pas avoir
de plus en plus de branches.

1948
01:37:24,990 --> 01:37:31,840
Vous pouvez combiner certains de l'équivalent
branches logiquement, que de cette manière.

1949
01:37:31,840 --> 01:37:37,150
>> Donc, nous allons jeter un oeil à un seul
ingrédient final, une construction finale,

1950
01:37:37,150 --> 01:37:37,847
que C permet.

1951
01:37:37,847 --> 01:37:39,930
Et nous reviendrons dans le
avenir pour d'autres encore.

1952
01:37:39,930 --> 01:37:44,400
Et puis nous allons conclure en regardant
de ne pas la justesse de code--

1953
01:37:44,400 --> 01:37:49,070
obtenir le code pour work-- mais la conception
du code, et planter ces graines tôt.

1954
01:37:49,070 --> 01:37:54,337
>> Alors laissez-moi aller de l'avant et
ouvrir un nouveau fichier ici.

1955
01:37:54,337 --> 01:37:54,920
Vous savez quoi?

1956
01:37:54,920 --> 01:37:57,450
Je vais ré-implémenter
ce même programme,

1957
01:37:57,450 --> 01:37:58,940
mais en utilisant une construction différente.

1958
01:37:58,940 --> 01:38:03,110
>> Alors laissez-moi vite me donner
l'accès à inclure CS50.h

1959
01:38:03,110 --> 01:38:07,150
pour la bibliothèque CS50,
Io.h standard pour printf.

1960
01:38:07,150 --> 01:38:09,510
Donnez-moi mon void main int.

1961
01:38:09,510 --> 01:38:12,310
Et puis ici, laissez
moi aller de l'avant et faire cela.

1962
01:38:12,310 --> 01:38:15,010
>> Char c obtient obtenir char, comme avant.

1963
01:38:15,010 --> 01:38:19,770
Et je vais utiliser une nouvelle construction
maintenant-- passer, sur ce personnage?

1964
01:38:19,770 --> 01:38:22,820
Donc interrupteur est un peu comme
la commutation d'un train pistes.

1965
01:38:22,820 --> 01:38:25,070
Ou, vraiment, il est une sorte de
un si bien, si bien si,

1966
01:38:25,070 --> 01:38:26,980
mais écrit un peu différemment.

1967
01:38:26,980 --> 01:38:28,490
>> Un commutateur ressemble à ceci.

1968
01:38:28,490 --> 01:38:32,060
Vous avez l'interrupteur, puis ce
caractère ou numéro que vous voulez regarder,

1969
01:38:32,060 --> 01:38:35,000
puis quelques accolades aiment dans
Scratch, dites simplement faire ce genre de choses.

1970
01:38:35,000 --> 01:38:36,480
Et puis vous avez différents cas.

1971
01:38:36,480 --> 01:38:37,830
>> Vous n'utilisez pas si et d'autre.

1972
01:38:37,830 --> 01:38:40,050
Vous utilisez littéralement le mot cas.

1973
01:38:40,050 --> 01:38:41,790
Et vous dire quelque chose comme ça.

1974
01:38:41,790 --> 01:38:46,820
>> Ainsi, dans le cas d'un minuscule y,
ou dans le cas d'un chapiteau Y,

1975
01:38:46,820 --> 01:38:50,350
aller de l'avant et d'imprimer oui.

1976
01:38:50,350 --> 01:38:52,020
Et puis sortir de l'interrupteur.

1977
01:38:52,020 --> 01:38:52,580
C'est tout.

1978
01:38:52,580 --> 01:38:53,880
Avaient fini.

1979
01:38:53,880 --> 01:39:00,270
>> Sinon, si, pour ainsi dire,
minuscules n ou N majuscule,

1980
01:39:00,270 --> 01:39:05,560
alors allez-y et imprimer
out pas, puis briser.

1981
01:39:05,560 --> 01:39:11,022
Else-- et ce genre de est le
cas par défaut indeed-- printf error--

1982
01:39:11,022 --> 01:39:13,980
et juste pour faire bonne mesure, bien que
logiquement cette rupture est pas nécessaire

1983
01:39:13,980 --> 01:39:15,896
parce que nous sommes à la fin
du commutateur de toute façon,

1984
01:39:15,896 --> 01:39:17,520
Je vais maintenant sortir de l'interrupteur.

1985
01:39:17,520 --> 01:39:19,280
Donc, cela ressemble un peu différent.

1986
01:39:19,280 --> 01:39:21,272
>> Mais, logiquement, il est
en fait équivalent.

1987
01:39:21,272 --> 01:39:22,980
Et pourquoi voudriez-vous utiliser
l'un sur l'autre?

1988
01:39:22,980 --> 01:39:26,220
Parfois, juste préférence personnelle,
parfois l'esthétique,

1989
01:39:26,220 --> 01:39:28,420
si je regarde à ce
maintenant, il y a quelque chose

1990
01:39:28,420 --> 01:39:30,510
à dire pour la
la lisibilité de ce code.

1991
01:39:30,510 --> 01:39:33,690
Je veux dire, sans parler du fait que cette
le code est nouveau pour beaucoup d'entre nous dans la chambre.

1992
01:39:33,690 --> 01:39:36,515
>> Mais il juste un peu est assez.

1993
01:39:36,515 --> 01:39:40,760
Vous voyez minuscules y, capitale Y,
minuscules n, N majuscule par défaut,

1994
01:39:40,760 --> 01:39:43,150
juste sorte de sauts
sur vous d'une manière

1995
01:39:43,150 --> 01:39:45,200
que, sans doute, peut-être
l'exemple précédent

1996
01:39:45,200 --> 01:39:48,780
avec les ifs et les barres verticales,
et les ifs d'autre, pourraient ne pas avoir.

1997
01:39:48,780 --> 01:39:54,600
Donc, ce qui est vraiment une question de personnel
choix, vraiment, ou la lisibilité,

1998
01:39:54,600 --> 01:39:55,360
du code.

1999
01:39:55,360 --> 01:40:01,230
>> Mais en termes de fonctionnalité, laissez-moi
aller de l'avant et de faire un commutateur, slash dot

2000
01:40:01,230 --> 01:40:08,830
commutateur, et maintenant taper y minuscules,
Y majuscule, minuscule n, N majuscule,

2001
01:40:08,830 --> 01:40:12,250
David, réessayez parce que ce
pas un seul caractère.

2002
01:40:12,250 --> 01:40:15,050
Faisons x, erreur, comme prévu.

2003
01:40:15,050 --> 01:40:18,640
Et, logically-- et cela est quelque chose
Je vous encourage à general-- même

2004
01:40:18,640 --> 01:40:20,790
si nous ne faisons que gratter la
la surface de certaines de ces fonctions.

2005
01:40:20,790 --> 01:40:23,560
>> Et il ne serait pas évident quand vous
vous asseoir au clavier,

2006
01:40:23,560 --> 01:40:24,370
Comment cela marche-t-il?

2007
01:40:24,370 --> 01:40:25,240
Qu'est-ce que cela?

2008
01:40:25,240 --> 01:40:28,630
La belle chose d'avoir
un ordinateur portable ou de bureau, ou l'accès

2009
01:40:28,630 --> 01:40:32,290
à un ordinateur avec un compilateur,
et avec un éditeur de code comme ceci,

2010
01:40:32,290 --> 01:40:35,990
est que vous pouvez presque toujours répondre à ces
questions pour vous-même juste en essayant.

2011
01:40:35,990 --> 01:40:39,570
>> Par exemple, si la rhétorique
question à portée de main étaient,

2012
01:40:39,570 --> 01:40:42,540
ce qui se passe si vous oubliez
vos déclarations de rupture?

2013
01:40:42,540 --> 01:40:44,400
Qui est en fait un
très courante chose à faire,

2014
01:40:44,400 --> 01:40:46,540
car il ne semble pas
comme vous avez vraiment besoin.

2015
01:40:46,540 --> 01:40:49,790
Ils ne sont pas vraiment complètent pas votre
pensé comme une parenthèse ou bouclés

2016
01:40:49,790 --> 01:40:50,714
brace fait.

2017
01:40:50,714 --> 01:40:52,630
Allons-y et
recompiler le code et voir.

2018
01:40:52,630 --> 01:40:56,690
Donc, assurez-commutateur, barre oblique point.

2019
01:40:56,690 --> 01:40:59,435
Voyons tapez en minuscules
y, le dessus du boîtier, Entrée.

2020
01:40:59,435 --> 01:41:02,390

2021
01:41:02,390 --> 01:41:03,700
Je tapais y.

2022
01:41:03,700 --> 01:41:07,420
>> Le programme dit oui, non, erreur,
comme si elle était en train de changer son esprit.

2023
01:41:07,420 --> 01:41:12,280
Mais ce genre d'été, parce que ce qui se passe
avec un commutateur est le premier cas que

2024
01:41:12,280 --> 01:41:16,899
correspondance signifie essentiellement, hé ordinateur,
exécuter la totalité du code-dessous.

2025
01:41:16,899 --> 01:41:19,690
Et si vous ne dites pas la rupture, ou
ne dites pas la rupture, ou ne pas dire pause,

2026
01:41:19,690 --> 01:41:22,540
l'ordinateur va exploser
à travers toutes les lignes

2027
01:41:22,540 --> 01:41:25,779
et d'exécuter tous les jusqu'à
il obtient à cette accolade.

2028
01:41:25,779 --> 01:41:27,320
Donc, les freins sont, en effet, nécessaire.

2029
01:41:27,320 --> 01:41:30,120
Mais un plat à emporter ici est, quand
dans le doute, essayer quelque chose.

2030
01:41:30,120 --> 01:41:32,510
Peut-être enregistrer votre premier code,
ou l'enregistrer dans un fichier supplémentaire

2031
01:41:32,510 --> 01:41:35,930
si vous êtes vraiment inquiet
gâcher et d'avoir à récupérer

2032
01:41:35,930 --> 01:41:37,430
le travail que vous savez fonctionne.

2033
01:41:37,430 --> 01:41:38,410
>> Mais essayer des choses.

2034
01:41:38,410 --> 01:41:41,074
Et ne soyez pas aussi peur, peut-être,
de ce que l'ordinateur peut faire,

2035
01:41:41,074 --> 01:41:42,490
ou que vous pourriez casser quelque chose.

2036
01:41:42,490 --> 01:41:45,790
Vous pouvez toujours revenir en arrière
à une version antérieure.

2037
01:41:45,790 --> 01:41:48,640
>> Donc, nous allons mettre fin en regardant
à la conception de code.

2038
01:41:48,640 --> 01:41:52,020
Nous avons cette capacité maintenant écrire
conditions, et des boucles d'écriture,

2039
01:41:52,020 --> 01:41:53,850
et les variables et les fonctions d'appel.

2040
01:41:53,850 --> 01:41:57,590
Donc, franchement, nous sommes un peu en arrière à
où nous étions il y a une semaine avec Scratch,

2041
01:41:57,590 --> 01:42:03,120
mais avec un texte moins convaincant
environnement que Scratch permet.

2042
01:42:03,120 --> 01:42:06,990
>> Mais remarquons rapidité avec laquelle nous avons acquis
ce vocabulaire, même si elle est

2043
01:42:06,990 --> 01:42:10,570
va prendre un peu de temps à couler,
de sorte que nous pouvons maintenant utiliser ce vocabulaire

2044
01:42:10,570 --> 01:42:13,320
pour écrire des programmes plus intéressants.

2045
01:42:13,320 --> 01:42:15,940
Et nous allons prendre un pas de bébé
dans cette direction, comme suit.

2046
01:42:15,940 --> 01:42:17,890
Laissez-moi aller de l'avant et
créer un nouveau fichier ici.

2047
01:42:17,890 --> 01:42:20,750
>> Je vais appeler cette
prototype.c, et d'introduire

2048
01:42:20,750 --> 01:42:23,954
pour la première fois, la possibilité
de faire vos propres fonctions.

2049
01:42:23,954 --> 01:42:25,870
Certains d'entre vous pourraient avoir
fait avec Scratch,

2050
01:42:25,870 --> 01:42:28,430
de sorte que vous pouvez créer votre
propres blocs personnalisés dans Scratch,

2051
01:42:28,430 --> 01:42:30,892
puis faites-les glisser en place
partout où vous souhaitez en C.

2052
01:42:30,892 --> 01:42:33,100
Et dans la plupart des émissions
langues, vous pouvez faire exactement

2053
01:42:33,100 --> 01:42:36,580
that-- faire vos propres fonctions,
si elles ne sont pas déjà.

2054
01:42:36,580 --> 01:42:41,660
>> Ainsi, par exemple, laissez-moi aller de l'avant
et comprennent CS50.h, et comprennent

2055
01:42:41,660 --> 01:42:46,110
norme io.h, void main int.

2056
01:42:46,110 --> 01:42:49,020
Et maintenant, nous avons un
espace réservé prêt à aller.

2057
01:42:49,020 --> 01:42:51,550
Je garde les choses d'impression
comme les noms des personnes aujourd'hui.

2058
01:42:51,550 --> 01:42:54,910
Et cela se sent like--
ne serait pas bien s'il y

2059
01:42:54,910 --> 01:42:56,936
étaient une fonction appelée nom d'impression?

2060
01:42:56,936 --> 01:42:58,060
Je ne dois pas utiliser printf.

2061
01:42:58,060 --> 01:42:59,976
Je n'ai pas de se rappeler
tous les codes de format.

2062
01:42:59,976 --> 01:43:03,050
Pourquoi pas moi, ou pourquoi
n'a pas quelqu'un avant moi,

2063
01:43:03,050 --> 01:43:05,980
créer une fonction appelée impression
nom, donné un nom,

2064
01:43:05,980 --> 01:43:06,980
imprime simplement it out?

2065
01:43:06,980 --> 01:43:11,700
>> En d'autres termes, si je dis, hey,
ordinateur, donnez-moi une chaîne

2066
01:43:11,700 --> 01:43:14,870
en demandant à l'utilisateur d'une telle,
via la fonction de chaîne get de CS50.

2067
01:43:14,870 --> 01:43:18,090
Hey, ordinateur, mettez cette chaîne dans
la variable du côté de la main gauche,

2068
01:43:18,090 --> 01:43:19,150
et appelez-le par.

2069
01:43:19,150 --> 01:43:25,150
Et puis, hé ordinateur, aller de l'avant
et imprimer que le nom de la personne, fait.

2070
01:43:25,150 --> 01:43:29,240
>> Maintenant, ce serait bien, parce que
ce programme, bien nommé,

2071
01:43:29,240 --> 01:43:32,170
me dit ce qu'il est censé faire
par des noms de ceux fonction.

2072
01:43:32,170 --> 01:43:35,930
Laissez-moi aller et faire un prototype, entrez.

2073
01:43:35,930 --> 01:43:37,930
Et, malheureusement,
cela ne va pas à voler.

2074
01:43:37,930 --> 01:43:42,430
>> Prototype.c, ligne 7, caractère
5, erreur, déclaration implicite

2075
01:43:42,430 --> 01:43:45,960
de la fonction nom d'impression
est invalide dans C99, C99

2076
01:43:45,960 --> 01:43:48,130
ce qui signifie une version de C
qui est sorti en 1999.

2077
01:43:48,130 --> 01:43:48,730
C'est tout.

2078
01:43:48,730 --> 01:43:51,780
>> Donc, je ne sais pas ce que
tout cela signifie encore.

2079
01:43:51,780 --> 01:43:53,810
Mais je reconnais erreur en rouge.

2080
01:43:53,810 --> 01:43:54,770
C'est assez évident.

2081
01:43:54,770 --> 01:43:56,769
>> Et il semble qu'avec
le caractère vert ici,

2082
01:43:56,769 --> 01:44:00,520
le problème est avec le nom d'impression, ouvert
paren s, à proximité paren, semi-colon.

2083
01:44:00,520 --> 01:44:04,800
Mais déclaration implicite de
fonction que nous avons vu brièvement plus tôt.

2084
01:44:04,800 --> 01:44:07,880
Cela signifie simplement que Clang
ne sais pas ce que je veux dire.

2085
01:44:07,880 --> 01:44:12,000
>> Je l'ai utilisé un mot de vocabulaire qu'il est
jamais vu ou été enseigné auparavant.

2086
01:44:12,000 --> 01:44:14,950
Et donc je dois enseigner
ce que signifie cette fonction.

2087
01:44:14,950 --> 01:44:16,590
Je vais donc aller de l'avant et de le faire.

2088
01:44:16,590 --> 01:44:20,970
>> Je vais aller de l'avant et mettre en œuvre
ma propre fonction appelée Imprimer Nom.

2089
01:44:20,970 --> 01:44:27,720
Et je vais vous dire, comme suit,
il le fait, printf, bonjour, pour cent

2090
01:44:27,720 --> 01:44:30,760
s, backslash n, nom, point-virgule.

2091
01:44:30,760 --> 01:44:32,250
Alors qu'est-ce que je viens de faire?

2092
01:44:32,250 --> 01:44:34,325
>> Donc, il se trouve, à
mettre en œuvre votre propre fonction,

2093
01:44:34,325 --> 01:44:36,845
nous sorte de empruntons certains
la même structure principale

2094
01:44:36,845 --> 01:44:38,720
que nous venons de
pris pour acquis, et je

2095
01:44:38,720 --> 01:44:40,730
il suffit de savoir la copie et
coller à peu près ce que

2096
01:44:40,730 --> 01:44:42,170
J'ai écrit dans le passé.

2097
01:44:42,170 --> 01:44:43,570
Mais remarquez le modèle ici.

2098
01:44:43,570 --> 01:44:46,750
Int, Main, Void, nous allons taquiner dehors
avant longtemps ce que cela signifie réellement.

2099
01:44:46,750 --> 01:44:49,160
>> Mais pour aujourd'hui, juste
remarquer le parallélisme.

2100
01:44:49,160 --> 01:44:51,210
Void, le nom d'impression,
nom de chaîne, donc il n'y a

2101
01:44:51,210 --> 01:44:53,310
un mot-clé pourpre, qui
nous allons commencer

2102
01:44:53,310 --> 01:44:57,067
appeler un type de retour, le nom de
la fonction, puis l'entrée.

2103
01:44:57,067 --> 01:44:59,400
Donc, en fait, nous pouvons distiller
ce genre de comme la semaine dernière

2104
01:44:59,400 --> 01:45:02,030
comme cela est le nom ou le
algorithme du code que nous sommes

2105
01:45:02,030 --> 01:45:03,761
va write-- la
algorithme sous-jacent

2106
01:45:03,761 --> 01:45:05,010
le code que nous allons écrire.

2107
01:45:05,010 --> 01:45:06,180
>> Ceci est son entrée.

2108
01:45:06,180 --> 01:45:07,670
Ceci est sa sortie.

2109
01:45:07,670 --> 01:45:11,730
Cette fonction, le nom d'impression, est
conçu pour prendre une chaîne appelée nom,

2110
01:45:11,730 --> 01:45:14,350
ou autre chose, comme entrée, puis vide.

2111
01:45:14,350 --> 01:45:16,904
Il ne retourne rien,
comme obtenir string ou obtenir int fait.

2112
01:45:16,904 --> 01:45:18,570
Donc, ça va me remettre quelque chose en retour.

2113
01:45:18,570 --> 01:45:20,960
Il va juste avoir un
effet secondaire, pour ainsi dire,

2114
01:45:20,960 --> 01:45:22,570
d'imprimer le nom d'une personne.

2115
01:45:22,570 --> 01:45:25,260
Donc, remarque, ligne 7, je
peut appeler le nom d'impression.

2116
01:45:25,260 --> 01:45:28,920
Ligne 10, je peux définir
ou mettre en œuvre le nom d'impression.

2117
01:45:28,920 --> 01:45:31,450
Mais, malheureusement, cela ne suffit pas.

2118
01:45:31,450 --> 01:45:34,230
>> Laissez-moi aller de l'avant et
recompiler après avoir sauvegardé.

2119
01:45:34,230 --> 01:45:36,910
Whoa, maintenant, je l'ai fait
Pire encore, il semblerait.

2120
01:45:36,910 --> 01:45:40,027
déclaration Donc implicite de
nom fonction d'impression est invalide.

2121
01:45:40,027 --> 01:45:41,360
Et, encore une fois, il n'y a plus d'erreurs.

2122
01:45:41,360 --> 01:45:44,430
Mais comme je l'ai mis en garde plus tôt, même
si vous obtenez accablé avec,

2123
01:45:44,430 --> 01:45:47,850
ou un peu triste de voir tant de
erreurs, se concentrer uniquement sur la première

2124
01:45:47,850 --> 01:45:50,500
d'abord, parce qu'il pourrait juste
ont eu un effet en cascade.

2125
01:45:50,500 --> 01:45:54,970
Donc, C ou plus précisément Clang,
ne reconnaît toujours pas le nom d'impression.

2126
01:45:54,970 --> 01:45:57,580
>> Et c'est parce Clang,
par la conception, est un peu idiot.

2127
01:45:57,580 --> 01:45:59,280
Il ne fait que ce que vous lui demandez de faire.

2128
01:45:59,280 --> 01:46:03,950
Et il ne le fait que dans l'ordre
dans laquelle vous lui demandez de faire.

2129
01:46:03,950 --> 01:46:08,270
>> Donc, je l'ai défini principale sur la ligne de quatre,
comme nous l'avons fait assez souvent.

2130
01:46:08,270 --> 01:46:10,980
J'ai défini le nom d'impression à la ligne 10.

2131
01:46:10,980 --> 01:46:14,793
Mais je suis en train d'utiliser
nom d'impression en ligne sept.

2132
01:46:14,793 --> 01:46:16,670
>> Il est trop tôt, n'existe pas encore.

2133
01:46:16,670 --> 01:46:22,150
Donc, je pourrais être intelligent, et être comme,
OK, donc nous allons jouer tout le long,

2134
01:46:22,150 --> 01:46:26,680
et déplacer le nom d'impression jusqu'à
ici, et re-compiler.

2135
01:46:26,680 --> 01:46:27,550
Oh mon Dieu.

2136
01:46:27,550 --> 01:46:28,260
Ça a marché.

2137
01:46:28,260 --> 01:46:29,670
C'était aussi simple que ça.

2138
01:46:29,670 --> 01:46:31,120
>> Mais la logique est exactement cela.

2139
01:46:31,120 --> 01:46:33,870
Vous devez apprendre à Clang ce qu'il
est en définissant la fonction première.

2140
01:46:33,870 --> 01:46:34,920
Ensuite, vous pouvez l'utiliser.

2141
01:46:34,920 --> 01:46:36,940
Mais, franchement, cela se sent
comme une pente glissante.

2142
01:46:36,940 --> 01:46:38,773
>> Ainsi, chaque fois que je lance
dans un problème, je suis juste

2143
01:46:38,773 --> 01:46:42,450
va mettre en évidence et de copier le code
Je l'ai écrit, le couper et le coller ici.

2144
01:46:42,450 --> 01:46:44,370
Et, sûrement, nous pourrions
ingénier certains scénarios

2145
01:46:44,370 --> 01:46:46,286
où une fonction pourrait
besoin d'appeler un autre.

2146
01:46:46,286 --> 01:46:49,030
Et vous ne pouvez pas mettre tous les
fonction ci-dessus tous les autres.

2147
01:46:49,030 --> 01:46:50,930
>> Donc, il se trouve qu'il y a
une meilleure solution.

2148
01:46:50,930 --> 01:46:53,100
Nous pouvons laisser ce soit.

2149
01:46:53,100 --> 01:46:56,677
Et, franchement, il est généralement agréable,
et pratique, et un bon design

2150
01:46:56,677 --> 01:46:59,760
de mettre principale d'abord, parce que, encore une fois,
principale, juste comme quand le drapeau vert cliqué,

2151
01:46:59,760 --> 01:47:02,027
qui est la fonction qui
est exécuté par défaut.

2152
01:47:02,027 --> 01:47:04,110
Donc, vous pourriez aussi bien mettre
au sommet du fichier

2153
01:47:04,110 --> 01:47:06,560
de sorte que lorsque vous ou tout
autre homme regarde le fichier

2154
01:47:06,560 --> 01:47:09,360
vous savez ce qui se passe
juste en lisant principal en premier.

2155
01:47:09,360 --> 01:47:18,360
Donc, il se trouve, nous pouvons dire Clang
de manière proactive, hé, Clang, sur la quatrième ligne,

2156
01:47:18,360 --> 01:47:20,940
Je promets de mettre en œuvre
une fonction appelée Imprimer

2157
01:47:20,940 --> 01:47:25,600
Nom qui prend un nom de chaîne appelée
comme entrée, et retourne rien, vide.

2158
01:47:25,600 --> 01:47:27,770
Et je vais autour de
la mise en œuvre plus tard.

2159
01:47:27,770 --> 01:47:28,680
>> Voici Main.

2160
01:47:28,680 --> 01:47:32,130
Principal maintenant sur la ligne 9 peut utiliser
Imprimer Nom parce Clang

2161
01:47:32,130 --> 01:47:35,600
est confiant que, par la suite,
il rencontre la définition

2162
01:47:35,600 --> 01:47:37,880
de la mise en œuvre du Print Nom.

2163
01:47:37,880 --> 01:47:40,390
Donc, après avoir sauvé mon dossier, laissez
moi aller de l'avant et de faire un prototype,

2164
01:47:40,390 --> 01:47:41,498
semble bon cette fois.

2165
01:47:41,498 --> 01:47:46,470
Dot slash, prototype, laissez-moi
aller de l'avant et taper un nom.

2166
01:47:46,470 --> 01:47:51,440
David, bonjour David, Zamila, bonjour
Zamila, et, en fait, maintenant il fonctionne.

2167
01:47:51,440 --> 01:47:55,200
>> Donc, l'ingrédient ici est que nous avons
fait une fonction personnalisée, comme une coutume

2168
01:47:55,200 --> 01:47:57,219
bloc de Scratch nous appeler.

2169
01:47:57,219 --> 01:48:00,010
Mais contrairement à Scratch où vous pouvez
il suffit de créer et commencer à l'utiliser,

2170
01:48:00,010 --> 01:48:02,330
maintenant, nous devons être un
peu plus pédant,

2171
01:48:02,330 --> 01:48:06,410
et effectivement former Clang
d'utiliser ou de s'y attendre.

2172
01:48:06,410 --> 01:48:12,140
Maintenant, en passant, pourquoi tout ce temps ont
nous avions été aveuglément sur la foi, y compris

2173
01:48:12,140 --> 01:48:15,170
CS50.h, et notamment la norme io.h?

2174
01:48:15,170 --> 01:48:18,190
>> Eh bien, il se trouve,
parmi quelques autres choses,

2175
01:48:18,190 --> 01:48:21,550
tout ce qui est dans les points h
fichiers, qui se trouvent être des fichiers.

2176
01:48:21,550 --> 01:48:23,460
Ils sont des fichiers d'en-tête, pour ainsi dire.

2177
01:48:23,460 --> 01:48:26,270
Ils sont toujours écrits en C. Mais
ils sont un type de fichier différent.

2178
01:48:26,270 --> 01:48:31,690
>> Pour l'instant, vous pouvez très bien supposer
que tout ce qui est à l'intérieur CS50.h

2179
01:48:31,690 --> 01:48:36,360
est des one-liners comme celui-ci, et non pas
pour les fonctions appelées Imprimer Nom,

2180
01:48:36,360 --> 01:48:39,840
mais pour Get String, Get
Float, et quelques autres.

2181
01:48:39,840 --> 01:48:44,510
Et il y a des prototypes semblables,
revêtements un, à l'intérieur de la norme io.h

2182
01:48:44,510 --> 01:48:49,241
pour printf, qui est maintenant en
ma propre fonction Imprimer Nom.

2183
01:48:49,241 --> 01:48:52,490
Donc, en d'autres termes, tout ce temps, nous avons
vient d'être aveuglément copiant et collant

2184
01:48:52,490 --> 01:48:54,780
inclure ce, inclure
que, ce qui se passe?

2185
01:48:54,780 --> 01:48:58,310
Ce sont juste un peu d'indices
à Clang à quelles fonctions

2186
01:48:58,310 --> 01:49:03,170
sont, en effet, mis en œuvre, tout simplement
ailleurs dans différents fichiers

2187
01:49:03,170 --> 01:49:05,440
ailleurs sur le système.

2188
01:49:05,440 --> 01:49:08,160
>> Nous avons donc mis en place le nom d'impression.

2189
01:49:08,160 --> 01:49:10,910
Il possède cet effet secondaire de
impression quelque chose sur l'écran.

2190
01:49:10,910 --> 01:49:13,170
Mais il ne fait
donnez-moi quelque chose en retour.

2191
01:49:13,170 --> 01:49:15,200
Comment allons-nous
mettre en oeuvre un programme qui

2192
01:49:15,200 --> 01:49:17,510
ne me remettre quelque chose en retour?

2193
01:49:17,510 --> 01:49:18,580
>> Eh bien, nous allons essayer cela.

2194
01:49:18,580 --> 01:49:24,360
Laissez-moi aller de l'avant et de mettre en œuvre
un return.c de fichier appelé

2195
01:49:24,360 --> 01:49:27,530
afin que nous puissions démontrer comment quelque chose
comme Get String, ou Get Int,

2196
01:49:27,530 --> 01:49:30,340
est en fait retourner
quelque chose en retour à l'utilisateur.

2197
01:49:30,340 --> 01:49:32,840
Allons de l'avant et de définir void main int.

2198
01:49:32,840 --> 01:49:36,230
>> Et, encore une fois, à l'avenir, nous allons
expliquer ce que int et ce vide

2199
01:49:36,230 --> 01:49:37,090
est en train de faire.

2200
01:49:37,090 --> 01:49:38,840
Mais pour aujourd'hui, nous allons
prendre pour acquis.

2201
01:49:38,840 --> 01:49:42,970
Je vais aller de l'avant et printf,
pour une bonne expérience utilisateur, x est.

2202
01:49:42,970 --> 01:49:47,360
Et puis je vais attendre la
utilisateur pour me donner x avec get int.

2203
01:49:47,360 --> 01:49:51,459
>> Et puis je vais aller de l'avant
et imprimer x au carré.

2204
01:49:51,459 --> 01:49:53,500
Alors, quand vous avez seulement un
clavier, les gens couramment

2205
01:49:53,500 --> 01:49:55,600
utiliser la petite carotte
symbole sur le clavier

2206
01:49:55,600 --> 01:49:58,330
pour représenter la puissance
, ou l'exposant.

2207
01:49:58,330 --> 01:50:01,960
Donc x au carré est présent i.

2208
01:50:01,960 --> 01:50:03,660
>> Et maintenant, je vais le faire.

2209
01:50:03,660 --> 01:50:06,940
Je ne pouvais tout simplement ce qui est do-- x
au carré? x au carré est x fois x.

2210
01:50:06,940 --> 01:50:09,690
>> Et nous avons fait un certain
Il y a longtemps déjà aujourd'hui.

2211
01:50:09,690 --> 01:50:11,730
Cela ne se sent pas comme
tout ce que beaucoup de progrès.

2212
01:50:11,730 --> 01:50:12,570
Vous savez quoi?

2213
01:50:12,570 --> 01:50:16,100
Nous allons tirer parti de certains de cette idée
depuis la dernière fois de l'abstraction.

2214
01:50:16,100 --> 01:50:19,080
>> Ne serait-il pas bien si
il y a une fonction appelée

2215
01:50:19,080 --> 01:50:21,460
carré qui fait exactement cela?

2216
01:50:21,460 --> 01:50:23,640
Il reste, à la fin de la
jour, fait la même mathématiques.

2217
01:50:23,640 --> 01:50:25,410
Résumé d'Mais laissez
loin de l'idée de la prise

2218
01:50:25,410 --> 01:50:28,280
un nombre multiplié par
une autre, et juste lui donner un nom,

2219
01:50:28,280 --> 01:50:30,360
comme carré de cette valeur.

2220
01:50:30,360 --> 01:50:32,560
>> Et, en d'autres termes,
C, nous allons créer une fonction

2221
01:50:32,560 --> 01:50:35,660
appelé carré qui fait exactement cela.

2222
01:50:35,660 --> 01:50:37,600
Il va être appelé carré.

2223
01:50:37,600 --> 01:50:38,790
Il va prendre un int.

2224
01:50:38,790 --> 01:50:40,820
Et nous allons tout va
appeler n, par défaut.

2225
01:50:40,820 --> 01:50:42,403
>> Mais nous pourrions l'appeler tout ce que nous voulons.

2226
01:50:42,403 --> 01:50:45,900
Et tout ce que ça va
faire, littéralement, est le retour

2227
01:50:45,900 --> 01:50:48,810
le résultat de n fois n.

2228
01:50:48,810 --> 01:50:51,980
Mais parce qu'il est
retourner quelque chose qui

2229
01:50:51,980 --> 01:50:56,690
est le mot-clé dans le pourpre, nous avons
jamais vu auparavant, je, sur la ligne 11,

2230
01:50:56,690 --> 01:50:58,410
ne peut pas simplement dire vide cette fois.

2231
01:50:58,410 --> 01:51:04,320
>> Void, dans l'exemple que nous venons de voir
plutôt du nom d'impression, signifie simplement,

2232
01:51:04,320 --> 01:51:05,190
faire quelque chose.

2233
01:51:05,190 --> 01:51:07,170
Mais ne me remettre pas quelque chose en retour.

2234
01:51:07,170 --> 01:51:09,790
Dans ce cas, je ne veux
pour revenir n fois n,

2235
01:51:09,790 --> 01:51:11,460
ou tout ce qui est, ce nombre.

2236
01:51:11,460 --> 01:51:15,460
>> Donc, je ne peux pas dire, hé, ordinateur,
Je reviens rien, nulle.

2237
01:51:15,460 --> 01:51:19,166
Il va revenir, par nature, un int.

2238
01:51:19,166 --> 01:51:20,790
Et voilà tout ce qui se passe ici.

2239
01:51:20,790 --> 01:51:23,070
>> L'entrée au carré
va être un int.

2240
01:51:23,070 --> 01:51:27,760
Et pour que nous puissions l'utiliser, il doit
avoir un nom, N. Il va à la sortie

2241
01:51:27,760 --> 01:51:29,240
un int qui n'a pas besoin d'un nom.

2242
01:51:29,240 --> 01:51:32,590
Nous pouvons laisser à principal, ou celui qui est
moi en utilisant de se rappeler cette valeur si nous

2243
01:51:32,590 --> 01:51:34,120
veulent avec sa propre variable.

2244
01:51:34,120 --> 01:51:36,230
>> Et, encore une fois, la seule nouvelle
mot-clé ici est de retour.

2245
01:51:36,230 --> 01:51:37,480
Et je fais juste un peu de maths.

2246
01:51:37,480 --> 01:51:44,825
Si je voulais vraiment être inutile,
Je pourrais dire produit int obtient n fois n.

2247
01:51:44,825 --> 01:51:47,170
>> Et puis, je pourrais dire, le produit de retour.

2248
01:51:47,170 --> 01:51:50,360
Mais, encore une fois, à mon point antérieur de
ce tout simplement pas être bon design--

2249
01:51:50,360 --> 01:51:53,060
comme, pourquoi introduire un nom,
un symbole, comme produit,

2250
01:51:53,060 --> 01:51:54,570
juste pour retourner immédiatement?

2251
01:51:54,570 --> 01:51:56,670
Il est un peu plus propre,
un peu plus serré, donc

2252
01:51:56,670 --> 01:52:02,380
de parler, juste pour dire le retour n fois
n, se débarrasser de cette ligne complètement.

2253
01:52:02,380 --> 01:52:05,860
>> Et il est juste moins de code à lire,
moins de possibilités d'erreurs.

2254
01:52:05,860 --> 01:52:08,180
Et nous allons voir si ce
fonctionne réellement maintenant.

2255
01:52:08,180 --> 01:52:12,380
Maintenant, je vais aller
avant et de faire retour.

2256
01:52:12,380 --> 01:52:14,460
>> Uh-oh, déclaration implicite de la fonction.

2257
01:52:14,460 --> 01:52:17,080
J'ai fait cette erreur avant, pas une grosse affaire.

2258
01:52:17,080 --> 01:52:21,950
Permettez-moi de taper, ou mettre en évidence et
copier, le même prototype de fonction exacte,

2259
01:52:21,950 --> 01:52:24,342
ou la signature, de la fonction ici.

2260
01:52:24,342 --> 01:52:25,800
Ou je pourrais déplacer toute la fonction.

2261
01:52:25,800 --> 01:52:26,841
>> Mais c'est un peu paresseux.

2262
01:52:26,841 --> 01:52:27,870
Donc, nous ne le ferons pas.

2263
01:52:27,870 --> 01:52:30,960
Maintenant, permettez-moi de retour
à nouveau, dot retour slash.

2264
01:52:30,960 --> 01:52:35,790
>> x est 2. x au carré est 4.
x est 3. x au carré est 9.

2265
01:52:35,790 --> 01:52:38,300
Et la fonction semble
maintenant travailler.

2266
01:52:38,300 --> 01:52:39,550
Alors, quelle est la différence ici?

2267
01:52:39,550 --> 01:52:45,520
J'ai une fonction qui est appelée carré,
dans ce cas, que je mets dans une entrée.

2268
01:52:45,520 --> 01:52:46,830
Et je reviens d'une sortie.

2269
01:52:46,830 --> 01:52:49,210
Et pourtant, précédemment, si
J'ouvre l'autre exemple

2270
01:52:49,210 --> 01:52:54,640
de plus tôt, ce qui
était appelé prototype.c,

2271
01:52:54,640 --> 01:52:57,770
J'ai eu le nom d'impression, qui
retourné vide, pour ainsi dire,

2272
01:52:57,770 --> 01:53:01,730
Ou il est revenu rien, et
avait tout simplement un effet secondaire.

2273
01:53:01,730 --> 01:53:03,230
>> Alors qu'est-ce qui se passe ici?

2274
01:53:03,230 --> 01:53:06,520
Eh bien, considérons la fonction
obtenir la chaîne pour un instant.

2275
01:53:06,520 --> 01:53:09,570
Nous avons utilisé la fonction
obtenir la chaîne de la façon suivante.

2276
01:53:09,570 --> 01:53:13,464
>> Nous avons eu une fonction get
chaîne, comme comprennent CS50.h,

2277
01:53:13,464 --> 01:53:19,624
inclure la norme io.h, int, principale, vide.

2278
01:53:19,624 --> 01:53:21,790
Et puis chaque fois que je l'ai
appelé chaîne get jusqu'à présent,

2279
01:53:21,790 --> 01:53:26,260
Je l'ai dit quelque chose comme, string s
obtient obtenir chaîne, car get string--

2280
01:53:26,260 --> 01:53:30,880
Appelons cette chaîne get get.c--
elle renvoie une chaîne qui je peux alors

2281
01:53:30,880 --> 01:53:35,050
utiliser, et dire bonjour, virgule,
pour cent s, backslash n, s.

2282
01:53:35,050 --> 01:53:38,660
>> Voici donc le même exemple,
vraiment, que nous avions auparavant.

2283
01:53:38,660 --> 01:53:40,920
Donc obtenir chaîne renvoie une valeur.

2284
01:53:40,920 --> 01:53:44,260
Mais il y a un instant, chaîne d'impression
ne retourne pas de valeur.

2285
01:53:44,260 --> 01:53:45,721
Il a tout simplement un effet secondaire.

2286
01:53:45,721 --> 01:53:47,220
Donc, ceci est une différence fondamentale.

2287
01:53:47,220 --> 01:53:49,710
Nous avons vu différents
types de fonctions maintenant,

2288
01:53:49,710 --> 01:53:52,490
dont certains sont rentrés
Les valeurs, dont certains ne le font pas.

2289
01:53:52,490 --> 01:53:54,890
Alors peut-être qu'il est une chaîne ou int, ou float.

2290
01:53:54,890 --> 01:53:56,480
Ou peut-être qu'il est juste vide.

2291
01:53:56,480 --> 01:53:58,710
>> Et la différence est
que ces fonctions

2292
01:53:58,710 --> 01:54:02,940
obtenir des données et retourner une valeur sont en fait
apporter quelque chose à la table,

2293
01:54:02,940 --> 01:54:04,110
pour ainsi dire.

2294
01:54:04,110 --> 01:54:06,710
Donc, nous allons aller de l'avant et
regarder un ensemble final

2295
01:54:06,710 --> 01:54:12,129
des exemples qui donne un sens, maintenant,
comment nous pourrions, en effet, abstrait mieux,

2296
01:54:12,129 --> 01:54:14,670
et mieux, et mieux, ou plus,
et plus, et plus, pour

2297
01:54:14,670 --> 01:54:16,810
à écrire, en fin de compte, un meilleur code.

2298
01:54:16,810 --> 01:54:19,860
Allons de l'avant, et dans l'esprit
Scratch, procédez comme suit.

2299
01:54:19,860 --> 01:54:24,700
>> Laissez-moi aller de l'avant et inclure
CS50.h et la norme io.h.

2300
01:54:24,700 --> 01:54:27,010
Laissez-moi aller de l'avant et de donner
moi un int, principale, vide.

2301
01:54:27,010 --> 01:54:30,380
Et laissez-moi aller de l'avant, appelle ce cough.c.

2302
01:54:30,380 --> 01:54:38,510
>> Et laissez-moi aller de l'avant et juste
comme Scratch, imprimez la toux / n.

2303
01:54:38,510 --> 01:54:40,170
Et je veux faire cela trois fois.

2304
01:54:40,170 --> 01:54:42,670
Je suis, bien sûr, tout va
copier et coller trois fois.

2305
01:54:42,670 --> 01:54:49,440
Je vais maintenant faire
Toux slash dot.

2306
01:54:49,440 --> 01:54:53,120
Allons me donner un peu plus d'espace
ici, Entrez, la toux, la toux, la toux.

2307
01:54:53,120 --> 01:54:56,970
>> Il y a, évidemment, déjà
possibilité d'amélioration.

2308
01:54:56,970 --> 01:54:58,679
Je l'ai copié et collé
quelques fois aujourd'hui.

2309
01:54:58,679 --> 01:55:01,261
Mais ce fut seulement alors je ne l'ai pas
avoir à taper autant de caractères.

2310
01:55:01,261 --> 01:55:03,250
J'ai changé encore ce
ces lignes de code sont.

2311
01:55:03,250 --> 01:55:07,240
>> Ces trois lignes sont identiques,
qui se sent paresseux et en effet est,

2312
01:55:07,240 --> 01:55:10,110
et est probablement pas la bonne approche.

2313
01:55:10,110 --> 01:55:14,029
Donc, avec ce que l'ingrédient
pourrions-nous améliorer ce code?

2314
01:55:14,029 --> 01:55:15,570
Nous ne devons pas copier et coller le code.

2315
01:55:15,570 --> 01:55:18,070
>> Et, en effet, chaque fois que vous vous sentez
vous copier-coller,

2316
01:55:18,070 --> 01:55:20,700
et même pas changer le code,
les chances sont qu'il ya une meilleure façon.

2317
01:55:20,700 --> 01:55:22,470
Et, en effet, il y a.

2318
01:55:22,470 --> 01:55:25,510
Laissez-moi aller de l'avant et faire une boucle,
même si la syntaxe peut-être pas

2319
01:55:25,510 --> 01:55:27,570
viennent naturellement encore.

2320
01:55:27,570 --> 01:55:32,494
>> Pour ce faire, trois fois, tout simplement
en faisant l'following--

2321
01:55:32,494 --> 01:55:34,160
et je sais cela de pratique.

2322
01:55:34,160 --> 01:55:35,810
Mais nous avons un certain nombre d'exemples maintenant.

2323
01:55:35,810 --> 01:55:37,950
Et vous verrez en ligne
références encore.

2324
01:55:37,950 --> 01:55:40,790
>> Ceci est la syntaxe sur la ligne 6, qui
un peu comme Scratch qui se répète

2325
01:55:40,790 --> 01:55:43,090
bloc, répéter les trois fois suivantes.

2326
01:55:43,090 --> 01:55:44,340
Il est un peu magique pour le moment.

2327
01:55:44,340 --> 01:55:46,050
Mais cela va obtenir plus,
et plus familier.

2328
01:55:46,050 --> 01:55:48,050
>> Et il va répéter
ligne de huit à trois reprises,

2329
01:55:48,050 --> 01:55:55,390
de sorte que si je re-compiler make toux,
dot slash toux, la toux, la toux, la toux.

2330
01:55:55,390 --> 01:55:57,030
Il fonctionne toujours de la même façon.

2331
01:55:57,030 --> 01:55:58,550
Donc, c'est tout beau et bon.

2332
01:55:58,550 --> 01:56:01,200
Mais ce n'est pas très abstraite.

2333
01:56:01,200 --> 01:56:02,371
>> Il est parfaitement correct.

2334
01:56:02,371 --> 01:56:04,370
Mais il se sent comme il
pourrait être l'occasion,

2335
01:56:04,370 --> 01:56:06,750
comme dans le monde
Scratch, au genre de début

2336
01:56:06,750 --> 01:56:10,530
d'ajouter une sémantique ici afin que
Je n'ai simplement pas une boucle,

2337
01:56:10,530 --> 01:56:12,867
et une fonction qui dit
toux, ou ne la toux.

2338
01:56:12,867 --> 01:56:13,450
Vous savez quoi?

2339
01:56:13,450 --> 01:56:15,620
Je vais essayer d'être un
peu plus frais que cela,

2340
01:56:15,620 --> 01:56:19,090
et en fait écrire une fonction qui
a certains effets secondaires, appeler la toux.

2341
01:56:19,090 --> 01:56:23,830
>> Et il ne prend pas d'entrée et
retourne pas de valeur en tant que sortie.

2342
01:56:23,830 --> 01:56:25,680
Mais vous savez ce qu'il fait?

2343
01:56:25,680 --> 01:56:32,370
Il fait this-- printf,
entre guillemets, toux.

2344
01:56:32,370 --> 01:56:35,380
>> Et maintenant ici, je vais
aller de l'avant et int,

2345
01:56:35,380 --> 01:56:39,070
i obtient zéro, i inférieur à 3, i plus plus.

2346
01:56:39,070 --> 01:56:42,770
Je vais pas faire printf, qui est
sans doute une implémentation de bas niveau

2347
01:56:42,770 --> 01:56:43,270
détail.

2348
01:56:43,270 --> 01:56:44,353
Je ne me soucie pas comment tousser.

2349
01:56:44,353 --> 01:56:46,240
Je veux juste utiliser la fonction de la toux.

2350
01:56:46,240 --> 01:56:47,840
Et je vais juste appeler la toux.

2351
01:56:47,840 --> 01:56:49,204
>> Maintenant, remarquez la dichotomie.

2352
01:56:49,204 --> 01:56:52,370
Lorsque vous appelez une fonction, si vous ne le faites pas
vouloir lui donner entrées, tout à fait bien.

2353
01:56:52,370 --> 01:56:54,780
Il suffit de faire paren ouvrir, fermer
paren, et vous avez terminé.

2354
01:56:54,780 --> 01:56:59,271
>> Lorsque vous définissez une fonction, ou
déclarer le prototype d'une fonction,

2355
01:56:59,271 --> 01:57:01,770
si vous savez à l'avance ce n'est pas
va prendre tous les arguments,

2356
01:57:01,770 --> 01:57:04,170
dire vide dans ces parenthèses là-bas.

2357
01:57:04,170 --> 01:57:08,660
Et cela fait certain que vous
ne sera pas accidentellement abuser.

2358
01:57:08,660 --> 01:57:10,020
Laissez-moi aller de l'avant et de faire la toux.

2359
01:57:10,020 --> 01:57:11,540
Et, bien sûr, je l'ai fait une erreur.

2360
01:57:11,540 --> 01:57:13,410
>> Zut, il n'y a que
déclaration implicite.

2361
01:57:13,410 --> 01:57:14,325
Mais ça va.

2362
01:57:14,325 --> 01:57:15,590
Il est une solution facile.

2363
01:57:15,590 --> 01:57:21,240
Je dois juste le prototype plus haut
dans mon dossier que je ne suis en fait l'utiliser.

2364
01:57:21,240 --> 01:57:23,070
>> Alors maintenant, permettez-moi de la toux à nouveau, agréable.

2365
01:57:23,070 --> 01:57:23,790
Maintenant ça marche.

2366
01:57:23,790 --> 01:57:25,930
Faire la toux, la toux, la toux, la toux.

2367
01:57:25,930 --> 01:57:28,930
Donc, vous pourriez penser que nous sommes vraiment
juste ingénierie sur ce problème.

2368
01:57:28,930 --> 01:57:29,763
Et, en effet, nous sommes.

2369
01:57:29,763 --> 01:57:31,870
Ce n'est pas un bon
candidat d'un programme

2370
01:57:31,870 --> 01:57:34,930
au moment de
refactoring, et faire ce qui est

2371
01:57:34,930 --> 01:57:38,645
appelée décomposition hiérarchique,
où vous prenez un peu de code, puis

2372
01:57:38,645 --> 01:57:41,790
vous genre de choses de facteurs, de sorte que
d'attribuer plus de sémantique pour eux,

2373
01:57:41,790 --> 01:57:43,930
et le réutiliser en fin de compte à plus long terme.

2374
01:57:43,930 --> 01:57:46,490
Mais il est un bloc de construction vers
des programmes plus sophistiqués

2375
01:57:46,490 --> 01:57:48,600
que nous allons commencer
écrit avant longtemps que

2376
01:57:48,600 --> 01:57:53,090
nous permet d'avoir le vocabulaire
avec lequel pour écrire un meilleur code.

2377
01:57:53,090 --> 01:57:55,920
Et, en effet, nous allons voir si nous
ne peut pas généraliser davantage.

2378
01:57:55,920 --> 01:58:00,984
>> Il semble un peu boiteux que je, principale,
à se soucier de cette bougresse boucle for,

2379
01:58:00,984 --> 01:58:02,400
et appeler encore et encore la toux.

2380
01:58:02,400 --> 01:58:06,050
Pourquoi ne puis-je dire à la toux,
s'il vous plaît tousser trois fois?

2381
01:58:06,050 --> 01:58:11,170
En d'autres termes, pourquoi je ne peux pas juste
apporter une contribution à tousser et à faire cela?

2382
01:58:11,170 --> 01:58:14,270
>> Pourquoi ne puis-je dire, en
la toux principale trois fois.

2383
01:58:14,270 --> 01:58:16,150
Et maintenant, cela est une sorte de magique.

2384
01:58:16,150 --> 01:58:17,540
Il est très itérative ici.

2385
01:58:17,540 --> 01:58:18,940
Et il est, en effet, une étape de bébé.

2386
01:58:18,940 --> 01:58:22,250
>> Mais la capacité à dire sur
ligne de huit, toux trois fois,

2387
01:58:22,250 --> 01:58:23,730
il est tellement plus lisible.

2388
01:58:23,730 --> 01:58:27,210
Et, plus, je ne dois pas savoir
ou de soin comment la toux est mis en œuvre.

2389
01:58:27,210 --> 01:58:29,460
Et, en effet, plus tard dans la
terme et pour les projets finaux,

2390
01:58:29,460 --> 01:58:32,150
si vous abordez un projet avec
un camarade de classe ou deux camarades de classe,

2391
01:58:32,150 --> 01:58:35,370
vous vous rendrez compte que vous allez
doivent, ou si vous voulez, diviser le travail.

2392
01:58:35,370 --> 01:58:37,650
>> Et vous allez vouloir décider
à l'avance, qui va faire quoi,

2393
01:58:37,650 --> 01:58:38,483
et dans lequel les pièces?

2394
01:58:38,483 --> 01:58:40,520
Et ne serait-il pas agréable
si vous, par exemple,

2395
01:58:40,520 --> 01:58:43,100
prendre en charge l'écriture principale, fait.

2396
01:58:43,100 --> 01:58:46,470
Et votre colocataire ou votre
partenaire plus généralement,

2397
01:58:46,470 --> 01:58:48,230
prend soin de mettre en œuvre la toux.

2398
01:58:48,230 --> 01:58:52,540
>> Et cette division, ceux-ci
murs de l'abstraction,

2399
01:58:52,540 --> 01:58:55,310
ou des couches d'abstraction si
vous, sont super puissant,

2400
01:58:55,310 --> 01:58:58,480
parce que surtout pour les plus grands,
plus de programmes et de systèmes complexes,

2401
01:58:58,480 --> 01:59:03,070
il permet à plusieurs personnes de construire
choses ensemble, et, finalement,

2402
01:59:03,070 --> 01:59:05,680
point leur travail ensemble de cette façon.

2403
01:59:05,680 --> 01:59:08,332
Mais, bien sûr, nous
besoin de fixer maintenant la toux.

2404
01:59:08,332 --> 01:59:10,290
Nous devons dire la toux
que, hé, vous savez quoi?

2405
01:59:10,290 --> 01:59:14,230
Vous allez avoir besoin de prendre un
input-- donc pas vide, mais int et maintenant.

2406
01:59:14,230 --> 01:59:18,170
Allons de l'avant et de mettre en
toux int. i obtient zéro.

2407
01:59:18,170 --> 01:59:19,890
>> i est inférieur à combien de fois.

2408
01:59:19,890 --> 01:59:21,550
Je l'ai dit trois avant.

2409
01:59:21,550 --> 01:59:23,420
Mais ce n'est pas ce que je veux.

2410
01:59:23,420 --> 01:59:28,520
Je veux tousser être généralisé à
soutenir un certain nombre d'itérations.

2411
01:59:28,520 --> 01:59:31,800
>> Donc, en effet, il est n que je veux,
quel que soit l'utilisateur me dit.

2412
01:59:31,800 --> 01:59:34,620
Maintenant, je peux aller de l'avant et dire imprimer la toux.

2413
01:59:34,620 --> 01:59:37,750
Et peu importe ce nombre
l'utilisateur passe,

2414
01:59:37,750 --> 01:59:39,890
J'itérer que de nombreuses fois.

2415
01:59:39,890 --> 01:59:42,160
>> Ainsi, à la fin de la journée,
programme est identique.

2416
01:59:42,160 --> 01:59:45,820
Mais remarquez tous ces trucs
pourrait même être dans un autre fichier.

2417
01:59:45,820 --> 01:59:48,620
En effet, je ne sais pas à la
instant comment printf est mis en œuvre.

2418
01:59:48,620 --> 01:59:50,980
>> Je ne sais pas pour le moment comment obtenir
chaîne, ou obtenir int, float ou obtenir

2419
01:59:50,980 --> 01:59:51,646
sont mises en oeuvre.

2420
01:59:51,646 --> 01:59:53,930
Et je ne veux pas
les voir sur mon écran.

2421
01:59:53,930 --> 01:59:58,320
Comme il est, je commence à se concentrer sur
mon programme, et non pas ces fonctions.

2422
01:59:58,320 --> 02:00:02,070
>> Et donc, en effet, dès que vous
commencer affacturage code comme ceci,

2423
02:00:02,070 --> 02:00:04,397
pourrions-nous déplacer même la toux
dans un fichier séparé?

2424
02:00:04,397 --> 02:00:05,730
Quelqu'un d'autre pourrait le mettre en œuvre.

2425
02:00:05,730 --> 02:00:09,810
Et vous et votre programme devenez
très beau, et très lisible,

2426
02:00:09,810 --> 02:00:13,830
sans doute, vraiment quatre
programme en ligne là.

2427
02:00:13,830 --> 02:00:16,510
>> Donc, nous allons aller de l'avant maintenant
et faire encore un changement.

2428
02:00:16,510 --> 02:00:19,180
Notez que mon prototype
doit changer en haut.

2429
02:00:19,180 --> 02:00:21,390
Alors permettez-moi de résoudre que tant
Je ne suis pas crié.

2430
02:00:21,390 --> 02:00:25,580
>> Faire la toux, permettez-moi de courir la toux, une fois
plus, toujours faire la même chose.

2431
02:00:25,580 --> 02:00:29,010
Mais maintenant, nous avons remarqué une
ingrédient pour une version finale.

2432
02:00:29,010 --> 02:00:29,940
Vous savez quoi?

2433
02:00:29,940 --> 02:00:32,040
Je ne veux pas de tousser juste, nécessairement.

2434
02:00:32,040 --> 02:00:33,802
Je veux avoir quelque chose de plus général.

2435
02:00:33,802 --> 02:00:34,510
Donc, vous savez quoi?

2436
02:00:34,510 --> 02:00:35,450
Je veux faire ça.

2437
02:00:35,450 --> 02:00:40,140
Je veux avoir, un peu comme Scratch
fait, un bloc de dire, mais pas seulement

2438
02:00:40,140 --> 02:00:41,680
dire quelque chose un certain nombre de fois.

2439
02:00:41,680 --> 02:00:44,510
Je veux dire une chaîne très spécifique.

2440
02:00:44,510 --> 02:00:46,850
Et, donc, je ne
voulez qu'il vient de dire la toux.

2441
02:00:46,850 --> 02:00:50,660
Je veux dire ce que
chaîne est passée dans.

2442
02:00:50,660 --> 02:00:52,960
>> Donc remarquer, j'ai généralisé
cette sorte que maintenant

2443
02:00:52,960 --> 02:00:56,110
dire se sent comme un bon nom
pour cela, comme Scratch,

2444
02:00:56,110 --> 02:00:58,530
prend deux arguments, à la différence Scratch.

2445
02:00:58,530 --> 02:00:59,570
La première est une chaîne.

2446
02:00:59,570 --> 02:01:00,300
L'un est un int.

2447
02:01:00,300 --> 02:01:01,130
>> Et je pourrais les passer.

2448
02:01:01,130 --> 02:01:03,713
Je viens un peu comme l'idée de
dire que la première chaîne, puis

2449
02:01:03,713 --> 02:01:04,940
combien de fois plus tard.

2450
02:01:04,940 --> 02:01:06,970
Void signifie qu'il reste
ne retourne rien.

2451
02:01:06,970 --> 02:01:09,428
Ce sont juste côté visuel
effets, comme avec [? Jordan,?]

2452
02:01:09,428 --> 02:01:11,240
un effet secondaire verbal de crier.

2453
02:01:11,240 --> 02:01:15,630
Il fait encore quelque chose n fois,
0 jusqu'à, mais pas égal à n.

2454
02:01:15,630 --> 02:01:17,540
Cela signifie que les temps n totaux.

2455
02:01:17,540 --> 02:01:19,540
Et puis juste imprimer
quelle que soit cette chaîne est.

2456
02:01:19,540 --> 02:01:22,060
Donc, je suis vraiment généralisé
cette ligne de code.

2457
02:01:22,060 --> 02:01:25,460
Alors maintenant, comment puis-je mettre en œuvre
la fonction de la toux?

2458
02:01:25,460 --> 02:01:28,520
>> Je peux faire la toux vide.

2459
02:01:28,520 --> 02:01:31,501
Et je peux encore prendre dans la façon
de nombreuses fois que vous voulez tousser.

2460
02:01:31,501 --> 02:01:32,250
Mais tu sais quoi?

2461
02:01:32,250 --> 02:01:34,240
Je peux maintenant dire punt.

2462
02:01:34,240 --> 02:01:39,540
>> Je peux appeler dire avec le
mot toux, en passant dans le n.

2463
02:01:39,540 --> 02:01:43,410
Et si je veux aussi mettre en œuvre,
juste pour le plaisir, une fonction d'éternuement,

2464
02:01:43,410 --> 02:01:45,290
Je peux éternuer un certain nombre de fois.

2465
02:01:45,290 --> 02:01:50,300
Et je peux continuer à réutiliser n, parce que
remarquer que m dans ce contexte ou étendue

2466
02:01:50,300 --> 02:01:52,470
existe uniquement dans cette fonction.

2467
02:01:52,470 --> 02:01:55,767
>> Et n dans ce contexte que
existe dans cette fonction ici.

2468
02:01:55,767 --> 02:01:57,600
Donc, nous allons y revenir
ces questions de portée.

2469
02:01:57,600 --> 02:02:04,160
Et ici, je vais juste dire,
Achoo, et ensuite n fois, point-virgule.

2470
02:02:04,160 --> 02:02:07,340
>> Et maintenant, je dois juste emprunter
ces fonctions signatures ici.

2471
02:02:07,340 --> 02:02:09,290
Donc, la toux est correcte.

2472
02:02:09,290 --> 02:02:13,090
éternuement Void est correct maintenant.

2473
02:02:13,090 --> 02:02:15,390
>> Et je reste juste besoin dire.

2474
02:02:15,390 --> 02:02:21,990
Donc, je vais dire, disons
chaîne s, int n, point-virgule.

2475
02:02:21,990 --> 02:02:25,010
Donc, je suis sur l'ingénierie de la
heck out de ce programme.

2476
02:02:25,010 --> 02:02:26,760
>> Et cela ne
nécessairement dire ceci est

2477
02:02:26,760 --> 02:02:29,343
ce que vous devez faire lors de l'écriture
même le plus simple des programmes.

2478
02:02:29,343 --> 02:02:32,280
Prenez quelque chose qui est évidemment
très simple, très court,

2479
02:02:32,280 --> 02:02:34,800
et re-mettre en œuvre
en utilisant beaucoup trop de code.

2480
02:02:34,800 --> 02:02:37,560
Mais vous allez vraiment voir, et
le temps de regarder en arrière sur ces exemples,

2481
02:02:37,560 --> 02:02:41,610
et de réaliser, oh, ce sont les étapes
nous avons pris réellement généraliser,

2482
02:02:41,610 --> 02:02:43,797
de tenir compte de quelque chose,
jusqu'à ce qu'à la fin de la journée

2483
02:02:43,797 --> 02:02:45,380
mon code est en fait assez raisonnable.

2484
02:02:45,380 --> 02:02:48,960
Parce que si je veux tousser trois
fois, puis éternuer trois fois,

2485
02:02:48,960 --> 02:02:53,420
Je vais simplement relancer cela,
programme faire la toux, et exécuter la toux.

2486
02:02:53,420 --> 02:02:56,620
Et j'ai trois toux
et trois éternue.

2487
02:02:56,620 --> 02:02:58,990
>> Et ceci est une base
paradigme, si vous voulez,

2488
02:02:58,990 --> 02:03:03,110
pour savoir comment nous pourrions aller sur
la mise en œuvre en fait un programme.

2489
02:03:03,110 --> 02:03:06,220
Mais nous allons voir tout à l'heure, il est
nous avons fait tout ce temps,

2490
02:03:06,220 --> 02:03:09,940
et ce que quelques-unes des pièces finales
sont derrière cette commande simple.

2491
02:03:09,940 --> 02:03:12,620
A la fin de la journée, nous avons
été en utilisant Clang comme notre compilateur.

2492
02:03:12,620 --> 02:03:14,494
Nous avons écrit la source
code, convertissant

2493
02:03:14,494 --> 02:03:15,820
via Clang en code machine.

2494
02:03:15,820 --> 02:03:18,540
>> Et nous avons utilisé Faites juste
pour faciliter nos frappes afin

2495
02:03:18,540 --> 02:03:23,740
que nous ne devons pas oublier
ces incantations de Clang lui-même.

2496
02:03:23,740 --> 02:03:25,640
Mais ce qui est réellement faire faire?

2497
02:03:25,640 --> 02:03:27,750
Et, à son tour, ce qui est
Clang en train de faire?

2498
02:03:27,750 --> 02:03:31,790
>> Il se trouve, bien que nous avons simplifié
la discussion d'aujourd'hui en disant:

2499
02:03:31,790 --> 02:03:36,090
vous prenez le code source, passez comme
entrée à un compilateur, qui vous donne

2500
02:03:36,090 --> 02:03:38,750
la sortie de la machine
code, se révèle-t-il de

2501
02:03:38,750 --> 02:03:40,420
à quelques pas différentes à l'intérieur il.

2502
02:03:40,420 --> 02:03:44,940
Et la compilation se trouve être le parapluie
terme pour tout un tas d'étapes.

2503
02:03:44,940 --> 02:03:46,970
Mais nous allons taquiner juste
ceci très rapidement.

2504
02:03:46,970 --> 02:03:51,070
>> Il se trouve que nous avons fait
plus de choses à chaque fois que je lance un programme,

2505
02:03:51,070 --> 02:03:53,990
ou chaque fois que je compile un programme aujourd'hui.

2506
02:03:53,990 --> 02:03:58,020
Donc, le prétraitement se réfère à
this-- quoi que ce soit dans un programme C,

2507
02:03:58,020 --> 02:04:01,720
comme nous le verrons encore et encore,
qui commence par ce symbole de hachage,

2508
02:04:01,720 --> 02:04:06,320
ou le symbole de hashtag ici, signifie
il est une directive de préprocesseur.

2509
02:04:06,320 --> 02:04:10,330
Cela signifie que, dans ce cas, hé
ordinateur, faire quelque chose avec ce fichier

2510
02:04:10,330 --> 02:04:12,430
avant de vous compilez mon propre code.

2511
02:04:12,430 --> 02:04:18,220
>> Dans ce cas, hachage include est,
essentiellement, la manière de C de dire,

2512
02:04:18,220 --> 02:04:22,325
hey ordinateur, allez obtenir le contenu
de CS50.h et collez-les ici.

2513
02:04:22,325 --> 02:04:25,170
Hey ordinateur, allez obtenir le
le contenu de la norme io.h,

2514
02:04:25,170 --> 02:04:27,690
où que ce soit sur la
disque dur, collez-le ici.

2515
02:04:27,690 --> 02:04:30,390
Donc, ces choses se produisent
première au cours du prétraitement.

2516
02:04:30,390 --> 02:04:31,880
>> Et Clang fait tout cela pour nous.

2517
02:04:31,880 --> 02:04:33,510
Et il le fait horriblement
rapide, vous faites même pas

2518
02:04:33,510 --> 02:04:35,000
voir quatre choses distinctes qui se passe.

2519
02:04:35,000 --> 02:04:37,100
Mais c'est la première telle étape.

2520
02:04:37,100 --> 02:04:38,560
>> Qu'est-ce qui se passe réellement à côté?

2521
02:04:38,560 --> 02:04:41,320
Eh bien, la prochaine officielle
étape est la compilation.

2522
02:04:41,320 --> 02:04:43,385
Et il se trouve que
compilation d'un programme

2523
02:04:43,385 --> 02:04:47,060
des moyens techniquement allant de
code source, les choses que nous avons

2524
02:04:47,060 --> 02:04:50,890
été écrit aujourd'hui, à quelque chose
appelé code assembleur, quelque chose

2525
02:04:50,890 --> 02:04:52,260
qui ressemble un peu différent.

2526
02:04:52,260 --> 02:04:54,050
>> Et, en fait, nous pouvons le voir très vite.

2527
02:04:54,050 --> 02:04:56,890
Permettez-moi de réellement entrer dans mon IDE.

2528
02:04:56,890 --> 02:05:01,050
Laissez-moi aller de l'avant et hello.c ouvert, qui
est le tout premier programme avec lequel nous

2529
02:05:01,050 --> 02:05:02,120
a commencé aujourd'hui.

2530
02:05:02,120 --> 02:05:07,130
Et laissez-moi aller de l'avant et d'exécuter un Clang
peu différemment, Clang-s, hello.c,

2531
02:05:07,130 --> 02:05:10,720
qui se passe réellement à
me donner un autre fichier hello.s.

2532
02:05:10,720 --> 02:05:13,330
>> Et nous le ferons probablement jamais
voir à nouveau ce genre de code.

2533
02:05:13,330 --> 02:05:16,030
Si vous prenez un niveau inférieur
classe de systèmes comme CS61,

2534
02:05:16,030 --> 02:05:17,920
vous verrez beaucoup plus
de ce genre de code.

2535
02:05:17,920 --> 02:05:20,020
Mais ceci est le langage d'assemblage.

2536
02:05:20,020 --> 02:05:25,050
Ceci est X86 langage d'assemblage
que l'unité centrale de traitement qui est sous-jacente

2537
02:05:25,050 --> 02:05:27,460
CS50 IDE comprend réellement.

2538
02:05:27,460 --> 02:05:30,060
>> Et cryptique comme il le fait
regardez, il est quelque chose

2539
02:05:30,060 --> 02:05:32,180
l'ordinateur comprend assez bien.

2540
02:05:32,180 --> 02:05:33,790
Sous q, ceci est une soustraction.

2541
02:05:33,790 --> 02:05:34,660
Il y a des mouvements.

2542
02:05:34,660 --> 02:05:38,730
>> Il y a d'appeler des fonctions ici,
x oring, un mouvement, un complément, un pop,

2543
02:05:38,730 --> 02:05:39,430
un retour.

2544
02:05:39,430 --> 02:05:41,850
Donc, il y a quelques très
instructions de bas niveau

2545
02:05:41,850 --> 02:05:44,280
que les processeurs comprennent que
J'y ai fait allusion plus tôt.

2546
02:05:44,280 --> 02:05:46,100
Voilà ce que Intel Inside.

2547
02:05:46,100 --> 02:05:48,030
>> Il existe des modèles de
zéros et de uns que

2548
02:05:48,030 --> 02:05:54,800
la carte à ces arcanely rédigé, mais
un peu bien nommé, des instructions,

2549
02:05:54,800 --> 02:05:55,780
pour ainsi dire.

2550
02:05:55,780 --> 02:05:57,780
Voilà ce qui arrive quand
vous compilez votre code.

2551
02:05:57,780 --> 02:06:01,560
Vous obtenez l'assemblage
langue hors de lui, qui

2552
02:06:01,560 --> 02:06:07,680
signifie la troisième étape consiste à assembler
que le code d'assemblage en fin de compte,

2553
02:06:07,680 --> 02:06:12,080
machines zéros et des uns, et non pas les code--
texte que nous venons de voir il y a un instant.

2554
02:06:12,080 --> 02:06:16,370
>> Donc, pré-traitement ne qui trouvent
et remplacer, et quelques autres choses.

2555
02:06:16,370 --> 02:06:19,430
Compiler prend source
le code de C, le code source

2556
02:06:19,430 --> 02:06:21,980
que nous avons écrit, à l'assemblage
Code que nous venons jeta un regard.

2557
02:06:21,980 --> 02:06:25,170
Assemblage prend cette assemblée
code zéros et des uns

2558
02:06:25,170 --> 02:06:27,680
que le CPU va vraiment
comprendre à la fin de la journée.

2559
02:06:27,680 --> 02:06:30,630
Et la liaison est la dernière étape
cela se produit pour us-- à nouveau,

2560
02:06:30,630 --> 02:06:32,830
si vite que nous ne le faisons pas même
notice-- qui dit,

2561
02:06:32,830 --> 02:06:35,460
hey ordinateur, prendre toutes
les zéros et ceux qui

2562
02:06:35,460 --> 02:06:39,750
le résultat de la compilation du code de David,
et sa fonction principale dans ce cas.

2563
02:06:39,750 --> 02:06:42,160
>> Et hey ordinateur, aller chercher
tous les zéros et

2564
02:06:42,160 --> 02:06:45,180
que le personnel a écrit CS50
à l'intérieur de la bibliothèque de CS50.

2565
02:06:45,180 --> 02:06:46,440
Mélanger ceux avec David.

2566
02:06:46,440 --> 02:06:49,648
Et hé ordinateur, allez obtenir tous les zéros
et ceux que quelqu'un d'autre a écrit années

2567
02:06:49,648 --> 02:06:50,470
Il y a pour printf.

2568
02:06:50,470 --> 02:06:52,880
Et d'ajouter ceux dans le
chose ensemble, de sorte que nous avons

2569
02:06:52,880 --> 02:06:55,870
obtenu mes zéros et des uns, la
les zéros et les uns du personnel CS50,

2570
02:06:55,870 --> 02:06:58,370
les zéros printf et ceux,
et tout ce que nous utilisons.

2571
02:06:58,370 --> 02:07:03,410
>> Ils ont tous se combiner en une seule
programme appelé, dans ce cas, bonjour.

2572
02:07:03,410 --> 02:07:06,141
Donc désormais, nous allons tout simplement
utiliser le mot compilation.

2573
02:07:06,141 --> 02:07:09,390
Et nous prendrons pour acquis que lorsque
nous disons, compiler votre programme, cela signifie,

2574
02:07:09,390 --> 02:07:11,849
hey faire le pré-traitement,
l'assemblage et la liaison.

2575
02:07:11,849 --> 02:07:14,890
Mais il y a effectivement quelques trucs juteux
passe là-bas sous le capot.

2576
02:07:14,890 --> 02:07:16,723
Et surtout si vous
obtenir curieux un certain temps,

2577
02:07:16,723 --> 02:07:18,900
vous pouvez commencer à piquer
autour de ce niveau inférieur.

2578
02:07:18,900 --> 02:07:22,660
Mais pour l'instant, se rendre compte que
parmi les plats à emporter pour aujourd'hui

2579
02:07:22,660 --> 02:07:26,420
sont tout simplement
début d'un processus,

2580
02:07:26,420 --> 02:07:29,700
de se familiariser avec
quelque chose comme bonjour monde.

2581
02:07:29,700 --> 02:07:32,575
En effet, la plupart de ce que nous avons fait aujourd'hui
ne sera certainement pas sombrer dans super rapide.

2582
02:07:32,575 --> 02:07:34,491
Et il faudra un certain
le temps, et une certaine pratique.

2583
02:07:34,491 --> 02:07:36,864
Et les chances sont, vous triez
de vouloir frapper votre clavier

2584
02:07:36,864 --> 02:07:37,780
ou crier à l'écran.

2585
02:07:37,780 --> 02:07:38,880
Et tout cela est OK.

2586
02:07:38,880 --> 02:07:41,320
Bien, peut-être essayer de ne pas
le faire dans la bibliothèque tellement.

2587
02:07:41,320 --> 02:07:43,820
>> Et en fin de compte, vous aurez
être en mesure cependant, pour commencer

2588
02:07:43,820 --> 02:07:47,580
voir les modèles, aussi bien dans un bon code
que vous avez écrit et erreurs

2589
02:07:47,580 --> 02:07:48,370
que vous avez fait.

2590
02:07:48,370 --> 02:07:51,965
Et tout comme le processus de
devient un TF ou CA est comme,

2591
02:07:51,965 --> 02:07:54,590
vous allez commencer à aller mieux et
mieux de voir ces modèles,

2592
02:07:54,590 --> 02:07:56,774
et juste la résolution de votre
en fin de compte des problèmes propres.

2593
02:07:56,774 --> 02:07:59,940
En attendant, il y aura beaucoup
nous vous prêter assistance, et vous obtenez

2594
02:07:59,940 --> 02:08:00,481
à travers cela.

2595
02:08:00,481 --> 02:08:02,450
Et dans les comptes-rendus
pour tous les problèmes

2596
02:08:02,450 --> 02:08:04,366
vous serez guidé à travers
toutes les commandes

2597
02:08:04,366 --> 02:08:08,330
que je sais certainement de
beaucoup de pratique maintenant,

2598
02:08:08,330 --> 02:08:10,380
mais pourrait avoir volé
dessus de la tête pour l'instant.

2599
02:08:10,380 --> 02:08:11,580
Et c'est tout à fait bien.

2600
02:08:11,580 --> 02:08:14,230
>> Mais, en fin de compte, vous allez
pour commencer à voir des tendances émergent.

2601
02:08:14,230 --> 02:08:17,260
Et une fois que vous avez passé tous les
détails stupides, comme entre parenthèses,

2602
02:08:17,260 --> 02:08:19,710
et des accolades et des points-virgules,
et les choses, franchement,

2603
02:08:19,710 --> 02:08:22,360
ce n'est pas du tout
intellectuellement intéressant.

2604
02:08:22,360 --> 02:08:25,690
Et il est pas l'objectif de
prendre une classe d'introduction.

2605
02:08:25,690 --> 02:08:27,410
Ce sont les idées qui vont à la matière.

2606
02:08:27,410 --> 02:08:29,659
>> Ce sont les boucles, et
les conditions et les fonctions,

2607
02:08:29,659 --> 02:08:33,552
et plus puissamment l'abstraction,
et l'affacturage de code,

2608
02:08:33,552 --> 02:08:36,510
et la bonne conception, et le bon
le style, et, finalement, l'exactitude

2609
02:08:36,510 --> 02:08:40,330
de votre code, qui est en fin de compte
aller à la matière le plus.

2610
02:08:40,330 --> 02:08:43,925
Donc, la semaine prochaine, nous allons prendre ces
idées que nous avons vu la première fois en Scratch

2611
02:08:43,925 --> 02:08:45,800
et ont maintenant traduit
C. Et nous allons commencer

2612
02:08:45,800 --> 02:08:48,740
à introduire le premier de la
monde réel les domaines de cours.

2613
02:08:48,740 --> 02:08:53,140
>> Nous allons nous concentrer sur le monde de la sécurité,
et la cryptographie plus spécifiquement,

2614
02:08:53,140 --> 02:08:54,980
l'art de brouiller l'information.

2615
02:08:54,980 --> 02:08:57,000
Et parmi les premiers
problèmes vous-même

2616
02:08:57,000 --> 02:08:59,840
se rendre à écrire au delà
en jouant avec une partie de la syntaxe

2617
02:08:59,840 --> 02:09:02,880
et la résolution de certains logique
problèmes, en fin de compte avant longtemps,

2618
02:09:02,880 --> 02:09:06,960
est de brouiller effectivement, ou chiffrer,
et, finalement, décrypter les informations.

2619
02:09:06,960 --> 02:09:09,470
Et tout ce que nous avons fait
aujourd'hui, sera assez faible

2620
02:09:09,470 --> 02:09:12,190
niveau, va tout simplement pour permettre
nous prenons un, et un,

2621
02:09:12,190 --> 02:09:16,550
et une étape de plus vers ci-dessus
écrit encore le code le plus intéressant.

2622
02:09:16,550 --> 02:09:18,050
>> Donc, plus sur que la semaine prochaine.

2623
02:09:18,050 --> 02:09:20,834

2624
02:09:20,834 --> 02:09:21,762
>> [LECTURE VIDÉO]

2625
02:09:21,762 --> 02:09:22,690

2626
02:09:22,690 --> 02:09:25,006
>> -Quel Pouvez-vous me dire au sujet
la dernière fois que vous l'avez vu?

2627
02:09:25,006 --> 02:09:29,041

2628
02:09:29,041 --> 02:09:30,040
-Qu'est Ce que je peux dire, vraiment?

2629
02:09:30,040 --> 02:09:33,500

2630
02:09:33,500 --> 02:09:38,340
Je veux dire, il était comme tout autre
répétition de pré-production,

2631
02:09:38,340 --> 02:09:43,510
sauf qu'il y avait quelque chose qu'il a dit
à la fin qui a collé avec moi.

2632
02:09:43,510 --> 02:09:47,810

2633
02:09:47,810 --> 02:09:49,640
>> -Ce Était CS50.

2634
02:09:49,640 --> 02:09:52,440

2635
02:09:52,440 --> 02:09:55,190
>> -C'est Une coupe tout le monde,
excellent travail sur la répétition.

2636
02:09:55,190 --> 02:09:56,070
>> le déjeuner de -Que?

2637
02:09:56,070 --> 02:09:57,986
>> -Oui, Vous et je peux
prendre un sandwich dans un peu.

2638
02:09:57,986 --> 02:10:01,380
Permettez-moi de reprendre avec
David très rapidement.

2639
02:10:01,380 --> 02:10:02,160
David?

2640
02:10:02,160 --> 02:10:04,260
David?

2641
02:10:04,260 --> 02:10:06,110
>> [FIN LECTURE]

