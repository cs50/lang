[MUSICのPLAYING] DAVID J.マラン：すべての権利、これはCS50です。 そしてこれは1週間です。 だから、0週目でその最後の時間を思い出します 我々は、計算の考え方に焦点を当てました。 そして、我々はそれからに移行しました スクラッチ、グラフィカルプログラミング 私たちの友人から言語 MITのメディアラボで。 

そして、スクラッチで、我々は探検でした 機能、および条件などのアイデア、 偶数とループ、変数、 イベント、スレッド、およびより多くの。 そして今日、私たちはするつもりです これらのアイデアを使用し続けます、 本当にためにそれらを取ります 付与されたが、それらを翻訳 C.今として知られている他の言語に、 Cは、より伝統的な言語です。 これは、より低いレベルです 言語、可能ならば。 

それは純粋なテキストです。 だから一見、それはです すべてむしろ不可解見に行きます あなたは以前にプログラムされたことがない場合。 我々は、必要があるとしています セミコロン、括弧、 そして、中括弧、およびより多くの。 しかし、それさえ実現 構文は次のとおりですが、 少し不慣れに見えることを約 あなたのほとんどに、その過ぎ参照してください。 やアイデアを参照してみてください それは、確かに、おなじみの、 ここでは週に1どのような理由 我々は、比較することです行うことから始めましょう 当初、C.対スクラッチ 

そのように、例えば、そのときに我々リコール 我々のプログラムの最初の実装 最後の時間、私たちは見てのブロックを持っていました this--ときのような小さなもの 緑の旗をクリックし、次に我々が持っていました その下の1以上のパズルのピース、 この場合には、Hello Worldの、と言います。 だから、確かに、スクラッチで、 私は緑色の旗をクリックしたとき そう、私のプログラムを実行します これらは、話すこと 実行されるブロック、または実行。 そして、具体的には、スクラッチ こんにちは、世界、と述べました。 

今、私は指定されている可能性が ここでは異なる言葉。 しかし、我々は確かに、その多くが表示されます 確かにこれらのblocks--との、 C言語で多くのfunctions--をすることができます パラメータ化またはカスタマイズ 異なるものを行います。 実際には、我々の場合C言語で 今、変換したいです、 このスクラッチプログラム この他の言語に、 我々は書くつもりです このような少し何か。 

確かに、いくつかのなじみのない存在であります そこ構文ほとんどの場合、int型、 括弧、ボイド。 しかしprintf--も、あなたはでしょうが それだけで印刷になると思います。 しかし、印刷は印刷を意味します 我々はすぐにわかりますように、フォーマットされています。 これは文字通り、印刷されます 画面に何でも 、それらの括弧の内側にあります もちろん、この場合には、ハロー世界です。 

しかし、あなたはいくつかの他のことに気づくでしょう 構文、いくつかの二重引用符、 その末尾に括弧、 セミコロンなどが挙げられます。 だから、オーバーヘッドのビットがあります、 いわば、両方の認知します そして、文法的に、我々が行っていること ずっと前に覚えておく必要があります。 しかし、実際にそれを実現 これはあなたに飛び出すを開始します。 

実際には、のは、その1に焦点を当ててみましょう 関数は、この場合、specifically-- こんにちは世界を言います。 だから関数であると言います。 こんにちは、世界はそのパラメータであり、 または引数、そのカスタマイズ。 

そして、Cでの等価性だけです ここでは、この1行になるだろう、 printf関数は、たとえば、に相当するものであるときは 二重引用符で囲まれた文字列、ハロー 世界は、当然のことながら、同等です そこに白いボックスに何を。 そして、少しかかわらず、バックスラッシュnを、 不思議と最初から存在しません、 単に私たちはよ効果を持ってしようとしています 私のMacまたはPCのように、コンピュータに表示、 ちょうど移動 次の行にカーソル。 それは打つようなものです キーボードのEnter。 

だから私たちはずっと前にそれを再度表示されます。 しかし、最初のは、このを見てみましょう ループの場合の他の例。 私たちは、前回この永遠にループしていました パズルのピースのシリーズでした それは文字通り何かをしました この場合にはforever--、 世界こんにちは、世界こんにちは、と言います、 世界こんにちは、世界こんにちは。 だから、設計によって無限ループです。 

Cでは、私たちはこれを実装したい場合 同じアイデアは、我々は単純にこれを行う可能性があります。 今真一方、ハローprintfのworld-- しばらく、ちょうど意味的に、種類の やっての考えを想起させます 何か再び、そして再び、そして再び、 そしてどのくらいか？ まあ、true--リコールその 真のは、ちょうど上または1です。 

そして、真のは、常に、もちろん、本当です。 だから、無意味のようなものです ちょうど真と言って声明。 しかし、確かに、これは意図的であり、 真がちょうど常に真である場合ので、 真はちょうど意味している間よりも、 少し間接的であれば、 次のコード行こと これらの中括弧の間にあります もう一度、再度実行する必要があり、 そして再び、実際に停止することはありません。 

しかし、あなたが望むならば、あなたの 私たちのように、停止するループ 以下のようなもので最後の時間をしました これは、次の50回繰り返し C言語で、私たちは何で同じことを行うことができます キーワードをloop--を呼びかけ しばらく、しかしためのものではありません。 そして、我々はここでいくつかの新しい構文を持って、 int型で私は、私が50未満、0に等しいです 私は++します。 そして、我々は戻ってそれに来ます。 どのように我々はだろうが、これは単にです スクラッチ・ブロックのセットを変換 符号のCラインのセットです。 

一方、変数を考慮してください。 そして、実際には、我々だけ 一瞬前に見ました。 そして、スクラッチの場合には、我々の場合 私と呼ばれる変数を宣言したかったです iは整数、ちょうど数であるため、 そして、我々はいくつかの値に設定したいです、 私たちは、このオレンジ色を使用します ブロックhere-- iが0に設定してください。 

そして、私たちは今日見るだろうと 超えて、ちょうど先週のように、 プログラマはほとんど常に行います 本当に、ゼロからカウントを開始 慣例により。 しかし、また、リコールの理由 バイナリの議論、 最小数のことができます。 任意のビット数で表します ちょうど0そのものになるだろう。 そして、私たちは一般的に開始します 0にしても私達の変数を初期化します。 

そして、C言語で同じことを行うには、 我々はint型を言おうとしています 整数のための、私だけの慣例により。 私は、この変数と呼ばれている可能性が 私が欲しいものは、単にスクラッチで好きです。 そして、0だけ割り当てに等しいです 右から値0 変数に格納します、または 左側の存在貯蔵容器、。 そして、セミコロン我々はsee--ますように 我々はこれらのalready--のいくつかを見てきました ちょうど思考の終わりを意味します。 何かを行うに進みます 続く行に。 

さて、どのようなブール式は？ スクラッチでそれを思い出し、 これらは表現しました いずれかの真であること またはfalse--質問、 本当に、trueまたはfalseのいずれかであること。 だから、スクラッチの場合、我々はかもしれません このような単純な質問をし、 iが50未満ですか？ だから私は、再び、整数です。 多分、我々はそれを使用しています スクラッチプログラムで スコアを追跡するために またはそのような何か。 ここではスクラッチでだからこの構文 ちょうど私が50未満である、ことを意味？ まあ、ありがたいことに、何かがあります C.が簡単で翻訳し、 これは、私たちは私がそれほど単純に言うだろう 50よりも、使い慣れたキーを使用して、 キーボードの。 

一方、あなたがしたい場合 、より一般的な何かを言います ここで、各ような、よく、yよりもX以下であります xとyの自身の変数がありますか？ 私たちは同じことを行うことができます Cには、あまりにも長い間、私たちはきたように すでにこれらの変数を作成しました。 そして、私たちはどのように表示されます 前に長いことを行います。 私たちは、単純にyよりxが小さいと言うでしょう。 

だから、に開始しています いくつかの類似点を参照してください。 作られ、それらの人々 スクラッチは確かにありま​​した これらの基本的ないくつかのアイデアに触発さ。 そして、あなたは、この種のを見ることができます 多くのlanguages​​--内の構文 だけではなく、ない傷 ちょうどCが、Pythonの、 そして、JavaScript、および まだ他の言語。 

のは、別の構造体を考えてみましょう C、条件の概念から、 条件付きで何かをします。 何かが真である場合、これを行います。 何か他のものがtrueの場合、それを行います。 これは、プログラミングの一種です 道路の分岐点に相当します。 多分それは、双方向のフォークです、 三方フォーク、以上。 そしてスクラッチで、我々が持っているかもしれません このようなものを見たこと。 

したがって、この1は大きな一つです。 しかし、相対を考えます ロジックのシンプルさ。 xがyよりも小さい場合には、xが小さくなると言います yより、xがyよりも大きい他の場合には、 その後、xがyよりも大きいと言います。 その後、論理的に、もし あなたがスクラッチに戻って考えます またはちょうどあなた自身の人間の直感、 よく、xがyより大きくない場合、そしてx その後もちろん、Y以上であります xがyに等しいことになるだろう。 この場合は、入れ子にすることで、だから、 それらのスクラッチ・ブロック、 我々は3を達成することができます 道路の道フォーク？ 

一方、我々がしたい場合は それは間違いなく、C言語でそれを行います 少なくとも少しsimpler--に見えます あなたは構文に慣れる回。 xがyよりも小さい場合、 printf関数xがyよりも小さいです。 他xがyよりも大きい場合、 printfのxはyよりも大きいです。 エルスのprintf xは-Y-に等しいと、 再び、これらのバックスラッシュでちょうど終わります これらの新しい行のため、もしので 実際にこの種のプログラムを実行しました それだけで移動します カーソル最終的に 画面の次の行に。 

さて、その間スクラッチは、他のを持っていました 唯一のより洗練された機能、 そのうちのいくつかは我々がしようとしています 最初はCの世界に上に移動 その一つでした スクラッチ内のリストと呼ばれます。 そして、これは特別なものでした 変数の型もの あなたは複数のものを保存することができ 戻ってそれで、背中合わせにするために、バックアップします。 

Cでは、それは持っていません リスト、それ自体が、何か より一般的であること 我々はよものの、アレイと呼ばれます この後学期に戻ってきます 何かを見に リスト、または実際にリンクされたリストと呼ばれます。 しかし今のところ、最も近いです 私たちのためにC言語で同等 何かになるだろう 配列と呼ばれます。 そして、配列は単純です 変数の特殊なタイプ それは、あなたがデータを保存することができます バック、背中合わせにするために、バックアップします。 

そして、確かに、スクラッチで、 私たちは、アクセスしたい場合 配列の最初の要素や list--と私はそれを呼び出すつもりです、 大会、ARGV、引数によって ベクトルが、よりその上に長い前。 私は最初の要素を取得したい場合 ARGVの、スクラッチの世界では あなたが実際に一般的に行います 1からカウントを開始します。 

そして私はARGVの項目1を得る可能性があります。 それはMITの実装方法だけです リストの概念。 しかし、C言語で、私はするつもりです もっと単純に言う、ARGV、 私の名前、再びこれは list--またはクリアされるように、配列。 そして、私が最初にしたい場合 要素は、私が行きますよ あなた角括弧を使用するには 多くの場合、キーボードの下に使用されない場合があります。 

しかし、0がちょうどいい、私に最初に取得します。 だから機会にとなど 時間が経過し、我々が行っています これらの二分法を見ることが開始します スクラッチとCの間、 これによりスクラッチは1を使用しています。 C言語で私たちはここに0を使用します。 しかし、あなたはすぐに表示されます あなたが理解すれば その各言語の基礎、 これらの事はすべての多くを得るために開始します 練習と実践を通しておなじみ。 

それでは、実際にプログラムを今すぐ見てみましょう。 ここに私たちのCの最初のものでなければなりません 完全なプログラムのソースコード。 そして、プログラムは、我々が行っています 検討のために提供します 同等なものです その先にスクラッチピースへ。 

だからここでは、我々は何を持っています 間違いなく最も簡単なCプログラム あなたはそれを書くことができます 実際に何かを行います。 今、私たちは過去を見ていきます、 今のところ、含まれています、 標準io.h、およびこれらの角度 ブラケット、およびint型、及びボイド、 そして、中括弧、などが挙げられます。 

そして、ちょうどに集中しましょう 少なくとも直感的にどのような、 すでにあなたに飛び出す可能性があります。 実際には、主に、私はしないでください 必ずしもこれが何であるかを知っています、 しかし、スクラッチなどの多くが持っていたときに 緑色のフラグがパズルのピースをクリックし、 そのようにプログラミング言語としてCを行います コー​​ドの主な部分を持っています デフォルトで実行されます。そして、確かに、 文字通り、メインと呼ばれるようになるだろう。 

そう主な機能です。 そして、それは存在する特殊機能です C言語でプログラムを実行するときに、 それはによって実行されることを主です デフォルト。スクラッチの世界では、 それはときにグリーンフラッグ通常ました デフォルトでは動作し得たことをクリックしました。 

一方、我々は前にこれを見てきました、 printf関数または印刷フォーマットされ、それはです に付属している機能になるだろう C、他人の全体の束と一緒に、 時間と時間からその意志 再び、正確に行うために、 その名の通り、何かを印刷します。 私たちは、印刷したいですか？ まあ、我々はそれを参照してくださいよ 囲み文字によって these--ハローワールドのような、 バックスラッシュnは二重引用符で、 我々は正確にprintf関数を伝えることができます 画面上に何を印刷します。 

しかし、行うために、 つまり、我々は、残念ながら 何かをする必要があります 私たち人間にはすでに謎めきました、 しかし、少なくともそれはややreadable--です シャープは、標準io.h、int型を含みます、 メイン、ボイド、printfの、魔法のすべて 私たちはただ、画面で見た呪文。 しかし、我々は実際に持っています さらにより難解に行きます。 私たちは、最初のコードを変換する必要があります 我々はマシンコードに記述すること。 そして、先週からリコールマシンという、 少なくとも私たちがここで知っているもの、 一日の終わりに 0と1を理解しています。 

そして、私の神、私たちはこれらを書かなければならなかった場合 実際にプログラムに0と1、 それは非常に、非常に迅速だろう 何から楽しみを取ります。 しかし、それは、最後の週、判明します その0と1のこれらのパターン ただ特別な意味を持っています。 特定の文脈においては、 彼らは数字を意味するかもしれません。 

いくつかの文脈では、彼らが意味するかもしれません 文字、または色、または任意の数 そこの際に他の抽象化。 しかし、コンピュータに搭載されているだけのように CPU、中央処理装置、 またはお使いのコンピュータの内部頭脳。 これは通常、インテルの それだから、内部 最大の企業の1 それは、コンピュータ用のCPUを作ります。 

さて、IntelのCPUとその他 単に事前に決定しました そのゼロの特定のパターンと ものは特定の事柄を意味するものとします。 0と1の特定のパターン 、画面に印刷このことを意味します、 またはこれら2つの数値を追加したり、 これら2つの数値を減算し、 またはからのデータのこの部分を移動 こちらに私のコンピュータのメモリ、 または他の非常に低レベルの任意の数の しかし、最終的に有用な操作。 しかし、ありがたいことに、私たち人間は進んでいません このレベルの詳細を知る必要があります。 確かに、ちょうど最後の時間のように、どこ 再び抽象化、そして再び、そして再び、 非常に低いレベルから建物 0と1のようなプリミティブ より高いレベルの概念に 数字、文字など、 そして、色、そしてより多くの、 私たちは、プログラマとして缶 の肩の上に立ちます 私たちの前に来た他の人 および他のそのソフトウェアを使用します 人々はus--前に書かれています すなわち、プログラムはコンパイラと呼ばれます。 

Cは、その言語であります 通常はコンパイルされ、 から変換を意味しています マシンコードのソースコード。 特に、これが意味 あなたがソースを持っている場合ということです あなた自身がすぐに我々のように、記述するコード 画面上に一瞬であろう、 そしてあなたはそれを変換したいです 最終的にマシンにcode-- これらの0と1という お使いのMacまたはお使いのPCのみ あなたが最初に持っていますunderstands-- 以下のように、そのソースコードを供給する 特別に入力します プログラムは、コンパイラと呼ばれます、 我々の出力 参照しなければならないマシンコードです。 そして、確かに、最後の時間は、我々が話をしました 本当に、一日の終わりに、約、 問題解決。 あなたが入力を持っています。 そして、あなたは出力を持っています。 そして、あなたはいくつかの種類を持っています 真ん中のアルゴリズムの。 

アルゴリズムは、確実にすることができます ソフトウェアで実装、 我々は先週擬似コードで見たように 私たちは実際のコードで表示されますように 今週。 だからコンパイラ本当にただ 内部アルゴリズムのセットを持っています それをどのように知っています 特別なキーワードを変換し、 メイン、およびprintfのような、 その他、我々だけ ゼロのパターンに見て、 ものの内部インテルと他のCPU 実際に理解しています。 だから我々はこれをどのように行うのですか？ どこでコンパイラを得るのですか？ 

ここで私たちのほとんどは、MacまたはPCを持っています。 そして、あなたは、Mac OSを実行している、またはしています Windows、またはLinux、またはSolaris、 または他の任意の数 オペレーティングシステム。 そして、確かに、我々は可能性 ウェブ上に出て行きます そして、コンパイラをダウンロード お使いのMacまたはお使いのPCのための 特定のオペレーティングシステム用の。 しかし、我々はすべての上だろう 別のページ、いわば。 私たちは少し必要があるだろう 異なる構成。 そして、物事はすべて同じように動作しません。 そして、確かに、これらの日 私たちの多くは使用しないでください 唯一の私たちのラップトップ上で動作するソフトウェア。 その代わりに、私たちは何かを使用します そのブラウザのような 私たちは、Webベースにアクセスすることを可能にします クラウド内のアプリケーション。 そして、この後学期、 私たちはまさにそれを行います。 私たちは、アプリケーションを作成しますか code--ないCを使用してソフトウェア、 しかし、Pythonのような他の言語と クラウドで実行JavaScript--。 

そして私たち自身、それをします 学期中 実際にクラウドベースを使用します。 CS50 IDEとして知られている環境。 これは、Webベースのプログラミングで 環境、または統合開発 いくつかの上に構築されています環境、IDE、 クラウド9と呼ばれるオープンソースソフトウェア。 そして、我々はいくつかの教育学を作りました それへの単純化 で特定の機能を非表示にするように、 我々が必要としない最初の数週間、 することができますし、その後、 それらを明らかにし、ほとんどの操作を行います あなたは環境にしたいもの。 

そして、それはに、あまりにも、私たちを可能にします 特定のソフトウェアをプレインストールします。 いわゆるCS50のようなもの 我々はすぐにわかりますライブラリ、 いくつかとCで私たちを提供します 追加機能。 だから、あなたが行く場合に、最終的には、CS50.io、 あなたはログインを求めるメッセージが表示されます、 一度あなたが行うと作成します 無料のアカウント、 あなたがアクセスできるようになります 非常にこのようになります環境。 

今、これがデフォルトモードです。 すべてがいいですし、 画面上に明るいです。 私たちの多くは、習慣を持っています だCS50ピースに取り組んで かなり夜遅くまで。 だから、あなたのいくつかはに好むかもしれません いわば、ナイトモードに変換します。 

しかし、最終的に、何をしています CS50 IDE内で見に行きます 三つの異なるareas--です 左の場所の面積 あなたのファイルは、であることを行っています クラウド、右上のエリア ここで、あなたのコードが編集可能になるだろう。 あなたが開くことができるようになります 任意のプログラムのための個々のタブ あなたは内部のこの学期を書くこと その右上隅の。 そして最もarcanely、 まだ力強く、 で、この事になるだろう ターミナルウィンドウとして知られている一番下。 

これは、古い学校です コマンドラインインタフェース、 またはCLIは、それが可能に あなたのコマンドを実行します この場合computer--に、 cloud--コンピュータ あなたのコードをコンパイルするようなことを行うには ソースコードからマシンコードへ、 あなたのプログラムを実行するために、またはあなたを開始します Webサーバ、またはデータベースにアクセスするために、 および他の技術の任意の数 私たちはずっと前から使用を開始するだろうと。 しかし、そこに到達するために、我々はしています 実際に持っているつもり オンライン行くと再生を開始します。 そして、それを行うには、最初にしてみましょう メインいじり始めます、 プログラムの主要部分を記述します。 とのは、その機能を使ってみましょう 我々は以前に使用printf関数、 単に何かを言うために。 

だからここに私はCS50 IDEの内部ですでにです。 私は事前に記録されてきました。 そして、私は完全なウィンドウをスクリーニングしました。 だから、最終的に、あなた あまりにも来る問題で その類似の手順に従います オンラインドキュメントを提供します。 だから、心配する必要はありません どんな小さな技術的ステップを吸収 今日はここで行うこと。 

しかし、あなたは、このような画面が得られます。 私はナイトモードであることが起こります。 そして、あなたはすべてを明るくすることができます ナイトモードを無効にすることにより、アップ。 との終わりに 日、次のように表示するつもりです ファイルareas--これらの三つの主要な 左側のブラウザ、トップアップコード、タブ、 そして、下部のターミナルウィンドウ。 

私は先に行ってみようと 私の最初のプログラムを書きます。 私は、先制ファイルに行くつもりです 保存し、hello.cのように私のファイルを保存します。 確かに、慣例により、任意のプログラムの我々 C言語で書かれている書き込み 何かを命名する必要があります 慣例によりドットC、。 だから私はので、それをhello.cの名前を付けるつもりです 私は世界に挨拶したいと思います。 今、私はズームするつもりです アウト、[保存]をクリックします。 そして、私は今ここにあるすべてのタブです ここで私は、コードを書き始めることができます。 

これは、コンパイルするつもりはありません。 これは何を意味します。 だから、私は変換した場合でも この0と1に、 CPUはありません持ってしようとしています 周りに何が起こっているのか考え。 しかし、私は試合を行う行を記述する場合 Cのconventions-- Cのビーイングとアップ、 再び、これは次のような構文でlanguage-- この、world--ハローのprintfとIました と快適得 時間をかけてこれを行います。 だから私は、私が作ったとは思いません 任意のタイプミス。 

しかし、常に、非常に最初の あなたがこれを行う時間は、必要になります。 そして、何私は非常に威力を行うことについての思い よくあなたのために初めて動作しません。 そして、それは完全にOKですが、 今あなたのために ちょうど新しさの全体の多くが表示されることがあり、 しかし、時間をかけて、あなたは慣れたら この環境で、と この言語、およびその他、 あなたはその物事を見ることから始めましょう 正しいか、間違っています。 

そして、これは何ですか 指導員とコース アシスタントは、オーバー時にとても良いされ得ます あなたのコード内のミスやバグをスポッティング。 しかし、私はそれがあると主張します このコードにはバグがありません。 だから私は今、このプログラムを実行したいです。 

今、自分のMacやPC上で、私がいますよ ダブルクリックアイコンの習慣 私はいくつかのプログラムを実行したいとき。 しかし、それはこちらのモデルはありません。 CS50 IDEです。この環境では。 私たちは、動作を使用しています Linuxのと呼ばれるシステム。 Linuxは、別のを彷彿とさせます オペレーティングシステムは、一般に知られています Unixのよう。 およびLinuxは、特にために知られています コマンドライン環境、CLIを持ちます。 今、私たちは特定のを使用しています リナックスの風味は、Ubuntuのと呼ばれます。 そして、Ubuntuは単純です Linuxの特定のバージョンの。 

しかし、これらのLinuxのこれらの日は、実際に行います グラフィカルユーザインタフェースが付属しています。 そして、我々が起こる1 ここで使用することは、Webベースです。 だから、これはさえ見え​​るかもしれません 何かとは少し違います あなたは自分が持っているかもしれません 見たり、過去に実行します。 

だから私は先に行くつもりです 今と次の手順を実行します。 私はのhello.cとしてこのファイルを保存しました。 私は先に行くつもりだと 型clanghello.cだからクラン C言語のコンパイラです。 これは、CS50 IDEにプリインストールされます。 そして、あなたは絶対にダウンロードすることができ、 あなた自身のMacやPC上でこれをインストールします。 

しかし、再び、あなたはすべてを持っていません 事前設定が自動的に行わ。 だから今のところ、私はちょうどよ clanghello.cを実行するつもり。 そして今、この構文に気付きます ここでは最終的に ちょうど私がにいることを意味実現 ワークスペースと呼ばれるフォルダまたはディレクトリ。 このドル記号は単なる慣習です 意味については、ここにあなたのコマンドを入力します。 

それはちょうど、プロンプトと呼ばれるものです 慣例により、ドル記号です。 そして、私は今、先に行くと、クリックした場合 入力し、何が起こっていないようです。 しかし、それは実際には良いことです。 以下のことに起こります 画面、より多くの可能性が高いです あなたのコードが正しいとされ、 少なくとも構文的。 

だから私はこれを実行する場合 プログラム、私は何をしますか？ まあ、それはことが判明 慣例により、デフォルトの名前 プログラムのためにあなたが指定されていないとき ちょうどa.outですあなたのプログラムのために名前を付けます。 あまりにもこの構文と、あなたはよ ずっと前に慣れます。 

ドットはただ、ちょっと、CS50を意味スラッシュ IDE、a.outのと呼ばれるプログラムを実行します それは私の現在のディレクトリ内です。 つまり、ドットはカレントディレクトリを意味します。 そして、我々はどのような他のそのような配列が表示されます 文字のずっと前を意味します。 

そこでここでは、Hello Worldの、入力し、行きます。 そして、あなたは何が起こっていること、わかりますか？ だけでなく、それはHello Worldのを印刷しました。 また、移動 次の行にカーソル。 

そして、なぜそれがでしたか？ 私たちは前に書いたコードは何でしたか それは、カーソルがあろうことを保証しました 次の行に行きますか？ 約面白いです コンピュータはそれだけで起こっているのです あなたはそれが何を言うこと文字通り行います。 

ですから、ハローのprintfにそれを伝える場合、 カンマ、スペース、世界、近くの引用、 それは文字通りだけで起こっています これらの文字を印刷します。 しかし、私はこの特殊文字を持っていました 終わりに、リコール、バックスラッシュn個。 そして、それは確実に何 文字が行ったこと 画面の次の行に。 

実際には、私が行くと、これをやらせます。 私が先に行くと、これを削除してみましょう。 さて、ということに気づきます 私の画面の上部にあります 小さな赤い光の中で タブを示し、 ねえ、あなたはあなたのファイルを保存していませんでした。 だから私は、コントロールを進めるつもりです SまたはコマンドS、ファイルを保存します。 今ではmoment--緑のために行ってきましたgoes--。 そして今、それはに戻ってです ちょうど近くにアイコンです。 

私は今、再びclanghello.cを実行すると、 、入力し、ドットスラッシュ、a.outの、入力してください あなたはそれがまだ働いていることがわかります。 しかし、それは間違いなく少しバギーです。 今、私のprompt--ワークスペース、 そして、そのドル記号、 そしてその後、私の実際のprompt-- すべての同一線上にあります。 だから、これは確か美的バグ、 場合でも、それは本当に論理的なバグではありません。 

だから、私はちょうど何をしたか元に戻すつもりです。 私はa.outを再実行するつもりです。 私が追加した注意してください 改行文字のバック。 私は、ファイルを保存しました。 

だから私は、a.outの再実行するつもりですand-- くそ、バグ、ミスを意味するバグ。 だから、バグがあってもかかわらずです 私は、nはそこにバックスラッシュを追加しました 再保存し、プログラムを再実行し、 動作は同じでした。 それはなぜでしょうか？ 

私は右のステップを、欠けていますか？ 以前そのキーのステップは、あなたが持っているということでした あなたがソースコードを変更すると、to-- それはまた、実行判明します それコンパイラを通して 再び、あなたは新しいマシンコードを取得します。 マシンコード 0と1、 、ほぼ同一であることを行っているが、 ない完全ので、私たちが必要とするため、 もちろん、その新しいライン。 

だから、この問題を解決するために、私が必要とするつもりです 、入力し、ドットをclanghello.cを再実行します スラッシュ、a.outの。 そして今、こんにちは世界が帰ってきました 私はそれがあることを期待した場所に。 だから、これはすべての罰金と良いです。 しかし、a.outがためにかなり愚かな名前です。 プログラム、それがあることを起こるにもかかわらず、 歴史的な理由のために、 アセンブリ出力を意味default--。 

しかし、私はここに先に行かせ そして、異なってこれを行います。 私は私のハローワールドプログラムをしたいです 実際にハローと呼ばれていました。 だから、私の上のアイコンだったら デスクトップ、それはa.outということはないだろう。 それは、ハローと呼ばれることになります。 

だから、これを行うには、それが判明します クランこと、多くのプログラムのように、 コマンドライン引数をサポートし、 またはフラグ、またはスイッチ、 単にその動作に影響を与えています。 具体的には、クランはダッシュOをサポートしています その後、2番目の単語を取るフラグ、。 この場合、私は任意よ、 しかし、合理的、こんにちはそれを呼び出します。 しかし、私は何もそれを呼び出すことができます 私はa.outの、を除いて、対象となります むしろポイント以外になります。 

そして、名前だけを指定 ファイルの私がコンパイルしたいん。 だから今でも、冒頭にかかわらず、 私はまだクランを持っているコマンドの、 コマンドの最後に 私はまだ、ファイル名を持っています、 私は今、これらのコマンドラインを持っています 引数、言っているこれらのフラグ、 ああ、ところで、出力-O、ファイル ないデフォルトのa.out、ハローと呼ばれます。 

だから私は、今、何も入力しないヒットした場合 起こっているようです。 そして、まだ、今私はハロードットスラッシュを行うことができます。 だから、同じプログラムです。 0と1であります 一日の終わりに同一。 

しかし、彼らは2にしています 異なるfiles-- a.outの、 これは最初のバージョンです ちょうど愚かという名前の、 そして今こんにちは、ずっとあります プログラムのためのより魅力的な名前。 しかし、正直なところ、私は決して午前 再びこれを覚えて行きます、 そして再び、再び。 そして、実際に、私たちが書いています より複雑なプログラム、 あなたがしているコマンド 書き込みしているつもり でも得ようとしています まだまだ複雑。 

そして、そのように心配する必要はありません。 それは人間の前にいることが判明します 私たちはあまりにも彼らを実現しています これと同じ問題を抱えていました。 彼らはあまりにもを有する楽しみませんでした かなり長い、難解なコマンドを入力し、 おろか、それらを覚えています。 そして、そのように私たちの前に人間が作りました それを容易にする他のプログラム お使いのソフトウェアをコンパイルします。 

そして、確かに、そのような プログラムはメイクと呼ばれています。 だから私は先に行くと、これを実行するつもりです。 私は、私はすべてを元に戻すつもりです ただ、次のようにしました。 私はLSを入力してみましょう。 そして、あなたは3 things--に気付くでしょう a.outの、星、ハロー 星、とのhello.c。 うまくいけば、これはすべき 少し直感的、 以前に存在したものであれば このワークスペースでは何もありません。 私が持っていたものは何もありませんでした 私たちはクラスを始めるまで作成しました。 

そして、私はhello.cのを作成しました。 私はそれをコンパイルし、それをするa.outと呼ばれます。 そして、私は少しそれを再度コンパイル 異なるとハローそれを呼びました。 だから私は、このディレクトリ内の3つのファイルを持っています、 このフォルダにワークスペースと呼ばれます。 さて、私もそれを見ることができます 私は実際にズームアウトした場合。 

私はここでズームアウトした場合と その右上を見て コー​​ナー、約束どおり左 画面の左側 いつもお見せしようとしています 何、あなたのアカウントに何 CS50 IDEの内部。 そして、そこに3つのファイルがあります。 

だから私はハローとするa.outを取り除きたいです。 そして、あなたがかもしれないとして、 、直感的にあなたを想像します 制御クリックで並べ替えることができ または右これをクリック。 そして、この小さなメニューがポップアップ表示されます。 あなたがファイルをダウンロードすることができ、実行 それは、それをプレビューし、リフレッシュし、名前の変更、 またはものではありません。 

そして私はちょうど削除することができ、 それは離れて行くだろう。 しかし、ここでは、コマンドで物事をやらせます 今のライン、快適な取得するように、 これで、そして次の手順を実行します。 私は先に行くと、削除するつもりです 文字通りrma.out入力して、a.outという。 これは、ためのコマンドが判明します 取り外したり、何かを削除します、 削除するか、削除されていません。 

それはちょうど節約するために、より簡潔RMです もしいくつかのキーストローク、およびEnt​​erキーを押します。 今、私たちは多少あることになるだろう ひそか正規のファイルa.outを削除します。 私は本当にわかりません 不規則なファイルはまだだろう。 しかし私はそれを削除したいです。 

だから私はイエスを表すyを入力するつもりです。 または私はそれを入力し、Enterキーを押しことができます。 そして、再び、何も起きていないようにみえます。 しかし、それは、一般的に、良いことです。 

私はこの時間LSを入力した場合、 私は何を参照する必要がありますか？ うまくいけば、単にこんにちはとのhello.c。 さて、余談、あなたとわかるように この星、アスタリスクに気づきます、 それは私のプログラムの終了時です。 そして、彼らはまた、緑色に見せています。 それはちょうどCS50 IDEの方法です 実際にあなたをcluingの ことそれはソースコードではありません。 つまり、実行可能な実行可能です あなたが実際に実行することができますプログラム ドットの操作を実行してスラッシュ、そしてそれが名前です。 

今、私は先に行くと、削除しましょう この、こんにちはRM、入力して、定期的に削除します はい、こんにちはファイル。 そして今、私はLSを入力した場合、 我々は戻ってのhello.cにしています。 あなたを削除しないようにしてください 実際のソースコード。 特徴があるにもかかわらず ここで、CS50 IDEに組み込まれて あなたの改訂履歴を介して行くことができます そして、誤ってあれば、時間に巻き戻し 何かを削除し、注意してください これらのプロンプトyesまたはnoあたりなど、 あなたが実際に何をしたいの。 そして、私はトップに上がる場合 ここの隅を残し、 hello.cは、すべてのことが残っています。 だからの房があります そのあなたの他のコマンド Linuxの世界で実行することができ、 あるのは、再び、メイク。 そして、私たちはするつもりです 私のプログラムは、現在は以下の通り。 

代わりに打ち鳴らすを行うための、 代わりにクラング-Oを行うための、 私は単純に行きますよ 文字通り入力し、ハロー作ります。 そして今、私は、気付きます hello.cを作る入力していません。 私はハローをmakeと入力しています。 

そして、このプログラムは、ことを確認してください CS50 IDEが付属しており、より多くの 一般的にLinuxで、 なプログラムです ハローと呼ばれるプログラムを作るつもり。 そして、慣例により、前提となるだろう このプログラムを行うことができる場合に、 ソースから作ることになるだろう ドット（c）に終わるコードファイル、hello.cで。 

だから私は今入力してヒットした場合、通知はその 実行されますコマンド さらに長い実際にあります 以前よりも前。 私たちがきたので、それはです 持っている事前設定されたCS50 IDE その中に組み込まれていくつかの追加機能 我々はまだ必要があるが、すぐに意志はありません。 しかし、重要なのは、実現するために、 私はハロープログラムを持っている今です。 

私は再びLSを入力した場合、I ハロープログラムを持っています。 そして、私はそれを実行することができます ドットスラッシュa.outの、いや、 このの全体のポイントので、 演習では、ドットスラッシュこんにちはでした。 そして今、私は私のハローワールドプログラムを持っています。 だから前進し、 私たちは、ほとんど常にしています 私たちのプログラムをコンパイルしようとして コマンドメイクを使用。 そして、我々は、それらを実行するつもりです ドットスラッシュ、およびプログラムの名前。 しかし、のために何をしているかメイクを実現 もし、それがコンパイラ自体ではないです。 それだけで便利なプログラムです それは、コンパイラをトリガする方法を知っています あなた自身がそれを使用できるように実行します。 

で、他にどのようなコマンドが存在します Linux、および順番にCS50 IDE？ 我々はすぐそこだことがわかります CDコマンド、ディレクトリ変更。 これが内ことができます あなたのコマンドラインインタフェース フォワード、バック移動し、 そして、別のフォルダを開きます あなたのマウスを使用せず。 

リストの略で、私たちが見たLS、 現在のディレクトリ内のファイル。 ディレクトリを作成し、次のことができます おそらく推測するために開始 これらのディレクトリを作るnow--何を意味しますか、 あなたは、フォルダを作成したい場合。 削除のためのRM、RMディレクトリ用 、directory--を削除し、これらの 再び、コマンドラインであります 何の当 マウスでCS50 IDEで行うことができます。 しかし、あなたはすぐに見つけることができます その時々それだけです やるべきことがたくさん速いです キーボードとの事、 そして最終的に、より多くの強力な。 

しかし、それは、と主張するのは難しいです 我々はこれまでに行ってきたもの ときにすべてのすべてのことは、強力です 我々はこんにちは、世界を言ってきました。 そして、実際に、私はハードコード 私のプログラムへのHello Worldの言葉。 まだダイナミズムはありません。 スクラッチは、大きさの順でした もっと面白い先週。 

それで者が取得してみましょう。 のは、そのことによって一歩を見てみましょう これらの機能のいくつかの方法。 だからだけでなく、Cは、printfのが付属していません 他の機能のと房 そのうちのいくつかは我々が表示されます 時間をかけて、それはしていません 右のアウトすべてのことが簡単にそれを作ります ユーザー入力を取得中にゲートの。 

弱点の事実、1 Cのような言語の、 まだ、さらにはJavaと 他の人、そうでないということです ちょうどのようなものを取得することが容易に ユーザーからの整数、または文字列、単語、 やフレーズ、などだけでは物事を聞かせて ポイント値、または実数浮動 本当に小数点、および付き 我々はすぐにわかるように長い数字、。 そこでここでは関数のこのリストは、これらの 他のスクラッチパズルのピースのようなものです 私たちは、CS50にプリインストールされていること 我々は数週間のために使用しますIDE 各種の補助輪のように、と 最終的にはそれらを脱いで、と見て フード、おそらく、で下に これらの事をどのように実装されています。 

しかし、これを行うには、してみましょう 実際にプログラムを書きます。 私は今、先に行ってみましょう。 そして、私は新しいを作成するつもりです この小さなプラスをクリックしてファイルを、 新しいファイルをクリックしてください。 

私はこの次を保存するつもりです string.c、の言わせ、として1、 私は文字列でプレーしたいので。 そして、Cの文字列だけです 文字のシーケンス。 それでは先に進みましょう そして次の操作を行います。 

標準IO.h--を含めると、 それは、標準IOが判明します IOだけ入出力を意味します。 だから、ことが判明します ここでは、この行は何ですか printfのを使用するために私達に隣接されています。 printf関数は、もちろん、出力を生成します。 そうprintf関数を使用するためには、オン あなたは、このコード行を持っている必要が出 あなたのファイルの先頭に。 

そして、我々はに戻ってくるもの それは本当に長い前を意味します。 それはでていることが判明します 私が書く任意のCプログラム、 私はそれを開始するんです このようなコード。 そして、あなたはCS50 IDEに気づくと、よ 他の統合開発 それのような環境では、 最善しようとしています 彼らはあなたの思考を終了することができます。 実際には、先ほど私は元に戻す場合 私は何をしたか、私はEnterキーを押します。 

私は、オープンカーリーを打ちます ブレース、もう一度Enterキーを押します。 そして、それは私の考えを終えました。 それは私にインデント劣らず、新しい行を与えました 素敵な文体の理由のために我々が表示されます。 そして、それは自動的に私を与えました その中カッコは私の思考を終了します。 今、それは常にありません あなたが何をしたいかと思います。 しかし、大部分は、それはありません あなたにいくつかのキーストロークを保存します。 だから一瞬前、我々はこのprogram--を走りました こんにちは、世界、それをコンパイルし、 し、それを実行しました。 しかし、ここで何のダイナミズムはありません。 我々が望んでいた場合はどう 別の何かをしますか？ まあ、私は実際に何を望んでいた場合 ユーザーから文字列を取得しますか？ 私は、パズルのピースを使用するつもりです 正確に文字列を取得しthat--と呼ばれます。 

Cで判明したくないときに パズルピースへの入力を提供するために、 またはより適切に機能するには、 文字通り、開き括弧を行います 閉じ括弧。 ありますかのようだからです 入力する白い箱はありません。 前の発言ブロック 小さな白いボックスを持っていました。 私たちは今、その白いボックスを持っていません。 

しかし、私は、get文字列を呼び出し、I どこかの結果を載せていきたいと思います。 だからCで非常に一般的なパラダイムはにあります ここに来る文字列のような関数を呼び出し、 そして、その戻り値を格納します。 それは、その結果です 何かで努力。 

そして、何です プログラミングで構築し、 C今スクラッチまたはかどうか、私たちはその 実際に何かを格納するために使用することができますか？ それは右、変数と呼ばれますか？ そしてスクラッチで、私たちは本当にしないでください 変数に何が起こっていたか気になります。 

しかし、このケースでは、我々は実際に行います。 私は、文字列を言うつもりです。 そして私は呼び出すことができます この私が欲しいもの。 私はそれを呼び出すつもりです 名前は、文字列を取得します。 

そして今、あなたがしている場合でも、 これに少し新しいです、 私はいくつかの詳細を欠いていることに気づきます。 私はセミコロンを忘れています。 私はこの考えを完了する必要があります。 だから私は、私のカーソルを移動するつもりです そしてそこにセミコロンを打ちました。 そして私はちょうど何をしましたか？ このコード行では、 現時点では数5、 ノー入力してget文字列を呼んでいます。 だから、何の小さな白いはありません 保存ブロックが持っているようボックス。 

私は、ちょっと、言っています コンピュータは、私の文字列を取得します。 等号は本当にありません 等号は、それ自体が。 それは割り当てです オペレータ手段、 ちょっと、コンピュータ、値を移動 左の上右から。 そして左に、私は次のように持っています。 

ねえ、コンピュータ、私にstring--を与えます 文字のシーケンス。 その文字列の名前を呼びます。 そして、私も名前、それを呼び出す必要はありません。 

私は従来から、それを呼び出すことができ、 Sのようなもの、 私たちは、私が使用するのと同じよう 私は、変数を呼び出します。 しかし、今、私はそれで何かをする必要があります。 〜するのはかなり愚かなことだろう 実行中、このコードをコンパイルしてみてください このプログラム、たとえ 私は、文字列を取得しています、 それだけではまだですので、 こんにちは、世界を言うつもり。 

しかし、私はこれを変更するには何をしたいならば。 なぜ私はこれをしませんか？ パーセントの、コンマ秒。 そして、これはまだ少し不可解です。 

だから私は、私の変数をより明確にしましょう​​。 私はこの変数名に名前を付けましょう。 そして、我々はいじめることができない場合を見てみましょう ここで何が起こっているか離れて。 

だからライン5に、私は文字列を取得しています。 そして、私はその文字列を格納しています、 ユーザーがで入力したものは何でも 彼または彼女のキーボードでは、 名前と呼ばれる変数インチ そして、それはことが判明します printf関数だけではなくありません 二重に一つの引数を取ります 引用符、二重引用符内の1つの入力。 

それは、2つ、または3つ、またはそれ以上を取ることができます 、第2、または第3の、または第4のこと 変数のすべての名前であり、 または具体的には、値 あなたがにプラグインすることを、 動的に、引用符でその文字列。 言い換えれば、どのような これで間違っているでしょうか？ 私は言った場合こんにちは名、バックスラッシュ nは、私のコードをコンパイルし、私のファイルを保存しました この走り、何が起こるのでしょうか？ 

ちょうどこんにちは、言おうとしています 名前、文字通りN-A-M-E、 どの種類の愚かな理由であります それは世界と何ら変わりません。 だから、引用符で囲まれたものであり、 何文字通り印刷されます。 だから私は持っているしたい場合 そこにプレースホルダ、 私は実際に使用する必要があります いくつかの特別な構文。 あなたが読めば、それが判明します printf関数のドキュメント、 それがいることを教えてくれます あなたは、パーセント秒を使用している場合、 次のように値を代入することができます。 

その後のコンマの後に 二重引用符、単にあなた の名前を書きます あなたがしたい変数 その形式にプラグインします コー​​ド、または書式指定子、 パーセントの文字列の。 そして今、私は私のファイルを保存した場合、 私は自分の端末にダウンして戻ってください。 そして、私は文字列を作成し入力し、 再び、ため、この名 私は前に選択したファイルがstring.cです。 

だから私は、文字列は、入力してくださいと言うつもりです。 善良私のああ、のすべてを見て ミス我々はすでに行われてきました。 そして、これはこれは本当に何ですか、is-- 6、7行のプログラムのような？ ここで、それは非常にすることができますので、これはです すぐに圧倒的な取得。 

このターミナルウィンドウが持っています 今だけの逆流 エラーメッセージの膨大な数。 確かに、私はより多くのエラーを持っていません 私はコードの行を持っているよりもメッセージ。 だから何が起こっているの？ 

まあ、最善の戦略 あなたはいつでも行うには 圧倒的に遭遇ん そのようなエラーのリスト、 バックスクロールされ、コマンドを探します あなただけの私の場合には、実行しました 文字列を作るです。 何をしたかのメイクを見て、それはそれです 長いクランコマンド、そこに大したことありません。 

しかし、赤が悪いです。 緑があることしようとしています 穏やかで親切。 しかし、それはこの場合には、まだ悪いです。 しかし、ここでそれは悪いのですか？ 

String.c、ライン5、文字5。 だから、これは単に一般的な慣例です。 何かコロン何か手段 行番号や文字番号。 エラー、未宣言の使用 識別子の文字列。 あなたは、標準的なことですか？ 

だから、残念ながら、クラン 参考にしようとしています。 しかし、それはこの場合には、間違っています。 いいえ、クランは、私は標準的なIOを意味するものではありませんでした。 私ははい、行1であることを意味しました。 

しかし、ライン5は、ここではこの1です。 そして、クランはしていません S-T-R-I-N-Gを理解しています。 これは未宣言の識別子、Aの それだけで前に見たことのない言葉。 そして、それは、Cのため、言語です 我々は、今でコードを書いています 文字列と呼ばれる変数を持っていません。 

これはサポート、デフォルトでは、しません 文字列と呼ばれるもの。 それはのCS50作品です 専門用語が、非常に従来の。 次のようにしかし、私はこの問題を解決することができます。 

私は、コードの1行を追加した場合 このプログラムの先頭に、 別のファイルであるCS50.hを含み、 どこかCS50 IDE、どこかの内部 ハードドライブ上に、いわば、 Ubuntuのオペレーティングシステムの 私が実行していることを、その だファイルがあります 操作を教えるつもり 文字列が何であるかをシステム、ちょうど 標準io.hのようなファイルです。 オペレーティングシステムで 何であるかのprintfそれを教えるつもり。 

実際、我々が得ているだろう 非常に同様のメッセージ IOは標準を認めていた場合 IO.hはとのprintfを使用しようとしました。 だから私は先に、ちょうど行くつもりです 私の画面をクリアするには、コントロールLを取ります。 それとも、明確な入力することができますし、それはなります ただ、ターミナルウィンドウをクリアします。 しかし、あなたはまだ時間に戻ってスクロールすることができます。 

そして、私は文字列を作成し再実行するつもりです。 この時に私の指を渡り、入力します。 私の神ああ、それが働きました。 それは私に長い不可解なコマンドを示しています それは、どのようなクランを経由して生成されたことを確認しています しかし、エラーメッセージなし。 だからにもかかわらず、実現 あなたは完全になるかもしれません と圧倒 エラーメッセージの数、 それだけで、この迷惑なカスケードであるかもしれません クランは理解していない効果、 それを意味する一つのこと、 次の単語を理解していません、 または次の行。 そしてそれはちょうどあなたのコードにチョーク。 しかし、この修正は簡単かもしれません。 だからいつもに焦点を当てます 出力の最初の行。 そして、あなたがいない場合 それを理解し、ちょうど見て かもしれないキーワードの 手がかり、および行番号、 文字、どこ その間違いがあるかもしれません。 

今、私は先に行くと入力してみましょう ドットスラッシュ、文字列、入力します。 フム、それはハロー何も言っていません。 どうして？ それが実行されているまあ、リコール、？ 

それはおそらく、現時点で立ち往生しています ループで、ライン6上、可能ならば、 設計によって文字列を取得しているため、 CS50のスタッフによって書かれました、 文字通り座ることを意味しています そこに待っている、と待っています、 文字列を待っています。 私たちは、文字列の意味はすべて、人間が入力されます。 だからあなたは何を知っていますか？ 私は先に行ってみよう。 そして、ちょうど気まぐれで、私を聞かせて 私の名前、デビッドを入力し、入力します。 今、私はよりダイナミックなプログラムを持っています。 それはデビッドこんにちは、と述べました。 

私は先に行くと、再びこれを実行すると、 私が入力し、Zamila名を言ってみましょう。 そして今、我々は動的なプログラムを持っています。 私は、ハードの世界をコーディングしていません。 私は、ハードコーディングしていません 名前、またはデビッド、またはZamila。 

今でははるかにプログラムのようです それが入力を取る場合、私たちは、どこに、知っています それがわずかに異なる出力を生成します。 さて、これが最善ではありません ユーザーエクスペリエンス、またはUX。 私はプログラムを実行します。 

私はなってるかわかりません 私は実際に見ていない限り、行うには またはソースコードを覚えています。 それでは、ユーザーを作ってみましょう 少し良く経験します 物事の最も簡単なと。 私はこの中に戻りましょう プログラムは、単にprintfのを言います。 

そして、私が先に行くと名前、コロンを言わせて、 そして、空間、次にセミコロン。 そして、ちょうど蹴りのため、ノーバックラッシュのn。 そして、それは意図的ですが、 私はしたくないので、 プロンプトが次の行に移動します。 

私は、代わりに、これをやってみたい、文字列を作ります 新しいマシンに私のコードを再コンパイルするには スラッシュ文字列のドットコード。 ああ、これははるかにきれいです。 今、私は実際にどのようなコンピュータを知っています 私が何をしたい、それに名前を付けます。 

だから私は先に行くと入力するつもりです ロブで、ハローロブを入力し、。 そこで、最後に、これはまだ実現 その日の、唯一の9ラインプログラム。 しかし、我々は、これらの赤ちゃんの措置を講じてきました。 

私達は私達との1行を書きました おなじみの、printf関数、こんにちは世界でした。 その後、我々はそれを少し元に戻しました。 そして、我々は実際のget文字列を使用していました。 そして、我々は変数にその値を投げました。 そして、我々は先に行って、改善されました さらに三行目でそれ。 そして、この反復プロセス ソフトウェアを書くことは本当にキーです。 CS50では、と一般的に生活の中で、 あなたは一般的に、座ってはいけません 心の中でプログラムを持っている、と書き込みをしてみてください すべてを一度に全体こいつ。 

これは、必然的に、のようになります 私たち自身がここで見たよりも多くのエラー。 でも私は、この日に、絶えず 他の愚かな間違いを犯します、 実際には困難ミスです それは把握することが困難です。 しかし、あなたはより多くの間違いがより多くを行います コー​​ドの行は、あなたが一度にすべてを書きます。 だからのこのような行為、 コー​​ドを少し書きます あなたがに慣れていることを、コンパイル それは、それを実行し、より一般的にそれをテストし、 その後、我々は保ただけのようなので、on--移動 先週階層化と階層化、 非常に何かからビルド より複雑なものに簡単な、 ここで同じことを行います。 座って、とにしようとしないでください 全体の問題を記述します。 実際にこれらの赤ちゃんの手順を実行します。 

さて、文字列がすべてではありません 自分自身にむかっその有用。 我々はしたいと、理想的には、実際にいただきたいです 私たちのツールキットで何かを持っています。 それでは、実際に正確にそれをやらせます。 

私は今、先に行くとかき立てるしてみましょう わずかに異なるプログラム。 そして、我々は整数のために、このint.cと呼ぶことにします。 私は、同様に、するつもりです、 CS550.hが含まれます。 私は、標準的なIOを含めるつもりです。 そして、それはかなり一般的になるだろう クラスのこれらの最初の数日間インチ 

そして、私は準備ができに行きますよ 自分のメイン機能を持ちます。 そして今、代わりに文字列を取得します、 それでは、先に行くと、int型を取得してみましょう。 のは、私にそれを呼ぶことにしましょう​​、と得るそれを呼び出します int型、クローズ括弧、セミコロン。 そして今のはやらせます それで何か、printf関数。 

以下のようなものを言ってみましょう こんにちは、バックスラッシュnは、カンマ私。 だから私はかなり模倣しています 私はちょっと前にやりました。 私はここで、プレースホルダを持っています。 私が欲しいので、私は、ここで私をカンマいます 私は、そのプレースホルダに差し込むします。 

それでは、先に行くと試してみましょう このプログラムをコンパイル。 ファイルが呼び出されint.c. だから私は入力して、int型を作る、と言うつもりです。 ああ私の神が、大したことないですよね？ 間違いがあります。 

構文上の誤りがあります ここでは、そのようなプログラムができないこと int.c、線の内側にコンパイルします 7、文字27、エラーフォーマット char型を指定します 星、それがされているもの。 しかし、引数の型はintです。 

そこでここでは、あまりにも、私たちはto--つもりはありません 今日は、材料がたくさんあるにもかかわらず、 私たちはであなたを圧倒するつもりです 絶対にCのすべての機能、 そして、より一般的にプログラミング ただ、これらの最初の数週間インチ だから、多くの場合、専門用語があるように起こっています これであなたが慣れていません。 そして、実際には、char型の星は何かであります 我々は戻ってくるつもりです 週または2の時間インチ 

しかし今のところ、私達ができる場合を見てみましょう よく知られている単語を解析します。 フォーマット - 私たちは形式を聞きました 指定子、書式コードの前に。 それはお馴染みです。 Type--しかし、引数はint型を持っています。 ちょっと待って、私はintです。 

たぶんパーセントの実際 いくつかの定義された意味を持っています。 そして、確かに、それはありません。 整数、あなたがしたい場合 それを代用するのprintf、 あなたが実際に使用する必要があります 異なる書式指定子。 そして、あなたはこのことを知っているだろう 誰かがあなたに言っていない限り、 またはあなたが前にそれを行っていました。 しかしパーセントiは何ですか 一般的に使用されることができます 整数をプラグインするためのprintfインチ またパーセントを使用することができます 10進整数のためのD。 しかし、私はここでいいと簡単です。 だから我々はそれで行くつもりです。 

今、私は先に行くとしましょう 再放送はint型を作り、入力します。 つまり、エラー良いです。 ドットは、int-- OK、ユーザーエクスペリエンスを大幅に削減します 私は自分自身に語っていないので、 何をすべきか。 しかし、それは大丈夫です。 私はすぐにキャッチしています。 

そして今、私が先に行くとしましょう デビッド、[OK]を、Zamila、ロブを入力します。 OK、これは良いことです。 今回、私は、関数を使用しています GET int型と呼ばれるパズルのピース、。 そして、それはout--になり、私たちはよ term--でこの以降を参照してください。 CS50のスタッフが実施しています このように文字列を取得 それだけで物理的になりますこと あなたのための文字列を取得します。 

これは、中のget int型を実装しています それが唯一のような方法 あなたのための整数値を取得します。 そして、あなたの場合、人間、 協力しない、それはです 文字通りに行きます 、再試行し、再試行し、再試行言います 文字通りまで、ループそこに座っ あなたはいくつかの魔法の数字で義務付けます、 50 50のような、およびこんにちは。 

または我々は再びこれを実行する場合 そして、タイプ42で、42こんにちは。 そのためのget int型の関数 そのパズルのピースの内側 十分なロジックがあり、十分に考え、 把握するために、言葉は何ですか？ その数は何ですか？ のみ、最終的に、数値を受け付けます。 

だから、このことが判明します すべてのことの表現ではありません。 これまでのところ。 だから、イェーイ、最後の時間、私たち かなり迅速に行ってきました ゲーム、アニメーションを実装するに、 そして、スクラッチで芸術作品。 そしてここで、我々はコンテンツつつあります こんにちはと世界、そしてハロー50。 

これは、すべてその感動はありません。 そして、確かに、これらの最初の数 例としては、ある程度の時間がかかります 興奮状態で上昇します。 しかし、我々はそんなに多くを持っています 実際には、今制御します。 そして、我々は非常にしようとしています すぐに重ね着を開始 これらの基本的なプリミティブの上に。 

しかし、最初のは理解してみましょう どのような制限があります。 物事の実際には、1 スクラッチは簡単にしません 見て本当に私たちが行うさせて ボンネットの下に、 とを理解 コンピュータは、それが何ができるか、です そしてその限界は何ですか。 そして、確かに、その不足の 理解、潜在的に、長期的 私たち自身のmistakes--書き込みにつながることができます 安全でないソフトウェアを書くバグ、その 何らかの方法でハッキングされます。 

それでは向けていくつかの手順を実行してみましょう によってこれは少し良く理解します 方法は、次の例を言います。 私は先に行くと、実装するつもりです 実際に素早く加算器と呼ばれるプログラム。 同様に、ご一緒にいくつかの数字を追加してみましょう。 そして、私はいくつかのコーナーをコーディングするつもりです ここでは、ちょうどコピーして貼り付けます 私は、前にあった場所 私たちはすぐに軌道に乗ることができます。 だから今、私は基本的な始まりを持っています 加算器と呼ばれるプログラムの。 

とのは、先に行くと、これを実行しましょう​​。 私は先に行くつもりだと たとえば、INTXはint型を取得します。 そして、あなたは何を知っていますか？ のは、優れたユーザーエクスペリエンスを作ってみましょう。 

それでは、ちょうどxがあり、かつ効果的に言わせて 私たちのxを与えるためにユーザに促します。 そして、私が先に行くとprintfの、としましょう どのようにyがあるについて、この時間は期待 ユーザーからの二つの値。 そして、ちょうど先に行くとしましょう たとえば、printf関数、xとyの和です。 そして今、私は、パーセント秒を行うにはしたくありません。 私は、パーセントの私をしたい、バックスラッシュ nは、その後、合計値をプラグイン。 

だから、どのように私はこれをやって行くことができますか？ あのね？ 私は、変数を使用する方法を知っています。 私はちょうど新しいもの、int型zを宣言してみましょう。 

そして、私はここで推測を取るつもりです。 この中で等号がある場合 言語は、多分私は、xプラスyはちょうど行うことができ、 長い間、私は私のエンドとして セミコロンで思いましたか？ 今私は、zのプラグイン、ダウンここに戻って行くことができます セミコロンでこの考えを終えます。 そして、これらの場合、それでは見てみましょう lines--のxの配列はint型を取得することです。 Yはint型を取得することです。 

X及びYを追加し、z--に値を格納 そう、再び、等号を覚えています 等しくありません。 これは、右から左への割り当てです。 そして、の和ことをプリントアウトしてみましょう xとyのは、文字通りzのではありません しかしZの中です。 それでは、加算器を作ってみましょう -  素敵な、間違いない今回。 ドットは、加算器は、入力スラッシュ xは1になるだろう。 

Yは2になるだろう。 xとyの和は3です。 だから、すべての罰金と良いです。 

だから、その数学を想像するだろう このようなプログラムで動作するはずです。 しかし、あなたは何を知っていますか？ この変数、行があります 12、であっても必要？ あなたが習慣に取得する必要はありません。 変数だけで物事を保存します ちょうどすることができますので。 そして、実際に、それは一般的な 悪いデザインと見なさ あなたは、変数を作成している場合、呼ばれます この場合のzは、それに何かを格納し、 その直後 それを使用して、決して再び。 なぜ何かに名前を付けます zのように、あなたは文字通りなら それを使用するつもり 事は一度だけ、など あなたが作成した場所への近位 その最初の場所で、 コー​​ドの行の点で非常に近いですか？ だからあなたは何を知っていますか？ これは、Cはかなり柔軟であることが判明しました。 私は実際にしたい場合 プラグインの値ここで、 私は、新しい変数を宣言する必要はありません。 私はプラグインの可能性がXプラス Y、Cは理解しているため 算術演算、および算術演算子。 

だから私は単純に、この計算を行う、と言うことができます xプラスyの、それらの値が何であれ、 その結果プラグ その文字列に整数。 だから、これはしかし、可能性があります 一行だけ短く、 優れたデザイン、より良いプログラム、 以下のコードがありますので、したがって、 私が理解するために以下です。 そしてそれは、また、単にクリーナーです 私たちではない限り、 新しい単語を導入し、 新しいシンボル、zのように、 彼らは本当にないにもかかわらず、 目的の多くを提供しています。 

残念ながら、数学ではありません 時にはすべてのことは、信頼性の高いです。 それでは、先に行くと、これを実行してみましょう。 私は先に行くつもりです 今と次の手順を実行します。 

のは、printfの、パーセントの私、プラスパーセントをやってみましょう 私は、パーセントの私は、バックスラッシュnをしなければなりません。 そして、私はthis-- XYXプラス、yをするつもりです。 だから、僕はリライトするつもりです この若干異なるここに。 私はちょうど迅速な健全性チェックをしましょう​​。 ここでも、のは、先に自分の取得しないようにしましょう​​。 加算器、ドットスラッシュ加算を行います。 xが1であり、yは2,1プラス2は3です。 だから、それは良いことです。 しかし、今度はこれを複雑にしてみましょう ビット、および新しいファイルを作成します。 

私はこの1つを呼び出すするつもりです、 int型、整数の複数の、と言います。 私は一瞬前にあった場所に私は見てみましょう。 しかし、今のは、他のいくつかの行をしましょう​​。 、私が先に行くと、以下のことをやってみましょう printf関数、パーセント私、マイナスパーセント私、 パーセントの私は、カンマのx、コンマYXマイナスyがあります。 だから私は少しやっています そこに別の数学。 のは、別のものをやってみましょう。 だからパーセント私回パーセント 私は、パーセント私、バックスラッシュnです。 プラグインでのx、およびy、およびx回のyましょう。 私たちは、上のアスタリスクを使用します 時間のコンピュータ。 

あなたは、xを使用しません。 xは ここでは変数名。 あなたは乗算の星を使用します。 のは、1以上をやってみましょう。 printfの％のI、分割 パーセントによって私は、私％で、 バックスラッシュn個。 XY-Y-で割った値 あなたがC言語でスラッシュを使用します 除算を行います。 とのは、他のいずれかの操作を実行してみましょう。 パーセントiの残り、分割 パーセントのiで、パーセントの私です。 xy--、今残り 余っているものです。 あなたは、分裂しようとすると 分子への分母、 ことをどのくらい残されています あなたはアウト分けることができませんでしたか？ 

だから、実際にはありません 必ずしも、シンボル 我々はこのために小学校に使用しました。 しかし、そこにあなたがすることができますC.で ここで、xをyで割った剰余を言います このcontext--でこのパーセント記号 紛らわしいあなたの中にいるとき 二重引用符の、 printf関数の内部に、パーセント 書式指定子として使用されています。 

あなたは外のパーセントを使用する場合 数学的な表現でその、 それは、モジュラーのための剰余演算子です 私たちの目的のためにarithmetic-- ここでは、ちょうど何であるか、意味 xの残りの部分をyで割りましたか？ このため、xスラッシュyはyで割っxは。 yで割ったxの残りの部分は何ですか？ プログラマが言うように、それは、モッズyのXの。 

私はここにはミスを犯していないのであれば、私を聞かせて 、先に行くとint型を作る、複数の、素敵な ドットスラッシュint型。 とのは、先に行くとしましょう 行う、のは、1、10をしましょう​​。 すべての権利は​​、1プラス10は、チェック、11です。 1マイナス10がマイナス9で、確認してください。 

1回10チェック、10です。 10 is--で割った1 [OK]を、私たちはその1をスキップします。 10で割った1の残りの部分は1です。 そのとおりです。 しかし、ここでバグがあります。 

だから1私は私を入れて 正しくない、手渡します。 私が意味する、それが0に近いです。 私たちがしている場合は10で割った1、あなたが知っています、 いくつかのコーナーをカット、必ず、それはゼロです。 しかし、それは本当に1/10にする必要があり、 0.1、または0.10、0.1000、または等々。 

それは本当にゼロであってはなりません。 まあ、それはコンピュータであることが判明します 文字通りやって我々が行うには、それを言いました。 私たちは、yで割ったXのような数学をやっています。 そして、ラインごとにxとyの両方、 以前のコードで、整数です。 

また、15行目に、私たちはあります printf関数を語って、ちょっと、printfのプラグイン 整数は、プラグインの整数、 プラグインinteger--特異的に その後、X、次にY、およびX yで割りました。 xとyはint型です。 私たちはそこに良いです。 

しかし、xはxで何を分けているのですか？ x、yがあるべきであるで割りました、 数学的に、1月10日、または0.1、 これは実数、実数であります 、潜在的に、小数点を持ちます。 これは整数ではありません。 

しかし、最も近いものです 1/10、または0.1の整数？ ええ、それは一種のゼロです。 0.1は、これだけのようなものです。 そして、図1は、このくらいです。 だから1/10に近いです それは一つにあるよりも0。 

だからCはus--のために何をしていますか 種類の我々はそれを言ったので、to-- その整数を切り捨てています。 それは再び値を取っています 0.1000のようなものであると考え、 0など。 そして、それはすべてのものを切り捨てています 小数点以下 このように、すべて もの、そうでないので、 これは、整数の概念に適合 1、0、1、負のようなだけの数であり、 上下、それはすべてを捨てます あなたのため小数点以下 小数点をフィットすることはできません 定義により、整数インチ 

そこでここでは答えはゼロです。 だから、どのように我々はこれを修正しますか？ 我々は、すべて一緒に別のソリューションが必要です。 以下のように、私たちは、これを行うことができます。 

私が先に行くと、新しいを作成してみましょう ファイル、この1はfloats.cと呼ばれます。 そして、ここでそれを保存 同じディレクトリに、float.c。 そして、私が先に行くと、コピーしてみましょう 以前からそのコードの一部。 

しかし、その代わりに取得します int型は、はこのやろう。 私に浮動小数点値を与えます Xと呼ばれます。ここで、浮動小数点 値は文字通りです 浮動小数点で何か。 それは右に、左に移動することができます。 それは実数です。 

そして、私がいないと呼びましょう int型を得るが、フロートを取得し、 また、メニューの中でした C250ライブラリのオプション。 フロートにyと変更してみましょう。 これはfloatを得るになります。 

そして今、我々はint型をプラグインする必要はありません。 それは我々がパーセントを使用する必要が判明します フロートのためのF、フロートのパーセントF、 そして今、それを保存します。 そして今、指が交差し、作ります 山車、素敵な、ドットスラッシュ山車。 xは1 1のyになるだろう 10もう一度になるだろう。 

そして、素敵な、[OK]を私の添加が正しいです。 私はより多くを期待していました、 私はそれを書くのを忘れていました。 それでは、行くとこの論理エラーを修正しましょう​​。 

それでは、先に行くと、次のをつ​​かむしてみましょう。 私たちは、ほんの少しのコピーと貼り付けを行います。 そして、私はマイナスを言うつもりです。 

そして、私は時間を言うつもりです。 そして私は、分割されたと言うつもりです。 そして、私は、剰余をするつもりはありませんよ これは、ここのようなゲルマンではありません F、および時間で割っplus-- OK、それでは、再びこれをしましょう​​。 

山車を作り、ドットスラッシュ山車、 1、10、and--素敵な、いや、[OK]をクリックします。 だから私は馬鹿です。 だから、これは非常に一般的です コンピュータサイエンスの このような愚かな間違いを犯しました。 

教育的な目的のために、 私が本当にやりたいこと ここで科学を変更しました。 プラス、マイナスに、倍に、 うまくいけば、あなたのように、分割します この運動中に気づきました。 だから今のは、これを再コンパイルしてみましょう プログラムは、ドットスラッシュ山車を行います。 

そして三度目の、みましょう それは私の期待を満たしているかどうかを確認します。 1、10、1.000、OK、はい、入力し、 10.000で割った、0.100000です。 そしてそれはどのように多くの私たちが制御でき判明します 数字は、それらの小数点の後にあります。 私たちは、実際になります。 我々は戻ってそれに来ます。 

しかし、今、実際には、数学が正しいです。 だから、もう一度、ここでお持ち帰りは何ですか？ それはCであることが判明します ただ、strings--と、実際にだけでなく、 我々ので、実際にそこではありません CS50ライブラリを持つものを追加します。 しかし、単にint型はありません。 

山車もあります。 そして、それは他のデータの束が判明します 種類はあまりにも、私たちはずっと前に使用しますことを。 あなたは、単一たい場合判明 文字の文字、文字列ではありません、 あなただけの文字を使用することができます。 

あなたはブール値が必要な場合ことが判明し、 ブール値trueまたはfalseのみ、 CS50ライブラリのおかげで、我々はしました 同様にCにブールデータ型を追加しました。 しかし、それはまた、中に存在します 他の多くの言語にも。 そして、それはその時々判明します デフォルトで来るより大きな番号が必要 int型とフロートと。 

そして、実際には、二重の数であります それはない32ビットが、64ビットを使用します。 そして、長い長いその数はあります ない32、ビットが、64ビットを使用し、 それぞれ、浮動小数点のために それぞれの値と整数、。 だから今、実際にしてみましょう この動作を確認。 

私はここで先に行くつもりです 一他のプログラムをかき立てます。 ここでは、私が先に行くつもりです そして、CS50.h.が含まれません そして、私が行くよう、標準IO.h.を含みます 

そして、あなたは何かに気付くでしょう ファンキーはここに起こっています。 それはで物事をカラーコーディングいません それは以前と同じように。 そして、それは私ので、それはだ、判明します 事にファイル名を与えられていません。 

私はこの1つを呼び出すつもりです sizeof.cは、保存を押してください。 そして、私は非常に何が起こるか気づきます その黒の背景に白のコード。 今、少なくともあります そこにいくつかの紫色。 そして、それは構文が強調表示されています。 

、非常に単純に、私はきたからです ファイルの種類をIDEに語りました それはそれに名前を与えることであり、 具体的には、ファイルの拡張子。 さて、先に行くと、これを実行しましょう​​。 私は先に、非常に行くつもりです 単にfollowing--ブール値をプリントアウト パーセントLUです。 

我々は戻ってくるだろう 一瞬のもの。 そして、私はするつもりです ブール値のプリントサイズ。 そして今、ちょうど保存します 自分自身いくつかの時間、私はよ 全体をするつもり 一度にこれらの束。 そして、具体的には、私はするつもりです チャーチャーに変更。 この1、私は変更するつもりです ダブル、ダブルへ。 

この1、私は変更するつもりです フロートとフロートへ。 この1、私はするつもりです int型とintに変更します。 そして、この1、私は行きますよ 長い長いに変更します。 そして、それはまだ取っています 長い時間、長い長いです。 

そして、最後に、私が与えました 私自身は、1あまりにも多く、文字列。 これは、Cには、があることが判明します 呼ばれる特別なオペレータ その大きさは、文字通りです 、ときに実行しようとして、 私たちのサイズを教えて これらの変数のそれぞれ。 そして、これは、今、方法です 我々は戻って接続することができます 先週の議論に データ及び表現の。 

私が先に行くと、コンパイルしてみましょう のドットスラッシュサイズの大きさ。 そして、見てみましょう。 これは、C言語でいることが判明し、 具体的にCS50 IDE上で、 具体的に オペレーティングシステムUbuntuの、 64ビットオペレーティングこれは この場合のシステム、 ブール値に起こっています スペースの1バイトを使用します。 それはサイズを測定する方法です、 ないビットではなく、バイトインチ そして、1バイトは8ビットであることを思い出してください。 だからブール値、も、あなたかかわらず、 技術的にのみ、0または1を必要とします それは少し無駄です どのように我々はそれを実装しました。 実際に全体を使用するように起こっています byte--ので、すべてのゼロは、多分あります すべてのもの、またはそのような何か、 またはちょうど1 1 8ビットのうち。 

チャーは、また、文字に使用されます 先週あたりのASCII文字のように、 1文字にな​​るだろう。 そして、それは私たちの概念とアップsynchs それは、むしろせいぜい256 bits--されていません それはなしであるとsynchsアップ 8ビット、これよりも長いです 私たちのように多くの256のような値を与えます。 ダブルはに起こっています 8バイトまたは64ビットです。 

フロートは4です。 intが4です。 、長い長いは8です。 そして、文字列が8です。 しかし、それについては心配しないでください。 私たちは、その層をバック剥離するつもりです。 これは、文字列ができ、判明します 8バイトより長くすること。 

そして、確かに、私たちは書きました 既に文字列、Hello Worldの、 8バイトより長いです。 しかし、我々は戻ってくるだろう 一瞬のもの。 しかし、ここで持ち帰りは以下の通りです。 

任意のコンピュータが唯一の有限を持っています メモリとスペースの量。 あなただけの非常に多くの保存することができます お使いのMacまたはPC上のファイル。 あなただけで非常に多くのプログラムを格納することができます RAMはあっても、必ずしも、一度に実行されています 仮想メモリと、理由 あなたはRAMの有限量を持っています。 

そして、ちょうど場合picture--します あなたがラップトップを開いたことがありません または余分なメモリを命じました コンピュータのための、あなた それを知らないかもしれません お使いのコンピュータの内部 見えるものです このような小さな。 だから、これはという名前だけの一般的な会社です コンピュータ用のRAMを作ることが重要。 そして、RAMはどこのプログラムであります 彼らが実行している間住んでいます。 

だから、あなたが倍増すべてのMacやPC、上 プログラムをクリックして、それが開き、 そして、それはいくつかのWord文書を開きます またはそのような何か、 それは一時的に格納します RAM、RAMは高速であるため、 あなたのハードディスクよりも、または あなたのソリッドステートディスク。 プログラムはどこに行くので、それはちょうどです 彼らが実行しているときに生きて、 またはファイルが使用されている場合。 

だから、見るものを持っています あなたのラップトップのこの内部のように、 またはわずかに大きいもの デスクトップの内部。 しかし、キーはあなたしかいないのさ これらの事の有限数。 との唯一の有限量があります ハードウェアは、この机の上に座って右側 ここに。 

だから、きっと、私たちは保存できません 無限に長い数字。 そして、まだ、あなたが戻って考える場合 小学校、どのように多くの桁ができます あなたが右に持っています 小数点の？ そのことについては、どのように多くの桁ができます あなたは、小数点の左側にありますか？ 本当に、無限に多くの。 

今、私たち人間だけかもしれません 百万の発音を知って、 10億、兆、および 兆、そして京。 そして、私は私の限界に挑戦しています understanding--またはmy--私は理解して 数字が、私の 数字の発音。 しかし、彼らはとの無限大得ることができます 左に無限に多くの桁数 または小数点の右側にあります。 

しかし、コンピュータしかいません メモリの有限量、 トランジスタの有限数、A 内部の電球の有限数。 だから何が起こるとき、 あなたは、スペースを使い果たし？ 言い換えれば、あなたの場合 バック先週に思います 我々は数字について話したとき、 自体は、バイナリで表現されています 我々が持っていると仮定 ここでは、この8ビットの値。 

そして、私たちは7の1と1 0を持っています。 そして、私たちが望むと仮定 この値に1を追加します。 これは、今本当に大きな数です。 

私が覚えている場合、これは、254であります 先週の右から数学。 しかし、私は何を変更した場合 右端の0から1の？ 全体数の コー​​スは、8 1のになります。 だから我々はまだ良いです。 

そしてそれはおそらく表し 255、文脈にもよるが それは実際に表すことができ 負の数。 しかし、それ別の時間の詳細。 それは程度だようにこれは感じています 私は数えることができるほど高いです。 

今、それは8ビットのみです。 そして、私のMacは、確かに、方法を持っています メモリの8ビット以上。 しかし、それは有限持っています。 だから、同じ引数があっても、適用され、私たち 画面上でこれらのものの多くを持っています。 

あなたがしている場合はどうなります この数、255を格納し、 あなたは1ビット高いカウントするようにしたいですか？ あなたは255から256に行きたいです。 この問題は、もちろんであるあなたなら 先週のようにゼロからカウントを開始し、 あなたは、高カウントすることはできません 、256のように、おろか257 一人で258、メートルどのような理由ましょう あなたは1を追加するとどうなりますか？ 古い小学校を行​​う場合 アプローチは、あなたがここに1を入れて、 そしてその後、1プラス1が2であるが、それはです 本当にゼロは、あなたは、1を運びます 1を運ぶ、1を運びます。 これらの事のすべて、 これらの1ののは、ゼロになります。 そして、あなたは誰かのように、はい、羽目になる 左側に、1を指摘し​​ました。 しかし、すべては、次のことができます 実際に見ると、メモリ内に収まります 言うことですちょうど8 0の、あります いくつかの点でよろしければ、コンピュータ、 十分に高いカウントアップしようとした、あなたがしています ラップアラウンドに行く、それが思われます、 ゼロへ、または多分負 ゼロよりもさらに低い数字。 

そして、我々は一種のこれを見ることができます。 私が先に行くと書いてみましょう ここで実際に素早くプログラム。 私が先に行くと書いてみましょう オーバーフローと呼ばれるプログラム。 含まれ、CS50.hを含みます 標準IO.h--ああ、 私は本当に私のシンタックスハイライ​​トを逃しました。 それではoverflow.cとしてこれを保存してみましょう。 

そして今、int型メインvoid-- そして、長い前に、私たちはよ 理由を説明に戻ってきます 我々はint型の主な空隙を書いておきます。 しかし、今のところ、ちょうどやらせます 当然だが、それを取って。 のは、自分自身のintを与えてみましょう、 そしてそれを0に初期化します。 

私はzero--を取得するのは、その後、int型のためにやってみましょう 実際に、の無限ループをやらせます そして、何が起こるかを参照してください。 真の間、その後のnをプリントアウトしてみましょう ％は私、バックスラッシュnは、プラグインnです。 しかし、今、のは、nは、nに1を加えますしましょう​​。 

言い換えれば、それぞれにそのように この無限ループの反復、 のは、nの値をみましょう、 し、それに1を追加し、 左側の背中のnに結果を格納。 そして、実際には、我々は次の構文を見てきました わずかにこのような、簡単に。 クールなトリックではなく、あります このすべてを書き出します、 あなたは、実際には、n個のプラス1に等しいと言うことができます。 

それとも、本当に空想になりたい場合は、 あなたは、nプラスプラスセミコロン言うことができます。 しかし、これら後者の二つだけです 私たちは糖衣構文を呼びたいです 最初のもののために。 

まず最初に、より明示的です 完全に罰金、完全に正しいです。 しかし、これはより一般的ですが、私は言うでしょう。 だから我々は、ちょっとこれをやります。 

音のが今作ろうオーバーフロー、 むしろ不吉な、ドットスラッシュオーバーフロー。 どれどれ、nはかなり大きななってきました。 しかし、nは得ることができますどのように大きな、のは、考えてみましょうか？ 

nがintです。 私たちは、の大きさに一瞬前に見ました 例intが4バイトであること。 私たちは、4バイトがあり、先週から知っています 32ビットため8倍4は、それが32です。 それは40億になるだろう。 

そして、我々は800,000までです。 これはに永遠に取るために起こっています 私はおそらくできるだけ高く数えます。 だから私は、先に行くつもりです あなたが前に長いかもしれませんが、 そして、率直に言ってコントロールをコントロールC--を打ちます C、コントロールC一般的に多く、 手段はキャンセル。 残念ながら、このため クラウドで実行されています、 時々雲があります そんなにものを吐き出し、 そんなに出力は、それがために起こっています 私の入力のために少し時間がかかります クラウドに取得します。 だから私はヒットにもかかわらず、 数秒前にコントロールC、 これは間違いなく側であります 無限ループの効果。 

そのため、このようなケースでは、我々はしています であることを残して行きます。 そして、私たちは別のものを追加するつもりです こっちターミナルウィンドウ もちろんないプラス、と そのように、それはまだ考えているので。 とのは、先に行くとなりましょう もう少し合理的。 

私は先に行くと何をするつもりです この唯一の有限個の回。 のは、forループを使用してみましょう、 これは私が以前に言及しました。 これをやろう。 私が0の修整を受ける別の変数はintを与えます。 私は、私は++ 64のは言わせて、より少ないです。 そして今、私が先に行くと印刷しましょう nは外パーセント私、コンマnです。 そして、これはまだありますN-- 永遠に連れて行きます。 これをやろう。 

nが2の修整を受けるn回。 それとも私たちは空想かもしれません そして時間が2に等しい行います。 しかし、ちょうどn個としましょう 2倍、それ自体に等しいです。 換言すれば、この中 プログラムの新バージョン、 私は永遠に待ちたくありません 80万などから40億に。 ちょうどこのオーバーを取得してみましょう。 

それでは、実際にnは、それぞれの時間を倍にしてみましょう。 これは、リコール、倍増があります もちろん、持っていることの反対。 そして、先週のに対し、我々が持っています 何か再び、そして再び、 そして再び、超高速、 確かだろう倍増 最大の可能性への1から私たちを取得します 我々はint型とに数えることができる値。 

それでは、まさにこれを実行しましょう​​。 そして、私たちはずっと前に戻ってこれに来ます。 しかし、これは、再び、ちょうどのようなものです スクラッチでリピートブロック。 そして、あなたはずっと前にこれを使用します。 

これは単に、ゼロからカウントを意味します 64、まで、しかし、等しくありません。 そして、これが繰り返されるたびに ループは、ちょうど私をインクリメント保ちます。 だから私は++  - と、この一般的な構文 7行目だけの超一般的な方法です のいくつかの行を繰り返します コー​​ド、何回か。 どのコードの行？ これらの中括弧、あなたと 今から収集している可能性があり、 手段は、次の手順を実行します。 

それはときに、のようなスクラッチにです それは黄色のブロックを有しています 他の色その種類の 他のブロックを受け入れるか、抱擁。 それはどのようなものを巻き毛です ブレースは、ここでやっています。 だから、私は構文を得た場合right--あなたを C手段にニンジンシンボルを見ることができます それは私がした回数です この問題を解決しようとします。 それでははその1を取り除くましょう 完全に、そのウィンドウを閉じます。 そして、我々は新しいものを使用します。 オーバーフロー、ドットスラッシュを作ります オーバーフロー、入力して、すべての権利、 それは最初に悪い見えます。 しかし、のが時間内に戻ってスクロールさせ、 私はこの64倍をしたので。 

そして、初めて気づく、nは1です。 二度目は、nが、2であります その後4、その後、8、次に16。 そして、それはできるだけ早くようです 私は、およそ10億を取得します 私は再びそれを倍にすると、その 私に20億を与える必要があります。 しかし、それは結局のところ、それはです カスプ上の権利。 

そしてそれは実際にオーバーフロー 10億からint型 2おおよそ負へ 億、整数ので、 数字の私たちとは異なり、 先週と仮定しました、 正と負の両方であることができます 現実には、コンピュータインチ そして、それらのように、少なくとも1 ビットが効果的に盗まれました。 だから我々は本当に唯一の31ビットを持って、 または20億可能な値。 

しかし、今のところ、お持ち帰りはかなりあります 単に、どのようなこれらの数字は、 そして、数学は、あるものは何でも 悪い何かが、最終的に起こります 最終的にはあなたがしようとしているため、 ビットを1何回も並べ替えます。 そして、あなたは効果的にすべてから行きます 1のに多分すべて0、または多分 そのそれだけで他のいくつかのパターン 明らかに、文脈に応じて、 負の数として解釈することができます。 そしてそれは、最高の私を思わ この特定のプログラムで数えることができます 大まかにしか10億です。 しかし、ここでは部分的な解決策があります。 あのね？ 

私はから変更してみましょう 長い長いのint型。 そして、私がここで先に行ってみましょう そして、私が持っているつもりですsay-- unsigned long型に変更します。 それとも、私は自分自身を覚えたことがない、見てみましょう。 

それでは、先に行くと、オーバーフローしてみましょう。 いいえ、それはできません、LLDは、ありがとうございました。 だから時々クランに役立ちます。 私はどのような形式を覚えていませんでした 指定子は、long long型のためでした。 

しかし、確かに、クランは私に言いました。 グリーンは、良いのいくつかの種類であります まだあなたがミスを犯したことを意味します。 私がLLDを意味していることを推測しています。 

限り、私はそれはアドバイスだてみましょう 長い進数は、それを保存します。 ドット、私はそれを再実行してみましょう オーバーフローをスラッシュ、入力します。 そして今、どのようなクールなのはこれです。 

私が時間内に戻ってスクロールすると、我々はまだ開始します 同じplace--でカウント1、2、4、 8、16。 通知は、我々はすべての取得します 10億までの道。 しかし、その後、私たちは安全に20億に到達します。 

その後、我々は40億に到達します、 その後、80億、170億。 そして、我々はより高い行くと、 高く、より高いです。 結局、この、あまりにも、休憩。 

結局、長い長いと、 64ビットの値ではなく、これは あなたはカウント場合は32ビット値、 高すぎると、あなたは0を包み込みます。 そして、この場合には、我々が起こります 負の数で終わります。 

これは問題があります。 そして、それは、このことが判明します 問題はすべてのこと難解ではありません。 私は意図的にしたにも関わらず、 これらのミスでそれを誘導し、 それは、我々はすべての種類のそれを見る判明します 私たちの私たちの周り、または少なくともいくつか行います。 

レゴスターウォーズで、もしそうであれば あなたは今までゲームをプレイしましたが、 それはあなたの周りに行くことができ判明します LEGOの世界で物事を壊します、 本質的に、コインを集めます。 そして、あなたが今までプレイした場合 このゲームあまりにも多くの時間、 この無名の個人として ここでは、総数をしました あなたが収集することができコインの それは、40億を思わ、です。 

さて、それは実際に丸みを帯びていて。 だから、LEGOをしようとしていました フレンドリーな物事のユーザーを保持します。 彼らはに正確に2をそれをしませんでした 先週あたり32電源、。 しかし、40億は理由があります。 それは、この情報に基づいて、と思われます、 そのLEGO、および会社 、この実際のソフトウェアを作ったことを決めました そのコインの最大数 ユーザーが蓄積することができます で、確かに、40億、 彼らは自分のコードで選択したので、 どうやら、長い長いませんを使用するには、 ちょうど整数、符号なし 整数、その​​唯一の正の整数、 最大値は、おおよそです。 さて、ここでもう一つの面白い一つです。 ゲーム文明におけるだから、どの あなたのいくつかはと、見覚えがあるかもしれません それは数年前にあっていることが判明します このゲームができるのバグでした あなたが役割を果たした場合 ガンジーのゲームで、 代わりに、彼は非常に平和であることの、 代わりに、信じられないほど、信じられないほどでした いくつかの状況で、積極的な。 具体的には、方法その文明 作品であれば、あなた、プレイヤーということです、 民主主義を採用し、あなたの 攻撃性スコアが取得します 2ので、マイナスデクリメント マイナス、その後マイナスマイナス。 

だから、から2を引きます あなたの実際の反復。 残念ながら、あなたの反復がある場合 最初は1、あなたはそれから2を引きます 民主主義を採用した後、 ここかもしれないガンジーなど 彼は非常にpassive--だったので、行ってきました 攻撃性のスケールで1。 しかし、彼はその後、民主主義を採用している場合 彼は1から負の1に行きます。 

残念ながら、それらはありました 符号なしの数字を使用して、 それらがあっても負扱わ意味 数字彼らが陽性であったかのように。 そして、それはことが判明 1負の正同等、 典型的なコンピュータプログラムにおいて、255です。 ガンジーが採用しているのであれば 民主主義、したがってました 彼の攻撃性のスコアが減少し、 それは実際に255に周りロール 彼最大限に活用 ゲームで攻撃的な性格。 ですから、この上にGoogleにすることができます。 そしてそれは、確かに、でした 不慮のプログラミングのバグ、 それはかなり入っています 以来伝承。 

つまり、すべての楽しさとかわいいです。 ときに、実際もっと恐ろしいです 現実世界のデバイスではなく、ゲーム、 これらの同じバグを持っています。 実際には、ちょうど1年前の記事が来ました ボーイング787についてアウト。 

そして、最初に記事 一見は少し難解を読み込みます。 しかし、それは言った、この、ソフトウェア ボーイング社の脆弱性 新しい787ドリームライナージェット持ちます パイロットを引き起こす可能性 のコントロールを失います おそらく航空機、 半ば飛行中、FAAの職員 最近の航空会社に警告しました。 それは決意しました そのモデル787 電源が入ってきた飛行機 連続248日間 すべての交流、交流を失うことができます、 発電機による電力 同時に制御ユニット、GCUs、 フェイルセーフモードに入ります。 それは私を失うようなものです。 しかし述べたメモは、[OK]を、今私はそれを持って、 条件は、ソフトウェアによって引き起こされました にカウンタ内部 発電機制御 後にオーバーフローするユニット 連続電力の248日間。 私たちは、これを発行しています 損失を防ぐために通知 すべてのAC電気の つながる可能性があり、電力、 飛行機の制御の喪失インチ 

だから、文字通り、いくつかの整数であり、 またはいくつかの同等のデータ型 ソフトウェアで使用されています 実際の飛行機の中で あなたの飛行機を保つ場合に これは明らかに、十分な長さに あなただけ実行している場合場合することができます 彼らは常に、決して抜きます あなたの飛行機は、それが思われる、または そのバッテリーが死ぬせ、 最終的にはアップカウントアップ、となります、 そして、アップし、アップ、最大、およびアップ。 

そして、本質的に、A メモリの有限量 、オーバーフローにロールバックされます ゼロまたはいくつかの負の値、 副作用があります 驚くほど本物の現実 飛行機が必要になる場合がありますことを 効果的に、再起動します、 それが飛ぶように、または落ちるかもしれないが、悪化。 問題のため、これらの種類 私たちと一緒に残っています、 even--これは、2015年の記事でした すべてもっと恐ろしいです あなたは必ずしもないとき 、理解に感謝、または予想 エラーのそれらの種類。 

だから、他の1があると判明します データ表現についての悪い事。 それも、浮動小数点数であることが判明します 種類の欠陥のある、フロートので、あまりにも、 私は32ビットで提案された、または 多分64あなたは二重を使用している場合。 しかし、それはまだ有限です。 

そして、キャッチは、あなたができればということです 数字の無限の数を置きます 小数点以下、 ない方法はありません すべての可能を表すことができます 私たちが教えられた番号 小学校で世界に存在することができます。 コンピュータは、本質的に有しています これらの数字のサブセットを選択します 正確に表現します。 

今、コンピュータができます ラウンド多分少し、 あなたはおおよそストアに許可することができます あなたはおそらく場合があります任意の数。 しかし、単に直感的に、あなたの場合 ビットの有限数を有し、 あなただけそれらを並べ替えることができます 非常に多くの有限な方法インチ だから、おそらくできません 有限数を使用します ビットの順列の、 0と1のパターン、 無限を表現します 番号の数、 どのコンピュータがかもしれないことを示唆しています 非常によく、時々私たちにうそになります。 

実際には、はこのやろう。 私はCS50のIDEに戻りましょう。 私は先に行ってみようと 小さなプログラムを作成 ことを示すために、不正確と呼ばれます コンピュータは、確かに、不正確です。 

そして、私が先に行くと、始めましょう 前からそのコードの一部、 そして今ちょうど次の操作を行います。 私が先に行くとprintfのをやってみましょう、パーセント F、バックスラッシュnは、10で割った1。 言い換えれば、のは、深くにダイブしましょう 1と10で割ったような、1月10日まで。 確かに、コンピュータは1月10日を表すことができます。 

それでは、先に行くと不正確さを作ってみましょう。 どれどれ。 形式は、double型を指定します。 しかし、引数はint型を持っています。 どうしたの？ 

ああ、面白いので、それはです レッスンでは、前から学びました。 私はちょっと、コンピュータショー、言っています 私パーセントfのフロート。 しかし、私はそれを2 int型を与えています。 だから結局、私が修正することができます いくつかの方法でこの。 

私はちょうど1.0に1を回すことができる、と 10.0に10、これだろう、確かに、 変換の効果を有します それらflo​​ats--にまだうまくいけば 同じ番号。 それとも、何かがありますが判明します 私たちは、長い前に再度表示されます。 あなたは数字を唱えられます。 

あなたは、この括弧内のを使用することができます 式は、あなたが言うことができます、 ちょっと、コンピュータは、これを取ります 私が知っている10は、intです。 しかし、それをしてください、治療、 ているかのようにそれがフロートです。 しかし、これは不必要に複雑に感じています。 

私たちの目的のために、今日、 文字通りみましょう それらは、浮動小数点値を作ります このような小数点を持ちます。 私が先に行くと再実行してみましょう、作ります 不正確、良い、ドットスラッシュ 不正確、入力します。 [OK]を、我々は良い探しています。 

1は私によると、10で割った値 ここではMacが、確かに、0.100000です。 今、私はそこに小学校で教えられました 0の無限の数でなければなりません。 それでは、少なくとも試してみましょう それらのいくつかを確認します。 これは、printfのが少しあることが判明します 手の込んだ、まだ私たちが使用してきたよりも。 それはあなたが指定する必要はありませんが判明します ちょうど％のF、または単にパーセントの私。 あなたが実際に指定することができます ここにいくつかのコントロールオプション。 

具体的には、私が行きますよ 言って、ちょっと、printf関数、 実際に私に10小数点を示します。 だから、それは少し奇妙に見えます。 しかし、あなたはパーセントを言います、 ドット、どのように多くの数字 あなたは後に見たいです その後、小数点、およびf フラットのために、それはちょうどので、 ドキュメントは言います。 私が先に行くとそれを保存してみましょう。 

そして、あまりにも気づく私が取得しています 物事を再入力するのに疲れ。 だから、僕はアップの設定だし、 ダウンここに私のキーに矢印。 そして、私は、あなたを打つ続ければ コマンドのすべてを見ることができます 私が作った、または正しく行われています。 

そして、私は今、先に行くつもりだし、 実際に明らかに、それを使用しません。 不正確、ドットを作ります そうimprecision--スラッシュ 私はで教えられました 小学校は、チェックアウトされます。 私は、10進にそれを印刷する場合でも、 場所それは、確かに、0.10000です。 しかし、あなたは何を知っていますか？ 

のは少し貪欲取得してみましょう。 私は55を示し、のように、言ってみましょう 小数点以下のポイント。 それでは、実際にこれを見てみましょう スピンのためのプログラムアウト。 私はメイクでそれをリメイクしてみましょう 不正確、ドットスラッシュ、不正確。 

さあ、いくぞ。 あなたの子供の頃は嘘でした。 どうやら、10で割った1は確かにありま​​す 0.100000000000000005551115123-- 

何が起こっている？ あなたの種類の場合まあ、それは、判明します 根底にある外に十分に見えます この表現 数、それ実際に 正確に1/10、または0.1ではなく、 ゼロの無限数。 さて、それはなぜですか？ 

まあ、これは単純であるにもかかわらず、 私たち人間の数は、図1に示すように、10で除します それはまだ無限に多くの一つです 私たちが考え出すことができ数字。 しかし、コンピュータは表すことができます 有限個のように数字。 だから、効果的に、どのような コンピュータは、私たちは、その最も近い表示されています 数への近似 私たちは、1月10日であると信じたいです または本当に0.10000際限。 

そうではなく、しかし、これは それが得ることができるように近いです。 そして、確かに、あなたが見てみると ボンネットの下に、 我々は見ることによって、ここにあるように 小数点以下55桁、 私たちは、実際にその現実を参照してください。 さて余談として、あなたがしている場合 今までmovie--を見ました あなたのほとんどは、おそらくhaven't-- しかし、スーパーマン3何年か前に、 リチャード・プライヤーは、基本的にこれを活用します 多くを盗むために彼の会社で現実 ペニーの分画と画分の、 私が思い出すようcompany--ので、 それは本質的だったwhile--されています 合わないものを捨てます セントの概念に。 

しかし、あなたは、これらすべてのを追加した場合 再び小さな、小さな、小さな数字、 そして再び、そして再び、あなたはのように、することができます 彼の場合は、お金の良い量を作ります。 

同様の考え方は、以下によって食い物にされたこと より最近、それでも今、古いです オフィススペースと呼ばれる映画、 ここで、その映画の中の男、 それを台無しに、同じ事をしました 完全に、あまりにも多くの方法になってしまいました 自分の銀行口座にお金。 それはすべての非常に疑わしいでした。 しかし、一日の終わりに、 不正確さが私たちの周りのすべてです。 

あまりにも、それは、とすることができます ケースを驚くほど。 それが判明しているスーパーマン3 そこ脇やオフィススペース、 いくつかの非常に現実をすることができます 世界の波及効果 不正確なの現実の データの表現 それさえも私たち人間に この日は、必ずしもん 同様に、我々がすべきのように理解し、 またはとして頻繁に私達がすべきのように覚えています。 そして、確かに、以下のクリップがあります いくつかの非常に現実の世界を見てから あなたならば何が起こるかの影響 その不正確さを理解していません 数値表現で発生する可能性があります。 

[ビデオ再生] 

-Computers、我々はすべて受け入れるようになってきました 多くの場合、イライラの問題という them--バグ、ウイルスに行きます、 およびソフトウェアの不具合、 小さな価格が支払うために 利便性のために。 しかし、ハイテク、高速で 軍事や宇宙プログラムアプリケーション、 最小の問題ことができます 災​​害に拡大します。 

6月4日、1996年には、科学者たちは準備します 無人アリアン5ロケットを起動します。 それは科学的運んでいました 衛星設計 正確にどのように確立します 地球磁場の相互作用 太陽風と。 ロケットがために建てられました 欧州宇宙機関、 その施設からリフトオフ フランス領ギアナの海岸に。 

約37秒-atへ 飛行、まず彼ら 何かが間違っているのに気づきました。 ノズルは、中に旋回しました。 方法彼らは本当にいけません。 飛行中に40秒付近、 明らかに、車両がトラブルにありました。 

彼らが作ったとき、それはです それを破壊することを決定。 と範囲の安全管理者、 驚異的な根性は、ボタンを押し、 それができたの前に、ロケットを爆破しました 公共の安全に危険になります。 

 - これは処女でした アリアン5の航海。 そして、その破壊がかかりました なぜなら傷の場所 ロケットのソフトウェアに組み込まれて。 アリアン上-The問題がありました その数があったこと 表現するために64ビットを必要としました。 そして、彼らは変換したかったです その16ビットの数値です。 彼らは、と仮定しました 番号は行くことはありませんでした それらのほとんどのことは、非常に大きなものとします 64ビットの数値の桁はゼロでした。 彼らは間違っていました。 

1の-Theできません 受け入れるためのソフトウェアプログラム によって生成された番号の種類 他には、障害の根本にありました。 ソフトウェア開発はなっていました 新技術の非常に高価な部分。 アリアンロケットは非常にされています ソフトウェアの成功、そんなに それもあったために作成さ アリアン5で使用されます。 

-The基本的な問題はアリアンということでした 図5は、速かったより速く加速しました。 そして、ソフトウェアはいませんでした そのために占めています。 

ロケットの-The破壊 巨大な金融災害でした、 微小なソフトウェアエラーに起因するすべて。 しかし、これは初めてではなかったです 時間データ変換の問題 現代のロケット技術を悩ませていました。 

開始と、1991 -in 第一次湾岸戦争の、 パトリオットミサイル 同様の種類を経験しました 番号変換の問題。 その結果、28人、 28アメリカ兵、 殺され、約ました 100他の人が負傷し、 ときになっていたパトリオット、 着信scudsから保護するために、 ミサイルを発射することができませんでした。 

-Whenイラクはクウェート、そしてアメリカを侵略しました 初期の1991年に砂漠の嵐を立ち上げ、 パトリオットミサイルの電池が配備されました サウジアラビアとイスラエルを守るために イラクのスカッドミサイル攻撃から。 パトリオットは、米国の中​​距離であります 空気システムに面、製造 レイセオン社によります。 

パトリオット迎撃の-Theサイズ 自身についてのおおよそ20フィートの長さです。 そして、それは、約2000ポンドの重さ。 そしてそれは、程度の弾頭を運びます 私はそれが約150ポンドだと思います。 そして弾頭自体はあります 高性能爆薬、その その周りの断片を持っています。 弾頭の筐体であります 散弾のよ​​うに行動するように設計されています。 

-Theミサイルを搭載しています コンテナあたり4、 そして、セミトレーラーによって輸送されます。 

-Theパトリオット対ミサイルシステム 今、少なくとも20年以上さかのぼります。 これはもともと設計されました 防空ミサイルなど 敵の飛行機を撃墜します。 第一次湾岸戦争では、 その戦争が一緒に来たときに、 陸軍はそれを使用したいです scuds、ない飛行機を撃墜。 

イラク空軍がありました 問題のあまりありません。 しかし、陸軍はscuds心配していました。 それで、彼らがしようとしました パトリオットをアップグレードします。 

敵を-Intercepting マッハ5で走行ミサイル 十分に挑戦するつもりでした。 しかし、時パトリオット サービスに突入して、 陸軍は知りませんでした 作られたイラクの変更 そのscudsヒットすることはほぼ不可能。 

 - 何が起こったことはscudsであります 不安定であったで来ていました。 彼らはゆらゆらました。 この理由はありました イラク人、順番に 600キロを取得します 300キロのうち ミサイル、重量を取りました フロント弾頭のうち。 彼らは、弾頭を軽量化。 

だから今パトリオットです スカッドに来るしようとしています。 そして、ほとんどの時間、 時間の圧倒的多数、 それだけでスカッドによって飛んでいくのです。 パトリオットシステム・オペレータに一度 パトリオットは、その目標を逃した実現し、 彼らは、パトリオットの弾頭を起爆 それならば可能な死傷者を避けるために、 地面に落下させました。 

 - つまりは、ほとんどの人が見たものでした 空にはそれらの大きい火の玉、 とと誤解 スカッド弾頭のインターセプト。 

夜に-Although 空、ペイトリオッツが登場しました 成功したことにします ダーランで、Scudsを破壊し、 間違いがありませんでした その性能について。 そこでは、パトリオットのレーダーシステム 着信スカッドのトラックを失いました、 そして、により発足することはありません ソフトウェアの欠陥に。 これは、最初に発見イスラエル人でした 長いシステムが上であったこと、 長い時間の不一致 、埋め込まれたクロックに起因になりました システムのコンピュータインチ 

-About 2週間前 ダーランで悲劇、 イスラエルはに報告しました 国防総省 システムは時間を失っていたこと。 約8時間後、または実行されています、 彼らは、システムということに気づきました 著しく少ない正確​​になっていました。 国防総省は、によって答え パトリオット電池のすべてを伝えます システムのままにしないように 長い時間のために。 彼らはどのような長い時間言ったことはありませんwas-- 八時間、10時間、1000時間。 誰も知りませんでした。 

-Theパトリオットバッテリー 兵舎に駐屯 ダーランとその欠陥のある内部に クロックは100時間以上でした 2月25日の夜に。 

 - それは正確さに時間を追跡しました 10分の1秒程度。 第二の今、第十 興味深いの数であり、 それは表現できないので、 バイナリで正確に、どの それは正確に表現できないことを意味 任意の現代のデジタルコンピュータインチ それは信じがたいです。 

しかし、一例として、これを使用しています。 番号三分の一を見てみましょう。 三分の一にすることはできません 正確に小数で表しました。 三分の一は0.333であり、 無限大のために起こっています。 

でそれをする方法はありません 小数で絶対精度。 それはまさに問題のようなものです それは愛国者で起こりました。 システムは、走った長いです 悪化時エラーになりました。 

操作の100時間、-after 時間の誤差はわずか約三分の一でした 第二の。 しかし、ターゲットとの観点から ミサイルマッハ5で走行し、 それは追跡をもたらしました 600メートル以上のエラー。 それは致命的なエラーになります 何の上の兵士のため 起こったスカッド発射です 早期警戒衛星が検出さ 彼らはスカッドがあったことを知っていました 彼らの一般的な方向に来ます。 それは来ていたどこに彼らは知りませんでした。 

 - それは、レーダーまでになりました パトリオットシステムの構成要素 見つけて保つためにダーランを擁護 着信敵のミサイルの軌道。 

-Theレーダーは非常にスマートでした。 これは、実際に追跡するだろう スカッドの位置、 そして、次にどこおそらくそれを予測 レーダーが送信され、次回になります パルス出力。 それはレンジゲートと呼ばれていました。 

パトリオット一度-Then、 十分な時間をしていることを決定 戻って、次を確認するために渡されます この検出された物体の位置、 それが戻って行きます。 だから、間違ったに戻ったとき、 場所は、それが次に何のオブジェクトを見ません。 そして、それはありませんがあったと判断しました オブジェクト、それが誤検出でした、 トラックを削除します。 

-The着信スカッドは姿を消しました レーダー画面から。 そして秒後、それを 兵舎に激突。 スカッドは28を殺し、そして最後でした 1は、第一次湾岸戦争中に発射しました。 

悲劇的に、更新されたソフトウェア 翌日ダーランに到着しました。 ソフトウェアの欠陥がありました 、閉鎖を修正されて 問題を抱えた中1章 パトリオットミサイルの歴史。 

[ビデオ再生] DAVID J.マラン：これはすべてにあります オーバーフローの、これらの問題と言います そして、不正確さがあまりにも本物です。 だから、どのように我々はここに来たのですか？ 私達はちょうどのprintfの話から始まりました。 ここでも、この関数こと 画面に何かを印刷し、 私たちは、その後、導入しました 他のいくつかの機能 いわゆるCS50のライブラリから。 そして、我々は、に進みます 期限内にこれらを参照してください。 そして、我々は、特に、GET文字列を使用し、 そして、、int型を取得し、今もフロートを取得 そして、まだ他の人はまだ我々が発生します やがて自分自身を使用します。 

しかし機会に、持っています 我々はすでに必要性を見て これらの機能が戻って手何を格納するには？ 彼らは私たちのバック文字列を渡し、 またはint型、またはフロート。 そして、時には我々はそれを配置する必要があります どこかの文字列、またはint型、またはフロート、。 

そして、それらの事を格納するために、ちょうどリコール スクラッチのように、我々は変数を持っています。 しかし、スクラッチとは異なり、 C言語で、私たちは実際の型を持っています variables--データの 種類、よりgenerally-- その中で、文字列、int型、A これらの他のものはまだ浮く、と。 

だから、我々はC言語で変数を宣言するときに、 我々は、我々のデータ型を宣言する必要があります。 これは、我々がよものではありません 学期の後半で行う必要があります 私たちは他の言語への移行など。 しかし、今のところ、我々は必要なのですか 事前に先験的に、 コンピュータどのタイプに説明 変数の我々はそれが私たちを与えたいです。 

さて、一方、印刷するには データ・タイプのもの種類 私たちは何を期待するのprintfを伝える必要があります。 そして、我々は、文字列のパーセントのを見ました そして、整数のパーセント私、 すでに、いくつかの他のもの。 そして、それらは単に要件です 視覚的なプレゼンテーションのため その情報の。 

そして、これらのそれぞれは、実際にすることができます 何らかの方法でパラメータ化または微調整、 あなたがコントロールを促進したい場合 あなたが得る出力のタイプ。 そして、実際に、それだけではないことが判明します 新しいラインのバックスラッシュnがあります。 バックスラッシュと呼ばれる何か他のものがあります キャリッジリターンのためのrを、その に、より似ています 古い学校のタイプライター、 また、Windowsは、長年にわたって使用しました。 

タブのバックスラッシュトンがあります。 あなたがしたい場合はこと、が判明 文字列の内側に二重引用符、 我々が使用したリコール 二重引用符、二重 左右の引用 これまで私たちの文字列の両端。 それは物事を混同しているように見えるだろう。 

あなたは二重引用符を入れたい場合 確かに、string--との中間の、 見て混乱しています。 とになるので、あなたは、エスケープする必要が 、何かで二重引用符を話します 以下のような、文字通り、二重引用符をバックスラッシュ。 そして、いくつかの他はまだあります。 そして、我々はそれらの多くを参照してくださいよ 実際に使用する前に長いです。 

それでは、今から移行してみましょう データ、および表現、 そして、算術演算子、すべての 私たちにいくつかの建物を与えたの 再生するとブロック。 しかし、今のは、実際に与えてみましょう 私たちの語彙の残りの部分 我々はすでに持っていたこと スクラッチとの最後の週 いくつかの他のを見てとることにより、 C--中の構築物ではないそれらのすべて。 しかし、アイデアは我々です 本当にただ見てについて からの翻訳を強調します 別の言語、スクラッチ、C. 

そして時間をかけて、我々は拾いますよ 私たちのツールキットのためのより多くのツール、 そう構文的に、話します。 そして、確かに、あなたはそのアイデアが表示されます 今先週からかなり精通しています。 それでは、これを実行しましょう​​。 

それでは、先に行くと、プログラムをかき立てるしてみましょう それは実際にいくつかの表現を使用し、 ブール式。 私はここで先に行ってみよう 新しいファイルを作成します。 私はこのcondition.cと呼ぶことにします。 

私は先に行ってみようと CS50ライブラリが含まれています。 そして、私が先に行くと含ませて 我々の機能のための標準IO.h、 そしてより多くのそれぞれのprintf、と。 私は自分自身の決まり文句を挙げてみましょう その説明我々はよint型メインボイド、 戻って将来的に来ます。 

今、私は先に行くと与えてみましょう 自分GET INTを介してint型。 そして、私が先に行くと、これを実行しましょう​​。 私はみましょうless--ある場合、私は言いたいです 負、正の区別、 またはゼロ値。 

iがゼロより小さい場合だから、私を聞かせて ただ、このプログラムは単純に言って持っています 他の負の、バックスラッシュnは、 iがゼロよりも大きい場合。 今私は、もちろん、言うつもりです printfの正、バックスラッシュn個。 そして、他の私はこれを行うことができますif--。 

iが0に等しい場合、私は行うことができます。 しかし、私はで作ることにしたいです すでに少なくとも1ミス。 等号があることを思い出してください 私たち人間はそれを知っているように、等しくありません。 

しかし、それは代入演算子です。 そして、我々は上の0を取るにしたくありません 右と左の私にそれを置きます。 したがって、この混乱を避けるために、または おそらく、等号の誤用は、サインイン 人間は何年か前に決めました その多くのプログラミング言語で あなたは等価性をチェックしたいとき 左と右の間、 あなたが実際に相当します使用しています。 だから、等号は二回に署名ヒット。 あなたは右から割り当てたいとき 左に、あなたは、単一の等号を使用します。 だから我々はthis--他に何ができます iが等しい場合にゼロに等しいです。 

私は、行くことができると 私の中括弧を開き、 そして、行われ、printfの0、バックスラッシュnは、言います。 しかし、どのようにこれらのを覚えています 道路のフォークが動作することができます。 そして、実際には、ちょうどロジックについて考えます。 私は数値です。 それは具体的には、整数です。 そして、それは少なくなるだろうことを意味します 0、0以上、または0より。 だから、これのようなものがあります 暗黙のデフォルトのケース。 

そして私たちは、ただ好きでした スクラッチ、それ以外の場合で済まします ちょうど他に言います。 論理的には、あなたの場合 プログラマはそこだけ知っています 3つのバケットいるAへ シナリオは、最初のfall--することができます 第二、または第三 このcase--でありません 追加の精度を追加する気に そしてそこに追加のロジック。 ちょうどを進めます ここでは、他のデフォルトの場合。 

さて、先に行きましょう これを保存した後、作ります 条件は、スラッシュドットconditions-- ない優れたユーザーインターフェース、 私はプロンプトいないよので、 ユーザ、私は先に述べたように。 しかし、それは大丈夫です。 私たちはそれをシンプルにしておこう。 のは、数42を試してみましょう。 そして、それはポジティブです。 番号を試してみましょう 負、42負。 

のは、値0を試してみましょう。 そして、確かに、それは動作します。 さて、あなたは前に問題に表示されます 長い、テスト物事3回、 おそらく十分ではありません。 あなたは、おそらくいくつかをテストします 大きな数字、いくつかの小さいです 数字、いくつかのコーナーケース、など 私たちはそれらを記述するために来ます。 

しかし今のところ、これは かなり簡単なプログラム。 そして、私は、論理的に、かなり確信しています それは3つのケースに収まります。 そして、確かに、たとえ私たちは 潜在的な弱点に焦点を当てました 不正確とオーバーフローの、で 現実CS50の問題の多く、 我々が心配するつもりはありません すべての時間、約、 オーバーフローのそれらの問題と 不正確、なぜなら、実際には、Cで、 それは実際にすべてではないこと それらの事を避けるのは簡単。 あなたがカウントアップしたい場合 大きな、そしてより大きな、そしてより大きな、 それは技術はあなたがそこにある判明します しばしば呼ばれるものを含む、使用することができます ライブラリ、コードのコレクション、その 他の人々はあなたが使用できることを書いて、 などと他の言語 実際にJavaおよび他、 それは非常に簡単にします さらに高いカウントします。 だから、本当にこれらの危険の一部であります あなたが使用している言語の関数。 そして、今後数週間以内に、我々はよ 本当にどのように危険なCを参照してください あなたはそれを正しく使用しない場合することができます。 しかし、そこから、とと Pythonの、およびJavaScript、意志 我々はいくつかの追加の保護を上の層、 そしてそれらのリスクの少ないを実行します。 

それでは、もう少し作ってみましょう 私たちのプログラムで興味深いロジック。 だから私は先に行くと作成してみましょう 論理と呼ばれるプログラム ちょうどので、私はいくつかで遊ぶことができます 実際のロジック、logical.c。 私はいくつかをコピーして貼り付けます 以前からコードので、私は戻って取得 この素敵な出発点に。 

私にこの時間をしてみましょう私はやるchar型のC. それをCの名前を提供するつもり それは従来のだという理由だけで、 ユーザーから文字を取得します。 とののようなふりをしましょう 私は部品を実装しています そのRmのプログラムの、削除 その前に、プログラムは、ユーザを促しました ファイルを削除します。 我々はこれをどのように行うことができますか？ 

Cが等しい場合、私は、言いたいです 、引用引用終わり、等しいです yが、その後、私が仮定するつもりです ユーザーは、はい選択したこと。 私はイエス印刷するつもりです。 それは実際に書いていた場合 除去プログラム、 我々は、ファイルを削除することができ コー​​ドの複数行で。 しかし、我々はそれをシンプルにしておこう。 

そうでcが等しい場合N--等しいです そして今ここで、私は言うつもりです、 ユーザーは無いことを意味している必要があります。 そして他に、あなたは何を知っていますか？ 私は他に何かわかりません ユーザーが入力しようとしています。 だから、僕はそれを言うつもりです それが誤りである、何でも 彼または彼女は実際に型指定されました。 

それでは、ここで起こっているの？ 根本的な違いがあります 私が過去にやった対。 二重引用符、二重引用符、二重 引用符、および、まだ、単一引用符、 単一引用符。 それはときにすることを、C言語で判明します あなたは、文字列を書きたいです、 あなたは私たちがきたと同じように、二重引用符を使用しています printf関数ですべてのこの時間を使って。 

しかし、あなただけに対処したい場合 単一の文字、いわゆるチャー、 あなたは実際には単一引用符を使用します。 プログラムされてきたあなたの人々の 前に、あなたが持っていない可能性があります このことを心配していました 特定の言語で区別。 Cでは、それは問題ありません。 だから、私はchar型を取得し、私が欲しいとき equalsを使ってその文字を比較します YまたはNのようないくつかの文字に等しく、私は、 確かに、単一引用符を持っている必要があります。 

さて、先に行くと、これを実行しましょう​​。 それでは、先に行くと作るのですかしてみましょう 論理ドットが論理スラッシュ。 そして今、私は、プロンプトが表示されています。 だから、おそらく、より良いユーザーエクスペリエンス 実際に何がここで行うように私に言うだろう。 しかし、私はちょうど盲目的に行きますよ 素敵な、[OK]を、イエスのために、yを言います。 

nは素敵な、ないために、のは再びそれを実行してみましょう。 私が知っている特定の人のように仮定し、 私のキャップはキーがあまりにも頻繁にすべての上にあるロック。 だから私は、首都Yは、入力エラーを行います。 OK、それは私が期待していまさにではありません。 確かに、コンピュータ 文字通り何をやっています 私はのためにチェックdo--するためにそれを言いました 小文字のyと小文字のn。 これは良いように感じることはありません ユーザーエクスペリエンス、しかし。 私はのために聞いてみようと受け入れ 小文字または大文字のいずれか。 だから結局、あなたがしたいことがあります スクラッチのような何かを言うために、 文字通りまたはCイコールのような 資本単一引用符で囲まれたyは等しいです。 結局のところ、Cは持っていません このリテラルキーワードまたは。 

しかし、それは2つの垂直バーを持っています。 あなたは、通常、Shiftキーを保持する必要が あなたはUSキーボードを使用している場合、 そして、垂直バーをヒット あなたのリターンキーの上のキー。 しかし、この垂直バー 垂直バーは、意味や。 

場合は、対照的に、我々が望んでいました 言うと、スクラッチのようにするために、 我々はアンパサンドアンパサンドを行うことができます。 つまり、ここには論理的な意味がありません 人間ではない可能性がなかったため、 yおよび小文字のyの両方を入力しました そして、同じ文字として資本Y。 だからかである私たちはここで何を意図しています。 

だから私は両方の場所でこれを行う場合、またはc 、首都N、今再実行するに等しい等しいです 論理作る、論理再実行してください。 今、私は、yを入力することができます。 そして、私は再びそれを行うことができます 首都Y、または資本N. そして、私は、追加で追加することもできます まだ組み合わせ。 

だから、これは論理的です 限り、今のようなプログラム 私はのために論理的にチェックしています この値またはこの値。 そして、私は、必ずしも、する必要はありません 2以上のIFSまたは他のIFSを思い付きます。 私は実際のいくつかを組み合わせることができます このように一緒にロジックを関連。 だから、これは良いだろう 単により設計 Cは小文字のyに等しい場合、言って、 cは資本Yに等しい場合、それ以外の、はい印刷 cが等しい場合、他の、はい印刷 他の言葉でlower--、 あなたが持っている必要はありません より多くの枝。 あなたは同等のいくつかを組み合わせることができます このように論理的に分岐します。 

それでは、ちょうど1を見てみましょう 最終的な成分、1最終構築物、 そのCができます。 そして、我々は中に戻ってきます まだ他の人に未来。 そして、我々は見ることによって結論付けます code--のない正確さで work--するためのコードが、設計を取得 コー​​ドの、と早い段階でこれらの種を植えます。 

だから私は先に行くとしましょう ここで新しいファイルを開きます。 あのね？ 私は再実装するつもりです その同じプログラム、 しかし、別の構成要素を使って。 

だから私はすぐに自分自身を与えてみましょう CS50.hを含むようにアクセス CS50ライブラリの、 printfのための標準的なIo.h。 私に私のint主な空隙を与えます。 そして、ここの上、みましょう 私は先に行くとこれを行います。 

シャアcは、直前のように、文字を取得します。 そして、私は新しい構文を使用するつもりです どのような文字で、スイッチnow--？ だから、スイッチは一種のようなものです 列車のトラックを切り替えます。 それとも、本当に、それは一種のです それ以外の場合、もし他にあれば、 しかし多少異なる書かれて。 

スイッチは次のようになります。 あなたはスイッチがあり、その後、どのような 文字や数字、あなたが見てみたいです、 のように、その後いくつかの中括弧 スクラッチ、ちょうどこのようなものをやると言います。 そして、あなたは異なる場合があります。 

あなたがあれば、他は使用しないでください。 あなたは文字通り単語のケースを使用しています。 そして、あなたはこのような何かを言うでしょう。 

だから、小文字のyの場合には、 または資本Yの場合には、 先に行くと、イエスをプリントアウト。 そして、スイッチから抜け出します。 それでおしまい。 もう終わった。 

いわば、場合そうで、 小文字のn、または資本N、 その後、先に行くと印刷 アウトなし、その後破ります。 Else--とされ、この種の デフォルトの場合indeed--のprintf error-- ちょうど良い測定のために、しかし 論理的に、このブレークは必要ありません 我々は終わりにしているので、 とにかくスイッチの、 私は今スイッチを抜け出しています。 だから、これは少し違って見えます。 

しかし、論理的に、それはです 実際に同等。 そして、なぜあなたは使用します 一方が他方の上？ 時には、単に個人的な好み、 時には美学、 私はこの一目場合 今、何かがあります 以下のために言うことにします このコードの可読性。 私はこの事実を気にしない、意味します コー​​ドは部屋に私たちの多くの新機能です。 

しかし、それはちょうど種類のかわいいです。 あなたは、小文字のY、資本Yを参照してください 小文字のn、資本Nのデフォルト、 それだけの種類のジャンプ 方法であなたにアウト 間違いなく、多分、その 前の例 IFS、縦棒と、 そして、それ以外のIFSは、持っていない可能性があります。 だから、これは本当に個人的な問題です 選択、本当に、または読みやすさ、 コー​​ドの。 

しかし、機能性の面で、私を聞かせて 先に行くとスイッチを作る、ドットスラッシュ スイッチは、今、小文字のyを入力します 首都Y、小文字のnは、資本N、 それだからダビデは、再試行します ない単一の文字。 期待通りのは、X、エラーをしましょう​​。 そして、logically--これは何かであります 私もgeneral--に励まします 我々は唯一の引っ掻きているものの これらの機能のいくつかの面。 

ときに、それは明白ではないかもしれません 自分では、キーボードで座ります これはどのように作動しますか？ これは何をしますか？ 持っていることについて美しいもの ラップトップ、またはデスクトップ、またはアクセス コンパイラを使用して、コンピュータに、 そして、このようなコードエディタで、 あなたはほとんど常にこれらに答えることができますされています ちょうどしようとすることによってあなた自身のための質問。 

例えば、修辞場合 手元の質問があったが、 あなたが忘れてしまった場合何が起こります あなたのbreak文？ これは実際に 行うには非常に一般的なもの、 それは見ていないので、 あなたのように実際にそれらを必要としています。 彼らは本当にあなたを完了しません カッコやカーリーのように思いました ブレースはありません。 それでは、先に行こうと コー​​ドを再コンパイルし、参照してください。 だからスイッチ、ドットスラッシュスイッチを作ります。 小文字を入力してみましょう yは、トップケースは、入力します。 だから私は、yを入力しました。 

プログラムは、はい、いいえ、エラーと述べ、 あるかのように、その心を変えました。 何が起こるので、しかし、それは一種の、でした スイッチとその最初のケースであります 試合は、本質的にちょっと、コンピュータを意味し、 その下のすべてのコードを実行します。 そして、あなたは休憩を言っていない場合、または 休憩を言っていない、または休憩を言うことはありません、 コンピュータが吹くために起こっています これらの行のすべてを介して、 そして、まではそれらのすべてを実行します その中括弧になります。 だからブレーキは、確かに、必要です。 しかし、ここでお持ち帰りは場合には、 疑いで、何かを試してみてください。 たぶん、最初のコードを保存し、 または余分なファイルに保存します あなたはについては本当に心配している場合 めちゃくちゃし、回復すること あなたが知っている仕事が働いています。 

しかし、物事を試してみてください。 そして、おそらく、など恐れることはありません コンピュータが行うかもしれないものの、 またはあなたが何かを壊すかもしれません。 あなたは、常に戻すことができます いくつかの以前のバージョンに。 

それでは、見ることによって終了してみましょう コー​​ドのデザインで。 我々は書くために今、この能力を持っています 条件、書き込みループ そして、変数、および通話機能。 だから、率直に言って、私たちは、背面の一種です ここで我々は、スクラッチで週間前でした あまり説得力のあるテキストとはいえ スクラッチよりも環境ができます。 

しかし、我々は取得してきたどのように迅速に気付きます それはだ場合であっても、その語彙、 でシンクする少しの間を取るつもり、 我々は今、この語彙を使用できるように、 もっと面白いプログラムを書き込みます。 そして、の赤ちゃんのステップを見てみましょう それに向かって、は以下の通り。 私は先に行ってみようと ここで新しいファイルを作成します。 

私はこれをコールするつもりです prototype.c、と紹介 初めて、能力 独自の関数を作ります。 あなたのいくつかは持っている可能性があります スクラッチでこれを行って、 あなたを作成することができます スクラッチで独自のカスタムブロック、 そしてその後、所定の位置にドラッグします あなたは、Cでみたいところはどこでも そして、ほとんどのプログラミングで 言語は、あなたが正確に行うことができます that--独自の関数を作ります、 彼らはすでに存在していない場合。 

だから、例えば、私は先に行ってみましょう そして、CS50.hを含み、および含まれます 標準IO.h、int型メインボイド。 そして今、我々は持っています 行く準備ができてプレースホルダー。 私は印刷物事を保ちます 人の名前、今日のように。 そしてそれはlike--感じ そこにあれば素敵ではないでしょう 印刷nameという関数がありましたか？ 私はprintfのを使用する必要はありません。 私が覚えておく必要はありません すべての書式コード。 なぜない私、またはなぜ 、私の前に誰かがしませんでした 印刷と呼ばれる関数を作成 名前、いくつかの名前を与えられたことを、 単にそれをプリントアウト？ 

言い換えれば、私は、ちょっと、言うなら コンピュータは、私の文字列を与えます そのようなのためにユーザに尋ねることで、 CS50のget文字列関数を介して。 ねえ、コンピュータにその文字列を入れて 左手側の変数 とだそれを呼び出します。 そして、コンピュータちょっと、先に行きます そして、行って、その人の名前を印刷します。 

今、それはので、いいだろう このプログラムは、適切に、命名します 行うことになっているものを私に伝えます これらの関数の名前を介して。 私が行ってみようとプロトタイプを作成し、入力します。 そして、残念ながら、 これは、飛行するつもりはありません。 

Prototype.c、7行目、キャラクター 5、エラー、暗黙の宣言 機能印刷名の C99、C99に無効です Cのバージョンを意味します それは1999年に出てきました。 それで全部です。 

だから私は何を知りません このすべては、まだ意味します。 しかし、私は赤でエラーを認識しません。 それはかなり明白です。 

そして、それはとのようです ここでは緑の文字、 問題は、印刷名でオープンしています 括弧秒、クローズ括弧、セミコロン。 しかし、の暗黙的な宣言 先ほど簡単に参照した機能。 これは、単に、そのクラン手段 私が何を意味するか知っていません。 

私はそれがだと語彙を使用しました 見られないか、または以前に教示されていません。 そして、私はそれを教える必要があります この関数は何を意味するのか。 だから私は先に行くとそれを行うつもりです。 

私は先に行くと、実装するつもりです 私自身の機能は、Print名前を呼ばれます。 そして、私は、次のように言おうとしているんです それがこの、printf関数、こんにちは、パーセントを行います 秒、バックスラッシュnは、名前、セミコロン。 だから、僕は何をしましたか？ 

だから、に、判明します 独自の機能を実装し、 私たちは、この種のいくつかを借ります メインと同じ構造 私たちはしてきたこと 当たり前の、そして私 知っているだけでコピーして ほとんど何を貼り付けます 私は過去に書いてきました。 しかし、ここでのパターンに気づきます。 int型、メイン、ボイド、我々は離れていじめるだろう やがてそれが実際に何を意味するのか。 

しかし、今日のために、ちょうど 並列性に気付きます。 ボイド、印刷名 文字列名は、とてもあります 紫色のキーワード、その 我々が開始するつもりです 戻り値の型の名前を呼んで 機能し、入力。 だから、実際には、我々は蒸留することができます 先週のようなこの種の 、これは名前またはあるとして 私たちがしているコードのアルゴリズム write--に行きます 基礎となるアルゴリズム コー​​ドは、我々は書くつもりです。 

これは、入力されます。 これは、出力されます。 この機能は、印刷名は、あります 名前と呼ばれる文字列を取るように設計されました、 または何でも、入力として、及びボイド。 それは、何も返しません 以下のような文字列を取得したり、intはありません取得します。 だから、戻って私に何かを手に起こっています。 ちょうど持っているために起こっています 副作用、いわば、 人の名前を印刷します。 だから私は、7行目、気付きます 印刷名を呼び出すことができます。 10行目、私が定義することができます または印刷名を実装します。 しかし、残念ながら、それは十分ではありません。 

私は先に行ってみようと 保存した後、これを再コンパイルします。 おっと、今、私はそれを作りました 悪いことに、それは思われます。 のだから、暗黙的な宣言 機能印刷名が無効です。 そして、再び、多くの誤りがあります。 しかし、私も、以前の警告として あなたがに圧倒取得する場合、 または少し悲しいほど多くを見るために エラーは、最初に焦点を当て 最初に、それは可能性があるため、単に カスケード効果を有していました。 より具体的にはC、またはクランそう まだ印刷名を認識しません。 

そして、それはクランためです、 設計によって、一種のダムです。 それは、あなたがそれを行うには言うことありません。 そして、それは唯一のためにそうします あなたは何をすることを教えています。 

だから私は、ライン4上の主な定義されています 以下のような私たちはかなり頻繁に行ってきました。 私はライン10上の印刷名を定義しました。 しかし、私は使用しようとしています ライン7上の印刷名。 

それは早すぎる、まだ存在していません。 だから私は賢いこと、などが挙げられるかもしれません、 [OK]を、ので、ちょうど一緒に演奏しましょう​​、 印刷名を上に移動 ここで、再度コンパイルします。 何てことだ。 出来た。 それはそれと同じくらい簡単でした。 

しかし論理はまさにそれです。 あなたはクランを教えるために持っているもの、それ 最初の関数を定義することです。 次に、あなたがそれを使用することができます。 しかし、率直に言って、これは感じています 滑りやすい坂道などです。 

だから毎回私が実行します 問題の中に、私はちょうどよ 強調表示し、コードをコピーしよう 私はそれをカットし、ここでそれを貼り付けて、書いています。 そして、確かに、我々は可能性 いくつかのシナリオを工夫 ここで、一つの機能の​​かもしれません 別のを呼び出す必要があります。 そして、あなたは、単にすべての置くことができません 他のすべてのような機能。 

だから、それはありますが判明します よりよい解決策。 私たちは、これがすることが残すことができます。 そして、率直に言って、それは、一般的にうれしいです そして、便利で、良いデザイン なぜなら、再び、第一主置くために、 ちょうど緑のフラグがクリックされたときのように、メイン、 それは、その関数であります デフォルトで実行されます。 だからあなたにも置くことがあるかもしれません そのファイルの先頭に そのため、ユーザーまたは任意の時 他の人間には、ファイルを見て あなたは何が起こっているのか知っています ちょうどメイン1を読み取ることで。 だから結局、私たちは、クランを伝えることができます 積極的に、ちょっと、クラン、ライン4に、 私が実装することを約束します 印刷と呼ばれる機能 名前と呼ばれる文字列を受け取り名前 入力として、ボイド何も返しません。 そして、私はに周りを取得します 後でそれを実装します。 

ここでは主な付属しています。 主は現在、9行目で使用することができます 印刷名クラン理由 最終的には、それを信頼され、 それは定義が発生します 印刷名の実装の。 だから私のファイルを保存した後、しましょう 私は先に行くと、プロトタイプを作成し、 今回はよさそうです。 ドットスラッシュ、プロトタイプ、私を聞かせて 先に行くと名前を入力します。 デイヴィッド、こんにちはデビッド、Zamila、ハロー Zamila、そして、確かに、今それが動作します。 

だからここ成分は、私たちがしたことです カスタムのように、カスタム関数を作りました スクラッチブロック我々はそれを呼んでいます。 しかし、スクラッチとは違ってどこにすることができます ちょうどそれを作成し、それを使用して起動し、 今、私たちはしなければなりません もう少し知識をひけらかします、 実際クランを訓練 使用する、またはそれを期待します。 さて、余談として、なぜこのすべての時間を持っています 我々は、以下を含む信仰にやみくもになって 標準IO.h含むCS50.h、と？ 

まあ、それは結局のところ、 いくつか他のものの中で、 すべてのことは、これらのドット時間でです ファイルことが起こるのファイル、。 彼らはいわば、ファイルヘッダいます。 彼らはまだCで書かれている。しかし 彼らは、ファイルの異なる種類です。 

今のところ、あなたはかなり仮定することができます CS50.hの内側にあるものすべてのこと このようないくつかのワンライナー、ではありません 印刷名と呼ばれる機能のため、 しかし、文字列を取得するためには、Get フロート、およびいくつかの他。 そして、同様のプロトタイプがあり、 1ライナー、標準IO.hの内側 に今あるのprintf、用 私自身の印刷名機能。 だから、他の言葉で、この全体の時間、私たちはしました やみくもにコピーして貼り付けられて 含む、これを含みます つまり、何が起こっているの？ これらは、手がかりのちょうど一種であります どのような機能をとして打ち鳴らすします 、確かに、ちょうど、実装されています 別の場所で別のファイルで システムの他の場所に。 

だから我々は、印刷名を実装しました。 それは、この副作用を持っています 画面上で何かを印刷します。 しかし、それは実際にはしません 私に何かをバック手。 どうやって行くのです そのプログラムを実施 バック私に何かを手渡していますか？ 

さて、これを試してみましょう。 私が先に行くと実装してみましょう return.cと呼ばれるファイル 私たちはどのように何かを証明することができます 以下のような文字列を取得し、またはINTを取得し、 実際に戻っています 戻ってユーザーに何か。 それでは、先に行くと、int型の主な空隙を定義してみましょう。 

そして、再び、将来的には、よ そのint型とその空隙何を説明 実際にやっています。 しかし、今日のために、我々はよ 当然だと思う。 私は先に行くと、printfのつもりです、 優れたユーザーエクスペリエンスのために、xがあります。 そして私は待つつもりです 私を与えるために、ユーザは、get int型を持つX。 

そして、私は先に行くつもりです 正方形にXをプリントアウト。 だから、あなたが唯一持っているとき 一般的に、キーボード、人々 少しニンジンを使用 キーボード上のシンボル 電源に表現します のの、または指数。 だから私は、二乗が存在しているxは。 

そして今、私はこれを行うつもりです。 私はちょうど、xが何do--でした 乗？ xの2乗をx倍のxです。 

そして、我々はいくつかのこれをしませんでした 今日既に前の時間。 これは、ように感じることはありません すべてのその多くの進歩。 あのね？ のは、そのアイデアの一部を活用してみましょう 抽象化の最後の時間から。 

それがあれば素晴らしいと思いません 呼び出された関数があります まさにその正方形の？ の終わりに、まだそれ、 日、同じ数学を行います。 しかし、の抽象ましょう 離れて撮影のアイデア 1数を乗じました 別の、そしてちょうどそれに名前を付け、 この値は、正方形のような。 

そして、換言すれば、内 Cは、の関数を作成してみましょう まさにその正方形と呼ばれます。 正方形と呼ばれるようになるだろう。 int型を取るために起こっています。 そして、我々はよだけでしょう デフォルトでは、nはそれを呼び出します。 

しかし、我々は、我々は何でもそれを呼び出すことができます。 そして、すべてのそれはに起こっていること 、文字通り、リターンですか n回nの結果。 しかし、それはですので、 何かを返す、その 私たちがきた紫色のキーワードです 私は、11行目に、前に見たことがありません ちょうどこの時間を失うと言うことはできません。 

私達はちょうど見た例では、ボイド むしろ印刷名、ちょうど手段の、 何かをします。 しかし、私に何かをバック手はありません。 この場合、私がしたいですか n回のn戻り、 またはそれが何であれ、その数。 

だから私は、ちょっと、コンピュータを言うことはできませんが、 私は、ボイド、何も返しません。 自然によって、int型を返すようになるだろう。 そして、そのためには、ここで起こっていることすべてです。 

正方形への入力 int型になるだろう。 我々はそれを使用できるように、そして、それはしてい これは、出力に起こっているの名称、Nを持っています 名前を必要としないint型。 私たちは、主にそれを残すことができ、または誰があります 我々場合は、この値を覚えて私を使用して、 独自の変数を使用して欲しいです。 

そして、再び、唯一の新しいです ここでのキーワードは戻ります。 そして、私はいくつかの数学をやっています。 私は本当に不要になりたかった場合は、 私はint型の製品がn回のnなると言えるでしょう。 

そして、私は、製品を返す、と言うことができます。 しかし、再び、以前の私のポイントに これはちょうど良いdesign--されていません 以下のような、なぜ名前を紹介し、 シンボル、製品のように、 ただ、すぐにそれを返すには？ それは、少しクリーナーです そう、少しタイト 、話すだけのリターンを言うためにn回 nは、完全にこの行を取り除きます。 

そして、それは読むためだけ少ないコードです、 間違いのためのより少ないチャンス。 そして、この場合を見てみましょう 実際に機能するようになりました。 今、私は行くつもりです 前方と復帰を実行してください。 

おっと、関数の暗黙的な宣言。 私は、前に大したを、このミスを犯していません。 私はちょうど入力してみましょう、またはハイライト表示して、 コピー、まったく同じ関数プロトタイプ、 または署名、ここまで機能。 それとも私は、全体の機能を移動することができます。 

しかし、それは少し怠け者です。 だから我々はそれを行うことはありません。 今、私はリターンを作ってみましょう もう一度、スラッシュリターンに点在しています。 

xは2 xは4である乗です。 xは3 xは9乗です。 そして、この関数は思わ 今作業します。 だから、ここでの違いは何ですか？ 私は、正方形と呼ばれる機能を持っています 私は入力に入れ、この場合、インチ そして、私は出力を取り戻します。 そして、まだ、以前に、もし 私は他の例を開きます 以前から、その prototype.cと呼ばれていました、 I印刷名を有していました いわば、void型の戻り、 それとも、何も返されず、 単に副作用を持っていました。 

それでは、ここで起こっているの？ まあ、機能を考えます ちょっと文字列を取得します。 私たちは、関数を使用してきました 以下の方法で文字列を取得します。 

私たちは、関数が取得しなければなりませんでした CS50.hを含むような文字列、 標準IO.h、int型、メイン、空隙を含みます。 そして、私がしたすべての時間を これまでのget文字列と呼ばれ、 私は、文字列s、のようなものを言いました 取得string--ので、文字列を取得します それでは、このget.c-- GET文字列を呼びましょう それ自体、私はそれからできた文字列を返します。 カンマ、使用、およびこんにちは、言います、 パーセント秒、バックスラッシュN、S。 

だから、これは同じ例で、 本当に、私たちは以前持っていたこと。 だから、文字列が値を返す取得します。 しかし、先ほど、印字文字列 値を返しません。 単に副作用を有します。 これは根本的な違いがあります。 我々は、さまざまな見てきました 今機能の種類、 そのうちのいくつかは戻ってきました 値は、そのうちのいくつかにはありません。 だから、多分それは、文字列、またはint型、またはフロートです。 それともそれだけで無効です。 

そして、の差であります これらの機能は、そのこと データを取得し、値を返す実際にあります テーブルに戻って何かをもたらし、 いわば。 それでは、先に行くとしましょう 1最終セットを見て 今、感覚を与える例の、の どのように我々はかもしれないが、確かに、抽象的、より良いです、 より良い、より良い、またはそれ以上、 順番に、そしてより多くの、そしてより 、最終的には、より良いコードを書くため。 のは、先に行ってみよう、と精神で スクラッチの、次の操作を行います。 

私は先に行ってみようと含み CS50.hと標準IO.h. 私が先に行くと挙げてみましょう 自分のint、メイン、ボイド。 そして、このcough.cを呼び出し、私は先に行ってみましょう。 

そして、私が先にだけ行ってみよう スクラッチのように、咳/ Nをプリントアウト。 そして、私はこの3回やってみたいです。 だから私は、もちろん、ちょうどつもりです 3回をコピーして貼り付けます。 私は今作るつもりです ドットスラッシュ咳を咳。 のは、自分自身に少しより多くの部屋を与えてみましょう ここでは、咳、咳、咳、入力します。 

すでに、明らかに、あります 改善の機会。 私はコピーして貼り付けました 数回今日。 しかし、それはだけなので、私はしませんでした など、多くの文字を入力する必要があります。 私はまだ何が変わっ コー​​ドのこれらの行があります。 

これらの3行は同一であり、 これは実際に怠惰な感じていると、 そしておそらく正しいアプローチではありません。 どのような成分とだから 私たちは、このコードを改善することができますか？ 私たちは、コピー＆ペーストコードする必要はありません。 

そして、確かに、あなたが感じるあらゆる時間 自分がコピー＆ペースト、 さらには、コードを変更しません オッズは良い方法はあります。 そして、実際に、存在します。 私が先に行くと、forループをやってみましょう、 でも、構文はないかもしれないが まだ自然に来ます。 

単純に、この3回の操作を行います following--を実行して、 そして、私は練習からこれを知ることが起こります。 しかし、我々は今の例の数を持っています。 そして、あなたは、オンラインで表示されます まだ複数の参照。 

これはことを、6行目の構文です 繰り返されるスクラッチのような多くの ブロックは、次の3回繰り返します。 それは、今のところ少し魔法です。 しかし、これは多くを得るだろう、 そしてもっと身近。 

そして、繰り返しになるだろう ライン8 3回、 私があればメイク咳を再コンパイルするように、 ドットスラッシュ咳、咳、咳、咳。 それはまだ同じように動作します。 だから、すべての罰金と良いです。 しかし、それは非常に抽象化ではありません。 

それは完全に正しいです。 しかし、それはそこのように感じています 機会かもしれません、 の世界のように、 開始の種類にスクラッチ、 ように、ここでいくつかのセマンティクスを追加します 私は、ループのためのいくつかを持っていません 言うと機能 咳、または咳ありません。 あのね？ 私はあることを試してみましょう それより少しクーラー そして、実際にその機能を書きます いくつかの副作用があり、それは咳を呼び出します。 

そして、それは何の入力を取らず、 出力として値を返しません。 しかし、あなたはそれが何を知っていますか？ それはthis--のprintfを行い、 引用終わり、咳を引用。 

そして今ここに、私が行きますよ 先に行くと、int型のためにするために、 私は、私プラスプラス、ゼロを取得し、私未満3。 私はある、のprintfをしないつもりです 間違いなく、低レベルの実装 詳細。 私は咳をする方法を気にしません。 私は咳の機能を使用したいです。 そして私はちょうど咳を呼ぶつもりです。 

今、二分法に注目してください。 そうしない場合は、関数を呼び出すとき それは完全に罰金、入力与えたいです。 ちょうど近くに、オープン括弧を行います 括弧、とすれば完了です。 

あなたは、関数を定義するとき、または 関数のプロトタイプを宣言し、 あなたが事前に知っていればそうではありません 任意の引数を取るつもり、 そこにそれらの括弧内のボイドと言います。 そして、それはある種のあなたのことになります 誤ってそれを悪用しません。 私が先に行くと咳をしてみましょう。 そして、もちろん、私はミスを犯しました。 

くそ、ということがあります 暗黙的な宣言。 しかし、それは大丈夫です。 それは簡単な修正です。 私はちょうど高いプロトタイプを必要とします 私のファイルに私は実際にそれを使用していますより。 

だから今素敵な、私は再び咳をしてみましょう。 今、それは動作します。 咳、咳、咳、咳をしてください。 だから、私たちは本当にだと思うかもしれません ただ、この問題は過剰性能。 そして、確かに、私たちはあります。 これは良いではありません プログラムの候補 以下のため現時点では リファクタリング、そして何やって 階層的な分解と呼ばれます どこにいくつかのコードを取り、その後、 ようにあなたの種類の因子物事うち、 彼らにもっと意味を帰するために、 それ最終的に長期的な再利用します。 しかし、それは向かってビルディングブロックです より洗練されたプログラム 我々が開始されること やがてその書き込み 私たちは語彙を持つことができます これでより良いコードを書くため。 そして、確かに、私たちどうかを見てみましょう これをさらに一般化することはできません。 

それは、そのI、主少しラメようです ループのために、このくそを心配する必要があり、 そして、何度も何度も咳を呼び出します。 なぜ私は、咳を伝えることはできません 3回咳してください？ ただ言い換えれば、なぜできない私 咳とこれを行うための入力を与えますか？ 

なぜ私だけでは、と言うことはできません メイン咳3回。 そして今、これは一種の魔法です。 ここは非常に反復的です。 そしてそれは、確かに、赤ちゃんのステップです。 

しかし、単に能力が上と言って ライン8、3回の咳、 それはちょうどそんなにより読みやすいです。 そして、プラス、私が知っている必要はありません または咳がどのように実装されるか気になります。 そして、確かに、それ以降で 用語と最終プロジェクトのため、 あなたがプロジェクトに取り組む場合 同級生または2クラスメート、 あなたがしようとしていることを実現します 持っている、または、作業を分割したいです。 

そして、あなたが決めたいとしています 事前に、誰が何をするつもりです、 どの作品で？ そして、それは素晴らしいではないでしょう あなたの場合、例えば、 行われ、メインの書き込みを担当します。 そして、あなたのルームメイト、またはあなたの 相手より一般的には、 咳を実装するの面倒を見ます。 

そして、この部門は、これらの 抽象化の壁、 抽象または層の場合 あなたは、超強力であります、 特に大規模用のため、 より複雑なプログラムやシステム、 それは、複数の人が構築することができます 物事一緒に、そして最終的に このように一緒に自分の仕事をステッチ。 しかし、当然のことながら、我々 今咳を修正する必要があります。 私たちは、咳を指示する必要があります その、ちょっと、あなたは何を知っていますか？ あなたが取る必要があるとしています そう空洞ではないが、今はint型とinput--。 それでは、先に行くと中に入れてみましょう int型を咳。私はゼロを取得します。 

私は何回未満です。 私は3を前に述べました。 しかし、それは私が欲しいものではありません。 私は咳がに一般化することにしたいです 任意の回数の反復をサポートしています。 

だから、確かに、それは、私が欲しいのnです どのようなユーザーが私に語りました。 今、私は先に行くと、印刷咳を言うことができます。 そして、何があっ番号 ユーザーは渡し、 私は何度も繰り返されます。 

だから一日の終わりに、 プログラムは同じです。 しかし、このようなもののすべてに気づきます でも、別のファイルである可能性があります。 確かに、私はで知りません printf関数がどのように実装されるかの瞬間。 

私が取得する方法現時点では分かりません 文字列、またはint型を取得、またはフロートを取得 実装されています。 そして、私はしたくありません 私の画面上でそれらを参照してください。 それがあるように、私が注力し始めています 私のプログラムではなく、それらの機能。 

そしてそう、確かに、できるだけ早くあなたのような このようなコードを因数分解開始、 私たちも、咳を移動することができます 別のファイルへ？ 他の誰かがそれを実装することができます。 そして、あなたとあなたのプログラムになっ 非常に美しく、そして非常に読みやすいです、 間違いなく、本当に4 右がラインプログラム。 

それでは、今先に行きましょう そしてもう一つの変更を行います。 お知らせ私のプロトタイプ トップを変更する必要があります。 だから私は非常にこれを修正しましょう 私は怒鳴られません。 

咳を行い、私は一度咳を実行してみましょう より、まだ同じことをやって。 しかし、今、私たちが持って気付きます 1最終バージョンのための成分。 あのね？ 私は必ずしも、咳する必要はありません。 私はより一般的な何かを持っていると思います。 だからあなたは何を知っていますか？ 私はこれをやってみたいです。 私は多くのスクラッチのように、持っていたいです 、たとえばブロックを行い、それだけではありません 何か何回か言います。 私はそれが非常に特定の文字列を言いたいです。 そして、そのため、私はしないでください それだけで咳を言いたいです。 私はそれが何でも言いたいです 文字列が渡されます。 

だから私は一般ましたが、気付きます このように今では 良い名前のように感じていると言います このため、スクラッチのような、 スクラッチとは異なり、2つの引数をとります。 一つは文字列です。 一つはintです。 

そして、私はそれらを切り替えることができます。 私だけの種類のアイデアのように その後、最初の文字列を言うと、 何回以降。 ボイドがまだそれを意味します 何も返しません。 これらは、単に視覚的な側面であります 【持つような効果、？ヨルダン、？] 叫んでの口頭副作用。 それでも、何かn回行い 0までが、nと等しくありません。 これは、n個の合計時間を意味します。 そして、ちょうどプリントアウト どのような文字列があります。 だから私は本当に一般化しました このコード行。 だから今、どのように私は実装しません 咳機能？ 

私は、ボイド咳を行うことができます。 そして、私はまだどのように取り込むことができます 何回あなたが咳をしたいです。 しかし、あなたは何を知っていますか？ 私は今言うことをパントすることができます。 

私はと言う呼び出すことができます ワード咳、n個を渡します。 そして、私はまた、実装したい場合は、 ちょうど楽しみのために、くしゃみ機能、 私は何回かくしゃみすることができます。 そして、私はので、n個を再利用し続けることができます このコンテキストまたはスコープでそのメートルに気付きます この関数内でのみ存在します。 

そして、nはこの文脈でのみ ここでは、この関数内に存在します。 だから我々は戻ってくるだろう スコープのこれらの問題。 そしてここで、私は言うつもりです、 アチュー、次にn回、セミコロン。 

そして今、私はちょうど借りる必要が これらの機能は、ここにシグネチャ。 だから咳が正しいです。 ボイドくしゃみは正しくなりました。 

そして、私はまだちょうど言う必要があります。 だから私は言う、と言うつもりです 文字列s、int型のn、セミコロン。 だから私は過剰設計されました このプログラムのうち一体。 

そして、これはそうではありません 必ずしもこれがある意味 書くとき、あなたは何をすべきか プログラムの最も単純な。 明らかに何かを取ります 本当に短い、本当に簡単、 それを再実装 あまりにも多くのコードを使用して。 しかし、あなたが実際に見て、でます 時間は、これらの例を振り返ります とまあ、それらはステップであり、実現 私たちは、実際に一般化するのにかかりました 何かを考慮するために、 一日の終わりまで 私のコードは実際にはかなり合理的です。 私は3を咳したい場合ので、 時間はその後、三回くしゃみ 私は単にこれを再実行するつもりです、 プログラムは、咳をする、と咳を実行します。 そして、私は3咳を持っています そして3くしゃみ。 

そして、これは基本的なもの パラダイム、可能ならば、 私たちが行くかもしれない方法について 実際にプログラムを実装します。 しかし、ちょうどそれが何であるかを見てみましょう 我々は、この時間のすべてを行ってきました そして、どのような最終的な作品の一部 この単純なコマンドの背後にあります。 一日の終わりに、我々はしました 私たちのコンパイラとしてクランを使用して。 私たちは、ソースを書いてきました コー​​ドは、それを変換します クラン経由して機械語コードに変換します。 

そして、私たちはただ作る使用してきました そう私達のキーストロークを容易にするために、 私たちは覚えておく必要はありません クラン自体のもの呪文。 しかし、実際にやってください何ですか？ そして、今度は、何ですか クランは、実際にやって？ 

我々は単純化していてもそれは、判明します 言うことで、今日の議論、 あなたは、ソースコードを取るようにそれを渡します あなたを与えるコンパイラに入力 マシンの出力 コー​​ドは、そこのが判明します そこに内部のいくつかの異なるステップ。 そして、コンパイルは傘であることを起こります 手順の全体の束のための用語。 しかし、ちょうどからかうてみましょう このうち本当にすぐ。 

それは我々が行ってきたことが判明します より多くのもの、私はプログラムを実行するたびに、 または私は今日のプログラムをコンパイルするたびに。 だから、前処理はを指し、 Cプログラムには何もthis--、 私たちは何度も何度もわかるように、 それは、このハッシュ記号で始まります または、ここでハッシュタグ記号は、意味します それは、プリプロセッサ指令です。 それはちょっと、この場合には、意味します コンピュータは、このファイルを使用して何かを行います あなたが実際に自分自身のコードをコンパイルする前に。 

この場合には、ハッシュが含まれ、 のは、本質的に、Cの方法、 ちょっとコンピュータ、内容を取りに行きます CS50.hのとそれらをここに貼り付けます。 ねえ、コンピュータ、取りに行きます 標準IO.hの内容、 どこそれがオン ハードドライブ、それをここに貼り付けます。 だから、これらのことが起こります 前処理時に最初に。 

そして、クランは私たちのためにこのすべてを行います。 そして、それはとてもくそそれをしません 速い、あなたもありません 4つの異なる事が起こって参照してください。 しかし、それは最初のような工程です。 

何が実際に次に起こりますか？ さて、次の公式 ステップがコンパイルされています。 そして、それはことが判明します プログラムをコンパイル 技術的に行くから意味 ソースコード、私たちがきたもの 何かに、今日書いて 何か、アセンブリコードと呼ばれます それは少し違って見えます。 

そして、実際には、我々は本当に速いこれを見ることができます。 私は実際に私のIDEに行ってみましょう。 私は先に行ってみようとオープンのhello.c、その 私たちと非常に最初のプログラムです 今日始まりました。 そして、私が先に行くとクランaを実行してみましょう 少し違った、クラン-S、hello.cに、 実際にしようとしています 私は別のファイルhello.sを与えます。 

そして、我々は、おそらく決して 再び、この種のコードを参照してください。 あなたは、より低いレベルをとる場合 CS61のようなシステムクラス、 あなたがより多く表示されます この種のコードの。 しかし、これはアセンブリ言語です。 これは、X86アセンブリ言語であります その根底にされるCPU CS50 IDEが実際に理解しています。 

そして、それは不可解そうであるよう それは何かである、見て コンピュータはかなりよく理解しています。 サブqが、これは減算です。 動きがあります。 

ここでは関数の呼び出しがあります、 X OR演算、移動、追加、ポップ、 リターン。 だから、いくつかは非常にあります 低レベル命令 CPUはことを理解していること 私は以前に言及しました。 それはどのようなインテルインサイドです。 

のパターンがあります 0と1という これらarcanely言葉遣いにマップが、 幾分よく名前の、命令、 いわば。 それはときに起こることです あなたのコードをコンパイルします。 あなたは、アセンブリを取得します それのうち、言語、どの 第三段階は、組み立てることであることを意味します そのアセンブリコードに、最終的には、 0と1 code--マシンではなく、 私たちはちょっと前に見たテキスト。 

だから、前処理、それは見つけるん そして、交換して、いくつか他のもの。 コンパイルは、ソースを取ります Cソースコードからコード 我々は、アセンブリに、書きました 私たちはちらっと見コード。 組み立ては、そのアセンブリを取り 0と1のコード CPU本当に意志います 一日の終わりに理解しています。 そして、リンクは最後のステップです それは、再びus--ために起こります そんなに早く私たちもしません 言いますnotice--、 ちょっとコンピュータは、すべてを取ります 0と1という ダビデのコードをコンパイルから生じました、 この場合の彼の主な機能。 

そしてちょっとコンピュータ、取りに行きます 0と1のすべて CS50のスタッフが書きました CS50ライブラリの内部。 ダビデの持つもので混ぜます。 そして、ちょっとコンピュータは、すべてゼロを取りに行きます 他の誰かが年に書いたことを、どれ printfのための前。 とにそれらを追加します。 全部、私たちがきたように、 、私の0と1を得ました CS50スタッフの0と1、 printf関数の0と1、 そして何か他のものは、我々が使用しています。 

彼らはすべて1にまとめます プログラムは、こんにちは、この場合には、と呼ばれます。 だから今後、私達はちょうどます 単語のコンパイルを使用しています。 そして、私たちは与えられたとき、そのためになります 我々は、それが意味する、あなたのプログラムをコンパイルし、言います ちょっと前処理を行い、 組み立て、およびリンク。 しかし、実際にいくつかのジューシーなものがあります ボンネットの下にそこに起こっています。 そして、特にあなたの場合 好奇心旺盛ないくつかの時間を取得し、 あなたが突っつい開始することができます この下位レベルの周り。 しかし、今のところ、それを実現します 今日のために持ち帰りうち、 非常に単純です プロセスの始まり、 に慣れるの ハロー世界のようなもの。 実際、我々が今日やったことのほとんど 確かに超高速に沈むことはありません。 そして、それはいくつかかかります 時間、およびいくつかの練習。 そして、オッズは、あなたがソートされ、あります キーボードを打つしたいです または、画面で叫びます。 そして、それのすべてがOKです。 しかし、おそらくしないようにしよう そんなにライブラリでそれを行います。 

そして最終的に、あなたはよ 開始するには、しかしことができます パターンを見て、両方の良いコードに あなたが書いたことやミスで あなたが行ったこと。 とのプロセスのような多くの TFになってきまたはCAが似ています、 あなたが良くなってから始めましょうと これらのパターンを見てでは、より良いです、 そしてちょうどあなたを解きます 最終的に自身の問題。 一方で、たくさんあるだろう あなたのサポートを貸す、とあなたを得るために私達の これを通して。 そして、書き込みアップで 問題のすべてのために あなたが通って案内されます すべてのコマンド 私は確かに知っていること 今ではたくさんの練習、 しかし飛行している可能性があります 今の頭の上に。 そして、それは完全に罰金です。 

しかし、最終的に、あなたが行っています 見に開始するパターンが出現します。 そして、あなたはすべてを乗り越える度 愚かな詳細、括弧のような、 そして、中括弧、およびセミコロン、 とか、率直に言って、 それがすべてではありません 知的興味深いです。 そして、それはの目的ではありません 任意の入門クラスを取ります。 それは問題ではしようとしているのアイデアです。 

それはループだし、 条件、および機能、 そしてより強力に抽象化、 そして、コードのファクタリング、 そして、優れたデザイン、そして良いです スタイル、そして最終的に正し あなたのコードの、それは最終的です 最も重要になるだろう。 だから来週、我々はこれらがかかります 我々は最初のスクラッチで見たアイデア そして今翻訳しました Cにそして、私たちは始めましょう の最初に紹介しま​​す コー​​スの実世界のドメイン。 

私たちは、セキュリティの世界に焦点を当てます より具体的には、暗号化 情報をスクランブリングの芸術。 そして、最初のうち、 問題あなた自身を 超えて書き込むようになるだろう 構文の一部と一緒に遊ん そして、いくつかの論理を解きます 問題、最終的に前に長いです、 、実際にスクランブル、または暗号化することです そして最終的に情報を解読します。 そして、すべては我々がやりました 今日、かなり低くなります レベルは、単に可能にするために起こっています 私たちは、1、および1を取ります 上記に向かって一歩 まだ最も興味深いコードを書きます。 

だから、より多くのその次の週に。 

[ビデオ再生] 

 - どのようなあなたはについての私に言うことができます あなたが彼を見た最後の時間？ 私は本当に、 - 何を言うことができますか？ 私が意味する、それは他のどのようなものでした プリプロダクションリハーサル、 彼が言った何かがあった以外 私と一緒に立ち往生非常に終わりに。 

 - これはCS50ました。 

 - つまりは、カット誰です リハーサルに素晴らしい仕事。 

 - つまりのランチ？ 

-Yeah、あなたと私がすることができます ビットでサンドイッチをつかみます。 私はちょうどで結果を聞くみよう デビッド本当にすぐ。 デビッド？ デビッド？ 

[END PLAYBACK] 