[MUSIC PŘEHRÁVÁNÍ] David J. Malan: Dobře, to je CS50. A to je jeden týden. Takže připomenout, že naposledy v týdnu nula, jsme se zaměřili na výpočetní myšlení. A my jsme přešli od toho, aby Scratch, grafické programování jazyka od našich přátel v Media Lab MIT. 

A s Scratch, jsme prozkoumat tedy ideje jako funkce, a podmínky, a smyčky, a proměnné, a to i události, a nitě a další. A dnes, budeme nadále používat ty nápady, a opravdu přičemž je pro samozřejmost, ale přeložit do jiného jazyka známého jako C. Now, C je více tradiční jazyk. Je to nižší úroveň Jazyk, chcete-li. 

Je to čistě textová. A tak na první pohled, je to vše bude vypadat poněkud záhadný pokud jste nikdy předtím naprogramován. Budeme mít středníky a závorky, a složené závorky a další. Ale uvědomit, že i i když je syntaxe asi vypadat trochu neznámá pro většinu z vás, vidět minulost. A pokusit se zjistit, nápady že jsou skutečně obeznámen, protože tady v týdnu jedno, co začneme udělat, je porovnat, zpočátku, Scratch proti C. 

Tak například, připomenout, že když realizován první z našich programů Naposled jsme měli blok, který vypadal trochu něco jako tohle-- když zelenou vlajkou klikli, a pak jsme měli jeden nebo více dílků pod ním, V tomto případě, řekněme, hello world. Takže, opravdu, ve Scratch, když kliknu, že zelený příznak spustit svůj program, takže mluvit, to jsou bloky, které se dostanou provedeny, nebo spustit. A konkrétně Scratch řekl, ahoj, svět. 

Teď jsem mohl specifikovány různá slova zde. Ale uvidíme, že mnohá z těchto blocks-- a opravdu, v jazyce C mnoho functions-- může být parametrized nebo přizpůsobené dělat různé věci. Ve skutečnosti, v C kdybychom chcete převést, teď, Tento Scratch programu do tohoto jiného jazyka, budeme psát Trochu něco takového. 

Je pravda, že tam je nějaká neznámá Syntaxe tam s největší pravděpodobností, int, a závorky a neplatné. Ale printf-- přestože byste myslím, že to bude jen tisk. Ale tisk znamená tisk formátován, jak budeme brzy vidět. To doslovně bude tisknout na obrazovku bez ohledu je uvnitř těchto závorkách, které Samozřejmě v tomto případě je, hello world. 

Ale všimněte si, některé další syntax, některé uvozovky, že závorky na konci, středník a podobně. Takže tam to trochu nad hlavou, tak říkajíc, a to jak kognitivně a syntakticky, že jedeme muset pamatovat zanedlouho. Ale uvědomit, že s praxí, to začne skákat na vás. 

Ve skutečnosti, pojďme zaměřit se na tomto jednom Funkce specifically-- v tomto případě, pozdravit svět. Takže říci, je funkce. Dobrý den, svět je jeho parametr, Argument nebo její přizpůsobení. 

A ekvivalence v C je jen Bude tento jeden řádek tady, kde printf je ekvivalentní, řekněme, dvojitý řetězec v uvozovkách, ahoj svět je ekvivalentní, samozřejmě, s tím, co je v bílém poli tam. A zpětné lomítko n, i když poněkud podivné a nepřítomný od nuly, prostě bude mít za následek Budeme viz v počítači, jako můj Mac nebo PC, pouhého Pohybem kurzor na další řádek. Je to jako bít Enter na klávesnici. 

Takže uvidíme, že zase zanedlouho. Ale první, pojďme se na to podívat Dalším příkladem v případě smyček. Měli jsme navždy smyčka minule, což byla série skládačky že udělal něco doslovně forever-- v tomto případě, říkají, Hello World, hello world, hello world, hello world. Takže je to nekonečné smyčce záměrné. 

V jazyce C, chceme-li implementovat toto Stejná myšlenka, mohli bychom prostě to udělat. I když pravda, world-- printf ahoj nyní zatímco jen sémanticky, druh vykouzlí představu o tom opět něco, a znovu a znovu, a na jak dlouho? No, true-- připomeňme, že pravda, je jen na jedno nebo. 

A pravda je, samozřejmě, vždy pravdivé. Takže je to jakýsi bezvýznamný Prohlášení jen říct pravdu. Ale ve skutečnosti, to je záměrné, protože pokud je to pravda, je prostě vždy pravdivý, než je sice pravda jen naznačuje, když trochu nepřímo že následující řádky kódu mezi těmito složenými závorkami měl prostě spustit znovu a znovu, a znovu a vlastně nikdy nezastaví. 

Pokud ale chcete, aby vaše smyčka zastavit, jako my minule se něco podobného toto opakujte následující 50krát, v jazyce C můžeme udělat totéž s tím, co je volal pro loop-- klíčové slovo není přitom, ale pro. A pak tu máme nějakou novou syntaxi tady, s int i = 0, i méně než 50, i ++. A vrátíme se k tomu. Ale to je prostě, jak bychom přeložit sadu Stírací bloků k souboru C řádků kódu. 

Mezitím, za proměnné. A ve skutečnosti, právě jsme viděl jeden před chvílí. A v případě Scratch, kdybychom chtěl deklarovat proměnnou jsem zavolal pro i je celé číslo, jen číslo, a chceme nastavit na libovolnou hodnotu, bychom použili oranžová blokovat here-- nastavit i na 0. 

A uvidíme dnes a mimo ni, stejně jako minulý týden, programátoři dělat téměř vždy začíná počítat od nuly, ale opravdu konvencí. Ale také proto, že stažení z naše diskuse o binární, Nejmenší číslo Můžete představují s libovolným počtem bitů Je jen bude 0 sám. A tak budeme obvykle zahajují inicializace i naše proměnné na hodnotu 0. 

A v jazyce C, aby učinili totéž, budeme říkat, int pro celé číslo, já jen konvencí. Mohl jsem volal tato proměnná cokoli chci, stejně jako v Scratch. A pak se rovná 0 právě nabyvatelé hodnota 0 z pravé a vloží jej do proměnné, nebo skladovací kontejner tam, na levé straně. A středník, jak budeme see-- a jsme viděli některé z těchto already-- prostě znamená konec myšlení. Přistoupit k dělat něco jiného na tratích, které následují. 

A teď, co Booleovských výrazech? Připomeňme, že v Scratch, tito byli výrazy že jsou buď pravdivé nebo false-- otázky, ve skutečnosti, že jsou buď pravdivé nebo nepravdivé. Takže v případě Scratch, mohli bychom položit jednoduchou otázku, jako je tato, je i nižší než 50 ° C? Tak jsem se, opět je celé číslo. Možná bychom ji používáte v programu Scratch sledovat skóre nebo něco takového. Takže tato syntaxe tady v Scratch prostě znamená, je i nižší než 50 ° C? No, naštěstí, je něco Jednoduchý v C. A překládat, Tento bychom jednoduše říci, že méně než 50 ° C, pomocí známého klíče na klávesnici. 

Zatím, pokud jste chtěli říkají obecnější něco, jako, no, je x menší než y, kde každý x a y jsou samy o sobě proměnné? Můžeme udělat totéž v C, tak dlouho, jak jsme vytvořil tyto proměnné již. A uvidíme, jak se tomu, že zanedlouho. Rádi bychom jednoduše říci x menší než y. 

Takže vy začínáte viz určité podobnosti. A ty lidi, kteří učinili Scratch byli jistě inspirovaný některé z těchto základních myšlenek. A uvidíte tento druh syntax v mnoha languages-- ne jen nuly, nikoli Jen C, ale Python, a JavaScript, a Jiné jazyky klidu. 

Podívejme se na další konstrukt z C, ponětí o stavu, dělat něco podmíněně. Je-li něco je pravda, to udělat. Pokud je pravda, něco jiného, ​​udělej to. Je to něco programování ekvivalent k rozcestí. Možná je to obousměrný vidlice, trojcestný vidlice, nebo více. A v Scratch, mohli bychom mít vidět něco takového. 

Takže tohle je jeden velký. Ale vzít v úvahu relativní jednoduchost logiky. Je-li x menší než y, pak říkají x méně než y, jinak, pokud x je větší než y, pak říkají, x je větší než y. A pak, logicky, pokud si myslíte, že zpět do nuly nebo jen svou vlastní lidskou intuici, dobře, pokud x není větší než y, a x není menší než y, pak se samozřejmě x bude rovno y. Takže v tomto případě by hnízdění Stírací tyto bloky, můžeme dosáhnout tři cesta rozcestí? 

Mezitím, pokud chceme to udělat v C, ale pravděpodobně Vypadá trochu simpler-- přinejmenším jakmile se seznámí se syntaxí. Pokud x je menší než y, printf x je menší než y. Else if x je větší než y, printf x je větší než y. Jiný printf x je rovno y- a, opět s těmi, lomítko končí jen u těch nových tratí, takže pokud máte vlastně běžel tento druh programu to by jen přesunout kurzor nakonec na další řádek obrazovky. 

Nyní se mezitím Scratch měl jiný sofistikovanější funkce, pouze z nichž některé budeme nejprve přejít do světa C. A jeden z nich byl volal seznam v Scratch. A to byl zvláštní typ proměnné povolena ukládat více věcí v ní zpátky k sobě, dozadu, dozadu. 

V C, nemá seznamy, samy o sobě, ale něco které jsou obecně s názvem pole, i když budeme vrátit později tento semestr se dívá na něco volal seznamu, nebo opravdu spojový seznam. Ale teď, nejbližší ekvivalent v C po dobu nás se bude něco zvané pole. A pole je jednoduše speciální typ proměnné který vám umožní ukládat data zpět k sobě, k sobě, k sobě. 

A skutečně, v Scratch, pokud chceme přistupovat první prvek pole nebo list-- a budu to říkat, Podle konvence argv, argumentace vektoru, ale o tom zanedlouho. Pokud chci se dostat na první prvek z argv, ve světě Scratch vlastně děláte obvykle začíná počítat od 1. 

A tak bych mohl dostat položky 1 argv. To je jen, jak implementována MIT pojem seznamů. Ale v C, jdu Více prostě jen říci, argv, což je opět jméno mého list-- nebo aby bylo jasné, pole. A když chci první prvky, jdu používat hranaté závorky, který vás nemusí často používány pod klávesnicí. 

Ale prostě znamená 0, dejte mi ten první. Tak příležitostně a jako plyne čas, jdeme začít vidět všechny tyto dichotomie mezi Scratch a C, přičemž Scratch používá. Jsme v jazyce C použít 0 zde. Ale budete rychle zjistit, jakmile pochopíte základy každého jazyka, aby tyto věci začnou dostat o to víc seznámí prostřednictvím praxe a praxe. 

Takže pojďme se vlastně vypadají nyní na programu. Zde je první naší C zdrojový kód pro kompletní programy. A program jdeme nabízet za úplatu je ten, který je rovnocenný na tomto dřívějším Scratch kus. 

Takže tady máme to, co je pravděpodobně nejjednodušší programu C můžete psát, že ve skutečnosti dělá něco. Nyní se podíváme kolem, Pro tuto chvíli má zahrnovat Standardní io.h, a tyto úhel držáky a int, a neplatná, a složené závorky, a podobně. 

A pojďme soustředit jen na co, alespoň intuitivně, mohl vyskočit na vás již. Ve skutečnosti je hlavní, nemám nutně vědět, co to je, ale podobně jako Scratch měl, že když zelenou vlajkou klepnutí kousek skládačky, tak dělá C jako programovací jazyk mají hlavní kus kódu, který dostane popraven ve výchozím nastavení. A opravdu, to doslova bude nazýván hlavní. 

Takže hlavní je funkce. A je to speciální funkce, která existuje v jazyce C, který při spuštění programu, to je hlavní, který se provozují default. Ve světě Scratch, to bylo obvykle, když zelená vlajka kliknul, která dostala spustí automaticky. 

Mezitím jsme viděli dříve, printf nebo vytisknout formátovaný, to je Bude to funkce, která přichází s C, spolu s celou partou druhých, že vůle čas od času a znovu, aby se dělat přesně jak již název napovídá, něco vytisknout. Co chcete vytisknout? No, uvidíme, že uzavřením charaktery jako these-- hello world, lomítko n v uvozovkách, můžeme říci přesně printf Co k tisku na obrazovce. 

Aby však bylo možné učinit že jsme se bohužel je třeba vzít něco, co je Již kryptické na nás lidi, ale aspoň je to poněkud readable-- ostré zahrnují standardní io.h, int, Hlavním, void, printf všechny magické zaklínání jsme právě viděli na obrazovce. Ale ve skutečnosti máme na jít ještě tajemné. nejprve musíme přeložit kód že píšeme do strojového kódu. A odvolávat z minulého týdne, že stroje, alespoň ty víme tady, Na konci dne jen porozumět nul a jedniček. 

A můj Bože, kdybychom museli psát tyto nuly a jedničky vlastně programu, bylo by velmi, velmi rychle vzít legraci ze všeho. Ale ukazuje se, za minulého týdne, že tyto vzory nul a jedniček Jen mají zvláštní význam. Za určitých okolností, by mohlo znamenat čísla. 

V některých kontextech, mohou znamenat dopisy, nebo barvy, nebo libovolný počet dalších abstrakcí tam na. Ale stejně jako má počítač CPU, Central Processing Unit, nebo mozky uvnitř počítače. Je to obvykle Intel uvnitř, protože to je jedna z největších firem která dělá procesorů pro počítače. 

No, Intel procesory a další prostě se rozhodli v předstihu že určité vzory nul a Ti se rozumí konkrétní věci. Některé vzory nul a jedniček bude znamenat, tisknout na obrazovku, nebo přidání těchto dvou čísel, nebo odečíst těchto dvou čísel, nebo přesunout tento kus dat z Paměť můj počítač je tady, nebo libovolný počet jiných velmi nízké úrovni, ale nakonec užitečné, operace. Ale, naštěstí, my lidé nebudou muset poznat tuto úroveň detailů. Ve skutečnosti, stejně jako minule, kde jsme abstrahovat znovu a znovu a znovu, Budova z velmi nízké úrovni primitiva jako nul a jedniček na vyšší úrovni pojmy jako čísla a písmena, a barvy a další, takže můžeme jako programátoři stojí na ramenou jiní, kteří přišli před námi a použitelný software, který ostatní lidé psali před us-- jmenovitě programy zvané kompilátory. 

C je jazyk, který je obvykle sestaveny, což znamená, přepočtena zdrojový kód do strojového kódu. Zejména, co to znamená je, že pokud máte zdroj kód, který si sami psát, jak jsme brzy bude za chvíli na obrazovce, a chcete převést v konečném důsledku ke stroji code-- ty nuly a ty, které Pouze váš Mac nebo PC understands-- máte první krmivo, které zdrojový kód se jako vstup pro speciální program s názvem kompilátor, jehož výstup jsme Uvidíme je strojový kód. A skutečně, minule jsme si povídali o, opravdu, na konci dne, řešení problému. Musíš vstupy. A máte výstupy. A máte nějakou algoritmu ve středu. 

Algoritmy může jistě být realizovány v softwaru, jak jsme viděli s pseudokódu minulého týdne a jak uvidíme se skutečným kódem tento týden. A tak kompilátor opravdu jen má sadu algoritmů uvnitř o tom, že vědí, jak převést speciální klíčová slova, jako hlavní a printf, a jiní, že jsme právě viděl do vzorů nul a ty, které Intel uvnitř a ostatní CPU ve skutečnosti chápe. Tak jak to uděláme? Kde získáme kompilátor? 

Většina z nás tady máte Mac nebo PC. A vy systémem Mac OS, nebo Windows nebo Linux, nebo Solaris, nebo libovolný počet jiných operační systémy. A vskutku, mohli bychom jít ven na web a stáhnout překladač pro váš Mac nebo PC pro příslušný operační systém. Ale všichni bychom být na Různé strany, tak říkajíc. Měli bychom mít mírně různé konfigurace. A věci nebude fungovat všechny stejné. A vskutku, v těchto dnech mnozí z nás nepoužívají software, který běží pouze na našich notebooků. Místo toho použít něco jako prohlížeč, který nám umožňuje přístup k web-based aplikace v cloudu. A později tento semestr, uděláme přesně to. Budeme psát aplikace, nebo software pomocí code-- ne C, ale jiné jazyky jako Python a JavaScript--, které pracují v cloudu. 

A k tomu, že my sami V průběhu semestru bude skutečně používat na bázi cloud- Prostředí známý jako CS50 IDE. To je programovací webová životní prostředí, nebo integrovaný rozvoj Prostředí IDE, který je postaven na vrcholu některé open source software s názvem Cloud 9. A my jsme udělali některé pedagogický zjednodušení do ní tak, aby se skrýt určité funkce v v prvních týdnech, které nepotřebujeme, po kterém můžete odhalují je a dělat většinu co chcete s životním prostředím. 

A nám umožňuje také, aby předem nainstalovat určitý software. Věci jako tzv CS50 knihovna, která budeme brzy vidět nám poskytuje v jazyce C s některými další funkce. Takže pokud jdete nakonec CS50.io, budete vyzváni k přihlášení, a jakmile to uděláte a vytvářet účet zdarma, budete moci přistupovat k Prostředí, které vypadá docela takhle. 

Nyní, to je ve výchozím režimu. Vše je pěkné a světlý na obrazovce. Mnozí z nás mají ve zvyku pracuje na CS50 kus, který je poměrně pozdě do noci. A tak někteří z vás možná raději přeměnit ji na noční režim, tak říkajíc. 

Ale nakonec, co jste uvidí v rámci CS50 IDE Je tři odlišné areas-- oblast na ležet tam, kde soubory se bude v mrak, což je oblast v pravém horním rohu kde váš kód bude upravovat. Budete mít možnost otevřít Jednotlivé karty pro jakýkoli program že budete psát tento semestr uvnitř uvedeného pravém horním rohu. A pak s největší arcanely, a přesto mocně, bude tato věc u Dno známý jako okno terminálu. 

To je stará škola Command Line Interface, nebo CLI, který umožňuje můžete spouštět příkazy Na computer-- v tomto případě, Počítač v cloud-- dělat věci, jako je kompilace kódu ze zdrojového kódu do strojového kódu, spouštět programy, nebo začněte webový server, nebo pro přístup k databázi, a jakýkoliv počet dalších technik že začneme používat zanedlouho. Ale aby se tam dostat, jsme bude skutečně mít přejít do režimu online a začít hrát. A k tomu, že, pojďme nejprve začít šťourat se hlavní, a psát hlavní část programu. A pojďme použít tuto funkci printf, který jsme použili dříve, prostě něco říct. 

Tak jsem tady už uvnitř CS50 IDE. Já jsem předem přihlášen. A já na plný detekční okno. A tak nakonec budete také v příštích problémů budou následovat podobné kroky, které bude poskytovat dokumentaci online. Takže nemusíte se obávat absorbovat každý malý technický krok že já tady dnes. 

Ale budete mít obrazovku podobnou následující. I stalo, že se v nočním režimu. A můžete oživit vše up vypnutím noční režim. A na konci den, budete vidět Tyto tři hlavní areas-- souboru Prohlížeč vlevo, kódové jazýčky nahoru vrcholu, a okno terminálu v dolní části. 

Nech mě jít dopředu a napsat svůj první program. Chystám se preventivně jít do souboru, Ukládat a uložit svůj soubor jako hello.c. Ve skutečnosti, podle konvence, jakýkoli program, který jsme píší, že je napsán v jazyce C. by měly být pojmenovány něco tečka c, konvencí. Takže budu jmenovat to hello.c, protože Jen chci pozdravit svět. Teď jdu pro zvětšení out a na tlačítko Uložit. A to všechno teď mám tady je karta ve kterém mohu začít psát kód. 

To nebude kompilovat. To znamená, že nic. A tak i když jsem převedeny to nul a jedniček, CPU bude mít žádný Myšlenka, co se děje kolem. Ale jestli píšu řádky, které odpovídají up s C je conventions-- C bytosti, Znovu, toto language-- se syntaxí jako to, printf Dobrý den world-- I a jsem dostali pohodlně Přitom v průběhu času. Takže si nemyslím, že jsem udělal případné typografické chyby. 

Ale vždy, úplně první Doba tak učiníte, budete. A co se chystám udělat, by mohli velmi stejně nebude pracovat pro vás poprvé. A to je naprosto v pořádku, protože právě teď Možná jen vidět spoustu novosti, ale v průběhu doby, jakmile se seznámí s tímto prostředím, a Tento jazyk, a jiní, začnete vidět věci, které jsou buď správné nebo nesprávné. 

A to je to, co učební kolegy a samozřejmě asistenti dostat tak dobří v průběhu času, je špinění chyby nebo chyby v kódu. Ale tvrdím, že existuje V této kódu nejsou žádné chyby. Tak jsem teď chcete spustit tento program. 

Nyní na své vlastní Mac nebo PC, jsem v zvyk dvojitých ikon klepnutím když chci spustit nějaký program. Ale to není model zde. V tomto prostředí, které je CS50 IDE. Jsme s použitím provozní Systém s názvem Linux. Linux je připomínající další operační systém, obecně známý jako Unix. A Linux je zvláště známý pro mající prostředí příkazového řádku, CLI. Teď jsme pomocí specifického Chuť Linux s názvem Ubuntu. A Ubuntu je prostě jistá verze Linuxu. 

Ale tyto Linuxu v těchto dnech dělat vlastně přijít s grafickým uživatelským rozhraním. A ta, kterou jsme náhodou Zde bude používat je web-based. Tak to může vypadat i trochu odlišný od něčeho vy sám může mít viděli nebo spustit v minulosti. 

Takže budu pokračovat Nyní a proveďte následující. Já jsem zachránil tento soubor jako hello.c. Chystám se jít dopředu a Typ clanghello.c Tak Clang pro jazyk C je kompilátor. Je to pre-nainstalovány v CS50 IDE. A můžete si stáhnout a absolutně nainstalovat tento na vlastním počítači Mac nebo PC. 

Ale opět, nebudete mít všechny pre-konfigurace pro tebe udělal. Takže teď jsem jen chystá spustit clanghello.c. A teď si všimnout tuto syntaxi Zde bude nakonec uvědomit, znamená, že jsem v složku nebo adresář s názvem Pracovní prostor. Tento znak dolaru je prostě konvence po smyslu, zadejte své příkazy zde. 

To, co se nazývá prompt, stačí konvencí je znak dolaru. A když půjdu napřed a hned na tlačítko Vstoupit, nic Zdá se, že se stalo. Ale to je vlastně dobrá věc. Čím méně se to stane na obrazovky, tím větší je pravděpodobnost váš kód je správný, alespoň syntakticky. 

Takže když chci spustit tento Program, co mám dělat? No, to ukáže, že Výchozí název konvencí pro programy, pokud nezadáte jmenovat váš program je jen a.out. A tato syntaxe příliš, budete seznámit se s zanedlouho. 

Dot lomítko prostě znamená, hej, CS50 IDE, spustit program s názvem a.out to je v mém aktuálním adresáři. Že tečka znamená aktuální adresář. A uvidíme, jaké další takové sekvence postav znamená, že zanedlouho. 

Tak jdeme na to, Enter, hello world. A všimněte si, že to, co se stalo? Nejenže tisknout hello world. To také přesunuta kurzor na další řádek. 

A proč to bylo? Jaký byl kód, který jsme psali dříve že zajistila, že se kurzor by pokračovat na dalším řádku? Legrační věc, o Počítač je to jen bude dělat doslova, co si to říct dělat. 

Takže pokud jste to říct, aby printf Dobrý den, čárka, mezera, svět, v blízkosti citace, to doslova jen bude vytisknout tyto znaky. Ale musel jsem tento speciální znak Na konci odvolání, zpětné lomítko n. A to je to, co zajištěna že postava šla na další řádek obrazovky. 

Ve skutečnosti, nech mě jít, a to udělat. Nech mě jít dopředu a smazat. Nyní si všimněte, že Horní část mé obrazovce je tu trochu červené světlo karta naznačuje, hej, jste neuložili souboru. Takže budu pokračovat s kontrolou S nebo příkaz S uložte soubor. Teď to goes-- šel na moment-- zelenou. A teď je to zpátky do jen být blízký ikona. 

Mám-li nyní spustit clanghello.c znovu, Enter, tečka lomítko, a.out, Enter, uvidíte, že to ještě funguje. Ale je to pravděpodobně trochu buggy. Právě teď, moje prompt-- pracovní prostor, a pak ten znak dolaru, a pak můj skutečný prompt-- vše je na stejném řádku. Tak to určitě estetický chyba, i když to není opravdu logická chyba. 

Takže jdu napravit to, co jsem právě udělal. Jdu znovu spustit a.out. Všimněte si, jsem přidal znak nového řádku zpět. Jsem uložení souboru. 

Takže jdu znovu spustit a.out, a-- sakra, chyba, chyba znamenat chybu. Takže chyba je, že ačkoli Přidal jsem zpětné lomítko n tam, re-uloží, znovu běžel program, chování byl stejný. Proč by to mělo být? 

Mi chybí krok, že jo? Že klíčový krok dříve bylo, že máte to-- když změníte zdrojový kód, to dopadá také spustit to přes překladač Znovu tak dostanete nový strojový kód. A strojový kód, nuly a ty, se bude téměř identické, ale není dokonale tak, protože potřebujeme, Samozřejmě, že nový řádek. 

Takže tento problém odstranit, budu potřebovat znovu spustit clanghello.c, vstupovat, tečka lomítko, a.out. A teď, hello world je zpět tam, kde jsem, že to bude. Tak to je vše v pořádku a dobré. Ale a.out je docela hloupé jméno pro Program, i když to se stane být, z historických důvodů default-- což znamená, montážní výstupy. 

Ale dovolte mi pokračovat zde a to jinak. Chci hello world skutečně nazvat Dobrý den. Takže pokud to bylo ikonu na mém desktop, to by nemělo být a.out. To by byl nazýván Dobrý den. 

Tak, jak to udělat, to dopadá že Clang, stejně jako mnoho programů, podporuje argumenty příkazového řádku, nebo vlajky, nebo přepínače, který jednoduše ovlivnit jeho chování. Konkrétně Clang podporuje pomlčka O příznak, který pak trvá druhé slovo. V tomto případě budu svévolně, ale rozumně, říkejte tomu ahoj. Ale já ji mohli nazvat něco Chci, s výjimkou a.out, který by bylo spíše vedle bodu. 

A pak stačí zadat jméno spisu já chci sestavit. Tak se i když na začátku příkazu mám ještě Clang, na konci příkazu Stále mám název souboru, Nyní mám tyto příkazový řádek argumenty, tyto příznaky, které říkají, oh, mimochodem, výstup-o, soubor s názvem Dobrý den, není výchozí a.out. 

Takže když jsem stiskněte klávesu Enter teď, nic Zdá se, že se stalo. A přece, teď můžu dělat dot lomítko Dobrý den. Takže je to stejný program. Nuly a ty jsou identický na konci dne. 

Ale jsou ve dvou odlišný files-- a.out, což je první verze a jen bláhově jmenován, a teď Dobrý den, což je mnohem přesvědčivější název programu. Ale upřímně, já jsem nikdy bude to zase pamatovat, a znovu a znovu. A skutečně, jak píšeme složitějších programů, povely nablízku budu muset psát se dostane i více komplikuje stále. 

A tak, aby se nebála. Ukazuje se, že lidé dříve abychom si uvědomili, že příliš měl tento přesně stejný problém. Oni příliš neužil museli typ poměrně dlouhé, tajemných příkazů, natož pak pamatovat si je. A tak lidé před námi dělali další programy, které usnadňují sestavit svůj software. 

A skutečně, jedním z takových program se nazývá Výrobek. Takže já jdu dopředu a to udělat. Chystám se vrátit všechno, co jsem právě udělal následujícím způsobem. Nech mě typ LS. A všimněte si tři things-- a.out, a hvězda, ahoj a hvězda a hello.c. Doufejme, mělo by to být trochu intuitivní, pokud již dříve došlo Nic v tomto prostoru. Nebylo nic, co bych měl vytvořit, dokud jsme začali třídu. 

A jsem vytvořil hello.c. Pak jsem ho sestavil, a nazval jej a.out. A pak jsem sestavil jej opět mírně odlišně a nazval jej pozdravit. Takže mám tři soubory v tomto adresáři, V této složce s názvem Pracovní prostor. Teď vidím, že stejně když jsem oddálit skutečnosti. 

Kdybych oddálit tady a podívejte na tu horní pravé ruky roh, jak bylo slíbeno levá na pravé straně obrazovky je vždy ukážu co je ve vašem účtu, co je Vnitřek CS50 IDE. A tam jsou tři soubory tam. 

Takže chci se zbavit a.out a ahoj. A jak byste mohli si představit, intuitivně, vás mohl řadit kontrolního kliknutí nebo klikněte pravým tlačítkem myši na toto téma. A tato malá nabídka objeví. Zde si můžete stáhnout soubor, spusťte to, prohlédnout, obnovovací, přejmenování, nebo co ne. 

A mohl bych jen odstranit, a to by jít pryč. Ale pojďme dělat věci s příkazem linka pro tuto chvíli, tak, aby si pohodlně s tím, a to následujícím způsobem. Chystám se jít dopředu a vyjměte a.out zadáním doslova rma.out. Ukázalo se, že příkaz k odstranění nebo odstranění něčeho, není odstranit nebo odstranit. 

Je to stručněji RM, stačí uložit vám některé stisky kláves, a stiskněte klávesu Enter. Nyní budeme mít poněkud záhadně odstranit běžný soubor a.out. Já opravdu nevím, co je to nepravidelný soubor by bylo dosud. Ale já chci, aby jej odstranit. 

Takže jdu Napište A pro Ano. Nebo bych mohl psát to, a stiskněte klávesu Enter. A opět se zdánlivě nic neděje. Ale to je obecně dobrá věc. 

Kdybych typ LS tentokrát, co bych měl vidět? Doufejme, že jen ahoj a hello.c. Nyní, jak stranou, budete Všimněte si tuto hvězdu, hvězdička, to je na konci svých programů. A oni také objevil v zelené barvě. To je jen CS50 IDE cesta z cluing vás do skutečnosti, že to není zdrojový kód. To je spustitelný, je spustitelný program, který si můžete skutečně spustit tím, že dělá dot lomítko, a pak je to název. 

A teď, nech mě jít dopředu a vyjměte to, rm ahoj, Enter, odstranit pravidelná soubor Dobrý den, ano. A teď když jsem typ LS, jsme zpátky hello.c. Snažte se odstranit vaše Skutečná zdrojový kód. I když existuje funkce zabudované do CS50 IDE kde můžete projít historii revizí a vzad v čase Pokud omylem smazat něco dělat budou mít na zřeteli podle těchto výzev ano nebo ne, o tom, co vlastně chcete dělat. A když jsem jít až na vrchol levém rohu tady, vše, co zůstává, je hello.c. Takže tam svazky další příkazy, které jste může provádět ve světě Linuxu z nichž jedna je, opět, I. A budeme si vyrobit můj program nyní následovně. 

Místo toho, aby dělal řinčení, namísto toho, aby Clang-o, Jdu prostě Doslova typ, aby ahoj. A teď si všimnout, jsem nepíšete, aby hello.c. Jsem psaní dělat ahoj. 

A tento program, aby to přichází s CS50 IDE a další obecně s Linuxem, je program, který je chystá udělat program s názvem Dobrý den. A to bude předpokládat, podle konvence, že pokud tento program mohou být provedeny, to bude být vyrobeny ze zdroje Kód soubor končící v bodovém c, hello.c. 

Takže když jsem stiskněte klávesu Enter Nyní si všimněte, že Příkaz, který se vykonán je ve skutečnosti ještě déle Před než dříve. A to proto, že jsme předkonfigurované CS50 IDE mít Některé další funkce postavené v tom, že nepotřebujeme ještě ne, ale brzy bude. Ale klíčové si uvědomit Nyní mám program Dobrý den. 

Kdybych typ LS znovu, já mají ahoj program. A můžu běžet ji Tečka a.out lomítko, ne, protože celý smysl této Cvičení bylo tečka lomítko Dobrý den. A teď mám hello world. Takže kupředu, Jsme téměř vždy jen bude kompilovat naše programy příkazem Vytvořit. A pak budeme je provozován dot lomítko a název programu. Ale uvědomit si, co udělat, je dělá pro vy, je to, že není kompilátor. Je to jen výhoda programu že ví, jak vyvolat kompilátor běžet tak, že vy sami ji použít. 

Co další příkazy existují Linux, a podle pořadí CS50 IDE? Brzy vidět, že je tu Příkaz CD, změna Directory. To vám umožní v rámci Váš rozhraní příkazové řádky k pohybu vpřed a zpět, a otevírat různé složky bez použití myši. 

LS jsme viděli, což je zkratka pro seznam soubory v aktuálním adresáři. Udělat Dir, můžete asi začít odvozovat co to znamená now-- aby adresář, Chcete-li vytvořit složku. RM pro odstranění, RM Dir pro odebrat directory-- a ty, Znovu, jsou příkazového řádku ekvivalenty toho, co mohl dělat v CS50 IDE s myší. Ale budete brzy zjistí, že někdy je to jen mnohem rychleji dělat věci s klávesnicí, a nakonec mnohem silnější. 

Ale je to těžké tvrdit, že něco jsme dělali doposud je vše, co silný, když všichni jsme byli říkám, hello world. A ve skutečnosti, I napevno Slova ahoj svět do mého programu. Dosud neexistuje žádná dynamika. Scratch byl řádově zajímavější minulý týden. 

A tak se pojďme se tam dostat. Pojďme se krok směrem, který by způsob, jak některé z těchto funkcí. Takže nejenže C přijít s printf, a svazky dalších funkcí z nichž některé uvidíme v průběhu času, to není aby to všechno tak jednoduché, hned po vybalení brány v získávání uživatelských vstupů. 

Ve skutečnosti je jedním z nedostatků jazyků, jako je C, a dokonce i Java a přesto jiní, je, že to není usnadňují jen dostat věci, jako je celá čísla od uživatelů, nebo řetězců, slova, a fráze, natož věci jako hodnot s plovoucí čárkou, nebo reálná čísla s desetinnými místy a ve skutečnosti dlouhá čísla, jak jsme brzy uvidí. Takže tento seznam funkcí zde, tito jsou stejně jako ostatní Scratch dílků že jsme předinstalované v CS50 IDE, který budeme používat po dobu několika týdnů jak koleček druhů, a Nakonec je sundat, a podívejte se Pod kapotou zřejmě tím, jak jsou tyto věci realizovány. 

Ale jak to udělat, pojďme ve skutečnosti napsat program. Nech mě jít napřed teď. A já jdu k vytvoření nového soubor kliknutím na tento malý Plus, a klepnutím na tlačítko Nový soubor. 

Jdu zachránit tento další jeden jako, řekněme, string.c, protože chci hrát s řetězci. A řetězec v C je jen posloupnost znaků. Takže teď pojďme vpřed a proveďte následující. 

Zahrnují standardní IO.h-- a to dopadá standardní IO, IO prostě znamená vstup a výstup. Tak to dopadá, že Tato linka je zde to, co Je nám sousední použít printf. Printf, samozřejmě, produkuje výstup. Takže aby bylo možné používat printf, to dopadá out musíte mít tento řádek kódu V horní části souboru. 

A vrátíme k tomu, co že ve skutečnosti znamená, že zanedlouho. Ukazuje se, že v jakýkoli program v jazyce C píšu, Musím začít ji kód, který vypadá takto. A všimněte si CS50 IDE a ostatní integrované vývojové prostředí, jako je to, se pokusíme co nejlépe oni mohou dokončit své myšlenky. Ve skutečnosti, před chvílí, když undo co jsem udělal, jsem stiskněte klávesu Enter. 

Pak jsem trefil otevřený kudrnaté rovnátka, stiskněte klávesu Enter znovu. A to dokončil svou myšlenku. To mi dal nový řádek, odsazeny o nic méně pro příjemné stylistických důvodů, uvidíme. A pak se mi automaticky dal že složená závorka dokončit svou myšlenku. Teď to není vždy odhadnout, co chcete dělat. Ale z velké části, to dělá ušetří několik stisků kláves. Takže před chvílí jsme spustili tento program-- Dobrý den, svět, a poté jej sestavil, a pak ji běžel. Ale není zde žádná dynamika. Co kdybychom chtěli dělat něco jiného? No, co kdybych chtěl vlastně získat řetězec od uživatele? Jdu k použití kousek skládačky volal přesně že-- dostat řetězec. 

Ukázalo se, že v jazyce C, že když nechcete, poskytovat informace pro kousek skládačky, nebo více vhodně funkci, budete doslova prostě otevřené závorky, V blízkosti závorka. Takže je to, jako by tam žádný bílý rámeček psát do. Hlavní slovo blok před Měl malou bílou krabičku. Nemáme tu bílý rámeček teď. 

Ale když jsem volat get řetězec I chtít, aby výsledek někde jinde. Takže velmi časté paradigma v C je volání funkce, jako get řetězec tady, a pak uložit svou návratovou hodnotu. Je to výsledek jeho úsilí v něčem. 

A co je konstruovat v programování, ať už v základu, nebo teď C, abychom lze použít k uložení vlastně něco? Volal to proměnná, že jo? A v Scratch, my ne ve skutečnosti jedno, co se děje v proměnných. 

Ale v tomto případě jsme vlastně dělat. Jdu říct řetězec. A pak jsem mohl zavolat to, co chci. Jdu to nazvat jméno, dostane dostat řetězec. 

A teď i když jste trochu na tento nový, Všimněte si, že jsem chybí nějaký detail. Já zapomněla středníkem. Musím dokončit tuto myšlenku. Takže jdu pohnout kurzorem, a udeřil středník tam. A co jsem právě udělal? V tomto řádku kódu, číslo 5 v okamžiku, Volám get řetězec s žádnými vstupy. Takže není málo bílé obrazovka jako na Save blok má. 

Jen říkám, hej, počítač, dejte mi řetězec. Rovnítko není opravdu rovnítko, samy o sobě. Je to úkol operátor, což znamená, hej, počítač, posunout hodnotu Z pravé strany směrem doleva. A v levé strany, mám následující. 

Hele, počítač, dej mi string-- posloupnost znaků. A volat, že String Name. A já nemají ani říkat Name. 

I to mohl zavolat, konvenčně, něco jako S, stejně jako jsme použili i na volat proměnné i. Ale teď musím něco udělat s ním. To by bylo dost hloupé kompilace tento kód, běh tento program, i když Začínám řetězec, protože je to stále jen jít pozdravit svět. 

Ale co když chci to změnit. Proč to mám udělat? Procento s, čárka s. A to je ještě trochu záhadná. 

Takže mi dovolte, aby se mé proměnné jasnější. Dovolte mi, abych pojmenovat tento název proměnné. A uvidíme, jestli nemůžeme dráždit kromě toho, co se tady děje. 

Takže na lince pět, já začínám řetězec. A já ukládání tento řetězec, bez ohledu na uživatel zadal na své klávesnici, v proměnné nazvané názvu. A ukázalo se, že printf není jen trvat jeden argument ve dvoulůžkových citáty, jeden vstup do uvozovek. 

To může trvat dva nebo tři, nebo více, například že druhý, nebo třetí, nebo čtvrtý, jsou všechny názvy proměnných, nebo specificky váží, který chcete zapojit do, dynamicky, že řetězec v uvozovkách. Jinými slovy, to, co by bylo špatného? Kdybych jen pozdravil jméno, lomítko n, mi zachránil soubor, sestavil můj kód, a běžel to, co by se stalo? 

Je to prostě neřekne, ahoj pojmenovat, doslova N-A-M-E, což je tak trochu hloupý, protože to nijak neliší od světa. Takže něco v uvozovkách je co doslova se vytiskne. Takže pokud chci mít zástupný tam, Já vlastně nutné použít některé speciální syntaxe. A ukázalo se, pokud si přečíst Dokumentace pro funkci printf, to vám řekne, že Pokud používáte procent ů, můžete nahradit hodnotu následujícím způsobem. 

Po čárkou po tom dvojité uvozovky, stačí zapsat na jméno proměnná, která chcete zapojit do tohoto formátu kódu nebo Specifikátor formátu, procenta s pro smyčce. A teď, jestli jsem zachránil svůj soubor, Jdu zpátky do mého terminálu. A píšu Udělat řetězec, protože, opět, název této Soubor, který jsem si vybrala, než bude string.c. 

Tak jsem chtěl říct Udělat řetězec, vstoupit. Ach můj bože, podívejte se na všechny chyby jsme udělali už. A to je-- to, co je to opravdu jako šest, sedm řádek programu? Tak tohle je místo, kde to může velmi rychle získat ohromující. 

Toto okno terminálu má Nyní jen vyvrhoval obrovské množství chybových zpráv. Jistě, nemám větší chybu Zprávy než já řádky kódu. Takže to, co se děje? 

No, nejlepší strategie dělat kdykoliv se setkávají drtivá seznam chyb, jako je to, Je posouvat zpět, podívejte se na povel jste právě běžel, což v mém případě je vytvořit řetězec. Podívejte se, co dělají udělal, a to, že dlouhá Clang příkaz, neexistuje žádný velký problém. 

Ale červená je špatná. Green se snaží být jemný a užitečné. Ale je to pořád špatné, v tomto případě. Ale tam, kde je to špatné? 

String.c, linka pět, znak pět. Takže je to jen obyčejný konvence. Něco něco tlustého střeva znamená, Číslo linky a číslo charakter. Chyba, využití nedeklarovaný Řetězec identifikátoru. Měli jste na mysli standardem? 

Takže, bohužel, Clang se snaží být užitečný. Ale je to špatně, v tomto případě. Ne, Clang, neměl jsem na mysli standardní IO. Myslel jsem, že na prvním řádku, ano. 

Ale linka pět Je to jeden tady. A Clang není pochopit, S-T-R-j-n-G. Je to nedeklarovaný identifikátor, je Slovo to prostě nikdy předtím neviděl. A to proto, že C, jazyk píšeme kód právě teď, nemá proměnné zvané řetězce. 

To není ve výchozím nastavení podporu něco, co nazývá řetězec. To je CS50 kus žargon, ale velmi běžné. Ale můžu opravit následujícím způsobem. 

Mám-li přidat jeden řádek kódu v horní části tohoto programu, zahrnují CS50.h, což je další soubor Někde uvnitř CS50 IDE, někde na pevném disku, tak říkajíc, operačního systému Ubuntu že běžím, že je soubor, který je bude učit provozní Systém, co je řetězec, jen jako standardní io.h je soubor v operačním systému, který je bude učit to, co je printf. 

Ve skutečnosti bychom se dostali velmi podobná zpráva pokud IO připustil standardu IO.h a snažil použít printf. Takže já jdu dopředu a jen převzít kontrolu L, abych si pročistil obrazovku. Nebo můžete psát jasné a bude stačí zrušit okno terminálu. Ale stále můžete posouvat zpět v čase. 

A budu znovu spustit Udělat řetězec. Kříž prsty tentokrát Enter. Panebože, to fungovalo. to mi ukazuje dlouhý záhadný povel to je tím, co generována přes Clang, ale žádné chybové zprávy. Takže si uvědomit, přestože můžete získat zcela zahlceni počet chybových zpráv, že to může být tak nepříjemné kaskádových efekt, kdy Clang nerozumí Jedna věc, která ji pak znamená, nerozumí další slovo, nebo další řádek. A tak to prostě tlumivky kódu. Ale oprava by mohla být jednoduchá. A tak vždy zaměří na První řádek výstupu. A jestli ne pochopit, stačí se podívat klíčová slova, která by mohla být záchytné body, a číslo řádku, a charakter, pokud že chyba může být. 

Nyní mi dovolte jít dopředu a zadejte dot lomítko, řetězec, vstoupit. Hm, to není zdravit nic. Proč? No, vzpomínám, kde je to běží? 

Je to pravděpodobně uvízl v tuto chvíli ve smyčce, chcete-li na lince šest, protože Získat řetězec od návrhu, napsal zaměstnanci CS50, je doslova chtěl jen sedět čeká, a čeká, a čeká na provázku. Vše máme na mysli řetězce je vstup člověka. Tak víte co? Nech mě jít napřed. A právě z rozmaru, dovolte mi, abych typ mé jméno, David, vstoupit. Teď mám větší dynamický program. To řekl, ahoj David. 

Mám-li pokračovat a spustit to znovu, zkusím říci jméno Zamila, vstoupit. A teď máme dynamický program. Nemám pevně dáno svět. Nemám těžké kódované pojmenovat, nebo David, nebo Zamila. 

Teď je to mnohem více jako programů Víme, kde pokud to trvat vstup, to produkuje trochu jiný výstup. Nyní, to není nejlepší uživatelské zkušenosti, nebo UX. I spustit program. 

Nevím, co mám dělat, pokud jsem vlastně prohlédnout nebo si pamatovat zdrojový kód. Takže pojďme udělat uživateli zažít trochu lépe s nejjednodušší věcí. Nech mě jít zpátky do toho Program a jednoduše říci printf. 

A nech mě jít dopředu a říkat jméno, tlustého střeva, a prostor, a pak středník. A jen pro zábavu, ne vůle n. A to je úmyslné, protože nechci výzvu pro přesun na další řádek. 

Chci, místo toho to, aby řetězec překompilovat svůj kód do nového stroje Kód tečka lomítko řetězec. Ach, to je mnohem hezčí. Teď už vím, co vlastně počítač chce, abych dělal, dát mu jméno. 

Takže já jdu dopředu a zadejte V Rob, vstupovat, a Dobrý den, Rob. Tak, si uvědomit, je to stále ještě na konci dne, jen devět řádek programu. Ale my jsme vzít tyto dětské krůčky. 

Psali jsme o jeden řádek, s nimiž znali, printf, hello world. Pak jsme odstranili trochu to. A my skutečně použita get řetězec. A my hodil tuto hodnotu v proměnné. A pak jsme šli dopředu a zlepšilo dále s třetím řádku. A to iterativní proces vypalovacím softwarem je opravdu klíčové. V CS50, av životě obecně, měli byste obecně ne sednout, mají program na mysli, a pokusit psaní celá ta zatracená věc najednou. 

To bude nevyhnutelně vést k cestě více chyb než my sami tu neviděl. Dokonce jsem až do dnešního dne, neustále provést další hloupé chyby, jsou vlastně tvrdší chyby které jsou těžší zjistit. Ale budete dělat další chyby tím více řádků kódu psát najednou. A tak to praxe, napsat trochu kódu který vám vyhovuje, kompilaci to, spusťte jej otestovat obecněji pak se přesunout on-- tak stejně jako my stále vrstvení a vrstvení minulý týden, budova z něčeho velmi jednoduché něco složitější, totéž tady. Nesedejte, a pokusit se napsat celý problém. Ve skutečnosti vzít tyto dětské krůčky. 

Nyní, řetězce nejsou všechny že užitečné sami sobě. Měli bychom ve skutečnosti, v ideálním případě, stejně jako na mají v našem souboru nástrojů něco jiného. Takže pojďme vlastně dělat přesně to. 

Nech mě jít dopředu a hned vybičovat trochu jiný program. A budeme nazývat int.c, na celé číslo. Chystám se, podobně, patří CS550.h. Jdu obsahovat standardní IO. A to bude docela obyčejný V těchto prvních dnech třídy. 

A budu připraven Sám s hlavní funkcí. A teď místo toho, jak se dostat řetězec, Pojďme dál a dostat int. Nazvěme to i, a volat to dostat int, úzkým parens, středník. A teď pojďme dělat něco s tím, printf. 

Řekněme, že něco podobného Dobrý den, lomítko n, čárka i. Takže jsem docela hodně napodobování co jsem udělal před chvílí. Mám zástupný zde. Jsem čárkou i tady, protože chci, zapojit i do tohoto zástupného symbolu. 

Tak pojďme do toho a zkuste sestavování tohoto programu. Soubor se nazývá int.c. Tak jsem chtěl říct, aby int, vstoupit. Ach můj bože, ale žádný velký problém, že jo? Tam je chyba. 

K dispozici je syntaktická chyba Zde taková, že program nemůže být sestaveny uvnitř int.c, řádek sedmimístné 27 formátu, chyba specifikuje typ char hvězda, co to je. Ale typ argument je int. 

Takže i zde nebudeme to-- i když dnes je spousta materiálu, budeme vás zahltit naprosto každý rys C, a programování obecněji V právě těchto prvních několika týdnů. Takže tam je často bude žargonu s nimiž nejste obeznámeni. A ve skutečnosti, char hvězda je něco jdeme vrátit do za týden až dva roky. 

Ale teď uvidíme, jestli můžeme analyzovat slova, která jsou obeznámeni. Formáty-- takže jsme slyšeli formát projektant formát kódu předtím. To je obeznámen. Type-- ale argument typu int. Počkej chvíli, já je int. 

Možná procent to vlastně má nějaký uvedený význam. A opravdu, to dělá. Celé číslo, pokud chcete printf jej nahradit, jste skutečně muset použít odlišný formát specifikátor. A vy byste to nevěděl Pokud vám někdo řekl, nebo jste měli to udělal předtím. Ale procent i je co mohou být běžně používané V printf pro připojování celé číslo. Můžete také použít procent d na desítkové celé číslo. Ale já je pěkný a jednoduchý zde. Takže půjdeme s tím. 

Nyní mi dovolte jít dopředu a opakování make int, Enter. To je dobře, žádné chyby. Dot lomítko int-- OK, špatné uživatelské zkušenosti, protože jsem se sám řekl, co dělat. Ale to je v pořádku. Jsem na lov rychle. 

A teď nech mě jít dopředu a zadejte Davida, OK, Zamila, Robe. OK, takže to je dobrá věc. Tentokrát jsem pomocí funkce, puzzle kus, nazvaný get int. A ukázalo se out-- a my viz později v term-- personál CS50 zavedla se řetězec, takovým způsobem, že bude pouze fyzikálně získat řetězec pro vás. 

Že provedl get int takovým způsobem, že to bude jen získat číslo pro vás. A pokud vás, člověk, nespolupracují, je to doslova jen tak říkají opakovat, opakovat, opakování, Doslova tam sedí smyčky, dokud budete zavázat s nějakým magickým číslem, jako je 50 ° C a 50 Dobrý den. 

Nebo když narazíme to znovu a zadejte 42, ahoj 42. A tak se funkce get int Uvnitř této skládačky je dost logické, dost myšlenka, přijít na to, co je to slovo? A co je to číslo? Pouze přijetí, nakonec i čísla. 

Tak to dopadá, že toto není všechno, že expresivní. zatím. Takže hurá, naposledy jsme šlo docela rychle do prováděcích her a animací, a uměleckých děl v nuly. A tady jsme, že obsah s Hello World, a přivítejte 50. 

To není všechno, co inspirativní. A skutečně, tito první pár Příklady bude trvat nějaký čas rozjet vzrušením. Ale máme mnohem víc ovládat se ve skutečnosti. A budeme velmi rychle začít vrstvení v horní části těchto základních tvary. 

Ale první, pojďme rozumět jaké jsou omezení. Ve skutečnosti, jednou z věcí, Scratch není snadné dělejme opravdu vypadat Pod kapotou a pochopit, co je to Počítač je, co to může dělat, a jaké jsou jeho omezení. A opravdu, že nedostatek porozumění, potenciálně dlouhodobý může vést k našemu vlastnímu psaní mistakes-- chyby, psaní nezabezpečeného softwaru, který dostane hacknutý nějakým způsobem. 

Takže pojďme se některé kroky směrem Pochopení tohoto trochu lépe způsob, řekněme, následující příklad. Chystám se jít dopředu a realizovat real rychlý program s názvem zmije. Stejně jako, řekněme, přidat nějaké čísla dohromady. A jdu ke kódu některé rohy tady, a jen kopírovat a vkládat kde jsem byl předtím, jen takže můžeme jít dřív. Takže teď mám základní začátky z programu s názvem zmije. 

A pojďme do toho a toho dosáhnout. Chystám se jít dopředu a řekněme, intx dostane dostat int. A víte co? Pojďme udělat lepší uživatelskou zkušenost. 

Takže řekněme x a účinně vyzve uživatele, aby nám x. A nechte mě jít dopředu a říkat, printf jak se o y je tentokrát čeká dvě hodnoty od uživatele. A pak pojďme prostě jít dopředu a řekněme, printf součet x a y je. A teď nechci dělat procent ů. Chci dělat procent i, lomítko n, a potom připojte součet hodnoty. 

Tak jak můžu jít asi dělá? Víš co? Vím, jak používat proměnné. Nech mě vyhlásit novou, int Z. 

A budu hádat zde. Pokud nejsou rovné v tom znamení jazyk, možná můžu prostě X plus y, tak dlouho, jak jsem skončit můj Myslel s středníkem? Teď se můžu vrátit tady dole, zapojte do Z, dokončit tuto myšlenku se středníkem. A podívejme se nyní, pokud tyto Sekvence lines-- x je dostat int. Y je dostat int. 

Přidejte x a y, ukládat hodnotu v Z- tak opět vzpomenout na rovnítko není rovno. Je to úkol zprava doleva. A pojďme vytisknout že součet z X a Y není doslova z, ale to, co je uvnitř z. Takže pojďme udělat zmije - pěkné, žádné chyby tomto okamžiku. Dot lomítko zmije, vstupovat, x bude 1. 

Y bude 2. A součet x a y je 3. Takže to je všechno v pořádku a dobře. 

Takže byste si představit, že matematiku by měl pracovat v programu, jako je tento. Ale víte co? Je tato proměnná, řádek 12, dokonce nezbytné? Nemusíte se dostat ve zvyku pouhého ukládání věcí do proměnných jen proto, že je to možné. A ve skutečnosti, to je všeobecně považováno za špatné konstrukce Pokud vytváříte proměnnou, nazvaný z v tomto případě něco, co v něm skladování, a pak hned ji používat, ale nikdy znovu. Proč něco dát název stejně jako z Pokud jste doslova bude používat, že to pouze jednou, a to proximální k místu, kde jste vytvořili se v první řadě, tak blízko, pokud jde o řádků kódu? Tak víte co? Ukazuje se, že C je dost flexibilní. Kdybych skutečně chtějí plug-in hodnotách tady, Nepotřebuji vyhlásit novou proměnnou. Mohl bych plug-in X plus y, protože C rozumí aritmetika a matematické operátory. 

Takže můžu jednoduše říci, dělat tuto matematiku, x a y, ať už tyto hodnoty, zástrčka výsledný integer do tohoto řetězce. Takže by to mohlo být, ačkoli pouze jeden řádek kratší, lepší design, lepší program protože tam je méně kódu, a proto méně pro mě pochopit. A je to také jen čistší, pokud nejsme zavádění nových slov, nové symboly, stejně jako z, i když ne ve skutečnosti slouží velký účelu. 

Bohužel, matematika není všichni, že spolehlivé někdy. Pojďme dál a to udělat. Chystám se pokračovat Nyní a proveďte následující. 

Udělejme printf, procento i plus procenta I bude procenta i, n lomítko. A já udělám tohle-- XYX navíc y. Takže jsem prostě jít přepsat to trochu jinak zde. Nech mě to prostě udělat rychlou kontrolu zdravý rozum. Opět platí, pojďme se dostat před sebe. Udělat sčítačka, tečka lomítko výbavu. x je 1, y je 2, 1 a 2 je 3. Tak to je dobře. Ale pojďme zkomplikovat to teď bit, a vytvořit nový soubor. 

Jdu volat tento jeden, říkají, ints, množné číslo pro celá čísla. Začněme, kde jsem byl před chvílí. Ale teď pojďme udělat několik dalších řádků. Nech mě jít dopředu a udělat následující, printf, procento i, minus procenta i, Je procenta i, čárka x, čárka yx minus y. Tak jsem něco dělat jiná matematika tam. Udělejme ještě jeden. Takže procent i časy procent i je i procento, lomítko n. Pojďme plug-in x a y a x y časy. Budeme použít hvězdičku na počítač pro časy. 

Nepoužívat x. x je název proměnné zde. Můžete použít hvězda pro násobení. Udělejme ještě jeden. Printf procenta I, rozdělených podle procent I se procento i, lomítko n. xy děleno y- takže můžete použít lomítko v jazyce C dělat divize. A jdem na jednu další. Zbývající procenta I, rozdělených podle procent I, se procento i. xy-- a teď zbytek je to, co zbude. Při pokusu rozdělením jmenovatele do čitatele, kolik zbude, že jste nemohli rozdělit ven? 

Takže tam není opravdu, nezbytně, symbol jsme použili na základní škole za to. Ale tam v C. Můžete říkat x modulo y, kde Tento znak procenta v tomto context-- zavádějícím způsobem, když jste uvnitř z uvozovek, Uvnitř printf, procenta se používá jako specifikátoru formátu. 

Pokud použijete procent mimo že matematický výraz, je to operátor modulo pro modulární arithmetic-- pro naše účely tady, prostě znamená, jaká je Zbytek x děleno y? Takže x děleno y je x lomítko y. Jaký je zbytek x děleno y? Je x mod y, což by programátor říct. 

Takže když jsem se žádné chyby tady, dovolte mi, abych pokračovat a dělat ints, množné číslo, pěkný, a tečka Slash ints. A pojďme do toho a ano, řekněme, 1, 10. Dobře, 1 plus 10 je 11, kontrola. 1 minus 10 je negativní 9, zkontrolovat. 

1 krát 10 je 10, kontrola. 1 děleno 10 je-- OK, budeme přeskočit, že jeden. Zbývající část 1 děleno 10 je 1. To je správně. Ale je tu chyba tady. 

Takže ten, který jsem dal můj předat, není správné. Myslím, že je to blízko do 0 ° C. 1 děleno 10, víte, když jsme řezání některé rohy, jistě, je to nula. Ale to by mělo být opravdu 1/10, 0,1, nebo 0,10, 0,1000, a tak dále. 

To by nemělo být opravdu nulový. No, ukázalo se, že je počítač dělá doslova to, co jsme to oznámili dělat. Děláme matematiku jako x děleno y. A oba x a y, za řádky kódu dříve, jsou celá čísla. 

Kromě toho, na řádku 15, jsme říkat printf, hej, printf plug-in celé číslo, plug-in celé číslo, plug-in s integer-- specificky x, y a pak, a pak x děleno y. x a y jsou ints. Jsme tam dobře. 

Ale co je x děleno x? x děleno y by měly být, matematicky, desetina, nebo 0,1, což je reálné číslo, reálné číslo mající potenciálně desetinnou čárku. To není celé číslo. 

Ale co je nejblíže číslo 1/10, nebo 0,1? Jo, docela to je nula. 0.1 je takhle moc. A 1 je to moc. Takže 1/10 je blíže k 0, než je jedna. 

A tak to, co C dělá pro us-- druh, protože jsme oznámili to to-- Je zkracovat, že celé číslo. Trvá to na hodnotu, která je opět má být něco jako 0,1000, 0, a tak dále. A to vše zkrácení za desetinnou čárkou tak, že to vše věci, protože to není zapadají do konceptu celé číslo, které je jen číslo jako negativní 1, 0, 1, nahoru a dolů, to vše odhodí za desetinnou čárkou, protože jste nevejde desetinnou čárku V celé číslo podle definice. 

Takže odpověď je zde nulová. Tak jak opravit? Musíme jiné řešení dohromady. A můžeme to udělat, a to následovně. 

Nech mě jít dopředu a vytvořit novou Soubor, tentokrát s názvem floats.c. A uložit jej zde v Stejný adresář, float.c. A nech mě jít dopředu a kopírování některé z těchto kódu z dříve. 

Ale místo toho, jak se dostat int, jdeme na to. Dej mi plovoucí bodovou hodnotu s názvem x. kde s pohyblivou řádovou čárkou Hodnota je jen doslovně něco s plovoucí desetinnou čárkou. Může se pohybovat doleva, doprava. Je to reálné číslo. 

A dovolte mi říkají ne dostat int, ale dostat se plavat, který byl také mezi nabídce možností v knihovně C250. Změňme r na hotovost. Takže to bude mít float. 

A teď nechceme připojit ints. Ukazuje se, že musíme použít procenta f pro float, procento f pro float, a nyní jej uložit. A teď, palce, aby plováky, pěkné, dot lomítko plováky. x bude jeden 1. y Bude 10 znovu. 

A, pěkný, OK můj přírůstek je správný. Doufal jsem, že po dobu delší, ale zapomněl jsem to napsat. Takže pojďme a opravit tuto logickou chybu. 

Pojďme dál a chytit následující. Budeme prostě trochu kopírovat a vložit. A budu říkat minus. 

A budu říkat krát. A já chtěl říct rozdělena. A já nebudu dělat modulo, což není tak germaine zde, děleno f, a doba plus-- OK, pojďme to udělat znovu. 

Dělají plováky, tečka lomítko plováky, a 1, 10, a-- pěkný, ne, OK. Takže jsem idiot. Tak to je velmi častý v informatice dělat hloupé chyby, jako je tato. 

Pro pedagogické účely, co jsem opravdu chtěl dělat byla-li změnit vědu zde na plus, mínus, do doby, a rozdělit, jako vy snad Všiml během tohoto cvičení. Takže teď pojďme re-kompilaci to Program, dělat dot lomítko plováky. 

A potřetí, pojďme uvidíme, jestli to splňuje mé očekávání. 1, 10, vstupovat, ano, OK, 1,000, děleno 10.000, je 0,100000. A ukázalo se můžeme kontrolovat, kolik Čísla jsou po těch desetinná místa. ve skutečnosti budeme. Vrátíme se k tomu. 

Ale nyní, ve skutečnosti, že matematický je správné. Takže, ještě jednou, co je tady stánek s jídlem? Ukazuje se, že v C existují nejen jen strings-- a ve skutečnosti, nejsou ve skutečnosti, protože my přidat ty s knihovnou CS50. Ale tam nejsou jen ints. 

K dispozici jsou také plave. A ukázalo se, spoustu dalších údajů Typy také, že budeme používat zanedlouho. Ukázalo se, že chcete-li jediný znak, nikoli řetězec znaků, můžete použít jen znak. 

Ukazuje se, že pokud chcete bool, logickou hodnotu pravda, nebo jen nepravdivé, Díky knihovně CS50, máme přidán do C datový typ bool stejně. Ale je to také přítomný v mnoho jiných jazyků stejně. A ukázalo se, že někdy Potřebujete větší množství pak přijde ve výchozím nastavení s ints a plováky. 

A ve skutečnosti, dvojitý je číslo který používá ne 32 bitů, ale 64 bitů. A long je číslo, které používá ne 32 bitů, ale 64 bitů, respektive pro plovoucí desetinnou čárkou hodnoty a celá čísla, resp. Tak ať to vlastně nyní vidět v akci. 

Chystám se pokračovat zde a vybičovat jeden jiný program. Zde budu pokračovat a to zahrnuje CS50.h. A nech mě jít, zahrnují standardní IO.h. 

A všimněte si něco funky se tady děje. Není to barevné kódování věci stejným způsobem, jako tomu bylo dříve. A ukázalo se, že je to proto, že jsem nedal ta věc název souboru. 

Jdu zavolat tenhle sizeof.c, a udeřil na Uložit. A všimněte si, co se stane s mým velmi bílá kód proti tomuto černému pozadí. A teď, aspoň je tu některé fialové tam. A to je syntaxe zvýrazněny. 

To proto, že zkrátka jsem řekl IDE, jaký typ souboru je to tím, že mu jméno, a specificky příponu souboru. Teď pojďme do toho a toho dosáhnout. Chystám se jít dopředu a velmi jednoduše vytisknout following-- bool Je procenta LU. 

Vrátíme se k že za chvíli. A pak jdu velikost tisku bool. A teď, jen proto, aby ušetřit Sám nějaký čas, jsem dělat celek banda z nich najednou. A konkrétně, jdu změnit na char a char. Ten, budu měnit na dvojnásobek a double. 

Ten, budu měnit s plovákem a hotovost. Ten, budu změnit na int a int. A tenhle, budu Pro změnu na long. A to stále trvají dlouhá doba, dlouhá dlouhá. 

A pak konečně jsem dal Sám jeden příliš mnoho, řetězec. Ukazuje se, že v jazyce C, je tu speciální operátor nazvaný velikost, která je doslova bude při spuštění, řekněte nám velikost každé z těchto proměnných. A je to způsob, nyní můžeme připojit zpět z minulého týdne diskuse dat a reprezentace. 

Nech mě jít dopředu a kompilovat velikost bodového velikosti lomítko části. A podívejme. Ukazuje se, že v jazyce C, konkrétně na CS50 IDE Zejména pokud jde o operační systém Ubuntu, což je 64-bitový operační Systém v tomto případě boolovské se chystá pouze jeden bajt prostoru. To je, jak se měří velikost, není v bitech, ale v bytech. A připomínají, že jeden bajt je osm bitů. Takže bool, přestože Technicky je třeba pouze 0 nebo 1, je to trochu zbytečné Jak jsme implementoval. Je to vlastně bude používat celek byte-- takže všechny nuly, jsou možná všechny z nich, nebo něco takového, nebo jen jeden 1 mezi osm bitů. 

Char, mezitím, který se používá pro znak jako ASCII znak za minulého týdne, bude jeden znak. A to synchs s naší představou přičemž ne více než 256 bits-- spíše, synchs se s tím, že ne delší než 8 bitů, což dává nám tolik jako 256 hodnot. Dvojité se chystá být 8 bajtů nebo 64 bitů. 

Plovoucí je 4. Int je 4. Dlouhý, dlouhý je 8. A je řetězec 8. Ale nebojte se o tom. Budeme sloupněte tuto vrstvu. Ukázalo se, že řetězce mohou být delší než 8 bajtů. 

A opravdu, jsme napsali struny Již hello world, delší než 8 bajtů. Ale vrátíme do že za chvíli. Ale odnést tady je následující. 

Každý počítač má jen konečný množství paměti a prostoru. Můžete ukládat pouze tolik soubory na počítači Mac nebo PC. Můžete uložit jen tolik programů RAM běží najednou, nutně, a to i s virtuální paměti, protože Máte omezené množství paměti RAM. 

A jen proto, aby v případě, picture-- jste nikdy otevřel notebook nebo objednat další paměť pro počítače, nemusí vědět, že uvnitř počítače je něco, co vypadá trochu jako je tento. Takže je to jen obyčejný společnost s názvem Rozhodující, aby činí RAM pro počítače. RAM je místo, kde programy žít, zatímco oni běží. 

Takže na každém počítači Mac nebo PC při poklepání Klepněte na program, a to otevírá, a otevírá nějaký dokument Word nebo něco takového, uloží jej do paměti dočasně RAM, protože RAM je rychlejší než pevný disk, nebo Váš solid state disk. Takže je to právě tam, kde programy jít žít, když používáte, nebo pokud jsou používány soubory. 

Takže máte věci, které vypadají takhle uvnitř vašeho notebooku, nebo mírně větší věci uvnitř počítače. Ale klíč je máte jen konečný počet těchto věcí. A je tu jen omezené množství hardware sedí na tomto stole vpravo zde. 

Takže určitě nemůžeme skladovat nekonečně dlouhá čísla. A přesto, pokud si myslíte, zpět do obecná škola, kolik číslic může Máte doprava o desetinnou čárkou? Když na to přijde, kolik číslic může máte vlevo od desetinné čárky? Opravdu, nekonečně mnoho. 

Nyní, my lidé by mohl jen umět vyslovit milionů, a miliardy, trillion, a kvadrilion a quintillion. A já posouvat hranice mého understanding-- nebo my-- Rozumím Čísla, ale my výslovnost čísel. Ale oni mohou dostat nekonečně velké s nekonečně mnoho Číslice vlevo nebo napravo od desetinné čárky. 

Ale počítače mají pouze omezené množství paměti, konečný počet tranzistorů, je konečný počet žárovek uvnitř. Takže co se stane, když vám dojdou prostoru? Jinými slovy, pokud vzpomenout na poslední týden Když jsme mluvili o číslech samy o sobě jsou zastoupeny v binárním, Domníváme se, že máme Tento 8-bitová hodnota zde. 

A máme sedm 1 a jedna 0. A předpokládám, že chceme přidat 1 k této hodnotě. To je opravdu velké číslo právě teď. 

To je 254, pokud si dobře vzpomínám matematický z minulého týdne vpravo. Ale co když změním že nejpravější 0 na 1? Celé číslo, ze Samozřejmě, že se stane osm 1 je. Takže jsme pořád dobré. 

A to pravděpodobně představuje 255, i když v závislosti na kontextu mohlo by ve skutečnosti představovat záporné číslo. Ale o tom až jindy. Tento pocit, že to o tak vysoko, jak se mohu spolehnout. 

Nyní je pouze 8 bitů. A můj Mac, určitě má cestu více než 8 bitů paměti. Ale to přece má konečný. Takže stejný argument platí, i kdybychom mají více z těchto ty na obrazovce. 

Ale co se stane, když jste uložení toto číslo, 255, a chcete spočítat jeden kousek výš? Chcete-li jít od 255 do 256. Problémem ovšem je, že pokud začíná počítat od nuly, jako minulý týden, nemůžete počítat jako s vysokým as 256, natož 257, natož 258 m, protože to, co se stane, když přidáte 1? Pokud tak učiníte starou základní školu přístup, dáte 1 tady, a pak 1 plus 1 je 2, ale to je opravdu nula, můžete nést 1, nést 1, nesou 1. Všechny tyto věci, Tyto 1, přejděte na nulu. A skončíš, ano, jako někoho, poukázal na to, 1 na levé straně. Ale vše, co můžete skutečně vidět a vejde do paměti Je jen osm 0 je, což znamená, na nějakém místě, pokud vás, počítač, Zkoušel počítání dostatečně vysoko, že jste bude zalomit kolem, jak se zdá, na nulu, nebo dokonce negativní Čísla, která jsou dokonce nižší než nula. 

A můžeme trochu vidět. Nech mě jít dopředu a psát skutečný rychlý programu zde. Nech mě jít dopředu a psát program s názvem přetečení. Patří CS50.h, zahrnují Standardní IO.h-- oh, Opravdu zmeškal zvýrazňování syntaxe. Takže pojďme uložit jako overflow.c. 

A teď int main void-- a netrvalo dlouho, zmíníme vrátit se k vysvětlením, proč držíme psaní int main neplatné. Ale teď, ať to prostě udělat to, brát to jako samozřejmost. Dejme sám int, a inicializovat ji na hodnotu 0. 

Pojďme pak udělat pro int i získat zero-- ve skutečnosti, pojďme udělat nekonečnou smyčku a uvidíme, co se stane. I když pravda, pak pojďme vytisknout n Je procenta i, n lomítko, plug-in n. Ale teď, pojďme dělat n dostane n plus 1. 

Takže jinými slovy, na každém iterace tohoto nekonečné smyčky, berme hodnotu n je, a přidat 1 k němu, a poté uložení výsledku zpět do n na levé straně. A ve skutečnosti, jsme viděli syntax Mírně takhle krátce. Chladný trikem je namísto psaní to všechno pryč, můžete skutečně říci n a rovná1. 

Nebo opravdu chcete být fantazie, pokud si, můžete říci, n a navíc středník. Ale tyto dva posledně jmenovaní jsou jen co bychom zavolat syntaktický cukr Pro první věc. 

První věc, kterou je jasnější, naprosto v pořádku, zcela správné. Ale to je běžnější, řeknu. Takže budeme to jen na chvíli. 

Podívejme se nyní, aby přepad, který zní poněkud zlověstný, dot přetečení lomítko. Podívejme se, n je stále dost velký. Ale řekněme si, jak velký může dostat n? 

n je int. Viděli jsme před chvílí s velikostí Příkladem že int je čtyři bajty. Víme, že od minulého týdne, čtyři byty je 32 bitů, protože 8 krát 4, to je 32. Že to bude 4 miliardy. 

A my jsme až 800,000. To bude trvat věčně počítat tak vysoko, jak jsem jen možné. Takže budu pokračovat, Jak jste si možná zanedlouho, a stiskněte Control C- řečeno, Control C, hodně, kde se provádí kontrola C celkově prostředky zrušit. Bohužel, protože toto běží v cloudu, Někdy oblak je plivat tolik věcí, tolik výstup, bude to chvíli trvat pro můj vstup se dostat do cloudu. Takže i když jsem trefil Ovládací C před několika sekund, je to určitě boční Účinek nekonečné smyčce. 

A tak v takových případech, my jsme opustí to být. A budeme přidávat další okno terminálu sem s plus, což samozřejmě neklade takhle, protože je to stále myslí. A pojďme do toho a bude trochu rozumnější. 

Chystám se jít dopředu a dělat toto jen konečně mnohokrát. Pojďme použít pro smyčce, který zmiňoval jsem se dříve. Pojďme to udělat. Dej mi ještě proměnnou int i dostane 0. i je nižší než, řekněme, 64 i ++. A teď nech mě jít dopředu a tisk out n je procento i, n čárka. A pak n- je to stále bude trvat věčně. Pojďme to udělat. 

n dostane n-krát 2. Nebo bychom mohli být ozdobný a to časy rovná 2. Ale řekněme, že n rovná samotné krát 2. Jinými slovy, v této Nová verze programu, Já nechci čekat věčně od podobných 800.000 až 4 miliardy. Řekněme to máme za sebou. 

Pojďme skutečně zdvojnásobit n pokaždé. Což, recall, je zdvojnásobení Opakem mají, samozřejmě. A vzhledem k tomu minulý týden máme opět něco, a znovu, a znovu, super rychlý, Zdvojnásobení budou jistě dostat nás od 1 do největší možný hodnota, kterou můžeme počítat, aby s int. 

Takže pojďme dělat přesně to. A vrátíme se k tomu zanedlouho. Ale to je opět stejně jako opakování blok v Scratch. A budete používat tento zanedlouho. 

To prostě znamená počítat od nuly až do, ale ne stejné, až 64. A na každém opakování této smyčka, jen držet postupně i. Takže i ++ - a tento obecný konstrukt Na řádku 7 je prostě super obyčejný způsob, opakujících se několik řádků kód, někteří kolikrát. Které řádků kódu? Tyto složené závorky, jako vy může být sbírána od této chvíle, znamená, postupujte následovně. 

Je to v jako Scratch, když má žluté bloky a jiné barvy, které druh objetí nebo obejmout dalších bloků. To je to, co ty kudrnatý rovnátka jsou tady. Takže když jsem dostal syntaxi right-- vás můžete vidět symbol mrkev v C prostředků to je kolikrát jsem byl se snaží tento problém vyřešit. Takže pojďme se zbavit že jeden dohromady, a zavřít to okno. A budeme používat novou. Udělat přepad, dot lomítko přepad, Enter, v pořádku, to vypadá špatně na prvním místě. Ale pojďme posunout zpět v čase, proto, že jsem to udělal 64-krát. 

A Všimněte si, poprvé, n je 1. Podruhé, n je 2, pak 4, pak 8, pak 16. A zdá se, že jakmile I dostat do zhruba miliarda, jestli jsem to dvakrát znovu, že by měl mi dát 2 miliardy. Ale ukazuje se, že je to přímo na prahu. 

A tak to vlastně přetečení int od 1 miliardu zhruba negativní 2 miliardy, protože celé číslo, Na rozdíl od čísel, která máme byly za předpokladu minulý týden, může být jak pozitivní, tak negativní ve skutečnosti a v počítači. A tak alespoň jeden z těch, bitů je účinně ukraden. Takže jsme opravdu pouze 31 bitů, nebo 2 miliardy možných hodnot. 

Ale teď, stánek s jídlem je docela Jednoduše řečeno, bez ohledu na tato čísla jsou a to bez ohledu na matematika, se stane něco špatného nakonec, protože nakonec se snažíte permutaci bitů jeden příliš mnohokrát. A efektivně přejít ze všech 1 je pro všechny možná 0 je, nebo možná Jen nějaký jiný vzor, ​​který ji Je zřejmé, že v závislosti na kontextu, lze interpretovat jako záporné číslo. A tak by se mohlo zdát nejvyšší I může počítat v tomto konkrétním programu Pouze zhruba miliarda. Ale je tu částečné řešení zde. Víš co? 

Dovolte mi, abych měnil z int k dlouhé dlouhé. A nech mě jít napřed zde a say-- budu mít tento stav změnit na unsigned long. Nebo se podívejme, nikdy Vzpomínám si sám. 

Pojďme dál a dělat přetečení. Ne, to není ono, LLD, děkuji. Takže někdy Clang může být užitečný. Nepamatoval jsem si, jaký formát specifikátor byl na dlouhou dlouho. 

Ale opravdu, Clang mi to řekl. Green je nějaká dobrá, Stále znamená, že jste udělali chybu. Je to hádat, že jsem měl na mysli LLD. 

Tak ať mi to brát radu, dlouhá dlouhá desetinné číslo, kromě toho, že. A dovolte mi, abych ji znovu spustit, dot lomítko přetečení, Enter. A teď, co je v pohodě, je to. 

Kdybych posouvat zpět v čase, stále začít počítání na stejné place-- 1, 2, 4, 8, 16. Všimněte si, dostaneme všichni cesta až 1 miliardy. Ale pak jsme se bezpečně dostat na 2 miliardy. 

Pak jsme se dostat na 4 miliardy, pak 8000000000, 17000000000. A my jít výš, a vyšší a vyšší. Nakonec, i to zlomí. 

Nakonec, s dlouhou dlouhá, což je 64-bitová hodnota, nikoliv 32-bitová hodnota, pokud počítáš příliš vysoká, můžete zabalit kolem 0. A v tomto případě jsme se náhodou skončit s záporné číslo. 

Takže se jedná o problém. A ukázalo se, že toto Problém není všechno, že tajemný. I přesto, že jsem úmyslně indukované to s těmito chybami, to dopadá to vidíme trochu ze všeho kolem nás, nebo alespoň někteří z nás dělat. 

Takže Lego Star Wars, pokud jste někdy hráli hru, to dopadá můžete objet lámání, co se v LEGO světě, a sbírání mincí v podstatě. A pokud jste někdy hráli tato hra příliš mnoho času, jako tento nejmenovaný jednotlivce tady dělal, celkový počet mincí, které můžete sbírat znamená, že by se mohlo zdát, 4 miliardy. 

Teď, když je to vlastně zaoblené. Takže LEGO se snažila udržet věci uživatelsky přívětivý. Oni to neudělali přesně 2 až 32 výkon, za minulého týdne. Ale 4000000000 je důvod, proč. Zdá se, že na základě těchto informací, že LEGO, a společnost, která učinil toto aktuální software, rozhodl že maximální počet mincí uživatel může hromadit Je skutečně 4000000000, protože oni si vybrali v jejich kódu k použití není dlouhá dlouhá, zdá se, ale jen celé číslo bez znaménka celé číslo, pouze kladné celé číslo, jehož max hodnota je zhruba to. No, tady je další legrační. Takže ve hře Civilization, který někteří z vás by mohl být obeznámeni s Ukazuje se, že tam před lety Byla to chyba v této hře, přičemž pokud jste hrál roli Gándhího ve hře, místo něj byl velmi pacifista, Místo toho byl neuvěřitelně, neskutečně agresivní, za určitých okolností. A zejména způsob, jakým civilizace Práce je, že pokud se hráč, přijmou demokracii, vaše agresivita skóre dostane sníží o dva, takže minus minus, a potom minus minus. 

Takže si odečíst z 2 vaše skutečné Iterace. Bohužel, pokud vaše Iterace je zpočátku 1, a odečíst 2 z něj po přijetí demokracie jak Gandhi zde mohlo udělal, protože byl velmi passive-- 1 v měřítku agresivity. Ale když přijme demokracii, pak se pohybuje od 1 do negativní 1. 

Bohužel, oni byli pomocí nepodepsané čísla, což znamená, že ošetřené dokonce záporná Čísla jako by byly pozitivní. A ukázalo se, že pozitivní ekvivalent negativní 1, v typických počítačových programů, je 255. Takže pokud Gandhi přijme demokracie má, a tudíž Jeho agresivita skóre snížil, to vlastně valí kolem 255 a dělá ho nejvíce agresivní charakter ve hře. Takže si můžete Googlu se na to. A bylo to opravdu, což náhodná programování chyba, ale to je docela vstoupil ten svět od té doby. 

To je vše zábavné a roztomilé. Děsivější je, když skutečná reálných zařízení, a ne hry, mají tytéž chyby. Ve skutečnosti, před rokem přišel článek out o Boeing 787. 

A článek na prvním místě pohled zní trochu Arcane. Ale to řekl, software zranitelnost v Boeing Nová 787 Dreamliner má jet potenciál způsobit piloty ztratit kontrolu letadlo, případně V polovině letu, úředníci FAA varoval aerolinie v poslední době. To bylo stanovení že model 787 letoun, který byl poháněn nepřetržitě po dobu 248 dní může ztratit veškerý střídavý proud, AC, elektrické energie v důsledku generátoru Řídicí jednotky, GCUs současně jít do nouzového režimu selhání. Je to trochu mě ztratí. Avšak memo uvedl, OK, teď mám, že podmínka byla způsobena softwarem proti interní řídicí generátor Jednotky, které přeteče po 248 dní nepřetržitého výkonu. Jsme to vydávající Všimněte si, aby nedošlo ke ztrátě Ze všeho střídavé elektrické energie, což by mohlo mít za následek ke ztrátě kontroly letounu. 

Takže doslova, tam je nějaké číslo, nebo nějaký ekvivalent datový typ, se používá v softwaru ve skutečném letadle že pokud budete mít vaše letadlo na dost dlouho, což zřejmě může být v případě, pokud jste právě běží je neustále a nikdy odpojování vaše letadlo, jak se zdá, nebo pouštění jeho vybijí baterie, nakonec počítat nahoru a nahoru a nahoru a nahoru a nahoru, a nahoru. 

A od přírody, je omezené množství paměti přeteče, návratu k nula nebo některé záporné hodnoty, vedlejší účinek, což je děsivě skutečné reality že letadlo může potřebovat být restartován, efektivně, nebo by mohly spadnout ještě hůře, jak to letí. Takže tyto druhy otázek jsou stále s námi, even-- to bylo 2015 článek, všechny ještě děsivější když ne nutně pochopit, ocenit, nebo předvídat tyto druhy chyb. 

Tak to dopadá je tu ještě jedna další špatná věc, o reprezentaci dat. Ukazuje se, že i plováky jsou druh chybné, protože plováky taky, Navrhl jsem se 32 bitů, nebo Možná 64, pokud používáte double. Ale to je ještě konečný. 

A Háček je v tom, že pokud je to možné dát nekonečný počet čísel za desetinnou čárkou, není tam žádný způsob, jak mohou reprezentovat všechny možné čísla, která nás učili V základní škole se mohou vyskytovat ve světě. Počítač, v podstatě, musí zvolit podskupinu těchto čísel reprezentovat přesně. 

Nyní, nemůže-li počítač kolo možná trochu, a může vám umožní zhruba obchodu libovolné číslo byste mohli přát. Ale jen intuitivně, pokud vás mají konečný počet bitů, můžete permutaci jen jim v mnoha konečných způsoby. Takže si nemůže použít konečný počet permutace bitů, vzory nul a jedniček, reprezentovat nekonečný počet čísel, což naznačuje, že by mohly počítače Velmi dobře se nám lže občas. 

Ve skutečnosti, jdeme na to. Nech mě jít zpátky do CS50 IDE. Nech mě jít dopředu a vytvořit malý program tzv Nepřesnost, ukázat, že Počítače jsou skutečně nepřesné. 

A nech mě jít dopředu a začít s některé z těchto kódu před rokem, a teď jen provést následující. Nech mě jít dopředu a udělat printf, procento f, n lomítko, 1 děleno 10. Jinými slovy, pojďme ponořit hlouběji 1/10, jako je 1 a děleno 10. Jistě, počítač může představovat 1/10. 

Tak pojďme do toho a dělat nepřesnost. Uvidíme. Formát Určuje typ double. Ale tento argument má typ int. Co se děje? 

Oh, zajímavý, takže je to ponaučení z předtím. Říkám, hej, počítač zobrazit mi plovák s procenta f. Ale já dávat to 2 celých čísel. Tak to dopadá, mohu opravit to v několika ohledech. 

Mohl jsem jen otočit jeden do 1,0, a 10 do 10,0, což by, samozřejmě, má za následek převedení je do floats-- stále s nadějí stejný počet. Nebo se ukáže, je tu něco, uvidíme opět zanedlouho. Dalo by se obsazení čísla. 

Můžete pomocí tohoto kulatých závorek výrazem, můžete říci, hej, počítač, vzít 10, o němž vím, je int. Ale zacházet s tím, prosím, jako kdyby je to float. Ale to cítí zbytečně složité. 

Pro naše účely dnes, Řekněme, doslovně činí je plovoucí bodové hodnoty s desetinnou čárkou, jako je tento. Nech mě jít dopředu a opakování, aby nepřesnost, dobrá, dot lomítko nepřesnost, vstoupit. OK, máme dobrý vzhled. 

1 děleno 10, podle mého Mac tady, je vskutku 0,100000. Teď jsem se učil na základní škole tam by měl být nekonečný počet 0 let. Takže pojďme se alespoň pokusit vidět některé z nich. Ukazuje se, že printf je trochu milovník ještě než jsme používali. Ukazuje se, že nemusíte specifikovat Jen procent f, nebo prostě procenta i. Ve skutečnosti můžete zadat některé kontrolní možnosti zde. 

Konkrétně Jdu říkat, hej, printf, ve skutečnosti mi ukázat 10 desetinných míst. Tak to vypadá trochu divně. Ale říkáte procent, tečka, kolik čísel Chcete-li vidět po desetinnou čárkou, a pak f pro ploché, jen proto, že je co dokumentace říká. Nech mě jít dopředu a kromě toho, že. 

A všimněte si také, začínám unavený přepisování věci. Takže jsem prostě nastavení nahoru a šipka dolů na mé klíče zde. A když jsem pořád bít, ty můžete vidět všechny příkazy že jsem udělal, nebo nesprávně vyrobeny. 

A já jdu dopředu a hned Není vlastně používat, že zdánlivě. Udělat Nepřesnost, tečka lomítko imprecision-- tak co jsem se naučil v základní škole odhlásí. Dokonce i když jsem ji vytisknout až 10 desítkové ji skutečně je 0,10000. Ale víte co? 

Pojďme trochu chamtivý. Řekněme, jako, ukaž mi 55 poukazuje za desetinnou čárkou. Pojďme opravdu vzít naprogramovat ven na projížďku. Nech mě předělat s make nepřesnost, tečka lomítko, nepřesnost. 

A tady jdeme. Vaše dětství byla lež. Zdá se, že 1 děleno 10 je skutečně 0.100000000000000005551115123-- 

Co se děje? Tak to dopadá, když se druh vypadat dost daleko do podkladových Zastoupení tohoto číslo, to vlastně není přesně 1/10, nebo 0,1 a nekonečný počet nul. A teď, proč tomu tak je? 

No, i když je to jednoduchý Číslo na nás lidi, 1 děleno 10, je to stále jedna z nekonečně mnoho čísla, která jsme mohli vymyslet. Ale počítač může představovat pouze konečně mnoho takže čísla. A tak efektivně, co Počítač se ukazuje nám je jeho nejbližší přibližování k číslu Chceme věřit, je 1/10, nebo opravdu 0,10000 ad infinitum. 

Spíše, když se jedná tak blízko, jak to může dostat. A skutečně, když se podíváte Pod kapotou jak jsme tady prohlížením 55 číslic za desetinnou čárkou, jsme vlastně vidět, že realitu. Nyní jako stranou, pokud jste někdy viděl movie-- většina z vás pravděpodobně haven't-- ale před Superman 3 několika lety, Richard Pryor v podstatě zadlužuje tento realita v jeho společnosti ukrást hodně zlomků a zlomcích haléře, protože company-- pokud si dobře vzpomínám, byl to while-- byla v zásadě zahodili všechno, co nezapadl do pojmu centů. 

Ale pokud sečtete všechny tyto malé, malé, drobné čísla znovu, a znovu a znovu, můžete, stejně jako v jeho případ, udělat dobrý množství peněz. 

Ten stejný nápad byl ošizen novější, ale teď starší film, nazvaný Kancelářské prostory, kde kluci v tomto filmu, udělal to samé, našroubovat ji úplně, skončil s cestou příliš mnoho peníze na svůj bankovní účet. Bylo to všechno velice podezřelé. Ale na konci dne, nepřesnost je všude kolem nás. 

A to také může být děsivě případ. Ukazuje se, že Superman 3 Kancelářské prostory a stranou, tam mohou být některé velmi reálné svět následky z realit nepřesný reprezentace dat že i my lidé do tento den nemusí nutně chápat stejně jako bychom měli, nebo si pamatovat tak často, jak bychom měli. A vskutku, následující klip z pohledu na některé velmi reálném světě Důsledky, co se stane, když vás neváží nepřesnost, která se může stát v číslech reprezentaci. 

[VIDEOPŘEHRÁVÁNÍ] 

-Computers, Všichni jsme si zvykli na jsou často nepříjemné problémy, které jít s them-- chyb, virů, a softwarové závady, Pro malé ceny platit pro pohodlí. Ale v high-tech a vysokou rychlostí vojenský a kosmický program aplikace, Nejmenší může problém zvětšovat do katastrofy. 

Dne 4. června 1996, připravené vědci zahájit bezpilotní Ariane 5 rakety. To nesl vědecké satelity navržen stanovit přesně, jak se vzájemnému působení magnetického pole Země se solárními větry. Raketa byla postavena Evropská kosmická agentura, a odstartovala z jejího zařízení na pobřeží Francouzské Guyany. 

-Na Asi 37 sekund do let, se poprvé Všiml se něco děje špatně. Trysky byly otočné v způsob, jak se opravdu neměli. Přibližně 40 sekund do letu, Je zřejmé, že vozidlo bylo v potížích. 

A to je, když oni dělali rozhodnutí ho zničit. Bezpečnostní důstojník rozsah, s obrovské střeva, stiskl tlačítko, vyhodil raketu, předtím to mohlo představovat nebezpečí pro veřejnou bezpečnost. 

Tohle byla panna plavba Ariane 5. A jeho zničení vzal místo z důvodu chyby vložené do softwaru rakety. -The Problém na Ariane byl že existuje celá řada, která vyžadováno 64 bitů vyjádřit. A chtěli převést to na 16-bitové číslo. Se předpokládá, že číslo bylo nikdy být velmi velká, že většina z nich Číslice v 64-bitové číslo byly nuly. Mýlili se. 

-The Neschopnost jednoho Softwarový program přijímat druh číslo generované Dalším byl u kořene selhání. Vývoj softwaru se stala velmi nákladné součástí nové technologie. Raketa Ariane byly velmi úspěšný, tolik softwaru vytvořen pro to bylo také použit v Ariane 5. 

-The Základním problémem bylo to, že Ariane 5 byl rychlejší, urychlováním. A software neměl účtuje za to. 

-The Zničení rakety Byla to obrovská finanční katastrofa, vše kvůli chybě minut softwaru. Ale to nebyl první Problémy s konverzí dat časové byl sužován moderní raketové techniky. 

-in 1991, se startem první války v Perském zálivu, Patriot Missile zažil podobný typ konverzního číslo problému. A jako výsledek, 28 lidí, 28 amerických vojáků, bylo zabito a asi 100 dalších zraněno, když Patriot, který měl chránit před přicházejícími scudy, nedokázal vystřelit raketu. 

-Když Irák napadl Kuvajt, a Ameriku zahájena Pouštní bouře počátkem roku 1991, Patriot Missile baterie byly nasazeny chránit Saudskou Arábii a Izrael z iráckých raketových útoků Scud. Patriot je v USA středního doletu povrch vzduchového systému, vyráběné od firmy Raytheon. 

-Velikost Patriot interceptor sama o sobě je asi zhruba 20 stop dlouhý. A váží asi 2000 liber. A to s sebou nese hlavici asi, Myslím, že to je zhruba 150 liber. A hlavice je sám o sobě vysoce výbušný, který Má fragmenty kolem něj. Pouzdro hlavice je navrženy tak, aby chovat jako hrubé broky. 

-The Rakety jsou prováděny čtyři na kontejner, a jsou přepravovány pomocí návěsu. 

-The Patriot protiraketový systém sahá nyní nejméně 20 let. Původně byl vyvinut jako obranné rakety vzduchu sestřelit nepřátelské letouny. V první války v Perském zálivu, když ta válka přišla, Armáda ji chtěl použít k sestřelit scudy, ne letadel. 

Irácké letectvo bylo Není tak velký problém. Ale armáda byla starosti scudy. A tak se snažili upgrade Patriot. 

-Intercepting Nepřítele raketa jede mach 5 šel být dost náročné. Ale když Patriot byl běhavý do provozu armáda nebyl vědom Irácký modifikace, která vyrobený jejich Pluje téměř nemožné zasáhnout. 

Co se stalo je, že Pluje přicházely byly nestabilní. Byly kymácení. Důvodem je to Iráčané za účelem získat 600 kilometrů z 300 kilometr doletu, vzal váhu z přední hlavice. Udělali hlavice lehčí. 

Takže teď je Patriot snaží se přijít na Scud. A většinu času, Drtivá většina z času, to by jen létat podle Scud. Jakmile provozovatelé Systém Patriot si uvědomil, že Patriot minul svůj cíl, oni odpálili Patriot v hlavici aby se zabránilo případným obětem pokud se nechá spadnout na zem. 

-To Je to, co většina lidí viděla, Ty velké ohnivé koule na obloze, a nepochopený as zachytí Scud hlavic. 

-Although V noci nebe, Patriots se objevil být úspěšně ničit scudy na Zahránu, tam mohl být žádná chyba o jeho výkonnosti. Tam, radarový systém Patriot ztratil na příchozí Scud, a nikdy zahájen v důsledku na software chybu. Bylo Izraelce, kteří poprvé objeven že čím delší je systém byl na, tím větší je časový nesoulad se stal v důsledku hodiny vložené V počítači systému. 

-O Dva týdny před Tragédie v Dhahran, Izraelci hlášeno ministerstvo obrany že systém ztrácí čas. Po asi osm hodin nebo běh, si všimli, že v systému stal se nápadně méně přesné. Ministerstvo obrany reagovala říkat všechny baterie Patriot nenechat systémy na dlouhou dobu. Oni nikdy neřekl, co je to dlouhá doba was-- osm hodin, 10 hodin, 1000 hodin. Nikdo nevěděl. 

-The Patriot baterie umístěný v kasárnách na Zahránu a její chybné interní Hodiny byl na více než 100 hodin v noci z 25. února. 

-Je Sledoval čas s přesností asi desetinu sekundy. Nyní desetin sekundy je zajímavé číslo, protože nemůže být vyjádřena v binárním přesně, což znamená, že nemůže být vyjádřen přesně v každém moderním digitálním počítači. Je těžké tomu uvěřit. 

Ale použít jako příklad. Vezměme si číslo jedna třetina. Třetina nemůže být vyjádřené v desítkové soustavě přesně. Jedna třetina je 0,333 děje na nekonečno. 

Neexistuje žádný způsob, jak to udělat s absolutní přesnost v desítkové soustavě. To je přesně ten druh problému která se stala v Patriot. Čím delší je systém běžel se hůře se stala chyba čas. 

-Po 100 hodinách provozu Chyba v době byl jen asi třetina sekundy. Ale pokud jde o cílení raketa jede Mach 5, to vedlo ke sledování Chyba více než 600 metrů. Bylo by fatální chyba pro vojáky o tom, co Stalo je Scud start byl detekovány satelity včasného varování a oni věděli, že Scud byl přichází ve svém obecném směru. Nevěděli, kde se blíží. 

-To Byl nyní na radaru součást systému Patriot bránit Zahránu najít a udržet Trať příchozí nepřátelské rakety. 

-The Radar byl velmi chytrý. To by ve skutečnosti sledovat poloha Scud, a pak předpovědět, kde to asi bude příště radar odesláno puls ven. Který byl nazýván řada brána. 

-Tak, Jakmile Patriot Rozhodne dost času má předán vrátit a zkontrolovat další umístění tohoto detekovaným objektem, se vrací. Takže když se vrátil k špatný Místo toho pak nevidí žádný objekt. A to se rozhodne, že neexistuje objekt, šlo o falešné detekce, a upustí stopu. 

-The Příchozí Scud zmizel z obrazovky radaru. A vteřin později jej narazila do kasáren. Plout zabila 28, a byl poslední jeden vystřelil během první války v Perském zálivu. 

Je tragické, že aktualizovaný software dorazil Zahránu následující den. Software vada měla Bylo opraveno, zavírání jedna kapitola v problémové Historie Patriot rakety. 

[VIDEOPŘEHRÁVÁNÍ] David J. Malan: Tak tohle je všechno říci, že tyto otázky přepadu a nepřesnosti jsou až příliš reálné. Tak jak jsme se sem dostali? Začali jsme si povídali o printf. Opět platí, že tato funkce, která vytiskne něco na obrazovku, a zavedli jsme poté několik dalších funkcí z tzv knihovny CS50 je. A budeme i nadále viz nich ve stanovené lhůtě. A my, a to zejména, který se používá get řetězec, a získat int, a nyní také získat float, a přesto jiní stále se setkáváme s a používat sami zanedlouho. 

Ale občas, mají jsme již viděli potřebu ukládat, co tyto funkce ruka zpátky? Oni nás zpět řetězec ruky, nebo int, nebo float. A někdy musíme dát, že řetězec, nebo int, nebo float, někde. 

A ukládat ty věci, připomínají jen stejně jako v Scratch, máme proměnné. Ale na rozdíl od Scratch, v jazyce C máme skutečné typy z variables-- dat typy, více generally-- mezi nimi, řetězec, int, je plavat, a ti ostatní v klidu. 

A tak, když budeme deklarovat proměnné v jazyce C, budeme muset deklarovat naše datové typy. To není něco, co bude muset udělat později v průběhu semestru jak jsme přechod do jiných jazyků. Ale teď, my potřebujeme se a priori v předstihu, vysvětlit, jaký typ počítače proměnné chceme, aby nám dát. 

Nyní se mezitím pro tisk tyto druhy datových typů, musíme říci printf, co může očekávat. A my jsme viděli procent ů pro smyčce, a procento i pro celá čísla, a několik dalších již. A ty jsou prostě požadavky pro vizuální prezentace těchto informací. 

A každý z nich může být ve skutečnosti parametrized nebo vylepšil nějakým způsobem, Chcete-li dále ovládat typ výstup, který dostanete. A ve skutečnosti se ukázalo, že nejenom Je tam zpětné lomítko n pro nový řádek. Je tu ještě něco nazývá zpětné lomítko R pro návrat vozíku, což je více podobný k old school psací stroj, a také Windows používá po mnoho let. 

Tam je zpětné lomítko t na kartách. Ukázalo se, že pokud chcete dvojité uvozovky uvnitř řetězce, Připomeňme si, že jsme použili uvozovky double citát vlevo a vpravo Konce našich řetězcích tak daleko. To by Zdá se zmást věci. 

Chcete-li dát uvozovky v Uprostřed string-- a samozřejmě, to je matoucí vidět. A tak budete muset utéct, takže se mluvit, s něčím, co si uvozovky jako je doslova zpětná lomítka uvozovky. A je tu ještě několik dalších. A uvidíme více z těch, ve skutečném užívání zanedlouho. 

Takže pojďme teď přechod od dat a reprezentace, a aritmetické operátory, vše z nichž nám dal nějakou budovu bloky, s nimiž hrát. Ale teď pojďme skutečně dát us zbytek slovníku že jsme již měli minulý týden Scratch tím, že se podívat na některé další konstrukty C- ne všechny z nich. Ale myšlenky jsme asi vidět opravdu jen zdůraznit překlad z jeden jazyk, Scratch, do druhého, C. 

A v průběhu času, budeme vyzvednout Další nástroje pro naši Toolkit tak říkajíc, syntakticky. A skutečně, uvidíte, že myšlenky jsou nyní spíše známé z minulého týdne. Tak jdeme na to. 

Pojďme dál a vybičovat program že ve skutečnosti používá některé výrazy, Boolean výraz. Nech mě jít napřed zde a vytvořit nový soubor. Zavolám tento condition.c. 

Nech mě jít dopředu a zahrnout knihovnu CS50. A nech mě jít dopředu a zahrnují Standardní IO.h pro naše funkce, a printf, a další, resp. Dovolte mi, abych sám sebe, že často používaný ve int main neplatné, jehož vysvětlení zmíníme vrátit se v budoucnosti. 

Nyní mi dovolte jít dopředu a dát Sám int přes get int. Tak mě nech jít dopředu a to udělat. Chci říct, jestli i je less-- pojďme rozlišovat mezi pozitivní, negativní, nebo nulové hodnoty. 

Takže pokud i je menší než nula, dovolte mi, abych stačí tento program jednoduše říci, negativní zpětné lomítko n, jinak pokud i je větší než nula. Teď jsem samozřejmě chtěl říct printf pozitivní, zpětné lomítko n. A pak ještě if-- bych mohl udělat. 

Mohl bych dělal, kdybych rovná 0. Ale já bych třeba dělat na alespoň už jedna chyba. Připomeňme si, že rovnítko je nerovná, jak my lidé to vědí. 

Ale je to operátor přiřazení. A my nechceme, aby se na 0 vpravo a vložte jej do i na levé straně. Tak, aby se vyhnuli nejasnostem, nebo Možná zneužití rovnítka, Lidé se rozhodl před několika lety že v mnoha programovacích jazycích když chcete zkontrolovat rovnost mezi levým a vpravo, budete skutečně používat rovná rovná. Takže jste hit rovnítko dvakrát. Chcete-li přiřadit zprava doleva, můžete použít jediný rovnítko. Takže jsme mohli udělat jinak tohle-- pokud i rovná se rovná nule. 

Mohl bych pak jít a otevřu složené závorky, a říkají, printf 0, lomítko n, hotovo. Ale pamatujte, jak tyto vidličky na silnici může fungovat. A opravdu, jen přemýšlet o logice. i je číslo. Je to celé číslo, konkrétně. A to znamená, že to bude méně než 0 nebo větší než 0, nebo 0. Takže tam je v jistém smyslu to implicitní standardní případ. 

A tak bychom mohli, stejně jako Scratch, upustit od else if, a prostě říct jinde. Logicky, pokud vám programátor vědět, že je to jen Tři kbelíky, do kterého scénář může fall-- první, druhý, nebo třetí v tomto case-- ne obtěžovat přidání dalšího přesnost a další logika tam. Prostě jít dopředu s Výchozí případ od jiného. 

Nyní se pojďme vpřed po uložení to, aby Podmínky dot lomítko conditions-- Není to skvělý uživatelské rozhraní, Protože nejsem pobízet Uživatel, jak jsem již zmínil. Ale to je v pořádku. Necháme to jednoduché. Zkusme číslo 42. A to je pozitivní. Zkusme číslo Negativní 42, negativní. 

Zkusme hodnotu 0. A skutečně to funguje. Nyní uvidíte s problémy předtím, než Dlouhé testování věci třikrát, pravděpodobně není dostačující. Pravděpodobně budete chtít vyzkoušet některé Větší čísla, některé menší Čísla, některé rohové případy, as dojdeme k jejich popisu. 

Ale teď je to docela jednoduchý program. A jsem si jistá, logicky, že spadá do třech případech. A skutečně, i když jsme jen zaměřila na potenciální stinné stránky nepřesnost a přepadu, v reality, kde je mnoho problémů CS50 je, nebudeme se bát o, po celou dobu, tyto otázky přepadu a nepřesnost, protože ve skutečnosti, v C, je to vlastně není vše, snadno vyhnout se ty věci. Chcete-li spočítat větší a větší a větší, to dopadá existují techniky, které Můžete použít, často zahrnovat věci zvané knihoven, sbírek kódu, aby ostatní lidé psali, které můžete použít, a jiné jazyky, jako je Java a další, ve skutečnosti aby bylo mnohem jednodušší počítat ještě vyšší. Takže je to opravdu některé z těchto nebezpečí funkcí jazyka, který používáte. A v příštích týdnech budeme vidět, jak nebezpečné C ve skutečnosti může být, pokud nechcete používat správně. Ale odtud, as Python a JavaScript, bude máme vrstvu na některé dodatečné ochrany, a spustit méně těchto rizik. 

Takže pojďme udělat trochu víc Zajímavý logika v našem programu. Tak nech mě jít dopředu a vytvořit program s názvem Logical Jen tak mohu hrát s některými Skutečná logika, logical.c. Budu stačí zkopírovat a vložit některé Kód z dřívějška, takže se vrátím k této pěkné výchozího bodu. 

Nechť mi tentokrát dělat char C. Jsem chystá dát mu jméno C jen proto, že je to obvyklé, získat charakter od uživatele. A pojďme předstírat, Já se provádí část Rm tohoto programu je odstranit Program před tím vyzvání uživatele k odstranění souboru. Jak bychom mohli udělat? 

Chci říci, jestli C se rovná rovná, citace konec citátu, y, pak budu předpokládat, že uživatel zvolil ano. Právě jdu k tisku ano. Pokud by bylo skutečně psaní Program odstranění, můžeme odebrat soubor s více řádků kódu. Ale budeme držet to jednoduchý. 

Else if c rovná se rovná n- a teď tady, budu říkat, uživatel musí mít znamená ne. A pak ještě, víte co? Nevím, co jiného Uživatel bude psát. Takže jsem jen chtěl říct, že že je chyba, bez ohledu on nebo ona vlastně napsal. 

Takže to, co se tady děje? Tam je zásadní rozdíl proti, co jsem udělal v minulosti. Uvozovky, uvozovky, dvojité citace, a přesto jednoduché uvozovky, jednoduché uvozovky. Ukazuje se, že v C, že když Chcete-li napsat řetězec použijete uvozovky, stejně jako máme Používám celou tu dobu se printf. 

Ale pokud chcete řešit jen Jeden znak, tzv char, pak jste skutečně používat apostrofy. Ti z vás, kteří si naprogramovat dříve, pravděpodobně nebude mít musel starat o to Rozdíl v některých jazycích. V jazyce C, to záleží. A tak když jsem si char a já chci přistoupit k porovnání tohoto char pomocí rovná se rovná nějaké písmeno, jako je y nebo N, já, ve skutečnosti, je třeba mít apostrofy. 

Teď pojďme do toho a toho dosáhnout. Pojďme dál a dělat, aby logické tečka lomítko logické. A teď jsem byli vyzváni. Takže, podle všeho, lepší uživatelskou zkušenost by mi vlastně říct, co dělat tady. Ale jdu jen slepě říkají, Y ano, OK, pěkný. 

Řekněme to znovu spustit, n po dobu ne, pěkný. Předpokládejme, že stejně jako u některých lidí, které znám, mí Caps Lock klíč je příliš často. Takže já kapitál Y, vstupovat, došlo k chybě. OK, to není přesně to, co jsem očekával. Ve skutečnosti, že počítač dělá doslova co Řekl jsem to do-- kontrolu malá písmena Y a malá písmena n. To nemá pocit, že dobrá uživatelské zkušenosti, ačkoli. Zeptám se pro a přijímám buď malá písmena nebo velká písmena. Tak to dopadá, možná budete chtít říkat něco jako ve Scratch, stejně jako doslovně nebo C se rovná rovná se kapitálu jednotné citovanou y. Ukázalo se, že C nemá tento doslovný klíčové slovo nebo. 

Ale má dvě svislé pruhy. Musíte se držet Shift obvykle, Pokud používáte americkou klávesnici, a udeřil na svislý pruh Klíčovým nad zpáteční klíč. Ale to svislá čára svislá čára znamená nebo. 

Pokud naopak, chtěli jsme říkat a stejně jako v Scratch, bychom mohli udělat ampersand ampersandu. To nedává logický smysl tady, protože člověk nemohl zadali oba y a malá písmena y a kapitál Y jako stejný znak. Takže nebo je to, co máme v úmyslu zde. 

Takže když jsem to udělat v obou místech nebo C rovná se rovná kapitál N, nyní znovu spustit, make logické, spusťte logické. Teď můžu psát y. A můžu to udělat znovu kapitál Y, nebo kapitál N. A mohl bych přidat další kombinace klidu. 

Tak tohle je logickým Program pokud nyní Já kontrola logicky pro tato hodnota nebo je tato hodnota. A nemám na nezbytně přijít s dalšími dvěma IFS Anebo kdyby. Mohu skutečně spojit některé z související logiku dohromady tímto způsobem. Takže by to bylo lepší navrženy tak, než jen řka: Jestliže C se rovná malými písmeny y, tisknout ano, jinak jestli c rovná kapitálu Y, tisknout ano, jinak jestli c rovná lower-- jinými slovy, nemusíte mít stále více a více poboček. Můžete kombinovat některé z ekvivalentu větve Logicky tudíž tímto způsobem. 

Takže pojďme se podívat na jen jeden finální přísada, jeden Finální konstrukt, který umožňuje C. A vrátíme se v Budoucí ostatním ještě. A pak budeme uzavírat prohlížením o teplotě správnosti code-- dostat kód work-- ale design kódu, a zasadit semínka ty brzy. 

Tak nech mě jít dopředu a otevírají nový soubor zde. Víš co? Chystám se znovu zavést že stejný program, ale s použitím jiného konstruktu. 

Tak mi dejte rychle dát sám Přístup zahrnout CS50.h pro knihovnu CS50, Standardní Io.h pro printf. Dej mi moje int main neplatné. A pak tady, ať mě jít dopředu a to udělat. 

Char c dostane dostat char, stejně jako předtím. A budu používat nový konstrukt now-- spínač, na jaký charakter? Takže přepínač je něco jako spínání koleje. Nebo, opravdu, to je v jistém smyslu if jiného, ​​pokud else if, ale psaný poněkud jinak. 

Přepínač vypadá takto. Máte vypínač a pak to, co znak nebo číslo, které chcete prohlédnout, pak některé složené závorky jako v Scratch, stačí říct dělat tohle. A pak máte různé případy. 

Nemusíte použít, pokud a jinde. Doslova používat případ slovo. A vy byste říci něco takového. 

Takže v případě malými písmeny y, nebo v případě, že Y kapitálu, pokračujte a vytisknout ano. A pak vypukne spínače. A je to. Máme hotovo. 

Else if, tak říkajíc, malá písmena n, nebo N kapitál, pak jděte do toho a tisk out ne, a pak zlomit. Else-- a tento druh je standardní případ indeed-- printf error-- a jen pro jistotu, ačkoli Logicky tato přestávka není nutné proto, že jsme na konci přepínače tak jako tak, Já jsem teď vypadla z přepínače. Takže to vypadá trochu jinak. 

Ale logicky, je to ve skutečnosti ekvivalentní. A proč byste měli používat jeden nad druhým? Někdy prostě osobní preference, Někdy estetika, když jsem se podíval na to Nyní je tu něco, třeba říci, pro čitelnost tohoto kódu. Myslím, nevadí skutečnost, že toto Kód je nová pro mnohé z nás v místnosti. 

Ale to jen tak je dost. Vidíte malá písmena Y, Y kapitálu, malá písmena n, kapitál N default, to jen trochu skoky na vás takovým způsobem, že pravděpodobně, možná Předchozí příklad s IFS a svislé pruhy, a jinde IFS, nemusí mít. Tak to je opravdu věc osobní volba, opravdu, nebo čitelnost, kódu. 

Ale pokud jde o funkčnost, dovolte mi, abych pokračovat a dělat spínač, dot lomítko switch, a teď psát malými písmeny y, kapitál Y, malé n, kapitál N, David, znovu protože to je ani jeden znak. Udělejme x, chyba, jak se očekávalo. A logically-- a to je něco, Chtěl bych povzbudit v general-- dokonce i když jsme pouze poškrábání Povrch některé z těchto funkcí. 

A to nemusí být zřejmé, když vás si sednout na klávesnici, Jak to funguje? Co by to udělat? Krásná věc, o které mají notebook nebo desktop, nebo přístup k počítači pomocí překladače, a s editoru kódu, jako je tato, se můžete téměř vždy odpovědět na tyto otázky pro sebe jen pokouší. 

Například, pokud je rétorická otázka po ruce byly, co se stane, když zapomenete přestávky na výroky? Což je vlastně velmi časté, co dělat, protože to nevypadá jako byste opravdu potřebují. Nemají opravdu dokončit svůj myslel jako závorce nebo kudrnaté rovnátka dělá. Pojďme dál a překompilovat kód a uvidíme. Tak, aby spínač, tečka lomítko přepínač. Pojďme psát malými písmeny y, vrchní případ, Enter. Tak jsem napsal y. 

Program řekl, že ano, ne, chyba, jako by to bylo mění svůj názor. Ale docela to bylo, protože to, co se děje s vypínačem se o první případ, že Zápas v podstatě znamená, hej počítač, provést všechny kód pod ní. A pokud nechcete říci zlomu, nebo Neříkejte pauzu, nebo neříkejte pauzu, Počítač bude foukat přes všechny ty linky a provádět všechny z nich, dokud se dostane do té složenou závorkou. Takže brzdy jsou skutečně nezbytné. Ale stánek s jídlem tady je, když pochybností, zkusit něco. Možná uložit první kód, nebo je uložit do jiného souboru pokud jste opravdu starosti popletl a museli obnovit dílo, které víte, že funguje. 

Ale zkuste věci. A nebuďte jako strach, snad, z toho, co počítač může dělat, nebo že byste mohli něco rozbít. Vždy se můžete vrátit zpět do jisté starší verze. 

Takže pojďme končí pohledem při konstrukci kódu. Máme nyní tuto schopnost psát Podmínky a zápis smyčky, a proměnné a funkce volání. Takže upřímně řečeno, jsme trochu zpátky na kde jsme byli před týdnem se Scratch, byť s méně přesvědčivé textové Prostředí než Scratch dovolí. 

Ale všimněte si, jak rychle jsme získali že slovní zásobu, i když je to bude chvíli trvat propadat, tak, že nyní můžeme použít tento slovní zásobu psát další zajímavé programy. A pojďme se dítě krok ke které takto. Nech mě jít dopředu a vytvoření nového souboru zde. 

Jdu to nazývat prototype.c, a zavést Poprvé, schopnost vytvořit svůj vlastní funkce. Někteří z vás mohou mít udělal to s Scratch, kde si můžete vytvořit svůj vlastní uživatelské bloky v základu, a pak přetáhnout na místo všude tam, kde byste chtěli v C. A ve většině programů jazyky, můžete to udělat přesně to, že-- vytvořit svůj vlastní funkce, v případě, že již neexistují. 

Tak například, nechte mě jít napřed a zahrnují CS50.h, a zahrnují Standardní IO.h, int main neplatné. A teď máme zástupného připraven jít. Pořád tisk věci stejně jako jména lidí dnes. A to cítí jako-- by neměl být hezké, kdyby tam byly funkci nazvanou název tiskového? Nemám použít printf. Nechci mít na paměti, Všechny formátu kódy. Proč ne já, nebo proč ne někdo přede mnou, Vytvoření funkce nazývá tisk jméno, že vzhledem k tomu nějaké jméno, prostě vytiskne jej ven? 

Jinými slovy, když řeknu, hej, počítač, dej mi řetězec tím, že žádá uživatele o takové, pomocí funkce get řetězec CS50 je. Hele, počítač, dal, že řetězec proměnná na levé straně, a nazvat to. A pak, hej počítač, pokračuj a vytisknout to jméno osoby, hotovo. 

Teď by to bylo hezké, protože tento program, příhodně pojmenovaný, mi řekne, co to má dělat prostřednictvím jmen těch, fungovaly je. Nech mě jít a dělat prototyp, Enter. A, bohužel, toto se nebude létat. 

Prototype.c, řádek 7, znak 5, chyba, implicitní prohlášení z funkce jména tiskového je neplatný v C99, C99 znamenat verzi C která vyšla v roce 1999. To je vše. 

Tak nevím, co To vše znamená, že dosud. Ale mám rozpoznat chybu v červené barvě. To je docela zřejmé. 

A zdá se, že s zelená znak zde, je problém s názvem tisku, otevřený paren s, zavřít závorka, semi-tlustého střeva. Ale implicitní prohlášení Funkce jsme krátce předtím viděl. To znamená, prostě, že Clang neví, co mám na mysli. 

Použil jsem slovo, slovní zásobu, že je Nikdy neviděl, ani učili předtím. A tak to musím naučit co tato funkce znamená. Takže já jdu dopředu a udělat to. 

Chystám se jít dopředu a realizovat mé vlastní volání funkce Print Name. A budu říkat, jak vyplývá, že Dělá to, printf, ahoj, procenta s, lomítko n, jméno, středník. Tak co jsem právě udělal? 

Tak to dopadá, aby implementovat své vlastní funkce, jsme trochu půjčit některé stejnou strukturu jako hlavní že jsme právě byli považována za samozřejmost, a já vím jen kopírování a vkládání přesně to, co Psal jsem v minulosti. Ale všimněte si vzor zde. Int, Main, Void, budeme šprýmaři odděleně netrvalo dlouho, co to vlastně znamená. 

Ale pro dnešek, jen Všimněte si, souběžnost. Void, tisk názvu, string name, takže je tu nachový klíčových slov, která jdeme na začátek volá návratový typ, název funkce, a potom vstup. Takže ve skutečnosti, lze destilovat tento druh jako minulého týdne protože se jedná o název nebo Algoritmus kódu kterém jsme bude write-- algoritmus podkladových Kód budeme psát. 

To je jeho vklad. To je jeho výstup. Tato funkce, název tisk, je navrženy tak, aby řetězec s názvem název, nebo cokoliv jiného, ​​jako vstup, a pak neplatné. To nic nevrací, jako dostat řetězec nebo získat int dělá. Tak to bude mi něco předat zpět. Je to jen bude mít Vedlejším efektem, tak říkajíc, tisknout jméno osoby. Takže si všimnout, řádek 7, I mohou volat jména tisku. Řádek 10, mohu definovat nebo zavést název tisku. Ale, bohužel, to nestačí. 

Nech mě jít dopředu a překompilovat to po uložení. Whoa, teď jsem to udělal horší, by se mohlo zdát. Takže implicitní prohlášení název funkce tisku je neplatná. A opět je tu další chyby. Ale jak jsem varoval již dříve, a to i pokud se dostanete zahlceni, nebo trochu smutné vidět tolik Chyby, zaměřit se pouze na první zpočátku, protože by to mohlo jen měly kaskádový účinek. Takže C, nebo Clang konkrétněji, stále nerozpozná název tisku. 

A to proto, že Clang, záměrné, je tak trochu hloupý. To jen dělá to, co si to říct dělat. A to dělá jen proto, v pořadí ve kterém se říci dělat. 

Tak jsem definovány hlavní on-line čtyři, stejně jako jsme dělali dost často. Já jsem je definován název tiskového na řádku 10. Ale já se snažím používat název tiskového na lince sedm. 

Je to příliš brzy, ještě neexistuje. Takže jsem mohl být chytrý, a to jako, OK, takže pojďme jen hrát spolu, a pohybovat název tiskového nahoru tady, a znovu sestavit. Ó můj bože. Fungovalo to. Bylo to tak jednoduché, jak to. 

Ale logika je přesně to. Musíte se naučit, co to Clang je, že se nejprve definuje funkci. Potom jej můžete použít. Ale, upřímně řečeno, to cítí jako šikmou plochu. 

Takže pokaždé, když jsem běžet na problém, jsem jen bude pro zvýraznění a zkopírujte kód Napsal jsem, nakrájejte a vložte jej sem. A jistě, mohli bychom vymyslet některé scénáře kde jedna funkce by mohl je třeba volat jiný. A vy prostě nemůže dát každý Funkce nad každý jiný. 

Tak to dopadá tu lepším řešením. Můžeme nechat to být. A upřímně řečeno, je to obecně pěkné, a pohodlné, a dobrý design aby hlavní první, protože, opět, Hlavním stejně jako při klepnutí zelená vlajka, že je funkce, která dostane popraven ve výchozím nastavení. Takže si klidně dát že v horní části souboru takže když vy nebo některý Jiný člověk podívá na soubor víte, co se děje pouhým přečtením hlavní první. Tak to dopadá, můžeme říci Clang proaktivně, hej, Clang na lince čtyři, Slibuji, že budu realizovat funkce nazvaná Tisk Název, který má název řetězec s názvem jako vstup a vrátí nic, void. A budu dostat kolem provádění později. 

Přichází Main. Hlavním nyní na lince 9 mohou používat Název tiskového protože Clang důvěřuje, že nakonec, že narazí definici implementace Print Name. Takže poté, co mi zachránil souboru, ať mě jít dopředu a vytvořit prototyp, vypadá dobře tentokrát. Dot lomítko, prototyp, dovolte mi, abych pokračovat a zadat název. David Ahoj Davide, Zamila, ahoj Zamila, a, opravdu, teď to funguje. 

Takže složka je, že máme udělal vlastní funkce, jako zvyk Scratch blok my ji volá. Ale na rozdíl od nuly, kde si můžete Jen ji vytvořit a začít používat, Nyní musíme být trochu pedantský, a vlastně trénovat Clang používat, nebo ji čeká. Nyní, jak stranou, proč celou tu dobu mají jsme byli jen slepě na víře, včetně CS50.h, včetně standardního IO.h? 

Tak to dopadá, Mezi několik dalších věcí, vše, co je v těch dot h Soubory, které se dějí být souborů. Jsou hlavičkové soubory, tak říkajíc. Jsou stále napsaný v C. Ale oni jsou jiný typ souboru. 

Pro tuto chvíli, můžete do značné míry předpokládat, že všechno, co je uvnitř CS50.h Je někdo vtipy, jako je tato, nikoliv pro funkce s názvem Print Name, ale k Get řetězec, Get Float, a několik dalších. A existují podobné prototypy, jeden vložky, uvnitř standardního IO.h pro printf, která je nyní v moje vlastní tisku název funkce. Takže jinými slovy, celá tato doba máme právě slepě kopírování a vkládání patří to, zahrnují to, co se děje? To jsou jen trochu stopy k řinčení pokud jde o jaké funkce jsou skutečně realizovány, jen jinde v různých souborů jinde v systému. 

Takže jsme implementován jméno tisku. To přece má tento nežádoucí účinek tisk něco na obrazovce. Ale to není ve skutečnosti podej mi něco zpět. Jak můžeme jít o provádění programu, který to mi podat něco pro sebe? 

Dobře, zkusme to. Nech mě jít dopředu a realizovat soubor nazvaný return.c takže můžeme ukázat, jak něco stejně jako Get řetězec, nebo získat Int, je vlastně vrací něco zpět uživateli. Pojďme dál a definovat int main neplatné. 

A opět v budoucnu, my budeme vysvětlí, co to int i tu prázdnotu je ve skutečnosti dělá. Ale pro dnešek, zmíníme brát jako samozřejmost. Chystám se jít dopředu a printf, pro dobrou uživatelské zkušenosti, x je. A pak budu čekat na Uživatel dát mi x s get int. 

A pak budu pokračovat a vytisknout x na náměstí. Takže když máte jen klávesnice, lidé obyčejně použijte malou mrkev symbol na klávesnici reprezentovat k napájení z ní nebo exponent. SOx druhou je přítomen i. 

A teď budu dělat. Mohl bych do--, co je x na druhou? x Squared je x krát x. 

A my jsme to udělali někteří Před časem již dnes. To nemá pocit, vše, co velký pokrok. Víš co? Pojďme využít některé z této myšlenky od minule abstrakce. 

Nebylo by hezké, kdyby tam je funkce nazvaná čtverec, který dělá přesně to? To ještě na konci den, dělá tu samou matematiku. Ale pojďme abstraktní pryč myšlenky o věnování jedno číslo vynásobí Dalším, a jen dát mu jméno, jako čtverec tuto hodnotu. 

A, jinými slovy, v C, pojďme vytvořit funkci volal čtverec, který dělá přesně to. Bude to nazvat čtverečních. Bude to trvat int. A my bude jen nazývají n, ve výchozím nastavení. 

Ale my jsme mohli nazvat něco chceme. A vše, co to bude ano, doslova, je návrat výsledek n-krát n. Ale proto, že je vracet něco, který je klíčové slovo ve fialové máme Nikdy předtím neviděl, jsem na lince 11, Nelze prostě říct void tentokrát. 

Neplatné, v tomto příkladu jsme právě viděli spíše názvu tisku, prostě znamená, dělej něco. Ale není mi předat něco zpět. V tomto případě, já chci Pro návrat n krát n, nebo co to je, že číslo. 

Takže nemohu říct, hej, počítač, Já nic vrátit, neplatné. Bude to návrat ze své povahy, int. A tak to je vše, co se tady děje. 

Vstup na náměstí bude int. A tak, že ji můžeme použít, musí mají jméno, N. To bude výstup int, který nepotřebuje jméno. Můžeme to nechat na hlavní, nebo ten, kdo je pomocí mě pamatovat tuto hodnotu Kdybychom chtít s vlastním proměnné. 

A opět, jedinou novou Zde je klíčové slovo Return. A já jsem jen dělal nějakou matematiku. Kdybych opravdu chtěl být zbytečné, Mohl bych říct, int výrobek dostane n-krát n. 

A pak bych mohl říci, vrátit výrobek. Ale opět, aby mého úhlu co nastane dříve to prostě není dobré design-- podobně, proč zavést název, symbol, stejně jako výrobek, jen proto, aby okamžitě vrátit? Je to trochu čistší, o něco silnější, takže mluvit, jen říct návrat n-krát n, zbavit se této linie úplně. 

A je to jen méně kódu ke čtení, méně příležitostí k chybám. A uvidíme, jestli to ve skutečnosti nyní pracuje. Teď, já jdu dopředu a dělat návrat. 

Uh-oh, implicitní deklarace funkce. Udělal jsem tuto chybu předtím, žádný velký problém. Dovolte mi psát, nebo zvýraznit a kopírovat, ten samý prototyp funkce, nebo podpis, funkce tady. Nebo bych mohl pohybovat celou funkci. 

Ale to je trochu líný. Takže nebudeme dělat. Nyní mi dovolte vrátit Znovu dot návrat lomítko. 

x je 2. x na druhou je 4. x je 3. x druhou 9. A funkce se zdá Nyní je třeba pracovat. Takže to, co je tady v tom rozdíl? Mám funkci, která se nazývá čtverec, V tomto případě, který jsem dal na vstupu. A já se vrátím výstup. A přesto, dříve, pokud Otevřu jiný příklad z dřívějška, což Byl nazýván prototype.c, Měl jsem tiskovou jméno, které vrátil neplatné, tak říkajíc, Nebo se vrátila nic, a jednoduše měla nežádoucí účinek. 

Takže to, co se tady děje? No, zvažovat funkci dostat řetězec jen na okamžik. Byli jsme pomocí funkce dostat řetězec v následujícím způsobem. 

Měli jsme funkce dostat řetězec, jako například: CS50.h, zahrnují standardní IO.h, int main, neplatné. A pak pokaždé, když jsem volal get řetězec tak daleko, Řekl jsem něco jako řetězec s dostane dostat řetězec, protože get string-- říkejme tento get.c-- get řetězec Samotný vrací řetězec, který mohu poté použít, a říkají, ahoj, čárka, procent s, lomítko n, s. 

Tak tohle je stejný příklad, ve skutečnosti, že jsme měli dříve. Tak se vrátí řetězec hodnotu. Ale před chvílí, tiskový řetězec nevrací hodnotu. To prostě má vedlejší účinky. Tak to je zásadní rozdíl. Viděli jsme odlišný typy funkcí nyní, z nichž některé se vrátili hodnot, z nichž některé nejsou. Takže možná je to řetězec nebo int, nebo float. Nebo možná je to jen neplatné. 

A rozdíl je že tyto funkce, které získat data a vrátit hodnotu jsou vlastně přinášet něco zpátky ke stolu, abych tak řekl. Tak pojďme do toho a podívejte se na jeden poslední sadu příkladů, které dává smysl, nyní z jak bychom mohli skutečně abstraktní lepší, a lepší a lepší, nebo více, a další a další, v pořadí psát, nakonec, lepší kód. Pojďme do toho, a v duchu Scratch, proveďte následující kroky. 

Nech mě jít dopředu a zahrnují CS50.h a standardní IO.h. Nech mě jít dopředu a dát Sám int, hlavní, neplatné. A nech mě jít napřed, volat toto cough.c. 

A nech mě jít dopředu a jen jako Scratch, vytisknout kašel / N. A já chci udělat třikrát. Takže jsem samozřejmě jen tak zkopírovat a vložit třikrát. Já jsem teď bude dělat kašel dot lomítko kašel. Dejme sám trochu více prostoru Zde, Enter, kašel, kašel, kašel. 

Tam je, samozřejmě, již nyní příležitost pro zlepšení. Já jsem zkopírovat a vložit párkrát dnes. Ale to bylo jen tak já ne muset zadat tolik znaků. I přesto co změnil tyto řádky kódu jsou. 

Tyto tři řádky jsou identické, který se cítí líní, a samozřejmě tak, a pravděpodobně není správný přístup. Takže s tím, co přísada můžeme zlepšit tento kód? Nemáme zkopírovat a vložit kód. 

A vskutku, kdykoli máte pocit, yourself kopírování a vkládání, a to dokonce ke změně kódu, šance jsou tam lepší způsob. A opravdu, tam je. Nech mě jít dopředu a udělat pro smyčce, i když možná ne syntaxe přijít ještě přirozeně. 

Tyto klávesy stiskněte třikrát, jednoduše tím, že dělá following-- a já náhodou vím z praxe. Ale máme řadu příkladů teď. A uvidíte on-line Další reference v klidu. 

To je syntaxe na řádku 6, které podobně jako Scratch, který se opakuje blok, opakujte následující třikrát. Je to trochu magické teď. Ale to dostane víc, a známější. 

A to bude opakovat linka osm třikrát, takže když jsem re-kompilaci make kašel, dot lomítko kašel, kašel, kašel, kašel. To ještě pracuje stejným způsobem. Takže to je všechno v pořádku a dobře. Ale to není moc roztržitý. 

Je to naprosto správné. Ale je to pocit, jako by tam by mohlo být příležitostí, jak ve světě Scratch, na druhem startu sem přidat nějaké sémantiku, takže Nemám prostě něco pro smyčce, a funkce, která říká: kašel, nebo se kašel. Víš co? Zkusím být málo chladnější než to, a vlastně napsat funkci, která má některé nežádoucí účinky, které říkají, že kašel. 

A to trvá žádný vstup, a nevrací žádnou hodnotu jako výstup. Ale víte, co to dělá? To dělá tohle-- printf, citát konec citátu, kašel. 

A teď tady, jdu jít dopředu a pro int, i dostane na nulu, i méně než tři, já a navíc. Chystám se to udělat printf, která je pravděpodobně implementace nízká úroveň detail. Nezajímá mě, jak ke kašli. Jen chci použít funkci kašel. A já jsem prostě jít zavolat kašel. 

Nyní si všimněte dichotomie. Při volání funkce, pokud nemáte chtějí dát to vstupy, úplně v pohodě. Prostě to otevřené závorka, v blízkém okolí paren, a máte hotovo. 

Při definování funkce, nebo deklarovat prototyp funkci je, pokud předem víte, že to není bude trvat žádné argumenty, říkají neplatné tam těch závorkách. A v tom je jisté, že vás nebude náhodně zneužít jej. Nech mě jít dopředu a dělat kašel. A samozřejmě jsem udělal chybu. 

Sakra, tam je to implicitní prohlášení. Ale to je v pořádku. Je to snadné opravit. Potřebuju jen prototyp výš v mém souboru, než jsem vlastně používat. 

Takže teď mi dovolte kašel znovu, pěkný. Teď to funguje. Zkontrolujte, kašel, kašel, kašel, kašel. Takže byste si mohli myslet, že jsme opravdu jen něco málo přes engineering tento problém. A skutečně jsme. To není dobrá kandidát programu v okamžiku, kdy pro refactoring, a to, co je volal hierarchický rozklad, kde budete mít nějaký kód, a poté tak nějak faktor věci ven, tak jako připisovat více sémantiku k nim, a opakovaně to nakonec z dlouhodobého hlediska. Ale je to stavebním kamenem směrem sofistikovanější programy že začneme psaní zanedlouho že nám umožňuje mít slovní zásobu s nímž psát lepší kód. A skutečně, podíváme se, jestli bychom nelze zobecnit to dál. 

Zdá se, že trochu chromý, že já, hlavní, muset starat o této látat pro smyčce, a volání kašel znovu a znovu. Proč nemohu jen říct kašel, prosím kašel třikrát? Jinými slovy, proč ne já jen dát impuls ke kašli a to udělat? 

Proč nemohu jen říct, v Hlavním kašel třikrát. A teď, to je druh kouzelné. Je to tady velmi iterativní. A je to opravdu malé dítě krok. 

Ale právě schopnost říci linka osm, kašel třikrát, je to tak mnohem čitelnější. A navíc, nemám vědět nebo jedno, jak je implementován kašel. A skutečně, později v Termín a závěrečných prací, pokud budete řešit projekt s spolužák nebo dva spolužáci, budete si uvědomit, že budete muset, nebo chcete, rozdělit práci. 

A budete chtít rozhodnout v předstihu, kdo to bude dělat to, co, a ve kterém kousky? A nebylo by to bylo hezké pokud jste například, postarat se o psaní Main, hotovo. A váš spolubydlící, nebo Váš partnerské obecněji se stará o provádění kašel. 

A toto rozdělení, tito Stěny abstrakce, nebo vrstvy abstrakce pokud budete, jsou super silné, proto, že zejména pro větší, Složitější programy a systémy, to umožňuje více lidem stavět věci dohromady, a nakonec steh svou práci společně tímto způsobem. Ale samozřejmě, my je třeba opravit teď kašel. Musíme říci, kašel že hej, víš co? Budeš muset vzít input-- tak není neplatný, ale int i teď. Pojďme dopředu a dát do kašel int. i dostane na nulu. 

i je menší než kolikrát. Řekl jsem tři předtím. Ale to není to, co chci. Chci kašel, které mají být zobecněny na podporovat libovolný počet iterací. 

Takže, opravdu, to je n, že chci, bez ohledu na uživatelské mi. Teď můžu jít dopředu a říkat tisku kašel. A bez ohledu na to, jaké číslo uživatel projde, Budu se opakovat, že mnohokrát. 

Takže na konci dne, Program je totožný. Nevšimnout všechny tyto věci mohly by být i v jiném souboru. Ve skutečnosti nevím at the moment, jak printf je implementována. 

Nevím, v tuto chvíli, jak dostat řetězec, nebo získat int, nebo si plovák jsou implementovány. A já nechci je vidět na mé obrazovce. Jak to je, začínám se zaměřit na můj program, ne ty funkce. 

A tak, opravdu, jakmile vás spustit factoring kód, jako je tohle, mohli bychom dokonce pohnout kašel do samostatného souboru? Někdo jiný mohl realizovat. A vy a váš program se stal velmi krásné a velmi čitelný, pravděpodobně opravdu čtyři řádek programu právě tam. 

Tak pojďme do toho teď a provést ještě jednu změnu. Všimněte si, že můj prototyp se musí změnit up vrchol. Dovolte mi tedy napravit tak Nechápu zařval. 

Zkontrolujte, kašel, dovolte mi běžet kašel, jakmile více, stále dělá to samé. Ale teď si všimněte, máme přísada pro jednu finální verzi. Víš co? Já nechci jen kašel, nutně. Chci mít něco obecnější. Tak víte co? Chci to udělat. Chci mít, podobně jako Scratch ano, vyjadřovat blok, ale ne jen říct něco určitý počet opakování. Chci, aby to říci velmi specifický řetězec. A proto nemám chci, aby to jen říct kašel. Chci, aby to říkat, co Řetězec předaný. 

Takže si všimnout, jsem generalizované to tak, že nyní dejme tomu cítí jako dobrého jména pro toto, jako Scratch, přijímá dva argumenty, na rozdíl od nuly. Jedním z nich je řetězec. Jedním z nich je int. 

A já je mohl přejít. Jen jsem něco jako myšlenku říkají řetězec a teprve potom kolikrát později. Void to znamená, že stále nic nevrací. To jsou jen vizuální stránka efekty, stejně jako u [? Jordan?] slovní vedlejším účinkem křičí. To ještě udělá něco n-krát, 0 až do, ale ne rovna n. To znamená, že n celkem třikrát. A pak už jen vytisknout co to je řetězec. Takže jsem opravdu zobecnit tento řádek kódu. Takže teď, jak mohu implementovat Funkce kašel? 

Mohu dělat void kašel. A můžu ještě trvat v tom, jak kolikrát budete chtít kašlat. Ale víte co? Nyní mohu punt říci. 

Můžu zavolat říci s Slovo kašel, procházející v n. A když chci také implementovat, jen tak pro zábavu, funkce kýchnutí, Mohu kýchání určitý počet opakování. A můžu mít znovupoužití n, protože Všimněte si, že m v tomto kontextu nebo rozsah existuje pouze v této funkci. 

A n v této souvislosti jen existuje v rámci této funkce zde. Takže se vrátíme k Tyto otázky rozsahu. A tady, já jen chtěl říct, achoo a potom n časy, středník. 

A teď už stačí jen půjčit Tyto funkce podpisy tady. Takže kašel je správná. Void kýchnutí je nyní správná. 

A já pořád stačí říct. Tak jsem chtěl říct, řekněme řetězec s, int n, středník. Tak jsem over-zkonstruoval sakra z tohoto programu. 

A to není nutně znamenat, že se jedná co byste měli dělat při psaní i ty nejjednodušší programů. Udělejte něco, co je zjevně opravdu jednoduché, opravdu málo, a re-implementovat ji s použitím příliš mnoho kódu. Ale budete skutečně vidět, av čas ohlížet na tyto příklady, a uvědomit si, ach, ty jsou kroky jsme se skutečně generalizovat, faktor něco, až na konci dne můj kód je vlastně docela rozumné. Protože pokud chci kašel tři Časy pak kýchnout třikrát, Já prostě jen znovu spustit to, Program dělat kašel a spusťte kašel. A mám tři kašel a tři smrkání. 

A tak to je základním paradigma, chcete-li, za jak bychom mohli jít o ve skutečnosti provádění programu. Ale pojďme se prostě vidět teď, co to je jsme dělali všechno této doby, a co někteří z finálních kusů jsou za tímto jednoduchým příkazem. Na konci dne, máme Byl pomocí Clang jako náš překladač. Byli jsme psát zdroj kód, převedením přes Clang do strojového kódu. 

A my jsme používali jen Udělat s cílem usnadnit našim stisky kláves, takže že nebudeme mít na paměti, ty zaklínání sama o sobě Clang. Ale co je Ujistěte se vlastně dělá? A, podle pořadí, co je Clang vlastně dělá? 

Ukázalo se, že i když jsme zjednodušili dnešní diskuse tím, že říká, budete mít zdrojový kód, předat jako vstup do kompilátor, který vám dává Výkon stroje kód, dopadá tu několik různých kroků tam uvnitř. A kompilace se stane být deštník termín pro spoustu kroků. Ale pojďme jen dráždit na to opravdu rychle. 

Ukazuje se, že jsme dělali více věcí Pokaždé, když jsem spustit program, nebo pokaždé, když jsem kompilaci programu dnes. Tak se odkazuje na předzpracování tohle-- něco v programu C, jak uvidíme znovu a znovu, který začíná tímto symbolem hash, nebo hashtag symbol tady, znamená, je to direktiva preprocesoru. To znamená, že v tomto případě, hej počítač, udělej něco s tímto souborem než je skutečně sestavit svůj vlastní kód. 

V tomto případě hash patří znamená, v podstatě, C je způsob, jak říct, hej počítač, jdi obsah z CS50.h a vložit je zde. Hej počítač, jít dostat Obsah standardního IO.h, všude tam, kde to je na pevný disk, vložte jej sem. Takže ty věci se dějí nejprve během předzpracování. 

A Clang dělá vše za námi. A to dělá tak zatraceně rychle, vy ani zobrazit čtyři různé věci děje. Ale to je první takový krok. 

Co se vlastně bude dít dál? No, další úředník krokem je kompilace. A ukázalo se, že sestavování programu technicky znamená jít od zdrojový kód, ty věci máme píše dnes k něčemu volal shromáždění kód, něco který vypadá trochu jinak. 

A ve skutečnosti, můžeme vidět velmi rychle. Nech mě skutečně jít do mého IDE. Nech mě jít dopředu a otevřené hello.c, který je první program, se kterým jsme se začala dnes. A nech mě jít dopředu a spuštění zvonění A trochu jinak, Clang-s, hello.c, který bude skutečně Dej mi jiný soubor hello.s. 

A budeme pravděpodobně nikdy znovu vidět tento druh kódu. Pokud budete mít nižší úroveň Třída systémy jako CS61, uvidíte mnohem víc tohoto druhu kódu. Ale to je jazyk symbolických instrukcí. To je X86 jazyk symbolických instrukcí že procesor, který je základem CS50 IDE skutečně rozumí. 

A mystický, jak to dělá hele, to je něco, Počítač rozumí docela dobře. Sub q, to ​​je odečíst. Je tu pohyby. 

Je tu volání funkcí zde, x Výc, hnutí, doplněk, pop, návrat. Takže tam je nějaký velmi Návod k nízké úrovni že CPU pochopili, že zmiňoval jsem se dříve. To je to, co Intel Inside. 

K dispozici jsou vzory nuly a ty, které mapovat tyto arcanely zní, ale poněkud dobře jmenován, instrukce, abych tak řekl. To je to, co se stane, když kompilaci kódu. Získáte sestavu jazyk z toho, který znamená, že třetí krok je sestavit že sestava kód do, nakonec, strojní code-- nuly a jedničky, ne Text, který jsme právě viděli před chvílí. 

Takže předzpracování to má najít a nahradit, a pár dalších věcí. Kompilace trvá zdroj Kód z C, zdrojový kód že jsme napsali, k montáži kód, který jsme právě podíval na. Montáž trvá toto shromáždění Kód na nuly a ty že procesor ve skutečnosti bude pochopit na konci dne. A propojení je posledním krokem že se stane pro us-- znovu, tak rychle, my ani notice--, který říká, hej počítač, přijmou veškerá nuly a ty, které vyplýval z kompilace Davida kód, a jeho hlavní funkcí je v tomto případě. 

A hele počítač, jdi všechny nul a jedniček že personál CS50 napsal uvnitř knihovny CS50. Smíchejte ty se Davida. A hele počítač, jdi všechny nuly a ty, které napsal někdo jiný let Před pro printf. A přidat ty, do Celá věc, takže máme svý nul a jedniček, The nuly a jedničky CS50 personálu, printf nuly a jedničky, a něco jiného užíváme. 

Všichni si spojí dohromady do jednoho program s názvem, v tomto případě, ahoj. Takže od nynějška budeme jen použít slovo kompilace. A budeme brát za samozřejmost, že když říkáme, sestavit svůj program, to znamená, hej provést předběžné zpracování, sestavování a propojování. Ale je to vlastně šťavnaté některé věci tam děje pod kapotou. A to zejména pokud zvědaví nějaký čas, můžete začít strkat kolem sebe na této nižší úrovni. Ale teď si uvědomit, že Mezi stánek s jídlem pro dnešek jsou poměrně jednoduše začátek procesu, jak se dostat pohodlně něco jako hello world. Ve skutečnosti většina z toho, co jsme udělali dnes určitě nebude klesat v super rychle. A to bude trvat nějaký čas, a někteří cvičí. A šance jsou, budete řadit of chtějí zasáhnout klávesnice nebo křičet na obrazovce. A to vše je v pořádku. I když, možná snažit se to v knihovně tolik. 

A nakonec, budete být schopen i když pro začátek vidění vzory, a to jak v dobrém kódu že jste napsali a chyb že jste udělali. A podobně jako proces stává TF nebo CA je jako, začnete cítit lépe a lépe při pohledu na tyto vzory, a právě řešení vašich vlastní problémy nakonec. Do té doby, tam bude spousta z nás půjčovat ho podpořili, a dostanete přes to. A v write-up pro všechny problémy budete provedeni všechny příkazy že jsem jistě znají z hodně praxe teď, ale mohl letět nad hlavou prozatím. A to je naprosto v pořádku. 

Ale nakonec, budete začít vidět vzory objevit. A jakmile se dostat přes všechny hloupé detaily, jako jsou závorky, a složené závorky a středníky, a věci, upřímně řečeno, že není vůbec intelektuálně zajímavé. A není cílem užívat jakýkoliv úvodní třídu. Jsou to myšlenky, které jdou na hmotu. 

To je smyčky, a podmínky a funkce, a silněji abstrakce, a factoring kódu, a dobrý design a dobrou styl, a nakonec správnost z kódu, který je v konečném důsledku bude záležet nejvíce. Takže příští týden, budeme brát tyto myšlenky, které jsme poprvé viděli v Scratch a nyní přeloženy k C. A začneme představit první z Samozřejmě je skutečný svět domén. 

Budeme se soustředit na světě bezpečnosti, a konkrétněji kryptografie, umění zakódování informace. A mezi prvními Problémy vy sám dostane psát mimo hrát s některými z syntaxe a řešit některé logické Problémy, nakonec netrvalo dlouho, Je skutečně zakódování, nebo šifrování, a nakonec dešifrování informací. A všechno, co jsme udělali Dnes se poměrně nízký Hladina se jen tak dovolit nám, aby jeden a jeden, a další krok směrem k výše psaní přesto nejzajímavější kód. 

Takže o tom až příští týden. 

[VIDEOPŘEHRÁVÁNÍ] 

Co mi můžete říct o v poslední době jste ho viděl? Co můžu říct, opravdu? Myslím, že to bylo jako každá jiná pre-produkce zkouška, s výjimkou tam bylo něco, řekl na samém konci, který uvízl se mnou. 

Tohle byl CS50. 

-To Střih všichni, skvělou práci na zkoušku. 

-To Oběd? 

Jo, vy a já mohu chytit sendvič v trochu. Nech mě vyslechnout s David opravdu rychle. David? David? 

[END PŘEHRÁVÁNÍ] 