[MUZIKO Ludanta] DAVID J. Malan: Bone, ĉi tiu estas CS50. Kaj tio estas semajno unu. Do memoru, ke lastfoje en semajno nulo, ni centris en komputa pensado. Kaj ni transitioneis de tiu al Nulo, grafika programado lingvo de niaj amikoj ĉe MIT Media Lab. 

Kaj kun Scratch, ni esploru ideoj kiel funkcioj kaj kondiĉoj kaj maŝojn kaj variabloj, kaj eĉ eventoj, kaj fadenoj, kaj pli. Kaj hodiaŭ, ni tuj kontinui uzante tiujn ideojn, kaj vere prenas ilin por konceditaj, sed traduki ilin al alia lingvo nomata C. Nun, C estas pli tradiciaj lingvo. Ĝi estas malalta nivelo lingvo, se vi volas. 

Ĝi estas pure teksta. Kaj do unuavide, ĝi estas ĉiuj tuj serĉos iom kamufla se vi neniam planita antaŭe. Ni tuj devas punktokomoj kaj krampoj, kaj krispa krampoj, kaj pli. Sed rimarkas ke eĉ kvankam la sintakso estas pri rigardi iomete nekonataj al plejparto de vi, vidas preter tio. Kaj provi vidi la ideojn kiuj estas ja konata, ĉar tie en semajno unu kia ni komencos fari estas kompari, komence, Scratch kontre C. 

Do, ekzemple, memoras ke kiam ni implementado la unua de niaj programoj lasta fojo, ni havis blokon kiu aspektis iom io this-- kiam verdaj flago klakis, kaj tiam ni devis unu aŭ pli enigmo pecoj sub ĝi, tiukaze, diru, saluton mondo. Do efektive, en Scratch, Kiam mi klakas tiu verda flago kuri mia programo, do paroli, tio estas la blokojn kiuj aplikiĝas, aŭ kuri. Kaj, specife, Scratch diris, saluton, mondo. 

Nun, mi povus esti precizigita malsamaj vortoj tie. Sed ni vidos ke ja multaj de tiuj blocks-- kaj efektive, en C da functions-- povas esti parametrigita aŭ adaptitajn fari malsamajn aferojn. Fakte, en C, se ni volas konverti, nun, ĉi Scratch programo al tiu alia lingvo, ni tuj skribos iom io tiamaniere. 

Koncedita, ekzistas iu nekonata sintakso tie plej verŝajne, int, kaj krampojn kaj dezerta. Sed printf-- kvankam vi farus kredas ke nur estus presitaj. Sed presitaj signifas presaĵo formatita, kiel ni baldaŭ vidos. Ĉi laŭvorte presos al la ekrano ajn estas ene de tiuj krampoj, kiuj Kompreneble en tiu kazo estas, saluton mondo. 

Sed vi rimarkos iun alian sintakso, iuj citiloj, ke la krampoj ĉe la fino, la duon-dupunkto kaj similaj. Do ekzistas iom de supre, tiel diri, ambaŭ cognitively kaj sintakse, ke ni iras havi memori antaux longe. Sed rimarkas ke kun praktiko, tio komencos salti tra vi. 

Fakte, ni enfokusigi ke oni funkcio specifically-- tiukaze, diru saluton mondo. Tiel diri estas la funkcio. Saluton mondo estas lia parametro, aŭ argumento, lia personigo. 

Kaj la ekvivalento en C estas nur tuj estos ĉi tiu linio tie, kie printf samvaloras, diru, la duobla citita ŝnuro, saluton mondo egalas kompreneble al kio estas en la blanka skatolo. Kaj la backslash n, kvankam iom stranga kaj forestanta de Scratch, simple tuj havi la efikon ni vidi en komputilo, kiel mia Mac aŭ PC, de nur movanta la kursoron al la sekvanta linio. Estas kiel frapanta Entajpu sur via klavaro. 

Do ni vidos ke denove antaŭ longe. Sed unue, Lasita-a preni rigardi ĉi alia ekzemplo estas la kazo de cikloj. Ni havis ĉi eterna buklo lasta fojo, kiu estis serio de puzlo pecoj kiuj faris ion laŭvorte forever-- tiukaze, diru, saluton mondo, saluton mondo, saluton mondo, saluton mondo. Do ĝi estas senfina ciklo de dezajno. 

En C, se ni volas apliki tiun sama ideo, ni povus simple fari tion. Dum vera, printf saluton world-- nun dum, nur semantike, ia elvokas la ideon de fari io denove kaj denove, kaj denove, kaj por kiom longe? Nu, true-- revokon ke vera estas nur sur aŭ unu. 

Kaj vera estas, kompreneble, ĉiam vera. Do ĝi estas speco de sensignifa deklaro simple diri vera. Sed ja, tio estas intenca, ĉar se vera estas nur ĉiam vera, ol dum vera nur implicas, se iom nerekte, ke la sekvajn liniojn de kodo intere tiuj buklaj krampoj devus nur ekzekuti denove, kaj denove, kaj denove, kaj neniam vere halti. 

Sed se vi deziras vian buklo halti, kiel ni faris lastan fojon kun iu kiel tiu, ripeti la sekvaj 50 fojojn, en C ni povas fari lin sama kun kio estas nomita por loop-- la ŝlosilvorto ne dum, sed por. Kaj tiam ni havas kelkajn novajn sintakso tie, kun int i egalas 0, i malpli ol 50, i ++. Kaj ni revenos al tio. Sed tiu estas simple kiel ni farus traduki la aro de Scratch blokoj al aro de C linioj de kodo. 

Dume, Konsideri variabloj. Kaj, fakte, ni nur vidis antaŭ momento. Kaj en la kazo de Scratch, se ni volis deklari variablon nomis i por i esti entjero, nur nombro, kaj ni volas agordi ĝin por iu valoro, ni uzus tiun oranĝo bloki here-- starigis i al 0. 

Kaj ni vidos hodiaŭ kaj preter, kiel pasintsemajne, programistoj fari preskaŭ ĉiam komenci rakonti de nulo, vere per konvencio. Sed ankaŭ ĉar revoko de nia diskuto de duuma, la plej malgranda nombro vi povas reprezenti kun iu ajn nombro de bitoj estas ĝuste tuj esti 0 sin. Kaj tiel ni ĝenerale komencas inicializar nia variabloj al 0. 

Kaj en C por fari la saman, ni tuj diru int por entjero, I nur per konvencio. Mi povus esti nomata ĉi ŝanĝiĝema ion mi volas, ĝuste kiel en Scratch. Kaj tiam egalas 0 ĵus kuratoroj la valoron 0 de la dekstra kaj metas ĝin en la variablo, aŭ la stokado ujo tie, maldekstre. Kaj la duon-dupunkto kiel ni see-- kaj ni vidis kelkajn el tiuj already-- nur signifas finon de penso. Procedi fari ion alian sur la linioj kiuj sekvas. 

Nun, kio pri Bulea esprimoj? Memoru ke en Scratch, jen esprimoj kiuj estas ĉu vera aŭ false-- demandoj, vere, ke estas ĉu vera aŭ malvera. Tiel en la kazo de Scratch, ni eble demandi simplan demandon tiel, Estas i malpli ol 50? Do mi, denove, estas entjero. Eble ni uzas ĝin en Scratch programo konservi trako de dudeko aŭ ion tian. Do tiu sintakso tie en Scratch nur signifas, estas i malpli ol 50? Nu, dankeme, io simpla en C. Kaj traduki, tio ni simple diru i malpli ol 50, uzante la konata ŝlosilo sur via klavaro. 

Dume, se vi volis diri ion pli ĝenerala, kiel, nu, estas x malpli ol y, kie ĉiu de x kaj y estas mem variabloj? Ni povas fari la samon en C, tiel longe kiel ni havas kreita tiuj variabloj jam. Kaj ni vidos kiel faru tion antaŭ longe. Ni simple diru x malpli ol y. 

Do vi komencas vidi iujn similecojn. Kaj tiuj homoj, kiuj faris Nulo estis certe inspirita iuj de tiuj bazaj ideoj. Kaj vi vidos tian sintakso en multaj languages-- Ne nur Scratch, ne nur C, sed Python, kaj JavaScript, kaj aliaj lingvoj ankoraŭ. 

Ni konsideru alian konstrukcio de C, la nocio de kondiĉo, fari ion kondiĉe. Se io estas vera, do ĉi. Se io alia estas vera, fari tion. Ĝi estas speco de la programado ekvivalenta de forko en la vojo. Eble ĝi estas dudirekta forko, tridirekta forko, aŭ pli. Kaj en Scratch, ni havu vidis ion kiel tiu. 

Do ĉi tiu estas granda. Sed konsideri la relativan simpleco de la logiko. Se x estas pli malgranda ol y, tiam diru x estas malpli ol y, alie se x estas pli granda ol y, tiam diru x estas pli granda ol y. Kaj tiam, logike, se vi pensas reen al Scratch aŭ nur via propra homa intuicio, bone, se x ne estas pli granda ol y, kaj x ne malpli ol y, tiam kompreneble x estas iranta esti egala al y. Do en ĉi tiu kazo, de nestado tiuj Scratch blokoj, ni povas atingi tri maniero forkon en la vojo? 

Dume, se ni volas fari tion en C, ĝi eble aspektas iom simpler-- almenaŭ iam vi akiri familiara kun la sintakso. Se x estas pli malgranda ol y, printf x estas malpli ol y. Else if x estas pli granda ol y, printf x estas pli granda ol y. Alie printf x estas egala al y-- kaj, denove kun tiuj backslash finiĝas ĵus por tiuj novaj linioj por ke se vi fakte kuris tian programon ĝi simple movas vian kursoron finfine al la sekva linio de la ekrano. 

Nun, dume Scratch havis aliajn pli kompleksaj funkcioj, nur iuj de kiuj ni tuj komence movi super al la mondo de C. Kaj unu el ili estis nomita listo en Scratch. Kaj tio estis speciala tipo de variablo kiu permesis stoki multoblajn aferojn en ĝin, subteni, apogi, subteni. 

En C, ĝi ne havas listoj, per, sed io kiuj estas pli ĝenerale nomata tabeloj, kvankam ni revenu poste ĉi semestro por rigardi ion nomita liston, aŭ vere ligillisto. Sed nuntempe, la plej proksima ekvivalenta en C por ni tuj estos io nomita tabelo. Kaj tabelo estas simple speciala tipo de variablo kiu permesas stoki datumoj dorso, apogi, subteni, por dorso. 

Kaj cetere, en Scratch, Se ni volis atingi la unua elemento de tabelo aŭ oni list-- kaj mi tuj vokos ŝin, per konvencio, argv, argumento vektoro, sed pli sur tiu antaŭ longe. Se mi volas ricevi la unuan elementon de argv, en la mondo de Scratch vi fakte faras tipe komenci rakonti de 1. 

Do mi povus akiri eron 1 de argv. Tio estas nur kiel MIT implementado la nocio de listoj. Sed en C, mi tuj pli simple nur diru, argv, kiu denove estas la nomo de mia list-- aŭ esti klara, tabelo. Kaj se mi volas la unuan elementoj, mi tuj uzi kvadrataj krampoj, kion vi eble ne ofte uzita sub klavaro. 

Sed 0 signifas nur, min la unua. Tiel sur okazo kaj kiel tempo pasas, ni tuj komenci vidi tiujn dicotomías inter Scratch kaj C, per Scratch uzas. Ni en C utiligas 0 tie. Sed vi rapide vidi iam vi komprenos la fundamentoj de ĉiu lingvo, ke tiuj aĵoj komencas akiri ĉiujn pli familiara tra praktiko kaj praktiko. 

Do ni vere rigardi nun en programo. Tie estos la unua de nia C fontkodon por kompleta programoj. Kaj la programo ni iras oferi pro konsidero Estas kiu estas ekvivalenta por ke antaŭaj Scratch peco. 

Do tie, ni havas kio estas eble la plej simpla C programon vi povas skribi ke fakte faras ion. Nun ni rigardu pasinteco, nuntempe, ĝi inkludas: norma io.h, kaj tiuj angulo krampoj, kaj int kaj dezerta, kaj la krispa krampoj, kaj similaj. 

Kaj ni simple enfokusigi kio, almenaŭ intuicie, povus salti tra vi jam. Fakte, ĉefa, mi ne faras nepre scias kio tiu estas, sed multe kiel Scratch havis kiam verdaj flago klakis enigmo pecon, tiel faras C programlingvo havas ĉefan pecon de kodo kiu gets ekzekutita defaŭlte. Kaj, efektive, ĝi estas laŭvorte tuj nomos ĉefa. 

Tiel ĉefa estas funkcio. Kaj ĝi estas speciala funkcio kiu ekzistas en C ke kiam vi kuros programon, ĝi estas ĉefa kiu akiras kuri per defaŭlta. En la mondo de Scratch, estis kutime kiam verda flago klakis ke got kuras defaŭlte. 

Dume, ni vidis tion antaŭe, printf aŭ presita formatita, jen tuj esti funkcio kiu venas kun C, kune kun tuta amaso de aliaj, ke volo de tempo kaj tempo denove, por fari precize kiel ĝia nomo indikas, montri ion. Kion ni volas presi? Nu, ni vidos ke per enmetanta karakteroj kiel these-- saluton mondo, backslash n en citiloj, ni povas diri printf ekzakte kio presi sur la ekrano. 

Sed por fari ke ni bedaŭrinde bezonas preni iun kiu estas Jam kamufla por ni homoj, sed almenaŭ estas iom readable-- akra inkluzivas, norma io.h, int, ĉefa, malplenon, printf, ĉiuj la magiaj sorĉojn ni ĵus vidis en la ekrano. Sed ni efektive devas iri pli arcano ankoraŭ. Ni unue bezonas por traduki la kodon ke ni skribu en maŝino kodo. Kaj memoras de lasta semajno ke maŝinoj, almenaŭ tiuj ni konas tie, fine de la tago nur kompreni nuloj kaj aĵoj. 

Kaj mia Dio, se ni devis verki tiujn nuloj kaj reale programo, ĝi volis tre, tre rapide preni la amuza el io. Sed rezultas, po pasintsemajne, ke tiuj ŝablonoj de nuloj kaj nur havas specialan signifon. En certaj kuntekstoj, ili povus signifi nombroj. 

En iuj kuntekstoj, oni povus signifi literoj aŭ koloroj, aŭ ajna nombro de aliaj abstraktaĵoj kovris. Sed nur kiel via komputilo havas CPU, la Centra Processing Unit, aŭ la cerbo ene de via komputilo. Ĝi estas kutime Intel interne, ĉar tio estas unu el la plej grandaj kompanioj kiu faras CPUs por komputiloj. 

Nu, Intel CPUs kaj aliaj simple decidis anticipe ke iuj ŝablonoj de nuloj kaj tiuj devas signifi specifajn aferojn. Certaj ŝablonoj de nuloj kaj signifos, presi ĉi al la ekrano, aŭ aldoni tiujn du nombroj, aŭ subtrahi tiuj du nombroj, aŭ movi pecon de datumoj de mia komputilo memoro super tie, aŭ ajnan numeron de aliaj tre malalta nivelo, sed finfine utila, operacioj. Sed, dankeme, ni homoj ne tuj bezoni scii tiun nivelon de detalo. Efektive, nur ŝatas lasta fojo, kie ni distrita denove, kaj denove, kaj denove, konstruaĵo de tre malalta nivelo primitivoj kiel nuloj kaj al pli alta nivelo konceptoj kiel numeroj kaj literoj, kaj koloroj, kaj pli, tiel povas nin kiel programistoj staru sur la ŝultroj de aliaj kiuj nin antaŭis kaj uzi programaron ke aliaj homoj skribis antaŭ us-- nome programoj nomitaj tradukiloj. 

C estas lingvo kiu estas kutime kompilita, kio signifas igitaj de fontkodon maŝino kodo. En aparta, kion tio signifas estas ke se vi havas via fonto kodo kiun vi mem skribas, kiel ni baldaŭ ja nur momento sur la ekrano, kaj vi volas konverti ĝin finfine maŝino code-- tiuj nuloj kaj ke nur via Mac aŭ via PC understands-- vi hvas unua nutros fontkodon en kiel enigo al speciala programo nomata tradukilo, la eligo de kiu ni ekvidos estas maŝino kodo. Kaj cetere, lastan fojon ni parolis pri, vere, ĉe la fino de la tago, solvi problemojn. Vi havas enigoj. Kaj vi havas eligoj. Kaj vi havas ian de algoritmo en la mezo. 

Algoritmoj povas farigxos implementado en programaro, kiel ni vidis kun _pseudocode_ lasta semajno kaj kiel ni vidos kun reala kodo ĉi-semajne. Kaj tiel tradukilo vere nur havas aron de algoritmoj ene de tio, kion scipovas konverti la specialaj ŝlosilvortoj, kiel ĉefa, kaj printf, kaj aliaj, ke ni ĵus vidis en la ŝablonoj de nuloj kaj kiuj Intel ene kaj aliaj CPUs vere komprenas. Nu do kiel ni faros tion? Kie ni preni tradukilo? 

Plimulto de ni ĉi tie havas Mac aŭ PC. Kaj vi uzas Mac OS, aŭ Fenestroj, aŭ Linukso aŭ Solaris, aŭ ajnan numeron de aliaj mastrumaj sistemoj. Kaj, efektive, ni povis iros sur la TTT kaj elŝuti compilador por via Mac aŭ via PC por via aparta mastruma sistemo. Sed ni ĉiuj estus sur malsamaj paĝoj, por tiel diri. Necesus iomete malsamaj konfiguracioj. Kaj aferoj ne funkcius tutegale. Kaj ja, tiuj tagoj multaj el ni ne uzas programaro kiu kuras nur sur nia tekkomputiloj. Anstataŭe, ni uzas ion kiel navegador kiu permesas al ni aliri ttt-bazita aplikoj en la nubo. Kaj poste tiu semestro, ni faros ĝuste tion. Ni skribos aplikoj aŭ programaro uzante code-- ne C, sed aliaj lingvoj kiel Python kaj JavaScript-- kiuj kuras en la nubo. 

Kaj por fari tion, ni mem dum la semestro efektive uzi nubo-bazita medio nomata CS50 IDE. Jen ttt-bazita programado medio, aŭ integrita disvolviĝo medio, ide, ke estas konstruita sur la pinto iuj malferma fonto programaro nomita Cloud 9. Kaj ni faris iujn pedagogiajn simpligoj al ĝi tiel kiel por kaŝi iuj karakterizaĵoj en la unuaj semajnoj, ke ni ne bezonas, post kiu vi povas malkaŝi ilin kaj fari plej ajn vi volas per la medio. 

Kaj ĝi permesas nin ankaŭ al antaŭ- instali iuj programaro. Aĵoj kiel tn CS50 biblioteko, kiun ni baldaŭ vidos provizas nin en C kun kelkaj aldonajn funkciojn. Do se vi iras al, finfine, CS50.io, vi estos petata ensaluti, Kaj unufoje vi faras kaj krei konton senpage, Vi povos aliri medio kiu aspektas tute kiel ĉi. 

Nun, tiu estas en la defaŭlta modo. Ĉio estas bela kaj brila sur la ekrano. Multaj el ni havas kutimon laborante en CS50 peco tio tre malfrue en la nokto. Kaj tiel kelkaj el vi eble preferas igi nokto mode, por tiel diri. 

Sed, finfine, kio vi estas tuj vidos ene CS50 IDE estas tri distingaj areas-- areo sur la maldekstra kie viajn dosierojn tuj estos en la nubo, areo sur la supra dekstra kie via kodo tuj estos redakteblaj. Vi povos malfermi individua langetoj por ajna programo ke vi skribas ĉi semestro interne de tiu supra dekstra mano angulo. Kaj tiam plej arcanely, kaj ankoraŭ potence, tuj estos tiu afero en la malsupro konata kiel fina fenestro. 

Tio estas malnova lernejo Komandlinia interfaco, aŭ CLI, kiu permesas vi ekzekuti komandojn sur la computer-- tiukaze, la komputilo en la cloud-- agi tiamaniere, kompili vian kodon de fontkodo al maŝino kodo, kuri via programoj, aŭ komenci vian retservilo, aŭ por via datumbazo, kaj kiom ajn da aliaj teknikoj ke ni ekuzas antaŭ longe. Sed akiri tie, ni estas tuj efektive havas iri enretan kaj komenci ludi. Kaj por fari tion, ni unua komenci laboreti kun ĉefa, kaj skribi la ĉefa parto de programo. Kaj ni uzu tiun funkcion printf, kiun ni uzis antaŭe, simple diri ion. 

Do jen mi jam ene de CS50 IDE. Mi ensalutinta anticipe. Kaj mi plenan sxirmis la fenestro. Kaj do, finfine, vi tro en venonta problemoj sekvos similan paŝoj provizos rete dokumentado. Do vi ne bezonas zorgi pri sorbante ĉiun malgrandan teknikan paŝo ke mi faras ĉi tie hodiaŭ. 

Sed vi ricevos ekrano kiel ĉi. Mi hazarde estas en nokta modo. Kaj vi povas ilumini ĉio per malŝalti nokto mode. Kaj fine de la tago, vi tuj vidos tiuj tri ĉefaj areas-- la dosiero retumilo maldekstre, la kodo langetoj supren supro, kaj la fina fenestro ĉe la malsupro. 

Lasu min antaŭeniri kaj skribi mian unuan programon. Mi tuj preventa iri al Dosiero: Savi, kaj savu mian dosieron kiel hello.c. Efektive, per konvencio, ajna programo ni skribi ke estas skribita en la lingvo C devus esti nomita ion punkto c, per konvencio. Do mi tuj nomas ĝin hello.c, ĉar Mi nur volas diri saluton al la mondo. Nun mi tuj zomi eksteren kaj klaku Save. Kaj ĉiuj mi havas ĉi tie nun estas langeto en kiu mi povas komenci skribi kodon. 

Ĉi tio ne tuj kompili. Tio signifas nenion. Kaj do eĉ se mi konvertiĝis tio al nuloj kaj, la CPU tuj havos neniun ideon kio okazas ĉirkaŭe. Sed se mi skribas liniojn kiuj kongruas kun C la conventions-- C estaĵo, denove, tiu language-- kun sintakso kiel tiu, printf saluton world-- kaj mi havas alveninta komforte farante tiun dum tempo. Tial mi ne kredas ke mi faris ajna tipografia eraroj. 

Sed, senescepte, la plej unua tempo vi fari tion ĉi, Vi volas. Kaj kion mi intencas fari povus tre bone ne funkcias por vi la unuan fojon. Kaj tio estas perfekte bone, ĉar nun vi nur povus vidi amason de noveco, sed kun la tempo iam vi akiri familiara kun tiu medio, kaj tiun lingvon, kaj aliaj, vi komencas vidi aĵojn kiuj estas ĉu ĝusta aŭ malĝusta. 

Kaj tio estas, kion la instruado uloj kaj kompreneble helpantoj tiom bona en la tempo, estas ekvidanta erarojn aŭ misfunkciadojn en via kodo. Sed mi asertas ke neniuj cimoj en tiu kodo. Do mi nun volas kuri ĉi programo. 

Nun mia propra Mac aŭ PC, mi estas en la kutimo de duobla musklako ikonoj kiam mi volas kuri iun programon. Sed tio ne estas la modelo tie. En tiu medio, kiu estas CS50 IDE. Ni abonas mastruma sistemo nomita Linukso. Linukso estas rememoriga pri alia mastruma sistemo, ĝenerale konataj kiel Unikso. Kaj Linukso estas aparte konata pro havante Komando Linio Medio, CLI. Nun, ni uzas specifan gusto de Linukso nomata Ubuntu. Kaj Ubuntu estas simple certa versio de Linukso. 

Sed tiuj Linukso tiuj tagoj fari reale veni kun grafikaj interfacoj de uzanto. Kaj la unu ni hazarde uzanta jen ttt-bazita. Do tio ĉi povus rigardi eĉ iom malsama ion vi mem havu vidis aŭ kuri en la pasinteco. 

Do mi tuj iros antaŭen nun kaj fari la sekvan. Mi savis ĉi dosiero hello.c. Mi tuj iros antaŭen kaj tipo clanghello.c Do Clang por la C lingvo estas tradukilo. Estas antaŭ-instalitaj en CS50 IDE. Kaj vi povas absolute elŝuti kaj instali ĉi sur via propra Mac aŭ PC. 

Sed, denove, vi ne havus ĉiujn la pre-agordo farita por vi. Do nun, mi estas nur tuj kuri clanghello.c. Kaj nun rimarkas tiun sintakson tie volas eventuale realigi nur signifas ke mi estas en dosierujo aŭ dosierujo nomita Workspace. Ĉi dolaro signo estas simple konvencio por signifo, tajpu vian komandojn tie. 

Ĝi estas kio nomiĝas prompto, simple per konvencio estas dolaro signo. Kaj se mi iras antaŭen nun kaj klaku Eniri, nenio ŝajnas okazi. Sed tio estas fakte bona aĵo. La malpli kio okazas sur via ekrano, la pli verŝajna via kodo estas esti ĝentilaj, almenaŭ sintakse. 

Do se mi volas kuri ĉi programo, kion mi faru? Nu, tio rezultas ke la defaŭlta nomo de konvencio por programoj kiam vi ne specifi nomas por via programo estas ĝuste a.out. Kaj tiu sintakso tro, vi akiri familiara kun antaŭ longe. 

Dot oblikvo signifas nur, hej, CS50 IDE, kuras programo nomata a.out kiu estas interne de mia aktuala dosierujo. Ke skalara signifas la aktuala dosierujo. Kaj ni vidos kion aliaj tiaj sekvencoj de karakteroj signifas antaŭ longe. 

Do jen ni iros, Enter, saluton mondo. Kaj vi rimarkos, ke kio okazis? Ne nur ĝi presas saluton mondo. Ĝi ankaŭ movis la kursoron al la sekvanta linio. 

Kaj kial tio okazis? Kio estis la kodo kiun ni skribis antaŭe kiu certigis ke la kursoron farus iri sur la sekva linio? Amuza afero pri komputilo estas ĝi estas nur irante fari laŭvorte kion vi diros ĝin fari. 

Do se vi rakontos ĝin al printf saluton, komo, spaco, mondo, proksime citaĵo, ĝi estas laŭvorte nur iranta presi tiujn karakterojn. Sed mi havis tiun specialan karakteron fine, revokon, backslash n. Kaj tio certigis ke la karaktero iris al la sekva linio de la ekrano. 

Fakte, mi iros kaj fari tion. Lasu min antaŭeniri kaj forviŝi ĉi. Nun, rimarki ke la supro de mia ekrano ekzistas iom ruĝa lumo en la langeto indikante, hej, vi ne savis vian dosieron. Do mi tuj iros antaŭen kun kontrolo S aŭ komando S, savu la dosieron. Nun goes-- iris por moment-- verda. Kaj nun ĝi estas reen al nur estante proksime ikono. 

Se mi kuros clanghello.c denove, Eniros, dot oblikvo, a.out, Enter, vi vidos ke ĝi ankoraŭ funkciis. Sed estas disputeble iom kalesxo. Nun, mia prompt-- laborspaca, kaj tiam ke dolaro signo, kaj tiam mia fakta prompt-- estas ĉiuj sur la sama linio. Do tiu certe estetika cimo, eĉ se ĝi ne estas vere logika eraro. 

Do mi tuj malfari kion mi ĵus faris. Mi tuj rerun a.out. Rimarki Mi aldonis la lino karaktero dorso. Mi savis la dosieron. 

Do mi tuj rerun a.out, kaj- dammit, cimo, cimo Signifanta eraro. Do la cimo estas ke kvankam Mi aldonis la backslash n tie, re-savita, re-kuris la programo, la konduto estis la sama. Kial tiu? 

Mi mankas paŝo, dekstra? Ke kerna paŝo pli frue estis, ke vi havas to-- kiam vi ŝanĝos vian fontkodon, rezultas ankaŭ kuri tra la tradukilo denove tiel vi ricevas novan maŝinon kodon. Kaj la maŝino kodo, la nuloj kaj, tuj estos preskaŭ identaj, sed Ne perfekte tiel, ĉar ni bezonas, kompreneble, ke nova linio. 

Tiel por fiksi tion, mi tuj bezonas al rerun clanghello.c, eniri, punkto oblikvo, a.out. Kaj nun, saluton mondo estas reen al kie mi atendis ĝin esti. Do tiu estas la tuta bela kaj bona. Sed a.out estas sufiĉe stulta nomo por programo, kvankam ĝi okazas esti, pro historiaj kialoj, la default-- signifas asembleon eliroj. 

Sed lasu min antaŭeniri tie kaj faru tion malsame. Mi volas mian saluton mondo programo por fakte nomi saluton. Do se estus ikono sur mia labortablo, ĝi ne a.out. Ĝi nomus saluton. 

Do fari tion, rezultas ke Clang, kiel multaj programoj, Elportas komandlinio argumentoj, aŭ flagoj, aŭ ŝaltiloj, kiu simple influi lian konduton. Specife, Clang eltenas haltostreko o flago, kiu tiam prenas duan vorton. Tiukaze, mi arbitre, sed prudente, nomas ĝin saluton. Sed mi povis nomi ŝin ion Mi volas, krom a.out, kiu estus prefere krom la punkto. 

Kaj tiam simple entajpi la nomon de la dosiero Mi volas kompili. Do nun kvankam komence de la komando mi ankoraŭ havas Clang, fine de la komando Mi ankoraŭ havas la dosiernomo, Mi nun havas tiujn komandlinio argumentoj, tiuj flagoj kiuj diras: ho, dum la vojo, eligo-o, dosiero nomata saluton, ne la defaŭlta a.out. 

Do se mi batis Enter nun, nenio ŝajnas esti okazinta. Kaj, tamen, nun mi povas fari dot oblikvo saluton. Do ĝi estas la sama programo. La nuloj kaj aĵoj estas identaj ĉe la fino de la tago. 

Sed ili estas en du malsamaj files-- a.out, kiu estas la unua versio kaj simple stulte nomata, kaj nun saluton, kio estas multe pli konvinka nomon por programo. Sed, honeste, mi neniam tuj memoros ĉi denove, kaj denove, kaj denove. Kaj, fakte, kiel ni skribu pli komplikaj programoj, la komandojn vi tuj devas skribi tuj akiri eĉ pli komplikita ankoraŭ. 

Do ne maltrankviliĝu. Ĝi rezultas ke homoj antaŭ ni rimarkis ke tro devis precize tiu sama problemo. Ili tro ne ĝuis devi tajpas sufiĉe longe, arcano komandojn, lasu sole memori ilin. Kaj tial homoj antaŭ ni faris aliaj programoj kiuj faciligos kompili vian programaron. 

Kaj cetere, unu tia programo nomiĝas Make. Do mi tuj iros antaŭen kaj fari tion. Mi tuj malfari ĉion mi nur faris en la sekva maniero. Lasu min tajpi LS. Kaj vi rimarkos tri things-- a.out, kaj stelo, saluton kaj stelo, kaj hello.c. Espereble, tiu devus iom intuicia, mezuro frue ekzistis nenio en tiu spaco de laboro. Estis nenio, kion mi havis kreita ĝis ni komencis klaso. 

Kaj mi kreis hello.c. Mi tiam kompilita gxin, kaj donis al gxi a.out. Kaj tiam mi kompilis ĝin denove iomete malsame kaj nomis ĝin saluton. Do mi havas tri dosierojn en tiu dosierujo, en tiu dosierujo nomita Workspace. Nun, mi povas vidi ke tiel se mi malzomi fakte. 

Se mi malzomi tie kaj Rigardu tiun supra dekstra mano angulo, kiel promesis la maldekstra flanko de via ekrano ĉiam montros al vi kio estas en via konto, kio estas ene de CS50 IDE. Kaj ekzistas tri dosierojn tie. 

Do mi volas forigi a.out kaj saluton. Kaj kiel vi povus imagu intuicie, vi povus ordigi de kontrolo klako aŭ dekstre alklaku ĉi. Kaj tio iom -menuo. Vi povas elŝuti la dosieron, kuri ĝin antaŭrigardi ĝin, refreŝigi, renomi, aŭ kio ne. 

Kaj mi povus simple forigi, kaj ĝi foriros. Sed ni faru aferoj per ordono linio nuntempe, tiel kiel akiri komfortan kun tiu, kaj fari la sekvan. Mi tuj iros antaŭen kaj forigi a.out tajpante laŭvorte rma.out. Rezultas, la komando por forigante aŭ forigi ion, ne forigi aŭ forviŝi. 

Ĝi estas pli koncize RM, nur por ŝpari vi kelkajn keystrokes kaj batis Eniru. Nun ni tuj iom crípticamente forigu regula dosiero a.out. Mi ne vere scias kia malregula dosiero estus ankoraŭ. Sed mi volas forigi ĝin. 

Do mi tuj tajpi y por jes. Aŭ mi povus tajpi ĝin, kaj batis Eniru. Kaj, denove, nenio ŝajnas okazi. Sed tio estas, ĝenerale, estas bona afero. 

Se mi tajpas LS tiu tempo, kion mi vidas? Espereble, simple saluton kaj hello.c. Nun, kiel flanken, vi rimarki tiun stelon, asterisko, jen ĉe la fino de mia programoj. Kaj ili estas ankaŭ montrante supren en verda. Ke estas ĝuste CS50 IDE vojo de cluing vin en la fakto ke tio ne fontkodo. Jen plenumebla, oni ajn estas ebla programo kiu vi povas efektive ruli farante dot oblikvo, kaj tiam ĝi estas nomo. 

Nun, lasu min antaŭeniri kaj forigi tiu, rm saluton, Enter, forigu regula dosieron saluton, jes. Kaj nun se mi tajpas LS, Ni estas reen al hello.c. Provu ne forigi vian fakta fontkodo. Kvankam ekzistas trajtoj konstruita en CS50 IDE kie Vi povas iri tra via revizio historio kaj malantaŭenigi ĝustatempe, se vi hazarde forigi ion, faru memoras kiel po tiuj instigas jes aŭ ne, kion vi efektive volas fari. Kaj se mi iros al la supro maldekstra mano angulo tie, ĉiuj kiuj restas estas hello.c. Do ekzistas aroj da aliaj komandoj ke vi povas ekzekuti en la mondo de Linukso, unu el kiu estas, denove, Faru. Kaj ni tuj Make mia programo nun kiel sekvas. 

Anstataŭ fari tin, anstataŭ fari tin-o, Mi tuj simple laŭvorte tajpi, fari saluton. Kaj nun rimarkas, mi estas ne tajpas fari hello.c. Mi tajpas fari saluton. 

Kaj ĉi programo Faru ke venas kun CS50 IDE kaj pli ĝenerale kun Linukso, estas programo kiu estas tuj fari programon nomitan Saluton. Kaj ĝi tuj supozas, per konvencio, ke se tiu programo povas esti farita, ĝi tuj estos farita de fonto kodo dosiero finiĝante en punkto c, hello.c. 

Do se mi batis Enter nun, rimarki ke la komando ke gets ekzekutita fakte eĉ pli longa antaux ol antaŭe. Kaj tio estas ĉar ni havas preconfigured CS50 IDE havi iuj pliaj karakterizaĵoj konstruita en tiu ni ne bezonas nur ankoraŭ, sed baldaŭ estos. Sed la ŝlosilo afero realigi Nun mi havas Saluton programo. 

Se mi tajpas LS denove, mi havas saluton programo. Kaj mi povas ruli ĝin per dot oblikvo a.out, ne, ĉar la tuta punkto de ĉi ekzerco estis dot oblikvo saluton. Kaj nun mi havas mian saluton mondo programo. Tiel antaŭeniras, ni preskaŭ ĉiam nur tuj kompilos nia programoj uzante la komandon Make. Kaj tiam ni tuj kuri ilin per dot oblikvo, kaj la programo nomo. Sed rimarkas kio Make faras por vi, ĉu estas sin ne compilador. Estas nur oportunajho programo ke scipovas deĉenigi tradukilo kuri por ke vi mem povu uzi ĝin. 

Kion aliaj komandoj ekzistas en Linukso, kaj siavice la CS50 Ide? Ni baldaŭ vidos, ke ne estas KD komando, Ŝanĝo Katalogo. Tio ebligas al vi ene via komandlinio interfaco movi antaŭen kaj reen, kaj malfermu malsamaj dosierujoj sen uzanta vian muson. 

LS ni vidis, kio signifas listo la dosierojn en la nuna dosierujo. Fari Dir, vi povas probable komencas konkludi kion tio signifas now-- fari dosierujo, Se vi volas krei dosierujon. RM por forigi, RM Dir por forigi directory kaj tiuj, denove, estas la komandlinio ekvivalentoj de kion vi povis fari en CS50 IDE kun via muso. Sed vi baldaŭ trovi ke foje ĝi estas nur multe pli rapida fari aferojn kun klavaro, kaj finfine multe pli potenca. 

Sed estas malfacile argumenti ke io ni estis farante ĝis nun Estas ĉio, kion potenca, kiam ĉiuj ni estis dirante estas, saluton mondo. Kaj, fakte, mi hardcoded la vortoj saluton mondo en mian programon. Ne ekzistas dinamismo ankoraŭ. Nulo estis ordo de grando pli interesa pasintsemajne. 

Kaj do ni alvenos tien. Ni prenu unu paŝon direkte al tiu de maniero de iuj de ĉi tiuj funkcioj. Do ne nur C venas kun printf, kaj aroj da aliaj funkcioj iuj de kiuj vidos dum tempo, ĝi ne fari ĉion tiel facila ĝuste ekstere el la pordego en atingi uzanto enigo. 

Fakte, unu el la debilidades de lingvoj kiel C, kaj eĉ Java tamen aliaj, estas ke ĝi ne faciligi simple akiri aferojn kiel entjeroj de uzantoj, aŭ ĉenoj, vortoj, kaj frazoj, des malpli aliaj similaj glitpunktaj valoroj, aŭ reelaj nombroj kun dekuma punktoj, kaj vere longaj nombroj, kiel ni baldaŭ vidos. Do tiu listo de funkcioj tie, tiuj Estas kiel alia Scratch enigmo pecoj ke ni havas pre-instalita en CS50 Ide ke ni uzos por kelkaj semajnoj kiel trejnado radoj de varoj, kaj eventuale preni gxin kaj rigardu sub la kapuĉo, eble, ĉe kiom tion realigitajn. 

Sed por fari tion, ni reale skribi programon. Lasu min nun. Kaj mi tuj krei novajn dosieron de klakanta ĉi iom pli, kaj klakanta Nov Dosiero. 

Mi tuj savi ĉi sekva unu kiel, ni diru, string.c, ĉar mi volas ludi kun kordoj. Kaj ĉenon en C estas nur vico de signoj. Do nun ni iru antaŭen kaj fari la sekvan. 

Inkluzivas normo IO.h-- kaj rezultas norma IO, IO nur signifas enigo kaj eligo. Do rezultas ke tiu linio tie estas kio estas la najbara nin uzi printf. Printf kompreneble produktas eligo. Tial por uzi printf, rezultas el vi devas havi tiun linion de kodo ĉe la supro de via dosiero. 

Kaj ni revenos al kio kiu vere signifas antaŭ longe. Ĝi rezultas ke en ajna C programon mi skribas, Mi devas komenci ĝin per kodo kiu aspektas kiel ĉi tio. Kaj vi rimarkos CS50 IDE, kaj alia disvolviĝo integrita medioj kiel ĝi, tuj klopodos kiel eble plej Ili povas fini vian penson. Fakte, antaŭ momento se mi malfari kion mi ĵus faris, mi batis Enter. 

Mi tiam batis malfermita krispa streĉa, batis Enter denove. Kaj ĝi finis mian penson. Ĝi donis al mi novan linion, dentado ne malpli por agrabla stilaj kialoj ni vidos. Kaj tiam ĝi aŭtomate donis al mi ke krispa streĉa fini mian penson. Nun, ĝi ne ĉiam diveni kion vi volas fari. Sed en granda parto, ĝi faras savi vin iu pulsbatoj. Do antaŭ momento, ni kuris ĉi program-- saluton, mondo, kaj tiam kompilita ŝin, kaj tiam kuris gxi. Sed ekzistas neniu dinamismo tie. Kio se ni volis fari iun malsama? Nu, kio se mi volis vere ricevi ĉenon de la uzanto? Mi tuj uzos enigmo peco nomita ĝuste that-- atingi ŝnuron. 

Rezultas en C ke kiam vi ne deziras provizi enigo al enigmo pecon, aŭ pli ĝuste al funkcio, vi laŭvorte nur faru malferma parentezo, fermi parentezo. Do ĝi estas kvazaŭ ekzistas neniu blanka skatolo tajpi en. La vorton bloko antaŭ havis malgrandan blankan skatolon. Ni ne havas tiun blankan skatolon nun. 

Sed kiam mi vokas akiri kordo, mi volas meti la rezulton ien. Do tre komuna paradigmo en C estas nomas funkcio, kiel akiri string tie, kaj tiam stokas lia reveno valoro. Ĝi estas la rezulto de liaj penado en io. 

Kaj kio estas la konstrui en programado, ĉu en Scratch aŭ nun C, kiun ni povas uzi por fakte stoki ion? Nomis ĝin variablo, dekstra? Kaj en Scratch, ni ne vere zorgas pri kio okazas en variabloj. 

Sed en ĉi tiu kazo, ni vere faras. Mi tuj diru ŝnuro. Kaj tiam mi povus alvoki ĉi ajn mi volas. Mi tuj nomas ĝin nomo, ricevas atingi ŝnuron. 

Kaj nun eĉ se vi estas iom nova por tiu, rimarkos ke mi mankas kelkaj detaloj. Mi forgesis semi-dupunkto. Mi devas fini ĉi penso. Do mi tuj movi mian kursoron, kaj trafis duon-dupunkto tie. Kaj kion mi ĵus faris! En ĉi tiu linio de kodo, numero 5 en la momento, Mi vokas get kordoj sen enigoj. Do ne iom blanka skatolo kiel la Konservi bloko havas. 

Mi nur diras, hey, komputilo, min ŝnuro. La egalsigno estas vere egala signo, por se. Estas la tasko operatoro, kiu signifas, hej, komputilo, movi la valoron de dekstre super maldekstren. Kaj en la maldekstra, mi havas la sekvan. 

Hej, komputilo, donu al mi ĉenon vico de signoj. Kaj nomas tion kordoj nomo. Kaj mi eĉ ne devas voki lin Nomo. 

Mi povus nomi, konvencie, io kiel S, multe kiel ni uzis i al vokas la variablo i. Sed nun mi devas fari ion per ĝi. Estus sufiĉe stulta por provu kompili tiun kodon, kurante tiu programo, kvankam Mi ricevas cxeno, ĉar ĝi estas ankoraŭ nur dironta saluton mondo. 

Sed kio se mi volas ŝanĝi tion. Kial mi ne faru tion? Procento s komo s. Kaj tio estas iom kamufla ankoraŭ. 

Do lasu min fari mian variabloj pli klara. Lasu min nomas tiun variablon Nomo. Kaj ni vidu, se ni ne turmentus krom kio okazas tie. 

Tiel sur linio kvin, mi ricevas cxeno. Kaj Mi stokante ke kordo, ajn la uzanto tajpas in en sia klavaro, en variablo nomata Nomo. Kaj ĝi rezultas ke printf ne nur preni unu argumenton en duobla citiloj, unu enigo en citiloj. 

Ĝi povas preni du aŭ tri, aŭ pli, tia ke la dua, aŭ tria, aŭ kvara, estas ĉiuj nomoj de variabloj, aŭ specife valoroj, ke vi volas ŝtopi en, dinamike, kiujn ĉenon en citiloj. Alivorte, kio estus malĝuste kun tio? Se Mi nur diris saluton nomo, backslash n, savis mian dosieron, kompilas mia kodo, kaj kuris tio, kio okazus? 

Ĝi simple volis diri, saluton nomi, laŭvorte N-Al-M-Kaj, kiu estas speco de stulta ĉar ĝi estas ne malsama mondo. Do io en citaĵoj estas kio laŭvorte akiras presita. Do se mi volas havi lokokupilo tie, Mi vere bezonas uzi iuj specialaj sintakso. Kaj ĝi rezultas, se vi legis la dokumentaro por la printf funkcio, ĝi informos vin ke se vi uzas procento s, vi povas anstataŭigi valoro jene. 

Post komo poste citilon, vi simple skribu la nomon de la ŝanĝiĝemaj ke vi volas ŝtopi en en tiu formato kodo, aŭ formato specifier, procento s por kordoj. Kaj nun se mi savis mian dosieron, Mi reiros al mia terminalo. Kaj mi tajpas Faru String, ĉar, denove, la nomo de tiu dosiero, kiun mi elektis antaŭe estas string.c. 

Do mi intencis diri Faru String, eniru. Ho mia boneco, rigardi ĉiujn la eraroj ni faris jam. Kaj ĉi is-- kio, tio estas vere kiel ses, sep linio programo? Do tiu estas kie povas tre rapide atingi abrumadora. 

Tiu fina fenestro havas nun nur vomitaj multegaj erarmesaĝoj. Certe, mi ne havas pli eraran mesaĝojn ol mi linioj de kodo. Do kio okazas? 

Nu, la plej bona strategio fari aùton vi ja renkontas abrumadora lerta de eraroj tiel, Estas rulumu reen, serĉi la komando Vi nur kuris, kiu en mia kazo estas fari ĉenon. Rigardu kion fari, kaj pri tio, ke longa Clang komando, neniu granda interkonsento tie. 

Sed la ruĝa estas malbona. Verda provas esti afabla kaj helpema. Sed ĝi estas ankoraŭ malbona, en tiu kazo. Sed kie estas malbone? 

String.c, linio kvin, karaktero kvin. Do tio estas nur komuna kongreso. Io dupunkto ion signifas linio nombro kaj karaktero nombro. Eraro, uzo de nedeklarita ensalutilo ŝnuro. Ĉu vi volas diri normo en? 

Do, bedaŭrinde, Clang provas esti helpemaj. Sed estas malbone, en tiu kazo. Ne, Clang, mi ne intencis norma IO. Mi signifis ke sur linio unu, jes. 

Sed linion kvin estas ĉi tie. Kaj Clang ne kompreni S-T-R-I-N-G. Ĝi estas nedeklarita ensalutilo, oni vorto ĝi ĵus neniam vidis antaŭe. Kaj tio estas ĉar C, la lingvo ni skribas kodo en ĝuste nun, ne havas variabloj nomita kordoj. 

Ne, defaŭlte, subteno iu nomita ŝnuro. Tio estas CS50 peco de ĵargono, sed tre convencional. Sed mi povas fiksi tion kiel sekvas. 

Se mi aldonas unu linion de kodo al la supro de ĉi tiu programo, inkluzivi CS50.h, kiu estas alia dosiero ie ene de CS50 IDE, ie sur la malmola disko, tiel diri, de la Ubuntu operaciumo ke mi kuras, ke Estas la dosiero tio tuj instruos la mastruma sistemo kio kordo estas, ĝuste kiel norma io.h estas la dosieron en la mastruma sistemo kiu estas tuj instrui ĝin kio printf estas. 

Efektive, ni estus alvenintaj tre simila mesaĝon se IO estis akceptita normo Io.h kaj provis uzi printf. Do mi tuj iros antaŭen kaj nur preni Kontrolo L malbari mian ekranon. Aŭ vi povas entajpi klara kaj ĝi volas nur liberigi la fina fenestro. Sed vi povas ankoraŭ rulumu reen en tempo. 

Kaj mi tuj rerun Faru String. Transiras la fingrojn tiu tempo, Enter. Ho mia Dio, ĝi laboris. ĝi montras al mi longan kamufla komando tion Make generita per Clang, sed neniu erarmesaĝojn. Do realigi, kvankam vi eble ricevos tute superŝutita per numeron de erarmesaĝoj, ĝi nur povus esti tiu ĝena kaskadan efekto, kie Clang ne komprenas Unue, kion signifas ĝi tiam Ne komprenas la sekva vorto, aŭ la sekva linio. Kaj tiel ĝi nur sufokas en via kodo. Sed la solvon povus esti simplaj. Kaj tiel ĉiam enfokusigi la unua linio de produktado. Kaj se vi faras ne kompreni ĝin, nur rigardu por ŝlosilvortoj kiuj povus esti postsignoj, kaj la numero de linioj, kaj la karaktero, kie ke eraro povus esti. 

Nun lasu min antaŭeniri kaj tajpu dot oblikvo, kordoj, eniru. Hm, ĝi ne diras saluton nenion. Kial? Nu, memoru, kie ĝi kuras? 

Ĝi estas probable senmoviĝita ĉe la momento en buklo, se vi volas, sur linio ses, ĉar Get String projekte, skribita de CS50 bastonon, Estas laŭvorte signifas simple sidi tie atendis kaj atendis, kaj atendante kordo. Ĉiuj ni celas per ŝnuro estas homa enigaĵo. Do vi scias kion? Lasu min antaŭeniri. Kaj nur sur kaprico, lasu min tajpas mian nomon, Davido, eniru. Nun mi havas pli dinamika programo. Ĝi diris, saluton David. 

Se mi iras antaŭen kaj kuri ĉi denove, mi provu diri Zamila nomo, eniru. Kaj nun ni havas dinamikan programo. Mi ne malfacile kodita mondo. Mi ne malfacile kodita nomi, nek Davido, aŭ Zamila. 

Nun estas multe pli ŝatas la programojn ni scias, kie se ĝi prenas enigo, ĝi produktas iomete malsamajn eligo. Nun, ĉi tiu estas ne la plej bona uzanto sperto, aŭ UX. Mi kuros la programo. 

Mi ne scias kion mi supozis fari, se mi efektive rigardu aŭ memori la fontkodon. Do ni faru la uzanto sperti iom pli bona kun la plej simpla de aferoj. Lasu min reiri en tiun programo, kaj simple diri printf. 

Kaj lasu min antaŭeniri kaj diru nomo, dupunkto, kaj spaco, kaj tiam semi-dupunkto. Kaj ĝuste por piedbatoj, neniu kontraŭreago n. Kaj tio estas intenca, ĉar mi ne volas la prompto movi al la sekva linio. 

Mi volas, anstataŭe, tion, faru ŝnuron recompilar mia kodo en nova maŝino kodo dot oblikvo ŝnuro. Ah, tio estas multe pli bela. Nun mi vere scias kio la komputilo volas ke mi faru, donu al li nomon. 

Do mi tuj iros antaŭen kaj tajpu en Rob, eniri, kaj saluton, Rob. Do, realigi, tio estas ankoraŭ, fine de la tago, nur naŭ linio programo. Sed ni prenis tiujn bebo paŝoj. 

Ni skribis unu linio kun kiu ni estis familiara, printf, saluton mondo. Tiam ni malligis iomete de tio. Kaj ni efektive uzata get kordoj. Kaj ni ĵetis tiun valoron en variablo. Kaj tiam ni antaŭeniris kaj plibonigita ĝi plu kun tria linio. Kaj tiu ripeta procezo de skribanta softvaron estas vere ŝlosilo. En CS50, kaj en la vivo ĝenerale, Vi devus ĝenerale ne sidigxos, havi programon en menso, kaj provu skribi la tuta malbenita afero subite. 

Ĝi, neeviteble, rezultigi vojo pli eraroj ol ni mem vidis tie. Eĉ mi, ĝis hodiaŭ, konstante fari aliajn stultajn erarojn, Estas vere malfacila erarojn ke estas malfacile diveni. Sed vi faros pli erarojn pli linioj de kodo vi skribis cxiujn samtempe. Kaj tiel tiu praktiko de, skribi iomete da kodo ke vi estas komforta kun, kompili ĝin, ruli ĝin, testi ĝin pli ĝenerale, tiam movi on-- tiel simple kiel ni tenis layering kaj layering pasintsemajne, konstruado de io tre simpla al io pli kompleksa, fari same tie. Ne sidiĝu kaj provu skribi tutan problemon. Reale preni tiujn bebo paŝoj. 

Nun, kordoj ne estas ĉiuj ke utilajn al si. Ke estos fakte, ideale, kiel al havas ion alian en nia ilaro. Do ni vere faras ĝuste tion. 

Lasu min nun kaj vipi supren iomete malsama programo. Kaj ni nomas tiun int.c, por entjero. Mi tuj Simile inkluzivas CS550.h. Mi tuj inkluzivi normo IO. Kaj ke tuj estos sufiĉe komuna en tiuj unuaj tagoj de la klaso. 

Kaj mi tuj preta min kun ĉefa funkcio. Kaj nun anstataŭ prenanta kordo, ni iru antaŭen kaj akiri int. Ni nomas ĝin I, kaj nomas ĝin akiri int, proksime parens, duon-dupunkto. Nun ni faru ion kun ĝi, printf. 

Diru ion kiel saluton, backslash n, komo mi. Do mi preskaux imitante kion mi faris nur antaŭ momento. Mi havas lokokupilo tie. Mi komo i tie, ĉar mi volas ŝtopi i en tiun lokokupilo. 

Do ni iru antaŭen kaj provu kompili tiun programon. La dosiero nomata int.c. Do mi intencis diri, ke int, eniru. Ho mia Dio, sed ne granda interkonsento, ĉu ne? Tie estas eraro. 

Tie estas sintaksa eraro tie tia ke la programo ne povas kompilita ene int.c, linio sep, karaktero 27, eraro formato Specifas tipo char stelo, kio ajn tio estas. Sed la argumento tipo estas int. 

Do jen, ankaŭ, ni ne tuj to-- kvankam hodiaŭ estas multe de materialo, ni tuj superforti vin kun absolute ĉiu trajto de C, kaj programado pli ĝenerale, en nur tiuj unuaj semajnoj. Do tie estas ofte iranta esti ĵargono kun kiu vi ne estas familiara. Kaj, fakte, char stelo estas io ni tuj revenos al en semajno aŭ du de tempo. 

Sed nuntempe, ni vidu se ni povas analizi vortojn kiuj estas familiaraj. Formats-- do ni aŭdis formato especificación, formato kodo antaŭe. Jen familiara. Type-- sed la argumento havas tipo int. Atendu minuton, mi estas int. 

Eble procento s reale Havas iun difinita signifo. Kaj, ja, jes. Entjero, se vi volas printf anstataŭigi ĝin, vi vere devas uzi malsama formato specifier. Kaj vi ne scias se neniu al vi, aŭ vi faris ĝin antaŭe. Sed procento i estas kio povas kutime uzita en printf por ŝtopanta en entjero. Vi povas ankaŭ uzi procento d por dekuma entjero. Sed i estas bela kaj simpla tie. Do ni iru kun tio. 

Nun lasu min antaŭeniri kaj rerun konsiston int, Enter. Tio estas bona, sen eraroj. Dot oblikvo int-- OK, malbona sperto de uzanto, ĉar mi ne diris al mi mem kion fari. Sed tio estas bone. Mi kaptanta sur rapide. 

Kaj nun lasu min iri antaŭen kaj tajpi en David, OK, Zamila, Rob. Bone, do ĉi estas bona afero. Tiu tempo, mi uzas funkcio, enigmo peco, nomita get int. Kaj ĝi rezultas fjordon kaj ni vidi tion poste en la term-- la CS50 dungitaro estas implementado akiri string tiel ke gxi volas nur fizike akiri kordo por vi. 

Ĝi efektivigis get int en tiel ke ĝi volas nur akiri entjero por vi. Kaj se vi, la homo, ne kunlabori, estas laŭvorte simple tuj diru reprovi, reprovi, reprovi, laŭvorte sidas tie looping, ĝis vi komplezos kun iuj magiaj numeron, kiel 50, kaj saluton 50. 

Aŭ se ni kuras ĉi denove kaj tajpu en 42, saluton 42. Kaj tiel la get int funkcio ene de tiu enigmo peco Suficxas logiko, sufiĉas penso, elkompreni, kio estas vorto? Kaj kio estas nombro? Nur akcepti, finfine, nombroj. 

Do rezultas ke tiu Ne ĉiuj kiuj esprima. ĝis nun. Do, yay, lastfoje ni iris bela rapide en efektivigado ludoj kaj kuraĝigo, kaj artaj verkoj en Scratch. Kaj tie, ni estas enhavo kun saluton mondo, kaj saluton 50. 

Ĝi ne estas ĉiu tiu inspira. Kaj, efektive, tiuj unuaj ekzemploj prenos iun tempon al deklivirejo supre en ekscito. Sed ni havas tiom da pli kontroli nun, fakte. Kaj ni tuj tre rapide komenci layering sur supro de tiuj bazaj primitivoj. 

Sed unue, ni komprenos kion la limigoj estas. Fakte, unu el la aĵoj Nulo ne facile Ni faras vere aspektas sub la kapuĉo, kaj kompreni kia komputilo, kio povas fari, kaj kion liaj limigoj. Kaj cetere, ke manko de kompreno, potenciale, longatempa povas konduki al nia propra mistakes-- skribo cimoj, skribante necerta programaro kiu akiras hakita iel. 

Do ni prenu paŝoj al komprenante ĉi iom pli bona per maniero, te la jena ekzemplo. Mi tuj iros antaŭen kaj apliki reala rapida programo nomata Adder. Kiel, ni aldonu iujn numerojn kune. Kaj mi tuj kodigi iuj anguloj tie kaj nur kopii kaj alglui kie mi estis antaŭe, ĵus do ni povas akiri iranta frue. Do nun mi havas la bazajn komencojn de programo nomita Adder. 

Kaj ni iru antaŭen kaj fari tion. Mi tuj iros antaŭen kaj diru, intx ricevas ricevas int. Kaj vi scias kion? Ni faru pli bona sperto. 

Do ni simple diru x kaj efike instigas la uzanton por transdoni nin x. Kaj tiam lasu min antaŭeniri kaj diru, printf Kiom proksimume y estas, tiu tempon atendante du valoroj de la uzanto. Kaj tiam ni simple iru antaŭen kaj diru printf, la sumo de x kaj y estas. Kaj nun mi ne volas fari procento s. Mi volas fari procento i, backslash n, kaj tiam plug en sumo valoro. 

Do kiel mi iros sur faras tion? Vi scias kion? Mi scias kiel uzi variablojn. Lasu min nur deklari novan, int z. 

Kaj mi tuj prenos diveno tie. Se estas egala signoj en tiu lingvo, eble mi povas simple fari x plus y, kiam mi finos mian pensis kun duon-dupunkto? Nun mi povos reiri malsupren tie, plug en z, fini tiun penson kun duon-dupunkto. Kaj ni vidu, se ĉi tiuj sekvencoj de lines-- x estas akiri int. Y estas akiri int. 

Aldoni x kaj y, stoki la valoron en z-- do, denove, memoru la egalsigno Ne gxusta. Estas tasko de dekstre maldekstren. Kaj ni presi ke la sumo de x kaj y estas ne laŭvorte z, sed kio estas interne de z. Tial ni ebriigu Adder - bela, ne erarojn tiun tempon. Dot oblikvo Adder, eniri, x tuj esti 1. 

Y tuj estos 2. Kaj la sumo de x kaj y estas 3. Do jen ĉio bone kaj bona. 

Do vi imagus ke matematiko devus labori en programo kiel ĉi. Sed vi scias kion? Estas ĉi variablo, linio 12, eĉ necesa? Vi ne devas akiri en la kutimo de ĵus stokante aferojn en variabloj nur ĉar vi povas. Kaj, fakte, ĝi estas ĝenerale konsiderita maltaŭga se vi kreas variablo, nomita z tiukaze, stokante ion en ĝi, kaj tiam tuj uzante ĝin, sed neniam denove. Kial doni ion nomon kiel z se vi estas laŭvorte tuj uzos tiun afero nur unufoje, kaj tiel proksimaj al kie vi kreis ĝi en la unua loko, tiel proksima en terminoj de linioj de kodo? Do vi scias kion? Ĝi rezultas ke C estas sufiĉe fleksebla. Se mi vere volas plug -in valoroj tie, Mi ne bezonas deklari nova variablo. Mi povis nur plug -in x plus y, ĉar C komprenas aritmetiko, matematikaj kaj operatoroj. 

Do mi povas simple diri, ĉu ĉi math, x plus y ajn tiuj valoroj estas, ŝtopi la rezultanta entjero en tiun ĉenon. Do povas esti tiu, kvankam nur unu linio pli mallonga, pli bona dezajno, bona programo, ĉar ekzistas malpli kodo, do malpli por mi kompreni. Kaj ĝi estas ankaŭ nur pura, mezuro ni ne enkondukante novajn vortojn, novajn simbolojn, kiel z, kvankam ili ne vere servi multe de celo. 

Bedaŭrinde, matematiko ne ĉiuj ke fidinda foje. Ni iru antaŭen kaj fari tion. Mi tuj iros antaŭen nun kaj fari la sekvan. 

Ni faru printf, procento i, pli procento I, estu procento i, backslash n. Kaj mi tuj faros this-- xyx plus y. Do mi simple tuj reskribi tiun iomete malsame tie. Lasu min nur faru rapidan prudento ĉeko. Denove, ni ne anticipos mem. Fari neston, dot oblikvo vipuro. x estas 1, y estas 2, 1 plus 2 estas 3. Do tio estas bona. Sed ni kompliki ĉi nun iom, kaj krei novan dosieron. 

Mi tuj voki ĉi tiun, diru, ints, pluralo por entjeroj. Lasi min komenci kie mi antaŭ momento. Sed nun ni faras kelkajn aliajn liniojn. Lasu min antaŭeniri kaj fari la sekvan, printf, procento i, minus procento i, Estas procento i, komo x, komo yx minus y. Tiel mi faras iomete malsamaj matematikaj tie. Ni faru alian. Tiel procento i tempoj procento i estas procento i, backslash n. Ni plug -in x, kaj y, kaj x fojojn kaj. Ni uzos la asterisko sur vian komputilon por fojojn. 

Vi ne uzas x. x estas ŝanĝiĝema nomon tie. Vi uzas la stelon por multipliko. Ni faru pli. Printf procento mi, dividita per procento i, estas procento i, backslash n. xy dividita per y-- tiel vi uzas la antaŭen oblikvo en C fari dividon. Kaj ni faru unu alia. Cetera procento i, dividita per procento i, estas procentoj i. xy-- kaj nun cetero estas kio restas. Kiam vi provas dividanta a denominatoro en numeratoro, kiom estas lasita super tiu vi povis dividi eksteren? 

Do estas ne vere, nepre, simbolo ni uzis en grado lernejo por tio. Sed en C. Vi povas diru x module y, kie ĉi procentsigno en ĉi context-- konfuze kiam vi estas interne de la citiloj, ene de printf, procento uzas kiel formato specifier. 

Kiam vi uzas procento ekster ke en matematika esprimo, ĝi estas la module operatoro por modula arithmetic-- por niaj celoj tie, nur signifas, kio estas la cetero de x dividita per y? Do x dividita per y estas x oblikvo kaj. Kio estas la resto de x dividita per y? Ĝi estas x mod y, kiel programisto dirus. 

Do se mi faris nenian erarojn tie, lasu min antaŭeniri kaj fari ints, pluralo, bela, kaj dot oblikvo ints. Kaj ni iru antaŭen kaj do, ni diru, 1, 10. Bone, 1 plus 10 estas 11, ĉeko. 1 minus 10 estas negativa 9, kontrolu. 

1 fojojn 10 estas 10, ĉeko. 1 dividita per 10 is-- OK, ni salti tiu. Cetero de 1 dividita per 10 estas 1. Jen korekta. Sed estas cimo tie. 

Tial la unu mi metis mian transdoni, ne korekta. Mi volas diri, estas proksima al 0. 1 dividita per 10, sciu, se ni tranĉante iuj anguloj, certe, ĝi estas nulo. Sed devus vere esti 1/10, 0.1, aŭ 0.10, 0,1000, aŭ tiel plu. 

Gxi ne vere esti nulo. Nu, tio rezultas ke la komputilo estas faras laŭvorte kion ni rakontis al fari. Ni faras matematiko kiel x dividita per y. Kaj ambaŭ x kaj y, por la linioj de kodo antaŭe, estas entjeroj. 

Plie, sur linio 15, ni estas rakontanta printf, hey, printf kromprogramo entjera, plug -in entjero, plug-en integer-- specife x, kaj tiam y, kaj tiam x dividita per y. x kaj y estas ints. Ni bone tie. 

Sed kio estas x dividita per x? x dividita per y devus esti, matematike, 1/10, aŭ 0,1, kio estas reela nombro, reela nombro havante, potenciale, dekuma punkto. Ĝi ne entjero. 

Sed kio estas la plej proksima entjero al 1/10, aŭ 0,1? Yeah, ĝi ia estas nulo. 0.1 estas tiel multe. Kaj 1 estas ĉi tiel. Do 1/10 estas pli proksima al 0 ol al tiu. 

Kaj sekve kio C faras por us-- ia ĉar ni rakontis to-- Estas detranĉante ke entjero. Ĝi prenas la valoron, kiu denove estas supozis esti io kiel 0,1000, 0 kaj tiel plu. Kaj ĝin detranĉante ĉio post la dekuma punkto tiel ke ĉiuj ĉi aĵon, ĉar ĝi ne konveni en la nocio de entjero, kiu estas nur nombro kiel negativa 1, 0, 1, supren kaj malsupren, ĝi ĵetas for ĉio post la dekuma punkto ĉar vi ne taŭgas dekuma punkto en entjero per difino. 

Do la respondo tie estas nulo. Nu do kiel ni ripari tion? Ni bezonas alian solvon kune. Kaj ni povas fari tion, kiel sekvas. 

Lasu min antaŭeniri kaj krei novan dosiero, ĉi tiu nomita floats.c. Kaj savu ŝin tie en la sama dosierujo, float.c. Kaj lasu min antaŭeniri kaj kopio iom de tiu kodo de antaŭe. 

Sed anstataŭe de iĝi int, ni faru tion. Donu glitpunktaj valoro nomata x. kie glitpunkta valoro estas nur laŭvorte io kun flosanta punkto. Ĝi povas movi al la maldekstra, dekstre. Ĝi estas reela nombro. 

Kaj mi ne vokas akiri int, sed akiri kaleŝego, kiu ankaŭ estis inter la menuo de ebloj en la C250 biblioteko. Ni ŝanĝas y al kaleŝego. Do tiu fariĝas akiri kaleŝego. 

Kaj nun, ni ne volas ŝtopi en ints. Rezultas ni devas uzi procento f por kaleŝego, procento f por kaleŝego, kaj nun savos. Nun fingrojn transiritaj, fari kaleŝegoj, bela, dot oblikvo kaleŝegoj. x estas iranta esti unu 1. y Tuj estos 10 denove. 

Kaj, bela, OK mia Krome estas korekta. Mi estis esperanta por pli, sed mi forgesis skribi ĝin. Do ni iru kaj ripari tiu logika eraro. 

Ni iru antaŭen kaj ekpreni la sekvan. Ni nur faru malgrandan kopion kaj almeti. Kaj mi tuj diru minuso. 

Kaj mi tuj diru fojojn. Kaj mi tuj diros dividita. Kaj mi ne tuj fari module, kiu ne estas tiel germane tie, dividita per f kaj tempojn plus-- OK, ni faru ĉi denove. 

Faru kaleŝegoj, dot oblikvo kaleŝegoj, kaj 1, 10, kaj- bela, ne, OK. Do mi estas idioto. Do tiu estas tre komuna en komputiko fari stultajn erarojn kiel tio. 

Por pedagogiaj celoj, kion mi vere deziris fari estis ŝanĝi la sciencon tie por pli, al minus, por momentoj, kaj dividi, kiel vi espereble rimarkis dum tiu ekzerco. Do nun ni re-kompili ĉi programo, do skalara oblikvo kaleŝegoj. 

Kaj por la tria fojo, ni ĉu ĝi renkontas miajn atendojn. 1, 10, eniru, jes, bone, 1,000, dividita per 10,000, estas 0.100000. Kaj ĝi rezultas ni povas kontroli kiom da nombroj estas post tiuj dekuma punktoj. Ni fakte volas. Ni revenos al tio. 

Sed nun, fakte, la math estas ĝusta. Do, denove, kio estas la takeaway tie? Ĝi rezultas ke en C, estas ne nur simple strings-- kaj, fakte, ne estas vere, ĉar ni aldoni tiujn kun la CS50 biblioteko. Sed estas ne nur ints. 

Ekzistas ankaŭ flosas. Kaj ĝi rezultas faskon da aliaj datumoj tipoj ankaŭ, ke ni uzos antaŭ longe. Rezultas se vi volas sola karaktero, ne ĉenon de karakteroj, Vi povas uzi nur char. 

Rezultas, ke se vi volas bool, Bulea valoro, vera aŭ malvera nur, danke al la CS50 biblioteko, ni havas aldonita al C la bool datumtipo ankaŭ. Sed ĝi estas ankaŭ prezenti en multaj aliaj lingvoj ankaŭ. Kaj ĝi rezultas ke kelkfoje vi bezonas pli grandan nombroj tiam venas implicite kun ints kaj flosoj. 

Kaj, fakte, duobla Estas nombro kiu uzas ne 32 bitoj, sed 64 bitoj. Kaj longa longa estas nombro kiu uzas ne 32, bitoj sed 64 bitoj, respektive, por glitpunktaj valoroj kaj entjeroj, respektive. Do ni vere nun vidi tion en ago. 

Mi tuj iros antaŭen tie kaj vipi unu la alian programon. Tie, mi tuj iros antaŭen kaj do inkluzivas cs50.h. Kaj mi iros, inkludas normon io.h. 

Kaj vi rimarkos ion funky okazas tie. Ĝi ne kolora kodigo aferoj same kiel ĝi faris antaŭe. Kaj ĝi rezultas, tio estas ĉar mi ne donis la afero dosiernomon. 

Mi tuj nomas tiun unu sizeof.c kaj batis Konservi. Kaj rimarki kio okazas al mia tre blanka kodo kontraŭ tiu nigra fono. Nun almenaŭ ekzistas iuj purpura tie. Kaj tio estas sintakso emfazita. 

Tio estas ĉar, tute simple, mi havas diris la IDE kion tipo de dosiero estas per doni al ĝi nomon, kaj specife dosiersufikso. Nun, ni iru antaŭen kaj fari tion. Mi tuj iros antaŭen kaj tre simple printi la following-- bool Estas procento LU. 

Ni revenos al ke en nur momento. Kaj tiam mi tuj print grandeco de bool. Kaj nun, nur por ŝpari mi iam, mi estas faros tuto faskon el tiuj samtempe. Kaj, specife, mi tuj ŝanĝu tion char kaj char. Ĉi tiu, mi tuj ŝanĝos al duobla kaj duobla. 

Ĉi tiu, mi tuj ŝanĝos por kaleŝego kaj kaleŝego. Ĉi tiu, mi tuj ŝanĝi al int kaj int. Kaj ĉi tiu, mi tuj ŝanĝi longa longa. Kaj ĝi estas ankoraŭ prenante longa tempo, longa longa. 

Kaj tiam, finfine, mi donis mi unu tro multaj, kordoj. Ĝi rezultas ke en C, estas la speciala operatoro nomas grandeco de tio laŭvorte tuj, kiam kuri, diru al ni la grandecon de ĉiu el tiuj variabloj. Kaj tio estas maniero, nun, ni povas konekti reen al lasta semajno de diskutejo de datumoj kaj prezento. 

Lasu min antaŭeniri kaj kompili grandeco de dot oblikvo grandeco de. Kaj ni vidu. Ĝi rezultas ke en C, specife sur CS50 IDE, specife sur la mastruma sistemo Ubuntu, kiu estas 64-bita mastruma sistemo en ĉi tiu kazo, bool tuj uzi unu bajto de spaco. Tiel grandeco mezuras, Ne en bitoj, sed en bajtoj. Kaj memoras ke unu bajto estas ok bitoj. Tiel bool, kvankam vi teknike nur bezonas 0 aŭ 1, ĝi estas iom malŝparema kiel ni implementado ĝin. Ĝi estas vere tuj uzos tuta byte-- tiel ĉiuj nuloj, estas eble ĉiuj, aŭ io simila, aŭ nur unu 1 inter ok bitoj. 

A char, dume, uzita por gravulo kiel Ascii karaktero po pasintsemajne, tuj estos unu signo. Kaj ke synchs kun nia nocio ĝi estante ne pli ol 256 bits-- prefere, synchs kun ĝi estanta neniu longa ol 8 bitoj, kiu donas al ni cxiuj, 256 valorojn. Duobla tuj estu 8 bajtoj aŭ 64 bitoj. 

Al kaleŝego estas 4. Int estas 4. Longa, longa estas 8. Kaj ŝnuro estas 8. Sed ne maltrankviliĝu pri tio. Ni tuj senŝeligi reen tiun tavolon. Rezultas, kordoj povas esti pli longa ol 8 bajtoj. 

Kaj, efektive, ni skribis kordoj jam, saluton mondo, longa ol 8 bajtoj. Sed ni revenos al ke en nur momento. Sed la preno for tie estas la sekva. 

Ajna komputilo nur havas finia kvanto de memoro kaj spaco. Vi nur povas stoki tiel multajn dosierojn sur via Mac aŭ PC. Vi nur povas stoki tantos programoj en RAM kurante samtempe, nepre, eĉ kun virtuala memoro, ĉar vi havas finia kvanto de RAM. 

Kaj nur al picture-- se vi neniam malfermis tekkomputilo aŭ ordigita ekstra memoro por komputilo, vi eble ne scias ke ene de via komputilo Estas iu kiu aspektas iom tiel. Do tio estas nur komuna entrepreno nomita Crucial kiu faras RAM por komputiloj. Kaj RAM estas kie programoj vivi dum ili kuras. 

Tiel sur ĉiu Mac aŭ PC, kiam vi duoble klaku programon, kaj ĝi malfermas, kaj ĝi malfermas iun Vorto dokumenton aŭ io simila, ĝi stokas ŝin temporalmente en RAM, ĉar RAM estas pli rapida ol via malmola disko, aŭ via solida stato disko. Do estas nur kie programoj iri vivi kiam ili estas kurado, aŭ kiam dosieroj uzitaj. 

Do vi havas aferojn kiuj aspektas tiel ene de via tekkomputilo, aŭ iomete pli grandaj aferoj ene de via labortablo. Sed la ŝlosilo estas vi nur havas finia nombro de tiuj aferoj. Kaj tie estas nur finia kvanto de aparataro sidas sur tiu skribotablo dekstra tie. 

Do, certe, ni ne povas stoki senfine longajn numerojn. Kaj, tamen, se vi opinias reen al lernojaro lernejo, kiom da ciferoj povas vi havas la rajton de dekuma punkto? Cetere, kiom da ciferoj povas vi havas maldekstre de dekuma punkto? Vere, senlime multaj. 

Nun, ni homoj povus nur scipovas prononci milionoj, kaj miliardo, duilionoj, kaj duiliardojn kaj quintillion. Kaj mi puŝas la limojn de mia understanding-- aŭ my-- mi komprenas nombroj, sed mia elparolo de nombroj. Sed ili povas akiri senfine granda kun malfinie multajn ciferojn maldekstren aŭ al la rajto de dekuma punkto. 

Sed komputiloj nur havas finia kvanto de memoro, finia nombro de transistoroj, a finia nombro de ampoloj ene. Do kio okazas kiam vi elĉerpas de spaco? Alivorte, se vi pensas reen al lasta semajno kiam oni parolis pri nombroj sin estanta reprezentita en duuma, supozu ke ni havas tiu 8-bita valoro tie. 

Kaj ni havas sep 1-oj kaj unu 0. Kaj supozu ke ni volas aldoni 1 al tiu valoro. Jen vere granda nombro nun. 

Tio estas 254, se mi bone memoras la matematiko de lasta semajno dekstra. Sed kio se mi ŝanĝas ke plej dekstra 0 al 1? La tuta nombro, de Kompreneble, iĝas ok 1-oj. Do ni estas ankoraŭ bonaj. 

Kaj kiu probable reprezentas 255, kvankam depende de la kunteksto ĝi povus reale reprezentas negativa nombro. Sed pli sur tiu alia tempo. Tio sentas kiel ĝi estas proksimume tiel alta kiel mi povas rakonti. 

Nun, ĝi estas nur 8 bitoj. Kaj mia Mac, verŝajne, havas vojon pli ol 8 bitoj de memoro. Sed ĝi havas finia. Tial la sama argumento validas, eĉ se ni havi pli de tiuj sur la ekrano. 

Sed kio okazas se vi estas stokante tiu nombro, 255, kaj vi volas rakonti 1 bito pli altaj? Vi volas iri de 255 al 256. La problemo, kompreneble, estas ke se vi komenci kalkulon je nulo kiel pasintsemajne, Vi ne povas kalkuli tiel alta kiel 256, des malpli 257, lasu sole 258, m pro kio okazas kiam vi aldonas 1? Se vi faros la malnova lernojaro lernejo alproksimiĝo, vi metis 1 tie, kaj tiam 1 plus 1 estas 2, sed tio estas vere nulo, vi portos la 1an porti la 1an porti la 1. Ĉiuj el tiuj aferoj, tiuj 1-a, iru al nulo. Kaj vi serpentumi supren, jes, kiel iu atentigis, 1 sur la maldekstra flanko. Sed ĉion vi povas reale vidi kaj havi en la memoro estas nur ok 0, kio estas ĉe iu punkto, se vi, komputilo, provis rakonti sufiĉe alta supren, vi estas tuj envolver ĉirkaŭe, ĝi ŝajnus, al nulo, aŭ eble eĉ negativa nombroj, kiuj estas eĉ pli malalta ol nulo. 

Kaj ni povas ia vidi ĉi. Lasu min antaŭeniri kaj skribi vera rapida programo tie. Lasu min antaŭeniri kaj skribi programo nomata Overflow. Inkluzivi CS50.h, inkluzivi norma IO.h-- ho, Mi vere maltrafis mian sintaksa kolorigo. Do ni savu tion kiel overflow.c. 

Kaj nun int ĉefa void-- kaj post nelonge, ni instruos vin revenu al klarigi kial ni tenas skribanta int ĉefa malplenon. Sed nuntempe, ni nur fari ĝi, prenante ĝin por sentado. Ni donu min int, kaj pravalorizi ĝin al 0. 

Ni tiam faru por int i akiras zero-- fakte, ni faru senfina ciklo kaj vidu kio okazas. Dum vera, tiam ni presi n Estas procento i, backslash n, plug -in n. Sed, nun, ni faru n prenas n plus 1. 

Do alivorte, sur ĉiu ripeto de tiu senfina buklo, ni prenu n valoro, kaj aldoni 1 al ĝi kaj poste stoki la rezulton reen en n maldekstre. Kaj, fakte, ni vidis sintakso iomete kiel tiu, mallonge. A cool lertaĵo estas anstataŭe verki ĉiuj ĉi ekstere, Vi povas fakte diri n plus egalas 1. 

Aŭ se vi vere volas esti imago, vi povas diri n plus plus duon-dupunkto. Sed tiuj lastaj du estas nur kion ni nomus sintaksa sukero por la unua afero. 

La unua afero estas pli eksplicita, tute bone, tute korekta. Sed tiu estas pli ofta, mi diros. Do ni faru tion por nur momento. 

Ni nun faras overflow, kiu sonas prefere malbonaŭgura, dot oblikvo troplenigxis. Vidu, n Fariĝas iom granda. Sed ni pensas, kiom granda povas n ricevis? 

n estas int. Ni vidis antaŭ momento kun la grandeco de Ekzemple ke int estas kvar bajtoj. Ni scias de la pasinta semajno, kvar bajtoj estas 32 bitoj, ĉar 8 fojoj 4, tio estas 32. Ke tuj estos 4 miliardoj. 

Kaj ni estas ĝis 800.000. Ĉi tiu tuj preni forever kalkuli tiel alta kiel mi eble povas. Do mi tuj iros antaŭen, kiel vi eble post nelonge, kaj batis Kontrolo C-- sincere, Kontrola C, multe, kie Kontrolo C ĝenerale per nuligi. Bedaŭrinde, pro tiu kuras en la nubo, Iufoje la nubo estas kracxi el tiom stuff, tiel eligo, ĝi tuj preni iom da tempo por mia enigo akiri al la nubo. Do kvankam mi trafis Kontrolo C kelkaj sekundoj antaŭ tiu estas sendube la flanko efekto de senfina ciklo. 

Kaj tiel en tiaj okazoj, ni estas lasos ke estu. Kaj ni tuj aldonas alian terminalfenestro tien kun la alpago, kiu kompreneble ne tiel, ĉar ĝi estas ankoraŭ pensas. Kaj ni iru antaŭen kaj estu iom pli racia. 

Mi tuj iros antaŭen kaj fari ĉi nur finie multajn fojojn. Ni uzu por ciklo, kiun mi aludis al pli frua. Ni faru ĉi. Donu al mi alian variablo int i ricevas 0. i estas malpli ol, ni diru, 64 I ++. Kaj nun lasu min iri antaŭen kaj presita el n estas procento i, komo n. Kaj tiam n-- tiu estas ankoraŭ tuj prenos ĉiam. Ni faru ĉi. 

n prenas n fojoj 2. Aŭ ni povus esti imago kaj fari tempoj egalas 2. Sed ni simple diri n egalas, tempoj 2. Alivorte, en tiu nova versio de la programo, Mi ne volas atendi por ĉiam de kiel 800,000 ĝis 4 miliardoj. Ni nur ricevas tiun super kun. 

Ni vere duobligi n ĉiufoje. Kiu, memoru, duobligo estas la malo de esti, kompreneble. Kaj dum lasta semajno havas io denove kaj denove, kaj denove, super rapida, duobligo certe liberigi nin el 1 al la plej granda ebla valoro kiun ni povas kalkuli al kun int. 

Do ni faru ĝuste tion. Kaj ni revenos al tiu post nelonge. Sed tiu, denove, estas nur kiel la ripeto bloko en Scratch. Kaj vi uzos tion antaŭ longe. 

Tio nur signifas grafo de nulo ĝis, sed ne egala, al 64. Kaj sur ĉiu ripeto de ĉi buklo, simple observu pliigante i. Do i ++ - kaj tiu ĝenerala konstrukcio sur linio 7 estas nur super komuna vojo ripeti iuj linioj de kodo, iu numero de fojoj. Kiuj linioj de kodo? Tiuj buklaj krampoj, kiel vi eble kolektis de nun, signifas, faru la sekvajn. 

Ĝi estas en kiel Scratch, kiam ĝi havas la flavajn blokojn kaj aliaj koloroj tian brakumi aŭ brakumi aliajn blokojn. Tion tiuj buklaj krampoj faras cxi tie. Do se mi akiris mian sintakso right-- vin povas vidi la karoto simbolo en C rimedoj jen kiom da fojoj mi provas solvi tiun problemon. Do ni seniĝi de tiu entute, kaj fermi tiun fenestron. Kaj ni uzos la novan. Fari overflow, dot oblikvo overflow, Enter, bone, ĝi aspektas malbona unue. Sed ni rulumu reen en tempo, ĉar mi faris tion 64 fojojn. 

Kaj rimarki la unua fojo, n estas 1. Duafoje, n estas 2, tiam 4, tiam 8, tiam 16. Kaj ĝi similas ke tuj kiam Mi alvenas al proksimume 1 miliardo, se mi duobligi ĝin denove, por ke donu al mi 2 miliardoj. Sed rezultas, estas ĝuste sur la pinto. 

Kaj do ĝi reale superfluas int de 1 miliardo al proksimume negativa 2 miliardoj, ĉar entjero, kontraste la numerojn ni estis supozante pasintsemajne, povas esti ambaŭ pozitivajn kaj negativajn en realeco kaj en komputilo. Kaj tiel almenaŭ unu el tiuj bitoj efektive ŝtelita. Do ni vere nur havas 31 bitojn, aŭ 2 miliardoj eblaj valoroj. 

Sed nuntempe, la takeaway estas sufiĉe simple ajn tiuj nombroj estas kaj kiel la matematiko estas, io malbona okazas fine, ĉar fine vi provas permuti la bitoj unu tro da fojoj. Kaj vi efektive iri de ĉiuj 1-oj al eble ĉiuj 0-a, aŭ eble nur iuj aliaj padrono ke klare, depende de la kunteksto, povas esti interpretita kiel negativa nombro. Kaj tiel ĝi ŝajnus la plej altaj mi povas kalkuli en ĉi tiu aparta programo nur malglate 1 miliardo. Sed estas parta solvo tie. Vi scias kion? 

Lasu min ŝanĝi de int por longa tempo. Kaj lasu min antaŭeniri tie kaj say-- mi tuj havos ŝanĝi ĉi tion al sensigna longa. Aŭ, ni vidu, mi neniam memoras min. 

Ni iru antaŭen kaj fari troplenigxis. Ne, tio ne estas ĝi, LLD, dankon. Do kelkfoje Clang povas esti helpema. Mi ne memoras, kion la formato especificación estis dum longa tempo. 

Sed ja Clang diris al mi. Green estas ia bona, ankoraŭ signifas vi eraris. Ĝi konjektas ke mi signifis LLD. 

Do lasu min preni ĝi estas konsilo, longa longa dekuma nombro, savi tion. Kaj mi rerun ĝin, dot oblikvo overflow, Enter. Nun kio estas malvarmeta estas tio. 

Se mi rulumu reen en tempo, ni ankoraŭ komenci rakonti al la sama place-- 1, 2, 4, 8, 16. Avizo, ni akiras ĉiujn vojo ĝis 1 miliardo. Sed tiam ni sendanĝere atingos 2 miliardojn. 

Tiam ni atingos 4 miliardoj, tiam 8 miliardoj 17 miliardoj. Kaj ni iru pli alten, kaj alta kaj pli alta. Fine, tiu, tro, paŭzoj. 

Eventuale, kun longa longa, kiu estas la 64-bita valoro, ne 32-bita valoro, se vi kalkuli tro alta, vi envolver ĉirkaŭ 0. Kaj en ĉi tiu kazo, ni hazarde finos kun negativa nombro. 

Do tiu estas problemo. Kaj ĝi rezultas ke tiu problemo ne ĉiuj kiuj arcano. Kvankam mi havas intence induktitaj per tiuj eraroj, rezultas ni vidas ia tuta ĉirkaŭ ni, aŭ almenaŭ iuj el ni faras. 

Tiel en Lego Star Wars, se vi iam ludis la ludon, ĝi rezultas vi povas ĉirkaŭiri rompi aĵojn en LEGO mondo, kaj kolektanta monerojn, esence. Kaj se vi iam ludis tiu ludo maniero tro da tempo, kiel tiu nenomita individua tie faris, la totala nombro de moneroj kiujn vi povas kolekti Estas, ĝi similus, 4 miliardoj. 

Nun kun ĝi estas fakte rondoforma. Tiel LEGO penis teni aferojn uzanto amika. Ili ne faris ekzakte 2 la 32 povo, po pasintsemajne. Sed 4 miliardoj estas kialo. Ŝajnas, bazita sur tiu informo, ke LEGO, kaj la kompanio kiu faris tiun faktan programaro, decidita ke la maksimuma nombro da moneroj la uzanto povas amasigi Estas ja 4 miliardoj, ĉar ili elektis en siaj kodo uzi ne longa tempo, ŝajne, sed nur entjero, sensigna entjera, nur pozitiva entjero, kies maks valoro estas proksimume tiu. Nu, jen alia amuza unu. Tiel en la ludo Civilization, kiu iuj el vi povus esti familiara, kun ĝi rezultas ke antaŭ jaroj ekzistas Estis cimo en tiu ludo per se vi ludis la rolon de Gandhi en la ludo, anstataŭ lin esti tre pacisma, anstataŭe estis nekredeble, nekredeble agresema, en iuj cirkonstancoj. Aparte, la maniero ke Civilizacio verkoj estas ke se vi, la ludanto, adopti demokratio, via agresividad partituro ricevas decremented duope, tiel minus minuso, kaj tiam minus minus. 

Do vi subtrahi 2 de via reala ripetanta. Bedaŭrinde, se via ripetanta estas komence 1, kaj vi subtrahi 2 de ĝi post adopti demokratio kiel Gandhi tie povus faris, ĉar li estis tre passive-- 1 sur la skalo de agresividad. Sed se li adoptas demokratio, tiam Li iras de 1 al negativa 1. 

Bedaŭrinde, ili estas uzante sensigna nombroj, kio signifas traktis eĉ negativa nombroj kvazaŭ ili estis pozitivaj. Kaj ĝi rezultas ke la pozitivaj ekvivalento de negativa 1, en tipa komputilo programoj, estas 255. Do se Gandhi adoptas demokratio, kaj pro tio havas lia agresividad partituro malpliiĝis, ĝi efektive ruliĝas ĉirkaŭ 255 kaj igas lin la plej agreseman karakteron en la ludo. Do vi povas Guglas sur tiu. Kaj ĝi estis ja kiel akcidenta programado cimo, sed tio eniris tute la popolscio tiam. 

Jen ĉio amuza kaj cute. Pli timiga estas kiam fakta reala mondo aparatoj kaj ne ludoj, havas tiujn samajn misfunkciadojn. Fakte, nur unu jaro artikolo venis el la Boeing 787 Dreamliner. 

Kaj la artikolo unue rigardo legas iom arkaikaj. Sed dirinte, programaro vulnerabilidad en Boeing nova 787 Dreamliner jeto havas la potencial por kaŭzi pilotoj perdi kontrolon de la aviadilo, eble en plena flugo, la FAA oficialuloj avertis aviadkompanioj ĵus. Estis prijuĝo ke modelo 787 aviadilo kiu estis funkciigita senĉese por 248 tagoj povas perdi ĉiuj alterna fluo, alterna, elektra povo pro la generatoron kontrolo unuoj, GCUs, samtempe iro en malsukcesos sekura reĝimo. Estas speco de perdi min. Sed la memo deklaris, OK, nun mi tion aŭdas, la kondiĉo estis kaŭzita de programaro kontraŭi internaj al la generatoro kontrolo unuoj kiuj superfluas post 248 tagoj de kontinua potenco. Ni eldonanta ĉi rimarki malhelpi perdon de ĉiuj AK elektra potenco, kiu povus rezulti en perdo de kontrolo de la aviadilo. 

Do, laŭvorte, estas iu entjero, aŭ iu ekvivalento datumtipo, uzata en programaro en fakta aviadilo ke se vi tenas vian aviadilon sur sufiĉe longa, kiu ŝajne povas esti la kazo se vi nur kuri ilin konstante kaj neniam unplugging via aviadilo, ŝajnas, aŭ lasanta lian kuirilaroj morti, eventuale kalkuli, kaj supren, kaj supren kaj supren kaj supren kaj supren. 

Kaj, nature, oni finia kvanto de memoro estos inunda derulis al nulo aŭ negativan valoron, kromefikon de kiuj estas la timige reala realaĵo ke la ebeno eble bezonas esti rebooted, efike, aŭ falu, malbona, kiel ĝi flugas. Tiuj specoj de aferoj estas ankoraŭ kun ni, even-- tio estis 2015 artikolo, des pli timiga kiam vi ne bezone kompreni, estimi, aŭ anticipi tiuj specoj de eraroj. 

Do rezultas ekzistas unu alia malbona afero pri datumoj reprezento. Ĝi rezultas ke eĉ flosigas estas ia misa, ĉar kaleŝegoj, tro, Mi proponis estas 32 bitoj, aŭ eble 64 se vi uzas duoblan. Sed tio ankoraŭ finiaj. 

Kaj la ruzo estas ke se vi povas metis malfinia nombro de ciferoj post la dekuma punkto, ne estas maniero vi povas reprezenti ĉiujn eblajn numeroj kiuj ni estas instruitaj en grado lernejo povas ekzisti en la mondo. Komputila, esence, ĝi devas elekti subaro de tiuj nombroj reprezenti precize. 

Nun, la komputilo povas ronda eble iomete, kaj povas permesi al vi malglate vendejo ajna nombro vi povus eble volas. Sed nur intuicie, se vi havas finia nombro de bitoj, Vi nur povas permuti ilin en tiom multaj finiaj manieroj. Do vi ne povas eble uzi finia nombro de permuto de bitoj, ŝablonoj de nuloj kaj aĵoj, reprezenti malfinia nombro de ciferoj, kiu sugestas ke komputiloj povus tre bone esti kuŝanta al ni kelkfoje. 

Fakte, ni faru tion. Lasu min reiri en CS50 IDE. Lasu min antaŭeniri kaj krei malgrandan programon nomita Imprecision, por montri ke komputiloj estas ja malpreciza. 

Kaj lasu min antaŭeniri kaj komenci kun iom de tiu kodo de antaŭe, kaj nun nur faru la sekvajn. Lasu min antaŭeniri kaj fari printf, procento f, backslash n, 1 dividita per 10. Alivorte, ni plonĝi en profundan al 1/10, kiel 1 kaj dividita per 10. Certe, komputilo povas reprezenti 1/10. 

Do ni iru antaŭen kaj fari imprecision. Ni vidos. Formato specifas tajpi duobla. Sed la argumento havas tipo int. Kio okazas? 

Ho, interesa, tial ĝi estas leciono lernis antaŭe. Mi diras, hey, komputila programo mi kaleŝego kun procento f. Sed mi donas gxin 2 ints. Do rezultas, mi povas ripari tiun en kelkaj manieroj. 

Mi povis nur turni unu en 1.0, kaj 10 en 10,0, kiu volis ja havas la efikon de transformado ilin floats-- ankoraŭ espereble la sama nombro. Aŭ ĝi rezultas ke estas io ni vidos denove post nelonge. Vi povus elpeli la numerojn. 

Vi povas, uzante ĉi parenthetical esprimo, oni povas diri, hej, komputilo, prenu tiun 10, kiun mi konas estas int. Sed traktas ĝin, bonvolu, kvazaŭ ĝi estas kaleŝego. Sed tiu sentas nenecese kompleksa. 

Por niaj celoj hodiaŭ, ni nur laŭvorte Fari ilin glitpunktaj valoroj kun dekuma punkto, kiel tiu. Lasu min antaŭeniri kaj rerun, fari imprecision, bona, dot oblikvo imprecision, eniru. OK, ni serĉas bonon. 

1 dividita per 10, laŭ mia Mac tie, estas, ja, 0.100000. Nun, mi estis instruita en grado lernejo devus esti malfinia nombro de 0-aj jaroj. Do ni almenaŭ provu vidi iuj de tiuj. Ĝi rezultas ke printf estas iom amatoro ankoraŭ ol ni estis uzante. Ĝi rezultas vi ne devas specifi nur procento f, aŭ simple procento i. Vi povas fakte specifi iu kontrolo ebloj tie. 

Specife, mi tuj diri, hey, printf, fakte montras min 10 dekuma punktoj. Do ĝi aspektas iom stranga. Sed vi diru procentoj, streketo kiom nombroj vi volas vidi post la dekuma punkto, kaj tiam f por plata, nur ĉar tio estas kion la dokumentado diras. Lasu min antaŭeniri kaj savi tion. 

Kaj rimarkos ankaŭ, mi ricevas laca de retyping aferoj. Do mi simple opcio la supren kaj malsupren sago sur mian ŝlosilojn tie. Kaj se mi tenas frapanta supre, Vi povas vidi ĉiujn komandojn ke mi faris, aŭ malĝuste faris. 

Kaj mi tuj iros antaŭen nun kaj ne vere uzas tion, ŝajne. Fari imprecision, punkto oblikvo imprecision-- tiel kion mi estis instruita en lernojaro lernejo kontrolas. Eĉ se mi presi ĝin al 10 dekuma metas ja estas 0,10000. Sed vi scias kion? 

Ni iru iom avara. Diru, kiel montri al mi 55 antaŭ post la dekuma. Ni vere preni tiun plani eksteren kiel spino. Lasu min refari ĝin kun ŝminko imprecision, dot oblikvo, imprecision. 

Kaj tie ni iru. Via infanaĝo estis mensogo. Ŝajne, 1 dividita per 10 estas ja 0.100000000000000005551115123-- 

Kio okazas? Nu, tio rezultas, se vi ia aspektas sufiĉe en la suba reprezento de tiu nombro, ĝi reale ne ekzakte 1/10, aŭ 0.1 kaj malfinia nombro de nuloj. Nun, kial do? 

Nu, eĉ se tiu estas simpla nombro por ni homoj, 1 dividita per 10, ĝi estas ankoraŭ unu el malfinie multaj numeroj kiuj ni povis elpensi. Sed komputilo povas nur reprezenti finie multaj tiel nombroj. Do, efektive, kion la komputilo montras al ni estas ĝia plej proksima aproksimado al la nombro ni volas kredi estas 1/10, aŭ vere 0,10000 ad infinitum. 

Prefere, tamen, ĉi tiu estas tiel proksime kiel ĝi povas akiri. Kaj cetere, se vi rigardas sub la kapuĉo, kiel ni estas tie rigardante 55 ciferoj post la dekuma, ni fakte vidos ke realeco. Nun kiel flanken, se vi havas iam vidis la movie-- plejparto de vi probable haven't-- sed Superman 3 kelkaj jaroj, Richard Pryor esence ekspluatita ĉi realo en sia entrepreno ŝteli multajn de frakcioj kaj frakcioj de pencoj, ĉar la company-- kiel mi memoras, ĝi pasis while-- estis esence ĵetante ion kiu ne persvadis en la nocio de cendoj. 

Sed se vi sumigas ĉiuj tiuj eta, eta, eta nombroj denove, kaj denove, kaj denove, vi povas, kiel en lia kazo, fari bonan kvanton de mono. 

Tiu sama ideo estis ŝirita for fare pli freŝa, sed ankoraŭ nun malnovaj filmo, nomita Office Space, kie la uloj en tiu filmo, faris la samon, ŝraŭbas ĝin tute, finis kun vojo tro multe mono en ilia banka konto. Ĉio estis tre suspektema. Sed fine de la tago, imprecision estas ĉirkaŭ ni. 

Kaj, ankaŭ, povas esti timige la kazo. Ĝi rezultas ke Superman 3 kaj Office Space flanken, tie povas esti iu tre reala mondo ramificaciones de la realaĵoj de malpreciza reprezentado de datumoj ke eĉ ni homoj al hodiaux ne bezone kompreni same kiel ni devus, aŭ memori kiel ofte kiel ni devus. Kaj, efektive, la jenaj klipo estas de rigardi iuj tre reala mondo ramificaciones de kio okazas se vi ne estimas la imprecision ke povas okazi en nombroj reprezento. 

[VIDEO reprodukto] 

-Computers, Ni ĉiuj venis akcepti la ofte frustrante problemoj kiuj akompanos them-- cimojn, virusoj, kaj programaro glitches, por malgrandaj prezoj pagi por la oportuneco. Sed en alta teknologio kaj alta rapido milita kaj spaca programo aplikoj, la plej malgranda problemo povas glorata en katastrofo. 

Junio ​​4, 1996, sciencistoj preparita ĵeti senpilotaj Ariane 5 raketo. Ĝi portis sciencajn satelitoj desegnita establi precize kiel la geomagnetiko interagas kun sunaj ventoj. La raketo estis konstruita por la Eŭropa Spaca Agentejo, kaj levis gxin el lia facileco sur la marbordo de Franca Gviano. 

Aýdis pri 37 sekundoj en la flugo, ili unue rimarkis ion iris malĝuste. La toberas estis swiveling en maniero ili vere ne devus. Ĉirkaŭ 40 sekundoj en la flugo, klare, la veturilo estis en premo. 

Kaj tio estas kiam ili faris decido detrui ĝin. La gamo sekureco oficiro, kun terura intestoj, premis la butonon, eksplodigis la raketo, antaŭ ol povis iĝi danĝero por la publika sekureco. 

-tio Cxi estis la knabino vojaĝo de la Ariane 5. Kaj lia detruo prenis meti pro difekto enigita en la raketo programaro. -La Problemo de la Ariane estis ke estas kelkaj kiuj postulata 64 bitojn por esprimi. Kaj ili volis konverti ĝin al 16-bita nombro. Ili supozis ke la nombro neniam iranta esti tre grandaj, ke la plejparto de tiuj ciferoj en 64-bita nombro estis nuloj. Ili eraris. 

-La Nekapablo de unu programaro akcepti la speco de nombro generita per alia estis ĉe la radiko de la fiasko. Softvarigo fariĝis tre peniga parto de nova teknologio. La Ariane raketo estis tre sukcesa, tiel de la programaro kreita por ĝi estis ankaŭ uzita en la Ariane 5. 

-La Baza problemo estis ke la Ariane 5 estis pli rapida, akcelis rapide. Kaj la programaro ne havis konsistigis tion. 

-La Detruo de la raketo Estis grandega financa katastrofo, ĉiuj pro minuto programaro eraro. Sed tio ne estis la unua tempo datumoj konvertiĝo problemoj estis plagita moderna raketo teknologio. 

-En 1991, kun la komenco de la unua Golfa Milito, la Patriot Missile spertis similan specon de nombro konvertiĝo problemo. Kaj kiel rezulto, 28 personoj, 28 usonaj soldatoj, mortis, kaj pri 100 aliaj vundis, kiam la Patriot, kiu estis supozita protekti kontraŭ alvenantaj Scuds, malsukcesis pafi misilo. 

-Kiam Irako invadis Kuvajton kaj Ameriko lanĉis Dezerto Ŝtormo en frua 1991, Patriot misilon piloj estis deplojitaj protekti Saŭda Arabio kaj Israelo de irakaj Scud misilon atakoj. The Patriot estas usona duona atingo surfaco al aero sistemo fabrikita de la Raytheon kompanio. 

-la Grandeco de la Patriot interceptor mem estas pri malglate 20 futojn longa. Kaj ĝi pezas proksimume 2,000 funtojn. Kaj ĝi portas kapon de ĉirkaŭ, Mi kredas ke estas krude 150 funtoj. Kaj la kapo sin estas alta eksploda kiu havas fragmentojn ĉirkaŭe. La carcasa de la kapo estas desegnita por agi kiel Buckshot. 

-La Misiloj estas portitaj kvar po ujo, kaj estas transportitaj per duone trailer. 

-la Patriot kontraŭ misiloj sistemo superas almenaŭ 20 jaroj nun. Ĝi estis origine dizajnita kiel aero defendo misilo pafi malsupren aviadiloj malamikoj. En la unua Golfa Milito, Kiam tiu milito venis kune, la Armeo volis uzi ĝin malkonstrui Scuds, ne aviadilojn. 

La iraka aerarmeo estis ne tiom de problemo. Sed la Armeo estis maltrankviligita Scuds. Kaj tiel ili provis ĝisdatigi la Patriot. 

-Intercepting Malamiko misilo vojaĝante al Mach 5 tuj estos defianta sufiĉas. Sed kiam la Patriot estis fulmtransportita en servon, la Armeo ne estis konscia de Iraka modifo Kreinto ilia Scuds preskaŭ neeble batis. 

-Kio Okazis estas la Scuds ke estis eniranta estis malstabilaj. Ili wobbling. La kialo por tio estis la irakanoj, en ordo akiri 600 kilometroj el 300 kilometro gamo misilo, prenis pezo el la fronto kapo. Ili faris la kapo pli malpeza. 

Do nun la Patriot estas provas veni ĉe la Scud. Kaj plejparto de la tempo, la abrumadora plimulto de la tempo, estus nur flugas per la Scud. Iam la Patriot sistemo operatoroj realigis la Patriot missed lia celo, ili detonado la Patriot la kapo eviti eblajn viktimojn se estis permesita fali al la grundo. 

-Tio Estis kio plej homoj vidis, tiuj grandaj buloj de fajro en la ĉielo, kaj miskomprenita kiel interkaptas de Scud kapoj. 

-Although Nokte ĉieloj, Patriots aperis esti sukcese detruante Scuds, ĉe Dhahran, tie povus esti eraro pri ĝia efikeco. Tie, la Patriota la radaro sistemo miskalkulis venonta Scud, kaj neniam ĵetis pro al programaro difekto. Estis la israelanoj kiuj unue malkovris ke la pli longa la sistemo estis, la pli granda la tempo diferenco igis, pro horloĝo enigita en la sistemo komputilo. 

-About Du semajnoj antaŭe la tragedio en Dhahran, la israelanoj raportoj la Defendo Fako ke la sistemo perdis tempon. Post ĉirkaŭ ok horoj aŭ kurado, ili rimarkis ke la sistemo iĝis rimarkinde malpli precizaj. La Defendo Fako Respondis rakontanta ĉiuj la Patriot pilojn por ne lasi la sistemoj dum longa tempo. Ili neniam diris kio longe was-- ok horoj, 10 horoj, 1.000 horojn. Neniu sciis. 

-la Patriot pilo postenigitaj ĉe la kazerno ĉe Dhahran kaj lia misa interna horloĝo estis sur pli ol 100 horojn sur la nokto de februaro 25a. 

-ĝi Spurita tempo al precizeco de ĉirkaŭ dekono de sekundo. Nun dekono de sekundo Estas interesa nombro, ĉar ĝi ne povas esti esprimita en duuma ekzakte, kion signifas ĝi ne povas esti esprimita akurate en ajna moderna cifereca komputilo. Estas malfacile kredi. 

Sed uzi tion kiel ekzemplon. Ni prenu la nombron unu triono. Triono ne povas esti esprimita en dekuma precize. Triono estas 0,333 okazas por malfinio. 

Ne estas maniero por fari tion kun absoluta precizeco en dekuma. Tio estas ĝuste la speco de problemo kiu okazis en la Patriot. La pli longa la sistemo kuris, la malbona la tempo eraro fariĝis. 

-After 100 horoj da operacio, la eraro en tempo estis nur proksimume triono de sekundo. Sed en terminoj de celado misilo vojaĝante al Mach 5, ĝi rezultis en sekvado eraro de super 600 metroj. Estus fatala eraro por la soldatoj sur kio okazis estas Scud ĵeto estis detektita de frua Averto satelitoj kaj ili sciis ke la Scud estis eniranta ilian ĝeneralan direkton. Ili ne sciis kie venas. 

-ĝi Estis nun ĝis la radaro komponanto de la Patriot sistemo defendanta Dhahran lokalizi kaj teni trako de la venonta malamiko misilo. 

-La Radaro estis tre inteligenta. Estus vere spuri la pozicio de la Scud, kaj tiam antaŭdiri kie probable estus la proksima tempo la radaro sendis premas eksteren. Kiu estis nomata gamo pordego. 

-Then, Tuj la Patriot Decidas sufiĉa tempo havas Pasis reiri kaj kontroli la venonta loko por ĉi detektita objekto, ĝi superas. Do kiam reiris al la malĝusta loko, ĝi tiam vidas neniun objekton. Kaj ĝi decidas ke forestas objekto, ĝi estis falsa detekto, kaj delasas la spuro. 

-La Venonta Scud malaperis de la radaro ekrano. Kaj sekundoj poste, ĝi brufermis en la fortikajxon. La Scud mortigis 28 kaj estis la lasta oni pafis dum la unua Golfa Milito. 

Tragike, la ĝisdatigita programaro alvenis al Dhahran la sekva tago. La programaro difekto estis estis riparita, fermante unu ĉapitro en la tumulta historio de la Patriot misilo. 

[VIDEO reprodukto] DAVID J. Malan: Do tiu estas ĉiuj diri ke tiuj aferoj de troplenigxis kaj imprecision estas ĉiuj tro reala. Do kiel ni alvenos? Ni komencis kun nur parolas printf. Denove, tiu funkcio kiu presas ion al la ekrano, kaj ni enkondukis poste kelkaj aliaj funkcioj de la tn CS50 biblioteko. Kaj ni daŭre vidi tiujn gxustatempe. Kaj ni, precipe, uzata get kordoj, kaj akiri int, kaj nun ankaŭ akiri kaleŝego, kaj ankoraŭ aliaj ankoraŭ ni renkontas kaj uzi nin antaux longe. 

Sed foje, havas ni jam vidis bezonon stoki kion tiuj funkcioj manon? Ili transdoni nin reen ĉenon, aŭ int aŭ kaleŝego. Kaj kelkfoje ni devas meti tiun ŝnuro, aŭ int, aŭ kaleŝego, ie. 

Kaj stoki tion, memoras ĝuste kiel en Scratch, ni havas variabloj. Sed malkiel en Scratch, en C ni havas faktan tipoj de variables-- datumoj tipoj, pli generally-- inter ili, ŝnuro, int, a flosi, kaj tiuj aliaj ankoraŭ. 

Kaj tiel, kiam ni deklari variablojn en C, ni devos deklari nian datumtipoj. Tio ne estas io ni devas fari poste en la semestro kiel ni transiro al aliaj lingvoj. Sed nuntempe, ni bezonas al priori anticipe, klarigi al la komputilo kion tipo de ŝanĝiĝema ni volas doni al ni. 

Nun dume, por presi tiuj specoj de datumtipoj, ni devas diri printf kion atendi. Kaj ni vidis procento s por kordoj, kaj procento i por entjeroj, kaj kelkaj aliaj jam. Kaj tiuj estas simple postuloj por la vida prezento de tiu informo. 

Kaj ĉiu el tiuj povas fakte esti parametrigita aŭ tweaked iel, se vi volas progresigi kontrolo la tipo de produktado kiu vi ricevas. Kaj, fakte, ĝi rezultas ke ne nur estas tie backslash n por nova linio. Estas io alia nomita backslash r por tirilo, kiu estas pli parenca al malnova lernejo tajpilon, kaj ankaŭ Vindozo uzita por multaj jaroj. 

Ekzistas backslash t por langetoj. Rezultas, ke se vi volas duobla citaĵo ene de kordo, revokon, ke ni uzis citilon duobla citaĵo maldekstre kaj dekstre finas de nia kordoj tiom. Kiu ŝajnas konfuzi aferoj. 

Se vi volas meti citilon en la mezo de ĉenon kaj ja ĝi estas konfuza vidi. Kaj tial vi devas eskapi, do al paroli, duobla citaĵo kun io kiel, laŭvorte, backslash citilon. Kaj estas kelkaj aliaj ankoraŭ. Kaj ni vidos pli de tiuj en fakta uzo antaŭ longe. 

Do ni nun transiro de datumoj, kaj reprezento, kaj aritmetikaj operatoroj, ĉiuj kio donis al ni konstruaĵo blokoj kun kiu ludi. Sed nun ni vere donas ni la reston de la vortaro ke ni jam havis lasta semajno kun Scratch prenante rigardu alian konstrukcioj en C-- ne ĉiuj. Sed la ideoj ni pri vidi vere nur elstari la traduko de unu lingvo Scratch, por alia, C. 

Kaj dum tempo, ni reprenos pli iloj por nia ilaro, tiel diri, sintakse. Kaj, efektive, vi vidos ke la ideoj nun iom familiara de lasta semajno. Do ni faru ĉi. 

Ni iru antaŭen kaj vipi programon kiu fakte uzas iuj esprimoj, Bulea esprimo. Lasu min antaŭeniri tie kaj krei novan dosieron. Mi vokos ĉi condition.c. 

Lasu min antaŭeniri kaj inkluzivas la CS50 biblioteko. Kaj lasu min antaŭeniri kaj inkluzivi norma io.h por niaj funkcioj, kaj printf, kaj pli respektive. Mi donos al mi mem ke kutimaĵo de int ĉefa malplenon, kies klarigo ni revenu al la estonteco. 

Nun lasu min antaŭeniri kaj doni mi int tra get int. Tiam lasu min antaŭeniri kaj fari tion. Mi volas diri, se mi estas less-- ni distingi inter pozitiva, negativa, aŭ nul valoroj. 

Do se mi estas malpli ol nulo, mi nur havas tiu programo simple diri, negativa, backslash n, alie se i estas pli granda ol nulo. Nun mi kompreneble volis diri printf pozitiva, backslash n. Kaj tiam alia if-- mi povus fari tion. 

Mi povus fari se i egalas 0. Sed mi konvinkos je Almenaŭ unu eraro jam. Memoru ke la egalsigno estas ne egalaj, kiel ni homoj scias ĝin. 

Sed estas la asigno operatoro. Kaj ni ne volas preni 0 sur la dekstra kaj metis ĝin en I maldekstre. Tiel eviti tiun konfuzon, aŭ eble misuzo de la egala signo, homoj decidis iuj jaroj ke en multaj programlingvoj kiam vi volas kontroli egaleco inter la maldekstra kaj la dekstra, vi efektive uzas egalas egaluloj. Do vi frapis la egala signo dufoje. Kiam vi deziras asigni de dekstra al maldekstra, vi uzas solan egala signo. Do ni povus fari this-- alian se i egalas egalas nulo. 

Mi povus tiam iru malfermu miajn krispa krampoj, kaj diru: printf 0, backslash n, farita. Sed memoru kiom tiuj forkoj en la vojo povas labori. Kaj, efektive, nur pensas pri la logiko. i estas nombro. Ĝi estas entjero, specife. Kaj tio signifas ke tuj estos malpli ol 0, aŭ pli granda ol 0, aŭ 0. Do tie estas ia tiu implicita defaŭlta kazo. 

Kaj tiel ni povus, ĵus ŝatas Nulo, malhavi la alian se, kaj simple diri alie. Logike, se vi programisto scias ke estas nur tri siteloj en kiujn oni scenaro povas fall-- la unua, la dua, aŭ tria en ĉi case-- ne ĝeni aldonante plian precizecon kaj la plia logiko tie. Nur antaŭeniri kun la defaŭlta kazo tie de alia. 

Nun, ni iru antaŭen post savi tion, faru kondiĉoj dot oblikvo conditions-- Ne granda uzantinterfaco, ĉar mi ne instigante la uzanto, kiel mi menciis antaŭe. Sed tio estas bone. Ni observu ĝin simpla. Ni provu la numero 42. Kaj tio estas pozitiva. Ni provu la nombro negativa 42, negativa. 

Ni provu la valoro 0. Kaj, efektive, ĝi funkcias. Nun vi vidos kun problemoj antaŭe longaj, testado aferoj trifoje, probable ne sufiĉa. Vi probable volas testi iuj grandaj nombroj, iuj malgrandaj nombroj, iu angulo kazoj, kiel ni venis por priskribi ilin. 

Sed nuntempe, tiu estas sufiĉe simpla programo. Kaj mi estas certa, logike, ke ĝi falas en tri kazoj. Kaj cetere, eĉ se ni nur temigis la potencialon downsides de imprecision rapide, en realaĵo kie multaj el CS50 la problemojn, ni ne tuj maltrankviliĝu pri la tuta tempo, tiuj aferoj de overflow kaj imprecision, ĉar, fakte, en C, ĝi estas fakte ne tiom facile eviti tion. Se vi volas rakonti ĝis granda kaj pli granda, kaj pli granda, rezultas ekzistas teknikoj vi povas uzi, ofte engaĝante aferoj alvokis bibliotekoj, kolektoj de kodo, ke aliaj homoj skribis ke vi povas uzi, kaj aliaj lingvoj kiel Java kaj aliaj, reale fari ĝin multe pli facile kalkuli eĉ pli altaj. Do ĝi vere estas iuj de ĉi tiuj danĝeroj funkcio de la lingvo vi uzas. Kaj en la venontaj semajnoj, ni instruos vin vidu kiom danĝeraj C vere povas esti se vi ne uzas ĝin taŭge. Sed de tie, kaj kun Python, kaj JavaScript, estos ni mantelo sur kelkaj aldonaj protektoj, kaj kuri pli malmultaj de tiuj riskoj. 

Do ni faras iom pli Interesa logiko en nia programo. Do lasu min antaŭeniri kaj krei programo nomata Logika nur do mi povas ludi kun iu fakta logiko, logical.c. Mi nur kopiu kaj algluu iun kodo de antaŭaj do mi reiros al tiu bela deirpunkto. 

Lasu min ĉi tempo faras char C. mi tuj donu al li nomon de C nur ĉar ĝi estas konvencia, akiri karaktero de la uzanto. Kaj ni ŝajnigi kiel Mi efektivigado parto de tiu Rm programo, la forigu programo antaŭ tio instigis la uzanto forigi dosieron. Kiel ni faru tion? 

Mi volas diri, se C egalas egaluloj, citaĵo unquote, y, tiam mi tuj supozi ke la uzanto elektis jes. Mi simple tuj presi jes. Se ĝi reale skribi la forigo programo, ni povus forigi la dosieron kun pli linioj de kodo. Sed ni observu ĝin simpla. 

Alie se c egalas egalas n-- kaj nun ĉi tie, mi tuj diru, la uzanto devas esti signifita ne. Kaj tiam alian, vi scias kion? Mi ne scias kion alian la uzanto tuj tajpi. Do mi simple volis diri ke ke estas eraro, kio ajn li aŭ ŝi vere tajpita. 

Do kio okazas ĉi tie? Estas fundamenta diferenco kontre kion mi faris en la pasinteco. Citiloj, citiloj, duobla citiloj, kaj, tamen, unuopaj citiloj, sola citaĵoj. Rezultas en C, ke kiam vi volas skribi kordo, vi uzas duoblan citaĵoj, samkiel ni havas estis uzante ĉiu ĉi tiu tempo kun printf. 

Sed se vi volas pritrakti nur sola karaktero, tn char, tiam vi efektive uzas solan citaĵoj. Tiuj el vi kiuj jam programita antaŭe, vi eble ne havas devis zorgi pri tio distingo en iuj lingvoj. En C, gravas. Kaj tiel, kiam mi akiras char kaj mi volas kompari ke char uzante egaluloj egalas al iu letero kiel y aŭ n, mi faros, ja devas havi la solan citaĵoj. 

Nun, ni iru antaŭen kaj fari tion. Ni iru antaŭen kaj ja faras logika dot oblikvo logika. Kaj nun mi estanta instigita. Do, supozeble, pli bona uzanto sperto estus vere diri al mi kion fari tie. Sed mi tuj nur blinde diru y por jes, bone, agrable. 

Ni ruli ĝin denove, n por neniu, bela. Supozu kiel iuj homoj mi scias, mia ĉapojn ŝlosi ŝlosilo estas en ĉiuj tro ofte. Tial Mi faros ĉefurbo Y, eniri, eraro. OK, ne precize kion mi atendis. Efektive, la komputilo faras laŭvorte kion Mi rakontis al do-- kontroli minuskla y kaj minuskla n. Ĉi tio ne sentas bone uzanto sperto, tamen. Lasu min peti kaj akcepti ĉu minuskla aŭ majuskla. Do rezultas, Vi povus deziri diri ion kiel en Scratch, kiel laŭvorte aŭ C egalas egalas ĉefurbo sola citata kaj. Rezultas, C ne havas tiu laŭvorta ŝlosilvorto aŭ. 

Sed ĝi havas du vertikalaj stangoj. Vi devi teni Shift kutime, se vi uzas usonan klavaron, kaj batis la vertikala baro ŝlosilo super via reveno ŝlosilon. Sed tiu vertikala breto vertikala stango signifas aŭ. 

Se, kontraste, ni volis diri kaj, kiel en Scratch, ni povus fari ampersand kaj-signo. Kiu faras neniun logikan sencon tie, ĉar homa povis eble tajpis ambaŭ y kaj minuskla y kaj ĉefurbo Y kiel la sama karaktero. Tiel aŭ tion ni intencas ĉi tie. 

Do se mi faras tion en ambaŭ lokoj, aŭ c egalas egalas ĉefurbo N, nun rerun, faras logikan, rerun logika. Nun, mi povas tajpi y. Kaj mi povas fari ĝin denove kun ĉefurbo Y, aŭ ĉefurbo N. Kaj mi povis aldoni en aldona kombinaĵoj ankoraŭ. 

Do tiu estas logika programo mezuro nun Mi kontrolas logike por tiu valoro aŭ tiun valoron. Kaj mi ne devas, nepre, supreniru kun du pli oj aŭ alia oj. Mi povas reale kombini iuj de la rilata logiko kune tiamaniere. Do tiu estus bona desegnita ol simple dirante: Se C egalas minuskloj y, presi jes, alie se c egalas ĉefurbo Y, presi jes, alie se c egalas lower-- alivorte, vi ne devas havi pli kaj pli branĉoj. Vi povas kombini iuj de la ekvivalenta branĉoj logike, kiel en ĉi tiu vojo. 

Do ni rigardu nur fina ingredienco, unu fina konstruo, ke C permesas. Kaj ni revenos en la estonteco al aliaj ankoraŭ. Kaj tiam ni konkludi per rigardado ĉe ne la ĝusteco de code-- atingi kodo work-- sed la dezajno de kodo, kaj plantos tiuj semoj frue. 

Do lasu min antaŭeniri kaj malfermi novan dosieron ĉi tie. Vi scias kion? Mi tuj re-apliki tiu sama programo, sed uzante malsama konstruo. 

Do mi rapide doni min aliro al inkluzivi CS50.h por la CS50 biblioteko, norma io.h por printf. Donu miajn int ĉefa malplenon. Kaj tiam super tie, lasu min antaŭeniri kaj fari tion. 

Char c ricevas akiri char, kiel antaŭe. Kaj mi tuj uzos nova konstruo now-- alti, sur kio karakteron? Do ŝaltilo estas ia kiel ŝaltanta trajno trakoj. Aŭ, vere, ĝi estas speco de kiel se alie, se alie se, sed skribita iom alimaniere. 

Ŝaltilo aspektas jene. Vi havas ŝaltilon, kaj tiam kion karaktero aŭ nombro vi volas rigardi, tiam iuj buklaj krampoj ŝatas en Nulo, nur diru tion aĵoj. Kaj tiam vi havos malsamajn kazojn. 

Vi ne uzas se kaj alie. Vi laŭvorte uzi la vorton tiel. Kaj vi dirus ion kiel tiu. 

Tiel en la kazo de minusklan y, aŭ en la kazo de majuskla Y, antaŭeniri kaj presi jes. Kaj tiam rompi la ŝaltilon. Jen ĝi. Ni faris. 

Alie se, por tiel diri, minuskla n, aŭ ĉefurbo N, tiam iru antaŭen kaj presita el neniu, kaj tiam rompu. Else-- kaj tian estas la defaŭlta kazo indeed-- printf error-- kaj nur por bonan mezuron, kvankam logike ĉi paŭzo ne estas necesa ĉar ni fine de la ŝaltilo ĉiuokaze, Mi nun elrompanta de la ŝaltilo. Do tio aspektas iom malsama. 

Sed, logike, ĝi estas fakte ekvivalenta. Kaj kial vi uzas unu super la alia? Kelkfoje, nur persona prefero, kelkfoje la estetiko, se mi rigardis tiun nun estas io diri al la legeblecon de tiu kodo. Mi volas diri, ne gravas la fakto ke ĉi poŝtkodo estas nova al multaj el ni en la ĉambro. 

Sed nur ia estas bela. Komprenu minuskla y, ĉefurbo Y, minuskla n, ĉefurbo N defaŭlta, ĝi nur speco de saltoj ĉe vi en vojo ke, eble, eble la antaŭa ekzemplo kun la oj, kaj la vertikalaj stangoj, kaj la alia oj, eble ne havas. Do tiu estas vere afero de persona elekto, vere, aŭ legeblecon, de la kodo. 

Sed en terminoj de funcionalidad, lasu min antaŭeniri kaj fari ŝaltilon, dot oblikvo ŝaltilo, kaj nun tajpas minuskle y, ĉefurbo Y, minuskla n, ĉefurbo N, David, reprovi ĉar tio ne sola karaktero. Ni faru x, eraro, kiel atendita. Kaj, logically-- kaj tio estas io Mi kuraĝigus en general-- eĉ kvankam ni nur gratante la surfaco de iuj de ĉi tiuj karakterizaĵoj. 

Kaj ĝi povus ne esti evidentaj kiam mem sidiĝi ĉe la klavaro, kiel tio funkcias? Kion tio do? La bela afero pri havanta tekkomputilo aŭ surtabla aŭ aliro al komputilo per tradukilo, kaj kun kodo redaktoro kiel tiu, Estas vi povas preskaŭ ĉiam respondi tiujn demandoj mem nur provanta. 

Ekzemple, se la retorika demando ĉe mano estis, kio okazas se vi forgesu via paŭzo deklaroj? Kiu estas fakte tre komuna afero por fari, ĉar ĝi ne aspektas kiel vi vere bezonas ilin. Ne vere kompletigi viajn pensis kiel paréntesis aŭ krispa stegon faras. Ni iru antaŭen kaj rekompili la kodon kaj vidi. Tiel faro ŝaltilo, dot oblikvo ŝaltilo. Ni entajpu minuskloj y, la supro kazo, Enter. Do mi tajpas kaj. 

La programo diris jes, ne, eraro, kvazaŭ ĝi ŝanĝas lian menson. Sed ia estis, ĉar kio okazas kun ŝaltilo estas la unua kazo ke matĉo esence signifas, hey komputilo, ekzekuti la kodon sub ĝi. Kaj se vi ne diras paŭzo, aŭ Ne diru paŭzo aŭ ne diras paŭzo, la komputilo tuj blovis tra ĉiuj tiuj linioj kaj ekzekuti ĉiujn ilin ĝis ĝi alvenas al tiu krispa krampoj. Tiel la bremsoj estas ja necese. Sed takeaway tie estas, kiam en dubo, provu ion. Eble savi vian kodon unua, aŭ savi ĝin en ekstra dosieron Se vi estas vere maltrankviligita rompado kaj devi reakiri la laboro ke vi sciu laboras. 

Sed provu aferoj. Kaj ne kiel timema, eble, de kio la komputilo povus fari, aŭ ke vi povus rompi ion. Vi povas ĉiam restarigu reen al iu pli frua versio. 

Do ni finos per rigardado en la dezajno de kodo. Ni havas tiun kapablon jam skribi kondiĉoj, kaj registran masxojn, kaj variabloj kaj alvoko funkciojn. Do, sincere, ni ia reen ĉe kie ni estis antaŭ unu semajno kun Scratch, kvankam kun malpli konvinka teksta medio ol Scratch permesas. 

Sed rimarki kiom rapide ni akiris ke vortprovizon, eĉ se ĝi estas tuj prenos iom da tempo por enprofundigi en, tiel ke ni nun povas uzi tiun vortaron skribi pli interesaj programoj. Kaj ni prenu bebo paŝo al tiu, kiel sekvas. Lasu min antaŭeniri kaj krei novan dosieron ĉi tie. 

Mi tuj nomas tiun prototype.c kaj enkonduki unuafoje, la kapablo fari vian propran funkcioj. Kelkaj el vi eble havas farinte per Scratch, per kiu vi povas krei vian propra kutimo blokoj en Scratch, kaj tiam treni ilin en lokon kien ajn vi volas en C. Kaj en plej programado lingvoj, vi povas fari ĝuste that-- fari viajn proprajn funkciojn, se ili ne jam ekzistas. 

Do, ekzemple, lasu min antaŭeniri kaj inkluzivi CS50.h kaj inkluzivi norma io.h, int ĉefa malplenon. Nun ni havas lokokupilo preta iri. Mi daŭre pres aferoj kiel popola nomoj hodiaŭ. Kaj kiu sentas like-- ne estus bela se estis funkcio nomita print nomo? Mi ne devas uzi printf. Mi ne devas memori ĉiuj formato kodoj. Kial ne, aŭ kial ne iu antaŭ mi, krei funkcio nomita print nomo, kiuj donas iun nomon, simple presas gxin? 

Alivorte, se mi diras, hey, komputilo, donu al mi ĉenon Petante la uzanto por tia, tra CS50 akiri string funkcio. Hej, komputilo, metis tiun ĉenon en la variablo en la maldekstra flanko, kaj nomas ĝin s. Kaj tiam, hey komputilo, antaŭeniri kaj presi ke persono nomo, faritaj. 

Nun, estus bela, ĉar tiu programo, trafe nomita, diras al mi kio ĝi estas supozita fari tra tiuj funkciaj nomoj. Mi volas iri kaj fari prototipo, Enter. Kaj, bedaŭrinde, ĉi tio ne tuj flugos. 

Prototype.c, linio 7, karaktero 5, eraro, implicita deklaro de funkcio print nomo estas nevalida en C99, C99 Signifanta versio de C kiu eliris en 1999. Tio estas ĉio. 

Do mi ne scias kio ĉio ĉi signifas ankoraŭ. Sed mi faras rekoni eraron en ruĝa. Tio estas sufiĉe evidentaj. 

Kaj ĝi similas ke kun verdan karakteron tie, la afero estas kun presitaj nomo, malferma paren s, proksime paren, duon-dupunkto. Sed implica deklaro de funkcio ni vidis mallonge antaŭe. Tio signifas, simple, ke Clang ne scias, kion mi volas diri. 

Mi uzis vortaron vorto ke ĝi estas neniam vidita aŭ instruis antaŭe. Do mi devas instrui gxin kion tiu funkcio signifas. Do mi tuj iros antaŭen kaj fari tion. 

Mi tuj iros antaŭen kaj apliki mia propra funkcio nomita Presi Nomo. Kaj mi tuj diros, kiel sekvas, ke ĝi faras tion, printf, saluton, procento s, backslash n, nomo, duon-dupunkto. Do kion mi ĵus faris? 

Do rezultas, al apliki vian propran funkcion, ni ia deprunti kelkaj la sama strukturo kiel ĉefa ke ni ĵus estis memkompreneble, kaj mi scias kopii kaj alglui preskaux kia Mi estis skribanta en la pasinteco. Sed rimarki la mastro tie. Int, Ĉefa, Void, ni turmentus aparte antaŭ longe kion tio vere signifas. 

Sed por hodiaŭ, nur rimarki la paralelismo. Void, presita nomo: string nomo, do ekzistas purpura ŝlosilvorto, kiun ni tuj komencos nomante reveno tipo, la nomon de la funkcio, kaj tiam la enigo. Do, fakte, ni povas distili tiu speco de kiel lasta semajno kiel, tiu estas la nomo aŭ la Algoritmo de la kodo ni tuj write-- la algoritmo subkuŝanta la kodo ni tuj skribos. 

Jen ĝia enigo. Tiu estas sian produktadon. Tiun funkcion, presita nomo, estas desegnita preni ŝnuro nomita nomo, aŭ kio ajn, kiel enigo, kaj tiam malplena. Ĝi ne revenas ion, kiel akiri string aŭ akiri int faras. Tial ĝi tuj donu al mi ion reen. Ĝi simple tuj havi kromefikon, por tiel diri, videbligi la nomon de persono. Do rimarki, linio 7, mi povas voki print nomo. Linio 10, mi povas difini aŭ apliki print nomo. Sed, bedaŭrinde, tio ne sufiĉas. 

Lasu min antaŭeniri kaj rekompili tiu post savi. Halt, nun, mi faris ĝin malbona, ĝi similus. Tiel implica deklaro de funkcio print nomo estas malvalida. Kaj, denove, estas pli eraroj. Sed mi avertis antaŭe, eĉ se vi ricevas superŝutita per, aŭ iom malĝoja vidi tiom da eraroj, enfokusigi nur sur la unua komence, ĉar eble nur havis kaskadan efikon. Do C, aŭ Clang pli specife, ankoraŭ ne rekonas print nomo. 

Kaj tio estas ĉar Clang, projekte, estas speco de mutaj. Ĝi nur faras kion vi diros al li fari. Kaj ĝi nur faras en la ordo en kiu vi diras ĝin fari. 

Do mi difinis ĉefa sur linio kvar, kiel ni estis farante sufiĉe ofte. Mi difinis print nomon sur linio 10. Sed mi provas uzi print nomon sur linio sep. 

Ĝi estas tro frue, ne ekzistanta. Do mi povus esti lerta kaj esti kiel, Bone, do ni nur ludas kune, kaj movi print nomon supren tie kaj re-kompili. Ho mia Dio. Funkciis. Estis tiel simpla kiel tiu. 

Sed la logiko estas ĝuste tio. Vi devas instrui Clang kion estas per difinanta la funkcio unue. Tiam vi povas uzi ĝin. Sed, sincere, tiu sentas kiel glitiga deklivo. 

Do ĉiufoje mi kuros en problemo, mi estas nur tuj elstaros kaj kopii la kodon Mi skribis, detrancxu gxin kaj gluu ĝin tie. Kaj, verŝajne, ni povis aranĝi kelkaj scenaroj kie funkcio povus bezonas voki alian. Kaj vi simple ne povas meti ĉiun funkcio super ĉiu alia. 

Do rezultas ke la pli bona solvo. Ni povas lasi tiun estu. Kaj, sincere, ĝi estas ĝenerale agrabla, kaj oportuna, kaj bona dezajno meti ĉefa unua, ĉar, denove, ĉefa ĝuste kiel kiam verda flago clicked, kiu estas la funkcio kiu gets ekzekutita defaŭlte. Do vi povus same meti cxe la supro de la dosiero tiel ke kiam vi aŭ iu ajn aliaj homaj rigardas la dosieron vi scias kio okazas nur legante ĉefa unue. Do rezultas ni povas diri Clang proactively, hej, Clang, sur linio kvar, Mi promesas implementar funkcio nomita Presi Nomo kiu prenas ŝnuro nomita nomon kiel enigo, kaj revenas nenion, malplenon. Kaj mi ricevos ĉirkaŭ al efektiviganta ĝin poste. 

Jen venas Ĉefaj. Ĉefa nun linio 9 povas uzi Print Nomo ĉar Clang estas konfidita ke, eventuale, ĝi renkontas la difinon de la efektivigo de Presi Nomo. Do post savi mian dosieron, lasu min antaŭeniri kaj fari prototipo, aspektas bone ĉi tiu tempo. Dot oblikvo, prototipo, lasu min antaŭeniri kaj tajpu en nomo. David Saluton David Zamila Saluton Zamila kaj ja nun funkcias. 

Tial la ingredienco estas, ke ni havas faris kutimo funkcio, kiel kutimo Nulo bloko ni vokas ĝin. Sed kontraste Scratch, kie vi povas simple kreu ĝin kaj komenci uzi ĝin, nun ni devas esti iom pli pedanta, kaj fakte trejni Clang uzi, aŭ atendi ŝin. Nun, kiel flanken, kial ĉiuj ĉi tempo havi Ni estis nur blinde sur fido inkluzive CS50.h kaj inkluzive normo io.h? 

Nu, tio rezultas, inter kelkaj aliaj aferoj, ĉiuj jen en tiuj punktoj h dosierojn, kiuj hazarde estas dosierojn. Ili header dosierojn, tiel diri. Ili ankoraŭ skribita en C. Sed ili estas malsama tipo de dosiero. 

Nuntempe, Vi povas sufiĉe multe supozi cxio, kio estas interne de CS50.h Estas kelkaj unu-ekskursoŝipoj kiel tiu, ne por funkcioj nomitaj Presi Nomo: sed por Get String, Akiri Kaleŝego, kaj kelkaj aliaj. Kaj ekzistas simila prototipoj, unu ekskursoŝipoj, ene de norma io.h por printf, kiu estas nun en mia propra Presi Nomo funkcio. Do alivorte, tiu tuta tempo ni havas ĵus blinde kopii kaj alglui inkluzivas tion, inkluzivi ke, kio okazas? Tiuj estas nur speco de postsignoj por Clang, kion funkcioj estas ja implementado, ĵus aliloke en malsamaj dosieroj aliloke sur la sistemo. 

Do ni implementado print nomo. Ĝi ja havas ĉi kromefikon de presi iun sur la ekrano. Sed ne reale transdoni al mi ion reen. Kiel ni iras sur efektiviganta programon kiu ne transdonu min ion? 

Nu, ni provu tion. Lasu min antaŭeniri kaj realigi dosiero nomata return.c tiel ni povas montri kiel ion kiel Get String aŭ Get Mez, Estas vere reveni ion reen al la uzanto. Ni iru antaŭen kaj difini int ĉefa malplenon. 

Kaj, denove, en la estonteco, ni instruos vin klarigi kion tio int kaj ke malplena fakte faras. Sed por hodiaŭ, ni instruos vin preni por donita. Mi tuj iros antaŭen kaj printf, por bona uzanta sperto, x estas. Kaj tiam mi iros atendi la uzanto doni al mi x kun get int. 

Kaj tiam mi iros por antaŭeniri kaj presi x al la kvadrato. Do kiam vi nur havas klavaro, homoj ofte uzi la malgranda karoto simbolo sur la klavaro reprezenti la povon de, aŭ la eksponento de. Do x kvadrato ĉeestas i. 

Kaj nun mi faros tion. Mi povis nur do-- kio estas x kvadrato? x kvadratoj estas x fojojn x. 

Kaj ni faris tiun iuj tempo jam hodiaŭ. Tio ne sentas kiel ĉiuj ke multe progreso. Vi scias kion? Ni utiligi iom de tiu ideo de lasta momento de abstracción. 

Ĉu ne estus bela se ekzistas funkcio vokis kvadrato kiu faras ĝuste tion? Ankoraŭ, fine de la tago, faras la saman matematiko. Sed ni abstrakta for la ideon de preno unu nombro multiplikita per alia, kaj simple doni al li nomon, kiel akordis tiun valoron. 

Kaj, en aliaj vortoj, en C, ni kreos funkcio nomita kvadrato kiu faras ĝuste tion. Ĝi tuj estos nomita kvadrato. Ĝi tuj preni int. Kaj ni volas nur nomas ĝin n, defaŭlte. 

Sed ni povus nomi ion ni volas. Kaj cxio, kion ĝi tuj do, laŭvorte, estas reveno la rezulto de n × n. Sed ĉar ĝi estas reveninte io, kio estas la ŝlosilvorto en purpuro ni havas neniam antaŭe vidis, mi, sur linio 11, ne povas simple diri malplenon tiu tempo. 

Malplenon, en la ekzemplo ĵus vidis prefere el presaĵo nomo, simple signifas, fari ion. Sed ne transdonu min ion. En tiu kazo, mi volas reveni n × n, aŭ kio ajn tio estas, ke nombro. 

Do mi ne povas diri, hej, Komputilo, Mi revenos nenio, malpleno. Ĝi tuj revenos, nature, int. Kaj do tio estas ĉio, kion okazas tie. 

La enigo akordi tuj esti int. Kaj por ke ni povas uzi ĝin, ĝi devas havas nomon, N. Ĝi tuj eligo int kiu ne bezonas nomon. Ni povas lasi gxin al ĉefa, aŭ kiu ajn estas uzante mi memoras tiun valoron se ni volas kun lia propra ŝanĝiĝema. 

Kaj, denove, la nura nova ŝlosilvorto jen Reveno. Kaj mi simple faranta iun math. Se mi vere volis esti nenecesa, Mi povus diri int produkto ricevas n × n. 

Kaj tiam mi povus diri, reveni produkto. Sed, denove, al mia punkto pli frue de ĉi nur ne esti bona design-- kiel, kial enkonduki nomon simbolo, kiel produkto, nur tuj revenos ĝin? Ĝi estas iom purigisto, iom pli strikta, tiel paroli, nur diri reveno n fojoj n, forigi tiun linion entute. 

Kaj estas simple malpli kodon por legi, malpli ŝancon por eraroj. Kaj ni vidu, se ĉi fakte nun laboras. Nun, mi tuj iros antaŭen kaj fari reveni. 

Uh-oh, implica deklaro de funkcio. Mi faris tiun eraron antaŭe, neniu granda interkonsento. Lasu min nur tajpi, aŭ reliefigi kaj kopii, la ĝusta sama funkcio prototipo, aŭ signumo, de la funkcio ĝis tie. Aŭ mi povis movi la tuta funkcio. 

Sed tio estas iom pigra. Do ni ne faros tion. Nun mi faras revenon denove, dot oblikvo reveno. 

x 2. x kvadrato estas 4. x 3. x kvadrato estas 9. Kaj la funkcio ŝajnas nun esti laborante. Do kio estas la diferenco ĉi tie? Mi havas funkcion kiu nomiĝas kvadrato, en tiu kazo, kiun mi metis en enigaĵoj. Kaj mi reiros eliro. Tamen, antaŭe, se Mi malfermos la alia ekzemplo de antaŭe, kiu Estis nomita prototype.c, Mi havis print nomon, revenis malplena, por tiel diri, Aŭ revenis nenion, kaj simple havis kromefikon. 

Do kio okazas ĉi tie? Nu, konsideru la funkcio akiri string por nur momento. Ni uzis la funkcio akiri string en la sekvanta maniero. 

Ni havis funkcion akiri ŝnuro, kiel inkluzivi CS50.h, inkludas normon io.h, int, ĉefa, malplenon. Kaj tiam ĉiu tempo mi havas vokis get kordoj kaj tiel ege, Mi diris ion kiel, kordo s ricevas akiri string, ĉar get ĉenon ni nomas ĉi get.c-- akiri string mem revenas kordo ke mi povas tiam uzi, kaj diri, saluton, komo, procento s, backslash n, s. 

Do tiu estas la sama ekzemplo, vere, ke ni havis antaŭe. Tiel akiri string resendas valoron. Sed antaŭ momento, presi ĉenon ne resendas valoro. Ĝi simple havas kromefikon. Do tiu estas fundamenta diferenco. Ni vidis malsamajn tipoj de funkcioj nun, iuj de kiuj revenis valorojn, iuj el kiuj ne. Do eble estas ŝnuro, aŭ int, aŭ kaleŝego. Aŭ eble ĝi estas nur malplena. 

Kaj la diferenco estas ke tiuj funkcioj kiuj akiri datumojn kaj resendas valoro estas fakte alportante ion reen al la tablo, por tiel diri. Do ni iru antaŭen kaj rigardi unu fina aro de ekzemploj kiuj donas senton, nun, de kiel ni povus ja abstrakta bona, kaj bona, kaj bona, aŭ pli, kaj pli, kaj pli, por skribi, finfine, bona kodo. Ni iru antaŭen kaj en la spirito de Scratch, faru la sekvajn. 

Lasu min antaŭeniri kaj inkluzivi CS50.h kaj norma io.h. Lasu min antaŭeniri kaj doni mi int, ĉefa, malplenon. Kaj lasu min antaŭeniri, nomas tiun cough.c. 

Kaj lasu min antaŭeniri kaj ĵus kiel Scratch, presi tuso / n. Kaj mi volas fari tion trifoje. Do mi kompreneble nur iranta kopii kaj alglui trifoje. Mi nun tuj faros tusi dot oblikvo tuso. Ni donu min iom pli ĉambron tie, Enter, tuso, tuso, tuso. 

Ekzistas, evidente, jam ŝanco por plibonigo. Mi kopiis kaj almetita kelkajn fojojn hodiaŭ. Sed tio estis nur tiel mi ne devas tajpi kiel multaj karakteroj. Mi ankoraŭ ŝanĝis kion tiuj linioj de kodo estas. 

Tiuj tri linioj estas identaj, kiuj sentas mallaborema kaj ja estas, kaj estas verŝajne ne la ĝusta alproksimiĝo. Do per kio ingredienco ni povus plibonigi tiun kodon? Ni ne devas kopii kaj almeti kodo. 

Kaj, efektive, ajna tempo vi sentas mem kopii kaj glui, kaj eĉ ŝanĝi kodo, probablecoj estas ke estas pli bona vojo. Kaj ja ekzistas. Lasu min antaŭeniri kaj faru por ciklo, kvankam la sintakso ne fariĝu veni nature ankoraŭ. 

Ĉu tio tri fojojn, simple farante la following-- kaj mi hazarde scias tion de praktiko. Sed ni havas kelkajn ekzemplojn nun. Kaj vi vidos rete pli referencoj ankoraŭ. 

Jen la sintakso de la linio 6, ke multe kiel Scratch kiu ripetas bloko, ripeti la sekvajn tri fojojn. Estas iom magia momento. Sed tiu ricevos pli, kaj pli familiara. 

Kaj ĝi tuj ripetos linio ok trifoje, tiel ke se mi re-kompili konsiston tuso, dot oblikvo tuso, tuso, tuso, tuso. Ĝi ankoraŭ funkcias same. Do jen ĉio bone kaj bona. Sed tio ne estas tre distrita. 

Ĝi estas perfekte ĝusta. Sed sentas tie povus esti ŝanco, kiel en la mondo de Nulo, al speco de komenco aldoni iun semantiko tie por ke Ne nur havas iom por ciklo, kaj funkcio kiu diras tusi, aŭ ne tusi. Vi scias kion? Mi provu esti iom malvarmeta ol tiu, kaj fakte skribi funkcion kiu havas iuj kromefikoj, voku lin tusi. 

Kaj ĝi prenas neniun enigo, kaj Revenas neniu valoro kiel eligo. Sed vi scias, kion ĝi faras? Jes this-- printf, citaĵo unquote, tusi. 

Kaj nun ĉi tien, mi tuj iri antaŭen kaj por int, i ricevas nulon, i malpli ol 3, i plus plus. Mi tuj fari printf, kiu estas eble malalta nivelo efektivigo detalon. Ne gravas kiom tusi. Mi nur volas uzi la tuso funkcio. Kaj mi simple tuj voki tuso. 

Nun, rimarki la dicotomía. Kiam vi nomas funkcio, se vi ne volas doni ĝin enigoj, tute bone. Nur faru malfermita paren, proksime paren, kaj vi faris. 

Kiam vi difinas funkcion, aŭ deklari funkcia prototipo, se vi scias anticipe ĝi ne tuj prenos neniun argumentojn, diru malplenon en tiuj krampoj tie. Kaj kiu faras certaj ke vi ne akcidente misuzas ĝin. Lasu min antaŭeniri kaj fari tuso. Kaj, kompreneble, mi eraris. 

Dammit, ekzistas tiu implicitan deklaron. Sed tio estas bone. Estas facila solvon. Mi nur bezonas la prototipo pli alte en mia dosiero ol mi fakte uzas ĝin. 

Do nun lasu min fari tuso denove bela. Nun ĝi funkcias. Fari tuso, tuso, tuso, tuso. Do vi eble pensas ke ni estas vere nur super inĝenierio tiun problemon. Kaj cetere, ni estas. Tio ne estas bona kandidato de programo ĉe la momento por refactorización kaj faras kio estas nomita hierarkia putriĝo, kie vi prenas iun kodon, kaj poste vi ia faktoro aferojn, tiel kiel atribui pli semantiko por ili, kaj reuzi gxin finfine plu termino. Sed estas konstruaĵo bloko al pli kompleksaj programoj ke ni komencos skribado antaŭ longe ke permesas al ni havi la vortprovizon kun kiu skribi pli kodo. Kaj, efektive, ni vidu, se ni ne ĝeneraligi ĉi plue. 

Ŝajnas iom lama mi, ĉefa, bezonas zorgi pri tiu Darn por ciklo, kaj nomante tuso denove kaj denove. Kial mi ne povas ĝuste diri tuso, bonvolu tusi tri fojojn? Alivorte, kial ne povas mi nur donu enigo tusadi kaj faru tion? 

Kial mi ne povas simple diri, en ĉefa tuso trifoje. Kaj nun, tiu estas speco de magia. Ĝi estas tre ripeta tie. Kaj ĝi estas ja bebo paŝon. 

Sed nur la kapablon parolu linio ok, tusi trifoje, estas nur tiom multe pli legebla. Kaj, plie, mi ne devas scii aŭ zorgas kiel tuso estas implementado. Kaj, efektive, poste en la termino kaj por fina projektoj, se vi pritrakti projekton kun samklasano aŭ du samklasanoj, vi rimarkos ke vi tuj devi aŭ voli, dividi la laboron. 

Kaj vi tuj volas decidi anticipe, kiu tuj faros kion, kaj en kiu pecoj? Kaj ĉu ne estus bela Se vi, ekzemple, ekestri skribo ĉefa, farita. Kaj via kompano, aŭ via partnero pli ĝenerale, prizorgas efektivigado tuso. 

Kaj tiu divido, tiuj muroj de abstraktado, aŭ tavoloj de abstracción se vi, estas super potencaj, ĉar precipe por pli grandaj, pli kompleksaj programoj kaj sistemoj, ĝi permesas multnombraj personoj konstrui aferojn kune, kaj fine stitch ilia laboro kune tiamaniere. Sed, kompreneble, ni bezonas nun ripari tuso. Ni devas diri tuso ke, hey, vi scias kion? Vi tuj bezonas preni input-- do ne malplena, sed int kaj nun. Ni iru antaŭen kaj metis en tusi la int. i ricevas nulon. 

i estas malpli ol kiom da fojoj. Mi diris tri antaŭe. Sed tio ne estas kion mi volas. Mi volas tusi esti ĝeneraligita al apogi ajnan numeron de ripetoj. 

Do ja, estas n kiun mi volas, ajn la uzanto diras mi. Nun, mi povas antaŭeniri kaj diru print tuso. Kaj negrave kiu nombro la uzanto pasas en, Mi persisti ke multfoje. 

Do fine de la tago, programo estas identaj. Sed rimarkas ĉiuj ĉi aferoj povus eĉ esti en alia dosiero. Ja, mi ne scias ĉe la momento kiel printf estas implementado. 

Mi ne konas nuntempe kiel akiri ŝnuro, aŭ akiri int, aŭ akiri kaleŝego realigitajn. Kaj mi ne volas vidi ilin sur mia ekrano. Kiel estas, mi komencas enfokusigi mia programo, ne tiuj funkcioj. 

Do, ja, kiam vi komenci faktoranta kodo kiel ĉi ekstere, ni povus eĉ movi tuso al aparta dosiero? Iu alia povus efektivigi ĝin. Kaj vi kaj via programo Farigxis tre bela kaj tre legebla, disputeble, vere kvar linio programo prava. 

Do ni iru antaŭen nun kaj unu fojon faros ŝanĝon. Rimarku ke mia prototipo devas ŝanĝi supren supro. Do lasu min korekti ke tiel Mi ne get kriis al. 

Fari tuson, mi kuros tuso iam pli, ankoraŭ fari la samon. Sed nun, rimarki ni havas ingredienco por unu fina versio. Vi scias kion? Mi ne volas nur tusi, nepre. Mi volas ion pli ĝenerala. Do vi scias kion? Mi volas fari tion. Mi volas havi multe kiel Scratch faras, oni diru bloko, sed ne nur diru ion iom da tempo. Mi volas diri tre specifa ŝnuro. Kaj do mi ne faras volas ĝin nur diru tuso. Mi volas diri kion ajn ŝnuro estas pasita en. 

Do rimarki, mi ĝeneraligita ĉi tial nun diru sentas bonan nomon por tio, kiel Scratch, prenas du argumentojn, kontraste Scratch. Unu estas ĉeno. Unu estas int. 

Kaj mi povus ŝanĝi ilin. Mi nur ia kiel la ideo de diru la ŝnuro, kaj poste kiom da fojoj poste. Void signifas ankoraŭ ne revenas nenion. Tiuj estas nur vida flanko efektoj, kiel la [? Jordan?] parola kromefikon de kriante. Ĝi ankoraŭ faras ion n fojojn, 0 ĝis, sed ne egalaj al n. Tio signifas n totala fojojn. Kaj tiam simple presi ajn tiu ŝnuro estas. Do mi vere ĝeneraligita tiu linio de kodo. Tial nun, Kiel implemento la tuso funkcio? 

Mi povas fari malplenon tuso. Kaj mi povas ankoraŭ fari en kiel multfoje vi volas tusi. Sed vi scias kion? Mi povas nun puŝpeli diri. 

Mi povas voki diri kun la vorto tuso, pasante en n. Kaj se mi volas ankaŭ apliki, nur por amuzo, kiel terno funkcio, Mi povas terni iu numero de fojoj. Kaj mi povas konservi reuzon n, ĉar rimarki ke m en tiu kunteksto aŭ amplekso nur ekzistas ene de ĉi tiu funkcio. 

Kaj n en tiu kunteksto nur Ekzistas ene tiu funkcio ĉi tie. Do ni revenos al tiuj temoj de medio. Kaj tie, mi nur volis diri, achoo kaj tiam n fojojn, duon-dupunkto. 

Kaj nun, mi nur bezonas prunti tiuj funkcio subskriboj tien. Tiel tuso estas korekta. Void terno estas ĝusta nun. 

Kaj mi ankoraŭ devas nur diri. Do mi tuj diru, diru ŝnuro s, int n, duon-dupunkto. Do mi tro realigita la heck ekstere de tiu programo. 

Kaj tio ne nepre signifas tio kion vi devas fari kiam skribanta eĉ la plej simpla de programoj. Preni iun kiu estas evidente vere simpla, vere mallonga, kaj re-apliki ĝin uzante tro multe kodo. Sed vi reale vidi, kaj en tempo retrorigardas sur tiuj ekzemploj, kaj rimarkas, ho, tiuj estas la paŝoj ni prenis por fakte ĝeneraligi, al faktoro ion, ĝis fine de la tago mia kodo estas vere bela racia. Ĉar se mi volas tusi tri tempoj tiam terni trifoje, Mi simple tuj rerun ĉi, programo fari tuson, kaj kuri tuso. Kaj mi havas tri tusoj kaj tri ternas. 

Kaj tiel tiu estas baza paradigmo, se vi volas, cxar kiel ni povus iri pri fakte efektiviganta programon. Sed ni simple rigardu kio estas ni estis farante ĉiuj ĉi tempo, kaj kion iuj de la fina pecoj estas malantaŭ ĉi tiu simpla komando. Fine de la tago, ni havas estis uzante Clang kiel nia tradukilo. Ni estis skribante fonto kodo, konvertado per Clang en maŝino kodo. 

Kaj ni uzis Faru nur faciligi nian pulsbatoj tiel ke ni ne devas memori tiujn sorĉojn de Clang mem. Sed kio estas Make fakte faras? Kaj, en victurno, kio estas Tin fakte faras? 

Rezultas, kvankam ni simpligita hodiaŭa diskuto dirante: vi prenas fontkodon, pasi ĝin kiel enigo al tradukilo, kiu donas eligo de maŝino kodo, rezultas ekzistas la kelkaj malsamaj ŝtupoj interne. Kaj kompilita hazarde estas la ombrelo termino por tuta aro da paŝoj. Sed ni nur turmentus ĉi ekstere vere rapide. 

Ĝi rezultas ke ni estis farante pli aferojn ĉiufoje mi kuros programon, aŭ ĉiufoje mi kompili programon hodiaŭ. Tiel preprocesamiento rilatas al this-- ion en C programo, kiel ni vidos denove kaj denove, kiu komenciĝas per tiu hash simbolo, aŭ la hashtag simbolo tie, signifas ĝi estas antaŭtraktilo direktivo. Tio signifas, tiukaze, hej komputilo, fari ion kun tiu dosiero antaŭ vi reale kompili mian propran kodon. 

Tiukaze, hash inkluzivas estas, esence, C maniero diri, hey komputilo, iru preni la enhavon de CS50.h kaj gluu ilin tie. Hey komputilo, iru akiri la enhavo de normo io.h, kie ajn kiu estas sur la malmola disko, alglui ĝin ĉi tie. Do tiuj aferoj okazas unua dum preprocesamiento. 

Kaj Clang faras ĉion ĉi por ni. Kaj ĝi faras lin tiel darn rapida, vi ne agos vidas kvar malsamajn aferojn okazas. Sed tio estas la unua tia paŝo. 

Kio fakte okazas nun? Nu, la sekva oficiala paŝo kompili. Kaj ĝi rezultas ke kompili programon teknike signifas irante de fontkodo, la aĵoj ni havas estis skribanta hodiaŭ, por ion nomita asembleo kodo, io kiu aspektas iom malsama. 

Kaj, fakte, ni povas vidi ĉi reala rapida. Lasu min reale iras en mian IDE. Lasu min antaŭeniri kaj malfermi hello.c, kiun Estas la unua programo kun kiu ni komenciĝis hodiaŭ. Kaj lasu min antaŭeniri kaj kuri Clang estas iom malsame, Clang -s, hello.c, kiuj estas efektive iranta donu al mi alian dosieron hello.s. 

Kaj ni volas probable neniam denove vidi tian kodon. Se vi prenas pli malaltan nivelon sistemoj klaso kiel CS61, vi vidos multe pli de tiu speco de kodo. Sed tiu estas lingvo ensamblador. Tio estas X86 asembla lingvo ke la CPU kiu subkuŝanta CS50 IDE vere komprenas. 

Kaj kripta kiel ĝi faras rigardu, estas io la komputilo komprenas sufiĉe bone. Sub q, tiu estas subtrahi. Ekzistas movadoj. 

Tie vokas funkciojn tie, x oring, movado, add, popo, revenon. Do ekzistas kelkaj tre malalta nivelo instrukcioj ke CPUs kompreni ke Mi aludis al pli frua. Tion Intel Inside. 

Ekzistas ŝablonoj de nuloj kaj ke mapi tiujn arcanely verkitan, sed iom bone nomita, instrukcioj, por tiel diri. Ke estas kio okazas kiam vi kompili vian kodon. Vi ricevas asembleo lingvo el ĝi, kiu signifas la tria paŝo estas kolekti ke asembleo kodo en, fine, maŝino code-- nuloj kaj ne la teksto kiun ni ĵus vidis antaŭ momento. 

Tial antaŭ-prilaborado faras ke trovi kaj anstataŭi, kaj kelkajn aliajn aferojn. Tradukado postulas via fonto kodo de C, fontkodo ke ni skribis al asembleo kodo kiu ni ĵus rigardetis. Kunvenadon prenas tiun komunumon kodo al nuloj kaj aĵoj ke la CPU vere volas kompreni fine de la tago. Kaj kunligi estas la lasta paŝo kiu okazas por us-- denove, tiom rapide ni faras eĉ notice-- kiu diras, hey komputilo, prenu ĉiujn la nuloj kaj ke rezultis de kompili David kodo, kaj lia ĉefa funkcio en ĉi tiu kazo. 

Kaj hey komputilo, iru preni ĉiuj nuloj kaj ke la CS50 bastonon skribis ene de la CS50 biblioteko. Miksi tiujn kun David. Kaj hey komputilo, iru preni ĉiuj nuloj kaj aĵoj ke iu alia skribis jaroj antaŭ por printf. Kaj aldoni tiujn en la tutan aferon, tiel ke ni havas akiris mia nuloj kaj, la CS50 bastonon de nuloj kaj, la printf nuloj kaj, kaj ion ajn ni uzas. 

Ili ĉiuj akiras kombinita kunvenos programo nomita, en tiu kazo, saluton. Do nun, ni volas simple uzi la vorton kompilita. Kaj ni prenos por koncedis ke kiam Ni diru, kompili vian programon, ĝi signifas, hej fari la antaŭ-prilaborado, ariganta, kaj kunligi. Sed estas vere iuj sukaj aĵoj okazas tie sub la kapuĉo. Kaj speciale se vi akiri scivola iu tempo, Vi povas komenci ŝovas ĉirkaŭe ĉe tiu malalta nivelo. Sed nuntempe, rimarkas ke inter la takeaways hodiaŭ estas tute simple la komencante de procezo, akiri komfortan kun ion kiel saluton mondo. Efektive, la plimulto de kion ni faris hodiaŭ Certe ne enprofundigi en super rapida. Kaj ĝi prenos iun tempo, kaj iu praktiko. Kaj prognozoj estas, vi ordigos de volas bati vian klavaron aŭ krii ĉe la ekrano. Kaj ĉiuj tio estas bone. Kvankam, eble provu ne fari ĝin en la biblioteko tiel. 

Kaj finfine, vi oni povis tamen, por komenci vidante ŝablonoj, ambaŭ en bona kodo ke vi skribis kaj eraroj ke vi faris. Kaj tre kiel la procezo de fariĝanta TF aŭ CA estas kiel, vi komencos akiri pli bonan kaj bone revidi tiujn mastrojn, kaj ĝuste solvi vian propraj problemoj finfine. Dume, tie estos abundo ni pruntedoni vin subteno kaj akiru tra ĉi. Kaj en la skribi-ups por ĉiuj problemoj Ĉu vi permesos gvidi tra ĉiujn komandojn ke mi certe scias el multan praktikon por nun, sed eble flugintaj super onies kapo nun. Kaj tio estas tute bone. 

Sed, finfine, vi tuj komenci vidi ŝablonoj emerĝi. Kaj unufoje vi preteriri ĉiujn stulta detaloj, kiel krampoj, kaj krispa krampoj, kaj punktokomoj, kaj la aĵoj, sincere, ke estas neniom intelekte interesa. Kaj ne estas la celo de prenante ajnan enkonduka klaso. Ĝi estas la ideojn kiuj tuj gravas. 

Ĝi estas la masxojn, la kondiĉoj, kaj la funkcioj, kaj pli potence la abstracción, kaj la faktoranta de kodo, kaj la bona dezajno, kaj la bona stilo, kaj finfine la ĝustecon de via kodo, jen finfine tuj gravas la plej. Tiel proksima semajno, ni prenos tiujn ideoj kiujn ni unue vidis en Scratch kaj nun tradukita al C. Kaj ni komencos enkonduki la unua de la Kompreneble la reala mondo domajnoj. 

Ni enfokusigi la mondo de sekureco, kaj pli specife ĉifriko, la arto de grimpadi informo. Kaj inter la unuaj problemoj vi mem ricevos skribi preter ludante kun iuj de la sintakso kaj solvi iujn logikajn problemoj, fine antaŭ longe, Estas efektive levi, aŭ ĉifri, kaj finfine deĉifri informon. Kaj ĉio ni faris hodiaŭ, volo sufiĉe malalta nivelo, estas ĝuste tuj permesos ni preni, kaj unu, kaj unu pli paŝo supre al skribas la plej interesajn kodo ankoraŭ. 

Do pli en tiu proksima semajno. 

[VIDEO reprodukto] 

-Kio Povas diri pri lastfoje vi vidis lin? -Kio Povas mi diri, vere? Mi volas diri, ĝi estis kiel ajna alia pre-produktado provludo, krom io li diris ĉe la fino kiu algluiĝis kun mi. 

-tio Cxi estis CS50. 

-Tio Estas tranĉo ĉiuj, grandan laboron sur provludo. 

Ke la tagmanĝo? 

-Yeah, Vi kaj mi povas Ekpreni sandviĉo en iom. Lasu min nur debrief kun David vere rapide. David? David? 

[FINO reprodukto] 