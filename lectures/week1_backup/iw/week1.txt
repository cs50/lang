[מוסיקה מתנגנת] דוד י מלאן: בסדר, זה CS50. וזה שבוע. אז לזכור כי בפעם האחרונה בשבוע אפס, התמקדנו חשיבה חישובית. ואנחנו מעבר ממעגל Scratch, תכנות גרפי שפה מהחברים שלנו במעבדת המדיה של MIT. 

ועם שריטות, עשינו לחקור רעיונות כמו פונקציות, ותנאים, ולולאות, ומשתנה, ואפילו אירועים, וחוטים ועוד. והיום, אנחנו הולכים להמשיך להשתמש רעיונות אלה, ובאמת לקחת אותם כמובן מאליו, אבל לתרגם אותם לשפה אחרת המכונה עכשיו ג, C היא שפה מסורתית יותר. זה רמה נמוכה שפה, אם תרצה. 

זה גרידא טקסטואלי. וכך במבט ראשון, זה הכל הולך נראה די נסתר אם אף פעם לא מתוכן לפני. אנו מתכוונים לקיים חצי נקודות וסוגריים, ו סוגריים מסולסלים, ועוד. אבל להבין כי גם למרות שהתחביר עומד להיראות קצת לא מוכר כדי שרובכם, לראות מעבר לכך. ולנסות לראות את הרעיונות כי הם, אכן, מוכרים, כי כאן בשבוע אחד מה נתחיל לעשות הוא להשוות, בתחילה, גרד לעומת ג 

כך, למשל, לזכור כי כאשר אנו יישמתי את הראשון של התוכניות שלנו הפעם האחרונה, היו לנו בלוק שנראה משהו קטן כמו זה- כאשר דגל ירוק נקש, ולאחר מכן היה לנו אחד או יותר חתיכות הפאזל מתחתיה, במקרה זה, אומר, hello world. אז, אכן, ב Scratch, כאשר אני לוחץ כי דגל ירוק כדי להפעיל את התוכנית שלי, כך לדבר, אלה הם אבני כי מוצאים להורג, או לרוץ. וגם, באופן ספציפי, Scratch אמר, שלום, עולם. 

עכשיו, יכולתי ציינתי מילים שונות כאן. אבל נראה כי, אכן, רב של blocks-- אלה ואכן, ב- C רב functions-- יכול להיות parametrized או מותאם אישית לעשות דברים שונים. למעשה, ב- C אם אנחנו רוצה להמיר, עכשיו, תוכנית Scratch זה לשפה אחרת זה, אנחנו הולכים לכתוב משהו קטן כזה. 

אמנם, יש כמה מוכר התחביר שם ככל הנראה, int, סוגריים, ומבוטל. אבל printf-- למרות שהיית חושב שזה יהיה רק ​​הדפסה. אבל הדפסה אומרת הדפסה מעוצב, כפי שאנו בקרוב לראות. זה יהיה ממש להדפיס למסך מה הוא בתוך סוגריים אלה, אשר כמובן שבמקרה זה, hello world. 

אבל תבחין כמה אחרים תחביר, כמה במרכאות כפולות, כי הסוגריים בסוף, the-פסיק וכדומה. אז יש קצת מעלינו, כביכול, הן מבחינה קוגניטיבית ו תחבירית, כי אנחנו הולכים צריך לזכור לפני זמן רב. אבל להבין כי עם תרגול, זה יתחיל לקפוץ החוצה אליך. 

למעשה, בואו נתמקד שאחד פונקציה specifically-- במקרה זה, להגיד שלום העולם. אז אומר היא הפונקציה. שלום העולם הוא הפרמטר שלה, או ויכוח, ההתאמה האישית שלה. 

ואת השקילות ב- C היא רק הולך להיות קו אחד זה כאן, שם printf שווה, אומרים, המחרוזת הכפולה המצוטטת, שלום העולם הוא שווה, כמובן, למה יש בתוך הקופסה הלבנה שם. ואת מהלך סרק n, אם כי קצת מוזר נעדר מאפס, פשוט הולך להיות השפעה אנחנו נעלה לראות במחשב, כמו Mac שלי או מחשב, רק הזזה הסמן לשורה הבאה. זה כמו להכות Enter במקלדת. 

אז נראינו כי בעוד זמן לא רב. אבל קודם, בואו נסתכל על זה דוגמא אחרת במקרה של לולאות. היו לנו לנצח לולאה זו הפעם האחרונה, בהן היתה שורה של חתיכות פאזל כי עשה משהו ממש forever-- במקרה זה, לומר, שלום עולם, hello world, hello world, hello world. אז זה ללולאה אינסופית על ידי עיצוב. 

ב C, אם אנחנו רוצים ליישם את זה אותו רעיון, נוכל פשוט לעשות את זה. בעוד נכון, printf שלום בעולם-- עכשיו זמן מה, רק סמנטי, סוג של מעלה את הרעיון של לעשות משהו שוב, ושוב, ושוב, ובמשך כמה זמן? ובכן, כזכור true-- כי נכון הוא רק על או אחד. 

וזה נכון, כמובן, תמיד נכון. אז זה סוג של משמעות שמירה על הפרטים רק לומר אמת. אבל אכן, זה מכוון, כי אם נכון הוא פשוט תמיד נכון, מ ואילו נכון רק מרמז, אם קצת בעקיפין, שקווי הקוד הבא בין אלה סוגריים מסולסלים צריך רק לבצע שוב, ושוב, ושוב, ואף פעם לא ממש להפסיק. 

אבל אם אתה רוצה שלך לולאה להפסיק, כפי שאנו עשה בפעם האחרונה עם משהו כמו זו, לחזור על 50 הפעמים הבאות, ב- C אנחנו יכולים לעשות את אותו הדבר עם מה נקרא על loop-- מילת המפתח לא להיות זמן מה, אבל עבור. ואז יש לנו כמה תחביר חדש כאן, עם int i שווה 0, אני פחות מ -50, i ++. ואנחנו נחזור לזה. אבל זה פשוט איך היינו לתרגם את הסט של בלוקים Scratch לקבוצה של שורות קוד C. 

בינתיים, לשקול משתנים. ואכן, אנחנו רק ראיתי אחד לפני רגע. וגם במקרה של גירוד, אם אנחנו רציתי להכריז על משתנה בשם i עבור i להיות שלם, רק מספר, ואנחנו רוצים להגדיר אותו ערך כלשהו, היינו להשתמש כתום זה לחסום כאן-- ואינדינ ל -0. 

ואנחנו נראה היום מעבר, בדיוק כמו בשבוע שעבר, מתכנת לעשות כמעט תמיד מתחילים לספור מאפס, באמת לפי האמנה. אבל גם בגלל ביטול מן בדיוננו בינארי, המספר הקטן ביותר שאתה יכול מייצג עם כל מספר סיבי רק הולך להיות 0 עצמה. וכך נתחיל בדרך כלל אתחול אפילו משתנים שלנו 0. 

וגם ב- C כדי לעשות את אותו הדבר, אנחנו הולכים לומר int עבור מספר שלם, אני פשוט על ידי האמנה. יכולתי לצלצל משתנה זה כל מה שאני רוצה, בדיוק כמו שריטה. ואז שווה 0 רק מקצה הערך 0 מימין ומכניס אותו לתוך המשתנה, או מיכל אחסון שם, בצד שמאל. ואת הפסיק כפי שאנו שתראה-- ו ראינו כמה already-- אלה רק אומר סוף מחשבה. המשך לעשות משהו אחר על השורות הבאות. 

עכשיו, מה לגבי ביטויים בוליאני? נזכיר כי ב Scratch, אלה היו ביטויים כי הם או נכונים או שאלות false--, באמת, כי הם או אמת או שקר. אז במקרה של גירוד, נוכל לשאול שאלה פשוטה כמו זו, הוא לי פחות מ -50? אז אני, שוב, הוא מספר שלם. אולי אנו משתמשים בו בתוכנית Scratch כדי לעקוב אחר ציון או משהו כזה. אז תחביר זה כאן Scratch רק אומר, הוא שאני פחות מ -50? ובכן, למרבה המזל, משהו הוא פשוט ב C. וכדי לתרגם, זה אנחנו פשוט היה אומר לי פחות מ -50, באמצעות המקש המוכר במקלדת. 

בינתיים, אם אתה רוצה לומר משהו כללי יותר, כמו, ובכן, הוא x פחות מ y כאשר כל של x ו- y הם עצמם משתנים? אנחנו יכולים לעשות את אותו הדבר ב C, ולכן כל עוד יש לנו כבר נוצר משתנים אלה. ואנחנו נראה איך לעשות את זה לפני זמן רב. אנחנו פשוט היו אומרים x פחות מ y. 

אז אתה מתחיל לראות כמה קווי דמיון. ואלה אנשים שעשו Scratch היה בהחלט בהשראת כמה רעיונות בסיסיים אלה. ואתה רואה את זה סוג של תחביר languages-- רב לא רק גרד, לא רק C, אבל פייטון, ו- JavaScript, ו בשפות אחרות עדיין. 

הבה נבחן מבנה אחר מ C, הרעיון של מצב, עושה משהו על תנאי. אם משהו הוא נכון, לעשות את זה. אם משהו אחר נכון, לעשות את זה. זה סוג של תכנות מקבילה של להצטלבות הדרכים. אולי זה מזלג דו כיוונית, מזלג משולש, או יותר. וגם שריטה, כמו שיש לה ראיתי משהו כזה. 

אז יש לנו פה אחת גדולה. אבל לשקול את היחסים הפשטות של ההיגיון. אם x קטן מ y, אז אומרים x קטן מ y, אחר אם x גדול מ- y, אז אומרים x גדול מ- y. ואז, באופן הגיוני, אם אתה חושב בחזרה Scratch או פשוט אינטואיציה אנושית משלך, טוב, אם x אינו עולה y, ו- x לא פחות מ y, אז כמובן x הולך להיות שווה y. אז במקרה הזה, על ידי קינון אלה אבני Scratch, אנחנו יכולים להשיג שלוש מזלג הדרך בכביש? 

בינתיים, אם אנחנו רוצים לעשות את זה ב- C, זה ללא ספק נראה simpler-- קצת לפחות ברגע שאתה מקבל מכיר את התחביר. אם x קטן מ y, x printf הוא פחות מ y. x אחר אם הוא גדול מ y, x printf עולה y. x printf אחר שווה y-- ו, שוב, עם אלה מהלך סרק מסתיים רק עבור קווים חדשים אלה, כך שאם אתה ממש רצה זה סוג של תוכנית זה היה רק ​​לעבור הסמן בסופו של דבר לשורה הבאה של המסך. 

עכשיו, בינתיים Scratch היה אחר יותר תכונות מתוחכמות, רק שחלקם אנחנו הולכים בתחילה לעבור אל העולם של ג ואחד מהם היה נקרא רשימת Scratch. וזה היה מיוחד סוג של משתנה מותר לך לאחסן דברים מרובים ב אותו בחזרה, אל גב, לגבות, לגבות. 

ב C, אין לו רשימות, כשלעצמה, אלא משהו כי הם באופן כללי יותר יהיו שנקרא מערכים, למרות שאנחנו לחזור מאוחר יותר בסמסטר הזה כדי להביט במשהו קרא רשימה, או באמת רשימה מקושרת. אבל לעת עתה, הדבר הקרוב ביותר המקבילה C בשבילנו הולך להיות משהו נקרא מערך. ואת מערך פשוט סוג מיוחד של משתנה המאפשר לך לאחסן נתונים בחזרה, לגבות, לגבות, אל גב. 

ואכן, ב Scratch, אם אנחנו רוצים לגשת הרכיב הראשון של מערך או list-- ואני הולך לקרוא לזה, לפי האמנה, argv, הטיעון וקטור, אבל עוד על כך לפני זמן רב. אם אני רוצה לקבל את האלמנט הראשון של argv, בעולם של Scratch אתה בעצם לעשות בדרך כלל מתחילים לספור מ -1. 

וכך אני עלול לקבל פריט 1 של argv. זה בדיוק איך MIT מיושם הרעיון של רשימות. אבל ב- C, אני הולך יותר פשוט פשוט לומר, argv, אשר שוב הוא השם של שלי list-- או להיות ברור, מערך. ואם אני רוצה את הראשון אלמנטים, אני הולך להשתמש בסוגריים מרובעים, אשר אתה אולי לעתים קרובות לא בשימוש תחת המקלדת. 

אבל 0 רק אומר, אני צריך את הראשון. לכן, בהזדמנות וכפי הזמן עובר, אנחנו הולכים כדי להתחיל לראות הדיכוטומיות הללו בין Scratch ו- C, לפיה Scratch משתמש בכרטיס. אנחנו ב- C להשתמש 0 כאן. אבל תוכל לראות במהירות ברגע שאתה מבין היסודות של כל שפה, כי הדברים האלה מתחילים לקבל את כל יותר מוכר באמצעות תרגול בפועל. 

אז בואו באמת נראים כעת על תכנית. כאן יהיה הראשון של C שלנו קוד מקור של תוכניות מלאות. והתוכנית אנחנו הולכים להציע בתמורה הוא זה שווה ערך לזה חתיכת Scratch קודם לכן. 

אז כאן, יש לנו מה זה ניתן לטעון את תוכנית C הפשוטה אתה יכול לכתוב כי באמת עושה משהו. עכשיו, נחפש בעבר, לעת עתה, יש לכלול, io.h סטנדרטי, וזווית אלה בסוגריים, ו int, ומבוטל, ואת סוגריים מסולסלים, וכיוצא באלה. 

ובואו רק להתמקד מה, לפחות באופן אינטואיטיבי, אולי לקפוץ החוצה אליך כבר. למעשה, עיקרי, אני לא בהכרח יודע מה זה, אבל הרבה כמו שריטה היתה שכאשר דגל ירוק לוחץ פיסת הפאזל, וכך גם C כשפת תכנות יש חתיכה ראשית של קוד מקבל להורג כברירת מחדל. ואכן, זה ממש הולך להיקרא ראשי. 

אז עיקרי היא פונקציה. וזה תפקיד מיוחד שקיים ב- C שכאשר אתה מפעיל תוכנית, זה ראשי שמקבל מנוהל על ידי בְּרִירַת מֶחדָל. בעולם של גרד, זה היה בדרך כלל כאשר דגל ירוק והכה נדרס כברירת מחדל. 

בינתיים, ראינו את זה קודם, printf או מעוצב הדפסה, זה הולך להיות פונקציה שמגיעה עם C, יחד עם חבורה שלמה של אחרים, רצון כי מעה והזמן שוב, כדי לעשות בדיוק כשמו, להדפיס משהו. מה אנחנו רוצים להדפיס? ובכן, נראה כי על ידי תווים תוחמים כמו these-- העולם שלום, n לוכסן אחורי במרכאות כפולות, אנחנו יכולים לספר printf בדיוק מה להדפיס על המסך. 

אבל כדי לעשות זה, לצערנו צריך לקחת משהו שהוא כבר נסתר לנו, בני האדם, אבל לפחות זה קצת readable-- חדה כוללים, io.h סטנדרטי, int, העיקרי, חלל, printf, כל קסום לחשים אנחנו פשוט ראינו על המסך. אבל אנחנו באמת צריכים ללכת יותר מסתורי עדיין. אנחנו קודם צריכים לתרגם את הקוד שנכתוב לקוד מכונה. ולהיזכר מהשבוע שעבר כי מכונות, לפחות מאלה שאנו מכירים כאן, בסוף היום היחיד להבין אפסים ואחדים. 

ואלוהים שלי, אם היינו צריכים לכתוב אלה אפסים ואחדים לתכנית למעשה, זה היה מאוד, מאוד מהר מוציא את כל הכיף של דבר. אבל מתברר, בשבוע שעבר, שדפוסים אלו של אפסים ואחדים יש רק משמעות מיוחדת. בהקשרים מסוימים, הם אולי זה אומר במספרים. 

בהקשרים מסוימים, ויכול להיות שפירושן אותיות או צבעים, או כל מספר הפשטות אחרות יש על. אבל בדיוק כמו המחשב שלך יש מעבד, יחידת עיבוד מרכזית, או במוחם הפנימי של המחשב. זה בדרך כלל אינטל בפנים, כי זה אחת החברות הגדולות שגורם מעבדים למחשבים. 

ובכן, מעבד אינטל ואחרים פשוט החליטו מראש כי דפוסים מסוימים של אפסים אלה משמעו דברים ספציפיים. דפוסים מסוימים של אפסים ואחדים יהיה משמעות, להדפיס זה למסך, או להוסיף שני מספרים אלה, או לחסר שני מספרים אלה, או להזיז את הכלי של נתונים הזיכרון של המחשב שלי לכאן, או כל מספר של רמה נמוכה מאוד אחרת, אבל בסופו של דבר שימושי, פעולות. אבל, למרבה המזל, אנחנו בני האדם לא הולכים צריך לדעת את רמת הפירוט הזו. ואכן, בדיוק כמו בפעם הקודמת, איפה אנחנו שוב מפוזר, ושוב, ושוב, בניין מרמה נמוכה מאוד הפרימיטיבים כמו אפסים ואחדים למושגים ברמה גבוהה יותר כמו מספרים ואותיות, וצבעים, ועוד, גם אנחנו יכולים כמו מתכנתים לעמוד על הכתפיים אחרים שבאו לפנינו ולהשתמש תוכנה אחרת אנשים כתבו לפני us-- כלומר תוכניות שנקראו מהדרים. 

C היא שפה בדרך כלל עובר הידור, כלומר מרה קוד המקור לקוד מכונה. בפרט, מה זה אומר הוא שאם יש לך המקור שלך קוד שאתה עצמך כותב, כפי שאנו בקרוב יהיה בעוד רגע על המסך, ואתה רוצה להמיר אותו בסופו של דבר מכונה code-- אפסים ואחדים אלה רק Mac או PC שלך understands-- יש לך ראשון להאכיל כי קוד המקור כפי קלט מיוחד תוכנית בשם מהדר, הפלט של אשר אנו שנראה הוא קוד מכונה. ואכן, בפעם האחרונה שדיברנו על, באמת, בסוף היום, פתרון בעיות. יש לך תשומות. ויש לך יציאות. ויש לך איזשהו של אלגוריתם באמצע. 

אלגוריתמים בטח יכול להיות מיושם בתוכנה, כפי שראינו בשבוע שעבר פסאודו קוד וכפי שנראים עם קוד בפועל השבוע. וכך מהדר באמת רק יש קבוצה של אלגוריתמים בתוך מזה שיודע להמיר את מילות המפתח מיוחד, כמו ראשי, printf, ואחרים שאנחנו פשוט ראה לתוך התבניות של אפסים אלה אינטל מעבד בתוך ואחרים בעצם מבין. אז איך עושים את זה? מנין אנו שואבים מהדר? 

רובנו כאן יש מק או PC. ואתה מפעיל Mac OS, או Windows או Linux, Solaris או, או כל מספר של אחרים מערכות הפעלה. ואכן, יכולנו לצאת על גבי האינטרנט ולהוריד מהדר עבור Mac שלך או למחשב במערכת ההפעלה הספציפית שלך. אבל כולנו יהיה על דפים שונים, אם אפשר לומר כך. נצטרך מעט תצורות שונות. ודברים לא יעבדו בכל זאת. ואכן, בימים אלה רבים מאיתנו לא להשתמש תוכנה שפועלת רק על המחשבים הניידים שלנו. במקום זאת, אנו משתמשים משהו כמו דפדפן מאפשר לנו לגשת מבוסס אינטרנט יישומים בענן. ובהמשך בסמסטר הזה, ואנו לעשות בדיוק את זה. נכתוב יישומים או תוכנה באמצעות code-- לא C, אבל בשפות אחרות כמו פייתון JavaScript-- שמופעל בענן. 

וכדי לעשות את זה, אנחנו עצמנו במהלך הסמסטר למעשה ישתמש ענן מבוסס סביבה המכונית CS50 IDE. זהו תכנות מבוסס אינטרנט סביבה, או פיתוח משולב הסביבה, IDE, זה נבנה על גבי חלק תוכנת קוד פתוח בשם קלאוד 9. וגם ביצענו כמה פדגוגית הפשטה אליו כדי להסתיר תכונות מסוימות בשבועות הראשונים שאנחנו לא צריכים, לאחר מכן אתה יכול לחשוף אותם ולעשות ביותר כל מה שאתה רוצה עם הסביבה. 

וזה מאפשר לנו גם כדי טרום להתקין תוכנות מסוימות. דברים כמו מה שנקרא CS50 הספרייה, אשר אנו בקרוב לראות מספק לנו ב- C עם כמה פונקציונליות נוספת. אז אם אתה הולך, בסופו של דבר, CS50.io, יתבקשו לך להתחבר, וברגע שאתה עושה וליצור חשבון בחינם, תוכלו לגשת בסביבה שנראית די ככה. 

עכשיו, זה נמצא במצב ברירת המחדל. הכל נחמד בהיר על המסך. לרבים מאתנו יש רגל של עובד על חתיכת CS50 זה מאוחר למדי אל תוך הלילה. וכך שחלקכם מעדיפים ולהפכו מצב לילה, אם אפשר לומר כך. 

אבל, בסופו של דבר, מה אתה הולך לראות בתוך CS50 IDE הוא שלושה האזורים-- ברורים שטח על שם שמאלה הקבצים שלך הולכים להיות ענן, שטח בפינה הימנית העליונה שם הקוד שלך הולך להיות לעריכה. תוכל לפתוח מכרטיסיות עבור כל תכנית שאתה כותב בסמסטר הזה בתוך זה בפינה הימנית העליונה. ואז ביותר arcanely, ובכל זאת בעצמה, הולך להיות הדבר הזה בבית בתחתית המכונית חלון מסוף. 

זהו בית ספר ישן ממשק שורת פקודה, או CLI, המאפשר לך לבצע פקודות על computer-- במקרה זה, את המחשב cloud-- לעשות דברים כמו לקמפל קוד שלך מקוד המקור לקוד מכונה, כדי להפעיל את התוכניות שלך, או להתחיל שלך שרת אינטרנט, או לגשת מסד הנתונים שלך, וכל מספר טכניקות אחרות כי נתחיל להשתמש לפני זמן רב. אבל כדי להגיע לשם, אנחנו הולך להיות ממש להיכנס לאינטרנט ולהתחיל לשחק. וכדי לעשות את זה, בוא ראשון להתחיל להתעסק ראשי, ולכתוב את החלק העיקרי של התוכנית. ובואו להשתמש בפונקציה כי printf, בו השתמשנו קודם לכן, פשוט לומר משהו. 

אז הנה אני כבר בפנים של IDE CS50. התחברתי מראש. ואני מלא הוקרן החלון. וכך, בסופו של דבר, אתה מדי בעיות קרובות צעדים הנדרשים דומים כי יספק תיעוד מקוון. אז אתה לא צריך לדאוג קליט כל צעד טכני קטן כי אני עושה כאן היום. 

אבל תקבל מסך כזה. אני דווקא להיות במצב לילה. ואתה יכול להאיר הכל על ידי השבתת מצב לילה. ובסוף של היום, אתה הולך לראות עיקרי שלושה האזורים-- את הקובץ דפדפן בצד השמאל, כרטיסיות הקוד למעלה, ואת חלון המסוף בתחתית. 

תן לי ללכת קדימה לכתוב התוכנית הראשונה שלי. אני הולך ללכת מנעתי אל הקובץ, שמור, ושמור את הקובץ שלי hello.c. ואכן, לפי האמנה, כל שאנו התוכנית תכתוב כתוב בשפת C צריך להיות שם משהו נקודה ג, לפי האמנה. אז אני הולך שם את זה hello.c, כי אני רק רוצה להגיד שלום לעולם. עכשיו אני הולך להגדיל מתוך ולחץ על שמור. וזה כל מה שיש לי כאן כרגע היא כרטיסייה שבו אני יכול להתחיל לכתוב קוד. 

זה לא הולך לקמפל. זה לא אומר כלום. וכך גם אם המרתי זה אפסים ואחדים, המעבד הוא הולך להיות לא מושג מה קורה מסביב. אבל אם אני כותב את השורות כי תואם עם ההוויה C conventions-- של C, שוב, זה language-- עם תחביר כמו זה, printf שלום בעולם-- ויש לי והתרווח עם עושה את זה לאורך זמן. אז אני לא חושב שעשיתי כל שגיאות דפוס. 

אבל, תמיד, ראשון פעם שאתה עושה זה, תרצה. ומה שאני עומד לעשות אולי מאוד גם לא מצליח לכם בפעם הראשונה. וזה בסדר גמור, כי עכשיו אתה יכול רק לראות הרבה חידוש כולו, אבל לאורך זמן ברגע שאתה מקבל מוכר עם הסביבה הזאת, בשפה זו, ואחרים, תתחיל לראות דברים או נכונים או לא נכונים. 

וזה מה עמיתי הוראה כמובן עוזרים מקבלים כל כך טובים בשלב מעל, הוא תצפית טעויות או באגים בקוד. אבל אני טוען שיש אין באגים בקוד זה. אז עכשיו אני רוצה להפעיל את התוכנית. 

עכשיו ב- Mac או PC שלי, אני הרגל של סמלי לחיצה כפולים כשאני רוצה להריץ כמה תכנית. אבל זה לא המודל כאן. בסביבה זו, המהווה CS50 IDE. אנחנו משתמשים תפעוליים מערכת בשם לינוקס. לינוקס היא מזכירה עוד מערכת ההפעלה, המכונה בדרך כלל כמו יוניקס. ו- Linux ידוע במיוחד עבור בעל CLI, בסביבת שורת פקודה. עכשיו, אנו משתמשים ספציפיים טעם של לינוקס בשם אובונטו. ואובונטו הוא פשוט גרסה מסוימת של לינוקס. 

אבל בימים אלה של לינוקס אלה בעצם לעשות מגיע עם ממשק משתמש גרפי. ואת אחד אנחנו לקרות להשתמש כאן הוא מבוסס אינטרנט. אז זה עשוי להיראות אפילו קצת שונה ממשהו אתה עצמך יכול להיות לראות או להפעיל בעבר. 

אז אני הולך קדימה עכשיו לבצע את הפעולות הבאות. שמרתי את הקובץ כפי hello.c. אני הולך קדימה, סוג clanghello.c אז קלאנג עבור שפת C הוא מהדר. זה מותקן מראש ב CS50 IDE. ואתה בהחלט יכול להוריד להתקין זה ב- Mac או PC שלך. 

אבל, שוב, לא היית צריך את כל התצורה-מראש נעשתה בשבילך. אז לעת עתה, אני פשוט הולך לרוץ clanghello.c. ועכשיו לב תחביר זה כאן יהיה בסופו של דבר פשוט מבינים אומר שאני בתוך תיקייה או ספרייה בשם Workspace. סימן הדולר זוהי רק מוסכמה אחר משמעות, להקליד פקודות שלך כאן. 

זה מה שנקרא מהיר, צודק לפי האמנה הוא סימן דולר. ואם אני הולך קדימה עכשיו ולחץ זן, שום דבר לא נראה קורה. אבל זה בעצם דבר טוב. פחות זה יקרה על המסך, כך סביר יותר הקוד שלך הוא יהיה נכון, לפחות מבחינה תחבירית. 

אז אם אני רוצה לנהל את העניינים התוכנית, מה עלי לעשות? ובכן, מתברר כי שם ברירת מחדל לפי אמנה לתוכניות כשאינך לציין שם עבור התוכנית שלך היא רק a.out. וזה גם תחביר, שתצליח להכיר לפני זמן רב. 

Dot לקצץ רק אומר, היי, CS50 IDE, להפעיל תוכנית בשם a.out זה בתוך הספרייה הנוכחית שלי. נקודה כלומר את הספרייה הנוכחית. ואנחנו נראים מה רצפים כאלה אחרים תווים אומר לפני זמן רב. 

אז הנה זה בא, זן, hello world. ואתה שם לב, זה מה שקרה? לא רק זה להדפיס hello world. כמו כן העביר את הסמן לשורה הבאה. 

ולמה זה היה? מה היה הקוד שכתבנו לפני כי הבטיח כי הסמן היה ללכת על הקו הבא? דבר מצחיק על המחשב הוא זה רק הולך לעשות ממש מה אתה אומר את זה כדי לעשות. 

אז אם אתה אומר את זה כדי printf שלום, פסיק, רווח, עולם, ציטוט קרוב, זה ממש רק הולך להדפיס תווים אלה. אבל היה לי אופי מיוחד זה בסוף, כזכור, קו נטוי הפוך n. וזה מה הבטיח שהדמות הלכה לשורה הבאה של המסך. 

למעשה, תן לי ללכת ולעשות את זה. תן לי ללכת קדימה ולמחוק זה. עכשיו, שימו לב כי העליון של המסך שלי יש נורה אדומה קטנה ב בכרטיסייה המציינת, היי, אתה כבר לא הצלת את קובץ. אז אני הולך קדימה עם שליטה S או הפקודה S, לשמור את הקובץ. עכשיו זה goes-- ירד ירוק moment--. ועכשיו היא חזרה פשוט להיות סמל סגירה. 

אם אני עכשיו לרוץ clanghello.c שוב, זן, לוכסן נקודה, a.out, זן, תראה שהיא עדיין מתפקדת. אבל זה ללא ספק עגלה קטנה. כרגע, סביבת עבודה prompt-- שלי, ואז זה סימן הדולר, ואז prompt-- בפועל שלי הכל באותה שורה. אז בהחלט זה באג אסתטי, גם אם זה לא ממש באג לוגי. 

אז אני הולך לבטל את מה בדיוק עשיתי. אני הולך להפעיל מחדש a.out. שים לב הוספתי את בחזרה אופי שורה חדשה. שמרתי את הקובץ. 

אז אני הולך להפעיל מחדש a.out, ו-- לעזאזל, באג, באג כלומר טעות. אז הבאג הוא שלמרות הוספתי את מהלך סרק n שם, מחדש הציל, מחדש ניהל את התוכנית, ההתנהגות הייתה זהה. למה זה יהיה? 

אני חסר צעד, נכון? זה צעד מפתח קודם לכן היה שיש לך עם-- בעת שינוי קוד המקור שלך, מתברר גם לרוץ זה דרך המהדר שוב, כך שאתה מקבל קוד מכונה חדשה. ואת הקוד מכונה, אפסים ואחדות, הולכים להיות כמעט זהה, אבל לא באופן מושלם כל כך, כי אנחנו צריכים, כמובן, כי הקו החדש. 

אז כדי לתקן את זה, אני הולך צריך להפעיל מחדש clanghello.c, זן, נקודה סלאש, a.out. ועכשיו, hello world חוזר למקום שבו אני מצפה שזה יהיה. אז זהו כל טוב ויפה. אבל a.out הוא שם די מטומטם בשביל התוכנית, למרות שזה קורה להיות, מסיבות היסטוריות, default-- כלומר פלטי הרכבה. 

אבל תן לי ללכת קדימה כאן ולעשות את זה בצורה שונה. אני רוצה תכנית שלום העולם שלי למעשה להיקרא שלום. אז אם זה היה סמל על שלי שולחן העבודה, זה לא יהיה a.out. זה ייקרא שלום. 

אז כדי לעשות זאת, מתברר כי קלאנג, כמו תוכניות רבות, תומך שורת הפקודה טיעונים, או דגלים, או מתגים, אשר פשוט להשפיע על ההתנהגות שלה. באופן ספציפי, קלאנג תומך קורטוב o דגל, אשר לאחר מכן הוא לוקח מילה שנייה. במקרה זה, אני יהיה שרירותי, אבל סביר, קוראים לזה שלום. אבל אני יכול לקרוא לזה משהו אני רוצה, חוץ a.out, אשר מעדיף להיות שייך לעניין. 

ואז פשוט לציין את שם של הקובץ אני רוצה לקמפל. אז עכשיו אף בתחילה של הפקודה עדיין יש לי קלאנג, בסוף הפקודה עדיין יש לי את הקובץ, עכשיו יש לי שורת הפקודה האלה ויכוחים, דגלים אלה כי אומרים, אה, דרך אגב, פלט-o, קובץ בשם שלום, לא a.out המחדל. 

אז אם אני מכה זן עכשיו, שום דבר כנראה קרה. וגם, עדיין, עכשיו אני יכול לעשות נקודת לוכסן שלום. אז זה אותו דבר התוכנית. האפסים ואת אלה הם זהה בסוף היום. 

אבל הם בשני a.out files-- השונה, המהווה את הגרסה הראשונה ופשוט בשם בטיפשות, ועכשיו שלום, שהינה הרבה שם מושך יותר עבור תוכנית. אבל, בכנות, אני אף פעם לא עוד נזכור את זה שוב, ושוב, ושוב. וזה, בעצם, כפי שאנו לכתוב יותר תוכניות מסובכות, את הפקודות שאתה הולך צריך לכתוב הולכים להתנקם יותר מסובך. 

וכך לא לדאוג. מתברר כי בני אדם לפני לנו הבינו גם הם היתה לי בעיה בדיוק זה. הם גם לא נהנו צורך הקלד ארוכות למדי, פקודות מסתוריות, כמה וכמה לזכור אותם. וכך אדם לפנינו עשו תוכניות אחרות שמקלות לקמפל את התוכנה. 

ואכן, אחד כזה התוכנית נקראת הפוך. אז אני הולך קדימה, לעשות זאת. אני הולך לבטל את כל מה שאני רק עשיתי את הדרך הבאה. תן לי להקליד LS. ותבחין שלושה things-- a.out, וכוכב, שלום וכוכב, ו hello.c. יש לקוות, זה צריך להיות קצת אינטואיטיבי, ככל קודם לכן היה דבר סביבת עבודה זו. לא היה שום דבר שיש לי נוצר עד שהתחלנו בכיתה. 

ויצרתי hello.c. אז אני הידור זה, וכינה אותו a.out. ואז ערכתי את זה שוב מעט אחרת וקרא לה שלום. אז יש לי שלושה קבצים בספריה זו, בתיקייה זו נקראת סביבת העבודה. עכשיו, אני רואה את זה גם כן אם אני Zoom בפועל. 

אם אני Zoom לכאן להסתכל כי ימני העליונה בפינה, כפי שהובטח שמאל יד בצד של המסך הוא תמיד הולך להראות לך מה בחשבונך, מה בתוך IDE CS50. ויש שם שלושה קבצים. 

אז אני רוצה להיפטר a.out ושלום. וכפי שאתה יכול לדמיין באופן אינטואיטיבי, אתה יכול למיין של קליק מלא או לחץ לחיצה ימנית על זה. והתפריט הקטן הזה צץ. ניתן להוריד את הקובץ, להפעיל זה, תצוגה מקדימה אותה, לרענן, לשנות, או מה לא. 

ואני יכול פשוט למחוק, וזה ייעלם. אבל בואו נעשה דברים עם פקודה קו לעת עתה, כדי להרגיש בנוח עם זה, לבצע את הפעולות הבאות. אני הולך להמשיך ולהסיר a.out ידי הקלדת ממש rma.out. מתברר, את הפקודה עבור הסרה או מחיקה של משהו, הוא לא להסיר או למחוק. 

זה יותר בתמציתיות RM, רק כדי לחסוך לך כמה קשה, וקש Enter. עכשיו אנחנו הולכים להיות מעט בלי לפרש להסיר a.out קובץ רגיל. אני באמת לא יודע מה קובץ לא סדיר יהיה עדיין. אבל אני רוצה להסיר אותו. 

אז אני הולך להקליד y עבור yes. או שאני יכול להקליד את זה, וקש Enter. וגם, שוב, שום דבר לא נראה לקרות. אבל זה, באופן כללי, דבר טוב. 

אם אני אדפיס LS הפעם, מה אני אמור לראות? יש לקוות, רק שלום hello.c. עכשיו, במאמר מוסגר, תקבל לב כוכבים זה, כוכבי, זה בסוף התוכניות שלי. והם גם להופיע בירוק. זה פשוט דרכו של CS50 IDE של cluing אותך לתוך העובדה כי זה לא קוד המקור. זהו קובץ הפעלה, runnable תוכנית שאתה באמת יכול לרוץ על ידי עושה לוכסן נקודה, ואז זה שם. 

עכשיו, תן לי להמשיך ולהסיר זה, rm שלום, זן, להסיר קבוע להגיש שלום, כן. ועכשיו אם אני מקליד LS, חזרנו לנקודת hello.c. נסו לא למחוק שלך קוד מקור ממשי. למרות שישנם תכונות מובנה בתוך IDE CS50 שם אתה יכול לעבור היסטוריית הגרסאות אחורה בזמן אם בטעות למחוק משהו, לעשות להיות זהיר לפי הבקשות האלה כן או לא, של מה שאתה באמת רוצה לעשות. ואם אני הולך עד לקצה בפינה שמאלית יד כאן, כל מה שנשאר זה hello.c. אז יש אשכולות פקודות אחרות שאתה יכול לבצע בעולם של לינוקס, אחד מהם הוא, שוב, הפוך. ואנחנו הולכים לעשות התוכנית שלי עכשיו כדלקמן. 

במקום לעשות צלצול, במקום לעשות צלצול-o, אני הולך פשוט הקלד פשוטו כמשמעו, להפוך שלום. ועכשיו לב, אני לא הקליד לעשות hello.c. אני מקליד לעשות שלום. 

תוכנית זו תעשה את זה מגיע עם IDE CS50, ועוד בדרך כלל עם לינוקס, היא תוכנית זה הולך לעשות תוכנית בשם שלום. וזה הולך להניח, לפי האמנה, שאם תוכנית זו יכולה להתבצע, זה הולך להתבצע ממקור קובץ קוד המסתיים ג נקודה, hello.c. 

אז אם אני מכה זן חברה, הודעה כי הפקודה שמקבל להורג הוא בעצם אף יותר לפני יותר מבעבר. וזה כי יש לנו IDE CS50 מוגדר מראש שיהיה כמה תכונות נוספות שנבנו כי אנחנו לא צריכים עדיין, אבל בקרוב. אבל הדבר העיקרי שיש לממש כרגע היא יש לי תוכנית שלום. 

אם אני אדפיס LS שוב, אני יש תוכנית שלום. ואני יכול להפעיל אותו עם נקודה סלאש a.out, לא, כי כל העניין של זה התרגיל היה שלום לוכסן נקודה. ועכשיו יש לי תכנית שלום העולם שלי. אז לנוע קדימה, אנחנו כמעט תמיד רק הולך לקמפל התוכניות שלנו באמצעות ביצוע הפקודה. ואז אנחנו הולכים להפעיל אותם על ידי נקודה סלאש, ואת שמו של התוכנית. אבל מבין מה לעשות הוא עושה עבור אתה, זה הוא עצמו לא מהדר. זה פשוט תוכנית נוחות שיודע להפעיל מהדר כך לרוץ כי אתה עצמך יכול להשתמש בו. 

מה פקודות אחרות להתקיים לינוקס, ו בתורו את IDE CS50? אנו בקרוב לראות שיש CD פקודה, שנת מדריך. זה מאפשר לך בתוך ממשק שורת הפקודה שלך כדי להתקדם, ובחזרה, ולפתוח תיקיות שונות ללא שימוש בעכבר. 

LS ראינו, אשר מייצג רשימה את הקבצים בספרייה הנוכחית. הפוך דיר, אתה יכול כנראה מתחיל להסיק מה אלה אומרים now-- לעשות בספרייה, אם אתה רוצה ליצור תיקייה. RM עבור הסרת RM דיר עבור להסיר directory-- ואלה, שוב, הם שורת הפקודה ושווי של מה שאתה יכול לעשות CS50 IDE עם העכבר. אבל בקרוב תוכל למצוא כי לפעמים זה פשוט הרבה יותר מהר לעשות דברים עם מקלדת, ובסופו של דבר הרבה יותר חזק. 

אבל קשה לטעון כי דבר שעשינו עד כה כל זה עוצמה, כאשר כל אנחנו כבר אומרים הוא, hello world. ואכן, אני hardcoded מילים hello world לתוכנית שלי. אין דינמי עדיין. Scratch היה בסדר גודל יותר מעניין בשבוע שעבר. 

וכך בוא להגיע לשם. בואו ניקח צעד לקראת שעד הדרך של חלק מהפעולות הללו. אז לא רק C לבוא עם printf, וזרי פונקציות אחרות שחלקם נראים לאורך זמן, זה לא לעשות את זה כל כך קל היישר השער לקבל קלט משתמש. 

למעשה, אחת החולשות של שפות כמו C, ואפילו Java ובכל זאת אחרים, הוא שזה לא לעשות את זה קל פשוט לקבל דברים כמו מספרים שלמים ממשתמשים, או מחרוזות, מילים, וביטויים, קל וחומר דברים כמו צוף ערכי צבע, או מספרים ממשיים עם נקודות עשרוניות, ובאמת מספרים ארוכים, כפי שאנו בקרוב לראות. אז רשימה זו של פונקציות כאן, אלה הם כמו חלקי פאזל Scratch אחרים כי יש לנו מותקן מראש ב CS50 IDE כי נשתמש במשך כמה שבועות כמו גלגלי עזר של מיני, ועל בסופו של דבר לקחת אותם, ולחפש מתחת למכסה המנוע, אולי, איך הדברים האלה מיושמים. 

אבל כדי לעשות זאת, בואו למעשה לכתוב תוכנית. תן לי ללכת קדימה עכשיו. ואני הולך ליצור חדש קובץ על ידי לחיצה בתוספת הקטנה הזה, ולחיצת קובץ חדש. 

אני הולך לחסוך הבא אחד כמו, נניח, string.c, כי אני רוצה לשחק עם מחרוזות. ומחרוזת ב- C היא רק רצף של תווים. אז עכשיו בואו נלך קדימה ובצע את הפעולות הבאות. 

כלול תקן IO.h-- ו מתברר תקן IO, IO רק אומר קלט ופלט. אז מתברר כי הקו הזה כאן הוא מה היש השכנות לנו להשתמש printf. Printf, כמובן, מפיקה פלט. אז כדי להשתמש printf, מסתבר מתוך אתה צריך שיהיה לך את שורת הקוד בחלק העליון של הקובץ שלך. 

ואנחנו נחזור למה זה באמת אומר לפני זמן רב. מתברר כי ב כל תוכנית C אני כותב, אני מוכרח להתחיל אותו עם קוד זה נראה ככה. ותבחין CS50 IDE, וכן פיתוח משולב אחרים סביבות כמו זה, הולכים לנסות כמיטב הם יכולים לסיים המחשבה שלך. למעשה, רגע לפני אם אני לבטל מה בדיוק עשיתי, אני מכה על Enter. 

אז אני מכה מתולתל פתוח וכתפיות, על Enter שוב. וזה סיים את המחשבה שלי. זה נתן לי קו חדש, מסוכסך לא פחות מסיבות סגנונית נחמדות נראים. ואז זה אוטומטית נתן לי סד מתולתל לסיים המחשבה שלי. עכשיו, זה לא תמיד נחשו מה שאתה רוצה לעשות. אבל במידה רבה, זה עושה לחסוך לכם קצת הקשות. אז לפני רגע, רצנו program-- זה שלום, עולם, ולאחר מכן הידור זה, ואחר כך העביר אותה. אבל אין הדינמיות כאן. מה אם אנחנו רוצים לעשות משהו שונה? ובכן, מה אם אני רוצה באמת לקבל מחרוזת מהמשתמש? אני הולך להשתמש פיסת הפאזל קרא בדיוק ש-- לקבל מחרוזת. 

מסתבר ב- C שכאשר אתה לא רוצה כדי לספק קלט חתיכת פאזל, או יותר כראוי לפונקציה, אתה פשוטו כמשמעו פשוט לעשות סוגריים פתוחים, בסוגריים קרובים. אז זה כאילו יש אין קופסה לבנה להקליד. הבלוק תניח לפני הייתה קופסא לבנה קטנה. אין לנו כי קופסה לבנה עכשיו. 

אבל כאשר אני קורא מחרוזת מקבל, אני רוצה לשים את התוצאה איפשהו. אז פרדיגמה נפוצה מאוד ב- C היא לקרוא לפונקציה, כמו מחרוזת להגיע לכאן, ולאחר מכן לאחסן ערך החזרה שלה. זוהי התוצאה של שלו מאמץ במשהו. 

ומהי לבנות בתכנות, בין אם גירוד או חברת C, כי אנחנו יכול להשתמש בו כדי לאחסן משהו באמת? קרא לזה משתנה, נכון? ובכל Scratch, שאנחנו לא באמת אכפת מה קורה במשתנים. 

אבל במקרה הזה, אנחנו באמת עושים. אני הולך לומר מחרוזת. ואז יכולתי לקרוא זה כל מה שאני רוצה. אני הולך לקרוא לזה שם, מקבל מקבל מחרוזת. 

ועכשיו גם אם אתה חדש קטן זה, שם לב שאני חסר איזה פרט. אני שוכח בנקודה פסיק. אני צריך לסיים את המחשבה הזאת. אז אני הולך להזיז את הסמן שלי, והכה-פסיק שם. ומה יש לי רק לעשות? בקו הזה של קוד, מספר 5 כרגע, אני מתקשר מחרוזת גט ללא תשומות. אז אין שום מעט לבן תיבה בדומה לאזור השמור יש. 

אני רק אומר, היי, מחשב, להשיג לי מחרוזת. סימן השוויון הוא לא באמת סימן שוויון, כשלעצמה. זה המשימה מפעיל, כלומר, היי, מחשב, הזז את הערך מימין למעלה משמאל. וגם משמאל, יש לי את הדברים הבאים. 

היי, המחשב, תן לי string-- רצף של תווים. ולקרוא כי שם מחרוזת. ואני אפילו לא צריך לקרוא לזה שם. 

יכולתי לקרוא לזה, כמקובל, משהו כמו S, בדומה השתמשנו ט קוראים המשתנים i. אבל עכשיו אני צריך לעשות עם זה משהו. זה יהיה די טיפשי לנסות להרכיב את הקוד הזה, ריצה תוכנית זו, למרות אני מקבל מחרוזת, כי זה עדיין רק מתכוון לומר לי שלום העולם. 

אבל מה אם אני רוצה לשנות את זה. למה אני לא עושה את זה? ים אחוז, פסיק הים. וזה לא ברור מספיק עדיין. 

אז תן לי לעשות המשתנים שלי יותר ברורים. תן לי שם שם משתנה זה. ובואו נראה אם ​​אנחנו לא יכולים להקניט מלבד מה שקורה כאן. 

אז על קו חמש, אני מקבל מחרוזת. ואני לאחסון מחרוזת, מה שהמשתמש הקליד על המקלדת שלו או שלה, במשתנה שנקרא שם. ומתברר כי printf לא רק לקחת טיעון אחד כפול ציטוטים, קלט אחד במרכאות כפולות. 

זה יכול לקחת שניים או שלושה, או יותר, כגון כי השני, או שלישי, או רביעי, הם כל השמות משתנים, או ערכי במיוחד, כי אתה רוצה לחבר אל, באופן דינמי, מחרוזת במרכאות. במילים אחרות, מה יהיה בסדר עם זה? אם אני רק אמרתי שלום שם, קו נטוי הפוך n, הציל את התיק שלי, הידור הקוד שלי, ורץ זו, מה יקרה? 

זה פשוט הולך להגיד, שלום שם, פשוטו כמשמעו N-A-M-E, וזה די טיפשי כי זה לא שונה מהעולם. אז דבר במרכאות הוא מה ממש יודפס. אז אם אני רוצה שיהיה לי מציין מיקום שם, אני באמת צריך להשתמש כמה תחביר מיוחד. ומתברר אם אתה קורא את בתיעוד של הפונקציה printf, זה יגיד לך את זה אם אתה משתמש s אחוזים, תוכל להחליף ערך כדלקמן. 

לאחר פסיק אחרי זה מרכאות כפולות, אתה פשוט לכתוב את השם של המשתנה שאתה רוצה לחבר לתוך התבנית קוד, או מציינים בפורמט, s אחוזים עבור מחרוזות. ועכשיו אם שמרתי את התיק שלי, אני חוזר אל המסוף שלי. ואני להקליד הפוך המיתרים, כי, שוב, בשם זה קובץ שבחרתי לפני הוא string.c. 

אז אני הולך להגיד הפוך מחרוזת, זן. אלוהים אדירים, מסתכל על כל הטעויות שעשינו כבר. וזה אז-- מה, זה באמת כמו תוכנית קו שש, שבע? אז זה המקום שבו זה יכול מאוד מהר לקבל מכריע. 

חלון מסוף זה יש עכשיו רק שחזרה בה מספר עצום של הודעות שגיאה. אין ספק, אין לי שגיאה יותר יש הודעות ממה שאני שורות קוד. אז מה קורה פה? 

ובכן, האסטרטגיה הטובה ביותר כדי לעשות זאת בכל עת לך אל נתקלים המכריע רשימה של טעויות כאלה, הוא לגלול אחורה, לחפש את הפקודה אתה פשוט רץ, שבמקרה שלי הוא להפוך מחרוזת. תראה מה עושה עשה, וזהו פקודה ארוכה קלאנג, לא ביג דיל שם. 

אבל אדום זה רע. גרין מנסה להיות עדין ומועיל. אבל זה עדיין רע, במקרה זה. אבל איפה זה רע? 

String.c, קו חמש, אופי חמש. אז זה רק כנס משותף. משהו נקודות משהו אומר מספר הקו ומספר הדמות. שגיאה, שימוש לא מוצהר מחרוזת מזהה. האם התכוונת סטנדרטי? 

לכן, למרבה הצער, קלאנג מנסה להיות מועיל. אבל זה לא נכון, במקרה הזה. לא, קלאנג, לא התכוונתי תקן IO. התכוונתי כי בשורה אחת, כן. 

אבל קו חמש הוא אחד זה כאן. ו קלאנג לא להבין S-T-R-I-N-G. זהו מזהה מוצהר, מילה זה פשוט מעולם לא ראה לפני כן. וזה משום C, השפה אנחנו כותבים קוד ב עכשיו, אין משתנה בשם בחוטים. 

זה לא, כברירת מחדל, תמיכה משהו שנקרא מחרוזת. זה חתיכת CS50 של בז'רגון, אבל מאוד קונבנציונאלי. אבל אני יכול לתקן את זה כדלקמן. 

אם אני מוסיף שורה אחת של קוד לחלק העליון של תכנית זו, כולל CS50.h, שהוא קובץ אחר איפשהו בתוך CS50 IDE, איפשהו על הכונן הקשיח, אם אפשר לומר כך, של מערכת ההפעלה אובונטו כי אני רצתי, כי הקובץ הוא זה הולך ללמד את ההפעלה מערכה מה מחרוזת הוא, רק כמו io.h הסטנדרטי הוא הקובץ במערכת ההפעלה זה הולך ללמד אותו מה הוא printf. 

ואכן, היינו התבגרתי הודעה דומה מאוד אם IO הודה תקן IO.h וניסה להשתמש printf. אז אני הולך קדימה ופשוט להשתלט L כדי לנקות את המסך שלי. או שאתה יכול להקליד ברור וזה יהיה רק לנקות את חלון המסוף. אבל אתה עדיין יכול לגלול אחורה בזמן. 

ואני הולך להפעיל מחדש הפוך מחרוזת. תחזיק אצבעות שלי הפעם, Enter. אוי אלוהים, זה עבד. זה מראה לי פקודה ארוכה נסתרה זה מה להרוויח שנוצר באמצעות קלאנג, אבל אין הודעות שגיאה. אז להבין, למרות אתה עלול לקבל לחלוטין מוצף מספר הודעות שגיאה, זה רק יכול להיות מדורג מעצבן זה אפקט, שבו קלאנג לא מבין דבר אחד, מה שאומר שזה אז לא מבין את המילה הבאה, או לשורה הבאה. וכך זה פשוט חונק על הקוד שלך. אבל התיקון עשוי להיות פשוט. וכך תמיד להתמקד השורה הראשונה של פלט. ואם לא תעשה זאת להבין את זה, רק להסתכל עבור מילות מפתח שעשוי להיות רמזים, ואת מספר השורה, ואת האופי, שם טעות זה יכול להיות. 

עכשיו תן לי ללכת קדימה להקליד נקודת סלאש, מחרוזת, זן. Hm, זה לא אומר שלום כלום. למה? ובכן, זוכר איפה הוא פועל? 

זה כנראה תקוע כרגע בתוך לולאה, אם תרצו, על קו שש, כי קבל מחרוזת ידי עיצוב, נכתב על ידי צוות CS50, נועד ממש פשוט לשבת שם מחכה, ומחכה, ומחכה מחרוזת. כל מה שאנחנו מתכוונים מחרוזת הוא קלט אנושי. אז אתה יודע מה? תן לי ללכת קדימה. ובדיוק על גחמה, תן לי הקלד את השם שלי, דוד, הזן. עכשיו יש לי תוכנית דינמית יותר. היה כתוב שם, שלום דוד. 

אם אני הולך קדימה ולרוץ זה שוב, תן לי לנסות להגיד את שם Zamila, זן. ועכשיו יש לנו תוכנית דינמית. אני לא מקודד קשה בעולם. אני לא מקודד קשה שם, או דוד, או Zamila. 

עכשיו זה הרבה יותר כמו התוכניות אנחנו יודעים, שאם זה לקחת קלט, היא מייצרת פלט שונה במקצת. עכשיו, זה לא הכי טוב חוויית המשתמש, או UX. אני מנהל את התוכנית. 

אני לא יודע מה אני אמור לעשות, אלא אם כן אני ממש מסתכל או לזכור את קוד המקור. אז בואו נעשה את המשתמש לחוות קצת יותר טוב עם את הדברים הפשוטים ביותר. תן לי לחזור לתוך זה התוכנית, ופשוט לומר printf. 

ותן לי באים ואומרים שם, מעי גס, וכן שטח ולאחר מכן נקודת פסיק. ובדיוק בשביל כיף, לא n החריף. וזה מכוון, כי אני לא רוצה הבשורה לעבור לשורה הבאה. 

אני רוצה, במקום, לעשות את זה, לעשות מחרוזת להדר מחדש את הקוד שלי לתוך מכונה חדש קוד נקודה סלאש מחרוזת. אה, זה הרבה יותר יפה. עכשיו אני באמת יודע מה המחשב רוצה שתעשה, נותן לו שם. 

אז אני הולך קדימה, הקלד ב רוב, הזן, ואת שלום, רוב. אז, להבין, זה עדיין, בסוף היום, תוכנית קו תשע בלבד. אבל ביצענו את הפעולות אלה התינוק. 

כתבנו שורה אחת שבה אנו מוכר, printf היו, hello world. אז אנחנו התרנו קצת זה. ואנחנו נעשינו שימוש בפועל מחרוזת גט. ואנחנו השלכנו ערך במשתנה. ואז הלכנו קדימה ומשופר זה עוד יותר עם שורה שלישית. וזה תהליך חוזר ונשנה זה של כתיבת תוכנה היא באמת מפתח. ב CS50, ובחיים בכלל, לא כדאי בדרך כלל לשבת, יש תוכנית בראש, ולנסות בכתב הדבר הארור בבת אחת. 

זה יהיה, בהכרח, לגרום בדרך יותר טעויות ממה שאנחנו עצמנו ראו כאן. אפילו אני, עד עצם היום הזה, כל זמן עושה טעויות טיפשיות אחרות, הם אכן שגיאות יותר כי קשה יותר להבין. אבל אתה תעשה יותר טעויות יותר שורות קוד שאתה כותב בבת אחת. וכך נוהג זה של, לכתוב קצת קוד קטן כי אתה מרגיש בנוח עם, לקמפל זה, להפעיל אותו, לבדוק את זה באופן כללי יותר, ואז לעבור on-- כל כך פשוט כמו ששמרנו שכבות ו שכבות בשבוע שעבר, בניית ממשהו מאוד פשוט משהו יותר מורכב, לעשות את אותו הדבר כאן. לא לשבת, ולנסות לכתוב הבעיה כולה. למעשה לנקוט צעדים אלה התינוק. 

עכשיו, מחרוזות אינן כל כי שימושי בפני עצמה. היינו למעשה, באופן אידיאלי, כמו כדי יש משהו אחר ערכת הכלים שלנו. אז בואו באמת לעשות בדיוק את זה. 

תן לי ללכת קדימה עכשיו להלהיב תוכנית שונה במקצת. ואנחנו נתקשר int.c זה, עבור מספר שלם. אני הולך, באופן דומה, כולל CS550.h. אני הולך לכלול תקן IO. וזה הולך להיות די נפוץ בימים הראשונים האלה של המעמד. 

ואני הולך מוכן עצמי עם פונקציה עיקרית. ועכשיו במקום לקבל מחרוזת, בואו נלך קדימה ולקבל int. בואו לקרוא את זה אני, וקוראים לזה לקבל int, סימני סגור סוגריים, פסיק. ועכשיו בואו נעשה עם זה משהו, printf. 

נניח משהו כמו שלום, מהלך סרק n, פסיק i. אז אני פחות או יותר מחקתי מה שעשיתי עד לפני רגע. יש לי מציין מיקום כאן. יש לי פסיק אני כאן, כי אני רוצה כדי לסתום לי לתוך מציין מיקום. 

אז בואו להמשיך ולנסות קומפילציה תוכנית זו. הקובץ נקרא int.c. אז אני הולך להגיד, לעשות int, זן. אוי אלוהים, אבל לא ביג דיל, נכון? יש טעות. 

יש טעות תחבירית כאן הוא כזה, התכנית לא יכולה הידור בתוך int.c, קו שבע, אופי 27, בפורמט שגיאה מציין סוג char לככב, מה שזה לא יהיה. אבל את סוג הטיעון הוא int. 

אז הנה, גם אנחנו לא הולכים עם-- למרות שכיום הוא הרבה חומר, אנחנו הולכים להציף אותך עם בהחלט כל תכונה של C, תכנות באופן כללי יותר, רק בשבועות הראשונים האלה. לכן לעתים קרובות יש הולך להיות בז'רגון שבה אתה לא מכיר. ואכן, כוכב char הוא משהו אנחנו הולכים לחזור בעוד שבוע או זמן של השני. 

אבל לעת עתה, בואו נראה אם ​​אנחנו יכולים לנתח מילים שאינן מוכרות. Formats-- כך שמענו בפורמט מציין, קוד בפורמט לפני. זה מוכר. Type-- אבל הטיעון יש int סוג. חכה רגע, אני הוא int. 

אולי s אחוזים למעשה יש משמעות מוגדרת. ואכן, היא עושה. מספר שלם, אם אתה רוצה printf כדי להחליף אותו, אתה באמת צריך להשתמש מציין בפורמט שונה. ואתה לא היית יודע את זה אלא אם מישהו היה אומר לך, או שאתה עשית את זה קודם. אבל אני אחוז מה ניתן נפוץ ב printf עבור חיבור שלם. אתה יכול גם להשתמש אחוזים ד עבור מספר שלם עשרוני. אבל אני הוא נחמד ופשוט כאן. אז אנחנו נלך עם זה. 

עכשיו תן לי ללכת קדימה שידור חוזר לעשות int, Enter. זה טוב, ללא שגיאות. Dot סלאש אישור int--, חוויית המשתמש רע, כי לא אמרתי לעצמי מה לעשות. אבל זה בסדר. אני תופס מהר. 

ועכשיו תן לי ללכת קדימה להקליד דוד, בסדר, Zamila, רוב. אוקיי, אז זה דבר טוב. הפעם, אני משתמש פונקציה, חתיכת פאזל, שנקראת int גט. וזה הופך out-- ואנו בהמשך זה term-- צוות CS50 יישם לקבל מחרוזת בצורה כזאת כי זה יהיה רק ​​פיזי לקבל מחרוזת בשבילך. 

זה יישם גט int ב באופן כזה זה יהיה רק לקבל מספר שלם בשבילך. ואם אתה, האדם, לא לשתף פעולה, זה פשוטו כמשמעו פשוט הולך לומר שוב, שוב, שוב, יושב שם ממש looping, עד אתה חסד עם כמה מספר קסום, כמו 50, וברכת שלום 50. 

או אם נריץ את זה שוב וסוג ב -42, שלום 42. וכך הפונקציה int הגט בתוך כי פיסת הפאזל היגיון מספיק, מספיק מחשבה, כדי להבין, מה היא מילה? ומה הוא מספר? רק לקבל, בסופו של דבר, מספרים. 

אז מתברר כי זו לא כל הוא כי הבעה. עד כה. אז, יש! הפעם האחרונה שאנחנו הלכתי די מהר לתוך משחקים ליישום, ואנימציה, ויצירות אמנותיות Scratch. והנה, אנחנו להיות תוכן עם שלום העולם, שלום 50. 

זה לא כל כך מעורר השראה. ואכן, תחילה אלה כמה דוגמאות תיקחנה קצת זמן יעלה בהתרגשות. אבל יש לנו כל כך הרבה יותר לשלוט עכשיו, למעשה. ואנחנו הולכים מאוד להתחיל במהירות שכבות על גבי הפרימיטיבים בסיסיים אלה. 

אבל קודם, בואו להבין מה הן המגבלות. למעשה, אחד הדברים גרד לא בקלות תנו לנו לעשות הוא באמת נראה מתחת למכסה המנוע, ולהבין איזה מחשב הוא, מה הוא יכול לעשות, ומה מגבלותיו הם. ואכן, כי חוסר הבנה, באופן פוטנציאלי, לטווח ארוך יכול להוביל לכתיבה mistakes-- משלנו באגים, כתיבת תוכנה מאובטחת נפרץ בדרך כלשהי. 

אז בואו לקחת כמה צעדים לכיוון הבנה טובה יותר קצת זה על ידי דרך, אומר, בדוגמא הבאה. אני הולך קדימה וליישם ממש מהר תוכנית בשם Adder. כאילו, בואו להוסיף קצת מספרים יחד. ואני הולך לקודד כמה פינות כאן, ופשוט להעתיק ולהדביק איפה הייתי לפני, רק כדי שנוכל להתחיל מוקדם יותר. אז עכשיו יש לי את ראשיתו הבסיסית של תוכנית בשם Adder. 

ובואו אתם מוזמנים לעשות זאת. אני הולך קדימה, נניח, intx מקבל לקבל int. ואתם יודעים מה? בואו נעשה את חווית משתמש טובה יותר. 

אז בוא נגיד x הוא, וביעילות מהמשתמש לתת לנו x. ואז הם נתנו לי באים ואומרים, printf מה דעתך על y הוא, הפעם מצפה שני ערכים מהמשתמש. ואז בואו פשוט להמשיך נניח, printf, סכום של x ו- y הוא. ועכשיו אני לא רוצה לעשות s אחוזים. אני רוצה לעשות אני אחוזים, מהלך סרק n, ולאחר מכן חבר בשווי סכום. 

אז איך אני יכול ללכת על עושה את זה? אתה יודע מה? אני יודע איך להשתמש משתנה. תן לי רק להכריז על אחד חדש, int z. 

ואני הולך לקחת ניחוש כאן. אם ישנם סימנים שווים זה השפה, אולי אני פשוט יכול לעשות X ועוד Y, כל עוד אני מסיים שלי חשבתי עם פסיק? עכשיו אני יכול לחזור לכאן, תקע z, לסיים את המחשבה הזאת עם-פסיק. ובואו לראות עכשיו, אם אלה רצפים של x lines-- הוא לקבל int. Y הוא לקבל int. 

להוסיף x ו- y, לאחסן את הערך z-- כך, שוב, זוכר את סימן השוויון הוא לא שווה. זה משימה מימין לשמאל. ובואו להדפיס שהסכום של x ו- y הוא לא ממש z, אבל מה יש בפנים של z. אז בואו נעשה את Adder - טעויות נחמדות, לא הפעם. Dot סלאש Adder, הזן, x הולך להיות 1. 

Y הולך להיות 2. ואת הסכום של x ו- y הוא 3. אז זה הכל טוב ויפה. 

אז היית לדמיין במתמטיקה כי צריך לעבוד תוכנית כזאת. אבל אתה יודע מה? האם משתנה זה, קו 12, אפילו הכרחי? אתה לא צריך לקבל את הרגל רק לאחסון דברים משתנים רק בגלל שאתה יכול. ואכן, זה בדרך כלל עיצוב רע שקולה אם אתה יוצר משתנה, נקרא z במקרה זה, אחסון משהו בתוכו, ומיד השימוש בו, אבל לעולם לא עוד. למה לתת משהו שם כמו z אם אתה ממש הולך להשתמש כי דבר רק פעם אחת, ולכן הפרוקסימלי שבו יצרת זה מלכתחילה, כל כך קרוב במונחים של שורות קוד? אז אתה יודע מה? מתברר כי C הוא די גמיש. אם אני באמת רוצה תוספת ערכים כאן, אני לא צריך להכריז על משתנה חדש. יכולתי רק תוספת X ועוד y, כי C מבין אריתמטיקה, ומפעיל מתמטי. 

אז אני יכול לומר פשוט, לעשות את המתמטיקה הזאת, X ועוד Y, מה הערכים האלה, תקע שהתקבל שלם לתוך אותה מחרוזת. אז זה יכול להיות, אם כי רק שורה אחת קצרה, עיצוב טוב יותר, תוכנית טובה יותר, משום שיש להם פחות קוד, ולכן פחות בשבילי להבין. וזה גם רק מנקה, ככל שאנחנו לא החדרת מילים חדשות, סמלים חדשים, כמו z, למרות שהם לא ממש לשרת הרבה של מטרה. 

למרבה הצער, מתמטיקה היא לא כל שלפעמים אמין. בואו נלך קדימה ולעשות את זה. אני הולך קדימה עכשיו לבצע את הפעולות הבאות. 

בואו לעשות printf, אני אחוז, בתוספת אחוז אני, אהיה לי אחוזים, מהלך הסרק n. ואני הולך לעשות זה- XYX בתוספת y. אז אני פשוט הולך לשכתב זה מעט שונה כאן. תן לי רק לבצע בדיקה בסיסית מהירה. שוב, הבה לא נקדים את המאוחר. הפוך אפעה, אפעה לוכסן נקודה. x הוא 1, y הוא 2, 1 ו -2 הוא 3. אז זה טוב. אבל בואו לסבך את זה עכשיו קצת, וליצור קובץ חדש. 

אני הולך לקרוא את זה, אומר, ints, רב עבור מספרים שלמים. הרשו לי להתחיל איפה הייתי לפני רגע. אבל עכשיו בוא נעשה כמה קווים אחרים. תן לי ללכת ולעשות את הדברים הבאים, printf, אני אחוז, מינוס אחוז אני, אני אחוז הוא, פסיק x, y מינוס פסיק yx. אז אני עושה מעט מתמטיקה שונה שם. בוא נעשה עוד אחד. אז אחוז i פעמים אחוזים אני הוא אני אחוזים, מהלך סרק n. בואו תוספת x, ו- y, ופעמי x y. אנו נשתמש הכוכבית על המחשב לזמנים שלך. 

אינך משתמש x. x הוא שם משתנה כאן. אתה משתמש הכוכב לכפל. בוא נעשה עוד אחד. אני אחוז printf, מחולק על ידי i אחוזים, הוא אחוז אני, n לוכסן אחורי. XY מחולק y-- לכן אתה השתמשת נטוי C לעשות חלוקה. ובואו לעשות אחד אחר. שארית i אחוזים, מחולק על ידי i אחוזים, הוא i אחוזים. xy-- ועכשיו שארית הוא על מה שנשאר. כאשר אתה מנסה חלוקה המכנה לתוך מונה, כמה שנשאר כי אתה לא יכול לחלק את? 

אז אין ממש, בהכרח, סמל השתמשנו בבית הספר היסודי לכך. אבל יש ב C. אתה יכול אומרים x מודולו y, שם זה סימן אחוזים context-- זה מבלבל כשאתה בפנים של במרכאות כפולות, בתוך printf, אחוזים משמש מציין הפורמט. 

כאשר אתה משתמש אחוזים מחוץ כי ביטוי מתמטי, זה מפעיל מודולו עבור מודולרי arithmetic-- לענייננו כאן, רק אומר, מה הוא שארית x מחולקת y? אז x מחולק y היא y לוכסן x. מה את שארית x מחולק y? זה x mod y, כמתכנת הייתה אומרת. 

אז אם לא עשיתי שום טעויות פה, תן לי ints להמשיך ולעשות, בלשון רב, נחמד, ו ints לוכסן נקודה. ועכשיו בואו נלך קדימה לעשות, נניח, 1, 10. בסדר, 1 בתוספת 10 הוא 11, הצ'ק. 1 מינוס 10 הם 9 שליליים, לבדוק. 

1 פעמים 10 הן 10, צק. 1 חלק 10 הוא-- בסדר, אנחנו לדלג כי אחד. שארית 1 חלק 10 היא 1. זה נכון. אבל יש באג כאן. 

אז אחד שמתי שלי למסור, אינו נכון. אני מתכוון, זה קרוב ל -0. 1 חלק 10, אתה יודע, אם אנחנו חיתוך פינות, בטוח, זה אפס. אבל זה באמת צריך להיות 1/10, 0.1, או 0.10, 0.1000, או הלאה. 

זה לא באמת צריך להיות אפס. ובכן, מתברר כי המחשב הוא עושה ממש מה שאמרנו זה לעשות. אנחנו עושים מתמטיקה כמו x מחולק y. ושניהם x ו- y, לכל הקווים קוד קודם לכן, הם מספרים שלמים. 

יתר על כן, על קו 15, אנחנו לספר printf, היי, printf תוספת שלם an, תוספת שלמה, תוספת בתוך integer-- במיוחד x, ואז y ולאחר מכן x מחולק y. x ו- y הם ints. אנחנו טובים שם. 

אבל מה x מחולק x? x מחולק y צריך להיות, באופן מתמטי, 1/10, או 0.1, אשר הוא מספר ממשי, מספר ממשי שיש, באופן פוטנציאלי, נקודה עשרונית. זה לא שלם. 

אבל מה הוא הדבר הקרוב ביותר שלם כדי 1/10, או 0.1? כן, זה סוג של הוא אפס. 0.1 הוא כמו כל כך הרבה. ו 1 הוא הרבה זה. אז 1/10 הוא קרוב יותר 0 מאשר אחד. 

אז מה C עושה עבור us-- סוג של כי אמרנו שזה עם-- הוא מקצץ שלם זה. זה לוקח בערך, אשר שוב הוא אמור להיות משהו כמו 0.1000, 0 וכן הלאה. וזה מקצץ הכל לאחר הנקודה העשרונית כך שכל זה דברים, כי זה לא להשתלב ברעיון של מספר שלם, אשר רק הוא מספר כמו 1 שלילי, 0, 1, למעלה ולמטה, זה זורק הכל לאחר הנקודה העשרונית, כי אתה לא יכול להתאים נקודה עשרונית ב שלם מעצם הגדרתו. 

אז התשובה כאן היא אפס. אז איך אנחנו לתקן את זה? אנחנו צריכים פתרון אחר הכל ביחד. ואנחנו יכולים לעשות את זה, כדלקמן. 

תן לי ללכת קדימה וליצור חדש קובץ, זה אחד בשם floats.c. ולשמור אותו כאן באותה ספרייה, float.c. ותן לי להמשיך ולהעתיק חלק זה קוד קודם לכן. 

אבל במקום לקבל int, בוא נעשה את זה. תן לי ערךנקודהצפה בשם x. שם נקודה צפה הערך הוא רק באופן מילולי משהו עם נקודה צפה. זה יכול לנוע שמאלה, ימינה. זהו מספר אמיתי. 

ותנו לי לקרוא לא לקבל int, אבל לקבל לצוף, גם שהיה בין התפריט אופציות בספריית C250. בוא נשנה y ל float. אז זה הופך לקבל לצוף. 

ועכשיו, אנחנו לא רוצים לחבר ints. מתברר שאנחנו צריכים להשתמש אחוזים f עבור לצוף, אחוז f עבור לצוף, ועכשיו לשמור אותו. ועכשיו, אני מחזיק אצבעות, לעשות צוף, נחמד, צוף לוכסן נקודה. x הולך להיות אחד 1. y הולך להיות 10 שוב. 

וגם, נחמד, בסדר בנוסף שלי נכון. קיוויתי ליותר, אבל שכחתי לכתוב את זה. אז בואו נלך ולתקן זה טעות לוגית. 

בואו נלך קדימה לתפוס את הבאה. אנחנו פשוט נעשה העתיקו והדביקו מעט. ואני הולך להגיד מינוס. 

ואני הולך לומר פעמים. ואני הולך אומר מפולג. ואני לא מתכוון לעשות מודולו, וזה לא רלוונטי כמו כאן, מחולק f, ופעמים plus-- בסדר, בוא נעשה את זה שוב. 

צף הפוך, צף לוכסן נקודה, ו 1, 10, ו-- נחמד, לא, בסדר. אז אני אידיוט. אז זה נפוץ מאוד במדעי המחשב לעשות טעויות טיפשיות כמו זו. 

למטרות פדגוגיות, מה שאני באמת רוצה לעשות היה לשנות את המדע כאן לפלוס, מינוס, לזמנים, ולחלק, כמו שאתה מקווה לב במהלך התרגיל הזה. אז עכשיו בואו לקמפל מחדש זו התוכנית, לעשות צף לוכסן נקודה. 

ובפעם השלישית, בואו לראות אם היא עונה על הציפיות שלי. 1, 10, זן, כן, בסדר, 1.000, מחולק 10.000, הוא 0.100000. ומתברר אנחנו יכולים לשלוט כמה מספרים אחרי אלה נקודות עשרוניות. אנחנו בעצם. נחזור לזה. 

אבל עכשיו, למעשה, את המתמטיקה נכונה. אז, שוב, מה takeaway כאן? מתברר כי ב C, ישנם לא רק: המיתרים, ולמעשה, ישנם לא ממש, כי אנחנו להוסיף את אלה עם ספריית CS50. אבל יש לא רק ints. 

ישנם גם צף. ומתברר חבורה של נתונים אחרים סוגים מדי, כי נשתמש לפני זמן רב. מסתבר שאם אתה רוצה אחת אופי, לא מחרוזת של תווים, אתה יכול להשתמש רק char. 

מסתבר שאם אתה רוצה bool, ערך בוליאני, רק אמת או שקר, בזכות הספרייה CS50, יש לנו הוסיף ל- C סוג הנתונים bool גם כן. אבל זה גם להציג בשפות רבות אחרות גם כן. ומתברר שלפעמים אתה צריך מספרים גדולים ואז לבוא כברירת מחדל עם ints וצפים. 

ואכן, כפול הוא מספר המשתמשת לא 32 סיביות, אך 64 סיביות. וגם ארוך ארוך הוא מספר כי משתמש לא 32, ביטים אך 64 סיביות, בהתאמה, עבור נקודה צפה ערכים שלמים, בהתאמה. אז בואו למעשה חברה לראות את זה בפעולה. 

אני הולך קדימה כאן להלהיב בתוכנית אחת אחרת. הנה, אני הולך קדימה ואל כוללים CS50.h. ותנו לי ללכת, כולל תקן IO.h. 

ותבחין משהו פאנקי שקורה כאן. הוא לא בצבע קידוד דברים באותו אופן כפי שהיה לפני. ומתברר, כי הסיבה לכך היא שאני לא נתנו הדבר שם קובץ. 

אני הולך לקרוא את זה sizeof.c, ופגע שמור. ושימו לב מה קורה שלי מאוד קוד לבן נגד זה רקע שחור. עכשיו, לפחות יש כמה סגול שם. וזה תחביר הדגיש. 

הסיבה לכך היא, בפשטות, אין לי אמר IDE איזה סוג של קובץ זאת היא על ידי מתן שם, ו במיוחד סיומת קובץ. עכשיו, בואו נלך קדימה לעשות זאת. אני הולך קדימה, מאוד פשוט להדפיס את bool following-- אחוז הוא LU. 

אנחנו נחזור כי בעוד רגע. ואז אני הולך גודל bool הדפסה. ועכשיו, רק כדי לחסוך לעצמי קצת זמן, אני הולך לעשות כולה חבורה של אלה בעת ובעונה אחת. וגם, באופן ספציפי, אני הולך לשנות זאת על char והשם. אחד זה, אני הולך לשנות אל זוגי כפול. 

אחד זה, אני הולך לשנות ל float ו לצוף. אחד זה, אני הולך לעבור להשתמש int ו int. וזה אחד, אני הולך לשנות ארוך ארוך. וזה עדיין לוקח זמן רב, רב מאוד. 

ואז, לבסוף, נתתי עצמי אחת יותר מדי, מחרוזת. מתברר כי ב- C, יש המפעיל המיוחד הנקרא גודל זה פשוטו כמשמעו הולך, כאשר לרוץ, לספר לנו את הגודל לכל אחד מהמשתנים הללו. וזו דרך, עכשיו, אנו יכולים להתחבר בחזרה לדיון בשבוע שעבר נתונים וייצוג. 

תן לי ללכת קדימה ולעבד לגבי גודל לוכסן נקודה של. ובואו לראות. מתברר כי ב- C, במיוחד על CS50 IDE, במיוחד על מערכת ההפעלה אובונטו, שהינה 64 סיביות הפעלה המערכת במקרה זה, bool הולך להשתמש בייט שטח אחד. ככה גודל נמדד, לא בסיביות, אבל בבתים. ולהיזכר כי בית אחד הוא שמונה סיביות. אז bool, למרות שאתה מבחינה טכנית רק צריך 0 או 1, זה קצת בזבזני איך אנחנו יישמנו את זה. זה באמת הולך להשתמש כולה byte-- כך כל האפסים, הם אולי כל אלה, או משהו כזה, או רק אחד 1 בין שמונה סיביות. 

לדמות יש, בינתיים, המשמש דמות כמו תו ASCII בשבוע האחרון, הולך להיות תו אחד. וזה synchs עם הרעיון שלנו של זה להיות לא יותר מ 256 bits-- למדי, synchs עם זה להיות לא יותר 8 סיביות, אשר נותן לנו כמה שיותר 256 ערכים. דאבל הולך 8 בתים או 64 סיביות להיות. 

מצוף הוא 4. Int הוא 4. ארוך, ארוך הוא 8. וגם מחרוזת היא 8. אבל אין לך מה לדאוג זה. אנחנו הולכים לקלף את השכבה. מתברר, מחרוזות יכול עוד מ -8 בתים. 

ואכן, כתבנו מחרוזות כבר, hello world, למעלה מ -8 בתים. אבל נחזור אל כי בעוד רגע. אבל לקחת כאן הוא כדלקמן. 

יש כל מחשב רק סופי כמות זיכרון ושטח. אתה יכול לאחסן רק כל כך הרבה קבצים ב- Mac או במחשב האישי שלך. אתה יכול לאחסן כל כך הרבה תוכניות רק RAM פועל בבת אחת, בהכרח, גם עם זיכרון וירטואלי, משום יש לך כמות ה- RAM סופית. 

וזה רק כדי picture-- אם מעולם שפתחת את מחשב נייד או הורה זיכרון נוסף עבור מחשב, אתה אולי לא יודע בתוך המחשב משהו שנראה קצת כמו זה. אז זה רק חברה משותפת בשם חיוני שעושה RAM למחשבים. ורם הוא המקום שבו תוכניות לחיות בזמן שהן פועלות. 

אז עם כל Mac או PC, בעת לחיצה כפולה לחץ תוכנית, והיא פותחת, וזה פותח קצת מסמך Word או משהו כזה, הוא מאחסן אותו באופן זמני RAM, כי זיכרון RAM מהיר יותר מ הדיסק הקשיח, או דיסק המצב המוצק שלך. אז זה בדיוק איפה תוכניות ללכת לחיות כאשר הם רצים, או כאשר נמצאים בשימוש קבצים. 

אז אתה צריך דברים שנראים כמו בתוך זה של המחשב הנייד שלך, או מעט דברים גדולים בתוך שולחן העבודה שלך. אבל המפתח הוא רק יש לך מספר סופי של הדברים האלה. ויש רק כמות סופית של חומרה יושבת על שולחן זה תקין כאן. 

אז, בוודאי, אנחנו לא יכולים לאחסן מספרים באורך אינסופי. וגם, עדיין, אם אתה חושב בחזרה יכול בית ספר יסודי, כמה ספרות יש לך את הזכות של נקודה עשרונית? לצורך העניין, כמה ספרות יכול יש לך בצד שמאל של נקודה עשרונית? באמת, אינסוף. 

עכשיו, אנחנו בני אדם אולי רק יודע איך מבטאים מיליון, ו מיליארד, טריליון, ו קוודריליון, ו quintillion. ואני דוחף את הגבולות שלי understanding-- או my-- אני מבין מספרים, אבל שלי הגייה של מספרים. אבל הם יכולים לקבל גדולים לאין שיעור עם ספרות אינסוף שמאלה או בצד ימין של נקודה עשרונית. 

אבל מחשבים יש רק כמות הזיכרון סופית, מספר סופי של טרנזיסטורים, מספר סופי של נורות בפנים. אז מה קורה כאשר נגמר לך שטח? במילים אחרות, אם אתה נזכר בשבוע שעבר כשדיברנו על מספרים עצמם להיות מיוצגים בינארי, נניח שיש לנו 8 סיבי ערך זה כאן. 

ויש לנו שבע 1 של ואחד 0. ונניח שאנחנו רוצים להוסיף 1 לערך זה. זהו מספר ממש גדולים עכשיו. 

זהו 254, אם אני זוכר את המתמטיקה משבוע תקין האחרונה. אבל מה אם אני אשנה כי הימני ביותר 0 עד 1? המספר השלם, של כמובן, הופך שמונה 1 של. אז אנחנו עדיין טובים. 

וזה כנראה מייצג 255, אם כי תלוי בהקשר זה באמת יכול לייצג מספר שלילי. אבל עוד על כך בפעם אחרת. זה מרגיש כאילו הוא קשור גבוה ככל שאני יכול לספור. 

עכשיו, זה רק 8 סיבי. ו- Mac שלי, בוודאי, יש דרך יותר מ -8 ביטים של זיכרון. אבל זה צריך סופית. אז אותו הטיעון תקף, גם אם אנחנו יש יותר של אלה אלה במסך. 

אבל מה קורה אם אתה לאחסון המספר הזה, 255, ואתה רוצה לספור 1 קצת גבוה? אתה רוצה ללכת מ 255 ל 256. הבעיה, כמובן, היא שאם אתה מתחילים לספור על אפס כמו בשבוע שעבר, אתה לא יכול לסמוך גבוה כמו 256, שלא לדבר על 257, קל וחומר 258, מ 'מפני מה קורה כאשר אתה מוסיף 1? אם אתה עושה את הכיתה בבית הספר היסודי גישה, תש 1 כאן, ולאחר מכן 1 פלוס 1 הוא 2, אבל זה באמת אפס, אתם נושאים את 1, לשאת את 1, לשאת את 1. כל הדברים האלה, אלה 1 של, ללכת אפס. ואתה בסופו של דבר, כן, כמי ציין, 1 בצד שמאל. אבל כל מה שאתה יכול ממש לראות ולהשתלב לזכרו הוא רק שמונה 0 של, כלומר בשלב מסוים אם, מחשב, ספירת ניסה גבוה מספיק עד, אתה הולך לעטוף, כך נראה, לאפס, או אולי אפילו שלילי מספרים, שהן אפילו נמוך מאפס. 

ואנחנו סוג יכול של לראות את זה. תן לי להמשיך לכתוב תכנית מהירה אמיתית כאן. תן לי להמשיך לכתוב תוכנית בשם גדש את המקום. כלול CS50.h, כולל תקן IO.h-- הו, כמה שהתגעגעתי הדגשת התחביר שלי. אז בואו נשמור את זה כמו overflow.c. 

ועכשיו int void-- הראשי ולא עבר זמן רב, אנו יהיה לחזור כדי להסביר מדוע אנו כותבים כל הזמן void main int. אבל לעת עתה, בואו פשוט לעשות זה, לוקח את זה כמובן מאליו. בואו לתת את עצמי int, ו לאתחל אותו ל -0. 

בואו ואז לעשות עבור int אני מקבל zero-- למעשה, בוא נעשה את ללולאה אינסופית ולראות מה קורה. בעוד נכון, אז בואו להדפיס n הוא אחוז i, מהלך הסרק n, תוספת n. אבל, עכשיו, בוא נעשה n מקבל n פלוס 1. 

אז במילים אחרות, על כל איטרציה של לולאה אינסופית זו, בואו ניקח הערך של n, ולהוסיף 1 אליו, ולאחר מכן לאחסן את התוצאה בחזרה ב n בצד שמאל. ואכן, ראינו תחביר מעט ככה, בקצרה. טריק מגניב במקום כתיבת כל זה החוצה, אתה באמת יכול לומר שיש n בתוספת שווה 1. 

לחלופין, אם אתה באמת רוצה להיות מפואר, אתה יכול להגיד n פלוס פלוס-פסיק. אבל שני אלה האחרונים הם רק מה שהיינו קוראים סוכר תחבירי עבור הדבר הראשון. 

הדבר הראשון הוא יותר מפורש, לגמרי בסדר, לגמרי נכון. אבל זה נפוץ יותר, אני אגיד. אז אנחנו נעשה את זה רק לרגע. 

עכשיו בואו לעשות הצפה, שנשמע הצפת קו נטויה מבשרת רעה, נקודה למדי. בוא נראה, n הזה נהיה גדול למדי. אבל בואו נחשוב, כמה גדול יכול לקבל n? 

n הוא מספר שלם. ראינו את זה לפני רגע עם הגודל למשל כי int הוא ארבעה בתים. אנחנו יודעים משבוע שעבר, ארבעה בתים הם 32 סיביות, כי 8 פעמים 4, זה 32. זה הולך להיות 4 מיליארד. 

ואנחנו עד 800,000. זה הולך לקחת המון זמן לספור גבוה ככל שאני יכול להיות. אז אני הולך קדימה, כפי שאתה עלול לא עבר זמן רב, והכה בקרה C-- בכנות, בקרה C, הרבה, שבו בקרה C בדרך כלל אמצעי לבטל. למרבה הצער, בגלל זה פועל בענן, לפעמים הענן הוא יורקים כל כך הרבה דברים, כל כך הרבה פלט, זה הולך לקחת קצת זמן עבור הקלט שלי כדי להגיע אל הענן. אז למרות שאני פגעתי בקרת C לפני כמה שניות, זה בהחלט בצד השפעה ללולאה אינסופית. 

וכך במקרים כאלה, אנחנו הולך לעזוב כי להיות. ואנחנו הולכים להוסיף עוד חלון מסוף כאן עם פלוס, מה שכמובן לא ככה, שכן הוא עדיין חושב. ועכשיו בואו נלך קדימה ולהיות קצת יותר סביר. 

אני הולך קדימה, לעשות הפעמים היחידות סופי של זה. בואו להשתמש בלולאת for, שעליו רמזתי קודם לכן. בוא נעשה את זה. תן לי עוד int משתנה i מקבלת 0. אני הוא פחות, נניח, 64 i ++. ועכשיו תן לי ללכת קדימה ולהדפיס מתוך n הוא אחוז i, פסיק n. ואז n-- זה עדיין הולך לקחת לנצח. בוא נעשה את זה. 

n מקבל n פעמים 2. או שאנחנו יכולים להיות מפוארים ולעשות פעמים שווה 2. אבל בוא נגיד n שווה עצמה, פעמים 2. במילים אחרות, זה הגרסה החדשה של התוכנית, אני לא רוצה לחכות לנצח מ כמו 800,000 ל -4 מיליארד. בואו נגמור עם זה. 

בואו למעשה להכפיל n בכל פעם. איזה, כזכור, הכפלה היא ההפך שיש, כמובן. והואיל בשבוע שעבר יש לנו משהו שוב, ושוב, ושוב, סופר מהיר, הכפלה בוודאי לקבל אותנו מ -1 עד הגדול ביותר האפשרי ערך שנוכל לספור עד עם int. 

אז בוא נעשה את זה בדיוק. ואנו חייבים לחזור אליו תוך זמן קצר. אבל זה, שוב, בדיוק כמו הבלוק חוזר Scratch. ואתה תשתמש בזה לפני זמן רב. 

זה רק אומר לספור מאפס עד, אבל לא שווה, ל -64. ועל כל איטרציה של זה לולאה, רק להגדיל כל הזמן אני. אז i ++ - ואת המבנה הכללי הזה על קו 7 הוא רק דרך סופר משותף לחזור על כמה שורות של קוד, כמה וכמה פעמים. איזה שורות קוד? סוגריים מסולסלים אלה, כפי שאתה ייתכן שלוקטו עכשיו, פירושו, לבצע את הפעולות הבאות. 

הוא נמצא Scratch כמו, כאשר יש לו את אבני צהוב וצבעים אחרים מהסוג הזה לאמץ או לחבק בלוקים אחרים. זה מה אלה מתולתלים פלטות עושות כאן. אז אם יש לי התחביר שלי כן-- לך יכול לראות את סמל הגזר באמצעי C זה כמה פעמים הייתי מנסה לפתור את הבעיה הזו. אז בואו להיפטר שאחד לגמרי, לסגור את החלון. ואנחנו נשתמש אחד החדש. הפוך לוכסן הצפה, נקודה הצפה, זן, בסדר, זה נראה רע בהתחלה. אבל בואו לגלול אחורה בזמן, כי עשיתי פעמים 64 זה. 

ושימו לב לראשונה, n הוא 1. בפעם השנייה, n הוא 2, אז 4, אז 8, אז בן 16. ונראה כי ברגע אני מקבל בערך 1 מיליארד, אם אני להכפיל את זה שוב, כי צריך לתת לי 2 מיליארד דולר. אבל מתברר, זה ממש על הסף. 

וכך זה באמת עולה על גדותיו מספר שלם מ 1 מיליארד בערך שלילי 2 מיליארדים, כי מספר שלם, בניגוד אנו מספרים היו בהנחה בשבוע שעבר, יכול להיות חיובי ושלילי כאחד במציאות במחשב. וכך לפחות אחד מאותם ביטים נגנבו ביעילות. אז באמת יש לנו רק 31 סיביות, או 2 מיליארד ערכים אפשריים. 

אבל לעת עתה, את ממסעדה די פשוט, כל מה שמספרים אלו וכל מה את המתמטיקה היא, משהו רע קורה בסופו של דבר, כי בסופו של דבר אתה מנסה permute הביטים פעמים רבות מדי. ואתה ביעילות ללכת מכל 1+ כדי להתאים אולי כל 0 של, או אולי רק חלק דפוס אחר זה ברור, תלוי בהקשר, יכול להתפרש מספר שלילי. וכך זה היה נראה לי הגבוה ביותר יכול לספור בתכנית המסוימת הזה 1 מיליארד הוא רק בערך. אבל יש פתרון חלקי כאן. אתה יודע מה? 

תן לי לשנות מן int כדי ארוך ארוך. ותן לי להמשיך כאן ו say-- אני הולך להיות כדי לשנות זאת ל ארוך חתום. או, בוא נראה, אני לא זוכר את עצמי. 

בואו נלך קדימה ולבצע הצפה. לא, זה לא זה, LLD, תודה. אז לפעמים קלאנג יכול להיות מועיל. לא זכרתי מה הפורמט מציין היה במשך תקופה ארוכה ארוכה. 

אבל, אכן, קלאנג סיפר לי. ירוק הוא סוג כלשהו של טוב, עדיין אומר שטעית. זה ניחוש כי התכוונתי LLD. 

אז תן לי לקחת את זה עצה, רב מספר עשרוני ארוך, שמור את זה. ותנו לי להפעיל מחדש את זה, נקודה סלאש הצפה, Enter. ועכשיו מה זה מגניב זה. 

אם אני לגלול אחורה בזמן, אנחנו עדיין להתחיל לספור באותו place-- 1, 2, 4, 8, 16. שימו לב, אנחנו מקבלים את כל עד הדרך עד 1 מיליארד דולר. אבל אז אנחנו בבטחה להגיע -2 מיליארד שקל. 

אז אנחנו מקבלים עד 4 מיליארד דולר, אז 8 מיליארד דולר, 17 מיליארד. ואנחנו הולכים גבוהים יותר, גבוה יותר ויותר. בסופו של דבר, זה גם הפסקות. 

בסופו של דבר, עם זמן רב, שהינו הערך 64 סיביות, לא ערך של 32 סיביות, אם סופרים גבוה מדי, אתה לעטוף 0. וגם במקרה הזה, אנחנו לקרות בסופו של דבר עם מספר שלילי. 

אז מדובר בבעיה. ומתברר שזו הבעיה היא לא כל כך מסתורית. למרות שאני בכוונה שדחק בו עם הטעויות האלה, מתברר שאנחנו רואים את זה סוג של כל סביבנו, או לפחות חלק מאיתנו לעשות. 

אז לגו מלחמת הכוכבים, אם יצא לך פעם שיחק את המשחק, מתברר שאתה יכול להסתובב פירוק דברים בעולם לגו, איסוף מטבעות, בעצם. ואם ששיחקת אי פעם יותר מדי זמן דרך המשחק הזה, כפרט ללא שם זה כאן עשה, המספר הכולל של מטבעות שניתן לגבות עליהם הוא, כך נראה, 4 מיליארד. 

עכשיו, עם זה מעוגל למעשה. אז לגו ניסה לשמור דברים ידידותיים למשתמש. הם לא עושים את זה בדיוק 2 32 הכח, בשבוע שעבר. אבל 4 מיליארד סיבה. נראה, על סמך מידע זה, לגו כי, לבין החברה עשה בפועל באמצעות תוכנה זו, החליט כי המספר המרבי של מטבעות המשתמש יכול לצבור הוא, אכן, 4 מיליארד דולר, מכיוון שהם בחרו בקוד שלהם לא להשתמש זמן רב עבר, כנראה, אבל רק מספר שלם, חתום שלם, רק מספר חיובי, אשר ערך המקסימום הוא בערך זה. ובכן, הנה עוד אחד מצחיק. אז בסופו של Civilization המשחק, אשר חלק מכם עשוי להיות מוכר, עם מתברר כי לפני שנים יש היה באג לפיה המשחק הזה אם שיחק את התפקיד של גנדי במשחק, במקום אותו בתור בחור מאוד פציפיסטי, במקום היה מאוד, מאוד אגרסיבי, בנסיבות מסוימות. בפרט, את האופן שבו תרבות עבודות היא שאם אתה, השחקן, לאמץ דמוקרטיה, שלך ציון תוקפנות מקבל decremented ידי השנייה, כך מינוס מינוס, ולאחר מכן מינוס מינוס. 

אז מחסר 2 מ ולביקורות שלך בפועל. למרבה הצער, אם ולביקורות שלכם הן בתחילה 1, ואתה להחסיר 2 ממנו לאחר אימוץ הדמוקרטיה כמו גנדי כאן אולי עשה, כי הוא היה מאוד passive-- 1 על הסקאלה של תוקפנות. אבל אם הוא מאמץ דמוקרטיה, אז הוא הולך מ 1 כדי 1 שלילי. 

למרבה הצער, הם היו באמצעות מספרים שאינם חתומים, כלומר הם התייחסו אף שליליים המספרים כאילו היו חיוביים. ומתברר כי שווה ערך חיובי של 1 שלילי, בתוכנות מחשב טיפוסיות, הוא 255. אז אם גנדי מאמצת דמוקרטיה, ולכן יש ציון האגרסיביות שלו ירד, זה באמת מתגלגל עד 255 והופך אותו ביותר אופי אגרסיבי במשחק. אז אתם יכולים לגגל על ​​זה. וזה היה, אכן, באג תכנות בשוגג, אבל זה נכנס די לתורתנו מאז ועד היום. 

זה כל הכיף חמוד. יותר מפחיד הוא כאשר בפועל התקנים בעולם האמיתי, ולא משחקים, יש באגים אותם. למעשה, רק לפני שנה מאמר הגיע מתוך על בואינג 787. 

והמאמר בהתחלה במבט קורא מסתורי מעט. אבל הוא אמר את זה, תוכנה פגיעות בואינג של יש חדש 787 דרימליינר סילון הפוטנציאל לגרום טייסים לאבד את השליטה המטוס, ואולי בעיצומו של מעוף, פקידי FAA חברות תעופה הזהירה לאחרונה. זה היה הנחישות כי מודל 787 המטוס כבר מופעל ברציפות במשך 248 ימים יכול להפסיד את כל זרם חשמלי משתנה, AC, חשמל בשל גנרטור יחידות בקרה, GCUs, בו זמנית נכנס להיכשל במצב בטוח. זהו סוג של לאבד אותי. אבל התזכיר כאמור, אוקיי, עכשיו יש לי את זה, התנאי נגרם על ידי תוכנה נגד פנימי השליטה גנרטור יחידות כי יעלו על גדותיהם לאחר 248 ימים של חשמל רציף. אנחנו הנפקה זה לב כדי למנוע אובדן של כל AC החשמל כוח, אשר עלול לגרום לאובדן השליטה של ​​המטוס. 

אז, פשוטו כמשמעו, יש איזה מספר שלם, או איזה סוג מידע דומה, בשימוש בתוכנה במטוס בפועל כי אם אתה שומר את המטוס שלך מספיק זמן, שככל הנראה יכול להיות מקרה אם אתה פשוט רץ אותם כל הזמן ואף פעם לא ניתוק המטוס שלך, כך נראה, או ומאפשר הסוללות שלה למות, בסופו של דבר יהיה לספור עד ומעלה, ומעלה ומעלה, ומעלה, ומעלה. 

וגם, על ידי טבע, כמות הזיכרון סופית יעלה על גדותיו, מתגלגל חזרה אפס או כמה ערך שלילי, תופעת לוואי של המהווה את מציאות אמיתית להחריד כי המטוס עשוי להזדקק להיות rebooted, ביעילות, או עלול ליפול, גרוע, כמו זבובים. אז בעיות מסוג זה הם עדיין איתנו, even-- זה היה מאמר 2015, על אחת כמה וכמה מפחיד כאשר אתה עושה לא בהכרח להבין, להעריך, או לצפות מיני שגיאות אלה. 

אז מתברר שיש אחד אחר דבר רע על ייצוג מידע. מתברר שגם צף הם סוג של פגום, משום צף, גם הצעתי הם 32 סיביות, או אולי 64 אם אתה משתמש כפול. אבל זה עדיין סופי. 

וגם לתפוס את זה, אם הדבר אפשרי לשים מספר אינסופי של מספרים לאחר הנקודה העשרונית, אין דרך אתה יכול לייצג את כל האפשר מספרים כי לימדו אותנו ספר בכיתה יכול להתקיים בעולם. מחשב, בעצם, צריך לבחור קבוצת משנה של המספרים האלה לייצג באופן מדויק. 

עכשיו, המחשב יכול סיבוב אולי קצת, והוא יכול לאפשר לך בערך חנות כל מספר שאתה יכול לרצות. אבל רק באופן אינטואיטיבי, אם אתה יש מספר סופי של ביטים, אתה יכול רק permute אותם בכל כך הרבה דרכים סופיות. אז אתה לא יכול להשתמש מספר סופי של תמורה של ביטים, דפוסים של אפסים ואחדים, לייצג אינסופי מספר המספרים, אשר טוען כי מחשבים אולי טוב מאוד להיות משקרים לנו לפעמים. 

למעשה, בוא נעשה את זה. תן לי לחזור לתוך IDE CS50. תן לי ללכת קדימה ליצור תוכנה קטנה קרא חוסר דיוק, כדי להראות כי מחשבים הם, אכן, לא מדויקים. 

ותנו לי להתקדם ולהתחיל עם חלק הקוד מלפני, ועכשיו רק לבצע את הפעולות הבאות. תן לי ללכת ולעשות printf, אחוזים f, מהלך סרק n, 1 חלק 10. במילים אחרות, בואו לצלול עמוק יותר כדי 1/10, כמו 1 ומחולק 10. אין ספק, מחשב יכול לייצג 1/10. 

אז בואו נלך קדימה ולעשות חוסר דיוק. בוא נראה. פורמט מציין סוג כפול. אבל יש את הטיעון int סוג. מה קורה? 

אה, מעניין, אז זה כלקח מלפני. אני אומר, היי, להראות מחשב לי לצוף עם אחוזים f. אבל אני נותן אותו 2 ints. אז מתברר, אני יכול לתקן זאת בכמה דרכים. 

יכולתי פשוט להפוך אחד אל 1.0, ו 10 לתוך 10.0, אשר היה, אכן, יש את ההשפעה של המרה אותם floats-- עדיין מקווה מספר זהה. או מתברר שיש משהו נראים שוב תוך זמן קצר. אתה יכול להטיל את המספרים. 

אתה יכול, תוך שימוש בסוגריים זה ביטוי, אתה יכול להגיד, היי, מחשב, קח את זה 10, אשר אני יודע הוא int. אבל להתייחס אליו, בבקשה, כאילו שזה לצוף. אבל זה מרגיש שלא לצורך מורכב. 

לענייננו היום, בואו פשוט ממש להפוך אותם צפים ערכי צבע עם נקודה עשרונית, ככה. תן לי להמשיך בשידור חוזר, לעשות חוסר דיוק, טוב, לוכסן נקודה חוסר דיוק, זן. בסדר, אנחנו מחפשים טובים. 

1 חלק 10, על פי שלי Mac כאן, הוא, אכן, 0.100000. עכשיו, אותי לימדו בבית הספר היסודי שם צריך להיות מספר אינסופי של ספרות 0. אז בואו לפחות לנסות לראות כמה מאלה. מתברר כי printf הוא קצת להשתכלל עדיין ממה שאנחנו כבר משתמשים. מתברר שאתה לא צריך לציין רק אחוז f, או סתם אני אחוזים. למעשה אתה יכול לציין כמה אפשרויות שליטה כאן. 

באופן ספציפי, אני הולך לומר, היי, printf, למעשה להראות לי 10 נקודות עשרוניות. אז זה נראה לי קצת מוזר. אבל אתה אומר אחוזים, מספרי נקודה, כמה אתה רוצה לראות אחרי נקודה עשרונית, ולאחר מכן f עבור שטוח, רק בגלל זה מה בתיעוד אומר. תן לי ללכת קדימה ולשמור את זה. 

ושימו לב גם, אני מקבל נמאס להקליד מחדש דברים. אז אני רק קביעה מעלה חץ למטה על המפתחות שלי כאן. ואם אני ממשיך להכות, אתה יכול לראות את כל הפקודות כי עשיתי, או שגוי עשיתי. 

ואני הולך קדימה עכשיו לא ממש להשתמש בזה, כנראה. הפוך חוסר דיוק, נקודה סלאש imprecision-- כך מה שלימדו אותי בבית הספר יסודי בודק. גם אם אני להדפיס אותו עד 10 עשרוני מציב אותה, אכן, הוא 0.10000. אבל אתה יודע מה? 

בואו לקבל קצת חמדן. נניח, כמו, הראה לי 55 מצביע אחרי הנקודה העשרונית. בואו באמת לקחת את זה לתכנת לסיבוב. תן לי לסדר את זה עם איפור חוסר דיוק, לוכסן נקודה, אי-דיוק. 

והנה אנחנו הולכים. הילדות שלך הייתה שקר. ככל הנראה, 1 חלק 10 הוא אכן 0.100000000000000005551115123-- 

מה קורה? ובכן, מתברר, אם אתה סוג של להסתכל רחוק מספיק בחוץ הבסיסי ייצוג זה מספר, זה באמת הוא לא בדיוק 1/10, או 0.1 ו מספר אינסופי של אפסים. עכשיו, מדוע זה כך? 

ובכן, למרות שזה פשוט מספר לנו, בני אדם, 1 חלק 10, זה עדיין אחד אינסוף מספרים שנוכל להמציא. אבל מחשב יכול לייצג רק סופי של מספרים כך. וכך, באופן יעיל, מה המחשב מראה לנו הוא הקרוב ביותר שלה קירוב למספר אנחנו רוצים להאמין הוא 1/10, או באמת אינסוף 0.10000. 

במקום זאת, אם כי, זה קרוב ככל שהיא יכולה לקבל. ואכן, אם אתה מסתכל מתחת למכסה המנוע, כמו שאנחנו כאן מלהסתכל 55 ספרות אחרי הנקודה העשרונית, שאנחנו רואים בפועל מציאות. עכשיו במאמר מוסגר, אם יש לך שמעולם לא ראה את movie-- רובכם כנראה haven't-- אבל סופרמן 3 לפני כמה שנים, ריצ'רד פריור בעצם ממנף את זה המציאות בחברתו לגנוב הרבה של שברים שברים של פרוטות, משום company-- ככל הזכור לי, זה היה while-- היה בעיקרו זורק משהו שלא התאים אל הרעיון של סנט. 

אבל אם אתה מוסיף את כל אלה מספרים קטנטנים, זעירים שוב, ושוב, ושוב, אתה יכול, כמו במקרה שלו, להפוך סכום כסף טוב. 

רעיון באותו נתלש ידי עדכן יותר, אבל עדיין כבר מבוגר הסרט, שנקרא שטחי משרדים, איפה החבר'ה בסרט ההוא, עשה את אותו הדבר, דפקת את לחלוטין, בסופו של דבר עם הרבה יותר מדי כסף בחשבון הבנק שלהם. הכל היה מאוד חשוד. אבל בסוף היום, חוסר דיוק הוא סביבנו. 

וזה גם יכול להיות להחריד במקרה. מתברר כי סופרמן 3 ו- Office Space הצידה, שם יכול להיות קצת מאוד אמיתי השלכות בעולם של המציאות של מדויק ייצוג של נתונים שגם אנחנו בני אדם היום הזה לא בהכרח להבין גם כמו שצריך, או לזכור לעתים קרובות ככל שאנחנו צריכים. ואכן, הקליפ הבא הוא מתוך מבט על כמה עולם מאוד אמיתי ההשלכות של מה קורה אם אתה לא מעריך את חוסר הדיוק כי יכול לקרות בייצוג מספרים. 

[הפעלת סרטון] 

-Computers, כל שהתרגלנו לקבל הבעיות המתסכלות לעתים קרובות כי ללכת עם them-- באגים, וירוסים, ותקלות תוכנה, עבור מחירים קטנים לשלם לנוחיות. אבל בהיי-טק ומהירות גבוהה יישומים צבאיים תוכנית החלל, הבעיה הכי קטנה יכולה להיות מוגדל לאסון. 

ב -4 ביוני 1996, מדענים מוכנים להשיק טיל בלתי מאויש Ariane 5. הוא נשא מדעי לוויינים תוכנן להקים במדויק את מידת הסטייה אינטראקציה השדה המגנטי של כדור הארץ עם רוחות שמש. הרקטה נבנתה עבור סוכנות החלל האירופית, והמריא מהמתקן שלה בחוף של גיאנה הצרפתית. 

בטיילת כ -37 שניות לתוך הטיסה, הם ראשונים משהו שם לב היה משתבש. הדיזות היו מסתובבות ב בדרך הם באמת לא צריכים. כ -40 שניות לאחר ההמראה, בבירור, הרכב היה בצרות. 

וזה כשעשה החלטה להרוס אותו. קצין בטיחות המגוון, עם אומץ אדיר, לחץ על הכפתור, פוצץ את הרקטות, לפני שהיא יכולה הפך למפגע בשלומו של הציבור. 

-זהו היתה העלמה המסע של אריאן 5. והריסתה לקחה למקם בגלל פגם מוטבע התוכנה של הרקטה. -The בעיה על אריאן היה כי החוליה מנתה מספר כי נדרש 64 סיביות להביע. והם רצו להמיר אותו מספר של 16 סיביות. הם הניחו כי מספר לא הולך להיות גדול מאוד, כי רוב אלה ספרות מספר 64 סיבי היו אפסים. הם טעו. 

-The חוסר יכולת של אחד תוכנה לקבל סוג של מספר שנוצר על ידי אחר היה בשורש של הכישלון. פיתוח תוכנה הפך מאוד יקר חלק טכנולוגיה חדשה. רקטת Ariane הייתה מאוד מוצלח, כל כך הרבה של התוכנה נוצר מפני שהיה בהם גם המשמש Ariane 5. 

-The הבעיה הבסיסית הייתה כי אריאן 5 היה מהיר יותר, האצה מהירה יותר. ואת התוכנה לא הייתה אחריות לכך. 

-The חורבן הרקטה היה אסון כלכלי עצום, הכל בגלל שגיאת תוכנה דקה. אבל זה לא היה ראשון בעיות המרת נתוני זמן שמטריד טכנולוגיות טילים מודרניות. 

-in 1991, עם תחילת מלחמת המפרץ הראשונה, הטיל הפטריוט חווה סוג דומה של בעיה המר מספר. כתוצאה מכך, 28 אנשים, 28 חיילים אמריקאים, נהרגו, וכ 100 נפצעו, כאשר פטריוט, שאמור היה על מנת להגן מפני הסקאדים נכנסים, נכשל לירות טיל. 

-כאשר עיראק פלשה לכווית, ובאמריקה השיק סופה במדבר בתחילת שנת 1991, סוללות טילי פטריוט נפרסו כדי להגן על ערב הסעודית וישראל מפני התקפות טילי סקאד עיראקיים. הפטריוט הוא מגוון-בינוני בארה"ב משטח למערכת אוויר, מיוצר על ידי חברת Raytheon. 

-The גודל של המיירט הפטריוט עצמו הוא על בערך באורך 20 מטרים. והוא שוקל כ -2,000 ק"ג. והיא נושאת ראש נפץ של כ, אני חושב שזה בערך 150 ק"ג. ואת ראש הנפץ עוצמה הוא חומר נפץ מסוכן, אשר רסיסים סביבו. המעטפת של הראש הקרבי היא מיועד לפעול כמו כדור עופרת. 

טילי -The מתבצעים ארבע למכולה, ו מועברים על ידי קרוואן למחצה. 

-The מערכה אנטי טילים פטריוטים חוזר לפחות עכשיו 20 שנים. זה היה במקור תוכנן כמו טיל הגנה אווירית כדי להפיל את מטוסי האויב. במלחמת המפרץ הראשונה, כשהמלחמה כי הגיעה יחד, הצבא רצה להשתמש בו כדי להפיל הסקאדים, לא מטוסים. 

חיל האוויר העיראקי היה לא כל כך בעיה גדולה. אבל הצבא היה מודאג לגבי הסקאדים. וכך הם ניסו לשדרג את הפטריוט. 

-Intercepting אויב טיל נוסעים מאך 5 הולך להיות מאתגר מספיק. אבל כאשר הפטריוט הובהל לשירות, הצבא לא היה מודע של שינוי העיראקי שגרם הסקאדים שלהם כמעט בלתי אפשרי להכות. 

-מה קרה הוא הסקאדים כי היו נכנסים היו יציבים. הם כשלו. הסיבה לכך היתה העיראקים, כדי כדי לקבל 600 ק"מ מתוך 300 קילומטר טיל טווח, הרים את משקלה מתוך הראש הקרבי הקדמי. הם עשו את ראש הנפץ קל. 

אז עכשיו את הפטריוט הוא מנסה לבוא על סקאד. ורוב הזמן, רוב מכריע של הזמן, זה פשוט יטוס על ידי סקאד. לאחר מפעילי מערכת הפטריוט הפטריוט הבין יחטיא את מטרתו, הם פוצצו את הראש הקרבי של הפטריוט כדי להימנע מפגיעה אפשרית אם זה הורשה ליפול אל הקרקע. 

ההיא." היה מה שרוב האנשים ראו, אלה כדורי אש גדולים בשמים, ולא מובן כפי מיירט של ראשי נפץ סקאד. 

אמנם, בלילה שמיים, הפטריוטס הופיע להיות בהצלחה להרוס הסקאדים, ב Dhahran, לא יכולה להיות טעות בנוגע לביצועים שלה. יש, מערכת המכ"ם של הפטריוט אבד את התחושה של בטיל סקאד, ולעולם השיק בשל כדי פגם בתוכנה. זה היה הישראלים שגילו ראשון כי הייתה המערכת כבר על, פער הזמן יותר הפך, עקב שעון משובץ במחשב של המערכת. 

-About שבועות לפני הטרגדיה Dhahran, הישראלים דיווחו משרד ההגנה שמערכת מאבד מזמנו. אחרי כשמונה שעות או ריצה, הם הבחינו כי המערכת נעשה באופן ניכר פחות מדויק. משרד ההגנה הגיב לספר את כל הסוללות הפטריוטיות לא לעזוב את המערכות במשך זמן רב. הם לא אמרו מה זמן רב was-- שמונה שעות, 10 שעות, 1,000 שעות. אף אחד לא ידע. 

-The סוללה הפטריוטית מוצבי הצריפים ב Dhahran והפנימי שלה הפגום השעון היה על מעל 100 שעות בליל ה -25 בפברואר. 

-זה במעקב הזמן ברמת דיוק של כעשירית שנייה. עכשיו, עשירית שנייה הוא מספר מעניין, כי זה לא יכול לבוא לידי ביטוי ב בינארי בדיוק, אשר שאומר שהוא לא יכול לבוא לידי ביטוי בדיוק בכל מחשב דיגיטלי מודרני. קשה להאמין. 

אבל להשתמש בהם כדוגמה. בואו ניקח את השלישי מספר אחד. שליש לא יכול להיות ביטוי עשרוני בדיוק. שליש הוא 0.333 נמשך לאינסוף. 

אין דרך לעשות את זה עם דיוק מוחלט עשרוני. זה בדיוק סוג של בעיה שקר הפטריוט. ככל מערכת רץ, גרוע שגיאת הזמן הפכה. 

-אחרי 100 שעות של המבצע, שגיאת בזמן הייתה רק כשליש של שנייה. אבל מבחינת מיקוד טיל נוסעים מאך 5, זה הביא מעקב שגיאה של למעלה מ -600 מטרים. זו תהיה שגיאה חמורה עבור החיילים על מה קרה הוא השקת סקאד היה זוהה על ידי לוויני אזהרה מוקדמים והם ידעו כי סקאד היה מתקדם לכיוון הכללי שלהם. הם לא ידעו מאיפה זה בא. 

-זה היה עכשיו עד לרדאר רכיב של מערכת הפטריוט בהגנה Dhahran לאתר ולשמור מסלול של טיל האויב הנכנס. 

-The המכ"ם היה מאוד חכם. זה היה למעשה לעקוב אחר עמדת סקאד, ואז לחזות היכן זה כנראה יהיה בפעם הבאה לרדאר שלח דופק החוצה. זה נקרא שער טווח. 

-Then, פעם הפטריוטית מחליט מספיק זמן יש עברו לחזור ולבדוק את הבא מיקום אובייקט מזוהה זה, זה הולך אחורה. אז כשזה חזר אל הלא נכון במקום, לאחר מכן הוא רואה שום חפץ. והוא מחליט כי אין אובייקט, זה היה גילוי שווא, וטיפות את המסלול. 

-The בטיל סקאד נעלם ממסך המכ"ם. ושניות לאחר מכן, זה טרק לצריפים. הסקאד נהרג 28, והיה האחרון אחד ירה במלחמת המפרץ הראשונה. 

באופן טרגי, התוכנה המעודכנת הגיע Dhahran למחרת. היה התוכנה פגם קבוע כבר, סגירה פרק אחד המוטרד ההיסטוריה של הטילים הפטריוטים. 

[הפעלת סרטון] דוד י מלאן: אז זהו הכל אומר כי בעיות אלה של הצפה ואי-דיוק הם למאוד מציאותי. אז איך הגענו לכאן? התחלנו עם מדברת רק על printf. שוב, פונקציה זו כי מדפיס משהו למסך, ואנחנו הצגנו ואילך כמה פונקציות אחרות מהספרייה שנקראה CS50. ואנחנו נמשיך לראות אותם בבוא הזמן. ואנחנו, במיוחד, המשמשים מחרוזת גט, ולקבל int, ועכשיו גם לקבל לצוף, ובכל זאת אחרים עדיין אנו נתקלים ולהשתמש עצמנו תוך זמן קצר. 

אבל מדי פעם, יש כבר ראינו צורך לאחסן פונקציות אלה היד מה בחזרה? הם מחלקים אותנו בחזרה מחרוזת, או int, או לצוף. ולפעמים אנחנו צריכים לשים את זה שרוכים או int, או לצוף, איפשהו. 

וכדי לאחסן דברים אלה, זוכר רק כמו גרד, יש לנו משתנה. אבל שלא כמו שריטה, יש בדו לנו סוגים בפועל נתוני variables-- סוגים, יותר generally-- ביניהם, מקבלת מחרוזת, int, לצוף, ואחרים אלה עדיין. 

וכך כאשר אנו להצהיר על משתנים ב C, נצטרך להכריז סוגי הנתונים שלנו. זה לא משהו יהיה לנו צריך לעשות בהמשך הסמסטר כפי שאנו המעבר לשפות אחרות. אבל לעת עתה, אנחנו צריכים כדי אפריורי מראש, להסביר למחשב איזה סוג של משתנה ואנחנו רוצים את זה כדי לתת לנו. 

עכשיו, לעומת זאת, להדפיס אלו סוגים של סוגי נתונים, יש לנו לספר printf למה לצפות. וראינו s אחוזים עבור מחרוזות, ואחוזי i עבור מספרים שלמים, ועוד כמה אנשים כבר. ואלה הם פשוט דרישות עבור מצגת ויזואלית של מידע זה. 

וכל אחד מהם יכול להיות באמת parametrized או צבט בדרך כלשהי, אם אתה רוצה שליטה רבה יותר על לסוג הפלט שאתה מקבל. ואכן, מתברר כי לא רק הוא מהלך סרק יש n עבור קו חדש. יש משהו שנקרא אחר מהלך סרק r עבור מעבר לשורה, אשר משול יותר כדי מכונת כתיבת ספר ישנה, וגם Windows בשימוש במשך שנים רבות. 

יש t הנטוי ההפוך עבור כרטיסיות. מסתבר, כי אם אתה רוצה מרכאות כפולות בתוך מחרוזת, נזכיר כי השתמשנו כפול מרכאות כפולות ציטוט על השמאל והימין מסתיים של המחרוזות שלנו עד כה. זה היה נראה לבלבל דברים. 

אם אתה רוצה לשים מרכאות כפולות ב באמצע string--, ואכן, זה מבלבל לראות. וכך אתה צריך לברוח, אם אפשר לדבר, מרכאות כפולות עם משהו כמו, פשוטו כמשמעו, מהלך סרק מרכאות כפולות. ויש כמה אחרים עדיין. ואנחנו נראה יותר מאלה משתמשים בו בפועל לפני זמן רב. 

אז בואו עכשיו מעבר מן נתונים, וייצוג, ו אופרטורים אריתמטיים, כל מהם נתן לנו איזה בניין בלוקים שבה לשחק. אבל עכשיו בואו למעשה לתת לנו שאר אוצר המילים כי כבר היו לנו בשבוע שעבר עם שריטה על ידי לקיחת מבט על כמה אחרים בונה ב C-- לא כולם. אבל הרעיונות שאנחנו על מנת לראות באמת רק כדי להדגיש את התרגום שפה אחת, שריטה, למשנהו, ג 

פעם אחר פעם, נבוא לאסוף כלים נוספים עבור ערכת הכלים שלנו, כביכול, מבחינה תחבירית. ואכן, תראה שהרעיונות עכשיו הם די מוכרים משבוע שעבר. אז בוא נעשה את זה. 

בואו נלך קדימה להלהיב תכנית כי בעצם משתמש כמה ביטויים, ביטוי בוליאני. תן לי ללכת קדימה כאן וליצור קובץ חדש. אני אתקשר condition.c זה. 

תן לי ללכת קדימה לכלול את ספריית CS50. ותן לי להמשיך ולכלול תקן IO.h לפונקציות שלנו, ו printf ועוד בהתאמה. תן לי לתת לעצמי מוכן מראש של void main int, שהסברה תהיה לנו לחזור בעתיד. 

עכשיו תנו לי להמשיך ולתת לעצמי int באמצעות int הגט. אז הרשה לי להמשיך לעשות את זה. אני רוצה לומר אם i הוא less-- בואו להבחין בין חיובי, שלילי, או ערכי אפס. 

אז אם אני הוא פחות מאפס, תן לי רק צריך תוכנית זו פשוט לומר, n שלילי, מהלך סרק, אחר אם i הוא גדול מאפס. עכשיו אני, כמובן, הולך להגיד printf חיובית, קו נטוי הפוך n. ואז אחר שאם-- יכולתי לעשות זאת. 

יכולתי לעשות אם אני שווה 0. אבל בעולם שהייתי עושה בבית כבר לפחות טעות אחת. נזכיר כי סימן השוויון הוא לא שווה, כפי שאנו בני האדם יודעים את זה. 

אבל זה אופרטור ההשמה. ואנחנו לא רוצים לקחת על 0 ימין לשים אותו אני בצד שמאל. אז כדי למנוע בלבול זה, או אולי ניצול לרעה של סימן השוויון, בני האדם החליטו לפני כמה שנים כי בשפות תכנות רבות כאשר אתה רוצה לבדוק לשוויון בין השמאל והימין, אתה בעצם משתמש שווה בין שווים. אז אתה מכה את סימן השווה פעמיים. כאשר אתה רוצה להקצות מימין לשמאל, אתה משתמש כניסה יחידה שווה. אז נוכל לעשות זה- אחר אם אני שווה שווה אפס. 

יכולתי אז ללכת לפתוח סוגריים מסולסלים שלי, ולומר, printf 0, קו נטוי הפוך n, נעשה. אבל זוכר איך אלה מזלגות בכביש יכול לעבוד. וגם, באמת, רק לחשוב על ההיגיון. אני הוא מספר. זה מספר שלם, באופן ספציפי. וזה אומר שזה הולך להיות פחות מ 0, או גדול מ -0, או 0. אז יש סוג של זה במקרה מחדל מרומז. 

וכך יכולנו, בדיוק כמו Scratch, לוותר על אחר אם, ופשוט לומר אחר. מבחינה הגיונית, אם לי את מתכנת יודע שיש רק שלושה דליים שלתוכו תרחיש יכול fall-- הראשון, השני, או השלישי ב זה case-- לא לטרוח להוסיף דיוק הנוסף ואת לוגיקה נוספת שם. רק קדימה עם במקרה ברירת המחדל כאן של אחר. 

עכשיו, בואו נלך קדימה לאחר השמירה הזה, לעשות תנאי dot סלאש conditions-- לא ממשק משתמש מעולה, כי אני לא להציג הודעה משתמשים, כפי שציינתי קודם לכן. אבל זה בסדר. אנחנו נשמור את זה פשוט. בואו ננסה את המספר 42. וזה חיובי. בואו ננסה את המספר 42 שלילי, שלילי. 

בואו ננסה את הערך 0. ואכן, זה עובד. עכשיו, תראה עם בעיות לפני שלוש פעמים ארוכות, דברי בדיקות, כנראה לא מספיק. אתה בטח רוצה לבדוק כמה מספרים גדולים, כמה קטן מספרים, ובמקרים מסוימים בפינה, כמו נבוא כדי לתאר אותם. 

אבל לעת עתה, זה הוא תוכנית פשוטה למדי. ואני די בטוח, באופן הגיוני, כי זה נופל לתוך שלושה מקרים. ואכן, למרות שאנחנו רק התמקד השלילי שלהם של חוסר דיוק ואת ההצפה, ב מציאות שבה רבה של הבעיות של CS50, אנחנו לא הולכים לדאוג על, כל הזמן, אלה בעיות של הצפה חוסר דיוק, כי, למעשה, ב- C, זה בעצם לא כל כך קל להימנע הדברים האלה. אם אתה רוצה לספור עד וגדל, וגדל, וגדל, מתברר ישנן טכניקות לך יכול להשתמש, לעתים קרובות מעורבים דברים בשם ספריות, אוספים של קוד, כי אנשים אחרים כתבו, כי אתה יכול להשתמש, ושפות אחרות כמו Java ואחרים, למעשה לעשות את זה הרבה יותר קל לספור אף יותר. אז זה באמת חלק הסכנות הללו פונקציה של השפה שאתה משתמש בה. במהלך השבועות הקרובים, נציג לראות עד כמה מסוכן C באמת יכול להיות אם אתה לא משתמש בו כראוי. אבל משם, ועם Python, ו- JavaScript, יהיה אנחנו שכבנו על כמה גינות נוספות, ולהפעיל פחות סיכונים אלה. 

אז בוא נעשה קצת יותר היגיון מעניין בתכנית שלנו. אז תנו לי להמשיך וליצור תוכנית בשם לוגי רק אז אני יכול לשחק עם כמה ההיגיון בפועל, logical.c. אני פשוט להעתיק ולהדביק כמה קוד מוקדם יותר, כך שאחזור לנקודת התחלה זה נחמד. 

תן לי הפעם לעשות ג char אני הולך לתת לו שם של C רק בגלל שזה קונבנציונלי, לקבל תו מהמשתמש. ובואו פנים כאילו אני ביישום חלק של אותה תוכנית Rm, הסר התוכנית לפני שהניעה המשתמש כדי להסיר קובץ. איך נוכל לעשות את זה? 

אני רוצה לומר, אם C שווה שווה, ציטוט כביכול הזאת, y, אז אני הולך להניח כי שהמשתמש בוחר כן. אני רק הולך להדפיס כן. אם הוא היה בעצם כתיבה התכנית להסרה, נוכל להסיר את הקובץ עם יותר שורות קוד. אבל נשמור את זה פשוט. 

אחר אם ג שווה שווה n-- ועכשיו כאן, אני הולך להגיד, המשתמש בוודאי לא התכוון. ואז אחר, אתה יודע מה? אני לא יודע מה עוד המשתמש הוא הולך להקליד. אז אני רק הולך להגיד כי הוא שגיאה, מה הוא או היא בעצם מוקלד. 

אז מה קורה פה? יש הבדל מהותי לעומת מה שעשיתי בעבר. במרכאות כפולות, במרכאות כפולות, כפול ציטוטים, ו, עדיין, בגרשיים בודדים, בגרשיים בודדים. מתברר ב- C, שכאשר אתה רוצה לכתוב מחרוזת, תעשה שימוש במרכאות כפולות, בדיוק כפי שאנחנו כבר כבר משתמש כל הזמן הזה עם printf. 

אבל אם אתה רוצה להתמודד עם רק תו בודד, לדמות יש מה שנקרא, אז אתה בעצם להשתמש בגרשיים בודדים. לאלו מכם אשר כבר מתוכנים לפני, אתה לא יכול להיות היה לדאוג בקשר לזה הבחנה בשפות מסוימות. ב C, זה כן משנה. וכך כאשר אני מקבל char ואני רוצה להשוות char ששימוש שווה שווה איזה מכתב כמו y או n, אני עושה, אכן, צריך לעבור את בגרשיים הבודדים. 

עכשיו, בואו נלך קדימה לעשות זאת. בואו נלך קדימה עושים נקודה הגיונית סלאש הגיוני. ועכשיו אני בקשת אישור. אז, ככל הנראה, חווית משתמש טובה יותר למעשה היה אומר לי מה לעשות כאן. אבל אני הולך רק בעיוורון אומרים y עבור yes, בסדר, נחמד. 

בואו להפעיל אותו שוב, n ללא, נחמד. נניח כמו אנשים מסוימים שאני מכיר, הכמוסות שלי נעילת מקשים על כל לעתים קרובות מדי. אז אני עושה הון Y, זן, שגיאה. בסדר, זה לא בדיוק מה שאני מצפה. ואכן, המחשב עושה ממש מה אמרתי את זה לבצע-- לבדוק n y והקטן קטן. זה לא מרגיש כמו טוב חוויית המשתמש, אם כי. הרשו לי לבקש ולקבל מקרה נמוך או אותיות גדולות. אז מתברר, ייתכן שתרצה לומר משהו כמו שריטה, כמו פשוטו כמשמעו או C שווה שווה y היחיד צטט הון. מסתבר, C אין או מילת המפתח המילולי הזה. 

אבל אכן יש שני קווים אנכיים. אתה צריך להחזיק Shift בדרך כלל, אם אתה משתמש במקלדת בארה"ב, במשקוף האנכי מפתח לעיל מפתח ההחזר. אבל קו אנכי זה קו אנכי אומר או. 

אם, לעומת זאת, רצינו לומר, כמו שריטה, יכולנו לעשות אמפרסנד אמפרסנד. זה לא הגיוני הגיוני כאן, כי אדם לא ייתכן הקלדה היא y ו- y הקטנה וההון Y כמו אותה הדמות. אז או מה שאנחנו מתכוונים כאן. 

אז אם אני עושה את זה בשני המקומות, או ג שווה שווה הון N, עכשיו בשידור חוזר, להפוך לוגי, בשידור חוזר הגיוני. עכשיו, אני יכול להקליד y. ואני יכול לעשות את זה שוב עם הון Y, או נ ההון ואני יכול להוסיף נוסף שילובים עדיין. 

אז זהו לוגי תכנית ככל עכשיו אני בודק באופן לוגי עבור ערך זה או ערך זה. ואני לא צריך, בהכרח, לבוא עם שני IFS יותר או אחר IFS. אני ממש יכול לשלב כמה מן הקשורים היגיון יחד בדרך זו. אז זה יהיה טוב יותר תוכנן מסתם אומר, אם C שווה y הגדולה וקטנה, להדפיס כן, אחר אם ג שווה הון Y, להדפיס כן, אחר אם ג שווה lower-- במילים אחרות, אתה לא צריך שיהיה לך ענפים יותר ויותר. ניתן לשלב כמה שווה סניפים לוגיים, כמו בדרך זו. 

אז בואו נסתכל רק אחד המרכיב האחרון, מבנה אחד אחרון, כי C מאפשר. ונבוא שוב בעתיד לאחרים עדיין. ואז נצטרך להסיק מלהסתכל בבית לא לנכונות code-- מקבל קוד work-- אבל העיצוב קוד, לזרוע זרעים אלה בשלב מוקדם. 

אז תן לי ללכת קדימה לפתוח קובץ חדש כאן. אתה יודע מה? אני הולך מחדש ליישם תוכנית דומה, אבל באמצעות תבנית אחרת. 

אז תנו לי מהר לתת את עצמי גישה לכלול CS50.h עבור ספריית CS50, Io.h תקן printf. תן לי void main int שלי. ואז לכאן, בואו לי להמשיך לעשות את זה. 

ג תו מקבל לקבל char, בדיוק כמו לפני. ואני הולך להשתמש מבנה חדש now-- לעבור, על אופי מה? אז בורר הוא כמו סוג של מיתוג מסלולי רכבת. או, באמת, זה סוג של אם אחר, אם אחר אם, אבל כתוב קצת אחרת. 

מתג נראה כך. יש לך מתג, ואז מה תו או מספר אתה רוצה להסתכל, אז כמה סוגריים מסולסלים אוהבים גרד, רק אומר לעשות את הדברים האלה. ואז יש לך מקרים שונים. 

אינך משתמש אם אחר. אתה ממש להשתמש במקרה המילה. ואתה אומר משהו כזה. 

אז במקרה של y קטנה, או במקרה של הון Y, אתם מוזמנים להדפיס כן. ואז לפרוץ את המתג. זהו זה. אנחנו סיימנו. 

אם אחר, אם אפשר לומר כך, במקרה n נמוך, או הון N, אז קדימה הדפסה מתוך שלא, ואז לשבור. Else-- ו מסוג זה הוא של במקרה מחדל indeed-- printf error-- ו רק למען הסדר הטוב, אם כי הגיוני הפסקה זה לא הכרחי בגלל שאנחנו בסוף של הבורר בכל מקרה, אני עכשיו לשבור את המתג. אז זה נראה קצת אחר. 

מן ההיגיון, זה למעשה שווה ערך. ולמה אתה משתמש אחד על פני השני? לפעמים, פשוט העדפה אישית, לפעמים האסתטיקה, אם אני מציץ זה עכשיו, יש משהו להיאמר עבור קריאות של הקוד הזה. אני מתכוון, שלא לדבר על העובדה שמדובר קוד חדש לרבים מאיתנו בחדר. 

אבל זה פשוט סוג של די. אתה רואה וקטן y, הון Y, באותיות קטנות n, ברירת המחדל ההון N, זה פשוט סוג של קפיצות החוצה אליך בצורה כי, ללא ספק, אולי בדוגמה הקודמת עם IFS, ואת הקווים האנכיים, ואת IFS האחר, לא יכול להיות. אז זה באמת עניין של אישיות בחירה של ממש, או קריאות, של הקוד. 

אבל מבחינה פונקציונלית, תן לי להמשיך ולעשות קו נטוי מתג, נקודה מתג, ועכשיו להקליד y הקטנה, הון Y, N הקטנה, בירת N, דוד, שוב כי זה לא תו בודד. בוא נעשה x, שגיאה, כצפוי. וגם, logically-- וזה משהו הייתי ממליץ ב general-- אפילו אם אנחנו רק מגרדים את פני השטח של חלק מהתכונות הללו. 

וזה לא יכול להיות ברור כשאתה עצמך לשבת ליד המקלדת, איך זה עובד? מה זה יעשה? מה שיפה שיש מחשב נייד או מחשב שולחני, או גישה למחשב עם מהדר, ועם עורך קוד כזה, הוא כמעט תמיד אתה יכול לענות אלה שאלות בעצמך רק על ידי מנסה. 

לדוגמה, אם רטורית השאלה שעל הפרק היו, מה קורה אם אתה שוכח דוחות ההפסקה שלך? שהוא למעשה נפוץ מאוד הדבר הנכון לעשות, כי זה לא נראה כמו שאתה באמת צריך אותם. הם לא באמת להשלים שלך חשבתי כמו סוגריים או מתולתל סד עושה. בואו נלך קדימה להדר מחדש את הקוד ולראות. אז להפוך מתג, מתג לוכסן נקודה. בואו להקליד אותיות קטנות y, במקרה העליון, Enter. אז הקלדתי y. 

התכנית אמרה כן, לא, טעות, כאילו זה היה שינוי דעתה. אבל זה סוג של היה, כי מה שקורה עם בורר במקרה הראשון משחק בעצם אומר, היי מחשב, לבצע את כל הקוד שמתחתיה. ואם אתה לא אומר להפסיק לפעול או לא אומר להפסיק לפעול או לא אומר הפסקה, המחשב עומד להתפוצץ באמצעות כל אלה קווים ולבצע כולם עד שהוא מגיע במחוך מתולתל. אז הבלמים הם, אכן, צורך. אבל משהו ממסעדה כאן היא, כאשר במקרה של ספק, לנסות משהו. אולי להציל את הקוד שלך ראשונה, או לשמור אותו בקובץ נוסף אם אתה באמת מודאג לקלקל ויש להם להתאושש העבודה שאתה יודע שהוא עובד. 

אבל לנסות דברים. ואל תפחד כמו, אולי, של מה שהמחשב יכול לעשות, או כי אתה עלול לשבור משהו. אתה תמיד יכול לחזור לכמה גרסה קודמת. 

אז בואו לסיים מלהסתכל על העיצוב של קוד. יש לנו את היכולת הזו עכשיו לכתוב תנאים, ולולאות כתיבה, ומשתנה, ופונקציות שיחה. אז, בכנות, אנחנו סוג של חזרה איפה היינו לפני שבוע עם שריטה, אמנם עם טקסטואלי פחות משכנע לסביבה מאשר Scratch מאפשרת. 

אבל שימו לב כמה מהר שצברנו אוצר המילים כי, גם אם זה הולך לקחת קצת זמן לשקוע, כך אנו יכולים כעת להשתמש באוצר המילים הזה כדי לכתוב תוכניות מעניינות יותר. ובואו לקחת צעד תינוק כלפי זה, כדלקמן. תן לי ללכת קדימה ליצור קובץ חדש כאן. 

אני הולך לקרוא את זה prototype.c, ולהציג בפעם הראשונה, את היכולת כדי להפוך פונקציות משלך. חלק מכם אולי יש עשה זאת עם שריטה, לפיה ניתן ליצור שלך בלוקי מנהג עצמו Scratch, ולאחר מכן לגרור אותם לתוך מקום איפה שאתה רוצה ב C. וברוב תכנות שפות, אתה יכול לעשות בדיוק ש-- להפוך פונקציות משלך, אם הם לא קיימים כבר. 

כך, למשל, תן לי ללכת קדימה וכולל CS50.h, וכולל תקן IO.h, void main int. ועכשיו יש לנו מציין מיקום מוכן ללכת. אני שומר את דברי הדפסה כמו היום של שמות אנשים. וזה מרגיש כמו-- לא יהיה נחמד אם יש היו פונקציה שנקראת שם להדפיס? אני לא צריך להשתמש printf. אני לא צריך לזכור כל הקודים בפורמט. למה לא אני, או מדוע לא עשה מישהו לפניי, ליצור הדפסת פונקציה שנקראת שם, כי ניתן לו איזה שם, מדפיס את זה פשוט? 

במילים אחרות, אם אני אומר, היי, מחשב, תן לי מחרוזת על ידי לשאול את המשתמש עבור כאלה, באמצעות פונקציית מחרוזת הגט של CS50. היי, המחשב, לשים אותה מחרוזת ב המשתנה בצד שמאל, וקוראים לזה זה. ואז, היי מחשב, קדימה ולהדפיס כי שמו של האדם, נעשה. 

עכשיו, זה יהיה נחמד, כי תוכנית זו, בשם הקולע, אומר לי את מה שהיא אמורה לעשות בדרך של אלה של שמות הפונקציה. תן לי ללכת ולעשות אבטיפוס, Enter. ולמרבה הצער, זה לא הולך לעוף. 

Prototype.c, קו 7, אופי 5, שגיאה, הצהרה סמויה שם הדפסת פונקציה אינו תקף C99, C99 כלומר גרסה של C שיצא ב -1999. זה הכל. 

אז אני לא יודע מה כל זה אומר עדיין. אבל אני כן מכיר שגיאה באדום. זה די ברור. 

ונראה כי עם הדמות הירוקה כאן, הבעיה היא עם שם הדפסה, פתוחה ים סוגריים, סגור סוגריים, פסיק. אבל הכרזה מרומזת פונקציה שעשינו לראות בקצרה קודם לכן. משמעות הדבר היא, פשוט, כי קלאנג לא יודע למה אני מתכוון. 

השתמשתי מילת אוצר מילים שזה מעולם לא ראה או שלמד לפני. ובשביל זה אני צריך ללמד אותו מה פונקציה זה אומר. אז אני הולך קדימה, לעשות את זה. 

אני הולך קדימה וליישם פונקציה משלי שנקראת שם הדפסה. ואני הולך להגיד, כדלקמן, כי הוא עושה זאת, printf, שלום, אחוזים ים, קו נטוי הפוך n, שם, פסיק. אז מה אני פשוט עושה? 

אז מתברר, כדי ליישם פונקציה משלך, אנחנו סוג של ללוות חלק באותו המבנה כמו ראשי כי אנחנו פשוט כבר מובן מאליו, ואני יודע רק העתקה הדבקה פחות או יותר מה אני כבר כותב בעבר. אבל מבחין כאן דפוס. Int, ראשי, Void, נצטרך ניסה להפריד לפני זמן מה שבעצם אומר. 

אבל היום, רק לב ההקבלה. Void, שם הדפסה, שם המחרוזת, כך שאין מילת מפתח סגולה, אשר אנחנו הולכים להתחיל קורא טיפוס החזרה, בשם הפונקציה, ולאחר מכן קלט. אז, למעשה, אנחנו יכולים לזקק סוג זה של שבוע שעבר כמו כמו, זהו השם או האלגוריתם של קוד אנחנו הולך write-- האלגוריתם שבבסיס את הקוד אנחנו הולכים לכתוב. 

זהו הקלט שלה. זהו הפלט שלה. פונקציה זו, שם הדפסה, היא שנועד לקחת מחרוזת קראה בשמה, או מה שלא יהיה, כקלט, ולאחר מכן ומבוטל. זה לא מחזיר שום דבר, כמו לקבל מחרוזת או לקבל int עושה. אז זה הולך לתת לי משהו בחזרה. זה פשוט הולך להיות תופעת לוואי, אם אפשר לומר כך, של הדפסת שמו של אדם. אז שם לב, קו 7, אני אפשר לקרוא שם הדפסה. קו 10, אני יכול להגדיר או ליישם שם הדפסה. אבל, למרבה הצער, זה לא מספיק. 

תן לי ללכת קדימה הידור זה לאחר השמירה. וואו, עכשיו, אני כבר עשיתי את זה יותר גרוע, זה היה נראה. אז ההצהרה המרומזת של שם פונקצית הדפסה אינו חוקי. וגם, שוב, יש עוד שגיאות. אבל כמו שאני הזהרתי קודם לכן, גם אם אתה מקבל מום עם, או קצת עצוב לראות כל כך הרבה שגיאות, להתמקד רק על הראשון בתחילה, משום שבאותה השפיעו באופן מדורג. אז C, או קלאנג ליתר דיוק, עדיין לא מכיר את שם הדפסה. 

וזה בגלל קלאנג, על ידי עיצוב, הוא סוג של טיפש. זה רק עושה את מה שאתה אומר את זה לעשות. וזה רק עושה זאת לפי הסדר שבה אתה אומר את זה כדי לעשות. 

אז הגדיר עיקרי על קו ארבעה, כמו שעשינו לעתים קרובות למדי. שהגדרתי שם הדפסה על קו 10. אבל אני מנסה להשתמש שם הדפסה על קו שבע. 

זה מוקדם מדי, לא קיים עדיין. אז אני יכול להיות חכם, ולהיות כמו, אוקיי, אז בואו פשוט לשחק יחד, ולעבור שם המודפס פונה כלפי מעלה כאן, לקמפל מחדש. אלוהים אדירים. זה עבד. זה היה פשוט עד כדי כך. 

אבל ההיגיון הוא בדיוק זה. אתה צריך ללמד קלאנג מה זה הוא על ידי הגדרת התפקיד הראשון. אז אתה יכול להשתמש בו. אבל, בכנות, זה מרגיש כמו מדרון חלקלק. 

אז בכל פעם שאני מפעיל לתוך בעיה, אני פשוט הולך לסמן ולהעתיק את הקוד כתבתי, לחתוך אותו ולהדביק אותו כאן. וגם, מן הסתם לא היה לנו להמציא כמה תרחישים שם תפקיד אחד אולי צריך לקרוא עוד. ואתה פשוט לא יכול לשים כל פונקציה מעל כל האחרים. 

אז מתברר של שם פתרון טוב יותר. אנחנו יכולים להשאיר את זה להיות. ולמען אמת, זה בדרך כלל נחמד, ונוח, ועיצוב טוב לשים ראשי ראשון, כי, שוב, ראשי בדיוק כמו כאשר הדגל ירוק לוחץ, כי הוא הפונקציה מקבל להורג כברירת מחדל. אז באותה מידה אתה יכול לשים אותו בחלק העליון של הקובץ כך שכאשר אתה או כל אדם אחר מביט הקובץ אתה יודע מה קורה רק על ידי הקריאה הראשונה ראשי. אז מתברר, אנחנו יכולים לספר קלאנג יזום, היי, קלאנג, על קו ארבע, אני מבטיח ליישם הדפס פונקציה שנקראת שם שלוקח שם מחרוזת בשם כקלט, וחוזר דבר, בטל. ואני אגיע יישום זה מאוחר יותר. 

הנה מגיע ראשי. עכשיו ראשים על קו 9 יכולים להשתמש שם הדפסה משום קלאנג הוא הסתמכות על כך, בסופו של דבר, זה יהיה מפגש ההגדרה היישום שם הדפסה. אז לאחר שמירת הקובץ שלי, תן לי להמשיך ולעשות אבטיפוס, נראה טוב הפעם. Dot סלאש, אב טיפוס, תן לי אתם מוזמנים להקליד שם. דוד, שלום דוד, Zamila, שלום Zamila, ואכן, עכשיו זה עובד. 

אז המרכיב כאן הוא כי יש לנו עשה פונקציה מותאמת אישית, כמו מנהג Scratch בלוק אנחנו קוראים לזה. אבל בניגוד Scratch שבו אתה יכול רק ליצור אותו ולהתחיל להשתמש בו, עכשיו אנחנו צריכים להיות קצת יותר קפדן, ולמעשה להכשיר קלאנג כדי להשתמש, או כדי לצפות בו. עכשיו, במאמר מוסגר, למה כל הזמן הזה יש היינו רק באופן עיוור על אמונה כוללת CS50.h, וכולל IO.h רגיל? 

ובכן, מתברר, בין כמה דברים אחרים, כל זה באותם הנקודה h קבצים, אשר במקרה קבצים. הם קובצים, אם אפשר לומר כך. הם עדיין הכתובים בשפת C. אבל הוא סוג של קבצים שונה. 

לעת עתה, אתה יכול פחות או יותר להניח שכל מה נמצא בתוך CS50.h הוא אחד ספינות כמה כזה, לא עבור פונקציות נקראות שם הדפסה, אבל עבור קבל מחרוזת, קבל Float, ועוד כמה אנשים. ויש טיפוס דומה, אחד ספינות, בתוך IO.h תקן עבור printf, הנמצא כעת פונקציה שם הדפסה משלי. אז במילים אחרות, זה כל הזמן יש לנו עתה העתיק בעיוורון והדבקה תכונה זו כולל, כוללת כי, מה קורה? אלה הם רק סוג של רמזים להרעיש כמו לפונקציות מה הם, אכן, מיושמים, רק במקומות אחרים קבצים שונים במקום אחר במערכת. 

אז אנחנו יישמנו שם הדפסה. אך עדיין יש תופעת לוואי זו של הדפסת משהו על המסך. אבל זה לא באמת למסור לי משהו בחזרה. איך אפשר ללכת על יישום תוכנית אין למסור לי משהו בחזרה? 

ובכן, בואו ננסה את זה. תן לי ללכת קדימה וליישם return.c קובץ בשם כדי שנוכל להדגים כיצד משהו כמו קבל מחרוזת, או קבל Int, הוא למעשה חוזר משהו בחזרה למשתמש. בואו נלך קדימה ולהגדיר void main int. 

וגם, שוב, בעתיד, אנחנו נעלה להסביר מה int כי וכי חלל בעצם הוא עושה. אבל היום, יהיה לנו לקחת את זה כמובן מאליו. אני הולך קדימה, printf, עבור חוויית משתמש טובה, הוא x. ואז אני הולך לחכות משתמש לתת לי x עם int הגט. 

ואז אני הולך קדימה ולהדפיס x לכיכר. לכן, כאשר יש לך רק מקלדת, אנשים בדרך כלל להשתמש גזר קטן סמל במקלדת לייצג את הכח של, או המעריך של. אז x בריבוע קיים i. 

ועכשיו אני הולך לעשות את זה. יכולתי רק לבצע-- מה x בריבוע? x בריבוע הוא x פעמים x. 

ועשינו את זה כמה לפני זמן מה כבר היום. זה לא מרגיש כמו כל התקדמות רבה. אתה יודע מה? בואו למנף חלק כי הרעיון מהפעם הקודמת של הפשטה. 

האם לא יהיה זה נחמד אם יש פונקציה שנקראת מרובע שעושה בדיוק את זה? זה עדיין, בסוף של יום, עושה את אותו הדבר במתמטיקה. אבל בואו מופשטים משם את הרעיון של לקיחת אחד מספר כפול אחר, ופשוט לתת לו שם, כמו כיכר ערך זה. 

וגם, או במילים אחרות, ב C, בואו ליצור פונקציה כיכר בשם שעושה בדיוק את זה. זה הולך להיקרא רבוע. זה הולך לקחת int. ואנו יהיו רק קוראים לזה n, כברירת מחדל. 

אבל אנו יכולים לקרוא לזה כל מה שאנחנו רוצים. וכל מה שהוא הולך לעשות, פשוטו כמשמעו, הוא החזרה התוצאה של n פעמי n. אבל בגלל זה הוא חוזר משהו, אשר מילת המפתח היא בסגול יש לנו מעולם לא ראיתי לפני, אני, על קו 11, אי אפשר פשוט לומר חלל הפעם. 

Void, בדוגמה שראינו הרגע דווקא שם הדפסה, רק אומר, עשה משהו. אבל אל תיתן לי משהו בחזרה. במקרה זה, אני רוצה לחזור n פעמים n, או מה שזה לא יהיה, את המספר הזה. 

אז אני לא יכול להגיד, היי, מחשב, אני חוזר שום דבר, בטל. זה הולך לחזור, מטבעו, int. וכך זה כל מה קורה כאן. 

הקלט לרבע הולך להיות מספר שלם. וכך שנוכל להשתמש בו, זה חייב יש שם, נ זה הולך פלט מספר שלם שאינו צריך שם. אנחנו יכולים להשאיר את זה ראשי, או מי הוא באמצעות לי לזכור את הערך הזה אם אנחנו רוצה עם משתנה משלה. 

וגם, שוב, חדש רק מילת המפתח כאן היא השיבה. ואני פשוט עושה קצת מתמטיקה. אם אני באמת רוצה להיות מיותר, יכולתי לומר מוצר int מקבל n פעמים n. 

ואז אני יכול לומר, להחזיר את המוצר. אבל, שוב, למה שרציתי להגיד קודם של רק לא להיות זה design-- טוב כמו, למה להכניס שם, סמל, כמו מוצר, רק כדי להחזיר אותו מיד? זה מנקה קצת, קצת חזק יותר, כך לדבר, רק כדי להגיד פעמים n בתמורה n, להיפטר של קו זה לגמרי. 

וזה פשוט פחות קוד לקרוא, הזדמנות פחות טעויות. ובואו לראות אם זה למעשה פועל כעת. עכשיו, אני הולך ללכת קדימה ולעשות בתמורה. 

אוי לא, הצהרת מרומזת של פונקציה. עשיתי את הטעות הזאת לפני, לא ביג דיל. תן לי רק להקליד, או להדגיש להעתיק, אב טיפוס הפונקציה בדיוק, או חתימה, של פעולת הרמה כאן. או שאני יכול להעביר את הפונקציה כולו. 

אבל זה קצת עצלן. אז אנחנו לא נעשה את זה. עכשיו, הרשו לי להכניס בחזרה שוב, נקודה בתמורה נטויה. 

x הוא 2. x בריבוע הוא 4. x הוא 3. x בריבוע הוא 9. ואת הפונקציה נראית עכשיו שזה עובד. אז מה ההבדל כאן? יש לי פונקציה נקראת מרובע, במקרה זה, אשר שמתי קלט. ואני לחזור פלט. ובכל זאת, בעבר, אם אני פותח את הדוגמא השנייה מוקדם יותר, אשר היה נקרא prototype.c, היה לי שם הדפסה, אשר חזר חלל, אם אפשר לומר כך, או שזה חזר כלום, היה פשוט תופעת לוואי. 

אז מה קורה פה? ובכן, כדאי לשקול את הפונקציה לקבל מחרוזת רק לרגע. אנחנו כבר באמצעות הפונקציה לקבל מחרוזת באופן הבא. 

היו לנו פונקציה לקבל מחרוזת, כמו כולל CS50.h, כולל, עיקרי, חלל IO.h, int רגיל. ואז כל פעם שאני קרא מחרוזת גט עד כה, שאמרתי משהו כמו, מחרוזת s מקבל מקבל מחרוזת, כי גט string-- בואו נקראים מחרוזת גט get.c-- זה עוצמה מחזירה מחרוזת כי אז אני יכול להשתמש, ולומר, הלו, פסיק, ים אחוזים, מהלך סרק n, s. 

אז זה אותו הדבר למשל, באמת, כי אנחנו קודם לכן. אז לקבל מחרוזת ומחזירה ערך. אבל לפני רגע, מחרוזת הדפסה אינו מחזיר ערך. זה פשוט יש תופעת לוואי. אז זהו הבדל מהותי. ראינו שונה סוגים של פונקציות החברה, שחלקם חזר ערכים, שחלקם לא. אז אולי זה שרוכים או int, או לצוף. או אולי זה רק חלל. 

וההבדל הוא כי פונקציות אלה כי לקבל נתונים להחזיר ערך הם למעשה להביא משהו בחזרה אל השולחן, כביכול. אז בואו נלך קדימה להסתכל קבוצה אחת סופית דוגמאות שנותנות תחושה, עכשיו, של כיצד נוכל, אכן, מופשט יותר, וטוב יותר, וטוב יותר, או יותר, ועוד, ועוד, על מנת כדי לכתוב, בסופו של דבר, קוד טוב יותר. בואו נלך קדימה, וברוח של גרד, לבצע את הפעולות הבאות. 

תן לי ללכת קדימה ולכלול CS50.h ורמת IO.h. תן לי להמשיך ולתת עצמי int, עיקרי, חלל. ותן לי ללכת קדימה, קורא cough.c זה. 

ותן לי ללכת קדימה ופשוט כמו גרד, להדפיס שיעול / n. ואני רוצה לעשות זאת שלוש פעמים. אז אני, כמובן, רק הולך להעתיק ולהדביק שלוש פעמים. עכשיו אני הולך לעשות להשתעל שיעול לוכסן נקודה. בואו לתת את עצמי בחדר קטן יותר כאן, זן, שיעול, שיעול, שיעול. 

יש, מן הסתם, כבר הזדמנות לשיפור. אני כבר להעתיק ולהדביק כמה פעמים היום. אבל זה היה רק ​​אז אני לא יש להקליד תווים רבים. אני עדיין שונה מה שורות קוד אלו. 

שלוש שורות אלה זהות, אשר מרגיש עצלן אכן הוא, והוא כנראה לא הגישה הנכונה. אז עם מה המרכיב נוכל לשפר את הקוד הזה? אנחנו לא צריכים להעתיק ולהדביק קוד. 

ואכן, כל פעם שאתה מרגיש עצמך העתקה והדבקה, ואפילו לא שינוי קוד, רוב הסיכויים הם שיש דרך טובה יותר. ואכן, יש. תן לי ללכת ולעשות עבור לולאה, למרות התחביר אולי לא בא בטבעיות עדיין. 

האם זה שלוש פעמים, פשוט על-ידי ביצוע following-- ואני יודע במקרה הזה מהפרקטיקה. אבל יש לנו מספר דוגמאות עכשיו. ואתה תראה באינטרנט יותר אזכור עדיין. 

זהו תחביר על קו 6, כי בדומה Scratch שחוזר בלוק, לחזור על שלוש הפעמים הבאות. זהו קסום מעט לעת עתה. אבל זה תקבלו יותר, ומוכר יותר. 

וזה הולך לחזור קו שמונה שלוש פעמים, כך שאם אני לקמפל מחדש שיעול לעשות, נקודת סלאש שיעול, שיעול, שיעול, שיעול. זה עדיין עובד באותה צורה. אז זה הכל טוב ויפה. אבל זה לא מאוד מפוזר. 

זה בהחלט נכון. אבל זה מרגיש כאילו יש יכול להיות הזדמנות, כמו בעולם של Scratch, לסוג של התחלה כדי להוסיף קצת סמנטיקה כאן כך אני לא רק צריך קצת עבור לולאה, ופונקציה שאומרת להשתעל, או שמא להשתעל. אתה יודע מה? תן לי לנסות להיות קריר מעט מזה, ולמעשה לכתוב פונקציה יש כמה תופעות לוואי, קוראים לזה להשתעל. 

וזה לוקח לא קלט, לא מחזיר ערך כפלט. אבל אתה יודע מה זה עושה? זה עושה זה- printf, ציטוט סוף ציטוט, להשתעל. 

ועכשיו עד כאן, אני הולך ללכת קדימה עבור int, אני מקבל אפס, אני פחות מ -3, אני פלוס פלוס. אני הולך לא לעשות printf, שהוא ניתן לטעון כי יישום ברמה נמוכה פרט. לא אכפת לי איך להשתעל. אני רק רוצה להשתמש בפונקצית השיעול. ואני רק הולך להתקשר שיעול. 

עכשיו, שימו לב לדיכוטומיה. כשאתה מתקשר פונקציה, אם לא רוצה לתת תשומות, לגמרי בסדר. פשוט תעשה פתח סוגריים, קרוב סוגריים, וסיימת. 

כאשר אתה מגדיר פונקציה, או להכריז על אב הטיפוס של פונקציה, אם אתה יודע מראש שזה לא הולך לקחת שום ויכוחים, אומר ריק בסוגריים אלה שם. וזה עושה בטוח שאתה לא ינצל לרעה את זה בטעות. תן לי ללכת קדימה ולעשות שיעול. וגם, כמובן, עשיתי טעות. 

לכל הרוחות, יש כי הצהרת מרומזת. אבל זה בסדר. זהו תיקון קל. אני רק צריך את אב הטיפוס במעלה בקובץ שלי מאשר אני בעצם השימוש בו. 

אז עכשיו תן לי לעשות שיעול שוב, נחמד. עכשיו, זה עובד. הפוך שיעול, שיעול, שיעול, שיעול. אז אתה יכול לחשוב שאנחנו באמת קצת יותר מ הנדסת בעיה זו. ואכן, אנחנו. זה לא טוב המועמד של תוכנית כרגע עבור בנייה מחדש, ועושה מה קרא פירוק היררכי, איפה אתה לוקח קצת קוד, ולאחר מכן סוג של גורם לך דברים החוצה, כדי לייחס יותר סמנטיקה להם, ושימוש חוזר בו בסופו של דבר בטווח ארוך. אבל זה אבן בניין כלפי יותר תוכניות מתוחכמות נתחיל כתיבה לפני הרבה זמן מאפשר לנו יש את אוצר המילים עם אשר לכתוב קוד טוב יותר. ואכן, בוא נראה אם ​​אנחנו לא יכול להכליל את זה עוד יותר. 

נראה קצת צולע שאני, עיקרי, צריך לדאוג לתקן את זה לולאה, וקורא שיעול שוב ושוב. למה אני לא יכול פשוט להגיד שיעול, אנא להשתעל שלוש פעמים? במילים אחרות, למה אני לא יכול פשוט לתת קלט להשתעל ולעשות את זה? 

למה אני לא יכול פשוט לומר, שיעול עיקרי שלוש פעמים. ועכשיו, זה סוג של כישוף. זה מאוד איטרטיבי כאן. וזה, אכן, צעד תינוק. 

אבל רק את היכולת לומר על קו שמונה, שיעול שלוש פעמים, זה פשוט כל כך הרבה יותר קריא. וגם, פלוס, אני לא צריך לדעת או אכפת איך הוא מיושם שיעול. ואכן, בהמשך טווח עבור פרויקטי גמר, אם לכם להתמודד עם פרויקט עם חבר לכיתה או שתיים לכיתה, תבין כי אתה הולך צריך, או רוצה, מחלק את העבודה. 

ואתה הולך רוצה להחליט מראש, מי הולך לעשות מה, ושבהם חתיכות? והאם לא יהיה נחמד אם אתה, למשל, לקחת אחריות על עיקרי בכתב, לעשות. ולשותפה שלך, או שלך שותף כללי יותר, דואג ליישום שיעול. 

והפיצול הזה, אלה קירות של הפשטה, או שכבות של הפשטה אם תוכל, הם סופר חזקים, כי במיוחד עבור גדול, יותר תוכניות ומערכות מורכבות, זה מאפשר לאנשים רבים לבנות דברים ביחד, ובסופו של דבר לתפור את עבודתם יחד בדרך זו. אבל, כמובן, אנו צריך לתקן שיעול עכשיו. אנחנו צריכים לספר שיעול כי, היי, אתה יודע מה? אתה הולך צריך לקחת input-- כך לא חלל, אבל int ועכשיו. בואו נלך קדימה והכנסנו להשתעל int. אני מקבל אפס. 

אני הוא פחות מ כמה פעמים. אמרתי שלושה לפני. אבל זה לא מה שאני רוצה. אני רוצה להשתעל כדי להכליל את תומך באף מספר החזרות. 

אז, אכן, זה n כי אני רוצה, מה שהמשתמש אומר לי. עכשיו, אני יכול להמשיך ולומר שיעול הדפסה. ולא משנה מה מספר המשתמש עובר, אני אחזור פעמים כי רבות. 

אז בסוף היום, התכנית היא זהה. אבל שם לב את כל הדברים האלה אפילו יכול להיות בקובץ אחר. אכן, אני לא יודע על רגע איך printf מיושם. 

אני לא יודע כרגע כיצד לקבל שרוכים או לקבל int, או לקבל לצוף מיושמים. ואני לא רוצה לראות אותם על המסך שלי. כמו כן, הוא, אני מתחיל להתמקד התוכנית שלי, לא פונקציות אלה. 

וכך, אכן, ברגע שאתה להתחיל הפקטורינג קוד כזה החוצה, אפילו שאנחנו יכולים לעבור שיעול לקובץ נפרד? מישהו אחר יכול ליישם את זה. ואתה והתכנית הופכים מאוד יפה, מאוד קריא, ניתן לטעון, באמת ארבע קו תכנית ממש שם. 

אז בואו נלך קדימה עם חברה ולעשות עוד שינוי אחד. שימו לב כי אב הטיפוס שלי יש לשנות למעלה. אז תנו לי לתקן את זה כל כך אני לא לקבל צעק. 

הפוך שיעול, תן לי לרוץ שיעול פעם יותר, עדיין עושה את אותו הדבר. אבל עכשיו, שימו לב שיש לנו מרכיב עבור גרסה סופית אחד. אתה יודע מה? אני לא רוצה רק להשתעל, בהכרח. אני רוצה שיהיה לי משהו יותר כללי. אז אתה יודע מה? אני רוצה לעשות את זה. אני רוצה שיהיה לי, ממש כמו שריטה עושה, בלוק למשל, אבל לא רק לומר משהו קצת מספר פעמים. אני רוצה להגיד את זה מחרוזת מאוד ספציפית. ולכן, אני לא רוצה את זה רק כדי להגיד שיעול. אני רוצה להגיד את זה מה מחרוזת מועברת. 

אז שם לב, אני כבר להכליל זה כך שכעת נניח מרגיש כמו שם טוב לכך, כמו שריטה, לוקח שתי טענות, בניגוד Scratch. אחת היא מחרוזת. האחד הוא int. 

ואני יכול לעבור אותם. אני פשוט סוג של אוהב את הרעיון של לומר את המחרוזת הראשונה, ולאחר מכן כמה פעמים לאחר מכן. Void אומר שזה עדיין לא מחזיר שום דבר. אלה הם רק צד חזותי תופעות, כמו עם [? ירדן,?] תופעת לוואי מילולית של צעקות. זה עדיין עושה פעמים משהו n, 0 עד, אבל לא שווה n. משמעות הדבר היא פעמים בסך הכל n. ואז פשוט להדפיס את מה שזה מחרוזת הוא. אז אני כבר באמת כללי שורת הקוד הזה. אז עכשיו, איך אני מיישם פונקצית השיעול? 

אני יכול לעשות שיעול ומבוטל. ואני עדיין יכול לקחת כמה הרבה פעמים אתה רוצה להשתעל. אבל אתה יודע מה? עכשיו אני יכול לומר דוגית. 

אני יכול להתקשר להגיד עם שיעול מילה, עובר n. ואם אני רוצה גם ליישם, סתם בשביל הכיף, פונקציה עיטוש, אני יכול להתעטש כמה וכמה פעמים. ואני יכול להשאיר שימוש חוזר n, כי להבחין כי מ 'בהקשר או היקף זה קיים רק בתוך הפונקציה הזאת. 

ו- N בהקשר זה רק קיים בתוך פונקציה זו כאן. אז אנחנו נחזור סוגיות אלה של היקף. והנה, אני רק הולך להגיד, באצ'ו, ולאחר מכן n פעמים, פסיק. 

ועכשיו, אני רק צריך לשאול פונקציה אלה חתימות עד כאן. אז השיעול נכון. עיטוש Void נכון עכשיו. 

ואני עדיין רק צריך לומר. אז אני הולך להגיד, אגיד מחרוזת s, int n, פסיק. אז אני כבר יתר מהונדס לעזאזל מחוץ תוכנית זו. 

וזה לא בהכרח זה מה שאתה צריך לעשות בעת כתיבת אפילו הפשוט ביותר של תוכניות. קח משהו שהוא ללא ספק ממש פשוט, ממש קצר, מחדש ליישם אותו באמצעות דרך קוד מדי. אבל אתה בעצם תראה, וב הזמן להסתכל אחורה על דוגמאות אלה, ולהבין, הו, אלה הם הצעדים לקחנו להכליל למעשה, גורם משהו, עד בסוף היום הקוד שלי הוא בעצם די סביר. כי אם אני רוצה להשתעל שלוש פעמים ואחרות מתעטשות שלוש פעמים, אני פשוט הולך להפעיל מחדש זו, התוכנית להפוך שיעול, ולהפעיל שיעול. ויש לי שלושה שיעולים ושלוש מתעטש. 

וכך זה הוא בסיסי הפרדיגמה, אם תרצו, עבור כיצד נוכל ללכת על למעשה ביישום תוכנית. אבל בואו רק לראות עכשיו מה הוא אנחנו כבר עושים כל הזמן הזה, ומה כמה חתיכות הסופיות עומד מאחורי פקודה פשוטה זו. בסוף היום, יש לנו כבר משתמש קלאנג כמו המהדר שלנו. אנחנו כבר כותבים מקור קוד, המרתו באמצעות קלאנג לקוד מכונה. 

ואנחנו כבר משתמש הפוך רק כדי להקל הקשות שלנו כל כך כי אין לנו לזכור אלה לחשים של קלאנג עצמה. אבל מה היא תעשה בעצם עושה? וזה, בתורו, מה הוא קלאנג בעצם עושה? 

מתברר, כי יש לנו פשוט הדיון היום באומרו, אתה לוקח את קוד המקור, להעביר את זה כמו קלט מהדר, אשר נותן לך פלט של מכונית קוד, מתברר של שם כמה צעדים שונים בפנים. קומפילציה קורית להיות המטרייה טווח עבור חבורה של צעדים שלמה. אבל בואו רק להקניט זה החוצה ממש מהר. 

מתברר כי אנחנו כבר עושים דברים יותר בכל פעם שאני מפעיל תוכנית, או בכל פעם שאני לקמפל תוכנית היום. אז עיבוד מקדים מתייחס זה- דבר בתוכנית C, כפי שנראים שוב ושוב, שמתחיל עם סמל חשיש זה, או סמל hashtag כאן, אומר זה הנחיה preprocessor. כלומר, במקרה זה, היי מחשב, לעשות משהו עם הקובץ הזה לפני שאתה בעצם לקמפל קוד משלי. 

במקרה זה, חשיש לכלול הוא, למעשה, הדרך של C לומר, היי מחשב, ללכת לקבל את התוכן של CS50.h ולהדביק אותם כאן. היי מחשב, לך לקבל את תוכן IO.h הסטנדרטי, איפה זה על כונן קשיח, ולהדביק אותו כאן. אז הדברים האלה לקרות לראשונה במהלך מקדים. 

ו קלאנג עושה את כל זה בשבילנו. והיא עושה את זה כל כך לעזאזל מהר, אתה אפילו לא לראות ארבעה דברים ברורים קורים. אבל זה הצעד הראשון מסוג זה. 

מה בעצם קורה עכשיו? ובכן, הפקיד הבא הצעד הוא קומפילציה. ומתברר כי קומפילציה תוכנית טכני אומר הולך מ קוד המקור, את החומר יש לנו כותב היום, למשהו בשם קוד הרכבה, משהו זה נראה קצת שונה. 

ואכן, אנו יכולים לראות את זה ממש מהר. תן לי בעצם להיכנס IDE שלי. תן לי ללכת קדימה hello.c הפתוח, אשר היא התוכנית הראשונה מאוד שבה אנו החל היום. ותן לי להמשיך ולהפעיל קלאנג קצת אחרת, קלאנג-ים, hello.c, אשר למעשה הוא הולך תן לי hello.s קובץ אחר. 

ואנחנו כנראה לעולם שוב רואה את זה סוג של קוד. אם אתה לוקח לרמה נמוכה יותר בכיתת מערכות כמו CS61, אתה תראה הרבה יותר מסוג זה של הקוד. אבל זה בשפת אסמבלי. זוהי שפת אסמבלי X86 כי המעבד כי הוא שבבסיס CS50 IDE בעצם מבין. 

וגם נסתר כפי שהיא עושה תראה, זה משהו המחשב מבין די טוב. q Sub, מדובר לחסר. יש תנועות. 

יש מתקשר של פונקציות כאן, x אורינג, תנועה, תוספת, פופ, תשואה. אז יש כמה מאוד הוראות ברמה נמוכה כי מעבדים להבין כי רמזתי קודם לכן. זה מה Intel Inside. 

ישנם דפוסי אפסים ואחדים כי ממופים מנוסחים arcanely אלה, אבל במקצת בשם היטב, הוראות, כביכול. זה מה שקורה כאשר אתה לקמפל קוד שלך. אתה מקבל הרכבה שפה ממנה, אשר פירושו השלב השלישי הוא להרכיב לתוך קוד הרכבה, בסופו של דבר, אפסים ואחדות מכונת code--, לא טקסט שראינו הרגע לפני רגע. 

אז מראש עיבוד האם זה למצוא ולהחליף, ועוד כמה דברים אחרים. הידור לוקח המקור שלך קוד מ C, קוד המקור שכתבנו, כדי הרכבה קוד שאנחנו רק הציץ. רכבת לוקחת כי הרכבה קוד אפסים ואחדות כי המעבד באמת יהיה להבין בסוף היום. וקישור הוא הצעד האחרון זה יקרה עבור us-- שוב, כל כך מהר שאנחנו אפילו לא notice-- שאומר, היי המחשב, לקחת את כל אפסים ואת אלה נבע קומפילצית הקוד של הדוד, ו הפונקציה העיקרית שלו במקרה זה. 

היי המחשב, לך לקבל כל אפסים ואחדות כי הצוות CS50 כתב בתוך הספרייה CS50. מערבבים אלה עם דוד של. היי מחשב, ללכת לקבל את כל האפסים ואת אלה שמישהו אחר כתב שנים לפני עבור printf. ולהוסיף אותם לתוך העניין, כך יש לנו יש אפסים ואחדות שלי, אפסים ואחדות של הצוות CS50, אפסים ואחדות printf, וכל דבר אחר שאנחנו משתמשים. 

כולם מקבלים בשילוב יחד לתוך אחד תוכנית בשם, במקרה זה, שלום. אז להלן, נעשה זאת רק להשתמש קומפילצית המילה. ואנו לוקחים כמובן מאליו שכאשר אנחנו אומרים, לקמפל את התוכנית, זה אומר, היי לעשות עיבוד מראש, רכבת, וקישור. אבל יש באמת כמה דברים עסיסיים קורה שם מתחת למכסה המנוע. ובמיוחד אם אתם לקבל זמן מה סקרנים, אתה יכול להתחיל תוקע סביב ברמה נמוכה יותר זו. אבל לעת עתה, מבין בין המזנונים להיום הם פשוט תחילתו של תהליך, להרגיש נוח עם משהו כמו שלום עולם. ואכן, רוב מה שעשינו היום בהחלט לא לשקוע סופר מהיר. וזה ייקח קצת זמן, וכמה בפועל. ואת רוב הסיכויים הם, תוכל למיין של רוצה להכות במקלדת או לצעוק על המסך. וכל זה בסדר. למרות, ואולי מנסה לא לעשות אותו בספריה כל כך הרבה. 

ובסופו של דבר, תקבל אם להיות מסוגל, כדי להתחיל רואה דפוסים, הוא קוד טוב שכתבת וגם טעויות שביצעת. ועוד הרבה כמו תהליך של להפוך TF או CA הוא כמו, תתחיל להשתפר טוב למראה דפוסים אלה, ופשוט לפתרון שלך בסופו של דבר בעיות משלו. בינתיים, יהיה הרבה מאיתנו להלוות תמיכה אותך, לקחת אותך דרך זה. ובסופו של הדו"חות עבור כל הבעיות המתוכנן מודרך דרך כל הפקודות כי אני בהחלט יודע מ הרבה תרגול על ידי חברה, אבל ייתכן ועופפתי מעל ראשו של אחד לעת עתה. וזה לגמרי בסדר. 

אבל, בסופו של דבר, אתה הולך כדי להתחיל לראות דפוסים. וברגע שאתה מצליח לעבור את כל פרטים טפשים, כמו סוגריים, ו סוגריים מסולסלים, חצי נקודות, ואת הדברים, ולמען האמת, כי הוא בכלל לא מעניין מבחינה אינטלקטואלית. וזה לא המטרה של נקיטה כל כיתת מבוא. זהו רעיונות כי הם הולכים משנה. 

זה לולאות, ואת תנאים, ואת הפונקציות, ועוד בעוצמה ההפשטה, ואת הפקטורינג של קוד, ואת העיצוב הטוב, וטוב סגנון, ובסופו של דבר את הנכונות של הקוד שלך, זה בסופו של דבר הולך החשוב ביותר. אז בשבוע הבא, אנו ננקוט אלה רעיונות שראינו הראשון Scratch עכשיו תרגם ל C. ונתחיל כדי להציג את הראשון של תחומים בעולם האמיתי של הקורס. 

נתמקד בעולם של ביטחון, ועוד קריפטוגרפיה במיוחד, האמנות של ערבול מידע. ובקרב הראשון בעיות שאתה עצמך יקבל לכתוב מעבר לשחק עם כמה התחביר ופתרון כמה הגיוני בעיות, בסופו של דבר עבר זמן רב, הוא ממש לטרוף, או להצפין, ובסופו של דבר לפענח מידע. וזה מה שעשינו היום, יהיה נמוך למדי רמה, רק הולכת לאפשר לנו לקחת אחד, ואחד, ועוד אחד צעד מעל כלפי כתיבת הקוד המעניין ביותר עד כה. 

אז עוד על כך בשבוע הבא. 

[הפעלת סרטון] 

-מה אתה יכול לספר לי על הפעם האחרונה שראית אותו? מה אני יכול להגיד, באמת? זאת אומרת, זה היה כמו כל האחרים חזרות טרום ייצור, מלבד שיש משהו שהוא אמר בסוף מאוד כי תקוע איתי. 

-זהו היה CS50. 

ההיא." זהו כולם לחתוך, עבודה נהדרת על חזרות. 

הצהריים של ההיא."? 

'כן, אתה ואני יכול לתפוס כריך קצת. תן לי רק לתחקר עם דוד ממש מהר. דוד? דוד? 

[סוף PLAYBACK] 