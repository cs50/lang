[MUSIC SVIRA] DAVID J. Malan: U redu, ovo je CS50. I ovo je tjedan jedan. Dakle podsjetiti da je posljednji put u tjedan dana nula, smo se usredotočili na računalnom razmišljanja. A mi prebačen iz koje se Scratch, grafički programiranje jezik od naših prijatelja na MIT Media Laba. 

A s nule, zar smo istražiti ideje kao što je funkcija i stanja, i petlje, i varijable, pa čak i događaje i teme, i još mnogo toga. I danas, mi smo idući u nastaviti koristiti te ideje, i stvarno ih uzimati za gotovo, ali prevesti ih na drugi jezik poznat kao C. Sada, C je više tradicionalna jezik. To je niža razina jezik, ako hoćete. 

To je čisto tekstualnog. I tako na prvi pogled, to je sve će izgledati prilično zagonetan ako ste nikada nije programiran prije. Mi ćemo imati polu-dvotočke i zagrade, i vitičastim zagradama, i još mnogo toga. Ali shvatite da čak i iako sintaksa je o da izgleda malo upoznati za većinu vas, vidjeti dalje od toga. I pokušati vidjeti ideje to su, zaista, poznato, jer ovdje u tjednu jedna ono počet ćemo učiniti je usporediti, u početku, Scratch naspram C. 

Tako, na primjer, podsjetiti da kada smo proveden je prvi od naših programa zadnji put smo imali blok koji je izgledao malo nešto učinimo, kada je zelena zastava kliknuo, a onda smo imali jedan ili više slagalice ispod njega, u ovom slučaju, recimo, Hello World. Pa, zapravo, ispočetka, kad kliknem na tu zelenu zastavu pokrenuti svoj program, tako govoriti, to su blokovi koji se izvršavaju, ili trčanje. I, posebno, ispočetka rekao je, zdravo, svijet. 

Sada sam mogao navesti različite riječi ovdje. No, vidjet ćemo da je, doista, mnogo tih blocks-- I doista, u C mnoge functions-- može biti parametrizirana ili prilagoditi raditi različite stvari. U stvari, na C kada smo želite pretvoriti, a sada, ovo Scratch programu na ovom drugom jeziku, ćemo napisati Malo nešto ovako. 

Priznajem, tu je neki nepoznat sintaksa tamo najvjerojatnije, int, i zagrade, i nevažeće. Ali printf-- čak i ako bi mislim da bi samo biti ispisa. No, print znači ispis formatiran, kao što ćemo uskoro vidjeti. To doslovno će ispisati na zaslon god nalazi se unutar tih zagrada, što Naravno, u ovom slučaju je, zdravo svijet. 

Ali vi ćete primijetiti neke druge sintaksa, neki dvostruki navodnici, da su zagrade na kraju, polu-kolona i slično. Tako da je malo iznad glave, da tako kažemo, i spoznajno i sintaktički, da idemo imati na umu prije dugo. Ali shvatite da s praksom, to će početi iskočiti na vas. 

U stvari, neka se usredotočiti na tome Funkcija specifically-- u ovom slučaju, pozdravi svijet. Pa kažu da je funkcija. Pozdrav svijetu je njegova parametar, ili argument, njegova prilagodbu. 

A ekvivalentnost u C je samo će biti tu jednu liniju ovdje gdje printf je ekvivalent za, recimo, dvostruko citirani string, zdravo Svijet je ekvivalent, naravno, na ono što je u bijelom okviru tamo. I kosih crta n, iako malo čudno i odsutno od nule, jednostavno će imati učinak ćemo vidi u računalu, kao što je moj Mac ili PC-u, samo pomicanjem pokazivač u sljedeći redak. To je kao udaranje Ulaz na tipkovnici. 

Tako ćemo vidjeti da opet ne zadugo. Ali prvo, neka je pogledati ovo Drugi primjer u slučaju petlje. Imali smo tu zauvijek petlju posljednji put, koja je bila serija slagalice da je nešto doslovno forever-- u ovom slučaju, kažu, Hello World, Hello World, Hello World, Hello World. Dakle, to je beskonačna petlja po dizajnu. 

U C, ako želimo za provedbu ovog Ista ideja, mogli bi jednostavno to učiniti. Dok je istina, printf zdravo svijet-sada a, samo semantički, vrsta dočarava ideju radi nešto opet, i opet, i opet, i na koliko dugo? Pa, true-- podsjetiti da je istina je samo na dan ili jednom. 

A istina je, naravno, uvijek točno. Dakle, to je vrsta beznačajno izjava samo reći istina. Ali doista, ovo je namjerno, jer ako je istina samo je uvijek istina, nego dok je istina upravo implicira, ako je malo indirektno, koji od sljedećih linija koda između tih vitičastim zagradama samo treba izvršiti ponovno, i ponovno, i opet, i zapravo nikad prestati. 

Ali ako želite da se vaš petlje da se zaustavi, kao i mi prošli put s nečim poput ovo ponoviti sljedeće 50 puta, u C možemo učiniti isto s onim što je naziva za loop-- ključnu riječ ne bude vremena, ali za. I onda imamo neku novu sintaksu ovdje s int i = 0, i manje od 50, i ++. A mi ćemo se vratiti na to. No, to je jednostavno način na koji bi prevesti set nule blokova na skupu C linija koda. 

U međuvremenu, u obzir varijable. A, u stvari, samo mi vidio jedan trenutak prije. I u slučaju nule, ako htjela proglasiti varijablu nazvao sam za i biti cijeli broj, samo broj, i želimo postaviti na neku vrijednost, mi bi koristili ovu naranču blokirati here-- ja postavljena na 0. 

A vidjet ćemo danas i dalje, baš kao i prošlog tjedna, programeri učiniti gotovo uvijek početi brojati od nule, stvarno po konvenciji. Ali i zato što RECALL naša rasprava o binarnom sustavu, najmanji broj možete predstavlja s bilo kojim brojem bitova je pravedan idući u biti 0 sebe. I tako ćemo općenito početi inicijalizacije čak i naše varijable na 0. 

A u C da učine isto, ćemo reći int za cijeli broj, ja samo po konvenciji. Mogao sam nazvao varijabla sve što želim, baš kao u nule. A onda je jednak 0 samo prenijetih prava vrijednost 0 s desne i stavlja ga u varijablu, odnosno skladištenje kontejnera tamo, na lijevoj strani. A-zarez kao što ćemo see-- i vidjeli smo neke od tih already-- samo znači kraj misli. Nastavite raditi nešto drugo na linijama koje slijede. 

Sada, što je Boolean izraza? Sjetite se da je ispočetka, to su izrazi da su bilo istinito ili false-- pitanja, Stvarno, to su ili istinite ili lažne. Dakle, u slučaju nule, mogli bismo postaviti jednostavno pitanje kao što je ovaj, je i manje od 50? Tako sam, opet, je cijeli broj. Možda smo ga koristite u Scratch programu pratiti rezultatom ili tako nešto. Dakle, ovo sintaksa ovdje u nule samo znači, je i manje od 50? Pa, srećom, nešto je Jednostavan u C. A prevesti, to bismo jednostavno reći da mi manji od 50, koristeći poznatu ključ na tipkovnici. 

U međuvremenu, ako ste htjeli reći nešto više općenito, kao, dobro je x manje od y, gdje svaki x i y su sami varijable? Mi možemo učiniti istu stvar u C, tako dugo dok imamo stvorio ove varijable već. I vidjet ćemo kako to prije dugo. Mi bismo jednostavno reći x manje od y. 

Tako ste počinju vidi neke sličnosti. A oni ljudi koji su napravili Scratch je sigurno inspirirani nekim od tih osnovnih ideja. I vidjet ćete ovu vrstu Sintaksa u mnogim languages-- ne samo nule, ne samo C, ali Python, i JavaScript i drugi jezici dalje. 

Razmotrimo još jedan konstrukt iz C, pojam stanja, radi nešto uvjetno. Ako je nešto istina, to učiniti. Ako je istina nešto drugo, to učiniti. To je vrsta programiranja ekvivalent raskrižju. Možda je to dvosmjerna vilica, troputni vilica, ili više. A ispočetka, možemo imati vidio ovako nešto. 

Dakle, ovaj je jedan veliki. No, smatra da je relativna Jednostavnost logike. Ako je x manje od y, onda kažu x je manje od y, inače ako je x veći od y, onda reci je x veći od y. A onda, logično, ako mislite natrag ispočetka ili samo svoj vlastiti ljudski intuicija, i, ako x nije veći od y i x nije manja od y, tada naravno x će biti jednako y. Dakle, u ovom slučaju, gniježđenje ti Scratch blokovi, možemo postići tri način račvanje na cesti? 

U međuvremenu, ako želimo to u C, što nedvojbeno izgleda malo simpler-- najmanje jednom kada se upoznati s sintakse. Ako je x manja od y, printf x je manji od y. Inače ako je x veći od y, printf je x veći od y. Drugi printf x jednak y-- i opet, s onima kosih crta završava upravo za one nove linije, tako da ako zapravo vodio ovu vrstu programa to bi samo premjestiti kursor na kraju na sljedeći redak zaslona. 

Sada, u međuvremenu ispočetka imao druge više sofisticirane značajke, samo od kojih su neke idemo na u početku premjestiti na svijetu C. A jedan od njih je bio zove se popis u nule. A to je posebna Vrsta varijable koje dopušteno da pohraniti više stvari u natrag, natrag, natrag, natrag. 

U C, što nema liste, sami po sebi, ali nešto koji su uglavnom naziva polja, iako ćemo vratiti se kasnije ovaj semestar da gleda na nešto zove popis ili stvarno vezana lista. No, za sada, u kojem se nalazi ekvivalent u C za nas će biti nešto nazvao polje. I niz je jednostavno Posebna vrsta varijable koji vam omogućuje pohranu podataka natrag, natrag, natrag, na leđa. 

I doista, u nule, ako smo htjeli pristupiti prvi element niza ili list-- i ja ću ga nazvati, Po dogovoru argv, argument vektor, ali više o tome prije dugo. Ako želim da se na prvi element od argv, u svijetu nule što zapravo učiniti obično početi brojati od 1. 

I tako sam mogao dobiti stavak 1 argv. To je samo kako MIT provodi pojam liste. Ali u C, idem više jednostavno samo reći, argv, što je opet ime moje list-- ili da bude jasno, niz. A ako želim prvo elementi, idem koristiti uglate zagrade, što vam možda nije često koristi u tipkovnicu. 

Ali, 0 samo znači, daj mi prvi. Dakle, povremeno i kao vrijeme prolazi, idemo kako bi se vidjeli ove dihotomije između nule i C, pri čemu ispočetka koristi jedan. Mi u C korištenje 0 ovdje. No, uskoro ćete vidjeti kad jednom shvatiti temelji svakog jezika, da te stvari počnu da se sve više upoznati kroz praksu i praksu. 

Tako ćemo zapravo pogled sada na programu. Ovdje će biti prvi od naših C izvorni kod za cjelovitim programima. A program ćemo ponuditi na razmatranje je onaj koji je ekvivalent kako to ranije Scratch komadu. 

Dakle ovdje imamo ono što je vjerojatno najjednostavniji C program možete napisati da zapravo radi nešto. Sada ćemo pogledati prošlost, za sada, nije uključuju, standardni io.h, a to kut Nosači i int i prazna, i vitičastim zagradama, i slično. 

I neka je samo usredotočiti na ono, barem intuitivno, Možda iskočiti na vas već. U stvari, uglavnom, ne znam nužno znati što je ovo, ali baš kao i ispočetka imala da kad zelena zastava kliknuo slagalice, tako i C kao programski jezik imati glavni dio koda koji dobiva pogubili po defaultu. I, doista, to doslovno će se zvati glavna. 

Dakle, glavna je funkcija. I to je posebna funkcija koja postoji u C da kada pokrenete program, to je glavna koji se vodi zadano. U svijetu ispočetka, bilo je uobičajeno kada se zelena zastava kliknuo koji je dobio automatski pokrenuti. 

U međuvremenu, vidjeli smo to i prije, printf ili ispisati formatirani, to je će biti funkcija koja dolazi s C, zajedno s cijelom hrpom drugih, koji će se s vremena i vremena opet, kako bi učiniti upravo Kao što mu ime govori, nešto ispisati. Što želimo ispisati? Pa, vidjet ćemo da je zatvaranjem znakova kao these-- Pozdrav svijetu, Obrnuta kosa crta n u dvostrukim navodnicima, možemo reći printf točno Što se ispisati na ekranu. 

Ali kako to učiniti da, nažalost je potrebno da se nešto što je Već zagonetan za nas ljudi, ali barem je nešto readable-- oštri su, standardna io.h, int, Glavni, praznina, printf, sve čarobne incantations smo upravo vidjeli na ekranu. No, mi zapravo treba da ići više kompliciranih i dalje. Prvo moramo prevesti šifru da pišemo u strojni kod. I sjećam od prošlog tjedna da se strojevima, barem one što znamo ovdje, na kraju dana samo razumjeti nula i jedinica. 

A Bože moj, ako smo morali pisati ovih nula i jedinica zapravo program, to bi vrlo, vrlo brzo ponijeti ni iz čega. No, ispostavilo se, po prošlog tjedna, da su ti obrasci nula i jedinica Samo imaju posebno značenje. U određenim kontekstima, oni mogu značiti brojeva. 

U nekim kontekstima, oni bi moglo značiti slova ili boje, ili bilo koji broj drugih apstrakcija tamo na. No, baš kao što je na računalu CPU, Central Processing Unit, ili mozak unutrašnjosti računala. To je obično Intel unutra, jer to je jedna od najvećih tvrtki koji čini CPU za računala. 

Pa, Intel CPU i drugi Jednostavno su odlučili unaprijed da određeni obrasci nule i Oni će značiti određene stvari. Određeni obrasci nula i jedinica znači, ispisati na ekran, ili dodati ta dva broja, ili oduzimanje ta dva broja, ili premjestiti ovaj dio podataka iz memorija mojeg računala ovamo, ili bilo koji broj druge vrlo niske razine, ali u konačnici korisno, za operacije. No, na sreću, mi ljudi se ne ide da moraju znati tu razinu detalja. Doista, baš kao i zadnji put, gdje smo rastresen opet, i opet, i opet, Zgrada od vrlo niske razine primitivci poput nula i jedinica viših pojmova razini poput brojeva i slova, i boje, i još mnogo toga, tako da možemo, kao programera stajati na ramenima drugi koji su došli prije nas i koristiti softver koji drugi ljudi su pisali prije us-- naime programa pod nazivom prevodioce. 

C je jezik koji obično je sastavljen, što znači pretvorena iz izvorni kod za strojni kod. Konkretno, to znači je da, ako ste dobili svoj izvor Kod koji ste sami napisati, kao što je prije će se u samo jednom trenutku na ekranu, i želite ga pretvoriti u konačnici stroj code-- ta nula i jedinica koje samo vaš Mac ili računalo understands-- što je dobio prvi hraniti taj izvorni kod u što ulaz za poseban Program pod nazivom prevodilac, izlaz od kojih Vidjet će se stroj kod. I, doista, posljednji put smo razgovarali o, zaista, na kraju dana, rješavanje problema. Imaš ulaza. A imaš izlaza. A ti imaš nekakav algoritma u sredini. 

Algoritmi se mogu sigurno ugraditi u softver, kao što smo vidjeli u pseudokod prošlog tjedna i kao što ćemo vidjeti u stvarnom kodu ovaj tjedan. I tako prevodilac zapravo samo ima skup algoritama unutar od toga da znam kako pretvoriti posebne riječi, kao glavni i printf, i ostali koje smo upravo vidjela u uzorcima nule i one koje Intel Inside i ostali CPU zapravo ne razumije. Pa kako ćemo to učiniti? Gdje ćemo dobiti prevodilac? 

Većina nas ovdje ima Mac ili PC. I koristite Mac OS, ili Windows ili Linux ili Solaris, ili bilo koji broj drugih operativne sustave. I doista, mogli bismo izaći na webu i preuzeti prevodilac za Mac ili računalo za vaš operativni sustav. Ali, svi mi bi se na različite stranice, da tako kažemo. Imali smo malo različite konfiguracije. A stvari ne bi raditi sve isto. I, štoviše, ovih dana mnogi od nas ne koriste softver koji radi samo na našim prijenosnicima. Umjesto toga, mi koristimo nešto kao preglednik koji omogućava nam da pristup web-based aplikacija u oblaku. A kasnije ovaj semestar, mi ćemo učiniti upravo to. Mi ćemo pisati aplikacije ili softver pomoću code-- nije C, ali drugi jezici kao što su Python i JavaScript-- koji rade u oblaku. 

A za to, mi sami tijekom semestra će zapravo koristiti oblak-based okolina poznata kao CS50 IDE. Ovo je web-based programiranje okoline ili integrirani razvoj okolina, IDE, koji je izgrađen na vrhu neke open source softvera zove Cloud 9. A mi smo napravili neke pedagoško pojednostavljenja za njega kako sakriti određene značajke u prvih tjedana da mi ne trebaju, nakon čega možete otkriti ih i napraviti najviše sve što želite s okolinom. 

I to nam omogućuje, također, unaprijed instalirati određeni softver. Stvari kao što su tzv CS50 knjižnica, koja uskoro ćemo vidjeti pruža nam u C s nekim Dodatna funkcionalnost. Dakle, ako idete, u konačnici, CS50.io, vas će se tražiti da se prijavite, a nakon što učiniti i stvoriti račun za besplatno, ćete biti u mogućnosti pristupiti okolina koja izgleda baš ovako. 

Sada, to je u zadanom načinu rada. Sve je lijepo i svijetle na zaslonu. Mnogi od nas imaju naviku radi na CS50 komad koji je kasno u noći. I tako su neki od vas možda radije pretvoriti ga u noćni način rada, da se tako izrazim. 

No, u konačnici, ono što ste idući u vidjeti u CS50 IDE je tri različita areas-- područje na lijevoj strani gdje datoteke će biti u oblak, područje u gornjem desnom uglu gdje je vaš broj će biti moguće. Vi ćete biti u mogućnosti otvoriti pojedinačne kartice za bilo koji program da li napisati ovaj semestar iznutra Od toga gornjem desnom kutu. I onda većina arcanely, a ipak snažno, će biti to stvar u Dno poznat kao prozor terminala. 

To je stara škola Command Line Interface, ili CLI, koja omogućuje izvršavanje naredbe na computer-- u ovom slučaju, računalo u cloud-- učiniti stvari kao što sastaviti svoj kod od izvorni kod za strojni kod, pokrenuti svoje programe, ili za početak svoje web server, ili za pristup svoje baze podataka, i bilo koji broj drugih tehnika da ćemo početi koristiti prije dugo. No, da bi se tamo, mi smo će zapravo otići online i početi igrati. A za to, neka prvi početi petljaju s glavnom, i pisati glavni dio programa. I neka je koristiti tu funkciju printf, koje smo koristili ranije, jednostavno nešto reći. 

Dakle, ovdje sam već unutar CS50 IDE. Ja sam prijavljen unaprijed. I ja sam pun prikazan prozor. I tako, na kraju, vi previše u nadolazećim problemima će slijediti slične korake koje će pružiti on-line dokumentaciju. Dakle, ne morate brinuti o tome upijajući svaki mali tehnički korak da ja ovdje danas. 

Ali vi ćete dobiti zaslon kao što je ovaj. Ja se dogoditi da se u noćnom načinu rada. A možete ukrasiti sve se onemogućavanjem noćni način rada. I na kraju od dan, ti si idući u vidjeti ova tri glavna areas-- datoteke preglednik na lijevoj strani, a kod kartice do vrha, i terminal prozor na dnu. 

Pusti me naprijed i napisati svoj prvi program. Idem preventivno ići na File, Uštedite i spremiti svoju datoteku kao hello.c. Doista, po konvenciji, bilo koji program mi napisati da je napisan u C jeziku trebao biti imenovan nešto točka c, po konvenciji. Tako da ću to ime hello.c, jer Samo želim pozdraviti svijetu. Sada ću za uvećanje van, a zatim kliknite Spremi. I sve što imam sada ovdje je kartica u kojem mogu početi pisanja koda. 

To se ne događa sastaviti. To ne znači ništa. I tako, čak i ako sam pretvoren to nula i jedinica, CPU će imati nikakav pojma što se događa okolo. Ali, ako sam pisati stihove koji ne podudaraju s kasiopejske conventions-- C bića, opet, to language-- sa sintaksom slično ovo printf zdravo svijet-a ja sam dobivši ugodno s to s vremenom. Dakle, ne mislim da sam napravio tiskarske pogreške. 

Ali, uvijek, prvi put kada to učinite, od vas će. A što ću učiniti to se vrlo dobro ne rade za vas prvi put. I to je sasvim u redu, jer upravo sada možda samo vidjeti puno novosti, ali s vremenom nakon što se upoznaju s tom okruženju, a taj jezik, i drugi, ćete početi vidjeti stvari koje su ispravna ili pogrešna. 

A to je ono što je nastavne drugovi i naravno asistenti dobiti tako dobri u vremenu, je uočavanje greške ili greške u kodu. Ali ja tvrdim da postoji nema greške u ovom kodu. Tako sam sada žele pokrenuti ovaj program. 

Sada na svom Mac ili PC, ja sam u navika dvostrukim klikom ikone kada želim pokrenuti neki program. No, to nije model ovdje. U tom okruženju, što je CS50 IDE. Mi koristimo operacijskoj Sustav pod nazivom Linux. Linux podsjeća na još jedan operativni sustav, općenito poznat kao Unix. A Linux posebno je poznat po ima Command Line okruženju, CLI. Sada, mi smo pomoću određenom Okus Linux zove Ubuntu. I Ubuntu je jednostavno sigurna verzija Linux. 

Ali tih Linux-a ovih dana to zapravo dolaze s grafičkim korisničkim sučeljima. A jedan mi se dogoditi da se koristi ovdje je web-based. Dakle, to može izgledati čak i malo drugačiji od nečega vi sami mogli imati vidjeti ili raditi u prošlosti. 

Tako ću ići naprijed sada i učinite sljedeće. Ja sam spasio ovu sliku kao hello.c. Ja ću ići naprijed i Vrsta clanghello.c Tako jeka za C jezik je prevodilac. To je unaprijed instaliran u CS50 IDE. A ti apsolutno može preuzeti i instalirati ovo na svoj Mac ili PC. 

Ali, opet, ne bi li sve pre-konfiguracija učinio za vas. Dakle, za sada, samo sam idući u trčanje clanghello.c. A sada primijetiti ovu sintaksu Ovdje će se s vremenom shvatiti samo znači da sam u mapu ili katalog naziva radnog prostora. Ovaj znak dolara je samo konvencija za smislom, upišite svoje naredbe ovdje. 

To je ono što se zove brz, samo po konvenciji je znak dolara. A ako ja ići naprijed i sada kliknite Ulaz, ništa ne čini da se dogodilo. Ali to je zapravo dobra stvar. Što manje što se događa na Vaš zaslon, to je vjerojatnije Vaš broj je biti točna, barem sintaktički. 

Dakle, ako želim pokrenuti ovaj Program, što da radim? Pa, ispada da je Zadani naziv po konvenciji za programe kada ne odredite naziv za svoj program je samo a.out. I to sintaksa previše, vi ćete upoznati se s prije dugo. 

Dot slash samo znači, hej, CS50 IDE, pokrenuti program pod nazivom a.out to je u mojoj trenutnoj mapi. To točkica označava trenutni direktorij. Pa ćemo vidjeti što druge takve sekvence znakova znači prije dugo. 

Dakle, ovdje mi ići, Enter, Hello World. I primijetit ćete da ono što se dogodilo? Ne samo da je ispisati Hello World. Također je premještena pokazivač u sljedeći redak. 

A zašto je to bilo? Što je kod koji smo pisali prije koji osigurava da se kursor bi ići na sljedeći redak? Čudno o Računalo je to samo ide raditi doslovno što to kažem. 

Dakle, ako ste mu reći da printf hello, zarez, prostor, svijet, u neposrednoj blizini citat, to je doslovno samo ide ispis tih znakova. Ali ja sam imao taj posebni znak na kraju, podsjetimo, obrnute kose crte br. I to je ono što osigurava da je lik otišao na sljedeći redak zaslona. 

U stvari, pustite me i to učiniti. Pusti me naprijed i izbrisati to. Sada, primijetiti da je vrh mog ekrana postoji malo crveno svjetlo na kartica ukazuje, hej, ne ste spremili datoteku. Tako ću nastaviti s kontrolom S ili naredba S, spremite datoteku. Sada je goes-- otišao za moment-- zeleno. A sada je natrag samo da je blizu ikona. 

Ako sam sada pokrenuti clanghello.c opet, Ući, dot slash, a.out, Enter, vidjet ćete da je još uvijek radio. Ali to je nedvojbeno malo lud. Upravo sada, mi prompt-- radni prostor, a zatim da znak dolara, a onda je moj stvarni prompt-- sve je na istoj liniji. Dakle, to svakako estetski bug, čak i ako to nije stvarno logičan bug. 

Tako ću poništiti ono što sam upravo učinio. Idem repriza a.out. Obavijest Dodao sam novi red karakter natrag. Ja sam spremili datoteku. 

Zato ću ponoviti a.out, and-- dammit, bug, bug znači grešku. Dakle, bug je da, iako dodao sam kosu crtu n postoji, ponovno spasio, ponovno je vodio program, ponašanje je bio isti. Zašto bi to bilo? 

Nedostaje mi korak, zar ne? Taj ključni korak ranije je da imate to-- prilikom promjene izvornog koda, ispada također pokrenuti to kroz prevodilac opet tako da ćete dobiti novi kôd stroja. A stroj kod, su nula i jedinica, će biti gotovo identičan, ali nije savršeno tako, jer nam je potrebno, Naravno, da je nova linija. 

Dakle, kako bi riješili ovo, ja ću trebati da repriza clanghello.c, ući, točku slash, a.out. A sada, pozdrav svijetu se vratio gdje sam očekivao da bude. Dakle, to je sve u redu i dobro. Ali a.out je prilično glupo ime za programa, iako se dogodi da se, iz povijesnih razloga, default-- znači montaža izlaza. 

No, dopustite mi ići naprijed ovdje i to učiniti drugačije. Želim da moj Hello World programa zapravo se zove zdravo. Tako da je ikona na moj desktop, to ne bi bilo a.out. To bi se moglo nazvati zdravo. 

Tako da to učinite, to ispada da zveket, kao i mnogih programa, podržava argumente naredbenog retka, ili zastave, ili prekidači, koji jednostavno utjecati na njegovo ponašanje. Naime, zveket podržava crtica oi Zastava, koja se zatim uzima drugu riječ. U tom slučaju, ja samovoljno ću, ali opravdano, nazivaju to zdravo. Ali mogao bih ga nazvati nešto Želim, osim a.out, koji bi radije osim točke. 

I onda samo navesti ime datoteke ja želim sastaviti. Tako sada, iako na početku naredbe još uvijek imaju zveket, na kraju naredbe Još uvijek imam naziv datoteke, Ja sada imam ove komandne linije argumenti, te zastave koje govore, oh, usput, izlaz-o, datoteka zove zdravo, a ne zadani a.out. 

Dakle, ako sam pogodio Unesite sada, ništa Čini se da se dogodilo. Pa ipak, sada mogu učiniti dot udarac zdravo. Dakle, to je isti program. Nula i one su identična krajem dana. 

Ali oni su u dva različiti files-- a.out, koja je prva verzija i samo ludo ime, a sada zdravo, što je znatno više uvjerljiv naziv za program. Ali, iskreno, nikad nisam će zapamtiti to opet, i opet, i opet. I, zapravo, kao što pišemo složeniji programi, naredbe koje ćete morati napisati će dobiti još više komplicirano i dalje. 

I tako da se ne brinem. Ispada da su ljudi prije nas su shvatili previše imao taj isti problem. Oni također ne uživaju da se tip prilično duge, kompliciranih naredbi, a kamoli ih zapamtiti. I tako su ljudi prije nas su napravili drugi programi koji olakšavaju sastaviti svoj softver. 

I, doista, jedan takav Program se zove napraviti. Tako ću ići naprijed i učiniti. Idem poništiti sve što sam upravo učinio na sljedeći način. Dopustite mi da upišete LS. A vi ćete primijetiti tri things-- a.out i zvijezda, zdravo i zvijezda, i hello.c. Na sreću, to bi trebalo biti malo intuitivno, utoliko što ranije nije bilo ništa u ovom radnom prostoru. Nije bilo ništa što sam imao stvorio dok nismo počeli klase. 

I ja sam stvorio hello.c. I onda ga sastavio, i nazvao ga a.out. A onda sam ga ponovo sastaviti nešto drugačije i nazvao ga pozdravi. Dakle, imam tri datoteke u ovaj direktorij, u toj mapi pod nazivom radnog prostora. Sada vidim da je dobro ako sam smanjivanje zapravo. 

Ako sam smanjivanje i ovdje pogledaj onu gornjem desnom rukom kutak, kao što je obećao lijeva Ruka stranu zaslona uvijek će vam pokazati što je na računu, što je unutar CS50 IDE. A tu je i tri datoteke tamo. 

Dakle, želim se riješiti a.out i zdravo. I kao što možda zamislite intuitivno, te mogao sortirati kontrole klikom ili desni klik na ovaj. I ovo malo pojavi izbornik. Možete preuzeti datoteku, pokrenite to, pregledati ga, osvježiti, preimenovati, ili što ne. 

I ja sam samo mogao izbrisati, i to bi otići. Ali neka je učiniti stvari s naredbom linija za sada, kako bi dobili udobna s tim, i to na sljedeći način. Ja ću ići naprijed i izvadite a.out upisivanjem doslovno rma.out. Ispada, naredbu za uklanjanje ili brisanje nešto, Nije ukloniti ili izbrisati. 

To je više jezgrovito RM, samo da se spasi ti neke tipke, i pritisnite Enter. Sada ćemo da se nešto zagonetno ukloniti redovite datoteke a.out. Ja stvarno ne znam što je to nepravilan datoteka će biti još. Ali ja želim da ga ukloniti. 

Dakle, idem na y tipa za potvrdan odgovor. Ili sam mogao je upisati i pritisnite Enter. A, opet, ništa ne čini da se dogodi. Ali to je, uglavnom, dobra stvar. 

Ako sam tip LS ovaj put, Što bih trebao vidjeti? Nadajmo se samo zdravo i hello.c. Sada, kao usput, vi ćete primijetiti ovu zvijezdu, zvjezdicu, to je na kraju svojih programa. I oni su također prikazuje u zelenoj boji. To je samo CS50 IRO način od vas cluing u činjenici da to nije izvorni kod. To je izvršna, A Runnable program koji zapravo možete pokrenuti obavljajući dot udarac, a onda je ime. 

Sada, neka mi ići naprijed i ukloniti ovaj, rm zdravo, Enter, uklanjanje redovni file Pozdrav, da. A sada, ako sam tip LS, vratili smo se do hello.c. Pokušajte ne brisati svoje stvarni izvorni kod. Iako postoje obilježja izgrađen u CS50 IDE gdje možete proći kroz reviziju povijesti i natrag u vremenu, ako vas slučajno brisanje nešto, ne biti svjestan kao i po tim poticajima da ili ne, ono što zapravo želite učiniti. Kad odem na vrh lijevom kutu ovdje sve što ostaje je hello.c. Dakle, postoji grozdove druge naredbe koje može izvršiti u svijetu Linuxa, od kojih je, opet, napraviti. A što ćemo napraviti moj program je sada na sljedeći način. 

Umjesto da rade zveket, umjesto da zveket-o, Idem jednostavno doslovno tipa, čine pozdrav. A sada primjetiti, ja sam Ne upisivati ​​bi hello.c. Ja sam tipkati napraviti pozdrav. 

I ovaj program učiniti da dolazi s CS50 IDE, i još mnogo toga općenito s Linuxom, je program koji je će napraviti program pod nazivom Hello. I to će preuzeti na sebe, po konvenciji, da, ako mogu napraviti taj program, to će se iz izvora broj datoteka koje završavaju na dot c, hello.c. 

Dakle, ako sam pogodio Unesite sada, obavijest da naredba koji se izvršava je zapravo još više Prije nego prije. A to je zato što imamo konfigurirano CS50 IDE imati neke dodatne značajke ugrađene u tome ne treba nam samo još, ali uskoro će. No, ključna stvar za shvatiti Sada imam Hello program. 

Ako sam ponovno upisati LS, ja imaju Hello program. I mogu ga pokrenuti s dot slash a.out, ne, jer je cijela točka ove Vježba je bila točka slash zdravo. I sad ja imam Hello World programa. Tako se kreće prema naprijed, smo gotovo uvijek samo će sastaviti naših programa korištenje naredbenog napraviti. A onda ćemo ih voditi dot udarac, i ime programa. Ali shvatili ono što čini čini za što je to sama ne prevodilac. To je samo pogodnost programa koji zna kako pokrenuti prevodilac izvoditi tako da se to može koristiti. 

Koje druge naredbe postoje u Linux, a zauzvrat CS50 IDE? Uskoro smo ćete da postoji CD naredba, Promjena imenik. To vam omogućuje roku Vaš komandna linija sučelje da se krene naprijed i natrag, i otvoriti različite mape bez upotrebe miša. 

LS smo vidjeli, koja se zalaže za popis datoteke u trenutnoj mapi. Provjerite semafore, možete vjerojatno početi zaključiti što je to značilo now-- napraviti katalog, ako želite stvoriti mapu. RM za ukloniti, RM Dir za uklanjanje directory-- i to, opet su komandne linije ekvivalenata od onoga što mogao učiniti u CS50 IDE mišem. No, uskoro ćete naći ponekad je to samo puno brže za napraviti stvari s tipkovnicom, i na kraju puno moćniji. 

No, teško je tvrditi da sve smo radili do sada je sve što je moćno, kada su svi smo reći je, Hello World. A, u stvari, kodirano sam riječi halo svijet u mom programu. Nema dinamizam još. Blok je bio red veličine zanimljivije je prošlog tjedna. 

I tako ćemo doći. Uzmimo korak ka da je način neke od tih funkcija. Dakle, ne samo C dolaze s printf, i kitice druge funkcije od kojih ćemo vidjeti tijekom vremena, to ne bi se sve to lako odmah od vrata na dobivanje korisničkog unosa. 

U stvari, jedna od slabosti jezika kao što su C, pa čak i Java, a ipak drugi je da se to ne dogodi olakšavaju samo dobiti stvari kao što su cijeli brojevi od korisnika ili žice, riječi, i fraze, a kamoli stvari poput pomičnim zarezom vrijednosti ili realni brojevi s decimalnim mjestima, i stvarno duge brojevi, kao što ćemo uskoro vidjeti. Dakle, ovaj popis funkcija ovdje, te poput drugih Blok slagalice koje smo unaprijed instaliran u CS50 IDE koji ćemo koristiti za nekoliko tjedana kao trening kotačima sorti, te na kraju ih skinuti i gledati ispod haube, možda, na kako te stvari provode. 

No, za to, neka je zapravo napisati program. Pusti me naprijed sada. I ja ću stvoriti nova file klikom na ovaj mali plus, i kliknete New File. 

Idem spasiti ovaj sljedeći on, kao, recimo, string.c, jer želim igrati sa žicama. I niz u C je samo niz znakova. Dakle, sada idemo naprijed i napraviti sljedeće. 

Uključi standardni IO.h-- i ispada standardne IO, IO samo znači ulaz i izlaz. Tako ispada da je ova linija Evo što je je nam susjedne koristiti printf. Printf, naravno, stvara izlaz. Dakle, kako bi se koristiti printf, ispada kako morate imati ovu liniju koda na vrhu datoteke. 

A mi ćemo se vratiti na ono što to zapravo znači prije dugo. Ispostavilo se da je u bilo C program pišem, Moram ga početi s kod koji izgleda ovako. A vi ćete primijetiti CS50 IDE, a drugi integrirani razvoj okruženjima poput njega, ćemo pokušati što bolje oni mogu završiti svoje misli. U stvari, trenutak prije, ako sam poništiti što sam upravo učinio, ja pritisnite Enter. 

I onda udario otvorenim kovrčavu Brace, udario opet Enter. I to završio moj misao. To mi je dalo novu liniju, razvedena ništa manje za lijepe stilskih razloga, vidjet ćemo. I onda on automatski mi je dao da kovrčava braće da završim misao. Sada, to nije uvijek pogodite što želite učiniti. A velikim dijelom, on ne uštedjeti neke tipke. Dakle, prije nekoliko trenutaka, imali smo tu program-- Pozdrav, svijet, a zatim ga sastavio, a zatim ga ran. Ali nema dinamika ovdje. Što ako smo htjeli učiniti nešto drugo? Pa, što ako sam htjela zapravo dobili niz od korisnika? Idem koristiti slagalice zove točno that-- dobiti niz. 

Ispostavilo se da u C da kada ne želite da daju svoj doprinos na puzzle komada, ili više pravilno na neku funkciju, koju doslovno samo napraviti otvorenu zagradu, blizu zagrada. Dakle, to je kao da postoji ne bijela kutija za unos u. Izgovori blok prije je malo bijeli okvir. Mi nemamo taj bijeli okvir sada. 

Ali kad ja zovem get niz, ja žele staviti rezultat negdje. Dakle, vrlo česta paradigma u C je pozvati funkciju, kao što get niz ovdje, a zatim pohraniti svoje povratnu vrijednost. To je rezultat njegove truda u nešto. 

A što je izgraditi u programiranju, bilo u nule i sada C, da mi mogu koristiti kako bi zapravo pohranu nešto? Nazvan je varijabla, zar ne? A u nule, mi stvarno ne zanima me što se događa u varijablama. 

No, u ovom slučaju, mi zapravo učiniti. Ja ću reći string. A onda sam se mogao nazvati ovo sve što želim. Idem ga nazvati ime i prezime, dobiva dobiti niz. 

A sada čak i ako ste malo novi u ovom, primijetiti da sam nedostaje neki detalj. Ja zaboravljam i zarez. Moram završiti ovu misao. Tako da ću pomaknuti pokazivač, i hit-zarez tamo. A što sam upravo učinio? U ovoj liniji koda, broj 5 u ovom trenutku, Zovem get niz bez ikakvih ulaza. Dakle, nema mali bijeli okvir poput Save blok ima. 

Samo kažem, hej, Računalo, daj mi niz. Znak jednakosti nije stvarno znak jednakosti, sam po sebi. To je zadatak operater, što znači, hej, računala, premjestili vrijednost s desne na lijevu. A u lijevo, imam sljedeće. 

Hej, računalo, daj mi string-- niz znakova. I poziv da string ime. I ne morate ga zovu ime. 

Mogao sam ga nazvati, uobičajeno, nešto poput S, baš kao što ja se nazvati varijable i. Ali sada moram nešto učiniti s njom. Bilo bi prilično glupo kompajliranja ovaj kod, trčanje ovaj program, iako Primam niz, jer je to još uvijek samo će pozdraviti svijet. 

No, što ako ja ne želim da se to promijeni. Zašto ne bih to učiniti? Posto je, zarez s. A to je malo zagonetan dalje. 

Pa neka mi da su moji varijable jasnija. Dopustite mi ime ove naziv varijable. I neka je vidjeti ako ne možemo zafrkavati osim što se ovdje događa. 

Dakle, on line pet, ja sam uzimajući niz. A ja pohranjivanje taj niz, god je korisnik utipkao na svom tipkovnici, u varijabli zove ime. I ispada da printf ne samo uzeti jedan argument u dvostruko citati, jedan ulaz u dvostrukim navodnicima. 

To može potrajati dva ili tri, ili više, kao da je drugi ili treći, ili četvrti, sve su to nazivi varijabli, ili specifično vrijednosti, da želite priključiti u, dinamički, taj se niz u navodnike. Drugim riječima, što je će biti u redu s ovim? Ako sam samo rekao halo ime, kosih crta n, spasio moj dosje, sastavio moj broj, i ran to, što će se dogoditi? 

To je samo reći, zdravo ime, doslovno N-A-M-e, koja je vrsta glupo, jer to ne razlikuje od svijeta. Tako je bilo u navodnicima je što doslovno ispisati. Dakle, ako želim imati rezervirano mjesto tamo, Ja zapravo je potrebno koristiti neke posebne sintakse. I to ispada, ako ste pročitali Dokumentacija za funkciju printf, to će vam reći da je ako koristite posto s, možete zamijeniti vrijednost kako slijedi. 

Nakon zarez nakon toga dvostruki navodnici, jednostavno napisati ime i prezime varijabla koja želite priključiti u tom formatu koda ili formata specifikator, posto je za gudače. A sada, ako sam spasio svoju sliku, Vraćam se na moj terminalu. A ja sam tip Make String, jer, opet, i ime za to file da sam izabrao je string.c. 

Zato ću reći Provjerite String, ući. Bože, pogledaj sve greške koje smo napravili već. A to is-- što je to stvarno kao šest, sedam linija programa? Dakle, ovo je mjesto gdje je vrlo moguće brzo dobiti neodoljiv. 

Ovaj terminal prozor ima sada samo regurgitated ogroman broj poruka o pogreškama. Zasigurno, nemam više pogrešku Poruke od mene linija koda. Dakle, što se događa? 

Pa, najbolja strategija učiniti u bilo koje vrijeme vam ne nailaze neodoljiv Popis grešaka kao što je to, je pomicanje unatrag, tražiti naredbe ti samo trčao, što je u mom slučaju je napraviti niz. Pogledajte što čine učinio, i to je to dugo zveket naredba, nije velika stvar tamo. 

No, crvena je loše. Zelena pokušava biti blag i koristan. No, to je još uvijek loše, u ovom slučaju. Ali gdje je to loše? 

String.c, linija pet znakova i pet. Dakle, ovo je samo zdrav konvencija. Nešto debelo nešto znači broj linija i broj znakova. Greška, korištenje neprijavljeni identifikator string. Jeste li mislili standard u? 

Dakle, na žalost, jeka pokušava biti od pomoći. Ali to je u redu, u ovom slučaju. Ne, jeka, nisam znači standardne IO. Mislio sam da je na liniji jedan, da. 

No, crta pet je ovaj ovdje. I zveket ne razumjeti S-T-R-I-N-G. To je crno identifikator, Riječ je samo nikada prije nije vidjela. A to je zato C, jezik mi smo kod pisanja u pravo vrijeme, nema varijable nazivaju žice. 

To ne, po defaultu, podrška nešto što se zove niz. To je CS50 komad žargon, ali je vrlo konvencionalna. Ali mogu popraviti ovo što slijedi. 

Ako sam dodati jednu liniju koda na vrh ovog programa, uključuju CS50.h, što je još jedan file negdje unutar CS50 IDE, negdje na tvrdom disku, da tako kažemo, Ubuntu operativnog sustava da bježim, da je datoteka koja je će naučiti s radom Sustav kakav struna, samo kao standardni io.h je datoteka u operacijskom sustavu koji je će ga naučiti što printf je. 

Doista, mi bi dobila vrlo sličnu poruku ako IO je priznao standarda IO.h i pokušao koristiti printf. Tako ću ići naprijed i samo preuzeti kontrolu L da razbistrim zaslon. Ili možete upisati jasno i to će samo očistiti prozor terminala. No, još uvijek možete pomicati natrag u vremenu. 

A ja ću ponoviti napraviti niz. Ubačaj moje prste ovaj put, Enter. O, moj Bože, on je radio. mi pokazuje dugo zagonetni naredbu to je ono što čini generira preko zveket, ali ne i poruke o pogreškama. Dakle shvatiti, iako možda ćete dobiti potpuno osvaja s Broj poruka o pogrešci, to može biti samo to neugodno kaskadno učinak, gdje zveka ne razumije jedna stvar, što znači da tada ne razumije sljedeću riječ, ili sljedeći redak. I tako je jednostavno guši u kodu. No, popravak može biti jednostavan. I tako uvijek fokus na Prvi redak izlaza. A ako ne shvatiti, samo pogledajte ključne riječi koje bi mogle biti tragove, a broj linija, i znak, na kojem da pogreška može biti. 

Sada neka mi ići naprijed i upišite dot udarac, niz, ući. Hm, to ne govori zdravo ništa. Zašto? Pa, podsjećamo, u kojoj se to radi? 

Vjerojatno je zapeo u ovom trenutku u petlju, ako hoćete, na liniji šest, jer Get Gudački po dizajnu, napisao CS50 osoblja, doslovno znači samo sjediti tamo čeka, i čeka, i čeka niz. Sve što podrazumijevamo pod nizom je ljudski ulaz. Dakle, znate što? Pusti me naprijed. I samo na ćud, pusti me upisati svoje ime, David, ući. Sada imam više dinamičan program. On je rekao, zdravo David. 

Ako sam ići naprijed i pokrenuti to opet, pokušat ću reći ime Zamila, ući. I sada imamo dinamičan program. Nisam hard kodirani svijet. Nisam hard kodirani ime, ili David ili Zamila. 

Sada je mnogo kao i programi znamo, gdje li se ulaz, ona proizvodi malo drugačiji izlaz. Sada, ovo nije najbolji korisničko iskustvo, ili UX. Ja pokrenuti program. 

Ne znam što bih trebala učiniti, osim ako ja zapravo pogled na ili se sjetiti izvorni kod. Tako ćemo napraviti korisniku doživjeti malo bolje s najjednostavnijim stvarima. Pusti me da se vratim u ovu Program i jednostavno reći printf. 

I neka mi ići naprijed i reći ime, debelo crijevo, i prostor, a zatim i zarez. I samo za slatkiš, nema zazora n. I to je namjerno, jer ne želim upit za pomicanje na sljedeći redak. 

Želim, umjesto toga, to učinili, napraviti niz rekompiliranje moj broj u novi stroj broj točkica slash niz. Ah, ovo je mnogo ljepše. Sad sam stvarno znati što se računalo želi od mene, dati joj ime. 

Tako ću ići naprijed i upišite u Rob, enter, i zdravo, Rob. Dakle, shvatiti, to je još uvijek, na kraju dana, samo devet linija programa. Ali mi smo poduzeti ove male korake. 

Napisali smo jednu liniju s kojima smo bili upoznati, printf, Hello World. Onda smo otkopča malo toga. A mi zapravo koristi get niz. I baci mi tu vrijednost u varijablu. I onda smo išli naprijed i poboljšana nadalje s trećom linijom. A to iterativan proces pisanje softvera je doista ključ. U CS50, iu životu općenito, općenito ne bi trebali sjesti, imaju program na umu, i pokušati pisati cijela prokleta stvar odjednom. 

To će neizbježno rezultirati način više pogrešaka nego mi sami ovdje vidio. Čak i ja, sve do danas, neprekidno bi ostale glupe greške, zapravo teže greške koje su teže za shvatiti. Ali vi ćete napraviti više grešaka više linija koda pišete sve odjednom. I tako ova praksa, napisati malo koda da ste zadovoljni s, sastaviti da, trčanje, testirati ga općenitije, onda krenuti on-- tako baš kao i mi čuva raslojavanje i raslojavanje prošlog tjedna, zgrada od nečega vrlo jednostavna za nešto složenije, učiniti isto ovdje. Ne sjesti i pokušati napisati cijeli problem. Zapravo uzeti ove male korake. 

Sada, žice nisu svi da je korisno za sebe. mi bi zapravo idealno, kao da se ima nešto drugo u našem alat. Tako ćemo zapravo učiniti upravo to. 

Pusti me naprijed i sada ščepati malo drugačiji plan. A mi ćemo nazvati ovu int.c, za cijeli broj. Idem, na sličan način, uključuju CS550.h. Idem uključuju standardne IO. I to će biti prilično čest u tih prvih nekoliko dana u razredu. 

A ja ću spreman ja s glavnom funkcijom. I sada umjesto uzimajući niz, idemo naprijed i dobiti int. Nazovimo ga ja, a zovu ga dobiti int, zatvorenih navodnika, točka-zarez. A sada ćemo napraviti nešto s njom, printf. 

Recimo nešto poput Pozdrav, kosih crta n, zarez ja. Tako sam prilično oponašajući ono što sam učinio prije samo trenutak. Imam rezervirano mjesto ovdje. Ja sam zarezom sam ovdje, jer želim da se spojite sam u tom rezervirano mjesto. 

Dakle idemo naprijed i pokušajte sastavljanju ovog programa. Datoteka naziva int.c. Zato ću reći, napraviti int, ući. O, moj Bože, ali nije velika stvar, zar ne? Tu je pogreška. 

Tu je sintaktička pogreška Ovdje kao da se program ne može biti sastavljen u int.c, linija sedam, lik 27, format error specificira tip char zvijezda, što god da je. Ali tip je argument int. 

Dakle, ovdje je, također, da se ne ide to-- iako je danas mnogo materijala, ćemo vas zasuti sa apsolutno svaki značajka C, i programiranje općenito, u samo tih prvih nekoliko tjedana. Tako se često događa da se žargonu s kojima niste upoznati. A, u stvari, char zvijezda je nešto ćemo se vratiti u tjedan ili dva vremena. 

No, za sada, da vidimo što možemo analizirati riječi koje su poznate. Formats-- pa smo čuli formatu specifikator, format koda prije. To je poznato. Type-- ali argument tipa int. Čekaj malo, ja je int. 

Možda posto je zapravo ima navedeno značenje. I doista, tako je. Cijeli broj, ako želiš printf ga zamijeniti, zaista morate koristiti drugačiji format specifikator. A ti ne bi znao to osim ako vam netko rekao, ili je to već radio. Ali posto sam je što mogu se obično koriste u printf za priključivanjem na cijeli broj. Također možete koristiti posto d za decimalnu cijeli broj. Ali ja je lijepo i jednostavno ovdje. Dakle, mi ćemo ići s tim. 

Sada neka mi ići naprijed i ponovno izvođenje make int, Enter. To je dobro, nema greške. Dot slash int-- OK, loše korisničko iskustvo, jer nisam rekla si Što uraditi. No, to je u redu. Ja sam lov na brzo. 

I sad neka mi ići naprijed i upisati Davida, OK, Zamila, Rob. U redu, tako da je ovo dobra stvar. Ovaj put, ja sam koristeći funkciju, zagonetka komad, zove get int. I ispada out--, a mi ćemo pogledajte ovaj kasnije u term-- CS50 osoblje je implementiran dobiti niz tako da će samo fizički dobili niz za vas. 

Ona je provela get int u takav način da samo hoće dobiti cijeli broj za vas. A ako ti je ljudski, ne surađuju, to je doslovno samo ide kažu pokušali ponovno, pokušajte ponovo, ponovo pokušati, doslovno sjedi petlje, dok što obvezuje s nekim čarobnim brojem, kao što su 50, a zdravo 50 godina. 

Ili, ako ćemo raditi to opet i tip u 42, zdravo 42. I tako se funkcija get int unutar tog puzzle komada Dovoljno je logika, dovoljno misao, shvatiti što je riječ? A što je broj? Samo prihvaćanje, u konačnici, brojevi. 

Tako ispada da je ovaj nije sve što je izražajan. do sada. Dakle, yay, zadnji put kad smo otišao prilično brzo u provedbene igre i animacije, i umjetničkih djela u nule. I ovdje, mi smo se sadržaj sa Zdravo, svijete, i zdravo 50 godina. 

To nije sve što je inspirativno. I doista, to prvih nekoliko Primjeri će potrajati neko vrijeme na izlazu se od uzbuđenja. No, imamo puno više kontrolirati sad, zapravo. I mi ćemo vrlo brzo početi raslojavanje na vrhu ovih osnovnih primitiva. 

Ali prvo, neka je razumjeti što ograničenja. U stvari, jedna od stvari Scratch ne lako činimo stvarno izgleda ispod haube, i razumjeti ono što je Računalo je, što se može učiniti, i koji su njeni ograničenja. I, doista, da je nedostatak razumijevanje, potencijalno, long-term može dovesti do vlastitog mistakes-- pisanja bube, pisanje nesigurni softver koji hakiran na neki način. 

Tako ćemo poduzeti neke korake prema razumijevanje ovo malo bolje način, kažu, sljedeći primjer. Ja ću ići naprijed i provoditi jako brzo program koji se zove Adder. Kao, neka je dodati neke brojeve zajedno. I ja ću da kod nekih ugla ovdje, a samo kopirati i zalijepiti gdje sam bio prije, samo tako da možemo krenuti prije. Pa sad sam dobio osnovne početke programa pod nazivom Adder. 

I idemo naprijed i to učiniti. Ja ću ići naprijed i recimo, intx dobiva dobiti int. I znate što? Učinimo bolje korisničko iskustvo. 

Pa recimo samo da je x, i učinkovito zatražiti od korisnika da nam x. I onda neka mi ići naprijed i reći: printf o tome kako je y, ovaj put očekuju dvije vrijednosti od korisnika. A onda neka je samo ići naprijed i recimo, printf, zbroj x i y je. I sad ja ne želim raditi posto s. Želim učiniti posto ja, kosih crta n, a zatim priključite sum vrijednosti. 

Dakle, kako mogu ići oko radiš to? Znaš što? Znam kako koristiti varijable. Pusti me samo proglasiti novi, int z. 

A ja ću uzeti pogodak ovdje. Ako postoje jednake znaci ovo jezik, možda ja samo mogu učiniti x plus y, tako dugo dok sam kraj moje Mislio sa zarezom? Sad sam se vratiti ovdje, priključite z, završiti ovu misao sa zarezom. A da vidimo sad, ako je to sekvence lines-- x je dobiti int. Y je dobiti int. 

Dodaj X i Y, pohraniti vrijednost u z-- Dakle, opet, sjetite se znak jednakosti nije jednako. To je zadatak s desna na lijevo. I neka je ispisati da je zbroj x i y nije doslovno z, ali ono što je unutar z. Tako ćemo napraviti Adder - lijepo, nema grešaka ovaj put. Dot slash Adder, ući, x će biti 1. 

Y će biti 2. A zbroj x i y je 3. Tako da je sve u redu i dobro. 

Dakle, što bi se zamisliti da je matematika bi trebao raditi u programu kao što je ovaj. Ali znate što? Je li ta varijabla, linija 12, pa je potrebno? Ne morate da se u naviku samo čuvanje stvari u varijablama samo zato što mogu. A, u stvari, to je općenito smatra da je loše dizajn ako stvaranju varijablu naziva z, u ovom slučaju, skladištenje nešto u njemu, a zatim se odmah koristeći ga, ali nikad više. Zašto dati nešto ime kao z ako ste doslovno ćemo koristiti kako stvar je samo jednom, i tako proksimalno u kojoj ste stvorili to je u prvom redu, tako blizu u smislu linija koda? Dakle, znate što? Ispada da je C je prilično fleksibilan. Ako sam zapravo želite plug-in vrijednostima ovdje, Ne treba da proglasi novu varijablu. Mogao sam samo plug-in x plus y, jer C razumije aritmetika, i matematički operatori. 

Tako sam se jednostavno može reći, učiniti math, x plus y, bez obzira na te vrijednosti su, plug dobivena broj u taj niz. Dakle, to bi moglo biti, iako samo jedan redak kraći, bolji dizajn, bolji program, jer ima manje kod, dakle, manje mi je razumjeti. I to je također samo čišće, ukoliko nismo uvođenje novih riječi, novi simboli, kao što su z, iako stvarno ne služi mnogo svrhe. 

Nažalost, matematika nije sve je pouzdano ponekad. Idemo naprijed i to učiniti. Idem samo naprijed sada i učinite sljedeće. 

Učinimo printf, posto ja, plus posto I, mora biti posto ja, kosih crta n. I ja ću to učinimo xyx plus y. Pa Samo ću prepisati to malo drugačije ovdje. Pusti me samo učiniti brzo duševne ček. Opet, nemojmo se ispred sebe. Provjerite zbrajalo, dot slash guja. x je 1, y je 2, 1 plus 2 3. Dakle, to je dobro. Ali neka se zakomplicirati ovaj sada malo, i stvoriti novu datoteku. 

Idem nazvati ovu, kažu, Ints, množina za cijelih brojeva. Pocnimo gdje sam bio maloprije. No, sada ćemo napraviti nekoliko drugih linija. Dopustite mi ići naprijed i učiniti sljedeće, printf, posto ja, minus posto ja, je posto ja, zarez x, zarez yx minus y. Tako ja radim nešto drugačija matematika tamo. Idemo napraviti još jedan. Dakle posto I. puta posto ja je posto ja, kosih crta n. Neka je plug-in x, y i x puta y. Mi ćemo koristiti zvjezdicu na računalo za vrijeme. 

Ne koristiti x. x je varijabla ime ovdje. Možete koristiti zvjezdicu za umnožavanje. Idemo napraviti još jedan. Printf posto sam, dijele po posto I, posto ja, Obrnuta kosa crta n. xy podijeljen y-- tako da upotrijebite kosu crtu u C napraviti podjelu. I neka je učiniti nešto drugo. Ostatak posto i, podijeljeni po posto I, posto ja. xy-- a sada ostatak je ono što je ostalo više. Pri pokušaju podjele nazivnik u brojniku, koliko je ostalo preko toga nisi mogao podijeliti van? 

Dakle, ne postoji stvarno, nužno, simbol mi smo koristili u osnovnoj školi za to. No, tu u C. Možete kažu x modulo y, gdje je ovaj znak postotka u ovom context-- zbunjujuće kad ste unutra od dvostruke navodnike, unutarnjoj printf, posto se koristi kao format razvrstač. 

Kada koristite posto izvan da se u matematički izraz, to je modulo operator za modularni arithmetic-- za naše potrebe ovdje, znači, što je Ostatak x podijeljena po y? Dakle, x podijeljen y je x slash y. Što je ostatak od x podijeljena po y? To je x mod y, kao programer će reći. 

Dakle, ako sam napravio bez greške ovdje, pusti me ići naprijed i učiniti Ints, plural, lijepo, i točka SLASH Ints. I idemo naprijed i ne, recimo, 1, 10. U redu, jedan plus 10 je 11, provjera. 1 minus 10 je negativan 9, provjerite. 

1 puta 10 je 10, provjera. 1 podijeljeno s 10 is-- U redu, mi ćemo preskočiti jedan. Ostatak od 1 podijeljeno s 10 je 1. To je točno. No, tu je bug ovdje. 

Dakle, jedan sam stavila predati, nije točno. Mislim, to je blizu 0. 1 podijeljeno s 10, znate, ako smo rezanje neke ugla, naravno, to je nula. Ali, to stvarno treba biti 1/10, 0.1 ili 0.10, 0,1000, ili tako dalje. 

To ne bi trebao biti stvarno nula. Pa, ispada da je računalo radi doslovno ono što smo to rekli učiniti. Mi smo radili matematiku kao x podijeljen y. I oba X i Y, po uzoru koda ranije, cijeli brojevi. 

Osim toga, na liniji 15, mi smo govori printf, hej, printf plug-in cijeli broj, plug-in cijeli broj, plug-in je integer-- posebno x, y i, zatim x podijeljen y. x i y su Ints. Mi smo dobro tamo. 

No, ono što je x podijeljena x? x podijeljena y trebao biti, matematički, 1/10, ili 0.1, koji je pravi broj, realni broj ima, potencijalno, decimalnu točku. To nije cijeli broj. 

No, ono što je najbliže broj do 1/10 ili 0,1? Da, vrsta je nula. 0.1 je ovako puno. A jedan je to puno. Dakle, 1/10 bliže 0 nego da je jedan. 

I ono što C je događaj za us-- vrsta jer smo to rekli to-- se skraćivanjem taj cijeli broj. To je uzimajući vrijednost, što je opet trebao biti nešto poput 0,1000, 0 i tako dalje. I to je skraćivanjem sve nakon decimalne točke tako da je sve to stvari, jer to ne uklapaju u pojam cijeli broj, koji je samo broj kao negativna 1, 0, 1, gore i dolje, to baca sve nakon decimalne točke, jer ste Ne mogu stati decimalne točke u cijeli broj po definiciji. 

Dakle, odgovor je ovdje nula. Pa kako ćemo ovo popraviti? Trebamo drugo rješenje sve zajedno. A to možemo učiniti, kako slijedi. 

Pusti me naprijed i stvoriti nova file, to se zove floats.c. I spremite ga ovdje u Isto imenik, float.c. I neka mi ići naprijed i kopirati dio tog koda od ranije. 

No, umjesto da se int, učinimo to. Daj mi Krajnja vrijednost zove x. gdje je s pomičnim zarezom vrijednost samo doslovno nešto s pomičnim zarezom. To se može premjestiti na lijevo, desno. To je pravi broj. 

I neka me ne zove dobiti int, ali se plovak, koji je također bio među izbornika mogućnosti u C250 knjižnici. Neka je y promijeniti plovka. Dakle, ovo postaje dobili ispliva. 

I sada, mi ne želimo priključiti Ints. Ispada moramo koristiti posto f za plovak, posto f za plovak, a sada ga spremiti. A sada, fige, napraviti plovci, lijepo, dot SLASH pluta. x je idući u biti jedan 1. y Će biti 10 opet. 

A, lijepo, OK moj dodatak je točan. Nadao sam se za više, ali sam zaboravio napisati. Dakle idemo i popraviti ovu logičku pogrešku. 

Idemo naprijed i iskoristite sljedeće. Samo ćemo napraviti malo kopirati i zalijepiti. A ja ću reći minus. 

A ja ću reći puta. A ja ću reći podijeljena. I neću učiniti modulom, koji nije tako tijesnoj ovdje podijeljen f, vrijeme plus-- OK, neka je to učiniti opet. 

Make pluta, dot SLASH pluta, i 1, 10, and-- lijepo, ne, u redu. Tako da sam idiot. Dakle, ovo je vrlo čest u računalnoj znanosti napraviti glupe greške kao što je ovaj. 

Za pedagoške svrhe, ono što sam stvarno želio učiniti je promijeniti znanost ovdje na plus, minus, na vrijeme, i da rastavljaju, kao i ti nadam se primijetio tijekom ove vježbe. Dakle, sada ćemo ponovno sastaviti ovo Program, učiniti dot Slash plovaka. 

I po treći put, neka je vidjeti ako ispunjava moja očekivanja. 1, 10, ući, da, u redu, 1.000, podijeljen 10.000 je 0,100000. I ispada da možemo kontrolirati koliko brojevi su nakon tih decimale. Mi zapravo hoće. Mi ćemo se vratiti na to. 

Ali sada, u stvari, matematika je točna. Dakle, opet, što je takeaway ovdje? Ispostavilo se da je u C, postoje Ne tek strings-- i, u stvari, ne postoji stvarno, jer mi dodati one s CS50 knjižnici. No, tu nisu samo Ints. 

Tu su i pluta. I ispada hrpa drugih podataka Vrste također, da ćemo koristiti prije dugo. Ispada da, ako želite jedan karakter, a ne niz znakova, možete koristiti samo char. 

Ispada da ako želite bool, Booleova vrijednost true ili false samo, zahvaljujući CS50 knjižnici, mi smo upisan u C tip podataka o bool, kao dobro. No, to je također prisutna u mnogi drugi jezici, kao dobro. I ispada da ponekad potreban veći broj onda dolaze po defaultu s Ints i lebdi. 

A, u stvari, dvostruki je broj koji koristi ne 32 bita, ali 64 bita. I dugo dugo je broj koji koristi ne 32, komadići, ali 64 bita, odnosno, za pomičnim zarezom vrijednosti i cijeli brojevi, redom. Dakle-a neka zapravo sada vidjeti u akciji. 

Idem naprijed ovdje i ščepati jedan drugi program. Evo, ja ću ići naprijed i ne uključuju CS50.h. I pustite me, uključuju standardne IO.h. 

A vi ćete primijetiti nešto funky se događa ovdje. To nije boja kodiranje stvari na isti način kao što je učinio prije. A što se ispostavilo, to je zato što sam nisu dali stvar naziv datoteke. 

Idem nazvati ovaj jedan sizeof.c, a pogodak Save. I primijetiti što se događa s mojim vrlo bijeli broj na tu crnu pozadinu. Sada barem postoji neki ljubičasti tamo. I to je sintaksa istaknuto. 

To je zato što, jednostavno, ja sam rekao IDE kakvu vrstu datoteke to je dajući joj naziv i posebno datotečni nastavak. Sada, neka je ići naprijed i učiniti. Ja ću ići naprijed i vrlo jednostavno ispisati following-- bool je posto LU. 

Mi ćemo se vratiti da je u samo jednom trenutku. A onda ću Veličina ispisa bool. A sada, samo za spremanje ja neko vrijeme, ja sam učiniti jednu cjelinu hrpa njih odjednom. I, posebno, idem promijeniti u char i char. Ovaj, idem promijeniti za dvostruki i dvostruko. 

Ovaj, idem promijeniti na plovak i plovak. Ovaj, idem promijeniti int i int. I to je jedan, idem kako promijeniti dugo dugo. I dalje traje dugo, dugo dugo. 

A onda, na kraju, dao sam ja jedan previše, niz. Ispostavilo se da je u C, ima poseban operator naziva Veličina to je doslovno će, kada se pokrene, da nam veličinu svaki od tih varijabli. I to je način, sada, možemo povezati natrag na prošlotjednom rasprave podataka i reprezentacije. 

Pusti me naprijed i sastaviti Veličina dot veličine slash od. I da vidimo. Ispostavilo se da je u C, konkretno na CS50 IDE, posebno na operativni sustav Ubuntu, što je 64-bitni operativni Sustav u ovom slučaju, bool će koristiti jedan bajt prostora. To je kako se mjeri veličina, nije u bitovima, ali u bajtovima. I podsjetiti da je jedan bajt je osam bitova. Tako bool, iako vas tehnički samo trebaju 0 ili 1, to je malo razoran kako smo ga provode. To se zapravo događa koristiti cjelinu byte-- pa sve nule, su možda svi oni, ili nešto slično, ili samo jedan jedan među osam bitova. 

Char, u međuvremenu, a koristi se za lika kao ASCII karaktera po prošlog tjedna, će biti jedan znak. I to synchs s našim pojmom to se ne više od 256 bits-- a, synchs s njim se ne duže od 8 bita, koji daje nam čak 256 vrijednosti. Dvostruka će biti 8 bajtova ili 64 bita. 

Plovak je 4. Int 4. Dugo, dugo je 8. I niz je 8. No, ne brinite o tome. Idemo ponovno oguliti taj sloj. Ispada, žica biti duži od 8 bajta. 

I, doista, napisali smo već žice, Hello World, duže od 8 bajta. No, mi ćemo se vratiti da je u samo jednom trenutku. Ali oduzeti ovdje je sljedeći. 

Svako računalo ima samo ograničen količina memorije i prostora. Možete pohraniti samo toliko datoteke na vašem Mac ili PC. Možete pohraniti samo toliko programa u RAM trčanje odjednom, nužno, čak i sa virtualnom memorijom, jer imate konačnu količinu RAM-a. 

I samo da picture-- ako nikad nisi otvorio laptop ili naručiti dodatnu memoriju za računalo, možda ne znaju da je unutar vašeg računala nešto što izgleda malo ovako. Dakle, ovo je samo zajedničko poduzeće pod nazivom Ključno je da čini RAM za računala. I RAM je mjesto gdje programi živjeti dok oni prikazuju. 

Dakle, na svakom Macu ili PC-u, kada dvaput kliknite program, a to otvara, i to otvara neke Word dokument ili tako nešto, to ga pohranjuje privremeno RAM-a, jer je RAM je brži nego vaš tvrdi disk ili Vaš SSD diska. Dakle, to je samo kada je program ide živjeti kad radite, ili kada se koriste datoteke. 

Dakle, imate stvari koje izgledaju ovako unutar vašeg laptopa, ili malo veće stvari unutar radne površine. No, ključno je da imate samo konačan broj od tih stvari. I postoji samo ograničen iznos hardver sjedi na tom stolu u pravu ovdje. 

Dakle, sigurno, ne možemo pohraniti beskrajno duge brojevi. Pa ipak, ako se prisjetite Škola, koliko je znamenki mogu imate na desnoj strani od decimalnog zareza? Što se toga tiče, koliko je znamenki mogu imate lijevo od decimalnog zareza? Stvarno, beskonačno mnogo. 

Sada mi ljudi samo da bi znate izgovoriti milijuna, i milijarde, milijarde, a bilijardi i kvintilijun. I ja sam gurajući granice moga understanding-- ili my-- razumijem brojeve, ali moj izgovor brojeva. No, oni mogu dobiti beskonačno velika s beskonačno mnogo Znamenke lijevo ili desno od decimalnog zareza. 

No, računala imaju samo konačna količina memorije, konačan broj tranzistora, A konačan broj žarulja unutra. Dakle, što se događa kada vam ponestane prostora? Drugim riječima, ako mislim natrag na prošli tjedan kad smo govorili o brojevima sami su predstavljeni u binarnom sustavu, pretpostavimo da imamo ovaj 8-bitna vrijednost ovdje. 

I imamo sedam +1 i jedna 0. I pretpostavimo da želimo dodati 1 do te vrijednosti. To je stvarno velik broj upravo sada. 

To je 254, ako se dobro sjećam math od prošlog tjedna desne strane. No, što ako ja promijeniti da najdesniji 0 do 1? Cijeli broj, od Naravno, postaje osam +1. Dakle, još smo dobro. 

I to vjerojatno predstavlja 255, iako, ovisno o kontekstu to zapravo može predstavljati negativan broj. Ali više o tome neki drugi put. To se osjeća kao da se radi o kao visok kao što mogu računati. 

Sada, to je samo 8 bita. I moj Mac, sigurno, ima put više od 8 bitova memorije. Ali to nema konačnog. Dakle, isti argument vrijedi, čak i ako smo imaju više od ovih one na zaslonu. 

Ali što se događa ako ste spremanje tog broja, 255, i želite brojati jedan malo veći? Želiš ići od 255 do 256. Problem je, naravno, da ako početi brojati od nule kao i prošlog tjedna, ne može računati kao visok kao 256, a kamoli 257, a kamoli 258, m jer ono što se događa kada dodate 1? Ako to ne učinite staru Osnovnu školu pristup, stavite 1 ovdje, a zatim 1 i 1 je 2, a to je stvarno nula, nosite 1, nose 1, nositi 1. Sve ove stvari, ovi 1 a, ide na nulu. A ti završiti, da, kao što je netko istaknuo, a 1 na lijevoj strani. No, sve što možete zapravo vidjeti i stane u memoriju je samo osam 0-a, što će reći u nekom trenutku, ako ti, računalo, Pokušao računajući dovoljno visoko gore, ti si će zaokrenuti, čini se, na nulu, ili možda čak negativan brojevi, koji su čak i niže od nule. 

I možemo vrsta vidjeti. Pusti me naprijed i pisati pravi program brzog ovdje. Pusti me naprijed i pisati program koji se zove Overflow. Uključi CS50.h uključuju standardni IO.h-- oh, Stvarno sam propustila svoje sintakse. Tako ćemo uštedjeti ovo kao overflow.c. 

A sada int glavni void-- i prije dugo, mi ćemo vratiti se objasniti zašto držimo pisanje int glavni prazninu. No, za sada, neka je samo napraviti da, uzimajući zdravo za gotovo. Recimo ja osobno dati int, i inicijalizaciju na 0. 

Idemo onda na int mogu dobiti zero-- zapravo, neka je učiniti beskonačnu petlju i vidjeti što se događa. Dok je istina, onda idemo ispisati n je posto ja, kosih crta n, plug-in n. Ali, sada, neka je učiniti n dobiva n plus jedan. 

Tako Drugim riječima, za svaki iteracija ovog beskonačnu petlju, uzmimo vrijednosti n-a, i dodati 1 do njega, a zatim pohraniti rezultat natrag u n na lijevoj strani. A, u stvari, vidjeli smo sintaksa nešto ovako, ukratko. Kul trik je umjesto pisanja sve ovo, zapravo možete reći n plus jednaka 1. 

Ili, ako zaista želite biti fancy, možete reći n plus plus točka-zarez. No, ova dva su samo što bismo nazvati sintaktički šećera za prvu stvar. 

Prva stvar je više eksplicitno, potpuno u redu, potpuno ispravan. No, to je više zajedničkog, ja ću reći. Dakle, mi ćemo to učiniti samo na trenutak. 

Idemo sada napraviti preljev, što zvuči a zloslutna, dot slash preljeva. Da vidimo, n je dobivanje prilično velika. Ali razmislimo, koliko je velik može n dobiti? 

n je cijeli broj. Vidjeli smo maloprije s veličinom Primjer koji int je četiri bajta. Znamo iz prošlog tjedna, četiri bajta je 32 bita, jer je 8 puta 4, to je 32. To će biti 4 milijarde. 

I mi smo do 800.000. Ovo će se zauvijek računati kao visok kao ja eventualno mogu. Tako ću ići naprijed, kao možda ne zadugo, i udario Upravljačka C-- iskreno, kontrola C, puno, gdje je kontrola C općenito znači odustajanje. Nažalost, jer je to je pokrenut u oblaku ponekad oblak pljuvanje se toliko stvari, toliko izlaz, to će uzeti malo vremena za moj ulaz doći do oblaka. Dakle, iako sam pogodio Kontrola C nekoliko sekundi prije, ovo je definitivno na strani Učinak beskonačnu petlju. 

I tako se u takvim slučajevima, mi smo će napustiti to biti. A mi ćemo dodati još terminal prozor ovamo s plus, što naravno ne kao da je, s obzirom da još uvijek razmišlja. I idemo naprijed i biti malo više razuman. 

Ja ću ići naprijed i učiniti To samo konacno mnogo puta. Iskoristimo for petlje, koja aludira sam ranije. Napravimo to. Daj mi još jednu varijablu int i dobiva 0. je i manje od, recimo, 64 i ++. I sad neka mi ići naprijed i print iz nje posto ja, zarez n. A onda n- to je još uvijek će trajati zauvijek. Napravimo to. 

n dobiva n puta 2. Ili možemo biti fancy i to vrijeme jednak 2. No recimo samo n Sam jednak, puta 2. Drugim riječima, u ovom Nova verzija programa, Ne želim čekati zauvijek od kao što je 800.000 do 4 milijarde. Recimo samo završimo s. 

Neka je zapravo dvostruko n svaki put. Koji, podsjetimo, udvostručenje je suprotno od imaju, naravno. I dok je prošli tjedan imamo nešto opet, i opet, i opet, super brzi, udvostručenje će sigurno dobili nas od 1 do najveće moguće vrijednost koja možemo računati da s int. 

Tako ćemo učiniti upravo to. A mi ćemo se vratiti na ovo prije dugo. No to je, opet, baš kao i ponavljanja bloka u nule. A vi ćete koristiti ovaj prije dugo. 

To samo znači brojati od nule sve do, ali nisu jednaki, na 64. A na svakom ponavljanju ovo petlja, samo nastavi povećavati i. Pa i ++ - a to uopće konstrukt na liniji 7 je jednostavno super čest način od ponavljanja neke linije kod, neki broj puta. Koja linija koda? Ove vitičastim zagradama, kao i vi možda sakupljen od sada, znači, učinite sljedeće. 

To je kao kada nule, kada ima žute blokove i druge boje koje vrste prihvatiti ili zagrliti druge blokove. To je ono što ti kovrčava aparatić ovdje radimo. Dakle, ako sam je dobio moj sintaksu redu-ti vidi simbol mrkve u C sredstvima to je koliko puta sam bio pokušavaju riješiti ovaj problem. Tako ćemo se riješiti tog jednog Sve u svemu, i zatvorite taj prozor. A mi ćemo koristiti novu. Provjerite overflow, dot slash overflow, Enter, sve u redu, to izgleda loše na prvi pogled. Ali neka se pomicati unatrag kroz vrijeme, jer sam to učinio 64 puta. 

A primijetiti prvi put, n je 1. Drugi put, n je 2, zatim 4, zatim 8, zatim 16. A čini se da čim Ja se otprilike 1 milijardu, ako sam ga ponovno udvostručiti, to treba mi dati 2 milijarde. No, ispostavilo se, da je Pravo na vrhuncu. 

I tako je zapravo preljeva int od 1 milijarde do otprilike negativna 2 milijarde, jer je cijeli broj, za razliku od brojeva mi su pod pretpostavkom da je prošli tjedan, može biti i pozitivan i negativan u stvarnosti i na računalu. Pa je najmanje jedan od onih bitovi učinkovito je ukraden. Tako smo zapravo samo 31 bita, ili 2 milijarde moguće vrijednosti. 

No, za sada je takeaway je prilično Jednostavno, što god ti brojevi i što god je matematika, nešto loše dogodi na kraju, jer na kraju se pokušava izmjenjivati ​​bitove previše puta. A vi učinkovito otići od svega 1 je na možda sve 0-a, ili možda Samo neki drugi uzorak koji to Jasno, ovisno o kontekstu, može se tumačiti kao negativan broj. I tako se čini najveću I može računati u ovom programu Samo oko 1 milijardu. No, tu je djelomična rješenje ovdje. Znaš što? 

Pusti me promjenu s int do dugo dugo. I neka mi ići naprijed ovdje i say-- ću imati da se to promijeni do nepotpisani dugo. Ili, da vidimo, nisam se sjetiti. 

Idemo naprijed i napraviti preljev. Ne, to nije to, LLD, hvala. Dakle, ponekad zveket može biti korisna. Nisam sjetiti što je format specifikator je za dugo dugo. 

Ali, doista, jeka mi je. Zelena je neka vrsta dobre, još uvijek znači da ste pogriješili. To je nagađanje da sam mislio LLD. 

Pa neka me uzeti da je savjet, dugo dugo decimalni broj, osim toga. I neka mi to ponoviti, točka slash preljevom, Enter. A sada ono što je super je to. 

Ako sam pomicati unatrag kroz vrijeme, još uvijek početak računajući na istoj mjesto-- 1, 2, 4, 8, 16. Obavijest, dobili smo sve način do 1 milijarde. Ali onda smo sigurno doći do 2 milijarde. 

Onda smo dobili 4 milijarde, tada 8 milijardi, 17 milijardi. I idemo veći, a više, i više. Na kraju, to je, također, pauze. 

Na kraju, uz dugo dugo, što je 64-bitna vrijednost, a ne 32-bitnu vrijednost, ako se računati previsoka, možete omotati oko 0. I u ovom slučaju, mi se dogoditi da završiti s negativnog broja. 

Dakle, to je problem. I ispada da je ovaj Problem nije sve što kompliciranih. Iako sam namjerno ga je izazvao ovim greškama, ispada da ga vidimo kakav svega oko nas, ili barem neki od nas rade. 

Tako je u Lego Star Wars, ako ste ikad igrali igru, ispada da možete ići okolo razbijanje stvari u LEGO svijetu, i prikupljanje novca, u suštini. A ako ste ikad igrali ova igra previše vremena, što je ovaj neimenovani pojedinac Ovdje je, ukupan broj kovanica koje možete prikupiti je, čini se, 4 milijarde. 

Sada, uz to je zapravo zaokružen. Dakle, LEGO je pokušavao držati stvari user friendly. Nisu to baš 2 do 32 snage, po prošlog tjedna. Ali 4000000000 razlog. Čini se, na temelju tih informacija, da LEGO, a tvrtka koja napravio ovaj stvarni softver, odlučili da je najveći broj kovanica korisnik može akumulirati je, doista, 4000000000, jer su izabrali u svom kodu korištenje nije dugo dugo, očito, nego samo cijeli broj, nepotpisani broj, samo pozitivni cijeli broj, čije max vrijednost je otprilike to. Pa, evo još jedan smiješni jednom. Tako je u igri Civilization, što neki od vas bi mogli biti upoznati s ispada da je prije nekoliko godina tamo Bio je to bug u ovoj igri, pri čemu ako je igrao ulogu od Gandhija u igri, umjesto njega se vrlo pacifist, umjesto da je nevjerojatno, nevjerojatno agresivan, u nekim okolnostima. Konkretno, na način da je civilizacija djela je da ako ti, igrač, usvojiti demokraciju, vaš agresivnost rezultat dobiva smanjivati ​​po dva, pa minus minus, a onda minus minus. 

Tako da oduzimanje 2 od Vaš stvarni ponavljaju. Nažalost, ako je vaš Ponavljanje je u početku 1 i oduzmete 2 od nje nakon donošenja demokracije kao Gandhi ovdje moglo učinili, jer je bio vrlo passive-- 1 na skali od agresivnosti. Ali ako on donese demokraciju, a zatim on ide od 1 do negativnog 1. 

Nažalost, oni su bili pomoću nepotpisane brojeva, što znači da liječi čak i negativni Brojevi kao da su pozitivni. I ispada da je pozitivni ekvivalent negativnim 1, u tipičnim računalnih programa je 255. Dakle, ako Gandhi donosi demokracija, i zbog toga ima njegova agresivnost rezultat je smanjen, to je zapravo role oko 255 i čini ga najviše agresivan lik u igri. Na taj način možete izguglati na ovo. I to je, doista, An slučajno programiranje bugova, ali to je ušao sasvim Lore otkad. 

To je sve zabava i slatka. Više zastrašujuće je kad stvarna stvarnom svijetu uređaje, a ne igre, ima iste greške. Naime, prije godinu dana je članak došao nešto o Boeing 787 Dreamliner. 

A članak na prvi Pogled čita malo kompliciranih. Ali to rekao, softver ranjivost u Boeing-a Novi 787 Dreamliner jet ima potencijal da uzrokuje pilota izgubiti kontrolu nad zrakoplov, možda sredinom leta, službenici FAA upozorio airlines u zadnje vrijeme. Bio je određivanje da model 787 avion koji je powered neprekidno 248 dana može izgubiti sve izmjeničnu struju, klima, električne energije s obzirom na generatoru kontrolne jedinice, GCUs, istovremeno odlaska u uspjeti siguran način. To je vrsta me izgubiti. No dopis navedeno, OK, sad sam to dobio, stanje je uzrokovano softvera protiv unutarnje kontrola generator jedinice koje će se preliti nakon 248 dana neprekidnog moći. Mi smo izdavanja ovog primijetiti da se spriječi gubitak od svih AC električne moć, što bi moglo dovesti do gubitkom kontrole u avionu. 

Dakle, doslovno, tu je neki cijeli broj, ili neki ekvivalentni tip podataka, se koristi u softver u stvarnoj avionu da ako bi se avion dovoljno dugo, što je očito može biti slučaj ako ste samo trčanje ih stalno i nikad isključivanjem Vaš avion, čini se, i ostavljajući svoje baterije umrijeti, će na kraju brojati i prema gore, i gore, i gore, i gore, i gore. 

I, po vrsti, konačna količina memorije će se prelijevati, valjanje natrag nula ili neke negativne vrijednosti, nuspojava koja je zastrašujuće stvarna stvarnost da je avion možda morati da se digne, učinkovito, ili mogu postati još gore, kao što leti. Tako ove vrste pitanja su još uvijek s nama, even-- ovo je bio 2015 članak sve više zastrašujuće kada ne nužno razumjeti, cijeniti, ili predvidjeti one vrste pogrešaka. 

Tako ispada da postoji jedna druga loše o zastupljenosti podataka. Ispada da su čak i pluta su vrsta manjkav, jer kola, također, predložio sam se 32 bita, ili možda 64 ako koristite dvostruko. Ali to je još uvijek konačna. 

A kvaka je u tome, ako možete stavi beskonačan broj brojeva nakon decimalne točke, ne postoji li način može predstavljati sve moguće brojevi koji su nas učili u osnovnoj školi može postojati u svijetu. Računalo, u biti, mora odabrati podskup tih brojeva da predstavlja točno. 

Sada, računalo može okrugli možda malo, i može vam omogućiti da otprilike trgovine bilo koji broj vam eventualno možda želite. No, samo intuitivno, ako vas imaju ograničen broj bitova, možete samo ih izmjenjivati u toliko konačnih načina. Tako da ne mogu koriste konačan broj permutacije bitova, obrasci nula i jedinica, da predstavlja beskonačan broj brojeva, što upućuje na to da računala mogu vrlo dobro se laže nam ponekad. 

U stvari, učinimo to. Pusti me da se vratim u CS50 IDE. Pusti me naprijed i stvoriti mali program pozvao Nepreciznost, pokazati da računala su, doista, neprecizan. 

I neka mi ići naprijed i početi s dio tog koda od prije, a sada samo učiniti sljedeće. Dopustite mi ići naprijed i učiniti printf, posto f, kosih crta n, 1 podijeljeno s 10. Drugim riječima, neka je roniti dublje do 1/10, kao što su 1 i podijeljen 10. Sigurno, računalo može predstavljati 1/10. 

Tako ćemo ići naprijed i učiniti nepreciznosti. Da vidimo. Format navodi tipa double. No, argument tipa int. Što se događa? 

Oh, zanimljivo, tako da je iskustvo steceno prije. Govorim, hej, računala emisija mi plovak sa postotnim f. Ali ja sam dajući mu 2 Ints. Tako ispada, ne mogu popraviti to u nekoliko načina. 

Mogao sam samo okrenuti jedan u 1,0 i 10 na 10,0, što bi, doista, imaju učinak pretvaranja ih u floats-- još uvijek nadam isti broj. Ili ispada da je nešto vidjet ćemo opet ne zadugo. Ti bi mogao baciti brojeve. 

Možete, pomoću ovog zagradi izraz, može se reći, hej, računalo, uzmi ovo 10, što ja znam je int. No, čuvajte ga, molim te, kao da je plovak. No, to se osjeća nepotrebno složena. 

Za naše potrebe i danas, neka je samo doslovno učiniti ih s pomičnim zarezom vrijednosti sa decimalne točke, kao što je ovaj. Pusti me naprijed i ponovno provjerite nepreciznosti, dobro, dot slash nepreciznosti, ući. U redu, mi tražimo dobro. 

1 podijeljeno s 10 je, prema mom Mac ovdje je, doista, 0,100000. Sada, ja sam učio u osnovnoj školi tamo bi trebao biti beskonačan broj 0-ih. Tako ćemo barem pokušati vidjeti neke od njih. Ispada da printf je malo ljubitelj dalje nego što smo koristili. Ispada da ne morate navesti Samo posto f, ili samo posto sam. Vi zapravo možete odrediti Neke kontrolne opcije ovdje. 

Naime, idem reći, hej, printf, zapravo mi pokazati 10 decimalne točke. Tako to izgleda malo čudno. Ali ti kažeš posto, točka, koliko brojeva Želite li vidjeti nakon što se decimalna točka, a zatim f za stan, samo zato što je što je dokumentacija, kaže. Pusti me naprijed i spasiti da. 

A primijetiti previše, ja sam uzimajući umorni od prekucavanje stvari. Pa ja sam samo postavljanje gore i Strelica dolje na moje ključeve ovdje. A ako sam stalno udaranje gore, vidi sve naredbe kako sam ja učinio, ili pogrešno napravio. 

I ja ću ići naprijed i sada zapravo ne koriste to, očito. Provjerite preciznost, točku slash imprecision-- tako ono što sam učio u Škola provjerava. Čak i ako sam ga ispisati do 10 decimale ga stavlja, doista, 0,10000. Ali znate što? 

Idemo malo pohlepni. Recimo, ono, pokaži mi 55 ističe nakon decimale. Neka je stvarno uzeti programirati kako za spin. Dopustite mi da to ponovo napraviti s make nepreciznosti, dot slash, nepreciznost. 

I ovdje mi ići. Vaš djetinjstva bila laž. Očigledno, 1 podijeljeno s 10 je doista 0.100000000000000005551115123-- 

Što se događa? Pa, što se ispostavilo, ako vrsta izgleda dovoljno daleko u pozadini prikaz ovo broj, to je zapravo nije točno 1/10 ili 0,1 i beskonačan broj nula. Sada, zašto je to tako? 

Pa, iako je to jednostavno Broj do nas ljudi, jednom podijeljen sa 10, to je još uvijek jedan od beskonačno mnogo brojevi koji smo mogli smisliti. No, računalo može predstavljati samo konacno mnogo tako brojeva. I tako, zapravo, ono što je računalo pokazuje nam da je njegova najbliža aproksimacija broja želimo vjerovati je 1/10, ili stvarno 0,10000 ad infinitum. 

Umjesto toga, ipak, to je kao bliski kao što mogu dobiti. I doista, ako pogledate ispod haube, kao što smo mi ovdje u potrazi 55 znamenki nakon decimalne, zapravo vidimo da je stvarnost. Sada kao stranu, ako ste ikada vidio movie-- većina vas vjerojatno haven't-- ali prije Superman 3 nekoliko godina, Richard Pryor bitno utjecati ova stvarnost u njegovom društvu ukrasti puno frakcija i frakcija novčana jedinica, jer company-- Koliko se sjećam, to je bio while-- je u osnovi odbacujući sve što ne stane u pojmu centi. 

Ali ako zbrojite sve to sitne, sitne, sitne brojeve opet, i opet, i opet, možete, kao u njegov slučaj, napraviti dobar iznos novca. 

Iste ideja je ripped off by novija, ali ipak sada stariji Film pod nazivom uredskog prostora, gdje su dečki u tom filmu, nije ista stvar, to zeznuo u potpunosti, završio s puta previše Novac u njihove bankovne račune. Sve je to bilo vrlo sumnjivo. Ali na kraju krajeva, nepreciznosti je svuda oko nas. 

I to je, također, može biti zastrašujuće slučaj. Ispada da je Superman 3 i poslovni prostor na stranu, ima može biti neki vrlo stvaran svjetski posljedice od stvarnosti neprecizan prikaz podataka da čak i mi ljudi u danas ne moraju nužno shvatiti kao i mi trebali, ili se ne sjećaju što je češće nego što bismo trebali. I, doista, sljedeći isječak od pogled na neke vrlo stvarnom svijetu Posljedice Što se događa ako ne cijeniti nepreciznost koja se može dogoditi u brojkama reprezentacije. 

[VIDEO PLAYBACK] 

-Computers, Svi smo došli prihvatiti su često frustrirajuće problemi koji ići s them-- greške, virusa, i softverske propuste, za male cijene za plaćanje za praktičnost. No, u visoke tehnologije i velike brzine vojni i svemirski program aplikacije najmanji problem može uzveličati u katastrofu. 

4. lipnja 1996. godine, znanstvenici su pripremili pokrenuti bez posade Ariane 5 raketa. To je nosio znanstveni sateliti dizajniran utvrditi točno kako zemlja je u interakciju magnetskog polja sa solarnim vjetrovima. Raketa je sagrađena za Europska svemirska agencija, i podigne iz svog objekta na obali Francuske Gvajane. 

-U Oko 37 sekundi u let, najprije primijetio da se nešto događa u redu. Mlaznice su zakretanjem u način oni stvarno ne bi trebali. Oko 40 sekundi u letu, jasno, vozilo je u nevolji. 

A to je kada su napravili odluka da ga uništi. Časnik za sigurnost raspona, uz ogromne crijeva, pritisnuo gumb, raznijeli raketu, prije nego što je mogao postati opasnost za javnu sigurnost. 

-Ovo Je djevojka putovanje od Ariane 5. A njeno rušenje uzeo staviti zbog mana ugrađen u raketnom softveru. -U Problem na Ariane je da je broj koji je potrebna 64 bita izraziti. I oni su htjeli pretvoriti to je 16-bitni broj. Oni su pretpostavili da je broj nikada nije bio idući biti vrlo velika, da većina onih znamenke u 64-bitnoj broja su nula. Oni su bili u krivu. 

-U Nesposobnost jedne program za prihvaćanje vrsta broja generira drugi je bio na korijen neuspjeha. Razvoj softvera je postao vrlo skupo dio nove tehnologije. Raketa Ariana su bili vrlo uspješna, toliko softvera stvoren za to je bio i koristi u Ariane 5. 

-U Osnovni problem je da je Ariane 5 bio brži, ubrzano brže. A softver nije imala činili to. 

-U Uništavanje raketa bio je veliki financijska katastrofa, sve zbog pogreške u minutu softvera. No, to nije bio prvi Vrijeme problemi konverziju podataka je udario moderne raketne tehnologije. 

-u 1991, s početkom od prvog Zaljevskog rata, Patriot raketa doživio sličnu vrstu problema broj konverzija. I kao rezultat toga, 28 osoba, 28 američkih vojnika, je ubijeno, a oko 100 drugi su ranjeni, kada je domoljub, koji je trebao za zaštitu od dolaznih scuds, nije uspio ispaliti projektil. 

-Kada Irak napao Kuvajt, i Ameriku pokrenula Pustinjska oluja početkom 1991. godine, Patriot raketnih sustava bili raspoređeni zaštititi Saudijsku Arabiju i Izrael iz iračkih Scud raketnih napada. Patriot je američki srednjeg dometa površina u sustav zraka, proizvedeni od strane tvrtke Raytheon. 

-U Veličina Patriot interceptor Sam je oko otprilike 20 stopa dugačak. I to teži oko 2.000 funti. I to nosi bojevu glavu od o, Mislim da je to otprilike 150 funti. I sama bojna glava je visoka eksploziv, koji je ima fragmente oko njega. Kućište je bojnom glavom osmišljena su da djeluju kao sačma. 

-U Rakete provodi četiri po kontejneru, a prevoze po polu prikolica. 

-U Patriot anti-raketni sustav seže najmanje 20 godina. To je izvorno dizajniran kao obrana rakete zrak pucati dolje neprijateljske zrakoplove. U prvom Zaljevskom ratu, kada je taj rat došao uzduž, vojska želi ga koristiti za pucati dolje scuds, a ne avionima. 

Irački Zrakoplovstvo je ne toliko problema. Ali vojska je zabrinuta zbog scuds. I tako su pokušali nadograditi Patriot. 

-Intercepting Neprijatelja projektil putuje na Mach 5 će biti dovoljno izazovan. No, kad je Patriot je požurio u službu, vojska nije bio svjestan nekog Irački modifikacija koje je napravio njihovi scuds gotovo nemoguće pogoditi. 

Što se dogodilo je scuds da su dolazili u bilo nestabilno. Oni su wobbling. Razlog za to je Iračani, u cilju da bi dobili 600 kilometara od 300 kilometra Raspon raketa, uzeo težinu iz prednjeg bojnom glavom. Oni su napravili bojeva glava upaljača. 

Tako sada Patriot je pokušava doći na Scud. I većinu vremena, velika većina vremena, to bi samo letjeti od Scud. Nakon operatora Patriot sustava shvatio da je Patriot propustili svoj cilj, oni detonirao Patriot u bojnu glavu kako bi se izbjegle eventualne gubitke ako se bilo dopušteno da padne na tlo. 

-To Je ono što većina ljudi vidjeli, one velike vatrene kugle na nebu, i neshvaćen kao presreće od Scud bojevih glava. 

-Although U noći nebo, Patriots pojavio biti uspješno uništavanje Scuds, na Dhahran, ne može biti pogreška o njegovu učinkovitost. Tamo, Patriot je radarski sustav izgubio trag o dolaznom Scud, i nikad pokrenut zbog za softver mana. Bilo je Izraelce koji je prvi otkrio da je više je sustav uključen, veće odstupanje vremena postala, zbog sat ugrađen u računalo sustava. 

-Oko Dva tjedna prije tragedija u Dhahran, Izraelci prijavljen Ministarstvo obrane da sustav gubi vrijeme. Nakon što je oko osam sati ili trčanje, su primijetili da u sustavu postaje osjetno manje točne. Ministarstvo obrane je odgovorila govori sve Patriot baterije da ne napuštaju sustav na za dugo vremena. Oni nikada nije rekao ono što je dugo vremena was-- osam sati, 10 sati, 1000 sati. Nitko nije znao. 

-U Patriot baterije stacionirane u vojarni u Dhahran i njegova mana unutarnje Sat je bio na preko 100 sati u noći 25. veljače. 

-To Pratiti put do točnosti od oko desetine sekunde. Sada, desetine sekunde je zanimljiv broj, jer se ne može izraziti u binarnom točno, što znači da se ne može izraziti točno u bilo suvremenog digitalnog računala. Teško je vjerovati. 

Ali koristiti kao primjer. Uzmimo broj trećinu. Jedna trećina ne može biti izražena u decimalnom točno. Jedna trećina je 0.333 traje beskonačno. 

Ne postoji način da to učiniti s apsolutna preciznost u decimale. To je upravo ona vrsta problema što se dogodilo u Patriot. Što duže sustav ran je gore je postao time error. 

-Nakon 100 sati rada, pogreška u to vrijeme bio samo oko jedne trećine sekunde. No, u smislu koja cilja projektil putuje na Mach 5, to je rezultiralo praćenje Pogreška od preko 600 metara. To bi bila fatalna pogreška za vojnike na ono dogodilo je Scud pokretanje bio otkriven ranih satelita upozorenja a oni su znali da je Scud je dolaze u općem smjeru. Oni nisu znali odakle dolazi. 

-Bilo Je sada na radaru komponenta Patriot sustava brani Dhahran locirati i držati staza od ulazne neprijateljske rakete. 

-U Radar je bio vrlo pametan. To bi zapravo pratiti položaj Scud, a zatim predvidjeti gdje je vjerojatno će biti sljedeći put radar poslao puls van. To je bio pozvan niz vrata. 

Onda, nakon Patriot odluči dovoljno vremena ima prošao vratiti i provjeriti sljedeći Mjesto za ovu otkriveni objekt, to ide natrag. Dakle, kada se vratio u krivu mjesto, to onda ne vidi objekt. I odluči da ne postoji predmet, to je bila lažna otkrivanje, i kapi pjesmu. 

-U Dolazni Scud nestala s radara. I sekundi kasnije ga udario u vojarnu. Scud ubijeno 28, a bio je posljednji jedan otkaz tijekom prvog Zaljevskog rata. 

Tragično, ažurirani softver stigao u Dhahran sljedeći dan. Softver mana je imao bila fiksna, zatvaranje jedno poglavlje u problematičnom Povijest Patriot rakete. 

[VIDEO PLAYBACK] DAVID J. Malan: Dakle, to je sve kažu da je tih pitanja preljeva i nepreciznosti su svi previše stvaran. Pa kako smo došli ovdje? Mi smo počeli sa samo govori o printf. Opet, to funkcija koja ispisuje nešto na ekranu, a mi smo uveli nakon toga nekoliko drugih funkcija od tzv CS50 knjižnici. A mi ćemo i dalje vidi ih u dogledno vrijeme. A mi, posebno, koristi get niz, i dobiti int, a sada i dobiti plutaju, a neki će i dalje nailazimo i koriste se prije dugo. 

No, ponekad se već smo vidjeli potrebu pohraniti ono što te funkcije ruku natrag? Oni predaju nas natrag niz, ili int ili float. I ponekad moramo staviti string ili int ili float, negdje. 

A za pohranu one stvari, sjećam samo kao u nule, imamo varijable. No, za razliku od nule, u C imamo stvarne vrste od variables-- podataka tipovi, više generally-- među njima, niz, int, A plutaju, a ovi drugi i dalje. 

I tako kad smo proglasiti varijable u C, ćemo morati proglasiti naše vrste podataka. To nije nešto što ćete morate učiniti kasnije u semestru kao što smo prijelaz na druge jezike. No, za sada, mi trebamo da se apriori unaprijed, objasniti na računalo ono tipa varijable želimo da nam se dati. 

Sada je, u međuvremenu, za ispis one vrste tipova podataka, moramo reći printf što očekivati. A vidjeli smo posto s za gudače, a posto ja za cijele brojeve, i nekoliko drugih već. A oni su jednostavno zahtjevi Za vizualni prikaz tih informacija. 

I svaka od njih zapravo može biti parametrizirana ili praćka na neki način, Ako želite dodatnu kontrolu vrsta proizvodnje koje ste dobili. A, u stvari, ispada da ne samo da postoji obrnuta kosa crta n za novu liniju. Ima još nešto što se zove obrnuta kosa crta r za povrat valjka, koji više srodan do stara škola pisaći stroj, i Windows koristi za mnogo godina. 

Postoji obrnuta kosa crta t za kartice. Ispada, da ako želite dvostruki navodnici unutar niza, Sjetite se da smo koristili dvostruki navodnici dvostruko citat na lijevoj i desnoj strani završava naših žice do sada. To će se činiti da se zbuniti stvari. 

Ako želite staviti dvostruko citat u usred string-- i, štoviše, to je zbunjujuće vidjeti. I tako da ćete morati pobjeći, tako da se govoriti, dvostruki citat s nečim kao, doslovno, kosih crta dvostruko citat. I tu je neki drugi i dalje. A mi ćemo vidjeti više od onih u stvarnoj uporabi prije dugo. 

Tako ćemo sada prijelaz iz podataka i zastupanje, i aritmetički operatori, sve od kojih nam je dao neke zgrade blokovi s kojim se igraju. Ali sada idemo zapravo dati nam ostatak vokabulara da smo već imali prošli tjedan s nule uzimajući pogled na neki drugi konstrukti u C-- nisu svi od njih. No, ideja da smo vidjet zapravo samo naglasiti prijevod iz jedan jezik, Scratch, na drugu, C. 

I s vremenom, mi ćemo pokupiti više alata za naše alate, da tako kažemo, sintaktički. I doista, vidjet ćete da je ideja sada su već poznati od prošlog tjedna. Tako ćemo to učiniti. 

Idemo naprijed i ščepati program koji zapravo koristi neke izraze, Booleova izraz. Pusti me naprijed ovdje i stvoriti novu datoteku. Nazvat ću ovo condition.c. 

Pusti me naprijed i uključuju CS50 knjižnicu. I neka mi ići naprijed i uključuju standardni IO.h za naše funkcije, i printf, i više respektivno. Dopustite mi da si dati da predloženi od int glavna praznina, čije objašnjenje mi ćemo vratiti se u budućnosti. 

Sada neka mi ići naprijed i dati ja int preko get int. Onda neka mi ići naprijed i učiniti. Želim reći, ako sam je less-- neka je razlikovati pozitivne, negativne, ili nula vrijednosti. 

Dakle, ako je i manje od nule, pusti me samo ovaj program jednostavno reći, negativan, kosih crta n, ostalo ako ja je veći od nule. Sada sam, naravno, neće reći printf pozitivan, obrnute kose crte br. I onda još if-- sam mogao to učiniti. 

Što mogu učiniti ako sam jednak 0. Ali ja bih se odluka na Najmanje jedna pogreška već. Sjetite se da je znak jednakosti je nije jednako kao i mi ljudi to znaju. 

No, to je operator zadatak. A mi ne želimo da se 0 na Pravo i staviti ga u i na lijevoj strani. Dakle, kako bi se izbjegle zabune, ili možda zloupotreba znaka jednakosti, ljudi odlučili prije nekoliko godina da u mnogim programskim jezicima kada želite provjeriti jednakost između lijeve i desne strane, što zapravo koristiti jednak jednakima. Znači li pogoditi znaka jednakosti dva puta. Kada želite pridružiti s desna na lijevo, koristite jedan znak jednakosti. Tako smo mogli to učinimo drugo ako ja jednak jednak nuli. 

I onda mogao ići i otvorim vitičastim zagradama, i reći: printf 0, kosih crta n, učinjeno. Ali zapamtite kako se oni vilice na cesti može raditi. I, stvarno, samo mislim o logici. ja je broj. To je cijeli broj, konkretno. A to znači da će biti manje od 0, ili veći od 0, ili 0 ° C. Dakle, postoji neka vrsta toga implicirana zadani slučaj. 

I tako smo mogli, baš kao i Scratch, dijeliti s još ako se, a samo reći drugo. Logično, ako vam programer zna da postoji samo tri kante u kojoj je scenarij može fall-- prvi, druga ili treća u ovom case-- ne smetaju dodajući još preciznost a dodatna logika tamo. Samo naprijed s Zadana ovdje slučaj od drugdje. 

Sada, idemo naprijed nakon spremanja toga napraviti Uvjeti dot slash conditions-- Nije veliki korisničko sučelje, jer nisam potaknuvši Korisnik, kao što sam spomenuo ranije. No, to je u redu. Mi ćemo i dalje ostane jednostavan. Pokušajmo broj 42. I to je pozitivno. Pokušajmo broj negativno 42, negativan. 

Pokušajmo vrijednost 0. I doista, to radi. Sada ćete vidjeti s problemima prije duge, ispitivanje stvari tri puta, Vjerojatno nije dovoljno. Vi vjerojatno želite testirati neke veće brojeve, neke manje brojevi, neki kutak slučajevima, kako doći ćemo ih opisati. 

No, za sada, to je prilično jednostavan program. I prilično sam siguran, logično, da spada u tri slučaja. I doista, iako smo upravo usredotočeni na potencijalne mane nepreciznosti i preljevom, u Stvarnost u kojoj su mnogi od CS50 probleme, nećemo brinuti o, sve vrijeme, ta pitanja preljeva i nepreciznosti zbog, u stvari, u C, to je zapravo nije sve što je lako izbjeći te stvari. Ako želite brojati veći i veći, i veći, ispada postoje tehnike vi mogu koristiti, često uključuje stvari zove knjižnice, zbirke koda, to drugi ljudi pisali da možete koristiti, i drugih jezika kao Java i drugi, zapravo čine ga puno lakše računati čak i veći. Dakle, to je stvarno neki od tih opasnosti funkcija jezika koji koristite. I u narednim tjednima, mi ćemo vidjeti koliko opasno C stvarno može biti ako se ne koristi pravilno. Ali od tamo, a uz Python i JavaScript, bit mi sloj na neke dodatne zaštite, i pokrenuti manje od tih rizika. 

Tako ćemo napraviti malo više Zanimljiva logika u našem programu. Pa neka mi ići naprijed i stvoriti program koji se zove Logičke Samo tako da mogu igrati s nekim Stvarni logika, logical.c. Ja ću samo kopirati i zalijepiti neke broj od ranije pa se vratim na ovom lijepom polazište. 

Neka mi ovaj put napraviti char C. Ja sam će mu dati ime C samo zato što je konvencionalna, dobiti znak od korisnika. I neka je pretvarati se kao Ja provedbu dijela tog Rm programa, ukloniti Program prije toga zatraži korisniku ukloniti datoteku. Kako bismo to mogli učiniti? 

Želim reći, ako je C jednak jednak, citat citat, y, onda ću pretpostaviti da je korisnik odabrao da. Samo ću ispisati da. Ako je to zapravo pisanje uklanjanje programa, bismo mogli ukloniti datoteku s više linija koda. No, mi ćemo i dalje ostane jednostavan. 

Inače, ako c jednak jednak n- i sad ovdje, ja ću reći, korisnik mora značiti br. I onda drugo, znate što? Ne znam što drugo korisnik će se upisati. Dakle, ja sam samo htjela reći da je to je greška, što god on ili ona zapravo upisali. 

Dakle, ono što se ovdje događa? Postoji temeljna razlika u odnosu na ono što sam učinio u prošlosti. Dvostruki navodnici, dvostruki navodnici, dvostruka citati, a ipak, jednostruke navodnike, jednostruke navodnike. Ispada u C, da kada želite napisati niz, vi koristiti dvostruke navodnike, baš kao što imamo koristim sve ovo vrijeme s printf. 

Ali ako želite da se bave samo jedan znak, tzv char, onda zapravo koristiti jednostruke navodnike. Oni od vas koji su programirani prije, možda nemate morao brinuti o tome Razlika u nekim jezicima. U C, ona je važna. I tako kad ja dobiti char i ja želim usporediti taj char koristeći jednakima jednaka nekom pismu kao što su y ili n, i ja, doista, potrebno je imati jednostruke navodnike. 

Sada, neka je ići naprijed i učiniti. Idemo naprijed i ne čine logičke dot slash logično. I sada sam se od vas zatraži. Dakle, vjerojatno, bolje korisničko iskustvo zapravo bi mi reći što učiniti ovdje. Ali ja ću se samo slijepo kažu y za da, u redu, lijepo. 

Idemo ponovno aktivirati, n za ne, lijepo. Recimo kao nekim ljudima koje znam, moji caps lock uključen prečesto. Pa ja kapitala Y, ući, pogrešku. U redu, to nije točno ono što sam očekivao. Doista, računalo radi doslovno ono Rekao sam da do-- provjeriti mala y i mala n. Ovo se ne osjećam kao dobar korisničko iskustvo, ipak. Pusti me tražiti i prihvatiti ili mala slova ili gornji slučaj. Tako ispada, možda želite reći nešto kao u nule, kao što su doslovno ili C jednaka jednaka kapitala jedan citirani y. Ispada, C nema to doslovna riječ ili. 

No, ona ima dvije okomite pruge. Morate držati Shift obično, ako koristite američku tipkovnicu, i udario u okomitu traku Ključ iznad povratka ključ. No, to okomita traka okomita traka znači ili. 

Ako, s druge strane, željeli smo reći i, kao u nule, smo mogli učiniti ampersand ampersand. To nema logičnog smisla ovdje, jer čovjek ne bi mogao upisali oba y i mala y i kapitala Y kao isti znak. Dakle, ili je ono što želimo ovdje. 

Dakle, ako sam to učiniti na oba mjesta, ili C jednak jednaka kapital N, sad ponovi, čine logičnim, repriza logično. Sada, ja mogu upisati y. I ja mogu to učiniti opet sa kapitala Y ili grad N. I ja sam mogao dodati u dodatni Kombinacije dalje. 

Dakle, to je logično Program utoliko što je sada Odjavljujem logično za ova vrijednost ili je ta vrijednost. A ja ne moram nužno, se s još dva oklijevanja ili drugo oklijevanja. Ja zapravo mogu kombinirati neke od vezana logika zajedno na ovaj način. Tako će to biti bolje dizajniran da jednostavno govoreći, ako je C jednak mala slova y, ispisati da, još ako je c jednak kapitala Y, ispisati da, još ako je c jednak lower-- drugim riječima, ne morate imati sve više i više grana. Možete kombinirati neke od protuvrijednosti grane Logično, što je na ovaj način. 

Tako ćemo pogledati samo jedan Konačni sastojak, jedan konačni konstrukt, da je C dopušta. A mi ćemo se vratiti u Budućnost drugima još. A onda ćemo zaključiti gledajući na ne ispravnosti code-- uzimajući kod u našem mišljenju, ali dizajn koda i posaditi one sjemenke rano. 

Pa neka mi ići naprijed i otvoriti novu datoteku ovdje. Znaš što? Idem ponovno provesti da isti program, ali s drugačijim konstrukt. 

Dakle, mi ćemo vrlo brzo dati sebe Pristup uključiti CS50.h za CS50 knjižnici, standardni Io.h za printf. Daj mi moju int glavni prazninu. I onda ovdje, neka mi ići naprijed i učiniti. 

Char c dobiva dobili char, baš kao i prije. I ja ću koristiti novi konstrukt now-- prebaciti, na što lik? Dakle, prekidač je vrsta kao što su prebacivanje u vlaku pjesme. Ili, stvarno, to je vrsta if drugo, ako je drugo, ako, ali napisano nešto drugačije. 

Prekidač izgleda ovako. Imate prekidač, i što onda znak ili broj koji želite pogledati, onda neki vitičastim zagradama kao u Scratch, samo reci ne ove stvari. I onda imaju različite slučajeve. 

Ne koristiti ako je i ostalo. Vi doslovno koristiti slučaj riječi. A ti bi rekao nešto poput ovoga. 

Dakle, u slučaju malih slova y, ili u slučaju kapitala Y, ići naprijed i ispisati da. A onda pobjeći iz prekidača. To je to. Gotovi smo. 

Inače, ako, da tako kažemo, mala slova n, odnosno kapitala N, onda ići naprijed i print kako ne, a onda slomiti. Else-- i ova vrsta je zadani slučaj indeed-- printf error-- i samo za dobru mjeru, iako logično ova pauza nije potrebna jer smo na kraju prekidača u svakom slučaju, Ja sam sada izlaska iz prekidača. Dakle, ovo izgleda malo drugačije. 

No, logično, to je zapravo ekvivalent. A zašto bi vam koristiti jedan na drugi? Ponekad, samo osobnih preferencija, ponekad estetika, ako gledam na to Sada, postoji nešto rekao je da se za čitljivost ovog zakona. Mislim, nikad ne smeta činjenica da je ovaj kod je novo za mnoge od nas u sobi. 

No, to je samo vrsta je prilično. Vidite mala slova y, kapitala Y, mala slova n, glavni N zadana, to je samo vrsta skokova se na vas na način da, vjerojatno, možda Iz prethodnog primjera s MS-e, kao i okomite trake a drugo oklijevanja, ne bi mogli imati. Dakle, ovo je stvarno stvar osobnog izbor, stvarno, ili čitljivost, koda. 

No, u smislu funkcionalnosti, pusti me ići naprijed i napraviti prekidač, dot slash prekidač, a sada pisanje malim slovima y, kapitala Y, mala slova n, glavni N, David ponovno pokušati, jer to je ni jedan znak. Učinimo x, greška, kako se i očekivalo. I logically-- i to je nešto Ja bi potaknuti na opću, čak iako smo samo češanje Površina neke od tih značajki. 

I to možda neće biti očite kod vas sami sjesti na tipkovnici, Kako ovo radi? Što bi to učinili? Prekrasna stvar o vlasništvo laptop ili stolno računalo, ili pristup na računalo s prevodilac, i sa uređivač koda kao što je ovaj, se gotovo uvijek može odgovoriti na ova Pitanja za sebe samo iz pokušaja. 

Na primjer, ako je retoričko Pitanje pri ruci bili su, što se događa ako ste zaboravili pauze izjave? Koji je zapravo vrlo uobičajena stvar za napraviti, jer to ne izgleda kao da ih je zaista potrebno. Oni zapravo ne dovrši svoj mislio kao zagradi ili kovrčava Brace radi. Idemo naprijed i rekompiliranje kod i vidjeti. Na taj način bi prekidač, dot slash sklopke. Recimo tip malim slovima y, gornji slučaj, Enter. Tako sam upisao y. 

Program je rekao da, ne, greška, kao da je mijenja svoj um. Ali to vrsta bila, jer ono što se događa s prekidačem je prvi slučaj da je Utakmica u biti znači, hej računalo, izvršava sve koda ispod njega. A ako ne kažem pauze, ili ne kažem pauzu, ili ne reći pauzu, računalo će puhati kroz sva ta linija i izvršiti sve od njih sve dok se dobiva na tom kovrčavom braće. Tako su kočnice doista potrebno. Ali takeaway ovdje, kad u nedoumici, probajte nešto. Možda spasiti svoj kod prvog, ili ga spremiti u extra datoteku ako si stvarno zabrinut zabrljati gore i da se oporavi rad koji znate da radi. 

No, pokušajte stvari. I nemojte biti kao boj se, možda, onoga što računalo može učiniti, ili da je možda nešto pokvariti. Uvijek možete vratiti u nekoj ranijoj verziji. 

Tako ćemo završiti gledajući u dizajnu koda. Imamo tu sposobnost sada pisati uvjeti i napišite petlje, i varijable, i poziv funkcije. Pa, iskreno, mi smo vrsta natrag na gdje smo bili prije tjedan dana s nule, iako s manje uvjerljiv tekstualnog okoliš od nule dopušta. 

Ali primijetiti kako brzo smo stekli da vokabular, čak i ako je će potrajati neko vrijeme da sjedne, tako da smo sada mogu koristiti ovaj riječnik više pisati zanimljive programe. I neka je korak za bebe prema tome, kao što slijedi. Pusti me naprijed i stvoriti novu datoteku ovdje. 

Idem nazvati ovo prototype.c, te uvesti po prvi put, sposobnost kako napraviti svoj vlastiti funkcije. Neki od vas možda ima to učinili s nule, u kojem možete stvoriti svoje vlastite prilagođene blokovi u nule, a zatim ih povucite na mjesto gdje god želite u C. I u većini programa jezici, možete to učiniti upravo that-- napraviti svoj vlastiti funkcije, ako oni ne postoje. 

Tako, na primjer, neka mi samo naprijed i uključuju CS50.h, a uključuju standardni IO.h, int glavna nevažeće. I sada imamo placeholder spremni otići. Držim tiskanja stvari kao što su imena ljudi danas. I da se osjeća da bismo mogli Ne bi bilo lijepo da postoji bili funkciju pod nazivom Naziv ispisa? Ne moram koristiti printf. Ne moram se sjetiti svi format kodovi. Zašto ne ja, ili zašto nije netko prije mene, stvoriti funkciju pod nazivom ispis ime, da dati neki naziv, jednostavno ga ispisuje? 

Drugim riječima, ako kažem, hej, Računalo, daj mi niz pitajući korisnika za takve, preko CS50 je doći string funkcije. Hej, računalo, staviti da string u varijabla u lijevoj strani, i nazvati to je. A onda, hej računalo, samo naprijed i ispisati to ime osobe, učinjeno. 

Sada, to bi bilo lijepo, jer ovaj program, podesno zove, govori mi ono što je trebao učiniti putem imena onih funkciju a. Pusti me i napraviti prototip, Enter. I, na žalost, to ne ide letjeti. 

Prototype.c, linija 7, karakter 5, pogreška, implicitno izjava od funkcije ime za ispis nevaljana u C99, C99 što znači verziju C koji je izašao 1999. godine. To je sve. 

Dakle, ne znam što sve je to još uvijek znači. Ali ja ne priznaju grešku u crvenom. To je prilično očito. 

A čini se da je s zeleni lik ovdje, problem vezan uz ime pisača, otvorite zagrada s, zatvoreni navodnik, polu-debelo crijevo. No, implicitno deklaracija Funkcija nismo vidjeli ukratko ranije. To znači, jednostavno, da je jeka ne znam što mislim. 

Ja sam se na vokabular riječi da je nikada nije vidio ili je prije učio. I tako sam ga morati naučiti što ova funkcija znači. Tako ću ići naprijed i učiniti. 

Ja ću ići naprijed i provoditi moja funkcija zove Ispis Ime. A ja ću reći, kako slijedi, da To čini, printf, Hello, posto s, kosih crta n, ime i prezime, točka-zarez. Pa što sam upravo učinio? 

Tako ispada da provesti vlastitu funkciju, mi vrsta posuditi neke od istu strukturu kao glavni da smo upravo bili uzimati zdravo za gotovo, a ja znam samo kopiranje i lijepljenje ljepušan velik dio onoga Sam pisao u prošlosti. Ali primijetite uzorak ovdje. Interesi, Main, Void ćemo zafrkavati, osim prije dugo što to zapravo znači. 

Ali danas, samo primijetiti paralelizam. Void, naziv print, Naziv niz, tako da ljubičasta ključne riječi, koje ćemo početi pozivom na vrstu povrata, naziv funkcija, te ulazni. Dakle, zapravo, možemo destilirati ova vrsta kao što su prošlog tjedna kao, to je ime, odnosno Algoritam koda smo ide na write-- algoritam se temelji šifra ćemo pisati. 

To je njegov unos. To je njegov izlaz. Ova funkcija, naziv ispisa je osmišljen kako bi se string zove ime, ili bilo što, što je ulaz, a zatim nevažeće. To ne vraća ništa, kao što su dobili niz ili dobiti int radi. Dakle, to će mi ruku nešto natrag. To je samo ide da imaju nuspojava, da tako kažemo, ispisa ime osobe. Dakle primijetiti, linija 7, ja mogu nazvati naziv ispisa. Linija 10, mogu definirati ili provoditi naziv ispisa. No, na žalost, to nije dovoljno. 

Pusti me naprijed i rekompiliranje to nakon spremanja. Opa, sad, ja sam to napravio još gore, čini se. Dakle implicitno deklaracija Naziv Funkcija ispisa je nevažeći. A, opet, ima više pogrešaka. Ali kao što sam upozorio ranije, ako se osvaja sa, ili malo tužno vidjeti tolike pogreške, usredotočiti se samo na prvi u početku, jer bi to moglo samo imali kaskadni učinak. Dakle, C, ili zveket točnije, još uvijek ne priznaje naziv ispisa. 

A to je zato što zveket, po dizajnu, je vrsta nijem. On samo radi ono što ga kažem. I to ne samo tako da u cilju u kojoj ste ga kažem. 

Tako sam to naznačio glavni na liniji četiri, kao što smo radili prilično često. Ja sam je definirano ime za ispis na liniji 10. Ali ja pokušavam koristiti Naziv ispisa na liniji sedam. 

To je prerano, još uvijek ne postoji. Tako sam mogao biti pametan i biti, OK, neka je samo igrati zajedno, i premjestiti ime za ispis prema gore ovdje, i ponovno sastaviti. O moj Bože. Upalilo je. To je kao jednostavan kao taj. 

Ali logika je upravo to. Morate naučiti jeka što je definiranjem funkciju na prvom mjestu. Zatim ga možete koristiti. Ali, iskreno, to se osjeća kao sklizak padini. 

Dakle, svaki put kad pokrenete u problem, samo sam će istaknuti i kopirati kod Napisao sam, izrezati i zalijepiti ovdje. I, svakako, mogli bismo dovijati neke scenarije gdje jedna funkcija možda trebate nazvati drugu. I jednostavno ne mogu staviti svaki Funkcija iznad svake druge. 

Tako ispada da postoji bolje rješenje. Možemo ostaviti to biti. I, iskreno, to je uglavnom lijepo, i zgodan i dobar dizajn staviti glavna prvo, jer, opet, Glavni baš kao i kada je zelena zastava pritisne, to je funkcija dobiva pogubili po defaultu. Tako da kao što bi dobro staviti je na vrhu datoteke tako da kada ste vi ili bilo druga ljudska gleda datoteke znate što se događa Samo čitajući Glavna prvi. Tako ispada, možemo reći jeka proaktivno, hej, zveket, na liniji četiri, Obećajem da ću provoditi funkcija zove Ispis Ime koje ima niz naziva ime kao ulaz, i vraća ništa, praznina. A ja ću doći oko njegovu provedbu kasnije. 

Ovdje dolazi Main. Glavni je sada na liniji 9 mogu koristiti Ispis Naziv jer jeka je vjerujući da je, na kraju, to će naići na definiciju provedbe Ispis imena. Tako je nakon spremanja moj dosje, neka mi ići naprijed i učiniti prototip, izgleda dobro ovaj put. Dot udarac, prototip, neka me ići naprijed i upišite ime. David, zdravo David Zamila, zdravo Zamila, i, štoviše, sada to radi. 

Tako je sastojak ovdje je da imamo napravili prilagođenu funkciju, kao običaj Blok Blok smo ga zove. No, za razliku od nule, gdje možete samo ga stvoriti i početi koristiti, sada moramo biti malo više pedantan, i zapravo vlak jeka koristiti ili da ga očekuju. Sada, kao usput, zašto sve ovo vrijeme ima smo bili samo slijepo vjere, uključujući CS50.h, uključujući i standardne IO.h? 

Pa, što se ispostavilo, Među nekoliko drugih stvari, sve što je u tim dot h datoteke, koje se dogoditi da se slika. Oni zaglavlje datoteke, da tako kažemo. Oni još uvijek pisana u C. No, oni su druga vrsta datoteke. 

Za sada, možete prilično mnogo pretpostaviti da je sve što je unutar CS50.h je li netko-linijski brodovi kao što je ovaj, a ne za funkcije nazivaju Ispis Ime, ali za dobiti String, Get Float, i nekoliko drugih. A tu su i slični prototipovi, jedan linijski brodovi, unutar standardne IO.h za printf, koji je sada u moja funkcija ispisa Naziv. Dakle, drugim riječima, cijelo vrijeme mi smo upravo slijepo kopiranje i lijepljenje su to, uključuju da, što se događa? To su samo neka vrsta tragove da jeka, sto funkcijama su, doista, provode, samo drugdje u različite datoteke drugdje u sustavu. 

Stoga smo provoditi naziv ispisa. Ona ima tu nuspojavu ispis nešto na ekranu. Ali to zapravo ne ruka me nešto natrag. Kako ćemo ići oko provodi program koji nema ruku mi nešto natrag? 

Pa, pokušajmo. Pusti me naprijed i provoditi datoteka zove return.c tako da možemo pokazati kako nešto kao što su dobili String ili dobiti Int, je zapravo povratak nešto natrag korisniku. Idemo naprijed i definirati int glavni prazninu. 

A, opet, u budućnosti, mi ćemo objasniti što je to int i tu prazninu zapravo radi. Ali danas, mi ćemo uzeti zdravo za gotovo. Ja ću ići naprijed i printf, za dobar korisničko iskustvo, x je. A onda ću čekati korisnički mi dati x S dobiti int. 

A onda ću ići naprijed i ispisati x na kvadrat. Dakle, kada imate samo tipkovnica, ljudi obično koristiti malo mrkve simbol na tipkovnici zastupati u vlasti , ili eksponent. Dakle, x na kvadrat je prisutan i. 

A sada ću to učiniti. Ja samo mogu do-- što je x kvadrat? x na kvadrat je x puta x. 

I mi to učinio neki prije vremena već danas. To ne osjećaju kao sve što je veliki napredak. Znaš što? Idemo iskoristiti nešto od te ideje od zadnjeg puta apstrakcije. 

Ne bi li bilo lijepo da postoji funkcija zove trg koji radi upravo to? Još uvijek, na kraju od dan, čini istu matematiku. Ali neka apstraktna daleko je ideja o preuzimanju jedan broj pomnožen drugi, i samo dati mu ime, kao što je trg ovu vrijednost. 

I, drugim riječima, u C, idemo stvoriti funkciju zove trg koji radi upravo to. To će se zvati trg. To će uzeti int. I mi ćemo vam samo zovu ga n, po defaultu. 

Ali mi smo ga mogli nazvati nešto što želimo. I sve to će to učiniti, doslovno je povratak rezultat n puta n. No, budući da je povratak nešto, što je ključna riječ u ljubičasto imamo nikada nije vidio prije, sam, na liniji 11, Ne mogu samo reći void ovaj put. 

Void, u primjeru smo upravo vidjeli umjesto naziva pisača, samo znači, učini nešto. No, ne ruka me nešto natrag. U tom slučaju, ja želim da se vrati n puta n, ili što god da je, taj broj. 

Tako da ne mogu reći, hej, računalo, I vratiti ništa, praznina. To će se vratiti, po prirodi, int. I to je sve što se ovdje događa. 

Ulaz na kvadrat će biti int. I tako da ga možemo koristiti, mora ime, N. To će izlaz int da ne treba ime. Možemo ga ostaviti na glavni, ili tko je pomoću me zapamtiti ovu vrijednost ako smo želim s vlastitim varijable. 

A, opet, jedini novi ključna riječ ovdje je povratak. A ja sam samo radi neke matematike. Da sam zaista želio biti nepotrebno, Mogao sam reći int proizvod dobiva n puta n. 

A onda bih mogao reći, vratiti proizvod. Ali, opet, na moje točke ranije to jednostavno nije dobra design-- kao što su, zašto uvesti ime, simbol, kao što su proizvod, samo da ga odmah vratiti? Malo je čišći, malo čvršće, tako govoriti, samo da kažem povratak n puta n, dobili osloboditi od ove linije uopce. 

A to je samo manji broj za čitanje, manje prilika za pogreške. I neka je vidjeti ako to zapravo sada radi. Sada ću otići naprijed i napravi povrat. 

Uh, implicitno deklaracija funkcije. JA je napravio ovu grešku i prije, nije velika stvar. Pusti me samo upisati ili istaknuti i kopirati, točno isti funkciju prototipa, ili potpis, funkcije se ovdje. Ili bih mogao kontrolirati cijelu funkciju. 

No, to je malo lijen. Dakle, nećemo to učiniti. Sada, neka mi povratak opet, dot povratak kose crte. 

x je 2. x na kvadrat 4. x je 3. x na kvadrat je 9. A funkcija čini Sada se radi. Dakle, u čemu je razlika ovdje? Imam funkciju koja se zove trg, u ovom slučaju, koji sam stavio na ulaz. I ja sam se vratiti izlaz. Pa ipak, prije, ako Otvaram drugi primjer od ranije, što zvao prototype.c, Imao sam naziv ispisa, koji se vratio praznina, da tako kažemo, Ili se vratio ništa i naprosto nuspojava. 

Dakle, ono što se ovdje događa? Pa, razmislite funkciju dobili niz samo na trenutak. Mi smo koristili funkciju dobili niz na sljedeći način. 

Mi smo imali funkciju dobiti niz, kao što su CS50.h, uključuju standardni IO.h, int, glavni, prazninu. I onda svaki put sam zove get niz do sada, Ja sam rekao nešto slično, niz s dobiva dobili niz, jer get string-- nazovimo to get.c-- get string Sama vraća string koji mogu onda koristiti i reći zdravo, zarez, posto s, kosih crta n, a. 

Dakle, ovo je isti primjer, Stvarno, da smo imali ranije. Na taj način dobili niz vraća vrijednost. No, prije nekoliko trenutaka, print string ne vratiti vrijednost. To jednostavno ima nuspojava. Dakle, to je temeljna razlika. Vidjeli smo drugačiji vrste funkcija sada, od kojih su se vratili vrijednosti, od kojih ne. Dakle, možda je string, ili int ili float. Ili možda je to samo praznina. 

A razlika je da ove funkcije koje dobiti podatke i vratiti vrijednost zapravo donosi nešto natrag do stola, da se tako izrazim. Dakle idemo naprijed i pogledajte jedan završni set primjera koji daje osjećaj, sad, od kako smo mogli, doista, sažetak bolje, i bolje, i bolje, ili više, i više, i više, kako bi za pisanje, u konačnici, bolje koda. Idemo naprijed, te u duhu od nule, učinite sljedeće. 

Pusti me naprijed i uključuju CS50.h i standard IO.h. Pusti me naprijed i dati ja int, glavni, nevažeće. I neka mi samo naprijed, to nazivamo cough.c. 

I neka mi ići naprijed i samo kao što su grebanje, ispisati kašalj / N. I želim to učiniti tri puta. Tako sam, naravno, samo ide kopirati i zalijepiti tri puta. Ja sam sada ide kako bi kašalj dot kose crte kašalj. Idemo si dati malo više prostora Ovdje, Enter, kašalj, kašalj, kašalj. 

Tu je, očito, već prilika za poboljšanje. Ja sam kopirati i zalijepiti nekoliko puta danas. Ali to je bilo samo zato da nisam morate upisati što više znakova. I dalje mijenjati ono ta linija koda su. 

Ove tri linije su identične, koji osjeća lijen i doista jest, i vjerojatno nije pravi pristup. Dakle, s tim što sastojak možemo poboljšati ovaj kod? Nemamo kopirati i zalijepiti kod. 

I doista, u bilo koje vrijeme ako se osjećate sami kopiranja i lijepljenja, i ni mijenjanja koda, izgledi su da postoji bolji način. I, doista, ne postoji. Dopustite mi ići naprijed i učiniti for petlje, iako sintaksa ne bi mogli doći prirodno još. 

Učinite to tri puta, jednostavno tako što je following-- i ja slučajno znam iz prakse. No, imamo niz primjera sada. I vidjet ćete na internetu više referenci na mjestu. 

To je sintaksa na liniji 6, koji baš kao Scratch koji se ponavlja blok, ponoviti sljedeće tri puta. To je malo čarobno za sada. Ali to će dobiti više, i više upoznati. 

I to će se ponoviti linija osam tri puta, tako da ako sam ponovno sastaviti make kašalj, dot smanjiti kašalj, kašalj, kašalj, kašalj. Ona još uvijek radi na isti način. Tako da je sve u redu i dobro. Ali to nije jako rastresen. 

To je savršeno točno. No, ona se osjeća kao da mogla biti prilika, kako u svijetu Scratch, na kakve početak dodati neke semantiku ovdje, tako da Ne samo da su neki za petlju, i funkcija koja govori kašalj ili ne kašlje. Znaš što? Pokušat ću biti Malo hladnije od toga, i zapravo napisati funkciju koja ima neke nuspojave, zovu ga kašalj. 

I to traje ni ulaz, a vraća nikakvu vrijednost kao izlaz. Ali znate što to radi? To ne učinimo, printf, citat citat, kašalj. 

I sada ovdje, idem ići naprijed i za int, ja dobiva nulu, i manje od 3, i plus plus. Idem ne radi printf, što je nedvojbeno implementacija niska razina detalj. Ne zanima me kako kašalj. Samo želim koristiti funkciju kašalj. A ja sam samo nazvati kašalj. 

Sada, primijetit dihotomiju. Kada pozovete funkciju, ako ne žele dati to ulazi, potpuno u redu. Dovoljno je učiniti Otvorena zagrada, u neposrednoj blizini zagrada, i gotovi ste. 

Kada definirate funkciju, ili proglasiti funkciju je prototip, Ako unaprijed znate da to nije će poduzeti bilo kakve argumente, kažu praznina u tim zagradama tamo. I to čini sigurni da vas neće slučajno ga krivo. Dopustite mi ići naprijed i učiniti kašalj. I, naravno, ja sam pogriješio. 

Kvragu, tu je da implicitna izjava. No, to je u redu. To je lako popraviti. Samo moram prototip viši u mojoj datoteci nego što sam zapravo ja ga koristi. 

Pa sad neka mi kašalj opet lijepo. Sada se to radi. Provjerite kašalj, kašalj, kašalj, kašalj. Dakle, možda mislite da smo stvarno nešto više od inženjerstvo ovaj problem. I doista, mi smo. Ovo nije dobro Kandidat programa u ovom trenutku za refactoring, i radi ono što je zove hijerarhijska dekompozicija, gdje vam se neka kod, a zatim Vi vrsta faktor stvari, tako što pripisati više semantika s njima, i ponovno ga u konačnici dugoročno. No, to je blok zgrada prema više sofisticirane programe da ćemo početi pisanje prije dugo da omogućuje nam da imaju vokabular kojom napisati bolje koda. I, doista, neka je vidjeti ako mi Ne mogu generalizirati ovo dalje. 

Čini se malo hromu da sam, uglavnom, morate brinuti o ovom darn for petlje, i opet i opet zove kašalj. Zašto ne mogu samo reći kašalj, molim kašalj tri puta? Drugim riječima, zašto ne mogu jednostavno dati doprinos na kašalj, a to je činiti? 

Zašto ne mogu samo reći, u Glavni kašalj tri puta. A sada, to je vrsta čaroban. Vrlo je iterativan ovdje. I to je, doista, beba korak. 

Ali samo sposobnost za reći o linija osam, kašalj tri puta, to je samo tako mnogo više čitati. I, plus, ne moram znati ili briga kako kašalj se provodi. I doista, kasnije u pojam i za konačne projekte, ako se borila projekt s kolega ili dva kolege, shvatit ćete da idete moraju ili žele podijeliti posao. 

A ti si idući u ištanje to odlučiti unaprijed, tko će učiniti što, iu kojoj komada? I to ne bi bilo lijepo Ako, na primjer, uzeti zadužen za pisanje Main, ispunjavanja. I vaš cimer, ili vaš partner općenitije, brine o provedbi kašalj. 

I ova podjela, te Zidovi apstrakcije, ili slojeva apstrakcije ako ćete, su super moćni, jer posebno za veće, složenijih programa i sustava, to vam se više ljudi za izgradnju stvari zajedno, i na kraju bod svoj rad zajedno na ovaj način. Ali, naravno, mi potrebno je odmah popraviti kašalj. Moramo reći kašalj da, hej, znaš što? Ti si idući u morati uzeti input-- pa nije praznina, nego int i sada. Idemo naprijed i staviti u kašalj int. ja dobiva nula. 

je i manje od koliko puta. rekao sam tri prije. Ali to nije ono što želim. Želim da kašlje da se generalizirati na podržavaju bilo koji broj ponavljanja. 

Pa, zapravo, to je n da želim, što god se korisnik mi govori. Sada, mogu ići naprijed i reći ispisa kašalj. I bez obzira što je broj korisnik prolazi, Ja ću ponoviti da je mnogo puta. 

Tako da je na kraju krajeva, Program je identičan. Ali primijetiti sve ove stvari čak mogao biti u nekoj drugoj datoteci. Zapravo, ne znam Na trenutak kako printf provodi. 

Ne znam u ovom trenutku kako doći string, ili se int, ili se plovak provode. A ja ne želim vidjeti ih na mom ekranu. Kao što je, ja sam počinju da se usredotočite na moj program, a ne te funkcije. 

I tako, doista, čim početi faktoring kod kao što je ovo, bismo mogli ni pomaknuti kašalj u zasebnu datoteku? Netko drugi bi mogao provesti. I vi i vaš program postati vrlo lijepa i vrlo čitljiv, vjerojatno, zapravo četiri Program crta upravo tamo. 

Dakle idemo naprijed sada i napraviti još jednu promjenu. Uočite da je moj prototip mora promijeniti do vrha. Pa neka mi riješili to tako Ja ne bi vikao na. 

Provjerite kašalj, neka mi pokrenuti kašalj jednom više, još uvijek radi istu stvar. Ali sada, primijetit ćemo imati sastojak za jednu konačnu verziju. Znaš što? Ne želim da se samo kašalj, nužno. Želim imati nešto općenitije. Dakle, znate što? Želim to učiniti. Želim imati, baš kao i ispočetka ne, pravo glasa blok, ali ne samo reći nešto malo više puta. Želim reći vrlo specifičan niz. I, dakle, ne znam želite da se samo reći kašalj. Želim reći što god Niz je prošao u. 

Dakle primjetiti, ja sam generalizirati to tako da je sada recimo osjeća kao dobro ime za to, kao što su grebanje, traje dva argumenta, za razliku od nule. Jedan od njih je niz. Jedan od njih je int. 

I da ih mogu prebaciti. Samo sam vrsta kao ideju kažu string, a zatim koliko puta kasnije. Void je znači još ne vraća se ništa. To su samo vizualna strana učinci, kao što je s [? Jordan?] verbalno nuspojava deranja. Još uvijek se nešto n puta, 0 do, ali ne i jednako br. To znači da ukupna n puta. I onda samo isprintati što god da je struna. Tako sam zapravo generalizirati ova linija koda. Tako sada, kako mogu implementirati funkcija kašalj? 

Ja mogu učiniti void kašalj. A ja još uvijek mogu uzeti u tome mnogo puta želite kašalj. Ali znate što? Ja sada mogu čamac za reći. 

Mogu nazvati reći s Riječ kašalj, prolaze u n. A ako želim provesti i, samo za zabavu, A kihanje funkcija, Mogu kihanje neki broj puta. I ja mogu držati ponovnog n, jer primijetiti da m u ovom kontekstu ili opseg postoji samo unutar ove funkcije. 

I n u ovom kontekstu samo postoji unutar ove funkcije ovdje. Dakle, mi ćemo se vratiti ta pitanja opsega. I ovdje, ja sam samo htio reći, achoo, a zatim n puta, točka-zarez. 

A sada, ja samo trebate posuditi one u službi potpisa ovdje. Dakle, kašalj je ispravan. Praznina kihanje je sada točno. 

I još uvijek samo trebate reći. Zato ću reći, recimo string s, int n, točka-zarez. Tako sam pretjerano projektirana pakao iz ovog programa. 

I to ne znači to je ono što bi trebalo učiniti prilikom pisanja čak i najjednostavniji programa. Uzmi nešto što je očito stvarno jednostavan, jako kratko, i ponovno provesti ga koristeći način previše koda. No, što zapravo ćete vidjeti, a Vrijeme osvrnuti na ovim primjerima, i shvatiti, oh, to su koraci uzeli smo zapravo generalizirati, da faktor nešto, sve dok se na kraju dan moj broj je zapravo prilično razumno. Jer ako želim kašalj tri puta onda kihanje tri puta, Ja sam jednostavno ide na ponoviti to, Program čine kašalj, i pokrenuti kašalj. A ja imam tri kašalj i tri kiše. 

I tako to je osnovni paradigma, ako će, za kako bismo mogli ići o zapravo provodi program. Ali neka je samo vidjeti sad što je to smo radili sve ovo vrijeme, i što neki od završnih komada Iza ovog jednostavnog naredbe. Na kraju krajeva, mi smo Koristim zveket kao naš prevodilac. Mi smo pisali izvor kod, pretvoriti ga putem jeka u strojni kod. 

I mi smo koristili napraviti samo kako bi se olakšalo naše tipke tako da ne moramo zapamtiti ti vračanja sama jeka. No, ono što je napraviti zapravo radi? I, s druge strane, što je Jeka zapravo radi? 

Ispada, iako smo pojednostavljeno današnja rasprava govoreći: što se izvorni kod, prođe ga kao ulaz za prevodilac, koji vam daje izlaz stroja kod, ispada da postoji nekoliko različitih koraka tamo. I sastavljanje se događa da se krovna izraz za cijela hrpa koraka. Ali neka je samo zafrkavati ovo jako brzo. 

Ispada da smo radili više stvari svaki put kad sam pokrenuti program, ili svaki put kad sam sastaviti program danas. Dakle, predobrada se odnosi na učinimo ništa u C programu, kao što ćemo vidjeti opet i opet, koji počinje s ovim hash simbolom, ili hashtag simbol ovdje, znači to je Preprocessoru direktiva. To znači, u tom slučaju, ej računalo, učiniti nešto s tom datotekom prije nego što zapravo sastaviti svoj vlastiti kod. 

U ovom slučaju, hash uključuju jest u biti, C način da se kaže, hej računalo, ići dobiti sadržaj od CS50.h i zalijepite ih ovdje. Hej računalo, ići dobiti Sadržaj standardnog IO.h, gdje god da se nalazi na hard disk, zalijepite ga ovdje. Dakle, te stvari dogoditi Prvi tijekom predobradi. 

I zveket se sve to za nas. I to ga čini tako prokleto brzo, ti uopće ne vidi četiri različita stvari događa. Ali to je prvi takav korak. 

Što se zapravo događa sljedeće? Pa, sljedeći službeni korak je sastavljanje. I ispada da sastavljanju programa tehnički znači da ide od izvorni kod, ono mi smo piše danas, u nešto zove montaže kod, nešto da izgleda malo drugačije. 

A, u stvari, možemo vidjeti vrlo brzo. Dopustite mi zapravo ide u moj IDE. Pusti me naprijed i otvoren hello.c, što je prvi program s kojim smo počela je danas. I neka mi ići naprijed i pokrenuti zveket A malo drugačije, zveket-s, hello.c, što se zapravo događa na daj mi neku drugu datoteku hello.s. 

A mi ćemo vjerojatno nikada opet vidjeti ovu vrstu koda. Ako uzmete nižu razinu Sustavi klase poput CS61, vidjet ćete puno više ove vrste koda. No, to je zbirni jezik. To je X86 zbirni jezik da CPU koji je u podlozi CS50 IDE zapravo ne razumije. 

I grobni kao što to radi gledaj, to je nešto računalo razumije prilično dobro. Pod q, ovo je oduzimati. Postoji pokreta. 

Postoji zove funkcija ovdje x oring, pokret, dodatak, pop, povratak. Dakle, postoji neki vrlo Upute za niske razine da CPU razumjeti da aludirao sam ranije. To je ono što Intel Inside. 

Postoje obrasci nula i jedinica koje preslikati na njih arcanely sročeni, ali nešto dobro imenovan, upute, da se tako izrazim. To je ono što se događa kada sastaviti svoj kôd. Možete dobiti montaža jezik iz nje, što znači treći korak je okupiti da se kod montaže kod u konačnici, stroj code-- nula i jedinica, a ne tekst koji smo upravo vidjeli maloprije. 

Dakle, predobrada to naći i zamijeniti, i nekoliko drugih stvari. Sastavljanju uzima svoj izvor broj od C, izvorni kod koje smo pisali, do montaže kod koje smo upravo je pogledao. Montaža traje taj sklop kod za nula i jedinica da CPU stvarno hoće razumjeti na kraju dana. A povezivanje je posljednji korak što se događa za us-- opet, tako brzo da uopće ne notice-- da kaže, hej računalo, uzmi sve nula i one koje rezultat prikupljanja Davidovu kod, a njegova glavna funkcija je u ovom slučaju. 

I hej računalo, ići dobiti sve nula i jedinica da je osoblje CS50 napisao unutar CS50 knjižnici. Pomiješajte one se u Davida. I hej računalo, ići dobiti sve nule i one koje je netko drugi pisao godina Prije za printf. I dodati one Into the Cijela stvar, tako da imamo dobio moj nula i jedinica, The CS50 osoblja nula i jedinica, u printf nula i jedinica, i sve ostalo što koristite. 

Svi su se u kombinaciji zajedno u jedan Program se zove, u ovom slučaju, zdravo. Dakle, od sada, mi ćemo jednostavno koristiti sastavljanje riječi. A mi ćemo uzeti zdravo za gotovo da kada kažemo, sastaviti svoj program, to znači, hej obaviti pred-obradu, montažu i povezivanje. No, tu je zapravo neki sočan stvari tamo događa ispod haube. A pogotovo ako dobiti znatiželjan neko vrijeme, možete početi poking oko sebe na ovoj nižoj razini. No, za sada, neće shvatiti među takeaways za danas sasvim jednostavno početak procesa, uzimajući sviđa nešto kao zdravo svijetu. Doista, većina onoga što smo učinili danas sigurno neće potonuti u super brzo. I to će potrajati neko put, a neki praksa. A izgledi su, od vas će sortirati od žele pogoditi tipkovnicu ili vikati na ekranu. I sve to je u redu. Iako, možda i pokušajte da ne to učiniti u knjižnici toliko. 

I na kraju, vi ćete biti u mogućnosti da, za početak gledajući uzorke, kako u dobrim koda koje ste napisali i grešaka da ste napravili. I baš kao proces postaje TF ili CA je kao, vi ćete početi da se bolje i bolje vide te obrasce, i samo rješavanje vašeg vlastiti problemi u konačnici. U međuvremenu, tu će biti dosta nas posuditi vam podršku, i dobiti kroz ovo. A u članke za sve probleme ćete biti vođeni kroz sve naredbe da ja sigurno znam iz puno prakse do sada, ali možda su letjeli nad glavom za sada. I to je sasvim u redu. 

No, u konačnici, idete početi pojavljivanje uzoraka. I nakon što se posljednjih sve od glupe detalje, kao što su zagrade, i vitičastim zagradama, a točkom sa zarezom, i stvari, iskreno, to uopće nije intelektualno zanimljiv. I to nije cilj uzimanje bilo uvodnom klase. To su ideje koje će važno. 

To je petlje i uvjeti i funkcije, i snažnije apstrakcija, i faktoring koda, i dobar dizajn, a dobro stil, i na kraju ispravnost svog koda, to je u konačnici će najviše smeta. Dakle, sljedeći tjedan ćemo uzeti ove ideje koje smo prvi put vidjeli u nule a sada su prevedene do C. A mi ćemo početi predstaviti prvi od Naravno u stvarnom svijetu domene. 

Mi ćemo se usredotočiti na svijetu sigurnosti, točnije kriptografija, umjetnost remećenje informacije. A među prvima Problemi vi sami dobit će pisati dalje igranje s nekim od sintakse i rješavanju nekih logično problemi, u konačnici ne zadugo, zapravo otimati, ili šifriranje, i na kraju dešifriranje podataka. I sve što smo učinili Danas će prilično niska razina, samo će omogućiti nam da se jedan, i jedan, i još jedan korak naprijed ka pisanje najzanimljiviji kod gostiju. 

Dakle, više na taj sljedeći tjedan. 

[VIDEO PLAYBACK] 

Što mi možete reći o zadnji put kad ga je vidjela? Što mogu reći, stvarno? Mislim, to je kao i svaki drugi pre-proizvodnja proba osim što je nešto rekao na samom kraju da zaglavi sa mnom. 

-Ovo Je CS50. 

-To Je cut svima, velik posao na probi. 

-To Je ručak? 

Da, ti i ja mogu zgrabite sendvič malo. Pusti me samo ispitati s David jako brzo. David? David? 

[END PLAYBACK] 