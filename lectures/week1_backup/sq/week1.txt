[MUSIC Duke luajtur] DAVID J. Malan: Në rregull, kjo është CS50. Dhe kjo është një javë. Pra, kujtojnë se herën e fundit në javë zero, ne u përqendruam në të menduarit kompjuterike. Dhe ne kaloi nga ajo për Scratch, një programimit grafike Gjuha nga miqtë tanë në Media Lab MIT. 

Dhe me Scratch, e kemi shqyrtuar ide si funksionon, dhe kushtet, dhe unazore, dhe ndryshoret, dhe madje edhe ngjarjet dhe temat, dhe më shumë. Dhe sot, ne do të vazhdoni të përdorni këto ide, dhe me të vërtetë duke marrë ata për dhënë, por t'i përkthejnë në një gjuhë tjetër të njohur si C. tani, C është një gjuhë më tradicionale. Kjo është një nivel më të ulët gjuha, nëse ju do. 

Është thjesht tekstuale. Dhe kështu në shikim të parë, është e të gjithë do të shikojnë në vend i fshehtë në qoftë se ju nuk keni programuar më parë. Ne do të kemi gjysmë-colons, dhe kllapa, dhe formatimin e teksteve kaçurrel, dhe më shumë. Por e kuptojnë se edhe pse Sintaksa është gati duket pak panjohura për shumicën prej jush, të parë e kaluara se. Dhe të përpiqen për të parë idetë që janë, në të vërtetë, të njohur, sepse këtu në javë një që ne do të fillojmë të bëjmë është për të krahasuar, fillimisht, Scratch kundrejt C. 

Kështu, për shembull, kujtojmë se kur ne zbatuar i pari programet tona Herën e fundit, kemi pasur një bllok që dukej një diçka të vogël si this-- kur është flamuri gjelbër klikuar, dhe pastaj kemi pasur një copë ose më shumë mister poshtë saj, në këtë rast, thonë, Hello World. Pra, në të vërtetë, në Scratch, kur unë klikoni atë flamur të gjelbër për të drejtuar programin tim, kështu që për të folur, këto janë blloqet që të ekzekutohen, ose të kandidojë. Dhe, në veçanti, Scratch tha: hello, bota. 

Tani, unë mund të ketë specifikuar fjalë të ndryshme këtu. Por ne do të shohim se, në të vërtetë, shumë nga këto blocks-- dhe në të vërtetë, në C shumë functions-- mund të jetë parametrized ose përshtatur për të bërë gjëra të ndryshme. Në fakt, në qoftë se ne C doni të konvertohet, tani, ky program Scratch në këtë gjuhë tjetër, ne jemi duke shkuar për të shkruar një pak diçka si kjo. 

Dhënë, ka disa të panjohura Sintaksa ka shumë të ngjarë, int, dhe kllapa, dhe e pavlefshme. Por printf-- edhe pse ju do të mendoj se kjo do të jetë vetëm të shtypura. Por print do të thotë të shtypura formatuar, si ne do të shohim së shpejti. Kjo fjalë për fjalë do të shtypura në ekran çfarëdo është brenda këtyre kllapa, e cila natyrisht në këtë rast është, Hello World. 

Por ju do të vëreni disa të tjera Sintaksa, disa citate të dyfishtë, që kllapa në fund, gjysmë-zorrë e trashë dhe si. Pra, ka pak e lart, kështu që të flasin, të dy cognitively dhe sintaksore, që ne jemi duke shkuar që duhet të mbani mend para se të gjatë. Por e kuptojnë se me praktikën, kjo do të fillojnë të hidhen jashtë në ju. 

Në fakt, le të përqëndrohet në se një Funksioni specifically-- në këtë rast, thonë hello botë. Pra, thonë se është funksioni. Tungjatjeta botë është parametër i saj, ose argumenti, customization e saj. 

Dhe ekuivalenca në C është vetëm do të jetë këtë një linjë këtu, ku printf është ekuivalente me, të themi, string dyfishtë cituar, përshëndetje bota është e barabartë, sigurisht, për çfarë është në kutinë e bardhë atje. Dhe backslash n, edhe pse pak çuditshme dhe mungon nga e para, thjesht do të ketë efekt ne do të shohim në një kompjuter, si Mac tim ose një PC, i vetëm duke lëvizur kursorin në rreshtin tjetër. Është si të goditur Enter në tastierën tuaj. 

Pra, ne do të shohim se një herë para se të gjatë. Por së pari, le të marrin një vështrim në këtë Shembulli tjetër në rastin e sythe. Ne kishim këtë përgjithmonë lak për herë të fundit, e cila ishte një seri e copa puzzle që bëri diçka fjalë për fjalë për gjithnjë në këtë rast, thonë, Hello World, Hello World, Hello World, Hello World. Pra, kjo është një loop pafund me dashje. 

Në C, në qoftë se ne duam të zbatojë këtë njëjtën ide, ne mund thjesht të bëjë këtë. Ndërsa e vërtetë, printf përshëndetje world-- tani ndërsa, vetëm semantike, lloji i zgjon idenë e bërë diçka përsëri, dhe përsëri, dhe përsëri, dhe për sa kohë? E pra, kujtojnë se true-- e vërtetë është vetëm në ose një. 

Dhe e vërtetë është, sigurisht, gjithmonë e vërtetë. Pra, kjo është lloj i një pakuptimtë Deklarata e vetëm për të thënë të vërtetë. Por në të vërtetë, kjo është e qëllimshme, sepse në qoftë se e vërtetë është vetëm gjithmonë e vërtetë, se ndërsa e vërtetë vetëm do të thotë, në qoftë se një pak në mënyrë të tërthortë, se linjat e mëposhtme të kodit në mes të këtyre formatimin e teksteve kaçurrel duhet vetëm të ekzekutojë përsëri, dhe përsëri, dhe përsëri, dhe në fakt nuk ndalet. 

Por në qoftë se ju doni tuaj loop për të ndaluar, si ne e bëri për herë të fundit me diçka si këtë, të përsëritur e mëposhtme 50 herë, në C ne mund të bëjmë të njëjtën gjë me atë që e quajtur një për loop-- fjalen mos qenë ndërkohë, por për. Dhe pastaj ne kemi një sintaksë të re këtu, me int i barabartë me 0, i më pak se 50, i ++. Dhe ne do të kthehen në atë. Por kjo është vetëm se si ne do përkthejnë grup të blloqeve Scratch për një grup të linjave C të kodit. 

Ndërkohë, e konsiderojnë variablat. Dhe, në fakt, ne vetëm pa një një moment më parë. Dhe në rastin e Scratch, nëse ne donte të deklarojë një ndryshore të quajtur I për të qenë i numër i plotë, vetëm një numër, dhe ne duam të vendosur atë në një vlerë, ne do të përdorim këtë portokalli bllokojnë here-- vendosur i të 0. 

Dhe ne do të shohim sot dhe më tej, ashtu si javën e kaluar, programuesit bëjnë pothuajse gjithmonë të fillojë numërimi nga zero, me të vërtetë nga Konventa. Por edhe për shkak kujtojnë nga Diskutimi ynë i binar, numri më i vogël ju mund të përfaqësuar me ndonjë numër të bit është vetëm do të jetë 0. vetë. Dhe kështu që ne do të në përgjithësi të fillojë fillimin edhe variablat tona në 0. 

Dhe në C për të bërë të njëjtën gjë, ne jemi duke shkuar për të thënë int për numër të plotë, i vetëm nga konventa. Unë mund të ketë quajtur këtë variabël çdo gjë që unë dua, ashtu si në Scratch. Dhe pastaj është e barabartë me 0 vetëm cakton vlera 0 nga e drejta dhe e vë atë në ndryshore, ose enë magazinimit atje, në të majtë. Dhe gjysmë-zorrës së trashë si ne do të see-- dhe ne kemi parë disa nga këto already-- thjesht do të thotë fundin e mendimit. Të vazhdojë për të bërë diçka tjetër në linjat që pasojnë. 

Tani, ajo që për shprehje Boolean? Kujtojnë se në Scratch, këto ishin shprehje që janë ose të vërteta ose pyetje false--, me të vërtetë, se janë ose të vërteta apo të rreme. Pra, në rastin e Scratch, ne fuqi një pyetje të thjeshtë si kjo, është i më pak se 50? Kaq i, një herë, eshte nje numer i plote. Ndoshta ne jemi duke e përdorur atë në një program Scratch të mbajnë gjurmët e një rezultat ose diçka të tillë. Pra, kjo Sintaksa këtu në Scratch thjesht do të thotë, është i më pak se 50? Well, fatmirësisht, diçka është e thjeshtë në C. Dhe për të përkthyer, kjo ne thjesht do të thonë se unë më pak shumë se 50, duke përdorur butonin njohur në tastierën tuaj. 

Ndërkohë, në qoftë se ju të kërkuar për të thoni diçka më të përgjithshme, si, dhe, është më pak se x y ku çdo e x dhe y janë vetë variablat? Ne mund të bëjmë të njëjtën gjë në C, për aq kohë sa ne kemi krijuar këto variabla tashmë. Dhe ne do të shohim se si për të bërë këtë para se të gjatë. Ne thjesht do të thotë më pak se x y. 

Pra, ju jeni duke filluar të shohim disa ngjashmëri. Dhe ata folks që kanë bërë Scratch ishin të frymëzuar nga disa nga këto ide themelore. Dhe ju do të shihni këtë lloj sintakse në shumë languages-- jo vetëm Scratch, nuk vetëm C, por Python, dhe JavaScript, dhe gjuhë të tjera ende. 

Le të konsiderojmë një konstrukt nga C, nocioni i një gjendje, duke bërë diçka me kusht. Nëse diçka është e vërtetë, e bëjnë këtë. Nëse diçka tjetër është e vërtetë, të bëjë atë. Kjo është lloj i programimit ekuivalent i një pirun në rrugë. Ndoshta kjo është një dy rrugë pirun, një tre-palësh pirun, ose më shumë. Dhe në Scratch, ne mund të kemi parë diçka si kjo. 

Pra, kjo është një e madhe. Por e konsiderojnë relative Thjeshtësia e logjikës. Nëse x është më pak se y, atëherë thonë se x është më pak sesa y, përndryshe nëse x është më e madhe se y, pastaj të thotë x është më e madhe se y. Dhe pastaj, logjikisht, nëse mendoni përsëri në Scratch ose vetëm vetë intuita juaj njerëzore, dhe, nëse x nuk është më i madh se y, dhe x është jo më pak se y, pastaj sigurisht x do të jenë të barabartë me y. Pra, në këtë rast, duke shturë ato blloqe Scratch, mund të arrijmë një tre Mënyra pirun në rrugë? 

Ndërkohë, në qoftë se ne duam të bëni këtë në C, ajo ndoshta duket një simpler-- të vogël të paktën sapo ju të merrni njohur me sintaksë. Nëse x është më pak se y, printf x është më pak se y. Përndryshe nëse x është më e madhe se y, printf x është më e madhe se y. Else printf x është e barabartë me y-- dhe, përsëri, me ato backslash përfundon vetëm për ato linja të reja në mënyrë që nëse ju në fakt u zhvillua këtë lloj të programit ajo vetëm do të lëvizë kursori juaj në fund të fundit në linjë tjetër të ekranit. 

Tani, ndërkohë Scratch kishte të tjera karakteristika më të sofistikuara, vetëm disa prej të cilave ne do të fillimisht të shkojë mbi në botën e C. Dhe një prej tyre ishte quajtur një listë në Scratch. Dhe kjo ishte një speciale lloji i variablit që lejuar ju për të ruajtur gjëra të shumta në atë përsëri, për të mbështetur, për të mbështetur, për të mbështetur. 

Në C, që nuk ka Listat, per se, por diçka që janë më të përgjithshme quajtur vargjeve, edhe pse ne do të kthehen më vonë këtë semestër për të kërkuar në diçka quajtur një listë, apo me të vërtetë një listë e lidhur. Por tani për tani, të afërt ekuivalente në C për ne do të jetë diçka quajtur një grup. Dhe një koleksion është thjesht një lloj i veçantë i variable që ju lejon të ruani të dhënat përsëri, për të mbështetur, për të mbështetur, për të pasme. 

Dhe, me të vërtetë, në Scratch, në qoftë se ne të kërkuar për të hyrë në elementi i parë i një grup ose një list-- dhe unë jam duke shkuar për të thirrur atë, nga konventës, argv, argumentit vektoriale, por më shumë në atë para se të gjatë. Nëse unë dua të të marrë në elementin e parë e argv, në botën e Scratch në të vërtetë ju bëni zakonisht fillojë numërimi nga 1. 

Dhe kështu që unë mund të merrni pika 1 të argv. Kjo është vetëm se si MIT zbatuar nocioni i listave. Por në C, unë jam duke shkuar për të më thjesht të them vetëm, argv, e cila përsëri është emri i tim list-- ose të jetë i qartë, një grup. Dhe në qoftë se unë dua të parë elemente, unë jam duke shkuar për të përdorur kllapa katrore, e cila ju mund të mos përdoret shpesh nën një tastierë. 

Por 0 thjesht do të thotë, të marrë më parë. Pra, në disa raste dhe si kalimin e kohës, ne jemi duke shkuar për të filluar për të parë këto dikotomi mes Scratch dhe C, ku Scratch përdor një të tillë. Ne në C përdorim 0 këtu. Por ju do të shihni shpejt sapo ju të kuptoni themelet e secilës gjuhë, që këto gjëra fillojnë të marrin të gjithë më njohur përmes praktikës dhe praktikës. 

Pra, le të shohim tani në fakt në një program. Këtu do të jetë i pari nga C tonë Kodi burim për programet e plotë. Dhe programi ne jemi duke shkuar të ofrojë për shqyrtim është ai që është ekuivalente për atë pjesë të mëparshëm Scratch. 

Kështu që këtu, ne kemi atë që e ndoshta program të thjeshtë C ju mund të shkruani se në fakt bën diçka. Tani, ne do të shikojmë të kaluarën, tani për tani, ka të përfshirë, io.h standarde, dhe këto kënd kllapa, dhe int, dhe e pavlefshme, dhe formatimin e teksteve kaçurrel, dhe të ngjashme. 

Dhe le të vetëm të përqëndrohet në ajo që, të paktën intuitive, mund të hidhen jashtë në ju tashmë. Në të vërtetë, kryesor, unë nuk domosdoshmërisht e di se çfarë është kjo, por ashtu si Scratch pasur se kur flamuri gjelbër klikuar pjesë mister, kështu që nuk C si një gjuhë programimi kanë një pjesë kryesore të kodit që merr ekzekutuar nga default. Dhe, me të vërtetë, ajo fjalë për fjalë do të quhet kryesore. 

Pra kryesor është një funksion. Dhe kjo është një funksion të veçantë që ekziston në C se kur ju drejtuar një program, është kryesore që merr të drejtuar nga default. Në botën e Scratch, kjo ishte zakonisht kur flamuri gjelbër klikuar se u drejtuar nga default. 

Ndërkohë, ne kemi parë këtë më parë, printf ose print formatuar, kjo është do të jetë një funksion që vjen me C, së bashku me një bandë e tërë e të tjerëve, se vullneti nga koha dhe koha përsëri, në mënyrë që të bëjë pikërisht si emrin e saj, shkruar diçka. Çfarë duam të shtypura? E pra, ne do të shohim se nga personazhet bashkëngjitur si these-- botë përshëndetje, backslash n në thonjëza dyshe, ne mund të them printf saktësisht çfarë duhet të shtypura në ekran. 

Por në mënyrë që të bëjë se, ne për fat të keq duhet të marrë diçka që është e tashmë të fshehtë për ne njerëzit, por të paktën kjo është disi readable-- mprehtë përfshijnë, io.h standarde, int, kryesore, e pavlefshme, printf, të gjitha të magjike yshtje ne vetëm e pa në ekran. Por ne fakt duhet të shkojnë më misterioze ende. Ne së pari duhet të përkthejnë kodin që kemi shkruar në kodin e makinës. Dhe kujtojnë nga java e fundit që makinat, të paktën ato që njeh këtu, ne fund te ditës vetëm kuptojnë zero dhe ato. 

Dhe Perëndia im, në qoftë se kemi pasur për të shkruar këto zero dhe ato që në fakt programi, kjo do shumë, shumë shpejt të marrë kënaqësi nga çdo gjë. Por kjo rezulton, në javën e kaluar, se këto modelet e zero dhe ato vetëm kanë domethënie të veçantë. Në kontekste të caktuara, ata mund të thotë numrat. 

Në disa kontekste, ata mund të thotë letra, ose ngjyra, apo ndonjë numër e abstraksioneve të tjera atje pas. Por ashtu si kompjuteri juaj ka një CPU, Central Processing Unit, apo truri brenda e kompjuterit tuaj. Kjo është zakonisht Intel brenda, sepse kjo është një nga kompanitë më të mëdha që e bën CPUs për kompjutera. 

E pra, CPU Intel dhe të tjerët thjesht kanë vendosur paraprakisht se disa modelet e zero dhe ato do të thotë gjëra të veçanta. Disa modelet e zero dhe ato do të thotë, të shtypura këtë në ekran, ose shtoni këto dy numra, ose zbres këto dy numra, apo veprim këtë pjesë të të dhënave nga memorie kompjuteri tim gjatë këtu, ose ndonjë numër të nivelit të tjerë shumë të ulët, por në fund të fundit e dobishme, operacionet. Por, fatmirësisht, ne njerëzit nuk janë duke shkuar që duhet të dini këtë nivel të detajuar. Në të vërtetë, ashtu si herën e fundit, ku ne përhumbur përsëri, dhe përsëri, dhe përsëri, Ndërtesa nga niveli shumë të ulët primitives si zero dhe ato të koncepteve të nivelit të lartë si numra dhe shkronja, dhe ngjyra, dhe më shumë, kështu që mund ne si programuesit qëndrojnë mbi supet e të tjerë që kanë ardhur para nesh dhe të përdorin softuer atë tjetrin njerëzit kanë shkruar para us-- përkatësisht programet e quajtur hartuesit. 

C është një gjuhë që është hartuar zakonisht, që do të thotë konvertuar nga Kodi burim për kodin e makinës. Në mënyrë të veçantë, çfarë do të thotë kjo është se në qoftë se ju keni marrë burim tuaj Kodi që ju vetë të shkruar, si ne së shpejti do të në një moment të vetëm në ekran, dhe ju doni për të kthyer atë në fund të fundit të makinës code-- ato zero dhe ato që vetëm Mac tuaj ose PC tuaj understands-- ju keni marrë një të parë ushqyer atë kod burim në si input për një të veçantë program të quajtur një përpilues, prodhimi i të cilave ne do të shohim është kodi makinë. Dhe, me të vërtetë, hera e fundit që kemi biseduar rreth, vërtetë, në fund të ditës, zgjidhjen e problemeve. Ju keni marrë inpute. Dhe ju keni marrë rezultatet. Dhe ju keni marrë disa lloj e algorithm në mes. 

Algoritmet me siguri mund të jetë zbatuar në software, siç e pamë me pseudokod javën e fundit dhe si ne do të shohim me kodin aktual këtë javë. Dhe kështu një përpilues të vërtetë vetëm ka një sërë algoritme brenda për atë që e di se si për të kthyer fjalë kyçe të veçanta, si kryesor, dhe printf, dhe të tjerët se ne vetëm pa në modelet e zero dhe ato që Intel brenda dhe të tjera të CPU në fakt e kupton. Pra, si mund ta bëjmë këtë? Ku nuk kemi marrë një përpilues? 

Shumica prej nesh këtu kanë një Mac apo PC. Dhe ju jeni duke Mac OS, ose Windows, ose Linux, Solaris, ose, ose ndonjë numër të tjera sistemeve operative. Dhe, me të vërtetë, ne mund të dalë mbi web dhe të shkarkoni një përpilues për Mac apo PC tuaj për sistemin tuaj operativ të veçantë. Por ne të gjithë do të jetë në Faqet e ndryshme, kështu që të flasin. Ne do të kemi pak konfigurime të ndryshme. Dhe gjërat nuk do të punojë gjithë të njëjtën gjë. Dhe, në të vërtetë, këto ditë shumë prej nesh nuk e përdorin software që shkon vetëm në laptopë tonë. Në vend të kësaj, ne përdorim diçka si një shfletues që na lejon për të hyrë në web-bazuar aplikacionet në cloud. Dhe më vonë këtë semestër, ne do të bëjmë pikërisht këtë. Ne do të shkruajnë aplikacione ose software jo duke përdorur code-- C, por gjuhë të tjera si Python dhe JavaScript-- që të kandidojë në re. 

Dhe për ta bërë këtë, ne vetë gjatë semestrit në fakt do të përdorë një re-bazuar Mjedisi i njohur si CS50 IDE. Kjo është një programimit web-bazuar mjedisit, ose zhvillimit të integruar Mjedisi, ide, që është ndërtuar në majë të disa software burim të hapur i quajtur Cloud 9. Dhe ne kemi bërë disa pedagogjike thjeshtëzime për të në mënyrë që për të fshehur veçoritë e caktuara në javëve të para që nuk kanë nevojë, pas së cilës ju mund të zbulojnë ato dhe të bëjë më të çdo gjë që ju doni me mjedisin. 

Dhe kjo na lejon, gjithashtu, të para-instaluar software të caktuara. Gjëra të tilla si një të ashtu-quajtur CS50 biblioteka, të cilat ne së shpejti do të shohim na jep në C me disa funksionalitetin shtesë. Pra, nëse ju shkoni në, në fund të fundit, CS50.io, ju do të nxitet për të hyrë brënda në, dhe një herë ju bëni dhe për të krijuar një llogari falas, ju do të jetë në gjendje për të hyrë në një mjedis që duket mjaft si kjo. 

Tani, kjo është në mënyrë të paracaktuar. Çdo gjë është e bukur dhe ndritshme në ekran. Shumë prej nesh kanë një zakon të duke punuar në pjesë që është CS50 mjaft në fund të natës. Dhe kështu disa nga ju mund të preferojnë të kthyer atë në mënyrë të natës, kështu që të flasin. 

Por, në fund të fundit, ajo që ju jeni do të shohim në CS50 IDE është tre areas-- dallueshme një zonë në të majtë ka ku dosjet tuaja do të jetë në cloud, një zonë në krye të drejtë ku kodi juaj do të jetë editable. Ju do të jetë në gjendje për të hapur tabs individuale për çdo program që ju të shkruani këtë semestër brenda e atij këndin e sipërm të djathtë. Dhe pastaj më arcanely, dhe ende të fuqishëm, do të jetë kjo gjë më së Fund i njohur si një dritare terminali. 

Kjo është një shkollë e vjetër Command Line Interface, ose CLI, që lejon ju për të ekzekutuar komandat në computer-- në këtë rast, kompjuter në cloud-- për të bërë gjëra të tilla si të përpilojnë kodin tuaj nga kodi burim në kodin e makinës, për të drejtuar programet tuaja, ose për të filluar tuaj web server, apo për të hyrë në bazën e të dhënave tuaja, dhe çdo numër të teknikave të tjera se ne do të fillojnë të përdorin para se të gjatë. Por për të arritur atje, ne jemi të do të ketë në fakt të shkoni në internet dhe të fillojnë të luajnë. Dhe për të bërë këtë, le të parë të fillojë ngatërresë me kryesore, dhe shkruani pjesën kryesore të programit. Dhe le të përdorim këtë funksion printf, të cilat ne kemi përdorur më parë, thjesht për të thënë diçka. 

Kështu që këtu unë jam tashmë në brendësi të CS50 IDE. Unë e kam regjistruar paraprakisht. Dhe unë e plotë shfaqet dritaren. Dhe kështu, në fund të fundit, ju edhe në problemet e ardhshme do të ndjekë hapat e të ngjashme që do të sigurojë dokumentacion në internet. Pra, ju nuk duhet të shqetësohen për thithjen çdo hap të vogël teknik që bëj unë sot këtu. 

Por ju do të merrni një ekran të tillë. Unë të ndodhë që të jetë në natën mode. Dhe ju mund të shndrit çdo gjë nga disabling mënyrën e natës. Dhe në fund të ditë, ju do të jeni për të parë këta të tre kryesore areas-- file shfletues në të majtë, skedat kodi deri krye, dhe dritarja terminal në fund. 

Më lejoni të shkojnë përpara dhe të shkruani programin tim të parë. Unë jam duke shkuar për të preemptively shkoni tek File, Ruaj, dhe për të shpëtuar fotografi tim si hello.c. Në të vërtetë, nga konventa, çdo ne program shkruaj që është shkruar në gjuhën C duhet të quhet diçka dot c, nga konventa. Kështu që unë jam duke shkuar për të përmendur atë hello.c, sepse Unë vetëm dua të them hello botë. Tani unë jam duke shkuar për të zmadhuar jashtë dhe klikoni Ruaj. Dhe të gjitha unë kam këtu tani është një tab në të cilën unë mund të filloni të shkruani kodin. 

Kjo nuk do të përpilojë. Kjo do të thotë asgjë. Dhe kështu që edhe në qoftë se unë konvertuar kjo me zero dhe ato, CPU do të ketë asnjë ide se çfarë po ndodh rreth e rrotull. Por në qoftë se unë shkruaj rreshta që përputhen me qenie conventions-- C-C, përsëri, kjo language-- me sintaksë si kjo, printf përshëndetje world-- dhe unë kam marrë të kënaqur me bërë këtë me kalimin e kohës. Kështu që unë nuk mendoj se kam bërë ndonjë gabim tipografike. 

Por, pa ndryshim, shumë të parë herë që të bëni këtë, ju do. Dhe atë që unë jam gati për të bërë fuqinë shumë edhe të mos punojnë për ju herë të parë. Dhe kjo është krejtësisht në rregull, sepse tani ju mund vetëm të shohim një të tërë shumë risi, por me kalimin e kohës një herë ju merrni të njohur me këtë mjedis, dhe kjo gjuhë, dhe të tjerët, ju do të fillojnë për të parë gjëra që janë ose të sakta apo të pasakta. 

Dhe kjo është ajo që e miqtë mësimdhënies dhe sigurisht asistentë të marrë aq i mirë në kalimin e kohës, është diktim gabime apo bugs në kodin tuaj. Por unë pretendojnë se ka ka mete në këtë kod. Kështu që unë tani dua të drejtuar këtë program. 

Tani në Mac tim apo PC, unë jam në zakoni i ikonave të dyfishtë klikuar kur unë dua të drejtuar ndonjë program. Por kjo nuk është modeli këtu. Në këtë mjedis, i cili është CS50 IDE. Ne jemi duke përdorur një operative sistem i quajtur Linux. Linux është e ngjashme me një tjetër sistem operativ, e njohur përgjithësisht si Unix. Dhe Linux është i njohur veçanërisht për të paturit e një Command Line Mjedisit, CLI. Tani, ne jemi duke përdorur një specifikë shije e Linux të quajtur Ubuntu. Dhe Ubuntu është thjesht një version i caktuar i Linux. 

Por këto Linux këto ditë të bëjë në fakt të vijë me ndërfaqe grafike të përdoruesit. Dhe ai që të ndodhë me të përdorur këtu është web-based. Pra, kjo mund të duket edhe një pak më ndryshe nga diçka ju vetë mund të ketë parë ose të kandidojë në të kaluarën. 

Kështu që unë jam duke shkuar për të shkuar përpara tani dhe të bëjë të mëposhtme. Unë e kam ruajtur këtë foto si hello.c. Unë jam duke shkuar për të shkuar përpara dhe të Lloji clanghello.c Pra tingëllimë për gjuhën C është një përpilues. Kjo është para-instaluar në CS50 IDE. Dhe ju mund të shkarkoni dhe absolutisht instaloni këtë në vetë Mac apo PC. 

Por, përsëri, ju nuk do të keni të gjitha para-konfigurimit bërë për ju. Kështu që tani për tani, unë jam vetëm do të kandidojë clanghello.c. Dhe tani vini re këtë sintaksë këtu do përfundimisht kuptojnë thjesht do të thotë se unë jam në një dosje apo directory quajtur Workspace. Kjo shenjë dollar është vetëm konventë për kuptimin, shkruani komandat tuaja këtu. 

Kjo është ajo që quhet një të shpejtë, vetëm nga konventa është shenjë dollar. Dhe kur të shkoj përpara tani dhe klikoni Shkruani, asgjë nuk duket të ketë ndodhur. Por kjo është në fakt një gjë e mirë. Sa më pak që ndodh në ekranin tuaj, më shumë të ngjarë Kodi juaj është që të jetë i saktë, paktën syntactically. 

Pra, nëse unë dua të drejtuar këtë program, çfarë të bëj? E pra, ajo rezulton se Emri i parazgjedhur nga konventa për programet kur ju nuk specifikon një përmendur për programi juaj është vetëm a.out. Dhe kjo sintaksë shumë, ju do të të marrë të njohur me para se të gjatë. 

Dot çaj thjesht do të thotë, hej, CS50 IDE, të drejtuar një program të quajtur a.out kjo është brenda directory time aktuale. Kjo do të thotë dot dosjen aktuale. Dhe ne do të shohim se çfarë sekuenca të tjera të tilla i karaktereve do të thotë para se të gjatë. 

Pra, këtu ne do të shkojmë, Shkruani, Hello World. Dhe ju do të vini re, se ajo që ndodhi? Jo vetëm që ajo të shtypura hello botë. Ajo gjithashtu e shtyu kursorin në rreshtin tjetër. 

Dhe pse ishte ajo? Cili ishte kodi që kemi shkruar më parë që siguroi se kursori do të shkojnë në linjë tjetër? Funny gjë në lidhje me a kompjuter është ajo është vetëm do për të bërë fjalë për fjalë atë që ju them se për të bërë. 

Pra, nëse ju them se për printf hello, presje, hapësira, bota, quote ngushtë, kjo është fjalë për fjalë vetëm do për të shtypur këto karaktere. Por kam pasur këtë karakter të veçantë në fund, risjell, backslash n. Dhe kjo është ajo që sigurohet se karakteri shkoi në linjë tjetër të ekranit. 

Në fakt, më lër të shkoj dhe të bëjë këtë. Më lejoni të shkojnë përpara dhe të fshini këtë. Tani, vini re se krye të ekranit tim ka një dritë të vogël të kuqe në tab treguar, hey, ju nuk keni ruajtur skedarin tuaj. Kështu që unë jam duke shkuar për të shkuar përpara me kontrollin S ose command S, ruani skedarin. Tani ajo goes-- shkoi për një të gjelbër moment--. Dhe tani është kthyer në vetëm duke qenë një ikonë të ngushtë. 

Nëse unë tani të drejtuar clanghello.c përsëri, Hyjnë, dot slash, a.out, Enter, ju do të shihni se ai ende ka punuar. Por kjo është ndoshta një buggy pak. Tani për tani, Workspace im prompt--, dhe pastaj se shenja e dollarit, dhe pastaj prompt-- im aktual është e gjitha në të njëjtën linjë. Pra, kjo sigurisht një bug estetike, edhe në qoftë se kjo nuk është me të vërtetë një bug logjike. 

Kështu që unë jam duke shkuar për të ndrequr atë që unë vetëm e bëri. Unë jam duke shkuar për përsëritje a.out. Njoftim Kam shtuar newline karakter mbrapa. Unë e kam ruajtur file. 

Kështu që unë jam duke shkuar për përsëritje a.out, and-- Dammit, një bug, një bug që do të thotë gabim. Pra, bug është se edhe pse I shtoi backslash n atje, ri-ruajtur, ri-u e programit, sjellja ishte i njëjtë. Pse është kjo? 

Unë jam i humbur një hap, apo jo? Ky hap i rëndësishëm më parë ishte se ju keni to-- kur ju të ndryshojë kodin tuaj burim, rezulton të kandidojë ajo përmes përpiluesit përsëri kështu që ju merrni kodin e ri makinë. Dhe kodi makine, e zero dhe ato, do të jenë pothuajse identike, por jo në mënyrë të përkryer kështu, sepse ne kemi nevojë, sigurisht, që linja e re. 

Pra, për të rregulluar këtë, unë do të duhet për përsëritje clanghello.c, shkruani, dot çaj, a.out. Dhe tani, Hello World është kthyer ku unë pres që ajo të jetë. Pra, kjo është e gjitha mirë dhe të mirë. Por a.out është një emër mjaft i trashë për një program, edhe pse kjo ndodh që të jetë, për arsye historike, default-- të thotë rezultatet e kuvendit. 

Por më lejoni të shkoj përpara këtu dhe e bëjnë këtë në mënyra të ndryshme. Dua programin tim Hello World që në fakt do të quhet përshëndetje. Pra, nëse do të ishte një ikonë të mia desktop, ajo nuk do të a.out. Ajo do të quhet përshëndetje. 

Pra, për të bërë këtë, ajo rezulton se tingëllimë, si shumë programe, mbështet argumente command line, ose flamuj, apo çelsin, që thjesht ndikojnë sjelljen e saj. Në mënyrë të veçantë, tingëllimë mbështet një dash o Flamuri, i cili pastaj merr një fjalë të dytë. Në këtë rast, unë do të në mënyrë arbitrare, por në mënyrë të arsyeshme, e quajti atë përshëndetje. Por unë mund të telefononi atë gjë Dua, përveç a.out, e cila do të jetë mjaft përveç pikë. 

Dhe pastaj vetëm të specifikojë emrin e dosjes unë dua për të hartuar. Deri tani, edhe pse në fillim e komandës unë ende kanë tingëllimë, ne fund te komandën Unë ende kanë emrin e skedarit, Unë tani kanë këto command line argumente, këto flamuj që janë duke thënë, oh, nga rruga, output-o, një fotografi quajtur hello, jo a.out default. 

Pra, nëse unë hit Enter tani, asgjë duket se ka ndodhur. Dhe, megjithatë, tani unë mund të bëj dot plagë përshëndetje. Kështu që është e njëjtë program. Të zero dhe ato janë identike në fund të ditë. 

Por ata janë në dy a.out ndryshme files--, që është version parë dhe vetëm quajtur pa mend, dhe tani hello, e cila është shumë më e më Emri bindëse për një program. Por, sinqerisht, unë nuk jam do të mbani mend këtë përsëri, dhe përsëri, dhe përsëri. Dhe, në të vërtetë, siç e kemi shkruar Programet më të komplikuara, komandat ju jeni do të duhet për të shkruar do të merrni edhe më e komplikuar akoma. 

Dhe kështu jo për t'u shqetësuar. Ajo rezulton se njerëzit para na kanë kuptuar ata too kishte këtë të njëjtin problem saktë. Edhe ata nuk gëzojnë të paturit të lloji mjaft të gjatë, komandat misterioze, e lëre më mbani mend ato. Dhe kështu njerëzit para nesh kanë bërë programe të tjera që e bëjnë më të lehtë për hartimin e software tuaj. 

Dhe, me të vërtetë, një të tillë Programi quhet Bëni. Kështu që unë jam duke shkuar për të shkuar përpara dhe të bëjë këtë. Unë jam duke shkuar për të ndrequr çdo gjë që unë vetëm e bëri në mënyrën e mëposhtme. Më lejoni të tipit LS. Dhe ju do të vëreni tre things-- a.out, dhe një yll, përshëndetje dhe një yll, dhe hello.c. Shpresojmë, ky duhet të të jetë pak intuitive, aq sa më parë kishte asgjë në këtë hapësirë ​​pune. Nuk kishte asgjë që kam pasur krijuar deri sa kemi filluar klasë. 

Dhe kam krijuar hello.c. Unë pastaj hartuar atë, dhe e quajti atë a.out. Dhe atëherë unë hartuar atë përsëri pak ndryshe dhe e quajti atë përshëndetje. Pra, unë kam tre fotografi në këtë directory, në këtë dosje të quajtur Workspace. Tani, unë mund të shoh se si në qoftë se unë zvogëluar në fakt. 

Nëse unë zvogëluar këtu dhe shikoni në atë anën e sipërm të djathtë qoshe, siç është premtuar të majtë Ana dora e ekranit tuaj është gjithmonë do të ju tregojnë se çfarë është në llogarinë tuaj, çfarë është brenda CS50 IDE. Dhe nuk ka tre fotografi atje. 

Kështu që unë dua të shpëtoj prej a.out dhe përshëndetje. Dhe si ju mund të imagjinoni intuitive, ju mund të lloj të kontrollit klik ose right click mbi këtë. Dhe kjo menu pak pops up. Ju mund të shkarkoni skedarin, të drejtuar ajo, preview atë, refresh, riemërtoj, apo çfarë jo. 

Dhe unë mund vetëm të fshini, dhe ajo do të shkojë larg. Por le të bëjë gjëra me një komandë Linja tani për tani, në mënyrë që të merrni të rehatshme me këtë, dhe të bëjë të mëposhtme. Unë jam duke shkuar për të shkuar përpara dhe për të hequr a.out nga shtypja fjalë për fjalë rma.out. Ajo rezulton, urdhrin për heqjen ose fshirë diçka, nuk është hequr apo fshij. 

Është më shumë shkurtimisht RM, vetëm për të kursyer ju disa tasteve, dhe hit Enter. Tani ne do të jetë disi cryptically hequr a.out rregullt file. Unë vërtetë nuk e di se çfarë një fotografi të parregullt do të jetë ende. Por unë dua për të hequr atë. 

Kështu që unë jam duke shkuar për të tipit Y për Po. Ose unë mund të shkruani atë jashtë, dhe hit Enter. Dhe, përsëri, asgjë nuk duket të ndodhë. Por kjo është, në përgjithësi, një gjë e mirë. 

Në qoftë se unë lloji LS këtë herë, çfarë duhet të shoh? Shpresojmë, vetëm përshëndetje dhe hello.c. Tani, si një mënjanë, ju do të vini re këtë yll, yll, kjo është në fund të programeve të mia. Dhe ata janë gjithashtu duke treguar deri në të gjelbër. Kjo është vetëm mënyrë CS50 IDE-së e cluing ju në faktin se kjo nuk është kodi burim. Kjo është një ekzekutues, një runnable program që ju në fakt mund të kandidojë duke bërë dot plagë, dhe atëherë është emri. 

Tani, më lejoni të shkojnë përpara dhe për të hequr kjo, rm hello, Shkruani, hiqni rregullt paraqesë hello, po. Dhe tani, nëse unë lloji LS, ne jemi kthyer në hello.c. Mundohuni të mos fshini tuaj Kodi aktual burimi. Edhe pse ka karakteristika ndërtuar në CS50 IDE ku ju mund të shkoni nëpër historinë tuaj rishikim dhe rewind në kohë, nëse ju aksidentalisht fshini diçka, të bëjë të jemi të ndërgjegjshëm sipas këtyre promptet po ose jo, për atë që ju në të vërtetë doni të bëni. Dhe kur të shkoj deri në krye la qoshe dorën këtu, të gjitha që mbetet është hello.c. Pra, ka bunches e komandat e tjera që mund të ekzekutojë në botën e Linux, njëra prej të cilave është, përsëri, Për të bërë. Dhe ne jemi duke shkuar për të bërë programi im tani si më poshtë. 

Në vend të bërë tingëllim, në vend të bërë tingëllimë-o, Unë do të thjesht fjalë për fjalë të tipit, të bëjë përshëndetje. Dhe tani vini re, unë jam Nuk shtypja bëjnë hello.c. Unë jam i shtypur bërë përshëndetje. 

Dhe ky program Sigurohuni që vjen me IDE CS50, dhe më shumë në përgjithësi me Linux, është një program që është duke shkuar për të bërë një program të quajtur Përshëndetje. Dhe ajo do të marrë, me konventë, se në qoftë se ky program mund të bëhet, ajo do të jetë bërë nga një burim Kodi Dosja përfundon në dot c, hello.c. 

Pra, nëse unë hit Enter tani, njoftim që komanda që merr ekzekutohet është në fakt edhe më gjatë para se më parë. Dhe kjo është për shkak se ne kemi preconfigured CS50 IDE që të ketë disa karakteristika të tjera të ndërtuara në atë ne nuk kemi nevojë vetëm ende, por së shpejti do të. Por gjëja kryesore për të realizuar Tani unë kam një program Përshëndetje. 

Në qoftë se unë lloji LS përsëri, unë kanë një program Hello. Dhe unë mund të kandidojë atë me dot çaj a.out, jo, sepse të gjithë pika e kësaj Ushtrimi ishte dot përshëndetje plagë. Dhe tani kam programin tim përshëndetje botërore. Pra duke shkuar përpara, ne jemi pothuajse gjithmonë vetëm do të hartojnë programet tona Bëni përdorimin e komandës. Dhe atëherë ne jemi duke shkuar për të drejtuar ata nga dot çaj, dhe emri i programit. Por kuptojnë se çfarë është duke bërë Bëni për ju, a nuk është në vetvete një përpilues. Kjo është vetëm një program komoditet që e di se si për të shkaktuar një përpilues për të drejtuar në mënyrë që ju vetë mund ta përdorni atë. 

Çfarë komandat e tjera ekzistojnë në Linux, dhe nga ana tjetër CS50 IDE? Ne së shpejti do të shohim se ka një CD komandë, Ndryshimi Directory. Kjo ju lejon brenda Ndërfaqja juaj command line për të ecur përpara dhe prapa, dhe të hapur dosje të ndryshme pa përdorur miun. 

LS kemi parë, i cili qëndron për listën fotografi në dosjen aktuale. Bëni Dir, ju mund të ndoshta fillojnë të konkludoj ç'do të thotë kjo now-- bëjë directory, në qoftë se ju doni të krijoni një dosje. RM për hiqni, RM Dir për hequr directory-- dhe këto, përsëri, janë vija e komandës ekuivalentet e çfarë ju mund të bëjë në CS50 IDE me miun tuaj. Por ju do të gjeni së shpejti që ndonjëherë kjo është vetëm shumë më të shpejtë për të bërë gjëra me një tastierë, dhe në fund të fundit shumë më të fuqishme. 

Por është e vështirë për të argumentuar se çdo gjë që kemi bërë deri më tani është e gjitha që e fuqishme, kur të gjithë ne kemi qenë të thënë se është, Hello World. Dhe, në fakt, unë hardcoded fjalë përshëndetje botërore në programin tim. Nuk ka dinamizëm ende. Scratch ishte një urdhër të magnitudë më interesante javën e kaluar. 

Dhe kështu që le të merrni atje. Le të bëjmë një hap drejt që nga Mënyra e disa prej këtyre funksioneve. Pra, jo vetëm që e bën C vijnë me printf, dhe rrush të funksioneve të tjera disa prej të cilave ne do të shohim me kalimin e kohës, ajo nuk ka bëjnë të gjitha që lehtë të drejtë nga e portës në marrjen e të dhëna përdoruesi. 

Në fakt, një nga dobësitë e gjuhëve si C, dhe madje edhe të Java dhe ende tjerë, është se ajo nuk ka e bëjnë të lehtë për të marrë vetëm gjëra të tilla si integers nga përdoruesit, ose vargjet, fjalët, dhe frazat, le të vetëm gjëra të tilla si vlerat pikë, ose numrat e vërtetë lundrues me pikë dhjetore, dhe të vërtetë numrat e gjatë, si ne së shpejti do të shohim. Pra, kjo listë e funksioneve këtu, këto janë si pjesë të tjera puzzle Scratch se ne kemi para-instaluar në CS50 IDE që ne do të përdorim për disa javë si rrotat të trajnimit të llojeve dhe përfundimisht të marrë të tyre, dhe të kërkoni nën kapuç, ndoshta, në se si këto gjëra janë zbatuar. 

Por për të bërë këtë, le të në fakt të shkruar një program. Më lejoni të shkojnë përpara tani. Dhe unë jam duke shkuar për të krijuar një të ri fotografi duke klikuar këtë plus të vogël, dhe klikuar File ri. 

Unë jam duke shkuar për të shpëtuar këtë të ardhshëm një si, le të themi, string.c, sepse unë dua të luaj me vargjet. Dhe string në C është vetëm një sekuencë e karaktereve. Pra, tani le të shkojë përpara dhe të bëjë të mëposhtme. 

Përfshijnë standarde IO.h-- dhe rezulton IO standarde, IO thjesht do të thotë input dhe output. Pra, rezulton se kjo linjë këtu është se çfarë është na fqinje për të përdorur printf. Printf, natyrisht, prodhon dalje. Pra, në mënyrë që të përdorin printf, ajo kthehet se ju duhet të keni këtë linjë të kodit në krye të dosjes tuaj. 

Dhe ne do të kthehen në atë që që me të vërtetë do të thotë para se të gjatë. Ajo rezulton se në çdo program C unë shkruaj, Unë kam marrë për të filluar me Kodi që duket si kjo. Dhe ju do të vëreni CS50 IDE, dhe zhvillim tjetër i integruar mjedise si ai, do të përpiqemi sa më mirë ata mund të për të përfunduar mendimin tuaj. Në fakt, një moment më parë në qoftë se unë të prish atë që unë vetëm e bëri, unë hit Enter. 

Unë pastaj goditi kaçurrel hapur mbajtëse, hit Enter përsëri. Dhe kjo përfundoi mendimin tim. Ajo më dha një linjë të re, prerë jo më pak për arsye bukur stilistike ne do të shohim. Dhe pastaj ajo automatikisht dha mua që mbajtëse kaçurrel për të përfunduar mendimin tim. Tani, ajo nuk ka gjithmonë me mend se çfarë ju doni të bëni. Por në pjesën më të madhe, ajo ka ju kursejnë disa tasteve. Pra, një moment më parë, ne u këtë program-- hello, bota, dhe pastaj të hartuar atë, dhe pastaj vrapoi atë. Por nuk ka dinamizëm këtu. Po në qoftë se ne të kërkuar për të bëjë diçka të ndryshme? E pra, çfarë nëse kam kërkuar për të vërtetë të marrë një varg nga përdoruesit? Unë jam duke shkuar për të përdorur një pjesë mister quajtur pikërisht that-- merrni string. 

Rezulton në C se kur ju nuk doni për të siguruar të dhëna për një copë mister, ose më shumë si duhet në një funksion, ju fjalë për fjalë vetëm të bëjë kllapa hapur, kllapa të ngushtë. Pra, kjo është sikur nuk ka asnjë kuti e bardhë të tipit në. Blloku themi para kishte një kuti të vogël të bardhë. Ne nuk e kemi atë kuti e bardhë tani. 

Por, kur unë e quaj të marrë varg, I duan të vënë rezultatin diku. Pra, një paradigmë shumë të zakonshme në C është për të thërrasë një funksion, si get varg këtu, dhe pastaj të ruajtur vlerën e saj të kthimit. Kjo është rezultat i saj përpjekje në diçka. 

Dhe çfarë është ndërtuar në programimin, qoftë në Scratch, ose tashmë C, se ne mund të përdorni të vërtetë të ruajtur diçka? E quajti atë një variabël, e drejtë? Dhe në Scratch, ne nuk të vërtetë kujdes se çfarë po ndodhte në variablave. 

Por në këtë rast, ne të vërtetë të bëjë. Unë jam duke shkuar për të thënë varg. Dhe atëherë unë mund të telefononi kjo gjë që unë dua. Unë jam duke shkuar për të thirrur atë emri, merr të string. 

Dhe tani edhe në qoftë se ju jeni një të ri pak për këtë, vëreni se unë jam i mungojnë disa detaje. Unë jam duke harruar një gjysmë-zorrës së trashë. Unë kam nevojë për të përfunduar këtë mendim. Kështu që unë jam duke shkuar për të lëvizur kursorin e mia, dhe e goditi gjysmë-zorrës së trashë atje. Dhe çfarë kam bërë vetëm? Në këtë linjë të kodit, numër 5 në këtë moment, Unë jam duke e quajtur varg të marrë me pa inputeve. Kështu që nuk ka të bardhë pak kuti si blloku Save ka. 

Unë jam vetëm duke thënë, hej, kompjuter, të marrë më një varg. Shenja të barabartë nuk është me të vërtetë një shenjë të barabartë, në vetvete. Është detyra operatori, që do të thotë, hey, kompjuter, të lëvizin vlera nga e drejta mbi të majtë. Dhe në të majtë, unë kam në vijim. 

Hey, kompjuter, më jepni një string-- një sekuencë e karaktereve. Dhe e quajnë atë string emrin. Dhe as nuk keni për të thirrur atë Emri. 

Unë mund të telefononi atë, konvencionale, diçka si S, ashtu si ne i përdorur për të e quajnë variabli i. Por tani kam nevojë për të bërë diçka me të. Ajo do të jetë goxha i trashë për të provoni hartimin e këtij kodi, duke ky program, edhe pse Unë jam duke marrë një varg, sepse kjo është ende vetëm do të thonë hello botë. 

Por, çfarë nëse unë dua për të ndryshuar këtë. Pse nuk mund ta bëj këtë? Percent s, presje s. Dhe kjo është pak i fshehtë ende. 

Pra më lejoni të bëjë variablat e mia më të qartë. Më lejoni të përmendur këtë Emri ndryshueshme. Dhe le të shohim nëse ne nuk mund të vë në lojë pavarësisht se çfarë po ndodh këtu. 

Pra, në linjë pesë, Unë jam duke marrë një varg. Dhe unë jam ruajtjen atë varg, çfarëdo që përdoruesi ka shtypur në në tastierën e tij ose të saj, në një ndryshore të quajtur Emri. Dhe kjo rezulton se printf nuk ka vetëm të marrë një argument në të dyfishtë citate, një input në thonjëza dyshe. 

Ajo mund të marrë dy ose tre, ose më shumë, të tilla se dyti, apo të tretë, apo të katërt, janë të gjithë emrat e variablave, ose në mënyrë specifike vlerat, që ju doni të prizë në, dinamike, që string në thonjëza. Me fjalë të tjera, çfarë do të ishte gabim me këtë? Në qoftë se unë vetëm tha hello emri, backslash n, shpëtoi dosjen time, hartuar kodin tim, dhe u zhvillua kjo, çfarë do të ndodhë? 

Është vetëm do të thonë, përshëndetje emrin, fjalë për fjalë N-A-M-E, që është lloj i trashë, sepse nuk është e ndryshme nga bota. Pra, çdo gjë në thonjëza është ajo fjalë për fjalë merr shtypura. Pra, nëse unë dua që të ketë një placeholder atje, Unë në fakt duhet të përdorni disa sintaksë të veçantë. Dhe kjo rezulton në qoftë se ju lexoni Dokumentacioni për funksionin printf, ajo do të ju them se qoftë se ju përdorni për qind s, ju mund të zëvendësojnë një vlerë si më poshtë. 

Pas një presje pas kësaj quote dyfishtë, ju thjesht shkruani emrin e të variable që ju dëshironi të vihet në prizë në atë format Kodi, apo format specifier, qind s për vargjet. Dhe tani, në qoftë se unë kam ruajtur dosjen time, I kthehemi poshtë për terminalin tim. Dhe unë lloji Bëni String, sepse, përsëri, emri i këtij fotografi që kam zgjedhur para është string.c. 

Kështu që unë jam duke shkuar për të thënë Bëni String, të hyjë. Oh mirësinë time, shikoni në të gjitha gabimet që kemi bërë tashmë. Dhe kjo is-- çfarë, kjo është me të vërtetë si një, shtatë program gjashtë linjë? Pra, ky është vendi ku ajo mund shumë shpejt të madhe. 

Kjo dritare terminali ka tani regurgitated vetëm një numër i madh i mesazhet e gabimit. Sigurisht, unë nuk kam shumë gabim Mesazhet se unë rreshta të kodit. Pra, çfarë po ndodh? 

E pra, strategjia më e mirë për të bërë në çdo kohë ju do të hasni një e madhe Lista e gabimeve si kjo, po lëviz prapa, shikoni për komandën ju vetëm u, e cila në rastin tim është bërë varg. Shikoni se çfarë bëjnë bëri, dhe kjo është se komandën e gjatë tingëllimë, ndonjë gjë e madhe atje. 

Por, e kuqe është e keqe. Gjelbër është duke u përpjekur të jetë butë dhe të dobishme. Por është ende e keqe, në këtë rast. Por ku është kjo e keqe? 

String.c, linjë pesë, karakteri pesë. Pra, kjo është vetëm konventë e zakonshme. diçka diçka të zorrës së trashë do të thotë Numri i linjës dhe numri karakter. Gabim, përdorimi i padeklaruar string identifikues. A e keni të thotë standarde në? 

Pra, për fat të keq, tingëllimë është duke u përpjekur të jenë të dobishëm. Por kjo është e gabuar, në këtë rast. Jo, tingëllimë, unë nuk do të thotë IO standarde. Unë do të thotë se në vijën e parë, po. 

Por linja pesë është kjo këtu. Dhe tingëllimë nuk ka kuptojnë S-T-R-I-N-G. Kjo është një identifikues padeklaruar, një fjala vetëm ajo kurrë nuk e ka parë më parë. Dhe kjo është për shkak se C, gjuha ne jemi duke shkruar kodin në të drejtë tani, nuk ka ndryshore të quajtur vargjet. 

Ajo nuk ka, nga parazgjedhur, mbështetje diçka që quhet një varg. Kjo është një pjesë e CS50 zhargon, por shumë konvencionale. Por unë mund të rregullojmë këtë si më poshtë. 

Nëse unë të shtoni një linjë të kodit në majë të këtij programi, përfshijnë CS50.h, i cili është një tjetër fotografi diku brenda CS50 IDE, diku në hard drive, kështu që të flasin, i sistemit operativ Ubuntu se unë jam në punë, që është fotografi që është duke shkuar për të mësuar operative sistemi çfarë është një string është, vetëm si io.h standarde është fotografi në sistemin operativ që është duke shkuar për të mësuar se çfarë është printf. 

Në të vërtetë, ne do të ketë marrë një mesazh shumë të ngjashme nëse IO kishte pranuar standardin IO.h dhe u përpoq për të përdorur printf. Kështu që unë jam duke shkuar për të shkuar përpara dhe vetëm Merrni kontrollin L për të pastruar ekranin tim. Ose ju mund të shtypni të qartë dhe kjo do vetëm të pastruar dritare terminali. Por ju mund të shkoni prapa në kohë. 

Dhe unë jam duke shkuar për të bërë përsëritje String. Kalojnë gishtat e mi këtë herë, Enter. O Zoti im, ai ka punuar. kjo tregon mua një komandë të gjatë fshehtë kjo është ajo që gjenerohet Sigurohuni via tingëllimë, por jo mesazhet e gabimit. Pra e kupton, edhe pse ju mund të merrni plotësisht përshkuar me numrin e mesazhet e gabimit, ajo vetëm mund të jetë kjo Cascading bezdisshëm Efekti, ku tingëllimë nuk e kupton një gjë, që do të thotë atë, atëherë nuk e kupton fjalën tjetër, ose linjë tjetër. Dhe kështu që ajo vetëm nuk gëlltitet në kodin tuaj. Por fix mund të jetë e thjeshtë. Dhe kështu që gjithmonë të përqëndrohet në Linja e parë e prodhimit. Dhe në qoftë se ju nuk e bëni kuptojnë atë, vetëm shikoni për fjalë kyçe që mund të jetë të dhëna, dhe numri i linjës, dhe karakteri, ku se gabimi mund të jetë. 

Tani më lejoni të shkoj përpara dhe të shkruani dot çaj, varg, të hyjë. Hm, nuk është thënë përshëndetje asgjë. Pse? E pra, kujtoj, ku ai kandidon? 

Kjo është mbërthyer ndoshta në këtë moment në një lak, në qoftë se ju do të, në përputhje gjashtë, sepse Get String me dashje, shkruar nga stafi CS50, ka për qëllim të vërtetë të rrimë aty duke pritur, dhe duke pritur, dhe duke pritur për një varg. Të gjithë ne kuptojmë me varg është input njerëzore. Kështu që ju e dini se çfarë? Më lejoni të shkojnë përpara. Dhe vetëm në një trill, më lejoni shkruani emrin tim, Davidit, të hyjë. Tani unë kam një program më dinamik. Ai tha, përshëndetje David. 

Nëse unë të shkojnë përpara dhe të drejtuar këtë përsëri, më lejoni të provoni të them emrin Zamila, të hyjë. Dhe tani ne kemi një program dinamik. Unë nuk e kanë koduar vështirë botën. Unë nuk e kanë koduar vështirë emrin, apo David, apo Zamila. 

Tani është më shumë si programet ne e dimë, ku në qoftë se ajo merr të dhëna, ajo prodhon dalje pak më të ndryshme. Tani, kjo nuk është më e mirë user experience, ose UX. I drejtuar programin. 

Unë nuk e di atë që unë jam duke menduar për të bërë, nëse unë në fakt të parë në ose mbani mend kodin burimor. Pra, le të bëjë të përdoruesit përvojë pak më të mirë me thjeshte e gjërave. Më lejoni të shkoj përsëri në këtë program, dhe thjesht të them printf. 

Dhe më lejoni të shkoj përpara dhe të thonë emrin, zorrës së trashë, dhe një hapësirë, dhe pastaj një gjysmë-zorrës së trashë. Dhe vetëm për shkelma, asnjë reagim n. Dhe kjo është e qëllimshme, sepse unë nuk dua e shpejtë për të lëvizur në vijën e ardhshëm. 

Unë dua të, në vend të kësaj, e bëjnë këtë, të bëjë string për të përpiluar kodin tim në makinë të re Kodi dot çaj string. Ah, kjo është shumë prettier. Tani unë në fakt e di se çfarë kompjuteri dëshiron që unë të bëj, t'i jepte një emër. 

Kështu që unë jam duke shkuar për të shkuar përpara dhe të shkruani në Rob, të hyjë, dhe hello, Rob. Pra, të kuptojnë, kjo është ende, në fund e ditës, vetëm një program nëntë linjë. Por ne kemi marrë këto hapa të fëmijës. 

Ne shkruam një linjë me të cilat ne ishin të njohur, printf, Hello World. Pastaj ne undid pak se. Dhe ne fakt përdorur marrë string. Dhe ne flak se vlera në një variabël. Dhe pastaj kemi shkuar përpara dhe përmirësuar më tej me një linjë të tretë. Dhe ky proces përsëritës i shkrim software është me të vërtetë i rëndësishëm. Në CS50, dhe në jetë në përgjithësi, ju duhet në përgjithësi nuk ulen, kanë një program në mendje, dhe të përpiqemi për shkrim të gjithë gjë damn të gjitha përnjëherë. 

Ajo do të, në mënyrë të pashmangshme, të rezultojë në mënyrë të më shumë gabime se sa ne vetë e panë këtu. Edhe unë, në këtë ditë, vazhdimisht bëjnë gabime të tjera idiote, gabime në fakt më e vështirë që janë të vështirë të kuptoj. Por ju do të bëni shumë gabime më shumë rreshta të kodit të shkruani të gjitha përnjëherë. Dhe kështu që kjo praktikë e, shkruaj pak të kodit se ju jeni të kënaqur me të, të hartojnë kjo, e drejtuar atë, të provuar atë në përgjithësi, pastaj të kalojnë on-- kështu që ashtu si ne mbajtur layering dhe layering javën e kaluar, ndërtuar nga diçka shumë thjeshtë për diçka më të ndërlikuar, bëjë të njëjtën gjë këtu. Mos u ulen, dhe të përpiqen për shkruani një problem të tërë. Aktualisht marrë këto hapa të fëmijës. 

Tani, vargjet nuk janë të gjithë se e dobishme për vete. Ne kishim në fakt, në mënyrë ideale, si për kanë diçka tjetër në veglën tonë. Pra, le të vërtetë të bëjë pikërisht këtë. 

Më lejoni të shkojnë përpara dhe tani nxit një program pak më të ndryshme. Dhe ne do të quajmë këtë int.c, për numër të plotë. Unë jam duke shkuar për të, në mënyrë të ngjashme, përfshijnë CS550.h. Unë jam duke shkuar për të përfshirë IO standarde. Dhe kjo do të jetë shumë e zakonshme në këto ditët e para të klasës. 

Dhe unë jam duke shkuar për të gatshme veten me një funksion kryesor. Dhe tani në vend të gjetjes së një varg, le të shkojnë përpara dhe për të marrë një int. Le të thërrasë atë unë, dhe e quajti atë të marrë int, parens ngushtë, gjysmë-zorrës së trashë. Dhe tani le të bëjmë diçka me të, printf. 

Le të thonë diçka si hello, backslash n, presje i. Kështu që unë jam shumë e shumë të imituar çfarë kam bërë vetëm një moment më parë. Unë kam një placeholder këtu. Kam presje bëj unë këtu, sepse unë dua të plug unë në atë placeholder. 

Pra, le të shkojnë përpara dhe të përpiqemi hartimin e këtij programi. Dosja është quajtur int.c. Kështu që unë jam duke shkuar për të thënë, të int, të hyjë. O Zoti im, por nuk është e madhe, apo jo? Ka një gabim. 

Ka një gabim sintaktik këtu tille qe programi nuk mund të përpilohet brenda int.c, linjë shtatë, karakteri 27, format gabim specifikon tipit char yll, çfarëdo që është. Por lloji argumenti është int. 

Kështu që këtu, edhe ne nuk jemi duke shkuar to-- edhe pse sot është një shumë e materialit, ne do të trullos ju me absolutisht çdo tipar C, dhe programimit në përgjithësi, në vetëm këto javët e para. Pra, nuk është shpesh do të jetë zhargon me të cilat ju nuk jeni të njohur. Dhe, në fakt, ylli char është diçka ne do të kthehen në në një javë ose dy herë së. 

Por tani për tani, le të shohim nëse ne mund të kuptoj fjalët që janë të njohur. Formats-- kështu që ne dëgjuam format specifier, kodi format para. Kjo është e njohur. Type-- por argumenti ka të tipit int. Prisni një minutë, i është një int. 

Ndoshta për qind në të vërtetë s ka disa kuptimin e përcaktuar. Dhe, në të vërtetë, ajo ka. Një numër i plotë, në qoftë se ju doni printf për të zëvendësuar atë, ju në të vërtetë duhet të përdorë format e ndryshme specifier. Dhe ju nuk do të dinë këtë nëse dikush ju tha, ose ju kishte bërë atë më parë. Por për qind i është çfarë mund të përdoret gjerësisht në printf për mbylljen në një numër të plotë. Ju mund të përdorni për qind d për një numër të plotë dhjetore. Por i është e bukur dhe e thjeshtë këtu. Pra, ne do të shkojnë me këtë. 

Tani më lejoni të shkoj përpara dhe të përsëritje make int, Enter. Kjo është e mirë, nuk ka gabime. Dot çaj OK int--, përvojë të keqe të përdoruesit, sepse unë nuk kam thënë vetes Cfare te bej. Por kjo është në rregull. Unë jam infektues shpejt. 

Dhe tani më lejoni të shkoj përpara dhe të të shkruani Davidin, OK, Zamila, Rob. OK, kështu që kjo është një gjë e mirë. Këtë herë, unë jam duke përdorur një funksion, një copë mister, i quajtur get int. Dhe kjo rezulton out-- dhe ne do të shohim këtë më vonë në term-- stafi CS50 ka zbatuar të marrë varg në mënyrë të tillë se ai vetëm do të fizikisht të marrë një varg për ty. 

Ajo ka zbatuar merrni int në një mënyrë të tillë që ajo vetëm do të të marrë një numër të plotë për ju. Dhe në qoftë se ju, njerëzore, nuk bashkëpunojnë, është fjalë për fjalë vetëm do të thonë rigjykuar, rigjykuar, rigjykuar, fjalë për fjalë ulur atje looping, deri në ju detyrojnë me disa numër magjik, si 50 dhe përshëndetje 50. 

Ose në qoftë se kemi drejtuar këtë përsëri dhe lloji në 42, përshëndetje 42. Dhe kështu funksioni i get int brenda atë pjesë të puzzle është logjika e mjaftueshme, mendim të mjaftueshme, të kuptoj se çfarë është një fjalë? Dhe çfarë është një numër? Vetëm duke pranuar, në fund të fundit, numra. 

Pra, rezulton se ky nuk është e gjitha që ekspresive. deri më tani. Pra, yay, hera e fundit që ne shkoi shumë shpejt në lojëra implementuese, dhe animacion, dhe punime artistike në Scratch. Dhe këtu, ne jemi duke u përmbajtja me botën përshëndetje, përshëndetje dhe 50. 

Kjo nuk është e gjitha që frymëzues. Dhe, me të vërtetë, këto para disa Shembujt do të marrë disa kohë të luftoj deri në eksitim. Por ne kemi shumë më shumë kontrollojnë tani, në fakt. Dhe ne jemi duke shkuar për shumë shpejt të fillojnë layering në krye të këtyre primitives themelore. 

Por së pari, le të kuptojnë se cilat janë kufizimet. Në fakt, një nga gjërat Scratch nuk ka të lehtë le të bëjmë është me të vërtetë duken nën kapuç, dhe për të kuptuar atë që një kompjuter është, çfarë mund të bëjë, dhe atë që kufizimet e saj janë. Dhe, me të vërtetë, se mungesa e të kuptuarit, potencialisht, afat-gjatë mund të çojë në shkrimin tonë të mistakes-- mete, shkrim software të pasigurt se merr hacked në një farë mënyre. 

Pra, le të marrë disa hapa drejt kuptuar këtë pak më të mirë nga mënyrë për të, të themi, shembullin e mëposhtëm. Unë jam duke shkuar për të shkuar përpara dhe të zbatojë vërtetë të shpejtë një program të quajtur Adder. Si, le të shtoni disa numra së bashku. Dhe unë jam duke shkuar për kodin disa qoshet këtu, dhe vetëm kopjoni dhe ngjisni ku ishte më parë, vetëm kështu që ne mund të merrni duke shkuar më shpejt. Deri tani unë kam marrë fillimet themelore e një programi të quajtur Adder. 

Dhe le të shkojnë përpara dhe të bëjë këtë. Unë jam duke shkuar për të shkuar përpara dhe të të themi, intx merr të int. Dhe ju e dini se çfarë? Le të bëjë një përvojë më të mirë të përdoruesit. 

Pra, le të them vetëm x është, dhe në mënyrë efektive menjëhershëm të përdoruesit për të na dhënë x. Dhe pastaj më lejoni të shkoj përpara dhe të thonë, printf si në lidhje me y është, këtë herë duke pritur dy vlera nga përdoruesi. Dhe pastaj le të vetëm të shkojnë përpara dhe të të themi, printf, shuma e x dhe y është. Dhe tani unë nuk dua të bëj për qind s. Unë dua të bëj për qind unë, backslash n, dhe pastaj plug në vlerë shuma. 

Pra, si mund të shkoj për të bërë këtë? Ju e dini se çfarë? Unë e di se si të përdorin variablave. Më lejoni vetëm të shpallë një të re, int z. 

Dhe unë jam duke shkuar për të marrë me mend ketu. Nëse ka shenja të barabarta në këtë gjuha, ndoshta unë mund të bëni vetëm x plus y, deri sa do të përfundojnë tim menduar me pikëpresje? Tani unë mund të shkoni përsëri këtu poshtë, vihet në prizë z, përfundojë këtë mendim me pikëpresje. Dhe le të shohim tani, në qoftë se këto sekuenca e lines-- x është marrë int. Y është marrë int. 

Shto x dhe y, të ruajë vlerën në z-- kështu, edhe një herë, mos harroni shenjën e barazimit nuk është e barabartë. Është detyrë nga djathta në të majtë. Dhe le të shtypura në dukje se shuma e x dhe y është fjalë z, por ajo që është brenda e z. Pra, le të bëjë Adder - bukur, pa gabime kete here. Dot çaj adder, të hyjë, x do të jetë 1. 

Y do të jetë 2. Dhe shuma e x dhe y është 3. Pra, kjo është e gjitha mirë dhe të mirë. 

Kështu që ju do të imagjinohet se matematikë duhet të punojnë në një program të tillë. Por ju e dini se çfarë? A është kjo variabël, linjë 12, madje edhe e nevojshme? Ju nuk keni nevojë për të marrë në zakonin të vetëm ruajtjen gjërat në variablat vetëm për shkak se ju mund të. Dhe, në fakt, është në përgjithësi Dizajni Konsiderohen keq në qoftë se ju jeni duke krijuar një ndryshore, të quajtur z në këtë rast, ruajtjen diçka në të, dhe pastaj menjëherë duke e përdorur atë, por kurrë përsëri. Pse të japë diçka një emër si z qoftë se ju jeni fjalë për fjalë do të përdorin atë gjë vetëm një herë, dhe kështu proximal ku keni krijuar në radhë të parë, në mënyrë të ngushtë në drejtim të linjave të kodit? Kështu që ju e dini se çfarë? Ajo rezulton se C është shumë fleksibël. Në qoftë se unë të vërtetë duan të plug-in vlerave këtu, Unë nuk duhet të deklarojë një ndryshore të re. Unë vetëm mund të plug-in x plus y, sepse C kupton aritmetike, dhe operatorët matematike. 

Kështu që unë thjesht mund të them, të bëjë këtë matematikë, x plus y, çfarëdo që këto vlera janë, plug rezulton integer në atë varg. Pra, kjo mund të jetë, edhe pse vetëm një linjë të shkurtër, një dizajn më të mirë, një program më të mirë, sepse nuk ka kodin më pak, për këtë arsye më pak për mua për të kuptuar. Dhe kjo është gjithashtu vetëm të pastër, aq sa ne nuk jemi duke futur fjalë të reja, simbolet e reja, si z, edhe pse ata nuk e bëjnë me të vërtetë të shërbejë shumë për një qëllim. 

Për fat të keq, matematikë nuk është të gjitha që ndonjëherë të besueshme. Le të shkojnë përpara dhe të bëjë këtë. Unë jam duke shkuar për të shkuar përpara tani dhe të bëjë të mëposhtme. 

Le të bëjmë printf, për qind i, plus qind i, do të jetë për qind i, backslash n. Dhe unë jam duke shkuar për të bërë this-- XYZ plus y. Kështu që unë jam vetëm duke shkuar për të rishkruar kjo pak më ndryshe këtu. Më lejoni vetëm të bëjë një kontroll të shpejtë mendje e shëndoshë. Përsëri, le të mos marrë përpara veten. Bëni nëpërkë, dot plagë kuçedër. x eshte 1, y eshte 2, 1 plus 2 është 3. Pra, kjo është e mirë. Por le të komplikojë këtë tani pak, dhe për të krijuar një skedë të re. 

Unë jam duke shkuar për të thirrur këtë, thonë, Ints, shumës për integers. Më lejoni të filloj kur isha një moment më parë. Por tani le të bëjmë disa rreshta të tjera. Më lejoni të shkojnë përpara dhe të bëjë të mëposhtme, printf, për qind i, minus për qind i, është qind i, comma x, comma yx minus y. Kështu që unë jam duke bërë pak math të ndryshme atje. Le të bëjmë një tjetër. Kështu për qind i herë për qind i është qind i, backslash n. Le të plug-in x dhe y, dhe herë x y. Ne do të përdorim të yll në kompjuterin tuaj për kohë. 

Ju nuk e përdorni x. x është një emër ndryshueshme këtu. Ju përdorni yll për shumëzim. Le të bëjmë një më shumë. Printf për qind I, të ndarë nga për qind i është qind i, n backslash. xy ndarë nga y-- kështu që ju përdorni plagë përpara në C për të bërë ndarje. Dhe le të bëjmë një tjetër. Pjesa tjetër e qind i, e ndarë nga për qind i është qind i. xy-- dhe tani e mbetur është ajo që ka mbetur gjatë. Kur ju provoni duke e ndarë një Emëruesi në një numërues, se sa është lënë gjatë se ju nuk mund të ndajë jashtë? 

Kështu që nuk është me të vërtetë, domosdoshmërisht, një simbol ne kemi përdorur në klasën e shkollës për këtë. Por ka në C. Ju ose mund thonë x modulo y, ku kjo shenjë për qind në këtë context-- për çudi, kur ju jeni brenda nga kuotat e dyfishtë, brenda të printf, për qind është përdorur si formatin specifier. 

Kur e keni përdorur për qind jashtë që në një shprehje matematik, është operatori modulo për modulare arithmetic-- për qëllimet tona këtu, thjesht do të thotë, çfarë është Pjesa e mbetur e ndarë nga x y? Kështu x ndarë nga y është x plagë y. Cila është pjesa e mbetur e ndarë nga x y? Është x y mod, siç do të thoshte një programues. 

Pra, nëse kam bërë asnjë gabim këtu, le të më të shkojnë përpara dhe të bëjë Ints, shumës, e bukur, dhe Ints dot Slash. Dhe le të shkojnë përpara dhe të bërë, le të themi, 1, 10. Të gjithë të drejtë, 1 plus 10 është 11, check. 1 minus 10 është negative 9, kontrolloni. 

1 herë 10 është 10, check. 1 të ndarë me 10 is-- OK, ne do të kaloni këtë një të tillë. Pjesa e 1 e ndarë nga 10 është 1. Kjo është e saktë. Por ka një bug në këtu. 

Kështu që e kam vënë mia dorëzojë, nuk është e saktë. Unë do të thotë, se është afër 0. 1 të ndarë me 10, ju e dini, në qoftë se ne jemi prerja disa qoshet, të sigurt, është zero. Por ajo duhet të vërtetë të jetë 1/10, 0.1, ose 0.10, 0,1000, ose kështu me radhë. 

Ajo nuk duhet të vërtetë të jetë zero. E pra, ajo rezulton se kompjuteri është duke bërë fjalë për fjalë atë që kemi thënë atë për të bërë. Ne jemi duke bërë matematikë si x pjesëtuar me y. Dhe të dy x dhe y, per linjat e kodit të parë, janë integers. 

Për më tepër, on line 15, ne jemi thënë printf, hey, printf plug-in një numër i plotë, plug-in një numër të plotë, plug-in një integer-- specifike x, dhe pastaj y, dhe pastaj x ndarë nga y. x dhe y jane Ints. Ne jemi mirë atje. 

Por ajo që është e ndarë nga x x? x ndarë nga y duhet të jetë, matematikisht, 1/10, ose 0.1, i cili është një numër të vërtetë, një numër real që ka, potencialisht, një pikë dhjetore. Kjo nuk është një numër të plotë. 

Por ajo që është më e afërt integer 1/10, ose 0.1? Yeah, kjo lloj është zero. 0.1 është si kjo shumë. Dhe 1 është kjo shumë. Pra 1/10 është më afër 0 se ajo është për një. 

Dhe kështu që ajo C është duke bërë për us-- lloj sepse ne ua tregoi to-- është truncating se numër i plotë. Është marrë vlerën, e cila përsëri është menduar të jetë diçka si 0.1000, 0 dhe kështu me radhë. Dhe kjo është truncating gjithçka pas presjes dhjetore në mënyrë që e gjithë kjo gjëra, sepse nuk ka përshtaten në nocionin e një numër të plotë, e cila është vetëm një numër si negative 1, 0, 1, lart e poshtë, që hedh çdo gjë pas presjes dhjetore, sepse ju nuk mund të përshtatet një pikë dhjetore në një numër të plotë nga ana e definicionit. 

Pra, përgjigja këtu është zero. Deri sa nuk kemi fix this? Ne kemi nevojë për një zgjidhje tjetër të gjithë së bashku. Dhe ne mund të bëjmë këtë, si më poshtë. 

Më lejoni të shkojnë përpara dhe për të krijuar një të ri file, kjo quhet floats.c. Dhe për të shpëtuar atë këtu në njëjtën directory, float.c. Dhe më lejoni të shkoj përpara dhe kopje disa prej se kodit nga më parë. 

Por në vend të gjetjes së një int, le ta bëjmë këtë. Më jep një vlerë lundrues pikë quajtur x. ku një pikë lundrues Vlera është vetëm fjalë për fjalë diçka me një pikë lundrues. Ajo mund të lëvizin në të majtë, në të djathtë. Kjo është një numër real. 

Dhe më lejoni të mos e quajnë merrni int, por të marrë noton, e cila gjithashtu ishte ndër menu e opsioneve në bibliotekë C250. Le të ndryshojë y në një noton. Pra, kjo bëhet për të marrë noton. 

Dhe tani, ne nuk duam të vihet në prizë ints. Ajo rezulton ne duhet të përdorim për qind f për të noton, f qind për noton, dhe tani për të shpëtuar atë. Dhe tani, gishtat e kaluar, të bëjë gjithandej, bukur, gjithandej dot Slash. x do të jetë një 1. y Do të jetë 10 herë. 

Dhe, e bukur, OK shtimi im është i saktë. Unë isha duke shpresuar për më shumë, por kam harruar për të shkruar atë. Pra, le të shkojë dhe të rregulluar këtë gabim logjik. 

Le të shkojnë përpara dhe të kap në vijim. Ne vetëm do të bëjë një kopje të vogël dhe paste. Dhe unë jam duke shkuar për të thënë minus. 

Dhe unë jam duke shkuar për të thënë herë. Dhe unë jam duke shkuar për të thonë ndarë. Dhe unë nuk jam duke shkuar për të bërë modulo, e cila nuk është aq i lidhur ngushtë këtu, ndarë nga F, dhe herë plus-- OK, le ta bëjmë këtë përsëri. 

Bëni gjithandej, gjithandej dot Slash, dhe 1, 10, and-- bukur, jo, OK. Kështu që unë jam një idiot. Pra, kjo është shumë e zakonshme në shkenca kompjuterike për të bërë gabime idiote si kjo. 

Për qëllime pedagogjike, ajo që unë me të vërtetë të kërkuar për të bërë u ndryshonte shkencën këtu me plus, minus për të, në kohë, dhe për të ndarë, si ju me shpresë vënë re gjatë këtij ushtrimi. Pra, tani le të ri-përpilojnë këtë program, të bëjë gjithandej dot çaj. 

Dhe për herë të tretë, le të të shohim nëse ajo i plotëson pritjet e mia. 1, 10, të hyjë, po, OK, 1.000, ndarë nga 10.000, është 0,100000. Dhe kjo rezulton ne mund të kontrollojë se sa Numrat janë pas ato pika dhjetore. Ne fakt do. Ne do të kthehen në atë. 

Por tani, në fakt, matematika është e saktë. Pra, përsëri, çfarë është takeaway këtu? Ajo rezulton se në C, nuk janë jo vetëm vetëm strings-- dhe, në fakt, nuk janë me të vërtetë, sepse ne shtoni ato me bibliotekën CS50. Por nuk janë vetëm Ints. 

Ka edhe gjithandej. Dhe kjo rezulton një bandë e të dhënave të tjera Llojet gjithashtu, se ne do të përdorim para se të gjatë. Rezulton se në qoftë se ju doni një të vetme karakter, jo një varg të karaktereve, ju mund të përdorni vetëm një char. 

Rezulton se në qoftë se ju doni një bool, një vlerë Boolean, e vërtetë apo vetëm të rreme, në sajë të bibliotekës CS50, ne kemi shtuar C tipin e të dhënave bool si. Por është i pranishëm edhe në shumë gjuhë të tjera. Dhe kjo rezulton se ndonjëherë ju nevojë për numra të mëdha vijnë pastaj nga default me ints dhe gjithandej. 

Dhe, në fakt, një të dyfishtë është një numër që përdor jo 32 bit, por 64 bit. Dhe një kohë të gjatë kohë të gjatë është një numër që përdor jo 32, por 64 bit bit, respektivisht, për pikë lundrues vlerat dhe integers, respektivisht. Pra, le të vërtetë tani shihni këtë në veprim. 

Unë jam duke shkuar për të shkuar përpara këtu dhe nxit një program tjetër. Këtu, unë jam duke shkuar për të shkuar përpara dhe përfshijnë CS50.h. Dhe më lejoni të shkoj, përfshijnë IO.h. standarde 

Dhe ju do të vëreni diçka funky po ndodh këtu. Kjo nuk është ngjyra coding gjërat në në të njëjtën mënyrë siç bëri më parë. Dhe kjo rezulton, kjo është për shkak se unë nuk kanë dhënë gjë një emër file. 

Unë jam duke shkuar për të thirrur këtë një sizeof.c, dhe e goditi Save. Dhe vini re se çfarë ndodh me shumë tim Kodi white kundër këtij sfondi të zi. Tani, të paktën nuk ka disa purpurtë në atje. Dhe kjo është sintaksë theksuar. 

Kjo për shkak se, thjesht, unë kam tha IDE çfarë lloj skedari ajo është duke i dhënë një emër, dhe në mënyrë specifike një file extension. Tani, le të shkojnë përpara dhe të bëjë këtë. Unë jam duke shkuar për të shkuar përpara dhe shumë thjesht të shtypura nga bool following-- është qind LU. 

Ne do të kthehen në se në një moment të vetëm. Dhe atëherë unë jam duke shkuar për madhësia print e bool. Dhe tani, vetëm për të kursyer vetë disa kohë, unë jam do të bëjë një tërësi bandë e tyre në të njëjtën kohë. Dhe, në veçanti, unë do të ndryshojë këtë në një char dhe char. Kjo, unë jam duke shkuar për të ndryshuar për një të dyfishtë dhe një të dyfishtë. 

Kjo, unë jam duke shkuar për të ndryshuar me një noton dhe një noton. Kjo, unë do të të ndryshojë në një int dhe një int. Dhe kjo, unë jam duke shkuar për të ndryshuar për një kohë të gjatë të gjatë. Dhe kjo është ende duke një kohë të gjatë, të gjatë e gjatë. 

Dhe pastaj, në fund, dhashë vetë një shumë, string. Ajo rezulton se në C, nuk ka operatori të veçantë të quajtur Madhësia e kjo është fjalë për fjalë do të, kur të drejtuar, na tregoni madhësinë e secili prej këtyre variablat. Dhe kjo është një mënyrë, tani, ne mund të lidheni përsëri për diskutimin e javës së kaluar e të dhënave dhe përfaqësimit. 

Më lejoni të shkojnë përpara dhe të hartojnë Madhësia e madhësisë dot çaj të. Dhe le të shohim. Ajo rezulton se në C, veçanërisht në CS50 IDE, në mënyrë të veçantë mbi të sistemit operativ Ubuntu, e cila është një operativ 64-bit Sistemi në këtë rast, një bool do të përdorin një bajt hapësirë. Kjo është se si madhësia është i matur, jo në copa, por në bytes. Dhe kujtojnë se një bajt është tetë bit. Pra, një bool, edhe pse ju teknike duhet vetëm një 0 ose 1, kjo është pak kota se si ne kemi zbatuar atë. Është e vërtetë do të përdorin një tërësi byte-- kështu që të gjitha zero, janë ndoshta të gjitha ato, ose diçka të tillë, ose vetëm një 1 në mesin e tetë bit. 

Një char, ndërkohë, e përdorur për një karakter si një karakter ASCII për javën e kaluar, do të jetë një karakter. Dhe kjo synchs me nocionin tonë të duke qenë jo më shumë se 256 bits-- në vend, synchs deri me atë që po asnjë më shumë se 8 bit, e cila na jep sa më shumë si 256 vlera. A e dyfishtë do të të jetë 8 bytes ose 64 bit. 

Një noton është 4. Një int është 4. Një kohë të gjatë, kohë të gjatë është 8. Dhe një varg është 8. Por mos u bëni merak për këtë. Ne jemi duke shkuar për të zhvishem përsëri se shtresa. Ajo rezulton, vargjet mund të jetë më shumë se 8 bytes. 

Dhe, me të vërtetë, ne kemi shkruar strings tashmë, Hello World, më shumë se 8 bytes. Por ne do të kthehen në se në një moment të vetëm. Por marrë larg këtu është në vijim. 

Çdo kompjuter ka vetëm një fundme Sasia e memories dhe hapësirë. Ju vetëm mund të ruajë kaq shumë fotografi në Mac apo PC. Ju mund të ruajë vetëm kaq shumë programe në RAM drejtimin në të njëjtën kohë, detyrimisht, edhe me memorie virtuale, sepse ju keni një sasi të caktuar të RAM. 

Dhe vetëm për picture-- nëse ju kurrë nuk kam hapur një laptop apo urdhëruar memorie ekstra për një kompjuter, ju mund të mos e dinë se brenda e kompjuterit tuaj është diçka që duket pak si kjo. Pra, kjo është vetëm një kompani të përbashkët të quajtur Rëndësishme që e bën RAM për kompjuterët. Dhe RAM është ku programet jetuar, ndërsa ata janë running. 

Pra, në çdo Mac apo PC, kur të dyfishtë click një program, dhe kjo hap, dhe kjo hap një dokument Word ose diçka të tillë, ajo ruan atë përkohësisht në RAM, sepse është më e shpejtë RAM se hard disku juaj, ose disku juaj solide të shtetit. Pra, kjo është vetëm ku programet shkoni për të jetuar, kur ata janë në punë, ose kur dosjet janë duke u përdorur. 

Pra, ju keni gjëra që duken të si ky brendësi të laptopë tuaj, ose gjëra pak më të mëdha brenda të desktop tuaj. Por kryesore është që ju keni vetëm një numër i caktuar i këtyre gjërave. Dhe ka vetëm një sasi të caktuar të hardware ulur në këtë tavolinë të drejtë këtu. 

Pra, me siguri, ne nuk mund të ruajë Numrat pafundësisht të gjata. Dhe, megjithatë, në qoftë se ju mendoni përsëri në Shkolla grade, sa shifra mund të ju keni për të drejtën nga një pikë dhjetore? Për këtë çështje, sa shifra mund të ju keni në të majtë të presjes dhjetore një? Really, pafundësisht shumë. 

Tani, ne njerëzit fuqi vetëm e di se si të shprehem milion, dhe miliard, trilion, dhe katrilion, dhe quintillion. Dhe unë jam i shtyrë kufijtë e mia understanding-- ose my-- kuptoj numra, por my shqiptim të numrave. Por ata mund të merrni pafundësisht i madh me pafundësisht shumë Shifrat në të majtë apo në të djathtë të presjes dhjetore. 

Por kompjuterat kanë vetëm një Shuma e fundme e kujtesës, një numër i caktuar i transistorëve, një numër i caktuar i poqat brenda. Pra, çfarë ndodh kur ju drejtuar nga hapësira? Me fjalë të tjera, në qoftë se ju mendoj se mbrapa në javën e fundit kur kemi biseduar në lidhje me numrat veten duke u përfaqësuar në binar, mendoj se ne kemi marrë kjo vlerë 8-bit këtu. 

Dhe ne kemi shtatë 1-të dhe një 0. Dhe mendoj se ne duam për të shtuar 1 për këtë vlerë. Ky është një numër të vërtetë e madhe tani. 

Kjo është 254, nëse më kujtohet matematikë nga javën e fundit të djathtë. Por, çfarë nëse unë të ndryshojë që rightmost 0 to a 1? Numri i përgjithshëm, i Sigurisht, bëhet e tetë 1 s. Pra, ne jemi ende mirë. 

Dhe që ndoshta përfaqëson 255, edhe pse në varësi të kontekstit ai në fakt mund të përfaqësojë një numër negativ. Por më shumë në atë kohë tjetër. Kjo ndjehet si ajo është në lidhje aq i lartë sa unë mund të llogarisë. 

Tani, kjo është vetëm 8 bit. Dhe Mac tim, me siguri, ka rrugën e më shumë se 8 bit të memories. Por ajo ka fundme. Pra, i njëjti argument vlen, edhe nëse kanë më shumë nga këta të në ekran. 

Por çfarë ndodh nëse ju jeni ruajtjen këtë numër, 255, dhe ju doni për të numëruar 1 pak më e lartë? Ju doni të shkoni nga 255 në 256. Problemi, natyrisht, është se në qoftë se ju të fillojë numërimi në zero si javën e kaluar, ju nuk mund të llogaritet si e lartë si 256, e lëre më 257, e lëre më 258, m sepse çfarë ndodh kur ju shtoni një 1? Nëse ju bëni shkollën e vjetër të klasës qasje, ju vënë një 1 këtu, dhe pastaj 1 plus 1 është 2, por kjo është me të vërtetë një zero, keni kryer 1, mbajnë 1, mbajnë 1. Të gjitha këto gjëra, këto 1-së, të shkojnë në zero. Dhe ju era deri, po, si dikush vuri në dukje, një 1 në anën e majtë. Por çdo gjë që ju mund të në fakt të parë dhe të përshtaten në kujtesën është vetëm tetë 0-së, e cila është për të thënë në një pikë në qoftë se ju, një kompjuter, përpoq numëruar mjaft e lartë, ju jeni do të përfundojë rreth, kjo do të duket, me zero, ose ndoshta edhe më negative numra, të cilat janë edhe më të ulëta se zero. 

Dhe ne mund të lloj të shihni këtë. Më lejoni të shkojnë përpara dhe të shkruajnë një program i vërtetë të shpejtë këtu. Më lejoni të shkojnë përpara dhe të shkruajnë një program të quajtur Overflow. Përfshijnë CS50.h, përfshijnë standarde IO.h-- oh, Unë me të vërtetë humbur theksim i sintaksës tim. Pra, le të ruani këtë si overflow.c. 

Dhe tani int void-- kryesore dhe para se të gjatë, ne do të kthehen për të shpjeguar se pse do të vazhdojmë me shkrim pavlefshme int kryesore. Por tani për tani, le të vetëm të bëjë ajo, duke marrë atë për të dhënë. Le të jap vetes një int, dhe nisja atë në 0. 

Le pastaj të bëjë për int shkoj zero-- në fakt, le të bëjë një lak pafund dhe shikoni se çfarë ndodh. Ndërsa e vërtetë, atëherë le të shtypura nga n është qind i, backslash n, plug-in n. Por, tani, le ta bëjmë n merr n plus 1. 

Pra, me fjalë të tjera, në secilën përsëritje të këtij lak të pafund, le të marrin vlerën e N-së, dhe për të shtuar 1 për të, dhe pastaj ruajtur rezultatin përsëri në n në të majtë. Dhe, në fakt, ne kemi parë Sintaksa pak si kjo, një kohë të shkurtër. Një mashtrim i ftohtë është në vend e të shkruarit të gjithë këtë, ju në fakt mund të them një plus n është e barabartë me 1. 

Ose në qoftë se ju me të vërtetë duan të jenë të dashuroj, ju mund të them n plus plus gjysmë-zorrës së trashë. Por këto dy të fundit janë vetëm ajo që ne do të thërrasë sheqer sintaktik për gjë të parë. 

Gjëja e parë është më i qartë, krejtësisht në rregull, tërësisht e saktë. Por kjo është më e zakonshme, unë do të të them. Pra, ne do të bëjmë këtë për vetëm një moment. 

Le tani të del nga shtrati, e cila tingëllon në vend ogurzi, del nga shtrati dot plagë. Le të shohim, n është marrë goxha i madh. Por le të mendojmë, se si e madhe n mund të merrni? 

n është një int. Ne pamë një moment më parë me madhësinë e Shembulli se një int është katër bytes. Ne e dimë nga java e fundit, katër bytes është 32 bit, sepse 8 herë 4, kjo është 32. Kjo do të jetë 4 miliardë. 

Dhe ne jemi deri në 800.000. Kjo do të marrë përgjithmonë për të llogariten si të lartë si unë ndoshta mund. Kështu që unë jam duke shkuar për të shkuar përpara, si ju mund të para se të gjatë, dhe e goditi Kontrollit C-- sinqerisht, Kontrollit C, një shumë, ku Kontrolli C në përgjithësi do të thotë të anulluar. Për fat të keq, sepse kjo po kandidon në një re, nganjëherë cloud është pështyrë nga aq shumë gjëra, output aq shumë, ajo do të të marrë pak kohë për kontributin tim për të marrë për të renë. Pra, edhe pse kam goditur Kontrolli C disa sekonda më parë, kjo është padyshim në anën e Efekti i një lak të pafund. 

Dhe kështu që në raste të tilla, ne jemi të do të largohen që të jetë. Dhe ne jemi duke shkuar për të shtuar një tjetër dritare terminali këtu me plus, e cila natyrisht nuk e bën si kjo, pasi ajo është ende duke menduar. Dhe le të shkojnë përpara dhe të jetë pak më e arsyeshme. 

Unë jam duke shkuar për të shkuar përpara dhe të bëjë kjo vetëm finitely shumë herë. Le të përdorim një për lak, që kam përmendur më herët. Le ta bejme kete. Më jep një int variabël i merr 0. i është më pak se, le të themi, 64 i ++. Dhe tani më lejoni të shkoj përpara dhe të shtypura se n është qind i, presje n. Dhe pastaj n-- kjo është ende do të marrë përgjithmonë. Le ta bejme kete. 

n merr n herë 2. Ose ne mund të jetë i zbukuruar dhe të bëjë herë është e barabartë me 2. Por le të them vetëm n barabartë në vetvete, herë 2. Me fjalë të tjera, në këtë Versioni i ri i programit, Unë nuk dua të pres përgjithmonë nga si 800,000 në 4 miliardë. Le të vetëm të marrë këtë gjatë me të. 

Le të vërtetë të dyfishtë n çdo kohë. E cila, kujtojnë, është dyfishuar kundërta e që ka, natyrisht. Dhe ndërsa javën e kaluar kemi diçka përsëri, dhe përsëri, dhe përsëri, super të shpejtë, dyfishim me siguri do të na marrë nga 1 deri më i madh të jetë e mundur vlera që ne mund të llogarisë për të me një int. 

Pra, le të bëjë pikërisht këtë. Dhe ne do të kthehen në këtë para se të gjatë. Por kjo, përsëri, është vetëm si blloku përsëritur në Scratch. Dhe ju do të përdorni këtë para se të gjatë. 

Kjo thjesht do të thotë akuzë nga zero deri ne, por jo të barabartë në 64. Dhe në çdo përsëritje të këtij loop, vetëm i mbajnë bën rritjen i. Pra, i ++ - dhe ky konstrukt të përgjithshme on line 7 është vetëm një mënyrë super të përbashkët e përsëritur disa linja të Kodi, disa disa herë. Të cilat rreshta të kodit? Këto formatimin e teksteve kaçurrel, si ju mund të nxirren nga tani, do të thotë, të bëjë të mëposhtme. 

Është në Scratch si, kur ajo ka blloqe të verdhë dhe ngjyra të tjera që lloj përqafuar apo përqafim blloqe të tjera. Kjo është ajo që ata kaçurrel formatimin e teksteve janë bërë këtu. Pra, nëse unë kam sintaksë tim right-- ju mund të shihni simbolin karrota në mjetet C kjo është se sa herë unë u duke u përpjekur për të zgjidhur këtë problem. Pra, le të heqin qafe se një krejt, dhe mbylleni atë dritare. Dhe ne do të përdorim një të ri. Bëni del nga shtrati, dot plagë del nga shtrati, Enter, të gjithë të drejtë, ajo duket e keqe në fillim. Por le të shkoni mbrapa në kohë, sepse unë e bëri këtë 64 herë. 

Dhe vini re për herë të parë, n është 1. Herën e dytë, n është 2, atëherë 4, pastaj 8, pastaj 16. Dhe duket se sa më shpejt që I merrni për rreth 1 miliard, në qoftë se unë të dyfishtë atë përsëri, që duhet të më jep 2 miliardë. Por kjo rezulton, është e të drejtë në majë. 

Dhe kështu ai në fakt përplot një int nga 1 miliard për afërsisht negative 2 miliardë, për shkak se një numër të plotë, ndryshe nga numrat e ne ishin supozuar javën e kaluar, mund të jetë edhe pozitive dhe negative në të vërtetë dhe në një kompjuter. Dhe kështu që të paktën një prej atyre bit është vjedhur në mënyrë efektive. Pra, ne të vërtetë kanë vetëm 31 bit, ose 2 miliardë vlerat e mundshme. 

Por tani për tani, takeaway është mjaft thjesht, pavarësisht këto shifra janë dhe sido që matematika është, diçka e keqe ndodh në fund, sepse në fund ju janë duke u përpjekur për të ndryshoj renditjen bit shumë herë. Dhe në mënyrë efektive të shkojnë nga e gjithë 1 e deri ndoshta të gjithë 0-së, apo ndoshta vetëm disa model tjetër që të në mënyrë të qartë, në varësi të kontekstit, mund të interpretohet si një numër negativ. Dhe kështu kjo do të duket e I të lartë mund të mbështeteni në këtë program të veçantë është vetëm rreth 1 miliard. Por ka një zgjidhje e pjesshme këtu. Ju e dini se çfarë? 

Më lejoni të ndryshojë nga një int për një kohë të gjatë të gjatë. Dhe më lejoni të shkoj përpara këtu dhe say-- Unë do të ketë për të ndryshuar këtë për një kohë të gjatë unsigned. Ose, le të shohim, unë kurrë nuk kujtohet vetë. 

Le të shkojnë përpara dhe të bëjë del nga shtrati. Jo, kjo nuk është ajo, LLD, faleminderit. Kështu që nganjëherë tingëllimë mund të jenë të dobishme. Unë nuk e mbani mend se çfarë formatin specifier ka qenë për një kohë të gjatë kohë të gjatë. 

Por, në të vërtetë, tingëllimë më tha. Green është një lloj i mirë, ende do të thotë që keni bërë një gabim. Është guessing se unë do të thotë LLD. 

Pra më lejoni të marrë kjo është këshillë, një kohë të gjatë numër i gjatë decimal, të shpëtuar atë. Dhe më lejoni përsëritje atë me pikë çaj del nga shtrati, Enter. Dhe tani ajo është e ftohtë është kjo. 

Në qoftë se unë lëviz prapa në kohë, ne ende të fillojë numërimi në të njëjtën place-- 1, 2, 4, 8, 16. Njoftim, ne kemi marrë të gjitha rrugën deri në 1 miliard. Por pastaj ne mund të sigurtë të marrë në 2 miliardë. 

Atëherë ne të merrni në 4 miliardë, pastaj 8 miliardë, 17 miliardë. Dhe ne do të shkojmë të lartë, dhe më të lartë, dhe të lartë. Përfundimisht, kjo, gjithashtu, prishet. 

Përfundimisht, me një kohë të gjatë të gjatë, që është vlera 64-bit, jo një vlerë të 32-bit, në qoftë se ju numërimin shumë i lartë, ju të përfundojë rreth 0. Dhe në këtë rast, ne të ndodhë të përfundojnë me një numër negativ. 

Pra, ky është një problem. Dhe kjo rezulton se kjo Problemi nuk është e gjitha që misterioze. Edhe pse unë kam qëllim detyruar me këto gabime, rezulton ne e shohim atë lloj të të gjitha rreth nesh, ose të paktën disa prej nesh. 

Pra, në Lego Star Wars, nëse ju keni luajtur ndonjëherë lojë, kjo rezulton nga ju mund të shkoni nëpër thyer gjërat në botë LEGO, dhe mbledhjen e monedhave, në thelb. Dhe në qoftë se ju keni luajtur ndonjëherë kjo lojë mënyrë shumë kohë, si ky individ pa emër këtu ka, numri i përgjithshëm e monedhave që ju mund të mbledhin është, kjo do të duket, 4 miliardë. 

Tani, me të është e rrumbullakuar në fakt. Pra LEGO po përpiqej të të mbajtur gjëra përdorues miqësore. Ata nuk e bëjnë atë saktësisht 2 të 32 Fuqia, në javën e kaluar. Por, 4 miliardë është një arsye. Duket, në bazë të këtij informacioni, që LEGO, dhe kompania që e bëri këtë softuer aktuale, vendosi se numri maksimal i monedhave përdoruesi mund të mblidhen është, në të vërtetë, 4 miliardë, sepse ata zgjodhën në kodin e tyre të përdorur nuk është një kohë të gjatë e gjatë, me sa duket, por vetëm një numër i plotë, një unsigned integer, vetëm një numër i plotë pozitiv, të cilit Vlera max rreth është se. E pra, këtu është një tjetër funny. Pra, në lojë Civilization, e cila disa prej jush mund të jenë të njohur me rezulton se vite më parë ka ishte një bug në këtë lojë ku në qoftë se keni luajtur rolin e Gandi në lojë, në vend të tij qenë shumë pacifist, në vend të kësaj ishte tepër, tepër agresive, në disa rrethana. Në veçanti, mënyra se Civilization vepra është se në qoftë se ju, lojtar, miratojë demokracinë, tuaj Rezultati agresiviteti merr decremented nga dy, kështu minus minus, dhe pastaj minus minus. 

Kështu që ju zbres 2 nga iterating tuaj aktuale. Për fat të keq, në qoftë se iterating juaj është fillimisht 1, dhe zbres 2 prej tij pas miratimit të demokracisë si Gandhi këtu fuqisë kanë bërë, për shkak se ai ishte shumë i passive-- 1 në shkallën e agresivitetit. Por në qoftë se ai miraton demokracinë, atëherë ai shkon nga 1 deri negative 1. 

Për fat të keq, ata ishin duke përdorur numrat unsigned, që do të thotë se ata trajtohen edhe negative Numrat sikur të ishin pozitive. Dhe kjo rezulton se ekuivalente pozitive e negative 1, në programet tipike kompjuterike, është 255. Pra, nëse Gandhi miraton demokraci, dhe për këtë arsye ka rezultati i tij agresiviteti ulur, në fakt ajo rrotullon rreth në 255 dhe e bën atë më të Karakteri agresiv në lojë. Kështu që ju mund të Google deri në këtë. Dhe kjo ishte, në të vërtetë, një aksidentale bug programimit, por që është futur mjaft lore që ndonjëherë. 

Kjo është e gjitha argëtim dhe cute. Më e frikshme është kur aktuale pajisjet e botës reale, dhe jo lojra, kanë të njëjtat të mete. Në fakt, vetëm një vit më parë një artikull erdhi rreth Boeing 787 Dreamliner të. 

Dhe artikulli në fillim shikim lexon një misterioze të vogël. Por ai tha se kjo, një software dobësi në Boeing-së ri 787 Dreamliner jet ka potencial për të shkaktuar pilotët të humbni kontrollin e avioni, ndoshta në mes të fluturimit, zyrtarët e FAA airlines paralajmëroi kohët e fundit. Ishte vendosmëria se një model 787 Aeroplani që i është mundësuar vazhdimisht për 248 ditë mund të humbasin të gjithë rrymën rotacion, AC, energjisë elektrike për shkak të gjenerator njësitë e kontrollit, GCUs, në të njëjtën kohë duke shkuar në mënyrë të sigurt të dështojnë. Kjo është lloj i humbjes më. Por memo thuhet, OK, tani kam marrë atë, gjendja është shkaktuar nga një software kundër të brendshëm për kontrolli gjenerator njësi që do të del nga shtrati pas 248 ditët e pushtetit të vazhdueshëm. Ne jemi lëshimin e kësaj re për të parandaluar humbjen të gjitha AC elektrike të energjisë, e cila mund të rezultojë në humbjen e kontrollit të aeroplanit. 

Pra, fjalë për fjalë, ka një numër i plotë, ose ndonjë lloj ekuivalente të dhënave, duke u përdorur në software në një aeroplan aktual se në qoftë se ju mbani aeroplan tuaj në kohë të mjaftueshme, e cila me sa duket mund të jetë rasti në qoftë se ju jeni vetëm duke ato vazhdimisht dhe nuk unplugging aeroplan tuaj, me sa duket, ose lënë bateri e saj të vdekur, përfundimisht do të numërojnë deri, dhe lart, dhe lart, dhe lart, dhe lart, dhe deri. 

Dhe, nga natyra, një Shuma e fundme e kujtesës do të vërshojë, kodrina prapa zero ose disa vlera negative, një efekt anësor i cili është Realiteti tmerrësisht e vërtetë se avioni mund të ketë nevojë për të restartohet, në mënyrë efektive, ose mund të bien, edhe më keq, si ajo fluturon. Pra, këto lloje të çështjeve janë ende me ne, even-- kjo ishte një artikull i 2015 edhe më të frikshme kur ju nuk domosdoshmërisht kuptojnë, vlerësojnë, ose parashikojnë këto lloje të gabimeve. 

Pra, rezulton se ka një tjetër gjë e keqe për përfaqësimin e të dhënave. Ajo rezulton se edhe gjithandej janë lloj të meta, sepse gjithandej, gjithashtu, I propozuar janë 32 bit, ose ndoshta 64 në qoftë se ju përdorni një të dyfishtë. Por kjo është ende e fundme. 

Dhe Kapur është se në qoftë se ju mund të vënë një numër të pafund të numrave pas presjes dhjetore, nuk ka asnjë mënyrë ju mund të përfaqësojnë të gjitha të jetë e mundur Numrat që ne ishim mësuar në klasën e shkollës mund të ekzistojë në botë. Një kompjuter, në thelb, ka të zgjidhni një mesin e atyre numrave për të përfaqësuar me saktësi. 

Tani, kompjuteri mund të Raundi ndoshta pak, dhe mund t'ju lejojë të ruajtur afërsisht çdo numër që ju mund të dëshironi. Por vetëm intuitive, në qoftë se ju kanë një numër i caktuar i bit, ju vetëm mund të ndryshoj renditjen e tyre në shumë mënyra të fundme. Pra, ju nuk mund të ndoshta përdorin një numër i caktuar e ndërrim të bit, modelet e zero dhe ato, për të përfaqësuar një të pafund numri i numrave, i cili sugjeron se kompjuterët e fuqisë shumë mirë të jetë shtrirë për ne ndonjëherë. 

Në fakt, le ta bëjmë këtë. Më lejoni të kthehem në CS50 IDE. Më lejoni të shkojnë përpara dhe të krijuar një program të vogël quajtur pasaktësi, për të treguar se kompjutera janë, me të vërtetë, të pasakta. 

Dhe më lejoni të shkoj përpara dhe të fillojnë me disa prej se kodit të para, dhe tani vetëm të bëjë të mëposhtme. Më lejoni të shkoj përpara dhe të bëjë printf, për qind f, backslash n, 1 të ndarë me 10. Me fjalë të tjera, le të zhyten në të thellë 1/10, si 1 dhe ndarë me 10. Sigurisht, një kompjuter mund të përfaqësojnë 1/10. 

Pra, le të shkojnë përpara dhe të bëjë pasaktësi. Le të shohim. Format specifikon tipit double. Por argumenti ka të tipit int. Çfarë po ndodh? 

Oh, interesante, kështu që është një mësim i mësuar nga më parë. Unë jam duke thënë, hej, show kompjuter me një noton me qind f. Por unë jam duke i dhënë asaj 2 ints. Pra, ajo rezulton, unë mund të rregullohet këtë në disa mënyra. 

Unë vetëm mund të kthehet në një në 1.0, dhe 10 në 10.0, e cila do të, në të vërtetë, kanë efektin e konvertimin ato në floats-- ende shpresë të njëjtin numër. Ose ajo rezulton atje është diçka ne do të shohim një herë para se të gjatë. Ju mund të hedhin numrat. 

Ju mund të, duke përdorur këtë ndermjetese shprehje, ju mund të thoni, hey, kompjuter, të marrë këtë 10, i cili e di është një int. Por të trajtuar atë, të lutem, sikur kjo është një noton. Por kjo ndihet në mënyrë të panevojshme kompleks. 

Për qëllimet tona sot, le të vetëm fjalë për fjalë t'i bëjë ata lundrues vlerat pikë me një pikë dhjetore, si kjo. Më lejoni të shkojnë përpara dhe përsëritje, të bëjë pasaktësi, mirë, dot slash pasaktësi, të hyjë. OK, ne jemi në kërkim të mira. 

1 të ndarë me 10, sipas mia Mac këtu, është, në të vërtetë, 0,100000. Tani, unë isha mësuar në klasën e shkollës ka duhet të jetë një numër i pafund 0-së. Pra, le të të paktën të përpiqet për të parë disa nga ata. Ajo rezulton se printf është pak ende njohës se ne kemi qenë duke përdorur. Kjo rezulton nga ju nuk duhet të specifikojë vetëm qind f, ose vetëm për qind i. Ju në fakt mund të specifikoni disa opsione kontrollit këtu. 

Në mënyrë të veçantë, unë jam duke shkuar për të thënë, hej, printf, në fakt më tregoni 10 pikë dhjetore. Kështu që duket pak i çuditshëm. Por ju thoni për qind, dot, sa shumë numra ju doni të shihni pas pikë dhjetore, dhe pastaj f për banesë, vetëm për shkak se kjo është çfarë thotë dokumentacioni. Më lejoni të shkojnë përpara dhe për të shpëtuar atë. 

Dhe vini re gjithashtu, unë jam duke lodhur e rishtypjes gjëra. Kështu që unë jam vetëm ngritjen dhe down arrow mbi çelësat e mia këtu. Dhe në qoftë se unë mbaj goditur, ju mund të shihni të gjitha komandat e që kam bërë, ose ka bërë gabimisht. 

Dhe unë jam duke shkuar për të shkuar përpara dhe tani fakt nuk e përdorin atë, me sa duket. Bëni pasaktësi, dot çaj imprecision-- kështu ajo që unë isha mësuar në Shkolla klasën kontrollon jashtë. Edhe në qoftë se unë të shtypura atë në 10 dhjetore vendos atë, në të vërtetë, është 0,10000. Por ju e dini se çfarë? 

Le të merrni pak lakmitar. Le të themi, si, më tregoni 55 pikë pas dhjetore. Le të vërtetë të marrë këtë programit për një shëtitje. Më lejoni të ribërë atë me make pasaktësi, dot plagë, pasaktësi. 

Dhe këtu ne do të shkojmë. fëmijëria juaj ishte një gënjeshtër. Me sa duket, 1 ndarë nga 10 është me të vërtetë 0.100000000000000005551115123-- 

Çfarë po ndodh? E pra, ajo rezulton, në qoftë se ju lloj i duken mjaft larg jashtë në të themelor përfaqësimi i kësaj numrin, ai në fakt nuk është saktësisht 1/10, ose 0.1 dhe një numër i pafund zero. Tani, pse është kjo? 

E pra, edhe pse kjo është një e thjeshtë Numri për ne njerëzit, 1 të ndarë me 10, kjo është ende një nga pafundësisht shumë Numrat që ne mund të mendojmë up. Por, një kompjuter mund të përfaqësojë vetëm finitely shumë numra kështu. Dhe kështu, në mënyrë efektive, çfarë kompjuteri është duke na është i afërt i tij përafrimi në numrin ne duam të besojmë se është 1/10, apo me të vërtetë 0,10000 ad infinitum. 

Përkundrazi, edhe pse, kjo është sa më afër që ajo mund të merrni. Dhe, me të vërtetë, në qoftë se ju shikoni nën kapuç, si ne jemi këtu duke shikuar 55 shifra pas decimal, ne fakt shohim këtë realitet. Tani si një mënjanë, në qoftë se ju keni parë ndonjëherë movie-- shumica prej jush ndoshta haven't-- por Superman 3 disa vite më parë, Richard Pryor leveraged thelb kjo Realiteti në kompaninë e tij për të vjedhur një shumë e fraksionet dhe fraksionet e pennies, sepse company-- si unë kujtoj, kjo është një while-- ishte në thelb duke hedhur larg çdo gjë që nuk përshtaten në nocionin e cent. 

Por në qoftë se ju të shtoni deri të gjitha këto vogël, të vogël, numrat e vogël përsëri, dhe përsëri, dhe përsëri, ju mund të, si në rasti i tij, të bëjë një sasi të mirë parash. 

Të njëjtën ide u shqye nga një më të fundit, por ende tani të vjetër Filmi, i quajtur Office Space, ku djemtë në atë film, bëri të njëjtën gjë, i dehur atë plotësisht, përfundoi me mënyrë shumë Paratë në llogarinë e tyre bankare. Kjo ishte e gjitha shumë e dyshimtë. Por në fund të ditës, pasaktësi është e të gjithë rreth nesh. 

Dhe se, gjithashtu, mund të jetë tmerrësisht rastin. Ajo rezulton se Superman 3 dhe Office Space mënjanë, ka mund të jetë një shumë e vërtetë pasojat e botës e realiteteve të papërcaktuar Përfaqësimi i të dhënave se edhe ne njerëzit për kjo ditë nuk domosdoshmërisht kuptojmë si duhet, ose mend aq shpesh sa duhet. Dhe, me të vërtetë, clip vijim është nga një vështrim në një botë shumë e vërtetë Pasojat e asaj që ndodh në qoftë se ju nuk e vlerësojmë pasaktësitë që mund të ndodhë në numrat përfaqësim. 

[VIDEO rishikim] 

-Computers, Ne kemi ardhur të gjithë për të pranuar problemet shpesh frustruese që shkoni me, porsi mete, viruset, dhe glitches software, për çmime të vogla për të paguar për lehtësi. Por, në të teknologjisë së lartë dhe shpejtësi të lartë aplikimet ushtarake dhe programit hapësirë, problemi më i vogël mund të të madhërohet në fatkeqësi. 

Më 4 qershor 1996, shkencëtarët përgatitur për të nisur një pilot Ariane 5 raketa. Ajo mbante shkencore satelitët projektuar për të përcaktuar saktësisht se si ndërvepron magnetike e tokës në terren me erërat diellore. Raketa është ndërtuar për Agjencia Hapësinore Evropiane, dhe ngriti jashtë nga objekti i saj në bregdetin e Guajanën Franceze. 

-Në Rreth 37 sekonda në fluturimi, ata së pari vënë re diçka ishte duke shkuar gabim. Nozzles u swiveling në një mënyrë që ata me të vërtetë nuk duhet. Rreth 40 sekonda, në fluturim, në mënyrë të qartë, automjeti ishte në telashe. 

Dhe kjo është kur ata bënë një vendim për ta shkatërruar atë. Zyrtari varg sigurisë, me guxim jashtëzakonshme, shtypur butonin, shpërtheu raketa, para se të mund të të bëhet një rrezik për sigurinë publike. 

-Kjo Ishte vajza fluturim i Ariane 5. Dhe shkatërrimi i saj mori vendin për shkak të një krisje ngulitura në software raketa-së. -The Problemi në Ariane ishte se ka pasur një numër që kërkohet 64 bit për të shprehur. Dhe ata donin për të kthyer është një numër 16-bit. Ata supozohet se Numri nuk ishte duke shkuar të jetë shumë i madh, se shumica e atyre shifrat në një numër të 64-bit ishin zero. Ata e kishin gabim. 

-The Paaftësia e një program software për të pranuar lloji i numrit të gjeneruara nga një tjetër ishte në rrënjë të dështimit. Software zhvillimit ishte bërë një pjesë shumë e kushtueshme të teknologjisë së re. Raketa Ariane kanë qenë shumë i suksesshëm, aq shumë e softuerit krijuar për të ishte edhe përdoret në Ariane 5. 

-The Problemi themelor ishte se Ariane 5 ka qenë më i shpejtë, më të shpejtë përshpejtuar. Dhe software nuk kishte llogariten për këtë. 

-The Shkatërrimin e raketave ishte një fatkeqësi e madhe financiare, të gjitha për shkak të një gabimi minuta software. Por ky nuk ishte i pari kohë probleme të dhënat e konvertimit kishte pllakosur teknologji moderne raketa. 

-Në 1991 me fillim e Luftës së parë të Gjirit, patriot raketave përjetuar një lloj i ngjashëm problemi numër konvertimit. Dhe si rezultat, 28 persona, 28 ushtarë amerikanë, u vranë dhe rreth 100 të tjerë janë plagosur, kur Patriot, i cili është dashur për të mbrojtur kundër scuds hyrje, dështuar për të zjarrit një raketë. 

-Kur Iraku pushtoi Kuvajtin, dhe Amerika nisur Desert Storm në fillim të vitit 1991, Bateritë Patriot raketave u vendosën për të mbrojtur Arabinë Saudite dhe Izraelit nga sulmet me raketa Skud Irakut. Patriot është një medium-varg amerikan sipërfaqe të sistemit të ajrit, të prodhuara nga kompania Raytheon. 

-The Madhësia e interceptorëve Patriot në vetvete është rreth rreth 20 këmbë të gjatë. Dhe peshon rreth 2.000 £. Dhe ajo mbart një kokë rakete prej rreth, Unë mendoj se është rreth 150 £. Dhe mbushje në vetvete është një eksploziv të lartë, i cili ka fragmente rreth tij. Zorrë e mbushje është projektuar për të vepruar si buckshot. 

-The Raketa janë kryer katër për enë, dhe janë transportuar me një rimorkio gjysmë. 

-The Sistemit Patriot anti-raketë shkon prapa të paktën 20 vjet tani. Ajo ishte projektuar në fillim si një raketë e mbrojtjes ajrore për të shuar avionët e armikut. Në Luftën e parë të Gjirit, kur se lufta erdhi së bashku, Ushtria donte të përdorin atë për të xhiruar poshtë scuds, jo aeroplanë. 

Forcat Ajrore Irakut ishte jo aq shumë e një problemi. Por ushtria u shqetësuar për scuds. Dhe kështu ata u përpoqën të përmirësuar Patriot. 

-Intercepting Një armik raketave udhëtojnë në mach 5 do të ishte sfiduese të mjaftueshme. Por kur Patriot u nxituan në shërbim, Ushtria nuk ishte në dijeni të një Modifikimi i Irakut që e bëri scuds e tyre gati e pamundur për të goditur. 

-Çfarë Ndodhi është scuds që vinin në ishin të paqëndrueshme. Ata ishin hapa të pasigurt. Arsyeja për këtë ishte Irakianët, në mënyrë për të marrë 600 kilometra nga një kilometër 300 varg raketat, mori peshë nga mbushje para. Ato bërë mbushje të lehta. 

Deri tani Patriot është duke u përpjekur për të ardhur në Skud. Dhe shumicën e kohës, Shumica dërrmuese e kohës, ajo do të fluturojnë vetëm nga Skud. Pasi operatorët e sistemit Patriot realizuar Patriot humbi objektivin e saj, ata shpërtheu mbushje patriot-së për të shmangur viktima të mundshme nëse ajo u lejohet të bjerë në tokë. 

-Kjo Ishte ajo e pa që shumica e njerëzve, këto fireballs mëdha në qiell, dhe keqkuptuar si Përgjimet e raketave Skud. 

-Megjithëse Në natën Qielli, Patriots shfaq të jetë i suksesshëm shkatërrimin Scuds, në Dhahran, nuk mund të ketë gabim në lidhje me performancën e saj. Atje, sistemi radar patriot-së humbur gjurmët e një Skud në hyrje, dhe kurrë nuk filloi për shkak për një krisje software. Ishte izraelitët i cili e parë të zbuluara se sa më gjatë sistemi ishte në, më e madhe koha mospërputhje u bë, për shkak të një orë ngulitur në kompjuterin e sistemit. 

-Rreth Dy javë më parë tragjedia në Dhahran, izraelitët raportuar Departamenti i Mbrojtjes se sistemi është humbur kohë. Pas rreth tetë orë apo drejtimin, ata vënë re se sistemi ishte duke u bërë dukshëm më pak të sakta. Departamenti i Mbrojtjes u përgjigj duke thënë të gjitha baterive Patriot për të mos i lënë sistemet për një kohë të gjatë. Ata kurrë nuk tha se çfarë një kohë të gjatë was-- tetë orë, 10 orë, 1,000 orë. Askush nuk e dinte. 

-The Bateri Patriot stacionuar në kazermën në Dhahran dhe e brendshme e saj me të meta Ora ka qenë në më shumë se 100 orë në natën e 25 shkurt. 

-Ajo Gjurmuar kohë për një saktësi rreth një të dhjetën e një të dytë. Tani, një e dhjeta e një të dytë është një numër interesante, sepse ajo nuk mund të shprehet në binar saktësisht, e cila do të thotë se nuk mund të shprehet saktësisht në çdo kompjuter moderne digjitale. Është e vështirë të besohet. 

Por e përdorin këtë si një shembull. Le të marrin numrin një të tretën. Një e treta nuk mund të jetë të shprehura në decimal saktësisht. Një e treta është 0,333 ndodh për pafundësi. 

Nuk ka asnjë mënyrë për të bërë këtë me Saktësia absolute në decimal. Kjo është pikërisht lloji i problemit që ka ndodhur në Patriot. Sa më gjatë që sistemi u, keq u bë herë gabim. 

-Pas 100 orë të punës, gabim në atë kohë ishte vetëm rreth një e treta e një të dytë. Por, sa i përket synimeve të dhënësit një raketave udhëtojnë në mach 5, kjo ka rezultuar në një ndjekja gabim prej mbi 600 metra. Do të ishte një gabim fatal për ushtarët në atë ndodhur është një fillojë Skud ishte zbuluar nga satelitët të Paralajmërimit të Hershëm dhe ata e dinin se ishte Skud që vijnë në drejtim të tyre të përgjithshëm. Ata nuk e dinë se ku po vinte. 

-Ishte Tani deri në radar komponent i sistemit Patriot mbrojtur Dhahran për të gjetur dhe për të mbajtur udhë të raketave të armikut në hyrje. 

-The Radar ishte shumë i zgjuar. Kjo në fakt do të pista pozicioni i Skud, dhe pastaj të parashikohet se ku ai ndoshta do të jetë hera e ardhshëm radar dërguar një impuls jashtë. Kjo u quajt një portë varg. 

-Pastaj, Dikur Patriot vendos kohë të mjaftueshme ka kaluar për të shkuar mbrapa dhe të kontrolloni të ardhshëm Lokacioni për këtë objekt zbuluar, ajo shkon prapa. Pra, kur ai u kthye në gabim vend, atëherë nuk sheh ndonjë objekt. Dhe vendos se nuk ka objekt, ajo ishte një zbulimin e rreme, dhe bie pista. 

-The Hyrje Skud u zhduk nga radari. Dhe sekonda më vonë, atë përplas në fortesë. Skud vrarë 28, dhe ishte i fundit një gjuajtur gjatë Luftës së parë të Gjirit. 

Tragjikisht, software updated arriti në Dhahran një ditë më pas. Software metë kishte qenë fikse, mbylljes një kapitull në trazuar Historia e raketave Patriot. 

[VIDEO rishikim] DAVID J. Malan: Pra, kjo është e gjitha për të thonë se këto çështje të del nga shtrati dhe pasaktësi janë të gjitha shumë e vërtetë. Pra, si nuk kemi marrë këtu? Kemi filluar me vetëm duke folur për printf. Përsëri, ky funksion që shtyp diçka në ekran, dhe ne kemi prezantuar më pas disa funksione disa të tjera nga e ashtuquajtura bibliotekën CS50 e. Dhe ne do të vazhdojmë të shikoni këto në kohën e duhur. Dhe ne, në veçanti, e përdorur për të marrë varg, dhe për të marrë int, dhe tani edhe të noton, dhe ende të tjerët ende do të hasim dhe të përdorin veten para se të gjatë. 

Por në disa raste, kanë ne tashmë shihet një nevojë të për të ruajtur atë që ato funksione të dorës prapa? Ata na kthehet një varg dorë, ose një int, ose nje pluskues. Dhe nganjëherë ne kemi nevojë për të vënë atë string, ose int, apo noton, diku. 

Dhe për të ruajtur këto gjëra, të kujtojnë vetëm si në Scratch, ne kemi variablave. Por ndryshe në Scratch, në C ne kemi lloje aktuale e të dhënave variables-- llojet, generally-- më shumë në mesin e tyre, një varg, një int, një noton, dhe këto të tjerët ende. 

Dhe kështu, kur ne deklarojmë variablat në C, ne do të duhet të deklarojnë lloje tona të dhënave. Kjo nuk është diçka që ne do të duhet të bëni më vonë në semestrin si ne kalimin në gjuhë të tjera. Por tani për tani, ne kemi nevojë për një priori paraprakisht, shpjegojë për kompjuter se çfarë lloji i ndryshore ne duam që ajo të na japë. 

Tani, ndërkohë, për të shtypur ato llojet e llojeve të të dhënave, ne duhet të them printf se çfarë të presin. Dhe ne pamë qind s për vargjet, dhe për qind i të integers, dhe disa të tjerë tashmë. Dhe ata janë thjesht kërkesa për prezantimin vizual këtë informacion. 

Dhe secili prej tyre në fakt mund të jetë parametrized ose tweaked në një farë mënyre, në qoftë se ju doni të kontrollit të mëtejshëm llojin e prodhimit që ju të merrni. Dhe, në fakt, rezulton se jo vetëm a ka backslash n për një linjë të re. Ka diçka tjetër të quajtur backslash r për një kthim topi, e cila është më e ngjashme me një makinë shkrimi të vjetër e shkollës, dhe gjithashtu të Windows përdorur për shumë vite. 

Ka t backslash për tabs. Rezulton, se në qoftë se ju doni të quote dyfishtë brenda një varg, kujtojnë se ne kemi përdorur double quote dyfishtë quote në të majtë dhe të djathtë skajet e vargjet tona deri tani. Kjo do të duket për të ngatërruar gjërat. 

Nëse ju doni të vendosni një kuotë të dyfishtë në mes të një string-- dhe, në të vërtetë, ajo është konfuze për të parë. Dhe kështu që ju keni për të shpëtuar, në mënyrë që të flasin, një kuotë të dyfishtë me diçka si, fjalë për fjalë, backslash kuotë të dyfishtë. Dhe ka një tjetër disa ende. Dhe ne do të shohim më shumë nga ata në përdorimin aktual para të gjatë. 

Pra, tani le të kalojnë nga të dhënave, dhe përfaqësim, dhe operatorët aritmetike, të gjitha i cili na dha një ndërtesë blloqe me të cilat për të luajtur. Por tani le të vërtetë të japë na pjesa tjetër e fjalorit që ne tashmë kishte javën e kaluar me Scratch duke marrë një vështrim në disa të tjera ndërton në C-- jo të gjitha prej tyre. Por idetë jemi gati për të parë të vërtetë vetëm për të theksuar nga përkthimi një gjuhë, Scratch, në një tjetër, C. 

Dhe me kalimin e kohës, ne do të të marr më shumë mjete për veglën tonë, mënyrë që të flasin, sintaksore. Dhe, me të vërtetë, ju do të shihni se idetë tani janë mjaft të njohur nga java e fundit. Pra, le ta bëjmë këtë. 

Le të shkojnë përpara dhe nxit një program që në fakt përdor disa shprehje, një shprehje Boolean. Më lejoni të shkojnë përpara këtu dhe për të krijuar një skedë të re. Unë do të thërrasë këtë condition.c. 

Më lejoni të shkojnë përpara dhe përfshijnë bibliotekën CS50. Dhe më lejoni të shkoj përpara dhe të përfshijnë standarde IO.h për funksionet tona, dhe printf, dhe më shumë respektivisht. Më lejoni të jap vetes se boilerplate e void int main, shpjegimi i të cilit ne do të të kthehen në të ardhmen. 

Tani më lejoni të shkoj përpara dhe të japë vetë një int via get int. Atëherë më lejoni të shkoj përpara dhe të bëjë këtë. Dua të them, nëse i është less-- le dallimin në mes pozitive, negative, ose zero vlera. 

Pra, nëse i është më pak se zero, më lejoni vetëm duhet ky program thjesht të thonë: negative, backslash n, tjetër nëse i është më e madhe se zero. Tani unë jam, sigurisht, do të thonë printf pozitiv, backslash n. Dhe pastaj tjetër if-- unë mund të bëjë këtë. 

Unë mund të bëj në qoftë se i barabartë 0. Por unë do të jetë bërë në paktën një gabim tashmë. Kujtojnë se shenja është i barabartë jo të barabartë, si ne njerëzit e dinë atë. 

Por kjo është operatori detyrë. Dhe ne nuk do të duan të marrin në anën 0 drejtë dhe e vënë atë në i në të majtë. Pra, për të shmangur këtë konfuzion, ose ndoshta keqpërdorimi i të barabartëve të nënshkruar, njerëzit vendosur disa vjet më parë që në shumë gjuhë programimi kur ju doni të kontrolloni për barazi në mes të majtë dhe të djathtë, në të vërtetë ju përdorni është e barabartë me të barabartë. Kështu që ju goditi të barabartë të nënshkruar dy herë. Kur ju doni të caktojë nga e drejta në të majtë, ju përdorni një shenjë të vetme të barabartë. Pra, ne mund të bëjmë this-- tjetër nëse i barabartë është e barabartë me zero. 

Unë pastaj mund të shkojnë dhe të hapur formatimin e teksteve kaçurrel e mia, dhe thonë: printf 0, backslash n, bërë. Por mos harroni se si këto forks në rrugë mund të punojnë. Dhe, me të vërtetë, vetëm mendoj për logjikën. i është një numër i. Kjo është një numër të plotë, në mënyrë specifike. Dhe kjo do të thotë se do të jetë më pak se 0 ose më e madhe se 0, ose 0. Pra, nuk është lloj i kësaj Rasti nënkuptuar default. 

Dhe kështu që ne mund të, ashtu si Scratch, shpërndarë me tjetër, nëse, dhe vetëm të thonë të tjerët. Logjikisht, nëse ti programues e di se ka vetëm tre kova në të cilën një Skenari mund fall-- e parë, e dytë, apo i tretë në këtë case-- nuk bother duke shtuar saktësi shtesë dhe logjika shtesë atje. Vetëm të shkojnë përpara me Rasti parazgjedhur këtu e tjetër. 

Tani, le të shkojë përpara pas kursimit të kësaj, të bëjë Kushtet dot çaj conditions-- nuk është një ndërfaqe e madhe e përdoruesit, sepse unë nuk jam duke nxitur përdorues, siç e përmenda më parë. Por kjo është në rregull. Ne do të mbani atë të thjeshtë. Le të përpiqemi numrin 42. Dhe kjo është pozitive. Le të përpiqemi numrin negative 42, negative. 

Le të përpiqemi vlerën 0. Dhe, në të vërtetë, ajo punon. Tani, ju do të shihni me probleme të para gjatë, testimi gjëra tri herë, ndoshta jo të mjaftueshme. Ju ndoshta dëshironi për të provuar disa numra të mëdha, disa të vogla numra, disa raste qoshe, si ne do të vijnë për të përshkruar ato. 

Por tani për tani, ky është një program shumë e thjeshtë. Dhe unë jam goxha i sigurt, logjikisht, se ajo bie në tri raste. Dhe, në të vërtetë, edhe pse ne vetëm fokusuar në dobësi e mundshme e pasaktësi dhe del nga shtrati, në realiteti ku shumë prej problemeve të CS50-së, ne nuk do të shqetësohen rreth, gjithë kohën, këto çështje të del nga shtrati dhe pasaktësi, për shkak se, në fakt, në C, kjo nuk është në të vërtetë të gjithë që lehtë për të shmangur ato gjëra. Nëse ju doni për të numëruar deri më të mëdha dhe më të mëdha dhe më të mëdha, del se teknika ju mund të përdorin, shpesh duke përfshirë gjëra të quajtur bibliotekat, koleksionet e kodit, që njerëz të tjerë shkruar se ju mund të përdorni, dhe gjuhë të tjera si Java dhe të tjerët, në të vërtetë e bëjnë atë një shumë më e lehtë për të numëruar edhe më të larta. Pra, kjo është me të vërtetë disa nga këto rreziqe një funksion i gjuhës që ju përdorni. Dhe në javët e ardhshme, ne do të të parë se sa të rrezikshme C vërtetë mund të jetë në qoftë se ju nuk e përdorni atë siç duhet. Por nga atje, dhe me Python, dhe JavaScript, do të ne shtresa në disa mbrojtje shtesë, dhe të drejtuar më pak nga këto rreziqe. 

Pra, le të bëjë pak më shumë Logjika interesante në programin tonë. Pra më lejoni të shkoj përpara dhe të krijojë një program të quajtur logjike vetëm kështu unë mund të luajnë me disa Logjika aktuale, logical.c. Unë vetëm do të kopjoni dhe ngjisni disa Kodi nga kështu që më parë kam marrë përsëri në këtë pikë të mirë fillimi. 

Le të më bëjë këtë herë C. char Jam duke shkuar për të dhënë atë një emër të C vetëm për shkak se është konvencionale, të marrë një karakter nga përdoruesit. Dhe le të pretendojë si Unë jam duke zbatuar pjesë e atij programi Rm, hiqni Programi i parë që bëri përdoruesit për të hequr një fotografi. Si mund ta bëjmë këtë? 

Dua të them, nëse C është e barabartë me barabartë, quote mbyll thonjëzat, y, atëherë unë jam duke shkuar për të marrë që përdoruesi ka zgjedhur po. Unë jam vetëm duke shkuar për të shkruar po. Nëse do të ishte në fakt shkruar programi heqjen, ne mund të hiqni fotografi me më shumë rreshta të kodit. Por ne do të mbajtur atë të thjeshtë. 

Tjetër në qoftë se c është e barabartë barabartë n-- dhe tani këtu, unë jam duke shkuar për të thënë, përdoruesi duhet të ketë për qëllim nr. Dhe pastaj tjetër, ju e dini se çfarë? Unë nuk e di se çfarë tjetër përdoruesi do të shkruani. Kështu që unë jam vetëm duke shkuar për të thënë se kjo është një gabim, çfarëdo ai ose ajo në të vërtetë shtypur. 

Pra, çfarë po ndodh këtu? Ka një ndryshim thelbësor kundrejt ajo që unë kam bërë në të kaluarën. Kuotat e dyfishtë, kuotat dyfishtë, të dyfishtë kuotat, dhe, ende, citate të vetme, Kuotat e vetme. Kjo rezulton në C, se kur ju dëshironi të shkruani një varg, ju nuk përdorni kuotat e dyfishtë, ashtu siç ne kemi përdorur të gjithë këtë kohë me printf. 

Por në qoftë se ju doni që të merren me vetëm një karakter të vetëm, një të ashtuquajtur char, atëherë ju në fakt përdorin këto apostrofa. Ata prej jush që kanë programuar para, ju nuk mund të ketë kishte për t'u shqetësuar në lidhje me këtë dallim në gjuhë të caktuara. Në C, ajo ka rëndësi. Dhe kështu që kur unë të marrë një char dhe dua për të krahasuar se char përdorur është e barabartë është e barabartë me një letër si y apo n, bëj, në të vërtetë, duhet të ketë këto apostrofa. 

Tani, le të shkojnë përpara dhe të bëjë këtë. Le të shkojnë përpara dhe të bëjnë dot logjike çaj logjike. Dhe tani unë jam duke e shtyrë. Pra, me sa duket, një përvojë më të mirë përdorues në fakt do të më tregoni se çfarë të bëjmë këtu. Por unë jam duke shkuar për të vetëm verbërisht thonë y për po, OK, e bukur. 

Le të drejtuar atë përsëri, n për të nuk ka, e bukur. Supozoni se si disa njerëz unë e di, caps lock e mia kryesore është në të gjithë shumë shpesh. Kështu që unë bëj kryeqyteti Y, të hyjë, gabim. OK, kjo nuk është pikërisht ajo që unë jam duke pritur. Në të vërtetë, kompjuteri është duke bërë fjalë për fjalë atë Këtë gjë ua tregova do-- kontrolluar për të vogla dhe të vogla y n. Kjo nuk do të ndjehen si të mirë user experience, edhe pse. Më lejoni të kërkojë dhe të pranojë ose rasti më i ulët apo rasti e sipërme. Pra, ajo rezulton, ju mund të dëshironi për të thënë diçka si në Scratch, si fjalë për fjalë ose C është e barabartë me është e barabartë me kapitalin y vetme cituar. Rezulton se, C nuk ka kjo fjalen literal ose. 

Por ajo ka dy bare vertikale. Ju keni për të mbajtur Shift zakonisht, në qoftë se ju jeni duke përdorur një tastierë amerikane, dhe goditi bar vertikale kryesore mbi tuaj çelës kthimit. Por ky bar vertikale bar vertikale do të thotë ose. 

Nëse, nga ana tjetër, kemi dashur për të thënë dhe, si në Scratch, ne mund të bëjmë simbol të ampersand. Kjo nuk ka kuptim logjik këtu, për shkak se një njeri nuk mund të ndoshta kanë shtypur dy y dhe y të vogla dhe kapitali Y si të njëjtit karakter. Pra, apo është ajo që ne synojmë këtu. 

Pra, nëse kam bërë këtë në të dy vendet, apo c barabartë barabartë kryeqyteti N, tani përsëritje, bëjnë logjike, përsëritje logjike. Tani, unë mund të shtypni y. Dhe unë mund ta bëjë këtë përsëri me Kapitali Y, ose N. kapitali Dhe unë mund të shtoni në shtesë kombinime ende. 

Pra, kjo është logjike program aq sa tani Unë jam duke kontrolluar logjikisht për kjo vlerë ose kjo vlerë. Dhe unë nuk kam për të, domosdoshmërisht, të dalë me dy ifs më shumë ose tjetër ifs. Unë në fakt mund të kombinohen disa nga lidhura logjike bashku ne kete menyre. Pra, kjo do të jetë më mirë projektuar se thjesht duke i thënë: në qoftë se C është e barabartë me y ulët rast, shtypura po, tjetër në qoftë se c është e barabartë e kapitalit Y, shtypura po, tjetër në qoftë se c është e barabartë me lower-- me fjalë të tjera, ju nuk duhet të ketë gjithnjë e më shumë degë. Ju mund të kombinohen disa ekuivalent degët Logjikisht, si në këtë mënyrë. 

Pra, le të marrin një vështrim në vetëm një përbërës final, një konstrukt final, se C lejon. Dhe ne do të kthehen në të ardhmen për të tjerët ende. Dhe pastaj ne do të përfundojmë duke shikuar në jo korrektësinë e code-- marrjen e kodit të work-- por dizajni e kodit, dhe të mbjellë ato fara herët. 

Pra më lejoni të shkoj përpara dhe të të hapur një skedë të re këtu. Ju e dini se çfarë? Unë jam duke shkuar për të ri-zbatuar të njëjtin program, por duke përdorur një konstrukt të ndryshme. 

Pra, le të më shpejt të japë veten qasje për të përfshirë CS50.h për bibliotekën CS50, Io.h standard për printf. Më jep boshllëkun tim int kryesore. Dhe pastaj gjatë këtu, le të shkoj përpara dhe të bëjë këtë. 

Char c merr marrë char, ashtu si më parë. Dhe unë jam duke shkuar për të përdorur një konstrukt të ri now-- kaloni, në atë karakter? Pra, switch është lloj si kalimi një këngë tren. Ose, me të vërtetë, kjo është lloj i një rast tjetër, në qoftë tjetër në qoftë se, por disi ndryshe me shkrim. 

Një kaloni duket si ky. Ju keni kaloni, dhe pastaj çfarë karakter ose numri që ju dëshironi të shikoni në, pastaj disa formatimin e teksteve kaçurrel si në Scratch, vetëm të thonë se bëjnë këto gjëra. Dhe atëherë ju keni raste të ndryshme. 

Ju nuk e përdorni nëse dhe tjetër. Ju fjalë për fjalë përdorni rastin fjalën. Dhe ju do të thoni diçka si kjo. 

Pra, në rastin e një y vogle, ose në rastin e një kapital Y, të shkojnë përpara dhe të shtypura nga po. Dhe pastaj të thyer nga kaloni. Kjo eshte. Ne jemi duke bërë. 

Tjetër në qoftë se, si të thuash, Rasti n më të ulët, ose kapitalin N, pastaj të shkojnë përpara dhe të shtypura jashtë jo, dhe pastaj thyer. Else-- dhe ky lloj është Rasti parazgjedhur indeed-- printf error-- dhe vetëm për masë të mirë, edhe pse logjikisht ky pushim nuk është e nevojshme sepse ne jemi në fund e kaloni gjithsesi, Unë tani jam duke thyer jashtë kaloni. Pra, kjo duket pak më ndryshe. 

Por, logjikisht, është e në fakt ekuivalent. Dhe pse do të përdorni njëri mbi tjetrin? Ndonjëherë, vetëm preferencë personale, nganjëherë estetikë, në qoftë se unë shikoj në këtë tani, ka diçka për të thënë për lexueshmëria e këtij kodi. Unë do të thotë, mos u mërzit për faktin se kjo Kodi është i ri për shumë prej nesh në dhomë. 

Por ajo vetëm lloj është shumë. Ju shikoni të vogla y, kapitalit Y, Rasti n ulët, kryeqyteti N parazgjedhur, ajo vetëm lloj hedhje jashtë në ju në një mënyrë që, ndoshta, ndoshta shembulli i mëparshëm me ifs dhe bare vertikale, dhe else sikur, nuk mund të ketë. Pra, kjo është me të vërtetë një çështje e personale zgjedhje, me të vërtetë, apo lexueshmëri, të kodit. 

Por në aspektin e funksionalitetit, le të më të shkojnë përpara dhe të bëjë një switch, dot plagë switch, dhe tani shkruani y vogle, Kapitali Y, n të vogla, kryeqyteti N, David, rigjykuar sepse kjo është jo një karakter të vetëm. Le të bëjmë x, gabim, siç pritej. Dhe, logically-- dhe kjo është diçka Unë do të inkurajojë në general-- edhe edhe pse ne jemi vetëm kruarje Sipërfaqja e disa nga këto karakteristika. 

Dhe kjo nuk mund të jetë e qartë kur ju veten ulen në tastierë, si e bën këtë punë? Çfarë do të bëni këtë? Gjë e bukur për të pasur një laptop apo desktop, apo qasje në një kompjuter me një përpilues, dhe me një editor kodin si kjo, është se ju mund të pothuajse gjithmonë të përgjigjem këto pyetje për veten vetëm duke u përpjekur. 

Për shembull, në qoftë se retorike Pyetja në dorë ishin, çfarë ndodh në qoftë se ju harroni deklaratat tuaja pushim? E cila është në fakt një shumë e zakonshme gjë për të bërë, sepse ajo nuk duket si ju me të vërtetë nevojë për ta. Ato nuk mund të vërtetë të përfundojë tuaj menduar si një parantezë ose një kaçurrel mbajtëse e bën. Le të shkojnë përpara dhe të përpiluar kodin dhe të shohim. Pra, ti kaloni, kaloni dot plagë. Le të shkruani në rastin më të ulët y, rasti i lartë, Enter. Kështu që unë shtypur y. 

Programi i tha po, jo, gabim, sikur të ishte ndryshuar mendjen e saj. Por kjo lloj ishte, sepse ajo që ndodh me një të kaluar është rasti i parë që ndeshje në thelb do të thotë, hej kompjuter, ekzekutuar të gjitha të kodit nën atë. Dhe në qoftë se ju nuk thoni pushim, ose mos thoni pushim, ose nuk thonë pushim, kompjuteri do të hidhte në erë nëpër të gjitha këto linja dhe të ekzekutuar të gjithë ata deri ajo merr në atë mbajtëse kaçurrel. Pra, frenat janë, me të vërtetë, është e nevojshme. Por një takeaway këtu është, kur në dyshim, provoni diçka. Ndoshta të ruajtur kodin tuaj të parë, apo ruani atë në një skedar shtesë nëse ju jeni të shqetësuar me të vërtetë në lidhje me messing up dhe të kesh për të rimarrë puna që ju e dini se është duke punuar. 

Por provoni gjëra. Dhe nuk do të jetë aq i frikësuar, ndoshta, e asaj që mund të bëjë kompjuteri, ose që ju mund të thyer diçka. Ju gjithmonë mund të ktheheni në një version më parë. 

Pra, le të përfundojnë duke shikuar në hartimin e kodit. Ne kemi këtë aftësi tani për të shkruar kushtet, dhe sythe shkruani, dhe variablave, dhe funksionet e thirrjes. Pra, sinqerisht, ne jemi lloj i kthyer në ku ishim një javë më parë me Scratch, edhe pse me një tekstuale pak bindëse Mjedisi se Scratch lejon. 

Por vini re se sa shpejt kemi fituar se fjalori, edhe nëse është e do të marrë pak kohë për të zhytet në, kështu që ne tani mund të përdorni këtë fjalor për të shkruar programet më interesante. Dhe le të marrin një hap fëmijë drejt se, si më poshtë. Më lejoni të shkojnë përpara dhe të krijojë një skedar të ri këtu. 

Unë jam duke shkuar për të thirrur këtë prototype.c, dhe futjen për herë të parë, aftësia për të bërë funksionet tuaja. Disa nga ju mund të kenë bërë këtë me Scratch, ku ju mund të krijoni tuaj blloqe vet porosi në Scratch, dhe pastaj terhiq e tyre në vend kudo që ju dëshironi në C. Dhe në programimin më gjuhë, ju mund të bëjë pikërisht that-- të funksioneve tuaja, nëse ata nuk ekzistojnë. 

Kështu, për shembull, më lejoni të shkoj përpara dhe përfshijnë CS50.h, dhe përfshijnë standarde IO.h, i pavlefshëm int main. Dhe tani ne kemi një placeholder gati për të shkuar. I mbajtur shtypjen gjëra si emrat e njerëzve sot. Dhe se ndjehet like-- Nuk do të jetë mirë në qoftë se ka ishin një funksion të quajtur emrin print? Unë nuk kam për të përdorur printf. Unë nuk duhet të mbani mend të gjitha kodet e format. Pse nuk kam, apo pse nuk ka dikush para meje, të krijuar një të shtypura funksion të quajtur emri, që i është dhënë ndonjë emër, thjesht kopje atë? 

Me fjalë të tjera, në qoftë se unë them, hej, kompjuter, më jepni një varg duke i kërkuar përdoruesit për të tillë, përmes funksionit get string CS50 e. Hey, kompjuter, vënë atë varg në variabli në anën e majtë, dhe e quajti atë s. Dhe pastaj, hej kompjuter, të shkojnë përpara dhe të shtypura se emri i personit, bëhet. 

Tani, do të ishte mirë, për shkak se ky program, quajtur me vend, më thotë atë që është menduar për të bërë me anë të emrave të atyre, funksioni së. Më lejoni të shkoj dhe të bëjë prototip, Enter. Dhe, për fat të keq, kjo nuk do të fluturojnë. 

Prototype.c, Linja 7, karakteri 5, gabim, deklarata implicit e funksionit emrit të shtypura është e pavlefshme në C99, C99 që do të thotë një version të C që doli në vitin 1999. Kjo eshte e gjitha. 

Kështu që unë nuk e di se çfarë e gjithë kjo do të thotë ende. Por unë njohë gabim në të kuqe. Kjo është shumë e qartë. 

Dhe duket se me karakteri gjelbër këtu, çështja është me emrin e shkruar, e hapur paren s, paren ngushtë, gjysmë-zorrës së trashë. Por deklarata e nënkuptuar e funksioni ne e bëmë të shohim shkurtimisht më parë. Kjo do të thotë, thjesht, se tingëllimë nuk e di se çfarë dua të them. 

Unë e kam përdorur një fjalë fjalorit që është e nuk shihet ose ishte mësuar më parë. Dhe kështu që kam nevojë për të mësuar atë çfarë do të thotë ky funksion. Kështu që unë jam duke shkuar për të shkuar përpara dhe të bëjë këtë. 

Unë jam duke shkuar për të shkuar përpara dhe të zbatojë Funksioni im quhet Print Emri. Dhe unë jam duke shkuar për të thënë, si më poshtë, të cilat ajo e bën këtë, printf, Hello, për qind s, backslash n, emri, gjysmë-zorrës së trashë. Pra, çfarë unë vetëm të bëjë? 

Pra, ajo rezulton, të zbatuar funksionin tuaj, ne lloj të marrë hua disa nga e njëjta strukturë si kryesore se ne kemi qenë vetëm marrë për të dhënë, dhe unë di vetëm kopjimi dhe pasting shumë e shumë ajo që Unë kam qenë i shkruar në të kaluarën. Por vini re model ketu. Int, Main, Void, ne do të vë në lojë përveç para se të gjatë ajo që në të vërtetë do të thotë. 

Por, për sot, vetëm vini re paralelizmin. Void, emri i të shtypura, Emri string, kështu që nuk ka një fjalen purple, e cila ne jemi duke shkuar për të filluar duke e quajtur një lloj të kthimit, emri i funksioni, dhe pastaj inputi. Pra, në fakt, mund të nxjerrim ky lloj i si javën e kaluar pasi, ky është emri ose algorithm e kodit ne jemi do të write-- algorithm themel kodi ne jemi duke shkuar për të shkruar. 

Kjo është input saj. Kjo është prodhimin e saj. Ky funksion, emri i të shtypura, është projektuar për të marrë një varg të quajtur emrin, apo çfarëdo, si input, dhe pastaj të pavlefshme. Ajo nuk ka kthim asgjë, si të marrë string ose të merrni int bën. Kështu ajo do të më dorëzojë diçka mbrapa. Është vetëm do të ketë një efekt anësor, kështu që të flasin, e shtypjes emrin e një personi. Pra vini re, Linja 7, I mund të telefononi emrin e shtypura. Line 10, unë mund të përcaktojë ose të zbatojë emrin e shtypura. Por, për fat të keq, kjo nuk është e mjaftueshme. 

Më lejoni të shkojnë përpara dhe përpiluar këtë pas kursimit. Whoa, tani, unë e kam bërë atë keq, kjo do të duket. Deklarata Pra implicit i Emri funksion të shtypura është i pavlefshëm. Dhe, përsëri, nuk ka më shumë gabime. Por, siç e paralajmëroi më parë, edhe në qoftë se ju merrni përshkuar me, apo i trishtuar pak për të parë kaq shumë gabime, të përqëndrohet vetëm në ditën e parë fillimisht, sepse ajo mund vetëm të kanë pasur një efekt Cascading. Pra, C, apo tingëllimë më konkretisht, ende nuk e njeh emrin e shtypura. 

Dhe kjo është për shkak se tingëllimë, me dashje, është lloj i heshtur. Ajo vetëm që e bën atë që të them atë për të bërë. Dhe kjo vetëm e bën këtë në mënyrë në të cilën ju thoni atë për të bërë. 

Kështu që unë kam përcaktuar kryesor në linjë katër, si ne kemi qenë bërë mjaft shpesh. Unë e kam përcaktuar emrin print on line 10. Por unë jam duke u përpjekur për të përdorur Emri print on line shtatë. 

Është shumë shpejt, nuk ekziston ende. Kështu që unë mund të jetë i mençur, dhe të jetë si, OK, kështu që le të vetëm të luajnë së bashku, dhe për të shkuar emrin e shtypura deri këtu, dhe ri-përpiloni. Oh Zoti im. Funksionoi. Ajo ishte aq e thjeshtë sa se. 

Por logjika është pikërisht kjo. Ju keni për të mësuar se çfarë tingëllimë është duke përcaktuar funksionin e parë. Pastaj ju mund ta përdorni atë. Por, sinqerisht, kjo ndihet si një shpat rrëshqitshëm. 

Kështu që çdo herë që unë të drejtuar në një problem, unë jam vetëm do të nxjerrë në pah dhe kopjoni kodin I shkruar, prerë atë dhe ngjitur deri këtu. Dhe, sigurisht, ne mund të zbuloj disa skenarë ku një funksion fuqi nevojë për të thirrur një tjetër. Dhe ju thjesht nuk mund të vënë çdo Funksioni mbi çdo tjetër. 

Pra, rezulton se ka një zgjidhje më të mirë. Ne mund të lënë këtë jetë. Dhe, sinqerisht, është përgjithësisht e bukur, dhe i përshtatshëm, dhe dizajn të mirë për të vënë kryesore pari, për shkak se, përsëri, kryesore ashtu si kur flamuri gjelbër klikuar, që është funksioni që merr ekzekutuar nga default. Kështu që ju mund të vënë edhe ajo në majë të file kështu që kur ju ose ndonjë të tjera të njeriut shikon file ju e dini se çfarë po ndodh vetëm duke lexuar kryesore të parë. Pra, ajo rezulton, ne mund të them tingëllimë në mënyrë proaktive, hey, tingëllimë, on line katër, Unë premtoj për të zbatuar një funksion të quajtur Print Emri që merr një emër varg të quajtur si input, dhe kthimit asgjë, void. Dhe unë do të marrë rreth për të zbatimin e tij më vonë. 

Këtu vjen kryesore. Main tani on line 9 mund të përdorni Print Emri sepse tingëllimë është besuar se, në fund, do të hasë në përkufizimin e zbatimit të Print Emri. Pra, pas kursimit dosjen time, le të shkoj përpara dhe të bëjë prototip, duket e mirë këtë herë. Dot çaj, prototip, le të më të shkojnë përpara dhe të shkruani një emër. David, përshëndetje David, Zamila, përshëndetje Zamila, dhe, në të vërtetë, tani ajo punon. 

Kështu përbërës këtu është se ne kemi bërë një funksion me porosi, si një porosi block Scratch ne jemi duke e quajtur atë. Por ndryshe nga Scratch ku ju mund të vetëm të krijojë atë dhe të fillojnë duke e përdorur atë, tani ne duhet të jetë një pak më shumë pedant, dhe në fakt tren tingëllimë për të përdorur, ose të presin atë. Tani, si një mënjanë, pse të gjithë këtë kohë kanë ne qenë vetëm verbërisht në besim, duke përfshirë CS50.h, dhe duke përfshirë IO.h standarde? 

E pra, ajo rezulton, në mesin e disa gjëra të tjera, gjithçka që është në ato dot h fotografi, të cilat ndodhin për dosjet. Ata janë fotografi header, kështu që të flasin. Ata janë ende të shkruar në C. Por, ata janë një lloj tjetër të dosjes. 

Tani për tani, ju mund të pretty much të supozojmë që gjithçka që ndodhet në brendësi të CS50.h është rreth një Liners si kjo, jo për funksionet e quajtur Print Emri, por për Get String, Get Float, dhe disa të tjerë. Dhe ka prototipa të ngjashme, një oxhaku, brenda e IO.h standarde për printf, e cila tani është në vet Print Emri funksioni im. Pra, me fjalë të tjera, këtë herë të gjithë ne kemi sapo është verbërisht kopjimi dhe pasting përfshijnë këtë, përfshijnë se çfarë po ndodh? Këto janë vetëm lloj të dhëna të tingëllimë për çfarë funksione janë, në të vërtetë, zbatohet, vetëm diku tjetër në fotografi të ndryshme diku tjetër në sistemin. 

Pra, ne kemi zbatuar emrin shtypura. Ai e bën këtë efekt anësor i shtypjen diçka në ekran. Por kjo nuk ka të vërtetë dorëzojnë mua diçka mbrapa. Si mund të shkoni në lidhje me zbatimin e një programi që do të dorëzojë mua diçka prapa? 

E pra, le të provoni këtë. Më lejoni të shkojnë përpara dhe të zbatojë një file i quajtur return.c kështu që ne mund të tregojë se si diçka si Get String, ose Get Int, në fakt është kthyer diçka mbrapa për përdoruesit. Le të shkojnë përpara dhe të përcaktojë pavlefshme int kryesore. 

Dhe, përsëri, në të ardhmen, ne do të të shpjegojë se çfarë se int dhe atë boshllëk është në të vërtetë duke bërë. Por, për sot, ne do të të marrë atë për të dhënë. Unë jam duke shkuar për të shkuar përpara dhe të printf, për një përvojë të mirë të përdoruesit, x është. Dhe atëherë unë jam duke shkuar për të pritur për përdorues që të jepni x me get int. 

Dhe atëherë unë jam duke shkuar për të shkuar përpara dhe të shtypura nga x në shesh. Pra, kur ju keni vetëm një tastierë, njerëzit e zakonshëm përdorur karrota pak Simboli në tastierë të përfaqësojë fuqisë i, apo eksponenti i. Kështu x katror është i pranishëm i. 

Dhe tani unë jam duke shkuar për të bërë këtë. Unë vetëm mund të do-- çfarë është x katror? x katror është x herë x. 

Dhe ne e bëmë këtë disa kohë më parë tashmë sot. Kjo nuk do të ndjehen si të gjitha që progresi shumë. Ju e dini se çfarë? Le të levave disa nga këtë ide nga koha e fundit të abstraksionit. 

Nuk do të jetë mirë në qoftë se ka një funksion të quajtur katrore që bën pikërisht këtë? Ajo ende, në fund të ditë, e bën të njëjtën matematikë. Por le të abstract larg ideja e marrjes një numër i shumëzuar me një tjetër, dhe vetëm t'i jepte një emër, si katrore këtë vlerë. 

Dhe, me fjalë të tjera, në C, le të krijojnë një funksion quajtur katror që bën pikërisht këtë. Ajo do të quhet katrore. Ajo do të marrë një int. Dhe ne do të do të vetëm e quajti atë n, by default. 

Por ne mund ta quajmë atë çdo gjë që ne duam. Dhe çdo gjë që ajo do të bërë, fjalë për fjalë, është kthimi rezultat i herë n n. Por për shkak se ajo është e kthyer diçka, e cila është fjalen në vjollcë ne kemi kurrë më parë, I, on line 11, nuk mund të them vetëm këtë herë pavlefshme. 

Void, në shembullin e ne vetëm e pa në vend të emrit të shtypura, thjesht do të thotë, bej dicka. Por mos dorëzojnë mua diçka mbrapa. Në këtë rast, unë dua për t'u kthyer n herë n, apo çfarëdo që është, ky numër. 

Kështu që unë nuk mund të them, hej, kompjuter, I kthyer asgjë, e pavlefshme. Ajo do të kthehen, nga natyra, një int. Dhe kështu kjo është e gjitha që po ndodh këtu. 

Të dhëna të katror do të jetë një int. Dhe kështu që ne mund ta përdorin atë, ajo duhet të të ketë një emër, N. Ajo do të prodhimit një int që nuk ka nevojë për një emër. Ne mund të lënë atë në kryesore, apo kushdo që është duke përdorur mua për të kujtuar këtë vlerë nëse ne doni me ndryshore e vet. 

Dhe, përsëri, vetëm e Re fjalen këtu është Kthimi. Dhe unë jam vetëm duke bërë disa matematikë. Në qoftë se unë me të vërtetë donte të jetë e panevojshme, Unë mund të them produkt int merr n herë n. 

Dhe atëherë unë mund të them, produkt kthehen. Por, përsëri, në pikën time të parë e kjo jo vetëm duke u design-- mirë si, pse të futur një emër, një simbol, si produkt, vetëm për të menjëherë të kthejë atë? Kjo është një pastruese pak, pak të forta, kështu që për të folur, vetëm për të thënë herë Kthimi n n, të hequr qafe këtë linjë krejt. 

Dhe kjo është vetëm pak kodi për të lexuar, më pak mundësi për gabime. Dhe le të shohim nëse kjo në fakt tani punon. Tani, unë jam duke shkuar për të shkuar përpara dhe të bëjë kthimin. 

Uh-oh, deklarimi implicit i funksionit. Unë e bëra këtë gabim para, ndonjë gjë e madhe. Më lejoni vetëm lloji, ose të nxjerrë në pah dhe kopje, saktë të njëjtën funksion prototip, ose nënshkrimit, e funksionit deri këtu. Ose unë mund të lëvizin të gjithë funksionin. 

Por kjo është pak dembel. Pra, ne nuk do të bëjë atë. Tani, më lejoni të bëjë kthimin e përsëri, dot kthimin slash. 

x është 2. x katror është 4. x është 3. x katror është 9. Dhe funksioni duket tani për të punuar. Pra, çfarë është dallimi këtu? Unë kam një funksion që është quajtur katrore, në këtë rast, që kam vënë në një input. Dhe unë të kthehet një prodhim. E megjithatë, më parë, në qoftë se I hapur shembullin tjetër nga parë, të cilat ishte quajtur prototype.c, I kishte emrin shtypura, të cilat kthyer pavlefshme, si të thuash, Ose kthyer asgjë, dhe thjesht kishte një efekt anësor. 

Pra, çfarë po ndodh këtu? E pra, të marrë në konsideratë funksionin të marrë varg për vetëm një moment. Ne kemi qenë duke përdorur funksionin të marrë varg në mënyrën e mëposhtme. 

Ne kemi pasur një funksion të string, si janë CS50.h, përfshijnë standarde IO.h, int, kryesor, boshllëk. Dhe pastaj çdo herë që unë kam quajtur get string deri tani, Unë e kam thënë diçka si, string s merr marrë varg, sepse get string-- le ta quajmë këtë varg get.c-- marrë Vetë kthen një varg që unë pastaj mund përdorin dhe thoni: hello, presje, përqind s, backslash n, s. 

Pra, ky është i njëjti shembull, me të vërtetë, se kemi pasur më herët. Pra, të marrë string kthen një vlerë. Por një moment më parë, string print nuk e kthen një vlerë. Ajo thjesht ka një efekt anësor. Pra, ky është një ndryshim thelbësor. Ne kemi parë ndryshme llojet e funksioneve tani, disa nga të cilat janë kthyer vlera, disa prej të cilave nuk e bëjnë. Pra, ndoshta kjo është string apo int, apo noton. Apo ndoshta kjo është vetëm e pavlefshme. 

Dhe diferenca është se këto funksione që të marrë të dhëna dhe të kthehet një vlerë të vërtetë janë sjellë diçka për të kthyer në tryezë, mënyrë që të flasin. Pra, le të shkojnë përpara dhe të shikoni në një grup të fundit e shembujve që i jep një kuptim, tani, i se si ne mund të, në të vërtetë, abstrakte mirë, dhe më të mirë, dhe më të mirë, ose më shumë, dhe më shumë, dhe më shumë, në mënyrë që për të shkruar, në fund të fundit, kodi më të mirë. Le të shkojnë përpara, dhe në frymën i Scratch, të bëjë të mëposhtme. 

Më lejoni të shkojnë përpara dhe të përfshijë CS50.h dhe IO.h. standarde Më lejoni të shkojnë përpara dhe të japë veten një int, kryesore, e pavlefshme. Dhe më lejoni të shkoj përpara, e quajmë këtë cough.c. 

Dhe më lejoni të shkoj përpara dhe vetëm si Scratch, të shtypura nga kollë / n. Dhe unë dua të bëj këtë tri herë. Kështu që unë jam, natyrisht, vetëm do të kopjoni dhe ngjisni tri herë. Unë tani jam duke shkuar për të bërë kollë kollë dot slash. Le të jap vetes një hapësirë ​​pak më shumë këtu, Enter, kollë, kollë, kollë. 

Ka, natyrisht, tashmë një mundësi për përmirësim. Unë e kam kopjuar dhe ngjit disa herë sot. Por kjo ishte vetëm kështu që unë nuk e bëri duhet të shkruani sa më shumë karaktere. Unë ende ndryshuar atë ato rreshta të kodit janë. 

Këto tre linja janë të njëjta, i cili ndihet dembel dhe në të vërtetë është, dhe ndoshta nuk është qasje e drejtë. Pra, me çfarë përbërës mund të përmirësojmë këtë kod? Ne nuk duhet të kopjoni dhe kodin paste. 

Dhe, me të vërtetë, çdo herë që ndjeheni veten kopjimi dhe pasting, dhe jo duke ndryshuar edhe kodin, shanset janë se ka një mënyrë më të mirë. Dhe, me të vërtetë, nuk ka. Më lejoni të shkojnë përpara dhe të bëjë një për lak, edhe pse mund të mos sintaksa të vijë natyrshëm ende. 

A këtë tri herë, thjesht duke bërë following-- dhe Unë të ndodhë që të dini këtë nga praktika. Por ne kemi një numër të shembujve tani. Dhe ju do të shihni në internet më shumë referenca ende. 

Kjo është sintaksa on line 6, që shumë si Scratch që përsërit bllok, të përsëritur tri herë e mëposhtme. Kjo është një magjike pak tani për tani. Por kjo do të merrni më shumë, dhe më të njohur. 

Dhe ajo do të përsërisë Linja tetë tri herë, kështu që në qoftë se unë të ri-përpilojnë make kollë, dot çaj kollë, kollë, kollë, kollë. Ai ende punon në të njëjtën mënyrë. Pra, kjo është e gjitha mirë dhe të mirë. Por kjo nuk është shumë i përhumbur. 

Kjo është krejtësisht e saktë. Por ajo ndjehet si ka mund të jetë një mundësi, si në botën e Scratch, për llojin e fillimit të shtoni disa semantikë këtu në mënyrë që Unë nuk e vetëm të ketë disa për lak, dhe një funksion që thotë se kollë, ose nuk kollë. Ju e dini se çfarë? Më lejoni të përpiqet të jetë një pak pije freskuese se kaq, dhe në fakt të shkruar një funksion që ka disa efekte anësore, e quajti atë kollë. 

Dhe kjo nuk merr të dhëna dhe kthen asnjë vlerë si prodhim. Por ju e dini atë që bën? Ai e bën this-- printf, quote mbyll thonjëzat, kollë. 

Dhe tani këtu, unë jam duke shkuar për të shkuar përpara dhe për int, i merr zero, i më pak se 3, i plus plus. Unë jam duke shkuar për të mos bërë printf, e cila është ndoshta një zbatim i nivelit të ulët detaje. Unë nuk e kujdesit se si për kollë. Unë vetëm dua të përdorni funksionin kollë. Dhe unë jam vetëm duke shkuar për të thirrur kollë. 

Tani, vini re dikotominë. Kur ju telefononi një funksion, në qoftë se ju nuk e bëni dua të jap të inputeve, krejtësisht fine. Vetëm të bëjë paren hapur, të ngushtë paren, dhe ju jeni bërë. 

Kur ju të përcaktojë një funksion, ose deklarojnë prototip Një funksion së, në qoftë se ju e dini paraprakisht se nuk është e do të marrë ndonjë argumente, thonë pavlefshme në këto kllapa atje. Dhe kjo e bën të sigurt që ju nuk do të aksidentalisht keqpërdorë atë. Më lejoni të shkojnë përpara dhe të bëjë kollë. Dhe, sigurisht, unë kam bërë një gabim. 

Dammit, nuk ka se Deklarata e nënkuptuar. Por kjo është në rregull. Kjo është një fix lehtë. Unë vetëm nevojë për prototip të lartë deri në dosjen time se unë jam në të vërtetë duke e përdorur atë. 

Kështu që tani më lejoni të bëjë kollë përsëri, e bukur. Tani, ajo punon. Bëni kollë, kollë, kollë, kollë. Kështu që ju mund të mendoni se ne jemi me të vërtetë pak më shumë se inxhinieri këtë problem. Dhe, me të vërtetë, ne jemi. Kjo nuk është një e mirë Kandidati i një programi në momentin për refactoring, dhe duke bërë atë që është e quajtur dekompozimi hierarkike, ku ju merrni një kod, dhe pastaj ju lloj i faktor gjëra jashtë, kështu që të përshkruajnë më shumë semantikë për ta, dhe ripërdorimin atë afat në fund të fundit më të gjatë. Por kjo është një bllok ndërtimi drejt Programet më të sofistikuara që ne do të fillojmë shkrim para se të gjatë se na lejon të kemi fjalorin me të cilën për të shkruar kodin më të mirë. Dhe, në të vërtetë, le të shohim nëse ne nuk mund të përgjithësoj këtë më tej. 

Duket një kafshë të çalë ose të vogël se unë, kryesore, duhet të shqetësohen për këtë mallkuar për lak, dhe duke bërë thirrje kollë përsëri dhe përsëri. Pse nuk mund të them vetëm kollë, ju lutem kollë tri herë? Me fjalë të tjera, pse nuk mund të unë vetëm japin të dhëna për kollë dhe të bëjë këtë? 

Pse nuk mund të them vetëm, në kollë kryesor tri herë. Dhe tani, kjo është lloj i magjike. Është shumë përsëritës këtu. Dhe kjo është, me të vërtetë, një hap fëmijë. 

Por vetëm aftësia për të thënë në Linja e tetë, kollë tri herë, kjo është vetëm shumë më shumë i lexueshëm. Dhe, plus, unë nuk duhet të dini ose kujdes se si kollë është zbatuar. Dhe, me të vërtetë, më vonë në gjatë dhe për projektet përfundimtare, në qoftë se ju të trajtuar një projekt me një shok klase ose dy shokët e klasës, ju do të kuptojë se ju jeni do të duhet të, ose të dëshironi të, ndarjen e punës. 

Dhe ju jeni do të duan për të vendosur më parë, i cili do të bëjë atë, dhe në të cilin copa? Dhe nuk do të ishte mirë në qoftë se ju, për shembull, të marrë përgjegjësinë e shkrimit kryesor, bërë. Dhe shokun tuaj, ose tuaj partner në përgjithësi, kujdeset për zbatimin e kollë. 

Dhe kjo ndarje, këto Muret e abstraksionit, ose shtresa e abstraksionit nëse ju do të, janë super të fuqishme, sepse sidomos për më të mëdha, më shumë programe komplekse dhe sistemet, ai i lejon njerëzit të shumta për të ndërtuar gjëra së bashku, dhe në fund të fundit thur punën e tyre së bashku në këtë mënyrë. Por, natyrisht, ne nevojë për të tani të rregulluar kollë. Ne kemi nevojë për të të treguar kollë që, hej, ju e dini se çfarë? Ju jeni do të duhet të merrni një input-- kështu që nuk e pavlefshme, por int dhe tani. Le të shkojnë përpara dhe të vënë në kollë int. i merr zero. 

i është më pak se sa shumë herë. I tha tre më parë. Por kjo nuk është ajo që unë dua. I duan kollë të përgjithësuar për të mbështetur ndonjë numër të iterations. 

Pra, në të vërtetë, kjo është n që unë dua, çfarëdo përdoruesi më thotë. Tani, unë mund të shkoni përpara dhe të thonë kollë të shtypura. Dhe pa marrë parasysh se çfarë numri përdoruesi kalon, Unë do të iterate se shumë herë. 

Pra, në fund të ditës, program është identike. Por vini re të gjitha të këtij stuff edhe mund të jetë në një tjetër dosje. Në të vërtetë, unë nuk e di më së moment si printf është zbatuar. 

Unë nuk e di në këtë moment se si të marrë string, ose të merrni int, ose të merrni noton janë zbatuar. Dhe unë nuk dua të shohin ato në ekran e mia. Siç është, unë jam duke filluar të përqëndrohet në programi im, jo ​​ato funksione. 

Dhe kështu, në të vërtetë, sa më shpejt që ju fillojnë factoring kodin si kjo jashtë, mund të kemi edhe të lëvizë kollë në një skedar të veçantë? Dikush tjetër mund të zbatojë atë. Dhe ju dhe programi juaj të bëhet shumë e bukur, dhe shumë të lexueshme, ndoshta, me të vërtetë katër Linja program të drejtë atje. 

Pra, le të shkojë përpara tani dhe të bëjë një ndryshim shumë. Vini re se prototip im duhet të ndryshojë deri të lartë. Pra më lejoni të rregulluar në mënyrë që Unë nuk do të marrë yelled at. 

Bëni kollë, më lejoni të drejtuar kollë herë Për më tepër, ende duke bërë të njëjtën gjë. Por tani, vini re ne kemi një përbërës për një version përfundimtar. Ju e dini se çfarë? Unë nuk dua të vetëm të kollë, domosdoshmërisht. Unë dua që të ketë diçka më të përgjithshme. Kështu që ju e dini se çfarë? Unë dua të bëj këtë. Unë dua që të ketë, ashtu si Scratch bën, një bllok të themi, por jo vetëm thonë diçka disa disa herë. Dua të them një varg shumë të veçantë. Dhe, për këtë arsye, unë nuk duan që ajo të them vetëm kollë. Unë dua të them gjithçka string është kaluar në. 

Pra vini re, unë kam përgjithësuar këtë në mënyrë që tani të themi ndjehet si një emër të mirë për këtë, si Scratch, merr dy argumente, ndryshe nga Scratch. Njëra është një string. Njëra është një int. 

Dhe unë mund të kaloni ato. Unë vetëm lloji i pëlqen ideja e thonë string parë, dhe pastaj sa herë më vonë. Void do të thotë se ende nuk e kthen asgjë. Këto janë vetëm anën vizuale efekte, si me [? Jordan,?] një efekt anësor i verbal yelling. Ajo ende bën herë diçka n, 0 deri në, por jo i barabartë me n. Kjo do të thotë n gjithsej herë. Dhe vetëm pastaj të shtypura nga çfarëdo që string është. Kështu që unë kam përgjithësuar me të vërtetë kjo linjë e kodit. Deri tani, si mund ta zbatojnë funksioni kollë? 

Unë mund të bëj kollë pavlefshme. Dhe unë ende mund të marrë në atë se si shumë herë ju doni të kollë. Por ju e dini se çfarë? Unë tani mund të vë bast për të thënë. 

Unë mund të telefononi të them me fjala kollë, duke kaluar në n. Dhe në qoftë se unë dua të zbatojë gjithashtu, vetëm për argëtim, një funksion teshtij, Unë mund të teshtij një numër i herë. Dhe unë mund të mbani ripërdorimin n, sepse vini re se m në këtë kontekst apo fushëveprimi ekziston vetëm brenda këtij funksioni. 

Dhe n në këtë kontekst vetëm ekziston brenda këtij funksioni këtu. Pra, ne do të kthehen në këto çështje të fushës. Dhe këtu, unë jam vetëm duke shkuar për të thënë, achoo, dhe pastaj n herë, gjysmë-zorrës së trashë. 

Dhe tani, unë vetëm nevojë për të marrë hua këto Funksioni firma këtu. Pra, kollë është e saktë. teshtij Void është e saktë tani. 

Dhe unë ende vetëm duhet të them. Kështu që unë jam duke shkuar për të thënë, të themi string s, int n, gjysmë-zorrës së trashë. Kështu që unë kam mbi-engineered dreq nga ky program. 

Dhe kjo nuk ka do të thotë kjo është çfarë ju duhet të bëni kur shkruani edhe më të thjeshtë të programeve. Të marrë diçka që është e qartë të vërtetë të thjeshtë, të vërtetë të shkurtër, dhe ri-zbatuar atë duke përdorur kodin mënyrë shumë. Por në fakt ju do të shihni, dhe në Ora të shikojnë prapa në këto shembuj, dhe kuptojnë, oh, këto janë hapat ne e mori që në fakt përgjithësuar, të faktor diçka, deri ne fund te ditës kodi im në fakt është shumë e arsyeshme. Sepse në qoftë se unë dua të nxjerr me kollë tre herë pas teshtij tri herë, Unë thjesht do të përsëritje këtë, program të kollë, dhe të drejtuar kollë. Dhe unë kam tre kollitet dhe tre teshtima. 

Dhe kështu që kjo është një bazë paradigmë, në qoftë se ju do të, për mënyrën se si ne mund të shkoni në lidhje me në fakt zbatimin e një programi. Por, le të vetëm të shohim tani se çfarë është ne kemi bërë të gjithë këtë kohë, dhe atë që disa nga pjesët e fundit janë pas kësaj komande të thjeshtë. Në fund të ditës, ne kemi qenë duke përdorur tingëllimë si përpilues tonë. Ne kemi qenë të shkruar burim Kodi, konvertimin atë via tingëllimë në kodin e makinës. 

Dhe ne kemi qenë duke përdorur të bëjë vetëm për të lehtësuar tasteve tona në mënyrë se ne nuk duhet të mbani mend ato yshtje e vetë tingëllimë. Por ajo që është bërë në të vërtetë duke bërë? Dhe, nga ana tjetër, ajo që është Tingëllimë të vërtetë duke bërë? 

Ajo rezulton, edhe pse ne kemi thjeshtuar Diskutimi i sotëm duke thënë: ju merrni kodin burim, të kalojë atë si input për një përpilues që ju jep prodhimit të makinës Kodi, rezulton se ka disa hapa të ndryshme brenda atje. Dhe hartimin ndodh të jetë ombrellë Termi për një bandë e tërë e hapave. Por, le të vetëm të vë në lojë këtë, me të vërtetë shpejt. 

Ajo rezulton se ne kemi qenë duke bërë shumë gjëra që çdo herë që unë të drejtuar një program, ose çdo herë që unë të hartuar një program të sot. Pra preprocessing referohet this-- asgjë në një program C, si ne do të shohim përsëri dhe përsëri, që fillon me këtë simbol hash, ose simboli hashtag këtu, do të thotë kjo është një direktivë preprocessor. Kjo do të thotë, në këtë rast, hey kompjuter, të bëjë diçka me këtë skedë të vërtetë para se të përpilojnë kodin tim. 

Në këtë rast, hash përfshijnë është, në thelb, mënyra C-së e duke thënë: hey kompjuter, shkoni merrni përmbajtjen e CS50.h dhe ngjiti ato këtu. Hey kompjuter, shkoni merrni Përmbajtja e IO.h standarde, kudo që ndodhet mbi hard drive, ngjitur këtu. Pra, këto gjëra ndodhin parë gjatë preprocessing. 

Dhe tingëllimë e bën të gjithë këtë për ne. Dhe kjo e bën atë në mënyrë të mallkuar shpejtë, ju nuk e bëni edhe të shihni katër gjëra të veçanta ndodhin. Por kjo është hapi i parë i tillë. 

Çfarë në të vërtetë ndodh më pas? E pra, zyrtari tjetër hap është përpiluar. Dhe kjo rezulton se hartimin e një programi teknikisht do të thotë duke shkuar nga kodi burim, sende ne kemi qenë i shkruar sot, diçka quajtur code kuvendi, diçka që duket pak më ndryshe. 

Dhe, në fakt, ne mund të shohim këtë të vërtetë të shpejtë. Më lejoni në fakt shkojnë në IDE tim. Më lejoni të shkojnë përpara dhe të hello.c të hapur, e cila është programi i parë me të cilin ne filloi sot. Dhe më lejoni të shkoj përpara dhe të drejtuar tingëllimë a pak ndryshe, tingëllimë-s, hello.c, e cila është në të vërtetë do të më jep një tjetër fotografi hello.s. 

Dhe ne me siguri kurrë nuk do të herë të parë këtë lloj të kodit. Nëse ju merrni një nivel më të ulët Sistemet e klasës si CS61, ju do të shihni shumë më tepër e këtij lloji të kodit. Por kjo është gjuha e kuvendit. Kjo është x86 gjuha kuvendi që CPU që është në themel CS50 IDE fakt e kupton. 

Dhe fshehtë si ajo e bën shikoni, kjo është diçka kompjuteri e kupton mjaft mirë. Nën q, kjo është një zbres. Ka lëvizje. 

Nuk flet e funksioneve këtu, x Oring, një lëvizje, një shtesë, një pop, një kthim. Pra, ka disa shumë udhëzime të nivelit të ulët se CPUs kuptojnë se I përmendur tërthorazi më parë. Kjo është ajo që Intel Inside. 

Ka modelet e zero dhe ato që hartë të këtyre formuluara arcanely, por disi i quajtur, udhëzime, mënyrë që të flasin. Kjo është ajo që ndodh kur të përpilojnë kodin tuaj. Ju merrni kuvendi Gjuha nga ajo, e cila do të thotë hapi i tretë është për të mbledhur që kodi kuvendi ne, në fund të fundit, makinë zero code-- dhe ato, jo Teksti që ne vetëm e pa një moment më parë. 

Pra, para-përpunimit të bën që të gjejnë dhe të zëvendësojë, dhe disa gjëra të tjera. Hartimi merr burim tuaj Kodi nga C, kod burim që kemi shkruar, që të kuvendit kodi që ne vetëm lëshoi ​​në. Grumbulluar merr atë asamble Kodi për zero dhe ato se CPU me të vërtetë do të kuptuar në fund të ditë. Dhe lidh është hapi i fundit kjo ndodh për us-- përsëri, në mënyrë të shpejtë, ne nuk bëjmë edhe notice-- që thotë se, hey kompjuter, të marrë të gjitha e zero dhe ato që rezultuar nga hartimin kodin e Davidit, dhe funksioni i tij kryesor në këtë rast. 

Dhe hej kompjuter, shkoni merrni të gjitha zero dhe ato se stafi CS50 shkroi brenda bibliotekës CS50. Mix ato me David. Dhe hej kompjuter, shkoni merrni të gjitha zero dhe ato që dikush tjetër ka shkruar vjet parë për printf. Dhe shtoni ato në të gjë e tërë, në mënyrë që ne kemi mori zero e mia dhe ato, The zero dhe ato të stafit CS50-së, të zero printf dhe ato, dhe çdo gjë tjetër ne jemi duke përdorur. 

Ata të gjithë të kombinuara së bashku në një program të quajtur, në këtë rast, përshëndetje. Kështu tani e tutje, ne do të vetëm përdorin përpilimin fjalën. Dhe ne do të marrë për të dhënë se kur themi, hartojnë programin tuaj, kjo do të thotë, hey bëjë para-përpunimin, grumbulluar, dhe lidh. Por ka në fakt disa sende me lëng ndodh atje nën kapuç. Dhe sidomos në qoftë se ju merrni kurioz disa kohë, ju mund të filloni poking rreth në këtë nivel të ulët. Por tani për tani, të kuptojë se ndër takeaways për sot janë mjaft të thjeshtë fillimi i një procesi, e duke u kënaqur me diçka si bota përshëndetje. Në të vërtetë, shumica e asaj që ne e bëmë sot me siguri nuk do të zhytet në super të shpejtë. Dhe ajo do të marrë disa kohë, dhe disa praktika. Dhe shanset janë, ju do lloj i duan të goditur tastierën tuaj ose bërtas në ekran. Dhe e gjithë kjo është në rregull. Edhe pse, ndoshta nuk do të përpiqet për të të bëjë atë në bibliotekë aq shumë. 

Dhe në fund të fundit, ju do të të aftë edhe pse, për të filluar duke parë modele, si në kodin mirë që e keni shkruar dhe në gabime që ju keni bërë. Dhe ashtu si në procesin e duke u bërë një TF apo CA është si, ju do të fillojnë për të merrni më të mirë dhe të më të mirë në duke parë këto modele, dhe vetëm zgjidhjen tuaj Problemet e vet në fund të fundit. Në ndërkohë, nuk do të jetë mjaft prej nesh të japë ju mbështetje dhe nisuni me këtë. Dhe në shkruaj-ups për të gjitha problemet do të të udhëhiqet përmes të gjitha komandat se unë me siguri e di nga një shumë të praktikës deri tani, por mund të ketë fluturuar mbi kokën e dikujt për tani. Dhe kjo është krejtësisht në rregull. 

Por, në fund të fundit, ju do të jeni për të filluar për të parë modele të dalin. Dhe një herë ju merrni kaluara të gjitha të Detajet e trashë, si kllapa, dhe formatimin e teksteve kaçurrel, dhe gjysmë-colons, dhe sende, sinqerisht, që nuk është aspak e intelektualisht interesante. Dhe kjo nuk është objektivi i marrë ndonjë klasë hyrës. Është ide që janë duke shkuar për të rëndësi. 

Është e sythe, dhe kushtet, dhe funksionet, dhe më fuqishëm nxjerrjen, dhe factoring e kodit, dhe dizajn të mirë, dhe e mira style, dhe në fund të fundit korrektësinë e kodit tuaj, kjo është në fund të fundit do të rëndësi më. Pra javën e ardhshme, ne do të marrim këto ide që ne së pari e pa në Scratch dhe kanë përkthyer tani të C. Dhe ne do të fillojmë për të futur e parë e domains botës reale natyrisht së. 

Ne do të përqëndrohet në botën e sigurisë, dhe më konkretisht cryptography, arti i përpiqen informacion. Dhe në mesin e parë Problemet ju vetë do të merrni për të shkruar më tej duke luajtur me disa sintaksë dhe zgjidhjen e disa logjike probleme, në fund të fundit para se të gjatë, është që në fakt të ngjitem, ose të encrypt, dhe në fund të fundit decrypt informacion. Dhe çdo gjë që kemi bërë sot, në mënyrë të drejtë do të ulët niveli, është vetëm do të lejojë ne për të marrë një të tillë, dhe një, dhe një hap më lart drejt shkruar kodin më interesante akoma. 

Pra, më shumë në atë javën e ardhshme. 

[VIDEO rishikim] 

-Çfarë Mund të më thoni në lidhje me hera e fundit që e panë atë? -Çfarë Mund të them, me të vërtetë? Unë do të thotë, ajo ishte si çdo tjetër provë para-prodhimit, me përjashtim të kishte diçka, tha ai në fund që mbërthyer me mua. 

-Kjo Ishte CS50. 

-Kjo Është një të gjithë të prerë, punë e madhe në provë. 

drekë -Kjo-së? 

-Yeah, Ju dhe unë mund të kap një sanduiç në një grimë. Më lejoni vetëm të informohemi me David të vërtetë shpejt. David? David? 

[END rishikim] 