[Muziek] DAVID J. MALAN: Oké, dit is CS50. En dit is een week. Zo herinneren dat de laatste keer in week nul, richtten we ons op computational denken. En we overgegaan van dat voor Scratch, een grafische programmeeromgeving de taal van onze vrienden aan het MIT Media Lab. 

En met Scratch, hebben we te verkennen ideeën zoals functies en voorwaarden, en loops, en variabelen, en zelfs evenementen en draden, en nog veel meer. En vandaag, we gaan blijven gebruiken die ideeën, en echt het nemen van hen voor verleend, maar vertalen andere taal bekend als C. Nu C is een meer traditionele taal. Het is een lager niveau taal, als je wil. 

Het is puur tekstueel. En zo op het eerste gezicht, het is allemaal nogal cryptisch te kijken Als je nog nooit hebt geprogrammeerd. We gaan te hebben puntkomma, en tussen haakjes, en accolades, en nog veel meer. Maar beseffen dat zelfs hoewel de syntax is op het punt om een ​​beetje kijken onbekende voor de meeste van jullie, zie verleden dat. En proberen om de ideeën te zien dat zijn inderdaad bekend, want hier in week een wat we zullen beginnen te doen is om te vergelijken, in eerste instantie, Scratch versus C. 

Dus bijvoorbeeld herinneren dat wanneer we geïmplementeerd de eerste van onze programma's de vorige keer hadden we een blok dat uitzag een beetje zoiets als wanneer dit-- groene vlag klikte, en toen moesten we één of meer puzzelstukjes eronder, in dit geval zeggen, hello wereld. Dus inderdaad, in Scratch, wanneer ik op dat groene vlag mijn programma uit te voeren, zodat spreken, zijn de blokken die krijgen uitgevoerd, of lopen. En, in het bijzonder, Scratch zei, hello, wereld. 

Nu, ik kon hebt opgegeven verschillende woorden hier. Maar we zullen zien dat, inderdaad, veel Deze blocks-- en inderdaad, C in vele functions-- kan geparametriseerd of aangepaste om verschillende dingen te doen. In feite, als we in C wilt converteren, nu, dit Scratch programma deze andere talen, we gaan naar een schrijven beetje zoiets als dit. 

Toegegeven, er enige onbekende syntax er het meest waarschijnlijk, int, en haakjes, en leegte. Maar printf-- hoewel je zou doen denk dat het gewoon druk zijn. Maar druk betekent druk geformatteerd, zoals we snel zullen zien. Dit zal letterlijk afgedrukt om het scherm wat ligt binnen de haakjes, die Uiteraard is in dit geval, hello wereld. 

Maar je zult merken een aantal andere syntax, sommige dubbele aanhalingstekens, dat de haakjes aan het einde, de puntkomma en dergelijke. Dus er is een beetje van de overhead, zo te zeggen, zowel cognitief en syntactisch, dat we gaan te hebben om te onthouden voordat lang. Maar beseffen dat met de praktijk, Dit zal beginnen te springen op je af. 

In feite, laten we focussen op die ene functie specifically-- in dit geval, zeg hallo wereld. Dat zeggen is de functie. Hallo wereld is de parameter, of argumenten, zijn maatwerk. 

En de gelijkwaardigheid in C is gewoon ga hier deze één lijn, waarbij printf komt overeen met, bijvoorbeeld, dubbele tekenreeks tussen aanhalingstekens, hello wereld gelijk natuurlijk naar wat er in de witte doos daar. En de backslash n, hoewel een beetje vreemd en afwezig Scratch, gewoon gaat om het effect we moeten zien in een computer, net als mijn Mac of een pc, Het wegnemen van de cursor naar de volgende regel. Het is als het raken Enter op uw toetsenbord. 

Dus we zullen zien dat nog eens het duurde niet lang. Maar laten we eerst eens een kijkje nemen op deze andere bijvoorbeeld bij lussen. We hadden dit voor altijd lus laatste keer, dat was een reeks van puzzelstukjes dat er iets deed letterlijk forever-- in casu zeg, hello wereld, hello wereld, hello wereld, hello wereld. Dus het is een oneindige lus door het ontwerp. 

In C, als we willen om dit te implementeren hetzelfde idee, we kunnen gewoon doen. Terwijl de echte, printf hello wereld-- nu terwijl slechts semantisch, soort roept het idee van het doen van weer iets, en opnieuw, en opnieuw, en voor hoe lang? Nou, true-- herinneren dat waar is net aan of één. 

En waar is natuurlijk altijd waar. Dus het is een soort van een zinloze verklaring alleen maar te zeggen waar. Maar inderdaad, dit is een bewuste, want als het waar is gewoon altijd waar, dan terwijl de ware alleen al impliceert, als een beetje indirect dat de volgende regels code tussen die accolades moet gewoon opnieuw, en opnieuw uit te voeren, en opnieuw, en nooit stoppen. 

Maar als je wilt dat uw lus te stoppen, als we vorige keer met iets als dit, herhaalt u de volgende 50 keer, in C kunnen we hetzelfde met wat er te doen genoemd voor loop-- het zoekwoord niet zijnde tijdje, maar voor. En dan hebben we een aantal nieuwe syntax hier, met int i gelijk is aan 0, i minder dan 50, i ++. En we zullen hierop terugkomen. Maar dit is gewoon hoe we zouden vertaalt de set van Scratch blokken om een ​​set van C regels code. 

Ondertussen overwegen variabelen. En, in feite hebben we gewoon zag men een ogenblik geleden. En bij Scratch, als we wilde een variabele met de naam i verklaren voor i zijn integer, maar een getal, en we willen deze ingesteld op een bepaalde waarde, we zouden dit orange gebruiken blokkeren hier-- I bij 0. 

En we zullen zien vandaag en voorbij, net als vorige week, programmeurs doen bijna altijd beginnen te tellen van nul, echt volgens afspraak. Maar ook omdat recall uit onze bespreking van binaire, het kleinste getal kunt u vertegenwoordigen elk aantal bits is gewoon gaat worden 0 zelf. En dus zullen we over het algemeen beginnen initialiseren zelfs onze variabelen 0. 

En C hetzelfde te doen, we gaan int zeggen voor integer, ik gewoon volgens afspraak. Ik kon deze variabele hebben opgeroepen wat ik wil, net als in Scratch. En dan gelijk is aan 0 net rechtverkrijgenden de waarde 0 van rechts en zet het in de variabele, of de voorraadhouder daar links. En de puntkomma zoals we zullen see-- en we hebben een paar van deze already-- gezien betekent gewoon het einde van het denken. Ga verder met iets anders te doen de lijnen die volgen. 

Nu, hoe zit het met Booleaanse expressies? Bedenk dat in Scratch, deze waren uitdrukkingen die true of false-- vragen, echt, die ofwel waar of onwaar. Dus in het geval van Scratch, kunnen we een eenvoudige vraag als deze, is dat ik minder dan 50? Dus i, nogmaals, een geheel getal. Misschien zijn we te gebruiken in een Scratch-programma om bij te houden van een score of zoiets. Dus dit syntax hier in Scratch gewoon betekent, is dat ik minder dan 50? Nou, gelukkig, is er iets eenvoudig in C. En te vertalen, Dit zouden we alleen maar zeggen dat ik minder dan 50, volgens de bekende sleutel op uw toetsenbord. 

Ondertussen, als je wilde zeg iets meer in het algemeen, als, nou ja, is x kleiner dan y waar elke van x en y zelf variabelen? We kunnen hetzelfde doen in C, zolang we hebben creëerde deze variabelen al. En we zullen zien hoe doe dat duurde niet lang. We zouden gewoon zeggen x kleiner dan y. 

Dus je begint zie een aantal overeenkomsten. En die mensen die gemaakt Scratch waren zeker geïnspireerd door een aantal van deze fundamentele ideeën. En je zult dit soort te zien syntax in vele languages-- niet alleen Scratch, niet alleen C, maar Python, en JavaScript, en andere talen nog steeds. 

Laten we eens kijken naar een ander construct vanaf het begrip van een aandoening, iets te doen voorwaardelijk. Als iets waar is, doe dit. Als er iets anders waar is, dat doen. Het is een soort van de programmering equivalent van een splitsing in de weg. Misschien is het een twee-weg vork, een drieweg vork of meer. En in Scratch, zouden we hebben gezien iets als dit. 

Dus dit is een grote. Maar rekening houden met de relatieve eenvoud van de logica. Indien x kleiner dan y is, dan zeg x minder dan y, anders als x groter is dan y, dan zeg x is groter dan y. En dan, logisch, als je denkt terug naar Scratch of gewoon je eigen menselijke intuïtie, en, als x niet groter dan y en x ten minste y, dan natuurlijk x gaat y gelijk zijn. Dus in dit geval, door het nestelen die Scratch blokken, kunnen we het bereiken van een drie weg vork in de weg? 

Ondertussen, als we willen dat doen in C, is het misschien wel ziet er een beetje simpler-- ten minste als je eenmaal bekend bent met de syntaxis. Als x kleiner dan y, printf x kleiner dan y. Anders als x groter is dan y, printf x groter is dan y. Else printf x is gelijk aan y-- en, weer, met die schuine streep eindigt net voor degenen die nieuwe lijnen, zodat als je eigenlijk liep dit soort programma's het zou gewoon verplaatsen cursor uiteindelijk naar de volgende regel van het scherm. 

Nu, ondertussen Scratch verwekte meer geavanceerde functies, maar waarvan sommige we gaan in eerste instantie over te stappen naar de wereld van C. En een van hen was riep een lijst in Scratch. En dit een speciale type variabele die staat je toe om meerdere dingen op te slaan in het terug, naar achter, naar achter, naar achteren. 

In C, heeft het niet lijsten, per se, maar iets die meer algemeen genoemd arrays, hoewel we terug te komen later dit semester te kijken naar iets riep een lijst, of eigenlijk een gekoppelde lijst. Maar voor nu, het dichtst equivalent in C ons gaat iets te zijn een array genoemd. En een array is simpelweg een speciaal type variabele die u toelaat om gegevens op te slaan terug, aan rug, aan rug, terug. 

En inderdaad, in Scratch, als we wilden om toegang te krijgen het eerste element van een matrix of een list-- en ik ga noemen, volgens afspraak, argv, argument vector, maar meer op dat duurde niet lang. Als ik bij het eerste element te krijgen van argv, in de wereld van Scratch je eigenlijk doen doorgaans beginnen te tellen vanaf 1. 

En dus ik zou kunnen krijgen punt 1 van argv. Dat is gewoon hoe MIT geïmplementeerd het begrip lijsten. Maar in C, ga ik meer gewoon zeggen, argv, die weer de naam van mijn list-- of helder zijn, een matrix. En als ik wil de eerste elementen, ik ga aan vierkante haken te gebruiken, die u misschien niet vaak gebruikt onder een toetsenbord. 

Maar 0 betekent gewoon, geef me de eerste. Zo af en toe en als Na verloop van tijd, we gaan om te beginnen met deze tweedelingen zien tussen Kras en C, waarbij Scratch maakt gebruik van een. Wij in C gebruiken 0 hier. Maar je zult snel zien als je eenmaal begrijpt de fundamenten van elke taal, dat deze dingen beginnen om des te meer te krijgen vertrouwd in de praktijk en de praktijk. 

Dus laten we eigenlijk nu kijken naar een programma. Hier zijn de eerste van onze C broncode van complete programma's. En het programma dat we gaan aan te bieden ter overweging is degene die gelijkwaardig dat eerder Scratch stuk. 

Dus hier, we hebben wat misschien wel de eenvoudigste C-programma je kunt schrijven dat daadwerkelijk iets doet. Nu zullen we kijken verleden, voor nu, heeft onder meer, standaard io.h, en deze hoek beugels en int, en leegte, en de accolades en dergelijke. 

En laten we gewoon concentreren op welke althans intuïtief, misschien al uit springen op je af. In feite, de belangrijkste, dat doe ik niet per se weten wat dit is, maar net als Kras hadden dat toen groene vlag klikte puzzelstuk, zo heeft C als programmeertaal hebben een belangrijke stukje code dat wordt uitgevoerd door gebrek. En inderdaad, Het is letterlijk gaat de belangrijkste te noemen. 

Dus belangrijkste is een functie. En het is een speciale functie die bestaat in C dat wanneer u een programma uitvoert, is het belangrijkste dat wordt gerund door standaard. In de wereld van Scratch, het was meestal als groene vlag klikte dat werd gerund door gebrek. 

Ondertussen hebben we dit eerder gezien, printf of afdrukken opgemaakt, dat is gaan naar een functie die wordt geleverd met zijn C, samen met een heleboel anderen, dat zal van tijd en tijd opnieuw, om precies zoals de naam al doet vermoeden, af te drukken iets. Wat willen we om af te drukken? Nou, we zullen zien dat door bijvoeging karakters zoals these-- hello wereld, backslash n dubbele aanhalingstekens, we kunnen printf precies vertellen wat af te drukken op het scherm. 

Maar om te doen dat wij helaas nodig hebben om iets dat te nemen al cryptische om ons mensen, maar in ieder geval is het enigszins readable-- scherpe omvatten standaard io.h, int, main, leegte, printf, alle van de magische bezweringen zagen we gewoon op het scherm. Maar we hebben eigenlijk ga nog meer mysterieus. We moeten eerst de code te vertalen dat we schrijven in machine code. En herinneren van vorige week dat de machines, tenminste degene die we hier kennen, aan het eind van de dag enige begrijpen nullen en enen. 

En mijn God, als we deze schrijven nullen en enen daadwerkelijk programma, Het zou heel, heel snel neem het plezier van om het even wat. Maar het blijkt, per week, dat deze patronen van nullen en enen gewoon hebben een speciale betekenis. In sommige contexten, ze zou kunnen betekenen nummers. 

In sommige contexten, zouden ze betekenen letters of kleuren, of een aantal van andere abstracties daar op. Maar net als uw computer heeft een CPU, Central Processing Unit, of de hersenen binnenkant van uw computer. Het is meestal Intel binnen, want dat is een van de grootste bedrijven dat maakt CPU's voor computers. 

Nou, Intel CPU's en anderen gewoon hebben besloten op voorhand qua 'nullen en degenen stelt specifieke dingen betekenen. Bepaalde patronen van enen en nullen zal betekenen, afdrukken naar het scherm, of voeg deze twee getallen, of aftrekken van deze twee getallen, of verplaats dit stuk van de gegevens uit het geheugen van mijn computer hier, of een aantal andere zeer laag niveau, maar uiteindelijk nuttig, operaties. Maar gelukkig, wij mensen zijn niet van plan nodig hebben om dit niveau van detail te kennen. Inderdaad, net als de vorige keer, waar we geabstraheerde opnieuw, en opnieuw, en opnieuw, de bouw van een zeer laag niveau primitieven zoals nullen en enen naar een hoger niveau concepten dezelfde cijfers en letters, en kleuren, en nog veel meer, dus kunnen wij als programmeurs staan ​​op de schouders van anderen die ons zijn gekomen en het gebruik van software die andere mensen hebben voordat ons-- geschreven namelijk programma's, genaamd compilers. 

C is een taal die gewoonlijk samengesteld, wat betekent omgezet van broncode machine code. Met name wat dit betekent is dat als je hebt je bron gekregen code die je zelf schrijft, als we binnenkort zal in slechts een moment op het scherm, en je wilt om te zetten uiteindelijk tot machine code-- die nullen en enen dat alleen je Mac of pc understands-- je hebt een eerste voeden dat source code in als ingevoerd in een speciale programma genaamd een compiler, de uitgang waarvan we zullen zien is machinecode. En inderdaad, de laatste keer dat we spraken over, echt, aan het eind van de dag, probleemoplossing. Je hebt ingangen. En je hebt uitgangen. En je hebt een soort gekregen algoritme in het midden. 

Algoritmen kan zeker worden geïmplementeerd in software, zoals we zagen met pseudocode vorige week en zoals we zullen zien met de werkelijke code deze week. En dus een compiler eigenlijk alleen maar heeft een set van algoritmen binnen ervan die weten hoe ze omzetten van de speciale trefwoorden, als belangrijkste, en printf, en anderen dat we net zag in de patronen van nullen en degenen die Intel inside en andere CPU daadwerkelijk begrijpt. Dus hoe kunnen we dit doen? Waar halen we een compiler? 

De meesten van ons hier een Mac of een pc. En je draait Mac OS, of Windows of Linux of Solaris, of elk aantal andere besturingssystemen. En inderdaad, we konden ga uit op het web en downloaden van een compiler voor je Mac of pc voor uw specifieke besturingssysteem. Maar we zouden allemaal op verschillende pagina's, om zo te zeggen. We zouden iets hebben verschillende configuraties. En de dingen zouden niet allemaal hetzelfde werken. En inderdaad, deze dagen velen van ons niet gebruiken software die draait alleen op onze laptops. In plaats daarvan gebruiken we iets zoals een browser die stelt ons in staat om toegang te krijgen op het web gebaseerde applicaties in de cloud. En later dit semester, zullen we precies dat doen. We zullen applicaties te schrijven of software met behulp van code-- niet C, maar andere talen zoals Python en JavaScript-- die worden uitgevoerd in de cloud. 

En dat doen wij onszelf tijdens het semester ook daadwerkelijk gebruik maken van een cloud-gebaseerde milieu bekend als CS50 IDE. Dit is een web-based programmeren milieu, of geïntegreerde ontwikkeling milieu, IDE, dat is gebouwd bovenop een aantal open source software genaamd Cloud 9. En we hebben een aantal pedagogische gemaakt vereenvoudigingen te om bepaalde functies in te verbergen de eerste weken dat we niet nodig hebben, waarna je kunt onthullen hen en doen de meeste alles wat je wilt met de omgeving. 

En het stelt ons ook om pre-installatie van bepaalde software. Dingen zoals een zogenaamd CS50 bibliotheek, die we binnenkort zullen zien geeft ons in C met een aantal extra functionaliteit. Dus als je naar, uiteindelijk, CS50.io, wordt u gevraagd om in te loggen, en zodra je en maak een account gratis, bent u in staat om toegang te krijgen tot een zal zijn omgeving die ziet er heel graag dit. 

Nu, dit is in de standaardmodus. Alles is mooi en helder op het scherm. Velen van ons hebben een gewoonte van werken aan CS50 stuk dat is vrij laat in de nacht. En dus sommige van jullie misschien de voorkeur aan zet hem in nachtmodus, om zo te zeggen. 

Maar uiteindelijk, wat je bent gaan zien binnen CS50 IDE drie afzonderlijke areas-- een gebied aan de linkerkant, waar uw bestanden zullen worden in de wolk, een gebied in de rechterbovenhoek waar uw code zal worden bewerkt. Je zult in staat om te openen individuele tabbladen voor elk programma dat je binnen dit schrijf semester van die rechter bovenhoek. En dan de meeste arcanely, en toch krachtig, gaat dit ding aan het worden bodem bekend als een terminal-venster. 

Dit is een oude school Command Line Interface, of CLI, waarmee je opdrachten uit te voeren de computer-- in casu de computer in de cloud-- om dingen zoals compileren uw code te doen vanuit de broncode naar machine code, om uw programma's te draaien, of om te beginnen met uw webserver, of om toegang te krijgen tot de database, en een aantal andere technieken dat we beginnen te gebruiken voordat lang. Maar om er te komen, we zijn gaat eigenlijk om online te gaan en beginnen te spelen. En om dat te doen, laten we eerst beginnen sleutelen aan de belangrijkste, en schrijf het hoofddeel van het programma. En laten we gebruik maken van die functie printf, die we eerder gebruikt, gewoon om iets te zeggen. 

Dus hier ben ik al binnenkant van CS50 IDE. Ik heb ingelogd op voorhand. En ik volledig gescreend het raam. En dus, uiteindelijk, je Ook in de komende problemen zal soortgelijke stappen volgen, dat zal online documentatie. U hoeft dus geen zorgen te maken over absorberen van elke kleine technische stap dat doe ik hier vandaag. 

Maar je zult een scherm zoals dit te krijgen. Ik toevallig in de nachtmodus. En je kunt alles fleuren up door het uitschakelen van de nachtmodus. En aan het einde van de dag, zul je zien deze drie belangrijkste areas-- het bestand browser links, de code tabbladen bovenin, en het terminalvenster onderaan. 

Laat me ga je gang en schrijf mijn eerste programma. Ik ga om preventief te gaan naar Bestand, Save, en sla mijn dossier als hello.c. Sterker nog, volgens afspraak, elk programma dat we schrijven dat is geschreven in de taal C moet iets worden genoemd dot c, volgens afspraak. Dus ik ga om het te noemen hello.c, omdat Ik wil alleen maar hallo tegen de wereld te zeggen. Nu ga ik om te vergroten out en klik op Opslaan. En alles wat ik heb hier nu een tab waar kan ik beginnen met het schrijven van code. 

Dit is niet van plan om te compileren. Dit betekent niets. En dus zelfs als ik bekeerd dit nullen en enen, de CPU zal geen hebben idee wat er gaande is rond. Maar als ik lijnen te schrijven die niet overeenkomen met conventions-- C wezen C's, nogmaals, dit language-- met syntax zoals dit, printf hallo wereld-- en ik heb gotten comfortabel met dit te doen in de tijd. Dus ik denk niet dat ik gemaakt eventuele typefouten. 

Maar, onveranderlijk, de allereerste keer dat je dit doet, zal je. En wat ik nu ga doen zou zeer ook niet voor de eerste keer. En dat is perfect in orde, want nu je misschien gewoon zien een heleboel nieuwheid, maar na verloop van tijd als je eenmaal bekend bent met deze omgeving, en deze taal, en anderen, zult u beginnen om dingen te zien dat zijn ofwel juist of onjuist. 

En dit is wat de onderwijs fellows en natuurlijk assistenten krijgen zo goed in de loop der tijd, wordt spotten fouten of bugs in de code. Maar ik beweren dat er zijn geen bugs in deze code. Dus wil ik nu om dit programma uit te voeren. 

Nu op mijn eigen Mac of pc, ik ben in de gewoonte van te dubbelklikken pictogrammen wanneer ik wil een aantal programma uit te voeren. Maar dat is niet het model hier. In deze omgeving, dat is CS50 IDE. Wij maken gebruik van een besturingssysteem systeem genaamd Linux. Linux doet denken aan een ander besturingssysteem, algemeen bekend Unix. En Linux is vooral bekend om het hebben van een Command Line Milieu, CLI. Nu, we zijn met behulp van een specifieke smaak van Linux genaamd Ubuntu. En Ubuntu is gewoon een bepaalde versie van Linux. 

Maar deze Linux doen deze dagen eigenlijk komen met grafische user interfaces. En degene die we toevallig hier worden gebruikt, is web-based. Dus dit zou zelfs een blik beetje anders dan iets je jezelf zou kunnen hebben gezien of draaien in het verleden. 

Dus ik ga om verder te gaan nu en doe het volgende. Ik heb dit bestand als hello.c opgeslagen. Ik ga om te gaan en Type clanghello.c Dus Clang de taal C is een compiler. Het is vooraf geïnstalleerd in CS50 IDE. En je kunt absoluut downloaden installeer dit op je eigen Mac of pc. 

Maar, nogmaals, zou je niet al hebben de pre-configuratie voor u gedaan. Dus voor nu, ik ben gewoon gaat clanghello.c draaien. En let nu op deze syntaxis hier zal uiteindelijk beseffen betekent dat ik in een map of directory met de naam Workspace. Dit dollarteken is enkel conventie naar betekenis, typt u uw commando's hier. 

Het is wat heet een prompt, net Volgens afspraak is dollarteken. En als ik nu ga je gang en klik op Enter, lijkt er niets te zijn gebeurd. Maar dat is eigenlijk een goede zaak. Hoe minder er gebeurt op uw scherm, hoe groter de kans uw code is juist te zijn, tenminste syntactisch. 

Dus als ik wil dit uitvoeren programma, wat moet ik doen? Nou, het blijkt dat de standaardnaam volgens afspraak voor programma's als je niet opgeeft een naam van uw programma is gewoon a.out. En deze syntaxis ook, zul je vertrouwd te raken met het duurde niet lang. 

Dot slash betekent gewoon, hey, CS50 IDE, uitvoeren van een programma genaamd a.out Dat is in mijn huidige directory. Dat stip betekent dat de huidige directory. En we zullen zien wat andere dergelijke sequenties tekens betekent dat duurde niet lang. 

Dus hier gaan we, Enter, hello wereld. En je zult merken, dat wat is er gebeurd? Niet alleen heeft het af te drukken hello wereld. Het bewoog ook de cursor naar de volgende regel. 

En waarom was dat? Wat was de code die we eerder schreven dat ervoor gezorgd dat de cursor zou Ga op de volgende regel? Grappig ding over een computer is dat het alleen maar letterlijk doen wat je hem vertelt wat te doen. 

Dus als je het vertellen printf hello, komma, ruimte, wereld, in de buurt citaat, Het is letterlijk alleen maar die tekens afgedrukt. Maar ik had deze bijzondere karakter aan het eind, rappel, backslash n. En dat is wat verzekerd dat het karakter ging naar de volgende regel van het scherm. 

In feite, laat me gaan en dit te doen. Laat me gaan en deze te verwijderen. Nu, merken dat de bovenkant van mijn scherm is er een beetje rood licht in het tabblad aangeeft, hey, je hebt niet het bestand opgeslagen. Dus ik ga om te gaan met controle S of commando S, sla het bestand op. Nu goes-- ging voor een moment-- green. En nu is het terug naar gewoon een nauwe icoon. 

Als ik nu weer te lopen clanghello.c, Enter, dot slash, a.out, Enter, je zult zien dat het nog steeds gewerkt. Maar het is misschien wel een beetje buggy. Op dit moment, mijn prompt-- werkruimte, en dan dat dollarteken, en dan mijn werkelijke prompt-- is allemaal op dezelfde lijn. Dus dit zeker een esthetische bug, ook al is het niet echt een logische bug. 

Dus ik ga om ongedaan te maken wat ik net deed. Ik ga a.out opnieuw uit te voeren. Let op, ik heb toegevoegd de newline karakter terug. Ik heb het bestand opgeslagen. 

Dus ik ga a.out opnieuw uit te voeren, en-- dammit, een bug, een bug betekent vergissing. Dus de bug is dat hoewel Ik voegde de backslash n daar, re-opgeslagen, opnieuw liep het programma, het gedrag was hetzelfde. Waarom zou dat zijn? 

Ik mis een stap, toch? Die belangrijke stap eerder was dat je hebt to-- wanneer u uw source code te wijzigen, het blijkt ook draaien het door de compiler weer zo krijg je nieuwe machine code. En de machine code, de nullen en enen, zullen bijna identiek zijn, maar niet perfect, want we nodig hebben, natuurlijk, dat nieuwe regel. 

Dus om dit op te lossen, ga ik nodig naar clanghello.c opnieuw uit te voeren, in te voeren, dot slash, a.out. En nu, hello wereld is terug naar waar ik verwacht dat het is. Dus dit is allemaal prima en goed. Maar a.out is een vrij domme naam voor een programma, hoewel het zo uitkomt om historische redenen, de default-- betekent assemblage uitgangen. 

Maar laat me hier ga je gang en anders doen dit. Ik wil dat mijn programma Hello World om daadwerkelijk te hello genoemd. Dus als het ware een icoon op mijn desktop, zou het niet worden a.out. Het zou hallo genoemd. 

Dus om dit te doen, zo blijkt dat Clang, net als vele programma's, ondersteunt command line argumenten, of vlaggen, of schakelaars, die eenvoudig te beïnvloeden zijn gedrag. In het bijzonder, Clang ondersteunt een streepje o vlag, die vervolgens met een tweede woord. In dit geval zal ik willekeurig, maar redelijk, noem het hello. Maar ik zou kunnen noemen om het even wat Ik wil, behalve a.out, die plaats naast het punt zou zijn. 

En dan gewoon geeft u de naam van het bestand dat ik wil compileren. Dus nu ook al aan het begin van de opdracht heb ik nog steeds Clang, Aan het einde van de opdracht Ik heb nog steeds de bestandsnaam, Ik heb nu deze command line argumenten, deze vlaggen die zeggen, oh, door de manier, output-o, een bestand riep hallo, niet de standaard a.out. 

Dus als ik druk op Enter nu, niets lijkt te zijn gebeurd. En toch, nu kan ik dot slash doen hallo. Dus het is hetzelfde programma. De nullen en enen zijn identiek aan het eind van de dag. 

Maar ze zijn in twee verschillende files-- a.out, dat de eerste versie en gewoon dom genoemd, en nu hallo, wat een veel aantrekkelijker naam voor een programma. Maar, eerlijk gezegd, ik ben nooit gaat dit opnieuw te herinneren, en opnieuw, en opnieuw. En, eigenlijk, als we schrijven meer ingewikkelde programma's, de opdrachten die u bent gaat te hebben om te schrijven gaan om wraak te nemen meer gecompliceerd nog steeds. 

En dus geen zorgen te maken. Het blijkt dat mensen eerder wij hebben ook zij gerealiseerd had exact hetzelfde probleem. Ook zij vond het niet te hoeven typt vrij lang, geheimzinnige commando's, laat staan ​​hen herinneren. En dus mensen vóór ons hebben gemaakt Software die het makkelijker om uw software te compileren. 

En inderdaad een dergelijke programma heet te maken. Dus ik ga om te gaan en dit te doen. Ik ga alles ongedaan te maken I net deed op de volgende manier. Laat me het type LS. En je zult merken drie things-- a.out, en een ster, hello en een ster, en hello.c. Hopelijk moet dit een beetje intuïtief, voorzover eerder was niets in deze werkruimte. Er was niets dat ik had gemaakt totdat we klasse begonnen. 

En ik heb gemaakt hello.c. dan heb ik gecompileerd, en noemde het a.out. En vervolgens samengesteld ik het weer licht anders en noemde het hallo. Dus ik heb drie bestanden in deze map, in deze map genaamd Workspace. Nu, ik kan zien dat ook als ik uitzoomen eigenlijk. 

Als ik hier te zoomen en kijk naar die rechtsboven hoek, zoals beloofd de linker kant van het scherm gaat altijd om te laten zien wat er in je account, wat is binnenkant van CS50 IDE. En er is drie bestanden daar. 

Dus ik wil om zich te ontdoen van a.out en hallo. En zoals je misschien stel intuïtief, je kan sorteren of control click of klik met de rechtermuisknop op dit punt. En deze kleine menu verschijnt. U kunt het bestand te downloaden, lopen het, een voorbeeld van het, vernieuwen, hernoemen, of wat al niet. 

En ik kon gewoon verwijderen, en het zou weggaan. Maar laten we dingen doen met een opdracht lijn voor nu, om zo comfortabel te krijgen met dit, en doe het volgende. Ik ga om te gaan en te verwijderen a.out door te typen letterlijk rma.out. Het blijkt, de opdracht voor verwijderen of iets te verwijderen, is niet te verwijderen of te verwijderen. 

Het is beknopter RM, gewoon om te besparen u enkele toetsaanslagen, en druk op Enter. Nu gaan we wat te zijn cryptisch verwijderen reguliere file a.out. Ik weet niet echt wat een onregelmatige bestand nog zou zijn. Maar ik wil om het te verwijderen. 

Dus ik ga naar het type van Y voor ja. Of ik kon het uittypen, en druk op Enter. En, nogmaals, niets lijkt te gebeuren. Maar dat is, over het algemeen, een goede zaak. 

Als ik LS typ deze keer, wat moet ik zien? Hopelijk gewoon hallo en hello.c. Nu, als een terzijde, zul je merkt deze ster, sterretje, dat aan het einde van mijn programma. En ze zijn ook weergegeven in het groen. Dat is gewoon CS50 IDE's weg van cluing je in het feit dat dat niet de broncode. Dat is een uitvoerbaar, een uitvoerbare programma dat je daadwerkelijk kunt draaien door het doen van dot slash, en dan is het de naam. 

Nu, laat me ga je gang en verwijder dit, rm hello, Enter, verwijderen regelmatige file hello, ja. En nu als ik typ LS, We zijn terug naar hello.c. Probeer niet te verwijderen van uw eigenlijke broncode. Ook al zijn er functies ingebouwd in CS50 IDE, waar kunt u via uw revisiegeschiedenis en terugspoelen in de tijd als je per ongeluk iets te verwijderen, doen rekening te houden volgens deze prompts ja of nee, van wat je eigenlijk wilt doen. En als ik ga naar de top linkerhoek hier, alles wat overblijft is hello.c. Dus er is trossen andere opdrachten die u kan uitvoeren in de wereld van Linux, een daarvan is, wederom, maken. En we gaan maken mijn programma nu als volgt uit. 

In plaats van het doen van Clang, in plaats van het doen van clang-o, Ik ga gewoon letterlijk type, merk hello. En nu ziet, ik ben niet typen maken hello.c. Ik ben het typen maken hallo. 

En dit programma te maken dat wordt geleverd met CS50 IDE, en nog veel meer meestal met Linux, is een programma dat gaat om een ​​programma genaamd Hallo te maken. En het gaat om aan te nemen, volgens afspraak, dat als dit programma kan worden gemaakt, het zal worden gemaakt van een bron code bestand dat eindigt op punt c, hello.c. 

Dus als ik druk op Enter nu, merken dat de opdracht die wordt uitgevoerd is eigenlijk nog langer eerder dan voorheen. En dat is omdat we hebben voorgeconfigureerde CS50 IDE te hebben een aantal extra functies ingebouwd in dat we nog gewoon niet nodig hebt, maar binnenkort wel. Maar het belangrijkste ding om te beseffen is nu heb ik een Hallo programma. 

Als ik typ LS nogmaals, ik hebben een hello programma. En ik kan het uit te voeren met dot slash a.out, nee, omdat het hele punt van deze oefening was dot slash hallo. En nu heb ik mijn programma Hello World. Dus vooruit, we bijna altijd gewoon gaan om onze programma's te compileren met de opdracht te maken. En dan gaan we ze uit te voeren door dot slash en de naam van het programma. Maar beseffen wat maken doet voor u, is het dan niet zelf een compiler. Het is gewoon een gemak programma die weet hoe je een compiler triggeren zo lopen dat je jezelf kunt gebruiken. 

Welke andere opdrachten bestaan Linux, en op zijn beurt de CS50 IDE? We zullen snel zien dat er een CD commando Change Directory. Hierdoor kunt u binnen je command line interface om vooruit te komen, en weer terug, en open verschillende mappen zonder gebruik te maken van uw muis. 

LS we zagen, wat staat voor lijst de bestanden in de huidige directory. Maak Dir, kunt u waarschijnlijk beginnen te concluderen wat deze betekenen now-- directory te maken, als je wilt naar een map te maken. RM voor verwijdert, RM Dir voor verwijderen directory-- en deze, nogmaals, zijn de command line equivalenten van wat je kon doen in CS50 IDE met je muis. Maar je zult al snel merken dat soms is het gewoon een stuk sneller te doen dingen met een toetsenbord, en uiteindelijk een stuk krachtiger. 

Maar het is moeilijk om te betogen dat alles wat we hebben gedaan tot nu toe is alles wat krachtig, wanneer alle wij hebben gezegd is, hello wereld. En, in feite, ik hardcoded de woorden hello wereld in mijn programma. Er is nog geen dynamiek. Scratch was een orde van grootte interessanter vorige week. 

En dus laten we daar te komen. Laten we eens een stap in de richting die door manier van sommige van deze functies. Dus niet alleen C worden geleverd met printf, en bossen van andere functies waarvan sommige we zullen zien na verloop van tijd, is het niet maken het allemaal zo gemakkelijk direct uit van de poort bij het verkrijgen van gebruikersinvoer. 

In feite is één van de tekortkomingen van talen als C, en zelfs Java en toch anderen, is dat het niet doet maken het gemakkelijk om gewoon dingen zoals gehele getallen van gebruikers of koorden, woorden, en zinnen, laat staan ​​zaken als floating point waarden, of reële getallen met cijfers na de komma, en echt lange nummers, zoals we binnenkort zullen zien. Dus deze lijst met functies hier, deze zijn net als andere Scratch puzzelstukjes die we hebben vooraf geïnstalleerd in CS50 IDE die we zullen gebruiken voor een paar weken als zijwieltjes van soorten, en uiteindelijk nemen ze af, en kijk onder de motorkap, misschien op hoe deze dingen worden toegepast. 

Maar om dit te doen, laten we eigenlijk een programma schrijven. Laat me nu ga je gang. En ik ga een nieuw te creëren bestand door te klikken op deze kleine plus, en te klikken op Nieuw bestand. 

Ik ga naar deze volgende besparen een als, laten we zeggen, string.c, want ik wil spelen met strijkers. En string in de C is gewoon een reeks tekens. Dus laten we nu doorgaan en doe het volgende. 

Zijn standaard IO.h-- en het blijkt standaard IO, IO betekent gewoon input en output. Dus het blijkt dat deze lijn hier is wat wordt het naastgelegen ons printf gebruiken. Printf natuurlijk uitvoer levert. Dus om printf gebruiken, zo blijkt out moet je deze regel code hebben op de top van uw dossier. 

En we zullen terugkomen naar wat dat betekent echt het duurde niet lang. Het blijkt dat in elke C programma dat ik schrijf, Ik heb om het te starten met code die er zo uitziet. En je zult merken CS50 IDE, en andere geïntegreerde ontwikkeling omgevingen zoals het, gaan zo goed proberen ze kunnen om je gedachten af ​​te maken. In feite, een ogenblik geleden als ik het ongedaan maken wat ik net deed, ik druk op Enter. 

Ik raak geopend krullend brace, sloeg weer op Enter. En het klaar met mijn gedachte. Het gaf me een nieuwe regel, ingesprongen niet minder voor sfeervolle stilistische redenen zien we wel. En dan is het automatisch gaf me dat accolade aan mijn gedachten af ​​te maken. Nu, is het niet altijd raden wat je wilt doen. Maar grotendeels, doet bespaart u toetsaanslagen. Dus even geleden, liepen we dit program-- hello, wereld, en dan gecompileerd, en dan liep het. Maar er is geen dynamiek hier. Wat als we wilden iets anders te doen? Nou, wat als ik wilde eigenlijk krijgen een string van de gebruiker? Ik ga een puzzelstukje te gebruiken riep precies dat-- snaar te krijgen. 

Blijkt in C dat als je niet wilt een bijdrage te leveren aan een puzzelstukje, of meer naar behoren aan een functie, je letterlijk gewoon open haakje, haakje sluiten. Dus het is alsof er geen witte doos te typen in. De inspraak blok vóór had een kleine witte doos. We nu niet hebben dat witte doos. 

Maar als ik bel get koord, I willen het resultaat ergens te zetten. Dus een veel voorkomende paradigma in C is bel een functie, zoals get touwtje hier, en bewaar de return waarde. Het is het gevolg van de inspanning in iets. 

En wat is de bouwen in de programmering, hetzij in Scratch of nu C, dat we kunnen gebruiken om daadwerkelijk iets te slaan? Noemde het een variabele, toch? En in Scratch, dat doen we niet echt schelen wat er gaande was in variabelen. 

Maar in dit geval, we eigenlijk doen. Ik ga naar een string te zeggen. En toen kon ik noem dit wat ik wil. Ik ga noemen naam, krijgt te krijgen string. 

En nu zelfs als je een beetje new to this, opmerken dat ik weinig detail. Ik ben het vergeten van een puntkomma. Ik moet deze gedachte af te maken. Dus ik ga mijn cursor te verplaatsen, en sloeg puntkomma daar. En wat heb ik net gedaan? In deze lijn van code, nummer 5 op dit moment, Ik bel get snaar zonder ingangen. Dus er is geen kleine witte doos zoals het blok Save heeft. 

Ik zeg alleen maar, hey, computer, geef me een string. Het isgelijkteken is niet echt een isgelijkteken, per se. Het is de opdracht operator, wat betekent, hey, computer, verplaats de waarde van rechts naar links. En in de linker, heb ik het volgende. 

Hey, computer, geef me een string-- een reeks tekens. En noem die string Name. En ik heb niet eens te noemen Naam. 

Ik zou kunnen noemen, conventioneel, zoiets als S, net zoals we gewend i te bellen met de variabele i. Maar nu moet ik iets mee doen. Het zou nogal dom te zijn probeer het samenstellen van deze code, hardlopen Dit programma, hoewel Ik krijg een string, want het is nog steeds gewoon gaan om hallo te zeggen wereld. 

Maar wat als ik wil dit veranderen. Waarom ik dit doe? Procent s, komma s. En dit is nog steeds een beetje cryptisch. 

Dus laat me mijn variabelen duidelijker te maken. Laat ik noem deze variabele Naam. En laten we kijken of we niet kunnen plagen behalve wat hier gebeurt. 

Dus op lijn vijf, krijg ik een string. En ik ben het opslaan van die string, ongeacht de gebruiker heeft getypt op zijn of haar toetsenbord, in een variabele met de naam naam. En het blijkt dat printf niet alleen neem een ​​argument in dubbel citaten, één ingang tussen dubbele aanhalingstekens. 

Het kan twee, of drie, of meer, zoals nemen dat de tweede of derde of vierde, zijn de namen van alle variabelen, of specifiek waarden, die u wilt aan te sluiten op, dynamisch, die string in aanhalingstekens. Met andere woorden, wat mis met deze zou zijn? Als ik net zei hello naam, backslash n, redde mijn dossier, opgesteld mijn code, en liep dit, wat er zou gebeuren? 

Het gaat gewoon om te zeggen, hello naam, letterlijk N-A-M-E, dat is een soort van dom omdat het is niet anders uit de wereldgeschiedenis. Dus alles tussen aanhalingstekens is wat letterlijk wordt afgedrukt. Dus als ik wil hebben een placeholder daar, Ik moet eigenlijk te gebruiken een aantal speciale syntax. En het blijkt dat als je leest het documentatie voor de printf functie, het zal u vertellen dat als je gebruik maakt procent s, U kunt een waarde vervangen als volgt. 

Na een komma daarna dubbele aanhalingstekens, je gewoon de naam van de variabele die u wilt aan te sluiten in dat formaat code, of format specifier, procent s voor strijkers. En nu als ik heb mijn bestand op te slaan, Ik ga terug naar mijn terminal. En ik typ Maak String, omdat wederom de naam van deze bestand dat ik koos voor is string.c. 

Dus ik ga zeggen Maak String, in te voeren. Oh mijn god, kijk naar alle de fouten die we al hebben gemaakt. En dat is-- wat, dit is echt zoals een zes, zeven line programma? Dus dit is waar het zeer kan snel overweldigend. 

Deze terminal venster heeft nu slechts uitgebraakt een groot aantal foutmeldingen. Zeker, heb ik niet meer fout berichten dan ik regels code. Dus wat is er aan de hand? 

Nou, de beste strategie om op elk moment heb je heb ontmoet een overweldigende lijst met fouten als dat, is terug te bladeren, op zoek naar het commando je gewoon liep, wat in mijn geval is het maken van string. Kijk naar wat maken deed, en dat is dat lang Clang bevel, geen big deal daar. 

Maar de rode is slecht. Groen probeert te vriendelijk en behulpzaam. Maar het is nog steeds slecht, in dit geval. Maar waar is het slecht? 

String.c, lijn vijf, karakter vijf. Dus dit is gewoon gezond conventie. Iets colon iets betekent lijnnummer en karakter nummer. Fout, het gebruik van niet-aangegeven identifier string. Bedoelde u standaard in bedoelt? 

Dus, helaas, Clang probeert om behulpzaam te zijn. Maar het is verkeerd, in dit geval. Nee, Clang, ik bedoelde niet standaard IO. Ik bedoelde dat op lijn één, ja. 

Maar lijn vijf is dit hier. En Clang niet begrijpen S-T-R-I-N-G. Het is een gedeclareerde identifier, een word het gewoon nog nooit eerder gezien. En dat komt omdat C, de taal we zijn het schrijven van code in op dit moment, niet variabelen genoemd snaren. 

Het maakt niet standaard, steun zoiets als een string. Dat is een stuk van de CS50 jargon, maar zeer conventioneel. Maar ik kan dit als volgt op te lossen. 

Als ik voeg een regel code naar de top van dit programma, omvatten CS50.h, dat is een ander bestand ergens binnenkant van CS50 IDE, ergens op de harde schijf, om zo te zeggen, van het Ubuntu-besturingssysteem dat ik ben bijna, dat is het bestand dat is gaan naar de operatiekamer te onderwijzen systeem wat een string is, net als standaard io.h is het bestand in het besturingssysteem dat is gaan om het te leren wat printf is. 

Sterker nog, we zouden hebben gekregen een vergelijkbaar bericht Als IO standaard had toegegeven IO.h en probeerde te printf gebruiken. Dus ik ga je gang en gewoon gaan Take Control L naar mijn scherm te wissen. Of je kunt duidelijk typen en het zal gewoon duidelijk de terminal-venster. Maar je kunt nog steeds schuiven terug in de tijd. 

En ik ga opnieuw uit te voeren maken String. Kruis mijn vingers deze keer, Enter. Oh mijn god, het werkte. het toont me een lange cryptische opdracht dat is wat Zorg gegenereerd via Clang, maar geen foutmeldingen. Dus realiseren, terwijl je zou helemaal te krijgen overweldigd door de aantal foutmeldingen, het misschien gewoon dit vervelende cascading zijn effect, waarbij Clang niet begrijpt één ding, wat betekent dat het dan begrijpt niet het volgende woord, of de volgende regel. En zo is het gewoon verslikt zich in uw code. Maar de oplossing kan eenvoudig zijn. En dus altijd gericht op de allereerste regel uitvoer. En als je dat niet doet begrijpen, kijk maar voor zoekwoorden die zou kunnen zijn aanwijzingen, en het lijnnummer, en het karakter, waar de die fout zou kunnen zijn. 

Laat me nu ga je gang en typ dot slash, koord, in te voeren. Hm, het is niet te zeggen hallo niets. Waarom? Nou, herinneren, waar is het draait? 

Het is waarschijnlijk vast te zitten op het moment in een lus, als je wil, op lijn zes, omdat Get String door het ontwerp, geschreven door CS50 personeel, is letterlijk bedoeld om gewoon zitten daar te wachten, en wachten, en wachten op een koord. Alle bedoelen we door string is mensenwerk. Dus weet je wat? Laat me ga je gang. En net op een bevlieging, laat me typ mijn naam, David, in te voeren. Nu heb ik een meer dynamisch programma. Het zei, hallo David. 

Als ik ga je gang en voer dit opnieuw, laat me proberen zeggen Zamila, voer. En nu hebben we een dynamisch programma. Ik heb niet hard gecodeerde wereld. Ik heb niet hard gecodeerde te noemen, of David, of Zamila. 

Nu is het veel meer als de programma's wij weten, waar als het te nemen input, produceert iets andere uitgang. Nu, dit is niet de beste user experience, of UX. Ik run het programma. 

Ik weet niet wat ik moet te doen, tenzij ik eigenlijk kijken of denk aan de broncode. Dus laten we de gebruiker ervaring een beetje beter met de eenvoudigste dingen. Laat me terug te gaan naar deze programma, en gewoon zeggen printf. 

En laat me ga je gang en zeg naam, dikke darm, en een spatie en vervolgens een puntkomma. En net voor de lol, geen speling n. En dat is opzettelijk, omdat ik niet wil de prompt om naar de volgende regel. 

Ik wil in plaats daarvan dit doen, maken koord mijn code in nieuwe machine opnieuw te compileren code dot slash string. Ah, dit is veel mooier. Nu heb ik eigenlijk weten wat de computer wil dat ik doe, geef het een naam. 

Dus ik ga om verder te gaan en typ in Rob, voer, en hallo, Rob. Dus, realiseren, dit nog steeds aan het einde van de dag, slechts negen line programma. Maar we hebben deze kleine stapjes genomen. 

We schreven een regel waarmee we waren bekend, printf, hello wereld. Dan ongedaan we een beetje van dat. En we eigenlijk wennen string. En we gooiden die waarde in een variabele. En toen gingen we verder en verbeterd het verder met een derde lijn. En dit iteratieve proces het schrijven van software is echt sleutel. In CS50, en in het leven in het algemeen, moet je over het algemeen niet zitten, hebben een programma in het achterhoofd, en probeer het schrijven de hele verdomde ding allemaal tegelijk. 

Het zal onvermijdelijk leiden tot manier meer fouten dan wij ons hier zagen. Zelfs ik, tot op de dag, voortdurend maak andere domme fouten, zijn eigenlijk moeilijker fouten die zijn moeilijker te achterhalen. Maar u zult meer fouten meer maken regels code schrijf je alles in één keer. En dus is deze praktijk, Schrijf een klein stukje code dat je prettig bij voelt, compileren het, voer het uit, test het meer in het algemeen, verplaats on-- dus net als wij blijven gelaagdheid en gelaagdheid van vorige week, het bouwen van iets heel eenvoudig iets ingewikkelder, hier doen hetzelfde. Ga niet zitten, en probeer te schrijf een hele probleem. Eigenlijk neem deze kleine stapjes. 

Nu, strings zijn niet allemaal die bruikbaar zijn op zich. We zouden eigenlijk, idealiter, was gelijk hebben iets anders in onze toolkit. Dus laten we eigenlijk precies dat te doen. 

Laat me nu ga je gang en zweep een iets ander programma. En we zullen dit int.c noemen, want integer. Ik ga, net, omvatten CS550.h. Ik ga standaard IO bevatten. En dat gaat vrij normaal te zijn in deze eerste dagen van de klas. 

En ik ga klaar mij met een hoofdfunctie. En nu in plaats van om een ​​koord, laten we ga je gang en krijg een int. Laten we noemen het i, en noemen het krijgen int, dicht parens, puntkomma. En laten we nu doen iets mee, printf. 

Laten we zeggen dat iets dergelijks hello, backslash n, komma i. Dus ik ben vrij veel nabootsen wat ik deed slechts een moment geleden. Ik heb een placeholder hier. Ik heb ik hier komma, want ik wil tot ik de stekker in die placeholder. 

Dus laten we gaan vooruit en proberen het samenstellen van dit programma. Het bestand heet int.c. Dus ik ga zeggen, maken int, in te voeren. Oh, mijn God, maar geen big deal, toch? Er is een vergissing. 

Er is een syntactische fout hier zodanig dat het programma niet kan worden opgesteld binnen int.c, lijn zeven, karakter 27, error-formaat specificeert het type char ster, wat dat ook is. Maar het argument type is int. 

Dus ook hier, we gaan niet to-- ook al is vandaag de dag is veel materiaal, we gaan je overdonderen met absoluut elke eigenschap van C, en programmeren algemeen, in alleen deze eerste paar weken. Dus er wordt vaak gaat worden jargon waarmee je niet vertrouwd bent. En inderdaad, char ster iets we gaan om terug te komen in een week of twee de tijd. 

Maar voor nu, laten we eens kijken of we kunnen ontleden woorden die vertrouwd zijn. Formats-- dus hoorden we formaat specifier, formaat code voor. Dat is bekend. Motortype- maar het argument type int. Wacht even, ik is een int. 

Misschien procent s eigenlijk heeft een aantal gedefinieerde betekenis. En inderdaad doet. Een geheel getal, als je wilt printf om het te vervangen, je eigenlijk een te gebruiken ander formaat specifier. En je zou niet weten tenzij iemand die je verteld, of je had het al eerder gedaan. Maar procent i is wat kan gewoonlijk worden gebruikt in printf voor het aansluiten van een integer. U kunt ook gebruik maken procent d voor een decimale integer. Maar ik is mooi en eenvoudig hier. Dus we gaan mee. 

Laat me nu ga je gang en herhaling make int, Enter. Dat is goed, geen fouten. Dot slash int-- OK, slechte gebruikerservaring, omdat ik mezelf niet heb verteld wat moeten we doen. Maar dat is prima. Ik ben het vangen op snel. 

En nu laat ik ga je gang en Typ in David, OK, Zamila, Rob. OK, dus dit is een goede zaak. Deze keer, ik ben met behulp van een functie, een stukje van de puzzel, de zogenaamde get int. En het blijkt out-- en we zullen zie deze later in de term-- de CS50 personeel heeft geïmplementeerd krijgen snaar zodanig dat het zal alleen fysiek krijgen een string voor je. 

Het is get int geïmplementeerd in zodanig dat het zal alleen krijgen een geheel voor u. En als je, de mens, niet meewerken, het is letterlijk gewoon gaan zeggen opnieuw te proberen, opnieuw proberen, opnieuw proberen, letterlijk zitten looping, totdat je verplichten met een aantal magische getal, zoals 50, en hallo 50. 

Of als we lopen dit opnieuw en typ in 42, 42 hello. En dus is de get int functie binnenkant van dat stukje van de puzzel is genoeg logica, genoeg gedachte, om erachter te komen, wat is een woord? En wat is een getal? Alleen accepteren uiteindelijk getallen. 

Zo blijkt dat is niet zo expressief. dusver. Dus, yay, laatste keer dat we ging vrij snel in de uitvoering van games, en animatie, en artistieke werken in Scratch. En hier zijn we tevreden zijn met hello wereld, en hallo 50. 

Het is niet zo inspirerend. En inderdaad, deze eerste voorbeelden zal enige tijd duren om oprit in opwinding. Maar we hebben nog veel meer controle nu, in feite. En we gaan zeer snel aan de slag gelaagdheid op de top van deze fundamentele primitieven. 

Maar laten we eerst begrijpen wat beperkingen. In feite is een van de dingen Scratch niet gemakkelijk laten we doen is echt kijken onder de motorkap, en begrijpen wat een computer is, wat het kan doen, en wat de beperkingen zijn. En inderdaad, dat het gebrek aan begrip, potentieel op lange termijn kan leiden tot onze eigen mistakes-- schrijven bugs, het schrijven van onveilige software die wordt gehackt op een bepaalde manier. 

Dus laten we eens een paar stappen in de richting begrijpen dit een beetje beter door manier, zeg, het volgende voorbeeld. Ik ga om verder te gaan en uit te voeren echt snel een programma genaamd Adder. Net als, laten we een aantal nummers samen te voegen. En ik ga sommige bochten coderen hier, en gewoon kopiëren en plakken waar ik vroeger was, net dus we kunnen krijgen sneller gaan. Dus nu heb ik de basis begin kreeg van een programma genaamd Adder. 

En laten we gaan en dit te doen. Ik ga om te gaan en laten we zeggen, INTX krijgt krijgen int. En weet je wat? Laten we een betere gebruikerservaring. 

Dus laten we gewoon zeggen x is, en effectief vraagt ​​de gebruiker om ons x geven. En laat mij dan ga je gang en zeggen: printf wat dacht je van y is, deze keer verwacht twee waarden van de gebruiker. En dan laten we gewoon doorgaan en bijvoorbeeld printf, de som van x en y. En nu wil ik niet om procent s doen. Ik wil procent i doen, backslash n, en steek de stekker in somwaarde. 

Dus hoe kan ik dat doen? Weet je wat? Ik weet hoe ik variabelen. Laat me verklaren een nieuwe, int z. 

En ik ga een gok hier te nemen. Als er gelijk tekenen in deze taal, misschien kan ik gewoon x plus y doen, zolang ik uiteindelijk mijn dacht met een puntkomma? Nu kan ik terug gaan hier beneden, plug in z, eindigen deze gedachte met een puntkomma. En laten we nu zien, of deze sequenties van lines-- x krijgen int. Y krijgen int. 

Voeg x en y, slaan de waarde in z-- Dus nogmaals, denk aan de gelijk-teken is niet gelijk. Het is opdracht van rechts naar links. En laten we uitprinten dat de som van x en y niet letterlijk z, maar wat is de binnenkant van z. Dus laten we Adder - nice, geen fouten deze keer. Dot slash Adder, in te voeren, x gaat worden 1. 

Y gaat worden 2. En de som van x en y 3. Dus dat is allemaal prima en goed. 

Dus je zou denken dat wiskunde zou moeten werken in een programma als dit. Maar weet je wat? Is deze variabele, lijn 12, zelfs noodzakelijk? U hoeft niet in de gewoonte te krijgen van alleen het opslaan van dingen in de variabelen gewoon omdat je kunt. En, in feite, het is over het algemeen weloverwogen slecht ontwerp als je het creëren van een variabele, genaamd z in dat geval slaan iets in, en dan meteen het gebruik ervan, maar nooit weer. Waarom geven iets een naam als z als je letterlijk gaan gebruiken dat wat slechts een keer, en zo proximale naar de plaats waar u hebt gemaakt het in de eerste plaats, zo dicht in termen van regels code? Dus weet je wat? Het blijkt dat C is vrij flexibel. Als ik wil eigenlijk plug-in waarden hier, Ik heb geen behoefte aan een nieuwe variabele verklaren. Ik kon gewoon plug-in x plus y, omdat C begrijpt rekenkundige en wiskundige operatoren. 

Dus ik kan alleen maar zeggen, doe dit math, x plus y, welke deze waarden, Sluit de resulterende integer in die string. Dus dit zou kunnen zijn, hoewel slechts één lijn korter, een beter ontwerp, een beter programma, omdat er minder code, dus minder voor mij om te begrijpen. En het is ook gewoon schoner, voor zover we niet de invoering van nieuwe woorden, nieuwe symbolen, zoals z, ook al zijn ze niet echt serveren veel van een doel. 

Helaas, wiskunde is niet dat alles betrouwbaar soms. Laten we gaan en dit te doen. Ik ga om verder te gaan nu en doe het volgende. 

Laten we het doen printf, i procent, plus procent i, zal procent i, backslash n zijn. En ik ga dit-- xyx plus y doen. Dus ik ga gewoon herschrijven dit iets anders hier. Laat me gewoon een snel sanity check. Nogmaals, laten we niet vooruit lopen. Maak adder, dot slash adder. x is 1, y is 2, 1 plus 2 is 3. Dus dat is goed. Maar laten we nu compliceren deze een beetje, en het creëren van een nieuw bestand. 

Ik ga dit één noemen, zeggen, ints, meervoud van gehele getallen. Laat ik beginnen waar ik daarnet was. Maar nu laten we een paar andere lijnen. Laat me ga je gang en doe het volgende, printf, i procent, minus procent i, is procent i, komma x, komma yx minus y. Dus ik ben een beetje bezig verschillende wiskunde daar. Laten we een ander. Dus procent i tijden procent i procent i, backslash n. Laten we plug-in x en y en x maal y. We zullen het sterretje te gebruiken op uw computer voor tijden. 

U hoeft geen gebruik maken van x. x een variabele naam hier. U gebruikt de ster voor vermenigvuldiging. Laten we nog één. Printf procent I, verdeeld door procent i, is procent i, backslash n. xy gedeeld door y-- zodat je de slash in C gebruiken om verdeeldheid te doen. En laten we één ander. Rest van i procent, verdeeld door procent i, is procent i. xy-- en nu rest is wat er overblijft. Wanneer u het delen van een noemer in een teller, hoeveel er nog over die je kon niet splitsen uit? 

Dus er is niet echt, noodzakelijkerwijs een symbool we hebben in de lagere school gebruikt. Maar in C. U kunt zeggen x modulo y, waarbij Dit procent teken in deze context-- verwarrend als je binnen bent van de dubbele aanhalingstekens, binnenkant van printf, procent wordt gebruikt als het format specifier. 

Wanneer u procent buiten dat in een wiskundige uitdrukking, het is de modulo operator voor modulaire arithmetic-- voor onze doeleinden hier, maar betekent, wat is de restant van x gedeeld door y? Dus x gedeeld door y x y slash. Wat is de rest van x gedeeld door y? Het is x mod y, als programmeur zou zeggen. 

Dus als ik geen fouten gemaakt hier, laat me ga je gang en maak ints, meervoud, aardig, en dot slash ints. En laten we gaan en te doen, laten we zeggen, 1, 10. Oké, 1 plus 10 is 11, check. 1 min 10 negatief is 9, te controleren. 

1 maal 10 is 10, check. 1 gedeeld door 10 is-- OK, we zullen dat overslaan. Rest van 1 gedeeld door 10 is 1. Dat is correct. Maar er is een bug in hier. 

Dus degene die ik mijn overhandigen, niet correct. Ik bedoel, het is dicht bij 0. 1 gedeeld door 10, weet je, als we snijden sommige bochten, zeker, het is nul. Maar het moet echt 1/10, 0,1 of 0,10, 0,1000, of dergelijke. 

Het moet niet echt nul. Nou, het blijkt dat de computer is doen letterlijk wat we te horen dat het te doen. We doen wiskunde als x gedeeld door y. En zowel x en y, volgens de lijnen van de code eerder, zijn gehele getallen. 

Bovendien, op lijn 15, we zijn vertellen printf, hey, printf plug-in een integer, plug-in een integer, plug-in een specifiek integer-- x, y en dan, en dan x gedeeld door y. x en y zijn gehele getallen. We zijn er goed. 

Maar wat is x gedeeld door x? x gedeeld door Y moeten zijn, wiskundig, 1/10 of 0,1, die een reëel getal, een getal hebben, in potentie, een komma. Het is geen geheel getal. 

Maar wat is de dichtstbijzijnde integer naar 1/10 of 0,1? Ja, het soort nul. 0.1 is als dit veel. En 1 is dit veel. Dus 1/10 dichter bij 0 dan is één. 

En dus wat C doet voor ons-- soort, omdat we te horen dat to-- afknotten wordt dat getal. Het is het nemen van de waarde, die weer verondersteld om iets als 0,1000 te zijn, 0 enzovoort. En het is alles beknotten na de komma zodat alles materiaal, omdat het niet reageert passen in het begrip van een integer, die is maar een getal als negatief 1, 0, 1, op en neer, gooit alles weg na de komma, omdat je past niet een komma een integer per definitie. 

Het antwoord hier nul. Dus hoe kunnen we dit oplossen? We moeten een andere oplossing allemaal samen. En we kunnen dit doen, als volgt. 

Laat me ga je gang en maak een nieuwe file, deze zogenaamde floats.c. En sla het hier in de dezelfde directory, float.c. En laat me ga je gang en kopieer een deel van die code uit eerder. 

Maar in plaats van het krijgen een int, laten we dit doen. Geef me een floating point waarde genaamd x. wanneer een drijvende komma waarde is gewoon letterlijk iets met een floating point. Het kan naar links, naar rechts. Het is een reëel getal. 

En laat me niet te bellen krijgen int, maar krijgen vlotter, die ook onder de menu van opties in de C250 bibliotheek. Laten we y veranderen naar een float. Dus dit wordt te krijgen zweven. 

En nu, we willen niet aan te sluiten in ints. Het blijkt dat we moeten procent gebruiken f voor float, procent f voor float, en nu opslaan. En nu, vingers gekruist, maken praalwagens, leuke, dot slash praalwagens. x gaat naar een 1. y zijn Gaat weer 10. 

En, mooi, OK mijn toevoeging is correct. Ik hoopte op meer, maar ik vergat om het te schrijven. Dus laten we gaan en bevestig deze denkfout. 

Laten we doorgaan en pak de volgende. We zullen gewoon een beetje kopiëren en plakken doen. En ik ga minus zeggen. 

En ik ga keer zeggen. En ik ga zeggen verdeeld. En ik ben niet van plan te doen modulo, die niet zo germane hier gedeeld door f, en tijden plus-- Oké, laten we dit opnieuw doen. 

Maak praalwagens, dot slash praalwagens, en 1, 10, en-- mooi, nee, OK. Dus ik ben een idioot. Dus dit is heel gebruikelijk in de informatica tot domme fouten als deze te maken. 

Voor pedagogische doeleinden, wat ik echt wilde doen Hier werd de wetenschap veranderen tot plus, min, de tijden, en hopelijk te verdelen, zoals u opgevallen tijdens deze oefening. Dus laten we nu opnieuw compileren deze programma, doe dot slash praalwagens. 

En voor de derde keer, laten we kijken of het voldoet aan mijn verwachtingen. 1, 10, voer, ja, OK, 1.000, gedeeld door 10.000, is 0,100000. En het blijkt dat we kunnen controleren hoeveel nummers zijn na die cijfers achter de komma. We eigenlijk wil. We zullen hierop terugkomen. 

Maar nu in feite de wiskunde is correct. Dus nogmaals, wat is het hier mee te nemen? Het blijkt dat in C, zijn er niet pas strings-- en, in feite, er zijn niet echt, want we toe te voegen die met de CS50 bibliotheek. Maar er zijn niet alleen ints. 

Er zijn ook drijft. En het blijkt een heleboel andere data types ook, dat we gebruiken het duurde niet lang. Blijkt dat als je wilt een enkele karakter, niet een reeks tekens, je kunt gewoon een char te gebruiken. 

Blijkt dat als je een Bool wilt, een Booleaanse waarde, waar of onwaar alleen, dankzij de CS50 bibliotheek, we hebben toegevoegd aan C de Bool datatype ook. Maar het is ook aanwezig in vele andere talen. En het blijkt dat je soms moet grotere aantallen dan komen standaard met ints en praalwagens. 

En in feite een dubbele een getal dat gebruik maakt van niet 32 ​​bits, maar 64 bits. En een lange lange is een nummer dat maakt niet 32, maar 64-bits bits, respectievelijk voor floating point waarden en getallen respectievelijk. Dus laten we nu eigenlijk Kijk hoe dit werkt. 

Ik ga hier verder te gaan en opkloppen een ander programma. Hier ga ik om verder te gaan en niet bevatten CS50.h. En laat me gaan, zijn onder andere standaard io.h. 

En je zult iets opmerken funky gebeurt hier. Het is niet kleurcodering dingen in op dezelfde wijze als voorheen. En het blijkt, dat komt omdat ik hebben het ding een bestandsnaam niet gegeven. 

Ik ga dit ene noemen sizeof.c, en druk op Opslaan. En let op wat gebeurt er met mijn zeer witte code tegen deze zwarte achtergrond. Nu, in ieder geval is er sommige paarse daar. En het is syntax gemarkeerd. 

Dat komt omdat, heel eenvoudig, ik heb vertelde de IDE wat voor soort bestand het is door het geven van een naam en in het bijzonder een bestandsextensie. Nu, laten we gaan en dit te doen. Ik ga je gang en zeer go gewoon uitprinten de following-- Bool is procent LU. 

We zullen terug te komen op dat in slechts een moment. En dan ga ik afdrukformaat van Bool. En nu, gewoon om te besparen mijzelf enige tijd, ben ik gaat een hele doen stelletje deze in een keer. En, in het bijzonder, ik ga dit veranderen naar een char en char. Deze, ik ga om te veranderen een tweepersoonsbed en een double. 

Deze, ik ga om te veranderen om een ​​vlotter en een vlotter. Deze, ik ga wijzigen in een int en een int. En deze, ga ik te veranderen naar een lange lange. En het is nog steeds het nemen van een lange tijd, lang lang. 

En dan, ten slotte, gaf ik zelf een te veel, string. Het blijkt dat in C, is er de speciale gebruiker genaamd grootte van dat is letterlijk gaan, wanneer deze wordt uitgevoerd, vertel ons de grootte van elk van deze variabelen. Dit is een manier, nu, we kunnen terug verbinden om de discussie van vorige week van gegevens en representatie. 

Laat me gaan en samen te stellen grootte van de dot slash grootte van. En laten we eens kijken. Het blijkt dat in C, specifiek op de CS50 IDE, specifiek op de besturingssysteem Ubuntu, die een 64-bits besturingssysteem systeem in casu een Bool gaat Gebruik een byte ruimte. Dat is hoe de grootte wordt gemeten, niet in bits, maar in bytes. En herinneren dat één byte is acht bits. Dus een Bool, ook al heb je technisch gezien alleen maar een 0 of 1, het is een beetje verspilling hoe we het hebben geïmplementeerd. Het is eigenlijk gaat om een ​​geheel te gebruiken byte-- dus allemaal nullen, zijn misschien allemaal enen, of iets dergelijks, of slechts een 1 onder de acht bits. 

Een char ondertussen voor een teken als een ASCII-teken per vorige week, zal een karakter. En die synchroniseert met onze notie van Het is niet meer dan 256 bits-- plaats, synchroniseert met het feit dat er geen langer dan 8 bits, die geeft ons wel 256 waarden. Een dubbele gaat zijn 8 bytes of 64 bits. 

Een float is 4. Een int is 4. Een lange, lange is 8. En een string 8. Maar maak je geen zorgen over. We gaan terug te pellen die laag. Het blijkt, strings kan langer dan 8 bytes. 

En inderdaad, we hebben geschreven strings al, hello wereld, langer dan 8 bytes. Maar we zullen terug te komen op dat in slechts een moment. Maar de afhaaldienst hier is het volgende. 

Elke computer heeft slechts een eindige hoeveelheid geheugen en ruimte. U kunt alleen op te slaan zo veel bestanden op je Mac of pc. U kunt alleen zo veel programma's in op te slaan RAM draaien tegelijk noodzakelijkerwijs ook virtueel geheugen, omdat je hebt een beperkte hoeveelheid RAM. 

En alleen maar om picture-- als je hebt nog nooit opende een laptop of te bestellen extra geheugen voor een computer, je misschien niet weten dat binnenkant van uw computer is iets dat eruit ziet een beetje als dit. Dus dit is gewoon een gemeenschappelijke onderneming met de naam Cruciaal dat maakt RAM voor computers. En RAM is waar programma's leven, terwijl ze draaien. 

Dus op elke Mac of pc, wanneer u dubbelklikt klik op een programma en het opent, en het opent een aantal Word-document of zoiets, slaat tijdelijk in RAM, omdat RAM sneller dan uw harde schijf of je solid state disk. Dus het is gewoon waar programma gaan om te leven als ze draaien, of wanneer bestanden worden gebruikt. 

Dus je moet dingen die eruit zien als dit de binnenkant van uw laptop, of iets grotere dingen binnenkant van uw bureaublad. Maar het belangrijkste is dat je alleen een eindig aantal van deze dingen. En er is slechts een beperkte hoeveelheid hardware zitten op dit bureau rechts hier. 

Dus, zeker, we kunnen niet bewaren oneindig lange nummers. En toch, als je denkt terug naar basisschool, hoeveel cijfers kan je moet de juiste van een komma? Wat dat betreft, hoeveel cijfers kan je moet aan de linkerkant van een komma? Echt, oneindig veel. 

Nu, misschien alleen wij mensen weten hoe te miljoen uit te spreken, en miljard, biljoen, en biljard, en triljoen. En ik ben tegen de grenzen van mijn understanding-- of my-- ik begrijp getallen, maar mijn uitspraak van getallen. Maar ze kunnen krijgen oneindig groot met oneindig veel cijfers links of rechts van een komma. 

Maar computers hebben slechts een eindige hoeveelheid geheugen, een eindig aantal transistors, een eindig aantal lampen binnen. Dus wat gebeurt er als u opraken van de ruimte? Met andere woorden, als je denk terug aan vorige week toen we spraken over aantallen zelf voorgesteld in binaire, Stel dat we hebben Deze 8-bit waarde hier. 

En we hebben zeven 1 en een 0. En stel dat we willen 1 aan deze waarde. Dit is echt een groot aantal op dit moment. 

Dit is 254, als ik herinner de wiskunde van vorige week goed. Maar wat als ik veranderen die meest rechtse 0 een 1? Het gehele getal van Natuurlijk, wordt acht 1's. Dus we zijn nog steeds goed. 

En dat is waarschijnlijk vertegenwoordigt 255, hoewel afhankelijk van de context Het kon eigenlijk vertegenwoordigen een negatief getal. Maar meer daarover een andere keer. Dit voelt als het over zo hoog als ik kan tellen. 

Nu, het is slechts 8 bits. En mijn Mac, zeker, heeft veel meer dan 8 bits geheugen. Maar het heeft wel eindig. Dus hetzelfde argument geldt, zelfs als we meer van dezen op het scherm. 

Maar wat gebeurt er als je opslaan van dit aantal, 255, en u wilt 1 stuk hoger tellen? U wilt gaan 255-256. Het probleem is natuurlijk dat als je beginnen te tellen bij nul als vorige week, kun je niet zo hoog te tellen 256, laat staan ​​257, laat staan ​​258, m want wat gebeurt er als je een 1 toe te voegen? Als je de oude lagere school aanpak, zet je een 1 hier, en dan 1 plus 1 is 2, maar dat is echt een nul, je draagt ​​de 1, dragen de 1, dragen de 1. Al deze dingen, deze 1 is, naar nul. En je eindigt, ja, als iemand wees erop, een 1 aan de linkerkant. Maar alles wat je kunt eigenlijk zien en past in het geheugen slechts acht 0, dat wil zeggen op een gegeven moment als je een computer, probeerde te tellen hoog genoeg, je bent gaat rond wikkelen, zo lijkt het, naar nul, of misschien zelfs negatief getallen, die zelfs lager zijn dan nul. 

En we kunnen soort van dit te zien. Laat me ga je gang en schrijf een echt snel programma hier. Laat me ga je gang en schrijf een programma genaamd overloop. Omvatten CS50.h, omvatten standaard IO.h-- oh, Ik miste mijn syntax highlighting. Dus laten we dit op te slaan als overflow.c. 

En nu int main void-- en het duurde niet lang, we kom terug om uit te leggen waarom we blijven schrijven int main leegte. Maar voor nu, laten we gewoon doen , nemen het voor lief. Laten we geef mezelf een int, en initialiseren op 0. 

Laten we het dan doen voor int ik krijg zero-- eigenlijk, laten we een oneindige lus en zie wat er gebeurt. Tijdens het waar is, dan laten we n uitprinten is procent i, backslash n, plug-in n. Maar nu, laten we het doen n krijgt n plus 1. 

Met andere woorden, op elke iteratie van deze oneindige lus, laten we de waarde n's, en voeg 1 tot en met, en dan sla het resultaat terug n links. En, in feite, we hebben syntax gezien iets als dit, kort. Een koele truc is in plaats dit alles uit te schrijven, kun je eigenlijk zeggen een n plus gelijk is aan 1. 

Of als je echt wilt fancy, je kunt zeggen n plus plus puntkomma. Maar deze laatste twee zijn gewoon wat we syntactische suiker zou noemen voor de eerste zaak. 

Het eerste ding is meer expliciet, helemaal prima, helemaal correct. Maar dit komt vaker voor, zeg ik. Dus we zullen dit voor slechts een moment te doen. 

Laten we nu te maken overflow, wat klinkt nogal onheilspellend, dot slash overflow. Laten we eens kijken, n wordt steeds vrij groot. Maar laten we denken, hoe groot kan n krijgen? 

n een int. We zagen een moment geleden met de omvang van de Bijvoorbeeld dat een int is vier bytes. We weten van vorige week, vier bytes is 32 bits, want 8 keer 4, dat is 32. Dat gaat worden 4 miljard. 

En we zijn tot 800.000. Dit gaat nemen voor eeuwig tellen als hoog als ik kan. Dus ik ga om verder te gaan, Zoals u wellicht het duurde niet lang, en sloeg Controle C-- eerlijk gezegd, Controle C, een stuk, waarin controle C in het algemeen middelen te annuleren. Helaas, omdat deze wordt uitgevoerd in de cloud, soms de cloud uitspugen zo veel spullen, zo veel output, het gaat om neem een ​​tijdje voor mijn inbreng naar de cloud te krijgen. Dus hoewel ik hit Controle C een paar seconden geleden, dit is zeker de kant effect van een oneindige lus. 

En dus in dergelijke gevallen, we zijn gaat verlaten dat. En we gaan naar een ander toe te voegen terminalvenster hier met de plus, wat natuurlijk niet doet als dat, aangezien het nog steeds denken. En laten we ga je gang en wees een beetje meer redelijk. 

Ik ga om te gaan en te doen dit alleen maar een eindig aantal malen. Laten we gebruik maken van een lus, die ik zinspeelde eerder. Laten we dit doen. Geef me een andere variabele int i krijgt 0. i is kleiner dan, laten we zeggen, 64 i ++. En nu laat ik ga je gang en af ​​te drukken out n procent i, komma n. En dan is dit nog steeds N-- gaat altijd te nemen. Laten we dit doen. 

n krijgt n keer 2. Of we kunnen fancy en doe tijden gelijk is aan 2. Maar laten we maar zeggen n is gelijk aan zichzelf, keer 2. Met andere woorden, in deze nieuwe versie van het programma, Ik wil niet eeuwig wachten uit als 800.000 tot 4 miljard. Laten we krijgen dit over met. 

Laten we eigenlijk het dubbele van n elke keer. Welke, recall, verdubbeling is de tegenovergestelde van het hebben, natuurlijk. En terwijl vorige week hebben we weer iets, en opnieuw, en opnieuw, super snel, verdubbeling zal zeker krijgen ons van 1 tot en met de grootst mogelijke waarde die we kunnen rekenen op een int. 

Dus laten we precies doen dit. En we zullen hierop terugkomen het duurde niet lang. Maar, nogmaals, is net als de herhaling blok in Scratch. En je zult dit gebruiken het duurde niet lang. 

Dit betekent gewoon tellen van nul tot, maar niet gelijk aan 64. En op elke variant van dit lus, gewoon blijven verhogen van i. So i ++ - en deze algemene construct op lijn 7 is gewoon een super voorkomende manier repeterende aantal regels code bepaald aantal keren. Welke regels code? Deze accolades, zoals u kunnen afgeleid uit nu, betekent, doe dan het volgende. 

Het is in zoals Scratch, wanneer het heeft de gele blokken en andere kleuren dat soort omhelzen of knuffelen andere blokken. Dat is wat die krullend beugels zijn hier doen. Dus als ik mijn syntax right-- u kan de wortel symbool in C middelen zien dat is hoe vaak ik was proberen om dit probleem op te lossen. Dus laten we te ontdoen van die ene in totaal, en sluit dat venster. En we zullen de nieuwe te gebruiken. Maak overloop, dot slash overloop, Enter, oke, Het ziet er slecht uit op het eerste. Maar laten scrollen terug in de tijd, want ik deed dit 64 keer. 

En let op de eerste keer, n 1 is. Tweede keer, n is 2, dan 4, dan 8, dan 16. En het schijnt dat zodra Ik krijg tot ongeveer 1 miljard, als ik weer verdubbelen, dat moet me 2 miljard. Maar het blijkt, het is direct aan de vooravond. 

En zo is het eigenlijk overflows een int van 1 miljard tot ongeveer negatieve 2 miljard, omdat een integer, Anders dan de nummers we werden vorige week de veronderstelling, kunnen zowel positief als negatief zijn in werkelijkheid en een computer. En dus tenminste een van die bits effectief gestolen. Zodat we echt hebben slechts 31 bits, of 2 miljard mogelijke waarden. 

Maar voor nu, de afhaalmaaltijd is vrij eenvoudig, wat deze getallen en wat de wiskunde is, er iets ergs gebeurt uiteindelijk, want uiteindelijk je probeert te permuteren de bits een te veel tijd. En u effectief gaan van alle 1 tot misschien wel alle 0's, of misschien gewoon een ander patroon dat het duidelijk, afhankelijk van de context, kan worden geïnterpreteerd als een negatief getal. En zo zou het de hoogste Ik schijn kan tellen in dit specifieke programma is slechts ongeveer 1 miljard. Maar er is een gedeeltelijke oplossing. Weet je wat? 

Laat me te veranderen van een int naar een lange lange. En laat me hier ga je gang en say-- ik ga moeten om dit te veranderen naar een unsigned long. Of, laten we eens kijken, ik zelf herinner me nooit. 

Laten we doorgaan en maak overflow. Nee, dat is het niet, LLD, dank je. Dus soms Clang kan nuttig zijn. Ik heb niet herinneren wat het formaat specifier was voor een lange lange. 

Maar inderdaad, Clang vertelde me. Groen is een soort van goede, nog steeds betekent dat je een fout hebt gemaakt. Het is gissen, dat bedoelde ik LLD. 

Dus laat me het advies, een lange lang decimaal getal, behalve dat. En laat me opnieuw uit te voeren is, dot slash overflow, Enter. En nu, wat cool is dit. 

Als ik terug in de tijd te bladeren, we nog steeds beginnen tellen op hetzelfde plaats-- 1, 2, 4, 8, 16. Let op, krijgen we alle manier tot 1 miljard euro. Maar dan zijn we veilig naar 2 miljard. 

Dan krijgen we 4 miljard, dan 8 miljard, 17 miljard. En we gaan hoger, en hoger en hoger. Uiteindelijk, ook dit pauzes. 

Uiteindelijk, met een lange lange, dat de 64-bits waarde, niet een 32-bits waarde, als je telt te hoog, wikkel je rond 0. En in dit geval gebeurt we eindigen met een negatief getal. 

Dus dit is een probleem. En het blijkt dat dit probleem is niet zo mysterieus. Hoewel ik heb met opzet veroorzaakte het met deze fouten, Het blijkt dat we het zien natura van alle om ons heen, of op zijn minst een deel van ons doen. 

Dus in Lego Star Wars, indien je ooit het spel gespeeld, het blijkt dat je kunt gaan rond breken van dingen in LEGO wereld, en het verzamelen van munten, wezen. En als je ooit hebt gespeeld dit spel veel te veel tijd, als deze niet nader genoemde persoon Hier heeft het aantal munten die je kunt verzamelen is, naar het schijnt, 4 miljard. 

Nu, met het eigenlijk afgerond. Dus LEGO probeerde te houden dingen gebruiksvriendelijk. Ze hebben het niet precies 2 tot de 32 macht, per week. Maar 4 miljard is een reden. Het lijkt erop dat, op basis van deze informatie, dat LEGO, en het bedrijf dat maakte deze eigenlijke software, besloot het maximum aantal munten de gebruiker kan ophopen is inderdaad 4 miljard, omdat zij kozen in hun code geen lange lang is om, blijkbaar, maar gewoon een integer, een niet-ondertekende integer, maar een positief geheel getal, waarvan max waarde is ongeveer dat. Nou, hier is een andere grappige. Dus in het spel Civilization, die sommigen van u wellicht bekend zijn, met het blijkt dat jaren geleden is er was een bug in dit spel, waarbij als je de rol van Gandhi in het spel, in plaats van hem zeer pacifist, in plaats daarvan was ongelooflijk, ongelooflijk agressief, in bepaalde omstandigheden. Vooral de manier waarop beschaving werken is dat als je de speler, vast te stellen democratie, uw agressiviteit score krijgt gedecrementeerd door twee, zo min minus, en dan minus minus. 

Dus u aftrekken 2 uit uw werkelijke iteratie. Helaas, als je itereren is aanvankelijk 1, en u aftrekken 2 daaruit na de goedkeuring van de democratie als Gandhi hier misschien hebben gedaan, omdat hij erg passive-- was 1 op de schaal van agressiviteit. Maar als hij aanneemt democratie, dan Hij gaat van 1 naar negatief 1. 

Helaas waren ze gebruik unsigned getallen, wat betekent dat ze behandeld zelfs negatief getallen alsof ze waren positief. En het blijkt dat de positieve equivalent van negatieve 1, in typische computerprogramma's, is 255. Dus als Gandhi goedkeurt democratie, en daarom Zijn agressiviteit score afgenomen, het eigenlijk rollen rond 255 en maakt hem de meest agressieve personage in het spel. Zo kunt u Google op dit punt. En het was inderdaad een toevallige programmering bug, maar dat is heel ingevoerd de overlevering sinds die tijd. 

Dat is allemaal leuk en schattig. Meer beangstigend is wanneer werkelijke echte wereld apparaten, en niet spelen, hebben dezelfde bugs. In feite, net een jaar geleden een artikel kwam komen over de Boeing 787 Dreamliner. 

En het artikel op het eerste oogopslag leest een beetje mysterieus. Maar het zei dit, een software kwetsbaarheid in Boeing nieuwe 787 Dreamliner jet heeft potentieel piloten veroorzaken om de controle over te verliezen het vliegtuig eventueel in het midden van de vlucht, de FAA ambtenaren waarschuwde luchtvaartmaatschappijen onlangs. Het was de vaststelling dat een model 787 vliegtuig dat werd aangedreven continu gedurende 248 dagen kunnen alle wisselstroom verliezen, AC, elektrische vermogen door de generator controle-eenheden, GCUs, gelijktijdig in te gaan op fail safe mode. Het is een soort van mij te verliezen. Maar de memo gezegd, OK, nu heb ik dat, de aandoening veroorzaakt door een software tegen interne de generator control eenheden die zal overstromen na 248 dagen continu vermogen. We zijn de uitgifte van dit opmerken om verlies te voorkomen van alle AC elektrische macht, wat kan resulteren in verlies van controle over het vliegtuig. 

Dus, letterlijk, er een integer, of een gelijkwaardige gegevens soort, gebruikt in software in een echte vliegtuig dat als je je vliegtuig te houden lang genoeg, die blijkbaar kan het geval zijn als je alleen loopt ze voortdurend en nooit loskoppelen je vliegtuig, zo lijkt het, of laten de batterijen sterven, zal uiteindelijk tellen, en omhoog, en omhoog, en omhoog, en omhoog, en omhoog. 

En, door de natuur, een eindige hoeveelheid geheugen zal overstromen, rollen terug naar nul of een negatieve waarde, bijwerking daarvan is de angstaanjagend echte werkelijkheid dat het vliegtuig zou kunnen hebben opnieuw worden opgestart, effectief, of zou kunnen vallen, nog erger, als het vliegt. Dus dit soort problemen zijn nog steeds bij ons, even-- dit was een 2015 artikel, des te meer angstaanjagend als je niet per se te begrijpen, te waarderen of te anticiperen dat soort fouten. 

Dus het blijkt dat er een ander slechte ding over data representatie. Het blijkt dat zelfs praalwagens zijn soort gebrekkig, omdat drijvers, ook, Ik stelde zijn 32 bits, of misschien 64 als je een dubbel gebruiken. Maar dat is nog steeds eindig. 

En de vangst is dat als je kunt zet een oneindig aantal nummers na de komma, er is geen manier waarop je kunnen alle mogelijke vormen nummers die we werden onderwezen op de lagere school kunnen bestaan ​​in de wereld. Een computer wezen moet Kies een subset van de getallen om nauwkeurig te vertegenwoordigen. 

Nu, de computer kan round misschien een beetje, en kunt u toestaan ​​tot ongeveer winkel elk nummer dat u zou kunnen wensen. Maar net intuïtief, als je een eindig aantal bits, je kunt ze alleen permuteren op zoveel manieren eindig. Dus je kan onmogelijk Gebruik een eindig aantal permutatie van bits, patronen van nullen en enen, een oneindige vertegenwoordigen aantal getallen, wat suggereert dat computers zou kunnen heel goed liegen tegen ons soms. 

In feite, laten we dit doen. Laat me teruggaan naar CS50 IDE. Laat me ga je gang en het creëren van een klein programma riep Onnauwkeurigheid, aan te tonen dat computers zijn inderdaad onnauwkeurig. 

En laat me ga je gang en beginnen met een deel van die code van vóór, en nu gewoon doen het volgende. Laat me ga je gang en doe printf, procent f, backslash n, 1 gedeeld door 10. Met andere woorden, laten we duiken dieper 1/10, als 1 en gedeeld door 10. Zeker, kan een computer vertegenwoordigen 1/10. 

Dus laten we gaan door en maak onnauwkeurigheid. Laten we eens kijken. Format bepaalt het type double. Maar het argument heeft type int. Wat gebeurd er? 

Oh, interessant, dus het is een les geleerd van voor. Ik zeg, hey, computer-show me een vlotter met een procent f. Maar ik ben het geven van 2 ints. Dus het blijkt, kan ik dit oplossen dit in een paar manieren. 

Ik kon het gewoon weer een in 1.0, en 10 tot 10,0, dat zou inderdaad hebben het effect van het omzetten ze in floats-- toch hopelijk hetzelfde nummer. Of het blijkt dat er iets we zullen weer te zien het duurde niet lang. Je kon de nummers uitbrengen. 

U kunt met behulp van deze haakjes expressie, kun je zeggen, hey, computer, neem deze 10, waarvan ik weet dat een int. Maar behandelen, dan kunt u, alsof het een vlotter. Maar dit voelt onnodig complex. 

Voor ons doel van vandaag, laten we gewoon letterlijk maken ze floating point waarden met een komma, zoals deze. Laat me ga je gang en herhaling, maken onnauwkeurigheid, goed, dot slash onnauwkeurigheid, in te voeren. Oké, we zijn er goed uit. 

1 gedeeld door 10, volgens mijn Mac hier, is inderdaad 0,100000. Nu, leerde ik op de lagere school is er moet een oneindig aantal 0 te zijn. Dus laten we op zijn minst proberen een aantal van die te zien. Het blijkt dat printf is een beetje liefhebber nog dan we heb gebruikt. Het blijkt dat je niet hoeft aan te geven gewoon procent f, of gewoon procent i. Je kunt eigenlijk opgeven enige controle mogelijkheden. 

In het bijzonder, ik ga te zeggen, hey, printf, eigenlijk toon me 10 cijfers achter de komma. Dus het ziet er een beetje raar. Maar u zegt procent, dot, hoeveel nummers je wilt zien na de komma, en dan is f voor platte, alleen maar omdat dat is wat de documentatie zegt. Laat me ga je gang en op te slaan dat. 

En let ook, ik krijg moe van het overtypen dingen. Dus ik ben gewoon het instellen van de up en pijl omlaag op mijn sleutels hier. En als ik blijf raken op, u kunnen alle opdrachten zien die ik gemaakt heb, of verkeerd gemaakt. 

En ik ga nu verder te gaan en eigenlijk niet gebruiken, blijkbaar. Maak onnauwkeurigheid, dot slash imprecision-- zo wat ik werd onderwezen in basisschool klopt. Zelfs als ik af te drukken op 10 decimaal plaatst het, inderdaad, is 0,10000. Maar weet je wat? 

Laten we een beetje hebberig. Laten we zeggen, als, laat me 55 punten achter de komma. Laten we dit echt te nemen Programma voor een spin. Laat me remake met make onnauwkeurigheid, dot slash, onnauwkeurigheid. 

En hier gaan we. Je jeugd was een leugen. Blijkbaar, 1 gedeeld door 10 inderdaad 0.100000000000000005551115123-- 

Wat is er aan de hand? Nou, het blijkt dat, als je soort kijk ver genoeg uit in de onderliggende weergave van deze nummer, het eigenlijk is niet exact 1/10, of 0,1 en een oneindig aantal nullen. Nu, waarom is dat? 

Nou, ook al is dit een eenvoudige nummer ons mensen, 1 gedeeld door 10, het is nog steeds een van de oneindig veel nummers die we konden bedenken. Maar een computer kan alleen vertegenwoordigen eindig veel dus nummers. En dus, effectief, wat de computer toont ons is de dichtstbijzijnde aanpassing aan het aantal we willen geloven is 1/10, of eigenlijk ad infinitum 0,10000. 

Veeleer is dit echter zo dicht als het kan krijgen. En inderdaad, als je kijkt onder de motorkap, als wij zijn hier door te kijken 55 cijfers achter de komma, we eigenlijk zien dat de werkelijkheid. Nu als een terzijde, als je hebt ooit de movie-- gezien de meeste van jullie waarschijnlijk haven't-- maar Superman 3 enkele jaren geleden, Richard Pryor dit wezen leveraged werkelijkheid in zijn bedrijf om veel te stelen van fracties en fracties van centen, omdat de company-- als ik me goed herinner, het is al een while-- wezen was weggooien van iets dat niet paste in het begrip cent. 

Maar als je optelt al deze klein, klein, kleine aantallen weer, en opnieuw, en opnieuw, kunt u, net als in zijn geval, maak een goede hoeveelheid geld. 

Diezelfde idee werd opgelicht door een meer recente, maar nu nog ouder film, genaamd Office Space, waar de jongens in die film, deed hetzelfde, verpest volledig, eindigde met veel te veel geld op hun bankrekening. Het was allemaal zeer verdacht. Maar aan het eind van de dag, onnauwkeurigheid is overal om ons heen. 

En ook dat kan zijn angstwekkend het geval. Het blijkt dat Superman 3 en Office Space terzijde, er kunnen een aantal zeer reële wereld vertakkingen de realiteit van onnauwkeurige representatie van data dat zelfs wij mensen aan deze dag niet per se begrijpen zo goed als we moeten, of onthoud zo vaak als we moeten. En inderdaad, de volgende clip uit een kijkje bij enkele zeer reële wereld vertakkingen van wat er gebeurt als je niet waarderen de onnauwkeurigheid die kan gebeuren getallen representatie. 

[VIDEO AFSPELEN] 

-Computers, We hebben allemaal te accepteren de vaak frustrerende problemen te gaan met them-- bugs, virussen, en software glitches, voor kleine prijzen te betalen voor het gemak. Maar in de high-tech en hoge snelheid militaire en ruimtevaartprogramma toepassingen, het kleinste probleem worden vergroot tot een ramp. 

Op 4 juni 1996, wetenschappers voorbereid om een ​​onbemande Ariane 5-raket te lanceren. Het vervoerde wetenschappelijke satellieten ontworpen precies hoe de vaststelling aardmagnetische veld wisselwerking met zonne-wind. De raket werd gebouwd voor het Europees Ruimteagentschap, en getild uit de faciliteit aan de kust van Frans-Guyana. 

-Bij Ongeveer 37 seconden in de vlucht, zij eerst merkte er iets fout gaat. De mondstukken zijn in zwenkbare een manier om ze echt niet moeten doen. Ongeveer 40 seconden in de vlucht, duidelijk, het voertuig in de problemen zat. 

En dat is wanneer ze maakten een beslissing te vernietigen. De range safety officer, met enorme lef, drukte op de knop, blies de raket, voordat het kon uitgegroeid tot een gevaar voor de openbare veiligheid. 

-Dit Was het meisje reis van de Ariane 5. En de vernietiging nam plaats als gevolg van een fout ingebed in de software van de raket. -Het Probleem op de Ariane was dat er een nummer dat vereiste 64 bits uit te drukken. En ze wilden bekeren naar een 16-bits getal. Zij aangenomen dat de nummer werd nooit zeer groot zijn, dat de meeste van deze cijfers in een 64-bits getal waren nullen. Ze hadden het verkeerd. 

-de Onvermogen van een softwareprogramma te accepteren het soort getal gegenereerd door een ander was de oorzaak van de storing. Software ontwikkeling was geworden van een zeer kostbaar deel van nieuwe technologie. De Ariane-raket zijn erg geweest succesvolle, zoveel van de software gecreëerd ook was gebruikt in de Ariane 5. 

-De Fundamentele probleem was dat de Ariane 5 was sneller versnelde sneller. En de software niet had goed voor. 

-De Vernietiging van de raket was een enorme financiële ramp, allemaal te wijten aan een minuut softwarefout. Maar dit was niet de eerste time data conversie problemen had moderne rakettechnologie geplaagd. 

-In 1991, met de start van de eerste Golfoorlog, de Patriot Missile kende een soortgelijke van het aantal conversie probleem. En daardoor 28 mensen, 28 Amerikaanse soldaten, werden gedood, en ongeveer 100 anderen gewond, wanneer de Patriot, die verondersteld werd om te beschermen tegen inkomende Scuds, niet aan een raket te vuren. 

-Wanneer Irak Koeweit binnenviel, en Amerika gelanceerd Desert Storm in het begin van 1991, Patriot Missile batterijen werden ingezet te beschermen Saoedi-Arabië en Israël van de Iraakse Scud raketaanvallen. De Patriot is een Amerikaanse middellange afstand oppervlak aan de lucht systeem, gefabriceerd door de Raytheon bedrijf. 

-De Grootte van de Patriot interceptor zelf is ongeveer ongeveer 20 voet lang. En hij weegt ongeveer 2.000 pond. En het draagt ​​een kernkop van ongeveer, Ik denk dat het ongeveer 150 pond. En de kernkop zelf een hoog explosieve, die heeft fragmenten eromheen. De behuizing van de kernkop is ontworpen om te fungeren als hagel. 

-De Raketten worden uitgevoerd vier per container, en worden vervoerd door een oplegger. 

-De Patriot anti-raketsysteem teruggaat nu minstens 20 jaar. Het werd oorspronkelijk ontworpen als luchtafweer raket neer te schieten vijandelijke vliegtuigen. In de eerste Golfoorlog, wanneer die oorlog kwam, het leger wilden gebruiken om neer te schieten Scuds, niet vliegtuigen. 

De Iraakse Luchtmacht was niet zo veel van een probleem. Maar het leger was bezorgd over Scuds. En dus probeerde ze te upgrade van de Patriot. 

-Intercepting Een vijand raket reizen op mach 5 zou worden uitdagend genoeg. Maar toen de Patriot werd in allerijl in dienst, het leger was niet op de hoogte van een Iraakse wijziging die gemaakt hun Scuds bijna onmogelijk te raken. 

Wat is er gebeurd is de Scuds dat kwamen in waren instabiel. Ze waren wiebelen. De reden hiervoor was de Irakezen, met het oog tot 600 kilometer krijgen uit een 300 kilometer afstandsraketten, nam het gewicht aan de voorkant kernkop. Ze maakten de kernkop lichter. 

Dus nu de Patriot is proberen de Scud komen. En meestal, de overgrote meerderheid van de tijd, het zou gewoon vliegen door de Scud. Zodra de Patriot netbeheerders realiseerde de Patriot miste zijn doel, ze ontploft de Patriot's kernkop mogelijke slachtoffers of vermijden mocht op de grond vallen. 

-dat Was wat de meeste mensen zag, die grote vuurballen in de lucht, en verkeerd begrepen als onderschept van Scud kernkoppen. 

-hoewel In de nacht luchten, verscheen Patriots succesvol zijn vernietigen Scuds op Dhahran, kon er geen vergissing zijn over de prestatie. Er is de Patriot's radarsysteem verloren spoor van een inkomende Scud, en nooit gelanceerd als gevolg om een ​​software fout. Het was de Israëli's die voor het eerst ontdekt dat hoe langer het systeem op, hoe groter de tijd discrepantie werd, als gevolg van een klok ingebed in de computer van het systeem. 

-Over Twee weken voor de tragedie in Dhahran, de Israëli's gemeld aan het ministerie van Defensie dat het systeem werd tijd te verliezen. Na ongeveer acht uur of hardlopen, ze merkten dat het systeem was steeds merkbaar minder nauwkeurig. Het ministerie van Defensie reageerde door vertellend allen van de Patriot-batterijen niet de systemen verlaten voor een lange tijd. Ze hebben nooit gezegd wat een lange tijd was-- acht uur, 10 uur, 1000 uur. Niemand wist. 

-De Patriot batterij gestationeerd op de kazerne in Dhahran en de gebrekkige interne klok waren meer dan 100 uur geweest op in de nacht van 25 februari. 

-Het Bijgehouden tijd met een nauwkeurigheid ongeveer een tiende seconde. Nu, een tiende van een seconde is een interessant getal, want het kan niet worden uitgedrukt in binaire precies die betekent kan niet exact worden uitgedrukt in elke moderne digitale computer. Het is moeilijk te geloven. 

Maar gebruik dit als een voorbeeld. Laten we de nummer een derde plaats. Een derde kan niet uitgedrukt in decimale precies. Een derde is 0,333 er aan de hand voor oneindigheid. 

Er is geen manier om dat te doen met absolute nauwkeurigheid in decimalen. Dat is precies het soort probleem dat gebeurde in de Patriot. Hoe langer het systeem liep, de slechter de fout werd. 

-Na 100 uur van de werking, de fout in de tijd was slechts ongeveer eenderde van een seconde. Maar in termen van gericht op een raket reizen op mach 5, het resulteerde in een tracking fout van meer dan 600 meter. Het zou een fatale fout zijn de soldaten wat gebeurd is een Scud lancering was gedetecteerd door vroegtijdige waarschuwing satellieten en ze wisten dat de Scud was komen in hun algemene richting. Ze wisten niet waar het vandaan kwam. 

-Het Was nu aan de radar component van het Patriot-systeem het verdedigen van Dhahran te vinden en te houden bijhouden van de inkomende vijandelijke raket. 

-De Radar was erg slim. Het zou eigenlijk bijhouden de positie van de Scud, en dan voorspellen waar het waarschijnlijk zal de volgende keer dat de radar gezonden een puls uit. Dat werd een reeks gate genoemd. 

-Dan, Zodra de Patriot beslist genoeg tijd heeft doorgegeven om terug te gaan en de volgende locatie voor dit gedetecteerde object, het gaat terug. Dus als het ging terug naar de verkeerde plaats het dan ziet geen object. En het besluit dat er geen sprake was object was een valse detectie, en daalt het spoor. 

-De Inkomende Scud verdwenen van het radarscherm. En seconden later, sloeg in de kazerne. De Scud gedood 28 en was de laatste een in brand gestoken tijdens de eerste Golfoorlog. 

Tragisch, de bijgewerkte software aangekomen bij Dhahran de volgende dag. De software fout had is vastgesteld, het sluiten één hoofdstuk in de onrustige geschiedenis van de Patriot raketten. 

[VIDEO AFSPELEN] DAVID J. MALAN: Dus dit is allemaal zeggen dat deze kwesties van overflow en onnauwkeurigheid zijn al te reëel. Dus hoe zijn we hier? We begonnen met het net over printf. Nogmaals, deze functie drukt iets op het scherm, en we daarna geïntroduceerd enkele andere functies de zogenaamde CS50 bibliotheek. En we blijven zien deze te zijner tijd. En wij, in het bijzonder, wennen koord, en krijg int, en nu ook vlotter, en weer anderen nog steeds zullen we tegenkomen en gebruik maken van ons het duurde niet lang. 

Maar af en toe, hebben bleek al behoefte om terug te slaan wat die functies de hand? Ze overhandigen ons terug een string, of een int of een float. En soms moeten we dat te zetten tekenreeks of int of float, ergens. 

En om die dingen op te slaan, te herinneren gewoon zoals in Scratch, hebben we variabelen. Maar in tegenstelling tot in Scratch, in C hebben wij alleen types van variables-- data soorten, meer generally-- waaronder een koord, int, een drijven, en die anderen nog. 

En dus toen we verklaren variabelen in C, we moeten onze data types te verklaren. Dit is niet iets wat we zullen moeten later doen in het semester we overgang naar andere talen. Maar voor nu, moeten we a priori vooraf, uitleggen aan de computer welk type variabele willen we dat het ons geeft. 

Nu, ondertussen, afdrukken dat soort types data, we moeten zeggen printf wat te verwachten. En we zagen procent s voor strijkers, en i procent voor integers, en een paar anderen al. En die zijn gewoon eisen voor de visuele presentatie van die informatie. 

En elk van deze kan eigenlijk geparametriseerd of getweaked op een bepaalde manier, als je wilt controle verder het type van de output die je krijgt. En inderdaad blijkt dat niet alleen is er backslash n voor een nieuwe regel. Er is iets anders opgeroepen backslash r voor een harde return, die is meer verwant is aan een oude school schrijfmachine, en ook Windows voor vele jaren. 

Er is backslash t voor tabs. Blijkt, dat als je wilt dubbele aanhalingstekens binnen van een string, herinneren dat we hebben gebruikt dubbele aanhalingstekens double citaat op de linker en de rechter uiteinden van onze strings tot nu toe. Dat lijkt om dingen te verwarren. 

Wilt u een dubbele quote in te zetten het midden van een string-- en, inderdaad, Het is verwarrend om te zien. En dus je moet ontsnappen, om zo te spreken, een dubbel aanhalingsteken met iets als, letterlijk, backslash dubbel aanhalingsteken. En er is een paar andere nog. En we zullen meer van deze te zien in het werkelijke gebruik het duurde niet lang. 

Dus laten we nu de overgang van data, en vertegenwoordiging, en rekenkundige operatoren, alle die gaf ons een aantal gebouw blokken om mee te spelen. Maar laten we nu eigenlijk te geven ons de rest van de woordenschat die we al hadden vorige week met Scratch door het nemen van een kijkje bij enkele andere constructies in C-- niet allemaal. Maar de ideeën die we zijn over om echt gewoon zien benadrukken de vertaling van één taal, Scratch, naar de andere, C. 

En na verloop van tijd, zullen we pick-up meer instrumenten voor onze toolkit, zo te zeggen, syntactisch. En inderdaad, zult u zien dat de ideeën zijn nu eerder bekend van vorige week. Dus laten we dit doen. 

Laten we ga je gang en zweep een programma dat gebruik maakt eigenlijk een aantal uitdrukkingen, een Booleaanse uitdrukking. Laat me hier ga je gang en maak een nieuw bestand. Ik zal dit condition.c noemen. 

Laat me ga je gang en omvatten de CS50 bibliotheek. En laat me ga je gang en omvatten standaard IO.h voor onze functies, en printf, en nog veel meer respectievelijk. Ik geef mezelf dat standaardtekst van int main leegte, wiens verklaring we zullen terug te komen in de toekomst. 

Laat me nu ga je gang en geef mijzelf een int via get int. Laat mij dan ga je gang en dit te doen. Ik wil zeggen dat als ik is less-- laten onderscheid tussen positieve, negatieve, of nul waarden. 

Dus als ik minder dan nul is, laat me moet gewoon dit programma gewoon zeggen, negatief, backslash n, anders Als i groter is dan nul. Nu ben ik natuurlijk gaan zeggen printf positief, backslash n. En dan anders if-- ik dit kon doen. 

Ik kon doen als ik gelijk is aan 0. Maar ik zou gaan maken op minstens één fout al. Bedenk dat het isgelijkteken is niet gelijk, want wij mensen kennen. 

Maar het is de opdracht operator. En we willen niet te nemen 0 op de rechts en zet het in i aan de linkerkant. Dus om deze verwarring te vermijden, of misschien wel misbruik van het isgelijkteken, de mens besloot enkele jaren geleden dat in vele programmeertalen wanneer u wilt controleren voor de gelijkheid tussen links en rechts u daadwerkelijk gebruikt is gelijk aan gelijken. Zodat je op de isgelijkteken tweemaal. Wanneer u wilt toewijzen van rechts naar links, gebruikt u één isgelijkteken. Dus we konden dit-- anders doen als ik gelijk gelijk is aan nul. 

Ik zou dan gaan open mijn accolades, en zeggen: printf 0, backslash n, gedaan. Maar vergeet niet hoe deze vorken in de weg kan werken. En, echt, denk maar aan de logica. i is een getal. Het is een geheel getal, in het bijzonder. En dat betekent dat het gaat om minder dan 0 of groter dan 0 of 0. Dus er is een soort van deze impliciete default case. 

En dus we konden, net als Scratch, afzien van de anders als, en gewoon zeggen anders. Logisch, als je de programmeur weet dat er alleen drie emmers waarin een scenario kan fall-- de eerste, de tweede of de derde in deze niet case-- doen moeite toevoeging van de extra precisie en de additionele logica daar. Gewoon doorgaan met de default geval is van het andere. 

Nu, laten we gaan vooruit na deze besparing, maken voorwaarden dot slash conditions-- niet een grote user interface, want ik ben niet wordt gevraagd de gebruiker, zoals ik al eerder zei. Maar dat is prima. We zullen het simpel te houden. Laten we proberen het nummer 42. En dat is positief. Laten we proberen het aantal 42 negatief, negatief. 

Laten we proberen de waarde 0. En inderdaad, het werkt. Nu, zie je met problemen voordat lang, het testen van dingen drie keer, waarschijnlijk niet voldoende. Wilt u waarschijnlijk een aantal testen grotere aantallen, enkele kleinere cijfers, een hoekje gevallen, we komen om hen te beschrijven. 

Maar voor nu, is dit een vrij eenvoudig programma. En ik ben er vrij zeker van, logisch, dat uit drie gevallen. En, inderdaad, hoewel we gewoon gericht op de mogelijke nadelen van onnauwkeurigheid en overloop, in werkelijkheid waar veel problemen CS50's, we zijn niet van plan te maken over, de hele tijd, die kwesties van de overloop en onnauwkeurigheid, omdat in feite in C, het is eigenlijk niet zo makkelijk om die dingen te vermijden. Als u wilt tellen groter en groter en groter, Het blijkt dat er zijn technieken die je kunt gebruiken, vaak met dingen genoemd bibliotheken, collecties van de code, die andere mensen schreven die u kunt gebruiken, en andere talen zoals Java en anderen, in feite maakt het een stuk makkelijker nog hogere tellen. Het is dus echt sommige gevaren een functie van de taal die u gebruikt. En in de komende weken zullen we zien hoe gevaarlijk C echt kan zijn als je het niet goed gebruiken. Maar daar, en Python en JavaScript, zal we laag op een aantal extra beveiligingen, en lopen minder van die risico's. 

Dus laten we een beetje meer interessante logica in ons programma. Dus laat me ga je gang en maak een programma genaamd Logical gewoon zo kan ik spelen met enkele eigenlijke logica, logical.c. Ik zal gewoon kopiëren en plakken sommige code uit eerdere dus ik terug om dit mooie uitgangspunt. 

Laat me dit keer doe char C. Ik ben gaan om het een naam te geven C gewoon omdat het conventionele, krijgt een personage uit de gebruiker. En laten we doen alsof Ik ben de uitvoering van een deel van die Rm-programma, het verwijderen programma daarvoor gevraagd de gebruiker om een ​​bestand te verwijderen. Hoe kunnen we dit doen? 

Ik wil zeggen, als C is gelijk aan evenaart, citaat unquote, y, dan ga ik ervan uit te gaan dat de gebruiker ja heeft gekozen. Ik ga gewoon om af te drukken ja. Als het waren eigenlijk het schrijven het programma voor het verwijderen, we konden het dossier te verwijderen met meer regels code. Maar we zullen het simpel te houden. 

Anders als c gelijk gelijk N-- en nu hier, ik ga zeggen, de gebruiker moet niet hebben betekend. En dan anders, weet je wat? Ik weet niet wat anders weet de gebruiker gaat typen. Dus ik ga gewoon om te zeggen dat dat is een fout, ongeacht hij of zij daadwerkelijk getypt. 

Dus wat is hier aan de hand? Er is een fundamenteel verschil ten opzichte van wat ik heb gedaan in het verleden. Dubbele aanhalingstekens, dubbele aanhalingstekens, dubbele citaten, en toch, enkele aanhalingstekens, enkele aanhalingstekens. Het blijkt in C, dat wanneer U wilt een string te schrijven, u gebruik maken van dubbele aanhalingstekens, net zoals wij hebben gebruik gemaakt van al die tijd met printf. 

Maar als je wilt om te gaan met slechts een enkel teken, een zogenaamd char, dan ben je daadwerkelijk gebruik maken van enkele aanhalingstekens. Degenen onder u die hebt geprogrammeerd vóór, zou je niet moest zorgen te maken over deze onderscheid in bepaalde talen. In C is het er wel toe doet. En dus toen ik een char te krijgen en ik wil dat char te vergelijken met behulp van gelijken gelijk aan een aantal letters, zoals y of n, dat doe ik, inderdaad, moeten de enkele aanhalingstekens te hebben. 

Nu, laten we gaan en dit te doen. Laten we doorgaan en doen maken logische dot slash logisch. En nu ben ik wordt gevraagd. Dus vermoedelijk een betere gebruikerservaring zou me eigenlijk vertellen wat te doen hier. Maar ik ga gewoon blindelings zeggen y voor ja, OK, nice. 

Laten we het weer draaien, n zonder, nice. Stel dat als sommige mensen die ik ken, mijn caps lock toets is maar al te vaak. Dus ik doe het kapitaal Y, voer, fout. OK, het is niet precies wat ik verwachtte. Inderdaad, de computer is letterlijk wat doet Ik vertelde het aan doen-- controleren kleine letters y en kleine n. Dit voelt niet als goed user experience, dat wel. Laat me vragen en accepteren ofwel kleine letters en hoofdletters. Dus het blijkt, wil je misschien om iets te zeggen, zoals in Scratch, zoals letterlijk of C gelijk evenaart hoofdstad enkele geciteerd y. Blijkt, heeft C geen deze letterlijke zoekwoord of. 

Maar het heeft wel twee verticale balken. Je moet Shift meestal te houden, als je met behulp van een Amerikaans toetsenbord, en druk op de verticale balk toets boven uw terugkeer sleutel. Maar deze verticale balk verticale balk betekent of. 

Indien daarentegen wilden te zeggen en, net als in Scratch, we konden ampersand ampersand doen. Dat maakt geen logische zin hier, want een mens kan onmogelijk hebt getypt zowel y en kleine letters y en kapitaal Y als hetzelfde personage. Dus of is wat we van plan hier. 

Dus als ik doe dit in beide plaatsen, of c gelijk is gelijk aan kapitaal N, nu opnieuw uit te voeren, maken logische, opnieuw uit te voeren logische. Nu kan ik y typen. En ik kan het weer doen met kapitaal Y, of het kapitaal N. En ik kon toevoegen aan extra combinaties nog steeds. 

Dit is dus een logische programma voor zover nu Ik logisch controleren deze waarde of deze waarde. En ik heb niet te noodzakelijkerwijs komen met twee ifs of anders ifs. Ik kan eigenlijk combineren sommige verwante logica bij elkaar op deze manier. Dus zou dit beter zijn ontworpen dan alleen zeggen, als C is gelijk aan kleine letters y, afdrukken ja, anders als c gelijk is aan het kapitaal Y, afdrukken ja, anders als c gelijk lower-- in andere woorden, je hoeft niet te hebben meer en meer takken. U kunt een aantal van de equivalente combineren takken logisch, zoals op deze manier. 

Dus laten we een kijkje nemen op één laatste ingrediënt, een laatste construct, C dat toelaat. En we zullen terugkomen in de toekomst anderen nog. En dan zullen we concluderen door te kijken bij niet de juistheid van code-- krijgen code om work-- maar het ontwerp van de code, en planten die zaden vroeg op. 

Dus laat me ga je gang en het openen van een nieuw bestand hier. Weet je wat? Ik ga opnieuw te implementeren datzelfde programma maar met een andere constructie. 

Dus laat me snel geef mezelf toegang tot CS50.h omvatten voor de CS50 bibliotheek, standaard Io.h voor printf. Geef me mijn int main leegte. En dan hier, laat ik ga je gang en dit te doen. 

Char c krijgt char te krijgen, net als vroeger. En ik ga een nieuwe constructie te gebruiken now-- schakelen, wat karakter? Dus switch is een soort schakelen van een spoor. Of, echt, het is een soort van een zo anders, zo anders als, maar enigszins anders geschreven. 

Een switch ziet er als volgt uit. Je hebt switch, en wat dan teken of nummer dat u wilt bekijken, vervolgens een aantal accolades graag in Scratch, gewoon zeggen doe dit soort dingen. En dan heb je verschillende zaken. 

U hoeft niet te gebruiken indien en anders. U gebruikt letterlijk het woord zaak. En je zou zoiets zeggen. 

Dus in het geval van een kleine letter y, of in het geval van een hoofdletter Y, ga je gang en uit te printen ja. En dan uit te breken van de schakelaar. Dat is het. Werden gedaan. 

Indien echter, om zo te zeggen, kleine letters n, of het vermogen N, dan ga je gang en af ​​te drukken Er zijn geen, en dan breken. Else-- en dergelijke is de default geval indeed-- printf error-- en gewoon voor een goede maatregel, hoewel logischerwijs deze pauze is niet nodig omdat we aan het eind van de schakelaar hoe dan ook, Ik ben nu het uitbreken van de schakelaar. Dus dit ziet er een beetje anders. 

Maar, logisch, het is eigenlijk equivalent. En waarom zou je gebruiken een over de ander? Soms is slechts persoonlijke voorkeur, soms de esthetiek, als ik kijk naar deze Nu, er is iets te zeggen voor de leesbaarheid van deze code. Ik bedoel, laat staan ​​het feit dat dit code is nieuw voor velen van ons in de kamer. 

Maar het gewoon een soort is vrij. Je ziet kleine letters y, kapitaal Y, kleine letters n, de hoofdstad N standaard is gewoon een soort sprongen uit bij u op een manier dat, misschien wel, misschien het vorige voorbeeld met de mitsen en de verticale balken, en de andere ifs, misschien niet. Dus dit is echt een kwestie van persoonlijke keus, echt, of leesbaarheid, van de code. 

Maar in termen van functionaliteit, laat me ga je gang en maak een switch, dot slash switch, en nu typt in kleine letters y, hoofdstad Y, kleine letters n, kapitaal N, David, proberen want dat is geen enkel teken. Laten we het doen x, fout, zoals verwacht. En, logically-- en dit is iets Ik zou aanmoedigen in general-- zelfs hoewel we alleen krassen op het oppervlak van sommige van deze functies. 

En het zou niet duidelijk zijn wanneer je je gaat zitten op het toetsenbord, hoe werkt dit? Wat zou dit doen? Het mooie ding over het hebben een laptop of desktop, of de toegang op een computer met een compiler, en met een code-editor als deze, wordt je bijna altijd antwoord op deze vragen voor jezelf gewoon door te proberen. 

Bijvoorbeeld, als de retorische vraag bij de hand was, wat gebeurt er als je vergeet uw vakantie uitspraken? Dat is eigenlijk een heel gebruikelijk om te doen, want het ziet er niet alsof je ze echt nodig hebt. Ze niet echt te voltooien uw dacht dat als een haakje of een krullende brace doet. Laten we doorgaan en opnieuw compileren van de code en te zien. Dus zorg switch, dot slash switch. Laten we type in kleine letters y, de topkoffer, Enter. Dus ik typte y. 

Het programma zei ja, nee, fout, alsof het was het veranderen van de geest. Maar het soort was, want wat gebeurt er een schakelaar is het eerste geval dat wedstrijd in wezen betekent, he computer, voeren alle van de code eronder. En als je niet zeggen breken, of zeg niet breken, of break niet zeggen, de computer gaat blazen door al die lijnen en uitvoeren allemaal tot het wordt om dat accolade. Zodat de remmen zijn inderdaad nodig. Maar een afhaalmaaltijd hier is, wanneer In geval van twijfel, probeer iets. Misschien sparen eerst uw code, of op te slaan in een extra bestand als je echt bezorgd over verprutsen en het hebben om te herstellen het werk dat je weet dat het werkt. 

Maar probeer dingen. En wees niet zo bang te zijn, misschien, van wat de computer zou kunnen doen, of dat je misschien iets breken. U kunt altijd weer terugschakelen sommige eerdere versie. 

Dus laten we een einde door te kijken bij het ontwerp van de code. We hebben dit vermogen nu om te schrijven omstandigheden en schrijven loops, en variabelen, en belfuncties. Dus, eerlijk gezegd, we zijn soort terug op waar we waren een week geleden met Scratch, zij het met een minder dwingende tekstuele milieu dan Scratch maakt. 

Maar let op hoe snel we hebben verworven dat vocabulaire, zelfs als het gaat een tijdje duren te zinken in, zodat we nu deze woordenschat kunnen gebruiken meer interessante programma's te schrijven. En laten we eens een baby stap naar dat, als hieronder. Laat me ga je gang en maak een nieuw bestand hier. 

Ik ga dit noemen prototype.c, en de invoering van voor het eerst de mogelijkheid om uw eigen functies maken. Sommigen van u zou kunnen hebben dit gedaan met Scratch, waarbij je kunt maken van uw eigen aangepaste blokken in Scratch, en sleep ze op hun plaats waar u maar wilt in C. En in de meeste programmeertalen talen, kunt u precies doen dat-- maak uw eigen functies, als ze nog niet bestaan. 

Dus, bijvoorbeeld, laat me ga je gang en omvatten CS50.h, en omvatten standaard IO.h, int main leegte. En nu hebben we een placeholder klaar om te gaan. Ik blijf afdrukken dingen als mensen namen vandaag. En dat voelt like-- zou het niet mooi zijn als er waren een functie genaamd afdruk naam? Ik hoef niet te printf gebruiken. Ik hoef niet te onthouden alle opmaak codes het. Waarom niet ik, of waarom niet iemand voor mij, maak een functie genaamd afdruk Naam, dat gegeven een naam, gewoon drukt het uit? 

Met andere woorden, als ik zeg, hey, computer, geef me een string door te vragen de gebruiker voor een dergelijke, via CS50's get snaar functie. Hey, computer, zet die string in de variabele in de linkerkant, en noemen het is. En dan, hey computer, ga je gang en af ​​te drukken dat de naam van persoon, gedaan. 

Nu, zou het leuk zijn, want dit programma, toepasselijke naam, vertelt me ​​wat het moet doen door middel van de namen die de functie van. Laat me gaan en maak prototype, Enter. En, helaas, dit is niet van plan om te vliegen. 

Prototype.c, lijn 7, karakter 5, fout, impliciete verklaring van de functie afdruk naam ongeldig is in C99, C99 betekent een versie van C dat uitkwam in 1999. Dat is alles. 

Dus ik weet niet wat allemaal betekent nog. Maar ik doe fout te herkennen in het rood. Dat is vrij duidelijk. 

En het schijnt dat met het groene karakter hier, het probleem is met de naam print, geopend paren s, dicht paren, puntkomma. Maar impliciete verklaring van functie zagen we kort eerder. Dit betekent eenvoudigweg dat Clang weet niet wat ik bedoel. 

Ik heb een woordenschat woord gebruikt dat het nooit gezien of eerder geleerd. En dus ik moet onderwijzen wat deze functie betekent. Dus ik ga om verder te gaan en dat te doen. 

Ik ga om verder te gaan en uit te voeren Mijn eigen functie genaamd Print Naam. En ik ga zeggen, als volgt, dat Het doet dit, printf, hello, procent s, backslash n, naam, puntkomma. Dus wat heb ik gewoon doen? 

Dus het blijkt, naar implementeren van uw eigen functie, we soort lenen van dezelfde structuur als belangrijkste dat we net geweest vanzelfsprekend, en ik weet gewoon kopiëren en plakken vrij veel wat Ik schrijf in het verleden. Maar hier ziet het patroon. Int, Main, Void, zullen we uit elkaar plagen het duurde niet lang wat dat eigenlijk betekent. 

Maar voor vandaag, net let op de parallelliteit. Void, print naam, tekenreeksnaam, dus er is een paarse zoekwoord, die we gaan beginnen roepen een return type, de naam de functie en de input. Dus, in feite, kunnen we destilleren dit soort als vorige week aangezien dit de naam of algoritme van de code zijn we gaan naar de write-- algoritme onderliggende de code we gaan schrijven. 

Dit is de ingang. Dit is de uitgang. Deze functie, print naam, is ontworpen om een ​​string genaamd naam te nemen, of wat dan ook, als input, en dan leegte. Het geeft niets, zoals krijgen touw of krijgen int doet. Dus het gaat me overhandigen iets terug. Het is gewoon gaat om een ​​hebben neveneffect, zo te zeggen, van het afdrukken van de naam van een persoon. Zo merken, lijn 7, I kan naamdruk bellen. Lijn 10, ik kan definiëren of de uitvoering van de naam af te drukken. Maar, helaas, dat is niet genoeg. 

Laat me ga je gang en recompile deze na het opslaan. Whoa, nu, ik heb het gedaan nog erger, zo lijkt het. Dus impliciete verklaring van functie afdruk naam is ongeldig. En, nogmaals, er is meer fouten. Maar zoals ik al eerder gewaarschuwd, zelfs als je overweldigd door te krijgen, of een beetje triest om zo veel te zien errors, richten zich op de eerste in eerste instantie, want het zou wel eens een cascade-effect hebben gehad. Dus C, of ​​Clang meer in het bijzonder, nog steeds niet naamdruk herkennen. 

En dat komt omdat Clang, door het ontwerp, is een beetje dom. Het doet alleen wat je hem vertelt wat te doen. En doet alleen zo in de volgorde waarin je hem vertelt wat te doen. 

Dus ik heb de belangrijkste on-line vier gedefinieerd, zoals wij hebben gedaan vrij vaak. Ik heb naamdruk gedefinieerd op lijn 10. Maar ik probeer te gebruiken afdrukken naam op de lijn zeven. 

Het is te vroeg, bestaat nog niet. Dus kon ik slim te zijn, en zijn als, OK, dus laten we gewoon meespelen, en beweeg naamdruk up hier, en opnieuw samen te stellen. O mijn God. Het werkte. Het was zo simpel als dat. 

Maar de logica is precies dat. Je moet Clang te leren wat het is door het definiëren van de functie eerste. Dan kunt u deze gebruiken. Maar, eerlijk gezegd, dit voelt als een hellend vlak. 

Dus elke keer als ik run een probleem, ik ben gewoon gaan om te markeren en kopieer de code Ik schreef, knippen en plakken hier. En, zeker, we konden verzinnen sommige scenario's waar men bijvoorbeeld nog moeten naar een andere te bellen. En je gewoon niet kan zetten elke functie boven alle andere. 

Zo blijkt er's een betere oplossing. We kunnen verlaten deze zijn. En, eerlijk gezegd, het is over het algemeen aardig, en handig, en een goed ontwerp om omdat, weer de belangrijkste op de eerste plaats, belangrijkste net als bij groene vlag geklikt, dat is de functie die wordt uitgevoerd door gebrek. Dus je kan net zo goed zetten het op het begin van het bestand zodat wanneer u of een andere menselijke kijkt naar het bestand je weet wat er aan de hand gewoon door het lezen van de belangrijkste eerste. Dus het blijkt, kunnen we Clang vertellen proactief, hey, Clang, on-line vier, Ik beloof te implementeren een functie genaamd Print Naam die een string genaamd naam dankt als input, en keert terug niets, leegte. En ik zal rond aan de uitvoering ervan later. 

Hier komt Main. Main nu op lijn 9 kunt gebruiken Print Naam omdat Clang is het vertrouwen dat, uiteindelijk, zal de definitie tegenkomen van de uitvoering van de Print Name. Dus na mijn bestand op te slaan, te laten ik ga je gang en maken prototype, ziet er goed uit deze tijd. Dot slash, prototype, laat me ga je gang en typ in een naam. David, hello David, Zamila, hello Zamila, en, inderdaad, nu het werkt. 

Dus het ingrediënt hier is dat we hebben maakte een aangepaste functie, zoals een aangepaste Scratch blok we noemen het. Maar in tegenstelling tot Scratch waar u kunt gewoon maken het en gaan gebruiken, nu moeten we een zijn beetje pedant, en eigenlijk trainen Clang te gebruiken of te verwachten. Nu, als een terzijde, waarom al die tijd hebben we gewoon blind geweest op het geloof, waaronder CS50.h, en inclusief standaard IO.h? 

Nou, zo blijkt, onder een paar andere dingen, alles wat in die dot h bestanden, die toevallig bestanden. Ze header-bestanden, om zo te zeggen. Ze zijn nog steeds geschreven in C. Maar ze zijn een ander type bestand. 

Voor nu, kan je vrij veel veronderstellen dat alles wat is de binnenkant van CS50.h is een aantal one-liners als deze, niet voor functies genaamd Print Naam, maar voor Get String, Get Float, en een paar anderen. Er zijn vergelijkbare prototypes, voeringen één, de binnenkant van standaard IO.h voor printf, die nu in Mijn eigen Print Naam functie. Dus met andere woorden, dit hele tijd dat we hebben net blindelings kopiëren en plakken omvatten deze omvatten dat, wat is er aan de hand? Dat zijn gewoon een soort aanwijzingen naar Clang wat functies zijn inderdaad uitgevoerd, net elders in verschillende bestanden elders op het systeem. 

Dus we hebben naamdruk geïmplementeerd. Het heeft de bijwerking van afdrukken iets op het scherm. Maar het doet niet echt geef me iets terug. Hoe gaan we over de uitvoering van een programma dat doet geef me iets terug? 

Nou, laten we proberen dit. Laat me ga je gang en uit te voeren een bestand genaamd return.c zodat we kunnen laten zien hoe iets bevallen Win String, of Vraag Int, eigenlijk terug iets terug aan de gebruiker. Laten we gaan en te definiëren int main leegte. 

En, nogmaals, in de toekomst, zullen we uitleggen wat die int en die leegte is werkelijk te doen. Maar voor vandaag, zullen we neem het voor lief. Ik ga je gang en printf gaan, voor een goede gebruikerservaring, x is. En dan ga ik te wachten op de gebruiker om me x met get int. 

En dan ga ik om verder te gaan en uit te printen x naar het plein. Dus als je alleen maar een toetsenbord, mensen vaak gebruik maken van de kleine carrot symbool op het toetsenbord te vertegenwoordigen de macht van, of de exponent van. Dus x kwadraat is aanwezig i. 

En nu ga ik om dit te doen. Ik kon gewoon doen-- wat x kwadraat? x kwadraat is x maal x. 

En dat deden we een aantal tijd geleden al vandaag. Dit voelt niet als dat alles veel vooruitgang. Weet je wat? Laten we profiteren van een aantal van dat idee van de laatste tijd van de abstractie. 

Zou het niet mooi zijn als is er een functie genaamd plein dat precies dat doet? Nog steeds aan het einde van de dag, doet hetzelfde wiskunde. Maar laten we abstract weg van het idee van het nemen een aantal vermenigvuldigd met een ander, en geef het een naam, zoals vierkant deze waarde. 

En, in andere woorden, in C, laten we zorgen voor een functie genaamd plein dat precies dat doet. Het gaat vierkante genoemd te worden. Het gaat om een ​​int nemen. En we zullen gewoon noem het n standaard. 

Maar we konden het noemen wat we willen. En alles wat het gaat om te doen, letterlijk, is terugkeer het resultaat van n maal n. Maar omdat het terugkerende iets wat is het sleutelwoord in het paars we hebben nooit eerder gezien, ik, op lijn 11, kan niet zomaar zeggen leegte deze tijd. 

Void, in het voorbeeld dat we net zagen in plaats van de naam van print, betekent gewoon, doe iets. Maar niet geef me iets terug. In dit geval wil ik terug n maal n, of wat dat ook is, dat nummer. 

Dus ik kan niet zeggen, hey, computer, Ik terug niets, leegte. Het gaat om terug te keren, door de natuur, een int. En dus dat is alles wat er hier aan de hand. 

De ingang naar veld gaat een int. En zodat we het kunnen gebruiken, moet het een naam, N. Het gaat om de productie een int die geen naam nodig heeft. We kunnen het overlaten aan de belangrijkste, of wie dan ook is met behulp van me om deze waarde als we bedenken wil met een eigen variabele. 

En, nogmaals, de enige nieuwe sleutelwoord is hier terug. En ik doe gewoon wat wiskunde. Als ik wilde echt niet nodig te zijn, Ik zou kunnen zeggen int product krijgt n keer n. 

En dan zou ik zeggen, terug product. Maar, nogmaals, om mijn punt vroegste van dit gewoon niet goed zijn design-- zoals, waarom de invoering van een naam, een symbool, zoals product, alleen maar om onmiddellijk terug te sturen? Het is een beetje schoner, een beetje strakker, dus te spreken, alleen maar om return n keer zeggen n, zich te ontdoen van deze lijn helemaal. 

En het is gewoon minder code te lezen, minder kans op fouten. En laten we eens zien of dit nu eigenlijk werkt. Nu, ik ga om te gaan vooruit en rendement te maken. 

Uh-oh, impliciete verklaring van de functie. Ik maakte deze fout eerder, geen big deal. Laat me enkel type, of markeer en kopiëren, exact dezelfde functie prototype, of handtekening van de functie hier. Of ik kon de hele functie te verplaatsen. 

Maar dat is een beetje lui. Dus zullen we niet doen. Nu, laat me terugkeer nogmaals, dot slash terugkeer. 

x is 2. x kwadraat is 4. x is 3 x kwadraat is 9. En de functie lijkt nu te werken. Dus wat is het verschil? Ik heb een functie die vierkant heet, in dit geval, dat ik in een input. En ik krijg weer een uitgang. Toch, eerder, indien Ik open de ander voorbeeld van eerdere, waarvan was genoemd prototype.c, Ik had afdrukken naam, die void terug zogezegd, Of het terug niets, en gewoon had een neveneffect. 

Dus wat is hier aan de hand? Nou ja, kunt u overwegen de functie krijgen string voor een ogenblik. We hebben met de functie krijgen tekenreeks als volgt. 

We hebben gehad een functie te krijgen koord, zoals onder meer CS50.h, zijn standaard IO.h, int, belangrijkste, nietig. En dan elke keer dat ik heb genaamd get reeks tot nu toe, Ik heb gezegd iets dergelijks, touw s krijgt krijgt koord, want get string-- laten we noemen dit get.c-- get snaar zelf retourneert een string die ik kan dan gebruiken, en zeggen: hallo, komma, procent s, backslash n, s. 

Dus dit is hetzelfde voorbeeld, echt, dat we hadden eerder. Dus maak je snaar een waarde retourneert. Maar een moment geleden, afdrukreeks geen waarde terug te keren. Het heeft slechts een neveneffect. Dus dit is een fundamenteel verschil. We hebben verschillende gezien typen functies nu, waarvan sommige zijn teruggekeerd waarden, waarvan sommige niet. Dus misschien is het koord, of int of float. Of misschien is het gewoon nietig. 

En het verschil dat deze functies gegevens krijgen en terug te keren een waarde zijn eigenlijk het brengen van iets terug naar de tafel, bij wijze van spreken. Dus laten we gaan vooruit en kijken naar een laatste set voorbeelden die een gevoel geeft, nu van hoe wij, inderdaad, abstract beter, en beter en beter, of meer, en meer, en meer, met het oog schrijven uiteindelijk betere code. Laten we gaan vooruit, en in de geest van Scratch, doet u het volgende. 

Laat me ga je gang en omvatten CS50.h en standaard io.h. Laat me ga je gang en geef mijzelf een int, belangrijkste, nietig. En laat me doorgaan, noemen dit cough.c. 

En laat me gaan en gewoon zoals Scratch, uitprinten hoest / n. En ik wil dit drie keer doen. Dus ik ben, natuurlijk, gewoon te kopiëren en plakken drie keer. Ik ga nu te maken hoesten dot slash hoest. Laten we geef mezelf een beetje meer ruimte hier, Enter, hoesten, hoest, hoest. 

Er is, natuurlijk, al een mogelijkheden voor verbetering. Ik heb gekopieerd en geplakt een paar keer vandaag. Maar dat was alleen zo ik niet moeten zoveel mogelijk tekens te typen. Ik heb nog steeds wat veranderd die regels code zijn. 

Deze drie lijnen identiek, die voelt lui en inderdaad is, en is waarschijnlijk niet de juiste aanpak. Dus met welk ingrediënt kunnen we het verbeteren van deze code? We hoeven niet te kopiëren en te plakken code. 

En inderdaad, op elk moment voel je je jezelf te kopiëren en te plakken, en niet zelfs het veranderen van de code, de kans groot dat er een betere manier. En inderdaad is. Laat me ga je gang en doe een lus, hoewel het misschien niet syntax komen nog natuurlijk. 

Doe dit drie keer, gewoon door het doen van de following-- en ik toevallig deze kennen uit de praktijk. Maar we hebben een aantal voorbeelden kaarten. En je zult zien online meer referenties nog steeds. 

Dit is de syntax op lijn 6, dat net als Scratch dat herhaalt blok, herhaal de volgende drie keer. Het is een beetje magisch voor nu. Maar dit zal meer te halen, en meer vertrouwd. 

En het zal herhalen lijn acht drie keer, dus dat als ik opnieuw compileren make hoest, dot slash hoest, hoesten, hoest, hoest. Het werkt nog steeds op dezelfde manier. Dus dat is allemaal prima en goed. Maar dat is niet erg geabstraheerd. 

Het is volkomen juist. Maar het voelt alsof er een kans kan zijn, zoals in de wereld van Scratch, van de soort start om wat semantiek hier toevoegen zodat Ik heb geen gewoon wat voor de lus, en een functie die zegt hoesten, of is hoesten. Weet je wat? Laat me proberen te zijn een beetje koeler dan dat, en eigenlijk schrijven functie heeft een aantal bijwerkingen, noem het hoesten. 

En het duurt geen input en had geen waarde als output. Maar weet je wat het doet? Het doet dit-- printf, citaat unquote, hoesten. 

En nu hier, ik ga om vooruit en int gaan, i krijgt nul, i minder dan 3, i plus plus. Ik ga printf niet doen, dat is misschien wel een lage uitvoeringsniveau detail. Kan me niet schelen hoe te hoesten. Ik wil gewoon de hoest functie te gebruiken. En ik ga gewoon hoesten bellen. 

Nu, let op de tweedeling. Wanneer u een functie aan te roepen, als je dat niet doet willen geven ingangen, helemaal prima. Gewoon doen openen paren, in de buurt paren, en je bent klaar. 

Wanneer u een functie definiëren of verklaren prototype van een functie, als je weet van tevoren dat het niet van plan om alle argumenten te nemen, zeggen leegte in die tussen haakjes daar. En dat zorgt ervoor dat je niet per ongeluk misbruiken. Laat me ga je gang en maak hoest. En, natuurlijk, ik heb een fout gemaakt. 

Dammit, er is dat impliciete verklaring. Maar dat is prima. Het is een makkelijke oplossing. Ik moet alleen het prototype hoger in mijn dossier dan ik ben eigenlijk gebruiken. 

Dus nu laat ik hoest weer, nice. Nu werkt het. Voeg hoest, hoest, hoest, hoest. Dus je zou denken dat we echt iets meer dan engineering van dit probleem. En inderdaad, we zijn. Dit is niet een goede kandidaat van een programma momenteel voor refactoring, en doen wat genoemd hiërarchische decompositie, waar u enkele code, en dan je soort van factor dingen uit, om zo om meer semantiek toeschrijven aan hen, en opnieuw te gebruiken uiteindelijk de langere termijn. Maar het is een bouwsteen in de richting van verfijndere programma dat we beginnen het schrijven van het duurde niet lang dat laat ons toe om de woordenschat waarmee betere code te schrijven. En, inderdaad, laten we eens kijken of we kan dit niet verder te generaliseren. 

Het lijkt een beetje lame dat ik, de belangrijkste, zorgen te maken over deze darn lus, en bellen hoesten opnieuw en opnieuw. Waarom kan ik niet gewoon vertellen hoesten, Neem hoesten drie keer? Met andere woorden, waarom kan ik niet gewoon geeft input te hoesten en dit te doen? 

Waarom kan ik niet gewoon zeggen, in belangrijkste hoest driemaal. En nu, dit is een soort van magisch. Het is hier heel iteratief. En het is inderdaad een baby stap. 

Maar de mogelijkheid om op te zeggen lijn acht, hoesten drie keer, het is gewoon zo veel meer leesbaar. En plus, heb ik niet te weten of schelen hoe hoest wordt geïmplementeerd. En zelfs later in de termijn en voor de laatste projecten, als je een project aan te pakken een klasgenoot of twee klasgenoten, zul je beseffen dat je gaat moeten of willen, verdeel het werk. 

En je gaat te willen om te beslissen vooraf, wie gaat wat doen, en waarbij stukken? En zou het niet mooi zijn Als je bijvoorbeeld de leiding nemen van het schrijven van de belangrijkste, gedaan. En je kamergenoot, of uw partner meer in het algemeen, draagt ​​zorg voor de uitvoering van hoest. 

En deze divisie, deze muren van abstractie, of abstractielagen indien u zult zijn super krachtig, omdat vooral voor grotere, meer complexe programma's en systemen, Het maakt het mogelijk meerdere mensen op te bouwen dingen samen, en uiteindelijk steek hun werk op deze manier samen. Maar, natuurlijk, we moeten nu op te lossen hoest. We moeten hoesten vertellen dat, hey, weet je wat? Je gaat nodig hebben om een ​​te nemen input-- dus niet ledig, maar int en nu. Laten we doorgaan en in gebruik genomen hoesten het int. i krijgt nul. 

i kleiner is dan het aantal keren. Ik zei drie eerder. Maar dat is niet wat ik wil. Ik wil hoest te worden gegeneraliseerd naar ondersteuning voor enig aantal iteraties. 

Dus, inderdaad, het is n dat ik wil, ongeacht de gebruiker vertelt me. Nu, ik kan gaan en zeggen druk hoest. En het maakt niet uit welk nummer de gebruiker gaat in, Ik zal herhalen dat vele malen. 

Dus aan het eind van de dag, programma identiek. Maar let op al deze spullen kan zelfs in een ander bestand. Sterker nog, ik weet het niet bij de Momenteel hoe printf wordt geïmplementeerd. 

Ik weet niet op dit moment hoe krijgen tekenreeks of krijgen int, of om float ten uitvoer worden gelegd. En ik wil niet ze te zien op mijn scherm. Zoals het is, begin ik te concentreren op mijn programma, niet die functies. 

En ja, inderdaad, zodra je start factoring code als volgt uit, konden we verhuizen zelfs hoesten naar een apart bestand? Iemand anders zou het uit te voeren. En u en uw programma te worden van de heel mooi, en zeer leesbaar, misschien wel, eigenlijk vier line programma daar. 

Dus laten we nu doorgaan en maak nog een verandering. Merk op dat mijn prototype moet veranderen boven. Dus laat me dat vast te stellen, zodat Krijg ik niet uitgescholden. 

Maak hoesten, laat ik hoest een keer draaien meer, nog steeds hetzelfde te doen. Maar nu zien we een ingrediënt voor een definitieve versie. Weet je wat? Ik wil niet alleen maar hoesten, per se. Ik wil iets meer algemeen. Dus weet je wat? Ik wil dit doen. Ik wil hebben, net als Scratch doet, inspraak blok, maar niet alleen iets zeggen sommige aantal keren. Ik wil dat het een zeer specifieke reeks zeggen. En daarom doe ik niet wil dat het gewoon zeggen hoest. Ik wil om te zeggen wat tekenreeks wordt doorgegeven. 

Zo merken, heb ik gegeneraliseerd Dit zodat nu zeg voelt als een goede naam voor deze, zoals Scratch, heeft twee argumenten, in tegenstelling tot Scratch. Een daarvan is een string. Een daarvan is een int. 

En ik kon ze te verwisselen. Ik heb net zoiets als het idee van zeggen dat de snaar, en dan hoe vaak later. Leegte betekent dat het nog steeds niets terug. Dit zijn slechts visuele kant effecten, zoals bij [? Jordan,?] een mondelinge neveneffect van schreeuwen. Het doet nog steeds iets n keer, 0 tot, maar niet gelijk aan n. Dit betekent dat in totaal n keer. En dan gewoon uitprinten wat dat string is. Dus ik heb echt gegeneraliseerd deze lijn van code. Dus nu, hoe kan ik implementeren de hoest functie? 

Ik kan leegte hoesten doen. En ik kan nog wel in de manier waarop vaak u wilt hoesten. Maar weet je wat? Ik kan nu punter te zeggen. 

Ik kan bellen zeggen met de woord hoesten, passeren in n. En als ik wil ook uit te voeren, gewoon voor de lol, een nies functie, Ik kan een aantal aantal keer niezen. En ik kan blijven hergebruik van n, want m merken dat in deze context of strekking bestaat alleen op deze functie. 

En n in deze context alleen bestaat binnen deze functie hier. Dus we zullen terug te komen deze kwesties van omvang. En hier, ik ga gewoon om te zeggen, achoo, en dan n keer, puntkomma. 

En nu, ik moet gewoon om te lenen deze functie handtekeningen hier. Dus hoest is correct. Void niezen is nu correct. 

En ik moet nog maar zeggen. Dus ik ga zeggen, laten we zeggen koord s, int n, puntkomma. Dus ik heb over-engineering van de heck uit van dit programma. 

En dit betekent niet noodzakelijkerwijs betekent dit is wat je moet doen bij het schrijven zelfs de eenvoudigste programma. Neem iets dat is natuurlijk heel simpel, heel kort, en re-implementeren het gebruik van veel te veel code. Maar je zult echt zien, en in tijd kijken terug op deze voorbeelden, en beseffen, oh, dat zijn de stappen we hebben om daadwerkelijk te generaliseren, iets factor out, tot aan het eind van de dag mijn code is eigenlijk vrij redelijk. Want als ik wil hoesten drie keer niezen dan drie keer, Ik ga gewoon naar deze opnieuw uit te voeren, programma te maken hoesten en lopen hoesten. En ik heb drie hoesten en drie niest. 

En dus dit is een fundamentele paradigma, als je wil, voor de manier waarop we zouden gaan over het eigenlijk de uitvoering van een programma. Maar laten we nu zien wat het is we hebben al die tijd te doen, en wat sommige van de laatste invullingen achter deze eenvoudige opdracht. Aan het eind van de dag, we hebben zijn met behulp van Clang als onze compiler. We zijn het schrijven van de bron code converteren via Clang in machine code. 

En we hebben gebruik gemaakt van Zorg onze toetsaanslagen zo vergemakkelijken dat we niet hoeven te onthouden die bezweringen van Clang zelf. Maar wat is je eigenlijk aan het doen? En op hun beurt, wat Clang eigenlijk aan het doen? 

Het blijkt dat, hoewel we hebben vereenvoudigd bespreking van vandaag door te zeggen: je broncode te nemen, doorgeven als input voor een compiler, die u geeft output van machine code, blijkt dat er's een paar verschillende stappen binnen is er. En compileren gebeurt er met de paraplu te zijn term voor een heleboel stappen. Maar laten we gewoon plagen dit uit heel snel. 

Het blijkt dat we hebben gedaan meer dingen elke keer als ik een programma uit te voeren, of elke keer als ik de samenstelling van een programma van vandaag. Dus preprocessing betreft dit-- alles in een C-programma, zoals we zullen zien opnieuw en opnieuw, dat begint met deze hekje, of de hashtag symbool hier, betekent het is een preprocessor richtlijn. Dat betekent in dit geval, he computer, doe iets met dit bestand voordat u daadwerkelijk compileren mijn eigen code. 

In dit geval, hash bevatten is, wezen, C's manier om te zeggen, hey computer, haal de inhoud van CS50.h en plak ze hier. Hey computer, haal de inhoud van standaard IO.h, waar dat op de harde schijf, plak het hier. Dus die dingen gebeuren eerst tijdens de voorbewerking. 

En Clang doet dit alles voor ons. En het doet het zo verdraaid snel, heb je niet eens zie vier verschillende dingen gebeuren. Maar dat is het eerste dergelijke stap. 

Wat gebeurt er eigenlijk de volgende stap? Nou, de volgende officiële stap is het opstellen van. En het blijkt dat het programmeren technisch betekent gaande van broncode, de spullen die we hebben schrijft vandaag de dag, om iets te riep assemblage-code, iets dat ziet er een beetje anders uit. 

En, in feite, we kunnen dit zien heel snel. Laat me eigenlijk in mijn IDE gaan. Laat me ga je gang en een open hello.c, die is het eerste programma waarmee we vandaag begonnen. En laat me ga je gang en lopen Clang een beetje anders, Clang-s, hello.c, die eigenlijk gaat geef me een ander bestand hello.s. 

En we zullen waarschijnlijk nooit weer te zien dit soort code. Als u een lager niveau te nemen systemen klasse zoals CS61, je zal veel meer te zien Dergelijke code. Maar dit is assembler. Dit is X86 assembler dat de CPU die onderliggende CS50 IDE eigenlijk begrijpt. 

En cryptisch als het doet kijk, het is iets de computer begrijpt vrij goed. Sub q, dit is een subtract. Er zijn bewegingen. 

Er belt functies hier, x oring, een beweging, een invoegtoepassing, een pop, een terugkeer. Dus is er een aantal zeer low level instructies dat CPU's begrijpen dat Ik zinspeelde eerder. Dat is wat Intel Inside. 

Er zijn patronen nullen en enen dat toewijzen aan deze arcanely geformuleerd, maar enigszins goed met de naam, instructies, bij wijze van spreken. Dat is wat er gebeurt als je compileert uw code. Je krijgt assemblage taal van te maken, die : de derde stap is te monteren dat assemblage-code in, uiteindelijk, machine code-- nullen en enen, niet de tekst die we net zagen een moment geleden. 

Dus pre-processing betekent dat vinden en vervang, en een paar andere dingen. Compileren neemt uw bron code van C, broncode dat we schreven, aan de montage code dat we net keek. Assembleren neemt dat assemblage code om nullen en enen dat de CPU echt wil begrijpen aan het eind van de dag. En linking is de laatste stap dat gebeurt voor ons-- weer, zo snel dat we niet eens notice-- dat zegt: hey computer, nemen alle de nullen en enen dat het gevolg van het opstellen van David's code, en zijn belangrijkste functie in dit geval. 

En hey computer, gaan halen alle nullen en enen dat de CS50 personeel schreef in de CS50 bibliotheek. Meng die met Davids. En hey computer, haal alle nullen en degenen die iemand anders schreef jaar geleden voor printf. En toe te voegen die in de hele zaak, zodat we hebben kreeg mijn nullen en enen, de nullen en enen CS50 personeel, de printf nullen en enen, en alles wat we gebruiken. 

Ze krijgen allemaal samen gecombineerd in één programma genaamd, in dit geval, hello. Dus voortaan, zullen we gewoon gebruiken het woord compileren. En we zullen vanzelfsprekend dat wanneer zeggen wij, samenstellen van uw programma, het betekent, hey doe de pre-processing, assembleren en koppelen. Maar er is eigenlijk een aantal sappige stuff gebeurt er onder de motorkap. En vooral als je krijgen nieuwsgierig wat tijd, je kunt beginnen met prikken rond op dit lagere niveau. Maar voor nu, beseffen dat onder de afhaalrestaurants voor vandaag zijn gewoon de begin van een proces, het krijgen van comfortabel met zoiets als Hello World. Sterker nog, de meeste van wat we vandaag gedaan zeker niet zal zinken in super snel. En het zal enige duren tijd, en wat oefening. En kansen zijn, zult u sorteren van het toetsenbord wilt raken of schreeuwen tegen het scherm. En dat alles is OK. Hoewel, misschien probeer niet te doe het in de bibliotheek zo veel. 

En uiteindelijk, zult u worden in staat hoewel, om te beginnen het zien van patronen, zowel in goede code dat je hebt geschreven en in fouten die je hebt gemaakt. En net als het proces van steeds een TF of een CA is als, zult u beginnen om beter te worden en beter bij het zien van die patronen, en gewoon het oplossen van uw eigen problemen uiteindelijk. In de tussentijd zal er genoeg zijn van ons om jullie steun te verlenen, en krijg je door dit. En in de schrijf-ups voor alle problemen wordt u begeleid bij alle opdrachten dat ik zeker weet uit veel van de praktijk van nu, maar zou hebben gevlogen boven het hoofd voor nu. En dat is helemaal prima. 

Maar, uiteindelijk, je gaat om te beginnen om te zien patronen ontstaan. En zodra je langs alle van de dom details, zoals haakjes, en accolades en puntkomma's, en het spul, eerlijk gezegd, dat is niet helemaal intellectueel interessant. En het is niet het doel van het nemen van een inleidende les. Het zijn de ideeën die gaan uit. 

Het is de lussen, en de omstandigheden en de functies, en krachtiger de abstractie, en de factoring van de code, en het een goed ontwerp, en de goede stijl, en uiteindelijk de juistheid van de code, dat is uiteindelijk gaan naar de meest toe. Dus volgende week, zullen we deze nemen ideeën die we voor het eerst zag in Scratch en hebben nu vertaald C. En we beginnen introduceren de eerste van de Natuurlijk de echte wereld domeinen. 

We zullen focussen op de wereld van de veiligheid, en meer in het bijzonder cryptografie, de kunst van het klauteren informatie. En een van de eerste problemen die je jezelf krijgt om verder te schrijven spelen met een aantal van de syntax en het oplossen van een aantal logische problemen, uiteindelijk duurde niet lang, is om daadwerkelijk te klauteren, of te versleutelen, en uiteindelijk decoderen gegevens. En alles wat we hebben gedaan Vandaag zal vrij laag niveau, is gewoon toestaan ons één en één nemen, en nog een stap boven in de richting van schrijven maar de meest interessante code. 

Dus meer daarover volgende week. 

[VIDEO AFSPELEN] 

Wat kan je me vertellen over de laatste keer dat je hem zag? Wat kan ik zeggen, echt? Ik bedoel, het was net als elk ander pre-productie repetitie, behalve dat er iets was, zei hij aan het eind dat geplakt met mij. 

-Dit Was CS50. 

Dat is een cut iedereen, geweldige baan bij de repetitie. 

lunch -dat's? 

Ja, jij en ik kan pak een sandwich in een beetje. Laat me ondervragen met David echt snel. David? David? 

[END AFSPELEN] 