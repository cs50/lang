1
00:00:00,000 --> 00:00:00,500

2
00:00:00,500 --> 00:00:02,490
[Reprodución de música]

3
00:00:02,490 --> 00:00:16,950

4
00:00:16,950 --> 00:00:19,240
>> DAVID J. Malan: Todo ben, iso é CS50.

5
00:00:19,240 --> 00:00:21,010
E esta é unha semana.

6
00:00:21,010 --> 00:00:25,050
Entón lembro a última vez a semana cero,
Nós nos concentrados en pensamento computacional.

7
00:00:25,050 --> 00:00:28,440
E a transición de que a
Cero, a programación gráfica

8
00:00:28,440 --> 00:00:30,360
linguaxe dos nosos amigos
no Media Lab do MIT.

9
00:00:30,360 --> 00:00:34,730
>> E co Scratch, que exploran
ideas como funcións e condicións,

10
00:00:34,730 --> 00:00:38,210
e loops e variables, e mesmo
eventos e debates, e máis.

11
00:00:38,210 --> 00:00:40,880
E hoxe, imos
continuar a utilizar estas ideas,

12
00:00:40,880 --> 00:00:43,630
e realmente levalos para
concedido, pero traducilo las

13
00:00:43,630 --> 00:00:47,220
a outro idioma coñecido como C. Agora
C é unha linguaxe máis tradicional.

14
00:00:47,220 --> 00:00:49,020
É un nivel máis baixo
a linguaxe, se quere.

15
00:00:49,020 --> 00:00:50,300
>> É puramente textual.

16
00:00:50,300 --> 00:00:52,910
E así, a primeira vista, é
todo vai mirar un pouco críptica

17
00:00:52,910 --> 00:00:54,430
se nunca programou antes.

18
00:00:54,430 --> 00:00:56,530
Nós imos ter
punto e coma e parénteses,

19
00:00:56,530 --> 00:00:58,150
e chaves, e moito máis.

20
00:00:58,150 --> 00:01:00,240
Pero entender que, aínda
aínda que a sintaxe sexa

21
00:01:00,240 --> 00:01:03,600
sobre a mirar un pouco familiarizado
a maioría de vós, ver ademais.

22
00:01:03,600 --> 00:01:06,220
E tentar ver as ideas
que son, de feito, familiar,

23
00:01:06,220 --> 00:01:09,750
porque aquí a semana un o que
comezaremos a facer é comparar,

24
00:01:09,750 --> 00:01:11,980
Inicialmente, Raspe contra C.

25
00:01:11,980 --> 00:01:15,350
>> Así, por exemplo, recordar que cando
aplicou o primeiro dos nosos programas

26
00:01:15,350 --> 00:01:19,220
último, tivemos un bloque que parecía
un pouco algo como isto-- cando

27
00:01:19,220 --> 00:01:22,990
bandeira verde premendo, e despois tivemos
Un ou máis pezas do puzzle, abaixo dela,

28
00:01:22,990 --> 00:01:25,150
neste caso, dicir, Ola mundo.

29
00:01:25,150 --> 00:01:27,870
Entón, en realidade, en perigo,
cando premo que a bandeira verde

30
00:01:27,870 --> 00:01:30,390
para realizar o meu programa, de xeito
falar, son

31
00:01:30,390 --> 00:01:32,520
os bloques que son executadas, ou correr.

32
00:01:32,520 --> 00:01:35,230
E, especialmente, risco
dixo, Ola, mundo.

33
00:01:35,230 --> 00:01:38,377
>> Agora, eu podería especificar
diferentes palabras aquí.

34
00:01:38,377 --> 00:01:40,960
Pero imos ver que, de feito, moitos
destes blocks-- e, en realidade,

35
00:01:40,960 --> 00:01:44,880
C en moitas funcións no se pode
parametrizada ou personalizado

36
00:01:44,880 --> 00:01:46,150
para facer cousas diferentes.

37
00:01:46,150 --> 00:01:48,520
De feito, en C
Quere converter agora

38
00:01:48,520 --> 00:01:50,567
este programa Raspadinha
a esta outra lingua,

39
00:01:50,567 --> 00:01:52,650
nós estamos indo a escribir un
pouco algo así.

40
00:01:52,650 --> 00:01:55,540
>> Concedida, hai algunha estraña
sintaxe hai máis probable, int,

41
00:01:55,540 --> 00:01:57,380
e parénteses e sen efecto.

42
00:01:57,380 --> 00:02:00,740
Pero printf-- mesmo que faría
creo que sería só impresión.

43
00:02:00,740 --> 00:02:03,120
Pero de impresión significa impresión
formato, como veremos en breve.

44
00:02:03,120 --> 00:02:05,140
Esta literalmente imprimirá
para a pantalla que quere

45
00:02:05,140 --> 00:02:08,990
está dentro destes parénteses, que
Claro que neste caso é, Ola mundo.

46
00:02:08,990 --> 00:02:12,290
>> Pero vai notar algunhas outras
sintaxe, algunhas comiñas,

47
00:02:12,290 --> 00:02:14,890
que os parénteses ao final,
o e coma e similares.

48
00:02:14,890 --> 00:02:18,027
Polo tanto, hai un pouco de sobrecarga,
por así dicir, cognitivamente tanto

49
00:02:18,027 --> 00:02:20,860
e sintaticamente, que imos
ter que lembrar antes de tempo.

50
00:02:20,860 --> 00:02:23,720
Pero entender que coa práctica,
iso vai comezar a ir para fóra en ti.

51
00:02:23,720 --> 00:02:27,920
>> De feito, imos concentrar no que un
función specifically-- neste caso

52
00:02:27,920 --> 00:02:29,290
dicir Hola mundo.

53
00:02:29,290 --> 00:02:30,560
Entón, digamos que é a función.

54
00:02:30,560 --> 00:02:34,320
Ola, mundo é o seu parámetro,
ou argumento, a personalización.

55
00:02:34,320 --> 00:02:37,320
>> E a equivalencia en C é só
será esta unha liña aquí,

56
00:02:37,320 --> 00:02:41,710
onde printf equivale a, digamos,
a cadea entre comiñas dobres, Ola

57
00:02:41,710 --> 00:02:44,470
mundo equivale, por suposto,
ao que está no cadro branco alí.

58
00:02:44,470 --> 00:02:48,680
E a barra invertida n, aínda que un pouco
estraña e ausente a partir de cero,

59
00:02:48,680 --> 00:02:52,380
simplemente vai ter o efecto que
ver nun ordenador, como o meu Mac ou PC,

60
00:02:52,380 --> 00:02:54,660
de só movendo o
cursor á seguinte liña.

61
00:02:54,660 --> 00:02:56,970
É como bater
Intro no teclado.

62
00:02:56,970 --> 00:02:58,580
>> Entón, imos ver iso de novo antes de tempo.

63
00:02:58,580 --> 00:03:01,640
Pero, primeiro, imos dar un ollo neste
outro exemplo, no caso de lacetes.

64
00:03:01,640 --> 00:03:05,830
Tivemos este loop para sempre na última vez,
que foi unha serie de pezas do puzzle

65
00:03:05,830 --> 00:03:08,490
que fixo algo literalmente
sempre-- neste caso

66
00:03:08,490 --> 00:03:11,360
dicir Hola mundo, Ola mundo,
Ola mundo, Ola mundo.

67
00:03:11,360 --> 00:03:13,350
Polo tanto, é un loop infinito por deseño.

68
00:03:13,350 --> 00:03:17,580
>> C, se queremos aplicar este
mesma idea, poderiamos simplemente facelo.

69
00:03:17,580 --> 00:03:22,570
Mentres verdade, printf Ola mundo-- agora
mentres, só semanticamente, tipo de

70
00:03:22,570 --> 00:03:26,090
evoca a idea de facer
algo máis dunha vez, e de novo, e de novo,

71
00:03:26,090 --> 00:03:26,980
e por canto tempo?

72
00:03:26,980 --> 00:03:30,990
Ben, lembre que true--
realidade é só o un.

73
00:03:30,990 --> 00:03:33,660
>> Certo é, por suposto, sempre certa.

74
00:03:33,660 --> 00:03:36,060
Polo tanto, é unha especie de sentido
declaración só para dicir verdade.

75
00:03:36,060 --> 00:03:39,890
Pero, en realidade, este é deliberada,
porque de ser verdade é só sempre certo,

76
00:03:39,890 --> 00:03:43,850
que mentres verdade só indica,
Un pouco indirectamente

77
00:03:43,850 --> 00:03:47,070
que as liñas de código
entre esas claves

78
00:03:47,070 --> 00:03:51,320
debe só realizar de novo, e de novo,
e de novo, e nunca realmente parar.

79
00:03:51,320 --> 00:03:53,230
>> Pero se quere que o seu
loop para deixar, como nós

80
00:03:53,230 --> 00:03:57,500
fixo a última vez con algo parecido
iso, repita os seguintes 50 veces,

81
00:03:57,500 --> 00:04:00,700
no C, podemos facer o mesmo co que hai de
chama a palabra clave para o loop--

82
00:04:00,700 --> 00:04:02,330
non sendo á vez, pero para.

83
00:04:02,330 --> 00:04:06,290
E entón temos algunha nova sintaxe aquí,
con int i é igual a 0, i inferior a 50,

84
00:04:06,290 --> 00:04:06,880
i ++.

85
00:04:06,880 --> 00:04:08,430
E nós imos voltar a iso.

86
00:04:08,430 --> 00:04:12,660
Pero iso é simplemente como iríamos
traducir o conxunto de bloques de raspadinhas

87
00:04:12,660 --> 00:04:16,079
para un conxunto de liñas de código C

88
00:04:16,079 --> 00:04:17,450
>> Mentres tanto, considerada variables.

89
00:04:17,450 --> 00:04:19,540
E, de feito, nós só
vin un un momento atrás.

90
00:04:19,540 --> 00:04:24,220
E no caso de cero, se
quería declarar unha variable chamada i

91
00:04:24,220 --> 00:04:27,590
para i sendo enteiro, só un número,
e queremos configuralo para algún valor,

92
00:04:27,590 --> 00:04:31,410
usariamos este laranxa
bloquear aqui-- establecer i a 0.

93
00:04:31,410 --> 00:04:33,800
>> E veremos hoxe e
ademais, como a semana pasada,

94
00:04:33,800 --> 00:04:36,850
programadores fan case sempre
comezar a contar desde cero, realmente

95
00:04:36,850 --> 00:04:37,950
por convención.

96
00:04:37,950 --> 00:04:40,250
Pero tamén porque recollida xunto
nosa discusión de par,

97
00:04:40,250 --> 00:04:42,990
o menor número posible
representan con calquera número de bits

98
00:04:42,990 --> 00:04:44,640
é só será 0 si.

99
00:04:44,640 --> 00:04:48,190
E por iso imos xeralmente comezan
arrincar mesmo nosas variables a 0.

100
00:04:48,190 --> 00:04:50,710
>> E en C a facer o mesmo,
imos dicir int

101
00:04:50,710 --> 00:04:53,110
por enteiro, eu só por convención.

102
00:04:53,110 --> 00:04:56,390
Podería chamar esta variable
o que eu queira, así como en perigo.

103
00:04:56,390 --> 00:05:00,770
E entón é igual a 0 só cessionários
o valor 0 da dereita

104
00:05:00,770 --> 00:05:04,319
e poñelas na variable, ou a
recipiente de almacenamento fai, na parte esquerda.

105
00:05:04,319 --> 00:05:07,360
E o punto e coma como imos see-- e
vimos algúns deses já--

106
00:05:07,360 --> 00:05:09,530
só significa final de pensamento.

107
00:05:09,530 --> 00:05:12,430
Avance para facer outra cousa
nas liñas que seguen.

108
00:05:12,430 --> 00:05:14,330
>> Agora, o que pasa con expresións booleanas?

109
00:05:14,330 --> 00:05:17,320
Lembre que en risco,
Estes eran expresións

110
00:05:17,320 --> 00:05:19,740
que son certas
ou preguntas false--,

111
00:05:19,740 --> 00:05:21,910
Realmente, que son certas ou falsas.

112
00:05:21,910 --> 00:05:24,960
Así, no caso do Scratch, poderiamos
facer unha pregunta sinxela como este,

113
00:05:24,960 --> 00:05:27,586
é i menos de 50?

114
00:05:27,586 --> 00:05:28,710
Entón eu, unha vez máis, é un número enteiro.

115
00:05:28,710 --> 00:05:30,210
Quizais estamos a usalo
nun programa de arañazos

116
00:05:30,210 --> 00:05:32,310
manter o control de unha puntuación
ou algo así.

117
00:05:32,310 --> 00:05:36,810
Polo tanto, esta sintaxe aquí Risco
Significa só que, se i menos de 50?

118
00:05:36,810 --> 00:05:40,330
Ben, por sorte, algo está
simple en C. E para traducir,

119
00:05:40,330 --> 00:05:44,780
iso sería simplemente dicir i menos
de 50, utilizando a clave familiarizados

120
00:05:44,780 --> 00:05:45,850
no teclado.

121
00:05:45,850 --> 00:05:48,141
>> Mentres tanto, se quería
dicir algo máis xeral,

122
00:05:48,141 --> 00:05:52,890
como, ben, é x menos y onde cada
de X e Y son, eles mesmos variables?

123
00:05:52,890 --> 00:05:55,280
Podemos facer o mesmo
no C, desde que temos

124
00:05:55,280 --> 00:05:56,942
creou estas variables xa.

125
00:05:56,942 --> 00:05:58,650
E veremos como
facelo antes de tempo.

126
00:05:58,650 --> 00:06:01,590
Simplemente diría x inferior a y.

127
00:06:01,590 --> 00:06:03,530
>> Entón, está empezando a
ver algunhas semellanzas.

128
00:06:03,530 --> 00:06:06,490
E aquelas persoas que fixeron
Cero eran certamente

129
00:06:06,490 --> 00:06:08,250
inspirado por algunhas destas ideas básicas.

130
00:06:08,250 --> 00:06:13,350
E vai ver este tipo de
sintaxe en moitos languages--

131
00:06:13,350 --> 00:06:15,160
non só cero, non
só C, pero Python,

132
00:06:15,160 --> 00:06:17,790
e JavaScript, e
outras linguas aínda.

133
00:06:17,790 --> 00:06:21,270
>> Imos considerar outra construción
de C, a noción dunha condición,

134
00:06:21,270 --> 00:06:23,370
facendo algo condicional.

135
00:06:23,370 --> 00:06:25,720
Se algo é certo, facelo.

136
00:06:25,720 --> 00:06:27,457
Se algo é certo, facelo.

137
00:06:27,457 --> 00:06:30,040
É unha especie de programación
equivalente a unha bifurcación na estrada.

138
00:06:30,040 --> 00:06:32,730
Quizais sexa unha de dúas vías garfo,
un garfo de tres vías, ou máis.

139
00:06:32,730 --> 00:06:35,800
E en perigo, poderiamos
visto algo así.

140
00:06:35,800 --> 00:06:37,010
>> Entón que é un gran problema.

141
00:06:37,010 --> 00:06:39,750
Pero considere o parente
simplicidade da lóxica.

142
00:06:39,750 --> 00:06:47,010
Se x é menor que y, a continuación, dicir x é menor
que Y, o resto si x é maior que Y,

143
00:06:47,010 --> 00:06:49,230
logo dicir que x é maior que y.

144
00:06:49,230 --> 00:06:51,300
E, a continuación, loxicamente, se
pensas que volta a rabuñar

145
00:06:51,300 --> 00:06:55,610
ou só a súa propia intuición humana,
así, se x non é maior que Y, e X

146
00:06:55,610 --> 00:07:00,000
non é menos que Y, entón está claro
x será igual a y.

147
00:07:00,000 --> 00:07:02,690
Polo tanto, neste caso, por asentamento
os bloques de raspadinhas,

148
00:07:02,690 --> 00:07:05,580
podemos conseguir un tres
xeito bifurcación na estrada?

149
00:07:05,580 --> 00:07:07,980
>> Mentres tanto, se queremos
facelo en C, é indiscutibelmente

150
00:07:07,980 --> 00:07:11,420
parece un pouco simpler--, polo menos,
xa que familiarizarse coa sintaxe.

151
00:07:11,420 --> 00:07:15,050
Se X é menor que Y,
printf x é inferior a y.

152
00:07:15,050 --> 00:07:19,140
Senón, se x é maior que Y,
printf x é maior que y.

153
00:07:19,140 --> 00:07:24,210
Else printf x é igual a y-- e,
unha vez máis, con aqueles barra invertida remata pronto

154
00:07:24,210 --> 00:07:27,160
para estas novas liñas de modo que se
Realmente foi este tipo de programa

155
00:07:27,160 --> 00:07:28,940
sería só mover
o cursor ao final,

156
00:07:28,940 --> 00:07:31,100
á seguinte liña da pantalla.

157
00:07:31,100 --> 00:07:34,270
>> Agora, con todo risco tivo outra
recursos máis sofisticados, única

158
00:07:34,270 --> 00:07:37,320
algúns dos cales imos
inicialmente pasar ao mundo do C.

159
00:07:37,320 --> 00:07:40,010
E un deles foi
chamado dunha lista en perigo.

160
00:07:40,010 --> 00:07:42,100
E este foi un especial
tipo de variable que

161
00:07:42,100 --> 00:07:45,840
permítelle almacenar moitas cousas
na volta, atrás, cara atrás, cara atrás.

162
00:07:45,840 --> 00:07:48,540
>> C, que non teñen
listas, de per si, pero algo

163
00:07:48,540 --> 00:07:51,090
que son máis xeralmente
chamado de matrices, aínda imos

164
00:07:51,090 --> 00:07:53,590
voltar máis tarde este semestre
a ollar para algo

165
00:07:53,590 --> 00:07:55,780
chamado dunha lista, ou realmente unha lista ligada.

166
00:07:55,780 --> 00:07:58,510
Pero, por agora, o máis próximo
equivalente en C para nós

167
00:07:58,510 --> 00:08:00,345
Vai ser algo
chamado dunha matriz.

168
00:08:00,345 --> 00:08:02,740
E unha matriz é simplemente unha
tipo especial de variable

169
00:08:02,740 --> 00:08:06,160
que lle permite almacenar datos
atrás, cara atrás, cara atrás, cara atrás.

170
00:08:06,160 --> 00:08:08,840
>> E, de feito, en perigo,
se queriamos para acceder

171
00:08:08,840 --> 00:08:12,030
o primeiro elemento dunha matriz ou
un lista-- e eu vou chamalo,

172
00:08:12,030 --> 00:08:16,600
por convención, argv, o argumento
vector, pero máis sobre iso antes de tempo.

173
00:08:16,600 --> 00:08:20,090
Se eu queira comezar no primeiro elemento
de argv, no mundo do scratch

174
00:08:20,090 --> 00:08:23,930
realmente fai normalmente
comezar a contar a partir do 1.

175
00:08:23,930 --> 00:08:25,850
>> E así eu podería obter o elemento 1 da argv.

176
00:08:25,850 --> 00:08:29,310
Isto é só como MIT aplicado
a noción de listas.

177
00:08:29,310 --> 00:08:32,860
Pero en C, vou
máis simple só dicir, argv,

178
00:08:32,860 --> 00:08:35,758
que de novo é o nome do meu
lista-- ou para ser claro, unha matriz.

179
00:08:35,758 --> 00:08:37,549
E se eu queira o primeiro
elementos, eu vou

180
00:08:37,549 --> 00:08:40,890
usar corchetes, o que
Pode non frecuentemente usado en un teclado.

181
00:08:40,890 --> 00:08:43,150
>> Pero 0 significa só, me o primeiro.

182
00:08:43,150 --> 00:08:45,160
Entón, de vez en cando e como
o tempo pasa, imos

183
00:08:45,160 --> 00:08:47,570
para comezar a ver estas dicotomias
entre cero e C,

184
00:08:47,570 --> 00:08:49,070
en que cero usa un.

185
00:08:49,070 --> 00:08:50,670
Nós en C usan 0 aquí.

186
00:08:50,670 --> 00:08:52,420
Pero vai ver rapidamente
Despois de entender

187
00:08:52,420 --> 00:08:55,920
os fundamentos de cada lingua, que
esas cousas comezan a estar aínda máis

188
00:08:55,920 --> 00:08:59,860
familiarizado coa práctica e práctica.

189
00:08:59,860 --> 00:09:02,700
>> Entón imos realmente ollar agora para un programa.

190
00:09:02,700 --> 00:09:07,031
Aquí debería ser o primeiro da nosa C
código fonte de programas completos.

191
00:09:07,031 --> 00:09:09,280
E o programa que imos
para ofrecer a consideración

192
00:09:09,280 --> 00:09:12,340
é o que equivale
para que no inicio peza cero.

193
00:09:12,340 --> 00:09:16,210
>> Entón aquí, temos o que é
sen dúbida, o programa máis simple C

194
00:09:16,210 --> 00:09:18,410
pode escribir que
realmente fai algo.

195
00:09:18,410 --> 00:09:21,250
Agora, imos ollar o pasado
por agora, ha inclúen,

196
00:09:21,250 --> 00:09:24,190
io.h serie, e ambos ángulo
corchetes, e int e baleira,

197
00:09:24,190 --> 00:09:25,840
e as chaves, e así por diante.

198
00:09:25,840 --> 00:09:28,390
>> E imos só centrar
o que, polo menos, intuitivamente,

199
00:09:28,390 --> 00:09:29,860
Pode ir para fóra en ti xa.

200
00:09:29,860 --> 00:09:33,300
De feito, o principal, eu non sei
necesariamente saben o que é iso,

201
00:09:33,300 --> 00:09:37,580
pero moi parecido cero tiña que cando
bandeira verde premendo parte do enigma,

202
00:09:37,580 --> 00:09:42,070
o mesmo ocorre con C como linguaxe de programación
ten unha peza principal de código que

203
00:09:42,070 --> 00:09:46,380
corre por defecto. E, de feito,
é, literalmente, será chamado principal.

204
00:09:46,380 --> 00:09:47,720
>> Así principal é unha función.

205
00:09:47,720 --> 00:09:51,720
E é unha función especial que hai
en C que, cando executar un programa,

206
00:09:51,720 --> 00:09:55,720
é principal que corre por
estándar. No mundo do scratch,

207
00:09:55,720 --> 00:09:59,970
era xeralmente cando a bandeira verde
premendo que foi executado por defecto.

208
00:09:59,970 --> 00:10:04,130
>> Mentres tanto, vimos isto antes,
printf ou imprimir formato, que é

209
00:10:04,130 --> 00:10:08,620
vai ser unha función que vén con
C, xunto con unha morea de outros,

210
00:10:08,620 --> 00:10:13,140
que a vontade de tempo e tempo
de novo, a fin de facer exactamente

211
00:10:13,140 --> 00:10:15,450
como o propio nome suxire, imprimir algo.

212
00:10:15,450 --> 00:10:16,500
O que queremos imprimir?

213
00:10:16,500 --> 00:10:18,770
Ben, imos ver que
por personaxes que encerran

214
00:10:18,770 --> 00:10:21,680
como o mundo these-- Ola,
barra invertida n entre comiñas dobres,

215
00:10:21,680 --> 00:10:26,040
podemos dicir exactamente printf
o que imprimir na pantalla.

216
00:10:26,040 --> 00:10:29,430
>> Pero, a fin de facer
que, por desgraza

217
00:10:29,430 --> 00:10:33,010
que tomar algo que é
xa enigmática para nós seres humanos,

218
00:10:33,010 --> 00:10:37,510
pero polo menos é algo readable--
afiada inclúen, io.h estándar, int,

219
00:10:37,510 --> 00:10:42,340
principal, baleiro, printf, toda a maxia
encantamentos que acabamos de ver na pantalla.

220
00:10:42,340 --> 00:10:45,470
Pero nós realmente temos que
ir máis misterioso aínda.

221
00:10:45,470 --> 00:10:50,140
Primeiro necesitamos traducir o código
que escribir en código máquina.

222
00:10:50,140 --> 00:10:54,370
E lembro desde a semana pasada que as máquinas,
polo menos os que sabemos aquí,

223
00:10:54,370 --> 00:10:57,450
no fin do día única
comprender ceros e uns.

224
00:10:57,450 --> 00:11:01,100
>> E, meu Deus, se tivésemos que escribir estas
ceros e uns que realmente programa,

225
00:11:01,100 --> 00:11:04,260
que sería moi, moi rápido
levar a diversión fóra de calquera cousa.

226
00:11:04,260 --> 00:11:08,150
Pero resulta que, por semana pasada
que eses patróns de ceros e uns

227
00:11:08,150 --> 00:11:09,400
só ten significado especial.

228
00:11:09,400 --> 00:11:11,500
En certos contextos,
poden significar números.

229
00:11:11,500 --> 00:11:14,840
>> Nalgúns contextos, poden significar
letras ou cores, ou calquera número

230
00:11:14,840 --> 00:11:17,710
doutras abstraccións alí enriba.

231
00:11:17,710 --> 00:11:21,450
Pero, así como o seu ordenador ten
unha CPU, Central Processing Unit,

232
00:11:21,450 --> 00:11:23,390
ou o cerebro no seu ordenador.

233
00:11:23,390 --> 00:11:25,240
É xeralmente Intel
dentro, porque iso é

234
00:11:25,240 --> 00:11:27,900
unha das maiores empresas
que fai CPUs para ordenadores.

235
00:11:27,900 --> 00:11:31,910
>> Ben, CPUs Intel e outros
simplemente decidir anticipadamente

236
00:11:31,910 --> 00:11:36,970
que certos patróns de ceros e
queridos debe significar cousas específicas.

237
00:11:36,970 --> 00:11:40,040
Certos patróns de ceros e uns
significará, imprimir esta a pantalla,

238
00:11:40,040 --> 00:11:42,710
ou engadir eses dous números, ou
restar eses dous números,

239
00:11:42,710 --> 00:11:46,310
ou mover este anaco de datos de
memoria do meu ordenador aquí,

240
00:11:46,310 --> 00:11:50,870
ou calquera número de outras nivel moi baixo,
pero en definitiva útil, operacións.

241
00:11:50,870 --> 00:11:56,022
Pero, por sorte, nós, humanos, non van
ter saber ese nivel de detalle.

242
00:11:56,022 --> 00:11:59,230
De feito, así como a última vez, onde nós
abstraída de novo, e de novo, e de novo,

243
00:11:59,230 --> 00:12:01,930
construción de moi baixo nivel
primitivos como ceros e uns

244
00:12:01,930 --> 00:12:04,160
a conceptos de nivel máis alto
como números e letras,

245
00:12:04,160 --> 00:12:07,330
e cores, e máis,
Tamén podemos como programadores

246
00:12:07,330 --> 00:12:10,080
estar sobre os ombreiros de
outros que viñeron antes de nós

247
00:12:10,080 --> 00:12:14,260
e utilizar o software que outra
persoas teñen escrito antes US--

248
00:12:14,260 --> 00:12:17,340
é dicir, programas chamados compiladores.

249
00:12:17,340 --> 00:12:20,770
>> C é unha linguaxe que
xeralmente é compilado,

250
00:12:20,770 --> 00:12:25,130
o que significa converter a partir
código fonte para código de máquina.

251
00:12:25,130 --> 00:12:28,230
En particular, o que significa isto
é que, se ten a súa fonte

252
00:12:28,230 --> 00:12:32,530
código que mesmo escribe, como nós en breve
vai en só un momento na pantalla,

253
00:12:32,530 --> 00:12:36,140
e quere convertelo-lo
finalmente, a máquina code--

254
00:12:36,140 --> 00:12:40,100
estes ceros e uns que
só o seu Mac ou PC

255
00:12:40,100 --> 00:12:44,230
understands-- ten un primeiro
alimentar ese código fonte en como

256
00:12:44,230 --> 00:12:49,340
entrada para un especial
programa chamado compilador,

257
00:12:49,340 --> 00:12:51,974
a saída dos cales nós
que ver é o código de máquina.

258
00:12:51,974 --> 00:12:54,890
E, de feito, a última vez que nos falamos
sobre, realmente, ao final do día,

259
00:12:54,890 --> 00:12:55,610
resolución de problemas.

260
00:12:55,610 --> 00:12:56,360
Ten entradas.

261
00:12:56,360 --> 00:12:57,318
E ten saídas.

262
00:12:57,318 --> 00:12:59,560
E ten algún tipo
do algoritmo no medio.

263
00:12:59,560 --> 00:13:02,830
>> Algoritmos poden certamente ser
aplicadas en software,

264
00:13:02,830 --> 00:13:05,900
como vimos con pseudocódigo a semana pasada
e, como veremos con código real

265
00:13:05,900 --> 00:13:06,490
esta semana.

266
00:13:06,490 --> 00:13:09,430
E así un compilador realmente só
ten un conxunto de algoritmos dentro

267
00:13:09,430 --> 00:13:13,060
de que sabe como
converter as palabras clave especiais,

268
00:13:13,060 --> 00:13:15,180
como principal, e printf,
e outros que acabamos

269
00:13:15,180 --> 00:13:20,620
viu nos patróns de ceros e
quen Intel dentro e outras CPUs

270
00:13:20,620 --> 00:13:23,020
realmente entende.

271
00:13:23,020 --> 00:13:25,460
Entón, como imos facelo?

272
00:13:25,460 --> 00:13:27,470
Onde é que imos conseguir un compilador?

273
00:13:27,470 --> 00:13:29,400
>> A maioría de nós aquí ten un Mac ou PC.

274
00:13:29,400 --> 00:13:32,152
E está executando Mac VOS, ou
Windows ou Linux ou Solaris,

275
00:13:32,152 --> 00:13:33,860
ou calquera número de outras
sistemas operativos.

276
00:13:33,860 --> 00:13:35,568
E, de feito, poderiamos
saír na web

277
00:13:35,568 --> 00:13:38,710
e baixar un compilador
para o seu Mac ou PC

278
00:13:38,710 --> 00:13:40,360
para o seu sistema operativo en particular.

279
00:13:40,360 --> 00:13:42,617
Pero todos nós sería en
páxinas diferentes, por así dicir.

280
00:13:42,617 --> 00:13:44,450
Teriamos algo
diferentes opcións.

281
00:13:44,450 --> 00:13:46,210
E as cousas non funcionan do mesmo xeito.

282
00:13:46,210 --> 00:13:48,280
E, de feito, a día de hoxe
moitos de nós non usan

283
00:13:48,280 --> 00:13:50,516
programa que se executa só nos nosos portátiles.

284
00:13:50,516 --> 00:13:52,390
Pola contra, usan algo
como un navegador que

285
00:13:52,390 --> 00:13:55,930
permítenos acceder web-based
aplicacións na nube.

286
00:13:55,930 --> 00:13:58,630
E aínda este semestre,
imos facer exactamente isto.

287
00:13:58,630 --> 00:14:02,660
Imos escribir aplicacións ou
software usando code-- non C,

288
00:14:02,660 --> 00:14:05,860
pero outras linguaxes como Python e
JavaScript-- que son executados na nube.

289
00:14:05,860 --> 00:14:08,860
>> E para facelo, nós mesmos
durante o semestre

290
00:14:08,860 --> 00:14:14,890
vai realmente usar unha base de nube
ambiente coñecido como CS50 IDE.

291
00:14:14,890 --> 00:14:19,030
Esta é unha programación baseada en web
ambiente ou de desenvolvemento integrado

292
00:14:19,030 --> 00:14:23,610
ambiente, IDE, que está construído enriba dalgúns
software de código aberto chamado Cloud 9.

293
00:14:23,610 --> 00:14:25,966
E nós fixemos algún pedagóxica
simplificacións para el

294
00:14:25,966 --> 00:14:28,840
para ocultar certos recursos no
as primeiras semanas que non precisa,

295
00:14:28,840 --> 00:14:30,770
Despois de que pode
revelalo-los e facer máis

296
00:14:30,770 --> 00:14:32,400
o que quere co medio ambiente.

297
00:14:32,400 --> 00:14:35,470
>> E iso nos permite, tamén, a
pre-instalar determinado programa.

298
00:14:35,470 --> 00:14:38,330
Cousas como un chamado CS50
biblioteca, que veremos en breve

299
00:14:38,330 --> 00:14:42,210
ofrece-nos en C con algún
funcionalidade adicional.

300
00:14:42,210 --> 00:14:47,392
Entón, se vai para, en última instancia, CS50.io,
lle será solicitada a entrar,

301
00:14:47,392 --> 00:14:49,350
e unha vez que fai e crear
unha conta para libre,

302
00:14:49,350 --> 00:14:55,150
será capaz de acceder a un
ambiente que parece bastante como este.

303
00:14:55,150 --> 00:14:56,760
>> Agora, iso está en modo estándar.

304
00:14:56,760 --> 00:14:58,650
Todo é bo e
brillante na pantalla.

305
00:14:58,650 --> 00:15:00,941
Moitos de nós teñen o costume de
traballando peza CS50 que é

306
00:15:00,941 --> 00:15:02,150
moi tarde para a noite.

307
00:15:02,150 --> 00:15:05,400
E así algúns de vostedes poden preferir
transformalo en modo noite, por así dicir.

308
00:15:05,400 --> 00:15:08,550
>> Pero, en definitiva, o que está
veremos dentro CS50 IDE

309
00:15:08,550 --> 00:15:11,340
é de tres areas-- distinta
unha área na que a esquerda

310
00:15:11,340 --> 00:15:15,604
os seus arquivos serán en
nube, unha área na esquina superior dereita

311
00:15:15,604 --> 00:15:17,270
onde o código será editable.

312
00:15:17,270 --> 00:15:19,650
Vai ser capaz de abrir
guías individuais para calquera programa

313
00:15:19,650 --> 00:15:22,670
que escribir este semestre dentro
dese ángulo superior dereito.

314
00:15:22,670 --> 00:15:26,070
E entón máis arcanely,
e aínda así potente,

315
00:15:26,070 --> 00:15:29,610
será esa cousa na
bottom coñecido como unha fiestra de terminal.

316
00:15:29,610 --> 00:15:32,450
>> Esta é unha vella escola
Command Line Interface,

317
00:15:32,450 --> 00:15:35,240
ou o CLI, que permite
executar comandos

318
00:15:35,240 --> 00:15:38,260
na Computador-- neste caso
o ordenador no cloud--

319
00:15:38,260 --> 00:15:42,090
para facer cousas como compilar o código
dende o código fonte para código de máquina,

320
00:15:42,090 --> 00:15:46,600
para realizar os seus programas, ou para comezar a súa
servidor web, ou para acceder a base de datos,

321
00:15:46,600 --> 00:15:50,454
e calquera número de outras técnicas
que vai comezar a usar antes de tempo.

322
00:15:50,454 --> 00:15:52,370
Pero para chegar alí, estamos
vai realmente ter

323
00:15:52,370 --> 00:15:54,240
ir en liña e comezar a xogar.

324
00:15:54,240 --> 00:15:57,399
E para facelo, imos primeiro
comezar a xogar coa principal,

325
00:15:57,399 --> 00:15:58,940
e escribir a parte principal dun programa.

326
00:15:58,940 --> 00:16:02,170
E imos usar esta función
printf, que temos utilizado anteriormente,

327
00:16:02,170 --> 00:16:04,050
simplemente para dicir algo.

328
00:16:04,050 --> 00:16:07,910
>> Entón aquí eu xa estou dentro IDE CS50.

329
00:16:07,910 --> 00:16:08,930
Teño rexistrado con antelación.

330
00:16:08,930 --> 00:16:10,360
E eu completo aparece na ventá.

331
00:16:10,360 --> 00:16:12,670
E así, en definitiva, ten
tamén en problemas próximos

332
00:16:12,670 --> 00:16:15,960
vai seguir os pasos similares que
pode fornecer a documentación en liña.

333
00:16:15,960 --> 00:16:19,360
Entón non se preocupe
absorbendo cada etapa técnica pouco

334
00:16:19,360 --> 00:16:20,730
o que fago aquí hoxe.

335
00:16:20,730 --> 00:16:22,222
>> Pero vai ter unha pantalla como esta.

336
00:16:22,222 --> 00:16:23,430
Acontece que eu estar en modo de noite.

337
00:16:23,430 --> 00:16:25,944
E pode iluminar todo
-Se desactivando o modo noite.

338
00:16:25,944 --> 00:16:27,860
E ao final da
día, vai ver

339
00:16:27,860 --> 00:16:33,090
estes tres principal areas-- o ficheiro
navegador á esquerda, as guías de código enriba,

340
00:16:33,090 --> 00:16:35,430
ea fiestra da terminal, na parte inferior.

341
00:16:35,430 --> 00:16:37,890
>> Deixe-me ir adiante e
escribir o meu primeiro programa.

342
00:16:37,890 --> 00:16:45,300
Eu estou indo a ir cautelarmente para arquivo,
Gardar e gardar o meu ficheiro como hello.c.

343
00:16:45,300 --> 00:16:49,850
En realidade, por convención, calquera que programa
gravación que está escrito na linguaxe C

344
00:16:49,850 --> 00:16:52,739
debe ser nomeado algo
dot c, por convención.

345
00:16:52,739 --> 00:16:56,030
Entón eu vou nomealo hello.c porque
Eu só quero dicir Hola para o mundo.

346
00:16:56,030 --> 00:16:57,820
Agora vou para aumentar
fóra e prema Gardar.

347
00:16:57,820 --> 00:17:01,180
E todo o que teño aquí agora é unha guía
en que eu poida comezar a escribir código.

348
00:17:01,180 --> 00:17:02,490
>> Iso non vai compilar.

349
00:17:02,490 --> 00:17:03,300
Iso non significa nada.

350
00:17:03,300 --> 00:17:05,750
E por iso mesmo que eu convertinme
isto para ceros e uns,

351
00:17:05,750 --> 00:17:08,390
a CPU terá ningunha
idea do que está a ocorrer ao redor.

352
00:17:08,390 --> 00:17:17,170
Pero se eu escribir as liñas que coinciden
-se co ser C conventions-- de C,

353
00:17:17,170 --> 00:17:23,150
de novo, esta language-- con sintaxe como
iso, printf Ola mundo-- e non teño

354
00:17:23,150 --> 00:17:25,210
sentiron cómodos con
facendo iso ao longo do tempo.

355
00:17:25,210 --> 00:17:27,510
Entón eu non creo que fixen
posibles erros tipográficos.

356
00:17:27,510 --> 00:17:30,910
>> Pero, invariablemente, o primeiro
xa que fas, vai.

357
00:17:30,910 --> 00:17:34,090
E o que eu estou a piques de facer moito pode
así non funciona para ti por primeira vez.

358
00:17:34,090 --> 00:17:36,610
E iso é perfectamente normal,
porque agora

359
00:17:36,610 --> 00:17:40,662
pode só ver unha chea de novidade,
pero co paso do tempo xa que familiarizarse

360
00:17:40,662 --> 00:17:42,870
con este ambiente, e
esta linguaxe, e outros,

361
00:17:42,870 --> 00:17:45,370
vai comezar a ver as cousas que
ou son correctas ou incorrectas.

362
00:17:45,370 --> 00:17:47,369
>> E iso é o que o
compañeiros de ensino e curso

363
00:17:47,369 --> 00:17:51,780
asistentes estar tan bo en ao longo do tempo, é
detectar erros ou erros no seu código.

364
00:17:51,780 --> 00:17:55,110
Pero aseguran que hai
hai erro neste código.

365
00:17:55,110 --> 00:17:56,990
Entón agora eu quero facer este programa.

366
00:17:56,990 --> 00:18:00,440
>> Agora no meu propio Mac ou PC, estou en
o costume de iconas dobre clic

367
00:18:00,440 --> 00:18:02,350
cando quero realizar algún programa.

368
00:18:02,350 --> 00:18:04,080
Pero iso non é o modelo aquí.

369
00:18:04,080 --> 00:18:07,570
Neste ambiente, o que é CS50 IDE.

370
00:18:07,570 --> 00:18:10,192
Estamos a usar unha operación
sistema chamado Linux.

371
00:18:10,192 --> 00:18:12,900
Linux é unha reminiscencia de outra
sistema operativo, xeralmente coñecido

372
00:18:12,900 --> 00:18:13,850
como Unix.

373
00:18:13,850 --> 00:18:19,340
E Linux é particularmente coñecido por
ter unha liña de comandos Ambiente, CLI.

374
00:18:19,340 --> 00:18:23,070
Agora, estamos a usar unha específica
sabor de Linux chamada Ubuntu.

375
00:18:23,070 --> 00:18:25,770
E Ubuntu é simplemente unha
determinada versión de Linux.

376
00:18:25,770 --> 00:18:30,900
>> Pero estes Linux nos días de hoxe fan, en realidade,
veñen con interfaces gráficas de usuario.

377
00:18:30,900 --> 00:18:33,360
E o que acontecerá co
estar a usar aquí está baseado na web.

378
00:18:33,360 --> 00:18:35,735
Polo tanto, este pode parecer ata un
pouco distinto de algo

379
00:18:35,735 --> 00:18:38,310
vostede mesmo pode ter
visto ou executado no pasado.

380
00:18:38,310 --> 00:18:40,910
>> Entón, eu estou indo a ir adiante
agora e faga o seguinte.

381
00:18:40,910 --> 00:18:43,950
Gardei este ficheiro como hello.c.

382
00:18:43,950 --> 00:18:50,350
Eu estou indo a ir adiante e
Tipo clanghello.c Entón Clang

383
00:18:50,350 --> 00:18:52,850
á linguaxe C é un compilador.

384
00:18:52,850 --> 00:18:54,952
É preinstalado no CS50 IDE.

385
00:18:54,952 --> 00:18:57,910
E pode absolutamente descargar e
instalar no seu propio Mac ou PC.

386
00:18:57,910 --> 00:19:00,910
>> Pero, unha vez máis, non ten todas
a preconfiguración feito para ti.

387
00:19:00,910 --> 00:19:03,940
Entón, por agora, eu son só
correrá clanghello.c.

388
00:19:03,940 --> 00:19:06,240
E agora entender esta sintaxe
aquí acabará

389
00:19:06,240 --> 00:19:09,930
realizar só significa que eu estou nun
carpeta ou directorio chamado Workspace.

390
00:19:09,930 --> 00:19:14,030
Este sinal de dólar é só unha convención
de sentido, escriba os comandos aquí.

391
00:19:14,030 --> 00:19:17,560
>> É o que se chama un prompt, pode
por convención é sinal de dólar.

392
00:19:17,560 --> 00:19:22,130
E se eu ir adiante agora e prema
Intro, nada parece acontecer.

393
00:19:22,130 --> 00:19:23,930
Pero iso é realmente bo.

394
00:19:23,930 --> 00:19:26,650
A menos que pasa sobre
pantalla, o máis probable

395
00:19:26,650 --> 00:19:29,710
seu código é ser correcto,
polo menos sintacticamente.

396
00:19:29,710 --> 00:19:32,120
>> Entón, se eu queira executar este
programa, o que fago?

397
00:19:32,120 --> 00:19:36,770
Ben, parece que o
nome por defecto por convención

398
00:19:36,770 --> 00:19:41,854
para os programas cando non especificar un
nomear ao seu programa só a.out.

399
00:19:41,854 --> 00:19:44,270
E esta sintaxe tamén, vai
familiarizarse con antes de tempo.

400
00:19:44,270 --> 00:19:50,500
>> Dot cortar só significa que, hey, CS50
IDE, executar un programa chamado a.out

401
00:19:50,500 --> 00:19:52,400
que está dentro do meu directorio actual.

402
00:19:52,400 --> 00:19:54,520
Isto punto significa o directorio actual.

403
00:19:54,520 --> 00:19:58,040
E imos ver o que outras secuencias
de caracteres significa antes de tempo.

404
00:19:58,040 --> 00:20:01,430
>> Entón, imos alí, Intro, Ola mundo.

405
00:20:01,430 --> 00:20:03,080
E vai notar, que o que pasou?

406
00:20:03,080 --> 00:20:04,580
Non só imprimir Ola mundo.

407
00:20:04,580 --> 00:20:08,990
Tamén movido a
cursor á seguinte liña.

408
00:20:08,990 --> 00:20:10,160
>> E por que isto?

409
00:20:10,160 --> 00:20:15,400
Cal era o código que escribiu antes
que asegurar-se que o cursor sería

410
00:20:15,400 --> 00:20:17,882
ir á seguinte liña?

411
00:20:17,882 --> 00:20:19,840
Cousa divertido sobre un
ordenador é que só vai

412
00:20:19,840 --> 00:20:21,570
para facer literalmente o que diga a el para facer.

413
00:20:21,570 --> 00:20:29,050
>> Entón, se diga a el para printf Ola,
coma, espacio, mundo, preto citas,

414
00:20:29,050 --> 00:20:32,090
é, literalmente, só vai
para imprimir estes caracteres.

415
00:20:32,090 --> 00:20:34,980
Pero eu tiña ese carácter especial
ao final, recall, barra invertida n.

416
00:20:34,980 --> 00:20:37,230
E iso é o que garantiu
que o personaxe pasou

417
00:20:37,230 --> 00:20:39,570
á seguinte liña da pantalla.

418
00:20:39,570 --> 00:20:41,097
>> En realidade, deixe-me ir e facelo.

419
00:20:41,097 --> 00:20:42,430
Deixe-me ir adiante e eliminar este.

420
00:20:42,430 --> 00:20:44,180
Agora, teña en conta que o
parte superior da miña pantalla hai

421
00:20:44,180 --> 00:20:45,890
un pouco de luz vermella na
a guía indica,

422
00:20:45,890 --> 00:20:48,047
hey, non salvou o seu arquivo.

423
00:20:48,047 --> 00:20:50,880
Entón, eu estou indo a ir adiante co control
S ou o comando S, salva o arquivo.

424
00:20:50,880 --> 00:20:54,130
Agora goes-- fun a un verde moment--.

425
00:20:54,130 --> 00:20:56,760
E agora está de volta para
só a ser un icono de preto.

426
00:20:56,760 --> 00:21:04,860
>> Se eu agora realizar clanghello.c de novo,
Intro, barra punto, a.out, enter,

427
00:21:04,860 --> 00:21:07,110
vai ver que aínda traballaba.

428
00:21:07,110 --> 00:21:09,020
Pero é, sen dúbida, un pouco buggy.

429
00:21:09,020 --> 00:21:11,714
Neste momento, o meu traballo prompt--,
e despois de que o sinal de dólar,

430
00:21:11,714 --> 00:21:13,880
e despois o meu prompt-- real
é todo na mesma liña.

431
00:21:13,880 --> 00:21:17,540
Entón, iso certamente un erro estética,
aínda que iso non é realmente un erro lóxico.

432
00:21:17,540 --> 00:21:19,250
>> Entón eu vou para desfacer o que eu fixen.

433
00:21:19,250 --> 00:21:21,560
Eu estou indo a executar de novo a.out.

434
00:21:21,560 --> 00:21:25,710
Repare que eu engadir o
newline personaxe de volta.

435
00:21:25,710 --> 00:21:27,280
Eu salvo o ficheiro.

436
00:21:27,280 --> 00:21:34,630
>> Entón, eu estou indo a executar de novo a.out, e-
caramba, un erro, un erro que supón erro.

437
00:21:34,630 --> 00:21:38,020
Así, o erro é que, aínda que
Eu engade a barra invertida n alí,

438
00:21:38,020 --> 00:21:44,180
re-gardados, re-correu o programa,
o comportamento era a mesma.

439
00:21:44,180 --> 00:21:45,640
Por que iso sería?

440
00:21:45,640 --> 00:21:46,910
>> Estou falta un paso, non?

441
00:21:46,910 --> 00:21:50,620
Ese paso clave no inicio foi que ten
a-- cando cambiar o seu código fonte,

442
00:21:50,620 --> 00:21:52,610
verifícase tamén realizar
Lo través do compilador

443
00:21:52,610 --> 00:21:54,102
novo para obter un novo código de máquina.

444
00:21:54,102 --> 00:21:55,810
E o código de máquina,
os ceros e uns,

445
00:21:55,810 --> 00:21:59,260
van ser case idéntico, pero
non perfectamente así, porque necesitamos,

446
00:21:59,260 --> 00:22:00,510
por suposto, que a nova liña.

447
00:22:00,510 --> 00:22:05,640
>> Entón, para corrixir iso, eu vou ter
executar novamente clanghello.c, entrar, dot

448
00:22:05,640 --> 00:22:06,800
slash, a.out.

449
00:22:06,800 --> 00:22:11,402
E agora, Ola mundo está de volta
onde eu esperaba que fose.

450
00:22:11,402 --> 00:22:12,610
Entón, iso é todo moi ben e bo.

451
00:22:12,610 --> 00:22:16,150
Pero a.out é un nome moi estúpido para un
programa, aínda que pasa a ser,

452
00:22:16,150 --> 00:22:19,530
por razóns históricas, o
default-- significando saídas de montaxe.

453
00:22:19,530 --> 00:22:23,780
>> Pero deixe-me ir adiante aquí
e facelo de forma distinta.

454
00:22:23,780 --> 00:22:27,760
Eu quero o meu programa Ola Mundo
para realmente ser chamado Ola.

455
00:22:27,760 --> 00:22:31,320
Entón, se fose unha icona no meu
escritorio, non sería a.out.

456
00:22:31,320 --> 00:22:32,730
Sería chamado Ola.

457
00:22:32,730 --> 00:22:36,660
>> Entón, para facelo, verifica-se
que Clang, como moitos programas,

458
00:22:36,660 --> 00:22:40,980
soporta os argumentos da liña de comandos,
ou bandeiras, ou interruptores,

459
00:22:40,980 --> 00:22:42,600
que simplemente influír no seu comportamento.

460
00:22:42,600 --> 00:22:48,160
En concreto, Clang soporta un trazo o
bandeira, que, a continuación, toma unha segunda palabra.

461
00:22:48,160 --> 00:22:51,190
Neste caso, eu vou arbitrariamente,
pero razoablemente, chamalo Ola.

462
00:22:51,190 --> 00:22:53,710
Pero eu podería chamalo algo
Quero, excepto a.out, que

463
00:22:53,710 --> 00:22:55,390
Sería moito máis alá do punto.

464
00:22:55,390 --> 00:22:58,640
>> E despois é só especificar o nome
do ficheiro que quero para compilar.

465
00:22:58,640 --> 00:23:02,190
Entón, agora mesmo que no inicio
da orde aínda teño Clang,

466
00:23:02,190 --> 00:23:04,410
ao final do comando
Eu aínda teño o nome do ficheiro,

467
00:23:04,410 --> 00:23:08,520
Agora teño eses liña de comandos
argumentos, estes sinalizados que están dicindo,

468
00:23:08,520 --> 00:23:14,180
Oh, por certo, output-o, un arquivo
chamado Ola, non o a.out estándar.

469
00:23:14,180 --> 00:23:16,810
>> Entón, se eu acertar Entre agora, nada
parece acontecer.

470
00:23:16,810 --> 00:23:20,900
E, ademais, agora podo facer barra dot Ola.

471
00:23:20,900 --> 00:23:22,089
Polo tanto, é o mesmo programa.

472
00:23:22,089 --> 00:23:24,380
Os ceros e uns son
idénticas ao final do día.

473
00:23:24,380 --> 00:23:27,210
>> Pero eles están en dous
diferente a.out files--,

474
00:23:27,210 --> 00:23:29,490
que é a primeira versión
e só tolamente nomeado,

475
00:23:29,490 --> 00:23:33,250
e agora Ola, que é un tanto
nome máis atractivo para un programa.

476
00:23:33,250 --> 00:23:36,195
Pero, honestamente, eu nunca estou
vai lembrar de novo,

477
00:23:36,195 --> 00:23:37,070
e de novo, e de novo.

478
00:23:37,070 --> 00:23:39,411
E, de feito, como se escribe
programas máis complicados,

479
00:23:39,411 --> 00:23:41,160
as ordes que está
Vai ter que escribir

480
00:23:41,160 --> 00:23:43,920
van estar aínda
aínda máis complicado.

481
00:23:43,920 --> 00:23:44,940
>> E así non se preocupe.

482
00:23:44,940 --> 00:23:49,220
Acontece que os seres humanos antes
nós xa viron que eles tamén

483
00:23:49,220 --> 00:23:50,530
tiven ese mesmo problema exacto.

484
00:23:50,530 --> 00:23:53,900
Eles non me gustaba de ter que
escribir ordes moi longos, misterioso,

485
00:23:53,900 --> 00:23:55,200
moito menos lembrar deles.

486
00:23:55,200 --> 00:23:59,070
E así os humanos antes de nós fixeron
outros programas que fan máis doado

487
00:23:59,070 --> 00:24:00,670
para compilar o seu programa.

488
00:24:00,670 --> 00:24:04,609
>> E, de feito, unha tal
programa chámase Marca.

489
00:24:04,609 --> 00:24:06,150
Entón, eu estou indo a ir adiante e facelo.

490
00:24:06,150 --> 00:24:08,691
Eu estou indo a desfacer todo o que eu
acaba de facer do seguinte xeito.

491
00:24:08,691 --> 00:24:10,690
Déixeme escribir LS.

492
00:24:10,690 --> 00:24:13,980
E verás tres coisas-
a.out, e unha estrela, Ola

493
00:24:13,980 --> 00:24:15,810
e unha estrela, e hello.c.

494
00:24:15,810 --> 00:24:17,730
Esperemos que este debe
ser un pouco intuitivo,

495
00:24:17,730 --> 00:24:21,220
na medida en que non había anteriormente
nada neste espazo de traballo.

496
00:24:21,220 --> 00:24:24,240
Non había nada que eu tiña
creado ata que comezamos a clase.

497
00:24:24,240 --> 00:24:25,840
>> E eu creei hello.c.

498
00:24:25,840 --> 00:24:27,544
Eu, entón, compilou, e chamou-a.out.

499
00:24:27,544 --> 00:24:30,460
E entón eu compilado de novo lixeiramente
diferente e chamou-lle Ola.

500
00:24:30,460 --> 00:24:35,830
Entón, eu teño tres arquivos nese directorio,
nesta carpeta chamada Workspace.

501
00:24:35,830 --> 00:24:38,005
Agora, podo ver que ben
se eu reducir en realidade.

502
00:24:38,005 --> 00:24:40,530
>> Se eu aumentar aquí e
mirar para este lado superior dereito

503
00:24:40,530 --> 00:24:42,940
canto, como prometera á esquerda
lado da pantalla

504
00:24:42,940 --> 00:24:45,990
sempre vai amosar-lle
o que está na súa conta, o que é

505
00:24:45,990 --> 00:24:47,790
dentro IDE CS50.

506
00:24:47,790 --> 00:24:49,680
E hai tres arquivos alí.

507
00:24:49,680 --> 00:24:52,070
>> Entón, quero me librar de a.out e Ola.

508
00:24:52,070 --> 00:24:54,275
E como pode
Imaxina intuitivamente, vostede

509
00:24:54,275 --> 00:24:56,400
podería tipo de control prema
ou prema co botón dereito sobre esta.

510
00:24:56,400 --> 00:24:57,590
E este pequeno menú aparece.

511
00:24:57,590 --> 00:25:00,170
Pode descargar o ficheiro, faga
Lo, velo, actualizar, eliminar,

512
00:25:00,170 --> 00:25:00,700
ou que non.

513
00:25:00,700 --> 00:25:03,260
>> E eu podería simplemente eliminar,
e ía.

514
00:25:03,260 --> 00:25:08,260
Pero imos facer as cousas cun mando
liña de momento, para estar cómodo

515
00:25:08,260 --> 00:25:10,010
con iso, e facer o seguinte.

516
00:25:10,010 --> 00:25:15,345
Eu estou indo a ir adiante e eliminar
a.out escribindo literalmente rma.out.

517
00:25:15,345 --> 00:25:17,890
Acontece que, a orde para
eliminar ou borrar algo,

518
00:25:17,890 --> 00:25:19,280
non é eliminar ou borrar.

519
00:25:19,280 --> 00:25:24,260
>> É máis brevemente RM, só para aforrar
-lle algunhas teclas, e prema Intro.

520
00:25:24,260 --> 00:25:27,707
Agora imos ser un pouco
enigmaticamente eliminar a.out ficheiro regular.

521
00:25:27,707 --> 00:25:30,040
Eu realmente non sei o que é un
arquivo irregular sería aínda.

522
00:25:30,040 --> 00:25:31,660
Pero quero eliminar-lo.

523
00:25:31,660 --> 00:25:33,150
>> Entón eu vou para escribir y para si.

524
00:25:33,150 --> 00:25:34,940
Ou eu podería escribir-lo para fóra, e prema Intro.

525
00:25:34,940 --> 00:25:36,440
E, de novo, nada parece ocorrer.

526
00:25:36,440 --> 00:25:38,840
Pero iso é, en xeral, bo.

527
00:25:38,840 --> 00:25:43,490
>> Se eu escribir LS esta vez,
o que debo ver?

528
00:25:43,490 --> 00:25:47,930
Afortunadamente, só Ola e hello.c.

529
00:25:47,930 --> 00:25:50,286
Agora, como un aparte, vai
notar esta estrela, asterisco,

530
00:25:50,286 --> 00:25:51,660
iso é o final dos meus programas.

531
00:25:51,660 --> 00:25:53,201
E tamén están aparecendo en verde.

532
00:25:53,201 --> 00:25:56,970
Isto é só a forma da CS50 IDE
de cluing-lo para o feito

533
00:25:56,970 --> 00:25:58,280
que iso non é o código fonte.

534
00:25:58,280 --> 00:26:01,880
Isto é un executable, un executable
programa que realmente pode facer

535
00:26:01,880 --> 00:26:04,020
facendo barra punto, e entón é nome.

536
00:26:04,020 --> 00:26:08,860
>> Agora, deixe-me ir adiante e eliminar
iso, rm Ola, Intro, eliminar regulares

537
00:26:08,860 --> 00:26:11,010
arquivo Ola, si.

538
00:26:11,010 --> 00:26:14,180
E agora si escribir LS,
estamos de volta a hello.c.

539
00:26:14,180 --> 00:26:16,917
Probe a non eliminar o seu
código fonte real.

540
00:26:16,917 --> 00:26:19,250
Aínda que haxa recursos
incorporado IDE CS50 onde

541
00:26:19,250 --> 00:26:22,870
pode pasar polo seu historial de revisión
e retroceder no tempo, se accidentalmente

542
00:26:22,870 --> 00:26:26,660
borrar algo, faga estar atento
por eses avisos si ou non,

543
00:26:26,660 --> 00:26:28,381
do que realmente quere facer.

544
00:26:28,381 --> 00:26:30,380
E se eu for ata o cumio
deixou canto aquí,

545
00:26:30,380 --> 00:26:33,696
todo o que queda é hello.c.

546
00:26:33,696 --> 00:26:35,570
Polo tanto, non hai acios de
outros comandos que

547
00:26:35,570 --> 00:26:40,550
Pode realizar no mundo Linux,
un dos cales é, de novo, Make.

548
00:26:40,550 --> 00:26:43,180
E nós estamos indo facer
meu programa agora como segue.

549
00:26:43,180 --> 00:26:46,270
>> No canto de facer clang,
en vez de facer clang-o,

550
00:26:46,270 --> 00:26:48,860
vou simplemente
literalmente, tipo, marca Ola.

551
00:26:48,860 --> 00:26:52,630
E agora conta, estou
non escribindo make hello.c.

552
00:26:52,630 --> 00:26:53,910
Estou escribindo make Ola.

553
00:26:53,910 --> 00:26:57,840
>> E este programa Fai ese
ven con IDE CS50, e máis

554
00:26:57,840 --> 00:27:00,090
xeralmente con Linux,
é un programa que é

555
00:27:00,090 --> 00:27:02,120
Vai facer un programa chamado Ola.

556
00:27:02,120 --> 00:27:06,680
E vai asumir, por convención,
que se este programa se pode facer,

557
00:27:06,680 --> 00:27:12,030
que será feita a partir dunha fonte
arquivo de código que terminan en c punto, hello.c.

558
00:27:12,030 --> 00:27:15,210
>> Entón, se eu prema Intro Agora, teña en conta que
a orde que se executa

559
00:27:15,210 --> 00:27:17,340
é, en realidade aínda máis
antes do que antes.

560
00:27:17,340 --> 00:27:19,670
E iso é porque temos
IDE CS50 preconfigurado para ter

561
00:27:19,670 --> 00:27:22,878
algunhas características adicionais construídos en que
Nós só non teñen, pero en breve.

562
00:27:22,878 --> 00:27:26,470
Pero a principal cousa a entender
agora eu teño un programa Ola.

563
00:27:26,470 --> 00:27:30,080
>> Se eu escribir LS novo, eu
ter un programa Ola.

564
00:27:30,080 --> 00:27:35,070
E podo executa-lo con
dot cortar a.out, non,

565
00:27:35,070 --> 00:27:38,590
porque todo o punto deste
exercicio foi dot Ola barra.

566
00:27:38,590 --> 00:27:41,089
E agora eu teño o meu programa Ola mundo.

567
00:27:41,089 --> 00:27:42,880
Entón, movendo-se para adiante,
estamos case sempre só

568
00:27:42,880 --> 00:27:45,088
indo para compilar os nosos programas
mediante o comando make.

569
00:27:45,088 --> 00:27:48,300
E entón nós estamos indo a executa-los por
dot slash, eo nome do programa.

570
00:27:48,300 --> 00:27:52,610
Pero entenden o que fan está facendo por
vostede, non é por si non é un compilador.

571
00:27:52,610 --> 00:27:56,310
É só un programa de barrio
que sabe como provocar un compilador

572
00:27:56,310 --> 00:27:59,470
para realizar para que mesmo pode usalo.

573
00:27:59,470 --> 00:28:03,220
>> Que hai outros comandos no
Linux, e á súa vez o CS50 IDE?

574
00:28:03,220 --> 00:28:06,107
Nós verá logo que hai unha
mando CD, Change Directory.

575
00:28:06,107 --> 00:28:08,190
Isto permite que dentro
súa interface de liña de comandos

576
00:28:08,190 --> 00:28:10,610
para seguir adiante, e cara atrás,
e abrir carpetas diferentes

577
00:28:10,610 --> 00:28:11,860
sen usar o rato.

578
00:28:11,860 --> 00:28:15,470
>> LS que vimos, que significa lista
os arquivos no directorio actual.

579
00:28:15,470 --> 00:28:17,650
Fai Dir, pode
probablemente comezar a inferir

580
00:28:17,650 --> 00:28:21,150
o que elas significan agora-- facer directorio,
se quere crear un cartafol.

581
00:28:21,150 --> 00:28:24,270
RM para eliminar, RM Dir para
eliminar directory-- e estes,

582
00:28:24,270 --> 00:28:27,160
unha vez máis, son a liña de comandos
equivalentes de o que

583
00:28:27,160 --> 00:28:29,945
podería facer en CS50 IDE co rato.

584
00:28:29,945 --> 00:28:31,820
Pero vai atopar en breve
que ás veces é só

585
00:28:31,820 --> 00:28:33,610
moito máis rápido que facer
cousas con un teclado,

586
00:28:33,610 --> 00:28:36,690
e, finalmente, unha máis poderosa.

587
00:28:36,690 --> 00:28:39,440
>> Pero é difícil argumentar que
calquera cousa que fixen ata agora

588
00:28:39,440 --> 00:28:42,990
é todo o que poderoso, cando todo
vimos a dicir é, Ola mundo.

589
00:28:42,990 --> 00:28:46,740
E, de feito, eu codificado a
palabras Ola Mundo no meu programa.

590
00:28:46,740 --> 00:28:48,530
Non hai dinamismo aínda.

591
00:28:48,530 --> 00:28:52,320
Scratch foi unha orde de magnitude
máis interesante a semana pasada.

592
00:28:52,320 --> 00:28:54,220
>> E así imos chegar alí.

593
00:28:54,220 --> 00:28:58,310
Imos dar un paso para que,
forma de algunhas destas funcións.

594
00:28:58,310 --> 00:29:02,470
Así, non só C veñen con printf,
e acios de outras funcións

595
00:29:02,470 --> 00:29:04,850
algúns dos cales veremos
co paso do tempo, iso non acontece

596
00:29:04,850 --> 00:29:08,760
facelo tan fácil para a dereita fora
da porta no sentido de obter a entrada do usuario.

597
00:29:08,760 --> 00:29:11,140
>> De feito, un dos puntos débiles
de linguaxes como C,

598
00:29:11,140 --> 00:29:13,140
e mesmo Java e aínda
os outros, é que non fai

599
00:29:13,140 --> 00:29:18,860
facelo doado de obter só cousas como
enteiros de usuarios, ou cordas, palabras,

600
00:29:18,860 --> 00:29:22,970
e frases, deixar as cousas só como
valores de punto ou números reais flotante

601
00:29:22,970 --> 00:29:26,240
con puntos decimais, e realmente
números longos, como veremos en breve.

602
00:29:26,240 --> 00:29:30,000
Polo tanto, esta lista de funcións aquí, estes
son como outras pezas do risco de puzzle

603
00:29:30,000 --> 00:29:34,090
que teñen pre-instalado no CS50
IDE que usaremos durante algunhas semanas

604
00:29:34,090 --> 00:29:37,010
como rodinhas de tipos e
finalmente, leva-los fora, e buscar

605
00:29:37,010 --> 00:29:40,210
por baixo da capa, quizais, en
como estas cousas son aplicadas.

606
00:29:40,210 --> 00:29:43,460
>> Pero para iso, imos
realmente escribir un programa.

607
00:29:43,460 --> 00:29:44,770
Déixeme ir adiante agora.

608
00:29:44,770 --> 00:29:47,750
E eu estou indo a crear un novo
arquivo premendo nesta pouco máis,

609
00:29:47,750 --> 00:29:48,970
e facendo clic en Novo ficheiro.

610
00:29:48,970 --> 00:29:52,250
>> Eu estou indo a gardar esta próxima
un, como, por exemplo, string.c,

611
00:29:52,250 --> 00:29:53,750
porque quero xogar con cordas.

612
00:29:53,750 --> 00:29:56,990
E cadea C é só
unha secuencia de caracteres.

613
00:29:56,990 --> 00:29:59,090
Entón agora imos adiante
e faga o seguinte.

614
00:29:59,090 --> 00:30:04,204
>> Incluír estándar IO.h-- e
verifícase se patrón de IO,

615
00:30:04,204 --> 00:30:06,360
IO significa só entrada e saída.

616
00:30:06,360 --> 00:30:08,920
Así, verifícase que
esta liña aquí é o que

617
00:30:08,920 --> 00:30:11,140
son os EUA veciña de usar printf.

618
00:30:11,140 --> 00:30:13,410
Printf, por suposto, produce unha saída.

619
00:30:13,410 --> 00:30:18,000
Polo tanto, a fin de utilizar printf, verifica-se
fóra ten que ter esta liña de código

620
00:30:18,000 --> 00:30:19,040
na parte superior do seu arquivo.

621
00:30:19,040 --> 00:30:21,456
>> E imos volver ao que
que realmente significa antes de tempo.

622
00:30:21,456 --> 00:30:23,400
Acontece que en
calquera programa C que eu escriba,

623
00:30:23,400 --> 00:30:26,640
Teño que inicia-lo con
código que se parece con isto.

624
00:30:26,640 --> 00:30:29,860
E notará CS50 IDE, e
outro desenvolvemento integrado

625
00:30:29,860 --> 00:30:33,050
ambientes como el,
van tentar o mellor

626
00:30:33,050 --> 00:30:34,780
poden rematar o seu pensamento.

627
00:30:34,780 --> 00:30:38,930
De feito, hai un momento si desfacer
o que eu fixen, eu prema Intro.

628
00:30:38,930 --> 00:30:42,160
>> Eu, entón, bateu rizados aberta
cinta, prema Intro novamente.

629
00:30:42,160 --> 00:30:43,430
E rematei o meu pensamento.

630
00:30:43,430 --> 00:30:48,140
Ela me deu unha nova liña, recuado non menos
por razóns estilísticas agradables veremos.

631
00:30:48,140 --> 00:30:51,559
E entón el automaticamente deume
que chaveta para rematar o meu pensamento.

632
00:30:51,559 --> 00:30:53,600
Agora, non sempre
adiviñar o que quere facer.

633
00:30:53,600 --> 00:30:56,620
Pero, en gran parte, fai
aforrar algunhas teclas.

634
00:30:56,620 --> 00:31:02,560
Entón, hai pouco, nós corremos ese program--
Ola, mundo, e entón compilou,

635
00:31:02,560 --> 00:31:03,460
e, a continuación, el foi.

636
00:31:03,460 --> 00:31:04,867
Pero non hai dinamismo aquí.

637
00:31:04,867 --> 00:31:06,700
O que se quixésemos
facer algo diferente?

638
00:31:06,700 --> 00:31:10,630
Ben, o que se eu quixese realmente
obter unha secuencia de usuario?

639
00:31:10,630 --> 00:31:14,250
Vou usar unha peza do puzzle
chamado precisamente isso-- obter cadea.

640
00:31:14,250 --> 00:31:18,860
>> Acontece que en C que, cando non quere
a contribuír a unha parte do enigma,

641
00:31:18,860 --> 00:31:22,360
ou máis propiamente a unha función,
literalmente só facer paréntese de apertura,

642
00:31:22,360 --> 00:31:23,430
preto parénteses.

643
00:31:23,430 --> 00:31:28,540
Por iso, é como se houbese
ningunha caixa branca para escribir en.

644
00:31:28,540 --> 00:31:30,720
O bloque de dicir antes
tiña unha pequena caixa branca.

645
00:31:30,720 --> 00:31:32,660
Non temos esa caixa branca agora.

646
00:31:32,660 --> 00:31:36,310
>> Pero cando eu chamo cadea get, I
Quere poñer o resultado en algún lugar.

647
00:31:36,310 --> 00:31:40,680
Así, un paradigma moi común en C é a
chamar unha función, como cadea de chegar aquí,

648
00:31:40,680 --> 00:31:44,070
e despois gardar o valor de retorno.

649
00:31:44,070 --> 00:31:47,450
É o resultado da súa
esforzo en algo.

650
00:31:47,450 --> 00:31:50,630
>> E cal é a
construír na programación,

651
00:31:50,630 --> 00:31:56,450
en cero ou empresa C, que
pode usar para realmente gardar algo?

652
00:31:56,450 --> 00:31:58,990
Chamou-lle unha variable, non?

653
00:31:58,990 --> 00:32:03,320
E en perigo, nós realmente non
importa o que estaba a ocorrer en variables.

654
00:32:03,320 --> 00:32:05,170
>> Pero, neste caso, nós realmente fan.

655
00:32:05,170 --> 00:32:06,719
Eu vou dicir cadea.

656
00:32:06,719 --> 00:32:08,510
E entón eu podería chamar
iso o que eu queira.

657
00:32:08,510 --> 00:32:11,340
Vou chamalo
nome, recibe obter cadea.

658
00:32:11,340 --> 00:32:13,250
>> E agora, aínda se está
algo novo para iso,

659
00:32:13,250 --> 00:32:14,984
ter en conta que eu estou falta algúns detalles.

660
00:32:14,984 --> 00:32:16,150
Estou esquecendo un punto e coma.

661
00:32:16,150 --> 00:32:17,400
Necesito rematar este pensamento.

662
00:32:17,400 --> 00:32:20,480
Entón, eu vou ir meu cursor,
e bater punto e coma alí.

663
00:32:20,480 --> 00:32:22,130
E o que eu fixen?

664
00:32:22,130 --> 00:32:24,440
Nesta liña de código,
número 5, no momento,

665
00:32:24,440 --> 00:32:26,799
Estou chamando cadea get sen entradas.

666
00:32:26,799 --> 00:32:29,090
Polo tanto, non hai pouco de branco
caixa como o Save bloque ten.

667
00:32:29,090 --> 00:32:31,590
>> Só digo, hey,
ordenador, me unha corda.

668
00:32:31,590 --> 00:32:34,390
O signo igual non é realmente
un signo igual, per se.

669
00:32:34,390 --> 00:32:36,790
É atribución
operador, o que significa,

670
00:32:36,790 --> 00:32:40,860
hey, ordenador, move o valor
da dereita á esquerda.

671
00:32:40,860 --> 00:32:43,480
E na esquerda, eu teño a seguinte.

672
00:32:43,480 --> 00:32:46,580
>> Hey, ordenador, dáme un string--
unha secuencia de caracteres.

673
00:32:46,580 --> 00:32:48,637
E chamar ese nome cadea.

674
00:32:48,637 --> 00:32:50,220
E eu nin sequera teñen que chamalo Name.

675
00:32:50,220 --> 00:32:52,970
>> Podería chamalo, convencionalmente,
algo así como S,

676
00:32:52,970 --> 00:32:55,900
así como usamos i para
chamar a variable i.

677
00:32:55,900 --> 00:32:57,829
Pero agora eu teño que facer algo con el.

678
00:32:57,829 --> 00:33:00,370
Sería moi parvo para
tente compilar este código, executando

679
00:33:00,370 --> 00:33:02,410
este programa, aínda que
Estou a recibir unha corda,

680
00:33:02,410 --> 00:33:04,580
porque aínda é só
vai dicir Hola mundo.

681
00:33:04,580 --> 00:33:09,140
>> Pero e se quero cambiar isto.

682
00:33:09,140 --> 00:33:10,940
Por que non facelo?

683
00:33:10,940 --> 00:33:14,632
Percent s, coma s.

684
00:33:14,632 --> 00:33:16,090
E iso é algo enigmática aínda.

685
00:33:16,090 --> 00:33:18,560
>> Entón deixe-me facer o meu variables máis clara.

686
00:33:18,560 --> 00:33:20,510
Déixeme citar esta Nome variable.

687
00:33:20,510 --> 00:33:23,230
E imos ver se non podemos provocar
ademais o que está pasando aquí.

688
00:33:23,230 --> 00:33:25,770
>> Entón, na liña de cinco, eu estou a recibir unha cadea.

689
00:33:25,770 --> 00:33:28,620
E eu estou almacenando esta secuencia,
todo o que o usuario introduciu no

690
00:33:28,620 --> 00:33:31,430
no teclado,
nunha variable chamada nome.

691
00:33:31,430 --> 00:33:33,590
E verifícase que
printf non só

692
00:33:33,590 --> 00:33:37,220
recibir un argumento en dobre
citas, unha entrada entre comiñas dobres.

693
00:33:37,220 --> 00:33:42,100
>> Pode levar dúas ou tres, ou máis, tales
que o segundo, ou terceiro, ou cuarto,

694
00:33:42,100 --> 00:33:45,320
son todos os nomes de variables,
ou valores en concreto,

695
00:33:45,320 --> 00:33:51,610
que pretende conectar,
dinámica, esta cadea entre comiñas.

696
00:33:51,610 --> 00:33:55,110
Noutras palabras, o que
Sería malo con iso?

697
00:33:55,110 --> 00:34:00,920
Se eu só dixen Ola nome, barra invertida
n, salvo o meu arquivo, compilado meu código,

698
00:34:00,920 --> 00:34:04,660
e foi iso, o que acontecería?

699
00:34:04,660 --> 00:34:08,139
>> É só vai dicir, Ola
citar literalmente N-A-M-E,

700
00:34:08,139 --> 00:34:10,900
que é unha especie de idiota, porque
non é diferente do mundo.

701
00:34:10,900 --> 00:34:13,400
Entón, calquera cousa entre comiñas é
o que, literalmente, imprimirase.

702
00:34:13,400 --> 00:34:15,520
Entón, se eu queira ter
un espazo reservado alí,

703
00:34:15,520 --> 00:34:17,422
En realidade, eu teño usar
algunha sintaxe especial.

704
00:34:17,422 --> 00:34:20,380
E resulta que se ler o
documentación para a función printf,

705
00:34:20,380 --> 00:34:24,320
ha dicirlle que
se usa por cento s,

706
00:34:24,320 --> 00:34:26,920
pode substituír un valor como segue.

707
00:34:26,920 --> 00:34:30,190
>> Tras unha vírgula despois diso
comiñas dobres, simplemente

708
00:34:30,190 --> 00:34:32,179
escribir o nome do
variable que quere

709
00:34:32,179 --> 00:34:36,790
para chamar a este formato
código, ou especificador de formato,

710
00:34:36,790 --> 00:34:38,469
por cento s para cordas.

711
00:34:38,469 --> 00:34:42,190
E agora, se eu teño gardado o meu arquivo,
Eu voltar o meu terminal.

712
00:34:42,190 --> 00:34:45,870
E eu tecleo Fai String,
porque, unha vez máis, o nome do presente

713
00:34:45,870 --> 00:34:48,510
arquivo que eu escollín antes é string.c.

714
00:34:48,510 --> 00:34:51,510
>> Entón eu vou dicir Fai String, entrar.

715
00:34:51,510 --> 00:34:54,550
Oh meu Deus, ollar para todos
os erros que xa fixo.

716
00:34:54,550 --> 00:34:58,540
E iso é-- o que, iso é realmente
como un, sete programa de liña de seis?

717
00:34:58,540 --> 00:35:00,790
Polo tanto, este é onde pode moi
rapidamente obter esmagadora.

718
00:35:00,790 --> 00:35:03,890
>> Esta fiestra de terminal ten
agora só regurgitado

719
00:35:03,890 --> 00:35:06,230
un gran número de mensaxes de erro.

720
00:35:06,230 --> 00:35:10,560
Certamente, eu non teño máis de erro
mensaxes que teño liñas de código.

721
00:35:10,560 --> 00:35:11,680
Entón, o que está a suceder?

722
00:35:11,680 --> 00:35:13,920
>> Ben, a mellor estratexia
para facer en calquera momento

723
00:35:13,920 --> 00:35:16,710
non atopa unha esmagadora
lista de erros como este,

724
00:35:16,710 --> 00:35:19,690
é rolar para atrás, mirar o comando
que acaba de correr que no meu caso

725
00:35:19,690 --> 00:35:21,020
é facer cadea.

726
00:35:21,020 --> 00:35:24,630
Olle para o que fan que o fixo, e que é iso
mando longo Clang, non é gran cousa alí.

727
00:35:24,630 --> 00:35:25,950
>> Pero o vermello é malo.

728
00:35:25,950 --> 00:35:27,750
Verde está tratando de ser
amable e prestativa.

729
00:35:27,750 --> 00:35:29,140
Senón que é malo, nese caso.

730
00:35:29,140 --> 00:35:30,510
Pero onde está mal?

731
00:35:30,510 --> 00:35:34,450
>> String.c, liña de cinco, cinco caracteres.

732
00:35:34,450 --> 00:35:35,930
Polo tanto, esta é só unha convención común.

733
00:35:35,930 --> 00:35:39,060
Algo colon algo significa
número de liña eo número de caracteres.

734
00:35:39,060 --> 00:35:44,080
Erro, a utilización de non declarado
cadea do identificador.

735
00:35:44,080 --> 00:35:45,900
Penso estándar en?

736
00:35:45,900 --> 00:35:48,530
>> Entón, por desgraza, Clang
está a tentar ser útil.

737
00:35:48,530 --> 00:35:49,850
Pero está mal, neste caso.

738
00:35:49,850 --> 00:35:52,350
Non, Clang, eu non quería dicir IO estándar.

739
00:35:52,350 --> 00:35:54,070
Eu quería dicir que na liña un, si.

740
00:35:54,070 --> 00:35:56,420
>> Pero a liña cinco é este aquí.

741
00:35:56,420 --> 00:36:00,040
E Clang non
entender S-T-R-I-N-L.

742
00:36:00,040 --> 00:36:04,490
É un identificador non declarado, a
palabra que nunca viu antes.

743
00:36:04,490 --> 00:36:08,730
E iso é porque C, a linguaxe
estamos escribindo código no momento

744
00:36:08,730 --> 00:36:11,070
Non ten variables chamadas cordas.

745
00:36:11,070 --> 00:36:14,380
>> Non se trata, por defecto, o soporte
algo chamado unha corda.

746
00:36:14,380 --> 00:36:19,750
Isto é unha peza de CS50
xerga, pero moi convencional.

747
00:36:19,750 --> 00:36:21,600
Pero eu podo solucionar isto como segue.

748
00:36:21,600 --> 00:36:25,090
>> Se eu engadir unha liña de código
para o inicio do programa,

749
00:36:25,090 --> 00:36:30,890
inclúen CS50.h, que é outro arquivo
nalgún lugar dentro CS50 IDE, nalgún lugar

750
00:36:30,890 --> 00:36:33,820
no disco duro, por así dicir,
do sistema operativo Ubuntu

751
00:36:33,820 --> 00:36:36,590
que eu estou correndo, que
é o ficheiro que é

752
00:36:36,590 --> 00:36:41,740
vai ensinar o funcionamento
sistema que unha cadea é, só

753
00:36:41,740 --> 00:36:44,930
como io.h estándar é o arquivo
no sistema operativo que é

754
00:36:44,930 --> 00:36:47,430
indo para ensinar-lle o que printf é.

755
00:36:47,430 --> 00:36:49,810
>> De feito, teriamos conseguido
unha mensaxe moi semellante

756
00:36:49,810 --> 00:36:53,600
Se Io tiña admitido estándar
Io.h e intentou utilizar printf.

757
00:36:53,600 --> 00:36:56,632
Entón, eu estou indo a ir adiante e só
tomar control L para limpar a miña pantalla.

758
00:36:56,632 --> 00:36:59,340
Ou podes escribir claro e vai
só limpar a fiestra de terminal.

759
00:36:59,340 --> 00:37:01,020
Pero aínda pode rolar de volta no tempo.

760
00:37:01,020 --> 00:37:04,100
>> E eu estou indo a executar de novo Fai cadea.

761
00:37:04,100 --> 00:37:06,660
Cruzar os dedos esta vez, Intro.

762
00:37:06,660 --> 00:37:08,380
Oh meu Deus, funcionou.

763
00:37:08,380 --> 00:37:12,280
me mostra unha orde longo críptica
que é o que fan xerado vía Clang,

764
00:37:12,280 --> 00:37:13,460
pero ningunha mensaxe de erro.

765
00:37:13,460 --> 00:37:15,460
Entón entende, aínda
pode estar completamente

766
00:37:15,460 --> 00:37:17,480
resaltado coa
número de mensaxes de erro,

767
00:37:17,480 --> 00:37:20,540
el só podería ser esta fervenza irritante
efecto, onde Clang non entende

768
00:37:20,540 --> 00:37:22,620
unha cousa, o que significa que, a continuación,
non entende a palabra seguinte,

769
00:37:22,620 --> 00:37:23,560
ou a liña seguinte.

770
00:37:23,560 --> 00:37:25,850
E por iso só engasga co seu código.

771
00:37:25,850 --> 00:37:27,440
Pero a corrección pode ser simple.

772
00:37:27,440 --> 00:37:30,822
E por iso sempre concentrarse no
primeira liña de saída.

773
00:37:30,822 --> 00:37:32,530
E se non o fai
comprende-lo, só tes que mirar

774
00:37:32,530 --> 00:37:35,480
para palabras clave que pode ser
pistas, eo número de liña,

775
00:37:35,480 --> 00:37:37,650
eo carácter, onde
este erro pode ser.

776
00:37:37,650 --> 00:37:43,328
>> Agora, deixe-me ir adiante e escribir
dot slash, corda, entrar.

777
00:37:43,328 --> 00:37:47,340
Hm, non está dicindo Ola nada.

778
00:37:47,340 --> 00:37:49,210
Por que?

779
00:37:49,210 --> 00:37:51,170
Ben, lembro, onde está a executar?

780
00:37:51,170 --> 00:37:56,730
>> Probablemente está preso no momento
en un loop, se quixeren, na liña seis,

781
00:37:56,730 --> 00:37:59,950
porque Obter Cordas de deseño,
escrito polo equipo CS50,

782
00:37:59,950 --> 00:38:03,350
é literalmente significa só sentir
alí esperando e esperando,

783
00:38:03,350 --> 00:38:04,850
e á espera dunha cadea.

784
00:38:04,850 --> 00:38:06,792
Todo o que quere dicir con cadea de entrada humana.

785
00:38:06,792 --> 00:38:07,500
Entón vostede sabe o que?

786
00:38:07,500 --> 00:38:08,166
Déixeme ir adiante.

787
00:38:08,166 --> 00:38:11,704
E só por un capricho, déixeme
Escribe o meu nome, David, entrar.

788
00:38:11,704 --> 00:38:13,120
Agora eu teño un programa máis dinámico.

789
00:38:13,120 --> 00:38:14,240
Dixo, Ola David.

790
00:38:14,240 --> 00:38:19,280
>> Se eu ir adiante e executar de novo,
déixeme probar dicir o nome Zamila, entrar.

791
00:38:19,280 --> 00:38:20,940
E agora temos un programa dinámico.

792
00:38:20,940 --> 00:38:22,380
Non codificado mundo.

793
00:38:22,380 --> 00:38:24,760
Non codificado
nome, ou David, ou Zamila.

794
00:38:24,760 --> 00:38:28,350
>> Agora é moito máis parecido cos programas
sabemos, en que se aproveitar a entrada,

795
00:38:28,350 --> 00:38:30,870
produce saída lixeiramente diferente.

796
00:38:30,870 --> 00:38:34,020
Agora, este non é o mellor
experiencia do usuario, ou UX.

797
00:38:34,020 --> 00:38:36,000
Executar o programa.

798
00:38:36,000 --> 00:38:38,830
>> Eu non sei o que eu debería
a facer, a menos que realmente ollar para

799
00:38:38,830 --> 00:38:40,290
ou lembrar o código fonte.

800
00:38:40,290 --> 00:38:42,640
Entón, imos facer o usuario
probar un pouco mellor

801
00:38:42,640 --> 00:38:44,240
coa máis simple das cousas.

802
00:38:44,240 --> 00:38:47,782
Déixeme volver a este
programa, e simplemente dicir printf.

803
00:38:47,782 --> 00:38:51,870
>> E deixe-me ir adiante e dicir o nome, colon,
e un espazo e, a continuación, un punto e coma.

804
00:38:51,870 --> 00:38:54,170
E só por diversión, sen descanso n.

805
00:38:54,170 --> 00:38:55,980
E iso é deliberada,
porque eu non quero

806
00:38:55,980 --> 00:38:57,590
a solicitude para mover á seguinte liña.

807
00:38:57,590 --> 00:39:01,800
>> Quero, en vez diso, facelo, faga cadea
recompilar o meu código nova máquina

808
00:39:01,800 --> 00:39:03,980
código dot cortar cadea.

809
00:39:03,980 --> 00:39:05,460
Ah, iso é moito máis fermosa.

810
00:39:05,460 --> 00:39:08,780
Agora eu realmente sei que o ordenador
quere que faga, darlle un nome.

811
00:39:08,780 --> 00:39:13,020
>> Entón, eu estou indo a ir adiante e escribir
en Rob, entrar, e Ola, Rob.

812
00:39:13,020 --> 00:39:16,640
Así, entender, esta aínda é, ao final
do día, só un programa de nove liña.

813
00:39:16,640 --> 00:39:18,090
Pero tivemos estes pasos de bebé.

814
00:39:18,090 --> 00:39:21,380
>> Nós escribir unha liña coa que
estaban familiarizados printf, Ola mundo ,.

815
00:39:21,380 --> 00:39:22,980
Logo desfixo algo diso.

816
00:39:22,980 --> 00:39:24,560
E realmente utilizados cadea get.

817
00:39:24,560 --> 00:39:26,362
E nós xogou ese valor nunha variable.

818
00:39:26,362 --> 00:39:29,070
E, a continuación, fomos adiante e mellorado
aínda máis cunha terceira liña.

819
00:39:29,070 --> 00:39:32,220
E este proceso iterativo de
escribir software é verdadeiramente clave.

820
00:39:32,220 --> 00:39:36,420
En CS50 e na vida en xeral,
normalmente non debe sentir-se,

821
00:39:36,420 --> 00:39:39,800
ten un programa en mente, e tentar escribir
a cousa toda dunha vez.

822
00:39:39,800 --> 00:39:43,810
>> Vai inevitablemente producir forma
máis erros que nós mesmos vimos aquí.

823
00:39:43,810 --> 00:39:47,070
Mesmo eu, ata hoxe, constantemente
facer outros erros estúpidos,

824
00:39:47,070 --> 00:39:50,480
son erros realmente máis difícil
que son máis difíciles de descubrir.

825
00:39:50,480 --> 00:39:55,095
Pero vai cometer máis erros máis
liñas de código que escribe todo dunha vez.

826
00:39:55,095 --> 00:39:57,220
E así esta práctica de,
escribir un pouco de código

827
00:39:57,220 --> 00:40:00,930
que está cómodo, compilar
Lo, executa-lo, proba-lo de modo máis xeral,

828
00:40:00,930 --> 00:40:04,370
a continuación, pasar on-- así como mantivemos
capas e capas a semana pasada,

829
00:40:04,370 --> 00:40:07,190
construción de algo moi
simple de algo máis complexo,

830
00:40:07,190 --> 00:40:08,200
facer o mesmo aquí.

831
00:40:08,200 --> 00:40:11,500
Non se sente, e tentar
escribir un problema enteiro.

832
00:40:11,500 --> 00:40:13,780
Realmente tomar estes pasos de bebé.

833
00:40:13,780 --> 00:40:18,100
>> Agora, cordas non son todos
tan útil para si mesmos.

834
00:40:18,100 --> 00:40:21,210
Teremos, en realidade, ideal, como a
teñen algo máis na nosa caixa de ferramentas.

835
00:40:21,210 --> 00:40:23,990
Entón imos realmente facer exactamente isto.

836
00:40:23,990 --> 00:40:27,900
>> Déixeme ir adiante agora e látego de
un programa pouco diferente.

837
00:40:27,900 --> 00:40:31,320
E nós imos chamar este int.c, por enteiro.

838
00:40:31,320 --> 00:40:33,870
Vou, do mesmo xeito,
inclúen CS550.h.

839
00:40:33,870 --> 00:40:36,060
Eu estou indo a incluír estándar IO.

840
00:40:36,060 --> 00:40:39,630
E iso vai ser moi común
nestes primeiros días de clase.

841
00:40:39,630 --> 00:40:42,050
>> E eu vou pronto
-me cunha función principal.

842
00:40:42,050 --> 00:40:46,370
E agora en vez de comezar unha corda,
imos adiante e obter un int.

843
00:40:46,370 --> 00:40:52,285
Imos chamalo i, e chamalo chegar
int, parens próximos, punto e coma.

844
00:40:52,285 --> 00:40:54,410
E agora imos facer
algo con el, printf.

845
00:40:54,410 --> 00:40:59,190
>> Imos dicir algo como
Ola, barra invertida n, coma i.

846
00:40:59,190 --> 00:41:03,010
Entón, eu estou moi ben imitando
o que eu fixen só un momento atrás.

847
00:41:03,010 --> 00:41:04,660
Eu teño un espazo reservado aquí.

848
00:41:04,660 --> 00:41:08,150
Teño coma i aquí, porque quero
para conectar i en que espazo reservado.

849
00:41:08,150 --> 00:41:10,250
>> Entón, imos adiante e experimentar
compilar este programa.

850
00:41:10,250 --> 00:41:13,060
O ficheiro é chamado int.c.

851
00:41:13,060 --> 00:41:15,920
Entón eu vou dicir, facer int, entrar.

852
00:41:15,920 --> 00:41:19,420
Oh meu Deus, pero non é gran cousa, non?

853
00:41:19,420 --> 00:41:20,230
Hai un erro.

854
00:41:20,230 --> 00:41:22,810
>> Hai un erro de sintaxe
aquí de tal forma que o programa non pode

855
00:41:22,810 --> 00:41:28,460
ser compilado dentro int.c, liña
sete, carácter 27, o formato de erro

856
00:41:28,460 --> 00:41:31,400
especifica tipo char
estrela, o que quere que sexa.

857
00:41:31,400 --> 00:41:33,020
Pero o tipo de argumento é int.

858
00:41:33,020 --> 00:41:36,110
>> Entón, aquí, tamén, non imos a--
aínda que hoxe en día é unha chea de material,

859
00:41:36,110 --> 00:41:38,710
nós estamos indo a oprimir-lo con
absolutamente todas as características do C,

860
00:41:38,710 --> 00:41:41,070
e programación dun xeito máis xeral,
en só estas primeiras semanas.

861
00:41:41,070 --> 00:41:43,400
Polo tanto, hai moitas veces vai ser xerga
co que non está familiarizado.

862
00:41:43,400 --> 00:41:46,350
E, de feito, estrela char é algo
imos volver

863
00:41:46,350 --> 00:41:47,830
en vez de unha semana ou dúas de.

864
00:41:47,830 --> 00:41:50,530
>> Pero, por agora, imos ver se podemos
analizar as palabras que son familiares.

865
00:41:50,530 --> 00:41:53,750
Formatos-- iso escoitamos formato
especificador, código de formato antes.

866
00:41:53,750 --> 00:41:54,840
Isto é familiar.

867
00:41:54,840 --> 00:41:56,840
Type-- pero o argumento ten o tipo int.

868
00:41:56,840 --> 00:41:58,980
Agarde un minuto, i é un int.

869
00:41:58,980 --> 00:42:02,230
>> Quizais por cento s en realidade,
ten algún significado definido.

870
00:42:02,230 --> 00:42:03,230
E, de feito, fai.

871
00:42:03,230 --> 00:42:06,101
Un enteiro, se quere
printf para substituílo,

872
00:42:06,101 --> 00:42:08,350
realmente ten que usar un
especificador de formato diferente.

873
00:42:08,350 --> 00:42:09,890
E non sabería que
a menos que alguén lle dixo,

874
00:42:09,890 --> 00:42:10,973
ou fixo iso antes.

875
00:42:10,973 --> 00:42:13,490
Pero o que é por cento i
pode ser utilizada

876
00:42:13,490 --> 00:42:15,240
en printf para conectar un enteiro.

877
00:42:15,240 --> 00:42:17,920
Tamén pode usar cento
d para un número enteiro decimal.

878
00:42:17,920 --> 00:42:19,490
Pero é agradable e sinxela aquí.

879
00:42:19,490 --> 00:42:20,590
Entón, imos ir con iso.

880
00:42:20,590 --> 00:42:24,160
>> Agora, deixe-me ir adiante e
reprise make int, Intro.

881
00:42:24,160 --> 00:42:26,328
Isto é bo, sen erros.

882
00:42:26,328 --> 00:42:30,260
Dot cortar OK int--, mala experiencia do usuario,
porque eu non dixen a min mesmo

883
00:42:30,260 --> 00:42:30,760
que facer.

884
00:42:30,760 --> 00:42:31,426
Pero iso é bo.

885
00:42:31,426 --> 00:42:32,480
Estou pegando rapidamente.

886
00:42:32,480 --> 00:42:39,260
>> E agora déixeme ir adiante e
escribir David, OK, Zamila, Rob.

887
00:42:39,260 --> 00:42:40,820
OK, entón iso é unha cousa boa.

888
00:42:40,820 --> 00:42:44,710
Esta vez, está a usar unha función,
unha peza do puzzle, chamado Get int.

889
00:42:44,710 --> 00:42:47,230
E pasa out-- e nós imos
ver iso máis tarde no term--

890
00:42:47,230 --> 00:42:50,730
o equipo CS50 aplicou
obter secuencia de tal forma

891
00:42:50,730 --> 00:42:53,350
que vai só fisicamente
obter unha corda para ti.

892
00:42:53,350 --> 00:42:57,340
>> El aplicou get int en
de tal forma que só pode

893
00:42:57,340 --> 00:42:58,590
obter un número enteiro para ti.

894
00:42:58,590 --> 00:43:00,830
E se, o ser humano,
non cooperar, é

895
00:43:00,830 --> 00:43:03,590
literalmente indo só para
din repetir, repetir, repetir,

896
00:43:03,590 --> 00:43:08,200
literalmente sentado alí looping, ata
vostede obrigar con algún número máxico,

897
00:43:08,200 --> 00:43:10,670
como 50, e Ola 50.

898
00:43:10,670 --> 00:43:14,440
>> Ou se executar esta nova
e escriba 42, Ola 42.

899
00:43:14,440 --> 00:43:18,750
E así a función get int
dentro dese enigma

900
00:43:18,750 --> 00:43:22,050
é a lóxica suficiente, o pensamento suficiente,
de descubrir, o que é unha palabra?

901
00:43:22,050 --> 00:43:23,330
E o que é un número?

902
00:43:23,330 --> 00:43:26,165
Só aceptar, en última instancia, números.

903
00:43:26,165 --> 00:43:28,690

904
00:43:28,690 --> 00:43:33,230
>> Así, verifícase que esta
Non é todo o que expresivo.

905
00:43:33,230 --> 00:43:33,910
moi lonxe.

906
00:43:33,910 --> 00:43:36,690
Entón, yay, última vez que
pasou moi rápido

907
00:43:36,690 --> 00:43:41,320
en xogos de execución, e animación,
e obras artísticas en cero.

908
00:43:41,320 --> 00:43:45,260
E aquí, estamos a ser contido
con Ola mundo, e Ola 50.

909
00:43:45,260 --> 00:43:46,696
>> Non é todo o que inspirado.

910
00:43:46,696 --> 00:43:49,070
E, de feito, estes primeiros
exemplos vai levar moito tempo

911
00:43:49,070 --> 00:43:50,510
a rampla ata en emoción.

912
00:43:50,510 --> 00:43:52,854
Pero temos moito máis
controlar o momento, en realidade.

913
00:43:52,854 --> 00:43:54,770
E nós estamos indo moi
iniciar rapidamente capas

914
00:43:54,770 --> 00:43:56,870
enriba destas primitivas básicas.

915
00:43:56,870 --> 00:43:59,370
>> Pero, primeiro, imos entender
cales son as limitacións.

916
00:43:59,370 --> 00:44:01,620
De feito, unha das cousas
Cero non é fácil

917
00:44:01,620 --> 00:44:03,990
imos facer é realmente ollar
por baixo da capa,

918
00:44:03,990 --> 00:44:06,740
e entender o que é un
ordenador, o que pode facer,

919
00:44:06,740 --> 00:44:08,250
e cales son as súas limitacións.

920
00:44:08,250 --> 00:44:11,580
E, de feito, que a falta de
comprensión, potencialmente, a longo prazo

921
00:44:11,580 --> 00:44:15,520
pode levar a nosa propia escrita mistakes--
erros, escribindo software inseguro que

922
00:44:15,520 --> 00:44:16,880
for cortada de algunha maneira.

923
00:44:16,880 --> 00:44:20,130
>> Entón, imos dar algúns pasos cara a
comprender isto un pouco mellor,

924
00:44:20,130 --> 00:44:22,710
forma de, digamos, o exemplo a seguir.

925
00:44:22,710 --> 00:44:26,550
Eu estou indo a ir adiante e aplicar
rapidinho un programa chamado Adder.

926
00:44:26,550 --> 00:44:28,134
Como, imos engadir algúns números xuntos.

927
00:44:28,134 --> 00:44:30,800
E eu estou indo a codificar algúns cantos
aquí, e simplemente copiar e pegar

928
00:44:30,800 --> 00:44:33,270
onde estaba antes, só
para que poidamos ir máis cedo.

929
00:44:33,270 --> 00:44:36,090
Entón agora eu teño os principios básicos
dun programa chamado Adder.

930
00:44:36,090 --> 00:44:37,670
>> E imos adiante e facelo.

931
00:44:37,670 --> 00:44:41,680
Eu estou indo a ir adiante e
digamos, IntX recibe obter int.

932
00:44:41,680 --> 00:44:42,430
E vostede sabe o que?

933
00:44:42,430 --> 00:44:43,990
Imos facer unha mellor experiencia do usuario.

934
00:44:43,990 --> 00:44:48,740
>> Entón, imos só dicir que x é e, efectivamente,
solicitar ao usuario a darnos x.

935
00:44:48,740 --> 00:44:53,600
E, a continuación, deixe-me ir adiante e dicir: printf
como sobre y é, desta vez esperando

936
00:44:53,600 --> 00:44:56,140
dous valores desde o usuario.

937
00:44:56,140 --> 00:45:02,759
E entón imos só ir adiante e
digamos, printf, a suma de x e y é.

938
00:45:02,759 --> 00:45:04,300
E agora eu non quero facer por cento s.

939
00:45:04,300 --> 00:45:12,080
Eu quero facer por cento i, barra invertida
n, e logo conecte valor da suma.

940
00:45:12,080 --> 00:45:13,620
>> Entón, como podo facer sobre iso?

941
00:45:13,620 --> 00:45:14,270
Vostede sabe o que?

942
00:45:14,270 --> 00:45:15,840
Sei como usar variables.

943
00:45:15,840 --> 00:45:18,140
Déixeme só declarar unha nova, int z.

944
00:45:18,140 --> 00:45:19,770
>> E eu vou dar un palpite aquí.

945
00:45:19,770 --> 00:45:24,470
Se hai signos iguais nesta
linguaxe, quizais eu só podo facer x máis y,

946
00:45:24,470 --> 00:45:26,660
mentres eu rematar o meu
pensou cun punto e coma?

947
00:45:26,660 --> 00:45:31,170
Agora podo volver para acá, Póñase z,
rematar este pensamento cun punto e coma.

948
00:45:31,170 --> 00:45:36,160
E imos ver agora, se estes
secuencias de lines-- x é obter int.

949
00:45:36,160 --> 00:45:37,770
Y é obter int.

950
00:45:37,770 --> 00:45:40,980
>> Agregar x e y, almacenar o valor en z--
por iso, unha vez máis, lembre o signo igual

951
00:45:40,980 --> 00:45:41,560
non é igual.

952
00:45:41,560 --> 00:45:44,100
É atribución da dereita á esquerda.

953
00:45:44,100 --> 00:45:48,180
E imos imprimir que a suma
de X e Y non é literalmente Z,

954
00:45:48,180 --> 00:45:49,830
pero o que está dentro z.

955
00:45:49,830 --> 00:45:53,090
Entón, imos facer Adder -
agradables, sen erros nesta ocasión.

956
00:45:53,090 --> 00:45:56,030
Dot cortar Adder, entrar,
x será 1.

957
00:45:56,030 --> 00:45:58,380
>> Y será 2.

958
00:45:58,380 --> 00:46:01,964
E a suma de x e y é 3.

959
00:46:01,964 --> 00:46:03,130
Entón, iso é todo moi ben e bo.

960
00:46:03,130 --> 00:46:06,260
>> Entón podes imaxinar que a matemática
deben traballar nun programa como este.

961
00:46:06,260 --> 00:46:07,040
Pero vostede sabe o que?

962
00:46:07,040 --> 00:46:09,904
É esta variable, liña
12, aínda necesario?

963
00:46:09,904 --> 00:46:12,820
Non precisa adquirir o hábito
de só almacenar cousas en variables

964
00:46:12,820 --> 00:46:13,980
só porque pode.

965
00:46:13,980 --> 00:46:16,550
E, de feito, é xeralmente
mala concepción ponderada

966
00:46:16,550 --> 00:46:21,100
se está creando unha variable chamada
z, neste caso, o almacenamento en algo que,

967
00:46:21,100 --> 00:46:24,390
e logo, inmediatamente
usalo, pero nunca de novo.

968
00:46:24,390 --> 00:46:27,700
Por que dar algo dun nome
como z, se está literalmente

969
00:46:27,700 --> 00:46:29,770
Vai usar este
cousa só unha vez, e así

970
00:46:29,770 --> 00:46:32,380
proximal ao lugar onde creou
Lo en primeiro lugar,

971
00:46:32,380 --> 00:46:34,052
tan preto en termos de liñas de código?

972
00:46:34,052 --> 00:46:34,760
Entón vostede sabe o que?

973
00:46:34,760 --> 00:46:37,480
Acontece que C é moi flexible.

974
00:46:37,480 --> 00:46:39,586
Se realmente quero
plugin valores aquí,

975
00:46:39,586 --> 00:46:41,210
Non ten declarar unha nova variable.

976
00:46:41,210 --> 00:46:44,680
Podería só plugin x máis
y porque C entende

977
00:46:44,680 --> 00:46:46,390
aritmética e operadores matemáticos.

978
00:46:46,390 --> 00:46:50,140
>> Entón, podo simplemente dicir, facer esa matemática,
x máis y, o que quere que eses valores son,

979
00:46:50,140 --> 00:46:53,780
Conecte o resultante
enteiro a esta cadea.

980
00:46:53,780 --> 00:46:56,730
Polo tanto, este pode ser, aínda que
só unha liña máis curta,

981
00:46:56,730 --> 00:47:01,480
un proxecto mellor, un programa mellor,
porque hai menos código, polo tanto,

982
00:47:01,480 --> 00:47:02,921
menos para min entender.

983
00:47:02,921 --> 00:47:04,920
E tamén é só máis limpo,
na medida en que non estamos

984
00:47:04,920 --> 00:47:07,620
introdución de novas palabras,
novos símbolos, como z,

985
00:47:07,620 --> 00:47:10,510
aínda que realmente non
serven moito dun propósito.

986
00:47:10,510 --> 00:47:15,890
>> Desafortunadamente, a matemática non é
todos os que ás veces fiables.

987
00:47:15,890 --> 00:47:18,270
Imos ir adiante e facelo.

988
00:47:18,270 --> 00:47:21,200
Eu estou indo a ir adiante
agora e faga o seguinte.

989
00:47:21,200 --> 00:47:30,650
>> Imos facer printf, cento i, ademais de por cento
i, será por cento i, barra invertida n.

990
00:47:30,650 --> 00:47:35,240
E eu vou facer isto-- xyx máis y.

991
00:47:35,240 --> 00:47:37,821
Entón eu só vou reescribir
esta un pouco diferente aquí.

992
00:47:37,821 --> 00:47:39,320
Déixeme só facer unha comprobación de sanidade rápida.

993
00:47:39,320 --> 00:47:40,986
Unha vez máis, non imos estar á fronte de nós mesmos.

994
00:47:40,986 --> 00:47:44,420
Fai víbora, punto barra víbora.

995
00:47:44,420 --> 00:47:47,950
x é 1, y é 2, 1 é máis 2 3.

996
00:47:47,950 --> 00:47:48,870
Entón, iso é bo.

997
00:47:48,870 --> 00:47:52,060
Pero imos complicar iso agora
un pouco, e crear un novo ficheiro.

998
00:47:52,060 --> 00:47:56,350
>> Vou chamar esta,
dicir, ints, plural para enteiros.

999
00:47:56,350 --> 00:47:58,980
Déixeme comezar de onde eu era un momento atrás.

1000
00:47:58,980 --> 00:48:00,770
Pero agora imos facer algunhas outras liñas.

1001
00:48:00,770 --> 00:48:06,430
Deixe-me ir adiante e facer o seguinte,
printf, cento i, menos por cento i,

1002
00:48:06,430 --> 00:48:11,959
é por cento i, coma x, coma yx menos y.

1003
00:48:11,959 --> 00:48:13,750
Entón, eu estou facendo algo
matemática diferente alí.

1004
00:48:13,750 --> 00:48:14,624
Imos facer outro.

1005
00:48:14,624 --> 00:48:19,610
Así por cento i veces por cento
i é por cento i, barra invertida n.

1006
00:48:19,610 --> 00:48:24,430
Imos plugin x e y, e x veces y de.

1007
00:48:24,430 --> 00:48:27,530
Imos usar o asterisco na
o ordenador para veces.

1008
00:48:27,530 --> 00:48:29,390
>> Non usa x. X é
un nome de variable aquí.

1009
00:48:29,390 --> 00:48:31,270
Usa a estrela para a multiplicación.

1010
00:48:31,270 --> 00:48:32,020
Imos facer un.

1011
00:48:32,020 --> 00:48:37,580
Printf por cento eu, dividido
por cento i, é por cento i,

1012
00:48:37,580 --> 00:48:43,460
n barra invertida. xy dividido por y--
para que use a barra en C

1013
00:48:43,460 --> 00:48:44,502
para facer a división.

1014
00:48:44,502 --> 00:48:45,460
E imos facer outro.

1015
00:48:45,460 --> 00:48:50,920

1016
00:48:50,920 --> 00:48:58,240
Resto por cento i, divididos
por cento i, é por cento eu.

1017
00:48:58,240 --> 00:49:02,550
xy-- e agora resta
é o que sobrou.

1018
00:49:02,550 --> 00:49:05,980
Cando tentar dividir un
denominador dentro dun numerador,

1019
00:49:05,980 --> 00:49:08,570
como é deixar ao longo deste
non podería dividir fóra?

1020
00:49:08,570 --> 00:49:10,910
>> Non hai realmente,
necesariamente, un símbolo

1021
00:49:10,910 --> 00:49:12,470
usamos na escola por iso.

1022
00:49:12,470 --> 00:49:16,830
Pero alí C. Pode
din x modulo y, onde

1023
00:49:16,830 --> 00:49:21,000
este signo por cento neste context--
confusa cando está dentro

1024
00:49:21,000 --> 00:49:23,170
das comiñas dobres,
dentro printf, cento

1025
00:49:23,170 --> 00:49:24,830
é utilizado como o especificador de formato.

1026
00:49:24,830 --> 00:49:28,420
>> Cando usa por cento fóra do
en que unha expresión matemática,

1027
00:49:28,420 --> 00:49:32,910
é o operador módulo para modular
arithmetic-- para os nosos propósitos

1028
00:49:32,910 --> 00:49:36,650
aquí, só significa, cal é a
resto X dividido polo y?

1029
00:49:36,650 --> 00:49:39,130
Así, X dividido polo y é X Y barra.

1030
00:49:39,130 --> 00:49:41,220
Cal é o resto x dividido por y?

1031
00:49:41,220 --> 00:49:44,780
É x y mod, como un programador diría.

1032
00:49:44,780 --> 00:49:51,300
>> Entón, se eu non cometeu erros aquí, déixeme
dalle facer ints, plural, agradable,

1033
00:49:51,300 --> 00:49:53,010
e ints da corte do punto.

1034
00:49:53,010 --> 00:49:58,270
E imos adiante e
facer, digamos, 1, 10.

1035
00:49:58,270 --> 00:50:01,390
Todo ben, 1, acrescido de 10 e 11, cheque.

1036
00:50:01,390 --> 00:50:04,240
1 menos 10 é negativo 9, confía.

1037
00:50:04,240 --> 00:50:06,420
>> 1 veces 10 é 10, cheque.

1038
00:50:06,420 --> 00:50:10,090
1 dividido por 10 é--
OK, imos saltar esa.

1039
00:50:10,090 --> 00:50:12,480
Resto de 1 dividido por 10 é 1.

1040
00:50:12,480 --> 00:50:13,680
Isto é correcto.

1041
00:50:13,680 --> 00:50:15,630
Pero hai un erro aquí.

1042
00:50:15,630 --> 00:50:18,390
>> Entón, o que eu poñer a miña
entregar, non é correcto.

1043
00:50:18,390 --> 00:50:19,670
Quero dicir, é próximo a 0.

1044
00:50:19,670 --> 00:50:23,670
1 dividido por 10, vostede sabe, se estivermos
cortar algúns cantos, con certeza, é cero.

1045
00:50:23,670 --> 00:50:31,050
Pero realmente debe ser 1/10,
0,1, ou 0,10, 0,1000, ou así por diante.

1046
00:50:31,050 --> 00:50:33,600
>> Non debe ser realmente cero.

1047
00:50:33,600 --> 00:50:38,990
Ben, parece que o ordenador está
facendo literalmente o que dixo para facer.

1048
00:50:38,990 --> 00:50:42,460
Estamos facendo a matemática como x dividido por y.

1049
00:50:42,460 --> 00:50:47,680
E ambos x e y, por liñas
de código anterior, son números enteiros.

1050
00:50:47,680 --> 00:50:53,440
>> Ademais, na liña 15, que son
dicindo printf, hey, printf plugin

1051
00:50:53,440 --> 00:50:57,230
un enteiro, plugin un número enteiro,
conectar un integer-- especificamente

1052
00:50:57,230 --> 00:51:00,580
x, e, a continuación, y, e logo, x
dividido por y. x e y son enteiros.

1053
00:51:00,580 --> 00:51:02,060
Somos bos alí.

1054
00:51:02,060 --> 00:51:04,250
>> Pero o que é x dividido por x?

1055
00:51:04,250 --> 00:51:09,790
X dividido polo y debe ser,
Matematicamente, 10/01, ou 0,1,

1056
00:51:09,790 --> 00:51:14,600
que é un número real, un número real
ter, potencialmente, un punto decimal.

1057
00:51:14,600 --> 00:51:16,230
Non é un número enteiro.

1058
00:51:16,230 --> 00:51:21,290
>> Pero o que é o máis próximo
número enteiro de 10/01, ou 0,1?

1059
00:51:21,290 --> 00:51:24,114
Si, tipo de é cero.

1060
00:51:24,114 --> 00:51:25,030
0,1 é así moito.

1061
00:51:25,030 --> 00:51:25,890
E 1 é moi presente.

1062
00:51:25,890 --> 00:51:28,870
Así, 1/10 está máis preto
0 que é a un.

1063
00:51:28,870 --> 00:51:33,800
>> E entón o que C está facendo por US--
tipo de porque dixo que a--

1064
00:51:33,800 --> 00:51:35,600
é truncar este completo.

1065
00:51:35,600 --> 00:51:43,540
É tomar o valor, que de novo é
debería ser algo así como 0,1 mil,

1066
00:51:43,540 --> 00:51:44,800
0 e así por diante.

1067
00:51:44,800 --> 00:51:48,320
E está truncando todo
despois do punto decimal

1068
00:51:48,320 --> 00:51:50,510
de xeito que todo isto
material, porque non

1069
00:51:50,510 --> 00:51:54,910
caben na noción dun enteiro, que
é só un número como negativo 1, 0, 1,

1070
00:51:54,910 --> 00:51:58,830
arriba e abaixo, el xoga fóra todo
despois do punto decimal porque

1071
00:51:58,830 --> 00:52:02,020
non pode caber nun punto decimal
nun número enteiro, por definición.

1072
00:52:02,020 --> 00:52:04,290
>> Polo tanto, a resposta aquí é cero.

1073
00:52:04,290 --> 00:52:05,600
Entón, como podemos solucionar isto?

1074
00:52:05,600 --> 00:52:07,400
Necesitamos unha outra solución en conxunto.

1075
00:52:07,400 --> 00:52:09,880
E podemos facer iso, como segue.

1076
00:52:09,880 --> 00:52:15,820
>> Deixe-me ir adiante e crear unha nova
ficheiro, este chamado floats.c.

1077
00:52:15,820 --> 00:52:19,500
E gardalo aquí no
mesmo directorio, float.c.

1078
00:52:19,500 --> 00:52:22,360

1079
00:52:22,360 --> 00:52:26,260
E deixe-me ir adiante e copiar
algúns de que o código de antes.

1080
00:52:26,260 --> 00:52:30,690
>> Pero en vez de estar
un int, imos facelo.

1081
00:52:30,690 --> 00:52:34,037
Dáme un valor de punto flotante
chamado x. onde un punto flotante

1082
00:52:34,037 --> 00:52:36,370
valor é só literalmente
algo cun punto flotante.

1083
00:52:36,370 --> 00:52:37,410
Pode mover-se cara á esquerda, á dereita.

1084
00:52:37,410 --> 00:52:38,530
É un número real.

1085
00:52:38,530 --> 00:52:41,050
>> E deixe-me chamar
obter int, pero chegar float,

1086
00:52:41,050 --> 00:52:44,420
que tamén estaba entre o menú
de opcións na biblioteca C250.

1087
00:52:44,420 --> 00:52:46,220
Imos cambiar y a unha boia.

1088
00:52:46,220 --> 00:52:48,000
Polo tanto, este pasa a ser obter float.

1089
00:52:48,000 --> 00:52:50,620
>> E agora, nós non queremos para conectar ints.

1090
00:52:50,620 --> 00:52:56,130
Acontece que temos que usar cento
f para float, por cento f para float,

1091
00:52:56,130 --> 00:52:57,560
e agora salvalo.

1092
00:52:57,560 --> 00:53:04,220
E agora, dedos cruzados, facer
flotadores, agradable, flotadores da corte de punto.

1093
00:53:04,220 --> 00:53:07,280
x será un 1. y
Será 10 de novo.

1094
00:53:07,280 --> 00:53:11,240
>> E, bo, OK miña banda é correcta.

1095
00:53:11,240 --> 00:53:13,240
Eu estaba esperando por máis,
pero eu esquezo de escribir.

1096
00:53:13,240 --> 00:53:16,250
Entón, imos ir e corrixir este erro lóxico.

1097
00:53:16,250 --> 00:53:19,280
>> Imos adiante e coller o seguinte.

1098
00:53:19,280 --> 00:53:21,080
Nós imos só facer un pouco de copiar e pegar.

1099
00:53:21,080 --> 00:53:23,080
E eu vou dicir de menos.

1100
00:53:23,080 --> 00:53:24,890
>> E eu vou dicir veces.

1101
00:53:24,890 --> 00:53:27,060
E eu vou dicir dividida.

1102
00:53:27,060 --> 00:53:31,240
E eu non vou facer modulo,
que non é tan pertinentes aquí,

1103
00:53:31,240 --> 00:53:36,690
dividido por f, e veces plus--
OK, imos facelo de novo.

1104
00:53:36,690 --> 00:53:47,210
>> Fan flotadores, boias de barra punto,
e 1, 10, e- agradable, non, OK.

1105
00:53:47,210 --> 00:53:48,250
Entón, eu son un idiota.

1106
00:53:48,250 --> 00:53:50,000
Entón, iso é moi común
en ciencia da computación

1107
00:53:50,000 --> 00:53:52,780
cometendo erros estúpidos como este.

1108
00:53:52,780 --> 00:53:56,100
>> Para fins pedagóxicos,
o que realmente quería facer

1109
00:53:56,100 --> 00:54:00,410
foi cambiar a ciencia aquí
para máis, a menos, á época,

1110
00:54:00,410 --> 00:54:04,140
e para dividir, como espera
notado durante este exercicio.

1111
00:54:04,140 --> 00:54:07,700
Entón agora imos volver compilar este
programa, faga flotadores da corte de punto.

1112
00:54:07,700 --> 00:54:10,950
>> E por terceira vez, imos
ver se atende ás miñas expectativas.

1113
00:54:10,950 --> 00:54:24,480
1, 10, entrar, si, OK, 1000,
dividido por 10,000, é 0,100000.

1114
00:54:24,480 --> 00:54:27,952
E resulta que podemos controlar cantas
números son despois destes puntos decimais.

1115
00:54:27,952 --> 00:54:28,660
Nós realmente vai.

1116
00:54:28,660 --> 00:54:29,790
Nós imos voltar a iso.

1117
00:54:29,790 --> 00:54:31,440
>> Pero agora, de feito, a matemática é correcta.

1118
00:54:31,440 --> 00:54:33,090
Entón, unha vez máis, que é o takeaway aquí?

1119
00:54:33,090 --> 00:54:36,050
Acontece que en C, existen
non só só strings-- e, de feito,

1120
00:54:36,050 --> 00:54:39,120
non hai realmente, porque nós
engadir aqueles coa biblioteca CS50.

1121
00:54:39,120 --> 00:54:40,710
Pero non son só números enteiros.

1122
00:54:40,710 --> 00:54:41,990
>> Tamén flota.

1123
00:54:41,990 --> 00:54:45,810
E verifícase un monte de outros datos
tipo tamén, que usaremos en pouco tempo.

1124
00:54:45,810 --> 00:54:49,270
Acontece que se quere un único
carácter, e non unha cadea de caracteres,

1125
00:54:49,270 --> 00:54:50,610
pode usar só un char.

1126
00:54:50,610 --> 00:54:55,350
>> Acontece que, se quere un bool,
un valor booleano, único verdadeiro ou falso,

1127
00:54:55,350 --> 00:54:59,840
grazas á biblioteca CS50, temos
engadido a C, o tipo de datos booleano ben.

1128
00:54:59,840 --> 00:55:02,180
Pero tamén está presente en
moitas outras linguas tamén.

1129
00:55:02,180 --> 00:55:07,130
E resulta que ás veces
precisan de números grandes, a continuación, veñen por defecto

1130
00:55:07,130 --> 00:55:08,210
con ints e Carrozas.

1131
00:55:08,210 --> 00:55:13,590
>> E, de feito, un dobre é un número
que usa nin 32 bits, pero 64 bits.

1132
00:55:13,590 --> 00:55:17,990
E un longo tempo é un número que
usa nin 32, bits, pero 64 bits,

1133
00:55:17,990 --> 00:55:22,190
respectivamente, para punto flotante
valores e enteiros, respectivamente.

1134
00:55:22,190 --> 00:55:25,780
Entón imos realmente agora
ver iso en acción.

1135
00:55:25,780 --> 00:55:29,150
>> Eu estou indo a ir adiante aquí
e látego dun navegador.

1136
00:55:29,150 --> 00:55:35,020
Aquí, eu estou indo a ir adiante
e non inclúen CS50.h.

1137
00:55:35,020 --> 00:55:37,910
E deixe-me ir, inclúen por defecto IO.h.

1138
00:55:37,910 --> 00:55:40,320
>> E vai notar algo
funky está pasando aquí.

1139
00:55:40,320 --> 00:55:43,592
Non é codificación de cores as cousas en
do mesmo xeito como facía antes.

1140
00:55:43,592 --> 00:55:46,550
E ao parecer, iso é porque eu
non deron a cousa un nome de ficheiro.

1141
00:55:46,550 --> 00:55:50,270
>> Vou chamar esta
sizeof.c, e bateu en Gardar.

1142
00:55:50,270 --> 00:55:54,039
E teña en conta o que pasa co meu moi
código de branco contra este pano de fondo negro.

1143
00:55:54,039 --> 00:55:55,830
Agora, polo menos hai
Nalgúns roxos alí.

1144
00:55:55,830 --> 00:55:57,490
E é sintaxe destacada.

1145
00:55:57,490 --> 00:56:00,700
>> Isto é porque, moi simplemente, non teño
dixo ao IDE que tipo de ficheiro

1146
00:56:00,700 --> 00:56:04,060
iso é dándolle un nome, e
especialmente unha extensión de arquivo.

1147
00:56:04,060 --> 00:56:06,620
Agora, imos ir adiante e facelo.

1148
00:56:06,620 --> 00:56:11,910
Eu estou indo a ir adiante e moi
simplemente imprimir o bool following--

1149
00:56:11,910 --> 00:56:14,080
é por cento LU.

1150
00:56:14,080 --> 00:56:15,950
>> Nós imos volver
que en só un momento.

1151
00:56:15,950 --> 00:56:18,840
E entón eu vou
tamaño de impresión de bool.

1152
00:56:18,840 --> 00:56:21,170
E agora, só para aforrar
-me un tempo, eu son

1153
00:56:21,170 --> 00:56:23,280
fará un todo
banda deles á vez.

1154
00:56:23,280 --> 00:56:27,620
E, especialmente, eu vou
cambiar isto para un char e carbón.

1155
00:56:27,620 --> 00:56:30,760
Este, eu vou cambiar
para unha parella e unha de matrimonio.

1156
00:56:30,760 --> 00:56:34,440
>> Este, eu vou cambiar
a unha boia e un flotador.

1157
00:56:34,440 --> 00:56:38,670
Este, eu vou
cambiar a un int e un int.

1158
00:56:38,670 --> 00:56:41,660
E este, eu vou
para cambiar a un longo tempo.

1159
00:56:41,660 --> 00:56:43,840
E aínda está tomando
un longo tempo, moito tempo.

1160
00:56:43,840 --> 00:56:47,572
>> E entón, finalmente, dei
me un demasiados, corda.

1161
00:56:47,572 --> 00:56:50,030
Acontece que en C, non hai
o operador especial chamado

1162
00:56:50,030 --> 00:56:53,260
tamaño do que é, literalmente,
Vai, cando se executa,

1163
00:56:53,260 --> 00:56:55,099
Díganos o tamaño do
Cada unha destas variables.

1164
00:56:55,099 --> 00:56:56,890
E este é un camiño, agora,
podemos chamar de volta

1165
00:56:56,890 --> 00:57:00,140
a discusión da semana pasada
de datos e de representación.

1166
00:57:00,140 --> 00:57:03,330
>> Deixe-me ir adiante e compilar
tamaño tamaño de punto de corte.

1167
00:57:03,330 --> 00:57:04,210
E veremos.

1168
00:57:04,210 --> 00:57:08,210
Acontece que en C,
especialmente en CS50 IDE,

1169
00:57:08,210 --> 00:57:11,170
especialmente na
sistema operativo Ubuntu,

1170
00:57:11,170 --> 00:57:14,100
que é un operativo de 64 bits
sistema, neste caso,

1171
00:57:14,100 --> 00:57:17,189
un booleano vai
usar un byte de espazo.

1172
00:57:17,189 --> 00:57:19,480
É así que o tamaño é medida,
non en bits, pero en bytes.

1173
00:57:19,480 --> 00:57:21,690
E lembrar que un byte é oito bits.

1174
00:57:21,690 --> 00:57:25,030
Así, un bool, aínda que
tecnicamente só precisa dun 0 ou 1,

1175
00:57:25,030 --> 00:57:27,092
é un pouco desperdicio
como temos implantado.

1176
00:57:27,092 --> 00:57:29,800
Realmente vai utilizar un todo
byte-- para que todos os ceros, son talvez

1177
00:57:29,800 --> 00:57:34,050
todos aqueles, ou algo así,
ou só un 1 entre os oito bits.

1178
00:57:34,050 --> 00:57:37,962
>> Un char, á súa vez, usado para un personaxe
como un carácter ASCII por semana pasada

1179
00:57:37,962 --> 00:57:39,170
será un personaxe.

1180
00:57:39,170 --> 00:57:45,340
E que sincroniza-se coa nosa noción de
sendo non máis que 256 bits-- vez,

1181
00:57:45,340 --> 00:57:48,360
sincroniza-se con el habendo
máis de 8 bits, que

1182
00:57:48,360 --> 00:57:50,450
dános ata 256 valores.

1183
00:57:50,450 --> 00:57:52,680
O dúo vai
ser de 8 bytes ou 64 bits.

1184
00:57:52,680 --> 00:57:53,510
>> Un flotador é 4.

1185
00:57:53,510 --> 00:57:54,690
Un int é de 4.

1186
00:57:54,690 --> 00:57:55,980
Un longo, longo é 8.

1187
00:57:55,980 --> 00:57:57,716
E unha corda é 8.

1188
00:57:57,716 --> 00:57:58,840
Pero non se preocupe con iso.

1189
00:57:58,840 --> 00:58:00,340
Nós imos pelar esa capa.

1190
00:58:00,340 --> 00:58:02,940
Acontece que, cordas poden
ter máis de 8 bytes.

1191
00:58:02,940 --> 00:58:05,310
>> E, de feito, escribimos
cordas xa, Ola mundo,

1192
00:58:05,310 --> 00:58:06,700
máis de 8 bytes.

1193
00:58:06,700 --> 00:58:09,270
Pero imos voltar a
que en só un momento.

1194
00:58:09,270 --> 00:58:12,690
Pero a toma de distancia aquí é o seguinte.

1195
00:58:12,690 --> 00:58:18,320
>> Calquera ordenador só ten unha finita
cantidade de memoria e espazo.

1196
00:58:18,320 --> 00:58:20,860
Só podes gardar tantos
ficheiros no seu Mac ou PC.

1197
00:58:20,860 --> 00:58:26,030
Só podes gardar tantos programas
RAM funcionando á vez, necesariamente, mesmo

1198
00:58:26,030 --> 00:58:29,360
coa memoria virtual, porque
ten unha cantidade finita de RAM.

1199
00:58:29,360 --> 00:58:31,990
>> E só para picture-- se
nunca abriu un portátil

1200
00:58:31,990 --> 00:58:34,300
ou encomendados memoria extra
para un ordenador,

1201
00:58:34,300 --> 00:58:36,670
Pode non saber que
dentro do seu ordenador

1202
00:58:36,670 --> 00:58:39,590
é algo que se parece
algo como isto.

1203
00:58:39,590 --> 00:58:43,540
Polo tanto, esta é só unha empresa común denominado
Crucial que fai RAM para ordenadores.

1204
00:58:43,540 --> 00:58:46,620
E RAM é onde os programas
vivir mentres eles están executando.

1205
00:58:46,620 --> 00:58:49,630
>> Así, en todos os Mac ou PC, cando dobrar
clic nun programa, e abre,

1206
00:58:49,630 --> 00:58:51,921
e abre un documento de Word
ou algo así,

1207
00:58:51,921 --> 00:58:54,764
almacena-o temporal na
RAM, RAM porque é máis rápido

1208
00:58:54,764 --> 00:58:56,680
que o seu disco duro, ou
o disco de estado sólido.

1209
00:58:56,680 --> 00:58:59,600
Entón é só onde os programas ir
para vivir cando están en execución,

1210
00:58:59,600 --> 00:59:01,060
ou cando os ficheiros están a ser empregados.

1211
00:59:01,060 --> 00:59:03,890
>> Entón tes cousas que parecen
como este no seu portátil,

1212
00:59:03,890 --> 00:59:06,320
ou cousas un pouco máis grande
dentro da súa área de traballo.

1213
00:59:06,320 --> 00:59:10,440
Pero a clave é que só ten un
número finito destas cousas.

1214
00:59:10,440 --> 00:59:14,230
E só hai unha cantidade finita de
hardware sentado nesa mesa dereita

1215
00:59:14,230 --> 00:59:14,730
aquí.

1216
00:59:14,730 --> 00:59:18,920
>> Entón, por suposto, non podemos almacenar
números infinitamente longos.

1217
00:59:18,920 --> 00:59:22,030
E, ademais, se pensas que volta a
escola, cantos díxitos pode

1218
00:59:22,030 --> 00:59:24,400
tes á dereita
dun punto decimal?

1219
00:59:24,400 --> 00:59:27,680
A esta materia, cantos díxitos poden
tes á esquerda do punto decimal?

1220
00:59:27,680 --> 00:59:29,300
Realmente, infinitamente moitos.

1221
00:59:29,300 --> 00:59:33,840
>> Agora, nós, seres humanos só podería
sabe como se pronuncia millóns,

1222
00:59:33,840 --> 00:59:37,990
e millóns, billóns, e
quatrilhões, e quintilhões.

1223
00:59:37,990 --> 00:59:42,370
E eu estou empurrando os límites do meu
understanding-- ou meu-- entendo

1224
00:59:42,370 --> 00:59:44,110
números, pero o meu
pronuncia dos números.

1225
00:59:44,110 --> 00:59:47,720
Pero poden obter infinitamente grande, con
infinitos díxitos á esquerda

1226
00:59:47,720 --> 00:59:50,050
ou á dereita dun punto decimal.

1227
00:59:50,050 --> 00:59:53,040
>> Pero os ordenadores teñen só un
cantidade finita de memoria,

1228
00:59:53,040 --> 00:59:56,510
un número finito de transistores, un
número finito de lámpadas no interior.

1229
00:59:56,510 --> 01:00:00,350
Entón, o que ocorre cando
executar para fóra do espazo?

1230
01:00:00,350 --> 01:00:02,620
Noutras palabras, se
pensar cara atrás a semana pasada

1231
01:00:02,620 --> 01:00:06,160
cando falamos números
-Se a ser representado en binario,

1232
01:00:06,160 --> 01:00:08,480
supoñamos que temos
este valor de 8 bits aquí.

1233
01:00:08,480 --> 01:00:11,290
>> E nós temos sete 1 e un 0.

1234
01:00:11,290 --> 01:00:13,827
E supoña que queremos
para engadir 1 a este valor.

1235
01:00:13,827 --> 01:00:15,410
Este é un número moi grande agora.

1236
01:00:15,410 --> 01:00:19,610
>> Este é 254, se ben me lembra
a matemática da semana pasada dereita.

1237
01:00:19,610 --> 01:00:22,480
Pero o que se eu cambiar
0 que máis á dereita dun 1?

1238
01:00:22,480 --> 01:00:25,800
O número enteiro, de
Por suposto, se converte oito 1s.

1239
01:00:25,800 --> 01:00:27,050
Polo tanto, aínda é bo.

1240
01:00:27,050 --> 01:00:30,204
>> E que probablemente representa
255, aínda que dependendo do contexto

1241
01:00:30,204 --> 01:00:32,120
podería realmente representar
un número negativo.

1242
01:00:32,120 --> 01:00:34,240
Pero máis sobre iso de novo.

1243
01:00:34,240 --> 01:00:37,220
Este parece que é
tan alto como podo contar.

1244
01:00:37,220 --> 01:00:38,290
>> Agora é só 8 bits.

1245
01:00:38,290 --> 01:00:41,170
E o meu Mac, con certeza, ten forma
máis de 8 bits de memoria.

1246
01:00:41,170 --> 01:00:42,170
Pero ten finito.

1247
01:00:42,170 --> 01:00:46,230
Así, o mesmo argumento aplícase, aínda que
temos máis destes queridos na pantalla.

1248
01:00:46,230 --> 01:00:50,020
>> Pero o que acontece se está
almacenar este número, 255,

1249
01:00:50,020 --> 01:00:52,290
e quere contar un pouco máis alto?

1250
01:00:52,290 --> 01:00:54,600
Queres ir de 255 a 256.

1251
01:00:54,600 --> 01:00:58,800
O problema, por suposto, é que se
comezar a contar desde cero como a semana pasada,

1252
01:00:58,800 --> 01:01:02,670
non pode contar como alto
como 256, moito menos 257,

1253
01:01:02,670 --> 01:01:05,584
moito menos 258, m porque o que
ocorre cando engade un 1?

1254
01:01:05,584 --> 01:01:08,000
Se fai a escola primaria antiga
visión, pór un 1 aquí,

1255
01:01:08,000 --> 01:01:11,150
e logo, 1 máis 1 e 2, pero iso é
realmente un cero, leva a 1,

1256
01:01:11,150 --> 01:01:12,695
transportar a 1, levar a 1.

1257
01:01:12,695 --> 01:01:15,620
Todas estas cousas,
Estas 1, ir a cero.

1258
01:01:15,620 --> 01:01:20,820
E acabar, si, como alguén
apuntou, a 1 sobre o lado esquerdo.

1259
01:01:20,820 --> 01:01:25,540
Pero todo o que poida
realmente ver e caber na memoria

1260
01:01:25,540 --> 01:01:30,960
é só oito 0 do, o que quere dicir
nalgún momento, se, un ordenador,

1261
01:01:30,960 --> 01:01:35,490
intentou conta alta abondo, está
vai implicar en torno a, ao parecer,

1262
01:01:35,490 --> 01:01:38,850
a cero, ou quizais mesmo negativo
números, que son aínda máis baixos que cero.

1263
01:01:38,850 --> 01:01:40,260
>> E pode tipo de ver iso.

1264
01:01:40,260 --> 01:01:42,900
Deixe-me ir adiante e escribir
un verdadeiro programa rápido aquí.

1265
01:01:42,900 --> 01:01:46,690
Deixe-me ir adiante e escribir
un programa chamado estourido.

1266
01:01:46,690 --> 01:01:52,980
Incluír CS50.h, inclúen
estándar IO.h-- oh,

1267
01:01:52,980 --> 01:01:54,730
Realmente perdín o meu destaque de sintaxe.

1268
01:01:54,730 --> 01:01:57,440
Entón, imos gardalo como overflow.c.

1269
01:01:57,440 --> 01:02:00,084
>> E void-- principal agora int
e en pouco tempo, imos

1270
01:02:00,084 --> 01:02:02,500
volver explicar por que
nós seguir a escribir void main int.

1271
01:02:02,500 --> 01:02:05,080
Pero, polo de agora, imos só facer
Lo, leva-lo para concedida.

1272
01:02:05,080 --> 01:02:09,200
Imos dar-me un int,
e Inicialize-o a 0.

1273
01:02:09,200 --> 01:02:14,716
>> Imos entón facer por int i obter zero--
en realidade, imos facer un loop infinito

1274
01:02:14,716 --> 01:02:15,590
e ver que pasa.

1275
01:02:15,590 --> 01:02:25,440
Mentres verdade, entón imos imprimir n
é por cento i, barra invertida n, plugin n.

1276
01:02:25,440 --> 01:02:30,200
Pero, agora, imos facer n recibe n + 1.

1277
01:02:30,200 --> 01:02:32,660
>> Polo tanto, noutras palabras, en cada
iteración deste ciclo infinito,

1278
01:02:32,660 --> 01:02:35,550
imos dar o valor de n,
e engadir 1 a el, e, a continuación,

1279
01:02:35,550 --> 01:02:37,350
almacenar o resultado en N na esquerda.

1280
01:02:37,350 --> 01:02:40,150
E, de feito, xa vimos a sintaxe
algo como este, brevemente.

1281
01:02:40,150 --> 01:02:42,730
Un truco legal é, en vez
de escribir todo isto,

1282
01:02:42,730 --> 01:02:45,770
realmente pode dicir un n máis é igual a 1.

1283
01:02:45,770 --> 01:02:50,480
>> Ou se o quere ser extravagante,
pode dicir n plus plus e coma.

1284
01:02:50,480 --> 01:02:53,130
Pero estes dous últimos son só
o que chamaría de azucre sintático

1285
01:02:53,130 --> 01:02:53,790
para o primeiro.

1286
01:02:53,790 --> 01:02:56,456
>> O primeiro é máis explícito,
totalmente ben, totalmente correcta.

1287
01:02:56,456 --> 01:02:58,470
Pero iso é máis común, eu vou dicir.

1288
01:02:58,470 --> 01:03:00,210
Entón, imos facelo por só un momento.

1289
01:03:00,210 --> 01:03:04,685
>> Imos agora facer estourido, o que soa
moi sinistro, estourido de corte de punto.

1290
01:03:04,685 --> 01:03:07,380

1291
01:03:07,380 --> 01:03:12,852
Imos ver, n está quedando moi grande.

1292
01:03:12,852 --> 01:03:14,310
Pero imos pensar, o no; gran pode n recibir?

1293
01:03:14,310 --> 01:03:15,870
>> n é un número enteiro.

1294
01:03:15,870 --> 01:03:19,400
Vimos hai pouco co tamaño do
exemplo, que é un int catro bytes.

1295
01:03:19,400 --> 01:03:25,070
Sabemos da semana pasada, catro bytes é
32 bits, xa 8 veces 4, que ten 32 anos.

1296
01:03:25,070 --> 01:03:26,460
Isto vai ser de 4 millóns.

1297
01:03:26,460 --> 01:03:28,802
>> E somos ata 800.000.

1298
01:03:28,802 --> 01:03:31,510
Isto vai levar unha eternidade para
contar tan alto como poida.

1299
01:03:31,510 --> 01:03:33,635
Entón, eu estou indo para adiante,
como pode en pouco tempo,

1300
01:03:33,635 --> 01:03:37,910
e bateu C-- Control francamente, Control
C, unha morea, onde Control C xeral

1301
01:03:37,910 --> 01:03:39,034
medios cancelar.

1302
01:03:39,034 --> 01:03:41,200
Desafortunadamente, porque este
está a ser executado na nube,

1303
01:03:41,200 --> 01:03:44,190
por veces, a nube é
cuspindo tanta cousa,

1304
01:03:44,190 --> 01:03:47,180
tanta saída, que vai
levar un pouco para a miña entrada

1305
01:03:47,180 --> 01:03:48,630
para chegar á nube.

1306
01:03:48,630 --> 01:03:52,240
Así, aínda que eu bati
Control C uns segundos atrás,

1307
01:03:52,240 --> 01:03:56,110
este é sempre o lado
efecto dun loop infinito.

1308
01:03:56,110 --> 01:03:59,070
>> E así, en tales casos, estamos
vai deixar que sexa.

1309
01:03:59,070 --> 01:04:02,050
E nós estamos indo para engadir outro
fiestra de terminal aquí

1310
01:04:02,050 --> 01:04:06,186
co plus, que naturalmente non fai
así, xa que aínda está a pensar.

1311
01:04:06,186 --> 01:04:08,310
E imos adiante e ser
algo máis razoable.

1312
01:04:08,310 --> 01:04:10,768
>> Eu estou indo a ir adiante e facer
esta única un número finito de veces.

1313
01:04:10,768 --> 01:04:13,047
Imos usar un loop for,
que aludi anteriormente.

1314
01:04:13,047 --> 01:04:13,630
Imos facelo.

1315
01:04:13,630 --> 01:04:16,430
Déame outra variable int i recibe 0.

1316
01:04:16,430 --> 01:04:20,430
i é menor que, digamos, 64 i ++.

1317
01:04:20,430 --> 01:04:27,010
E agora déixeme ir adiante e de impresión
a n é por cento i, coma n.

1318
01:04:27,010 --> 01:04:30,547
E entón n-- este aínda é
vai levar para sempre.

1319
01:04:30,547 --> 01:04:31,130
Imos facelo.

1320
01:04:31,130 --> 01:04:33,620
>> n recibe n veces 2.

1321
01:04:33,620 --> 01:04:37,140
Ou poderiamos ser extravagante
e facer veces é igual a 2.

1322
01:04:37,140 --> 01:04:40,120
Pero imos só dicir que n
iguala-se, 2 veces.

1323
01:04:40,120 --> 01:04:42,321
Noutras palabras, o presente
nova versión do programa,

1324
01:04:42,321 --> 01:04:44,820
Non quero esperar para sempre
de como 800.000 para 4 millóns.

1325
01:04:44,820 --> 01:04:46,070
Nós só acabar con iso.

1326
01:04:46,070 --> 01:04:47,920
>> Imos realmente dobrar n cada vez.

1327
01:04:47,920 --> 01:04:50,660
Que, recall, duplicación é a
contrario de ter, por suposto.

1328
01:04:50,660 --> 01:04:53,035
E que a semana pasada temos
algo máis dunha vez, e de novo,

1329
01:04:53,035 --> 01:04:55,200
e, de novo, super rápido,
duplicación certamente

1330
01:04:55,200 --> 01:05:01,080
levar de 1 a maior posible
valor que podemos contar ata con un int.

1331
01:05:01,080 --> 01:05:02,750
>> Entón, imos facer exactamente isto.

1332
01:05:02,750 --> 01:05:04,720
E nós imos voltar a este antes de tempo.

1333
01:05:04,720 --> 01:05:07,180
Pero iso, de novo, é como
o bloque de repetición en perigo.

1334
01:05:07,180 --> 01:05:08,600
E vai usar este antes de tempo.

1335
01:05:08,600 --> 01:05:13,170
>> Isto só significa conta de cero
ata, pero non igual, a 64.

1336
01:05:13,170 --> 01:05:17,285
E en cada iteración deste
loop, só manter incrementando i.

1337
01:05:17,285 --> 01:05:21,990
Entón i ++ - e esta construción xeral
na liña 7 é só un xeito super común

1338
01:05:21,990 --> 01:05:25,290
repetir algunhas liñas de
código, un certo número de veces.

1339
01:05:25,290 --> 01:05:26,362
Cales liñas de código?

1340
01:05:26,362 --> 01:05:28,570
Estas claves, como
Pode ter adquirido a partir de agora,

1341
01:05:28,570 --> 01:05:29,780
significa, faga o seguinte.

1342
01:05:29,780 --> 01:05:32,510
>> É dentro como cero, cando
ten os bloques amarelos

1343
01:05:32,510 --> 01:05:35,680
e outras cores que tipo de
abrazar ou abrazar outros bloques.

1344
01:05:35,680 --> 01:05:37,750
Iso é o que estes rizado
cintas están facendo aquí.

1345
01:05:37,750 --> 01:05:43,200
Entón, se eu teño o meu sintaxe direita-- vostede
Pode ver o símbolo de cenoria no medio C

1346
01:05:43,200 --> 01:05:45,706
iso é cantas veces eu estaba
intentando solucionar este problema.

1347
01:05:45,706 --> 01:05:48,330
Entón, imos librar-se de que un
por completo, e pecha a fiestra.

1348
01:05:48,330 --> 01:05:49,520
E nós imos usar o novo.

1349
01:05:49,520 --> 01:05:54,980
Fai estourido, Slash dot
estourido, Intro, todo ben,

1350
01:05:54,980 --> 01:05:56,090
parece mal no comezo.

1351
01:05:56,090 --> 01:05:59,200
Pero imos rolar para atrás no tempo,
porque eu fixen iso 64 veces.

1352
01:05:59,200 --> 01:06:01,700
>> E observar por primeira vez, n é 1.

1353
01:06:01,700 --> 01:06:06,110
Segundo tempo, o símbolo n representa 2,
logo, 4, despois 8, entón con 16 anos.

1354
01:06:06,110 --> 01:06:12,450
E parece que así
Chegar a preto de 1 mil millóns,

1355
01:06:12,450 --> 01:06:15,800
se eu dobre-la de novo, que
debería darme 2 millóns.

1356
01:06:15,800 --> 01:06:17,980
Pero acontece, é
dereito na cúspide.

1357
01:06:17,980 --> 01:06:21,930
>> E así el realmente reborda
un enteiro de 1 billón

1358
01:06:21,930 --> 01:06:26,514
a preto de 2 negativo
millóns, porque un número enteiro,

1359
01:06:26,514 --> 01:06:28,430
ao contrario do que números
foron asumindo a semana pasada,

1360
01:06:28,430 --> 01:06:31,397
pode ser tanto positivo como negativo
en realidade, e nun ordenador.

1361
01:06:31,397 --> 01:06:33,730
E así, polo menos, un destes
bits é eficaz roubado.

1362
01:06:33,730 --> 01:06:37,190
Entón, nós realmente só ten 31 bits,
ou 2 mil millóns de valores.

1363
01:06:37,190 --> 01:06:41,220
>> Pero, por agora, o takeaway é moi
simplemente, calquera que sexan estes números son

1364
01:06:41,220 --> 01:06:45,280
e todo o que a matemática é,
algo malo acontece, finalmente,

1365
01:06:45,280 --> 01:06:49,980
porque finalmente estás
permutar os bits dun miúdo.

1366
01:06:49,980 --> 01:06:54,060
E efectivamente ir de todo
1 de quizais para todo 0 do, ou que

1367
01:06:54,060 --> 01:06:57,260
só algún outro estándar que
Claramente, dependendo do contexto,

1368
01:06:57,260 --> 01:06:59,342
pode ser interpretado como un número negativo.

1369
01:06:59,342 --> 01:07:02,300
E así parece o máis alto I
pode contar neste programa específico

1370
01:07:02,300 --> 01:07:04,210
é só a preto de 1 mil millóns.

1371
01:07:04,210 --> 01:07:05,760
Pero hai unha solución parcial aquí.

1372
01:07:05,760 --> 01:07:06,480
Vostede sabe o que?

1373
01:07:06,480 --> 01:07:10,600
>> Déixeme cambiar a partir dun
int para un longo tempo.

1374
01:07:10,600 --> 01:07:13,633
E deixe-me ir adiante aquí
e dizer-- eu vou ter

1375
01:07:13,633 --> 01:07:15,290
para cambiar isto para un sen sinatura longo.

1376
01:07:15,290 --> 01:07:19,860
Ou, imos ver, eu nunca me lembrar.

1377
01:07:19,860 --> 01:07:22,920
>> Imos adiante e facer rebosar.

1378
01:07:22,920 --> 01:07:24,860
Non, non é iso, LLD, grazas.

1379
01:07:24,860 --> 01:07:26,430
Entón, ás veces Clang pode ser útil.

1380
01:07:26,430 --> 01:07:30,550
Eu non me lembro o que o formato
especificador foi por moito tempo.

1381
01:07:30,550 --> 01:07:31,950
>> Pero, en realidade, Clang díxome.

1382
01:07:31,950 --> 01:07:34,570
O verde é unha especie de bo,
aínda significa que cometeu un erro.

1383
01:07:34,570 --> 01:07:36,190
É supoñendo que eu quería dicir LLD.

1384
01:07:36,190 --> 01:07:41,750
>> Entón deixe-me leva-la é un consello, un longo
longa número decimal, gardar isto.

1385
01:07:41,750 --> 01:07:46,190
E déixeme executa-lo de novo, dot
cortar exceso, Intro.

1386
01:07:46,190 --> 01:07:48,020
E agora o que é legal é iso.

1387
01:07:48,020 --> 01:07:52,140
>> Se eu rolar para atrás no tempo, aínda comezar
contando ao mesmo Place-- 1, 2, 4,

1388
01:07:52,140 --> 01:07:53,220
8, 16.

1389
01:07:53,220 --> 01:07:57,860
Aviso, temos todo o
camiño ata 1 billón.

1390
01:07:57,860 --> 01:08:00,070
Pero, entón, chegar con seguridade ao 2 millóns.

1391
01:08:00,070 --> 01:08:04,300
>> Entón comezamos a 4 millóns,
logo 8 millóns, 17 millóns.

1392
01:08:04,300 --> 01:08:06,340
E nós ir máis alto, e
maior, e máis altos.

1393
01:08:06,340 --> 01:08:08,740
Finalmente, tanto, tamén, saltos.

1394
01:08:08,740 --> 01:08:12,350
>> Finalmente, con un longo tempo,
que é o valor de 64 bits, non

1395
01:08:12,350 --> 01:08:16,660
un valor de 32 bits, se contar
moi alto, participa en torno a 0.

1396
01:08:16,660 --> 01:08:19,410
E neste caso, nós pasar
acabar con un número negativo.

1397
01:08:19,410 --> 01:08:20,550
>> Polo tanto, este é un problema.

1398
01:08:20,550 --> 01:08:23,439
E verifícase que este
problema non é todo o que arcano.

1399
01:08:23,439 --> 01:08:26,060
Aínda que eu teña deliberadamente
inducida con estes erros,

1400
01:08:26,060 --> 01:08:29,149
verifícase se vemos que tipo de todo
nós, ou polo menos algúns de nós en torno a facer.

1401
01:08:29,149 --> 01:08:31,939
>> Así, en Lego Star Wars, se
xa xogou o xogo,

1402
01:08:31,939 --> 01:08:36,830
verifícase que pode ir ao redor
rompendo as cousas no mundo LEGO,

1403
01:08:36,830 --> 01:08:39,640
e recollida de moedas, esencialmente.

1404
01:08:39,640 --> 01:08:42,200
E se nunca xogou
este xogo xeito moito tempo,

1405
01:08:42,200 --> 01:08:45,630
como este individuo non identificado
aquí fixeron, o número total

1406
01:08:45,630 --> 01:08:49,700
de moedas que pode recoller
é, ao parecer, 4 millóns.

1407
01:08:49,700 --> 01:08:51,240
>> Agora, con el é realmente redondeados.

1408
01:08:51,240 --> 01:08:53,239
Entón LEGO estaba tentando
manter as cousas agradable.

1409
01:08:53,239 --> 01:08:56,779
Non facelo exactamente 2 a
a 32 de alimentación, por semana pasada.

1410
01:08:56,779 --> 01:08:58,310
Pero 4 millóns é unha razón.

1411
01:08:58,310 --> 01:09:01,979
Parece, con base nesas informacións,
que LEGO, ea empresa que

1412
01:09:01,979 --> 01:09:05,624
fixo este software real, decidiu
que o número máximo de moedas

1413
01:09:05,624 --> 01:09:07,540
o usuario pode acumular
é, en realidade, 4 millóns,

1414
01:09:07,540 --> 01:09:15,069
porque escolleron o seu código
usar non moito tempo, ao parecer,

1415
01:09:15,069 --> 01:09:19,140
pero só un enteiro, un sen sinatura
enteiro, só a un número enteiro positivo, cuxa

1416
01:09:19,140 --> 01:09:21,089
valor máximo aproximadamente iso.

1417
01:09:21,089 --> 01:09:22,380
Ben, aquí está un divertido.

1418
01:09:22,380 --> 01:09:26,500
Así, no xogo Civilization, que
algúns de vostedes poden estar familiarizados coa

1419
01:09:26,500 --> 01:09:29,660
verifícase que anos atrás non
era un erro neste partido no que

1420
01:09:29,660 --> 01:09:31,750
se desempeñou o papel
de Gandhi no xogo,

1421
01:09:31,750 --> 01:09:37,020
no canto de que sexa moi pacifista,
no seu lugar foi incrible, incrible

1422
01:09:37,020 --> 01:09:39,399
agresivo, nalgunhas circunstancias.

1423
01:09:39,399 --> 01:09:43,529
En particular, a forma que a civilización
obras é que se o xogador,

1424
01:09:43,529 --> 01:09:47,680
adoptar a democracia, o
puntuación de agresividade queda

1425
01:09:47,680 --> 01:09:51,130
diminuíu en dous, de xeito menos
menos, e despois de menos de menos.

1426
01:09:51,130 --> 01:09:53,569
>> Entón restar 2
súa iteración actual.

1427
01:09:53,569 --> 01:09:59,650
Desafortunadamente, a súa iteración é
inicialmente 1, e restar 2 a partir del

1428
01:09:59,650 --> 01:10:02,050
despois de adoptar a democracia
como Gandhi aquí pode

1429
01:10:02,050 --> 01:10:05,200
ter feito, porque era moi passive--
1 na escala de agresividade.

1430
01:10:05,200 --> 01:10:07,830
Pero se adopta a democracia, a continuación,
vai de 1 a 1 negativo.

1431
01:10:07,830 --> 01:10:14,470
>> Desafortunadamente, eles eran
usando números non asinados,

1432
01:10:14,470 --> 01:10:18,400
o que significa que eles trataron mesmo negativo
números como se fosen positivos.

1433
01:10:18,400 --> 01:10:22,780
E verifícase que o
equivalente positivo do negativo 1,

1434
01:10:22,780 --> 01:10:26,480
en programas de ordenador típicos, é de 255.

1435
01:10:26,480 --> 01:10:30,250
Entón, se Gandhi adopta
democracia e, polo tanto, ten

1436
01:10:30,250 --> 01:10:35,470
súa puntuación agresividade diminuíu,
realmente rula ao redor de 255

1437
01:10:35,470 --> 01:10:38,470
e faino o máis
carácter agresivo no xogo.

1438
01:10:38,470 --> 01:10:39,930
Entón podes Google-se sobre este asunto.

1439
01:10:39,930 --> 01:10:42,380
E foi, de feito, unha
erro de programación accidental,

1440
01:10:42,380 --> 01:10:46,010
pero iso entrou moi
a tradición desde entón.

1441
01:10:46,010 --> 01:10:47,360
>> Isto é todo o desfrute e bonito.

1442
01:10:47,360 --> 01:10:50,760
Máis asustado é cando real
dispositivos do mundo real, e non xogos,

1443
01:10:50,760 --> 01:10:51,820
ter eses mesmos erros.

1444
01:10:51,820 --> 01:10:57,500
De feito, só un ano, un artigo veu
-se sobre o Boeing 787 Dreamliner.

1445
01:10:57,500 --> 01:10:59,850
>> E o artigo en primeiro
ollar le algo misterioso.

1446
01:10:59,850 --> 01:11:04,480
Pero dito isto, un programa
vulnerabilidade no Boeing

1447
01:11:04,480 --> 01:11:07,790
novo 787 Dreamliner chorro ten
o potencial de causar pilotos

1448
01:11:07,790 --> 01:11:10,220
perder o control de
da aeronave, finalmente

1449
01:11:10,220 --> 01:11:14,750
a mediados de voo, os funcionarios da FAA
compañías aéreas advertiu recentemente.

1450
01:11:14,750 --> 01:11:17,520
Foi a determinación
que un modelo 787

1451
01:11:17,520 --> 01:11:22,770
avión que foi alimentado
continuamente durante 248 días

1452
01:11:22,770 --> 01:11:27,880
Pode perder toda a corrente alterna, AC,
enerxía eléctrica debido ao xerador

1453
01:11:27,880 --> 01:11:31,892
unidades de control, GCUs, simultaneamente
indo para deixar modo de seguridade.

1454
01:11:31,892 --> 01:11:32,850
É unha especie de me perder.

1455
01:11:32,850 --> 01:11:38,390
Pero o memorando afirmou, OK, agora eu teño que,
a condición foi causado por un programa

1456
01:11:38,390 --> 01:11:41,590
contador interno para
o control do xerador

1457
01:11:41,590 --> 01:11:47,860
unidades que vai rebosar despois
248 días de potencia continua.

1458
01:11:47,860 --> 01:11:50,070
Estamos a emisión do presente
aviso para evitar a perda

1459
01:11:50,070 --> 01:11:52,300
de todos AC eléctricos
poder, o que podería resultar

1460
01:11:52,300 --> 01:11:53,980
perda de control do avión.

1461
01:11:53,980 --> 01:11:58,380
>> Así, literalmente, existe algún enteiro,
ou algún tipo de datos equivalente,

1462
01:11:58,380 --> 01:12:00,960
sendo utilizado en software
nun avión real

1463
01:12:00,960 --> 01:12:03,756
que se manter o seu avión
en tempo suficiente, o que, ao parecer,

1464
01:12:03,756 --> 01:12:06,880
pode ser o caso se está só a executar
Los constantemente e nunca apagar

1465
01:12:06,880 --> 01:12:09,810
o avión, ao parecer, é
deixando as súas baterías morrer,

1466
01:12:09,810 --> 01:12:12,840
acabará contar-se, e para arriba,
e cara arriba, e para arriba, e para arriba, e cara arriba.

1467
01:12:12,840 --> 01:12:15,150
>> E, por natureza, un
cantidade finita de memoria

1468
01:12:15,150 --> 01:12:18,880
transbordára, rolando ao
cero ou algún valor negativo,

1469
01:12:18,880 --> 01:12:22,920
efectos secundarios das cales é a
realidade assustadoramente reais

1470
01:12:22,920 --> 01:12:26,970
que o avión pode ter
de reiniciar, efectivamente,

1471
01:12:26,970 --> 01:12:30,290
ou pode caer, peor, como voa.

1472
01:12:30,290 --> 01:12:32,230
Entón, eses tipos de problemas
aínda están entre nós,

1473
01:12:32,230 --> 01:12:36,130
even-- este foi un artigo de 2015,
todo o máis asustado

1474
01:12:36,130 --> 01:12:39,100
cando non fai necesariamente
entender, apreciar, é anticipar

1475
01:12:39,100 --> 01:12:41,640
estes tipos de erros.

1476
01:12:41,640 --> 01:12:45,030
>> Non é que hai outra
algo malo sobre representación de datos.

1477
01:12:45,030 --> 01:12:50,080
Acontece que mesmo os coches alegóricos son
tipo de fallo, porque flotadores, tamén,

1478
01:12:50,080 --> 01:12:54,440
Propuxen son 32 bits, ou
quizais 64 se usa unha parella.

1479
01:12:54,440 --> 01:12:56,070
Pero iso aínda é finito.

1480
01:12:56,070 --> 01:13:00,070
>> E o problema é que se poida
poñer un número infinito de números

1481
01:13:00,070 --> 01:13:02,460
despois do punto decimal,
non hai ningunha maneira que

1482
01:13:02,460 --> 01:13:05,690
Pode representar as posibles
números que foron ensino

1483
01:13:05,690 --> 01:13:07,990
no grao escola pode existir no mundo.

1484
01:13:07,990 --> 01:13:11,870
Un ordenador, esencialmente, ten a
escoller un subconxunto destes números

1485
01:13:11,870 --> 01:13:13,200
para representar con precisión.

1486
01:13:13,200 --> 01:13:15,450
>> Agora, o ordenador pode
rolda quizais un pouco,

1487
01:13:15,450 --> 01:13:20,900
e pode permitir-lle uns tenda
calquera número que pode querer.

1488
01:13:20,900 --> 01:13:23,940
Pero só intuitivamente, se
teñen un número finito de bits,

1489
01:13:23,940 --> 01:13:27,560
só se pode permutar a eles
en tantas formas finitas.

1490
01:13:27,560 --> 01:13:29,570
Entón non pode posiblemente
teñen un número finito

1491
01:13:29,570 --> 01:13:32,880
de intercambio de bits,
patróns de ceros e uns,

1492
01:13:32,880 --> 01:13:35,940
para representar un infinito
número de números,

1493
01:13:35,940 --> 01:13:40,370
o que suxire que computadores poden
moi ben ser mentindo para nós ás veces.

1494
01:13:40,370 --> 01:13:41,770
>> De feito, imos facelo.

1495
01:13:41,770 --> 01:13:44,239
Déixeme volver IDE CS50.

1496
01:13:44,239 --> 01:13:46,030
Deixe-me ir adiante e
crear un programiña

1497
01:13:46,030 --> 01:13:50,940
chamada imprecisión, para amosar que
os ordenadores son, de feito, imprecisa.

1498
01:13:50,940 --> 01:13:54,910
>> E deixe-me ir adiante e comezar
algúns de que o código de antes,

1499
01:13:54,910 --> 01:13:56,830
e agora pode facer o seguinte.

1500
01:13:56,830 --> 01:14:06,640
Deixe-me ir adiante e facer printf, cento
f, barra invertida n, 1 dividido por 10.

1501
01:14:06,640 --> 01:14:10,430
Noutras palabras, imos mergullar no máis profundo
a 1/10, como 1 e dividida por 10.

1502
01:14:10,430 --> 01:14:12,760
Certamente, un ordenador pode representar 1/10.

1503
01:14:12,760 --> 01:14:16,620
>> Entón, imos adiante e facer imprecisión.

1504
01:14:16,620 --> 01:14:17,390
Vexamos.

1505
01:14:17,390 --> 01:14:19,210
Format especifica o tipo de matrimonio.

1506
01:14:19,210 --> 01:14:21,160
Pero o argumento ten o tipo int.

1507
01:14:21,160 --> 01:14:22,040
Que está pasando?

1508
01:14:22,040 --> 01:14:24,970
>> Oh, interesante, polo que é unha
lección aprendida de antes.

1509
01:14:24,970 --> 01:14:29,050
Eu digo, hey, feira de informática
me un flotador con cento f.

1510
01:14:29,050 --> 01:14:31,200
Pero eu estou dándolle 2 ints.

1511
01:14:31,200 --> 01:14:34,120
Así, ao parecer, podo solucionar
isto nun par de formas.

1512
01:14:34,120 --> 01:14:41,430
>> Podería simplemente transformar un 1.0, e
10 para 10,0, o que, de feito,

1513
01:14:41,430 --> 01:14:45,390
ten o efecto de converter
Los en floats-- aínda espero

1514
01:14:45,390 --> 01:14:46,180
o mesmo número.

1515
01:14:46,180 --> 01:14:48,880
Ou se ve que hai algo
veremos de novo en pouco tempo.

1516
01:14:48,880 --> 01:14:50,170
Podería publicar os números.

1517
01:14:50,170 --> 01:14:52,880
>> Pode, usando este parénteses
expresión, pode dicir,

1518
01:14:52,880 --> 01:14:55,560
hey, ordenador, aproveitar esta
10, que sei que é un int.

1519
01:14:55,560 --> 01:14:57,660
Pero trata-lo, por favor,
como se fose unha boia.

1520
01:14:57,660 --> 01:14:59,680
Pero iso parece innecesarios complexa.

1521
01:14:59,680 --> 01:15:02,040
>> Para os nosos propósitos hoxe,
imos só literalmente

1522
01:15:02,040 --> 01:15:05,700
facelos valores de punto flotante
cun punto decimal, como este.

1523
01:15:05,700 --> 01:15:10,060
Deixe-me ir adiante e volva executar, faga
imprecisión, bo, barra dot

1524
01:15:10,060 --> 01:15:11,870
imprecisión, entrar.

1525
01:15:11,870 --> 01:15:13,990
OK, nós estamos mirando bo.

1526
01:15:13,990 --> 01:15:21,194
>> 1 dividida por 10, segundo o meu
Mac aquí, é, de feito, 0,100 mil.

1527
01:15:21,194 --> 01:15:24,360
Agora, eu fun ensina na escola hai
debe ser un número infinito de 0 do.

1528
01:15:24,360 --> 01:15:26,151
Entón, imos polo menos tentar
para ver algunhas delas.

1529
01:15:26,151 --> 01:15:29,770
Acontece que printf é algo
aínda máis extravagante que temos benvida a empregar.

1530
01:15:29,770 --> 01:15:33,890
Acontece que non ten que especificar
simplemente por cento f, ou simplemente por cento i.

1531
01:15:33,890 --> 01:15:36,830
Realmente pode especificar
algunhas opcións de control aquí.

1532
01:15:36,830 --> 01:15:39,470
>> En concreto, eu estou indo
para dicir, hey, printf,

1533
01:15:39,470 --> 01:15:42,660
realmente amosar-me 10 puntos decimais.

1534
01:15:42,660 --> 01:15:43,820
Polo tanto, parece un pouco raro.

1535
01:15:43,820 --> 01:15:45,845
Pero di por cento,
punto, cantos números

1536
01:15:45,845 --> 01:15:47,970
quere ver tralo
punto decimal e logo f

1537
01:15:47,970 --> 01:15:51,340
para plana, só porque é
o que di a documentación.

1538
01:15:51,340 --> 01:15:53,080
Deixe-me ir adiante e gardar ese.

1539
01:15:53,080 --> 01:15:55,460
>> E teña en conta tamén, eu estou a recibir
canso de ter que redigitar as cousas.

1540
01:15:55,460 --> 01:15:58,900
Entón, eu estou só definir o para arriba e
frecha para abaixo en miñas claves aquí.

1541
01:15:58,900 --> 01:16:01,710
E se eu mantéñome bater-se,
Pode ver todos os comandos

1542
01:16:01,710 --> 01:16:04,090
que eu fixen, ou feita de forma incorrecta.

1543
01:16:04,090 --> 01:16:07,630
>> E eu estou indo a ir adiante agora e
Non realmente usar que, ao parecer.

1544
01:16:07,630 --> 01:16:14,416
Fai imprecisión, dot
cortar imprecision-- así

1545
01:16:14,416 --> 01:16:16,290
o que se ensina na
escola primaria confire.

1546
01:16:16,290 --> 01:16:22,010
Aínda que eu imprimir lo a 10 decimal
pon, de feito, é 0,10000.

1547
01:16:22,010 --> 01:16:22,840
Pero vostede sabe o que?

1548
01:16:22,840 --> 01:16:24,150
>> Imos estar un pouco ganancioso.

1549
01:16:24,150 --> 01:16:26,990
Digamos que, como, mostre-me 55
puntos tras o decimal.

1550
01:16:26,990 --> 01:16:29,160
Imos realmente tomar esta
programar para dar unha volta.

1551
01:16:29,160 --> 01:16:34,170
Déixeme refacelo lo co make
imprecisión, barra punto, imprecisión.

1552
01:16:34,170 --> 01:16:35,390
>> E aquí imos nós.

1553
01:16:35,390 --> 01:16:37,420
A súa infancia foi unha mentira.

1554
01:16:37,420 --> 01:16:51,410
Ao parecer, 1 dividido por 10 é efectivamente
0.100000000000000005551115123--

1555
01:16:51,410 --> 01:16:52,740
>> Que pasa?

1556
01:16:52,740 --> 01:16:56,360
Ben, ao parecer, se tipo de
mirar lonxe o suficiente na subxacente

1557
01:16:56,360 --> 01:16:58,950
representación do presente
número, realmente

1558
01:16:58,950 --> 01:17:03,400
Non é exactamente 10/01, ou 0,1 e
un número infinito de ceros.

1559
01:17:03,400 --> 01:17:04,630
Agora, por que isto?

1560
01:17:04,630 --> 01:17:09,250
>> Ben, aínda que esta é unha simple
número para nós seres humanos, 1 dividido por 10,

1561
01:17:09,250 --> 01:17:13,910
aínda é un dos infinitos
números que poderiamos imaxinar.

1562
01:17:13,910 --> 01:17:17,490
Pero un ordenador só pode representar
un número finito de números así.

1563
01:17:17,490 --> 01:17:21,710
E así, de forma eficaz, o que o
ordenador está nos amosando é o seu máis próximo

1564
01:17:21,710 --> 01:17:25,940
aproximación ao número
queremos crer é 1/10,

1565
01:17:25,940 --> 01:17:30,760
ou realmente 0,10000 ad infinitum.

1566
01:17:30,760 --> 01:17:33,425
>> Pola contra, porén, este é
tan preto que pode chegar.

1567
01:17:33,425 --> 01:17:35,300
E, de feito, se ollar
por baixo da capa,

1568
01:17:35,300 --> 01:17:40,050
como estamos aquí examinando
55 díxitos tras o decimal,

1569
01:17:40,050 --> 01:17:42,990
realmente vemos que a realidade.

1570
01:17:42,990 --> 01:17:45,610
Agora, como un aparte, se ten
Xa viu o movie--

1571
01:17:45,610 --> 01:17:48,780
a maioría de vostedes probablemente haven't--
pero Superman 3 hai uns anos,

1572
01:17:48,780 --> 01:17:52,500
Richard Pryor esencialmente panca este
realidade na súa empresa para roubar unha morea

1573
01:17:52,500 --> 01:17:56,500
de fraccións e as fraccións de centavos,
porque o company-- se ben me lembra,

1574
01:17:56,500 --> 01:18:00,210
foi un while-- era esencialmente
xogando fóra todo o que non se encaixa

1575
01:18:00,210 --> 01:18:01,790
na noción de centavos.

1576
01:18:01,790 --> 01:18:04,480
>> Pero se sumar todos estes
minúsculos, minúsculo, minúsculos números unha vez máis,

1577
01:18:04,480 --> 01:18:07,960
e de novo, e de novo, pode, como en
seu caso, facer unha boa cantidade de diñeiro.

1578
01:18:07,960 --> 01:18:11,010
>> Esa mesma idea foi roubado por
unha última, senón que agora máis vellos

1579
01:18:11,010 --> 01:18:13,500
película, chamado Office Space,
onde os mozos que a película,

1580
01:18:13,500 --> 01:18:16,501
fixo o mesmo, estraguei todo
completo, acabou coa forma demasiado

1581
01:18:16,501 --> 01:18:17,666
diñeiro da súa conta bancaria.

1582
01:18:17,666 --> 01:18:18,800
Foi todo moi sospeitoso.

1583
01:18:18,800 --> 01:18:22,290
Con todo, ao final do día,
imprecisión está ao noso arredor.

1584
01:18:22,290 --> 01:18:25,240
>> E que, ademais, se pode
assustadoramente o caso.

1585
01:18:25,240 --> 01:18:28,590
Acontece que Superman 3
e espazo de oficinas de lado, hai

1586
01:18:28,590 --> 01:18:31,460
Pode haber algún moi real
ramificacións mundiais

1587
01:18:31,460 --> 01:18:35,290
das realidades da imprecisa
representación de datos

1588
01:18:35,290 --> 01:18:37,770
que mesmo nós, humanos, a
este día non necesariamente

1589
01:18:37,770 --> 01:18:41,230
entender así como deberiamos,
ou lembrar tan frecuentemente como debería.

1590
01:18:41,230 --> 01:18:45,950
E, de feito, o clip seguinte
Bótalle un ollo a algúns mundo moi real

1591
01:18:45,950 --> 01:18:50,730
ramificacións do que pasa se
non aprecian a imprecisión que

1592
01:18:50,730 --> 01:18:53,065
pode ocorrer en números representación.

1593
01:18:53,065 --> 01:18:54,300
>> [Reprodución de vídeo]

1594
01:18:54,300 --> 01:18:58,620
>> -Computadores, Todos temos que chegou a aceptar
os problemas que moitas veces frustrante

1595
01:18:58,620 --> 01:19:03,310
ir con eles-- erros, virus,
e fallos de software,

1596
01:19:03,310 --> 01:19:06,130
para pequenos prezos a pagar
para o barrio.

1597
01:19:06,130 --> 01:19:10,800
Pero, en alta tecnoloxía e alta velocidade
aplicacións do programa espacial e militares,

1598
01:19:10,800 --> 01:19:15,800
menor problema pode
ser ampliada para o desastre.

1599
01:19:15,800 --> 01:19:21,900
>> O 04 de xuño de 1996, os científicos preparados
para lanzar un non tripulado Ariane 5 foguete.

1600
01:19:21,900 --> 01:19:24,220
Estaba cargando científica
satélites deseñados

1601
01:19:24,220 --> 01:19:27,600
para establecer con precisión o xeito no que o
interactúa campo magnético da Terra

1602
01:19:27,600 --> 01:19:30,410
con ventos solares.

1603
01:19:30,410 --> 01:19:33,800
O foguete foi construído para
a Axencia Espacial Europea,

1604
01:19:33,800 --> 01:19:37,370
e despegou da súa instalación
na costa de Güiana Francesa.

1605
01:19:37,370 --> 01:19:40,540
>> -No Uns 37 segundos para
o voo, eles primeiro

1606
01:19:40,540 --> 01:19:42,270
notado que algo estaba a suceder de malo.

1607
01:19:42,270 --> 01:19:45,250
Os picos foron xirando en
un xeito que non debería.

1608
01:19:45,250 --> 01:19:49,580
Uns 40 segundos de voo,
claramente, o vehículo estaba en apuros.

1609
01:19:49,580 --> 01:19:51,850
>> E iso é cando fixeron
a decisión de destruír-lo.

1610
01:19:51,850 --> 01:19:55,780
O oficial de seguridade gama, con
tremenda coraxe, apertou o botón,

1611
01:19:55,780 --> 01:20:01,150
estoupou o foguete, antes de que puidese
facer un perigo para a seguridade pública.

1612
01:20:01,150 --> 01:20:04,060
>> -Este Foi o de solteira
viaxe do Ariane 5.

1613
01:20:04,060 --> 01:20:06,960
E a súa destrución levou
poñer debido a un fallo

1614
01:20:06,960 --> 01:20:08,822
embutido no programa do foguete.

1615
01:20:08,822 --> 01:20:11,280
-O Problema no Ariane foi
que había un número que

1616
01:20:11,280 --> 01:20:13,600
64 bits requirido para expresar.

1617
01:20:13,600 --> 01:20:16,590
E eles querían converter
Lo a un número de 16 bits.

1618
01:20:16,590 --> 01:20:18,610
Eles asumiron que o
número nunca ía

1619
01:20:18,610 --> 01:20:23,980
de ser moi grande, que a maior parte dos
díxitos do número de 64 bits foron ceros.

1620
01:20:23,980 --> 01:20:25,440
Estaban equivocados.

1621
01:20:25,440 --> 01:20:28,060
>> -O Incapacidade dun
programa de software para aceptar

1622
01:20:28,060 --> 01:20:32,510
o tipo de número xerado pola
outra estaba na orixe do fallo.

1623
01:20:32,510 --> 01:20:37,350
desenvolvemento de software tornouse un
parte moi cara de nova tecnoloxía.

1624
01:20:37,350 --> 01:20:41,140
O foguete Ariane foron moi
exitoso, tanto do software

1625
01:20:41,140 --> 01:20:44,550
creado por iso tamén se
usado no Ariane 5.

1626
01:20:44,550 --> 01:20:50,940
>> -O Problema básico era que a Ariane
5 foi máis rápido, máis rápido acelerada.

1627
01:20:50,940 --> 01:20:54,450
E o software non
que representaron.

1628
01:20:54,450 --> 01:20:58,060
>> -A Destrución do foguete
foi un enorme desastre financeiro,

1629
01:20:58,060 --> 01:21:01,790
todo debido a un erro de software minuto.

1630
01:21:01,790 --> 01:21:04,210
Pero este non foi o primeiro
problemas de conversión de datos de tempos

1631
01:21:04,210 --> 01:21:07,820
había atormentado a tecnoloxía de foguetes moderna.

1632
01:21:07,820 --> 01:21:11,050
>> -En 1991, co inicio
da primeira Guerra do Golfo,

1633
01:21:11,050 --> 01:21:13,570
o Patriot Missile
experimentaron un tipo similar

1634
01:21:13,570 --> 01:21:15,800
do problema de conversión de número.

1635
01:21:15,800 --> 01:21:19,090
E, como resultado, 28 persoas,
28 soldados norteamericanos,

1636
01:21:19,090 --> 01:21:22,080
morreron, e preto de
100 resultaron feridas,

1637
01:21:22,080 --> 01:21:25,780
cando o Patriot, que debería
para protexer contra scuds recibidas,

1638
01:21:25,780 --> 01:21:28,830
non puido disparar un mísil.

1639
01:21:28,830 --> 01:21:34,670
>> -Cando Iraq invadiu Kuwait, e América
lanzou Desert Storm a principios de 1991,

1640
01:21:34,670 --> 01:21:38,780
baterías de mísiles Patriot foron implantados
para protexer a Arabia Saudita e Israel

1641
01:21:38,780 --> 01:21:42,230
de ataques de mísiles Scud iraquís.

1642
01:21:42,230 --> 01:21:46,810
O Patriot é un medio alcance US
superficie de sistema de aire, fabricado

1643
01:21:46,810 --> 01:21:48,770
pola empresa Raytheon.

1644
01:21:48,770 --> 01:21:55,340
>> -O Tamaño do interceptor Patriot
en si é de aproximadamente uns 20 pés de longo.

1645
01:21:55,340 --> 01:21:58,230
E pesa uns 2.000 quilos.

1646
01:21:58,230 --> 01:22:02,320
E leva unha ogiva de preto,
Creo que é máis ou menos 150 libras.

1647
01:22:02,320 --> 01:22:06,930
E é o propio ogiva
un elevado explosivo, que

1648
01:22:06,930 --> 01:22:10,330
ten fragmentos en torno a el.

1649
01:22:10,330 --> 01:22:14,680
O invólucro de ogiva é
deseñado para actuar como chumbo groso.

1650
01:22:14,680 --> 01:22:17,110
>> -As Mísiles realízanse
catro por recipiente,

1651
01:22:17,110 --> 01:22:20,130
e son transportados por un semi-remolque.

1652
01:22:20,130 --> 01:22:27,930
>> -O Sistema Patriot anti-mísil
remonta polo menos 20 anos.

1653
01:22:27,930 --> 01:22:31,420
Foi orixinalmente deseñado
como un mísil de defensa aérea

1654
01:22:31,420 --> 01:22:33,720
para abater avións inimigos.

1655
01:22:33,720 --> 01:22:37,500
Na primeira Guerra do Golfo,
cando a guerra chegou,

1656
01:22:37,500 --> 01:22:42,745
Exército quería usalo para
abater scuds, non avións.

1657
01:22:42,745 --> 01:22:46,620
>> A Forza Aérea iraquí foi
non tanto dun problema.

1658
01:22:46,620 --> 01:22:49,670
Pero o Exército estaba preocupado scuds.

1659
01:22:49,670 --> 01:22:53,170
E así intentaron
actualizar o Patriot.

1660
01:22:53,170 --> 01:22:55,800
>> -Intercepting Un inimigo
mísil viaxando a Mach 5

1661
01:22:55,800 --> 01:22:58,830
ía ser moi difícil.

1662
01:22:58,830 --> 01:23:01,490
Pero cando o Patriot
foi levado ás présas en servizo,

1663
01:23:01,490 --> 01:23:05,860
o Exército non estaba ao tanto dun
modificación iraquí que fixo

1664
01:23:05,860 --> 01:23:08,930
seus scuds case imposible de bater.

1665
01:23:08,930 --> 01:23:13,740
>> -O Que pasou é que scuds
estaban chegando eran inestables.

1666
01:23:13,740 --> 01:23:14,692
Estaban bailando.

1667
01:23:14,692 --> 01:23:17,910
A razón para iso era
os iraquís, a fin

1668
01:23:17,910 --> 01:23:21,280
para 600 quilómetros
fóra dun 300 km

1669
01:23:21,280 --> 01:23:24,700
alcance dos mísiles, tomou peso
fóra da ogiva fronte.

1670
01:23:24,700 --> 01:23:26,390
Fixeron a ogiva máis lixeiro.

1671
01:23:26,390 --> 01:23:30,330
>> Polo tanto, agora o Patriot é
tentar chegar ao Scud.

1672
01:23:30,330 --> 01:23:33,230
E a maior parte do tempo, o
esmagadora maioría do tempo,

1673
01:23:33,230 --> 01:23:35,940
sería só voar pola Scuderia.

1674
01:23:35,940 --> 01:23:40,260
Xa que os operadores do sistema Patriot
entender que o Patriot errou o seu obxectivo,

1675
01:23:40,260 --> 01:23:44,690
eles detonaron ogiva do Patriot
para evitar posibles accidentes se

1676
01:23:44,690 --> 01:23:47,570
Deixouse caer ao chan.

1677
01:23:47,570 --> 01:23:51,790
>> -Iso Era o que a maioría da xente viu,
eses grandes bolas de lume no ceo,

1678
01:23:51,790 --> 01:23:57,550
e mal interpretado como
intercepta de oxivas Scud.

1679
01:23:57,550 --> 01:23:59,630
>> -aínda Na noite
ceos, Patriots apareceu

1680
01:23:59,630 --> 01:24:03,370
para ser correctamente
destruíndo Scuds, en Dhahran,

1681
01:24:03,370 --> 01:24:06,360
pode haber ningún erro
sobre o seu funcionamento.

1682
01:24:06,360 --> 01:24:10,970
Alí, sistema de radar do Patriot
perdeu a noción dun Scud entrada,

1683
01:24:10,970 --> 01:24:13,721
e nunca lanzado debido
a un fallo de software.

1684
01:24:13,721 --> 01:24:17,090

1685
01:24:17,090 --> 01:24:21,940
Foron os israelís que descuberto por primeira vez
que canto máis tempo o sistema foi ligado,

1686
01:24:21,940 --> 01:24:25,690
canto maior sexa o tempo de discrepancia
tornouse, debido a un reloxo incorporado

1687
01:24:25,690 --> 01:24:27,810
no ordenador do sistema.

1688
01:24:27,810 --> 01:24:31,210
>> -Cerca A dúas semanas antes
a traxedia en Dhahran,

1689
01:24:31,210 --> 01:24:33,770
os israelís informar para
o Departamento de Defensa

1690
01:24:33,770 --> 01:24:35,590
que o sistema estaba perdendo tempo.

1691
01:24:35,590 --> 01:24:38,360
Despois de preto de oito horas ou en execución,
eles notaron que o sistema

1692
01:24:38,360 --> 01:24:40,720
estaba facendo visiblemente menos precisas.

1693
01:24:40,720 --> 01:24:44,900
O Departamento de Defensa respondeu
contando todas as baterías Patriot

1694
01:24:44,900 --> 01:24:47,950
para non deixar os sistemas
por un longo período de tempo.

1695
01:24:47,950 --> 01:24:52,160
Nunca dixeron que un longo tempo foi--
oito horas, 10 horas, 1.000 horas.

1696
01:24:52,160 --> 01:24:54,360
Ninguén sabía.

1697
01:24:54,360 --> 01:24:56,380
>> -A Batería Patriot
estacionados no cuartel

1698
01:24:56,380 --> 01:25:01,350
en Dhahran ea súa falla interna
reloxo fora en máis de 100 horas

1699
01:25:01,350 --> 01:25:04,670
na noite do 25 de febreiro.

1700
01:25:04,670 --> 01:25:08,917
>> -É Monitor o tempo con precisión
de aproximadamente un décimo de segundo.

1701
01:25:08,917 --> 01:25:11,000
Agora, unha décima de segundo
é un número interesante,

1702
01:25:11,000 --> 01:25:14,920
por que non pode ser expresada
en binario exactamente, o que

1703
01:25:14,920 --> 01:25:19,820
significa que non pode ser expresado exactamente
en calquera ordenador dixital moderno.

1704
01:25:19,820 --> 01:25:21,540
É difícil de crer.

1705
01:25:21,540 --> 01:25:24,210
>> Pero usar isto como un exemplo.

1706
01:25:24,210 --> 01:25:26,540
Imos dar o número de un terzo.

1707
01:25:26,540 --> 01:25:30,350
Un terceiro non pode ser
expresada en decimal exactamente.

1708
01:25:30,350 --> 01:25:35,080
Un terzo é 0,333
pasando para o infinito.

1709
01:25:35,080 --> 01:25:39,480
>> Non hai ningunha forma de facelo con
a precisión absoluta en decimal.

1710
01:25:39,480 --> 01:25:42,560
Ese é o tipo de problema
que pasou o Patriot.

1711
01:25:42,560 --> 01:25:47,100
Canto máis tempo o sistema funcionou, o
peor o erro de tempo se fixo.

1712
01:25:47,100 --> 01:25:51,890
>> -Despois De 100 horas de funcionamento, o
erro no tempo foi só preto dun terzo

1713
01:25:51,890 --> 01:25:53,600
dun segundo.

1714
01:25:53,600 --> 01:25:57,210
Pero en termos de como obxectivo un
mísil viaxando a Mach 5,

1715
01:25:57,210 --> 01:26:01,710
deu lugar a un seguimento
de erro de máis de 600 metros.

1716
01:26:01,710 --> 01:26:05,120
Sería un erro grave
para os soldados do que

1717
01:26:05,120 --> 01:26:11,940
aconteceu é o lanzamento dun Scud foi
detectados por satélites de alerta precoz

1718
01:26:11,940 --> 01:26:15,860
e eles sabían que o Scud foi
está na súa dirección xeral.

1719
01:26:15,860 --> 01:26:18,320
Eles non sabían de onde viña.

1720
01:26:18,320 --> 01:26:21,250
>> -Foi Agora á radar
compoñente do sistema Patriota

1721
01:26:21,250 --> 01:26:26,190
defendendo Dhahran para localizar e manter
Ruta do mísil inimigo de entrada.

1722
01:26:26,190 --> 01:26:27,609
>> -O Radar era moi intelixente.

1723
01:26:27,609 --> 01:26:29,650
Sería, de feito, visite
a posición do Scud,

1724
01:26:29,650 --> 01:26:33,350
e logo, prever onde probablemente
sería a próxima vez que o radar enviado

1725
01:26:33,350 --> 01:26:34,420
Un pulso para fóra.

1726
01:26:34,420 --> 01:26:36,110
Que foi chamado un portón de gama.

1727
01:26:36,110 --> 01:26:40,660
>> -Entón, Xa que o Patriot
decide tempo suficiente ten

1728
01:26:40,660 --> 01:26:45,450
pasado para volver e comprobar a próxima
situación para este obxecto detectado,

1729
01:26:45,450 --> 01:26:46,600
vai volver.

1730
01:26:46,600 --> 01:26:51,650
Así, cando se volveu para o mal
lugar, a continuación, ve ningún obxecto.

1731
01:26:51,650 --> 01:26:55,160
E decide que non houbo
obxecto, foi unha falsa detección,

1732
01:26:55,160 --> 01:26:56,930
e deixa a pista.

1733
01:26:56,930 --> 01:27:00,030
>> -O Scud entrada desapareceu
da pantalla do radar.

1734
01:27:00,030 --> 01:27:03,260
E segundos despois,
chocou contra o cuartel.

1735
01:27:03,260 --> 01:27:09,150
O Scud matou 28, e foi a última
un disparou durante a primeira Guerra do Golfo.

1736
01:27:09,150 --> 01:27:14,960
>> Traxicamente, o software actualizado
Dhahran chegou o día seguinte.

1737
01:27:14,960 --> 01:27:17,930
O fallo de software tivo
foi fixada, o peche

1738
01:27:17,930 --> 01:27:22,806
un capítulo na conturbada
historia do mísil Patriot.

1739
01:27:22,806 --> 01:27:23,729
>> [Reprodución de vídeo]

1740
01:27:23,729 --> 01:27:26,520
DAVID J. Malan: Entón, iso é todo para
din que estas cuestións de estourido

1741
01:27:26,520 --> 01:27:28,860
e imprecisión son moi reais.

1742
01:27:28,860 --> 01:27:29,920
Entón, como chegamos aquí?

1743
01:27:29,920 --> 01:27:31,895
Comezamos con só fala de printf.

1744
01:27:31,895 --> 01:27:34,270
Unha vez máis, esta función que
imprime algo para a pantalla,

1745
01:27:34,270 --> 01:27:36,450
e nós introducidas posteriormente
algunhas outras funcións

1746
01:27:36,450 --> 01:27:37,945
desde o chamado biblioteca CS50.

1747
01:27:37,945 --> 01:27:39,910
E nós imos seguir
vexa estes en debido tempo.

1748
01:27:39,910 --> 01:27:43,760
E nós, en particular, usado cadea get,
e obter int, e agora tamén terá float,

1749
01:27:43,760 --> 01:27:47,410
e aínda outros aínda atoparemos
e utilizar connosco antes de tempo.

1750
01:27:47,410 --> 01:27:50,220
>> Pero de cando en vez, ten
visto que xa unha necesidade

1751
01:27:50,220 --> 01:27:53,520
para almacenar o que estas funcións man cara atrás?

1752
01:27:53,520 --> 01:27:55,920
Eles nos tras unha cadea de man,
ou un int ou float.

1753
01:27:55,920 --> 01:27:59,070
E ás veces hai que poñer que
cadea, ou int ou float, en algún lugar.

1754
01:27:59,070 --> 01:28:03,100
>> E para almacenar estas cousas, lembre-se só
como en perigo, temos variables.

1755
01:28:03,100 --> 01:28:06,260
Pero a diferenza de risco,
C temos tipos reais

1756
01:28:06,260 --> 01:28:08,530
de datos variables--
tipo, máis generally--

1757
01:28:08,530 --> 01:28:11,640
entre eles, unha corda, un int, un
flotar, e eses outros aínda.

1758
01:28:11,640 --> 01:28:15,321
>> E por iso, cando declara variables en C,
imos ter que declarar os nosos tipos de datos.

1759
01:28:15,321 --> 01:28:17,820
Isto non é algo que imos
Ten que facer máis tarde no semestre

1760
01:28:17,820 --> 01:28:19,810
A medida que a transición a outras linguas.

1761
01:28:19,810 --> 01:28:22,610
Pero, por agora, necesitamos
para a priori antes,

1762
01:28:22,610 --> 01:28:27,370
explicar ao ordenador que tipo
da variable que queremos dar.

1763
01:28:27,370 --> 01:28:30,290
>> Agora, con todo, para imprimir
estes tipos de tipos de datos,

1764
01:28:30,290 --> 01:28:32,570
debemos dicir printf o que esperar.

1765
01:28:32,570 --> 01:28:35,450
E vimos por cento s para cordas,
e cento i para enteiros,

1766
01:28:35,450 --> 01:28:36,790
e algúns outros xa.

1767
01:28:36,790 --> 01:28:40,237
E estes son só requisitos
para a presentación visual

1768
01:28:40,237 --> 01:28:41,070
desas informacións.

1769
01:28:41,070 --> 01:28:45,080
>> E cada un destes pode ser realmente
parametrizada ou revolto, dalgún xeito,

1770
01:28:45,080 --> 01:28:48,370
se quere promover o control
o tipo de saída que comeza.

1771
01:28:48,370 --> 01:28:52,604
E, de feito, parece que non só
hai barra invertida n para unha nova liña.

1772
01:28:52,604 --> 01:28:55,520
Hai unha cousa chamada barra invertida
r para un retorno de coche, o que

1773
01:28:55,520 --> 01:28:57,360
é máis semellante a un
Máquina de escribir vella escola,

1774
01:28:57,360 --> 01:29:00,690
e tamén o Windows usado por moitos anos.

1775
01:29:00,690 --> 01:29:02,690
>> Hai barra invertida ta guías.

1776
01:29:02,690 --> 01:29:06,170
Acontece que, que se quere
comiñas dentro dunha cadea,

1777
01:29:06,170 --> 01:29:08,000
Lembre que usamos
dobre comiñas

1778
01:29:08,000 --> 01:29:10,900
Cita á esquerda e á dereita
acaba de nosas cordas ata agora.

1779
01:29:10,900 --> 01:29:12,420
Isto parece confundir as cousas.

1780
01:29:12,420 --> 01:29:15,503
>> Se queres poñer un aspa en
no medio dunha string-- e, en realidade,

1781
01:29:15,503 --> 01:29:16,670
é confuso para ver.

1782
01:29:16,670 --> 01:29:20,120
E entón ten que escapar, por así
falar, unha aspa con algo

1783
01:29:20,120 --> 01:29:21,860
como literalmente barra invertida comiñas dobres.

1784
01:29:21,860 --> 01:29:23,230
E hai algunhas outras aínda.

1785
01:29:23,230 --> 01:29:27,540
E veremos máis destes
no uso real en pouco tempo.

1786
01:29:27,540 --> 01:29:30,930
>> Entón, imos agora a transición
de datos e de representación,

1787
01:29:30,930 --> 01:29:33,820
e operadores aritméticos, todo
dos cales nos deu algún edificio

1788
01:29:33,820 --> 01:29:35,070
bloques que a desempeñar.

1789
01:29:35,070 --> 01:29:37,481
Pero agora imos realmente dar
-Nos resto do vocabulario

1790
01:29:37,481 --> 01:29:39,230
que xa
a semana pasada co Scratch

1791
01:29:39,230 --> 01:29:42,350
dando un ollo a algún outro
construcións en C-- non todas elas.

1792
01:29:42,350 --> 01:29:44,680
Pero as ideas que estamos
a piques de ver realmente só

1793
01:29:44,680 --> 01:29:48,610
salientar a tradución do
unha lingua, risco, a outro, C.

1794
01:29:48,610 --> 01:29:51,470
>> E co paso do tempo, imos incorporarse
máis ferramentas para a nosa caixa de ferramentas,

1795
01:29:51,470 --> 01:29:52,820
por así dicir, sintaticamente.

1796
01:29:52,820 --> 01:29:57,190
E, de feito, podes ver que as ideas
agora son moi familiares da semana pasada.

1797
01:29:57,190 --> 01:29:58,200
Entón, imos facelo.

1798
01:29:58,200 --> 01:30:01,870
>> Imos adiante e látego dun programa
que realmente usa algunhas expresións,

1799
01:30:01,870 --> 01:30:03,720
unha expresión booleana.

1800
01:30:03,720 --> 01:30:05,810
Déixeme ir adiante aquí
e crear un novo ficheiro.

1801
01:30:05,810 --> 01:30:09,090
Vou chamar este condition.c.

1802
01:30:09,090 --> 01:30:12,350
>> Deixe-me ir adiante e
inclúen a biblioteca CS50.

1803
01:30:12,350 --> 01:30:15,640
E deixe-me ir adiante e inclúen
estándar io.h ás nosas funcións,

1804
01:30:15,640 --> 01:30:17,690
e printf, e máis, respectivamente.

1805
01:30:17,690 --> 01:30:21,900
Deixe-me dar a min mesmo que cliché de
void main int, cuxa explicación que vai

1806
01:30:21,900 --> 01:30:23,360
volver no futuro.

1807
01:30:23,360 --> 01:30:26,820
>> Agora, deixe-me ir adiante e dar
me un int vía get int.

1808
01:30:26,820 --> 01:30:28,970
Entón deixe-me ir adiante e facelo.

1809
01:30:28,970 --> 01:30:33,150
Quero dicir, se eu é less-- imos
distinguir entre positivo, negativo,

1810
01:30:33,150 --> 01:30:34,260
ou valores iguais a cero.

1811
01:30:34,260 --> 01:30:39,630
>> Entón, se eu for menor que cero, déixeme
só ten este programa simplemente dicir:

1812
01:30:39,630 --> 01:30:45,370
negativo, barra invertida n, outra
i é maior que cero.

1813
01:30:45,370 --> 01:30:50,030
Agora eu estou, por suposto, vai dicir
printf positivo, barra invertida n.

1814
01:30:50,030 --> 01:30:53,690
E entón algo se-- eu podería facelo.

1815
01:30:53,690 --> 01:30:56,410
>> Podería facer se eu for igual a 0.

1816
01:30:56,410 --> 01:30:58,840
Pero eu estaría facendo en
menos un erro xa.

1817
01:30:58,840 --> 01:31:02,480
Lembre que o signo de igualdade é
non é igual, como nós, seres humanos saben diso.

1818
01:31:02,480 --> 01:31:04,010
>> Pero é o operador de asignación.

1819
01:31:04,010 --> 01:31:08,640
E nós non queremos tomar 0 no
dereita e poñelas i á esquerda.

1820
01:31:08,640 --> 01:31:14,810
Entón, para evitar esta confusión, ou
quizais uso indebido do signo igual,

1821
01:31:14,810 --> 01:31:17,740
os seres humanos decidiron hai uns anos
que en moitas linguaxes de programación

1822
01:31:17,740 --> 01:31:21,000
cando quere comprobar a igualdade
entre a esquerda ea dereita,

1823
01:31:21,000 --> 01:31:22,635
realmente usa é igual iguais.

1824
01:31:22,635 --> 01:31:24,010
Entón bate o signo igual dúas veces.

1825
01:31:24,010 --> 01:31:28,600
Cando quere asignar a partir da dereita
á esquerda, usa un único signo igual.

1826
01:31:28,600 --> 01:31:32,360
Para que puidésemos facer outra cousa isto--
i é igual a cero.

1827
01:31:32,360 --> 01:31:34,710
>> Podería, entón, ir e
abrir os chaves,

1828
01:31:34,710 --> 01:31:39,087
e dicir: printf 0, barra invertida n, feito.

1829
01:31:39,087 --> 01:31:41,170
Pero lembre-se como estes
garfos na estrada pode funcionar.

1830
01:31:41,170 --> 01:31:42,836
E, realmente, só pensar sobre a lóxica.

1831
01:31:42,836 --> 01:31:44,510
i é un número.

1832
01:31:44,510 --> 01:31:46,320
É un enteiro, especialmente.

1833
01:31:46,320 --> 01:31:51,600
E isto significa que vai ser menos
que 0, ou maior que 0, ou 0.

1834
01:31:51,600 --> 01:31:54,600
Polo tanto, non é unha especie de agasallo
caso estándar implícito.

1835
01:31:54,600 --> 01:31:57,920
>> E así poderiamos, así como
Cero, dispensar o else if,

1836
01:31:57,920 --> 01:31:58,747
e só dicir outra cousa.

1837
01:31:58,747 --> 01:32:00,830
Loxicamente, o
programador sabe que só hai

1838
01:32:00,830 --> 01:32:04,635
tres baldes na cal un
escenario pode fall-- o primeiro,

1839
01:32:04,635 --> 01:32:06,510
o segundo, ou terceiro
neste case-- non

1840
01:32:06,510 --> 01:32:10,100
molesta engadindo a precisión adicional
ea lóxica adicional alí.

1841
01:32:10,100 --> 01:32:12,690
Só tes que ir adiante coa
caso estándar aquí doutra persoa.

1842
01:32:12,690 --> 01:32:14,950
>> Agora, imos adiante
despois de gardar tanto, asegúrese

1843
01:32:14,950 --> 01:32:18,760
condicións dot cortar conditions--
non unha gran interface de usuario,

1844
01:32:18,760 --> 01:32:21,914
porque eu non estou levando o
usuario, como mencionei anteriormente.

1845
01:32:21,914 --> 01:32:22,580
Pero iso é bo.

1846
01:32:22,580 --> 01:32:23,454
Imos mantelo simple.

1847
01:32:23,454 --> 01:32:24,890
Tentaremos número 42.

1848
01:32:24,890 --> 01:32:26,240
E iso é positivo.

1849
01:32:26,240 --> 01:32:29,120
Tentaremos número
negativo 42, negativa.

1850
01:32:29,120 --> 01:32:31,244
>> Tentaremos valor 0.

1851
01:32:31,244 --> 01:32:32,160
E, de feito, funciona.

1852
01:32:32,160 --> 01:32:36,900
Agora, podes ver con problemas antes
longos e probar as cousas tres veces,

1853
01:32:36,900 --> 01:32:37,980
probablemente insuficiente.

1854
01:32:37,980 --> 01:32:40,438
Probablemente vai querer probar algúns
números grandes, algúns menores

1855
01:32:40,438 --> 01:32:43,520
números, nalgúns casos de canto, como
nós imos chegar a describilos-los.

1856
01:32:43,520 --> 01:32:45,500
>> Pero, por agora, esta é unha
programa moi sinxelo.

1857
01:32:45,500 --> 01:32:48,160
E eu estou seguro que, loxicamente,
que se divide en tres casos.

1858
01:32:48,160 --> 01:32:52,360
E, de feito, aínda que só
incidir sobre os potenciais inconvenientes

1859
01:32:52,360 --> 01:32:56,480
de imprecisión e inundará, en
realidade onde moitos dos problemas do CS50,

1860
01:32:56,480 --> 01:32:59,000
Non imos preocuparnos
sobre, todo o tempo,

1861
01:32:59,000 --> 01:33:02,050
estes problemas de estourido e
imprecisión, porque, en realidade, en C,

1862
01:33:02,050 --> 01:33:04,889
non é realmente todo o que
doado de evitar isto.

1863
01:33:04,889 --> 01:33:07,180
Se desexa contar-se
maior, e máis, e máis,

1864
01:33:07,180 --> 01:33:10,510
resulta que existen técnicas que
Pode usar a miúdo inclúen cousas chamadas

1865
01:33:10,510 --> 01:33:14,240
bibliotecas, coleccións de código, que
outros escribiu que pode usar,

1866
01:33:14,240 --> 01:33:16,910
e outras linguaxes como
Java e outros, en realidade,

1867
01:33:16,910 --> 01:33:18,800
facelo moito máis fácil
contar aínda maior.

1868
01:33:18,800 --> 01:33:22,810
Polo tanto, é realmente algúns deses perigos
unha función da linguaxe que usa.

1869
01:33:22,810 --> 01:33:25,710
E nas próximas semanas, imos
ver como perigoso C realmente

1870
01:33:25,710 --> 01:33:27,950
pode ser, se non usalo correctamente.

1871
01:33:27,950 --> 01:33:30,610
Pero a partir de aí, e con
Python e JavaScript, vai

1872
01:33:30,610 --> 01:33:35,620
nós capa nalgunhas proteccións adicionais,
e executar menos deses riscos.

1873
01:33:35,620 --> 01:33:38,820
>> Entón, imos facer un pouco máis
lóxica interesante no noso programa.

1874
01:33:38,820 --> 01:33:42,110
Entón deixe-me ir adiante e crear
un programa chamado lóxico

1875
01:33:42,110 --> 01:33:46,804
só así podo xogar con algúns
lóxica real, logical.c.

1876
01:33:46,804 --> 01:33:49,870
Eu só vou copiar e pegar algún
Código de antes, entón eu volver

1877
01:33:49,870 --> 01:33:52,950
a este bo punto de partida.

1878
01:33:52,950 --> 01:33:56,980
>> Déixeme esta vez facer C. de char que eu son
vai dar-lle un nome de C

1879
01:33:56,980 --> 01:34:01,510
só porque é convencional,
obter un personaxe do usuario.

1880
01:34:01,510 --> 01:34:03,730
E imos finxir
Estou aplicando parte

1881
01:34:03,730 --> 01:34:07,130
dese programa Rm, a retirada
programa antes que levou ao usuario

1882
01:34:07,130 --> 01:34:08,400
para eliminar un ficheiro.

1883
01:34:08,400 --> 01:34:09,750
Como poderiamos facelo?

1884
01:34:09,750 --> 01:34:14,090
>> Quero dicir que, se C é igual a
iguais, entre comiñas,

1885
01:34:14,090 --> 01:34:19,304
y, entón eu vou asumir
que o usuario decide si.

1886
01:34:19,304 --> 01:34:20,470
Eu só vou para imprimir si.

1887
01:34:20,470 --> 01:34:22,440
Se fose realmente escribir
o programa de eliminación,

1888
01:34:22,440 --> 01:34:24,420
poderiamos eliminar o ficheiro
con máis liñas de código.

1889
01:34:24,420 --> 01:34:25,461
Pero nós imos mantelo simple.

1890
01:34:25,461 --> 01:34:28,950

1891
01:34:28,950 --> 01:34:34,250
>> Else if c é igual a igual n--
e agora aquí, eu vou dicir,

1892
01:34:34,250 --> 01:34:35,980
o usuario debe ter significado ningún.

1893
01:34:35,980 --> 01:34:37,360
E entón algo, vostede sabe o que?

1894
01:34:37,360 --> 01:34:39,200
Non sei o que máis
o usuario vai escribir.

1895
01:34:39,200 --> 01:34:41,533
Entón, eu estou indo só para dicir que
que é un erro, calquera que sexa

1896
01:34:41,533 --> 01:34:43,070
el ou ela realmente ingresaran.

1897
01:34:43,070 --> 01:34:44,180
>> Entón, o que está pasando aquí?

1898
01:34:44,180 --> 01:34:47,530
Hai unha diferenza fundamental
versus o que eu fixen no pasado.

1899
01:34:47,530 --> 01:34:52,300
comiñas, aspas dobres, o dobre
citas, e, aínda, aspas,

1900
01:34:52,300 --> 01:34:53,170
aspas.

1901
01:34:53,170 --> 01:34:55,860
Acontece en C, que cando
quere escribir unha corda,

1902
01:34:55,860 --> 01:34:59,680
usa comiñas dobres, así como temos
benvida a empregar todo este tempo con printf.

1903
01:34:59,680 --> 01:35:05,030
>> Pero se quere tratar con só un
carácter único, un chamado char,

1904
01:35:05,030 --> 01:35:06,780
entón realmente usar comiñas simples.

1905
01:35:06,780 --> 01:35:08,450
Aqueles de vós que teña previsto
antes, pode non ter

1906
01:35:08,450 --> 01:35:10,850
tiña que preocuparse con iso
distinción en certas linguas.

1907
01:35:10,850 --> 01:35:12,450
C, non importa.

1908
01:35:12,450 --> 01:35:15,560
E así cando chegar nun char e quero
comparar ese carácter usando equals

1909
01:35:15,560 --> 01:35:21,350
é igual a algunha carta como y ou n, fago,
en realidade, ten que ter as aspas.

1910
01:35:21,350 --> 01:35:22,770
>> Agora, imos ir adiante e facelo.

1911
01:35:22,770 --> 01:35:29,180
Imos ir adiante e fan
dot lóxicas cortar lóxico.

1912
01:35:29,180 --> 01:35:30,305
E agora eu estou sendo solicitado.

1913
01:35:30,305 --> 01:35:33,638
Así, presuntamente, unha mellor experiencia de usuario
sería realmente dicir o que facer aquí.

1914
01:35:33,638 --> 01:35:36,030
Pero eu vou só cega
din y para si, OK, agradable.

1915
01:35:36,030 --> 01:35:38,780
>> Imos executa-lo de novo, n para ningunha, agradable.

1916
01:35:38,780 --> 01:35:42,610
Supoña como certas persoas que coñezo,
meus tecla bloqueo de mayúsculas está conectado con demasiada frecuencia.

1917
01:35:42,610 --> 01:35:46,740
Entón fago o capital Y, entrar, erro.

1918
01:35:46,740 --> 01:35:49,130
OK, non é o que eu estou esperando.

1919
01:35:49,130 --> 01:35:51,170
Efectivamente, o ordenador
Está facendo literalmente o que

1920
01:35:51,170 --> 01:35:54,794
Eu dixen-o para comprobar a fazer--
minúsculas n y e minúsculas.

1921
01:35:54,794 --> 01:35:56,960
Este non se sente como bo
experiencia do usuario, aínda que.

1922
01:35:56,960 --> 01:36:02,010
Déixeme pedir e aceptar
ambos os casos inferior ou maiúsculas.

1923
01:36:02,010 --> 01:36:05,090
Así, verifícase se, pode querer
dicir algo como en perigo,

1924
01:36:05,090 --> 01:36:11,150
como literal ou C é igual a
é igual a de capital único y citado.

1925
01:36:11,150 --> 01:36:14,400
Acontece que, C non ten
esta palabra chave literal ou.

1926
01:36:14,400 --> 01:36:15,880
>> Pero ten dúas barras verticais.

1927
01:36:15,880 --> 01:36:18,463
Ten que soster a tecla Maiús normalmente,
se está a usar un teclado americano,

1928
01:36:18,463 --> 01:36:21,910
e bateu a barra vertical
clave sobre a súa tecla de retorno.

1929
01:36:21,910 --> 01:36:25,410
Pero esa barra vertical
barra vertical significa ou.

1930
01:36:25,410 --> 01:36:29,220
>> Se, pola contra, queriamos
a dicir, e como en perigo,

1931
01:36:29,220 --> 01:36:31,180
poderiamos facer comercial e comercial.

1932
01:36:31,180 --> 01:36:34,330
Isto non ten sentido lóxico aquí,
porque un humano non podería posiblemente

1933
01:36:34,330 --> 01:36:40,110
escribiu tanto y e minúsculas y
e capital de Y como o mesmo personaxe.

1934
01:36:40,110 --> 01:36:42,470
Así, é o que pretendemos aquí.

1935
01:36:42,470 --> 01:36:49,280
>> Entón, se eu fai iso en ambos os lugares, ou c
é igual é igual a de capital N, agora realizar de novo,

1936
01:36:49,280 --> 01:36:52,390
fan lóxica, executa novo lóxico.

1937
01:36:52,390 --> 01:36:54,200
Agora, podo escribir y.

1938
01:36:54,200 --> 01:36:56,920
E podo facelo de novo con
capital de Y ou N. de capital

1939
01:36:56,920 --> 01:36:59,630
E eu podería engadir no adicional
combinacións fixas.

1940
01:36:59,630 --> 01:37:01,810
>> Polo tanto, esta é unha lóxica
programa na medida en que agora

1941
01:37:01,810 --> 01:37:04,940
Estou comprobando loxicamente para
Este valor é ese valor.

1942
01:37:04,940 --> 01:37:09,420
E eu non teño que, necesariamente,
vir cara arriba con dous IFS ou entón IFS.

1943
01:37:09,420 --> 01:37:12,960
Eu realmente combinan un pouco da
Relacionado coa lóxica xuntos deste xeito.

1944
01:37:12,960 --> 01:37:14,950
Polo tanto, este sería mellor
deseñado simplemente

1945
01:37:14,950 --> 01:37:20,490
dicindo si C é igual a menor caso y,
imprimir si, máis se c é igual a capital de Y,

1946
01:37:20,490 --> 01:37:23,074
imprimir si, máis se c é igual a
lower-- noutras palabras,

1947
01:37:23,074 --> 01:37:24,990
Non ten que ter
máis e máis filiais.

1948
01:37:24,990 --> 01:37:31,840
É posible combinar algunhas das equivalente
Loxicamente, como ramas deste xeito.

1949
01:37:31,840 --> 01:37:37,150
>> Entón, imos dar un ollo en só un
ingrediente final, unha construción final,

1950
01:37:37,150 --> 01:37:37,847
que permite C.

1951
01:37:37,847 --> 01:37:39,930
E nós imos voltar no
futuro, a outros aínda.

1952
01:37:39,930 --> 01:37:44,400
E entón nós imos concluír, mirando
por non a corrección de code--

1953
01:37:44,400 --> 01:37:49,070
como obter o código de trabalho-- pero o deseño
de código, e plantar as sementes no inicio.

1954
01:37:49,070 --> 01:37:54,337
>> Entón deixe-me ir adiante e
abrir un novo ficheiro aquí.

1955
01:37:54,337 --> 01:37:54,920
Vostede sabe o que?

1956
01:37:54,920 --> 01:37:57,450
Eu estou indo a reimplementar
que mesmo programa,

1957
01:37:57,450 --> 01:37:58,940
pero utilizando unha construción diferente.

1958
01:37:58,940 --> 01:38:03,110
>> Entón me deixe rapidamente darme
Acceso para incluír CS50.h

1959
01:38:03,110 --> 01:38:07,150
para a biblioteca de CS50,
Io.h estándar para printf.

1960
01:38:07,150 --> 01:38:09,510
Dáme o meu void main int.

1961
01:38:09,510 --> 01:38:12,310
E entón para acá, imos
me ir adiante e facelo.

1962
01:38:12,310 --> 01:38:15,010
>> Char c recibe obter char, como antes.

1963
01:38:15,010 --> 01:38:19,770
E eu vou usar unha nova construción
agora-- cambiar, na cal personaxe?

1964
01:38:19,770 --> 01:38:22,820
Entón chave é tipo como
O cambio dun carrís do tren.

1965
01:38:22,820 --> 01:38:25,070
Ou, en realidade, é unha especie de
unha máis, se else if,

1966
01:38:25,070 --> 01:38:26,980
pero escrito un pouco diferente.

1967
01:38:26,980 --> 01:38:28,490
>> A clave parece con isto.

1968
01:38:28,490 --> 01:38:32,060
Ten switch, e entón o que
caracteres ou número que quere para ollar,

1969
01:38:32,060 --> 01:38:35,000
logo dalgunhas claves como en
Cero, só dicir que facer estas cousas.

1970
01:38:35,000 --> 01:38:36,480
E entón tes casos diferentes.

1971
01:38:36,480 --> 01:38:37,830
>> Non usar if e else.

1972
01:38:37,830 --> 01:38:40,050
Vostede literalmente usar o caso da palabra.

1973
01:38:40,050 --> 01:38:41,790
E diría algo así.

1974
01:38:41,790 --> 01:38:46,820
>> Así, no caso dun minúsculas Y,
ou no caso dun capital Y,

1975
01:38:46,820 --> 01:38:50,350
dalle imprimir si.

1976
01:38:50,350 --> 01:38:52,020
E, a continuación, saír do switch.

1977
01:38:52,020 --> 01:38:52,580
É iso aí.

1978
01:38:52,580 --> 01:38:53,880
Estamos a facer.

1979
01:38:53,880 --> 01:39:00,270
>> Else if, por así dicir,
minúsculas n, ou de capital N,

1980
01:39:00,270 --> 01:39:05,560
entón vai adiante e imprimir
saír, non, e, a continuación, romper.

1981
01:39:05,560 --> 01:39:11,022
Else-- e este tipo de é o
caso estándar indeed-- printf error--

1982
01:39:11,022 --> 01:39:13,980
e só para unha boa medida, aínda que
loxicamente esta pausa non é necesario

1983
01:39:13,980 --> 01:39:15,896
porque estamos na fin
do interruptor de calquera xeito,

1984
01:39:15,896 --> 01:39:17,520
Agora estou batendo fóra do switch.

1985
01:39:17,520 --> 01:39:19,280
Polo tanto, este parece un pouco diferente.

1986
01:39:19,280 --> 01:39:21,272
>> Pero, loxicamente, é
efectivamente equivalente.

1987
01:39:21,272 --> 01:39:22,980
E por que usaría
un sobre o outro?

1988
01:39:22,980 --> 01:39:26,220
Ás veces, só preferencia persoal,
por veces, a estética,

1989
01:39:26,220 --> 01:39:28,420
se eu ollo para esta
Agora, hai algo

1990
01:39:28,420 --> 01:39:30,510
a ser dito para o
lexibilidade deste código.

1991
01:39:30,510 --> 01:39:33,690
É dicir, non importa o feito de que este
código é novo para moitos de nós no cuarto.

1992
01:39:33,690 --> 01:39:36,515
>> Pero é só unha especie de é bonito.

1993
01:39:36,515 --> 01:39:40,760
Ve minúsculas y, capital de Y,
minúsculas n, patrón de capital N,

1994
01:39:40,760 --> 01:39:43,150
el só tipo de saltos
fóra en ti dunha maneira

1995
01:39:43,150 --> 01:39:45,200
que, sen dúbida, se cadra
o exemplo anterior

1996
01:39:45,200 --> 01:39:48,780
coas IFS, e as barras verticais,
e os IFS outra persoa, pode non ter.

1997
01:39:48,780 --> 01:39:54,600
Polo tanto, esta é realmente unha cuestión de persoal
elección, realmente, é a lexibilidade,

1998
01:39:54,600 --> 01:39:55,360
do código.

1999
01:39:55,360 --> 01:40:01,230
>> Pero en termos de funcionalidade, déixeme
dalle facer unha chave, barra dot

2000
01:40:01,230 --> 01:40:08,830
switch, e agora escribir y minúsculas,
capital de Y, minúsculas n, capital de N,

2001
01:40:08,830 --> 01:40:12,250
David, ténteo de novo, porque iso é
non un único carácter.

2002
01:40:12,250 --> 01:40:15,050
Faremos x, erro, como se esperaba.

2003
01:40:15,050 --> 01:40:18,640
E, logically-- e iso é algo
Quere fomentar en general-- mesmo

2004
01:40:18,640 --> 01:40:20,790
aínda estamos só raiar a
superficie dalgunhas destas características.

2005
01:40:20,790 --> 01:40:23,560
>> E isto pode non ser evidente cando
-Se sentir no teclado,

2006
01:40:23,560 --> 01:40:24,370
como funciona?

2007
01:40:24,370 --> 01:40:25,240
O que isto fai?

2008
01:40:25,240 --> 01:40:28,630
A fermosa cousa sobre ter
un portátil ou de escritorio, ou o acceso

2009
01:40:28,630 --> 01:40:32,290
a un ordenador cun compilador,
e con un editor de código como este,

2010
01:40:32,290 --> 01:40:35,990
é case sempre pode responder a estas
preguntas a si mesmo só tentando.

2011
01:40:35,990 --> 01:40:39,570
>> Por exemplo, se o retórico
cuestión en apreciado foron,

2012
01:40:39,570 --> 01:40:42,540
o que pasa se esquecer
súas declaracións de ruptura?

2013
01:40:42,540 --> 01:40:44,400
Que é realmente un
moi común que hai que facer,

2014
01:40:44,400 --> 01:40:46,540
por que non parece
como realmente precisa deles.

2015
01:40:46,540 --> 01:40:49,790
Realmente non completar o seu
pensaba como paréntese ou rizado

2016
01:40:49,790 --> 01:40:50,714
cinta fai.

2017
01:40:50,714 --> 01:40:52,630
Imos ir adiante e
recompilar o código e ver.

2018
01:40:52,630 --> 01:40:56,690
Entón faga chave, chave de corte de punto.

2019
01:40:56,690 --> 01:40:59,435
Imos escribir en letras minúsculas
y, a top case, Intro.

2020
01:40:59,435 --> 01:41:02,390

2021
01:41:02,390 --> 01:41:03,700
Entón eu escriba y.

2022
01:41:03,700 --> 01:41:07,420
>> O programa dixo que si, non, de erro,
como se está cambiando a súa mente.

2023
01:41:07,420 --> 01:41:12,280
Pero que tipo de era, xa que o que pasa
cun interruptor é o primeiro caso que

2024
01:41:12,280 --> 01:41:16,899
xogo significa, esencialmente, hey ordenador,
realizar todo o código de abaixo dela.

2025
01:41:16,899 --> 01:41:19,690
E se non se ruptura, ou
non digo ruptura, ou non din ruptura,

2026
01:41:19,690 --> 01:41:22,540
o ordenador vai explotar
a través de todas as liñas

2027
01:41:22,540 --> 01:41:25,779
e realizar todos eles ata
chega a ese chaveta.

2028
01:41:25,779 --> 01:41:27,320
Así, os freos son, de feito, é necesario.

2029
01:41:27,320 --> 01:41:30,120
Pero un takeaway aquí é cando
En caso de dúbida, proba algo.

2030
01:41:30,120 --> 01:41:32,510
Quizais gardar o código en primeiro lugar,
ou garda-lo nun arquivo extra

2031
01:41:32,510 --> 01:41:35,930
se está realmente preocupado
desorde e ter que recuperar

2032
01:41:35,930 --> 01:41:37,430
o traballo que sabe que funciona.

2033
01:41:37,430 --> 01:41:38,410
>> Pero tentar cousas.

2034
01:41:38,410 --> 01:41:41,074
E non ser tan medo, se cadra,
que o ordenador pode facer,

2035
01:41:41,074 --> 01:41:42,490
ou que pode romper algo.

2036
01:41:42,490 --> 01:41:45,790
Sempre pode volver
a algunha versión anterior.

2037
01:41:45,790 --> 01:41:48,640
>> Entón imos acabar vendo
para o deseño de código.

2038
01:41:48,640 --> 01:41:52,020
Temos esa capacidade agora de escribir
condicións e loops de gravación,

2039
01:41:52,020 --> 01:41:53,850
e variables, e funcións de chamada.

2040
01:41:53,850 --> 01:41:57,590
Entón, francamente, estamos especie de volta ao
onde estabamos hai unha semana co Scratch,

2041
01:41:57,590 --> 01:42:03,120
aínda que cun textuais menos convincentes
ambiente que cero permite.

2042
01:42:03,120 --> 01:42:06,990
>> Pero teña en conta a rapidez con que adquiriu
que o vocabulario, aínda que sexa

2043
01:42:06,990 --> 01:42:10,570
vai levar un pouco de tempo para afondar,
de xeito que agora podemos utilizar este vocabulario

2044
01:42:10,570 --> 01:42:13,320
para escribir programas máis interesantes.

2045
01:42:13,320 --> 01:42:15,940
E imos dar un paso de bebé
para que, deste xeito.

2046
01:42:15,940 --> 01:42:17,890
Deixe-me ir adiante e
crear un novo arquivo aquí.

2047
01:42:17,890 --> 01:42:20,750
>> Vou chamar esta
prototype.c, e introducir

2048
01:42:20,750 --> 01:42:23,954
por primeira vez, a capacidade
para facer as súas propias funcións.

2049
01:42:23,954 --> 01:42:25,870
Algúns de vostedes poden ter
feito isto co Scratch,

2050
01:42:25,870 --> 01:42:28,430
a través do cal pode crear o seu
bloques individuais propios en cero,

2051
01:42:28,430 --> 01:42:30,892
e logo, arrastralo los para sitio
onde queira que quere en C.

2052
01:42:30,892 --> 01:42:33,100
E na maior parte da programación
idiomas, pode facer exactamente

2053
01:42:33,100 --> 01:42:36,580
isso-- facer as súas propias funcións,
se xa non existen.

2054
01:42:36,580 --> 01:42:41,660
>> Así, por exemplo, deixe-me ir adiante
e inclúen CS50.h, e incluír

2055
01:42:41,660 --> 01:42:46,110
estándar io.h, int void main.

2056
01:42:46,110 --> 01:42:49,020
E agora temos unha
espazo reservado preparado para ir.

2057
01:42:49,020 --> 01:42:51,550
I manter as cousas de impresión
como os nomes das persoas hoxe.

2058
01:42:51,550 --> 01:42:54,910
E que se sente como--
Non sería bo se hai

2059
01:42:54,910 --> 01:42:56,936
eran unha función chamada nome de impresión?

2060
01:42:56,936 --> 01:42:58,060
Non teño de utilizar printf.

2061
01:42:58,060 --> 01:42:59,976
Non teño a lembrar
todos os códigos de formato.

2062
01:42:59,976 --> 01:43:03,050
Por que non eu, ou porque
non alguén antes de min,

2063
01:43:03,050 --> 01:43:05,980
crear unha función chamada de impresión
nome, dado algún nome,

2064
01:43:05,980 --> 01:43:06,980
simplemente imprime-lo para fóra?

2065
01:43:06,980 --> 01:43:11,700
>> Noutras palabras, se eu digo, hey,
ordenador, dáme unha corda

2066
01:43:11,700 --> 01:43:14,870
pedindo ao usuario para tal,
vía función de cadea get de CS50.

2067
01:43:14,870 --> 01:43:18,090
Hey, ordenador, poñer esa cadea en
a variable na parte esquerda,

2068
01:43:18,090 --> 01:43:19,150
e chamalo s.

2069
01:43:19,150 --> 01:43:25,150
E, a continuación, hey ordenador, vai adiante
e imprimir o nome de persoa, feito.

2070
01:43:25,150 --> 01:43:29,240
>> Agora sería bo, porque
Neste programa, apropiadamente chamado,

2071
01:43:29,240 --> 01:43:32,170
dime o que se quere facer
por medio de nomes daqueles función.

2072
01:43:32,170 --> 01:43:35,930
Deixe-me ir e facer prototipo, Intro.

2073
01:43:35,930 --> 01:43:37,930
E, por desgraza,
iso non vai voar.

2074
01:43:37,930 --> 01:43:42,430
>> Prototype.c, liña 7, personaxe
5, de erro, declaración implícita

2075
01:43:42,430 --> 01:43:45,960
da función nome de impresión
non é válido na C99, C99

2076
01:43:45,960 --> 01:43:48,130
significa unha versión de C
que saíu en 1999.

2077
01:43:48,130 --> 01:43:48,730
Iso é todo.

2078
01:43:48,730 --> 01:43:51,780
>> Entón, eu non sei o que
todo isto significa aínda.

2079
01:43:51,780 --> 01:43:53,810
Pero eu recoñezo erro en vermello.

2080
01:43:53,810 --> 01:43:54,770
Isto é moi evidente.

2081
01:43:54,770 --> 01:43:56,769
>> E parece que, con
o personaxe verde aquí,

2082
01:43:56,769 --> 01:44:00,520
o problema é o nome de impresión, aberta
Paren s, paren próximos, e coma.

2083
01:44:00,520 --> 01:44:04,800
Pero a declaración implícita de
función fixemos ver brevemente antes.

2084
01:44:04,800 --> 01:44:07,880
Isto significa, simplemente, que Clang
Non sabe o que quero dicir.

2085
01:44:07,880 --> 01:44:12,000
>> Eu usei a palabra do vocabulario que se
Nunca vin ou foi ensinado antes.

2086
01:44:12,000 --> 01:44:14,950
E entón eu teño ensino-lo
o que esta función significa.

2087
01:44:14,950 --> 01:44:16,590
Entón, eu estou indo a ir adiante e facelo.

2088
01:44:16,590 --> 01:44:20,970
>> Eu estou indo a ir adiante e aplicar
miña propia función chamada Nome impreso.

2089
01:44:20,970 --> 01:44:27,720
E eu vou dicir, como segue, que
fai iso, printf, Ola, cento

2090
01:44:27,720 --> 01:44:30,760
s, barra invertida n, nome, punto e coma.

2091
01:44:30,760 --> 01:44:32,250
Entón, o que eu acabo de facer?

2092
01:44:32,250 --> 01:44:34,325
>> Non é que, para
aplicar a súa propia función,

2093
01:44:34,325 --> 01:44:36,845
que tipo de prestar algúns dos
a mesma estrutura principal

2094
01:44:36,845 --> 01:44:38,720
que fomos só
tida como certa, e eu

2095
01:44:38,720 --> 01:44:40,730
sabe só copiando e
colar moi fermoso o que

2096
01:44:40,730 --> 01:44:42,170
Teño escrito no pasado.

2097
01:44:42,170 --> 01:44:43,570
Pero teña en conta o nivel aquí.

2098
01:44:43,570 --> 01:44:46,750
Int, Main, Baleiro, imos desmembrar
en pouco tempo o que iso realmente significa.

2099
01:44:46,750 --> 01:44:49,160
>> Pero para hoxe, só
notar o paralelismo.

2100
01:44:49,160 --> 01:44:51,210
Baleiro, o nome de impresión,
nome de cadea, por iso hai

2101
01:44:51,210 --> 01:44:53,310
un contrasinal vermello, que
comezaremos

2102
01:44:53,310 --> 01:44:57,067
chamando un tipo de retorno, o nome do
a función, e despois da entrada.

2103
01:44:57,067 --> 01:44:59,400
Entón, en realidade, podemos destilar
este tipo de como a semana pasada

2104
01:44:59,400 --> 01:45:02,030
como, este é o nome ou o
algoritmo do código estamos

2105
01:45:02,030 --> 01:45:03,761
indo a write--
algoritmo subxacente

2106
01:45:03,761 --> 01:45:05,010
o código que vai escribir.

2107
01:45:05,010 --> 01:45:06,180
>> Esta é a súa entrada.

2108
01:45:06,180 --> 01:45:07,670
Esta é a súa saída.

2109
01:45:07,670 --> 01:45:11,730
Esta función, o nome de impresión, é
deseñados para ter unha cadea chamada nome,

2110
01:45:11,730 --> 01:45:14,350
ou o que quere, como entrada, e logo anuladas.

2111
01:45:14,350 --> 01:45:16,904
Non volve nada,
como obter corda ou obter int fai.

2112
01:45:16,904 --> 01:45:18,570
El me vai dar algo de volta.

2113
01:45:18,570 --> 01:45:20,960
É só vai ter un
efecto secundario, por así dicir,

2114
01:45:20,960 --> 01:45:22,570
de imprimir o nome dunha persoa.

2115
01:45:22,570 --> 01:45:25,260
Entón, teña en conta, liña 7, I
Pode chamar o nome de impresión.

2116
01:45:25,260 --> 01:45:28,920
Liña 10, podo axustar
ou aplicar nome de impresión.

2117
01:45:28,920 --> 01:45:31,450
Pero, desgraciadamente, isto non é suficiente.

2118
01:45:31,450 --> 01:45:34,230
>> Deixe-me ir adiante e
recompilar isto despois de gardar.

2119
01:45:34,230 --> 01:45:36,910
Whoa, agora, eu fixen iso
peor, ao parecer.

2120
01:45:36,910 --> 01:45:40,027
declaración de xeito implícito de
nome da función de impresión non é válido.

2121
01:45:40,027 --> 01:45:41,360
E, de novo, hai máis erros.

2122
01:45:41,360 --> 01:45:44,430
Pero como eu advertiu anteriormente, aínda
se queda resaltado con,

2123
01:45:44,430 --> 01:45:47,850
ou un pouco triste ver tantos
erros, concentrarse só na primeira

2124
01:45:47,850 --> 01:45:50,500
inicialmente, porque só podería
ter un efecto en fervenza.

2125
01:45:50,500 --> 01:45:54,970
Así, C, ou máis especificamente Clang,
segue a non recoñecer o nome de impresión.

2126
01:45:54,970 --> 01:45:57,580
>> E iso é porque Clang,
por deseño, é unha especie de idiota.

2127
01:45:57,580 --> 01:45:59,280
El só fai o que diga a el para facer.

2128
01:45:59,280 --> 01:46:03,950
E iso só fai iso na orde
no que diga a el para facer.

2129
01:46:03,950 --> 01:46:08,270
>> Entón, eu teño definido principal na liña de catro,
como vimos facendo bastante frecuencia.

2130
01:46:08,270 --> 01:46:10,980
Eu define o nome de impresión en liña 10.

2131
01:46:10,980 --> 01:46:14,793
Pero eu estou tentando usar
nome de impresión en liña sete.

2132
01:46:14,793 --> 01:46:16,670
>> É moi cedo, aínda non existe.

2133
01:46:16,670 --> 01:46:22,150
Así podería ser intelixente, e ser como,
OK, entón imos só xogar xunto,

2134
01:46:22,150 --> 01:46:26,680
e mover nome de impresión superior
aquí, e recompilar.

2135
01:46:26,680 --> 01:46:27,550
Meu Deus.

2136
01:46:27,550 --> 01:46:28,260
Funcionou.

2137
01:46:28,260 --> 01:46:29,670
Era tan simple como iso.

2138
01:46:29,670 --> 01:46:31,120
>> Pero a lóxica é exactamente iso.

2139
01:46:31,120 --> 01:46:33,870
Tes de ensinar o que Clang
é definindo a función primeira.

2140
01:46:33,870 --> 01:46:34,920
Logo, pode usalo.

2141
01:46:34,920 --> 01:46:36,940
Pero, francamente, este se sente
como unha ladeira escorregadia.

2142
01:46:36,940 --> 01:46:38,773
>> Así, cada vez que eu corro
nun problema, eu son só

2143
01:46:38,773 --> 01:46:42,450
vai destacar e copiar o código
Escribín, corte-lo e pegalo aquí.

2144
01:46:42,450 --> 01:46:44,370
E, por suposto, poderiamos
inventar uns escenarios

2145
01:46:44,370 --> 01:46:46,286
onde unha función pode
que chamar outra.

2146
01:46:46,286 --> 01:46:49,030
E simplemente non pode poñer todo
función enriba de calquera outro.

2147
01:46:49,030 --> 01:46:50,930
>> Non é que hai
unha solución mellor.

2148
01:46:50,930 --> 01:46:53,100
Podemos deixar este ser.

2149
01:46:53,100 --> 01:46:56,677
E, francamente, é xeralmente bo,
e cómodo, e un bo deseño

2150
01:46:56,677 --> 01:46:59,760
para poñer principal en primeiro lugar, porque, de novo,
principal só como cando a bandeira verde premendo,

2151
01:46:59,760 --> 01:47:02,027
que é a función que
corre por defecto.

2152
01:47:02,027 --> 01:47:04,110
Así, pode moi ben poñer
Lo na parte superior do ficheiro

2153
01:47:04,110 --> 01:47:06,560
de xeito que cando ou calquera
outro ser humano mira para o arquivo

2154
01:47:06,560 --> 01:47:09,360
sabe o que está a suceder
só lendo principal en primeiro lugar.

2155
01:47:09,360 --> 01:47:18,360
Non é que podemos dicir Clang
Proativo, hey, Clang, na liña catro,

2156
01:47:18,360 --> 01:47:20,940
Eu prometer para aplicar
unha función chamada impresión

2157
01:47:20,940 --> 01:47:25,600
Nome que leva o nome de cadea chamada
como entrada, e devolve nada, nula.

2158
01:47:25,600 --> 01:47:27,770
E eu vou dar a volta a
implementar lo máis tarde.

2159
01:47:27,770 --> 01:47:28,680
>> Aí vén Principal.

2160
01:47:28,680 --> 01:47:32,130
Iniciar agora na liña 9 pode usar
Imprimir Nombre porque Clang

2161
01:47:32,130 --> 01:47:35,600
é confiar en que, finalmente,
ha atopar a definición

2162
01:47:35,600 --> 01:47:37,880
da execución da impresión Name.

2163
01:47:37,880 --> 01:47:40,390
Entón, despois de salvar meu arquivo, imos
-me ir adiante e facer prototipo,

2164
01:47:40,390 --> 01:47:41,498
parece ser bo neste momento.

2165
01:47:41,498 --> 01:47:46,470
Dot cortar, prototipo, déixeme
dalle escriba un nome.

2166
01:47:46,470 --> 01:47:51,440
David, Ola David, Zamila, Ola
Zamila, e, de feito, agora funciona.

2167
01:47:51,440 --> 01:47:55,200
>> Así, o ingrediente aquí é que temos
fixo unha función personalizada, como un costume

2168
01:47:55,200 --> 01:47:57,219
bloque cero estamos chamando.

2169
01:47:57,219 --> 01:48:00,010
Pero, a diferenza do risco onde podes
só crealo e comezar a usalo,

2170
01:48:00,010 --> 01:48:02,330
agora temos que ser un
pouco máis pedante,

2171
01:48:02,330 --> 01:48:06,410
e realmente adestrar Clang
de usar, ou esperar.

2172
01:48:06,410 --> 01:48:12,140
Agora, como un aparte, por que todo este tempo ten
fomos cegamente na fe incluíndo

2173
01:48:12,140 --> 01:48:15,170
CS50.h, e incluíndo io.h defecto?

2174
01:48:15,170 --> 01:48:18,190
>> Ben, ao parecer,
entre algunhas outras cousas,

2175
01:48:18,190 --> 01:48:21,550
todo o que está naqueles dot h
arquivos, que terá lugar a ser arquivos.

2176
01:48:21,550 --> 01:48:23,460
Son arquivos de cabeceira, por así dicir.

2177
01:48:23,460 --> 01:48:26,270
Están aínda escrito en C. Pero
son un tipo de ficheiro.

2178
01:48:26,270 --> 01:48:31,690
>> De momento, pode moi ben asumir
que todo o que está dentro CS50.h

2179
01:48:31,690 --> 01:48:36,360
é algúns one-liners como este, non
para funcións chamadas Nome impreso,

2180
01:48:36,360 --> 01:48:39,840
pero para obter String, Obter
Float, e algúns outros.

2181
01:48:39,840 --> 01:48:44,510
E hai prototipos similares,
forros un, dentro io.h estándar

2182
01:48:44,510 --> 01:48:49,241
para printf, que está agora en
miña propia función Imprimir Nome.

2183
01:48:49,241 --> 01:48:52,490
Polo tanto, noutras palabras, todo este tempo temos
acaba de ser cegamente copiar e pegar

2184
01:48:52,490 --> 01:48:54,780
inclúen tanto, incluír
que, o que está pasando?

2185
01:48:54,780 --> 01:48:58,310
Estas son só un tipo de pistas
para Clang que funcións

2186
01:48:58,310 --> 01:49:03,170
son, de feito, aplicada, só
noutras posicións diferentes ficheiros

2187
01:49:03,170 --> 01:49:05,440
noutra parte do sistema.

2188
01:49:05,440 --> 01:49:08,160
>> Entón, nós temos implantado nome de impresión.

2189
01:49:08,160 --> 01:49:10,910
Ten ese efecto colateral de
imprimir algo na pantalla.

2190
01:49:10,910 --> 01:49:13,170
Pero iso non acontece, en realidade,
me dea algo de volta.

2191
01:49:13,170 --> 01:49:15,200
Como é que imos
a posta en marcha dun programa que

2192
01:49:15,200 --> 01:49:17,510
non me dar algo de volta?

2193
01:49:17,510 --> 01:49:18,580
>> Ben, imos tentar iso.

2194
01:49:18,580 --> 01:49:24,360
Deixe-me ir adiante e aplicar
un arquivo chamado return.c

2195
01:49:24,360 --> 01:49:27,530
para que poidamos demostrar como algo
como Get String, ou obter Int,

2196
01:49:27,530 --> 01:49:30,340
é, en realidade, volvendo
algo de volta para o usuario.

2197
01:49:30,340 --> 01:49:32,840
Imos adiante e establecer void main int.

2198
01:49:32,840 --> 01:49:36,230
>> E, de novo, no futuro, imos
explicar o que iso int e ese baleiro

2199
01:49:36,230 --> 01:49:37,090
é realmente facendo.

2200
01:49:37,090 --> 01:49:38,840
Pero para hoxe, imos
é un dato adquirido.

2201
01:49:38,840 --> 01:49:42,970
Eu estou indo a ir adiante e printf,
para unha boa experiencia do usuario, x é.

2202
01:49:42,970 --> 01:49:47,360
E entón eu vou esperar a
do usuario para darme x con get int.

2203
01:49:47,360 --> 01:49:51,459
>> E entón eu estou indo a ir adiante
e imprimir x ao cadrado.

2204
01:49:51,459 --> 01:49:53,500
Entón, cando só ten un
teclado, a xente comunmente

2205
01:49:53,500 --> 01:49:55,600
usar o pouco de cenoria
símbolo do teclado

2206
01:49:55,600 --> 01:49:58,330
para representar o poder
, Ou o expoñente.

2207
01:49:58,330 --> 01:50:01,960
Entón x ao cadrado está presente i.

2208
01:50:01,960 --> 01:50:03,660
>> E agora eu vou facelo.

2209
01:50:03,660 --> 01:50:06,940
Podería só fazer-- que é x
cadrado? x cadrado é x veces x.

2210
01:50:06,940 --> 01:50:09,690
>> E nós fixemos iso algo
tempo xa hoxe.

2211
01:50:09,690 --> 01:50:11,730
Este non se sente como
todo o que moito progreso.

2212
01:50:11,730 --> 01:50:12,570
Vostede sabe o que?

2213
01:50:12,570 --> 01:50:16,100
Imos aproveitar algo desa idea
a última vez de abstracción.

2214
01:50:16,100 --> 01:50:19,080
>> Non sería bo se
hai unha función chamada

2215
01:50:19,080 --> 01:50:21,460
cadrado que fai exactamente iso?

2216
01:50:21,460 --> 01:50:23,640
Aínda, a finais do
día, fai o mesmo matemáticas.

2217
01:50:23,640 --> 01:50:25,410
Pero imos abstracto
aínda que a idea de tomar

2218
01:50:25,410 --> 01:50:28,280
un número multiplicado por
outra, e só darlle un nome,

2219
01:50:28,280 --> 01:50:30,360
como conciliar ese valor.

2220
01:50:30,360 --> 01:50:32,560
>> E, por outras palabras, en
C, imos crear unha función

2221
01:50:32,560 --> 01:50:35,660
chamado cadrado que fai exactamente iso.

2222
01:50:35,660 --> 01:50:37,600
Será chamado cadrado.

2223
01:50:37,600 --> 01:50:38,790
Vai levar un int.

2224
01:50:38,790 --> 01:50:40,820
E nós imos será só
chamalo n, por defecto.

2225
01:50:40,820 --> 01:50:42,403
>> Pero poderiamos chamalo de calquera cousa que queiramos.

2226
01:50:42,403 --> 01:50:45,900
E todo o que vai
facer, literalmente, é o retorno

2227
01:50:45,900 --> 01:50:48,810
o resultado n veces n.

2228
01:50:48,810 --> 01:50:51,980
Senón porque é
retornando algo, que

2229
01:50:51,980 --> 01:50:56,690
é a palabra clave en vermello temos
nunca antes visto, I, na liña 11,

2230
01:50:56,690 --> 01:50:58,410
Non pode simplemente dicir nula neste momento.

2231
01:50:58,410 --> 01:51:04,320
>> Baleiro, no exemplo que acabamos de ver
no canto do nome de impresión, significa só,

2232
01:51:04,320 --> 01:51:05,190
facer algo.

2233
01:51:05,190 --> 01:51:07,170
Pero non me deixa algo de volta.

2234
01:51:07,170 --> 01:51:09,790
Neste caso, quero
para volver N N veces,

2235
01:51:09,790 --> 01:51:11,460
ou o que quere que sexa, este número.

2236
01:51:11,460 --> 01:51:15,460
>> Entón eu non podo dicir, hey, ordenador,
I voltar nada, o baleiro.

2237
01:51:15,460 --> 01:51:19,166
Vai volver, por natureza, un int.

2238
01:51:19,166 --> 01:51:20,790
E entón iso é todo o que está pasando aquí.

2239
01:51:20,790 --> 01:51:23,070
>> A entrada ao cadrado
será un int.

2240
01:51:23,070 --> 01:51:27,760
E para que poidamos usalo, ten que
ten un nome, N. Vai saída

2241
01:51:27,760 --> 01:51:29,240
un int que non precisa dun nome.

2242
01:51:29,240 --> 01:51:32,590
Podemos deixalo ao principal, ou quen queira que sexa
utilizándose me a lembrar este valor

2243
01:51:32,590 --> 01:51:34,120
quere coa súa propia variable.

2244
01:51:34,120 --> 01:51:36,230
>> E, unha vez máis, a única nova
palabra clave aquí é Return.

2245
01:51:36,230 --> 01:51:37,480
E eu estou só facendo un pouco de matemáticas.

2246
01:51:37,480 --> 01:51:44,825
Se realmente quería ser innecesario,
Podería dicir do produto int recibe n veces n.

2247
01:51:44,825 --> 01:51:47,170
>> E entón eu podería dicir, o produto voltar.

2248
01:51:47,170 --> 01:51:50,360
Pero, de novo, para o meu punto anterior do
iso só non ser bo design--

2249
01:51:50,360 --> 01:51:53,060
como, por introducir un nome,
un símbolo, como produto,

2250
01:51:53,060 --> 01:51:54,570
só para devolve-lo inmediatamente?

2251
01:51:54,570 --> 01:51:56,670
É un pouco máis limpo,
un pouco máis axustado, polo que

2252
01:51:56,670 --> 01:52:02,380
para falar, só para dicir retorno n veces
n, librar-se desta liña por completo.

2253
01:52:02,380 --> 01:52:05,860
>> E é só menos código para ler,
menos oportunidades para erros.

2254
01:52:05,860 --> 01:52:08,180
E imos ver se este
en realidade, traballa agora.

2255
01:52:08,180 --> 01:52:12,380
Agora, eu estou indo a ir
adiante e facer o retorno.

2256
01:52:12,380 --> 01:52:14,460
>> Uh-oh, declaración implícita da función.

2257
01:52:14,460 --> 01:52:17,080
Eu cometín este erro antes, non é gran cousa.

2258
01:52:17,080 --> 01:52:21,950
Déixeme só escribir ou destacar e
copiar, exactamente a mesma función prototipo,

2259
01:52:21,950 --> 01:52:24,342
ou sinatura, da función ata aquí.

2260
01:52:24,342 --> 01:52:25,800
Ou eu podería mover toda a función.

2261
01:52:25,800 --> 01:52:26,841
>> Pero iso é algo perezoso.

2262
01:52:26,841 --> 01:52:27,870
Polo tanto, non imos facelo.

2263
01:52:27,870 --> 01:52:30,960
Agora, deixe-me facer o retorno
unha vez máis, o punto de retorno barra.

2264
01:52:30,960 --> 01:52:35,790
>> x é 2. x ao cadrado é 4.
x é 3. x ao cadrado é 9.

2265
01:52:35,790 --> 01:52:38,300
E a función parece
agora estar funcionando.

2266
01:52:38,300 --> 01:52:39,550
Entón, cal é a diferenza aquí?

2267
01:52:39,550 --> 01:52:45,520
Eu teño unha función que se chama cadrado,
neste caso, que me puxen nunha entrada.

2268
01:52:45,520 --> 01:52:46,830
E eu volver unha saída.

2269
01:52:46,830 --> 01:52:49,210
E aínda, con anterioridade, se
Abro outro exemplo

2270
01:52:49,210 --> 01:52:54,640
de antes, o que
chamouse prototype.c,

2271
01:52:54,640 --> 01:52:57,770
Eu tiña o nome de impresión, que
volveu baleiro, por así dicir,

2272
01:52:57,770 --> 01:53:01,730
Ou voltou nada e
simplemente tiña un efecto colateral.

2273
01:53:01,730 --> 01:53:03,230
>> Entón, o que está pasando aquí?

2274
01:53:03,230 --> 01:53:06,520
Ben, considere a función
obter cadea por só un momento.

2275
01:53:06,520 --> 01:53:09,570
Temos benvida a empregar a función
obter secuencia do seguinte xeito.

2276
01:53:09,570 --> 01:53:13,464
>> Tivemos unha función de obter
corda, como incluír CS50.h,

2277
01:53:13,464 --> 01:53:19,624
inclúen estándar io.h, int, principal, nula.

2278
01:53:19,624 --> 01:53:21,790
E, a continuación, cada vez que eu teño
chamada cadea get ata agora,

2279
01:53:21,790 --> 01:53:26,260
Eu dixen algo, corda s
recibe obter corda, porque get string--

2280
01:53:26,260 --> 01:53:30,880
Imos chamar esa cadea get get.c--
-Se devolve unha cadea que podo, entón,

2281
01:53:30,880 --> 01:53:35,050
usar, e dicir, Ola, coma,
por cento s, barra invertida n, s.

2282
01:53:35,050 --> 01:53:38,660
>> Polo tanto, este é o mesmo exemplo,
Realmente, que tiñamos antes.

2283
01:53:38,660 --> 01:53:40,920
Polo tanto, obter secuencia retorna un valor.

2284
01:53:40,920 --> 01:53:44,260
Pero hai pouco, secuencia de impresión
non retorna un valor.

2285
01:53:44,260 --> 01:53:45,721
Simplemente ten efectos secundarios.

2286
01:53:45,721 --> 01:53:47,220
Polo tanto, esta é unha diferenza fundamental.

2287
01:53:47,220 --> 01:53:49,710
Vimos diferente
tipo de funcións agora,

2288
01:53:49,710 --> 01:53:52,490
algúns dos cales retornar
valores, algúns dos cales non.

2289
01:53:52,490 --> 01:53:54,890
Entón quizais sexa cadea, ou int ou float.

2290
01:53:54,890 --> 01:53:56,480
Ou quizais sexa só en branco.

2291
01:53:56,480 --> 01:53:58,710
>> E é a diferenza
que estas funcións que

2292
01:53:58,710 --> 01:54:02,940
obter datos e voltar un valor son realmente
traendo algo de volta á mesa,

2293
01:54:02,940 --> 01:54:04,110
por así dicir.

2294
01:54:04,110 --> 01:54:06,710
Entón, imos adiante e
mirar para un conxunto final

2295
01:54:06,710 --> 01:54:12,129
de exemplos que dá unha sensación, agora,
como podemos, de feito, abstracto mellor,

2296
01:54:12,129 --> 01:54:14,670
e mellor, e mellor, ou máis,
e máis, e máis, a fin

2297
01:54:14,670 --> 01:54:16,810
para escribir, en definitiva, un código mellor.

2298
01:54:16,810 --> 01:54:19,860
Imos adiante, e no espírito
do Scratch, faga o seguinte.

2299
01:54:19,860 --> 01:54:24,700
>> Deixe-me ir adiante e inclúen
CS50.h e IO.h. estándar

2300
01:54:24,700 --> 01:54:27,010
Deixe-me ir adiante e dar
me un int, principal, nula.

2301
01:54:27,010 --> 01:54:30,380
E deixe-me ir adiante, chame este cough.c.

2302
01:54:30,380 --> 01:54:38,510
>> E deixe-me ir adiante e só
como cero, imprima a tose / n.

2303
01:54:38,510 --> 01:54:40,170
E quero facelo tres veces.

2304
01:54:40,170 --> 01:54:42,670
Entón, eu estou, por suposto, só vai
para copiar e pegar tres veces.

2305
01:54:42,670 --> 01:54:49,440
Estou indo agora para facer
tos tos barra de punto.

2306
01:54:49,440 --> 01:54:53,120
Imos dar-me un pouco máis de espazo
aquí, Intro, tose, tose, tose.

2307
01:54:53,120 --> 01:54:56,970
>> Hai, obviamente, xa un
oportunidade de mellora.

2308
01:54:56,970 --> 01:54:58,679
Copiei e colei
algunhas veces hoxe.

2309
01:54:58,679 --> 01:55:01,261
Pero iso foi só para que eu non fixen
Ten que escribir cantos caracteres.

2310
01:55:01,261 --> 01:55:03,250
Eu cambiou o que
estas liñas de código son.

2311
01:55:03,250 --> 01:55:07,240
>> Estes tres liñas son idénticos,
que se sente preguiceiro e de feito é,

2312
01:55:07,240 --> 01:55:10,110
e probablemente non é a visión correcta.

2313
01:55:10,110 --> 01:55:14,029
Así, co ingrediente
poderiamos mellorar este código?

2314
01:55:14,029 --> 01:55:15,570
Non debemos copiar e pegar o código.

2315
01:55:15,570 --> 01:55:18,070
>> E, de feito, cando sente
-Se copiar e pegar,

2316
01:55:18,070 --> 01:55:20,700
e nin mesmo cambiar o código,
posibilidades son de que hai un xeito mellor.

2317
01:55:20,700 --> 01:55:22,470
E, de feito, non existe.

2318
01:55:22,470 --> 01:55:25,510
Deixe-me ir adiante e facer un loop for,
aínda que a sintaxe non pode

2319
01:55:25,510 --> 01:55:27,570
vén naturalmente aínda.

2320
01:55:27,570 --> 01:55:32,494
>> Faino tres veces, simplemente
facendo o following--

2321
01:55:32,494 --> 01:55:34,160
E resulta que eu sei que iso a partir da práctica.

2322
01:55:34,160 --> 01:55:35,810
Pero temos unha serie de exemplos agora.

2323
01:55:35,810 --> 01:55:37,950
E vai ver en liña
máis referencias fixas.

2324
01:55:37,950 --> 01:55:40,790
>> Esta é a sintaxe en liña 6, que
así como do risco que se repite

2325
01:55:40,790 --> 01:55:43,090
bloque, repita os seguintes tres veces.

2326
01:55:43,090 --> 01:55:44,340
É un pouco máxico para agora.

2327
01:55:44,340 --> 01:55:46,050
Pero iso vai ser máis,
e máis familiar.

2328
01:55:46,050 --> 01:55:48,050
>> E vai repetir
liña de oito por tres veces,

2329
01:55:48,050 --> 01:55:55,390
de xeito que se eu re-compilar make tose,
dot cortar tose, tose, tose, tose.

2330
01:55:55,390 --> 01:55:57,030
Aínda funciona do mesmo xeito.

2331
01:55:57,030 --> 01:55:58,550
Entón, iso é todo moi ben e bo.

2332
01:55:58,550 --> 01:56:01,200
Pero iso non é moi abstraída.

2333
01:56:01,200 --> 01:56:02,371
>> É perfectamente correcto.

2334
01:56:02,371 --> 01:56:04,370
Pero parece que hai
podería ser unha oportunidade,

2335
01:56:04,370 --> 01:56:06,750
como no mundo de
Cero, ao tipo de inicio

2336
01:56:06,750 --> 01:56:10,530
engadir algúns semántica para que
Non só ter algún lazo for,

2337
01:56:10,530 --> 01:56:12,867
e unha función que se
tossir ou non tossir.

2338
01:56:12,867 --> 01:56:13,450
Vostede sabe o que?

2339
01:56:13,450 --> 01:56:15,620
Déixeme probar ser un
pouco máis frío do que iso,

2340
01:56:15,620 --> 01:56:19,090
e realmente escribir unha función que
ten algúns efectos secundarios, chamalo tossir.

2341
01:56:19,090 --> 01:56:23,830
>> E non ten entrada e
non retorna ningún valor como saída.

2342
01:56:23,830 --> 01:56:25,680
Pero vostede sabe o que fai?

2343
01:56:25,680 --> 01:56:32,370
Fai isto-- printf,
entre comiñas, tossir.

2344
01:56:32,370 --> 01:56:35,380
>> E agora aquí enriba, eu vou
ir adiante e para int,

2345
01:56:35,380 --> 01:56:39,070
i recibe cero, i inferior a 3, i plus plus.

2346
01:56:39,070 --> 01:56:42,770
Eu estou indo a non facer printf, que é
sen dúbida unha implementación de baixo nivel

2347
01:56:42,770 --> 01:56:43,270
detalle.

2348
01:56:43,270 --> 01:56:44,353
Eu non me importa como tusir.

2349
01:56:44,353 --> 01:56:46,240
Eu só quero usar a función de tose.

2350
01:56:46,240 --> 01:56:47,840
E eu estou indo só para chamar tose.

2351
01:56:47,840 --> 01:56:49,204
>> Agora, teña en conta a dicotomía.

2352
01:56:49,204 --> 01:56:52,370
Cando chamar unha función, se non o fai
quero darlle entradas, totalmente ben.

2353
01:56:52,370 --> 01:56:54,780
Só ten que facer o paréntese aberta, preto
paréntese, e está feito.

2354
01:56:54,780 --> 01:56:59,271
>> Cando define unha función, ou
declarar un prototipo de función,

2355
01:56:59,271 --> 01:57:01,770
Se sabe de antemán que non é
Vai tomar calquera argumentos,

2356
01:57:01,770 --> 01:57:04,170
dicir nula naqueles parénteses alí.

2357
01:57:04,170 --> 01:57:08,660
E iso fai seguro de que
non accidentalmente abusar dela.

2358
01:57:08,660 --> 01:57:10,020
Deixe-me ir adiante e facer tose.

2359
01:57:10,020 --> 01:57:11,540
E, por suposto, eu cometín un erro.

2360
01:57:11,540 --> 01:57:13,410
>> Drogas, hai que
declaración implícita.

2361
01:57:13,410 --> 01:57:14,325
Pero iso é bo.

2362
01:57:14,325 --> 01:57:15,590
É un reparación doado.

2363
01:57:15,590 --> 01:57:21,240
Eu só teño o prototipo máis arriba
no meu arquivo do que eu estou realmente empregar.

2364
01:57:21,240 --> 01:57:23,070
>> Entón, agora déixeme facer tose novo, agradable.

2365
01:57:23,070 --> 01:57:23,790
Agora funciona.

2366
01:57:23,790 --> 01:57:25,930
Fai tose, tose, tose, tose.

2367
01:57:25,930 --> 01:57:28,930
Entón pode pensar que estamos realmente
pouco máis de enxeñaría este problema.

2368
01:57:28,930 --> 01:57:29,763
E, de feito, somos.

2369
01:57:29,763 --> 01:57:31,870
Este non é un bo
candidato dun programa

2370
01:57:31,870 --> 01:57:34,930
no momento de
refatoração, e facer o que é

2371
01:57:34,930 --> 01:57:38,645
chamado de descomposición xerárquica,
onde toma un código, e logo

2372
01:57:38,645 --> 01:57:41,790
vostede tipo de factor de cousas para fóra, así como
asignar máis semántica para eles,

2373
01:57:41,790 --> 01:57:43,930
e reutiliza-lo en definitiva, a longo prazo.

2374
01:57:43,930 --> 01:57:46,490
Pero é un bloque de construción en dirección
programas máis sofisticados

2375
01:57:46,490 --> 01:57:48,600
que imos comezar
escribir en pouco tempo que

2376
01:57:48,600 --> 01:57:53,090
permítenos ter o vocabulario
co cal a escribir mellor código.

2377
01:57:53,090 --> 01:57:55,920
E, de feito, imos ver se nós
Non se pode xeneralizar este proxecto.

2378
01:57:55,920 --> 01:58:00,984
>> Parece un pouco lame que, de inicio,
se preocupe este danado para loop,

2379
01:58:00,984 --> 01:58:02,400
e chamando a tose novo e de novo.

2380
01:58:02,400 --> 01:58:06,050
Por que non podo só dicir tose,
tussa tres veces?

2381
01:58:06,050 --> 01:58:11,170
Noutras palabras, por que non podo só
dar entrada a tossir e facelo?

2382
01:58:11,170 --> 01:58:14,270
>> Por que non podo só dicir, en
principal tose tres veces.

2383
01:58:14,270 --> 01:58:16,150
E agora, este é o tipo de maxia.

2384
01:58:16,150 --> 01:58:17,540
É moi iterativo aquí.

2385
01:58:17,540 --> 01:58:18,940
E é, de feito, un pequeno paso.

2386
01:58:18,940 --> 01:58:22,250
>> Pero só a capacidade de dicir
liña oito, tose por tres veces,

2387
01:58:22,250 --> 01:58:23,730
é só moito máis lexible.

2388
01:58:23,730 --> 01:58:27,210
E, ademais, eu non teño que saber
ou coidado como tose é aplicado.

2389
01:58:27,210 --> 01:58:29,460
E, de feito, a finais do
prazo e para proxectos finais,

2390
01:58:29,460 --> 01:58:32,150
Se afrontar un proxecto con
un compañeiro ou dous compañeiros,

2391
01:58:32,150 --> 01:58:35,370
notarás que está indo
Ten que, ou se quere, dividir o traballo.

2392
01:58:35,370 --> 01:58:37,650
>> E vai querer decidir
de antelación, quen vai facer o que,

2393
01:58:37,650 --> 01:58:38,483
e en que pezas?

2394
01:58:38,483 --> 01:58:40,520
E non sería bo
Se, por exemplo,

2395
01:58:40,520 --> 01:58:43,100
asumir o mando da escrita principal, feito.

2396
01:58:43,100 --> 01:58:46,470
E o seu compañeiro de cuarto, ou o seu
socio dun modo máis xeral,

2397
01:58:46,470 --> 01:58:48,230
coida da posta en marcha de tose.

2398
01:58:48,230 --> 01:58:52,540
>> E esa división, estes
paredes de abstracción,

2399
01:58:52,540 --> 01:58:55,310
ou capas de abstracción se
vai, son super poderoso,

2400
01:58:55,310 --> 01:58:58,480
porque todo para maior,
máis programas e sistemas complexos,

2401
01:58:58,480 --> 01:59:03,070
Permite que varias persoas para construír
cousas xuntos, e finalmente

2402
01:59:03,070 --> 01:59:05,680
coser o seu traballo en conxunto deste xeito.

2403
01:59:05,680 --> 01:59:08,332
Pero, por suposto, nós
Debe agora corrixir tose.

2404
01:59:08,332 --> 01:59:10,290
Necesitamos dicir a tose
que, hey, vostede sabe o que?

2405
01:59:10,290 --> 01:59:14,230
Vai ter que tomar un
input-- por iso non baleiro, pero int e agora.

2406
01:59:14,230 --> 01:59:18,170
Imos adiante e poñer en
tos do int. i recibe cero.

2407
01:59:18,170 --> 01:59:19,890
>> i é menos que o número de veces.

2408
01:59:19,890 --> 01:59:21,550
Eu dixen tres antes.

2409
01:59:21,550 --> 01:59:23,420
Pero non é iso que eu quero.

2410
01:59:23,420 --> 01:59:28,520
Quero tossir para ser xeneralizado para
soportar calquera número de iteracións.

2411
01:59:28,520 --> 01:59:31,800
>> Entón, en realidade, é n que quero,
todo o que o usuario dime.

2412
01:59:31,800 --> 01:59:34,620
Agora, podo ir adiante e dicir tose impresión.

2413
01:59:34,620 --> 01:59:37,750
E non importa o número de
o usuario pasa,

2414
01:59:37,750 --> 01:59:39,890
Vou facer unha iteración que moitas veces.

2415
01:59:39,890 --> 01:59:42,160
>> Así, ao final do día,
programa é o mesmo.

2416
01:59:42,160 --> 01:59:45,820
Pero teña en conta todas estas cousas
Pode até ser noutro ficheiro.

2417
01:59:45,820 --> 01:59:48,620
En realidade, eu non sei o
momento, como printf é aplicado.

2418
01:59:48,620 --> 01:59:50,980
>> Non sei no momento como chegar
corda, ou obter int, ou obter flotador

2419
01:59:50,980 --> 01:59:51,646
son aplicadas.

2420
01:59:51,646 --> 01:59:53,930
E eu non quero
velos na pantalla do meu.

2421
01:59:53,930 --> 01:59:58,320
Como é, eu estou empezando a se concentrar en
meu programa, non estas funcións.

2422
01:59:58,320 --> 02:00:02,070
>> E así, de feito, tan pronto
comezar factoring código como este para fóra,

2423
02:00:02,070 --> 02:00:04,397
Nós ata podía mover tose
a un arquivo separado?

2424
02:00:04,397 --> 02:00:05,730
Alguén máis podería implementar lo.

2425
02:00:05,730 --> 02:00:09,810
E vostede eo seu programa de chegar a ser o
moi bonito, e moi lexible,

2426
02:00:09,810 --> 02:00:13,830
sen dúbida, realmente catro
programa de liña alí.

2427
02:00:13,830 --> 02:00:16,510
>> Entón, imos adiante agora
e facer unha mudanza.

2428
02:00:16,510 --> 02:00:19,180
Teña en conta que o meu prototipo
ten que cambiar enriba.

2429
02:00:19,180 --> 02:00:21,390
Entón deixe-me corrixir isto así
Non obter berrou.

2430
02:00:21,390 --> 02:00:25,580
>> Fai tose, deixarme correr tose xa
máis, aínda facendo o mesmo.

2431
02:00:25,580 --> 02:00:29,010
Pero agora, entender que temos unha
ingrediente para unha versión final.

2432
02:00:29,010 --> 02:00:29,940
Vostede sabe o que?

2433
02:00:29,940 --> 02:00:32,040
Non quero só tose, necesariamente.

2434
02:00:32,040 --> 02:00:33,802
Eu quero ter algo máis xeral.

2435
02:00:33,802 --> 02:00:34,510
Entón vostede sabe o que?

2436
02:00:34,510 --> 02:00:35,450
Eu quero facelo.

2437
02:00:35,450 --> 02:00:40,140
Quero ter, así como do risco
fai, un bloque por exemplo, pero non só

2438
02:00:40,140 --> 02:00:41,680
dicir algo un determinado número de veces.

2439
02:00:41,680 --> 02:00:44,510
Quero dicir unha secuencia moi específica.

2440
02:00:44,510 --> 02:00:46,850
E, polo tanto, non sei
queres que acaba de dicir tose.

2441
02:00:46,850 --> 02:00:50,660
Quero dicir o que quere
cadea é pasado.

2442
02:00:50,660 --> 02:00:52,960
>> Entón, teña en conta, eu xeneralizada
isto para que agora

2443
02:00:52,960 --> 02:00:56,110
digamos se sente como un bo nome
para iso, como o risco,

2444
02:00:56,110 --> 02:00:58,530
leva dous argumentos, ao contrario cero.

2445
02:00:58,530 --> 02:00:59,570
Un deles é un string.

2446
02:00:59,570 --> 02:01:00,300
Un deles é un int.

2447
02:01:00,300 --> 02:01:01,130
>> E eu podería muda-los.

2448
02:01:01,130 --> 02:01:03,713
Eu medio que me gusta a idea de
din que a corda primeiro, e despois

2449
02:01:03,713 --> 02:01:04,940
cantas veces posteriores.

2450
02:01:04,940 --> 02:01:06,970
Baleiro significa aínda
non retorna nada.

2451
02:01:06,970 --> 02:01:09,428
Estes son só lado visual
efectos, como con [? Jordan ,?]

2452
02:01:09,428 --> 02:01:11,240
efectos secundarios verbal de berrar.

2453
02:01:11,240 --> 02:01:15,630
Inda fai algo n veces,
0 ata, pero non igual a n.

2454
02:01:15,630 --> 02:01:17,540
Isto significa n veces en total.

2455
02:01:17,540 --> 02:01:19,540
E despois é só imprimir
o que quere que esta cadea é.

2456
02:01:19,540 --> 02:01:22,060
Entón, realmente xeneralizada
esta liña de código.

2457
02:01:22,060 --> 02:01:25,460
Entón, agora, como fago para aplicar
a función de tose?

2458
02:01:25,460 --> 02:01:28,520
>> Podo facer tose baleiro.

2459
02:01:28,520 --> 02:01:31,501
E eu aínda podo tomar como
moitas veces quere a tossir.

2460
02:01:31,501 --> 02:01:32,250
Pero vostede sabe o que?

2461
02:01:32,250 --> 02:01:34,240
agora podo chutar a dicir.

2462
02:01:34,240 --> 02:01:39,540
>> Podo chamar dicir co
palabra tose, pasando n.

2463
02:01:39,540 --> 02:01:43,410
E se eu queira aplicar tamén,
só por diversión, unha función espirro,

2464
02:01:43,410 --> 02:01:45,290
I pode Espirrar un determinado número de veces.

2465
02:01:45,290 --> 02:01:50,300
E podo manter reutilizando n, porque
ter en conta que m neste contexto ou extensión

2466
02:01:50,300 --> 02:01:52,470
só existe dentro desa función.

2467
02:01:52,470 --> 02:01:55,767
>> E n neste contexto só
existe dentro desta función aquí.

2468
02:01:55,767 --> 02:01:57,600
Entón, imos volver
estas cuestións de ámbito.

2469
02:01:57,600 --> 02:02:04,160
E aquí, eu só vou dicir,
Achoo e logo n veces, punto e coma.

2470
02:02:04,160 --> 02:02:07,340
>> E agora, eu só precisa tomar prestado
estas funcións sinaturas ata aquí.

2471
02:02:07,340 --> 02:02:09,290
Entón tose é correcto.

2472
02:02:09,290 --> 02:02:13,090
espirro baleiro é correcta agora.

2473
02:02:13,090 --> 02:02:15,390
>> E eu aínda só precisa dicir.

2474
02:02:15,390 --> 02:02:21,990
Entón eu vou dicir, digamos
cadea s, int n, punto e coma.

2475
02:02:21,990 --> 02:02:25,010
Entón, eu teño máis de enxeñaría do
Parreira fóra deste programa.

2476
02:02:25,010 --> 02:02:26,760
>> E iso non fai
significa necesariamente que se trata

2477
02:02:26,760 --> 02:02:29,343
o que debe facer cando se escribe
mesmo o máis simple dos programas.

2478
02:02:29,343 --> 02:02:32,280
Tomé algo que é, obviamente,
moi sinxelo, moi curto,

2479
02:02:32,280 --> 02:02:34,800
e re-lo aplicar
usando xeito moi código.

2480
02:02:34,800 --> 02:02:37,560
Pero vai realmente ver, e en
tempo de ollar cara atrás sobre estes exemplos,

2481
02:02:37,560 --> 02:02:41,610
e entender, oh, estes son os pasos
tomamos para realmente xeneralizar,

2482
02:02:41,610 --> 02:02:43,797
fatorar algo fóra,
ata o final do día

2483
02:02:43,797 --> 02:02:45,380
meu código é realmente moi razoable.

2484
02:02:45,380 --> 02:02:48,960
Porque se eu queira tossir tres
veces, a continuación, espirrar tres veces,

2485
02:02:48,960 --> 02:02:53,420
Eu estou indo simplemente para realizar de novo este,
programa facer tose, e realizar tose.

2486
02:02:53,420 --> 02:02:56,620
E eu teño tres toses
e tres espirra.

2487
02:02:56,620 --> 02:02:58,990
>> E por iso este é un básicos
paradigma, se quixeren,

2488
02:02:58,990 --> 02:03:03,110
de como podemos ir sobre
en realidade, a posta en marcha dun programa.

2489
02:03:03,110 --> 02:03:06,220
Pero imos ver agora o que é
temos está a facer todo este tempo,

2490
02:03:06,220 --> 02:03:09,940
e que algunhas das pezas finais
están detrás desta simple comando.

2491
02:03:09,940 --> 02:03:12,620
Ao final do día, temos
benvida a empregar Clang como o noso compilador.

2492
02:03:12,620 --> 02:03:14,494
Vimos escribir fonte
código, convertendo-

2493
02:03:14,494 --> 02:03:15,820
vía Clang en código máquina.

2494
02:03:15,820 --> 02:03:18,540
>> E nós temos que chegou a empregar facer só
para facilitar as nosas combinacións de teclas para

2495
02:03:18,540 --> 02:03:23,740
que non ten que lembrar
eses encantamentos de si Clang.

2496
02:03:23,740 --> 02:03:25,640
Pero o que é facer realmente facendo?

2497
02:03:25,640 --> 02:03:27,750
E, á súa vez, o que é
Clang realmente facendo?

2498
02:03:27,750 --> 02:03:31,790
>> Acontece que, aínda que simplificado
a discusión de hoxe, dicindo:

2499
02:03:31,790 --> 02:03:36,090
toma código fonte, pasalo como
entrada para un compilador, que lle dá

2500
02:03:36,090 --> 02:03:38,750
saída da máquina
código, acontece que hai

2501
02:03:38,750 --> 02:03:40,420
algúns pasos diferentes dentro alí.

2502
02:03:40,420 --> 02:03:44,940
E compilación pasa a ser o paraugas
prazo para todo un conxunto de pasos.

2503
02:03:44,940 --> 02:03:46,970
Pero imos só provocalo
isto moi rapidamente.

2504
02:03:46,970 --> 02:03:51,070
>> Acontece que temos está a facer
máis cousas cada vez que eu executar un programa,

2505
02:03:51,070 --> 02:03:53,990
ou cada vez que eu compilar un programa hoxe.

2506
02:03:53,990 --> 02:03:58,020
Así, o pre-procesamento refírese a
isto-- algo nun programa C,

2507
02:03:58,020 --> 02:04:01,720
como veremos de novo e de novo,
que comeza con este símbolo de hash,

2508
02:04:01,720 --> 02:04:06,320
ou o símbolo hashtag aquí, significa
é un pre-procesador directiva.

2509
02:04:06,320 --> 02:04:10,330
Isto significa que, neste caso, ei
ordenador, facer algo con este ficheiro

2510
02:04:10,330 --> 02:04:12,430
antes de que realmente compilar meu propio código.

2511
02:04:12,430 --> 02:04:18,220
>> Neste caso, de hash inclúen sexa,
esencialmente, forma de dicir do C,

2512
02:04:18,220 --> 02:04:22,325
hey ordenador, ir buscar o contido
de CS50.h e cola-los aquí.

2513
02:04:22,325 --> 02:04:25,170
Hey ordenador, ir buscar o
contido de io.h estándar,

2514
02:04:25,170 --> 02:04:27,690
onde queira que sexa sobre o
disco duro, pegalo aquí.

2515
02:04:27,690 --> 02:04:30,390
Entón, estas cousas acontecen
por primeira vez durante o pre-procesamento.

2516
02:04:30,390 --> 02:04:31,880
>> E Clang fai todo isto para nós.

2517
02:04:31,880 --> 02:04:33,510
E faino tan danado
rápido, nin sequera

2518
02:04:33,510 --> 02:04:35,000
ver catro cousas distintas ocorrer.

2519
02:04:35,000 --> 02:04:37,100
Pero esa é a primeira tal paso.

2520
02:04:37,100 --> 02:04:38,560
>> O que realmente ocorre logo?

2521
02:04:38,560 --> 02:04:41,320
Ben, o próximo oficial
paso é a compilación.

2522
02:04:41,320 --> 02:04:43,385
E verifícase que
compilar un programa

2523
02:04:43,385 --> 02:04:47,060
tecnicamente significa que vai de
código fonte, as cousas que teño

2524
02:04:47,060 --> 02:04:50,890
foi escrito hoxe, para algo
chamado código de montaxe, algo

2525
02:04:50,890 --> 02:04:52,260
que parece un pouco diferente.

2526
02:04:52,260 --> 02:04:54,050
>> E, de feito, podemos ver que moi rápido.

2527
02:04:54,050 --> 02:04:56,890
Déixeme realmente ir ao meu IDE.

2528
02:04:56,890 --> 02:05:01,050
Deixe-me ir adiante e hello.c aberta, que
é o primeiro programa co que nós

2529
02:05:01,050 --> 02:05:02,120
comezou hoxe.

2530
02:05:02,120 --> 02:05:07,130
E deixe-me ir adiante e executar Clang un
pouco distinto, Clang-s, hello.c,

2531
02:05:07,130 --> 02:05:10,720
que está indo realmente para
Déame outra hello.s de ficheiro.

2532
02:05:10,720 --> 02:05:13,330
>> E nós probablemente nunca será
novo ver este tipo de código.

2533
02:05:13,330 --> 02:05:16,030
Se tomar un nivel máis baixo
sistemas de clase como CS61,

2534
02:05:16,030 --> 02:05:17,920
vai ver moito máis
deste tipo de código.

2535
02:05:17,920 --> 02:05:20,020
Pero esta é a linguaxe assembly.

2536
02:05:20,020 --> 02:05:25,050
Este é X86 linguaxe assembly
que a CPU que está subxacente

2537
02:05:25,050 --> 02:05:27,460
CS50 IDE realmente entende.

2538
02:05:27,460 --> 02:05:30,060
>> E enigmática como fai
ollar, é algo

2539
02:05:30,060 --> 02:05:32,180
o ordenador entende moi ben.

2540
02:05:32,180 --> 02:05:33,790
Sub Q, isto é un substrato.

2541
02:05:33,790 --> 02:05:34,660
Hai movementos.

2542
02:05:34,660 --> 02:05:38,730
>> Non está chamando de funcións aquí,
x oring, un movemento, un complemento, un pop,

2543
02:05:38,730 --> 02:05:39,430
un retorno.

2544
02:05:39,430 --> 02:05:41,850
Polo tanto, hai algúns moi
instrucións de baixo nivel

2545
02:05:41,850 --> 02:05:44,280
que CPUs entender que
Aludi anteriormente.

2546
02:05:44,280 --> 02:05:46,100
Iso é o que Intel Inside.

2547
02:05:46,100 --> 02:05:48,030
>> Existen patróns de
ceros e uns que

2548
02:05:48,030 --> 02:05:54,800
mapear a estes redactado arcanely pero
algo así nomeado, instrucións,

2549
02:05:54,800 --> 02:05:55,780
por así dicir.

2550
02:05:55,780 --> 02:05:57,780
Isto é o que ocorre cando
compilar o código.

2551
02:05:57,780 --> 02:06:01,560
Comeza a montaxe
lingua de fóra, o que

2552
02:06:01,560 --> 02:06:07,680
significa que o terceiro paso é para montar
que o código assembly para, en definitiva,

2553
02:06:07,680 --> 02:06:12,080
Máquina de ceros code-- e uns, non os
texto que acabamos de ver un momento atrás.

2554
02:06:12,080 --> 02:06:16,370
>> Así, pre-procesamento que iso atopar
e substituír, e algunhas outras cousas.

2555
02:06:16,370 --> 02:06:19,430
Compilando leva a súa fonte
código de C, o código fonte

2556
02:06:19,430 --> 02:06:21,980
que escribiu, para montaxe
código que só mirou.

2557
02:06:21,980 --> 02:06:25,170
Montaxe leva que a montaxe
código para ceros e uns

2558
02:06:25,170 --> 02:06:27,680
que o CPU vai realmente
comprender, ao final do día.

2559
02:06:27,680 --> 02:06:30,630
E vinculación é a última etapa
que pasa a US-- novo,

2560
02:06:30,630 --> 02:06:32,830
tan rápido que nin sequera
notice-- que di:

2561
02:06:32,830 --> 02:06:35,460
hey ordenador, tomar todas
os ceros e uns que

2562
02:06:35,460 --> 02:06:39,750
resultou de compilar o código de David,
ea súa principal función neste caso.

2563
02:06:39,750 --> 02:06:42,160
>> E ei ordenador, ir buscar
todo ceros e uns

2564
02:06:42,160 --> 02:06:45,180
que o equipo CS50 escribiu
dentro da biblioteca CS50.

2565
02:06:45,180 --> 02:06:46,440
Mestura aqueles con David.

2566
02:06:46,440 --> 02:06:49,648
E ei ordenador, ir buscar todos os ceros
e os que alguén escribiu anos

2567
02:06:49,648 --> 02:06:50,470
atrás para printf.

2568
02:06:50,470 --> 02:06:52,880
E engadir aqueles para o
cousa toda, de xeito que temos

2569
02:06:52,880 --> 02:06:55,870
teño os meus ceros e uns, a
ceros e uns do persoal CS50,

2570
02:06:55,870 --> 02:06:58,370
os ceros e uns, printf
e calquera outra cousa que estamos a usar.

2571
02:06:58,370 --> 02:07:03,410
>> Todos eles se combinados nun
programa chamado neste caso Hola.

2572
02:07:03,410 --> 02:07:06,141
Entón, de agora en diante, imos só
usar a palabra compilación.

2573
02:07:06,141 --> 02:07:09,390
E imos tomar como certo que, cando
dicimos, compilar o seu programa, é dicir,

2574
02:07:09,390 --> 02:07:11,849
hey facer o pre-procesamento,
montaxe e conexión.

2575
02:07:11,849 --> 02:07:14,890
Pero hai realmente algunhas cousas suculenta
pasando alí debaixo do capó.

2576
02:07:14,890 --> 02:07:16,723
E especialmente se
estar curioso algún tempo,

2577
02:07:16,723 --> 02:07:18,900
pode comezar a picar
en torno a este nivel inferior.

2578
02:07:18,900 --> 02:07:22,660
Pero, por agora, entender que
entre os temas para hoxe

2579
02:07:22,660 --> 02:07:26,420
son pura e simplemente o
inicio dun proceso,

2580
02:07:26,420 --> 02:07:29,700
de estar cómodo con
algo así como Ola mundo.

2581
02:07:29,700 --> 02:07:32,575
En realidade, a maioría do que fixemos hoxe
certamente non vai afundir na super rápido.

2582
02:07:32,575 --> 02:07:34,491
E iso vai levar moito
tempo, e algunha práctica.

2583
02:07:34,491 --> 02:07:36,864
E as probabilidades son, vostede pode clasificar
de quere bater o teclado

2584
02:07:36,864 --> 02:07:37,780
ou berrar para a pantalla.

2585
02:07:37,780 --> 02:07:38,880
E todo iso é OK.

2586
02:07:38,880 --> 02:07:41,320
Aínda que, quizais intente non
facelo na biblioteca tanto.

2587
02:07:41,320 --> 02:07:43,820
>> E, finalmente, vai
ser capaces, porén, de comezar

2588
02:07:43,820 --> 02:07:47,580
vendo patróns, tanto no bo código
que escribiu e erros

2589
02:07:47,580 --> 02:07:48,370
que fixo.

2590
02:07:48,370 --> 02:07:51,965
E moi parecido ao proceso de
tornándose un TF ou CA é como,

2591
02:07:51,965 --> 02:07:54,590
vai comezar a ir mellor e
mellor ao ver eses patróns,

2592
02:07:54,590 --> 02:07:56,774
e só resolver o seu
propios problemas en última instancia.

2593
02:07:56,774 --> 02:07:59,940
Nese medio tempo, haberá unha abundancia
de nós para darlle soporte, e levalo

2594
02:07:59,940 --> 02:08:00,481
por iso.

2595
02:08:00,481 --> 02:08:02,450
E nos write-ups
para todos os problemas

2596
02:08:02,450 --> 02:08:04,366
será guiado a través
todos os comandos

2597
02:08:04,366 --> 02:08:08,330
que seguramente sabe de
moita práctica ata agora,

2598
02:08:08,330 --> 02:08:10,380
pero podería voar
sobre a cabeza de momento.

2599
02:08:10,380 --> 02:08:11,580
E iso é totalmente ben.

2600
02:08:11,580 --> 02:08:14,230
>> Pero, en definitiva, vai
para comezar a ver xurdir patróns.

2601
02:08:14,230 --> 02:08:17,260
E unha vez que pasar por todo o
detalles estúpidas, como parénteses,

2602
02:08:17,260 --> 02:08:19,710
e chaves, e punto e coma,
e as cousas, a verdade,

2603
02:08:19,710 --> 02:08:22,360
que non é de ningún xeito
intelectualmente interesante.

2604
02:08:22,360 --> 02:08:25,690
E non é o obxectivo de
tomar calquera clase introdutoria.

2605
02:08:25,690 --> 02:08:27,410
E as ideas que van importa.

2606
02:08:27,410 --> 02:08:29,659
>> Son os loops, eo
condicións e as funcións,

2607
02:08:29,659 --> 02:08:33,552
e máis poderosamente a abstracción,
eo factoring de código,

2608
02:08:33,552 --> 02:08:36,510
eo bo deseño, eo bo
estilo, e, finalmente, a exactitude

2609
02:08:36,510 --> 02:08:40,330
do seu código, que é, en definitiva
Vai descargar máis.

2610
02:08:40,330 --> 02:08:43,925
Así, a próxima semana, imos tomar estas
ideas que vimos por primeira vez en Risco

2611
02:08:43,925 --> 02:08:45,800
e agora traducido
a C. E imos comezar

2612
02:08:45,800 --> 02:08:48,740
para introducir a primeira do
dominios do mundo real do curso.

2613
02:08:48,740 --> 02:08:53,140
>> Imos concentrar-se no mundo da seguridade,
e máis especificamente cifrado,

2614
02:08:53,140 --> 02:08:54,980
técnica de codificación da información.

2615
02:08:54,980 --> 02:08:57,000
E entre o primeiro
problemas que aínda

2616
02:08:57,000 --> 02:08:59,840
comezará a gravar ademais
xogando con algunha da sintaxe

2617
02:08:59,840 --> 02:09:02,880
e resolver algúns lóxica
problemas, en definitiva, en pouco tempo,

2618
02:09:02,880 --> 02:09:06,960
é realmente loitan, ou cifrar,
e, finalmente, descifrar a información.

2619
02:09:06,960 --> 02:09:09,470
E todo o que fixemos
Hoxe, será moi baixa

2620
02:09:09,470 --> 02:09:12,190
nivel, é só permitirá
-Nos a tomar un, e un,

2621
02:09:12,190 --> 02:09:16,550
e un paso arriba cara
escribir o código máis interesante aínda.

2622
02:09:16,550 --> 02:09:18,050
>> Entón máis sobre iso a próxima semana.

2623
02:09:18,050 --> 02:09:20,834

2624
02:09:20,834 --> 02:09:21,762
>> [Reprodución de vídeo]

2625
02:09:21,762 --> 02:09:22,690

2626
02:09:22,690 --> 02:09:25,006
>> -O Que me pode dicir sobre
a última vez que o viu?

2627
02:09:25,006 --> 02:09:29,041

2628
02:09:29,041 --> 02:09:30,040
-O Que podo dicir, realmente?

2629
02:09:30,040 --> 02:09:33,500

2630
02:09:33,500 --> 02:09:38,340
Quero dicir, era como calquera outra
ensaio de pre-produción,

2631
02:09:38,340 --> 02:09:43,510
agás que non era algo que dixo
ao final que quedou comigo.

2632
02:09:43,510 --> 02:09:47,810

2633
02:09:47,810 --> 02:09:49,640
>> -Este Foi CS50.

2634
02:09:49,640 --> 02:09:52,440

2635
02:09:52,440 --> 02:09:55,190
>> -É Un corte de todos,
gran traballo en ensaio.

2636
02:09:55,190 --> 02:09:56,070
>> o xantar de -que?

2637
02:09:56,070 --> 02:09:57,986
>> Si, e eu podemos
incorporarse un bocadillos en algo.

2638
02:09:57,986 --> 02:10:01,380
Déixeme só interrogar con
David moi rapidamente.

2639
02:10:01,380 --> 02:10:02,160
David?

2640
02:10:02,160 --> 02:10:04,260
David?

2641
02:10:04,260 --> 02:10:06,110
>> [FIN DE REPRODUCIÓN]

