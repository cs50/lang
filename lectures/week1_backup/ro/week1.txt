[MUZICĂ] David J. MALAN: Bine, acest lucru este CS50. Și acest lucru este de o saptamana. Așa că amintesc că ultima dată în săptămâna zero ne-am concentrat pe o gândire de calcul. Si am trecut de la asta Zero, un grafic de programare Limba de la prietenii noștri la MIT Media Lab. 

Și, cu zgârieturi, am explora idei, cum ar fi funcții și condiții, și bucle, și variabile, și chiar evenimente și fire de execuție și multe altele. Și astăzi, vom continua folosind aceste idei, și într-adevăr luați-le pentru acordate, dar să le traducă într-o altă limbă cunoscută sub numele de C. Acum, C este un limbaj mai tradițional. Este un nivel inferior limbă, dacă vreți. 

Este pur textuală. Și așa, la prima vedere, este toate vor să se uite destul de criptic dacă nu ați programat mai înainte. Vom avea semi-colons, și paranteze, și acolade, și multe altele. Dar, dau seama că, chiar deși sintaxa este pe cale să se uite un pic nefamiliar la cele mai multe dintre voi, vezi trecut peste asta. Și să încerce să vadă ideile care sunt, într-adevăr, familiare, pentru că aici, în prima săptămână ceea ce vom începe să facem este să compare, Inițial, Scratch versus C. 

Astfel, de exemplu, amintim că, atunci când ne a implementat primul dintre programele noastre ultima dată, am avut un bloc care sa uitat un pic ceva de genul astea-- când pavilion verde dat click, iar apoi am avut una sau mai multe piese de puzzle de sub el, în acest caz, să zicem, hello world. Așa că, într-adevăr, în Scratch, atunci când fac clic steagul verde pentru a rula programul meu, așa să vorbească, acestea sunt blocurile care se executa, sau a alerga. Și, în special, Scratch a declarat, bună, lume. 

Acum, aș fi putut fi specificat diferite cuvinte aici. Dar vom vedea că, într-adevăr, mulți acestor blocks-- și într-adevăr, în C multe functions-- poate fi parametrizat sau personalizate de a face lucruri diferite. De fapt, în C, dacă ne doresc să transforme, acum, acest program Scratch la această altă limbă, vom scrie ceva de genul asta. 

Desigur, există unele necunoscute sintaxă acolo cel mai probabil, int și între paranteze și gol. Dar, chiar dacă printf-- v-ar cred că ar fi pur și simplu de imprimare. Dar, de imprimare înseamnă imprimare formatate, după cum vom vedea în curând. Acest lucru literalmente va imprima pe ecran, indiferent este în interiorul acestor paranteze, care desigur, în acest caz este, bună mondial. 

Dar, veți observa câteva alte sintaxa, unele ghilimele duble, că parantezele la sfârșit, semi-colon și altele asemenea. Deci, există un pic de deasupra capului, ca să spunem așa, atât cognitiv și sintactic, că vom merge să aibă să-și amintească înainte de mult timp. Dar, dau seama că, odată cu practica, acest lucru va începe să sară la tine. 

De fapt, să se concentreze pe faptul că unul Funcția specifically-- în acest caz, spun salut mondial. Deci, spun este funcția. Hello World este parametrul, sau argumente, personalizarea acestuia. 

Și echivalența în C este doar Va fi aceasta linie de aici, în cazul în care printf este echivalent cu, să zicem, șirul citat dublu, salut lume este echivalent, desigur, la ceea ce este în cutie albă acolo. Iar backslash n, deși un pic ciudat și absente de la zero, pur și simplu va avea ca efect ne vom a se vedea într-un calculator, cum ar fi Mac sau un PC, de doar mutarea cursorul la linia următoare. E ca lovind Enter de pe tastatură. 

Așa că, vom vedea că din nou înainte de mult timp. Dar, mai întâi, să aruncăm o privire la acest alt exemplu în cazul buclelor. Am avut această buclă pentru totdeauna ultima dată, care a fost o serie de piese de puzzle care a făcut ceva literalmente forever-- în acest caz, spune, hello world, hello world, hello world, hello world. Deci este o buclă infinită prin design. 

În C, dacă vrem să pună în aplicare această aceeași idee, am putea face acest lucru, pur și simplu. În timp ce este adevărat, printf salut world-- acum în timp ce, doar semantically, un fel de evocă ideea de a face ceva nou, și din nou, și din nou, și pentru cât timp? Ei bine, amintesc că true-- adevărat este doar pe sau unul. 

Și adevărat este, desigur, întotdeauna adevărat. Deci, e un fel de lipsit de sens declarație doar să spun adevărat. Dar, într-adevăr, acest lucru este în mod deliberat, pentru că dacă este adevărat este doar întotdeauna adevărat, decât în ​​timp ce doar adevărat implică, în cazul în care un pic indirect, că următoarele linii de cod între aceste acolade trebuie doar să executați din nou, și din nou, și din nou, și nu se opresc niciodata de fapt. 

Dar, dacă tu nu vrei sa-ti bucla pentru a opri, așa cum am a făcut ultima oară cu ceva de genul acest lucru, se repetă următoarele 50 de ori, în C, putem face același lucru cu ceea ce este numit pentru loop-- cuvântul cheie nu este în același timp, dar pentru. Și apoi avem o sintaxă nouă aici, cu int i este egal cu 0, i mai puțin de 50, i ++. Si vom reveni la asta. Dar acest lucru este pur și simplu modul în care ne-ar traducerea setului de blocuri răzuibile la un set de linii de cod C. 

În același timp, ia în considerare variabile. Și, de fapt, tocmai am a văzut unul acum un moment. Iar în cazul Scratch, dacă a vrut să declare o variabilă numită i pentru i fi întreg, doar un număr, și vrem să-l setați la o anumită valoare, vom folosi această portocală blocul aici-- setat i la 0 ° C. 

Și vom vedea astăzi și dincolo de aceasta, la fel ca și săptămâna trecută, programatori face aproape întotdeauna începe numărarea de la zero, într-adevăr prin convenție. Dar, de asemenea, pentru că retragerea din discuția noastră de binar, cel mai mic număr posibil reprezintă cu orice număr de biți este doar de gând să fie 0 în sine. Și așa vom începe, în general, initializarea chiar și variabilele noastre la 0. 

Și, în C, pentru a face același lucru, vom spune int pentru întreg, doar prin convenție. Aș putea fi numit această variabilă tot ce vreau, la fel ca și în Scratch. Și apoi este egal cu 0 la doar imputernicitii valoarea 0 din dreapta și pune în variabila, sau containere de depozitare acolo, pe partea stângă. Și semi-colon ca vom see-- și am văzut câteva dintre aceste already-- înseamnă doar sfârșitul termenului de gândire. Mai departe spre a face altceva pe liniile care urmează. 

Acum, ce despre expresiile booleene? Să ne amintim că în Scratch, acestea au fost expresii care sunt fie adevărate sau întrebări false--, într-adevăr, că sunt fie adevărate sau false. Deci, în cazul Scratch, am putea pune o întrebare simplă ca asta, este i mai mică de 50? Deci, eu, din nou, este un număr întreg. Poate că noi o utilizați într-un program de Scratch pentru a ține evidența unui scor sau asa ceva. Astfel încât această sintaxă aici, în Scratch înseamnă doar, este i mai mică de 50 de ani? Ei bine, din fericire, este ceva simplu în C. Și pentru a traduce, acest lucru ne-ar spune pur și simplu i mai puțin de 50, folosind cheia familiară de pe tastatură. 

Între timp, dacă ai vrut să spune ceva mai general, cum ar fi, ei bine, este x mai mică decât în ​​cazul în care fiecare y x și y sunt ele însele variabile? Putem face același lucru în C, atâta timp cât ne-am a creat aceste variabile deja. Si vom vedea cum se face acest lucru înainte de mult timp. Ne-ar spune pur și simplu x mai mic decât y. 

Așa că ai început să a se vedea unele similitudini. Iar acei oameni care au făcut Zgârietură au fost cu siguranță inspirat de unele dintre aceste idei de bază. Și veți vedea acest tip de sintaxă în multe languages-- nu doar zero, nu doar C, dar Python, și JavaScript și alte limbi încă. 

Hai să analizăm un alt construct de la C, noțiunea de condiție, face ceva în mod condiționat. Dacă ceva este adevărat, acest lucru. Dacă ceva este adevărat altceva, face asta. Este un fel de programare echivalentul unei furculiță în drum. Poate este o furculiță cu două sensuri, o furculiță cu trei căi, sau mai mult. Și, în Scratch, am putea avea văzut ceva de genul asta. 

Așa că acesta e unul mare. Dar ia în considerare în raport simplitatea logicii. Dacă x este mai mic decât y, atunci spune x este mai mică decât y, altfel daca x este mai mare decât y, apoi spune x este mai mare decât y. Și apoi, în mod logic, dacă te gândești înapoi la zero sau pur și simplu propria intuiție umană, bine, dacă x nu este mai mare decât y și x nu este mai mic decât y, atunci, desigur, x va fi egal cu y. Deci, în acest caz, prin cuiburi aceste blocuri, răzuibile putem realiza o perioadă de trei drum furculiță în drum? 

Între timp, dacă vrem să face acest lucru în C, se poate spune arată un pic simpler-- cel puțin odată ce vă familiarizați cu sintaxa. Dacă x este mai mic decât y, printf x este mai mic decât y. Altfel, dacă x este mai mare decât y, printf x este mai mare decât y. X este altceva printf egal cu y-- și, din nou, cu cei backslash se termină doar pentru aceste noi linii, astfel că, dacă a fugit de fapt, acest tip de program ar muta doar cursorul în cele din urmă la următoarea linie a ecranului. 

Acum, între timp zero a avut alt caracteristici mai sofisticate, numai unele dintre care ne vom muta inițial peste în lumea C. Și unul dintre ei a fost numita listă în Scratch. Și acest lucru a fost o specială tipul de variabilă care permis să stocați mai multe lucruri în ea înapoi, în spate, în spate, în spate. 

În C, nu are liste, per se, dar ceva care sunt în general mai numite tablouri, cu toate că vom întoarce mai târziu în acest semestru pentru a uita la ceva numita listă, sau într-adevăr o listă legată. Dar pentru acum aproape, The echivalent în C pentru noi va fi ceva numit matrice. Și o matrice este pur și simplu un tip special de variabilă care vă permite să stocați date înapoi, în spate, în spate, în spate. 

Și, într-adevăr, în Scratch, dacă ne-am dorit să acceseze primul element al unui tablou sau un list-- și am de gând să-l sun, prin convenție, argv, argumentul vector, dar mai mult pe asta înainte de mult timp. Dacă vreau să ajung primul element din argv, în lumea Scratch tu de fapt, nu de obicei începe numărarea de la 1. 

Și, așa că am putea obține punctul 1 din argv. Asta e doar modul în care a implementat MIT noțiunea de liste. Dar, în C, voi mai simplu doar să spun, argv, care din nou este numele meu list-- sau să fie clar, o matrice. Și, dacă vreau primul elemente, mă duc pentru a utiliza paranteze pătrate, care vă s-ar putea să nu de multe ori utilizată sub o tastatură. 

Dar, 0 înseamnă doar, adu-mi primul. Așa că uneori și ca timpul trece, vom merge pentru a începe să vadă aceste dihotomii între zero și C, prin care Scratch utilizează una. Noi, în C, utilizați 0 aici. Dar, veți vedea rapid odată ce ați înțeles bazele fiecărei limbi, care aceste lucruri încep să se tot mai mult familiare prin practica si practica. 

Așa că haideți să ne uităm de fapt, acum la un program. Aici va fi primul nostru C codul sursă pentru programe complete. Iar programul ne vom pentru a oferi cu titlu oneros este cel care este echivalent la acea piesa Scratch mai devreme. 

Așa că aici, avem ceea ce-i fără îndoială, cel mai simplu program C puteți scrie că de fapt, face ceva. Acum, ne vom uita din trecut, de acum, a includ, io.h standard și acestea unghi între paranteze, și int și gol, și acolade și altele asemenea. 

Și să ne concentrăm asupra ceea ce, cel puțin în mod intuitiv, s-ar putea sări la tine deja. De fapt, principal, eu nu fac știu neapărat ce este acest lucru, dar, la fel ca zero a avut ca atunci când pavilion verde apasat bucata de puzzle, tot așa C, ca un limbaj de programare au o piesă principală de cod care este executat în mod implicit. Și, într-adevăr, este pur și simplu va fi numit principal. 

Deci principal este o funcție. Și este o funcție specială care există în C, că, atunci când executați un program, este principalul care devine condus de Mod implicit. În lumea Scratch, era, de obicei, atunci când steagul verde a făcut clic pe care s-au administrat în mod implicit. 

Între timp, am văzut acest lucru înainte, printf sau imprimare formatat, asta va fi o funcție care vine cu C, împreună cu o grămadă de alții, care va din timp și de timp din nou, în scopul de a face exact după cum sugerează și numele, imprima ceva. Ce vrem să imprimați? Ei bine, vom vedea că de caractere anexând cum ar fi these-- mondial Bună ziua, backslash n în ghilimele duble, putem spune printf exact ce pentru a imprima pe ecran. 

Dar, în scopul de a face că, din păcate, trebuie să ia ceva care este deja criptice pentru noi, oamenii, dar cel puțin este oarecum readable-- ascuțite includ, io.h standard int principal, nule, printf, toate magice incantatii tocmai am văzut pe ecran. Dar noi de fapt, trebuie să du-te mai Arcane încă. În primul rând avem nevoie de a traduce codul pe care le scrie în cod mașină. Și amintesc de săptămâna trecută că mașinile, cel puțin pe cele pe care le știm aici, la sfârșitul zilei numai să înțeleagă zero-uri si altele. 

Iar Dumnezeul meu, dacă a trebuit să scrie aceste zero-uri și cele pentru programul de fapt, aceasta ar fi foarte, foarte repede ia de distracție din nimic. Dar, se pare, pe saptamana trecuta, că aceste modele de zero-uri și altele pur și simplu au o semnificație specială. În anumite contexte, acestea ar putea însemna numere. 

În anumite contexte, ar putea însemna litere, sau culori, sau orice număr din alte abstracțiuni acolo asupra. Dar, la fel ca și computerul are un CPU, Central Processing Unit, sau creierul din interiorul calculatorului. Este de obicei Intel în interior, pentru că una dintre cele mai mari companii care face procesoare pentru calculatoare. 

Ei bine, procesoare Intel și altele pur și simplu, s-au decis în avans că anumite modele de zero-uri și cele înseamnă lucruri specifice. Anumite modele de zero-uri și altele va însemna, imprima acest lucru pe ecran, sau adăugați aceste două numere, sau scad aceste două numere, sau mutați această bucată de date de la memoria computerului meu aici, sau orice alt număr de nivel foarte scăzut, dar în cele din urmă util, operații. Dar, din fericire, noi oamenii nu-i merge să aibă nevoie să cunoască acest nivel de detaliu. Intr-adevar, la fel ca ultima dată, în cazul în care ne-am abstrase din nou, și din nou, și din nou, clădire de la un nivel foarte scăzut Primitive, cum ar fi zero-uri și altele la concepte de nivel superior cum ar fi numere și litere, și culori, și multe altele, astfel încât putem noi programatori stau pe umerii alții care au venit înaintea noastră și de a folosi software-ul celălalt oamenii au scris înainte de us-- și anume programe numite compilatoare. 

C este un limbaj care este de obicei compilat, ceea ce înseamnă convertit de la codul sursă pentru cod mașină. În special, ceea ce înseamnă este că, dacă ai sursa ta cod pe care le scrie, așa cum am în curând va fi, în doar un moment de pe ecran, și doriți să-l convertiți în cele din urmă la mașină code-- aceste zerouri și cele care numai Mac sau PC-ul understands-- ai un prim hrana pentru animale, care codul sursă ca intrare la o specială program numit un compilator, ieșirea pe care le se vedea este cod mașină. Și, într-adevăr, ultima dată când am vorbit aproximativ, într-adevăr, la sfârșitul zilei, rezolvarea problemelor. Ai intrări. Iar tu ai ieșiri. Si ai un fel a algoritmului în mijloc. 

Algoritmii pot fi cu siguranță implementat în software-ul, așa cum am văzut săptămâna trecută pseudocod și după cum vom vedea cu codul real săptămâna aceasta. Si astfel un compilator cu adevărat doar are un set de algoritmi interior din ea care știu cum să converti cuvintele cheie speciale, cum ar fi principală, și printf, și altele pe care tocmai l a văzut în tiparele de zero-uri și cele pe care Intel în interiorul și în alte procesoare de fapt, o înțelege. Deci, cum facem asta? De unde obținem un compilator? 

Cei mai mulți dintre noi aici au un Mac sau un PC. Și tu ești care rulează Mac OS, sau Windows sau Linux sau Solaris, sau orice număr de alte sisteme de operare. Și, într-adevăr, am putea du-te afară pe web și de a descărca un compilator pentru Mac-ul sau PC-ul pentru sistemul de operare special. Dar noi ar fi toate pe pagini diferite, ca să spunem așa. Ne-ar fi puțin configurații diferite. Și lucrurile nu ar merge toate la fel. Și, într-adevăr, în aceste zile mulți dintre noi nu folosesc software-ul care rulează numai pe laptop-urile noastre. In schimb, folosim ceva ca un browser ne permite să acceseze web-based aplicații în cloud. Și, în cursul acestui semestru, vom face exact asta. Vom scrie aplicatii sau Software-ul nu utilizează code-- C, dar alte limbaje cum ar fi Python și JavaScript-- care rulează în nor. 

Și pentru a face acest lucru, noi înșine pe parcursul semestrului se va folosi de fapt un nor bazat pe mediu cunoscut sub numele de CS50 IDE. Aceasta este o programare web mediu, sau de dezvoltare integrat mediu, Ide, care este construit in varful unele software-ul open source numit Cloud 9. Și am făcut unele pedagogice simplificări pentru ea astfel încât să se ascundă anumite funcții în primele săptămâni pe care nu avem nevoie, după care puteți dezvăluie-le și de a face cele mai multe tot ce vrei cu mediul înconjurător. 

Și ne permite, de asemenea, să pre-a instala anumite programe. Lucruri cum ar fi așa-numitele CS50 bibliotecă, pe care le vom vedea în curând ne oferă în C, cu unele funcționalitate suplimentară. Așa că, dacă te duci la, în cele din urmă, CS50.io, vi se va solicita să vă conectați, și o dată ce faci și creați un cont gratuit, vei putea accesa un mediu care arata destul ca acest lucru. 

Acum, acest lucru este în modul implicit. Totul este frumos și luminoase de pe ecran. Mulți dintre noi au obiceiul de lucru pe bucata CS50 asta destul de târziu în noapte. Și astfel, unii dintre voi s-ar putea prefera să porniți-l în modul de noapte, ca să spunem așa. 

Dar, în cele din urmă, ceea ce ești O să vadă în interiorul CS50 IDE este de trei areas-- distincte o zonă pe unde a plecat fișierele vor fi în nor, o zonă de pe partea dreaptă sus în cazul în care codul va fi editat. Vei putea deschide file individuale pentru orice program pe care scrie acest semestru interior din acel colț de sus din dreapta. Și apoi mai arcanely, și totuși puternic, va fi acest lucru la cele mai fund cunoscut sub numele de o fereastră de terminal. 

Aceasta este o școală veche Interfață linie de comandă, sau CLI, care permite vă pentru a executa comenzi pe computer--, în acest caz, computerul în cloud-- pentru a face lucruri cum ar fi compila codul de la codul sursă la cod mașină, pentru a rula programe sau pentru a începe server de web sau pentru a accesa baza de date, precum și orice număr de alte tehnici că vom începe să utilizați înainte de mult timp. Dar pentru a ajunge acolo, suntem va avea de fapt pentru a merge on-line și de a începe să joace. Și pentru a face acest lucru, să mai întâi începe să meșterească principal, și a scrie cea mai mare parte a unui program. Și să folosească această funcție printf, pe care am folosit mai devreme, pur și simplu să spună ceva. 

Deci, aici sunt deja în interiorul IDE-ului CS50. M-am autentificat în avans. Si am ecranat plin fereastra. Și așa, în cele din urmă, tu prea în probleme următori va urma pașii similare va furniza o documentație on-line. Așa că nu trebuie să vă faceți griji cu privire la absorbind fiecare pas tehnic mic că eu fac astăzi aici. 

Dar, veți primi un ecran de genul asta. I se întâmplă să fie în modul de noapte. Și tu poți lumina totul prin dezactivarea modului de noapte. Iar la sfârșitul fișierului zi, vei vedea aceste trei principale areas-- fișierul browser-ul de la stânga, filele de cod în sus de sus, și fereastra terminalului din partea de jos. 

Lasă-mă să merg mai departe și scrie primul meu program de. Mă duc să preemptively la File, Salvați și salvați fișierul meu ca hello.c. Într-adevăr, prin convenție, orice program de noi scrie care este scris în limbajul C ar trebui să fie numit ceva dot c, prin convenție. Așa că am de gând să-l numească hello.c, deoarece Vreau doar să spun salut din lume. Acum am de gând să zoom afară și faceți clic pe Salvare. Si tot ce am aici, acum este o filă în care eu pot începe scrierea de cod. 

Acest lucru nu se va compila. Acest lucru nu înseamnă nimic. Și astfel, chiar dacă m-am convertit acest lucru la zero-uri si cele, procesorul va avea nici un idee despre ce se întâmplă în jur. Dar dacă voi scrie linii care se potrivesc cu C fiind conventions-- lui C, din nou, acest language-- cu sintaxa cum ar fi acest lucru, printf salut world-- și am ajuns confortabil cu a face acest lucru în timp. Deci, eu nu cred că am făcut orice erori tipografice. 

Dar, invariabil, primul timp ce faci acest lucru, vei face. Și ce sunt pe cale să fac s-ar putea foarte bine să nu lucreze pentru tine prima dată. Și asta e perfect în regulă, deoarece chiar acum tu ar putea vedea doar o mulțime de noutate, dar, în timp, odată ce vă familiarizați cu acest mediu, și această limbă, și altele, veți începe să vedeți lucruri care sunt fie corecte sau incorecte. 

Și acest lucru este ceea ce semenii didactice și desigur asistenți obține atât de bun la timp, este spotting erori sau bug-uri în codul. Dar eu susțin că acolo nu sunt bug-uri în acest cod. Deci, eu acum vreau să rulați acest program. 

Acum, pe cont propriu Mac sau PC-ul, eu sunt în obiceiul de icoane dublu click când vreau să ruleze un alt program. Dar asta nu e modelul de aici. În acest mediu, care este CS50 IDE. Noi folosim o operare sistem numit Linux. Linux amintește de un alt sistem de operare, cunoscut în general ca Unix. Și Linux este cunoscut în special pentru având o linie de comandă pentru mediu, CLI. Acum, noi folosim un anumit aromă de Linux, denumit Ubuntu. Ubuntu și este pur și simplu un anumită versiune de Linux. 

Dar, aceste Linux în aceste zile face de fapt vin cu interfețe grafice de utilizator. Iar cel care se întâmplă să să fie utilizați aici este web-based. Deci, acest lucru s-ar putea arata chiar un putin diferit de ceva v-ar putea avea văzut sau a alerga în trecut. 

Așa că am de gând să merg mai departe acum și de a face următoarele. Am salvat acest fișier ca hello.c. Mă duc să merg mai departe și Tip clanghello.c Deci, zăngănit pentru limbajul C este un compilator. Este pre-instalat în CS50 IDE. Și tu poți descărca și absolut instalați acest lucru pe cont propriu Mac sau PC. 

Dar, din nou, nu v-ar avea toate pre-configurația făcut pentru tine. Deci, pentru moment, eu sunt doar va rula clanghello.c. Și acum observați această sintaxă aici cele din urmă va dau seama că înseamnă că sunt într-un director sau director numit spațiu de lucru. Acest semn dolar este doar convenție pentru sensul, tastați comenzile aici. 

Este ceea ce se numește un prompt, doar prin convenție, este semn dolar. Și, dacă mă duc mai departe acum și faceți clic Enter, nimic nu pare să se fi întâmplat. Dar asta e de fapt un lucru bun. Mai puțin ce se întâmplă pe ecran, cu atât mai probabil codul este să fie corectă, cel puțin sintactic. 

Așa că, dacă vreau să rulați acest Programul, ce să fac? Ei bine, se pare că nume implicit prin convenție pentru programe când nu specificați o nume pentru programul dvs. este doar a.out. Iar această sintaxă le veți se familiarizeze cu mult timp înainte de a. 

Dot slash înseamnă doar, hei, CS50 IDE, executați un program numit a.out care este în interiorul directorul meu curent. Dot înseamnă că directorul curent. Și vom vedea ce alte astfel de secvențe de caractere înseamnă înainte de mult timp. 

Deci, aici vom merge, Enter, hello world. Și veți observa că ceea ce sa întâmplat? Nu numai că a imprima Bună ziua lume. De asemenea, acesta a mutat cursorul la linia următoare. 

Și de ce a fost asta? Care a fost codul pe care am scris mai înainte care a asigurat că cursorul ar du-te pe linia următoare? lucru amuzant despre un computerul este doar merge pentru a face literalmente ceea ce spune sa faci. 

Așa că, dacă ai spune să printf Bună ziua, virgulă, spațiu, lume, aproape citat, este literalmente doar merge pentru a imprima aceste caractere. Dar nu am avut acest caracter special la final, retragerea, backslash n. Și asta e ceea ce a asigurat că personajul a mers la următoarea linie a ecranului. 

De fapt, lasă-mă să merg și fac acest lucru. Lasă-mă să merg mai departe și să ștergeți acest lucru. Acum, observați că partea de sus a ecranului meu acolo un pic de lumină roșie fila care indică, hei, nu ați salvat fișierul. Așa că am de gând să merg mai departe cu un control S sau comanda S, salvați fișierul. Acum, ea a mers goes-- un verde moment--. Și acum este înapoi doar fiind o pictogramă aproape. 

Dacă am rula din nou clanghello.c, Enter, slash punct, a.out, Enter, veți vedea că acesta a lucrat in continuare. Dar este, fără îndoială, un pic buggy. Chiar acum, spațiul de lucru meu prompt--, și apoi acest semn dolar, și apoi prompt-- meu real este tot pe aceeași linie. Deci, acest lucru cu siguranță un bug estetic, chiar dacă nu este cu adevărat o eroare logică. 

Asa ca voi anula ceea ce tocmai am făcut-o. Mă duc să rulați din nou a.out. Observati Am adăugat caracter înapoi linie noua. Am salvat fișierul. 

Așa că voi să rulați din nou a.out, si-- La naiba, un bug, un bug care înseamnă greșeală. Asa ca bug-ul este că, chiar dacă Am adăugat backslash n acolo, re-salvat, re-fugit programul, comportamentul a fost același. De ce ar fi asta? 

Îmi lipsește un pas, nu? Acest pas cheie mai devreme a fost că aveți sa-- atunci când modificați codul sursă, De asemenea, se dovedește a alerga ea prin compilatorul din nou, astfel încât să obțineți un nou cod mașină. Și codul mașină, zerouri și cele, vor fi aproape identice, dar nu este perfect așa, pentru că avem nevoie, desigur, că noua linie. 

Deci, pentru a rezolva această problemă, voi avea nevoie de să rulați din nou clanghello.c, introduceți, punct slash, a.out. Și acum, salut lume este din nou unde mă aștept să fie. Deci, acest lucru este toate bine și bine. Dar, a.out este un nume destul de prost pentru un Programul, chiar dacă se întâmplă să fie, din motive istorice, default-- însemnând ieșiri de asamblare. 

Dar, lasă-mă să merg mai departe aici și de a face acest lucru în mod diferit. Vreau programul meu Salut lume pentru a fi de fapt numit salut. Așa că, dacă ar fi fost o icoana de pe mea desktop-ul, nu ar fi a.out. Ar fi numit salut. 

Deci, pentru a face acest lucru, se pare că zăngănit, la fel ca multe programe, sprijină argumente în linia de comandă, sau steaguri, sau comutatoare, care influențează pur și simplu comportamentul său. In mod specific, zăngănit susține o liniuță o pavilion, care ia apoi un al doilea cuvânt. În acest caz, eu voi arbitrar, dar în mod rezonabil, o numesc salut. Dar, am putea spune nimic Vreau, cu excepția a.out, care ar fi mai degrabă pe lângă punctul. 

Și apoi specificați doar numele din fișierul pe care îl doresc să compilați. Deci, acum, chiar dacă la început a comenzii am încă zăngănit, la sfârșitul comenzii Eu încă mai au numele de fișier, Am acum acestea linie de comandă argumente, aceste steaguri, care spun, oh, de modul în care, de ieșire-o, un fișier numit salut, nu a.out implicit. 

Deci, dacă am lovit Enter acum, nimic pare să se fi întâmplat. Și totuși, acum pot face slash dot salut. Deci, e același program. Zerourile și sunt cele de identic la sfârșitul zilei. 

Dar ei sunt în două diferite a.out files--, care este prima versiune și doar prostește pe nume, iar acum salut, care este un mult mai multe nume convingătoare pentru un program. Dar, sincer, eu nu sunt niciodată O să-și amintească acest lucru din nou, și din nou și din nou. Si, de fapt, așa cum am scrie programe mai complicate, comenzile de care sunteți Va trebui să scrie se vor obține chiar mai complicat încă. 

Și, ca să nu vă faceți griji. Se pare că, oamenii înainte de ne-au dat seama prea a avut aceeași problemă exact. Și ei nu s-au bucurat nevoie să tip comenzi destul de lungi, arcane, să nu mai vorbim să le amintească. Și, tot așa oamenii înainte de a ne-au făcut alte programe care fac mai ușoară pentru a compila software-ul. 

Și, într-adevăr, o astfel de Programul se numește face. Așa că am de gând să merg mai departe și de a face acest lucru. Voi anula tot ce am Tocmai am făcut în felul următor. Lasă-mă de tip LS. Și veți observa trei lucruri-- a.out, și o stea, salut și o stea, și hello.c. Din fericire, acest lucru ar trebui să fie un pic mai intuitiv, în măsura în care nu a existat anterior nimic în acest spațiu de lucru. Nu a fost nimic pe care am avut creată până când am început clasa. 

Si am creat hello.c. Apoi am compilat, și la numit a.out. Și apoi l-am compilat din nou ușor în mod diferit și a numit-o salut. Așa că am trei fișiere în acest director, în acest folder numit spațiu de lucru. Acum, eu pot vedea că la fel de bine dacă am zoom out de fapt. 

Dacă aș fi zoom aici și uita-te la mâna dreaptă sus colt, așa cum a promis la stânga în partea stângă a ecranului este întotdeauna să vă arăt ce-i în contul tău, ce-i în interiorul IDE-ului CS50. Și, există trei fișiere acolo. 

Așa că vreau să scap de a.out și de salut. Și, după cum s-ar putea imagina intuitiv, tu ar putea sorta de comandă clic sau faceți clic dreapta pe acest. Iar acest meniu mic apare. Puteți descărca fișierul, executați l, examinați-l, refresh, redenumi, sau ce nu. 

Și tocmai am putut șterge, și ar pleca. Dar hai să facem lucrurile cu o comandă line pentru acum, astfel încât să se obține confortabil cu acest lucru, și de a face următoarele. Mă duc să merg mai departe și eliminați a.out prin tastarea literalmente rma.out. Se pare, comanda pentru înlăturarea sau ștergerea ceva, nu elimina sau șterge. 

Este mai succint RM, doar pentru a salva ai unele intrarile de la tastatura, și apăsați Enter. Acum vom fi oarecum criptic elimina a.out fișier obișnuit. Nu știu cu adevărat o fișier neregulat ar fi încă. Dar eu vreau să-l eliminați. 

Așa că mă duc la y de tip pentru da. Sau aș putea să-l tip afară, și apăsați Enter. Și, din nou, nimic nu pare să se întâmple. Dar acest lucru este, în general, un lucru bun. 

Dacă aș fi de tip LS data aceasta, ce ar trebui să văd? Să sperăm că, trebuie doar să salut și hello.c. Acum, ca o parte, veți observați această stea, asterisc, că e la sfârșitul programelor mele. Și ei, de asemenea, să apară în verde. Acesta este doar modul CS50 IDE dintre voi cluing în faptul că acest lucru nu este codul sursă. Asta e un executabil, un Runnable program care poate rula de fapt, prin a face slash punct, iar apoi este numele. 

Acum, lasă-mă să merg mai departe și eliminați acest lucru, rm salut, Enter, eliminați regulat fișier salut, da. Și acum, dacă am de tip LS, ne întoarcem la hello.c. Încercați să nu ștergeți codul sursă reală. Chiar dacă există caracteristici construit în CS50 IDE în cazul în care puteți merge prin istoricul de revizuire și înapoi în timp, dacă în mod accidental șterge ceva, nu să fie conștient conform acestor solicitări da sau nu, de fapt, ceea ce vrei să faci. Și, dacă mă duc până la partea de sus Colțul din stânga mână aici, tot ceea ce rămâne este hello.c. Deci, nu există buchete de alte comenzi pe care le se poate executa în lumea Linux, una dintre care este, din nou, Make. Și vom merge pentru a face programul meu acum după cum urmează. 

In loc de a face zăngănit, în loc de a face zăngăni-o, Voi pur și simplu literalmente tip, să salut. Și acum observați, eu sunt nu face tastarea hello.c. Sunt tastarea face salut. 

Iar acest program Asigurați că vine cu IDE CS50, și multe altele în general, cu Linux, este un program care este va face un program numit Hello. Și va să-și asume, prin convenție, că în cazul în care acest program poate fi făcută, aceasta va fi făcută dintr-o sursă fișier de cod care se termină în c dot, hello.c. 

Deci, dacă am lovit Enter acum, observați că comanda care este executat este de fapt chiar mai mult înainte de a decât înainte. Si asta pentru ca ne-am preconfigurat IDE CS50 pentru a avea unele caracteristici suplimentare construite în nu avem nevoie doar de încă, dar în curând va fi. Dar mai important lucru pentru a realiza este acum am un program Buna ziua. 

Dacă aș fi din nou tip LS, I au un program de salut. Si eu pot rula cu dot slash a.out, nu, pentru că întregul punct al acestei exercițiu a fost dot salut slash. Și acum am programul meu Salut lume. Așa că merge mai departe, suntem aproape întotdeauna doar va compila programele noastre folosind comanda make. Și apoi vom merge să-i conduse de dot slash, și numele programului. Dar, dau seama ce fac este pentru a face tu, este că nu este ea însăși un compilator. Este doar un program de confort care știe cum să declanșeze un compilator pentru a rula astfel încât să le puteți folosi. 

Ce există alte comenzi în Linux, iar la rândul său CS50 IDE? Vom vedea în curând că există o comanda CD, Change Directory. Acest lucru vă permite în termen interfață linie de comandă ta pentru a merge mai departe, și înapoi, și să se deschidă dosare diferite fără a utiliza mouse-ul. 

LS am văzut-o, care vine de la lista fișierele din directorul curent. Asigurați-Dir, poți probabil, începe să se deducă Ce înseamnă aceste now-- face director, dacă doriți să creați un folder. RM pentru eliminare, RM Dir pentru eliminați directory-- și acestea, din nou, sunt linia de comandă echivalenți de ceea ce ai ar putea face în CS50 IDE cu mouse-ul. Dar, în curând vei găsi că, uneori, este doar mult mai repede pentru a face lucruri cu o tastatură, și în cele din urmă mult mai puternic. 

Dar este greu să susțină că tot ce am făcut până acum este tot atât de puternic, atunci când toate ne-am zis este, Bună ziua lume. Și, de fapt, am hardcoded cuvinte salut lumea în programul meu. Nu există nici un dinamism încă. Zgâriere a fost un ordin de mărime mai interesant săptămâna trecută. 

Și așa să mergem acolo. Hai să facem un pas spre care prin mod unora dintre aceste funcții. Deci, nu numai că vine C cu printf, și ciorchini de alte funcții unele dintre care vom vedea a lungul timpului, ea nu face tot atât de ușor dreapta afară din poarta în obținerea de intrare de utilizator. 

De fapt, unul dintre punctele slabe de limbaje cum ar fi C, și chiar Java și încă alții, este că nu face mai ușor pentru a obține doar lucruri cum ar fi numere întregi de la utilizatori, sau siruri de caractere, cuvinte, și fraze, lasa lucrurile singur cum ar fi valori punctuale sau numere reale plutitoare cu puncte zecimale, și într-adevăr numere lungi, după cum vom vedea în curând. Așa că această listă de funcții aici, acestea sunt ca și alte piese de puzzle Scratch pe care le-am pre-instalate în CS50 IDE pe care le vom folosi pentru câteva săptămâni ca și roți de formare de soiuri, și în cele din urmă le ia off, și uite sub capota, probabil, la modul în care sunt puse în aplicare aceste lucruri. 

Dar pentru a face acest lucru, să de fapt, a scrie un program. Lasă-mă să plec mai departe acum. Si voi crea o nouă fișierul făcând clic pe acest mic plus, și făcând clic pe New File. 

Voi salva această următor unul ca, să zicem, string.c, pentru că vreau să se joace cu siruri de caractere. Și șir de caractere în C este doar o secvență de caractere. Așa că acum să mergem mai departe și de a face următoarele. 

Includ standardul IO.h-- și se pare standardul IO, IO înseamnă doar de intrare și de ieșire. Deci, se pare că această linie aici este ceea ce este ne vecine de a folosi printf. Printf, desigur, produce ieșire. Deci, în scopul de a utiliza printf, se transformă afară trebuie să aibă această linie de cod în partea de sus a fișierului. 

Și ne vom întoarce la ceea ce ceea ce înseamnă cu adevărat înainte de mult timp. Se pare că, în orice program C I a scrie, Am să-l înceapă cu cod care arata ca acest lucru. Și veți observa CS50 IDE, și alte tipuri de dezvoltare integrată medii, cum ar fi ea, vor încerca ca cele mai bune ei pot să termine gândul tău. De fapt, un moment în urmă, dacă am anula ce am făcut, am lovit Enter. 

Am lovit apoi ondulat deschis bretele, lovit din nou Enter. Și sa terminat gândul meu. Mi-a dat o nouă linie, indentate nu mai puțin din motive stilistice frumoase, vom vedea. Și apoi mi-a dat în mod automat care acoladă pentru a termina gândul meu. Acum, ea nu întotdeauna ghici ce vrei să faci. Dar, în mare parte, nu-i salva niste taste. Deci, un moment în urmă, am rulat acest program-- Bună ziua, lume, și apoi compilat, și apoi a fugit. Dar nu e nici un dinamism aici. Ce se întâmplă dacă am vrut să face ceva diferit? Ei bine, ce dacă aș fi vrut să de fapt obține un șir de caractere de la utilizator? Am de gând să folosească o piesă de puzzle numit exact that-- obține șir. 

Se pare că, în C, că, atunci când nu doriți pentru a oferi intrare la o piesă de puzzle, sau mai corect la o funcție, literalmente face doar paranteze deschise, aproape paranteză. Deci, e ca și cum ar exista nici o cutie albă pentru a introduce în. Blocul spus înainte a avut o cutie mică de culoare albă. Noi nu avem acea cutie alba acum. 

Dar, când eu numesc șir get, eu doresc să pună rezultatul undeva. Deci, o paradigmă foarte frecvente în C este de apela o funcție, cum ar fi string ajunge aici, și apoi stoca valoarea de retur. Este rezultatul acesteia efort în ceva. 

Și ceea ce este construct în programare, fie în zero sau acum C, pe care noi se poate folosi pentru a stoca de fapt ceva? A numit-o variabilă, nu? Și, în Scratch, noi nu prea pasă ce se întâmplă în variabile. 

Dar, în acest caz, vom face de fapt. Am de gând să spun șir de caractere. Și apoi aș putea suna acest lucru tot ce vreau. Mă duc să-l sun nume, devine primi șir. 

Și acum, chiar dacă sunteți un pic mai nou la acest lucru, observați că am lipsit unele detalii. Sunt uita un semi-colon. Trebuie să termin acest gând. Așa că mă voi muta cursorul meu, și a lovit semi-colon acolo. Și ce tocmai am făcut? În această linie de cod, numărul 5 în acest moment, Am sunat șir get fără intrări. Deci, nu există nici un alb mic cutie ca blocul de Salvare are. 

Spun doar că, hei, calculator, adu-mi un șir de caractere. Semnul egal nu este cu adevărat un semn egal, per se. Este atribuirea operatorul, ceea ce înseamnă, hei, calculator, mutați valoarea din dreapta spre stânga. Iar în stânga, am următoarele. 

Hei, calculator, da-mi un string-- o secvență de caractere. Și sună asta Nume șir. Și eu nu au nici măcar să-l numesc nume. 

Aș putea numi, în mod convențional, ceva de genul S, la fel ca am folosit i pentru a apelați variabila i. Dar acum am nevoie să fac ceva cu ea. Ar fi destul de prost să încercați compilarea acestui cod, care rulează acest program, chiar dacă Primesc un șir de caractere, pentru că este încă doar O să te salut mondială. 

Dar dacă eu vreau să schimbe acest lucru. De ce nu fac asta? La suta s, s virgulă. Și acest lucru este un pic criptic încă. 

Deci, să-mi fac variabilele mele mai clare. Permiteți-mi să numim acest Nume variabilă. Și să vedem dacă nu putem șicana în afară ce se întâmplă aici. 

Deci, pe linia cinci, eu sunt obtinerea un șir de caractere. Si eu sunt acel șir de stocare, indiferent de utilizator a tastat la tastatura lui sau ei, într-o variabilă numită nume. Și se pare că printf nu doar ia un argument în dublu citate, o intrare în ghilimele duble. 

Aceasta poate dura două sau trei, sau mai multe, cum ar că a doua, sau a treia, sau a patra, sunt toate numele variabilelor, sau în mod specific valori, pe care doriți să conectați în, dinamic, acel șir în ghilimele. Cu alte cuvinte, ceea ce ar fi în neregulă cu asta? În cazul în care tocmai am spus salut numele, backslash n, a salvat fișierul meu, compilat codul meu, și a fugit acest lucru, ce s-ar întâmpla? 

Este doar o să spun, salut nume, literalmente N-A-M-E, care este un fel de prost, deoarece nu e diferit de lumea. Așa că nimic în ghilimele este ceea ce literalmente se imprimă. Așa că, dacă vreau să am un înlocuitor acolo, de fapt, am nevoie pentru a utiliza unele sintaxă specială. Și se pare că, dacă ai citit documentație pentru funcția printf, vă va spune că dacă utilizați procente s, puteți înlocui o valoare după cum urmează. 

După o virgulă după aceea dublu citat, pur și simplu scrie pe numele variabilă pe care doriți să conectați în acest format cod, sau în format specifier, procente pentru siruri de caractere. Și acum, dacă am salvat fișierul meu, Mă duc înapoi la terminalul meu. Și I tip String Make, pentru că, din nou, numele acestui fișier pe care am ales înainte de string.c. 

Așa că am de gând să spun realiza un șir, introduceți. Oh, Doamne, uita-te la toate greșelile pe care le-am făcut deja. Si acest este-- ceea ce este într-adevăr acest lucru ca un, șapte program de șase linii? Deci, acest lucru este în cazul în care se poate foarte obține rapid copleșitoare. 

Această fereastră are terminale acum doar regurgitate un număr foarte mare de mesaje de eroare. Cu siguranță, eu nu am mai eroare mesaje decât am linii de cod. Deci, ce se întâmplă? 

Ei bine, cea mai bună strategie pentru a face oricând tine se confruntă cu o copleșitoare lista de erori, cum ar fi faptul că, este defila înapoi, uita-te pentru comanda tocmai ai fugit, care, în cazul meu este de a face șir. Uita-te la ce face făcut, și cu asta basta comandă lung zăngănit, nu e mare acolo. 

Dar, roșu este rău. Verde încearcă să fie blând și de ajutor. Dar este încă rău, în acest caz. Dar, în cazul în care este rău? 

String.c, linia de cinci, cinci caractere. Deci, aceasta este doar convenție comună. Ceva de colon ceva înseamnă numărul de linie și numărul de caractere. Eroare, utilizarea nedeclarată string identificator. Ai vrut să spui standard? 

Așa că, din păcate, zăngănit este încercarea de a fi de ajutor. Dar este greșit, în acest caz. Nu, zăngănit, nu am vrut standardul IO. Am vrut să spun că, pe o singură linie, da. 

Dar, linia cinci este asta aici. Și zăngănit nu înțeleg S-T-R-I-N-G. Este un identificator nedeclarat, o cuvânt pur și simplu nu a mai văzut înainte. Si asta pentru ca C, limba noi scriem cod chiar acum, nu are variabile numite siruri de caractere. 

Ea nu are, în mod implicit, suport ceva numit un șir de caractere. Asta-i o bucată de CS50 jargonul, dar foarte convențional. Dar eu pot rezolva această problemă, după cum urmează. 

În cazul în care am adăuga o linie de cod în partea de sus a acestui program, includ CS50.h, care este un alt fișier undeva în interiorul CS50 IDE, undeva pe hard disk, ca să spunem așa, a sistemului de operare Ubuntu că eu sunt difuzate, că este fișierul care este va preda în funcțiune sistem ce este un șir de caractere, doar cum ar fi io.h standard este fișierul în sistemul de operare care este O să-l învețe ce printf este. 

Într-adevăr, ne-ar fi ajuns un mesaj foarte asemănător în cazul în care IO a admis standardul IO.h și a încercat să folosească printf. Așa că am de gând să merg mai departe și doar să preia controlul L pentru a goli ecranul. Sau puteți introduce clar și va doar clar fereastra terminalului. Dar vă puteți defila încă înapoi în timp. 

Și am de gând să rulați din nou realiza un șir. Cruce degetele mele de data aceasta, Enter. Oh, Doamne, a funcționat. mi arată o comandă de lungă criptic că este ceea ce Marcă au generat prin intermediul zăngănit, dar nici un mesaj de eroare. Așa că dau seama, chiar dacă s-ar putea obține complet copleșit de Numărul de mesaje de eroare, ea ar putea fi doar acest enervant în cascadă efect, în cazul în care zăngănit nu înțelege un singur lucru, ceea ce înseamnă că atunci nu înțelege cuvântul următor, sau linia următoare. Și așa doar inductoare de pe codul. Dar fix s-ar putea să fie simplu. Și, astfel încât întotdeauna să se concentreze pe de prima linie de ieșire. Și, dacă nu Înțeleg că, uita-te doar pentru cuvintele cheie care ar putea fi indicii, și numărul liniei, și caracterul, în cazul în care că greșeala ar putea fi. 

Acum, lasă-mă să merg mai departe și tastați dot slash, șir, introduceți. Hm, nu spune nimic salut. De ce? Ei bine, amintesc, în cazul în care este execută? 

Este, probabil, blocat în acest moment într-o buclă, dacă va fi, pe linia de șase, deoarece Ia-String prin design, în scris de către personalul CS50, este literalmente menit să stea doar acolo de așteptare, și de așteptare, și de așteptare pentru un șir de caractere. Tot ceea ce înțelegem prin șir de intrare este uman. Deci, tu ce știi? Lasă-mă să merg mai departe. Și doar pe un capriciu, lasă-mă tastați numele meu, David, introduceți. Acum am un program mai dinamic. Acesta a spus, salut David. 

Dacă mă duc mai departe și a alerga acest lucru din nou, lasă-mă să încerc spun numele Zamila, introduceți. Și acum avem un program dinamic. Nu am codificate greu mondiale. Nu am codificate greu nume sau David sau Zamila. 

Acum este mult mai mult ca programele știm, în cazul în care în cazul în care luați de intrare, ea produce ieșire ușor diferită. Acum, acest lucru nu este cel mai bun experiența utilizatorului, sau UX. Am rula programul. 

Nu știu ce-ar trebui de a face, dacă nu de fapt, uita-te la sau să vă amintiți codul sursă. Așa că hai să facem utilizatorului experimenta un pic mai bine cu cele mai simple lucruri. Lasă-mă să mă întorc în asta program și spune pur și simplu printf. 

Și lasă-mă să merg mai departe și spun numele, de colon, și un spațiu, și apoi un semi-colon. Si doar pentru lovituri, fără reacții negative n. Și asta e în mod deliberat, pentru că nu vreau prompt pentru a trece la linia următoare. 

Vreau, în schimb, a face acest lucru, face șir de caractere să recompilați codul meu într-o nouă mașină cod dot slash șir. Ah, acest lucru este mult mai frumoasa. Acum, de fapt, eu știu ce computerul vrea ca eu să fac, da un nume. 

Așa că am de gând să merg mai departe și tastați în Rob, intră, și salut, Rob. Așa că, realiza, aceasta este încă, la sfârșitul anului a doua zi, doar un program de nouă linie. Dar ne-am luat acești pași pentru copii. 

Am scris-o singură linie cu care ne-am erau familiare, printf, hello world. Apoi am undid un pic de asta. Si am folosit de fapt șir get. Si ne-am aruncat acea valoare într-o variabilă. Și apoi am mers mai departe și îmbunătățite l în continuare cu o a treia linie. Iar acest proces iterativ de scris software-ul este cu adevărat cheie. În CS50, și în viață, în general, în general, nu ar trebui să stai jos, au un program în minte, și încercați să scrieți totul naibii totul dintr-o dată. 

Ea va fi, în mod inevitabil, ca rezultat într-un mod mai multe erori decât ne-am văzut aici. Chiar și eu, până în această zi, în mod constant face alte greșeli stupide, sunt greșeli de fapt mai greu care sunt mai greu să dau seama. Dar va face mai multe greșeli mai mult linii de cod scrieți toate dintr-o dată. Și astfel, această practică, a scrie un pic de cod că tu ești confortabil, compila ea, rulați-l, testați-l mai general, apoi mutați on-- astfel încât la fel ca și ne-am păstrat stratificarea și stratificarea săptămâna trecută, construirea de la ceva foarte simplu la ceva mai complex, face același lucru aici. Nu stai jos, și să încerce să a scrie o întreagă problemă. De fapt, acești pași să ia copii. 

Acum, siruri de caractere nu sunt toate că utile pentru ei înșiși. Ne-ar, de fapt, în mod ideal, cum ar fi să au altceva în set de instrumente noastre. Așa că hai de fapt, face exact asta. 

Lasă-mă să merg mai departe acum și biciul un program ușor diferit. Si noi vom numi acest int.c, pentru întreg. Mă duc să, în mod similar, includ CS550.h. Am de gând să includă standardul IO. Si asta va fi destul de frecvente în aceste primele câteva zile ale clasei. 

Și voi gata eu cu o funcție principală. Iar acum, în loc de a obține un șir de caractere, Să mergem mai departe și să obțină un int. Hai să-l sun eu, si suna-l int parens aproape, semi-colon. Și acum să facem ceva cu ea, printf. 

Hai să spunem ceva de genul Bună ziua, backslash n, i virgulă. Deci, eu sunt destul de mult mimarea ceea ce am făcut doar o clipă în urmă. Am un înlocuitor aici. Am virgulă i aici, pentru că vreau la i conectați în acel substituent. 

Așa că hai să mergem mai departe și să încerce compilarea acestui program. Fișierul este numit int.c. Așa că am de gând să spun, fac int enter. Oh, Doamne, dar nu e mare, nu? E o greșeală. 

E o greșeală sintactică aici, astfel încât programul nu poate să fie compilate în interiorul int.c, linie șapte, caracter 27, format de eroare specifică tip char stea, indiferent ce este. Dar, tipul de argument este int. 

Deci, aici, de asemenea, vom nu merge sa-- chiar dacă astăzi este o mulțime de materiale, vom să vă copleșească cu absolut fiecare trăsătură a C, și programarea mai general, in doar aceste primele câteva săptămâni. Deci, exista de multe ori va fi jargon cu care nu sunteți familiarizați. Și, de fapt, char stea este ceva ne vom întoarce la într-o săptămână sau timp de doi lui. 

Dar, pentru moment, să vedem dacă putem analiza cuvinte care sunt familiare. așa că Formats-- am auzit formatul specifier, cod format înainte de a. Asta e familiar. Type-- dar argumentul are tip int. Stai puțin, i este un int. 

Poate la suta s de fapt are un sens definit. Si, intr-adevar, o face. Un număr întreg, dacă doriți printf să-l înlocuiască, tu de fapt, trebuie să utilizați un format diferit specificator. Și n-ar ști acest lucru cu excepția cazului în cineva ți-a spus, sau ați făcut-o înainte. Dar, la sută, i este ceea ce pot fi utilizate în mod obișnuit în printf pentru conectarea într-un întreg. De asemenea, puteți utiliza la sută d pentru un număr întreg zecimal. Dar i este simplu si frumos aici. Așa că vom merge cu asta. 

Acum, lasă-mă să merg mai departe și rerun marca int Enter. Asta e bine, nici o eroare. Dot slash OK int--, experiența utilizatorului rău, pentru că nu m-am spus ce sa fac. Dar asta e bine. Sunt prinderea pe repede. 

Și acum lasă-mă să merg mai departe și tastați David, OK, Zamila, Rob. OK, astfel încât acesta este un lucru bun. De data aceasta, eu sunt, folosind o funcție, o piesă de puzzle, numit get int. Și se pare out-- și ne vom a se vedea acest lucru mai târziu în term-- personalul CS50 a pus în aplicare obține șir în așa fel că aceasta va numai fizic obține un șir de caractere pentru tine. 

S-a implementat get int în astfel încât acesta va numai obține un număr întreg pentru tine. Și dacă tu, omul, nu cooperează, este literalmente doar a merge la spun încerca din nou, încercați din nou, încercați din nou, literalmente stând acolo looping, până când vă obligă cu unele număr magic, cum ar fi 50, și salut 50. 

Sau, dacă vom rula acest lucru din nou și tipul de la 42, 42 Buna ziua. Si astfel functia get int în interiorul acelei piese de puzzle este destul de logică, îndeajuns de multă gândire, să ne dăm seama, ce este un cuvânt? Și ce este un număr? Numai acceptarea, în cele din urmă, numere. 

Deci, se pare că acest lucru nu este tot ceea ce expresiv. pana acum. Așa că, yay, ultima dată când am a mers destul de repede în jocuri de punere în aplicare, și de animație, și lucrări artistice în Scratch. Si aici, suntem conținut cu lumea salut, și salut 50. 

Nu e tot ce inspira. Și, într-adevăr, aceste prime exemple vor lua ceva timp la sol până în excitare. Dar noi avem atât de mult mai mult controlează în prezent, de fapt. Și vom merge la foarte începe rapid layering pe partea de sus a acestor primitivelor de bază. 

Dar, în primul rând, trebuie să înțelegem ce limitările sunt. De fapt, unul dintre lucrurile Zgârietură nu cu ușurință să ne facem este într-adevăr uite sub capota, și să înțeleagă ce computerul este, ceea ce poate face, și care sunt limitele sale. Și, într-adevăr, că lipsa înțelegere, potențial, pe termen lung poate duce la propria noastră scris mistakes-- bug-uri, software-ul scris nesigur că devine tocat într-un fel. 

Așa că hai să facem niște pași spre înțelegerea acest lucru un pic mai bine mod, să zicem, exemplul următor. Mă duc să merg mai departe și să pună în aplicare real, rapid un program numit Adder. Cum ar fi, să adăugăm niște numere împreună. Și voi să cod unele colțuri aici, și doar să copiați și lipiți unde am fost înainte, doar astfel încât să putem să plecăm mai devreme. Așa că acum am începuturi de bază a unui program numit Adder. 

Și să mergem mai departe și de a face acest lucru. Mă duc să merg mai departe și să zicem, INTx devine primi int. Si tu ce știi? Hai să facem o experiență de utilizare mai bună. 

Așa că hai să spunem x este, în mod eficient și cere utilizatorului să ne dea de x. Și apoi lasă-mă să merg mai departe și spun, printf cum despre y este, de data aceasta așteptându două valori de la utilizator. Și apoi să mergem mai departe și să zicem, printf, suma lui x și y este. Și acum nu vreau sa fac la suta s. Vreau să fac procente i, backslash n, și apoi conectați valoare sumă. 

Deci, cum pot merge despre a face acest lucru? Știi ce? Știu cum să folosească variabile. Lasă-mă să declare doar unul nou, int z. 

Și mă duc să iau o presupunere aici. Dacă există semne egale în această limbă, poate că eu pot face doar x plus y, atât timp cât am sfârșitul meu gândit cu un semi-colon? Acum mă pot întoarce aici în jos, conectați z, termina acest gând cu un semi-colon. Și să vedem acum, în cazul în care acestea Secvențele de x lines-- este de a lua int. Y este de a lua int. 

Se adaugă x și y, păstrează valoarea în z-- deci, din nou, amintiți-vă semnul egal nu este egal. Este misiune de la dreapta la stânga. Și să imprime că suma x și y nu este literalmente z, dar ceea ce este în interiorul lui z. Așa că hai să facem Adder - frumos, fără greșeli de data asta. Dot slash Adder, introduceți, x va fi 1. 

Y va fi 2. Și suma lui x și y este 3. Deci asta e tot fin și bun. 

Așa că v-ar imagina că matematica ar trebui să lucreze într-un program de genul asta. Dar știi ce? Este această variabilă, linie 12, chiar necesar? Nu aveți nevoie pentru a obține în obiceiul de a stoca doar lucruri în variabile doar pentru că poți. Și, de fapt, este în general Design considerate proaste dacă creați o variabilă, numită z, în acest caz, depozitarea ceva în ea, și apoi imediat folosindu-l, dar niciodată din nou. De ce să dea ceva un nume cum ar fi z dacă sunteți literalmente O să folosească lucru doar o singură dată, și așa mai departe proximal în cazul în care ați creat-o aceasta în primul rând, atât de aproape, în ceea ce privește liniile de cod? Deci, tu ce știi? Se pare că, C este destul de flexibil. Dacă aș fi de fapt, doresc să plug-in valori aici, Nu am nevoie să declare o nouă variabilă. Aș putea doar plug-in x plus y, deoarece C înțelege aritmetică, și operatorii matematice. 

Deci, eu pot spune pur și simplu, face acest lucru matematica, x plus y, oricare ar fi aceste valori sunt, conectați rezultați întreg în acel șir. Deci, acest lucru ar putea fi, totuși doar o singură linie mai scurtă, un design mai bun, un program mai bun, pentru că există mai puțin de cod, prin urmare, mai puțin pentru mine să înțeleg. Și este, de asemenea, doar mai curat, în măsura în care nu suntem introducerea de cuvinte noi, noi simboluri, cum ar fi z, chiar dacă acestea nu fac într-adevăr servesc o mare parte a unui scop. 

Din nefericire, matematica nu este toate că, uneori, de încredere. Hai să mergem mai departe și de a face acest lucru. Mă duc să merg mai departe acum și de a face următoarele. 

Hai să facem printf, procente i, în plus la sută i, sunt procente i, backslash n. Si am de gând să fac asta-- XYX plus y. Așa că am de gând doar să rescrie acest lucru ușor diferit aici. Lasă-mă să fac o verificare bun-simț rapid. Din nou, hai să nu ne pripim. Asigurați-sumator, punct slash sumator. x este 1, y 2, 1 plus 2 este 3. Deci asta e bine. Dar, hai să complice acest lucru acum un pic, și de a crea un nou fișier. 

Voi suna asta, spune, Ints, plural pentru numere întregi. Permiteți-mi să încep unde am fost un moment în urmă. Dar, acum, să facem alte câteva rânduri. Lasă-mă să merg mai departe și fac următoarele, printf, procente i, minus la sută i, este la sută i, virgula x, y minus virgula YX. Deci, eu fac ușor diferite de matematică acolo. Hai să facem încă una. Așa că sută la sută de ori i i este la sută i, backslash n. Hai sa plug-in x, si y, x și y ori. Vom folosi asterisc computerul pentru vremuri. 

Tu nu utilizați x. x este un nume de variabilă aici. Utilizați steaua pentru multiplicare. Hai să facem una. Printf la sută I, divizat de procente i, este la sută I, n backslash. xy împărțit la y-- astfel încât să utilizați slash înainte în C pentru a face divizare. Și să facem unul de altul. Remainder de procente i, divizat de procente i, este la sută i. xy-- și acum restul este ceea ce a mai rămas. Atunci când încercați divizarea unui denominator într-un numărător, cât de mult este lăsat peste asta nu a putut împărți afară? 

Deci nu este într-adevăr, în mod necesar, un simbol am folosit în școală pentru clasa asta. Dar există în C. Puteți spune x modulo y, în cazul în care acest semn la sută în acest context-- atunci când ești un risc de confuzie în interior dintre ghilimele duble, în interiorul printf, procente este utilizat ca specificatorul de format. 

Atunci când utilizați procente în afara că într-o expresie matematică, este operatorul modulo pentru modulare arithmetic-- pentru scopurile noastre aici, înseamnă doar, ceea ce este restul de x împărțit la y? Deci x împărțit la y este x y slash. Care este restul x împărțit la y? Este x y mod, ca un programator ar spune. 

Deci, dacă am făcut nici o greșeală aici, lasă-mă mergeți mai departe și să facă Ints, plural, frumos, și Ints slash punct. Și să mergem mai departe și face, să zicem, 1, 10. Bine, 1 plus 10 este de 11, cec. 1 minus 10 este negativ 9, verificați. 

1 ori 10 este 10, cec. 1 împărțit la 10 este-- OK, vom trece peste asta. Remainder de 1 împărțit la 10 este 1. Este corect. Dar există o problemă aici. 

Așa că l-am pus meu preda, nu este corect. Adică, este aproape de 0. 1 împărțit la 10, tu știi, dacă suntem tăierea unele colțuri, sigur, este zero. Dar ar trebui să fie într-adevăr 1/10, 0,1, sau 0,10, 0,1000, sau așa mai departe. 

Aceasta nu ar trebui să fie într-adevăr zero. Ei bine, se pare că computerul este făcând literalmente ceea ce am spus. Noi facem matematica cum ar fi x împărțit la y. Și x și y, pe liniile de cod anterior, sunt numere întregi. 

Mai mult decât atât, pe linia 15, suntem spune printf, hei, printf plug-in un număr întreg, plug-in-un număr întreg, plug-in-un integer-- specific x, y și apoi, și apoi x împărțit la y. x și y sunt Ints. Suntem bine acolo. 

Dar ceea ce este x împărțit la x? x împărțit y ar trebui să fie, matematic, 1/10, sau 0,1, care este un număr real, un număr real având, eventual, un punct zecimal. Nu e un număr întreg. 

Dar ceea ce este cel mai aproape număr întreg de la 1/10, sau 0,1? Da, este un fel de este zero. 0.1 este ca aceasta mult. Și 1 este atât de mult. Deci 1/10 este mai aproape 0 decât este una. 

Și ce C este de a face pentru us-- un fel de pentru că l-am spus sa-- este trunchiere acel număr întreg. Durează valoarea, care este din nou ar trebui să fie ceva de genul 0.1000, 0 și așa mai departe. Și este totul trunchierea după virgulă astfel încât toate acestea lucruri, deoarece nu se potrivesc în noțiunea de un număr întreg, care este doar un număr negativ cum ar fi 1, 0, 1, în sus și în jos, se aruncă totul după punctul zecimal deoarece ați nu se poate potrivi cu un punct zecimal într-un întreg prin definiție. 

Deci, răspunsul aici este zero. Deci, cum putem rezolva această problemă? Avem nevoie de o altă soluție împreună. Și noi putem face acest lucru, după cum urmează. 

Lasă-mă să merg mai departe și de a crea un nou fișier, acesta numit floats.c. Și salvați-l aici, în același director, float.c. Și lasă-mă să merg mai departe și să copiați o parte din acest cod de mai devreme. 

Dar, în loc de a obține un int, să facem acest lucru. Dă-mi o valoare în virgulă mobilă numita x. în cazul în care un punct plutitor Valoarea este doar literalmente ceva cu un punct plutitor. Se poate deplasa spre stânga, spre dreapta. Este un număr real. 

Și lasă-mă să nu sun obține int, dar obține float, care, de asemenea, a fost printre meniu de opțiuni în biblioteca C250. Hai să se schimbe y la un plutitor. Deci, acest lucru devine obține float. 

Și acum, noi nu vrem să conectați Ints. Se pare că avem de a folosi la sută f pentru float, procente f pentru float, și acum salvați-l. Și acum, degetele încrucișate, face plutește, frumos, plută slash dot. x va fi una 1. y Va fi 10 din nou. 

Si, frumos, OK plus mea este corectă. Am fost în speranța pentru mai mult, dar am uitat să-l scrie. Așa că hai să mergem și să stabilească această eroare logică. 

Hai să mergem mai departe și apuca următoarele. Vom face doar un pic de copiere și lipire. Si eu voi spune minus. 

Si voi spune ori. Si eu voi spune divizat. Si eu nu am de gând să fac modulo, care nu este la fel de germaniu aici, împărțit la f, și ori plus-- OK, hai să facem asta din nou. 

Face plută, plută slash dot, și 1, 10, si-- frumos, nu, OK. Așa că sunt un idiot. Deci, acest lucru este foarte frecvente în informatică pentru a face greșeli stupide de genul asta. 

În scopuri pedagogice, ceea ce am vrut să fac a fost schimba știința aici la plus, la minus, la ori, și să împartă, după cum sperăm a observat în timpul acestui exercițiu. Așa că acum să re-compila acest lucru Programul, face flotoare slash dot. 

Iar pentru a treia oară, să a se vedea dacă îndeplinește așteptările mele. 1, 10, introduceți, da, OK, 1.000, împărțit la 10.000, este 0.100000. Și se pare că putem controla cât de multe Numerele sunt după acele puncte zecimale. Noi de fapt, va fi. Vom reveni la asta. 

Dar acum, de fapt, matematica este corectă. Deci, din nou, ce-i MENIUL aici? Se pare că, în C, există nu numai că doar strings-- și, de fapt, nu sunt cu adevărat, pentru că noi se adaugă cei cu biblioteca CS50. Dar nu sunt doar Ints. 

Există, de asemenea, plutește. Și se pare că o grămadă de alte date Tipuri de asemenea, că vom folosi înainte de mult timp. Se pare că, dacă doriți un singur caracter, nu un șir de caractere, puteți folosi doar un char. 

Se pare că, dacă doriți un bool, o valoare booleană, numai adevărat sau fals, grație bibliotecii CS50, ne-am a adăugat la C tipul de date bool, de asemenea. Dar este prezenta, de asemenea, în multe alte limbi. Și se pare că, uneori, nevoie de numere mai mari, apoi vin în mod implicit cu Ints și plutește. 

Și, de fapt, un dublu este un număr care nu utilizează 32 de biți, dar 64 de biți. Și un lung lung este un număr care nu utilizează 32 de biți, dar 64 de biți, respectiv, pentru virgulă mobilă valori și numere întregi, respectiv. Așa că hai de fapt acum a se vedea acest lucru în acțiune. 

Mă duc să merg mai departe aici și biciul unul alt program. Aici, am de gând să merg mai departe și includ CS50.h. Și lasă-mă să plec, includ standardul IO.h. 

Și veți observa ceva funky, se întâmplă aici. Nu e de culoare de codificare lucruri în în același mod ca și a făcut-o mai înainte. Și se pare, asta pentru că eu nu s-au dat lucrul un nume de fișier. 

Mă duc să sun asta sizeof.c, și a lovit Salvare. Și observați ce se întâmplă cu foarte mea cod alb pe care fundalul negru. Acum, cel puțin acolo unele mov acolo. Și este sintaxa evidențiată. 

Asta pentru că, pur și simplu, am a spus IDE ce tip de fișier este dându-i un nume, și în mod specific o extensie de fișier. Acum, să mergem mai departe și de a face acest lucru. Mă duc să merg mai departe și foarte pur și simplu imprima bool following-- este de procente LU. 

Vom reveni la că, în doar un moment. Și apoi voi Dimensiunea de imprimare de bool. Și acum, doar pentru a salva eu ceva timp, eu sunt O să facă un întreg grămadă de acestea dintr-o dată. Și, în special, voi schimba acest lucru la un char și char. Acesta, am de gând să se schimbe la o dublă și o dublă. 

Acesta, am de gând să se schimbe la un flotor și un plutitor. Acesta, voi schimba la un int si un int. Si asta, voi pentru a trece la o lungă lungă. Și este încă luați o lungă perioadă de timp, mult timp lung. 

Și apoi, în cele din urmă, i-am dat eu una prea multe, șir de caractere. Se pare că, în C, există operatorul special numit mărimea asta literalmente merge la, atunci când executați, spune-ne dimensiunea fiecare dintre aceste variabile. Si aceasta este o cale, acum, ne putem conecta înapoi la discuția de săptămâna trecută de date și de reprezentare. 

Lasă-mă să merg mai departe și compila Dimensiunea de marimea slash punct de. Și să vedem. Se pare că, în C, în special pe CS50 IDE, în special pe sistem de operare Ubuntu, care este un sistem de operare pe 64 de biți sistem în acest caz, o bool va utilizați un octet de spațiu. Asta e modul în care se măsoară dimensiunea, nu în biți, dar în octeți. Și amintesc că un octet este de opt biți. Deci, un bool, chiar dacă punct de vedere tehnic au nevoie doar de 0 sau 1, este un pic mai risipitor cum i-am pus în aplicare. Este de fapt de gând să folosească un întreg byte-- astfel încât toate zerouri, sunt probabil toate cele, sau ceva de genul asta, sau doar un singur 1 între opt biți. 

Un char, între timp, folosit pentru un personaj ca un caracter ascii pe saptamana trecuta, va fi un singur caracter. Și că synchs cu noțiunea noastră de ea fiind nu mai mult de 256 de bits--, mai degrabă, synchs cu ea nefiind mai mult de 8 biți, care ne dă cât mai multe 256 de valori. O dublă va fie de 8 octeți sau 64 de biți. 

Un float este de 4. Int este 4. Un lung, lung este 8. Și un șir de caractere este 8. Dar nu vă faceți griji despre asta. Vom merge să coaja înapoi acel strat. Se pare, siruri de caractere poate să fie mai mare de 8 octeți. 

Și, într-adevăr, ne-am scris siruri de caractere deja, hello world, mai mult de 8 octeți. Dar ne vom întoarce la că, în doar un moment. Dar aici este ține departe următorul. 

Orice computer are doar un finit cantitate de memorie și spațiu. Puteți stoca doar atât de multe fișiere de pe Mac sau PC-ul. Puteți stoca numai atât de multe programe în RAM care rulează la o dată, în mod necesar, chiar cu memorie virtuală, deoarece aveți o cantitate finită de RAM. 

Și doar pentru picture-- dacă n-ai deschis un laptop sau comandate de memorie suplimentară pentru un computer, s-ar putea să nu știu că în interiorul computerului este ceva care arată un pic ca asta. Deci, aceasta este doar o companie comună numită Crucial care face RAM pentru calculatoare. Și RAM este în cazul în care programele trăiesc în timp ce acestea sunt difuzate. 

Deci, pe fiecare Mac sau PC-ul, atunci când dublu faceți clic pe un program, și se deschide, și deschide unele document Word sau asa ceva, îl stochează temporar în RAM, deoarece memoria RAM este mai rapid decât hard disk, sau discul în stare solidă. Deci, e doar în cazul în care programele de du-te să trăiască când rulează, sau atunci când sunt utilizate fișiere. 

Deci, tu ai lucruri care arata cum ar fi acest lucru în interiorul laptop-ul, sau lucruri ușor mai mari în interiorul desktop-ul tau. Dar cheia este aveți doar o număr finit de aceste lucruri. Și nu există decât o cantitate finită de hardware-ul așezat pe acest birou drept aici. 

Așa că, cu siguranță, nu putem stoca numere infinit lungi. Și totuși, dacă te gândești înapoi la școală de grad, cât de multe cifre pot aveți la dreapta dintr-un punct zecimal? Pentru asta contează, cât de multe cifre pot trebuie la stânga unui punct zecimal? Într-adevăr, infinit de multe. 

Acum, noi oamenii doar s-ar putea Știi cum se pronunță milioane, și miliarde, trilioane, și catrilion și quintillion. Și mă împinge limitele mele understanding-- sau my-- am înțeles numere, dar mea pronunția numerelor. Dar ei pot obține infinit de mare, cu infinit mai multe cifre la stânga sau la dreapta unui punct zecimal. 

Dar, calculatoarele au doar o cantitate finită de memorie, un număr finit de tranzistori, un număr finit de becuri din interior. Ce se întâmplă atunci când tu a alerga afară de spațiu? Cu alte cuvinte, dacă cred că înapoi la săptămâna trecută când am vorbit despre numere ele însele fiind reprezentate în binar, să presupunem că avem această valoare pe 8 biți aici. 

Și avem șapte 1 și unul 0. Și să presupunem că vrem pentru a adăuga 1 la această valoare. Acesta este un număr foarte mare, chiar acum. 

Acest lucru este 254, dacă îmi amintesc matematica din ultima săptămână dreapta. Dar, ce se întâmplă dacă am schimba că extrema dreaptă 0 la 1? Numărul întreg, de Desigur, devine opt 1 lui. Deci, suntem încă bine. 

Și aceasta reprezintă, probabil, 255, deși în funcție de context ar putea reprezenta de fapt un număr negativ. Dar mai mult pe altă dată. Acest lucru se simte ca este vorba despre la fel de mare ca eu pot conta. 

Acum, este doar 8 biți. Și, Mac-ul meu, cu siguranță, are modul mai mult de 8 biți de memorie. Dar are finit. Prin urmare, același argument se aplică, chiar dacă am au mai multe dintre acestea pe ecran. 

Dar ce se întâmplă dacă sunteți stocarea acestui număr, 255, și doriți să conta un pic mai mare? Vrei să mergi 255-256. Problema, desigur, este că, dacă începe numărarea de la zero, cum ar fi săptămâna trecută, nu poate conta la fel de mare ca 256, să nu mai vorbim 257, să nu mai vorbim 258, m pentru că ceea ce se întâmplă atunci când adăugați un 1? Dacă veți face școala clasa veche abordare, ai pus-o aici 1, și apoi 1 plus 1 este 2, dar asta într-adevăr un zero, ai transporta 1, transporta 1, transporta 1. Toate aceste lucruri, aceste lui 1, du-te la zero. Si ajungi, da, ca cineva a subliniat, un 1 de pe partea stanga. Dar, tot ce poți de fapt, a se vedea și se potrivesc în memorie este doar opt 0, care este de a spune la un moment dat, dacă tu, un calculator, a încercat de numărare destul de mare în sus, tu ești O să-și încheie în jurul valorii, s-ar părea, la zero, sau poate chiar negativ numere, care sunt chiar mai mici decât zero. 

Si putem vedea un fel de acest lucru. Lasă-mă să merg mai departe și scrie un adevărat program de rapid aici. Lasă-mă să merg mai departe și scrie un program numit overflow. Includ CS50.h, includ standardul IO.h-- oh, Chiar am ratat meu sintaxa.Valorile. Deci să salvăm acest lucru ca overflow.c. 

Și acum int void-- principal și înainte de mult timp, ne vom vin înapoi pentru a explica de ce vom păstra scris void main int. Dar pentru acum, hai să facem ea, luând-l pentru a acordat. Hai să mă dau un int, și inițializarea la 0. 

Hai să facem atunci pentru int I a lua zero-- de fapt, să facem o buclă infinită și să vedem ce se întâmplă. În timp ce este adevărat, atunci să imprimați n este la sută i, backslash n, plug-in n. Dar, acum, să facem n plus 1 devine n. 

Cu alte cuvinte, pe fiecare iterație a acestei bucle infinite, Să luăm o valoare a lui n, și se adaugă 1 la ea, și apoi stoca rezultatul înapoi în n pe partea stângă. Și, de fapt, am văzut sintaxa ușor ca aceasta, pe scurt. Un truc rece este în schimb de a scrie toate acestea afară, poti spune de fapt un n plus este egal cu 1. 

Sau, dacă într-adevăr doriți să fie fantezie, puteți spune n plus, plus, semi-colon. Dar, acestea din urmă două sunt doar ceea ce am numi zahăr sintactic pentru primul lucru. 

Primul lucru este mai explicit, total bine, total corect. Dar acest lucru este mai frecvent, voi spune. Deci, vom face acest lucru pentru un moment. 

Să ne face acum preaplin, care sună mai degrabă de rău augur, preaplin slash punct. Hai să vedem, n Devine destul de mare. Dar să ne gândim, cât de mare se poate obține n? 

n este un întreg. Am văzut un moment în urmă cu dimensiunea de exemplu, că un int este de patru octeți. Știm din săptămâna trecută, patru octeți este 32 de biți, pentru că de 8 ori 4, e 32. Asta va fi de 4 miliarde. 

Și noi suntem de până la 800.000. Acest lucru va dura pentru totdeauna la conta la fel de mare ca mine, eventual, pot. Așa că am de gând să merg mai departe, așa cum s-ar putea înainte de mult timp, și a lovit de control sincer C--, control C, o mulțime, în cazul în care controlul C, în general, înseamnă a anula. Din păcate, deoarece aceasta se execută în nor, uneori, norul este scuipă lucruri atât de mult, atât de mult de ieșire, va să ia un pic în timp ce pentru intrarea mea pentru a ajunge la nor. Deci, chiar dacă am lovit Controlul C acum câteva secunde, acest lucru este cu siguranță partea efectul unei bucle infinite. 

Și astfel, în astfel de cazuri, suntem O să părăsească fie. Și, vom adăuga un alt fereastră de terminal aici cu plus, care, desigur, nu cum ar fi că, din moment ce încă mai gândesc. Și să mergem mai departe și să fie un pic mai rezonabil. 

Mă duc să merg mai departe și de a face acest lucru numai de multe ori. un număr finit Să folosim o buclă, pe care am făcut aluzie la mai devreme. Sa o facem. Dă-mi un alt int variabila i devine 0. i este mai mică decât, să zicem, 64 i ++. Și acum lasă-mă să merg mai departe și de imprimare out n este sută i, virgulă n. Și apoi acest lucru este încă N- va dura pentru totdeauna. Sa o facem. 

n devine de n ori 2. Sau am putea fi fantezie și de a face ori egal cu 2. Dar, să zicem n este egal cu sine, ori 2. Cu alte cuvinte, în această Noua versiune a programului, Nu vreau să aștepte pentru totdeauna de la cum ar fi 800.000 până la 4 miliarde. Să luăm doar terminăm cu asta. 

Jocul va fi lăsat de fapt dublu n fiecare dată. Ceea ce, amintesc, dublarea este cea vizavi de a avea, desigur. Și, în timp ce săptămâna trecută avem ceva nou, și din nou, și din nou, super rapid, dublarea siguranță va du-ne de la 1 la cel mai mare posibil Valoarea pe care putem conta la cu un int. 

Așa că hai să facem exact acest lucru. Si vom reveni la acest lucru înainte de mult timp. Dar acest lucru, din nou, este la fel ca blocul se repetă în Scratch. Și veți utiliza acest lucru înainte de mult timp. 

Acest lucru înseamnă că doar numărul de la zero până la, dar nu este egal, la 64. Iar pe fiecare iterație a acestui buclă, continuați să incrementare i. Asa ca i ++ - și acest construct general, pe linia 7 este doar o modalitate extrem de comună repetarea unor linii de cod, unele mai multe ori. Care linii de cod? Aceste acolade, ca tine pot fi spicuite de acum, înseamnă, efectuați următoarele. 

Este în Scratch cum ar fi, atunci când are blocurile galbene și alte culori, acest tip de îmbrățișa sau îmbrățișare alte blocuri. Asta e ceea ce creț acele bretele sunt aici. Așa că, dacă am sintaxa mea tine right-- se poate vedea simbolul morcov înseamnă C asta de câte ori am fost încercând să rezolve această problemă. Așa că haideți să scapi de unul cu totul, și închideți fereastra aia. Iar noi vom folosi cea nouă. Asigurați-vă de preaplin, slash dot preaplin, Enter, bine, Se pare rău la început. Dar, să derulați înapoi în timp, pentru că am făcut acest lucru de 64 de ori. 

Și observați prima dată, n este 1. A doua oara, n este 2, apoi 4, apoi 8, apoi 16. Și se pare că, de îndată ce Am ajunge la aproximativ 1 miliard, dacă am dubla din nou, că ar trebui să-mi dea 2 miliarde. Dar, se pare, este chiar pe punctul de inflexiune. 

Și așa se revarsă de fapt un int de la 1 miliard la aproximativ 2 negativ miliarde de euro, pentru că un număr întreg, spre deosebire de statisticile pe care le au fost presupunând săptămâna trecută, poate fi atât pozitive, cât și negative în realitate, și într-un calculator. Așa că cel puțin unul dintre cei biți este furat în mod eficient. Așa că avem într-adevăr avem doar 31 de biți, sau 2 miliarde de valori posibile. 

Dar, pentru moment, takeaway este destul de pur și simplu, oricare ar fi aceste numere sunt și indiferent de matematica este, ceva rău se întâmplă în cele din urmă, pentru că în cele din urmă pe care încercați să permuta biții de prea multe ori. Iar tu du-te în mod eficient de toate 1 lui poate la toate 0 lui, sau poate doar un alt model pe care-l în mod clar, în funcție de context, poate fi interpretată ca un număr negativ. Și așa s-ar părea cel mai înalt I poate conta în acest program special este doar aproximativ 1 miliard. Dar există o soluție parțială aici. Știi ce? 

Lasă-mă să se schimbe dintr-un int la o lungă lungă. Și lasă-mă să merg mai departe aici și say-- voi avea pentru a schimba acest lucru într-o lungă fără semn. Sau, hai să vedem, eu nu mi amintesc. 

Să mergem mai departe și să facă preaplin. Nu, nu-i asta, LLD, vă mulțumesc. Așa că, uneori, zăngănit poate fi de ajutor. Nu-mi amintesc ce formatul Specificator a fost pentru o lungă lungă. 

Dar, într-adevăr, zăngănit mi-a spus. Verde este un fel de bun, încă înseamnă că a făcut o greșeală. Se ghicitul că am vrut să spun LLD. 

Așa că lasă-mă să-l sfat, o lungă număr zecimal lung, cu excepția asta. Și să-l rulați din nou, punct slash preaplin, Enter. Și acum, ce e cool e asta. 

În cazul în care defilează înapoi în timp, încă începe să numărând în același place-- 1, 2, 4, 8, 16. Observați, vom obține toate mod de până la 1 miliard. Dar, atunci vom ajunge în siguranță la 2 miliarde. 

Apoi vom ajunge la 4 miliarde de euro, apoi 8 miliarde de euro, 17 miliarde. Si vom merge mai mari, și din ce in ce mai sus. În cele din urmă, acest lucru, de asemenea, pauze. 

În cele din urmă, cu o lungă lungă, care este valoarea de 64 de biți, nu o valoare de 32 de biți, dacă numărul prea mare, în jurul valorii de 0 înfășurați. Și, în acest caz, se întâmplă să se încheie cu un număr negativ. 

Deci, aceasta este o problemă. Și se pare că acest lucru problema nu este tot ceea ce arcane. Chiar dacă am intenționat induse cu aceste greșeli, se pare că vom vedea un fel de toate în jurul nostru, sau cel puțin unii dintre noi. 

Deci, în Lego Star Wars, dacă v-ați jucat vreodată jocul, se pare că vă puteți merge în jurul valorii de rupere lucrurile în lumea LEGO, și monede de colectare, în esență. Și, dacă v-ați jucat vreodată acest joc prea mult timp, ca acest individ fără nume aici a făcut, numărul total de monede pe care le pot colecta este, s-ar părea, 4 miliarde. 

Acum, cu ea e de fapt rotunjit. Așa că LEGO a încercat să să păstreze lucrurile ușor de utilizat. Ei nu a făcut-o exact 2 32 putere, pe saptamana trecuta. Dar, 4 miliarde de euro este un motiv. Se pare că, pe baza acestor informații, că LEGO, și compania care a făcut acest software-ul real, a decis că numărul maxim de monede utilizatorul poate acumula este, într-adevăr, 4 miliarde de euro, pentru că ei au ales în codul lor de a utiliza nu un lung lung, aparent, ci doar un număr întreg, un nesemnat număr întreg, doar un număr întreg pozitiv, al cărui Valoarea maximă este de aproximativ asta. Ei bine, aici e încă una amuzantă. Deci, în civilizația de joc, care unii dintre voi s-ar putea să fie familiarizat, cu se pare că acum câțiva ani acolo a fost un bug în acest joc, prin care dacă ai jucat rolul Gandhi în joc, în loc să-i fie foarte pacifistă, în schimb a fost incredibil, incredibil agresiv, în anumite circumstanțe. În special, modul în care Civilization fapte este că, dacă, player-ul, să adopte democrația, dvs scor agresivitate devine decrementat cu doi, deci minus minus, iar apoi minus minus. 

Deci ai scade 2 din recapitularea-ul real. Din păcate, în cazul în care recapitularea este inițial 1, și se scade 2 din ea după adoptarea democrației ca Gandhi aici s-ar putea s-au făcut, pentru că el a fost foarte passive-- 1 pe scara de agresivitate. Dar, dacă el adoptă democrația, atunci el merge de la 1 la 1 negativ. 

Din nefericire, ei erau folosind numere fără semn, ceea ce înseamnă că au tratat chiar negative Numerele ca și cum acestea au fost pozitive. Și se pare că echivalentul pozitiv al negativ 1, în programe de calculator tipic, este de 255. Așa că, dacă Gandhi adoptă Și, prin urmare, democrația are scorul său agresivitate a scăzut, este de fapt sub formă de rulouri în jurul valorii de 255 și-l face cel mai mult caracterul agresiv în joc. Astfel încât să puteți Google pe acest lucru. Și a fost, într-adevăr, o bug de programare accidentale, dar care a intrat destul de lore de atunci. 

Asta e tot distracție și drăguț. Mai înfricoșător este atunci când real Dispozitivele din lumea reală, și nu jocuri, au aceleași aceste bug-uri. De fapt, doar un an în urmă un articol a venit despre Dreamliner Boeing 787. 

Iar articolul la început scurt citește un pic arcane. Dar a spus acest lucru, un software vulnerabilitate Boeing Noul 787 are jet potențialul de a provoca piloților să-și piardă controlul aeronava, eventual în mijlocul zborului, oficialii FAA linii aeriene. avertizat recent A fost determinarea că un model 787 avion care a fost alimentat în mod continuu timp de 248 de zile poate pierde toate curent alternativ, AC, energie electrică datorită generatorului unități de control, GCUs, simultan a intra în modul de siguranță eșuează. E un fel de a pierde mine. Dar, memo a declarat, OK, acum am înțeles, conditie a fost cauzată de un software contracara internă controlul generatorului unități care vor fi inundate după 248 de zile de curent continuu. Publicam aceste observați pentru a preveni pierderea tuturor AC electrice putere, ceea ce ar putea avea ca rezultat în pierderea controlului asupra avionului. 

Așa că, literalmente, există unele număr întreg, sau un anumit tip de date echivalente, fiind utilizate în software într-un avion real că, dacă vă păstrați avionul pe suficient de mult timp, care aparent poate fi cazul dacă sunteți doar rulează le deconectezi în mod constant și niciodată avionul, se pare, sau lăsând bateriile să moară, va conta în cele din urmă în sus și în sus, și în sus, și în sus, și în sus și în sus. 

Și, prin natura sa, o cantitate finită de memorie se va revărsa, rulare înapoi la zero, sau o anumită valoare negativă, un efect secundar al cărui este realitatea reală înfricoșător că avionul ar putea avea nevoie să fie reinițializat, în mod eficient, sau s-ar putea cădea, mai rău, așa cum zboară. Deci, aceste tipuri de probleme sunt încă cu noi, even-- aceasta a fost un articol în 2015, tot mai înfricoșător atunci când nu neapărat să înțeleagă, aprecia, sau anticipa aceste tipuri de erori. 

Deci, se pare că există un alt lucru rău despre reprezentarea datelor. Se pare că, chiar și flotoare sunt un fel de defecte, pentru că plutește, de asemenea, Am propus sunt 32 de biți, sau poate, 64 dacă utilizați un dublu. Dar asta e încă finit. 

Și captura este că, dacă poți a pus un număr infinit de numere după punctul zecimal, nu există nici o cale de poate reprezenta tot posibilul Numerele pe care am fost învățați în clasa școală poate exista în lume. Un computer, în esență, trebuie să pentru a alege un subset al acestor numere pentru a reprezenta cu exactitate. 

Acum, computerul poate a rundă poate un pic, și vă puteți permite aproximativ magazin orice număr pe care s-ar putea dori, eventual. Dar, pur și simplu intuitiv, dacă tu au un număr finit de biți, puteți să le permuta numai în atât de multe feluri finite. Deci, tu nu poți, eventual, utilizați un număr finit de permutare de biți, modele de zero-uri și altele, pentru a reprezenta un infinit numărul de numere, ceea ce sugerează că computerele ar putea foarte bine să ne mint uneori. 

De fapt, hai să facem acest lucru. Lasă-mă să mă întorc în IDE CS50. Lasă-mă să merg mai departe și a crea un mic program numita Imprecizia, pentru a arăta că calculatoarele sunt, într-adevăr, imprecis. 

Și lasă-mă să merg mai departe și să înceapă cu o parte din acest cod de mai înainte, iar acum face doar următoarele. Lasă-mă să merg mai departe și fac printf, procente f, backslash n, 1 împărțit la 10. Cu alte cuvinte, să se scufunde mai adanc la 1/10, cum ar fi 1 și împărțit la 10. Cu siguranță, un calculator poate reprezenta 1/10. 

Așa că hai să mergem mai departe și să facă imprecizie. Sa vedem. Formatul specifică de tip dublu. Dar argumentul are tip int. Ce se întâmplă? 

Oh, interesant, așa că este o Lecții învățate din mai înainte. Spun că, hei, spectacol de calculator mi un flotor cu procente f. Dar eu voi da-l 2 Ints. Deci, se pare, eu pot repara acest lucru în câteva moduri. 

Aș putea transforma doar unul în 1.0 și 10 în 10,0, ceea ce ar fi, într-adevăr, au ca efect transformarea le în floats-- încă sperăm același număr. Sau se pare că e ceva vom vedea din nou înainte de mult timp. Ai putea arunca numerele. 

, Aveți posibilitatea să utilizați acest parentetic expresie, se poate spune, hei, calculator, să ia acest lucru 10, pe care știu că este un int. Dar, trata, te rog, ca și cum este un plutitor. Dar acest lucru se simte inutil de complex. 

Pentru scopurile noastre de astăzi, hai doar literalmente Fă-i plutitoare valori punctuale cu un punct zecimal, cum ar fi acest lucru. Lasă-mă să merg mai departe și să rulați din nou, face imprecizie, bun, slash dot imprecizie, introduceți. OK, ne arata bine. 

1 împărțit la 10, potrivit mea Mac aici, este, într-adevăr, 0.100000. Acum, am fost învățat în școală clasa acolo ar trebui să fie un număr infinit de 0 lui. Așa că hai să încercăm cel puțin pentru a vedea unele dintre acestea. Se pare că printf este un pic încă mai arătoasă decât ne-am folosit. Se pare ca nu trebuie să specificați doar la suta f, sau pur și simplu la sută i. Puteți specifica, de fapt, unele opțiuni de control aici. 

Mai exact, voi să spun, hei, printf, de fapt, arată-mi 10 puncte zecimale. Deci, se pare un pic ciudat. Dar tu spui la sută, dot, cât de multe numere doriți să vedeți după ce punctul zecimal, și apoi f pentru plat, doar pentru că asta e ceea ce spune documentația. Lasă-mă să merg mai departe și de a salva asta. 

Și observați prea, eu sunt obtinerea obosit de lucruri le rescrie. Deci, eu sunt doar setarea sus și săgeată în jos pe cheile mele aici. Și, dacă mă lovesc mereu în sus, tu pot vedea toate comenzile că am făcut, sau a făcut în mod incorect. 

Si voi merge mai departe acum și nu folosesc de fapt că, aparent. Asigurați-imprecizie, punct slash imprecision-- asa ceea ce am fost învățat în școală clasa verifică. Chiar dacă am imprima până la 10 zecimale plasează, într-adevăr, este 0.10000. Dar știi ce? 

Hai să luăm un pic lacom. Hai să zicem, cum ar fi, arată-mi 55 puncte după zecimal. Hai să luăm într-adevăr acest lucru programeze o tură. Lasă-mă să-l remake-ul cu marca imprecizie, slash punct, imprecizie. 

Si aici vom merge. copilăria ta a fost o minciună. Aparent, 1 împărțit la 10 este într-adevăr, 0.100000000000000005551115123-- 

Ce se întâmplă? Ei bine, se pare că, în cazul în care un fel de uite destul de departe în activul suport Reprezentarea acestei număr, de fapt, nu este exact 1/10, sau 0,1 și un număr infinit de zerouri. Acum, de ce e asta? 

Ei bine, chiar dacă acest lucru este un simplu număr pentru noi, oamenii, 1 împărțit la 10, este încă una infinit mai multe Numerele pe care ne-am putea gândi în sus. Dar un calculator poate reprezenta numai multe numere, astfel un număr finit. Și astfel, în mod eficient, ceea ce calculator ne arată este cel mai apropiat ei aproximație la numărul vrem să credem este 1/10, sau într-adevăr 0.10000 ad infinitum. 

Mai degrabă, însă, acest lucru este cât mai aproape se poate obține. Și, într-adevăr, dacă te uiți sub capota, așa cum suntem aici prin căutarea 55 cifre după zecimal, vom vedea de fapt, acea realitate. Acum, ca o parte, dacă ai văzut vreodată movie-- cele mai multe dintre voi, probabil, haven't-- dar acum Superman 3 câțiva ani, Richard Pryor efectul de levier, în esență, această realitate în compania sa pentru a fura o mulțime din fracțiuni și fracțiuni de mărunțiș, deoarece company-- după cum îmi amintesc, a fost o while-- a fost în esență a aruncat departe ceva care nu se potrivea în noțiunea de cenți. 

Dar, dacă adăugați toate cuvintele acestea ,, numere mici, mici, mici, din nou, și din nou, și din nou, aveți posibilitatea, ca în cazul său, face o sumă bună de bani. 

Aceeași idee a fost furat de o mai recent, dar încă acum mai în vârstă film, numit Office Space, în cazul în care cei din acel film, a făcut același lucru, înșurubată-l complet, sa încheiat cu prea mult bani în contul lor bancar. A fost foarte suspicios. Dar, la sfârșitul zilei, imprecizie este tot în jurul nostru. 

Și asta, de asemenea, poate fi frighteningly cazul. Se pare că, Superman 3 și Office Space deoparte, acolo pot fi unele foarte reale ramificații mondiale a realităților imprecise Reprezentarea datelor că, chiar și noi, oamenii, la această zi, nu neapărat să înțeleagă la fel de bine cum ar trebui, sau amintiți-vă la fel de des cum ar trebui. Și, într-adevăr, următorul clip este dintr-o privire la o lume foarte reală ramificații de ceea ce se întâmplă dacă nu apreciază că imprecizia se poate întâmpla în reprezentarea numerelor. 

[REDARE VIDEO] 

-Computers, Toți am ajuns să accepte problemele de multe ori frustrant du-te cu them-- bug-uri, viruși, și defectele software, pentru prețuri mici la plata cheltuielilor pentru comoditatea. Dar, în high tech și de mare viteză aplicatii de program spațial militar și, cea mai mică problemă poate să fie mărite în caz de dezastre. 

În data de 4 iunie 1996, oamenii de știință pregătite pentru a lansa un fără pilot Ariane 5 rachete. Acesta a fost realizarea științifică sateliți concepute pentru a stabili precis modul în care interacționează câmpul magnetic al Pământului cu vânturi solare. Racheta a fost construit pentru Agenția Spațială Europeană, și a ridicat off de la facilitatea de pe coasta Guyanei Franceze. 

-la Aproximativ 37 de secunde de la zborul, ei mai întâi ceva ce a observat a fost merge bine. Duzele au fost pivotarea în un mod în care într-adevăr nu ar trebui. În jur de 40 de secunde în zbor, în mod clar, vehiculul era în pericol. 

Și atunci au făcut o decizie să-l distrugă. Agentul de siguranță gama, cu curaj extraordinar, apăsat butonul, a explodat racheta, înainte de a putea deveni un pericol pentru siguranța publică. 

-acest A fost de fată călătorie a Ariane 5. Și distrugerea ei a luat loc din cauza unui defect încorporate în software-ul rachetei. -ORAȘUL Problema pe Ariane a fost că a existat un număr care necesară 64 de biți pentru a exprima. Și au vrut să convertească l la un număr de 16 biți. Ei au presupus că Numărul nu a fost niciodată de gând să fie foarte mare, că majoritatea celor cifre într-un număr de 64 de biți au fost zerouri. S-au înșelat. 

-ORAȘUL Incapacitatea unuia program software pentru a accepta tipul de număr generat de altul a fost la originea eșecului. Dezvoltarea de software a devenit un o parte foarte costisitoare de noi tehnologii. Racheta Ariane au fost foarte de succes, atât de mult a software-ului creat pentru ea a fost, de asemenea, utilizat în Ariane 5. 

-ORAȘUL Problemă de bază a fost că Ariane 5 a fost mai rapid, accelerat mai repede. Și software-ul nu a avut a reprezentat pentru asta. 

-ORAȘUL Distrugerea rachetei a fost un dezastru financiar imens, toate din cauza unei erori de software minut. Dar acest lucru nu a fost primul timp probleme de conversie a datelor a afectat tehnologia modernă de rachete. 

-În 1991, odată cu începutul din primul război din Golf, Patriot Missile experimentat un fel asemănător de problema numărul de conversie. Și, ca urmare, 28 de persoane, 28 de soldați americani, au fost uciși, și despre altele 100 răniți, când Patriot, care trebuia pentru a proteja împotriva scuds de intrare, nu a reușit să foc o rachetă. 

-Când Irakul a invadat Kuweitul, și America a lansat Desert Storm, la începutul anului 1991, Baterii Patriot pentru rachete au fost dislocate pentru a proteja Arabia Saudită și Israel de la atacurile irakiene cu rachete Scud. Patriot este un mediu-range din SUA suprafața de sistem de aer, fabricat de către compania Raytheon. 

-ORAȘUL Dimensiunea separatorului Patriot în sine este de aproximativ 20 de picioare lungi de aproximativ. Si cantareste aproximativ 2.000 de lire sterline. Si transporta un focos de aproximativ, Cred că e cam 150 de lire. Iar focosul în sine este un exploziv de mare, care are fragmente în jurul ei. Carcasa este focosul proiectat să acționeze ca alice mari. 

-ORAȘUL Rachete sunt transportate patru per container, și sunt transportate printr-o semi-remorcă. 

-Sistemul Patriot anti-rachetă merge înapoi cel puțin 20 de ani. Acesta a fost proiectat inițial ca o rachetă de apărare aeriană pentru a trage în jos avioane inamice. În primul război din Golf, când acel război a venit de-a lungul, Armata a vrut să-l folosească pentru a trage în jos scuds, nu avioane. 

Irakian Air Force a fost nu atât de mult de o problemă. Dar armata era îngrijorat cu privire la scuds. Așa că au încercat să upgrade-Patriot. 

-Intercepting Un inamic rachetă călătoresc la Mach 5 a fost de gând să fie suficient de provocatoare. Dar când Patriot a fost grăbit în serviciu, Armata nu a fost conștient de modificarea irakiene care a făcut scuds lor aproape imposibil de a lovi. 

-Ce Sa întâmplat este că scuds au venit au fost instabile. Ei au fost clatina. Motivul pentru aceasta a fost irakieni, în ordine pentru a obține 600 de kilometri dintr-un kilometru 300 gama de rachete, a luat în greutate din focosul din față. Ei au făcut focos brichetă. 

Deci, acum Patriot este încercând să vină la Scud. Și cele mai multe din timp, majoritatea covârșitoare a timpului, ar acoperi doar de către Scud. Odată ce operatorii de sisteme Patriot a realizat Patriot ratat ținta, au detonat focos Patrioților pentru a evita posibilele accidente dacă aceasta s-a lăsat să cadă la pământ. 

Asta a fost ceea ce a văzut cei mai mulți oameni, aceste mingi de foc mari pe cer, și înțeleasă greșit ca interceptări ale focoase Scud. 

-Deși În noapte Cer, Patriots a apărut pentru a fi cu succes distrugerea Scuds, la Dhahran, ar putea exista nici o greșeală despre performanțele sale. Acolo, sistem radar Patrioților pierdut urma unui Scud de intrare, și niciodată nu a lansat din cauza la un defect de software. A fost mai întâi israelienii care au descoperit că mai lung sistemul a fost pornit, cu atât mai mare diferența de timp a devenit, datorită unui ceas încorporat în calculatorul sistemului. 

-aproximativ Cu două săptămâni înainte de tragedia din Dhahran, israelienii au raportat la Departamentul de Apărare că sistemul a fost pierde timp. După aproximativ opt ore sau de rulare, au observat că sistemul a devenit considerabil mai puțin precise. Departamentul de Apărare a răspuns prin spune tuturor bateriilor Patriot să nu părăsească sistemele pe o perioadă lungă de timp. Ei nu au spus ce o lungă perioadă de timp asta-- opt ore, 10 ore, 1.000 de ore. Nimeni nu știa. 

-ORAȘUL Acumulator Patriot staționate la cazarmă la Dhahran și interne sale eronate ceas a fost pe mai mult de 100 de ore în noaptea de 25 februarie. 

-se Urmarite timp cu o precizie de aproximativ o zecime de secundă. Acum, o zecime de secundă este un număr interesant, deoarece nu poate fi exprimat în binar exact, care înseamnă că nu poate fi exprimată exact în orice calculator digital modern. E greu de crezut. 

Dar, utilizați acest lucru ca un exemplu. Să luăm treilea numărul unu. O treime nu poate fi exprimată în zecimal exact. O treime este 0.333 se întâmplă pentru infinit. 

Nu există nici o modalitate de a face acest lucru cu precizia absolută în zecimal. Asta e exact genul de problemă care sa întâmplat în Patriot. Cu cât sistemul a fugit, mai rău eroarea de timp a devenit. 

-după 100 de ore de funcționare, eroare în timp a fost doar aproximativ o treime dintr-o secundă. Dar, în ceea ce privește direcționarea în funcție de o rachetă călătoresc la Mach 5, a rezultat într-o urmărire eroare de peste 600 de metri. Ar fi o eroare fatală pentru soldații cu privire la ce sa întâmplat este o lansare a fost Scud detectate de sateliți de avertizare timpurie și ei știau că era Scud venind în direcția lor generală. Ei nu au știut unde vine. 

-A Fost acum la radar componentă a sistemului Patriot apărarea Dhahran pentru a localiza și menține urmări rachete inamice primite. 

-ORAȘUL Radar a fost foarte inteligent. S-ar urmări de fapt poziția Scud, și apoi prezice unde, probabil, ar fi data viitoare când radarul trimis un puls afară. Acest lucru a fost numit o poartă interval. 

-Apoi, O dată pe Patriot decide suficient timp are a trecut pentru a merge înapoi și să verificați următorul locație pentru acest obiect detectat, merge înapoi. Deci, atunci când s-au întors la greșit loc, se vede atunci nici un obiect. Și se decide că nu a existat nici o obiect, a fost o detectare falsă, și picături pista. 

-ORAȘUL De intrare Scud a dispărut de pe ecranul radar. Si secunde mai târziu, ea trântit în barăci. Scud a ucis 28, și a fost ultimul unul a tras în timpul primului război din Golf. 

Tragic, software-ul actualizat a sosit la Dhahran în ziua următoare. Scaparea de software a avut fost fixat, de închidere un capitol în tulbure Istoria rachetelor Patriot. 

[REDARE VIDEO] David J. MALAN: Deci asta este tot la spun că aceste probleme de depășire și imprecizia sunt prea reale. Deci, cum am ajuns aici? Am început cu doar vorbim despre printf. Din nou, această funcție care imprimă ceva pe ecran, și am introdus ulterior alte câteva funcții din așa-numita biblioteca CS50 lui. Și vom continua să a se vedea acestea în timp util. Iar noi, în special, folosit șir get, și de a lua int, iar acum primi, de asemenea, float, și totuși alții încă mai vor vom întâlni și ne folosesc înainte de mult timp. 

Dar, uneori, au am văzut deja o necesitate pentru a stoca ce mână acele funcții înapoi? Ne-au întors un șir de mână, sau un int sau float. Și, uneori, trebuie să punem asta string, sau int sau float, undeva. 

Și pentru a stoca aceste lucruri, amintesc doar cum ar fi în Scratch, avem variabile. Dar, spre deosebire de zero, în C avem tipuri reale de date variables-- tipuri, mai multe generally-- printre ei, un șir de caractere, un int, un float, iar aceste încă altele. 

Așa că atunci când vom declara variabile în C, va trebui să declare tipurile noastre de date. Acest lucru nu este ceva ce vom trebuie să facă mai târziu în semestrul așa cum tranziția spre alte limbi. Dar, pentru moment, avem nevoie pentru a priori în avans, explica la calculator ce tip variable vrem să ne dea. 

Acum, între timp, pentru a imprima aceste tipuri de tipuri de date, trebuie să spunem printf ce să se aștepte. Si am vazut la suta pentru siruri de caractere, și i la sută pentru numere întregi, și alte câteva deja. Iar acestea sunt pur și simplu cerințe pentru prezentarea vizuală din aceste informații. 

Și fiecare dintre acestea pot fi de fapt parametrizat sau optimizat într-un fel, dacă doriți să continue controlul tipul de ieșire pe care le obține. Și, de fapt, se pare că nu numai este acolo backslash n pentru o nouă linie. Mai e ceva numit backslash r pentru un retur de car, care este mai asemănător cu un mașină de scris școală veche, și, de asemenea, pentru Windows utilizate de mai mulți ani. 

Nu e t backslash pentru file. Se pare că, că, dacă doriți să dublu citat în interiorul unui șir de caractere, amintesc că am utilizat dublu citat dublu citat din stânga și din dreapta capetele corzilor noastre până acum. Asta ar părea să confunde lucrurile. 

În cazul în care doriți să puneți un citat dublu mijlocul unui string-- și, într-adevăr, este confuz pentru a vedea. Și așa va trebui să scape, astfel încât să vorbesc, un citat dublu cu ceva cum ar fi, literalmente, backslash-ul dublu citat. Și, există alte câteva încă. Si vom vedea mai multe dintre în utilizarea reală înainte de mult timp. 

Așa că hai acum tranziția de la date, și reprezentare, și operatori matematici, toate din care ne-a dat niște clădiri blocuri cu care să se joace. Dar acum, hai de fapt, da ne restul vocabularului că am avut deja săptămâna trecută cu Scratch de a lua o privire la alte constructe în C-- nu toate dintre ele. Dar ideile pe care le suntem pe cale de a se vedea într-adevăr doar pentru a sublinia traducerea din o singură limbă, Scratch, la alta, C. 

Și-a lungul timpului, vom ridica mai multe instrumente pentru ajutorul setului de instrumente, ca să spunem așa, sintactic. Și într-adevăr, veți vedea că ideile sunt acum destul de familiare de săptămâna trecută. Așa că hai să facem acest lucru. 

Hai să mergem mai departe și biciul un program de care folosește de fapt, unele expresii, o expresie booleană. Lasă-mă să plec mai departe aici și de a crea un nou fișier. O să sun acest condition.c. 

Lasă-mă să merg mai departe și includ biblioteca CS50. Și lasă-mă să merg mai departe și să includă standardul IO.h pentru funcțiile noastre, și printf, și mai mult, respectiv. Permiteți-mi să mă dai de boilerplate void main int, a cărui explicație ne vom vin înapoi în viitor. 

Acum, lasă-mă să merg mai departe și eu un int prin int get. Atunci lasă-mă să merg mai departe și fac acest lucru. Vreau să spun că dacă i este less-- să distincția între pozitiv, negativ, sau valori zero. 

Așa că, dacă i este mai mică decât zero, permiteți-mi au doar acest program spune pur și simplu, negativ, backslash n, altfel în cazul în care i este mai mare decât zero. Acum eu sunt, desigur, va spune printf pozitiv, backslash n. Și apoi altceva if-- am putut face acest lucru. 

Aș putea face dacă i este egal cu 0. Dar mi-ar fi a face la cel puțin o greșeală deja. Să ne amintim că semnul egal este nu este egal, așa cum noi oamenii știu. 

Dar este operatorul de atribuire. Si noi nu vrem să ia 0 de pe dreapta și pune-l în i pe partea stângă. Deci, pentru a evita această confuzie, sau probabil, utilizarea abuzivă a semnului egal, oamenii au decis în urmă cu câțiva ani că, în multe limbaje de programare atunci când doriți să verificați pentru egalitate între stânga și dreapta, tu de fapt, utilizați este egal la egal la egal. Deci ai lovit semnul egal de două ori. Atunci când doriți să atribuiți din dreapta la stânga, utilizați un singur semn egal. Așa că am putea face astea-- altceva dacă i este egal este egala cu zero. 

atunci am putea merge și Deschide bretele mele buclat, și spune, printf 0, backslash n, făcut. Dar, amintiți-vă cum acestea furci în drum pot lucra. Și, într-adevăr, trebuie doar să se gândească la logica. i este un număr. Este un număr întreg, în mod specific. Și asta înseamnă că va fi mai puțin decât 0 sau mai mare decât 0, sau 0. Deci, există un fel de acest lucru caz implicit implicite. 

Și așa am putea, la fel ca Zgârietură, dispensa cu else if, și doar spun altceva. În mod logic, dacă vă programator știu că există doar trei găleți în care scenariu poate fall-- primul, al doilea sau al treilea în acest case-- nu deranja adăugarea suplimentară de precizie și logica suplimentară acolo. Doar du-te mai departe cu caz implicit aici de altceva. 

Acum, să mergem mai departe după salvarea acestei, face Condiții dot slash conditions-- nu o interfață de utilizator mare, pentru că nu sunt fapt care a determinat utilizator, așa cum am menționat mai devreme. Dar asta e bine. O să-l păstrați simplu. Să încercăm numărul 42. Și asta e pozitiv. Să încercăm numărul negativ 42, negativ. 

Să încercăm valoarea 0. Și, într-adevăr, ea funcționează. Acum, veți vedea cu probleme înainte lungi, de testare lucruri de trei ori, probabil, nu este suficient. probabil că doriți să testați unele numere mai mari, unele mai mici numere, unele cazuri de colt, ca vom veni să le descrie. 

Dar pentru moment, aceasta este o Programul destul de simplu. Și eu sunt destul de sigur că, în mod logic, că aceasta se încadrează în trei cazuri. Și, într-adevăr, chiar dacă ne-am axat pe potențialele dezavantaje de imprecizie și de preaplin, în realitate, în cazul în care multe dintre problemele lui CS50, noi nu vom face griji despre, tot timpul, aceste probleme de depășire și imprecizie, pentru că, de fapt, în C, nu e de fapt, tot ceea ce ușor pentru a evita aceste lucruri. Dacă doriți ca să conta în sus mai mare, și mai mare, și mai mare, se pare că există tehnici pe care le se poate utiliza, de multe ori care implică lucruri numite biblioteci, colecții de cod, care alte persoane au scris pe care le puteți utiliza, și alte limbi, cum ar fi Java și altele, de fapt, face mult mai ușor pentru a conta chiar mai mare. Așa că într-adevăr este unele dintre aceste pericole o funcție de limba pe care o utilizați. Și, în săptămânile următoare, ne vom a se vedea cât de periculos C într-adevăr poate fi, dacă nu-l utilizați în mod corespunzător. Dar, de acolo, și cu Python, și JavaScript, va noi strat pe unele protectii suplimentare, și a alerga mai puține din aceste riscuri. 

Așa că hai să facem un pic mai mult logica interesantă în programul nostru. Așa că lasă-mă să merg mai departe și de a crea un program numit logică doar ca sa ma pot juca cu unele logica reală, logical.c. Voi doar să copiați și lipiți unele cod de la asa mai devreme mă întorc la acest frumos punct de plecare. 

Dați-mi voie de data asta fac C. char Sunt O să-i dea un nume de C doar pentru că este convențională, obține un caracter de utilizator. Și să pretinzi Sunt de punere în aplicare parte din acel program Rm Remove Programul înainte de care a determinat utilizatorul pentru a elimina un fișier. Cum am putea face acest lucru? 

Vreau să spun, dacă C este egal cu este egal, citat unquote, y, atunci am de gând să-și asume că utilizatorul a ales da. Mă duc pentru a imprima da. Dacă ar fi scris, de fapt programul de ștergere, am putea elimina fișierul cu mai multe linii de cod. Dar vom păstra simplu. 

Else if c este egal cu egal cu N- iar acum aici, voi spune, utilizatorul trebuie să fi însemnat nr. Și apoi altceva, știi ce? Nu știu ce altceva utilizatorul va introduce. Așa că am de gând doar să spun că că este o eroare, oricare ar fi el sau ea de fapt tastat. 

Deci, ce se întâmplă aici? Există o diferență fundamentală față de ceea ce am făcut în trecut. ghilimele duble, ghilimele duble, dublu citate, și, cu toate acestea, ghilimele simple, ghilimele simple. Se pare ca în C, că, atunci când pe care doriți să scrie un șir de caractere, nu folosiți ghilimele duble, la fel cum ne-am fost folosind tot acest timp cu printf. 

Dar, dacă doriți să se ocupe cu doar un cu un singur caracter, o așa-numită char, atunci va folosi de fapt ghilimele simple. Aceia dintre voi care ați programat înainte de a, nu s-ar putea avea a trebuit să vă faceți griji cu privire la acest lucru distincție în anumite limbi. În C, nu contează. Și așa când am un char si vreau pentru a compara acel char folosind egali este egală cu o anumită literă cum ar fi y sau n, fac eu, într-adevăr, trebuie să aibă ghilimele simple. 

Acum, să mergem mai departe și de a face acest lucru. Hai să mergem mai departe și fac dot logice slash logice. Și acum am fost întrebat în prealabil. Așa că, probabil, o mai bună experiență de utilizare s-ar spune de fapt, mi ce să fac aici. Dar, voi doar orbește spun y pentru da, OK, frumos. 

Hai să-l rulați din nou, n pentru nici, frumos. Să presupunem ca și anumite persoane pe care le cunosc, capace de blocare a cheia este prea des. Așa că am făcut capital de Y, introduceți, eroare. OK, nu e exact ceea ce mă așteptam. Într-adevăr, computerul este de a face literalmente ceea ce Am spus să do-- verifica litere mici y și litere mici n. Acest lucru nu se simte ca bine experiență de utilizator, totuși. Lasă-mă să solicite și să accepte fie minuscule sau majuscule. Deci, se pare, s-ar putea dori să spună ceva de genul în Scratch, cum ar fi literalmente sau C este egal cu este egal cu capitalul unic y citat. Se pare că, C nu are acest cuvânt cheie sau literal. 

Dar are două bare verticale. Trebuie să-țineți apăsată tasta Shift de obicei, dacă utilizați o tastatură din SUA, și a lovit bara verticală Tasta de mai sus cheia de întoarcere. Dar această bară verticală bară verticală înseamnă sau. 

În cazul în care, în schimb, ne-am dorit să spunem și, la fel ca în Scratch, am putea face ampersand ampersand. Nu are nici un sens logic aici, pentru că un om ar putea, eventual, nu au tastat atât y și y litere mici și capitalul Y ca același caracter. Acest lucru sau este ceea ce ne propunem aici. 

Deci, dacă am face acest lucru în ambele locuri, sau c este egal cu capitalul N egalează, acum rulați din nou, face logic, logic rulați din nou. Acum, eu pot tip y. Și eu pot face din nou cu capitalul Y sau N. Capital Și aș putea adăuga în plus combinații încă. 

Deci, aceasta este o logică în măsura în care programul acum Verific în mod logic această valoare sau această valoare. Si eu nu trebuie, în mod necesar, veni cu încă două sau altceva ar fi dacă ar fi dacă. Pot combina de fapt, unele dintre cele mai logica legate împreună în acest fel. Deci, acest lucru ar fi mai bine proiectat decât pur și simplu spunând dacă C este egal cu litere mici y, print da, altfel daca c este egal cu capitalul Y, print da, altceva în cazul în care c este egal cu lower-- cu alte cuvinte, nu trebuie să aibă tot mai multe ramuri. Puteți combina unele dintre echivalentul ramuri în mod logic, ca în acest fel. 

Așa că hai să aruncăm o privire la doar unul ingredient final un construct final că C permite. Iar noi vom veni în în viitor pentru alții încă. Și apoi vom încheia prin căutarea la care nu corectitudinea code-- obtinerea de cod pentru work-- dar design-ul de cod, și planta acele semințe de timpuriu. 

Așa că lasă-mă să merg mai departe și deschide un fișier nou aici. Știi ce? Am de gând să re-pună în aplicare că același program, dar folosind o construcție diferită. 

Așa că lasă-mă repede da eu acces pentru a include CS50.h pentru biblioteca CS50, standardul Io.h pentru printf. Dă-mi void main int. Și apoi aici, să mă să merg mai departe și fac acest lucru. 

Char c devine obține char, la fel ca înainte. Si eu voi folosi un nou construct now-- trece, pe ce personaj? Așa că comutatorul este un fel de Comutarea unei piese de tren. Sau, într-adevăr, este un fel de în cazul în care un altul, dacă altceva în cazul în care, dar scrise oarecum diferit. 

Un comutator arata ca acest lucru. Ai comutator, și apoi ce caracter sau numărul pe care doriți să se uite la, apoi unele acolade ca în Zero, spun doar fac aceste lucruri. Și, atunci aveți diferite cazuri. 

Nu mai folosești dacă și altceva. Utilizați literalmente caz cuvântul. Și v-ar spune ceva de genul asta. 

Deci, în cazul unei litere mici y, sau în cazul unui capital Y, mergeți mai departe și imprima da. Și apoi ieși din comutator. Asta e. Au fost efectuate. 

Dacă este altfel, ca să spunem așa, caz n inferior, sau de capital N, apoi mergeți mai departe și de imprimare afară nu, și apoi se rupe. Else-- și acest tip de este default indeed-- printf error-- și doar pentru o bună măsură, deși în mod logic, această pauză nu este necesară pentru că suntem la sfârșitul anului a comutatorului, oricum, Sunt acum de rupere a comutatorului. Deci, acest lucru pare un pic diferit. 

Dar, în mod logic, este de fapt echivalent. Și de ce ai folosi una peste alta? Uneori, doar o preferință personală, uneori estetica, dacă am arunca o privire la acest Acum, e ceva pentru a spune pentru lizibilitatea acestui cod. Vreau să spun, nu contează faptul că această Codul este nou pentru mulți dintre noi în cameră. 

Dar este doar un fel de e destul. Tu vezi cu litere mici y, capitalul Y, caz n inferior, capitalul N implicit, ea doar un fel de salturi la tine într-un mod că, fără îndoială, poate exemplul anterior cu, și IdS bare verticale, iar IdS altceva, nu s-ar putea avea. Deci, acest lucru este într-adevăr o chestiune de personal alegere, într-adevăr, sau lizibilitatea, din cod. 

Dar, în ceea ce privește funcționalitatea, permiteți-mi mergeți mai departe și să facă un comutator, bară oblică punct comutator, iar acum tastați în y litere mici, de capital Y, litere mici n, capitalul N, David, încercați din nou pentru că asta nu un singur caracter. Hai să facem x, eroare, cum era de așteptat. Și, logically-- și acest lucru este ceva Aș încuraja în general-- chiar deși suntem doar zgârierea Suprafața unora dintre aceste caracteristici. 

Si s-ar putea să nu fie evident atunci când stai jos te la tastatură, Cum funcţionează asta? Ce ar face asta? Lucru frumos despre care au un laptop, sau desktop sau de acces la un calculator cu un compilator, și cu un editor de cod de genul asta, este aproape iti poti răspunde întotdeauna aceste întrebări pentru tine doar incercand. 

De exemplu, în cazul în care retorice întrebare la îndemână au fost, Ce se întâmplă dacă uitați declarațiile dumneavoastră pauză? Ceea ce este de fapt un foarte frecvente lucru de făcut, deoarece nu arata cum ar fi într-adevăr nevoie de ele. Ei nu completează cu adevărat tău crezut ca o paranteza sau ondulat bretele face. Să mergem mai departe și recompilați codul și a vedea. Deci, asigurați-comutator, comutator bară oblică punct. Hai să tastați în litere mici y, caz de sus, Enter. Așa că am tastat y. 

Programul a spus da, nu, eroare, ca și cum a fost schimbarea mintea ei. Dar e cam fost, pentru că ceea ce se întâmplă cu un comutator este primul caz în care potrivire înseamnă că, în esență, hei calculator, executa tot codul de sub el. Și, dacă nu spui pauză, sau nu spun pauză, sau nu spun pauză, calculatorul va sufla prin toate aceste linii și să execute toate acestea, până se ajunge la asta acoladă. Așa că frânele sunt, într-adevăr, este necesar. Dar, o livrata acasa aici este, atunci când în îndoială, încercați ceva. Poate salva codul în primul rând, sau salvați-l într-un fișier suplimentar dacă sunteți într-adevăr îngrijorat încurc și având pentru a recupera munca pe care o știi este de lucru. 

Dar, încercați lucruri. Si nu fie la fel de frică, probabil, a ceea ce s-ar putea face computerul, sau că s-ar putea rupe ceva. Puteți oricând să reveniți înapoi într-o anumită versiune anterioară. 

Așa că hai să închei căutarea la proiectarea codului. Avem această capacitate acum de a scrie condiții, și bucle de scriere, și variabile, și funcțiile de apelare. Așa că, sincer, suntem un fel de la spate unde am fost acum o săptămână cu Scratch, deși cu un text mai puțin convingătoare mediu decât zero permite acest lucru. 

Dar, observați cât de repede ne-am dobândit că vocabularul, chiar dacă este O să ia ceva timp să se scufunde în, astfel încât să putem folosi acum acest vocabular pentru a scrie mai multe programe interesante. Și să facem un pas copil față de faptul că, după cum urmează. Lasă-mă să merg mai departe și a crea un fișier nou aici. 

Mă duc să sun acest prototype.c, și să introducă pentru prima dată, capacitatea pentru a face propriile funcții. Unii dintre voi s-ar putea avea făcut acest lucru cu zgârieturi, prin care vă puteți crea blocuri personalizate proprii în Scratch, și apoi glisați-le în loc ori de câte ori doriți în C. Și, în cele mai multe de programare limbi, puteți face exact that-- face propriile funcții, în cazul în care acestea nu există deja. 

Astfel, de exemplu, lasă-mă să merg mai departe și includ CS50.h, și includ standard de IO.h, void main int. Și acum avem un placeholder gata de plecare. Am păstra de imprimare lucrurile cum ar fi numele oamenilor de azi. Si asta se simte like-- nu ar fi frumos dacă există au fost o funcție numită nume de imprimare? Nu trebuie să utilizați printf. Nu trebuie să-și amintească toate codurile de format. De ce nu, sau de ce nu a făcut cineva înaintea mea, a crea o funcție numită de imprimare nume, că dat un nume, pur și simplu se imprimă afară? 

Cu alte cuvinte, dacă eu spun, hei, calculator, da-mi un șir de caractere prin solicitarea utilizatorului pentru o astfel, prin intermediul funcției șir get CS50 lui. Hei, computer, a pus acel șir în variabila in partea stanga, si suna-l e. Și apoi, hei calculator, mergeți mai departe și imprima numele persoanei, făcut. 

Acum, ar fi frumos, pentru că acest program, numit pe bună dreptate, îmi spune ce ar trebui sa faca prin intermediul numelor celor ale funcției lui. Lasă-mă să merg și să facă prototip, Enter. Și, din păcate, acest lucru nu se întâmplă să zboare. 

Prototype.c, linia 7, caracter 5, eroare, declarația implicită a funcției nume de imprimare este nevalid în C99, C99 ceea ce înseamnă o versiune de C care a ieșit în 1999. Asta e tot. 

Deci, eu nu știu ce toate acestea înseamnă încă. Dar eu recunosc eroare în roșu. Asta e destul de evident. 

Și se pare că, cu caracterul verde aici, problema este cu numele de imprimare, deschis Paranteză s, Paranteză aproape, semi-colon. Dar, declarația implicită a Funcția le-am văzut pe scurt mai devreme. Acest lucru înseamnă, pur și simplu, că zăngănit nu știe ce vreau să spun. 

Am folosit un cuvânt de vocabular că este nu a văzut sau a fost predat inainte. Așa că am nevoie să-l învețe ceea ce înseamnă această funcție. Așa că am de gând să merg mai departe și de a face asta. 

Mă duc să merg mai departe și să pună în aplicare mea funcție proprie numită Print Name. Si eu voi spune, după cum urmează, că face acest lucru, printf, salut, la sută s, backslash n, numele, semi-colon. Deci ce am făcut? 

Deci, se pare, la pune în aplicare propria funcție, am un fel de a împrumuta unele dintre aceeași structură ca principală că am fost doar de la sine, și eu știu doar să copiați și să lipirea destul de mult ceea ce Am scris în trecut. Dar observați modelul aici. Int, principal, nu apare, vom tachineze în afară înainte de mult timp ce asta înseamnă, de fapt. 

Dar pentru ziua de azi, doar observă paralelismul. , Numele de imprimare nu apare, string name, deci nu există un cuvânt cheie violet, care vom incepe apelarea unui tip de întoarcere, numele funcția, și apoi de intrare. Așa că, de fapt, putem distila acest fel de săptămâna trecută ca, acesta este numele sau Algoritmul de cod suntem merge la write-- algoritmul care stau la baza codul pe care îl vom scrie. 

Aceasta este intrarea sa. Aceasta este producția sa. Această funcție, numele de imprimare, este proiectat pentru a lua un șir de caractere numit nume, sau orice altceva, ca intrare, și apoi anulate. Ea nu se întoarce nimic, cum ar obține șir sau pentru a obține o face int. Așa că o să-mi dai ceva înapoi. Doar că va avea un efect secundar, ca să spunem așa, de a imprima numele unei persoane. Așa că observați, linia 7, I poate apela numele de imprimare. Linia 10, eu pot defini sau să pună în aplicare numele de imprimare. Dar, din păcate, asta nu e suficient. 

Lasă-mă să merg mai departe și recompilați acest lucru după salvare. Hei, acum, l-am făcut mai rău, s-ar părea. asemenea declarație implicită Numele funcției de imprimare este nevalid. Și, din nou, există mai multe erori. Dar, așa cum am avertizat mai devreme, chiar dacă te copleșit, sau un pic trist pentru a vedea atât de mulți erori, se concentreze doar pe primul inițial, pentru că s-ar putea pur și simplu au avut un efect în cascadă. Deci C, sau zăngănit mai precis, încă nu recunoaște numele de imprimare. 

Si asta pentru ca zăngănit, prin design, este un fel de prost. Face doar ceea ce le spune să facă. Și face acest lucru doar în ordinea în care îi spun să facă. 

Așa că am definit în principal pe linia patru, așa cum ne-am făcut destul de des. Am definit numele de imprimare pe linia 10. Dar eu încerc să folosesc numele de imprimare pe linia șapte. 

E prea devreme, nu există încă. Așa că am putea fi inteligent, și să fie ca, OK, așa că hai să se joace de-a lungul, și pentru a muta numele de imprimare în sus aici, și re-compila. O Doamne. A mers. Era la fel de simplu ca asta. 

Dar logica este exact asta. Trebuie să-i învețe zăngănit ce este prin definirea funcției mai întâi. Apoi îl puteți folosi. Dar, sincer, acest lucru se simte ca o pantă alunecoasă. 

Așa că de fiecare dată când am alerga într-o problemă, eu sunt doar va evidenția și copiați codul Am scris, taie-l și lipiți-l aici. Și, în mod sigur, am putea născoci unele scenarii în cazul în care o funcție s-ar putea nevoie pentru a apela un alt. Si pur si simplu nu se poate pune în fiecare Funcția mai presus de orice. 

Deci, se pare că nu există o soluție mai bună. Noi putem lăsa acest lucru să fie. Si, sincer, este în general frumos, și convenabil, și design bun pentru a pune principală întâi, pentru că, din nou, principal la fel ca atunci când steagul verde a făcut clic, adică funcția pe care este executat în mod implicit. Așa că s-ar putea la fel de bine pus l în partea de sus a fișierului astfel încât, atunci când sau orice alt om se uită la fișierul Știi ce se întâmplă doar prin citirea principală întâi. Deci, se pare, putem spune zăngănit în mod proactiv, hei, zăngănit, pe linia de patru, Eu promit să pună în aplicare o funcție numită de imprimare Numele care ia un nume de coarde numit ca intrare, și se întoarce nimic, nule. Și eu voi ajunge în jurul valorii de la de punere în aplicare mai târziu. 

Aici vine Main. Principala acum pe linia 9 poate utiliza Imprimare Nume deoarece zăngănit este încrederea că, în cele din urmă, se va întâlni definiția a punerii în aplicare a Print Name. Deci, după ce salvați fișierul meu, să mă să merg mai departe și să facă prototip, arată bine de data asta. Dot slash, prototip, lasă-mă mergeți mai departe și tastați un nume. David, salut David, Zamila, salut Zamila, și, într-adevăr, acum funcționează. 

Așa că ingredientul de aici este că ne-am a făcut o funcție de comandă, cum ar fi un obicei Bloc zgârietură noi o chemare. Dar, spre deosebire de zero în cazul în care puteți doar crea și începe să-l utilizați, acum trebuie să fim un puțin mai pedant, și de fapt, tren zăngănit să folosească, sau să-l aștepte. Acum, ca o parte, de ce tot acest timp au am fost pur și simplu orbește pe credință, inclusiv CS50.h, inclusiv standardul IO.h? 

Ei bine, se pare, printre alte câteva lucruri, tot ceea ce este în acele dot h fișiere, care se întâmplă să fie fișiere. Sunt antet fișiere, ca să spunem așa. Sunt încă scrise în C. Dar acestea sunt un alt tip de fișier. 

Pentru moment, se poate presupune destul de mult că tot ceea ce este în interiorul CS50.h este unele-garnituri, cum ar fi acest lucru, nu pentru funcțiile numite Print Nume, dar pentru Get String, Get Float, și alte câteva. Și acolo sunt prototipuri similare, una garnituri, în interiorul IO.h standardului pentru printf, care este acum în propria mea funcție de imprimare Nume. Deci, cu alte cuvinte, în tot acest timp ne-am tocmai a fost orbește copierea și lipirea includ acest lucru, includ că, ce se întâmplă? Acestea sunt doar un fel de indicii la zăngăni cu privire la ce funcții sunt, într-adevăr, puse în aplicare, doar în altă parte, în diferite fișiere în altă parte asupra sistemului. 

Prin urmare, am implementat numele de imprimare. Ea are acest efect secundar al imprimarea ceva pe ecran. Dar nu face de fapt Dă-mi ceva înapoi. Cum vom merge despre punerea în aplicare a unui program care nu dă-mi ceva înapoi? 

Ei bine, să încercăm. Lasă-mă să merg mai departe și să pună în aplicare un fișier numit return.c astfel încât să putem demonstra cum ceva cum ar fi Get String, sau Get Int, este de fapt revenirea ceva înapoi la utilizator. Să mergem mai departe și să definească void main int. 

Și, din nou, în viitor, vom explica ce acel int și acel gol este de fapt face. Dar pentru ziua de azi, vom ia-o serios. Mă duc să merg mai departe și printf, pentru o bună experiență de utilizator, x este. Și apoi am de gând să aștepte pentru utilizator pentru a-mi da x cu int get. 

Și apoi am de gând să merg mai departe și imprima x la pătrat. Așa că, atunci când ai doar un tastatură, oameni frecvent utilizați morcov mic Simbolul de pe tastatură să reprezinte la puterea a, sau exponent al. Deci x la patrat este prezent eu. 

Și acum voi face asta. Aș putea doar do-- ce e x la pătrat? x pătrat este x ori x. 

Si am facut asta unii timp în urmă deja astăzi. Acest lucru nu se simte ca tot atât de mult progres. Știi ce? Hai să impulsioneze o parte din această idee din ultima dată de abstracție. 

Nu s-ar fi frumos dacă există o funcție numită pătrat care face exact asta? Încă, la sfârșitul fișierului zi, face acelasi matematica. Dar, hai abstract departe ideea de a lua un singur număr înmulțit cu o alta, si doar da un nume, cum ar fi pătrat această valoare. 

Și, cu alte cuvinte, în C, să creeze o funcție numita pătrat care face exact asta. Va fi numit pătrat. Se va lua un int. Și vom doar va suna-l n, în mod implicit. 

Dar am putea numi orice vrem. Și, tot ceea ce va face, literalmente, este întoarcere rezultatul de n ori n. Dar, pentru că este întoarcere ceva, care este cuvântul cheie în purpuriu ne-am niciodată văzut înainte, eu, pe linia 11, nu se poate spune pur și simplu anulate de data asta. 

Nule, în exemplul tocmai am văzut mai degrabă numele de imprimare, pur și simplu înseamnă, Fă ceva. Dar, nu-mi dai ceva înapoi. În acest caz, eu vreau pentru a reveni n n ori, sau orice altceva care este, acel număr. 

Deci, eu nu pot spune, hei, calculator, Mă întorc nimic, nul. O să se întoarcă, prin natura sa, un int. Și astfel, asta e tot ce se întâmplă aici. 

Intrare la pătrat va fi un int. Și, astfel încât să putem folosi, trebuie să au un nume, N. Se va ieșire un int care nu are nevoie de un nume. O putem lăsa principal, sau cine este folosind-mi amintesc această valoare, dacă doresc cu propria variabilă. 

Și, din nou, singurul nou cuvinte cheie aici este de retur. Si eu fac doar niște matematică. Dacă aș fi dorit cu adevărat să fie inutilă, Aș putea spune produsul int devine de n ori n. 

Și apoi am putea spune, returna produsul. Dar, din nou, la punctul meu mai devreme de acest lucru pur și simplu nu este design-- bun cum ar fi, de ce introduce un nume, un simbol, cum ar fi produs, pur și simplu să-l returneze imediat? Este un pic mai curat, un pic mai strâns, așa să vorbească, doar pentru a spune întoarcerea de n ori n, a scăpa de această linie cu totul. 

Și este doar mai puțin de cod pentru a citi, mai puține șanse de greșeli. Și să vedem dacă acest lucru de fapt, funcționează acum. Acum, am de gând să merg înainte și să facă retur. 

Uh-oh, declarația implicită a funcției. Am făcut această greșeală înainte de a, nu e mare. Lasă-mă să tastați, sau evidențiați și copia, exact aceeasi functie prototip, sau semnătura, a funcției de aici. Sau aș putea mișca întreaga funcție. 

Dar asta e un pic leneș. Așa că nu vom face asta. Acum, lasă-mă să fac întoarcere din nou, punct de întoarcere bară oblică. 

x este 2. x la patrat este 4. x este 3 x patrat este de 9. Iar funcția pare acum să fie de lucru. Deci, ce este diferența aici? Am o funcție care se numește pătrat, în acest caz, pe care am pus într-o intrare. Iar eu mă întorc o ieșire. Și totuși, mai înainte, în cazul în care Am deschis celălalt exemplu din anterioare, care a fost numit prototype.c, Am avut numele de imprimare, care a revenit nule, ca să spunem așa, Sau returnat nimic, și pur și simplu a avut un efect secundar. 

Deci, ce se întâmplă aici? Ei bine, ia în considerare funcția obține șir doar pentru un moment. Am fost folosind funcția obține șir în felul următor. 

Am avut o funcție de a obține șir de caractere, cum ar fi includ CS50.h, includ standardul IO.h, int principal, void. Și apoi de fiecare dată când am numit string get pana acum, Am spus ceva de genul, șir de caractere s devine obține șir, pentru că get string-- Să numim acest șir get get.c-- se returnează un șir de caractere pe care le pot apoi utilizați, și spune, salut, virgulă, procente s, backslash n, s. 

Deci, acesta este același exemplu, într-adevăr, că am avut mai devreme. Așa că obține șir returnează o valoare. Dar un moment în urmă, șir de imprimare nu returnează o valoare. Ea pur și simplu are un efect secundar. Deci, aceasta este o diferență fundamentală. Ne-am văzut diferit tipuri de funcții acum, unii dintre care s-au întors valori, dintre care unele nu. Deci, poate că e șir de caractere, sau int sau float. Sau poate e doar nule. 

Iar diferența este că aceste funcții care obține date și să returneze o valoare sunt de fapt aducând ceva înapoi la masă, ca sa zicem asa. Așa că hai să mergem mai departe și uita-te la un set final de exemple care dă un sens, acum, de cum am putea, într-adevăr, mai bine abstract, și mai bine, și mai bine, sau mai mult, și mai mult, și mai mult, în ordine pentru a scrie, în cele din urmă, codul de mai bine. Hai să mergem mai departe, și în spiritul Scratch, procedați în felul următor. 

Lasă-mă să merg mai departe și să includă CS50.h și standardul IO.h. Lasă-mă să merg mai departe și eu un int, principal, nule. Și lasă-mă să merg mai departe, numesc acest cough.c. 

Și lasă-mă să merg mai departe și doar cum ar fi zero, imprima tuse / n. Și vreau să fac acest lucru de trei ori. Deci, eu sunt, desigur, doar merge pentru a copia și lipi de trei ori. Sunt acum de gând să facă tuse tuse slash dot. Hai să mă dau mai mult spațiu aici, Enter, tuse, tuse, tuse. 

Nu există, în mod evident, deja oportunitate de îmbunătățire. Am copiat și inserat de câteva ori astăzi. Dar asta a fost doar așa că nu am trebuie să tastați cât mai multe caractere. Tot ceea ce a schimbat aceste linii de cod sunt. 

Aceste trei linii sunt identice, care se simte leneș și într-adevăr este, și nu este, probabil, abordarea corectă. Deci, cu ce ingredient am putea îmbunătăți acest cod? Noi nu trebuie să copiați și inserați codul. 

Si, intr-adevar, orice moment în care simți te copierea și lipirea, și nici măcar schimbarea codului, cotele sunt că există o cale mai bună. Și, într-adevăr, există. Lasă-mă să merg mai departe și de a face o buclă, chiar dacă sintaxa nu s-ar putea vin natural încă. 

Fa acest lucru de trei ori, pur și simplu prin a face following-- și se întâmplă să știu acest lucru din practică. Dar avem un număr de exemple acum. Și veți vedea on-line mai multe referințe încă. 

Aceasta este sintaxa pe linia 6, că la fel ca Scratch care se repetă bloc, se repetă următoarele trei ori. Este un pic magic acum. Dar acest lucru va primi mai mult, și mai familiare. 

Și se va repeta linia opt de trei ori, astfel că, dacă am re-compila make-tuse, dot slash tuse, tuse, tuse, tuse. Acesta funcționează în continuare în același mod. Deci asta e tot fin și bun. Dar asta nu e foarte captată. 

Este perfect corect. Dar se simte ca acolo ar putea fi o oportunitate, ca și în lumea Zero, la fel de pornire pentru a adăuga unele semantica aici, astfel încât Nu am doar o bucla, și o funcție care spune tuse, sau nu tuse. Știi ce? Lasă-mă să încerc să fie putin mai rece decât atât, și de fapt, a scrie o funcție care are unele efecte secundare, o numesc tuse. 

Și este nevoie de nici o intrare, și returnează nici o valoare ca ieșire. Dar știi ce face? Ea face astea-- printf, citat unquote, tuse. 

Și acum aici, mă duc pentru a merge mai departe și pentru int i devine zero i mai mic de 3, i, plus, plus. Am de gând să nu fac printf, care este fără îndoială, un nivel scăzut de implementare detaliu. Nu-mi pasă cum de tuse. Vreau doar să utilizați funcția de tuse. Si eu doar o să sun tuse. 

Acum, observați dihotomia. Atunci când apelați o funcție, dacă nu doresc să-i dea intrările, total bine. Doar face Paranteză deschise, close Paranteză, și ați terminat. 

Atunci când definiți o funcție sau să declare prototipul unei funcții, a dacă știi dinainte că nu e va lua orice argumente, spun nule în acele paranteze acolo. Și asta face sigur că nu va abuza în mod accidental. Lasă-mă să merg mai departe și să facă tuse. Și, desigur, am făcut o greșeală. 

La naiba, e că Declarația implicită. Dar asta e bine. Este un remediu simplu. Am nevoie doar de prototip mai sus în fișierul meu decât eu sunt de fapt, folosind. 

Deci, acum lasă-mă să fac din nou tuse, frumos. Acum, funcționează. Asigurați-tuse, tuse, tuse, tuse. Așa că s-ar putea crede că suntem într-adevăr doar puțin peste inginerie această problemă. Si, intr-adevar, suntem. Acest lucru nu este un bun candidat al unui program in acest moment restructurează, și de a face ceea ce-i numita descompunere ierarhică, în cazul în care vă luați un cod, și apoi vă factor de fel de lucruri, asa ca să-i atribuie mai multe semantica lor, și refolosirea-l în cele din urmă pe termen mai lung. Dar este o piatră de temelie spre programe mai sofisticate că vom începe scris, înainte de mult timp că ne permite să avem vocabularul cu care să scrie cod mai bine. Și, într-adevăr, să vedem dacă ne nu se poate generaliza această continuare. 

Se pare un pic șchiop că eu, principal, Trebuie să vă faceți griji cu privire la acest lucru darn pentru bucla, si de asteptare tuse din nou și din nou. De ce nu pot spune doar tuse, vă rugăm să tuse de trei ori? Cu alte cuvinte, de ce nu pot doar da de intrare pentru tuse și de a face acest lucru? 

De ce nu pot doar să spun, în tuse principală de trei ori. Și acum, acest lucru este un fel de magic. Este foarte iterativ aici. Și este, într-adevăr, un pas copil. 

Dar, pur și simplu abilitatea de a spune pe linia opt, tuse de trei ori, este doar atât de mult mai ușor de citit. Și, în plus, nu trebuie să știu sau de îngrijire cum este pus în aplicare tuse. Și, într-adevăr, mai târziu, în pe termen lung și pentru proiectele finale, dacă ați aborda un proiect cu un coleg sau doi colegi, vei realiza că vei trebuie, sau doriți să, împărțiți munca. 

Si tu vei dori să decidă în avans, care va face ceea ce, și în care piesele? Si n-ar fi frumos în cazul în care, de exemplu, se ocupa de scris principal, făcut. Iar colegul tău de cameră, sau ta partener mai general, are grijă de punere în aplicare a tusei. 

Iar această divizare, acestea pereți de abstracție, sau straturi de abstractizare dacă va, sunt super puternice, deoarece în special pentru a mari, mai multe programe și sisteme complexe, ea permite mai multor persoane să construiască lucruri împreună, și în cele din urmă cusatura munca lor împreună în acest fel. Dar, desigur, noi Trebuie să se stabilească acum tuse. Trebuie să ne spunem tuse că, hei, știi ce? Vei avea nevoie pentru a lua o input-- deci nu nule, dar int si acum. Să mergem mai departe și a pus în tuse int. i devine zero. 

i este mai mic de cât de multe ori. Am spus trei înainte. Dar asta nu e ceea ce vreau. Vreau ca tuse să fie generalizate la sprijini orice număr de iterații. 

Așa că, într-adevăr, este n că vreau, indiferent de utilizator îmi spune. Acum, eu pot merge mai departe și spune tuse de imprimare. Și nu contează ce număr utilizatorul trece în, Voi repeta asta de multe ori. 

Astfel, la sfârșitul zilei, Programul este identic. Dar, observați toate aceste lucruri ar putea fi chiar și într-un alt fișier. Într-adevăr, eu nu știu la cele mai moment, modul în care printf este pus în aplicare. 

Nu știu în acest moment cum obține șir de caractere, sau pentru a obține int sau pentru a obține float sunt puse în aplicare. Si eu nu vreau să a le vedea pe ecran. Așa cum este, eu încep să se concentreze asupra programul meu, nu aceste funcții. 

Și așa, într-adevăr, de îndată ce vă incepe un cod ca acest factoring afară, am putea muta chiar tuse într-un fișier separat? Altcineva ar putea pune în aplicare. Și tu și programul să devină foarte frumos, și foarte ușor de citit, fără îndoială, într-adevăr patru program de linie dreapta si acolo. 

Așa că hai să mergem mai departe acum și să facă o schimbare mai. Observați că prototipul meu trebuie să se schimbe în sus de sus. Deci să-mi repar asa Eu nu primesc tipat la. 

Asigurați-vă tuse, permiteți-mi să executați tuse o dată mai mult, încă mai face același lucru. Dar acum, observați avem un ingredient pentru o versiune finală. Știi ce? Nu vreau să tuse doar, în mod necesar. Vreau să am ceva mai general. Deci, tu ce știi? Vreau să fac acest lucru. Vreau să am, la fel ca zero nu, un bloc să zicem, dar nu doar spune ceva unele de mai multe ori. Vreau să spun un șir de caractere foarte specific. Și, de aceea, eu nu fac doresc să spun doar tuse. Vreau să spun orice șir este trecut în. 

Așa că observați, am generalizat acest lucru, astfel încât acum să zicem se simte ca un nume bun pentru acest lucru, cum ar fi zero, ia două argumente, spre deosebire de zero. Una dintre ele este un șir de caractere. Una dintre ele este un int. 

Și aș putea să le schimba. Am doar un fel de ca ideea de spun șirul întâi, și apoi De câte ori mai târziu. Nule înseamnă încă nu se întoarce nimic. Acestea sunt doar partea vizuala efecte, cum ar fi cu [? Jordan,?] un efect secundar verbal de țipete. Încă mai are ceva de n ori, 0 până la, dar nu este egal cu n. Acest lucru înseamnă că n total de ori. Și apoi imprimați doar afară oricare ar fi acel șir este. Așa că am generalizat într-adevăr această linie de cod. Deci, acum, cum pot pune în aplicare funcția de tuse? 

Pot face nule tuse. Si eu pot lua în continuare în modul în care de multe ori doriți să tuse. Dar știi ce? Pot să punt acum să spun. 

Pot să sun spune împreună cu cuvânt tuse, trecând în n. Și, dacă vreau să pună în aplicare, de asemenea, doar pentru distracție, o funcție de strănut, Pot să strănute unele de mai multe ori. Și eu pot păstra refolosirii n, deoarece observă că, în acest context m sau domeniu de aplicare există numai în această funcție. 

Și n, în acest context, numai există în această funcție aici. Așa că ne vom întoarce la aceste aspecte legate de domeniul de aplicare. Si aici, eu doar o să spun, achoo, și apoi de n ori, semi-colon. 

Și acum, am nevoie doar să împrumute aceste funcții semnături aici. Așa că tusea este corectă. strănut nule este corectă acum. 

Si mai am nevoie doar să spun. Așa că am de gând să spun, să zicem șir de caractere s, int n, semi-colon. Așa că am supra-proiectând heck din acest program. 

Și acest lucru nu înseamnă neapărat acest lucru este ceea ce ar trebui să faci atunci când scrieți chiar și cele mai simple programe. Ia-ceva care este în mod evident într-adevăr simplu, într-adevăr scurt, și re-l pună în aplicare folosind prea mult cod. Dar, veți vedea de fapt, și în timp privi înapoi la aceste exemple, și își dau seama, oh, acestea sunt etapele am luat pentru a generaliza, de fapt, la factorul ceva, până la sfârșitul zilei codul meu este de fapt destul de rezonabil. Pentru că dacă vreau să tuse trei ori, apoi trage pe nas de trei ori, Sunt pur și simplu o să rulați din nou acest lucru, program de a face tuse, și a alerga tuse. Si am trei tușește și trei stranuta. 

Si deci aceasta este o bază paradigmă, dacă va fi, pentru modul în care am putea merge despre punerea în aplicare a unui program de fapt. Dar, hai să vedem acum ce este am făcut tot acest timp, și ce unele dintre piesele finale sunt în spatele acestei comenzi simple. La sfârșitul zilei, ne-am fost folosind zăngănit ca compilator nostru. Ne-am scris sursa cod, aceasta conversie prin zăngănit în cod mașină. 

Și am folosit face doar pentru a facilita intrarile de la tastatura noastre, astfel că noi nu trebuie să ne amintim aceste incantatii de zăngănit în sine. Dar ceea ce este de a face de fapt face? Și, la rândul său, ceea ce este Zăngăni face de fapt? 

Se pare, deși am simplificat discuția de astăzi prin a spune, luați codul sursă, să-l dați ca intrare la un compilator, care vă oferă Producția de mașini cod, se pare că nu există câțiva pași diferite în interiorul acolo. Și compilării se întâmplă să fie umbrela pe termen lung pentru o întreagă grămadă de pași. Dar, hai să șicana asta foarte repede. 

Se pare că ne-am făcut mai multe lucruri de fiecare dată când am rula un program, sau de fiecare dată când am compila un program de astăzi. Deci preprocesare se referă la astea-- ceva într-un program de C, după cum vom vedea din nou și din nou, care începe cu acest simbol hash, sau simbolul hashtag aici, înseamnă este o directivă preprocesor. Asta înseamnă că, în acest caz, hei calculator, face ceva cu acest fișier înainte de a compila de fapt propriul meu cod. 

În acest caz, hash includ este, în esență, modul de a spune lui C, hei calculator, du-te conținutul din CS50.h și lipiți-le aici. Hei calculator, adu conținutul standardului IO.h, ori de câte ori este pe hard disk, lipiți-l aici. Așa că aceste lucruri se întâmplă în primul rând în timpul preprocesare. 

Și zăngănit face toate astea pentru noi. Și se face acest lucru darn rapid, tu nici măcar nu a se vedea patru lucruri distincte se întâmplă. Dar asta e prima astfel de pas. 

Ce se întâmplă de fapt în continuare? Ei bine, următorul oficial pas este compilarea. Și se pare că compilarea unui program de înseamnă punct de vedere tehnic merge de la codul sursă, lucrurile pe care le-am a fost scris astăzi, la ceva numitul cod de asamblare, ceva care arată un pic diferit. 

Și, de fapt, putem vedea acest lucru foarte repede. Lasă-mă să merg de fapt în IDE meu. Lasă-mă să merg mai departe și hello.c deschis, care este primul program, cu care noi a început astăzi. Și lasă-mă să merg mai departe și a alerga un zăngănit putin diferit, zăngănit-s, hello.c, care este, de fapt va da-mi un alt hello.s fișier. 

Și probabil nu vom din nou, a se vedea acest tip de cod. Dacă ați avea un nivel mai scăzut clasa de sisteme cum ar fi CS61, veți vedea mult mai mult de acest tip de cod. Dar acest lucru este limbaj de asamblare. Aceasta este X86 limbaj de asamblare că procesorul care stau la baza CS50 IDE de fapt o înțelege. 

Și criptic așa cum o face uite, este ceva computerul înțelege destul de bine. Sub q, aceasta este o scădere. Nu există mișcări. 

Au sunat de funcții aici, x Oring, o mișcare, un program, o poziție favorabilă, O întoarcere. Așa că există unele foarte instrucțiuni de nivel scăzut că procesoarele să înțeleagă că Am făcut aluzie la mai devreme. Asta este ceea ce Intel Inside. 

Exista modele de zero-uri și cele care harta acestora formulată după arcanely, dar oarecum bine numit, instrucțiuni, ca sa zicem asa. Asta este ceea ce se întâmplă atunci când compilarea codul. Primești asamblare limba din ea, care reprezintă al treilea pas este de a asambla că codul de asamblare în, în cele din urmă, masina de zero-uri code-- și cele, nu, textul pe care tocmai l-am văzut acum un moment. 

Așa că pre-procesare nu găsi că și înlocuiți, și alte câteva lucruri. Compilarea ia sursa ta cod de la C, codul sursă pe care am scris, de asamblare cod care tocmai ne-am aruncat o privire. Asamblare reușește ca asamblarea cod și cele zerouri că procesorul într-adevăr va înțeleagă, la sfârșitul zilei. Și legarea este ultimul pas acest lucru se întâmplă pentru us-- din nou, atât de repede nici măcar nu notice-- care spune, hei calculator, să ia toate zerouri și cele care a rezultat din compilarea codului lui David, și funcția sa principală în acest caz. 

Și hei calculator, du-te toate zero-uri și cele că personalul CS50 a scris în interiorul bibliotecii CS50. Se amestecă cele cu cel al lui David. Și hei calculator, du-te cu toate tipurile de zerouri și cele pe care altcineva a scris ani în urmă pentru printf. Și adăugați cei în Toată chestia asta, așa că ne-am recuperează zerouri și cele mei, zero-uri și cei ai personalului CS50 lui, zerouri printf și cele, și orice altceva pe care îl utilizăm. 

Toti isi vor combinate împreună într-un singur program numit, în acest caz, salut. Așa că de acum înainte, vom face doar utilizați compilarea cuvântul. Și vom lua de la sine înțeles că, atunci când noi spunem, compila programul, aceasta înseamnă, hei face pre-procesare, asamblarea și conectarea. Dar, de fapt, există unele chestii suculente se întâmplă acolo sub capota. Și, mai ales dacă obține curios ceva timp, puteți începe poking în jurul valorii de la acest nivel inferior. Dar, pentru moment, dau seama că printre takeaways pentru ziua de azi sunt destul de simplu începutul unui proces, de a obține confortabil cu ceva ca lumea bună. Intr-adevar, cele mai multe din ceea ce am făcut astăzi cu siguranță nu se va scufunda în super-rapid. Și va dura ceva timp, și unele practici. Și cote sunt, vă va sorta din care doriți să lovească tastatura sau tipa la ecran. Si toate astea e în regulă. Cu toate că, probabil, încearcă să nu fă-o în bibliotecă atât de mult. 

Și, în cele din urmă, veți să fie în măsură, deși, pentru a începe văzând modele, atât în ​​cod bun pe care le-ați scris și în greșeli pe care le-ați făcut. Și, la fel ca procesul de devenind un TF sau o CA este ca, veți începe pentru a obține o mai bună și mai bine la a vedea aceste modele, și doar rezolvarea ta propriile probleme în cele din urmă. Între timp, vor exista o multime dintre noi pentru a împrumuta sprijin, și veți obține prin asta. Și în a scrie-up-uri pentru toate problemele vei fi ghidat prin toate comenzile că știu cu siguranță de la o mulțime de practică până acum, dar ar fi putut să zboare deasupra capului pentru acum. Și asta e total bine. 

Dar, în cele din urmă, vei pentru a începe să vadă modele de emerge. Și odată ce ai trecut cele de mai detalii stupide, cum ar fi paranteze, și acolade și virgulele, și lucrurile, sincer, care nu este deloc intelectual interesant. Și nu este obiectivul luând orice clasă introductivă. Este ideile care vor să conteze. 

Este buclele, și Condițiile și funcțiile, și mai puternic captarea, și factoring de cod, și design bun, și bun stil, și în cele din urmă corectitudinea a codului, care este în cele din urmă va conta cel mai mult. Așa că săptămâna viitoare, vom lua aceste idei pe care le-am văzut pentru prima dată în Scratch și s-au tradus acum C. Și vom începe să introducă prima dintre cele domenii din lumea reala curs lui. 

Ne vom concentra asupra lumii de securitate, și mai precis criptografie, arta de codare a informațiilor. Și printre primii te probleme de tine va ajunge să scrie dincolo juca cu unele din sintaxa și rezolvarea unor logice probleme, în cele din urmă înainte de mult timp, este de fapt pentru a încăierare, sau cripta, și în cele din urmă decripta informații. Si tot ce am făcut astăzi, va destul de scăzută nivel, este pur și simplu va permite ne să ia una, și una, și încă un pas spre mai sus scris încă codul cel mai interesant. 

Cu atât mai mult pe săptămâna viitoare. 

[REDARE VIDEO] 

Ce poți să-mi spui despre ultima dată când l-ai văzut? Ce pot să spun, într-adevăr? Adică, a fost ca oricare alt repetiție pre-producție, cu excepția era ceva, a spus el la sfârșit, care a ramas cu mine. 

-acest A fost CS50. 

Asta e toată lumea tăiat, mare de locuri de muncă la repetiții. 

prânzul -Asta? 

Da, tu și eu pot apuca un sandwich într-un pic. Lasă-mă doar cu interogheze David foarte repede. David? David? 

[END REDARE] 