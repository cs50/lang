[MUZYKA] David J. MALAN: Dobra, to CS50. I jest jeden tydzień. Tak więc przypomnieć, że ostatni raz w tygodniu zerowym, skupiliśmy się na obliczeniowej myślenia. A my przesiedli się od tego, do Scratch, do programowania graficznego język od naszych przyjaciół w MIT Media Lab. 

I z początku, nie badamy pomysły, takie jak funkcje i warunki, i pętle i zmienne, a nawet wydarzenia, nici i inne. A dzisiaj mamy zamiar nadal korzystać z tych pomysłów, i biorąc je za bardzo przyznane, ale je przetłumaczyć na inny język znany jako C. Teraz C jest bardziej tradycyjny język. Jest to niższy poziom języka, jeśli będzie. 

To czysto tekstowe. I tak na pierwszy rzut oka, to wszystko będzie wyglądać dość zagadkowy jeśli nigdy wcześniej zaprogramowane wcześniej. My będziemy mieć średniki i nawiasów, i nawiasy klamrowe i więcej. Ale sobie sprawę, że nawet choć składnia jest o wyglądać trochę zaznajomiony dla większości z was zobaczyć przeszłość. I spróbuj zobaczyć pomysły które są rzeczywiście znane, bo tutaj w tym tygodniu jeden, co zaczniemy robić to porównanie, Początkowo Scratch kontra C. 

Tak więc, na przykład, przypominam, że kiedy realizowane nasze pierwsze programów Ostatnim razem, mieliśmy blok, który wyglądał trochę coś jak this-- kiedy zielona flaga kliknięciu, a następnie mieliśmy jeden lub więcej elementów układanki pod nią w tym przypadku, powiedzmy, hello world. Tak, rzeczywiście, na początku, gdy klikam że zielone flagi uruchomić mój program, więc mówić, są to bloki, który zostanie wykonany, lub uruchomić. A konkretnie, Scratch powiedział, hello, world. 

Teraz mogłem podano różne słowa tutaj. Ale zobaczymy, że rzeczywiście, wiele tych blocks-- i rzeczywiście, w C może być wiele functions-- parametryzowane lub dostosować robić różne rzeczy. W rzeczywistości, jeśli mamy w C chcesz przekonwertować, a teraz, Ten program Scratch z tym innym języku, mamy zamiar napisać Trochę coś takiego. 

To prawda, jest jakaś obca Składnia jest najbardziej prawdopodobny, int, i nawiasy i nieważne. Ale printf-- choć byś myślę, że to po prostu drukowania. Ale druku oznacza drukiem sformatowany, a my wkrótce. To dosłownie drukuje do ekranu niezależnie od znajduje się wewnątrz tych nawiasach, które Oczywiście w tym przypadku jest, hello world. 

Ale zauważysz jakiś inny Składnia, niektóre podwójnych cudzysłowów, że nawiasy na końcu, średnik i tym podobne. Więc jest nieco napowietrznych, by tak rzec, zarówno poznawczo i składniowo, że jedziemy Trzeba pamiętać, aby przed długi. Ale sobie sprawę, że w praktyce, to rozpocznie się wyskoczyć na ciebie. 

W rzeczywistości, skupmy się na tym, że jeden Funkcja specifically-- w tym przypadku, przywitaj świat. Tak mówią jest funkcja. Hello world jest jego parametrów, lub argumentów, jej dostosowywania. 

Oraz równoważność w C jest po prostu Będzie to jeden wiersz tutaj gdzie printf jest równoznaczne z, powiedzmy, podwójne cudzysłowie, cześć Świat jest równoważne, oczywiście, do tego, co jest w białym pudełku. I n backslash, choć trochę dziwnie nieobecny od zera, po prostu będzie miał wpływ będziemy zobacz w komputerze, jak mój Mac lub PC, po prostu przesuwając kursor do następnego wiersza. To tak, jakby uderzenie Enter na klawiaturze. 

Więc widzimy, że ponownie przed długo. Ale po pierwsze, rzućmy okiem na to Innym przykładem, w przypadku pętli. Mieliśmy ten ostatni raz na zawsze pętlę, która była seria puzzli że zrobił coś dosłownie forever-- w tym przypadku, powiedzieć, hello world, hello world, hello world, hello world. Więc to nieskończoną pętlę z projektem. 

W C, jeśli chcemy, aby zaimplementować to Ta sama idea, że ​​może po prostu to zrobić. Choć to prawda, printf komentarzy world-- teraz gdy tylko semantycznie, rodzaj kojarzy się pomysł robienia coś znowu, i znowu, i znowu, i na jak długo? Cóż, true-- Przypomnijmy, że prawda jest tylko jedna lub. 

I prawdą jest, oczywiście, zawsze prawdziwe. Więc to trochę bez znaczenia Oświadczenie to znaczy prawdziwe. Ale rzeczywiście, jest to celowe, bo jeśli prawdą jest to zawsze prawdziwe, niż gdy prawda tylko wskazuje, jeśli trochę pośrednio że następujących linii kodu Pomiędzy tymi nawiasy należy po prostu wykonać znowu, i znowu, i znowu, i nigdy nie przestanie. 

Ale jeśli chcesz, żeby Twój pętli do zatrzymania, jak my ostatnim razem z czymś tego, powtarzaj następujące 50 razy, w C możemy zrobić to samo z tym, co nazywany przez loop-- słowa kluczowego Nie będąc jednocześnie, ale. A potem mamy jakąś nową składnię tutaj z int i jest równa 0, to mniej niż 50, i ++. I będziemy wracać do tego. Ale to jest po prostu jak to będzie przetłumaczyć zestaw klocków Scratch zestawowi linii C kodu. 

Tymczasem pod uwagę zmienne. I rzeczywiście, po prostu zobaczyłem przed chwilą. A w przypadku podstaw, gdybyśmy chciał zadeklarować zmienną o nazwie I bo jest liczbą całkowitą, tylko numer, i chcemy, aby ustawić go do pewnej wartości, użylibyśmy tego pomarańczowo zablokować here-- ustawić i na 0. 

I zobaczymy dzisiaj i poza nią, tak jak w zeszłym tygodniu, programiści zrobić prawie zawsze zaczynały się od zera, naprawdę umownie. Ale także dlatego, że odbierze od Nasza dyskusja binarny, najmniejszą liczbę można reprezentować dowolną liczbą bitów jest po prostu będzie się 0. I tak będziemy zazwyczaj rozpoczynają inicjowanie nawet nasze zmienne 0. 

A w C zrobić to samo, mamy zamiar powiedzieć, int do liczby całkowitej, po prostu przez konwencję. Mógłbym nazywa ta zmienna cokolwiek chcę, tak jak w Scratch. I wtedy właśnie przypisuje równa 0 wartość 0 z prawej i umieszcza go w zmiennej lub Pojemnik na tam, po lewej stronie. A średnik jako i my see-- widzieliśmy kilka z tych already-- oznacza po prostu koniec myślenia. Przejdź do zrobienia czegoś innego na liniach, które następują. 

Teraz, co z wyrażeń logicznych? Przypomnijmy, że na początku, były to wyrażenia które są albo prawdziwe lub false-- pytania, Naprawdę, które są albo prawdziwe, albo fałszywe. Tak więc w przypadku podstaw, możemy zadać proste pytanie w ten sposób, jest i mniejsza niż 50? Tak I znów jest liczbą całkowitą. Może używamy go W programie na zarysowania śledzić wynik czy coś takiego. Więc ta składnia tu w Scratch po prostu oznacza, że ​​jest mniej niż 50? Cóż, na szczęście, coś jest Prosty w C. I przetłumaczyć, to byłoby po prostu powiedzieć, że mniej niż 50, za pomocą klucza znanego na klawiaturze. 

Tymczasem, jeśli chcesz powiedzieć coś bardziej ogólnego, jak dobrze, to x mniej niż Y gdzie każdy X i Y są takie same zmienne? Możemy zrobić to samo w C, tak długo jak mamy stworzył już tych zmiennych. I zobaczymy jak zrobić niebawem. Chcemy po prostu powiedzieć x mniejsze od y. 

Więc zaczynamy zobaczyć kilka podobieństw. I tych ludzi, którzy dokonali Scratch były na pewno inspirowane przez niektóre z tych podstawowych pojęć. I zobaczysz tego rodzaju Składnia w wielu languages-- nie tylko podstaw, nie tylko C, ale Python, i JavaScript, a inne języki martwych. 

Rozważmy inny konstrukt z C, pojęcie stanu, robi coś warunkowo. Jeśli coś jest prawdziwe, to zrobić. Jeśli coś innego nie jest prawdziwe, to zrobić. To coś w rodzaju programowania odpowiednikiem rozwidleniu dróg. Może to dwukierunkowa widelec, trójdrożny widelec, lub więcej. A w zera, możemy mieć widziałem coś takiego. 

Więc ten jeden jest duży. Ale rozważyć względne Prostota logiki. Jeśli x jest mniejsze niż Y, to znaczy x jest mniejsza niż Y, w przeciwnym razie, jeśli x jest większa od y, to znaczy x jest większe niż y. A potem, logicznie, jeśli myślisz powrotem do zera lub po prostu własne ludzka intuicja, oraz, jeśli X nie jest większa od y, a X wynosi nie mniej niż Y, to oczywiście x ma być równa r. Więc w tym przypadku, poprzez zagnieżdżanie te bloki podstaw, możemy osiągnąć trzy Sposób widelec w drodze? 

Tymczasem, jeśli chcemy zrobić w C, to prawdopodobnie wygląda trochę simpler-- przynajmniej gdy pojawi się zapoznać ze składnią. Jeśli x jest mniejsze niż Y, printf x jest mniejsze niż y. Inaczej, jeśli x jest większa od y, printf x jest większe niż y. Inny printf x jest równe y-- i znowu z tymi backslash kończy się tuż dla tych nowych linii tak, że jeśli faktycznie prowadził tego rodzaju programu byłoby to po prostu przenieść kursor ostatecznie do następnego wiersza ekranu. 

Teraz, w międzyczasie miał inne Scratch Bardziej zaawansowane funkcje, tylko z których niektóre będziemy początkowo poruszać się w świecie C I jeden z nich był nazywa się lista w Scratch. A ten był szczególny typ zmiennej pozwalał na przechowywanie wielu rzeczy w jego plecy, do tyłu, do tyłu, do tyłu. 

W ° C, nie ma Wykazy, per se, ale coś które są bardziej ogólnie nazywane tablice, chociaż będziemy wrócić później w tym semestrze aby patrząc na coś nazywa listę, czy naprawdę połączonej listy. Ale na razie najbliżej równoważne w C dla nas będzie coś zwana tablicą. A tablica jest po prostu Szczególnym rodzajem zmiennej która pozwala na przechowywanie danych wstecz, do tyłu, do tyłu, do tyłu. 

I rzeczywiście, w Scratch, jeśli chcemy, aby uzyskać dostęp pierwszy element tablicy lub list-- i mam zamiar to nazwać, Umownie argv argument wektor, ale o tym wkrótce. Jeśli chcę, aby dostać się do pierwszego elementu ARGV, w świecie Scratch faktycznie zrobić typowo rozpocząć liczenie od 1. 

I tak mógłbym dostać punkt 1 argv. To, jak realizowane MIT pojęcie list. Ale w C, zamierzam prościej po prostu powiedzieć, argv, co znowu jest nazwa mojego list-- lub być jasne, tablicą. A jeśli chcę pierwszy Elementy, jadę używać nawiasów kwadratowych, które Cię nie może być używany w klawiaturze. 

Ale 0 oznacza po prostu, daj mi pierwszego. Tak przy okazji, jak z upływem czasu, jedziemy aby rozpocząć, aby zobaczyć te dychotomii między Scratch i C, przy czym Scratch wykorzystuje jeden. My w C stosować 0 tutaj. Ale będziesz szybko zobaczyć po zrozumieniu fundamenty każdego języka, to te rzeczy zaczynają się bardziej zaznajomieni poprzez praktykę i praktyki. 

Więc niech spojrzy teraz w programie. Tutaj jest pierwszy w naszym C Kod źródłowy dla kompletnych programów. A program jedziemy oferować odpłatnie to taka, która jest równoważna do tego wcześniejszego kawałka Scratch. 

Więc tutaj mamy co prawdopodobnie najprostszy program w C można napisać, że rzeczywiście coś robi. Teraz przyjrzymy przeszłości, Na razie jest to, średnia io.h, a te kąt Wsporniki i int, i nieważne, i kręcone, szelki i tym podobne. 

I niech po prostu skupić się na co, przynajmniej intuicyjnie, może wyskoczyć na ciebie już. W rzeczywistości głównym, nie wiem muszą wiedzieć, co to jest, ale podobnie jak Scratch, że kiedy miał zielona flaga kliknięciu kawałek układanki, tak nie C jako język programowania mają główny fragment kodu, który pobiera wykonywane domyślnie. I rzeczywiście, Jest to dosłownie będzie zwany głównym. 

Tak więc głównym jest funkcją. I jest to specjalna funkcja, która istnieje w C, który po uruchomieniu programu, jest głównym, który pobiera prowadzony przez zaniedbanie. W świecie Scratch, było zwykle, gdy zielona flaga kliknął że dostałem uruchamiany domyślnie. 

Tymczasem, widzieliśmy to już wcześniej, printf lub wydrukować sformatowane, to będzie to funkcja, która pochodzi z C, wraz z całą masę innych, że będzie od czasu i czasu I znów, w celu konkretnie jak sama nazwa wskazuje, coś wydrukować. Co chcemy drukować? Cóż, zobaczymy, że znakami załączając jak these-- Hello World, backslash n w cudzysłów, możemy powiedzieć dokładnie printf Co do wydrukowania na ekranie. 

Ale aby to zrobić że niestety trzeba wziąć coś, co jest tajemnicze już do nas ludzi, ale przynajmniej jest nieco readable-- ostre obejmują standardowe io.h, int, Głównym, nieważne, printf, wszystkie magiczne inkantacje właśnie zobaczyłem na ekranie. Ale tak naprawdę trzeba przejść dalej Arcane nadal. Najpierw musimy przetłumaczyć kod że piszemy do kodu maszynowego. I przypomnieć, że z ostatniego tygodnia maszyn, przynajmniej te znamy tutaj Na koniec dnia, tylko zrozumieć zer i jedynek. 

I mój Boże, jeśli mieliśmy napisać nich zer i jedynek faktycznie programem, że będzie bardzo, bardzo szybko trochę zabawy z niczego. Ale okazuje się, za ostatnim tygodniu, że te schematy zer i jedynek po prostu mają specjalne znaczenie. W pewnych kontekstach, mogą one oznaczają cyfry. 

W niektórych sytuacjach, mogą oznaczać, Litery lub kolory, lub dowolną liczbę innych abstrakcji tam po. Ale tak jak komputer ma CPU, Central Processing Unit lub mózgi wewnątrz komputera. Zazwyczaj Intel w środku, bo to jedna z największych firm sprawia, że ​​procesory do komputerów. 

Cóż, procesory Intel i inni po prostu postanowiliśmy z góry że pewne wzorce i zer te oznaczają konkretne rzeczy. Pewne schematy zer i jedynek będzie oznaczać, drukuj na ekranie, lub dodać te dwie liczby, lub odjąć te dwie liczby, lub przenieść ten kawałek danych z Pamięć mojego komputera tutaj, lub dowolną liczbę innych bardzo niskim poziomie ale ostatecznie przydatne operacje. Ale, na szczęście, my, ludzie, nie będziemy aby wiedzieć ten poziom szczegółowości. Rzeczywiście, tak jak ostatnim razem, gdzie wydobywane znowu, i znowu, i znowu, budynek z bardzo niskim poziomie prymitywy jak zer i jedynek wyższym poziomie pojęć jak cyfr i liter, i kolory, i więcej, Możemy więc jako programistów stanąć na ramionach inni, którzy przybyli przed nami i korzystać z oprogramowania, które nawzajem osób pisało wcześniej us-- czyli programy nazywane kompilatory. 

C jest językiem, który zazwyczaj jest skompilowany, co oznacza, przeliczone z Kod źródłowy do kodu maszynowego. W szczególności oznacza to, co jest to, że jeśli masz źródło kod, który sam pisać, a wkrótce będzie za chwilę na ekranie, i chcesz go przekonwertować ostatecznie maszynie code-- te zer i jedynek, które tylko komputer Mac lub komputer understands-- masz pierwszy RSS tego kodu źródłowego jako Wejście do specjalnego Program nazywa się kompilator, Sygnał wyjściowy z których ujrzy to kod maszynowy. I rzeczywiście, ostatni raz rozmawialiśmy o naprawdę, na koniec dnia rozwiązanie problemu. Musicie wejść. I masz wyjścia. A masz jakieś algorytmu w środku. 

Algorytmy mogą z pewnością realizowane w oprogramowaniu jak widzieliśmy w ostatnim tygodniu pseudokod a jak zobaczymy w rzeczywistym kodzie w tym tygodniu. I tak naprawdę tylko kompilator posiada zestaw algorytmów wewnątrz o tym, że wie, jak konwersja specjalnych słów kluczowych, jak główny i printf, i inni, że po prostu widział do wzorców i zer Te, które Intel Inside i inne procesory rzeczywiście rozumie. Więc w jaki sposób to zrobić? Gdzie możemy uzyskać kompilator? 

Większość z nas posiada Mac lub PC. A ty z systemem Mac OS lub Windows lub Linux lub Solaris lub dowolne inne system operacyjny. I rzeczywiście, mogliśmy wyjść na internecie i pobrać kompilator na komputerze Mac lub PC dla danego systemu operacyjnego. Ale wszyscy się na różnych stron, że tak powiem. Musielibyśmy nieznacznie różnych konfiguracjach. I rzeczy nie będzie działać tak samo. I rzeczywiście, w dzisiejszych czasach wielu z nas nie używać oprogramowanie, które działa tylko na naszych laptopów. Zamiast tego używamy coś jak przeglądarka, która pozwala nam na dostęp internetowy Aplikacje w chmurze. A jeszcze w tym semestrze, będziemy robić dokładnie to. Będziemy pisać aplikacje lub oprogramowania za pomocą code-- nie C, ale inne języki, takie jak Python i JavaScript-- działające w chmurze. 

A do tego, my sami w trakcie semestru faktycznie użyć oparte na chmurze środowisku znany jako CS50 IDE. To programowania oparty na sieci Web środowiska, lub zintegrowany rozwój środowisko, IDE, który jest zbudowany na szczycie niektórych Oprogramowanie open source o nazwie Cloud 9. I zrobiliśmy niektóre pedagogiczne uproszczeń do niego tak, aby ukryć pewne cechy pierwsze tygodnie, że nie ma potrzeby, po którym można ujawniają je i robić najbardziej cokolwiek chcesz z otoczeniem. 

I to pozwala nam także, aby pre-instalacji określonego oprogramowania. Rzeczy takie jak tzw CS50 biblioteki, które będziemy wkrótce dostarcza nam w C z niektórymi Dodatkowa funkcjonalność. Więc jeśli pójdziesz do ostatecznie CS50.io, zostaniesz poproszony o zalogowanie się, i raz zrobić i stworzyć Załóż konto za darmo, będzie można uzyskać dostęp do Środowisko, który wygląda zupełnie jak ta. 

Teraz, to jest w trybie domyślnym. Wszystko jest ładne i jasne na ekranie. Wielu z nas ma zwyczaj pracuje na kawałku CS50, który jest dość późno w nocy. I tak niektórzy z was mogą preferować przekształcić go w trybie nocnym, że tak powiem. 

Ale, ostatecznie, co masz żeby zobaczyć ciągu CS50 IDE to trzy odrębne areas-- obszar, na lewo, gdzie Twoje pliki będą w Chmura, obszar w prawym górnym rogu gdzie Twój kod będzie można edytować. Będziesz w stanie otworzyć Poszczególne zakładki dla każdego programu że piszesz w tym semestrze wewnątrz tego prawym górnym rogu. I wtedy najbardziej arcanely, a jednak mocno, będzie to coś u Dno znany jako oknie terminala. 

To jest stara szkoła Command Line Interface, lub CLI, który pozwala do wykonywania poleceń na computer-- w tym wypadku komputer w cloud-- robić takie rzeczy jak skompilować kod z kodu źródłowego do kodu maszynowego, do uruchamiania programów lub na rozpoczęcie serwer WWW lub w celu uzyskania dostępu do bazy danych, i wielu innych technik że zaczniemy używać niedługo. Ale żeby się tam dostać, jesteśmy będzie rzeczywiście przejść do trybu online i zacząć grać. I to zrobić, niech pierwszy zacząć majstrować przy głównym, i zapisu główną część programu. I użyjmy tej funkcji printf, którego użyliśmy wcześniej, po prostu coś powiedzieć. 

Więc tutaj jestem już wewnątrz CS50 IDE. Mam zalogowany wyprzedzeniem. I pełne przesiewa się przez okno. I tak, w końcu, ty też w nadchodzących problemów pójdą podobne kroki, które dostarczy dokumentację online. Więc nie trzeba się martwić chłonąc każdy mały krok technicznej że ja tu dzisiaj. 

Ale dostaniesz ekran takiego. Zdarza mi się być w trybie nocnym. I można rozjaśnić wszystko przez wyłączenie trybu nocnego. I na koniec dzień, idziesz, aby zobaczyć Te trzy główne areas-- pliku Przeglądarka w lewo, klapki kodu w górę w górę, a okno terminal na dole. 

Pozwólcie mi iść do przodu i napisać swój pierwszy program. Idę zapobiegawczo przejść do pliku, Zapisz, a następnie zapisz plik jako hello.c moje. Rzeczywiście, zgodnie z przyjętą konwencją, każda mamy programu napisać, że jest napisany w języku C powinien być nazwany coś kropka c, zgodnie z przyjętą konwencją. Więc mam zamiar wymienić go hello.c, ponieważ Chcę tylko powiedzieć cześć świata. Teraz mam zamiar powiększyć się i kliknij Zapisz. I wszystko, co mam tu teraz jest zakładka w którym mogę zacząć pisać kod. 

To nie będzie skompilować. Oznacza to nic. A więc nawet jeśli przekształcone to zer i jedynek, CPU będzie miał żadnego Pomysł, co się dzieje dookoła. Ale jeśli piszę wiersze, które pasują do siebie z conventions-- C to C, w ponownie, tym language-- ze składnią jak to printf komentarzy world-- i mam zdobyć komfortowo robi to w miarę upływu czasu. Więc nie sądzę, zrobiłem wszelkie błędy typograficzne. 

Ale zawsze, pierwszy Czas to zrobisz, będziesz. A co mam zrobić, może bardzo również nie działać dla ciebie za pierwszym razem. I to jest zupełnie OK, bo teraz jesteś Może po prostu zobaczyć całe mnóstwo nowości, ale z biegiem czasu, gdy pojawi się znajome z tego środowiska, a Ten język, a inni, zaczniesz widzieć rzeczy, które albo są poprawne lub niepoprawne. 

I to jest to, co Fellows nauczania i przebieg asystenci uzyskać tak dobry w miarę upływu czasu, jest plamienia błędów lub błędów w kodzie. Ale twierdzą, że nie Brak błędów w tym kodzie. Więc teraz chcę, aby uruchomić ten program. 

Teraz na własnym komputerze Mac lub PC, jestem w nawyk podwójnego klikania ikony gdy chcę uruchomić jakiś program. Ale to nie jest tutaj model. W tym środowisku, które jest CS50 IDE. Używamy operacyjną System o nazwie Linux. Linux jest przypominający innego system operacyjny, powszechnie znane jak Unix. I Linux jest szczególnie znana o Command Line Środowisko, CLI. Teraz używamy swoistego Smak Linux o nazwie Ubuntu. A to po prostu Ubuntu pewna wersja Linux. 

Ale te Linuksa te dni faktycznie pochodzą z graficznym interfejsem użytkownika. A ten, który się zdarzyć być tutaj używając jest oparty na sieci Web. Tak to może wyglądać nawet Trochę różni się od czegoś sam może mieć widział lub uruchomić w przeszłości. 

Więc mam zamiar iść do przodu teraz i wykonaj następujące czynności. Uratowałem ten plik jako hello.c. Mam zamiar iść do przodu i Typ clanghello.c Więc Clang dla języka C jest kompilator. To wstępnie zainstalowane w CS50 IDE. I można pobrać i absolutnie zainstalować to na swoim własnym komputerze Mac lub PC. 

Ale znowu, to nie miałoby wszystkich wstępna konfiguracja odbywa się za Ciebie. Więc teraz, jestem tylko zamierza uruchomić clanghello.c. A teraz zauważyć tej składni Tutaj w końcu sobie sprawę, oznacza to, że jestem w folder lub katalog o nazwie Workspace. Ten znak dolara to tylko konwencja sensu wpisz swoje polecenia tutaj. 

To, co się nazywa szybka, wystarczy umownie jest znak dolara. A jeśli pójdę teraz do przodu, a następnie kliknij Enter, nic się nie stało. Ale to naprawdę dobra rzecz. Im mniej, co dzieje się na ekran, tym bardziej prawdopodobne Twój kod jest prawidłowe, przynajmniej składniowo. 

Więc jeśli chcę uruchomić to Program, co mam zrobić? Cóż, okazuje się, że Domyślna nazwa umownie programów, jeśli nie podasz nazwę dla programu jest po prostu a.out. I ta składnia też będziesz zapoznanie się z wcześniej długo. 

Dot slash po prostu oznacza, hej, CS50 IDE, uruchom program o nazwie a.out to w moim bieżącym katalogu. To kropka oznacza katalog bieżący. I zobaczymy, co inne takie sekwencje znaków oznacza niebawem. 

Więc zaczynamy, Enter, hello world. I można zauważyć, że to, co się stało? Nie tylko wydrukować Hello World. To również przeniósł kursor do następnego wiersza. 

I dlaczego to było? Jaki był kod, który pisaliśmy wcześniej który zapewnił, że kursor będzie przejdź do następnego wiersza? Zabawne około Komputer jest to tylko będzie robić dosłownie co powiedzieć to zrobić. 

Więc jeśli powiesz jej printf cześć, przecinek, przestrzeni, świata, w pobliżu cytat Jest to dosłownie tylko będzie wydrukować te znaki. Ale miałem ten szczególny charakter Na koniec przypominam, backslash n. I to właśnie zapewnił że charakter poszedł do następnego wiersza ekranu. 

W rzeczywistości, pozwól mi iść i to zrobić. Pozwólcie mi iść do przodu i usuwania tego produktu. Teraz zwróć uwagę, że góra moim ekranie nie ma trochę czerwona lampka zakładka wskazuje, hej, nie wcześniej zapisany plik. Więc mam zamiar iść do przodu z regulacją S lub S polecenie, zapisz plik. Teraz goes-- poszedł na moment-- zieleni. A teraz z powrotem do po prostu będąc bliski ikony. 

Jeśli teraz ponownie uruchomić clanghello.c, Enter, kropka ukośnik, a.out, Enter, zobaczysz, że nadal pracował. Ale to zapewne trochę buggy. Teraz, mój prompt-- roboczy, a następnie, że znak dolara, a następnie moja rzeczywista prompt-- jest w tej samej linii. Więc to na pewno estetyczny bug, nawet jeśli to naprawdę nie jest logiczny błąd. 

Więc mam zamiar cofnąć to, co właśnie zrobił. Idę powtórzona a.out. Zauważ Dodałem znak nowej linii do tyłu. Uratowałem plik. 

Więc mam zamiar ponownie uruchomić a.out, and-- Cholera, to błąd, błąd, co oznacza błąd. Więc błąd jest, że chociaż Dodałem ukośnik n tam, ponownie zapisane, ponownie uruchomiono program zachowanie było takie samo. Dlaczego miałoby to być? 

Brakuje mi krok, prawda? To kluczowy krok wcześniej było to, że masz to-- po zmianie kodu źródłowego, Okazuje się również uruchomić to przez kompilator znowu więc można dostać nowy kod maszynowy. I kod maszynowy, zera i jedynki, będą niemal identyczne, ale Nie tak doskonale, bo musimy, oczywiście, że nowa linia. 

Tak więc, aby rozwiązać ten problem, będę potrzebował ponownie uruchomić clanghello.c, wejść, kropka slash, a.out. A teraz, hello world is back gdzie mogę oczekiwać, że będzie. Więc to wszystko jest w porządku i dobrze. Ale a.out jest dość głupie nazwy dla Program, choć zdarza się, ze względów historycznych, The default-- czyli wyjść montażu. 

Ale pozwól mi iść dalej tutaj i to zrobić inaczej. Chcę mój program Hello World faktycznie nazwać cześć. Tak jakby to była ikona na moim pulpit, nie byłoby a.out. Byłoby to nazwać cześć. 

Tak więc, aby to zrobić, okazuje się, że Clang, podobnie jak wiele programów, obsługuje argumenty wiersza poleceń, lub flagi, albo przełączniki, który po prostu mieć wpływ na jego zachowanie. Konkretnie Clang obsługuje kreska O flaga, która następnie wykonuje drugie słowo. W tym przypadku, będę arbitralnie, ale rozsądnie, nazywają go przywitać. Ale mogę nazwać to coś Chcę, chyba a.out, które byłoby raczej poza punkt. 

A potem po prostu podać nazwę pliku chcę skompilować. Więc teraz, chociaż na początku komendy mam jeszcze brzękiem, pod koniec polecenia Nadal mam nazwę pliku, Mam teraz te wiersza poleceń argumenty, te flagi, które mówią, Och, przy okazji, wyjście-o, plik nazywa cześć, a nie domyślny a.out. 

Więc jeśli uderzę Wprowadź teraz, nic Wydaje się, że stało. A jednak teraz mogę zrobić dot ukośnik cześć. Więc to jest ten sam program. W zer i jedynek są identyczne pod koniec dnia. 

Ale są w dwóch inna files-- a.out, który jest pierwsza wersja i po prostu głupio nazwane, a teraz cześć, która jest znacznie bardziej przekonujące nazwę dla programu. Ale, szczerze mówiąc, nigdy nie jestem będziemy pamiętać, to znowu, i znowu, i znowu. I rzeczywiście, jak piszemy bardziej skomplikowane programy, polecenia mozesz będzie musiał napisać chce stać się nawet bardziej skomplikowane nadal. 

I tak się nie martwić. Okazuje się, że ludzie przed USA mają sobie sprawę, że zbyt miałem dokładnie ten sam problem. Oni też nie cieszą konieczności wpisać dość długie, tajemne poleceń, nie mówiąc już o nich pamiętać. I tak ludzie przed nami dokonały inne programy, które ułatwiają do kompilacji oprogramowania. 

I rzeczywiście, jedną z takich Program nazywa się wprowadzić. Więc mam zamiar iść do przodu i to zrobić. Zamierzam cofnąć wszystko, co tak jak w następujący sposób. Pozwól, typ LS. I można zauważyć trzy things-- a.out, a gwiazdą, witam i gwiazda i hello.c. Mamy nadzieję, że proporcja ta powinna być trochę intuicyjne, o ile wcześniej nie było nic w tym obszarze roboczym. Nie było nic, że miałem utworzony, dopóki nie zaczęliśmy klasę. 

I stworzył hello.c. Następnie opracowano go i nazwał go a.out. A potem kompilowany ponownie nieznacznie inaczej i nazwał go przywitać. Więc mam trzy pliki w tym katalogu, W tym folderze o nazwie roboczej. Teraz widzę, że dobrze gdybym pomniejszyć rzeczywistości. 

Gdybym tu i pomniejszyć patrzeć na tę górę prawą rękę rogu, jak obiecał lewa strony ekranu zawsze będzie pokazać co jest na koncie, co jest Wnętrze CS50 IDE. I nie ma tam trzy pliki. 

Więc chcę pozbyć a.out i cześć. I jak może wyobrazić sobie intuicyjnie, ty może rodzaj sterowania kliknięcia lub kliknąć prawym przyciskiem myszy na ten temat. A to małe menu. Możesz pobrać plik, uruchom Opisz je przejrzeć, odświeżyć, zmienić nazwę, i co nie. 

A może po prostu usunąć i byłoby odejść. Ale zróbmy rzeczy z poleceniem Linia do tej pory tak się komfortowo z tym, i wykonaj następujące czynności. Mam zamiar iść do przodu i wyjąć a.out wpisując dosłownie rma.out. Okazuje się, polecenia dla usuwanie lub usuwanie coś, nie usuwać lub usunąć. 

To bardziej zwięźle RM, tylko zapisać Ci kilka klawiszy i naciśnij Enter. Teraz mamy zamiar być nieco tajemniczo usunięcia regularne a.out pliku. I naprawdę nie wiem, co za nieregularne plik byłby jeszcze. Ale chcę, aby ją usunąć. 

Więc zamierzam typu Y na tak. Albo mogę wpisać go i naciśnij Enter. I znowu, nic się nie dzieje. Ale to, na ogół, jest dobrą rzeczą. 

Gdybym typ LS tym razem, co mam widzieć? Mamy nadzieję, że po prostu przywitać i hello.c. Teraz, jak na bok, będziesz zauważy ten gwiazda, gwiazdka, to na koniec moich programów. I oni również pojawiać się na zielono. To jest po prostu sposobem CS50 IDE z cluing cię do rzeczywistości że to nie jest kod źródłowy. To jest plikiem wykonywalnym, o runnable program, który rzeczywiście można uruchomić wykonując dot ukośnik, a następnie jego nazwę. 

Teraz, pozwól mi iść do przodu i wyjąć to rm witam, Enter, usuń regularne złożyć cześć, tak. A teraz, jeśli typ LS, wracamy do hello.c. Staraj się nie usuwać swoje Rzeczywisty kod źródłowy. Nawet jeśli istnieją funkcje wbudowany CS50 IDE gdzie można przejść przez historii zmian i do tyłu w czasie, jeśli przypadkowo coś usunąć, należy mieć na uwadze jak na tych monitów tak lub nie, o tym, co rzeczywiście chcesz zrobić. A jeśli pójdę do góry lewy rogu tutaj pozostaje tylko hello.c. Więc nie ma pęki inne polecenia, które można wykonać w świecie Linuksa z których jeden jest, ponownie, Marka. I mamy zamiar zrobić mój program przedstawia się następująco. 

Zamiast robić szczęk, zamiast robić clang-o, Idę po prostu dosłownie rodzaju, marki Halo. A teraz zauważyć, jestem Nie wpisując dokonać hello.c. Piszę aby przywitać. 

A ten program sprawi że pochodzi z CS50 IDE, a bardziej na ogół z Linuksem, Jest to program, który jest zamiar zrobić program o nazwie Halo. I to się dzieje, aby zakładać, zgodnie z konwencją, że jeśli program ten może być wykonana, to ma być wykonany ze źródła Plik kodu kończy się kropką c, hello.c. 

Więc jeśli uderzę Wprowadź teraz zauważyć, że komenda, która zostanie wykonana jest w rzeczywistości nawet dłużej wcześniej niż dotychczas. A to dlatego, że mamy wstępnie CS50 IDE mieć niektóre dodatkowe funkcje wbudowane w tym nie musimy jeszcze, ale wkrótce będzie. Ale najważniejsze jest, aby uświadomić sobie, Jest teraz mam program Halo. 

Gdybym typ LS znowu mieć program Halo. I mogę go uruchomić z Dot slash a.out, nie, bo cały sens tego ćwiczenia była kropka ukośnik cześć. A teraz mam mój program Hello World. Więc naprzód, prawie zawsze po prostu zamierza skompilować nasze programy za pomocą polecenia make. A potem mamy zamiar uruchomić je Dot slash i nazwa programu. Ale sobie sprawę, co robi dla Marka ty, to ono samo nie kompilatora. To tylko program wygoda który wie, jak wywołać kompilator biec tak, że sam może go używać. 

Jakie istnieją inne polecenia w Linux, az kolei CS50 IDE? Wkrótce zobaczysz, że istnieje Polecenie CD, Change Directory. To pozwala w ciągu Twój interfejs linii poleceń do przodu i do tyłu, i otworzyć różne foldery bez użycia myszy. 

LS widzieliśmy, co oznacza listy pliki w bieżącym katalogu. Bądź Dir, można prawdopodobnie rozpocznie się wyprowadzić co to znaczy now-- dokonać katalogu, jeśli chcesz utworzyć folder. RM do usuwania, RM kierunek dla usuń directory-- i te, znowu, to linia poleceń odpowiedniki tego, co może zrobić w CS50 IDE za pomocą myszki. Jednak wkrótce okaże że czasami jest to po prostu dużo szybciej robić rzeczy z klawiatury, a ostatecznie o wiele bardziej wydajny. 

Ale trudno twierdzić, że cokolwiek robiliśmy do tej pory wszystko jest tak potężny, gdy wszystkie byliśmy mówiąc znaczy Hello World. I w rzeczywistości, sztywno Słowa powitania świat w moim programie. Nie ma jeszcze dynamizm. Scratch była o rząd wielkości bardziej interesujące w zeszłym tygodniu. 

A więc niech tam dostać. Weźmy krok ku temu, by sposób niektóre z tych funkcji. Więc nie tylko C pochodzą z printf, i kiście innych funkcji niektóre z nich zobaczymy z upływem czasu, to nie robi sprawiają, że wszystko tak łatwo od razu po wyjęciu bramy w uzyskaniu danych wprowadzanych przez użytkownika. 

W rzeczywistości jeden ze słabych języków takich jak C, a nawet Java i jeszcze inne, jest to, że nie ułatwiają prostu takie rzeczy liczbami całkowitymi od użytkowników lub sznurków, słów, i zwrotów, nie mówiąc takie rzeczy zmiennoprzecinkowych lub liczb rzeczywistych z kropkami, a tak naprawdę długie numery, a my wkrótce. Więc to lista funkcji tutaj, te są podobnie jak inne kawałki układanki Scratch że mamy zainstalowane w CS50 IDE, które będziemy używać przez kilka tygodni jako kółka o rodzaju i w końcu je zdjąć i szukać pod maską, być może, w jak te rzeczy są realizowane. 

Ale żeby to zrobić, niech faktycznie napisać program. Pozwólcie mi iść do przodu teraz. A ja zamierzam utworzyć nowy plik, klikając ten mały znak plus, i klikając nowego pliku. 

Mam zamiar zapisać to następna jeden, jak, powiedzmy, string.c, bo chcę grać z łańcuchów. I ciąg w C jest po prostu sekwencją znaków. Więc teraz chodźmy do przodu i wykonaj następujące czynności. 

Zawierać standardowe IO.h-- i Okazuje się standardowe IO, IO oznacza po prostu wejście i wyjście. Tak więc okazuje się, że linia ta oto co jest sąsiedni nam korzystać printf. Printf, oczywiście, produkuje wyjście. Tak więc w celu użycia printf okazuje out trzeba mieć ten wiersz kodu na początku pliku. 

I będziemy wracać do tego, co to naprawdę oznacza niebawem. Okazuje się, że w każdy program C piszę, Muszę zacząć go kod, który wygląda następująco. A zauważysz CS50 IDE, a Inny zintegrowany rozwój środowiskach, takich jak to, zamiar spróbować jak najlepiej mogą skończyć swoją myśl. W rzeczywistości, przed chwilą, czy mogę cofnąć co właśnie zrobiłem, naciśnij Enter. 

Potem uderzył otwartą kręcone nawiasów, naciśnij Enter ponownie. I skończyłem myśl. To dało mi nową linię, wcięty nie mniej za miłe stylistycznych powodów zobaczymy. A potem dał mi on automatycznie że nawias klamrowy dokończyć myśl. Teraz nie zawsze domyślam się, co chcesz zrobić. Lecz w dużej mierze, to nie zaoszczędzić kilka klawiszy. Więc przed chwilą, prowadziliśmy tę program-- hello, world, a następnie zestawiane go, a następnie prowadził ją. Ale nie ma tu dynamizm. Co zrobić, jeśli chcemy zrobić coś innego? A co gdybym chciał rzeczywiście uzyskać ciąg od użytkownika? Zamierzam użyć kawałek układanki nazywa się dokładnie that-- ciąg. 

Okazuje się, że w C, jeśli nie chcą aby zapewnić wejście do kawałka układanki, lub więcej odpowiednio do funkcji, należy dosłownie zrobić otwartego nawiasu, zamknij nawias. Więc to tak, jakby tam no białe pole do wpisywania się. Blok powiedzmy przed miał trochę białe pole. Nie mamy teraz to białe pole. 

Ale kiedy zadzwonić get ciąg, I chcesz umieścić wynik gdzieś. Tak bardzo powszechnym paradygmatem w C jest wywołania funkcji, jak get ciąg tutaj a następnie zapisać zwróconej wartości. Jest to wynikiem jego wysiłek w coś. 

A jaka jest skonstruować w programowaniu, czy to w C podstaw lub teraz, że my Można użyć, aby faktycznie coś zapisać? Wywoływana jest zmienna, prawda? A nowa, tak naprawdę nie obchodzi, co dzieje się w zmiennych. 

Ale w tym przypadku rzeczywiście zrobić. Idę powiedzieć ciąg. I wtedy będę mógł zadzwonić to wszystko chcę. Mam zamiar to nazwać imię, staje się łańcuch. 

A teraz nawet jeśli jesteś trochę nowy w tym, zauważyć, że brakuje mi jakiś szczegół. Ja zapominam średnik. Muszę skończyć tę myśl. Więc mam zamiar przenieść kursor, i uderzył średnik tam. I co ja właśnie zrobiłem? W tej linii kodu, Numer 5 w tej chwili, Dzwonię get ciąg bez nakładów. Nie ma więc mały biały box jakby Zapisz blok ma. 

Po prostu mówię, hej, komputer, daj mi łańcuch. Znak równości nie jest tak naprawdę znak równości, per se. To przyporządkowanie Operator, który oznacza hej, komputer, przesuwać wartość z prawej strony na lewo. A w lewo, mam następujący. 

Hej, komputer, daj mi string-- sekwencją znaków. I nazywają to string Nazwa. I nie trzeba nawet nazwać Nazwa. 

Mógłbym to nazwać, konwencjonalnie, coś jak S, podobnie jak kiedyś I do zadzwoń zmiennej i. Ale teraz muszę coś z tym zrobić. Byłoby to dość głupie spróbuj skompilować ten kod, bieganie ten program, choć Dostaję ciąg, bo to wciąż tylko zamiar przywitać świat. 

Ale co, jeśli chcę, aby to zmienić. Dlaczego nie mogę to zrobić? Procent s, przecinek s. I to jest trochę tajemniczy nadal. 

Więc pozwól mi moje zmienne bardziej jasne. Pozwól mi nazwać to nazwa zmiennej. I zobaczmy, czy nie możemy drażnić Oprócz tego, co się tutaj dzieje. 

Więc on line pięciu, Dostaję ciąg. A ja przechowywania tego ciągu, co użytkownik wpisał na swojej klawiaturze, w zmiennej o nazwie Name. I okazuje się, że printf nie tylko przyjmować jeden argument w podwójnej cytaty, jedno wejście w cudzysłów. 

może przyjmować dwa, albo trzy, lub więcej, na przykład że drugi lub trzeci lub czwarty są wszystkie nazwy zmiennych, lub szczególnie ceni, które chcesz podłączyć do, dynamicznie, że ciąg w cudzysłowach. Innymi słowy, byłoby w tym złego? Gdybym tak powiedział cześć imię, backslash n, uratował mi plik skompilowany mojego kodu, i prowadził tego, co by się stało? 

To jest po prostu powiedzieć, hello nazwa, dosłownie N-A-M-E, co jest głupie, bo to nie różni się od świata. Więc wszystko jest w cudzysłowie co dosłownie zostanie wydrukowany. Więc jeśli chcę mieć symbol zastępczy tam, I rzeczywiście trzeba użyć niektóre specjalna składnia. I okazuje się, jeśli czytasz Dokumentacja dla funkcji printf powie to, że jeśli używasz procent s, można zastąpić wartość w następujący sposób. 

Po przecinek po tym cudzysłów, po prostu wpisz nazwę zmienna, że ​​chcesz podłączyć do tego formatu Kod lub Format specifier, procent s ciągów. A teraz, jeśli mam zapisany mój plik, Wracam do mojego terminalu. I make String, bo, znowu, nazwa ta Plik, który wybrałem wcześniej jest string.c. 

Więc powiem Bądź String wprowadzić. O mój Boże, spójrz na wszystko błędy zrobiliśmy wcześniej. I to is-- co, to jest naprawdę jak sześć, siedem linii programu? Tak to jest, gdy może ona bardzo Szybko się przytłaczająca. 

To okno terminalu ma teraz po prostu wypluta ogromna liczba komunikatów o błędach. Na pewno nie mam więcej błędów Komunikaty niż ja linijek kodu. Więc, co się dzieje? 

No, najlepszą strategią to zrobić w każdej chwili napotykają przytłaczająca lista błędów tak, jest przewijanie wstecz, spojrzeć na komendzie po prostu biegł, co w moim przypadku to zrobić łańcuch. Spójrz na to, co czynią tak, i to, że długie polecenie Clang, nic wielkiego tam. 

Ale czerwony jest źle. Zielona stara się być delikatne i pomocny. Ale to wciąż złe, w tym przypadku. Ale gdzie to jest złe? 

String.c linia pięć, pięć znaków. Więc to jest tylko zdrowy konwencji. Coś oznacza coś grubego numer linii i liczby znaków. Błąd, korzystanie z nierejestrowana Ciąg identyfikatora. Czy chodziło Ci o standard? 

Tak, niestety, Clang stara się być pomocny. Ale to się stało w tym przypadku. Nie, Clang, nie miałem na myśli standardowe IO. Miałem na myśli, że na jednej linii, tak. 

Ale linia pięć jest tym tutaj. I Clang nie zrozumieć S-T-Ri-N-G. Jest to identyfikator nierejestrowana, A Słowo to po prostu nigdy nie widział. A to dlatego, C, język piszemy kod w tej chwili, nie ma zmiennych zwanych ciągów. 

To nie ma domyślnie wsparcia coś, co nazywa się ciąg. To kawałek z CS50 żargon, ale bardzo konwencjonalne. Ale mogę rozwiązać ten problem w następujący sposób. 

Jeśli dodać jedną linię kodu na wierzchu tego programu obejmują CS50.h, który jest inny plik gdzieś wewnątrz CS50 IDE, gdzieś na dysku twardym, by tak rzec, systemu operacyjnego Ubuntu że biegnę, że Jest to plik zamiar nauczyć operacyjną System jakie ciąg jest po prostu jak standardowego io.h jest plik w systemie operacyjnym, który jest zamiar nauczyć go, co printf jest. 

Rzeczywiście, chcemy zdobyć bardzo podobny komunikat jeśli IO przyznał standardu Io.h i próbował użyć printf. Więc mam zamiar iść do przodu i po prostu Przejmij kontrolę L, aby wyczyścić ekran. Albo można wpisać jasne i będzie wystarczy wyczyścić okno terminala. Ale nadal można przewijać wstecz w czasie. 

I mam zamiar ponownie uruchomić Bądź String. Trzymam kciuki tym razem Enter. O mój Boże, to działało. to pokazuje mi dużo polecenie tajemniczy to, co czyni generowany poprzez Clang, ale żadne komunikaty o błędach. Więc sobie sprawę, chociaż można całkowicie pozbyć przytłoczony liczba komunikatów o błędach, to właśnie może być to denerwujące kaskadowy efekt, jeżeli Clang nie rozumie Jedno, co oznacza, że ​​wówczas nie rozumie następne słowo, lub następnego wiersza. I tak po prostu dławi się na kodzie. Ale poprawka może być proste. I tak zawsze skupić się na Pierwszy wiersz wyjścia. A jeśli tego nie zrobisz zrozumieć, wystarczy spojrzeć słów kluczowych, które mogą być wskazówki i numer linii, i charakter, w którym które może być błędem. 

Teraz pozwól mi iść do przodu i wpisz Dot slash, łańcuch, enter. Hm, to nie witania czegokolwiek. Czemu? Cóż, pamiętam, gdzie to działa? 

To chyba tkwi w tym momencie w pętli, jeśli chcesz, w wierszu szóstym, ponieważ Get String z projektem, napisany przez pracowników CS50, dosłownie oznaczało po prostu siedzieć tam czeka i czeka, i czeka na sznurku. Wszyscy rozumiemy przez ciąg wejściowy jest człowiekiem. Więc wiesz co? Pozwólcie mi iść do przodu. I tak dla kaprysu, pozwól mi wpisz swoje imię, David, enter. Teraz mam bardziej dynamiczny program. Mówi się, cześć Davida. 

Jeśli pójdę do przodu i uruchomić to znowu, pozwól mi spróbować powiedzieć nazwę Zamila wprowadzić. A teraz mamy dynamiczny program. Nie trudno kodowane świat. Nie trudno kodowane nazwę lub David lub Zamila. 

Teraz jest o wiele bardziej jak w programach Wiemy, gdzie jeśli to zajmie wejście, produkuje się nieco różnić. Otóż, nie jest to najlepszy doświadczenie użytkownika lub UX. Uruchomić program. 

Nie wiem, co mam robić, chyba że rzeczywiście spojrzeć na czy zapamiętać kod źródłowy. Więc zróbmy użytkownikowi doświadczyć trochę lepiej z najprostszych rzeczy. Pozwól mi wrócić do tego program, a następnie po prostu powiedzieć printf. 

I pozwól mi iść dalej i powiedzieć, nazwisko, jelita grubego, i przestrzeni, a następnie średnik. I tylko dla zabawy, nie ma luzów n. I to jest celowe, bo nie chcą monit, aby przejść do następnego wiersza. 

Chcę, zamiast to zrobić, aby ciąg rekompilacji kodu do nowej maszyny Kod Dot slash ciąg. Ach, to jest o wiele ładniejsza. Teraz tak naprawdę wiedzieć, co komputer chce mi zrobić, nadać mu nazwę. 

Więc mam zamiar iść do przodu i wpisz w Roba, wejść, i cześć, Rob. Tak więc sobie sprawę, że jest nadal na koniec dnia, program tylko dziewięć linii. Ale podjęliśmy kroki dziecka. 

Pisaliśmy o jedną linię, z którą znali, printf, hello world. Potem rozpiął trochę tego. I rzeczywiście wykorzystane pobiera ciąg znaków. A my odrzucił tę wartość w zmiennej. A potem poszedł do przodu i poprawić Ponadto w trzeciej linii. I ten proces iteracyjny pisanie oprogramowania jest naprawdę kluczem. W CS50, w życiu w ogóle, nie powinno się na ogół usiąść, mieć program w pamięci, a następnie spróbuj pisanie całe cholerstwo wszystkie naraz. 

To będzie nieuchronnie prowadzić sposób więcej błędów niż my sami widzieli tutaj. Nawet ja, do dnia dzisiejszego stale wprowadzić inne głupie błędy, są rzeczywiście trudniejsze błędy które są trudniejsze do rozszyfrowania. Ale można zrobić więcej błędów bardziej linie kodu piszesz wszystkie naraz. A więc ta praktyka, napisać trochę kodu że jesteś wygodne, kompilowania Opisz go uruchomić, przetestować go bardziej ogólnie, następnie przenieść on-- tak samo jak my zachowaliśmy warstw i warstw w zeszłym tygodniu, budynku od czegoś bardzo proste do czegoś bardziej skomplikowanego, tu zrobić to samo. Nie usiąść i spróbować napisać cały problem. Właściwie podjąć kroki dziecka. 

Teraz, łańcuchy nie są że przydatne do siebie. Chcemy rzeczywiście, najlepiej, jak to jest mieć coś innego w naszej Toolkit. Więc faktycznie robią dokładnie to. 

Pozwólcie mi iść do przodu i teraz wzbudzać nieco inny program. A my nazywamy to int.c dla całkowitej. Idę, podobnie, obejmują CS550.h. Zamierzam to standardowe IO. I że będzie to dość powszechne w tych pierwszych kilku dni klasy. 

I będę gotowy Sam z główną funkcją. A teraz zamiast się ciąg, chodźmy do przodu i uzyskać int. Nazwijmy to ja, i nazywają go pozbyć int, zamknij nawiasy, średnik. A teraz zróbmy coś z nim, printf. 

Powiedzmy, że coś takiego witam, backslash n, przecinek i. Więc jestem dość dużo naśladując co zrobiłem przed chwilą. Mam tu zastępczy. Mam przecinkiem I tu, bo chcę do podłączenia I w tym zastępczy. 

Więc idź naprzód i spróbować przygotowanie tego programu. Plik nazywa int.c. Więc mam zamiar powiedzieć, aby int wprowadzić. O mój Boże, ale to nic wielkiego, prawda? Jest to błąd. 

Jest błędem składniowym tutaj taki, że program nie może zostać skompilowany wewnątrz int.c, linii siedem znaków 27, format error określa typ char gwiazda, cokolwiek to znaczy. Ale argument jest typu int. 

Więc tutaj też mamy nie dzieje to-- chociaż dzisiaj jest dużo materiału, mamy zamiar cię przytłaczać absolutnie każda cecha C, i programowania ogólniej zaledwie w tych pierwszych kilku tygodni. Więc nie często będzie żargonie z którymi nie jesteś zaznajomiony. I rzeczywiście, gwiazda char jest coś mamy zamiar wrócić do w tydzień lub dwa czasu. 

Ale teraz zobaczmy, czy możemy analizowania słów, które są znane. Rodzaje-- tak słyszeliśmy formatu specifier, kod formatu wcześniej. To znajomy. Type-- ale argument typu int. Chwileczkę, ja to int. 

Może faktycznie procent s ma pewne określone znaczenie. I rzeczywiście tak jest. Liczbą całkowitą, jeśli chcesz printf, aby go zastąpić, rzeczywiście trzeba użyć inny format specyfikatora. I nie będzie o tym wiedzieć chyba że ktoś ci powiedział, albo zrobił to wcześniej. Ale procent i to, co Mogą być powszechnie stosowane w printf dla podłączając całkowitej. Można również użyć procent d dla dziesiętną liczbę całkowitą. Ale jest ładne i proste tutaj. Więc pójdziemy z tym. 

Teraz pozwól mi iść do przodu i powtórka make int, Enter. To dobrze, bez błędów. Dot slash int-- Ok, złe doświadczenia użytkownika, bo nie powiedziałem sobie co zrobić. Ale to jest w porządku. Łapię się szybko. 

A teraz pozwól mi iść do przodu i wpisać Dawida, OK, Zamila Rob. OK, więc jest to dobra rzecz. Tym razem używam funkcji kawałek układanki, zwany get int. I okazuje out-- a my zobaczyć to później w term-- personel CS50 wdrożył się łańcuch w taki sposób, że będzie tylko fizycznie uzyskać ciąg dla Ciebie. 

To wdrożył w get int w taki sposób, że będzie tylko uzyskać całkowitą dla Ciebie. A jeśli, ludzki, nie współpracują, to dosłownie zamiar powiedzieć, ponownie, ponownie, ponownie, dosłownie siedząc tam pętli, dopóki Państwo nakłada się pewną liczbę magiczną, 50, jak i cześć 50. 

Lub jeśli prowadzimy tego ponownie i wpisać 42, hello 42. A więc funkcja get int wewnątrz tego kawałka układanki wystarczy logika, tyle myśli, dowiedzieć się, co to słowo? A co to jest numer? Tylko przyjmując ostatecznie numery. 

Tak więc okazuje się, że to nie jest tak wyrazisty. jak dotąd. Tak, yay, ostatni raz poszło dość szybko do gier wykonawczymi oraz animacji i prace artystyczne w zera. I tu jesteśmy treść z Hello World, i cześć 50. 

To nie wszystko, co inspirujące. I rzeczywiście, te kilka pierwszych przykłady zajmie trochę czasu na ziemi się w podnieceniu. Ale mamy dużo więcej kontrolować teraz, w rzeczywistości. I mamy zamiar bardzo szybko rozpocząć warstw na wierzchu tych podstawowych pierwotnych. 

Ale najpierw niech rozumie jakie są ograniczenia. W istocie, jednym z miejsc Scratch nie łatwo zróbmy to naprawdę wyglądają pod maską i zrozumieć, co komputer, co może zrobić, i jakie są jego ograniczenia. I rzeczywiście, że brak Zrozumienie, potencjalnie długotrwałe może prowadzić do naszego piśmie mistakes-- robaki, pisanie niepewnego oprogramowania dostaje włamał się w jakiś sposób. 

Warto więc podjąć pewne kroki w kierunku Zrozumienie tego trochę lepiej sposób, powiedzmy, następujący przykład. Mam zamiar iść do przodu i wdrożenia bardzo szybko program o nazwie Adder. Jak, dodajmy kilka numerów razem. I mam zamiar kodować kilka narożników tutaj, i po prostu skopiuj i wklej gdzie byłem wcześniej, po prostu więc możemy już iść szybciej. Więc teraz mam podstawowe początki programu zwanego Adder. 

I chodźmy naprzód i to zrobić. Mam zamiar iść do przodu i powiedzmy, intx dostaje się int. I wiesz co? Zróbmy lepsze doświadczenie użytkownika. 

Więc powiedzmy, że x jest i skutecznie poprosi użytkownika, aby dać nam x. I pozwól mi iść dalej i powiedzieć, printf jak o y jest tym razem oczekując Dwie wartości od użytkownika. A potem niech po prostu iść do przodu i powiedzmy, printf, suma x i y jest. A teraz nie chcę robić procent s. Chcę zrobić procent i, odwrotny ukośnik n, a następnie podłącz wartość sumy. 

Więc jak mogę to zabrać? Wiesz co? Wiem, jak używać zmiennych. Niech mi tylko ogłosić nowy, int oo. 

A ja zamierzam zgadywać tutaj. Jeśli istnieją znaki równości w tym języka, może uda mi się po prostu zrobić X plus Y, tak długo, jak kończę pomyślał z średnikiem? Teraz mogę wrócić na dół, podłączyć z, dokończyć tę myśl ze średnikiem. I zobaczmy teraz, jeśli to Sekwencje lines-- x jest uzyskać int. Y jest uzyskać int. 

Dodaj x i y przechowywać wartość w z-- więc znowu pamiętam znak równości nie jest równa. To przyporządkowanie od prawej do lewej. I niech wydrukować, że suma X i Y nie jest dosłownie oo ale to, co jest w środku z. Więc zróbmy Adder - ładne, żadnych błędów i tym razem. Dot slash Adder, wejść, x będzie 1. 

Y będzie 2. A suma xiy wynosi 3. Więc to wszystko jest w porządku i dobre. 

Więc można sobie wyobrazić, że matematyka powinny działać w programie takiego. Ale wiesz co? Czy ta zmienna linia 12, a nawet konieczne? Nie ma potrzeby, aby w zwyczaju po prostu przechowywanie rzeczy w zmiennych tylko dlatego, że jest to możliwe. I rzeczywiście, jest to ogólnie uważane za brak projektowania jeśli tworzysz zmienną o nazwie oo W tym przypadku, przechowywanie w nim coś, a następnie natychmiast używając go, ale nigdy więcej. Dlaczego dać coś nazwę jak z Jeśli jesteś dosłownie zamiar użyć tego rzeczą tylko raz, a więc Bliższy do miejsca, gdzie został utworzony to w pierwszej kolejności tak blisko pod względem linii kodu? Więc wiesz co? Okazuje się, że C jest dość elastyczny. Jeśli rzeczywiście chcesz plug-in wartościami tutaj Nie muszę zadeklarować nową zmienną. Mogłem po prostu plug-in X plus y, bo C rozumie arytmetyczne i operatory matematyczne. 

Więc mogę po prostu powiedzieć, czy ten matematyki, x oraz y, niezależnie od wartości te są podłącz wynikowy całkowita do tego łańcucha. Więc to może być, choć tylko jedna linia krótsza, lepszy design, lepszy program bo jest mniej kodu, więc mniej dla mnie do zrozumienia. I to jest też po prostu czystsze, o ile nie jesteśmy wprowadzanie nowych słów, nowe symbole, takie jak z, choć tak naprawdę nie służyć dużo celów. 

Niestety, nie jest matematyka wszystkie, że wiarygodne czasem. Idziemy naprzód i to zrobić. Mam zamiar iść do przodu teraz i wykonaj następujące czynności. 

Zróbmy printf, Procent I, plus procent I, zostaje procent i, odwrotny ukośnik n. A ja zamierzam zrobić this-- XYX plusa y. Więc jestem po prostu przepisać to nieco inaczej tutaj. Niech mi tylko zrobić szybki test dla pewności. Ponownie, niech nie dostać przed siebie. Bądź adder, kropka ukośnik adder. x oznacza 1, y oznacza 2, 1 plus 2 3. Więc to jest dobre. Ale bądźmy skomplikować to teraz nieco, i utworzyć nowy plik. 

Idę zadzwonić ten jeden, powiedzieć, int, liczba mnoga dla liczb całkowitych. Zacznę gdzie byłem przed chwilą. Ale teraz zróbmy kilka innych linii. Pozwólcie mi iść do przodu i wykonaj następujące czynności, printf, procent i minus procent i, I jest procent, przecinek x, przecinek yx minus y. Więc robię nieco inna matematyka istnieje. Zróbmy jeszcze jeden. Więc procent I czasy procent I jest procent i, odwrotny ukośnik n. Załóżmy, plug-in X i Y, a x razy y. Użyjemy na gwiazdkę komputer dla czasów. 

Nie używać x. x jest nazwa zmiennej tutaj. Za pomocą gwiazdę mnożenia. Zróbmy jeszcze jeden. Printf proc Ja, podzielone w procentach I, procent i, backslash n. xy podzielona przez y-- więc używać ukośnika w C zrobić podział. I zróbmy jeden inny. Pozostała część procentu I, dzieli w procentach I, procent i. xy-- a teraz pozostała to, co pozostało. Przy próbie podzielenie mianownika w liczniku, ile zostało nad tym nie można podzielić na zewnątrz? 

Więc tak naprawdę nie ma, Niekoniecznie, symbol Użyliśmy w szkole za to. Ale nie w C. Można mówią x modulo y, gdzie Ten znak procent w tym context-- złudzenia, gdy jesteś w środku z cudzysłowy, Wewnątrz printf, procent stosowany jest jako specyfikatora formatu. 

Podczas korzystania procent zewnątrz że w wyrażeniu matematycznym to operator modulo dla modularnych arithmetic-- dla naszych celów tutaj, oznacza po prostu, jaka jest Pozostała x podzielona przez y? Więc x jest podzielona przez y x y ukośnik. Co znajduje się pozostała część podzielona przez x y? To x mod y, jako programista powie. 

Więc jeśli nie popełniali błędów tutaj, niech mnie iść do przodu i zrobić int, liczba mnoga, Nicea, i kropka int ukośnikiem. I chodźmy naprzód i zrobić, powiedzmy, 1, 10. Wszystko w porządku, jeden plus 10 jest 11, check. 1 minus 10 jest ujemny 9, sprawdź. 

1 razy 10 to 10, check. 1 podzielone przez 10 is-- OK, będziemy pomiń ten jeden. Pozostała część 1 podzielone przez 10 to 1. To jest poprawne. Ale jest to problem tutaj. 

Więc jeden Kładę przekazać, nie jest prawidłowe. To znaczy, że jest blisko do 0. 1 podzielone przez 10, wiesz, jeśli jesteśmy cięcia niektórych zakątkach, na pewno, to jest zero. Ale to powinno być naprawdę 10/01, 0,1 lub 0,10, 0,1000, i tak dalej. 

To naprawdę nie powinno wynosić zero. Cóż, okazuje się, że komputer jest robi dosłownie co powiedzieliśmy to zrobić. Robimy matematyki jak x podzielona przez y. I oba X i Y, na liniach kodu wcześniej, są liczbami całkowitymi. 

Ponadto, w linii 15, to jest printf mówi, hej, printf plug-in liczbą całkowitą, podłączenie całkowitej, podłączenie integer-- specjalnie X i Y, a następnie x podzielona przez y. x i y są int. Jesteśmy tam dobrze. 

Ale co to jest x dzieli się przez x? podzielone przez x y powinno być, matematycznie, 1/10 lub 0,1, która jest liczbą rzeczywistą, liczba rzeczywista mające potencjalnie punkt dziesiętny. To nie jest liczbą całkowitą. 

Ale to, co jest najbliżej całkowita do 1/10 lub 0,1? Tak, to niby jest zerem. 0.1 jest podobny do tego dużo. I jedno jest to dużo. Tak 1/10 jest bliżej 0, niż to jest do jednego. 

A więc to, co robi dla C us-- rodzaju, ponieważ powiedziano nam go to-- jest obcinanie że całkowitą. To przyjmując wartość, która z kolei jest powinno być coś takiego jak 0.1000, 0 i tak dalej. I to wszystko obcinania po przecinku tak, że wszystko rzeczy, ponieważ nie mieszczą się w pojęciu liczby całkowitej, która jest tylko numer, jak negatywne 1, 0, 1, w górę iw dół, to wyrzuca wszystko po przecinku Bo Nie można dopasować dziesiętny jest liczbą całkowitą z definicji. 

Więc odpowiedź tutaj jest zerem. Jak więc rozwiązać ten problem? Potrzebujemy innego rozwiązania wszystkich razem. I możemy to zrobić w następujący sposób. 

Pozwólcie mi iść do przodu i utworzyć nową Plik ten jeden o nazwie floats.c. I zapisz go tutaj w sam katalog, float.c. I pozwól mi iść do przodu i skopiuj część tego kodu z wcześniej. 

Ale zamiast się int, zróbmy to. Daj mi wartość zmiennoprzecinkową nazywany x. gdzie zmiennoprzecinkowe wartość ta jest po prostu dosłownie coś z zmiennoprzecinkowych. może poruszać się w lewo, w prawo. Jest to liczba rzeczywista. 

I niech nie nazywają uzyskać int, ale się pływak, który również należał do menu opcji w bibliotece C250. Zmieńmy y do pływaka. Więc ta staje się pływak. 

A teraz, nie chcemy podłączyć wskazówki. Okazuje się, musimy użyć procent f dla pływaka, procent f dla pływaka, a teraz go zapisać. A teraz, kciuki, aby pływaki, ładne, kropki pływaki slash. x będzie jeden 1. y Będzie 10 ponownie. 

I miły, OK moja dodatkiem jest prawidłowe. Miałem nadzieję na więcej, ale zapomniałem napisać. Więc chodźmy i naprawić ten błąd logiczny. 

Idziemy do przodu i złapał następuje. Musimy po prostu zrobić trochę skopiować i wkleić. A ja powiem minus. 

A ja powiem razy. A ja powiem podzielone. A ja nie zamierzam zrobić modulo, co nie jest tu germane, podzielony przez F, a czas plus-- OK, zróbmy to jeszcze raz. 

Złóż pływaki, pływaki ukośnik, kropka oraz 1, 10, and-- ładne, no, OK. Więc jestem idiotą. Więc to jest bardzo częste w informatyce aby głupich błędów jak ten. 

Dla celów dydaktycznych, co naprawdę chciał zrobić było zmienić naukę tutaj na plus, minus, do czasów, i dzielić, jak ty z nadzieją Zauważyłem podczas tego ćwiczenia. Więc teraz zróbmy to ponownie skompilować Program, czy kropki pływaków ukośnikiem. 

I po raz trzeci, niech sprawdzić, czy spełnia on moje oczekiwania. 1, 10, wejść, tak, OK, 1,000, podzielona przez 10.000, to 0,100000. I okazuje się, możemy kontrolować, ile Liczby są po tych miejsc po przecinku. My rzeczywiście będzie. Wrócimy do tego. 

Ale teraz, w rzeczywistości, matematyka jest poprawna. Tak więc raz jeszcze, co się tutaj na wynos? Okazuje się, że w C istnieją nie dopiero strings--, w rzeczywistości nie ma tak naprawdę, bo dodać te z biblioteki CS50. Ale to nie tylko int. 

Istnieją również pływa. I okazuje się, kilka innych danych Typy też, że użyjemy niedługo. Okazuje się, że jeśli chcesz pojedynczy charakter, a nie ciąg znaków, można użyć tylko char. 

Okazuje się, że jeśli chcesz bool, wartość logiczna, prawda czy tylko fałszywe, Dzięki bibliotece CS50, mamy dodane do C bool typu danych, jak również. Ale jest również obecny w wiele innych języków, jak również. I okazuje się, że czasami potrzebujemy większych liczb Potem są domyślnie o wskazówki i pływaków. 

I rzeczywiście, podwójny szereg który wykorzystuje nie 32 bity, ale 64 bity. A long long jest liczbą zastosowania nie 32, ale bity 64 bity, odpowiednio dla zmiennoprzecinkowych Wartości i, odpowiednio, liczbami całkowitymi. Więc właściwie teraz zobaczyć w akcji. 

Mam zamiar iść do przodu tutaj i wzbudzać jeden inny program. Tutaj mam zamiar iść do przodu i zawierają CS50.h. I pozwól mi odejść, to standardowy IO.h. 

A zauważysz coś Funky się tutaj dzieje. Nie Kolor kodowania rzeczy w ten sam sposób jak to miało miejsce wcześniej. I okazuje się, że to dlatego, że nie podano Chodzi o nazwę pliku. 

Idę zadzwonić ten jeden sizeof.c i naciśnij Zapisz. I zauważyć, co się dzieje z moim bardzo biały Kod przeciwko tej czarnym tle. Teraz, przynajmniej tam niektóre fioletowy tam. I to jest składnia podświetlona. 

To dlatego, że po prostu, mam powiedział IDE, jaki typ pliku to przez nadanie jej nazwy, a specjalnie rozszerzenie pliku. Teraz chodźmy naprzód i to zrobić. Mam zamiar iść do przodu i bardzo wystarczy wydrukować following-- bool jest procent LU. 

Będziemy wracać do które za chwilę. A potem mam zamiar wielkość druku bool. A teraz, żeby zapisać Sam jakiś czas, jestem zrobi całość Pęczek z nich naraz. A konkretnie, zamierzam zmienić na char i char. Ten jeden, mam zamiar zmienić z podwójnym i podwójne. 

Ten jeden, mam zamiar zmienić do pływaka i pływak. Ten jeden, ja jadę zmienić na int i int. A ten, jadę aby zmienić na długi długi. I to jeszcze biorąc dawno, dawno, dawno. 

A potem wreszcie dałem Sam jeden zbyt wiele, string. Okazuje się, że w C, nie specjalny operator zwany Rozmiar to dosłownie zamiar, po uruchomieniu Poinformuj nas o wielkości każda z tych zmiennych. I to jest droga, a teraz, możemy połączyć z powrotem do zeszłotygodniowej debaty danych i reprezentacji. 

Pozwólcie mi iść do przodu i kompilacji wielkość kropki wielkości cięciem. I zobaczmy. Okazuje się, że w języku C, konkretnie CS50 IDE w szczególności na system operacyjny Ubuntu, który jest operacyjny 64-bitowy system, w tym przypadku, bool będzie używać jeden bajt przestrzeni. W ten sposób wielkość jest mierzona, Nie w bitach, ale w bajtach. I przypomnieć, że jeden bajt to osiem bitów. Więc bool, nawet jeśli technicznie wystarczy 0 lub 1, to trochę marnotrawstwo w jaki sposób zostały wdrożone go. To rzeczywiście zamiar wykorzystać całość byte-- więc wszystkie zera, to może wszystkie z nich, czy coś takiego, czy tylko jeden jeden spośród ośmiu bitów. 

Char tymczasem wykorzystywane do charakteru jak znak ASCII za ostatniego tygodnia będzie jeden znak. I że synchronizuje się z naszym pojęciem przy czym nie więcej niż 256 bits-- raczej synchronizuje się z tym brak jest dłużej niż 8 bitów, które daje nam aż 256 wartości. Podwójny zamierza wynosić 8 bajtów lub 64 bity. 

Pływak jest 4. Int jest 4. Dawno, dawno wynosi 8. I ciąg jest 8. Ale nie martw się o to. Jedziemy do skórki z powrotem tę warstwę. Okazuje się, łańcuchy mogą być dłuższy niż 8 bajtów. 

I rzeczywiście, pisaliśmy już struny, hello world, dłużej niż 8 bajtów. Ale wrócimy do które za chwilę. Ale zabrać tutaj jest następująca. 

Każdy komputer ma tylko skończoną ilość pamięci i przestrzeni. Można przechowywać tylko tyle pliki na komputerze Mac lub PC. Można przechowywać tylko tyle programy RAM działa od razu, niekoniecznie nawet z pamięci wirtualnej, ponieważ masz ograniczoną ilość pamięci RAM. 

A jeśli po prostu picture-- nigdy nie otworzył laptopa lub zamówić dodatkową pamięć na komputerze, może nie wiedzieć, że wewnątrz komputera jest coś, co wygląda trochę jak ten. Więc to jest tylko wspólna firma o nazwie Crucial sprawia, że ​​pamięć RAM dla komputerów. A gdzie programy RAM żyć kiedy są one uruchomione. 

Więc na każdym komputerze Mac lub PC, po dwukrotnym kliknij program, a to otwiera, i otwiera jakiś dokument Word czy coś takiego, przechowuje je tymczasowo RAM, pamięci RAM, ponieważ szybciej niż dysk twardy lub Twój dysku SSD. Więc to jest po prostu gdzie programy przejść żyć, gdy są uruchomione, lub gdy są używane pliki. 

Więc masz rzeczy, które wyglądają jak ten wewnątrz komputera przenośnego, lub nieco większe rzeczy wewnątrz pulpicie. Ale kluczem jest masz tylko skończona liczba tych rzeczy. I nie tylko skończoną ilość wyroby metalowe siedzi na tym biurku w prawo tutaj. 

Tak, na pewno, nie możemy zapisać nieskończenie długie numery. A jednak, jeśli uważasz, że powrót do Szkoła, ile cyfr może trzeba w prawo punktu dziesiętnego? Jeśli o to chodzi, ile cyfr może masz po lewej stronie przecinka dziesiętnego? Naprawdę, nieskończenie wiele. 

Teraz może tylko my ludzie wiesz jak wymówić mln, i miliardy, biliony, a biliardów i trylionów. A ja przesuwanie granic z moich understanding-- lub my-- Rozumiem numery, ale moja wymowa liczb. Ale mogą się nieskończenie duże, nieskończenie wiele cyfr po lewej lub na prawo od kropki dziesiętnej. 

Ale komputery mają tylko skończoną ilość pamięci, skończona liczba tranzystorów, A skończoną ilość żarówek wewnątrz. Więc co się dzieje, gdy zabraknie miejsca? Innymi słowy, jeśli wracam pamięcią do ostatniego tygodnia kiedy rozmawialiśmy o numerach sami są reprezentowane w formacie binarnym, załóżmy, że mamy wartość ta tutaj 8-bitowy. 

I mamy siedem 1 i jednym 0. I przypuśćmy, że chcemy dodać 1 do tej wartości. Jest to bardzo duża liczba teraz. 

To jest 254, jeśli dobrze pamiętam matematyka z ostatniego tygodnia prawo. Ale co, jeśli zmienię że skrajna 0 na 1? Cały szereg, od Oczywiście, staje ośmiu 1-ki. Więc jesteśmy nadal dobre. 

A to zapewne oznacza 255, choć w zależności od kontekstu może faktycznie reprezentują liczbą ujemną. Ale o tym innym razem. To czuje się jak to o tak wysokie, jak mogę liczyć. 

Teraz, to tylko 8 bitów. A mój Mac, z pewnością, ma drogę więcej niż 8 bitów pamięci. Ale to ma skończone. Tak samo argument dotyczy, nawet jeśli więcej tych co na ekranie. 

Ale co się stanie, jeśli jesteś przechowywania tej liczby, 255, i chcesz policzyć jeden nieco wyżej? Chcesz jechać z 255 do 256. Problemem jest oczywiście to, że jeśli rozpocznie odliczanie od zera jak w ubiegłym tygodniu, nie można liczyć tak wysokie jak 256, nie mówiąc już o 257, nie mówiąc już o 258 m, ponieważ to, co dzieje się po dodaniu 1? Jeśli tak stary szkole podstawowej Podejście, umieścić 1 tutaj a następnie 1 plus 1 to 2, ale to naprawdę zero, nosisz 1, nieść 1, przenoszenia 1. Wszystkie te rzeczy, te 1, przejdź do zera. I skończyć tak, jak ktoś, wskazał, a 1 na lewym skrzydle. Ale wszystko można rzeczywiście zobaczyć i zmieścić się w pamięci Zaledwie osiem 0, co jest do powiedzenia W pewnym momencie, gdy ciebie, komputer, Próbowałem licząc wystarczająco wysokie góry, jesteś zamiar owinąć wokół, wydaje się, do zera, a może nawet ujemny Liczby, które są jeszcze niższe niż zero. 

A może my niby to zobaczyć. Pozwólcie mi iść do przodu i pisać prawdziwy szybkie Program tutaj. Pozwólcie mi iść do przodu i pisać program o nazwie przelewowy. Dołącz CS50.h, m.in. średnia IO.h-- oh, Naprawdę brakowało mi podświetlanie składni. Warto więc zapisać to jako overflow.c. 

A teraz int main void-- i wkrótce, będziemy wrócić do wyjaśnienia, dlaczego trzymamy pisanie int main pustkę. Ale teraz Zróbmy go, biorąc za pewnik. Dajmy sobie int, i zainicjować go na 0. 

Załóżmy następnie zrobić dla int i dostać zero-- faktycznie, zróbmy nieskończoną pętlę i zobaczyć, co się dzieje. Chociaż prawdą, to niech wydrukować n jest procent i, odwrotny ukośnik n, plug-in n. Ale teraz, zróbmy n dostaje n oraz 1. 

Tak więc, innymi słowy, na każdej iteracja tej nieskończonej pętli rzućmy wartość n, w i dodać 1 do niego, a następnie zapisać wynik z powrotem w n po lewej stronie. I rzeczywiście, widzieliśmy składni nieco więcej tak krótko. Fajna sztuczka jest natomiast pisać to wszystko na zewnątrz, rzeczywiście można powiedzieć, n oraz równy 1. 

A jeśli naprawdę chcesz być wyobraźnia, można powiedzieć n Plus Plus średnik. Ale te dwa ostatnie są po prostu co my nazywamy cukier syntaktyczny dla pierwszej rzeczy. 

Pierwszą rzeczą jest bardziej wyraźne, całkowicie w porządku, całkowicie poprawne. Ale to jest bardziej powszechne, powiem. Więc zrobimy to za chwilę. 

Załóżmy teraz dokonać przelewu, który brzmi raczej złowieszczo, kropka przepełnienie ukośnik. Zobaczmy, n robi się dość duże. Ale pomyślmy, jak duża może n dostać? 

n jest int. Widzieliśmy przed chwilą z wielkością Przykładem, że int jest cztery bajty. Wiemy z ostatniego tygodnia, to cztery bajty 32 bity, bo 8 razy 4, to 32. To będzie 4 miliardy. 

I jesteśmy do 800.000. To zajmie wieki liczą się tak wysokie, jak to możliwe, bym. Więc mam zamiar iść do przodu, jak może niedługo i uderzył sterowania C- szczerze, kontrola C, dużo, gdzie na ogół sterowania C Środki anulować. Niestety, ponieważ działa w chmurze, Czasami chmura jest wypluwa tyle rzeczy, tyle wyjście, to będzie trochę potrwać do mojego wejścia aby dostać się do chmury. Więc nawet jeśli uderzę Kontrola C kilka sekund temu jest to z pewnością strona efekt nieskończonej pętli. 

I tak w takich przypadkach jesteśmy zamiar opuścić to być. I mamy zamiar dodać kolejne okno terminalu tutaj z plusem, co oczywiście nie tak, ponieważ jest to wciąż myśli. I idziemy do przodu i być trochę bardziej rozsądne. 

Mam zamiar iść do przodu i robić to tylko skończenie wiele razy. Użyjmy pętli for, których wspomniałem wcześniej. Zróbmy to. Daj mi jeszcze jedną zmienną int i pobiera 0. i jest mniejsza niż, powiedzmy, 64 i ++. A teraz pozwól mi iść do przodu i do druku z n jest procent i, przecinek n. A potem to jeszcze n- potrwa wiecznie. Zróbmy to. 

n dostaje n razy 2. Albo moglibyśmy być wyszukane i robić razy równa 2. Ale powiedzmy n równa się sama, razy 2. Innymi słowy, w tym Nowa wersja programu, Nie chcę czekać w nieskończoność z niczym 800000 4 mld. Miejmy tylko z tym skończyć. 

Spójrzmy prawdzie w rzeczywistości dwukrotnie n za każdym razem. Która, przypomnijmy, jest podwojenie Przeciwieństwem konieczności, oczywiście. A podczas ostatniego tygodnia mamy coś znowu, i znowu, i znowu, super szybki, Podwojenie na pewno dostać nam od 1 do możliwie największym wartość, którą możemy liczyć się z int. 

Więc zróbmy to dokładnie. I będziemy wracać do tego niebawem. Ale to znowu jest tak jak powtórzenie bloku w Scratch. I będziesz korzystać z tego niebawem. 

To po prostu oznacza liczbę od zera się, ale nie takie same, do 64. I na każdej iteracji tego Pętla, po prostu zachować inkrementacji i. Więc i ++ - i to ogólna konstrukcja na linii 7 jest po prostu super popularnym sposobem powtarzając niektóre linie kod pewną liczbę razy. Które linie kodu? Te nawiasy klamrowe, jak ty może być zbierana z teraz oznacza, wykonaj następujące czynności. 

Jest w jak Scratch, gdy ma żółte bloki i inne kolory tego rodzaju objęcia lub przytulić innych bloków. To właśnie te kręcone szelki są tu robi. Więc jeśli mam cię moją składnię prawy-- widać symbol marchwi w drodze C to ile razy byłem próby rozwiązania tego problemu. Warto więc pozbyć się tego jednego w ogóle, i zamknąć to okno. I będziemy używać nowego. Dokonaj przelewu, kropka ukośnik przepełnienie, Enter, wszystko w porządku, wygląda źle na początku. Ale bądźmy przewijanie wstecz w czasie, bo zrobił to 64 razy. 

I zauważył po raz pierwszy, n wynosi 1. Drugi raz, n oznacza 2, Następnie 4, a 8, a następnie 16. A wydaje się, że zaraz I dostać się do około 1 mld USD, gdybym podwoić go ponownie, że powinien dać mi 2 mld USD. Ale okazuje się, że to prawo na zakręcie. 

I tak rzeczywiście przelewa int z 1 mld z grubsza ujemna 2 mld, bo liczba całkowita, inaczej niż my liczbach były zakładając w zeszłym tygodniu, mogą być zarówno pozytywne jak i negatywne w rzeczywistości, w komputerze. I tak, co najmniej jeden z tych Bity skutecznie skradziony. Tak naprawdę mamy tylko 31 bitów, lub 2 miliardów możliwych wartości. 

Ale na razie, jest dość wynos wystarczy, cokolwiek te liczby są a co jest matematyka, coś złego dzieje się w końcu, ponieważ w końcu próbujesz permutacji bitów jeden raz za dużo. I skutecznie przejść od wszystkich 1 do może wszystkie na 0, a może po prostu jakiś inny wzór, który to Oczywiście, w zależności od kontekstu może być interpretowana jako wartość ujemna. I tak wydaje się najwyższą I może liczyć w tym konkretnym programem Tylko około 1 mld USD. Ale jest częściowe rozwiązanie tutaj. Wiesz co? 

Pozwól mi zmienić z int do długo długo. I pozwól mi iść dalej tutaj i say-- zamierzam mieć to zmienić na niepodpisany długo. Albo, zobaczmy, nigdy nie pamiętam siebie. 

Idziemy do przodu i zrobić przelew. Nie, to nie o to chodzi, LLD, dziękuję. Więc czasami Clang może być pomocny. Nie pamiętam, co format specifier był przez długi długi. 

Ale rzeczywiście, Clang mi powiedział. Zielony jest jakaś dobra, wciąż oznacza, że ​​popełnił błąd. To domyślając się, że miałem na myśli LLD. 

Więc pozwól mi wziąć to rada, długa długa liczba dziesiętna, z wyjątkiem tego. I pozwól mi ponownie uruchomić go, kropka slash przepełnienie, Enter. A teraz, co jest fajne to jest. 

Gdybym przewijanie wstecz w czasie, nadal zacząć licząc w tym samym place-- 1, 2, 4, 8, 16. Wskazówki, otrzymujemy wszystko aż do 1 miliarda. Ale wtedy możemy bezpiecznie dostać się do 2 mld USD. 

Następnie docieramy do 4 mld euro, Następnie 8 mld, 17 mld USD. I idziemy wyższe, a wyżej i wyżej. W końcu to też przerwy. 

Ostatecznie, z long long, która jest wartością 64-bitową, a nie wartość 32-bitowy, jeśli liczyć zbyt wysokie, owinąć wokół 0. A w tym przypadku stało skończyć z liczby ujemnej. 

Więc jest to problem. I okazuje się, że to Problem nie jest wcale tak zaawansowanych. Choć mam celowo indukowane go z tymi błędami, Okazuje się go widzimy niby wszystko wokół nas, a przynajmniej niektórzy z nas zrobić. 

Tak więc w Lego Star Wars, jeśli kiedykolwiek grałeś w grę, Okazuje się można obejść łamanie rzeczy w świecie LEGO, i zbieranie monet, w istocie. A jeśli kiedykolwiek grałeś Ta gra zbyt wiele czasu, w tej nienazwanej osoby o nie, łączną liczbę monet, które można zbierać jest, jak się wydaje, 4 mld. 

Teraz, wraz z nim faktycznie zaokrąglone. Więc LEGO próbował zachować rzeczy przyjazny dla użytkownika. Oni tego nie zrobił dokładnie 2 do moc 32, za ostatni tydzień. Ale 4000000000 jest powodem. Wydaje się, na podstawie tych informacji, że LEGO, a firma, która wykonany ten rzeczywisty oprogramowanie, postanowił że maksymalna liczba monet użytkownik może gromadzić jest, rzeczywiście, 4000000000, bo wybrali w kodzie Nie używać długo długo, jak widać, ale po prostu liczbą całkowitą, niepodpisany całkowita tylko dodatnia, którego Wartość maksymalna jest grubsza tym. Cóż, oto kolejny zabawny. Więc w cywilizacji gra, która niektórzy z was mogą być zaznajomieni z Okazuje się, że lata temu Był to błąd w tej grze, zgodnie z którą Jeśli grałeś rolę Gandhiego w grze, Zamiast niego jest bardzo pacyfistą, zamiast tego był bardzo, bardzo agresywne, w pewnych okolicznościach. W szczególności, sposób, że cywilizacja Prace, że jeśli gracz, przyjęcia demokracji, twój agresywność wynik dostaje zmniejszana o dwa, więc minus minus, a następnie minus minus. 

Więc odjąć 2 od rzeczywisty iteracji. Niestety, jeśli Iteracja jest Początkowo 1 i odjąć od niej 2 po przyjęciu demokracji jak Gandhi tutaj może zrobili, bo było bardzo passive-- 1 w skali agresywności. Ale jeśli przyjmuje demokrację, a następnie idzie od 1 do negatywnej 1. 

Niestety, były one za pomocą cyfr bez znaku, co oznacza, że ​​traktuje nawet ujemna numery jakby były one pozytywne. I okazuje się, że Pozytywny odpowiednik ujemna 1, w typowych programów komputerowych, jest 255. Więc jeśli Gandhi przyjmuje demokrację, a zatem Wynik jego agresywność spadła, faktycznie rolkach wokół 255 i czyni go najbardziej agresywną postacią w grze. Więc można wygooglować się w tej sprawie. I to było rzeczywiście przypadkowe błąd programowania, ale to weszło dość lore tej pory. 

To wszystko, co zabawne i słodkie. Bardziej przerażające jest, gdy rzeczywista Urządzenia rzeczywistego świata, a nie gry, mają te same błędy. W rzeczywistości, po prostu rok temu artykuł przyszedł się o Boeing 787. 

A artykuł na początku Rzut oka brzmi trochę tajniki. Ale powiedział, oprogramowanie Luka w Boeinga Nowa 787 Dreamliner jet ma potencjał do spowodowania pilotów stracić kontrolę samolot, prawdopodobnie w locie, urzędnicy FAA ostrzegł linie niedawno. To było ustalenie że model 787 Samolot, który został zasilany nieprzerwanie przez 248 dni może stracić wszystko prądu zmiennego AC, Moc elektryczna w związku z generatora Jednostki sterujące, GCUs jednocześnie nie wchodząc w tryb awaryjny. To coś w rodzaju utraty mnie. Ale notatka stwierdził, OK, teraz mam, że warunek został spowodowany przez oprogramowanie przeciwdziałać wewnętrznego sterowanie generatorem Jednostki, które wyleje się po 248 dni ciągłej mocy. Jesteśmy wydawania tego UWAGA Aby zapobiec utracie wszystkim AC elektryczne zasilanie, co mogłoby spowodować utratę kontroli nad samolotem. 

Tak więc, dosłownie istnieje pewna liczba całkowita lub jakiś odpowiednik typ danych, wykorzystywane w oprogramowaniu w rzeczywistym samolocie że jeśli utrzymać samolot na tyle długo, co najwidoczniej może być w przypadku, jeśli jesteś po prostu działa je nieustannie i nigdy nie odłączając Twój samolot, jak się wydaje, albo pozwalając jej baterie umrzeć w końcu liczy się i do góry i do góry i do góry i do góry i do góry. 

A przy natury, skończoną ilość pamięci wyleje, wycofywanie się zero lub niektóre ujemna wartość, efektem ubocznym, który jest przerażająco prawdziwa rzeczywistość że samolot może być konieczne zostać uruchomiony ponownie, skutecznie, lub może spaść, co gorsza, jak leci. Więc tego rodzaju problemów nadal są z nami, even-- było to 2015 artykuł Tym bardziej przerażające kiedy nie koniecznie zrozumienie, docenienie, czy przewidywania te rodzaje błędów. 

Tak więc okazuje się, jest jeszcze jedna Źle o reprezentacji danych. Okazuje się, że nawet pływaki są rodzaj wadliwa, ponieważ pływa też Zaproponowałem są 32 bity lub może 64 jeśli używasz podwójne. Ale to jeszcze skończona. 

I połów jest to, że jeśli potrafisz umieścić nieskończoną ilość numerów po przecinku, Nie ma sposób może reprezentować wszystkie możliwe Liczby, które były nauczane w szkole może istnieć w świecie. Komputer w istocie, musi wybrać podzbiór tych numerów reprezentować dokładnie. 

Teraz komputer może okrągłe może trochę, i może zezwolić na około sklepie dowolna liczba może chcieć. Ale tylko intuicyjnie, jeśli ciebie mają skończoną liczbę bitów, można je tylko permutacji na tak wiele sposobów skończonych. Więc nie można ewentualnie operują na liczbach skończonych permutacji bitów, wzory zer i jedynek, do reprezentowania nieskończona Liczba numerów, co sugeruje, że komputery mogą bardzo dobrze leżeć nam czasem. 

W rzeczywistości, zróbmy to. Pozwól mi wrócić do CS50 IDE. Pozwólcie mi iść do przodu i stworzyć mały program nazywa Nieprecyzyjność, aby pokazać, że komputery są rzeczywiście niedokładne. 

I pozwól mi iść do przodu i zacząć część tego kodu z wcześniej a teraz po prostu wykonaj następujące czynności. Pozwólcie mi iść do przodu i zrobić printf procent f, backslash n, 1 dzieli się przez 10. Innymi słowy, niech nurkować głębiej 1/10, podobnie jak 1 i dzieli się przez 10. Z pewnością, komputer może stanowić 1/10. 

Więc idź naprzód i dokonać niedokładności. Zobaczmy. Format określa typ double. Ale argument typu int. Co się dzieje? 

Och, interesujący, więc jest to lekcja sprzed. Mówię, hej, komputer pokaż mi pływak z procentami f. Ale daję mu 2 ints. Tak więc okazuje się, można to naprawić to na kilka sposobów. 

może po prostu włączyć jeden do 1,0, a 10 do 10,0, co rzeczywiście mają wpływ na konwersję je pod floats-- wciąż z nadzieją ten sam numer. A okazuje się, że coś zobaczymy ponownie przed długo. Można oddać numery. 

Można za pomocą tego nawias Wyrażenie, można powiedzieć, hej, komputer, weź to 10, co wiem, jest int. Ale traktować go, proszę, jakby to pływak. Ale to czuje się niepotrzebnie skomplikowane. 

Dla naszych celów dzisiaj niech po prostu dosłownie umożliwiają ich zmiennoprzecinkowych z przecinkiem, jak ten. Pozwólcie mi iść do przodu i ponownie, aby nieścisłości, dobry, kropka ukośnik nieścisłości, enter. OK, jesteśmy dobrze wyglądać. 

1 podzielone przez 10, zgodnie z moim Mac tu jest, rzeczywiście, 0,100000. Teraz, uczono mnie w szkole nie powinna być nieskończona liczba 0-tych. Warto więc przynajmniej spróbować aby zobaczyć niektóre z nich. Okazuje się, że jest trochę printf hodowcy wciąż nie używaliśmy. Okazuje się, że nie trzeba określać po prostu procent f, lub po prostu procent i. Rzeczywiście można określić Niektóre opcje tutaj kontrolne. 

Konkretnie, jadę powiedzieć, hej, printf, faktycznie pokazują mi 10 miejsc po przecinku. Tak to wygląda trochę dziwnie. Ale mówisz procent, Kropka, ile numerów chcesz zobaczyć po punkt dziesiętny, a następnie f do mieszkania, tylko dlatego, że co mówi dokumentacja. Pozwólcie mi iść do przodu i zapisz to. 

I zauważ też, Dostaję zmęczony przepisywania rzeczy. Więc ja tylko ustanowienie i strzałka w dół na moje klucze tutaj. A jeśli wciąż uderzając w górę, Można zobaczyć wszystkie polecenia że zrobiłem, lub nieprawidłowo wykonane. 

I zamierzam iść do przodu i teraz faktycznie nie używać, że widocznie. Bądź niedokładności, kropka slash imprecision-- tak czego uczono mnie w Szkoła sprawdza. Nawet gdybym je drukować do 10 po przecinku umieszcza go rzeczywiście jest 0,10000. Ale wiesz co? 

Chodźmy trochę chciwy. Powiedzmy, na przykład, pokaż mi 55 wskazuje po przecinku. Załóżmy, naprawdę wziąć to zaprogramować się na przejażdżkę. Pozwól mi przerobić go z make nieścisłości, kropka ukośnik, nieścisłości. 

I jedziemy. Twoje dzieciństwo było kłamstwem. Wydaje się, że 1 podzielone przez 10 rzeczywiście 0.100000000000000005551115123-- 

Co się dzieje? Cóż, jak się okazuje, jeśli rodzaj spojrzeć na tyle daleko w bazowy reprezentacja tego liczba, to faktycznie nie jest dokładnie 1/10 lub 0,1 nieskończenie wiele zer. Teraz, dlaczego tak jest? 

Cóż, nawet jeśli jest to proste Numer do nas ludzi, 1 dzieli się przez 10, to wciąż jeden z nieskończenie wiele Liczby, które moglibyśmy wymyślić. Ale może stanowić tylko komputer skończenie wiele tak numery. I tak skutecznie, co Komputer pokazuje nam jest jego najbliższym przybliżeniem do liczby chcemy wierzyć jest 1/10, czy naprawdę 0,10000 ad infinitum. 

Przeciwnie, jednak, to jest tak blisko, jak można dostać. I rzeczywiście, jeśli spojrzeć pod maską jak tu jesteśmy, patrząc 55 cyfr po przecinku, faktycznie zobaczyć, że rzeczywistość. Teraz tak na marginesie, jeśli masz kiedykolwiek widział movie-- Większość z was zapewne haven't-- jednak Superman 3 laty, Richard Pryor zasadniczo wykorzystała tę Rzeczywistość w jego towarzystwie ukraść dużo frakcji i ułamkach grosze, ponieważ company-- ile pamiętam, to było while-- był zasadniczo wyrzucać wszystko, co nie pasuje pod pojęciem centów. 

Ale jeśli dodać do tych wszystkich malutkie, malutkie, malutkie numery znowu, i znowu, i znowu, można, jak w jego sprawa, zrobić dobre kwotę pieniędzy. 

Ten sam pomysł został oszukany przez nowsza, ale teraz starszy Film o nazwie Office Space, gdzie faceci w tym filmie, zrobił to samo, wkręca go całkowicie, skończyło się tak za dużo pieniądze na koncie bankowym. To wszystko było bardzo podejrzane. A na koniec dnia niedokładność jest wszędzie wokół nas. 

I tak też może być przerażająco sprawę. Okazuje się, że Superman 3 i biurowe na bok, istnieje może być jakaś bardzo realne konsekwencje świata realiów nieprecyzyjne przedstawieniem danych że nawet my, ludzie, do Ten dzień nie koniecznie zrozumieć, jak powinniśmy, czy zapamiętać tak często, jak powinniśmy. I rzeczywiście, poniższy klip jest od spojrzeć na niektóre bardzo realnym świecie Konsekwencje tego, co się dzieje, jeśli nie doceniają, że niedokładności może się zdarzyć w reprezentacji liczb. 

[ODTWARZANIE] 

-Computers, My wszyscy przychodzą do zaakceptowania często frustrujące problemy iść z them-- robaki, wirusy, i usterki oprogramowania, dla małych ceny do zapłaty dla wygody. Ale w zaawansowanej technologii i wysokiej prędkości zastosowania militarne i programu kosmicznego, najmniejszy problem może zostać powiększony do katastrofy. 

W dniu 4 czerwca 1996 roku, naukowcy przygotowane uruchomienie bezzałogowy Ariane 5 rakietę. To niósł naukowe satelity zaprojektowane ustalić dokładnie, w jaki sposób Pole magnetyczne oddziałuje Ziemi z wiatrów słonecznych. Rakieta została zbudowana na Europejska Agencja Kosmiczna, i podniósł się ze swojego zakładu na wybrzeżu Gujany Francuskiej. 

-Na Około 37 sekund na język lot, po raz pierwszy Zauważyłem coś się dzieje źle. Dysze obrotowe zostały w sposób tak naprawdę nie powinno. Około 40 sekundach lotu, Oczywiste jest, że pojazd był w tarapatach. 

I wtedy zrobili decyzja, aby je zniszczyć. Oficer bezpieczeństwa zasięg, z olbrzymie wnętrzności, nacisnął guzik, wysadzili rakietę, zanim będzie mógł stanowić zagrożenie dla bezpieczeństwa publicznego. 

-To Było panieńskie wyprawa na Ariane 5. A jego zniszczenie trwało miejsce ze względu na wadę wbudowane w oprogramowanie rakiety. -The Problem na Ariane był że nie był to numer Wymagane 64 bity wyrazić. I chcieli przekształcić go na liczbę 16-bitową. Zakładali oni, że Numer nie szło być bardzo duże, że większość z tych, cyfry w szeregu 64-bitowe są zerami. Mylili się. 

-The Niezdolność jednego program do zaakceptowania rodzaj liczby generowane przez inna była u podstaw niepowodzenia. Rozwój oprogramowania stał się bardzo kosztowne częścią nowej technologii. Rakieta Ariane były bardzo sukces, tak oprogramowania stworzony przez to także stosowane w Ariane 5. 

-The Podstawowym problemem było to, że Ariane 5 był szybszy, przyspieszone szybciej. I oprogramowanie nie miał stanowiły, że. 

-The Zniszczenie rakiety była ogromna katastrofa finansowa, Wszystko z powodu błędu oprogramowania minut. Ale to nie był pierwszy Problemy konwersji danych czasowych był nękany nowoczesną technologię rakietową. 

-W 1991, przy starcie pierwszej wojny w Zatoce, Patriot Missile doświadczył podobnego rodzaju problem konwersji liczby. I w rezultacie, 28 osób, 28 amerykańskich żołnierzy, zginęło, a około 100 rannych, gdy Patriot, która miała w celu ochrony przed przychodzących scuds, udało się wystrzelić pocisk. 

-Gdy Irak najechał na Kuwejt i Ameryce rozpoczęła Pustynna Burza na początku 1991 roku, baterie rakiet Patriot zostały rozmieszczone do ochrony Arabii Saudyjskiej i Izraela z irackich rakiet Scud ataków. Patriot jest amerykańskim średniego zasięgu Powierzchnia do systemu powietrznego, wyprodukowany przez firmę Raytheon. 

-The Wielkość przechwytujących Patriot Sam jest o około 20 stóp długości. I waży około 2000 funtów. A to niesie głowicę około, Myślę, że to mniej więcej 150 funtów. A sama głowica jest wysoki wybuchowa, która zawiera fragmenty wokół niego. Obudowa głowicy ma zaprojektowane tak, aby działać jak śrutem. 

-The Pociski są prowadzone cztery za kontener, i są transportowane przez naczepy. 

-The System Patriot antyrakietowa sięga co najmniej 20 lat. Pierwotnie był on przeznaczony jako rakiet obrony powietrznej zestrzelić samoloty wroga. W pierwszej wojny w Zatoce, gdy przyszła wojna wraz, Armia chciała użyć go do zestrzelić scuds, a nie samoloty. 

Irackie lotnictwo było nie jest tak wielkim problemem. Ale armia martwi scuds. I tak próbowali uaktualnić patriotą. 

-Intercepting Wroga pocisk porusza się Mach 5 miał być wystarczająco trudne. Ale kiedy Patriot został przewieziony do użytku, Armia nie było świadome Iracki modyfikacje, które wykonane ich scuds prawie niemożliwe do trafienia. 

-Co Się stało, że jest scuds wchodzili były niestabilne. Zostali chwieje. Powodem tego było Irakijczycy, aby dostać 600 kilometrów z 300 kilometr Przedział rakiet, wziął ciężar z przodu głowicy. Zrobili głowica lżejsze. 

Więc teraz jest Patriot starając się przyjść na Scud. I większość czasu, Przeważająca większość czasu, byłoby to po prostu latać przez Scud. Po operatorów systemów Patriot realizowane Patriot chybiła celu, oni zdetonował głowicę Patriota za aby uniknąć ewentualnych strat jeśli to pozwolono upaść na ziemię. 

-To Było to, co większość ludzi widziało, te wielkie kule ognia na niebie, i tak źle przechwytuje głowic Scud. 

-Mimo W nocy nieba, pojawiła Patriots być z powodzeniem niszcząc Scuds na Dhahran, nie mogło być mowy o pomyłce o jego wydajności. Tam, system radarowy Patriota za straciłem przychodzących Scud, i nigdy nie rozpoczęła ze względu do wada oprogramowania. Było Izraelczyków, którzy po raz pierwszy odkryta że już system został włączony, im większa jest różnica czasu się, ze względu na dobę osadzony w komputerze systemu. 

-O Dwa tygodnie przed tragedia w Dhahran, Izraelczycy zgłaszane Departament Obrony że system tracił czasu. Po około ośmiu godzinach lub biegania, zauważyli, że system stawało się znacznie mniej dokładne. Departament Obrony odpowiedział informując wszystkich baterii Patriot aby nie pozostawić systemy od dłuższego czasu. Nigdy nie powiedział, co dawno was-- osiem godzin, 10 godzin, 1000 godzin. Nikt nie wiedział. 

-The Baterii Patriot stacjonował w koszarach w Dhahran i jego wadliwe wewnętrzne Zegar był na ponad 100 godzin w nocy z 25 lutego. 

-To Śledzone czasu z dokładnością około jednej dziesiątej sekundy. Teraz jedna dziesiąta sekundy Jest to ciekawy numer, ponieważ nie może być wyrażona binarnie dokładnie, co oznacza, że ​​nie może być dokładnie wyrażony w każdym nowoczesnym komputerze cyfrowym. Trudno w to uwierzyć. 

Jednak wykorzystać jako przykład. Weźmy liczbę jedną trzecią. Jedna trzecia nie może być wyrażoną w postaci dziesiętnej dokładnie. Jedna trzecia jest 0,333 trwa od nieskończoności. 

Nie ma sposobu, aby to zrobić z dokładność w systemie dziesiętnym. To jest dokładnie ten rodzaj problemu które miało miejsce w Patriot. Im dłużej system ran, The gorszy błąd czasu stał. 

-Po 100 godzin pracy, Błąd w czasie tylko około jednej trzeciej sekundy. Jednak jeśli chodzi o ukierunkowanych na pocisk porusza się Mach 5, Wynikało to w śledzeniu Błąd z ponad 600 metrów. Byłby to błąd krytyczny dla żołnierzy na tym, co stało to było uruchomienie Scud wykryte przez satelity wczesnego ostrzegania i wiedzieli, że był Scud nadchodzi w ich ogólnym kierunku. Nie wiem, gdzie to nastąpi. 

-To Był już do radaru Składnik systemu Patriot broniąc Dhahran do zlokalizowania i utrzymać utwór z nadchodzącego wroga pocisków. 

-The Radar był bardzo inteligentny. Byłoby to rzeczywiście śledzić pozycja Scud, a następnie przewidzieć, gdzie prawdopodobnie będzie następnym razem radar wysłany Impuls na zewnątrz. To był nazywany bramą zasięgu. 

-Więc Po Patriot postanawia ma wystarczająco dużo czasu, przeszedł wrócić i sprawdzić następny lokalizacja dla tego wykrytego obiektu, wraca. Więc kiedy wrócił do złego miejsce, to wtedy nie widzi obiekt. I postanawia, że ​​nie ma Celem było fałszywe wykrywanie, i traci utwór. 

-The Przychodzące Scud zniknął z ekranu radaru. I sekund później, uderzył w koszarach. Scud zginęło 28, a był to ostatni jeden zwolniony podczas pierwszej wojny w Zatoce. 

Niestety, uaktualnione oprogramowanie Dhahran przybył następnego dnia. Błąd oprogramowania miał ustalono, zamknięcie jeden rozdział w niespokojnych Historia rakiet Patriot. 

[ODTWARZANIE] David J. MALAN: Więc to wszystko powiedzieć, że te kwestie przepełnienia i precyzji są zbyt realne. Więc jak się tu dostaliśmy? Zaczęliśmy tylko mówić o printf. Ponownie, to funkcja wypisuje coś na ekranie, a następnie wprowadziliśmy kilka innych funkcji z tak zwaną bibliotekę CS50 jest. A my nadal zobacz je w odpowiednim czasie. A my, zwłaszcza stosowane pobiera ciąg znaków, i uzyskać int, a teraz również uzyskać pływaka, a jeszcze inni będą nadal mamy do czynienia i używać się przed długi. 

Ale przy okazji, mają mamy już widział potrzebę do przechowywania, co te funkcje ręcznie z powrotem? Oni nas z powrotem ręcznie ciągiem znaków, lub int lub float. A czasami musimy umieścić, że ciąg lub int lub float, gdzieś. 

Oraz przechowywanie tych rzeczy, po prostu pamiętam jak w Scratch mamy zmienne. Ale w odróżnieniu od zera, w C mamy rzeczywiste typy z variables-- danych Typy, więcej generally-- Wśród nich, ciąg, int, A float, a te jeszcze inni. 

A więc kiedy deklarowania zmiennych w języku C, musimy zadeklarować nasze typy danych. To nie jest coś, czego będziesz trzeba zrobić jeszcze w tym semestrze jak przejść do innych języków. Ale na razie musimy by a priori z góry, wyjaśnić, jaki rodzaj komputera zmiennej chcemy, aby nam dać. 

Teraz, w międzyczasie, aby wydrukować te rodzaje typów danych, musimy powiedzieć printf czego się spodziewać. I widzieliśmy procent S strun, oraz procent i dla liczb całkowitych, i kilka innych już. A ci są po prostu wymogi do prezentacji wizualnej tych informacji. 

I każdy z nich może być w rzeczywistości parametryzowane lub manipulowane w jakiś sposób, jeśli chcesz dalszej kontroli rodzaj produkcji, które można uzyskać. I w rzeczywistości okazuje się, że nie tylko tam jest odwrotny ukośnik n dla nowej linii. Jest jeszcze coś o nazwie backslash r do powrotu karetki, która jest bardziej zbliżona do Stare maszyny do pisania szkoła, a także system Windows używany przez wiele lat. 

Jest backslash t na kartach. Okazuje się, że jeśli chcesz cudzysłów wewnątrz łańcucha, Przypomnijmy, że używaliśmy cudzysłów podwójny cytat na lewo i prawo kończy nasze struny do tej pory. To wydaje się mylić rzeczy. 

Jeśli chcesz umieścić w podwójny cudzysłów środku string--, a nawet to jest kłopotliwe, aby zobaczyć. A więc trzeba się uciekać, by tak niejako podwójny cudzysłów z czymś jak, dosłownie, odwrotnego ukośnika podwójny cudzysłów. I jest jeszcze kilka innych. I zobaczymy więcej osób w rzeczywistym użytkowaniu przed długie. 

Więc teraz przejście od Dane i reprezentacji, oraz operatory arytmetyczne, wszystkie którego dał nam jakiś budynek bloki z którego można odtworzyć. Ale teraz niech faktycznie dają nam reszta słownictwa że już w zeszłym tygodniu z Scratch przez przyjrzeniu się jakaś inna konstrukty w C- nie wszystkie z nich. Ale idee jesteśmy by zobaczyć tak naprawdę podkreślić tłumaczenie z jeden język, Scratch, do drugiego, C. 

I w miarę upływu czasu, będziemy pick up więcej narzędzi do naszego zestawu narzędzi, by tak rzec, składniowo. I rzeczywiście, zobaczysz, że idee Teraz raczej zaznajomieni z ostatniego tygodnia. Więc zróbmy to. 

Idziemy do przodu i wzbudzać program który faktycznie korzysta z niektórych wyrażeń, logiczna wypowiedzi. Pozwólcie mi iść do przodu tutaj i utworzyć nowy plik. Zadzwonię do tej condition.c. 

Pozwólcie mi iść do przodu i obejmują bibliotekę CS50. I pozwól mi iść dalej i obejmują średnia io.h dla naszych funkcji i printf i bardziej odpowiednio. Podam sobie tego kotła z int main nieważne, którego wyjaśnienie we''ll wrócić w przyszłości. 

Teraz pozwól mi iść do przodu i dać Sam int poprzez get int. Pozwól mi iść naprzód i to zrobić. Chcę powiedzieć, czy ja to less-- niech rozróżnić pozytywne, negatywne, lub wartości zerowe. 

Więc jeśli jest mniejsza niż zero, niech mnie po prostu ten program po prostu powiedzieć, ujemna, backslash n, w przeciwnym wypadku jeśli i jest większe niż zero. Teraz ja, oczywiście, powie printf pozytywne, ukośnika n. A potem jeszcze if-- mógłbym to zrobić. 

mogę zrobić, jeśli jest równa 0. Ale będę decyzji na co najmniej jeden błąd już. Przypomnijmy, że znak jest równa nie równe, jak my, ludzie o tym wiedzą. 

Ale to operator przypisania. A my nie chcemy brać 0 Na prawo i umieścić go w i po lewej stronie. Tak więc, aby uniknąć tego zamieszania, lub Może nadużycia znaku równości, ludzie postanowili kilka lat temu że w wielu językach programowania jeśli chcesz sprawdzić na rzecz równości między lewą i prawa, faktycznie korzysta równa równych. Więc trafisz znak równości dwukrotnie. Gdy chcesz przypisać od prawej do lewej, należy użyć jeden znak równości. Tak więc możemy zrobić this-- indziej jeśli i równa jest równa zeru. 

Mógłbym wtedy iść i Otwieram nawiasy klamrowe, i powiedzieć, printf 0, backslash n, zrobione. Ale pamiętam, jak to widły na drodze może pracować. I, naprawdę, tylko myśleć o logice. I jest liczbą. To jest liczbą całkowitą, a konkretnie. A to oznacza, że ​​będzie mniej niż 0 lub większa niż 0 lub 0. Więc nie jest to rodzaj implikowana domyślny przypadek. 

I tak możemy, podobnie jak Scratch, zrezygnować z else if, i po prostu powiedzieć indziej. Logicznie rzecz biorąc, jeśli jesteś programista wie, że jest tylko trzy wiadra do którego Scenariusz może fall-- pierwszego, drugi, lub trzeci w case-- ta nie przeszkadza dodając dodatkową precyzję a dodatkowa logika tam. Wystarczy iść do przodu z Domyślnym przypadek tu jeszcze. 

Teraz idziemy do przodu Po zapisaniu tego dokonać Warunki dot slash conditions-- Nie wielki interfejs użytkownika, Ponieważ nie jestem monitowania użytkownika, jak już wspomniano wcześniej. Ale to jest w porządku. Będziemy keep it simple. Spróbujmy numer 42. I to jest pozytywne. Spróbujmy numer ujemny 42, ujemny. 

Spróbujmy wartość 0. I rzeczywiście, to działa. Teraz zobaczysz z problemami przed długie, badawcze warte trzy razy, zapewne nie wystarcza. Prawdopodobnie chcesz przetestować niektóre numery większe, niektóre mniejsze numery, w niektórych przypadkach, jak narożniki będziemy się je opisać. 

Ale na razie, jest to dość prosty program. I jestem całkiem pewny, logicznie, że składa się z trzech przypadkach. I rzeczywiście, mimo że po prostu koncentruje się na potencjalnych wad niedokładności i przepełnienie w rzeczywistość, gdzie wiele problemów CS50, w nie będziemy się martwić o, cały czas, te kwestie przepełnienia i niedokładność, ponieważ w rzeczywistości, w ° C, to nie jest właściwie wszystko, łatwo uniknąć tych rzeczy. Jeśli chcesz się liczyć większy i większy i większy, okazuje się, istnieją techniki wy Można go wykorzystać, często z udziałem rzeczy zwanych biblioteki, zbiory Kodeksu, inni napisali, że można użyć, i inne języki, takie jak Java i innych, w rzeczywistości sprawiają, że o wiele łatwiej liczyć nawet wyższe. Więc tak naprawdę to niektóre z tych zagrożeń funkcją używanego języka. A w ciągu najbliższych tygodni, będziemy zobacz jak naprawdę niebezpieczny C może być, jeśli nie używasz go prawidłowo. Ale stamtąd, a także z Python i JavaScript będzie mamy warstwę na jakieś dodatkowe zabezpieczenia, i uruchomić mniej z tych zagrożeń. 

Więc zróbmy trochę bardziej ciekawe logiki w naszym programie. Więc pozwól mi iść dalej i stworzyć program o nazwie Logical tak więc mogę grać z niektórymi Rzeczywista logika logical.c. Ja po prostu skopiować i wkleić niektóre Kod z wcześniej, więc wrócę do tego miły punkt wyjścia. 

Daj mi ten czas zrobić char C. jestem zamiar dać mu nazwę od C tylko dlatego, że konwencjonalne, uzyskać znak z użytkownikiem. I niech udawać Jestem wykonawczych udział tego programu RM, usuwania, Program wcześniej skłoniły użytkownika aby usunąć plik. Jak możemy to zrobić? 

Chcę powiedzieć, że jeśli C jest równa równa, cytat cytatu, y, to mam zamiar założyć, że użytkownik wybrał tak. Idę do wydrukowania tak. Jeśli to rzeczywiście pisanie program do usuwania, możemy usunąć plik z kilku linii kodu. Ale my keep it simple. 

Else if c równa równa n- a teraz mam zamiar powiedzieć, użytkownik musi mieć na myśli nie ma. A potem jeszcze, wiesz co? Nie wiem, co jeszcze użytkownik ma zamiar pisać. Więc ja po prostu powiedzieć, że że jest to błąd, niezależnie od on lub ona rzeczywiście wpisane. 

Więc co tu się dzieje? Istnieje zasadnicza różnica w porównaniu do tego, co robiłem w przeszłości. Podwójne cudzysłowy, podwójne, podwójne cudzysłowy cytaty, a jednak pojedyncze cytaty, pojedyncze cudzysłowy. Okazuje się, w C, który po chcesz napisać ciąg, używasz cudzysłowów, tak jak mamy był używany przez cały ten czas z printf. 

Ale jeśli chcemy mieć do czynienia z zaledwie pojedynczy znak, tzw char, wtedy faktycznie używać apostrofów. Ci z was, którzy już zaprogramowany wcześniej, nie może mieć musiał się o to martwić wyróżnienie w niektórych językach. W C, to bez znaczenia. A więc kiedy dostanę char i chcę porównać ten char użyciu równych równa się do pewnego listu jak Y lub N, ja, Rzeczywiście, trzeba mieć apostrofów. 

Teraz chodźmy naprzód i to zrobić. Idziemy do przodu i rób Dot logiczne slash logiczne. A teraz mam potwierdzeniu. Tak, przypuszczalnie, lepsze doświadczenie użytkownika faktycznie mi powiedzieć, co tu robić. Ale będę ślepo powiedzieć, y na tak, OK, miły. 

Załóżmy, uruchom go ponownie, n na nie, miły. Załóżmy, jak niektórych ludzi, których znam, moi caps lock key jest zbyt często. Więc robię kapitał Y, wejść, błąd. OK, nie jest to dokładnie to, czego oczekuję. Rzeczywiście, komputer robi dosłownie co Powiedziałem jej do-- sprawdzić małe litery Y i małe litery n. To nie ma ochoty na dobre user experience, choć. Pozwól mi poprosić i zaakceptować albo małymi literami lub wielkimi literami. Tak więc okazuje się, warto powiedzieć coś jak w Scratch, jak dosłownie lub C jest równa równa kapitału apostrofami y. Okazuje się, C nie ma to dosłowne słowo kluczowe lub. 

Ale ma dwie pionowe paski. Musisz przytrzymać klawisz Shift zwykle jeśli używasz klawiatury USA, i uderzył w pionowy pasek klawisz nad klucza powrotnej. Ale to pionowy pasek Pionowa kreska oznacza albo. 

Jeśli, przeciwnie, chcieliśmy powiedzieć i jak się podstaw, mogliśmy zrobić ampersand ampersanda. To nie ma logicznego sensu tutaj ponieważ człowiek nie mógłby ewentualnie zostało wpisane zarówno y i małe litery Y i kapitał Y jako ten sam charakter. Więc czy jest to, co chcemy tutaj. 

Więc jeśli zrobić to w obu tych miejscach lub C kapitału równa równa N, teraz ponownie uruchomić, make logiczne, uruchom logiczne. Teraz mogę wpisać y. I mogę to zrobić ponownie Kapitał Y lub N. kapitału I mógłbym dodać dodatkowe Kombinacje martwych. 

Więc to jest logiczne Program w jakim teraz Mam do sprawdzenia logicznego Ta wartość lub wartość. I nie trzeba koniecznie, pochodzić z dwóch kolejnych ifs albo IFS. Mogę właściwie połączyć niektóre z związanych z logiką ze sobą w ten sposób. Więc to byłoby lepiej zaprojektowane niż zwykłe mówiąc, jeśli C jest równa małą y, wydrukować tak, else if c równa kapitałowej Y, wydrukować tak, else if c jest równa lower-- innymi słowy nie musisz mieć Coraz więcej oddziałów. Można połączyć niektóre równowartości gałęzie logicznie jak w ten sposób. 

Warto więc przyjrzeć się tylko jedna Ostateczna składnik, jeden ostateczny konstrukt, że C pozwala. I wrócimy w przyszłość dla innych martwych. A potem możemy stwierdzić, patrząc co nie poprawności code-- uzyskanie kodu do work-- ale projekt kodu, a nasiona tych roślin wcześnie. 

Więc pozwól mi iść do przodu i otwiera nowy plik tutaj. Wiesz co? Idę do ponownego wdrożenia że sam program, ale stosując inną konstrukcję. 

Więc pozwól mi szybko oddać Dostęp do włączenia CS50.h dla biblioteki CS50, średnia io.h dla printf. Daj mi int main pustkę. A potem tu, niech mi iść naprzód i to zrobić. 

Char c dostaje się char, tak samo jak przedtem. A ja zamierzam wykorzystać nowy konstrukt now-- przełączyć, na jakiej postaci? Więc przełącznik jest tak jakby Przełączanie torach kolejowych. Albo, naprawdę, jest to rodzaj if else, jeśli else if, ale napisany nieco inaczej. 

Przełącznik wygląda następująco. Masz przełącznik, a następnie co znak lub numer, który chcesz patrzeć, Następnie niektóre nawiasy klamrowe jak w Scratch, wystarczy powiedzieć, robić te rzeczy. A potem mają różne przypadki. 

Nie używać, jeśli i inni. Dosłownie użyć obudowy słowo. I można by powiedzieć coś takiego. 

Tak więc w przypadku małej litery Y, lub w przypadku dużej litery Y iść do przodu i wydrukować tak. A potem wyrwać się z przełącznika. to jest to! Skończyliśmy. 

Else if, że tak powiem, mała litera N, N lub kapitału, a następnie przejść do przodu i do druku na nie, a następnie zerwać. Else-- a tego rodzaju jest Domyślnym przypadku indeed-- printf error-- i po prostu na wszelki wypadek, gdyby logicznie przerwa ta nie jest konieczna dlatego, że jesteśmy na końcu przełącznika i tak, Jestem teraz wyrwanie się z przełącznika. Tak to wygląda trochę inaczej. 

Ale logicznie, to rzeczywiście równoważne. I dlatego należałoby użyć jeden nad drugim? Czasami, po prostu osobistych preferencji, czasami estetyka, jeśli Spoglądam na to Teraz, coś należy powiedzieć o czytelność tego kodu. To znaczy, nie przeszkadza fakt, że ten Kod jest nowością dla wielu z nas w pokoju. 

Ale to właśnie niby jest ładna. Widzisz mała litera Y, Y kapitału, mała litera n, domyślnie kapitału N, to po prostu rodzaj skoków się na siebie w taki sposób, , Która prawdopodobnie, być może W poprzednim przykładzie z IFS i pionowych prętów, oraz IFS indziej, może nie mieć. Więc to jest naprawdę kwestia osobista wybór, tak naprawdę, czy czytelność, kodu. 

Ale jeśli chodzi o funkcjonalność, pozwól mi iść dalej i uczynić przełącznika, kropka ukośnik switch, a teraz pisać małymi literami Y, Kapitał Y, mała litera n, kapitał N, David, ponownie, ponieważ to nie pojedynczy znak. Zróbmy X, błąd, zgodnie z oczekiwaniami. I logically-- i to jest coś Chciałbym zachęcić nawet w general-- choć jesteśmy tylko zarysowania powierzchnia niektóre z tych cech. 

I to może nie być oczywiste, kiedy Sam usiadł przy klawiaturze, jak to działa? Co by to zrobić? Piękna rzeczą o laptop lub desktop lub dostęp do komputera za pomocą kompilatora, i za pomocą edytora kodu jak ten, jest prawie zawsze można odpowiedzieć na te pytania do siebie po prostu spróbować. 

Na przykład, jeśli retoryczna Pytanie było pod ręką, co się dzieje, jeśli zapomnisz Twoje wypowiedzi przerwę? Która jest faktycznie bardzo często rzeczą do zrobienia, bo to nie wygląda jakbyś naprawdę ich potrzebują. Oni naprawdę nie zakończyć swoje myślałem jak nawiasie lub kręcone klamra robi. Idziemy do przodu i skompilować kod i zobaczyć. Więc upewnij przełącznik dot przełącznika ukośnik. Załóżmy wpisać małymi literami y, top case, Enter. Więc wpisałem y. 

Program powiedział tak, nie, błąd, jakby została ona zmienia swój umysł. Ale to niby był, bo to, co się dzieje z przełącznikiem jest to pierwszy przypadek, że Mecz w istocie oznacza, hej komputer, wykonać cały kod pod nią. A jeśli nie mów przerwa lub nie mów przerwę, albo nie mówią przerwę, komputer będzie dmuchać przez wszystkich tych liniach i wykonać wszystkie z nich, dopóki dojdzie do tego nawias klamrowy. Więc hamulce są rzeczywiście konieczne. Ale na wynos o to, kiedy wątpliwości należy spróbować czegoś. Może zapisać swój kod po pierwsze, lub zapisać go w dodatkowym pliku jeśli jesteś naprawdę martwi brudząc się i konieczności odzyskania praca, że ​​wiesz pracuje. 

Ale spróbuj rzeczy. I nie bój się, jak może, co komputer może zrobić, lub że można złamać coś. Zawsze można wrócić do jakiejś wcześniejszej wersji. 

Więc w końcu, patrząc na etapie projektowania kodu. Mamy taką zdolność teraz napisać Warunki i pętle zapisu, i zmienne i funkcje połączeń. Tak więc, mówiąc, że jesteśmy z powrotem na rodzaj gdzie byliśmy tydzień temu z podstaw, choć z mniej przekonujące tekstowych Środowisko niż Scratch pozwala. 

Należy jednak zauważyć, jak szybko mamy nabyte że słownictwo, nawet jeśli jest to zajmie trochę czasu, aby zatopić się w, tak, że możemy teraz używać tego słownictwa napisać więcej ciekawych programów. A weźmy o krok dziecka ku temu, w sposób następujący. Pozwólcie mi iść do przodu i utworzyć nowy plik tutaj. 

Mam zamiar nazwać prototype.c oraz wprowadzenie po raz pierwszy, możliwość tworzyć własne funkcje. Niektórzy z was mogą mieć zrobić to z początku, dzięki czemu można stworzyć swój własne niestandardowe bloki podstaw, a następnie przeciągnij je na miejsce gdziekolwiek chcesz w C. I w większości programów Języki, można to zrobić dokładnie, that-- tworzyć własne funkcje, jeśli nie są one już istnieją. 

Tak więc, na przykład, pozwól mi iść do przodu i obejmują CS50.h i obejmują średnia io.h, int main nieważne. A teraz mamy placeholder gotowe. Trzymam drukowania rzeczy jak nazwy ludzi dzisiaj. I że czuje like-- nie byłoby dobrze, gdyby nie były funkcję o nazwie nazwa druku? Nie mam użyć printf. Nie trzeba pamiętać wszystkie kody formatu. Dlaczego nie mogę, dlaczego nie kogoś przede mną, Tworzenie funkcji o nazwie print Nazwa, że ​​biorąc pod uwagę pewne imię, po prostu wypisuje go? 

Innymi słowy, jeśli powiem, hej, Komputer, daj mi łańcuch prosząc użytkownika o takich, poprzez funkcję get ciąg CS50 jest. Hej, komputer, umieścić ten ciąg w zmienna się po lewej stronie, i nazywają to s. A potem, hej komputer, iść do przodu i wydrukować to nazwisko osoby, gotowe. 

Teraz byłoby miło, ponieważ Program ten, trafnie nazwany, Mówi mi, co to ma do zrobienia w drodze Te nazwy funkcji. Pozwól mi odejść i zrobić prototyp, Enter. I niestety To nie będzie latać. 

Prototype.c, linia 7, charakter 5, błąd, bezpośrednia deklaracja nazwa funkcji drukowania jest nieważny w C99, C99 oznacza wersję C który ukazał się w 1999 roku. To wszystko. 

Więc nie wiem co Wszystko to oznacza jeszcze. Ale mam rozpoznać błąd w kolorze czerwonym. To dość oczywiste. 

I wydaje się, że przy zielony charakter tutaj problem jest z nazwą druku, otwarta PAREN s, blisko PAREN, średnik. Ale niejawna deklaracja Funkcja widzieliśmy przez chwilę wcześniej. Oznacza to po prostu, że Clang nie wie, co mam na myśli. 

Użyłem słowa słownictwa, które jest Nigdy nie widziałem ani nie uczono wcześniej. A więc trzeba go uczyć co oznacza ta funkcja. Więc mam zamiar iść do przodu i robić. 

Mam zamiar iść do przodu i wdrożenia moja własna funkcja o nazwie Print Name. A ja powiem, jak wynika, że Czyni to, printf, witaj procent s, backslash n, nazwa, średnik. Więc co ja zrobiłem? 

Okazuje się zatem, aby zaimplementować własną funkcję, my niby pożyczyć taką samą strukturę jak główne że mamy właśnie brane za pewnik, a ja wiedzieć, powielanie i wklejając dość dużo, co Pisałem w przeszłości. Ale zauważmy wzór tutaj. Int, Main, Pustki, będziemy drażnić siebie Przed długi, co to właściwie znaczy. 

Ale dzisiaj, po prostu zauważyć równoległość. Nieważne, nazwa wydruku, string name, więc nie purpurowy słów kluczowych, które mamy zamiar zacząć wywołaniem zwracany typ, nazwa Funkcja i jej wartość. Tak, rzeczywiście, możemy destylować tego rodzaju jak w ubiegłym tygodniu jak to jest nazwa lub Algorytm kodu jesteśmy zamiar write-- algorytm bazowego kod będziemy pisać. 

To jest jego wejście. To jest jego wyjście. Ta funkcja, nazwa wydruku jest zaprojektowana, aby ciąg o nazwie nazwa, lub cokolwiek, jako dane wejściowe, a następnie anulowane. To nic nie wróci, jak uzyskać ciąg lub uzyskać int robi. Więc to będzie przekazać mi coś w zamian. To się po prostu dzieje się mieć Efektem ubocznym, że tak powiem, drukowania nazwisko osoby. Tak więc zauważyć, linia 7, I można nazwać nazwę druku. Linia 10, mogę zdefiniować lub zastosować nazwę druku. Ale, niestety, to nie wystarczy. 

Pozwólcie mi iść do przodu i rekompilacji to po zapisaniu. Zaraz, teraz, zrobiłem to co gorsza, wydaje się. Więc niejawna deklaracja Nazwa Funkcja druku jest nieprawidłowy. I znowu, nie ma więcej błędów. Ale jak już wcześniej ostrzegł, nawet jeśli ogarnia, lub trochę smutny zobaczyć tak wielu Błędy, tylko skupić się na pierwszym Początkowo, bo może po prostu miały efekt kaskadowy. Tak więc C lub Clang dokładniej nadal nie rozpoznaje nazwy wydruku. 

A to dlatego, Clang, Zgodnie z projektem, jest trochę głupie. Robi tylko to, co powiedzieć to zrobić. I to nie tylko tak, w porządku w którym powiesz to zrobić. 

Więc nie zdefiniowano główne na linii czterech, jak robiliśmy dość często. Mam zdefiniowane nazwy drukowania na linii 10. Ale staram się używać Nazwa nadruk na linii siedmiu. 

Jest zbyt wcześnie, jeszcze nie istnieje. Więc mogę być mądry, i być jak, OK, więc niech po prostu grać razem, i przenieść się nazwę druku tutaj, i ponownie skompilować. O mój Boże. Zadziałało. To było takie proste. 

Ale logika jest dokładnie to. Musisz nauczyć brzękiem co jest określenie funkcji pierwszego. Wtedy można go używać. Ale, szczerze mówiąc, to czuje się jak równi pochyłej. 

Więc za każdym razem uruchomić na problem, jestem po prostu zamiar zaznaczyć i skopiować kod Pisałem, wyciąć i wkleić go tutaj. I, z pewnością moglibyśmy wymyślić kilka scenariuszy gdzie jedna funkcja może trzeba zadzwonić innego. I po prostu nie można umieścić w każdym Funkcja powyżej każdy inny. 

Okazuje się tam lepszym rozwiązaniem. Możemy zostawić to być. I, szczerze mówiąc, to na ogół dobre, i wygodny, a dobry projekt umieścić główną pierwsze, dlatego, znowu, Głównym podobnie jak przy zielona flaga kliknięciu które to funkcja pobiera wykonywane domyślnie. Więc równie dobrze można umieścić że na początku pliku tak, że gdy użytkownik lub wszelkie inne ludzkie patrzy na pliku Wiesz, co się dzieje tylko przez czytanie główną jako pierwszy. Tak więc okazuje się, możemy powiedzieć, dzyń proaktywnie, hej, Clang, w wierszu czwartym Obiecuję, że wdrożenie funkcja nazywa Drukuj Nazwa, która przyjmuje nazwę ciąg zwany jako dane wejściowe i zwraca nic, nieważne. A ja ominąć wdrożenie go później. 

Nadchodzi Główny. Główne teraz na linii 9 można używać Drukuj Nazwa ponieważ Clang ufa, że ​​w końcu, będzie spotkać definicję realizacji Print Name. Więc po zapisaniu mój plik, niech mi iść do przodu i zrobić prototyp, wygląda dobrze tym razem. Dot slash, prototyp, pozwól mi idź i wpisać nazwę. David, cześć Dawid Zamila, cześć Zamila i, rzeczywiście, teraz to działa. 

Więc składnikiem jest to, że mamy wykonane funkcję niestandardową, jak zwyczaj Blok Scratch my nazywając ją. Jednak w odróżnieniu od podstaw, gdzie można wystarczy utworzyć go i rozpocząć korzystanie z niego, Teraz musimy być trochę bardziej pedantyczny a właściwie trenować brzękiem w użyciu, albo się go spodziewać. Teraz, na marginesie, dlaczego cały czas mieć możemy być tylko ślepo na wierze w tym CS50.h, a tym standardzie io.h? 

Cóż, okazuje się, Wśród kilku innych rzeczy, wszystko, co znajduje się w tych dot godz Pliki, które stało się plikami. Oni nagłówku plików, by tak rzec. Oni wciąż napisany w C. Ale oni inny typ pliku. 

Na razie można bardzo dużo Zakładamy że wszystko, co znajduje się wewnątrz CS50.h Jest ktoś wkładki takie jak ten, nie dla funkcji zwanych Drukuj Nazwa, ale pobiera ciąg znaków, Zapisz Float, i kilka innych. I istnieją podobne prototypy, jeden wkładki, wewnątrz standardowego io.h dla printf, która jest obecnie w moja własna funkcja Print Name. Więc innymi słowy, cały czas mamy właśnie ślepo kopiując i wklejając obejmuje to m.in. że to, co się dzieje? Są to po prostu rodzaj wskazówek do szczęk, co funkcji są rzeczywiście realizowane, po prostu indziej w różnych plikach gdzie indziej w systemie. 

Więc mamy wdrożone nazwę druku. To ma ten skutek uboczny drukowanie coś na ekranie. Ale tak nie jest w rzeczywistości podaj mi coś w zamian. Jak pójdziemy na temat realizacji programu, który ma przekazać mi coś w zamian? 

Dobrze, spróbujmy. Pozwólcie mi iść do przodu i wdrożenia plik o nazwie return.c więc możemy pokazać, jak coś Uzyskaj String lub Get int jest rzeczywiście powrocie coś z powrotem do użytkownika. Idziemy do przodu i definiowania int main pustkę. 

I znowu, w przyszłości, będziemy wyjaśnić, co to int i tę pustkę jest rzeczywiście robi. Ale dzisiaj, będziemy przyjąć za pewnik. Mam zamiar iść do przodu i printf, dobrego doświadczenia użytkownika, x jest. A potem będę czekać na użytkownik może mi dać xz get int. 

A potem mam zamiar iść do przodu i wydrukować x do kwadratu. Więc kiedy masz tylko klawiszowe, ludzie powszechnie użyć trochę marchewki symboli na klawiaturze reprezentować do potęgi z lub wykładnik. Więc x kwadrat jest obecny i. 

A teraz mam zamiar to zrobić. Mógłbym do-- co x kwadratu? x kwadrat jest x razy x. 

I zrobiliśmy to jakiś dawno już dziś. To nie ma ochoty wszystko to wielki postęp. Wiesz co? Załóżmy wykorzystać niektóre z tych idei z ostatniej chwili abstrakcji. 

Czy nie byłoby miło, gdyby istnieje funkcja o nazwie Kwadrat, który robi dokładnie to? Nadal na koniec dzień, robi to samo matematyki. Ale bądźmy abstrakcyjne Odległość idea podejmowania jedna liczba pomnożona przez inny, a tylko dać mu nazwę, jak pogodzić tę wartość. 

A innymi słowy, w C, stwórzmy funkcję zwany kwadrat, który robi dokładnie to. To się nazywa być kwadratowe. To zajmie int. A my po prostu nazwać n, domyślnie. 

Ale moglibyśmy nazwać cokolwiek chcemy. I wszystko, co dzieje się zrobić, dosłownie, jest zwrotny wynikiem razy n n. Jednak, ponieważ jest powrocie coś, co to słowo kluczowe w kolorze fioletowym mamy Nigdy nie widziałem, ja, na linii 11, Nie można po prostu powiedzieć, nieważne tym razem. 

Pustka, w przykładzie po prostu widział raczej nazwą druku, po prostu oznacza, Zrób coś. Ale nie podaj mi coś w zamian. W tym przypadku, chcę powrotu n n razy, lub cokolwiek to jest, że liczba. 

Więc nie mogę powiedzieć, hej, komputer, Nic nie wrócić, nieważne. To będzie powrót, przez naturę, int. A więc to wszystko, co się tu dzieje. 

Wejście do kwadratu będzie int. I tak, że można go używać, to musi mieć nazwę, N. To będzie wyjście int, że nie potrzebuje nazwy. Możemy pozostawić główną, czy ktokolwiek jest wykorzystuje mnie zapamiętać tę wartość, gdybyśmy chcą z własnej zmiennej. 

I znów, tylko nowe Hasło o to Return. A ja po prostu robi trochę matematyki. Gdybym naprawdę chciał być niepotrzebne, Mógłbym powiedzieć, int produkt dostanie n n razy. 

I wtedy będę mógł powiedzieć, produkt wróci. Ale znowu, z mojego punktu wcześniej z to po prostu nie jest dobre zamiary jak, dlaczego wprowadzić nazwę, symbol, podobny produkt, tak, aby natychmiast powrócić? To trochę czystsze, trochę mocniej, więc mówić, po prostu powiedzieć razy return n n, pozbyć się tej linii w ogóle. 

I to jest po prostu mniej kodu do odczytu, mniejsza szansa na błędy. I zobaczmy, czy to faktycznie działa teraz. Teraz mam zamiar iść naprzód i dokonać zwrotu. 

Uh-oh, bezpośrednia deklaracja funkcji. Zrobiłem ten błąd wcześniej, nic wielkiego. Pozwól mi wystarczy wpisać lub zaznaczyć i kopiowanie, dokładnie ten sam prototyp funkcji, lub podpis, funkcji tutaj. Albo mogę przenieść całą funkcję. 

Ale to jest trochę leniwy. Więc nie rób tego. Teraz pozwól mi powrót znowu dot powrót slash. 

x oznacza 2. x kwadrat jest 4. x oznacza 3. x kwadrat jest 9. A funkcja wydaje teraz pracować. Więc jaka jest różnica tutaj? Mam funkcji, która jest wywoływana kwadratowy, w tym przypadku, co umieścić w wejście. I wrócę wyjście. A jeszcze wcześniej, jeśli Otwieram Innym przykładem od wcześniej, co był nazywany prototype.c, Miałem nazwę druku, które powrócił nieważne, że tak powiem, Albo powrócił nic, a po prostu miał efekt uboczny. 

Więc co tu się dzieje? Dobrze, rozważmy funkcję uzyskać ciąg na chwilę. Byliśmy przy użyciu funkcji uzyskać ciąg w następujący sposób. 

Mieliśmy funkcją uzyskać łańcuch, jak to CS50.h, zawierają standardowe io.h, int, główny kanał, pustkę. A potem za każdym razem mam nazywa get ciąg tej pory, Powiedziałem coś podobnego, string s dostaje się ciąg, ponieważ get string-- nazwijmy to get.c-- get ciąg Sam zwraca ciąg mogę potem używać, i powiedzieć cześć, przecinek, procent s, backslash n, s. 

Więc jest to ten sam przykład, Naprawdę, które mieliśmy wcześniej. Więc ciąg zwraca wartość. Ale przed chwilą, druk ciąg nie zwraca wartości. To po prostu ma efekt uboczny. Więc to jest zasadnicza różnica. Widzieliśmy różne rodzaje funkcji teraz, Niektóre z nich są zwrócone wartości, z których niektóre nie. Więc może to ciąg lub int lub pływaka. A może to po prostu nieważne. 

A różnica jest że te funkcje, które uzyskać dane i zwracają wartość są w rzeczywistości przynosząc coś z powrotem do stołu, że tak powiem. Więc idź naprzód i spojrzeć na jeden ostateczny zestaw przykładów, które daje poczucie, teraz, od jak może, rzeczywiście, abstrakcyjne lepiej, i lepsze i lepiej, lub więcej, i więcej, i inne, w celu napisać ostatecznie lepszy kod. Idziemy do przodu, a także w duchu od zera, należy wykonać następujące czynności. 

Pozwól mi iść dalej i obejmują CS50.h i standard IO.h. Pozwólcie mi iść do przodu i dać Sam int, główny kanał, nieważne. I pozwól mi iść do przodu, nazywamy to cough.c. 

I pozwól mi iść do przodu i po prostu jak Scratch, wydrukować kaszel / N. I chcę zrobić to trzy razy. Więc ja, oczywiście, po prostu będzie skopiować i wkleić trzy razy. Jestem teraz zamiar zrobić kaszel dot ukośnik kaszel. Dajmy sobie trochę więcej miejsca tutaj, Enter, kaszel, kaszel, kaszel. 

Jest, oczywiście, już okazja do poprawy. Mam skopiowane i wklejone kilka razy dzisiaj. Ale to był tylko więc nie trzeba wpisywać tyle znaków. Wciąż zmieniane co te wiersze kodu. 

Te trzy linie są identyczne, która czuje się leniwi i rzeczywiście jest, i prawdopodobnie nie jest właściwe podejście. Więc z czym składnik możemy poprawić ten kod? Nie mamy skopiować i wkleić kod. 

I rzeczywiście, za każdym razem czujesz Sam kopiowanie i wklejanie, i nawet nie zmieniając kodu kursy są tam lepszy sposób. I rzeczywiście, nie ma. Pozwólcie mi iść do przodu i robić pętli for, choć może nie składnia nadejść w sposób naturalny. 

Czy to trzy razy, po prostu wykonując following-- a ja akurat wiem to z praktyki. Ale mamy szereg przykładów teraz. I zobaczysz w Internecie więcej odniesień martwych. 

Jest składnia w pozycji 6, które podobnie jak Scratch, który powtarza Blok, powtarzaj następujące trzy razy. To trochę magiczne teraz. Ale to dostanie więcej i bardziej znajome. 

I to będzie powtarzać Linia osiem trzy razy, tak, że jeśli ponownie skompilować make kaszel, Dot slash kaszel, kaszel, kaszel, kaszel. Nadal działa w ten sam sposób. Więc to wszystko jest w porządku i dobre. Ale to nie jest bardzo roztargniony. 

Jest to całkowicie prawidłowe. Ale wydaje się, jakby tam może być okazją, jak w świecie Scratch do rodzaju początek dodać kilka semantykę tutaj tak, że Nie wystarczy mieć trochę dla pętli oraz funkcja, która mówi kaszel, czy też kaszel. Wiesz co? Spróbuję być trochę chłodniej niż to, i rzeczywiście napisać funkcję, która ma pewne skutki uboczne, nazywają go kaszel. 

I to nie bierze wejście i zwraca żadnej wartości jako wyjścia. Ale wiesz co to robi? Czyni this-- printf, cytat cytatu, kaszel. 

A teraz tutaj, jadę iść do przodu i do int, I dostaje do zera, i mniej niż 3, ja plus plusem. Mam zamiar nie printf, która jest Realizacja zapewne niski poziom Szczegół. Nie obchodzi mnie, jak kaszel. Chcę po prostu użyć funkcji kaszel. A ja po prostu zamiar zadzwonić kaszel. 

Teraz, zwróć uwagę na dychotomii. Podczas wywoływania funkcji, jeśli nie Aby nadać mu wejść całkowicie w porządku. Wystarczy zrobić otwarte paren blisko paren i gotowe. 

Podczas definiowania funkcji lub Oświadczam, prototypów funkcji, jeśli z góry wiadomo, że nie jest zamierza podjąć żadnych argumentów, powiedzieć, nieważne tam tych nawiasach. A to sprawia, że ​​pewność, że Nie przypadkowo nadużywać go. Pozwólcie mi iść do przodu i zrobić kaszel. I, oczywiście, zrobiłem błąd. 

Cholera, nie jest tak dorozumiane oświadczenie. Ale to jest w porządku. Jest to łatwo naprawić. Muszę tylko prototyp wyżej w moim pliku, niż jestem w rzeczywistości jej stosowania. 

Więc teraz pozwól mi kaszel znów miłe. Teraz działa. Sprawdź, kaszel, kaszel, kaszel, kaszel. Więc można by pomyśleć, że jesteśmy naprawdę nieco ponad inżynierii ten problem. I rzeczywiście, jesteśmy. To nie jest dobra Kandydat programu w tym momencie do refactoring, i robi, co jest zwany rozkładem hierarchiczny, gdzie przejąć jakiś kod, a następnie wy rodzaj czynnika rzeczy out, tak przypisywać więcej semantyki do nich: i ponowne ostatecznie dłuższym okresie. Ale to jest budulcem stronę Bardziej zaawansowane programy że zaczniemy pisząc, że niebawem pozwala nam słownictwa z którym pisać lepsze kodu. I rzeczywiście, zobaczmy, czy mamy Nie można uogólniać tego dalej. 

Wydaje się trochę lame, że ja, głównym, trzeba się martwić o to darn pętli for i znowu dzwoni kaszel. Dlaczego nie mogę po prostu powiedzieć, kaszel, Proszę kaszel trzy razy? Innymi słowy, dlaczego nie można po prostu swój wkład do kaszlu i to zrobić? 

Dlaczego nie mogę po prostu powiedzieć, w Głównym kaszel trzy razy. A teraz, jest to rodzaj magiczne. Jest tu bardzo iteracyjny. I to jest rzeczywiście krokiem dziecka. 

Ale zdolność do powiedzenia Linia osiem, kaszel trzykrotnie to jest po prostu o wiele bardziej czytelny. A plus, nie trzeba znać lub opieki, jak kaszel jest realizowany. I rzeczywiście, w dalszej części Termin i projektów końcowych, jeśli projekt walki z kolega lub dwóch kolegów, zdasz sobie sprawę, że masz zamiar muszą lub chcą podzielić pracę. 

I masz zamiar chcą decydować z góry, kto zrobi co, oraz w którym elementy? I nie byłoby miło Jeśli, na przykład, przejęcie pisania Main, zrobione. A twój współlokator, albo zwrot partnerem bardziej ogólnie, dba o realizację kaszel. 

I ten podział, to Ściany abstrakcji, lub warstwy abstrakcji jeśli będziesz, są bardzo wydajne, ponieważ szczególnie dla większych, bardziej złożone programy i systemy Pozwala wielu ludzi do budowania rzeczy razem, a ostatecznie zszyć ich pracy ze sobą w ten sposób. Ale, oczywiście, mamy trzeba teraz naprawić kaszel. Musimy powiedzieć kaszel że, hej, wiesz co? Idziesz do konieczności zdawania input-- więc nie nieważne, ale int i teraz. Idziemy do przodu i umieścić w kaszel int. I dostaje zero. 

i jest mniejsze od tego jak wiele razy. Powiedziałem trzy wcześniej. Ale to nie to, co chcę. Chcę, kaszel być uogólnione na obsługiwać dowolną liczbę iteracji. 

Tak, rzeczywiście, jest to, że chcę n, co użytkownik mówi mi. Teraz mogę śmiało powiedzieć, drukowania i kaszel. I bez względu na to, jaki numer użytkownik przechodzi, Będę iteracji, że wiele razy. 

Tak więc na koniec dnia Program jest identyczne. Zauważmy jednak, wszystkie te rzeczy może być nawet w innym pliku. Rzeczywiście, nie wiem u Chwila jak printf jest realizowany. 

Nie wiem w tej chwili, jak się ciąg, lub uzyskać int, lub uzyskać pływaka są realizowane. A ja nie chcę zobaczyć je na ekranie. Jak to jest, ja zaczynam skupiać się na mój program, a nie te funkcje. 

I tak, rzeczywiście, jak tylko rozpocząć faktoringu kod jak to uwagę, możemy nawet przenieść kaszel do osobnego pliku? Ktoś inny mógłby go wdrożyć. A ty i twój program staje się Bardzo piękne i bardzo czytelny, zapewne, naprawdę cztery Program tam linię. 

Więc śmiało teraz i uczynić jeszcze jedną zmianę. Zauważ, że mój prototyp musi zmienić się szczyt. Więc pozwól mi naprawić tak Nie daj się wrzasnął. 

Sprawdź, kaszel, pozwól mi działać kaszel raz więcej, nadal robi to samo. Teraz jednak zauważyć mamy składnikiem jednej z wersji finalnej. Wiesz co? Nie chcę po prostu kaszel, niekoniecznie. Chcę mieć coś bardziej ogólnego. Więc wiesz co? Chcę to zrobić. Chcę mieć, podobnie jak Scratch robi, blok powiedzieć, ale nie tylko coś powiedzieć jakąś liczbę razy. Chcę to powiedzieć bardzo specyficzny łańcuch. A zatem, nie wiem ma to po prostu powiedzieć kaszel. Chcę, żeby powiedzieć cokolwiek Łańcuch jest przekazywana. 

Tak więc zauważyć, mam uogólnione to tak, że teraz powiedzmy czuje się jak dobre imię do tego, jak nowa, przyjmuje dwa argumenty, w przeciwieństwie do zera. Jednym z nich jest ciągiem. Jednym z nich jest typu int. 

I mogę je przełączać. Po prostu coś w rodzaju idei znaczy łańcuch, a potem ile razy później. Odpada Oznacza to nadal niczego nie powrócić. Są to tylko strona wizualna efekty, jak w przypadku [? Jordan?] werbalne efektem ubocznym wrzask. To wciąż robi coś n razy, 0 do, ale nie jest równa n. Oznacza to całkowite n razy. A potem po prostu wydrukować cokolwiek to jest ciąg. Więc ja naprawdę uogólnione ta linia kodu. Więc teraz, w jaki sposób mogę wdrożyć funkcja kaszel? 

mogę zrobić void kaszel. A mogę jeszcze wziąć w jaki wiele razy chcesz kaszel. Ale wiesz co? Teraz mogę punt powiedzieć. 

Mogę zadzwonić powiedzieć, z Słowo kaszel, przekazując n. A jeśli chcę również wdrożenia, tylko dla zabawy, funkcja kichania, Mogę kichanie pewną liczbę razy. I mogę zapewnić ponowne n, ponieważ zauważyć, że w tym kontekście m lub zakresu istnieje tylko w tej funkcji. 

I N w tym kontekście tylko istnieje w tej funkcji tutaj. Więc wracamy do te zagadnienia z zakresu. I tu, ja po prostu powiedzieć, Achoo i to n razy, średnik. 

A teraz po prostu trzeba pożyczać Sygnatury te funkcjonują tutaj. Więc kaszel jest prawidłowe. Odpada kichnięcie jest prawidłowe. 

I wciąż wystarczy powiedzieć. Więc mam zamiar powiedzieć, powiedzmy łańcuch s, int n, średnik. Tak już ponad inżynierii cholery z tym programem. 

I to nie robi niekoniecznie oznacza to co należy zrobić podczas pisania nawet najprostszych programów. Zrób coś, co jest oczywiście bardzo proste, bardzo krótki, i ponownego wprowadzenia jej w życie używając zbyt dużo kodu. Ale rzeczywiście zobaczyć, aw Czas spojrzeć wstecz na tych przykładach, i uświadomić sobie, och, to są kroki wzięliśmy rzeczywiście generalizować, czynnik coś, aż na koniec dnia mój kod jest rzeczywiście bardzo rozsądne. Ponieważ jeśli chcę kaszel trzy Czasy następnie trzykrotnie kichania, Jestem po prostu będzie powtórzona ta, Program sprawiają, kaszel, kaszel i uruchomić. I mam trzy kaszlu i trzy kicha. 

I tak to jest podstawowy Paradygmat, jeśli chcesz, w jaki sposób możemy go o rzeczywiście realizuje program. Ale niech tylko teraz zobaczyć, co to jest robiliśmy przez cały ten czas, i co niektóre z końcowych części stoją za tym prostym poleceniem. Na koniec dnia, mamy używałeś brzękiem jak nasz kompilator. Byliśmy pisanie źródło Kod, przekształcając go poprzez Clang do kodu maszynowego. 

I używaliśmy Bądź po prostu aby ułatwić naszym klawiszy tak że nie trzeba pamiętać te zaklęcia sam Clang. Ale co to właściwie robi Dodać? Oraz z kolei, o co Clang właściwie robi? 

Okazuje się, iż mamy uproszczone Dzisiejsza dyskusja mówiąc, wziąć kod źródłowy, należy przekazać go jako Wejście do kompilatora, co daje Wyjście maszynie Kod, okazuje się tam kilka różnych kroków wewnątrz tam. I zestawiania dzieje się parasol termin na całą masę krokach. Ale niech tylko podrażnić to się bardzo szybko. 

Okazuje się, że robiliśmy więcej rzeczy za każdym razem uruchomić program, i za każdym razem jak skompilować program dziś. Więc przerób dotyczy this-- niczego w programie C, jak zobaczymy znowu i znowu, który zaczyna się od tego skrótu symbolu, lub symbol hashtag tutaj, oznacza to dyrektywa preprocesora. Oznacza to, że w tym przypadku, hej komputer, coś zrobić z tym plikiem zanim faktycznie kompilacji mój własny kod. 

W tym przypadku, hash to znaczy, zasadniczo sposobem C na powiedzenie, hej komputer, idź zawartość z CS50.h i wklej je tutaj. Hej komputer, przejść uzyskać Zawartość standardowego io.h, gdziekolwiek by to było na dysk twardy, wklej go tutaj. Więc te rzeczy się zdarzają najpierw podczas wstępnego przetwarzania. 

I Clang robi to wszystko dla nas. I robi to tak cholernie szybko, nawet nie zobaczyć cztery różne rzeczy dzieje. Ale to pierwszy taki krok. 

Co dzieje się dalej? Cóż, kolejna oficjalna krokiem jest kompilacja. I okazuje się, że kompilacji programu Technicznie oznacza przejście z Kod źródłowy, rzeczy mamy pisze dziś, do czegoś Zespół nazywa się kod, coś który wygląda trochę inaczej. 

I rzeczywiście, możemy zobaczyć to naprawdę szybko. Pozwól, że rzeczywiście iść do mojego IDE. Pozwólcie mi iść do przodu i otwarta hello.c, które Jest to pierwszy program, z którym mamy rozpoczęła dziś. I pozwól mi iść do przodu i uruchomić Clang A trochę inaczej, Clang-s, hello.c, których faktycznie się Daj mi jeszcze hello.s plików. 

I prawdopodobnie nigdy nie będziemy znów zobaczyć ten rodzaj kodu. Jeśli wziąć niższy poziom Systemy klasy jak CS61, widać dużo więcej Tego rodzaju kodu. Ale to jest w asemblerze. Jest to asembler x86 że procesor, który jest zasadniczym CS50 IDE rzeczywiście rozumie. 

I tajemnicze jak to robi patrzeć, to jest coś komputer rozumie całkiem dobrze. Sub q, to ​​odejmowanie. Jest ruchy. 

Nie dzwoni funkcji tutaj x oring, ruch, dodatek, pop, powrót. Więc jest kilka bardzo Instrukcje niski poziom że procesory zrozumieć, że Wspomniałem wcześniej. To jest to, co Intel Inside. 

Istnieją wzory zer i jedynek, które mapa do tych arcanely sformułowane, ale dość dobrze nazwane, instrukcje, że tak powiem. To, co się dzieje, gdy kompilowania kodu. Otrzymasz montaż język z tego, co Oznacza trzecim etapem jest montaż że kod montażu w ostatecznym rozrachunku, Maszyna code-- zer i jedynek, a nie Tekst, który właśnie przed chwilą zobaczył. 

Więc wstępnego przetwarzania czy to znaleźć i wymienić, i kilka innych rzeczy. Kompilacja odbywa źródło Kod z C, kod źródłowy że pisał do montażu kod, który po prostu spojrzał na. Montaż odbywa że montaż Kod z zer i jedynek że procesor będzie naprawdę zrozumieć na koniec dnia. I powiązanie jest ostatnim krokiem że zdarza us-- ponownie tak szybko, że nawet nie notice-- który mówi, hej komputer, podjąć wszystkie z zer i jedynek, które wynikał z kompilacją kodu Dawida, a jego głównym zadaniem w tej sprawie. 

I hej komputer, idź wszystkich zer i jedynek że pracownicy CS50 napisał wewnątrz biblioteki CS50. Wymieszać ci się z Dawida. I hej komputer, przejdź się wszystkie zera oraz te, które ktoś inny napisał lat temu przez printf. I dodać je do Całość, dzięki czemu mamy got my zer i jedynek, tym zer i jedynek pracownik wykonawczy CS50'S, printf zera i jedynki, i coś jeszcze używamy. 

Wszystkie one łączyć się ze sobą w jeden Program nazywa się, w tym przypadku, cześć. Więc odtąd będziemy po prostu używać kompilacji słów. A my przyjmujemy za pewnik, że kiedy mówimy, kompilacji programu, to znaczy, hej zrobić przetwarzaniem wstępnym, montaż i łączenie. Ale faktycznie niektóre rzeczy soczyste dzieje się pod maską. A zwłaszcza jeśli uzyskać ciekawy trochę czasu, można zacząć szturchanie dokoła na tym niższym poziomie. Ale teraz sobie sprawę, że Wśród wynos na dziś są dość po prostu początek procesu, uzyskania komfortowo coś jak Hello World. Rzeczywiście, większość z tego, co zrobiliśmy dzisiaj Z pewnością nie będzie tonąć w super szybko. A to zajmie trochę czas, a niektóre praktyki. A szanse są, można sortować z chcesz trafić klawiaturę lub krzyczeć na ekranie. A wszystko to jest OK. Chociaż, może nie próbować to zrobić w bibliotece tak dużo. 

I ostatecznie, będziesz być może jednak, aby rozpocząć widząc wzorów, zarówno w dobrej kodu które zostały napisane i błędy które zostały wykonane. I podobnie jak w procesie staje się TF lub CA jest podobny, zaczniesz lepiej i lepiej widząc te wzory, i po prostu rozwiązywania własne problemy ostatecznie. W międzyczasie będzie dużo nas do udzielenia Ci pomocy, a cię przez to. Aw napisać firm dla wszystkich problemów będzie prowadzony przez wszystkich poleceń że z pewnością wiedzą dużo praktyki teraz, ale może być pokonywana nad głową do teraz. I to jest całkowicie w porządku. 

Ale, ostatecznie, idziesz aby rozpocząć, aby zobaczyć wzory pojawiają. A kiedy ominąć wszystkie z głupie szczegółów, takich jak nawiasy, i nawiasy klamrowe i średniki, i rzeczy, szczerze mówiąc, nie jest wcale intelektualnie interesujące. I nie jest celem podejmowania jakichkolwiek klasę wstępną. To idee, które idą do materii. 

To pętle, a warunki i funkcje, i silniej abstrakcja, a faktoring kodu, a dobry design i dobre styl, a ostatecznie prawidłowość Twój kod, to ostatecznie będzie najbardziej znaczenia. Więc w przyszłym tygodniu, weźmiemy je idee, które po raz pierwszy zobaczyłem w Scratch a teraz przetłumaczone do C. I zaczniemy przedstawić pierwszy z domen rzeczywistym świecie Kursu. 

Będziemy koncentrować się na świecie, bezpieczeństwa, a bardziej konkretnie kryptografii sztuka kodowania informacji. A jednym z pierwszych Problemy ty sam dostanie napisać poza gry z niektórych składni i rozwiązywanie logicznych Problemy ostatecznie niedługo jest faktycznie wyścig, lub szyfrowania, i ostatecznie odszyfrowania informacji. I wszystko, co zrobiliśmy Dziś będzie dość niski poziom jest po prostu będzie, aby umożliwić nam podjąć jeden i jeden, i jeszcze jeden krok w kierunku wyżej pisanie jeszcze najciekawszą kod. 

Więc tym bardziej na przyszły tydzień. 

[ODTWARZANIE] 

-Co może mi pan powiedzieć o ostatni raz go widział? -Co Mogę powiedzieć, naprawdę? To znaczy, że był jak każdy inny próba pre-produkcji, wyjątkiem było coś powiedział na samym końcu, że utknął ze mną. 

-To Był CS50. 

-To Jest każdy krój, wielką pracę na próbę. 

obiad -To? 

-Tak, Ty i ja mogę chwycić kanapkę w kawałku. Niech mi tylko debrief z David bardzo szybko. David? David? 

[KONIEC ODTWARZANIA] 