1
00:00:00,000 --> 00:00:00,500

2
00:00:00,500 --> 00:00:02,490
[NHẠC]

3
00:00:02,490 --> 00:00:16,950

4
00:00:16,950 --> 00:00:19,240
>> DAVID J. Malan: Được rồi, đây là CS50.

5
00:00:19,240 --> 00:00:21,010
Và đây là tuần một.

6
00:00:21,010 --> 00:00:25,050
Vì vậy, nhớ lại rằng thời gian qua trong tuần không,
chúng tôi tập trung vào tư duy tính toán.

7
00:00:25,050 --> 00:00:28,440
Và chúng tôi chuyển từ đó đến
Scratch, một lập trình đồ họa

8
00:00:28,440 --> 00:00:30,360
ngôn ngữ từ bạn bè của chúng tôi
tại Media Lab của MIT.

9
00:00:30,360 --> 00:00:34,730
>> Và với Scratch, đã chúng tôi khám phá
ý tưởng như chức năng và điều kiện,

10
00:00:34,730 --> 00:00:38,210
và vòng lặp, và các biến, và thậm chí
sự kiện, và chủ đề, và nhiều hơn nữa.

11
00:00:38,210 --> 00:00:40,880
Và hôm nay, chúng ta sẽ
tiếp tục sử dụng những ý tưởng,

12
00:00:40,880 --> 00:00:43,630
và thực sự đưa chúng cho
cấp, nhưng dịch chúng

13
00:00:43,630 --> 00:00:47,220
sang một ngôn ngữ được gọi là C. Bây giờ,
C là một ngôn ngữ truyền thống hơn.

14
00:00:47,220 --> 00:00:49,020
Đó là một mức độ thấp hơn
ngôn ngữ, nếu bạn muốn.

15
00:00:49,020 --> 00:00:50,300
>> Nó hoàn toàn là văn bản.

16
00:00:50,300 --> 00:00:52,910
Và do đó, ở cái nhìn đầu tiên, đó là
tất cả sẽ trông khá khó hiểu

17
00:00:52,910 --> 00:00:54,430
nếu bạn đã không bao giờ được lập trình trước.

18
00:00:54,430 --> 00:00:56,530
Chúng ta sẽ có
dấu chấm phẩy và dấu ngoặc,

19
00:00:56,530 --> 00:00:58,150
và dấu ngoặc nhọn, và nhiều hơn nữa.

20
00:00:58,150 --> 00:01:00,240
Nhưng nhận ra rằng mặc
mặc dù cú pháp

21
00:01:00,240 --> 00:01:03,600
về để tìm một chút quen thuộc
cho hầu hết các bạn, xem quá khứ đó.

22
00:01:03,600 --> 00:01:06,220
Và cố gắng nhìn thấy những ý tưởng
đó là, thực sự, quen thuộc,

23
00:01:06,220 --> 00:01:09,750
bởi vì ở đây trong tuần một điều gì
chúng tôi sẽ bắt đầu làm là để so sánh,

24
00:01:09,750 --> 00:01:11,980
Ban đầu, Scratch so với C.

25
00:01:11,980 --> 00:01:15,350
>> Vì vậy, ví dụ, nhớ lại rằng khi chúng ta
thực hiện đầu tiên của chương trình của chúng tôi

26
00:01:15,350 --> 00:01:19,220
thời gian qua, chúng tôi đã có một khối mà nhìn
một chút gì đó như này-- khi

27
00:01:19,220 --> 00:01:22,990
lá cờ màu xanh lá cây nhấp, và sau đó chúng tôi đã có
một mảnh ghép hoặc nhiều bên dưới nó,

28
00:01:22,990 --> 00:01:25,150
trong trường hợp này, nói, xin chào thế giới.

29
00:01:25,150 --> 00:01:27,870
Vì vậy, thực sự, trong Scratch,
khi tôi nhấp vào lá cờ màu xanh lá cây

30
00:01:27,870 --> 00:01:30,390
để chạy chương trình của tôi, vì vậy
để nói chuyện, đây là những

31
00:01:30,390 --> 00:01:32,520
các khối có được thực thi, hoặc chạy.

32
00:01:32,520 --> 00:01:35,230
Và, đặc biệt, Scratch
cho biết, hello, thế giới.

33
00:01:35,230 --> 00:01:38,377
>> Bây giờ, tôi có thể đã xác định
Nói cách khác nhau ở đây.

34
00:01:38,377 --> 00:01:40,960
Nhưng chúng ta sẽ thấy rằng, trên thực tế, nhiều
các blocks-- và quả thật,

35
00:01:40,960 --> 00:01:44,880
trong C nhiều functions-- có thể
parametrized hoặc tùy chỉnh

36
00:01:44,880 --> 00:01:46,150
để làm những việc khác nhau.

37
00:01:46,150 --> 00:01:48,520
Trong thực tế, trong C nếu chúng ta
muốn chuyển đổi, bây giờ,

38
00:01:48,520 --> 00:01:50,567
chương trình Scratch này
đến các ngôn ngữ này,

39
00:01:50,567 --> 00:01:52,650
chúng ta sẽ viết thư
chút gì đó như thế này.

40
00:01:52,650 --> 00:01:55,540
>> Cấp, có một số không quen thuộc
cú pháp có nhiều khả năng, int,

41
00:01:55,540 --> 00:01:57,380
và dấu ngoặc đơn và trống không.

42
00:01:57,380 --> 00:02:00,740
Nhưng printf-- mặc dù bạn sẽ
nghĩ rằng nó sẽ chỉ được in.

43
00:02:00,740 --> 00:02:03,120
Nhưng in có nghĩa là in
định dạng, như chúng ta sẽ sớm thấy.

44
00:02:03,120 --> 00:02:05,140
Điều này nghĩa là sẽ in
để màn hình bất cứ điều gì

45
00:02:05,140 --> 00:02:08,990
là bên trong những dấu ngoặc đơn, mà
tất nhiên trong trường hợp này là, xin chào thế giới.

46
00:02:08,990 --> 00:02:12,290
>> Nhưng bạn sẽ nhận thấy một số khác
cú pháp, một số dấu ngoặc kép,

47
00:02:12,290 --> 00:02:14,890
rằng các dấu ngoặc đơn ở cuối,
dấu chấm phẩy và muốn.

48
00:02:14,890 --> 00:02:18,027
Vì vậy, có một chút trên không,
vậy để nói chuyện, cả hai nhận thức

49
00:02:18,027 --> 00:02:20,860
và cú pháp, mà chúng ta đang đi
phải nhớ trước khi dài.

50
00:02:20,860 --> 00:02:23,720
Nhưng nhận ra rằng với thực hành,
này sẽ bắt đầu nhảy vào bạn.

51
00:02:23,720 --> 00:02:27,920
>> Trong thực tế, chúng ta hãy tập trung vào một trong những
chức năng specifically-- trong trường hợp này,

52
00:02:27,920 --> 00:02:29,290
chào thế giới.

53
00:02:29,290 --> 00:02:30,560
Vì vậy, nói là chức năng.

54
00:02:30,560 --> 00:02:34,320
Xin chào thế giới là tham số của nó,
hoặc đối số, tuỳ biến của nó.

55
00:02:34,320 --> 00:02:37,320
>> Và sự tương đương trong C chỉ là
sẽ là một trong những dòng này ở đây,

56
00:02:37,320 --> 00:02:41,710
nơi printf là tương đương với, nói,
các chuỗi trích dẫn đôi, hello

57
00:02:41,710 --> 00:02:44,470
thế giới là tương đương, tất nhiên,
để những gì trong hộp màu trắng đó.

58
00:02:44,470 --> 00:02:48,680
Và n xuyệc ngược, mặc dù một chút
kỳ lạ và vắng mặt từ Scratch,

59
00:02:48,680 --> 00:02:52,380
chỉ đơn giản là sẽ có hiệu lực chúng tôi sẽ
thấy trong một máy tính, như máy Mac của tôi hoặc một máy tính,

60
00:02:52,380 --> 00:02:54,660
chỉ di chuyển
con trỏ đến dòng kế tiếp.

61
00:02:54,660 --> 00:02:56,970
Nó giống như đánh
Enter trên bàn phím của bạn.

62
00:02:56,970 --> 00:02:58,580
>> Vì vậy, chúng ta sẽ thấy rằng một lần nữa trước khi dài.

63
00:02:58,580 --> 00:03:01,640
Nhưng trước tiên, chúng ta hãy nhìn vào điều này
Ví dụ khác trong trường hợp của các vòng.

64
00:03:01,640 --> 00:03:05,830
Chúng tôi đã mãi mãi vòng này thời gian qua,
đó là một loạt các mảnh ghép

65
00:03:05,830 --> 00:03:08,490
mà đã làm một cái gì đó theo nghĩa đen
forever-- trong trường hợp này,

66
00:03:08,490 --> 00:03:11,360
nói, thế giới hello, hello thế giới,
hello thế giới, xin chào thế giới.

67
00:03:11,360 --> 00:03:13,350
Vì vậy, nó là một vòng lặp vô hạn của thiết kế.

68
00:03:13,350 --> 00:03:17,580
>> Trong C, nếu chúng ta muốn thực hiện điều này
cùng ý tưởng, chúng ta có thể chỉ đơn giản là làm điều này.

69
00:03:17,580 --> 00:03:22,570
Trong khi sự thật, printf chào world-- nay
trong khi, chỉ ngữ nghĩa, loại

70
00:03:22,570 --> 00:03:26,090
gợi lên ý tưởng làm
một cái gì đó một lần nữa, và một lần nữa, và một lần nữa,

71
00:03:26,090 --> 00:03:26,980
và trong bao lâu?

72
00:03:26,980 --> 00:03:30,990
Vâng, thu hồi true-- đó
đúng là chỉ trên hoặc một.

73
00:03:30,990 --> 00:03:33,660
>> Và sự thật là, tất nhiên, luôn luôn đúng.

74
00:03:33,660 --> 00:03:36,060
Vì vậy, nó là loại một vô nghĩa
tuyên bố chỉ để nói sự thật.

75
00:03:36,060 --> 00:03:39,890
Nhưng thực sự, đây là cố ý,
bởi vì nếu thật sự chỉ là luôn luôn đúng,

76
00:03:39,890 --> 00:03:43,850
hơn trong khi sự thật chỉ ngụ ý,
nếu một chút gián tiếp,

77
00:03:43,850 --> 00:03:47,070
rằng các dòng mã sau đây
ở giữa những dấu ngoặc nhọn

78
00:03:47,070 --> 00:03:51,320
nên chỉ cần thực hiện một lần nữa, và một lần nữa,
và một lần nữa, và không bao giờ thực sự dừng lại.

79
00:03:51,320 --> 00:03:53,230
>> Nhưng nếu bạn muốn của bạn
vòng lặp dừng lại, như chúng ta

80
00:03:53,230 --> 00:03:57,500
làm lần trước với một cái gì đó như
này, lặp lại 50 lần sau,

81
00:03:57,500 --> 00:04:00,700
trong C chúng ta có thể làm tương tự với những gì
gọi là cho loop-- từ khóa

82
00:04:00,700 --> 00:04:02,330
không phải là thời gian, nhưng đối.

83
00:04:02,330 --> 00:04:06,290
Và sau đó chúng tôi có một số cú pháp mới đây,
với int i bằng 0, tôi ít hơn 50,

84
00:04:06,290 --> 00:04:06,880
i ++.

85
00:04:06,880 --> 00:04:08,430
Và chúng tôi sẽ trở lại đó.

86
00:04:08,430 --> 00:04:12,660
Nhưng điều này chỉ đơn giản là làm thế nào chúng ta sẽ
dịch các tập hợp các khối Scratch

87
00:04:12,660 --> 00:04:16,079
cho một tập các dòng C mã.

88
00:04:16,079 --> 00:04:17,450
>> Trong khi đó, xem xét các biến.

89
00:04:17,450 --> 00:04:19,540
Và, trên thực tế, chúng ta chỉ
nhìn thấy một trong một thời gian trước đây.

90
00:04:19,540 --> 00:04:24,220
Và trong trường hợp của Scratch, nếu chúng ta
muốn khai báo một biến gọi là i

91
00:04:24,220 --> 00:04:27,590
i là số nguyên, chỉ một số,
và chúng tôi muốn đặt nó vào một số giá trị,

92
00:04:27,590 --> 00:04:31,410
chúng tôi sẽ sử dụng màu cam này
chặn đây-- thiết lập i đến 0.

93
00:04:31,410 --> 00:04:33,800
>> Và chúng ta sẽ thấy ngày hôm nay và
xa hơn nữa, giống như tuần trước,

94
00:04:33,800 --> 00:04:36,850
lập trình viên làm hầu như luôn luôn
bắt đầu đếm từ số không, thực sự

95
00:04:36,850 --> 00:04:37,950
theo quy ước.

96
00:04:37,950 --> 00:04:40,250
Nhưng cũng vì thu hồi từ
thảo luận của chúng ta về nhị phân,

97
00:04:40,250 --> 00:04:42,990
số nhỏ nhất có thể
đại diện với bất kỳ số lượng các bit

98
00:04:42,990 --> 00:04:44,640
chỉ sẽ là 0 chính nó.

99
00:04:44,640 --> 00:04:48,190
Và vì vậy chúng tôi sẽ thường bắt đầu
khởi tạo thậm chí biến của chúng tôi để 0.

100
00:04:48,190 --> 00:04:50,710
>> Và trong C để làm như vậy,
chúng ta sẽ nói int

101
00:04:50,710 --> 00:04:53,110
cho số nguyên, tôi chỉ theo quy ước.

102
00:04:53,110 --> 00:04:56,390
Tôi có thể gọi là biến này
bất cứ điều gì tôi muốn, giống như trong Scratch.

103
00:04:56,390 --> 00:05:00,770
Và sau đó bằng 0 chỉ chuyển nhượng
giá trị 0 từ bên phải

104
00:05:00,770 --> 00:05:04,319
và đặt nó vào biến, hoặc
container lưu trữ ở đó, bên trái.

105
00:05:04,319 --> 00:05:07,360
Và dấu chấm phẩy như chúng tôi sẽ see-- và
chúng tôi đã nhìn thấy một vài trong số những already--

106
00:05:07,360 --> 00:05:09,530
chỉ có nghĩa là kết thúc của tư tưởng.

107
00:05:09,530 --> 00:05:12,430
Tiến hành để làm cái gì khác
trên dòng tiếp theo.

108
00:05:12,430 --> 00:05:14,330
>> Bây giờ, những gì về các biểu thức Boolean?

109
00:05:14,330 --> 00:05:17,320
Nhớ lại rằng trong Scratch,
đây là những biểu thức

110
00:05:17,320 --> 00:05:19,740
đó là một trong hai thành sự thật
hoặc câu hỏi false--,

111
00:05:19,740 --> 00:05:21,910
thực sự, đó là đúng hoặc sai.

112
00:05:21,910 --> 00:05:24,960
Vì vậy, trong trường hợp của Scratch, chúng ta có thể
đặt một câu hỏi đơn giản như thế này,

113
00:05:24,960 --> 00:05:27,586
là tôi ít hơn 50?

114
00:05:27,586 --> 00:05:28,710
Vì vậy, tôi, một lần nữa, là một số nguyên.

115
00:05:28,710 --> 00:05:30,210
Có lẽ chúng ta đang sử dụng nó
trong một chương trình Scratch

116
00:05:30,210 --> 00:05:32,310
để theo dõi điểm số
hay đại loại thế.

117
00:05:32,310 --> 00:05:36,810
Vì vậy, cú pháp này ở đây trong Scratch
chỉ có nghĩa là tôi ít hơn 50?

118
00:05:36,810 --> 00:05:40,330
Vâng, may mắn, cái gì là
đơn giản trong C. Và để dịch,

119
00:05:40,330 --> 00:05:44,780
này, chúng ta sẽ chỉ đơn giản nói rằng tôi ít
50, sử dụng phím quen thuộc

120
00:05:44,780 --> 00:05:45,850
trên bàn phím của bạn.

121
00:05:45,850 --> 00:05:48,141
>> Trong khi đó, nếu bạn muốn
nói điều gì đó tổng quát hơn,

122
00:05:48,141 --> 00:05:52,890
như, tốt, là x ít hơn y mà mỗi
của x và y là tự biến?

123
00:05:52,890 --> 00:05:55,280
Chúng tôi có thể làm điều tương tự
trong C, miễn là chúng tôi đã

124
00:05:55,280 --> 00:05:56,942
tạo ra các biến này đã.

125
00:05:56,942 --> 00:05:58,650
Và chúng ta sẽ thấy làm thế nào để
làm điều đó trước khi dài.

126
00:05:58,650 --> 00:06:01,590
Chúng tôi chỉ đơn giản là nói ít hơn x y.

127
00:06:01,590 --> 00:06:03,530
>> Vì vậy, bạn đang bắt đầu
thấy một số điểm tương đồng.

128
00:06:03,530 --> 00:06:06,490
Và những folks những người làm
Scratch là chắc chắn

129
00:06:06,490 --> 00:06:08,250
lấy cảm hứng từ một số trong những ý tưởng cơ bản.

130
00:06:08,250 --> 00:06:13,350
Và bạn sẽ thấy loại này
cú pháp trong nhiều languages--

131
00:06:13,350 --> 00:06:15,160
không chỉ Scratch, không
chỉ C, nhưng Python,

132
00:06:15,160 --> 00:06:17,790
và JavaScript, và
ngôn ngữ khác vẫn còn.

133
00:06:17,790 --> 00:06:21,270
>> Hãy xem xét xây dựng khác
từ C, khái niệm về một điều kiện,

134
00:06:21,270 --> 00:06:23,370
làm một cái gì đó có điều kiện.

135
00:06:23,370 --> 00:06:25,720
Nếu một cái gì đó là sự thật, làm được điều này.

136
00:06:25,720 --> 00:06:27,457
Nếu cái gì khác là sự thật, làm điều đó.

137
00:06:27,457 --> 00:06:30,040
Đó là loại của chương trình
tương đương với một ngã ba đường.

138
00:06:30,040 --> 00:06:32,730
Có lẽ đó là một hai chiều ngã ba,
ba chiều ngã ba, hoặc nhiều hơn.

139
00:06:32,730 --> 00:06:35,800
Và trong Scratch, chúng ta có thể có
nhìn thấy một cái gì đó như thế này.

140
00:06:35,800 --> 00:06:37,010
>> Vì vậy, con này một lớn.

141
00:06:37,010 --> 00:06:39,750
Nhưng xem xét tương đối
đơn giản của logic.

142
00:06:39,750 --> 00:06:47,010
Nếu x là ít hơn so với năm trước, sau đó nói rằng x là ít
hơn y, khác nếu x lớn hơn y,

143
00:06:47,010 --> 00:06:49,230
sau đó nói x lớn hơn y.

144
00:06:49,230 --> 00:06:51,300
Và sau đó, một cách logic, nếu
bạn nghĩ lại Scratch

145
00:06:51,300 --> 00:06:55,610
hay chỉ là trực giác của con người của riêng bạn,
tốt, nếu x là không lớn hơn y, và x

146
00:06:55,610 --> 00:07:00,000
không phải là ít hơn so với y, sau đó tất nhiên
x sẽ là bằng y.

147
00:07:00,000 --> 00:07:02,690
Vì vậy, trong trường hợp này, bởi làm tổ
những khối Scratch,

148
00:07:02,690 --> 00:07:05,580
chúng ta có thể đạt được một ba
cách ngã ba đường?

149
00:07:05,580 --> 00:07:07,980
>> Trong khi đó, nếu chúng ta muốn
làm điều đó trong C, nó được cho là

150
00:07:07,980 --> 00:07:11,420
nhìn một chút simpler-- ít nhất
một khi bạn làm quen với cú pháp.

151
00:07:11,420 --> 00:07:15,050
Nếu x là ít hơn so với năm trước,
printf x là ít hơn so với năm ngoái.

152
00:07:15,050 --> 00:07:19,140
Else if x lớn hơn y,
printf x lớn hơn y.

153
00:07:19,140 --> 00:07:24,210
Khác printf x bằng y-- và,
một lần nữa, với những dấu chéo ngược kết thúc chỉ

154
00:07:24,210 --> 00:07:27,160
đối với những dây chuyền mới để nếu bạn
đã chạy loại chương trình

155
00:07:27,160 --> 00:07:28,940
nó sẽ chỉ di chuyển
con trỏ của bạn cuối cùng

156
00:07:28,940 --> 00:07:31,100
đến dòng kế tiếp của màn hình.

157
00:07:31,100 --> 00:07:34,270
>> Bây giờ, trong khi đó Scratch có khác
tính năng phức tạp hơn, chỉ

158
00:07:34,270 --> 00:07:37,320
một số trong đó chúng ta sẽ
ban đầu chuyển sang một thế giới của C.

159
00:07:37,320 --> 00:07:40,010
Và một trong số đó là
được gọi là một danh sách trong Scratch.

160
00:07:40,010 --> 00:07:42,100
Và đây là một đặc biệt
loại biến

161
00:07:42,100 --> 00:07:45,840
cho phép bạn lưu trữ nhiều thứ
trong nó trở lại, trở lại, trở lại, để trở lại.

162
00:07:45,840 --> 00:07:48,540
>> Trong C, nó không có
danh sách, mỗi gia nhập, nhưng một cái gì đó

163
00:07:48,540 --> 00:07:51,090
mà nói chung là hơn
gọi là mảng, mặc dù chúng tôi sẽ

164
00:07:51,090 --> 00:07:53,590
quay lại sau học kỳ này
để nhìn vào một cái gì đó

165
00:07:53,590 --> 00:07:55,780
được gọi là một danh sách, hoặc thực sự là một danh sách liên kết.

166
00:07:55,780 --> 00:07:58,510
Nhưng hiện nay, gần nhất
tương đương trong C cho chúng tôi

167
00:07:58,510 --> 00:08:00,345
sẽ là một cái gì đó
gọi là mảng.

168
00:08:00,345 --> 00:08:02,740
Và một mảng chỉ đơn giản là một là
loại đặc biệt của biến

169
00:08:02,740 --> 00:08:06,160
cho phép bạn lưu trữ dữ liệu
trở lại, trở lại, trở lại, trở lại.

170
00:08:06,160 --> 00:08:08,840
>> Và, quả thật vậy, trong Scratch,
nếu chúng ta muốn truy cập

171
00:08:08,840 --> 00:08:12,030
các yếu tố đầu tiên của một mảng hoặc
một list-- và tôi sẽ gọi nó,

172
00:08:12,030 --> 00:08:16,600
theo quy ước, argv, lập luận
vector, nhưng thêm vào đó trước khi dài.

173
00:08:16,600 --> 00:08:20,090
Nếu tôi muốn có được ở các phần tử đầu tiên
argv, trong thế giới của Scratch

174
00:08:20,090 --> 00:08:23,930
bạn thực sự làm thường
bắt đầu đếm từ 1.

175
00:08:23,930 --> 00:08:25,850
>> Và vì vậy tôi có thể nhận được khoản 1 argv.

176
00:08:25,850 --> 00:08:29,310
Đó chỉ là cách MIT thực hiện
khái niệm về danh sách.

177
00:08:29,310 --> 00:08:32,860
Nhưng trong C, tôi sẽ
đơn giản hơn chỉ cần nói, argv,

178
00:08:32,860 --> 00:08:35,758
mà lại là tên của tôi
list-- hoặc để được rõ ràng, một mảng.

179
00:08:35,758 --> 00:08:37,549
Và nếu tôi muốn là người đầu tiên
yếu tố, tôi sẽ

180
00:08:37,549 --> 00:08:40,890
sử dụng dấu ngoặc vuông, mà bạn
có thể không thường xuyên được sử dụng theo một bàn phím.

181
00:08:40,890 --> 00:08:43,150
>> Nhưng 0 chỉ có nghĩa là, làm cho tôi đầu tiên.

182
00:08:43,150 --> 00:08:45,160
Vì vậy, vào dịp và như
thời gian trôi qua, chúng ta sẽ

183
00:08:45,160 --> 00:08:47,570
để bắt đầu thấy những phân đôi
giữa Scratch và C,

184
00:08:47,570 --> 00:08:49,070
theo đó Scratch sử dụng một.

185
00:08:49,070 --> 00:08:50,670
Chúng tôi trong C sử dụng 0 ở đây.

186
00:08:50,670 --> 00:08:52,420
Nhưng bạn sẽ nhanh chóng thấy
một khi bạn hiểu

187
00:08:52,420 --> 00:08:55,920
nền móng của mỗi ngôn ngữ, mà
những điều này bắt đầu để có được tất cả các chi tiết

188
00:08:55,920 --> 00:08:59,860
quen thuộc thông qua thực hành và thực hành.

189
00:08:59,860 --> 00:09:02,700
>> Vì vậy, hãy thực sự nhìn tại một chương trình.

190
00:09:02,700 --> 00:09:07,031
Đây sẽ là lần đầu tiên của C của chúng tôi
mã nguồn cho chương trình hoàn thiện.

191
00:09:07,031 --> 00:09:09,280
Và chương trình chúng ta sẽ
cung cấp để xem xét

192
00:09:09,280 --> 00:09:12,340
là một trong đó là tương đương
cho rằng mảnh Scratch trước đó.

193
00:09:12,340 --> 00:09:16,210
>> Vì vậy, ở đây, chúng tôi có những gì
cho là chương trình đơn giản C

194
00:09:16,210 --> 00:09:18,410
bạn có thể viết rằng
thực sự làm một cái gì đó.

195
00:09:18,410 --> 00:09:21,250
Bây giờ, chúng ta sẽ xem qua,
cho bây giờ, đã bao gồm,

196
00:09:21,250 --> 00:09:24,190
io.h tiêu chuẩn, và các góc
ngoặc, và int và trống không,

197
00:09:24,190 --> 00:09:25,840
và các dấu ngoặc nhọn, và như thế.

198
00:09:25,840 --> 00:09:28,390
>> Và chúng ta chỉ tập trung vào
gì, ít nhất là trực giác,

199
00:09:28,390 --> 00:09:29,860
có thể nhảy vào bạn rồi.

200
00:09:29,860 --> 00:09:33,300
Trong thực tế, chính, tôi không
nhất thiết phải biết điều này là gì,

201
00:09:33,300 --> 00:09:37,580
nhưng giống như Scratch có khi nào
lá cờ màu xanh lá cây nhấp mảnh ghép,

202
00:09:37,580 --> 00:09:42,070
cũng vậy C là một ngôn ngữ lập trình
có một mảnh chính của mã đó

203
00:09:42,070 --> 00:09:46,380
được thực hiện theo mặc định. Và thực sự,
nó là nghĩa đen sẽ được gọi là chính.

204
00:09:46,380 --> 00:09:47,720
>> Vì vậy, chính là một chức năng.

205
00:09:47,720 --> 00:09:51,720
Và đó là một chức năng đặc biệt mà tồn tại
trong C mà khi bạn chạy một chương trình,

206
00:09:51,720 --> 00:09:55,720
nó là chính mà được chạy bởi
mặc định. Trong thế giới của Scratch,

207
00:09:55,720 --> 00:09:59,970
nó thường là khi lá cờ màu xanh lá cây
nhấp đó đã chạy theo mặc định.

208
00:09:59,970 --> 00:10:04,130
>> Trong khi đó, chúng tôi đã nhìn thấy điều này trước đây,
printf hoặc in định dạng, đó là

209
00:10:04,130 --> 00:10:08,620
sẽ là một chức năng mà đi kèm với
C, cùng với một bó toàn bộ của người khác,

210
00:10:08,620 --> 00:10:13,140
rằng sẽ từ thời gian và thời gian
một lần nữa, để làm chính xác

211
00:10:13,140 --> 00:10:15,450
như tên gọi của nó cho thấy, in cái gì.

212
00:10:15,450 --> 00:10:16,500
Những gì chúng tôi muốn in?

213
00:10:16,500 --> 00:10:18,770
Vâng, chúng ta sẽ thấy rằng
bởi nhân vật kèm theo

214
00:10:18,770 --> 00:10:21,680
như these-- thế giới hello,
backslash n trong ngoặc kép,

215
00:10:21,680 --> 00:10:26,040
chúng ta có thể nói chính xác printf
in cái gì trên màn hình.

216
00:10:26,040 --> 00:10:29,430
>> Nhưng để làm được
đó, chúng tôi không may

217
00:10:29,430 --> 00:10:33,010
cần phải thực hiện một điều gì đó
đã khó hiểu với con người chúng ta,

218
00:10:33,010 --> 00:10:37,510
nhưng ít nhất nó hơi readable--
sắc nét bao gồm, io.h chuẩn, int,

219
00:10:37,510 --> 00:10:42,340
chính, void, printf, tất cả các phép thuật
câu thần chú, chúng tôi chỉ nhìn thấy trên màn hình.

220
00:10:42,340 --> 00:10:45,470
Nhưng chúng tôi thực sự phải
đi phức tạp hơn nhiều.

221
00:10:45,470 --> 00:10:50,140
Đầu tiên chúng ta cần để dịch mã
mà chúng tôi viết thành mã máy.

222
00:10:50,140 --> 00:10:54,370
Và nhớ lại từ tuần trước rằng máy móc,
ít nhất là những người chúng tôi biết ở đây,

223
00:10:54,370 --> 00:10:57,450
vào cuối ngày duy nhất
hiểu số không và những người thân.

224
00:10:57,450 --> 00:11:01,100
>> Và Thiên Chúa của tôi, nếu chúng ta đã phải viết những
số không và những người thực sự chương trình,

225
00:11:01,100 --> 00:11:04,260
nó sẽ rất, rất nhanh chóng
mất những niềm vui trong bất cứ điều gì.

226
00:11:04,260 --> 00:11:08,150
Nhưng hóa ra, mỗi tuần cuối cùng,
rằng những mô hình số không và những người thân

227
00:11:08,150 --> 00:11:09,400
chỉ có ý nghĩa đặc biệt.

228
00:11:09,400 --> 00:11:11,500
Trong bối cảnh nhất định,
họ có thể có nghĩa là con số.

229
00:11:11,500 --> 00:11:14,840
>> Trong một số hoàn cảnh, họ có thể có nghĩa là
chữ cái, hoặc màu sắc, hoặc số bất kỳ

230
00:11:14,840 --> 00:11:17,710
trừu tượng hóa khác có thuận.

231
00:11:17,710 --> 00:11:21,450
Nhưng cũng giống như máy tính của bạn có
một CPU, đơn vị xử lý trung tâm,

232
00:11:21,450 --> 00:11:23,390
hoặc bộ não bên trong máy tính của bạn.

233
00:11:23,390 --> 00:11:25,240
Nó thường là Intel
bên trong, bởi vì đó là

234
00:11:25,240 --> 00:11:27,900
một trong những công ty lớn nhất
mà làm cho CPU cho máy tính.

235
00:11:27,900 --> 00:11:31,910
>> Vâng, CPU Intel và những người khác
chỉ đơn giản là đã quyết định trước

236
00:11:31,910 --> 00:11:36,970
rằng một số mô hình của số không và
những người có trách nhiệm có nghĩa là những việc cụ thể.

237
00:11:36,970 --> 00:11:40,040
Một số mô hình của số không và những người thân
sẽ có nghĩa là, in này đến màn hình,

238
00:11:40,040 --> 00:11:42,710
hoặc thêm hai con số này, hoặc
trừ hai con số này,

239
00:11:42,710 --> 00:11:46,310
hoặc di chuyển này mảnh dữ liệu từ
bộ nhớ máy tính của tôi trên đây,

240
00:11:46,310 --> 00:11:50,870
hoặc bất kỳ số lượng mức rất thấp khác,
nhưng cuối cùng hữu ích, hoạt động.

241
00:11:50,870 --> 00:11:56,022
Nhưng, may mắn thay, con người chúng ta sẽ không
cần phải biết mức độ chi tiết này.

242
00:11:56,022 --> 00:11:59,230
Thật vậy, giống như thời gian qua, nơi chúng tôi
trừu tượng hóa một lần nữa, và một lần nữa, và một lần nữa,

243
00:11:59,230 --> 00:12:01,930
xây dựng từ mức rất thấp
nguyên thủy như số không và những người thân

244
00:12:01,930 --> 00:12:04,160
các khái niệm mức độ cao hơn
như số và chữ cái,

245
00:12:04,160 --> 00:12:07,330
và màu sắc, và nhiều hơn nữa,
vì vậy có thể chúng tôi là lập trình viên

246
00:12:07,330 --> 00:12:10,080
đứng trên vai của
những người đã đi trước chúng ta

247
00:12:10,080 --> 00:12:14,260
và sử dụng phần mềm khác
người đã viết trước đây--

248
00:12:14,260 --> 00:12:17,340
cụ thể là các chương trình được gọi là trình biên dịch.

249
00:12:17,340 --> 00:12:20,770
>> C là một ngôn ngữ
thường được biên soạn,

250
00:12:20,770 --> 00:12:25,130
có nghĩa là chuyển đổi từ
mã nguồn thành mã máy.

251
00:12:25,130 --> 00:12:28,230
Đặc biệt, điều này có nghĩa
được rằng nếu bạn đã có mã nguồn của bạn

252
00:12:28,230 --> 00:12:32,530
mã mà bạn tự viết, như chúng ta sớm
sẽ chỉ trong một khoảnh khắc trên màn hình,

253
00:12:32,530 --> 00:12:36,140
và bạn muốn chuyển đổi nó
cuối cùng là máy code--

254
00:12:36,140 --> 00:12:40,100
những số không và những người
chỉ Mac hoặc máy PC của bạn

255
00:12:40,100 --> 00:12:44,230
understands-- bạn đã có một đầu tiên
thức ăn đó mã nguồn trong khi

256
00:12:44,230 --> 00:12:49,340
đầu vào cho một đặc biệt
chương trình gọi là một trình biên dịch,

257
00:12:49,340 --> 00:12:51,974
đầu ra của mà chúng
sẽ thấy là mã máy.

258
00:12:51,974 --> 00:12:54,890
Và, quả thật vậy, thời gian qua, chúng tôi đã nói chuyện
về, thực sự, vào cuối ngày,

259
00:12:54,890 --> 00:12:55,610
giải quyết vấn đề.

260
00:12:55,610 --> 00:12:56,360
Bạn đã có đầu vào.

261
00:12:56,360 --> 00:12:57,318
Và bạn đã có kết quả đầu ra.

262
00:12:57,318 --> 00:12:59,560
Và bạn đã có một số loại
của thuật toán ở giữa.

263
00:12:59,560 --> 00:13:02,830
>> Các thuật toán chắc chắn có thể được
thực hiện trong phần mềm,

264
00:13:02,830 --> 00:13:05,900
như chúng ta đã thấy với giả tuần trước
và như chúng ta sẽ thấy có mã thực tế

265
00:13:05,900 --> 00:13:06,490
tuần này.

266
00:13:06,490 --> 00:13:09,430
Và do đó, một trình biên dịch thực sự chỉ
có một tập hợp các thuật toán bên trong

267
00:13:09,430 --> 00:13:13,060
của nó mà biết làm thế nào để
chuyển đổi các từ khóa đặc biệt,

268
00:13:13,060 --> 00:13:15,180
như chính, và printf,
và những người khác mà chúng ta vừa

269
00:13:15,180 --> 00:13:20,620
thấy vào các mô hình số không và
những người mà Intel bên trong và các CPU

270
00:13:20,620 --> 00:13:23,020
thực sự hiểu.

271
00:13:23,020 --> 00:13:25,460
Vì vậy, làm thế nào để chúng tôi làm điều này?

272
00:13:25,460 --> 00:13:27,470
Nơi nào chúng ta có được một trình biên dịch?

273
00:13:27,470 --> 00:13:29,400
>> Hầu hết chúng ta ở đây có một máy Mac hoặc máy PC.

274
00:13:29,400 --> 00:13:32,152
Và bạn đang chạy Mac OS, hoặc
Windows, hoặc Linux, hoặc Solaris,

275
00:13:32,152 --> 00:13:33,860
hoặc bất kỳ số khác
các hệ điều hành.

276
00:13:33,860 --> 00:13:35,568
Và, quả thật vậy, chúng ta có thể
đi ra ngoài vào web

277
00:13:35,568 --> 00:13:38,710
và tải về một trình biên dịch
dành cho máy Mac hoặc máy PC của bạn

278
00:13:38,710 --> 00:13:40,360
cho hệ điều hành cụ thể của bạn.

279
00:13:40,360 --> 00:13:42,617
Nhưng tất cả chúng ta sẽ được vào
các trang khác nhau, vì vậy để nói chuyện.

280
00:13:42,617 --> 00:13:44,450
Chúng tôi muốn có một chút
cấu hình khác nhau.

281
00:13:44,450 --> 00:13:46,210
Và việc này sẽ không làm việc tất cả như nhau.

282
00:13:46,210 --> 00:13:48,280
Và, quả thật vậy, những ngày này
nhiều người trong chúng ta không sử dụng

283
00:13:48,280 --> 00:13:50,516
phần mềm chỉ chạy trên máy tính xách tay của chúng tôi.

284
00:13:50,516 --> 00:13:52,390
Thay vào đó, chúng tôi sử dụng một cái gì đó
giống như một trình duyệt

285
00:13:52,390 --> 00:13:55,930
cho phép chúng ta truy cập dựa trên web
ứng dụng trong các đám mây.

286
00:13:55,930 --> 00:13:58,630
Và sau học kỳ này,
chúng tôi sẽ làm chính xác điều đó.

287
00:13:58,630 --> 00:14:02,660
Chúng tôi sẽ viết các ứng dụng hay
phần mềm sử dụng code-- không phải C,

288
00:14:02,660 --> 00:14:05,860
nhưng các ngôn ngữ khác như Python và
JavaScript-- chạy trong đám mây.

289
00:14:05,860 --> 00:14:08,860
>> Và để làm được điều đó, chính chúng ta
trong học kỳ

290
00:14:08,860 --> 00:14:14,890
sẽ thực sự sử dụng một đám mây dựa trên
môi trường được gọi là CS50 IDE.

291
00:14:14,890 --> 00:14:19,030
Đây là một chương trình dựa trên web
môi trường, hoặc phát triển tích hợp

292
00:14:19,030 --> 00:14:23,610
môi trường, IDE, đó là xây dựng trên đỉnh một số
phần mềm mã nguồn mở được gọi là Cloud 9.

293
00:14:23,610 --> 00:14:25,966
Và chúng tôi đã thực hiện một số nghiệp vụ sư phạm
đơn giản hóa để nó

294
00:14:25,966 --> 00:14:28,840
để ẩn các tính năng nhất định trong
những tuần đầu tiên mà chúng ta không cần,

295
00:14:28,840 --> 00:14:30,770
sau đó bạn có thể
tiết lộ họ và làm nhất

296
00:14:30,770 --> 00:14:32,400
bất cứ điều gì bạn muốn với môi trường.

297
00:14:32,400 --> 00:14:35,470
>> Và nó cho phép chúng ta nữa, để
cài đặt sẵn phần mềm nào đó.

298
00:14:35,470 --> 00:14:38,330
Những điều như một cái gọi là CS50
thư viện, mà chúng ta sẽ sớm thấy

299
00:14:38,330 --> 00:14:42,210
cung cấp cho chúng tôi trong C với một số
chức năng bổ sung.

300
00:14:42,210 --> 00:14:47,392
Vì vậy, nếu bạn đi đến cuối cùng, CS50.io,
bạn sẽ được nhắc nhở để đăng nhập,

301
00:14:47,392 --> 00:14:49,350
và một khi bạn làm và tạo
một tài khoản miễn phí,

302
00:14:49,350 --> 00:14:55,150
bạn sẽ có thể truy cập vào một
môi trường trông khá như thế này.

303
00:14:55,150 --> 00:14:56,760
>> Bây giờ, điều này là ở chế độ mặc định.

304
00:14:56,760 --> 00:14:58,650
Mọi thứ đều tốt đẹp và
sáng trên màn hình.

305
00:14:58,650 --> 00:15:00,941
Nhiều người trong chúng ta có một thói quen
làm việc trên mảnh đó là CS50

306
00:15:00,941 --> 00:15:02,150
khá muộn vào ban đêm.

307
00:15:02,150 --> 00:15:05,400
Và do đó, một số bạn có thể thích
biến nó thành chế độ ban đêm, vì vậy để nói chuyện.

308
00:15:05,400 --> 00:15:08,550
>> Nhưng, cuối cùng, những gì bạn
sẽ thấy bên trong CS50 IDE

309
00:15:08,550 --> 00:15:11,340
là ba areas-- biệt
một khu vực trên các nơi còn lại

310
00:15:11,340 --> 00:15:15,604
file của bạn đang có được trong
đám mây, một khu vực phía trên bên phải

311
00:15:15,604 --> 00:15:17,270
nơi mà mã của bạn là có thể chỉnh sửa.

312
00:15:17,270 --> 00:15:19,650
Bạn sẽ có thể mở
tab riêng lẻ cho bất kỳ chương trình

313
00:15:19,650 --> 00:15:22,670
mà bạn viết trong học kỳ này bên trong
đó góc trên bên phải.

314
00:15:22,670 --> 00:15:26,070
Và sau đó arcanely nhất,
và chưa mạnh mẽ,

315
00:15:26,070 --> 00:15:29,610
sẽ là điều này tại
đáy biết đến như một cửa sổ terminal.

316
00:15:29,610 --> 00:15:32,450
>> Đây là một trường học cũ
Giao diện dòng lệnh,

317
00:15:32,450 --> 00:15:35,240
hoặc CLI, cho phép
bạn để thực hiện các lệnh

318
00:15:35,240 --> 00:15:38,260
trên computer-- trong trường hợp này,
các máy tính trong cloud--

319
00:15:38,260 --> 00:15:42,090
để làm những việc như biên dịch mã của bạn
từ mã nguồn thành mã máy,

320
00:15:42,090 --> 00:15:46,600
để chạy chương trình của bạn, hoặc để bắt đầu của bạn
máy chủ web, hoặc để truy cập cơ sở dữ liệu của bạn,

321
00:15:46,600 --> 00:15:50,454
và bất kỳ số kỹ thuật khác
rằng chúng ta sẽ bắt đầu sử dụng trước khi dài.

322
00:15:50,454 --> 00:15:52,370
Nhưng để đạt được điều đó, chúng tôi
sẽ thực sự có

323
00:15:52,370 --> 00:15:54,240
để đi trực tuyến và bắt đầu chơi.

324
00:15:54,240 --> 00:15:57,399
Và để làm được điều đó, trước tiên hãy
bắt đầu mày mò với chính,

325
00:15:57,399 --> 00:15:58,940
và viết các phần chính của một chương trình.

326
00:15:58,940 --> 00:16:02,170
Và chúng ta hãy sử dụng chức năng
printf, mà chúng tôi sử dụng trước đó,

327
00:16:02,170 --> 00:16:04,050
đơn giản chỉ để nói một cái gì đó.

328
00:16:04,050 --> 00:16:07,910
>> Vì vậy, ở đây tôi đã được bên trong của CS50 IDE.

329
00:16:07,910 --> 00:16:08,930
Tôi đã đăng nhập trước.

330
00:16:08,930 --> 00:16:10,360
Và tôi hoàn toàn chiếu cửa sổ.

331
00:16:10,360 --> 00:16:12,670
Và như vậy, cuối cùng, bạn có
quá trong vấn đề sắp tới

332
00:16:12,670 --> 00:16:15,960
sẽ thực hiện theo các bước tương tự
sẽ cung cấp tài liệu trực tuyến.

333
00:16:15,960 --> 00:16:19,360
Vì vậy, bạn không cần phải lo lắng về
hấp thụ tất cả các bước kỹ thuật ít

334
00:16:19,360 --> 00:16:20,730
mà tôi làm ở đây ngày hôm nay.

335
00:16:20,730 --> 00:16:22,222
>> Nhưng bạn sẽ nhận được một màn hình như thế này.

336
00:16:22,222 --> 00:16:23,430
Tôi xảy ra được trong chế độ ban đêm.

337
00:16:23,430 --> 00:16:25,944
Và bạn có thể làm sáng tất cả mọi thứ
lên bằng cách tắt chế độ ban đêm.

338
00:16:25,944 --> 00:16:27,860
Và vào cuối của
ngày, bạn sẽ thấy

339
00:16:27,860 --> 00:16:33,090
ba chính areas-- file
trình duyệt ở bên trái, các tab mã lên hàng đầu,

340
00:16:33,090 --> 00:16:35,430
và các cửa sổ terminal ở phía dưới.

341
00:16:35,430 --> 00:16:37,890
>> Hãy để tôi đi trước và
viết chương trình đầu tiên của tôi.

342
00:16:37,890 --> 00:16:45,300
Tôi sẽ làm việc tạm vào File,
Save, và lưu tập tin của tôi như là hello.c.

343
00:16:45,300 --> 00:16:49,850
Thật vậy, theo quy ước, bất kỳ chương trình chúng tôi
viết được được viết bằng ngôn ngữ C

344
00:16:49,850 --> 00:16:52,739
nên được đặt tên là một cái gì đó
dot c, theo quy ước.

345
00:16:52,739 --> 00:16:56,030
Vì vậy, tôi sẽ đặt tên nó hello.c, vì
Tôi chỉ muốn nói xin chào với thế giới.

346
00:16:56,030 --> 00:16:57,820
Bây giờ tôi sẽ để phóng to
ra và bấm Save.

347
00:16:57,820 --> 00:17:01,180
Và tất cả tôi có ở đây bây giờ là một tab
trong đó tôi có thể bắt đầu viết mã.

348
00:17:01,180 --> 00:17:02,490
>> Điều này sẽ không được biên dịch.

349
00:17:02,490 --> 00:17:03,300
Điều này có nghĩa là không có gì.

350
00:17:03,300 --> 00:17:05,750
Và ngay cả nếu tôi chuyển đổi
này để số không và những người thân,

351
00:17:05,750 --> 00:17:08,390
CPU sẽ không có
ý tưởng những gì đang diễn ra xung quanh.

352
00:17:08,390 --> 00:17:17,170
Nhưng nếu tôi viết dòng mà phù hợp
với C phúc conventions-- C,

353
00:17:17,170 --> 00:17:23,150
một lần nữa, điều này language-- với cú pháp như
này, printf chào world-- và tôi đã

354
00:17:23,150 --> 00:17:25,210
nhận được thoải mái với
làm điều này theo thời gian.

355
00:17:25,210 --> 00:17:27,510
Vì vậy, tôi không nghĩ rằng tôi đã thực hiện
bất kỳ lỗi đánh máy.

356
00:17:27,510 --> 00:17:30,910
>> Nhưng, không thay đổi, việc đầu tiên
khi bạn làm điều này, bạn sẽ.

357
00:17:30,910 --> 00:17:34,090
Và những gì tôi về để làm sẽ rất kinh
cũng không làm việc cho bạn lần đầu tiên.

358
00:17:34,090 --> 00:17:36,610
Và đó là hoàn toàn OK,
bởi vì ngay bây giờ bạn

359
00:17:36,610 --> 00:17:40,662
chỉ có thể thấy một toàn bộ rất nhiều sự mới mẻ,
nhưng theo thời gian khi bạn làm quen

360
00:17:40,662 --> 00:17:42,870
với môi trường này, và
ngôn ngữ này, và những người khác,

361
00:17:42,870 --> 00:17:45,370
bạn sẽ bắt đầu thấy những điều mà
hoặc là đúng hay sai.

362
00:17:45,370 --> 00:17:47,369
>> Và đây là những gì
nghiên cứu sinh giảng dạy và học

363
00:17:47,369 --> 00:17:51,780
trợ lý được tốt như vậy tại qua thời gian, được
đốm sai sót hoặc lỗi trong mã của bạn.

364
00:17:51,780 --> 00:17:55,110
Nhưng tôi cho rằng có
không có lỗi trong mã này.

365
00:17:55,110 --> 00:17:56,990
Vì vậy, bây giờ tôi muốn chạy chương trình này.

366
00:17:56,990 --> 00:18:00,440
>> Bây giờ trên máy Mac hoặc máy PC của riêng tôi, tôi đang ở trong
thói quen của các biểu tượng nhấp đúp

367
00:18:00,440 --> 00:18:02,350
khi tôi muốn chạy một số chương trình.

368
00:18:02,350 --> 00:18:04,080
Nhưng đó không phải là mô hình ở đây.

369
00:18:04,080 --> 00:18:07,570
Trong môi trường này, đó là CS50 IDE.

370
00:18:07,570 --> 00:18:10,192
Chúng tôi đang sử dụng một điều hành
hệ thống gọi là Linux.

371
00:18:10,192 --> 00:18:12,900
Linux là gợi nhớ của người khác
hệ điều hành, thường được biết đến

372
00:18:12,900 --> 00:18:13,850
như Unix.

373
00:18:13,850 --> 00:18:19,340
Và Linux được đặc biệt biết đến với
có một Command Line Môi trường, CLI.

374
00:18:19,340 --> 00:18:23,070
Bây giờ, chúng tôi đang sử dụng cụ thể
hương vị của Linux gọi là Ubuntu.

375
00:18:23,070 --> 00:18:25,770
Và Ubuntu chỉ đơn giản là một là
phiên bản nào đó của Linux.

376
00:18:25,770 --> 00:18:30,900
>> Nhưng của các Linux trong những ngày làm thực
đi kèm với giao diện người dùng đồ họa.

377
00:18:30,900 --> 00:18:33,360
Và những gì chúng tôi xảy ra
được sử dụng ở đây là dựa trên web.

378
00:18:33,360 --> 00:18:35,735
Vì vậy, đây có thể nhìn ngay cả một
chút khác nhau từ một cái gì đó

379
00:18:35,735 --> 00:18:38,310
bạn mình có thể có
nhìn thấy hoặc chạy trong quá khứ.

380
00:18:38,310 --> 00:18:40,910
>> Vì vậy, tôi sẽ đi trước
bây giờ và làm như sau.

381
00:18:40,910 --> 00:18:43,950
Tôi đã lưu tập tin này như hello.c.

382
00:18:43,950 --> 00:18:50,350
Tôi sẽ đi trước và
loại clanghello.c Vì vậy Clang

383
00:18:50,350 --> 00:18:52,850
cho ngôn ngữ C là một trình biên dịch.

384
00:18:52,850 --> 00:18:54,952
Nó được cài đặt sẵn trong CS50 IDE.

385
00:18:54,952 --> 00:18:57,910
Và bạn hoàn toàn có thể tải về và
cài đặt này trên máy Mac hoặc máy PC của bạn.

386
00:18:57,910 --> 00:19:00,910
>> Nhưng, một lần nữa, bạn sẽ không có tất cả
pre-cấu hình thực hiện cho bạn.

387
00:19:00,910 --> 00:19:03,940
Vì vậy, bây giờ, tôi chỉ
sẽ chạy clanghello.c.

388
00:19:03,940 --> 00:19:06,240
Và bây giờ nhận thấy cú pháp này
đây sẽ cuối cùng

389
00:19:06,240 --> 00:19:09,930
nhận ra chỉ có nghĩa là tôi đang ở trong một
thư mục hoặc thư mục gọi là Workspace.

390
00:19:09,930 --> 00:19:14,030
ký hiệu đô la này chỉ là ước
ý nghĩa, gõ các lệnh của bạn ở đây.

391
00:19:14,030 --> 00:19:17,560
>> Đó là những gì được gọi là một nhắc nhở, chỉ
theo quy ước là ký hiệu đô la.

392
00:19:17,560 --> 00:19:22,130
Và nếu tôi đi trước bây giờ và nhấp
Nhập, không có gì có vẻ như đã xảy ra.

393
00:19:22,130 --> 00:19:23,930
Nhưng đó thực sự là một điều tốt.

394
00:19:23,930 --> 00:19:26,650
Càng ít xảy ra trên
màn hình của bạn, nhiều khả năng

395
00:19:26,650 --> 00:19:29,710
mã của bạn là đúng,
ít nhất là cú pháp.

396
00:19:29,710 --> 00:19:32,120
>> Vì vậy, nếu tôi muốn chạy này
chương trình, tôi phải làm gì?

397
00:19:32,120 --> 00:19:36,770
Vâng, nó quay ra rằng
Tên mặc định theo quy ước

398
00:19:36,770 --> 00:19:41,854
cho các chương trình khi bạn không chỉ định một
đặt tên cho chương trình của bạn chỉ là a.out.

399
00:19:41,854 --> 00:19:44,270
Và cú pháp này quá, bạn sẽ
làm quen với trước khi dài.

400
00:19:44,270 --> 00:19:50,500
>> Dot giảm chỉ có nghĩa là, hey, CS50
IDE, chạy một chương trình gọi là a.out

401
00:19:50,500 --> 00:19:52,400
đó là bên trong thư mục hiện tại của tôi.

402
00:19:52,400 --> 00:19:54,520
dot đó có nghĩa là thư mục hiện hành.

403
00:19:54,520 --> 00:19:58,040
Và chúng ta sẽ thấy những gì các trình tự khác như
của các nhân vật có nghĩa là trước khi dài.

404
00:19:58,040 --> 00:20:01,430
>> Vì vậy, ở đây chúng tôi đi, Enter, hello thế giới.

405
00:20:01,430 --> 00:20:03,080
Và bạn sẽ nhận thấy, rằng những gì đã xảy ra?

406
00:20:03,080 --> 00:20:04,580
Không chỉ làm nó in hello thế giới.

407
00:20:04,580 --> 00:20:08,990
Nó cũng di chuyển
con trỏ đến dòng kế tiếp.

408
00:20:08,990 --> 00:20:10,160
>> Tại sao lại thế?

409
00:20:10,160 --> 00:20:15,400
mã mà chúng tôi đã viết trước đây là gì
đã bảo đảm rằng con trỏ sẽ

410
00:20:15,400 --> 00:20:17,882
đi trên dòng tiếp theo?

411
00:20:17,882 --> 00:20:19,840
Điều buồn cười về một
máy tính là nó chỉ đi

412
00:20:19,840 --> 00:20:21,570
làm nghĩa đen những gì bạn nói với nó để làm.

413
00:20:21,570 --> 00:20:29,050
>> Vì vậy, nếu bạn cho nó để printf hello,
dấu phẩy, không gian, thế giới, trích dẫn gần gũi,

414
00:20:29,050 --> 00:20:32,090
nó là nghĩa đen chỉ đi
để in những ký tự.

415
00:20:32,090 --> 00:20:34,980
Nhưng tôi đã có nhân vật đặc biệt này
ở cuối, thu hồi, dấu chéo ngược n.

416
00:20:34,980 --> 00:20:37,230
Và đó là những gì đảm bảo
rằng các nhân vật đã đi

417
00:20:37,230 --> 00:20:39,570
đến dòng kế tiếp của màn hình.

418
00:20:39,570 --> 00:20:41,097
>> Trong thực tế, để tôi đi và làm điều này.

419
00:20:41,097 --> 00:20:42,430
Hãy để tôi đi trước và xóa này.

420
00:20:42,430 --> 00:20:44,180
Bây giờ, hãy chú ý
trên màn hình của tôi có

421
00:20:44,180 --> 00:20:45,890
một chút ánh sáng màu đỏ trong
tab cho thấy,

422
00:20:45,890 --> 00:20:48,047
hey, bạn đã không được lưu tập tin của bạn.

423
00:20:48,047 --> 00:20:50,880
Vì vậy, tôi sẽ đi trước với điều khiển
S hoặc lệnh S, lưu tập tin.

424
00:20:50,880 --> 00:20:54,130
Bây giờ nó goes-- đi cho một màu xanh lá cây moment--.

425
00:20:54,130 --> 00:20:56,760
Và bây giờ nó quay trở lại
chỉ là một biểu tượng đóng.

426
00:20:56,760 --> 00:21:04,860
>> Nếu bây giờ tôi chạy clanghello.c một lần nữa,
Nhập, dấu chấm dấu gạch chéo, a.out, Enter,

427
00:21:04,860 --> 00:21:07,110
bạn sẽ thấy rằng nó vẫn làm việc.

428
00:21:07,110 --> 00:21:09,020
Nhưng nó cho là một lỗi nhỏ.

429
00:21:09,020 --> 00:21:11,714
Ngay bây giờ, không gian làm việc prompt-- của tôi,
và sau đó là ký hiệu đô la,

430
00:21:11,714 --> 00:21:13,880
và sau đó prompt-- thực tế của tôi
là tất cả trên cùng một dòng.

431
00:21:13,880 --> 00:21:17,540
Vì vậy, đây chắc chắn là một lỗi thẩm mỹ,
thậm chí nếu nó không thực sự là một lỗi logic.

432
00:21:17,540 --> 00:21:19,250
>> Vì vậy, tôi sẽ hoàn tác những gì tôi chỉ cần làm.

433
00:21:19,250 --> 00:21:21,560
Tôi sẽ chạy lại a.out.

434
00:21:21,560 --> 00:21:25,710
Thông báo của tôi đã thêm
xuống dòng nhân vật trở lại.

435
00:21:25,710 --> 00:21:27,280
Tôi đã lưu tập tin.

436
00:21:27,280 --> 00:21:34,630
>> Vì vậy, tôi sẽ chạy lại a.out, và-
Chết tiệt, một lỗi, một lỗi có nghĩa là sai lầm.

437
00:21:34,630 --> 00:21:38,020
Vì vậy, các lỗi đó là mặc dù
Tôi thêm dấu chéo ngược n có,

438
00:21:38,020 --> 00:21:44,180
tái lưu, tái chạy các chương trình,
hành vi là như nhau.

439
00:21:44,180 --> 00:21:45,640
Tại sao điều đó sẽ là gì?

440
00:21:45,640 --> 00:21:46,910
>> Tôi đang thiếu một bước, phải không?

441
00:21:46,910 --> 00:21:50,620
Đó là bước quan trọng trước là bạn có
với: khi bạn thay đổi mã nguồn của bạn,

442
00:21:50,620 --> 00:21:52,610
Hóa ra cũng chạy
nó thông qua các trình biên dịch

443
00:21:52,610 --> 00:21:54,102
một lần nữa để bạn có được mã máy mới.

444
00:21:54,102 --> 00:21:55,810
Và các mã máy,
các số không và những người thân,

445
00:21:55,810 --> 00:21:59,260
đang có được gần như giống hệt nhau, nhưng
không hoàn toàn như vậy, vì chúng ta cần,

446
00:21:59,260 --> 00:22:00,510
tất nhiên, rằng dòng mới.

447
00:22:00,510 --> 00:22:05,640
>> Vì vậy, để khắc phục điều này, tôi sẽ cần
chạy lại clanghello.c, nhập, chấm

448
00:22:05,640 --> 00:22:06,800
dấu gạch chéo, a.out.

449
00:22:06,800 --> 00:22:11,402
Và bây giờ, xin chào thế giới đã trở lại
đến nơi mà tôi mong đợi nó được.

450
00:22:11,402 --> 00:22:12,610
Vì vậy, đây là tất cả tốt và tốt.

451
00:22:12,610 --> 00:22:16,150
Nhưng a.out là một cái tên khá ngu ngốc cho một
chương trình, mặc dù nó sẽ xảy ra,

452
00:22:16,150 --> 00:22:19,530
vì lý do lịch sử,
default-- nghĩa là đầu ra lắp ráp.

453
00:22:19,530 --> 00:22:23,780
>> Nhưng hãy để tôi đi trước đây
và điều này khác đi.

454
00:22:23,780 --> 00:22:27,760
Tôi muốn chương trình hello thế giới của tôi
để thực sự được gọi là hello.

455
00:22:27,760 --> 00:22:31,320
Vì vậy, nếu nó là một biểu tượng trên của tôi
máy tính để bàn, nó sẽ không được a.out.

456
00:22:31,320 --> 00:22:32,730
Nó sẽ được gọi là hello.

457
00:22:32,730 --> 00:22:36,660
>> Vì vậy, để làm được điều này, nó quay ra
rằng Clang, giống như nhiều chương trình,

458
00:22:36,660 --> 00:22:40,980
hỗ trợ các tham số dòng lệnh,
hoặc cờ, hoặc bị chuyển mạch,

459
00:22:40,980 --> 00:22:42,600
mà đơn giản chỉ ảnh hưởng đến hành vi của nó.

460
00:22:42,600 --> 00:22:48,160
Cụ thể, Clang hỗ trợ o dash
lá cờ, mà sau đó có một từ thứ hai.

461
00:22:48,160 --> 00:22:51,190
Trong trường hợp này, tôi sẽ tùy tiện,
nhưng hợp lý, hãy gọi nó hello.

462
00:22:51,190 --> 00:22:53,710
Nhưng tôi có thể gọi nó là bất cứ điều gì
Tôi muốn, ngoại trừ a.out, mà

463
00:22:53,710 --> 00:22:55,390
sẽ được thay bên cạnh điểm.

464
00:22:55,390 --> 00:22:58,640
>> Và sau đó chỉ cần ghi rõ tên
của các tập tin tôi muốn biên dịch.

465
00:22:58,640 --> 00:23:02,190
Vì vậy, bây giờ thậm chí mặc dù lúc đầu
của lệnh tôi vẫn còn có Clang,

466
00:23:02,190 --> 00:23:04,410
ở phần cuối của lệnh
Tôi vẫn còn có các tên tập tin,

467
00:23:04,410 --> 00:23:08,520
bây giờ tôi có những dòng lệnh
lập luận, những lá cờ đó đang nói,

468
00:23:08,520 --> 00:23:14,180
oh, bằng cách này, đầu ra-o, một tập tin
hello, không phải là a.out mặc định.

469
00:23:14,180 --> 00:23:16,810
>> Vì vậy, nếu tôi nhấn Enter bây giờ, không có gì
dường như đã xảy ra.

470
00:23:16,810 --> 00:23:20,900
Và, đâu, bây giờ tôi có thể làm dấu chấm dấu gạch chéo hello.

471
00:23:20,900 --> 00:23:22,089
Vì vậy, đó là chương trình tương tự.

472
00:23:22,089 --> 00:23:24,380
Các số không và những người thân
giống hệt nhau vào cuối ngày.

473
00:23:24,380 --> 00:23:27,210
>> Nhưng họ đang ở trong hai
a.out files-- khác nhau,

474
00:23:27,210 --> 00:23:29,490
đó là phiên bản đầu tiên
và chỉ cách ngu ngốc đặt tên,

475
00:23:29,490 --> 00:23:33,250
và bây giờ xin chào, đó là một nhiều
nhiều tên hấp dẫn cho một chương trình.

476
00:23:33,250 --> 00:23:36,195
Nhưng, thành thật, tôi không bao giờ
sẽ nhớ điều này một lần nữa,

477
00:23:36,195 --> 00:23:37,070
và một lần nữa, và một lần nữa.

478
00:23:37,070 --> 00:23:39,411
Và thật ra, như chúng ta viết
chương trình phức tạp hơn,

479
00:23:39,411 --> 00:23:41,160
các lệnh bạn
sẽ phải viết

480
00:23:41,160 --> 00:23:43,920
sẽ nhận được thậm chí
phức tạp hơn vẫn còn.

481
00:23:43,920 --> 00:23:44,940
>> Và do đó, không phải lo lắng.

482
00:23:44,940 --> 00:23:49,220
Nó chỉ ra rằng con người trước
chúng tôi đã nhận ra rằng họ quá

483
00:23:49,220 --> 00:23:50,530
có cùng một vấn đề chính xác này.

484
00:23:50,530 --> 00:23:53,900
Họ cũng không thích phải
gõ khá dài, các lệnh phức tạp,

485
00:23:53,900 --> 00:23:55,200
hãy để một mình nhớ chúng.

486
00:23:55,200 --> 00:23:59,070
Và do đó con người trước chúng ta đã thực hiện
các chương trình khác mà làm cho nó dễ dàng hơn

487
00:23:59,070 --> 00:24:00,670
biên dịch phần mềm của bạn.

488
00:24:00,670 --> 00:24:04,609
>> Và, quả thật vậy, một trong những ví dụ
chương trình được gọi là Make.

489
00:24:04,609 --> 00:24:06,150
Vì vậy, tôi sẽ đi trước và làm điều này.

490
00:24:06,150 --> 00:24:08,691
Tôi sẽ lùi lại tất cả mọi thứ tôi
chỉ cần làm theo cách sau.

491
00:24:08,691 --> 00:24:10,690
Hãy để tôi gõ LS.

492
00:24:10,690 --> 00:24:13,980
Và bạn sẽ thấy ba things--
a.out, và một ngôi sao, xin chào

493
00:24:13,980 --> 00:24:15,810
và một ngôi sao, và hello.c.

494
00:24:15,810 --> 00:24:17,730
Hy vọng rằng, điều này cần
có một ít trực quan,

495
00:24:17,730 --> 00:24:21,220
trong chừng mực trước đó đã có
không có gì trong không gian làm việc này.

496
00:24:21,220 --> 00:24:24,240
Chẳng có gì mà tôi đã có
tạo ra cho đến khi chúng tôi bắt đầu lớp.

497
00:24:24,240 --> 00:24:25,840
>> Và tôi đã tạo hello.c.

498
00:24:25,840 --> 00:24:27,544
sau đó tôi biên dịch nó, và gọi nó là a.out.

499
00:24:27,544 --> 00:24:30,460
Và sau đó tôi biên soạn lại một chút
khác nhau và gọi nó là hello.

500
00:24:30,460 --> 00:24:35,830
Vì vậy, tôi có ba tập tin trong thư mục này,
trong thư mục này được gọi là Workspace.

501
00:24:35,830 --> 00:24:38,005
Bây giờ, tôi có thể nhìn thấy điều đó là tốt
nếu tôi thu nhỏ thực sự.

502
00:24:38,005 --> 00:24:40,530
>> Nếu tôi phóng to ra ở đây và
nhìn vào đó trên bên phải

503
00:24:40,530 --> 00:24:42,940
góc, như đã hứa bên trái
bên của màn hình của bạn

504
00:24:42,940 --> 00:24:45,990
luôn luôn là sẽ chỉ cho bạn
những gì trong tài khoản của bạn, những gì

505
00:24:45,990 --> 00:24:47,790
bên trong của CS50 IDE.

506
00:24:47,790 --> 00:24:49,680
Và có ba tập tin đó.

507
00:24:49,680 --> 00:24:52,070
>> Vì vậy, tôi muốn thoát khỏi a.out và chào.

508
00:24:52,070 --> 00:24:54,275
Và như bạn có thể
tưởng tượng trực giác, bạn

509
00:24:54,275 --> 00:24:56,400
có thể sắp xếp kiểm soát nhấp chuột
hoặc click chuột phải vào điều này.

510
00:24:56,400 --> 00:24:57,590
Và đơn này ít bật lên.

511
00:24:57,590 --> 00:25:00,170
Bạn có thể tải về các tập tin, chạy
nó, xem trước nó, làm mới, đổi tên,

512
00:25:00,170 --> 00:25:00,700
hoặc những gì không.

513
00:25:00,700 --> 00:25:03,260
>> Và tôi chỉ có thể xóa,
và nó sẽ biến mất.

514
00:25:03,260 --> 00:25:08,260
Nhưng chúng ta hãy làm việc với một lệnh
dòng cho bây giờ, để có được thoải mái

515
00:25:08,260 --> 00:25:10,010
với điều này, và làm như sau.

516
00:25:10,010 --> 00:25:15,345
Tôi sẽ đi trước và loại bỏ
a.out bằng cách gõ theo nghĩa đen rma.out.

517
00:25:15,345 --> 00:25:17,890
Hóa ra, lệnh cho
loại bỏ hoặc xóa một cái gì đó,

518
00:25:17,890 --> 00:25:19,280
không phải là loại bỏ hoặc xóa.

519
00:25:19,280 --> 00:25:24,260
>> Đó là cách ngắn gọn hơn RM, chỉ để tiết kiệm
bạn một số thao tác bàn phím, và nhấn Enter.

520
00:25:24,260 --> 00:25:27,707
Bây giờ chúng ta sẽ được phần nào
khó hiểu loại bỏ tập tin a.out thường xuyên.

521
00:25:27,707 --> 00:25:30,040
Tôi thực sự không biết những gì một
tập tin bất thường sẽ được nêu ra.

522
00:25:30,040 --> 00:25:31,660
Nhưng tôi muốn loại bỏ nó.

523
00:25:31,660 --> 00:25:33,150
>> Vì vậy, tôi sẽ gõ y cho có.

524
00:25:33,150 --> 00:25:34,940
Hoặc tôi có thể gõ nó ra, và nhấn Enter.

525
00:25:34,940 --> 00:25:36,440
Và, một lần nữa, không có gì có thể xảy ra.

526
00:25:36,440 --> 00:25:38,840
Nhưng đó là, nói chung, là một điều tốt.

527
00:25:38,840 --> 00:25:43,490
>> Nếu tôi gõ LS thời gian này,
Tôi sẽ thấy những gì?

528
00:25:43,490 --> 00:25:47,930
Hy vọng rằng, chỉ chào và hello.c.

529
00:25:47,930 --> 00:25:50,286
Bây giờ, như một sang một bên, bạn sẽ
nhận thấy ngôi sao này, dấu hoa thị,

530
00:25:50,286 --> 00:25:51,660
đó là ở phần cuối của chương trình của tôi.

531
00:25:51,660 --> 00:25:53,201
Và họ cũng đang hiển thị trong màu xanh lá cây.

532
00:25:53,201 --> 00:25:56,970
Đó chỉ là cách CS50 IDE
của cluing bạn vào thực tế

533
00:25:56,970 --> 00:25:58,280
rằng đó không phải là mã nguồn.

534
00:25:58,280 --> 00:26:01,880
Đó là một thực thi, một Runnable
chương trình mà bạn thực sự có thể chạy

535
00:26:01,880 --> 00:26:04,020
bằng cách làm dấu chấm dấu gạch chéo, và sau đó tên của nó.

536
00:26:04,020 --> 00:26:08,860
>> Bây giờ, hãy để tôi đi trước và loại bỏ
này, rm hello, Enter, loại bỏ thường xuyên

537
00:26:08,860 --> 00:26:11,010
nộp xin chào, có.

538
00:26:11,010 --> 00:26:14,180
Và bây giờ nếu tôi gõ LS,
Chúng ta trở lại hello.c.

539
00:26:14,180 --> 00:26:16,917
Cố gắng không để xóa của bạn
mã nguồn thực tế.

540
00:26:16,917 --> 00:26:19,250
Mặc dù có những tính năng
được xây dựng vào CS50 IDE nơi

541
00:26:19,250 --> 00:26:22,870
bạn có thể đi qua lịch sử sửa đổi của bạn
và tua lại trong thời gian nếu bạn vô tình

542
00:26:22,870 --> 00:26:26,660
xóa cái gì, làm được tâm
theo các hướng dẫn có hoặc không,

543
00:26:26,660 --> 00:26:28,381
những gì bạn thực sự muốn làm.

544
00:26:28,381 --> 00:26:30,380
Và nếu tôi đi lên đến đỉnh
góc bên trái bàn tay ở đây,

545
00:26:30,380 --> 00:26:33,696
tất cả những gì còn lại là hello.c.

546
00:26:33,696 --> 00:26:35,570
Vì vậy, có chùm
lệnh khác mà bạn

547
00:26:35,570 --> 00:26:40,550
có thể thực hiện trong thế giới của Linux,
một trong số đó là, một lần nữa, làm.

548
00:26:40,550 --> 00:26:43,180
Và chúng ta sẽ làm
chương trình của tôi bây giờ như sau.

549
00:26:43,180 --> 00:26:46,270
>> Thay vì làm vang,
thay vì làm vang-o,

550
00:26:46,270 --> 00:26:48,860
Tôi sẽ chỉ đơn giản
nghĩa đen gõ, làm hello.

551
00:26:48,860 --> 00:26:52,630
Và bây giờ để ý, tôi
không gõ làm hello.c.

552
00:26:52,630 --> 00:26:53,910
Tôi gõ làm hello.

553
00:26:53,910 --> 00:26:57,840
>> Và chương trình này Làm cho rằng
đi kèm với IDE CS50, và nhiều hơn nữa

554
00:26:57,840 --> 00:27:00,090
nói chung với Linux,
là một chương trình đó là

555
00:27:00,090 --> 00:27:02,120
sẽ thực hiện một chương trình gọi là Hello.

556
00:27:02,120 --> 00:27:06,680
Và nó sẽ giả định, theo quy ước,
rằng nếu chương trình này có thể được thực hiện,

557
00:27:06,680 --> 00:27:12,030
nó sẽ được thực hiện từ một nguồn
mã tập tin kết thúc bằng dấu chấm c, hello.c.

558
00:27:12,030 --> 00:27:15,210
>> Vì vậy, nếu tôi nhấn Enter bây giờ, thông báo rằng
lệnh đó được thực thi

559
00:27:15,210 --> 00:27:17,340
là thực sự thậm chí còn
trước so với trước đây.

560
00:27:17,340 --> 00:27:19,670
Và đó là bởi vì chúng tôi đã
cấu hình sẵn CS50 IDE có

561
00:27:19,670 --> 00:27:22,878
một số tính năng bổ sung xây dựng trong đó
chúng ta không cần chỉ được nêu ra, nhưng sớm biết thôi.

562
00:27:22,878 --> 00:27:26,470
Nhưng điều quan trọng để nhận ra
là bây giờ tôi có một chương trình Hello.

563
00:27:26,470 --> 00:27:30,080
>> Nếu tôi gõ LS lần nữa, tôi
có một chương trình hello.

564
00:27:30,080 --> 00:27:35,070
Và tôi có thể chạy nó với
dot giảm a.out, không,

565
00:27:35,070 --> 00:27:38,590
bởi vì toàn bộ các điểm này
tập thể dục là dấu chấm dấu gạch chéo hello.

566
00:27:38,590 --> 00:27:41,089
Và bây giờ tôi có chương trình hello thế giới của tôi.

567
00:27:41,089 --> 00:27:42,880
Vì vậy, di chuyển về phía trước,
chúng tôi hầu như luôn luôn chỉ

568
00:27:42,880 --> 00:27:45,088
sẽ biên dịch chương trình của chúng tôi
sử dụng Make lệnh.

569
00:27:45,088 --> 00:27:48,300
Và sau đó chúng ta sẽ chạy chúng bằng cách
dot gạch chéo, và tên của chương trình.

570
00:27:48,300 --> 00:27:52,610
Nhưng nhận ra những gì Hãy là làm cho
bạn, là nó là chính nó không phải là một trình biên dịch.

571
00:27:52,610 --> 00:27:56,310
Nó chỉ là một chương trình tiện
mà biết làm thế nào để kích hoạt một trình biên dịch

572
00:27:56,310 --> 00:27:59,470
chạy để bạn mình có thể sử dụng nó.

573
00:27:59,470 --> 00:28:03,220
>> Những lệnh khác tồn tại trong
Linux, và lần lượt các CS50 IDE?

574
00:28:03,220 --> 00:28:06,107
Chúng tôi sẽ sớm thấy rằng có một
lệnh CD, Change Directory.

575
00:28:06,107 --> 00:28:08,190
Điều này cho phép bạn trong vòng
giao diện dòng lệnh của bạn

576
00:28:08,190 --> 00:28:10,610
để di chuyển về phía trước, và trở lại,
và mở các thư mục khác nhau

577
00:28:10,610 --> 00:28:11,860
mà không cần sử dụng con chuột của bạn.

578
00:28:11,860 --> 00:28:15,470
>> LS chúng ta đã thấy, đó là viết tắt của danh sách
các tập tin trong thư mục hiện hành.

579
00:28:15,470 --> 00:28:17,650
Hãy Dir, bạn có thể
có thể bắt đầu để suy ra

580
00:28:17,650 --> 00:28:21,150
những gì chúng có ý nghĩa now-- tạo thư mục,
nếu bạn muốn tạo một thư mục.

581
00:28:21,150 --> 00:28:24,270
RM cho remove, RM Dir cho
loại bỏ directory-- và những,

582
00:28:24,270 --> 00:28:27,160
một lần nữa, là những dòng lệnh
tương đương của bạn

583
00:28:27,160 --> 00:28:29,945
có thể làm trong CS50 IDE với con chuột của bạn.

584
00:28:29,945 --> 00:28:31,820
Nhưng bạn sẽ sớm tìm thấy
mà đôi khi nó chỉ là

585
00:28:31,820 --> 00:28:33,610
nhanh hơn rất nhiều để làm
việc với một bàn phím,

586
00:28:33,610 --> 00:28:36,690
và cuối cùng là rất nhiều mạnh mẽ hơn.

587
00:28:36,690 --> 00:28:39,440
>> Nhưng thật khó để tranh luận rằng
bất cứ điều gì chúng tôi đã làm cho đến nay

588
00:28:39,440 --> 00:28:42,990
là tất cả những gì mạnh mẽ, khi tất cả
chúng tôi đã nói là, hello thế giới.

589
00:28:42,990 --> 00:28:46,740
Và, trên thực tế, tôi hardcoded sự
lời chào thế giới vào chương trình của tôi.

590
00:28:46,740 --> 00:28:48,530
Không có động lực nào.

591
00:28:48,530 --> 00:28:52,320
Scratch là một bậc
thú vị hơn tuần trước.

592
00:28:52,320 --> 00:28:54,220
>> Và như vậy chúng ta hãy đến đó.

593
00:28:54,220 --> 00:28:58,310
Chúng ta hãy bước về phía đó bằng
cách của một số các chức năng này.

594
00:28:58,310 --> 00:29:02,470
Vì vậy, không chỉ C đi kèm với printf,
và chùm chức năng khác

595
00:29:02,470 --> 00:29:04,850
một số trong đó chúng ta sẽ thấy
theo thời gian, nó không

596
00:29:04,850 --> 00:29:08,760
làm cho nó tất cả những gì dễ dàng ngay
cổng trong việc sử dụng đầu vào.

597
00:29:08,760 --> 00:29:11,140
>> Trong thực tế, một trong những điểm yếu
các ngôn ngữ như C,

598
00:29:11,140 --> 00:29:13,140
và thậm chí cả Java và chưa
những người khác, đó là nó không

599
00:29:13,140 --> 00:29:18,860
làm cho nó dễ dàng chỉ cần có được những thứ như
số nguyên từ người dùng, hoặc các chuỗi, lời nói,

600
00:29:18,860 --> 00:29:22,970
và cụm từ, hãy để mọi thứ một mình như
nổi điểm giá trị, hoặc số thực

601
00:29:22,970 --> 00:29:26,240
với điểm thập phân, và thực sự
số dài, như chúng ta sẽ sớm thấy.

602
00:29:26,240 --> 00:29:30,000
Vì vậy, danh sách các chức năng ở đây, những
là giống như miếng Scratch câu đố khác

603
00:29:30,000 --> 00:29:34,090
mà chúng ta đã cài đặt sẵn trong CS50
IDE mà chúng ta sẽ sử dụng cho một vài tuần

604
00:29:34,090 --> 00:29:37,010
như bánh xe đào tạo của các loại, và
cuối cùng đưa họ ra, và tìm

605
00:29:37,010 --> 00:29:40,210
bên dưới mui xe, có lẽ, ở
làm thế nào những điều được thực hiện.

606
00:29:40,210 --> 00:29:43,460
>> Nhưng để làm được điều này, chúng ta hãy
thực sự viết một chương trình.

607
00:29:43,460 --> 00:29:44,770
Hãy để tôi đi trước bây giờ.

608
00:29:44,770 --> 00:29:47,750
Và tôi sẽ tạo ra một mới
nộp bằng cách nhấn vào dấu cộng nhỏ này,

609
00:29:47,750 --> 00:29:48,970
và click vào New File.

610
00:29:48,970 --> 00:29:52,250
>> Tôi sẽ tiết kiệm này bên cạnh
một là, hãy nói, string.c,

611
00:29:52,250 --> 00:29:53,750
bởi vì tôi muốn chơi với chuỗi.

612
00:29:53,750 --> 00:29:56,990
Và chuỗi trong C chỉ là
một chuỗi các ký tự.

613
00:29:56,990 --> 00:29:59,090
Vì vậy, bây giờ hãy đi trước
và làm như sau.

614
00:29:59,090 --> 00:30:04,204
>> Bao gồm các tiêu chuẩn và IO.h--
nó quay ra chuẩn IO,

615
00:30:04,204 --> 00:30:06,360
IO chỉ có nghĩa là đầu vào và đầu ra.

616
00:30:06,360 --> 00:30:08,920
Vì vậy, nó chỉ ra rằng
dòng này ở đây là gì

617
00:30:08,920 --> 00:30:11,140
được các nước láng giềng chúng ta sử dụng printf.

618
00:30:11,140 --> 00:30:13,410
Printf, tất nhiên, sản lượng sản xuất.

619
00:30:13,410 --> 00:30:18,000
Vì vậy, để sử dụng printf, nó quay
ra bạn phải có dòng mã này

620
00:30:18,000 --> 00:30:19,040
ở đầu tập tin của bạn.

621
00:30:19,040 --> 00:30:21,456
>> Và chúng tôi sẽ trở lại với những gì
mà thực sự có nghĩa là trước khi dài.

622
00:30:21,456 --> 00:30:23,400
Nó chỉ ra rằng trong
bất kỳ chương trình C tôi viết,

623
00:30:23,400 --> 00:30:26,640
Tôi phải bắt đầu nó với
mã trông như thế này.

624
00:30:26,640 --> 00:30:29,860
Và bạn sẽ nhận thấy CS50 IDE, và
phát triển tích hợp khác

625
00:30:29,860 --> 00:30:33,050
môi trường như nó,
sẽ cố gắng làm tốt nhất

626
00:30:33,050 --> 00:30:34,780
họ có thể để kết thúc suy nghĩ của bạn.

627
00:30:34,780 --> 00:30:38,930
Trong thực tế, một khoảnh khắc trước khi tôi hoàn tác
những gì tôi vừa làm, tôi nhấn Enter.

628
00:30:38,930 --> 00:30:42,160
>> sau đó tôi nhấn xoăn mở
cú đúp, nhấn Enter lần nữa.

629
00:30:42,160 --> 00:30:43,430
Và nó đã hoàn thành suy nghĩ của tôi.

630
00:30:43,430 --> 00:30:48,140
Nó đã cho tôi một dòng mới, thụt không kém
vì lý do phong cách đẹp chúng ta sẽ thấy.

631
00:30:48,140 --> 00:30:51,559
Và sau đó nó tự động đã cho tôi
mà cú đúp xoăn để kết thúc suy nghĩ của tôi.

632
00:30:51,559 --> 00:30:53,600
Bây giờ, nó không luôn luôn
đoán những gì bạn muốn làm.

633
00:30:53,600 --> 00:30:56,620
Nhưng phần lớn, nó
bạn tiết kiệm một số tổ hợp phím.

634
00:30:56,620 --> 00:31:02,560
Vì vậy, một thời gian trước đây, chúng tôi chạy program-- này
hello, thế giới, và sau đó biên dịch nó,

635
00:31:02,560 --> 00:31:03,460
và sau đó chạy nó.

636
00:31:03,460 --> 00:31:04,867
Nhưng không có tính năng động ở đây.

637
00:31:04,867 --> 00:31:06,700
Nếu chúng ta muốn
làm một cái gì khác nhau?

638
00:31:06,700 --> 00:31:10,630
Vâng, những gì nếu tôi muốn thực sự
nhận được một chuỗi từ người sử dụng?

639
00:31:10,630 --> 00:31:14,250
Tôi sẽ sử dụng một mảnh ghép
gọi là chính xác mà-- nhận được chuỗi.

640
00:31:14,250 --> 00:31:18,860
>> Hóa ra trong C mà khi bạn không muốn
để cung cấp đầu vào cho một mảnh ghép,

641
00:31:18,860 --> 00:31:22,360
hay đúng hơn một chức năng, bạn
nghĩa đen chỉ làm ngoặc mở,

642
00:31:22,360 --> 00:31:23,430
ngoặc đóng.

643
00:31:23,430 --> 00:31:28,540
Vì vậy, nó như thể có
không có hộp màu trắng để đánh vào.

644
00:31:28,540 --> 00:31:30,720
Tiếng nói khối trước
đã có một hộp nhỏ màu trắng.

645
00:31:30,720 --> 00:31:32,660
Chúng tôi không có mà hộp trắng bây giờ.

646
00:31:32,660 --> 00:31:36,310
>> Nhưng khi tôi gọi get chuỗi, tôi
muốn đặt kết quả ở đâu đó.

647
00:31:36,310 --> 00:31:40,680
Vì vậy, một mô hình rất phổ biến trong C là
gọi một chức năng, như get chuỗi ở đây,

648
00:31:40,680 --> 00:31:44,070
và sau đó lưu trữ giá trị trả về của nó.

649
00:31:44,070 --> 00:31:47,450
Đó là kết quả của nó
nỗ lực trong một cái gì đó.

650
00:31:47,450 --> 00:31:50,630
>> Và là những gì
xây dựng trong chương trình,

651
00:31:50,630 --> 00:31:56,450
cho dù trong Scratch hay bây giờ C, mà chúng ta
có thể sử dụng để thực sự lưu trữ một cái gì đó?

652
00:31:56,450 --> 00:31:58,990
Gọi nó là một biến, phải không?

653
00:31:58,990 --> 00:32:03,320
Và trong Scratch, chúng tôi không thực sự
quan tâm những gì đang diễn ra trong các biến.

654
00:32:03,320 --> 00:32:05,170
>> Nhưng trong trường hợp này, chúng tôi thực sự làm.

655
00:32:05,170 --> 00:32:06,719
Tôi sẽ nói chuỗi.

656
00:32:06,719 --> 00:32:08,510
Và sau đó tôi có thể gọi
bất cứ điều gì tôi muốn này.

657
00:32:08,510 --> 00:32:11,340
Tôi sẽ gọi nó
tên, được nhận được chuỗi.

658
00:32:11,340 --> 00:32:13,250
>> Và bây giờ, ngay cả khi bạn đang
một chút mới này,

659
00:32:13,250 --> 00:32:14,984
nhận thấy rằng tôi đang thiếu một số chi tiết.

660
00:32:14,984 --> 00:32:16,150
Tôi quên một dấu chấm phẩy.

661
00:32:16,150 --> 00:32:17,400
Tôi cần phải kết thúc suy nghĩ này.

662
00:32:17,400 --> 00:32:20,480
Vì vậy, tôi sẽ di chuyển con trỏ của tôi,
và đánh dấu chấm phẩy ở đó.

663
00:32:20,480 --> 00:32:22,130
Và những gì đã tôi chỉ thực hiện?

664
00:32:22,130 --> 00:32:24,440
Trong dòng mã này,
số 5 vào lúc này,

665
00:32:24,440 --> 00:32:26,799
Tôi gọi chuỗi get không có đầu vào.

666
00:32:26,799 --> 00:32:29,090
Vì vậy, không có chút trắng
hộp như Save block có.

667
00:32:29,090 --> 00:32:31,590
>> Tôi chỉ nói rằng, hey,
máy tính, làm cho tôi một chuỗi.

668
00:32:31,590 --> 00:32:34,390
Các dấu bằng là không thực sự
một dấu bằng, mỗi se.

669
00:32:34,390 --> 00:32:36,790
Đó là sự phân công
điều hành, có nghĩa là,

670
00:32:36,790 --> 00:32:40,860
hey, máy tính, di chuyển các giá trị
từ bên phải qua bên trái.

671
00:32:40,860 --> 00:32:43,480
Và ở bên trái, tôi có sau.

672
00:32:43,480 --> 00:32:46,580
>> Hey, máy tính, cho tôi một string--
một chuỗi các ký tự.

673
00:32:46,580 --> 00:32:48,637
Và gọi đó là chuỗi Name.

674
00:32:48,637 --> 00:32:50,220
Và tôi thậm chí không cần phải gọi nó tên.

675
00:32:50,220 --> 00:32:52,970
>> Tôi có thể gọi nó, thông thường,
một cái gì đó giống như S,

676
00:32:52,970 --> 00:32:55,900
giống như chúng ta sử dụng i để
gọi các biến i.

677
00:32:55,900 --> 00:32:57,829
Nhưng bây giờ tôi cần phải làm một cái gì đó với nó.

678
00:32:57,829 --> 00:33:00,370
Nó sẽ được khá ngu ngốc để
thử biên dịch mã này, chạy

679
00:33:00,370 --> 00:33:02,410
chương trình này, mặc dù
Tôi nhận được một chuỗi,

680
00:33:02,410 --> 00:33:04,580
bởi vì nó vẫn chỉ là
sẽ nói hello thế giới.

681
00:33:04,580 --> 00:33:09,140
>> Nhưng những gì nếu tôi muốn thay đổi điều này.

682
00:33:09,140 --> 00:33:10,940
Tại sao tôi không làm được điều này?

683
00:33:10,940 --> 00:33:14,632
Phần trăm s, dấu phẩy s.

684
00:33:14,632 --> 00:33:16,090
Và đây là một chút khó hiểu vẫn còn.

685
00:33:16,090 --> 00:33:18,560
>> Vì vậy, hãy để tôi làm cho các biến của tôi rõ ràng hơn.

686
00:33:18,560 --> 00:33:20,510
Hãy để tôi đặt tên biến Tên này.

687
00:33:20,510 --> 00:33:23,230
Và chúng ta hãy xem nếu chúng ta không thể trêu chọc
ngoài những gì đang xảy ra ở đây.

688
00:33:23,230 --> 00:33:25,770
>> Vì vậy, trên đường năm, tôi nhận được một chuỗi.

689
00:33:25,770 --> 00:33:28,620
Và tôi đang lưu trữ chuỗi,
bất cứ điều gì người dùng đã gõ trong

690
00:33:28,620 --> 00:33:31,430
vào bàn phím của mình,
trong một biến gọi là Danh.

691
00:33:31,430 --> 00:33:33,590
Và nó chỉ ra rằng
printf không chỉ

692
00:33:33,590 --> 00:33:37,220
đưa một đối số trong đôi
dấu ngoặc kép, một đầu vào trong dấu ngoặc kép.

693
00:33:37,220 --> 00:33:42,100
>> Nó có thể mất hai, hoặc ba, hoặc nhiều hơn, chẳng hạn
rằng thứ hai, hoặc thứ ba, hay thứ tư,

694
00:33:42,100 --> 00:33:45,320
là tất cả các tên của các biến,
hay cụ thể giá trị,

695
00:33:45,320 --> 00:33:51,610
mà bạn muốn cắm vào,
động, mà chuỗi trong dấu ngoặc kép.

696
00:33:51,610 --> 00:33:55,110
Nói cách khác, những gì
sẽ là sai với điều này?

697
00:33:55,110 --> 00:34:00,920
Nếu tôi chỉ nói xin chào, tên, dấu chéo ngược
n, lưu tập tin của tôi, biên dịch mã của tôi,

698
00:34:00,920 --> 00:34:04,660
và chạy này, điều gì sẽ xảy ra?

699
00:34:04,660 --> 00:34:08,139
>> Nó chỉ sẽ nói, xin chào
tên, nghĩa là N-A-M-E,

700
00:34:08,139 --> 00:34:10,900
đó là loại ngu ngốc vì
nó không có gì khác biệt so với thế giới.

701
00:34:10,900 --> 00:34:13,400
Vì vậy, bất cứ điều gì trong dấu ngoặc kép là
những gì theo nghĩa đen được in.

702
00:34:13,400 --> 00:34:15,520
Vì vậy, nếu tôi muốn có
một giữ chỗ đó,

703
00:34:15,520 --> 00:34:17,422
Tôi thực sự cần phải sử dụng
một số cú pháp đặc biệt.

704
00:34:17,422 --> 00:34:20,380
Và hóa ra nếu bạn đọc
tài liệu hướng dẫn cho các chức năng printf,

705
00:34:20,380 --> 00:34:24,320
nó sẽ cho bạn biết rằng
nếu bạn sử dụng phần trăm s,

706
00:34:24,320 --> 00:34:26,920
bạn có thể thay thế một giá trị như sau.

707
00:34:26,920 --> 00:34:30,190
>> Sau một dấu phẩy sau đó
báo giá gấp đôi, bạn chỉ đơn giản

708
00:34:30,190 --> 00:34:32,179
viết tên của
biến mà bạn muốn

709
00:34:32,179 --> 00:34:36,790
cắm vào định dạng mà
mã, hoặc format specifier,

710
00:34:36,790 --> 00:34:38,469
phần trăm của các chuỗi.

711
00:34:38,469 --> 00:34:42,190
Và bây giờ nếu tôi đã lưu tập tin của tôi,
Tôi quay trở lại xuống đến thiết bị đầu cuối của tôi.

712
00:34:42,190 --> 00:34:45,870
Và tôi gõ Tạo String,
bởi vì, một lần nữa, cái tên này

713
00:34:45,870 --> 00:34:48,510
tập tin mà tôi đã chọn trước là string.c.

714
00:34:48,510 --> 00:34:51,510
>> Vì vậy, tôi sẽ nói Hãy String, nhập.

715
00:34:51,510 --> 00:34:54,550
Ôi lòng tốt, nhìn vào tất cả
những sai lầm, chúng tôi đã thực hiện rồi.

716
00:34:54,550 --> 00:34:58,540
Và điều này hợp-- gì, điều này thực sự là
như một sáu, chương trình dòng bảy?

717
00:34:58,540 --> 00:35:00,790
Vì vậy, đây là nơi mà nó có thể rất
nhanh chóng có được áp đảo.

718
00:35:00,790 --> 00:35:03,890
>> cửa sổ thiết bị đầu cuối này có
bây giờ chỉ cần nhả

719
00:35:03,890 --> 00:35:06,230
một số lượng lớn các thông báo lỗi.

720
00:35:06,230 --> 00:35:10,560
Chắc chắn, tôi không có nhiều lỗi
thông điệp hơn là tôi có dòng mã.

721
00:35:10,560 --> 00:35:11,680
Vậy chuyện gì đang xảy ra thế?

722
00:35:11,680 --> 00:35:13,920
>> Vâng, chiến lược tốt nhất
làm bất cứ lúc nào bạn

723
00:35:13,920 --> 00:35:16,710
làm gặp phải một áp đảo
danh sách các lỗi như thế,

724
00:35:16,710 --> 00:35:19,690
được di chuyển trở lại, tìm kiếm các lệnh
bạn chỉ cần chạy, mà trong trường hợp của tôi

725
00:35:19,690 --> 00:35:21,020
là làm cho chuỗi.

726
00:35:21,020 --> 00:35:24,630
Nhìn vào những gì làm đã làm, và đó là điều đó
lệnh dài Clang, không có việc lớn đó.

727
00:35:24,630 --> 00:35:25,950
>> Nhưng màu đỏ là xấu.

728
00:35:25,950 --> 00:35:27,750
Xanh là cố gắng để được
nhẹ nhàng và hữu ích.

729
00:35:27,750 --> 00:35:29,140
Nhưng nó vẫn còn xấu, trong trường hợp này.

730
00:35:29,140 --> 00:35:30,510
Nhưng đâu là nó xấu?

731
00:35:30,510 --> 00:35:34,450
>> String.c, dòng năm, nhân vật năm.

732
00:35:34,450 --> 00:35:35,930
Vì vậy, đây chỉ là quy ước chung.

733
00:35:35,930 --> 00:35:39,060
Một cái gì đó đại tràng một cái gì đó có nghĩa là
số dòng và số nhân vật.

734
00:35:39,060 --> 00:35:44,080
Lỗi, sử dụng không khai báo
nhận dạng chuỗi.

735
00:35:44,080 --> 00:35:45,900
Ý của bạn là tiêu chuẩn trong?

736
00:35:45,900 --> 00:35:48,530
>> Vì vậy, thật không may, Clang
đang cố gắng để được giúp đỡ.

737
00:35:48,530 --> 00:35:49,850
Nhưng đó là sai, trong trường hợp này.

738
00:35:49,850 --> 00:35:52,350
Không, Clang, tôi không có nghĩa là tiêu chuẩn IO.

739
00:35:52,350 --> 00:35:54,070
Tôi có nghĩa là trên một dòng, có.

740
00:35:54,070 --> 00:35:56,420
>> Nhưng dòng năm là này ở đây.

741
00:35:56,420 --> 00:36:00,040
Và Clang không
hiểu S-T-R-I-N-G.

742
00:36:00,040 --> 00:36:04,490
Đó là một định không khai báo, một
từ đó nó chỉ chưa bao giờ thấy trước đây.

743
00:36:04,490 --> 00:36:08,730
Và đó là bởi vì C, ngôn ngữ
chúng ta đang viết mã trong ngay bây giờ,

744
00:36:08,730 --> 00:36:11,070
không có các biến được gọi là chuỗi.

745
00:36:11,070 --> 00:36:14,380
>> Nó không, theo mặc định, hỗ trợ
một cái gì đó gọi là một chuỗi.

746
00:36:14,380 --> 00:36:19,750
Đó là một mảnh của CS50
thuật ngữ, nhưng rất thông thường.

747
00:36:19,750 --> 00:36:21,600
Nhưng tôi có thể sửa lỗi này như sau.

748
00:36:21,600 --> 00:36:25,090
>> Nếu tôi thêm một dòng mã
để đầu của chương trình này,

749
00:36:25,090 --> 00:36:30,890
bao gồm CS50.h, mà là một tập tin khác
ở đâu đó bên trong CS50 IDE, ở đâu đó

750
00:36:30,890 --> 00:36:33,820
trên ổ đĩa cứng, có thể nói,
của hệ điều hành Ubuntu

751
00:36:33,820 --> 00:36:36,590
rằng tôi đang chạy, mà
là tập tin đó

752
00:36:36,590 --> 00:36:41,740
sẽ dạy cho các điều hành
hệ thống những gì một chuỗi là, chỉ cần

753
00:36:41,740 --> 00:36:44,930
như io.h tiêu chuẩn là các tập tin
trong hệ điều hành đó là

754
00:36:44,930 --> 00:36:47,430
sẽ dạy cho nó là gì printf.

755
00:36:47,430 --> 00:36:49,810
>> Thật vậy, chúng ta đã có thể nhận
một thông điệp rất tương tự

756
00:36:49,810 --> 00:36:53,600
nếu IO đã thừa nhận tiêu chuẩn
IO.h và cố gắng sử dụng printf.

757
00:36:53,600 --> 00:36:56,632
Vì vậy, tôi sẽ đi trước và chỉ
mất kiểm soát L để xóa màn hình của tôi.

758
00:36:56,632 --> 00:36:59,340
Hoặc bạn có thể gõ rõ ràng và nó sẽ
chỉ cần xóa sổ thiết bị đầu cuối.

759
00:36:59,340 --> 00:37:01,020
Nhưng bạn vẫn có thể di chuyển trở lại trong thời gian.

760
00:37:01,020 --> 00:37:04,100
>> Và tôi sẽ chạy lại Hãy String.

761
00:37:04,100 --> 00:37:06,660
Qua các ngón tay của tôi lần này, Enter.

762
00:37:06,660 --> 00:37:08,380
Ôi Chúa ơi, nó làm việc.

763
00:37:08,380 --> 00:37:12,280
nó cho thấy tôi một lệnh dài khó hiểu
đó là những gì Hãy tạo ra thông qua Clang,

764
00:37:12,280 --> 00:37:13,460
nhưng không có thông báo lỗi.

765
00:37:13,460 --> 00:37:15,460
Vì vậy, nhận ra, mặc dù
bạn có thể nhận được hoàn toàn

766
00:37:15,460 --> 00:37:17,480
choáng ngợp với
số thông báo lỗi,

767
00:37:17,480 --> 00:37:20,540
nó chỉ có thể là tầng này gây phiền nhiễu
hiệu lực, nơi Clang không hiểu

768
00:37:20,540 --> 00:37:22,620
một điều, có nghĩa là nó sau đó
không hiểu từ kế tiếp,

769
00:37:22,620 --> 00:37:23,560
hoặc các dòng tiếp theo.

770
00:37:23,560 --> 00:37:25,850
Và do đó, nó chỉ cuộn cảm trên mã của bạn.

771
00:37:25,850 --> 00:37:27,440
Nhưng việc sửa chữa có thể là đơn giản.

772
00:37:27,440 --> 00:37:30,822
Và do đó, luôn tập trung vào các
dòng đầu tiên của đầu ra.

773
00:37:30,822 --> 00:37:32,530
Và nếu bạn không
hiểu nó, chỉ cần nhìn

774
00:37:32,530 --> 00:37:35,480
cho các từ khóa đó có thể là
manh mối, và số dòng,

775
00:37:35,480 --> 00:37:37,650
và các nhân vật, nơi
sai lầm mà có thể được.

776
00:37:37,650 --> 00:37:43,328
>> Bây giờ hãy để tôi đi trước và gõ
dot dấu gạch chéo, chuỗi, nhập.

777
00:37:43,328 --> 00:37:47,340
Hm, nó không chào hỏi bất cứ điều gì.

778
00:37:47,340 --> 00:37:49,210
Tại sao?

779
00:37:49,210 --> 00:37:51,170
Vâng, nhớ lại, mà là nó chạy?

780
00:37:51,170 --> 00:37:56,730
>> Đây có thể là bị mắc kẹt tại thời điểm này
trong vòng một, nếu bạn sẽ, trên đường sáu,

781
00:37:56,730 --> 00:37:59,950
vì Nhận String thiết kế,
được viết bởi đội ngũ nhân viên CS50,

782
00:37:59,950 --> 00:38:03,350
là nghĩa đen có nghĩa là chỉ cần ngồi
ở đó chờ đợi, và chờ đợi,

783
00:38:03,350 --> 00:38:04,850
và chờ đợi cho một chuỗi.

784
00:38:04,850 --> 00:38:06,792
Tất cả chúng ta có ý nghĩa bởi chuỗi là đầu vào của con người.

785
00:38:06,792 --> 00:38:07,500
Vì vậy, bạn biết những gì?

786
00:38:07,500 --> 00:38:08,166
Hãy để tôi đi trước.

787
00:38:08,166 --> 00:38:11,704
Và chỉ cần vào một ý thích, cho tôi
gõ tên của tôi, David, nhập.

788
00:38:11,704 --> 00:38:13,120
Bây giờ tôi có một chương trình năng động hơn.

789
00:38:13,120 --> 00:38:14,240
Nó nói, hello David.

790
00:38:14,240 --> 00:38:19,280
>> Nếu tôi đi trước và chạy này một lần nữa,
hãy để tôi cố gắng nói tên Zamila, nhập.

791
00:38:19,280 --> 00:38:20,940
Và bây giờ chúng tôi có một chương trình năng động.

792
00:38:20,940 --> 00:38:22,380
Tôi đã không cứng mã hóa thế giới.

793
00:38:22,380 --> 00:38:24,760
Tôi đã không được mã hóa cứng
tên, hay David, hoặc Zamila.

794
00:38:24,760 --> 00:38:28,350
>> Bây giờ nó nhiều hơn như các chương trình
chúng ta đã biết, mà nếu nó lấy đầu vào,

795
00:38:28,350 --> 00:38:30,870
nó tạo ra hơi khác nhau.

796
00:38:30,870 --> 00:38:34,020
Bây giờ, điều này không phải là tốt nhất
kinh nghiệm người dùng, hoặc UX.

797
00:38:34,020 --> 00:38:36,000
Tôi chạy chương trình.

798
00:38:36,000 --> 00:38:38,830
>> Tôi không biết những gì tôi phải
để làm, trừ khi tôi thực sự nhìn vào

799
00:38:38,830 --> 00:38:40,290
hoặc nhớ mã nguồn.

800
00:38:40,290 --> 00:38:42,640
Vì vậy, chúng ta hãy làm cho người sử dụng
trải nghiệm tốt hơn một chút

801
00:38:42,640 --> 00:38:44,240
với các đơn giản nhất của sự vật.

802
00:38:44,240 --> 00:38:47,782
Hãy để tôi quay trở lại này
chương trình, và chỉ đơn giản nói printf.

803
00:38:47,782 --> 00:38:51,870
>> Và hãy để tôi đi trước và nói tên, đại tràng,
và một không gian, và sau đó một dấu chấm phẩy.

804
00:38:51,870 --> 00:38:54,170
Và chỉ cần cho đá, không có phản ứng dữ dội n.

805
00:38:54,170 --> 00:38:55,980
Và đó là cố ý,
bởi vì tôi không muốn

806
00:38:55,980 --> 00:38:57,590
dấu nhắc để chuyển sang dòng tiếp theo.

807
00:38:57,590 --> 00:39:01,800
>> Tôi muốn, thay vào đó, làm điều này, làm cho chuỗi
biên dịch lại mã của tôi vào máy mới

808
00:39:01,800 --> 00:39:03,980
Mã dot giảm chuỗi.

809
00:39:03,980 --> 00:39:05,460
Ah, đây là đẹp hơn rất nhiều.

810
00:39:05,460 --> 00:39:08,780
Bây giờ tôi thực sự biết những gì máy tính
muốn tôi làm, cho nó một cái tên.

811
00:39:08,780 --> 00:39:13,020
>> Vì vậy, tôi sẽ đi trước và gõ
trong Rob, nhập, và xin chào, Rob.

812
00:39:13,020 --> 00:39:16,640
Vì vậy, nhận ra, đây vẫn là, ở cuối
trong ngày, chỉ có một chương trình chín dòng.

813
00:39:16,640 --> 00:39:18,090
Nhưng chúng tôi đã thực hiện các bước nhỏ.

814
00:39:18,090 --> 00:39:21,380
>> Chúng tôi đã viết một dòng mà chúng ta
đã quá quen thuộc, printf, xin chào thế giới.

815
00:39:21,380 --> 00:39:22,980
Sau đó, chúng phá hoại một chút về điều đó.

816
00:39:22,980 --> 00:39:24,560
Và chúng tôi thực sự sử dụng get chuỗi.

817
00:39:24,560 --> 00:39:26,362
Và chúng tôi ném giá trị đó trong một biến.

818
00:39:26,362 --> 00:39:29,070
Và sau đó chúng tôi đã đi trước và được cải thiện
nó hơn nữa với dòng thứ ba.

819
00:39:29,070 --> 00:39:32,220
Và quá trình lặp đi lặp lại này
viết phần mềm là thực sự quan trọng.

820
00:39:32,220 --> 00:39:36,420
Trong CS50, và trong cuộc sống nói chung,
bạn không nên thường ngồi xuống,

821
00:39:36,420 --> 00:39:39,800
có một chương trình trong tâm trí, và cố gắng viết
toàn bộ điều chết tiệt tất cả cùng một lúc.

822
00:39:39,800 --> 00:39:43,810
>> Nó sẽ, chắc chắn, dẫn đến cách
nhiều lỗi hơn bản thân chúng ta thấy ở đây.

823
00:39:43,810 --> 00:39:47,070
Ngay cả tôi, cho đến ngày nay, liên tục
phạm sai lầm ngu ngốc khác,

824
00:39:47,070 --> 00:39:50,480
là những sai lầm thực sự khó khăn hơn
đó là khó khăn hơn để tìm ra.

825
00:39:50,480 --> 00:39:55,095
Nhưng bạn sẽ làm nhiều hơn những sai lầm hơn
dòng mã bạn viết tất cả cùng một lúc.

826
00:39:55,095 --> 00:39:57,220
Và do đó, thực tế này,
viết một chút ít mã

827
00:39:57,220 --> 00:40:00,930
mà bạn thấy thoải mái, biên dịch
nó, chạy nó, thử nghiệm nó tổng quát hơn,

828
00:40:00,930 --> 00:40:04,370
sau đó di chuyển on-- nên giống như chúng ta giữ
layering và lớp cuối tuần trước,

829
00:40:04,370 --> 00:40:07,190
xây dựng từ một cái gì đó rất
đơn giản để một cái gì đó phức tạp hơn,

830
00:40:07,190 --> 00:40:08,200
làm tương tự ở đây.

831
00:40:08,200 --> 00:40:11,500
Đừng ngồi xuống, và cố gắng
viết cả một vấn đề.

832
00:40:11,500 --> 00:40:13,780
Trên thực tế có những bước nhỏ.

833
00:40:13,780 --> 00:40:18,100
>> Bây giờ, dây là không phải tất cả
mà hữu ích unto mình.

834
00:40:18,100 --> 00:40:21,210
Chúng ta nên thực sự, lý tưởng, thích
có cái gì khác trong bộ công cụ của chúng tôi.

835
00:40:21,210 --> 00:40:23,990
Vì vậy, hãy thực sự làm chính xác điều đó.

836
00:40:23,990 --> 00:40:27,900
>> Hãy để tôi đi trước bây giờ và whip lên
một chương trình hơi khác nhau.

837
00:40:27,900 --> 00:40:31,320
Và chúng ta sẽ gọi int.c này, đối với số nguyên.

838
00:40:31,320 --> 00:40:33,870
Tôi sẽ, tương tự,
bao gồm CS550.h.

839
00:40:33,870 --> 00:40:36,060
Tôi sẽ bao gồm tiêu chuẩn IO.

840
00:40:36,060 --> 00:40:39,630
Và đó sẽ là khá phổ biến
trong những ngày đầu tiên của lớp.

841
00:40:39,630 --> 00:40:42,050
>> Và tôi sẽ sẵn sàng
bản thân mình với một chức năng chính.

842
00:40:42,050 --> 00:40:46,370
Và bây giờ thay vì nhận được một chuỗi,
chúng ta hãy đi trước và nhận được một int.

843
00:40:46,370 --> 00:40:52,285
Hãy gọi nó là tôi, và gọi nó là được
int, dấu ngoặc đóng, dấu chấm phẩy.

844
00:40:52,285 --> 00:40:54,410
Và bây giờ chúng ta hãy làm
một cái gì đó với nó, printf.

845
00:40:54,410 --> 00:40:59,190
>> Hãy nói điều gì đó như
hello, dấu chéo ngược n, dấu phẩy i.

846
00:40:59,190 --> 00:41:03,010
Vì vậy, tôi bắt chước khá nhiều
những gì tôi đã làm chỉ là một khoảnh khắc trước.

847
00:41:03,010 --> 00:41:04,660
Tôi có một placeholder đây.

848
00:41:04,660 --> 00:41:08,150
Tôi đã dấu phẩy tôi ở đây, bởi vì tôi muốn
cắm tôi vào chỗ mà.

849
00:41:08,150 --> 00:41:10,250
>> Vì vậy, chúng ta hãy đi trước và thử
biên dịch chương trình này.

850
00:41:10,250 --> 00:41:13,060
Các tập tin được gọi là int.c.

851
00:41:13,060 --> 00:41:15,920
Vì vậy, tôi sẽ nói, làm cho int, nhập.

852
00:41:15,920 --> 00:41:19,420
Ôi Chúa ơi, nhưng không có việc lớn, phải không?

853
00:41:19,420 --> 00:41:20,230
Có một sai lầm.

854
00:41:20,230 --> 00:41:22,810
>> Có một sai lầm cú pháp
ở đây như vậy mà chương trình có thể không

855
00:41:22,810 --> 00:41:28,460
được biên soạn trong int.c, dòng
bảy, nhân vật 27, định dạng lỗi

856
00:41:28,460 --> 00:41:31,400
chỉ định kiểu char
ngôi sao, bất kể đó là.

857
00:41:31,400 --> 00:41:33,020
Nhưng các loại đối số là int.

858
00:41:33,020 --> 00:41:36,110
>> Vì vậy, ở đây, chúng tôi sẽ không đối với:
mặc dù hôm nay là rất nhiều vật liệu,

859
00:41:36,110 --> 00:41:38,710
chúng ta sẽ áp đảo bạn với
hoàn toàn mọi tính năng của C,

860
00:41:38,710 --> 00:41:41,070
và lập trình nói chung,
chỉ trong vài tuần đầu tiên.

861
00:41:41,070 --> 00:41:43,400
Vì vậy, có người thường sẽ là biệt ngữ
mà bạn không quen thuộc.

862
00:41:43,400 --> 00:41:46,350
Và, trên thực tế, ngôi sao char là một cái gì đó
chúng ta sẽ quay trở lại

863
00:41:46,350 --> 00:41:47,830
trong một tuần hoặc thời gian hai của.

864
00:41:47,830 --> 00:41:50,530
>> Nhưng hiện nay, chúng ta hãy xem nếu chúng ta có thể
phân tích các từ quen thuộc.

865
00:41:50,530 --> 00:41:53,750
Định dạng khác nên chúng tôi nghe định dạng
specifier, mã định dạng trước.

866
00:41:53,750 --> 00:41:54,840
Đó là quen thuộc.

867
00:41:54,840 --> 00:41:56,840
Doanh-- nhưng đối số có kiểu int.

868
00:41:56,840 --> 00:41:58,980
Chờ một phút, tôi là một int.

869
00:41:58,980 --> 00:42:02,230
>> Có lẽ phần trăm của thực
có một số ý nghĩa xác định.

870
00:42:02,230 --> 00:42:03,230
Và, quả thật vậy, nó.

871
00:42:03,230 --> 00:42:06,101
Một số nguyên, nếu bạn muốn
printf để thay thế nó,

872
00:42:06,101 --> 00:42:08,350
bạn thực sự phải sử dụng một
định dạng khác nhau đặc tả.

873
00:42:08,350 --> 00:42:09,890
Và bạn sẽ không biết điều này
trừ khi ai đó nói với bạn,

874
00:42:09,890 --> 00:42:10,973
hoặc bạn đã làm trước đó.

875
00:42:10,973 --> 00:42:13,490
Nhưng phần trăm tôi là gì
có thể được sử dụng phổ biến

876
00:42:13,490 --> 00:42:15,240
trong printf để cắm vào một số nguyên.

877
00:42:15,240 --> 00:42:17,920
Bạn cũng có thể sử dụng phần trăm
d cho một số nguyên thập phân.

878
00:42:17,920 --> 00:42:19,490
Nhưng tôi là tốt đẹp và đơn giản ở đây.

879
00:42:19,490 --> 00:42:20,590
Vì vậy, chúng tôi sẽ đi với điều đó.

880
00:42:20,590 --> 00:42:24,160
>> Bây giờ hãy để tôi đi trước và
chạy lại làm cho int, Enter.

881
00:42:24,160 --> 00:42:26,328
Đó là tốt, không có lỗi.

882
00:42:26,328 --> 00:42:30,260
Dot giảm OK int--, trải nghiệm người dùng xấu,
bởi vì tôi đã không nói với bản thân mình

883
00:42:30,260 --> 00:42:30,760
phải làm gì.

884
00:42:30,760 --> 00:42:31,426
Nhưng đó là tốt.

885
00:42:31,426 --> 00:42:32,480
Tôi đang đánh bắt trên một cách nhanh chóng.

886
00:42:32,480 --> 00:42:39,260
>> Và bây giờ hãy để tôi đi trước và
gõ vào David, OK, Zamila, Rob.

887
00:42:39,260 --> 00:42:40,820
OK, vì vậy đây là một điều tốt.

888
00:42:40,820 --> 00:42:44,710
Thời gian này, tôi đang sử dụng một chức năng,
một mảnh ghép, được gọi là get int.

889
00:42:44,710 --> 00:42:47,230
Và nó quay out-- và chúng tôi sẽ
thấy sau này trong term--

890
00:42:47,230 --> 00:42:50,730
các nhân viên đã thực hiện CS50
nhận được chuỗi theo cách như vậy

891
00:42:50,730 --> 00:42:53,350
rằng nó sẽ chỉ thể chất
nhận được một chuỗi cho bạn.

892
00:42:53,350 --> 00:42:57,340
>> Nó đã thực hiện get int trong
như một cách mà nó sẽ chỉ

893
00:42:57,340 --> 00:42:58,590
có một số nguyên cho bạn.

894
00:42:58,590 --> 00:43:00,830
Và nếu quý vị, con người,
không hợp tác, đó là

895
00:43:00,830 --> 00:43:03,590
nghĩa là chỉ cần đi để
nói thử lại, thử lại, thử lại,

896
00:43:03,590 --> 00:43:08,200
nghĩa đen ngồi đó looping, cho đến khi
bạn bắt buộc với một số số huyền diệu,

897
00:43:08,200 --> 00:43:10,670
như 50, và chào 50.

898
00:43:10,670 --> 00:43:14,440
>> Hoặc nếu chúng ta chạy này một lần nữa
và gõ 42, hello 42.

899
00:43:14,440 --> 00:43:18,750
Và như vậy các chức năng get int
bên trong đó mảnh ghép

900
00:43:18,750 --> 00:43:22,050
là đủ logic, đủ suy nghĩ,
để tìm ra, một từ là gì?

901
00:43:22,050 --> 00:43:23,330
Và một số là những gì?

902
00:43:23,330 --> 00:43:26,165
Chỉ chấp nhận, cuối cùng, con số.

903
00:43:26,165 --> 00:43:28,690

904
00:43:28,690 --> 00:43:33,230
>> Vì vậy, nó quay ra rằng điều này
không phải là tất cả những biểu cảm.

905
00:43:33,230 --> 00:43:33,910
cho đến nay.

906
00:43:33,910 --> 00:43:36,690
Vì vậy, yay, thời gian qua chúng tôi
đã đi khá nhanh chóng

907
00:43:36,690 --> 00:43:41,320
vào thực hiện trò chơi, và hình ảnh động,
và các công trình nghệ thuật trong Scratch.

908
00:43:41,320 --> 00:43:45,260
Và ở đây, chúng tôi đang được nội dung
với hello thế giới, và chào 50.

909
00:43:45,260 --> 00:43:46,696
>> Nó không phải tất cả những cảm hứng.

910
00:43:46,696 --> 00:43:49,070
Và, quả thật, những số đầu tiên
ví dụ sẽ mất một thời gian

911
00:43:49,070 --> 00:43:50,510
đến đoạn đường nối lên trong sự phấn khích.

912
00:43:50,510 --> 00:43:52,854
Nhưng chúng tôi có rất nhiều
kiểm soát hiện nay, trên thực tế.

913
00:43:52,854 --> 00:43:54,770
Và chúng ta sẽ rất
nhanh chóng bắt đầu layering

914
00:43:54,770 --> 00:43:56,870
trên đầu trang của các nguyên thủy cơ bản.

915
00:43:56,870 --> 00:43:59,370
>> Nhưng trước tiên, chúng ta hãy hiểu
những gì những hạn chế là.

916
00:43:59,370 --> 00:44:01,620
Trong thực tế, một trong những điều
Scratch không dễ dàng

917
00:44:01,620 --> 00:44:03,990
để chúng tôi làm là thực sự nhìn
bên dưới mui xe,

918
00:44:03,990 --> 00:44:06,740
và hiểu những gì một
máy tính là, những gì nó có thể làm,

919
00:44:06,740 --> 00:44:08,250
và các hạn chế của nó được.

920
00:44:08,250 --> 00:44:11,580
Và, thực sự, mà thiếu
hiểu biết, có thể, dài hạn

921
00:44:11,580 --> 00:44:15,520
có thể dẫn đến viết mistakes-- riêng của chúng tôi
lỗi, viết phần mềm không an toàn

922
00:44:15,520 --> 00:44:16,880
bị hack một cách nào đó.

923
00:44:16,880 --> 00:44:20,130
>> Vì vậy, chúng ta hãy có một số bước về phía
sự hiểu biết này tốt hơn một chút bằng cách

924
00:44:20,130 --> 00:44:22,710
cách, nói, ví dụ sau đây.

925
00:44:22,710 --> 00:44:26,550
Tôi sẽ đi trước và thực hiện
thật nhanh một chương trình gọi là Adder.

926
00:44:26,550 --> 00:44:28,134
Giống như, hãy thêm một vài số với nhau.

927
00:44:28,134 --> 00:44:30,800
Và tôi sẽ để mã số góc
ở đây, và chỉ cần sao chép và dán

928
00:44:30,800 --> 00:44:33,270
nơi tôi đã được trước đó, chỉ
vì vậy chúng tôi có thể nhận ra sớm hơn.

929
00:44:33,270 --> 00:44:36,090
Vì vậy, bây giờ tôi đã có sự khởi đầu cơ bản
của một chương trình gọi là Adder.

930
00:44:36,090 --> 00:44:37,670
>> Và chúng ta hãy đi trước và làm điều này.

931
00:44:37,670 --> 00:44:41,680
Tôi sẽ đi trước và
nói, intx được lấy int.

932
00:44:41,680 --> 00:44:42,430
Và bạn biết những gì?

933
00:44:42,430 --> 00:44:43,990
Hãy làm cho một kinh nghiệm người dùng tốt hơn.

934
00:44:43,990 --> 00:44:48,740
>> Vì vậy, chúng ta hãy chỉ nói x là, và hiệu quả
nhắc nhở người dùng để cung cấp cho chúng tôi x.

935
00:44:48,740 --> 00:44:53,600
Và sau đó cho tôi đi trước và nói, printf
làm thế nào về y là, lần này mong đợi

936
00:44:53,600 --> 00:44:56,140
hai giá trị từ người sử dụng.

937
00:44:56,140 --> 00:45:02,759
Và sau đó chúng ta chỉ cần đi trước và
nói, printf, tổng của x và y được.

938
00:45:02,759 --> 00:45:04,300
Và bây giờ tôi không muốn làm trăm s.

939
00:45:04,300 --> 00:45:12,080
Tôi muốn làm trăm i, gạch chéo ngược
n, và sau đó cắm vào giá trị tổng.

940
00:45:12,080 --> 00:45:13,620
>> Vì vậy, làm thế nào tôi có thể đi về việc này?

941
00:45:13,620 --> 00:45:14,270
Bạn biết những gì?

942
00:45:14,270 --> 00:45:15,840
Tôi biết làm thế nào để sử dụng các biến.

943
00:45:15,840 --> 00:45:18,140
Hãy để tôi chỉ cần khai báo một cái mới, int z.

944
00:45:18,140 --> 00:45:19,770
>> Và tôi sẽ mất một đoán ở đây.

945
00:45:19,770 --> 00:45:24,470
Nếu có dấu hiệu bình đẳng trong này
ngôn ngữ, có lẽ tôi chỉ có thể làm X cộng Y,

946
00:45:24,470 --> 00:45:26,660
miễn là tôi kết thúc của tôi
nghĩ với một dấu chấm phẩy?

947
00:45:26,660 --> 00:45:31,170
Bây giờ tôi có thể quay trở lại xuống đây, cắm z,
kết thúc suy nghĩ này với một dấu chấm phẩy.

948
00:45:31,170 --> 00:45:36,160
Và chúng ta thấy bây giờ, nếu các
trình tự của lines-- x là nhận int.

949
00:45:36,160 --> 00:45:37,770
Y là có được int.

950
00:45:37,770 --> 00:45:40,980
>> Thêm x và y, lưu trữ các giá trị trong z--
như vậy, một lần nữa, hãy nhớ dấu bằng

951
00:45:40,980 --> 00:45:41,560
không bằng.

952
00:45:41,560 --> 00:45:44,100
Đó là nhiệm vụ từ phải sang trái.

953
00:45:44,100 --> 00:45:48,180
Và chúng ta hãy in ra rằng tổng
của x và y không phải là nghĩa đen z,

954
00:45:48,180 --> 00:45:49,830
nhưng những gì bên trong của z.

955
00:45:49,830 --> 00:45:53,090
Vì vậy, chúng ta hãy làm Adder -
tốt đẹp, không có sai lầm lần này.

956
00:45:53,090 --> 00:45:56,030
Dot giảm Adder, nhập,
x sẽ là 1.

957
00:45:56,030 --> 00:45:58,380
>> Y sẽ là 2.

958
00:45:58,380 --> 00:46:01,964
Và tổng x và y là 3.

959
00:46:01,964 --> 00:46:03,130
Vì vậy, đó là tất cả tốt và tốt.

960
00:46:03,130 --> 00:46:06,260
>> Vì vậy, bạn sẽ tưởng tượng rằng môn toán
nên làm việc trong một chương trình như thế này.

961
00:46:06,260 --> 00:46:07,040
Nhưng bạn biết những gì?

962
00:46:07,040 --> 00:46:09,904
Là biến này, dòng
12, thậm chí còn cần thiết?

963
00:46:09,904 --> 00:46:12,820
Bạn không cần phải có thói quen
chỉ lưu trữ những thứ trong các biến

964
00:46:12,820 --> 00:46:13,980
chỉ vì bạn có thể.

965
00:46:13,980 --> 00:46:16,550
Và, trên thực tế, nó thường
thiết kế xấu coi

966
00:46:16,550 --> 00:46:21,100
nếu bạn đang tạo ra một biến, được gọi là
z trong trường hợp này, lưu trữ một cái gì đó trong nó,

967
00:46:21,100 --> 00:46:24,390
và sau đó ngay lập tức
sử dụng nó, nhưng không bao giờ trở lại.

968
00:46:24,390 --> 00:46:27,700
Tại sao cho một cái gì đó một tên
như z nếu bạn theo nghĩa đen

969
00:46:27,700 --> 00:46:29,770
sẽ sử dụng
Điều duy nhất một lần, và do đó

970
00:46:29,770 --> 00:46:32,380
gần đến nơi bạn đã tạo
nó ở nơi đầu tiên,

971
00:46:32,380 --> 00:46:34,052
rất gần gũi về dòng mã?

972
00:46:34,052 --> 00:46:34,760
Vì vậy, bạn biết những gì?

973
00:46:34,760 --> 00:46:37,480
Nó chỉ ra rằng C là khá linh hoạt.

974
00:46:37,480 --> 00:46:39,586
Nếu tôi thực sự muốn
plug-in các giá trị ở đây,

975
00:46:39,586 --> 00:46:41,210
Tôi không cần phải khai báo một biến mới.

976
00:46:41,210 --> 00:46:44,680
Tôi chỉ có thể cắm trong X cộng
y, bởi vì C hiểu

977
00:46:44,680 --> 00:46:46,390
số học, và toán tử toán học.

978
00:46:46,390 --> 00:46:50,140
>> Vì vậy, tôi chỉ có thể nói rằng, làm toán này,
x cộng với y, bất cứ những giá trị,

979
00:46:50,140 --> 00:46:53,780
cắm kết quả
số nguyên thành chuỗi.

980
00:46:53,780 --> 00:46:56,730
Vì vậy, đây có thể là, mặc dù
chỉ có một đường ngắn hơn,

981
00:46:56,730 --> 00:47:01,480
một thiết kế tốt hơn, một chương trình tốt hơn,
bởi vì có mã ít hơn, do đó

982
00:47:01,480 --> 00:47:02,921
ít hơn cho tôi hiểu.

983
00:47:02,921 --> 00:47:04,920
Và nó cũng chỉ sạch hơn,
trong chừng mực chúng tôi không

984
00:47:04,920 --> 00:47:07,620
giới thiệu từ mới,
biểu tượng mới, như z,

985
00:47:07,620 --> 00:47:10,510
mặc dù họ không thực sự
phục vụ nhiều mục đích.

986
00:47:10,510 --> 00:47:15,890
>> Thật không may, không phải là toán học
tất cả những gì đôi khi đáng tin cậy.

987
00:47:15,890 --> 00:47:18,270
Hãy đi trước và làm điều này.

988
00:47:18,270 --> 00:47:21,200
Tôi sẽ đi trước
bây giờ và làm như sau.

989
00:47:21,200 --> 00:47:30,650
>> Hãy làm printf, phần trăm tôi, cộng thêm phần trăm
i, chịu trăm i, gạch chéo ngược n.

990
00:47:30,650 --> 00:47:35,240
Và tôi sẽ làm điều này-- xyx cộng với y.

991
00:47:35,240 --> 00:47:37,821
Vì vậy, tôi chỉ cần đi để viết lại
này hơi khác nhau ở đây.

992
00:47:37,821 --> 00:47:39,320
Hãy để tôi chỉ làm một kiểm tra sự tỉnh táo nhanh chóng.

993
00:47:39,320 --> 00:47:40,986
Một lần nữa, chúng ta không có được trước của mình.

994
00:47:40,986 --> 00:47:44,420
Hãy cộng, dấu chấm dấu gạch chéo cộng.

995
00:47:44,420 --> 00:47:47,950
x là 1, y là 2, 1 + 2 là 3.

996
00:47:47,950 --> 00:47:48,870
Vì vậy, đó là tốt.

997
00:47:48,870 --> 00:47:52,060
Nhưng chúng ta hãy làm phức tạp này ngay bây giờ
một chút, và tạo ra một tập tin mới.

998
00:47:52,060 --> 00:47:56,350
>> Tôi sẽ gọi con này,
nói, ints, số nhiều cho các số nguyên.

999
00:47:56,350 --> 00:47:58,980
Hãy để tôi bắt đầu từ đâu tôi là một khoảnh khắc trước.

1000
00:47:58,980 --> 00:48:00,770
Nhưng bây giờ chúng ta hãy làm một vài dòng khác.

1001
00:48:00,770 --> 00:48:06,430
Hãy để tôi đi trước và làm như sau,
printf, phần trăm tôi, trừ đi phần trăm i,

1002
00:48:06,430 --> 00:48:11,959
là phần trăm tôi, dấu phẩy x, dấu phẩy yx trừ y.

1003
00:48:11,959 --> 00:48:13,750
Vì vậy, tôi đang làm một chút
toán khác nhau đó.

1004
00:48:13,750 --> 00:48:14,624
Hãy làm một khác.

1005
00:48:14,624 --> 00:48:19,610
Vì vậy, phần trăm i lần phần trăm
i là phần trăm i, gạch chéo ngược n.

1006
00:48:19,610 --> 00:48:24,430
Hãy plug-in x và y, và lần x y.

1007
00:48:24,430 --> 00:48:27,530
Chúng tôi sẽ sử dụng dấu hoa thị trên
máy tính của bạn cho lần.

1008
00:48:27,530 --> 00:48:29,390
>> Bạn không sử dụng x. x là
một tên biến ở đây.

1009
00:48:29,390 --> 00:48:31,270
Bạn sử dụng sao cho phép nhân.

1010
00:48:31,270 --> 00:48:32,020
Hãy làm một nhiều hơn.

1011
00:48:32,020 --> 00:48:37,580
Printf phần trăm tôi, chia
theo phần trăm tôi, là phần trăm i,

1012
00:48:37,580 --> 00:48:43,460
n dấu chéo ngược. xy chia y--
do đó, bạn sử dụng các dấu gạch chéo trong C

1013
00:48:43,460 --> 00:48:44,502
để làm phân chia.

1014
00:48:44,502 --> 00:48:45,460
Và chúng ta hãy làm một khác.

1015
00:48:45,460 --> 00:48:50,920

1016
00:48:50,920 --> 00:48:58,240
Phần còn lại của phần trăm tôi, chia
theo phần trăm tôi, là phần trăm tôi.

1017
00:48:58,240 --> 00:49:02,550
xy-- và bây giờ còn lại
là những gì còn lại.

1018
00:49:02,550 --> 00:49:05,980
Khi bạn cố gắng chia một
Mẫu số vào tử số,

1019
00:49:05,980 --> 00:49:08,570
bao nhiêu là trái hơn mà
bạn không thể chia ra?

1020
00:49:08,570 --> 00:49:10,910
>> Vì vậy, không có thực sự,
nhất thiết, một biểu tượng

1021
00:49:10,910 --> 00:49:12,470
chúng tôi đã sử dụng trong trường lớp cho việc này.

1022
00:49:12,470 --> 00:49:16,830
Nhưng có trong C. Bạn có thể
nói x modulo y, trong đó

1023
00:49:16,830 --> 00:49:21,000
dấu hiệu này phần trăm trong context-- này
gây nhầm lẫn khi bạn đang ở trong

1024
00:49:21,000 --> 00:49:23,170
của dấu ngoặc kép,
bên trong của printf, phần trăm

1025
00:49:23,170 --> 00:49:24,830
được sử dụng như là sự xác định định dạng.

1026
00:49:24,830 --> 00:49:28,420
>> Khi bạn sử dụng phần trăm ngoài
rằng trong một biểu thức toán học,

1027
00:49:28,420 --> 00:49:32,910
đó là các nhà điều hành modulo cho mô-đun
arithmetic-- cho mục đích của chúng tôi

1028
00:49:32,910 --> 00:49:36,650
ở đây, chỉ có nghĩa, là những gì
còn lại của x chia y?

1029
00:49:36,650 --> 00:49:39,130
Vì vậy x chia y là x slash y.

1030
00:49:39,130 --> 00:49:41,220
phần còn lại của x chia y là gì?

1031
00:49:41,220 --> 00:49:44,780
Đó là x mod y, như một lập trình viên sẽ nói.

1032
00:49:44,780 --> 00:49:51,300
>> Vì vậy, nếu tôi đã không sai lầm ở đây, cho tôi
đi trước và làm cho ints, số nhiều, tốt đẹp,

1033
00:49:51,300 --> 00:49:53,010
và ints slash dot.

1034
00:49:53,010 --> 00:49:58,270
Và chúng ta hãy đi trước và
làm, hãy nói, 1, 10.

1035
00:49:58,270 --> 00:50:01,390
Tất cả các bên phải, 1 + 10 là 11, kiểm tra.

1036
00:50:01,390 --> 00:50:04,240
1 trừ đi 10 là âm 9, kiểm tra.

1037
00:50:04,240 --> 00:50:06,420
>> 1 lần 10 là 10, kiểm tra.

1038
00:50:06,420 --> 00:50:10,090
1 chia cho 10 hợp--
OK, chúng tôi sẽ bỏ qua một.

1039
00:50:10,090 --> 00:50:12,480
Phần còn lại của 1 chia cho 10 là 1.

1040
00:50:12,480 --> 00:50:13,680
Đúng rồi.

1041
00:50:13,680 --> 00:50:15,630
Nhưng có một lỗi ở đây.

1042
00:50:15,630 --> 00:50:18,390
>> Vì vậy, một trong những tôi đặt của tôi
bàn giao, không chính xác.

1043
00:50:18,390 --> 00:50:19,670
Ý tôi là, nó gần với 0.

1044
00:50:19,670 --> 00:50:23,670
1 chia cho 10, bạn biết, nếu chúng ta
cắt một số góc, chắc chắn, nó không.

1045
00:50:23,670 --> 00:50:31,050
Nhưng nó thực sự phải là 1/10,
0.1 hoặc 0.10, 0,1000, vân vân.

1046
00:50:31,050 --> 00:50:33,600
>> Nó nên không thực sự là không.

1047
00:50:33,600 --> 00:50:38,990
Vâng, nó chỉ ra rằng máy tính là
làm nghĩa đen những gì chúng tôi nói với nó để làm.

1048
00:50:38,990 --> 00:50:42,460
Chúng tôi đang làm toán học như x chia y.

1049
00:50:42,460 --> 00:50:47,680
Và cả x và y, mỗi dòng
mã trước đó, là số nguyên.

1050
00:50:47,680 --> 00:50:53,440
>> Hơn nữa, trên đường 15, chúng tôi
nói printf, hey, printf plug-in

1051
00:50:53,440 --> 00:50:57,230
một số nguyên, plug-in một số nguyên,
plug-in một integer-- đặc biệt

1052
00:50:57,230 --> 00:51:00,580
x, và sau đó y, và sau đó x
chia cho y. x và y là kiểu int.

1053
00:51:00,580 --> 00:51:02,060
Chúng tôi đang tốt ở đó.

1054
00:51:02,060 --> 00:51:04,250
>> Nhưng những gì đang x chia x?

1055
00:51:04,250 --> 00:51:09,790
x chia y nên được,
toán học, 1/10, hoặc 0.1,

1056
00:51:09,790 --> 00:51:14,600
đó là một số thực, một số thực
có, khả năng, một điểm thập phân.

1057
00:51:14,600 --> 00:51:16,230
Nó không phải là một số nguyên.

1058
00:51:16,230 --> 00:51:21,290
>> Nhưng gần nhất là gì
số nguyên 1/10 hay 0,1?

1059
00:51:21,290 --> 00:51:24,114
Yeah, nó loại là số không.

1060
00:51:24,114 --> 00:51:25,030
0,1 là như này nhiều.

1061
00:51:25,030 --> 00:51:25,890
Và 1 là nhiều này.

1062
00:51:25,890 --> 00:51:28,870
Vì vậy, 1/10 là gần gũi hơn với
0 hơn là để một.

1063
00:51:28,870 --> 00:51:33,800
>> Và vì vậy những gì C đang làm cho đây--
loại vì chúng tôi nói với nó đối với:

1064
00:51:33,800 --> 00:51:35,600
được cắt xén nguyên đó.

1065
00:51:35,600 --> 00:51:43,540
Nó lấy giá trị, mà lại là
nghĩa vụ phải được một cái gì đó giống như 0,1000,

1066
00:51:43,540 --> 00:51:44,800
0 và vv.

1067
00:51:44,800 --> 00:51:48,320
Và nó cắt bỏ tất cả mọi thứ
sau dấu thập phân

1068
00:51:48,320 --> 00:51:50,510
để tất cả những điều này
công cụ, bởi vì nó không

1069
00:51:50,510 --> 00:51:54,910
phù hợp với quan niệm của một số nguyên, mà
chỉ là một số mặt hàng như tiêu cực 1, 0, 1,

1070
00:51:54,910 --> 00:51:58,830
lên và xuống, nó ném đi tất cả mọi thứ
sau dấu thập phân vì bạn

1071
00:51:58,830 --> 00:52:02,020
không thể phù hợp với một dấu thập phân
trong một số nguyên theo định nghĩa.

1072
00:52:02,020 --> 00:52:04,290
>> Vì vậy, câu trả lời ở đây là số không.

1073
00:52:04,290 --> 00:52:05,600
Vì vậy, làm thế nào để chúng tôi sửa lỗi này?

1074
00:52:05,600 --> 00:52:07,400
Chúng ta cần một giải pháp tất cả cùng nhau.

1075
00:52:07,400 --> 00:52:09,880
Và chúng ta có thể làm được điều này, như sau.

1076
00:52:09,880 --> 00:52:15,820
>> Hãy để tôi đi trước và tạo ra một mới
tập tin, chương trình này được gọi là floats.c.

1077
00:52:15,820 --> 00:52:19,500
Và lưu nó ở đây
cùng một thư mục, float.c.

1078
00:52:19,500 --> 00:52:22,360

1079
00:52:22,360 --> 00:52:26,260
Và hãy để tôi đi trước và sao chép
một số mã mà từ trước đó.

1080
00:52:26,260 --> 00:52:30,690
>> Nhưng thay vì nhận được
một int, chúng ta hãy làm điều này.

1081
00:52:30,690 --> 00:52:34,037
Hãy cho tôi một giá trị dấu chấm động
gọi là x. nơi một điểm nổi

1082
00:52:34,037 --> 00:52:36,370
giá trị chỉ là nghĩa đen
một cái gì đó với một dấu chấm.

1083
00:52:36,370 --> 00:52:37,410
Nó có thể di chuyển sang trái, sang phải.

1084
00:52:37,410 --> 00:52:38,530
Đó là một số thực.

1085
00:52:38,530 --> 00:52:41,050
>> Và hãy để tôi gọi không
được int, nhưng có được phao,

1086
00:52:41,050 --> 00:52:44,420
đó cũng là một trong những thực đơn
các tùy chọn trong thư viện C250.

1087
00:52:44,420 --> 00:52:46,220
Hãy thay đổi y đến một phao.

1088
00:52:46,220 --> 00:52:48,000
Vì vậy, điều này trở nên có được phao.

1089
00:52:48,000 --> 00:52:50,620
>> Và bây giờ, chúng tôi không muốn để cắm ints.

1090
00:52:50,620 --> 00:52:56,130
Hóa ra chúng ta phải sử dụng phần trăm
f cho phao, phần trăm f cho phao,

1091
00:52:56,130 --> 00:52:57,560
và bây giờ lưu nó.

1092
00:52:57,560 --> 00:53:04,220
Và bây giờ, ngón tay vượt qua, làm cho
phao nổi, đẹp, nổi slash dot.

1093
00:53:04,220 --> 00:53:07,280
x sẽ là một 1. y
Sẽ là 10 lần nữa.

1094
00:53:07,280 --> 00:53:11,240
>> Và, đẹp, OK Ngoài ra tôi là chính xác.

1095
00:53:11,240 --> 00:53:13,240
Tôi đã hy vọng cho nhiều hơn,
nhưng tôi quên để viết nó.

1096
00:53:13,240 --> 00:53:16,250
Vì vậy, chúng ta hãy đi và sửa chữa lỗi logic này.

1097
00:53:16,250 --> 00:53:19,280
>> Hãy đi trước và lấy sau.

1098
00:53:19,280 --> 00:53:21,080
Chúng tôi sẽ chỉ cần làm một bản sao nhỏ và dán.

1099
00:53:21,080 --> 00:53:23,080
Và tôi sẽ nói trừ.

1100
00:53:23,080 --> 00:53:24,890
>> Và tôi sẽ nói lần.

1101
00:53:24,890 --> 00:53:27,060
Và tôi sẽ nói chia.

1102
00:53:27,060 --> 00:53:31,240
Và tôi sẽ không làm theo modulo,
mà không phải là Gecman đây,

1103
00:53:31,240 --> 00:53:36,690
chia f, và lần plus--
OK, chúng ta hãy làm điều này một lần nữa.

1104
00:53:36,690 --> 00:53:47,210
>> Hãy phao, phao nổi slash dot,
và 1, 10, và- tốt đẹp, không có, OK.

1105
00:53:47,210 --> 00:53:48,250
Vì vậy, tôi là một thằng ngốc.

1106
00:53:48,250 --> 00:53:50,000
Vì vậy, đây là rất phổ biến
khoa học máy tính

1107
00:53:50,000 --> 00:53:52,780
phạm sai lầm ngu ngốc như thế này.

1108
00:53:52,780 --> 00:53:56,100
>> Đối với mục đích sư phạm,
những gì tôi thực sự muốn làm

1109
00:53:56,100 --> 00:54:00,410
đã được thay đổi khoa học ở đây
để cộng, trừ đi, để lần,

1110
00:54:00,410 --> 00:54:04,140
và để phân chia, như bạn hy vọng
nhận thấy trong bài tập này.

1111
00:54:04,140 --> 00:54:07,700
Vì vậy bây giờ chúng ta hãy lập lại này
chương trình, làm nổi slash dot.

1112
00:54:07,700 --> 00:54:10,950
>> Và lần thứ ba, chúng ta hãy
xem nếu nó đáp ứng mong đợi của tôi.

1113
00:54:10,950 --> 00:54:24,480
1, 10, nhập, có, OK, 1.000,
chia cho 10.000, là 0,100000.

1114
00:54:24,480 --> 00:54:27,952
Và hóa ra chúng ta có thể kiểm soát bao nhiêu
con số này sau khi những điểm thập phân.

1115
00:54:27,952 --> 00:54:28,660
Chúng tôi thực sự sẽ.

1116
00:54:28,660 --> 00:54:29,790
Chúng ta sẽ quay trở lại đó.

1117
00:54:29,790 --> 00:54:31,440
>> Nhưng bây giờ, trên thực tế, các môn toán là chính xác.

1118
00:54:31,440 --> 00:54:33,090
Vì vậy, một lần nữa, các takeaway những gì ở đây?

1119
00:54:33,090 --> 00:54:36,050
Nó chỉ ra rằng trong C, có
không chỉ strings-- và, trên thực tế,

1120
00:54:36,050 --> 00:54:39,120
có không thực sự, bởi vì chúng tôi
thêm những người có thư viện CS50.

1121
00:54:39,120 --> 00:54:40,710
Nhưng không chỉ là kiểu int.

1122
00:54:40,710 --> 00:54:41,990
>> Ngoài ra còn có nổi.

1123
00:54:41,990 --> 00:54:45,810
Và hóa ra một loạt các dữ liệu khác
loại quá, mà chúng ta sẽ sử dụng trước khi dài.

1124
00:54:45,810 --> 00:54:49,270
Hóa ra, nếu bạn muốn có một đơn
nhân vật, không phải là một chuỗi ký tự,

1125
00:54:49,270 --> 00:54:50,610
bạn có thể sử dụng chỉ cần một char.

1126
00:54:50,610 --> 00:54:55,350
>> Chỉ ra rằng nếu bạn muốn có một bool,
một giá trị Boolean, đúng hay sai chỉ,

1127
00:54:55,350 --> 00:54:59,840
nhờ các thư viện CS50, chúng tôi đã
thêm vào C kiểu dữ liệu bool là tốt.

1128
00:54:59,840 --> 00:55:02,180
Nhưng nó cũng có mặt ở
nhiều ngôn ngữ khác.

1129
00:55:02,180 --> 00:55:07,130
Và nó chỉ ra rằng đôi khi bạn
cần những con số lớn hơn sau đó đi theo mặc định

1130
00:55:07,130 --> 00:55:08,210
với ints và nổi được.

1131
00:55:08,210 --> 00:55:13,590
>> Và, trên thực tế, một đôi là một số
sử dụng không 32 bit, nhưng 64 bit.

1132
00:55:13,590 --> 00:55:17,990
Và một lâu dài là một con số
sử dụng không 32, bit nhưng 64 bit,

1133
00:55:17,990 --> 00:55:22,190
tương ứng, cho điểm nổi
giá trị và số nguyên tương ứng.

1134
00:55:22,190 --> 00:55:25,780
Vì vậy, hãy thực hiện
thấy điều này trong hành động.

1135
00:55:25,780 --> 00:55:29,150
>> Tôi sẽ đi trước đây
và whip lên một chương trình khác.

1136
00:55:29,150 --> 00:55:35,020
Ở đây, tôi sẽ đi trước
và không bao gồm CS50.h.

1137
00:55:35,020 --> 00:55:37,910
Và hãy để tôi đi, bao gồm tiêu chuẩn IO.h.

1138
00:55:37,910 --> 00:55:40,320
>> Và bạn sẽ nhận thấy một cái gì đó
sôi nổi đang diễn ra ở đây.

1139
00:55:40,320 --> 00:55:43,592
Nó không phải màu sắc mã hóa mọi thứ trong
theo cùng một cách như trước.

1140
00:55:43,592 --> 00:55:46,550
Và hóa ra, đó là bởi vì tôi
đã không được đưa ra các điều một tên tập tin.

1141
00:55:46,550 --> 00:55:50,270
>> Tôi sẽ gọi con này
sizeof.c, và nhấn Save.

1142
00:55:50,270 --> 00:55:54,039
Và nhận thấy những gì xảy ra với tôi rất
mã điểm trắng so với nền màu đen.

1143
00:55:54,039 --> 00:55:55,830
Bây giờ, ít nhất có
một số màu tím trong đó.

1144
00:55:55,830 --> 00:55:57,490
Và đó là cú pháp tô sáng.

1145
00:55:57,490 --> 00:56:00,700
>> Đó là bởi vì, khá đơn giản, tôi đã
nói với các IDE loại tập tin

1146
00:56:00,700 --> 00:56:04,060
nó là đặt cho nó một cái tên, và
đặc biệt là một phần mở rộng tập tin.

1147
00:56:04,060 --> 00:56:06,620
Bây giờ, chúng ta hãy đi trước và làm điều này.

1148
00:56:06,620 --> 00:56:11,910
Tôi sẽ đi trước và rất
chỉ đơn giản là in ra bool following--

1149
00:56:11,910 --> 00:56:14,080
là phần trăm LU.

1150
00:56:14,080 --> 00:56:15,950
>> Chúng ta sẽ quay trở lại
mà chỉ trong một khoảnh khắc.

1151
00:56:15,950 --> 00:56:18,840
Và sau đó tôi sẽ
in kích thước của bool.

1152
00:56:18,840 --> 00:56:21,170
Và bây giờ, chỉ để tiết kiệm
bản thân mình một thời gian, tôi

1153
00:56:21,170 --> 00:56:23,280
sẽ làm một toàn bộ
bó của các cùng một lúc.

1154
00:56:23,280 --> 00:56:27,620
Và, đặc biệt, tôi sẽ
thay đổi này đến một char và char.

1155
00:56:27,620 --> 00:56:30,760
Điều này, tôi sẽ thay đổi
một đôi và một đôi.

1156
00:56:30,760 --> 00:56:34,440
>> Điều này, tôi sẽ thay đổi
để một phao và một phao.

1157
00:56:34,440 --> 00:56:38,670
Điều này, tôi sẽ
thay đổi đến một int và int.

1158
00:56:38,670 --> 00:56:41,660
Và một trong những điều này, tôi sẽ
thay đổi đến một lâu dài.

1159
00:56:41,660 --> 00:56:43,840
Và nó vẫn còn dùng
một thời gian dài, rất dài.

1160
00:56:43,840 --> 00:56:47,572
>> Và sau đó, cuối cùng, tôi đã cho
bản thân mình là quá nhiều, chuỗi.

1161
00:56:47,572 --> 00:56:50,030
Nó chỉ ra rằng trong C, có
các nhà điều hành đặc biệt gọi là

1162
00:56:50,030 --> 00:56:53,260
kích thước của đó là nghĩa đen
đi, khi chạy,

1163
00:56:53,260 --> 00:56:55,099
cho chúng tôi biết kích thước của
mỗi một trong các biến.

1164
00:56:55,099 --> 00:56:56,890
Và đây là một cách, bây giờ,
chúng ta có thể kết nối trở lại

1165
00:56:56,890 --> 00:57:00,140
để thảo luận tuần trước
dữ liệu và đại diện.

1166
00:57:00,140 --> 00:57:03,330
>> Hãy để tôi đi trước và biên dịch
kích thước của kích thước slash dot trong.

1167
00:57:03,330 --> 00:57:04,210
Và chúng ta hãy xem.

1168
00:57:04,210 --> 00:57:08,210
Nó chỉ ra rằng trong C,
cụ thể về CS50 IDE,

1169
00:57:08,210 --> 00:57:11,170
cụ thể về
hệ điều hành Ubuntu,

1170
00:57:11,170 --> 00:57:14,100
mà là một hành 64-bit
hệ thống trong trường hợp này,

1171
00:57:14,100 --> 00:57:17,189
một bool sẽ
sử dụng một byte của không gian.

1172
00:57:17,189 --> 00:57:19,480
Đó là cách kích thước được đo,
không bit, nhưng trong byte.

1173
00:57:19,480 --> 00:57:21,690
Và nhớ lại rằng một byte là tám bit.

1174
00:57:21,690 --> 00:57:25,030
Vì vậy, một bool, ngay cả khi bạn
kỹ thuật chỉ cần một 0 hoặc 1,

1175
00:57:25,030 --> 00:57:27,092
đó là một chút lãng phí
như thế nào chúng tôi đã thực hiện nó.

1176
00:57:27,092 --> 00:57:29,800
Nó thực sự sẽ sử dụng toàn bộ
byte-- vì vậy tất cả các số không, là có thể

1177
00:57:29,800 --> 00:57:34,050
tất cả những người thân, hoặc một cái gì đó như thế,
hay chỉ là một 1 trong số tám bit.

1178
00:57:34,050 --> 00:57:37,962
>> Một char, trong khi đó, được sử dụng cho một nhân vật
giống như một nhân vật Ascii mỗi tuần trước,

1179
00:57:37,962 --> 00:57:39,170
sẽ là một ký tự.

1180
00:57:39,170 --> 00:57:45,340
Và đó synchs lên với ý niệm của chúng ta về
nó là không quá 256 bits-- thay,

1181
00:57:45,340 --> 00:57:48,360
synchs lên với nó là không có
dài hơn 8 bit, mà

1182
00:57:48,360 --> 00:57:50,450
cung cấp cho chúng tôi nhiều như 256 giá trị.

1183
00:57:50,450 --> 00:57:52,680
Một đôi sẽ
là 8 byte hoặc 64 bit.

1184
00:57:52,680 --> 00:57:53,510
>> Một float là 4.

1185
00:57:53,510 --> 00:57:54,690
Một int là 4.

1186
00:57:54,690 --> 00:57:55,980
Một dài, dài là 8.

1187
00:57:55,980 --> 00:57:57,716
Và một chuỗi là 8.

1188
00:57:57,716 --> 00:57:58,840
Nhưng đừng lo lắng về điều đó.

1189
00:57:58,840 --> 00:58:00,340
Chúng tôi đang đi để bóc lại lớp đó.

1190
00:58:00,340 --> 00:58:02,940
Hóa ra, dây có thể
dài hơn 8 byte.

1191
00:58:02,940 --> 00:58:05,310
>> Và, quả thật vậy, chúng tôi đã viết
dây đã, xin chào thế giới,

1192
00:58:05,310 --> 00:58:06,700
dài hơn 8 byte.

1193
00:58:06,700 --> 00:58:09,270
Nhưng chúng tôi sẽ trở lại
mà chỉ trong một khoảnh khắc.

1194
00:58:09,270 --> 00:58:12,690
Nhưng mất đi ở đây là sau đây.

1195
00:58:12,690 --> 00:58:18,320
>> Bất kỳ máy tính chỉ có hữu hạn
số lượng bộ nhớ và không gian.

1196
00:58:18,320 --> 00:58:20,860
Bạn chỉ có thể lưu trữ rất nhiều
các tập tin trên máy Mac hoặc máy PC của bạn.

1197
00:58:20,860 --> 00:58:26,030
Bạn chỉ có thể lưu trữ rất nhiều các chương trình trong
RAM chạy cùng một lúc, nhất thiết, thậm chí

1198
00:58:26,030 --> 00:58:29,360
với bộ nhớ ảo, vì
bạn có một số lượng hữu hạn của bộ nhớ RAM.

1199
00:58:29,360 --> 00:58:31,990
>> Và chỉ để picture-- nếu
bạn đã bao giờ mở ra một máy tính xách tay

1200
00:58:31,990 --> 00:58:34,300
hoặc đặt thêm bộ nhớ
cho một máy tính, bạn

1201
00:58:34,300 --> 00:58:36,670
có thể không biết rằng
bên trong máy tính của bạn

1202
00:58:36,670 --> 00:58:39,590
là cái gì đó trông
một chút như thế này.

1203
00:58:39,590 --> 00:58:43,540
Vì vậy, đây chỉ là một công ty chung có tên
Quan trọng là làm cho bộ nhớ RAM cho máy tính.

1204
00:58:43,540 --> 00:58:46,620
Và RAM là nơi mà các chương trình
sống trong khi họ đang chạy.

1205
00:58:46,620 --> 00:58:49,630
>> Vì vậy, trên mọi máy Mac hoặc PC, khi bạn tăng gấp đôi
nhấp vào một chương trình, và nó mở ra,

1206
00:58:49,630 --> 00:58:51,921
và nó sẽ mở ra một số tài liệu Word
hay đại loại thế,

1207
00:58:51,921 --> 00:58:54,764
nó lưu nó tạm thời trong
RAM, vì RAM là nhanh hơn

1208
00:58:54,764 --> 00:58:56,680
hơn so với đĩa cứng của bạn, hoặc
ổ đĩa trạng thái rắn của bạn.

1209
00:58:56,680 --> 00:58:59,600
Vì vậy, nó chỉ là nơi chương trình đi
để sống khi họ đang chạy,

1210
00:58:59,600 --> 00:59:01,060
hoặc khi tập tin đang được sử dụng.

1211
00:59:01,060 --> 00:59:03,890
>> Vì vậy, bạn có những thứ mà nhìn
như bên này của máy tính xách tay của bạn,

1212
00:59:03,890 --> 00:59:06,320
hoặc những điều hơi lớn hơn
bên trong của máy tính để bàn của bạn.

1213
00:59:06,320 --> 00:59:10,440
Nhưng quan trọng là bạn chỉ có một
số lượng hữu hạn của những điều này.

1214
00:59:10,440 --> 00:59:14,230
Và chỉ có một số lượng hữu hạn của
phần cứng ngồi trên bàn này ngay

1215
00:59:14,230 --> 00:59:14,730
đây.

1216
00:59:14,730 --> 00:59:18,920
>> Vì vậy, chắc chắn, chúng ta không thể lưu trữ
số dài vô hạn.

1217
00:59:18,920 --> 00:59:22,030
Và, tuy nhiên, nếu bạn suy nghĩ lại về
trường lớp, bao nhiêu chữ số có thể

1218
00:59:22,030 --> 00:59:24,400
bạn có về bên phải
của một điểm thập phân?

1219
00:59:24,400 --> 00:59:27,680
Đối với vấn đề đó, có bao nhiêu chữ số có thể
bạn phải trái của một điểm thập phân?

1220
00:59:27,680 --> 00:59:29,300
Thực sự, vô cùng nhiều.

1221
00:59:29,300 --> 00:59:33,840
>> Bây giờ, con người chúng ta có thể chỉ
biết làm thế nào để phát âm triệu,

1222
00:59:33,840 --> 00:59:37,990
và tỷ, nghìn tỷ, và
nghìn triệu triệu, và quintillion.

1223
00:59:37,990 --> 00:59:42,370
Và tôi là đẩy các giới hạn của tôi
understanding-- hoặc my-- Tôi hiểu

1224
00:59:42,370 --> 00:59:44,110
con số, nhưng tôi
phát âm của con số.

1225
00:59:44,110 --> 00:59:47,720
Nhưng họ có thể nhận được vô cùng lớn với
vô hạn số chữ số bên trái

1226
00:59:47,720 --> 00:59:50,050
hoặc bên phải của một điểm thập phân.

1227
00:59:50,050 --> 00:59:53,040
>> Nhưng máy tính chỉ có một
số lượng hữu hạn của bộ nhớ,

1228
00:59:53,040 --> 00:59:56,510
một số hữu hạn các bóng bán dẫn, một
số hữu hạn các bóng đèn bên trong.

1229
00:59:56,510 --> 01:00:00,350
Vì vậy, những gì sẽ xảy ra khi
bạn chạy ra khỏi không gian?

1230
01:00:00,350 --> 01:00:02,620
Nói cách khác, nếu bạn
nghĩ lại tuần trước

1231
01:00:02,620 --> 01:00:06,160
khi chúng tôi nói chuyện về những con số
mình đang được đại diện trong hệ nhị phân,

1232
01:00:06,160 --> 01:00:08,480
giả sử rằng chúng ta đã có
8-bit giá trị này ở đây.

1233
01:00:08,480 --> 01:00:11,290
>> Và chúng tôi có bảy 1 và một 0.

1234
01:00:11,290 --> 01:00:13,827
Và giả sử rằng chúng ta muốn
thêm 1 giá trị này.

1235
01:00:13,827 --> 01:00:15,410
Đây là một số thực sự lớn ngay bây giờ.

1236
01:00:15,410 --> 01:00:19,610
>> Đây là 254, nếu tôi nhớ
toán học từ tuần cuối cùng bên phải.

1237
01:00:19,610 --> 01:00:22,480
Nhưng nếu tôi thay đổi
rằng ngoài cùng bên phải 0 đến 1?

1238
01:00:22,480 --> 01:00:25,800
Các số nguyên, của
Tất nhiên, trở thành tám 1.

1239
01:00:25,800 --> 01:00:27,050
Vì vậy, chúng tôi vẫn tốt.

1240
01:00:27,050 --> 01:00:30,204
>> Và đó có thể đại diện
255, mặc dù phụ thuộc vào bối cảnh

1241
01:00:30,204 --> 01:00:32,120
nó thực sự có thể đại diện
một số âm.

1242
01:00:32,120 --> 01:00:34,240
Nhưng thêm vào đó một thời điểm khác.

1243
01:00:34,240 --> 01:00:37,220
Điều này cảm thấy như nó về
cao như tôi có thể đếm.

1244
01:00:37,220 --> 01:00:38,290
>> Bây giờ, nó chỉ có 8 bit.

1245
01:00:38,290 --> 01:00:41,170
Và máy Mac của tôi, chắc chắn, có cách
hơn 8 bit của bộ nhớ.

1246
01:00:41,170 --> 01:00:42,170
Nhưng nó không có giới hạn.

1247
01:00:42,170 --> 01:00:46,230
Vì vậy, các lập luận tương tự áp dụng, thậm chí nếu chúng ta
có nhiều hơn những cái trên màn hình.

1248
01:00:46,230 --> 01:00:50,020
>> Nhưng điều gì sẽ xảy ra nếu bạn
lưu trữ số này, 255,

1249
01:00:50,020 --> 01:00:52,290
và bạn muốn tính cao hơn 1 chút?

1250
01:00:52,290 --> 01:00:54,600
Bạn muốn đi 255-256.

1251
01:00:54,600 --> 01:00:58,800
Vấn đề, tất nhiên, là nếu bạn
bắt đầu đếm từ số không như tuần trước,

1252
01:00:58,800 --> 01:01:02,670
bạn không thể tính là cao
là 256, hãy để một mình 257,

1253
01:01:02,670 --> 01:01:05,584
hãy để một mình 258, m vì những gì
sẽ xảy ra khi bạn thêm 1?

1254
01:01:05,584 --> 01:01:08,000
Nếu bạn làm trường lớp cũ
phương pháp tiếp cận, bạn đặt một 1 ở đây,

1255
01:01:08,000 --> 01:01:11,150
và sau đó 1 cộng 1 là 2, nhưng đó là
thực sự là một số không, bạn mang 1,

1256
01:01:11,150 --> 01:01:12,695
mang 1, mang 1.

1257
01:01:12,695 --> 01:01:15,620
Tất cả những điều này,
những nhân 1, đi đến số không.

1258
01:01:15,620 --> 01:01:20,820
Và bạn gió lên, vâng, như ai đó
chỉ ra, 1 ở phía bên tay trái.

1259
01:01:20,820 --> 01:01:25,540
Nhưng tất cả mọi thứ bạn có thể
thực sự thấy và phù hợp trong bộ nhớ

1260
01:01:25,540 --> 01:01:30,960
chỉ là tám 0, mà là để nói
tại một số điểm nếu bạn, một máy tính,

1261
01:01:30,960 --> 01:01:35,490
cố gắng đếm đủ cao, bạn đang
đi để bọc xung quanh, có vẻ như,

1262
01:01:35,490 --> 01:01:38,850
bằng không, hoặc thậm chí có tiêu cực
con số, mà thậm chí còn thấp hơn số không.

1263
01:01:38,850 --> 01:01:40,260
>> Và chúng tôi loại có thể thấy điều này.

1264
01:01:40,260 --> 01:01:42,900
Hãy để tôi đi trước và viết
một chương trình nhanh chóng thực sự ở đây.

1265
01:01:42,900 --> 01:01:46,690
Hãy để tôi đi trước và viết
một chương trình gọi là tràn.

1266
01:01:46,690 --> 01:01:52,980
Bao gồm CS50.h, bao gồm
chuẩn IO.h-- oh,

1267
01:01:52,980 --> 01:01:54,730
Tôi thực sự bỏ lỡ tô sáng cú pháp của tôi.

1268
01:01:54,730 --> 01:01:57,440
Vì vậy, hãy lưu này như overflow.c.

1269
01:01:57,440 --> 01:02:00,084
>> Và bây giờ int void-- chính
và chẳng bao lâu, chúng tôi sẽ

1270
01:02:00,084 --> 01:02:02,500
trở lại để giải thích lý do tại sao
chúng tôi tiếp tục viết int void main.

1271
01:02:02,500 --> 01:02:05,080
Nhưng hiện nay, chúng ta chỉ cần làm
nó, dùng nó cho các cấp.

1272
01:02:05,080 --> 01:02:09,200
Hãy cho bản thân mình một int,
và khởi tạo nó để 0.

1273
01:02:09,200 --> 01:02:14,716
>> Hãy để sau đó nhân làm cho int tôi nhận zero--
thực sự, chúng ta hãy làm một vòng lặp vô hạn

1274
01:02:14,716 --> 01:02:15,590
và xem những gì sẽ xảy ra.

1275
01:02:15,590 --> 01:02:25,440
Trong khi sự thật, sau đó hãy in ra n
là phần trăm i, gạch chéo ngược n, plug-in n.

1276
01:02:25,440 --> 01:02:30,200
Nhưng, bây giờ, chúng ta hãy làm n được n + 1.

1277
01:02:30,200 --> 01:02:32,660
>> Vì vậy, nói cách khác, trên mỗi
lần lặp của vòng lặp vô hạn này,

1278
01:02:32,660 --> 01:02:35,550
chúng ta hãy giá trị của n,
và thêm 1 vào nó, và sau đó

1279
01:02:35,550 --> 01:02:37,350
lưu kết quả lại n bên trái.

1280
01:02:37,350 --> 01:02:40,150
Và, trên thực tế, chúng tôi đã nhìn thấy cú pháp
hơi như thế này, một thời gian ngắn.

1281
01:02:40,150 --> 01:02:42,730
Một trick mát là thay vì
viết bài này ra,

1282
01:02:42,730 --> 01:02:45,770
bạn thực sự có thể nói một cộng với n bằng 1.

1283
01:02:45,770 --> 01:02:50,480
>> Hoặc nếu bạn thực sự muốn được ưa thích,
bạn có thể nói n cộng với cộng với dấu chấm phẩy.

1284
01:02:50,480 --> 01:02:53,130
Nhưng những Hai người này đang chỉ
những gì chúng ta gọi cú pháp đường

1285
01:02:53,130 --> 01:02:53,790
cho việc đầu tiên.

1286
01:02:53,790 --> 01:02:56,456
>> Điều đầu tiên là rõ ràng hơn,
hoàn toàn tốt đẹp, hoàn toàn chính xác.

1287
01:02:56,456 --> 01:02:58,470
Nhưng điều này là phổ biến hơn, tôi sẽ nói.

1288
01:02:58,470 --> 01:03:00,210
Vì vậy, chúng tôi sẽ làm điều này chỉ trong một khoảnh khắc.

1289
01:03:00,210 --> 01:03:04,685
>> Bây giờ chúng ta làm tràn, mà âm thanh
chứ không đáng ngại, dấu chấm dấu gạch chéo tràn.

1290
01:03:04,685 --> 01:03:07,380

1291
01:03:07,380 --> 01:03:12,852
Hãy xem, n ấy ngày càng lớn mạnh.

1292
01:03:12,852 --> 01:03:14,310
Nhưng hãy để suy nghĩ, làm thế nào lớn n có thể nhận được?

1293
01:03:14,310 --> 01:03:15,870
>> n là một số nguyên.

1294
01:03:15,870 --> 01:03:19,400
Chúng tôi nhìn thấy một thời điểm trước đây với kích thước của
ví dụ mà một int là bốn byte.

1295
01:03:19,400 --> 01:03:25,070
Chúng tôi biết từ tuần trước, bốn byte là
32 bit, vì 8 lần 4, đó là 32.

1296
01:03:25,070 --> 01:03:26,460
Đó sẽ là 4 tỷ đồng.

1297
01:03:26,460 --> 01:03:28,802
>> Và chúng tôi đang lên đến 800.000.

1298
01:03:28,802 --> 01:03:31,510
Điều này sẽ mất mãi mãi để
tính là cao như tôi có thể có thể.

1299
01:03:31,510 --> 01:03:33,635
Vì vậy, tôi sẽ đi trước,
như bạn có thể trước khi dài,

1300
01:03:33,635 --> 01:03:37,910
và nhấn Control C-- thẳng thắn, Control
C, rất nhiều, nơi kiểm soát C thường

1301
01:03:37,910 --> 01:03:39,034
phương tiện hủy.

1302
01:03:39,034 --> 01:03:41,200
Thật không may, bởi vì đây
đang chạy trong đám mây,

1303
01:03:41,200 --> 01:03:44,190
đôi khi các đám mây là
phun ra rất nhiều công cụ,

1304
01:03:44,190 --> 01:03:47,180
rất nhiều đầu ra, nó sẽ
mất một ít thời gian cho đầu vào của tôi

1305
01:03:47,180 --> 01:03:48,630
để có được các đám mây.

1306
01:03:48,630 --> 01:03:52,240
Vì vậy, mặc dù tôi nhấn
Control C một vài giây,

1307
01:03:52,240 --> 01:03:56,110
điều này chắc chắn là một bên
hiệu lực của một vòng lặp vô hạn.

1308
01:03:56,110 --> 01:03:59,070
>> Và như vậy trong trường hợp này, chúng tôi
sẽ rời khỏi đó được.

1309
01:03:59,070 --> 01:04:02,050
Và chúng ta sẽ thêm một
cửa sổ thiết bị đầu cuối trên đây

1310
01:04:02,050 --> 01:04:06,186
với các cộng, trong đó tất nhiên không
như thế, vì nó vẫn nghĩ.

1311
01:04:06,186 --> 01:04:08,310
Và chúng ta hãy đi trước và được
hợp lý hơn một chút.

1312
01:04:08,310 --> 01:04:10,768
>> Tôi sẽ đi trước và làm
này chỉ có hữu hạn nhiều lần.

1313
01:04:10,768 --> 01:04:13,047
Hãy sử dụng một vòng lặp for,
mà tôi đã đề cập đến trước đó.

1314
01:04:13,047 --> 01:04:13,630
Làm thôi nào.

1315
01:04:13,630 --> 01:04:16,430
Hãy cho tôi một biến int i được 0.

1316
01:04:16,430 --> 01:04:20,430
i nhỏ hơn, hãy nói, 64 i ++.

1317
01:04:20,430 --> 01:04:27,010
Và bây giờ hãy để tôi đi trước và in ấn
ra n là phần trăm tôi, dấu phẩy n.

1318
01:04:27,010 --> 01:04:30,547
Và sau đó n-- này vẫn là
sẽ mất mãi mãi.

1319
01:04:30,547 --> 01:04:31,130
Làm thôi nào.

1320
01:04:31,130 --> 01:04:33,620
>> n được n lần 2.

1321
01:04:33,620 --> 01:04:37,140
Hoặc chúng ta có thể được ưa thích
và làm lần = 2.

1322
01:04:37,140 --> 01:04:40,120
Nhưng chúng ta hãy chỉ nói n
bằng chính nó, lần 2.

1323
01:04:40,120 --> 01:04:42,321
Nói cách khác, trong này
phiên bản mới của chương trình,

1324
01:04:42,321 --> 01:04:44,820
Tôi không muốn chờ đợi mãi mãi
từ như 800.000 đến 4 tỷ đồng.

1325
01:04:44,820 --> 01:04:46,070
Hãy chỉ vượt qua điều này với.

1326
01:04:46,070 --> 01:04:47,920
>> Hãy thực sự tăng gấp đôi n mỗi lần.

1327
01:04:47,920 --> 01:04:50,660
Trong đó, thu hồi, tăng gấp đôi là
đối diện có, tất nhiên.

1328
01:04:50,660 --> 01:04:53,035
Và trong khi tuần trước chúng tôi có
một cái gì đó một lần nữa, và một lần nữa,

1329
01:04:53,035 --> 01:04:55,200
và một lần nữa, siêu nhanh,
tăng gấp đôi chắc chắn sẽ

1330
01:04:55,200 --> 01:05:01,080
đưa chúng ta từ 1 đến tốt nhất
giá trị mà chúng ta có thể đếm đến với một int.

1331
01:05:01,080 --> 01:05:02,750
>> Vì vậy, chúng ta hãy làm chính xác điều này.

1332
01:05:02,750 --> 01:05:04,720
Và chúng ta sẽ trở lại vấn đề này trước khi dài.

1333
01:05:04,720 --> 01:05:07,180
Nhưng điều này, một lần nữa, giống như
khối lặp lại trong Scratch.

1334
01:05:07,180 --> 01:05:08,600
Và bạn sẽ sử dụng này trước khi dài.

1335
01:05:08,600 --> 01:05:13,170
>> Điều này chỉ có nghĩa là đếm từ con số không
lên, nhưng không bằng nhau, đến 64.

1336
01:05:13,170 --> 01:05:17,285
Và trên mỗi lần lặp này
vòng lặp, chỉ cần giữ incrementing i.

1337
01:05:17,285 --> 01:05:21,990
Vì vậy, i ++ - và xây dựng chung này
trên dòng 7 chỉ là một cách siêu phổ biến

1338
01:05:21,990 --> 01:05:25,290
lặp đi lặp lại một số dòng
mã, một số số lần.

1339
01:05:25,290 --> 01:05:26,362
Những dòng mã?

1340
01:05:26,362 --> 01:05:28,570
Những dấu ngoặc nhọn, như bạn
có thể lượm lặt từ bây giờ,

1341
01:05:28,570 --> 01:05:29,780
nghĩa là, làm như sau.

1342
01:05:29,780 --> 01:05:32,510
>> Đó là trong Scratch như thế, khi
nó có các khối màu vàng

1343
01:05:32,510 --> 01:05:35,680
và màu sắc khác loại
ôm hôn hoặc ôm khối khác.

1344
01:05:35,680 --> 01:05:37,750
Đó là những gì những người xoăn
niềng răng đang làm ở đây.

1345
01:05:37,750 --> 01:05:43,200
Vì vậy, nếu tôi nhận được cú pháp của tôi right-- bạn
có thể nhìn thấy biểu tượng cà rốt trong các phương tiện C

1346
01:05:43,200 --> 01:05:45,706
đó là bao nhiêu lần tôi đã
cố gắng để giải quyết vấn đề này.

1347
01:05:45,706 --> 01:05:48,330
Vì vậy, hãy để nhân thoát khỏi một mà
hoàn toàn, và đóng cửa sổ đó.

1348
01:05:48,330 --> 01:05:49,520
Và chúng tôi sẽ sử dụng những cái mới.

1349
01:05:49,520 --> 01:05:54,980
Hãy tràn, dấu chấm dấu gạch chéo
tràn, Enter, tất cả các quyền,

1350
01:05:54,980 --> 01:05:56,090
nó trông xấu lúc đầu.

1351
01:05:56,090 --> 01:05:59,200
Nhưng chúng ta hãy di chuyển trở lại trong thời gian,
bởi vì tôi đã làm điều này 64 lần.

1352
01:05:59,200 --> 01:06:01,700
>> Và thông báo thời gian đầu tiên, n là 1.

1353
01:06:01,700 --> 01:06:06,110
lần thứ hai, n là 2,
sau đó 4, sau đó 8, sau đó 16.

1354
01:06:06,110 --> 01:06:12,450
Và có vẻ như rằng ngay sau khi
Tôi nhận được để khoảng 1 tỷ đồng,

1355
01:06:12,450 --> 01:06:15,800
nếu tôi tăng gấp đôi nó một lần nữa, rằng
nên cho tôi 2 tỷ.

1356
01:06:15,800 --> 01:06:17,980
Nhưng hóa ra, đó là
ngay trên đỉnh.

1357
01:06:17,980 --> 01:06:21,930
>> Và do đó, nó thực sự tràn
một int từ 1 tỷ

1358
01:06:21,930 --> 01:06:26,514
để khoảng âm 2
tỷ đồng, vì một số nguyên,

1359
01:06:26,514 --> 01:06:28,430
không giống như những con số chúng tôi
được giả định vào tuần trước,

1360
01:06:28,430 --> 01:06:31,397
có thể có cả tích cực và tiêu cực
trong thực tế và trong một máy tính.

1361
01:06:31,397 --> 01:06:33,730
Và như vậy ít nhất một trong những
bit là bị đánh cắp một cách hiệu quả.

1362
01:06:33,730 --> 01:06:37,190
Vì vậy, chúng tôi thực sự chỉ có 31 bit,
hoặc 2 tỷ giá trị có thể.

1363
01:06:37,190 --> 01:06:41,220
>> Nhưng hiện nay, các takeaway khá
đơn giản, bất cứ điều gì các con số

1364
01:06:41,220 --> 01:06:45,280
và bất cứ điều gì các môn toán là,
điều gì xấu xảy ra cuối cùng,

1365
01:06:45,280 --> 01:06:49,980
bởi vì cuối cùng bạn đang cố gắng để
hoán vị các bit một trong quá nhiều lần.

1366
01:06:49,980 --> 01:06:54,060
Và bạn có hiệu quả đi từ tất cả
1 để có thể tất cả 0, hoặc có thể

1367
01:06:54,060 --> 01:06:57,260
chỉ một số mô hình khác mà nó
rõ ràng, tùy thuộc vào hoàn cảnh,

1368
01:06:57,260 --> 01:06:59,342
có thể được hiểu là một số âm.

1369
01:06:59,342 --> 01:07:02,300
Và do đó, nó sẽ có vẻ tôi cao nhất
có thể tính vào chương trình đặc biệt này

1370
01:07:02,300 --> 01:07:04,210
chỉ khoảng 1 tỷ là.

1371
01:07:04,210 --> 01:07:05,760
Nhưng có một giải pháp một phần ở đây.

1372
01:07:05,760 --> 01:07:06,480
Bạn biết những gì?

1373
01:07:06,480 --> 01:07:10,600
>> Hãy để tôi thay đổi từ một
int đến một lâu dài.

1374
01:07:10,600 --> 01:07:13,633
Và hãy để tôi đi trước đây
và say-- tôi sẽ có

1375
01:07:13,633 --> 01:07:15,290
để thay đổi sang một unsigned long.

1376
01:07:15,290 --> 01:07:19,860
Hoặc, để xem nào, tôi không bao giờ nhớ bản thân mình.

1377
01:07:19,860 --> 01:07:22,920
>> Hãy đi trước và làm tràn.

1378
01:07:22,920 --> 01:07:24,860
Không, đó không phải nó, LLD, cảm ơn bạn.

1379
01:07:24,860 --> 01:07:26,430
Vì vậy, đôi khi Clang có thể hữu ích.

1380
01:07:26,430 --> 01:07:30,550
Tôi không nhớ những gì định dạng
specifier là một lâu dài.

1381
01:07:30,550 --> 01:07:31,950
>> Nhưng, thực sự, Clang nói với tôi.

1382
01:07:31,950 --> 01:07:34,570
Màu xanh lá cây là một số loại tốt,
vẫn có nghĩa là bạn đã thực hiện một sai lầm.

1383
01:07:34,570 --> 01:07:36,190
Nó đoán rằng tôi có nghĩa là LLD.

1384
01:07:36,190 --> 01:07:41,750
>> Vì vậy, hãy để tôi mang nó là lời khuyên, một dài
số thập phân dài, tiết kiệm mà.

1385
01:07:41,750 --> 01:07:46,190
Và hãy để tôi chạy lại nó, chấm
cắt giảm tràn, Enter.

1386
01:07:46,190 --> 01:07:48,020
Và bây giờ những gì là mát mẻ là điều này.

1387
01:07:48,020 --> 01:07:52,140
>> Nếu tôi di chuyển ngược thời gian, chúng tôi vẫn bắt đầu
đếm ở cùng place-- 1, 2, 4,

1388
01:07:52,140 --> 01:07:53,220
8, 16.

1389
01:07:53,220 --> 01:07:57,860
Thông báo, chúng tôi nhận được tất cả các
cách lên đến 1 tỷ đồng.

1390
01:07:57,860 --> 01:08:00,070
Nhưng sau đó chúng tôi một cách an toàn đến 2 tỷ đồng.

1391
01:08:00,070 --> 01:08:04,300
>> Sau đó chúng ta có được đến 4 tỷ đồng,
sau đó 8 tỷ đồng, 17 tỷ đồng.

1392
01:08:04,300 --> 01:08:06,340
Và chúng tôi đi cao hơn, và
cao hơn và cao hơn.

1393
01:08:06,340 --> 01:08:08,740
Cuối cùng, điều này, quá, nghỉ giải lao.

1394
01:08:08,740 --> 01:08:12,350
>> Cuối cùng, với một lâu dài,
đó là giá trị 64-bit, không

1395
01:08:12,350 --> 01:08:16,660
một giá trị 32-bit, nếu bạn đếm
quá cao, bạn quấn quanh 0.

1396
01:08:16,660 --> 01:08:19,410
Và trong trường hợp này, chúng tôi xảy ra để
kết thúc với một số âm.

1397
01:08:19,410 --> 01:08:20,550
>> Vì vậy, đây là một vấn đề.

1398
01:08:20,550 --> 01:08:23,439
Và nó quay ra rằng điều này
vấn đề không phải là tất cả những phức tạp.

1399
01:08:23,439 --> 01:08:26,060
Mặc dù tôi đã cố tình
gây ra nó với những sai lầm,

1400
01:08:26,060 --> 01:08:29,149
hóa ra chúng ta thấy nó loại tất cả
xung quanh chúng ta, hoặc ít nhất là một số trong chúng ta làm.

1401
01:08:29,149 --> 01:08:31,939
>> Vì vậy, trong Lego Star Wars, nếu
bạn đã từng chơi các trò chơi,

1402
01:08:31,939 --> 01:08:36,830
nó quay ra bạn có thể đi xung quanh
phá vỡ những thứ trong LEGO thế giới,

1403
01:08:36,830 --> 01:08:39,640
và thu thập tiền xu, về cơ bản.

1404
01:08:39,640 --> 01:08:42,200
Và nếu bạn đã từng chơi
trò chơi này quá nhiều thời gian,

1405
01:08:42,200 --> 01:08:45,630
như cá nhân giấu tên này
ở đây đã làm, tổng số

1406
01:08:45,630 --> 01:08:49,700
tiền cổ mà bạn có thể thu thập
là, dường như, 4 tỷ đồng.

1407
01:08:49,700 --> 01:08:51,240
>> Bây giờ, với nó thực sự làm tròn.

1408
01:08:51,240 --> 01:08:53,239
Vì vậy, LEGO đã cố gắng để
giữ cho mọi thứ người dùng thân thiện.

1409
01:08:53,239 --> 01:08:56,779
Họ đã không làm điều đó một cách chính xác 2
32 điện, mỗi tuần trước.

1410
01:08:56,779 --> 01:08:58,310
Nhưng 4 tỷ là một lý do.

1411
01:08:58,310 --> 01:09:01,979
Có vẻ như, dựa trên thông tin này,
mà LEGO, và công ty mà

1412
01:09:01,979 --> 01:09:05,624
làm phần mềm thực tế này, quyết định
rằng số lượng tối đa của đồng tiền

1413
01:09:05,624 --> 01:09:07,540
người sử dụng có thể tích lũy
là, thực sự, 4 tỷ đồng,

1414
01:09:07,540 --> 01:09:15,069
bởi vì họ đã chọn trong mã của họ
sử dụng không phải là dài lâu, rõ ràng,

1415
01:09:15,069 --> 01:09:19,140
nhưng chỉ là một số nguyên, một unsigned
số nguyên, chỉ có một số nguyên dương, mà

1416
01:09:19,140 --> 01:09:21,089
giá trị tối đa khoảng là.

1417
01:09:21,089 --> 01:09:22,380
Vâng, đây là một số khác vui.

1418
01:09:22,380 --> 01:09:26,500
Vì vậy, trong các trò chơi Civilization, mà
một số bạn có thể quen với

1419
01:09:26,500 --> 01:09:29,660
nó chỉ ra rằng năm trước đó
là một lỗi trong trò chơi đó đây

1420
01:09:29,660 --> 01:09:31,750
nếu bạn chơi vai trò
Gandhi trong game,

1421
01:09:31,750 --> 01:09:37,020
thay vì anh ta là rất hòa bình,
thay vào đó là vô cùng, vô cùng

1422
01:09:37,020 --> 01:09:39,399
tích cực, trong một số trường hợp.

1423
01:09:39,399 --> 01:09:43,529
Đặc biệt, cách mà nền văn minh
công việc là vì nếu bạn, người chơi,

1424
01:09:43,529 --> 01:09:47,680
áp dụng dân chủ, của bạn
điểm gây hấn được

1425
01:09:47,680 --> 01:09:51,130
giảm đi hai, do đó trừ đi
trừ đi, và sau đó trừ đi trừ.

1426
01:09:51,130 --> 01:09:53,569
>> Vì vậy, bạn trừ đi 2 từ
iterating thực tế của bạn.

1427
01:09:53,569 --> 01:09:59,650
Thật không may, nếu bạn là iterating
ban đầu 1, và bạn trừ 2 từ nó

1428
01:09:59,650 --> 01:10:02,050
sau khi áp dụng dân chủ
như Gandhi ở đây có thể

1429
01:10:02,050 --> 01:10:05,200
đã làm, bởi vì ông rất passive--
1 trên quy mô của hấn.

1430
01:10:05,200 --> 01:10:07,830
Nhưng nếu anh có chính dân chủ, sau đó
ông đi từ 1 đến 1 âm.

1431
01:10:07,830 --> 01:10:14,470
>> Thật không may, họ đã
sử dụng số unsigned,

1432
01:10:14,470 --> 01:10:18,400
có nghĩa là họ đối xử thậm chí tiêu cực
số như thể họ là tích cực.

1433
01:10:18,400 --> 01:10:22,780
Và nó chỉ ra rằng
tương đương tích cực của âm 1,

1434
01:10:22,780 --> 01:10:26,480
trong các chương trình máy tính điển hình, là 255.

1435
01:10:26,480 --> 01:10:30,250
Vì vậy, nếu có chính Gandhi
dân chủ, và do đó có

1436
01:10:30,250 --> 01:10:35,470
điểm gây hấn của ông giảm,
nó thực sự cuộn xung quanh đến 255

1437
01:10:35,470 --> 01:10:38,470
và làm cho anh ta nhiều nhất
nhân vật tích cực trong các trò chơi.

1438
01:10:38,470 --> 01:10:39,930
Vì vậy, bạn có thể Google lên trên này.

1439
01:10:39,930 --> 01:10:42,380
Và thực sự nó là, một
lỗi lập trình ngẫu nhiên,

1440
01:10:42,380 --> 01:10:46,010
nhưng đó là bước khá
các truyền thuyết từ bao giờ.

1441
01:10:46,010 --> 01:10:47,360
>> Đó là tất cả vui vẻ và dễ thương.

1442
01:10:47,360 --> 01:10:50,760
đáng sợ hơn nữa là khi thực tế
thiết bị thế giới thực, và không phải trò chơi,

1443
01:10:50,760 --> 01:10:51,820
có những lỗi tương tự.

1444
01:10:51,820 --> 01:10:57,500
Trong thực tế, chỉ một năm trước, một bài viết đến
hiểu về các máy bay Boeing 787 Dreamliner.

1445
01:10:57,500 --> 01:10:59,850
>> Và các bài viết ở đầu
lướt qua đọc một chút phức tạp.

1446
01:10:59,850 --> 01:11:04,480
Nhưng nó nói điều này, một phần mềm
dễ bị tổn thương trong của Boeing

1447
01:11:04,480 --> 01:11:07,790
mới 787 Dreamliner máy bay phản lực có
khả năng gây ra các phi công

1448
01:11:07,790 --> 01:11:10,220
để mất quyền kiểm soát
máy bay, có thể

1449
01:11:10,220 --> 01:11:14,750
vào giữa chuyến bay, các quan chức FAA
hãng hàng không cảnh báo thời gian gần đây.

1450
01:11:14,750 --> 01:11:17,520
Đó là việc xác định
rằng một mô hình 787

1451
01:11:17,520 --> 01:11:22,770
máy bay đã được cung cấp
liên tục trong 248 ngày

1452
01:11:22,770 --> 01:11:27,880
có thể mất tất cả dòng điện xoay chiều, AC,
năng lượng điện do các máy phát điện

1453
01:11:27,880 --> 01:11:31,892
đơn vị kiểm soát, GCUs, đồng thời
đi vào chế độ an toàn không.

1454
01:11:31,892 --> 01:11:32,850
Đó là loại mất tôi.

1455
01:11:32,850 --> 01:11:38,390
Nhưng các bản ghi nhớ đã nói, OK, bây giờ tôi đã nhận rằng,
bệnh này được gây ra bởi một phần mềm

1456
01:11:38,390 --> 01:11:41,590
chống lại nội bộ để
điều khiển máy phát điện

1457
01:11:41,590 --> 01:11:47,860
đơn vị sẽ tràn sau khi
248 ngày của điện liên tục.

1458
01:11:47,860 --> 01:11:50,070
Chúng tôi đang phát hành này
chú ý để tránh mất

1459
01:11:50,070 --> 01:11:52,300
của tất cả các AC điện
điện, có thể dẫn

1460
01:11:52,300 --> 01:11:53,980
đến mất kiểm soát của máy bay.

1461
01:11:53,980 --> 01:11:58,380
>> Vì vậy, theo nghĩa đen, có một số nguyên,
hoặc một số kiểu dữ liệu tương đương,

1462
01:11:58,380 --> 01:12:00,960
được sử dụng trong phần mềm
trong một chiếc máy bay thực tế

1463
01:12:00,960 --> 01:12:03,756
rằng nếu bạn giữ cho máy bay của bạn
đủ lâu, mà dường

1464
01:12:03,756 --> 01:12:06,880
có thể là trường hợp nếu bạn chỉ cần chạy
họ liên tục và không bao giờ rút

1465
01:12:06,880 --> 01:12:09,810
máy bay của bạn, có vẻ như, hoặc
để cho pin của nó chết,

1466
01:12:09,810 --> 01:12:12,840
cuối cùng sẽ đếm lên, lên,
lên, lên, lên, và lên.

1467
01:12:12,840 --> 01:12:15,150
>> Và, bởi bản chất, một
số lượng hữu hạn của bộ nhớ

1468
01:12:15,150 --> 01:12:18,880
sẽ tràn, lăn trở lại
không hoặc một số giá trị tiêu cực,

1469
01:12:18,880 --> 01:12:22,920
một tác dụng phụ của nó là các
Thực tế đáng sợ thật

1470
01:12:22,920 --> 01:12:26,970
rằng chiếc máy bay có thể cần
được khởi động lại, hiệu quả,

1471
01:12:26,970 --> 01:12:30,290
hoặc có thể rơi, tồi tệ hơn, khi nó bay.

1472
01:12:30,290 --> 01:12:32,230
Vì vậy, các loại của các vấn đề
vẫn còn với chúng tôi,

1473
01:12:32,230 --> 01:12:36,130
even-- đây là một bài viết năm 2015,
tất cả các đáng sợ hơn nữa

1474
01:12:36,130 --> 01:12:39,100
khi bạn không nhất thiết phải
hiểu, đánh giá cao, hoặc dự đoán

1475
01:12:39,100 --> 01:12:41,640
những loại lỗi.

1476
01:12:41,640 --> 01:12:45,030
>> Vì vậy, nó quay ra có một khác
điều xấu về biểu diễn dữ liệu.

1477
01:12:45,030 --> 01:12:50,080
Nó chỉ ra rằng thậm chí nổi là
loại sai lầm, bởi vì phao nổi, quá,

1478
01:12:50,080 --> 01:12:54,440
Tôi đề xuất được 32 bit, hoặc
có lẽ 64 nếu bạn sử dụng một đôi.

1479
01:12:54,440 --> 01:12:56,070
Nhưng đó vẫn là hữu hạn.

1480
01:12:56,070 --> 01:13:00,070
>> Và nắm bắt được rằng nếu bạn có thể
đưa một số lượng vô hạn các số

1481
01:13:00,070 --> 01:13:02,460
sau dấu thập phân,
không có cách nào bạn

1482
01:13:02,460 --> 01:13:05,690
có thể đại diện cho tất cả các thể
con số mà chúng tôi được dạy

1483
01:13:05,690 --> 01:13:07,990
trong lớp học có thể tồn tại trên thế giới.

1484
01:13:07,990 --> 01:13:11,870
Một máy tính, về cơ bản, có tới
chọn một tập hợp con của những con số

1485
01:13:11,870 --> 01:13:13,200
thể hiện chính xác.

1486
01:13:13,200 --> 01:13:15,450
>> Bây giờ, máy tính có
vòng có thể một chút,

1487
01:13:15,450 --> 01:13:20,900
và có thể cho phép bạn để khoảng cửa hàng
bất kỳ số nào bạn có thể muốn.

1488
01:13:20,900 --> 01:13:23,940
Nhưng chỉ bằng trực giác, nếu bạn
có một số hữu hạn các bit,

1489
01:13:23,940 --> 01:13:27,560
bạn chỉ có thể hoán vị cho họ
trong rất nhiều cách hữu hạn.

1490
01:13:27,560 --> 01:13:29,570
Vì vậy, bạn có thể không có thể
sử dụng một số lượng hữu hạn

1491
01:13:29,570 --> 01:13:32,880
các hoán vị của các bit,
mẫu số không và những người thân,

1492
01:13:32,880 --> 01:13:35,940
đại diện cho một vô hạn
số lượng các số,

1493
01:13:35,940 --> 01:13:40,370
điều này cho thấy rằng máy tính có thể
rất tốt được nói dối với chúng tôi đôi khi.

1494
01:13:40,370 --> 01:13:41,770
>> Trong thực tế, chúng ta hãy làm điều này.

1495
01:13:41,770 --> 01:13:44,239
Hãy để tôi quay trở lại vào CS50 IDE.

1496
01:13:44,239 --> 01:13:46,030
Hãy để tôi đi trước và
tạo ra một chương trình nhỏ

1497
01:13:46,030 --> 01:13:50,940
gọi là không chính xác, để cho thấy rằng
máy tính được, quả thực, không chính xác.

1498
01:13:50,940 --> 01:13:54,910
>> Và hãy để tôi đi trước và bắt đầu với
một số mã có từ trước,

1499
01:13:54,910 --> 01:13:56,830
và bây giờ chỉ cần làm như sau.

1500
01:13:56,830 --> 01:14:06,640
Hãy để tôi đi trước và làm printf, phần trăm
f, n xuyệc ngược, 1 chia cho 10.

1501
01:14:06,640 --> 01:14:10,430
Nói cách khác, chúng ta hãy cùng tìm hiểu sâu hơn
1/10, như 1 và chia cho 10.

1502
01:14:10,430 --> 01:14:12,760
Chắc chắn, một máy tính có thể đại diện cho 1/10.

1503
01:14:12,760 --> 01:14:16,620
>> Vì vậy, chúng ta hãy đi trước và thực hiện không chính xác.

1504
01:14:16,620 --> 01:14:17,390
Hãy xem.

1505
01:14:17,390 --> 01:14:19,210
Format định gõ đôi.

1506
01:14:19,210 --> 01:14:21,160
Nhưng đối số có kiểu int.

1507
01:14:21,160 --> 01:14:22,040
Những gì đang xảy ra?

1508
01:14:22,040 --> 01:14:24,970
>> Oh, thú vị, vì vậy nó là một
bài học kinh nghiệm từ trước.

1509
01:14:24,970 --> 01:14:29,050
Tôi đang nói, hey, máy tính chương trình
tôi một float với trăm f.

1510
01:14:29,050 --> 01:14:31,200
Nhưng tôi cho nó 2 ints.

1511
01:14:31,200 --> 01:14:34,120
Vì vậy, nó quay ra, tôi có thể sửa chữa
này trong một vài cách.

1512
01:14:34,120 --> 01:14:41,430
>> Tôi chỉ có thể biến một thành 1.0, và
10 thành 10,0, mà sẽ, thực sự,

1513
01:14:41,430 --> 01:14:45,390
có tác dụng chuyển đổi
chúng vào floats-- vẫn hy vọng

1514
01:14:45,390 --> 01:14:46,180
cùng một số.

1515
01:14:46,180 --> 01:14:48,880
Hoặc nó quay ra có điều gì đó
chúng ta sẽ thấy một lần nữa trước khi dài.

1516
01:14:48,880 --> 01:14:50,170
Bạn có thể cast các con số.

1517
01:14:50,170 --> 01:14:52,880
>> Bạn có thể sử dụng dấu ngoặc đơn này
biểu thức, bạn có thể nói,

1518
01:14:52,880 --> 01:14:55,560
hey, máy tính, thực hiện việc này
10, mà tôi biết là một int.

1519
01:14:55,560 --> 01:14:57,660
Nhưng đối xử với nó, xin vui lòng,
như thể đó là một phao.

1520
01:14:57,660 --> 01:14:59,680
Nhưng điều này cảm thấy không cần thiết phức tạp.

1521
01:14:59,680 --> 01:15:02,040
>> Đối với mục đích của chúng tôi ngày hôm nay,
chúng ta hãy chỉ theo nghĩa đen

1522
01:15:02,040 --> 01:15:05,700
làm cho họ nổi giá trị điểm
với một điểm thập phân, như thế này.

1523
01:15:05,700 --> 01:15:10,060
Hãy để tôi đi trước và chạy lại, làm cho
không chính xác, tốt, dấu chấm dấu gạch chéo

1524
01:15:10,060 --> 01:15:11,870
không chính xác, nhập.

1525
01:15:11,870 --> 01:15:13,990
OK, chúng tôi đang tìm kiếm tốt.

1526
01:15:13,990 --> 01:15:21,194
>> 1 chia cho 10, theo tôi
Mac ở đây, là, thực sự, 0,100000.

1527
01:15:21,194 --> 01:15:24,360
Bây giờ, tôi đã được dạy trong trường lớp có
phải là một số lượng vô hạn của 0 của.

1528
01:15:24,360 --> 01:15:26,151
Vì vậy, hãy thử ít nhất một
để xem một số trong những người.

1529
01:15:26,151 --> 01:15:29,770
Nó chỉ ra rằng printf là một chút
fancier vẫn hơn chúng ta đã sử dụng.

1530
01:15:29,770 --> 01:15:33,890
Hóa ra bạn không cần phải chỉ định
chỉ phần trăm f, hoặc chỉ phần trăm tôi.

1531
01:15:33,890 --> 01:15:36,830
Bạn thực sự có thể chỉ định
một số tùy chọn điều khiển ở đây.

1532
01:15:36,830 --> 01:15:39,470
>> Cụ thể, tôi sẽ
để nói, hey, printf,

1533
01:15:39,470 --> 01:15:42,660
thực sự cho tôi 10 điểm thập phân.

1534
01:15:42,660 --> 01:15:43,820
Vì vậy, có vẻ một chút lạ.

1535
01:15:43,820 --> 01:15:45,845
Nhưng bạn nói phần trăm,
dot, bao nhiêu số

1536
01:15:45,845 --> 01:15:47,970
bạn muốn xem sau
điểm thập phân, và sau đó f

1537
01:15:47,970 --> 01:15:51,340
cho bằng phẳng, chỉ vì đó là
những tài liệu nói rằng.

1538
01:15:51,340 --> 01:15:53,080
Hãy để tôi đi trước và tiết kiệm mà.

1539
01:15:53,080 --> 01:15:55,460
>> Và hãy chú ý quá, tôi nhận được
mệt mỏi của gõ lại mọi thứ.

1540
01:15:55,460 --> 01:15:58,900
Vì vậy, tôi chỉ cần thiết lập lên và
mũi tên xuống trên các phím của tôi ở đây.

1541
01:15:58,900 --> 01:16:01,710
Và nếu tôi tiếp tục đánh lên, bạn
có thể xem tất cả các lệnh

1542
01:16:01,710 --> 01:16:04,090
mà tôi thực hiện, hoặc không đúng cách thực hiện.

1543
01:16:04,090 --> 01:16:07,630
>> Và tôi sẽ đi trước bây giờ và
không thực sự sử dụng, rõ ràng.

1544
01:16:07,630 --> 01:16:14,416
Hãy tính thiếu chính xác, chấm
giảm imprecision-- vậy

1545
01:16:14,416 --> 01:16:16,290
những gì tôi đã được dạy trong
học lớp kiểm tra ra.

1546
01:16:16,290 --> 01:16:22,010
Ngay cả khi tôi in nó đến 10 chữ số thập phân
đặt nó, thực sự, là 0,10000.

1547
01:16:22,010 --> 01:16:22,840
Nhưng bạn biết những gì?

1548
01:16:22,840 --> 01:16:24,150
>> Hãy có được một chút tham lam.

1549
01:16:24,150 --> 01:16:26,990
Hãy nói rằng, như thế, chỉ cho tôi 55
chỉ sau khi các số thập phân.

1550
01:16:26,990 --> 01:16:29,160
Hãy thực sự mất này
chương trình ra cho một spin.

1551
01:16:29,160 --> 01:16:34,170
Hãy để tôi làm lại nó với make
không chính xác, chấm dấu gạch chéo, không rõ ràng.

1552
01:16:34,170 --> 01:16:35,390
>> Và ở đây chúng tôi đi.

1553
01:16:35,390 --> 01:16:37,420
thời thơ ấu của bạn là một lời nói dối.

1554
01:16:37,420 --> 01:16:51,410
Rõ ràng, 1 chia cho 10 thực sự là
0.100000000000000005551115123--

1555
01:16:51,410 --> 01:16:52,740
>> Điều gì đang xảy ra?

1556
01:16:52,740 --> 01:16:56,360
Vâng, nó quay ra, nếu bạn loại
tìm đủ xa ra trong tiềm ẩn

1557
01:16:56,360 --> 01:16:58,950
đại diện này
số lượng, nó thực sự

1558
01:16:58,950 --> 01:17:03,400
là không chính xác 1/10 hay 0,1 và
một số lượng vô hạn của số không.

1559
01:17:03,400 --> 01:17:04,630
Bây giờ, tại sao vậy?

1560
01:17:04,630 --> 01:17:09,250
>> Vâng, mặc dù đây là một đơn giản
số để con người chúng ta, 1 chia cho 10,

1561
01:17:09,250 --> 01:17:13,910
nó vẫn là một trong vô số
con số mà chúng ta có thể nghĩ ra.

1562
01:17:13,910 --> 01:17:17,490
Nhưng một máy tính chỉ có thể đại diện
hữu hạn số lượng nhiều như vậy.

1563
01:17:17,490 --> 01:17:21,710
Và như vậy, hiệu quả, những gì
máy tính được hiển thị chúng tôi là gần gũi nhất của nó

1564
01:17:21,710 --> 01:17:25,940
xấp xỉ với số
chúng ta muốn tin là 1/10,

1565
01:17:25,940 --> 01:17:30,760
hoặc thực sự 0,10000 vô cùng tận.

1566
01:17:30,760 --> 01:17:33,425
>> Thay vào đó, mặc dù, đây là
gần như nó có thể nhận được.

1567
01:17:33,425 --> 01:17:35,300
Và, quả thật vậy, nếu bạn nhìn
bên dưới mui xe,

1568
01:17:35,300 --> 01:17:40,050
như chúng ta đang ở đây bằng cách tìm kiếm
55 chữ số sau chữ số thập phân,

1569
01:17:40,050 --> 01:17:42,990
chúng ta thực sự nhìn thấy thực tế đó.

1570
01:17:42,990 --> 01:17:45,610
Bây giờ là một sang một bên, nếu bạn đã
bao giờ nhìn thấy movie--

1571
01:17:45,610 --> 01:17:48,780
hầu hết các bạn có thể haven't--
nhưng Superman 3 cách đây vài năm,

1572
01:17:48,780 --> 01:17:52,500
Richard Pryor chất đòn bẩy này
thực tế trong công ty của mình để ăn cắp rất nhiều

1573
01:17:52,500 --> 01:17:56,500
của phân số và các phần phân đoạn của các đồng xu,
vì company-- khi tôi gọi lại,

1574
01:17:56,500 --> 01:18:00,210
nó được một while-- cơ bản là
vứt đi bất cứ điều gì đó không phù hợp

1575
01:18:00,210 --> 01:18:01,790
vào các khái niệm về xu.

1576
01:18:01,790 --> 01:18:04,480
>> Nhưng nếu bạn thêm lên tất cả những
nhỏ xíu, nhỏ xíu, con số nhỏ bé lại,

1577
01:18:04,480 --> 01:18:07,960
và một lần nữa, và một lần nữa, bạn có thể, như trong
trường hợp của mình, làm cho một số lượng tốt của tiền bạc.

1578
01:18:07,960 --> 01:18:11,010
>> Đó là ý tưởng tương tự đã được tách ra bởi
một nhiều gần đây, nhưng hiện vẫn còn lớn tuổi

1579
01:18:11,010 --> 01:18:13,500
bộ phim, được gọi là không gian văn phòng,
nơi mà những kẻ trong bộ phim đó,

1580
01:18:13,500 --> 01:18:16,501
đã làm điều tương tự, vặn nó lên
hoàn toàn, đã kết thúc với quá nhiều

1581
01:18:16,501 --> 01:18:17,666
tiền trong tài khoản ngân hàng của họ.

1582
01:18:17,666 --> 01:18:18,800
Đó là tất cả đều rất đáng ngờ.

1583
01:18:18,800 --> 01:18:22,290
Nhưng vào cuối ngày,
không chính xác là tất cả xung quanh chúng ta.

1584
01:18:22,290 --> 01:18:25,240
>> Và điều đó cũng có thể được
đáng sợ như vậy.

1585
01:18:25,240 --> 01:18:28,590
Nó chỉ ra rằng Superman 3
và không gian văn phòng sang một bên, có

1586
01:18:28,590 --> 01:18:31,460
có thể có một số rất thực tế
nhánh trên thế giới

1587
01:18:31,460 --> 01:18:35,290
những thực tế của không chính xác
đại diện của dữ liệu

1588
01:18:35,290 --> 01:18:37,770
mà ngay cả con người chúng ta để
ngày nay không nhất thiết

1589
01:18:37,770 --> 01:18:41,230
hiểu cũng như chúng ta nên,
hoặc nhớ thường xuyên như chúng ta nên.

1590
01:18:41,230 --> 01:18:45,950
Và, quả thật vậy, các clip sau đây là
từ một cái nhìn tại một số thế giới rất thực tế

1591
01:18:45,950 --> 01:18:50,730
chi nhánh của những gì sẽ xảy ra nếu bạn
không đánh giá cao sự thiếu chính xác mà

1592
01:18:50,730 --> 01:18:53,065
có thể xảy ra trong số đại diện.

1593
01:18:53,065 --> 01:18:54,300
>> [XEM LẠI VIDEO]

1594
01:18:54,300 --> 01:18:58,620
>> -Computers, Tất cả chúng tôi đến để chấp nhận
những vấn đề thường bực bội mà

1595
01:18:58,620 --> 01:19:03,310
đi với them-- lỗi, virus,
và phần mềm ổn định,

1596
01:19:03,310 --> 01:19:06,130
cho giá nhỏ để trả tiền
cho sự tiện lợi.

1597
01:19:06,130 --> 01:19:10,800
Nhưng trong công nghệ cao và tốc độ cao
chương trình không gian và quân sự ứng dụng,

1598
01:19:10,800 --> 01:19:15,800
những vấn đề nhỏ nhất có thể
được phóng đại thành thảm họa.

1599
01:19:15,800 --> 01:19:21,900
>> Ngày 04 tháng 6 1996, các nhà khoa học chuẩn bị
để khởi động một người lái Ariane 5 tên lửa.

1600
01:19:21,900 --> 01:19:24,220
Nó được thực hiện khoa học
vệ tinh được thiết kế

1601
01:19:24,220 --> 01:19:27,600
để thiết lập một cách chính xác như thế nào
tương tác từ trường của trái đất

1602
01:19:27,600 --> 01:19:30,410
với gió mặt trời.

1603
01:19:30,410 --> 01:19:33,800
Các tên lửa được xây dựng cho
Cơ quan Vũ trụ châu Âu,

1604
01:19:33,800 --> 01:19:37,370
và dỡ bỏ khỏi cơ sở của nó
trên bờ biển French Guiana.

1605
01:19:37,370 --> 01:19:40,540
>> -Tại Khoảng 37 giây vào
các chuyến bay, họ lần đầu tiên

1606
01:19:40,540 --> 01:19:42,270
nhận thấy một cái gì đó đã đi sai.

1607
01:19:42,270 --> 01:19:45,250
Các vòi phun được xoay trong
một cách mà họ thực sự không nên.

1608
01:19:45,250 --> 01:19:49,580
Khoảng 40 giây vào chuyến bay,
rõ ràng, chiếc xe đã gặp rắc rối.

1609
01:19:49,580 --> 01:19:51,850
>> Và đó là khi họ thực hiện
một quyết định để tiêu diệt nó.

1610
01:19:51,850 --> 01:19:55,780
Các sĩ quan an toàn phạm vi, với
ruột vô cùng, nhấn nút,

1611
01:19:55,780 --> 01:20:01,150
thổi lên các tên lửa, trước khi nó có thể
trở thành một mối nguy hiểm cho sự an toàn công cộng.

1612
01:20:01,150 --> 01:20:04,060
>> -Đây Là trinh nữ
hành trình của tên lửa Ariane 5.

1613
01:20:04,060 --> 01:20:06,960
Và nó bị phá hủy mất
đặt vì một lỗ hổng

1614
01:20:06,960 --> 01:20:08,822
nhúng trong phần mềm của tên lửa.

1615
01:20:08,822 --> 01:20:11,280
-Các Vấn đề trên Ariane là
rằng có một con số

1616
01:20:11,280 --> 01:20:13,600
cần 64 bit để thể hiện.

1617
01:20:13,600 --> 01:20:16,590
Và họ muốn chuyển đổi
nó cho một số 16-bit.

1618
01:20:16,590 --> 01:20:18,610
Họ giả định rằng
số sẽ không bao giờ

1619
01:20:18,610 --> 01:20:23,980
là rất lớn, mà hầu hết những người
chữ số trong một số 64-bit là zero.

1620
01:20:23,980 --> 01:20:25,440
Họ đã sai lầm.

1621
01:20:25,440 --> 01:20:28,060
>> -Các Sự bất lực của một
chương trình phần mềm để chấp nhận

1622
01:20:28,060 --> 01:20:32,510
các loại số được tạo ra bởi
khác là gốc rễ của sự thất bại.

1623
01:20:32,510 --> 01:20:37,350
phát triển phần mềm đã trở thành một
phần rất tốn kém của công nghệ mới.

1624
01:20:37,350 --> 01:20:41,140
Tên lửa Ariane đã rất
thành công, rất nhiều các phần mềm

1625
01:20:41,140 --> 01:20:44,550
tạo ra cho nó cũng là
được sử dụng trong các tên lửa Ariane 5.

1626
01:20:44,550 --> 01:20:50,940
>> -Các Vấn đề cơ bản là các Ariane
5 là nhanh hơn, tăng tốc nhanh hơn.

1627
01:20:50,940 --> 01:20:54,450
Và các phần mềm đã không
chiếm đó.

1628
01:20:54,450 --> 01:20:58,060
>> -Các Phá hủy các tên lửa
là một thảm họa tài chính khổng lồ,

1629
01:20:58,060 --> 01:21:01,790
tất cả do một lỗi phần mềm phút.

1630
01:21:01,790 --> 01:21:04,210
Nhưng đây không phải là lần đầu tiên
Hiện vấn đề chuyển đổi dữ liệu

1631
01:21:04,210 --> 01:21:07,820
đã cản công nghệ tên lửa hiện đại.

1632
01:21:07,820 --> 01:21:11,050
>> -Trong Năm 1991, với sự bắt đầu
Chiến tranh vùng Vịnh đầu tiên,

1633
01:21:11,050 --> 01:21:13,570
Patriot Missile
kinh nghiệm một loại tương tự

1634
01:21:13,570 --> 01:21:15,800
của vấn đề chuyển đổi số.

1635
01:21:15,800 --> 01:21:19,090
Và kết quả là, 28 người,
28 lính Mỹ,

1636
01:21:19,090 --> 01:21:22,080
đã bị giết chết, và về
100 người khác bị thương,

1637
01:21:22,080 --> 01:21:25,780
khi Patriot, mà đã được yêu
để bảo vệ chống lại các tên lửa Scud đến,

1638
01:21:25,780 --> 01:21:28,830
không bắn một tên lửa.

1639
01:21:28,830 --> 01:21:34,670
>> -Khi Iraq xâm chiếm Kuwait, và Mỹ
đưa ra Desert Storm vào đầu năm 1991,

1640
01:21:34,670 --> 01:21:38,780
pin Patriot Missile đã được triển khai
để bảo vệ Saudi Arabia và Israel

1641
01:21:38,780 --> 01:21:42,230
từ các cuộc tấn công tên lửa Scud của Iraq.

1642
01:21:42,230 --> 01:21:46,810
The Patriot là một Mỹ tầm trung
bề mặt để hệ thống không khí, chế tạo

1643
01:21:46,810 --> 01:21:48,770
do công ty Raytheon.

1644
01:21:48,770 --> 01:21:55,340
>> -Các Kích thước của các máy bay đánh chặn Patriot
chính nó là dài khoảng khoảng 20 feet.

1645
01:21:55,340 --> 01:21:58,230
Và nó chỉ nặng khoảng 2.000 bảng Anh.

1646
01:21:58,230 --> 01:22:02,320
Và nó mang một đầu đạn hạt nhân của khoảng,
Tôi nghĩ đó là khoảng 150 pounds.

1647
01:22:02,320 --> 01:22:06,930
Và các đầu đạn hạt nhân chính nó là
một vụ nổ, trong đó

1648
01:22:06,930 --> 01:22:10,330
có mảnh vỡ xung quanh nó.

1649
01:22:10,330 --> 01:22:14,680
Vỏ của đầu đạn là
được thiết kế để hoạt động như đạn chì.

1650
01:22:14,680 --> 01:22:17,110
>> -Các Tên lửa được tiến hành
bốn trên mỗi container,

1651
01:22:17,110 --> 01:22:20,130
và được vận chuyển bằng một trailer bán.

1652
01:22:20,130 --> 01:22:27,930
>> -Các Hệ thống Patriot chống tên lửa
đi lại ít nhất 20 năm nay.

1653
01:22:27,930 --> 01:22:31,420
Nó được thiết kế ban đầu
như một tên lửa phòng không

1654
01:22:31,420 --> 01:22:33,720
để bắn hạ máy bay của đối phương.

1655
01:22:33,720 --> 01:22:37,500
Trong chiến tranh vùng Vịnh đầu tiên,
khi chiến tranh mà đến cùng,

1656
01:22:37,500 --> 01:22:42,745
Quân đội muốn sử dụng nó để
bắn hạ tên lửa Scud, không phải máy bay.

1657
01:22:42,745 --> 01:22:46,620
>> Không quân Iraq đã
không quá nhiều của một vấn đề.

1658
01:22:46,620 --> 01:22:49,670
Nhưng quân đội đã lo lắng về tên lửa Scud.

1659
01:22:49,670 --> 01:22:53,170
Và do đó, họ đã cố gắng để
nâng cấp Patriot.

1660
01:22:53,170 --> 01:22:55,800
>> -Intercepting Một kẻ thù
tên lửa đi du lịch tại mach 5

1661
01:22:55,800 --> 01:22:58,830
sắp được thử thách đủ.

1662
01:22:58,830 --> 01:23:01,490
Nhưng khi Patriot
được đưa vào phục vụ,

1663
01:23:01,490 --> 01:23:05,860
Quân đội đã không nhận thức một
sửa đổi của Iraq đã làm

1664
01:23:05,860 --> 01:23:08,930
tên lửa Scud của họ gần như không thể đánh trúng.

1665
01:23:08,930 --> 01:23:13,740
>> -Điều Gì đã xảy ra là các tên lửa Scud mà
đã đến ở không ổn định.

1666
01:23:13,740 --> 01:23:14,692
Họ bị lắc lư.

1667
01:23:14,692 --> 01:23:17,910
Lý do cho điều này là
người Iraq, để

1668
01:23:17,910 --> 01:23:21,280
để có được 600 km
ra khỏi một cây số 300

1669
01:23:21,280 --> 01:23:24,700
tên lửa tầm xa, mất cân
ra khỏi đầu đạn trước.

1670
01:23:24,700 --> 01:23:26,390
Họ đã làm cho đầu đạn nhẹ hơn.

1671
01:23:26,390 --> 01:23:30,330
>> Vì vậy, bây giờ là Patriot
cố gắng để đi vào các tên lửa Scud.

1672
01:23:30,330 --> 01:23:33,230
Và hầu hết thời gian,
đại đa số thời gian,

1673
01:23:33,230 --> 01:23:35,940
nó sẽ chỉ bay bằng các tên lửa Scud.

1674
01:23:35,940 --> 01:23:40,260
Một khi các nhà khai thác hệ thống Patriot
nhận ra Patriot bỏ mục tiêu của mình,

1675
01:23:40,260 --> 01:23:44,690
chúng phát nổ đầu đạn của Patriot
để tránh thương vong có thể nếu nó

1676
01:23:44,690 --> 01:23:47,570
được phép rơi xuống đất.

1677
01:23:47,570 --> 01:23:51,790
>> -đó Là những gì hầu hết mọi người đã thấy,
những quả cầu lửa lớn trên bầu trời,

1678
01:23:51,790 --> 01:23:57,550
và hiểu nhầm
chặn các đầu đạn tên lửa Scud.

1679
01:23:57,550 --> 01:23:59,630
>> -Although Trong đêm
bầu trời, Patriots xuất hiện

1680
01:23:59,630 --> 01:24:03,370
để được thành công
phá hủy tên lửa Scud, tại Dhahran,

1681
01:24:03,370 --> 01:24:06,360
có thể không có sai lầm
về hiệu quả của nó.

1682
01:24:06,360 --> 01:24:10,970
Có, hệ thống radar của Patriot
bị mất theo dõi của một tên lửa Scud đến,

1683
01:24:10,970 --> 01:24:13,721
và không bao giờ đưa ra do
để một lỗ hổng phần mềm.

1684
01:24:13,721 --> 01:24:17,090

1685
01:24:17,090 --> 01:24:21,940
Đó là những người Israel đầu tiên phát hiện ra
mà còn hệ thống đã được trên,

1686
01:24:21,940 --> 01:24:25,690
càng lớn thì sự chênh lệch thời gian
trở thành, do một đồng hồ nhúng

1687
01:24:25,690 --> 01:24:27,810
trong máy tính của hệ thống.

1688
01:24:27,810 --> 01:24:31,210
>> -Về Hai tuần trước
thảm kịch ở Dhahran,

1689
01:24:31,210 --> 01:24:33,770
Israel báo cáo
Bộ Quốc phòng

1690
01:24:33,770 --> 01:24:35,590
mà hệ thống đã làm mất thời gian.

1691
01:24:35,590 --> 01:24:38,360
Sau khoảng tám giờ hoặc chạy,
họ nhận thấy rằng hệ thống

1692
01:24:38,360 --> 01:24:40,720
đã trở nên đáng chú ý hơn chính xác.

1693
01:24:40,720 --> 01:24:44,900
Bộ Quốc phòng Mỹ đáp trả bằng cách
nói với tất cả các loại pin Patriot

1694
01:24:44,900 --> 01:24:47,950
để không để lại các hệ thống
trong một thời gian dài.

1695
01:24:47,950 --> 01:24:52,160
Họ không bao giờ nói những gì một thời gian dài was--
tám giờ, 10 giờ, 1.000 giờ.

1696
01:24:52,160 --> 01:24:54,360
Không ai biết.

1697
01:24:54,360 --> 01:24:56,380
>> -Các Pin Patriot
đóng quân tại doanh trại

1698
01:24:56,380 --> 01:25:01,350
tại Dhahran và thiếu sót nội bộ của mình
đồng hồ đã hơn 100 giờ

1699
01:25:01,350 --> 01:25:04,670
vào đêm 25 tháng 2.

1700
01:25:04,670 --> 01:25:08,917
>> -Nó Theo dõi thời gian với độ chính xác
khoảng một phần mười của một giây.

1701
01:25:08,917 --> 01:25:11,000
Bây giờ, một phần mười của một giây
là một số thú vị,

1702
01:25:11,000 --> 01:25:14,920
bởi vì nó không thể được thể hiện
trong hệ nhị phân chính xác, mà

1703
01:25:14,920 --> 01:25:19,820
có nghĩa là nó không thể được thể hiện một cách chính xác
trong bất kỳ máy tính kỹ thuật số hiện đại.

1704
01:25:19,820 --> 01:25:21,540
Thật khó để tin.

1705
01:25:21,540 --> 01:25:24,210
>> Nhưng sử dụng như là một ví dụ.

1706
01:25:24,210 --> 01:25:26,540
Hãy lấy số thứ ba.

1707
01:25:26,540 --> 01:25:30,350
Một phần ba không thể được
thể hiện trong thập phân chính xác.

1708
01:25:30,350 --> 01:25:35,080
Một phần ba là 0,333
diễn ra trong vô cực.

1709
01:25:35,080 --> 01:25:39,480
>> Không có cách nào để làm điều đó với
độ chính xác tuyệt đối trong hệ thập phân.

1710
01:25:39,480 --> 01:25:42,560
Đó chính là loại vấn đề
đã xảy ra trong Patriot.

1711
01:25:42,560 --> 01:25:47,100
Các hệ thống này còn chạy,
tệ hơn các lỗi thời gian đã trở thành.

1712
01:25:47,100 --> 01:25:51,890
>> -Sau 100 giờ hoạt động,
lỗi trong thời gian chỉ khoảng một phần ba

1713
01:25:51,890 --> 01:25:53,600
của một giây.

1714
01:25:53,600 --> 01:25:57,210
Nhưng về nhắm mục tiêu một
tên lửa đi du lịch tại mach 5,

1715
01:25:57,210 --> 01:26:01,710
nó dẫn đến một theo dõi
lỗi trên 600 mét.

1716
01:26:01,710 --> 01:26:05,120
Nó sẽ là một lỗi nghiêm trọng
cho những người lính trên những gì

1717
01:26:05,120 --> 01:26:11,940
xảy ra là một vụ phóng tên lửa Scud là
phát hiện bởi các vệ tinh cảnh báo sớm

1718
01:26:11,940 --> 01:26:15,860
và họ biết rằng các tên lửa Scud là
đến trong hướng chung của họ.

1719
01:26:15,860 --> 01:26:18,320
Họ không biết nơi nó sẽ đến.

1720
01:26:18,320 --> 01:26:21,250
>> -Nó Là bây giờ lên đến radar
thành phần của hệ thống Patriot

1721
01:26:21,250 --> 01:26:26,190
bảo vệ Dhahran để xác định vị trí và giữ
theo dõi các tên lửa đối phương đến.

1722
01:26:26,190 --> 01:26:27,609
>> -Các Radar đã rất thông minh.

1723
01:26:27,609 --> 01:26:29,650
Nó thực sự sẽ theo dõi
vị trí của tên lửa Scud,

1724
01:26:29,650 --> 01:26:33,350
và sau đó tiên đoán nó có lẽ
sẽ là lần tiếp theo radar gửi

1725
01:26:33,350 --> 01:26:34,420
một xung ra.

1726
01:26:34,420 --> 01:26:36,110
Đó được gọi là cổng loạt.

1727
01:26:36,110 --> 01:26:40,660
>> -Sau Đó, một khi Patriot
quyết định đủ thời gian có

1728
01:26:40,660 --> 01:26:45,450
thông qua để quay trở lại và kiểm tra tiếp theo
vị trí cho đối tượng phát hiện này,

1729
01:26:45,450 --> 01:26:46,600
nó đi lại.

1730
01:26:46,600 --> 01:26:51,650
Vì vậy, khi nó quay trở lại sai
chỗ, nó sau đó thấy không có đối tượng.

1731
01:26:51,650 --> 01:26:55,160
Và nó quyết định rằng không có
đối tượng, đó là một phát hiện sai,

1732
01:26:55,160 --> 01:26:56,930
và giọt đường đua.

1733
01:26:56,930 --> 01:27:00,030
>> -Các Scud đến biến mất
từ màn hình radar.

1734
01:27:00,030 --> 01:27:03,260
Và giây sau, nó
đâm sầm vào các doanh trại.

1735
01:27:03,260 --> 01:27:09,150
Tên lửa Scud giết chết 28, và là người cuối cùng
một bắn trong Chiến tranh vùng Vịnh đầu tiên.

1736
01:27:09,150 --> 01:27:14,960
>> Buồn thay, phần mềm cập nhật
đến Dhahran ngày hôm sau.

1737
01:27:14,960 --> 01:27:17,930
Các lỗ hổng phần mềm có
được cố định, đóng cửa

1738
01:27:17,930 --> 01:27:22,806
một chương trong khó khăn
lịch sử của tên lửa Patriot.

1739
01:27:22,806 --> 01:27:23,729
>> [XEM LẠI VIDEO]

1740
01:27:23,729 --> 01:27:26,520
DAVID J. Malan: Vì vậy, đây là tất cả để
nói rằng những vấn đề về tràn

1741
01:27:26,520 --> 01:27:28,860
và không chính xác là quá thực tế.

1742
01:27:28,860 --> 01:27:29,920
Vì vậy, làm thế nào chúng ta có được ở đây?

1743
01:27:29,920 --> 01:27:31,895
Chúng tôi bắt đầu với chỉ nói về printf.

1744
01:27:31,895 --> 01:27:34,270
Một lần nữa, chức năng này
in cái gì đó ra màn hình,

1745
01:27:34,270 --> 01:27:36,450
và chúng tôi giới thiệu sau đó
một vài chức năng khác

1746
01:27:36,450 --> 01:27:37,945
từ cái gọi là thư viện CS50 của.

1747
01:27:37,945 --> 01:27:39,910
Và chúng tôi sẽ tiếp tục
thấy những đúng thời hạn.

1748
01:27:39,910 --> 01:27:43,760
Và chúng ta, đặc biệt, sử dụng get chuỗi,
và nhận được int, và bây giờ cũng được thả nổi,

1749
01:27:43,760 --> 01:27:47,410
nhưng những người khác vẫn còn chúng tôi sẽ gặp phải
và sử dụng chính mình trước khi dài.

1750
01:27:47,410 --> 01:27:50,220
>> Nhưng thỉnh thoảng, có
chúng tôi đã nhìn thấy một nhu cầu

1751
01:27:50,220 --> 01:27:53,520
để lưu trữ những gì các chức năng tay trở lại?

1752
01:27:53,520 --> 01:27:55,920
Họ tay chúng ta trở lại một chuỗi,
hoặc một int, hoặc một phao.

1753
01:27:55,920 --> 01:27:59,070
Và đôi khi chúng ta cần phải đặt mà
string, int, float hoặc một nơi nào đó.

1754
01:27:59,070 --> 01:28:03,100
>> Và để lưu trữ những điều đó, nhớ lại chỉ
như trong Scratch, chúng tôi có các biến.

1755
01:28:03,100 --> 01:28:06,260
Nhưng không giống như trong Scratch,
trong C, chúng tôi có các loại thực tế

1756
01:28:06,260 --> 01:28:08,530
dữ liệu variables--
loại, hơn generally--

1757
01:28:08,530 --> 01:28:11,640
trong số đó, một chuỗi, một int, một
nổi, và những người khác vẫn còn.

1758
01:28:11,640 --> 01:28:15,321
>> Và như vậy khi chúng ta khai báo biến trong C,
chúng tôi sẽ phải khai báo kiểu dữ liệu của chúng tôi.

1759
01:28:15,321 --> 01:28:17,820
Đây không phải là một cái gì đó chúng tôi sẽ
phải làm sau đó trong học kỳ

1760
01:28:17,820 --> 01:28:19,810
khi chúng ta chuyển đổi sang ngôn ngữ khác.

1761
01:28:19,810 --> 01:28:22,610
Nhưng hiện nay, chúng ta cần
để một tiên trước,

1762
01:28:22,610 --> 01:28:27,370
giải thích cho các máy tính loại
biến chúng ta muốn nó cho chúng ta.

1763
01:28:27,370 --> 01:28:30,290
>> Bây giờ, trong khi đó, để in
những loại định dạng dữ liệu,

1764
01:28:30,290 --> 01:28:32,570
chúng ta phải nói printf những gì mong đợi.

1765
01:28:32,570 --> 01:28:35,450
Và chúng ta đã thấy phần trăm s cho các chuỗi,
và phần trăm tôi cho các số nguyên,

1766
01:28:35,450 --> 01:28:36,790
và một vài người khác đã.

1767
01:28:36,790 --> 01:28:40,237
Và những người chỉ đơn giản là yêu cầu
cho các bài thuyết trình trực quan

1768
01:28:40,237 --> 01:28:41,070
thông tin đó.

1769
01:28:41,070 --> 01:28:45,080
>> Và mỗi người trong những thực sự có thể được
parametrized hoặc tinh chỉnh một cách nào đó,

1770
01:28:45,080 --> 01:28:48,370
nếu bạn muốn tiếp tục kiểm soát
loại đầu ra mà bạn nhận được.

1771
01:28:48,370 --> 01:28:52,604
Và, trên thực tế, nó chỉ ra rằng không chỉ
là có dấu chéo ngược n cho một dòng mới.

1772
01:28:52,604 --> 01:28:55,520
Có cái gì khác được gọi là dấu chéo ngược
r cho một trở về vận chuyển, mà

1773
01:28:55,520 --> 01:28:57,360
là hơn giống như một
máy đánh chữ trường học cũ,

1774
01:28:57,360 --> 01:29:00,690
và cũng có Windows được sử dụng trong nhiều năm.

1775
01:29:00,690 --> 01:29:02,690
>> Có t dấu chéo ngược cho các tab.

1776
01:29:02,690 --> 01:29:06,170
Hóa ra, nếu bạn muốn
báo giá gấp đôi bên trong một chuỗi,

1777
01:29:06,170 --> 01:29:08,000
nhớ lại rằng chúng ta đã sử dụng
giá gấp đôi gấp đôi

1778
01:29:08,000 --> 01:29:10,900
quote ở bên trái và bên phải
kết thúc của chuỗi của chúng tôi cho đến nay.

1779
01:29:10,900 --> 01:29:12,420
Điều đó dường như để gây nhầm lẫn thứ.

1780
01:29:12,420 --> 01:29:15,503
>> Nếu bạn muốn đặt một đôi báo ở
giữa một string-- và, thực sự,

1781
01:29:15,503 --> 01:29:16,670
nó là khó hiểu để xem.

1782
01:29:16,670 --> 01:29:20,120
Và như vậy bạn có để thoát khỏi, vì vậy để
nói chuyện, một báo giá gấp đôi với một cái gì đó

1783
01:29:20,120 --> 01:29:21,860
như, theo nghĩa đen, dấu chéo ngược nháy kép.

1784
01:29:21,860 --> 01:29:23,230
Và có một số khác vẫn còn.

1785
01:29:23,230 --> 01:29:27,540
Và chúng ta sẽ thấy nhiều hơn những
trong thực tế sử dụng trước khi dài.

1786
01:29:27,540 --> 01:29:30,930
>> Vì vậy, bây giờ chúng ta chuyển từ
dữ liệu, và đại diện,

1787
01:29:30,930 --> 01:29:33,820
và toán tử số học, tất cả
trong đó đã cho chúng tôi một số tòa nhà

1788
01:29:33,820 --> 01:29:35,070
khối nào đó để chơi.

1789
01:29:35,070 --> 01:29:37,481
Nhưng bây giờ chúng ta hãy thực sự cung cấp
chúng tôi phần còn lại của từ vựng

1790
01:29:37,481 --> 01:29:39,230
rằng chúng tôi đã có
Hồi tuần trước, Scratch

1791
01:29:39,230 --> 01:29:42,350
bằng cách lấy một cái nhìn tại một số khác
cấu trúc trong C-- không phải tất cả trong số họ.

1792
01:29:42,350 --> 01:29:44,680
Nhưng những ý tưởng chúng tôi
về để xem thực sự chỉ

1793
01:29:44,680 --> 01:29:48,610
để nhấn mạnh bản dịch từ
một ngôn ngữ, Scratch, khác, C.

1794
01:29:48,610 --> 01:29:51,470
>> Và theo thời gian, chúng ta sẽ nhận
nhiều công cụ cho bộ công cụ của chúng tôi,

1795
01:29:51,470 --> 01:29:52,820
có thể nói, cú pháp.

1796
01:29:52,820 --> 01:29:57,190
Và, thực sự, bạn sẽ thấy rằng những ý tưởng
bây giờ là khá quen thuộc với tuần trước.

1797
01:29:57,190 --> 01:29:58,200
Vì vậy, hãy làm điều này.

1798
01:29:58,200 --> 01:30:01,870
>> Hãy đi trước và whip lên một chương trình
mà thực sự sử dụng một số biểu thức,

1799
01:30:01,870 --> 01:30:03,720
một biểu thức Boolean.

1800
01:30:03,720 --> 01:30:05,810
Hãy để tôi đi trước đây
và tạo ra một tập tin mới.

1801
01:30:05,810 --> 01:30:09,090
Tôi sẽ gọi condition.c này.

1802
01:30:09,090 --> 01:30:12,350
>> Hãy để tôi đi trước và
bao gồm các thư viện CS50.

1803
01:30:12,350 --> 01:30:15,640
Và hãy để tôi đi trước và bao gồm
chuẩn IO.h cho các chức năng của chúng tôi,

1804
01:30:15,640 --> 01:30:17,690
và printf, và tương ứng hơn.

1805
01:30:17,690 --> 01:30:21,900
Hãy để tôi cung cấp cho bản thân mình mà soạn sẵn của
void main int, mà chúng tôi sẽ giải thích

1806
01:30:21,900 --> 01:30:23,360
trở lại trong tương lai.

1807
01:30:23,360 --> 01:30:26,820
>> Bây giờ hãy để tôi đi trước và cho
bản thân mình một int qua get int.

1808
01:30:26,820 --> 01:30:28,970
Sau đó, hãy để tôi đi trước và làm điều này.

1809
01:30:28,970 --> 01:30:33,150
Tôi muốn nói rằng nếu tôi là less-- hãy
phân biệt giữa tích cực, tiêu cực,

1810
01:30:33,150 --> 01:30:34,260
hoặc không có giá trị.

1811
01:30:34,260 --> 01:30:39,630
>> Vì vậy, nếu tôi là ít hơn không, cho tôi
chỉ có chương trình này chỉ đơn giản là nói,

1812
01:30:39,630 --> 01:30:45,370
tiêu cực, dấu chéo ngược n, khác
nếu tôi là lớn hơn không.

1813
01:30:45,370 --> 01:30:50,030
Bây giờ tôi, tất nhiên, sẽ nói
printf tích cực, dấu chéo ngược n.

1814
01:30:50,030 --> 01:30:53,690
Và sau đó khác if-- tôi có thể làm điều này.

1815
01:30:53,690 --> 01:30:56,410
>> Tôi có thể làm gì nếu tôi bằng 0.

1816
01:30:56,410 --> 01:30:58,840
Nhưng tôi muốn được làm tại
ít nhất một sai lầm rồi.

1817
01:30:58,840 --> 01:31:02,480
Nhớ lại rằng dấu bằng là
không bình đẳng, như con người chúng ta biết điều đó.

1818
01:31:02,480 --> 01:31:04,010
>> Nhưng đó là toán tử gán.

1819
01:31:04,010 --> 01:31:08,640
Và chúng tôi không muốn để mất 0 trên
phải và đặt nó trong i bên trái.

1820
01:31:08,640 --> 01:31:14,810
Vì vậy, để tránh sự nhầm lẫn này, hoặc
có lẽ sử dụng sai dấu bằng,

1821
01:31:14,810 --> 01:31:17,740
con người quyết định một số năm trước
rằng trong nhiều ngôn ngữ lập trình

1822
01:31:17,740 --> 01:31:21,000
khi bạn muốn kiểm tra cho sự bình đẳng
giữa bên trái và bên phải,

1823
01:31:21,000 --> 01:31:22,635
bạn thực sự sử dụng bằng bình đẳng.

1824
01:31:22,635 --> 01:31:24,010
Vì vậy, bạn nhấn dấu bằng hai lần.

1825
01:31:24,010 --> 01:31:28,600
Khi bạn muốn gán từ đúng
sang trái, bạn sử dụng một dấu bằng.

1826
01:31:28,600 --> 01:31:32,360
Vì vậy, chúng ta có thể làm điều này-- khác
nếu tôi bằng bằng không.

1827
01:31:32,360 --> 01:31:34,710
>> sau đó tôi có thể đi và
mở dấu ngoặc nhọn của tôi,

1828
01:31:34,710 --> 01:31:39,087
và nói, printf 0, dấu chéo ngược n, thực hiện.

1829
01:31:39,087 --> 01:31:41,170
Nhưng hãy nhớ làm thế nào những
ngã ba đường có thể làm việc.

1830
01:31:41,170 --> 01:31:42,836
Và, thực sự, chỉ cần nghĩ về logic.

1831
01:31:42,836 --> 01:31:44,510
tôi là một con số.

1832
01:31:44,510 --> 01:31:46,320
Đây là một số nguyên, cụ thể.

1833
01:31:46,320 --> 01:31:51,600
Và điều đó có nghĩa là nó sẽ được ít
hơn 0, hoặc lớn hơn 0, hoặc 0.

1834
01:31:51,600 --> 01:31:54,600
Vì vậy, có loại này
ngụ ý trường hợp mặc định.

1835
01:31:54,600 --> 01:31:57,920
>> Và như vậy chúng ta có thể, chỉ cần thích
Scratch, bỏ qua những khác nếu,

1836
01:31:57,920 --> 01:31:58,747
và chỉ cần nói gì khác.

1837
01:31:58,747 --> 01:32:00,830
Logic, nếu bạn
lập trình viên biết chỉ có

1838
01:32:00,830 --> 01:32:04,635
ba xô vào đó một
Kịch bản có thể fall-- đầu tiên,

1839
01:32:04,635 --> 01:32:06,510
thứ hai, hoặc thứ ba
trong này case-- không

1840
01:32:06,510 --> 01:32:10,100
bận tâm thêm độ chính xác thêm
và logic thêm ở đó.

1841
01:32:10,100 --> 01:32:12,690
Chỉ cần đi trước với
trường hợp mặc định đây của người khác.

1842
01:32:12,690 --> 01:32:14,950
>> Bây giờ, chúng ta hãy đi trước
sau khi tiết kiệm này, chắc

1843
01:32:14,950 --> 01:32:18,760
điều kiện chấm giảm conditions--
không phải là một giao diện người dùng rất lớn,

1844
01:32:18,760 --> 01:32:21,914
vì tôi không khiến
người sử dụng, như tôi đã đề cập trước đó.

1845
01:32:21,914 --> 01:32:22,580
Nhưng đó là tốt.

1846
01:32:22,580 --> 01:32:23,454
Chúng tôi sẽ giữ nó đơn giản.

1847
01:32:23,454 --> 01:32:24,890
Hãy thử số 42.

1848
01:32:24,890 --> 01:32:26,240
Và đó là tích cực.

1849
01:32:26,240 --> 01:32:29,120
Hãy thử các số
âm 42, tiêu cực.

1850
01:32:29,120 --> 01:32:31,244
>> Hãy thử các giá trị 0.

1851
01:32:31,244 --> 01:32:32,160
Và, quả thật vậy, nó hoạt động.

1852
01:32:32,160 --> 01:32:36,900
Bây giờ, bạn sẽ thấy có vấn đề trước
dài, thử nghiệm thứ ba lần,

1853
01:32:36,900 --> 01:32:37,980
có lẽ chưa đủ.

1854
01:32:37,980 --> 01:32:40,438
Bạn có thể muốn kiểm tra một số
số lớn hơn, một số nhỏ hơn

1855
01:32:40,438 --> 01:32:43,520
số, một số trường hợp góc, như
chúng tôi sẽ đến để mô tả chúng.

1856
01:32:43,520 --> 01:32:45,500
>> Nhưng hiện nay, đây là một
chương trình khá đơn giản.

1857
01:32:45,500 --> 01:32:48,160
Và tôi khá chắc chắn, một cách logic,
số đó rơi vào ba trường hợp.

1858
01:32:48,160 --> 01:32:52,360
Và, thực sự, mặc dù chúng ta chỉ
tập trung vào các nhược điểm tiềm năng

1859
01:32:52,360 --> 01:32:56,480
không chính xác tương và tràn, trong
thực tế mà nhiều vấn đề CS50 của,

1860
01:32:56,480 --> 01:32:59,000
chúng ta sẽ không phải lo lắng
về, tất cả các thời gian,

1861
01:32:59,000 --> 01:33:02,050
những vấn đề về tràn và
không chính xác, bởi vì, trên thực tế, trong C,

1862
01:33:02,050 --> 01:33:04,889
nó thực sự không phải tất cả mà
dễ dàng để tránh những điều đó.

1863
01:33:04,889 --> 01:33:07,180
Nếu bạn muốn đếm lên
lớn hơn, và lớn hơn, và lớn hơn,

1864
01:33:07,180 --> 01:33:10,510
Hóa ra có các kỹ thuật bạn
có thể sử dụng, thường liên quan đến những thứ được gọi là

1865
01:33:10,510 --> 01:33:14,240
thư viện, các bộ sưu tập của mã, mà
người khác đã viết rằng bạn có thể sử dụng,

1866
01:33:14,240 --> 01:33:16,910
và các ngôn ngữ khác như
Java và những người khác, thực sự

1867
01:33:16,910 --> 01:33:18,800
làm cho nó dễ dàng hơn nhiều
để đếm thậm chí cao hơn.

1868
01:33:18,800 --> 01:33:22,810
Vì vậy, nó thực sự là một số trong những mối nguy hiểm
một chức năng của ngôn ngữ mà bạn sử dụng.

1869
01:33:22,810 --> 01:33:25,710
Và trong những tuần tới, chúng tôi sẽ
xem làm thế nào nguy hiểm thực sự C

1870
01:33:25,710 --> 01:33:27,950
có thể được nếu bạn không sử dụng nó đúng cách.

1871
01:33:27,950 --> 01:33:30,610
Nhưng từ đó, và với
Python, và JavaScript, sẽ

1872
01:33:30,610 --> 01:33:35,620
chúng tôi lớp trên một số biện pháp bảo vệ bổ sung,
và chạy ít những rủi ro.

1873
01:33:35,620 --> 01:33:38,820
>> Vì vậy, chúng ta hãy làm nhiều hơn một chút
Logic thú vị trong chương trình của chúng tôi.

1874
01:33:38,820 --> 01:33:42,110
Vì vậy, hãy để tôi đi trước và tạo
một chương trình gọi là logic

1875
01:33:42,110 --> 01:33:46,804
chỉ để tôi có thể chơi với một số
logic thực tế, logical.c.

1876
01:33:46,804 --> 01:33:49,870
Tôi sẽ chỉ cần sao chép và dán một số
mã từ trước đó vì vậy tôi có được trở lại

1877
01:33:49,870 --> 01:33:52,950
đến thời điểm khởi đầu tốt đẹp này.

1878
01:33:52,950 --> 01:33:56,980
>> Hãy cho tôi thời gian này làm C. char tôi
sẽ cung cấp cho nó một cái tên của C

1879
01:33:56,980 --> 01:34:01,510
chỉ vì nó là thông thường,
có một kí tự từ người dùng.

1880
01:34:01,510 --> 01:34:03,730
Và chúng ta hãy giả vờ như
Tôi đang thực hiện một phần

1881
01:34:03,730 --> 01:34:07,130
với chương trình Rm, remove
chương trình trước đó nhắc nhở người sử dụng

1882
01:34:07,130 --> 01:34:08,400
để loại bỏ một tập tin.

1883
01:34:08,400 --> 01:34:09,750
Làm thế nào chúng ta có thể làm được điều này?

1884
01:34:09,750 --> 01:34:14,090
>> Tôi muốn nói, nếu C bằng
bằng, quote unquote,

1885
01:34:14,090 --> 01:34:19,304
y, sau đó tôi sẽ giả định
mà người dùng đã chọn yes.

1886
01:34:19,304 --> 01:34:20,470
Tôi chỉ cần đi để in có.

1887
01:34:20,470 --> 01:34:22,440
Nếu nó đã thực sự viết
các chương trình gỡ bỏ,

1888
01:34:22,440 --> 01:34:24,420
chúng ta có thể loại bỏ các tập tin
với nhiều dòng mã.

1889
01:34:24,420 --> 01:34:25,461
Nhưng chúng tôi sẽ giữ nó đơn giản.

1890
01:34:25,461 --> 01:34:28,950

1891
01:34:28,950 --> 01:34:34,250
>> Else if c bằng bằng n--
và bây giờ đây, tôi sẽ nói,

1892
01:34:34,250 --> 01:34:35,980
người sử dụng phải có nghĩa là không có.

1893
01:34:35,980 --> 01:34:37,360
Và sau đó nữa, bạn biết những gì?

1894
01:34:37,360 --> 01:34:39,200
Tôi không biết những gì khác
người dùng sẽ gõ.

1895
01:34:39,200 --> 01:34:41,533
Vì vậy, tôi chỉ muốn nói rằng
đó là một lỗi, bất cứ điều gì

1896
01:34:41,533 --> 01:34:43,070
anh hay cô thực sự gõ.

1897
01:34:43,070 --> 01:34:44,180
>> Vì vậy, những gì đang xảy ra ở đây?

1898
01:34:44,180 --> 01:34:47,530
Có một sự khác biệt cơ bản
so với những gì tôi đã làm trong quá khứ.

1899
01:34:47,530 --> 01:34:52,300
dấu ngoặc kép, dấu ngoặc kép, gấp đôi
dấu ngoặc kép, và, nhưng, dấu ngoặc đơn,

1900
01:34:52,300 --> 01:34:53,170
dấu nháy đơn.

1901
01:34:53,170 --> 01:34:55,860
Hóa ra trong C, mà khi
bạn muốn viết một chuỗi,

1902
01:34:55,860 --> 01:34:59,680
bạn sử dụng dấu ngoặc kép, giống như chúng ta đã
được sử dụng tất cả thời gian này với printf.

1903
01:34:59,680 --> 01:35:05,030
>> Nhưng nếu bạn muốn để đối phó với chỉ một
nhân vật duy nhất, một cái gọi là char,

1904
01:35:05,030 --> 01:35:06,780
sau đó bạn thực sự sử dụng dấu nháy đơn.

1905
01:35:06,780 --> 01:35:08,450
Những người bạn của những người đã được lập trình
trước khi, bạn có thể không có

1906
01:35:08,450 --> 01:35:10,850
phải lo lắng về điều này
sự phân biệt trong ngôn ngữ nhất định.

1907
01:35:10,850 --> 01:35:12,450
Trong C, nó không thành vấn đề.

1908
01:35:12,450 --> 01:35:15,560
Và như vậy khi tôi nhận được một char và tôi muốn
để so sánh char sử dụng bằng

1909
01:35:15,560 --> 01:35:21,350
tương đương với một số lá thư như y hoặc n, tôi làm,
thực sự, cần phải có các dấu nháy đơn.

1910
01:35:21,350 --> 01:35:22,770
>> Bây giờ, chúng ta hãy đi trước và làm điều này.

1911
01:35:22,770 --> 01:35:29,180
Hãy đi trước và làm làm
dot logic cắt giảm hợp lý.

1912
01:35:29,180 --> 01:35:30,305
Và bây giờ tôi đang bị nhắc nhở.

1913
01:35:30,305 --> 01:35:33,638
Vì vậy, có lẽ, một kinh nghiệm người dùng tốt hơn
thực sự sẽ cho tôi biết phải làm gì đây.

1914
01:35:33,638 --> 01:35:36,030
Nhưng tôi sẽ chỉ mù quáng
nói y cho có, OK, tốt đẹp.

1915
01:35:36,030 --> 01:35:38,780
>> Hãy chạy lại, n không có, tốt đẹp.

1916
01:35:38,780 --> 01:35:42,610
Giả sử như một số người tôi biết,
mũ của tôi khóa quan trọng là tất cả các quá thường xuyên.

1917
01:35:42,610 --> 01:35:46,740
Vì vậy, tôi làm vốn Y, nhập, lỗi.

1918
01:35:46,740 --> 01:35:49,130
OK, nó không chính xác những gì tôi đang mong đợi.

1919
01:35:49,130 --> 01:35:51,170
Thật vậy, máy tính
đang làm nghĩa gì

1920
01:35:51,170 --> 01:35:54,794
Tôi nói với nó để do-- kiểm tra
chữ thường và chữ thường y n.

1921
01:35:54,794 --> 01:35:56,960
Điều này không cảm thấy như tốt
kinh nghiệm người dùng, mặc dù.

1922
01:35:56,960 --> 01:36:02,010
Hãy để tôi yêu cầu và chấp nhận
cả hai trường hợp thấp hơn hoặc trường hợp trên.

1923
01:36:02,010 --> 01:36:05,090
Vì vậy, nó quay ra, bạn có thể muốn
để nói một cái gì đó giống như trong Scratch,

1924
01:36:05,090 --> 01:36:11,150
như nghĩa đen hoặc C bằng
bằng vốn đơn y được trích dẫn.

1925
01:36:11,150 --> 01:36:14,400
Hóa ra, C không có
từ khóa đen này hay.

1926
01:36:14,400 --> 01:36:15,880
>> Nhưng nó có hai thanh dọc.

1927
01:36:15,880 --> 01:36:18,463
Bạn phải giữ phím Shift thường,
nếu bạn đang sử dụng một bàn phím Mỹ,

1928
01:36:18,463 --> 01:36:21,910
và nhấn thanh dọc
phím trên chìa khóa của bạn trở lại.

1929
01:36:21,910 --> 01:36:25,410
Nhưng thanh dọc này
thanh dọc là hay.

1930
01:36:25,410 --> 01:36:29,220
>> Nếu, ngược lại, chúng tôi muốn
để nói, và cũng như trong Scratch,

1931
01:36:29,220 --> 01:36:31,180
chúng ta có thể làm dấu và dấu &.

1932
01:36:31,180 --> 01:36:34,330
Điều đó làm cho không có ý nghĩa logic ở đây,
vì một con người có thể không có thể

1933
01:36:34,330 --> 01:36:40,110
đã gõ cả y và chữ thường y
và vốn Y như cùng một ký tự.

1934
01:36:40,110 --> 01:36:42,470
Vì vậy, hoặc là những gì chúng tôi có ý định ở đây.

1935
01:36:42,470 --> 01:36:49,280
>> Vì vậy, nếu tôi làm điều này ở cả hai nơi, hoặc c
bằng bằng với vốn tồn tại, bây giờ chạy lại,

1936
01:36:49,280 --> 01:36:52,390
làm cho hợp lý, chạy lại hợp lý.

1937
01:36:52,390 --> 01:36:54,200
Bây giờ, tôi có thể gõ y.

1938
01:36:54,200 --> 01:36:56,920
Và tôi có thể làm điều đó một lần nữa với
vốn Y, hoặc N. vốn

1939
01:36:56,920 --> 01:36:59,630
Và tôi có thể thêm vào thêm
Các kết hợp.

1940
01:36:59,630 --> 01:37:01,810
>> Vì vậy, đây là một hợp lý
chương trình trong chừng mực như bây giờ

1941
01:37:01,810 --> 01:37:04,940
Tôi đang kiểm tra một cách hợp lý cho
giá trị này hay giá trị này.

1942
01:37:04,940 --> 01:37:09,420
Và tôi không phải, nhất thiết,
đi lên với hơn hai IFS hoặc khác IFS.

1943
01:37:09,420 --> 01:37:12,960
Tôi thực sự có thể kết hợp một số các
lý liên quan với nhau theo cách này.

1944
01:37:12,960 --> 01:37:14,950
Vì vậy, đây sẽ là tốt hơn
thiết kế đơn giản hơn

1945
01:37:14,950 --> 01:37:20,490
nói, nếu C bằng thấp hơn trường hợp y,
in có, khác nếu c bằng vốn Y,

1946
01:37:20,490 --> 01:37:23,074
in có, khác nếu c bằng
lower-- nói cách khác,

1947
01:37:23,074 --> 01:37:24,990
bạn không cần phải có
hơn và nhiều chi nhánh.

1948
01:37:24,990 --> 01:37:31,840
Bạn có thể kết hợp một số lượng tương đương
chi nhánh một cách hợp lý, như trong cách này.

1949
01:37:31,840 --> 01:37:37,150
>> Vì vậy, chúng ta hãy nhìn vào chỉ một
thành phần cuối cùng, một cấu trúc cuối cùng,

1950
01:37:37,150 --> 01:37:37,847
C cho phép.

1951
01:37:37,847 --> 01:37:39,930
Và chúng tôi sẽ quay trở lại trong
tương lai cho những người khác vẫn còn.

1952
01:37:39,930 --> 01:37:44,400
Và sau đó chúng tôi sẽ kết luận bằng cách nhìn
tại không đúng đắn của code--

1953
01:37:44,400 --> 01:37:49,070
nhận được mã để work-- nhưng thiết kế
mã, và trồng những hạt giống đầu vào.

1954
01:37:49,070 --> 01:37:54,337
>> Vì vậy, hãy để tôi đi trước và
mở một tập tin mới ở đây.

1955
01:37:54,337 --> 01:37:54,920
Bạn biết những gì?

1956
01:37:54,920 --> 01:37:57,450
Tôi sẽ tái thực hiện
mà cùng một chương trình,

1957
01:37:57,450 --> 01:37:58,940
nhưng sử dụng một cấu trúc khác nhau.

1958
01:37:58,940 --> 01:38:03,110
>> Vì vậy, hãy để tôi nhanh chóng cung cấp cho bản thân mình
truy cập để bao gồm CS50.h

1959
01:38:03,110 --> 01:38:07,150
cho thư viện CS50,
chuẩn Io.h cho printf.

1960
01:38:07,150 --> 01:38:09,510
Hãy cho tôi void main int của tôi.

1961
01:38:09,510 --> 01:38:12,310
Và sau đó ở đây, chúng ta hãy
tôi đi trước và làm điều này.

1962
01:38:12,310 --> 01:38:15,010
>> Char c được lấy char, giống như trước đây.

1963
01:38:15,010 --> 01:38:19,770
Và tôi sẽ sử dụng một cấu trúc mới
now-- chuyển, về những gì nhân vật?

1964
01:38:19,770 --> 01:38:22,820
Vì vậy, chuyển đổi là loại giống như
chuyển một chuyến tàu đường ray.

1965
01:38:22,820 --> 01:38:25,070
Hoặc, thực sự, nó là loại
một nếu người nào khác, nếu người nào khác nếu,

1966
01:38:25,070 --> 01:38:26,980
nhưng viết hơi khác nhau.

1967
01:38:26,980 --> 01:38:28,490
>> Một chuyển đổi trông như thế này.

1968
01:38:28,490 --> 01:38:32,060
Bạn có chuyển đổi, và sau đó những gì
nhân vật hoặc số bạn muốn để xem xét,

1969
01:38:32,060 --> 01:38:35,000
sau đó một số dấu ngoặc nhọn giống như trong
Scratch, chỉ nói làm công cụ này.

1970
01:38:35,000 --> 01:38:36,480
Và sau đó bạn có trường hợp khác nhau.

1971
01:38:36,480 --> 01:38:37,830
>> Bạn không sử dụng if và else.

1972
01:38:37,830 --> 01:38:40,050
Bạn có nghĩa là sử dụng các trường hợp từ.

1973
01:38:40,050 --> 01:38:41,790
Và bạn sẽ nói điều gì đó như thế này.

1974
01:38:41,790 --> 01:38:46,820
>> Vì vậy, trong trường hợp của một chữ thường y,
hoặc trong trường hợp của một Y vốn,

1975
01:38:46,820 --> 01:38:50,350
đi trước và in ra có.

1976
01:38:50,350 --> 01:38:52,020
Và sau đó thoát ra của switch.

1977
01:38:52,020 --> 01:38:52,580
Đó là nó.

1978
01:38:52,580 --> 01:38:53,880
Đã được thực hiện.

1979
01:38:53,880 --> 01:39:00,270
>> Else if, có thể nói,
trường hợp n thấp hơn, hoặc vốn N,

1980
01:39:00,270 --> 01:39:05,560
sau đó đi trước và in
ra không, và sau đó phá vỡ.

1981
01:39:05,560 --> 01:39:11,022
Else-- và của loại này là
trường hợp mặc định indeed-- printf error--

1982
01:39:11,022 --> 01:39:13,980
và chỉ cho các biện pháp tốt, mặc dù
logic nghỉ này là không cần thiết

1983
01:39:13,980 --> 01:39:15,896
bởi vì chúng tôi đang ở cuối
của switch anyway,

1984
01:39:15,896 --> 01:39:17,520
Tôi bây giờ phá vỡ ra của switch.

1985
01:39:17,520 --> 01:39:19,280
Vì vậy, điều này có vẻ hơi khác một chút.

1986
01:39:19,280 --> 01:39:21,272
>> Nhưng, một cách logic, đó là
thực sự tương đương.

1987
01:39:21,272 --> 01:39:22,980
Và tại sao bạn sẽ sử dụng
một trong khác?

1988
01:39:22,980 --> 01:39:26,220
Đôi khi, chỉ là sở thích cá nhân,
đôi khi các thẩm mỹ,

1989
01:39:26,220 --> 01:39:28,420
nếu tôi liếc nhìn này
bây giờ, có điều gì đó

1990
01:39:28,420 --> 01:39:30,510
để nói cho các
khả năng đọc của mã này.

1991
01:39:30,510 --> 01:39:33,690
Tôi có nghĩa là, không bao giờ tâm trí thực tế này
đang mới đối với nhiều người trong chúng ta trong phòng.

1992
01:39:33,690 --> 01:39:36,515
>> Nhưng nó chỉ là loại khá.

1993
01:39:36,515 --> 01:39:40,760
Bạn thấy chữ thường y, vốn Y,
n chữ thường, vốn tồn tại mặc định,

1994
01:39:40,760 --> 01:39:43,150
nó chỉ là loại nhảy
ra ở bạn một cách

1995
01:39:43,150 --> 01:39:45,200
rằng, tranh cãi, có lẽ
ví dụ trước

1996
01:39:45,200 --> 01:39:48,780
với IFS, và những cột thẳng đứng,
và IFS khác, có thể không có.

1997
01:39:48,780 --> 01:39:54,600
Vì vậy, đây thực sự là một vấn đề của cá nhân
lựa chọn, thực sự, hoặc có thể đọc,

1998
01:39:54,600 --> 01:39:55,360
của mã.

1999
01:39:55,360 --> 01:40:01,230
>> Nhưng về mặt chức năng, cho tôi
đi trước và thực hiện một chuyển đổi, dấu chấm dấu gạch chéo

2000
01:40:01,230 --> 01:40:08,830
chuyển đổi, và bây giờ gõ y chữ thường,
vốn Y, chữ thường n, vốn tồn tại,

2001
01:40:08,830 --> 01:40:12,250
David, thử lại vì đó là
không phải là một nhân vật duy nhất.

2002
01:40:12,250 --> 01:40:15,050
Hãy làm x, lỗi, như mong đợi.

2003
01:40:15,050 --> 01:40:18,640
Và, logically-- và điều này là một cái gì đó
Tôi sẽ khuyến khích trong general-- thậm chí

2004
01:40:18,640 --> 01:40:20,790
mặc dù chúng tôi chỉ trầy xước
bề mặt của một số các tính năng này.

2005
01:40:20,790 --> 01:40:23,560
>> Và nó có thể không được rõ ràng khi bạn
mình ngồi vào bàn phím,

2006
01:40:23,560 --> 01:40:24,370
Cái này hoạt động ra sao?

2007
01:40:24,370 --> 01:40:25,240
điều này sẽ làm gì?

2008
01:40:25,240 --> 01:40:28,630
Điều đẹp về việc có
một máy tính xách tay, hoặc để bàn, truy cập

2009
01:40:28,630 --> 01:40:32,290
với một máy tính với một trình biên dịch,
và với một trình soạn thảo mã như thế này,

2010
01:40:32,290 --> 01:40:35,990
là bạn có thể hầu như luôn luôn trả lời những
câu hỏi cho chính mình chỉ bằng cách cố gắng.

2011
01:40:35,990 --> 01:40:39,570
>> Ví dụ, nếu tu từ
câu hỏi ở tay là,

2012
01:40:39,570 --> 01:40:42,540
những gì sẽ xảy ra nếu bạn quên
báo cáo nghỉ của bạn?

2013
01:40:42,540 --> 01:40:44,400
Mà thực sự là một
rất phổ biến là điều phải làm,

2014
01:40:44,400 --> 01:40:46,540
bởi vì nó không giống
như bạn thực sự cần chúng.

2015
01:40:46,540 --> 01:40:49,790
Họ không thực sự hoàn thành của bạn
nghĩ như một ngoặc đơn hoặc một xoăn

2016
01:40:49,790 --> 01:40:50,714
cú đúp không.

2017
01:40:50,714 --> 01:40:52,630
Hãy đi trước và
biên dịch lại mã và xem.

2018
01:40:52,630 --> 01:40:56,690
Vì vậy, thực hiện chuyển đổi, chuyển đổi chấm dấu gạch chéo.

2019
01:40:56,690 --> 01:40:59,435
Hãy gõ chữ thường
y, trường hợp đầu, Enter.

2020
01:40:59,435 --> 01:41:02,390

2021
01:41:02,390 --> 01:41:03,700
Vì vậy, tôi đã gõ y.

2022
01:41:03,700 --> 01:41:07,420
>> Chương trình nói có, không, lỗi,
như thể nó đã được thay đổi tâm trí của nó.

2023
01:41:07,420 --> 01:41:12,280
Nhưng nó loại là, bởi vì những gì xảy ra
với một chuyển đổi là trường hợp đầu tiên mà

2024
01:41:12,280 --> 01:41:16,899
trận đấu về cơ bản có nghĩa là, hey máy tính,
thực hiện tất cả các mã bên dưới nó.

2025
01:41:16,899 --> 01:41:19,690
Và nếu bạn không nói nghỉ, hoặc
không nói nghỉ, hoặc không nói nghỉ,

2026
01:41:19,690 --> 01:41:22,540
máy tính sẽ cho nổ tung
thông qua tất cả những dòng

2027
01:41:22,540 --> 01:41:25,779
và thực hiện tất cả trong số họ cho đến khi
nó được cho rằng cú đúp xoăn.

2028
01:41:25,779 --> 01:41:27,320
Vì vậy, hệ thống phanh là, thực sự, cần thiết.

2029
01:41:27,320 --> 01:41:30,120
Nhưng một takeaway ở đây là, khi
nghi ngờ, hãy thử một cái gì đó.

2030
01:41:30,120 --> 01:41:32,510
Có thể lưu mã của bạn đầu tiên,
hoặc lưu nó trong một tập tin thêm

2031
01:41:32,510 --> 01:41:35,930
nếu bạn đang thực sự lo lắng về
rối tung lên và phải phục hồi

2032
01:41:35,930 --> 01:41:37,430
công việc mà bạn biết đang làm việc.

2033
01:41:37,430 --> 01:41:38,410
>> Nhưng hãy thử những điều.

2034
01:41:38,410 --> 01:41:41,074
Và đừng như sợ, có lẽ,
của những gì máy tính có thể làm,

2035
01:41:41,074 --> 01:41:42,490
hoặc bạn có thể phá vỡ một cái gì đó.

2036
01:41:42,490 --> 01:41:45,790
Bạn luôn có thể phục hồi trở lại
với một số phiên bản trước đó.

2037
01:41:45,790 --> 01:41:48,640
>> Vì vậy, chúng ta hãy kết thúc bằng cách tìm kiếm
vào thiết kế của mã.

2038
01:41:48,640 --> 01:41:52,020
Chúng tôi có khả năng này ngay bây giờ để viết
điều kiện và vòng viết,

2039
01:41:52,020 --> 01:41:53,850
và các biến, và các chức năng gọi.

2040
01:41:53,850 --> 01:41:57,590
Vì vậy, thẳng thắn, chúng tôi loại lại
nơi chúng tôi là một tuần trước đây với Scratch,

2041
01:41:57,590 --> 01:42:03,120
mặc dù với một văn bản ít hấp dẫn
môi trường hơn Scratch cho phép.

2042
01:42:03,120 --> 01:42:06,990
>> Nhưng lưu ý chúng tôi có được một cách nhanh chóng như thế nào
mà từ vựng, thậm chí nếu nó

2043
01:42:06,990 --> 01:42:10,570
sẽ mất một chút thời gian để chìm xuống,
vì vậy mà bây giờ chúng ta có thể sử dụng từ vựng này

2044
01:42:10,570 --> 01:42:13,320
để viết các chương trình thú vị hơn.

2045
01:42:13,320 --> 01:42:15,940
Và chúng ta hãy bước bé
về phía đó, như sau.

2046
01:42:15,940 --> 01:42:17,890
Hãy để tôi đi trước và
tạo ra một tập tin mới ở đây.

2047
01:42:17,890 --> 01:42:20,750
>> Tôi sẽ gọi này
prototype.c, và giới thiệu

2048
01:42:20,750 --> 01:42:23,954
lần đầu tiên, khả năng
để thực hiện chức năng của riêng bạn.

2049
01:42:23,954 --> 01:42:25,870
Một số bạn có thể có
thực hiện điều này với Scratch,

2050
01:42:25,870 --> 01:42:28,430
nhờ đó mà bạn có thể tạo ra của bạn
khối riêng trong Scratch,

2051
01:42:28,430 --> 01:42:30,892
và sau đó kéo chúng vào vị trí
bất cứ nơi nào bạn muốn trong C.

2052
01:42:30,892 --> 01:42:33,100
Và trong hầu hết các lập trình
ngôn ngữ, bạn có thể thực hiện chính xác

2053
01:42:33,100 --> 01:42:36,580
mà-- thực hiện chức năng của riêng bạn,
nếu họ không tồn tại.

2054
01:42:36,580 --> 01:42:41,660
>> Vì vậy, ví dụ, hãy để tôi đi trước
và bao gồm CS50.h, và bao gồm

2055
01:42:41,660 --> 01:42:46,110
chuẩn IO.h, int void main.

2056
01:42:46,110 --> 01:42:49,020
Và bây giờ chúng tôi có một
giữ chỗ sẵn sàng để đi.

2057
01:42:49,020 --> 01:42:51,550
Tôi giữ cho mọi thứ in
như tên của người dân ngày hôm nay.

2058
01:42:51,550 --> 01:42:54,910
Và cảm thấy like--
sẽ không được tốt đẹp nếu có

2059
01:42:54,910 --> 01:42:56,936
là một chức năng gọi tên in?

2060
01:42:56,936 --> 01:42:58,060
Tôi không cần phải sử dụng printf.

2061
01:42:58,060 --> 01:42:59,976
Tôi không cần phải ghi nhớ
tất cả các mã định dạng.

2062
01:42:59,976 --> 01:43:03,050
Tại sao tôi không, hay tại sao
không một người nào đó trước tôi,

2063
01:43:03,050 --> 01:43:05,980
tạo ra một chức năng gọi là in
tên, mà đưa ra một số tên,

2064
01:43:05,980 --> 01:43:06,980
chỉ đơn giản in nó ra?

2065
01:43:06,980 --> 01:43:11,700
>> Nói cách khác, nếu tôi nói, hey,
máy tính, cho tôi một chuỗi

2066
01:43:11,700 --> 01:43:14,870
bằng cách yêu cầu người dùng cho như vậy,
thông qua chức năng get chuỗi CS50 của.

2067
01:43:14,870 --> 01:43:18,090
Hey, máy tính, một chuỗi ký tự mà trong
biến ở phía bên tay trái,

2068
01:43:18,090 --> 01:43:19,150
và gọi nó là.

2069
01:43:19,150 --> 01:43:25,150
Và sau đó, hey máy tính, đi trước
và in mà tên của người đó, thực hiện.

2070
01:43:25,150 --> 01:43:29,240
>> Bây giờ, nó sẽ được tốt đẹp, bởi vì
chương trình này, hòn đảo có tên,

2071
01:43:29,240 --> 01:43:32,170
nói với tôi những gì nó phải làm
bằng cách tên những người của hàm.

2072
01:43:32,170 --> 01:43:35,930
Hãy để tôi đi và làm cho nguyên mẫu, Enter.

2073
01:43:35,930 --> 01:43:37,930
Và, thật không may,
điều này sẽ không để bay.

2074
01:43:37,930 --> 01:43:42,430
>> Prototype.c, dòng 7, nhân vật
5, lỗi, khai báo ngầm

2075
01:43:42,430 --> 01:43:45,960
tên in chức năng
là không hợp lệ trong C99, C99

2076
01:43:45,960 --> 01:43:48,130
có nghĩa là một phiên bản của C
mà ra đến năm 1999.

2077
01:43:48,130 --> 01:43:48,730
Đó là tất cả.

2078
01:43:48,730 --> 01:43:51,780
>> Vì vậy, tôi không biết những gì
tất cả điều này có nghĩa là chưa.

2079
01:43:51,780 --> 01:43:53,810
Nhưng tôi nhận ra lỗi trong màu đỏ.

2080
01:43:53,810 --> 01:43:54,770
Đó là khá rõ ràng.

2081
01:43:54,770 --> 01:43:56,769
>> Và dường như với
các nhân vật màu xanh lá cây ở đây,

2082
01:43:56,769 --> 01:44:00,520
vấn đề là với tên in, mở
Dấu ngoặc s, dấu ngoặc đóng, dấu chấm phẩy.

2083
01:44:00,520 --> 01:44:04,800
Nhưng tuyên bố tiềm ẩn của
chức năng, chúng tôi đã nhìn thấy một thời gian ngắn trước đó.

2084
01:44:04,800 --> 01:44:07,880
Điều này có nghĩa, đơn giản, mà Clang
không biết những gì tôi có ý nghĩa.

2085
01:44:07,880 --> 01:44:12,000
>> Tôi đã sử dụng một từ ngữ mà chúng nó
không bao giờ nhìn thấy hoặc được dạy trước.

2086
01:44:12,000 --> 01:44:14,950
Và vì vậy tôi cần phải dạy cho nó
những chức năng này có nghĩa.

2087
01:44:14,950 --> 01:44:16,590
Vì vậy, tôi sẽ đi trước và làm điều đó.

2088
01:44:16,590 --> 01:44:20,970
>> Tôi sẽ đi trước và thực hiện
chức năng riêng của tôi gọi là In Name.

2089
01:44:20,970 --> 01:44:27,720
Và tôi sẽ nói như sau, mà
nó thực hiện điều này, printf, hello, phần trăm

2090
01:44:27,720 --> 01:44:30,760
s, dấu chéo ngược n, tên, dấu chấm phẩy.

2091
01:44:30,760 --> 01:44:32,250
Vì vậy, những gì đã làm tôi chỉ làm gì?

2092
01:44:32,250 --> 01:44:34,325
>> Vì vậy, nó quay ra, để
thực hiện chức năng riêng của bạn,

2093
01:44:34,325 --> 01:44:36,845
chúng tôi loại vay mượn một số
cấu trúc tương tự như chính

2094
01:44:36,845 --> 01:44:38,720
rằng chúng tôi đã chỉ được
đưa cho các cấp, và tôi

2095
01:44:38,720 --> 01:44:40,730
biết chỉ cần sao chép và
dán khá nhiều những gì

2096
01:44:40,730 --> 01:44:42,170
Tôi đã viết trong quá khứ.

2097
01:44:42,170 --> 01:44:43,570
Nhưng nhận thấy mô hình ở đây.

2098
01:44:43,570 --> 01:44:46,750
Int, Main, Void, chúng tôi sẽ trêu chọc nhau
trước dài những gì mà thực sự có nghĩa.

2099
01:44:46,750 --> 01:44:49,160
>> Nhưng hôm nay, chỉ cần
nhận thấy song song.

2100
01:44:49,160 --> 01:44:51,210
Void, tên in,
tên chuỗi, do đó,

2101
01:44:51,210 --> 01:44:53,310
một từ khóa tím, mà
chúng ta sẽ bắt đầu

2102
01:44:53,310 --> 01:44:57,067
gọi một kiểu trả về, tên của
chức năng, và sau đó đầu vào.

2103
01:44:57,067 --> 01:44:59,400
Vì vậy, trên thực tế, chúng ta có thể chưng cất
loại này giống như tuần trước

2104
01:44:59,400 --> 01:45:02,030
như, đây là tên hoặc
thuật toán mã chúng tôi

2105
01:45:02,030 --> 01:45:03,761
sẽ write-- sự
thuật toán cơ bản

2106
01:45:03,761 --> 01:45:05,010
mã chúng tôi đang đi để viết.

2107
01:45:05,010 --> 01:45:06,180
>> Đây là đầu vào của nó.

2108
01:45:06,180 --> 01:45:07,670
Đây là sản lượng của nó.

2109
01:45:07,670 --> 01:45:11,730
Chức năng này, tên in, là
được thiết kế để có một chuỗi gọi tên,

2110
01:45:11,730 --> 01:45:14,350
hoặc bất cứ điều gì, như đầu vào, và sau đó vô hiệu.

2111
01:45:14,350 --> 01:45:16,904
Nó không trả lại bất cứ điều gì,
như nhận được chuỗi hoặc nhận int không.

2112
01:45:16,904 --> 01:45:18,570
Vì vậy, nó sẽ đưa cho tôi một cái gì đó trở lại.

2113
01:45:18,570 --> 01:45:20,960
Nó chỉ là sẽ có một
tác dụng phụ, có thể nói,

2114
01:45:20,960 --> 01:45:22,570
in ấn tên của một người.

2115
01:45:22,570 --> 01:45:25,260
Vì vậy, để ý, dòng 7, tôi
có thể gọi tên in.

2116
01:45:25,260 --> 01:45:28,920
Dòng 10, tôi có thể xác định
hoặc thực hiện các tên in.

2117
01:45:28,920 --> 01:45:31,450
Nhưng, không may, đó là chưa đủ.

2118
01:45:31,450 --> 01:45:34,230
>> Hãy để tôi đi trước và
biên dịch lại này sau khi tiết kiệm.

2119
01:45:34,230 --> 01:45:36,910
Whoa, bây giờ, tôi đã thực hiện nó
tệ hơn, nó sẽ có vẻ.

2120
01:45:36,910 --> 01:45:40,027
khai Vì vậy tiềm ẩn của
Tên chức năng in không hợp lệ.

2121
01:45:40,027 --> 01:45:41,360
Và, một lần nữa, có nhiều sai sót.

2122
01:45:41,360 --> 01:45:44,430
Nhưng như tôi đã cảnh báo trước đó, thậm chí
nếu bạn nhận được tràn đầy,

2123
01:45:44,430 --> 01:45:47,850
hoặc một chút buồn khi thấy rất nhiều
lỗi, chỉ tập trung vào ngày đầu tiên

2124
01:45:47,850 --> 01:45:50,500
Ban đầu, bởi vì nó có thể chỉ
đã có một ảnh hưởng tầng.

2125
01:45:50,500 --> 01:45:54,970
Vì vậy, C, hoặc Clang cụ thể hơn,
vẫn không nhận ra tên in.

2126
01:45:54,970 --> 01:45:57,580
>> Và đó là bởi vì Clang,
bởi thiết kế, là loại câm.

2127
01:45:57,580 --> 01:45:59,280
Nó chỉ làm những gì bạn nói với nó để làm.

2128
01:45:59,280 --> 01:46:03,950
Và nó chỉ làm như vậy theo thứ tự
trong đó bạn nói với nó để làm.

2129
01:46:03,950 --> 01:46:08,270
>> Vì vậy, tôi đã xác định chính trên dòng bốn,
như chúng ta đã làm khá thường xuyên.

2130
01:46:08,270 --> 01:46:10,980
Tôi đã xác định tên in trên dòng 10.

2131
01:46:10,980 --> 01:46:14,793
Nhưng tôi đang cố gắng để sử dụng
Tên in trên dòng bảy.

2132
01:46:14,793 --> 01:46:16,670
>> Nó quá sớm, chưa hề tồn tại.

2133
01:46:16,670 --> 01:46:22,150
Vì vậy, tôi có thể là thông minh, và được như thế,
OK, vì vậy chúng ta hãy chỉ chơi cùng,

2134
01:46:22,150 --> 01:46:26,680
và di chuyển tên in lên
ở đây, và lập lại.

2135
01:46:26,680 --> 01:46:27,550
Ôi chúa ơi.

2136
01:46:27,550 --> 01:46:28,260
Nó đã làm việc.

2137
01:46:28,260 --> 01:46:29,670
nó đơn giản như vây thôi.

2138
01:46:29,670 --> 01:46:31,120
>> Nhưng logic là chính xác đó.

2139
01:46:31,120 --> 01:46:33,870
Bạn phải dạy Clang gì nó
là bằng cách định nghĩa các chức năng đầu tiên.

2140
01:46:33,870 --> 01:46:34,920
Sau đó, bạn có thể sử dụng nó.

2141
01:46:34,920 --> 01:46:36,940
Nhưng thẳng thắn mà nói, điều này cảm thấy
như một dốc trơn trượt.

2142
01:46:36,940 --> 01:46:38,773
>> Vì vậy, mỗi khi tôi chạy
vào một vấn đề, tôi chỉ

2143
01:46:38,773 --> 01:46:42,450
sẽ làm nổi bật và sao chép mã
Tôi đã viết, cắt và dán nó lên đây.

2144
01:46:42,450 --> 01:46:44,370
Và, chắc chắn, chúng tôi có thể
xoay sở một số kịch bản

2145
01:46:44,370 --> 01:46:46,286
nơi mà một hàm có thể
cần phải gọi khác.

2146
01:46:46,286 --> 01:46:49,030
Và bạn chỉ có thể đặt tất cả
Chức năng trên mỗi khác.

2147
01:46:49,030 --> 01:46:50,930
>> Vì vậy, nó quay ra có của
một giải pháp tốt hơn.

2148
01:46:50,930 --> 01:46:53,100
Chúng tôi có thể rời khỏi đây được.

2149
01:46:53,100 --> 01:46:56,677
Và, thẳng thắn, nó thường tốt đẹp,
và thuận tiện, và thiết kế tốt

2150
01:46:56,677 --> 01:46:59,760
để đặt chính đầu tiên, bởi vì, một lần nữa,
chính giống như khi lá cờ màu xanh lá cây nhấp,

2151
01:46:59,760 --> 01:47:02,027
đó là chức năng mà
được thực hiện theo mặc định.

2152
01:47:02,027 --> 01:47:04,110
Vì vậy, bạn cũng có thể đặt
nó ở trên cùng của tập tin

2153
01:47:04,110 --> 01:47:06,560
để khi bạn hay bất kỳ
con người khác nhìn vào các tập tin

2154
01:47:06,560 --> 01:47:09,360
bạn biết những gì đang xảy ra
chỉ bằng cách đọc chính đầu tiên.

2155
01:47:09,360 --> 01:47:18,360
Vì vậy, nó quay ra, chúng ta có thể nói Clang
chủ động, hey, Clang, trên dòng bốn,

2156
01:47:18,360 --> 01:47:20,940
Tôi hứa sẽ thực hiện
một chức năng gọi là In

2157
01:47:20,940 --> 01:47:25,600
Tên rằng phải mất một chuỗi gọi tên
như đầu vào, và trả về không có gì, void.

2158
01:47:25,600 --> 01:47:27,770
Và tôi sẽ nhận được xung quanh để
thực hiện nó sau này.

2159
01:47:27,770 --> 01:47:28,680
>> Ở đây có chính.

2160
01:47:28,680 --> 01:47:32,130
Chính hiện nay trên dòng 9 có thể sử dụng
In Name vì Clang

2161
01:47:32,130 --> 01:47:35,600
được tin tưởng rằng, cuối cùng,
nó sẽ gặp phải định nghĩa

2162
01:47:35,600 --> 01:47:37,880
việc thực hiện các In Name.

2163
01:47:37,880 --> 01:47:40,390
Vì vậy, sau khi lưu file của tôi, chúng ta hãy
tôi đi trước và làm mẫu,

2164
01:47:40,390 --> 01:47:41,498
có vẻ tốt thời gian này.

2165
01:47:41,498 --> 01:47:46,470
Dot giảm, nguyên mẫu, cho tôi
đi trước và gõ vào một tên.

2166
01:47:46,470 --> 01:47:51,440
David, xin chào David, Zamila, hello
Zamila, và, thực sự, bây giờ nó hoạt động.

2167
01:47:51,440 --> 01:47:55,200
>> Vì vậy, các thành phần ở đây là chúng ta đã
thực hiện một chức năng tùy chỉnh, như một tùy chỉnh

2168
01:47:55,200 --> 01:47:57,219
khối đầu chúng tôi đang gọi nó.

2169
01:47:57,219 --> 01:48:00,010
Nhưng không giống như Scratch nơi bạn có thể
chỉ tạo ra nó và bắt đầu sử dụng nó,

2170
01:48:00,010 --> 01:48:02,330
bây giờ chúng ta phải là một
ít mô phạm hơn,

2171
01:48:02,330 --> 01:48:06,410
và thực sự đào tạo Clang
để sử dụng, hoặc để mong đợi nó.

2172
01:48:06,410 --> 01:48:12,140
Bây giờ, như một sang một bên, tại sao tất cả các thời gian này có
chúng tôi đã chỉ một cách mù quáng vào đức tin bao gồm

2173
01:48:12,140 --> 01:48:15,170
CS50.h, và bao gồm cả tiêu chuẩn IO.h?

2174
01:48:15,170 --> 01:48:18,190
>> Vâng, nó quay ra,
một trong số ít những thứ khác,

2175
01:48:18,190 --> 01:48:21,550
tất cả những gì trong những dấu chấm h
tập tin, mà xảy ra được file.

2176
01:48:21,550 --> 01:48:23,460
Họ đang tập tin tiêu đề, vậy để nói chuyện.

2177
01:48:23,460 --> 01:48:26,270
Họ vẫn đang được viết bằng C. Nhưng
họ là một loại khác nhau của tập tin.

2178
01:48:26,270 --> 01:48:31,690
>> Để bây giờ, bạn có thể khá nhiều giả định
rằng tất cả những gì là bên trong của CS50.h

2179
01:48:31,690 --> 01:48:36,360
là số một lớp lót như thế này, không
cho các chức năng Print Name,

2180
01:48:36,360 --> 01:48:39,840
nhưng đối với Nhận String, Nhận
Phao, và một vài người khác.

2181
01:48:39,840 --> 01:48:44,510
Và có những mẫu tương tự,
một lớp lót, bên trong IO.h chuẩn

2182
01:48:44,510 --> 01:48:49,241
cho printf, mà bây giờ trong
riêng In Tên chức năng của tôi.

2183
01:48:49,241 --> 01:48:52,490
Vì vậy, nói cách khác, toàn bộ thời gian này, chúng tôi đã
chỉ được một cách mù quáng sao chép và dán

2184
01:48:52,490 --> 01:48:54,780
bao gồm này, bao gồm
rằng, những gì đang xảy ra?

2185
01:48:54,780 --> 01:48:58,310
Những người chỉ là loại manh mối
để kêu vang như chức năng gì

2186
01:48:58,310 --> 01:49:03,170
được, thực sự, thực hiện, chỉ cần
ở những nơi khác trong các tập tin khác nhau

2187
01:49:03,170 --> 01:49:05,440
ở những nơi khác trên hệ thống.

2188
01:49:05,440 --> 01:49:08,160
>> Vì vậy, chúng tôi đã triển khai tên in.

2189
01:49:08,160 --> 01:49:10,910
Nó không có tác dụng phụ này của
in một cái gì đó trên màn hình.

2190
01:49:10,910 --> 01:49:13,170
Nhưng nó không thực sự
đưa cho tôi một cái gì đó trở lại.

2191
01:49:13,170 --> 01:49:15,200
Làm thế nào để chúng tôi đi về
thực hiện một chương trình

2192
01:49:15,200 --> 01:49:17,510
không đưa cho tôi một cái gì đó trở lại?

2193
01:49:17,510 --> 01:49:18,580
>> Vâng, chúng ta hãy cố gắng này.

2194
01:49:18,580 --> 01:49:24,360
Hãy để tôi đi trước và thực hiện
một tập tin gọi là return.c

2195
01:49:24,360 --> 01:49:27,530
vì vậy chúng tôi có thể chứng minh một cái gì đó như thế nào
như Get String, hoặc Nhận Int,

2196
01:49:27,530 --> 01:49:30,340
là thực sự trở về
một cái gì đó trở lại cho người sử dụng.

2197
01:49:30,340 --> 01:49:32,840
Hãy đi trước và xác định int void main.

2198
01:49:32,840 --> 01:49:36,230
>> Và, một lần nữa, trong tương lai, chúng tôi sẽ
giải thích những gì mà int và khoảng trống đó

2199
01:49:36,230 --> 01:49:37,090
là thực sự làm.

2200
01:49:37,090 --> 01:49:38,840
Nhưng hôm nay, chúng tôi sẽ
đưa nó cho cấp.

2201
01:49:38,840 --> 01:49:42,970
Tôi sẽ đi trước và printf,
cho một kinh nghiệm người dùng tốt, x là.

2202
01:49:42,970 --> 01:49:47,360
Và sau đó tôi sẽ chờ đợi cho
người sử dụng để cung cấp cho tôi với x get int.

2203
01:49:47,360 --> 01:49:51,459
>> Và sau đó tôi sẽ đi trước
và in ra x với hình vuông.

2204
01:49:51,459 --> 01:49:53,500
Vì vậy, khi bạn chỉ có một
bàn phím, mọi người thường

2205
01:49:53,500 --> 01:49:55,600
sử dụng cà rốt nhỏ
biểu tượng trên bàn phím

2206
01:49:55,600 --> 01:49:58,330
đại diện cho sức mạnh
của, hoặc số mũ của.

2207
01:49:58,330 --> 01:50:01,960
Vì vậy x bình phương là hiện tại tôi.

2208
01:50:01,960 --> 01:50:03,660
>> Và bây giờ tôi sẽ làm điều này.

2209
01:50:03,660 --> 01:50:06,940
Tôi chỉ có thể do-- x là gì
bình phương? x bình phương là x lần x.

2210
01:50:06,940 --> 01:50:09,690
>> Và chúng tôi đã làm điều này một số
thời gian trước đây đã được ngày hôm nay.

2211
01:50:09,690 --> 01:50:11,730
Điều này không cảm thấy như
tất cả những tiến bộ nhiều.

2212
01:50:11,730 --> 01:50:12,570
Bạn biết những gì?

2213
01:50:12,570 --> 01:50:16,100
Hãy tận dụng một số ý kiến ​​cho rằng
từ lần cuối cùng của sự trừu tượng.

2214
01:50:16,100 --> 01:50:19,080
>> Nó sẽ không được tốt đẹp nếu
có một chức năng gọi là

2215
01:50:19,080 --> 01:50:21,460
vuông mà không chính xác đó?

2216
01:50:21,460 --> 01:50:23,640
Nó vẫn còn, vào cuối của
ngày, hiện các toán tương tự.

2217
01:50:23,640 --> 01:50:25,410
Nhưng chúng ta hãy tóm tắt
đi những ý tưởng chốt

2218
01:50:25,410 --> 01:50:28,280
một số nhân
khác, và chỉ cần cung cấp cho nó một cái tên,

2219
01:50:28,280 --> 01:50:30,360
như vuông giá trị này.

2220
01:50:30,360 --> 01:50:32,560
>> Và, nói cách khác, trong
C, chúng ta hãy tạo ra một chức năng

2221
01:50:32,560 --> 01:50:35,660
gọi là hình vuông mà không chính xác đó.

2222
01:50:35,660 --> 01:50:37,600
Nó sẽ được gọi là vuông.

2223
01:50:37,600 --> 01:50:38,790
Nó sẽ mất một int.

2224
01:50:38,790 --> 01:50:40,820
Và chúng tôi sẽ sẽ chỉ
gọi nó là n, theo mặc định.

2225
01:50:40,820 --> 01:50:42,403
>> Nhưng chúng ta có thể gọi nó là bất cứ điều gì chúng ta muốn.

2226
01:50:42,403 --> 01:50:45,900
Và tất cả những gì nó sẽ
làm, theo nghĩa đen, là trở lại

2227
01:50:45,900 --> 01:50:48,810
kết quả của n n lần.

2228
01:50:48,810 --> 01:50:51,980
Nhưng bởi vì nó là
trở về một cái gì đó, mà

2229
01:50:51,980 --> 01:50:56,690
là từ khóa trong màu tím chúng tôi đã
chưa bao giờ thấy trước đây, tôi, trên đường 11,

2230
01:50:56,690 --> 01:50:58,410
không thể chỉ nói khoảng trống thời gian này.

2231
01:50:58,410 --> 01:51:04,320
>> Void, trong ví dụ này, chúng tôi chỉ thấy
chứ không phải của tên in, chỉ có nghĩa là,

2232
01:51:04,320 --> 01:51:05,190
làm việc gì đó.

2233
01:51:05,190 --> 01:51:07,170
Nhưng đừng đưa cho tôi một cái gì đó trở lại.

2234
01:51:07,170 --> 01:51:09,790
Trong trường hợp này, tôi muốn
trở lại n lần n,

2235
01:51:09,790 --> 01:51:11,460
hoặc bất cứ điều gì có nghĩa là, con số đó.

2236
01:51:11,460 --> 01:51:15,460
>> Vì vậy, tôi không thể nói, hey, máy tính,
Tôi trở về không có gì, void.

2237
01:51:15,460 --> 01:51:19,166
Nó sẽ quay trở lại, bởi bản chất, một int.

2238
01:51:19,166 --> 01:51:20,790
Và đó là tất cả những gì xảy ra ở đây.

2239
01:51:20,790 --> 01:51:23,070
>> Các đầu vào vuông
sẽ là một int.

2240
01:51:23,070 --> 01:51:27,760
Và như vậy chúng ta có thể sử dụng nó, nó phải
có một tên, N. Nó sẽ đầu ra

2241
01:51:27,760 --> 01:51:29,240
một int mà không cần một tên.

2242
01:51:29,240 --> 01:51:32,590
Chúng tôi có thể để lại nó cho chính, hoặc bất cứ ai
sử dụng tôi nhớ lại giá trị này nếu chúng ta

2243
01:51:32,590 --> 01:51:34,120
muốn với biến riêng của mình.

2244
01:51:34,120 --> 01:51:36,230
>> Và, một lần nữa, mới chỉ
từ khóa ở đây là Return.

2245
01:51:36,230 --> 01:51:37,480
Và tôi chỉ cần làm một số toán học.

2246
01:51:37,480 --> 01:51:44,825
Nếu tôi thực sự muốn là không cần thiết,
Tôi có thể nói int sản phẩm được n n lần.

2247
01:51:44,825 --> 01:51:47,170
>> Và sau đó tôi có thể nói, trả lại sản phẩm.

2248
01:51:47,170 --> 01:51:50,360
Nhưng, một lần nữa, quan điểm của tôi trước đó của
này chỉ cần không phải là design-- tốt

2249
01:51:50,360 --> 01:51:53,060
như thế, tại sao giới thiệu tên,
một biểu tượng, như sản phẩm,

2250
01:51:53,060 --> 01:51:54,570
chỉ để ngay lập tức trả lại nó?

2251
01:51:54,570 --> 01:51:56,670
Đó là một chút bụi,
một chút chặt chẽ, vì vậy

2252
01:51:56,670 --> 01:52:02,380
để nói chuyện, chỉ để nói lần trở lại n
n, loại bỏ dòng này hoàn toàn.

2253
01:52:02,380 --> 01:52:05,860
>> Và nó chỉ là mã ít hơn để đọc,
ít cơ hội cho những sai lầm.

2254
01:52:05,860 --> 01:52:08,180
Và chúng ta hãy xem nếu điều này
thực hiện hoạt động.

2255
01:52:08,180 --> 01:52:12,380
Bây giờ, tôi sẽ đi
trước và thực hiện trở lại.

2256
01:52:12,380 --> 01:52:14,460
>> Uh-oh, khai tiềm ẩn của chức năng.

2257
01:52:14,460 --> 01:52:17,080
Tôi đã sai lầm này trước khi, không có việc lớn.

2258
01:52:17,080 --> 01:52:21,950
Hãy để tôi chỉ cần gõ, hoặc làm nổi bật và
sao chép, chính xác cùng một chức năng nguyên mẫu,

2259
01:52:21,950 --> 01:52:24,342
hoặc chữ ký, các chức năng ở đây.

2260
01:52:24,342 --> 01:52:25,800
Hoặc tôi có thể di chuyển toàn bộ chức năng.

2261
01:52:25,800 --> 01:52:26,841
>> Nhưng đó là một chút lười biếng.

2262
01:52:26,841 --> 01:52:27,870
Vì vậy, chúng tôi sẽ không làm điều đó.

2263
01:52:27,870 --> 01:52:30,960
Bây giờ, hãy để tôi làm lại
một lần nữa, chấm nương trở lại.

2264
01:52:30,960 --> 01:52:35,790
>> x kiến ​​2 x bình phương là 4.
x kiến ​​3 x bình phương là 9.

2265
01:52:35,790 --> 01:52:38,300
Và các chức năng dường như
bây giờ để được làm việc.

2266
01:52:38,300 --> 01:52:39,550
Vì vậy, sự khác biệt ở đây là gì?

2267
01:52:39,550 --> 01:52:45,520
Tôi có một chức năng đó được gọi là hình vuông,
trong trường hợp này, mà tôi đưa vào một đầu vào.

2268
01:52:45,520 --> 01:52:46,830
Và tôi nhận lại một đầu ra.

2269
01:52:46,830 --> 01:52:49,210
Tuy nhiên, trước đó, nếu
Tôi mở ví dụ khác

2270
01:52:49,210 --> 01:52:54,640
từ trước đó, mà
đã gọi là prototype.c,

2271
01:52:54,640 --> 01:52:57,770
Tôi đã có tên in, mà
trở về khoảng trống, có thể nói,

2272
01:52:57,770 --> 01:53:01,730
Hoặc nó trở lại không có gì, và
chỉ đơn giản là có một tác dụng phụ.

2273
01:53:01,730 --> 01:53:03,230
>> Vì vậy, những gì đang xảy ra ở đây?

2274
01:53:03,230 --> 01:53:06,520
Vâng, hãy xem xét các chức năng
nhận được chuỗi cho chỉ là một khoảnh khắc.

2275
01:53:06,520 --> 01:53:09,570
Chúng tôi đã sử dụng chức năng
nhận được chuỗi theo cách sau.

2276
01:53:09,570 --> 01:53:13,464
>> Chúng tôi đã có một chức năng được
chuỗi, giống như bao gồm CS50.h,

2277
01:53:13,464 --> 01:53:19,624
bao gồm tiêu chuẩn IO.h, int, main, void.

2278
01:53:19,624 --> 01:53:21,790
Và sau đó mỗi khi tôi đã
được gọi là get chuỗi vậy, đến nay,

2279
01:53:21,790 --> 01:53:26,260
Tôi đã nói như thế, chuỗi s
được nhận được chuỗi, vì get string--

2280
01:53:26,260 --> 01:53:30,880
chúng ta hãy gọi get chuỗi get.c-- này
tự trả về một chuỗi mà tôi có thể sau đó

2281
01:53:30,880 --> 01:53:35,050
sử dụng, và nói, xin chào, dấu phẩy,
phần trăm s, dấu chéo ngược n, s.

2282
01:53:35,050 --> 01:53:38,660
>> Vì vậy, đây là những ví dụ tương tự,
thực sự, chúng ta đã có trước đó.

2283
01:53:38,660 --> 01:53:40,920
Vì vậy, nhận được chuỗi trả về một giá trị.

2284
01:53:40,920 --> 01:53:44,260
Nhưng một thời gian trước đây, chuỗi in
không trả về một giá trị.

2285
01:53:44,260 --> 01:53:45,721
Nó chỉ đơn giản là có một tác dụng phụ.

2286
01:53:45,721 --> 01:53:47,220
Vì vậy, đây là một sự khác biệt cơ bản.

2287
01:53:47,220 --> 01:53:49,710
Chúng tôi đã nhìn thấy khác nhau
loại chức năng bây giờ,

2288
01:53:49,710 --> 01:53:52,490
một số trong đó đã quay trở lại
giá trị, một số trong đó không.

2289
01:53:52,490 --> 01:53:54,890
Vì vậy, có lẽ đó là chuỗi, hoặc int, hoặc thả nổi.

2290
01:53:54,890 --> 01:53:56,480
Hoặc có lẽ nó chỉ là vô hiệu.

2291
01:53:56,480 --> 01:53:58,710
>> Và sự khác biệt là
rằng những chức năng mà

2292
01:53:58,710 --> 01:54:02,940
có được dữ liệu và trả về một giá trị thực sự
mang lại một cái gì đó trở lại bàn,

2293
01:54:02,940 --> 01:54:04,110
vậy để nói chuyện.

2294
01:54:04,110 --> 01:54:06,710
Vì vậy, chúng ta hãy đi trước và
nhìn vào một tập cuối cùng

2295
01:54:06,710 --> 01:54:12,129
các ví dụ cho một cảm giác, bây giờ, các
thế nào chúng ta có thể, quả thực, trừu tượng hơn,

2296
01:54:12,129 --> 01:54:14,670
và tốt hơn, và tốt hơn, hay hơn,
và nhiều hơn nữa, và nhiều hơn nữa, để

2297
01:54:14,670 --> 01:54:16,810
để viết, cuối cùng, mã tốt hơn.

2298
01:54:16,810 --> 01:54:19,860
Hãy đi trước, và trong tinh thần
của Scratch, làm như sau.

2299
01:54:19,860 --> 01:54:24,700
>> Hãy để tôi đi trước và bao gồm
CS50.h và chuẩn IO.h.

2300
01:54:24,700 --> 01:54:27,010
Hãy để tôi đi trước và cho
bản thân mình một int, main, void.

2301
01:54:27,010 --> 01:54:30,380
Và hãy để tôi đi trước, gọi cough.c này.

2302
01:54:30,380 --> 01:54:38,510
>> Và hãy để tôi đi trước và chỉ
như Scratch, in ra ho / n.

2303
01:54:38,510 --> 01:54:40,170
Và tôi muốn làm điều này ba lần.

2304
01:54:40,170 --> 01:54:42,670
Vì vậy, tôi, tất nhiên, chỉ cần đi
để sao chép và dán ba lần.

2305
01:54:42,670 --> 01:54:49,440
Tôi bây giờ sẽ làm cho
ho dot slash ho.

2306
01:54:49,440 --> 01:54:53,120
Hãy cho bản thân mình một căn phòng nhỏ hơn
ở đây, Enter, ho, ho, ho.

2307
01:54:53,120 --> 01:54:56,970
>> Có, rõ ràng đã là một
cơ hội để cải thiện.

2308
01:54:56,970 --> 01:54:58,679
Tôi đã sao chép và dán
một vài lần hiện nay.

2309
01:54:58,679 --> 01:55:01,261
Nhưng đó chỉ là vì vậy tôi đã không
phải nhập bao nhiêu ký tự.

2310
01:55:01,261 --> 01:55:03,250
Tôi vẫn còn thay đổi gì
những dòng mã được.

2311
01:55:03,250 --> 01:55:07,240
>> Ba dòng giống hệt nhau,
mà cảm thấy lười biếng và thực sự là,

2312
01:55:07,240 --> 01:55:10,110
và có lẽ không phải là cách tiếp cận đúng.

2313
01:55:10,110 --> 01:55:14,029
Vì vậy, với những gì thành phần
chúng ta có thể cải thiện mã này?

2314
01:55:14,029 --> 01:55:15,570
Chúng tôi không cần phải sao chép và dán mã.

2315
01:55:15,570 --> 01:55:18,070
>> Và, quả thật vậy, bất cứ lúc nào bạn cảm thấy
tự sao chép và dán,

2316
01:55:18,070 --> 01:55:20,700
và thậm chí không thay đổi mã,
tỷ lệ cược là có một cách tốt hơn.

2317
01:55:20,700 --> 01:55:22,470
Và, quả thật, có.

2318
01:55:22,470 --> 01:55:25,510
Hãy để tôi đi trước và làm một vòng lặp for,
mặc dù cú pháp có thể không

2319
01:55:25,510 --> 01:55:27,570
đến tự nhiên nào.

2320
01:55:27,570 --> 01:55:32,494
>> Làm điều này ba lần, chỉ cần
bằng cách làm following--

2321
01:55:32,494 --> 01:55:34,160
và tôi xảy ra để biết điều này từ thực tiễn.

2322
01:55:34,160 --> 01:55:35,810
Nhưng chúng tôi có một số ví dụ bây giờ.

2323
01:55:35,810 --> 01:55:37,950
Và bạn sẽ thấy trực tuyến
nhiều tài liệu tham khảo vẫn còn.

2324
01:55:37,950 --> 01:55:40,790
>> Đây là cú pháp trên dòng 6, mà
giống như Scratch đó lặp đi lặp lại

2325
01:55:40,790 --> 01:55:43,090
khối, lặp lại ba lần sau.

2326
01:55:43,090 --> 01:55:44,340
Đó là một phép thuật nhỏ cho bây giờ.

2327
01:55:44,340 --> 01:55:46,050
Nhưng điều này sẽ nhận được nhiều hơn,
và quen thuộc hơn.

2328
01:55:46,050 --> 01:55:48,050
>> Và nó sẽ lặp lại
dòng tám ba lần,

2329
01:55:48,050 --> 01:55:55,390
do đó, nếu tôi lập lại làm cho ho,
dot giảm ho, ho, ho, ho.

2330
01:55:55,390 --> 01:55:57,030
Nó vẫn hoạt động theo cùng một cách.

2331
01:55:57,030 --> 01:55:58,550
Vì vậy, đó là tất cả tốt và tốt.

2332
01:55:58,550 --> 01:56:01,200
Nhưng đó không phải là rất trừu tượng.

2333
01:56:01,200 --> 01:56:02,371
>> Đó là hoàn toàn chính xác.

2334
01:56:02,371 --> 01:56:04,370
Nhưng nó cảm thấy như có
có thể là một cơ hội,

2335
01:56:04,370 --> 01:56:06,750
như trong thế giới của
Scratch, để loại bắt đầu

2336
01:56:06,750 --> 01:56:10,530
để thêm một số ngữ nghĩa ở đây để
Tôi không chỉ có một số vòng lặp,

2337
01:56:10,530 --> 01:56:12,867
và một chức năng mà nói
ho hoặc không ho.

2338
01:56:12,867 --> 01:56:13,450
Bạn biết những gì?

2339
01:56:13,450 --> 01:56:15,620
Hãy để tôi cố gắng để được một
ít lạnh hơn,

2340
01:56:15,620 --> 01:56:19,090
và thực sự viết một chức năng mà
có một số tác dụng phụ, gọi nó là ho.

2341
01:56:19,090 --> 01:56:23,830
>> Và nó sẽ không có đầu vào, và
trả về không có giá trị như đầu ra.

2342
01:56:23,830 --> 01:56:25,680
Nhưng bạn biết những gì nó?

2343
01:56:25,680 --> 01:56:32,370
Nó này-- printf,
quote unquote, ho.

2344
01:56:32,370 --> 01:56:35,380
>> Và bây giờ lên đây, tôi sẽ
đi trước và cho int,

2345
01:56:35,380 --> 01:56:39,070
i được không, tôi ít hơn 3, tôi cộng cộng.

2346
01:56:39,070 --> 01:56:42,770
Tôi sẽ không làm printf, đó là
cho là một việc thực hiện ở mức độ thấp

2347
01:56:42,770 --> 01:56:43,270
chi tiết.

2348
01:56:43,270 --> 01:56:44,353
Tôi không quan tâm làm thế nào để ho.

2349
01:56:44,353 --> 01:56:46,240
Tôi chỉ muốn sử dụng chức năng ho.

2350
01:56:46,240 --> 01:56:47,840
Và tôi chỉ cần đi để gọi ho.

2351
01:56:47,840 --> 01:56:49,204
>> Bây giờ, nhận thấy sự phân đôi.

2352
01:56:49,204 --> 01:56:52,370
Khi bạn gọi một chức năng, nếu bạn không
muốn cho nó đầu vào, hoàn toàn tốt.

2353
01:56:52,370 --> 01:56:54,780
Chỉ cần làm mở dấu ngoặc, gần
Dấu ngoặc đơn, và bạn đang làm.

2354
01:56:54,780 --> 01:56:59,271
>> Khi bạn xác định một chức năng, hoặc
khai báo nguyên mẫu của một chức năng,

2355
01:56:59,271 --> 01:57:01,770
nếu bạn biết trước nó không
sẽ mất bất kỳ đối số,

2356
01:57:01,770 --> 01:57:04,170
nói khoảng trống trong những dấu ngoặc đơn ở đó.

2357
01:57:04,170 --> 01:57:08,660
Và điều đó làm cho chắc chắn rằng bạn
sẽ không vô tình lạm dụng nó.

2358
01:57:08,660 --> 01:57:10,020
Hãy để tôi đi trước và làm cho ho.

2359
01:57:10,020 --> 01:57:11,540
Và, tất nhiên, tôi đã thực hiện một sai lầm.

2360
01:57:11,540 --> 01:57:13,410
>> Chết tiệt, có mà
khai ngầm.

2361
01:57:13,410 --> 01:57:14,325
Nhưng đó là tốt.

2362
01:57:14,325 --> 01:57:15,590
Đây là một sửa chữa dễ dàng.

2363
01:57:15,590 --> 01:57:21,240
Tôi chỉ cần các nguyên mẫu cao lên
trong tập tin của tôi hơn là tôi đang thực sự sử dụng nó.

2364
01:57:21,240 --> 01:57:23,070
>> Vì vậy, bây giờ hãy để tôi làm cho ho một lần nữa, tốt đẹp.

2365
01:57:23,070 --> 01:57:23,790
Bây giơ no hoạt động.

2366
01:57:23,790 --> 01:57:25,930
Hãy ho, ho, ho, ho.

2367
01:57:25,930 --> 01:57:28,930
Vì vậy, bạn có thể nghĩ rằng chúng tôi đang thực sự
chỉ hơn kỹ vấn đề này.

2368
01:57:28,930 --> 01:57:29,763
Và, quả thật vậy, chúng tôi đang có.

2369
01:57:29,763 --> 01:57:31,870
Đây không phải là tốt
ứng cử viên của một chương trình

2370
01:57:31,870 --> 01:57:34,930
tại thời điểm cho
refactoring, và làm những gì

2371
01:57:34,930 --> 01:57:38,645
gọi là phân hủy phân cấp,
nơi bạn có một số mã, và sau đó

2372
01:57:38,645 --> 01:57:41,790
bạn loại yếu tố điều trên, như vậy là
gán nhiều ngữ nghĩa đối với họ,

2373
01:57:41,790 --> 01:57:43,930
và tái sử dụng nó hạn cuối cùng còn.

2374
01:57:43,930 --> 01:57:46,490
Nhưng đó là một khối xây dựng hướng tới
chương trình tinh vi hơn

2375
01:57:46,490 --> 01:57:48,600
rằng chúng ta sẽ bắt đầu
viết trước dài

2376
01:57:48,600 --> 01:57:53,090
cho phép chúng ta có các từ vựng
mà để viết mã tốt hơn.

2377
01:57:53,090 --> 01:57:55,920
Và, thực sự, chúng ta hãy xem nếu chúng ta
không thể khái quát này hơn nữa.

2378
01:57:55,920 --> 01:58:00,984
>> Nó có vẻ hơi khập khiễng mà tôi, chính,
cần phải lo lắng về darn này cho vòng lặp,

2379
01:58:00,984 --> 01:58:02,400
và kêu gọi ho một lần nữa và một lần nữa.

2380
01:58:02,400 --> 01:58:06,050
Tại sao tôi không thể chỉ nói với ho,
xin ho ba lần?

2381
01:58:06,050 --> 01:58:11,170
Nói cách khác, tại sao có thể tôi chỉ
cung cấp cho đầu vào để ho và làm điều này?

2382
01:58:11,170 --> 01:58:14,270
>> Tại sao tôi không thể chỉ nói, trong
ho chính ba lần.

2383
01:58:14,270 --> 01:58:16,150
Và bây giờ, đây là loại ma thuật.

2384
01:58:16,150 --> 01:58:17,540
Nó rất lặp đi lặp lại ở đây.

2385
01:58:17,540 --> 01:58:18,940
Và đó là, thực sự, một bước em bé.

2386
01:58:18,940 --> 01:58:22,250
>> Nhưng chỉ cần khả năng để nói về
dòng tám, ho ba lần,

2387
01:58:22,250 --> 01:58:23,730
nó chỉ là nhiều hơn nữa có thể đọc được.

2388
01:58:23,730 --> 01:58:27,210
Và, cộng thêm, tôi không cần phải biết
hoặc chăm sóc như thế nào ho được thực hiện.

2389
01:58:27,210 --> 01:58:29,460
Và, quả thật vậy, sau này trong
hạn và cho các dự án cuối cùng,

2390
01:58:29,460 --> 01:58:32,150
nếu bạn giải quyết một dự án với
một người bạn cùng lớp hoặc hai bạn cùng lớp,

2391
01:58:32,150 --> 01:58:35,370
bạn sẽ nhận ra rằng bạn đang đi tới
có, hoặc muốn, chia công việc.

2392
01:58:35,370 --> 01:58:37,650
>> Và bạn sẽ muốn quyết định
trước, ai sẽ làm những gì,

2393
01:58:37,650 --> 01:58:38,483
và trong đó miếng?

2394
01:58:38,483 --> 01:58:40,520
Và nó sẽ không được tốt đẹp
nếu bạn, ví dụ,

2395
01:58:40,520 --> 01:58:43,100
phụ trách bằng văn bản chính, thực hiện.

2396
01:58:43,100 --> 01:58:46,470
Và bạn cùng phòng của bạn, hoặc bạn
đối tác nói chung,

2397
01:58:46,470 --> 01:58:48,230
chăm sóc thực hiện ho.

2398
01:58:48,230 --> 01:58:52,540
>> Và phân chia này, các
tường trừu tượng,

2399
01:58:52,540 --> 01:58:55,310
hoặc lớp trừu tượng nếu
bạn sẽ, là siêu mạnh mẽ,

2400
01:58:55,310 --> 01:58:58,480
vì đặc biệt là đối lớn,
các chương trình phức tạp hơn và hệ thống,

2401
01:58:58,480 --> 01:59:03,070
nó cho phép nhiều người để xây dựng
thứ cùng nhau, và cuối cùng

2402
01:59:03,070 --> 01:59:05,680
khâu công việc của họ với nhau theo cách này.

2403
01:59:05,680 --> 01:59:08,332
Nhưng, tất nhiên, chúng tôi
cần bây giờ sửa chữa ho.

2404
01:59:08,332 --> 01:59:10,290
Chúng ta cần nói ho
rằng, hey, bạn biết những gì?

2405
01:59:10,290 --> 01:59:14,230
Bạn sẽ cần phải thực hiện một
input-- do đó không có hiệu lực, nhưng int và bây giờ.

2406
01:59:14,230 --> 01:59:18,170
Hãy đi trước và đưa vào
ho int. i được không.

2407
01:59:18,170 --> 01:59:19,890
>> i nhỏ hơn bao nhiêu lần.

2408
01:59:19,890 --> 01:59:21,550
Tôi nói ba trước.

2409
01:59:21,550 --> 01:59:23,420
Nhưng đó không phải là những gì tôi muốn.

2410
01:59:23,420 --> 01:59:28,520
Tôi muốn ho để được tổng quát cho
hỗ trợ bất kỳ số lần lặp lại.

2411
01:59:28,520 --> 01:59:31,800
>> Vì vậy, thực sự, đó là n mà tôi muốn,
bất cứ điều gì người dùng nói với tôi.

2412
01:59:31,800 --> 01:59:34,620
Bây giờ, tôi có thể đi trước và nói in ho.

2413
01:59:34,620 --> 01:59:37,750
Và dù con số
người sử dụng đi qua,

2414
01:59:37,750 --> 01:59:39,890
Tôi sẽ lặp lại nhiều lần.

2415
01:59:39,890 --> 01:59:42,160
>> Vì vậy, vào cuối ngày,
chương trình là giống hệt nhau.

2416
01:59:42,160 --> 01:59:45,820
Nhưng nhận thấy tất cả các công cụ này
thậm chí có thể trong tập tin khác.

2417
01:59:45,820 --> 01:59:48,620
Thật vậy, tôi không biết tại
thời điểm cách printf được thực hiện.

2418
01:59:48,620 --> 01:59:50,980
>> Tôi không biết tại thời điểm này như thế nào có được
chuỗi, hoặc nhận int, hoặc nhận được phao

2419
01:59:50,980 --> 01:59:51,646
được thực hiện.

2420
01:59:51,646 --> 01:59:53,930
Và tôi không muốn
xem chúng trên màn hình của tôi.

2421
01:59:53,930 --> 01:59:58,320
Vì nó là, tôi bắt đầu tập trung vào
chương trình của tôi, không những chức năng.

2422
01:59:58,320 --> 02:00:02,070
>> Và như vậy, quả thật vậy, ngay sau khi bạn
bắt đầu phân tách mã như thế này ra,

2423
02:00:02,070 --> 02:00:04,397
chúng tôi thậm chí có thể di chuyển ho
vào một tập tin riêng biệt?

2424
02:00:04,397 --> 02:00:05,730
Một người nào khác có thể thực hiện nó.

2425
02:00:05,730 --> 02:00:09,810
Và bạn và chương trình của bạn trở thành
rất đẹp, và rất có thể đọc được,

2426
02:00:09,810 --> 02:00:13,830
cho là, thực sự là bốn
chương trình dòng ngay tại đó.

2427
02:00:13,830 --> 02:00:16,510
>> Vì vậy, chúng ta hãy đi trước nay
và làm cho một sự thay đổi hơn.

2428
02:00:16,510 --> 02:00:19,180
Chú ý rằng nguyên mẫu của tôi
có thay đổi lên hàng đầu.

2429
02:00:19,180 --> 02:00:21,390
Vì vậy, hãy để tôi sửa chữa mà rất
Tôi không bị mắng.

2430
02:00:21,390 --> 02:00:25,580
>> Hãy ho, cho phép tôi chạy một lần ho
hơn, vẫn làm điều tương tự.

2431
02:00:25,580 --> 02:00:29,010
Nhưng bây giờ, nhận thấy chúng ta có một
thành phần cho một phiên bản cuối cùng.

2432
02:00:29,010 --> 02:00:29,940
Bạn biết những gì?

2433
02:00:29,940 --> 02:00:32,040
Tôi không muốn chỉ cần ho, nhất thiết.

2434
02:00:32,040 --> 02:00:33,802
Tôi muốn có một cái gì đó chung chung hơn.

2435
02:00:33,802 --> 02:00:34,510
Vì vậy, bạn biết những gì?

2436
02:00:34,510 --> 02:00:35,450
Tôi muốn làm điều này.

2437
02:00:35,450 --> 02:00:40,140
Tôi muốn có, giống như Scratch
không có gì, một khối nói, nhưng không chỉ

2438
02:00:40,140 --> 02:00:41,680
nói điều gì đó một số lần.

2439
02:00:41,680 --> 02:00:44,510
Tôi muốn nó nói một chuỗi rất cụ thể.

2440
02:00:44,510 --> 02:00:46,850
Và, do đó, tôi không
muốn nó để chỉ nói ho.

2441
02:00:46,850 --> 02:00:50,660
Tôi muốn nó để nói bất cứ điều gì
chuỗi được thông qua tại.

2442
02:00:50,660 --> 02:00:52,960
>> Vì vậy, để ý, tôi đã khái quát
này để bây giờ

2443
02:00:52,960 --> 02:00:56,110
nói cảm thấy như một tên tốt
cho điều này, như Scratch,

2444
02:00:56,110 --> 02:00:58,530
nhận hai đối số, không giống như Scratch.

2445
02:00:58,530 --> 02:00:59,570
Một là một chuỗi.

2446
02:00:59,570 --> 02:01:00,300
Một là một int.

2447
02:01:00,300 --> 02:01:01,130
>> Và tôi có thể chuyển đổi chúng.

2448
02:01:01,130 --> 02:01:03,713
Tôi chỉ giống như ý tưởng
nói các chuỗi đầu tiên, và sau đó

2449
02:01:03,713 --> 02:01:04,940
bao nhiêu lần sau.

2450
02:01:04,940 --> 02:01:06,970
Void có nghĩa là nó vẫn còn
không trả lại bất cứ điều gì.

2451
02:01:06,970 --> 02:01:09,428
Đây chỉ là phụ trên thị
hiệu ứng, giống như với [? Jordan,?]

2452
02:01:09,428 --> 02:01:11,240
một tác dụng phụ miệng la hét.

2453
02:01:11,240 --> 02:01:15,630
Nó vẫn còn hiện lần gì đó n,
0 lên, nhưng không phải bằng n.

2454
02:01:15,630 --> 02:01:17,540
Điều này có nghĩa là tổng số n lần.

2455
02:01:17,540 --> 02:01:19,540
Và sau đó chỉ cần in ra
bất cứ chuỗi đó là.

2456
02:01:19,540 --> 02:01:22,060
Vì vậy, tôi đã thực sự khái quát hóa
dòng mã này.

2457
02:01:22,060 --> 02:01:25,460
Vì vậy, bây giờ, làm thế nào để thực hiện
chức năng ho?

2458
02:01:25,460 --> 02:01:28,520
>> Tôi có thể làm vô hiệu ho.

2459
02:01:28,520 --> 02:01:31,501
Và tôi vẫn có thể đi như thế nào
nhiêu lần bạn muốn ho.

2460
02:01:31,501 --> 02:01:32,250
Nhưng bạn biết những gì?

2461
02:01:32,250 --> 02:01:34,240
bây giờ tôi có thể đá trái banh để nói.

2462
02:01:34,240 --> 02:01:39,540
>> Tôi có thể gọi điện nói với
từ ho, đi qua trong n.

2463
02:01:39,540 --> 02:01:43,410
Và nếu tôi muốn cũng để thực hiện,
chỉ để cho vui, một chức năng hắt hơi,

2464
02:01:43,410 --> 02:01:45,290
Tôi có thể hắt hơi một số lần.

2465
02:01:45,290 --> 02:01:50,300
Và tôi có thể giữ cho việc tái sử dụng n, vì
nhận thấy rằng m trong bối cảnh này, phạm vi

2466
02:01:50,300 --> 02:01:52,470
chỉ tồn tại trong chức năng này.

2467
02:01:52,470 --> 02:01:55,767
>> Và n trong bối cảnh này chỉ
tồn tại trong chức năng này tại đây.

2468
02:01:55,767 --> 02:01:57,600
Vì vậy, chúng tôi sẽ trở lại
nhưng vấn đề trong phạm vi.

2469
02:01:57,600 --> 02:02:04,160
Và ở đây, tôi chỉ cần đi để nói,
achoo, và sau đó n lần, dấu chấm phẩy.

2470
02:02:04,160 --> 02:02:07,340
>> Và bây giờ, tôi chỉ cần vay
các chức năng chữ ký ở đây.

2471
02:02:07,340 --> 02:02:09,290
Vì vậy ho là đúng.

2472
02:02:09,290 --> 02:02:13,090
hắt hơi Void là đúng ngay bây giờ.

2473
02:02:13,090 --> 02:02:15,390
>> Và tôi vẫn chỉ cần nói.

2474
02:02:15,390 --> 02:02:21,990
Vì vậy, tôi sẽ nói, nói
string s, int n, dấu chấm phẩy.

2475
02:02:21,990 --> 02:02:25,010
Vì vậy, tôi đã qua chế các
heck ra khỏi chương trình này.

2476
02:02:25,010 --> 02:02:26,760
>> Và điều này không
nhất thiết có nghĩa là

2477
02:02:26,760 --> 02:02:29,343
những gì bạn nên làm khi viết
thậm chí đơn giản của chương trình.

2478
02:02:29,343 --> 02:02:32,280
Lấy một cái gì đó rõ ràng
thực sự đơn giản, thực sự ngắn,

2479
02:02:32,280 --> 02:02:34,800
và tái thực hiện nó
sử dụng quá nhiều mã.

2480
02:02:34,800 --> 02:02:37,560
Nhưng bạn sẽ thực sự thấy, và trong
thời gian nhìn lại những ví dụ,

2481
02:02:37,560 --> 02:02:41,610
và nhận ra, oh, đó là những bước
chúng tôi đã thực sự khái quát,

2482
02:02:41,610 --> 02:02:43,797
đến yếu tố gì đó ra,
cho đến khi vào cuối ngày

2483
02:02:43,797 --> 02:02:45,380
mã của tôi thực sự là khá hợp lý.

2484
02:02:45,380 --> 02:02:48,960
Bởi vì nếu tôi muốn ho ba
lần sau đó hắt hơi ba lần,

2485
02:02:48,960 --> 02:02:53,420
Tôi chỉ đơn giản là đi chạy lại này,
chương trình thực hiện ho, và chạy ho.

2486
02:02:53,420 --> 02:02:56,620
Và tôi có ba ho
và ba hắt hơi.

2487
02:02:56,620 --> 02:02:58,990
>> Và do đó, đây là một cơ bản
mô hình, nếu bạn muốn,

2488
02:02:58,990 --> 02:03:03,110
để làm thế nào chúng ta có thể đi về
thực sự thực hiện một chương trình.

2489
02:03:03,110 --> 02:03:06,220
Nhưng chúng ta chỉ nhìn thấy nó là bây giờ những gì
chúng tôi đã làm tất cả thời gian này,

2490
02:03:06,220 --> 02:03:09,940
và những gì một số các mảnh thức
đang đứng sau lệnh này đơn giản.

2491
02:03:09,940 --> 02:03:12,620
Vào cuối ngày, chúng tôi đã
được sử dụng Clang như trình biên dịch của chúng tôi.

2492
02:03:12,620 --> 02:03:14,494
Chúng tôi đã viết mã nguồn
mã, chuyển đổi nó

2493
02:03:14,494 --> 02:03:15,820
qua Clang thành mã máy.

2494
02:03:15,820 --> 02:03:18,540
>> Và chúng tôi đã được sử dụng làm chỉ
để tạo điều kiện cho các tổ hợp phím của chúng tôi để

2495
02:03:18,540 --> 02:03:23,740
rằng chúng ta không cần phải nhớ
những câu thần chú của Clang chính nó.

2496
02:03:23,740 --> 02:03:25,640
Nhưng những gì đang làm thực sự đang làm gì?

2497
02:03:25,640 --> 02:03:27,750
Và, lần lượt, những gì là
Clang thực sự đang làm gì?

2498
02:03:27,750 --> 02:03:31,790
>> Nó chỉ ra, mặc dù chúng tôi đã đơn giản hóa
thảo luận ngày hôm nay bằng cách nói,

2499
02:03:31,790 --> 02:03:36,090
bạn lấy mã nguồn, vượt qua nó như
đầu vào cho một trình biên dịch, mang đến cho bạn

2500
02:03:36,090 --> 02:03:38,750
đầu ra của máy
mã, hóa ra có của

2501
02:03:38,750 --> 02:03:40,420
một vài bước khác nhau trong đó.

2502
02:03:40,420 --> 02:03:44,940
Và biên dịch sẽ xảy ra là ô
hạn cho một bó toàn bộ các bước.

2503
02:03:44,940 --> 02:03:46,970
Nhưng chúng ta hãy chỉ trêu chọc
ra điều này thực sự nhanh chóng.

2504
02:03:46,970 --> 02:03:51,070
>> Nó chỉ ra rằng chúng tôi đã làm
nhiều điều mỗi khi tôi chạy một chương trình,

2505
02:03:51,070 --> 02:03:53,990
hoặc mỗi khi tôi biên dịch chương trình ngày hôm nay.

2506
02:03:53,990 --> 02:03:58,020
Vì vậy, tiền xử lý đề cập đến
này-- bất cứ điều gì trong một chương trình C,

2507
02:03:58,020 --> 02:04:01,720
như chúng ta sẽ thấy một lần nữa và một lần nữa,
bắt đầu với biểu tượng băm này,

2508
02:04:01,720 --> 02:04:06,320
hoặc biểu tượng hashtag ở đây, có nghĩa là
đó là một chỉ thị tiền xử lý.

2509
02:04:06,320 --> 02:04:10,330
Điều đó có nghĩa, trong trường hợp này, hey
máy tính, làm điều gì đó với tập tin này

2510
02:04:10,330 --> 02:04:12,430
trước khi bạn thực sự biên dịch mã của riêng tôi.

2511
02:04:12,430 --> 02:04:18,220
>> Trong trường hợp này, băm bao gồm là,
về cơ bản, cách nói của C,

2512
02:04:18,220 --> 02:04:22,325
hey máy tính, hãy lấy các nội dung
của CS50.h và dán chúng ở đây.

2513
02:04:22,325 --> 02:04:25,170
Hey máy tính, hãy lấy các
nội dung của tiêu chuẩn IO.h,

2514
02:04:25,170 --> 02:04:27,690
bất cứ nơi nào mà là trên
ổ cứng, dán nó ở đây.

2515
02:04:27,690 --> 02:04:30,390
Vì vậy, những sự việc xảy ra
đầu tiên trong quá trình tiền xử lý.

2516
02:04:30,390 --> 02:04:31,880
>> Và Clang làm tất cả những điều này cho chúng tôi.

2517
02:04:31,880 --> 02:04:33,510
Và nó có phải nó như vậy darn
nhanh chóng, bạn thậm chí không

2518
02:04:33,510 --> 02:04:35,000
thấy bốn điều khác biệt xảy ra.

2519
02:04:35,000 --> 02:04:37,100
Nhưng đó là bước đầu tiên như vậy.

2520
02:04:37,100 --> 02:04:38,560
>> Điều gì thực sự xảy ra tiếp theo?

2521
02:04:38,560 --> 02:04:41,320
Vâng, chính thức tiếp theo
bước được biên dịch.

2522
02:04:41,320 --> 02:04:43,385
Và nó chỉ ra rằng
biên soạn một chương trình

2523
02:04:43,385 --> 02:04:47,060
kỹ thuật có nghĩa là đi từ
mã nguồn, những thứ chúng tôi đã

2524
02:04:47,060 --> 02:04:50,890
đã viết ngày hôm nay, một cái gì đó
được gọi là mã lắp ráp, một cái gì đó

2525
02:04:50,890 --> 02:04:52,260
trông hơi khác một chút.

2526
02:04:52,260 --> 02:04:54,050
>> Và, trên thực tế, chúng ta có thể thấy điều này thật nhanh.

2527
02:04:54,050 --> 02:04:56,890
Hãy để tôi thực sự đi vào IDE của tôi.

2528
02:04:56,890 --> 02:05:01,050
Hãy để tôi đi trước và hello.c mở,
là chương trình đầu tiên mà chúng ta

2529
02:05:01,050 --> 02:05:02,120
bắt đầu ngày hôm nay.

2530
02:05:02,120 --> 02:05:07,130
Và hãy để tôi đi trước và chạy Clang một
chút khác nhau, Clang-s, hello.c,

2531
02:05:07,130 --> 02:05:10,720
mà thực sự đi
đưa cho tôi một tập tin hello.s.

2532
02:05:10,720 --> 02:05:13,330
>> Và chúng ta sẽ chẳng bao giờ
một lần nữa nhìn thấy loại mã này.

2533
02:05:13,330 --> 02:05:16,030
Nếu bạn có một mức độ thấp hơn
hệ thống lớp học như CS61,

2534
02:05:16,030 --> 02:05:17,920
bạn sẽ nhìn thấy rất nhiều hơn
của loại mã này.

2535
02:05:17,920 --> 02:05:20,020
Nhưng đây là ngôn ngữ lắp ráp.

2536
02:05:20,020 --> 02:05:25,050
Đây là X86 ngữ
rằng CPU đang tiềm ẩn

2537
02:05:25,050 --> 02:05:27,460
CS50 IDE thực sự hiểu.

2538
02:05:27,460 --> 02:05:30,060
>> Và khó hiểu như nó
nhìn, nó là một cái gì đó

2539
02:05:30,060 --> 02:05:32,180
các máy tính hiểu được khá tốt.

2540
02:05:32,180 --> 02:05:33,790
Sub q, đây là một trừ.

2541
02:05:33,790 --> 02:05:34,660
Có phong trào.

2542
02:05:34,660 --> 02:05:38,730
>> Có đang gọi của chức năng ở đây,
x oring, một phong trào, một add, một cửa sổ pop,

2543
02:05:38,730 --> 02:05:39,430
Sự trở về, sự trở lại.

2544
02:05:39,430 --> 02:05:41,850
Vì vậy, có một số rất
hướng dẫn mức thấp

2545
02:05:41,850 --> 02:05:44,280
mà CPU hiểu rằng
Tôi ám chỉ trước đó.

2546
02:05:44,280 --> 02:05:46,100
Đó là những gì Intel Inside.

2547
02:05:46,100 --> 02:05:48,030
>> Có mô hình
số không và những người

2548
02:05:48,030 --> 02:05:54,800
bản đồ cho những lời lẽ arcanely, nhưng
phần nào cũng được đặt tên, hướng dẫn,

2549
02:05:54,800 --> 02:05:55,780
vậy để nói chuyện.

2550
02:05:55,780 --> 02:05:57,780
Đó là những gì sẽ xảy ra khi
bạn biên dịch mã của bạn.

2551
02:05:57,780 --> 02:06:01,560
Bạn sẽ có được lắp ráp
ngôn ngữ ra khỏi nó, mà

2552
02:06:01,560 --> 02:06:07,680
có nghĩa là bước thứ ba là để lắp ráp
mã lắp ráp vào, cuối cùng,

2553
02:06:07,680 --> 02:06:12,080
máy số không code-- và những người thân, không phải là
văn bản mà chúng ta chỉ thấy một khoảnh khắc trước.

2554
02:06:12,080 --> 02:06:16,370
>> Vì vậy, trước khi chế biến không mà tìm
và thay thế, và một vài thứ khác.

2555
02:06:16,370 --> 02:06:19,430
Biên dịch mất nguồn của bạn
code từ C, mã nguồn

2556
02:06:19,430 --> 02:06:21,980
mà chúng tôi đã viết, để lắp ráp
mã mà chúng ta chỉ cần liếc nhìn.

2557
02:06:21,980 --> 02:06:25,170
Lắp mất assembly
mã để zero và những người thân

2558
02:06:25,170 --> 02:06:27,680
mà CPU thực sự sẽ
hiểu vào cuối ngày.

2559
02:06:27,680 --> 02:06:30,630
Và liên kết là bước cuối cùng
điều đó xảy ra cho đây-- một lần nữa,

2560
02:06:30,630 --> 02:06:32,830
quá nhanh, chúng tôi thậm chí không
notice-- mà nói,

2561
02:06:32,830 --> 02:06:35,460
hey máy tính, mất tất cả
các số không và những người

2562
02:06:35,460 --> 02:06:39,750
kết quả từ biên dịch mã của David,
và chức năng chính của mình trong trường hợp này.

2563
02:06:39,750 --> 02:06:42,160
>> Và hey máy tính, hãy lấy
tất cả các số không và những người thân

2564
02:06:42,160 --> 02:06:45,180
rằng các nhân viên CS50 viết
bên trong các thư viện CS50.

2565
02:06:45,180 --> 02:06:46,440
Trộn những người ở với David.

2566
02:06:46,440 --> 02:06:49,648
Và hey máy tính, hãy lấy tất cả các số không
và những cái mà người khác đã viết năm

2567
02:06:49,648 --> 02:06:50,470
trước đây cho printf.

2568
02:06:50,470 --> 02:06:52,880
Và thêm những thành
toàn bộ điều, vì vậy mà chúng tôi đã

2569
02:06:52,880 --> 02:06:55,870
có số không và những người thân của tôi,
số không và những nhân viên của CS50,

2570
02:06:55,870 --> 02:06:58,370
các số không printf và những người thân,
và bất cứ điều gì chúng ta đang sử dụng.

2571
02:06:58,370 --> 02:07:03,410
>> Họ tất cả được kết hợp với nhau thành một
chương trình gọi là, trong trường hợp này, xin chào.

2572
02:07:03,410 --> 02:07:06,141
Vì vậy, từ nay về sau, chúng tôi sẽ chỉ
sử dụng biên dịch từ.

2573
02:07:06,141 --> 02:07:09,390
Và chúng tôi sẽ đưa cho các cấp rằng khi
chúng ta nói, biên dịch chương trình của bạn, nó có nghĩa là,

2574
02:07:09,390 --> 02:07:11,849
hey làm trước khi chế biến,
lắp ráp, và liên kết.

2575
02:07:11,849 --> 02:07:14,890
Nhưng có thực sự là một số công cụ ngon ngọt
xảy ra ở đó bên dưới mui xe.

2576
02:07:14,890 --> 02:07:16,723
Và đặc biệt là nếu bạn
tò mò một thời gian,

2577
02:07:16,723 --> 02:07:18,900
bạn có thể bắt đầu chọc
xung quanh ở mức thấp này.

2578
02:07:18,900 --> 02:07:22,660
Nhưng hiện nay, nhận ra rằng
trong takeaways cho ngày hôm nay

2579
02:07:22,660 --> 02:07:26,420
khá đơn giản là
bắt đầu của một quá trình,

2580
02:07:26,420 --> 02:07:29,700
nhận được thoải mái với
một cái gì đó giống như hello thế giới.

2581
02:07:29,700 --> 02:07:32,575
Thật vậy, hầu hết những gì chúng ta làm ngày hôm nay
chắc chắn sẽ không chìm trong siêu nhanh.

2582
02:07:32,575 --> 02:07:34,491
Và nó sẽ mất một
thời gian, và một số thực hành.

2583
02:07:34,491 --> 02:07:36,864
Và tỷ lệ cược là, bạn sẽ sắp xếp
của muốn nhấn bàn phím của bạn

2584
02:07:36,864 --> 02:07:37,780
hay la hét vào màn hình.

2585
02:07:37,780 --> 02:07:38,880
Và tất cả đó là OK.

2586
02:07:38,880 --> 02:07:41,320
Mặc dù, có lẽ cố gắng không để
làm điều đó trong thư viện rất nhiều.

2587
02:07:41,320 --> 02:07:43,820
>> Và cuối cùng, bạn sẽ
được thể tuy nhiên, để bắt đầu

2588
02:07:43,820 --> 02:07:47,580
nhìn thấy các mô hình, cả trong mã tốt
mà bạn đã viết và sai lầm

2589
02:07:47,580 --> 02:07:48,370
mà bạn đã thực hiện.

2590
02:07:48,370 --> 02:07:51,965
Và giống như quá trình
trở thành một TF hoặc một CA là như thế,

2591
02:07:51,965 --> 02:07:54,590
bạn sẽ bắt đầu để có được tốt hơn và
tốt hơn khi nhìn thấy những người mẫu,

2592
02:07:54,590 --> 02:07:56,774
và chỉ cần giải quyết của bạn
vấn đề của riêng cuối cùng.

2593
02:07:56,774 --> 02:07:59,940
Trong khi đó, sẽ có rất nhiều
của chúng tôi để cho vay hỗ trợ bạn, và giúp bạn có

2594
02:07:59,940 --> 02:08:00,481
thông qua này.

2595
02:08:00,481 --> 02:08:02,450
Và trong khi write-up
cho tất cả các vấn đề

2596
02:08:02,450 --> 02:08:04,366
bạn sẽ được hướng dẫn
tất cả các lệnh

2597
02:08:04,366 --> 02:08:08,330
mà tôi chắc chắn biết từ
rất nhiều thực hành của bây giờ,

2598
02:08:08,330 --> 02:08:10,380
nhưng có thể đã bay
trên đầu của một người cho bây giờ.

2599
02:08:10,380 --> 02:08:11,580
Và đó là hoàn toàn tốt đẹp.

2600
02:08:11,580 --> 02:08:14,230
>> Nhưng, cuối cùng, bạn sẽ
để bắt đầu để xem các mẫu xuất hiện.

2601
02:08:14,230 --> 02:08:17,260
Và một khi bạn vượt qua tất cả các
chi tiết ngu ngốc, giống như dấu ngoặc đơn,

2602
02:08:17,260 --> 02:08:19,710
và dấu ngoặc nhọn, và dấu chấm phẩy,
và các công cụ, thẳng thắn,

2603
02:08:19,710 --> 02:08:22,360
đó không phải là ở tất cả
trí tuệ thú vị.

2604
02:08:22,360 --> 02:08:25,690
Và nó không phải là mục tiêu của
dùng bất cứ lớp giới thiệu.

2605
02:08:25,690 --> 02:08:27,410
Đó là ý tưởng rằng sẽ có vấn đề.

2606
02:08:27,410 --> 02:08:29,659
>> Đó là các vòng, và
điều kiện, và các chức năng,

2607
02:08:29,659 --> 02:08:33,552
và mạnh mẽ hơn các khái niệm trừu tượng,
và thanh toán của các mã,

2608
02:08:33,552 --> 02:08:36,510
và thiết kế tốt, và tốt
phong cách, và cuối cùng là đúng đắn

2609
02:08:36,510 --> 02:08:40,330
mã của bạn, đó là cuối cùng
đi quan trọng nhất.

2610
02:08:40,330 --> 02:08:43,925
Vì vậy, tuần tới, chúng tôi sẽ có những
ý tưởng mà chúng tôi lần đầu tiên thấy trong Scratch

2611
02:08:43,925 --> 02:08:45,800
và bây giờ đã dịch
C. Và chúng ta sẽ bắt đầu

2612
02:08:45,800 --> 02:08:48,740
để giới thiệu đầu tiên của
lĩnh thế giới thực của khóa học.

2613
02:08:48,740 --> 02:08:53,140
>> Chúng tôi sẽ tập trung vào thế giới của an ninh,
và đặc biệt hơn mật mã,

2614
02:08:53,140 --> 02:08:54,980
nghệ thuật xáo trộn thông tin.

2615
02:08:54,980 --> 02:08:57,000
Và trong số những người đầu tiên
vấn đề bản thân bạn

2616
02:08:57,000 --> 02:08:59,840
sẽ nhận được để viết ngoài
chơi với một số cú pháp

2617
02:08:59,840 --> 02:09:02,880
và giải quyết một số logic
vấn đề, cuối cùng trước khi dài,

2618
02:09:02,880 --> 02:09:06,960
là để thực sự tranh giành, hoặc mã hóa,
và cuối cùng giải mã thông tin.

2619
02:09:06,960 --> 02:09:09,470
Và tất cả mọi thứ chúng tôi đã thực hiện
ngày hôm nay, sẽ khá thấp

2620
02:09:09,470 --> 02:09:12,190
level, sẽ cho phép
chúng tôi để có một, và một,

2621
02:09:12,190 --> 02:09:16,550
và hơn một bước so với đối
viết mã thú vị nhất chưa.

2622
02:09:16,550 --> 02:09:18,050
>> Vì vậy, thêm vào đó vào tuần tới.

2623
02:09:18,050 --> 02:09:20,834

2624
02:09:20,834 --> 02:09:21,762
>> [XEM LẠI VIDEO]

2625
02:09:21,762 --> 02:09:22,690

2626
02:09:22,690 --> 02:09:25,006
>> -Điều Gì bạn có thể cho tôi biết về
lần cuối cùng bạn nhìn thấy anh ta?

2627
02:09:25,006 --> 02:09:29,041

2628
02:09:29,041 --> 02:09:30,040
-Điều Gì tôi có thể nói, thực sự?

2629
02:09:30,040 --> 02:09:33,500

2630
02:09:33,500 --> 02:09:38,340
Ý tôi là, nó giống như bất kỳ khác
diễn tập chuẩn bị sản xuất,

2631
02:09:38,340 --> 02:09:43,510
ngoại trừ có một điều gì ông nói
ở cuối câu mà bị mắc kẹt với tôi.

2632
02:09:43,510 --> 02:09:47,810

2633
02:09:47,810 --> 02:09:49,640
>> -Đây Là CS50.

2634
02:09:49,640 --> 02:09:52,440

2635
02:09:52,440 --> 02:09:55,190
>> -đó Là cắt tất cả mọi người,
việc tuyệt vời trên diễn tập.

2636
02:09:55,190 --> 02:09:56,070
>> trưa -đó không?

2637
02:09:56,070 --> 02:09:57,986
>> -Vâng, Bạn và tôi có thể
lấy một chiếc bánh sandwich trong một chút.

2638
02:09:57,986 --> 02:10:01,380
Hãy để tôi chỉ Phỏng vấn với
David thực sự nhanh chóng.

2639
02:10:01,380 --> 02:10:02,160
David?

2640
02:10:02,160 --> 02:10:04,260
David?

2641
02:10:04,260 --> 02:10:06,110
>> [END PLAYBACK]

