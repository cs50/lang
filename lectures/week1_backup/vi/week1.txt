[NHẠC] DAVID J. Malan: Được rồi, đây là CS50. Và đây là tuần một. Vì vậy, nhớ lại rằng thời gian qua trong tuần không, chúng tôi tập trung vào tư duy tính toán. Và chúng tôi chuyển từ đó đến Scratch, một lập trình đồ họa ngôn ngữ từ bạn bè của chúng tôi tại Media Lab của MIT. 

Và với Scratch, đã chúng tôi khám phá ý tưởng như chức năng và điều kiện, và vòng lặp, và các biến, và thậm chí sự kiện, và chủ đề, và nhiều hơn nữa. Và hôm nay, chúng ta sẽ tiếp tục sử dụng những ý tưởng, và thực sự đưa chúng cho cấp, nhưng dịch chúng sang một ngôn ngữ được gọi là C. Bây giờ, C là một ngôn ngữ truyền thống hơn. Đó là một mức độ thấp hơn ngôn ngữ, nếu bạn muốn. 

Nó hoàn toàn là văn bản. Và do đó, ở cái nhìn đầu tiên, đó là tất cả sẽ trông khá khó hiểu nếu bạn đã không bao giờ được lập trình trước. Chúng ta sẽ có dấu chấm phẩy và dấu ngoặc, và dấu ngoặc nhọn, và nhiều hơn nữa. Nhưng nhận ra rằng mặc mặc dù cú pháp về để tìm một chút quen thuộc cho hầu hết các bạn, xem quá khứ đó. Và cố gắng nhìn thấy những ý tưởng đó là, thực sự, quen thuộc, bởi vì ở đây trong tuần một điều gì chúng tôi sẽ bắt đầu làm là để so sánh, Ban đầu, Scratch so với C. 

Vì vậy, ví dụ, nhớ lại rằng khi chúng ta thực hiện đầu tiên của chương trình của chúng tôi thời gian qua, chúng tôi đã có một khối mà nhìn một chút gì đó như này-- khi lá cờ màu xanh lá cây nhấp, và sau đó chúng tôi đã có một mảnh ghép hoặc nhiều bên dưới nó, trong trường hợp này, nói, xin chào thế giới. Vì vậy, thực sự, trong Scratch, khi tôi nhấp vào lá cờ màu xanh lá cây để chạy chương trình của tôi, vì vậy để nói chuyện, đây là những các khối có được thực thi, hoặc chạy. Và, đặc biệt, Scratch cho biết, hello, thế giới. 

Bây giờ, tôi có thể đã xác định Nói cách khác nhau ở đây. Nhưng chúng ta sẽ thấy rằng, trên thực tế, nhiều các blocks-- và quả thật, trong C nhiều functions-- có thể parametrized hoặc tùy chỉnh để làm những việc khác nhau. Trong thực tế, trong C nếu chúng ta muốn chuyển đổi, bây giờ, chương trình Scratch này đến các ngôn ngữ này, chúng ta sẽ viết thư chút gì đó như thế này. 

Cấp, có một số không quen thuộc cú pháp có nhiều khả năng, int, và dấu ngoặc đơn và trống không. Nhưng printf-- mặc dù bạn sẽ nghĩ rằng nó sẽ chỉ được in. Nhưng in có nghĩa là in định dạng, như chúng ta sẽ sớm thấy. Điều này nghĩa là sẽ in để màn hình bất cứ điều gì là bên trong những dấu ngoặc đơn, mà tất nhiên trong trường hợp này là, xin chào thế giới. 

Nhưng bạn sẽ nhận thấy một số khác cú pháp, một số dấu ngoặc kép, rằng các dấu ngoặc đơn ở cuối, dấu chấm phẩy và muốn. Vì vậy, có một chút trên không, vậy để nói chuyện, cả hai nhận thức và cú pháp, mà chúng ta đang đi phải nhớ trước khi dài. Nhưng nhận ra rằng với thực hành, này sẽ bắt đầu nhảy vào bạn. 

Trong thực tế, chúng ta hãy tập trung vào một trong những chức năng specifically-- trong trường hợp này, chào thế giới. Vì vậy, nói là chức năng. Xin chào thế giới là tham số của nó, hoặc đối số, tuỳ biến của nó. 

Và sự tương đương trong C chỉ là sẽ là một trong những dòng này ở đây, nơi printf là tương đương với, nói, các chuỗi trích dẫn đôi, hello thế giới là tương đương, tất nhiên, để những gì trong hộp màu trắng đó. Và n xuyệc ngược, mặc dù một chút kỳ lạ và vắng mặt từ Scratch, chỉ đơn giản là sẽ có hiệu lực chúng tôi sẽ thấy trong một máy tính, như máy Mac của tôi hoặc một máy tính, chỉ di chuyển con trỏ đến dòng kế tiếp. Nó giống như đánh Enter trên bàn phím của bạn. 

Vì vậy, chúng ta sẽ thấy rằng một lần nữa trước khi dài. Nhưng trước tiên, chúng ta hãy nhìn vào điều này Ví dụ khác trong trường hợp của các vòng. Chúng tôi đã mãi mãi vòng này thời gian qua, đó là một loạt các mảnh ghép mà đã làm một cái gì đó theo nghĩa đen forever-- trong trường hợp này, nói, thế giới hello, hello thế giới, hello thế giới, xin chào thế giới. Vì vậy, nó là một vòng lặp vô hạn của thiết kế. 

Trong C, nếu chúng ta muốn thực hiện điều này cùng ý tưởng, chúng ta có thể chỉ đơn giản là làm điều này. Trong khi sự thật, printf chào world-- nay trong khi, chỉ ngữ nghĩa, loại gợi lên ý tưởng làm một cái gì đó một lần nữa, và một lần nữa, và một lần nữa, và trong bao lâu? Vâng, thu hồi true-- đó đúng là chỉ trên hoặc một. 

Và sự thật là, tất nhiên, luôn luôn đúng. Vì vậy, nó là loại một vô nghĩa tuyên bố chỉ để nói sự thật. Nhưng thực sự, đây là cố ý, bởi vì nếu thật sự chỉ là luôn luôn đúng, hơn trong khi sự thật chỉ ngụ ý, nếu một chút gián tiếp, rằng các dòng mã sau đây ở giữa những dấu ngoặc nhọn nên chỉ cần thực hiện một lần nữa, và một lần nữa, và một lần nữa, và không bao giờ thực sự dừng lại. 

Nhưng nếu bạn muốn của bạn vòng lặp dừng lại, như chúng ta làm lần trước với một cái gì đó như này, lặp lại 50 lần sau, trong C chúng ta có thể làm tương tự với những gì gọi là cho loop-- từ khóa không phải là thời gian, nhưng đối. Và sau đó chúng tôi có một số cú pháp mới đây, với int i bằng 0, tôi ít hơn 50, i ++. Và chúng tôi sẽ trở lại đó. Nhưng điều này chỉ đơn giản là làm thế nào chúng ta sẽ dịch các tập hợp các khối Scratch cho một tập các dòng C mã. 

Trong khi đó, xem xét các biến. Và, trên thực tế, chúng ta chỉ nhìn thấy một trong một thời gian trước đây. Và trong trường hợp của Scratch, nếu chúng ta muốn khai báo một biến gọi là i i là số nguyên, chỉ một số, và chúng tôi muốn đặt nó vào một số giá trị, chúng tôi sẽ sử dụng màu cam này chặn đây-- thiết lập i đến 0. 

Và chúng ta sẽ thấy ngày hôm nay và xa hơn nữa, giống như tuần trước, lập trình viên làm hầu như luôn luôn bắt đầu đếm từ số không, thực sự theo quy ước. Nhưng cũng vì thu hồi từ thảo luận của chúng ta về nhị phân, số nhỏ nhất có thể đại diện với bất kỳ số lượng các bit chỉ sẽ là 0 chính nó. Và vì vậy chúng tôi sẽ thường bắt đầu khởi tạo thậm chí biến của chúng tôi để 0. 

Và trong C để làm như vậy, chúng ta sẽ nói int cho số nguyên, tôi chỉ theo quy ước. Tôi có thể gọi là biến này bất cứ điều gì tôi muốn, giống như trong Scratch. Và sau đó bằng 0 chỉ chuyển nhượng giá trị 0 từ bên phải và đặt nó vào biến, hoặc container lưu trữ ở đó, bên trái. Và dấu chấm phẩy như chúng tôi sẽ see-- và chúng tôi đã nhìn thấy một vài trong số những already-- chỉ có nghĩa là kết thúc của tư tưởng. Tiến hành để làm cái gì khác trên dòng tiếp theo. 

Bây giờ, những gì về các biểu thức Boolean? Nhớ lại rằng trong Scratch, đây là những biểu thức đó là một trong hai thành sự thật hoặc câu hỏi false--, thực sự, đó là đúng hoặc sai. Vì vậy, trong trường hợp của Scratch, chúng ta có thể đặt một câu hỏi đơn giản như thế này, là tôi ít hơn 50? Vì vậy, tôi, một lần nữa, là một số nguyên. Có lẽ chúng ta đang sử dụng nó trong một chương trình Scratch để theo dõi điểm số hay đại loại thế. Vì vậy, cú pháp này ở đây trong Scratch chỉ có nghĩa là tôi ít hơn 50? Vâng, may mắn, cái gì là đơn giản trong C. Và để dịch, này, chúng ta sẽ chỉ đơn giản nói rằng tôi ít 50, sử dụng phím quen thuộc trên bàn phím của bạn. 

Trong khi đó, nếu bạn muốn nói điều gì đó tổng quát hơn, như, tốt, là x ít hơn y mà mỗi của x và y là tự biến? Chúng tôi có thể làm điều tương tự trong C, miễn là chúng tôi đã tạo ra các biến này đã. Và chúng ta sẽ thấy làm thế nào để làm điều đó trước khi dài. Chúng tôi chỉ đơn giản là nói ít hơn x y. 

Vì vậy, bạn đang bắt đầu thấy một số điểm tương đồng. Và những folks những người làm Scratch là chắc chắn lấy cảm hứng từ một số trong những ý tưởng cơ bản. Và bạn sẽ thấy loại này cú pháp trong nhiều languages-- không chỉ Scratch, không chỉ C, nhưng Python, và JavaScript, và ngôn ngữ khác vẫn còn. 

Hãy xem xét xây dựng khác từ C, khái niệm về một điều kiện, làm một cái gì đó có điều kiện. Nếu một cái gì đó là sự thật, làm được điều này. Nếu cái gì khác là sự thật, làm điều đó. Đó là loại của chương trình tương đương với một ngã ba đường. Có lẽ đó là một hai chiều ngã ba, ba chiều ngã ba, hoặc nhiều hơn. Và trong Scratch, chúng ta có thể có nhìn thấy một cái gì đó như thế này. 

Vì vậy, con này một lớn. Nhưng xem xét tương đối đơn giản của logic. Nếu x là ít hơn so với năm trước, sau đó nói rằng x là ít hơn y, khác nếu x lớn hơn y, sau đó nói x lớn hơn y. Và sau đó, một cách logic, nếu bạn nghĩ lại Scratch hay chỉ là trực giác của con người của riêng bạn, tốt, nếu x là không lớn hơn y, và x không phải là ít hơn so với y, sau đó tất nhiên x sẽ là bằng y. Vì vậy, trong trường hợp này, bởi làm tổ những khối Scratch, chúng ta có thể đạt được một ba cách ngã ba đường? 

Trong khi đó, nếu chúng ta muốn làm điều đó trong C, nó được cho là nhìn một chút simpler-- ít nhất một khi bạn làm quen với cú pháp. Nếu x là ít hơn so với năm trước, printf x là ít hơn so với năm ngoái. Else if x lớn hơn y, printf x lớn hơn y. Khác printf x bằng y-- và, một lần nữa, với những dấu chéo ngược kết thúc chỉ đối với những dây chuyền mới để nếu bạn đã chạy loại chương trình nó sẽ chỉ di chuyển con trỏ của bạn cuối cùng đến dòng kế tiếp của màn hình. 

Bây giờ, trong khi đó Scratch có khác tính năng phức tạp hơn, chỉ một số trong đó chúng ta sẽ ban đầu chuyển sang một thế giới của C. Và một trong số đó là được gọi là một danh sách trong Scratch. Và đây là một đặc biệt loại biến cho phép bạn lưu trữ nhiều thứ trong nó trở lại, trở lại, trở lại, để trở lại. 

Trong C, nó không có danh sách, mỗi gia nhập, nhưng một cái gì đó mà nói chung là hơn gọi là mảng, mặc dù chúng tôi sẽ quay lại sau học kỳ này để nhìn vào một cái gì đó được gọi là một danh sách, hoặc thực sự là một danh sách liên kết. Nhưng hiện nay, gần nhất tương đương trong C cho chúng tôi sẽ là một cái gì đó gọi là mảng. Và một mảng chỉ đơn giản là một là loại đặc biệt của biến cho phép bạn lưu trữ dữ liệu trở lại, trở lại, trở lại, trở lại. 

Và, quả thật vậy, trong Scratch, nếu chúng ta muốn truy cập các yếu tố đầu tiên của một mảng hoặc một list-- và tôi sẽ gọi nó, theo quy ước, argv, lập luận vector, nhưng thêm vào đó trước khi dài. Nếu tôi muốn có được ở các phần tử đầu tiên argv, trong thế giới của Scratch bạn thực sự làm thường bắt đầu đếm từ 1. 

Và vì vậy tôi có thể nhận được khoản 1 argv. Đó chỉ là cách MIT thực hiện khái niệm về danh sách. Nhưng trong C, tôi sẽ đơn giản hơn chỉ cần nói, argv, mà lại là tên của tôi list-- hoặc để được rõ ràng, một mảng. Và nếu tôi muốn là người đầu tiên yếu tố, tôi sẽ sử dụng dấu ngoặc vuông, mà bạn có thể không thường xuyên được sử dụng theo một bàn phím. 

Nhưng 0 chỉ có nghĩa là, làm cho tôi đầu tiên. Vì vậy, vào dịp và như thời gian trôi qua, chúng ta sẽ để bắt đầu thấy những phân đôi giữa Scratch và C, theo đó Scratch sử dụng một. Chúng tôi trong C sử dụng 0 ở đây. Nhưng bạn sẽ nhanh chóng thấy một khi bạn hiểu nền móng của mỗi ngôn ngữ, mà những điều này bắt đầu để có được tất cả các chi tiết quen thuộc thông qua thực hành và thực hành. 

Vì vậy, hãy thực sự nhìn tại một chương trình. Đây sẽ là lần đầu tiên của C của chúng tôi mã nguồn cho chương trình hoàn thiện. Và chương trình chúng ta sẽ cung cấp để xem xét là một trong đó là tương đương cho rằng mảnh Scratch trước đó. 

Vì vậy, ở đây, chúng tôi có những gì cho là chương trình đơn giản C bạn có thể viết rằng thực sự làm một cái gì đó. Bây giờ, chúng ta sẽ xem qua, cho bây giờ, đã bao gồm, io.h tiêu chuẩn, và các góc ngoặc, và int và trống không, và các dấu ngoặc nhọn, và như thế. 

Và chúng ta chỉ tập trung vào gì, ít nhất là trực giác, có thể nhảy vào bạn rồi. Trong thực tế, chính, tôi không nhất thiết phải biết điều này là gì, nhưng giống như Scratch có khi nào lá cờ màu xanh lá cây nhấp mảnh ghép, cũng vậy C là một ngôn ngữ lập trình có một mảnh chính của mã đó được thực hiện theo mặc định. Và thực sự, nó là nghĩa đen sẽ được gọi là chính. 

Vì vậy, chính là một chức năng. Và đó là một chức năng đặc biệt mà tồn tại trong C mà khi bạn chạy một chương trình, nó là chính mà được chạy bởi mặc định. Trong thế giới của Scratch, nó thường là khi lá cờ màu xanh lá cây nhấp đó đã chạy theo mặc định. 

Trong khi đó, chúng tôi đã nhìn thấy điều này trước đây, printf hoặc in định dạng, đó là sẽ là một chức năng mà đi kèm với C, cùng với một bó toàn bộ của người khác, rằng sẽ từ thời gian và thời gian một lần nữa, để làm chính xác như tên gọi của nó cho thấy, in cái gì. Những gì chúng tôi muốn in? Vâng, chúng ta sẽ thấy rằng bởi nhân vật kèm theo như these-- thế giới hello, backslash n trong ngoặc kép, chúng ta có thể nói chính xác printf in cái gì trên màn hình. 

Nhưng để làm được đó, chúng tôi không may cần phải thực hiện một điều gì đó đã khó hiểu với con người chúng ta, nhưng ít nhất nó hơi readable-- sắc nét bao gồm, io.h chuẩn, int, chính, void, printf, tất cả các phép thuật câu thần chú, chúng tôi chỉ nhìn thấy trên màn hình. Nhưng chúng tôi thực sự phải đi phức tạp hơn nhiều. Đầu tiên chúng ta cần để dịch mã mà chúng tôi viết thành mã máy. Và nhớ lại từ tuần trước rằng máy móc, ít nhất là những người chúng tôi biết ở đây, vào cuối ngày duy nhất hiểu số không và những người thân. 

Và Thiên Chúa của tôi, nếu chúng ta đã phải viết những số không và những người thực sự chương trình, nó sẽ rất, rất nhanh chóng mất những niềm vui trong bất cứ điều gì. Nhưng hóa ra, mỗi tuần cuối cùng, rằng những mô hình số không và những người thân chỉ có ý nghĩa đặc biệt. Trong bối cảnh nhất định, họ có thể có nghĩa là con số. 

Trong một số hoàn cảnh, họ có thể có nghĩa là chữ cái, hoặc màu sắc, hoặc số bất kỳ trừu tượng hóa khác có thuận. Nhưng cũng giống như máy tính của bạn có một CPU, đơn vị xử lý trung tâm, hoặc bộ não bên trong máy tính của bạn. Nó thường là Intel bên trong, bởi vì đó là một trong những công ty lớn nhất mà làm cho CPU cho máy tính. 

Vâng, CPU Intel và những người khác chỉ đơn giản là đã quyết định trước rằng một số mô hình của số không và những người có trách nhiệm có nghĩa là những việc cụ thể. Một số mô hình của số không và những người thân sẽ có nghĩa là, in này đến màn hình, hoặc thêm hai con số này, hoặc trừ hai con số này, hoặc di chuyển này mảnh dữ liệu từ bộ nhớ máy tính của tôi trên đây, hoặc bất kỳ số lượng mức rất thấp khác, nhưng cuối cùng hữu ích, hoạt động. Nhưng, may mắn thay, con người chúng ta sẽ không cần phải biết mức độ chi tiết này. Thật vậy, giống như thời gian qua, nơi chúng tôi trừu tượng hóa một lần nữa, và một lần nữa, và một lần nữa, xây dựng từ mức rất thấp nguyên thủy như số không và những người thân các khái niệm mức độ cao hơn như số và chữ cái, và màu sắc, và nhiều hơn nữa, vì vậy có thể chúng tôi là lập trình viên đứng trên vai của những người đã đi trước chúng ta và sử dụng phần mềm khác người đã viết trước đây-- cụ thể là các chương trình được gọi là trình biên dịch. 

C là một ngôn ngữ thường được biên soạn, có nghĩa là chuyển đổi từ mã nguồn thành mã máy. Đặc biệt, điều này có nghĩa được rằng nếu bạn đã có mã nguồn của bạn mã mà bạn tự viết, như chúng ta sớm sẽ chỉ trong một khoảnh khắc trên màn hình, và bạn muốn chuyển đổi nó cuối cùng là máy code-- những số không và những người chỉ Mac hoặc máy PC của bạn understands-- bạn đã có một đầu tiên thức ăn đó mã nguồn trong khi đầu vào cho một đặc biệt chương trình gọi là một trình biên dịch, đầu ra của mà chúng sẽ thấy là mã máy. Và, quả thật vậy, thời gian qua, chúng tôi đã nói chuyện về, thực sự, vào cuối ngày, giải quyết vấn đề. Bạn đã có đầu vào. Và bạn đã có kết quả đầu ra. Và bạn đã có một số loại của thuật toán ở giữa. 

Các thuật toán chắc chắn có thể được thực hiện trong phần mềm, như chúng ta đã thấy với giả tuần trước và như chúng ta sẽ thấy có mã thực tế tuần này. Và do đó, một trình biên dịch thực sự chỉ có một tập hợp các thuật toán bên trong của nó mà biết làm thế nào để chuyển đổi các từ khóa đặc biệt, như chính, và printf, và những người khác mà chúng ta vừa thấy vào các mô hình số không và những người mà Intel bên trong và các CPU thực sự hiểu. Vì vậy, làm thế nào để chúng tôi làm điều này? Nơi nào chúng ta có được một trình biên dịch? 

Hầu hết chúng ta ở đây có một máy Mac hoặc máy PC. Và bạn đang chạy Mac OS, hoặc Windows, hoặc Linux, hoặc Solaris, hoặc bất kỳ số khác các hệ điều hành. Và, quả thật vậy, chúng ta có thể đi ra ngoài vào web và tải về một trình biên dịch dành cho máy Mac hoặc máy PC của bạn cho hệ điều hành cụ thể của bạn. Nhưng tất cả chúng ta sẽ được vào các trang khác nhau, vì vậy để nói chuyện. Chúng tôi muốn có một chút cấu hình khác nhau. Và việc này sẽ không làm việc tất cả như nhau. Và, quả thật vậy, những ngày này nhiều người trong chúng ta không sử dụng phần mềm chỉ chạy trên máy tính xách tay của chúng tôi. Thay vào đó, chúng tôi sử dụng một cái gì đó giống như một trình duyệt cho phép chúng ta truy cập dựa trên web ứng dụng trong các đám mây. Và sau học kỳ này, chúng tôi sẽ làm chính xác điều đó. Chúng tôi sẽ viết các ứng dụng hay phần mềm sử dụng code-- không phải C, nhưng các ngôn ngữ khác như Python và JavaScript-- chạy trong đám mây. 

Và để làm được điều đó, chính chúng ta trong học kỳ sẽ thực sự sử dụng một đám mây dựa trên môi trường được gọi là CS50 IDE. Đây là một chương trình dựa trên web môi trường, hoặc phát triển tích hợp môi trường, IDE, đó là xây dựng trên đỉnh một số phần mềm mã nguồn mở được gọi là Cloud 9. Và chúng tôi đã thực hiện một số nghiệp vụ sư phạm đơn giản hóa để nó để ẩn các tính năng nhất định trong những tuần đầu tiên mà chúng ta không cần, sau đó bạn có thể tiết lộ họ và làm nhất bất cứ điều gì bạn muốn với môi trường. 

Và nó cho phép chúng ta nữa, để cài đặt sẵn phần mềm nào đó. Những điều như một cái gọi là CS50 thư viện, mà chúng ta sẽ sớm thấy cung cấp cho chúng tôi trong C với một số chức năng bổ sung. Vì vậy, nếu bạn đi đến cuối cùng, CS50.io, bạn sẽ được nhắc nhở để đăng nhập, và một khi bạn làm và tạo một tài khoản miễn phí, bạn sẽ có thể truy cập vào một môi trường trông khá như thế này. 

Bây giờ, điều này là ở chế độ mặc định. Mọi thứ đều tốt đẹp và sáng trên màn hình. Nhiều người trong chúng ta có một thói quen làm việc trên mảnh đó là CS50 khá muộn vào ban đêm. Và do đó, một số bạn có thể thích biến nó thành chế độ ban đêm, vì vậy để nói chuyện. 

Nhưng, cuối cùng, những gì bạn sẽ thấy bên trong CS50 IDE là ba areas-- biệt một khu vực trên các nơi còn lại file của bạn đang có được trong đám mây, một khu vực phía trên bên phải nơi mà mã của bạn là có thể chỉnh sửa. Bạn sẽ có thể mở tab riêng lẻ cho bất kỳ chương trình mà bạn viết trong học kỳ này bên trong đó góc trên bên phải. Và sau đó arcanely nhất, và chưa mạnh mẽ, sẽ là điều này tại đáy biết đến như một cửa sổ terminal. 

Đây là một trường học cũ Giao diện dòng lệnh, hoặc CLI, cho phép bạn để thực hiện các lệnh trên computer-- trong trường hợp này, các máy tính trong cloud-- để làm những việc như biên dịch mã của bạn từ mã nguồn thành mã máy, để chạy chương trình của bạn, hoặc để bắt đầu của bạn máy chủ web, hoặc để truy cập cơ sở dữ liệu của bạn, và bất kỳ số kỹ thuật khác rằng chúng ta sẽ bắt đầu sử dụng trước khi dài. Nhưng để đạt được điều đó, chúng tôi sẽ thực sự có để đi trực tuyến và bắt đầu chơi. Và để làm được điều đó, trước tiên hãy bắt đầu mày mò với chính, và viết các phần chính của một chương trình. Và chúng ta hãy sử dụng chức năng printf, mà chúng tôi sử dụng trước đó, đơn giản chỉ để nói một cái gì đó. 

Vì vậy, ở đây tôi đã được bên trong của CS50 IDE. Tôi đã đăng nhập trước. Và tôi hoàn toàn chiếu cửa sổ. Và như vậy, cuối cùng, bạn có quá trong vấn đề sắp tới sẽ thực hiện theo các bước tương tự sẽ cung cấp tài liệu trực tuyến. Vì vậy, bạn không cần phải lo lắng về hấp thụ tất cả các bước kỹ thuật ít mà tôi làm ở đây ngày hôm nay. 

Nhưng bạn sẽ nhận được một màn hình như thế này. Tôi xảy ra được trong chế độ ban đêm. Và bạn có thể làm sáng tất cả mọi thứ lên bằng cách tắt chế độ ban đêm. Và vào cuối của ngày, bạn sẽ thấy ba chính areas-- file trình duyệt ở bên trái, các tab mã lên hàng đầu, và các cửa sổ terminal ở phía dưới. 

Hãy để tôi đi trước và viết chương trình đầu tiên của tôi. Tôi sẽ làm việc tạm vào File, Save, và lưu tập tin của tôi như là hello.c. Thật vậy, theo quy ước, bất kỳ chương trình chúng tôi viết được được viết bằng ngôn ngữ C nên được đặt tên là một cái gì đó dot c, theo quy ước. Vì vậy, tôi sẽ đặt tên nó hello.c, vì Tôi chỉ muốn nói xin chào với thế giới. Bây giờ tôi sẽ để phóng to ra và bấm Save. Và tất cả tôi có ở đây bây giờ là một tab trong đó tôi có thể bắt đầu viết mã. 

Điều này sẽ không được biên dịch. Điều này có nghĩa là không có gì. Và ngay cả nếu tôi chuyển đổi này để số không và những người thân, CPU sẽ không có ý tưởng những gì đang diễn ra xung quanh. Nhưng nếu tôi viết dòng mà phù hợp với C phúc conventions-- C, một lần nữa, điều này language-- với cú pháp như này, printf chào world-- và tôi đã nhận được thoải mái với làm điều này theo thời gian. Vì vậy, tôi không nghĩ rằng tôi đã thực hiện bất kỳ lỗi đánh máy. 

Nhưng, không thay đổi, việc đầu tiên khi bạn làm điều này, bạn sẽ. Và những gì tôi về để làm sẽ rất kinh cũng không làm việc cho bạn lần đầu tiên. Và đó là hoàn toàn OK, bởi vì ngay bây giờ bạn chỉ có thể thấy một toàn bộ rất nhiều sự mới mẻ, nhưng theo thời gian khi bạn làm quen với môi trường này, và ngôn ngữ này, và những người khác, bạn sẽ bắt đầu thấy những điều mà hoặc là đúng hay sai. 

Và đây là những gì nghiên cứu sinh giảng dạy và học trợ lý được tốt như vậy tại qua thời gian, được đốm sai sót hoặc lỗi trong mã của bạn. Nhưng tôi cho rằng có không có lỗi trong mã này. Vì vậy, bây giờ tôi muốn chạy chương trình này. 

Bây giờ trên máy Mac hoặc máy PC của riêng tôi, tôi đang ở trong thói quen của các biểu tượng nhấp đúp khi tôi muốn chạy một số chương trình. Nhưng đó không phải là mô hình ở đây. Trong môi trường này, đó là CS50 IDE. Chúng tôi đang sử dụng một điều hành hệ thống gọi là Linux. Linux là gợi nhớ của người khác hệ điều hành, thường được biết đến như Unix. Và Linux được đặc biệt biết đến với có một Command Line Môi trường, CLI. Bây giờ, chúng tôi đang sử dụng cụ thể hương vị của Linux gọi là Ubuntu. Và Ubuntu chỉ đơn giản là một là phiên bản nào đó của Linux. 

Nhưng của các Linux trong những ngày làm thực đi kèm với giao diện người dùng đồ họa. Và những gì chúng tôi xảy ra được sử dụng ở đây là dựa trên web. Vì vậy, đây có thể nhìn ngay cả một chút khác nhau từ một cái gì đó bạn mình có thể có nhìn thấy hoặc chạy trong quá khứ. 

Vì vậy, tôi sẽ đi trước bây giờ và làm như sau. Tôi đã lưu tập tin này như hello.c. Tôi sẽ đi trước và loại clanghello.c Vì vậy Clang cho ngôn ngữ C là một trình biên dịch. Nó được cài đặt sẵn trong CS50 IDE. Và bạn hoàn toàn có thể tải về và cài đặt này trên máy Mac hoặc máy PC của bạn. 

Nhưng, một lần nữa, bạn sẽ không có tất cả pre-cấu hình thực hiện cho bạn. Vì vậy, bây giờ, tôi chỉ sẽ chạy clanghello.c. Và bây giờ nhận thấy cú pháp này đây sẽ cuối cùng nhận ra chỉ có nghĩa là tôi đang ở trong một thư mục hoặc thư mục gọi là Workspace. ký hiệu đô la này chỉ là ước ý nghĩa, gõ các lệnh của bạn ở đây. 

Đó là những gì được gọi là một nhắc nhở, chỉ theo quy ước là ký hiệu đô la. Và nếu tôi đi trước bây giờ và nhấp Nhập, không có gì có vẻ như đã xảy ra. Nhưng đó thực sự là một điều tốt. Càng ít xảy ra trên màn hình của bạn, nhiều khả năng mã của bạn là đúng, ít nhất là cú pháp. 

Vì vậy, nếu tôi muốn chạy này chương trình, tôi phải làm gì? Vâng, nó quay ra rằng Tên mặc định theo quy ước cho các chương trình khi bạn không chỉ định một đặt tên cho chương trình của bạn chỉ là a.out. Và cú pháp này quá, bạn sẽ làm quen với trước khi dài. 

Dot giảm chỉ có nghĩa là, hey, CS50 IDE, chạy một chương trình gọi là a.out đó là bên trong thư mục hiện tại của tôi. dot đó có nghĩa là thư mục hiện hành. Và chúng ta sẽ thấy những gì các trình tự khác như của các nhân vật có nghĩa là trước khi dài. 

Vì vậy, ở đây chúng tôi đi, Enter, hello thế giới. Và bạn sẽ nhận thấy, rằng những gì đã xảy ra? Không chỉ làm nó in hello thế giới. Nó cũng di chuyển con trỏ đến dòng kế tiếp. 

Tại sao lại thế? mã mà chúng tôi đã viết trước đây là gì đã bảo đảm rằng con trỏ sẽ đi trên dòng tiếp theo? Điều buồn cười về một máy tính là nó chỉ đi làm nghĩa đen những gì bạn nói với nó để làm. 

Vì vậy, nếu bạn cho nó để printf hello, dấu phẩy, không gian, thế giới, trích dẫn gần gũi, nó là nghĩa đen chỉ đi để in những ký tự. Nhưng tôi đã có nhân vật đặc biệt này ở cuối, thu hồi, dấu chéo ngược n. Và đó là những gì đảm bảo rằng các nhân vật đã đi đến dòng kế tiếp của màn hình. 

Trong thực tế, để tôi đi và làm điều này. Hãy để tôi đi trước và xóa này. Bây giờ, hãy chú ý trên màn hình của tôi có một chút ánh sáng màu đỏ trong tab cho thấy, hey, bạn đã không được lưu tập tin của bạn. Vì vậy, tôi sẽ đi trước với điều khiển S hoặc lệnh S, lưu tập tin. Bây giờ nó goes-- đi cho một màu xanh lá cây moment--. Và bây giờ nó quay trở lại chỉ là một biểu tượng đóng. 

Nếu bây giờ tôi chạy clanghello.c một lần nữa, Nhập, dấu chấm dấu gạch chéo, a.out, Enter, bạn sẽ thấy rằng nó vẫn làm việc. Nhưng nó cho là một lỗi nhỏ. Ngay bây giờ, không gian làm việc prompt-- của tôi, và sau đó là ký hiệu đô la, và sau đó prompt-- thực tế của tôi là tất cả trên cùng một dòng. Vì vậy, đây chắc chắn là một lỗi thẩm mỹ, thậm chí nếu nó không thực sự là một lỗi logic. 

Vì vậy, tôi sẽ hoàn tác những gì tôi chỉ cần làm. Tôi sẽ chạy lại a.out. Thông báo của tôi đã thêm xuống dòng nhân vật trở lại. Tôi đã lưu tập tin. 

Vì vậy, tôi sẽ chạy lại a.out, và- Chết tiệt, một lỗi, một lỗi có nghĩa là sai lầm. Vì vậy, các lỗi đó là mặc dù Tôi thêm dấu chéo ngược n có, tái lưu, tái chạy các chương trình, hành vi là như nhau. Tại sao điều đó sẽ là gì? 

Tôi đang thiếu một bước, phải không? Đó là bước quan trọng trước là bạn có với: khi bạn thay đổi mã nguồn của bạn, Hóa ra cũng chạy nó thông qua các trình biên dịch một lần nữa để bạn có được mã máy mới. Và các mã máy, các số không và những người thân, đang có được gần như giống hệt nhau, nhưng không hoàn toàn như vậy, vì chúng ta cần, tất nhiên, rằng dòng mới. 

Vì vậy, để khắc phục điều này, tôi sẽ cần chạy lại clanghello.c, nhập, chấm dấu gạch chéo, a.out. Và bây giờ, xin chào thế giới đã trở lại đến nơi mà tôi mong đợi nó được. Vì vậy, đây là tất cả tốt và tốt. Nhưng a.out là một cái tên khá ngu ngốc cho một chương trình, mặc dù nó sẽ xảy ra, vì lý do lịch sử, default-- nghĩa là đầu ra lắp ráp. 

Nhưng hãy để tôi đi trước đây và điều này khác đi. Tôi muốn chương trình hello thế giới của tôi để thực sự được gọi là hello. Vì vậy, nếu nó là một biểu tượng trên của tôi máy tính để bàn, nó sẽ không được a.out. Nó sẽ được gọi là hello. 

Vì vậy, để làm được điều này, nó quay ra rằng Clang, giống như nhiều chương trình, hỗ trợ các tham số dòng lệnh, hoặc cờ, hoặc bị chuyển mạch, mà đơn giản chỉ ảnh hưởng đến hành vi của nó. Cụ thể, Clang hỗ trợ o dash lá cờ, mà sau đó có một từ thứ hai. Trong trường hợp này, tôi sẽ tùy tiện, nhưng hợp lý, hãy gọi nó hello. Nhưng tôi có thể gọi nó là bất cứ điều gì Tôi muốn, ngoại trừ a.out, mà sẽ được thay bên cạnh điểm. 

Và sau đó chỉ cần ghi rõ tên của các tập tin tôi muốn biên dịch. Vì vậy, bây giờ thậm chí mặc dù lúc đầu của lệnh tôi vẫn còn có Clang, ở phần cuối của lệnh Tôi vẫn còn có các tên tập tin, bây giờ tôi có những dòng lệnh lập luận, những lá cờ đó đang nói, oh, bằng cách này, đầu ra-o, một tập tin hello, không phải là a.out mặc định. 

Vì vậy, nếu tôi nhấn Enter bây giờ, không có gì dường như đã xảy ra. Và, đâu, bây giờ tôi có thể làm dấu chấm dấu gạch chéo hello. Vì vậy, đó là chương trình tương tự. Các số không và những người thân giống hệt nhau vào cuối ngày. 

Nhưng họ đang ở trong hai a.out files-- khác nhau, đó là phiên bản đầu tiên và chỉ cách ngu ngốc đặt tên, và bây giờ xin chào, đó là một nhiều nhiều tên hấp dẫn cho một chương trình. Nhưng, thành thật, tôi không bao giờ sẽ nhớ điều này một lần nữa, và một lần nữa, và một lần nữa. Và thật ra, như chúng ta viết chương trình phức tạp hơn, các lệnh bạn sẽ phải viết sẽ nhận được thậm chí phức tạp hơn vẫn còn. 

Và do đó, không phải lo lắng. Nó chỉ ra rằng con người trước chúng tôi đã nhận ra rằng họ quá có cùng một vấn đề chính xác này. Họ cũng không thích phải gõ khá dài, các lệnh phức tạp, hãy để một mình nhớ chúng. Và do đó con người trước chúng ta đã thực hiện các chương trình khác mà làm cho nó dễ dàng hơn biên dịch phần mềm của bạn. 

Và, quả thật vậy, một trong những ví dụ chương trình được gọi là Make. Vì vậy, tôi sẽ đi trước và làm điều này. Tôi sẽ lùi lại tất cả mọi thứ tôi chỉ cần làm theo cách sau. Hãy để tôi gõ LS. Và bạn sẽ thấy ba things-- a.out, và một ngôi sao, xin chào và một ngôi sao, và hello.c. Hy vọng rằng, điều này cần có một ít trực quan, trong chừng mực trước đó đã có không có gì trong không gian làm việc này. Chẳng có gì mà tôi đã có tạo ra cho đến khi chúng tôi bắt đầu lớp. 

Và tôi đã tạo hello.c. sau đó tôi biên dịch nó, và gọi nó là a.out. Và sau đó tôi biên soạn lại một chút khác nhau và gọi nó là hello. Vì vậy, tôi có ba tập tin trong thư mục này, trong thư mục này được gọi là Workspace. Bây giờ, tôi có thể nhìn thấy điều đó là tốt nếu tôi thu nhỏ thực sự. 

Nếu tôi phóng to ra ở đây và nhìn vào đó trên bên phải góc, như đã hứa bên trái bên của màn hình của bạn luôn luôn là sẽ chỉ cho bạn những gì trong tài khoản của bạn, những gì bên trong của CS50 IDE. Và có ba tập tin đó. 

Vì vậy, tôi muốn thoát khỏi a.out và chào. Và như bạn có thể tưởng tượng trực giác, bạn có thể sắp xếp kiểm soát nhấp chuột hoặc click chuột phải vào điều này. Và đơn này ít bật lên. Bạn có thể tải về các tập tin, chạy nó, xem trước nó, làm mới, đổi tên, hoặc những gì không. 

Và tôi chỉ có thể xóa, và nó sẽ biến mất. Nhưng chúng ta hãy làm việc với một lệnh dòng cho bây giờ, để có được thoải mái với điều này, và làm như sau. Tôi sẽ đi trước và loại bỏ a.out bằng cách gõ theo nghĩa đen rma.out. Hóa ra, lệnh cho loại bỏ hoặc xóa một cái gì đó, không phải là loại bỏ hoặc xóa. 

Đó là cách ngắn gọn hơn RM, chỉ để tiết kiệm bạn một số thao tác bàn phím, và nhấn Enter. Bây giờ chúng ta sẽ được phần nào khó hiểu loại bỏ tập tin a.out thường xuyên. Tôi thực sự không biết những gì một tập tin bất thường sẽ được nêu ra. Nhưng tôi muốn loại bỏ nó. 

Vì vậy, tôi sẽ gõ y cho có. Hoặc tôi có thể gõ nó ra, và nhấn Enter. Và, một lần nữa, không có gì có thể xảy ra. Nhưng đó là, nói chung, là một điều tốt. 

Nếu tôi gõ LS thời gian này, Tôi sẽ thấy những gì? Hy vọng rằng, chỉ chào và hello.c. Bây giờ, như một sang một bên, bạn sẽ nhận thấy ngôi sao này, dấu hoa thị, đó là ở phần cuối của chương trình của tôi. Và họ cũng đang hiển thị trong màu xanh lá cây. Đó chỉ là cách CS50 IDE của cluing bạn vào thực tế rằng đó không phải là mã nguồn. Đó là một thực thi, một Runnable chương trình mà bạn thực sự có thể chạy bằng cách làm dấu chấm dấu gạch chéo, và sau đó tên của nó. 

Bây giờ, hãy để tôi đi trước và loại bỏ này, rm hello, Enter, loại bỏ thường xuyên nộp xin chào, có. Và bây giờ nếu tôi gõ LS, Chúng ta trở lại hello.c. Cố gắng không để xóa của bạn mã nguồn thực tế. Mặc dù có những tính năng được xây dựng vào CS50 IDE nơi bạn có thể đi qua lịch sử sửa đổi của bạn và tua lại trong thời gian nếu bạn vô tình xóa cái gì, làm được tâm theo các hướng dẫn có hoặc không, những gì bạn thực sự muốn làm. Và nếu tôi đi lên đến đỉnh góc bên trái bàn tay ở đây, tất cả những gì còn lại là hello.c. Vì vậy, có chùm lệnh khác mà bạn có thể thực hiện trong thế giới của Linux, một trong số đó là, một lần nữa, làm. Và chúng ta sẽ làm chương trình của tôi bây giờ như sau. 

Thay vì làm vang, thay vì làm vang-o, Tôi sẽ chỉ đơn giản nghĩa đen gõ, làm hello. Và bây giờ để ý, tôi không gõ làm hello.c. Tôi gõ làm hello. 

Và chương trình này Làm cho rằng đi kèm với IDE CS50, và nhiều hơn nữa nói chung với Linux, là một chương trình đó là sẽ thực hiện một chương trình gọi là Hello. Và nó sẽ giả định, theo quy ước, rằng nếu chương trình này có thể được thực hiện, nó sẽ được thực hiện từ một nguồn mã tập tin kết thúc bằng dấu chấm c, hello.c. 

Vì vậy, nếu tôi nhấn Enter bây giờ, thông báo rằng lệnh đó được thực thi là thực sự thậm chí còn trước so với trước đây. Và đó là bởi vì chúng tôi đã cấu hình sẵn CS50 IDE có một số tính năng bổ sung xây dựng trong đó chúng ta không cần chỉ được nêu ra, nhưng sớm biết thôi. Nhưng điều quan trọng để nhận ra là bây giờ tôi có một chương trình Hello. 

Nếu tôi gõ LS lần nữa, tôi có một chương trình hello. Và tôi có thể chạy nó với dot giảm a.out, không, bởi vì toàn bộ các điểm này tập thể dục là dấu chấm dấu gạch chéo hello. Và bây giờ tôi có chương trình hello thế giới của tôi. Vì vậy, di chuyển về phía trước, chúng tôi hầu như luôn luôn chỉ sẽ biên dịch chương trình của chúng tôi sử dụng Make lệnh. Và sau đó chúng ta sẽ chạy chúng bằng cách dot gạch chéo, và tên của chương trình. Nhưng nhận ra những gì Hãy là làm cho bạn, là nó là chính nó không phải là một trình biên dịch. Nó chỉ là một chương trình tiện mà biết làm thế nào để kích hoạt một trình biên dịch chạy để bạn mình có thể sử dụng nó. 

Những lệnh khác tồn tại trong Linux, và lần lượt các CS50 IDE? Chúng tôi sẽ sớm thấy rằng có một lệnh CD, Change Directory. Điều này cho phép bạn trong vòng giao diện dòng lệnh của bạn để di chuyển về phía trước, và trở lại, và mở các thư mục khác nhau mà không cần sử dụng con chuột của bạn. 

LS chúng ta đã thấy, đó là viết tắt của danh sách các tập tin trong thư mục hiện hành. Hãy Dir, bạn có thể có thể bắt đầu để suy ra những gì chúng có ý nghĩa now-- tạo thư mục, nếu bạn muốn tạo một thư mục. RM cho remove, RM Dir cho loại bỏ directory-- và những, một lần nữa, là những dòng lệnh tương đương của bạn có thể làm trong CS50 IDE với con chuột của bạn. Nhưng bạn sẽ sớm tìm thấy mà đôi khi nó chỉ là nhanh hơn rất nhiều để làm việc với một bàn phím, và cuối cùng là rất nhiều mạnh mẽ hơn. 

Nhưng thật khó để tranh luận rằng bất cứ điều gì chúng tôi đã làm cho đến nay là tất cả những gì mạnh mẽ, khi tất cả chúng tôi đã nói là, hello thế giới. Và, trên thực tế, tôi hardcoded sự lời chào thế giới vào chương trình của tôi. Không có động lực nào. Scratch là một bậc thú vị hơn tuần trước. 

Và như vậy chúng ta hãy đến đó. Chúng ta hãy bước về phía đó bằng cách của một số các chức năng này. Vì vậy, không chỉ C đi kèm với printf, và chùm chức năng khác một số trong đó chúng ta sẽ thấy theo thời gian, nó không làm cho nó tất cả những gì dễ dàng ngay cổng trong việc sử dụng đầu vào. 

Trong thực tế, một trong những điểm yếu các ngôn ngữ như C, và thậm chí cả Java và chưa những người khác, đó là nó không làm cho nó dễ dàng chỉ cần có được những thứ như số nguyên từ người dùng, hoặc các chuỗi, lời nói, và cụm từ, hãy để mọi thứ một mình như nổi điểm giá trị, hoặc số thực với điểm thập phân, và thực sự số dài, như chúng ta sẽ sớm thấy. Vì vậy, danh sách các chức năng ở đây, những là giống như miếng Scratch câu đố khác mà chúng ta đã cài đặt sẵn trong CS50 IDE mà chúng ta sẽ sử dụng cho một vài tuần như bánh xe đào tạo của các loại, và cuối cùng đưa họ ra, và tìm bên dưới mui xe, có lẽ, ở làm thế nào những điều được thực hiện. 

Nhưng để làm được điều này, chúng ta hãy thực sự viết một chương trình. Hãy để tôi đi trước bây giờ. Và tôi sẽ tạo ra một mới nộp bằng cách nhấn vào dấu cộng nhỏ này, và click vào New File. 

Tôi sẽ tiết kiệm này bên cạnh một là, hãy nói, string.c, bởi vì tôi muốn chơi với chuỗi. Và chuỗi trong C chỉ là một chuỗi các ký tự. Vì vậy, bây giờ hãy đi trước và làm như sau. 

Bao gồm các tiêu chuẩn và IO.h-- nó quay ra chuẩn IO, IO chỉ có nghĩa là đầu vào và đầu ra. Vì vậy, nó chỉ ra rằng dòng này ở đây là gì được các nước láng giềng chúng ta sử dụng printf. Printf, tất nhiên, sản lượng sản xuất. Vì vậy, để sử dụng printf, nó quay ra bạn phải có dòng mã này ở đầu tập tin của bạn. 

Và chúng tôi sẽ trở lại với những gì mà thực sự có nghĩa là trước khi dài. Nó chỉ ra rằng trong bất kỳ chương trình C tôi viết, Tôi phải bắt đầu nó với mã trông như thế này. Và bạn sẽ nhận thấy CS50 IDE, và phát triển tích hợp khác môi trường như nó, sẽ cố gắng làm tốt nhất họ có thể để kết thúc suy nghĩ của bạn. Trong thực tế, một khoảnh khắc trước khi tôi hoàn tác những gì tôi vừa làm, tôi nhấn Enter. 

sau đó tôi nhấn xoăn mở cú đúp, nhấn Enter lần nữa. Và nó đã hoàn thành suy nghĩ của tôi. Nó đã cho tôi một dòng mới, thụt không kém vì lý do phong cách đẹp chúng ta sẽ thấy. Và sau đó nó tự động đã cho tôi mà cú đúp xoăn để kết thúc suy nghĩ của tôi. Bây giờ, nó không luôn luôn đoán những gì bạn muốn làm. Nhưng phần lớn, nó bạn tiết kiệm một số tổ hợp phím. Vì vậy, một thời gian trước đây, chúng tôi chạy program-- này hello, thế giới, và sau đó biên dịch nó, và sau đó chạy nó. Nhưng không có tính năng động ở đây. Nếu chúng ta muốn làm một cái gì khác nhau? Vâng, những gì nếu tôi muốn thực sự nhận được một chuỗi từ người sử dụng? Tôi sẽ sử dụng một mảnh ghép gọi là chính xác mà-- nhận được chuỗi. 

Hóa ra trong C mà khi bạn không muốn để cung cấp đầu vào cho một mảnh ghép, hay đúng hơn một chức năng, bạn nghĩa đen chỉ làm ngoặc mở, ngoặc đóng. Vì vậy, nó như thể có không có hộp màu trắng để đánh vào. Tiếng nói khối trước đã có một hộp nhỏ màu trắng. Chúng tôi không có mà hộp trắng bây giờ. 

Nhưng khi tôi gọi get chuỗi, tôi muốn đặt kết quả ở đâu đó. Vì vậy, một mô hình rất phổ biến trong C là gọi một chức năng, như get chuỗi ở đây, và sau đó lưu trữ giá trị trả về của nó. Đó là kết quả của nó nỗ lực trong một cái gì đó. 

Và là những gì xây dựng trong chương trình, cho dù trong Scratch hay bây giờ C, mà chúng ta có thể sử dụng để thực sự lưu trữ một cái gì đó? Gọi nó là một biến, phải không? Và trong Scratch, chúng tôi không thực sự quan tâm những gì đang diễn ra trong các biến. 

Nhưng trong trường hợp này, chúng tôi thực sự làm. Tôi sẽ nói chuỗi. Và sau đó tôi có thể gọi bất cứ điều gì tôi muốn này. Tôi sẽ gọi nó tên, được nhận được chuỗi. 

Và bây giờ, ngay cả khi bạn đang một chút mới này, nhận thấy rằng tôi đang thiếu một số chi tiết. Tôi quên một dấu chấm phẩy. Tôi cần phải kết thúc suy nghĩ này. Vì vậy, tôi sẽ di chuyển con trỏ của tôi, và đánh dấu chấm phẩy ở đó. Và những gì đã tôi chỉ thực hiện? Trong dòng mã này, số 5 vào lúc này, Tôi gọi chuỗi get không có đầu vào. Vì vậy, không có chút trắng hộp như Save block có. 

Tôi chỉ nói rằng, hey, máy tính, làm cho tôi một chuỗi. Các dấu bằng là không thực sự một dấu bằng, mỗi se. Đó là sự phân công điều hành, có nghĩa là, hey, máy tính, di chuyển các giá trị từ bên phải qua bên trái. Và ở bên trái, tôi có sau. 

Hey, máy tính, cho tôi một string-- một chuỗi các ký tự. Và gọi đó là chuỗi Name. Và tôi thậm chí không cần phải gọi nó tên. 

Tôi có thể gọi nó, thông thường, một cái gì đó giống như S, giống như chúng ta sử dụng i để gọi các biến i. Nhưng bây giờ tôi cần phải làm một cái gì đó với nó. Nó sẽ được khá ngu ngốc để thử biên dịch mã này, chạy chương trình này, mặc dù Tôi nhận được một chuỗi, bởi vì nó vẫn chỉ là sẽ nói hello thế giới. 

Nhưng những gì nếu tôi muốn thay đổi điều này. Tại sao tôi không làm được điều này? Phần trăm s, dấu phẩy s. Và đây là một chút khó hiểu vẫn còn. 

Vì vậy, hãy để tôi làm cho các biến của tôi rõ ràng hơn. Hãy để tôi đặt tên biến Tên này. Và chúng ta hãy xem nếu chúng ta không thể trêu chọc ngoài những gì đang xảy ra ở đây. 

Vì vậy, trên đường năm, tôi nhận được một chuỗi. Và tôi đang lưu trữ chuỗi, bất cứ điều gì người dùng đã gõ trong vào bàn phím của mình, trong một biến gọi là Danh. Và nó chỉ ra rằng printf không chỉ đưa một đối số trong đôi dấu ngoặc kép, một đầu vào trong dấu ngoặc kép. 

Nó có thể mất hai, hoặc ba, hoặc nhiều hơn, chẳng hạn rằng thứ hai, hoặc thứ ba, hay thứ tư, là tất cả các tên của các biến, hay cụ thể giá trị, mà bạn muốn cắm vào, động, mà chuỗi trong dấu ngoặc kép. Nói cách khác, những gì sẽ là sai với điều này? Nếu tôi chỉ nói xin chào, tên, dấu chéo ngược n, lưu tập tin của tôi, biên dịch mã của tôi, và chạy này, điều gì sẽ xảy ra? 

Nó chỉ sẽ nói, xin chào tên, nghĩa là N-A-M-E, đó là loại ngu ngốc vì nó không có gì khác biệt so với thế giới. Vì vậy, bất cứ điều gì trong dấu ngoặc kép là những gì theo nghĩa đen được in. Vì vậy, nếu tôi muốn có một giữ chỗ đó, Tôi thực sự cần phải sử dụng một số cú pháp đặc biệt. Và hóa ra nếu bạn đọc tài liệu hướng dẫn cho các chức năng printf, nó sẽ cho bạn biết rằng nếu bạn sử dụng phần trăm s, bạn có thể thay thế một giá trị như sau. 

Sau một dấu phẩy sau đó báo giá gấp đôi, bạn chỉ đơn giản viết tên của biến mà bạn muốn cắm vào định dạng mà mã, hoặc format specifier, phần trăm của các chuỗi. Và bây giờ nếu tôi đã lưu tập tin của tôi, Tôi quay trở lại xuống đến thiết bị đầu cuối của tôi. Và tôi gõ Tạo String, bởi vì, một lần nữa, cái tên này tập tin mà tôi đã chọn trước là string.c. 

Vì vậy, tôi sẽ nói Hãy String, nhập. Ôi lòng tốt, nhìn vào tất cả những sai lầm, chúng tôi đã thực hiện rồi. Và điều này hợp-- gì, điều này thực sự là như một sáu, chương trình dòng bảy? Vì vậy, đây là nơi mà nó có thể rất nhanh chóng có được áp đảo. 

cửa sổ thiết bị đầu cuối này có bây giờ chỉ cần nhả một số lượng lớn các thông báo lỗi. Chắc chắn, tôi không có nhiều lỗi thông điệp hơn là tôi có dòng mã. Vậy chuyện gì đang xảy ra thế? 

Vâng, chiến lược tốt nhất làm bất cứ lúc nào bạn làm gặp phải một áp đảo danh sách các lỗi như thế, được di chuyển trở lại, tìm kiếm các lệnh bạn chỉ cần chạy, mà trong trường hợp của tôi là làm cho chuỗi. Nhìn vào những gì làm đã làm, và đó là điều đó lệnh dài Clang, không có việc lớn đó. 

Nhưng màu đỏ là xấu. Xanh là cố gắng để được nhẹ nhàng và hữu ích. Nhưng nó vẫn còn xấu, trong trường hợp này. Nhưng đâu là nó xấu? 

String.c, dòng năm, nhân vật năm. Vì vậy, đây chỉ là quy ước chung. Một cái gì đó đại tràng một cái gì đó có nghĩa là số dòng và số nhân vật. Lỗi, sử dụng không khai báo nhận dạng chuỗi. Ý của bạn là tiêu chuẩn trong? 

Vì vậy, thật không may, Clang đang cố gắng để được giúp đỡ. Nhưng đó là sai, trong trường hợp này. Không, Clang, tôi không có nghĩa là tiêu chuẩn IO. Tôi có nghĩa là trên một dòng, có. 

Nhưng dòng năm là này ở đây. Và Clang không hiểu S-T-R-I-N-G. Đó là một định không khai báo, một từ đó nó chỉ chưa bao giờ thấy trước đây. Và đó là bởi vì C, ngôn ngữ chúng ta đang viết mã trong ngay bây giờ, không có các biến được gọi là chuỗi. 

Nó không, theo mặc định, hỗ trợ một cái gì đó gọi là một chuỗi. Đó là một mảnh của CS50 thuật ngữ, nhưng rất thông thường. Nhưng tôi có thể sửa lỗi này như sau. 

Nếu tôi thêm một dòng mã để đầu của chương trình này, bao gồm CS50.h, mà là một tập tin khác ở đâu đó bên trong CS50 IDE, ở đâu đó trên ổ đĩa cứng, có thể nói, của hệ điều hành Ubuntu rằng tôi đang chạy, mà là tập tin đó sẽ dạy cho các điều hành hệ thống những gì một chuỗi là, chỉ cần như io.h tiêu chuẩn là các tập tin trong hệ điều hành đó là sẽ dạy cho nó là gì printf. 

Thật vậy, chúng ta đã có thể nhận một thông điệp rất tương tự nếu IO đã thừa nhận tiêu chuẩn IO.h và cố gắng sử dụng printf. Vì vậy, tôi sẽ đi trước và chỉ mất kiểm soát L để xóa màn hình của tôi. Hoặc bạn có thể gõ rõ ràng và nó sẽ chỉ cần xóa sổ thiết bị đầu cuối. Nhưng bạn vẫn có thể di chuyển trở lại trong thời gian. 

Và tôi sẽ chạy lại Hãy String. Qua các ngón tay của tôi lần này, Enter. Ôi Chúa ơi, nó làm việc. nó cho thấy tôi một lệnh dài khó hiểu đó là những gì Hãy tạo ra thông qua Clang, nhưng không có thông báo lỗi. Vì vậy, nhận ra, mặc dù bạn có thể nhận được hoàn toàn choáng ngợp với số thông báo lỗi, nó chỉ có thể là tầng này gây phiền nhiễu hiệu lực, nơi Clang không hiểu một điều, có nghĩa là nó sau đó không hiểu từ kế tiếp, hoặc các dòng tiếp theo. Và do đó, nó chỉ cuộn cảm trên mã của bạn. Nhưng việc sửa chữa có thể là đơn giản. Và do đó, luôn tập trung vào các dòng đầu tiên của đầu ra. Và nếu bạn không hiểu nó, chỉ cần nhìn cho các từ khóa đó có thể là manh mối, và số dòng, và các nhân vật, nơi sai lầm mà có thể được. 

Bây giờ hãy để tôi đi trước và gõ dot dấu gạch chéo, chuỗi, nhập. Hm, nó không chào hỏi bất cứ điều gì. Tại sao? Vâng, nhớ lại, mà là nó chạy? 

Đây có thể là bị mắc kẹt tại thời điểm này trong vòng một, nếu bạn sẽ, trên đường sáu, vì Nhận String thiết kế, được viết bởi đội ngũ nhân viên CS50, là nghĩa đen có nghĩa là chỉ cần ngồi ở đó chờ đợi, và chờ đợi, và chờ đợi cho một chuỗi. Tất cả chúng ta có ý nghĩa bởi chuỗi là đầu vào của con người. Vì vậy, bạn biết những gì? Hãy để tôi đi trước. Và chỉ cần vào một ý thích, cho tôi gõ tên của tôi, David, nhập. Bây giờ tôi có một chương trình năng động hơn. Nó nói, hello David. 

Nếu tôi đi trước và chạy này một lần nữa, hãy để tôi cố gắng nói tên Zamila, nhập. Và bây giờ chúng tôi có một chương trình năng động. Tôi đã không cứng mã hóa thế giới. Tôi đã không được mã hóa cứng tên, hay David, hoặc Zamila. 

Bây giờ nó nhiều hơn như các chương trình chúng ta đã biết, mà nếu nó lấy đầu vào, nó tạo ra hơi khác nhau. Bây giờ, điều này không phải là tốt nhất kinh nghiệm người dùng, hoặc UX. Tôi chạy chương trình. 

Tôi không biết những gì tôi phải để làm, trừ khi tôi thực sự nhìn vào hoặc nhớ mã nguồn. Vì vậy, chúng ta hãy làm cho người sử dụng trải nghiệm tốt hơn một chút với các đơn giản nhất của sự vật. Hãy để tôi quay trở lại này chương trình, và chỉ đơn giản nói printf. 

Và hãy để tôi đi trước và nói tên, đại tràng, và một không gian, và sau đó một dấu chấm phẩy. Và chỉ cần cho đá, không có phản ứng dữ dội n. Và đó là cố ý, bởi vì tôi không muốn dấu nhắc để chuyển sang dòng tiếp theo. 

Tôi muốn, thay vào đó, làm điều này, làm cho chuỗi biên dịch lại mã của tôi vào máy mới Mã dot giảm chuỗi. Ah, đây là đẹp hơn rất nhiều. Bây giờ tôi thực sự biết những gì máy tính muốn tôi làm, cho nó một cái tên. 

Vì vậy, tôi sẽ đi trước và gõ trong Rob, nhập, và xin chào, Rob. Vì vậy, nhận ra, đây vẫn là, ở cuối trong ngày, chỉ có một chương trình chín dòng. Nhưng chúng tôi đã thực hiện các bước nhỏ. 

Chúng tôi đã viết một dòng mà chúng ta đã quá quen thuộc, printf, xin chào thế giới. Sau đó, chúng phá hoại một chút về điều đó. Và chúng tôi thực sự sử dụng get chuỗi. Và chúng tôi ném giá trị đó trong một biến. Và sau đó chúng tôi đã đi trước và được cải thiện nó hơn nữa với dòng thứ ba. Và quá trình lặp đi lặp lại này viết phần mềm là thực sự quan trọng. Trong CS50, và trong cuộc sống nói chung, bạn không nên thường ngồi xuống, có một chương trình trong tâm trí, và cố gắng viết toàn bộ điều chết tiệt tất cả cùng một lúc. 

Nó sẽ, chắc chắn, dẫn đến cách nhiều lỗi hơn bản thân chúng ta thấy ở đây. Ngay cả tôi, cho đến ngày nay, liên tục phạm sai lầm ngu ngốc khác, là những sai lầm thực sự khó khăn hơn đó là khó khăn hơn để tìm ra. Nhưng bạn sẽ làm nhiều hơn những sai lầm hơn dòng mã bạn viết tất cả cùng một lúc. Và do đó, thực tế này, viết một chút ít mã mà bạn thấy thoải mái, biên dịch nó, chạy nó, thử nghiệm nó tổng quát hơn, sau đó di chuyển on-- nên giống như chúng ta giữ layering và lớp cuối tuần trước, xây dựng từ một cái gì đó rất đơn giản để một cái gì đó phức tạp hơn, làm tương tự ở đây. Đừng ngồi xuống, và cố gắng viết cả một vấn đề. Trên thực tế có những bước nhỏ. 

Bây giờ, dây là không phải tất cả mà hữu ích unto mình. Chúng ta nên thực sự, lý tưởng, thích có cái gì khác trong bộ công cụ của chúng tôi. Vì vậy, hãy thực sự làm chính xác điều đó. 

Hãy để tôi đi trước bây giờ và whip lên một chương trình hơi khác nhau. Và chúng ta sẽ gọi int.c này, đối với số nguyên. Tôi sẽ, tương tự, bao gồm CS550.h. Tôi sẽ bao gồm tiêu chuẩn IO. Và đó sẽ là khá phổ biến trong những ngày đầu tiên của lớp. 

Và tôi sẽ sẵn sàng bản thân mình với một chức năng chính. Và bây giờ thay vì nhận được một chuỗi, chúng ta hãy đi trước và nhận được một int. Hãy gọi nó là tôi, và gọi nó là được int, dấu ngoặc đóng, dấu chấm phẩy. Và bây giờ chúng ta hãy làm một cái gì đó với nó, printf. 

Hãy nói điều gì đó như hello, dấu chéo ngược n, dấu phẩy i. Vì vậy, tôi bắt chước khá nhiều những gì tôi đã làm chỉ là một khoảnh khắc trước. Tôi có một placeholder đây. Tôi đã dấu phẩy tôi ở đây, bởi vì tôi muốn cắm tôi vào chỗ mà. 

Vì vậy, chúng ta hãy đi trước và thử biên dịch chương trình này. Các tập tin được gọi là int.c. Vì vậy, tôi sẽ nói, làm cho int, nhập. Ôi Chúa ơi, nhưng không có việc lớn, phải không? Có một sai lầm. 

Có một sai lầm cú pháp ở đây như vậy mà chương trình có thể không được biên soạn trong int.c, dòng bảy, nhân vật 27, định dạng lỗi chỉ định kiểu char ngôi sao, bất kể đó là. Nhưng các loại đối số là int. 

Vì vậy, ở đây, chúng tôi sẽ không đối với: mặc dù hôm nay là rất nhiều vật liệu, chúng ta sẽ áp đảo bạn với hoàn toàn mọi tính năng của C, và lập trình nói chung, chỉ trong vài tuần đầu tiên. Vì vậy, có người thường sẽ là biệt ngữ mà bạn không quen thuộc. Và, trên thực tế, ngôi sao char là một cái gì đó chúng ta sẽ quay trở lại trong một tuần hoặc thời gian hai của. 

Nhưng hiện nay, chúng ta hãy xem nếu chúng ta có thể phân tích các từ quen thuộc. Định dạng khác nên chúng tôi nghe định dạng specifier, mã định dạng trước. Đó là quen thuộc. Doanh-- nhưng đối số có kiểu int. Chờ một phút, tôi là một int. 

Có lẽ phần trăm của thực có một số ý nghĩa xác định. Và, quả thật vậy, nó. Một số nguyên, nếu bạn muốn printf để thay thế nó, bạn thực sự phải sử dụng một định dạng khác nhau đặc tả. Và bạn sẽ không biết điều này trừ khi ai đó nói với bạn, hoặc bạn đã làm trước đó. Nhưng phần trăm tôi là gì có thể được sử dụng phổ biến trong printf để cắm vào một số nguyên. Bạn cũng có thể sử dụng phần trăm d cho một số nguyên thập phân. Nhưng tôi là tốt đẹp và đơn giản ở đây. Vì vậy, chúng tôi sẽ đi với điều đó. 

Bây giờ hãy để tôi đi trước và chạy lại làm cho int, Enter. Đó là tốt, không có lỗi. Dot giảm OK int--, trải nghiệm người dùng xấu, bởi vì tôi đã không nói với bản thân mình phải làm gì. Nhưng đó là tốt. Tôi đang đánh bắt trên một cách nhanh chóng. 

Và bây giờ hãy để tôi đi trước và gõ vào David, OK, Zamila, Rob. OK, vì vậy đây là một điều tốt. Thời gian này, tôi đang sử dụng một chức năng, một mảnh ghép, được gọi là get int. Và nó quay out-- và chúng tôi sẽ thấy sau này trong term-- các nhân viên đã thực hiện CS50 nhận được chuỗi theo cách như vậy rằng nó sẽ chỉ thể chất nhận được một chuỗi cho bạn. 

Nó đã thực hiện get int trong như một cách mà nó sẽ chỉ có một số nguyên cho bạn. Và nếu quý vị, con người, không hợp tác, đó là nghĩa là chỉ cần đi để nói thử lại, thử lại, thử lại, nghĩa đen ngồi đó looping, cho đến khi bạn bắt buộc với một số số huyền diệu, như 50, và chào 50. 

Hoặc nếu chúng ta chạy này một lần nữa và gõ 42, hello 42. Và như vậy các chức năng get int bên trong đó mảnh ghép là đủ logic, đủ suy nghĩ, để tìm ra, một từ là gì? Và một số là những gì? Chỉ chấp nhận, cuối cùng, con số. 

Vì vậy, nó quay ra rằng điều này không phải là tất cả những biểu cảm. cho đến nay. Vì vậy, yay, thời gian qua chúng tôi đã đi khá nhanh chóng vào thực hiện trò chơi, và hình ảnh động, và các công trình nghệ thuật trong Scratch. Và ở đây, chúng tôi đang được nội dung với hello thế giới, và chào 50. 

Nó không phải tất cả những cảm hứng. Và, quả thật, những số đầu tiên ví dụ sẽ mất một thời gian đến đoạn đường nối lên trong sự phấn khích. Nhưng chúng tôi có rất nhiều kiểm soát hiện nay, trên thực tế. Và chúng ta sẽ rất nhanh chóng bắt đầu layering trên đầu trang của các nguyên thủy cơ bản. 

Nhưng trước tiên, chúng ta hãy hiểu những gì những hạn chế là. Trong thực tế, một trong những điều Scratch không dễ dàng để chúng tôi làm là thực sự nhìn bên dưới mui xe, và hiểu những gì một máy tính là, những gì nó có thể làm, và các hạn chế của nó được. Và, thực sự, mà thiếu hiểu biết, có thể, dài hạn có thể dẫn đến viết mistakes-- riêng của chúng tôi lỗi, viết phần mềm không an toàn bị hack một cách nào đó. 

Vì vậy, chúng ta hãy có một số bước về phía sự hiểu biết này tốt hơn một chút bằng cách cách, nói, ví dụ sau đây. Tôi sẽ đi trước và thực hiện thật nhanh một chương trình gọi là Adder. Giống như, hãy thêm một vài số với nhau. Và tôi sẽ để mã số góc ở đây, và chỉ cần sao chép và dán nơi tôi đã được trước đó, chỉ vì vậy chúng tôi có thể nhận ra sớm hơn. Vì vậy, bây giờ tôi đã có sự khởi đầu cơ bản của một chương trình gọi là Adder. 

Và chúng ta hãy đi trước và làm điều này. Tôi sẽ đi trước và nói, intx được lấy int. Và bạn biết những gì? Hãy làm cho một kinh nghiệm người dùng tốt hơn. 

Vì vậy, chúng ta hãy chỉ nói x là, và hiệu quả nhắc nhở người dùng để cung cấp cho chúng tôi x. Và sau đó cho tôi đi trước và nói, printf làm thế nào về y là, lần này mong đợi hai giá trị từ người sử dụng. Và sau đó chúng ta chỉ cần đi trước và nói, printf, tổng của x và y được. Và bây giờ tôi không muốn làm trăm s. Tôi muốn làm trăm i, gạch chéo ngược n, và sau đó cắm vào giá trị tổng. 

Vì vậy, làm thế nào tôi có thể đi về việc này? Bạn biết những gì? Tôi biết làm thế nào để sử dụng các biến. Hãy để tôi chỉ cần khai báo một cái mới, int z. 

Và tôi sẽ mất một đoán ở đây. Nếu có dấu hiệu bình đẳng trong này ngôn ngữ, có lẽ tôi chỉ có thể làm X cộng Y, miễn là tôi kết thúc của tôi nghĩ với một dấu chấm phẩy? Bây giờ tôi có thể quay trở lại xuống đây, cắm z, kết thúc suy nghĩ này với một dấu chấm phẩy. Và chúng ta thấy bây giờ, nếu các trình tự của lines-- x là nhận int. Y là có được int. 

Thêm x và y, lưu trữ các giá trị trong z-- như vậy, một lần nữa, hãy nhớ dấu bằng không bằng. Đó là nhiệm vụ từ phải sang trái. Và chúng ta hãy in ra rằng tổng của x và y không phải là nghĩa đen z, nhưng những gì bên trong của z. Vì vậy, chúng ta hãy làm Adder - tốt đẹp, không có sai lầm lần này. Dot giảm Adder, nhập, x sẽ là 1. 

Y sẽ là 2. Và tổng x và y là 3. Vì vậy, đó là tất cả tốt và tốt. 

Vì vậy, bạn sẽ tưởng tượng rằng môn toán nên làm việc trong một chương trình như thế này. Nhưng bạn biết những gì? Là biến này, dòng 12, thậm chí còn cần thiết? Bạn không cần phải có thói quen chỉ lưu trữ những thứ trong các biến chỉ vì bạn có thể. Và, trên thực tế, nó thường thiết kế xấu coi nếu bạn đang tạo ra một biến, được gọi là z trong trường hợp này, lưu trữ một cái gì đó trong nó, và sau đó ngay lập tức sử dụng nó, nhưng không bao giờ trở lại. Tại sao cho một cái gì đó một tên như z nếu bạn theo nghĩa đen sẽ sử dụng Điều duy nhất một lần, và do đó gần đến nơi bạn đã tạo nó ở nơi đầu tiên, rất gần gũi về dòng mã? Vì vậy, bạn biết những gì? Nó chỉ ra rằng C là khá linh hoạt. Nếu tôi thực sự muốn plug-in các giá trị ở đây, Tôi không cần phải khai báo một biến mới. Tôi chỉ có thể cắm trong X cộng y, bởi vì C hiểu số học, và toán tử toán học. 

Vì vậy, tôi chỉ có thể nói rằng, làm toán này, x cộng với y, bất cứ những giá trị, cắm kết quả số nguyên thành chuỗi. Vì vậy, đây có thể là, mặc dù chỉ có một đường ngắn hơn, một thiết kế tốt hơn, một chương trình tốt hơn, bởi vì có mã ít hơn, do đó ít hơn cho tôi hiểu. Và nó cũng chỉ sạch hơn, trong chừng mực chúng tôi không giới thiệu từ mới, biểu tượng mới, như z, mặc dù họ không thực sự phục vụ nhiều mục đích. 

Thật không may, không phải là toán học tất cả những gì đôi khi đáng tin cậy. Hãy đi trước và làm điều này. Tôi sẽ đi trước bây giờ và làm như sau. 

Hãy làm printf, phần trăm tôi, cộng thêm phần trăm i, chịu trăm i, gạch chéo ngược n. Và tôi sẽ làm điều này-- xyx cộng với y. Vì vậy, tôi chỉ cần đi để viết lại này hơi khác nhau ở đây. Hãy để tôi chỉ làm một kiểm tra sự tỉnh táo nhanh chóng. Một lần nữa, chúng ta không có được trước của mình. Hãy cộng, dấu chấm dấu gạch chéo cộng. x là 1, y là 2, 1 + 2 là 3. Vì vậy, đó là tốt. Nhưng chúng ta hãy làm phức tạp này ngay bây giờ một chút, và tạo ra một tập tin mới. 

Tôi sẽ gọi con này, nói, ints, số nhiều cho các số nguyên. Hãy để tôi bắt đầu từ đâu tôi là một khoảnh khắc trước. Nhưng bây giờ chúng ta hãy làm một vài dòng khác. Hãy để tôi đi trước và làm như sau, printf, phần trăm tôi, trừ đi phần trăm i, là phần trăm tôi, dấu phẩy x, dấu phẩy yx trừ y. Vì vậy, tôi đang làm một chút toán khác nhau đó. Hãy làm một khác. Vì vậy, phần trăm i lần phần trăm i là phần trăm i, gạch chéo ngược n. Hãy plug-in x và y, và lần x y. Chúng tôi sẽ sử dụng dấu hoa thị trên máy tính của bạn cho lần. 

Bạn không sử dụng x. x là một tên biến ở đây. Bạn sử dụng sao cho phép nhân. Hãy làm một nhiều hơn. Printf phần trăm tôi, chia theo phần trăm tôi, là phần trăm i, n dấu chéo ngược. xy chia y-- do đó, bạn sử dụng các dấu gạch chéo trong C để làm phân chia. Và chúng ta hãy làm một khác. Phần còn lại của phần trăm tôi, chia theo phần trăm tôi, là phần trăm tôi. xy-- và bây giờ còn lại là những gì còn lại. Khi bạn cố gắng chia một Mẫu số vào tử số, bao nhiêu là trái hơn mà bạn không thể chia ra? 

Vì vậy, không có thực sự, nhất thiết, một biểu tượng chúng tôi đã sử dụng trong trường lớp cho việc này. Nhưng có trong C. Bạn có thể nói x modulo y, trong đó dấu hiệu này phần trăm trong context-- này gây nhầm lẫn khi bạn đang ở trong của dấu ngoặc kép, bên trong của printf, phần trăm được sử dụng như là sự xác định định dạng. 

Khi bạn sử dụng phần trăm ngoài rằng trong một biểu thức toán học, đó là các nhà điều hành modulo cho mô-đun arithmetic-- cho mục đích của chúng tôi ở đây, chỉ có nghĩa, là những gì còn lại của x chia y? Vì vậy x chia y là x slash y. phần còn lại của x chia y là gì? Đó là x mod y, như một lập trình viên sẽ nói. 

Vì vậy, nếu tôi đã không sai lầm ở đây, cho tôi đi trước và làm cho ints, số nhiều, tốt đẹp, và ints slash dot. Và chúng ta hãy đi trước và làm, hãy nói, 1, 10. Tất cả các bên phải, 1 + 10 là 11, kiểm tra. 1 trừ đi 10 là âm 9, kiểm tra. 

1 lần 10 là 10, kiểm tra. 1 chia cho 10 hợp-- OK, chúng tôi sẽ bỏ qua một. Phần còn lại của 1 chia cho 10 là 1. Đúng rồi. Nhưng có một lỗi ở đây. 

Vì vậy, một trong những tôi đặt của tôi bàn giao, không chính xác. Ý tôi là, nó gần với 0. 1 chia cho 10, bạn biết, nếu chúng ta cắt một số góc, chắc chắn, nó không. Nhưng nó thực sự phải là 1/10, 0.1 hoặc 0.10, 0,1000, vân vân. 

Nó nên không thực sự là không. Vâng, nó chỉ ra rằng máy tính là làm nghĩa đen những gì chúng tôi nói với nó để làm. Chúng tôi đang làm toán học như x chia y. Và cả x và y, mỗi dòng mã trước đó, là số nguyên. 

Hơn nữa, trên đường 15, chúng tôi nói printf, hey, printf plug-in một số nguyên, plug-in một số nguyên, plug-in một integer-- đặc biệt x, và sau đó y, và sau đó x chia cho y. x và y là kiểu int. Chúng tôi đang tốt ở đó. 

Nhưng những gì đang x chia x? x chia y nên được, toán học, 1/10, hoặc 0.1, đó là một số thực, một số thực có, khả năng, một điểm thập phân. Nó không phải là một số nguyên. 

Nhưng gần nhất là gì số nguyên 1/10 hay 0,1? Yeah, nó loại là số không. 0,1 là như này nhiều. Và 1 là nhiều này. Vì vậy, 1/10 là gần gũi hơn với 0 hơn là để một. 

Và vì vậy những gì C đang làm cho đây-- loại vì chúng tôi nói với nó đối với: được cắt xén nguyên đó. Nó lấy giá trị, mà lại là nghĩa vụ phải được một cái gì đó giống như 0,1000, 0 và vv. Và nó cắt bỏ tất cả mọi thứ sau dấu thập phân để tất cả những điều này công cụ, bởi vì nó không phù hợp với quan niệm của một số nguyên, mà chỉ là một số mặt hàng như tiêu cực 1, 0, 1, lên và xuống, nó ném đi tất cả mọi thứ sau dấu thập phân vì bạn không thể phù hợp với một dấu thập phân trong một số nguyên theo định nghĩa. 

Vì vậy, câu trả lời ở đây là số không. Vì vậy, làm thế nào để chúng tôi sửa lỗi này? Chúng ta cần một giải pháp tất cả cùng nhau. Và chúng ta có thể làm được điều này, như sau. 

Hãy để tôi đi trước và tạo ra một mới tập tin, chương trình này được gọi là floats.c. Và lưu nó ở đây cùng một thư mục, float.c. Và hãy để tôi đi trước và sao chép một số mã mà từ trước đó. 

Nhưng thay vì nhận được một int, chúng ta hãy làm điều này. Hãy cho tôi một giá trị dấu chấm động gọi là x. nơi một điểm nổi giá trị chỉ là nghĩa đen một cái gì đó với một dấu chấm. Nó có thể di chuyển sang trái, sang phải. Đó là một số thực. 

Và hãy để tôi gọi không được int, nhưng có được phao, đó cũng là một trong những thực đơn các tùy chọn trong thư viện C250. Hãy thay đổi y đến một phao. Vì vậy, điều này trở nên có được phao. 

Và bây giờ, chúng tôi không muốn để cắm ints. Hóa ra chúng ta phải sử dụng phần trăm f cho phao, phần trăm f cho phao, và bây giờ lưu nó. Và bây giờ, ngón tay vượt qua, làm cho phao nổi, đẹp, nổi slash dot. x sẽ là một 1. y Sẽ là 10 lần nữa. 

Và, đẹp, OK Ngoài ra tôi là chính xác. Tôi đã hy vọng cho nhiều hơn, nhưng tôi quên để viết nó. Vì vậy, chúng ta hãy đi và sửa chữa lỗi logic này. 

Hãy đi trước và lấy sau. Chúng tôi sẽ chỉ cần làm một bản sao nhỏ và dán. Và tôi sẽ nói trừ. 

Và tôi sẽ nói lần. Và tôi sẽ nói chia. Và tôi sẽ không làm theo modulo, mà không phải là Gecman đây, chia f, và lần plus-- OK, chúng ta hãy làm điều này một lần nữa. 

Hãy phao, phao nổi slash dot, và 1, 10, và- tốt đẹp, không có, OK. Vì vậy, tôi là một thằng ngốc. Vì vậy, đây là rất phổ biến khoa học máy tính phạm sai lầm ngu ngốc như thế này. 

Đối với mục đích sư phạm, những gì tôi thực sự muốn làm đã được thay đổi khoa học ở đây để cộng, trừ đi, để lần, và để phân chia, như bạn hy vọng nhận thấy trong bài tập này. Vì vậy bây giờ chúng ta hãy lập lại này chương trình, làm nổi slash dot. 

Và lần thứ ba, chúng ta hãy xem nếu nó đáp ứng mong đợi của tôi. 1, 10, nhập, có, OK, 1.000, chia cho 10.000, là 0,100000. Và hóa ra chúng ta có thể kiểm soát bao nhiêu con số này sau khi những điểm thập phân. Chúng tôi thực sự sẽ. Chúng ta sẽ quay trở lại đó. 

Nhưng bây giờ, trên thực tế, các môn toán là chính xác. Vì vậy, một lần nữa, các takeaway những gì ở đây? Nó chỉ ra rằng trong C, có không chỉ strings-- và, trên thực tế, có không thực sự, bởi vì chúng tôi thêm những người có thư viện CS50. Nhưng không chỉ là kiểu int. 

Ngoài ra còn có nổi. Và hóa ra một loạt các dữ liệu khác loại quá, mà chúng ta sẽ sử dụng trước khi dài. Hóa ra, nếu bạn muốn có một đơn nhân vật, không phải là một chuỗi ký tự, bạn có thể sử dụng chỉ cần một char. 

Chỉ ra rằng nếu bạn muốn có một bool, một giá trị Boolean, đúng hay sai chỉ, nhờ các thư viện CS50, chúng tôi đã thêm vào C kiểu dữ liệu bool là tốt. Nhưng nó cũng có mặt ở nhiều ngôn ngữ khác. Và nó chỉ ra rằng đôi khi bạn cần những con số lớn hơn sau đó đi theo mặc định với ints và nổi được. 

Và, trên thực tế, một đôi là một số sử dụng không 32 bit, nhưng 64 bit. Và một lâu dài là một con số sử dụng không 32, bit nhưng 64 bit, tương ứng, cho điểm nổi giá trị và số nguyên tương ứng. Vì vậy, hãy thực hiện thấy điều này trong hành động. 

Tôi sẽ đi trước đây và whip lên một chương trình khác. Ở đây, tôi sẽ đi trước và không bao gồm CS50.h. Và hãy để tôi đi, bao gồm tiêu chuẩn IO.h. 

Và bạn sẽ nhận thấy một cái gì đó sôi nổi đang diễn ra ở đây. Nó không phải màu sắc mã hóa mọi thứ trong theo cùng một cách như trước. Và hóa ra, đó là bởi vì tôi đã không được đưa ra các điều một tên tập tin. 

Tôi sẽ gọi con này sizeof.c, và nhấn Save. Và nhận thấy những gì xảy ra với tôi rất mã điểm trắng so với nền màu đen. Bây giờ, ít nhất có một số màu tím trong đó. Và đó là cú pháp tô sáng. 

Đó là bởi vì, khá đơn giản, tôi đã nói với các IDE loại tập tin nó là đặt cho nó một cái tên, và đặc biệt là một phần mở rộng tập tin. Bây giờ, chúng ta hãy đi trước và làm điều này. Tôi sẽ đi trước và rất chỉ đơn giản là in ra bool following-- là phần trăm LU. 

Chúng ta sẽ quay trở lại mà chỉ trong một khoảnh khắc. Và sau đó tôi sẽ in kích thước của bool. Và bây giờ, chỉ để tiết kiệm bản thân mình một thời gian, tôi sẽ làm một toàn bộ bó của các cùng một lúc. Và, đặc biệt, tôi sẽ thay đổi này đến một char và char. Điều này, tôi sẽ thay đổi một đôi và một đôi. 

Điều này, tôi sẽ thay đổi để một phao và một phao. Điều này, tôi sẽ thay đổi đến một int và int. Và một trong những điều này, tôi sẽ thay đổi đến một lâu dài. Và nó vẫn còn dùng một thời gian dài, rất dài. 

Và sau đó, cuối cùng, tôi đã cho bản thân mình là quá nhiều, chuỗi. Nó chỉ ra rằng trong C, có các nhà điều hành đặc biệt gọi là kích thước của đó là nghĩa đen đi, khi chạy, cho chúng tôi biết kích thước của mỗi một trong các biến. Và đây là một cách, bây giờ, chúng ta có thể kết nối trở lại để thảo luận tuần trước dữ liệu và đại diện. 

Hãy để tôi đi trước và biên dịch kích thước của kích thước slash dot trong. Và chúng ta hãy xem. Nó chỉ ra rằng trong C, cụ thể về CS50 IDE, cụ thể về hệ điều hành Ubuntu, mà là một hành 64-bit hệ thống trong trường hợp này, một bool sẽ sử dụng một byte của không gian. Đó là cách kích thước được đo, không bit, nhưng trong byte. Và nhớ lại rằng một byte là tám bit. Vì vậy, một bool, ngay cả khi bạn kỹ thuật chỉ cần một 0 hoặc 1, đó là một chút lãng phí như thế nào chúng tôi đã thực hiện nó. Nó thực sự sẽ sử dụng toàn bộ byte-- vì vậy tất cả các số không, là có thể tất cả những người thân, hoặc một cái gì đó như thế, hay chỉ là một 1 trong số tám bit. 

Một char, trong khi đó, được sử dụng cho một nhân vật giống như một nhân vật Ascii mỗi tuần trước, sẽ là một ký tự. Và đó synchs lên với ý niệm của chúng ta về nó là không quá 256 bits-- thay, synchs lên với nó là không có dài hơn 8 bit, mà cung cấp cho chúng tôi nhiều như 256 giá trị. Một đôi sẽ là 8 byte hoặc 64 bit. 

Một float là 4. Một int là 4. Một dài, dài là 8. Và một chuỗi là 8. Nhưng đừng lo lắng về điều đó. Chúng tôi đang đi để bóc lại lớp đó. Hóa ra, dây có thể dài hơn 8 byte. 

Và, quả thật vậy, chúng tôi đã viết dây đã, xin chào thế giới, dài hơn 8 byte. Nhưng chúng tôi sẽ trở lại mà chỉ trong một khoảnh khắc. Nhưng mất đi ở đây là sau đây. 

Bất kỳ máy tính chỉ có hữu hạn số lượng bộ nhớ và không gian. Bạn chỉ có thể lưu trữ rất nhiều các tập tin trên máy Mac hoặc máy PC của bạn. Bạn chỉ có thể lưu trữ rất nhiều các chương trình trong RAM chạy cùng một lúc, nhất thiết, thậm chí với bộ nhớ ảo, vì bạn có một số lượng hữu hạn của bộ nhớ RAM. 

Và chỉ để picture-- nếu bạn đã bao giờ mở ra một máy tính xách tay hoặc đặt thêm bộ nhớ cho một máy tính, bạn có thể không biết rằng bên trong máy tính của bạn là cái gì đó trông một chút như thế này. Vì vậy, đây chỉ là một công ty chung có tên Quan trọng là làm cho bộ nhớ RAM cho máy tính. Và RAM là nơi mà các chương trình sống trong khi họ đang chạy. 

Vì vậy, trên mọi máy Mac hoặc PC, khi bạn tăng gấp đôi nhấp vào một chương trình, và nó mở ra, và nó sẽ mở ra một số tài liệu Word hay đại loại thế, nó lưu nó tạm thời trong RAM, vì RAM là nhanh hơn hơn so với đĩa cứng của bạn, hoặc ổ đĩa trạng thái rắn của bạn. Vì vậy, nó chỉ là nơi chương trình đi để sống khi họ đang chạy, hoặc khi tập tin đang được sử dụng. 

Vì vậy, bạn có những thứ mà nhìn như bên này của máy tính xách tay của bạn, hoặc những điều hơi lớn hơn bên trong của máy tính để bàn của bạn. Nhưng quan trọng là bạn chỉ có một số lượng hữu hạn của những điều này. Và chỉ có một số lượng hữu hạn của phần cứng ngồi trên bàn này ngay đây. 

Vì vậy, chắc chắn, chúng ta không thể lưu trữ số dài vô hạn. Và, tuy nhiên, nếu bạn suy nghĩ lại về trường lớp, bao nhiêu chữ số có thể bạn có về bên phải của một điểm thập phân? Đối với vấn đề đó, có bao nhiêu chữ số có thể bạn phải trái của một điểm thập phân? Thực sự, vô cùng nhiều. 

Bây giờ, con người chúng ta có thể chỉ biết làm thế nào để phát âm triệu, và tỷ, nghìn tỷ, và nghìn triệu triệu, và quintillion. Và tôi là đẩy các giới hạn của tôi understanding-- hoặc my-- Tôi hiểu con số, nhưng tôi phát âm của con số. Nhưng họ có thể nhận được vô cùng lớn với vô hạn số chữ số bên trái hoặc bên phải của một điểm thập phân. 

Nhưng máy tính chỉ có một số lượng hữu hạn của bộ nhớ, một số hữu hạn các bóng bán dẫn, một số hữu hạn các bóng đèn bên trong. Vì vậy, những gì sẽ xảy ra khi bạn chạy ra khỏi không gian? Nói cách khác, nếu bạn nghĩ lại tuần trước khi chúng tôi nói chuyện về những con số mình đang được đại diện trong hệ nhị phân, giả sử rằng chúng ta đã có 8-bit giá trị này ở đây. 

Và chúng tôi có bảy 1 và một 0. Và giả sử rằng chúng ta muốn thêm 1 giá trị này. Đây là một số thực sự lớn ngay bây giờ. 

Đây là 254, nếu tôi nhớ toán học từ tuần cuối cùng bên phải. Nhưng nếu tôi thay đổi rằng ngoài cùng bên phải 0 đến 1? Các số nguyên, của Tất nhiên, trở thành tám 1. Vì vậy, chúng tôi vẫn tốt. 

Và đó có thể đại diện 255, mặc dù phụ thuộc vào bối cảnh nó thực sự có thể đại diện một số âm. Nhưng thêm vào đó một thời điểm khác. Điều này cảm thấy như nó về cao như tôi có thể đếm. 

Bây giờ, nó chỉ có 8 bit. Và máy Mac của tôi, chắc chắn, có cách hơn 8 bit của bộ nhớ. Nhưng nó không có giới hạn. Vì vậy, các lập luận tương tự áp dụng, thậm chí nếu chúng ta có nhiều hơn những cái trên màn hình. 

Nhưng điều gì sẽ xảy ra nếu bạn lưu trữ số này, 255, và bạn muốn tính cao hơn 1 chút? Bạn muốn đi 255-256. Vấn đề, tất nhiên, là nếu bạn bắt đầu đếm từ số không như tuần trước, bạn không thể tính là cao là 256, hãy để một mình 257, hãy để một mình 258, m vì những gì sẽ xảy ra khi bạn thêm 1? Nếu bạn làm trường lớp cũ phương pháp tiếp cận, bạn đặt một 1 ở đây, và sau đó 1 cộng 1 là 2, nhưng đó là thực sự là một số không, bạn mang 1, mang 1, mang 1. Tất cả những điều này, những nhân 1, đi đến số không. Và bạn gió lên, vâng, như ai đó chỉ ra, 1 ở phía bên tay trái. Nhưng tất cả mọi thứ bạn có thể thực sự thấy và phù hợp trong bộ nhớ chỉ là tám 0, mà là để nói tại một số điểm nếu bạn, một máy tính, cố gắng đếm đủ cao, bạn đang đi để bọc xung quanh, có vẻ như, bằng không, hoặc thậm chí có tiêu cực con số, mà thậm chí còn thấp hơn số không. 

Và chúng tôi loại có thể thấy điều này. Hãy để tôi đi trước và viết một chương trình nhanh chóng thực sự ở đây. Hãy để tôi đi trước và viết một chương trình gọi là tràn. Bao gồm CS50.h, bao gồm chuẩn IO.h-- oh, Tôi thực sự bỏ lỡ tô sáng cú pháp của tôi. Vì vậy, hãy lưu này như overflow.c. 

Và bây giờ int void-- chính và chẳng bao lâu, chúng tôi sẽ trở lại để giải thích lý do tại sao chúng tôi tiếp tục viết int void main. Nhưng hiện nay, chúng ta chỉ cần làm nó, dùng nó cho các cấp. Hãy cho bản thân mình một int, và khởi tạo nó để 0. 

Hãy để sau đó nhân làm cho int tôi nhận zero-- thực sự, chúng ta hãy làm một vòng lặp vô hạn và xem những gì sẽ xảy ra. Trong khi sự thật, sau đó hãy in ra n là phần trăm i, gạch chéo ngược n, plug-in n. Nhưng, bây giờ, chúng ta hãy làm n được n + 1. 

Vì vậy, nói cách khác, trên mỗi lần lặp của vòng lặp vô hạn này, chúng ta hãy giá trị của n, và thêm 1 vào nó, và sau đó lưu kết quả lại n bên trái. Và, trên thực tế, chúng tôi đã nhìn thấy cú pháp hơi như thế này, một thời gian ngắn. Một trick mát là thay vì viết bài này ra, bạn thực sự có thể nói một cộng với n bằng 1. 

Hoặc nếu bạn thực sự muốn được ưa thích, bạn có thể nói n cộng với cộng với dấu chấm phẩy. Nhưng những Hai người này đang chỉ những gì chúng ta gọi cú pháp đường cho việc đầu tiên. 

Điều đầu tiên là rõ ràng hơn, hoàn toàn tốt đẹp, hoàn toàn chính xác. Nhưng điều này là phổ biến hơn, tôi sẽ nói. Vì vậy, chúng tôi sẽ làm điều này chỉ trong một khoảnh khắc. 

Bây giờ chúng ta làm tràn, mà âm thanh chứ không đáng ngại, dấu chấm dấu gạch chéo tràn. Hãy xem, n ấy ngày càng lớn mạnh. Nhưng hãy để suy nghĩ, làm thế nào lớn n có thể nhận được? 

n là một số nguyên. Chúng tôi nhìn thấy một thời điểm trước đây với kích thước của ví dụ mà một int là bốn byte. Chúng tôi biết từ tuần trước, bốn byte là 32 bit, vì 8 lần 4, đó là 32. Đó sẽ là 4 tỷ đồng. 

Và chúng tôi đang lên đến 800.000. Điều này sẽ mất mãi mãi để tính là cao như tôi có thể có thể. Vì vậy, tôi sẽ đi trước, như bạn có thể trước khi dài, và nhấn Control C-- thẳng thắn, Control C, rất nhiều, nơi kiểm soát C thường phương tiện hủy. Thật không may, bởi vì đây đang chạy trong đám mây, đôi khi các đám mây là phun ra rất nhiều công cụ, rất nhiều đầu ra, nó sẽ mất một ít thời gian cho đầu vào của tôi để có được các đám mây. Vì vậy, mặc dù tôi nhấn Control C một vài giây, điều này chắc chắn là một bên hiệu lực của một vòng lặp vô hạn. 

Và như vậy trong trường hợp này, chúng tôi sẽ rời khỏi đó được. Và chúng ta sẽ thêm một cửa sổ thiết bị đầu cuối trên đây với các cộng, trong đó tất nhiên không như thế, vì nó vẫn nghĩ. Và chúng ta hãy đi trước và được hợp lý hơn một chút. 

Tôi sẽ đi trước và làm này chỉ có hữu hạn nhiều lần. Hãy sử dụng một vòng lặp for, mà tôi đã đề cập đến trước đó. Làm thôi nào. Hãy cho tôi một biến int i được 0. i nhỏ hơn, hãy nói, 64 i ++. Và bây giờ hãy để tôi đi trước và in ấn ra n là phần trăm tôi, dấu phẩy n. Và sau đó n-- này vẫn là sẽ mất mãi mãi. Làm thôi nào. 

n được n lần 2. Hoặc chúng ta có thể được ưa thích và làm lần = 2. Nhưng chúng ta hãy chỉ nói n bằng chính nó, lần 2. Nói cách khác, trong này phiên bản mới của chương trình, Tôi không muốn chờ đợi mãi mãi từ như 800.000 đến 4 tỷ đồng. Hãy chỉ vượt qua điều này với. 

Hãy thực sự tăng gấp đôi n mỗi lần. Trong đó, thu hồi, tăng gấp đôi là đối diện có, tất nhiên. Và trong khi tuần trước chúng tôi có một cái gì đó một lần nữa, và một lần nữa, và một lần nữa, siêu nhanh, tăng gấp đôi chắc chắn sẽ đưa chúng ta từ 1 đến tốt nhất giá trị mà chúng ta có thể đếm đến với một int. 

Vì vậy, chúng ta hãy làm chính xác điều này. Và chúng ta sẽ trở lại vấn đề này trước khi dài. Nhưng điều này, một lần nữa, giống như khối lặp lại trong Scratch. Và bạn sẽ sử dụng này trước khi dài. 

Điều này chỉ có nghĩa là đếm từ con số không lên, nhưng không bằng nhau, đến 64. Và trên mỗi lần lặp này vòng lặp, chỉ cần giữ incrementing i. Vì vậy, i ++ - và xây dựng chung này trên dòng 7 chỉ là một cách siêu phổ biến lặp đi lặp lại một số dòng mã, một số số lần. Những dòng mã? Những dấu ngoặc nhọn, như bạn có thể lượm lặt từ bây giờ, nghĩa là, làm như sau. 

Đó là trong Scratch như thế, khi nó có các khối màu vàng và màu sắc khác loại ôm hôn hoặc ôm khối khác. Đó là những gì những người xoăn niềng răng đang làm ở đây. Vì vậy, nếu tôi nhận được cú pháp của tôi right-- bạn có thể nhìn thấy biểu tượng cà rốt trong các phương tiện C đó là bao nhiêu lần tôi đã cố gắng để giải quyết vấn đề này. Vì vậy, hãy để nhân thoát khỏi một mà hoàn toàn, và đóng cửa sổ đó. Và chúng tôi sẽ sử dụng những cái mới. Hãy tràn, dấu chấm dấu gạch chéo tràn, Enter, tất cả các quyền, nó trông xấu lúc đầu. Nhưng chúng ta hãy di chuyển trở lại trong thời gian, bởi vì tôi đã làm điều này 64 lần. 

Và thông báo thời gian đầu tiên, n là 1. lần thứ hai, n là 2, sau đó 4, sau đó 8, sau đó 16. Và có vẻ như rằng ngay sau khi Tôi nhận được để khoảng 1 tỷ đồng, nếu tôi tăng gấp đôi nó một lần nữa, rằng nên cho tôi 2 tỷ. Nhưng hóa ra, đó là ngay trên đỉnh. 

Và do đó, nó thực sự tràn một int từ 1 tỷ để khoảng âm 2 tỷ đồng, vì một số nguyên, không giống như những con số chúng tôi được giả định vào tuần trước, có thể có cả tích cực và tiêu cực trong thực tế và trong một máy tính. Và như vậy ít nhất một trong những bit là bị đánh cắp một cách hiệu quả. Vì vậy, chúng tôi thực sự chỉ có 31 bit, hoặc 2 tỷ giá trị có thể. 

Nhưng hiện nay, các takeaway khá đơn giản, bất cứ điều gì các con số và bất cứ điều gì các môn toán là, điều gì xấu xảy ra cuối cùng, bởi vì cuối cùng bạn đang cố gắng để hoán vị các bit một trong quá nhiều lần. Và bạn có hiệu quả đi từ tất cả 1 để có thể tất cả 0, hoặc có thể chỉ một số mô hình khác mà nó rõ ràng, tùy thuộc vào hoàn cảnh, có thể được hiểu là một số âm. Và do đó, nó sẽ có vẻ tôi cao nhất có thể tính vào chương trình đặc biệt này chỉ khoảng 1 tỷ là. Nhưng có một giải pháp một phần ở đây. Bạn biết những gì? 

Hãy để tôi thay đổi từ một int đến một lâu dài. Và hãy để tôi đi trước đây và say-- tôi sẽ có để thay đổi sang một unsigned long. Hoặc, để xem nào, tôi không bao giờ nhớ bản thân mình. 

Hãy đi trước và làm tràn. Không, đó không phải nó, LLD, cảm ơn bạn. Vì vậy, đôi khi Clang có thể hữu ích. Tôi không nhớ những gì định dạng specifier là một lâu dài. 

Nhưng, thực sự, Clang nói với tôi. Màu xanh lá cây là một số loại tốt, vẫn có nghĩa là bạn đã thực hiện một sai lầm. Nó đoán rằng tôi có nghĩa là LLD. 

Vì vậy, hãy để tôi mang nó là lời khuyên, một dài số thập phân dài, tiết kiệm mà. Và hãy để tôi chạy lại nó, chấm cắt giảm tràn, Enter. Và bây giờ những gì là mát mẻ là điều này. 

Nếu tôi di chuyển ngược thời gian, chúng tôi vẫn bắt đầu đếm ở cùng place-- 1, 2, 4, 8, 16. Thông báo, chúng tôi nhận được tất cả các cách lên đến 1 tỷ đồng. Nhưng sau đó chúng tôi một cách an toàn đến 2 tỷ đồng. 

Sau đó chúng ta có được đến 4 tỷ đồng, sau đó 8 tỷ đồng, 17 tỷ đồng. Và chúng tôi đi cao hơn, và cao hơn và cao hơn. Cuối cùng, điều này, quá, nghỉ giải lao. 

Cuối cùng, với một lâu dài, đó là giá trị 64-bit, không một giá trị 32-bit, nếu bạn đếm quá cao, bạn quấn quanh 0. Và trong trường hợp này, chúng tôi xảy ra để kết thúc với một số âm. 

Vì vậy, đây là một vấn đề. Và nó quay ra rằng điều này vấn đề không phải là tất cả những phức tạp. Mặc dù tôi đã cố tình gây ra nó với những sai lầm, hóa ra chúng ta thấy nó loại tất cả xung quanh chúng ta, hoặc ít nhất là một số trong chúng ta làm. 

Vì vậy, trong Lego Star Wars, nếu bạn đã từng chơi các trò chơi, nó quay ra bạn có thể đi xung quanh phá vỡ những thứ trong LEGO thế giới, và thu thập tiền xu, về cơ bản. Và nếu bạn đã từng chơi trò chơi này quá nhiều thời gian, như cá nhân giấu tên này ở đây đã làm, tổng số tiền cổ mà bạn có thể thu thập là, dường như, 4 tỷ đồng. 

Bây giờ, với nó thực sự làm tròn. Vì vậy, LEGO đã cố gắng để giữ cho mọi thứ người dùng thân thiện. Họ đã không làm điều đó một cách chính xác 2 32 điện, mỗi tuần trước. Nhưng 4 tỷ là một lý do. Có vẻ như, dựa trên thông tin này, mà LEGO, và công ty mà làm phần mềm thực tế này, quyết định rằng số lượng tối đa của đồng tiền người sử dụng có thể tích lũy là, thực sự, 4 tỷ đồng, bởi vì họ đã chọn trong mã của họ sử dụng không phải là dài lâu, rõ ràng, nhưng chỉ là một số nguyên, một unsigned số nguyên, chỉ có một số nguyên dương, mà giá trị tối đa khoảng là. Vâng, đây là một số khác vui. Vì vậy, trong các trò chơi Civilization, mà một số bạn có thể quen với nó chỉ ra rằng năm trước đó là một lỗi trong trò chơi đó đây nếu bạn chơi vai trò Gandhi trong game, thay vì anh ta là rất hòa bình, thay vào đó là vô cùng, vô cùng tích cực, trong một số trường hợp. Đặc biệt, cách mà nền văn minh công việc là vì nếu bạn, người chơi, áp dụng dân chủ, của bạn điểm gây hấn được giảm đi hai, do đó trừ đi trừ đi, và sau đó trừ đi trừ. 

Vì vậy, bạn trừ đi 2 từ iterating thực tế của bạn. Thật không may, nếu bạn là iterating ban đầu 1, và bạn trừ 2 từ nó sau khi áp dụng dân chủ như Gandhi ở đây có thể đã làm, bởi vì ông rất passive-- 1 trên quy mô của hấn. Nhưng nếu anh có chính dân chủ, sau đó ông đi từ 1 đến 1 âm. 

Thật không may, họ đã sử dụng số unsigned, có nghĩa là họ đối xử thậm chí tiêu cực số như thể họ là tích cực. Và nó chỉ ra rằng tương đương tích cực của âm 1, trong các chương trình máy tính điển hình, là 255. Vì vậy, nếu có chính Gandhi dân chủ, và do đó có điểm gây hấn của ông giảm, nó thực sự cuộn xung quanh đến 255 và làm cho anh ta nhiều nhất nhân vật tích cực trong các trò chơi. Vì vậy, bạn có thể Google lên trên này. Và thực sự nó là, một lỗi lập trình ngẫu nhiên, nhưng đó là bước khá các truyền thuyết từ bao giờ. 

Đó là tất cả vui vẻ và dễ thương. đáng sợ hơn nữa là khi thực tế thiết bị thế giới thực, và không phải trò chơi, có những lỗi tương tự. Trong thực tế, chỉ một năm trước, một bài viết đến hiểu về các máy bay Boeing 787 Dreamliner. 

Và các bài viết ở đầu lướt qua đọc một chút phức tạp. Nhưng nó nói điều này, một phần mềm dễ bị tổn thương trong của Boeing mới 787 Dreamliner máy bay phản lực có khả năng gây ra các phi công để mất quyền kiểm soát máy bay, có thể vào giữa chuyến bay, các quan chức FAA hãng hàng không cảnh báo thời gian gần đây. Đó là việc xác định rằng một mô hình 787 máy bay đã được cung cấp liên tục trong 248 ngày có thể mất tất cả dòng điện xoay chiều, AC, năng lượng điện do các máy phát điện đơn vị kiểm soát, GCUs, đồng thời đi vào chế độ an toàn không. Đó là loại mất tôi. Nhưng các bản ghi nhớ đã nói, OK, bây giờ tôi đã nhận rằng, bệnh này được gây ra bởi một phần mềm chống lại nội bộ để điều khiển máy phát điện đơn vị sẽ tràn sau khi 248 ngày của điện liên tục. Chúng tôi đang phát hành này chú ý để tránh mất của tất cả các AC điện điện, có thể dẫn đến mất kiểm soát của máy bay. 

Vì vậy, theo nghĩa đen, có một số nguyên, hoặc một số kiểu dữ liệu tương đương, được sử dụng trong phần mềm trong một chiếc máy bay thực tế rằng nếu bạn giữ cho máy bay của bạn đủ lâu, mà dường có thể là trường hợp nếu bạn chỉ cần chạy họ liên tục và không bao giờ rút máy bay của bạn, có vẻ như, hoặc để cho pin của nó chết, cuối cùng sẽ đếm lên, lên, lên, lên, lên, và lên. 

Và, bởi bản chất, một số lượng hữu hạn của bộ nhớ sẽ tràn, lăn trở lại không hoặc một số giá trị tiêu cực, một tác dụng phụ của nó là các Thực tế đáng sợ thật rằng chiếc máy bay có thể cần được khởi động lại, hiệu quả, hoặc có thể rơi, tồi tệ hơn, khi nó bay. Vì vậy, các loại của các vấn đề vẫn còn với chúng tôi, even-- đây là một bài viết năm 2015, tất cả các đáng sợ hơn nữa khi bạn không nhất thiết phải hiểu, đánh giá cao, hoặc dự đoán những loại lỗi. 

Vì vậy, nó quay ra có một khác điều xấu về biểu diễn dữ liệu. Nó chỉ ra rằng thậm chí nổi là loại sai lầm, bởi vì phao nổi, quá, Tôi đề xuất được 32 bit, hoặc có lẽ 64 nếu bạn sử dụng một đôi. Nhưng đó vẫn là hữu hạn. 

Và nắm bắt được rằng nếu bạn có thể đưa một số lượng vô hạn các số sau dấu thập phân, không có cách nào bạn có thể đại diện cho tất cả các thể con số mà chúng tôi được dạy trong lớp học có thể tồn tại trên thế giới. Một máy tính, về cơ bản, có tới chọn một tập hợp con của những con số thể hiện chính xác. 

Bây giờ, máy tính có vòng có thể một chút, và có thể cho phép bạn để khoảng cửa hàng bất kỳ số nào bạn có thể muốn. Nhưng chỉ bằng trực giác, nếu bạn có một số hữu hạn các bit, bạn chỉ có thể hoán vị cho họ trong rất nhiều cách hữu hạn. Vì vậy, bạn có thể không có thể sử dụng một số lượng hữu hạn các hoán vị của các bit, mẫu số không và những người thân, đại diện cho một vô hạn số lượng các số, điều này cho thấy rằng máy tính có thể rất tốt được nói dối với chúng tôi đôi khi. 

Trong thực tế, chúng ta hãy làm điều này. Hãy để tôi quay trở lại vào CS50 IDE. Hãy để tôi đi trước và tạo ra một chương trình nhỏ gọi là không chính xác, để cho thấy rằng máy tính được, quả thực, không chính xác. 

Và hãy để tôi đi trước và bắt đầu với một số mã có từ trước, và bây giờ chỉ cần làm như sau. Hãy để tôi đi trước và làm printf, phần trăm f, n xuyệc ngược, 1 chia cho 10. Nói cách khác, chúng ta hãy cùng tìm hiểu sâu hơn 1/10, như 1 và chia cho 10. Chắc chắn, một máy tính có thể đại diện cho 1/10. 

Vì vậy, chúng ta hãy đi trước và thực hiện không chính xác. Hãy xem. Format định gõ đôi. Nhưng đối số có kiểu int. Những gì đang xảy ra? 

Oh, thú vị, vì vậy nó là một bài học kinh nghiệm từ trước. Tôi đang nói, hey, máy tính chương trình tôi một float với trăm f. Nhưng tôi cho nó 2 ints. Vì vậy, nó quay ra, tôi có thể sửa chữa này trong một vài cách. 

Tôi chỉ có thể biến một thành 1.0, và 10 thành 10,0, mà sẽ, thực sự, có tác dụng chuyển đổi chúng vào floats-- vẫn hy vọng cùng một số. Hoặc nó quay ra có điều gì đó chúng ta sẽ thấy một lần nữa trước khi dài. Bạn có thể cast các con số. 

Bạn có thể sử dụng dấu ngoặc đơn này biểu thức, bạn có thể nói, hey, máy tính, thực hiện việc này 10, mà tôi biết là một int. Nhưng đối xử với nó, xin vui lòng, như thể đó là một phao. Nhưng điều này cảm thấy không cần thiết phức tạp. 

Đối với mục đích của chúng tôi ngày hôm nay, chúng ta hãy chỉ theo nghĩa đen làm cho họ nổi giá trị điểm với một điểm thập phân, như thế này. Hãy để tôi đi trước và chạy lại, làm cho không chính xác, tốt, dấu chấm dấu gạch chéo không chính xác, nhập. OK, chúng tôi đang tìm kiếm tốt. 

1 chia cho 10, theo tôi Mac ở đây, là, thực sự, 0,100000. Bây giờ, tôi đã được dạy trong trường lớp có phải là một số lượng vô hạn của 0 của. Vì vậy, hãy thử ít nhất một để xem một số trong những người. Nó chỉ ra rằng printf là một chút fancier vẫn hơn chúng ta đã sử dụng. Hóa ra bạn không cần phải chỉ định chỉ phần trăm f, hoặc chỉ phần trăm tôi. Bạn thực sự có thể chỉ định một số tùy chọn điều khiển ở đây. 

Cụ thể, tôi sẽ để nói, hey, printf, thực sự cho tôi 10 điểm thập phân. Vì vậy, có vẻ một chút lạ. Nhưng bạn nói phần trăm, dot, bao nhiêu số bạn muốn xem sau điểm thập phân, và sau đó f cho bằng phẳng, chỉ vì đó là những tài liệu nói rằng. Hãy để tôi đi trước và tiết kiệm mà. 

Và hãy chú ý quá, tôi nhận được mệt mỏi của gõ lại mọi thứ. Vì vậy, tôi chỉ cần thiết lập lên và mũi tên xuống trên các phím của tôi ở đây. Và nếu tôi tiếp tục đánh lên, bạn có thể xem tất cả các lệnh mà tôi thực hiện, hoặc không đúng cách thực hiện. 

Và tôi sẽ đi trước bây giờ và không thực sự sử dụng, rõ ràng. Hãy tính thiếu chính xác, chấm giảm imprecision-- vậy những gì tôi đã được dạy trong học lớp kiểm tra ra. Ngay cả khi tôi in nó đến 10 chữ số thập phân đặt nó, thực sự, là 0,10000. Nhưng bạn biết những gì? 

Hãy có được một chút tham lam. Hãy nói rằng, như thế, chỉ cho tôi 55 chỉ sau khi các số thập phân. Hãy thực sự mất này chương trình ra cho một spin. Hãy để tôi làm lại nó với make không chính xác, chấm dấu gạch chéo, không rõ ràng. 

Và ở đây chúng tôi đi. thời thơ ấu của bạn là một lời nói dối. Rõ ràng, 1 chia cho 10 thực sự là 0.100000000000000005551115123-- 

Điều gì đang xảy ra? Vâng, nó quay ra, nếu bạn loại tìm đủ xa ra trong tiềm ẩn đại diện này số lượng, nó thực sự là không chính xác 1/10 hay 0,1 và một số lượng vô hạn của số không. Bây giờ, tại sao vậy? 

Vâng, mặc dù đây là một đơn giản số để con người chúng ta, 1 chia cho 10, nó vẫn là một trong vô số con số mà chúng ta có thể nghĩ ra. Nhưng một máy tính chỉ có thể đại diện hữu hạn số lượng nhiều như vậy. Và như vậy, hiệu quả, những gì máy tính được hiển thị chúng tôi là gần gũi nhất của nó xấp xỉ với số chúng ta muốn tin là 1/10, hoặc thực sự 0,10000 vô cùng tận. 

Thay vào đó, mặc dù, đây là gần như nó có thể nhận được. Và, quả thật vậy, nếu bạn nhìn bên dưới mui xe, như chúng ta đang ở đây bằng cách tìm kiếm 55 chữ số sau chữ số thập phân, chúng ta thực sự nhìn thấy thực tế đó. Bây giờ là một sang một bên, nếu bạn đã bao giờ nhìn thấy movie-- hầu hết các bạn có thể haven't-- nhưng Superman 3 cách đây vài năm, Richard Pryor chất đòn bẩy này thực tế trong công ty của mình để ăn cắp rất nhiều của phân số và các phần phân đoạn của các đồng xu, vì company-- khi tôi gọi lại, nó được một while-- cơ bản là vứt đi bất cứ điều gì đó không phù hợp vào các khái niệm về xu. 

Nhưng nếu bạn thêm lên tất cả những nhỏ xíu, nhỏ xíu, con số nhỏ bé lại, và một lần nữa, và một lần nữa, bạn có thể, như trong trường hợp của mình, làm cho một số lượng tốt của tiền bạc. 

Đó là ý tưởng tương tự đã được tách ra bởi một nhiều gần đây, nhưng hiện vẫn còn lớn tuổi bộ phim, được gọi là không gian văn phòng, nơi mà những kẻ trong bộ phim đó, đã làm điều tương tự, vặn nó lên hoàn toàn, đã kết thúc với quá nhiều tiền trong tài khoản ngân hàng của họ. Đó là tất cả đều rất đáng ngờ. Nhưng vào cuối ngày, không chính xác là tất cả xung quanh chúng ta. 

Và điều đó cũng có thể được đáng sợ như vậy. Nó chỉ ra rằng Superman 3 và không gian văn phòng sang một bên, có có thể có một số rất thực tế nhánh trên thế giới những thực tế của không chính xác đại diện của dữ liệu mà ngay cả con người chúng ta để ngày nay không nhất thiết hiểu cũng như chúng ta nên, hoặc nhớ thường xuyên như chúng ta nên. Và, quả thật vậy, các clip sau đây là từ một cái nhìn tại một số thế giới rất thực tế chi nhánh của những gì sẽ xảy ra nếu bạn không đánh giá cao sự thiếu chính xác mà có thể xảy ra trong số đại diện. 

[XEM LẠI VIDEO] 

-Computers, Tất cả chúng tôi đến để chấp nhận những vấn đề thường bực bội mà đi với them-- lỗi, virus, và phần mềm ổn định, cho giá nhỏ để trả tiền cho sự tiện lợi. Nhưng trong công nghệ cao và tốc độ cao chương trình không gian và quân sự ứng dụng, những vấn đề nhỏ nhất có thể được phóng đại thành thảm họa. 

Ngày 04 tháng 6 1996, các nhà khoa học chuẩn bị để khởi động một người lái Ariane 5 tên lửa. Nó được thực hiện khoa học vệ tinh được thiết kế để thiết lập một cách chính xác như thế nào tương tác từ trường của trái đất với gió mặt trời. Các tên lửa được xây dựng cho Cơ quan Vũ trụ châu Âu, và dỡ bỏ khỏi cơ sở của nó trên bờ biển French Guiana. 

-Tại Khoảng 37 giây vào các chuyến bay, họ lần đầu tiên nhận thấy một cái gì đó đã đi sai. Các vòi phun được xoay trong một cách mà họ thực sự không nên. Khoảng 40 giây vào chuyến bay, rõ ràng, chiếc xe đã gặp rắc rối. 

Và đó là khi họ thực hiện một quyết định để tiêu diệt nó. Các sĩ quan an toàn phạm vi, với ruột vô cùng, nhấn nút, thổi lên các tên lửa, trước khi nó có thể trở thành một mối nguy hiểm cho sự an toàn công cộng. 

-Đây Là trinh nữ hành trình của tên lửa Ariane 5. Và nó bị phá hủy mất đặt vì một lỗ hổng nhúng trong phần mềm của tên lửa. -Các Vấn đề trên Ariane là rằng có một con số cần 64 bit để thể hiện. Và họ muốn chuyển đổi nó cho một số 16-bit. Họ giả định rằng số sẽ không bao giờ là rất lớn, mà hầu hết những người chữ số trong một số 64-bit là zero. Họ đã sai lầm. 

-Các Sự bất lực của một chương trình phần mềm để chấp nhận các loại số được tạo ra bởi khác là gốc rễ của sự thất bại. phát triển phần mềm đã trở thành một phần rất tốn kém của công nghệ mới. Tên lửa Ariane đã rất thành công, rất nhiều các phần mềm tạo ra cho nó cũng là được sử dụng trong các tên lửa Ariane 5. 

-Các Vấn đề cơ bản là các Ariane 5 là nhanh hơn, tăng tốc nhanh hơn. Và các phần mềm đã không chiếm đó. 

-Các Phá hủy các tên lửa là một thảm họa tài chính khổng lồ, tất cả do một lỗi phần mềm phút. Nhưng đây không phải là lần đầu tiên Hiện vấn đề chuyển đổi dữ liệu đã cản công nghệ tên lửa hiện đại. 

-Trong Năm 1991, với sự bắt đầu Chiến tranh vùng Vịnh đầu tiên, Patriot Missile kinh nghiệm một loại tương tự của vấn đề chuyển đổi số. Và kết quả là, 28 người, 28 lính Mỹ, đã bị giết chết, và về 100 người khác bị thương, khi Patriot, mà đã được yêu để bảo vệ chống lại các tên lửa Scud đến, không bắn một tên lửa. 

-Khi Iraq xâm chiếm Kuwait, và Mỹ đưa ra Desert Storm vào đầu năm 1991, pin Patriot Missile đã được triển khai để bảo vệ Saudi Arabia và Israel từ các cuộc tấn công tên lửa Scud của Iraq. The Patriot là một Mỹ tầm trung bề mặt để hệ thống không khí, chế tạo do công ty Raytheon. 

-Các Kích thước của các máy bay đánh chặn Patriot chính nó là dài khoảng khoảng 20 feet. Và nó chỉ nặng khoảng 2.000 bảng Anh. Và nó mang một đầu đạn hạt nhân của khoảng, Tôi nghĩ đó là khoảng 150 pounds. Và các đầu đạn hạt nhân chính nó là một vụ nổ, trong đó có mảnh vỡ xung quanh nó. Vỏ của đầu đạn là được thiết kế để hoạt động như đạn chì. 

-Các Tên lửa được tiến hành bốn trên mỗi container, và được vận chuyển bằng một trailer bán. 

-Các Hệ thống Patriot chống tên lửa đi lại ít nhất 20 năm nay. Nó được thiết kế ban đầu như một tên lửa phòng không để bắn hạ máy bay của đối phương. Trong chiến tranh vùng Vịnh đầu tiên, khi chiến tranh mà đến cùng, Quân đội muốn sử dụng nó để bắn hạ tên lửa Scud, không phải máy bay. 

Không quân Iraq đã không quá nhiều của một vấn đề. Nhưng quân đội đã lo lắng về tên lửa Scud. Và do đó, họ đã cố gắng để nâng cấp Patriot. 

-Intercepting Một kẻ thù tên lửa đi du lịch tại mach 5 sắp được thử thách đủ. Nhưng khi Patriot được đưa vào phục vụ, Quân đội đã không nhận thức một sửa đổi của Iraq đã làm tên lửa Scud của họ gần như không thể đánh trúng. 

-Điều Gì đã xảy ra là các tên lửa Scud mà đã đến ở không ổn định. Họ bị lắc lư. Lý do cho điều này là người Iraq, để để có được 600 km ra khỏi một cây số 300 tên lửa tầm xa, mất cân ra khỏi đầu đạn trước. Họ đã làm cho đầu đạn nhẹ hơn. 

Vì vậy, bây giờ là Patriot cố gắng để đi vào các tên lửa Scud. Và hầu hết thời gian, đại đa số thời gian, nó sẽ chỉ bay bằng các tên lửa Scud. Một khi các nhà khai thác hệ thống Patriot nhận ra Patriot bỏ mục tiêu của mình, chúng phát nổ đầu đạn của Patriot để tránh thương vong có thể nếu nó được phép rơi xuống đất. 

-đó Là những gì hầu hết mọi người đã thấy, những quả cầu lửa lớn trên bầu trời, và hiểu nhầm chặn các đầu đạn tên lửa Scud. 

-Although Trong đêm bầu trời, Patriots xuất hiện để được thành công phá hủy tên lửa Scud, tại Dhahran, có thể không có sai lầm về hiệu quả của nó. Có, hệ thống radar của Patriot bị mất theo dõi của một tên lửa Scud đến, và không bao giờ đưa ra do để một lỗ hổng phần mềm. Đó là những người Israel đầu tiên phát hiện ra mà còn hệ thống đã được trên, càng lớn thì sự chênh lệch thời gian trở thành, do một đồng hồ nhúng trong máy tính của hệ thống. 

-Về Hai tuần trước thảm kịch ở Dhahran, Israel báo cáo Bộ Quốc phòng mà hệ thống đã làm mất thời gian. Sau khoảng tám giờ hoặc chạy, họ nhận thấy rằng hệ thống đã trở nên đáng chú ý hơn chính xác. Bộ Quốc phòng Mỹ đáp trả bằng cách nói với tất cả các loại pin Patriot để không để lại các hệ thống trong một thời gian dài. Họ không bao giờ nói những gì một thời gian dài was-- tám giờ, 10 giờ, 1.000 giờ. Không ai biết. 

-Các Pin Patriot đóng quân tại doanh trại tại Dhahran và thiếu sót nội bộ của mình đồng hồ đã hơn 100 giờ vào đêm 25 tháng 2. 

-Nó Theo dõi thời gian với độ chính xác khoảng một phần mười của một giây. Bây giờ, một phần mười của một giây là một số thú vị, bởi vì nó không thể được thể hiện trong hệ nhị phân chính xác, mà có nghĩa là nó không thể được thể hiện một cách chính xác trong bất kỳ máy tính kỹ thuật số hiện đại. Thật khó để tin. 

Nhưng sử dụng như là một ví dụ. Hãy lấy số thứ ba. Một phần ba không thể được thể hiện trong thập phân chính xác. Một phần ba là 0,333 diễn ra trong vô cực. 

Không có cách nào để làm điều đó với độ chính xác tuyệt đối trong hệ thập phân. Đó chính là loại vấn đề đã xảy ra trong Patriot. Các hệ thống này còn chạy, tệ hơn các lỗi thời gian đã trở thành. 

-Sau 100 giờ hoạt động, lỗi trong thời gian chỉ khoảng một phần ba của một giây. Nhưng về nhắm mục tiêu một tên lửa đi du lịch tại mach 5, nó dẫn đến một theo dõi lỗi trên 600 mét. Nó sẽ là một lỗi nghiêm trọng cho những người lính trên những gì xảy ra là một vụ phóng tên lửa Scud là phát hiện bởi các vệ tinh cảnh báo sớm và họ biết rằng các tên lửa Scud là đến trong hướng chung của họ. Họ không biết nơi nó sẽ đến. 

-Nó Là bây giờ lên đến radar thành phần của hệ thống Patriot bảo vệ Dhahran để xác định vị trí và giữ theo dõi các tên lửa đối phương đến. 

-Các Radar đã rất thông minh. Nó thực sự sẽ theo dõi vị trí của tên lửa Scud, và sau đó tiên đoán nó có lẽ sẽ là lần tiếp theo radar gửi một xung ra. Đó được gọi là cổng loạt. 

-Sau Đó, một khi Patriot quyết định đủ thời gian có thông qua để quay trở lại và kiểm tra tiếp theo vị trí cho đối tượng phát hiện này, nó đi lại. Vì vậy, khi nó quay trở lại sai chỗ, nó sau đó thấy không có đối tượng. Và nó quyết định rằng không có đối tượng, đó là một phát hiện sai, và giọt đường đua. 

-Các Scud đến biến mất từ màn hình radar. Và giây sau, nó đâm sầm vào các doanh trại. Tên lửa Scud giết chết 28, và là người cuối cùng một bắn trong Chiến tranh vùng Vịnh đầu tiên. 

Buồn thay, phần mềm cập nhật đến Dhahran ngày hôm sau. Các lỗ hổng phần mềm có được cố định, đóng cửa một chương trong khó khăn lịch sử của tên lửa Patriot. 

[XEM LẠI VIDEO] DAVID J. Malan: Vì vậy, đây là tất cả để nói rằng những vấn đề về tràn và không chính xác là quá thực tế. Vì vậy, làm thế nào chúng ta có được ở đây? Chúng tôi bắt đầu với chỉ nói về printf. Một lần nữa, chức năng này in cái gì đó ra màn hình, và chúng tôi giới thiệu sau đó một vài chức năng khác từ cái gọi là thư viện CS50 của. Và chúng tôi sẽ tiếp tục thấy những đúng thời hạn. Và chúng ta, đặc biệt, sử dụng get chuỗi, và nhận được int, và bây giờ cũng được thả nổi, nhưng những người khác vẫn còn chúng tôi sẽ gặp phải và sử dụng chính mình trước khi dài. 

Nhưng thỉnh thoảng, có chúng tôi đã nhìn thấy một nhu cầu để lưu trữ những gì các chức năng tay trở lại? Họ tay chúng ta trở lại một chuỗi, hoặc một int, hoặc một phao. Và đôi khi chúng ta cần phải đặt mà string, int, float hoặc một nơi nào đó. 

Và để lưu trữ những điều đó, nhớ lại chỉ như trong Scratch, chúng tôi có các biến. Nhưng không giống như trong Scratch, trong C, chúng tôi có các loại thực tế dữ liệu variables-- loại, hơn generally-- trong số đó, một chuỗi, một int, một nổi, và những người khác vẫn còn. 

Và như vậy khi chúng ta khai báo biến trong C, chúng tôi sẽ phải khai báo kiểu dữ liệu của chúng tôi. Đây không phải là một cái gì đó chúng tôi sẽ phải làm sau đó trong học kỳ khi chúng ta chuyển đổi sang ngôn ngữ khác. Nhưng hiện nay, chúng ta cần để một tiên trước, giải thích cho các máy tính loại biến chúng ta muốn nó cho chúng ta. 

Bây giờ, trong khi đó, để in những loại định dạng dữ liệu, chúng ta phải nói printf những gì mong đợi. Và chúng ta đã thấy phần trăm s cho các chuỗi, và phần trăm tôi cho các số nguyên, và một vài người khác đã. Và những người chỉ đơn giản là yêu cầu cho các bài thuyết trình trực quan thông tin đó. 

Và mỗi người trong những thực sự có thể được parametrized hoặc tinh chỉnh một cách nào đó, nếu bạn muốn tiếp tục kiểm soát loại đầu ra mà bạn nhận được. Và, trên thực tế, nó chỉ ra rằng không chỉ là có dấu chéo ngược n cho một dòng mới. Có cái gì khác được gọi là dấu chéo ngược r cho một trở về vận chuyển, mà là hơn giống như một máy đánh chữ trường học cũ, và cũng có Windows được sử dụng trong nhiều năm. 

Có t dấu chéo ngược cho các tab. Hóa ra, nếu bạn muốn báo giá gấp đôi bên trong một chuỗi, nhớ lại rằng chúng ta đã sử dụng giá gấp đôi gấp đôi quote ở bên trái và bên phải kết thúc của chuỗi của chúng tôi cho đến nay. Điều đó dường như để gây nhầm lẫn thứ. 

Nếu bạn muốn đặt một đôi báo ở giữa một string-- và, thực sự, nó là khó hiểu để xem. Và như vậy bạn có để thoát khỏi, vì vậy để nói chuyện, một báo giá gấp đôi với một cái gì đó như, theo nghĩa đen, dấu chéo ngược nháy kép. Và có một số khác vẫn còn. Và chúng ta sẽ thấy nhiều hơn những trong thực tế sử dụng trước khi dài. 

Vì vậy, bây giờ chúng ta chuyển từ dữ liệu, và đại diện, và toán tử số học, tất cả trong đó đã cho chúng tôi một số tòa nhà khối nào đó để chơi. Nhưng bây giờ chúng ta hãy thực sự cung cấp chúng tôi phần còn lại của từ vựng rằng chúng tôi đã có Hồi tuần trước, Scratch bằng cách lấy một cái nhìn tại một số khác cấu trúc trong C-- không phải tất cả trong số họ. Nhưng những ý tưởng chúng tôi về để xem thực sự chỉ để nhấn mạnh bản dịch từ một ngôn ngữ, Scratch, khác, C. 

Và theo thời gian, chúng ta sẽ nhận nhiều công cụ cho bộ công cụ của chúng tôi, có thể nói, cú pháp. Và, thực sự, bạn sẽ thấy rằng những ý tưởng bây giờ là khá quen thuộc với tuần trước. Vì vậy, hãy làm điều này. 

Hãy đi trước và whip lên một chương trình mà thực sự sử dụng một số biểu thức, một biểu thức Boolean. Hãy để tôi đi trước đây và tạo ra một tập tin mới. Tôi sẽ gọi condition.c này. 

Hãy để tôi đi trước và bao gồm các thư viện CS50. Và hãy để tôi đi trước và bao gồm chuẩn IO.h cho các chức năng của chúng tôi, và printf, và tương ứng hơn. Hãy để tôi cung cấp cho bản thân mình mà soạn sẵn của void main int, mà chúng tôi sẽ giải thích trở lại trong tương lai. 

Bây giờ hãy để tôi đi trước và cho bản thân mình một int qua get int. Sau đó, hãy để tôi đi trước và làm điều này. Tôi muốn nói rằng nếu tôi là less-- hãy phân biệt giữa tích cực, tiêu cực, hoặc không có giá trị. 

Vì vậy, nếu tôi là ít hơn không, cho tôi chỉ có chương trình này chỉ đơn giản là nói, tiêu cực, dấu chéo ngược n, khác nếu tôi là lớn hơn không. Bây giờ tôi, tất nhiên, sẽ nói printf tích cực, dấu chéo ngược n. Và sau đó khác if-- tôi có thể làm điều này. 

Tôi có thể làm gì nếu tôi bằng 0. Nhưng tôi muốn được làm tại ít nhất một sai lầm rồi. Nhớ lại rằng dấu bằng là không bình đẳng, như con người chúng ta biết điều đó. 

Nhưng đó là toán tử gán. Và chúng tôi không muốn để mất 0 trên phải và đặt nó trong i bên trái. Vì vậy, để tránh sự nhầm lẫn này, hoặc có lẽ sử dụng sai dấu bằng, con người quyết định một số năm trước rằng trong nhiều ngôn ngữ lập trình khi bạn muốn kiểm tra cho sự bình đẳng giữa bên trái và bên phải, bạn thực sự sử dụng bằng bình đẳng. Vì vậy, bạn nhấn dấu bằng hai lần. Khi bạn muốn gán từ đúng sang trái, bạn sử dụng một dấu bằng. Vì vậy, chúng ta có thể làm điều này-- khác nếu tôi bằng bằng không. 

sau đó tôi có thể đi và mở dấu ngoặc nhọn của tôi, và nói, printf 0, dấu chéo ngược n, thực hiện. Nhưng hãy nhớ làm thế nào những ngã ba đường có thể làm việc. Và, thực sự, chỉ cần nghĩ về logic. tôi là một con số. Đây là một số nguyên, cụ thể. Và điều đó có nghĩa là nó sẽ được ít hơn 0, hoặc lớn hơn 0, hoặc 0. Vì vậy, có loại này ngụ ý trường hợp mặc định. 

Và như vậy chúng ta có thể, chỉ cần thích Scratch, bỏ qua những khác nếu, và chỉ cần nói gì khác. Logic, nếu bạn lập trình viên biết chỉ có ba xô vào đó một Kịch bản có thể fall-- đầu tiên, thứ hai, hoặc thứ ba trong này case-- không bận tâm thêm độ chính xác thêm và logic thêm ở đó. Chỉ cần đi trước với trường hợp mặc định đây của người khác. 

Bây giờ, chúng ta hãy đi trước sau khi tiết kiệm này, chắc điều kiện chấm giảm conditions-- không phải là một giao diện người dùng rất lớn, vì tôi không khiến người sử dụng, như tôi đã đề cập trước đó. Nhưng đó là tốt. Chúng tôi sẽ giữ nó đơn giản. Hãy thử số 42. Và đó là tích cực. Hãy thử các số âm 42, tiêu cực. 

Hãy thử các giá trị 0. Và, quả thật vậy, nó hoạt động. Bây giờ, bạn sẽ thấy có vấn đề trước dài, thử nghiệm thứ ba lần, có lẽ chưa đủ. Bạn có thể muốn kiểm tra một số số lớn hơn, một số nhỏ hơn số, một số trường hợp góc, như chúng tôi sẽ đến để mô tả chúng. 

Nhưng hiện nay, đây là một chương trình khá đơn giản. Và tôi khá chắc chắn, một cách logic, số đó rơi vào ba trường hợp. Và, thực sự, mặc dù chúng ta chỉ tập trung vào các nhược điểm tiềm năng không chính xác tương và tràn, trong thực tế mà nhiều vấn đề CS50 của, chúng ta sẽ không phải lo lắng về, tất cả các thời gian, những vấn đề về tràn và không chính xác, bởi vì, trên thực tế, trong C, nó thực sự không phải tất cả mà dễ dàng để tránh những điều đó. Nếu bạn muốn đếm lên lớn hơn, và lớn hơn, và lớn hơn, Hóa ra có các kỹ thuật bạn có thể sử dụng, thường liên quan đến những thứ được gọi là thư viện, các bộ sưu tập của mã, mà người khác đã viết rằng bạn có thể sử dụng, và các ngôn ngữ khác như Java và những người khác, thực sự làm cho nó dễ dàng hơn nhiều để đếm thậm chí cao hơn. Vì vậy, nó thực sự là một số trong những mối nguy hiểm một chức năng của ngôn ngữ mà bạn sử dụng. Và trong những tuần tới, chúng tôi sẽ xem làm thế nào nguy hiểm thực sự C có thể được nếu bạn không sử dụng nó đúng cách. Nhưng từ đó, và với Python, và JavaScript, sẽ chúng tôi lớp trên một số biện pháp bảo vệ bổ sung, và chạy ít những rủi ro. 

Vì vậy, chúng ta hãy làm nhiều hơn một chút Logic thú vị trong chương trình của chúng tôi. Vì vậy, hãy để tôi đi trước và tạo một chương trình gọi là logic chỉ để tôi có thể chơi với một số logic thực tế, logical.c. Tôi sẽ chỉ cần sao chép và dán một số mã từ trước đó vì vậy tôi có được trở lại đến thời điểm khởi đầu tốt đẹp này. 

Hãy cho tôi thời gian này làm C. char tôi sẽ cung cấp cho nó một cái tên của C chỉ vì nó là thông thường, có một kí tự từ người dùng. Và chúng ta hãy giả vờ như Tôi đang thực hiện một phần với chương trình Rm, remove chương trình trước đó nhắc nhở người sử dụng để loại bỏ một tập tin. Làm thế nào chúng ta có thể làm được điều này? 

Tôi muốn nói, nếu C bằng bằng, quote unquote, y, sau đó tôi sẽ giả định mà người dùng đã chọn yes. Tôi chỉ cần đi để in có. Nếu nó đã thực sự viết các chương trình gỡ bỏ, chúng ta có thể loại bỏ các tập tin với nhiều dòng mã. Nhưng chúng tôi sẽ giữ nó đơn giản. 

Else if c bằng bằng n-- và bây giờ đây, tôi sẽ nói, người sử dụng phải có nghĩa là không có. Và sau đó nữa, bạn biết những gì? Tôi không biết những gì khác người dùng sẽ gõ. Vì vậy, tôi chỉ muốn nói rằng đó là một lỗi, bất cứ điều gì anh hay cô thực sự gõ. 

Vì vậy, những gì đang xảy ra ở đây? Có một sự khác biệt cơ bản so với những gì tôi đã làm trong quá khứ. dấu ngoặc kép, dấu ngoặc kép, gấp đôi dấu ngoặc kép, và, nhưng, dấu ngoặc đơn, dấu nháy đơn. Hóa ra trong C, mà khi bạn muốn viết một chuỗi, bạn sử dụng dấu ngoặc kép, giống như chúng ta đã được sử dụng tất cả thời gian này với printf. 

Nhưng nếu bạn muốn để đối phó với chỉ một nhân vật duy nhất, một cái gọi là char, sau đó bạn thực sự sử dụng dấu nháy đơn. Những người bạn của những người đã được lập trình trước khi, bạn có thể không có phải lo lắng về điều này sự phân biệt trong ngôn ngữ nhất định. Trong C, nó không thành vấn đề. Và như vậy khi tôi nhận được một char và tôi muốn để so sánh char sử dụng bằng tương đương với một số lá thư như y hoặc n, tôi làm, thực sự, cần phải có các dấu nháy đơn. 

Bây giờ, chúng ta hãy đi trước và làm điều này. Hãy đi trước và làm làm dot logic cắt giảm hợp lý. Và bây giờ tôi đang bị nhắc nhở. Vì vậy, có lẽ, một kinh nghiệm người dùng tốt hơn thực sự sẽ cho tôi biết phải làm gì đây. Nhưng tôi sẽ chỉ mù quáng nói y cho có, OK, tốt đẹp. 

Hãy chạy lại, n không có, tốt đẹp. Giả sử như một số người tôi biết, mũ của tôi khóa quan trọng là tất cả các quá thường xuyên. Vì vậy, tôi làm vốn Y, nhập, lỗi. OK, nó không chính xác những gì tôi đang mong đợi. Thật vậy, máy tính đang làm nghĩa gì Tôi nói với nó để do-- kiểm tra chữ thường và chữ thường y n. Điều này không cảm thấy như tốt kinh nghiệm người dùng, mặc dù. Hãy để tôi yêu cầu và chấp nhận cả hai trường hợp thấp hơn hoặc trường hợp trên. Vì vậy, nó quay ra, bạn có thể muốn để nói một cái gì đó giống như trong Scratch, như nghĩa đen hoặc C bằng bằng vốn đơn y được trích dẫn. Hóa ra, C không có từ khóa đen này hay. 

Nhưng nó có hai thanh dọc. Bạn phải giữ phím Shift thường, nếu bạn đang sử dụng một bàn phím Mỹ, và nhấn thanh dọc phím trên chìa khóa của bạn trở lại. Nhưng thanh dọc này thanh dọc là hay. 

Nếu, ngược lại, chúng tôi muốn để nói, và cũng như trong Scratch, chúng ta có thể làm dấu và dấu &. Điều đó làm cho không có ý nghĩa logic ở đây, vì một con người có thể không có thể đã gõ cả y và chữ thường y và vốn Y như cùng một ký tự. Vì vậy, hoặc là những gì chúng tôi có ý định ở đây. 

Vì vậy, nếu tôi làm điều này ở cả hai nơi, hoặc c bằng bằng với vốn tồn tại, bây giờ chạy lại, làm cho hợp lý, chạy lại hợp lý. Bây giờ, tôi có thể gõ y. Và tôi có thể làm điều đó một lần nữa với vốn Y, hoặc N. vốn Và tôi có thể thêm vào thêm Các kết hợp. 

Vì vậy, đây là một hợp lý chương trình trong chừng mực như bây giờ Tôi đang kiểm tra một cách hợp lý cho giá trị này hay giá trị này. Và tôi không phải, nhất thiết, đi lên với hơn hai IFS hoặc khác IFS. Tôi thực sự có thể kết hợp một số các lý liên quan với nhau theo cách này. Vì vậy, đây sẽ là tốt hơn thiết kế đơn giản hơn nói, nếu C bằng thấp hơn trường hợp y, in có, khác nếu c bằng vốn Y, in có, khác nếu c bằng lower-- nói cách khác, bạn không cần phải có hơn và nhiều chi nhánh. Bạn có thể kết hợp một số lượng tương đương chi nhánh một cách hợp lý, như trong cách này. 

Vì vậy, chúng ta hãy nhìn vào chỉ một thành phần cuối cùng, một cấu trúc cuối cùng, C cho phép. Và chúng tôi sẽ quay trở lại trong tương lai cho những người khác vẫn còn. Và sau đó chúng tôi sẽ kết luận bằng cách nhìn tại không đúng đắn của code-- nhận được mã để work-- nhưng thiết kế mã, và trồng những hạt giống đầu vào. 

Vì vậy, hãy để tôi đi trước và mở một tập tin mới ở đây. Bạn biết những gì? Tôi sẽ tái thực hiện mà cùng một chương trình, nhưng sử dụng một cấu trúc khác nhau. 

Vì vậy, hãy để tôi nhanh chóng cung cấp cho bản thân mình truy cập để bao gồm CS50.h cho thư viện CS50, chuẩn Io.h cho printf. Hãy cho tôi void main int của tôi. Và sau đó ở đây, chúng ta hãy tôi đi trước và làm điều này. 

Char c được lấy char, giống như trước đây. Và tôi sẽ sử dụng một cấu trúc mới now-- chuyển, về những gì nhân vật? Vì vậy, chuyển đổi là loại giống như chuyển một chuyến tàu đường ray. Hoặc, thực sự, nó là loại một nếu người nào khác, nếu người nào khác nếu, nhưng viết hơi khác nhau. 

Một chuyển đổi trông như thế này. Bạn có chuyển đổi, và sau đó những gì nhân vật hoặc số bạn muốn để xem xét, sau đó một số dấu ngoặc nhọn giống như trong Scratch, chỉ nói làm công cụ này. Và sau đó bạn có trường hợp khác nhau. 

Bạn không sử dụng if và else. Bạn có nghĩa là sử dụng các trường hợp từ. Và bạn sẽ nói điều gì đó như thế này. 

Vì vậy, trong trường hợp của một chữ thường y, hoặc trong trường hợp của một Y vốn, đi trước và in ra có. Và sau đó thoát ra của switch. Đó là nó. Đã được thực hiện. 

Else if, có thể nói, trường hợp n thấp hơn, hoặc vốn N, sau đó đi trước và in ra không, và sau đó phá vỡ. Else-- và của loại này là trường hợp mặc định indeed-- printf error-- và chỉ cho các biện pháp tốt, mặc dù logic nghỉ này là không cần thiết bởi vì chúng tôi đang ở cuối của switch anyway, Tôi bây giờ phá vỡ ra của switch. Vì vậy, điều này có vẻ hơi khác một chút. 

Nhưng, một cách logic, đó là thực sự tương đương. Và tại sao bạn sẽ sử dụng một trong khác? Đôi khi, chỉ là sở thích cá nhân, đôi khi các thẩm mỹ, nếu tôi liếc nhìn này bây giờ, có điều gì đó để nói cho các khả năng đọc của mã này. Tôi có nghĩa là, không bao giờ tâm trí thực tế này đang mới đối với nhiều người trong chúng ta trong phòng. 

Nhưng nó chỉ là loại khá. Bạn thấy chữ thường y, vốn Y, n chữ thường, vốn tồn tại mặc định, nó chỉ là loại nhảy ra ở bạn một cách rằng, tranh cãi, có lẽ ví dụ trước với IFS, và những cột thẳng đứng, và IFS khác, có thể không có. Vì vậy, đây thực sự là một vấn đề của cá nhân lựa chọn, thực sự, hoặc có thể đọc, của mã. 

Nhưng về mặt chức năng, cho tôi đi trước và thực hiện một chuyển đổi, dấu chấm dấu gạch chéo chuyển đổi, và bây giờ gõ y chữ thường, vốn Y, chữ thường n, vốn tồn tại, David, thử lại vì đó là không phải là một nhân vật duy nhất. Hãy làm x, lỗi, như mong đợi. Và, logically-- và điều này là một cái gì đó Tôi sẽ khuyến khích trong general-- thậm chí mặc dù chúng tôi chỉ trầy xước bề mặt của một số các tính năng này. 

Và nó có thể không được rõ ràng khi bạn mình ngồi vào bàn phím, Cái này hoạt động ra sao? điều này sẽ làm gì? Điều đẹp về việc có một máy tính xách tay, hoặc để bàn, truy cập với một máy tính với một trình biên dịch, và với một trình soạn thảo mã như thế này, là bạn có thể hầu như luôn luôn trả lời những câu hỏi cho chính mình chỉ bằng cách cố gắng. 

Ví dụ, nếu tu từ câu hỏi ở tay là, những gì sẽ xảy ra nếu bạn quên báo cáo nghỉ của bạn? Mà thực sự là một rất phổ biến là điều phải làm, bởi vì nó không giống như bạn thực sự cần chúng. Họ không thực sự hoàn thành của bạn nghĩ như một ngoặc đơn hoặc một xoăn cú đúp không. Hãy đi trước và biên dịch lại mã và xem. Vì vậy, thực hiện chuyển đổi, chuyển đổi chấm dấu gạch chéo. Hãy gõ chữ thường y, trường hợp đầu, Enter. Vì vậy, tôi đã gõ y. 

Chương trình nói có, không, lỗi, như thể nó đã được thay đổi tâm trí của nó. Nhưng nó loại là, bởi vì những gì xảy ra với một chuyển đổi là trường hợp đầu tiên mà trận đấu về cơ bản có nghĩa là, hey máy tính, thực hiện tất cả các mã bên dưới nó. Và nếu bạn không nói nghỉ, hoặc không nói nghỉ, hoặc không nói nghỉ, máy tính sẽ cho nổ tung thông qua tất cả những dòng và thực hiện tất cả trong số họ cho đến khi nó được cho rằng cú đúp xoăn. Vì vậy, hệ thống phanh là, thực sự, cần thiết. Nhưng một takeaway ở đây là, khi nghi ngờ, hãy thử một cái gì đó. Có thể lưu mã của bạn đầu tiên, hoặc lưu nó trong một tập tin thêm nếu bạn đang thực sự lo lắng về rối tung lên và phải phục hồi công việc mà bạn biết đang làm việc. 

Nhưng hãy thử những điều. Và đừng như sợ, có lẽ, của những gì máy tính có thể làm, hoặc bạn có thể phá vỡ một cái gì đó. Bạn luôn có thể phục hồi trở lại với một số phiên bản trước đó. 

Vì vậy, chúng ta hãy kết thúc bằng cách tìm kiếm vào thiết kế của mã. Chúng tôi có khả năng này ngay bây giờ để viết điều kiện và vòng viết, và các biến, và các chức năng gọi. Vì vậy, thẳng thắn, chúng tôi loại lại nơi chúng tôi là một tuần trước đây với Scratch, mặc dù với một văn bản ít hấp dẫn môi trường hơn Scratch cho phép. 

Nhưng lưu ý chúng tôi có được một cách nhanh chóng như thế nào mà từ vựng, thậm chí nếu nó sẽ mất một chút thời gian để chìm xuống, vì vậy mà bây giờ chúng ta có thể sử dụng từ vựng này để viết các chương trình thú vị hơn. Và chúng ta hãy bước bé về phía đó, như sau. Hãy để tôi đi trước và tạo ra một tập tin mới ở đây. 

Tôi sẽ gọi này prototype.c, và giới thiệu lần đầu tiên, khả năng để thực hiện chức năng của riêng bạn. Một số bạn có thể có thực hiện điều này với Scratch, nhờ đó mà bạn có thể tạo ra của bạn khối riêng trong Scratch, và sau đó kéo chúng vào vị trí bất cứ nơi nào bạn muốn trong C. Và trong hầu hết các lập trình ngôn ngữ, bạn có thể thực hiện chính xác mà-- thực hiện chức năng của riêng bạn, nếu họ không tồn tại. 

Vì vậy, ví dụ, hãy để tôi đi trước và bao gồm CS50.h, và bao gồm chuẩn IO.h, int void main. Và bây giờ chúng tôi có một giữ chỗ sẵn sàng để đi. Tôi giữ cho mọi thứ in như tên của người dân ngày hôm nay. Và cảm thấy like-- sẽ không được tốt đẹp nếu có là một chức năng gọi tên in? Tôi không cần phải sử dụng printf. Tôi không cần phải ghi nhớ tất cả các mã định dạng. Tại sao tôi không, hay tại sao không một người nào đó trước tôi, tạo ra một chức năng gọi là in tên, mà đưa ra một số tên, chỉ đơn giản in nó ra? 

Nói cách khác, nếu tôi nói, hey, máy tính, cho tôi một chuỗi bằng cách yêu cầu người dùng cho như vậy, thông qua chức năng get chuỗi CS50 của. Hey, máy tính, một chuỗi ký tự mà trong biến ở phía bên tay trái, và gọi nó là. Và sau đó, hey máy tính, đi trước và in mà tên của người đó, thực hiện. 

Bây giờ, nó sẽ được tốt đẹp, bởi vì chương trình này, hòn đảo có tên, nói với tôi những gì nó phải làm bằng cách tên những người của hàm. Hãy để tôi đi và làm cho nguyên mẫu, Enter. Và, thật không may, điều này sẽ không để bay. 

Prototype.c, dòng 7, nhân vật 5, lỗi, khai báo ngầm tên in chức năng là không hợp lệ trong C99, C99 có nghĩa là một phiên bản của C mà ra đến năm 1999. Đó là tất cả. 

Vì vậy, tôi không biết những gì tất cả điều này có nghĩa là chưa. Nhưng tôi nhận ra lỗi trong màu đỏ. Đó là khá rõ ràng. 

Và dường như với các nhân vật màu xanh lá cây ở đây, vấn đề là với tên in, mở Dấu ngoặc s, dấu ngoặc đóng, dấu chấm phẩy. Nhưng tuyên bố tiềm ẩn của chức năng, chúng tôi đã nhìn thấy một thời gian ngắn trước đó. Điều này có nghĩa, đơn giản, mà Clang không biết những gì tôi có ý nghĩa. 

Tôi đã sử dụng một từ ngữ mà chúng nó không bao giờ nhìn thấy hoặc được dạy trước. Và vì vậy tôi cần phải dạy cho nó những chức năng này có nghĩa. Vì vậy, tôi sẽ đi trước và làm điều đó. 

Tôi sẽ đi trước và thực hiện chức năng riêng của tôi gọi là In Name. Và tôi sẽ nói như sau, mà nó thực hiện điều này, printf, hello, phần trăm s, dấu chéo ngược n, tên, dấu chấm phẩy. Vì vậy, những gì đã làm tôi chỉ làm gì? 

Vì vậy, nó quay ra, để thực hiện chức năng riêng của bạn, chúng tôi loại vay mượn một số cấu trúc tương tự như chính rằng chúng tôi đã chỉ được đưa cho các cấp, và tôi biết chỉ cần sao chép và dán khá nhiều những gì Tôi đã viết trong quá khứ. Nhưng nhận thấy mô hình ở đây. Int, Main, Void, chúng tôi sẽ trêu chọc nhau trước dài những gì mà thực sự có nghĩa. 

Nhưng hôm nay, chỉ cần nhận thấy song song. Void, tên in, tên chuỗi, do đó, một từ khóa tím, mà chúng ta sẽ bắt đầu gọi một kiểu trả về, tên của chức năng, và sau đó đầu vào. Vì vậy, trên thực tế, chúng ta có thể chưng cất loại này giống như tuần trước như, đây là tên hoặc thuật toán mã chúng tôi sẽ write-- sự thuật toán cơ bản mã chúng tôi đang đi để viết. 

Đây là đầu vào của nó. Đây là sản lượng của nó. Chức năng này, tên in, là được thiết kế để có một chuỗi gọi tên, hoặc bất cứ điều gì, như đầu vào, và sau đó vô hiệu. Nó không trả lại bất cứ điều gì, như nhận được chuỗi hoặc nhận int không. Vì vậy, nó sẽ đưa cho tôi một cái gì đó trở lại. Nó chỉ là sẽ có một tác dụng phụ, có thể nói, in ấn tên của một người. Vì vậy, để ý, dòng 7, tôi có thể gọi tên in. Dòng 10, tôi có thể xác định hoặc thực hiện các tên in. Nhưng, không may, đó là chưa đủ. 

Hãy để tôi đi trước và biên dịch lại này sau khi tiết kiệm. Whoa, bây giờ, tôi đã thực hiện nó tệ hơn, nó sẽ có vẻ. khai Vì vậy tiềm ẩn của Tên chức năng in không hợp lệ. Và, một lần nữa, có nhiều sai sót. Nhưng như tôi đã cảnh báo trước đó, thậm chí nếu bạn nhận được tràn đầy, hoặc một chút buồn khi thấy rất nhiều lỗi, chỉ tập trung vào ngày đầu tiên Ban đầu, bởi vì nó có thể chỉ đã có một ảnh hưởng tầng. Vì vậy, C, hoặc Clang cụ thể hơn, vẫn không nhận ra tên in. 

Và đó là bởi vì Clang, bởi thiết kế, là loại câm. Nó chỉ làm những gì bạn nói với nó để làm. Và nó chỉ làm như vậy theo thứ tự trong đó bạn nói với nó để làm. 

Vì vậy, tôi đã xác định chính trên dòng bốn, như chúng ta đã làm khá thường xuyên. Tôi đã xác định tên in trên dòng 10. Nhưng tôi đang cố gắng để sử dụng Tên in trên dòng bảy. 

Nó quá sớm, chưa hề tồn tại. Vì vậy, tôi có thể là thông minh, và được như thế, OK, vì vậy chúng ta hãy chỉ chơi cùng, và di chuyển tên in lên ở đây, và lập lại. Ôi chúa ơi. Nó đã làm việc. nó đơn giản như vây thôi. 

Nhưng logic là chính xác đó. Bạn phải dạy Clang gì nó là bằng cách định nghĩa các chức năng đầu tiên. Sau đó, bạn có thể sử dụng nó. Nhưng thẳng thắn mà nói, điều này cảm thấy như một dốc trơn trượt. 

Vì vậy, mỗi khi tôi chạy vào một vấn đề, tôi chỉ sẽ làm nổi bật và sao chép mã Tôi đã viết, cắt và dán nó lên đây. Và, chắc chắn, chúng tôi có thể xoay sở một số kịch bản nơi mà một hàm có thể cần phải gọi khác. Và bạn chỉ có thể đặt tất cả Chức năng trên mỗi khác. 

Vì vậy, nó quay ra có của một giải pháp tốt hơn. Chúng tôi có thể rời khỏi đây được. Và, thẳng thắn, nó thường tốt đẹp, và thuận tiện, và thiết kế tốt để đặt chính đầu tiên, bởi vì, một lần nữa, chính giống như khi lá cờ màu xanh lá cây nhấp, đó là chức năng mà được thực hiện theo mặc định. Vì vậy, bạn cũng có thể đặt nó ở trên cùng của tập tin để khi bạn hay bất kỳ con người khác nhìn vào các tập tin bạn biết những gì đang xảy ra chỉ bằng cách đọc chính đầu tiên. Vì vậy, nó quay ra, chúng ta có thể nói Clang chủ động, hey, Clang, trên dòng bốn, Tôi hứa sẽ thực hiện một chức năng gọi là In Tên rằng phải mất một chuỗi gọi tên như đầu vào, và trả về không có gì, void. Và tôi sẽ nhận được xung quanh để thực hiện nó sau này. 

Ở đây có chính. Chính hiện nay trên dòng 9 có thể sử dụng In Name vì Clang được tin tưởng rằng, cuối cùng, nó sẽ gặp phải định nghĩa việc thực hiện các In Name. Vì vậy, sau khi lưu file của tôi, chúng ta hãy tôi đi trước và làm mẫu, có vẻ tốt thời gian này. Dot giảm, nguyên mẫu, cho tôi đi trước và gõ vào một tên. David, xin chào David, Zamila, hello Zamila, và, thực sự, bây giờ nó hoạt động. 

Vì vậy, các thành phần ở đây là chúng ta đã thực hiện một chức năng tùy chỉnh, như một tùy chỉnh khối đầu chúng tôi đang gọi nó. Nhưng không giống như Scratch nơi bạn có thể chỉ tạo ra nó và bắt đầu sử dụng nó, bây giờ chúng ta phải là một ít mô phạm hơn, và thực sự đào tạo Clang để sử dụng, hoặc để mong đợi nó. Bây giờ, như một sang một bên, tại sao tất cả các thời gian này có chúng tôi đã chỉ một cách mù quáng vào đức tin bao gồm CS50.h, và bao gồm cả tiêu chuẩn IO.h? 

Vâng, nó quay ra, một trong số ít những thứ khác, tất cả những gì trong những dấu chấm h tập tin, mà xảy ra được file. Họ đang tập tin tiêu đề, vậy để nói chuyện. Họ vẫn đang được viết bằng C. Nhưng họ là một loại khác nhau của tập tin. 

Để bây giờ, bạn có thể khá nhiều giả định rằng tất cả những gì là bên trong của CS50.h là số một lớp lót như thế này, không cho các chức năng Print Name, nhưng đối với Nhận String, Nhận Phao, và một vài người khác. Và có những mẫu tương tự, một lớp lót, bên trong IO.h chuẩn cho printf, mà bây giờ trong riêng In Tên chức năng của tôi. Vì vậy, nói cách khác, toàn bộ thời gian này, chúng tôi đã chỉ được một cách mù quáng sao chép và dán bao gồm này, bao gồm rằng, những gì đang xảy ra? Những người chỉ là loại manh mối để kêu vang như chức năng gì được, thực sự, thực hiện, chỉ cần ở những nơi khác trong các tập tin khác nhau ở những nơi khác trên hệ thống. 

Vì vậy, chúng tôi đã triển khai tên in. Nó không có tác dụng phụ này của in một cái gì đó trên màn hình. Nhưng nó không thực sự đưa cho tôi một cái gì đó trở lại. Làm thế nào để chúng tôi đi về thực hiện một chương trình không đưa cho tôi một cái gì đó trở lại? 

Vâng, chúng ta hãy cố gắng này. Hãy để tôi đi trước và thực hiện một tập tin gọi là return.c vì vậy chúng tôi có thể chứng minh một cái gì đó như thế nào như Get String, hoặc Nhận Int, là thực sự trở về một cái gì đó trở lại cho người sử dụng. Hãy đi trước và xác định int void main. 

Và, một lần nữa, trong tương lai, chúng tôi sẽ giải thích những gì mà int và khoảng trống đó là thực sự làm. Nhưng hôm nay, chúng tôi sẽ đưa nó cho cấp. Tôi sẽ đi trước và printf, cho một kinh nghiệm người dùng tốt, x là. Và sau đó tôi sẽ chờ đợi cho người sử dụng để cung cấp cho tôi với x get int. 

Và sau đó tôi sẽ đi trước và in ra x với hình vuông. Vì vậy, khi bạn chỉ có một bàn phím, mọi người thường sử dụng cà rốt nhỏ biểu tượng trên bàn phím đại diện cho sức mạnh của, hoặc số mũ của. Vì vậy x bình phương là hiện tại tôi. 

Và bây giờ tôi sẽ làm điều này. Tôi chỉ có thể do-- x là gì bình phương? x bình phương là x lần x. 

Và chúng tôi đã làm điều này một số thời gian trước đây đã được ngày hôm nay. Điều này không cảm thấy như tất cả những tiến bộ nhiều. Bạn biết những gì? Hãy tận dụng một số ý kiến ​​cho rằng từ lần cuối cùng của sự trừu tượng. 

Nó sẽ không được tốt đẹp nếu có một chức năng gọi là vuông mà không chính xác đó? Nó vẫn còn, vào cuối của ngày, hiện các toán tương tự. Nhưng chúng ta hãy tóm tắt đi những ý tưởng chốt một số nhân khác, và chỉ cần cung cấp cho nó một cái tên, như vuông giá trị này. 

Và, nói cách khác, trong C, chúng ta hãy tạo ra một chức năng gọi là hình vuông mà không chính xác đó. Nó sẽ được gọi là vuông. Nó sẽ mất một int. Và chúng tôi sẽ sẽ chỉ gọi nó là n, theo mặc định. 

Nhưng chúng ta có thể gọi nó là bất cứ điều gì chúng ta muốn. Và tất cả những gì nó sẽ làm, theo nghĩa đen, là trở lại kết quả của n n lần. Nhưng bởi vì nó là trở về một cái gì đó, mà là từ khóa trong màu tím chúng tôi đã chưa bao giờ thấy trước đây, tôi, trên đường 11, không thể chỉ nói khoảng trống thời gian này. 

Void, trong ví dụ này, chúng tôi chỉ thấy chứ không phải của tên in, chỉ có nghĩa là, làm việc gì đó. Nhưng đừng đưa cho tôi một cái gì đó trở lại. Trong trường hợp này, tôi muốn trở lại n lần n, hoặc bất cứ điều gì có nghĩa là, con số đó. 

Vì vậy, tôi không thể nói, hey, máy tính, Tôi trở về không có gì, void. Nó sẽ quay trở lại, bởi bản chất, một int. Và đó là tất cả những gì xảy ra ở đây. 

Các đầu vào vuông sẽ là một int. Và như vậy chúng ta có thể sử dụng nó, nó phải có một tên, N. Nó sẽ đầu ra một int mà không cần một tên. Chúng tôi có thể để lại nó cho chính, hoặc bất cứ ai sử dụng tôi nhớ lại giá trị này nếu chúng ta muốn với biến riêng của mình. 

Và, một lần nữa, mới chỉ từ khóa ở đây là Return. Và tôi chỉ cần làm một số toán học. Nếu tôi thực sự muốn là không cần thiết, Tôi có thể nói int sản phẩm được n n lần. 

Và sau đó tôi có thể nói, trả lại sản phẩm. Nhưng, một lần nữa, quan điểm của tôi trước đó của này chỉ cần không phải là design-- tốt như thế, tại sao giới thiệu tên, một biểu tượng, như sản phẩm, chỉ để ngay lập tức trả lại nó? Đó là một chút bụi, một chút chặt chẽ, vì vậy để nói chuyện, chỉ để nói lần trở lại n n, loại bỏ dòng này hoàn toàn. 

Và nó chỉ là mã ít hơn để đọc, ít cơ hội cho những sai lầm. Và chúng ta hãy xem nếu điều này thực hiện hoạt động. Bây giờ, tôi sẽ đi trước và thực hiện trở lại. 

Uh-oh, khai tiềm ẩn của chức năng. Tôi đã sai lầm này trước khi, không có việc lớn. Hãy để tôi chỉ cần gõ, hoặc làm nổi bật và sao chép, chính xác cùng một chức năng nguyên mẫu, hoặc chữ ký, các chức năng ở đây. Hoặc tôi có thể di chuyển toàn bộ chức năng. 

Nhưng đó là một chút lười biếng. Vì vậy, chúng tôi sẽ không làm điều đó. Bây giờ, hãy để tôi làm lại một lần nữa, chấm nương trở lại. 

x kiến ​​2 x bình phương là 4. x kiến ​​3 x bình phương là 9. Và các chức năng dường như bây giờ để được làm việc. Vì vậy, sự khác biệt ở đây là gì? Tôi có một chức năng đó được gọi là hình vuông, trong trường hợp này, mà tôi đưa vào một đầu vào. Và tôi nhận lại một đầu ra. Tuy nhiên, trước đó, nếu Tôi mở ví dụ khác từ trước đó, mà đã gọi là prototype.c, Tôi đã có tên in, mà trở về khoảng trống, có thể nói, Hoặc nó trở lại không có gì, và chỉ đơn giản là có một tác dụng phụ. 

Vì vậy, những gì đang xảy ra ở đây? Vâng, hãy xem xét các chức năng nhận được chuỗi cho chỉ là một khoảnh khắc. Chúng tôi đã sử dụng chức năng nhận được chuỗi theo cách sau. 

Chúng tôi đã có một chức năng được chuỗi, giống như bao gồm CS50.h, bao gồm tiêu chuẩn IO.h, int, main, void. Và sau đó mỗi khi tôi đã được gọi là get chuỗi vậy, đến nay, Tôi đã nói như thế, chuỗi s được nhận được chuỗi, vì get string-- chúng ta hãy gọi get chuỗi get.c-- này tự trả về một chuỗi mà tôi có thể sau đó sử dụng, và nói, xin chào, dấu phẩy, phần trăm s, dấu chéo ngược n, s. 

Vì vậy, đây là những ví dụ tương tự, thực sự, chúng ta đã có trước đó. Vì vậy, nhận được chuỗi trả về một giá trị. Nhưng một thời gian trước đây, chuỗi in không trả về một giá trị. Nó chỉ đơn giản là có một tác dụng phụ. Vì vậy, đây là một sự khác biệt cơ bản. Chúng tôi đã nhìn thấy khác nhau loại chức năng bây giờ, một số trong đó đã quay trở lại giá trị, một số trong đó không. Vì vậy, có lẽ đó là chuỗi, hoặc int, hoặc thả nổi. Hoặc có lẽ nó chỉ là vô hiệu. 

Và sự khác biệt là rằng những chức năng mà có được dữ liệu và trả về một giá trị thực sự mang lại một cái gì đó trở lại bàn, vậy để nói chuyện. Vì vậy, chúng ta hãy đi trước và nhìn vào một tập cuối cùng các ví dụ cho một cảm giác, bây giờ, các thế nào chúng ta có thể, quả thực, trừu tượng hơn, và tốt hơn, và tốt hơn, hay hơn, và nhiều hơn nữa, và nhiều hơn nữa, để để viết, cuối cùng, mã tốt hơn. Hãy đi trước, và trong tinh thần của Scratch, làm như sau. 

Hãy để tôi đi trước và bao gồm CS50.h và chuẩn IO.h. Hãy để tôi đi trước và cho bản thân mình một int, main, void. Và hãy để tôi đi trước, gọi cough.c này. 

Và hãy để tôi đi trước và chỉ như Scratch, in ra ho / n. Và tôi muốn làm điều này ba lần. Vì vậy, tôi, tất nhiên, chỉ cần đi để sao chép và dán ba lần. Tôi bây giờ sẽ làm cho ho dot slash ho. Hãy cho bản thân mình một căn phòng nhỏ hơn ở đây, Enter, ho, ho, ho. 

Có, rõ ràng đã là một cơ hội để cải thiện. Tôi đã sao chép và dán một vài lần hiện nay. Nhưng đó chỉ là vì vậy tôi đã không phải nhập bao nhiêu ký tự. Tôi vẫn còn thay đổi gì những dòng mã được. 

Ba dòng giống hệt nhau, mà cảm thấy lười biếng và thực sự là, và có lẽ không phải là cách tiếp cận đúng. Vì vậy, với những gì thành phần chúng ta có thể cải thiện mã này? Chúng tôi không cần phải sao chép và dán mã. 

Và, quả thật vậy, bất cứ lúc nào bạn cảm thấy tự sao chép và dán, và thậm chí không thay đổi mã, tỷ lệ cược là có một cách tốt hơn. Và, quả thật, có. Hãy để tôi đi trước và làm một vòng lặp for, mặc dù cú pháp có thể không đến tự nhiên nào. 

Làm điều này ba lần, chỉ cần bằng cách làm following-- và tôi xảy ra để biết điều này từ thực tiễn. Nhưng chúng tôi có một số ví dụ bây giờ. Và bạn sẽ thấy trực tuyến nhiều tài liệu tham khảo vẫn còn. 

Đây là cú pháp trên dòng 6, mà giống như Scratch đó lặp đi lặp lại khối, lặp lại ba lần sau. Đó là một phép thuật nhỏ cho bây giờ. Nhưng điều này sẽ nhận được nhiều hơn, và quen thuộc hơn. 

Và nó sẽ lặp lại dòng tám ba lần, do đó, nếu tôi lập lại làm cho ho, dot giảm ho, ho, ho, ho. Nó vẫn hoạt động theo cùng một cách. Vì vậy, đó là tất cả tốt và tốt. Nhưng đó không phải là rất trừu tượng. 

Đó là hoàn toàn chính xác. Nhưng nó cảm thấy như có có thể là một cơ hội, như trong thế giới của Scratch, để loại bắt đầu để thêm một số ngữ nghĩa ở đây để Tôi không chỉ có một số vòng lặp, và một chức năng mà nói ho hoặc không ho. Bạn biết những gì? Hãy để tôi cố gắng để được một ít lạnh hơn, và thực sự viết một chức năng mà có một số tác dụng phụ, gọi nó là ho. 

Và nó sẽ không có đầu vào, và trả về không có giá trị như đầu ra. Nhưng bạn biết những gì nó? Nó này-- printf, quote unquote, ho. 

Và bây giờ lên đây, tôi sẽ đi trước và cho int, i được không, tôi ít hơn 3, tôi cộng cộng. Tôi sẽ không làm printf, đó là cho là một việc thực hiện ở mức độ thấp chi tiết. Tôi không quan tâm làm thế nào để ho. Tôi chỉ muốn sử dụng chức năng ho. Và tôi chỉ cần đi để gọi ho. 

Bây giờ, nhận thấy sự phân đôi. Khi bạn gọi một chức năng, nếu bạn không muốn cho nó đầu vào, hoàn toàn tốt. Chỉ cần làm mở dấu ngoặc, gần Dấu ngoặc đơn, và bạn đang làm. 

Khi bạn xác định một chức năng, hoặc khai báo nguyên mẫu của một chức năng, nếu bạn biết trước nó không sẽ mất bất kỳ đối số, nói khoảng trống trong những dấu ngoặc đơn ở đó. Và điều đó làm cho chắc chắn rằng bạn sẽ không vô tình lạm dụng nó. Hãy để tôi đi trước và làm cho ho. Và, tất nhiên, tôi đã thực hiện một sai lầm. 

Chết tiệt, có mà khai ngầm. Nhưng đó là tốt. Đây là một sửa chữa dễ dàng. Tôi chỉ cần các nguyên mẫu cao lên trong tập tin của tôi hơn là tôi đang thực sự sử dụng nó. 

Vì vậy, bây giờ hãy để tôi làm cho ho một lần nữa, tốt đẹp. Bây giơ no hoạt động. Hãy ho, ho, ho, ho. Vì vậy, bạn có thể nghĩ rằng chúng tôi đang thực sự chỉ hơn kỹ vấn đề này. Và, quả thật vậy, chúng tôi đang có. Đây không phải là tốt ứng cử viên của một chương trình tại thời điểm cho refactoring, và làm những gì gọi là phân hủy phân cấp, nơi bạn có một số mã, và sau đó bạn loại yếu tố điều trên, như vậy là gán nhiều ngữ nghĩa đối với họ, và tái sử dụng nó hạn cuối cùng còn. Nhưng đó là một khối xây dựng hướng tới chương trình tinh vi hơn rằng chúng ta sẽ bắt đầu viết trước dài cho phép chúng ta có các từ vựng mà để viết mã tốt hơn. Và, thực sự, chúng ta hãy xem nếu chúng ta không thể khái quát này hơn nữa. 

Nó có vẻ hơi khập khiễng mà tôi, chính, cần phải lo lắng về darn này cho vòng lặp, và kêu gọi ho một lần nữa và một lần nữa. Tại sao tôi không thể chỉ nói với ho, xin ho ba lần? Nói cách khác, tại sao có thể tôi chỉ cung cấp cho đầu vào để ho và làm điều này? 

Tại sao tôi không thể chỉ nói, trong ho chính ba lần. Và bây giờ, đây là loại ma thuật. Nó rất lặp đi lặp lại ở đây. Và đó là, thực sự, một bước em bé. 

Nhưng chỉ cần khả năng để nói về dòng tám, ho ba lần, nó chỉ là nhiều hơn nữa có thể đọc được. Và, cộng thêm, tôi không cần phải biết hoặc chăm sóc như thế nào ho được thực hiện. Và, quả thật vậy, sau này trong hạn và cho các dự án cuối cùng, nếu bạn giải quyết một dự án với một người bạn cùng lớp hoặc hai bạn cùng lớp, bạn sẽ nhận ra rằng bạn đang đi tới có, hoặc muốn, chia công việc. 

Và bạn sẽ muốn quyết định trước, ai sẽ làm những gì, và trong đó miếng? Và nó sẽ không được tốt đẹp nếu bạn, ví dụ, phụ trách bằng văn bản chính, thực hiện. Và bạn cùng phòng của bạn, hoặc bạn đối tác nói chung, chăm sóc thực hiện ho. 

Và phân chia này, các tường trừu tượng, hoặc lớp trừu tượng nếu bạn sẽ, là siêu mạnh mẽ, vì đặc biệt là đối lớn, các chương trình phức tạp hơn và hệ thống, nó cho phép nhiều người để xây dựng thứ cùng nhau, và cuối cùng khâu công việc của họ với nhau theo cách này. Nhưng, tất nhiên, chúng tôi cần bây giờ sửa chữa ho. Chúng ta cần nói ho rằng, hey, bạn biết những gì? Bạn sẽ cần phải thực hiện một input-- do đó không có hiệu lực, nhưng int và bây giờ. Hãy đi trước và đưa vào ho int. i được không. 

i nhỏ hơn bao nhiêu lần. Tôi nói ba trước. Nhưng đó không phải là những gì tôi muốn. Tôi muốn ho để được tổng quát cho hỗ trợ bất kỳ số lần lặp lại. 

Vì vậy, thực sự, đó là n mà tôi muốn, bất cứ điều gì người dùng nói với tôi. Bây giờ, tôi có thể đi trước và nói in ho. Và dù con số người sử dụng đi qua, Tôi sẽ lặp lại nhiều lần. 

Vì vậy, vào cuối ngày, chương trình là giống hệt nhau. Nhưng nhận thấy tất cả các công cụ này thậm chí có thể trong tập tin khác. Thật vậy, tôi không biết tại thời điểm cách printf được thực hiện. 

Tôi không biết tại thời điểm này như thế nào có được chuỗi, hoặc nhận int, hoặc nhận được phao được thực hiện. Và tôi không muốn xem chúng trên màn hình của tôi. Vì nó là, tôi bắt đầu tập trung vào chương trình của tôi, không những chức năng. 

Và như vậy, quả thật vậy, ngay sau khi bạn bắt đầu phân tách mã như thế này ra, chúng tôi thậm chí có thể di chuyển ho vào một tập tin riêng biệt? Một người nào khác có thể thực hiện nó. Và bạn và chương trình của bạn trở thành rất đẹp, và rất có thể đọc được, cho là, thực sự là bốn chương trình dòng ngay tại đó. 

Vì vậy, chúng ta hãy đi trước nay và làm cho một sự thay đổi hơn. Chú ý rằng nguyên mẫu của tôi có thay đổi lên hàng đầu. Vì vậy, hãy để tôi sửa chữa mà rất Tôi không bị mắng. 

Hãy ho, cho phép tôi chạy một lần ho hơn, vẫn làm điều tương tự. Nhưng bây giờ, nhận thấy chúng ta có một thành phần cho một phiên bản cuối cùng. Bạn biết những gì? Tôi không muốn chỉ cần ho, nhất thiết. Tôi muốn có một cái gì đó chung chung hơn. Vì vậy, bạn biết những gì? Tôi muốn làm điều này. Tôi muốn có, giống như Scratch không có gì, một khối nói, nhưng không chỉ nói điều gì đó một số lần. Tôi muốn nó nói một chuỗi rất cụ thể. Và, do đó, tôi không muốn nó để chỉ nói ho. Tôi muốn nó để nói bất cứ điều gì chuỗi được thông qua tại. 

Vì vậy, để ý, tôi đã khái quát này để bây giờ nói cảm thấy như một tên tốt cho điều này, như Scratch, nhận hai đối số, không giống như Scratch. Một là một chuỗi. Một là một int. 

Và tôi có thể chuyển đổi chúng. Tôi chỉ giống như ý tưởng nói các chuỗi đầu tiên, và sau đó bao nhiêu lần sau. Void có nghĩa là nó vẫn còn không trả lại bất cứ điều gì. Đây chỉ là phụ trên thị hiệu ứng, giống như với [? Jordan,?] một tác dụng phụ miệng la hét. Nó vẫn còn hiện lần gì đó n, 0 lên, nhưng không phải bằng n. Điều này có nghĩa là tổng số n lần. Và sau đó chỉ cần in ra bất cứ chuỗi đó là. Vì vậy, tôi đã thực sự khái quát hóa dòng mã này. Vì vậy, bây giờ, làm thế nào để thực hiện chức năng ho? 

Tôi có thể làm vô hiệu ho. Và tôi vẫn có thể đi như thế nào nhiêu lần bạn muốn ho. Nhưng bạn biết những gì? bây giờ tôi có thể đá trái banh để nói. 

Tôi có thể gọi điện nói với từ ho, đi qua trong n. Và nếu tôi muốn cũng để thực hiện, chỉ để cho vui, một chức năng hắt hơi, Tôi có thể hắt hơi một số lần. Và tôi có thể giữ cho việc tái sử dụng n, vì nhận thấy rằng m trong bối cảnh này, phạm vi chỉ tồn tại trong chức năng này. 

Và n trong bối cảnh này chỉ tồn tại trong chức năng này tại đây. Vì vậy, chúng tôi sẽ trở lại nhưng vấn đề trong phạm vi. Và ở đây, tôi chỉ cần đi để nói, achoo, và sau đó n lần, dấu chấm phẩy. 

Và bây giờ, tôi chỉ cần vay các chức năng chữ ký ở đây. Vì vậy ho là đúng. hắt hơi Void là đúng ngay bây giờ. 

Và tôi vẫn chỉ cần nói. Vì vậy, tôi sẽ nói, nói string s, int n, dấu chấm phẩy. Vì vậy, tôi đã qua chế các heck ra khỏi chương trình này. 

Và điều này không nhất thiết có nghĩa là những gì bạn nên làm khi viết thậm chí đơn giản của chương trình. Lấy một cái gì đó rõ ràng thực sự đơn giản, thực sự ngắn, và tái thực hiện nó sử dụng quá nhiều mã. Nhưng bạn sẽ thực sự thấy, và trong thời gian nhìn lại những ví dụ, và nhận ra, oh, đó là những bước chúng tôi đã thực sự khái quát, đến yếu tố gì đó ra, cho đến khi vào cuối ngày mã của tôi thực sự là khá hợp lý. Bởi vì nếu tôi muốn ho ba lần sau đó hắt hơi ba lần, Tôi chỉ đơn giản là đi chạy lại này, chương trình thực hiện ho, và chạy ho. Và tôi có ba ho và ba hắt hơi. 

Và do đó, đây là một cơ bản mô hình, nếu bạn muốn, để làm thế nào chúng ta có thể đi về thực sự thực hiện một chương trình. Nhưng chúng ta chỉ nhìn thấy nó là bây giờ những gì chúng tôi đã làm tất cả thời gian này, và những gì một số các mảnh thức đang đứng sau lệnh này đơn giản. Vào cuối ngày, chúng tôi đã được sử dụng Clang như trình biên dịch của chúng tôi. Chúng tôi đã viết mã nguồn mã, chuyển đổi nó qua Clang thành mã máy. 

Và chúng tôi đã được sử dụng làm chỉ để tạo điều kiện cho các tổ hợp phím của chúng tôi để rằng chúng ta không cần phải nhớ những câu thần chú của Clang chính nó. Nhưng những gì đang làm thực sự đang làm gì? Và, lần lượt, những gì là Clang thực sự đang làm gì? 

Nó chỉ ra, mặc dù chúng tôi đã đơn giản hóa thảo luận ngày hôm nay bằng cách nói, bạn lấy mã nguồn, vượt qua nó như đầu vào cho một trình biên dịch, mang đến cho bạn đầu ra của máy mã, hóa ra có của một vài bước khác nhau trong đó. Và biên dịch sẽ xảy ra là ô hạn cho một bó toàn bộ các bước. Nhưng chúng ta hãy chỉ trêu chọc ra điều này thực sự nhanh chóng. 

Nó chỉ ra rằng chúng tôi đã làm nhiều điều mỗi khi tôi chạy một chương trình, hoặc mỗi khi tôi biên dịch chương trình ngày hôm nay. Vì vậy, tiền xử lý đề cập đến này-- bất cứ điều gì trong một chương trình C, như chúng ta sẽ thấy một lần nữa và một lần nữa, bắt đầu với biểu tượng băm này, hoặc biểu tượng hashtag ở đây, có nghĩa là đó là một chỉ thị tiền xử lý. Điều đó có nghĩa, trong trường hợp này, hey máy tính, làm điều gì đó với tập tin này trước khi bạn thực sự biên dịch mã của riêng tôi. 

Trong trường hợp này, băm bao gồm là, về cơ bản, cách nói của C, hey máy tính, hãy lấy các nội dung của CS50.h và dán chúng ở đây. Hey máy tính, hãy lấy các nội dung của tiêu chuẩn IO.h, bất cứ nơi nào mà là trên ổ cứng, dán nó ở đây. Vì vậy, những sự việc xảy ra đầu tiên trong quá trình tiền xử lý. 

Và Clang làm tất cả những điều này cho chúng tôi. Và nó có phải nó như vậy darn nhanh chóng, bạn thậm chí không thấy bốn điều khác biệt xảy ra. Nhưng đó là bước đầu tiên như vậy. 

Điều gì thực sự xảy ra tiếp theo? Vâng, chính thức tiếp theo bước được biên dịch. Và nó chỉ ra rằng biên soạn một chương trình kỹ thuật có nghĩa là đi từ mã nguồn, những thứ chúng tôi đã đã viết ngày hôm nay, một cái gì đó được gọi là mã lắp ráp, một cái gì đó trông hơi khác một chút. 

Và, trên thực tế, chúng ta có thể thấy điều này thật nhanh. Hãy để tôi thực sự đi vào IDE của tôi. Hãy để tôi đi trước và hello.c mở, là chương trình đầu tiên mà chúng ta bắt đầu ngày hôm nay. Và hãy để tôi đi trước và chạy Clang một chút khác nhau, Clang-s, hello.c, mà thực sự đi đưa cho tôi một tập tin hello.s. 

Và chúng ta sẽ chẳng bao giờ một lần nữa nhìn thấy loại mã này. Nếu bạn có một mức độ thấp hơn hệ thống lớp học như CS61, bạn sẽ nhìn thấy rất nhiều hơn của loại mã này. Nhưng đây là ngôn ngữ lắp ráp. Đây là X86 ngữ rằng CPU đang tiềm ẩn CS50 IDE thực sự hiểu. 

Và khó hiểu như nó nhìn, nó là một cái gì đó các máy tính hiểu được khá tốt. Sub q, đây là một trừ. Có phong trào. 

Có đang gọi của chức năng ở đây, x oring, một phong trào, một add, một cửa sổ pop, Sự trở về, sự trở lại. Vì vậy, có một số rất hướng dẫn mức thấp mà CPU hiểu rằng Tôi ám chỉ trước đó. Đó là những gì Intel Inside. 

Có mô hình số không và những người bản đồ cho những lời lẽ arcanely, nhưng phần nào cũng được đặt tên, hướng dẫn, vậy để nói chuyện. Đó là những gì sẽ xảy ra khi bạn biên dịch mã của bạn. Bạn sẽ có được lắp ráp ngôn ngữ ra khỏi nó, mà có nghĩa là bước thứ ba là để lắp ráp mã lắp ráp vào, cuối cùng, máy số không code-- và những người thân, không phải là văn bản mà chúng ta chỉ thấy một khoảnh khắc trước. 

Vì vậy, trước khi chế biến không mà tìm và thay thế, và một vài thứ khác. Biên dịch mất nguồn của bạn code từ C, mã nguồn mà chúng tôi đã viết, để lắp ráp mã mà chúng ta chỉ cần liếc nhìn. Lắp mất assembly mã để zero và những người thân mà CPU thực sự sẽ hiểu vào cuối ngày. Và liên kết là bước cuối cùng điều đó xảy ra cho đây-- một lần nữa, quá nhanh, chúng tôi thậm chí không notice-- mà nói, hey máy tính, mất tất cả các số không và những người kết quả từ biên dịch mã của David, và chức năng chính của mình trong trường hợp này. 

Và hey máy tính, hãy lấy tất cả các số không và những người thân rằng các nhân viên CS50 viết bên trong các thư viện CS50. Trộn những người ở với David. Và hey máy tính, hãy lấy tất cả các số không và những cái mà người khác đã viết năm trước đây cho printf. Và thêm những thành toàn bộ điều, vì vậy mà chúng tôi đã có số không và những người thân của tôi, số không và những nhân viên của CS50, các số không printf và những người thân, và bất cứ điều gì chúng ta đang sử dụng. 

Họ tất cả được kết hợp với nhau thành một chương trình gọi là, trong trường hợp này, xin chào. Vì vậy, từ nay về sau, chúng tôi sẽ chỉ sử dụng biên dịch từ. Và chúng tôi sẽ đưa cho các cấp rằng khi chúng ta nói, biên dịch chương trình của bạn, nó có nghĩa là, hey làm trước khi chế biến, lắp ráp, và liên kết. Nhưng có thực sự là một số công cụ ngon ngọt xảy ra ở đó bên dưới mui xe. Và đặc biệt là nếu bạn tò mò một thời gian, bạn có thể bắt đầu chọc xung quanh ở mức thấp này. Nhưng hiện nay, nhận ra rằng trong takeaways cho ngày hôm nay khá đơn giản là bắt đầu của một quá trình, nhận được thoải mái với một cái gì đó giống như hello thế giới. Thật vậy, hầu hết những gì chúng ta làm ngày hôm nay chắc chắn sẽ không chìm trong siêu nhanh. Và nó sẽ mất một thời gian, và một số thực hành. Và tỷ lệ cược là, bạn sẽ sắp xếp của muốn nhấn bàn phím của bạn hay la hét vào màn hình. Và tất cả đó là OK. Mặc dù, có lẽ cố gắng không để làm điều đó trong thư viện rất nhiều. 

Và cuối cùng, bạn sẽ được thể tuy nhiên, để bắt đầu nhìn thấy các mô hình, cả trong mã tốt mà bạn đã viết và sai lầm mà bạn đã thực hiện. Và giống như quá trình trở thành một TF hoặc một CA là như thế, bạn sẽ bắt đầu để có được tốt hơn và tốt hơn khi nhìn thấy những người mẫu, và chỉ cần giải quyết của bạn vấn đề của riêng cuối cùng. Trong khi đó, sẽ có rất nhiều của chúng tôi để cho vay hỗ trợ bạn, và giúp bạn có thông qua này. Và trong khi write-up cho tất cả các vấn đề bạn sẽ được hướng dẫn tất cả các lệnh mà tôi chắc chắn biết từ rất nhiều thực hành của bây giờ, nhưng có thể đã bay trên đầu của một người cho bây giờ. Và đó là hoàn toàn tốt đẹp. 

Nhưng, cuối cùng, bạn sẽ để bắt đầu để xem các mẫu xuất hiện. Và một khi bạn vượt qua tất cả các chi tiết ngu ngốc, giống như dấu ngoặc đơn, và dấu ngoặc nhọn, và dấu chấm phẩy, và các công cụ, thẳng thắn, đó không phải là ở tất cả trí tuệ thú vị. Và nó không phải là mục tiêu của dùng bất cứ lớp giới thiệu. Đó là ý tưởng rằng sẽ có vấn đề. 

Đó là các vòng, và điều kiện, và các chức năng, và mạnh mẽ hơn các khái niệm trừu tượng, và thanh toán của các mã, và thiết kế tốt, và tốt phong cách, và cuối cùng là đúng đắn mã của bạn, đó là cuối cùng đi quan trọng nhất. Vì vậy, tuần tới, chúng tôi sẽ có những ý tưởng mà chúng tôi lần đầu tiên thấy trong Scratch và bây giờ đã dịch C. Và chúng ta sẽ bắt đầu để giới thiệu đầu tiên của lĩnh thế giới thực của khóa học. 

Chúng tôi sẽ tập trung vào thế giới của an ninh, và đặc biệt hơn mật mã, nghệ thuật xáo trộn thông tin. Và trong số những người đầu tiên vấn đề bản thân bạn sẽ nhận được để viết ngoài chơi với một số cú pháp và giải quyết một số logic vấn đề, cuối cùng trước khi dài, là để thực sự tranh giành, hoặc mã hóa, và cuối cùng giải mã thông tin. Và tất cả mọi thứ chúng tôi đã thực hiện ngày hôm nay, sẽ khá thấp level, sẽ cho phép chúng tôi để có một, và một, và hơn một bước so với đối viết mã thú vị nhất chưa. 

Vì vậy, thêm vào đó vào tuần tới. 

[XEM LẠI VIDEO] 

-Điều Gì bạn có thể cho tôi biết về lần cuối cùng bạn nhìn thấy anh ta? -Điều Gì tôi có thể nói, thực sự? Ý tôi là, nó giống như bất kỳ khác diễn tập chuẩn bị sản xuất, ngoại trừ có một điều gì ông nói ở cuối câu mà bị mắc kẹt với tôi. 

-Đây Là CS50. 

-đó Là cắt tất cả mọi người, việc tuyệt vời trên diễn tập. 

trưa -đó không? 

-Vâng, Bạn và tôi có thể lấy một chiếc bánh sandwich trong một chút. Hãy để tôi chỉ Phỏng vấn với David thực sự nhanh chóng. David? David? 

[END PLAYBACK] 