[음악 재생] 데이비드 J. 마란 : 좋아,이 CS50입니다. 그리고 이것은 주입니다. 그래서 주 제로에서 마지막 시간을 기억, 우리는 전산 사고에 초점을 맞추었다. 그리고 우리는 그것과로 전환 스크래치, 그래픽 프로그래밍 우리의 친구의 언어 MIT의 미디어 랩에서. 

그리고 스크래치와 함께, 우리는 탐험 않았다 기능과 같은 아이디어 및 조건, 및 루프, 변수, 심지어 이벤트, 스레드, 그리고 더. 그리고 오늘, 우리는 거 야 그 아이디어를 계속, 정말 그들을 복용 부여 있지만 번역 C. 지금으로 알려진 또 다른 언어, C는 전통적인 언어입니다. 그것은 낮은 수준이다 언어가됩니다. 

그것은 순수하게 텍스트입니다. 그래서 언뜻보기에, 그것은이다 모든 다소 애매한 볼 것 이전에 프로그램 된 적이있는 경우. 우리는 할 겁니다 세미콜론, 괄호, 중괄호, 그리고 더 많은합니다. 하지만 그조차 실현 구문은하지만 익숙하지 않은 약간의 모양에 대한 당신의 가장으로, 그 과거를 참조하십시오. 그리고 아이디어를 확인하려고 이 있으며, 실제로 잘 알고, 여기에 주에 한 무엇 때문에 우리는 비교하는 것입니다 시작합니다 처음에, C. 대 스크래치 

그래서, 예를 들어, 호출 할 때 우리를 그 우리의 프로그램의 첫 번째 구현 마지막으로, 우리는 보았다 블록을했다 이 항아리 때와 같은 작은 선물 녹색 깃발을 클릭 한 다음 우리는 있었다 그 아래에 하나 이상의 퍼즐 조각, 이 경우, 안녕하세요 세계 말한다. 그래서, 참으로, 스크래치에, 그 녹색 깃발을 클릭하면 그래서, 내 프로그램을 실행하려면 다음은, 말하자면 실행 된 얻을 블록, 또는 실행. 그리고, 구체적으로는, 스크래치 안녕하세요, 세계 말했다. 

지금, 나는 지정한 수 여기에 다른 단어. 그러나 우리는 실제로 그 많은 보자 실제로 이러한 blocks-- 그리고, C에서 많은 functions--이 될 수 있습니다 매개 변수화 또는 사용자 정의 다른 일을한다. 사실, C에서 우리 경우 지금, 변환 할, 이 스크래치 프로그램 이 다른 언어, 우리는 쓰기거야 이 같은 작은 선물. 

부여, 일부 익숙하지가 이 구문 가능성, INT, 괄호 및 무효. 당신이하고자하지만 그러나 심지어 printf-- 그냥 인쇄 될 것 같아요. 하지만 인쇄는 인쇄를 의미한다 우리는 곧 알게 되겠지만, 형식. 이것은 문자 그대로 인쇄됩니다 화면에 어떤 그 괄호 안에있는 물론이 경우에, 안녕하세요 세계입니다. 

하지만 당신은 다른를 알 수 있습니다 구문, 일부 따옴표, 그 끝에 괄호, 세미콜론 등을들 수있다. 그래서 오버 헤드가 약간있다, 말하자면, 둘 다인지하는 및 구문, 우리는 거라고 오래 전에 기억해야합니다. 그러나, 연습과 그 실현 이것은 당신에 뛰어 시작합니다. 

사실, 이제 그 일에 집중하자 함수는,이 경우 specifically-- 안녕하세요 세계를 말한다. 그래서 기능을 말한다. 안녕하세요 세계는 매개 변수가, 또는 인수의 정의. 

그리고 C의 등가은 그냥 여기에이 한 줄이 될 것, printf의이 동등이고, 말 이중 인용 된 문자열, 안녕하세요 세상은 물론 상당 거기에 흰색 상자에 무엇이합니다. 그리고 백 슬래시 n은 조금하지만 이상하고 처음부터 결석, 단순히 우리가 거​​하는 효과를해야 할 것입니다 컴퓨터에서 볼, 내 맥 또는 PC 등 단지 이동 다음 행으로 커서. 그것은 타격처럼 키보드에 입력합니다. 

그래서 우리는 머지 않아 다시는 볼 수 있습니다. 그러나 처음의이 살펴 보자 루프의 경우에 다른 예. 우리는 지난 시간이 영원히 루프를했습니다 퍼즐 조각 일련이었다 그 말 그대로 뭔가를했다 이 경우 forever--, 말, 안녕하세요, 안녕하세요 세계, 안녕하세요 세계, 안녕하세요. 그래서 디자인하여 무한 루프입니다. 

C에서, 우리는이를 구현하려면 같은 생각, 우리는 간단하게이 작업을 수행 할 수 있습니다. 진정한 동안, 안녕하세요 printf의 지금을 전 세계 반면, 단지 의미, 종류의 일의 아이디어를 연상 어떤 또 다시, 다시, 과에 대한 얼마나? 음, true-- 리콜 그 사실은 나 하나입니다. 

그리고 사실은 항상, 물론 사실이다. 그래서는 의미의 종류의 문은 진정한 대답. 그러나 실제로, 이것은 의도적 인 사실 그냥 항상 해당하는 경우 때문에, 사실 그냥 의미하면서보다, 간접적으로 작은 경우, 다음 코드 줄이 그 중괄호 사이에 그냥 다시하고 다시 실행해야, 다시, 실제로 절대 멈추지 않아. 

그러나 당신이 원하는 않는 경우 루프는 우리로, 중지 같은 지난 시간을했다 이것은 다음 50 회 반복 C에서 우리는 무엇과 같은 작업을 수행 할 수 있습니다 키워드 loop-- 대한 착신 동안,하지만 대한 없다는. 그리고 우리는 여기에 몇 가지 새로운 구문이 INT와 내가, 내가 50 미만 0과 동일 나는 ++. 그리고 우리는 다시 그에게 올 것이다. 그러나 이것은 단순히 우리가 어떻게 것 스크래치 블록들의 세트를 변환 코드 C 선을 설정한다. 

한편, 변수를 고려한다. 그리고 사실, 단지 잠시 전에 하나를 보았다. 스크래치의 경우에서는, 만약 난라는 변수를 선언하고 싶었다 내가 정수를 들면, 단지 수, 우리는 어떤 값으로 설정하려면, 우리는이 오렌지를 사용합니다 차단 here-- 내가 0으로 설정합니다. 

그리고 오늘날 우리가 볼 수 및 이후, 지난 주와 같은, 프로그래머는 거의 항상 정말, 0부터 세기 시작 관례. 또한 리콜에서 때문에 이진의 논의, 가장 적은 수의 당신이 할 수있는 비트의 개수로 나타낼 그냥 0 자체를 될 것입니다. 그래서 우리는 일반적으로 시작합니다 0 심지어 우리 변수를 초기화. 

그리고 C에서, 동일한 작업을 수행합니다 우리는 INT 말할거야 정수, 난 그냥 관례. 나는이 변수라는 수 있었다 아무것도 난 그냥 스크래치처럼, 할 수 있습니다. 그리고 0 다만 양수인과 동일 오른쪽의 값 0 가변 넣는 것, 또는 좌측이 수납 용기. 그리고 세미콜론으로 우리가 see--거야, 그리고 우리는이 already-- 몇 봤어요 단지 생각의 끝을 의미한다. 다른 뭔가를 진행 다음 라인에. 

자, 부울 표현식에 대한? 스크래치에 그 기억, 이러한 표현했다 중 하나에 해당하는 그 또는 false-- 질문 정말, 참 또는 거짓입니다 그. 따라서 상처의 경우는 수도 다음과 같은 간단한 질문을, 나는 50 미만? 그래서, 다시 정수이다. 어쩌면 우리는 그것을 사용하는 스크래치 프로그램 점수를 추적하는 또는 그런 일. 스크래치 여기 그래서이 구문 단지 내가 50보다 작은 의미? 음, 다행히도, 뭔가있다 C.에서 그리고 번역하는 간단하고, 이 우리는 단순히 덜 내가 말할 것 50보다 친숙한 키로 키보드. 

한편, 경우에 원 뭔가 더 일반적인 말, 같은, 잘, Y 위치를 각보다 X 작 x와 y의 자체 변수? 우리는 같은 일을 할 수 C에서, 너무 오래 우리는했습니다으로 이미 이러한 변수를 만들었습니다. 그리고 우리는 방법을 볼 수 있습니다 머지 않아 그렇게. 우리는 단순히 Y보다 X 덜 말할 것입니다. 

그래서 당신은에 시작하고 일부 유사성을 참조하십시오. 만든 그 사람 스크래치 확실히했다 이러한 기본 개념 중 일부에 의해 영감을 된. 그리고 당신은 이런 종류의를 볼 수 있습니다 많은 languages​​--에서 구문 뿐만 아니라,하지 스크래치 단지 C,하지만 파이썬, 와 자바 스크립트, 여전히 다른 언어. 

의 다른 구조를 살펴 보자 C에서, 조건의 개념, 조건부로 뭔가를하고. 뭔가가 true의 경우,이 작업을 수행. 뭔가가 true의 경우, 그렇게. 그것은 프로그램의 일종 도로에 포크의 상당. 어쩌면 양방향 포크 년대 삼원 포크 이상이다. 그리고 스크래치, 우리는있을 수 있습니다 이 같은 것을 본. 

그래서이 사람은 큰 일입니다. 그러나 상대를 고려 논리의 단순성. X가 Y보다 작은 경우, X는 이하라고 Y보다 X가 Y보다 큰 다른 경우 다음 x가 Y보다 큰 말한다. 그리고, 논리적으로, 경우 당신은 스크래치로 다시 생각한다 또는 그냥 자신의 인간의 직관, 또한, X가 Y보다 큰 경우이며, x 물론 다음, Y 이상입니다 X는 Y와 동일 할 것입니다. 이 경우, 중첩에 의해 그래서 이러한 스크래치 블록 우리는 세 가지를 얻을 수 있습니다 도로에서 길 포크? 

한편, 우리는 원하는 경우 그것은 틀림없이, C에서 그렇게 적어도 조금 simpler-- 보인다 당신은 문법에 익숙해 번. X는 Y보다 작 으면 의 printf X는 Y보다 작다. X가 Y보다 큰 경우에 그렇지, 의 printf X는 Y보다 크다. 다른 사람의 printf X는 y--과 같음 다시와 그 백 슬래시는 종료 그 새로운 라인이 그렇다면 당신 실제로 프로그램의이 종류를 실행 그냥 움직일 것입니다 커서 궁극적으로 화면의 다음 행. 

지금, 그 사이에 스크래치가 다른했다 더 정교한 기능 만 일부는 우리가 갈거야 처음 C.의 세계에 걸쳐 이동 그 중 하나였다 스크래치의 목록을했다. 그리고이 특별한이었다 변수의 유형이 여러 가지를 저장할 수 다시는에서, 백업, 백업, 백업합니다. 

C에서는없는 목록, 자체,하지만 뭔가 더 일반적으로 그 , 배열 있지만 우리는거야라고 이번 학기에 다시 올 뭔가 찾고에 목록, 또는 정말 링크 된 목록을했다. 그러나, 가장 가까운 지금 우리를 위해 C에 해당하는 뭔가 될 것입니다 배열했다. 및 배열은 간단하다 변수의 특별한 유형 그 데이터를 저장할 수 있습니다 뒤로, 뒤로, 백업, 백업합니다. 

그리고, 참으로, 스크래치에, 우리는 접근하기를 원한다면 어레이의 첫 번째 요소 또는 list--와 나는 그것을 호출하는거야 규칙, 변수는 argv, 인수에 의해 벡터,하지만 더 그 긴 전에. 나는 첫 번째 요소에서 얻고 싶은 경우에 의 스크래치의 세계에서, argv를 실제로 일반적으로 수행 1부터 계산 시작합니다. 

그래서 나는 변수는 argv의 항목 1을 얻을 수 있습니다. 즉, MIT 구현 단지 방법 목록의 개념. 그러나 C에서, 내가 갈거야 더 간단하게 그냥 말, 변수는 argv, 이는 다시의 이름입니다 내 list-- 또는 명확하게하기 위해, 배열. 그리고 첫 번째를 원하는 경우 요소는, 내가 갈거야 대괄호를 사용하는 당신을 종종 키보드에서 사용하지 않을 수 있습니다. 

그러나 0 그냥 의미, 나에게 처음으로 구매하십시오. 그래서 기회에 등 시간은 우리가 가고있어, 통과 이러한 이분법을보고 시작 스크래치와 C 사이, 이에 스크래치 하나를 사용합니다. C에서 우리는 여기서 0을 사용합니다. 하지만 당신은 신속하게 볼 수 있습니다 당신이 이해 한 번 각 언어의 기초, 그 이러한 일들은 모두가 더 많은 것을 알고 싶으 시다면 시작 연습과 연습을 통해 익숙해. 

그래서 실제로 프로그램에서 지금 살펴 보자. 여기에 우리의 C의 첫 번째한다 전체 프로그램의 소스 코드입니다. 그리고 프로그램은 우리거야 고려 제공합니다 등가의 하나입니다 그 이전의 스크래치 부분에. 

여기에 그래서, 우리는 무슨 일이있어 가지고 틀림없이 간단한 C 프로그램 당신은 쓸 수 있습니다 실제로 무언가를. 이제, 우리는 과거를 볼 것이다, 지금 포함하고있다, 표준 io.h,이 각도 브래킷 및 INT 및 무효, 그리고 중괄호 등을들 수있다. 

그리고 그냥 집중하자 적어도 직관적으로 무엇을, 이미 밖으로 뛰어 수 있습니다. 사실, 메인, 난 몰라 반드시이 무엇인지, 하지만 스크래치 등 많은했다 때 녹색 깃발은 퍼즐 조각을 클릭 그래서 프로그래밍 언어로 C 않습니다 코드의 주요 부분이 그 기본적으로 실행됩니다. 그리고, 참으로, 말 그대로 메인 호출 할 것입니다. 

그래서 주요 기능입니다. 그리고 그것은 존재하는 특수 기능입니다 C에서이 프로그램을 실행할 때, 그것은에 의해 운영되는 그 주입니다 태만. 스크래치의 세계에서, 이 때 녹색 깃발 일반적이었다 클릭 기본적으로 실행있어 그. 

한편, 우리는 전에 본 적이, printf의 또는 인쇄 형식, 그건 함께 제공되는 기능이 될 것 C, 다른 사람의 전체 무리와 함께, 시간과 시간에서 그 의지 다시 순서대로 정확히 수행하는 그 이름에서 알 수 있듯이, 뭔가를 인쇄 할 수 있습니다. 우리는 무엇을 인쇄 할 수 있습니까? 글쎄, 우리는 그것을 볼 수 있습니다 둘러싸는 문자로 these-- 안녕하세요 세계처럼, 큰 따옴표로 백 슬래시 N, 우리는 정확히의 printf를 알 수 있습니다 화면에 무엇을 인쇄합니다. 

그러나 순서대로하면해야 할 일 즉, 우리는 불행하게도 무언가를 취할 필요 우리 인간에게 이미 비밀, 하지만 적어도 그것은 다소 readable--이다 날카로운 포함, 표준 io.h, INT, 메인, 무효, printf와, 마법의 모든 주술 우리는 단지 화면에 보았다. 그러나 우리는 사실에있다 아직도 비밀의 이동합니다. 우리는 먼저 코드를 번역해야 우리는 기계 코드로 작성하는 것이. 그리고 지난 주부터 리콜 기계가, 적어도 사람은 우리가 여기 알고, 하루의 끝에 만 0과 1을 이해합니다. 

우리가 있던 경우에 나의 하나님,이를 작성 실제로 프로그램에 0과 1, 그것은 매우, 매우 빠르게 것 아무것도에서 재미를 가지고. 하지만, 지난 주 당 밝혀 즉 0과 1의 이러한 패턴 그냥 특별한 의미를 가지고있다. 특정 상황에서, 그들은 숫자를 의미 할 수 있습니다. 

어떤 상황에서, 그들은 의미 할 수 문자 또는 색상 또는 숫자 거기에 따라 다른 추상화. 그러나 컴퓨터가 것처럼 는 CPU, 중앙 처리 장치, 또는 컴퓨터 내부의 두뇌. 그것은 일반적으로 인텔의 내부, 그 때문에 가장 큰 회사 중 하나 즉, 컴퓨터의 CPU를 만든다. 

음, 인텔 CPU와 다른 사람 단순히 사전에 결정 그 제로의 특정 패턴 사람들은 특정 일을 의미한다. 0과 1의 특정 패턴 말은, 화면이 인쇄됩니다, 또는이 두 숫자를 추가하거나, 이 두 숫자를 빼기 또는 데이터의이 조각을 이동 내 컴퓨터의 메모리 여기에, 다른 매우 낮은 수준의 번호, 하지만 궁극적으로 유용한 작업. 그러나, 다행히도, 우리 인간은 갈 수 없습니다 세부 사항의 수준을 알 필요가있다. 사실, 어디서, 지난 번처럼 우리 또 다시, 다시 추출, 매우 낮은 수준에서 건물 0과 같은 프리미티브 상위 레벨 개념 숫자, 문자 등, 색상 등, 그래서 우리를 프로그래머로 수 의 어깨에 서 우리 앞에 와서 다른 사람 및 기타 해당 소프트웨어를 사용 사람들은 us-- 전에 작성했습니다 즉, 프로그램은 컴파일러를했다. 

C는 언어입니다 일반적으로 컴파일, 하는 변환 수단 머신 코드, 소스 코드를 포함 할 수있다. 특히, 어떤이 의미 것을 당신은 당신의 소스를 가지고하는 경우 당신 자신이 곧 우리와 같이 쓰기 코드 화면에 그냥 잠시 것이다, 당신은 그것을 변환 할 궁극적으로 기계에 code-- 그 0과 1이 단지 당신의 맥 또는 PC understands-- 당신은 첫째있어 로 그 소스 코드를 공급 특별한 입력 프로그램은 컴파일러라고, 출력되는 우리의 볼 것이다 기계 코드입니다. 그리고, 참으로, 마지막으로 우리는 이야기 대한, 정말, 하루의 끝에, 문제 해결. 당신은 입력을 가지고있다. 그리고 당신은 출력을 가지고있다. 그리고 당신은 어떤 종류의있어 중간에 알고리즘. 

알고리즘은 확실하게 할 수있다 소프트웨어로 구현 우리는 의사 지난 주에 본대로 우리는 실제 코드를 볼 수 있습니다로 이번 주. 그리고 컴파일러 정말 내부 알고리즘의 세트를 갖는다 그것을 알고있는 방법 특별한 키워드 변환 주 및 printf와 같은, 다른 사람들이 우리 단지 0의 패턴으로보고 사람이 인텔 내부와 다른 CPU 실제로 이해하고 있습니다. 그렇다면 우리는이 작업을 수행합니까? 우리는 어디 컴파일러를받을 수 있나요? 

우리들 대부분은 여기에 맥 또는 PC가 있습니다. 그리고 당신은 맥 OS를 실행하거나하는 윈도우, 또는 Linux 또는 Solaris, 또는 기타 임의의 개수 운영체제. 그리고, 참으로, 우리는 할 수 웹에 외출 그리고 컴파일러를 다운로드 Mac 또는 PC를위한 특정 운영 체제에 대한. 그러나 우리는 모두의 것 다른 페이지, 말하자면. 우리는 약간 거라고 다른 구성. 그리고 물건은 모두 동일하게 작동하지 않을 것입니다. 그리고, 참, 요즘 사용하지 않는 우리의 많은 우리의 노트북에서 실행되는 소프트웨어입니다. 대신, 우리는 뭔가를 사용 브라우저처럼 그 우리가 액세스 할 수 있도록 웹 기반 클라우드 응용 프로그램. 그리고 이번 학기, 우리는 정확하게 할 것입니다. 우리는 응용 프로그램을 작성하는 것 또는 소프트웨어, C code--을하지 사용 하지만 파이썬 같은 다른 언어와 클라우드에서 실행 JavaScript--. 

그리고 우리에게 자신을 그렇게합니다 학기 중 실제로 클라우드 기반을 사용합니다 CS50 IDE로 알려진 환경을 제공합니다. 이 웹 기반의 프로그램이다 환경, 또는 통합 개발 환경, IDE는, 그 일부 꼭대기에 지어진 것 클라우드 9라는 오픈 소스 소프트웨어. 그리고 우리는 몇 가지 교수법을했습니다 그것을 단순화 특정 기능을 숨길 수 있도록 우리가 필요로하지 않는 첫 번째 주, 그 후에 당신은 할 수 를 공개하고 할 가장 아무것도 당신은 환경을 원한다. 

그리고 그것은에, 너무, 우리를 수 특정 소프트웨어를 미리 설치합니다. 소위 CS50 같은 것들 우리가 곧 볼 도서관, 일부 C에서 우리를 제공합니다 추가 기능을 제공합니다. 그래서 당신이가는 경우에, 궁극적으로 CS50.io, 당신은, 로그인하라는 메시지가 표시됩니다 당신은 어떻게 만들되면 무료 계정, 당신은에 액세스 할 수 있습니다 아주 다음과 같습니다 환경을 제공합니다. 

이제, 이것은 디폴트 모드이다. 모든 좋은이며, 화면에 밝은. 우리 중 많은 사람들은 습관이 의 CS50 조각 작업 아주 늦은 밤에. 그리고 당신의 일부를 선호 할 수도 말하자면, 야간 모드 변환합니다. 

그러나, 궁극적으로, 당신은 무엇이야 CS50 IDE 내에서 보게 될 것 세 가지 areas--입니다 왼쪽 위치에 대한 지역 파일이있을거야 구름, 오른쪽 상단의 영역 여기서 코드는 편집 될 것입니다. 당신은 열 수 있습니다 모든 프로그램에 대한 개별 탭 당신은 내부 이번 학기를 작성하는 것이 그 오른쪽 상단의. 그리고 가장 arcanely, 아직 강력하게, 상기 본 일이 될 것입니다 터미널 창으로 알려진 바닥. 

이것은 오래된 학교입니다 명령 줄 인터페이스, 또는 CLI, 즉 수 있습니다 당신은 명령을 실행합니다 이 경우 computer--에, cloud--에서 컴퓨터 코드를 컴파일 등의 작업을 수행합니다 소스 코드에서 머신 코드, 프로그램을 실행하거나 시작합니다 웹 서버, 데이터베이스에 액세스하려면, 다른 기술들의 개수 우리는 오래 전에 사용하기 시작거야. 그러나 거기에 도착하기 위해, 우리는있어 실제로해야 할 것 온라인 및 재생을 시작합니다. 그리고 그렇게 먼저하자 주요 땜질 시작, 및 프로그램의 주요부 물품. 그리고 이제 그 기능을 사용하자 우리가 이전에 사용 printf와, 단순히 무언가를 말할 수 있습니다. 

그래서 나는 여기 CS50의 IDE의 내부에 이미입니다. 나는 사전에 기록했습니다. 그리고 전체 창을 상영. 그리고, 궁극적으로, 당신 너무 오는 문제에 비슷한 단계를 수행 것이다 온라인 설명서를 제공합니다. 그래서 당신에 대해 걱정할 필요가 없습니다 모든 작은 기술 단계를 흡수 오늘은 여기에서있다. 

그러나이 같은 화면을 얻을 수 있습니다. 나는 밤 모드로 발생합니다. 그리고 당신은 모든 것을 밝게 할 수 있습니다 야간 모드를 해제하여입니다. 그리고 끝에 하루, 당신은 보게 될 것 파일 areas--이 세 가지 주요 왼쪽 브라우저 상단까지 코드 탭, 그리고 하단에있는 터미널 창. 

내가 가서 보자 처음 프로그램을 작성. 나는, 선제 파일로 갈거야 저장하고에서는 hello.c로 내 파일을 저장합니다. 사실, 규칙에 의해, 모든 프로그램 우리 즉 C 언어로 작성 쓰기 뭔가를 지정해야 관례 점 다. 그래서 나는 때문에, 그것을에서는 hello.c의 이름을거야 난 그냥 세계에 인사하고 싶다. 지금은 확대거야 출력 및 저장을 클릭합니다. 그리고 나는 지금 여기에있는 모든 탭입니다 있는 나는 코드를 작성을 시작할 수 있습니다. 

이것은 컴파일하지 않을. 이것은 아무 의미가 없습니다. 그리고 변환 이렇게해도 0과 1이, CPU는 더해야 할 것입니다 아이디어는 주변에 무슨 일이 일어나고 있는지. 내가 라인을 작성하는 경우 그러나이 일치합니까 C의 conventions-- C의 존재 최대, 다시,이 같은 구문을 language-- 나는했습니다이, 인사의 printf을 전 세계 편안 받고 시간이 지남에 따라이 작업을 수행. 그래서 나는 내가 만든 생각하지 않습니다 모든 인쇄상의 오류. 

하지만, 변함없이, 최초 시간이 작업을 수행, 당신은 것입니다. 내가 할에 대한 누구인지 매우 수도 잘 당신을 위해 처음 작동하지. 그리고 그것은 완벽하게 괜찮아요 지금 당신 때문에 단지 새로움의 전체를 많이 볼 수 있습니다, 하지만 시간이 지남에 당신은 잘 알고 일단 이 환경 및 이 언어 등, 당신은 일을보고 시작합니다 그 올바른 또는 잘못된 중 하나입니다. 

그리고 이것은 무엇이다 교육 동료와 과정 조수, 이상 한 번에 너무 좋아한다 얻을 코드에서 실수 나 버그를 스포팅. 하지만 주장이 이 코드에는 버그가 없습니다. 그래서 나는 지금이 프로그램을 실행합니다. 

지금 내 자신의 Mac 또는 PC에, 나는에있어 더블 클릭 아이콘의 습관 나는 어떤 프로그램을 실행하고자 할 때. 하지만 여기에 모델이 아니다. CS50 IDE이다이 환경에서는. 우리는 운영을 사용하는 리눅스라는 시스템. 리눅스는 다른 연상 운영 체제는 일반적으로 공지 유닉스있다. 그리고 리눅스는 특히 유명하다 명령 줄 환경, CLI 데. 이제, 우리는 특정를 사용하는 리눅스의 맛은 우분투를했다. 그리고 우분투는 단순히이다 리눅스의 특정 버전입니다. 

그러나 이러한 리눅스의 이러한 일이 실제로 수행 그래픽 사용자 인터페이스를 갖추고 있습니다. 그리고 우리가 어떻게 하나 여기에 사용하는 것은 웹 기반이다. 그래서 심지어 보일 수 있습니다 뭔가에서 조금 다른 당신은 자신이있을 수 있습니다 보이거나 과거에 실행. 

그래서 앞서 갈거야 이제 다음을 수행합니다. 나는에서는 hello.c로이 파일을 저장 한. 내가 가서거야 및 형 clanghello.c 연타 그래서 C 언어를위한 컴파일러입니다. 그것은 미리 설치의 CS50 IDE에서. 그리고 당신은 절대적으로 다운로드 할 수 있으며, 자신의 Mac 또는 PC에이를 설치합니다. 

그러나, 다시, 당신은 모든이없는 것 사전 구성은 당신을 위해 수행. 지금은 그래서, 난 그냥 해요 clanghello.c를 실행하는 것. 그리고 지금이 구문을 알 여기에 결국 것이다 단지 나는에있어 것을 의미 실현 폴더 또는 디렉토리는 작업을했다. 이 달러 기호는 규칙이다 의미를, 여기에 명령을 입력합니다. 

그냥하는 프롬프트라고 무엇 관례에 달러 기호입니다. 그리고 내가 지금 가서 경우 ​​클릭 입력, 아무 일도 것으로 보인다. 하지만 실제로 좋은 일입니다. 적은 그가 발생 화면, 더 많은 가능성 코드가 정확해야하는 것입니다, 적어도 구문. 

나는 이것을 실행하려면 이렇게 프로그램, 내가 무엇을해야합니까? 글쎄, 그것은 것으로 판명 규칙에 의해 기본 이름 당신이를 지정하지 않는 경우 프로그램 프로그램이 단지의 a.out입니다에 대한 이름을 지정합니다. 너무 구문, 당신은거야 머지 않아 익숙해. 

점은, 헤이, CS50을 의미 슬래시 IDE, a.out의라는 프로그램을 실행 그건 내 현재 디렉토리 안에 있습니다. 그 점은 현재 디렉토리를 의미한다. 그리고 우리는 무엇을 등의 순서를 볼 수 있습니다 문자 오래 전에 의미한다. 

그래서 여기에 우리가 안녕하세요 세계, 입력, 이동합니다. 그리고 당신은 무슨 일이 있었는지 것을 알 수 있습니다? 그것은 안녕하세요 세상을 인쇄 않았다뿐만 아니라. 또한 이동 한 다음 행으로 커서. 

그리고 그 이유를했다? 우리가 전에 쓴 코드는 무엇인가 그 보장 커서 것이라고 다음 줄에 이동? 약 재미있는 것은 컴퓨터는 단지 무슨이다 문자 그대로 할 당신은 어떻게 그것을 말할 것. 

그래서 당신은 안녕의 printf를 말한다면, 쉼표, 공간, 세계, 가까운 인용, 그것은 문자 그대로 만거야 이러한 문자를 인쇄합니다. 하지만이 특수 문자를했다 결국, 리콜, 백 슬래시 n은. 그리고이 보장 무엇 캐릭터가 가서 그 화면의 다음 행. 

사실, 내가 가서이 작업을 수행 할 수 있습니다. 내가 가서이 삭제 할 수 있습니다. 이제, 알 내 화면의 상단이있다 작은 빨간 빛 표시 탭, 이봐, 당신은 당신의 파일을 저장하지했습니다. 그래서 내가 컨트롤과 함께 진행거야 S 또는 명령 S, 파일을 저장합니다. 지금은 moment-- 녹색에 들어갑니다 goes--. 그리고 지금은 다시이다 그냥 닫기 아이콘을 주도했습니다. 

내가 지금 다시 clanghello.c을 실행하면, 도트 슬래시, a.out의 Enter를 입력합니다, 당신은 여전히​​ 작동하는지 확인할 수 있습니다. 그러나 그것은 틀림없이 약간의 버그가 있습니다. 지금, 내 prompt-- 작업 공간, 그리고 그 달러 기호, 다음 내 실제 prompt-- 모두 같은 줄에 있습니다. 그래서이 확실히 미적 버그, 도 정말 논리적 인 버그가 아니다. 

그래서 난 그냥 무슨 짓을 취소하겠습니다. 나는 a.out의를 다시 실행거야. 내가 추가 한 유의 사항 개행 문자 다시. 나는 파일을 저장했습니다. 

그래서, a.out을 다시 실행거야 그리고 - 젠 버그, 실수를 의미 버그. 그래서 버그는 비록입니다 나는, n은 거기에 백 슬래시를 추가 재 저장, 프로그램을 다시 실행 동작은 동일하다. 이유가 있을까요? 

나는 오른쪽 단계를 실종 해요? 그 핵심 단계 이전 당신이 가진 것이 었습니다 당신이 당신의 소스 코드를 변경할 때 께 다시, 또한 실행 밝혀 컴파일러를 통해 다시 새로운 머신 코드를 얻을 수 있도록. 상기 머신 코드, 0과 1, 거의 동일하려고하지만, 하지 완벽 그래서, 우리가 필요로하기 때문에, 물론, 그 새로운 라인. 

그래서 내가 필요한거야,이 문제를 해결하려면 입력, 점 clanghello.c를 다시 실행하기 , a.out의 슬래시. 그리고 지금, 안녕하세요 세계가 돌아왔다 내가 기대하는 곳이 될 수 있습니다. 그래서이 모든 미세하고 좋은 것입니다. 하지만 a.out의은을위한 매우 어리석은 이름입니다 프로그램이 될 일이 있더라도, 역사적인 이유로 어셈블리 출력을 의미 default--. 

그러나 내가 여기에 앞서 가자 다르게 이렇게. 내 안녕하세요 세계 프로그램을 원하는 실제로 인사라고. 그래서 만약 그것의 아이콘이었다 내 바탕 화면, 그것은 이는 a.out되지 않습니다. 그것은 안녕하세요라는 것입니다. 

그래서이 작업을 수행하는, 그것은 밝혀 연타가 많은 프로그램과 같은, 명령 줄 인수를 지원합니다 또는 플래그 또는 스위치 단순히 행동에 영향을한다. 특히, 연타는 대시 O를 지원합니다 다음 두 번째 단어를 취 플래그입니다. 이 경우, I 임의로거야 그러나 합리적 인사를 호출합니다. 그러나 나는 아무것도를 호출 할 수 있습니다 나는 a.out을 제외하고, 할 오히려 점 외에 될 것이다. 

그리고 그냥 이름을 지정 파일의 I 컴파일 할 않습니다. 그래서 지금도 처음에 생각 난 아직도 연타를 명령, 명령 끝에 나는 아직도 파일 이름을 가지고, 지금은 명령 행이 인수 말하는 이들 플래그, 아, 그런데, 출력 - 오, 파일 하지의 기본은 a.out, 안녕하세요했다. 

그래서 히트 경우, 아무것도 지금 입력하지 일 것으로 보인다. 그리고, 아직, 지금은 안녕 점 슬래시를 할 수 있습니다. 그래서 동일한 프로그램이다. 0과 1은 하루의 끝에서 동일합니다. 

그러나 그들은 두에있어 다른 files--의 a.out, 이는 첫 번째 버전입니다 그냥 바보라는 지금 안녕하세요, 이는 훨씬입니다 프로그램에 대한 더 강력한 이름입니다. 그러나, 정직하게, 나는 결코 생각하지 다시 기억하는 것, 다시, 다시. 그리고, 사실로 우리는 쓰기 더 복잡한 프로그램, 당신이있어 명령 작성해야 할 것 도받을 예정 더 여전히 복잡. 

그래서 걱정하지. 그것은 밝혀 그 인간 전에 우리는 너무 그들은을 실현 이 동일한 문제를 가지고 있었다. 그들도를 갖는 즐기지 않았다 상당히 긴, 비밀 명령을 입력 홀로 그들을 기억. 그리고 우리 앞에 인간이 만든 보다 쉽게​​ 다른 프로그램 소프트웨어를 컴파일합니다. 

그리고, 참으로, 하나의 프로그램을 만들기라고합니다. 그래서 내가 가서이 일을하려고 해요. 나는 모든 것을 취소 할거야 I 다만 다음과 같은 방식으로했다. 내가 LS를 입력 할 수 있습니다. 그리고 당신은 세 가지를 알 수 있습니다 things-- a.out의, 그리고 별, 안녕하세요 별과에서는 hello.c합니다. 바라건대,이해야 조금 직관적 등의 이전이 있었다 한, 이 작업 공간에 아무것도 없습니다. 내가 가진 것은 아무 것도 없었다 우리가 수업을 시작할 때까지 만들었습니다. 

그리고 나는에서는 hello.c를 만들었습니다. 나는 다음을 컴파일하고 a.out을했다. 그리고 나는 약간 다시 컴파일 다르게 인사를했다. 그래서이 디렉토리에 세 개의 파일을 가지고, 작업 공간이라는 폴더입니다. 지금, 나는 그뿐만 아니라 볼 수 있습니다 실제로 축소합니다. 

내가 여기 축소하는 경우와 그 오른쪽 상단에 보면 코너, 약속대로 왼쪽 화면의 편 언제나 당신을 보여줄 것입니다 무엇 귀하의 계정에있어, 무슨 일이야 CS50의 IDE의 내부. 그리고 세 개의 파일이 있습니다. 

그래서 인사와 a.out을 제거하려고합니다. 그리고 당신은 수도 직관적으로 당신을 상상 제어 클릭으로 정렬 할 수 있습니다 또는 오른쪽이 클릭합니다. 그리고이 작은 메뉴가 나타납니다. 당신은 파일을 다운로드 할 수 있습니다 실행 그것은, 그것을 미리보기, 새로 고침, 이름 바꾸기 또는 무엇 없습니다. 

그리고 난 그냥 삭제할 수 있습니다, 그리고 그것은 멀리 갈 것입니다. 그러나의 명령으로 작업을 수행 할 수 지금은 줄 수 있도록하는 것이 편안합니다 이에 의해, 다음을 수행. 내가 가서 제거하는거야 말 그대로 rma.out 입력하여 a.out의. 이 명령에 대해 밝혀 제거하거나 뭔가를 삭제, 제거하거나 삭제하지 않습니다. 

그냥 저장, 더 간결 RM의 당신이 몇 가지 키 입력하고 Enter를 누르십시오. 이제 우리는 어느 정도가 될거야 비밀스럽게 일반 파일의 a.out을 제거합니다. 정말 얼마나 몰라 불규칙한 파일은 아직 것입니다. 그러나 나는 그것을 제거 할 않습니다. 

그래서 예에 대한 y를 입력거야. 아니면 내가 그것을 입력하고 Enter 키를 누르 수 있습니다. 그리고, 다시, 아무것도 일어날 것 같다. 하지만, 일반적으로 좋은 일이있다. 

나는이 시간 LS를 입력하면, 내가 무엇을 볼 것인가? 바라 건데, 그냥 인사 및에서는 hello.c. 이제, AS는 제쳐두고, 당신은거야 , 별표 (*)를이 별을 발견, 그건 내 프로그램의 끝 부분에 있습니다. 그리고 그들은 또한 녹색으로 표시하고 있습니다. 그건 그냥 CS50 IDE의 방법입니다 사실로 당신을 cluing의 것을 그 소스 코드 아닙니다. 즉, 실행 가능한 실행의 실제로 실행할 수있는 프로그램 다음 점 슬래시 일을하고하여 이름입니다. 

이제, 내가 가서 제거 할 수 이, 안녕하세요 RM은, 입력, 정기적으로 제거 네, 안녕하세요 파일. 그리고 지금은, LS를 입력하면 우리는 다시에서는 hello.c에있어. 삭제하지 않으려 고 당신의 실제 소스 코드입니다. 기능이있다하더라도 CS50의 IDE 위치에 내장 당신은 당신의 개정 역사를 통해 갈 수 있습니다 시간에 당신이 만약 실수로 되감기 뭔가를 삭제 염두에 두어야 할 이 메시지에 예 또는 아니오에 따라, 당신이 실제로 수행 할 작업의. 그리고 정상까지 가면 여기에 모서리를 왼쪽, 에서는 hello.c는 모두 남아 있습니다. 그래서 다발을 거기에 다른 명령 당신 리눅스의 세계에서 실행할 수 있습니다, 중 하나가 다시 확인된다. 그리고 우리는 확인거야 내 프로그램은 현재로는 다음과 같다. 

대신 그 소리를하는, 대신 그 소리 - 오 일을, 나는 단지에 갈거야 문자 그대로 안녕을 입력합니다. 그리고 지금 나는, 알 에서는 hello.c을 입력하지. 나는 안녕을 입력하고 있습니다. 

이 프로그램은 만들기 CS50의 IDE 등을 함께 제공 일반적으로 리눅스, 의 프로그램입니다 안녕하세요라는 프로그램을 만들려고. 그리고, 관례, 가정거야 이 프로그램 될 수있는 경우 것을 이 소스에서 할 것 점 C로 끝나는 코드 파일에서는 hello.c. 

그래서 나는 명중하면, 이제 통지를 입력하는 실행되는 명령 더 오래 실제로 이전보다 전에. 우리가했습니다 때문에 그건 사전 CS50의 IDE는이합니다 그 내장 된 몇 가지 추가 기능 우리는 아직 필요하지만 곧 것입니다하지 않습니다. 그러나 중요한 것은 실현 나는 안녕하세요 프로그램이 지금이다. 

나는 다시 LS를 입력하면, I 헬로 프로그램이 있습니다. 그리고 나는 그것을 실행할 수 있습니다 점은, 아니, a.out의 슬래시 이것의 요점 때문에 운동 도트 슬래시 인사했다. 그리고 지금 나는 안녕하세요 세계 프로그램이 있습니다. 그래서 앞으로 이동, 우리는 거의 항상있어 우리의 프로그램을 컴파일하는 것 명령 만들기를 사용하여. 그리고 우리가 실행할거야 점은 슬래시, 프로그램의 이름입니다. 그러나에 대한 일을되어 있는지 확인 실현 당신은,이 컴파일러 자체를하지입니다. 그것은 단지 편리한 프로그램입니다 그 컴파일러를 실행하는 방법을 알고 당신 자신이 사용할 수 있도록 실행합니다. 

어떤 다른 명령이 존재 Linux 및 턴 CS50 IDE에서? 우리는 곧이 있다고 볼 수 있습니다 CD 명령, 변경 디렉토리. 이것은 이내에 할 수 있습니다 명령 줄 인터페이스 다시 앞으로 이동하고, 다른 폴더를 열어 마우스를 사용하지 않고. 

목록 약자 우리가 본 LS, 현재 디렉토리에있는 파일. 디렉터리를 확인, 당신은 할 수 아마 추측하기 시작 이 디렉토리를 만들 now-- 무엇을 의미하는지, 당신은 폴더를 만들려면. 제거를위한 RM, RM 디렉터리에 대한 , directory-- 이러한 제거 다시, 명령어 라인이다 당신이 무엇을 등가물 마우스로 CS50 IDE에서 할 수있다. 하지만 당신은 곧 찾을 수 있습니다 때로는 그것은 단지 빨리 많이해야 할 일 키보드와 가지, 궁극적으로 훨씬 더 강력한. 

그러나 주장하기 어렵다 무엇이든 우리가 지금까지 해왔 모든 경우는 모두 강력한 우리는 안녕하세요 세계, IS 말을했습니다. 그리고, 사실, 나는 하드 코딩 내 프로그램에 안녕하세요 세계 단어. 더 역 동성이 아직 없습니다. 스크래치는 크기의 순서였다 더 흥미로운 지난 주. 

그리고 그래서 거기에 도착 할 수 있습니다. 의에 의해 그 방향으로 단계를 보자 이러한 기능 중 일부의 방법입니다. 그래서뿐만 아니라 C는 printf와 함께 않습니다, 다른 기능과 송이 일부는 우리가 나타납니다 시간이 지남에, 그렇지 않습니다 바로 잡아 모든 것을 쉽게 사용자 입력을 얻는데 게이트. 

약점의 사실, 하나 C와 같은 언어, 심지어 자바와 아직 다른 사람들이 없다는 것이다 단지 같은 것들을 얻을 쉽게 만들 사용자 또는 문자열, 단어의 정수, 및 문구처럼 혼자 일을하자 소수점 값, 또는 실수 부동 정말 소수점과 함께 우리가 곧 볼 수 있습니다로 긴 번호. 그래서 여기에 기능의 목록이 다른 스크래치 퍼즐 조각처럼 우리는 CS50에 미리 설치되어 있는지 우리는 몇 주 동안 사용합니다 IDE 훈련 종류의 바퀴, 그리고 결국 그들을 이륙 해 봐 후드, 아마도에서 아래 이런 일이 어떻게 구현된다. 

그러나이 작업을 수행하는,하자 실제로 프로그램을 작성. 내가 지금 가서 보자. 그리고 나는 새를 만들거야 이 작은 플러스 기호 (+)를 클릭하여 파일을, 및 새 파일을 클릭. 

나는이 다음을 저장거야 ,의 말을하자 하나, string.c, 나는 문자열 놀고 싶어하기 때문이다. 그리고 C에서 문자열은 그냥 일련의 문자. 그래서 지금의 앞서 가자 그리고 다음을 수행합니다. 

포함 표준 IO.h-- 및 그것은 표준 IO를 밝혀 IO는 입력 및 출력을 의미한다. 그래서 그것은 밝혀 여기에이 라인은 무엇입니까 printf가를 사용하는 우리 이웃입니다. printf와, 물론, 출력을 생성합니다. 그래서의 printf를 사용하기 위해서는, 회전 밖으로 당신은 코드 행이 있어야 파일의 상단에. 

그리고 우리는 다시 올 거 야 그건 정말 오래 전에 의미한다. 이 글은 그 밝혀 내가 쓰는 모든 C 프로그램, 나는 그것을 시작하는 데있어 다음과 같습니다 코드입니다. 그리고 당신은 CS50 IDE를 발견하고 있습니다 다른 통합 개발 그것과 같은 환경, 최선을 시도하려고 그들은 당신의 생각을 완료 할 수 있습니다. 사실, 잠시 전에 내가 취소하는 경우 난 그냥 무슨 짓을했는지, 내가 Enter 키를 누릅니다. 

나는 그 다음 오픈 곱슬 충돌 중괄호, 다시 Enter 키를 누릅니다. 그리고 내 생각을 마쳤다. 그것은 나에게 새로운 라인을 준 덜 들여 쓰기하지 좋은 문체 이유로 우리는 볼 수 있습니다. 그리고 자동 준 그 중괄호 내 생각을 완료합니다. 지금, 그것은 항상 않습니다 당신이 무엇을 원하는 것 같아요. 그러나 많은 부분, 그것을 수행 몇 가지 키 입력을 저장합니다. 그래서 잠시 전, 우리는이 program--를 실행 안녕하세요, 세계, 후 컴파일, 다음을 달렸다. 하지만 동성 여기가 없습니다. 우리가 원한다면 무엇 뭔가 다른 일을? 글쎄, 난 사실에 무엇을 원하는 경우 사용자로부터 문자열을 얻을? 나는 퍼즐 조각을 사용하는거야 문자열을 얻을 that-- 정확하게했다. 

C에서 밝혀 원하지 않는 때 퍼즐 조각에 입력을 제공하기 위해, 이상 제대로 기능하려면 말 그대로 그냥 여는 괄호을 닫는 괄호. 거기 것처럼 그래서입니다 더 흰색 상자에 입력 없습니다. 말 블록 전에 작은 흰색 상자를했다. 우리는 지금 그 흰색 상자가 없습니다. 

하지만 GET 문자열을 호출 할 때, I 어딘가에 결과를 넣을. 그래서 C에서 매우 일반적인 패러다임이다 여기에 도착 문자열 같은 함수를 호출, 다음 반환 값을 저장합니다. 이 결과의 그것 뭔가 노력. 

그리고 무엇 인 프로그램의 구성, C 지금 스크래치 또는 여부, 우리는 그 실제로 뭔가를 저장하는 데 사용할 수 있습니까? 그것은 바로, 변수 호출? 그리고 스크래치, 우리는 정말하지 않습니다 변수에 무슨 일이 있었는지 관심. 

그러나,이 경우 실제로 수행. 나는 문자열을 말하는거야. 그리고 내가 부를 수 내가 원하는이 아무것도. 나는 그것을 호출하는거야 이름, 문자열을 얻을 가져옵니다. 

그리고 지금 당신이 경우에도 이에 작은 새, 나는 몇 가지 세부 사항을 결여하고있어 것을 알 수 있습니다. 나는 세미콜론을 잊고 있어요. 나는이 생각을 완료해야합니다. 그래서 나는 나의 커서를 이동하려고 해요 거기에 세미콜론을 기록했다. 그리고 난 그냥 무슨 짓을 한거야? 이 코드 줄에서, 순간에 5 번, 나는 어떤 입력을 가진 GET 문자열을 호출하고 있습니다. 그래서 더 작은 흰색이 없다 저장 블록이이 같은 상자. 

난 그냥, 헤이, 말하는거야 컴퓨터가 나에게 문자열을 얻을. 등호는 정말 아니다 등호는 그 자체. 이 과제의 의미 연산자 이봐, 컴퓨터, 값을 이동 왼쪽 위에 오른쪽에서. 그리고 왼쪽에, 나는 다음과 같은 수 있습니다. 

이봐, 컴퓨터가 나에게 string--을 제공 일련의 문자. 그리고 그 캐릭터의 이름을 부른다. 그리고 난 이름을 호출 할 필요가 없습니다. 

나는 종래 그것을 호출 할 수 있습니다, S 같은, 우리는에 내가 사용 많은처럼 변수를 내가 전화. 하지만 지금은 그것으로 뭔가를 할 필요가있다. 그것은 꽤 어리석은 것 실행이 코드를 컴파일 시도 이 프로그램은, 비록 나는 문자열을 받고 있어요, 그냥 아직 때문에 안녕하세요 세계를 말하는 것. 

그러나 나는이 위치를 변경 무엇을 원하는 경우. 왜 이렇게하지? 퍼센트의, 쉼표의. 그리고 이것은 여전히​​ 작은 비밀입니다. 

그래서 내 변수를 더 명확하게 할 수 있습니다. 날이 변수 이름의 이름을 보자. 그리고 우리가 애타게 할 수없는 경우 보자 떨어져 여기에 무슨 일이 일어나고 있는지. 

그래서 라인 오에, 나는 문자열을 받고 있어요. 그리고 그 문자열을 저장하고있어, 어떤 사용자는에 입력했다 자신의 키보드에서, 이름라는 변수입니다. 그리고 그것은 밝혀 printf와는 단지 않습니다 두 번에 하나의 인수를 따옴표, 큰 따옴표 하나의 입력. 

또한 2 또는 3 또는 그 이상, 예를 취할 수 두 번째 또는 세 번째 또는 네 번째 것을 변수의 모든 이름은, 또는 구체적으로, 값 당신이에 연결하려는, 동적으로, 따옴표로 해당 문자열. 즉, 어떤 이 잘못된 것입니까? 내가 방금 말한 경우 안녕하세요 이름, 백 슬래시 N, 내 파일을 저장 한 코드를 컴파일 이 달렸다, 어떤 일이 일어날까요? 

그냥 인사 말 것 말 그대로 N-A-M-E, 이름, 어떤 종류의 바보 때문에입니다 그것은 세계 다르지 없습니다. 그래서 따옴표에서 아무것도이다 무엇을 말 그대로 인쇄됩니다. 내가 가지고 싶다면 이 자리 표시 자, 실제로 사용할 필요가 일부 특수 구문. 당신이 읽을 경우 그리고 그것은 밝혀 printf 함수에 대한 설명서, 그것은 당신을 말할 것이다 당신은 퍼센트의를 사용하는 경우, 다음과 같이이 값을 대체 할 수 있습니다. 

그 후 쉼표 후 큰 따옴표, 당신 만 의 이름을 쓰기 당신이 원하는 변수 그 형식으로의 연결합니다 코드 또는 형식 지정자, 퍼센트의 문자열. 그리고 지금은, 내 파일을 저장 한 경우 내 단말기에 다시 아래로 이동합니다. 내가 문자열을 확인 입력 때문에, 이러한 다시 이름 내가 전에 선택한 파일 string.c입니다. 

그래서 내가 입력 한 문자열을 확인 말하는거야. 선 (善) 오, 모든 봐 실수 우리는 이미했습니다. 그리고 이것은이 정말 무엇인지, is-- 여섯, 일곱 줄 프로그램처럼? 그래서이 곳은 매우 수있다 빨리 압도 얻을. 

이 터미널 창은있다 지금 막 역류 오류 메시지의 거대한 숫자. 확실히, 나는 더 많은 오류가 없습니다 나는보다 메시지는 코드의 라인을 가지고있다. 그래서 무슨 일입니까? 

음, 최선의 전략 당신은 언제 할까 압도적가 발생합니까 그런 오류의 목록, 다시 스크롤된다 명령을 찾습니다 당신은 그냥 도망 내 경우에는 어떤 문자열을 만들 수 있습니다. 한 만든다 무엇을 봐, 그리고 그 것을이다 긴 연타 명령이 더 큰 문제. 

하지만 빨간색은 나쁜 것입니다. 녹색으로 노력하고있다 부드러운 도움. 그러나이 경우에도, 여전히 나쁘다. 그러나 어디는 나쁘다? 

String.c, 라인 오, 문자 오. 그래서 이것은 단지 행해지고 있습니다. 뭔가 대장 뭔가 의미 행 번호와 문자 수입니다. 오류, 신고되지 않은 사용 식별자 문자열. 당신은 표준 찾으시는 것입니까? 

그래서, 불행하게도, 연타 도움이 될하려고합니다. 그러나이 경우, 잘못. 아니, 연타, 나는 표준 IO를 의미하지 않았다. 나는 그래, 줄 하나에 그 의미. 

그러나 라인 다섯은 여기 하나입니다. 그리고 연타하지 않습니다 S-T-R-I-N-G를 이해합니다. 이 선언되지 않은 식별자,이다 그냥 한 번도 본 적이없는 단어입니다. 그리고는 C 때문에, 언어의 우리는 지금 코드를 작성하는 문자열이라는 변수가 없습니다. 

그것은 기본적으로 지원하여,하지 않습니다 뭔가 문자열을했다. 즉의 CS50 편이다 전문 용어,하지만 매우 종래. 다음과 같이 그러나 나는이 문제를 해결할 수 있습니다. 

나는 한 줄의 코드를 추가하는 경우 이 프로그램의 상단에, 다른 파일 CS50.h을 포함 어딘가 CS50 IDE의 내부 어딘가에 하드 드라이브에, 말하자면, 우분투 운영 체제 내가 실행 해요 것으로, 그 의 파일입니다 운영을 가르 칠 것 문자열이 무엇인지 시스템, 단지 표준 io.h 같은 파일입니다 의 운영 체제 무엇의 printf를 가르 칠 것. 

사실, 우리가받은 것 매우 비슷한 메시지 IO 표준을 인정했다면 IO.h가와의 printf를 사용했습니다. 그래서 나는 앞으로 그냥 갈거야 내 화면을 취소 제어 L을. 아니면 명확 입력 할 수 있으며 것 그냥 터미널 창을 취소합니다. 하지만 당신은 아직 시간이 다시 스크롤 할 수 있습니다. 

그리고 문자열을 확인 다시 실행거야. 입력, 내 손가락이 시간을 교차. 나의 하나님 오, 일했다. 그것은 나에게 긴 비밀 명령을 보여줍니다 즉, 어떤 연타를 통해 생성 확인하다 하지만 오류 메시지. 그래서 비록 실현 당신은 완전히 얻을 수 있습니다 압도 오류 메시지의 수, 그냥이 성가신 계단식 수 있습니다 연타가 이해하지 못하는 효과, 다음을 의미 한 가지, 다음 단어를 이해하지 못하는, 또는 다음의 행. 그리고 그것은 당신의 코드에 질식. 하지만 수정은 간단 수 있습니다. 그래서 항상에 초점 출력의 첫 번째 라인. 그리고 당신이하지 않으면 그것을 이해, 그냥 봐 키워드에 대해 그 수 있습니다 단서 및 행 번호, 상기 문자 곳 그 실수는있을 수 있습니다. 

지금 내가 가서 입력하자 점은 입력 문자열을 슬래시. 흠, 그것은 안녕하세요 아무 말도 아닙니다. 왜? 음, 어디가 실행되고, 기억? 

그것은 아마 순간에 붙어 루프에서, 라인 여섯에, 만약에 당신, 디자인 문자열을 가져 오기 때문에, CS50 직원에 의해 작성, 말 그대로 그냥 앉아 의미 이 기다리고, 기다리고, 및 문자열을 기다리고. 우리는 문자열을 의미하는 모든 인간 입력된다. 그래서 당신은 무엇인지? 내가 가서 보자. 단지 변덕에, 저를 보자 내 이름은 데이비드을 입력, 입력합니다. 지금은보다 동적 인 프로그램이 있습니다. 그것은 안녕하세요 데이비드 말했다. 

내가 가서 다시 실행하면, 내가 입력 Zamila 이름을 말하려고 할 수 있습니다. 그리고 지금 우리는 역동적 인 프로그램이 있습니다. 내가 열심히 세계를 구분하지 않았습니다. 나는 하드 코딩하지 않은 이름, 또는 다윗, 또는 Zamila. 

지금은 프로그램과 같은 훨씬 더 이 입력을하면 우리는 여기서, 알고 그것은 약간 다른 출력을 생성합니다. 이제, 이것은 최선 아니다 사용자 경험, 또는 UX. 나는 프로그램을 실행합니다. 

내가 생각하고있는 무슨 모른다 내가 실제로보고하지 않는 한,해야 할 일 또는 소스 코드를 기억한다. 그럼 사용자를 만들어 보자 조금 더 나은 경험 사물의 단순한와. 날이 다시 가자 프로그램은 간단하게 printf의 말. 

그리고, 내가 가서 이름, 콜론을 가정 해 봅시다 공백, 다음 세미​​콜론. 그리고 단지 차기에 대한, 아니 반발 없음. 그리고는 의도적이다 내가 원하지 않는 때문에 프롬프트는 다음 행으로 이동합니다. 

나는 문자열을, 대신,이 작업을 수행 할 수 새로운 기계에 내 코드를 다시 컴파일하기 코드 점은 문자열을 슬래시. 아,이 훨씬 예뻐이다. 지금은 실제로 어떤 컴퓨터 알고 나, 이렇게 이름을 지정하려고합니다. 

그래서 내가 가서 입력 할거야 롭에, 안녕하세요 롭을 입력합니다. 그래서, 마지막에, 아직 실현 하루 만 아홉 줄 프로그램의. 그러나 우리는이 아기 조치를 취했습니다. 

우리는 한 줄 쓴과 우리 익숙한, printf와, 안녕하세요 세계이었다. 그런 다음 우리는 약간을 취소 한. 그리고 우리는 실제로 GET 문자열을 사용했다. 그리고 우리는 변수에 그 값을 던졌다. 그리고 우리가 나서서 개선 그것은 세 번째 라인 추가. 그리고 이러한 반복 과정 소프트웨어를 작성하는 것은 참으로 중요합니다. CS50, 그리고 일반적으로 생활에, 당신은 일반적으로 앉아서는 안 염두에두고 프로그램을, 쓰기를 시도 한 번에 전체 망할 것. 

그것은 불가피하게 발생합니다 자신이 여기에 본 우리보다 더 많은 오류. 심지어 나는이 일에 지속적으로 다른 바보 같은 실수를, 실제로 열심히 실수는 알아 내기 어렵습니다 그. 하지만 당신은 더 많은 실수가 더 많은 것 코드 라인은 한 번에 모든 물품. 그리고이 연습, 코드를 조금 쓰기 당신이 편안하게 걸, 컴파일 그것은, 그것을 실행 더 일반적으로 테스트 우리는 계속 그렇게처럼 on-- 이동 레이어 지난 주 레이어, 뭔가에서 구축 매우 더 복잡한 것을 단순, 여기에 동일한 작업을 수행. 앉아서하려고하​​지 마십시오 전체 문제를 작성합니다. 실제로이 아기 조치를 취합니다. 

자, 문자열은 모든되지 않습니다 자신에게 그 유용합니다. 우리는에 같이 이상적으로, 실제로 거라고 우리의 툴킷에 뭔가가있다. 그래서 실제로 정확하게 할 수 있습니다. 

내가 지금 가서 채찍하자 약간 다른 프로그램입니다. 그리고 우리는 정수에 대해,이 int.c를 호출 할 수 있습니다. 나는 유사에 갈거야, CS550.h을 포함한다. 나는 표준 IO를 포함하는거야. 그리고 꽤 공통 될 것 클래스의이 처음 몇 일있다. 

그리고 나는 준비에 갈거야 자신 주요 기능. 그리고 지금 대신 문자열을 가져 오는, 이제 가서 int를 얻을 수 있습니다. 의 난을 호출하자, 그것을 얻을 전화 INT, 가까운 괄호, 세미콜론. 그리고 지금의이하자 그것으로 뭔가의 printf. 

의이 같은 말을하자 안녕하세요, 백 슬래시 N, 쉼표 전. 그래서 나는 꽤 많이 모방하고있어 난 그냥 잠시 전에 무슨 짓을했는지. 여기 자리가 있습니다. 내가 원하는 때문에, 여기에 내가 쉼표있다 그 자리에 내가 연결합니다. 

그럼 가서 해보자 이 프로그램을 컴파일. 이 파일은 int.c.라고 그래서 입력 INT을 말할거야. 오 나의 하나님,하지만 더 큰 문제가, 오른쪽? 실수가있다. 

통 사적 실수가있다 여기 있도록 프로그램 할 수 없습니다 int.c, 라인 내부 컴파일 일곱, 문자 (27), 오류 형식 char 형을 지정합니다 즉 무엇이든, 스타. 그러나 인수 유형은 INT이다. 

도, 우리는 그래서 여기를 건 ...하지 않을거야 오늘날 많은 물질이 있더라도 우리는 당신을 압도거야 절대적 C의 모든 기능, 그리고, 더 일반적으로 프로그래밍 다만이 처음 몇 주입니다. 그래서 종종 전문 용어가있을거야 있는 당신이 익숙하지. 그리고, 사실, 문자 스타 뭔가 우리는 다시 올거야 주 또는 2의 시간입니다. 

하지만 지금은, 우리가 할 수있는 경우에 보자 익숙한 단어를 구문 분석합니다. Formats-- 그래서 우리는 형식을 들었다 지정, 형식 코드 전에. 즉, 잘 알고 있습니다. 유형 선택 -하지만 인수는 int 형이있다. 잠깐, 내가하는 int입니다. 

실제로 아마 퍼센트의 일부 정의 된 의미를 갖습니다. 그리고, 실제로는 않습니다. 정수, 당신이 원하는 경우 를 대체 할 수는 printf, 당신은 사실을 사용해야합니다 다른 형식 지정자. 그리고 당신이 모르는 것 하지 않는 한 누군가가 당신에게 또는 이전을 완료했다. 그러나 %의 나는 무엇을이다 일반적으로 사용될 수있다 정수를 연결하기위한 printf와있다. 또한 퍼센트를 사용할 수 있습니다 진수 정수 라. 하지만 난 여기에 좋은 간단하다. 그래서 우리는 그와 함께 갈 것입니다. 

지금 내가 가서 보자 다시 실행 메이크업의 int를 입력합니다. 즉, 오류 좋은 없습니다. 점은, int-- OK, 나쁜 사용자 경험을 슬래시 나는 나 자신에게 이야기하지 않았기 때문에 무엇을 할 수 있습니다. 하지만 괜찮아요. 나는 빨리에 잡는거야. 

그리고 지금 내가 가서 보자 데이비드, OK, Zamila, 롭을 입력합니다. OK, 그래서 이것은 좋은 일이있다. 이 시간, 나는 기능을 사용하고 있습니다 가져 오기 INT라는 퍼즐 조각. 그리고 그것은해서 돌출집니다 우리는거야 term--이 나중에 참조 CS50 직원은 구현했습니다 같은 방법으로 문자열을 얻을 즉, 단지 물리적 것 당신을 위해 문자열을 얻을. 

이 글은 가져 오기 INT을 구현했습니다 같은 방식으로 그에만 의지 당신을 위해 정수를 얻을. 그리고 만약, 인간, 협력하지 않는, 그건 말 그대로 단지로 이동 , 다시 시도, 시도 시도라고 문자 그대로 때까지 반복 거기에 앉아 당신은 몇 가지 마법의 숫자로 강요, 50, 50 안녕하세요있다. 

아니면 우리는 다시이 작업을 실행하는 경우 입력 42, 42 안녕하세요. 그리고 가져 오기 INT 함수 그 퍼즐 조각의 내부 충분한 로직이 충분히 사상 파악하는 단어는 무엇인가? 그리고 숫자는 무엇인가? 단지 최종적으로, 숫자, 수용성. 

그래서이 밝혀 모든 표현이 아니다. 지금까지. 그래서, 실로, 지난 시간 우리 꽤 빨리 갔다 실행 게임, 애니메이션으로, 스크래치 및 예술 작품. 그리고 여기, 우리는 콘텐츠되고있다 안녕하세요 세계, 50 안녕하세요와. 

그것은 모든 고무 아니다. 그리고, 실제로이 처음 몇 예를 들면 시간이 좀 걸릴 것입니다 흥분에 램프합니다. 그러나 우리는 훨씬 더이 사실, 지금 제어 할 수 있습니다. 그리고 우리는에거야 매우 빨리 레이어 시작 이러한 기본 프리미티브의 상단에. 

하지만 먼저,의 이해하자 한계는 무엇인지. 일의 사실, 하나 스크래치는 쉽게하지 않습니다 보면 정말 우리가 수행되어 보자 후드 아래, 그리고 무엇을 이해 컴퓨터, 그것은 무엇을 할 수있다 그리고 그 한계는 무엇인가. 와, 실제로 그 부족 이해 잠재적 장기 우리 자신의 mistakes-- 서면으로 이어질 수 있습니다 안전하지 않은 소프트웨어를 작성 버그, 그 어떤 방법으로 해킹됩니다. 

그럼 향한 어떤 조치를 취할 수 있도록 하여이 조금 더 이해 의 방법은, 다음의 예를 말한다. 내가 가서 구현하는거야 가산기라는 프로그램 진짜 빨리. 마찬가지로,의 함께 몇 가지 숫자를 추가 할 수 있습니다. 그리고 나는 약간의 모서리를 코딩하는거야 여기에, 그리고 그냥 복사 및 붙여 넣기 여기서 난 그냥 예전 그래서 우리는 빨리 갈 수 있습니다. 지금 나는 기본 시작있어 가산기라는 프로그램의. 

그리고 이제 가서이 작업을 수행 할 수 있습니다. 내가 가서거야 및 말하자면, INTX은 INT를 얻을 가져옵니다. 그리고 그거 알아? 의 더 나은 사용자 경험을 만들어 보자. 

그래서 그냥 x는, 효과적으로 가정 해 봅시다 사용자에게 메시지를 표시하는 것은 우리에게 X를 제공합니다. 그리고 다음 날의 printf, 가서 가정 해 봅시다 어떻게 y는 약, 이번에는 기대 사용자로부터 두 개의 값. 그리고 그냥 진행하자 가령의 printf, x와 y의 합이다. 그리고 지금은 퍼센트의 싶지 않아. 나는 퍼센트 내가하고 싶은, 백 슬래시 N, 다음 합계 값에 연결합니다. 

그래서 내가 어떻게이 일에 대해 갈 수 있나요? 당신 그거 알아? 나는 변수를 사용하는 방법을 알고있다. 나 그냥 새, INT z를 선언 할 수 있습니다. 

그리고 여기 추측을거야. 이에 등호가있는 경우 언어, 어쩌면 내가 X 플러스 y를 할 단지 수 있습니다, 너무 오래 내 끝으로 세미콜론 생각? 지금은, 아래로 여기 돌아가 Z에 연결할 수 있습니다, 세미콜론이 생각을 완료합니다. 그리고 이제 이러한 경우, 지금 보자 lines-- X의 서열은 INT를 얻을 수있다. Y는 INT를 얻을 수있다. 

x와 y를 추가의 값을 저장 z-- 그래서, 다시, 등호를 기억 동일하지 않다. 그것은 오른쪽에서 왼쪽으로 할당합니다. 그리고 이제 합 있음을 인쇄 할 수 X 축과 Y는 문자 Z 아니다 그러나 Z의 내부거야. 그럼 가산기를 만들어 보자 - 좋은, 실수없는이 시간. 점은, 가산기는 입력 슬래시 여기서 x는 1이 될 것입니다. 

Y는 2 될 것입니다. 그리고 x와 y의 합은 3이다. 그래서 모든 벌금과 좋은입니다. 

그래서 당신은 수학을 상상 이 같은 프로그램에서 작동합니다. 하지만 당신은 알아? 이 변수를 줄입니다 (12)도 필요? 당신은 습관을 할 필요가 없습니다 단지 변수에 물건을 저장 단지 당신이 할 수 있기 때문이다. 그리고, 실제로, 통상의 심사숙고 나쁜 디자인 당신이 변수를 작성하는 경우, 호출 이 경우의 Z는 그것을 뭔가 저장 다음 바로 그러나 결코 다시 그것을 사용. 이유는 뭔가에 이름을 지정 Z처럼 그대로 있다면 것을 사용할 것 일이 한 번만 등 사용자가 만든 곳으로 근위 처음에 그것은, 코드 라인의 측면에서 너무 가까이? 그래서 당신은 무엇인지? 그것은 C 꽤 유연 것으로 나타났다. 나는 실제로 원하는 경우 플러그인 값 여기서, 나는 새로운 변수를 선언 할 필요가 없습니다. 난 그냥 플러그인 수 X 플러스 Y, C가 이해하기 때문에 산술 및 수학 연산자. 

그래서 나는 단순히이 계산을 말할 수 X 플러스 Y, 그 값은 무엇이든, 그 결과 연결 해당 문자열로 정수입니다. 그래서, 비록 수 있습니다 한 줄 짧은, 더 나은 디자인, 더 나은 프로그램, 적은 코드 따라서,이 때문에 나를 이해하기 이하이다. 그리고 그것은 또한 단지 청소기입니다 우리는 아니에요하는 한 새로운 단어를 소개하고, 새로운 심볼, Z 등, 비록 그들은 정말하지 않습니다 목적의 대부분을 제공합니다. 

불행하게도, 수학은 아니다 모든 신뢰할 때로는. 이제 가서이 작업을 수행 할 수 있습니다. 나는 앞서 갈거야 이제 다음을 수행합니다. 

의는의 printf, %의 난, 플러스 퍼센트를하자 난, %의 난, 백 슬래시 n을해야한다. 그리고 나는이 항아리 xyx 플러스 y를 할거야. 그래서 난 그냥 다시거야 이 약간 다르게 여기. 내가 그냥 빨리 정신 검사를 할 수 있습니다. 다시 말하지만,의 앞서 자신의 얻을 수 있습니다. 가산기, 도트 슬래시 가산합니다. X 1, Y 2, 1 더하기 2는 3이다. 그래서 좋다. 그러나의 지금이 복잡하게 비트, 그리고 새로운 파일을 만듭니다. 

나는이 하나를 호출하는거야, 정수, 정수에 대한 복수라고. 내가 잠시 전에 어디 나부터 시작하자. 하지만 지금의 몇 가지 다른 라인을 수행 할 수 있습니다. , 내가 가서 다음을 수행하자 의 printf, %의 난, 마이너스 %의 난, %의 난, 쉼표 X, 쉼표 YX 마이너스 Y입니다. 그래서 조금하고 있어요 거기에 다른 수학. 의 또 다른 하나를 수행 할 수 있습니다. 그래서 %의 난 배 퍼센트 난 %의 난, 백 슬래시 n은. 의 플러그인에서 X 및 Y 및 X 시간 Y 보자. 우리는에 별표 (*)를 사용합니다 시간에 대한 컴퓨터. 

당신은 X를 사용하지 마십시오. X는 여기에 변수 이름. 당신은 곱셈의 스타를 사용합니다. 의 하나 이상을 수행 할 수 있습니다. PRINTF %의 I, 분할 %의 난에 의해, 퍼센트 난입니다 백 슬래시 n은. XY y--로 나눈 그래서 당신은 C에서 슬래시를 사용 분할을 할 수 있습니다. 그리고의 다른 하나를 수행 할 수 있습니다. %의 난의 나머지 분할 %의 난에 의해 %의 난입니다. xy-- 이제 나머지 이상 남은 것입니다. 당신은 분할 할 때 분자로 분모 것이 이상 남은 당신은 밖으로 나눌 수 없었다? 

그래서, 정말이 없다 반드시, 상징 우리는이를 위해 초등학교에 사용했습니다. 그러나이 C에서 당신은 할 수 있습니다 말 X 모듈 Y, 어디 이 context--이 퍼센트 기호 혼동을 일으킬 당신 안에있을 때 큰 따옴표의, 의 printf의 %의 내부 형식 지정자로 사용됩니다. 

당신은 외부 퍼센트를 사용하는 경우 수학 식에 그, 이 모듈의 모듈로 연산자이다 우리의 목적을 위해 arithmetic-- 여기에, 그냥 의미, 무엇 인 X의 나머지 부분은 Y로 나눈? Y로 나눈 x를 그래서 X 슬래시 Y입니다. Y로 나눈 x의 나머지 부분은 무엇입니까? 프로그래머가 말하는 것처럼 그것은 모드 y를 x를합니다. 

여기에는 실수를하지 않는 경우 그래서, 저를 보자 가서 복수의 정수는, 좋은 수 있도록, 도트 슬래시 정수. 그리고 이제 가서 보자 수행의가, 1, 10을 가정 해 봅시다. 좋아, 1 더하기 (10)는 검사, 11이다. 1 마이너스 10 확인, 부정적인 9입니다. 

1 시간 10 검사, 10입니다. 1 10 is--로 나눈 OK, 우리는 하나를 건너 뛸 수 있습니다. 10로 나눈 1의 나머지는 1 개입니다. 맞습니다. 그러나 여기에 버그가있다. 

그래서 하나는 내가 넣어 내 정확하지, 넘겨. 나는 0으로 가까이, 의미한다. 우리가 인 경우 10로 나눈 1, 당신은 알고있다 일부 모서리를 절단해야합니다, 그것은 제로입니다. 하지만 정말, 1/10해야한다 0.1 또는 0.10, 0.1000, 또는 등. 

정말 제로이어야한다. 음, 컴퓨터가 밝혀 말 그대로 일을 우리는 어떻게 그것을 말한. 우리는 y를 나눈 X 같은 수학을하고있다. 그리고 라인 당 모두 x와 y, 코드의 이전, 정수입니다. 

또한, 라인 (15)에, 우리는 이야기의 printf, 헤이, printf와 플러그인 정수, 플러그인 정수 플러그에 integer-- 구체적 X, 다음 y 및 다음 X Y로 나눈. x와 y는 정수이다. 우리는이 좋은입니다. 

그러나 여기서 x는 x로 어떻게 구분합니까? X, Y가되어야로 나눈 수학적으로, 1/10, 0.1, 어떤 실수, 실수이다 잠재적으로, 소수점을 갖는. 그것은 정수 아니다. 

그러나 가장 가까운 것입니다 1/10, 0.1 정수? 그래, 종류의 제로이다. 0.1이 훨씬 같다. 그리고 일이 많이 있습니다. 그래서 1/10에 가까운 0는 하나보다. 

그래서 C는 us--을 위해 무엇을하고 있는지 종류의 우리가 그것을 건 ... 말 때문에 그 정수를 절단한다. 또한 다시 한 값을 복용 0.1000 같은 것을해야하는데, 0 등등. 그리고 그것은 모든 것을 자르는 것 소수점 이러한 모든 때문에 물건이 없기 때문에 정수의 개념에 들어있는 1, 0, 1과 같은 부정적인 단지 숫자로, 위로 아래로, 그것은 모든 것을 버린다 당신 때문에 소수점 소수점에 맞지 않을 수 있습니다 정의에 의해 정수입니다. 

그래서 여기에 대한 답은 0이다. 그래서 우리는 어떻게이 문제를 해결합니까? 우리는 모두 함께 다른 솔루션이 필요합니다. 다음과 같이 우리는,이 작업을 수행 할 수 있습니다. 

내가 앞서 가자 새를 만들 파일이 하나 floats.c을했다. 그리고 여기에 저장 같은 디렉토리, float.c. 그리고 내가 가서 복사하자 이전부터 코드의 일부. 

그러나 대신에 점점 int 형은,이 해 보자. 나에게 부동 소수점 값을 지정 X라고합니다. 여기서 부동 소수점 값은 그대로입니다 부동 소수점 뭔가. 그것은 오른쪽으로, 왼쪽으로 이동할 수 있습니다. 그것은 실수입니다. 

그리고 내가하지 부르 자 INT를 얻을 수 있지만, 플로트를 얻을, 또한 메뉴 중이었다 C250 라이브러리의 옵션. 의는 float로 Y를 변경할 수 있습니다. 그래서이 플로트를 얻을된다. 

그리고 지금, 우리는 정수를 연결하고 싶지 않아요. 그것은 우리가 퍼센트를 사용할 필요가 밝혀 플로트에 대한 F, 부동 소수점에 대한 %의 F, 지금 저장합니다. 그리고 지금, 손가락이 교차 만들 수레, 좋은, 도트 슬래시 수레. 여기서 x는 하나 (1) Y가 될 것입니다 다시 10을 될 것입니다. 

그리고, 좋은, OK 내 추가 올바른 것입니다. 나는 더 기대했다 하지만 난 그것을 작성하는 잊어 버렸습니다. 그럼 가서이 논리 오류를 수정 할 수 있습니다. 

이제 가서 다음을 잡아 보자. 우리는 단지 약간의 복사 및 붙여 넣기를 할 수 있습니다. 그리고 마이너스 말거야. 

그리고 나는 시간을 말하는거야. 그리고 나는 나누어 말할거야. 그리고, 모듈을 않을거야 이는, 여기에 같은 게르만하지 않습니다 F로 분할하고, 회 plus-- OK, 이제 다시이 작업을 수행 할 수 있습니다. 

확인 수레, 도트 슬래시 수레, 1, 10, 그리고 - 좋은, 아니, 확인을 클릭합니다. 그래서 나는 바보입니다. 그래서 이것은 매우 일반적인 컴퓨터 과학 이 바보 같은 실수를합니다. 

교육적 목적을 위해, 내가 정말하고 싶었던 여기에 과학을 변경했다 더하기, 빼기에, 배, 희망 당신으로, 분할하기 이 운동을하는 동안 나타났습니다. 그래서 지금의이 다시 컴파일하자 프로그램, 점 슬래시 수레을한다. 

그리고 세 번째로,하자 내 기대를 충족되는지 확인합니다. 1, 10, 1.000, OK, 그래, 입력, 10.000 나눈, 0.100000이다. 그리고 그것은 우리가 제어 할 수 있습니다 밝혀 얼마나 많은 숫자는 그 소수점 후입니다. 우리는 실제로 것입니다. 우리는 다시 그에게 올 것이다. 

하지만 지금은, 사실, 수학은 올바른 것입니다. 그래서, 다시, 테이크 아웃은 여기에 무엇입니까? 그것은 C에 있다는 것을 밝혀 뿐만 아니라 단지 사실, strings--하고, 정말이없는 우리 때문에 CS50 라이브러리들을 추가 할 수 있습니다. 그러나 단지 정수가 없습니다. 

또한 수레가 있습니다. 그리고 다른 데이터의 무리를 밝혀 종류도, 우리는 오래 전에 사용하는거야. 단일 것인지 밝혀 문자의 문자가 아닌 문자열 당신은 단지 문자를 사용할 수 있습니다. 

당신은 부울을 원한다면 밝혀, 만 참 또는 거짓 부울 값, CS50 라이브러리 덕분에, 우리는했습니다 뿐만 아니라 C 부울 데이터 유형에 추가됩니다. 그러나 그것은 또한에 존재하는 것 많은 다른 언어뿐만 아니라. 그리고 가끔 당신에게 밝혀 다음 기본적으로 올 더 큰 숫자가 필요합니다 정수와 수레. 

그리고, 사실, 이중 숫자는 즉,하지 32 비트,하지만 64 비트를 사용합니다. 그리고 오래 오래는 숫자입니다 아니라 32 비트이지만 64 비트를 사용 각각 부동 소수점에 대한 각각 값과 정수. 이제 실제로하자 행동이를 참조하십시오. 

여기 가서거야 그리고 다른 프로그램을 채찍. 자, 내가 가서거야 및 CS50.h.을 포함 할 그리고 나 가자, 표준 IO.h. 포함 

그리고 당신이 뭔가를 알 수 있습니다 펑키 여기에서 일어나고있다. 그것은 사물을 코딩 색상 아니에요 이전과 동일한 방법. 그리고 그게 내가 때문이다, 밝혀 물건을 파일 이름을 지정하지 않았습니다. 

나는이 하나를 호출거야 sizeof.c, 그리고 저장을 누르십시오. 그리고 내 매우 어떻게되는지 알 그 검은 배경에 흰색 코드입니다. 지금, 적어도 거기 일부가 보라색. 그리고 그것은 구문 강조한다. 

아주 간단하게, 나는했습니다 때문이다 파일의 형식 IDE를 말했다 그것의 이름을 제공함으로써, 그리고 특히 파일 확장자. 자, 가서이 작업을 수행 할 수 있습니다. 나는 앞으로 매우 갈거야 단순히 following-- 부울을 인쇄 %의 LU입니다. 

우리는 다시 올 것이다 그냥 순간에 그. 그리고 내가 갈거야 부울의 인쇄 크기. 그리고 지금, 바로 저장 자신 시간, 난 전체를 할 것 한 번에 이들의 무리. 그리고, 특히, 나는에 갈거야 숯불과 문자로 변경. 이 사람은, 내가 바꿀거야 더블 더블로. 

이 사람은, 내가 바꿀거야 부동 소수점 및 부동 소수점한다. 이 사람은, 내가 갈거야 int 형과 int로 변경합니다. 그리고이 사람은, 내가 갈거야 오래 오래로 변경합니다. 그리고 그것은 여전히​​ 복용 시간이 오래, 오래 오래. 

그리고, 마지막으로, 내가 준 자신은 너무 많은 문자열. 그것은 C에, 거기에 밝혀 라는 특수 연산자 그 크기는 그대로입니다 때 실행하는 것, 우리의 크기를 말해 이러한 변수의 각. 그리고 이것은 지금, 방법입니다 우리는 다시 연결할 수 있습니다 지난 주 토론 데이터 및 표현. 

내가 가서 컴파일하자 의 도트 슬래시 크기의 크기입니다. 그리고 보자. 그것은, C에서 밝혀 특히 CS50 IDE에, 특히에 운영 체제 우분투, 64 비트는 동작 인 이 경우 시스템, 부울는에 가고 공간 1 바이트를 사용합니다. 즉, 크기를 측정하는 방법은, 하지 비트,하지만 바이트입니다. 그리고 한 바이트는 8 비트 것을 기억합니다. 그래서 부울, 심지어하지만 기술적으로 만하면 0 또는 1, 그것은 약간의 낭비입니다 우리는 어떻게 그것을 구현했습니다. 실제로 전체를 사용하는 것 byte-- 그래서 모두 제로는, 어쩌면이다 그런 모든 것들, 또는 무엇인가, 또는 한 1 8 비트 중. 

숯불는 한편, 문자 사용 지난 주 ASCII 문자처럼, 하나의 문자가 될 것입니다. 그리고 그것은 우리의 개념과 함께 한단 그것은 오히려 더 이상 256 bits--되는 없습니다 그것은 더 인과 한단 위로 이상 8 비트, 어떤 우리에게 256 개의 값을 제공합니다. 이중이 가고있다 8 바이트 또는 64 비트합니다. 

플로트은 4입니다. int입니다은 4입니다. 긴은 길이 8입니다. 그리고 문자열은 8입니다. 하지만 그것에 대해 걱정하지 마십시오. 우리는 층을 벗겨 것입니다. 그것은 문자열 수, 밝혀 8 바이트보다 더 길어질 수 있습니다. 

그리고, 참으로, 우리는 서면으로 작성했습니다 이미 문자열, 안녕하세요 세계, 8 바이트 이상. 그러나 우리는 다시 올 것이다 그냥 순간에 그. 그러나 멀리 여기 권취은 다음이다. 

모든 컴퓨터는 유한이 메모리 및 공간의 양입니다. 당신은 너무 많은 저장할 수 있습니다 Mac 또는 PC에있는 파일. 당신은 매우 많은 프로그램을 저장할 수 있습니다 RAM에도, 반드시 한 번에 실행 가상 메모리 때문에 당신은 RAM의 한정된 금액을 가지고있다. 

그냥 경우 picture--하기 당신은 노트북을 열어 적이 없어요 또는 추가 메모리를 주문 컴퓨터를 들어, 알고하지 않을 수 있습니다 컴퓨터의 내부 보이는 무언가가있다 이런 작은. 그래서이 이름을 그냥 일반적인 회사입니다 중요한 그 컴퓨터의 RAM을합니다. 그리고 RAM은 어디에 프로그램입니다 그들이 실행하는 동안 살고 있습니다. 

그래서 당신은 두 번 모든 Mac 또는 PC에 프로그램을 클릭하고 열어, 그리고 일부 Word 문서를 엽니 다 또는 그런 일, 일시적에 저장 RAM, RAM 빨리 때문에 하드 디스크 이상, 또는 솔리드 스테이트 디스크. 프로그램이 어디로 그래서 그냥 그들이 실행중인 경우 살, 또는 파일을 사용하는 경우. 

그래서 당신은 볼 일이 노트북이 내부처럼, 또는 약간 더 큰 것 바탕 화면의 내. 그러나 열쇠는 당신 만이있다 이러한 것들의 유한 수. 그리고의 유한 한 양있다 하드웨어는이 책상에 앉아있는 권리 이리. 

그래서, 확실히, 우리는 저장할 수 없습니다 무한히 긴 번호. 그리고, 그러나, 당신은 되돌아 생각하면 초등학교, 얼마나 많은 자리 수 당신은 오른쪽에 있습니다 소수점? 그 문제에 관해서는, 얼마나 많은 자리 수 당신은 소수점의 왼쪽에있다? 정말, 무한히 많은. 

이제, 우리 인간은 수도 만 발음하는 방법을 알고, 그리고 억, 조, 및 천조 및 quintillion. 그리고 난의 한계를 밀어있어 내 understanding-- 또는 거니 이해 숫자,하지만 내 숫자의 발음. 그러나 그들은 함께 무한히 큰 얻을 수 있습니다 왼쪽에 무한히 많은 숫자 또는 소수점의 오른쪽에. 

그러나 컴퓨터 만이 메모리의 유한 한 양, 트랜지스터의 유한 번호, 내부 전구의 유한 수. 그래서이 때 발생 당신은 공간이 부족? 즉, 만약 다시 지난 주에 생각 우리는 숫자에 대해 이야기 할 때 자신은 바이너리로 표현되는 우리가 가지고 있다고 가정 여기에서이 8 비트 값. 

그리고 우리는 일곱 1의 하나의 공을 가지고있다. 그리고 우리가 원하는 것을 가정 이 값에 1을 추가 할 수 있습니다. 이것은 지금 정말 큰 숫자입니다. 

내가 기억하는 경우에, 254 지난 주 오른쪽에서 수학. 그러나 나는 무엇을 변경하는 경우 오른쪽 0 1인가요? 전체 수의 물론에는 8 일의가됩니다. 그래서 우리는 여전히 좋은입니다. 

그리고 아마 대표 255하지만 문맥에 따라 실제로 나타낼 수 있습니다 음수. 하지만 다른 시간에 대한 자세한. 이 약처럼이 느낌 나는 셀 수만큼 높은. 

지금, 그것은 단지 8 비트입니다. 그리고 내 맥, 확실하게, 방법이 메모리의 8 비트 이상의. 그러나 유한 가지고있다. 그래서 동일한 인수하더라도 적용 우리 화면에이 사람을 더 많이 가지고있다. 

하지만 당신이 있다면 어떻게 이 번호 255를 저장, 당신은 1 비트 더 높은 계산하려면? 당신은 255에서 256로 가고 싶어. 이 문제는 물론, 그 경우 당신 지난 주와 같은 제로 카운트 시작 당신은 높은 셀 수 없다 256로, 혼자 257을 보자 혼자 258 보자 m 무엇 때문에 당신이 하나를 추가 할 때 어떻게됩니까? 당신은 오래된 초등학교를 할 경우 방법, 당신은 여기에 1을 넣어 다음 1 더하기 1은 2이지만, 그건 정말 제로, 당신은 1 휴대, 1을 가지고, 1을 수행한다. 이 모든 것들이, 이 일의의는 제로로 이동합니다. 그리고 당신은 사람으로, 그래, 바람 좌측에 1을 지적했다. 하지만 모든 것을 수행 할 수 있습니다 실제로보고 메모리에 맞지 말을 그냥 팔 공의입니다 어떤 시점에서 당신의 경우, 컴퓨터, 충분히 높이까지 계산 시도, 당신은있어 랩 어라운드 것, 그것은 보인다 아마 제로 또는 마이너스 제로보다 훨씬 낮은 수치. 

그리고 우리는 종류의이을 볼 수 있습니다. 내가 가서 쓸 수 여기 진짜 빠른 프로그램입니다. 내가 가서 쓸 수 오버 플로우라는 프로그램. 포함 CS50.h 포함 표준 IO.h-- 오, 난 정말 내 구문 강조를 놓쳤다. 그럼 overflow.c으로 저장 할 수 있습니다. 

그리고 지금 INT 주요 void-- 긴 전에, 우리는거야 이유를 설명에 돌아온다 우리는 INT 주요 무효를 작성 유지한다. 하지만 지금은, 그냥하자 부여는, 그것을 복용. 의 자신에게 int를 줘 보자, 0으로 초기화합니다. 

의 다음 인터넷 용하자 내가 zero-- 얻을 실제로,의 무한 루프를하자 그리고 무슨 일이 일어 나는지. 진정한 동안, 다음의 n을 출력 할 수 퍼센트 난, 백 슬래시 N, 플러그인 N. 하지만, 지금의 n은 n은 플러스 1 취득 할 수 있습니다. 

즉, 각 그래서 이 무한 루프의 반복, 의를 n의 값을 보자, 한 다음에 1을 추가하고, 왼쪽에 다시 N에 결과를 저장합니다. 그리고, 사실, 우리는 구문 봤어요 약간 이런 식으로 짧게. 멋진 트릭을 대신하다 이 모든을 작성, 당신은 실제로는 n 플러스 1에 해당 말할 수있다. 

아니면 정말 멋진 수 있도록하려면, 당신은 N 플러스 플러스 세미콜론 말할 수 있습니다. 그러나 이러한 후자의 두 단지입니다 우리는 문법 설탕이라고 부르는 제일 먼저합니다. 

우선, 더 명시 적입니다 완전히 잘 완전히 올바른. 하지만이 일반적이다, 내가 말할 수 있습니다. 그래서 우리는 단지 잠시 동안이 작업을 수행 할 수 있습니다. 

소리의 지금 만들어 보자 오버 플로우, 오히려 불길한, 도트 슬래시 오버 플로우. 의 n 개의 꽤 큰지고있어, 보자. 그러나의 생각하자 n은 얼마나 큰을받을 수 있나요? 

n은 int이며. 우리는의 크기가 조금 전에 보았던 예를 int는 4 바이트입니다. 우리는 지난 주 알고, 4 바이트입니다 32 비트 때문에 8 시간 4, 즉 32입니다. 즉, 40 억이 될거야. 

그리고 우리는 80까지입니다. 이것은 영원히 걸릴 것입니다 나는 같은 높이로 가능한 계산합니다. 그래서 앞서 갈거야 당신은 머지 않아 수도 그리고, 솔직히 컨트롤을 제어 C-- 충돌 C, 많은, 위치 제어 C 일반적으로 수단을 취소 할 수 있습니다. 불행하게도,이 때문에 클라우드에서 실행되고, 때때로 구름입니다 너무 많은 물건을 침, 너무 많은 출력, 그것은 것 내 입력을위한 약간의 시간이 걸릴 클라우드로 얻을 수 있습니다. 그래서 공격에도 불구하고 몇 초 전에 제어 C, 이것은 확실히 쪽 무한 루프의 효과. 

그래서 이러한 경우에, 우리는있어 그 떠날 예정. 그리고 우리는 서로를 추가 할거야 여기에 터미널 창 물론하지 않는 플러스와 함께 그런 식으로, 아직 생각을하기 때문이다. 그리고 이제 가서하자 좀 더 합리적인. 

내가 가서 할거야 이 단지 유한 한 여러 번. ,의 루프에 대한 사용하자 이는 내가 이전에 언급. 이 해 보자. 나에게 내가 공 얻는다 다른 int 변수를 제공합니다. 난,의, 난 ++ (64)를 가정 해 봅시다보다 작습니다. 그리고 지금 나를 앞서 및 인쇄 가자 n은 퍼센트 내가 체크 아웃, n은 콤마. 그리고 이것은 여전히​​ 다음 N-- 영원히 걸릴 것. 이 해 보자. 

n을 가져 n 번 2. 아니면 우리는 멋진 될 수 있습니다 및 시간이 동일 할. 하지만 그냥 N 가정 해 봅시다 시간이 자체 같습니다. 즉, 이것으로 이 프로그램의 새로운 버전, 나는 영원히 기다리지 않으 같은 80 만 40 억에에서. 그냥이 이상하자. 

의 실제 n은 각각 시간을 두 배로 할 수 있습니다. 어느, 리콜, 두 배는이다 물론 갖는 대향. 그리고 지난 주 반면 우리는이 어떤 또 다시, 다시, 슈퍼 빠른, 두 배는 확실히 것 가장 큰 가능한 1에서 우리를 얻을 우리가하는 int로에 믿을 수있는 값입니다. 

그럼 바로이 작업을 수행 할 수 있습니다. 그리고 우리는 오래 전에 다시이에 올 것이다. 그러나 이것은, 다시, 단지처럼 스크래치에서 반복 블록. 그리고 당신은 오래 전에이 사용됩니다. 

이것은 단지 0에서 수를 의미 64,하지만 같지까지. 그리고이 각각의 반복에 루프는 그냥를 증가 유지. 그래서 나는 + + -이 일반적인 구조 라인 7은 슈퍼 일반적인 방법입니다 의 일부 라인을 반복 코드, 시간의 일부 번호. 어떤 코드 라인? 이 중괄호, 당신 같은 지금부터 수집 한 수, 다음을 의미한다. 

그것은 같은 스크래치에있어, 때 그것은 노란색 블록이 다른 색상이 가지 수용 또는 다른 블록을 포옹. 즉, 어떤 사람들 곱슬이다 중괄호는 여기하고있다. 그래서 난 내 구문을 가지고있는 경우 right--을 C 수단의 당근 기호를 볼 수 있습니다 그게 내가 얼마나 많은 시간이다 이 문제를 해결하려고. 그래서 그 하나를 제거 내버려 모두, 그 창을 닫습니다. 그리고 우리는 새로운 하나를 사용합니다. 오버 플로우, 도트 슬래시 만들기 오버 플로우, 입력, 모든 권리, 먼저 나쁜 보인다. 그러나 이제 시간을 거슬러 이동하자, 나는이 64 시간을했기 때문에. 

처음으로 알, n은 1이다. 두 번째는, n은 2이고 다음 4, 다음 8 다음 16. 그리고 그것은 가능한 한 빨리 것 같다 나는 약 10 억에 도착 내가 다시 두 배로 경우, 그 나에게 20 억을 제공해야합니다. 하지만 그건 밝혀 첨단 오른쪽. 

그리고 실제로 오버 플로우 10 억에서의 int 이 약 마이너스 억, 정수 때문에, 숫자의 우리와는 달리 지난 주 가정하고, 긍정과 부정 모두가 될 수 현실과 컴퓨터입니다. 그리고 그 너무 적어도 하나의 비트는 효과적으로 도난. 그래서 우리는 정말 만, 31 비트가 또는 20 억 가능한 값. 

하지만 지금은 테이크 아웃은 아주이다 간단하게, 어떤 이들 번호는 그리고 수학은, 무엇이든 나쁜 일이 결국 발생 결국 당신이 노력하고 있기 때문에 비트에게 너무 많은 시간을 바꾸어 넣습니다. 그리고 당신은 효과적으로 모든에서 이동 1의에 어쩌면 모두 0, 아니면 그냥 몇 가지 다른 패턴 그것은 그 분명히, 상황에 따라, 음수로 해석 될 수있다. 그리고 그것은 가장 높은 I을 보일 수있을 것입니다 이 특정 프로그램에 셀 수 만 약 10 억이다. 그러나 여기에 부분적인 해결책이있다. 당신 그거 알아? 

날이에서 변경할 수 있습니다 오래 오래에 int로. 그리고 내가 여기에 앞서 가자 그리고 내가 가진거야 say-- 부호없는 긴로 변경합니다. 아니면, 나 자신을 기억하지, 어디 보자. 

이제 가서 오버 플로우를 만들어 보자. 아니, 그게 아니라, LLD, 감사합니다. 그래서 때로는 연타가 도움이 될 수 있습니다. 나는 어떤 형식을 기억하지 않았다 지정은 오래 오래였다. 

그러나, 참으로, 연타 나에게 말했다. 녹색, 좋은의 일종이다 아직도 당신이 실수를 의미한다. 내가 LLD를 의미하는 추측입니다. 

그래서, 내가이 충고 걸릴 긴하자 긴 진수, 즉 저​​장합니다. 그리고 도트, 내가 그것을 다시 실행하자 입력 오버 플로우를 슬래시. 그리고 지금 어떤 멋진 것은 이것입니다. 

내가 시간을 거슬러 스크롤하면, 우리는 여전히 시작 동일한 place--에서 계수 1, 2, 4, 8, 16. 공지 사항, 우리가 얻을 수있는 모든 방법 최대 10 억까지. 그러나 우리는 안전하게 20 억에 도착. 

그리고 우리가 40 억에 도착, 다음 80 억, 170 억. 그리고 우리는 더 높은 가고, 이상, 더. 결국,이 역시 휴식. 

결국, 오래 오래 함께, 64 비트 값이 아니라 이는 32 비트 값하면 계산하면 너무 높은, 당신은 주위에 공을 포장. 이 경우, 우리는 일이 음수로 끝날. 

그래서이 문제이다. 그리고이 밝혀 문제는 모든 비밀이 아니다. 나는 의도적으로했습니다에도 불구하고 이러한 실수로 유도, 우리가 모든 종류의 볼 밝혀 우리 또는 우리의 적어도 일부 주위 않습니다. 

레고 스타 워즈에서, 경우에 따라서 혹시 게임을 해본 적이, 당신이 주변에 갈 수 있습니다 밝혀 LEGO 세계에서 물건을 깨고, 본질적으로, 동전을 수집. 그리고 혹시 연주 한 경우 이 게임에 너무 많은 시간, 이 이름이 개별로 여기서, 총 개수했다 당신이 수집 할 수 있습니다 동전 그것은, 40 억을 보일 수있을 것입니다. 

지금, 그것을 실제로 둥근 것. 그래서 LEGO는에 노력했다 쉬운 일 사용자를 유지합니다. 그들은에 정확히 2 그것을하지 않았다 지난 주 당 32 전원. 그러나 40 억은 이유입니다. 또한이 정보를 기반으로 보인다 그 LEGO, 회사 그 이 실제 소프트웨어를 만든 결정 그 동전들의 최대 개수 사용자가 쌓일 수 있습니다 이다, 참으로, 40 억, 그들은 그들의 코드를 선택했기 때문에 분명히, 오래 오래되지 사용하는, 하지만 그냥 정수, 부호 그 정수에만 양의 정수이고, 최대 값은 크게된다. 음, 여기에 또 다른 재미 하나입니다. , 게임 문명에 따라서하는 당신의 일부와, 잘 알고 있습니다 그것은 년 전에 밝혀 이 게임을함으로써에서이 문제였다 당신은 역할을하는 경우 게임에서 간디의, 대신 그를 매우 평화 주의자 인 대신에 믿을 수 없을만큼, 믿을 수 없을만큼했다 공격적, 어떤 상황입니다. 특히, 방법 그 문명 작품은 당신의 경우, 플레이어, 민주주의를 채택하여 공격성 점수는 도착 이 때문에 마이너스로 감소 마이너스, 다음 마이너스 마이너스. 

그래서 당신은 2 빼기 실제 반복하는. 불행하게도, 당신의 반복하는 인 경우 처음 1, 그리고 그것에서 2 빼기 민주주의를 채택 후 여기에 수도 간디 등 그는 매우 passive-- 때문에, 수행 한 공격성의 규모에 1. 그러나 그는 다음, 민주주의를 채택하는 경우 그는 1 음 1로 이동합니다. 

불행하게도, 그들이 있었다 부호 번호를 사용하여, 어떤 의미 그들은 심지어 부정적인 처리 비록 숫자는 긍정적이었다. 그리고 그것은 것으로 판명 1 음의 긍정적 상응하는, 전형적인 컴퓨터 프로그램 (255)이다. 간디가 채택한다면 민주주의는, 따라서이 그의 공격성 ​​점수는 감소 실제로 255의 주위에 롤 그 가장한다 게임에서 공격적인 캐릭터. 그래서 당신이 위로 구글로 할 수 있습니다. 그리고 그것은, 실제로이었던 우발적 인 프로그래밍 버그, 그러나 그것은 아주 입력 있어요 그 이후로 지식. 

즉, 모든 재미와 귀여운입니다. 더 무서운 때 실제입니다 실제 장치가 아니라 게임 이 같은 버그가 있습니다. 사실, 그냥 년 전 기사가 와서 보잉 787 드림 라이너에 대한 아웃. 

그리고 처음 기사 눈은 작은 비밀을 읽습니다. 그러나 그것은 말했다이, 소프트웨어 보잉의 취약점 새로운 787 드림 라이너 제트가 전위는 파일럿을 일으키는 의 통제를 잃고 항공기, 아마도 중반 비행, 연방 항공국 관리 최근에 경고 항공사. 이 판정했다 그 모델 787 전원을 끈 비행기 지속적 대한 248일 모든 교류를 잃을 수, AC, 상기 발전기에 의한 전력 제어 유닛 GCUs 동시에 로가는 안전 모드를 실패합니다. 그것은 나 손실의 종류입니다. 하지만 메모는 OK, 지금은 그있어, 진술, 조건은 소프트웨어로 인해 발생 된 내부 카운터 발전기 제어 후 오버플 단위 연속 전력의 248일. 우리는이 발행된다 손실을 방지하기 위해주의 모든 AC 전기 될 수 있습니다 전원, 비행기의 제어의 손실이다. 

그래서, 말 그대로, 몇 가지 정수가, 일부 또는 등가 데이터 타입, 소프트웨어에서 사용되고 실제 비행기 당신이 당신의 비행기를 유지하는 경우 그 이는 분명히, 충분히 긴에 그냥 실행하는 경우 경우 일 수있다 그들에게 지속적으로 결코 분리 당신의 비행기, 그것은 것, 또는 그 배터리가 죽을시키는, 결국 카운트, 것, 위로, 위로, 위로, 위로. 

그리고, 자연에 의해, 메모리의 유한 한 양 오버플로 롤백합니다 제로 또는 약간의 음의 값, 부작용 인 무섭 실제 현실 비행기는해야 할 수도 있음 재부팅하고, 효율적으로, 또는,이 더 떨어질 수도는 파리로. 문제의 그래서 이러한 종류의 우리와 함께 여전히, even--이는 2015 기사였다 더욱 무서운 당신은 필요하지 않을 때 이해에 감사, 또는 예상 오류의 그 종류. 

그래서 다른 하나는 거기에 밝혀 데이터 표현에 대한 나쁜 일. 심지어 수레가 밝혀 가지 결함, 수레 때문에, 너무, 나는 32 비트를하는 제안, 또는 아마 64 당신은 두 번을 사용하는 경우. 하지만 여전히 유한합니다. 

그리고 캐치는 당신이 할 수있는 경우에 그 숫자의 무한한 숫자를 넣어 소수점 후, 방법 당신은 없다 모든 가능한 나타낼 수 있습니다 우리가 배운 번호 학년 학교는 세계에서 존재할 수 있습니다. 컴퓨터는 본질적에 보유 그 수의 서브 세트를 선택할 정확하게 나타냅니다. 

현재, 컴퓨터는 수 라운드 어쩌면 조금, 그리고 대략 상점에 당신을 허용 할 수 있습니다 당신이 가능하게 할 수있는 번호입니다. 그러나 단지 직관적으로, 당신의 경우 비트 유한 수 있고, 당신은 단지 그들을 순열 수 많은 유한 한 방법이다. 그래서 당신은 아마도 수 없습니다 유한 번호를 사용 비트의 순열의, 0과 1의 패턴, 무한을 나타내는 숫자의 개수 이는 컴퓨터가 수도 있음을 시사 잘 때때로 우리에게 거짓말을합니다. 

사실,이 해 보자. 내가 CS50의 IDE로 돌아 가자. 내가 가서 보자 작은 프로그램을 작성 것을 보여주기 위해, 부정확라는 컴퓨터는 참으로 부정확하다. 

그리고 내가 가서 시작하자 전에에서 코드의 일부, 지금은 그냥 다음을 수행하십시오. 내가 가서 printf의, 퍼센트를하자 f를 10로 나눈 백 슬래시 n은 1. 즉,의 깊은 다이빙하자 1/10처럼 1과 10로 나눈 것이다. 확실히, 컴퓨터는 1/10를 나타낼 수 있습니다. 

그럼 가서 부정확 할 수 있습니다. 어디 보자. 형식은 두 번 입력을 지정합니다. 그러나 인수는 int 형이있다. 무슨 일이야? 

아, 흥미, 그래서 그것은이다 교훈은 앞에서 배웠습니다. 나는 어이, 컴퓨터 쇼, 말하는거야 날 %의 F의 float. 그러나 나는 그것을 2 정수를주는거야. 이 밝혀 그래서, 내가 해결할 수 몇 가지 방법이. 

난 그냥 1.0로 한 켠 수 10.0로 10,하는 것, 참으로, 변환의 효과가 floats--로 여전히 희망 같은 번호. 거기에 뭔가 밖으로 아니면집니다 우리는 오래 전에 다시 볼 수 있습니다. 당신은 번호를 캐스팅 할 수 있습니다. 

당신은이 괄호를 사용 할 수 있습니다 표현은, 당신은 말할 수 이봐, 컴퓨터,이 걸릴 내가 아는 (10)는 int이며. 하지만, 제발 치료 비록 그것은 부동입니다. 그러나 이것은 불필요하게 복잡한 느낀다. 

우리의 목적을 위해 오늘, 그냥 그대로하자 그것들은 부동 소수점 값을 만든다 이 같은 소수점와. 내가 앞서 가자 다시 실행, 확인 부정확, 좋은 점 슬래시 부정확 입력합니다. OK, 우리는 좋은 찾고 있습니다. 

(1)에 따르면, 10로 나눈 내 여기 맥, 참으로, 0.100000이다. 지금, 나는이 초등학교에서 배웠습니다 0의 무한한 수 있어야한다. 그럼 적어도 해보자 그 중 일부를 볼 수 있습니다. 그것은 printf와는 조금 밝혀 우리가 사용했던 것보다 애호가 여전히. 그것은 당신이 지정할 필요가 없습니다 밝혀 단지 %의 F, 아니면 그냥 %의 난. 당신은 실제로 지정할 수 있습니다 여기에 몇 가지 제어 옵션을 제공합니다. 

특히, 내가 갈거야 대답, 헤이, printf와, 실제로 나에게 10 소수점을 보여줍니다. 그래서 조금 이상한 보인다. 하지만 퍼센트를 말한다 점, 얼마나 많은 숫자 당신은 후에보고 싶어 소수점 다음 F 평면에 대해, 그건 그냥 있기 때문에 문서는 말씀. 내가 가서 그 내용을 저장 할 수 있습니다. 

그리고 난 받고 있어요, 너무 알 일을 다시 입력 피곤. 그래서 난 그냥 위로 설정하고 있는데 아래 여기 내 키에 화살표입니다. 그리고 I가 타격 계속 경우 모든 명령을 볼 수 있습니다 것을 내가 만든, 또는 잘못했다. 

그리고 지금 진행 예정하고있어 실제로 분명히, 그 사용합니다. 부정확, 점을 확인 그래서 imprecision-- 슬래시 내가 무엇에 배웠습니다 초등학교는 체크 아웃. 나는 10 진수로 인쇄 할 경우에도 를 배치, 참으로, 0.10000이다. 하지만 당신은 알아? 

의 조금 욕심하자. 나에게 (55)을 보여,의이 같은 가정 해 봅시다 소수 후 지적했다. 이제 정말 보자 스핀 밖으로 프로그램. 나 메이크업으로 리메이크하자 부정확, 도트 슬래시, 부정확성. 

그리고 여기 우리는 간다. 당신의 어린 시절은 거짓말이었다. 분명히, 10로 나눈 1은 참으로 0.100000000000000005551115123-- 

무슨 일 이죠? 음, 만약 당신이 가지 밝혀 기본에에서 충분히 봐 이 표현 수, 그것은 실제로 정확히 1/10, 또는 0.1입니다 제로의 무한한 수. 이제, 그 이유는 무엇입니까? 

그런데, 이것은 간단한하더라도 우리 인체 번호 1은 10로 나눈 여전히 무한 중 하나입니다 숫자는 우리가 생각할 수 있었다. 그러나 컴퓨터는 나타낼 수 유한 한 많은 그래서 번호. 그리고, 효과적으로, 무엇을 컴퓨터는 우리의 가장 가까운 보이고있다 개수 근사 우리는 1/10 믿고 싶어 또는 정말 0.10000 광고 인해서. 

오히려,하지만이입니다 이 얻을 수있는만큼 가깝습니다. 그리고, 참으로, 당신은 보면 후드 아래, 우리가보고 여기로 소수점 이하 55 자리, 우리는 실제로 현실을 참조하십시오. 이제했습니다 여담으로, 경우 이제까지 movie-- 본 당신의 대부분은 아마 haven't-- 하지만 슈퍼맨 3 몇 년 전, 리처드 프라는 기본적으로이 활용 그의 회사의 현실은 많이 훔치는 동전의 분수와 분수의, , 내 기억으로 company-- 때문에 그것은 본질적으로했다 while--을이었다 아무것도 버리는 것은 적합하지 않았다 센트의 개념으로. 

하지만 당신은 추가 할 경우 모든 다시 작은, 작은, 작은 숫자, 그리고 또 다시 경우에서와 같이, 수 그의 경우는, 돈을 좋은 금액을 확인합니다. 

그 같은 생각은에 의해 찢어했다 이제 이전 여전히 최신 있지만 사무실 공간라는 영화, 어디 그 영화에서 사람, 같은 일을했다 그것을 망쳐 완전하게, 너무 많은 방법을 결국 자신의 은행 계좌에 돈입니다. 그것은 모두 매우 의심했다. 그러나 결국, 부정확는 우리 주변입니다. 

그리고 그 역시 할 수있다 사건을 무섭게. 그것은 밝혀 그 슈퍼맨 3 및 사무실 공간 옆으로,이 매우 현실이 될 수 있습니다 세계의 파급 효과 부정확의 현실 데이터의 표현 심지어 우리 인간에게 이 날은 반드시 수행 뿐만 아니라 우리가해야로서 이해, 또는 자주 우리가해야으로 기억한다. 그리고, 참으로, 다음 클립입니다 매우 현실 세계를 살펴에서 당신이 경우 발생하는의 파급 효과 부정확성을 인정하지 않는 숫자 표현에서 발생할 수 있습니다. 

[VIDEO 재생] 

-Computers, 우리는 받아 왔어요 종종 좌절 문제가 , them-- 버그와 바이러스를 이동, 소프트웨어 결함, 작은 가격을 지불 할 편의를 위해. 그러나 첨단 기술 및 고속에서 군사 및 우주 프로그램 응용 프로그램, 작은 문제 수 재해로 확대 될 수있다. 

6 월 4, 1996, 과학자들은 준비 무인 아리안 5 로켓을 시작합니다. 그것은 과학 실시 하였다 위성 설계 정확하게 어떻게 수립 지구 자기장의 상호 작용 태양 바람과 함께. 로켓을 위해 세워졌습니다 유럽​​ 우주국, 그 시설에서 들어 올려 프랑스어 령 기아나의 해안. 

에 대한 37초 -at 비행, 그들은 처음 눈치 뭔가 잘못 가고 있었다. 노즐은으로 선회했다 방법 그들은 정말 안. 비행에 40초 주변, 분명히, 차량 문제가 있었다. 

그들이 만든 때 그건 결정을 파괴한다. 범위 안전 책임자와 엄청난 용기는, 버튼을 누르면, 그 전에, 로켓 폭발 공공 안전에 위험이된다. 

-이는 처녀이었다 아리안 5의 항해. 그리고 그 파괴했다 때문에 결함의 위치 로켓의 소프트웨어에 내장. 아리안에 -THE 문제였다 숫자가 있다는 것을 그 표현하는 64 비트를 요구했다. 그리고 그들은 변환 원 16 비트 번호 그것. 그들은 가정 그 수는 결코 예정되지 않았다 아주 큰 일하는 사람들의 대부분이 64 비트 숫자 숫자 제로였다. 그들은 틀렸다. 

하나의 -THE 수 없음 소프트웨어 프로그램에 동의합니다 생성 수의 종류 또 다른 실패의 루트에 있었다. 소프트웨어 개발이 될 수 있었던 새로운 기술의 매우 비용이 많이 드는 부분입니다. 아리안 로켓은 매우되었습니다 소프트웨어의 성공, 너무 많은 그것은 또한이었다 생성 아리안 5에 사용됩니다. 

년 - 기본 문제는 아리안이었다 5 빨랐다 빠른 가속. 그리고 소프트웨어는했으나, 그를 차지했다. 

로켓의 -THE 파괴 거대한 금융 재앙이었다 모든 인해 분 소프트웨어 오류. 그러나이 제 아니었다 시간 데이터 변환 문제 현대 로켓 기술을 괴롭혀했다. 

시작으로 1991 년 -in 첫 번째 걸프 전쟁, 패트리어트 미사일 비슷한 종류의 경험 수 변환 문제. 결과적으로 28 명 28 미군, 사망, 약 하였다 100 명이 부상, 때 가정 된 애국, 들어오는 스커드을 방지하기 위해, 미사일을 발사하는 데 실패했습니다. 

- 언제 이라크는 쿠웨이트, 미국을 침공 초기 1991 년 사막의 폭풍을 시작, 패트리어트 미사일 배터리는 배치되었다 사우디 아라비아와 이스라엘을 보호하기 위해 이라크의 스커드 미사일 공격. 애국은 미국의 중간 범위 공기 시스템의면에서 제조 레이 시온 회사에 의해. 

패트리어트 요격의 -THE 크기 자체에 대한 약 20 피트이다. 그리고 약 2,000 파운드의 무게. 그리고, 약의 탄두를 운반 나는 대략 150 파운드 생각합니다. 그리고 탄두 자체입니다 높은 폭발성, 어떤 주위 조각이있다. 탄두의 케이스입니다 사슴 사냥 용 총알처럼 행동하도록 설계되었습니다. 

-THE 미사일이 수행된다 컨테이너 당 사, 및 세미 트레일러에 의해 운반된다. 

년 - 패트리어트 미사일 시스템 지금 적어도 20 년 전으로 거슬러 간다. 그것은 원래 설계되었습니다 공기 방어 미사일 등 적군의 비행기를 격추합니다. 첫 번째 걸프 전쟁에서, 그 전쟁이 따라 왔을 때, 육군은에 그것을 사용하고 싶어 스커드가 아닌 비행기를 격추. 

이라크 공군이었다 문제가 너무 없습니다. 그러나 군은 스커드에 대해 걱정했다. 그래서 그들은하려 애국를 업그레이드합니다. 

적을 -Intercepting 미사일 마하 5에 여행 충분히 도전 할 예정였다. 그러나 때 애국 서비스로 돌진했다, 육군은 인식하지 않았다 만든 이라크 수정 자신의 스커드 칠 거의 불가능합니다. 

무슨 일이 것은 스커드입니다 에서오고 있었다 불안정했다. 그들은 흔들 흔들했다. 그 이유였다 순서대로 이라크, 600km를 얻을 수 300 킬로미터 밖으로 미사일, 무게를했다 전면 탄두 중. 그들은 탄두 경량화했다. 

그래서 지금 애국이다 스커드에 와서하려고합니다. 대부분의 시간은 시간의 압도적 인 다수, 그냥 스커드에 의해 비행 것입니다. 애국 시스템 운영자 번 , 애국자는 목표를 놓친 실현 그들은 애국의 탄두를 폭발 그것이 가능하면 사고를 방지하기 위해 땅에 떨어지지 하였다. 

대부분의 사람들이 본 것을 - 그건이었다 하늘에서 그 큰 불 덩어리, 와 같은 오해 스커드 탄두의 차단. 

밤에 - 비록 하늘, 애국자 등장 성공적으로 될 수 있습니다 다란에서 스커드를 파괴, 실수있을 수 없다 성능에 대한. 거기에, 애국의 레이더 시스템 수신 스커드 추적을 잃었 및 때문에 시작하지 소프트웨어 결함에. 먼저 발견 한 이스라엘이었다 더 이상 시스템이 켜져 있는지, 큰 시간 불일치 때문에 내장 된 시계가되었다 이 시스템의 컴퓨터이다. 

대략 125 이주하기 전에 다란의 비극, 이스라엘은보고 국방부 그 시스템은 시간을 손실 하였다. 여덟 시간 실행 한 후, 그들은 시스템 것으로 나타났습니다 눈에 띄게 덜 정확한되고 있었다. 국방부에 의해 반응 애국 배터리의 모든 이야기 시스템을 떠나지합니다 오랜 시간에. 그들은 무엇을 오랫동안 말한 적 전 ... - 팔시간 10 시간 1,000 시간이다. 아무도 몰랐다. 

년 - 애국 배터리 막사에 주둔 다란과 결함이 내부에서 100시간를 통해 시계에 있었다 2 월 25 일의 밤에. 

- 그것은 정확도로 시간을 추적 두 번째의 10 대한. 두 번째의 자, 십분의 흥미로운 숫자입니다, 이 표현 될 수 있기 때문에 정확히 이진에있는 정확히 표현할 수없는 수단 현대의 디지털 컴퓨터입니다. 그것은 믿기 어렵다. 

그러나 예를 들어이를 사용합니다. 이제 번호를 하나의 세 번째 보자. 한 세 번째는 될 수 없습니다 정확히 진수로 표현. 한 세 번째는 0.333이다 무한 동안 진행. 

와 그렇게 할 수있는 방법은 없습니다 소수의 절대 정확도. 즉, 문제의 정확히 종류의 그 애국에 일어났다. 더 이상 시스템이 실행은 더 시간 오류가되었다. 

운전 100 시간 -after의 시간 오류는 1/3이었다 초. 그러나 타겟팅의 측면에서 미사일 마하 5에 여행, 그 추적 결과 600 미터의 오류입니다. 그것은 치명적인 오류가 될 것이다 무엇에 군인을위한 무슨 일이 있었 스커드 발사했다입니다 조기 경보 위성에 의해 검출 그들은 스커드는 것을 알고 있었다 자신의 일반적인 방향으로오고. 이오고 어디 그들은 몰랐다. 

- 그것은 레이더까지 지금이었다 패트리어트 시스템의 구성 요소 다란을 방어하는 것은 찾아 유지 들어오는 적의 미사일을 추적. 

-THE 레이더는 매우 영리했다. 실제로 추적 할 것 스커드의 위치, 다음 어디 아마 예측 레이더 보낸 다음 시간이 될 것입니다 아웃 펄스. 즉 범위 게이트 불렀다. 

- 그럼, 애국 번 충분한 시간을 가지고 결정 돌아가서 다음을 확인 통과 이 검출 된 객체에 대한 위치, 그것은 돌아갑니다. 그래서 잘못된로 돌아 갔을 때 장소는 그 다음에 어떤 물체를보고하지 않는다. 그리고 그것은 전혀가 있다고 결정하지 객체는 잘못된 검출했다 트랙을 삭제합니다. 

-THE 들어오는 스커드가 사라 레이더 화면에서. 그리고 초 후에, 그것을 막사를 강타. 스커드 (28)를 살해하고 마지막으로 하나는 첫 번째 걸프 전쟁 때졌습니다. 

안타깝게도, 업데이트 된 소프트웨어 다음 날 다란에 도착했다. 소프트웨어 결함이 있었다 하고 고정 폐쇄 고생 한 장 패트리어트 미사일의 역사. 

[VIDEO 재생] 데이비드 J. 마란 : 그래서이 모든이다 말 오버 플로우의 이러한 문제가 및 부정확성은 너무 현실이다. 어떻게 우리가 여기에 도착 했습니까? 우리는 printf의에 대해 얘기하기 시작했다. 다시 말하지만,이 기능이 화면에 뭔가를 인쇄 우리는 그 후 도입 몇 가지 다른 기능 소위 CS50의 라이브러리에서. 그리고 우리는 계속됩니다 때문에 시간이를 참조하십시오. 그리고 우리는, 특히, GET 문자열을 사용 및 INT를 얻고, 이제 플로트를 얻을, 그럼에도 불구하고 사람들은 여전히​​ 우리는 발생합니다 머지 않아 자신을 사용합니다. 

그러나 경우에,이 우리는 이미 필요를 볼 다시 무엇을 그 기능을 손 저장하는 방법? 그들은 우리 다시 문자열을 손, int 형, 또는 플로트 나. 그리고 때때로 우리는 그것을 둘 필요 어딘가에 문자열 또는 INT 또는 플로트. 

그리고 그 물건을 저장하는 데, 그냥 기억 스크래치처럼, 우리는 변수가 있습니다. 그러나 스크래치 달리, C에서 우리는 실제 유형이 variables-- 데이터의 유형, 더 generally-- 그 (것)들의 사이에서, 문자열의 int하는 떠, 여전히이 다른 사람. 

그래서 우리는 C에서 변수를 선언 할 때, 우리는 우리의 데이터 형식을 선언해야합니다. 이것은 우리가거야 일이 아니다 학기 이후에해야 할 로 우리는 다른 언어로 전환. 하지만 지금, 우리는 필요합니까 미리 사전에, 컴퓨터 유형에 대해 설명 변수의 우리는 우리를주고 싶다. 

지금, 한편, 인쇄 데이터 유형들 종류 우리에게 무엇을 기대해야하는지는 printf해야합니다. 그리고 우리는, 문자열 퍼센트의보고 및 정수에 대한 퍼센트 내가, 이미 몇 다른 사람. 그리고 그 단순히 요구 사항 시각적 프리젠 테이션 정보의. 

이들 각각은 실제로 될 수 매개 변수화 또는 어떤 방법으로 불통, 당신이 컨트롤을 촉진하려는 경우 당신이 얻을 출력의 유형입니다. 그리고, 사실, 그뿐만 아니라 밝혀 새로운 라인 백 슬래시 N이있다. 다른 백 슬래시라는 뭔가가있다 캐리지 리턴에 대한 연구한다 에 더 가깝다 구식 타자기, 또한 윈도우는 몇 년 동안 사용. 

탭의 백 슬래시 t이있다. 당신이 원한다면 것을 밝혀 문자열 내부에 큰 따옴표, 우리가 사용했던 리콜 큰 따옴표를 두 번 왼쪽과 오른쪽에 인용 지금까지 우리의 문자열로 끝납니다. 즉, 일을 혼동하는 것 같다. 

당신의 따옴표를 넣어하려는 경우 실제로, string--과의 중간, 그것을보고 혼란이다. 그리고 당신은 너무, 탈출해야 , 뭔가 이중 인용 부호를 말한다 같은, 말 그대로, 큰 따옴표를 백 슬래시. 그리고 아직도 다른 몇 가지가 있습니다. 그리고 우리는 그 이상을 볼 수 있습니다 오래 전에 실제 사용한다. 

그럼 지금부터 전환하자 데이터 및 표현, 및 산술 연산자, 모든 그 중 우리에게 약간의 건물을 준 와 블록을 재생합니다. 하지만 지금의이 실제로 제공 할 수 우리 어휘의 나머지 우리는 이미 한 것으로 스크래치와 지난 주 다른에 모습을 취함으로써 C--에서 구조되지 모두. 그러나 아이디어는 우리 것 정말 볼에 대한 에서 번역을 강조하기 위해 하나의 언어, 스크래치, 다른, C. 

그리고 시간이 지남에, 우리가 데리러 갈게 우리의 툴킷에 대한 더 많은 도구, 그래서 구문, 말을합니다. 그리고, 참으로, 당신은 아이디어를 볼 수 있습니다 지금 지난 주보다는 잘 알고 있습니다. 그래서이 작업을 수행 할 수 있습니다. 

이제 가서 프로그램을 채찍질하자 그 사실은 몇 가지 표현을 사용, 부울 식입니다. 내가 여기에 앞서 가자 새 파일을 만듭니다. 나는이 condition.c를 호출 할 수 있습니다. 

내가 가서 보자 CS50 라이브러리를 포함한다. 그리고 내가 가서 포함 할 수 우리의 기능에 대한 표준 IO.h, 과의 printf 등 각각. 나 자신에게의 상용구를 제공하자 그의 설명 우리는거야 INT 주요 무효, 뒤로 앞으로 온다. 

지금 내가 가서 해주지 자신의 get INT를 통해 INT. 그리고 내가 가서이 작업을 수행 할 수 있습니다. 내가하자 less-- 경우 내가하고 싶은 말 음, 양의 구별, 또는 0 값. 

i가 0보다 작은 경우 그래서, 저를 보자 다만이 프로그램은 단순히 말을 가지고, 음, 백 슬래시 n을, 다른 I는 0보다 큰 경우. 지금은 물론, 말거야 긍정적 인, 백 슬래시 N을는 printf. 그리고 또 나는이 작업을 수행 할 수 혹시 .... 

내가 0 동일한 경우 나는 할 수있다. 하지만 난에서 만드는 것 이미 적어도 하나의 실수. 등호가 있음을 기억하라 동일하지, 우리 인간이 그것을 알고있다. 

그러나 할당 연산자입니다. 그리고 우리는에 0을하지 않으 오른쪽과 왼쪽 난에 넣어. 그래서이 혼란을 피하기, 또는하기 아마도 등호의 오용 서명, 인간은 몇 년 전에 결정 많은 프로그래밍 언어 당신은 어떤지를 확인하고자 할 때 왼쪽과 오른쪽 사이 당신은 실제로 동등한 동일 사용합니다. 그래서 당신은 등호 두 번에 서명했다. 당신은 오른쪽에서 할당 할 때 왼쪽에, 당신은 하나의 등호를 사용합니다. 그래서 우리는이 항아리 다른 할 수있는 전 같으면 0 인. 

그때 가서 수 내 중괄호를 엽니 다 과의 printf 0, 백 슬래시 N, 수행, 말한다. 하지만 방법이 기억 도로에서 포크 작업 할 수 있습니다. 그리고, 정말로, 그냥 논리에 대해 생각합니다. 나는 숫자입니다. 이는 구체적으로, 정수이다. 그리고 그것은 덜 될 것 의미 0, 0 0보다, 나보다. 그래서이 종류가있다 묵시적 기본 케이스. 

그래서 우리는 그냥 좋아하는 수 스크래치,의 다른 경우 생략 그냥 다른 말한다. 논리적으로, 만약 당신이 프로그래머가 만 알고 세 가지 버킷 이는에 시나리오 첫 fall-- 수 두 번째 또는 세 번째 이하지 않는 case--에 추가 정확도를 추가 귀찮게 거기에 추가 논리. 그냥 함께 진행 여기에 다른 사람의 기본 케이스. 

이제, 앞서 가자 이 저장 한 후, 확인 조건은 conditions-- 슬래시 점 없는 훌륭한 사용자 인터페이스, 내가 묻지 않을거야 때문에 사용자는 내가 앞서 언급으로. 하지만 괜찮아요. 우리는 간단하게됩니다. 의이 수 (42)를 해보자. 그리고 긍정적이다. 의이 수를 해보자 음, 42 음. 

의의 값이 0 해보자. 그리고, 참으로, 그것을 작동합니다. 지금, 당신은 전에 문제를 볼 수 있습니다 긴 테스트 것들 세 번, 아마 충분하지 않습니다. 당신은 아마 몇 가지를 테스트하려면 더 큰 숫자, 몇 가지 작은 숫자, 일부 코너의 경우, 같은 우리는 그들을 설명하기 위해 온 것입니다. 

하지만 지금,이 인 아주 간단한 프로그램. 그리고, 논리적으로, 확실 해요 그것은 세 가지 경우로 떨어질 것이다. 그리고, 참으로, 심지어 우리하지만 단지 잠재적 인 단점에 초점을 맞춘 부정확 및 오버 플로우에서 CS50의 문제가 많은 현실 경우, 우리는 걱정하지 않을 수 있습니다 모든 시간에 대한, 오버 플로우의 그 문제와 부정확성 때문에, 사실, C에서, 사실은 모두가 아니다 그 그 일을 방지하기 쉬운. 당신은 카운트하려면 더 큰, 더 큰, 더 큰, 이 기술을 사용하면이 밝혀 자주라는 것을 포함, 사용할 수 있습니다 라이브러리, 코드의 수집, 그 당신이 사용할 수있는 다른 사람들이 쓴 같은 다른 언어 실제로 자바와 다른 사람, 그것은 훨씬 쉽게 만들 더 높은 계산합니다. 그래서 정말 이러한 위험의 일부입니다 당신이 사용하는 언어의 함수. 그리고 앞으로 몇 주 안에, 우리는거야 정말 얼마나 위험 C를 참조하십시오 당신이 그것을 제대로 사용하지 않는 경우 일 수있다. 그러나 거기에서,와 함께 파이썬, 자바 스크립트, 것입니다 우리는 몇 가지 추가 보호를에 층, 그 위험의 적은 실행합니다. 

그럼 만들어 보자 조금 더 우리의 프로그램에서 흥미로운 논리. 그래서 내가 가서 만들 수 있습니다 논리라는 프로그램 그냥 좀 놀 수 있습니다 실제 로​​직, logical.c. 난 그냥 복사 일부를 붙여 넣기합니다 이전 그래서 코드에서 나는 돌아 가야 이 좋은 출발점이다. 

난 문자 C.을 나에게이 시간을 보자 그것을 C의 이름을 지정 예정 그것은 기존의 그냥 있기 때문에, 사용자로부터 문자를 얻을. 그리고 이제 척하자 나는 부분을 구현하고 있습니다 그 Rm의 프로그램의 제거 그 이전 프로그램은 사용자를 프롬프트 파일을 제거합니다. 우리는 이것을 어떻게 할 수 있습니까? 

C가 동일한 경우는 내가하고 싶은 말 , 인용 인용을 끝내, 동일 Y는 다음 나는 가정거야 사용자가 예를 선택했다고. 난 그냥 예 인쇄 할거야. 실제로 기록 된 경우 제거 프로그램 우리는 파일을 제거 할 수 있습니다 코드의 더 많은 라인. 그러나 우리는 간단하게됩니다. 

다른 C가 동일한 경우 N-- 동일 지금 여기, 내가 말할거야 사용자는 어떤 의미가 있어야합니다. 그리고 다른, 그거 알아? 나는 어떤 다른 모른다 사용자가 입력하는 것입니다. 그래서 난 그냥 그런 말을하는거야 그 오류, 무엇이든 그 또는 그녀는 실제로 입력했습니다. 

그래서 여기 일이야? 근본적인 차이가있다 내가 과거에 한 일을 대. 큰 따옴표 큰 따옴표를 두 번 따옴표, 그리고 아직, 작은 따옴표, 작은 따옴표. 이 때, C에서 밝혀 당신은 문자열을 쓰고 싶어요, 당신은 우리가했습니다 것처럼 따옴표를 사용합니까 printf와 함께 모든 시간을 사용하고있다. 

하지만 당신은 단지에 대처하려면 단일 문자, 소위 문자, 당신은 실제로 작은 따옴표를 사용합니다. 프로그램 한 분들 전에, 당신은하지 않을 수 있습니다 이것에 대해 걱정했다 특정 언어로 구분. C에서는 문제 않습니다. 내가 문자를받을 때 그래서 내가 원하는 등호를 사용하여 해당 문자를 비교 Y 또는 N 같은 일부 문자에 동일, 내가, 실제로, 작은 따옴표가 필요합니다. 

자, 가서이 작업을 수행 할 수 있습니다. 이제 가서 확인하자 논리적 점은 논리적 슬래시. 그리고 지금은 묻지하고 있습니다. 그래서, 아마, 더 나은 사용자 경험 실제로 말해 것입니다 무슨 여기에해야 할 일. 하지만 난 그냥 맹목적에 갈거야 좋은, OK, 예에 대한 y를 말한다. 

이제 다시 실행하자, n은 없음에 대한 좋은. 내가 아는 어떤 사람처럼 가정, 내 모자는 키가 너무 자주 모두에 잠급니다. 그래서, 자본 Y는 입력 오류를 않습니다. OK, 내가 기대하고있어 정확히 아니다. 실제로, 컴퓨터 말 그대로 일을한다 나는 확인 do-- 할 말 소문자 y를 소문자 n은. 이 좋은 기분하지 않습니다 사용자 경험하지만. 나에 대해 물어 보자 수락 소문자 나 대문자 중 하나. 이 밝혀 그래서, 당신은 할 수 있습니다 스크래치처럼 뭔가 말을하고, 같은 문자 또는 C 같음 자본 단일 인용 Y 같습니다. 알고 보니, C는 없습니다 이 문자 키워드 나. 

그러나 두 개의 수직 막대를 가지고있다. 당신은 일반적으로 Shift 키를 누른해야 당신이 미국 키보드를 사용하는 경우, 수직 가로대에 맞았 당신의 리턴 키 위의 키. 하지만이 수직 막대 수직 막대는 의미 나. 

경우, 대조적으로, 우리는 원 스크래치처럼, 말을하고, 우리는 앰퍼샌드 앰퍼샌드을 할 수 있습니다. 즉, 여기에 논리적 인 이해되지 않는다 때문에 인간의 가능성이없는 수 입력 한 두 Y와 소문자 y를 같은 문자로 자본 Y. 그래서이거나 우리가 여기서 뭘하려는. 

나는 두 곳에서이 작업을 수행하는 경우, 또는 c 그래서 자본 N, 지금 다시 실행 일치 한 동일 논리 논리 다시 실행합니다. 지금, 나는 Y를 입력 할 수 있습니다. 그리고 난 다시 그것을 할 수 있습니다 자본 Y, 또는 자본 N. 그리고 추가에 추가 할 수 있습니다 아직 조합. 

그래서 이것은 논리적이다 지금처럼하는 한 프로그램 나는에 대해 논리적으로 확인 해요 이 값 또는이 값. 그리고, 반드시 필요 없어 두 개 더 IFS 또는 다른 IFS와 함께 제공됩니다. 나는 실제로 몇 가지를 결합 할 수 있습니다 이러한 방식으로 서로 관련 논리. 그래서이 더 나은 것 단순히보다 설계 C는 소문자 y를 동일한 경우, 말, C는 자본 Y와 동일한 경우는 다른, 예 인쇄, C가 동일한 경우는 다른, 예 인쇄 즉 lower--, 당신은 할 필요가 없습니다 더 많은 지점. 당신은 등가의 일부를 결합 할 수 있습니다 이러한 방식으로 논리적 분기. 

그래서 그냥 한 곳에서 살펴 보자 최종 성​​분, 하나의 최종 구조, 그 C가 있습니다. 그리고 우리는 다시 올 것이다 여전히 다른 사람에게 미래. 그리고 우리는보고 결론을 내릴 수 있습니다 code-- 아닌 정확성에 코드를 얻는 것은 work--하지만 디자인하기 코드로, 초기에 그 씨앗을 심는. 

그래서 내가 가서 보자 여기에 새 파일을 엽니 다. 당신 그거 알아? 나는 다시 구현거야 같은 프로그램, 하지만 다른 구조를 사용하여. 

그래서 자신을주고 빨리 저를 보자 액세스 CS50.h을 포함하는 CS50 라이브러리, printf의 표준 Io.h. 나에게 내 INT의 주요 공간을 제공합니다. 그리고 여기,하자 나 가서 이렇게. 

문자 C는 직전과 같은 문자를 얻을 가져옵니다. 그리고 나는 새로운 구조를 사용하는거야 어떤 캐릭터, 전환 now--? 그래서 스위치는 가지처럼 기차 트랙을 전환. 아니면, 정말, 그것의 종류입니다 다른 경우, 만약 다른 경우, 하지만 다소 다르게 작성합니다. 

스위치는 다음과 같습니다. 당신은 스위치가 다음 무엇을 문자 또는 당신이보고 싶을 수, 그 다음 약간의 중괄호에 좋아 스크래치, 그냥 물건을 말한다. 그리고 당신은 다른 경우가 있습니다. 

다음과 같은 경우와 다른 사용하지 마십시오. 당신은 말 그대로 단어 케이스를 사용합니다. 그리고 당신이 뭔가를 말할 것입니다. 

그래서 소문자 (Y)의 경우, 또는 자본 Y의 경우, 가서 네 인쇄. 그리고 스위치에서 휴식. 이게 다예요. 되었다. 

말하자면, 경우 다른, 소문자 N, 자본 N, 다음 가서 인쇄 밖으로없는 한 다음 휴식. Else-- 그리고이 종류 인 기본 경우 indeed--의 printf error-- 그냥하지만​​, 좋은 측정을위한 논리적으로이 휴식이 필요하지 않습니다 우리는 마지막이기 때문에 어쨌든 스위치, 지금은 스위치의 돌발하고있다. 그래서 이것은 조금 다른 보인다. 

하지만, 논리적으로, 그것은이다 실제로 것과 같습니다. 그리고 왜 사용합니다 다른 통해 하나? 때로는 그냥 개인적인 취향, 때로는 미학, 나는이 언뜻 경우 지금, 거기에 뭔가 라고 할 수 있습니다 이 코드의 가독성. 내 말은,이 사실을 결코 마음 코드는 방에있는 우리의 많은 새로운 기능입니다. 

그러나 그것은 단지 종류의 예쁜입니다. 당신은 소문자 y를, 자본 Y 참조 소문자 N 자본 N 기본, 그냥 가지 점프 방법으로 당신의 밖으로 틀림없이, 어쩌면, 그 앞의 예 IFS의, 수직 막대, 그리고 다른 사람의 IFS는 없을 수도 있습니다. 그래서 이것은 개인의 정말 문제입니다 선택, 정말, 또는 가독성, 코드. 

그러나 기능의 관점에서 나를 보자 가서 스위치, 도트 슬래시을 스위치는, 지금, 소문자 y를 입력 자본 Y, 소문자 N 자본 N, 그 때문에 다윗은 다시 시도 하지 단일 문자. 예상대로의이, 배, 오류를하자. 그리고, logically--이는 뭔가 나는 general--도에 격려 것 우리는 단지 긁적하고 비록 이러한 기능 중 일부의 표면. 

그리고 그것은 분명하지 않을 수 있습니다 때를 자신은 키보드에 앉아 어떻게 작동합니까? 이것은 무엇을 할 것인가? 데에 대한 아름다운 것 노트북 또는 데스크탑, 또는 액세스 컴파일러와 컴퓨터, 이 같은 코드 편집기, 당신은 거의 항상이 대답 할 수있다 다만 노력에 의해 자신에 대한 질문. 

예를 들어, 수사학 경우 손에 질문했다, 당신이 잊어 버리면 어떻게됩니까 당신의 휴식 문? 이는 실제로 할 일이 매우 일반적인, 그것은 보이지 않는 때문에 같은 당신이 정말로 그들을 필요합니다. 그들은 정말 완료하지 귀하 괄호 또는 곱슬처럼 생각 중괄호는 않습니다. 의 앞서 가자와 코드를 컴파일하고 참조하십시오. 그래서 스위치, 도트 슬래시 스위치를 확인하십시오. 의 소문자를 입력하자 Y는 상단 경우, 입력합니다. 그래서 나는 Y를 입력했습니다. 

이 프로그램은 아니, 그래 말했다, 오류, 비록 그것의 마음을 변경했다. 어떤 일이 발생하기 때문에 그러나 가지였다 스위치와 함께 첫 번째 경우는 그 경기는 본질적 의미, 헤이 컴퓨터, 그 아래에 모든 코드를 실행합니다. 그리고 당신은 말을하지 않는 경우 휴식, 또는 휴식을 말을하지 않습니다, 또는 휴식을 말을하지 않습니다, 컴퓨터가 날려 것입니다 그 라인의 모든을 통해 때까지 모두를 수행 그것은 그 중괄호로 가져옵니다. 따라서 브레이크는, 참으로 필요하다. 그러나 여기에 테이크 아웃이 될 때입니다 의심, 무언가를 시도. 아마 먼저 코드를 저장, 또는 별도의 파일에 저장 당신은 정말 걱정하는 경우 엉망 및 복구하는 데 당신이 알고있는 작품 노력하고 있습니다. 

그러나 일을하려고합니다. 그리고, 아마도, 같은 두려워하지 말라 컴퓨터가 할 수있는 무엇, 또는 당신이 뭔가를 깰 수있다. 당신은 항상 다시 되돌릴 수 있습니다 일부 이전 버전. 

그럼보고 끝낼 수 있습니다 코드의 디자인에서. 우리가 작성하는 지금이 능력을 가지고 조건 및 기록 루프 변수 및 통화 기능을 제공합니다. 그래서 솔직히, 우리는 뒷면에 친절 여기서 우리는 스크래치와 주일 전이었다 덜 강력한 텍스트와이기는하지만 스크래치보다 환경이 있습니다. 

그러나 우리가 획득 한 얼마나 빨리 발견 이 경우에도 그 어휘, 에서 싱크 조금 시간이 걸릴 것, 우리가이 용어를 사용할 수 있도록 더 흥미로운 프로그램을 작성합니다. 그리고 이제 아기 조치를 취할 수 있도록 그 방향으로는 다음과 같다. 내가 가서 보자 여기에 새 파일을 만듭니다. 

나는이 전화거야 prototype.c 및 소개 처음 능력 자신의 기능을 확인합니다. 여러분 중 일부는있을 수 있습니다 스크래치와 함께이 일을, 이에 만들 수 있습니다 스크래치에서 사용자 정의 블록, 다음 장소로 드래그 어디든지 당신이 C로하고 싶습니다 그리고 대부분의 프로그래밍에 언어, 당신은 정확하게 수행 할 수 있습니다 that-- 자신의 기능을, 그들은 이미 존재하지 않는 경우. 

그래서, 예를 들어, 내가 앞서 가자 및 CS50.h을 포함하고 포함 표준 IO.h, INT 주요 무효. 그리고 지금 우리는이 갈 준비가 자리 표시 자. 나는 인쇄 일을 계속 사람들의 이름이 오늘있다. 그리고는 이렇게 ... 느낌 좋은하지 않을 경우이 인쇄 이름라는 함수를했다? 나는의 printf를 사용할 필요가 없습니다. 나는 기억할 필요가 없습니다 모든 형식의 코드. 왜하지 I, 또는 왜 내 앞에 누군가를하지 않았다 함수 호출 인쇄를 작성 이름, 몇 가지 이름을 부여하는 것이, 간단하게 출력한다? 

즉, 나는 야, 말한다면 컴퓨터가 나에게 문자열을 제공 예를 사용자에게 요청하여, CS50의 GET 문자열 기능을 통해. 이봐, 컴퓨터에서 해당 문자열을 넣어 좌측의 변수, 그것은이야 호출합니다. 그리고, 컴퓨터 야, 가서 그리고 사람의 이름, 수행 것을 인쇄 할 수 있습니다. 

지금, 그것은 좋은 일 때문에 것 이 프로그램은 적절하게 명명 이하기로되어 있는지 알려줍니다 그 함수의 이름의 방법으로. 내가 가서 프로토 타입을 만들어 입력 할 수 있습니다. 그리고, 불행하게도, 이 비행하지 않을. 

Prototype.c, 7 호선, 문자 5, 오류, 암시 적 선언 기능 인쇄 이름 C99, C99에 유효하지 않습니다 C 버전을 의미 즉, 1999 년에 나왔다. 그게 다야. 

그래서 나도 몰라 무엇을 이 모든 아직 의미한다. 그러나 나는 빨간색으로 오류를 인식 할. 그것은 매우 분명하다. 

그리고 그것은을 가진 것 같다 여기에 녹색 문자, 문제는 인쇄 이름으로 열려 괄호 s에 가까운 괄호, 세미콜론. 그러나의 암시 적 선언 함수 우리는 간단히 이전 보았다. 이 것을 단순히 의미 연타 무슨 뜻인지 알 수 없습니다. 

그것의 것을 나는 어휘 단어를 사용했습니다 본하거나 이전에 배운 적이. 그래서 나는 그것을 가르 칠 필요 이 기능은 무엇을 의미하는지. 그래서 내가 가서 그렇게 할거야. 

내가 가서 구현하는거야 인쇄 이름이라고 내 자신의 함수입니다. 다음과 같이 그리고 나는 것을 말할거야 그것은이, printf와, 안녕하세요, 퍼센트 않습니다 의, 백 슬래시 N, 이름, 세미콜론. 그래서 난 그냥 무슨 짓을 한거야? 

그래서에, 밝혀 자신의 기능을 구현 우리는 가지의 일부를 빌려 메인 동일한 구조 우리는 단지 있었던 것을 촬영 부여, 그리고 알고 그냥 복사 거의 어떤 붙여 넣기 나는 과거에 작성했습니다. 그러나 여기 패턴을 알 수 있습니다. 지능은, 주요, 무효, 우리는 떨어져 애타게합니다 머지 않아이 실제로 무엇을 의미하는지. 

그러나 오늘, 단지 병렬을 알 수 있습니다. 공허, 인쇄 이름, 문자열 이름, 그래서 거기에 보라색 ​​키워드하는 우리는 시작하는거야 의 반환 형식을 호출, 이름 기능하고, 입력. 그래서, 실제로, 우리는 증류 할 수 있습니다 등 지난 주 이런 종류의 이는 나 이름은 그대로 우리가있어 코드의 알고리즘 을 write-- 것 기본 알고리즘 코드는 우리가 작성하는 것입니다. 

이 입력된다. 이 출력된다. 이 기능은 인쇄 이름이며 이름라는 문자열을하도록 설계, 또는 무엇 이건, 입력으로하고 무효. 그것은 아무것도 반환하지 않습니다 같은 문자열을 가져 오거나 INT는 않습니다 얻을. 그래서 다시 내게 뭔가를 손에 것입니다. 그냥있는 것 부작용 말하자면 사람의 이름을 인쇄. 그래서, 7 호선, 알 인쇄 이름을 호출 할 수 있습니다. 선 (10), 나는 정의 할 수 있습니다 또는 인쇄 이름을 구현합니다. 그러나, 불행하게도, 그것은 충분하지 않습니다. 

내가 가서 보자 저장 한 후이를 다시 컴파일. 우와, 지금, 나는 그것을했습니다 더 나쁜, 그것은 보인다. 그렇게 암시 적 선언 기능 인쇄 이름이 잘못되었습니다. 그리고, 다시, 더 많은 오류가있다. 하지만 난 이전주의로 당신이 압도 얻을 경우, 또는 조금 슬픈 너무 많은 것을 볼 수 있습니다 에러는, 제에만 집중 초기 왜냐하면 그것은 단지 수도 계단식 효과가 있었다. 보다 구체적으로 C 또는 연타 그래서 여전히 인쇄 이름을 인식하지 못합니다. 

그리고 그 때문에 연타는이다 디자인, 종류의 바보입니다. 그것은 단지 당신이 그것을 말해 무엇 않습니다. 그리고만을 위해 그렇게 하는 당신이 할 그것을 말해. 

그래서, 온라인 사에 대한 기본 정의 같은 우리는 꽤 자주 해왔습니다. 나는 선 (10)에 인쇄 이름을 정의했습니다. 하지만 내가 사용하려고 해요 라인 일곱에 인쇄 이름입니다. 

그것은 너무 빨리, 아직 존재하지 않는 것. 그래서 영리하고, 같은 수, 좋아, 그럼 그냥 연주하자, 인쇄 이름을 이동 여기에, 다시 컴파일합니다. 세상에. 그것은했다. 그것은 그렇게 간단했다. 

그러나 논리는 정확히이다. 당신은 연타를 가르 칠 필요가 무엇 제 기능을 정의한다. 그럼 당신은 그것을 사용할 수 있습니다. 하지만, 솔직히,이 느낌 미끄러운 경사 등을들 수있다. 

그래서 때마다 나는 실행 문제로, 그냥 해요 선택하고 코드를 복사 예정 나는 그것을 잘라 여기를 붙여 썼다. 그리고, 확실히, 우리는 할 수 몇 가지 시나리오를 고안 여기서 하나의 기능은 수도 서로를 호출해야합니다. 그리고 당신은 모든을 넣을 수 없습니다 다른 모든 위의 함수. 

그래서 거기의 밝혀 더 나은 솔루션입니다. 우리는이 될 남길 수 있습니다. 그리고, 솔직히, 그것은 일반적으로 좋은입니다 편리하고 좋은 디자인 때문에, 다시, 제 1 주 넣어, 다만 녹색 깃발을 클릭 할 때처럼 주, 그 기능입니다 기본적으로 실행됩니다. 그래서 당신은뿐만 아니라 넣을 수 있습니다 파일의 맨 위에 그 그래서 당신이나 때 다른 사람은 파일을 살펴 봅니다 당신은 무슨 일이 일어나고 있는지 알고 다만 주 먼저 읽어. 이 밝혀 그래서, 우리는 연타를 알 수 있습니다 사전에, 헤이, 연타, 행 사에, 내가 구현하는 약속 함수 호출 인쇄 문자열라는 이름을 사용합니다 이름 입력 및 반환 아무것도 무효로. 그리고 주위에 얻을 것이다 나중에 구현. 

여기에 주요 온다. 지금 줄에 9 사용할 수있는 홈페이지 인쇄 이름 때문에 연타 결국, 그 신뢰한다, 그 정의를 만날 인쇄 이름의 구현. 그래서 내 파일을 저장 한 후,하자 나 가서 프로토 타입을, 이 때 좋아 보인다. 점은 프로토 타입, 나를 보자, 슬래시 가서 이름을 입력합니다. 데이비드, 안녕하세요 데이비드, Zamila, 안녕하세요 Zamila, 그리고, 참으로, 지금은 작동합니다. 

그래서 여기 성분은 우리가했습니다 것입니다 사용자 정의처럼, 사용자 정의 함수를 만든 스크래치 블록 우리가 그것을 호출하고 있습니다. 그러나 스크래치와는 달리 어디 수 그냥 만들고 그것을 사용하기 시작, 지금 우리는 일해야 더 현학적 작은 실제로 연타를 양성 사용하거나 예상 할 수 있습니다. 이제 제쳐두고로 모든이 시간은 왜 우리는 다음과 같은 믿음에 그냥 맹목적으로되어 표준 IO.h 포함 CS50.h, 그리고? 

글쎄, 그것은 밝혀, 몇 가지 다른 것들 사이에, 모두 그 점 시간에있어 일이 파일은 파일이어야합니다. 그들은 말하자면, 파일 헤더하고 있습니다. 그들은 여전히​​ C로 작성하고 그러나 파일들은 다른 유형의 것. 

지금, 당신은 꽤 많은 가정 할 수있다 CS50.h의 내부에 그 모든 것을 이 같은 일부 한 - 라이너, 아니다 인쇄 이름이라는 기능, 하지만 문자열을 얻기 위해, 가져 오기 플로트, 그리고 몇 가지 다른. 그리고 유사한 프로토 타입이있다, 표준 IO.h 내부에 하나 라이너, 에 지금의 printf에 대한 내 자신의 인쇄 이름 기능. 그래서 다른 말로,이 모든 시간을 우리는했습니다 그냥 맹목적으로 복사 및 붙여 넣기 한 등이 포함 것을, 무슨 일이야? 사람들은 단서의 단지 종류입니다 어떤 기능으로 연타하기 실제로, 단지 구현 다른 곳에서 다른 파일에 다른 시스템. 

그래서 우리는 인쇄 이름을 구현했습니다. 그것은 이러한 부작용을 가지고 화면에 뭔가를 인쇄. 그러나 실제로는 그렇지 않습니다 다시 나에게 뭔가를 손. 우리는 약 가서 어떻게 프로그램을 실행하는 다시 나에게 뭔가를 손으로 무엇입니까? 

글쎄,이 시도 할 수 있습니다. 내가 가서 구현하자 라는 파일 return.c 그래서 우리는 어떻게 뭔가를 보여줄 수 같은 문자열을 가져 오기, 또는 지능을 가져, 실제로 반환 사용자에게 다시 뭔가. 이제 가서 INT 주요 무효를 정의 할 수 있습니다. 

그리고, 다시 미래에, 우리는거야 그 INT 그 보이드 무엇을 설명 실제로 일이다. 그러나 오늘, 우리는거야 그것을 가지고 부여. 나는, 앞서와의 printf 갈거야 좋은 사용자 경험을 위해, 배입니다. 그리고 나는 기다릴거야 사용자는 가져 오기 INT와 x를 저를 얻었다. 

그리고 내가 가서거야 그리고 광장에 X를 인쇄 할 수 있습니다. 그래서 당신은 단지이있을 때 일반적으로 키보드, 사람들 작은 당근을 사용 키보드의 상징 전원을 대표하는 중 또는 지수. 그래서 제곱 x를 내가 존재한다. 

그리고 지금은이 작업을 수행하겠습니다. 난 그냥 여기서 x는 무엇 do-- 수 제곱? X 제곱은 X 곱하기 x는. 

그리고 우리가했던이 일부 전 시간이 이미 오늘. 이 같은 느낌하지 않습니다 모든 그 정도 진행. 당신 그거 알아? 이제 그 생각의 일부를 활용하자 추상화의 마지막에서. 

이 경우 좋지 않을까 라는 함수가있다 정확하게 작업을 수행 광장? 의 끝에 여전히, 일, 같은 연산을 수행합니다. 그러나의 추상하자 복용의 거리에 아이디어 하나의 수를 곱한 다른 하나는, 그냥 이름을 지정, 등이 값을 제곱. 

또한, 다시 말하면,에 C는의 함수를 만들 수 있습니다 정확하게 작업을 수행라는 광장. 광장 호출 할 것입니다. int를 취할 것입니다. 그리고 우리는거야 그냥 것 기본적으로, n 개의 호출. 

그러나 우리는 우리가 원하는 무엇이든 그것을 호출 할 수 있습니다. 그리고 모든이에게 무슨 일이 문자 그대로, 복귀가 수행 N 곱하기 N의 결과. 그러나 때문에 뭔가를 반환하는 우리는했습니다 보라색의 키워드는 결코 내가 라인 (11)에, 전에 볼 수없는, 그냥이 시간을 무효 말할 수 없습니다. 

공허의 예에서 우리는 방금 본 인쇄 이름의 오히려, 그냥 의미 뭔가. 그러나 다시 나에게 뭔가를 손으로하지 않습니다. 이 경우, 내가 원하는거야 n 번 N 돌아갑니다, 또는 그 무엇이든, 그 번호. 

그래서 난 말할 수 없다, 헤이, 컴퓨터, 나는 무효, 아무 것도 반환하지 않습니다. 본질적으로 int를 반환하는 것입니다. 그리고 그래서 여기에 무슨 일이 전부입니다. 

입력은 광장 하는 int 될 것입니다. 우리가 사용할 수 있도록, 그것은에 보유 이름이, N. 그것은 출력거야 이름을 필요로하지 않는 INT. 우리는 주에 남길 수 있습니다, 또는 누구는 저를 사용하여 우리의 경우이 값을 기억 자신의 변수로합니다. 

그리고, 다시, 단지 새로운 여기에 키워드를 반환합니다. 그리고 난 그냥 수학을하고 있어요. 정말 불필요하고 싶었다면, 나는 INT 제품이 n 번 N 가져옵니다 말할 수 있습니다. 

그리고 나는 제품을 반환 말할 수 있습니다. 그러나,의 다시, 내 지점으로 이전 이 단지없는 좋은 디자인 - 같은, 왜 이름을 소개하고, 상징, 제품 등, 다만 즉시 반환? 그것은 조금 청소기의 조금 더 단단한, 그래서 그냥 반환 n 배 말을, 말하자면 n은 모두이 줄을 없애. 

그리고 그것은 읽을 수있는 단지 적은 코드가 있어요 실수 적은 기회. 그리고 이제이 있는지 확인하자 실제로 작동합니다. 지금, 나는 갈거야 앞서 및 반환을합니다. 

어 - 오, 함수의 암시 적 선언. 나는 전에 더 큰 거래를이 실수를하지 않았다. 나 방금 입력하자, 또는 강조 복사, 동일한 함수 프로토 타입, 또는 서명, 여기까지 함수. 아니면 전체 기능을 이동할 수 있습니다. 

하지만 그건 좀 게으른입니다. 그래서 우리는 그렇게하지 ​​않습니다. 이제, 내가 수익을 만들어 보자 다시, 슬래시 수익을 점. 

X 2. x는 제곱은 4입니다. X 3. x는 제곱은 9입니다. 그리고 기능이 보인다 이제 작동합니다. 그래서 차이는 여기에 무엇입니까? 나는, 사각라고하는 기능을 가지고 내가 입력에 넣어이 경우입니다. 그리고 출력을 다시 얻을. 그럼에도 불구하고, 이전하는 경우 나는 다른 예를 열고 이전로부터의 , prototype.c라고했다 나는 인쇄 이름을 가지고있는 말하자면, 무효 반환, 아니면 아무 것도 반환하지 않으며, 단순히 부작용이 있었다. 

그래서 여기 일이야? 음, 기능을 고려 단지 잠시 문자열을 찾으실 수 있습니다. 우리는 함수를 사용하고있다 다음과 같은 방법으로 문자열을 찾으실 수 있습니다. 

우리는 기능을 얻을 했어 문자열 등이 CS50.h 포함 표준 IO.h, INT, 메인, 무효를 포함한다. 그리고 그 때마다 나는했습니다 지금까지 GET 문자열이라고, 내가 말한 뭔가 문자열의 같은 GET string-- 때문에, 문자열을 얻을 도착 의이 get.c-- GET 문자열을 부르 자 자신은 그때 할 수있는 문자열을 반환 쉼표, 사용, 안녕하세요, 말, 퍼센트의, 백 슬래시 N, S. 

따라서이 같은 예는, 정말, 우리는 이전하였습니다. 그래서 문자열 값을 반환받을. 그러나 잠시 전, 인쇄 문자열 값을 반환하지 않습니다. 단순히 부작용을 갖는다. 그래서 이것은 근본적인 차이가있다. 우리는 다른 보았다 이제 함수의 종류, 그 중 일부는 돌아왔다 값은, 그 중 일부는하지 않습니다. 그래서 어쩌면 문자열 또는 INT 또는 부동입니다. 아니면 그냥 무효입니다. 

그 차이는 이러한 기능이 그 데이터를 가져 값을 반환하는 것은 실제로 테이블에 다시 무언가를 가져, 말하자면. 그럼 가서 보자 하나의 최종 세트 봐 의, 지금은 감각을 준다 예 우리가 어떻게 수도, 참으로, 추상적 인 더, 더 나은, 그리고 더 나은, 이상, 위해서는, 더욱,보다 궁극적으로 더 나은 코드를 작성합니다. 의 전방 이동 및 정신하자 스크래치에, 다음을 수행하십시오. 

내가 가서 포함하자 CS50.h 및 표준 IO.h. 내가 가서 보겠습니다 주 자신의 int, 무효. 그리고 날, 가서이 cough.c를 호출 할 수 있습니다. 

그리고 내가 앞으로 그냥 가자 스크래치처럼, 기침 / N을 인쇄 할 수 있습니다. 그리고이 세 번 싶어요. 그래서 나는, 물론, 그냥 갈거야 복사 세 번 붙여 넣습니다. 지금 만들려고 해요 도트 슬래시 기침 기침. 의 나 자신에게 좀 더 많은 공간을 줘 보자 여기, 기침, 기침, 기침, 입력합니다. 

이미 분명히있다 개선을위한 기회를 제공합니다. 나는 복사 및 붙여 넣기 한 몇 번 오늘. 내가하지 않았다, 그래서하지만 만했다 많은 문자를 입력해야합니다. 난 아직도 변경 내용 코드의 그 라인이다. 

이 세 가지 라인은 동일 어느 게으른 느낌이 참으로, 아마 올바른 방법이 아니다. 어떤 성분에 따라서 우리는이 코드를 향상시킬 수? 우리는 복사 및 붙여 넣기 코드가 없습니다. 

그리고, 참으로, 언제든지 당신이 기분 자신을 복사 및 붙여 넣기, 심지어, 코드를 변경하지 확률은 더 나은 방법이 있습니다. 그리고, 실제로 존재한다. 내가 가서 보자 루프를 수행 비록 구문은 그렇지 않을 수 있습니다 아직 자연적으로 온다. 

단지,이 세 번 수행 following--을 수행하여 나는 연습에서이 알고 일어난다. 그러나 우리는 지금 예제 수 있습니다. 그리고 당신은 온라인으로 볼 수 있습니다 아직도 참조. 

이 것을, 6 행의 구문입​​니다 반복 스크래치 등 많은 블록은 다음 세 번 반복한다. 그것은 지금 약간의 마법입니다. 그러나 이것은 더 얻을 것이다, 더 익숙한. 

그리고 반복 것 라인 팔을 세 번, 내가하면 화장 기침을 다시 컴파일되도록, 점은 기침, 기침, 기침, 기침을 슬래시. 여전히 동일한 방식으로 작동한다. 그래서 모든 벌금과 좋은입니다. 그러나 그것은 매우 추상화 아니다. 

그것은 완벽하게 맞습니다. 그러나이 같은 느낌 기회가 될 수있다, 의 세계로 시작의 종류 스크래치, 그래서 여기에 몇 가지 의미를 추가하는 방법 난 그냥 루프에 대한 몇 가지가 없습니다 그리고 함수는 말한다 기침을하거나 기침 않습니다. 당신 그거 알아? 날이 될 해보자 보다 작은 쿨러, 실제로 함수를 작성하는 약간의 부작용을 가지고, 이는 기침 부른다. 

그리고 그것은 어떤 입력을 받아없고, 출력으로 어떤 값도 반환하지 않는다. 그러나 당신은 무엇을 알아? 그것은,이 항아리의 printf 않습니다 인용을 끝내 인용, 기침. 

그리고 지금 여기까지 나는거야 앞서 및 인터넷 용 이동, 내가 플러스 플러스, 제로를 얻을 난 미만 3. 나는 인의 printf하지거야 틀림없이 낮은 수준의 구현 세부. 나는 기침을하는 방법에 대해 걱정하지 않는다. 난 그냥 기침 기능을 사용하고 싶습니다. 그리고 난 그냥 기침을 호출하는거야. 

이제 이분법을 알 수 있습니다. 그렇게하지 ​​않으면 당신은 함수를 호출 할 때 그것은 완전히 잘, 입력주고 싶다. 그냥 열린 괄호 닫고을 괄호,하면됩니다. 

당신은 함수를 정의 할 때, 또는 함수의 프로토 타입을 선언 당신이 미리 알고있는 경우는 아니다 인수를 취할 것, 거기에 그 괄호 안의 무효 말한다. 그리고 특정하게 당신이 실수로 오용되지 않습니다. 내가 가서 기침을 만들어 보자. 그리고 물론, 내가 실수를했습니다. 

젠 것을 거기 암시 적 선언. 하지만 괜찮아요. 그것은 쉽게 수정합니다. 난 그냥 프로토 타입 이상을 필요로 내 파일에 나는 실제로 그것을 사용하고보다. 

그래서 지금 나 기침 다시, 좋은합시다. 지금, 그것은 작동합니다. 기침, 기침, 기침, 기침을합니다. 그래서 우리가 정말 걸 생각 그냥이 문제를 엔지니어링. 그리고, 참으로, 우리는. 이것은 좋지 않다 프로그램의 후보 의 순간 리팩토링, 그리고 무슨 일을 계층 적 분해라고, 어디 몇 가지 코드를 가지고 다음 그래서 당신이 가지 요인 것들 아웃, 그들에게 더 많은 의미를 돌리다하고, 그리고 그것을 궁극적으로 장기를 다시 사용합니다. 그러나 향해 빌딩 블록의 더 정교한 프로그램 우리는 시작됩니다 머지 않아 그 작성 우리는 어휘를 가질 수 있습니다 있는 더 나은 코드를 작성합니다. 그리고, 참으로,의가 있는지 확인하자 우리 또한이 일반화 할 수 없습니다. 

그것은 약간의 색상을 보인다 I, 메인, 루프이 이놈에 대해 걱정할 필요, 그리고 또 다시 기침을 호출. 왜 난 그냥 기침을 말할 수 없다 세 번 기침하세요? 즉, 왜 나는 할 수 없습니다 단지 기침이 작업을 수행하는 입력을 제공? 

왜 그냥, 말할 수 없다 주요 기침을 세 번. 그리고 지금,이 종류의 마법이다. 그것은 여기에 매우 반복적이다. 그리고, 참으로, 아기 단계입니다. 

그러나 단지 능력에 대답 라인 팔, 세 번 기침, 그냥 훨씬 더 읽을 수 있습니다. 그리고, 플러스, 나도 할 필요가 없습니다 또는 기침이 구현되는 방법을 신경. 그리고, 참으로, 이후에 용어 및 최종 프로젝트, 당신은 프로젝트와 태클 경우 동급생 또는 두 개의 반 친구, 당신은 당신이 가고 있다는 것을 깨닫게됩니다 에, 또는, 작업을 분할 할 수 있습니다. 

그리고 당신은 결정하려는거야 사전에 누가 무엇을 할 것, 어느 조각? 그리고 그것은 좋은되지 않을 것 당신이 경우, 예를 들어, 쓰기의 주요 담당, 수행을. 그리고 당신의 룸메이트, 또는 파트너보다 일반적 기침을 구현 처리합니다. 

그리고이 부문이 추상화의 벽, 추상화 또는 레이어 경우 당신은, 매우 강력합니다 특히 큰위한 때문에 더 복잡한 프로그램 및 시스템, 그것은 여러 사람이 만들 수 있습니다 일 함께, 궁극적 이러한 방식으로 함께 작업을 만들기. 하지만, 물론, 우리 지금 기침을 수정해야합니다. 우리는 기침을 말할 필요 즉, 야, 그거 알아? 당신은 걸릴 필요 해요 input-- 무효로하지만, INT 지금은 없습니다. 이제 가서 넣어 보자 INT 기침. 나는 제로를 가져옵니다. 

내가 얼마나 많은 시간 미만이다. 나는 3을하기 전에 말했다. 하지만 내가 원하는 게 아니에요. 나는 일반화 될 기침을 원하는 반복의 임의의 수를 지원한다. 

그래서, 사실, 그것이 내가 원하는 n이있어, 어떤 사용자가 나에게 이야기한다. 지금, 나는 가서 인쇄 기침을 말할 수있다. 그리고 상관없이 번호 사용자는에 전달 나는 여러 번 반복합니다. 

하루의 끝에 그래서 프로그램은 동일합니다. 하지만이 물건의 모든 통지 심지어 다른 파일에있을 수 있습니다. 사실, 나는에 몰라 순간 방법의 printf 구현된다. 

나는 얼마나 순간에 알 수없는 문자열, 또는 INT를 얻을, 또는 플로트를 얻을 수 구현된다. 그리고 난 싶지 않아 내 화면을 참조하십시오. 그대로, 나는에 초점을 시작 해요 내 프로그램되지 않은 기능을한다. 

그리고, 참으로, 즉시로 이 같은 코드를 감안 시작 우리는 심지어 기침을 움직일 수 별도의 파일에? 다른 사람이 그것을 구현할 수 있습니다. 그리고 당신과 당신의 프로그램이 될 매우 아름답고, 매우 읽을 수있는, 틀림없이, 정말 네 바로 거기에 줄 프로그램. 

그럼 이제 앞서 가자 그리고 한 번 더 변경합니다. 주목 나의 프로토 타입 상단을 변경할 수 있습니다. 그래서 내가 그래서 문제를 해결하자 나는 고함되지 않습니다. 

기침을 확인, 내가 한 번 기침을 실행하자 더, 여전히 같은 일을하고. 하지만 지금, 우리는이 통지 하나의 최종 버전에 해당하는 성분. 당신 그거 알아? 나는 반드시, 단지 기침을하고 싶지 않다. 좀 더 일반적으로 무언가를 갖고 싶어. 그래서 당신은 무엇인지? 나는이 작업을 수행 할 수 있습니다. 나는 많은 스크래치처럼, 갖고 싶어 , 않는 말 블록 아니라 단지 무언가에게 시간의 어떤 수를 말한다. 나는 그것이 매우 특정 문자열을 말하고 싶습니다. 그리고, 그러므로, 난 몰라 그냥 기침을 말하고 싶습니다. 내가 말하고 싶은대로 문자열에 전달됩니다. 

그래서 알, 나는 일반화 한 이 때문에 지금 말은 좋은 이름 같은 느낌 이것에 대한, 스크래치 등, 스크래치는 달리, 2 개의 인수를 취하는. 하나는 문자열입니다. 하나는 int이며. 

그리고 나는 그들을 전환 할 수 있습니다. 나는 그냥 가지의 아이디어 등 첫 번째 문자열 말을 한 다음 얼마나 많은 나중에 시간. 보이드는 여전히 의미 아무것도 반환하지 않습니다. 이 단지 시각적 인 측면이다 [와 같은 효과? 요르단,?] 소리의 구두 부작용. 아직, 뭔가 n 배를 않습니다 최대 0하지만, n은 동일하지. 이는 N 개의 총 시간을 의미한다. 그리고 바로 인쇄 무엇이든 그 문자열입니다. 그래서 난 정말 일반화 한 이 코드 줄. 그래서 지금, 내가 어떻게 구현합니까 기침 기능? 

나는 무효 기침을 할 수 있습니다. 그리고 난 아직도 방법에 걸릴 수 있습니다 몇 번 기침을합니다. 하지만 당신은 알아? 지금은 말을 펀트 수 있습니다. 

나는 말할 호출 할 수 있습니다 워드 기침, n은 전달. 그리고 나는 또한 구현하려는 경우, 그냥 재미를 위해, 재채기 기능, 나는 시간의 어떤 수를 재채기를 할 수 있습니다. 그리고 나는 때문에, n은 재사용 유지할 수 있습니다 이러한 맥락 또는 범위에서 해당 m 통지 단지이 함수 내에서 존재한다. 

n은이 맥락에서 만 여기에이 함수 내에서 존재한다. 그래서 우리는 되돌아 올 것이다 범위의 이러한 문제. 그리고 여기, 난 그냥 말할거야 achoo 한 다음 n 번, 세미콜론. 

그리고 지금, 난 그냥 빌릴 필요 이러한 기능은 여기 시그니처. 그래서 기침이 올바른 것입니다. 공허 재채기 이제 올바른 것입니다. 

그리고 난 아직도 그냥 말을해야합니다. 그래서 나는 말, 말거야 문자열의, INT n을, 세미콜론. 그래서 과잉 설계 한 이 프로그램의 밖으로 지옥. 

그리고 이것은하지 않습니다 반드시이 의미 쓸 때 당신은 무엇을해야하는지 프로그램 중 가장 간단한. 그건 분명 뭔가를 타고 정말 짧은, 정말 간단, 그것을 다시 구현 너무 많은 코드를 사용하여. 그러나 실제로 확인하고있는 것입니다 시간은, 이들 실시 예에 되돌아 볼 및 실현, 오, 사람들은 단계는 우리는 실제로 일반화했다 뭔가를 고려하고, 하루의 끝에까지 내 코드는 실제로 꽤 합리적이다. 나는 세 가지 기침을 할 경우 때문에 다음 번, 세 번 재채기 나는 단순히이를 다시 실행거야 프로그램은 기침을하고, 기침을 실행합니다. 그리고 나는 3 기침이 세 재채기. 

그리고이 기본이다 패러다임, 만약에 당신, 우리가 갈 수있는 방법에 대한 실제로 프로그램을 구현. 하지만 그냥은 지금 무엇을 보자 우리는이 모든 시간을 해왔습니다 어떤 최종 작품의 일부 이 간단한 명령 뒤에 있습니다. 하루의 끝에서, 우리는했습니다 우리의 컴파일러로 연타를 사용하고. 우리는 소스를 작성했습니다 코드로 변환 기계 코드로 연타를 통해. 

그리고 우리는 단지 확인 사용했던 그래서 우리의 키 입력을 용이하게하기 우리는 기억 할 필요가 없습니다 연타 자체의 그 주술. 그러나 실제로 확인하고 무엇입니까? 그리고, 다시, 무엇이다 연타 실제로 일을? 

우리는 간단했다하지만 그것은 밝혀 말을하여 오늘의 토론, 당신은 소스 코드를 가지고로 전달 당신을 제공하는 컴파일러에 입력 기계의 출력 코드가의 밝혀 이 안에 몇 가지 단계. 그리고 컴파일은 우산 될 일이 단계의 모두에 대한 용어입니다. 하지만 그냥 애타게하자 이 밖으로 정말 빠르게. 

그것은 우리가 해왔 밝혀 더 많은 것들이 내가 프로그램을 실행할 때마다, 또는 때마다 나는 오늘 프로그램을 컴파일합니다. 그래서 전처리를 의미한다 C 프로그램에서 아무 것도이 항아리, 우리는 또 다시 살펴 보 겠지만, 즉,이 해시 기호로 시작 또는 여기에 해시 태그 기호, 의미 그것은 처리기 지시문입니다. 즉 이봐,이 경우, 의미 컴퓨터는이 파일에 뭔가를 당신은 실제로 내 자신의 코드를 컴파일하기 전에. 

이 경우, 해시가 포함 본질적으로, 말의 C의 방법, 헤이 컴퓨터, 내용을 가서 및 CS50.h의 여기에 붙여 넣습니다. 헤이 컴퓨터 인 가서 표준 IO.h의 내용, 그것은에 어디든지 하드 드라이브, 여기에 붙여 넣습니다. 그래서 그 일이 일어날 전처리 중 첫 번째. 

그리고 연타 우리를 위해이 모든 작업을 수행합니다. 그리고 그것은 그래서 이놈을 수행 빨리, 당신도하지 않습니다 일이 네 가지 일을 참조하십시오. 그러나 그것은 최초의 단계입니다. 

무엇 실제로 다음됩니까? 그럼, 다음 공식 단계는 컴파일됩니다. 그리고 그것은 밝혀 프로그램을 컴파일 기술적에서가는 의미 소스 코드, 우리가했습니다 물건 뭔가, 오늘 쓰고 뭔가, 어셈블리 코드라고 그건 좀 다르게 보입니다. 

그리고, 사실, 우리는 정말 빨리이를 볼 수 있습니다. 내가 실제로 내 IDE로 가자. 나 앞서 오픈에서는 hello.c 가자하는 맨 처음 프로그램 인과 우리 오늘 시작했다. 그리고 내가 가서 연타 a를 실행하자 다른 작은, 연타-S,에서는 hello.c, 실제로에있는을 것입니다 나에게 다른 파일 hello.s을 제공합니다. 

그리고 우리는 결코 아마 것 다시 코드의이 종류를 참조하십시오. 당신은 낮은 수준을 경우 CS61 같은 시스템 클래스, 당신은 더 많이 볼 수 있습니다 이 코드 종류의. 그러나 이것은 어셈블리 언어입니다. 이는 X86 어셈블리 언어 그 기본이되는 CPU CS50 IDE는 실제로 이해한다. 

그리고 그것은 비밀처럼 그것은 뭔가 봐 컴퓨터가 꽤 잘 이해하고 있습니다. 서브 Q, 이것은 빼기이다. 움직임이있다. 

여기 기능의이 부르고 X or 연산, 이동, 추가, 팝업, 반환. 그래서 거기에 아주 낮은 수준의 지침 CPU는 것을 이해 나는 이전에 언급. 즉, 어떤 인텔 인사이드입니다. 

패턴이 있습니다 0과 1이 이 arcanely 말로에 매핑하지만, 다소 잘 이름, 설명, 말하자면. 그 때 발생하는 것입니다 당신은 당신의 코드를 컴파일합니다. 당신은 조립 얻을 그것에서 언어, 어느 세 번째 단계는 조립을 의미 해당 어셈블리 코드로, 궁극적으로, 기계 code-- 0과 1이 아닌 우리가 잠시 전에 본 텍스트입니다. 

그래서 사전 처리는 찾지 않습니다 대체, 그리고 몇 가지 다른 것들과. 컴파일은 소스 소요 C 코드에서, 소스 코드 우리는 어셈블리에, 쓴 우리가 흘끗 코드입니다. 조립은 조립 소요 0과에 코드 는 CPU 정말 것이다 하루의 끝에 이해한다. 그리고 링크는 마지막 단계입니다 즉, 다시 us--에 대한 발생 너무 빨리 우리는 심지어하지 않습니다 즉 말한다 notice-- 헤이 컴퓨터의 모든을 0과 1이 다윗의 코드를 컴파일의 결과 이 경우 자신의 주요 기능. 

그리고 컴퓨터 야, 가서 0과 1의 모든 CS50 직원이 쓴 CS50 라이브러리 내부. 다윗과 그에 섞는다. 그리고 헤이 컴퓨터가 모두 0을 가서 그리고 다른 사람이 년을 쓴 사람 있음 전 printf의합니다. 그리고에 사람들을 추가 모든 것은, 우리가했습니다 있도록 내 0과 1을은있어 CS50 직원의 0과 1, printf가의 0과 1, 그리고 무엇 우리가 사용하고 있습니다. 

그들은 모두 하나에 정리하세요 프로그램 안녕하세요,이 경우했다. 그래서 이제부터는, 우리는 것입니다 단지 단어 컴파일을 사용합니다. 그리고 우리는 당연한 걸릴 때 우리는 그 의미, 당신의 프로그램을 컴파일, 말 헤이 전처리를 수행 조립 및 연결. 그러나 실제로 일부 육즙이 물건을 거기에 후드 아래가 진행. 그리고 특히 경우 호기심 시간을 얻을 당신은 파고 시작할 수 있습니다 주변이 낮은 수준에서. 하지만 지금은, 그 실현 오늘의 테이크 아웃 중 이다 아주 간단하게 프로세스의 시작, 편안한 점점 안녕하세요 세계 같은. 사실, 우리가 오늘 한 일의 대부분 확실히 슈퍼 빠른에 침몰되지 않습니다. 그리고 그것은 일부를 취할 것 시간 및 연습. 그리고 확률, 당신은 정렬합니다 의 키보드를 치고 싶어 또는 화면에서 소리. 그리고 그 모두 OK입니다. 하지만, 아마에하지 않으려 고 너무 많은 도서관에서 그것을 할. 

그리고 궁극적으로, 당신은거야 하지만 수 시작된다 좋은 코드 모두에서 패턴을보고 당신이 쓴 그 실수에 당신은했습니다있다. 그리고 과정 등 많은 TF되고 또는 CA 같은 것입니다, 당신이 더 얻을 시작합니다 및 그 패턴을보고 더 나은, 그냥 당신을 해결 궁극적으로 자신의 문제. 한편, 충분히있을 것입니다 우리의 당신이 지원을 빌려, 당신을 얻을 수 이를 통해. 그리고 쓰기 업에 모든 문제에 대한 당신은을 통해 안내됩니다 모든 명령 나는 확실히 알고 있음 지금 쯤 연습을 많이, 하지만 비행 수도 지금은 하나의 머리. 그리고 완전히 괜찮아요. 

그러나, 궁극적으로, 당신은거야 패턴이 등장보고 시작합니다. 그리고 당신은 모든 과거의 일단 바보 세부 사항, 괄호 등, 중괄호, 세미 콜론, 그리고 물건, 솔직히, 그건 전혀 아니다 지적 흥미 롭군요. 그리고 그것은의 목적 아니다 어떤 입문 수업을. 그것은 중요하고자하는 아이디어입니다. 

이것은 루프의 및 조건 및 기능 더 강력하게 추상화, 코드의 인수 분해, 그리고 좋은 디자인과 좋은 스타일 및 궁극적 정확성 코드의 그 궁극적이다 가장 중요한 것. 그래서 다음 주에, 우리는이 걸릴 것입니다 우리가 처음 스크래치에서 본 아이디어 지금 번역했습니다 C.에 그리고 우리는 시작합니다 의 첫 번째를 소개합니다 과정의 실제 도메인. 

우리는 보안의 세계에 초점을 맞출 것 더욱 구체적으로, 암호화 스크램블링 정보의 기술. 그리고 첫 번째 중 문제가 당신에게 자신을 이후 작성하는 얻을 것이다 구문의 일부와 함께 연주 어떤 논리를 해결 문제, 궁극적으로 머지 않아, 실제로 스크램블링 또는 암호화하는 것입니다, 궁극적 정보를 해독. 그리고 모든 것을 우리가했던 오늘 것이다 상당히 낮은 레벨, 그냥 허용하는 것입니다 우리는 하나, 그리고 하나를 수행합니다 위를 향해 한 단계 그러나 가장 흥미로운 코드를 작성. 

그 다음 주에 그래서 더. 

[VIDEO 재생] 

- 왜 당신에 대해 말해 줄 수 당신이 그를 마지막으로 본 게 언제? - 무슨 난 정말 말할 수 있습니까? 내 말은, 그것은 다른 것 같았다 사전 제작 리허설 뭔가가 있었다를 제외하고 그는 말했다 나와 함께 붙어 매우 끝. 

-이는 CS50했다. 

- 그건, 절단 모든 사람의 리허설에 훌륭한 일. 

- 그건의 점심? 

그래, 당신과 나는 할 수 약간의 샌드위치를​​ 잡아. 내가 단지로 브리핑하자 데이비드 정말 빨리. 데이비드? 데이비드? 

[END 재생] 