1
00:00:00,000 --> 00:00:00,500

2
00:00:00,500 --> 00:00:02,490
[音樂]

3
00:00:02,490 --> 00:00:16,950

4
00:00:16,950 --> 00:00:19,240
>> DAVID J. MALAN：好吧，這是CS50。

5
00:00:19,240 --> 00:00:21,010
而這是一個星期。

6
00:00:21,010 --> 00:00:25,050
所以，記得最後一次是在零一周，
我們專注於計算思維。

7
00:00:25,050 --> 00:00:28,440
而我們從轉變，要
從無到有，圖形化編程

8
00:00:28,440 --> 00:00:30,360
從我們的朋友的語言
在麻省理工學院的媒體實驗室。

9
00:00:30,360 --> 00:00:34,730
>> 並與划痕，沒有我們探討
想法一樣的功能，和條件，

10
00:00:34,730 --> 00:00:38,210
和循環，和變量，甚至
事件，以及線程，以及更多。

11
00:00:38,210 --> 00:00:40,880
而今天，我們要
繼續使用這些想法，

12
00:00:40,880 --> 00:00:43,630
真正帶他們
理所當然，但他們翻譯

13
00:00:43,630 --> 00:00:47,220
被稱為現在C.另一種語言，
C是一個更傳統的語言。

14
00:00:47,220 --> 00:00:49,020
這是一個較低的水平
語言，如果你願意。

15
00:00:49,020 --> 00:00:50,300
>> 這純粹是文字。

16
00:00:50,300 --> 00:00:52,910
所以乍看之下，它的
一切都將看起來相當神秘

17
00:00:52,910 --> 00:00:54,430
如果你從來沒有編程。

18
00:00:54,430 --> 00:00:56,530
我們將有
分號和括號，

19
00:00:56,530 --> 00:00:58,150
和大括號，等等。

20
00:00:58,150 --> 00:01:00,240
但是認識到，即使
雖然語法

21
00:01:00,240 --> 00:01:03,600
即將看起來有點陌生
大多數的你，看過去那種。

22
00:01:03,600 --> 00:01:06,220
並嘗試看看的想法
這的確都是熟悉的，

23
00:01:06,220 --> 00:01:09,750
因為在這裡每週有什麼
我們將開始做的是比較，

24
00:01:09,750 --> 00:01:11,980
最初，耐刮與C.

25
00:01:11,980 --> 00:01:15,350
>> 所以，舉例來說，回想一下，當我們
實現了第一個我們的節目

26
00:01:15,350 --> 00:01:19,220
最後一次，我們有看起來塊
有點像this--時

27
00:01:19,220 --> 00:01:22,990
綠旗點擊，然後我們有
一個或多個拼圖在它下面，

28
00:01:22,990 --> 00:01:25,150
在這種情況下，就是說，世界你好。

29
00:01:25,150 --> 00:01:27,870
因此，事實上，在划痕，
當我點擊了綠色環保標誌

30
00:01:27,870 --> 00:01:30,390
運行我的程序，所以
可以說，這些都是

31
00:01:30,390 --> 00:01:32,520
得到執行的塊，或運行。

32
00:01:32,520 --> 00:01:35,230
和，特別是，臨時
說，你好，世界。

33
00:01:35,230 --> 00:01:38,377
>> 現在，我可以指定
這裡不同的話。

34
00:01:38,377 --> 00:01:40,960
但是我們會發現，事實上，許多
這些blocks--確實的，

35
00:01:40,960 --> 00:01:44,880
用C許多functions--可
參數化或定制

36
00:01:44,880 --> 00:01:46,150
做不同的事情。

37
00:01:46,150 --> 00:01:48,520
事實上，在C，如果我們
要轉換，現在，

38
00:01:48,520 --> 00:01:50,567
這耐刮劃
這個其他語言，

39
00:01:50,567 --> 00:01:52,650
我們將寫一
小這樣的事情。

40
00:01:52,650 --> 00:01:55,540
>> 當然，有一些陌生
語法有最有可能，INT，

41
00:01:55,540 --> 00:01:57,380
和括號，和無效的。

42
00:01:57,380 --> 00:02:00,740
但是，儘管你甚至會printf--
認為這將只是打印。

43
00:02:00,740 --> 00:02:03,120
但是打印表示打印
格式化，因為我們很快就會看到。

44
00:02:03,120 --> 00:02:05,140
這從字面上將打印
到屏幕上的任何

45
00:02:05,140 --> 00:02:08,990
是那些括號內，這
當然，在這種情況下，世界你好。

46
00:02:08,990 --> 00:02:12,290
>> 但你會發現一些其他的
語法，一些雙引號，

47
00:02:12,290 --> 00:02:14,890
，在結束括號，
分號等。

48
00:02:14,890 --> 00:02:18,027
因此，有一點開銷，
可以這麼說，無論是認知

49
00:02:18,027 --> 00:02:20,860
和語法，我們要去
有不久記住。

50
00:02:20,860 --> 00:02:23,720
但要意識到聯繫實際，
這將開始在你跳出來。

51
00:02:23,720 --> 00:02:27,920
>> 事實上，讓我們專注於一個
功能specifically--在這種情況下，

52
00:02:27,920 --> 00:02:29,290
打招呼的世界。

53
00:02:29,290 --> 00:02:30,560
所以說是功能。

54
00:02:30,560 --> 00:02:34,320
你好世界是它的參數，
或參數，它的定制。

55
00:02:34,320 --> 00:02:37,320
>> 而在C中的等價只是
要在這裡成為這一行，

56
00:02:37,320 --> 00:02:41,710
在這裡的printf相當於，說，
雙引號字符串，你好

57
00:02:41,710 --> 00:02:44,470
世界是等效的，當然，
什麼是在白框那裡。

58
00:02:44,470 --> 00:02:48,680
和反斜線N，雖然有點
奇怪的並從頭缺席，

59
00:02:48,680 --> 00:02:52,380
簡單地說就是將有我們的影響
看到一台電腦，像我的Mac或PC，

60
00:02:52,380 --> 00:02:54,660
只是移動
光標移到下一行。

61
00:02:54,660 --> 00:02:56,970
這就像打
鍵盤上的Enter。

62
00:02:56,970 --> 00:02:58,580
>> 因此，我們將不久再次看到這一點。

63
00:02:58,580 --> 00:03:01,640
但首先，讓我們來看看這個
在循環的情況下，其他的例子。

64
00:03:01,640 --> 00:03:05,830
我們有這樣永遠循環最後一次，
這是一系列的拼圖

65
00:03:05,830 --> 00:03:08,490
那做了字面上
forever--在這種情況下，

66
00:03:08,490 --> 00:03:11,360
說，你好世界，你好世界，
世界你好，你好世界。

67
00:03:11,360 --> 00:03:13,350
所以這是設計一個無限循環。

68
00:03:13,350 --> 00:03:17,580
>> 在C中，如果我們想實現這個
同樣的想法，我們可以簡單地做到這一點。

69
00:03:17,580 --> 00:03:22,570
雖然如此，printf的招呼現在天下 - 
同時，剛剛語義，那種

70
00:03:22,570 --> 00:03:26,090
聯想到做的念頭
重複的事情，又一次，又一次，

71
00:03:26,090 --> 00:03:26,980
多長時間？

72
00:03:26,980 --> 00:03:30,990
那麼，true--回憶一下，
真正是剛上或1。

73
00:03:30,990 --> 00:03:33,660
>> 而真正的，當然，總是如此。

74
00:03:33,660 --> 00:03:36,060
所以這是一種毫無意義的
聲明只是說真的。

75
00:03:36,060 --> 00:03:39,890
但事實上，這是故意的，
因為如果真的僅僅是總是正確的，

76
00:03:39,890 --> 00:03:43,850
而不是真正的就是意味著，
如果有點間接的，

77
00:03:43,850 --> 00:03:47,070
那下面的代碼行
在這些大括號

78
00:03:47,070 --> 00:03:51,320
應該只是又一次，又一次執行，
又一次，從來沒有真正停止。

79
00:03:51,320 --> 00:03:53,230
>> 但是，如果你希望你的
循環停止，因為我們

80
00:03:53,230 --> 00:03:57,500
跟上次喜歡的東西
這種重複以下50次，

81
00:03:57,500 --> 00:04:00,700
用C我們可以做什麼是相同的
被稱為為loop--關鍵字

82
00:04:00,700 --> 00:04:02,330
不是一陣子，而是。

83
00:04:02,330 --> 00:04:06,290
然後，我們有一些新的語法在這裡，
使用int i等於0，我不到50，

84
00:04:06,290 --> 00:04:06,880
我++。

85
00:04:06,880 --> 00:04:08,430
我們會回來這一點。

86
00:04:08,430 --> 00:04:12,660
但是，這僅僅是我們如何會
翻譯組划痕塊

87
00:04:12,660 --> 00:04:16,079
一組的碼C的行。

88
00:04:16,079 --> 00:04:17,450
>> 同時，考慮的變量。

89
00:04:17,450 --> 00:04:19,540
而且，事實上，我們只是
看見一個人剛才。

90
00:04:19,540 --> 00:04:24,220
並且在暫存的情況下，如果我們
要聲明一個叫做變量i

91
00:04:24,220 --> 00:04:27,590
因為我是整數，只是一個數字，
我們希望將它設置為某個值，

92
00:04:27,590 --> 00:04:31,410
我們將使用這個橙色
阻斷這裡 - 我設置為0。

93
00:04:31,410 --> 00:04:33,800
>> 而我們今天將看到和
超越，就像上週，

94
00:04:33,800 --> 00:04:36,850
程序員做幾乎總是
從零開始計數，真

95
00:04:36,850 --> 00:04:37,950
按照慣例。

96
00:04:37,950 --> 00:04:40,250
但也因為召回
我們的二元討論，

97
00:04:40,250 --> 00:04:42,990
最小的號碼，你可以
用任何數目的位表示

98
00:04:42,990 --> 00:04:44,640
只是將是0本身。

99
00:04:44,640 --> 00:04:48,190
所以，我們通常會開始
即使初始化我們的變量為0。

100
00:04:48,190 --> 00:04:50,710
>> 而在C ++做的一樣，
我們會說INT

101
00:04:50,710 --> 00:04:53,110
為整數，我只是按照慣例。

102
00:04:53,110 --> 00:04:56,390
我可以叫這個變量
任何我想要的，就像在刮。

103
00:04:56,390 --> 00:05:00,770
然後等於0只是受讓人
從右側的值0

104
00:05:00,770 --> 00:05:04,319
並將其放入變量，或
儲存容器有，在左側。

105
00:05:04,319 --> 00:05:07,360
和分號，我們會see--和
我們已經看到了一些這些already--的

106
00:05:07,360 --> 00:05:09,530
只是意味著思想的終結。

107
00:05:09,530 --> 00:05:12,430
繼續做別的事情
在接下來的線。

108
00:05:12,430 --> 00:05:14,330
>> 現在，關於布爾表達式？

109
00:05:14,330 --> 00:05:17,320
回想一下，在刮，
這些人表情

110
00:05:17,320 --> 00:05:19,740
那些是真
或false--問題，

111
00:05:19,740 --> 00:05:21,910
真的，要么是真還是假。

112
00:05:21,910 --> 00:05:24,960
因此，在划痕的情況下，我們可能
問一個簡單的問題，這樣，

113
00:05:24,960 --> 00:05:27,586
為i小於50？

114
00:05:27,586 --> 00:05:28,710
所以我，再次是整數。

115
00:05:28,710 --> 00:05:30,210
也許我們正在使用它
在臨時計劃

116
00:05:30,210 --> 00:05:32,310
保持比分的軌道
或類似的東西。

117
00:05:32,310 --> 00:05:36,810
所以這個語法在這裡划痕
只是手段，是我不到50？

118
00:05:36,810 --> 00:05:40,330
好了，幸運的是，事情是
簡單的C。和翻譯，

119
00:05:40,330 --> 00:05:44,780
這一點，我們就簡單的說我少
50，使用熟悉的關鍵

120
00:05:44,780 --> 00:05:45,850
鍵盤上。

121
00:05:45,850 --> 00:05:48,141
>> 同時，如果你想
說一些比較一般，

122
00:05:48,141 --> 00:05:52,890
像，很好，比y這裡每個x少
x和y的本身變量？

123
00:05:52,890 --> 00:05:55,280
我們可以做同樣的事情
在C，只要我們已經

124
00:05:55,280 --> 00:05:56,942
創建這些變量了。

125
00:05:56,942 --> 00:05:58,650
我們將看到如何
這樣做不久。

126
00:05:58,650 --> 00:06:01,590
我們就簡單的說比Y X更少。

127
00:06:01,590 --> 00:06:03,530
>> 所以，你開始
看到一些相似之處。

128
00:06:03,530 --> 00:06:06,490
和誰做那些人
從無到有是肯定

129
00:06:06,490 --> 00:06:08,250
通過其中的一些基本思想的啟發。

130
00:06:08,250 --> 00:06:13,350
你會看到這樣的
語法在很多languages​​--

131
00:06:13,350 --> 00:06:15,160
不只是劃傷，
只是C，但是Python，

132
00:06:15,160 --> 00:06:17,790
和JavaScript，以及
其他語言依舊。

133
00:06:17,790 --> 00:06:21,270
>> 讓我們考慮另一種結構
從C，條件的概念，

134
00:06:21,270 --> 00:06:23,370
做一些有條件。

135
00:06:23,370 --> 00:06:25,720
如果事情是真的，做到這一點。

136
00:06:25,720 --> 00:06:27,457
如果別的東西是真實的，做到這一點。

137
00:06:27,457 --> 00:06:30,040
這有點編程的
在一個岔路口的等價物。

138
00:06:30,040 --> 00:06:32,730
也許這是一個叉雙向的，
三通叉，或更多。

139
00:06:32,730 --> 00:06:35,800
而在划痕，我們可能有
看到這樣的事情。

140
00:06:35,800 --> 00:06:37,010
>> 所以這一塊是一個大的。

141
00:06:37,010 --> 00:06:39,750
但考慮到相對
邏輯簡單性。

142
00:06:39,750 --> 00:06:47,010
如果x小於y，然後說x是少
比Y，否則如果x大於y，

143
00:06:47,010 --> 00:06:49,230
然後說x是大於y。

144
00:06:49,230 --> 00:06:51,300
然後，在邏輯上，如果，
回想一下划痕

145
00:06:51,300 --> 00:06:55,610
或者只是你自己的人的直覺，
好吧，如果x不大於y，並且x

146
00:06:55,610 --> 00:07:00,000
不除Y更小，則當然
x被將是等於y。

147
00:07:00,000 --> 00:07:02,690
因此，在這種情況下，通過嵌套
這些划痕塊，

148
00:07:02,690 --> 00:07:05,580
我們可以實現一個三
在行進的方式叉？

149
00:07:05,580 --> 00:07:07,980
>> 同時，如果我們想
這樣做，在C，它可以說是

150
00:07:07,980 --> 00:07:11,420
看起來至少有一點simpler--
一旦你熟悉的語法。

151
00:07:11,420 --> 00:07:15,050
如果x小於y，
printf的x是小於y。

152
00:07:15,050 --> 00:07:19,140
否則如果x大於y，
printf的x是大於y。

153
00:07:19,140 --> 00:07:24,210
其他的printf x等於y--和，
再次，與那些反斜杠只

154
00:07:24,210 --> 00:07:27,160
對於這些新的生產線，這樣，如果你
居然跑這種方案

155
00:07:27,160 --> 00:07:28,940
它只是移動
光標最終

156
00:07:28,940 --> 00:07:31,100
到屏幕的下一行。

157
00:07:31,100 --> 00:07:34,270
>> 現在，同時有划痕等
更複雜的功能，只

158
00:07:34,270 --> 00:07:37,320
其中有些我們要
最初移動到C的世界

159
00:07:37,320 --> 00:07:40,010
其中之一是
稱為划痕列表。

160
00:07:40,010 --> 00:07:42,100
這是一個特殊的
變量的類型

161
00:07:42,100 --> 00:07:45,840
允許你存儲多個事
在回來，背，背，背。

162
00:07:45,840 --> 00:07:48,540
>> 在C中，它不具有
名單，本身的事，但

163
00:07:48,540 --> 00:07:51,090
是更一般
所謂的陣列，雖然我們

164
00:07:51,090 --> 00:07:53,590
回來以後這個學期
要尋找的東西

165
00:07:53,590 --> 00:07:55,780
所謂的名單，還是真的鍊錶。

166
00:07:55,780 --> 00:07:58,510
但現在，最接近
相當於C語言為我們

167
00:07:58,510 --> 00:08:00,345
會是什麼
稱為陣列。

168
00:08:00,345 --> 00:08:02,740
和陣列是一個簡單的
特殊類型的可變的

169
00:08:02,740 --> 00:08:06,160
這允許你存儲數據
背，背，背，背到。

170
00:08:06,160 --> 00:08:08,840
>> 而且，事實上，在划痕，
如果我們想訪問

171
00:08:08,840 --> 00:08:12,030
數組的第一元素或
一個列表中 - 我要去稱呼它，

172
00:08:12,030 --> 00:08:16,600
按照慣例，argv的，說法
矢量，但不久還有更多。

173
00:08:16,600 --> 00:08:20,090
如果我想要得到的第一個元素
ARGV的，在刮的世界

174
00:08:20,090 --> 00:08:23,930
你實際上做一般
從1開始計數。

175
00:08:23,930 --> 00:08:25,850
>> 所以，我可能會得到argv的第1項。

176
00:08:25,850 --> 00:08:29,310
這是麻省理工學院的只是如何實現的
列表的概念。

177
00:08:29,310 --> 00:08:32,860
但在C，我要去
更簡單地只是說，ARGV，

178
00:08:32,860 --> 00:08:35,758
這又是對我的名字
列表中 - 或者是明確的，一個數組。

179
00:08:35,758 --> 00:08:37,549
如果我想第一
元素，我要去

180
00:08:37,549 --> 00:08:40,890
用方括號，你
可能不會經常鍵盤下使用。

181
00:08:40,890 --> 00:08:43,150
>> 但是，0只是意味著，拿到我的第一。

182
00:08:43,150 --> 00:08:45,160
等等場合和
久而久之，我們要去

183
00:08:45,160 --> 00:08:47,570
開始看到這些二分法
划痕和C之間，

184
00:08:47,570 --> 00:08:49,070
即刮使用一個。

185
00:08:49,070 --> 00:08:50,670
我們用C在這裡使用0。

186
00:08:50,670 --> 00:08:52,420
但你會很快看到
一旦你理解

187
00:08:52,420 --> 00:08:55,920
每種語言的基礎，即
這些事情開始變得更加

188
00:08:55,920 --> 00:08:59,860
熟悉通過實踐和實踐。

189
00:08:59,860 --> 00:09:02,700
>> 因此，讓我們實際上是在一個程序現在看起來。

190
00:09:02,700 --> 00:09:07,031
這裡應是第一個我們的C
完整程序的源代碼。

191
00:09:07,031 --> 00:09:09,280
而該計劃，我們要去
提供審議

192
00:09:09,280 --> 00:09:12,340
就是這相當於一個
那個早期的刮片。

193
00:09:12,340 --> 00:09:16,210
>> 所以在這裡，我們有什麼
可以說是最簡單的C程序

194
00:09:16,210 --> 00:09:18,410
你可以寫
實際上做什麼。

195
00:09:18,410 --> 00:09:21,250
現在，我們來看看過去，
現在，已經包括，

196
00:09:21,250 --> 00:09:24,190
標準io.h，而這些角度
括號和int和無效的，

197
00:09:24,190 --> 00:09:25,840
及大括號，和類似物。

198
00:09:25,840 --> 00:09:28,390
>> 而我們只專注於
什麼，至少直覺，

199
00:09:28,390 --> 00:09:29,860
可能會對你已經跳出。

200
00:09:29,860 --> 00:09:33,300
事實上，主要的，我不知道
一定知道這是什麼，

201
00:09:33,300 --> 00:09:37,580
但就像刮了，當
綠旗點擊拼圖，

202
00:09:37,580 --> 00:09:42,070
這樣做C作為編程語言
有一個主一段代碼，

203
00:09:42,070 --> 00:09:46,380
被默認執行。而且，事實上，
它字面上將被稱為主。

204
00:09:46,380 --> 00:09:47,720
>> 所以主要是一個函數。

205
00:09:47,720 --> 00:09:51,720
而且它是一個真實存在的特殊功能
用C，當你運行一個程序，

206
00:09:51,720 --> 00:09:55,720
它是由被主運行
默認。在划痕的世界裡，

207
00:09:55,720 --> 00:09:59,970
它通常是，當綠旗
點擊的得到了默認情況下運行。

208
00:09:59,970 --> 00:10:04,130
>> 同時，我們已經見過這個，
printf的或打印的格式，這是

209
00:10:04,130 --> 00:10:08,620
也會有一些自帶的功能
C，伴隨著一大堆別人的，

210
00:10:08,620 --> 00:10:13,140
從時間和時間的意願
再次，為了準確地做

211
00:10:13,140 --> 00:10:15,450
正如它的名字所暗示的，打印的東西。

212
00:10:15,450 --> 00:10:16,500
我們究竟要打印？

213
00:10:16,500 --> 00:10:18,770
好吧，我們會看到，
由封閉字符

214
00:10:18,770 --> 00:10:21,680
像these--世界你好，
反斜杠n的雙引號，

215
00:10:21,680 --> 00:10:26,040
我們可以告訴準確的printf
什麼要打印在屏幕上。

216
00:10:26,040 --> 00:10:29,430
>> 但為了做
這一點，我們很遺憾

217
00:10:29,430 --> 00:10:33,010
需要採取的東西是
已經隱晦了我們人類，

218
00:10:33,010 --> 00:10:37,510
但至少它有點readable--
犀利包括標準io.h，INT，

219
00:10:37,510 --> 00:10:42,340
主要的，無效的printf，所有的神奇
咒語剛才我們看到在屏幕上。

220
00:10:42,340 --> 00:10:45,470
但是實際上我們要
走得更神秘依舊。

221
00:10:45,470 --> 00:10:50,140
我們首先需要翻譯的代碼
我們編寫成機器代碼。

222
00:10:50,140 --> 00:10:54,370
而從上週回顧機，
至少那些我們知道這裡，

223
00:10:54,370 --> 00:10:57,450
在一天結束的時候只
了解零和一。

224
00:10:57,450 --> 00:11:01,100
>> 我的上帝，如果我們寫這些
零和的實際計劃，

225
00:11:01,100 --> 00:11:04,260
它會非常快
採取樂趣的事情。

226
00:11:04,260 --> 00:11:08,150
但事實證明，每上週，
該零和一的這些模式

227
00:11:08,150 --> 00:11:09,400
只是有特殊的意義。

228
00:11:09,400 --> 00:11:11,500
在某些情況下，
他們可能意味著數。

229
00:11:11,500 --> 00:11:14,840
>> 在某些情況下，它們可能意味著
字母或顏色，或任何數目的

230
00:11:14,840 --> 00:11:17,710
其他抽象存在於。

231
00:11:17,710 --> 00:11:21,450
但是，就像你的電腦有
一個CPU，中央處理單元，

232
00:11:21,450 --> 00:11:23,390
或您的計算機內的大腦。

233
00:11:23,390 --> 00:11:25,240
它通常是英特爾
在裡面，因為這是

234
00:11:25,240 --> 00:11:27,900
最大的公司之一
這使得CPU的電腦。

235
00:11:27,900 --> 00:11:31,910
>> 那麼，英特爾的CPU及其他
只需提前決定

236
00:11:31,910 --> 00:11:36,970
該零點的某些模式和
那些指具體的事情。

237
00:11:36,970 --> 00:11:40,040
零和一的某種模式
將意味著，打印此屏幕，

238
00:11:40,040 --> 00:11:42,710
或加這兩個數字，或
減去這兩個數字，

239
00:11:42,710 --> 00:11:46,310
或將這塊數據從
我的電腦的記憶在這裡，

240
00:11:46,310 --> 00:11:50,870
或任何數量的其他非常低的水平，
但最終有用的，運營。

241
00:11:50,870 --> 00:11:56,022
不過，值得慶幸的是，我們人類都不會
需要知道這些細節。

242
00:11:56,022 --> 00:11:59,230
事實上，和上次一樣，我們在那裡
又一次，又一次，又一次抽象，

243
00:11:59,230 --> 00:12:01,930
從很低水平建設
基元像零和一

244
00:12:01,930 --> 00:12:04,160
更高層次的概念
像數字和字母，

245
00:12:04,160 --> 00:12:07,330
和顏色，以及多，
所以我們可以為程序員

246
00:12:07,330 --> 00:12:10,080
站在肩上
別人在我們面前誰也來了

247
00:12:10,080 --> 00:12:14,260
和使用的軟件，其他
人前us--采寫

248
00:12:14,260 --> 00:12:17,340
即所謂的程序編譯器。

249
00:12:17,340 --> 00:12:20,770
>> C是一種語言，
通常編譯，

250
00:12:20,770 --> 00:12:25,130
這意味著從轉換
源代碼的機器代碼。

251
00:12:25,130 --> 00:12:28,230
特別是，這意味著什麼
是，如果你有你的源代碼

252
00:12:28,230 --> 00:12:32,530
代碼，您自己寫，因為我們很快
將在剛剛在屏幕上的時刻，

253
00:12:32,530 --> 00:12:36,140
並且希望將其轉換
最終以機器代碼 - 

254
00:12:36,140 --> 00:12:40,100
這些零和那些
只有你的Mac或PC機

255
00:12:40,100 --> 00:12:44,230
understands--你已經有了一個第一
養活源代碼作為

256
00:12:44,230 --> 00:12:49,340
輸入到一個特
程序調用一個編譯器，

257
00:12:49,340 --> 00:12:51,974
輸出其中我們
應當看到的是機器代碼。

258
00:12:51,974 --> 00:12:54,890
而且，事實上，上次我們聊
一下，果然，在一天結束的時候，

259
00:12:54,890 --> 00:12:55,610
解決問題。

260
00:12:55,610 --> 00:12:56,360
你有投入。

261
00:12:56,360 --> 00:12:57,318
和你有輸出。

262
00:12:57,318 --> 00:12:59,560
和你有某種
在中間算法。

263
00:12:59,560 --> 00:13:02,830
>> 算法可以肯定是
在軟件中實現，

264
00:13:02,830 --> 00:13:05,900
正如我們所看到上週偽
當我們將與實際的代碼看

265
00:13:05,900 --> 00:13:06,490
本星期。

266
00:13:06,490 --> 00:13:09,430
所以編譯器真的只是
有一組算法內

267
00:13:09,430 --> 00:13:13,060
它知道如何
轉換成特殊的關鍵字，

268
00:13:13,060 --> 00:13:15,180
像主，和printf，
和其他人，我們只是

269
00:13:15,180 --> 00:13:20,620
只見到零的模式和
那些Intel Inside和其他CPU

270
00:13:20,620 --> 00:13:23,020
其實理解。

271
00:13:23,020 --> 00:13:25,460
那麼，如何才能做到這一點？

272
00:13:25,460 --> 00:13:27,470
我們在哪裡可以得到一個編譯器？

273
00:13:27,470 --> 00:13:29,400
>> 我們中的大多數在這裡有一台Mac或PC。

274
00:13:29,400 --> 00:13:32,152
而你運行Mac OS，或
Windows或Linux或Solaris，

275
00:13:32,152 --> 00:13:33,860
或任何數量的其他
操作系統。

276
00:13:33,860 --> 00:13:35,568
而且，事實上，我們可以
走出去到網上

277
00:13:35,568 --> 00:13:38,710
並下載一個編譯器
為您的Mac或PC機

278
00:13:38,710 --> 00:13:40,360
為您的特定的操作系統。

279
00:13:40,360 --> 00:13:42,617
但是，我們都將是上
不同的頁面，可以這麼說。

280
00:13:42,617 --> 00:13:44,450
我們會略有
不同的配置。

281
00:13:44,450 --> 00:13:46,210
而事情是行不通的都是一樣的。

282
00:13:46,210 --> 00:13:48,280
而且，事實上，這些天
我們很多人不使用

283
00:13:48,280 --> 00:13:50,516
僅運行在我們的筆記本電腦的軟件。

284
00:13:50,516 --> 00:13:52,390
相反，我們使用的東西
像的瀏覽器

285
00:13:52,390 --> 00:13:55,930
允許我們訪問基於Web的
在雲應用。

286
00:13:55,930 --> 00:13:58,630
後來這個學期，
我們將這樣做。

287
00:13:58,630 --> 00:14:02,660
我們將編寫應用程序或
使用代碼 - 軟件不是C，

288
00:14:02,660 --> 00:14:05,860
但其他語言如Python和
JavaScript--在雲中運行。

289
00:14:05,860 --> 00:14:08,860
>> 要做到這一點，我們自己
在本學期

290
00:14:08,860 --> 00:14:14,890
將實際使用基於雲計算的
環境被稱為CS50 IDE。

291
00:14:14,890 --> 00:14:19,030
這是一個基於網絡的編程
環境，或集成開發

292
00:14:19,030 --> 00:14:23,610
環境，IDE，它內建一些之上
所謂雲9開源軟件。

293
00:14:23,610 --> 00:14:25,966
我們已經取得了一定的教學
簡化到它

294
00:14:25,966 --> 00:14:28,840
從而隱藏某些功能
我們並不需要在第一週，

295
00:14:28,840 --> 00:14:30,770
之後就可以
揭示他們做最

296
00:14:30,770 --> 00:14:32,400
任何你想要的環境。

297
00:14:32,400 --> 00:14:35,470
>> 它讓我們也一樣，要
預安裝某些軟件。

298
00:14:35,470 --> 00:14:38,330
比如像所謂的CS50
圖書館，我們很快就會看到

299
00:14:38,330 --> 00:14:42,210
為我們提供了用C與一些
附加功能。

300
00:14:42,210 --> 00:14:47,392
所以，如果你去，最終CS50.io，
你會被提示登錄，

301
00:14:47,392 --> 00:14:49,350
一旦你這樣做，並創建
一個是免費的賬號，

302
00:14:49,350 --> 00:14:55,150
你將能夠訪問
環境看起來很喜歡這一點。

303
00:14:55,150 --> 00:14:56,760
>> 現在，這是默認模式。

304
00:14:56,760 --> 00:14:58,650
一切都是好的，
明亮的屏幕上。

305
00:14:58,650 --> 00:15:00,941
我們很多人都習慣
工作CS50一塊是

306
00:15:00,941 --> 00:15:02,150
挺到深夜。

307
00:15:02,150 --> 00:15:05,400
所以，有些人可能更喜歡
把它變成夜間模式，可以這麼說。

308
00:15:05,400 --> 00:15:08,550
>> 但是，最終，你在做什麼
要CS50 IDE中看到

309
00:15:08,550 --> 00:15:11,340
是三個不同的areas--
在離開的地方面積

310
00:15:11,340 --> 00:15:15,604
您的文件將要在
雲，在右上方的區域

311
00:15:15,604 --> 00:15:17,270
在您的代碼將是編輯。

312
00:15:17,270 --> 00:15:19,650
您可以打開
對於任何程序各個選項卡

313
00:15:19,650 --> 00:15:22,670
你寫的裡面這學期
最重要的是右上角。

314
00:15:22,670 --> 00:15:26,070
然後最arcanely，
然而有力，

315
00:15:26,070 --> 00:15:29,610
將是這個東西在
底部被稱為一個終端窗口。

316
00:15:29,610 --> 00:15:32,450
>> 這是一個老同學
命令行界面，

317
00:15:32,450 --> 00:15:35,240
或CLI，允許
你執行命令

318
00:15:35,240 --> 00:15:38,260
在這種情況下，computer--，
在cloud--電腦

319
00:15:38,260 --> 00:15:42,090
做事喜歡編譯代碼
從源代碼到機器碼，

320
00:15:42,090 --> 00:15:46,600
運行您的程序，或者啟動
Web服務器或訪問數據庫，

321
00:15:46,600 --> 00:15:50,454
和任意數量的其他技術
我們將開始不久使用。

322
00:15:50,454 --> 00:15:52,370
但到那裡，我們
去居然有

323
00:15:52,370 --> 00:15:54,240
到網上去，並開始播放。

324
00:15:54,240 --> 00:15:57,399
要做到這一點，讓我們先
開始擺弄為主，

325
00:15:57,399 --> 00:15:58,940
寫一個程序的主要部分。

326
00:15:58,940 --> 00:16:02,170
讓我們使用這個函數
printf的，這是我們前面使用，

327
00:16:02,170 --> 00:16:04,050
簡單地說幾句。

328
00:16:04,050 --> 00:16:07,910
>> 所以我在這裡已經CS50 IDE裡面。

329
00:16:07,910 --> 00:16:08,930
我登錄的進步。

330
00:16:08,930 --> 00:16:10,360
我完全屏蔽的窗口。

331
00:16:10,360 --> 00:16:12,670
所以，最終，你
過在未來的問題

332
00:16:12,670 --> 00:16:15,960
將遵循類似步驟
將提供在線文檔。

333
00:16:15,960 --> 00:16:19,360
所以你不必擔心
每吸收一點技術一步

334
00:16:19,360 --> 00:16:20,730
我今天在這裡做。

335
00:16:20,730 --> 00:16:22,222
>> 但你會得到這樣的畫面。

336
00:16:22,222 --> 00:16:23,430
我碰巧在夜間模式。

337
00:16:23,430 --> 00:16:25,944
你可以照亮一切
同比禁用夜間模式。

338
00:16:25,944 --> 00:16:27,860
而在底了
一天，你會看到

339
00:16:27,860 --> 00:16:33,090
這三個主要areas--文件
在瀏覽器的左邊，代碼標籤向上頂，

340
00:16:33,090 --> 00:16:35,430
和在底部的終端窗口。

341
00:16:35,430 --> 00:16:37,890
>> 讓我繼續前進，
寫我的第一個程序。

342
00:16:37,890 --> 00:16:45,300
我要搶先去文件，
保存，我的文件保存為hello.c的。

343
00:16:45,300 --> 00:16:49,850
事實上，按照慣例，任何程序我們
寫是寫C語言

344
00:16:49,850 --> 00:16:52,739
名稱應該
C點，按照約定。

345
00:16:52,739 --> 00:16:56,030
所以，我打算將其命名為hello.c的，因為
我只是想打個招呼世界。

346
00:16:56,030 --> 00:16:57,820
現在，我要放大
並點擊保存。

347
00:16:57,820 --> 00:17:01,180
和所有我現在這裡是一個標籤
在我可以開始編寫代碼。

348
00:17:01,180 --> 00:17:02,490
>> 這不會編譯。

349
00:17:02,490 --> 00:17:03,300
這意味著什麼。

350
00:17:03,300 --> 00:17:05,750
所以，即使我轉換
這對零和一，

351
00:17:05,750 --> 00:17:08,390
在CPU將不得不無
知道發生了什麼繞來繞去。

352
00:17:08,390 --> 00:17:17,170
但是，如果我寫的線條那些匹配
就以C的conventions-- C是，

353
00:17:17,170 --> 00:17:23,150
再次，這language--語法像
對此，printf的招呼天下 - 我已經

354
00:17:23,150 --> 00:17:25,210
得到舒服
這樣隨著時間的推移。

355
00:17:25,210 --> 00:17:27,510
所以，我不認為我做了
任何印刷錯誤。

356
00:17:27,510 --> 00:17:30,910
>> 但是，不約而同地，第一個
你這樣做的時候，你會的。

357
00:17:30,910 --> 00:17:34,090
什麼我將做很可能會
也不會為你工作的第一次。

358
00:17:34,090 --> 00:17:36,610
而這完全確定，
因為現在你

359
00:17:36,610 --> 00:17:40,662
可能只是看到一大堆新奇的，
但隨著時間的推移，一旦你熟悉

360
00:17:40,662 --> 00:17:42,870
與此環境下，並
這種語言，等人，

361
00:17:42,870 --> 00:17:45,370
你會開始看到的東西，
要么是正確或不正確。

362
00:17:45,370 --> 00:17:47,369
>> 這是什麼
教學研究員，當然

363
00:17:47,369 --> 00:17:51,780
助理在得到隨著時間的推移這麼好，是
察覺你的代碼錯誤或錯誤。

364
00:17:51,780 --> 00:17:55,110
但我要求有
在這段代碼中沒有錯誤。

365
00:17:55,110 --> 00:17:56,990
所以，我現在要運行這個程序。

366
00:17:56,990 --> 00:18:00,440
>> 現在我自己的Mac或PC，我在
中雙擊圖標的習慣

367
00:18:00,440 --> 00:18:02,350
當我要運行一些程序。

368
00:18:02,350 --> 00:18:04,080
但是，這不是模型在這裡。

369
00:18:04,080 --> 00:18:07,570
在這樣的環境中，這是CS50的IDE。

370
00:18:07,570 --> 00:18:10,192
我們使用的操作系統
系統稱為Linux。

371
00:18:10,192 --> 00:18:12,900
Linux是讓人聯想到另一
操作系統，通常已知

372
00:18:12,900 --> 00:18:13,850
作為Unix的。

373
00:18:13,850 --> 00:18:19,340
而Linux是特別出名
有一個命令行環境，CLI。

374
00:18:19,340 --> 00:18:23,070
現在，我們使用一個特定的
Linux的味道叫做Ubuntu Linux系統。

375
00:18:23,070 --> 00:18:25,770
和Ubuntu是一個簡單的
某些版本的Linux。

376
00:18:25,770 --> 00:18:30,900
>> 但是這些的Linux的這些天真正做到
配備了圖形用戶界面。

377
00:18:30,900 --> 00:18:33,360
和一個我們碰巧
在這裡使用是基於Web的。

378
00:18:33,360 --> 00:18:35,735
因此，這可能看起來甚至
從東西有點不同

379
00:18:35,735 --> 00:18:38,310
你自己可能有
看到或跑過去。

380
00:18:38,310 --> 00:18:40,910
>> 所以我要繼續前進
現在做到以下幾點。

381
00:18:40,910 --> 00:18:43,950
我已經保存此文件的hello.c。

382
00:18:43,950 --> 00:18:50,350
我要繼續前進，
類型clanghello.c所以鏘

383
00:18:50,350 --> 00:18:52,850
對於C語言編譯器。

384
00:18:52,850 --> 00:18:54,952
這是預安裝在CS50 IDE。

385
00:18:54,952 --> 00:18:57,910
你完全可以下載
在自己的Mac或PC上安裝它。

386
00:18:57,910 --> 00:19:00,910
>> 但是，同樣，你不會有所有的
為您預先配置完成。

387
00:19:00,910 --> 00:19:03,940
所以現在，我只是
要運行clanghello.c。

388
00:19:03,940 --> 00:19:06,240
而現在注意到這一點語法
這裡最終將

389
00:19:06,240 --> 00:19:09,930
認識只是意味著我在
文件夾或目錄被稱為工作區。

390
00:19:09,930 --> 00:19:14,030
這個美元符號僅僅是慣例
為內涵，在這裡輸入你的命令。

391
00:19:14,030 --> 00:19:17,560
>> 這就是被稱為一個提示，只是
按照慣例是美元符號。

392
00:19:17,560 --> 00:19:22,130
如果我繼續前進，現在並點擊
回車後，似乎沒有任何已經發生。

393
00:19:22,130 --> 00:19:23,930
但是，這實際上是一件好事。

394
00:19:23,930 --> 00:19:26,650
出現這種情況就少
您的屏幕，越有可能

395
00:19:26,650 --> 00:19:29,710
你的代碼是正確，
至少語法。

396
00:19:29,710 --> 00:19:32,120
>> 所以，如果我想運行此
程序，我該怎麼辦？

397
00:19:32,120 --> 00:19:36,770
嗯，事實證明，
按照慣例默認名稱

398
00:19:36,770 --> 00:19:41,854
對於程序時，您不指定
名稱為您的計劃僅僅是為a.out。

399
00:19:41,854 --> 00:19:44,270
而這也是語法，你會
熟悉不久。

400
00:19:44,270 --> 00:19:50,500
>> 點斜線只是意味著，哎，CS50
IDE，運行一個名為a.out的程序

401
00:19:50,500 --> 00:19:52,400
這是我的當前目錄裡。

402
00:19:52,400 --> 00:19:54,520
這點是指當前目錄。

403
00:19:54,520 --> 00:19:58,040
我們會看到什麼其他的這些序列
人物不久手段。

404
00:19:58,040 --> 00:20:01,430
>> 所以在這裡我們去，回車，世界你好。

405
00:20:01,430 --> 00:20:03,080
你會發現，發生了什麼？

406
00:20:03,080 --> 00:20:04,580
它不僅打印的hello world。

407
00:20:04,580 --> 00:20:08,990
它也感動
光標移到下一行。

408
00:20:08,990 --> 00:20:10,160
>> 以及為什麼呢？

409
00:20:10,160 --> 00:20:15,400
那是什麼，我們以前寫的代碼
即確保該光標將

410
00:20:15,400 --> 00:20:17,882
繼續下一行？

411
00:20:17,882 --> 00:20:19,840
大約一個有趣的事情
計算機是它一定會

412
00:20:19,840 --> 00:20:21,570
做字面上你告訴它做。

413
00:20:21,570 --> 00:20:29,050
>> 所以，如果你告訴它給printf你好，
逗號，空間，世界，接近報價，

414
00:20:29,050 --> 00:20:32,090
它字面上只打算
打印這些字符。

415
00:20:32,090 --> 00:20:34,980
但我有這個特殊字符
在年底，召回，反斜線ñ。

416
00:20:34,980 --> 00:20:37,230
而這正是保證
該字符去

417
00:20:37,230 --> 00:20:39,570
到屏幕的下一行。

418
00:20:39,570 --> 00:20:41,097
>> 事實上，讓我去做到這一點。

419
00:20:41,097 --> 00:20:42,430
讓我繼續前進，刪除。

420
00:20:42,430 --> 00:20:44,180
現在，請注意
我的屏幕上方有

421
00:20:44,180 --> 00:20:45,890
一個小紅燈
標籤顯示，

422
00:20:45,890 --> 00:20:48,047
哎，你不保存文件。

423
00:20:48,047 --> 00:20:50,880
所以，我要與控制繼續前進
S或命令S，保存文件。

424
00:20:50,880 --> 00:20:54,130
現在goes--去了moment--綠色。

425
00:20:54,130 --> 00:20:56,760
而現在又回到了
只是作為一個關閉圖標。

426
00:20:56,760 --> 00:21:04,860
>> 如果我現在再次運行clanghello.c，
進入，點斜線，a.out的，回車，

427
00:21:04,860 --> 00:21:07,110
你會看到，它仍然工作。

428
00:21:07,110 --> 00:21:09,020
但它可以說是一個小馬車。

429
00:21:09,020 --> 00:21:11,714
現在，我的工作區prompt--，
然後是美元符號，

430
00:21:11,714 --> 00:21:13,880
然後我的實際prompt--
是所有在同一行上。

431
00:21:13,880 --> 00:21:17,540
所以這肯定是一個錯誤的審美，
即使它不是一個真正的邏輯錯誤。

432
00:21:17,540 --> 00:21:19,250
>> 所以，我要撤銷我只是做了。

433
00:21:19,250 --> 00:21:21,560
我要重新運行的a.out。

434
00:21:21,560 --> 00:21:25,710
請注意，我已經添加了
換行符回來。

435
00:21:25,710 --> 00:21:27,280
我保存的文件。

436
00:21:27,280 --> 00:21:34,630
>> 所以，我要的a.out重新運行，還有 - 
該死，一個bug，錯誤的意思的錯誤。

437
00:21:34,630 --> 00:21:38,020
因此，錯誤是，即使
我加了反斜線Ñ那裡，

438
00:21:38,020 --> 00:21:44,180
重新保存，重新運行該程序，
的行為是相同的。

439
00:21:44,180 --> 00:21:45,640
為什麼會是這樣？

440
00:21:45,640 --> 00:21:46,910
>> 我缺少的一個步驟，對不對？

441
00:21:46,910 --> 00:21:50,620
這關鍵的一步早前是你有
當你改變你的源代碼中場休息，

442
00:21:50,620 --> 00:21:52,610
事實證明也辦
它通過編譯

443
00:21:52,610 --> 00:21:54,102
再次讓你獲得新的機器代碼。

444
00:21:54,102 --> 00:21:55,810
和機器代碼，
在零和一，

445
00:21:55,810 --> 00:21:59,260
將要幾乎相同，但
不完全是這樣，因為我們需要的，

446
00:21:59,260 --> 00:22:00,510
當然，新的線路。

447
00:22:00,510 --> 00:22:05,640
>> 因此，要解決這個問題，我會需要
重新運行clanghello.c，輸入，點

448
00:22:05,640 --> 00:22:06,800
斜線，a.out的。

449
00:22:06,800 --> 00:22:11,402
而現在，世界您好又回來了
在那裡我希望它是。

450
00:22:11,402 --> 00:22:12,610
因此，這是一切優秀和良好。

451
00:22:12,610 --> 00:22:16,150
但a.out的是一個相當愚蠢的名字
方案，即使它正好是，

452
00:22:16,150 --> 00:22:19,530
由於歷史的原因，
default--意思裝配輸出。

453
00:22:19,530 --> 00:22:23,780
>> 但讓​​我繼續在這裡
而不同的做到這一點。

454
00:22:23,780 --> 00:22:27,760
我希望我的Hello World程序
實際上叫你好。

455
00:22:27,760 --> 00:22:31,320
所以，如果它是一個圖標我
台式機，它不會被A.OUT。

456
00:22:31,320 --> 00:22:32,730
它會被稱為打招呼。

457
00:22:32,730 --> 00:22:36,660
>> 因此，要做到這一點，事實證明
那鐺，像許多節目，

458
00:22:36,660 --> 00:22:40,980
支持命令行參數，
或標誌，或開關

459
00:22:40,980 --> 00:22:42,600
它只是影響其行為。

460
00:22:42,600 --> 00:22:48,160
具體來說，鏘支持破折號Ø
標誌，然後拿著第二個字。

461
00:22:48,160 --> 00:22:51,190
在這種情況下，我會隨意，
但合理的，把它打個招呼。

462
00:22:51,190 --> 00:22:53,710
但我可以把它叫做什麼
我想，除了a.out的，這

463
00:22:53,710 --> 00:22:55,390
會相當除了點。

464
00:22:55,390 --> 00:22:58,640
>> 然後只需指定名稱
文件我確實想編譯。

465
00:22:58,640 --> 00:23:02,190
所以，現在即使在開始
命令我仍然有鐺的，

466
00:23:02,190 --> 00:23:04,410
在命令結束時
我仍然有文件名，

467
00:23:04,410 --> 00:23:08,520
我現在有這些命令行
參數，這些標誌是在說，

468
00:23:08,520 --> 00:23:14,180
哦，對了，輸出-O，文件
名為hello，而不是默認的a.out。

469
00:23:14,180 --> 00:23:16,810
>> 所以，現在如果我打回車鍵，沒什麼
似乎已經發生了。

470
00:23:16,810 --> 00:23:20,900
而且，然而，現在我可以做點斜線打招呼。

471
00:23:20,900 --> 00:23:22,089
所以這是相同的程序。

472
00:23:22,089 --> 00:23:24,380
在零和一的
相同在一天結束。

473
00:23:24,380 --> 00:23:27,210
>> 但是他們兩個
不同files--的a.out，

474
00:23:27,210 --> 00:23:29,490
這是第一個版本
和公正的愚蠢命名，

475
00:23:29,490 --> 00:23:33,250
現在你好，這是一個非常
更引人注目的名字的程序。

476
00:23:33,250 --> 00:23:36,195
但是，說實話，我從來沒有
又要記住這一點，

477
00:23:36,195 --> 00:23:37,070
又一次，又一次。

478
00:23:37,070 --> 00:23:39,411
而且，事實上，正如我們寫
更複雜的程序，

479
00:23:39,411 --> 00:23:41,160
你的命令
不得不寫

480
00:23:41,160 --> 00:23:43,920
要報復
更複雜的仍。

481
00:23:43,920 --> 00:23:44,940
>> 所以不用擔心。

482
00:23:44,940 --> 00:23:49,220
事實證明，人類前
我們已經意識到，他們也

483
00:23:49,220 --> 00:23:50,530
有這個相同的問題。

484
00:23:50,530 --> 00:23:53,900
他們也沒有享受不必
鍵入相當長的，神秘的命令，

485
00:23:53,900 --> 00:23:55,200
更不用說記住他們。

486
00:23:55,200 --> 00:23:59,070
所以，擺在我們面前的人類已經取得
其他程序，可以更容易

487
00:23:59,070 --> 00:24:00,670
編譯軟件。

488
00:24:00,670 --> 00:24:04,609
>> 而且，事實上，這樣的一個
計劃被稱為製作。

489
00:24:04,609 --> 00:24:06,150
所以我要繼續前進，並做到這一點。

490
00:24:06,150 --> 00:24:08,691
我要撤銷我的一切
正好在下面的方式一樣。

491
00:24:08,691 --> 00:24:10,690
讓我LS型。

492
00:24:10,690 --> 00:24:13,980
你會注意到三個things--
a.out的，和一個明星，你好

493
00:24:13,980 --> 00:24:15,810
和一個明星，而hello.c中。

494
00:24:15,810 --> 00:24:17,730
但願，這應該
有一點直觀，

495
00:24:17,730 --> 00:24:21,220
只要前面有
沒有在此工作空間。

496
00:24:21,220 --> 00:24:24,240
沒有什麼，我有
創建，直到我們開始上課。

497
00:24:24,240 --> 00:24:25,840
>> 和我創建的hello.c。

498
00:24:25,840 --> 00:24:27,544
然後我編譯它，並把它稱為a.out的。

499
00:24:27,544 --> 00:24:30,460
然後我再編譯稍微
不同，稱之為打招呼。

500
00:24:30,460 --> 00:24:35,830
所以我有這個目錄中的三個文件，
在這個文件夾叫工作空間。

501
00:24:35,830 --> 00:24:38,005
現在，我可以看到，以及
如果我縮小實際。

502
00:24:38,005 --> 00:24:40,530
>> 如果我縮小這裡
看那個右上角

503
00:24:40,530 --> 00:24:42,940
角落裡，如許左
屏幕的右側

504
00:24:42,940 --> 00:24:45,990
總是會告訴你
什麼是在您的帳戶，有什麼

505
00:24:45,990 --> 00:24:47,790
裡面CS50的IDE。

506
00:24:47,790 --> 00:24:49,680
而且有三個文件存在。

507
00:24:49,680 --> 00:24:52,070
>> 所以，我想擺脫的a.out和打招呼。

508
00:24:52,070 --> 00:24:54,275
正如你可能
想像直觀，你

509
00:24:54,275 --> 00:24:56,400
可以控制排序點擊
或右鍵點擊這個。

510
00:24:56,400 --> 00:24:57,590
而這個小菜單彈出。

511
00:24:57,590 --> 00:25:00,170
您也可以下載文件，運行
它，預覽，刷新，重命名，

512
00:25:00,170 --> 00:25:00,700
或什麼不是。

513
00:25:00,700 --> 00:25:03,260
>> 而且我可能只是刪除，
它會消失。

514
00:25:03,260 --> 00:25:08,260
但是讓我們做的事情有一個命令
行了，這樣才能讓自己舒服

515
00:25:08,260 --> 00:25:10,010
這一點，並做到以下幾點。

516
00:25:10,010 --> 00:25:15,345
我要繼續前進，並刪除
通過鍵入字面上rma.out的a.out。

517
00:25:15,345 --> 00:25:17,890
原來，該命令
去除或刪除的東西，

518
00:25:17,890 --> 00:25:19,280
是不是刪除或刪除。

519
00:25:19,280 --> 00:25:24,260
>> 這是更簡潔RM，只是為了節省
你一些按鍵，並按下回車鍵。

520
00:25:24,260 --> 00:25:27,707
現在，我們要有點
神秘地刪除常規文件的a.out。

521
00:25:27,707 --> 00:25:30,040
我真的不知道是什麼的
不規則的文件會呢。

522
00:25:30,040 --> 00:25:31,660
但我要刪除它。

523
00:25:31,660 --> 00:25:33,150
>> 所以，我要鍵入Y（是）。

524
00:25:33,150 --> 00:25:34,940
或者，我可以鍵入它，然後按Enter鍵。

525
00:25:34,940 --> 00:25:36,440
並再次，好像沒有什麼改變。

526
00:25:36,440 --> 00:25:38,840
但是，這是一般，是一件好事。

527
00:25:38,840 --> 00:25:43,490
>> 如果我輸入ls這一次，
我應該怎麼看？

528
00:25:43,490 --> 00:25:47,930
我們希望，只是打招呼，hello.c中。

529
00:25:47,930 --> 00:25:50,286
現在，順便說一句，你會
注意到這一點明星，星號，

530
00:25:50,286 --> 00:25:51,660
這是在我的節目的結束。

531
00:25:51,660 --> 00:25:53,201
而且他們也顯示為綠色。

532
00:25:53,201 --> 00:25:56,970
這僅僅是CS50 IDE的方式
cluing你到事實的

533
00:25:56,970 --> 00:25:58,280
那這不是源代碼。

534
00:25:58,280 --> 00:26:01,880
這是一個可執行文件，可運行
你可以實際運行的程序

535
00:26:01,880 --> 00:26:04,020
通過做點斜杠，然後它的名字。

536
00:26:04,020 --> 00:26:08,860
>> 現在，讓我繼續和刪除
對此，RM你好，回車，定期刪除

537
00:26:08,860 --> 00:26:11,010
文件你好，是的。

538
00:26:11,010 --> 00:26:14,180
現在，如果我輸入LS，
我們又回到hello.c中。

539
00:26:14,180 --> 00:26:16,917
盡量不要刪除
實際的源代碼。

540
00:26:16,917 --> 00:26:19,250
即使有特點
內置IDE CS50在哪裡

541
00:26:19,250 --> 00:26:22,870
你可以通過你的修訂歷史記錄
並及時退，如果你不小心

542
00:26:22,870 --> 00:26:26,660
刪除一些東西，做銘記
按照這些提示是或否，

543
00:26:26,660 --> 00:26:28,381
什麼你真正想做的事情。

544
00:26:28,381 --> 00:26:30,380
如果我去到頂部
這裡左手角落，

545
00:26:30,380 --> 00:26:33,696
剩下的工作就是hello.c中。

546
00:26:33,696 --> 00:26:35,570
因此，有一束束
其他命令你

547
00:26:35,570 --> 00:26:40,550
可在Linux世界執行，
其中之一是，再次進行。

548
00:26:40,550 --> 00:26:43,180
而我們要製作
我現在的程序如下。

549
00:26:43,180 --> 00:26:46,270
>> 而不是做鐺的，
而不是做鐺-O，

550
00:26:46,270 --> 00:26:48,860
我要簡單地
從字面上類型，製造打招呼。

551
00:26:48,860 --> 00:26:52,630
而現在發現，我
不打字做的hello.c。

552
00:26:52,630 --> 00:26:53,910
我打字做打招呼。

553
00:26:53,910 --> 00:26:57,840
>> 而這個節目的製作
自帶CS50 IDE，以及更多

554
00:26:57,840 --> 00:27:00,090
一般的Linux，
是一個程序，是

555
00:27:00,090 --> 00:27:02,120
要做一個名為Hello程序。

556
00:27:02,120 --> 00:27:06,680
而且它要承擔，按照慣例，
如果可以進行該程序，

557
00:27:06,680 --> 00:27:12,030
它會從一個源發
代碼文件中C點結束，hello.c中。

558
00:27:12,030 --> 00:27:15,210
>> 所以，現在如果我打回車，通知，
這被執行的命令

559
00:27:15,210 --> 00:27:17,340
實際上甚至更長
前比以前。

560
00:27:17,340 --> 00:27:19,670
那是因為我們已經
預配置CS50 IDE有

561
00:27:19,670 --> 00:27:22,878
建於一些額外的功能
我們並不需要，只是還沒有，但很快會。

562
00:27:22,878 --> 00:27:26,470
但關鍵的事情來實現
現在我有一個Hello程序。

563
00:27:26,470 --> 00:27:30,080
>> 如果我再次鍵入LS，我
有一個hello程序。

564
00:27:30,080 --> 00:27:35,070
而且我可以運行它
點斜線a.out的，不，

565
00:27:35,070 --> 00:27:38,590
因為這個整點
演習點斜線打招呼。

566
00:27:38,590 --> 00:27:41,089
現在，我有我的Hello World程序。

567
00:27:41,089 --> 00:27:42,880
所以向前走，
我們幾乎永遠只是

568
00:27:42,880 --> 00:27:45,088
要編譯我們的節目
使用命令make。

569
00:27:45,088 --> 00:27:48,300
然後，我們將通過為它們運行
點斜線，程序的名字。

570
00:27:48,300 --> 00:27:52,610
但要意識到什麼使正在為
你，是它本身不是一個編譯器。

571
00:27:52,610 --> 00:27:56,310
這只是一個方便程序
知道如何觸發一個編譯器

572
00:27:56,310 --> 00:27:59,470
運行，讓你自己可以使用它。

573
00:27:59,470 --> 00:28:03,220
>> 還有什麼其他的命令中存在
Linux和依次CS50的IDE？

574
00:28:03,220 --> 00:28:06,107
我們很快就會看到，有一個
CD命令，切換目錄。

575
00:28:06,107 --> 00:28:08,190
這允許您在
你的命令行界面

576
00:28:08,190 --> 00:28:10,610
繼續前進，和背部，
並打開不同的文件夾

577
00:28:10,610 --> 00:28:11,860
不使用鼠標。

578
00:28:11,860 --> 00:28:15,470
>> 我們看到了LS，代表名單
在當前目錄中的文件。

579
00:28:15,470 --> 00:28:17,650
讓迪爾，你可以
可能開始推斷

580
00:28:17,650 --> 00:28:21,150
這些意味著什麼now--創建目錄，
如果你想創建一個文件夾。

581
00:28:21,150 --> 00:28:24,270
RM為刪除，RM為迪爾
刪除directory--而這些，

582
00:28:24,270 --> 00:28:27,160
再次，是命令行
什麼你現金等價物

583
00:28:27,160 --> 00:28:29,945
可在CS50 IDE與你的鼠標。

584
00:28:29,945 --> 00:28:31,820
但是，你很快就會發現
有時它只是

585
00:28:31,820 --> 00:28:33,610
速度快了很多做
事用鍵盤，

586
00:28:33,610 --> 00:28:36,690
最終很多更強大。

587
00:28:36,690 --> 00:28:39,440
>> 但是，這很難說
任何事情我們一直在做，到目前為止

588
00:28:39,440 --> 00:28:42,990
是所有強大的，當所有
我們一直在說的是，世界你好。

589
00:28:42,990 --> 00:28:46,740
而且，事實上，我的硬編碼
也就是說世界你好了我的計劃。

590
00:28:46,740 --> 00:28:48,530
有沒有活力呢。

591
00:28:48,530 --> 00:28:52,320
划痕是一個數量級
更有趣的最後一周。

592
00:28:52,320 --> 00:28:54,220
>> 所以，讓我們在那裡。

593
00:28:54,220 --> 00:28:58,310
讓我們走向一個一步
一些這些功能的方法。

594
00:28:58,310 --> 00:29:02,470
所以不僅ç配備的printf，
其它的功能和束

595
00:29:02,470 --> 00:29:04,850
其中的一些，我們會看到
隨著時間的推移，它不

596
00:29:04,850 --> 00:29:08,760
使這一切容易右出
在獲取用戶輸入的柵極。

597
00:29:08,760 --> 00:29:11,140
>> 弱點事實上，人們
的語言，如C，

598
00:29:11,140 --> 00:29:13,140
甚至Java和尚未
別人是，它不

599
00:29:13,140 --> 00:29:18,860
可以很容易地只得到一樣的東西
從用戶或字符串，整數的話，

600
00:29:18,860 --> 00:29:22,970
和短語，讓喜歡獨處的東西
浮點值，或實數

601
00:29:22,970 --> 00:29:26,240
帶有小數點的，真
長數字，因為我們很快就會看到。

602
00:29:26,240 --> 00:29:30,000
所以功能這個名單在這裡，這些
就像其他的划痕拼圖

603
00:29:30,000 --> 00:29:34,090
我們已經預先安裝在CS50
IDE，我們將用數週

604
00:29:34,090 --> 00:29:37,010
作為各種訓練車輪，和
最終把他們趕走，並期待

605
00:29:37,010 --> 00:29:40,210
引擎蓋，也許，在下方
這些東西是如何實現的。

606
00:29:40,210 --> 00:29:43,460
>> 但要做到這一點，讓我們
其實寫一個程序。

607
00:29:43,460 --> 00:29:44,770
現在讓我先走。

608
00:29:44,770 --> 00:29:47,750
而且我要創建一個新的
通過點擊這個小加檔，

609
00:29:47,750 --> 00:29:48,970
然後單擊新建文件。

610
00:29:48,970 --> 00:29:52,250
>> 我要救這下
一個作為，讓我們說，string.c，

611
00:29:52,250 --> 00:29:53,750
因為我想用繩子玩。

612
00:29:53,750 --> 00:29:56,990
和字符串在C是剛
字符序列。

613
00:29:56,990 --> 00:29:59,090
所以，現在讓我們繼續
並做到以下幾點。

614
00:29:59,090 --> 00:30:04,204
>> 包括標準IO.h--和
事實證明標準IO，

615
00:30:04,204 --> 00:30:06,360
IO只是意味著輸入和輸出。

616
00:30:06,360 --> 00:30:08,920
所以，事實證明，
這裡這條線是什麼

617
00:30:08,920 --> 00:30:11,140
在相鄰的我們用printf。

618
00:30:11,140 --> 00:30:13,410
printf的，當然，產生輸出。

619
00:30:13,410 --> 00:30:18,000
因此，為了用printf，原來
出你必須有這行代碼

620
00:30:18,000 --> 00:30:19,040
在你的文件的頂部。

621
00:30:19,040 --> 00:30:21,456
>> 我們會回來的是什麼
不久的真正含義。

622
00:30:21,456 --> 00:30:23,400
事實證明，在
任何C程序我寫的，

623
00:30:23,400 --> 00:30:26,640
我必須與啟動
代碼如下所示。

624
00:30:26,640 --> 00:30:29,860
你會發現CS50 IDE和
其他集成開發

625
00:30:29,860 --> 00:30:33,050
喜歡它的環境，
要盡可能在

626
00:30:33,050 --> 00:30:34,780
他們可以完成你的想法。

627
00:30:34,780 --> 00:30:38,930
其實，剛才我是否撤消
我只是做了，我打回車鍵。

628
00:30:38,930 --> 00:30:42,160
>> 然後我打左大
撐，命中再次輸入。

629
00:30:42,160 --> 00:30:43,430
它完成了我的想法。

630
00:30:43,430 --> 00:30:48,140
它給了我一個新的生產線，縮進不會少
對於好的文體的原因，我們拭目以待。

631
00:30:48,140 --> 00:30:51,559
然後它會自動給我
那花括號來完成我的想法。

632
00:30:51,559 --> 00:30:53,600
現在，它並不總是
猜你想要做什麼。

633
00:30:53,600 --> 00:30:56,620
但在很大程度上，它確實
為您節省一些按鍵。

634
00:30:56,620 --> 00:31:02,560
所以，剛才，我們跑這program--
你好，世界，然後編譯它，

635
00:31:02,560 --> 00:31:03,460
然後運行它。

636
00:31:03,460 --> 00:31:04,867
但這裡有沒有活力。

637
00:31:04,867 --> 00:31:06,700
如果我們想
做不同的事情？

638
00:31:06,700 --> 00:31:10,630
好吧，如果我想實際
獲取來自用戶的字符串？

639
00:31:10,630 --> 00:31:14,250
我將使用一塊拼圖
正是所謂的that--得到的字符串。

640
00:31:14,250 --> 00:31:18,860
>> 用C原來，當你不想要
提供輸入到一塊拼圖，

641
00:31:18,860 --> 00:31:22,360
或者更恰當給一個函數，你
從字面上只是做開括號，

642
00:31:22,360 --> 00:31:23,430
右括號。

643
00:31:23,430 --> 00:31:28,540
因此，這好像有
沒有白框鍵入。

644
00:31:28,540 --> 00:31:30,720
之前說塊
有一個白色的小盒子。

645
00:31:30,720 --> 00:31:32,660
我們沒有白框現在。

646
00:31:32,660 --> 00:31:36,310
>> 但是，當我調用get字符串，我
想不想找個地方把結果。

647
00:31:36,310 --> 00:31:40,680
所以在C很常見的模式是
這裡調用一個函數，以獲得更多的字符串，

648
00:31:40,680 --> 00:31:44,070
然後存儲它的返回值。

649
00:31:44,070 --> 00:31:47,450
它的結果其
努力的東西。

650
00:31:47,450 --> 00:31:50,630
>> 什麼是
構造在編程，

651
00:31:50,630 --> 00:31:56,450
無論是在划痕或現在C，我們
可以使用實際存儲的東西嗎？

652
00:31:56,450 --> 00:31:58,990
稱它是可變的，對不對？

653
00:31:58,990 --> 00:32:03,320
而在劃傷，我們真的不
關心變量打算。

654
00:32:03,320 --> 00:32:05,170
>> 但是，在這種情況下，我們實際上做的。

655
00:32:05,170 --> 00:32:06,719
我要說的字符串。

656
00:32:06,719 --> 00:32:08,510
然後，我可以打電話給
這樣的事情我想要的。

657
00:32:08,510 --> 00:32:11,340
我要叫它
名稱，獲取得到的字符串。

658
00:32:11,340 --> 00:32:13,250
>> 現在，即使你
有點新本，

659
00:32:13,250 --> 00:32:14,984
注意到，我缺少一些細節。

660
00:32:14,984 --> 00:32:16,150
我忘了一個分號。

661
00:32:16,150 --> 00:32:17,400
我需要完成這一思想。

662
00:32:17,400 --> 00:32:20,480
所以，我打算將我的光標，
並創下分號那裡。

663
00:32:20,480 --> 00:32:22,130
和你有我只是做了什麼？

664
00:32:22,130 --> 00:32:24,440
在這行代碼，
此刻號5，

665
00:32:24,440 --> 00:32:26,799
我調用get字符串，沒有投入。

666
00:32:26,799 --> 00:32:29,090
因此，有不小的白色
像盒保存塊。

667
00:32:29,090 --> 00:32:31,590
>> 我只是說，嘿，
電腦，給我一個字符串。

668
00:32:31,590 --> 00:32:34,390
等號是不是真的
一個等號，本身。

669
00:32:34,390 --> 00:32:36,790
這是分配
操作者，這意味著，

670
00:32:36,790 --> 00:32:40,860
哎，電腦，移動值
從以上至左右。

671
00:32:40,860 --> 00:32:43,480
而在左邊，我有以下。

672
00:32:43,480 --> 00:32:46,580
>> 嘿，電腦，給我一個string--
字符序列。

673
00:32:46,580 --> 00:32:48,637
並調用該字符串名稱。

674
00:32:48,637 --> 00:32:50,220
我甚至不具備調用它的名稱。

675
00:32:50,220 --> 00:32:52,970
>> 我可以調用它，按照慣例，
像S，

676
00:32:52,970 --> 00:32:55,900
就像我們用我來
調用變量i。

677
00:32:55,900 --> 00:32:57,829
但現在我需要用它做什麼。

678
00:32:57,829 --> 00:33:00,370
這將是非常愚蠢的
嘗試編譯這段代碼，運行

679
00:33:00,370 --> 00:33:02,410
這個程序，即使
我得到一個字符串，

680
00:33:02,410 --> 00:33:04,580
因為它仍然只是
去打招呼的世界。

681
00:33:04,580 --> 00:33:09,140
>> 但是，如果我不想要什麼來改變這種狀況。

682
00:33:09,140 --> 00:33:10,940
我為什麼不這樣做呢？

683
00:33:10,940 --> 00:33:14,632
％的S，逗號秒。

684
00:33:14,632 --> 00:33:16,090
這是一個有點神秘依舊。

685
00:33:16,090 --> 00:33:18,560
>> 所以，讓我的變量更加清晰。

686
00:33:18,560 --> 00:33:20,510
讓我這個變量名稱。

687
00:33:20,510 --> 00:33:23,230
讓我們看看如果我們不能去惹
除了這裡發生了什麼。

688
00:33:23,230 --> 00:33:25,770
>> 因此，對五號線，我得到的字符串。

689
00:33:25,770 --> 00:33:28,620
而我存儲這個字符串，
無論用戶已鍵入的

690
00:33:28,620 --> 00:33:31,430
在他或她的鍵盤，
在一個名為名稱的變量。

691
00:33:31,430 --> 00:33:33,590
而事實證明，
printf的不只是

692
00:33:33,590 --> 00:33:37,220
採取雙重一個參數
引號，在雙引號的輸入。

693
00:33:37,220 --> 00:33:42,100
>> 它可以採取兩個或三個，或更多，如
使第二，或第三，或第四，

694
00:33:42,100 --> 00:33:45,320
是變量所有的名字，
或者特別重視，

695
00:33:45,320 --> 00:33:51,610
要插入，
動態，用引號引起該字符串。

696
00:33:51,610 --> 00:33:55,110
換句話說，什麼
將問題呢？

697
00:33:55,110 --> 00:34:00,920
如果我只是說你好名稱，反斜線
N，救了我的文件，我的編譯代碼，

698
00:34:00,920 --> 00:34:04,660
跑了這一點，會發生什麼？

699
00:34:04,660 --> 00:34:08,139
>> 它只是會說，你好
名字，從字面上N-A-M-E，

700
00:34:08,139 --> 00:34:10,900
這是一種愚蠢的，因為
這是一個從世界上沒有什麼不同。

701
00:34:10,900 --> 00:34:13,400
因此，在行情是什麼
什麼字面上被打印出來。

702
00:34:13,400 --> 00:34:15,520
所以，如果我想有
一個佔位符那裡，

703
00:34:15,520 --> 00:34:17,422
我真正需要使用
一些特殊的語法。

704
00:34:17,422 --> 00:34:20,380
而事實證明，如果你讀了
對於printf函數的文檔，

705
00:34:20,380 --> 00:34:24,320
它會告訴你，
如果你使用％的S，

706
00:34:24,320 --> 00:34:26,920
您可以按如下替換值。

707
00:34:26,920 --> 00:34:30,190
>> 後一個逗號後
雙引號，你只需

708
00:34:30,190 --> 00:34:32,179
寫的名字
要變

709
00:34:32,179 --> 00:34:36,790
插上到該格式
代碼或格式說明，

710
00:34:36,790 --> 00:34:38,469
％的S代表字符串。

711
00:34:38,469 --> 00:34:42,190
現在，如果我救了我的文件，
我回去到我的終端。

712
00:34:42,190 --> 00:34:45,870
而I型製作繩，
因為，再次，在此名稱

713
00:34:45,870 --> 00:34:48,510
我之前選擇的文件是string.c。

714
00:34:48,510 --> 00:34:51,510
>> 所以，我要說讓字符串，請輸入。

715
00:34:51,510 --> 00:34:54,550
我的天哪，看看所有的
錯誤我們已經取得了。

716
00:34:54,550 --> 00:34:58,540
而這is--什麼，這實在是
像六，七行程序？

717
00:34:58,540 --> 00:35:00,790
因此，這是它可以很
快速獲得壓倒性的。

718
00:35:00,790 --> 00:35:03,890
>> 該終端窗口有
現在只是反芻

719
00:35:03,890 --> 00:35:06,230
數量巨大的錯誤消息。

720
00:35:06,230 --> 00:35:10,560
當然，我沒有更多的錯誤
消息比我行代碼。

721
00:35:10,560 --> 00:35:11,680
那麼到底是怎麼回事？

722
00:35:11,680 --> 00:35:13,920
>> 那麼，最好的策略
做到任何時候你

723
00:35:13,920 --> 00:35:16,710
確實遇到了壓倒性
這樣的錯誤列表，

724
00:35:16,710 --> 00:35:19,690
被回滾，查找命令
你剛剛運行，這在我的情況下，

725
00:35:19,690 --> 00:35:21,020
為使字符串。

726
00:35:21,020 --> 00:35:24,630
看看什麼使所做的，就是這樣
長鐺命令，沒什麼大不了的存在。

727
00:35:24,630 --> 00:35:25,950
>> 但紅色是壞的。

728
00:35:25,950 --> 00:35:27,750
格林試圖將
溫柔，樂於助人。

729
00:35:27,750 --> 00:35:29,140
但它仍然很糟糕，在這種情況下。

730
00:35:29,140 --> 00:35:30,510
但是，在這樣做不好？

731
00:35:30,510 --> 00:35:34,450
>> String.c，五號線，性格五位。

732
00:35:34,450 --> 00:35:35,930
所以這只是常見的約定。

733
00:35:35,930 --> 00:35:39,060
結腸癌的東西意味著什麼
行數和字符數。

734
00:35:39,060 --> 00:35:44,080
錯誤，使用未申報
標識字符串。

735
00:35:44,080 --> 00:35:45,900
你的意思是標準？

736
00:35:45,900 --> 00:35:48,530
>> 所以，不幸的是，鏘
試圖有所幫助。

737
00:35:48,530 --> 00:35:49,850
但是，它是錯的，在這種情況下。

738
00:35:49,850 --> 00:35:52,350
不，鏘，我不是故意的標準IO。

739
00:35:52,350 --> 00:35:54,070
我的意思是在同一行，不錯。

740
00:35:54,070 --> 00:35:56,420
>> 但是，五號線在這裡這一個。

741
00:35:56,420 --> 00:36:00,040
而鏘不
了解S-T-R-I-N-G。

742
00:36:00,040 --> 00:36:04,490
這是一個未聲明的標識符，
一句話，它只是從來沒有見過的。

743
00:36:04,490 --> 00:36:08,730
那是因為C，語言
我們在寫代碼的權利，

744
00:36:08,730 --> 00:36:11,070
不具有的變量稱為串。

745
00:36:11,070 --> 00:36:14,380
>> 這不，在默認情況下，支持
所謂的字符串。

746
00:36:14,380 --> 00:36:19,750
這是一個CS50一塊
行話，但很傳統。

747
00:36:19,750 --> 00:36:21,600
但是，我可以按如下方式解決這個問題。

748
00:36:21,600 --> 00:36:25,090
>> 如果我添加一行代碼
這個程序的頂部，

749
00:36:25,090 --> 00:36:30,890
包括CS50.h，這是另一種文件
裡面的某個地方IDE CS50的某處

750
00:36:30,890 --> 00:36:33,820
在硬盤上，可以這麼說，
在Ubuntu操作系統

751
00:36:33,820 --> 00:36:36,590
我參加競選，這
是的文件

752
00:36:36,590 --> 00:36:41,740
要教工作
系統中的字符串是什麼，只是

753
00:36:41,740 --> 00:36:44,930
像標準io.h是文件
在操作系統中那

754
00:36:44,930 --> 00:36:47,430
要教它是什麼的printf。

755
00:36:47,430 --> 00:36:49,810
>> 事實上，我們會得到
一個非常類似的消息

756
00:36:49,810 --> 00:36:53,600
如果IO也認標準
IO.h並試圖用printf。

757
00:36:53,600 --> 00:36:56,632
所以我要繼續前進，只是
採取控制L到清除我的屏幕。

758
00:36:56,632 --> 00:36:59,340
或者，您可以鍵入清晰，它會
只是清除終端窗口。

759
00:36:59,340 --> 00:37:01,020
但你仍然可以在時間上向後滾動。

760
00:37:01,020 --> 00:37:04,100
>> 而我要重新運行製作繩。

761
00:37:04,100 --> 00:37:06,660
穿過我的手指此時，回車。

762
00:37:06,660 --> 00:37:08,380
哦，我的上帝，它的工作。

763
00:37:08,380 --> 00:37:12,280
它顯示了我很長的神秘命令
這是通過鏘請生成的內容，

764
00:37:12,280 --> 00:37:13,460
但沒有錯誤消息。

765
00:37:13,460 --> 00:37:15,460
所以實現的，即使
你可能會得到完全

766
00:37:15,460 --> 00:37:17,480
此番與
錯誤信息的數量，

767
00:37:17,480 --> 00:37:20,540
也許會是這惱人的級聯
實際上，在那裡鏘不明白

768
00:37:20,540 --> 00:37:22,620
一方面，這意味著它然後
不理解下一個字，

769
00:37:22,620 --> 00:37:23,560
或下一行。

770
00:37:23,560 --> 00:37:25,850
所以它只是扼流圈您的代碼。

771
00:37:25,850 --> 00:37:27,440
但是，該補丁可能很簡單。

772
00:37:27,440 --> 00:37:30,822
所以始終圍繞
輸出的第一行。

773
00:37:30,822 --> 00:37:32,530
如果你不這樣做
理解，只是看

774
00:37:32,530 --> 00:37:35,480
關鍵字，可能是
線索，並且行號，

775
00:37:35,480 --> 00:37:37,650
和字符，其中
這種錯誤可能是。

776
00:37:37,650 --> 00:37:43,328
>> 現在讓我先走，然後鍵入
點斜線，字符串，請輸入。

777
00:37:43,328 --> 00:37:47,340
嗯，這不是打個招呼什麼。

778
00:37:47,340 --> 00:37:49,210
為什麼？

779
00:37:49,210 --> 00:37:51,170
好了，還記得，它在哪兒跑？

780
00:37:51,170 --> 00:37:56,730
>> 它可能停留在此刻
在一個循環中，如果你願意，六線，

781
00:37:56,730 --> 00:37:59,950
因為設計的GET字符串，
通過CS50的工作人員寫的，

782
00:37:59,950 --> 00:38:03,350
字面意思只是坐在
在那裡等著，等著，

783
00:38:03,350 --> 00:38:04,850
並等待一個字符串。

784
00:38:04,850 --> 00:38:06,792
所有我們所說的字符串是人力的投入。

785
00:38:06,792 --> 00:38:07,500
所以，你知道嗎？

786
00:38:07,500 --> 00:38:08,166
讓我先走。

787
00:38:08,166 --> 00:38:11,704
而就心血來潮，讓我
輸入我的名字，大衛進入。

788
00:38:11,704 --> 00:38:13,120
現在我有一個更加動態的程序。

789
00:38:13,120 --> 00:38:14,240
它說，你好大衛。

790
00:38:14,240 --> 00:38:19,280
>> 如果我繼續前進，再次運行此，
讓我試試說Zamila名稱，輸入。

791
00:38:19,280 --> 00:38:20,940
現在我們有一個動態的程序。

792
00:38:20,940 --> 00:38:22,380
我沒有硬編碼的世界。

793
00:38:22,380 --> 00:38:24,760
我沒有硬編碼
名稱或大衛，或Zamila。

794
00:38:24,760 --> 00:38:28,350
>> 現在它更像程序
我們知道，在那裡，如果需要輸入，

795
00:38:28,350 --> 00:38:30,870
它產生的輸出結果略有不同。

796
00:38:30,870 --> 00:38:34,020
現在，這並不是最好的
用戶體驗，或者UX。

797
00:38:34,020 --> 00:38:36,000
我運行該程序。

798
00:38:36,000 --> 00:38:38,830
>> 我不知道我應該
這樣做，除非我其實看

799
00:38:38,830 --> 00:38:40,290
或記住的源代碼。

800
00:38:40,290 --> 00:38:42,640
因此，讓用戶
遇到好一點

801
00:38:42,640 --> 00:38:44,240
用最簡單的事情。

802
00:38:44,240 --> 00:38:47,782
讓我回去到這個
程序，簡單地說printf的。

803
00:38:47,782 --> 00:38:51,870
>> 讓我繼續說名字，結腸，
和一個空間，然後分號。

804
00:38:51,870 --> 00:38:54,170
而只是踢，無隙ñ。

805
00:38:54,170 --> 00:38:55,980
這就是故意的，
因為我不想

806
00:38:55,980 --> 00:38:57,590
提示移動到下一行。

807
00:38:57,590 --> 00:39:01,800
>> 我想，相反，這樣做，使串
重新編譯我的代碼到新機

808
00:39:01,800 --> 00:39:03,980
代碼點斜線的字符串。

809
00:39:03,980 --> 00:39:05,460
啊，這是非常漂亮。

810
00:39:05,460 --> 00:39:08,780
現在，我實際上知道什麼是電腦
要我做的，給它一個名字。

811
00:39:08,780 --> 00:39:13,020
>> 所以我要繼續前進，並鍵入
在羅布，進入，你好，羅布。

812
00:39:13,020 --> 00:39:16,640
因此，實現，這仍然是，在結束
當天，只有一個九行程序。

813
00:39:16,640 --> 00:39:18,090
但是，我們已經採取了這些嬰兒的步驟。

814
00:39:18,090 --> 00:39:21,380
>> 我們寫了一行與我們
熟悉，printf的，世界你好。

815
00:39:21,380 --> 00:39:22,980
然後，我們毀掉了那一點。

816
00:39:22,980 --> 00:39:24,560
而我們實際使用的GET字符串。

817
00:39:24,560 --> 00:39:26,362
而我們在扔一個變量值。

818
00:39:26,362 --> 00:39:29,070
然後我們說乾就幹，提高
它進一步與第三行。

819
00:39:29,070 --> 00:39:32,220
與此迭代過程
寫軟件是真正的關鍵。

820
00:39:32,220 --> 00:39:36,420
在CS50，而在一般的生活，
一般情況下不應坐下，

821
00:39:36,420 --> 00:39:39,800
心中有一個程序，並嘗試寫作
整個該死的事情一下子。

822
00:39:39,800 --> 00:39:43,810
>> 這將不可避免地導致的方式
更多的錯誤比我們自己在這裡看到。

823
00:39:43,810 --> 00:39:47,070
就連我，為了這一天，不斷
讓其他愚蠢的錯誤，

824
00:39:47,070 --> 00:39:50,480
其實更難錯誤
這是很難搞清楚。

825
00:39:50,480 --> 00:39:55,095
但你會犯更多的錯誤越多
行代碼你寫的一次。

826
00:39:55,095 --> 00:39:57,220
所以這種做法，
編寫代碼一點點

827
00:39:57,220 --> 00:40:00,930
你是舒服，編譯
它，運行它，更普遍的測試，

828
00:40:00,930 --> 00:40:04,370
然後移動on--所以就像我們不停
分層和上週層次感，

829
00:40:04,370 --> 00:40:07,190
從建築的東西很
簡單，更複雜的東西，

830
00:40:07,190 --> 00:40:08,200
做同樣的在這裡。

831
00:40:08,200 --> 00:40:11,500
不要坐下來，並嘗試
寫一個完整的問題。

832
00:40:11,500 --> 00:40:13,780
實際上採取這些嬰兒的步驟。

833
00:40:13,780 --> 00:40:18,100
>> 現在，字符串是不是所有的
對自己有用。

834
00:40:18,100 --> 00:40:21,210
實際上，我們應該，理想情況下，喜歡
在我們的工具包東西。

835
00:40:21,210 --> 00:40:23,990
因此，讓我們真正做到這一點。

836
00:40:23,990 --> 00:40:27,900
>> 現在讓我繼續前進，掀起
一個稍微不同的程序。

837
00:40:27,900 --> 00:40:31,320
我們會打電話給這個int.c，為整數。

838
00:40:31,320 --> 00:40:33,870
我要去，同樣，
包括CS550.h。

839
00:40:33,870 --> 00:40:36,060
我將包括標準IO。

840
00:40:36,060 --> 00:40:39,630
而這將是很常見
在類的這些最初幾天。

841
00:40:39,630 --> 00:40:42,050
>> 而我要準備好
我自己用的主要功能。

842
00:40:42,050 --> 00:40:46,370
而現在，而不是得到一個字符串，
讓我們繼續前進，並得到一個int。

843
00:40:46,370 --> 00:40:52,285
讓我們把它叫做我，並把它弄
INT，關閉括號，分號。

844
00:40:52,285 --> 00:40:54,410
現在，讓我們做
東西吧，printf的。

845
00:40:54,410 --> 00:40:59,190
>> 比方說像
你好，反斜杠N，逗號我。

846
00:40:59,190 --> 00:41:03,010
所以，我幾乎模仿
我所做的只是一個剛才。

847
00:41:03,010 --> 00:41:04,660
我有一個佔位符在這裡。

848
00:41:04,660 --> 00:41:08,150
我在這裡用逗號我，因為我想
堵塞我到該佔位符。

849
00:41:08,150 --> 00:41:10,250
>> 因此，讓我們繼續前進，並嘗試
編譯此程序。

850
00:41:10,250 --> 00:41:13,060
該文件稱為int.c.

851
00:41:13,060 --> 00:41:15,920
所以我要說，讓INT輸入。

852
00:41:15,920 --> 00:41:19,420
噢，我的上帝，但沒什麼大不了的，對不對？

853
00:41:19,420 --> 00:41:20,230
有一個錯誤。

854
00:41:20,230 --> 00:41:22,810
>> 有一個語法錯誤
這裡是程序不能

855
00:41:22,810 --> 00:41:28,460
裡面int.c，行編譯
七，性格27，錯誤格式

856
00:41:28,460 --> 00:41:31,400
指定char類型
明星，不管它是什麼。

857
00:41:31,400 --> 00:41:33,020
不過，參數類型為int。

858
00:41:33,020 --> 00:41:36,110
>> 所以在這裡，我們不打算中場休息
雖然今天是很多的材料，

859
00:41:36,110 --> 00:41:38,710
我們要以壓倒你
絕對的C每一個功能，

860
00:41:38,710 --> 00:41:41,070
和編程更一般地，
在短短的這些最初的幾個星期。

861
00:41:41,070 --> 00:41:43,400
因此，有經常將是行話
與你不熟悉。

862
00:41:43,400 --> 00:41:46,350
而且，事實上，焦炭星是什麼
我們要回來

863
00:41:46,350 --> 00:41:47,830
在兩個星期的時間。

864
00:41:47,830 --> 00:41:50,530
>> 但現在，讓我們看看如果我們能
解析是熟悉的字眼。

865
00:41:50,530 --> 00:41:53,750
Formats--所以我們聽到的格式
說明，格式代碼之前。

866
00:41:53,750 --> 00:41:54,840
這是熟悉的。

867
00:41:54,840 --> 00:41:56,840
類型 - 但參數的類型為int。

868
00:41:56,840 --> 00:41:58,980
等一下，我是一個int。

869
00:41:58,980 --> 00:42:02,230
>> 也許％的5事實上
有一些定義的含義。

870
00:42:02,230 --> 00:42:03,230
而且，事實上，它的作用。

871
00:42:03,230 --> 00:42:06,101
一個整數，如果你想
printf的替代它，

872
00:42:06,101 --> 00:42:08,350
你確實有使用
不同的格式說明。

873
00:42:08,350 --> 00:42:09,890
你不會知道這
除非有人告訴你，

874
00:42:09,890 --> 00:42:10,973
或者你已經這樣做。

875
00:42:10,973 --> 00:42:13,490
但是我百分之什麼
可共同使用

876
00:42:13,490 --> 00:42:15,240
在printf中的一個整數堵塞。

877
00:42:15,240 --> 00:42:17,920
您還可以使用百分比
d表示十進制整數。

878
00:42:17,920 --> 00:42:19,490
但我是好的，簡單的在這裡。

879
00:42:19,490 --> 00:42:20,590
因此，我們將與該走了。

880
00:42:20,590 --> 00:42:24,160
>> 現在讓我繼續前進，
重新運行化妝INT，回車。

881
00:42:24,160 --> 00:42:26,328
這是很好的，沒有錯誤。

882
00:42:26,328 --> 00:42:30,260
點斜線int-- OK，不好的用戶體驗，
因為我沒有告訴自己

883
00:42:30,260 --> 00:42:30,760
該怎麼辦。

884
00:42:30,760 --> 00:42:31,426
但是，這很好。

885
00:42:31,426 --> 00:42:32,480
我迅速迎頭趕上。

886
00:42:32,480 --> 00:42:39,260
>> 現在讓我去前進，
鍵入大衛，OK，Zamila，羅布。

887
00:42:39,260 --> 00:42:40,820
好了，所以這是一件好事。

888
00:42:40,820 --> 00:42:44,710
這一次，我使用的功能，
一個拼圖，名為get int類型。

889
00:42:44,710 --> 00:42:47,230
而事實證明out--，我們將
看到這個以後在term--

890
00:42:47,230 --> 00:42:50,730
該工作人員CS50已實施
以這樣的方式獲得的字符串

891
00:42:50,730 --> 00:42:53,350
它只會物理
得到你的字符串。

892
00:42:53,350 --> 00:42:57,340
>> 它已經實施的get int類型
這樣一種方式，它僅將

893
00:42:57,340 --> 00:42:58,590
得到一個整數你。

894
00:42:58,590 --> 00:43:00,830
如果你的人，
不配合，這是

895
00:43:00,830 --> 00:43:03,590
從字面上只是要
說重試，重試，重試，

896
00:43:03,590 --> 00:43:08,200
從字面上坐在那裡循環，直到
你迫使一些神奇的數字，

897
00:43:08,200 --> 00:43:10,670
像50和50打招呼。

898
00:43:10,670 --> 00:43:14,440
>> 或者，如果我們再次運行此
並鍵入42，你好42。

899
00:43:14,440 --> 00:43:18,750
這樣一來，GET INT功能
那一塊拼圖內

900
00:43:18,750 --> 00:43:22,050
足夠的邏輯，足夠的思想，
要弄清楚，什麼是一個字？

901
00:43:22,050 --> 00:43:23,330
什麼是多少？

902
00:43:23,330 --> 00:43:26,165
只有接受，最終的數字。

903
00:43:26,165 --> 00:43:28,690

904
00:43:28,690 --> 00:43:33,230
>> 因此，原來這
是不是所有的表現力。

905
00:43:33,230 --> 00:43:33,910
至今。

906
00:43:33,910 --> 00:43:36,690
所以，耶，我們最後一次
去很快

907
00:43:36,690 --> 00:43:41,320
為實現遊戲和動畫，
在划痕和藝術作品。

908
00:43:41,320 --> 00:43:45,260
而在這裡，我們正在內容
與世界你好，你好和50。

909
00:43:45,260 --> 00:43:46,696
>> 這是不是所有的令人振奮。

910
00:43:46,696 --> 00:43:49,070
而且，事實上，這些前幾
實施例將需要一些時間

911
00:43:49,070 --> 00:43:50,510
在興奮的增產行動。

912
00:43:50,510 --> 00:43:52,854
但是，我們有這麼多
現在控制，實際上。

913
00:43:52,854 --> 00:43:54,770
而且我們要非常
快速啟動分層

914
00:43:54,770 --> 00:43:56,870
這些基本的原語的頂部。

915
00:43:56,870 --> 00:43:59,370
>> 但首先，讓我們了解
什麼限制是。

916
00:43:59,370 --> 00:44:01,620
的東西事實上，人們
刮不容易

917
00:44:01,620 --> 00:44:03,990
讓我們做的是真正審視
引擎蓋下，

918
00:44:03,990 --> 00:44:06,740
並且明白什麼是
計算機是，它能做什麼，

919
00:44:06,740 --> 00:44:08,250
和它的局限性是什麼。

920
00:44:08,250 --> 00:44:11,580
而且，事實上，缺乏的
理解，潛在地，長期

921
00:44:11,580 --> 00:44:15,520
可以導致我們自己的寫作mistakes--
錯誤，寫出不安全的軟件，

922
00:44:15,520 --> 00:44:16,880
以某種方式被黑客攻擊。

923
00:44:16,880 --> 00:44:20,130
>> 因此，讓我們對一些步驟
理解這一點更好一點通過

924
00:44:20,130 --> 00:44:22,710
的，這樣說了，下面的例子。

925
00:44:22,710 --> 00:44:26,550
我要繼續前進，實現
真正的快一個叫做加法程序。

926
00:44:26,550 --> 00:44:28,134
像，讓我們添加一些數字加在一起。

927
00:44:28,134 --> 00:44:30,800
而且我要編寫一些角落
在這裡，只是複製和粘貼

928
00:44:30,800 --> 00:44:33,270
我在那裡之前，恰好
所以我們可以得到更快去。

929
00:44:33,270 --> 00:44:36,090
所以，現在我已經得到了基本的開端
一個叫做加法器程序。

930
00:44:36,090 --> 00:44:37,670
>> 讓我們繼續前進，做到這一點。

931
00:44:37,670 --> 00:44:41,680
我要繼續前進，
比方說和INTx得到得到int類型。

932
00:44:41,680 --> 00:44:42,430
你知道嗎？

933
00:44:42,430 --> 00:44:43,990
讓我們做一個更好的用戶體驗。

934
00:44:43,990 --> 00:44:48,740
>> 所以讓我們只說X是有效的
提示用戶給我們的X.

935
00:44:48,740 --> 00:44:53,600
然後讓我先走，說的printf
怎麼樣y是，這一次期待

936
00:44:53,600 --> 00:44:56,140
從用戶的兩個值。

937
00:44:56,140 --> 00:45:02,759
然後就讓我們繼續前進，
比方說，printf的，x和y的總和為。

938
00:45:02,759 --> 00:45:04,300
現在我不想做百分之秒。

939
00:45:04,300 --> 00:45:12,080
我想做％的我，反斜線
N，再插上總和值。

940
00:45:12,080 --> 00:45:13,620
>> 所以，我怎麼能去這樣做？

941
00:45:13,620 --> 00:45:14,270
你知道嗎？

942
00:45:14,270 --> 00:45:15,840
我知道如何使用變量。

943
00:45:15,840 --> 00:45:18,140
讓我聲明一個新的，INT態。

944
00:45:18,140 --> 00:45:19,770
>> 而我要在這裡採取了猜測。

945
00:45:19,770 --> 00:45:24,470
如果在此等號
語言，也許我可以做X加Y，

946
00:45:24,470 --> 00:45:26,660
只要我結束我的
用分號想？

947
00:45:26,660 --> 00:45:31,170
現在我可以回到這裡了，插上Z，
完成本以為用分號。

948
00:45:31,170 --> 00:45:36,160
而且，我們現在看到的，如果這些
lines-- x的序列是獲得int類型。

949
00:45:36,160 --> 00:45:37,770
Y是獲得int類型。

950
00:45:37,770 --> 00:45:40,980
>> 添加x和y，存儲在值z--
所以，再一次，記住等號

951
00:45:40,980 --> 00:45:41,560
是不相等的。

952
00:45:41,560 --> 00:45:44,100
這是從右到左分配。

953
00:45:44,100 --> 00:45:48,180
讓我們打印出的總和
x和y的是不是字面上Z，

954
00:45:48,180 --> 00:45:49,830
但什麼的Z裡面。

955
00:45:49,830 --> 00:45:53,090
所以，讓我們做加法 - 
不錯，沒有錯誤這一次。

956
00:45:53,090 --> 00:45:56,030
點斜線加法器，輸入，
x被將是1。

957
00:45:56,030 --> 00:45:58,380
>> Y為將是2。

958
00:45:58,380 --> 00:46:01,964
x和y的總和為3。

959
00:46:01,964 --> 00:46:03,130
所以這是一切優秀和良好。

960
00:46:03,130 --> 00:46:06,260
>> 所以，你會想像數學
應該在這樣的程序中工作。

961
00:46:06,260 --> 00:46:07,040
但是，你知道嗎？

962
00:46:07,040 --> 00:46:09,904
這是可變的，行
12，甚至是必要的？

963
00:46:09,904 --> 00:46:12,820
你不需要的習慣得到
只是存儲在變數的事情

964
00:46:12,820 --> 00:46:13,980
只是因為你可以。

965
00:46:13,980 --> 00:46:16,550
並且，實際上，它通常是
認為是不好的設計

966
00:46:16,550 --> 00:46:21,100
如果您正在創建一個變量，叫
中的Z這種情況下，存儲在它的東西，

967
00:46:21,100 --> 00:46:24,390
然後立即
使用它，但從來沒有一次。

968
00:46:24,390 --> 00:46:27,700
為什麼要給東西的名字
像Z如果你從字面上

969
00:46:27,700 --> 00:46:29,770
要使用該
事僅一次，所以

970
00:46:29,770 --> 00:46:32,380
近端創建哪裡
它擺在首位，

971
00:46:32,380 --> 00:46:34,052
如此接近的代碼行的條款？

972
00:46:34,052 --> 00:46:34,760
所以，你知道嗎？

973
00:46:34,760 --> 00:46:37,480
事實證明，C是非常靈活。

974
00:46:37,480 --> 00:46:39,586
如果我真的想
插件值這裡，

975
00:46:39,586 --> 00:46:41,210
我並不需要聲明一個新的變量。

976
00:46:41,210 --> 00:46:44,680
我可以外掛x加
Y，因為C理解

977
00:46:44,680 --> 00:46:46,390
算術和數學運算。

978
00:46:46,390 --> 00:46:50,140
>> 所以，我可以簡單地說，這樣做數學，
X加Y，無論這些值，

979
00:46:50,140 --> 00:46:53,780
堵塞造成
整成字符串。

980
00:46:53,780 --> 00:46:56,730
因此，這可能是，雖然
只有一條線短，

981
00:46:56,730 --> 00:47:01,480
一個更好的設計，更好的節目，
因為有更少的代碼，因此

982
00:47:01,480 --> 00:47:02,921
少我明白。

983
00:47:02,921 --> 00:47:04,920
而且這也只是清潔，
只要我們不是

984
00:47:04,920 --> 00:47:07,620
引進新詞，
新的符號，比如Z，

985
00:47:07,620 --> 00:47:10,510
即使他們真的不
服務太大的目的。

986
00:47:10,510 --> 00:47:15,890
>> 不幸的是，數學不是
所有可靠的時候。

987
00:47:15,890 --> 00:47:18,270
讓我們繼續前進，並做到這一點。

988
00:47:18,270 --> 00:47:21,200
我要繼續前進
現在做到以下幾點。

989
00:47:21,200 --> 00:47:30,650
>> 讓我們做的printf，我百分之，百分之加
我，應該我百分之，反斜線ñ。

990
00:47:30,650 --> 00:47:35,240
而我要做的this-- XYX加y。

991
00:47:35,240 --> 00:47:37,821
所以我只是要改寫
此略有不同在這裡。

992
00:47:37,821 --> 00:47:39,320
我只想做一個快速的健全性檢查。

993
00:47:39,320 --> 00:47:40,986
再次，讓我們不要超前。

994
00:47:40,986 --> 00:47:44,420
做加法，點斜線加法器。

995
00:47:44,420 --> 00:47:47,950
x為1，y為2，1加2是3。

996
00:47:47,950 --> 00:47:48,870
所以這是很好的。

997
00:47:48,870 --> 00:47:52,060
但是，讓我們現在這個複雜
了一下，並創建一個新的文件。

998
00:47:52,060 --> 00:47:56,350
>> 我會打電話給這一個，
說，整型，複數的整數。

999
00:47:56,350 --> 00:47:58,980
讓我先在那裡我是剛才。

1000
00:47:58,980 --> 00:48:00,770
但是，現在讓我們做一些其他的線路。

1001
00:48:00,770 --> 00:48:06,430
讓我繼續前進，做到以下幾點，
printf的，我百分比，減去％的我，

1002
00:48:06,430 --> 00:48:11,959
是我百分之逗號X，逗號YX減Y。

1003
00:48:11,959 --> 00:48:13,750
所以我稍微做
不同的數學存在。

1004
00:48:13,750 --> 00:48:14,624
讓我們做一個又一個。

1005
00:48:14,624 --> 00:48:19,610
所以，我百分之百分之倍
我是百分之一，反斜線ñ。

1006
00:48:19,610 --> 00:48:24,430
讓我們插件x和y，以及x乘以y。

1007
00:48:24,430 --> 00:48:27,530
我們將使用星號上
您的計算機時代。

1008
00:48:27,530 --> 00:48:29,390
>> 你不會用x。 x是
這裡變量名。

1009
00:48:29,390 --> 00:48:31,270
你用乘法的明星。

1010
00:48:31,270 --> 00:48:32,020
讓我們做一個。

1011
00:48:32,020 --> 00:48:37,580
百分之printf的我，分
由百分之一，百分之是我，

1012
00:48:37,580 --> 00:48:43,460
反斜杠ñ。 XY由y--分
所以你用C中的正斜杠

1013
00:48:43,460 --> 00:48:44,502
做除法。

1014
00:48:44,502 --> 00:48:45,460
讓我們做一個其他的。

1015
00:48:45,460 --> 00:48:50,920

1016
00:48:50,920 --> 00:48:58,240
我百分比剩餘，分
由百分之一，百分之是我。

1017
00:48:58,240 --> 00:49:02,550
xy--現在剩下的
是什麼遺留下來的。

1018
00:49:02,550 --> 00:49:05,980
當您嘗試將一
分母變成分子，

1019
00:49:05,980 --> 00:49:08,570
有多少是遺留下來
你不能分裂出去？

1020
00:49:08,570 --> 00:49:10,910
>> 所以是不是真的，
必須地，一個符號

1021
00:49:10,910 --> 00:49:12,470
我們在小學用於此。

1022
00:49:12,470 --> 00:49:16,830
但是，在C.你可以
例如x模y，其中

1023
00:49:16,830 --> 00:49:21,000
在這個context--這個百分號
容易混淆的，當你在裡面

1024
00:49:21,000 --> 00:49:23,170
雙引號的，
裡面的printf，百分比

1025
00:49:23,170 --> 00:49:24,830
用作格式說明。

1026
00:49:24,830 --> 00:49:28,420
>> 當您使用百分比之外
在數學表達式，

1027
00:49:28,420 --> 00:49:32,910
它是模塊化模運算符
arithmetic--我們的目的

1028
00:49:32,910 --> 00:49:36,650
在這裡，只是意味著，什麼是
x的剩餘除以y？

1029
00:49:36,650 --> 00:49:39,130
所以x除以y為x斜線年。

1030
00:49:39,130 --> 00:49:41,220
什麼是x的除以y的餘數？

1031
00:49:41,220 --> 00:49:44,780
它的x模Y，作為一個程序員會說。

1032
00:49:44,780 --> 00:49:51,300
>> 所以，如果我在這裡沒有失誤，讓我
繼續前進，使整型，複數，美觀大方，

1033
00:49:51,300 --> 00:49:53,010
和點斜線整數。

1034
00:49:53,010 --> 00:49:58,270
讓我們繼續前進，
這樣做，比方說，1，10。

1035
00:49:58,270 --> 00:50:01,390
好吧，1加10是11，檢查。

1036
00:50:01,390 --> 00:50:04,240
1減去10為負9，檢查。

1037
00:50:04,240 --> 00:50:06,420
>> 1次10是10，檢查。

1038
00:50:06,420 --> 00:50:10,090
1 10 is--分
OK，我們將跳過一個。

1039
00:50:10,090 --> 00:50:12,480
餘數1除以10為1。

1040
00:50:12,480 --> 00:50:13,680
這是正確的。

1041
00:50:13,680 --> 00:50:15,630
但有一個錯誤在這裡。

1042
00:50:15,630 --> 00:50:18,390
>> 所以，一個我把我的
交出，不正確的。

1043
00:50:18,390 --> 00:50:19,670
我的意思是，這是接近0。

1044
00:50:19,670 --> 00:50:23,670
1除以10，你知道，如果我們
削減一些角落，當然，它是零。

1045
00:50:23,670 --> 00:50:31,050
但它確實應該1/10，
0.1或0.10，0.1000，或等等。

1046
00:50:31,050 --> 00:50:33,600
>> 它真的不應該是零。

1047
00:50:33,600 --> 00:50:38,990
那麼，事實證明，電腦
從字面上做什麼，我們告訴它做的事。

1048
00:50:38,990 --> 00:50:42,460
我們正在做數學一樣x除以y。

1049
00:50:42,460 --> 00:50:47,680
和x和y，每行
代碼前，都是整數。

1050
00:50:47,680 --> 00:50:53,440
>> 此外，第15行，我們都
告訴printf的，嘿嘿，printf的插件

1051
00:50:53,440 --> 00:50:57,230
的整數，插件的整數，
插件的integer--具體

1052
00:50:57,230 --> 00:51:00,580
x，然後y和則x
除以y。 x和y是整數。

1053
00:51:00,580 --> 00:51:02,060
我們是好那裡。

1054
00:51:02,060 --> 00:51:04,250
>> 但是，為x除以x？

1055
00:51:04,250 --> 00:51:09,790
點¯x分由y是應該的，
數學上，1/10，或0.1，

1056
00:51:09,790 --> 00:51:14,600
這是一個實數，一個實數
有潛在的，一個小數點。

1057
00:51:14,600 --> 00:51:16,230
這不是一個整數。

1058
00:51:16,230 --> 00:51:21,290
>> 但是，什麼是最接近
整數到1/10，或0.1？

1059
00:51:21,290 --> 00:51:24,114
是的，這一種是零。

1060
00:51:24,114 --> 00:51:25,030
0.1是這個樣子了。

1061
00:51:25,030 --> 00:51:25,890
和1是本得多。

1062
00:51:25,890 --> 00:51:28,870
所以1/10更接近
0比它為一個。

1063
00:51:28,870 --> 00:51:33,800
>> 所以什麼C是做us--
樣的，因為我們告訴它中場休息

1064
00:51:33,800 --> 00:51:35,600
被截斷的整數。

1065
00:51:35,600 --> 00:51:43,540
它採取的值，而這又是
應該是這樣的0.1000，

1066
00:51:43,540 --> 00:51:44,800
0等等。

1067
00:51:44,800 --> 00:51:48,320
而且這一切截斷
小數點後

1068
00:51:48,320 --> 00:51:50,510
這樣，所有這一切
的東西，因為它沒有

1069
00:51:50,510 --> 00:51:54,910
適合的整數的概念，這
就像負1，0，1的數，

1070
00:51:54,910 --> 00:51:58,830
上下，它拋出了一切
小數點，因為你以後

1071
00:51:58,830 --> 00:52:02,020
不適合小數點
在由定義的整數。

1072
00:52:02,020 --> 00:52:04,290
>> 因此，這裡的答案是零。

1073
00:52:04,290 --> 00:52:05,600
那麼，我們如何解決這個問題？

1074
00:52:05,600 --> 00:52:07,400
我們需要另一種解決方案都在一起。

1075
00:52:07,400 --> 00:52:09,880
我們可以做到這一點，如下所示。

1076
00:52:09,880 --> 00:52:15,820
>> 讓我繼續前進，創造一個新的
文件中，這個叫floats.c。

1077
00:52:15,820 --> 00:52:19,500
這裡保存了
同一目錄下，float.c。

1078
00:52:19,500 --> 00:52:22,360

1079
00:52:22,360 --> 00:52:26,260
讓我繼續和複製
一些早期的代碼。

1080
00:52:26,260 --> 00:52:30,690
>> 但是，而不是領
一個int，讓我們做到這一點。

1081
00:52:30,690 --> 00:52:34,037
給我一個浮點值
名為x。其中，浮點

1082
00:52:34,037 --> 00:52:36,370
值只是從字面上
一些與一個浮點。

1083
00:52:36,370 --> 00:52:37,410
它可以移動到左邊，在右邊。

1084
00:52:37,410 --> 00:52:38,530
這是一個實數。

1085
00:52:38,530 --> 00:52:41,050
>> 讓我沒有打電話
得到INT，但得到浮動，

1086
00:52:41,050 --> 00:52:44,420
這也就是菜單中
在C250庫選項。

1087
00:52:44,420 --> 00:52:46,220
讓我們修改y為float。

1088
00:52:46,220 --> 00:52:48,000
因此，這將成為獲取浮動。

1089
00:52:48,000 --> 00:52:50,620
>> 而現在，我們不希望在整數堵塞。

1090
00:52:50,620 --> 00:52:56,130
事實證明，我們必須使用百分
如欲浮動，浮法％的樓

1091
00:52:56,130 --> 00:52:57,560
現在保存它。

1092
00:52:57,560 --> 00:53:04,220
而現在，手指交叉，使
彩車，美觀大方，點斜線浮動。

1093
00:53:04,220 --> 00:53:07,280
x被打算當1ÿ
將會再次成為10。

1094
00:53:07,280 --> 00:53:11,240
>> 而且，美觀大方，OK我除了是正確的。

1095
00:53:11,240 --> 00:53:13,240
我希望更多的，
但我忘了寫。

1096
00:53:13,240 --> 00:53:16,250
因此，讓我們去解決這個邏輯上的錯誤。

1097
00:53:16,250 --> 00:53:19,280
>> 讓我們繼續前進，抓住以下。

1098
00:53:19,280 --> 00:53:21,080
我們只是做一些複製和粘貼。

1099
00:53:21,080 --> 00:53:23,080
而我要說負。

1100
00:53:23,080 --> 00:53:24,890
>> 而我要說倍。

1101
00:53:24,890 --> 00:53:27,060
而我要說的分歧。

1102
00:53:27,060 --> 00:53:31,240
而且我不會做模，
這是不一樣鍺這裡，

1103
00:53:31,240 --> 00:53:36,690
用f分割，時間plus--
好吧，讓我們再次做到這一點。

1104
00:53:36,690 --> 00:53:47,210
>> 製作花車，點斜線花車，
1，10，還有 - 不錯，沒有，OK。

1105
00:53:47,210 --> 00:53:48,250
所以，我是個白痴。

1106
00:53:48,250 --> 00:53:50,000
因此，這是很常見
在計算機科學

1107
00:53:50,000 --> 00:53:52,780
做出愚蠢的錯誤是這樣的。

1108
00:53:52,780 --> 00:53:56,100
>> 用於教導的目的，
我真正想做的事

1109
00:53:56,100 --> 00:54:00,410
在這裡改變科學
要加，零下，到時候，

1110
00:54:00,410 --> 00:54:04,140
和來劃分，你希望
這個練習過程中發現。

1111
00:54:04,140 --> 00:54:07,700
現在讓我們重新編譯這個
節目，做點斜線浮動。

1112
00:54:07,700 --> 00:54:10,950
>> 而第三次，我們
看它是否符合我的期望。

1113
00:54:10,950 --> 00:54:24,480
1，10，輸入，是的，OK，1.000，
由10.000分，是0.100000。

1114
00:54:24,480 --> 00:54:27,952
而事實證明，我們能控制多少
數字是那些小數點後。

1115
00:54:27,952 --> 00:54:28,660
實際上，我們會的。

1116
00:54:28,660 --> 00:54:29,790
我們會回來這一點。

1117
00:54:29,790 --> 00:54:31,440
>> 但現在，其實數學是正確的。

1118
00:54:31,440 --> 00:54:33,090
那麼，又是什麼這裡的外賣？

1119
00:54:33,090 --> 00:54:36,050
事實證明，在C，有
不僅只是strings--，事實上，

1120
00:54:36,050 --> 00:54:39,120
有沒有真正的，因為我們
添加這些與CS50庫。

1121
00:54:39,120 --> 00:54:40,710
但也有不只是整數。

1122
00:54:40,710 --> 00:54:41,990
>> 也有浮動。

1123
00:54:41,990 --> 00:54:45,810
而事實證明了一堆其他數據
類型也一樣，我們將在不久使用。

1124
00:54:45,810 --> 00:54:49,270
事實證明，如果你想單
字符，而不是一個字符串，

1125
00:54:49,270 --> 00:54:50,610
你可以只使用一個char。

1126
00:54:50,610 --> 00:54:55,350
>> 事實證明，如果你想有一個布爾值，
一個布爾值，只有真或假，

1127
00:54:55,350 --> 00:54:59,840
感謝CS50庫，我們已經
添加到C BOOL數據類型為好。

1128
00:54:59,840 --> 00:55:02,180
但它也存在於
許多其他語言。

1129
00:55:02,180 --> 00:55:07,130
而事實證明，有時你
需要更大的數字則默認情況下都

1130
00:55:07,130 --> 00:55:08,210
與整型和浮點型。

1131
00:55:08,210 --> 00:55:13,590
>> 並且，實際上，雙是一個數字
使用不是32位，但64位。

1132
00:55:13,590 --> 00:55:17,990
和長隆是一個數字，
不使用32位，但64位，

1133
00:55:17,990 --> 00:55:22,190
分別為浮點
值和整數，分別為。

1134
00:55:22,190 --> 00:55:25,780
所以，讓我們現在實際上
看到這個動作。

1135
00:55:25,780 --> 00:55:29,150
>> 我要在這裡繼續
並掀起另一個程序。

1136
00:55:29,150 --> 00:55:35,020
在這裡，我要繼續前進
並且確實包括CS50.h.

1137
00:55:35,020 --> 00:55:37,910
讓我走，包括標準IO.h.

1138
00:55:37,910 --> 00:55:40,320
>> 你會發現什麼
時髦發生在這裡。

1139
00:55:40,320 --> 00:55:43,592
這不是顏色編碼的東西
以同樣的方式，因為它以前那樣。

1140
00:55:43,592 --> 00:55:46,550
而事實證明，那是因為我
沒有給的東西的文件名。

1141
00:55:46,550 --> 00:55:50,270
>> 我會打電話給這一個
sizeof.c，並創下保存。

1142
00:55:50,270 --> 00:55:54,039
並注意發生了什麼我很
白色的代碼針對黑色背景。

1143
00:55:54,039 --> 00:55:55,830
現在，至少有
一些紫色在那裡。

1144
00:55:55,830 --> 00:55:57,490
它是語法高亮。

1145
00:55:57,490 --> 00:56:00,700
>> 這是因為，很簡單，我已經
告訴IDE哪些類型的文件

1146
00:56:00,700 --> 00:56:04,060
它是由給它一個名稱，
具體的文件擴展名。

1147
00:56:04,060 --> 00:56:06,620
現在，讓我們繼續前進，做到這一點。

1148
00:56:06,620 --> 00:56:11,910
我要繼續前進，很
簡單地打印出following--布爾

1149
00:56:11,910 --> 00:56:14,080
是百分之LU。

1150
00:56:14,080 --> 00:56:15,950
>> 我們會回來的
在短短的時刻。

1151
00:56:15,950 --> 00:56:18,840
然後我要去
布爾的打印尺寸。

1152
00:56:18,840 --> 00:56:21,170
而現在，只是為了節省
我有一段時間，我

1153
00:56:21,170 --> 00:56:23,280
要做一個整體
這些一堆一次。

1154
00:56:23,280 --> 00:56:27,620
而且，具體而言，我要去
更改為一個char和char。

1155
00:56:27,620 --> 00:56:30,760
這一次，我要改變
以一張雙人床和一個雙。

1156
00:56:30,760 --> 00:56:34,440
>> 這一次，我要改變
一個浮子和一個浮動。

1157
00:56:34,440 --> 00:56:38,670
這一次，我要去
更改為int和一個int。

1158
00:56:38,670 --> 00:56:41,660
而這一次，我要去
更改為一個很長很長。

1159
00:56:41,660 --> 00:56:43,840
它仍然採取
時間長了，很長很長。

1160
00:56:43,840 --> 00:56:47,572
>> 然後，最後，我放棄
我太多了，字符串。

1161
00:56:47,572 --> 00:56:50,030
事實證明，在C，有
被稱為特殊的運算符

1162
00:56:50,030 --> 00:56:53,260
那大小是字面上
要在運行時，

1163
00:56:53,260 --> 00:56:55,099
告訴我們的大小
這些變量。

1164
00:56:55,099 --> 00:56:56,890
這是一種方式，現在，
我們可以連接回

1165
00:56:56,890 --> 00:57:00,140
上週的討論
數據和代表性。

1166
00:57:00,140 --> 00:57:03,330
>> 讓我繼續前進，編譯
的點斜線大小的尺寸。

1167
00:57:03,330 --> 00:57:04,210
讓我們來看看。

1168
00:57:04,210 --> 00:57:08,210
事實證明，在C，
特別是在CS50 IDE，

1169
00:57:08,210 --> 00:57:11,170
特別是在
操作系統Ubuntu的，

1170
00:57:11,170 --> 00:57:14,100
這是一個64位操作
系統在此情況下，

1171
00:57:14,100 --> 00:57:17,189
一個布爾打算
使用的空間的一個字節。

1172
00:57:17,189 --> 00:57:19,480
這就是大小如何衡量，
不在位，但在字節。

1173
00:57:19,480 --> 00:57:21,690
並且記得，一個字節為8位。

1174
00:57:21,690 --> 00:57:25,030
因此，一個布爾值，即使你
技術上只需要一個0或1，

1175
00:57:25,030 --> 00:57:27,092
這是一個有點浪費
如何我們已經實現了它。

1176
00:57:27,092 --> 00:57:29,800
它實際上是要使用一個整體
byte--因此所有零，也許是

1177
00:57:29,800 --> 00:57:34,050
所有的人，或者類似的東西，
或只是一個1間八位。

1178
00:57:34,050 --> 00:57:37,962
>> 一個char，同時，用於字符
每一樣上週ASCII字符，

1179
00:57:37,962 --> 00:57:39,170
將是一個字符。

1180
00:57:39,170 --> 00:57:45,340
這SYNCHS與我們的觀念
它是不超過256 bits--相當，

1181
00:57:45,340 --> 00:57:48,360
SYNCHS了它是沒有
超過8位，這

1182
00:57:48,360 --> 00:57:50,450
為我們提供了多達256個值。

1183
00:57:50,450 --> 00:57:52,680
雙打算
為8字節或64位。

1184
00:57:52,680 --> 00:57:53,510
>> 一個浮點是4。

1185
00:57:53,510 --> 00:57:54,690
一個int是4。

1186
00:57:54,690 --> 00:57:55,980
長，長為8。

1187
00:57:55,980 --> 00:57:57,716
和一個字符串為8。

1188
00:57:57,716 --> 00:57:58,840
但是不要擔心。

1189
00:57:58,840 --> 00:58:00,340
我們要剝開那層。

1190
00:58:00,340 --> 00:58:02,940
事實證明，字符串可以
超過8個字節。

1191
00:58:02,940 --> 00:58:05,310
>> 而且，事實上，我們已經寫
弦已經，世界你好，

1192
00:58:05,310 --> 00:58:06,700
超過8個字節。

1193
00:58:06,700 --> 00:58:09,270
但是，我們會回來的
在短短的時刻。

1194
00:58:09,270 --> 00:58:12,690
但帶走這裡如下。

1195
00:58:12,690 --> 00:58:18,320
>> 任何計算機中僅具有有限
的存儲器和空間量。

1196
00:58:18,320 --> 00:58:20,860
你只能儲存那麼多
你的Mac或PC上的文件。

1197
00:58:20,860 --> 00:58:26,030
您只能存儲在這麼多程序
RAM運行一次，一定，甚至

1198
00:58:26,030 --> 00:58:29,360
使用虛擬內存，因為
你的內存有限數量。

1199
00:58:29,360 --> 00:58:31,990
>> 而只是為了picture--如果
你從來沒有打開一台筆記本電腦

1200
00:58:31,990 --> 00:58:34,300
或下令額外的內存
對於一台電腦，你

1201
00:58:34,300 --> 00:58:36,670
可能不知道
你的電腦裡面

1202
00:58:36,670 --> 00:58:39,590
是一些看起來
有點像這樣。

1203
00:58:39,590 --> 00:58:43,540
所以，這只是一個普通的公司命名為
至關重要的是，使計算機的RAM。

1204
00:58:43,540 --> 00:58:46,620
和RAM就是程序
而他們正在運行生活。

1205
00:58:46,620 --> 00:58:49,630
>> 所以每次Mac或PC，當您雙擊上
點擊一個程序，它打開了，

1206
00:58:49,630 --> 00:58:51,921
它打開了一些Word文檔
或類似的東西，

1207
00:58:51,921 --> 00:58:54,764
它存儲在臨時
RAM，RAM因為速度更快

1208
00:58:54,764 --> 00:58:56,680
比你的硬盤上，或
你的固態硬盤。

1209
00:58:56,680 --> 00:58:59,600
所以，這只是程序的地方去
當他們正在運行的生活，

1210
00:58:59,600 --> 00:59:01,060
或當正在使用的文件。

1211
00:59:01,060 --> 00:59:03,890
>> 所以，你有事情看起來
這樣你的筆記本電腦裡面，

1212
00:59:03,890 --> 00:59:06,320
或者稍微大一點的東西
裡面的桌面。

1213
00:59:06,320 --> 00:59:10,440
但關鍵是你只有一個
有限數量的這些事情。

1214
00:59:10,440 --> 00:59:14,230
還有的只是一個有限的
硬件坐在這張桌子右邊

1215
00:59:14,230 --> 00:59:14,730
這裡。

1216
00:59:14,730 --> 00:59:18,920
>> 因此，可以肯定，我們不能存儲
無限長的數字。

1217
00:59:18,920 --> 00:59:22,030
而且，然而，如果你想回
小學的時候，有多少位可以

1218
00:59:22,030 --> 00:59:24,400
你有權利
一個小數點？

1219
00:59:24,400 --> 00:59:27,680
對於這個問題，有多少位可以
你有一個小數點左邊？

1220
00:59:27,680 --> 00:59:29,300
真的，無限多的。

1221
00:59:29,300 --> 00:59:33,840
>> 現在，我們人類唯一可能
知道如何發音萬元，

1222
00:59:33,840 --> 00:59:37,990
和十億，萬億，和
萬億和三次方。

1223
00:59:37,990 --> 00:59:42,370
而我推的限制我
understanding--或my--我明白

1224
00:59:42,370 --> 00:59:44,110
數字，但我
數字的發音。

1225
00:59:44,110 --> 00:59:47,720
但他們可以得到無限大
無限多的數字向左

1226
00:59:47,720 --> 00:59:50,050
或小數點的右邊。

1227
00:59:50,050 --> 00:59:53,040
>> 但電腦只有一個
內存量有限，

1228
00:59:53,040 --> 00:59:56,510
晶體管的一個有限數量，一
數量有限的內部燈泡。

1229
00:59:56,510 --> 01:00:00,350
會發生什麼時
您運行的空間？

1230
01:00:00,350 --> 01:00:02,620
換句話說，如果
回想起上週

1231
01:00:02,620 --> 01:00:06,160
當我們談到數字
自己被代表二進制，

1232
01:00:06,160 --> 01:00:08,480
假設我們有
這8位值在這裡。

1233
01:00:08,480 --> 01:00:11,290
>> 而且我們有七個1的和一個0。

1234
01:00:11,290 --> 01:00:13,827
而假設我們想
添加1至這個值。

1235
01:00:13,827 --> 01:00:15,410
這是一個非常大的數字現在。

1236
01:00:15,410 --> 01:00:19,610
>> 這是254，如果我沒有記錯
從上週權的數學。

1237
01:00:19,610 --> 01:00:22,480
但是，如果我改變
最右邊是0到1？

1238
01:00:22,480 --> 01:00:25,800
整數，
當然，成為8個1的。

1239
01:00:25,800 --> 01:00:27,050
所以，我們還是不錯的。

1240
01:00:27,050 --> 01:00:30,204
>> 這可能代表
255，雖然根據上下文

1241
01:00:30,204 --> 01:00:32,120
它實際上代表
負數。

1242
01:00:32,120 --> 01:00:34,240
但更多的是另一次。

1243
01:00:34,240 --> 01:00:37,220
這感覺就像它是關於
高達我可以指望。

1244
01:00:37,220 --> 01:00:38,290
>> 現在，它只有8位。

1245
01:00:38,290 --> 01:00:41,170
而我的Mac，當然，有辦法
內存大於8位。

1246
01:00:41,170 --> 01:00:42,170
但它確實有有限的。

1247
01:00:42,170 --> 01:00:46,230
所以同樣的觀點也適用，即使我們
有更多的人，這些在屏幕上。

1248
01:00:46,230 --> 01:00:50,020
>> 但是，如果你發生了什麼
存儲該號碼，255，

1249
01:00:50,020 --> 01:00:52,290
並且要算1位高？

1250
01:00:52,290 --> 01:00:54,600
你想去從255到256。

1251
01:00:54,600 --> 01:00:58,800
的問題，當然，是如果
從零開始，就像上週算起，

1252
01:00:58,800 --> 01:01:02,670
你不能指望高
256，更不用說257，

1253
01:01:02,670 --> 01:01:05,584
別說258，男因為什麼
當您添加1會怎麼樣？

1254
01:01:05,584 --> 01:01:08,000
如果你做舊小學
方法，你把這裡1，

1255
01:01:08,000 --> 01:01:11,150
然後1加1是2，但是這
真的是零，你扛1，

1256
01:01:11,150 --> 01:01:12,695
扛1，攜帶1。

1257
01:01:12,695 --> 01:01:15,620
所有這些事情，
這些1的，去到零。

1258
01:01:15,620 --> 01:01:20,820
和你風，是的，正如有人
在左手側所指出的，一個1。

1259
01:01:20,820 --> 01:01:25,540
但是，一切都可以
真正看到並裝入內存

1260
01:01:25,540 --> 01:01:30,960
是只有八0年代，這是說
在某些時候，如果你一台電腦，

1261
01:01:30,960 --> 01:01:35,490
試著計數足夠高了，你
要環繞，這似乎

1262
01:01:35,490 --> 01:01:38,850
零，或者甚至負
號，這是大於零甚至更低。

1263
01:01:38,850 --> 01:01:40,260
>> 我們可以樣的看到這一點。

1264
01:01:40,260 --> 01:01:42,900
我要繼續寫
一個真正的快速程序在這裡。

1265
01:01:42,900 --> 01:01:46,690
我要繼續寫
一個叫溢出程序。

1266
01:01:46,690 --> 01:01:52,980
包括CS50.h包括
標準IO.h--哦，

1267
01:01:52,980 --> 01:01:54,730
我真的很想念我的語法高亮。

1268
01:01:54,730 --> 01:01:57,440
因此，讓我們這個保存為overflow.c。

1269
01:01:57,440 --> 01:02:00,084
>> 而現在INT主要void--
過不了多久，我們就會

1270
01:02:00,084 --> 01:02:02,500
回過頭來解釋為什麼
我們繼續寫INT主作廢。

1271
01:02:02,500 --> 01:02:05,080
但現在，我們只是做
它，視之為理所當然。

1272
01:02:05,080 --> 01:02:09,200
讓我們給自己一個int，
並初始化為0。

1273
01:02:09,200 --> 01:02:14,716
>> 讓我們再對INT做我得到zero--
其實，讓我們做一個無限循環

1274
01:02:14,716 --> 01:02:15,590
看看會發生什麼。

1275
01:02:15,590 --> 01:02:25,440
雖然如此，那麼讓我們打印出ñ
是我百分比，反斜線N，插件在正。

1276
01:02:25,440 --> 01:02:30,200
但是，現在，讓我們做n得到n與1。

1277
01:02:30,200 --> 01:02:32,660
>> 因此，換句話說，在每
這個無限循環迭代，

1278
01:02:32,660 --> 01:02:35,550
讓我們取n的值，
並把它加1，然後

1279
01:02:35,550 --> 01:02:37,350
將結果存儲回在正在左側。

1280
01:02:37,350 --> 01:02:40,150
而且，事實上，我們已經看到了語法
微微就是這樣，簡單。

1281
01:02:40,150 --> 01:02:42,730
一個很棒的技巧反而
編寫出這一切的，

1282
01:02:42,730 --> 01:02:45,770
你可以居然說一個n加等於1。

1283
01:02:45,770 --> 01:02:50,480
>> 或者，如果你真的想成為幻想，
你可以說n與加分號。

1284
01:02:50,480 --> 01:02:53,130
但後​​兩個都只是
我們會打電話語法糖

1285
01:02:53,130 --> 01:02:53,790
對的第一件事。

1286
01:02:53,790 --> 01:02:56,456
>> 的第一件事是更加明確，
完全正常的，完全正確的。

1287
01:02:56,456 --> 01:02:58,470
但是，這是比較常見的，我會說。

1288
01:02:58,470 --> 01:03:00,210
所以，我們會為短短的時刻做到這一點。

1289
01:03:00,210 --> 01:03:04,685
>> 現在，讓我們做溢出，這聽起來
而不祥，點斜線溢出。

1290
01:03:04,685 --> 01:03:07,380

1291
01:03:07,380 --> 01:03:12,852
讓我們來看看，正變得越來越蠻大的。

1292
01:03:12,852 --> 01:03:14,310
但我們認為，有多大可能得到ň？

1293
01:03:14,310 --> 01:03:15,870
>> n是一個int。

1294
01:03:15,870 --> 01:03:19,400
我們看到剛才用的大小
例子，一個int是四個字節。

1295
01:03:19,400 --> 01:03:25,070
我們從上週知道，四個字節是
32位，因為8次4，這是32。

1296
01:03:25,070 --> 01:03:26,460
那將是4個十億。

1297
01:03:26,460 --> 01:03:28,802
>> 而我們可達80萬。

1298
01:03:28,802 --> 01:03:31,510
這將永遠採取
數高達我所能。

1299
01:03:31,510 --> 01:03:33,635
所以我要繼續前進，
正如你可能過不了多久，

1300
01:03:33,635 --> 01:03:37,910
並創下控制C--坦言，控制
C，很多，其中對照C一般

1301
01:03:37,910 --> 01:03:39,034
手段取消。

1302
01:03:39,034 --> 01:03:41,200
不幸的是，因為這
在雲中運行時，

1303
01:03:41,200 --> 01:03:44,190
有時雲
吐出了這麼多東西，

1304
01:03:44,190 --> 01:03:47,180
如此多的產量，這將
取一小會兒我輸入

1305
01:03:47,180 --> 01:03:48,630
去雲。

1306
01:03:48,630 --> 01:03:52,240
所以，即使我打
對照C幾秒鐘前，

1307
01:03:52,240 --> 01:03:56,110
這絕對是側
無限循環的效果。

1308
01:03:56,110 --> 01:03:59,070
>> 因此在這種情況下，我們
要離開的是。

1309
01:03:59,070 --> 01:04:02,050
而且我們要增加另一個
在這裡的終端窗口

1310
01:04:02,050 --> 01:04:06,186
與加，這當然不
這樣，因為它仍在思考。

1311
01:04:06,186 --> 01:04:08,310
讓我們繼續前進，並
多了幾分合理性。

1312
01:04:08,310 --> 01:04:10,768
>> 我要繼續前進，做
這只有有限多次。

1313
01:04:10,768 --> 01:04:13,047
讓我們用一個for循環，
我前面提到。

1314
01:04:13,047 --> 01:04:13,630
我們開工吧。

1315
01:04:13,630 --> 01:04:16,430
再給我一次變量int我得到0。

1316
01:04:16,430 --> 01:04:20,430
我不到，比方說，64個I ++。

1317
01:04:20,430 --> 01:04:27,010
現在讓我繼續和打印
出n是百分之一，逗號ñ。

1318
01:04:27,010 --> 01:04:30,547
然後N--這仍然是
要採取永遠。

1319
01:04:30,547 --> 01:04:31,130
我們開工吧。

1320
01:04:31,130 --> 01:04:33,620
>> n得到n次2。

1321
01:04:33,620 --> 01:04:37,140
或者我們可以被看中
做次等於2。

1322
01:04:37,140 --> 01:04:40,120
但是，讓我們只說ñ
等於本身，乘以2。

1323
01:04:40,120 --> 01:04:42,321
換句話說，在該
程序的新版本，

1324
01:04:42,321 --> 01:04:44,820
我不想永遠等待
從像80萬至4十億。

1325
01:04:44,820 --> 01:04:46,070
就讓我們這種過度使用。

1326
01:04:46,070 --> 01:04:47,920
>> 讓我們實際上每次加倍ñ。

1327
01:04:47,920 --> 01:04:50,660
其中，召回，加倍是
對面有當然的。

1328
01:04:50,660 --> 01:04:53,035
和而上週我們有
重複的事情，並再次，

1329
01:04:53,035 --> 01:04:55,200
又一次，超快速，
加倍必將

1330
01:04:55,200 --> 01:05:01,080
1讓我們以最大的可能
值，我們可以用一個int計數。

1331
01:05:01,080 --> 01:05:02,750
>> 因此，讓我們做的正是這一點。

1332
01:05:02,750 --> 01:05:04,720
我們再回過頭來此不久。

1333
01:05:04,720 --> 01:05:07,180
但是這又好比
在從無到有的重複塊。

1334
01:05:07,180 --> 01:05:08,600
你會不久使用。

1335
01:05:08,600 --> 01:05:13,170
>> 這也就意味著，從零計數
達，但不相等，為64。

1336
01:05:13,170 --> 01:05:17,285
而在此每次迭代
循環，只是不停地增加i。

1337
01:05:17,285 --> 01:05:21,990
所以，我++  - 這一般結構
第7行僅僅是一個超級常見的方式

1338
01:05:21,990 --> 01:05:25,290
重複的部分線路
代碼，一些次數。

1339
01:05:25,290 --> 01:05:26,362
哪行代碼？

1340
01:05:26,362 --> 01:05:28,570
這些大括號，如你
可能從現在收集，

1341
01:05:28,570 --> 01:05:29,780
手段，做到以下幾點。

1342
01:05:29,780 --> 01:05:32,510
>> 它像划痕，當
它具有黃色塊

1343
01:05:32,510 --> 01:05:35,680
和其他顏色的那種
擁抱或擁抱其他塊。

1344
01:05:35,680 --> 01:05:37,750
這就是那些花
括號在這裡做。

1345
01:05:37,750 --> 01:05:43,200
所以，如果我得到了我的語法right--你
可以看到C表示胡蘿蔔符號

1346
01:05:43,200 --> 01:05:45,706
這就是我多少次
試圖解決這個問題。

1347
01:05:45,706 --> 01:05:48,330
因此，讓我們擺脫的那一個
乾脆，並關閉該窗口。

1348
01:05:48,330 --> 01:05:49,520
我們將使用新的。

1349
01:05:49,520 --> 01:05:54,980
使溢出，點斜杠
溢出，進入，所有的權利，

1350
01:05:54,980 --> 01:05:56,090
它看起來壞在第一。

1351
01:05:56,090 --> 01:05:59,200
但是，讓我們向後滾動的時候，
因為我這樣做64次。

1352
01:05:59,200 --> 01:06:01,700
>> 和在第一時間通知，n是1。

1353
01:06:01,700 --> 01:06:06,110
第二次，n為2，
然後4，然後按8，然後16。

1354
01:06:06,110 --> 01:06:12,450
並盡快似乎
我得到低於約1十億，

1355
01:06:12,450 --> 01:06:15,800
如果我再翻一番它，
應該給我兩十億。

1356
01:06:15,800 --> 01:06:17,980
但事實證明，這是
正確的風口浪尖上。

1357
01:06:17,980 --> 01:06:21,930
>> 所以它實際上溢出
1十億一個int

1358
01:06:21,930 --> 01:06:26,514
大致2負
十億，因為一個整數，

1359
01:06:26,514 --> 01:06:28,430
不像我們的數字
上週假設，

1360
01:06:28,430 --> 01:06:31,397
既可以是正和負
在現實中，並在一台計算機。

1361
01:06:31,397 --> 01:06:33,730
而這些，所以至少一個
位被有效被盜。

1362
01:06:33,730 --> 01:06:37,190
所以，我們真的只有31位，
或2十億可能的值。

1363
01:06:37,190 --> 01:06:41,220
>> 但就目前而言，外賣相當
簡單地說，不管這些數字

1364
01:06:41,220 --> 01:06:45,280
而無論數學，
有壞事發生，最終，

1365
01:06:45,280 --> 01:06:49,980
因為最終你試圖
重排的位太多次。

1366
01:06:49,980 --> 01:06:54,060
你有效地都去
1對也許所有0，或者

1367
01:06:54,060 --> 01:06:57,260
只是一些其他的模式，它
清楚地，根據上下文，

1368
01:06:57,260 --> 01:06:59,342
可以理解為一個負數。

1369
01:06:59,342 --> 01:07:02,300
因此它似乎最高的I
可以在這個特定的程序計數

1370
01:07:02,300 --> 01:07:04,210
只有大約1十億。

1371
01:07:04,210 --> 01:07:05,760
但是，這裡有一個部分解決方案。

1372
01:07:05,760 --> 01:07:06,480
你知道嗎？

1373
01:07:06,480 --> 01:07:10,600
>> 讓我從改變
詮釋一個很長很長。

1374
01:07:10,600 --> 01:07:13,633
讓我繼續在這裡
和say--我將有

1375
01:07:13,633 --> 01:07:15,290
要改變這種為unsigned long。

1376
01:07:15,290 --> 01:07:19,860
或者，讓我們來看看，我從來不記得自己。

1377
01:07:19,860 --> 01:07:22,920
>> 讓我們繼續前進，使溢出。

1378
01:07:22,920 --> 01:07:24,860
不，這不是它，LLD，謝謝。

1379
01:07:24,860 --> 01:07:26,430
所以有時鏘能有所幫助。

1380
01:07:26,430 --> 01:07:30,550
我不記得是什麼格式
說明是一個很長很長。

1381
01:07:30,550 --> 01:07:31,950
>> 但是，事實上，鏘告訴我的。

1382
01:07:31,950 --> 01:07:34,570
綠色是某種好，
仍然意味著你犯了一個錯誤。

1383
01:07:34,570 --> 01:07:36,190
它是猜，我的意思是LLD。

1384
01:07:36,190 --> 01:07:41,750
>> 因此，讓我把它的建議，長
長十進制數，保存。

1385
01:07:41,750 --> 01:07:46,190
讓我重新運行它，點
斜線溢出，回車。

1386
01:07:46,190 --> 01:07:48,020
現在什麼是酷是這樣的。

1387
01:07:48,020 --> 01:07:52,140
>> 如果我回卷的時候，我們還是開始
在同一place--計數1，2，4，

1388
01:07:52,140 --> 01:07:53,220
8，16。

1389
01:07:53,220 --> 01:07:57,860
請注意，我們得到了所有的
一路攀升至1十億。

1390
01:07:57,860 --> 01:08:00,070
但是，我們安全到達2十億。

1391
01:08:00,070 --> 01:08:04,300
>> 然後我們4十億，
然後從8十億，17個十億。

1392
01:08:04,300 --> 01:08:06,340
而我們走的更高，而且
越來越高。

1393
01:08:06,340 --> 01:08:08,740
最終，這也算休息。

1394
01:08:08,740 --> 01:08:12,350
>> 最終，用長長的，
它是64位的值，而不是

1395
01:08:12,350 --> 01:08:16,660
一個32位的值，如果算上
過高，環繞0。

1396
01:08:16,660 --> 01:08:19,410
在這種情況下，我們碰巧
結束了一個負數。

1397
01:08:19,410 --> 01:08:20,550
>> 因此，這是一個問題。

1398
01:08:20,550 --> 01:08:23,439
而事實證明，這
問題是，不是所有的神秘。

1399
01:08:23,439 --> 01:08:26,060
即使我刻意
這些錯誤引起的，

1400
01:08:26,060 --> 01:08:29,149
事實證明，我們那種看到它的全部
我們，或者至少我們中的一些周圍的人。

1401
01:08:29,149 --> 01:08:31,939
>> 因此，在樂高星球大戰，如果
你曾經玩過的遊戲，

1402
01:08:31,939 --> 01:08:36,830
事實證明，你可以去周圍
打破東西在世界樂高，

1403
01:08:36,830 --> 01:08:39,640
和收集硬幣，本質上。

1404
01:08:39,640 --> 01:08:42,200
如果你打過
這個遊戲了太多的時間，

1405
01:08:42,200 --> 01:08:45,630
因為這無名的個人
在這裡做到了，總數

1406
01:08:45,630 --> 01:08:49,700
你可以收集硬幣
是，它似乎，4個十億。

1407
01:08:49,700 --> 01:08:51,240
>> 現在，它的實際四捨五入。

1408
01:08:51,240 --> 01:08:53,239
所以LEGO試圖
讓事情變得人性化。

1409
01:08:53,239 --> 01:08:56,779
他們沒有做到這一點正是2
32次冪，每上週。

1410
01:08:56,779 --> 01:08:58,310
但4個十億是一個道理。

1411
01:08:58,310 --> 01:09:01,979
看來，基於該信息，
這LEGO，該公司的

1412
01:09:01,979 --> 01:09:05,624
使這個實際的軟件，決定
該硬幣的最大數目

1413
01:09:05,624 --> 01:09:07,540
用戶可以積累
確實是，4個十億，

1414
01:09:07,540 --> 01:09:15,069
因為他們選擇在自己的代碼
使用不是很長很長，很顯然，

1415
01:09:15,069 --> 01:09:19,140
但僅僅是一個整數，一個無符號
整數，只有一個正整數，其

1416
01:09:19,140 --> 01:09:21,089
最大值大約是這一點。

1417
01:09:21,089 --> 01:09:22,380
那麼，這裡的另一個有趣的。

1418
01:09:22,380 --> 01:09:26,500
所以在遊戲中文明，這
有些人可能很熟悉，與

1419
01:09:26,500 --> 01:09:29,660
原來，幾年前有
在本場比賽由此錯誤

1420
01:09:29,660 --> 01:09:31,750
如果你所扮演的角色
甘地在比賽中，

1421
01:09:31,750 --> 01:09:37,020
代替他的是非常和平，
反而是令人難以置信的，令人難以置信

1422
01:09:37,020 --> 01:09:39,399
攻擊性，在某些情況下。

1423
01:09:39,399 --> 01:09:43,529
特別是，方式文明
作品是，如果您的播放器，

1424
01:09:43,529 --> 01:09:47,680
採取民主，你
侵略性成績獲得

1425
01:09:47,680 --> 01:09:51,130
由兩個，所以減去遞減
減，再減去負。

1426
01:09:51,130 --> 01:09:53,569
>> 所以你減去2從
實際的迭代。

1427
01:09:53,569 --> 01:09:59,650
不幸的是，如果你的是迭代
最初1，你從中減去2

1428
01:09:59,650 --> 01:10:02,050
採用經過民主
甘地在這裡可能

1429
01:10:02,050 --> 01:10:05,200
這樣做，是因為他很passive--
1對侵略性的規模。

1430
01:10:05,200 --> 01:10:07,830
但是，如果他採取民主，那麼
他去從1到1負。

1431
01:10:07,830 --> 01:10:14,470
>> 不幸的是，它們是
使用無符號數，

1432
01:10:14,470 --> 01:10:18,400
這意味著他們對待甚至是負
數字，好像他們是積極的。

1433
01:10:18,400 --> 01:10:22,780
而且事實證明，
負1陽性當量，

1434
01:10:22,780 --> 01:10:26,480
在典型的計算機程序，為255。

1435
01:10:26,480 --> 01:10:30,250
因此，如果採用甘地
，因此具有民主

1436
01:10:30,250 --> 01:10:35,470
他的侵略性評分下降，
它實際上來臨時，以255

1437
01:10:35,470 --> 01:10:38,470
而讓他最
侵略性的比賽。

1438
01:10:38,470 --> 01:10:39,930
所以，你可以在此Google了。

1439
01:10:39,930 --> 01:10:42,380
而且，的確是一個
意外編程錯誤，

1440
01:10:42,380 --> 01:10:46,010
但是這相當進入
絕殺至今。

1441
01:10:46,010 --> 01:10:47,360
>> 這是所有的樂趣和可愛。

1442
01:10:47,360 --> 01:10:50,760
更可怕的是，當實際
真實世界的設備，而不是遊戲，

1443
01:10:50,760 --> 01:10:51,820
有這些相同的錯誤。

1444
01:10:51,820 --> 01:10:57,500
事實上，就在一年前的一篇文章來了
更多關於波音787夢想飛機。

1445
01:10:57,500 --> 01:10:59,850
>> 和製品在第一
讀取一目了然有點神秘。

1446
01:10:59,850 --> 01:11:04,480
但它說，這是一家軟件
在波音公司的脆弱性

1447
01:11:04,480 --> 01:11:07,790
新型787夢想飛機具有
可能造成飛行員

1448
01:11:07,790 --> 01:11:10,220
失去控制
飛機，可能

1449
01:11:10,220 --> 01:11:14,750
在飛行中，美國聯邦航空局官員
告誡航空公司最近。

1450
01:11:14,750 --> 01:11:17,520
這是確定
一個模型787

1451
01:11:17,520 --> 01:11:22,770
已通電飛機
連續248天

1452
01:11:22,770 --> 01:11:27,880
可能會失去所有的交流電流，交流，
電功率，由於發電機

1453
01:11:27,880 --> 01:11:31,892
控制單元，同時GCUs，
進入故障安全模式。

1454
01:11:31,892 --> 01:11:32,850
這是一種失去我的。

1455
01:11:32,850 --> 01:11:38,390
但備忘錄說，好了，現在我得到的，
條件是由軟件引起的

1456
01:11:38,390 --> 01:11:41,590
專櫃內部
發電機控制

1457
01:11:41,590 --> 01:11:47,860
單元後，將溢出
248天連續功率。

1458
01:11:47,860 --> 01:11:50,070
頒發本
注意防止損失

1459
01:11:50,070 --> 01:11:52,300
所有交流電
功率，這可能導致

1460
01:11:52,300 --> 01:11:53,980
在飛機的失控。

1461
01:11:53,980 --> 01:11:58,380
>> 所以，從字面上看，有一些整數，
或者一些等價的數據類型，

1462
01:11:58,380 --> 01:12:00,960
在軟件被使用
在實際的飛機

1463
01:12:00,960 --> 01:12:03,756
如果你保持你的飛機
足夠長的時間，這顯然

1464
01:12:03,756 --> 01:12:06,880
可如果你只是運行情況
他們不斷地從不拔下

1465
01:12:06,880 --> 01:12:09,810
你的飛機，現在看來，還是
讓其電池不行了，

1466
01:12:09,810 --> 01:12:12,840
將最終計數和向上，
和起來，向上，及以上，和向上。

1467
01:12:12,840 --> 01:12:15,150
>> 並且，按質，一
內存數量有限

1468
01:12:15,150 --> 01:12:18,880
會溢出，回滾到
零或者一些負值，

1469
01:12:18,880 --> 01:12:22,920
其中的一個副作用是
實得嚇人現實

1470
01:12:22,920 --> 01:12:26,970
這架飛機可能需要
必須重新啟動，有效，

1471
01:12:26,970 --> 01:12:30,290
也可能下降，更糟糕的，因為它飛起來。

1472
01:12:30,290 --> 01:12:32,230
所以這類問題
仍然伴隨著我們，

1473
01:12:32,230 --> 01:12:36,130
even--這是一個2015年的文章，
所有的更可怕

1474
01:12:36,130 --> 01:12:39,100
當你不一定
理解，欣賞，或預期

1475
01:12:39,100 --> 01:12:41,640
這些類型的錯誤。

1476
01:12:41,640 --> 01:12:45,030
>> 因此，原來還有另一個
有關數據表示壞事。

1477
01:12:45,030 --> 01:12:50,080
事實證明，即使花車
樣的缺陷，因為花車也是如此，

1478
01:12:50,080 --> 01:12:54,440
我提出的是32位的，或
也許64如果你使用雙。

1479
01:12:54,440 --> 01:12:56,070
但是，這仍然是有限的。

1480
01:12:56,070 --> 01:13:00,070
>> 而美中不足的是，如果你能
把數的無限數量

1481
01:13:00,070 --> 01:13:02,460
小數點後，
沒有辦法，你

1482
01:13:02,460 --> 01:13:05,690
可以代表所有可能的
我們被教導號碼

1483
01:13:05,690 --> 01:13:07,990
在小學可以在世界上存在。

1484
01:13:07,990 --> 01:13:11,870
一台電腦，從本質上講，有
選擇這些數字的一個子集

1485
01:13:11,870 --> 01:13:13,200
準確地表示。

1486
01:13:13,200 --> 01:13:15,450
>> 現在，該計算機可以
輪也許一點點，

1487
01:13:15,450 --> 01:13:20,900
並且可以讓你大致店
任何號碼，你有可能會需要。

1488
01:13:20,900 --> 01:13:23,940
但是，僅僅憑直覺，如果你
有比特的有限數目，

1489
01:13:23,940 --> 01:13:27,560
你只能他們重排
在很多方面有限。

1490
01:13:27,560 --> 01:13:29,570
所以，你不可能
用有限數量的

1491
01:13:29,570 --> 01:13:32,880
比特置換，
零和一的模式，

1492
01:13:32,880 --> 01:13:35,940
代表無限
號的數目，

1493
01:13:35,940 --> 01:13:40,370
這表明計算機可能
很好是對我們撒謊的時候。

1494
01:13:40,370 --> 01:13:41,770
>> 事實上，讓我們做到這一點。

1495
01:13:41,770 --> 01:13:44,239
讓我重新回到CS50 IDE。

1496
01:13:44,239 --> 01:13:46,030
讓我繼續前進，
創建一個小程序

1497
01:13:46,030 --> 01:13:50,940
叫不精確，就表明
電腦的確都是不精確的。

1498
01:13:50,940 --> 01:13:54,910
>> 讓我繼續前進，並與開始
一些代碼來自之前，

1499
01:13:54,910 --> 01:13:56,830
現在只要做到以下幾點。

1500
01:13:56,830 --> 01:14:06,640
我要繼續做的printf，百分比
樓反斜線N，1除以10。

1501
01:14:06,640 --> 01:14:10,430
換句話說，讓我們在更深的下潛
到1/10，象1和除以10。

1502
01:14:10,430 --> 01:14:12,760
當然，一個計算機可以代表1/10。

1503
01:14:12,760 --> 01:14:16,620
>> 因此，讓我們繼續前進，使不精確。

1504
01:14:16,620 --> 01:14:17,390
讓我們來看看。

1505
01:14:17,390 --> 01:14:19,210
格式指定double類型。

1506
01:14:19,210 --> 01:14:21,160
但參數的類型為int。

1507
01:14:21,160 --> 01:14:22,040
這是怎麼回事？

1508
01:14:22,040 --> 01:14:24,970
>> 呵呵，有意思，所以這是一個
從課前的教訓。

1509
01:14:24,970 --> 01:14:29,050
我說，哎，電腦展
我百分之F A浮動。

1510
01:14:29,050 --> 01:14:31,200
但我給它2個整數。

1511
01:14:31,200 --> 01:14:34,120
所以，事實證明，我可以修復
這幾種方式。

1512
01:14:34,120 --> 01:14:41,430
>> 我只是把一成1.0，和
10到10.0，這，的確，

1513
01:14:41,430 --> 01:14:45,390
有轉換的效果
他們進入floats--仍有望

1514
01:14:45,390 --> 01:14:46,180
相同的號碼。

1515
01:14:46,180 --> 01:14:48,880
或者，它原來有什麼東西
我們不久再見到。

1516
01:14:48,880 --> 01:14:50,170
你可以投中的數字。

1517
01:14:50,170 --> 01:14:52,880
>> 您可以使用此括號
表達式，你可以說，

1518
01:14:52,880 --> 01:14:55,560
哎，電腦，藉此
10，我知道是一個int。

1519
01:14:55,560 --> 01:14:57,660
但是對待它，請
就好像它是一個浮動。

1520
01:14:57,660 --> 01:14:59,680
但這種感覺過於複雜。

1521
01:14:59,680 --> 01:15:02,040
>> 對於我們今天的目的，
我們只是從字面上

1522
01:15:02,040 --> 01:15:05,700
讓他們浮點值
帶小數點，就像這樣。

1523
01:15:05,700 --> 01:15:10,060
讓我繼續前進並重新運行，使
不精確，好，點斜線

1524
01:15:10,060 --> 01:15:11,870
不精確，進入。

1525
01:15:11,870 --> 01:15:13,990
OK，我們正在尋找好的。

1526
01:15:13,990 --> 01:15:21,194
>> 1除以10，按照我的
蘋果在這裡，的確是0.100000。

1527
01:15:21,194 --> 01:15:24,360
現在，我學會了上小學的時候有
應該是0的無限數量。

1528
01:15:24,360 --> 01:15:26,151
因此，讓我們至少嘗試
看到其中的一些。

1529
01:15:26,151 --> 01:15:29,770
事實證明，printf的是一個小
票友仍然比我們一直在使用。

1530
01:15:29,770 --> 01:15:33,890
原來你沒有指定
剛剛％的F或只是我百分比。

1531
01:15:33,890 --> 01:15:36,830
實際上，你可以指定
這裡的一些控制選項。

1532
01:15:36,830 --> 01:15:39,470
>> 具體來說，我要去
就是說，哎，printf的，

1533
01:15:39,470 --> 01:15:42,660
居然告訴我10小數點。

1534
01:15:42,660 --> 01:15:43,820
所以它看起來有點怪異。

1535
01:15:43,820 --> 01:15:45,845
但是你說個百分點，
點，多少號

1536
01:15:45,845 --> 01:15:47,970
你想以後看到
小數點，以及則f

1537
01:15:47,970 --> 01:15:51,340
平，只是因為這是
文件說什麼。

1538
01:15:51,340 --> 01:15:53,080
讓我繼續前進並保存。

1539
01:15:53,080 --> 01:15:55,460
>> 並注意過，我越來越
厭倦了重複輸入的事情。

1540
01:15:55,460 --> 01:15:58,900
所以我只是設置和
在這裡我的鑰匙向下箭頭。

1541
01:15:58,900 --> 01:16:01,710
如果我繼續打了，你
可以看到所有的命令

1542
01:16:01,710 --> 01:16:04,090
我犯了，或不正確的。

1543
01:16:04,090 --> 01:16:07,630
>> 而我現在要繼續前進，
沒有實際使用，顯然。

1544
01:16:07,630 --> 01:16:14,416
讓不精確，點
斜線imprecision--所以

1545
01:16:14,416 --> 01:16:16,290
我所教
小學檢查出來。

1546
01:16:16,290 --> 01:16:22,010
即使我把它打印到10進制
地方，它確實是0.10000。

1547
01:16:22,010 --> 01:16:22,840
但是，你知道嗎？

1548
01:16:22,840 --> 01:16:24,150
>> 讓我們有點貪心。

1549
01:16:24,150 --> 01:16:26,990
比方說，比如，告訴我55
小數點後點。

1550
01:16:26,990 --> 01:16:29,160
讓我們真的採取這種
劃出來兜風。

1551
01:16:29,160 --> 01:16:34,170
讓我用make改造它
不精確，點斜線，不精確。

1552
01:16:34,170 --> 01:16:35,390
>> 現在我們開始。

1553
01:16:35,390 --> 01:16:37,420
你的童年是一個謊言。

1554
01:16:37,420 --> 01:16:51,410
很顯然，1除以10的確
0.100000000000000005551115123--

1555
01:16:51,410 --> 01:16:52,740
>> 到底是怎麼回事？

1556
01:16:52,740 --> 01:16:56,360
那麼，事實證明，如果你種
看遠遠不夠出在底層

1557
01:16:56,360 --> 01:16:58,950
這表示
數目，它實際上

1558
01:16:58,950 --> 01:17:03,400
是不完全的1/10，或0.1和
無限數量的零。

1559
01:17:03,400 --> 01:17:04,630
現在，這是為什麼？

1560
01:17:04,630 --> 01:17:09,250
>> 那麼，即使這是一個簡單的
我們人類數，1除以10，

1561
01:17:09,250 --> 01:17:13,910
它仍然是無限多的一個
數字，我們能想到的。

1562
01:17:13,910 --> 01:17:17,490
但是，一台電腦只能代表
有限多個這樣的數字。

1563
01:17:17,490 --> 01:17:21,710
所以，有效的，是什麼
電腦正顯示出我們的是其最接近

1564
01:17:21,710 --> 01:17:25,940
近似​​與數
我們願意相信是1/10，

1565
01:17:25,940 --> 01:17:30,760
還是真的0.10000循環往復。

1566
01:17:30,760 --> 01:17:33,425
>> 而，雖然，這是
盡可能接近，因為它可以得到的。

1567
01:17:33,425 --> 01:17:35,300
而且，事實上，如果你看看
引擎蓋下，

1568
01:17:35,300 --> 01:17:40,050
因為我們在這裡通過看
小數點後55位，

1569
01:17:40,050 --> 01:17:42,990
實際上我們看到的現實。

1570
01:17:42,990 --> 01:17:45,610
現在，順便說一句，如果你
見過movie--

1571
01:17:45,610 --> 01:17:48,780
大多數人可能haven't--
但超人3若干年前，

1572
01:17:48,780 --> 01:17:52,500
理查德·普賴爾基本上是利用這
現實中，他的公司竊取了很多

1573
01:17:52,500 --> 01:17:56,500
便士的分數和分數的，
因為我記得在company--，

1574
01:17:56,500 --> 01:18:00,210
它是一個while--基本上是
扔掉任何東西，不適合

1575
01:18:00,210 --> 01:18:01,790
進入仙的概念。

1576
01:18:01,790 --> 01:18:04,480
>> 但是，如果你把所有這些
很小，很小，很小的數字再次，

1577
01:18:04,480 --> 01:18:07,960
又一次，又一次，你可以象在
他的情況下，賺錢的一個良好的數額。

1578
01:18:07,960 --> 01:18:11,010
>> 那同樣的想法被扯掉
更近，但還是現在年紀大了

1579
01:18:11,010 --> 01:18:13,500
電影，叫辦公空間，
凡在那部電影的傢伙，

1580
01:18:13,500 --> 01:18:16,501
做同樣的事情，搞砸了
徹底，結束了太多

1581
01:18:16,501 --> 01:18:17,666
錢在自己的銀行賬戶。

1582
01:18:17,666 --> 01:18:18,800
這一切都是很可疑。

1583
01:18:18,800 --> 01:18:22,290
但在一天結束時，
不精確就在我們身邊。

1584
01:18:22,290 --> 01:18:25,240
>> 並且，也可以是
令人震驚的情況。

1585
01:18:25,240 --> 01:18:28,590
原來，3超人
和辦公空間之外，還有

1586
01:18:28,590 --> 01:18:31,460
可能有一些非常現實的
世界後果

1587
01:18:31,460 --> 01:18:35,290
不精確的現實
數據的表示

1588
01:18:35,290 --> 01:18:37,770
即使我們人類
這一天不一定

1589
01:18:37,770 --> 01:18:41,230
理解，以及我們應該，
或記住盡可能多我們應該。

1590
01:18:41,230 --> 01:18:45,950
而且，事實上，以下剪輯是
從看一些很真實的世界

1591
01:18:45,950 --> 01:18:50,730
如果你會發生什麼後果
不欣賞的不精確性

1592
01:18:50,730 --> 01:18:53,065
在數字代表出現。

1593
01:18:53,065 --> 01:18:54,300
>> [視頻回放]

1594
01:18:54,300 --> 01:18:58,620
>> -Computers，我們都逐漸接受
經常令人沮喪的問題，

1595
01:18:58,620 --> 01:19:03,310
去them--錯誤，病毒，
和軟件故障，

1596
01:19:03,310 --> 01:19:06,130
對於小的價格支付
為方便。

1597
01:19:06,130 --> 01:19:10,800
但是，在高科技和高速度
軍事和航天計劃的應用，

1598
01:19:10,800 --> 01:19:15,800
最小的問題即可
被放大成災難。

1599
01:19:15,800 --> 01:19:21,900
>> 在1996年6月4日，科學家們準備
發射無人阿麗亞娜5型火箭。

1600
01:19:21,900 --> 01:19:24,220
它攜帶的科學
衛星設計

1601
01:19:24,220 --> 01:19:27,600
建立精確如何
地球的磁場相互作用

1602
01:19:27,600 --> 01:19:30,410
與太陽風。

1603
01:19:30,410 --> 01:19:33,800
火箭是專為
歐洲航天局，

1604
01:19:33,800 --> 01:19:37,370
並從其設施升空
在法屬圭亞那的海岸。

1605
01:19:37,370 --> 01:19:40,540
>> -At約37秒進
飛行中，他們首先

1606
01:19:40,540 --> 01:19:42,270
注意到某些事正在錯誤的。

1607
01:19:42,270 --> 01:19:45,250
噴嘴在被旋轉
某種意義上說，他們實在不應該。

1608
01:19:45,250 --> 01:19:49,580
大約40秒後進入飛行，
顯然，車輛遇到了麻煩。

1609
01:19:49,580 --> 01:19:51,850
>> 那就是當他們做了
決定摧毀它。

1610
01:19:51,850 --> 01:19:55,780
該範圍內的安全官員，與
巨大的膽量，按下按鈕，

1611
01:19:55,780 --> 01:20:01,150
炸毀了火箭，它可能前
成為對公眾安全造成危害。

1612
01:20:01,150 --> 01:20:04,060
>>  - 這是處女
阿麗亞娜5的航程。

1613
01:20:04,060 --> 01:20:06,960
而其毀滅了
地方，因為一個缺陷

1614
01:20:06,960 --> 01:20:08,822
嵌入火箭的軟件。

1615
01:20:08,822 --> 01:20:11,280
在阿麗亞娜-The問題是
認為有許多

1616
01:20:11,280 --> 01:20:13,600
需要64位來表示。

1617
01:20:13,600 --> 01:20:16,590
他們想轉換
它的16位數字。

1618
01:20:16,590 --> 01:20:18,610
他們假定
數字是永遠不會

1619
01:20:18,610 --> 01:20:23,980
是非常大的，大多數的那些
在一個64位的號碼數字是零。

1620
01:20:23,980 --> 01:20:25,440
但他們錯了。

1621
01:20:25,440 --> 01:20:28,060
>> -The無力之一
軟件程序接受

1622
01:20:28,060 --> 01:20:32,510
所產生的那種數
另一種是在失敗的根源。

1623
01:20:32,510 --> 01:20:37,350
軟件開發已經成為一個
的新技術非常昂貴的部分。

1624
01:20:37,350 --> 01:20:41,140
該阿麗亞娜火箭已經很
成功，那麼多的軟件

1625
01:20:41,140 --> 01:20:44,550
創造了它也是
在阿麗亞娜5中。

1626
01:20:44,550 --> 01:20:50,940
>> -The根本的問題是，阿麗亞娜
5增快，加速快。

1627
01:20:50,940 --> 01:20:54,450
而且軟件早已不是
佔了點。

1628
01:20:54,450 --> 01:20:58,060
>> 火箭-The破壞
是一個巨大的金融災難，

1629
01:20:58,060 --> 01:21:01,790
一切緣於一分鐘，軟件錯誤。

1630
01:21:01,790 --> 01:21:04,210
但是，這不是第一次
實時數據轉換問題

1631
01:21:04,210 --> 01:21:07,820
一直困擾現代火箭技術。

1632
01:21:07,820 --> 01:21:11,050
>> -in 1991年，開始時
第一次海灣戰爭中，

1633
01:21:11,050 --> 01:21:13,570
愛國者導彈
經歷了類似的一種

1634
01:21:13,570 --> 01:21:15,800
數轉換的問題。

1635
01:21:15,800 --> 01:21:19,090
而作為一個結果，28人，
28名美國士兵，

1636
01:21:19,090 --> 01:21:22,080
被打死，約
100人受傷，

1637
01:21:22,080 --> 01:21:25,780
當愛國者，這本來是
防止傳入的飛毛腿導彈，

1638
01:21:25,780 --> 01:21:28,830
沒有發射導彈。

1639
01:21:28,830 --> 01:21:34,670
>>  - 當伊拉克入侵科威特和美國
在1991年年初推出沙漠風暴

1640
01:21:34,670 --> 01:21:38,780
愛國者導彈部署
保護沙特阿拉伯和以色列

1641
01:21:38,780 --> 01:21:42,230
伊拉克飛毛腿導彈襲擊。

1642
01:21:42,230 --> 01:21:46,810
愛國者是美國中程
表面空氣系統，製造

1643
01:21:46,810 --> 01:21:48,770
由雷神公司。

1644
01:21:48,770 --> 01:21:55,340
>> 愛國者攔截-The大小
本身是關於約20英尺長。

1645
01:21:55,340 --> 01:21:58,230
它重約2000磅。

1646
01:21:58,230 --> 01:22:02,320
同時還可以進行約一個彈頭，
我認為這是大約150磅。

1647
01:22:02,320 --> 01:22:06,930
和彈頭本身
高爆發力，這

1648
01:22:06,930 --> 01:22:10,330
周圍有碎片。

1649
01:22:10,330 --> 01:22:14,680
彈頭的外殼是
旨在像大號鉛彈。

1650
01:22:14,680 --> 01:22:17,110
>> -The導彈進行
百分之四的容器中，

1651
01:22:17,110 --> 01:22:20,130
和由半拖車運輸。

1652
01:22:20,130 --> 01:22:27,930
>> -The愛國者反導彈系統
追溯到現在至少有20年。

1653
01:22:27,930 --> 01:22:31,420
它最初的設計
作為防空導彈

1654
01:22:31,420 --> 01:22:33,720
擊落敵人的飛機。

1655
01:22:33,720 --> 01:22:37,500
在第一次海灣戰爭，
當戰爭來了，

1656
01:22:37,500 --> 01:22:42,745
陸軍想用它來
擊落飛毛腿導彈，而不是飛機。

1657
01:22:42,745 --> 01:22:46,620
>> 伊拉克空軍
沒有那麼多的問題。

1658
01:22:46,620 --> 01:22:49,670
但軍隊是擔心飛毛腿導彈。

1659
01:22:49,670 --> 01:22:53,170
所以他們試圖
升級愛國者。

1660
01:22:53,170 --> 01:22:55,800
>> -Intercepting敵人
在導彈5馬赫旅行

1661
01:22:55,800 --> 01:22:58,830
將要被足夠的挑戰性。

1662
01:22:58,830 --> 01:23:01,490
但是，當愛國者
被送往投入服務，

1663
01:23:01,490 --> 01:23:05,860
陸軍不知道的
伊拉克的修改，使得

1664
01:23:05,860 --> 01:23:08,930
他們的飛毛腿導彈幾乎是不可能的打擊。

1665
01:23:08,930 --> 01:23:13,740
>>  - 什麼事是飛毛腿導彈的
要來的是不穩定的。

1666
01:23:13,740 --> 01:23:14,692
他們在晃動。

1667
01:23:14,692 --> 01:23:17,910
這樣做的原因是
伊拉克人，為了

1668
01:23:17,910 --> 01:23:21,280
獲得600公里
出300公里

1669
01:23:21,280 --> 01:23:24,700
中程導彈，重了
從前面彈頭。

1670
01:23:24,700 --> 01:23:26,390
他們提出的彈頭更輕。

1671
01:23:26,390 --> 01:23:30,330
>> 所以，現在的愛國者
苦思的飛毛腿。

1672
01:23:30,330 --> 01:23:33,230
和大部分的時間，該
絕大多數的時間，

1673
01:23:33,230 --> 01:23:35,940
它只是由飛毛腿飛。

1674
01:23:35,940 --> 01:23:40,260
一旦愛國者系統運營商
實現了愛國者錯過了目標，

1675
01:23:40,260 --> 01:23:44,690
他們引爆愛國者的彈頭
以避免如果可能的人員傷亡

1676
01:23:44,690 --> 01:23:47,570
被允許倒在地上。

1677
01:23:47,570 --> 01:23:51,790
>>  - 那是大多數人所看到的，
在天空中那些大火球，

1678
01:23:51,790 --> 01:23:57,550
和誤解成
飛毛腿彈頭的攔截。

1679
01:23:57,550 --> 01:23:59,630
>>  - 雖然在夜間
天空，出現了愛國者

1680
01:23:59,630 --> 01:24:03,370
要成功地
摧毀飛毛腿導彈，在宰赫蘭

1681
01:24:03,370 --> 01:24:06,360
有可能是沒有錯
關於它的性能。

1682
01:24:06,360 --> 01:24:10,970
目前，愛國者的雷達系統
失去了進入的飛毛腿的軌道，

1683
01:24:10,970 --> 01:24:13,721
從不因推出
到一個軟件缺陷。

1684
01:24:13,721 --> 01:24:17,090

1685
01:24:17,090 --> 01:24:21,940
這是誰首先發現了以色列人
的時間越長該系統上，

1686
01:24:21,940 --> 01:24:25,690
越大時間差異
成為，由於嵌入的時鐘

1687
01:24:25,690 --> 01:24:27,810
在系統的計算機。

1688
01:24:27,810 --> 01:24:31,210
>>  - 關於前兩週
悲劇發生在宰赫蘭

1689
01:24:31,210 --> 01:24:33,770
以色列人報
國防部

1690
01:24:33,770 --> 01:24:35,590
該系統正在失去的時間。

1691
01:24:35,590 --> 01:24:38,360
約8小時運行之後，
他們注意到，該系統

1692
01:24:38,360 --> 01:24:40,720
變得明顯不準確。

1693
01:24:40,720 --> 01:24:44,900
國防部回應
告訴所有的愛國者電池

1694
01:24:44,900 --> 01:24:47,950
不離開系統
上很長一段時間。

1695
01:24:47,950 --> 01:24:52,160
他們從來不說什麼了很久was--
八小時，10小時，千小時。

1696
01:24:52,160 --> 01:24:54,360
沒有人知道。

1697
01:24:54,360 --> 01:24:56,380
>> -The愛國者電池
駐紮在軍營

1698
01:24:56,380 --> 01:25:01,350
在宰赫蘭和內部缺陷
時鐘已經超過100小時一直在

1699
01:25:01,350 --> 01:25:04,670
2月25日的夜晚。

1700
01:25:04,670 --> 01:25:08,917
>>  - 它跟踪的時間精度
約一秒鐘的十分之一。

1701
01:25:08,917 --> 01:25:11,000
現在，第二的第十
是一個有趣的數字，

1702
01:25:11,000 --> 01:25:14,920
因為它不能表示
二進制準確地說，這

1703
01:25:14,920 --> 01:25:19,820
意味著它不能精確地表達
在任何現代數字計算機。

1704
01:25:19,820 --> 01:25:21,540
很難相信。

1705
01:25:21,540 --> 01:25:24,210
>> 但是使用此作為一個例子。

1706
01:25:24,210 --> 01:25:26,540
讓我們來數三分之一。

1707
01:25:26,540 --> 01:25:30,350
三分之一不能
十進制明確地表達。

1708
01:25:30,350 --> 01:25:35,080
三分之一是0.333
持續了無窮大。

1709
01:25:35,080 --> 01:25:39,480
>> 有沒有辦法做到這一點與
絕對精度十進制。

1710
01:25:39,480 --> 01:25:42,560
這正是那種問題
這發生在愛國者。

1711
01:25:42,560 --> 01:25:47,100
時間越長，系統運行時，
更糟糕的時間誤差成了。

1712
01:25:47,100 --> 01:25:51,890
>>  - 後運行100小時後，
在時間誤差僅為約三分之一

1713
01:25:51,890 --> 01:25:53,600
的第二。

1714
01:25:53,600 --> 01:25:57,210
但是，在一個目標的角度
導彈在5馬赫旅行，

1715
01:25:57,210 --> 01:26:01,710
它導致了跟踪
超過600米錯誤。

1716
01:26:01,710 --> 01:26:05,120
這將是一個致命的錯誤
對於什麼戰士

1717
01:26:05,120 --> 01:26:11,940
碰巧是飛毛腿發射是
通過預警衛星檢測

1718
01:26:11,940 --> 01:26:15,860
他們知道，是飛毛腿
未來在他們的大方向。

1719
01:26:15,860 --> 01:26:18,320
他們不知道有人來了。

1720
01:26:18,320 --> 01:26:21,250
>>  - 它現在要由雷達
愛國者系統的組成部分

1721
01:26:21,250 --> 01:26:26,190
衛冕達蘭定位和保持
跟踪來襲的敵方導彈。

1722
01:26:26,190 --> 01:26:27,609
>> -The雷達是非常聰明的。

1723
01:26:27,609 --> 01:26:29,650
它實際上是將跟踪
飛毛腿的位置，

1724
01:26:29,650 --> 01:26:33,350
然後預測出可能
將是下一個時間的雷達發送

1725
01:26:33,350 --> 01:26:34,420
脈衝出來。

1726
01:26:34,420 --> 01:26:36,110
這是所謂的範圍內門。

1727
01:26:36,110 --> 01:26:40,660
>>  - 然後，一旦愛國者
決定時間已夠

1728
01:26:40,660 --> 01:26:45,450
傳遞回去檢查下
此檢測物體的位置，

1729
01:26:45,450 --> 01:26:46,600
它可以追溯到。

1730
01:26:46,600 --> 01:26:51,650
因此，當它回到了錯
地方，然後看見沒有對象。

1731
01:26:51,650 --> 01:26:55,160
和它決定，沒有
對象，這是一個錯誤的檢測，

1732
01:26:55,160 --> 01:26:56,930
和下降的軌道。

1733
01:26:56,930 --> 01:27:00,030
>> -The傳入飛毛腿消失
從雷達屏幕上。

1734
01:27:00,030 --> 01:27:03,260
幾秒鐘後，它
撞上軍營。

1735
01:27:03,260 --> 01:27:09,150
飛毛腿打死28，並且是最後一個
在第一次海灣戰爭中開火。

1736
01:27:09,150 --> 01:27:14,960
>> 可悲的是，更新的軟件
抵達宰赫蘭的第二天。

1737
01:27:14,960 --> 01:27:17,930
該軟件有缺陷
得到修復，閉合

1738
01:27:17,930 --> 01:27:22,806
在陷入困境的一章
愛國者導彈的歷史。

1739
01:27:22,806 --> 01:27:23,729
>> [視頻回放]

1740
01:27:23,729 --> 01:27:26,520
DAVID J. MALAN：所以這是所有
說，溢出的這些問題

1741
01:27:26,520 --> 01:27:28,860
和不精確都太真實了。

1742
01:27:28,860 --> 01:27:29,920
那麼我們是如何來到這裡的？

1743
01:27:29,920 --> 01:27:31,895
我們開始只是談論的printf。

1744
01:27:31,895 --> 01:27:34,270
再次，此函數
打印一些東西到屏幕上，

1745
01:27:34,270 --> 01:27:36,450
我們隨後推出
幾個其他功能

1746
01:27:36,450 --> 01:27:37,945
從所謂CS50的庫。

1747
01:27:37,945 --> 01:27:39,910
我們將繼續
看到這些在適當的時候。

1748
01:27:39,910 --> 01:27:43,760
而我們，尤其是使用的GET字符串，
並獲得INT，現在還可以獲得浮動，

1749
01:27:43,760 --> 01:27:47,410
還有一些仍然會遇到我們
不久使用自己。

1750
01:27:47,410 --> 01:27:50,220
>> 但有時，有
我們已經看到有必要

1751
01:27:50,220 --> 01:27:53,520
存儲什麼這些功能的手背？

1752
01:27:53,520 --> 01:27:55,920
他們一方面我們回到一個字符串，
或int或浮動。

1753
01:27:55,920 --> 01:27:59,070
有時，我們需要把該
字符串或int，或float地方。

1754
01:27:59,070 --> 01:28:03,100
>> 並存儲那些東西，只是召回
就像在刮，我們有變數。

1755
01:28:03,100 --> 01:28:06,260
但與划痕，
在C中有實際的類型

1756
01:28:06,260 --> 01:28:08,530
variables--數據
類型，更generally--

1757
01:28:08,530 --> 01:28:11,640
其中，一個字符串，一個int，一個
浮動，而這些人依然。

1758
01:28:11,640 --> 01:28:15,321
>> 所以，當我們用C聲明變量，
我們必須聲明的數據類型。

1759
01:28:15,321 --> 01:28:17,820
這不是我們
必須在學期過去了做

1760
01:28:17,820 --> 01:28:19,810
因為我們過渡到其他語言。

1761
01:28:19,810 --> 01:28:22,610
但現在，我們確實需要
到預先先驗，

1762
01:28:22,610 --> 01:28:27,370
解釋計算機是什麼類型
可變的，我們希望它給我們。

1763
01:28:27,370 --> 01:28:30,290
>> 現在，同時，進行打印
這些類型的數據類型，

1764
01:28:30,290 --> 01:28:32,570
我們要告訴printf的什麼期望。

1765
01:28:32,570 --> 01:28:35,450
我們看到字符串％的S，
和我百分之整數，

1766
01:28:35,450 --> 01:28:36,790
和其他幾個人了。

1767
01:28:36,790 --> 01:28:40,237
而這些僅僅是要求
對於視覺呈現

1768
01:28:40,237 --> 01:28:41,070
這些信息。

1769
01:28:41,070 --> 01:28:45,080
>> 而且每個這些其實是可以
參數化或以某種方式調整，

1770
01:28:45,080 --> 01:28:48,370
如果你想進一步控制
你得到的輸出類型。

1771
01:28:48,370 --> 01:28:52,604
而且，事實上，它不僅證明
有反斜杠n，則新行。

1772
01:28:52,604 --> 01:28:55,520
還有別的東西叫反斜線
r代表回車，這

1773
01:28:55,520 --> 01:28:57,360
更類似於一個
老同學打字機，

1774
01:28:57,360 --> 01:29:00,690
並且還視窗使用多年。

1775
01:29:00,690 --> 01:29:02,690
>> 有製表符反斜杠噸。

1776
01:29:02,690 --> 01:29:06,170
事實證明，如果你想
字符串裡面的雙引號，

1777
01:29:06,170 --> 01:29:08,000
我們已經使用召回
雙引號雙

1778
01:29:08,000 --> 01:29:10,900
引用在左側和右
迄今為止，我們的字符串結束。

1779
01:29:10,900 --> 01:29:12,420
這似乎混淆的東西。

1780
01:29:12,420 --> 01:29:15,503
>> 如果你想要把雙引號中
一個string--，實際上中間，

1781
01:29:15,503 --> 01:29:16,670
它是混亂看到的。

1782
01:29:16,670 --> 01:29:20,120
所以你要逃跑，所以
說話，用的東西一個雙引號

1783
01:29:20,120 --> 01:29:21,860
像，從字面上看，反斜杠雙引號。

1784
01:29:21,860 --> 01:29:23,230
而且還有一些其他的還在。

1785
01:29:23,230 --> 01:29:27,540
我們將看到更多的這些
在不久的實際使用。

1786
01:29:27,540 --> 01:29:30,930
>> 現在讓我們從過渡
數據和代表性，

1787
01:29:30,930 --> 01:29:33,820
和算術運算符，所有
這給了我們一些建築

1788
01:29:33,820 --> 01:29:35,070
與玩積木。

1789
01:29:35,070 --> 01:29:37,481
但現在，讓我們實際上給
我們的詞彙的其餘部分

1790
01:29:37,481 --> 01:29:39,230
我們已經完成了
上週與划痕

1791
01:29:39,230 --> 01:29:42,350
通過一些其他的考慮看看
在C--結構不是所有的人。

1792
01:29:42,350 --> 01:29:44,680
但是我們的想法
就要看真的只是

1793
01:29:44,680 --> 01:29:48,610
要強調從翻譯
一種語言，從無到有，到另一個，C.

1794
01:29:48,610 --> 01:29:51,470
>> 隨著時間的推移，我們會拿起
更多的工具，我們的工具包，

1795
01:29:51,470 --> 01:29:52,820
可以這麼說，語​​法上。

1796
01:29:52,820 --> 01:29:57,190
而且，事實上，你會看到的想法
現在從上週相當熟悉。

1797
01:29:57,190 --> 01:29:58,200
因此，讓我們做到這一點。

1798
01:29:58,200 --> 01:30:01,870
>> 讓我們繼續前進，並掀起程序
實際使用一些表情，

1799
01:30:01,870 --> 01:30:03,720
布爾表達式。

1800
01:30:03,720 --> 01:30:05,810
讓我繼續在這裡
並創建一個新的文件。

1801
01:30:05,810 --> 01:30:09,090
我會打電話給這個condition.c。

1802
01:30:09,090 --> 01:30:12,350
>> 讓我繼續前進，
包括CS50庫。

1803
01:30:12,350 --> 01:30:15,640
讓我繼續前進，包括
標準IO.h我們的功能，

1804
01:30:15,640 --> 01:30:17,690
和printf，更分別。

1805
01:30:17,690 --> 01:30:21,900
讓我給自己的樣板
INT主要無效，其解釋我們

1806
01:30:21,900 --> 01:30:23,360
回來的未來。

1807
01:30:23,360 --> 01:30:26,820
>> 現在讓我先走，並把
我通過get INT一個int。

1808
01:30:26,820 --> 01:30:28,970
然後讓我繼續前進，做到這一點。

1809
01:30:28,970 --> 01:30:33,150
我想說，如果我是less--讓我們
正，負區分

1810
01:30:33,150 --> 01:30:34,260
或零值。

1811
01:30:34,260 --> 01:30:39,630
>> 所以，如果我是小於零，讓我
只是有這個計劃簡單地說，

1812
01:30:39,630 --> 01:30:45,370
負，反斜線N，否則
如果i大於零。

1813
01:30:45,370 --> 01:30:50,030
現在，我當然會說
printf的正面，反斜線ñ。

1814
01:30:50,030 --> 01:30:53,690
然後，其他if--我能做到這一點。

1815
01:30:53,690 --> 01:30:56,410
>> 如果我等於0，我可以做的。

1816
01:30:56,410 --> 01:30:58,840
但我在做被
至少一個錯誤了。

1817
01:30:58,840 --> 01:31:02,480
回想一下，等號
不相等的，因為我們人類知道這一點。

1818
01:31:02,480 --> 01:31:04,010
>> 但它的賦值操作符。

1819
01:31:04,010 --> 01:31:08,640
而我們不希望在採取0
權利，把它放在我的左邊。

1820
01:31:08,640 --> 01:31:14,810
因此，為了避免這種混亂，或
也許是平等的濫用簽收，

1821
01:31:14,810 --> 01:31:17,740
人類決定幾年前
在許多編程語言

1822
01:31:17,740 --> 01:31:21,000
當您要檢查等式
左和右之間，

1823
01:31:21,000 --> 01:31:22,635
你實際使用等於等號。

1824
01:31:22,635 --> 01:31:24,010
所以，你打等號的兩倍。

1825
01:31:24,010 --> 01:31:28,600
當你想從分配權
到左，你用一個等號。

1826
01:31:28,600 --> 01:31:32,360
因此，我們可以做別的this--
如果我等於為零。

1827
01:31:32,360 --> 01:31:34,710
>> 然後，我可以去
打開我的大括號，

1828
01:31:34,710 --> 01:31:39,087
並說，printf的0，反斜線N，完成。

1829
01:31:39,087 --> 01:31:41,170
但要記住，這些是如何
在岔路口能正常工作。

1830
01:31:41,170 --> 01:31:42,836
而且，真的，只是想想邏輯。

1831
01:31:42,836 --> 01:31:44,510
i是一個數字。

1832
01:31:44,510 --> 01:31:46,320
這是一個整數，具體。

1833
01:31:46,320 --> 01:31:51,600
這意味著它將會是少
大於0，或者大於0，或者0大。

1834
01:31:51,600 --> 01:31:54,600
因此，有一種這樣
隱含的默認情況。

1835
01:31:54,600 --> 01:31:57,920
>> 因此，我們可以，就像
劃傷，免除了其他如，

1836
01:31:57,920 --> 01:31:58,747
而只是說別的。

1837
01:31:58,747 --> 01:32:00,830
從邏輯上講，如果您在
程序員知道，只有

1838
01:32:00,830 --> 01:32:04,635
三個存儲成一個
情況可能fall--第一，

1839
01:32:04,635 --> 01:32:06,510
第二，或第三
在這個case--不

1840
01:32:06,510 --> 01:32:10,100
懶得添加額外的精度
和附加​​邏輯那裡。

1841
01:32:10,100 --> 01:32:12,690
只是繼續用
默認情況下，這裡的人。

1842
01:32:12,690 --> 01:32:14,950
>> 現在，讓我們繼續
保存此之後，使

1843
01:32:14,950 --> 01:32:18,760
條件斜線點條件 - 
不是一個偉大的用戶界面，

1844
01:32:18,760 --> 01:32:21,914
因為我不惹得
用戶，正如我前面提到的。

1845
01:32:21,914 --> 01:32:22,580
但是，這很好。

1846
01:32:22,580 --> 01:32:23,454
我們將保持簡單。

1847
01:32:23,454 --> 01:32:24,890
讓我們嘗試數字42。

1848
01:32:24,890 --> 01:32:26,240
這就是積極的。

1849
01:32:26,240 --> 01:32:29,120
讓我們嘗試次數
負42負。

1850
01:32:29,120 --> 01:32:31,244
>> 讓我們嘗試值0。

1851
01:32:31,244 --> 01:32:32,160
而且，事實上，它的工作原理。

1852
01:32:32,160 --> 01:32:36,900
現在，你將與之前看到的問題
長，檢測的事三次，

1853
01:32:36,900 --> 01:32:37,980
可能不充分。

1854
01:32:37,980 --> 01:32:40,438
你可能想測試一些
更大的數字，一些規模較小的

1855
01:32:40,438 --> 01:32:43,520
數字，一些角落情況下，如
我們會來描述它們。

1856
01:32:43,520 --> 01:32:45,500
>> 但現在，這是一個
很簡單的程序。

1857
01:32:45,500 --> 01:32:48,160
而且我敢肯定，在邏輯上，
它分為三種情況。

1858
01:32:48,160 --> 01:32:52,360
而且，事實上，即使我們只是
集中在潛在的缺點

1859
01:32:52,360 --> 01:32:56,480
不精確和溢出，在
現實中，許多的CS50的問題，

1860
01:32:56,480 --> 01:32:59,000
我們不會擔心
一下，所有的時間，

1861
01:32:59,000 --> 01:33:02,050
溢出的這些問題，
不精確的，因為，事實上，在C，

1862
01:33:02,050 --> 01:33:04,889
它實際上不是所有的
容易避免這些東西。

1863
01:33:04,889 --> 01:33:07,180
如果你想計數
大，大，大，

1864
01:33:07,180 --> 01:33:10,510
事實證明，有技術，您
可以使用，常累及東西叫做

1865
01:33:10,510 --> 01:33:14,240
圖書館的館藏代碼，即
其他人寫的，你可以使用，

1866
01:33:14,240 --> 01:33:16,910
和其他語言如
Java和其他人，其實

1867
01:33:16,910 --> 01:33:18,800
讓人們更方便
數甚至更高。

1868
01:33:18,800 --> 01:33:22,810
因此，它確實是有些危險
您使用的語言的函數。

1869
01:33:22,810 --> 01:33:25,710
並在未來幾週內，我們將
看有多危險真的Ç

1870
01:33:25,710 --> 01:33:27,950
可如果不正確地使用它。

1871
01:33:27,950 --> 01:33:30,610
但是從那裡，並與
蟒蛇，和JavaScript，將

1872
01:33:30,610 --> 01:33:35,620
我們圖層上的某些額外的保護，
並運行這些風險較少。

1873
01:33:35,620 --> 01:33:38,820
>> 因此，讓多一點
有趣的邏輯在我們的節目。

1874
01:33:38,820 --> 01:33:42,110
因此，讓我繼續創建
一個叫做邏輯程序

1875
01:33:42,110 --> 01:33:46,804
只是這樣我就可以玩一些
實際的邏輯，logical.c。

1876
01:33:46,804 --> 01:33:49,870
我只是複製和粘貼一些
從早期的代碼，所以我回來

1877
01:33:49,870 --> 01:33:52,950
這個漂亮的出發點。

1878
01:33:52,950 --> 01:33:56,980
>> 讓我這個時候做字符C.我
打算給它的C名稱

1879
01:33:56,980 --> 01:34:01,510
只是因為它的傳統，
獲取來自用戶的字符。

1880
01:34:01,510 --> 01:34:03,730
讓我們假裝
我實施的一部分

1881
01:34:03,730 --> 01:34:07,130
該室的方案，刪除
在此之前，程序提示用戶

1882
01:34:07,130 --> 01:34:08,400
刪除文件。

1883
01:34:08,400 --> 01:34:09,750
我們怎麼能做到這一點？

1884
01:34:09,750 --> 01:34:14,090
>> 我想說的是，如果C等於
等於，報價引文結束，

1885
01:34:14,090 --> 01:34:19,304
Y，然後我要去承擔
該用戶已經是選擇。

1886
01:34:19,304 --> 01:34:20,470
我只是要打印的是。

1887
01:34:20,470 --> 01:34:22,440
如果它被實際編寫
拆除程序，

1888
01:34:22,440 --> 01:34:24,420
我們可以刪除文件
有更多行的代碼。

1889
01:34:24,420 --> 01:34:25,461
但我們會保持它的簡單。

1890
01:34:25,461 --> 01:34:28,950

1891
01:34:28,950 --> 01:34:34,250
>> 如果C等於等於N--
現在這裡，我會說，

1892
01:34:34,250 --> 01:34:35,980
用戶必須意味著沒有。

1893
01:34:35,980 --> 01:34:37,360
然後別的，你知道嗎？

1894
01:34:37,360 --> 01:34:39,200
我不知道還有什麼
用戶將要輸入。

1895
01:34:39,200 --> 01:34:41,533
所以，我只是說，
這是一個錯誤，無論

1896
01:34:41,533 --> 01:34:43,070
他或她實際鍵入。

1897
01:34:43,070 --> 01:34:44,180
>> 那麼是什麼回事？

1898
01:34:44,180 --> 01:34:47,530
有一個根本的區別
與我在過去所做的那樣。

1899
01:34:47,530 --> 01:34:52,300
雙引號，雙引號，雙
報價和，但是，單引號

1900
01:34:52,300 --> 01:34:53,170
單引號。

1901
01:34:53,170 --> 01:34:55,860
原來，在C，當
你想要寫一個字符串，

1902
01:34:55,860 --> 01:34:59,680
你使用雙引號，就像我們已經
使用所有這一次的printf了。

1903
01:34:59,680 --> 01:35:05,030
>> 但是，如果你要處理的只是一個
單個字符，所謂字符，

1904
01:35:05,030 --> 01:35:06,780
那麼你實際使用單引號。

1905
01:35:06,780 --> 01:35:08,450
你們當中誰已設定
之前，你可能沒有

1906
01:35:08,450 --> 01:35:10,850
不用擔心這個
區別在某些語言。

1907
01:35:10,850 --> 01:35:12,450
在C中，這非常重要。

1908
01:35:12,450 --> 01:35:15,560
所以，當我得到一個char，我想
使用equals來比較字符

1909
01:35:15,560 --> 01:35:21,350
等於像y或n一些信，我做的，
的確，需要有單引號。

1910
01:35:21,350 --> 01:35:22,770
>> 現在，讓我們繼續前進，做到這一點。

1911
01:35:22,770 --> 01:35:29,180
讓我們繼續前進，不要做
邏輯點斜線邏輯。

1912
01:35:29,180 --> 01:35:30,305
而現在我被提示。

1913
01:35:30,305 --> 01:35:33,638
因此，據推測，更好的用戶體驗
實際上告訴我在這裡做什麼。

1914
01:35:33,638 --> 01:35:36,030
但我要去只是盲目
說Y（是），不錯，真不錯。

1915
01:35:36,030 --> 01:35:38,780
>> 讓我們再次運行它，正因為沒有，美觀大方。

1916
01:35:38,780 --> 01:35:42,610
假設像某些人我知道，
我的大寫鎖定鍵是所有過於頻繁。

1917
01:35:42,610 --> 01:35:46,740
所以我做資本Y，回車，錯誤。

1918
01:35:46,740 --> 01:35:49,130
OK，這不是正是我期待的。

1919
01:35:49,130 --> 01:35:51,170
的確，計算機
簡直是在做什麼

1920
01:35:51,170 --> 01:35:54,794
我告訴它do--檢查
小寫字母y和小寫的n。

1921
01:35:54,794 --> 01:35:56,960
這並不覺得自己是最好
用戶體驗，雖然。

1922
01:35:56,960 --> 01:36:02,010
讓我索取，接受採訪
無論是小寫或大寫。

1923
01:36:02,010 --> 01:36:05,090
因此，原來，你可能想
說類似的划痕，

1924
01:36:05,090 --> 01:36:11,150
像字面上或C等於
等於資本單引號年。

1925
01:36:11,150 --> 01:36:14,400
事實證明，C沒有
這個文字關鍵字或。

1926
01:36:14,400 --> 01:36:15,880
>> 但它確實有兩個豎條。

1927
01:36:15,880 --> 01:36:18,463
你要平時按住Shift，
如果您使用的是美式鍵盤，

1928
01:36:18,463 --> 01:36:21,910
並擊中豎線
按鍵上的回車鍵。

1929
01:36:21,910 --> 01:36:25,410
但是，這豎線
豎線表示或。

1930
01:36:25,410 --> 01:36:29,220
>> 如果，相反，我們希望
說，就像在刮，

1931
01:36:29,220 --> 01:36:31,180
我們可以做的符號與符號。

1932
01:36:31,180 --> 01:36:34,330
這使得沒有任何邏輯意義在這裡，
因為人不可能

1933
01:36:34,330 --> 01:36:40,110
鍵入y和小寫ÿ
和資本y為相同的字符。

1934
01:36:40,110 --> 01:36:42,470
所以，還是就是我們打算在這裡。

1935
01:36:42,470 --> 01:36:49,280
>> 所以，如果我這樣做，在這兩個地方，或c
等於等於資本N，現在重新運行，

1936
01:36:49,280 --> 01:36:52,390
使邏輯，重新運行邏輯。

1937
01:36:52,390 --> 01:36:54,200
現在，我可以鍵入y。

1938
01:36:54,200 --> 01:36:56,920
而且我可以再做一次
資本Y，或資本N.

1939
01:36:56,920 --> 01:36:59,630
而且我可以添加額外的
組合依然。

1940
01:36:59,630 --> 01:37:01,810
>> 因此，這是一個邏輯
程序只要現在

1941
01:37:01,810 --> 01:37:04,940
我檢查的邏輯
這個值或該值。

1942
01:37:04,940 --> 01:37:09,420
我不就得了，必然，
拿出兩個IFS否則IFS。

1943
01:37:09,420 --> 01:37:12,960
其實我可以結合一些
以這種方式將相關邏輯。

1944
01:37:12,960 --> 01:37:14,950
因此，這將是更好
設計不是簡單的

1945
01:37:14,950 --> 01:37:20,490
他說，如果C等於較低的情況下，y，
打印是的，如果C等於資本Y，

1946
01:37:20,490 --> 01:37:23,074
打印是的，如果C等於
lower--換句話說，

1947
01:37:23,074 --> 01:37:24,990
你不必有
越來越多的分支。

1948
01:37:24,990 --> 01:37:31,840
您可以結合一些等價的
分支邏輯，如在這種方式。

1949
01:37:31,840 --> 01:37:37,150
>> 因此，讓我們來看看只有一個
最後一個要素，一是最終的構建，

1950
01:37:37,150 --> 01:37:37,847
這C允許。

1951
01:37:37,847 --> 01:37:39,930
我們會回來的
今後其他的還是。

1952
01:37:39,930 --> 01:37:44,400
然後我們通過觀察得出結論：
在代碼 - 不正確性

1953
01:37:44,400 --> 01:37:49,070
讓代碼work--而設計
的代碼，建廠初期這些種子。

1954
01:37:49,070 --> 01:37:54,337
>> 因此，讓我繼續前進，
在這裡開闢一個新的文件。

1955
01:37:54,337 --> 01:37:54,920
你知道嗎？

1956
01:37:54,920 --> 01:37:57,450
我要重新實現
同樣的程序，

1957
01:37:57,450 --> 01:37:58,940
但使用不同的構建體。

1958
01:37:58,940 --> 01:38:03,110
>> 因此，讓我趕緊給自己
獲得包括CS50.h

1959
01:38:03,110 --> 01:38:07,150
為CS50庫，
標準Io.h像printf。

1960
01:38:07,150 --> 01:38:09,510
給我INT主要無效。

1961
01:38:09,510 --> 01:38:12,310
然後在這裡，讓
我繼續前進，做到這一點。

1962
01:38:12,310 --> 01:38:15,010
>> 煤焦Ç得到得到CHAR，就像以前一樣。

1963
01:38:15,010 --> 01:38:19,770
而且我將使用一個新的結構
now--切換，什麼角色？

1964
01:38:19,770 --> 01:38:22,820
因此，開關是一種像
切換火車軌道。

1965
01:38:22,820 --> 01:38:25,070
或者，真的，這是怎麼樣的
如果一個別人，如果別人如果

1966
01:38:25,070 --> 01:38:26,980
但寫的有些不同。

1967
01:38:26,980 --> 01:38:28,490
>> 開關看起來是這樣的。

1968
01:38:28,490 --> 01:38:32,060
你有開關，然後什麼
字符或你想看看號碼，

1969
01:38:32,060 --> 01:38:35,000
然後一些大括號喜歡
划痕，只是說做這個東西。

1970
01:38:35,000 --> 01:38:36,480
然後你有不同的情況。

1971
01:38:36,480 --> 01:38:37,830
>> 你不if和else使用。

1972
01:38:37,830 --> 01:38:40,050
你從字面上用字情況。

1973
01:38:40,050 --> 01:38:41,790
你會說這樣的事情。

1974
01:38:41,790 --> 01:38:46,820
>> 因此，在一個小寫y的情況下，
或在資本Y的情況下，

1975
01:38:46,820 --> 01:38:50,350
繼續前進並打印出肯定的。

1976
01:38:50,350 --> 01:38:52,020
然後打出來的開關。

1977
01:38:52,020 --> 01:38:52,580
而已。

1978
01:38:52,580 --> 01:38:53,880
我們就大功告成了。

1979
01:38:53,880 --> 01:39:00,270
>> 否則，如果，可以這麼說，
小寫n或大寫字母N，

1980
01:39:00,270 --> 01:39:05,560
然後繼續和打印
出去不，再突破。

1981
01:39:05,560 --> 01:39:11,022
Else--和這種是
默認情況下indeed--的printf error--

1982
01:39:11,022 --> 01:39:13,980
和公正的良好措施，但
這在邏輯上破則沒有必要

1983
01:39:13,980 --> 01:39:15,896
因為我們是在最後
反正開關，

1984
01:39:15,896 --> 01:39:17,520
現在我打破了開關了。

1985
01:39:17,520 --> 01:39:19,280
因此，這看起來有點不同。

1986
01:39:19,280 --> 01:39:21,272
>> 但是，從邏輯上講，它是
實際上相當於。

1987
01:39:21,272 --> 01:39:22,980
你為什麼要使用
一個比其他？

1988
01:39:22,980 --> 01:39:26,220
有時候，只是個人喜好，
有時美學，

1989
01:39:26,220 --> 01:39:28,420
如果我看了一眼這個
現在，有什麼東西

1990
01:39:28,420 --> 01:39:30,510
以說是為
這個代碼的可讀性。

1991
01:39:30,510 --> 01:39:33,690
我的意思是，心中永遠的事實，這
代碼是新的在房間裡我們許多人。

1992
01:39:33,690 --> 01:39:36,515
>> 但它只是一種很漂亮。

1993
01:39:36,515 --> 01:39:40,760
你看小寫字母Y，資本Y，
小寫N，大寫字母N默認情況下，

1994
01:39:40,760 --> 01:39:43,150
它只是一種跳躍
出你的方式

1995
01:39:43,150 --> 01:39:45,200
如此，可以說，也許
在前面的例子

1996
01:39:45,200 --> 01:39:48,780
與如果，和垂直桿，
和其他IFS，可能沒有。

1997
01:39:48,780 --> 01:39:54,600
因此，這是真正的個人問題
選擇，真的，還是可讀性，

1998
01:39:54,600 --> 01:39:55,360
的代碼。

1999
01:39:55,360 --> 01:40:01,230
>> 但在功能方面，讓我
繼續前進，使開關，點斜杠

2000
01:40:01,230 --> 01:40:08,830
開關，現在鍵入小寫字母Y，
資本Y，小寫的n，資本N，

2001
01:40:08,830 --> 01:40:12,250
大衛，重試，因為這是
不是單個字符。

2002
01:40:12,250 --> 01:40:15,050
讓我們做X，錯誤，符合市場預期。

2003
01:40:15,050 --> 01:40:18,640
和，logically--這是值得
我會鼓勵general--甚至

2004
01:40:18,640 --> 01:40:20,790
雖然我們只是刮傷
的一些功能上。

2005
01:40:20,790 --> 01:40:23,560
>> 它可能不是很明顯，當你
自己坐到鍵盤，

2006
01:40:23,560 --> 01:40:24,370
這個怎麼用？

2007
01:40:24,370 --> 01:40:25,240
你會這樣嗎？

2008
01:40:25,240 --> 01:40:28,630
關於有美麗的東西
膝上型或桌面，或訪問

2009
01:40:28,630 --> 01:40:32,290
與編譯器的計算機，
與這樣的代碼編輯器，

2010
01:40:32,290 --> 01:40:35,990
是你幾乎總是可以回答這些
問題為自己只是嘗試。

2011
01:40:35,990 --> 01:40:39,570
>> 例如，如果修辭
在眼前的問題是，

2012
01:40:39,570 --> 01:40:42,540
如果你忘記了，會發生什麼
你break語句？

2013
01:40:42,540 --> 01:40:44,400
這實際上是一個
很平常的事，

2014
01:40:44,400 --> 01:40:46,540
因為它看起來並不
就像你真的需要它們。

2015
01:40:46,540 --> 01:40:49,790
他們並不真正完成
像想一個括號或捲曲

2016
01:40:49,790 --> 01:40:50,714
括號一樣。

2017
01:40:50,714 --> 01:40:52,630
讓我們繼續前進，
重新編譯代碼，看看。

2018
01:40:52,630 --> 01:40:56,690
因此，請開關，點斜線開關。

2019
01:40:56,690 --> 01:40:59,435
讓我們輸入小寫
Y，頂的情況下，回車。

2020
01:40:59,435 --> 01:41:02,390

2021
01:41:02,390 --> 01:41:03,700
所以我輸入年。

2022
01:41:03,700 --> 01:41:07,420
>> 該計劃說的沒錯，沒有，錯誤，
因為雖然它是改變了主意。

2023
01:41:07,420 --> 01:41:12,280
但是，那種是的，因為會發生什麼
有開關是第一種情況是

2024
01:41:12,280 --> 01:41:16,899
比賽實際上意味著，哎電腦，
執行所有代碼的下方。

2025
01:41:16,899 --> 01:41:19,690
如果你不說破，或
不說破，還是不說破，

2026
01:41:19,690 --> 01:41:22,540
電腦會爆
通過所有這些行

2027
01:41:22,540 --> 01:41:25,779
並執行所有的人，直到
它獲取到大括號。

2028
01:41:25,779 --> 01:41:27,320
因此，剎車，的確有必要。

2029
01:41:27,320 --> 01:41:30,120
但這裡外賣，當
有疑問，嘗試一些東西。

2030
01:41:30,120 --> 01:41:32,510
也許先救你的代碼，
或將其保存在一個額外的文件

2031
01:41:32,510 --> 01:41:35,930
如果你真的很擔心
搞亂了，不得不恢復

2032
01:41:35,930 --> 01:41:37,430
你知道的工作是工作。

2033
01:41:37,430 --> 01:41:38,410
>> 但嘗試的事情。

2034
01:41:38,410 --> 01:41:41,074
不要像害怕，也許，
什麼樣的電腦可能會做，

2035
01:41:41,074 --> 01:41:42,490
或者，你可能碰壞。

2036
01:41:42,490 --> 01:41:45,790
您可以隨時恢復
一些早期版本。

2037
01:41:45,790 --> 01:41:48,640
>> 因此，讓我們通過觀察結束
在代碼的設計。

2038
01:41:48,640 --> 01:41:52,020
現在，我們有這個能力來寫
的條件下，與寫循環，

2039
01:41:52,020 --> 01:41:53,850
和變量，和通話功能。

2040
01:41:53,850 --> 01:41:57,590
因此，坦率地說，我們是那種回
我們是一個星期前從無到有，

2041
01:41:57,590 --> 01:42:03,120
儘管有一個不太引人注目的文本
環境比刮允許。

2042
01:42:03,120 --> 01:42:06,990
>> 但是請注意，我們的速度已經獲得
那個詞彙，即使是

2043
01:42:06,990 --> 01:42:10,570
要帶一小會兒下沉，
所以，我們現在可以使用這個詞彙

2044
01:42:10,570 --> 01:42:13,320
寫出比較有趣的節目。

2045
01:42:13,320 --> 01:42:15,940
讓我們一起來小步
往那，如下所示。

2046
01:42:15,940 --> 01:42:17,890
讓我繼續前進，
在這裡創建一個新文件。

2047
01:42:17,890 --> 01:42:20,750
>> 我要調用此
prototype.c，並引進

2048
01:42:20,750 --> 01:42:23,954
首次的能力
使自己的功能。

2049
01:42:23,954 --> 01:42:25,870
有些人可能有
有划痕做到了這一點，

2050
01:42:25,870 --> 01:42:28,430
讓你可以創建你
在刮自己的自定義模塊，

2051
01:42:28,430 --> 01:42:30,892
然後將它們拖放到的地方
無論你想在C.

2052
01:42:30,892 --> 01:42:33,100
而在大多數編程
語言，你可以做完全

2053
01:42:33,100 --> 01:42:36,580
that--使自己的功能，
如果它們不存在。

2054
01:42:36,580 --> 01:42:41,660
>> 所以，舉例來說，讓我先走
和包括CS50.h，並且包括

2055
01:42:41,660 --> 01:42:46,110
標準IO.h，INT主要作廢。

2056
01:42:46,110 --> 01:42:49,020
現在我們有一個
佔位蓄勢待發。

2057
01:42:49,020 --> 01:42:51,550
我一直在承印物
像今天的人的名字。

2058
01:42:51,550 --> 01:42:54,910
那種感覺like--
不會是很好，如果有

2059
01:42:54,910 --> 01:42:56,936
是所謂的打印功能的名稱？

2060
01:42:56,936 --> 01:42:58,060
我沒有用printf。

2061
01:42:58,060 --> 01:42:59,976
我不必記住
所有的格式代碼。

2062
01:42:59,976 --> 01:43:03,050
為什麼不要我，為什麼
沒有人在我面前，

2063
01:43:03,050 --> 01:43:05,980
創建一個函數調用打印
名，給予一定的名字，

2064
01:43:05,980 --> 01:43:06,980
簡單地打印出來？

2065
01:43:06,980 --> 01:43:11,700
>> 換句話說，如果我說，嘿，
電腦，給我一個字符串

2066
01:43:11,700 --> 01:43:14,870
通過詢問用戶這樣，
通過CS50的get字符串函數。

2067
01:43:14,870 --> 01:43:18,090
嘿，計算機，把那個字符串
在左手側的變量，

2068
01:43:18,090 --> 01:43:19,150
並稱之為秒。

2069
01:43:19,150 --> 01:43:25,150
然後，嘿嘿計算機，勇往直前
並打印此人的姓名，完成。

2070
01:43:25,150 --> 01:43:29,240
>> 現在，這將是很好的，因為
這一方案，適當命名的，

2071
01:43:29,240 --> 01:43:32,170
告訴我這是什麼應該做的
這些函數的名稱的方式。

2072
01:43:32,170 --> 01:43:35,930
讓我走，讓原型，回車。

2073
01:43:35,930 --> 01:43:37,930
而且，不幸的是，
這是不會飛。

2074
01:43:37,930 --> 01:43:42,430
>> Prototype.c，7號線，字符
5，錯誤，隱式聲明

2075
01:43:42,430 --> 01:43:45,960
函數打印名字
在C99，C99是無效的

2076
01:43:45,960 --> 01:43:48,130
這意味著一個版本的C
在1999年就出來了。

2077
01:43:48,130 --> 01:43:48,730
就這樣。

2078
01:43:48,730 --> 01:43:51,780
>> 所以，我不知道是什麼
所有這一切意味著呢。

2079
01:43:51,780 --> 01:43:53,810
但我認識到紅色的錯誤。

2080
01:43:53,810 --> 01:43:54,770
這是很明顯的。

2081
01:43:54,770 --> 01:43:56,769
>> 並且似乎與
綠色性格在這裡，

2082
01:43:56,769 --> 01:44:00,520
問題是打印的名字，開
括號S，右括號，分號。

2083
01:44:00,520 --> 01:44:04,800
但隱式聲明
函數，我們確實看到前面簡單。

2084
01:44:04,800 --> 01:44:07,880
這意味著，簡單地說，鏘
不知道我的意思。

2085
01:44:07,880 --> 01:44:12,000
>> 我用一個詞彙詞，它的
以前從未見過或被教導。

2086
01:44:12,000 --> 01:44:14,950
所以，我要教它
這個函數是什麼意思。

2087
01:44:14,950 --> 01:44:16,590
所以我要繼續前進，並做到這一點。

2088
01:44:16,590 --> 01:44:20,970
>> 我要繼續前進，實現
我自己的函數調用打印名稱。

2089
01:44:20,970 --> 01:44:27,720
而我要說，如下所示，這
它這樣做，printf的，你好，百分比

2090
01:44:27,720 --> 01:44:30,760
S，反斜線N，名稱，分號。

2091
01:44:30,760 --> 01:44:32,250
那麼，為什麼我只是做？

2092
01:44:32,250 --> 01:44:34,325
>> 因此，原來，為了
實現自己的功能，

2093
01:44:34,325 --> 01:44:36,845
我們種借用一些
相同的結構主要

2094
01:44:36,845 --> 01:44:38,720
我們剛剛得到
理所當然的，我

2095
01:44:38,720 --> 01:44:40,730
知道剛才複製和
粘貼幾乎什麼

2096
01:44:40,730 --> 01:44:42,170
我已經寫了過去。

2097
01:44:42,170 --> 01:44:43,570
但這裡要注意的格局。

2098
01:44:43,570 --> 01:44:46,750
詮釋，主，無效的，我們將梳理出
沒過多久什麼實際意義。

2099
01:44:46,750 --> 01:44:49,160
>> 但在今天，只是
注意到並行性。

2100
01:44:49,160 --> 01:44:51,210
太虛，打印的名字，
字符串名稱，所以有

2101
01:44:51,210 --> 01:44:53,310
一個紫色的關鍵字，這
我們要開始

2102
01:44:53,310 --> 01:44:57,067
調用返回類型，名稱
的功能，並且然後將輸入。

2103
01:44:57,067 --> 01:44:59,400
所以，實際上，我們可以提煉出
這種上週一樣的

2104
01:44:59,400 --> 01:45:02,030
如，這是名稱或
我們的代碼算法

2105
01:45:02,030 --> 01:45:03,761
去寫 - 的
底層算法

2106
01:45:03,761 --> 01:45:05,010
代碼我們將書寫。

2107
01:45:05,010 --> 01:45:06,180
>> 這是它的輸入。

2108
01:45:06,180 --> 01:45:07,670
這是它的輸出。

2109
01:45:07,670 --> 01:45:11,730
此功能，打印的名字，是
設計上採用了一個名為名稱的字符串，

2110
01:45:11,730 --> 01:45:14,350
也好，作為輸入，然後空隙。

2111
01:45:14,350 --> 01:45:16,904
它不返回任何東西，
像得到字符串或得到INT一樣。

2112
01:45:16,904 --> 01:45:18,570
所以它要交給我的東西回來。

2113
01:45:18,570 --> 01:45:20,960
它只是將有一個
副作用，可以這麼說，

2114
01:45:20,960 --> 01:45:22,570
印刷一個人的名字。

2115
01:45:22,570 --> 01:45:25,260
因此注意到，7號線，我
可以調用打印名稱。

2116
01:45:25,260 --> 01:45:28,920
10號線，我可以定義
或實施打印的名稱。

2117
01:45:28,920 --> 01:45:31,450
但不幸的是，這還不夠。

2118
01:45:31,450 --> 01:45:34,230
>> 讓我繼續前進，
保存後重新編譯這一點。

2119
01:45:34,230 --> 01:45:36,910
哇，現在，我做了它
更糟的是，它似乎。

2120
01:45:36,910 --> 01:45:40,027
這樣的隱式聲明
功能打印名稱無效。

2121
01:45:40,027 --> 01:45:41,360
並再次，還有更多的錯誤。

2122
01:45:41,360 --> 01:45:44,430
但正如我前面提醒，即使
如果你不知所措，

2123
01:45:44,430 --> 01:45:47,850
還是有點難過，看到這麼多
錯誤，只專注於第一

2124
01:45:47,850 --> 01:45:50,500
最初，因為它可能只是
產生了連鎖效應。

2125
01:45:50,500 --> 01:45:54,970
所以C，或鏘更具體地，
仍不能識別打印的名稱。

2126
01:45:54,970 --> 01:45:57,580
>> 那是因為鐺，
在設計上，是種愚蠢。

2127
01:45:57,580 --> 01:45:59,280
它只做你告訴它做什麼。

2128
01:45:59,280 --> 01:46:03,950
而且只在該命令這樣做
在你告訴它做。

2129
01:46:03,950 --> 01:46:08,270
>> 所以我定義主四線，
就像我們一直很經常做的事情。

2130
01:46:08,270 --> 01:46:10,980
我在第10行定義的打印名稱。

2131
01:46:10,980 --> 01:46:14,793
但我想使用
在七號線打印的名稱。

2132
01:46:14,793 --> 01:46:16,670
>> 這太快了，還不存在。

2133
01:46:16,670 --> 01:46:22,150
所以，我可能是聰明，像，
好了，我們只是一起玩，

2134
01:46:22,150 --> 01:46:26,680
和移動打印的名字了
這裡，和重新編譯。

2135
01:46:26,680 --> 01:46:27,550
哦，我的上帝。

2136
01:46:27,550 --> 01:46:28,260
有效。

2137
01:46:28,260 --> 01:46:29,670
它是那樣簡單。

2138
01:46:29,670 --> 01:46:31,120
>> 但邏輯正是如此。

2139
01:46:31,120 --> 01:46:33,870
你要教鏘什麼
是通過首先確定函數。

2140
01:46:33,870 --> 01:46:34,920
然後你可以使用它。

2141
01:46:34,920 --> 01:46:36,940
但是，坦率地說，這種感覺
像滑坡。

2142
01:46:36,940 --> 01:46:38,773
>> 所以每次我運行
一個問題，我只是

2143
01:46:38,773 --> 01:46:42,450
要突出顯示並複製代碼
我寫的，就把它和它粘貼在這裡了。

2144
01:46:42,450 --> 01:46:44,370
而且，可以肯定，我們可以
圖謀一些場景

2145
01:46:44,370 --> 01:46:46,286
其中一個可能的功能
需要調用另一個。

2146
01:46:46,286 --> 01:46:49,030
而你只是不能把每
功能上面隔。

2147
01:46:49,030 --> 01:46:50,930
>> 因此，原來在那裡的
一個更好的解決方案。

2148
01:46:50,930 --> 01:46:53,100
我們可以離開這個可以。

2149
01:46:53,100 --> 01:46:56,677
而且，坦率地說，這是普遍不錯，
方便，良好的設計

2150
01:46:56,677 --> 01:46:59,760
把主要一是因為，再次，
主要就好像當綠旗​​點擊，

2151
01:46:59,760 --> 01:47:02,027
這是函數是
被默認執行。

2152
01:47:02,027 --> 01:47:04,110
所以，你不妨把
它在該文件的頂部

2153
01:47:04,110 --> 01:47:06,560
所以，當您或任何
其他人查看文件

2154
01:47:06,560 --> 01:47:09,360
你知道這是怎麼回事
通過閱讀主要首位。

2155
01:47:09,360 --> 01:47:18,360
所以，事實證明，我們可以告訴鏘
主動，嘿嘿，鏘，四線，

2156
01:47:18,360 --> 01:47:20,940
我答應實施
一個函數調用打印

2157
01:47:20,940 --> 01:47:25,600
名稱以一個字符串名為name
作為輸入，並且沒有返回的，無效的。

2158
01:47:25,600 --> 01:47:27,770
我會避開
後來實現它。

2159
01:47:27,770 --> 01:47:28,680
>> 這裡談到主。

2160
01:47:28,680 --> 01:47:32,130
現在主要在第9行可以使用
打印名稱，因為鏘

2161
01:47:32,130 --> 01:47:35,600
被信任的是，最終，
它會遇到的定義

2162
01:47:35,600 --> 01:47:37,880
姓名正楷的實施。

2163
01:47:37,880 --> 01:47:40,390
所以，救了我的文件之後，讓
我繼續前進，使原型，

2164
01:47:40,390 --> 01:47:41,498
看起來不錯，這一次。

2165
01:47:41,498 --> 01:47:46,470
點斜線，原型，讓我
繼續前進，鍵入一個名稱。

2166
01:47:46,470 --> 01:47:51,440
大衛，你好大衛Zamila，你好
Zamila，事實上，現在的作品。

2167
01:47:51,440 --> 01:47:55,200
>> 因此，這裡的成分是，我們已經
做了一個自定義的功能，如自定義

2168
01:47:55,200 --> 01:47:57,219
划痕塊中，我們要調用它。

2169
01:47:57,219 --> 01:48:00,010
但是，與划痕在那裡你可以
只是創建它，並開始使用它，

2170
01:48:00,010 --> 01:48:02,330
現在我們要成為一個
多一點迂腐，

2171
01:48:02,330 --> 01:48:06,410
實際上訓練鏘
使用，或指望它。

2172
01:48:06,410 --> 01:48:12,140
現在，順便說一句，為什麼這段時間有
我們一直只是盲目信仰，包括

2173
01:48:12,140 --> 01:48:15,170
CS50.h，並且包括標準IO.h？

2174
01:48:15,170 --> 01:48:18,190
>> 那麼，事實證明，
其中一些其他的東西，

2175
01:48:18,190 --> 01:48:21,550
所有的這些點^ h
文件，這恰好是文件。

2176
01:48:21,550 --> 01:48:23,460
他們在頭文件，可以這麼說。

2177
01:48:23,460 --> 01:48:26,270
他們還在用C寫的但是
他們是不同類型的文件。

2178
01:48:26,270 --> 01:48:31,690
>> 現在，你幾乎可以承擔
所有這是CS50.h內

2179
01:48:31,690 --> 01:48:36,360
一些單行尚且如此，
名為打印名稱的功能，

2180
01:48:36,360 --> 01:48:39,840
但對於獲取字符串，獲取
浮動，和其他幾個人。

2181
01:48:39,840 --> 01:48:44,510
而也有類似的原型，
單行，標準IO.h內

2182
01:48:44,510 --> 01:48:49,241
像printf，這是現在在
我自己打印名稱的功能。

2183
01:48:49,241 --> 01:48:52,490
因此，換句話說，這整個時間內，我們
剛剛被盲目複製和粘貼

2184
01:48:52,490 --> 01:48:54,780
包括這一點，包括
這，這是怎麼回事？

2185
01:48:54,780 --> 01:48:58,310
這些僅僅是一種線索
以鐺，以什麼功能

2186
01:48:58,310 --> 01:49:03,170
的確都是執行，只是
在不同的文件別處

2187
01:49:03,170 --> 01:49:05,440
別處在系統上。

2188
01:49:05,440 --> 01:49:08,160
>> 因此，我們已經實現打印的名稱。

2189
01:49:08,160 --> 01:49:10,910
它確實有這種副作用
打印屏幕上的內容。

2190
01:49:10,910 --> 01:49:13,170
但它實際上並沒有
遞給我的東西回來。

2191
01:49:13,170 --> 01:49:15,200
我們如何去
執行一個程序，

2192
01:49:15,200 --> 01:49:17,510
並交給我的東西回來？

2193
01:49:17,510 --> 01:49:18,580
>> 好吧，讓我們試試這個。

2194
01:49:18,580 --> 01:49:24,360
我要繼續貫徹
一個名為return.c

2195
01:49:24,360 --> 01:49:27,530
所以我們可以演示如何的東西
以獲得更多的字符串，或得到詮釋，

2196
01:49:27,530 --> 01:49:30,340
實際上回國
回饋給用戶。

2197
01:49:30,340 --> 01:49:32,840
讓我們繼續前進，並確定主要INT無效。

2198
01:49:32,840 --> 01:49:36,230
>> 並再次，在未來，我們將
解釋什麼是int和這一空白

2199
01:49:36,230 --> 01:49:37,090
其實這樣做。

2200
01:49:37,090 --> 01:49:38,840
但今天，我們將
理所當然。

2201
01:49:38,840 --> 01:49:42,970
我會繼續和printf，
一個良好的用戶體驗，x是。

2202
01:49:42,970 --> 01:49:47,360
然後，我會等待
用戶給我x，其中GET INT。

2203
01:49:47,360 --> 01:49:51,459
>> 然後我要繼續前進
並打印出X到廣場。

2204
01:49:51,459 --> 01:49:53,500
所以，當你只有一個
鍵盤，一般的人

2205
01:49:53,500 --> 01:49:55,600
使用小蘿蔔
鍵盤上的符號

2206
01:49:55,600 --> 01:49:58,330
代表的功率
的，或者的指數。

2207
01:49:58,330 --> 01:50:01,960
SO x的平方是目前我。

2208
01:50:01,960 --> 01:50:03,660
>> 現在我要做到這一點。

2209
01:50:03,660 --> 01:50:06,940
我可以do--什麼的x
平方？點¯x平方為x倍的X.

2210
01:50:06,940 --> 01:50:09,690
>> 我們這樣做了一些
今天已經很久以前。

2211
01:50:09,690 --> 01:50:11,730
這種感覺並不像
那麼多的進展。

2212
01:50:11,730 --> 01:50:12,570
你知道嗎？

2213
01:50:12,570 --> 01:50:16,100
讓我們利用一些想法
從抽象的最後一次。

2214
01:50:16,100 --> 01:50:19,080
>> 那豈不是很好，如果
有一個調用的函數

2215
01:50:19,080 --> 01:50:21,460
方認為正是這麼做的？

2216
01:50:21,460 --> 01:50:23,640
它仍然在的結束
一天，做了同樣的數學。

2217
01:50:23,640 --> 01:50:25,410
但是，讓我們抽象
拿走的想法

2218
01:50:25,410 --> 01:50:28,280
一個數字乘以
另一個，只要給它一個名稱，

2219
01:50:28,280 --> 01:50:30,360
像方此值。

2220
01:50:30,360 --> 01:50:32,560
>> 並且，換句話說，在
C，讓我們創建一個功能

2221
01:50:32,560 --> 01:50:35,660
叫方認為正是這麼做的。

2222
01:50:35,660 --> 01:50:37,600
這將被調用方。

2223
01:50:37,600 --> 01:50:38,790
這將需要一個int。

2224
01:50:38,790 --> 01:50:40,820
我們會只是
稱之為N，默認情況下。

2225
01:50:40,820 --> 01:50:42,403
>> 但我們可以把它叫做什麼，我們想要的。

2226
01:50:42,403 --> 01:50:45,900
和所有它會
這樣做，從字面上看，就是回報

2227
01:50:45,900 --> 01:50:48,810
n次n的結果。

2228
01:50:48,810 --> 01:50:51,980
但是，因為它是
回國東西，這

2229
01:50:51,980 --> 01:50:56,690
在紫色我們已經關鍵字
以前從未見過，我，第11行，

2230
01:50:56,690 --> 01:50:58,410
不能說作廢這個時候。

2231
01:50:58,410 --> 01:51:04,320
>> 太虛，在這個例子中，我們剛才看到
而打印的名字，只是表示，

2232
01:51:04,320 --> 01:51:05,190
做一點事。

2233
01:51:05,190 --> 01:51:07,170
但是，不要遞給我的東西回來。

2234
01:51:07,170 --> 01:51:09,790
在這種情況下，我想
返回n次N，

2235
01:51:09,790 --> 01:51:11,460
或者不管它是什麼，該號碼。

2236
01:51:11,460 --> 01:51:15,460
>> 所以，我不能說，哎，電腦，
我返回任何結果，無效的。

2237
01:51:15,460 --> 01:51:19,166
這將返回在本質上，一個int。

2238
01:51:19,166 --> 01:51:20,790
所以，這是所有在這裡嗎。

2239
01:51:20,790 --> 01:51:23,070
>> 輸入方
將是一個int。

2240
01:51:23,070 --> 01:51:27,760
因此，我們可以使用它，它有
有一個名字，N.這將輸出

2241
01:51:27,760 --> 01:51:29,240
一個int並不需要一個名字。

2242
01:51:29,240 --> 01:51:32,590
我們可以把它交給主，或者是誰
用我記住，如果我們這個值

2243
01:51:32,590 --> 01:51:34,120
想擁有自己的變量。

2244
01:51:34,120 --> 01:51:36,230
>> 並再次，唯一的新
關鍵字這裡是回歸。

2245
01:51:36,230 --> 01:51:37,480
而我只是在做一些數學。

2246
01:51:37,480 --> 01:51:44,825
如果我真的想成為不必要的，
我可以說INT產品得到n次ñ。

2247
01:51:44,825 --> 01:51:47,170
>> 然後，我可以說，回歸產品。

2248
01:51:47,170 --> 01:51:50,360
但同樣，我的觀點同期
這恰恰不是好的設計 - 

2249
01:51:50,360 --> 01:51:53,060
喜歡，為什麼引入一個名字，
一個符號，如產品，

2250
01:51:53,060 --> 01:51:54,570
只是立即返回呢？

2251
01:51:54,570 --> 01:51:56,670
這是一個有點清潔，
有點緊張，所以

2252
01:51:56,670 --> 01:52:02,380
說話，只是說回n倍
N，擺脫這一行乾脆。

2253
01:52:02,380 --> 01:52:05,860
>> 它只是較少的代碼閱讀，
失誤少的機會。

2254
01:52:05,860 --> 01:52:08,180
讓我們看看這個
其實現在的作品。

2255
01:52:08,180 --> 01:52:12,380
現在，我要去
提前做出回報。

2256
01:52:12,380 --> 01:52:14,460
>> 嗯，哦，功能隱式聲明。

2257
01:52:14,460 --> 01:52:17,080
我以前犯了這個錯誤，沒什麼大不了的。

2258
01:52:17,080 --> 01:52:21,950
我只需鍵入，或突出顯示和
複製，完全相同的函數原型，

2259
01:52:21,950 --> 01:52:24,342
或簽名，該功能在這裡的。

2260
01:52:24,342 --> 01:52:25,800
或者，我可以移動整個功能。

2261
01:52:25,800 --> 01:52:26,841
>> 但是，這是一個有點懶惰。

2262
01:52:26,841 --> 01:52:27,870
因此，我們不會那麼做。

2263
01:52:27,870 --> 01:52:30,960
現在，讓我回
再次，點斜線回報。

2264
01:52:30,960 --> 01:52:35,790
>> x為2。X的平方等於4。
x被。X的平方等於9。

2265
01:52:35,790 --> 01:52:38,300
而功能似乎
現在的工作。

2266
01:52:38,300 --> 01:52:39,550
那麼，有什麼區別嗎？

2267
01:52:39,550 --> 01:52:45,520
我有一個這就是所謂的平方函數，
在這種情況下，我把在一個輸入。

2268
01:52:45,520 --> 01:52:46,830
而我回來的輸出。

2269
01:52:46,830 --> 01:52:49,210
然而，此前，如果
我打開其他的例子

2270
01:52:49,210 --> 01:52:54,640
從早期的，這
被稱為prototype.c，

2271
01:52:54,640 --> 01:52:57,770
我有打印的名稱，
退回作廢，可以這麼說，

2272
01:52:57,770 --> 01:53:01,730
或者，它返回什麼，
簡單地產生了副作用。

2273
01:53:01,730 --> 01:53:03,230
>> 那麼是什麼回事？

2274
01:53:03,230 --> 01:53:06,520
那麼，考慮功能
得到的字符串只是一瞬間。

2275
01:53:06,520 --> 01:53:09,570
我們一直在使用功能
得到以下列方式串。

2276
01:53:09,570 --> 01:53:13,464
>> 我們有一個函數來獲取
字符串，如包括CS50.h，

2277
01:53:13,464 --> 01:53:19,624
包括標準IO.h，INT，主要的，無效的。

2278
01:53:19,624 --> 01:53:21,790
然後每一次我
名為get字符串到目前為止，

2279
01:53:21,790 --> 01:53:26,260
我說的一樣，字符串s
得到得到的字符串，因為GET string--

2280
01:53:26,260 --> 01:53:30,880
我們稱之為get.c-- GET字符串
本身返回一個字符串，我可以再

2281
01:53:30,880 --> 01:53:35,050
用了，說，你好，逗號，
％的S，反斜線N，S。

2282
01:53:35,050 --> 01:53:38,660
>> 因此，這是相同的例子，
真的，我們前面了。

2283
01:53:38,660 --> 01:53:40,920
因此，獲得字符串返回一個值。

2284
01:53:40,920 --> 01:53:44,260
但是剛才，打印字符串
沒有返回值。

2285
01:53:44,260 --> 01:53:45,721
它只是有一個副作用。

2286
01:53:45,721 --> 01:53:47,220
所以這是一個根本的區別。

2287
01:53:47,220 --> 01:53:49,710
我們已經看到了不同的
類型的功能現在，

2288
01:53:49,710 --> 01:53:52,490
其中一些已經返回
值，其中一些則沒有。

2289
01:53:52,490 --> 01:53:54,890
因此，也許它的字符串或整型，浮點或。

2290
01:53:54,890 --> 01:53:56,480
或者，也許它只是無效。

2291
01:53:56,480 --> 01:53:58,710
>> 不同的是
這些函數

2292
01:53:58,710 --> 01:54:02,940
獲取數據並返回一個值實際上是
把東西回表，

2293
01:54:02,940 --> 01:54:04,110
可以這麼說。

2294
01:54:04,110 --> 01:54:06,710
因此，讓我們繼續前進，
看一眼決勝盤

2295
01:54:06,710 --> 01:54:12,129
的實施例，給出了一個感，現在的
我們怎麼可能，的確，抽象更好，

2296
01:54:12,129 --> 01:54:14,670
更好，更好或更多
多，而且多，為了

2297
01:54:14,670 --> 01:54:16,810
寫，最終更好的代碼。

2298
01:54:16,810 --> 01:54:19,860
讓我們繼續前進，並在精神
刮，做到以下幾點。

2299
01:54:19,860 --> 01:54:24,700
>> 讓我繼續前進，包括
CS50.h和標準IO.h.

2300
01:54:24,700 --> 01:54:27,010
讓我先走，並把
我自己一個int，主要的，無效的。

2301
01:54:27,010 --> 01:54:30,380
讓我先走，稱此cough.c。

2302
01:54:30,380 --> 01:54:38,510
>> 讓我繼續前進，只是
像划痕，打印出咳嗽/ N。

2303
01:54:38,510 --> 01:54:40,170
我想這樣做三次。

2304
01:54:40,170 --> 01:54:42,670
所以我，當然，只是去
複製和粘貼三次。

2305
01:54:42,670 --> 01:54:49,440
我現在要作
咳嗽點斜線咳嗽。

2306
01:54:49,440 --> 01:54:53,120
讓我們給自己多一點的房間
在這裡，回車，咳，咳，咳。

2307
01:54:53,120 --> 01:54:56,970
>> 還有，很明顯，已經是一個
機會改善。

2308
01:54:56,970 --> 01:54:58,679
我複製並粘貼
今天一幾次。

2309
01:54:58,679 --> 01:55:01,261
但是，這是唯一的，所以我沒有
必須輸入盡可能多的字符。

2310
01:55:01,261 --> 01:55:03,250
我還是改變了什麼
這些代碼行。

2311
01:55:03,250 --> 01:55:07,240
>> 這三條線是相同的，
這感覺懶惰，的確是，

2312
01:55:07,240 --> 01:55:10,110
而可能是不正確的方法。

2313
01:55:10,110 --> 01:55:14,029
那麼什麼成分
我們可以改善這個代碼？

2314
01:55:14,029 --> 01:55:15,570
我們不必複製和粘貼的代碼。

2315
01:55:15,570 --> 01:55:18,070
>> 而且，事實上，任何時候你感覺
自己複製和粘貼，

2316
01:55:18,070 --> 01:55:20,700
即使不更改代碼，
賠率是有一個更好的辦法。

2317
01:55:20,700 --> 01:55:22,470
而且，事實上，有。

2318
01:55:22,470 --> 01:55:25,510
讓我繼續前進，循環做了，
即使語法可能不

2319
01:55:25,510 --> 01:55:27,570
自然來呢。

2320
01:55:27,570 --> 01:55:32,494
>> 這樣做三次，只需
通過執行following--

2321
01:55:32,494 --> 01:55:34,160
我碰巧從實踐中知道這一點。

2322
01:55:34,160 --> 01:55:35,810
但是，我們有一些例子吧。

2323
01:55:35,810 --> 01:55:37,950
你會看到在線
更多的參考依然。

2324
01:55:37,950 --> 01:55:40,790
>> 這是第6行的句法，即
就像從頭開始重複

2325
01:55:40,790 --> 01:55:43,090
塊，重複下面的三倍。

2326
01:55:43,090 --> 01:55:44,340
這是一個有點神奇現在。

2327
01:55:44,340 --> 01:55:46,050
但是，這會得到更多，
越來越熟悉。

2328
01:55:46,050 --> 01:55:48,050
>> 而且它會重複
八號線三次，

2329
01:55:48,050 --> 01:55:55,390
所以，如果我重新編譯化妝咳嗽，
點斜線咳，咳，咳，咳。

2330
01:55:55,390 --> 01:55:57,030
它仍然以同樣的方式。

2331
01:55:57,030 --> 01:55:58,550
所以這是一切優秀和良好。

2332
01:55:58,550 --> 01:56:01,200
但是，這不是很抽象。

2333
01:56:01,200 --> 01:56:02,371
>> 這是完全正確的。

2334
01:56:02,371 --> 01:56:04,370
但感覺好像有
可能是一個機會，

2335
01:56:04,370 --> 01:56:06,750
作為在世界
從無到有，來樣開始

2336
01:56:06,750 --> 01:56:10,530
在這裡添加一些語義使
我不只是有一定的循環，

2337
01:56:10,530 --> 01:56:12,867
和一個函數，說
咳嗽，還是咳嗽。

2338
01:56:12,867 --> 01:56:13,450
你知道嗎？

2339
01:56:13,450 --> 01:56:15,620
我想做個
有點涼比，

2340
01:56:15,620 --> 01:56:19,090
實際上編寫一個函數，
有一定的副作用，稱之為咳嗽。

2341
01:56:19,090 --> 01:56:23,830
>> 而且它沒有輸入，
無返回值作為輸出。

2342
01:56:23,830 --> 01:56:25,680
但是你知道它做什麼？

2343
01:56:25,680 --> 01:56:32,370
它this--的printf，
報價引文結束，咳嗽。

2344
01:56:32,370 --> 01:56:35,380
>> 現在在這裡，我要去
繼續前進，對於int，

2345
01:56:35,380 --> 01:56:39,070
我得到零，我不到3，我加再加。

2346
01:56:39,070 --> 01:56:42,770
我會不會做的printf，這是
可以說是一個低層次的實現

2347
01:56:42,770 --> 01:56:43,270
詳情。

2348
01:56:43,270 --> 01:56:44,353
我不在乎怎麼咳嗽。

2349
01:56:44,353 --> 01:56:46,240
我只是想用止咳的功能。

2350
01:56:46,240 --> 01:56:47,840
而我只是要打電話咳嗽。

2351
01:56:47,840 --> 01:56:49,204
>> 現在，請注意二分法。

2352
01:56:49,204 --> 01:56:52,370
當你調用一個函數，如果你不
想給它輸入，完全罰款。

2353
01:56:52,370 --> 01:56:54,780
只要做開括號，接近
括號，就大功告成了。

2354
01:56:54,780 --> 01:56:59,271
>> 當你定義一個函數，或
聲明函數的原型，

2355
01:56:59,271 --> 01:57:01,770
如果你事先知道這不是
要採取任何參數，

2356
01:57:01,770 --> 01:57:04,170
說這些括號出現空白。

2357
01:57:04,170 --> 01:57:08,660
這使某些你
會不小心誤用。

2358
01:57:08,660 --> 01:57:10,020
讓我繼續前進，使咳嗽。

2359
01:57:10,020 --> 01:57:11,540
而且，當然，我犯了一個錯誤。

2360
01:57:11,540 --> 01:57:13,410
>> 該死的，還有那
隱式聲明。

2361
01:57:13,410 --> 01:57:14,325
但是，這很好。

2362
01:57:14,325 --> 01:57:15,590
這是一個容易解決。

2363
01:57:15,590 --> 01:57:21,240
我需要的只是原型上漲
在我的文件比我實際使用它。

2364
01:57:21,240 --> 01:57:23,070
>> 所以，現在讓我又咳嗽，美觀大方。

2365
01:57:23,070 --> 01:57:23,790
現在，它的工作原理。

2366
01:57:23,790 --> 01:57:25,930
讓咳，咳，咳，咳。

2367
01:57:25,930 --> 01:57:28,930
所以，你可能會認為我們真的
剛過工程這個問題。

2368
01:57:28,930 --> 01:57:29,763
而且，事實上，我們是。

2369
01:57:29,763 --> 01:57:31,870
這不是一個好
的程序的候補

2370
01:57:31,870 --> 01:57:34,930
在時刻
重構，做什麼

2371
01:57:34,930 --> 01:57:38,645
所謂的層次分解，
在這裡你需要一些代碼，然後

2372
01:57:38,645 --> 01:57:41,790
有種你因子東西出來，這樣
歸於更多的語義他們，

2373
01:57:41,790 --> 01:57:43,930
和重用它最終長期的。

2374
01:57:43,930 --> 01:57:46,490
但它是一個構建塊朝
更複雜的程序

2375
01:57:46,490 --> 01:57:48,600
我們將開始
之前寫了長

2376
01:57:48,600 --> 01:57:53,090
讓我們有詞彙
與寫出更好的代碼。

2377
01:57:53,090 --> 01:57:55,920
而且，事實上，讓我們看看，如果我們
不能一概而論進一步此。

2378
01:57:55,920 --> 01:58:00,984
>> 這似乎有點跛，我，主，
需要擔心這個該死的for循環，

2379
01:58:00,984 --> 01:58:02,400
並一再呼籲咳嗽。

2380
01:58:02,400 --> 01:58:06,050
為什麼我不能只是告訴咳嗽，
請咳嗽三次？

2381
01:58:06,050 --> 01:58:11,170
換句話說，為什麼我不能只是
給輸入咳嗽，做到這一點？

2382
01:58:11,170 --> 01:58:14,270
>> 為什麼我不能只是說，在
主咳嗽三次。

2383
01:58:14,270 --> 01:58:16,150
而現在，這是種神奇。

2384
01:58:16,150 --> 01:58:17,540
這是非常反复的在這裡。

2385
01:58:17,540 --> 01:58:18,940
而且它是，事實上，一個嬰兒的一步。

2386
01:58:18,940 --> 01:58:22,250
>> 但就在能力上說，
八號線，咳嗽三次，

2387
01:58:22,250 --> 01:58:23,730
它只是這麼多的可讀性。

2388
01:58:23,730 --> 01:58:27,210
而且，再加上，我不必知道
或護理咳嗽是如何實現的。

2389
01:58:27,210 --> 01:58:29,460
而且，事實上，在後來的
長期和最終項目，

2390
01:58:29,460 --> 01:58:32,150
如果你處理一個項目
一個同學或兩位同學，

2391
01:58:32,150 --> 01:58:35,370
你會意識到，你要
有，或者想，分工。

2392
01:58:35,370 --> 01:58:37,650
>> 而你會想決定
事先，誰去做些什麼，

2393
01:58:37,650 --> 01:58:38,483
並在其中部分？

2394
01:58:38,483 --> 01:58:40,520
而不會是好的
如果，例如，

2395
01:58:40,520 --> 01:58:43,100
負責撰寫主力，完成。

2396
01:58:43,100 --> 01:58:46,470
而你的室友，或者你
夥伴更一般地，

2397
01:58:46,470 --> 01:58:48,230
負責實施的咳嗽。

2398
01:58:48,230 --> 01:58:52,540
>> 而且這種劃分，這些
抽象的牆，

2399
01:58:52,540 --> 01:58:55,310
抽象或層，如果
你會，是超級強大，

2400
01:58:55,310 --> 01:58:58,480
因為特別是較大的，
更複雜的程序和系統，

2401
01:58:58,480 --> 01:59:03,070
它允許多個人建
東西放在一起，最終

2402
01:59:03,070 --> 01:59:05,680
縫合在一起以這種方式工作。

2403
01:59:05,680 --> 01:59:08,332
但是，當然，我們
現在需要解決的咳嗽。

2404
01:59:08,332 --> 01:59:10,290
我們需要告訴咳嗽
，嘿，你知道嗎？

2405
01:59:10,290 --> 01:59:14,230
你將需要採取
input--所以並不作廢，int和現在。

2406
01:59:14,230 --> 01:59:18,170
讓我們繼續前進並投入
咳嗽整型。我得到零。

2407
01:59:18,170 --> 01:59:19,890
>> i小於多少倍。

2408
01:59:19,890 --> 01:59:21,550
我以前說過三種。

2409
01:59:21,550 --> 01:59:23,420
但是，這不是我想要的。

2410
01:59:23,420 --> 01:59:28,520
我想咳嗽推廣到
支持任何數量的迭代。

2411
01:59:28,520 --> 01:59:31,800
>> 所以，事實上，它是n表示我想，
無論用戶告訴我。

2412
01:59:31,800 --> 01:59:34,620
現在，我可以繼續說打印咳嗽。

2413
01:59:34,620 --> 01:59:37,750
無論什麼號碼
用戶通過在，

2414
01:59:37,750 --> 01:59:39,890
我會重複很多次。

2415
01:59:39,890 --> 01:59:42,160
>> 這樣在一天結束時，
程序是相同的。

2416
01:59:42,160 --> 01:59:45,820
但是請注意，所有的這些東西
甚至可以是在另一文件中。

2417
01:59:45,820 --> 01:59:48,620
事實上，我不知道在
此刻怎麼printf的實現。

2418
01:59:48,620 --> 01:59:50,980
>> 我不知道此刻怎麼弄
串，或得到int或獲得浮動

2419
01:59:50,980 --> 01:59:51,646
的貫徹落實。

2420
01:59:51,646 --> 01:59:53,930
而且我不希望
看到他們我的屏幕上。

2421
01:59:53,930 --> 01:59:58,320
正因為如此，我開始專注於
我的程序，而不是那些功能。

2422
01:59:58,320 --> 02:00:02,070
>> 所以，事實上，只要你
開始分解這樣的代碼了，

2423
02:00:02,070 --> 02:00:04,397
可能我們連招咳嗽
到一個單獨的文件？

2424
02:00:04,397 --> 02:00:05,730
別人可以實現它。

2425
02:00:05,730 --> 02:00:09,810
你和你的程序成為
很漂亮，非常具有可讀性，

2426
02:00:09,810 --> 02:00:13,830
可以說，真正的4
行程序就在那裡。

2427
02:00:13,830 --> 02:00:16,510
>> 現在讓我們繼續前進
並作一次改變。

2428
02:00:16,510 --> 02:00:19,180
請注意，我的原型
必須改變往上頂。

2429
02:00:19,180 --> 02:00:21,390
因此，讓我解決，這麼
我沒有得到大聲呵斥。

2430
02:00:21,390 --> 02:00:25,580
>> 使咳嗽，讓我跑一次咳嗽
更多的，仍然在做同樣的事情。

2431
02:00:25,580 --> 02:00:29,010
但現在，看到我們有一個
成分為最後一個版本。

2432
02:00:29,010 --> 02:00:29,940
你知道嗎？

2433
02:00:29,940 --> 02:00:32,040
我不希望只是咳嗽，不一定。

2434
02:00:32,040 --> 02:00:33,802
我希望有更多的東西一般。

2435
02:00:33,802 --> 02:00:34,510
所以，你知道嗎？

2436
02:00:34,510 --> 02:00:35,450
我想這樣做。

2437
02:00:35,450 --> 02:00:40,140
我想有，就像刮
確實，一說塊，但不只是

2438
02:00:40,140 --> 02:00:41,680
說些什麼的時候一定數目。

2439
02:00:41,680 --> 02:00:44,510
我希望它說一個非常具體的字符串。

2440
02:00:44,510 --> 02:00:46,850
，因此，我不知道
希望它只是說咳嗽。

2441
02:00:46,850 --> 02:00:50,660
我希望它說什麼
字符串在通過。

2442
02:00:50,660 --> 02:00:52,960
>> 所以請注意，我全身
這讓現在

2443
02:00:52,960 --> 02:00:56,110
比方說感覺就像一個好名字
對於這一點，喜歡從無到有，

2444
02:00:56,110 --> 02:00:58,530
有兩個參數，不像劃傷。

2445
02:00:58,530 --> 02:00:59,570
之一是一個字符串。

2446
02:00:59,570 --> 02:01:00,300
一個是一個int。

2447
02:01:00,300 --> 02:01:01,130
>> 我可以切換。

2448
02:01:01,130 --> 02:01:03,713
我只是有點像的想法
說字符串，然後再

2449
02:01:03,713 --> 02:01:04,940
多少次以後。

2450
02:01:04,940 --> 02:01:06,970
虛空意味著它仍然
不返回任何東西。

2451
02:01:06,970 --> 02:01:09,428
這些僅僅是視覺方面
效果，像[？喬丹？]

2452
02:01:09,428 --> 02:01:11,240
大呼小叫的口頭副作用。

2453
02:01:11,240 --> 02:01:15,630
它仍然做了n次，
0到，但不等於n。

2454
02:01:15,630 --> 02:01:17,540
這意味著全部N次。

2455
02:01:17,540 --> 02:01:19,540
然後只需打印出
無論是字符串。

2456
02:01:19,540 --> 02:01:22,060
所以，我真的全身
這行代碼。

2457
02:01:22,060 --> 02:01:25,460
所以，現在，我該如何實現
咳嗽功能？

2458
02:01:25,460 --> 02:01:28,520
>> 我可以做無效咳嗽。

2459
02:01:28,520 --> 02:01:31,501
我仍然可以在如何
你想多次咳嗽。

2460
02:01:31,501 --> 02:01:32,250
但是，你知道嗎？

2461
02:01:32,250 --> 02:01:34,240
現在我可以踢的話。

2462
02:01:34,240 --> 02:01:39,540
>> 我可以調用的說
字咳嗽，經過n的。

2463
02:01:39,540 --> 02:01:43,410
如果我想，也能實現，
只是為了好玩，一個噴嚏功能，

2464
02:01:43,410 --> 02:01:45,290
我打噴嚏的時候一定數目。

2465
02:01:45,290 --> 02:01:50,300
我可以繼續重用N，因為
注意到在這種情況下或範圍是m

2466
02:01:50,300 --> 02:01:52,470
只有在這個函數中存在。

2467
02:01:52,470 --> 02:01:55,767
>> 和N在這種情況下只
這裡這個函數中存在。

2468
02:01:55,767 --> 02:01:57,600
因此，我們會回來的
範圍這些問題。

2469
02:01:57,600 --> 02:02:04,160
而在這裡，我只是說，
ACHOO，然後n倍，分號。

2470
02:02:04,160 --> 02:02:07,340
>> 而現在，我只需要借用
這些功能在這裡簽名了。

2471
02:02:07,340 --> 02:02:09,290
所以咳嗽是正確的。

2472
02:02:09,290 --> 02:02:13,090
虛空噴嚏現在是正確的。

2473
02:02:13,090 --> 02:02:15,390
>> 我仍然只是需要說。

2474
02:02:15,390 --> 02:02:21,990
所以我要說，說
字符串s，詮釋N，分號。

2475
02:02:21,990 --> 02:02:25,010
所以，我已經過度設計的
赫克出這個計劃。

2476
02:02:25,010 --> 02:02:26,760
>> 這並不
一定意味著這是

2477
02:02:26,760 --> 02:02:29,343
寫作時你應該做的
節目即使是最簡單。

2478
02:02:29,343 --> 02:02:32,280
就拿東西是很明顯
很簡單，真的很短，

2479
02:02:32,280 --> 02:02:34,800
並重新實現它
使用太多的代碼。

2480
02:02:34,800 --> 02:02:37,560
但是，你實際看到的，而在
時間回頭看這些例子，

2481
02:02:37,560 --> 02:02:41,610
與實現，哦，那些步驟
我們採取了實際一概而論，

2482
02:02:41,610 --> 02:02:43,797
要因素出來的東西，
直到在一天結束

2483
02:02:43,797 --> 02:02:45,380
我的代碼實際上是非常合理的。

2484
02:02:45,380 --> 02:02:48,960
因為如果我想咳嗽3
次，然後打噴嚏三次，

2485
02:02:48,960 --> 02:02:53,420
我只是要重新運行此，
計劃使咳嗽，並運行咳嗽。

2486
02:02:53,420 --> 02:02:56,620
而且我有三個咳嗽
和三個噴嚏。

2487
02:02:56,620 --> 02:02:58,990
>> 所以這是一個基本的
範例，如果你願意，

2488
02:02:58,990 --> 02:03:03,110
對於我們如何去
實際執行的程序。

2489
02:03:03,110 --> 02:03:06,220
但是讓我們只看到現在是什麼
我們一直在做這一切的時候，

2490
02:03:06,220 --> 02:03:09,940
什麼一些最終件
這是簡單的命令後面。

2491
02:03:09,940 --> 02:03:12,620
在一天結束的時候，我們已經
使用鏘作為我們編譯了。

2492
02:03:12,620 --> 02:03:14,494
我們一直在寫源
代碼，將其轉換

2493
02:03:14,494 --> 02:03:15,820
通過鏘成機器代碼。

2494
02:03:15,820 --> 02:03:18,540
>> 而且我們一直在使用剛剛製作
以方便我們這樣的擊鍵

2495
02:03:18,540 --> 02:03:23,740
我們不必記住
鏘本身的咒語。

2496
02:03:23,740 --> 02:03:25,640
但是，什麼是讓真正在做什麼？

2497
02:03:25,640 --> 02:03:27,750
並且，反過來，是什麼
鏘實際上做？

2498
02:03:27,750 --> 02:03:31,790
>> 事實證明，儘管我們已經簡化
說今天的討論，

2499
02:03:31,790 --> 02:03:36,090
你把源代碼，把它作為
輸入一個編譯器，它給你

2500
02:03:36,090 --> 02:03:38,750
機的輸出
代碼，原來有

2501
02:03:38,750 --> 02:03:40,420
裡邊有幾個不同的步驟。

2502
02:03:40,420 --> 02:03:44,940
和編譯恰好是傘
術語一大堆的步驟。

2503
02:03:44,940 --> 02:03:46,970
但是，我們只是戲弄
這一點真的很快。

2504
02:03:46,970 --> 02:03:51,070
>> 事實證明，我們一直在做
更多的事情我每次運行一個程序的時候，

2505
02:03:51,070 --> 02:03:53,990
或每次我今天編譯程序。

2506
02:03:53,990 --> 02:03:58,020
因此，預處理是指
在C程序this--什麼，

2507
02:03:58,020 --> 02:04:01,720
如我們一次又一次地看到，
與此井號開始，

2508
02:04:01,720 --> 02:04:06,320
還是這裡的＃標籤符號，意味著
這是一個預處理指令。

2509
02:04:06,320 --> 02:04:10,330
這意味著，在這種情況下，餵
計算機，做一些與此文件

2510
02:04:10,330 --> 02:04:12,430
在你真正編譯自己的代碼。

2511
02:04:12,430 --> 02:04:18,220
>> 在此情況下，散列包括就是
本質上，C的說法方式，

2512
02:04:18,220 --> 02:04:22,325
哎電腦，去獲得內容
CS50.h，並將其粘貼在這裡。

2513
02:04:22,325 --> 02:04:25,170
嘿電腦，去獲得的
標準IO.h的內容，

2514
02:04:25,170 --> 02:04:27,690
無論是在
硬盤驅動器，它貼在這裡。

2515
02:04:27,690 --> 02:04:30,390
因此，這些事情發生
預處理時先。

2516
02:04:30,390 --> 02:04:31,880
>> 而鏘做這一切對我們來說。

2517
02:04:31,880 --> 02:04:33,510
並且實現起來這麼混賬
快，你甚至不

2518
02:04:33,510 --> 02:04:35,000
看到四個不同的事情發生。

2519
02:04:35,000 --> 02:04:37,100
但是，這是第一個這樣的一步。

2520
02:04:37,100 --> 02:04:38,560
>> 其實什麼接下來會發生？

2521
02:04:38,560 --> 02:04:41,320
好了，接下來的正式
一步是編譯。

2522
02:04:41,320 --> 02:04:43,385
而事實證明，
編譯程序

2523
02:04:43,385 --> 02:04:47,060
技術上意味著從去
源代碼，我們已經東東

2524
02:04:47,060 --> 02:04:50,890
今天一直在寫，東西
所謂的彙編代碼，東西

2525
02:04:50,890 --> 02:04:52,260
看起來有點不同。

2526
02:04:52,260 --> 02:04:54,050
>> 而且，事實上，我們可以真正快速的看到這一點。

2527
02:04:54,050 --> 02:04:56,890
讓我真正進入我的IDE。

2528
02:04:56,890 --> 02:05:01,050
讓我繼續前進，開放的hello.c，這
是第一個程序，使用它我們

2529
02:05:01,050 --> 02:05:02,120
今天開始了。

2530
02:05:02,120 --> 02:05:07,130
讓我繼續運行鏘一
有點不同，鏘-S，hello.c中，

2531
02:05:07,130 --> 02:05:10,720
這實際上是要
給我另一個文件hello.s。

2532
02:05:10,720 --> 02:05:13,330
>> 我們可能永遠不會
再次看到這種代碼。

2533
02:05:13,330 --> 02:05:16,030
如果你把一個較低的水平
系統類像CS61，

2534
02:05:16,030 --> 02:05:17,920
你會看到更多
的這種代碼。

2535
02:05:17,920 --> 02:05:20,020
但是，這是彙編語言。

2536
02:05:20,020 --> 02:05:25,050
這是X86彙編語言
這是基本的CPU

2537
02:05:25,050 --> 02:05:27,460
CS50 IDE實際上理解。

2538
02:05:27,460 --> 02:05:30,060
>> 和隱蔽因為它
看，那是什麼

2539
02:05:30,060 --> 02:05:32,180
計算機理解得很好。

2540
02:05:32,180 --> 02:05:33,790
子Q，這是一個減法。

2541
02:05:33,790 --> 02:05:34,660
有動作。

2542
02:05:34,660 --> 02:05:38,730
>> 還有的調用函數在這裡，
點¯xO形圈，一個動作，一個插件，彈出，

2543
02:05:38,730 --> 02:05:39,430
回報。

2544
02:05:39,430 --> 02:05:41,850
因此，有一些非常
低級別的指令

2545
02:05:41,850 --> 02:05:44,280
該CPU的理解，
我前面提到。

2546
02:05:44,280 --> 02:05:46,100
這就是英特爾內部。

2547
02:05:46,100 --> 02:05:48,030
>> 有模式
零和一其

2548
02:05:48,030 --> 02:05:54,800
映射到這些措辭arcanely，但
有些良好的命名，說明，

2549
02:05:54,800 --> 02:05:55,780
可以這麼說。

2550
02:05:55,780 --> 02:05:57,780
那是發生在什麼
您編譯代碼。

2551
02:05:57,780 --> 02:06:01,560
你得到總成
語言出來，這

2552
02:06:01,560 --> 02:06:07,680
裝置的第三個步驟是組裝
該彙編代碼進入，最終，

2553
02:06:07,680 --> 02:06:12,080
機代碼 - 零和一，而不是
文本剛才我們看到剛才。

2554
02:06:12,080 --> 02:06:16,370
>> 因此，預處理這是否找到
和替換，以及一些其他的東西。

2555
02:06:16,370 --> 02:06:19,430
編譯把你的源代碼
從C代碼，源代碼

2556
02:06:19,430 --> 02:06:21,980
我們寫的，到組裝
代碼，我們只是看了一眼。

2557
02:06:21,980 --> 02:06:25,170
組裝需要該程序集
碼到零和一

2558
02:06:25,170 --> 02:06:27,680
該CPU真的會
理解在一天結束。

2559
02:06:27,680 --> 02:06:30,630
和鏈接是最後一步
出現這種情況的再次us--，

2560
02:06:30,630 --> 02:06:32,830
如此之快，我們甚至不
notice--，上面寫著：

2561
02:06:32,830 --> 02:06:35,460
哎電腦，採取所有的
在零和一的

2562
02:06:35,460 --> 02:06:39,750
源於編譯大衛的代碼，
和他在這種情況下，主要的功能。

2563
02:06:39,750 --> 02:06:42,160
>> 哎電腦，去獲得
所有的零和一

2564
02:06:42,160 --> 02:06:45,180
該工作人員CS50寫道：
在CS50庫內。

2565
02:06:45,180 --> 02:06:46,440
混合那些與大衛的。

2566
02:06:46,440 --> 02:06:49,648
哎電腦，去獲得所有的零
和那些別人寫了幾年

2567
02:06:49,648 --> 02:06:50,470
以前像printf。

2568
02:06:50,470 --> 02:06:52,880
而這些添加進
整個事情，讓我們已經

2569
02:06:52,880 --> 02:06:55,870
得到了我的零和一的
CS50員工的零和的，

2570
02:06:55,870 --> 02:06:58,370
printf的的零和一，
和我們使用其他任何東西。

2571
02:06:58,370 --> 02:07:03,410
>> 它們都能夠結合在一起成一個
程序調用，在這種情況下，餵。

2572
02:07:03,410 --> 02:07:06,141
所以，從今以後，我們將只
用這個詞編譯。

2573
02:07:06,141 --> 02:07:09,390
我們會理所當然地認為，當
我們說，編譯你的程序，這意味著，

2574
02:07:09,390 --> 02:07:11,849
哎做預處理，
彙編和連接。

2575
02:07:11,849 --> 02:07:14,890
但實際上有一些多汁的東西
對那裡發生的引擎蓋下面。

2576
02:07:14,890 --> 02:07:16,723
特別是如果你
讓好奇的一段時間，

2577
02:07:16,723 --> 02:07:18,900
你可以開始戳
圍繞在這個較低的水平。

2578
02:07:18,900 --> 02:07:22,660
但是現在，意識到
在外賣今天之一

2579
02:07:22,660 --> 02:07:26,420
是很簡單的
開始的過程中，

2580
02:07:26,420 --> 02:07:29,700
越來越舒服的
類似的hello world。

2581
02:07:29,700 --> 02:07:32,575
事實上，大多數的我們今天做了
當然不會下沉超快。

2582
02:07:32,575 --> 02:07:34,491
它會採取一些
時間，以及一些實踐。

2583
02:07:34,491 --> 02:07:36,864
賠率是，你將整理
的想打你的鍵盤

2584
02:07:36,864 --> 02:07:37,780
或者在屏幕大喊大叫。

2585
02:07:37,780 --> 02:07:38,880
而所有的這行。

2586
02:07:38,880 --> 02:07:41,320
不過，也許是盡量不要
這樣做在圖書館這麼多。

2587
02:07:41,320 --> 02:07:43,820
>> 最終，你會
被能夠雖然，以啟動

2588
02:07:43,820 --> 02:07:47,580
眼看模式，無論是在好的代碼
你寫在錯誤

2589
02:07:47,580 --> 02:07:48,370
你所做的。

2590
02:07:48,370 --> 02:07:51,965
和很像的過程
成為一個TF或CA是什麼樣子，

2591
02:07:51,965 --> 02:07:54,590
你會開始變得更好，
在看到這些模式比較好，

2592
02:07:54,590 --> 02:07:56,774
和公正的解決您的
自己的問題最終。

2593
02:07:56,774 --> 02:07:59,940
在此期間，將有大量
我們借給你們的支持，讓你

2594
02:07:59,940 --> 02:08:00,481
通過這個。

2595
02:08:00,481 --> 02:08:02,450
而在寫窗口
對於所有的問題

2596
02:08:02,450 --> 02:08:04,366
你會通過引導
所有的命令

2597
02:08:04,366 --> 02:08:08,330
我當然知道，從
現在大量的實踐，

2598
02:08:08,330 --> 02:08:10,380
但可能已飛過
在一個人的頭了。

2599
02:08:10,380 --> 02:08:11,580
這是完全的罰款。

2600
02:08:11,580 --> 02:08:14,230
>> 但是，最終，你會
開始看到的模式出現。

2601
02:08:14,230 --> 02:08:17,260
而一旦你過去所有的
愚蠢的細節，比如括號，

2602
02:08:17,260 --> 02:08:19,710
和大括號和分號，
和東西，坦率地說，

2603
02:08:19,710 --> 02:08:22,360
這不是在所有的
智力有趣。

2604
02:08:22,360 --> 02:08:25,690
它不是客觀
服用任何入門級。

2605
02:08:25,690 --> 02:08:27,410
它是將要事情的想法。

2606
02:08:27,410 --> 02:08:29,659
>> 它的循環，而
條件，以及功能，

2607
02:08:29,659 --> 02:08:33,552
和更有力的抽象，
與上面的代碼保理，

2608
02:08:33,552 --> 02:08:36,510
和良好的設計，以及良好的
風格，最終的正確性

2609
02:08:36,510 --> 02:08:40,330
你的代碼，這是最終
事情影響最大。

2610
02:08:40,330 --> 02:08:43,925
所以下週，我們將採取以下
想法，我們第一次看到划痕

2611
02:08:43,925 --> 02:08:45,800
現在已經翻譯
到C.我們將開始

2612
02:08:45,800 --> 02:08:48,740
引進第一的
當然，真實世界的領域。

2613
02:08:48,740 --> 02:08:53,140
>> 我們將專注於安全領域，
更具體密碼學，

2614
02:08:53,140 --> 02:08:54,980
藝術擾碼信息。

2615
02:08:54,980 --> 02:08:57,000
和第一批
你自己的問題，你

2616
02:08:57,000 --> 02:08:59,840
將得到超越寫
與一些語法的打

2617
02:08:59,840 --> 02:09:02,880
和解決一些邏輯
問題，最終沒多久，

2618
02:09:02,880 --> 02:09:06,960
是真正爭我奪，或加密，
並最終解密信息。

2619
02:09:06,960 --> 02:09:09,470
而我們所做的一切
今天，將相當低

2620
02:09:09,470 --> 02:09:12,190
的水平，只是要允許
我們採取之一，和一，

2621
02:09:12,190 --> 02:09:16,550
以上朝著一個步驟
寫作最有趣的代碼呢。

2622
02:09:16,550 --> 02:09:18,050
>> 因此，更多的是在下週。

2623
02:09:18,050 --> 02:09:20,834

2624
02:09:20,834 --> 02:09:21,762
>> [視頻回放]

2625
02:09:21,762 --> 02:09:22,690

2626
02:09:22,690 --> 02:09:25,006
>>  - 什麼，你能告訴我
您看見他是什麼時候？

2627
02:09:25,006 --> 02:09:29,041

2628
02:09:29,041 --> 02:09:30,040
 - 什麼我可以說，真的嗎？

2629
02:09:30,040 --> 02:09:33,500

2630
02:09:33,500 --> 02:09:38,340
我的意思是，它像任何其他
生產前的排練，

2631
02:09:38,340 --> 02:09:43,510
但有些事情，他說
在最後與我卡住了。

2632
02:09:43,510 --> 02:09:47,810

2633
02:09:47,810 --> 02:09:49,640
>>  - 這是CS50。

2634
02:09:49,640 --> 02:09:52,440

2635
02:09:52,440 --> 02:09:55,190
>>  - 那是一個切大家，
在排練偉大的工作。

2636
02:09:55,190 --> 02:09:56,070
>>  - 這就是午餐？

2637
02:09:56,070 --> 02:09:57,986
>> 是啊，你和我可以
搶位三明治。

2638
02:09:57,986 --> 02:10:01,380
我只是聽取匯報
大衛真的很快。

2639
02:10:01,380 --> 02:10:02,160
大衛？

2640
02:10:02,160 --> 02:10:04,260
大衛？

2641
02:10:04,260 --> 02:10:06,110
>> [結束播放]

