1
00:00:00,000 --> 00:00:00,500

2
00:00:00,500 --> 00:00:02,490
[RIPRODUZIONE DI BRANI MUSICALI]

3
00:00:02,490 --> 00:00:16,950

4
00:00:16,950 --> 00:00:19,240
>> David J. MALAN: Va bene, questo è CS50.

5
00:00:19,240 --> 00:00:21,010
E questo è uno settimana.

6
00:00:21,010 --> 00:00:25,050
Così ricordare che l'ultima volta a settimana pari a zero,
ci siamo concentrati sul pensiero computazionale.

7
00:00:25,050 --> 00:00:28,440
E noi la transizione da quello a
Scratch, una programmazione grafica

8
00:00:28,440 --> 00:00:30,360
lingua da parte dei nostri amici
al Media Lab del MIT.

9
00:00:30,360 --> 00:00:34,730
>> E con Scratch, abbiamo esplorare
idee come funzioni e le condizioni,

10
00:00:34,730 --> 00:00:38,210
e loop, e variabili, e anche
eventi e discussioni, e altro ancora.

11
00:00:38,210 --> 00:00:40,880
E oggi, stiamo andando a
continuare a usare quelle idee,

12
00:00:40,880 --> 00:00:43,630
e davvero li prendere per
scontato, ma tradurli

13
00:00:43,630 --> 00:00:47,220
in un'altra lingua conosciuta come C. Ora,
C è un linguaggio più tradizionale.

14
00:00:47,220 --> 00:00:49,020
Si tratta di un livello più basso
lingua, se si vuole.

15
00:00:49,020 --> 00:00:50,300
>> E 'puramente testuale.

16
00:00:50,300 --> 00:00:52,910
E così, a prima vista, è
tutto andando a guardare piuttosto criptico

17
00:00:52,910 --> 00:00:54,430
se non hai mai programmato prima.

18
00:00:54,430 --> 00:00:56,530
Stiamo per avere
punto e virgola, e parentesi,

19
00:00:56,530 --> 00:00:58,150
e parentesi graffe, e altro ancora.

20
00:00:58,150 --> 00:01:00,240
Ma rendersi conto che anche
anche se la sintassi è

21
00:01:00,240 --> 00:01:03,600
per guardare un po 'sconosciuto
per la maggior parte di voi, vedere oltre quello.

22
00:01:03,600 --> 00:01:06,220
E cercare di vedere le idee
che sono, infatti, familiare,

23
00:01:06,220 --> 00:01:09,750
perché qui in settimana una cosa
inizieremo a fare è quello di confrontare,

24
00:01:09,750 --> 00:01:11,980
Inizialmente, Scratch contro C.

25
00:01:11,980 --> 00:01:15,350
>> Così, per esempio, ricordare che quando
implementato il primo dei nostri programmi

26
00:01:15,350 --> 00:01:19,220
l'ultima volta, abbiamo avuto un blocco che sembrava
un po 'di qualcosa come questo-- quando

27
00:01:19,220 --> 00:01:22,990
bandiera verde cliccato, e poi abbiamo avuto
uno o più pezzi del puzzle sotto di essa,

28
00:01:22,990 --> 00:01:25,150
in questo caso, dire, ciao mondo.

29
00:01:25,150 --> 00:01:27,870
Così, infatti, in Scratch,
quando si sceglie quella bandiera verde

30
00:01:27,870 --> 00:01:30,390
per eseguire il mio programma, in modo da
parlare, questi sono

31
00:01:30,390 --> 00:01:32,520
i blocchi che vengono eseguiti o eseguiti.

32
00:01:32,520 --> 00:01:35,230
E, in particolare, Scratch
detto, ciao, mondo.

33
00:01:35,230 --> 00:01:38,377
>> Ora, avrei potuto specificato
parole diverse qui.

34
00:01:38,377 --> 00:01:40,960
Ma vedremo che, in effetti, molti
di questi blocks-- e in effetti,

35
00:01:40,960 --> 00:01:44,880
in C molti functions-- possono essere
parametrizzate o personalizzato

36
00:01:44,880 --> 00:01:46,150
di fare cose diverse.

37
00:01:46,150 --> 00:01:48,520
Infatti, in C se
desidera convertire, ora,

38
00:01:48,520 --> 00:01:50,567
questo programma Scratch
a tale lingua,

39
00:01:50,567 --> 00:01:52,650
stiamo andando a dare una
po 'di qualcosa di simile.

40
00:01:52,650 --> 00:01:55,540
>> Certo, vi è una certa familiarità
sintassi lì molto probabilmente, int,

41
00:01:55,540 --> 00:01:57,380
e tra parentesi, e vuoto.

42
00:01:57,380 --> 00:02:00,740
Ma printf-- anche se si farebbe
penso che sarebbe solo di stampa.

43
00:02:00,740 --> 00:02:03,120
Ma stampa significa stampa
formattato, come vedremo tra poco.

44
00:02:03,120 --> 00:02:05,140
Questo letteralmente stamperà
alla schermata qualunque

45
00:02:05,140 --> 00:02:08,990
è all'interno di quelle parentesi, che
Naturalmente in questo caso è, ciao mondo.

46
00:02:08,990 --> 00:02:12,290
>> Ma si noterà qualche altro
sintassi, alcuni doppi apici,

47
00:02:12,290 --> 00:02:14,890
che le parentesi alla fine,
il semi-colon e simili.

48
00:02:14,890 --> 00:02:18,027
Quindi c'è un po 'di testa,
per così dire, sia cognitivamente

49
00:02:18,027 --> 00:02:20,860
e sintatticamente, che stiamo andando
di dover ricordare in breve tempo.

50
00:02:20,860 --> 00:02:23,720
Ma rendersi conto che con la pratica,
questo inizierà a saltare fuori di te.

51
00:02:23,720 --> 00:02:27,920
>> In effetti, concentriamoci su quello
Funzione specifically-- in questo caso,

52
00:02:27,920 --> 00:02:29,290
dire ciao mondo.

53
00:02:29,290 --> 00:02:30,560
Quindi dire che è la funzione.

54
00:02:30,560 --> 00:02:34,320
Ciao mondo è il suo parametro,
o argomento, la sua personalizzazione.

55
00:02:34,320 --> 00:02:37,320
>> E l'equivalenza in C è solo
sta per essere presente una riga qui,

56
00:02:37,320 --> 00:02:41,710
dove printf è equivalente a, diciamo,
la stringa doppia citato, ciao

57
00:02:41,710 --> 00:02:44,470
mondo è equivalente, naturalmente,
a ciò che è nel riquadro bianco lì.

58
00:02:44,470 --> 00:02:48,680
E il backslash n, anche se un po '
strano e assente da zero,

59
00:02:48,680 --> 00:02:52,380
semplicemente sta per avere l'effetto faremo
vedere in un computer, come il mio Mac o un PC,

60
00:02:52,380 --> 00:02:54,660
di appena spostare il
cursore alla riga successiva.

61
00:02:54,660 --> 00:02:56,970
E 'come colpire
Invio sulla tastiera.

62
00:02:56,970 --> 00:02:58,580
>> Così vedremo di nuovo in poco tempo.

63
00:02:58,580 --> 00:03:01,640
Ma prima, diamo uno sguardo a questo
altro esempio nel caso di loop.

64
00:03:01,640 --> 00:03:05,830
Abbiamo avuto questo per sempre anello ultima volta,
che era una serie di pezzi del puzzle

65
00:03:05,830 --> 00:03:08,490
che ha fatto qualcosa di letteralmente
forever-- in questo caso,

66
00:03:08,490 --> 00:03:11,360
dire ciao mondo, ciao mondo,
Ciao mondo, ciao mondo.

67
00:03:11,360 --> 00:03:13,350
Quindi è un ciclo infinito di progettazione.

68
00:03:13,350 --> 00:03:17,580
>> In C, se vogliamo attuare questa
stessa idea, si potrebbe semplicemente fare questo.

69
00:03:17,580 --> 00:03:22,570
Mentre vero, printf ciao world-- ora
mentre, solo semanticamente, tipo di

70
00:03:22,570 --> 00:03:26,090
evoca l'idea di fare
qualcosa di nuovo, e ancora, e ancora,

71
00:03:26,090 --> 00:03:26,980
e per quanto tempo?

72
00:03:26,980 --> 00:03:30,990
Beh, ricordo che true--
vero è solo su uno o.

73
00:03:30,990 --> 00:03:33,660
>> E vero è, ovviamente, sempre vero.

74
00:03:33,660 --> 00:03:36,060
Quindi è una specie di un insignificante
dichiarazione solo per dire vero.

75
00:03:36,060 --> 00:03:39,890
Ma in effetti, questo è intenzionale,
perché se è vero è proprio sempre vero,

76
00:03:39,890 --> 00:03:43,850
che mentre vero implica solo,
se un po indirettamente,

77
00:03:43,850 --> 00:03:47,070
che le seguenti righe di codice
tra questi parentesi graffe

78
00:03:47,070 --> 00:03:51,320
deve solo eseguire di nuovo, e di nuovo,
e ancora, e in realtà mai smettere.

79
00:03:51,320 --> 00:03:53,230
>> Ma se volete che il vostro
ciclo di fermarsi, come noi

80
00:03:53,230 --> 00:03:57,500
fatto l'ultima volta con qualcosa di simile
questo, ripetere i seguenti 50 volte,

81
00:03:57,500 --> 00:04:00,700
in C siamo in grado di fare lo stesso con ciò che è
chiamato per loop-- la parola chiave

82
00:04:00,700 --> 00:04:02,330
non essendo mentre, ma per.

83
00:04:02,330 --> 00:04:06,290
E poi abbiamo un po 'di nuova sintassi qui,
con int i è uguale a 0, i meno di 50,

84
00:04:06,290 --> 00:04:06,880
i ++.

85
00:04:06,880 --> 00:04:08,430
E ci torneremo a questo.

86
00:04:08,430 --> 00:04:12,660
Ma questo è semplicemente il modo in cui sarebbe
tradurre l'insieme di blocchi Scratch

87
00:04:12,660 --> 00:04:16,079
ad un insieme di linee di codice C.

88
00:04:16,079 --> 00:04:17,450
>> Nel frattempo, in considerazione variabili.

89
00:04:17,450 --> 00:04:19,540
E, infatti, abbiamo appena
visto uno un attimo fa.

90
00:04:19,540 --> 00:04:24,220
E nel caso di Scratch, se
ha voluto dichiarare una variabile denominata i

91
00:04:24,220 --> 00:04:27,590
per i essendo intero, solo un numero,
e vogliamo impostarlo su un certo valore,

92
00:04:27,590 --> 00:04:31,410
useremmo questo arancione
bloccare qui-- ho impostato a 0.

93
00:04:31,410 --> 00:04:33,800
>> E vedremo oggi e
al di là, proprio come la settimana scorsa,

94
00:04:33,800 --> 00:04:36,850
i programmatori fanno quasi sempre
iniziare a contare da zero, davvero

95
00:04:36,850 --> 00:04:37,950
per convenzione.

96
00:04:37,950 --> 00:04:40,250
Ma anche perché il richiamo da
la nostra discussione di binario,

97
00:04:40,250 --> 00:04:42,990
il minor numero possibile
rappresentare qualsiasi numero di bit

98
00:04:42,990 --> 00:04:44,640
è solo andare a essere 0 se stesso.

99
00:04:44,640 --> 00:04:48,190
E così faremo in genere inizia
inizializzazione anche le nostre variabili a 0.

100
00:04:48,190 --> 00:04:50,710
>> E in C a fare lo stesso,
stiamo andando a dire int

101
00:04:50,710 --> 00:04:53,110
per intero, ho solo per convenzione.

102
00:04:53,110 --> 00:04:56,390
Avrei potuto chiamare questa variabile
tutto quello che voglio, proprio come in Scratch.

103
00:04:56,390 --> 00:05:00,770
E poi è uguale a 0 solo cessionari
il valore 0 da destra

104
00:05:00,770 --> 00:05:04,319
e lo mette nella variabile, o
contenitore lì, sulla sinistra.

105
00:05:04,319 --> 00:05:07,360
E il punto e virgola come vedremo see-- e
abbiamo visto alcuni di questi already--

106
00:05:07,360 --> 00:05:09,530
significa solo fine di pensiero.

107
00:05:09,530 --> 00:05:12,430
Procedere a fare qualcosa di diverso
sulle linee che seguono.

108
00:05:12,430 --> 00:05:14,330
>> Ora, per quanto riguarda le espressioni booleane?

109
00:05:14,330 --> 00:05:17,320
Ricordiamo che in Scratch,
queste erano espressioni

110
00:05:17,320 --> 00:05:19,740
che sono o vere
o domande false--,

111
00:05:19,740 --> 00:05:21,910
in realtà, che sono o vere o false.

112
00:05:21,910 --> 00:05:24,960
Quindi, nel caso di Scratch, potremmo
fare una semplice domanda come questa,

113
00:05:24,960 --> 00:05:27,586
Sono io meno di 50?

114
00:05:27,586 --> 00:05:28,710
Così ho, ancora una volta, è un numero intero.

115
00:05:28,710 --> 00:05:30,210
Forse stiamo usando
in un programma Scratch

116
00:05:30,210 --> 00:05:32,310
per tenere traccia di un punteggio
o qualcosa di simile.

117
00:05:32,310 --> 00:05:36,810
Quindi, questa sintassi qui a Scratch
significa semplicemente, è che a meno di 50?

118
00:05:36,810 --> 00:05:40,330
Beh, per fortuna, qualcosa è
semplice in C. E da tradurre,

119
00:05:40,330 --> 00:05:44,780
questo si sarebbe semplicemente dire che sono meno
di 50, utilizzando la chiave familiare

120
00:05:44,780 --> 00:05:45,850
sulla tastiera.

121
00:05:45,850 --> 00:05:48,141
>> Nel frattempo, se si voleva
dire qualcosa di più generale,

122
00:05:48,141 --> 00:05:52,890
come, beh, è ​​x meno y dove ogni
di X e Y sono variabili se stessi?

123
00:05:52,890 --> 00:05:55,280
Siamo in grado di fare la stessa cosa
in C, fino a quando abbiamo

124
00:05:55,280 --> 00:05:56,942
creato queste variabili già.

125
00:05:56,942 --> 00:05:58,650
E vedremo come
farlo in breve tempo.

126
00:05:58,650 --> 00:06:01,590
Vorremmo semplicemente dire x meno y.

127
00:06:01,590 --> 00:06:03,530
>> Quindi, si sta iniziando a
vedere alcune somiglianze.

128
00:06:03,530 --> 00:06:06,490
E quelle persone che hanno fatto
Scratch erano certamente

129
00:06:06,490 --> 00:06:08,250
ispirato da alcune di queste idee di base.

130
00:06:08,250 --> 00:06:13,350
E vedrete questo tipo di
sintassi in molti languages--

131
00:06:13,350 --> 00:06:15,160
non solo graffio, non
solo C, ma Python,

132
00:06:15,160 --> 00:06:17,790
e JavaScript, e
altre lingue ancora.

133
00:06:17,790 --> 00:06:21,270
>> Prendiamo in considerazione un altro costrutto
da C, il concetto di una condizione,

134
00:06:21,270 --> 00:06:23,370
fare qualcosa condizionale.

135
00:06:23,370 --> 00:06:25,720
Se qualcosa è vero, fare questo.

136
00:06:25,720 --> 00:06:27,457
Se qualcosa è vero, farlo.

137
00:06:27,457 --> 00:06:30,040
È una specie di programmazione
equivalente di un bivio.

138
00:06:30,040 --> 00:06:32,730
Forse è una forchetta a due vie,
a tre vie forcella, o più.

139
00:06:32,730 --> 00:06:35,800
E in Scratch, potremmo avere
visto qualcosa di simile.

140
00:06:35,800 --> 00:06:37,010
>> Quindi questo è un grande.

141
00:06:37,010 --> 00:06:39,750
Ma prendere in considerazione la relativa
semplicità della logica.

142
00:06:39,750 --> 00:06:47,010
Se x è minore di y, allora dire che x è meno
di y, altrimenti se x è maggiore di y,

143
00:06:47,010 --> 00:06:49,230
poi dicono x è maggiore di y.

144
00:06:49,230 --> 00:06:51,300
E poi, logicamente, se
si ripensa a Scratch

145
00:06:51,300 --> 00:06:55,610
o semplicemente il proprio intuito umano,
bene, se x non è maggiore di y, e x

146
00:06:55,610 --> 00:07:00,000
non è minore di y, allora naturalmente
x sta per essere uguale a y.

147
00:07:00,000 --> 00:07:02,690
Quindi in questo caso, per nesting
quei blocchi Scratch,

148
00:07:02,690 --> 00:07:05,580
possiamo raggiungere tre
modo bivio?

149
00:07:05,580 --> 00:07:07,980
>> Nel frattempo, se vogliamo
farlo in C, probabilmente

150
00:07:07,980 --> 00:07:11,420
sembra un po 'simpler-- almeno
Una volta acquisita familiarità con la sintassi.

151
00:07:11,420 --> 00:07:15,050
Se x è minore di y,
printf x è minore di y.

152
00:07:15,050 --> 00:07:19,140
Altrimenti, se x è maggiore di y,
printf x è maggiore di y.

153
00:07:19,140 --> 00:07:24,210
Else printf x è uguale a y-- e,
ancora una volta, con quelli backslash finisce proprio

154
00:07:24,210 --> 00:07:27,160
per quelle nuove linee in modo che se si
in realtà correva questo tipo di programma

155
00:07:27,160 --> 00:07:28,940
sarebbe solo spostare
il cursore in ultima analisi,

156
00:07:28,940 --> 00:07:31,100
alla riga successiva della schermata.

157
00:07:31,100 --> 00:07:34,270
>> Ora, nel frattempo Scratch aveva altra
funzioni più sofisticate, solo

158
00:07:34,270 --> 00:07:37,320
alcuni dei quali andremo a
inizialmente passare al mondo di C.

159
00:07:37,320 --> 00:07:40,010
E uno di loro era
chiamato una lista in Scratch.

160
00:07:40,010 --> 00:07:42,100
E questa era una speciale
tipo di variabile che

161
00:07:42,100 --> 00:07:45,840
ha permesso di memorizzare più cose
in indietro, alla parte posteriore, alla schiena, alla parte posteriore.

162
00:07:45,840 --> 00:07:48,540
>> In C, non ha
liste, di per sé, ma qualcosa

163
00:07:48,540 --> 00:07:51,090
che sono più generalmente
chiamato array, anche se ti

164
00:07:51,090 --> 00:07:53,590
tornare più tardi questo semestre
a guardare qualcosa

165
00:07:53,590 --> 00:07:55,780
chiamato una lista, o realmente una lista collegata.

166
00:07:55,780 --> 00:07:58,510
Ma per ora, la più vicina
equivalente in C per noi

167
00:07:58,510 --> 00:08:00,345
sta per essere qualcosa
chiamato un array.

168
00:08:00,345 --> 00:08:02,740
E un array è semplicemente un
speciale tipo di variabile

169
00:08:02,740 --> 00:08:06,160
che consente di memorizzare i dati
indietro, alla parte posteriore, alla schiena, alla schiena.

170
00:08:06,160 --> 00:08:08,840
>> E, in effetti, in Scratch,
se volessimo accedere

171
00:08:08,840 --> 00:08:12,030
il primo elemento di un array o
un list-- e ho intenzione di chiamarlo,

172
00:08:12,030 --> 00:08:16,600
per convenzione, argv, argomento
vettore, ma più su che tra non molto.

173
00:08:16,600 --> 00:08:20,090
Se voglio arrivare al primo elemento
di argv, nel mondo di Scratch

174
00:08:20,090 --> 00:08:23,930
effettivamente fare tipicamente
iniziare il conteggio da 1.

175
00:08:23,930 --> 00:08:25,850
>> E così potrei ottenere punto 1 di argv.

176
00:08:25,850 --> 00:08:29,310
Questo è solo il modo MIT implementato
la nozione di liste.

177
00:08:29,310 --> 00:08:32,860
Ma in C, ho intenzione di
più semplicemente solo dire, argv,

178
00:08:32,860 --> 00:08:35,758
che ancora una volta è il nome del mio
list-- o per essere chiari, un array.

179
00:08:35,758 --> 00:08:37,549
E se voglio la prima
Elementi, sto andando

180
00:08:37,549 --> 00:08:40,890
per usare le parentesi quadre, che si
potrebbe non spesso usato sotto una tastiera.

181
00:08:40,890 --> 00:08:43,150
>> Ma 0 significa solo, mi ottenere il primo.

182
00:08:43,150 --> 00:08:45,160
Quindi, in occasione e come
il tempo passa, stiamo andando

183
00:08:45,160 --> 00:08:47,570
per iniziare a vedere queste dicotomie
tra il Gratta e C,

184
00:08:47,570 --> 00:08:49,070
per cui Scratch utilizza uno.

185
00:08:49,070 --> 00:08:50,670
Siamo in C 0 per questo.

186
00:08:50,670 --> 00:08:52,420
Ma vedrete rapidamente
una volta capito

187
00:08:52,420 --> 00:08:55,920
le fondamenta di ogni lingua, che
queste cose cominciano a farsi sempre più

188
00:08:55,920 --> 00:08:59,860
familiare attraverso la pratica e la pratica.

189
00:08:59,860 --> 00:09:02,700
>> Quindi cerchiamo di guardare in realtà ora ad un programma.

190
00:09:02,700 --> 00:09:07,031
Qui sarà il primo della nostra C
codice sorgente di programmi completi.

191
00:09:07,031 --> 00:09:09,280
E il programma stiamo andando
di offrire a titolo oneroso

192
00:09:09,280 --> 00:09:12,340
è quello che è equivalente
a quel pezzo Scratch in precedenza.

193
00:09:12,340 --> 00:09:16,210
>> Così qui, abbiamo ciò che è
probabilmente il più semplice programma in C

194
00:09:16,210 --> 00:09:18,410
si può scrivere che
in realtà fa qualcosa.

195
00:09:18,410 --> 00:09:21,250
Ora, vedremo passato,
per ora, è comprendere,

196
00:09:21,250 --> 00:09:24,190
io.h di serie, e questi l'angolo
staffe, e int, e vuoto,

197
00:09:24,190 --> 00:09:25,840
e le parentesi graffe, e simili.

198
00:09:25,840 --> 00:09:28,390
>> E facciamo solo concentrarsi su
ciò, almeno intuitivamente,

199
00:09:28,390 --> 00:09:29,860
potrebbe saltare fuori a voi già.

200
00:09:29,860 --> 00:09:33,300
In realtà, principale, non lo faccio
necessariamente sapere di cosa si tratta,

201
00:09:33,300 --> 00:09:37,580
ma molto simile a Scratch avevano che quando
bandiera verde cliccato pezzo di puzzle,

202
00:09:37,580 --> 00:09:42,070
così fa C come linguaggio di programmazione
avere un pezzo principale di codice che

203
00:09:42,070 --> 00:09:46,380
viene eseguito per impostazione predefinita. E senza dubbio,
è letteralmente sta per essere chiamato principale.

204
00:09:46,380 --> 00:09:47,720
>> Così principale è una funzione.

205
00:09:47,720 --> 00:09:51,720
Ed è una funzione speciale che esiste
in C che quando si esegue un programma,

206
00:09:51,720 --> 00:09:55,720
è principale che viene gestito da
predefinito. Nel mondo di Scratch,

207
00:09:55,720 --> 00:09:59,970
era solito quando bandiera verde
cliccato che ha ottenuto eseguito per impostazione predefinita.

208
00:09:59,970 --> 00:10:04,130
>> Nel frattempo, abbiamo visto prima,
printf o stampare in formato, che è

209
00:10:04,130 --> 00:10:08,620
sarà una funzione che viene con
C, insieme a tutta una serie di altri,

210
00:10:08,620 --> 00:10:13,140
che la volontà da tempo e il tempo
di nuovo, al fine di fare esattamente

211
00:10:13,140 --> 00:10:15,450
come suggerisce il nome, stampare qualcosa.

212
00:10:15,450 --> 00:10:16,500
Cosa vogliamo stampare?

213
00:10:16,500 --> 00:10:18,770
Bene, vedremo che
da personaggi che racchiudono

214
00:10:18,770 --> 00:10:21,680
come these-- mondo ciao,
backslash n tra virgolette,

215
00:10:21,680 --> 00:10:26,040
possiamo dire esattamente printf
quello di stampare sullo schermo.

216
00:10:26,040 --> 00:10:29,430
>> Ma per fare
che, purtroppo

217
00:10:29,430 --> 00:10:33,010
bisogno di prendere qualcosa che è
già criptico per noi esseri umani,

218
00:10:33,010 --> 00:10:37,510
ma almeno è un po 'readable--
affilato includono, di serie io.h, int,

219
00:10:37,510 --> 00:10:42,340
principale, vuoto, printf, tutta la magica
incantesimi che abbiamo appena visto sullo schermo.

220
00:10:42,340 --> 00:10:45,470
Ma in realtà abbiamo a
andare più arcana ancora.

221
00:10:45,470 --> 00:10:50,140
In primo luogo abbiamo bisogno di tradurre il codice
che scriviamo in codice macchina.

222
00:10:50,140 --> 00:10:54,370
E ricordare della settimana scorsa che le macchine,
almeno quelli che conosciamo qui,

223
00:10:54,370 --> 00:10:57,450
alla fine della giornata solo
comprendere zero e uno.

224
00:10:57,450 --> 00:11:01,100
>> E il mio Dio, se abbiamo dovuto scrivere questi
zero e uno in realtà il programma,

225
00:11:01,100 --> 00:11:04,260
sarebbe molto, molto rapidamente
togliere il divertimento di qualsiasi cosa.

226
00:11:04,260 --> 00:11:08,150
Ma si scopre, per la settimana scorsa,
che questi schemi di zero e uno

227
00:11:08,150 --> 00:11:09,400
appena hanno un significato speciale.

228
00:11:09,400 --> 00:11:11,500
In alcuni contesti,
potrebbero significare numeri.

229
00:11:11,500 --> 00:11:14,840
>> In alcuni contesti, che potrebbero significare
lettere, o colori, o un qualsiasi numero

230
00:11:14,840 --> 00:11:17,710
di altre astrazioni lì sopra.

231
00:11:17,710 --> 00:11:21,450
Ma proprio come il computer ha
una CPU, Central Processing Unit,

232
00:11:21,450 --> 00:11:23,390
o il cervello all'interno del computer.

233
00:11:23,390 --> 00:11:25,240
Di solito Intel
dentro, perché è

234
00:11:25,240 --> 00:11:27,900
una delle più grandi aziende
che rende le CPU per i computer.

235
00:11:27,900 --> 00:11:31,910
>> Beh, le CPU Intel e gli altri
semplicemente hanno deciso in anticipo

236
00:11:31,910 --> 00:11:36,970
che alcuni modelli di zeri e
quelli si intendono cose specifiche.

237
00:11:36,970 --> 00:11:40,040
Alcuni modelli di zero e uno
significherà, stampare questa sullo schermo,

238
00:11:40,040 --> 00:11:42,710
o aggiungere questi due numeri, o
sottrarre questi due numeri,

239
00:11:42,710 --> 00:11:46,310
o spostare questo pezzo di dati da
la memoria del mio computer qui,

240
00:11:46,310 --> 00:11:50,870
o un qualsiasi numero di altri livelli molto bassi,
ma alla fine utile, le operazioni.

241
00:11:50,870 --> 00:11:56,022
Ma, per fortuna, noi esseri umani non stanno andando
ad avere bisogno di conoscere questo livello di dettaglio.

242
00:11:56,022 --> 00:11:59,230
Infatti, proprio come l'ultima volta, dove abbiamo
Sottratto ancora, e ancora, e ancora,

243
00:11:59,230 --> 00:12:01,930
edificio da un livello molto basso
primitive come zero e uno

244
00:12:01,930 --> 00:12:04,160
ai concetti di livello superiore
come i numeri e lettere,

245
00:12:04,160 --> 00:12:07,330
e colori, e di più,
in modo che possiamo come programmatori

246
00:12:07,330 --> 00:12:10,080
stare in piedi sulle spalle di
altri che sono venuti prima di noi

247
00:12:10,080 --> 00:12:14,260
e usare il software che altro
persone hanno scritto prima noi--

248
00:12:14,260 --> 00:12:17,340
vale a dire i programmi chiamati compilatori.

249
00:12:17,340 --> 00:12:20,770
>> C è un linguaggio che
di solito è compilato,

250
00:12:20,770 --> 00:12:25,130
che significa convertito da
codice sorgente in codice macchina.

251
00:12:25,130 --> 00:12:28,230
In particolare, ciò che questo significa
è che se hai la tua fonte

252
00:12:28,230 --> 00:12:32,530
codice che si scrive da soli, come abbiamo appena
sarà in un momento sullo schermo,

253
00:12:32,530 --> 00:12:36,140
e volete convertirlo
in ultima analisi, di lavorare code--

254
00:12:36,140 --> 00:12:40,100
tali zeri e quelli che
solo il vostro Mac o PC

255
00:12:40,100 --> 00:12:44,230
understands-- hai una prima
alimentare che il codice sorgente come

256
00:12:44,230 --> 00:12:49,340
ingresso ad una speciale
programma chiamato compilatore,

257
00:12:49,340 --> 00:12:51,974
la cui uscita si
deve vedere è codice macchina.

258
00:12:51,974 --> 00:12:54,890
E, in effetti, l'ultima volta che abbiamo parlato
merito, davvero, alla fine della giornata,

259
00:12:54,890 --> 00:12:55,610
problem solving.

260
00:12:55,610 --> 00:12:56,360
Hai ingressi.

261
00:12:56,360 --> 00:12:57,318
E hai uscite.

262
00:12:57,318 --> 00:12:59,560
E hai qualche tipo
dell'algoritmo nel mezzo.

263
00:12:59,560 --> 00:13:02,830
>> Gli algoritmi possono essere sicuramente
implementato nel software,

264
00:13:02,830 --> 00:13:05,900
come abbiamo visto con pseudocodice la scorsa settimana
e come vedremo con codice vero e proprio

265
00:13:05,900 --> 00:13:06,490
questa settimana.

266
00:13:06,490 --> 00:13:09,430
E così un compilatore in realtà solo
ha una serie di algoritmi all'interno

267
00:13:09,430 --> 00:13:13,060
di esso che sanno
convertire le parole chiave speciali,

268
00:13:13,060 --> 00:13:15,180
come principale, e printf,
e altri che abbiamo appena

269
00:13:15,180 --> 00:13:20,620
ha visto negli schemi di zeri e
quelli che Intel Inside e altre CPU

270
00:13:20,620 --> 00:13:23,020
in realtà capisce.

271
00:13:23,020 --> 00:13:25,460
Quindi, come facciamo questo?

272
00:13:25,460 --> 00:13:27,470
Dove possiamo ottenere un compilatore?

273
00:13:27,470 --> 00:13:29,400
>> La maggior parte di noi qui hanno un Mac o un PC.

274
00:13:29,400 --> 00:13:32,152
E si sta eseguendo Mac OS, o
Windows o Linux, o Solaris,

275
00:13:32,152 --> 00:13:33,860
o un qualsiasi numero di altri
sistemi operativi.

276
00:13:33,860 --> 00:13:35,568
E, in effetti, si potrebbe
uscire sul web

277
00:13:35,568 --> 00:13:38,710
e scaricare un compilatore
per il vostro Mac o PC

278
00:13:38,710 --> 00:13:40,360
per il sistema operativo.

279
00:13:40,360 --> 00:13:42,617
Ma saremmo tutti su
diverse pagine, per così dire.

280
00:13:42,617 --> 00:13:44,450
Avremmo un po '
diverse configurazioni.

281
00:13:44,450 --> 00:13:46,210
E le cose non avrebbero funzionato lo stesso.

282
00:13:46,210 --> 00:13:48,280
E, in effetti, in questi giorni
molti di noi non utilizzare

283
00:13:48,280 --> 00:13:50,516
un software che gira solo su i nostri computer portatili.

284
00:13:50,516 --> 00:13:52,390
Invece, usiamo qualcosa
come un browser

285
00:13:52,390 --> 00:13:55,930
ci permette di accesso basato sul Web
applicazioni nel cloud.

286
00:13:55,930 --> 00:13:58,630
E più tardi questo semestre,
faremo esattamente questo.

287
00:13:58,630 --> 00:14:02,660
Scriveremo applicazioni o
software utilizzando code-- non C,

288
00:14:02,660 --> 00:14:05,860
ma altri linguaggi come Python e
Javascript-- che funzionano in the cloud.

289
00:14:05,860 --> 00:14:08,860
>> E per farlo, noi stessi
durante il semestre

290
00:14:08,860 --> 00:14:14,890
effettivamente utilizzare una base di cloud
ambiente conosciuto come CS50 IDE.

291
00:14:14,890 --> 00:14:19,030
Questa è una programmazione web-based
ambiente, o di sviluppo integrato

292
00:14:19,030 --> 00:14:23,610
ambiente, IDE, che è costruito in cima ad un certo
software open source chiamato Cloud 9.

293
00:14:23,610 --> 00:14:25,966
E abbiamo fatto un po 'pedagogica
semplificazioni ad esso

294
00:14:25,966 --> 00:14:28,840
in modo da nascondere determinate caratteristiche in
le prime settimane che non abbiamo bisogno,

295
00:14:28,840 --> 00:14:30,770
dopo di che è possibile
rivelarli e fare la maggior parte

296
00:14:30,770 --> 00:14:32,400
tutto quello che vuoi con l'ambiente.

297
00:14:32,400 --> 00:14:35,470
>> E ci permette, anche, per
pre-installare determinati programmi.

298
00:14:35,470 --> 00:14:38,330
Cose come un cosiddetto CS50
biblioteca, che vedremo tra poco

299
00:14:38,330 --> 00:14:42,210
ci fornisce in C con un po '
funzionalità aggiuntive.

300
00:14:42,210 --> 00:14:47,392
Quindi, se si va a, in ultima analisi, CS50.io,
ti verrà richiesto di accedere,

301
00:14:47,392 --> 00:14:49,350
e una volta che fate e creare
un account gratuito,

302
00:14:49,350 --> 00:14:55,150
si sarà in grado di accedere ad un
ambiente che sembra abbastanza come questo.

303
00:14:55,150 --> 00:14:56,760
>> Ora, questo è nella modalità predefinita.

304
00:14:56,760 --> 00:14:58,650
Tutto è bello e
luminoso sullo schermo.

305
00:14:58,650 --> 00:15:00,941
Molti di noi hanno l'abitudine di
lavorando su un pezzo che è CS50

306
00:15:00,941 --> 00:15:02,150
piuttosto tardi nella notte.

307
00:15:02,150 --> 00:15:05,400
E così alcuni di voi potrebbero preferire di
trasformarlo in modalità notte, per così dire.

308
00:15:05,400 --> 00:15:08,550
>> Ma, in ultima analisi, ciò che sei
andando a vedere all'interno CS50 IDE

309
00:15:08,550 --> 00:15:11,340
è di tre distinti areas--
un'area sulla cui sinistra

310
00:15:11,340 --> 00:15:15,604
i file saranno nel
nuvola, una zona in alto a destra

311
00:15:15,604 --> 00:15:17,270
dove il codice sta per essere modificabile.

312
00:15:17,270 --> 00:15:19,650
Sarete in grado di aprire
le schede individuali per ogni programma

313
00:15:19,650 --> 00:15:22,670
che si scrive questo semestre all'interno
di quella in alto a destra.

314
00:15:22,670 --> 00:15:26,070
E poi più arcanamente,
e tuttavia potente,

315
00:15:26,070 --> 00:15:29,610
sta per essere questa cosa al
fondo noto come una finestra di terminale.

316
00:15:29,610 --> 00:15:32,450
>> Si tratta di una vecchia scuola
Command Line Interface,

317
00:15:32,450 --> 00:15:35,240
o CLI, che permette
di eseguire comandi

318
00:15:35,240 --> 00:15:38,260
sulla computer-- in questo caso,
il computer nel cloud--

319
00:15:38,260 --> 00:15:42,090
di fare cose come compilare il codice
dal codice sorgente in codice macchina,

320
00:15:42,090 --> 00:15:46,600
per eseguire i programmi, o per iniziare la
web server, o per accedere al database,

321
00:15:46,600 --> 00:15:50,454
e qualsiasi numero di altre tecniche
che inizieremo a usare in breve tempo.

322
00:15:50,454 --> 00:15:52,370
Ma per arrivarci, siamo
andando ad avere in realtà

323
00:15:52,370 --> 00:15:54,240
di andare online e iniziare a giocare.

324
00:15:54,240 --> 00:15:57,399
E per fare questo, si deve prima
iniziare ad armeggiare con principale,

325
00:15:57,399 --> 00:15:58,940
e scrivere la parte principale di un programma.

326
00:15:58,940 --> 00:16:02,170
E cerchiamo di usare quella funzione
printf, che abbiamo utilizzato in precedenza,

327
00:16:02,170 --> 00:16:04,050
semplicemente per dire qualcosa.

328
00:16:04,050 --> 00:16:07,910
>> Così eccomi qui già dentro di CS50 IDE.

329
00:16:07,910 --> 00:16:08,930
Ho effettuato l'accesso in anticipo.

330
00:16:08,930 --> 00:16:10,360
E ho piena proiettato alla finestra.

331
00:16:10,360 --> 00:16:12,670
E così, in ultima analisi, si
Anche in problemi derivanti

332
00:16:12,670 --> 00:16:15,960
seguirà una procedura simile che
fornirà la documentazione in linea.

333
00:16:15,960 --> 00:16:19,360
Quindi non c'è bisogno di preoccuparsi
assorbendo ogni piccolo passo tecnico

334
00:16:19,360 --> 00:16:20,730
che faccio qui oggi.

335
00:16:20,730 --> 00:16:22,222
>> Ma si otterrà una schermata come questa.

336
00:16:22,222 --> 00:16:23,430
Mi capita di essere in modalità notturna.

337
00:16:23,430 --> 00:16:25,944
E si può illuminare tutto
fino disabilitando la modalità notte.

338
00:16:25,944 --> 00:16:27,860
E alla fine
giorno, si sta andando a vedere

339
00:16:27,860 --> 00:16:33,090
questi tre principali areas-- il file
del browser a sinistra, le schede di codificare fino in alto,

340
00:16:33,090 --> 00:16:35,430
e il terminale nella parte inferiore.

341
00:16:35,430 --> 00:16:37,890
>> Lasciami andare avanti e
scrivere il mio primo programma.

342
00:16:37,890 --> 00:16:45,300
Ho intenzione di andare preventivamente su File,
Salva e salvare il mio file come hello.c.

343
00:16:45,300 --> 00:16:49,850
Infatti, per convenzione, qualsiasi che il programma
scrivere che è scritto in linguaggio C

344
00:16:49,850 --> 00:16:52,739
dovrebbe essere chiamato qualcosa
dot C, per convenzione.

345
00:16:52,739 --> 00:16:56,030
Quindi ho intenzione di nominarlo hello.c, perché
Voglio solo dire ciao al mondo.

346
00:16:56,030 --> 00:16:57,820
Ora ho intenzione di zoom
fuori e fare clic su Salva.

347
00:16:57,820 --> 00:17:01,180
E tutto quello che ho qui ora è una scheda
in cui posso iniziare a scrivere codice.

348
00:17:01,180 --> 00:17:02,490
>> Questo non sta andando per la compilazione.

349
00:17:02,490 --> 00:17:03,300
Questo non significa nulla.

350
00:17:03,300 --> 00:17:05,750
E quindi, anche se mi sono convertito
questo a zero e uno,

351
00:17:05,750 --> 00:17:08,390
la CPU sta per avere nessun
idea di quello che sta succedendo intorno.

352
00:17:08,390 --> 00:17:17,170
Ma se scrivo linee che corrispondono
con conventions-- essere di C C,

353
00:17:17,170 --> 00:17:23,150
Di nuovo, questo Language, con una sintassi simile
questo, printf ciao world-- e ho

354
00:17:23,150 --> 00:17:25,210
ottenuto agio con
farlo nel tempo.

355
00:17:25,210 --> 00:17:27,510
Quindi non penso che ho fatto
eventuali errori tipografici.

356
00:17:27,510 --> 00:17:30,910
>> Ma, invariabilmente, la prima
volta che si esegue questa operazione, si farà.

357
00:17:30,910 --> 00:17:34,090
E quello che sto per fare molto potrebbe
bene non funzionare per voi la prima volta.

358
00:17:34,090 --> 00:17:36,610
E questo è perfettamente OK,
perché in questo momento si

359
00:17:36,610 --> 00:17:40,662
potrebbe anche vedere un sacco di novità,
ma nel corso del tempo, una volta acquisita familiarità

360
00:17:40,662 --> 00:17:42,870
con questo ambiente, e
questo linguaggio, e gli altri,

361
00:17:42,870 --> 00:17:45,370
si inizia a vedere cose che
sono sia giusta o sbagliata.

362
00:17:45,370 --> 00:17:47,369
>> E questo è ciò che il
compagni di insegnamento e corso

363
00:17:47,369 --> 00:17:51,780
assistenti ottenere così bravo a nel corso del tempo, è
individuare errori o bug nel codice.

364
00:17:51,780 --> 00:17:55,110
Ma io sostengo che non ci
sono errori in questo codice.

365
00:17:55,110 --> 00:17:56,990
Così ora voglio eseguire questo programma.

366
00:17:56,990 --> 00:18:00,440
>> Ora sul mio Mac o PC, sono in
l'abitudine di doppi icone di clic

367
00:18:00,440 --> 00:18:02,350
quando voglio eseguire qualche programma.

368
00:18:02,350 --> 00:18:04,080
Ma non è il modello qui.

369
00:18:04,080 --> 00:18:07,570
In questo ambiente, che è CS50 IDE.

370
00:18:07,570 --> 00:18:10,192
Stiamo utilizzando un operativo
sistema chiamato Linux.

371
00:18:10,192 --> 00:18:12,900
Linux ricorda di un altro
sistema operativo, generalmente noto

372
00:18:12,900 --> 00:18:13,850
come Unix.

373
00:18:13,850 --> 00:18:19,340
E Linux è particolarmente noto per
avere una Command Line Ambiente, CLI.

374
00:18:19,340 --> 00:18:23,070
Ora, stiamo usando una specifica
sapore di Linux chiamata Ubuntu.

375
00:18:23,070 --> 00:18:25,770
E Ubuntu è semplicemente un
determinata versione di Linux.

376
00:18:25,770 --> 00:18:30,900
>> Ma di questi Linux in questi giorni fanno in realtà
sono dotati di interfacce grafiche.

377
00:18:30,900 --> 00:18:33,360
E quello ci capita di
stia usando qui è web-based.

378
00:18:33,360 --> 00:18:35,735
Quindi questo potrebbe apparire anche una
po 'diverso da qualcosa

379
00:18:35,735 --> 00:18:38,310
lei stesso potrebbe avere
visto o eseguire in passato.

380
00:18:38,310 --> 00:18:40,910
>> Quindi ho intenzione di andare avanti
ora e fare quanto segue.

381
00:18:40,910 --> 00:18:43,950
Ho salvato questo file come hello.c.

382
00:18:43,950 --> 00:18:50,350
Ho intenzione di andare avanti e
Tipo clanghello.c Così Clang

383
00:18:50,350 --> 00:18:52,850
per il linguaggio C è un compilatore.

384
00:18:52,850 --> 00:18:54,952
E 'pre-installato in CS50 IDE.

385
00:18:54,952 --> 00:18:57,910
E si può assolutamente scaricare e
installare questo sul proprio Mac o PC.

386
00:18:57,910 --> 00:19:00,910
>> Ma, ancora una volta, si potrebbe non avere tutti
la pre-configurazione di fatto per voi.

387
00:19:00,910 --> 00:19:03,940
Quindi per ora, io sono solo
andare a correre clanghello.c.

388
00:19:03,940 --> 00:19:06,240
E ora notare questa sintassi
qui finirà

389
00:19:06,240 --> 00:19:09,930
rendo conto significa solo che io sono in un
cartella o directory chiamata di lavoro.

390
00:19:09,930 --> 00:19:14,030
Questo simbolo del dollaro è solo convenzione
di senso, digitare i comandi qui.

391
00:19:14,030 --> 00:19:17,560
>> E 'quello che si chiama un prompt, basta
per convenzione è il simbolo del dollaro.

392
00:19:17,560 --> 00:19:22,130
E se vado avanti ora e fare clic su
Invio, nulla sembra essere accaduto.

393
00:19:22,130 --> 00:19:23,930
Ma questo è in realtà una buona cosa.

394
00:19:23,930 --> 00:19:26,650
Il meno che accade sulla
lo schermo, il più probabile

395
00:19:26,650 --> 00:19:29,710
il codice è di essere corretto,
almeno sintatticamente.

396
00:19:29,710 --> 00:19:32,120
>> Quindi, se voglio correre questo
il programma, cosa devo fare?

397
00:19:32,120 --> 00:19:36,770
Beh, si scopre che il
nome di default per convenzione

398
00:19:36,770 --> 00:19:41,854
per i programmi quando non si specifica un
un nome per il vostro programma è solo a.out.

399
00:19:41,854 --> 00:19:44,270
E questa sintassi troppo, ti
acquisire familiarità con poco tempo.

400
00:19:44,270 --> 00:19:50,500
>> Dot taglio su significa semplicemente, hey, CS50
IDE, eseguire un programma chiamato a.out

401
00:19:50,500 --> 00:19:52,400
che è dentro la mia directory corrente.

402
00:19:52,400 --> 00:19:54,520
Questo punto significa che la directory corrente.

403
00:19:54,520 --> 00:19:58,040
E vedremo cosa altri tali sequenze
di personaggi significa in breve tempo.

404
00:19:58,040 --> 00:20:01,430
>> Quindi qui si va, Enter, ciao mondo.

405
00:20:01,430 --> 00:20:03,080
E si noterà, che cosa è successo?

406
00:20:03,080 --> 00:20:04,580
Non solo la stampa ciao mondo.

407
00:20:04,580 --> 00:20:08,990
E 'anche spostato il
cursore alla riga successiva.

408
00:20:08,990 --> 00:20:10,160
>> E perché è stato?

409
00:20:10,160 --> 00:20:15,400
Qual è stato il codice che abbiamo scritto prima
che ha assicurato che il cursore sarebbe

410
00:20:15,400 --> 00:20:17,882
andare sulla riga successiva?

411
00:20:17,882 --> 00:20:19,840
La cosa divertente circa un
computer è è solo andare

412
00:20:19,840 --> 00:20:21,570
di fare letteralmente quello che gli si dice di fare.

413
00:20:21,570 --> 00:20:29,050
>> Quindi, se gli si dice di printf ciao,
virgola, spazio, mondo, vicino citazione,

414
00:20:29,050 --> 00:20:32,090
E 'letteralmente solo andando
per stampare quei personaggi.

415
00:20:32,090 --> 00:20:34,980
Ma ho avuto questo carattere speciale
alla fine, richiamo, backslash n.

416
00:20:34,980 --> 00:20:37,230
Ed è quello che garantisce
che il personaggio è andato

417
00:20:37,230 --> 00:20:39,570
alla riga successiva della schermata.

418
00:20:39,570 --> 00:20:41,097
>> In realtà, mi permetta di andare a fare questo.

419
00:20:41,097 --> 00:20:42,430
Lasciami andare avanti e cancellare questo.

420
00:20:42,430 --> 00:20:44,180
Ora, si noti che la
parte superiore del mio schermo non c'è

421
00:20:44,180 --> 00:20:45,890
un po 'di luce rossa
Nella scheda che indica,

422
00:20:45,890 --> 00:20:48,047
Ehi, non hai salvato il file.

423
00:20:48,047 --> 00:20:50,880
Quindi ho intenzione di andare avanti con il controllo
S o comando S, salvare il file.

424
00:20:50,880 --> 00:20:54,130
Ora goes-- andato per un verde moment--.

425
00:20:54,130 --> 00:20:56,760
E ora si torna a
solo di essere l'icona di un vicino.

426
00:20:56,760 --> 00:21:04,860
>> Se ora corro di nuovo clanghello.c,
Invio, barra di punti, a.out, Enter,

427
00:21:04,860 --> 00:21:07,110
vedrai che funzionava ancora.

428
00:21:07,110 --> 00:21:09,020
Ma è senza dubbio un po 'buggy.

429
00:21:09,020 --> 00:21:11,714
In questo momento, il mio lavoro prompt--,
e poi che il simbolo del dollaro,

430
00:21:11,714 --> 00:21:13,880
e poi il mio prompt-- reale
è tutto sulla stessa linea.

431
00:21:13,880 --> 00:21:17,540
Quindi, questo è certamente un bug di estetica,
anche se non è proprio un errore logico.

432
00:21:17,540 --> 00:21:19,250
>> Quindi ho intenzione di disfare ciò che ho appena fatto.

433
00:21:19,250 --> 00:21:21,560
Ho intenzione di eseguire nuovamente a.out.

434
00:21:21,560 --> 00:21:25,710
Notate ho aggiunto il
carattere indietro a capo.

435
00:21:25,710 --> 00:21:27,280
Ho salvato il file.

436
00:21:27,280 --> 00:21:34,630
>> Quindi ho intenzione di eseguire nuovamente a.out, e-
dannazione, un insetto, un bug che significa errore.

437
00:21:34,630 --> 00:21:38,020
Così il bug è che anche se
Ho aggiunto il backslash n lì,

438
00:21:38,020 --> 00:21:44,180
ri-salvato, ri-corse del programma,
il comportamento era lo stesso.

439
00:21:44,180 --> 00:21:45,640
Perché sarebbe?

440
00:21:45,640 --> 00:21:46,910
>> Mi manca un passo, giusto?

441
00:21:46,910 --> 00:21:50,620
Questo passo fondamentale prima è che bisogna
a-- quando si modifica il codice sorgente,

442
00:21:50,620 --> 00:21:52,610
si scopre anche gestito
attraverso il compilatore

443
00:21:52,610 --> 00:21:54,102
ancora una volta in modo da ottenere un nuovo codice macchina.

444
00:21:54,102 --> 00:21:55,810
E il codice macchina,
le zero e uno,

445
00:21:55,810 --> 00:21:59,260
stanno per essere quasi identica, ma
non perfettamente così, perché abbiamo bisogno,

446
00:21:59,260 --> 00:22:00,510
naturalmente, che la nuova linea.

447
00:22:00,510 --> 00:22:05,640
>> Quindi, per risolvere questo problema, ho intenzione di bisogno
rieseguire clanghello.c, entrare, dot

448
00:22:05,640 --> 00:22:06,800
tagliare, a.out.

449
00:22:06,800 --> 00:22:11,402
E ora, ciao mondo è tornato
al punto in cui mi aspettavo che fosse.

450
00:22:11,402 --> 00:22:12,610
Quindi questo è tutto bello e buono.

451
00:22:12,610 --> 00:22:16,150
Ma a.out è un nome abbastanza stupido per un
programma, anche se si trova,

452
00:22:16,150 --> 00:22:19,530
per ragioni storiche, la
default-- significa uscite di montaggio.

453
00:22:19,530 --> 00:22:23,780
>> Ma mi permetta di andare avanti qui
e farlo in modo diverso.

454
00:22:23,780 --> 00:22:27,760
Voglio che il mio programma ciao mondo
in realtà essere chiamato ciao.

455
00:22:27,760 --> 00:22:31,320
Quindi, se si trattasse di una icona sul mio
desktop, non sarebbe a.out.

456
00:22:31,320 --> 00:22:32,730
Si sarebbe chiamato ciao.

457
00:22:32,730 --> 00:22:36,660
>> Quindi, per fare questo, si scopre
che Clang, come molti programmi,

458
00:22:36,660 --> 00:22:40,980
sostiene gli argomenti della riga di comando,
o bandiere, o interruttori,

459
00:22:40,980 --> 00:22:42,600
che si limita a influenzare il suo comportamento.

460
00:22:42,600 --> 00:22:48,160
In particolare, Clang supporta un trattino o
bandiera, che poi prende una seconda parola.

461
00:22:48,160 --> 00:22:51,190
In questo caso, io arbitrariamente,
ma ragionevolmente, lo chiamano ciao.

462
00:22:51,190 --> 00:22:53,710
Ma potrei chiamarlo nulla
Io voglio, tranne a.out, che

463
00:22:53,710 --> 00:22:55,390
sarebbe piuttosto oltre il punto.

464
00:22:55,390 --> 00:22:58,640
>> E poi basta specificare il nome
del file che voglio per la compilazione.

465
00:22:58,640 --> 00:23:02,190
Così ora, anche se all'inizio
del comando ho ancora Clang,

466
00:23:02,190 --> 00:23:04,410
alla fine del comando
Ho ancora il nome del file,

467
00:23:04,410 --> 00:23:08,520
Ora ho questi riga di comando
argomenti, questi flag che stanno dicendo,

468
00:23:08,520 --> 00:23:14,180
Oh, a proposito, uscita-o, un file
chiamato ciao, non il a.out di default.

469
00:23:14,180 --> 00:23:16,810
>> Quindi, se ho colpito Inserisci ora, niente
sembra essere accaduto.

470
00:23:16,810 --> 00:23:20,900
E, tuttavia, ora posso fare barra dot ciao.

471
00:23:20,900 --> 00:23:22,089
Quindi è lo stesso programma.

472
00:23:22,089 --> 00:23:24,380
Gli zero e uno sono
identica alla fine della giornata.

473
00:23:24,380 --> 00:23:27,210
>> Ma sono in due
diverso a.out files--,

474
00:23:27,210 --> 00:23:29,490
che è la prima versione
e solo stupidamente di nome,

475
00:23:29,490 --> 00:23:33,250
e ora ciao, che è un gran
altro nome interessante per un programma.

476
00:23:33,250 --> 00:23:36,195
Ma, onestamente, non sono mai
andando a ricordare di nuovo,

477
00:23:36,195 --> 00:23:37,070
e ancora, e ancora.

478
00:23:37,070 --> 00:23:39,411
E, in realtà, mentre scriviamo
programmi più complicati,

479
00:23:39,411 --> 00:23:41,160
i comandi sei
andando ad avere per scrivere

480
00:23:41,160 --> 00:23:43,920
stanno per arrivare anche
più complicata ancora.

481
00:23:43,920 --> 00:23:44,940
>> E così non preoccuparsi.

482
00:23:44,940 --> 00:23:49,220
Si scopre che gli esseri umani prima
Ci siamo resi conto anche loro

483
00:23:49,220 --> 00:23:50,530
avuto questo stesso problema.

484
00:23:50,530 --> 00:23:53,900
Anche loro non godere dover
tipo piuttosto lunghi, comandi arcani,

485
00:23:53,900 --> 00:23:55,200
per non parlare di ricordare.

486
00:23:55,200 --> 00:23:59,070
E così gli esseri umani prima di noi hanno fatto
altri programmi che rendono più facile

487
00:23:59,070 --> 00:24:00,670
per compilare il software.

488
00:24:00,670 --> 00:24:04,609
>> E, in effetti, una tale
programma si chiama fare.

489
00:24:04,609 --> 00:24:06,150
Quindi ho intenzione di andare avanti e fare questo.

490
00:24:06,150 --> 00:24:08,691
Io vado a disfare tutto quello che ho
appena fatto nel modo seguente.

491
00:24:08,691 --> 00:24:10,690
Mi permetta di tipo LS.

492
00:24:10,690 --> 00:24:13,980
E si noterà tre things--
a.out, e una stella, ciao

493
00:24:13,980 --> 00:24:15,810
e una stella, e hello.c.

494
00:24:15,810 --> 00:24:17,730
Speriamo che questo dovrebbe
essere un po intuitiva,

495
00:24:17,730 --> 00:24:21,220
nella misura in cui in precedenza non vi era
nulla in questo spazio di lavoro.

496
00:24:21,220 --> 00:24:24,240
Non c'era niente che ho avuto
creato fino a quando abbiamo iniziato classe.

497
00:24:24,240 --> 00:24:25,840
>> E ho creato hello.c.

498
00:24:25,840 --> 00:24:27,544
Poi ho compilato, e lo ha chiamato a.out.

499
00:24:27,544 --> 00:24:30,460
E poi ho compilato di nuovo un po '
diversamente e lo ha chiamato ciao.

500
00:24:30,460 --> 00:24:35,830
Così ho tre file in questa directory,
in questa cartella denominata Area di lavoro.

501
00:24:35,830 --> 00:24:38,005
Ora, posso vedere che pure
se io diminuire in realtà.

502
00:24:38,005 --> 00:24:40,530
>> Se io diminuire qui e
guarda che la mano in alto a destra

503
00:24:40,530 --> 00:24:42,940
angolo, come promesso sinistra
lato dello schermo

504
00:24:42,940 --> 00:24:45,990
è sempre intenzione di mostrare
cosa c'è nel tuo account, che cosa è

505
00:24:45,990 --> 00:24:47,790
all'interno di CS50 IDE.

506
00:24:47,790 --> 00:24:49,680
E ci sono tre file lì.

507
00:24:49,680 --> 00:24:52,070
>> Quindi voglio sbarazzarsi di a.out e ciao.

508
00:24:52,070 --> 00:24:54,275
E come si potrebbe
immaginare intuitivamente, è

509
00:24:54,275 --> 00:24:56,400
potrebbe sorta di controllo click
o fare clic destro su questo.

510
00:24:56,400 --> 00:24:57,590
E questo piccolo menu si apre.

511
00:24:57,590 --> 00:25:00,170
È possibile scaricare il file, esegue
essa, in anteprima, aggiornamento, rinominare,

512
00:25:00,170 --> 00:25:00,700
o cosa no.

513
00:25:00,700 --> 00:25:03,260
>> E ho potuto solo cancellare,
e sarebbe andato via.

514
00:25:03,260 --> 00:25:08,260
Ma facciamo le cose con un comando
Linea per ora, in modo da ottenere confortevole

515
00:25:08,260 --> 00:25:10,010
con questo, e fare quanto segue.

516
00:25:10,010 --> 00:25:15,345
Ho intenzione di andare avanti e rimuovere
a.out digitando letteralmente rma.out.

517
00:25:15,345 --> 00:25:17,890
Si scopre, il comando per
la rimozione o l'eliminazione di qualcosa,

518
00:25:17,890 --> 00:25:19,280
non rimuovere o cancellare.

519
00:25:19,280 --> 00:25:24,260
>> E 'più succintamente RM, solo per salvare
alcune combinazioni di tasti, e premi invio.

520
00:25:24,260 --> 00:25:27,707
Ora stiamo andando a essere un po '
cripticamente rimuovere file regolare a.out.

521
00:25:27,707 --> 00:25:30,040
Io non so davvero che cosa un
file di irregolare sarebbe ancora.

522
00:25:30,040 --> 00:25:31,660
Ma io voglio rimuoverlo.

523
00:25:31,660 --> 00:25:33,150
>> Quindi ho intenzione di digitare Y per sì.

524
00:25:33,150 --> 00:25:34,940
O potrei scrivere fuori, e premere Invio.

525
00:25:34,940 --> 00:25:36,440
E, ancora una volta, nulla sembra accadere.

526
00:25:36,440 --> 00:25:38,840
Ma questo è, in generale, una buona cosa.

527
00:25:38,840 --> 00:25:43,490
>> Se scriv LS questa volta,
cosa devo vedere?

528
00:25:43,490 --> 00:25:47,930
Si spera, solo ciao e hello.c.

529
00:25:47,930 --> 00:25:50,286
Ora, come un a parte, ti
notare questa stella, asterisco,

530
00:25:50,286 --> 00:25:51,660
che è alla fine dei miei programmi.

531
00:25:51,660 --> 00:25:53,201
E stanno anche mostrando in verde.

532
00:25:53,201 --> 00:25:56,970
Questo è solo il modo di CS50 IDE
di voi cluing nella realtà

533
00:25:56,970 --> 00:25:58,280
che questo non è il codice sorgente.

534
00:25:58,280 --> 00:26:01,880
Questo è un eseguibile, un eseguibile
programma che si può effettivamente eseguire

535
00:26:01,880 --> 00:26:04,020
facendo barra di punti, e quindi il suo nome.

536
00:26:04,020 --> 00:26:08,860
>> Ora, mi permetta di andare avanti e rimuovere
questo, RM ciao, Enter, rimuovere regolare

537
00:26:08,860 --> 00:26:11,010
presentare ciao, sì.

538
00:26:11,010 --> 00:26:14,180
E ora, se digito LS,
siamo tornati a hello.c.

539
00:26:14,180 --> 00:26:16,917
Cercate di non cancellare il tuo
codice sorgente.

540
00:26:16,917 --> 00:26:19,250
Anche se ci sono caratteristiche
integrato nel CS50 IDE dove

541
00:26:19,250 --> 00:26:22,870
si può passare attraverso la tua cronologia delle revisioni
e riavvolgere in tempo se accidentalmente

542
00:26:22,870 --> 00:26:26,660
cancellare qualcosa, fare essere consapevoli
come da queste richieste sì o no,

543
00:26:26,660 --> 00:26:28,381
di ciò che si vuole realmente fare.

544
00:26:28,381 --> 00:26:30,380
E se vado fino alla cima
sinistra angolo mano qui,

545
00:26:30,380 --> 00:26:33,696
tutto ciò che rimane è hello.c.

546
00:26:33,696 --> 00:26:35,570
Quindi c'è grappoli d'
altri comandi che si

547
00:26:35,570 --> 00:26:40,550
può eseguire nel mondo di Linux,
uno dei quali è, ancora una volta, Make.

548
00:26:40,550 --> 00:26:43,180
E stiamo andando a fare
il mio programma ora come segue.

549
00:26:43,180 --> 00:26:46,270
>> Invece di fare clang,
invece di fare clang-o,

550
00:26:46,270 --> 00:26:48,860
Ho intenzione di semplicemente
letteralmente tipo, fare ciao.

551
00:26:48,860 --> 00:26:52,630
E ora notato, io sono
Non digitando fare hello.c.

552
00:26:52,630 --> 00:26:53,910
Sto scrivendo fanno ciao.

553
00:26:53,910 --> 00:26:57,840
>> E questo programma make che
viene fornito con CS50 IDE, e altro ancora

554
00:26:57,840 --> 00:27:00,090
generalmente con Linux,
è un programma che è

555
00:27:00,090 --> 00:27:02,120
andando a fare un programma chiamato Ciao.

556
00:27:02,120 --> 00:27:06,680
E sta andando ad assumere, per convenzione,
che se questo programma può essere fatto,

557
00:27:06,680 --> 00:27:12,030
sta andando essere fatta da una fonte
file di codice che termina con punto c, hello.c.

558
00:27:12,030 --> 00:27:15,210
>> Quindi, se ho colpito Entra subito, si noti che
il comando che viene eseguito

559
00:27:15,210 --> 00:27:17,340
è in realtà ancora più a lungo
prima di prima.

560
00:27:17,340 --> 00:27:19,670
E questo perché abbiamo
preconfigurato CS50 IDE di avere

561
00:27:19,670 --> 00:27:22,878
alcune funzionalità aggiuntive integrate in quel
non abbiamo bisogno di appena ancora, ma presto sarà.

562
00:27:22,878 --> 00:27:26,470
Ma la cosa fondamentale da realizzare
è ora ho un programma Ciao.

563
00:27:26,470 --> 00:27:30,080
>> Se scrivo di nuovo LS, ho
avere un programma ciao.

564
00:27:30,080 --> 00:27:35,070
E posso eseguirlo con
dot taglio su a.out, no,

565
00:27:35,070 --> 00:27:38,590
perché il punto di questo
esercizio è stato dot ciao barra.

566
00:27:38,590 --> 00:27:41,089
E ora ho il mio programma ciao mondo.

567
00:27:41,089 --> 00:27:42,880
Quindi andare avanti,
ci siamo quasi sempre solo

568
00:27:42,880 --> 00:27:45,088
andare per compilare i nostri programmi
utilizzando il comando Crea.

569
00:27:45,088 --> 00:27:48,300
E allora stiamo andando a correre per loro
dot slash, e il nome del programma.

570
00:27:48,300 --> 00:27:52,610
Ma realizzare ciò che fanno è facendo per
si, è che è in sé non un compilatore.

571
00:27:52,610 --> 00:27:56,310
E 'solo un programma di convenienza
che sa innescare un compilatore

572
00:27:56,310 --> 00:27:59,470
per eseguire in modo che lei stesso può utilizzare.

573
00:27:59,470 --> 00:28:03,220
>> Quello che esistono altri comandi
Linux, ed a sua volta il CS50 IDE?

574
00:28:03,220 --> 00:28:06,107
Presto vedremo che c'è un
comando CD, Cambia directory.

575
00:28:06,107 --> 00:28:08,190
Ciò consente all'interno
l'interfaccia a riga di comando

576
00:28:08,190 --> 00:28:10,610
ad andare avanti, e indietro,
e di aprire cartelle diverse

577
00:28:10,610 --> 00:28:11,860
senza utilizzare il mouse.

578
00:28:11,860 --> 00:28:15,470
>> LS abbiamo visto, che sta per lista
i file nella directory corrente.

579
00:28:15,470 --> 00:28:17,650
Fare Dir, è possibile
probabilmente iniziare a dedurre

580
00:28:17,650 --> 00:28:21,150
ciò che questi significano now-- fare directory,
se si desidera creare una cartella.

581
00:28:21,150 --> 00:28:24,270
RM per rimuovere, RM Dir per
rimuovere directory-- e questi,

582
00:28:24,270 --> 00:28:27,160
ancora una volta, sono la linea di comando
equivalenti di ciò che si

583
00:28:27,160 --> 00:28:29,945
potrebbe fare in CS50 IDE con il mouse.

584
00:28:29,945 --> 00:28:31,820
Ma troverai subito
che a volte è solo

585
00:28:31,820 --> 00:28:33,610
molto più veloce da fare
le cose con una tastiera,

586
00:28:33,610 --> 00:28:36,690
e infine molto più potente.

587
00:28:36,690 --> 00:28:39,440
>> Ma è difficile sostenere che
tutto ciò che abbiamo fatto finora

588
00:28:39,440 --> 00:28:42,990
è tutto ciò che potente, quando tutti
abbiamo detto è, ciao mondo.

589
00:28:42,990 --> 00:28:46,740
E, infatti, ho hardcoded il
parole ciao mondo nel mio programma.

590
00:28:46,740 --> 00:28:48,530
Non vi è ancora alcuna dinamismo.

591
00:28:48,530 --> 00:28:52,320
Scratch è un ordine di grandezza
più interessante la scorsa settimana.

592
00:28:52,320 --> 00:28:54,220
>> E così andiamo lì.

593
00:28:54,220 --> 00:28:58,310
Facciamo un passo verso che,
modo di alcune di queste funzioni.

594
00:28:58,310 --> 00:29:02,470
Quindi non solo C sono dotati di printf,
e mazzi di altre funzioni

595
00:29:02,470 --> 00:29:04,850
alcune delle quali vedremo
nel tempo, non è così

596
00:29:04,850 --> 00:29:08,760
rendere il tutto così facile a destra fuori
della porta a ottenere l'input dell'utente.

597
00:29:08,760 --> 00:29:11,140
>> In effetti, uno dei punti deboli
di linguaggi come C,

598
00:29:11,140 --> 00:29:13,140
e anche Java e ancora
altri, è che non fa

599
00:29:13,140 --> 00:29:18,860
rendere più facile per ottenere solo le cose come
interi degli utenti, o stringhe, parole,

600
00:29:18,860 --> 00:29:22,970
e le frasi, lasciare che le cose da soli, come
valori di punto, o numeri reali galleggiante

601
00:29:22,970 --> 00:29:26,240
con punti decimali, e davvero
numeri lunghi, come vedremo tra poco.

602
00:29:26,240 --> 00:29:30,000
Quindi questo elenco di funzioni qui, questi
sono come gli altri pezzi del puzzle Scratch

603
00:29:30,000 --> 00:29:34,090
che abbiamo pre-installato in CS50
IDE che useremo per alcune settimane

604
00:29:34,090 --> 00:29:37,010
come ruote di formazione di sorta, e
alla fine li decollare, e guardare

605
00:29:37,010 --> 00:29:40,210
sotto la cappa, forse,
come queste cose siano applicate.

606
00:29:40,210 --> 00:29:43,460
>> Ma per fare questo, andiamo
in realtà scrivere un programma.

607
00:29:43,460 --> 00:29:44,770
Lasciami andare avanti ora.

608
00:29:44,770 --> 00:29:47,750
E ho intenzione di creare una nuova
il file cliccando questo piccolo vantaggio,

609
00:29:47,750 --> 00:29:48,970
e facendo clic su Nuovo file.

610
00:29:48,970 --> 00:29:52,250
>> Io vado a salvare questo prossimo
uno come, diciamo, string.c,

611
00:29:52,250 --> 00:29:53,750
perché voglio giocare con le stringhe.

612
00:29:53,750 --> 00:29:56,990
E stringa in C è solo
una sequenza di caratteri.

613
00:29:56,990 --> 00:29:59,090
Così ora andiamo avanti
e procedere come segue.

614
00:29:59,090 --> 00:30:04,204
>> Include di serie IO.h-- e
si scopre IO standard,

615
00:30:04,204 --> 00:30:06,360
IO significa solo ingresso e uscita.

616
00:30:06,360 --> 00:30:08,920
Così si scopre che
questa linea qui è ciò che

617
00:30:08,920 --> 00:30:11,140
Gli Stati Uniti sono vicini da utilizzare printf.

618
00:30:11,140 --> 00:30:13,410
Printf, ovviamente, produce output.

619
00:30:13,410 --> 00:30:18,000
Quindi, al fine di utilizzare printf, risulta
out devi avere questa riga di codice

620
00:30:18,000 --> 00:30:19,040
nella parte superiore del file.

621
00:30:19,040 --> 00:30:21,456
>> E torneremo a quello che
questo significa che in realtà non molto.

622
00:30:21,456 --> 00:30:23,400
Risulta che in
qualsiasi programma C che scrivo,

623
00:30:23,400 --> 00:30:26,640
Ho avuto modo di iniziare con
codice che assomiglia a questo.

624
00:30:26,640 --> 00:30:29,860
E si noterà CS50 IDE e
altro sviluppo integrato

625
00:30:29,860 --> 00:30:33,050
ambienti come esso,
stanno andando a cercare come meglio

626
00:30:33,050 --> 00:30:34,780
il possibile per finire il pensiero.

627
00:30:34,780 --> 00:30:38,930
In realtà, un momento fa, se mi annullare
quello che ho appena fatto, mi ha colpito Invio.

628
00:30:38,930 --> 00:30:42,160
>> Ho poi ha colpito ricci aperta
brace, premere Invio di nuovo.

629
00:30:42,160 --> 00:30:43,430
Ed è finito il mio pensiero.

630
00:30:43,430 --> 00:30:48,140
Mi ha dato una nuova linea, non meno frastagliata
per belle ragioni stilistiche vedremo.

631
00:30:48,140 --> 00:30:51,559
E poi mi ha dato automaticamente
che graffa per terminare il mio pensiero.

632
00:30:51,559 --> 00:30:53,600
Ora, non sempre
indovinare che cosa si vuole fare.

633
00:30:53,600 --> 00:30:56,620
Ma in gran parte, lo fa
risparmiare alcuni tasti.

634
00:30:56,620 --> 00:31:02,560
Quindi un momento fa, abbiamo fatto questo program--
ciao, mondo, e quindi compilato,

635
00:31:02,560 --> 00:31:03,460
e poi corse esso.

636
00:31:03,460 --> 00:31:04,867
Ma non c'è dinamismo qui.

637
00:31:04,867 --> 00:31:06,700
E se volessimo
fare qualcosa di diverso?

638
00:31:06,700 --> 00:31:10,630
Beh, e se volevo davvero
ottenere una stringa da parte dell'utente?

639
00:31:10,630 --> 00:31:14,250
Ho intenzione di usare un pezzo di puzzle
chiamato esattamente che-- ottenere stringa.

640
00:31:14,250 --> 00:31:18,860
>> Risulta in C che, quando non si vuole
di fornire un contributo ad un pezzo di puzzle,

641
00:31:18,860 --> 00:31:22,360
o più propriamente ad una funzione,
letteralmente fare parentesi aperta,

642
00:31:22,360 --> 00:31:23,430
parentesi chiusa.

643
00:31:23,430 --> 00:31:28,540
Quindi è come se ci fosse
nessuna scatola bianca per digitare in.

644
00:31:28,540 --> 00:31:30,720
Il blocco dire prima
aveva una piccola scatola bianca.

645
00:31:30,720 --> 00:31:32,660
Non abbiamo quella scatola bianca ora.

646
00:31:32,660 --> 00:31:36,310
>> Ma quando chiamo stringa get, io
vuole mettere il risultato in qualche luogo.

647
00:31:36,310 --> 00:31:40,680
Quindi, un paradigma molto comune in C è quello di
chiamare una funzione, come stringa di arrivare qui,

648
00:31:40,680 --> 00:31:44,070
e quindi memorizzare il suo valore di ritorno.

649
00:31:44,070 --> 00:31:47,450
È il risultato della sua
sforzo in qualcosa.

650
00:31:47,450 --> 00:31:50,630
>> E qual è il
costruire in programmazione,

651
00:31:50,630 --> 00:31:56,450
sia in Scratch o adesso C, che abbiamo
possono utilizzare per memorizzare in realtà qualcosa?

652
00:31:56,450 --> 00:31:58,990
Chiamato una variabile, giusto?

653
00:31:58,990 --> 00:32:03,320
E in Scratch, non lo facciamo davvero
cura che cosa stava succedendo nelle variabili.

654
00:32:03,320 --> 00:32:05,170
>> Ma in questo caso, abbiamo effettivamente facciamo.

655
00:32:05,170 --> 00:32:06,719
Sto per dire stringa.

656
00:32:06,719 --> 00:32:08,510
E poi ho potuto chiamare
questo tutto quello che voglio.

657
00:32:08,510 --> 00:32:11,340
Ho intenzione di chiamarlo
nome, ottiene ottenere stringa.

658
00:32:11,340 --> 00:32:13,250
>> E ora anche se sei
un po 'di nuovo a questo,

659
00:32:13,250 --> 00:32:14,984
Noto che mi manca qualche dettaglio.

660
00:32:14,984 --> 00:32:16,150
Sto dimenticando un punto e virgola.

661
00:32:16,150 --> 00:32:17,400
Ho bisogno di finire questo pensiero.

662
00:32:17,400 --> 00:32:20,480
Quindi ho intenzione di spostare il mio cursore,
e ha colpito virgola lì.

663
00:32:20,480 --> 00:32:22,130
E quello che ho appena fatto?

664
00:32:22,130 --> 00:32:24,440
In questa linea di codice,
numero 5 in questo momento,

665
00:32:24,440 --> 00:32:26,799
Sto chiamando stringa get senza ingressi.

666
00:32:26,799 --> 00:32:29,090
Quindi non c'è po 'di bianco
box come il blocco Salva ha.

667
00:32:29,090 --> 00:32:31,590
>> Sto solo dicendo, hey,
calcolatore, portami una stringa.

668
00:32:31,590 --> 00:32:34,390
Il segno di uguale non è davvero
un segno di uguale, di per sé.

669
00:32:34,390 --> 00:32:36,790
E 'l'assegnazione
operatore, il che significa,

670
00:32:36,790 --> 00:32:40,860
Hey, computer, spostare il valore
da destra verso sinistra.

671
00:32:40,860 --> 00:32:43,480
E a sinistra, ho il seguente.

672
00:32:43,480 --> 00:32:46,580
>> Hey, computer, dammi un string--
una sequenza di caratteri.

673
00:32:46,580 --> 00:32:48,637
E chiamare quel Nome stringa.

674
00:32:48,637 --> 00:32:50,220
E non hanno nemmeno bisogno di chiamarla Nome.

675
00:32:50,220 --> 00:32:52,970
>> Potrei chiamarla, convenzionalmente,
qualcosa di simile a S,

676
00:32:52,970 --> 00:32:55,900
molto simile a noi ho usato per
chiamare la variabile i.

677
00:32:55,900 --> 00:32:57,829
Ma ora ho bisogno di fare qualcosa con esso.

678
00:32:57,829 --> 00:33:00,370
Sarebbe piuttosto stupido
provare a compilare questo codice, in esecuzione

679
00:33:00,370 --> 00:33:02,410
questo programma, anche se
Sto diventando una stringa,

680
00:33:02,410 --> 00:33:04,580
perché è ancora solo
andare a dire ciao mondo.

681
00:33:04,580 --> 00:33:09,140
>> Ma cosa succede se voglio cambiare questo.

682
00:33:09,140 --> 00:33:10,940
Perché non fare questo?

683
00:33:10,940 --> 00:33:14,632
Percentuale s, comma s.

684
00:33:14,632 --> 00:33:16,090
E questo è un po 'criptico ancora.

685
00:33:16,090 --> 00:33:18,560
>> Quindi, mi permetta di fare le mie variabili più chiaro.

686
00:33:18,560 --> 00:33:20,510
Ne posso citare questo nome di variabile.

687
00:33:20,510 --> 00:33:23,230
E vediamo se non possiamo prendere in giro
A parte quello che sta succedendo qui.

688
00:33:23,230 --> 00:33:25,770
>> Quindi, sulla linea cinque, sto diventando una stringa.

689
00:33:25,770 --> 00:33:28,620
E sto memorizzare la stringa,
qualunque sia l'utente ha digitato

690
00:33:28,620 --> 00:33:31,430
a sua tastiera,
in una variabile denominata Nome.

691
00:33:31,430 --> 00:33:33,590
E si scopre che
printf non solo

692
00:33:33,590 --> 00:33:37,220
prendere un argomento in camera doppia
citazioni, un ingresso tra virgolette.

693
00:33:37,220 --> 00:33:42,100
>> Si può prendere due, o tre, o più, tale
che il secondo, o il terzo o il quarto,

694
00:33:42,100 --> 00:33:45,320
sono tutti i nomi di variabili,
o valori specificamente,

695
00:33:45,320 --> 00:33:51,610
che si desidera collegare in,
dinamicamente, che stringa tra virgolette.

696
00:33:51,610 --> 00:33:55,110
In altre parole, ciò che
sarebbe sbagliato in questo?

697
00:33:55,110 --> 00:34:00,920
Se ho appena detto ciao nome, backslash
n, salvato il mio file, compilato il mio codice,

698
00:34:00,920 --> 00:34:04,660
e corse questo, che cosa accadrebbe?

699
00:34:04,660 --> 00:34:08,139
>> E 'solo andando a dire, ciao
nome, letteralmente N-A-M-E,

700
00:34:08,139 --> 00:34:10,900
che è una specie di stupido perché
non è diverso da mondo.

701
00:34:10,900 --> 00:34:13,400
Quindi, qualsiasi cosa tra virgolette è
ciò che letteralmente viene stampata.

702
00:34:13,400 --> 00:34:15,520
Quindi, se voglio avere
un segnaposto lì,

703
00:34:15,520 --> 00:34:17,422
Io in realtà bisogno di usare
una sintassi speciale.

704
00:34:17,422 --> 00:34:20,380
E si scopre se si legge la
documentazione per la funzione printf,

705
00:34:20,380 --> 00:34:24,320
vi dirà che
se si utilizza per cento s,

706
00:34:24,320 --> 00:34:26,920
è possibile sostituire un valore come segue.

707
00:34:26,920 --> 00:34:30,190
>> Dopo una virgola dopo che
virgolette, è sufficiente

708
00:34:30,190 --> 00:34:32,179
scrivere il nome del
variabile che si desidera

709
00:34:32,179 --> 00:34:36,790
di collegare in quel formato
codice, o di formato,

710
00:34:36,790 --> 00:34:38,469
cento s per le stringhe.

711
00:34:38,469 --> 00:34:42,190
E ora se ho salvato il mio file,
Torno giù a mio terminale.

712
00:34:42,190 --> 00:34:45,870
E scrivo Fai String,
perché, ancora una volta, il nome di questa

713
00:34:45,870 --> 00:34:48,510
il file che ho scelto prima è string.c.

714
00:34:48,510 --> 00:34:51,510
>> Quindi ho intenzione di dire fare String, digitare.

715
00:34:51,510 --> 00:34:54,550
Oh mio Dio, guarda tutti
gli errori che abbiamo fatto già.

716
00:34:54,550 --> 00:34:58,540
E questo è-- cosa, questo è davvero
come una, sette programma a linea di sei?

717
00:34:58,540 --> 00:35:00,790
Quindi questo è dove molto può
ottenere rapidamente schiacciante.

718
00:35:00,790 --> 00:35:03,890
>> Questa finestra di terminale ha
ora appena rigurgitato

719
00:35:03,890 --> 00:35:06,230
un numero enorme di messaggi di errore.

720
00:35:06,230 --> 00:35:10,560
Di certo, non ho più l'errore
Messaggi di quanto ho righe di codice.

721
00:35:10,560 --> 00:35:11,680
Quindi cosa sta succedendo?

722
00:35:11,680 --> 00:35:13,920
>> Ebbene, la strategia migliore
di fare in qualsiasi momento

723
00:35:13,920 --> 00:35:16,710
non incontrare uno schiacciante
elenco degli errori del genere,

724
00:35:16,710 --> 00:35:19,690
è scorrere indietro, cercare il comando
appena eseguito, che nel mio caso

725
00:35:19,690 --> 00:35:21,020
è rendere stringa.

726
00:35:21,020 --> 00:35:24,630
Guarda a quello rendono fatto, e questo è tutto
lungo comando Clang, un grosso problema lì.

727
00:35:24,630 --> 00:35:25,950
>> Ma il rosso è male.

728
00:35:25,950 --> 00:35:27,750
Verde sta cercando di essere
gentile e disponibile.

729
00:35:27,750 --> 00:35:29,140
Ma è ancora male, in questo caso.

730
00:35:29,140 --> 00:35:30,510
Ma dove è male?

731
00:35:30,510 --> 00:35:34,450
>> String.c, la linea cinque, carattere cinque.

732
00:35:34,450 --> 00:35:35,930
Quindi questo è solo convenzione comune.

733
00:35:35,930 --> 00:35:39,060
Qualcosa del colon qualcosa significa
numero di riga e il numero di carattere.

734
00:35:39,060 --> 00:35:44,080
Errore, l'uso di non dichiarato
stringa di identificazione.

735
00:35:44,080 --> 00:35:45,900
Cercavi standard?

736
00:35:45,900 --> 00:35:48,530
>> Così, purtroppo, Clang
sta cercando di essere utile.

737
00:35:48,530 --> 00:35:49,850
Ma è sbagliato, in questo caso.

738
00:35:49,850 --> 00:35:52,350
No, Clang, non intendevo IO standard.

739
00:35:52,350 --> 00:35:54,070
Volevo dire che sulla linea uno, sì.

740
00:35:54,070 --> 00:35:56,420
>> Ma la linea cinque è questa qui.

741
00:35:56,420 --> 00:36:00,040
E non lo fa Clang
capire S-T-R-I-N-G.

742
00:36:00,040 --> 00:36:04,490
Si tratta di un identificatore non dichiarato, un
parola semplicemente non ha mai visto prima.

743
00:36:04,490 --> 00:36:08,730
E questo perché C, il linguaggio
stiamo scrivendo il codice in questo momento,

744
00:36:08,730 --> 00:36:11,070
non ha variabili chiamate stringhe.

745
00:36:11,070 --> 00:36:14,380
>> E non, per impostazione predefinita, il supporto
una cosa chiamata una stringa.

746
00:36:14,380 --> 00:36:19,750
Questo è un pezzo di CS50
gergo, ma molto convenzionale.

747
00:36:19,750 --> 00:36:21,600
Ma posso risolvere questo problema come segue.

748
00:36:21,600 --> 00:36:25,090
>> Se posso aggiungere una riga di codice
all'inizio del programma,

749
00:36:25,090 --> 00:36:30,890
includere CS50.h, che è un altro file
da qualche parte dentro di CS50 IDE, da qualche parte

750
00:36:30,890 --> 00:36:33,820
sul disco rigido, per così dire,
del sistema operativo Ubuntu

751
00:36:33,820 --> 00:36:36,590
che sto correndo, che
è il file che è

752
00:36:36,590 --> 00:36:41,740
andando a insegnare il funzionamento
Sistema di quello che una stringa è, semplicemente

753
00:36:41,740 --> 00:36:44,930
come io.h standard è il file
nel sistema operativo che è

754
00:36:44,930 --> 00:36:47,430
andando ad insegnare ciò che è printf.

755
00:36:47,430 --> 00:36:49,810
>> Anzi, avremmo ottenuto
un messaggio molto simile

756
00:36:49,810 --> 00:36:53,600
se IO aveva ammesso di serie
Io.h e ha cercato di usare printf.

757
00:36:53,600 --> 00:36:56,632
Quindi ho intenzione di andare avanti e basta
Prendi il controllo L per cancellare il mio schermo.

758
00:36:56,632 --> 00:36:59,340
Oppure si può digitare chiaro e sarà
basta cancellare la finestra di terminale.

759
00:36:59,340 --> 00:37:01,020
Ma si può ancora scorrere indietro nel tempo.

760
00:37:01,020 --> 00:37:04,100
>> E ho intenzione di eseguire nuovamente fare String.

761
00:37:04,100 --> 00:37:06,660
Incrocio le dita questa volta, Invio.

762
00:37:06,660 --> 00:37:08,380
Oh mio Dio, ha funzionato.

763
00:37:08,380 --> 00:37:12,280
mi mostra un comando lungo criptico
questo è ciò che rende generato tramite Clang,

764
00:37:12,280 --> 00:37:13,460
ma nessun messaggio di errore.

765
00:37:13,460 --> 00:37:15,460
Quindi realizzare, anche se
si potrebbe ottenere completamente

766
00:37:15,460 --> 00:37:17,480
sopraffatto con la
il numero di messaggi di errore,

767
00:37:17,480 --> 00:37:20,540
che potrebbe essere solo questo a cascata fastidioso
effetto, dove Clang non capisce

768
00:37:20,540 --> 00:37:22,620
una cosa, il che significa che poi
non capisce la parola successiva,

769
00:37:22,620 --> 00:37:23,560
o la linea successiva.

770
00:37:23,560 --> 00:37:25,850
E così appena soffoca sul vostro codice.

771
00:37:25,850 --> 00:37:27,440
Ma la correzione potrebbe essere semplice.

772
00:37:27,440 --> 00:37:30,822
E concentrarsi così sempre sulla
prima linea di uscita.

773
00:37:30,822 --> 00:37:32,530
E se non lo fai
capirlo, basta guardare

774
00:37:32,530 --> 00:37:35,480
per le parole chiave che potrebbe essere
indizi, e il numero di riga,

775
00:37:35,480 --> 00:37:37,650
e il carattere, dove
questo errore potrebbe essere.

776
00:37:37,650 --> 00:37:43,328
>> Ora lasciatemi andare avanti e digitare
dot taglio su, stringhe, entrare.

777
00:37:43,328 --> 00:37:47,340
Hm, non sta dicendo ciao nulla.

778
00:37:47,340 --> 00:37:49,210
Perché?

779
00:37:49,210 --> 00:37:51,170
Ebbene, ricordo, in cui è in esecuzione?

780
00:37:51,170 --> 00:37:56,730
>> Probabilmente è bloccato al momento
in un ciclo, se si vuole, in linea di sei,

781
00:37:56,730 --> 00:37:59,950
perché Ottenere String in base alla progettazione,
scritto da personale CS50,

782
00:37:59,950 --> 00:38:03,350
è letteralmente significava solo per sedersi
lì in attesa, e in attesa,

783
00:38:03,350 --> 00:38:04,850
e in attesa di una stringa.

784
00:38:04,850 --> 00:38:06,792
Tutto quello che intendiamo per stringa è input umano.

785
00:38:06,792 --> 00:38:07,500
Allora sai cosa?

786
00:38:07,500 --> 00:38:08,166
Lasciami andare avanti.

787
00:38:08,166 --> 00:38:11,704
E proprio per un capriccio, mi permetta
digitare il mio nome, David, entrare.

788
00:38:11,704 --> 00:38:13,120
Ora ho un programma più dinamico.

789
00:38:13,120 --> 00:38:14,240
Ha detto, ciao David.

790
00:38:14,240 --> 00:38:19,280
>> Se vado avanti e correre di nuovo,
mi permetta di provare dire il nome Zamila, entrare.

791
00:38:19,280 --> 00:38:20,940
E ora abbiamo un programma dinamico.

792
00:38:20,940 --> 00:38:22,380
Non ho codificato duro mondo.

793
00:38:22,380 --> 00:38:24,760
Non ho codificato duro
nome, o David, o Zamila.

794
00:38:24,760 --> 00:38:28,350
>> Ora è molto più simile ai programmi
sappiamo, dove se ci vuole di ingresso,

795
00:38:28,350 --> 00:38:30,870
produce uscita leggermente diverso.

796
00:38:30,870 --> 00:38:34,020
Ora, questa non è la migliore
l'esperienza degli utenti, o UX.

797
00:38:34,020 --> 00:38:36,000
Corro il programma.

798
00:38:36,000 --> 00:38:38,830
>> Non so cosa dovrei
da fare, a meno che io in realtà guardo

799
00:38:38,830 --> 00:38:40,290
o ricordare il codice sorgente.

800
00:38:40,290 --> 00:38:42,640
Quindi cerchiamo di rendere l'utente
sperimentare un po 'meglio

801
00:38:42,640 --> 00:38:44,240
con la più semplice delle cose.

802
00:38:44,240 --> 00:38:47,782
Lasciami andare di nuovo in questo
il programma, e dire semplicemente printf.

803
00:38:47,782 --> 00:38:51,870
>> E mi permetta di andare avanti e dire il nome, del colon,
e uno spazio, e poi una virgola.

804
00:38:51,870 --> 00:38:54,170
E solo per i calci, senza gioco n.

805
00:38:54,170 --> 00:38:55,980
E questo è intenzionale,
perché io non voglio

806
00:38:55,980 --> 00:38:57,590
la richiesta di passare alla riga successiva.

807
00:38:57,590 --> 00:39:01,800
>> Voglio, invece, fare questo, fare stringa
ricompilare il mio codice in nuova macchina

808
00:39:01,800 --> 00:39:03,980
Codice dot taglio su stringa.

809
00:39:03,980 --> 00:39:05,460
Ah, questo è molto più bella.

810
00:39:05,460 --> 00:39:08,780
Ora io in realtà so che cosa il computer
vuole che io faccia, dargli un nome.

811
00:39:08,780 --> 00:39:13,020
>> Quindi ho intenzione di andare avanti e digitare
a Rob, entrare, e ciao, Rob.

812
00:39:13,020 --> 00:39:16,640
Così, realizzare, questo è ancora, alla fine
del giorno, solo un programma di nove linea.

813
00:39:16,640 --> 00:39:18,090
Ma abbiamo preso questi piccoli passi.

814
00:39:18,090 --> 00:39:21,380
>> Abbiamo scritto una riga con cui si
erano familiare, printf, ciao mondo.

815
00:39:21,380 --> 00:39:22,980
Poi abbiamo annullato un po 'di quello.

816
00:39:22,980 --> 00:39:24,560
E abbiamo effettivamente usato stringa get.

817
00:39:24,560 --> 00:39:26,362
E abbiamo gettato quel valore in una variabile.

818
00:39:26,362 --> 00:39:29,070
E poi siamo andati avanti e migliorato
ulteriormente con una terza linea.

819
00:39:29,070 --> 00:39:32,220
E questo processo iterativo di
la scrittura di software è veramente fondamentale.

820
00:39:32,220 --> 00:39:36,420
In CS50, e nella vita in generale,
non si dovrebbe in genere sedersi,

821
00:39:36,420 --> 00:39:39,800
avere un programma in mente, e provare a scrivere
il tutto maledettamente tutto in una volta.

822
00:39:39,800 --> 00:39:43,810
>> Sarà, inevitabilmente, provocare modo
più errori di quanto noi stessi visto qui.

823
00:39:43,810 --> 00:39:47,070
Anche io, fino ad oggi, in costante
fare altri errori stupidi,

824
00:39:47,070 --> 00:39:50,480
sono errori in realtà più difficile
che sono più difficili da capire.

825
00:39:50,480 --> 00:39:55,095
Ma si farà più errori più
righe di codice si scrive tutto in una volta.

826
00:39:55,095 --> 00:39:57,220
E così questa pratica di,
scrivere un po 'di codice

827
00:39:57,220 --> 00:40:00,930
che sei a tuo agio con, compila
esso, eseguirlo, testarlo, più in generale,

828
00:40:00,930 --> 00:40:04,370
passa poi on-- così come abbiamo mantenuto
stratificazione e stratificazione della scorsa settimana,

829
00:40:04,370 --> 00:40:07,190
la costruzione di qualcosa di molto
semplice da qualcosa di più complesso,

830
00:40:07,190 --> 00:40:08,200
fare lo stesso qui.

831
00:40:08,200 --> 00:40:11,500
Non sedersi, e cercare di
scrivere un intero problema.

832
00:40:11,500 --> 00:40:13,780
In realtà prendere questi piccoli passi.

833
00:40:13,780 --> 00:40:18,100
>> Ora, le stringhe non sono tutti
che utile a se stessi.

834
00:40:18,100 --> 00:40:21,210
Avevamo in realtà, idealmente, come ad
hanno qualcosa di diverso nel nostro toolkit.

835
00:40:21,210 --> 00:40:23,990
Quindi cerchiamo di realtà fanno esattamente questo.

836
00:40:23,990 --> 00:40:27,900
>> Lasciami andare avanti ora e montare
un programma leggermente diverso.

837
00:40:27,900 --> 00:40:31,320
E chiameremo questo int.c, per intero.

838
00:40:31,320 --> 00:40:33,870
Io vado a, allo stesso modo,
includere CS550.h.

839
00:40:33,870 --> 00:40:36,060
Ho intenzione di includere IO standard.

840
00:40:36,060 --> 00:40:39,630
E che sta per essere abbastanza comune
in questi primi giorni della classe.

841
00:40:39,630 --> 00:40:42,050
>> E ho intenzione di pronto
me stesso con una funzione principale.

842
00:40:42,050 --> 00:40:46,370
E ora invece di ottenere una stringa,
andiamo avanti e ottenere un int.

843
00:40:46,370 --> 00:40:52,285
Chiamiamolo i, e lo chiamano ottenere
int, chiudere parens, punto e virgola.

844
00:40:52,285 --> 00:40:54,410
Ed ora facciamo
qualcosa con esso, printf.

845
00:40:54,410 --> 00:40:59,190
>> Diciamo che qualcosa di simile
ciao, backslash n, comma i.

846
00:40:59,190 --> 00:41:03,010
Così sto praticamente mimando
quello che ho fatto solo un momento fa.

847
00:41:03,010 --> 00:41:04,660
Ho un segnaposto qui.

848
00:41:04,660 --> 00:41:08,150
Ho virgola i qui, perché voglio
per collegare io per quel segnaposto.

849
00:41:08,150 --> 00:41:10,250
>> Quindi cerchiamo di andare avanti e provare
compilazione di questo programma.

850
00:41:10,250 --> 00:41:13,060
Il file si chiama int.c.

851
00:41:13,060 --> 00:41:15,920
Quindi ho intenzione di dire, fare int, entrare.

852
00:41:15,920 --> 00:41:19,420
Oh mio Dio, ma niente di grave, giusto?

853
00:41:19,420 --> 00:41:20,230
C'è un errore.

854
00:41:20,230 --> 00:41:22,810
>> C'è un errore sintattico
qui in modo che il programma non può

855
00:41:22,810 --> 00:41:28,460
essere compilato all'interno int.c, linea
sette, carattere 27, formato di errore

856
00:41:28,460 --> 00:41:31,400
specifica il tipo char
Star, qualunque essa sia.

857
00:41:31,400 --> 00:41:33,020
Ma il tipo di argomento è int.

858
00:41:33,020 --> 00:41:36,110
>> Quindi anche qui, non stiamo andando a--
anche se oggi è un sacco di materiale,

859
00:41:36,110 --> 00:41:38,710
stiamo andando a sopraffare con
assolutamente ogni caratteristica di C,

860
00:41:38,710 --> 00:41:41,070
e programmazione più in generale,
in appena queste prime settimane.

861
00:41:41,070 --> 00:41:43,400
Quindi c'è spesso sarà gergo
con cui non hai familiarità.

862
00:41:43,400 --> 00:41:46,350
E, infatti, char stella è qualcosa
stiamo per tornare a

863
00:41:46,350 --> 00:41:47,830
in una settimana o tempo di due.

864
00:41:47,830 --> 00:41:50,530
>> Ma per ora, vediamo se possiamo
analizzare le parole che sono familiari.

865
00:41:50,530 --> 00:41:53,750
così disposizioni-- abbiamo sentito formato
identificatore, codice del formato prima.

866
00:41:53,750 --> 00:41:54,840
Questo è familiare.

867
00:41:54,840 --> 00:41:56,840
Type-- ma l'argomento è di tipo int.

868
00:41:56,840 --> 00:41:58,980
Aspetta un minuto, i è un int.

869
00:41:58,980 --> 00:42:02,230
>> Forse per cento s in realtà
ha un significato definito.

870
00:42:02,230 --> 00:42:03,230
E, in effetti, lo fa.

871
00:42:03,230 --> 00:42:06,101
Un numero intero, se si desidera
printf di sostituirlo,

872
00:42:06,101 --> 00:42:08,350
in realtà si deve utilizzare un
diverso identificatore di formato.

873
00:42:08,350 --> 00:42:09,890
E non si sa questo
a meno che qualcuno ti ha detto,

874
00:42:09,890 --> 00:42:10,973
o si era fatto prima.

875
00:42:10,973 --> 00:42:13,490
Ma per cento i è ciò che
può essere comunemente usato

876
00:42:13,490 --> 00:42:15,240
in printf per collegare un numero intero.

877
00:42:15,240 --> 00:42:17,920
È inoltre possibile utilizzare per cento
d per un intero decimale.

878
00:42:17,920 --> 00:42:19,490
Ma i è piacevole e semplice qui.

879
00:42:19,490 --> 00:42:20,590
Quindi andremo con quello.

880
00:42:20,590 --> 00:42:24,160
>> Ora lasciami andare avanti e
replica make int, Invio.

881
00:42:24,160 --> 00:42:26,328
Questo è un bene, senza errori.

882
00:42:26,328 --> 00:42:30,260
Dot taglio su OK int--, brutta esperienza utente,
perché non mi sono detto

883
00:42:30,260 --> 00:42:30,760
Cosa fare.

884
00:42:30,760 --> 00:42:31,426
Ma va bene.

885
00:42:31,426 --> 00:42:32,480
Sto prendendo piede rapidamente.

886
00:42:32,480 --> 00:42:39,260
>> E ora lasciami andare avanti e
digitare David, OK, Zamila, Rob.

887
00:42:39,260 --> 00:42:40,820
OK, quindi questa è una buona cosa.

888
00:42:40,820 --> 00:42:44,710
Questa volta, sto usando una funzione,
un pezzo di puzzle, chiamato get int.

889
00:42:44,710 --> 00:42:47,230
E si scopre fuori-- e ti
vedere questo più avanti nella term--

890
00:42:47,230 --> 00:42:50,730
il personale CS50 ha implementato
ottenere corda in modo tale

891
00:42:50,730 --> 00:42:53,350
che lo farà solo fisicamente
ottenere una stringa per voi.

892
00:42:53,350 --> 00:42:57,340
>> Esso ha implementato get int in
modo tale che solo sarà

893
00:42:57,340 --> 00:42:58,590
ottenere un numero intero per voi.

894
00:42:58,590 --> 00:43:00,830
E se si, l'umano,
non cooperare, è

895
00:43:00,830 --> 00:43:03,590
letteralmente solo andando a
dire riprovare, riprovare, riprovare,

896
00:43:03,590 --> 00:43:08,200
letteralmente seduto lì loop, fino a quando
costringesse con qualche numero magico,

897
00:43:08,200 --> 00:43:10,670
come 50, e ciao 50.

898
00:43:10,670 --> 00:43:14,440
>> Oppure, se corriamo di nuovo
e digitare 42, ciao 42.

899
00:43:14,440 --> 00:43:18,750
E così la funzione get int
all'interno di quel pezzo di puzzle

900
00:43:18,750 --> 00:43:22,050
è abbastanza logica, basta il pensiero,
per capire, ciò che è una parola?

901
00:43:22,050 --> 00:43:23,330
E che è un numero?

902
00:43:23,330 --> 00:43:26,165
Solo accettando, in definitiva, i numeri.

903
00:43:26,165 --> 00:43:28,690

904
00:43:28,690 --> 00:43:33,230
>> Così si scopre che questo
non è poi così espressiva.

905
00:43:33,230 --> 00:43:33,910
finora.

906
00:43:33,910 --> 00:43:36,690
Così, yay, ultima volta che abbiamo
è andato abbastanza rapidamente

907
00:43:36,690 --> 00:43:41,320
in giochi di attuazione, e l'animazione,
e opere artistiche a zero.

908
00:43:41,320 --> 00:43:45,260
E qui, ci viene contenuti
con il mondo ciao, ciao e 50.

909
00:43:45,260 --> 00:43:46,696
>> Non è tutto ciò che stimolante.

910
00:43:46,696 --> 00:43:49,070
E, in effetti, queste prime
esempi ci vorrà del tempo

911
00:43:49,070 --> 00:43:50,510
a far decollare l'eccitazione.

912
00:43:50,510 --> 00:43:52,854
Ma noi abbiamo molto di più
controllare ora, in effetti.

913
00:43:52,854 --> 00:43:54,770
E stiamo per molto
avviare rapidamente stratificazione

914
00:43:54,770 --> 00:43:56,870
in cima a questi primitive di base.

915
00:43:56,870 --> 00:43:59,370
>> Ma in primo luogo, cerchiamo di capire
quali sono i limiti.

916
00:43:59,370 --> 00:44:01,620
Infatti, una delle cose
Scratch non è così facile

917
00:44:01,620 --> 00:44:03,990
facciamo è davvero guardare
sotto la cappa,

918
00:44:03,990 --> 00:44:06,740
e capire che cosa un
computer è, che cosa può fare,

919
00:44:06,740 --> 00:44:08,250
e quali sono i suoi limiti.

920
00:44:08,250 --> 00:44:11,580
E, infatti, che la mancanza di
comprensione, potenzialmente, a lungo termine

921
00:44:11,580 --> 00:44:15,520
può portare alla nostra scrittura mistakes--
insetti, la scrittura di software insicuro che

922
00:44:15,520 --> 00:44:16,880
viene violato in qualche modo.

923
00:44:16,880 --> 00:44:20,130
>> Quindi cerchiamo di prendere alcuni passi verso la
comprensione di questo un po 'meglio

924
00:44:20,130 --> 00:44:22,710
modo, per esempio, il seguente esempio.

925
00:44:22,710 --> 00:44:26,550
Ho intenzione di andare avanti e mettere in atto
reale veloce un programma chiamato Adder.

926
00:44:26,550 --> 00:44:28,134
Come, aggiungiamo alcuni numeri insieme.

927
00:44:28,134 --> 00:44:30,800
E ho intenzione di codificare alcuni angoli
qui, e basta copiare e incollare

928
00:44:30,800 --> 00:44:33,270
dove ero prima, appena
in modo che possiamo andare avanti prima.

929
00:44:33,270 --> 00:44:36,090
Così ora ho gli inizi di base
di un programma chiamato Adder.

930
00:44:36,090 --> 00:44:37,670
>> E andiamo avanti e fare questo.

931
00:44:37,670 --> 00:44:41,680
Ho intenzione di andare avanti e
per esempio, IntX ottiene ottenere int.

932
00:44:41,680 --> 00:44:42,430
E sai una cosa?

933
00:44:42,430 --> 00:44:43,990
Facciamo una migliore esperienza utente.

934
00:44:43,990 --> 00:44:48,740
>> Quindi diciamo solo che x è, e in modo efficace
richiedere all'utente di darci x.

935
00:44:48,740 --> 00:44:53,600
E poi mi permetta di andare avanti e dire, printf
Che ne dite di y è, questa volta in attesa

936
00:44:53,600 --> 00:44:56,140
due valori da parte dell'utente.

937
00:44:56,140 --> 00:45:02,759
E poi cerchiamo di andare avanti e
per esempio, printf, la somma di x ed y è.

938
00:45:02,759 --> 00:45:04,300
E ora non voglio fare cento s.

939
00:45:04,300 --> 00:45:12,080
Voglio fare i cento, backslash
n, e quindi collegare valore della somma.

940
00:45:12,080 --> 00:45:13,620
>> Così come posso fare per fare questo?

941
00:45:13,620 --> 00:45:14,270
Sai cosa?

942
00:45:14,270 --> 00:45:15,840
Io so come usare le variabili.

943
00:45:15,840 --> 00:45:18,140
Vorrei solo dichiarare una nuova, int z.

944
00:45:18,140 --> 00:45:19,770
>> E ho intenzione di prendere una supposizione qui.

945
00:45:19,770 --> 00:45:24,470
Se ci sono segni di uguale in questo
lingua, forse posso solo fare x più y,

946
00:45:24,470 --> 00:45:26,660
fino a quando finisco il mio
pensato con un punto e virgola?

947
00:45:26,660 --> 00:45:31,170
Ora posso tornare quaggiù, collegare z,
finire questo pensiero con un punto e virgola.

948
00:45:31,170 --> 00:45:36,160
E vediamo ora, se questi
sequenze di x lines-- è ottenere int.

949
00:45:36,160 --> 00:45:37,770
Y è ottenere int.

950
00:45:37,770 --> 00:45:40,980
>> Aggiungere xey, memorizzare il valore in z--
così, ancora una volta, ricordare il segno di uguale

951
00:45:40,980 --> 00:45:41,560
Non è uguale.

952
00:45:41,560 --> 00:45:44,100
E 'assegnazione da destra a sinistra.

953
00:45:44,100 --> 00:45:48,180
E cerchiamo di stampare fuori che la somma
di X e Y non è letteralmente z,

954
00:45:48,180 --> 00:45:49,830
ma cosa c'è dentro di z.

955
00:45:49,830 --> 00:45:53,090
Quindi cerchiamo di fare Adder -
bello, nessun errore questa volta.

956
00:45:53,090 --> 00:45:56,030
Dot taglio su Adder, entrare,
x sta per essere 1.

957
00:45:56,030 --> 00:45:58,380
>> Y sta per essere 2.

958
00:45:58,380 --> 00:46:01,964
E la somma di x ed y è 3.

959
00:46:01,964 --> 00:46:03,130
Ecco, questo è tutto bello e buono.

960
00:46:03,130 --> 00:46:06,260
>> Quindi, si potrebbe immaginare che la matematica
dovrebbe funzionare in un programma come questo.

961
00:46:06,260 --> 00:46:07,040
Ma sai una cosa?

962
00:46:07,040 --> 00:46:09,904
È questa variabile, la linea
12, anche necessario?

963
00:46:09,904 --> 00:46:12,820
Non è necessario per ottenere l'abitudine
di appena memorizzare le cose in variabili

964
00:46:12,820 --> 00:46:13,980
solo perché si può.

965
00:46:13,980 --> 00:46:16,550
E, infatti, è generalmente
Considered Design Bad

966
00:46:16,550 --> 00:46:21,100
se si sta creando una variabile, chiamata
z in questo caso, memorizzare qualcosa in esso,

967
00:46:21,100 --> 00:46:24,390
e poi subito
usarlo, ma mai più.

968
00:46:24,390 --> 00:46:27,700
Perché dare qualcosa di un nome
come z se siete letteralmente

969
00:46:27,700 --> 00:46:29,770
intenzione di utilizzare tale
cosa sola volta, e così

970
00:46:29,770 --> 00:46:32,380
prossimale al punto in cui si è creato
in primo luogo,

971
00:46:32,380 --> 00:46:34,052
così vicini in termini di linee di codice?

972
00:46:34,052 --> 00:46:34,760
Allora sai cosa?

973
00:46:34,760 --> 00:46:37,480
Si scopre che C è abbastanza flessibile.

974
00:46:37,480 --> 00:46:39,586
Se Io in realtà voglio
plug-in valori qui,

975
00:46:39,586 --> 00:46:41,210
Non ho bisogno di dichiarare una nuova variabile.

976
00:46:41,210 --> 00:46:44,680
Ho potuto solo plug-in di x più
y, perché capisce C

977
00:46:44,680 --> 00:46:46,390
aritmetica, e gli operatori matematici.

978
00:46:46,390 --> 00:46:50,140
>> Così posso semplicemente dire, fare questo per la matematica,
x + y, qualunque questi valori sono,

979
00:46:50,140 --> 00:46:53,780
collegare il risultante
intero in quella stringa.

980
00:46:53,780 --> 00:46:56,730
Quindi questo potrebbe essere, anche se
solo una linea più breve,

981
00:46:56,730 --> 00:47:01,480
una migliore progettazione, un programma migliore,
perché c'è meno codice, quindi,

982
00:47:01,480 --> 00:47:02,921
meno per me capire.

983
00:47:02,921 --> 00:47:04,920
Ed è anche appena più pulito,
nella misura in cui non siamo

984
00:47:04,920 --> 00:47:07,620
l'introduzione di nuove parole,
nuovi simboli, come z,

985
00:47:07,620 --> 00:47:10,510
anche se in realtà non
servire molto di uno scopo.

986
00:47:10,510 --> 00:47:15,890
>> Purtroppo, la matematica non è
tutto ciò che a volte affidabili.

987
00:47:15,890 --> 00:47:18,270
Andiamo avanti e fare questo.

988
00:47:18,270 --> 00:47:21,200
Ho intenzione di andare avanti
ora e fare quanto segue.

989
00:47:21,200 --> 00:47:30,650
>> Facciamo printf, cento i, oltre cento
I sono cento i, backslash n.

990
00:47:30,650 --> 00:47:35,240
E ho intenzione di fare questo-- xyx più y.

991
00:47:35,240 --> 00:47:37,821
Così Sto solo andando a riscrivere
questo in modo leggermente diverso qui.

992
00:47:37,821 --> 00:47:39,320
Vorrei solo fare un controllo di integrità rapido.

993
00:47:39,320 --> 00:47:40,986
Anche in questo caso, cerchiamo di non andare avanti di noi stessi.

994
00:47:40,986 --> 00:47:44,420
Fai la vipera, dot barra vipera.

995
00:47:44,420 --> 00:47:47,950
x è 1, y è 2, 1 + 2 fa 3.

996
00:47:47,950 --> 00:47:48,870
Quindi, questo è un bene.

997
00:47:48,870 --> 00:47:52,060
Ma cerchiamo di complicare questo ora
un po ', e creare un nuovo file.

998
00:47:52,060 --> 00:47:56,350
>> Ho intenzione di chiamare questa,
dire, int, plurali per gli interi.

999
00:47:56,350 --> 00:47:58,980
Permettetemi di iniziare dove ero un attimo fa.

1000
00:47:58,980 --> 00:48:00,770
Ma ora facciamo un paio di altre linee.

1001
00:48:00,770 --> 00:48:06,430
Mi permetta di andare avanti e fare quanto segue,
printf, cento i, meno per cento i,

1002
00:48:06,430 --> 00:48:11,959
è cento i, comma x, comma YX meno y.

1003
00:48:11,959 --> 00:48:13,750
Così sto facendo un po '
matematica diverso lì.

1004
00:48:13,750 --> 00:48:14,624
Facciamo un altro.

1005
00:48:14,624 --> 00:48:19,610
Così per cento i tempi per cento
i è cento i, backslash n.

1006
00:48:19,610 --> 00:48:24,430
Facciamo plug-in x, y, e tempi di X Y.

1007
00:48:24,430 --> 00:48:27,530
Useremo l'asterisco su
il computer per i tempi.

1008
00:48:27,530 --> 00:48:29,390
>> Non si utilizza x. x è
un nome di variabile qui.

1009
00:48:29,390 --> 00:48:31,270
Si utilizza la stella per la moltiplicazione.

1010
00:48:31,270 --> 00:48:32,020
Facciamo un altro.

1011
00:48:32,020 --> 00:48:37,580
Printf per cento I, diviso
per cento i, è cento i,

1012
00:48:37,580 --> 00:48:43,460
n backslash. xy diviso per y--
in modo da utilizzare la barra in C

1013
00:48:43,460 --> 00:48:44,502
a fare la divisione.

1014
00:48:44,502 --> 00:48:45,460
E facciamo un altro.

1015
00:48:45,460 --> 00:48:50,920

1016
00:48:50,920 --> 00:48:58,240
Resto di cento i, diviso
per cento i, è cento i.

1017
00:48:58,240 --> 00:49:02,550
xy-- e ora resto
è ciò che rimane.

1018
00:49:02,550 --> 00:49:05,980
Quando si tenta un dividendo
denominatore in un numeratore

1019
00:49:05,980 --> 00:49:08,570
quanto è rimasto che
non si poteva dividere fuori?

1020
00:49:08,570 --> 00:49:10,910
>> Quindi non c'è davvero,
necessariamente, un simbolo

1021
00:49:10,910 --> 00:49:12,470
abbiamo usato in grado di scuola per questo.

1022
00:49:12,470 --> 00:49:16,830
Ma c'è in C. Si può
dire x modulo y, dove

1023
00:49:16,830 --> 00:49:21,000
questo segno per cento in questo context--
confusamente quando sei dentro

1024
00:49:21,000 --> 00:49:23,170
delle virgolette,
all'interno di printf, per cento

1025
00:49:23,170 --> 00:49:24,830
viene utilizzato come identificatore di formato.

1026
00:49:24,830 --> 00:49:28,420
>> Quando si utilizza per cento al di fuori di
che in un'espressione matematica,

1027
00:49:28,420 --> 00:49:32,910
è l'operatore modulo per modulare
arithmetic-- per i nostri scopi

1028
00:49:32,910 --> 00:49:36,650
qui, significa semplicemente, che cosa è la
restante x diviso per y?

1029
00:49:36,650 --> 00:49:39,130
Quindi x diviso per y è x barra y.

1030
00:49:39,130 --> 00:49:41,220
Nei il resto di x diviso per y?

1031
00:49:41,220 --> 00:49:44,780
E 'x y mod, come programmatore direbbe.

1032
00:49:44,780 --> 00:49:51,300
>> Quindi, se ho commesso errori qui, mi permetta
andare avanti e fare interi, plurali, bello,

1033
00:49:51,300 --> 00:49:53,010
e int oblique punti.

1034
00:49:53,010 --> 00:49:58,270
E andiamo avanti e
fare, diciamo, 1, 10.

1035
00:49:58,270 --> 00:50:01,390
Va bene, 1 più 10 è 11, di controllo.

1036
00:50:01,390 --> 00:50:04,240
1 meno 10 è negativo 9, controllare.

1037
00:50:04,240 --> 00:50:06,420
>> 1 volte 10 è 10, di controllo.

1038
00:50:06,420 --> 00:50:10,090
1 diviso 10 è--
OK, ci salteremo che uno.

1039
00:50:10,090 --> 00:50:12,480
Resto di 1 diviso 10 è 1.

1040
00:50:12,480 --> 00:50:13,680
È corretto.

1041
00:50:13,680 --> 00:50:15,630
Ma c'è un bug in qui.

1042
00:50:15,630 --> 00:50:18,390
>> Quindi quello che ho messo la mia
consegnare, non è corretto.

1043
00:50:18,390 --> 00:50:19,670
Voglio dire, è vicino a 0.

1044
00:50:19,670 --> 00:50:23,670
1 diviso per 10, si sa, se siamo
taglio alcuni angoli, certo, è pari a zero.

1045
00:50:23,670 --> 00:50:31,050
Ma in realtà dovrebbe essere 1/10,
0.1 o 0.10, 0.1000, o così via.

1046
00:50:31,050 --> 00:50:33,600
>> Non dovrebbe essere veramente zero.

1047
00:50:33,600 --> 00:50:38,990
Beh, si scopre che il computer è
fare letteralmente quello che abbiamo detto di fare.

1048
00:50:38,990 --> 00:50:42,460
Stiamo facendo la matematica come x diviso per y.

1049
00:50:42,460 --> 00:50:47,680
Ed entrambi X e Y, per le linee
di codice in precedenza, sono interi.

1050
00:50:47,680 --> 00:50:53,440
>> Inoltre, sulla linea 15, siamo
dicendo printf, ehi, printf plug-in

1051
00:50:53,440 --> 00:50:57,230
un numero intero, plug-in un numero intero,
plug-in integer-- specificamente

1052
00:50:57,230 --> 00:51:00,580
x, quindi y, e poi x
diviso per y. xey sono interi.

1053
00:51:00,580 --> 00:51:02,060
Siamo a posto lì.

1054
00:51:02,060 --> 00:51:04,250
>> Ma ciò che è x diviso per x?

1055
00:51:04,250 --> 00:51:09,790
x diviso per y dovrebbe essere,
matematicamente, 1/10, o 0.1,

1056
00:51:09,790 --> 00:51:14,600
che è un numero reale, un numero reale
avere, potenzialmente, un punto decimale.

1057
00:51:14,600 --> 00:51:16,230
Non è un numero intero.

1058
00:51:16,230 --> 00:51:21,290
>> Ma ciò che è la più vicina
integer a 1/10, o 0.1?

1059
00:51:21,290 --> 00:51:24,114
Sì, che tipo di è pari a zero.

1060
00:51:24,114 --> 00:51:25,030
0.1 è così tanto.

1061
00:51:25,030 --> 00:51:25,890
E 1 è così tanto.

1062
00:51:25,890 --> 00:51:28,870
Quindi, è più vicino al 1/10
0 piuttosto che uno.

1063
00:51:28,870 --> 00:51:33,800
>> E così quello che C sta facendo per noi--
tipo di perché abbiamo detto che a--

1064
00:51:33,800 --> 00:51:35,600
è troncando quella intero.

1065
00:51:35,600 --> 00:51:43,540
E 'prendendo il valore, che è ancora
doveva essere qualcosa di simile a 0.1000,

1066
00:51:43,540 --> 00:51:44,800
0 e così via.

1067
00:51:44,800 --> 00:51:48,320
Ed è troncare tutto
dopo il punto decimale

1068
00:51:48,320 --> 00:51:50,510
in modo che tutto questo
roba, perché non è così

1069
00:51:50,510 --> 00:51:54,910
inserire nella nozione di un numero intero, che
è solo un numero come negativo 1, 0, 1,

1070
00:51:54,910 --> 00:51:58,830
su e giù, si butta via tutto
dopo il punto decimale perché

1071
00:51:58,830 --> 00:52:02,020
Non può andare bene un punto decimale
in un numero intero per definizione.

1072
00:52:02,020 --> 00:52:04,290
>> Quindi la risposta qui è zero.

1073
00:52:04,290 --> 00:52:05,600
Quindi, come possiamo risolvere questo problema?

1074
00:52:05,600 --> 00:52:07,400
Abbiamo bisogno di un'altra soluzione tutti insieme.

1075
00:52:07,400 --> 00:52:09,880
E possiamo farlo, come segue.

1076
00:52:09,880 --> 00:52:15,820
>> Lasciami andare avanti e creare un nuovo
il file, questo chiamato floats.c.

1077
00:52:15,820 --> 00:52:19,500
E salvarlo qui in
stessa directory, float.c.

1078
00:52:19,500 --> 00:52:22,360

1079
00:52:22,360 --> 00:52:26,260
E mi permetta di andare avanti e copiare
alcuni di tale codice precedente.

1080
00:52:26,260 --> 00:52:30,690
>> Ma invece di ottenere
un int, facciamolo.

1081
00:52:30,690 --> 00:52:34,037
Datemi un valore in virgola mobile
chiamato x. qualora un punto floating

1082
00:52:34,037 --> 00:52:36,370
il valore è solo letteralmente
qualcosa con una virgola mobile.

1083
00:52:36,370 --> 00:52:37,410
Può spostarsi a sinistra, a destra.

1084
00:52:37,410 --> 00:52:38,530
Si tratta di un numero reale.

1085
00:52:38,530 --> 00:52:41,050
>> E mi permetta di non chiamo
ottenere int, ma ottenere galleggiante,

1086
00:52:41,050 --> 00:52:44,420
che era anche tra i menu
di opzioni nella libreria C250.

1087
00:52:44,420 --> 00:52:46,220
Cambiamo y ad un galleggiante.

1088
00:52:46,220 --> 00:52:48,000
Così questo diventa ottenere galleggiante.

1089
00:52:48,000 --> 00:52:50,620
>> E ora, non vogliamo collegare int.

1090
00:52:50,620 --> 00:52:56,130
Si scopre che dobbiamo usare per cento
f per galleggiare, cento f per float,

1091
00:52:56,130 --> 00:52:57,560
e ora salvarlo.

1092
00:52:57,560 --> 00:53:04,220
E ora, incrociamo le dita, fanno
galleggianti, bello, carri oblique punti.

1093
00:53:04,220 --> 00:53:07,280
x sta per essere uno 1. y
Sta per essere di nuovo 10.

1094
00:53:07,280 --> 00:53:11,240
>> E, bello, OK mia aggiunta è corretta.

1095
00:53:11,240 --> 00:53:13,240
Speravo in più,
ma ho dimenticato di scriverlo.

1096
00:53:13,240 --> 00:53:16,250
Quindi andiamo a correggere questo errore logico.

1097
00:53:16,250 --> 00:53:19,280
>> Andiamo avanti e afferrare quanto segue.

1098
00:53:19,280 --> 00:53:21,080
Dobbiamo solo fare un po 'di copia e incolla.

1099
00:53:21,080 --> 00:53:23,080
E io vado a dire meno.

1100
00:53:23,080 --> 00:53:24,890
>> E ho intenzione di dire volte.

1101
00:53:24,890 --> 00:53:27,060
E io vado a dire divisi.

1102
00:53:27,060 --> 00:53:31,240
E io non ho intenzione di fare modulo,
che non è così germano qui,

1103
00:53:31,240 --> 00:53:36,690
divisi da f, e tempi plus--
OK, facciamolo di nuovo.

1104
00:53:36,690 --> 00:53:47,210
>> Rendere carri, carri oblique punti,
e 1, 10, e- bello, no, OK.

1105
00:53:47,210 --> 00:53:48,250
Quindi sono un idiota.

1106
00:53:48,250 --> 00:53:50,000
Quindi questo è molto comune
in informatica

1107
00:53:50,000 --> 00:53:52,780
di fare errori stupidi come questo.

1108
00:53:52,780 --> 00:53:56,100
>> Ai fini pedagogici,
quello che volevo veramente fare

1109
00:53:56,100 --> 00:54:00,410
è stato cambiare la scienza qui
al più, a meno, a volte,

1110
00:54:00,410 --> 00:54:04,140
e di dividere, come si spera
notato nel corso di questo esercizio.

1111
00:54:04,140 --> 00:54:07,700
Così ora cerchiamo di ri-compilare questo
il programma, fare carri oblique punti.

1112
00:54:07,700 --> 00:54:10,950
>> E per la terza volta, facciamo
vedere se soddisfa le mie aspettative.

1113
00:54:10,950 --> 00:54:24,480
1, 10, entrare, sì, OK, 1.000,
diviso per 10.000, è 0.100000.

1114
00:54:24,480 --> 00:54:27,952
E si scopre che possiamo controllare il numero di
numeri sono dopo quei punti decimali.

1115
00:54:27,952 --> 00:54:28,660
Abbiamo effettivamente sarà.

1116
00:54:28,660 --> 00:54:29,790
Torneremo a questo.

1117
00:54:29,790 --> 00:54:31,440
>> Ma ora, infatti, la matematica è corretta.

1118
00:54:31,440 --> 00:54:33,090
Così, ancora una volta, qual è l'asporto qui?

1119
00:54:33,090 --> 00:54:36,050
Risulta che in C, ci sono
Non appena strings-- e, di fatto,

1120
00:54:36,050 --> 00:54:39,120
Non ci sono davvero, perché noi
aggiungere quelli con la libreria CS50.

1121
00:54:39,120 --> 00:54:40,710
Ma non ci sono solo int.

1122
00:54:40,710 --> 00:54:41,990
>> Ci sono anche galleggia.

1123
00:54:41,990 --> 00:54:45,810
E si scopre una serie di altri dati
tipi di troppo, che useremo in poco tempo.

1124
00:54:45,810 --> 00:54:49,270
Si scopre che se si vuole un unico
carattere, non è una stringa di caratteri,

1125
00:54:49,270 --> 00:54:50,610
è possibile utilizzare solo un carattere.

1126
00:54:50,610 --> 00:54:55,350
>> Scopre che se si desidera un bool,
un valore booleano, vero o solo falso,

1127
00:54:55,350 --> 00:54:59,840
grazie alla biblioteca CS50, abbiamo
aggiunto alla C il tipo di dati bool pure.

1128
00:54:59,840 --> 00:55:02,180
Ma è presente anche in
molte altre lingue.

1129
00:55:02,180 --> 00:55:07,130
E si scopre che a volte si
bisogno di numeri più grandi poi vengono di default

1130
00:55:07,130 --> 00:55:08,210
con interi e galleggianti.

1131
00:55:08,210 --> 00:55:13,590
>> E, infatti, un doppio è un numero
che utilizza non a 32 bit, ma 64 bit.

1132
00:55:13,590 --> 00:55:17,990
E un lungo tempo è un numero che
usa non 32, ma 64 bit bit,

1133
00:55:17,990 --> 00:55:22,190
rispettivamente, per virgola mobile
valori e numeri interi, rispettivamente.

1134
00:55:22,190 --> 00:55:25,780
Quindi cerchiamo di realtà ora
vedere questo in azione.

1135
00:55:25,780 --> 00:55:29,150
>> Ho intenzione di andare avanti qui
e montare un altro programma.

1136
00:55:29,150 --> 00:55:35,020
Qui, ho intenzione di andare avanti
e non comprendono CS50.h.

1137
00:55:35,020 --> 00:55:37,910
E lasciami andare, includere standard di io.h.

1138
00:55:37,910 --> 00:55:40,320
>> E si noterà qualcosa
funky sta accadendo qui.

1139
00:55:40,320 --> 00:55:43,592
Non è la codifica a colori le cose in
allo stesso modo come prima.

1140
00:55:43,592 --> 00:55:46,550
E si scopre, è perché io
Non hanno dato la cosa un nome di file.

1141
00:55:46,550 --> 00:55:50,270
>> Ho intenzione di chiamare questo uno
sizeof.c, e ha colpito Salva.

1142
00:55:50,270 --> 00:55:54,039
E cosa succede al mio molto
codice bianco contro quello sfondo nero.

1143
00:55:54,039 --> 00:55:55,830
Ora, almeno c'è
un po 'di viola in là.

1144
00:55:55,830 --> 00:55:57,490
Ed è sintassi evidenziata.

1145
00:55:57,490 --> 00:56:00,700
>> Questo perché, molto semplicemente, non ho
ha detto l'IDE tipo di file

1146
00:56:00,700 --> 00:56:04,060
è dandogli un nome, e
in particolare l'estensione del file.

1147
00:56:04,060 --> 00:56:06,620
Ora, andiamo avanti e fare questo.

1148
00:56:06,620 --> 00:56:11,910
Ho intenzione di andare avanti e molto
semplicemente stampare il bool following--

1149
00:56:11,910 --> 00:56:14,080
è cento LU.

1150
00:56:14,080 --> 00:56:15,950
>> Torneremo a
che in un attimo.

1151
00:56:15,950 --> 00:56:18,840
E poi ho intenzione di
formato di stampa di bool.

1152
00:56:18,840 --> 00:56:21,170
E ora, solo per risparmiare
io stesso un po 'di tempo, sono

1153
00:56:21,170 --> 00:56:23,280
andando a fare un intero
mazzo di questi immediatamente.

1154
00:56:23,280 --> 00:56:27,620
E, in particolare, ho intenzione di
cambiare questo ad un char e char.

1155
00:56:27,620 --> 00:56:30,760
Questo, ho intenzione di cambiare
per una matrimoniale e una doppia.

1156
00:56:30,760 --> 00:56:34,440
>> Questo, ho intenzione di cambiare
ad un galleggiante e un galleggiante.

1157
00:56:34,440 --> 00:56:38,670
Questo, ho intenzione di
cambiare per un int e un int.

1158
00:56:38,670 --> 00:56:41,660
E questo, ho intenzione
cambiare per un lungo tempo.

1159
00:56:41,660 --> 00:56:43,840
Ed è ancora in corso
un lungo tempo, molto lungo.

1160
00:56:43,840 --> 00:56:47,572
>> E poi, infine, ho dato
io stesso uno di troppo, stringa.

1161
00:56:47,572 --> 00:56:50,030
Si scopre che in C, non c'è
l'operatore speciale chiamato

1162
00:56:50,030 --> 00:56:53,260
dimensioni che è letteralmente
andando a, quando viene eseguito,

1163
00:56:53,260 --> 00:56:55,099
dirci che il formato di
ciascuna di queste variabili.

1164
00:56:55,099 --> 00:56:56,890
E questo è un modo, ora,
ci si può collegare indietro

1165
00:56:56,890 --> 00:57:00,140
alla discussione della scorsa settimana
di dati e di rappresentanza.

1166
00:57:00,140 --> 00:57:03,330
>> Lasciami andare avanti e compilare
dimensione della dimensione barra di punti di.

1167
00:57:03,330 --> 00:57:04,210
E vediamo.

1168
00:57:04,210 --> 00:57:08,210
Si scopre che in C,
in particolare sulla CS50 IDE,

1169
00:57:08,210 --> 00:57:11,170
in particolare sulla
sistema operativo Ubuntu,

1170
00:57:11,170 --> 00:57:14,100
che è operativo a 64 bit
sistema in questo caso,

1171
00:57:14,100 --> 00:57:17,189
un bool sta per
utilizzare un byte di spazio.

1172
00:57:17,189 --> 00:57:19,480
Ecco come dimensioni è misurato,
non in bit, ma in byte.

1173
00:57:19,480 --> 00:57:21,690
E ricordare che un byte è otto bit.

1174
00:57:21,690 --> 00:57:25,030
Quindi un bool, anche se si
tecnicamente solo bisogno di un 0 o 1,

1175
00:57:25,030 --> 00:57:27,092
è un po 'uno spreco
come abbiamo implementato esso.

1176
00:57:27,092 --> 00:57:29,800
In realtà intenzione di utilizzare un intero
byte-- così tutti gli zeri, sono forse

1177
00:57:29,800 --> 00:57:34,050
tutti quelli, o qualcosa del genere,
o solo uno tra 1 otto bit.

1178
00:57:34,050 --> 00:57:37,962
>> Un char, nel frattempo, utilizzato per un personaggio
come un carattere ASCII per la scorsa settimana,

1179
00:57:37,962 --> 00:57:39,170
sta per essere un personaggio.

1180
00:57:39,170 --> 00:57:45,340
E che sincronizza con il nostro concetto di
essendo non più di 256 bits-- piuttosto,

1181
00:57:45,340 --> 00:57:48,360
sincronizza con esso non essendo
più di 8 bit, che

1182
00:57:48,360 --> 00:57:50,450
ci dà fino a 256 valori.

1183
00:57:50,450 --> 00:57:52,680
Un doppio sta per
essere di 8 byte o 64 bit.

1184
00:57:52,680 --> 00:57:53,510
>> Un galleggiante è 4.

1185
00:57:53,510 --> 00:57:54,690
Un int è 4.

1186
00:57:54,690 --> 00:57:55,980
Una lunga, lunga è 8.

1187
00:57:55,980 --> 00:57:57,716
E una stringa è 8.

1188
00:57:57,716 --> 00:57:58,840
Ma non ti preoccupare di questo.

1189
00:57:58,840 --> 00:58:00,340
Stiamo andando a buccia indietro quel livello.

1190
00:58:00,340 --> 00:58:02,940
Si scopre, le stringhe possono
essere più lungo di 8 byte.

1191
00:58:02,940 --> 00:58:05,310
>> E, in effetti, abbiamo scritto
stringhe già, ciao mondo,

1192
00:58:05,310 --> 00:58:06,700
più di 8 byte.

1193
00:58:06,700 --> 00:58:09,270
Ma torneremo a
che in un attimo.

1194
00:58:09,270 --> 00:58:12,690
Ma il take via qui è il seguente.

1195
00:58:12,690 --> 00:58:18,320
>> Ogni computer ha soltanto una limitata
quantità di memoria e di spazio.

1196
00:58:18,320 --> 00:58:20,860
È possibile memorizzare solo così tante
file sul vostro Mac o PC.

1197
00:58:20,860 --> 00:58:26,030
È possibile memorizzare solo tanti programmi in
RAM in esecuzione in una sola volta, necessariamente, anche

1198
00:58:26,030 --> 00:58:29,360
con memoria virtuale, perché
si dispone di una quantità limitata di RAM.

1199
00:58:29,360 --> 00:58:31,990
>> E proprio per un'Immagine-- se
non hai mai aperto un computer portatile

1200
00:58:31,990 --> 00:58:34,300
o ordinato memoria aggiuntiva
per un computer,

1201
00:58:34,300 --> 00:58:36,670
potrebbe non sapere che
all'interno del computer

1202
00:58:36,670 --> 00:58:39,590
è qualcosa che sembra
un po 'come questo.

1203
00:58:39,590 --> 00:58:43,540
Quindi questa è solo una società comune denominata
Fondamentale che rende RAM per i computer.

1204
00:58:43,540 --> 00:58:46,620
E la RAM è dove i programmi
vivere mentre sono in esecuzione.

1205
00:58:46,620 --> 00:58:49,630
>> Così su ogni Mac o PC, quando si fa doppio
fare clic su un programma e si apre,

1206
00:58:49,630 --> 00:58:51,921
e si apre qualche documento Word
o qualcosa di simile,

1207
00:58:51,921 --> 00:58:54,764
memorizza temporaneamente nella
RAM, perché la RAM è più veloce

1208
00:58:54,764 --> 00:58:56,680
di disco rigido, o
il disco a stato solido.

1209
00:58:56,680 --> 00:58:59,600
Quindi è proprio dove i programmi vanno
a vivere quando sono in esecuzione,

1210
00:58:59,600 --> 00:59:01,060
o quando vengono utilizzati i file.

1211
00:59:01,060 --> 00:59:03,890
>> In modo da avere le cose che sembrano
come questo all'interno del vostro computer portatile,

1212
00:59:03,890 --> 00:59:06,320
o cose un po 'più grandi
all'interno del desktop.

1213
00:59:06,320 --> 00:59:10,440
Ma la chiave è che si hanno solo una
numero finito di queste cose.

1214
00:59:10,440 --> 00:59:14,230
E c'è solo una quantità finita di
hardware seduto su questa scrivania a destra

1215
00:59:14,230 --> 00:59:14,730
Qui.

1216
00:59:14,730 --> 00:59:18,920
>> Quindi, sicuramente, non possiamo immagazzinare
numeri infinitamente lunghi.

1217
00:59:18,920 --> 00:59:22,030
E, tuttavia, se si pensa di nuovo a
scuola elementare, quante cifre può

1218
00:59:22,030 --> 00:59:24,400
si ha a destra
di un punto decimale?

1219
00:59:24,400 --> 00:59:27,680
Del resto, quante cifre può
si deve alla sinistra di un punto decimale?

1220
00:59:27,680 --> 00:59:29,300
In realtà, infiniti.

1221
00:59:29,300 --> 00:59:33,840
>> Ora, noi esseri umani solo potrebbe
Sai come pronunciare milioni,

1222
00:59:33,840 --> 00:59:37,990
e miliardi, miliardi di dollari, e
quadrilioni, e quintilioni.

1223
00:59:37,990 --> 00:59:42,370
E sto spingendo i limiti della mia
understanding-- o my-- ho capito

1224
00:59:42,370 --> 00:59:44,110
i numeri, ma il mio
Pronuncia di numeri.

1225
00:59:44,110 --> 00:59:47,720
Ma possono ottenere infinitamente grande con
un numero infinito di cifre a sinistra

1226
00:59:47,720 --> 00:59:50,050
oa destra del punto decimale.

1227
00:59:50,050 --> 00:59:53,040
>> Ma i computer hanno solo un
quantità limitata di memoria,

1228
00:59:53,040 --> 00:59:56,510
un numero finito di transistor, un
numero finito di lampadine all'interno.

1229
00:59:56,510 --> 01:00:00,350
Che cosa succede quando
si esaurisce lo spazio?

1230
01:00:00,350 --> 01:00:02,620
In altre parole, se
ripensare a settimana scorsa

1231
01:00:02,620 --> 01:00:06,160
quando abbiamo parlato di numeri
stessi di essere rappresentato in binario,

1232
01:00:06,160 --> 01:00:08,480
supponiamo che abbiamo
questo valore a 8 bit qui.

1233
01:00:08,480 --> 01:00:11,290
>> E abbiamo sette 1 e uno 0.

1234
01:00:11,290 --> 01:00:13,827
E supponiamo che vogliamo
aggiungere 1 a questo valore.

1235
01:00:13,827 --> 01:00:15,410
Questo è davvero un grande numero di adesso.

1236
01:00:15,410 --> 01:00:19,610
>> Si tratta di 254, se non ricordo
la matematica dalla settimana scorsa destra.

1237
01:00:19,610 --> 01:00:22,480
Ma cosa succede se cambio
che più a destra 0 a 1?

1238
01:00:22,480 --> 01:00:25,800
Il numero intero, di
Naturalmente, diventa otto 1 di.

1239
01:00:25,800 --> 01:00:27,050
Quindi siamo ancora buono.

1240
01:00:27,050 --> 01:00:30,204
>> E che rappresenta probabilmente
255, anche se a seconda del contesto

1241
01:00:30,204 --> 01:00:32,120
potrebbe effettivamente rappresentare
un numero negativo.

1242
01:00:32,120 --> 01:00:34,240
Ma più su che un'altra volta.

1243
01:00:34,240 --> 01:00:37,220
Questo si sente come se fosse su
il più in alto che posso contare.

1244
01:00:37,220 --> 01:00:38,290
>> Ora, è solo 8 bit.

1245
01:00:38,290 --> 01:00:41,170
E il mio Mac, sicuramente, ha senso
più di 8 bit di memoria.

1246
01:00:41,170 --> 01:00:42,170
Ma ha finito.

1247
01:00:42,170 --> 01:00:46,230
Così lo stesso argomento vale, anche se
avere più di questi sullo schermo.

1248
01:00:46,230 --> 01:00:50,020
>> Ma cosa succede se si è
memorizzare questo numero, 255,

1249
01:00:50,020 --> 01:00:52,290
e si desidera contare 1 po 'più alto?

1250
01:00:52,290 --> 01:00:54,600
Vuoi andare 255-256.

1251
01:00:54,600 --> 01:00:58,800
Il problema, naturalmente, è che se si
iniziare a contare da zero come la settimana scorsa,

1252
01:00:58,800 --> 01:01:02,670
Non si può contare più in alto
come 256, per non parlare di 257,

1253
01:01:02,670 --> 01:01:05,584
per non parlare di 258, m perché ciò che
accade quando si aggiunge un 1?

1254
01:01:05,584 --> 01:01:08,000
Se fate la vecchia scuola elementare
approccio, si mette un 1 qui,

1255
01:01:08,000 --> 01:01:11,150
e poi 1 più 1 è 2, ma questo è
davvero uno zero, si portano il 1,

1256
01:01:11,150 --> 01:01:12,695
portare il 1, trasportare il 1.

1257
01:01:12,695 --> 01:01:15,620
Tutte queste cose,
questi 1 di, vanno a zero.

1258
01:01:15,620 --> 01:01:20,820
E si finisce, sì, come qualcuno
sottolineato, un 1 sul lato sinistro.

1259
01:01:20,820 --> 01:01:25,540
Ma tutto è possibile
effettivamente vedere e montare in memoria

1260
01:01:25,540 --> 01:01:30,960
è appena otto 0 di, vale a dire
ad un certo punto, se si, un computer,

1261
01:01:30,960 --> 01:01:35,490
provato a contare abbastanza in alto, sei
andando ad avvolgere intorno, sembrerebbe,

1262
01:01:35,490 --> 01:01:38,850
a zero, o forse addirittura negativo
numeri, che sono ancora minore di zero.

1263
01:01:38,850 --> 01:01:40,260
>> E possiamo tipo di vedere questo.

1264
01:01:40,260 --> 01:01:42,900
Lasciami andare avanti e scrivere
un vero e proprio programma veloce qui.

1265
01:01:42,900 --> 01:01:46,690
Lasciami andare avanti e scrivere
un programma chiamato overflow.

1266
01:01:46,690 --> 01:01:52,980
Includi CS50.h, comprendono
standard di IO.h-- oh,

1267
01:01:52,980 --> 01:01:54,730
Mi mancava la mia evidenziazione della sintassi.

1268
01:01:54,730 --> 01:01:57,440
Quindi cerchiamo di salvare questo come overflow.c.

1269
01:01:57,440 --> 01:02:00,084
>> E ora int void-- principale
e in poco tempo, ci

1270
01:02:00,084 --> 01:02:02,500
tornare a spiegare perché
continuiamo a scrivere int void main.

1271
01:02:02,500 --> 01:02:05,080
Ma per ora, facciamo solo fare
esso, dando per scontato.

1272
01:02:05,080 --> 01:02:09,200
Diamo me un int,
e inizializzare a 0.

1273
01:02:09,200 --> 01:02:14,716
>> Facciamo quindi fare per int ottengo zero--
in realtà, cerchiamo di fare un ciclo infinito

1274
01:02:14,716 --> 01:02:15,590
e vedere cosa succede.

1275
01:02:15,590 --> 01:02:25,440
Mentre vero, allora cerchiamo di stampare fuori n
è cento i, backslash n, plug-in n.

1276
01:02:25,440 --> 01:02:30,200
Ma, ora, facciamo n ottiene più 1 n.

1277
01:02:30,200 --> 01:02:32,660
>> In altre parole, su ciascun
iterazione di questo ciclo infinito,

1278
01:02:32,660 --> 01:02:35,550
diamo il valore di n,
e aggiungere 1 ad esso, e poi

1279
01:02:35,550 --> 01:02:37,350
memorizzare il risultato nel n a sinistra.

1280
01:02:37,350 --> 01:02:40,150
E, infatti, abbiamo visto sintassi
un po 'come questo, per breve tempo.

1281
01:02:40,150 --> 01:02:42,730
Un trucco fresco è invece
di scrivere tutto questo fuori,

1282
01:02:42,730 --> 01:02:45,770
si può effettivamente dire un n più uguale a 1.

1283
01:02:45,770 --> 01:02:50,480
>> Oppure, se si vuole veramente essere di fantasia,
si può dire n plus plus e virgola.

1284
01:02:50,480 --> 01:02:53,130
Ma questi ultimi due sono appena
quello che noi chiameremmo zucchero sintattico

1285
01:02:53,130 --> 01:02:53,790
per la prima cosa.

1286
01:02:53,790 --> 01:02:56,456
>> La prima cosa è più esplicito,
tutto bene, del tutto corretta.

1287
01:02:56,456 --> 01:02:58,470
Ma questo è più comune, dirò.

1288
01:02:58,470 --> 01:03:00,210
Quindi faremo questo solo per un momento.

1289
01:03:00,210 --> 01:03:04,685
>> Vediamo ora fare troppo pieno, che suona
piuttosto inquietante, troppo pieno barra dot.

1290
01:03:04,685 --> 01:03:07,380

1291
01:03:07,380 --> 01:03:12,852
Vediamo, n sta facendo abbastanza grande.

1292
01:03:12,852 --> 01:03:14,310
Ma pensiamo, quanto grande può ottenere n?

1293
01:03:14,310 --> 01:03:15,870
>> n è un int.

1294
01:03:15,870 --> 01:03:19,400
Abbiamo visto un momento fa, con le dimensioni di
esempio che un int è di quattro byte.

1295
01:03:19,400 --> 01:03:25,070
Sappiamo dalla settimana scorsa, quattro byte è
32 bit, per 8 volte 4, che di 32.

1296
01:03:25,070 --> 01:03:26,460
Che sta per essere 4 miliardi.

1297
01:03:26,460 --> 01:03:28,802
>> E siamo fino a 800.000.

1298
01:03:28,802 --> 01:03:31,510
Si tratta di andare a prendere per sempre a
contare su quanto mi sarà possibile.

1299
01:03:31,510 --> 01:03:33,635
Quindi ho intenzione di andare avanti,
come si potrebbe in breve tempo,

1300
01:03:33,635 --> 01:03:37,910
e ha colpito di controllo C-- francamente, di controllo
C, un sacco, dove il controllo C in generale

1301
01:03:37,910 --> 01:03:39,034
mezzi annullare.

1302
01:03:39,034 --> 01:03:41,200
Sfortunatamente, poiché questo
è in esecuzione nel cloud,

1303
01:03:41,200 --> 01:03:44,190
a volte la nube è
sputando tanta roba,

1304
01:03:44,190 --> 01:03:47,180
così tanto l'uscita, sta andando a
prendere un po 'di tempo per il mio ingresso

1305
01:03:47,180 --> 01:03:48,630
per arrivare al cloud.

1306
01:03:48,630 --> 01:03:52,240
Così, anche se mi ha colpito
Controllo C pochi secondi fa,

1307
01:03:52,240 --> 01:03:56,110
questo è sicuramente il lato
effetto di un ciclo infinito.

1308
01:03:56,110 --> 01:03:59,070
>> E così in questi casi, siamo
intenzione di lasciare che si tratti.

1309
01:03:59,070 --> 01:04:02,050
E stiamo per aggiungere un altro
finestra di terminale qui

1310
01:04:02,050 --> 01:04:06,186
con il plus, che ovviamente non lo fa
così, dal momento che è ancora pensando.

1311
01:04:06,186 --> 01:04:08,310
E andiamo avanti ed essere
un po 'più ragionevole.

1312
01:04:08,310 --> 01:04:10,768
>> Ho intenzione di andare avanti e fare
questo solo un numero finito di volte.

1313
01:04:10,768 --> 01:04:13,047
Usiamo un ciclo for,
che ho accennato in precedenza.

1314
01:04:13,047 --> 01:04:13,630
Facciamolo.

1315
01:04:13,630 --> 01:04:16,430
Dammi un'altra variabile int mi viene 0.

1316
01:04:16,430 --> 01:04:20,430
i è inferiore, diciamo, 64 i ++.

1317
01:04:20,430 --> 01:04:27,010
E ora lasciami andare avanti e di stampa
out n è cento i, comma n.

1318
01:04:27,010 --> 01:04:30,547
E poi n-- questo è ancora
andando a prendere per sempre.

1319
01:04:30,547 --> 01:04:31,130
Facciamolo.

1320
01:04:31,130 --> 01:04:33,620
>> n ottiene n volte 2.

1321
01:04:33,620 --> 01:04:37,140
O potremmo essere di fantasia
e fanno volte è uguale a 2.

1322
01:04:37,140 --> 01:04:40,120
Ma diciamo solo che n
è uguale a se stessa, volte 2.

1323
01:04:40,120 --> 01:04:42,321
In altre parole, in questo
nuova versione del programma,

1324
01:04:42,321 --> 01:04:44,820
Non voglio aspettare per sempre
da come 800.000 a 4 miliardi.

1325
01:04:44,820 --> 01:04:46,070
Diciamo solo farla finita.

1326
01:04:46,070 --> 01:04:47,920
>> Facciamo in realtà matrimoniale n ogni volta.

1327
01:04:47,920 --> 01:04:50,660
Il che, ricordo, è il raddoppio
opposta di avere, ovviamente.

1328
01:04:50,660 --> 01:04:53,035
E che la settimana scorsa abbiamo
qualcosa di nuovo, e di nuovo,

1329
01:04:53,035 --> 01:04:55,200
e di nuovo, super veloce,
raddoppio sicuramente sarà

1330
01:04:55,200 --> 01:05:01,080
farci dal 1 al più grande possibile
valore che siamo in grado di contare fino a int.

1331
01:05:01,080 --> 01:05:02,750
>> Quindi cerchiamo di fare esattamente questo.

1332
01:05:02,750 --> 01:05:04,720
E torneremo a questa prima lunga.

1333
01:05:04,720 --> 01:05:07,180
Ma questo, ancora una volta, è proprio come
il blocco di ripetizione in Scratch.

1334
01:05:07,180 --> 01:05:08,600
E potrai utilizzare questo in poco tempo.

1335
01:05:08,600 --> 01:05:13,170
>> Questo significa solo conteggio da zero
fino a, ma non uguale, a 64.

1336
01:05:13,170 --> 01:05:17,285
E su ciascuna iterazione di questo
ciclo, continua incrementando i.

1337
01:05:17,285 --> 01:05:21,990
Così i ++ - e questo costrutto generale
sulla linea 7 è solo un modo super comune

1338
01:05:21,990 --> 01:05:25,290
di ripetere alcune linee di
codice, un numero di volte.

1339
01:05:25,290 --> 01:05:26,362
Quali linee di codice?

1340
01:05:26,362 --> 01:05:28,570
Queste parentesi graffe, come si
potrebbe essere raccolte da ora,

1341
01:05:28,570 --> 01:05:29,780
significa, effettuare le seguenti operazioni.

1342
01:05:29,780 --> 01:05:32,510
>> E 'in Scratch come, quando
ha i blocchi gialli

1343
01:05:32,510 --> 01:05:35,680
e altri colori che tipo di
abbracciare o abbracciare altri blocchi.

1344
01:05:35,680 --> 01:05:37,750
Questo è ciò che quei ricci
bretelle stanno facendo qui.

1345
01:05:37,750 --> 01:05:43,200
Quindi, se ho preso la mia sintassi destra- sopra voi
può vedere il simbolo di carota in C mezzi

1346
01:05:43,200 --> 01:05:45,706
questo è quante volte sono stato
cercare di risolvere questo problema.

1347
01:05:45,706 --> 01:05:48,330
Quindi cerchiamo di sbarazzarsi di quella
del tutto, e chiudere quella finestra.

1348
01:05:48,330 --> 01:05:49,520
E useremo quello nuovo.

1349
01:05:49,520 --> 01:05:54,980
Fare troppo pieno, barra dot
troppo pieno, Enter, va bene,

1350
01:05:54,980 --> 01:05:56,090
sembra male in un primo momento.

1351
01:05:56,090 --> 01:05:59,200
Ma facciamo scorrere indietro nel tempo,
perché ho fatto questo 64 volte.

1352
01:05:59,200 --> 01:06:01,700
>> E notare la prima volta, n è 1.

1353
01:06:01,700 --> 01:06:06,110
Seconda volta, n è 2,
poi 4, poi 8, poi 16.

1354
01:06:06,110 --> 01:06:12,450
E sembra che appena
Arrivare a circa 1 miliardo,

1355
01:06:12,450 --> 01:06:15,800
se raddoppio di nuovo, che
dovrebbe darmi 2 miliardi.

1356
01:06:15,800 --> 01:06:17,980
Ma si scopre, è
proprio sulla cuspide.

1357
01:06:17,980 --> 01:06:21,930
>> E così è in realtà trabocca
un int da 1 miliardo

1358
01:06:21,930 --> 01:06:26,514
a circa 2 negativo
miliardi, perché un numero intero,

1359
01:06:26,514 --> 01:06:28,430
a differenza del numeri che
sono state assumendo la scorsa settimana,

1360
01:06:28,430 --> 01:06:31,397
può essere sia positivo che negativo
in realtà e in un computer.

1361
01:06:31,397 --> 01:06:33,730
E così almeno uno di quelli
bit è effettivamente rubati.

1362
01:06:33,730 --> 01:06:37,190
Così abbiamo davvero solo 31 bit,
o 2 miliardi di possibili valori.

1363
01:06:37,190 --> 01:06:41,220
>> Ma per ora, l'asporto è abbastanza
semplicemente, qualunque siano questi numeri sono

1364
01:06:41,220 --> 01:06:45,280
e tutto ciò che la matematica è,
succede qualcosa di brutto alla fine,

1365
01:06:45,280 --> 01:06:49,980
perché alla fine si sta tentando di
permutare i bit di una volta di troppo.

1366
01:06:49,980 --> 01:06:54,060
E in modo efficace va da tutti
1 di a forse tutti i 0 del, o forse

1367
01:06:54,060 --> 01:06:57,260
solo qualche altro modello che
chiaramente, a seconda del contesto,

1368
01:06:57,260 --> 01:06:59,342
può essere interpretato come un numero negativo.

1369
01:06:59,342 --> 01:07:02,300
E così sembrerebbe la più alta I
può contare in questo particolare programma

1370
01:07:02,300 --> 01:07:04,210
è solo approssimativamente 1 miliardo.

1371
01:07:04,210 --> 01:07:05,760
Ma c'è una soluzione parziale qui.

1372
01:07:05,760 --> 01:07:06,480
Sai cosa?

1373
01:07:06,480 --> 01:07:10,600
>> Vorrei cambiare da un
int per un lungo tempo.

1374
01:07:10,600 --> 01:07:13,633
E mi permetta di andare avanti qui
e say-- ho intenzione di avere

1375
01:07:13,633 --> 01:07:15,290
per cambiare l'accaduto a un unsigned long.

1376
01:07:15,290 --> 01:07:19,860
Oppure, vediamo, non mi ricordo mai me stesso.

1377
01:07:19,860 --> 01:07:22,920
>> Andiamo avanti e fare troppo pieno.

1378
01:07:22,920 --> 01:07:24,860
No, non è questo, LLD, grazie.

1379
01:07:24,860 --> 01:07:26,430
Così a volte Clang può essere utile.

1380
01:07:26,430 --> 01:07:30,550
Non mi ricordo cosa il formato
specificatore è stato per lungo tempo.

1381
01:07:30,550 --> 01:07:31,950
>> Ma, in effetti, Clang mi ha detto.

1382
01:07:31,950 --> 01:07:34,570
Il verde è una sorta di bene,
significa che ancora hai fatto un errore.

1383
01:07:34,570 --> 01:07:36,190
E 'indovinando che volevo dire LLD.

1384
01:07:36,190 --> 01:07:41,750
>> Quindi, mi permetta di prendere è un consiglio, un lungo
numero decimale lungo, salvo che.

1385
01:07:41,750 --> 01:07:46,190
E mi permetta di eseguire di nuovo esso, dot
tagliare troppo pieno, Invio.

1386
01:07:46,190 --> 01:07:48,020
E ora che cosa è cool è questo.

1387
01:07:48,020 --> 01:07:52,140
>> Se ho scorrere indietro nel tempo, abbiamo ancora iniziamo
contando allo stesso posto-- 1, 2, 4,

1388
01:07:52,140 --> 01:07:53,220
8, 16.

1389
01:07:53,220 --> 01:07:57,860
Avviso, otteniamo tutto il
fino a 1 miliardo.

1390
01:07:57,860 --> 01:08:00,070
Ma poi abbiamo tranquillamente arriva a 2 miliardi.

1391
01:08:00,070 --> 01:08:04,300
>> Poi si arriva a 4 miliardi,
poi 8 miliardi, 17 miliardi.

1392
01:08:04,300 --> 01:08:06,340
E andiamo più in alto, e
sempre più alto.

1393
01:08:06,340 --> 01:08:08,740
Alla fine, anche questo, si rompe.

1394
01:08:08,740 --> 01:08:12,350
>> Alla fine, con un lungo tempo,
che è il valore a 64-bit, non

1395
01:08:12,350 --> 01:08:16,660
un valore a 32 bit, se si conta
troppo alto, si avvolge intorno a 0.

1396
01:08:16,660 --> 01:08:19,410
E in questo caso, ci capita di
finire con un numero negativo.

1397
01:08:19,410 --> 01:08:20,550
>> Quindi questo è un problema.

1398
01:08:20,550 --> 01:08:23,439
E si scopre che questo
problema non è poi così arcana.

1399
01:08:23,439 --> 01:08:26,060
Anche se ho deliberatamente
indotto con questi errori,

1400
01:08:26,060 --> 01:08:29,149
si scopre lo vediamo genere di tutto
intorno a noi, o almeno alcuni di noi fare.

1401
01:08:29,149 --> 01:08:31,939
>> Quindi, in Lego Star Wars, se
avete mai giocato al gioco,

1402
01:08:31,939 --> 01:08:36,830
si scopre che si può andare in giro
rompere le cose in mondo LEGO,

1403
01:08:36,830 --> 01:08:39,640
e la raccolta delle monete, in sostanza.

1404
01:08:39,640 --> 01:08:42,200
E se hai mai giocato
questo gioco troppo tempo,

1405
01:08:42,200 --> 01:08:45,630
come questo individuo senza nome
qui ha fatto, il numero totale

1406
01:08:45,630 --> 01:08:49,700
di monete che si possono raccogliere
è, a quanto pare, 4 miliardi.

1407
01:08:49,700 --> 01:08:51,240
>> Ora, con in realtà è arrotondato.

1408
01:08:51,240 --> 01:08:53,239
Così LEGO stava cercando di
mantenere le cose user friendly.

1409
01:08:53,239 --> 01:08:56,779
Non hanno fatto esattamente 2 a
il 32 di potenza, per la settimana scorsa.

1410
01:08:56,779 --> 01:08:58,310
Ma 4 miliardi è una ragione.

1411
01:08:58,310 --> 01:09:01,979
Sembra, sulla base di queste informazioni,
che LEGO, e la società che

1412
01:09:01,979 --> 01:09:05,624
reso questo software vero e proprio, ha deciso
che il numero massimo di monete

1413
01:09:05,624 --> 01:09:07,540
l'utente può accumulare
è, infatti, 4 miliardi,

1414
01:09:07,540 --> 01:09:15,069
perché hanno scelto nel loro codice
da utilizzare non un lungo tempo, apparentemente,

1415
01:09:15,069 --> 01:09:19,140
ma solo un numero intero, un unsigned
integer, solo un numero intero positivo, cui

1416
01:09:19,140 --> 01:09:21,089
valore massimo o meno è così.

1417
01:09:21,089 --> 01:09:22,380
Bene, ecco un altro divertente.

1418
01:09:22,380 --> 01:09:26,500
Quindi, nel gioco Civilization, che
alcuni di voi potrebbero avere familiarità con

1419
01:09:26,500 --> 01:09:29,660
si scopre che anni fa ci
era un bug in questo gioco in cui

1420
01:09:29,660 --> 01:09:31,750
se hai giocato il ruolo
di Gandhi nel gioco,

1421
01:09:31,750 --> 01:09:37,020
invece di essere molto pacifista,
invece era incredibilmente, incredibilmente

1422
01:09:37,020 --> 01:09:39,399
aggressivo, in alcune circostanze.

1423
01:09:39,399 --> 01:09:43,529
In particolare, il modo in cui civiltà
opere è che se si, il giocatore,

1424
01:09:43,529 --> 01:09:47,680
adottare la democrazia, la vostra
punteggio aggressività ottiene

1425
01:09:47,680 --> 01:09:51,130
decrementato di due, in modo meno
minus, e quindi meno meno.

1426
01:09:51,130 --> 01:09:53,569
>> Così si sottrae 2 dal
il vostro iterazione attuale.

1427
01:09:53,569 --> 01:09:59,650
Purtroppo, se il vostro è l'iterazione
inizialmente 1, e si sottrae 2 da esso

1428
01:09:59,650 --> 01:10:02,050
dopo aver adottato la democrazia
come Gandhi qui potrebbe

1429
01:10:02,050 --> 01:10:05,200
hanno fatto, perché era molto passive--
1 sulla scala di aggressività.

1430
01:10:05,200 --> 01:10:07,830
Ma se egli adotta la democrazia, allora
va da 1 a negativo 1.

1431
01:10:07,830 --> 01:10:14,470
>> Purtroppo, erano
utilizzando i numeri senza segno,

1432
01:10:14,470 --> 01:10:18,400
il che significa che hanno trattato addirittura negativo
i numeri come se fossero positivi.

1433
01:10:18,400 --> 01:10:22,780
E si scopre che il
equivalente positivo di negativo 1,

1434
01:10:22,780 --> 01:10:26,480
nei programmi tipici di computer, è 255.

1435
01:10:26,480 --> 01:10:30,250
Quindi, se Gandhi adotta
la democrazia ha, e quindi

1436
01:10:30,250 --> 01:10:35,470
il suo punteggio di aggressività è diminuito,
in realtà rotola intorno a 255

1437
01:10:35,470 --> 01:10:38,470
e lui la maggior parte delle marche
carattere aggressivo nel gioco.

1438
01:10:38,470 --> 01:10:39,930
Così si può google su questo.

1439
01:10:39,930 --> 01:10:42,380
E 'stato, infatti, un
accidentale bug di programmazione,

1440
01:10:42,380 --> 01:10:46,010
ma che è entrato abbastanza
la tradizione da allora.

1441
01:10:46,010 --> 01:10:47,360
>> Questo è tutto divertente e simpatico.

1442
01:10:47,360 --> 01:10:50,760
Più spaventoso è quando attuale
dispositivi del mondo reale, e non giochi,

1443
01:10:50,760 --> 01:10:51,820
hanno gli stessi errori.

1444
01:10:51,820 --> 01:10:57,500
Infatti, appena un anno fa, un articolo è venuto
conoscere il Boeing 787 Dreamliner.

1445
01:10:57,500 --> 01:10:59,850
>> E l'articolo in prima
sguardo legge un po 'arcano.

1446
01:10:59,850 --> 01:11:04,480
Ma ha detto questo, un software
vulnerabilità in Boeing

1447
01:11:04,480 --> 01:11:07,790
nuovo 787 Dreamliner jet ha
il potenziale di causare piloti

1448
01:11:07,790 --> 01:11:10,220
a perdere il controllo della
dell'aeromobile, possibilmente

1449
01:11:10,220 --> 01:11:14,750
in pieno volo, i funzionari della FAA
compagnie aeree avvertito di recente.

1450
01:11:14,750 --> 01:11:17,520
Era la determinazione
che un modello 787

1451
01:11:17,520 --> 01:11:22,770
aereo che è stato alimentato
ininterrottamente per 248 giorni

1452
01:11:22,770 --> 01:11:27,880
può perdere tutto in corrente alternata, AC,
potenza elettrica dovuta al generatore

1453
01:11:27,880 --> 01:11:31,892
centraline, GCUs, simultaneamente
entrare in modalità sicura sicuro.

1454
01:11:31,892 --> 01:11:32,850
E 'una specie di perdermi.

1455
01:11:32,850 --> 01:11:38,390
Ma il memo dichiarato, OK, ora ho ottenuto che,
la condizione è stata causata da un software

1456
01:11:38,390 --> 01:11:41,590
contatore interno a
il controllo del generatore

1457
01:11:41,590 --> 01:11:47,860
unità che traboccherà dopo
248 giorni di potenza continua.

1458
01:11:47,860 --> 01:11:50,070
Stiamo promuovendo il presente
notare per prevenire la perdita

1459
01:11:50,070 --> 01:11:52,300
di tutti AC elettrica
alimentazione, che potrebbe risultare

1460
01:11:52,300 --> 01:11:53,980
la perdita di controllo del velivolo.

1461
01:11:53,980 --> 01:11:58,380
>> Quindi, letteralmente, c'è qualche intero,
o qualche tipo di dati equivalente,

1462
01:11:58,380 --> 01:12:00,960
utilizzato nel software
in un velivolo reale

1463
01:12:00,960 --> 01:12:03,756
che se si mantiene il vostro aereo
abbastanza a lungo, che apparentemente

1464
01:12:03,756 --> 01:12:06,880
può essere il caso se si sta solo in esecuzione
loro costantemente e mai scollegare

1465
01:12:06,880 --> 01:12:09,810
il vostro aereo, a quanto pare, o
lasciando che le sue batterie morire,

1466
01:12:09,810 --> 01:12:12,840
alla fine contare su, e su,
e su, e su, e su, e su.

1467
01:12:12,840 --> 01:12:15,150
>> E, per sua natura, un
quantità limitata di memoria

1468
01:12:15,150 --> 01:12:18,880
traboccherà, sul ritorno alla
zero o un valore negativo,

1469
01:12:18,880 --> 01:12:22,920
un effetto collaterale dei quali è il
la realtà spaventosamente reale

1470
01:12:22,920 --> 01:12:26,970
che il piano potrebbe essere necessario
essere riavviato, in modo efficace,

1471
01:12:26,970 --> 01:12:30,290
o potrebbe cadere, peggio, come si vola.

1472
01:12:30,290 --> 01:12:32,230
Così questi tipi di problemi
sono ancora con noi,

1473
01:12:32,230 --> 01:12:36,130
even-- questo è stato un articolo 2015,
tanto più spaventoso

1474
01:12:36,130 --> 01:12:39,100
quando non si necessariamente
capire, apprezzare, o anticipare

1475
01:12:39,100 --> 01:12:41,640
quei tipi di errori.

1476
01:12:41,640 --> 01:12:45,030
>> Così si scopre c'è un altro
cosa negativa di rappresentazione dei dati.

1477
01:12:45,030 --> 01:12:50,080
Si scopre che anche i galleggianti sono
sorta di imperfetto, perché galleggia, troppo,

1478
01:12:50,080 --> 01:12:54,440
Ho proposto sono a 32 bit, o
forse 64 se si utilizza un doppio.

1479
01:12:54,440 --> 01:12:56,070
Ma questo è ancora finita.

1480
01:12:56,070 --> 01:13:00,070
>> E il problema è che se si può
mettere un numero infinito di numeri

1481
01:13:00,070 --> 01:13:02,460
dopo il punto decimale,
non vi è alcun modo di

1482
01:13:02,460 --> 01:13:05,690
può rappresentare tutte le possibili
numeri che ci è stato insegnato

1483
01:13:05,690 --> 01:13:07,990
nel grado scuola può esistere nel mondo.

1484
01:13:07,990 --> 01:13:11,870
Un computer, essenzialmente, deve
scegliere un sottoinsieme di questi numeri

1485
01:13:11,870 --> 01:13:13,200
per rappresentare accuratamente.

1486
01:13:13,200 --> 01:13:15,450
>> Ora, il computer può
tondo forse un po ',

1487
01:13:15,450 --> 01:13:20,900
e può permettere di circa negozio
qualsiasi numero si potrebbe desiderare.

1488
01:13:20,900 --> 01:13:23,940
Ma solo intuitivamente, se si
hanno un numero finito di bit,

1489
01:13:23,940 --> 01:13:27,560
è possibile permutare solo
in tanti modi finiti.

1490
01:13:27,560 --> 01:13:29,570
Così non si può forse
utilizzare un numero finito

1491
01:13:29,570 --> 01:13:32,880
di permutazione di bit,
modelli di zero e uno,

1492
01:13:32,880 --> 01:13:35,940
rappresentare un infinito
numero di numeri,

1493
01:13:35,940 --> 01:13:40,370
il che suggerisce che i computer potrebbero
benissimo essere sdraiato a noi a volte.

1494
01:13:40,370 --> 01:13:41,770
>> In realtà, cerchiamo di fare questo.

1495
01:13:41,770 --> 01:13:44,239
Torniamo in CS50 IDE.

1496
01:13:44,239 --> 01:13:46,030
Lasciami andare avanti e
creare un piccolo programma

1497
01:13:46,030 --> 01:13:50,940
L'imprecisione chiamato, per mostrare che
computer sono, infatti, imprecise.

1498
01:13:50,940 --> 01:13:54,910
>> E mi permetta di andare avanti e iniziare con
alcuni di quel codice da prima,

1499
01:13:54,910 --> 01:13:56,830
e ora solo fare quanto segue.

1500
01:13:56,830 --> 01:14:06,640
Mi permetta di andare avanti e fare printf, per cento
f, backslash n, 1 diviso per 10.

1501
01:14:06,640 --> 01:14:10,430
In altre parole, cerchiamo di tuffo nel profondo
a 1/10, come 1 e diviso per 10.

1502
01:14:10,430 --> 01:14:12,760
Sicuramente, un computer può rappresentare 1/10.

1503
01:14:12,760 --> 01:14:16,620
>> Quindi cerchiamo di andare avanti e fare l'imprecisione.

1504
01:14:16,620 --> 01:14:17,390
Vediamo.

1505
01:14:17,390 --> 01:14:19,210
Formato specifica tipo double.

1506
01:14:19,210 --> 01:14:21,160
Ma l'argomento è di tipo int.

1507
01:14:21,160 --> 01:14:22,040
Cosa sta succedendo?

1508
01:14:22,040 --> 01:14:24,970
>> Oh, interessante, quindi è un
lezione imparata da prima.

1509
01:14:24,970 --> 01:14:29,050
Sto dicendo, hey, computer di spettacolo
me un galleggiante con cento f.

1510
01:14:29,050 --> 01:14:31,200
Ma io sto dando 2 int.

1511
01:14:31,200 --> 01:14:34,120
Così si scopre, posso risolvere
questo in un paio di modi.

1512
01:14:34,120 --> 01:14:41,430
>> Ho potuto solo girare uno in 1.0, e
10 in 10.0, che sarebbe, in effetti,

1513
01:14:41,430 --> 01:14:45,390
avere l'effetto di conversione
li in floats-- ancora si spera

1514
01:14:45,390 --> 01:14:46,180
lo stesso numero.

1515
01:14:46,180 --> 01:14:48,880
Oppure si scopre che c'è qualcosa
vedremo di nuovo in poco tempo.

1516
01:14:48,880 --> 01:14:50,170
Si potrebbe lanciare i numeri.

1517
01:14:50,170 --> 01:14:52,880
>> È possibile, utilizzando questa parentesi
espressione, si può dire,

1518
01:14:52,880 --> 01:14:55,560
Hey, computer, prendere questa
10, che so essere un int.

1519
01:14:55,560 --> 01:14:57,660
Ma trattare, per favore,
come se fosse un galleggiante.

1520
01:14:57,660 --> 01:14:59,680
Ma questo si sente inutilmente complesso.

1521
01:14:59,680 --> 01:15:02,040
>> Per i nostri scopi di oggi,
facciamo solo letteralmente

1522
01:15:02,040 --> 01:15:05,700
rendono loro i valori in virgola mobile
con un punto decimale, come questo.

1523
01:15:05,700 --> 01:15:10,060
Lasciami andare avanti e replica, fare
imprecisioni, buono, barra dot

1524
01:15:10,060 --> 01:15:11,870
imprecisioni, entrare.

1525
01:15:11,870 --> 01:15:13,990
OK, stiamo guardando bene.

1526
01:15:13,990 --> 01:15:21,194
>> 1 diviso 10, secondo il mio
Mac qui, è, infatti, 0.100000.

1527
01:15:21,194 --> 01:15:24,360
Ora, mi è stato insegnato nella scuola elementare lì
deve essere un numero infinito di 0 di.

1528
01:15:24,360 --> 01:15:26,151
Quindi cerchiamo di almeno provare
per vedere alcuni di questi.

1529
01:15:26,151 --> 01:15:29,770
Si scopre che printf è un po '
amatore ancora che abbiamo usato.

1530
01:15:29,770 --> 01:15:33,890
Si scopre che non è necessario specificare
proprio per cento f, o semplicemente per cento i.

1531
01:15:33,890 --> 01:15:36,830
Si può effettivamente specificare
alcune opzioni di controllo qui.

1532
01:15:36,830 --> 01:15:39,470
>> In particolare, sto andando
per dire, ehi, printf,

1533
01:15:39,470 --> 01:15:42,660
in realtà mi mostra 10 punti decimali.

1534
01:15:42,660 --> 01:15:43,820
Quindi sembra un po 'strano.

1535
01:15:43,820 --> 01:15:45,845
Ma che dici per cento,
punti, quanti numeri

1536
01:15:45,845 --> 01:15:47,970
vuoi vedere dopo il
punto decimale, e quindi f

1537
01:15:47,970 --> 01:15:51,340
per piatta, proprio perché è
quello che dice la documentazione.

1538
01:15:51,340 --> 01:15:53,080
Lasciami andare avanti e salvare questo.

1539
01:15:53,080 --> 01:15:55,460
>> E notare troppo, sto diventando
stanco di riscrivere le cose.

1540
01:15:55,460 --> 01:15:58,900
Così sto solo impostando l'alto e
freccia verso il basso le chiavi qui.

1541
01:15:58,900 --> 01:16:01,710
E se continuo a colpire in su,
può vedere tutti i comandi

1542
01:16:01,710 --> 01:16:04,090
che ho fatto, o non correttamente fatto.

1543
01:16:04,090 --> 01:16:07,630
>> E ho intenzione di andare avanti ora e
in realtà non usare quella, a quanto pare.

1544
01:16:07,630 --> 01:16:14,416
Fare imprecisioni, dot
tagliare imprecision-- così

1545
01:16:14,416 --> 01:16:16,290
quello che mi è stato insegnato a
scuola elementare estrae.

1546
01:16:16,290 --> 01:16:22,010
Anche se stampo a 10 decimale
lo colloca, infatti, è 0.10000.

1547
01:16:22,010 --> 01:16:22,840
Ma sai una cosa?

1548
01:16:22,840 --> 01:16:24,150
>> Prendiamo un po 'avido.

1549
01:16:24,150 --> 01:16:26,990
Diciamo che, come, mostrarmi 55
punti dopo la virgola.

1550
01:16:26,990 --> 01:16:29,160
Facciamo davvero prendere questo
programmare fuori per un giro.

1551
01:16:29,160 --> 01:16:34,170
Mi permetta di rifarlo con make
imprecisioni, barra di punti, imprecisioni.

1552
01:16:34,170 --> 01:16:35,390
>> E qui andiamo.

1553
01:16:35,390 --> 01:16:37,420
La vostra infanzia era una bugia.

1554
01:16:37,420 --> 01:16:51,410
Apparentemente, 1 diviso 10 è infatti
0.100000000000000005551115123--

1555
01:16:51,410 --> 01:16:52,740
>> Cosa sta succedendo?

1556
01:16:52,740 --> 01:16:56,360
Beh, si scopre, se tipo di
guardare abbastanza lontano nel sottostante

1557
01:16:56,360 --> 01:16:58,950
rappresentazione di questo
il numero, in realtà

1558
01:16:58,950 --> 01:17:03,400
non è esattamente 1/10, o 0,1 e
un numero infinito di zeri.

1559
01:17:03,400 --> 01:17:04,630
Ora, perché?

1560
01:17:04,630 --> 01:17:09,250
>> Bene, anche se questo è un semplice
numero per noi esseri umani, 1 diviso per 10,

1561
01:17:09,250 --> 01:17:13,910
è ancora uno di infiniti
numeri che si potrebbe pensare su.

1562
01:17:13,910 --> 01:17:17,490
Ma un computer può rappresentare solo
un numero finito di numeri così.

1563
01:17:17,490 --> 01:17:21,710
E così, di fatto, cosa
computer mostra a noi è il suo più vicino

1564
01:17:21,710 --> 01:17:25,940
approssimazione al numero
vogliamo credere è 1/10,

1565
01:17:25,940 --> 01:17:30,760
o realmente 0.10000 all'infinito.

1566
01:17:30,760 --> 01:17:33,425
>> Piuttosto, però, questo è
il più vicino come si può ottenere.

1567
01:17:33,425 --> 01:17:35,300
E, in effetti, se si guarda
sotto la cappa,

1568
01:17:35,300 --> 01:17:40,050
come noi siamo qui, cercando
55 cifre dopo la virgola,

1569
01:17:40,050 --> 01:17:42,990
in realtà vediamo che la realtà.

1570
01:17:42,990 --> 01:17:45,610
Ora, come un a parte, se hai
mai visto la movie--

1571
01:17:45,610 --> 01:17:48,780
la maggior parte di voi probabilmente haven't--
ma Superman 3 alcuni anni fa,

1572
01:17:48,780 --> 01:17:52,500
Richard Pryor essenzialmente sfruttato questo
la realtà in sua compagnia per rubare un sacco

1573
01:17:52,500 --> 01:17:56,500
di frazioni e frazioni di centesimi,
perché il Company-- come ricordo,

1574
01:17:56,500 --> 01:18:00,210
è stato un while-- era essenzialmente
buttare via tutto ciò che non si adattava

1575
01:18:00,210 --> 01:18:01,790
nella nozione di centesimi.

1576
01:18:01,790 --> 01:18:04,480
>> Ma se si sommano tutti questi
piccoli, piccoli, piccoli numeri ancora una volta,

1577
01:18:04,480 --> 01:18:07,960
e ancora, e ancora, è possibile, come in
il suo caso, fare una buona quantità di denaro.

1578
01:18:07,960 --> 01:18:11,010
>> La stessa idea è stata strappato via da
un più recente, ma ancora oggi più vecchio

1579
01:18:11,010 --> 01:18:13,500
film, chiamato Office Space,
dove i ragazzi in quel film,

1580
01:18:13,500 --> 01:18:16,501
ha fatto la stessa cosa, avvitata in su
completamente, si è conclusa con modo troppo

1581
01:18:16,501 --> 01:18:17,666
soldi nel loro conto in banca.

1582
01:18:17,666 --> 01:18:18,800
E 'stato tutto molto sospetto.

1583
01:18:18,800 --> 01:18:22,290
Ma alla fine della giornata,
imprecisione è tutto intorno a noi.

1584
01:18:22,290 --> 01:18:25,240
>> E che, inoltre, può essere
Spaventosamente il caso.

1585
01:18:25,240 --> 01:18:28,590
Si scopre che Superman 3
e Office Space a parte, ci

1586
01:18:28,590 --> 01:18:31,460
può essere un po 'molto reale
ramificazioni mondiali

1587
01:18:31,460 --> 01:18:35,290
delle realtà imprecisa
rappresentazione dei dati

1588
01:18:35,290 --> 01:18:37,770
che anche noi esseri umani a
questo giorno non necessariamente

1589
01:18:37,770 --> 01:18:41,230
capire come dovremmo,
o ricordare come spesso come dovremmo.

1590
01:18:41,230 --> 01:18:45,950
E, in effetti, il seguente clip è
da uno sguardo ad alcuni mondo molto reale

1591
01:18:45,950 --> 01:18:50,730
ramificazioni di ciò che accade se si
non apprezzano l'imprecisione che

1592
01:18:50,730 --> 01:18:53,065
può accadere nella rappresentazione dei numeri.

1593
01:18:53,065 --> 01:18:54,300
>> [RIPRODUZIONE VIDEO]

1594
01:18:54,300 --> 01:18:58,620
>> -Computers, Tutti abbiamo imparato ad accettare
i problemi spesso frustrante che

1595
01:18:58,620 --> 01:19:03,310
andare con them-- bug, virus,
e anomalie nel software,

1596
01:19:03,310 --> 01:19:06,130
per i piccoli prezzi da pagare
per la comodità.

1597
01:19:06,130 --> 01:19:10,800
Ma in alta tecnologia e ad alta velocità
applicazioni programmi spaziali militari e,

1598
01:19:10,800 --> 01:19:15,800
il più piccolo problema può
essere ingrandita nel disastro.

1599
01:19:15,800 --> 01:19:21,900
>> Il 4 giugno del 1996, gli scienziati preparati
per lanciare un razzo Ariane 5 senza equipaggio.

1600
01:19:21,900 --> 01:19:24,220
Si stava trasportando scientifica
satelliti progettati

1601
01:19:24,220 --> 01:19:27,600
per stabilire con precisione come la
interagisce campo magnetico della terra

1602
01:19:27,600 --> 01:19:30,410
con venti solari.

1603
01:19:30,410 --> 01:19:33,800
Il razzo è stato costruito per
l'Agenzia spaziale europea,

1604
01:19:33,800 --> 01:19:37,370
e sollevato fuori dal suo stabilimento
sulla costa della Guyana francese.

1605
01:19:37,370 --> 01:19:40,540
>> -A Circa 37 secondi in
il volo, in primo luogo

1606
01:19:40,540 --> 01:19:42,270
notato qualcosa stava andando storto.

1607
01:19:42,270 --> 01:19:45,250
Gli ugelli sono orientabili in
un modo che davvero non dovrebbe.

1608
01:19:45,250 --> 01:19:49,580
Circa 40 secondi dall'inizio del volo,
chiaramente, il veicolo era in difficoltà.

1609
01:19:49,580 --> 01:19:51,850
>> Ed è allora che hanno fatto
la decisione di distruggerla.

1610
01:19:51,850 --> 01:19:55,780
Il responsabile della sicurezza gamma, con
enormi coraggio, preme il pulsante,

1611
01:19:55,780 --> 01:20:01,150
fatto saltare in aria il razzo, prima che potesse
diventare un pericolo per la sicurezza pubblica.

1612
01:20:01,150 --> 01:20:04,060
>> -Questo Era la fanciulla
viaggio del Ariane 5.

1613
01:20:04,060 --> 01:20:06,960
E la sua distruzione ha preso
posizionare causa di un difetto

1614
01:20:06,960 --> 01:20:08,822
incorporato nel software del razzo.

1615
01:20:08,822 --> 01:20:11,280
-Il Problema sul Ariane era
che c'era un numero che

1616
01:20:11,280 --> 01:20:13,600
necessaria 64 bit per esprimere.

1617
01:20:13,600 --> 01:20:16,590
E volevano convertire
in un numero a 16 bit.

1618
01:20:16,590 --> 01:20:18,610
Si presume che il
numero avrebbe mai

1619
01:20:18,610 --> 01:20:23,980
essere molto grande, che la maggior parte di quelli
cifre in un numero a 64 bit erano zeri.

1620
01:20:23,980 --> 01:20:25,440
Si sbagliavano.

1621
01:20:25,440 --> 01:20:28,060
>> -La Incapacità di una
programma software per accettare

1622
01:20:28,060 --> 01:20:32,510
il tipo di numero generato da
un altro era alla radice del fallimento.

1623
01:20:32,510 --> 01:20:37,350
Lo sviluppo del software era diventato un
parte molto costosa delle nuove tecnologie.

1624
01:20:37,350 --> 01:20:41,140
Il razzo Ariane sono stati molto
successo, tanto del software

1625
01:20:41,140 --> 01:20:44,550
creata per era anche
utilizzato nella Ariane 5.

1626
01:20:44,550 --> 01:20:50,940
>> -Il Problema di fondo era che il Ariane
5 è stato più veloce, più veloce accelerato.

1627
01:20:50,940 --> 01:20:54,450
E il software non ha avuto
spiega che cosa.

1628
01:20:54,450 --> 01:20:58,060
>> -La Distruzione del razzo
è stato un grande disastro finanziario,

1629
01:20:58,060 --> 01:21:01,790
tutto a causa di un errore di software minuto.

1630
01:21:01,790 --> 01:21:04,210
Ma questo non era il primo
problemi di conversione dei dati in tempo

1631
01:21:04,210 --> 01:21:07,820
aveva afflitto tecnologia dei razzi moderna.

1632
01:21:07,820 --> 01:21:11,050
>> -In 1991 con l'avvio
della prima Guerra del Golfo,

1633
01:21:11,050 --> 01:21:13,570
il Patriot Missile
sperimentato una specie simile

1634
01:21:13,570 --> 01:21:15,800
del problema di conversione numero.

1635
01:21:15,800 --> 01:21:19,090
E come risultato, 28 persone,
28 soldati americani,

1636
01:21:19,090 --> 01:21:22,080
sono stati uccisi, e circa
altri 100 feriti,

1637
01:21:22,080 --> 01:21:25,780
quando il Patriot, che avrebbe dovuto
per la protezione contro rincoramenti arrivo,

1638
01:21:25,780 --> 01:21:28,830
omesso di sparare un missile.

1639
01:21:28,830 --> 01:21:34,670
>> -Quando Iraq invase il Kuwait, e in America
Desert Storm lanciato all'inizio del 1991,

1640
01:21:34,670 --> 01:21:38,780
batterie Patriot Missile sono stati schierati
per proteggere l'Arabia Saudita e Israele

1641
01:21:38,780 --> 01:21:42,230
da attacchi missilistici iracheni Scud.

1642
01:21:42,230 --> 01:21:46,810
La Patriot è un medio raggio US
superficie per aria, prodotto

1643
01:21:46,810 --> 01:21:48,770
dalla società Raytheon.

1644
01:21:48,770 --> 01:21:55,340
>> -La Dimensione del intercettore Patriot
di per sé è di circa circa 20 piedi.

1645
01:21:55,340 --> 01:21:58,230
E pesa circa 2.000 chili.

1646
01:21:58,230 --> 01:22:02,320
E porta una testata di circa,
Penso che sia più o meno 150 libbre.

1647
01:22:02,320 --> 01:22:06,930
E la testata stessa è
un alto esplosivo, che

1648
01:22:06,930 --> 01:22:10,330
ha frammenti intorno ad esso.

1649
01:22:10,330 --> 01:22:14,680
L'involucro della testata è
progettato per agire come pallettoni.

1650
01:22:14,680 --> 01:22:17,110
>> -Le Missili sono svolte
quattro per contenitore,

1651
01:22:17,110 --> 01:22:20,130
e sono trasportati da un semirimorchio.

1652
01:22:20,130 --> 01:22:27,930
>> -Il Sistema Patriot antimissile
risale subito almeno 20 anni.

1653
01:22:27,930 --> 01:22:31,420
È stato originariamente progettato
come un missile di difesa aerea

1654
01:22:31,420 --> 01:22:33,720
di abbattere gli aerei nemici.

1655
01:22:33,720 --> 01:22:37,500
Nella prima Guerra del Golfo,
quando la guerra è arrivato,

1656
01:22:37,500 --> 01:22:42,745
l'esercito voleva usarlo per
abbattere Scud, non aerei.

1657
01:22:42,745 --> 01:22:46,620
>> L'Air Force iracheno era
non tanto di un problema.

1658
01:22:46,620 --> 01:22:49,670
Ma l'esercito era preoccupato per Scud.

1659
01:22:49,670 --> 01:22:53,170
E così hanno cercato di
aggiornare il Patriot.

1660
01:22:53,170 --> 01:22:55,800
>> -Intercepting Un nemico
missile viaggiando a Mach 5

1661
01:22:55,800 --> 01:22:58,830
stava per essere abbastanza impegnativo.

1662
01:22:58,830 --> 01:23:01,490
Ma quando il Patriot
è stato ricoverato in servizio,

1663
01:23:01,490 --> 01:23:05,860
l'esercito non era a conoscenza di un
modifica irachena che ha fatto

1664
01:23:05,860 --> 01:23:08,930
i loro scudi quasi impossibile da colpire.

1665
01:23:08,930 --> 01:23:13,740
>> -Cosa È successo è il Scud che
stavano entrando erano instabili.

1666
01:23:13,740 --> 01:23:14,692
Erano dondolavano.

1667
01:23:14,692 --> 01:23:17,910
La ragione di questo è stato
gli iracheni, in ordine

1668
01:23:17,910 --> 01:23:21,280
per ottenere 600 chilometri
su un chilometro 300

1669
01:23:21,280 --> 01:23:24,700
gamma di missili, ha preso di peso
dalla testata anteriore.

1670
01:23:24,700 --> 01:23:26,390
Hanno fatto la testata più leggero.

1671
01:23:26,390 --> 01:23:30,330
>> Così ora il Patriot è
cercando di venire al Scud.

1672
01:23:30,330 --> 01:23:33,230
E la maggior parte del tempo, la
stragrande maggioranza del tempo,

1673
01:23:33,230 --> 01:23:35,940
sarebbe solo volare dal Scud.

1674
01:23:35,940 --> 01:23:40,260
Una volta che i gestori del sistema Patriot
ha realizzato il Patriot mancato il suo obiettivo,

1675
01:23:40,260 --> 01:23:44,690
hanno fatto esplodere testata del Patriot
al fine di evitare possibili incidenti, se si

1676
01:23:44,690 --> 01:23:47,570
è stato permesso di cadere a terra.

1677
01:23:47,570 --> 01:23:51,790
>> -Che Era quello che la maggior parte delle persone hanno visto,
quei grandi palle di fuoco nel cielo,

1678
01:23:51,790 --> 01:23:57,550
e fraintesa come
intercettazioni di testate Scud.

1679
01:23:57,550 --> 01:23:59,630
>> -Anche Se nella notte
cieli, Patriots apparve

1680
01:23:59,630 --> 01:24:03,370
di essere con successo
distruggendo Scud, a Dhahran,

1681
01:24:03,370 --> 01:24:06,360
ci potrebbe essere nessun errore
sulle sue prestazioni.

1682
01:24:06,360 --> 01:24:10,970
Lì, il sistema radar del Patriot
perso le tracce di un Scud in arrivo,

1683
01:24:10,970 --> 01:24:13,721
e mai lanciato a causa
ad un difetto del software.

1684
01:24:13,721 --> 01:24:17,090

1685
01:24:17,090 --> 01:24:21,940
E 'stato gli israeliani che per primo ha scoperto
che più il sistema era acceso,

1686
01:24:21,940 --> 01:24:25,690
maggiore è il tempo di discrepanza
divenne, a causa di un orologio incorporato

1687
01:24:25,690 --> 01:24:27,810
nel computer del sistema.

1688
01:24:27,810 --> 01:24:31,210
>> -A Proposito di due settimane prima
la tragedia di Dhahran,

1689
01:24:31,210 --> 01:24:33,770
gli israeliani riferito a
il Dipartimento della Difesa

1690
01:24:33,770 --> 01:24:35,590
che il sistema perdeva tempo.

1691
01:24:35,590 --> 01:24:38,360
Dopo circa otto ore o in esecuzione,
hanno notato che il sistema

1692
01:24:38,360 --> 01:24:40,720
stava diventando decisamente meno precise.

1693
01:24:40,720 --> 01:24:44,900
Il Dipartimento della Difesa ha risposto
raccontando tutte le batterie Patriot

1694
01:24:44,900 --> 01:24:47,950
di non lasciare i sistemi
per lungo tempo.

1695
01:24:47,950 --> 01:24:52,160
Non hanno mai detto quello che un lungo periodo di tempo era--
otto ore, 10 ore, 1.000 ore.

1696
01:24:52,160 --> 01:24:54,360
Nessuno sapeva.

1697
01:24:54,360 --> 01:24:56,380
>> -La Batteria Patriot
di stanza presso la caserma

1698
01:24:56,380 --> 01:25:01,350
a Dhahran e la sua viziata interna
orologio era stato in più di 100 ore

1699
01:25:01,350 --> 01:25:04,670
la notte del 25 febbraio.

1700
01:25:04,670 --> 01:25:08,917
>> -E Monitorati tempo con una precisione
di circa un decimo di secondo.

1701
01:25:08,917 --> 01:25:11,000
Ora, un decimo di secondo
è un numero interessante,

1702
01:25:11,000 --> 01:25:14,920
perché non può essere espressa
in binario esattamente, che

1703
01:25:14,920 --> 01:25:19,820
significa che non può essere espressa esattamente
in qualsiasi moderno computer digitale.

1704
01:25:19,820 --> 01:25:21,540
È difficile da credere.

1705
01:25:21,540 --> 01:25:24,210
>> Ma utilizzare questo come esempio.

1706
01:25:24,210 --> 01:25:26,540
Prendiamo il numero di un terzo.

1707
01:25:26,540 --> 01:25:30,350
Un terzo non può essere
espresso in decimali esattamente.

1708
01:25:30,350 --> 01:25:35,080
Un terzo è 0.333
in corso per l'infinito.

1709
01:25:35,080 --> 01:25:39,480
>> Non c'è modo di farlo con
precisione assoluta in decimale.

1710
01:25:39,480 --> 01:25:42,560
Questo è esattamente il tipo di problema
quello che è successo nel Patriot.

1711
01:25:42,560 --> 01:25:47,100
Più lungo è il sistema di corse, il
peggio l'errore di tempo è diventato.

1712
01:25:47,100 --> 01:25:51,890
>> -Dopo 100 ore di funzionamento, la
errore nel tempo era solo circa un terzo

1713
01:25:51,890 --> 01:25:53,600
di un secondo.

1714
01:25:53,600 --> 01:25:57,210
Ma in termini di mira un
missile viaggiando a Mach 5,

1715
01:25:57,210 --> 01:26:01,710
si è tradotto in un inseguimento
errore di oltre 600 metri.

1716
01:26:01,710 --> 01:26:05,120
Sarebbe un errore fatale
per i soldati su cosa

1717
01:26:05,120 --> 01:26:11,940
successo è un lancio Scud era
rilevato dai satelliti di preallarme

1718
01:26:11,940 --> 01:26:15,860
e sapevano che il Scud era
venendo nella loro direzione generale.

1719
01:26:15,860 --> 01:26:18,320
Non sapevano dove venisse.

1720
01:26:18,320 --> 01:26:21,250
>> -Era Ora fino al radar
componente del sistema Patriot

1721
01:26:21,250 --> 01:26:26,190
difendere Dhahran per individuare e mantenere
traccia del missile nemico in arrivo.

1722
01:26:26,190 --> 01:26:27,609
>> -Il Radar era molto intelligente.

1723
01:26:27,609 --> 01:26:29,650
Sarebbe in realtà tenere traccia
la posizione del Scud,

1724
01:26:29,650 --> 01:26:33,350
e poi prevedere dove probabilmente
sarebbe la prossima volta radar inviato

1725
01:26:33,350 --> 01:26:34,420
Un impulso fuori.

1726
01:26:34,420 --> 01:26:36,110
Che è stato chiamato un cancello gamma.

1727
01:26:36,110 --> 01:26:40,660
>> -Poi, Una volta che il Patriot
decide il tempo ha

1728
01:26:40,660 --> 01:26:45,450
passato a tornare indietro e controllare il prossimo
posizione per questo oggetto rilevato,

1729
01:26:45,450 --> 01:26:46,600
risale.

1730
01:26:46,600 --> 01:26:51,650
Così, quando si tornò al sbagliata
posto, poi vede nessun oggetto.

1731
01:26:51,650 --> 01:26:55,160
E decide che non c'era
oggetto, si trattava di un falso rilevamento,

1732
01:26:55,160 --> 01:26:56,930
e scende in pista.

1733
01:26:56,930 --> 01:27:00,030
>> -Il Scud in entrata scomparso
dallo schermo radar.

1734
01:27:00,030 --> 01:27:03,260
E pochi secondi dopo, è
sbattuto in caserma.

1735
01:27:03,260 --> 01:27:09,150
Il Scud ucciso 28, ed è stato l'ultimo
uno sparato durante la prima Guerra del Golfo.

1736
01:27:09,150 --> 01:27:14,960
>> Tragicamente, il software aggiornato
arrivati ​​a Dhahran il giorno seguente.

1737
01:27:14,960 --> 01:27:17,930
Il difetto del software aveva
stato, chiusura fisso

1738
01:27:17,930 --> 01:27:22,806
un capitolo nella travagliata
la storia del missile Patriot.

1739
01:27:22,806 --> 01:27:23,729
>> [RIPRODUZIONE VIDEO]

1740
01:27:23,729 --> 01:27:26,520
David J. MALAN: Quindi questo è tutto da
dire che questi problemi di trabocco

1741
01:27:26,520 --> 01:27:28,860
e l'imprecisione sono fin troppo reale.

1742
01:27:28,860 --> 01:27:29,920
Così come siamo arrivati ​​qui?

1743
01:27:29,920 --> 01:27:31,895
Abbiamo iniziato con solo parlando di printf.

1744
01:27:31,895 --> 01:27:34,270
Anche questa funzione che
stampa qualcosa sullo schermo,

1745
01:27:34,270 --> 01:27:36,450
e abbiamo introdotto successivamente
alcune altre funzioni

1746
01:27:36,450 --> 01:27:37,945
dalla cosiddetta biblioteca di CS50.

1747
01:27:37,945 --> 01:27:39,910
E noi continueremo a
vedere questi a tempo debito.

1748
01:27:39,910 --> 01:27:43,760
E noi, in particolare, usato stringa di ottenere,
e ottenere int, e ora anche ottenere galleggiante,

1749
01:27:43,760 --> 01:27:47,410
e altri ancora saranno ancora che incontrano
e utilizzare noi stessi in breve tempo.

1750
01:27:47,410 --> 01:27:50,220
>> Ma a volte, avere
abbiamo già visto un bisogno

1751
01:27:50,220 --> 01:27:53,520
per memorizzare ciò che quelle funzioni mano indietro?

1752
01:27:53,520 --> 01:27:55,920
ci riporta una stringa Essi mano,
o un int, o di un galleggiante.

1753
01:27:55,920 --> 01:27:59,070
E a volte abbiamo bisogno di mettere che
stringa o int, float o, in qualche luogo.

1754
01:27:59,070 --> 01:28:03,100
>> E per memorizzare quelle cose, ricordare solo
come in Scratch, abbiamo variabili.

1755
01:28:03,100 --> 01:28:06,260
Ma a differenza di Scratch,
in C abbiamo tipi effettivi

1756
01:28:06,260 --> 01:28:08,530
dei dati variables--
tipi, più generally--

1757
01:28:08,530 --> 01:28:11,640
tra questi, una stringa, un int, un
float, e questi altri ancora.

1758
01:28:11,640 --> 01:28:15,321
>> E così, quando dichiariamo le variabili in C,
saremo costretti a dichiarare i nostri tipi di dati.

1759
01:28:15,321 --> 01:28:17,820
Questo non è qualcosa faremo
hanno a che fare più avanti nel semestre

1760
01:28:17,820 --> 01:28:19,810
come abbiamo transizione ad altre lingue.

1761
01:28:19,810 --> 01:28:22,610
Ma per ora, abbiamo bisogno
a priori in anticipo,

1762
01:28:22,610 --> 01:28:27,370
spiegare al computer che tipo
di variabili vogliamo che darci.

1763
01:28:27,370 --> 01:28:30,290
>> Ora, nel frattempo, per la stampa
questi tipi di tipi di dati,

1764
01:28:30,290 --> 01:28:32,570
dobbiamo dire printf cosa aspettarsi.

1765
01:28:32,570 --> 01:28:35,450
E abbiamo visto per cento s per le stringhe,
e cento i per interi,

1766
01:28:35,450 --> 01:28:36,790
e pochi altri già.

1767
01:28:36,790 --> 01:28:40,237
E quelli sono semplicemente requisiti
per la presentazione visiva

1768
01:28:40,237 --> 01:28:41,070
di tali informazioni.

1769
01:28:41,070 --> 01:28:45,080
>> E ciascuno di questi può effettivamente essere
parametrizzata o ottimizzato in qualche modo,

1770
01:28:45,080 --> 01:28:48,370
se si vuole ulteriormente il controllo
il tipo di output che si ottiene.

1771
01:28:48,370 --> 01:28:52,604
E, infatti, si scopre che non solo
c'è backslash n per una nuova linea.

1772
01:28:52,604 --> 01:28:55,520
C'è qualcos'altro chiamato backslash
R per un ritorno a capo, che

1773
01:28:55,520 --> 01:28:57,360
è più simile a un
vecchia macchina da scrivere scuola,

1774
01:28:57,360 --> 01:29:00,690
e anche di Windows utilizzato per molti anni.

1775
01:29:00,690 --> 01:29:02,690
>> C'è t backslash per le schede.

1776
01:29:02,690 --> 01:29:06,170
Si scopre, che se si vuole
doppio apice all'interno di una stringa,

1777
01:29:06,170 --> 01:29:08,000
Ricordiamo che abbiamo usato
doppia doppia citazione

1778
01:29:08,000 --> 01:29:10,900
citazione a sinistra e destra
estremità delle nostre corde finora.

1779
01:29:10,900 --> 01:29:12,420
Ciò sembrerebbe confondere le cose.

1780
01:29:12,420 --> 01:29:15,503
>> Se si vuole mettere un doppio apice in
mezzo di una string-- e, anzi,

1781
01:29:15,503 --> 01:29:16,670
è fonte di confusione per vedere.

1782
01:29:16,670 --> 01:29:20,120
E quindi bisogna sfuggire, in modo da
dire, un doppio apice con qualcosa

1783
01:29:20,120 --> 01:29:21,860
come, letteralmente, la barra inversa virgolette.

1784
01:29:21,860 --> 01:29:23,230
E c'è qualche altro ancora.

1785
01:29:23,230 --> 01:29:27,540
E vedremo più di quelli
nell'uso reale non molto.

1786
01:29:27,540 --> 01:29:30,930
>> Quindi cerchiamo di passaggio da ora
dei dati, e la rappresentazione,

1787
01:29:30,930 --> 01:29:33,820
e gli operatori aritmetici, tutto
di cui ci ha dato un po 'di costruzione

1788
01:29:33,820 --> 01:29:35,070
blocchi con cui giocare.

1789
01:29:35,070 --> 01:29:37,481
Ma ora diamo effettivamente dare
noi il resto del vocabolario

1790
01:29:37,481 --> 01:29:39,230
che abbiamo già avuto
la settimana scorsa con Scratch

1791
01:29:39,230 --> 01:29:42,350
per dare un'occhiata a qualche altro
costrutti in C-- non tutti.

1792
01:29:42,350 --> 01:29:44,680
Ma le idee noi siamo
per vedere in realtà solo

1793
01:29:44,680 --> 01:29:48,610
per sottolineare la traduzione dal
una lingua, Scratch, ad un altro, C.

1794
01:29:48,610 --> 01:29:51,470
>> E nel corso del tempo, ci prendiamo
più strumenti per il nostro toolkit,

1795
01:29:51,470 --> 01:29:52,820
per così dire, sintatticamente.

1796
01:29:52,820 --> 01:29:57,190
E, in effetti, si vedrà che le idee
sono ormai piuttosto familiare della scorsa settimana.

1797
01:29:57,190 --> 01:29:58,200
Quindi cerchiamo di fare questo.

1798
01:29:58,200 --> 01:30:01,870
>> Andiamo avanti e improvvisare un programma
che in realtà utilizza alcune espressioni,

1799
01:30:01,870 --> 01:30:03,720
una espressione booleana.

1800
01:30:03,720 --> 01:30:05,810
Lasciami andare avanti qui
e creare un nuovo file.

1801
01:30:05,810 --> 01:30:09,090
Chiamerò questo condition.c.

1802
01:30:09,090 --> 01:30:12,350
>> Lasciami andare avanti e
includere la libreria CS50.

1803
01:30:12,350 --> 01:30:15,640
E mi permetta di andare avanti e includo
standard di io.h per le nostre funzioni,

1804
01:30:15,640 --> 01:30:17,690
e printf, e altro ancora, rispettivamente.

1805
01:30:17,690 --> 01:30:21,900
Permettetemi di fare a me stesso che boilerplate di
int void main, la cui spiegazione faremo

1806
01:30:21,900 --> 01:30:23,360
tornare in futuro.

1807
01:30:23,360 --> 01:30:26,820
>> Ora vorrei andare avanti e dare
io stesso un int tramite get int.

1808
01:30:26,820 --> 01:30:28,970
Allora mi permetta di andare avanti e fare questo.

1809
01:30:28,970 --> 01:30:33,150
Voglio dire se i è less-- facciamo
distinguere tra positivo, negativo,

1810
01:30:33,150 --> 01:30:34,260
o valori zero.

1811
01:30:34,260 --> 01:30:39,630
>> Quindi, se i è minore di zero, mi permetta
basta questo programma semplicemente dire,

1812
01:30:39,630 --> 01:30:45,370
negativo, backslash n, altro
se i è maggiore di zero.

1813
01:30:45,370 --> 01:30:50,030
Ora sto, ovviamente, andando a dire
printf positivo, backslash n.

1814
01:30:50,030 --> 01:30:53,690
E poi altro se: avrei potuto fare questo.

1815
01:30:53,690 --> 01:30:56,410
>> Ho potuto fare se è uguale a 0.

1816
01:30:56,410 --> 01:30:58,840
Ma io avrei fatto a
Almeno un errore già.

1817
01:30:58,840 --> 01:31:02,480
Ricordiamo che il segno di uguale è
non uguale, come noi esseri umani sanno.

1818
01:31:02,480 --> 01:31:04,010
>> Ma è l'operatore di assegnazione.

1819
01:31:04,010 --> 01:31:08,640
E noi non vogliamo prendere sul 0
destra e metterlo in i sulla sinistra.

1820
01:31:08,640 --> 01:31:14,810
Quindi, per evitare questa confusione, o
forse cattivo uso del segno di uguale,

1821
01:31:14,810 --> 01:31:17,740
gli esseri umani hanno deciso alcuni anni fa,
che in molti linguaggi di programmazione

1822
01:31:17,740 --> 01:31:21,000
quando si desidera controllare per l'uguaglianza
tra la sinistra e la destra,

1823
01:31:21,000 --> 01:31:22,635
che effettivamente utilizzate è pari a pari.

1824
01:31:22,635 --> 01:31:24,010
Così si colpisce il segno di uguale due volte.

1825
01:31:24,010 --> 01:31:28,600
Quando si desidera assegnare da destra
a sinistra, è possibile utilizzare un unico segno di uguale.

1826
01:31:28,600 --> 01:31:32,360
Così abbiamo potuto fare altro questo--
se è uguale a è uguale a zero.

1827
01:31:32,360 --> 01:31:34,710
>> Potrei poi andare a
aprire le mie parentesi graffe,

1828
01:31:34,710 --> 01:31:39,087
e dire, printf 0, backslash n, fatto.

1829
01:31:39,087 --> 01:31:41,170
Ma ricordare come questi
forchette in mezzo alla strada in grado di lavorare.

1830
01:31:41,170 --> 01:31:42,836
E, in realtà, basta pensare alla logica.

1831
01:31:42,836 --> 01:31:44,510
i è un numero.

1832
01:31:44,510 --> 01:31:46,320
Si tratta di un intero, in particolare.

1833
01:31:46,320 --> 01:31:51,600
E questo significa che sta andando ad essere meno
di 0 o maggiore di 0 o 0.

1834
01:31:51,600 --> 01:31:54,600
Quindi non vi è una specie di questo
caso di default implicito.

1835
01:31:54,600 --> 01:31:57,920
>> E così abbiamo potuto, proprio come
Scratch, a meno della else if,

1836
01:31:57,920 --> 01:31:58,747
e solo dire altro.

1837
01:31:58,747 --> 01:32:00,830
Logicamente, se la
programmatore sa c'è solo

1838
01:32:00,830 --> 01:32:04,635
tre secchi in cui un
scenario può fall-- il primo,

1839
01:32:04,635 --> 01:32:06,510
il secondo, o il terzo
in questo case-- non lo fanno

1840
01:32:06,510 --> 01:32:10,100
fastidio aggiungendo la precisione aggiuntivo
e la logica aggiuntiva lì.

1841
01:32:10,100 --> 01:32:12,690
Basta andare avanti con il
caso di default qui di altro.

1842
01:32:12,690 --> 01:32:14,950
>> Ora, andiamo avanti
dopo aver salvato questo, fare

1843
01:32:14,950 --> 01:32:18,760
condizioni dot tagliare conditions--
Non una grande interfaccia utente,

1844
01:32:18,760 --> 01:32:21,914
perché io non sto spingendo la
utente, come ho detto prima.

1845
01:32:21,914 --> 01:32:22,580
Ma va bene.

1846
01:32:22,580 --> 01:32:23,454
Terremo le cose semplici.

1847
01:32:23,454 --> 01:32:24,890
Proviamo il numero 42.

1848
01:32:24,890 --> 01:32:26,240
E questo è positivo.

1849
01:32:26,240 --> 01:32:29,120
Proviamo il numero
negativo 42, negativo.

1850
01:32:29,120 --> 01:32:31,244
>> Proviamo il valore 0.

1851
01:32:31,244 --> 01:32:32,160
E, in effetti, funziona.

1852
01:32:32,160 --> 01:32:36,900
Ora, si vedrà con problemi prima
lunghe, le cose di prova tre volte,

1853
01:32:36,900 --> 01:32:37,980
Probabilmente non è sufficiente.

1854
01:32:37,980 --> 01:32:40,438
Probabilmente si desidera testare alcuni
numeri più grandi, un po 'più piccolo

1855
01:32:40,438 --> 01:32:43,520
numeri, alcuni casi angolo, come
verremo a descriverli.

1856
01:32:43,520 --> 01:32:45,500
>> Ma per ora, questo è un
programma piuttosto semplice.

1857
01:32:45,500 --> 01:32:48,160
E sono abbastanza sicuro che, logicamente,
che cade in tre casi.

1858
01:32:48,160 --> 01:32:52,360
E, in effetti, anche se abbiamo solo
concentrati sui potenziali aspetti negativi

1859
01:32:52,360 --> 01:32:56,480
di imprecisione e troppo pieno, in
realtà dove molti dei problemi di CS50,

1860
01:32:56,480 --> 01:32:59,000
non stiamo andando a preoccuparsi
A proposito, per tutto il tempo,

1861
01:32:59,000 --> 01:33:02,050
questi problemi di troppo pieno e
imprecisioni, perché, infatti, in C,

1862
01:33:02,050 --> 01:33:04,889
non è poi così
facile da evitare quelle cose.

1863
01:33:04,889 --> 01:33:07,180
Se si desidera contare fino
più grande, e più grande, e più grande,

1864
01:33:07,180 --> 01:33:10,510
si scopre ci sono tecniche che
può usare, che spesso coinvolgono cose chiamate

1865
01:33:10,510 --> 01:33:14,240
biblioteche, collezioni di codice, che
altre persone hanno scritto che è possibile utilizzare,

1866
01:33:14,240 --> 01:33:16,910
e altri linguaggi come
Java e altri, in realtà

1867
01:33:16,910 --> 01:33:18,800
rendere molto più facile
a contare ancora più in alto.

1868
01:33:18,800 --> 01:33:22,810
Così è davvero alcuni di questi pericoli
una funzione del linguaggio che si usa.

1869
01:33:22,810 --> 01:33:25,710
E nelle prossime settimane, ci
vedere come pericoloso C davvero

1870
01:33:25,710 --> 01:33:27,950
può essere se non si utilizza in modo corretto.

1871
01:33:27,950 --> 01:33:30,610
Ma da lì, e con
Python, e JavaScript, sarà

1872
01:33:30,610 --> 01:33:35,620
abbiamo strato su alcune protezioni aggiuntive,
ed eseguire meno di tali rischi.

1873
01:33:35,620 --> 01:33:38,820
>> Quindi cerchiamo di fare un po 'di più
logica interessante nel nostro programma.

1874
01:33:38,820 --> 01:33:42,110
Quindi, mi permetta di andare avanti e di creare
un programma denominato Logical

1875
01:33:42,110 --> 01:33:46,804
solo così posso giocare con alcuni
la logica attuale, logical.c.

1876
01:33:46,804 --> 01:33:49,870
Mi limiterò a copiare e incollare un po '
codice da così presto torno

1877
01:33:49,870 --> 01:33:52,950
a questo bel punto di partenza.

1878
01:33:52,950 --> 01:33:56,980
>> Lasciami fare questa volta C. char Sono
andare a dargli un nome di C

1879
01:33:56,980 --> 01:34:01,510
solo perché è convenzionale,
ottenere un carattere dall'utente.

1880
01:34:01,510 --> 01:34:03,730
E facciamo finta come
Sto implementando parte

1881
01:34:03,730 --> 01:34:07,130
di quel programma Rm, la rimozione
programma prima che ha spinto l'utente

1882
01:34:07,130 --> 01:34:08,400
per rimuovere un file.

1883
01:34:08,400 --> 01:34:09,750
Come potremmo fare questo?

1884
01:34:09,750 --> 01:34:14,090
>> Voglio dire, se è uguale a C
è uguale, tra virgolette,

1885
01:34:14,090 --> 01:34:19,304
y, quindi ho intenzione di assumere
che l'utente ha scelto sì.

1886
01:34:19,304 --> 01:34:20,470
Sto solo andando a stampare sì.

1887
01:34:20,470 --> 01:34:22,440
Se fosse in realtà la scrittura
il programma di rimozione,

1888
01:34:22,440 --> 01:34:24,420
potremmo rimuovere il file
con più linee di codice.

1889
01:34:24,420 --> 01:34:25,461
Ma noi terremo le cose semplici.

1890
01:34:25,461 --> 01:34:28,950

1891
01:34:28,950 --> 01:34:34,250
>> Altrimenti, se c è uguale uguale n--
e ora qui, ho intenzione di dire,

1892
01:34:34,250 --> 01:34:35,980
l'utente deve aver significato no.

1893
01:34:35,980 --> 01:34:37,360
E poi gli altri, sai una cosa?

1894
01:34:37,360 --> 01:34:39,200
Non so che altro
l'utente sta per digitare.

1895
01:34:39,200 --> 01:34:41,533
Così sto solo andando a dire che
che è un errore, qualunque

1896
01:34:41,533 --> 01:34:43,070
lui o lei in realtà digitato.

1897
01:34:43,070 --> 01:34:44,180
>> Allora, cosa sta succedendo qui?

1898
01:34:44,180 --> 01:34:47,530
Vi è una differenza fondamentale
rispetto a quello che ho fatto in passato.

1899
01:34:47,530 --> 01:34:52,300
doppi apici, doppi apici, doppio
citazioni, e, tuttavia, virgolette singole,

1900
01:34:52,300 --> 01:34:53,170
apici.

1901
01:34:53,170 --> 01:34:55,860
Risulta in C, che quando
si vuole scrivere una stringa,

1902
01:34:55,860 --> 01:34:59,680
si fa usare le virgolette, proprio come abbiamo
state utilizzando tutto questo tempo con printf.

1903
01:34:59,680 --> 01:35:05,030
>> Ma se si vuole affrontare con un solo
singolo carattere, un cosiddetto char,

1904
01:35:05,030 --> 01:35:06,780
poi effettivamente utilizzati apici.

1905
01:35:06,780 --> 01:35:08,450
Quelli di voi che hanno programmato
prima, non si potrebbe avere

1906
01:35:08,450 --> 01:35:10,850
ha dovuto preoccuparsi di questo
distinzione in alcune lingue.

1907
01:35:10,850 --> 01:35:12,450
In C, esso non importa.

1908
01:35:12,450 --> 01:35:15,560
E così, quando ho un carattere e voglio
per confrontare che char utilizzando eguali

1909
01:35:15,560 --> 01:35:21,350
è uguale a qualche lettera, come Y o N, lo faccio,
anzi, devono avere le virgolette singole.

1910
01:35:21,350 --> 01:35:22,770
>> Ora, andiamo avanti e fare questo.

1911
01:35:22,770 --> 01:35:29,180
Andiamo avanti e facciamo
dot logiche tagliano logico.

1912
01:35:29,180 --> 01:35:30,305
E ora sto venga richiesto.

1913
01:35:30,305 --> 01:35:33,638
Quindi, presumibilmente, una migliore esperienza utente
sarebbe in realtà mi dica cosa fare qui.

1914
01:35:33,638 --> 01:35:36,030
Ma ho intenzione di ciecamente
y dire per Sì, OK, bello.

1915
01:35:36,030 --> 01:35:38,780
>> Corriamo ancora, n per no, bello.

1916
01:35:38,780 --> 01:35:42,610
Supponiamo come certe persone che conosco,
i miei tasto Bloc Maiusc è su troppo spesso.

1917
01:35:42,610 --> 01:35:46,740
Così faccio capitale Y, immettere, errore.

1918
01:35:46,740 --> 01:35:49,130
OK, non è esattamente quello che mi aspetto.

1919
01:35:49,130 --> 01:35:51,170
Infatti, il computer
sta facendo letteralmente ciò

1920
01:35:51,170 --> 01:35:54,794
Ho detto che per verificare la presenza di fare--
minuscole y e minuscole n.

1921
01:35:54,794 --> 01:35:56,960
Questo non si sente come bene
l'esperienza degli utenti, però.

1922
01:35:56,960 --> 01:36:02,010
Mi permetta di chiedere e accetto
sia minuscolo o maiuscolo.

1923
01:36:02,010 --> 01:36:05,090
Così si scopre, si potrebbe desiderare
a dire qualcosa di simile a Scratch,

1924
01:36:05,090 --> 01:36:11,150
come letteralmente o uguale a C
è uguale a capitale singolo y citato.

1925
01:36:11,150 --> 01:36:14,400
Risulta, C non ha
questa parola chiave letterale o.

1926
01:36:14,400 --> 01:36:15,880
>> Ma ha due barre verticali.

1927
01:36:15,880 --> 01:36:18,463
È necessario tenere premuto Shift solito,
se si sta utilizzando una tastiera americana,

1928
01:36:18,463 --> 01:36:21,910
e ha colpito la barra verticale
chiave sopra il tasto invio.

1929
01:36:21,910 --> 01:36:25,410
Ma questa barra verticale
barra verticale significa o.

1930
01:36:25,410 --> 01:36:29,220
>> Se, invece, volevamo
a dire e, come in Scratch,

1931
01:36:29,220 --> 01:36:31,180
potremmo fare e commerciale e commerciale.

1932
01:36:31,180 --> 01:36:34,330
Questo non ha senso logico qui,
perché un essere umano non poteva

1933
01:36:34,330 --> 01:36:40,110
digitato sia y e y minuscola
e il capitale Y come lo stesso carattere.

1934
01:36:40,110 --> 01:36:42,470
Quindi, o è quello che vogliamo qui.

1935
01:36:42,470 --> 01:36:49,280
>> Quindi, se faccio questo in entrambi i luoghi, o c
è uguale a equals capitale N, ora eseguire di nuovo,

1936
01:36:49,280 --> 01:36:52,390
rendere logico, eseguire nuovamente logico.

1937
01:36:52,390 --> 01:36:54,200
Ora, posso digitare y.

1938
01:36:54,200 --> 01:36:56,920
E posso farlo di nuovo con
capitale Y, o al capitale N.

1939
01:36:56,920 --> 01:36:59,630
E potrei aggiungere ulteriore
combinazioni ancora.

1940
01:36:59,630 --> 01:37:01,810
>> Quindi questa è una logica
programma nella misura in cui la società

1941
01:37:01,810 --> 01:37:04,940
Sto controllando logicamente
questo valore o questo valore.

1942
01:37:04,940 --> 01:37:09,420
E io non devo, necessariamente,
venire con altri due IFS oppure IFS.

1943
01:37:09,420 --> 01:37:12,960
Posso effettivamente combinare alcuni dei
correlate logica insieme in questo modo.

1944
01:37:12,960 --> 01:37:14,950
Quindi questo sarebbe meglio
progettata che semplicemente

1945
01:37:14,950 --> 01:37:20,490
dicendo, se è uguale a C minuscola y,
stampare sì, altrimenti se c è uguale a capitale Y,

1946
01:37:20,490 --> 01:37:23,074
stampare sì, altrimenti se c è uguale
lower-- in altre parole,

1947
01:37:23,074 --> 01:37:24,990
non si deve avere
sempre più rami.

1948
01:37:24,990 --> 01:37:31,840
È possibile combinare alcuni dei equivalente
rami logicamente, come in questo modo.

1949
01:37:31,840 --> 01:37:37,150
>> Quindi, diamo uno sguardo a un solo
ingrediente finale, una costruzione finale,

1950
01:37:37,150 --> 01:37:37,847
che permette C.

1951
01:37:37,847 --> 01:37:39,930
E ci torneremo in
futuro per altri ancora.

1952
01:37:39,930 --> 01:37:44,400
E poi ci concludiamo, cercando
di non la correttezza della code--

1953
01:37:44,400 --> 01:37:49,070
ottenere il codice per work-- ma il design
di codice, e piantare quei semi nella fase iniziale.

1954
01:37:49,070 --> 01:37:54,337
>> Quindi, mi permetta di andare avanti e
aprire un nuovo file qui.

1955
01:37:54,337 --> 01:37:54,920
Sai cosa?

1956
01:37:54,920 --> 01:37:57,450
Ho intenzione di re-implementare
quello stesso programma,

1957
01:37:57,450 --> 01:37:58,940
ma utilizzando un costrutto diverso.

1958
01:37:58,940 --> 01:38:03,110
>> Quindi, mi permetta rapidamente donarmi
l'accesso per includere CS50.h

1959
01:38:03,110 --> 01:38:07,150
per la biblioteca CS50,
standard di io.h per printf.

1960
01:38:07,150 --> 01:38:09,510
Dammi il mio int void main.

1961
01:38:09,510 --> 01:38:12,310
E poi qui, lasciare
me andare avanti e fare questo.

1962
01:38:12,310 --> 01:38:15,010
>> Char c ottiene ottenere char, proprio come prima.

1963
01:38:15,010 --> 01:38:19,770
E ho intenzione di utilizzare un nuovo costrutto
now-- passare, su ciò che carattere?

1964
01:38:19,770 --> 01:38:22,820
Così interruttore è un po 'come
commutazione a binari del treno.

1965
01:38:22,820 --> 01:38:25,070
Oppure, in realtà, è una specie di
un altro caso, se il resto se,

1966
01:38:25,070 --> 01:38:26,980
ma scritta in modo diverso.

1967
01:38:26,980 --> 01:38:28,490
>> Un interruttore simile a questa.

1968
01:38:28,490 --> 01:38:32,060
Hai interruttore, e poi cosa
carattere o il numero che si desidera guardare,

1969
01:38:32,060 --> 01:38:35,000
poi alcune parentesi graffe come in
Scratch, basta dire fare questa roba.

1970
01:38:35,000 --> 01:38:36,480
E poi ci sono diversi casi.

1971
01:38:36,480 --> 01:38:37,830
>> Non si utilizza se e altro.

1972
01:38:37,830 --> 01:38:40,050
È letteralmente utilizzare il caso di parola.

1973
01:38:40,050 --> 01:38:41,790
E si potrebbe dire qualcosa di simile.

1974
01:38:41,790 --> 01:38:46,820
>> Così, nel caso di un minuscolo y,
o nel caso di un capitale Y,

1975
01:38:46,820 --> 01:38:50,350
andare avanti e stampare sì.

1976
01:38:50,350 --> 01:38:52,020
E poi uscire l'interruttore.

1977
01:38:52,020 --> 01:38:52,580
Questo è tutto.

1978
01:38:52,580 --> 01:38:53,880
Sono state fatte.

1979
01:38:53,880 --> 01:39:00,270
>> Altrimenti, se, per così dire,
minuscolo n, o il capitale N,

1980
01:39:00,270 --> 01:39:05,560
poi andare avanti e di stampa
fuori no, e poi pausa.

1981
01:39:05,560 --> 01:39:11,022
Else-- e questo tipo di è il
caso di default indeed-- printf error--

1982
01:39:11,022 --> 01:39:13,980
e per buona misura, anche se
logicamente questa rottura non è necessario

1983
01:39:13,980 --> 01:39:15,896
perché siamo alla fine
dell'interruttore comunque,

1984
01:39:15,896 --> 01:39:17,520
Ora sto rompendo fuori dello switch.

1985
01:39:17,520 --> 01:39:19,280
Quindi, questo sembra un po 'diverso.

1986
01:39:19,280 --> 01:39:21,272
>> Ma, logicamente, è
in realtà equivalente.

1987
01:39:21,272 --> 01:39:22,980
E perché useresti
uno sopra l'altro?

1988
01:39:22,980 --> 01:39:26,220
A volte, solo preferenze personali,
a volte l'estetica,

1989
01:39:26,220 --> 01:39:28,420
se Guardo questo
Ora, c'è qualcosa

1990
01:39:28,420 --> 01:39:30,510
da dire per la
la leggibilità del codice.

1991
01:39:30,510 --> 01:39:33,690
Voglio dire, non importa il fatto che questo
il codice è nuovo per molti di noi nella stanza.

1992
01:39:33,690 --> 01:39:36,515
>> Ma è solo un po 'è abbastanza.

1993
01:39:36,515 --> 01:39:40,760
Vedete minuscolo Y, Y capitale,
minuscolo n, di default N maiuscola,

1994
01:39:40,760 --> 01:39:43,150
solo tipo di salti
fuori a voi in modo

1995
01:39:43,150 --> 01:39:45,200
che, probabilmente, forse
Nell'esempio precedente

1996
01:39:45,200 --> 01:39:48,780
con i se, e le barre verticali,
e le IFS altro, non potrebbero avere.

1997
01:39:48,780 --> 01:39:54,600
Quindi questo è veramente una questione di personale
scelta, in realtà, o la leggibilità,

1998
01:39:54,600 --> 01:39:55,360
del codice.

1999
01:39:55,360 --> 01:40:01,230
>> Ma in termini di funzionalità, mi permetta
andare avanti e fare un interruttore, barra dot

2000
01:40:01,230 --> 01:40:08,830
interruttore, e ora digitare y minuscolo,
capitale Y, minuscolo n, N maiuscola,

2001
01:40:08,830 --> 01:40:12,250
David, riprovare perché è
Non un singolo carattere.

2002
01:40:12,250 --> 01:40:15,050
Facciamo x, l'errore, come previsto.

2003
01:40:15,050 --> 01:40:18,640
E, logically-- e questo è qualcosa
Vorrei incoraggiare a general-- anche

2004
01:40:18,640 --> 01:40:20,790
anche se siamo solo graffiare la
superficie di alcune di queste caratteristiche.

2005
01:40:20,790 --> 01:40:23,560
>> E potrebbe non essere evidente quando si
te sedersi alla tastiera,

2006
01:40:23,560 --> 01:40:24,370
come funziona?

2007
01:40:24,370 --> 01:40:25,240
Cosa sarebbe questo fare?

2008
01:40:25,240 --> 01:40:28,630
La cosa bella di avere
un computer portatile, o desktop, o l'accesso

2009
01:40:28,630 --> 01:40:32,290
a un computer con un compilatore,
e con un editor di codice come questo,

2010
01:40:32,290 --> 01:40:35,990
è che si può quasi sempre rispondere a queste
Domande per te solo per provare.

2011
01:40:35,990 --> 01:40:39,570
>> Per esempio, se la retorica
domanda a portata di mano erano,

2012
01:40:39,570 --> 01:40:42,540
cosa succede se si dimentica
le sue dichiarazioni pausa?

2013
01:40:42,540 --> 01:40:44,400
Che è in realtà un
cosa molto comune da fare,

2014
01:40:44,400 --> 01:40:46,540
perché non sembra
come si ha realmente bisogno di loro.

2015
01:40:46,540 --> 01:40:49,790
In realtà non completano la vostra
pensato come una parentesi o un riccio

2016
01:40:49,790 --> 01:40:50,714
brace fa.

2017
01:40:50,714 --> 01:40:52,630
Andiamo avanti e
ricompilare il codice e vedere.

2018
01:40:52,630 --> 01:40:56,690
Quindi, fare interruttore, interruttore barra dot.

2019
01:40:56,690 --> 01:40:59,435
Facciamo digitare in minuscolo
y, il bauletto, Enter.

2020
01:40:59,435 --> 01:41:02,390

2021
01:41:02,390 --> 01:41:03,700
Così ho digitato y.

2022
01:41:03,700 --> 01:41:07,420
>> Il programma ha detto sì, no, errore,
come se stava cambiando la sua mente.

2023
01:41:07,420 --> 01:41:12,280
Ma che tipo di stato, perché ciò che accade
con un interruttore è il primo caso

2024
01:41:12,280 --> 01:41:16,899
partita significa essenzialmente, hey di computer,
eseguire tutto il codice sottostante.

2025
01:41:16,899 --> 01:41:19,690
E se non dici pausa, o
non dire rompere, o non dire pausa,

2026
01:41:19,690 --> 01:41:22,540
il computer sta per soffiare
attraverso tutte quelle linee

2027
01:41:22,540 --> 01:41:25,779
ed eseguire tutti loro fino a quando
si arriva a quella parentesi graffa.

2028
01:41:25,779 --> 01:41:27,320
Così i freni sono, infatti, necessario.

2029
01:41:27,320 --> 01:41:30,120
Ma un take-away qui è, quando
Nel dubbio, provare qualcosa.

2030
01:41:30,120 --> 01:41:32,510
Forse salvare il codice prima,
o salvarlo in un file in più

2031
01:41:32,510 --> 01:41:35,930
se siete veramente preoccupati
incasinare e di dover recuperare

2032
01:41:35,930 --> 01:41:37,430
il lavoro che si sa sta lavorando.

2033
01:41:37,430 --> 01:41:38,410
>> Ma provare cose.

2034
01:41:38,410 --> 01:41:41,074
E non essere così paura, forse,
di ciò che il computer potrebbe fare,

2035
01:41:41,074 --> 01:41:42,490
o che si potrebbe rompere qualcosa.

2036
01:41:42,490 --> 01:41:45,790
Si può sempre ritornare indietro
a qualche versione precedente.

2037
01:41:45,790 --> 01:41:48,640
>> Così finiamo cercando
alla progettazione di codice.

2038
01:41:48,640 --> 01:41:52,020
Abbiamo questa capacità ora di scrivere
le condizioni, e cicli di scrittura,

2039
01:41:52,020 --> 01:41:53,850
e variabili, e le funzioni di chiamata.

2040
01:41:53,850 --> 01:41:57,590
Quindi, francamente, siamo sorta di indietro
dove siamo stati una settimana fa con Scratch,

2041
01:41:57,590 --> 01:42:03,120
anche se con un testo meno convincente
ambiente di Scratch permette.

2042
01:42:03,120 --> 01:42:06,990
>> Ma notiamo quanto velocemente abbiamo acquisito
quel vocabolario, anche se è

2043
01:42:06,990 --> 01:42:10,570
andando a prendere un po 'di tempo per affondare in,
così che ora possiamo utilizzare questo vocabolario

2044
01:42:10,570 --> 01:42:13,320
scrivere programmi più interessanti.

2045
01:42:13,320 --> 01:42:15,940
E facciamo un passo bambino
verso quella, come segue.

2046
01:42:15,940 --> 01:42:17,890
Lasciami andare avanti e
creare un nuovo file qui.

2047
01:42:17,890 --> 01:42:20,750
>> Ho intenzione di chiamare questo
prototype.c, e di introdurre

2048
01:42:20,750 --> 01:42:23,954
per la prima volta, la capacità
per rendere le proprie funzioni.

2049
01:42:23,954 --> 01:42:25,870
Alcuni di voi potrebbero avere
fatto questo con Scratch,

2050
01:42:25,870 --> 01:42:28,430
per cui è possibile creare il
propri blocchi personalizzati in Scratch,

2051
01:42:28,430 --> 01:42:30,892
e poi trascinarli in luogo
ovunque si desidera in C.

2052
01:42:30,892 --> 01:42:33,100
E in più di programmazione
lingue, si può fare esattamente

2053
01:42:33,100 --> 01:42:36,580
che-- fare le proprie funzioni,
se non esistono già.

2054
01:42:36,580 --> 01:42:41,660
>> Così, per esempio, mi permetta di andare avanti
e comprendono CS50.h, e comprendono

2055
01:42:41,660 --> 01:42:46,110
standard di io.h, int void main.

2056
01:42:46,110 --> 01:42:49,020
E ora abbiamo un
segnaposto pronto ad andare.

2057
01:42:49,020 --> 01:42:51,550
Continuo a cose di stampa
come i nomi delle persone di oggi.

2058
01:42:51,550 --> 01:42:54,910
E che si sente like--
Non sarebbe bello se ci

2059
01:42:54,910 --> 01:42:56,936
erano una funzione chiamata nome di stampa?

2060
01:42:56,936 --> 01:42:58,060
Non devo usare printf.

2061
01:42:58,060 --> 01:42:59,976
Non devo ricordare
tutti i codici di formato.

2062
01:42:59,976 --> 01:43:03,050
Perché non, o perché
non l'ha fatto qualcuno prima di me,

2063
01:43:03,050 --> 01:43:05,980
creare una stampa funzione chiamata
nome, che dato qualche nome,

2064
01:43:05,980 --> 01:43:06,980
semplicemente lo stampa fuori?

2065
01:43:06,980 --> 01:43:11,700
>> In altre parole, se io dico, hey,
calcolatore, dammi una stringa

2066
01:43:11,700 --> 01:43:14,870
chiedendo all'utente per tali,
tramite la funzione di stringa get del CS50.

2067
01:43:14,870 --> 01:43:18,090
Hey, computer, messo quella stringa in
la variabile nel lato sinistro,

2068
01:43:18,090 --> 01:43:19,150
e chiamare s.

2069
01:43:19,150 --> 01:43:25,150
E poi, ehi computer, andare avanti
e stampa che il nome della persona, fatto.

2070
01:43:25,150 --> 01:43:29,240
>> Ora, sarebbe bello, perché
questo programma, giustamente intitolato,

2071
01:43:29,240 --> 01:43:32,170
mi dice che cosa dovrebbe fare
a titolo di nomi quelli della funzione.

2072
01:43:32,170 --> 01:43:35,930
Lasciami andare e fare prototipi, Enter.

2073
01:43:35,930 --> 01:43:37,930
E, purtroppo,
questo non sta andando a volare.

2074
01:43:37,930 --> 01:43:42,430
>> Prototype.c, linea 7, carattere
5, l'errore, dichiarazione implicita

2075
01:43:42,430 --> 01:43:45,960
della funzione nome di stampa
è invalido in C99, C99

2076
01:43:45,960 --> 01:43:48,130
cioè una versione di C
che è venuto fuori nel 1999.

2077
01:43:48,130 --> 01:43:48,730
È tutto.

2078
01:43:48,730 --> 01:43:51,780
>> Quindi io non so cosa
tutto questo significa ancora.

2079
01:43:51,780 --> 01:43:53,810
Ma lo faccio riconoscere l'errore in rosso.

2080
01:43:53,810 --> 01:43:54,770
Questo è abbastanza ovvio.

2081
01:43:54,770 --> 01:43:56,769
>> E sembra che con
il carattere verde qui,

2082
01:43:56,769 --> 01:44:00,520
il problema è con il nome di stampa, aperto
paren s, vicino paren, punto e virgola.

2083
01:44:00,520 --> 01:44:04,800
Ma dichiarazione implicita di
Funzione abbiamo visto brevemente in precedenza.

2084
01:44:04,800 --> 01:44:07,880
Questo significa, semplicemente, che Clang
non so se mi spiego.

2085
01:44:07,880 --> 01:44:12,000
>> Ho usato una parola del vocabolario che è
mai visto o stato insegnato prima.

2086
01:44:12,000 --> 01:44:14,950
E quindi ho bisogno di insegnare
che cosa significa questa funzione.

2087
01:44:14,950 --> 01:44:16,590
Quindi ho intenzione di andare avanti e farlo.

2088
01:44:16,590 --> 01:44:20,970
>> Ho intenzione di andare avanti e mettere in atto
la mia funzione chiamata Stampa Nome.

2089
01:44:20,970 --> 01:44:27,720
E ho intenzione di dire, come segue, che
lo fa, printf, ciao, cento

2090
01:44:27,720 --> 01:44:30,760
s, backslash n, nome, punto e virgola.

2091
01:44:30,760 --> 01:44:32,250
Così che cosa faccio e basta?

2092
01:44:32,250 --> 01:44:34,325
>> Così si scopre, a
implementare la propria funzione,

2093
01:44:34,325 --> 01:44:36,845
abbiamo tipo di prestito alcuni dei
la stessa struttura principale

2094
01:44:36,845 --> 01:44:38,720
che abbiamo appena stati
dato per scontato, e io

2095
01:44:38,720 --> 01:44:40,730
conoscere semplicemente copiando e
incollando più o meno quello

2096
01:44:40,730 --> 01:44:42,170
Ho scritto in passato.

2097
01:44:42,170 --> 01:44:43,570
Ma notare il modello qui.

2098
01:44:43,570 --> 01:44:46,750
Int, principale, Vuoto, dovremo prendere in giro a parte
fra non molto che cosa significa in realtà.

2099
01:44:46,750 --> 01:44:49,160
>> Ma per oggi, proprio
notare il parallelismo.

2100
01:44:49,160 --> 01:44:51,210
Void, nome di stampa,
string name, quindi non c'è

2101
01:44:51,210 --> 01:44:53,310
una parola chiave viola, che
stiamo per iniziare

2102
01:44:53,310 --> 01:44:57,067
chiamando un tipo di ritorno, il nome
la funzione, e quindi l'ingresso.

2103
01:44:57,067 --> 01:44:59,400
Quindi, in realtà, siamo in grado di distillare
questo tipo di come la settimana scorsa

2104
01:44:59,400 --> 01:45:02,030
come, questo è il nome o
Algoritmo del codice siamo

2105
01:45:02,030 --> 01:45:03,761
andando a write-- la
algoritmo sottostante

2106
01:45:03,761 --> 01:45:05,010
il codice che andremo a scrivere.

2107
01:45:05,010 --> 01:45:06,180
>> Questo è il suo ingresso.

2108
01:45:06,180 --> 01:45:07,670
Questa è la sua uscita.

2109
01:45:07,670 --> 01:45:11,730
Questa funzione, nome di stampa, è
progettato per prendere una stringa chiamata nome,

2110
01:45:11,730 --> 01:45:14,350
o qualunque, come input, e quindi nulla.

2111
01:45:14,350 --> 01:45:16,904
Esso non restituisce nulla,
come ottenere stringa o ottenere int fa.

2112
01:45:16,904 --> 01:45:18,570
Così sta andando a consegnare me qualcosa di nuovo.

2113
01:45:18,570 --> 01:45:20,960
E 'solo andando ad avere un
effetto collaterale, per così dire,

2114
01:45:20,960 --> 01:45:22,570
di stampare il nome di una persona.

2115
01:45:22,570 --> 01:45:25,260
Così Noto, linea 7, I
può chiamare il nome di stampa.

2116
01:45:25,260 --> 01:45:28,920
Linea 10, posso definire
o implementare nome di stampa.

2117
01:45:28,920 --> 01:45:31,450
Ma, purtroppo, questo non è sufficiente.

2118
01:45:31,450 --> 01:45:34,230
>> Lasciami andare avanti e
ricompilare questo dopo il salvataggio.

2119
01:45:34,230 --> 01:45:36,910
Wow, ora, ce l'ho fatta
peggio, sembrerebbe.

2120
01:45:36,910 --> 01:45:40,027
Dichiarazione Così implicita della
Nome funzione di stampa non è valido.

2121
01:45:40,027 --> 01:45:41,360
E, ancora una volta, non c'è più errori.

2122
01:45:41,360 --> 01:45:44,430
Ma, come ho ammonito in precedenza, anche
se si ottiene sopraffatto con,

2123
01:45:44,430 --> 01:45:47,850
o un po 'triste vedere così tanti
errori, si concentrano solo sulla prima

2124
01:45:47,850 --> 01:45:50,500
inizialmente, perché potrebbe solo
hanno avuto un effetto a cascata.

2125
01:45:50,500 --> 01:45:54,970
Quindi C, o Clang più specificamente,
ancora non riconosce il nome di stampa.

2126
01:45:54,970 --> 01:45:57,580
>> E questo perché Clang,
dal disegno, è una specie di muto.

2127
01:45:57,580 --> 01:45:59,280
Lo fa solo quello che gli si dice di fare.

2128
01:45:59,280 --> 01:46:03,950
E lo fa solo in ordine
in cui gli si dice di fare.

2129
01:46:03,950 --> 01:46:08,270
>> Così ho definito principale sulla linea di quattro,
come abbiamo fatto abbastanza spesso.

2130
01:46:08,270 --> 01:46:10,980
Ho definito nome di stampa on line 10.

2131
01:46:10,980 --> 01:46:14,793
Ma sto cercando di usare
nome di stampa on line sette.

2132
01:46:14,793 --> 01:46:16,670
>> E 'troppo presto, non esiste ancora.

2133
01:46:16,670 --> 01:46:22,150
Così ho potuto essere intelligente, e come,
Ok, facciamo solo giocare insieme,

2134
01:46:22,150 --> 01:46:26,680
e spostare il nome di stampa fino
qui, e ricompilare.

2135
01:46:26,680 --> 01:46:27,550
Dio mio.

2136
01:46:27,550 --> 01:46:28,260
Ha funzionato.

2137
01:46:28,260 --> 01:46:29,670
E 'stato così semplice.

2138
01:46:29,670 --> 01:46:31,120
>> Ma la logica è esattamente questo.

2139
01:46:31,120 --> 01:46:33,870
Dovete insegnare Clang cosa
è definendo la funzione prima.

2140
01:46:33,870 --> 01:46:34,920
Quindi è possibile utilizzarlo.

2141
01:46:34,920 --> 01:46:36,940
Ma, francamente, questo si sente
come un pendio scivoloso.

2142
01:46:36,940 --> 01:46:38,773
>> Così ogni volta che corro
in un problema, io sono solo

2143
01:46:38,773 --> 01:46:42,450
andando ad evidenziare e copiare il codice
Ho scritto, tagliarlo e incollarlo qui.

2144
01:46:42,450 --> 01:46:44,370
E, sicuramente, potremmo
escogitare alcuni scenari

2145
01:46:44,370 --> 01:46:46,286
dove una funzione potrebbe
bisogno di chiamare un altro.

2146
01:46:46,286 --> 01:46:49,030
E non si può mettere ogni
funzione di sopra di ogni altra.

2147
01:46:49,030 --> 01:46:50,930
>> Così si scopre c'è
una soluzione migliore.

2148
01:46:50,930 --> 01:46:53,100
Possiamo lasciare che questo sia.

2149
01:46:53,100 --> 01:46:56,677
E, francamente, è generalmente bello,
e comodo, e buon design

2150
01:46:56,677 --> 01:46:59,760
mettere principale prima, perché, di nuovo,
principale, proprio come quando la bandiera verde cliccato,

2151
01:46:59,760 --> 01:47:02,027
cioè la funzione che
viene eseguito per impostazione predefinita.

2152
01:47:02,027 --> 01:47:04,110
Così si potrebbe anche mettere
nella parte superiore del file

2153
01:47:04,110 --> 01:47:06,560
in modo che quando si o qualsiasi
altro essere umano guarda il file

2154
01:47:06,560 --> 01:47:09,360
si sa che cosa sta succedendo
solo leggendo prima principale.

2155
01:47:09,360 --> 01:47:18,360
Così si scopre, possiamo dire Clang
in modo proattivo, ehi, Clang, sulla linea quattro,

2156
01:47:18,360 --> 01:47:20,940
Prometto di implementare
una funzione chiamata Stampa

2157
01:47:20,940 --> 01:47:25,600
Nome che prende il nome di stringa denominata
come input, e restituisce nulla, nulla.

2158
01:47:25,600 --> 01:47:27,770
E io andare in giro a
implementazione in un secondo momento.

2159
01:47:27,770 --> 01:47:28,680
>> Ecco che arriva principale.

2160
01:47:28,680 --> 01:47:32,130
Principali ora in linea 9 può usare
Nome in stampatello perché Clang

2161
01:47:32,130 --> 01:47:35,600
è fiducioso che, alla fine,
si incontrerà la definizione

2162
01:47:35,600 --> 01:47:37,880
dell'attuazione della stampa Nome.

2163
01:47:37,880 --> 01:47:40,390
Così, dopo aver salvato il mio file, lasciate
andare avanti e fare il prototipo,

2164
01:47:40,390 --> 01:47:41,498
guarda bene questa volta.

2165
01:47:41,498 --> 01:47:46,470
Dot taglio su, prototipo, mi permetta
andare avanti e digitare un nome.

2166
01:47:46,470 --> 01:47:51,440
David, ciao David, Zamila, ciao
Zamila, e, anzi, ora funziona.

2167
01:47:51,440 --> 01:47:55,200
>> Quindi, l'ingrediente è che abbiamo
fatto una funzione personalizzata, come un costume

2168
01:47:55,200 --> 01:47:57,219
blocco Scratch stiamo chiamando.

2169
01:47:57,219 --> 01:48:00,010
Ma a differenza di Scratch dove è possibile
basta crearlo e iniziare ad usarlo,

2170
01:48:00,010 --> 01:48:02,330
ora dobbiamo essere un
poco più pedante,

2171
01:48:02,330 --> 01:48:06,410
ed effettivamente formare Clang
da utilizzare o aspettarselo.

2172
01:48:06,410 --> 01:48:12,140
Ora, come un a parte, perché tutto questo tempo hanno
siamo stati solo ciecamente sulla fede compreso

2173
01:48:12,140 --> 01:48:15,170
CS50.h, e compresi di serie io.h?

2174
01:48:15,170 --> 01:48:18,190
>> Beh, si scopre,
Tra un paio di altre cose,

2175
01:48:18,190 --> 01:48:21,550
tutto ciò che è in quelle dot h
file, che si trovano ad essere i file.

2176
01:48:21,550 --> 01:48:23,460
Stanno File di intestazione, per così dire.

2177
01:48:23,460 --> 01:48:26,270
Stanno ancora scritte in C. Ma
sono un altro tipo di file.

2178
01:48:26,270 --> 01:48:31,690
>> Per ora, si può tranquillamente supporre
che tutto ciò che si trova all'interno di CS50.h

2179
01:48:31,690 --> 01:48:36,360
è alcune battute come questo, non
per le funzioni di chiamata Print Nome,

2180
01:48:36,360 --> 01:48:39,840
ma per Get String, Get
Float, e pochi altri.

2181
01:48:39,840 --> 01:48:44,510
E ci sono prototipi simili,
uno fodere, all'interno di standard di io.h

2182
01:48:44,510 --> 01:48:49,241
per printf, che ora è in
la mia funzione di stampa Nome.

2183
01:48:49,241 --> 01:48:52,490
Quindi, in altre parole, tutto questo tempo abbiamo
appena stato ciecamente copiare e incollare

2184
01:48:52,490 --> 01:48:54,780
includere questo, includere
che, cosa sta succedendo?

2185
01:48:54,780 --> 01:48:58,310
Queste sono solo tipo di indizi
per clang da quali funzioni

2186
01:48:58,310 --> 01:49:03,170
sono, infatti, implementato, solo
altrove in file diversi

2187
01:49:03,170 --> 01:49:05,440
altrove nel sistema.

2188
01:49:05,440 --> 01:49:08,160
>> Così abbiamo implementato nome di stampa.

2189
01:49:08,160 --> 01:49:10,910
Lo fa avere questo effetto collaterale di
stampa qualcosa sullo schermo.

2190
01:49:10,910 --> 01:49:13,170
Ma in realtà non
passami qualcosa di nuovo.

2191
01:49:13,170 --> 01:49:15,200
Come facciamo a
l'attuazione di un programma che

2192
01:49:15,200 --> 01:49:17,510
Mi fa consegnare qualcosa di nuovo?

2193
01:49:17,510 --> 01:49:18,580
>> Bene, proviamo questo.

2194
01:49:18,580 --> 01:49:24,360
Lasciami andare avanti e realizzare
un file chiamato return.c

2195
01:49:24,360 --> 01:49:27,530
in modo che possiamo dimostrare come qualcosa
come Get String, o Get Int,

2196
01:49:27,530 --> 01:49:30,340
è in realtà il ritorno
qualcosa di nuovo per l'utente.

2197
01:49:30,340 --> 01:49:32,840
Andiamo avanti e definire int void main.

2198
01:49:32,840 --> 01:49:36,230
>> E, ancora, in futuro, faremo
spiegare ciò che int e quel vuoto

2199
01:49:36,230 --> 01:49:37,090
è in realtà facendo.

2200
01:49:37,090 --> 01:49:38,840
Ma per oggi, ci
prendilo per buono.

2201
01:49:38,840 --> 01:49:42,970
Ho intenzione di andare avanti e printf,
per una buona esperienza utente, x è.

2202
01:49:42,970 --> 01:49:47,360
E poi ho intenzione di aspettare il
utente di darmi x con get int.

2203
01:49:47,360 --> 01:49:51,459
>> E poi ho intenzione di andare avanti
e stampare x al quadrato.

2204
01:49:51,459 --> 01:49:53,500
Così, quando hai solo un
tastiera, la gente comunemente

2205
01:49:53,500 --> 01:49:55,600
usare la piccola carota
simbolo sulla tastiera

2206
01:49:55,600 --> 01:49:58,330
rappresentare al potere
, o l'esponente.

2207
01:49:58,330 --> 01:50:01,960
Quindi x ^ è presente i.

2208
01:50:01,960 --> 01:50:03,660
>> E ora ho intenzione di farlo.

2209
01:50:03,660 --> 01:50:06,940
Ho potuto solo fare-- ciò che è x
al quadrato? x squared è x volte x.

2210
01:50:06,940 --> 01:50:09,690
>> E abbiamo fatto questo un po '
tempo fa già oggi.

2211
01:50:09,690 --> 01:50:11,730
Questo non si sente come
tutto ciò che molti progressi.

2212
01:50:11,730 --> 01:50:12,570
Sai cosa?

2213
01:50:12,570 --> 01:50:16,100
Facciamo leva alcuni di quell'idea
dall'ultima volta di astrazione.

2214
01:50:16,100 --> 01:50:19,080
>> Non sarebbe bello se
c'è una funzione chiamata

2215
01:50:19,080 --> 01:50:21,460
piazza che fa esattamente questo?

2216
01:50:21,460 --> 01:50:23,640
Ancora, alla fine del
giorno, fa la stessa matematica.

2217
01:50:23,640 --> 01:50:25,410
Ma andiamo astratto
via l'idea di prendere

2218
01:50:25,410 --> 01:50:28,280
un numero moltiplicato per
un'altra, e solo dargli un nome,

2219
01:50:28,280 --> 01:50:30,360
come Piazza di questo valore.

2220
01:50:30,360 --> 01:50:32,560
>> E, in altre parole,
C, creiamo una funzione

2221
01:50:32,560 --> 01:50:35,660
chiamato piazza che fa esattamente questo.

2222
01:50:35,660 --> 01:50:37,600
E 'intenzione di essere chiamati quadrato.

2223
01:50:37,600 --> 01:50:38,790
Sta andando a prendere un int.

2224
01:50:38,790 --> 01:50:40,820
E faremo sarà solo
chiamarla n, per impostazione predefinita.

2225
01:50:40,820 --> 01:50:42,403
>> Ma potremmo chiamare tutto ciò che vogliamo.

2226
01:50:42,403 --> 01:50:45,900
E tutto ciò che sta andando a
fare, letteralmente, è il ritorno

2227
01:50:45,900 --> 01:50:48,810
il risultato di n volte n.

2228
01:50:48,810 --> 01:50:51,980
Ma perché è
tornando qualcosa, che

2229
01:50:51,980 --> 01:50:56,690
è la parola chiave in viola Abbiamo
mai visto prima, che, sulla linea 11,

2230
01:50:56,690 --> 01:50:58,410
non si può solo dire nulla questa volta.

2231
01:50:58,410 --> 01:51:04,320
>> Void, nell'esempio che abbiamo appena visto
piuttosto di nome di stampa, significa semplicemente,

2232
01:51:04,320 --> 01:51:05,190
Fai qualcosa.

2233
01:51:05,190 --> 01:51:07,170
Ma non mi consegnare qualcosa in cambio.

2234
01:51:07,170 --> 01:51:09,790
In questo caso, voglio
per tornare n volte n,

2235
01:51:09,790 --> 01:51:11,460
o qualunque cosa sia, quel numero.

2236
01:51:11,460 --> 01:51:15,460
>> Quindi non posso dire, ehi, computer,
Torno nulla, nulla.

2237
01:51:15,460 --> 01:51:19,166
E 'intenzione di tornare, per sua natura, un int.

2238
01:51:19,166 --> 01:51:20,790
E così questo è tutto quello che sta succedendo qui.

2239
01:51:20,790 --> 01:51:23,070
>> L'ingresso al quadrato
sta per essere un int.

2240
01:51:23,070 --> 01:51:27,760
E in modo che possiamo usare, deve
avere un nome, N. E 'intenzione di uscita

2241
01:51:27,760 --> 01:51:29,240
un int che non ha bisogno di un nome.

2242
01:51:29,240 --> 01:51:32,590
Siamo in grado di lasciare a principale, o chiunque sia
con me per ricordare questo valore se noi

2243
01:51:32,590 --> 01:51:34,120
vuole con la propria variabile.

2244
01:51:34,120 --> 01:51:36,230
>> E, ancora, l'unica nuova
parola chiave qui è di ritorno.

2245
01:51:36,230 --> 01:51:37,480
E sto solo facendo un po 'di matematica.

2246
01:51:37,480 --> 01:51:44,825
Se volevo davvero essere inutile,
Potrei dire int prodotto ottiene n volte n.

2247
01:51:44,825 --> 01:51:47,170
>> E poi potrei dire, prodotto di ritorno.

2248
01:51:47,170 --> 01:51:50,360
Ma, ancora una volta, al mio punto precedente di
Questo semplicemente non essere buono design--

2249
01:51:50,360 --> 01:51:53,060
Come, perché introdurre un nome,
un simbolo, come il prodotto,

2250
01:51:53,060 --> 01:51:54,570
solo per tornare immediatamente?

2251
01:51:54,570 --> 01:51:56,670
E 'un po' più pulito,
un po 'più stretto, così

2252
01:51:56,670 --> 01:52:02,380
a parlare, solo per dire i tempi di ritorno n
n, sbarazzarsi di questa linea del tutto.

2253
01:52:02,380 --> 01:52:05,860
>> Ed è solo meno codice per leggere,
meno opportunità per gli errori.

2254
01:52:05,860 --> 01:52:08,180
E vediamo se questo
in realtà ora funziona.

2255
01:52:08,180 --> 01:52:12,380
Ora, ho intenzione di andare
avanti e fare ritorno.

2256
01:52:12,380 --> 01:52:14,460
>> Uh-oh, implicita dichiarazione di funzione.

2257
01:52:14,460 --> 01:52:17,080
Ho fatto questo errore prima, un grosso problema.

2258
01:52:17,080 --> 01:52:21,950
Vorrei solo tipo, o evidenziare e
copiare, la stessa identica funzione di prototipo,

2259
01:52:21,950 --> 01:52:24,342
o la firma, della funzione di quassù.

2260
01:52:24,342 --> 01:52:25,800
Oppure avrei potuto spostare l'intera funzione.

2261
01:52:25,800 --> 01:52:26,841
>> Ma questo è un po 'pigro.

2262
01:52:26,841 --> 01:52:27,870
In modo da non farlo.

2263
01:52:27,870 --> 01:52:30,960
Ora, permettetemi di fare ritorno
ancora una volta, dot ritorno barra.

2264
01:52:30,960 --> 01:52:35,790
>> x è 2. x Squared è 4.
x è 3. x Squared è 9.

2265
01:52:35,790 --> 01:52:38,300
E la funzione sembra
ora di lavorare.

2266
01:52:38,300 --> 01:52:39,550
Allora, qual è la differenza qui?

2267
01:52:39,550 --> 01:52:45,520
Ho una funzione che si chiama piazza,
in questo caso, che ho messo in un ingresso.

2268
01:52:45,520 --> 01:52:46,830
E torno un'uscita.

2269
01:52:46,830 --> 01:52:49,210
Eppure, in precedenza, se
Apro l'altro esempio

2270
01:52:49,210 --> 01:52:54,640
da prima, che
è stato chiamato prototype.c,

2271
01:52:54,640 --> 01:52:57,770
Ho avuto il nome di stampa, che
restituito vuoto, per così dire,

2272
01:52:57,770 --> 01:53:01,730
O è tornato nulla, e
semplicemente ha avuto un effetto collaterale.

2273
01:53:01,730 --> 01:53:03,230
>> Allora, cosa sta succedendo qui?

2274
01:53:03,230 --> 01:53:06,520
Beh, si consideri la funzione
ottenere corda solo per un momento.

2275
01:53:06,520 --> 01:53:09,570
Abbiamo utilizzato la funzione
ottenere stringa nel modo seguente.

2276
01:53:09,570 --> 01:53:13,464
>> Abbiamo avuto una funzione get
stringa, come includono CS50.h,

2277
01:53:13,464 --> 01:53:19,624
includere standard di io.h, int, principale, vuoto.

2278
01:53:19,624 --> 01:53:21,790
E poi ogni volta che ho
chiamato stringa di ottenere finora,

2279
01:53:21,790 --> 01:53:26,260
Ho detto qualcosa di simile, stringa s
ottiene ottenere stringa, perché get string--

2280
01:53:26,260 --> 01:53:30,880
chiamiamolo questa stringa get get.c--
si restituisce una stringa che posso poi

2281
01:53:30,880 --> 01:53:35,050
usare, e dire ciao, virgola,
cento s, backslash n, s.

2282
01:53:35,050 --> 01:53:38,660
>> Quindi questo è lo stesso esempio,
in realtà, che abbiamo avuto in precedenza.

2283
01:53:38,660 --> 01:53:40,920
Quindi, ottenere stringa restituisce un valore.

2284
01:53:40,920 --> 01:53:44,260
Ma un momento fa, stringa di stampa
non restituisce un valore.

2285
01:53:44,260 --> 01:53:45,721
Essa ha semplicemente un effetto collaterale.

2286
01:53:45,721 --> 01:53:47,220
Quindi questa è una differenza fondamentale.

2287
01:53:47,220 --> 01:53:49,710
Abbiamo visto diversi
tipi di funzioni ora,

2288
01:53:49,710 --> 01:53:52,490
alcuni dei quali sono tornati
valori, alcuni dei quali non lo fanno.

2289
01:53:52,490 --> 01:53:54,890
Quindi forse è stringa o int o float.

2290
01:53:54,890 --> 01:53:56,480
O forse è solo vuoto.

2291
01:53:56,480 --> 01:53:58,710
>> E la differenza è
che tali funzioni che

2292
01:53:58,710 --> 01:54:02,940
ottenere i dati e restituire un valore sono in realtà
portare qualcosa di nuovo al tavolo,

2293
01:54:02,940 --> 01:54:04,110
per così dire.

2294
01:54:04,110 --> 01:54:06,710
Quindi andiamo avanti e
guardare un set finale

2295
01:54:06,710 --> 01:54:12,129
esempi che dà un senso, ora,
Come possiamo, anzi, astratto meglio,

2296
01:54:12,129 --> 01:54:14,670
e meglio, e meglio, o più,
e più, e più, al fine

2297
01:54:14,670 --> 01:54:16,810
scrivere, in ultima analisi, codice migliore.

2298
01:54:16,810 --> 01:54:19,860
Andiamo avanti, e nello spirito
di Scratch, effettuare le seguenti operazioni.

2299
01:54:19,860 --> 01:54:24,700
>> Lasciami andare avanti e includo
CS50.h e standard di io.h.

2300
01:54:24,700 --> 01:54:27,010
Mi permetta di andare avanti e dare
io stesso un int, principale, vuoto.

2301
01:54:27,010 --> 01:54:30,380
E mi permetta di andare avanti, chiamo questo cough.c.

2302
01:54:30,380 --> 01:54:38,510
>> E mi permetta di andare avanti e basta
come Scratch, stampare tosse / n.

2303
01:54:38,510 --> 01:54:40,170
E io voglio fare questo per tre volte.

2304
01:54:40,170 --> 01:54:42,670
Quindi sono, ovviamente, solo andando
copiare e incollare tre volte.

2305
01:54:42,670 --> 01:54:49,440
Ora sto andando a fare
tosse dot tosse barra.

2306
01:54:49,440 --> 01:54:53,120
Diamo me stesso un po 'più spazio
qui, Enter, tosse, tosse, tosse.

2307
01:54:53,120 --> 01:54:56,970
>> C'è, ovviamente, già
possibilità di miglioramento.

2308
01:54:56,970 --> 01:54:58,679
Ho copiato e incollato
un paio di volte oggi.

2309
01:54:58,679 --> 01:55:01,261
Ma questo era solo così non l'ho fatto
necessario digitare il maggior numero di caratteri.

2310
01:55:01,261 --> 01:55:03,250
Ho ancora cambiato ciò che
quelle righe di codice sono.

2311
01:55:03,250 --> 01:55:07,240
>> Queste tre linee sono identiche,
che si sente pigro e in effetti è,

2312
01:55:07,240 --> 01:55:10,110
e probabilmente non è l'approccio giusto.

2313
01:55:10,110 --> 01:55:14,029
Quindi, con quello che l'ingrediente
potremmo migliorare questo codice?

2314
01:55:14,029 --> 01:55:15,570
Non abbiamo per copiare e incollare il codice.

2315
01:55:15,570 --> 01:55:18,070
>> E, in effetti, ogni volta che si sente
te copia e incolla,

2316
01:55:18,070 --> 01:55:20,700
e nemmeno modificare il codice,
probabilità sono c'è un modo migliore.

2317
01:55:20,700 --> 01:55:22,470
E, in effetti, c'è.

2318
01:55:22,470 --> 01:55:25,510
Mi permetta di andare avanti e fare un ciclo for,
anche se la sintassi non potrebbe

2319
01:55:25,510 --> 01:55:27,570
ancora venuto naturalmente.

2320
01:55:27,570 --> 01:55:32,494
>> Fate questo per tre volte, semplicemente
facendo il following--

2321
01:55:32,494 --> 01:55:34,160
e mi capita di conoscere questo dalla pratica.

2322
01:55:34,160 --> 01:55:35,810
Ma abbiamo un certo numero di esempi ora.

2323
01:55:35,810 --> 01:55:37,950
E vedrete on-line
più riferimenti ancora.

2324
01:55:37,950 --> 01:55:40,790
>> Questa è la sintassi sulla linea 6, che
molto simile a Scratch che si ripete

2325
01:55:40,790 --> 01:55:43,090
blocco, ripetere le seguenti tre volte.

2326
01:55:43,090 --> 01:55:44,340
E 'un po' magica, per ora.

2327
01:55:44,340 --> 01:55:46,050
Ma questo otterrà di più,
e più familiare.

2328
01:55:46,050 --> 01:55:48,050
>> E sta andando a ripetere
linea di otto per tre volte,

2329
01:55:48,050 --> 01:55:55,390
in modo che se ho ri-compilare make tosse,
dot taglio su tosse, tosse, tosse, tosse.

2330
01:55:55,390 --> 01:55:57,030
Ancora funziona allo stesso modo.

2331
01:55:57,030 --> 01:55:58,550
Ecco, questo è tutto bello e buono.

2332
01:55:58,550 --> 01:56:01,200
Ma non è molto astratto.

2333
01:56:01,200 --> 01:56:02,371
>> E 'perfettamente corretto.

2334
01:56:02,371 --> 01:56:04,370
Ma ci si sente come se ci
potrebbe essere l'occasione,

2335
01:56:04,370 --> 01:56:06,750
come nel mondo
Scratch, al tipo di avvio

2336
01:56:06,750 --> 01:56:10,530
aggiungere alcune semantiche qui in modo che
Non mi resta che un po 'per il ciclo,

2337
01:56:10,530 --> 01:56:12,867
e una funzione che dice
tosse, o che tossire.

2338
01:56:12,867 --> 01:56:13,450
Sai cosa?

2339
01:56:13,450 --> 01:56:15,620
Vorrei cercare di essere un
po 'più fresco di quello,

2340
01:56:15,620 --> 01:56:19,090
ed effettivamente scrivere una funzione che
ha alcuni effetti collaterali, lo chiamano tosse.

2341
01:56:19,090 --> 01:56:23,830
>> E ci vuole nessun ingresso e
restituisce alcun valore come output.

2342
01:56:23,830 --> 01:56:25,680
Ma sai cosa fa?

2343
01:56:25,680 --> 01:56:32,370
Lo fa questo-- printf,
tra virgolette, tosse.

2344
01:56:32,370 --> 01:56:35,380
>> E ora qui, sto andando
di andare avanti e per int,

2345
01:56:35,380 --> 01:56:39,070
mi viene a zero, i meno di 3, i plus plus.

2346
01:56:39,070 --> 01:56:42,770
Ho intenzione di non fare printf, che è
senza dubbio una implementazione a basso livello

2347
01:56:42,770 --> 01:56:43,270
dettaglio.

2348
01:56:43,270 --> 01:56:44,353
Non mi importa come tossire.

2349
01:56:44,353 --> 01:56:46,240
Voglio solo usare la funzione di tosse.

2350
01:56:46,240 --> 01:56:47,840
E sto solo andando a chiamare la tosse.

2351
01:56:47,840 --> 01:56:49,204
>> Ora, si noti la dicotomia.

2352
01:56:49,204 --> 01:56:52,370
Quando si chiama una funzione, se non lo fai
voler dare ingressi, tutto bene.

2353
01:56:52,370 --> 01:56:54,780
Basta fare paren aperte, chiudere
paren, e il gioco è fatto.

2354
01:56:54,780 --> 01:56:59,271
>> Quando si definisce una funzione, o
dichiarare il prototipo di una funzione,

2355
01:56:59,271 --> 01:57:01,770
se si sa in anticipo che non è
andando a prendere qualsiasi argomento,

2356
01:57:01,770 --> 01:57:04,170
dire nulla in quelle parentesi lì.

2357
01:57:04,170 --> 01:57:08,660
E questo fa certo che si
non abusare accidentalmente.

2358
01:57:08,660 --> 01:57:10,020
Mi permetta di andare avanti e fare la tosse.

2359
01:57:10,020 --> 01:57:11,540
E, naturalmente, ho fatto un errore.

2360
01:57:11,540 --> 01:57:13,410
>> Dannazione, c'è quella
dichiarazione implicita.

2361
01:57:13,410 --> 01:57:14,325
Ma va bene.

2362
01:57:14,325 --> 01:57:15,590
Si tratta di una soluzione semplice.

2363
01:57:15,590 --> 01:57:21,240
Ho solo bisogno il prototipo più in alto
nel mio file di realtà sto usando.

2364
01:57:21,240 --> 01:57:23,070
>> Così ora lasciatemi fare tosse di nuovo, piacevole.

2365
01:57:23,070 --> 01:57:23,790
Ora funziona.

2366
01:57:23,790 --> 01:57:25,930
Fai la tosse, tosse, tosse, tosse.

2367
01:57:25,930 --> 01:57:28,930
Quindi, si potrebbe pensare che siamo veramente
poco più di ingegneria questo problema.

2368
01:57:28,930 --> 01:57:29,763
E, in effetti, ci sono.

2369
01:57:29,763 --> 01:57:31,870
Questo non è un buon
candidato di un programma

2370
01:57:31,870 --> 01:57:34,930
al momento per
refactoring, e fare ciò che è

2371
01:57:34,930 --> 01:57:38,645
chiamato scomposizione gerarchica,
dove si prende un po 'di codice, e quindi

2372
01:57:38,645 --> 01:57:41,790
Si tipo di fattore di cose fuori, così come
attribuire più semantica per loro,

2373
01:57:41,790 --> 01:57:43,930
e riutilizzarlo in ultima analisi, a più lungo termine.

2374
01:57:43,930 --> 01:57:46,490
Ma si tratta di un blocco di costruzione verso
programmi più sofisticati

2375
01:57:46,490 --> 01:57:48,600
che inizieremo
scrivere in breve tempo che

2376
01:57:48,600 --> 01:57:53,090
ci permette di avere il vocabolario
con cui scrivere codice migliore.

2377
01:57:53,090 --> 01:57:55,920
E, in effetti, vediamo se ci
Non si può generalizzare questo ulteriore.

2378
01:57:55,920 --> 01:58:00,984
>> Sembra un po 'zoppo che io, principale,
bisogno di preoccuparsi di questo dannato ciclo for,

2379
01:58:00,984 --> 01:58:02,400
e chiamando ancora e ancora la tosse.

2380
01:58:02,400 --> 01:58:06,050
Perché non posso solo dire tosse,
Si prega di tosse tre volte?

2381
01:58:06,050 --> 01:58:11,170
In altre parole, perché non posso semplicemente
dare un contributo a tossire e fare questo?

2382
01:58:11,170 --> 01:58:14,270
>> Perché non posso solo dire, in
tosse principale tre volte.

2383
01:58:14,270 --> 01:58:16,150
E ora, questo è una specie di magico.

2384
01:58:16,150 --> 01:58:17,540
E 'molto iterativo qui.

2385
01:58:17,540 --> 01:58:18,940
Ed è, infatti, un bambino passo.

2386
01:58:18,940 --> 01:58:22,250
>> Ma solo la capacità di dire su
linea di otto, tosse tre volte,

2387
01:58:22,250 --> 01:58:23,730
è solo così molto più leggibile.

2388
01:58:23,730 --> 01:58:27,210
E, in più, non devo sapere
o interessa come la tosse è implementato.

2389
01:58:27,210 --> 01:58:29,460
E, in effetti, più avanti nel
termine e per i progetti finali,

2390
01:58:29,460 --> 01:58:32,150
se affrontare un progetto con
un compagno di classe o due compagni di classe,

2391
01:58:32,150 --> 01:58:35,370
vi renderete conto che si sta andando a
devono, o vogliono, dividere il lavoro.

2392
01:58:35,370 --> 01:58:37,650
>> E si sta andando a voler decidere
in anticipo, che sta per fare che cosa,

2393
01:58:37,650 --> 01:58:38,483
e in cui i pezzi?

2394
01:58:38,483 --> 01:58:40,520
E non sarebbe bello
se, per esempio,

2395
01:58:40,520 --> 01:58:43,100
farsi carico di scrittura principale, fatto.

2396
01:58:43,100 --> 01:58:46,470
E il tuo compagno di stanza, o il vostro
Partner più in generale,

2397
01:58:46,470 --> 01:58:48,230
si occupa di attuare la tosse.

2398
01:58:48,230 --> 01:58:52,540
>> E questa divisione, questi
pareti di astrazione,

2399
01:58:52,540 --> 01:58:55,310
o strati di astrazione, se
si, sono super potente,

2400
01:58:55,310 --> 01:58:58,480
perché soprattutto per i più grandi,
più programmi complessi e sistemi,

2401
01:58:58,480 --> 01:59:03,070
permette a più persone di costruire
le cose insieme, e in ultima analisi,

2402
01:59:03,070 --> 01:59:05,680
cucire il loro lavoro insieme in questo modo.

2403
01:59:05,680 --> 01:59:08,332
Ma, naturalmente,
bisogno di risolvere ora la tosse.

2404
01:59:08,332 --> 01:59:10,290
Dobbiamo dire tosse
che, ehi, sai una cosa?

2405
01:59:10,290 --> 01:59:14,230
Si sta andando ad avere bisogno di prendere un
input-- quindi non vuoto, ma int e ora.

2406
01:59:14,230 --> 01:59:18,170
Andiamo avanti e mettere in
tosse il int. mi viene a zero.

2407
01:59:18,170 --> 01:59:19,890
>> i è inferiore a quante volte.

2408
01:59:19,890 --> 01:59:21,550
Ho detto tre prima.

2409
01:59:21,550 --> 01:59:23,420
Ma non è quello che voglio.

2410
01:59:23,420 --> 01:59:28,520
Io voglio tosse essere generalizzato a
supportare qualsiasi numero di iterazioni.

2411
01:59:28,520 --> 01:59:31,800
>> Così, in effetti, si tratta di n che voglio,
qualunque sia l'utente mi dice.

2412
01:59:31,800 --> 01:59:34,620
Ora, posso andare avanti e dire la tosse stampa.

2413
01:59:34,620 --> 01:59:37,750
E non importa quale numero
l'utente passa,

2414
01:59:37,750 --> 01:59:39,890
Io iterare che molte volte.

2415
01:59:39,890 --> 01:59:42,160
>> Così, alla fine della giornata,
programma è identico.

2416
01:59:42,160 --> 01:59:45,820
Ma notare tutte queste cose
potrebbe anche essere in un altro file.

2417
01:59:45,820 --> 01:59:48,620
Anzi, non so al
momento come printf è implementato.

2418
01:59:48,620 --> 01:59:50,980
>> Non so al momento come arrivare
stringa, o ottenere int, float o ottenere

2419
01:59:50,980 --> 01:59:51,646
sono implementati.

2420
01:59:51,646 --> 01:59:53,930
E io non voglio
vederli sul mio schermo.

2421
01:59:53,930 --> 01:59:58,320
Così com'è, sto iniziando a concentrarsi su
il mio programma, non quelle funzioni.

2422
01:59:58,320 --> 02:00:02,070
>> E così, in effetti, non appena
avviare factoring codice come questo fuori,

2423
02:00:02,070 --> 02:00:04,397
potremmo anche spostare la tosse
in un file separato?

2424
02:00:04,397 --> 02:00:05,730
Qualcun altro potrebbe attuarlo.

2425
02:00:05,730 --> 02:00:09,810
E voi e il vostro programma di diventare il
molto bello, e molto leggibile,

2426
02:00:09,810 --> 02:00:13,830
senza dubbio, in realtà quattro
programma a riga proprio lì.

2427
02:00:13,830 --> 02:00:16,510
>> Quindi cerchiamo di andare avanti ora
e fare un ulteriore cambiamento.

2428
02:00:16,510 --> 02:00:19,180
Si noti che il mio prototipo
deve cambiare sulla parte superiore.

2429
02:00:19,180 --> 02:00:21,390
Così mi permetta di risolvere che così
Io non vengo sgridato.

2430
02:00:21,390 --> 02:00:25,580
>> Fai la tosse, mi permetta di correre tosse volta
di più, ancora facendo la stessa cosa.

2431
02:00:25,580 --> 02:00:29,010
Ma ora, notare abbiamo un
ingrediente per una versione finale.

2432
02:00:29,010 --> 02:00:29,940
Sai cosa?

2433
02:00:29,940 --> 02:00:32,040
Non voglio tossire solo, necessariamente.

2434
02:00:32,040 --> 02:00:33,802
Voglio avere qualcosa di più generale.

2435
02:00:33,802 --> 02:00:34,510
Allora sai cosa?

2436
02:00:34,510 --> 02:00:35,450
Voglio farlo.

2437
02:00:35,450 --> 02:00:40,140
Voglio avere, molto simile a Scratch
fa, un blocco per esempio, ma non solo

2438
02:00:40,140 --> 02:00:41,680
dire qualcosa di un po 'di numero di volte.

2439
02:00:41,680 --> 02:00:44,510
Lo voglio dire una stringa molto specifico.

2440
02:00:44,510 --> 02:00:46,850
E, di conseguenza, non lo faccio
Lo voglio dire solo colpo di tosse.

2441
02:00:46,850 --> 02:00:50,660
Lo voglio dire qualunque cosa
stringa viene passato.

2442
02:00:50,660 --> 02:00:52,960
>> Così notare, ho generalizzato
questo modo che ora

2443
02:00:52,960 --> 02:00:56,110
per esempio si sente come un buon nome
per questo, come Scratch,

2444
02:00:56,110 --> 02:00:58,530
prende due argomenti, a differenza di Scratch.

2445
02:00:58,530 --> 02:00:59,570
Uno è una stringa.

2446
02:00:59,570 --> 02:01:00,300
Uno è un int.

2447
02:01:00,300 --> 02:01:01,130
>> E ho potuto passare.

2448
02:01:01,130 --> 02:01:03,713
Ho solo un po 'come l'idea di
dire la stringa prima, e poi

2449
02:01:03,713 --> 02:01:04,940
quante volte successive.

2450
02:01:04,940 --> 02:01:06,970
Void significa che ancora
non restituisce nulla.

2451
02:01:06,970 --> 02:01:09,428
Questi sono solo lato visivo
effetti, come con [? Jordan,?]

2452
02:01:09,428 --> 02:01:11,240
un effetto collaterale verbale di urlare.

2453
02:01:11,240 --> 02:01:15,630
Lo fa ancora qualcosa di volte n,
0 fino a, ma non uguale a n.

2454
02:01:15,630 --> 02:01:17,540
Questo significa che i tempi n totali.

2455
02:01:17,540 --> 02:01:19,540
E poi basta stampare
qualunque essa stringa è.

2456
02:01:19,540 --> 02:01:22,060
Così ho davvero generalizzato
questa riga di codice.

2457
02:01:22,060 --> 02:01:25,460
Così ora, come faccio a implementare
la funzione di tosse?

2458
02:01:25,460 --> 02:01:28,520
>> Posso fare tosse vuoto.

2459
02:01:28,520 --> 02:01:31,501
E posso ancora prendere nel modo in cui
molte volte si desidera a tossire.

2460
02:01:31,501 --> 02:01:32,250
Ma sai una cosa?

2461
02:01:32,250 --> 02:01:34,240
Ora posso punt da dire.

2462
02:01:34,240 --> 02:01:39,540
>> Posso chiamare dire con la
parola tosse, passando n.

2463
02:01:39,540 --> 02:01:43,410
E se voglio implementare anche,
solo per divertimento, una funzione di starnuto,

2464
02:01:43,410 --> 02:01:45,290
Posso starnuto un determinato numero di volte.

2465
02:01:45,290 --> 02:01:50,300
E posso tenere il riutilizzo n, perché
notare che m, in questo contesto e la portata

2466
02:01:50,300 --> 02:01:52,470
esiste solo all'interno di questa funzione.

2467
02:01:52,470 --> 02:01:55,767
>> E n in questo contesto solo
esiste all'interno di questa funzione qui.

2468
02:01:55,767 --> 02:01:57,600
Quindi torneremo a
questi problemi di portata.

2469
02:01:57,600 --> 02:02:04,160
E qui, sto solo andando a dire,
Achoo, e poi n volte, punto e virgola.

2470
02:02:04,160 --> 02:02:07,340
>> E ora, ho solo bisogno di prendere in prestito
queste funzioni firme qui.

2471
02:02:07,340 --> 02:02:09,290
Così tosse è corretta.

2472
02:02:09,290 --> 02:02:13,090
starnuto Void è corretto ora.

2473
02:02:13,090 --> 02:02:15,390
>> E ho ancora solo bisogno di dire.

2474
02:02:15,390 --> 02:02:21,990
Quindi ho intenzione di dire, per esempio
stringa s, int n, punto e virgola.

2475
02:02:21,990 --> 02:02:25,010
Così ho Engineered over-the
heck fuori di questo programma.

2476
02:02:25,010 --> 02:02:26,760
>> E questo non lo fa
necessariamente che questo è

2477
02:02:26,760 --> 02:02:29,343
cosa si deve fare quando si scrive
anche il più semplice dei programmi.

2478
02:02:29,343 --> 02:02:32,280
Prendere qualcosa che è, ovviamente,
molto semplice, molto breve,

2479
02:02:32,280 --> 02:02:34,800
e ri-attuarlo
utilizzando modo troppo codice.

2480
02:02:34,800 --> 02:02:37,560
Ma vi si può vedere, e in
ora guardare indietro a questi esempi,

2481
02:02:37,560 --> 02:02:41,610
e realizzare, oh, questi sono i passi
abbiamo preso a generalizzare in realtà,

2482
02:02:41,610 --> 02:02:43,797
di fattore qualcosa,
fino alla fine della giornata

2483
02:02:43,797 --> 02:02:45,380
il mio codice è in realtà piuttosto ragionevole.

2484
02:02:45,380 --> 02:02:48,960
Perché se voglio tosse tre
volte poi starnutiscono tre volte,

2485
02:02:48,960 --> 02:02:53,420
Sto semplicemente andando a rieseguire questo,
programma di rendere la tosse, ed eseguire la tosse.

2486
02:02:53,420 --> 02:02:56,620
E ho tre colpi di tosse
e tre starnuti.

2487
02:02:56,620 --> 02:02:58,990
>> E quindi questa è una base
paradigma, se si vuole,

2488
02:02:58,990 --> 02:03:03,110
per come potremmo fare per
in realtà attuazione di un programma.

2489
02:03:03,110 --> 02:03:06,220
Ma facciamo solo vedere ora che cosa si tratta
abbiamo fatto tutto questo tempo,

2490
02:03:06,220 --> 02:03:09,940
e ciò che alcuni dei pezzi finali
sono alla base di questo semplice comando.

2491
02:03:09,940 --> 02:03:12,620
Alla fine della giornata, abbiamo
stato usando Clang come il nostro compilatore.

2492
02:03:12,620 --> 02:03:14,494
Abbiamo scritto fonte
codice, convertendolo

2493
02:03:14,494 --> 02:03:15,820
via Clang in codice macchina.

2494
02:03:15,820 --> 02:03:18,540
>> E abbiamo usato Fai solo
per facilitare le nostre battute così

2495
02:03:18,540 --> 02:03:23,740
che non abbiamo da ricordare
quegli incantesimi di Clang stesso.

2496
02:03:23,740 --> 02:03:25,640
Ma ciò che è fare effettivamente fare?

2497
02:03:25,640 --> 02:03:27,750
E, a sua volta, ciò che è
Clang effettivamente facendo?

2498
02:03:27,750 --> 02:03:31,790
>> Si scopre, anche se abbiamo semplificato
la discussione di oggi dicendo,

2499
02:03:31,790 --> 02:03:36,090
si prende il codice sorgente, passarlo come
ingresso a un compilatore, che vi dà

2500
02:03:36,090 --> 02:03:38,750
uscita della macchina
codice, risulta non c'è

2501
02:03:38,750 --> 02:03:40,420
a pochi passi differenti dentro.

2502
02:03:40,420 --> 02:03:44,940
E la compilazione sembra essere l'ombrello
termine per tutta una serie di passaggi.

2503
02:03:44,940 --> 02:03:46,970
Ma facciamo solo prendere in giro
questo fuori molto velocemente.

2504
02:03:46,970 --> 02:03:51,070
>> Si scopre che abbiamo fatto
più cose ogni volta che eseguire un programma,

2505
02:03:51,070 --> 02:03:53,990
o ogni volta che compilare un programma di oggi.

2506
02:03:53,990 --> 02:03:58,020
Quindi pre-elaborazione si riferisce a
Questa poi qualsiasi cosa in un programma C,

2507
02:03:58,020 --> 02:04:01,720
come vedremo ancora e ancora,
che inizia con questo simbolo cancelletto,

2508
02:04:01,720 --> 02:04:06,320
o il simbolo hashtag qui, significa
si tratta di una direttiva del preprocessore.

2509
02:04:06,320 --> 02:04:10,330
Ciò significa che, in questo caso, hey
del computer, fare qualcosa con questo file

2510
02:04:10,330 --> 02:04:12,430
prima che realmente compila il mio codice.

2511
02:04:12,430 --> 02:04:18,220
>> In questo caso, hash includono IS,
in sostanza, il modo di C per dire,

2512
02:04:18,220 --> 02:04:22,325
Ehi del computer, andare a prendere i contenuti
di CS50.h e incollarli qui.

2513
02:04:22,325 --> 02:04:25,170
Ehi del computer, andare a prendere il
il contenuto della norma io.h,

2514
02:04:25,170 --> 02:04:27,690
dovunque sia sulla
disco rigido, incollarlo qui.

2515
02:04:27,690 --> 02:04:30,390
Quindi, queste cose succedono
prima durante la pre-elaborazione.

2516
02:04:30,390 --> 02:04:31,880
>> E Clang fa tutto questo per noi.

2517
02:04:31,880 --> 02:04:33,510
E lo fa così maledettamente
veloce, non è necessario nemmeno

2518
02:04:33,510 --> 02:04:35,000
vedere quattro cose distinte che accadono.

2519
02:04:35,000 --> 02:04:37,100
Ma questo è il primo passo del genere.

2520
02:04:37,100 --> 02:04:38,560
>> Cosa succede in realtà dopo?

2521
02:04:38,560 --> 02:04:41,320
Bene, la prossima ufficiale
passo è la compilazione.

2522
02:04:41,320 --> 02:04:43,385
E si scopre che
compilazione di un programma

2523
02:04:43,385 --> 02:04:47,060
tecnicamente significa andare da
il codice sorgente, la roba che abbiamo

2524
02:04:47,060 --> 02:04:50,890
state scrivendo oggi, a qualcosa
chiamato codice assembly, qualcosa

2525
02:04:50,890 --> 02:04:52,260
che sembra un po 'diverso.

2526
02:04:52,260 --> 02:04:54,050
>> E, infatti, possiamo vedere questa veloce reale.

2527
02:04:54,050 --> 02:04:56,890
Mi permetta effettivamente andare nel mio IDE.

2528
02:04:56,890 --> 02:05:01,050
Lasciami andare avanti e ciao.c aperta, che
è il primo programma con cui

2529
02:05:01,050 --> 02:05:02,120
ha cominciato oggi.

2530
02:05:02,120 --> 02:05:07,130
E mi permetta di andare avanti e correre Clang a
po 'diverso, Clang-s, hello.c,

2531
02:05:07,130 --> 02:05:10,720
che in realtà è di andare a
datemi un altro file hello.s.

2532
02:05:10,720 --> 02:05:13,330
>> E probabilmente ci sarà mai
ancora una volta vedere questo tipo di codice.

2533
02:05:13,330 --> 02:05:16,030
Se si prende un livello più basso
classe di sistemi come CS61,

2534
02:05:16,030 --> 02:05:17,920
si vedrà molto di più
di questo tipo di codice.

2535
02:05:17,920 --> 02:05:20,020
Ma questo è il linguaggio assembly.

2536
02:05:20,020 --> 02:05:25,050
Questo è X86 linguaggio assembly
che la CPU che è sotteso

2537
02:05:25,050 --> 02:05:27,460
CS50 IDE in realtà capisce.

2538
02:05:27,460 --> 02:05:30,060
>> E criptico come fa
guardare, si tratta di qualcosa

2539
02:05:30,060 --> 02:05:32,180
il computer capisce abbastanza bene.

2540
02:05:32,180 --> 02:05:33,790
Sub q, questa è una sottrazione.

2541
02:05:33,790 --> 02:05:34,660
Ci sono movimenti.

2542
02:05:34,660 --> 02:05:38,730
>> Ci sta chiamando delle funzioni qui,
x oring, un movimento, un componente aggiuntivo, un pop,

2543
02:05:38,730 --> 02:05:39,430
un ritorno.

2544
02:05:39,430 --> 02:05:41,850
Quindi c'è un po 'di molto
istruzioni di basso livello

2545
02:05:41,850 --> 02:05:44,280
che le CPU capire che
Ho accennato in precedenza.

2546
02:05:44,280 --> 02:05:46,100
Questo è ciò che Intel Inside.

2547
02:05:46,100 --> 02:05:48,030
>> Ci sono modelli di
zeri e quelli che

2548
02:05:48,030 --> 02:05:54,800
mappa a questi arcanamente formulata, ma
un po 'ben di nome-, istruzioni,

2549
02:05:54,800 --> 02:05:55,780
per così dire.

2550
02:05:55,780 --> 02:05:57,780
Questo è ciò che succede quando
si compila il codice.

2551
02:05:57,780 --> 02:06:01,560
Si ottiene assemblaggio
lingua fuori di esso, che

2552
02:06:01,560 --> 02:06:07,680
indica il terzo passo è assemblare
tale codice assemblaggio in, in ultima analisi,

2553
02:06:07,680 --> 02:06:12,080
macchine zeri code-- e quelli, non le
testo che abbiamo appena visto un momento fa.

2554
02:06:12,080 --> 02:06:16,370
>> Quindi pre-trattamento non che trovano
e sostituire, e poche altre cose.

2555
02:06:16,370 --> 02:06:19,430
Compilazione prende la vostra fonte
codice C, codice sorgente

2556
02:06:19,430 --> 02:06:21,980
che abbiamo scritto, al montaggio
codice che abbiamo appena guardò.

2557
02:06:21,980 --> 02:06:25,170
Assemblaggio prende quell'assemblea
codice a zero e uno

2558
02:06:25,170 --> 02:06:27,680
che la CPU sarà davvero
capire alla fine della giornata.

2559
02:06:27,680 --> 02:06:30,630
E il collegamento è l'ultimo passo
ciò accade per noi-- di nuovo,

2560
02:06:30,630 --> 02:06:32,830
così in fretta, non facciamo nemmeno
notice-- che dice,

2561
02:06:32,830 --> 02:06:35,460
Hey, adottare tutti
gli zeri e quelli che

2562
02:06:35,460 --> 02:06:39,750
il risultato di compilazione del codice di David,
e la sua funzione principale in questo caso.

2563
02:06:39,750 --> 02:06:42,160
>> E hey del computer, andare a prendere
tutti gli zeri e

2564
02:06:42,160 --> 02:06:45,180
che il personale ha scritto CS50
all'interno della libreria CS50.

2565
02:06:45,180 --> 02:06:46,440
Mescolare quelli con il David di.

2566
02:06:46,440 --> 02:06:49,648
E hey del computer, andare a prendere tutti gli zeri
e quelli che qualcun altro ha scritto anni

2567
02:06:49,648 --> 02:06:50,470
fa per printf.

2568
02:06:50,470 --> 02:06:52,880
E aggiungere quelli in
tutto, in modo che abbiamo

2569
02:06:52,880 --> 02:06:55,870
ha ottenuto i miei zero e uno, il
zero e uno del personale CS50,

2570
02:06:55,870 --> 02:06:58,370
gli zeri printf e quelli,
e qualsiasi altra cosa che stiamo usando.

2571
02:06:58,370 --> 02:07:03,410
>> Tutti vengono combinati insieme in un unico
programma chiamato, in questo caso, ciao.

2572
02:07:03,410 --> 02:07:06,141
Quindi d'ora in poi, ci sarà solo
usare la parola compilazione.

2573
02:07:06,141 --> 02:07:09,390
E noi dare per scontato che quando
diciamo, compilare il proprio programma, significa,

2574
02:07:09,390 --> 02:07:11,849
hey fare il pre-processing,
l'assemblaggio, e il collegamento.

2575
02:07:11,849 --> 02:07:14,890
Ma c'è in realtà un po 'di roba succosa
succedendo lì sotto la cappa.

2576
02:07:14,890 --> 02:07:16,723
E soprattutto se si
ottenere curioso po 'di tempo,

2577
02:07:16,723 --> 02:07:18,900
si può iniziare a frugare
intorno a questo livello più basso.

2578
02:07:18,900 --> 02:07:22,660
Ma per ora, rendersi conto che
tra i takeaway per oggi

2579
02:07:22,660 --> 02:07:26,420
sono semplicemente la
inizio di un processo,

2580
02:07:26,420 --> 02:07:29,700
di prendere confidenza con
qualcosa di simile ciao mondo.

2581
02:07:29,700 --> 02:07:32,575
In effetti, la maggior parte di quello che abbiamo fatto oggi
di certo non andranno affondare in super veloce.

2582
02:07:32,575 --> 02:07:34,491
E ci vorrà un po 'di
tempo, e una certa pratica.

2583
02:07:34,491 --> 02:07:36,864
E le probabilità sono, si ordinerà
di voler colpire la tastiera

2584
02:07:36,864 --> 02:07:37,780
o urlare verso lo schermo.

2585
02:07:37,780 --> 02:07:38,880
E tutto questo è OK.

2586
02:07:38,880 --> 02:07:41,320
Anche se, forse, cercare di non
farlo nella biblioteca così tanto.

2587
02:07:41,320 --> 02:07:43,820
>> E alla fine, ti
essere in grado, però, di avviare

2588
02:07:43,820 --> 02:07:47,580
vedere modelli, sia in buono codice
che hai scritto e in errori

2589
02:07:47,580 --> 02:07:48,370
che hai fatto.

2590
02:07:48,370 --> 02:07:51,965
E molto simile al processo di
diventando una TF o di una CA è come,

2591
02:07:51,965 --> 02:07:54,590
inizierete a ottenere una migliore e
meglio a vedere quei modelli,

2592
02:07:54,590 --> 02:07:56,774
e solo risolvere il vostro
problemi in definitiva.

2593
02:07:56,774 --> 02:07:59,940
Nel frattempo, ci sarà abbondanza
di noi a dare un supporto, e farti

2594
02:07:59,940 --> 02:08:00,481
attraverso questo.

2595
02:08:00,481 --> 02:08:02,450
E nelle rivalutazioni
per tutti i problemi

2596
02:08:02,450 --> 02:08:04,366
si sarà guidati attraverso
tutti i comandi

2597
02:08:04,366 --> 02:08:08,330
che certamente so da
un sacco di pratica, ormai,

2598
02:08:08,330 --> 02:08:10,380
ma potrebbe aver volato
sopra la testa, per ora.

2599
02:08:10,380 --> 02:08:11,580
E questo è tutto bene.

2600
02:08:11,580 --> 02:08:14,230
>> Ma, in ultima analisi, si sta andando
per iniziare a vedere i modelli emergere.

2601
02:08:14,230 --> 02:08:17,260
E una volta passato tutto il
stupidi dettagli, come parentesi,

2602
02:08:17,260 --> 02:08:19,710
e parentesi graffe, e punti e virgola,
e la roba, francamente,

2603
02:08:19,710 --> 02:08:22,360
che non è affatto
intellettualmente interessante.

2604
02:08:22,360 --> 02:08:25,690
E non è l'obiettivo di
prendere qualsiasi corso introduttivo.

2605
02:08:25,690 --> 02:08:27,410
Sono le idee che stanno alla materia.

2606
02:08:27,410 --> 02:08:29,659
>> È loop, e
le condizioni, e le funzioni,

2607
02:08:29,659 --> 02:08:33,552
e più potentemente l'astrazione,
e il factoring di codice,

2608
02:08:33,552 --> 02:08:36,510
e il buon design, e il buon
stile, e in ultima analisi, la correttezza

2609
02:08:36,510 --> 02:08:40,330
del codice, che è in ultima analisi,
andando a contano di più.

2610
02:08:40,330 --> 02:08:43,925
Così la prossima settimana, ci vorrà questi
idee che abbiamo visto la prima volta in Scratch

2611
02:08:43,925 --> 02:08:45,800
e sono ora tradotti
a C. E cominceremo

2612
02:08:45,800 --> 02:08:48,740
per introdurre il primo della
i domini del mondo reale del corso.

2613
02:08:48,740 --> 02:08:53,140
>> Ci concentriamo sul mondo della sicurezza,
e più specificamente crittografia,

2614
02:08:53,140 --> 02:08:54,980
l'arte di scrambling informazioni.

2615
02:08:54,980 --> 02:08:57,000
E tra i primi
problemi Tu stesso

2616
02:08:57,000 --> 02:08:59,840
si arriva a scrivere oltre
giocando con alcuni dei sintassi

2617
02:08:59,840 --> 02:09:02,880
e risolvere alcuni logico
problemi, in ultima analisi, in breve tempo,

2618
02:09:02,880 --> 02:09:06,960
è quello di arrampicarsi in realtà, o cifrare,
e, infine, decifrare le informazioni.

2619
02:09:06,960 --> 02:09:09,470
E tutto quello che abbiamo fatto
oggi, sarà piuttosto bassa

2620
02:09:09,470 --> 02:09:12,190
livello, è solo andare a permettere
noi a prendere uno, e uno,

2621
02:09:12,190 --> 02:09:16,550
e un altro passo verso sopra
scrivere ancora il codice più interessante.

2622
02:09:16,550 --> 02:09:18,050
>> Quindi, più che la prossima settimana.

2623
02:09:18,050 --> 02:09:20,834

2624
02:09:20,834 --> 02:09:21,762
>> [RIPRODUZIONE VIDEO]

2625
02:09:21,762 --> 02:09:22,690

2626
02:09:22,690 --> 02:09:25,006
>> -Cosa Mi puoi raccontare
l'ultima volta che l'hai visto?

2627
02:09:25,006 --> 02:09:29,041

2628
02:09:29,041 --> 02:09:30,040
-Cosa Posso dire, davvero?

2629
02:09:30,040 --> 02:09:33,500

2630
02:09:33,500 --> 02:09:38,340
Voglio dire, era come qualsiasi altro
le prove di pre-produzione,

2631
02:09:38,340 --> 02:09:43,510
tranne che c'era qualcosa che ha detto
proprio alla fine che mi è rimasta.

2632
02:09:43,510 --> 02:09:47,810

2633
02:09:47,810 --> 02:09:49,640
>> -Questo Era CS50.

2634
02:09:49,640 --> 02:09:52,440

2635
02:09:52,440 --> 02:09:55,190
>> -Che È un taglio a tutti,
grande lavoro su prove.

2636
02:09:55,190 --> 02:09:56,070
>> pranzo di -Che?

2637
02:09:56,070 --> 02:09:57,986
>> Si ', voi ed io possiamo
prendere un panino in un po '.

2638
02:09:57,986 --> 02:10:01,380
Vorrei solo debriefing con
David molto velocemente.

2639
02:10:01,380 --> 02:10:02,160
David?

2640
02:10:02,160 --> 02:10:04,260
David?

2641
02:10:04,260 --> 02:10:06,110
>> [FINE RIPRODUZIONE]

