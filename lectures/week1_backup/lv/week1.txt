[SKAN MŪZIKA] DAVID J. Malan: Labi, tas ir CS50. Un tas ir šonedēļ viens. Tāpēc atgādina, ka pēdējo reizi nulles nedēļā, mēs vērsta uz skaitļošanas domāšanu. Un mēs pārgāja no līdz Scratch, grafisks programmēšana valoda no mūsu draugiem at MIT Media Lab. 

Un ar nulles, vai mēs izpētīt idejas, piemēram, funkcijām, un nosacījumus, un cilpas, un mainīgie, un pat notikumi un diegi, un vairāk. Un šodien, mēs ejam, lai turpināt izmantot šo ideju, un tiešām ņemot tos par piešķirta, bet tulkot tos citā valodā sauc par C. Now, C ir vairāk tradicionāls valoda. Tas ir zemāks līmenis valoda, ja Jums gribas. 

Tas ir tīri teksta. Un tā pēc pirmā acu uzmetiena, tas ir visi skatīsies visai noslēpumains Ja jūs nekad neesmu programmēt agrāk. Mēs ejam, lai būtu semikoli, un iekavas, un cirtaini bikšturi, un vairāk. Bet saprotu, ka pat gan sintakse ir par to, lai izskatās nedaudz svešs lai lielākā daļa no jums, redzēt pagātni, ka. Un mēģināt redzēt idejas ka ir, protams, pazīstams, jo šeit nedēļā viens ko mēs sāksim darīt, ir salīdzināt, Sākotnēji, Scratch pret C. 

Tā, piemēram, atceros, ka tad, kad mēs īsteno pirmā no mūsu programmas pēdējo reizi, mums bija bloks, kas izskatījās mazliet kaut kā this-- kad zaļš karogs uzklikšķināt, un tad mums bija viens vai vairāki puzzle gabalus zem tā, šajā gadījumā, teiksim, hello pasaule. Tātad, protams, ir nulles, kad es noklikšķiniet uz šīs zaļās karogu palaist savu programmu, lai runāt, tie ir bloki, kas saņem izpildīts, vai palaist. Un, konkrēti, Scratch teica, hello, pasaule. 

Tagad es varētu būt norādīts dažādi vārdi šeit. Bet mēs redzam, ka, protams, daudzi Šo blocks-- un, protams, C daudzi functions-- var būt parametrized vai pielāgot darīt dažādas lietas. Patiesībā, C, ja mēs vēlaties konvertēt, tagad, šī Scratch programma šajā citā valodā, mēs ejam rakstīt mazliet kaut kas līdzīgs šim. 

Piešķirts, ir daži svešs sintakse tur, visticamāk, int, un iekavas, un par spēkā neesošu. Bet printf-- pat ja jūs būtu domāju, ka tas būtu vienkārši izdrukāt. Bet print nozīmē drukāt formatēti, kā mēs drīz redzēt. Tas burtiski būs drukāt uz ekrāna neatkarīgi ir iekšpusē no tiem iekavās, kas Protams, šajā gadījumā ir, hello pasaule. 

Bet jūs pamanīsiet kādu citu sintakse, daži pēdiņas, ka iekavas beigās, semi-resnās zarnas un tamlīdzīgi. Tātad tur ir mazliet virs galvas, tā sakot, gan kognitīvi un sintaktiski, ka mēs ejam ir jāatceras pirms ilgi. Bet saprotu, ka ar praksi, tas sāks izlēkt pie jums. 

Patiesībā, pieņemsim koncentrēties uz šo vienu funkcija specifically-- šajā gadījumā, sasveicināties pasauli. Tā teikt, ir funkcija. Sveiki pasaule ir tās parametrs, vai arguments, tā pielāgošanu. 

Un ekvivalence C ir tikai būs šo vienu līniju šeit, kur printf ir līdzvērtīgs, teiksim, dubultā citēts string, hello pasaule ir līdzvērtīgs, protams, to, kas ir baltā kastē tur. Un slīpsvītru n, lai gan nedaudz dīvaini un prom no nulles, vienkārši nāksies sekas mēs redzēt datorā, piemēram, mana Mac vai PC, no tikai pārvietojot kursoru uz nākamo rindiņu. Tas ir tāpat kā hitting Enter uz tastatūras. 

Tātad mēs redzam, ka atkal pirms ilgi. Bet vispirms, pieņemsim to apskatīt šo cits piemērs gadījumā cilpas. Mums bija šo forever cilpa pēdējo reizi, kurš bija virkne puzzle gabalus ka tomēr kaut ko burtiski forever-- šajā gadījumā, saka, Hello World, hello pasaule, Hello World, hello pasaule. Tātad, tas ir bezgalīgs cilpa ar dizainu. 

C, ja mēs vēlamies, lai īstenotu šo pati ideja, mēs varētu vienkārši izdarīt. Lai gan ir taisnība, printf sveiki world-- tagad savukārt, tikai semantiski, veida uzbur ideju darīt kaut kas atkal un atkal, un atkal, un cik ilgi? Nu, true-- atgādināt, ka taisnība ir tikai vai vienu. 

Un taisnība, protams, vienmēr ir taisnība. Tātad, tas ir sava veida jēgu paziņojums vienkārši pateikt taisnība. Bet tiešām, tas ir apzināta, jo, ja taisnība ir tikai vienmēr ir taisnība, nekā bet taisnība tikai nozīmē, ja mazliet netieši, ka šādām līnijām kodu starp šiem cirtaini lencēm vajadzētu tikai izpildīt atkal, un atkal, un atkal, un patiesībā nekad apstāties. 

Bet, ja jūs vēlaties, lai jūsu cilpa pārtraukt, kā mēs darīja pēdējo reizi ar kaut ko līdzīgu tas, atkārtojiet šādus 50 reizes, C mēs varam darīt to pašu ar to, kas ir sauc par loop-- atslēgvārdu kas nav, bet, bet. Un tad mums ir dažas jaunas sintakse šeit, ar int i ir vienāds ar 0, I mazāk nekā 50, i ++. Un mēs būsim atpakaļ uz to. Bet tas ir vienkārši, kā mēs būtu tulkot kopumu Scratch blokiem kopumu C rindas kodu. 

Tikmēr, uzskata mainīgos. Un, patiesībā, mēs vienkārši redzēju vienu pirms brīža. Un gadījumā, ja nulles, ja mēs vēlējās deklarēt mainīgo sauc i par i ir vesels skaitlis, tikai skaitlis, un mēs gribam, lai uzstādītu to uz kādu vērtību, mēs varētu izmantot šo apelsīnu bloķēt here-- noteikts i līdz 0. 

Un mēs redzam šodien, un tālāk, tāpat kā pagājušajā nedēļā, programmētāji darīt gandrīz vienmēr sāk skaitīt no nulles, tiešām pēc vienošanās. Bet arī tāpēc, ka atsaukšana no Mūsu diskusija binārā, mazākais skaits varat pārstāv ar jebkuru bitu skaitu ir tikai būs 0. sevi. Un tāpēc mēs parasti sākas inicializēšana pat mūsu mainīgos līdz 0. 

Un C darīt to pašu, mēs ejam teikt int vesels skaitlis, es tikai pēc vienošanās. Es varētu būt sauc šis mainīgais kaut ko es gribu, tāpat kā nulles. Un tad ir 0 tikai piešķir vērtība 0 no labās un nodod to uz mainīgo, vai glabāšanas konteineris tur, pa kreisi. Un daļēji kols kā mēs see-- un mēs esam redzējuši dažus no šiem already-- tikai nozīmē beigas domas. Rīkoties, lai darīt kaut ko citu uz līnijām, kas seko. 

Tagad, ko par Būla izteiksmes? Atgādināt, ka nulles, tie bija izteiksmes kas ir vai nu patiess vai false-- jautājumi, tiešām, kas ir vai nu patiess vai nepatiess. Tātad, šajā gadījumā uz nulles, mēs varētu uzdot vienkāršu jautājumu, piemēram, tas, ir tā, i mazāk nekā 50? Tāpēc es, atkal, ir vesels skaitlis. Varbūt mēs to izmanto kādā Scratch programmā sekot rezultātu vai kaut kas tāds. Tātad šis sintakse šeit Scratch tikai nozīmē, ir i mazāk nekā 50? Nu, par laimi, kaut kas ir vienkāršs C. Un tulkot, tā mēs varētu vienkārši teikt, es mazāk nekā 50, izmantojot pazīstamo atslēgu uz tastatūras. 

Tikmēr, ja vēlaties pateikt kaut ko vairāk vispār, piemēram, labi, ir x mazāks nekā y, kur katra no X un Y ir paši mainīgie? Mēs varam darīt to pašu C, tik ilgi, kamēr mēs esam radīja šos mainīgos jau. Un mēs redzēsim, kā darīt pirms ilgi. Mēs vienkārši sakām x mazāk nekā y. 

Tātad jūs, sākot ar redzēt dažas līdzības. Un tiem ļaudīm, kas izgatavotas Scratch noteikti bija iedvesmojoties no dažiem no šiem pamata ideju. Un jūs redzēsiet šāda veida sintakse daudzās languages-- ne tikai Scratch, nav tikai C, bet Python, un JavaScript, un citas valodas joprojām. 

Apskatīsim citu konstrukciju no C, jēdziens nosacījumu, darot kaut ko nosacīti. Ja kaut kas ir patiess, to izdarītu. Ja kaut kas cits ir taisnība, darīt. Tas ir sava veida plānošanas ekvivalents dakšiņu ceļa. Varbūt tas ir divvirzienu dakša, trīs-way dakša, vai vairāk. Un nulles, mums varētu būt redzējis kaut kas līdzīgs šim. 

Tāpēc šis viens ir liels vienu. Bet uzskatu, relatīvais vienkāršība loģiku. Ja x ir mazāks nekā y, tad teikt, ka x ir mazāks nekā y, cits ja x ir lielāks nekā y, tad teikt x ir lielāks nekā y. Un tad, loģiski, ja Jūs domājat, ka atpakaļ uz nulles vai vienkārši savu cilvēka intuīcija, labi, ja x ir ne lielāks par y, un x ir ne mazāks par y, tad protams x būs vienāds ar y. Tātad, šajā gadījumā, ar ligzdošanas šie Scratch bloki, mēs varam sasniegt trīs kā dakša uz ceļa? 

Tikmēr, ja mēs vēlamies, lai darīt, ka C, tas varbūt izskatās nedaudz simpler-- vismaz kad jūs iepazīties ar sintaksi. Ja x ir mazāks nekā y, printf x ir mazāks nekā y. Cits ja x ir lielāks nekā y, printf x ir lielāks nekā y. Else printf x ir vienāds ar y-- un, atkal, ar tiem reversā slīpsvītra beidzas tikai tiem jaunām līnijām tā, ka, ja jūs faktiski bija šāda veida programmas tas vienkārši pārvietot jūsu kursors galu galā uz nākamo rindu ekrāna. 

Tagad, tikmēr Scratch bija cits sarežģītākas funkcijas, tikai daži no kuriem mēs ejam sākotnēji pāriet uz pasaules C. Un viens no tiem bija sauc saraksts nulles. Un tas bija īpašs Mainīgā veids, kas ļāva jums saglabāt vairākas lietas tajā atpakaļ, atpakaļ, atpakaļ, atpakaļ. 

C, tas nav saraksti, per se, bet kaut kas kas ir vispārīgāk sauc bloki, lai gan mēs atgriezties vēlāk šo semestri lai meklē kaut ko sauc sarakstu, vai tiešām saistītu sarakstu. Bet tagad, tuvākais ekvivalents C mums būs kaut kas sauc masīvs. Un masīvs ir vienkārši īpaša veida mainīgo kas ļauj uzglabāt datus atpakaļ, atpakaļ, atpakaļ, uz muguras. 

Un, protams, ir nulles, ja mēs vēlējāmies, lai piekļūtu masīva pirmais elements vai list-- un es esmu gatavojas, lai izsauktu to, Pēc vienošanās, argv, arguments vektors, bet vairāk par to pirms ilgi. Ja es vēlos saņemt pie pirmā elementa no argv, pasaulē Scratch jūs faktiski darīt parasti sāk skaitīt no 1. 

Un tā es varētu saņemt par argv 1.punktā. Tas ir tikai, cik MIT īstenoti jēdziens sarakstus. Bet C, es esmu gatavojas vairāk vienkārši tikai teikt, argv, kas atkal ir nosaukums mana list-- vai lai būtu skaidrs, masīvs. Un, ja es gribu pirmais elementi, es eju izmantot kvadrātiekavas, kas jums iespējams, nav bieži izmanto ar klaviatūru. 

Bet 0 tikai nozīmē, atnesiet man pirmais. Tātad par godu un kā laiks iet, mēs ejam lai sāktu, lai redzētu šīs dihotomijas no nulles un C, kuru Scratch izmanto. Mēs C izmanto 0 šeit. Bet jūs ātri redzēt kad jūs saprotat pamati katrā valodā, ka šīs lietas sāk iegūt vēl vairāk iepazinušies ar praksi un praksi. 

Tātad pieņemsim tiešām izskatās tagad programmu. Šeit ir pirmais no mūsu C pirmkods kompleksajai programmām. Un programma, mēs ejam piedāvāt izskatīšanai ir viens, kas ir līdzvērtīgi uz šo agrāko Scratch gabalu. 

Tātad šeit, mums ir, ko ir varbūt vienkāršākais C programma jūs varat rakstīt, ka faktiski dara kaut ko. Tagad mēs apskatīt pagātni, tagad, jau ietver, standarta io.h, un tie leņķis kronšteini, un int, un par spēkā neesošu, un cirtaini bikšturi, un tamlīdzīgi. 

Un pieņemsim tikai koncentrēties uz ko, vismaz intuitīvi, varētu izlēkt pie jums jau. Patiesībā, galvenais, man nav vienmēr zina, kas tas ir, bet daudz, piemēram, nulles bija, ka tad, kad zaļš karogs uzklikšķināt puzzles gabaliņam, tas pats C kā programmēšanas valodu ir galvenais gabals kodu, kas izpaužas izpildīts pēc noklusējuma. Un, protams, tas burtiski būs saukt galvenais. 

Tātad galvenais ir funkcija. Un tas ir speciāla funkcija, kas pastāv C, ka tad, kad jūs palaist programmu, tas ir galvenais, kas izpaužas vada noklusējuma. Pasaulē nulles, Parasti tas bija, kad zaļš karogs uzklikšķināt ka got darboties pēc noklusējuma. 

Tikmēr mēs esam redzējuši šo pirms, printf vai izdrukāt formatēt, tas ir būs funkcija, kas nāk ar C, kopā ar visu ķekars citiem, ka griba laiku un laiku atkal, lai darīt tieši jo tā nosaukums liecina, drukāt kaut ko. Ko mēs vēlamies drukāt? Nu, mēs redzēsim, ka ar pievienojot rakstzīmes tāpat these-- Hello World, slīpsvītru n pēdiņās, mēs varam pateikt printf precīzi ko drukāt uz ekrāna. 

Bet, lai darīt ka mēs diemžēl ir nepieciešams veikt kaut ko, kas ir jau mistisks uz mums cilvēkiem, bet vismaz tas ir nedaudz readable-- asas ietver standarta io.h, int, Galvenais, par spēkā neesošu, printf, visi burvju buramvārdi mēs tikko redzējām uz ekrāna. Bet mums tiešām ir iet vairāk arcane joprojām. Mums vispirms ir nepieciešams tulkot kodu ka mēs rakstīt uz mašīnu kodu. Un atsauktu no pagājušajā nedēļā, ka mašīnas, vismaz tie, mēs zinām šeit, beigās, dienā tikai izprast nullēm un uzņēmumiem. 

Un mans Dievs, ja mums bija rakstīt šos nullēm un uzņēmumiem faktiski programmu, tas būtu ļoti, ļoti ātri veikt fun no neko. Bet izrādās, par pagājušajā nedēļā, ka šie modeļi nullēm un uzņēmumiem vienkārši ir īpaša nozīme. Dažos kontekstos, tie varētu nozīmēt numurus. 

Dažās situācijās, viņi varētu nozīmēt vēstules, vai krāsas, vai jebkuru numuru Citu abstrakciju tur pēc. Bet, tāpat kā jūsu dators ir CPU, Central Processing Unit, vai smadzenes iekšpusē datora. Tas parasti Intel iekšā, jo tas ir viens no lielākajiem uzņēmumiem kas padara CPU datoriem. 

Nu, Intel CPU un citi vienkārši ir nolēmuši iepriekš ka daži modeļi nullēm un tiem ir īpašas lietas. Daži modeļi nullēm un uzņēmumiem nozīmēs, drukāt tas uz ekrāna, vai pievienot šos divus skaitļus, vai atņemt šos divus skaitļus, vai pārvietot šo gabalu datus no mana datora atmiņā vairāk nekā šeit, vai vairākas citas ļoti zemā līmenī, bet galu galā noderīga, operācijas. Bet, par laimi, mēs cilvēki nenāks uz nepieciešamību zināt šo detalizācijas pakāpi. Patiešām, tāpat kā pēdējo reizi, kad mēs nošķirts atkal, un atkal, un atkal, Ēka no ļoti zema līmeņa primitīvi kā nullēm un uzņēmumiem uz augstāka līmeņa koncepcijām piemēram, skaitļu un burtu, un krāsas, un vairāk, lai mēs kā programmētāji stāvēt uz pleciem citi, kas ir ieradušies pirms mums un lietot programmatūru, kas cita cilvēki ir rakstīts pirms us-- proti, programmas sauc kompilatoru. 

C ir valoda, kas parasti apkopoti, kas nozīmē pārveidots no pirmkods uz mašīnu kodu. Jo īpaši, ko tas nozīmē ir tas, ka, ja jūs esat ieguvuši savu avotu kods, kas tu pats rakstīt, kā mēs drīz būs tikai brīdi uz ekrāna, un jūs vēlaties, lai pārvērstu to galu galā mašīna code-- šie nullēm un tiem, kas tikai jūsu Mac vai datora understands-- tev pirmais barību, ka pirmkodu kā ieguldījums īpašu Programma sauc kompilatoru, kuras izejas signāls mēs redzēsim ir mašīna kods. Un, protams, pēdējo reizi mēs runājām apmēram, patiešām, beigās, dienā, problēmu risināšana. Jūs esat ieguvuši ieejas. Un tev izejas. Un tev kādu algoritma vidū. 

Algoritmi var, protams, ir īstenoti programmatūru, kā mēs redzējām ar pseudocode pagājušajā nedēļā un kā mēs redzēsim ar faktisko kodu šonedēļ. Un tāpēc kompilators tiešām tikko ir kopums algoritmu iekšpusē par to, kas zina, kā pārvērst īpašos atslēgvārdus, piemēram, galveno, un printf, un citiem, ka mēs tikko redzēja vērā modeļus nullēm un tie, kas Intel iekšpusē un citi CPU tiešām saprot. Tātad, kā mēs to darām? Kur mēs iegūstam kompilatoru? 

Lielākā daļa no mums šeit ir Mac vai PC. Un jūs darbojas Mac OS, vai Windows vai Linux vai Solaris, vai vairākas citas operētājsistēmas. Un, protams, mēs varētu iziet uz web un lejupielādēt kompilatoru jūsu Mac vai datora par jūsu konkrēto operētājsistēmu. Bet mēs visi būtu uz dažādas lapas, lai runāt. Mēs ir nedaudz dažādas konfigurācijas. Un lietas nedarbosies visi vienādi. Un, protams, šajās dienās daudzi no mums neizmanto programmatūra, kas darbojas tikai uz mūsu klēpjdatorus. Tā vietā, mēs izmantot kaut ko kā pārlūku, kas ļauj mums piekļūt tīmekļa lietojumprogrammas mākonis. Un vēlāk šajā semestrī, mēs darīsim tieši tā. Mēs rakstīt pieteikumus vai programmatūru, izmantojot code-- ne C, bet citās valodās, piemēram, Python un JavaScript-- ka ieskriet mākoni. 

Un, lai to izdarītu, mēs paši semestra laikā faktiski izmantot mākonis balstītas vide pazīstams kā CS50 IDE. Šī ir tīmekļa programmēšana vide, vai integrētā izstrādes vide, IDE, kas ir būvēts atop daži atvērtā koda programmatūras sauc Cloud 9. Un mēs esam padarījuši dažus pedagoģiskā vienkāršojumi uz to lai slēptu noteiktas funkcijas Pirmajās nedēļās, kas mums nav nepieciešams, pēc kura jūs varat atklāt tos un darīt visvairāk kaut ko vēlaties ar vidi. 

Un tas ļauj mums, arī, lai pre-instalēt noteiktu programmatūru. Lietas, piemēram, tā saukto CS50 bibliotēka, ko mēs drīz redzēt nodrošina mūs C ar kādu papildu funkcionalitāti. Tātad, ja jums iet uz galu galā, CS50.io, Jums tiks piedāvāts pieteikties, un, kad jūs darīt, un izveidot kontu par brīvu, jums būs iespēja piekļūt vide, kas izskatās gluži kā šis. 

Tagad tas ir noklusējuma režīmā. Viss ir jauki un spilgti uz ekrāna. Daudzi no mums ir ieradums strādā CS50 gabals, kas ir diezgan vēlai naktij. Un tāpēc daži no jums varētu labāk pārvērst to nakts režīmu, lai runāt. 

Bet, galu galā, ko jūs esat gatavojas redzēt ietvaros CS50 IDE ir trīs atšķirīgas areas-- zona pa kreisi, kur faili gatavojas tiks sniegta mākonis, platība labajā augšējā stūrī kur jūsu kods būs rediģējams. Jūs varēsiet atvērt individuālie cilnes jebkuru programmu ka jūs rakstīt šo semestri iekšā Minētā augšējā labajā stūrī. Un tad lielākā arcanely, un tomēr spēcīgi, būs šī lieta pie apakšējā pazīstams kā termināļa logā. 

Tas ir vecās skolas Command Line Interface, vai CLI, kas ļauj jums izpildīt komandas par computer-- šajā gadījumā, dators In cloud-- darīt lietas, piemēram, sastādīt savu kodu no avota kodu, lai mašīnu kodu, palaist savu programmu, vai sākt savu web serveri, vai arī, lai piekļūtu jūsu datu bāzē, un neierobežotu skaitu citu paņēmienu ka mēs sāksim lietot pirms ilgi. Bet, lai tur nokļūt, mēs esam būs tiešām ir doties tiešsaistē un sākt spēlēt. Un, lai to izdarītu, pieņemsim vispirms sākt tinkering ar galveno, un rakstīt galveno daļu programmu. Un pieņemsim izmantot šo funkciju printf, ko mēs izmantojām agrāk, vienkārši pateikt kaut ko. 

Tātad, šeit es esmu jau iekšā CS50 IDE. Esmu pieteicies iepriekš. Un es pilnībā pārmeklēta logu. Un tā, galu galā, jūs Arī turpmākajos problēmas sekos līdzīgus pasākumus, kas nodrošinās tiešsaistes dokumentāciju. Tātad jums nav jāuztraucas par absorbējot ik maz tehnisko soli ka man šeit šodien. 

Bet jūs saņemsiet ekrāna kā šis. Man gadās būt nakts režīmā. Un jūs varat atdzīvoties visu up ar invaliditāti nakts režīmu. Un beigās no diena, jūs gatavojas redzēt šie trīs galvenie areas-- faila pārlūks pa kreisi, kods cilnes augšu augšu, un termināļa logs apakšā. 

Ļaujiet man iet uz priekšu un uzrakstīt savu pirmo programmu. Es esmu gatavojas preemptively doties uz File, Glābt un saglabāt savu failu kā hello.c. Patiešām, pēc vienošanās, jebkura programma, mēs raksta, ka ir rakstīts C valodā jānosauc kaut dot c, pēc vienošanās. Tāpēc es esmu gatavojas nosaukt to hello.c, jo Es tikai gribu teikt hello uz pasauli. Tagad es esmu gatavojas, lai tuvinātu out un noklikšķiniet uz Saglabāt. Un viss, kas man ir tagad šeit ir tab kurā es varētu sākt rakstīt kodu. 

Tas nav gatavojas sastādīt. Tas neko nenozīmē. Un pat tad, ja es konvertē tas nullēm un tiem, CPU ir nāksies nē ideja, kas notiek apkārt. Bet, ja es rakstītu līnijām, kas atbilst ar C s conventions-- C būtni, atkal, tas language-- ar sintaksi, piemēram, Tas, printf sveiki world-- un es esmu gotten apmierināti ar darot laika gaitā. Tāpēc es nedomāju, ka es jebkuras drukas kļūdas. 

Bet, vienmēr, ļoti pirmais reizi, kad jūs to izdarītu, jums būs. Un ko es esmu gatavojas darīt varētu ļoti labi nestrādās jums pirmo reizi. Un tas ir pilnīgi OK, jo tieši tagad tu var tikai redzēt visai daudz jaunums, bet laika gaitā, kad jūs iepazīties ar šo vidi, un šī valoda, un citi, jūs sākat redzēt lietas, kas ir vai nu pareizi vai nepareizi. 

Un tas ir tas, ko mācību puiši un protams palīgi saņemt tik labi laika gaitā, ir smērēšanās kļūdas vai bugs jūsu kodu. Bet es apgalvo, ka nav bugs šajā kodeksā. Tāpēc es tagad gribu palaist šo programmu. 

Tagad uz savu Mac vai PC, es esmu ieradums dubultklikšķi uz ikonas kad es gribu palaist kādu programmu. Bet tas nav modelis šeit. Šajā vidē, kas ir CS50 IDE. Mēs izmantojam pamatdarbības sistēma, ko sauc Linux. Linux ir atgādina cita operētājsistēma, vispār zināms kā Unix. Un Linux ir īpaši pazīstama kam Command Line vides, CLI. Tagad mēs esam, izmantojot īpašu aromāts Linux sauc Ubuntu. Un Ubuntu ir vienkārši pārliecināts versija Linux. 

Bet šie Linux šajās dienās darīt faktiski nāk ar grafisko lietotāja saskarnes. Un viens mēs gadās izmantojat šeit ir tīmekļa. Tātad tas varētu izskatīties pat nedaudz atšķiras no kaut ko jūs pats varētu būt redzējuši vai palaist pagātnē. 

Tāpēc es esmu gatavojas iet uz priekšu tagad un darīt šādi. Esmu saglabājis šo failu kā hello.c. Es iešu uz priekšu un tips clanghello.c Tātad šķindēt par C valodā ir kompilatoru. Tas ir iepriekš uzstādīta CS50 IDE. Un jūs varat absolūti lejupielādēt un instalēt šo par savu Mac vai PC. 

Bet, atkal, jums nebūtu visi iepriekš konfigurācija darīts jums. Tātad tagad, es esmu tikai gatavojas palaist clanghello.c. Un tagad paziņojums šo sintaksi šeit būs galā saprast tikai nozīmē, ka es esmu A mapi vai direktoriju sauc darbvietas. Tas dolāra zīme ir tikai konvencija jēgu, ierakstiet savu komandas šeit. 

Tas ir tas, ko sauc ātru, vienkārši pēc vienošanās ir dolāra zīme. Un, ja es iet uz priekšu tagad un noklikšķiniet Ievadiet, nekas, šķiet, ir noticis. Bet tas tiešām ir laba lieta. Jo mazāk, kas notiek uz jūsu ekrāna, jo lielāka iespēja Jūsu kods ir pareizs, vismaz sintaktiski. 

Tātad, ja es gribu, lai palaistu šo programma, ko man darīt? Nu, izrādās, ka noklusējuma nosaukums pēc vienošanās programmām, ja jums nav jānorāda nosaukt jūsu programma ir tikai a.out. Un tas sintakse pārāk, jūs iepazīties ar pirms ilgi. 

Dot slash tikai nozīmē, hey, CS50 IDE, palaist programmu, ko sauc a.out tas ir manā pašreizējā direktorijā. Tas dot nozīmē pašreizējā direktorijā. Un mēs redzēsim, ko citi šādas secības rakstzīmju nozīmē pirms ilgi. 

Tātad šeit mēs ejam, Enter, hello pasaule. Un jūs pamanīsiet, ka tas, kas notika? Tas ne tikai drukāt Hello pasaulē. Tā arī pārvietots kursoru uz nākamo rindiņu. 

Un kāpēc tas bija? Kāds bija kods, kas mēs rakstījām pirms ka jānodrošina, ka kursors būtu doties uz nākamo rindiņu? Funny lieta par dators ir tas tikai gatavojas darīt burtiski to, ko tu pateikt to darīt. 

Tātad, ja jums pateikt to printf hello, komats, atstarpe, pasaule, tuvu quote, tas burtiski tikai gatavojas izdrukāt šos rakstzīmes. Bet man bija šo īpašo raksturu Beigās, atsaukšanu, slīpsvītru n. Un tas, ko nodrošināja ka raksturs gāja uz nākamo rindu ekrāna. 

Patiesībā, ļaujiet man iet un darīt. Ļaujiet man iet uz priekšu un izdzēst to. Tagad, paziņojums, ka top par manu ekrānu tur nedaudz sarkanā gaisma cilni, norādot, hey, jūs esat ne saglabājis failu. Tāpēc es esmu gatavojas iet uz priekšu ar kontroli S vai komandu S, saglabājiet failu. Tagad tas goes-- devās uz moment-- zaļš. Un tagad tas ir atpakaļ tikai ir cieša ikona. 

Ja es tagad palaist clanghello.c atkal, Enter, dot slīpsvītra, a.out, Enter, jūs redzēsiet, ka tas vēl strādāja. Bet tas varbūt ir nedaudz buggy. Tieši tagad, mans prompt-- darbvieta, un tad, ka dolāra zīmi, un tad mans aktuālā prompt-- ir visu uz vienas līnijas. Tātad šī noteikti ir estētisks bug, pat ja tas nav īsti loģiska kļūda. 

Tāpēc es esmu gatavojas atsaukt to, ko es tikko darīju. Es esmu gatavojas atkārto a.out. Paziņojums Esmu pievienotās newline raksturs atpakaļ. Esmu saglabājis failu. 

Tāpēc es esmu gatavojas atkārto a.out, and-- dammit, bug, bug nozīmē kļūda. Tātad kļūda ir tā, ka, lai gan I pievienotās slīpsvītru n tur, re-saglabāti, re-skrēja programmu, uzvedību bija tāda pati. Kāpēc tas var būt? 

Es esmu trūkst soli, labi? Ka galvenais solis agrāk bija, ka jums ir kuri paredzēti, ja jūs maināt savu pirmkodu, izrādās arī palaist tas caur kompilators atkal, lai jūs iegūtu jaunu mašīnu kodu. Un mašīnu kodu, nullēm un tiem, ir būs gandrīz identiski, bet nav pilnīgi tāpēc, ka mums ir nepieciešams, protams, ka jaunā līnija. 

Tātad, lai to labotu, es esmu dodas uz nepieciešamību lai atkārto clanghello.c, ievadiet, dot slīpsvītra, a.out. Un tagad, sveiki pasaule ir atpakaļ lai kur es gaidīt to, lai būtu. Tātad tas ir viss labi un labs. Bet a.out ir diezgan stulba nosaukums programma, pat ja tas notiek, ir, vēsturisku iemeslu dēļ default-- nozīmē montāžas izejas. 

Bet ļaujiet man iet uz priekšu šeit un darīt savādāk. Es gribu savu Sveika, pasaule faktiski sauc sveiki. Tātad, ja tas būtu ikona par manu desktop, tas nebūtu a.out. To varētu saukt sveiki. 

Tātad, lai to izdarītu, izrādās, ka šķindēt, tāpat kā daudzas programmas, atbalsta komandrindas argumentus, vai karogi, vai slēdži, kas vienkārši ietekmēt savu uzvedību. Konkrēti, šķindēt atbalsta domuzīme o karogs, kura tad otru vārdu. Šajā gadījumā, es ņemšu patvaļīgi, bet saprātīgi, to sauc sveiki. Bet es varētu to nosaukt kaut kas Es gribu, izņemot a.out, kas būtu diezgan papildus punktu. 

Un tad tikai norādiet vārdu faila es vēlos, lai apkopotu. Tātad, tagad, pat ja sākumā no komandu man vēl ir šķindēt, beigās komandu Man joprojām ir faila nosaukumu, Man tagad ir šīs komandrindas argumenti, šie karogi, kas saka, oh, starp citu, izeja-o, fails sauc hello, nevis noklusējuma a.out. 

Tātad, ja es hit Enter tagad, nekas šķiet, ir noticis. Un, tomēr, tagad es varu darīt dot slīpsvītra sveiki. Tātad, tas ir tā pati programma. Nullēm un tiem ir identisks beigās, dienā. 

Bet viņi divās atšķirīgs files-- a.out, kas ir pirmais variants un vienkārši muļķīgi nosaukts, un tagad hello, kas ir daudz vairāk pārliecinoši nosaukums programmai. Bet, godīgi, es esmu nekad gatavojas atcerēties to atkal, un atkal, un atkal. Un, patiesībā, kā mēs rakstām sarežģītāka programmas, komandas jūs esat nāksies rakstīt gatavojas saņemt pat vairāk sarežģī vēl. 

Un tāpēc nav jāuztraucas. Izrādās, ka cilvēki pirms mums ir sapratuši, viņi pārāk bija šī tieši tādu pašu problēmu. Arī viņi neguva, kam tips diezgan ilgi, mistiskā komandas, nemaz nerunājot atcerēties tos. Un tā cilvēki pirms mums ir devuši citas programmas, kas atvieglo sastādīt savu programmatūru. 

Un, protams, viens no šādiem Programma sauc Make. Tāpēc es esmu gatavojas iet uz priekšu un darīt to. Es esmu gatavojas atsaukt visu I vienkārši darīja sekojošā veidā. Ļaujiet man rakstīt LS. Un jūs pamanīsiet trīs things-- a.out, un zvaigzne, hello un zvaigzne, un hello.c. Cerams, tas būtu būt mazliet intuitīva, ciktāl agrāk nebija nekas šajā darbvietā. Nebija nekas, ka man bija izveidots kamēr mēs sākām klasē. 

Un es izveidojis hello.c. Es pēc tam apkopo to, un nosauca to a.out. Un tad es apkopo to atkal nedaudz savādāk un nosauca to sveiki. Tāpēc man ir trīs failus šajā direktorijā, Šajā mapē sauc Workspace. Tagad es redzu, ka arī ja es attālinātu faktiski. 

Ja es zoom out šeit un apskatīt šajā augšējā labajā rokā stūra, kā solīts kreisās labajā pusē no ekrāna vienmēr gatavojas parādīs kas ir jūsu kontā, kas ir iekšpusē CS50 IDE. Un tur ir trīs failus tur. 

Tāpēc es gribu atbrīvoties no a.out un sveiki. Un, kā jūs varētu iedomāties intuitīvi, jums varētu šķirot Kontroles klikšķi vai labo klikšķi uz šīs. Un tas maz izvēlne. Jūs varat lejupielādēt failu, palaist tas, priekšskatīt, atsvaidzināt, pārdēvēt, vai ko ne. 

Un es varētu vienkārši izdzēst, un tas iet prom. Bet pieņemsim darīt lietas ar komandu line tagad, lai saņemtu apmierināti ar šo, un darīt šādi. Es iešu uz priekšu un izņemiet a.out ierakstot burtiski rma.out. Izrādās, ka komandu likvidējot vai dzēšot kaut, nav noņemt vai izdzēst. 

Tas ir vairāk kodolīgi RM, tikai, lai ietaupītu jūs daži keystrokes, un hit Enter. Tagad mēs spēsim būt nedaudz cryptically noņemt regulāru failu a.out. Man nav īsti zināt, ko neregulāra fails būtu vēl. Bet es gribu, lai to noņemtu. 

Tāpēc es esmu gatavojas rakstīt y uz Jā. Vai es varētu ierakstīt to ārā, un hit Enter. Un atkal, nekas, šķiet, notiek. Bet tas ir, parasti, ir laba lieta. 

Ja es tipa LS šoreiz, ko man vajadzētu redzēt? Cerams, vienkārši sveiki un hello.c. Tagad, kā malā, jūs pamanīt šo zvaigzni, zvaigznīti, kas ir beigās manas programmas. Un viņi arī rāda uz augšu zaļā krāsā. Tas ir tikai CS50 IDE veids, no cluing tevi faktu ka tas nav pirmkods. Tas ir izpildāmā A skrienams programma, ka jūs faktiski var palaist darot dot slīpsvītra, un tad tas ir nosaukums. 

Tagad, ļaujiet man iet uz priekšu un izņemiet Tas, rm hello, Enter, noņemt regulāru failu hello, jā. Un tagad, ja es tipa LS, mēs esam atpakaļ uz hello.c. Izmēģiniet nedrīkst izdzēst savu faktiskais pirmkodu. Pat tad, ja ir pazīmes, iebūvēts CS50 IDE kur jūs varat iet caur jūsu pārskatīšanas vēsturi un ar laiku attīt ja jūs nejauši izdzēst kaut ko, esiet piesardzīgs kā uz šiem liek jā vai nē, par to, ko jūs tiešām vēlaties to darīt. Un, ja es iet uz augšu uz augšu kreisajā stūrī šeit, viss, kas paliek, ir hello.c. Tātad tur ir ķekarus citas komandas, kas jums var izpildīt pasaulē Linux, viens no tiem ir, atkal, Make. Un mēs ejam padarīt mana programma tagad šādi. 

Tā vietā, lai dara šķindēt, nevis uz šķindēt-o, Es esmu gatavojas vienkārši burtiski tips, veikt Sveiki. Un tagad paziņojums, es esmu ne rakstīt padarīt hello.c. Es rakstīt darīt Sveiki. 

Un šī programma Make ka nāk ar CS50 IDE, un vairāk parasti ar Linux, ir programma, kas ir gatavojas veikt programmu, ko sauc Sveiki. Un tas notiek, lai pieņemt, pēc vienošanās, ka, ja šī programma var tikt veikta, tas būs jāizdara no avota kods failu beidzas dot c, hello.c. 

Tātad, ja es hit Enter tagad, paziņojis, ka komanda, kas izpaužas izpildīts faktiski pat ilgāk Pirms nekā agrāk. Un tas ir tāpēc, ka mēs esam iepriek CS50 IDE ir dažas papildu funkcijas uzcelta, ka mums nevajag tikai vēl, bet drīz būs. Bet galvenais lieta saprast tagad man ir Sveiki programmu. 

Ja es tipa LS atkal, es ir hello programmu. Un es varu palaist to ar dot slash a.out, nē, jo viss punkts tas vingrinājums bija dot slash sveiki. Un tagad man ir mana Sveika, pasaule. Tātad virzās uz priekšu, mēs esam gandrīz vienmēr ir tikai gatavojas sastādīt mūsu programmas izmantojot komandu Marka. Un tad mēs ejam, lai palaistu tos dot slīpsvītra, un programmas nosaukumu. Bet saprast, kas darīt ir dara tu, ir tas pats nav kompilatoru. Tas ir tikai ērtības programma kas zina, kā izraisīt kompilators palaist, lai jūs pats varat to izmantot. 

Kādas citas komandas pastāv Linux, un, savukārt, CS50 IDE? Mēs drīz redzēt, ka tur ir CD komandu, Mainīt Directory. Tas ļauj jums laikā Jūsu komandrindas interfeisu virzīties uz priekšu, un atpakaļ, un atvērt dažādas mapes neizmantojot peli. 

LS mēs redzējām, kas apzīmē sarakstu faili pašreizējā direktorijā. Padarīt Dir, jūs varat iespējams sākt secināt ko tie nozīmē now-- veikt direktoriju, ja jūs vēlaties, lai izveidotu mapi. RM par noņemt RM Dir par noņemt directory-- un tie, atkal, ir komandrindas ekvivalenti, ko jūs varētu darīt CS50 IDE ar peli. Bet jūs ātri atrast ka dažreiz tas ir tikai daudz ātrāk darīt lietas ar klaviatūru, un galu galā daudz spēcīgāks. 

Bet tas ir grūti apgalvot, ka kaut ko mēs esam darījuši līdz šim ir viss, kas spēcīgs, kad visi mēs esam bijuši saku ir, hello pasaule. Un, patiesībā, es hardcoded vārdi sveiki pasaules manā programmā. Nav dinamika vēl. Scratch bija par kārtu interesantāku pagājušajā nedēļā. 

Un tāpēc pieņemsim tur nokļūt. Paņemsim solis, ka līdz veids, kā dažas no šīm funkcijām. Tātad ne tikai C nāk ar printf, un ķekarus citas funkcijas daži no kuriem mēs redzēsim laika gaitā, tā nav padara to tik vienkārši labi out no vārtiem iegūt lietotāja ievadi. 

Patiesībā, viens no trūkumiem Valodu, piemēram, C, un pat Java un vēl citi, ir tas, ka tā nav padara to viegli, lai tikai iegūtu lietas, piemēram, veseli skaitļi no lietotājiem, vai virknes, vārdiem, un frāzes, nemaz nerunājot par lietām, piemēram, peldošā punkta vērtības vai reāliem skaitļiem ar cipariem aiz komata, un tiešām ilgi numurus, kā mēs drīz redzēt. Tātad šis saraksts funkcijas šeit, šie ir līdzīgi citiem Scratch puzzle gabalus ka mēs esam iepriekš uzstādītas CS50 IDE, ka mēs izmantosim uz pāris nedēļām kā mācību riteņiem veidu, un beidzot ņemt tos off, un izskatās zem motora pārsega, iespējams, pie kā šīs lietas tiek īstenotas. 

Bet, lai to izdarītu, pieņemsim faktiski uzrakstīt programmu. Ļaujiet man iet uz priekšu tagad. Un es esmu gatavojas, lai izveidotu jaunu failu, noklikšķinot uz šo maz plus, un noklikšķinot jaunu failu. 

Es esmu gatavojas, lai saglabātu šo nākamo viens, kā, teiksim, string.c, jo es gribu spēlēt ar stīgām. Un stīgu C ir tikai rakstzīmju sekvence. Tāpēc tagad iesim uz priekšu un darīt šādi. 

Iekļaut standarta IO.h-- un izrādās standarta IO, IO nozīmē tikai ieejas un izejas. Tātad izrādās, ka šī līnija šeit ir tas, ko ir kaimiņu mums izmantot printf. Printf, protams, ražo produkciju. Tātad, lai izmantotu printf, izrādās out jums ir, lai šo rindiņu kodu augšpusē jūsu failu. 

Un mēs būsim atpakaļ uz to, ko tas tiešām nozīmē pirms ilgi. Izrādās, ka jebkurš C programma man rakstīt, Man, lai sāktu to ar kods, kas izskatās šādi. Un jūs pamanīsiet CS50 IDE, un cita integrēta attīstība vidēm, piemēram, to, gatavojas izmēģināt, kā vislabāk viņi var pabeigt savu domu. Patiesībā, pirms brīža, ja es atsaukt ko es tikko darīju, es hit Enter. 

Tad es hit atvērtu cirtaini lencēm, hit Enter vēlreiz. Un tas gatavo mana doma. Tas deva man jaunu līniju, izrobota ne mazāk jauku stilistisko iemeslu dēļ mēs redzēsim. Un tad tas automātiski man iedeva ka cirtaini lencēm, lai pabeigtu manu domu. Tagad tas ne vienmēr uzminēt, ko jūs vēlaties darīt. Bet liela daļa, tā dara saglabātu jums dažas keystrokes. Tātad pirms brīža, mums bija šis program-- hello, pasaule, un pēc tam apkopo to, un tad skrēja to. Bet tur nav dinamisms šeit. Ko darīt, ja mēs vēlējāmies darīt kaut ko citu? Nu, ko, ja es gribēju, lai faktiski saņemt virkni no lietotāja? Es esmu gatavojas izmantot puzzles gabaliņam sauc tieši that-- saņemt virkni. 

Izrādās, C, ka, ja jūs nevēlaties sniegt ieguldījumu puzzle gabals, vai pareizāk uz funkciju, jums burtiski vienkārši darīt atvērtu iekavu, close iekavas. Tātad, tas ir tā, it kā tur ir nav balta kaste ievadīts. Say bloks pirms bija mazliet balta kaste. Mums nav, ka balta kaste tagad. 

Bet, kad es aicinu get virkni, es gribu, lai rezultātu kaut kur. Tik ļoti bieži paradigma C ir zvanu funkciju, piemēram, get virkni šeit, un pēc tam uzglabāt savu atgriešanās vērtību. Tas ir rezultāts tās pūles kaut ko. 

Un kāda ir būvēt plānošanā, vai nu nulles vai nu C, ka mēs var izmantot, lai faktiski saglabātu kaut ko? Sauc to mainīga, vai ne? Un nulles, mums nav īsti vienalga, kas notiek ar mainīgajiem. 

Bet šajā gadījumā, mēs faktiski darīt. Es esmu gatavojas teikt virkni. Un tad es varētu zvanīt Tas kaut ko es gribu. Es esmu gatavojas to nosaukt nosaukums, izpaužas saņemt virkni. 

Un tagad, pat ja tu esi maz jauni, paziņojums, ka es esmu trūkst dažas detaļas. Es esmu aizmirstot semikolu. Man vajag, lai pabeigtu šo domu. Tāpēc es esmu gatavojas pārvietot savu kursoru, un hit semikolu tur. Un ko es esmu tikko darījis? Šajā rindā kodu, numurs 5 brīdī, Es esmu aicinot get virkne ar bez ieejas. Tāpēc nav maz balts kaste patīk Save bloks ir. 

Es tikai saku, hey, dators, atnesiet man virkni. Vienādības zīme nav īsti vienādības zīmi, per se. Tas ir uzdevums operators, kas nozīmē, hey, datoru, pārvietot vērtību no tiesības pār pa kreisi. Un pa kreisi, man ir šādas. 

Hey, dators, man string-- rakstzīmju sekvence. Un aicinu šo String nosaukums. Un man pat nav, lai izsauktu to nosaukums. 

Es varētu to nosaukt, parasti, kaut kā S, līdzīgi mēs izmantojām i, lai zvaniet mainīgais i. Bet tagad man ir nepieciešams kaut ko darīt ar to. Tas būtu diezgan stulba izmēģināt šo kodu apkopojot, darbojas šī programma, lai gan Es saņemu virkni, jo tas joprojām ir tikai gatavojas teikt sveiki pasauli. 

Bet ko tad, ja es vēlos to mainīt. Kāpēc man darīt? Procenti s, komats s. Un tas ir nedaudz mistisks joprojām. 

Tāpēc ļaujiet man manu mainīgie vairāk skaidrs. Ļaujiet man nosaukt šo mainīgā nosaukums. Un pieņemsim redzēt, ja mēs nevaram kaitināt izņemot to, kas notiek šeit. 

Tātad uz līnijas pieci, es saņemu virkni. Un es esmu glabāšanai šo virkni, kāds lietotājs ir ievadījis viņa vai viņas klaviatūras, ar mainīgo sauc vārds. Un izrādās, ka printf nav tikai veikt vienu argumentu dubultā citātus, viens ievades dubultās pēdiņas. 

To var veikt divus, vai trīs, vai vairāk, piemēram, ka otrais, vai trešais, vai ceturtais, ir visi vārdi mainīgajiem, vai konkrēti vērtības, ka jūs vēlaties, lai kontaktdakšu, dinamiski, ka virkne pēdiņās. Citiem vārdiem sakot, tas, ko Būtu nepareizi ar šo? Ja es tikko teicu sveiki nosaukums, reversā slīpsvītra n, izglāba manu failu, apkopoti manu kodu, un skrēja tas, kas notiktu? 

Tas ir tikai gatavojas teikt, sveiki nosaukt, burtiski N-A-M-E, kas ir sava veida stulba, jo tas neatšķiras no pasaules. Tātad kaut pēdiņās ir ko burtiski tiek drukāts. Tātad, ja es gribu būt vietturis tur, Man tiešām ir nepieciešams, lai izmantotu dažas īpašas sintakse. Un izrādās, ja jūs lasīt dokumentācija printf funkciju, tas jums pateiks, ka ja jūs izmantojat procentiem s, Jūs varat aizstāt vērtību šādi. 

Pēc komats pēc tā dubultā quote, jūs vienkārši uzrakstīt nosaukumu mainīgais, ka vēlaties iespraudiet minētajā formātā kodu vai formātā apzīmētājs, procenti s stīgas. Un tagad, ja es esmu saglabājis manu failu, Es dodos atpakaļ uz leju, lai manu terminālu. Un es tipa Make String, jo, atkal, sauc šo failu, es izvēlējos pirms ir string.c. 

Tāpēc es esmu gatavojas teikt Make String, ievadiet. Ak mans Dievs, apskatīt visas kļūdas mēs esam padarījuši jau. Un tas is-- ko, tas ir patiešām kā sešus, septiņus līnija programma? Tātad, tas ir, ja tā var ļoti ātri iegūt milzīgs. 

Šī termināla logs ir tagad tikai regurgitated milzīgs skaits kļūdu ziņojumus. Protams, man nav lielāka kļūda ziņas nekā es koda rindiņas. Tātad, kas notiek? 

Nu, labākā stratēģija darīt jebkurā laikā jums do sastopas pārliecinošu saraksts, kļūdas, piemēram, ka, ir ritināt atpakaļ, meklēt komandu jūs vienkārši skrēja, kas manā gadījumā ir veikt virkni. Paskaties, kas padara to darīja, un tas, ka garš šķindēt komandu, nav liels darījumu tur. 

Bet sarkanā ir slikti. Zaļā ir cenšas būt maigs un izpalīdzīgi. Bet tas joprojām ir slikti, šajā gadījumā. Bet kur tas ir slikti? 

String.c, līnija pieci, raksturs pieci. Tātad tas ir tikai kopīgs konvencija. Kaut kolu kaut nozīmē line skaits un raksturs numurs. Kļūda, izmantošana nedeklarētu identifikators virkne. Vai jūs domājāt standartu? 

Tātad, diemžēl, šķindēt cenšas būt noderīga. Bet tas ir nepareizi, šajā gadījumā. Nē, šķindēt, es nenozīmē standarta IO. Es nozīmēja, ka uz līnijas vienā, jā. 

Bet līnija pieci tas ir viens šeit. Un šķindēt nav saprast S-T-R-I-N-G. Tas ir nedeklarētu identifikators A vārds tas vienkārši nekad nav redzējis. Un tas ir tāpēc, ka C, valoda mēs rakstiski kodu tieši tagad, nav mainīgos sauc stīgas. 

Tas nav, pēc noklusējuma, atbalstu kaut ko sauc virkni. Tas ir CS50 gabals žargons, bet ļoti parasto. Bet es varu noteikt šo šādi. 

Ja es pievienot vienu rindiņu kodu uz augšu no šīs programmas, ietver CS50.h, kas ir vēl viens fails kaut kur iekšpusē CS50 IDE, kaut kur uz cietā diska, tā sakot, no Ubuntu operētājsistēmas ka es skrienu, ka ir fails, kas ir gatavojas mācīt apkalpojošā Sistēma, ko string ir, tikai piemēram, standarta io.h ir fails operētājsistēmu, kas ir gatavojas mācīt to, ko printf ir. 

Patiesi, mēs esam gotten ļoti līdzīga ziņa ja IO atzina standarts IO.h un centās izmantot printf. Tāpēc es esmu gatavojas iet uz priekšu un tikai Veikt kontroli L, lai notīrītu manu ekrānu. Vai arī jūs varat ierakstīt skaidrs, un tas būs vienkārši notīrīt termināļa logu. Bet jūs joprojām varat ritināt atpakaļ laikā. 

Un es esmu gatavojas atkārto Make String. Šķērsot mani pirksti šoreiz, Enter. Ak mans Dievs, tā strādāja. tas liecina man ilgu noslēpumains komandu tas ir tas, kas padara radīts caur šķindēt, bet ne kļūdu ziņojumus. Tātad realizēt, kaut gan jūs varētu saņemt pilnīgi nomākti ar skaits kļūdu ziņojumus, tas tikai varētu būt šo kaitinošas kaskādes efekts, kur šķindēt nesaprot viena lieta, kas nozīmē, ka pēc tam nesaprot nākamo vārdu, vai nākamajā rindā. Un tā tas vienkārši droseles uz jūsu kodu. Bet fix varētu būt vienkārši. Un tā vienmēr koncentrēties uz Pati pirmā līnija produkciju. Un, ja jums nav saprotu, paskatieties atslēgvārdus, kas varētu būt clues, un līniju skaits, un raksturs, kur ka kļūda varētu būt. 

Tagad ļaujiet man iet uz priekšu un ievadiet dot slash, stīgu, ievadiet. Hm, tas nav saprotams, sveiki neko. Kāpēc? Nu, atceros, kur tas darbojas? 

Tas ir iespējams, iestrēdzis brīdī pa apli, ja jūs, uz sešiem līniju, jo Saņemt String dizains, raksta CS50 darbinieki, ir burtiski domāts, lai tikai sēdēt tur gaida, un gaida, un gaida virkni. Viss, ko mēs saprotam ar auklu ir cilvēka ieejas. Tātad, jūs zināt, ko? Ļaujiet man iet uz priekšu. Un tikai par kaprīze, ļaujiet man ierakstīt savu vārdu, David, ievadiet. Tagad man ir daudz dinamisku programmu. Tā teica, sveiki David. 

Ja es iet uz priekšu un palaist to atkal, ļaujiet man mēģināt pateikt Zamila vārdu, ievadiet. Un tagad mums ir dinamiska programma. Man nav grūti kodēta pasauli. Man nav grūti kodēta nosaukt, vai David, vai Zamila. 

Tagad tas ir daudz vairāk, piemēram, programmu mēs zinām, kur, ja tas veic ieguldījumu, tas rada nedaudz atšķirīgu produkciju. Tagad tas nav labākais lietotāju pieredzi, vai UX. Es palaist programmu. 

Es nezinu, ko es esmu vajadzēja ko darīt, ja es tiešām apskatīt vai atcerēties pirmkodu. Tātad, pieņemsim padarīt lietotājam piedzīvot mazliet labāk ar vienkāršāko lietas. Ļaujiet man iet atpakaļ uz šo programma, un vienkārši teikt printf. 

Un ļaujiet man iet uz priekšu un teikt vārdu, kolu, un telpa, un pēc tam daļēji resnās zarnas. Un tikai sākas, ne negatīvu reakciju n. Un tas ir apzināta, jo es nevēlos ātru, lai pārietu uz nākamo rindiņu. 

Es gribu, tā vietā, to izdarītu, virkni recompile manu kodu jaunās mašīnas kods dot slīpsvītra virkni. Ah, tas ir daudz prettier. Tagad es tiešām zinu, ko dators grib, lai es daru, arī tā nosaukumu. 

Tāpēc es esmu gatavojas iet uz priekšu un ievadiet in Rob, ievadīt, un sveiki, Rob. Tātad, jāsaprot,, tas joprojām ir, beigās no dienas, tikai deviņi līnijas programmā. Bet mēs esam veikuši šīs bērnu pasākumus. 

Mēs rakstījām vienu līniju, ar kuriem mēs bija pazīstami, printf, hello pasaule. Tad mēs undid mazliet kas. Un mēs faktiski izmanto get virkni. Un mēs tossed šo vērtību mainīgā. Un tad mēs devāmies uz priekšu un uzlabota tā tālāk ar trešo pozīciju. Un šis iteratīvs process rakstīšanas programmatūru ir patiesi svarīgs. In CS50, un dzīvē kopumā, Jums nevajadzētu sēdēt, ir programma prātā, un mēģināt rakstīšana viss nopelt lieta visu uzreiz. 

Tas neizbēgami izraisīs veidā vairāk kļūdas nekā mēs paši redzēja šeit. Pat es, līdz šai dienai, pastāvīgi veikt citas stulba kļūdas, faktiski grūtāk kļūdas kas ir grūtāk izdomāt. Bet jums dos vairāk kļūdas vairāk rindas kods rakstīt visu uzreiz. Un tāpēc šī prakse, uzrakstīt mazliet koda ka jūs esat apmierināti ar, apkopot tas, palaist to, pārbaudītu to kopumā, tad pāriet on-- tāpēc, tāpat kā mēs tur layering un layering pagājušajā nedēļā, ēkas no kaut ko ļoti vienkārši kaut ko sarežģītāku, darīt to pašu šeit. Ne apsēsties, un mēģināt uzrakstīt visu problēmu. Faktiski veikt šos bērnu pasākumus. 

Tagad, stīgas ir ne visi lietderīgu unto sevi. Mēs gribētu tiešām, ideāli, tāpat kā ir kaut kas cits mūsu rīkkopa. Tātad, pieņemsim faktiski darīt tieši to. 

Ļaujiet man iet uz priekšu tagad un sakult nedaudz atšķirīga programma. Un mēs saucam par int.c, lai skaitlim. Es esmu gatavojas, līdzīgi, ietver CS550.h. Es esmu gatavojas iekļaut standarta IO. Un tas būs diezgan bieži šajās pirmajās dienās klasē. 

Un es esmu gatavojas gatavs sevi ar galveno funkciju. Un tagad tā vietā iegūt virkni, iesim uz priekšu un iegūt int. Sauksim to es, un sauc to saņemt int, tuvu Parens, semikols. Un tagad pieņemsim do kaut kas ar to, printf. 

Pieņemsim, ka kaut ko līdzīgu hello, slīpsvītru n, komats i. Tāpēc es esmu diezgan daudz atdarinot ko es darīju tikai pirms brīža. Man ir vietturi šeit. Esmu Comma esmu šeit, jo es gribu plug i minētajā vietturi. 

Tātad, pieņemsim iet uz priekšu un mēģināt Sastādot šo programmu. Fails sauc int.c. Tāpēc es esmu gatavojas teikt, padarīt int, ievadiet. Ak mans Dievs, bet nav liels galā, vai ne? Tur ir kļūda. 

Tur ir sintakses kļūda šeit tāds, ka programma nevar jāapkopo iekšpusē int.c, līniju septiņi, raksturs 27, kļūda formāts precizēts tipa char zvaigzne, kāds tas ir. Bet arguments tips ir int. 

Tātad arī šeit, mēs nebrauksim kuri paredzēti, lai gan šodien ir daudz materiāla, mēs spēsim apbērt jums ar absolūti katrs iezīme C, un programmēšana kopumā, tikai šajās pirmajās nedēļās. Tātad tur ir bieži būs žargons ar kuru jūs neesat pazīstami. Un, patiesībā, char zvaigzne ir kaut kas mēs spēsim atgriezties pēc nedēļas vai divām laikā. 

Bet tagad, pieņemsim redzēt, ja mēs varam apstrādāt vārdus, kas ir pazīstami. Formats-- tāpēc mēs dzirdējām formātā apzīmētājs, formāta kods pirms. Tas ir pazīstams. Type-- bet arguments ir tipa int. Pagaidiet minūti, man ir int. 

Varbūt procenti s faktiski ir dažas definētā nozīmē. Un, protams, tā dara. Vesels skaitlis, ja vēlaties printf aizstāt to, Jums tiešām ir izmantot atšķirīga formāta noteicēju. Un jūs nezināt ja vien kāds teicis, vai jums bija darījuši līdz šim. Bet procenti i ir tas, ko var parasti izmanto in printf par tapām veselam skaitlim. Jūs varat arī izmantot procentiem d par decimālo skaitlim. Bet es ir jauka un vienkārši šeit. Tātad mēs iet ar to. 

Tagad ļaujiet man iet uz priekšu un atkārto make int, Enter. Tas ir labi, nav kļūdu. Dot slash int-- OK, slikta lietotāja pieredzi, jo es neesmu sev teicu ko darīt. Bet tas ir jauki. Es esmu iepatikusies ātri. 

Un tagad ļaujiet man iet uz priekšu un ierakstiet Dāvidu, OK, Zamila, Robs. Labi, tāpēc šī ir laba lieta. Šoreiz, es esmu, izmantojot funkciju, puzzle gabals, ko sauc get int. Un izrādās out-- un mēs redzēt šo vēlāk term-- CS50 darbinieki ir īstenojusi saņemt string tādā veidā, ka tas būs tikai fiziski iegūt virkni jums. 

Tā ir īstenojusi get int in tādā veidā, ka tas būs tikai iegūt skaitlis jums. Un, ja jūs, cilvēka, nesadarbojas, tas ir burtiski tikai gatavojas saka vēlreiz, vēlreiz, vēlreiz, burtiski sēdēja tur looping, līdz tu liktu ar kādu burvju numuru, piemēram, 50, un sveiki 50. 

Vai, ja mēs palaist šo atkal un ierakstiet 42, hello 42. Un tā get int funkcija iekšpusē šo puzzle gabals ir pietiekami loģika, pietiekami doma, izdomāt, kas ir vārds? Un kas ir numurs? Tikai pieņemot, galu galā, skaitļi. 

Tātad izrādās, ka šis nav tik izteiksmīga. tik tālu. Tātad, Yay, pēdējo reizi mēs gāja diezgan ātri jāiekļauj īstenošanas spēles, un animācijas, un mākslas darbi nulles. Un šeit, mums tiek saturs ar Hello World, un sveiki 50. 

Tas vēl nav viss, kas iedvesmo. Un, protams, tie vispirms maz piemēri prasīs kādu laiku rampas līdz uztraukums. Bet mums ir tik daudz vairāk kontrolēt tagad, patiesībā. Un mēs ejam uz ļoti ātri sākt izkārtojums virsū šiem pamata primitīvi. 

Bet vispirms, pieņemsim saprast kādi ierobežojumi. Patiesībā, viena no lietām, Scratch nav viegli darīsim tiešām izskatās zem motora pārsega, un saprast, ko dators ir, ko tā var darīt, un kādi ir tās ierobežojumi. Un, protams, ka trūkums izpratne, iespējams, ilgtermiņa var novest pie mūsu pašu mistakes-- rakstiski bugs, rakstot nedroši programmatūru, kas izpaužas ielauzies kādā veidā. 

Tātad pieņemsim veikt dažus soļus Saprotot to mazliet labāk, veids, teiksim, šādu piemēru. Es iešu uz priekšu un īstenot nekustamo ātri programma, ko sauc papildinātājs. Tāpat kā, pieņemsim pievienot dažus numurus kopā. Un es esmu gatavojas kodu dažas stūriem šeit, un vienkārši kopēt un ielīmēt kur es biju agrāk, tikai lai mēs varētu iegūt notiek ātrāk. Tāpēc tagad es esam ieguvuši pamata sākumu par programmu, ko sauc papildinātājs. 

Un iesim uz priekšu un darīt to. Es iešu uz priekšu un teiksim, intx izpaužas saņemt int. Un jūs zināt, ko? Veidosim labāku lietotāja pieredzi. 

Tāpēc pieņemsim tikai teikt x ir, un efektīvi nekavējoties lietotājam, lai dotu mums x. Un tad ļaujiet man iet uz priekšu un saka, printf Kā par y ir, šoreiz cerot divas vērtības no lietotāja. Un tad pieņemsim tikai iet uz priekšu un teiksim, printf, tad par x un y summa ir. Un tagad es nevēlos darīt procentiem s. Es gribu darīt procentiem i, reversā slīpsvītra n, un pēc tam plug summas vērtības. 

Tātad, kā es varu iet par to izdarīt? Tu zini ko? Es zinu, kā izmantot mainīgos. Ļaujiet man tikai pasludināt jaunu, int z. 

Un es esmu gatavojas veikt minējums šeit. Ja ir vienādas zīmes šis valoda, varbūt es vienkārši varu darīt x plus y, tik ilgi, kamēr es galu mana domāju ar semikolu? Tagad es varu iet atpakaļ uz leju šeit, pievienojiet z, pabeigt šo domu ar semikolu. Un pieņemsim redzēt tagad, ja tie sekvences lines-- x ir iegūt int. Y ir iegūt int. 

Pievieno x un y, uzglabāt vērtību z-- tā, atkal, atcerieties vienādības zīmi nav vienāds. Tas ir uzdevums no labās uz kreiso. Un pieņemsim izdrukāt ka summa no X un Y nav burtiski Z, bet to, kas ir iekšā z. Tātad, pieņemsim padarīt papildinātāja - jauki, nav kļūdu šoreiz. Dot slash papildinātāja, ievadiet, x būs 1. 

Y būs 2. Un pie tam x un y summa ir 3. Tā ka viss ir labi un labs. 

Tātad jūs varētu iedomāties, ka matemātiku jāstrādā programmu, kā šis. Bet jūs zināt, ko? Vai tas ir mainīgs, līnija 12, pat nepieciešams? Jums nav nepieciešams, lai nokļūt ieradumos no vienkārši uzglabātu lietas mainīgajiem tikai tāpēc, ka tas ir iespējams. Un, patiesībā, tas ir vispār uzskatīts par sliktu dizains ja jūs veidojat mainīgais, ko sauc z šajā gadījumā, uzglabājot kaut ko tā, un tad uzreiz to izmanto, bet nekad atkal. Kāpēc dot kaut vārdu tāpat z ja jūs burtiski gatavojas izmantot ka lieta tikai vienu reizi, un tā proksimāls kur jūs izveidojāt tas, pirmkārt, tik tuvu ziņā koda rindiņas? Tātad, jūs zināt, ko? Izrādās, ka C ir diezgan elastīgs. Ja es tiešām gribu plug-in vērtībām šeit, Man nav nepieciešams deklarēt jaunu mainīgo. Es varētu tikai plug-in x plus y, jo C saprot aritmētika, un matemātiskās uzņēmēji. 

Tāpēc es varu vienkārši pateikt, darīt math, x plus y, kāds šīs vērtības ir, plug rezultātā skaitlis vērā, ka virknē. Tātad tas varētu būt, lai gan tikai viena līnija īsāks, labāks dizains, labāka programma, jo tur ir mazāk kodu, tāpēc mazāk man saprast. Un tas ir arī tikai tīrāku, ciktāl mēs neesam ieviešot jaunus vārdus, jauni simboli, piemēram, z, pat ja tie nav īsti kalpot daudz mērķiem. 

Diemžēl, matemātika nav viss, kas uzticami dažreiz. Iesim uz priekšu un darīt to. Es iešu uz priekšu tagad un darīt šādi. 

Darīsim printf, procenti i, plus procenti i, jābūt procenti i, reversā slīpsvītra n. Un es esmu gatavojas darīt this-- xyx plus vec. Tāpēc es esmu tikai gatavojas pārrakstīt Tas nedaudz atšķirīgi šeit. Ļaujiet man tikai darīt ātri veselība pārbaudītu. Atkal, pieņemsim nav get priekšā sevi. Padarīt papildinātājs, dot slash papildinātājs. x ir 1, y ir 2, 1 plus 2 ir 3. Tātad tas ir labi. Bet pieņemsim sarežģīt šo tagad mazliet, un izveidot jaunu failu. 

Es esmu gatavojas, lai izsauktu šo vienu, saka, Ints, daudzskaitļa par veseliem skaitļiem. Ļaujiet man sākt, kur es biju pirms brīža. Bet tagad pieņemsim darīt dažas citas līnijas. Ļaujiet man iet uz priekšu un darīt šādu, printf, procenti i, mīnus procenti i, ir procenti i, komats x, komats YX mīnus y. Tāpēc es esmu dara nedaudz atšķirīgs math tur. Darīsim vēl vienu. Tātad procenti i reizes procentiem i ir procenti i, reversā slīpsvītra n. Let 'plug-in x, un y, un ar x reizes y. Mēs izmantosim zvaigznīti uz Jūsu dators reizes. 

Jūs neizmantojat x. x ir mainīgā vārds šeit. Jūs izmantojat zvaigzni uz vairošanos. Darīsim vienu vairāk. Printf Es procenti, sadalīta ar procentiem i, ir procenti i, reversā slīpsvītra n. xy dalīts ar y-- lai jūs izmantojat slīpsvītra C darīt sadalījumu. Un pieņemsim do vienu citu. Atlikušo procentiem i, sadalīta ar procentiem i, ir procenti i. xy-- un tagad atlikušo ir tas, kas ir palicis pāri. Kad jūs mēģināt dalot saucējs uz skaitītāju, cik daudz ir palicis pāri, ka jūs nevarētu sadalīt ārā? 

Tāpēc nav īsti, obligāti, simbols mēs esam izmanto pakāpē skolā par to. Bet tur C. Jūs varat teikt x modulo y, kur Šī procentu zīme šajā context-- sajaucami kad tu esi iekšā no dubultās pēdiņas, iekšpusē printf, procenti tiek izmantots kā formāta noteicēju. 

Kad jūs izmantot procentiem ārpus kas ar matemātisku izteiksmi, tas ir Modulo operators modulārās arithmetic-- par mūsu mērķiem šeit, tikai nozīmē, kāda ir atlikušo x dalot ar y? Tātad x dalot ar y ir x slīpsvītra y. Kas atlikušo x dalot ar y? Tas ir x mod y, kā programmētājs teiktu. 

Tātad, ja es nekādas kļūdas šeit, ļaujiet man iet uz priekšu un darīt Ints, daudzskaitlī, jauki, un dot Slīpsvītra Ints. Un iesim uz priekšu un darīt, teiksim, 1, 10. Labi, 1 plus 10 ir 11, pārbaude. 1 mīnus 10 ir negatīvs 9, pārbaudiet. 

1 reizes 10 ir 10, pārbaude. 1 dalīts ar 10 is-- Labi, mēs izlaist, ka viens. Atlikušo 1 dalīts ar 10 ir 1. Tas ir pareizi. Bet tur ir kļūda šeit. 

Tātad man manu nodot, nav pareizs. Es domāju, tas ir tuvu 0. 1 dalīts ar 10, jūs zināt, ja mēs esam griešana dažas stūriem, protams, tas ir nulle. Bet tas tiešām būtu 1/10, 0.1, vai 0.10, 0,1000, vai tā tālāk. 

Tas nav īsti būt nulle. Nu, izrādās, ka dators ir darot burtiski to, ko mēs teicis to darīt. Mēs darām math kā ​​x, dalot ar y. Un abi x un y, per līnijām kodu iepriekš, ir veseli skaitļi. 

Turklāt, on line 15, mēs esam stāsta printf, hey, printf plug-in vesels skaitlis, plug-in veselam skaitlim, plug-in ar integer-- īpaši x, un pēc tam y, un pēc tam x dalot ar y. x un y neatkarīgi ir Inta. Mēs esam labi tur. 

Bet kas ir x dala ar x? x dala ar y būtu, matemātiski, 1/10, vai 0.1, kas ir reāls skaitlis, reāls skaitlis kam, iespējams, komatu. Tas nav vesels skaitlis. 

Bet to, kas ir vistuvāk skaitlis 1/10 vai 0,1? Jā, tā veida ir nulle. 0.1 ir līdzīgs šim daudz. Un 1 tas ir daudz. Tātad 1/10 ir tuvāk 0, nekā tas ir viens. 

Un tā, kādi C dara par us-- veida jo mums pastāstīja kuri paredzēti, ir truncating šo skaitli. Tas ir ņemot vērtību, kas atkal ir vajadzēja būt kaut kas līdzīgs 0,1000, 0 un tā tālāk. Un tas ir viss truncating aiz komata tā, ka tas viss stuff, jo tas nav ietilptu jēdzienā veselam skaitlim, kas ir tikai skaitlis, piemēram, negatīvs 1, 0, 1, augšu un uz leju, tas met prom visu aiz komata, jo jums nevar fit komatu in veselam skaitlim pēc definīcijas. 

Tātad šeit atbilde ir nulle. Tātad, kā mēs varam noteikt šo? Mums ir nepieciešams cits risinājums visiem kopā. Un mēs varam darīt, ir šāda. 

Ļaujiet man iet uz priekšu un izveidot jaunu fails, šis viens sauc floats.c. Un saglabājiet to šeit pats katalogs, float.c. Un ļaujiet man iet uz priekšu un kopēt daži no šī kodeksa no agrāk. 

Bet tā vietā, kā iegūt int, pieņemsim darīt. Dodiet man peldošā komata vērtība sauc x. kur peldošā komata vērtība ir tikai burtiski kaut kas ar peldošo punktu. To var pārvietot pa kreisi, pa labi. Tas ir reāls skaitlis. 

Un ļaujiet man zvanu nav get int, bet saņemt peldēt, kas arī bija starp izvēlni no opcijām C250 bibliotēkā. Mainīsim y apgrozāmos līdzekļus. Tātad tas kļūst nokļūt peldēt. 

Un tagad, mēs negribam, lai kontaktdakšu ints. Izrādās, mums ir jāizmanto procentiem f par peldēt, procenti f uz peldēt, un tagad to saglabāt. Un tagad, īkšķus, padarīt pludiņiem, Nica, dot Slash pludiņi. x būs viens 1. y Būs 10 vēlreiz. 

Un, jauks, OK mans papildinājums ir pareizs. Es cerēju vairāk, bet es aizmirsu uzrakstīt to. So iesim un noteikt šo loģisko kļūdu. 

Iesim uz priekšu un paķert sekojošo. Mēs vienkārši darīt nedaudz kopēt un ielīmēt. Un es esmu gatavojas teikt mīnuss. 

Un es esmu gatavojas teikt reizes. Un es esmu gatavojas teikt dalās. Un es neesmu gatavojas darīt modulo, kas nav tik piederīgs šeit, dalot ar F, un reizes plus-- Labi, pieņemsim darīt atkal. 

Make pludiņiem, dot Slash pludiņiem, un 1, 10, and-- jauki, nē, OK. Tāpēc es esmu idiots. Tātad tas ir ļoti bieži datorzinātnēs padarīt stulba kļūdas, kā šis. 

Par pedagoģisko nolūkos, ko es patiešām gribēju darīt tika mainīt zinātni šeit līdz plus, mīnuss, pie reizes, un sadalīt, kā jūs cerams pamanīju šo uzdevumu laikā. Tāpēc tagad pieņemsim atkārtoti sastādīt šo programma, do DOT Slash pludiņi. 

Un trešo reizi, pieņemsim redzētu, vai tas atbilst manas cerības. 1, 10, ievadiet, jā, OK, 1000, dalīts ar 10.000, ir 0,100000. Un izrādās, mēs varam kontrolēt, cik daudz skaitļi ir pēc šiem cipariem aiz komata. Mēs tiešām būs. Mēs atgriezties pie tā. 

Bet tagad, patiesībā, math ir pareiza. Tātad, atkal, kāda ir takeaway šeit? Izrādās, ka C, ir ne tikai tikko strings-- un, patiesībā, tur nav īsti, jo mēs pievienot tos ar CS50 bibliotēku. Bet ir ne tikai Ints. 

Ir arī pludiņi. Un izrādās, ķekars citiem datiem veidi arī, ka mēs izmantosim pirms ilgi. Izrādās, ja jūs vēlaties viens raksturs, nevis rakstzīmju virkne, Jūs varat izmantot tikai char. 

Izrādās, ka, ja jūs vēlaties Bool, Būla vērtība, patiess vai nepatiess tikai, pateicoties CS50 bibliotēkā, mēs esam pievienots C ar bool datu tipu, kā arī. Bet tas ir arī klāt daudzas citas valodas, kā arī. Un izrādās, ka dažkārt jums vajag lielākus skaitļus, tad nāk pēc noklusējuma ar ints un pludiņiem. 

Un, patiesībā, dubultā ir skaitlis kas izmanto ne 32 biti, bet 64 biti. Un ilgi ilgi ir skaitlis, kas izmanto ne 32, biti bet 64 biti, attiecīgi, uz peldošo punktu vērtības un veseli skaitļi, attiecīgi. Tātad pieņemsim faktiski tagad redzēt šo darbībā. 

Es iešu uz priekšu šeit un sakult vienu citu programmu. Lūk, es esmu gatavojas iet uz priekšu un tie ietver CS50.h. Un ļaujiet man iet, iekļauj standartinformāciju IO.h. 

Un jūs pamanīsiet kaut ko funky notiek šeit. Tas nav krāsu kodēšanas lietas tāpat, kā tas bija agrāk. Un izrādās, tas ir tāpēc, I nav dota lieta faila nosaukumu. 

Es esmu dodas uz zvanu šo vienu sizeof.c, un hit Saglabāt. Un paziņojums, kas notiek ar manu ļoti balts kods pret šo melno fona. Tagad, vismaz tur ir daži violeta tur. Un tas ir sintakse iezīmēts. 

Tas ir tāpēc, ka, gluži vienkārši, es esmu pastāstīja IDE kāda veida failu tas ir, dodot tai nosaukumu, un īpaši faila paplašinājums. Tagad iesim uz priekšu un darīt to. Es iešu uz priekšu un ļoti vienkārši izdrukāt following-- Bool ir procenti LU. 

Mēs atgriezties ka tikai brīdi. Un tad es esmu gatavojas drukas izmērs Bool. Un tagad, tikai, lai ietaupītu pats kādu laiku, es esmu gatavojas darīt visu ķekars no tiem uzreiz. Un, konkrēti, es esmu gatavojas mainīt uz char un char. Tas viens, es esmu gatavojas mainīt lai dubultā un dubultā. 

Tas viens, es esmu gatavojas mainīt ar pludiņu un apgrozāmos līdzekļus. Tas viens, es esmu gatavojas pāriet uz int un int. Un tas viens, es esmu gatavojas jāmaina, lai ilgi ilgi. Un tas joprojām ņemot ilgu laiku, sen sen. 

Un tad, visbeidzot, es deva sevi par daudz, auklas. Izrādās, ka C, tur ir īpašais operators sauc lielums, kas ir burtiski gatavojas, kad skrien, pastāstiet mums par izmēru katrs no šiem mainīgajiem. Un tas ir veids, tagad, mēs varam savienot atpakaļ uz pagājušās nedēļas diskusiju Datu un pārstāvību. 

Ļaujiet man iet uz priekšu un apkopo lielums dot slīpsvītra lieluma. Un paskatīsimies. Izrādās, ka C, konkrēti par CS50 IDE, īpaši par operētājsistēma Ubuntu, kas ir 64-bit darba sistēma, šajā gadījumā, bool gatavojas izmantot vienu baitu telpu. Tas, kā tiek mērīta izmērs, ne bitos, bet bytes. Un atcerēties, ka viens baits ir astoņi biti. Tātad bool, pat ja jums tehniski tikai need a ir 0 vai 1, tas ir nedaudz izšķērdīgs kā mēs esam to īstenoja. Tas faktiski gatavojas izmantot visu byte-- lai visi nulles, ir iespējams visi tie, vai kaut kas tamlīdzīgs, vai tikai vienu 1 starp astoņiem bitiem. 

Char, tikmēr izmantota raksturs tāpat ASCII raksturs vienu pagājušajā nedēļā, būs viena rakstzīme. Un kas synchs līdzi mūsu jēdzienam tas ir ne vairāk kā 256 bits-- drīzāk, synchs līdz ar to ir ne ilgāk nekā 8 biti, kas dod mums tik daudz kā 256 vērtībām. Dubultā gatavojas ir 8 biti vai 64 bitiem. 

Pluds ir 4. Int ir 4. Ilgi, ilgi ir 8. Un virkne ir 8. Bet nav jāuztraucas par to. Mēs ejam, lai mizu atpakaļ šo slāni. Izrādās, stīgas var būt garāks par 8 baitiem. 

Un, protams, mēs esam rakstīts stīgas jau, hello pasaule, ilgāk nekā 8 baitiem. Bet mēs atgriezties ka tikai brīdi. Bet atņemt šeit ir šāds. 

Jebkurš dators ir tikai ierobežots summa atmiņas un telpā. Jūs varat tikai uzglabāt tik daudz failus uz jūsu Mac vai PC. Jūs varat uzglabāt tikai tik daudz programmas RAM darbojas uzreiz, vienmēr, pat ar virtuālo atmiņu, jo Jums ir ierobežots daudzums RAM. 

Un tikai, lai picture-- ja jūs nekad neesmu atvēra portatīvo datoru vai pasūtīt papildus atmiņu par datoru, jūs varētu nezināt, ka iekšpusē datora ir kaut kas izskatās mazliet kā šis. Tātad tas ir tikai kopīga uzņēmuma nosaukumu Crucial kas padara RAM datoriem. Un RAM ir, ja programmas dzīvot kamēr viņi darbojas. 

Tātad par katru Mac vai PC, ja jūs dubultā noklikšķiniet uz programmu, un tas paver, un tas paver kādu Word dokumentu vai kaut kas tāds, to uzglabā īslaicīgi RAM, jo RAM ir ātrāks nekā jūsu cietā diska, vai Jūsu cietvielu disks. Tātad, tas ir tieši tur, kur programmas iet dzīvot, kad viņi darbojas, vai ja faili tiek izmantoti. 

Tātad jums ir lietas, kas izskatās patīk šī iekšpusē jūsu klēpjdators, vai nedaudz lielākas lietas iekšpusē darbvirsmas. Bet galvenais ir jums ir tikai ierobežots skaits no šīm lietām. Un tur ir tikai ierobežots daudzums aparatūras sēž uz šī galda tiesības šeit. 

Tātad, protams, mēs nevaram uzglabāt bezgalīgi ilgi numuri. Un, tomēr, ja jūs domājat atpakaļ Skolas, cik cipari var jums ir labi no komata? Attiecībā uz šo jautājumu, cik cipari var Jums ir pa kreisi no komata? Tiešām, bezgalīgi daudz. 

Tagad mēs cilvēkiem varētu tikai zināt, kā izrunāt miljonus, un miljardi, triljoni, un quadrillion, un quintillion. Un es esmu stumšanas robežas mana understanding-- vai my-- es saprotu skaitļi, bet mans izruna numuriem. Bet viņi var saņemt bezgalīgi liels ar bezgala daudz cipariem pa kreisi vai pa labi no komata. 

Bet datori ir tikai ierobežots atmiņas apjoms, ierobežots skaits tranzistori A ierobežots skaits spuldžu iekšpusē. Tātad, kas notiek, kad jūs darbināt no vietas? Citiem vārdiem sakot, ja jums domāju, ka atpakaļ uz pagājušajā nedēļā kad mēs runājām par numuru paši attēlot binārā, pieņemsim, ka mēs esam ieguvuši tas 8-bit vērtība šeit. 

Un mums ir septiņi 1 s un vienu 0. Un domāju, ka mēs gribam pievienot 1 līdz šai vērtībai. Tas ir patiešām liels skaits tieši tagad. 

Tas ir 254, ja es atceros math no pagājušajā nedēļā labās. Bet ko tad, ja es mainu ka rightmost 0 līdz 1? Visa skaits, par Protams, kļūst astoņi 1 s. Tāpēc mēs joprojām esam labi. 

Un tas, iespējams, ir 255, lai gan atkarībā no konteksta tas patiešām varētu pārstāvēt negatīvs skaitlis. Taču vairāk par šo citā laikā. Tas uzskata, tāpat kā tas ir par augsta kā es varu paļauties. 

Tagad tas ir tikai 8 biti. Un mans Mac, protams, ir veids, kā vairāk nekā 8 biti atmiņā. Bet tas ir ierobežots. Tātad tas pats arguments attiecas, pat ja mēs būt vairāk no šīm tiem uz ekrāna. 

Bet kas notiek, ja tu esi glabāšanai šo numuru, 255., un jūs vēlaties saskaitīt 1 nedaudz lielāks? Jūs vēlaties, lai iet no 255 līdz 256. Problēma, protams, ir tas, ka, ja jums sākas skaitīšana nulles līmenī, piemēram, pagājušajā nedēļā, jūs nevarat rēķināties tik augsts kā 256, nemaz nerunājot par 257, nemaz nerunājot par 258, m jo tas, ko notiek, ja jūs pievienojat 1? Ja jūs veco pakāpē skolā pieeju, jūs varat ievietot 1 šeit, un tad 1 plus 1 ir 2, bet tas ir tiešām nulles, jūs veikt ar 1, veikt 1, veikt 1. Visas šīs lietas, šie 1 s, dodieties uz nulli. Un jūs likvidēt, jā, kā kāds norādīja, a 1 kreisajā pusē. Bet viss, jūs varat faktiski redzēt un fit atmiņā ir tikai astoņi 0 s, kas ir teikt, kādā brīdī, ja jūs, dators, mēģināju skaitot pietiekami augsts augšu, tu esi gatavojas aptīšanas, šķiet, nullei, vai varbūt pat negatīva numurus, kas ir pat mazāks par nulli. 

Un mēs varam veida redzēt šo. Ļaujiet man iet uz priekšu un rakstīt īsts ātri programma šeit. Ļaujiet man iet uz priekšu un rakstīt programma, ko sauc pārpildes. Iekļaut CS50.h, ietver standarta IO.h-- oh, Es tiešām neatbildētos manu sintakse izceļot. Tātad, pieņemsim saglabājiet to kā overflow.c. 

Un tagad int galvenais void-- un pirms ilgi, mēs atgriezties, lai izskaidrotu, kāpēc mēs turpinām rakstot int galvenais tukšumu. Bet tagad, pieņemsim tikai do tas, ņemot to par pašsaprotamu. Pieņemsim dot sev int, un sāktu to 0. 

Let 's tad darīt int i get zero-- patiesībā, pieņemsim do bezgalīgu cilpu un redzēt, kas notiek. Lai gan ir taisnība, tad pieņemsim izdrukāt n ir procenti i, slīpsvītru n, plug-in n. Bet, tagad, pieņemsim do n izpaužas n plus 1. 

Tātad, citiem vārdiem sakot, uz katru atkārtojuma šīs bezgalīga cilpa, pieņemsim n vērtību, un pievieno 1 līdz tam, un pēc tam uzglabāt rezultātu atpakaļ n pa kreisi. Un, patiesībā, mēs esam redzējuši sintakse nedaudz, piemēram, tas, īsumā. Cool triks ir vietā rakstot šo visu ārā, jūs faktiski var teikt par n plus ir vienāds ar 1. 

Vai, ja jūs patiešām vēlaties būt iedomātā, Jūs varat teikt n plus plus semikols. Bet šie pēdējie divi ir tikai ko mēs gribētu saucam sintakses cukurs Pirmo lieta. 

Pirmā lieta ir skaidrāk, pilnīgi naudas sodu, pilnīgi pareizs. Bet tas ir biežāk, es saku. Tāpēc mēs to izdarīt tikai brīdi. 

Pieņemsim tagad veikt pārplūdes, kas izklausās diezgan draudošs, dot slīpsvītra pārplūdes. Paskatīsimies, n kļūst diezgan liels. Bet Padomāsim, cik liels var n nokļūt? 

n ir vesels int. Mēs redzējām pirms brīža ar izmēru piemērs, ka int ir četri baiti. Mēs zinām no pagājušajā nedēļā, četri baiti ir 32 biti, jo 8 reizes 4, tas ir 32. Tas būs 4 miljardi. 

Un mēs esam līdz 800,000. Tas ir gatavojas veikt uz visiem laikiem, lai skaitīt tikpat augsta kā es, iespējams, var. Tāpēc es esmu gatavojas iet uz priekšu, Kā jūs varētu pirms ilgi, un hit Control C- atklāti, Control C, daudz, kur Control C parasti līdzekļi atcelt. Diemžēl, jo šis darbojas mākonis, dažreiz mākonis ir spitting veic tik daudz sīkumi, tik daudz produkcijas, tas notiek, lai aizņemt nedaudz, bet par manu ieguldījumu nokļūt uz mākoni. Tātad, pat ja es hit Control C dažas sekundes pirms, tas noteikti ir puse efekts bezgalīgu cilpu. 

Un tāpēc šādos gadījumos mēs esam gatavojas atstāt, ka būtu. Un mēs ejam, lai pievienotu citu termināla logu nekā šeit ar plus, kas, protams, dara ne piemēram, ka, tā kā tas joprojām domāšana. Un iesim uz priekšu un būt nedaudz vairāk saprātīgi. 

Es iešu uz priekšu un darīt Tas tikai finitely daudzas reizes. Pieņemsim izmantot cilpas, ko es norādīja uz agrāk. Izdarīsim to. Dodiet man citu mainīgo int i izpaužas 0. i ir mazāk nekā, teiksim, 64 i ++. Un tagad ļaujiet man iet uz priekšu un izdrukāt out n ir procenti i, komats n. Un tad N- tas joprojām ir gatavojas veikt uz visiem laikiem. Izdarīsim to. 

n izpaužas n reizes 2. Vai mēs varētu būt fancy un darīt laiki atbilst 2. Bet pieņemsim tikai teikt n vienāds pati, reizes 2. Citiem vārdiem sakot, šis Jaunā programmas versija, Es negribu gaidīt mūžīgi no, piemēram, 800000 līdz 4 miljardiem. Pieņemsim tikai iegūt šo pāri ar. 

Pieņemsim faktiski dubultā n katru reizi. Kurš, atgādināt, dubultošana ir pretī, kam, protams. Un tā kā pagājušajā nedēļā mums kaut kas atkal un atkal, un atkal, super ātri, dubultošana, protams, mūs no 1 līdz lielākais iespējamais vērtība, ka mēs varam paļauties uz ar int. 

Tātad, pieņemsim darīt tieši to. Un mēs būsim atpakaļ uz šo pirms ilgi. Bet tas, atkal, ir tāpat kā atkārtošanas bloks Scratch. Un jūs izmantot šo pirms ilgi. 

Tas tikai nozīmē, skaits no nulles līdz, bet ne vienāds, līdz 64. Un par katru atkārtojuma šīs cilpa, tikai glabāt palielināšanai i. Tāpēc es ++ - un tas vispār konstrukcija on line 7 ir tikai super kopīgs veids atkārtot dažas rindiņas kods, daži vairākas reizes. Kuras rindas kodu? Šie cirtaini bikšturi, kā jūs var būt gūta no tagad, nozīmē, rīkojieties šādi. 

Tas ir, piemēram, nulles, kad tas ir dzeltenās bloki un citas krāsas, kas veida apskāviens vai ķēriens citus blokus. Tas, ko šie curly bikšturi šeit darām. Tātad, ja es saņēmu savu sintaksi right-- tevi var redzēt burkānu simbolu C līdzekļiem tas, cik reizes es biju mēģina atrisināt šo problēmu. Tātad, pieņemsim atbrīvoties no ka viens vispār, un aizvērt šo logu. Un mēs izmantosim jaunu. Padarīt pārplūdes, dot slīpsvītru pārplūdes, Enter, labi, tas izskatās slikti sākumā. Bet pieņemsim ritināt atpakaļ laikā, jo man bija šo 64 reizes. 

Un paziņojums pirmo reizi, n ir 1. Otro reizi, n ir 2, tad 4, tad 8, tad 16. Un šķiet, ka, tiklīdz Es nokļūt aptuveni 1000000000, ja es dubultā to vēlreiz, ka būtu man 2 miljardus. Bet izrādās, tas ir tiesības uz smaile. 

Un tā tas tiešām pārplūšanas int no 1 miljardu līdz aptuveni negatīvs 2 miljardi, jo veselam skaitlim, atšķirībā no numuriem mēs Tika pieņemot pagājušajā nedēļā, var būt gan pozitīva, gan negatīva patiesībā un datorā. Un tā ir vismaz viens no tiem, biti efektīvi nozagts. Tātad mums tiešām ir tikai 31 biti, vai 2 miljardi iespējamās vērtības. 

Bet tagad, takeaway ir diezgan vienkārši, neatkarīgi šie skaitļi ir un neatkarīgi no math ir, kaut kas slikts notiek ar laiku, jo galu galā jūs mēģināt apmainīt bitiem viens pārāk daudz reižu. Un jūs faktiski iet no visiem 1 s līdz varbūt visi 0 s, vai varbūt tikai daži citi modelis, kas to skaidri, atkarībā no konteksta, var interpretēt kā negatīvu skaitli. Un tā tas varētu šķist augstāko I var rēķināties šajā konkrētajā programmā ir tikai aptuveni 1000000000. Bet tur ir daļējs risinājums šeit. Tu zini ko? 

Ļaujiet man mainīt no int lai ilgi ilgi. Un ļaujiet man iet uz priekšu šeit un say-- es esmu nāksies lai mainītu to neparakstīts garš. Vai arī, pieņemsim redzēt, es nekad sevi atceros. 

Iesim uz priekšu un veikt pārplūdes. Nē, tas nav tas, LLD, paldies. Tātad, dažreiz šķindēt var būt noderīgi. Man nav atcerēties, ko formātu Specifier bija ilgi ilgi. 

Bet, protams, šķindēt man teica. Zaļā ir sava veida labas, tomēr nozīmē, ka jūs kļūdījies. Tas ir guessing, ka es gribēju LLD. 

Tāpēc ļaujiet man izmantot, tas ir padoms, garš garš decimālskaitlis, saglabājiet to. Un ļaujiet man atkārto to, dot slash pārplūst, Enter. Un tagad to, kas ir cool tas ir. 

Ja es ritiniet atpakaļ laikā, mēs joprojām sākas skaitot tajā pašā place-- 1, 2, 4, 8, 16. Paziņojums, mēs visi ceļu līdz pat 1 miljardam. Bet tad mēs droši nokļūt līdz 2 miljardiem. 

Tad mēs līdz 4 miljardiem, tad 8000000000, 17000000000. Un mēs ejam augstāk, un augstāk, un augstāk. Galu galā, arī tas, pārtraukumiem. 

Galu galā, ar ilgi ilgi, kas ir 64-bit vērtība, kas nav 32 bitu vērtība, ja jūs skaits pārāk liels, jūs wrap ap 0. Un šajā gadījumā mēs gadās galu galā ar negatīvu skaitli. 

Tātad tā ir problēma. Un izrādās, ka šis Problēma nav tik arcane. Pat ja es esmu apzināti izraisīta to ar šīm kļūdām, izrādās, mēs to redzam veida visu mums apkārt, vai vismaz daži no mums darīt. 

Tātad Lego Star Wars, ja esat kādreiz spēlējis spēli, izrādās, jūs varat iet apkārt sadalīšana lietas pat LEGO pasaulē, un vācot monētas, būtībā. Un, ja jūs esat kādreiz spēlējis šī spēle pārāk daudz laika, kā šo nenosaukts indivīds šeit darīja, kopējo skaitu Monētu ka jūs varat savākt ir, šķiet, 4 miljardi. 

Tagad, līdz ar to patiesībā noapaļoti. Tātad LEGO centās saglabātu lietas lietotājam draudzīgi. Tie nav darīt to tieši no 2 līdz 32 jauda, ​​par pagājušajā nedēļā. Bet 4000000000 ir iemesls. Šķiet, balstoties uz šo informāciju, ka LEGO, un uzņēmums, kas padarījusi šo faktisko programmatūru, nolēma ka maksimālais skaits monētu lietotājs var uzkrāties ir, protams, 4000000000, jo viņi izvēlējās savā kodā izmantot ne ilgi ilgi, acīmredzot, bet tikai skaitlis, neparakstīts vesels skaitlis, tikai pozitīvs vesels skaitlis, kura max vērtība ir aptuveni ka. Nu, šeit ir vēl viens funny vienu. Tātad spēle Civilizācija, kas daži no jums varētu būt pazīstams, ar izrādās, ka pirms gadiem bija kļūda šajā spēlē, kurā ja tu spēlē lomu no Gandija spēlē, viņa vietā ir ļoti pacifists, vietā bija neticami, neticami agresīvs, dažos gadījumos. Jo īpaši, tā, ka Civilization darbi ir tas, ka, ja jūs, spēlētājs, pieņemt demokrātiju, jūsu agresivitāte rezultāts izpaužas decremented ar divi, tāpēc mīnus mīnus, un pēc tam mīnus mīnus. 

Tātad jūs atņemt 2 no jūsu faktisko atkārtojot. Diemžēl, ja jūsu atkārtojot ir Sākotnēji 1, un jūs atņemt 2 no tā pēc demokrātijas pieņemot kā Gandhi šeit varētu ir darīts, jo viņš bija ļoti passive-- 1 uz skalas agresivitātes. Bet, ja viņš pieņems demokrātiju, tad viņš iet no 1 līdz negatīva 1. 

Diemžēl, tie bija izmantojot neparakstītu numurus, kas nozīmē, ka tie apstrādāti pat negatīvs numuriem, it kā tie bija pozitīvas. Un izrādās, ka pozitīvs ekvivalents 1 negatīvs, tipisks datorprogrammām, ir 255. Tātad, ja Gandhi pieņem , Un tāpēc ir demokrātija viņa agresivitāte rezultāts samazinājās, tas faktiski ruļļos apkārt 255 un padara viņu visvairāk agresīvs raksturs spēlē. Tātad jūs varat Google līdzi šo. Un tas bija patiešām uzskata, nejauša programmēšana bug, bet tas ir ievadīts diezgan mācība kopš. 

Tas ir viss jautri un gudrs. Vairāk biedējoši ir, kad faktiskais reālās pasaules ierīces, un ne spēles, ir šīs pašas kļūdas. Patiesībā, tikai pirms gada raksts nāca out par Boeing 787 Dreamliner. 

Un raksts sākumā skatiens skan nedaudz mistisks. Bet tas teica, programmatūras ievainojamība Boeing s jauns 787 Dreamliner jet ir potenciāls radīt pilotus zaudēt kontroli pār lidaparāts, iespējams, in vidū lidojuma, FAA amatpersonas brīdināja aviokompānijas nesen. Tas bija noteikšana ka modelis 787 lidmašīna, kas ir darbināms nepārtraukti 248 dienas var zaudēt visu maiņstrāva, AC, elektriskās strāvas saistīts ar ģeneratoru vadības ierīces, GCUs, vienlaicīgi nonākšana neizdoties drošais režīms. Tas ir sava veida zaudēt mani. Bet paziņojumā tas norādīja, OK, tagad es saņēmu, ka, nosacījums izraisīja programmatūru counter iekšēja ģenerators kontrole vienības, kas būs pārplūdes pēc 248 dienas nepārtrauktas jaudas. Mēs izsniedzot šo paziņojums, lai novērstu zaudējumus no visiem maiņstrāvas spēks, kas varētu rasties in kontroles lidmašīnas zaudēšanu. 

Tātad, burtiski, ir daži skaitlis, vai kādu līdzvērtīgu datu tipu, tiek izmantota programmatūra kādā īstā lidmašīnā ka, ja jūs saglabāt savu lidmašīnu par pietiekami ilgi, kas acīmredzot var būt gadījumā, ja jūs vienkārši darbojas viņiem pastāvīgi un nekad atvienošanas Jūsu lidmašīna, šķiet, vai ļaujot tās baterijas mirst, būs iespējams saskaitīt, un uz augšu, un uz augšu, un uz augšu, un uz augšu, un uz augšu. 

Un, pēc dabas, ierobežots atmiņas apjoms pārplūdes, ritošā atpakaļ nulle vai kādu negatīva vērtība, blakusparādība, kas ir biedējoši reāls realitāte ka lidmašīna varētu būt vajadzīga kas rebooted, efektīvi, vai varētu samazināties, sliktāk, jo tas lido. Tātad šie jautājumi veidi joprojām ir kopā ar mums, even-- tas bija 2015 rakstu, vēl jo vairāk biedējoši ja jums nav obligāti izprast, novērtēt, vai paredzēt šie veidu kļūdas. 

Tātad izrādās, tur ir viens cits slikta lieta par datu attēlojumā. Izrādās, ka pat pludiņi ir veida kļūdains, jo pludiņiem, pārāk, Es ierosināju ir 32 biti, vai varbūt 64, ja jūs izmantojat dubultā. Bet tas joprojām ir ierobežots. 

Un loms ir, ka, ja jūs varat likts neskaitāmas numuru aiz komata, nav tā, kā jūs var pārstāvēt visu iespējamo skaitļi, kas mums mācīja pakāpē skola var pastāvēt pasaulē. Dators, būtībā, ir izvēlēties apakškopu šiem numuriem pārstāvēt precīzi. 

Tagad, dators var apaļa varbūt mazliet, un var ļaut jums aptuveni veikalu jebkurš skaits jūs, iespējams, vēlaties. Bet tikai intuitīvi, ja jums ir ierobežots bitu skaits, jūs varat tikai apmainīt tos tik daudz ierobežotos veidos. Tātad jūs nav iespējams izmanto ierobežots skaits par permutation bitiem, modeļi nullēm un tiem, pārstāvēt bezgalīgs skaits skaitļiem, kas liecina, ka datori varētu ļoti labi būt guļus mums reizēm. 

Patiesībā, pieņemsim darīt. Ļaujiet man iet atpakaļ CS50 IDE. Ļaujiet man iet uz priekšu un izveidot nelielu programmu sauc neprecizitāte, lai pierādītu, ka datori ir, patiešām, neprecīzs. 

Un ļaujiet man iet uz priekšu un sākt ar daži no šī kodeksa no pirms, un tagad vienkārši darīt šādi. Ļaujiet man iet uz priekšu un darīt printf, procenti f, slīpsvītru n, 1 dalīts ar 10. Citiem vārdiem sakot, pieņemsim nirt dziļāk 1/10, piemēram, 1 un dalīts ar 10. Protams, dators var pārstāvēt 1/10. 

Tātad, pieņemsim iet uz priekšu un darīt neprecizitātes. Paskatīsimies. Formāts precizē dubultā rakstīt. Bet arguments tipa int. Kas notiek? 

Ak, interesanti, tāpēc tas ir mācoties no iepriekš. Es saku, hey, dators parādīt me pludiņš ar procentiem f. Bet es esmu, kas 2 Ints. Tātad izrādās, es varu noteikt šis pāris veidos. 

Es varētu tikai savukārt viens par 1,0, un 10 uz 10,0, kas, protams, būt tāda iedarbība, pārvēršot tos floats-- vēl cerams tas pats numurs. Vai izrādās, tur ir kaut kas mēs redzēsim atkal pirms ilgi. Jūs varētu nodot numurus. 

Jūs varat, izmantojot šo Parenthetical izteiksme, jūs varat teikt, hey, dators, ņemt to 10, ko es zinu, ir int. Bet pret to, lūdzu, it kā tas ir pludiņš. Bet tas jūtas nevajadzīgi sarežģīti. 

Par mūsu mērķiem šodien, pieņemsim tikai burtiski padara tos peldošā punkta vērtības ar komata, kā šis. Ļaujiet man iet uz priekšu un atkārto, padarīt neprecizitāte, labi, dot slīpsvītra neprecizitāte, ievadiet. Labi, mēs meklējam labu. 

1 dalīts ar 10, saskaņā ar manu Mac šeit, ir, protams, 0,100000. Tagad, man mācīja pakāpē skolā tur vajadzētu būt bezgalīgs skaits 0 gados. Tātad, pieņemsim vismaz mēģināt redzēt dažus no tiem. Izrādās, ka printf ir nedaudz mīļotājs joprojām nekā mēs esam izmantojuši. Izrādās, jums nav jānorāda vienkārši procenti f, vai vienkārši procenti i. Jūs faktiski var norādīt daži kontroles iespējas šeit. 

Konkrēti, es eju teikt, hey, printf, faktiski parādiet man 10 decimāldaļu punktus. Tātad, tas izskatās mazliet dīvaini. Bet jūs sakāt procentiem, dot, cik daudz skaitļu Jūs vēlaties redzēt pēc komatu, un tad f vienotas, tikai tāpēc, ka tas ir kāda dokumentācija saka. Ļaujiet man iet uz priekšu un saglabājiet to. 

Un paziņojums pārāk, es saņemu noguris pārrakstīšana lietas. Tāpēc es esmu tikai nosakot up un leju arrow par manu taustiņiem šeit. Un, ja es turpinu hitting augšu, var redzēt visas komandas ka es, vai nepareizi veikts. 

Un es iešu uz priekšu tagad faktiski neizmanto, ka, acīmredzot. Padarīt neprecizitāte, dot slash imprecision-- tik kas man bija mācīts Skolas pārbaudes veic. Pat ja es to izdrukāt uz 10 aiz komata izvieto tā, protams, ir 0,10000. Bet jūs zināt, ko? 

Iesim mazliet mantkārīgs. Teiksim, piemēram, parādiet man 55 norāda aiz. Pieņemsim tiešām ņemt to programmu, kas par spin. Ļaujiet man pārtaisīt to ar marku neprecizitāte, dot slīpsvītra, neprecizitāte. 

Un šeit mēs ejam. Tava bērnība bija meli. Acīmredzot, 1 dalīts ar 10 ir patiešām 0.100000000000000005551115123-- 

Kas notiek? Nu, izrādās, ja jūs veida izskatīties pietiekami tālu in bāzes pārstāvība šo skaits, tā faktiski nav precīzi 1/10, vai 0.1 un bezgalīgi daudz nullēm. Tagad, kāpēc tā? 

Nu, pat ja tas ir vienkāršs numuru, lai mums cilvēkiem, 1 dalīts ar 10, tas joprojām ir viens no bezgala daudziem skaitļi, kas mēs varētu izdomāt. Bet dators var tikai pārstāvēt finitely daudz tā numuri. Un tā, efektīvi, ko dators rāda mums ir tās tuvākais tuvināšana uz numuru mēs gribam ticēt, ir 1/10, vai tiešām 0,10000 bezgalīgi. 

Drīzāk, lai gan, tas ir tik tuvu, jo tā var iegūt. Un, protams, ja paskatās zem motora pārsega, jo mēs esam šeit, apskatot 55 zīmēm aiz, mēs faktiski redzēt šo realitāti. Tagad kā malā, ja esat kādreiz redzējuši movie-- lielākā daļa no jums droši vien haven't-- bet pirms Superman 3 dažiem gadiem, Richard Pryor būtībā parādi šis realitāte savā uzņēmumā nozagt daudz frakciju un frakciju pennies, jo company-- kā es atceros, tas ir bijis while-- būtībā bija throwing prom kaut kas nav piemērots uz jēdzienu centiem. 

Bet, ja jūs saskaitīt visus šos tiny, tiny, tiny skaitļi atkal, un atkal, un atkal, jūs varat, kā viņa lieta, darīt labu naudas summu. 

Ka pati ideja tika ripped off ar vēl nesen, bet tomēr tagad vecāki filma, ko sauc par Office Space, kur puiši šajā filmā, bija tas pats, ieskrūvē to pilnīgi, beidzās ar pārāk daudz naudu savā bankas kontā. Tas viss bija ļoti aizdomīgs. Bet beigās, dienā, neprecizitāte ir mums visapkārt. 

Un tas arī var būt biedējoši lietu. Izrādās, ka Supermens 3 un Office Space malā, tur var būt daži ļoti reāls pasaules atzari realitāti neprecīzu pārstāvība datu ka pat mēs cilvēki uz Šajā dienā ne vienmēr izprast, kā arī mums ir, vai atcerēties, cik bieži mums vajadzētu. Un, protams, šādi klips ir no apskatīt dažas ļoti reālajā pasaulē atzari, kas notiek, ja jūs neapzinās neprecizitāti, ka var notikt skaitļos pārstāvību. 

[VIDEO PLAYBACK] 

-datori, Mēs visi esam ieradušies pieņemt tad bieži nomākta problēmas, iet ar them-- bugs, vīrusi, un programmatūras glitches, mazajiem cenas maksāt par ērtībām. Bet augsto tehnoloģiju un lielu ātrumu militāro un kosmosa programmu pieteikumus, mazākais problēma var tikt palielināts par katastrofu. 

Jūnijā 4, 1996, zinātnieki sagatavoja uzsākt bezpilota Ariane 5 raķeti. Tas nesa zinātnisko satelīti izstrādātas noteikt precīzi, kā Zemes magnētiskais lauks mijiedarbojas ar saules vēju. Raķete tika uzbūvēta Eiropas Kosmosa aģentūra, un pacēla off no objekta krastā Franču Gviānā. 

-at Aptuveni 37 sekundes ievešanu lidojums, viņi vispirms pamanīju kaut kas notiek nepareizi. Sprauslas tika grozot in veids, kā viņi tiešām nevajadzētu. Ap 40. lidojuma sekundē, skaidri, transportlīdzeklis bija nepatikšanas. 

Un tas ir tad, kad viņi lēmums to iznīcināt. Diapazons drošības virsnieks, ar milzīgs iekšām, nospiedis pogu, uzspridzināja raķešu, pirms tas varētu kļūt par apdraudējumu sabiedrības drošībai. 

-Tas Bija jaunava reiss no Ariane 5. Un tās iznīcināšana paņēma vieta, jo plaisāt iestrādāta raķešu programmatūras. -The Problēma uz Ariane bija ka tur bija vairāki, kas nepieciešami 64 biti izteikt. Un viņi gribēja, lai pārvērstu tā uz 16-bitu skaitu. Viņi pieņem, ka numurs bija nekad būt ļoti liels, ka lielākā daļa no tiem cipariem 64 bitu skaits bija nulles. Viņi bija nepareizi. 

-The Nespēja viens programmatūru pieņemt veida numuru, ko ģenerē vēl bija pie saknes neveiksmi. Programmatūras izstrāde bija kļuvusi ļoti dārgi daļa no jaunās tehnoloģijas. Ariane raķete bijuši ļoti veiksmīgs, tik daudz programmatūras izveidots tā bija arī izmanto Ariane 5. 

-The Pamata problēma bija tā, ka Ariane 5 bija ātrāks, paātrināta ātrāk. Un programmatūras nebija veidoja to. 

-The Iznīcināšana raķete bija milzīgs finanšu katastrofa, viss dēļ minūti programmatūras kļūdu. Bet tas nebija pirmais laika datu pārveides problēmas bija cieš modernas raķešu tehnoloģijas. 

-In 1991 ar sākuma pirmā Persijas līča kara, Patriot raķešu piedzīvoja līdzīga veida no skaits konversijas problēmu. Un kā rezultātā, 28 cilvēki, 28 amerikāņu karavīri, tika nogalināti, un par 100 citi ievainoti, kad Patriot, kas bija paredzēts aizsardzībai pret ienākošo scuds, neizdevās uguns raķeti. 

-Kad Irāka iebruka Kuveitā un Amerikā uzsāka Desert Storm 1991 sākumā, Patriot raķešu baterijas tika izvietoti aizsargāt Saūda Arābiju un Izraēlu no Irākas dzīšanās raķešu uzbrukumiem. Patriot ir ASV vidēja darbības rādiusa virsmas gaisa sistēmas, izgatavoti ar Raytheon kompānija. 

-The Lielums Patriot kolektoru pati par sevi ir apmēram apmēram 20 pēdu garš. Un tas sver aptuveni 2000 mārciņas. Un tā veic kaujas galviņu apmēram, Es domāju, ka tas ir aptuveni 150 mārciņas. Un kaujas galviņu pats par sevi ir augsts sprāgstviela, kuru ir fragmenti ap to. No Warhead apvalks paredzēti rīkoties kā rupja skrots. 

-Mikroshēmas Raķetes tiek veiktas četri vienu konteineru, un tiek transportēti ar puspiekabi piekabi. 

-The Patriot pretraķešu sistēma iet atpakaļ vismaz 20 gadus. Tā sākotnēji tika izstrādāta kā gaisa aizsardzības raķete atvašu nosaka ienaidnieka lidmašīnas. Pirmajā Līča kara, kad tas karš nāca kopā, armija vēlējās izmantot, lai atvašu nosaka scuds, nevis lidmašīnas. 

Irākas Gaisa spēki bija ne tik daudz problēmu. Bet armija bija noraizējies par scuds. Un tā viņi centās uzlabot Patriot. 

-Intercepting Ienaidnieks raķešu ceļo pie Mach 5 bija būs izaicinājums pietiekami. Bet, kad Patriot tika steidzās ekspluatācijā, armija nebija zināms par Irākas modifikācija, kas padarīja viņu scuds gandrīz neiespējami, lai sasniegtu. 

-Kas Noticis ir scuds ka tika nāk bija nestabila. Viņi bija wobbling. Iemesls tam bija irākiešiem, lai lai saņemtu 600 kilometrus no 300 kilometru diapazons raķešu, paņēma svaru no priekšējās Warhead. Viņi padarīja kaujas galviņu vieglāks. 

Tātad tagad Patriot ir mēģina nākt pie dzīšanās. Un lielāko daļu no laika, Lielākā daļa no laika, tas tikai lidot ar dzīšanās. Kad Patriot sistēmu operatoriem sapratu Patriot garām savu mērķi, tie uzsprāgt Patriot ir kaujas galviņu lai izvairītos no iespējamiem nelaimes gadījumiem, ja to bija atļauts krist uz zemes. 

-That Bija tas, ko lielākā daļa cilvēku redzēja, šie lielie fireballs debesīs, un pārprot kā pārtver no dzīšanās kaujas galviņām. 

-Although Naktī debesis, Patriots parādījās būt veiksmīgi iznīcinot Scuds, pie Dhahran, tur varētu būt kļūda par savu sniegumu. Tur, Patriot ir radaru sistēma zaudējis dziesmu par ienākošu dzīšanās, un nekad uzsāka dēļ ar programmatūras plaisāt. Tas bija izraēliešiem kurš pirmais atklāja ka vairs sistēma bija, jo lielāks laiks neatbilstība kļuva, pateicoties pulksteņa iegulto Sistēmā datorā. 

-Par Divas nedēļas pirms traģēdija in Dhahran, izraēlieši ziņoja Aizsardzības departaments ka sistēma tika zaudēt laiku. Pēc apmēram astoņas stundas vai skriešanu, viņi pamanīja, ka sistēmā kļuva ievērojami mazāk precīzi. Aizsardzības departaments atbildēja, stāsta visi Patriot baterijas lai neatstāj sistēmas uz ilgu laiku. Viņi nekad nav teicis, ko sen was-- astoņas stundas, 10 stundas, 1000 stundas. Neviens nezināja. 

-The Patriot baterijas izvietoti pie kazarmām pie Dhahran un tās trūkumi iekšējā pulkstenis bija vairāk nekā 100 stundas naktī no 25. februāra. 

-Tas Kāpurķēžu laiku ar precizitāti no aptuveni desmito daļu sekundes. Tagad, desmitā daļa otrā ir interesants skaitlis, jo tas nevar tikt izteikta binārā precīzi, kas nozīmē to nevar izteikt precīzi jebkurā mūsdienu digitālā datora. Tas ir grūti noticēt. 

Bet izmantot to kā piemēru. Paņemsim numurs vienu trešdaļu. Viena trešdaļa nevar būt izteikta komata precīzi. Viena trešdaļa ir 0,333 notiek uz bezgalību. 

Nav veids, kā to darīt, ka ar absolūtā precizitāte aiz komata. Tas ir tieši veida problēmas kas notika Patriot. Jo ilgāk sistēma skrēja, tad sliktāk kļuva par laika kļūda. 

-Pēc 100 ekspluatācijas stundām, tad kļūda laikā bija tikai aptuveni viena trešdaļa par sekundi. Bet attiecībā uz mērķauditorijas raķešu ceļo pie Mach 5, tas izraisīja izsekošanu kļūda vairāk nekā 600 metri. Tas būtu fatāla kļūda par karavīriem par to, ko noticis ir dzīšanās uzsākšana bija atklāj agrīnās brīdināšanas satelītiem un viņi zināja, ka dzīšanās bija nāk viņu vispārējo virzību. Viņi nezināja, kur tā nāk. 

-Tas Bija tagad līdz radara komponents no Patriota sistēmas aizstāvot Dhahran, lai atrastu un saglabātu dziesmu no ienākošo ienaidnieka raķešu. 

-The Radara bija ļoti gudrs. Tas faktiski izsekot nostāja dzīšanās, un tad prognozēt, kur tas iespējams, būtu nākamreiz radara nosūtīts pulsa out. Ka sauca diapazons vārtiem. 

-Tad, Kad Patriot nolemj pietiekami daudz laika ir nodots, lai dotos atpakaļ un pārbaudiet nākamo vieta šim atklāto objektu, tas iet atpakaļ. Tad, kad tā devās atpakaļ uz nepareizu vieta, tad tas nesaskata objektu. Un tā nolemj, ka nav objekts, tas bija viltus atklāšanu, un pilieni dziesmu. 

-The Ienākošo dzīšanās pazuda no radara ekrāna. Un sekundes vēlāk, to ietriecās kazarmās. Dzīšanās nogalināti 28, un bija pēdējais viens kurināti pirmā Persijas līča kara laikā. 

Traģiski, atjaunināto programmatūru ieradās Dhahran nākamajā dienā. Programmatūra plaisāt bija ir fiksēts, slēdzot viens nodaļu nemierīgajā vēsture Patriot raķešu. 

[VIDEO PLAYBACK] DAVID J. Malan: Tātad tas ir viss, lai teikt, ka šajos jautājumos pārplūdi un neprecizitāte ir pārāk reāls. Tātad, kā mēs šeit? Mēs sākām ar tikai runā par printf. Arī šī funkcija, izdrukā kaut ko uz ekrāna, un mēs iepazīstinājām tam dažas citas funkcijas No tā sauktās CS50 bibliotēkā. Un mēs turpināsim redzēt tos savlaicīgi. Un mēs, jo īpaši, izmanto get virkni, un saņemt int, un tagad arī saņemt peldēt, un vēl citi, joprojām mēs saskaramies un izmantot sevi pirms ilgi. 

Bet reizēm, ir mēs jau redzējuši vajadzību uzglabāt to, kas šīs funkcijas roku atpakaļ? Tie rokas mūs atpakaļ string, vai int, vai pludiņš. Un dažkārt mums ir nepieciešams, lai tas string, vai int vai peldēt, kaut kur. 

Un uzglabāt tās lietas, atgādināt tikai tāpat kā nulles, mums ir mainīgie. Bet atšķirībā no nulles, C mums ir faktiskie veidi no variables-- datu veidi, vairāk generally-- Starp tiem, string, int A peldēt, un šie citi vēl. 

Un tad, kad mēs deklarēt mainīgos C, mums nāksies atzīt mūsu datu tipu. Tas nav kaut kas, mēs ņemšu jādara vēlāk semestra kā mēs pāriet uz citām valodām. Bet tagad mums ir nepieciešams uz a priori iepriekš, izskaidrot ar datoru, kas tipa Mainīgā mēs gribam, lai dotu mums. 

Tagad, tikmēr, lai drukātu šie veida datu tipu, mums ir pateikt printf, ko gaidīt. Un mēs redzējām procentiem S stīgas, un procenti i par veseliem skaitļiem, un daži citi jau. Un tie ir vienkārši prasības par vizuālo noformējumu Šīs informācijas. 

Un katrs no tiem patiesībā var būt parametrized vai tweaked kaut kādā veidā, ja jūs vēlaties, lai turpinātu kontroli Par produkcijas veidu, kas jums. Un, patiesībā, izrādās, ka ne tikai ir tur slīpsvītru n jaunu līniju. Tur ir kaut kas cits sauc reversā slīpsvītra R rakstatgriezi, kas vairāk līdzinās vecās skolas rakstāmmašīnas, un arī Windows izmantoti jau daudzus gadus. 

Tur slīpsvītru t cilnēm. Izrādās, ka, ja jūs vēlaties, lai dubultā quote iekšpusē virknes, atgādināt, ka mēs esam izmantojuši double double quote citāts pa kreisi un pa labi beidzas mūsu stīgām līdz šim. Tas, šķiet, jauc lietas. 

Ja jūs vēlaties, lai divkāršu citātu vidū string-- un, protams, tas ir mulsinoši redzēt. Un tāpēc jums ir izvairīties, tāpēc, lai runā, dubultu citātu ar kaut ko piemēram, burtiski, slīpsvītru dubultu cenas. Un tur ir dažas citas vēl. Un mēs redzēsim vairāk no tiem, faktisko izmantošanu pirms ilgi. 

Tātad, pieņemsim tagad pāreja no dati, un pārstāvība, un aritmētiskās uzņēmējiem, visiem kura deva mums kādu ēku bloki ar ko spēlēt. Bet tagad pieņemsim faktiski dod mums pārējā leksikas ka mums jau bija pagājušajā nedēļā ar nulles ņemot apskatīt kādu citu konstrukcijas, kas C- ne visi no tiem. Bet idejas mēs esam par to, lai redzētu, tiešām tikai uzsvērt tulkojumu no viena valoda, Scratch, uz citu, C. 

Un laika gaitā, mēs uzņemt vairāk instrumenti mūsu rīkkopa, tā sakot, sintaktiski. Un, protams, jūs redzēsiet, ka idejām tagad ir diezgan pazīstams no pagājušajā nedēļā. Tātad, pieņemsim darīt. 

Iesim uz priekšu un pātagu up programmu kas faktiski izmanto dažas izteiksmes, Būla izteiksme. Ļaujiet man iet uz priekšu šeit un izveidotu jaunu failu. Es aicinu šo condition.c. 

Ļaujiet man iet uz priekšu un ietver CS50 bibliotēka. Un ļaujiet man iet uz priekšu un ietver standarts IO.h mūsu funkcijām, un printf, un vairāk attiecīgi. Ļaujiet man sniegt sev, ka tekstveidnes no int galvenais neesošu, kuru skaidrojums mēs ņemšu atgriezties nākotnē. 

Tagad ļaujiet man iet uz priekšu un dot myself int caur get int. Tad ļaujiet man iet uz priekšu un darīt to. Es gribu teikt, ja man ir less-- pieņemsim atšķirt pozitīva, negatīva, vai nulles vērtības. 

Tātad, ja es ir mazāks par nulli, ļaujiet man vienkārši ir šī programma vienkārši pateikt, negatīvs, slīpsvītru n, cits ja i ir lielāka par nulli. Tagad es esmu, protams, gatavojas teikt printf pozitīvu, reversā slīpsvītra n. Un tad vēl if-- es varētu darīt. 

Es varētu darīt, ja man ir vienāds ar 0. Bet es gribētu būt pieņemšanā vismaz viena kļūda jau. Atgādināt, ka vienādības zīme ir nav vienāds, jo mēs cilvēki zina. 

Bet tas ir uzdevums operators. Un mēs negribam uzņemties 0 Uz tiesības un nodot to i pa kreisi. Tātad, lai izvairītos no šīs neskaidrības, vai varbūt no vienādības nepareiza paraksta, cilvēki nolēma pirms dažiem gadiem ka daudzās programmēšanas valodās ja jūs vēlaties, lai pārbaudītu vienlīdzību starp kreisās un labās puses, jūs faktiski izmantot vienāds vienāds. Tātad jūs hit vienādības zīmes divreiz. Ja jūs vēlaties piešķirt no labās pa kreisi, jūs izmantojat vienu vienādības zīmi. Lai mēs varētu darīt this-- cits ja es vienāds vienāds ar nulli. 

Tad es varētu iet un atvērt manas cirtaini bikšturi, un teikt, printf 0, slīpsvītru n, darīts. Bet atceries, kā šie dakšas uz ceļa var strādāt. Un, patiesi, tikai domāju par loģiku. i ir skaitlis. Tas ir vesels skaitlis, īpaši. Un tas nozīmē, ka tas būs mazāks par 0, vai lielāks par 0, vai 0. Tātad ir sava veida šī netiešā neatmaksāšanas gadījumā. 

Un tā mēs varētu, tāpat kā Scratch, iztikt ar cits, ja, un tikai teikt cits. Loģiski, ja Jums programmētājs zināt, tur ir tikai trīs spaiņi uz kurām scenārijs var fall-- pirmais, otrais, vai trešais šajā case-- nav apnikt pievienojot papildu precizitāti un papildus loģika tur. Tikai iet uz priekšu ar noklusējuma gadījums no cits. 

Tagad iesim uz priekšu pēc glābšanas tas, padarīt apstākļi dot slash conditions-- nav lieliska lietotāja saskarne, jo es neesmu pamudinot lietotāju, kā jau iepriekš minēju. Bet tas ir jauki. Mēs saglabātu tā vienkārši. Pamēģināsim numuru 42. Un tas ir pozitīvi. Pamēģināsim numuru negatīvs 42, negatīvs. 

Pamēģināsim vērtību 0. Un, protams, tas darbojas. Tagad, jūs redzēsiet ar problēmām pirms garš, testēšanas lietas trīs reizes, iespējams, nav pietiekami. Jūs, iespējams, vēlaties, lai pārbaudītu kādu lielāks skaits, daži mazāki numuri, daži stūra gadījumos, kā mēs būsim tās aprakstīt. 

Bet tagad, tas ir diezgan vienkārša programma. Un es esmu diezgan pārliecināts, loģiski, ka tas iekrīt trīs gadījumos. Un, protams, kaut arī mēs tikko vērsta uz potenciālajiem ēnas par neprecizitāti un pārplūdes, jo realitāti, kur daudzi no CS50 problēmām, mēs neesam gatavojas jāuztraucas par, visu laiku, šie jautājumi pārpildes un neprecizitāte, jo, patiesībā, C, tas tiešām nav viss, kas viegli izvairīties no šīs lietas. Ja vēlaties saskaitīt lielāks, un lielāks, un lielāks, izrādās, ka ir metodes, jūs var izmantot, bieži iesaistot lietas sauc bibliotēkas, kolekcijas koda, ka citi cilvēki rakstīja, ka jūs varat izmantot, un citas valodas, piemēram, Java un citi, faktiski padara to daudz vieglāk skaitīt vēl lielāks. Tātad, tas tiešām ir dažas no šīm briesmām funkcija valodas jūs izmantojat. Un tuvākajās nedēļās mēs redzētu, cik bīstama C patiešām var būt, ja jums nav to izmantot pareizi. Bet no turienes, un ar Python, un JavaScript, būs mēs slānis dažas papildu aizsardzība, un palaist mazāk no šiem riskiem. 

Tātad, pieņemsim padarīt nedaudz vairāk interesanta loģika mūsu programmā. Tāpēc ļaujiet man iet uz priekšu un izveidot programma, ko sauc Loģiskā tikai, lai es varētu spēlēt ar kādu Faktiskais loģika, logical.c. Es ņemšu tikai kopēt un ielīmēt dažas kodu no agrāk, lai es saņemtu atpakaļ uz šo jauku sākumpunktu. 

Ļaujiet man šoreiz darīt char C. es esmu gatavojas arī tā nosaukumu C tikai tāpēc, ka tas ir parasto, iegūt rakstzīmi no lietotāja. Un pieņemsim izlikties, piemēram, Es esmu īstenojot daļu Minētās Rm programmas noņemt programma pirms tam lika lietotājam izņemt failu. Kā mēs varētu darīt? 

Es gribu teikt, ja C ir vienāds vienāds, quote likt pēdiņas beigās, y, tad es esmu gatavojas pieņemt ka lietotājs ir izvēlējies jā. Es esmu tikai gatavojas drukāt jā. Ja tas tiešām ir rakstiski pārcelšanās programmu, mēs varētu noņemt failu ar vairākām līnijām kodu. Bet mēs saglabāt to vienkārši. 

Cits, ja c vienāds vienāds N- un tagad šeit, es esmu gatavojas teikt, lietotājam ir nozīmēja nē. Un tad vēl, jūs zināt, ko? Es nezinu, ko vēl lietotājs gatavojas rakstīt. Tāpēc es esmu tikai gatavojas teikt, ka ka ir kļūda, neatkarīgi viņš vai viņa faktiski drukāti. 

Tātad, kas notiek šeit? Ir būtiska atšķirība pret to, ko es esmu darījusi agrāk. Pēdiņas, pēdiņas, dubultā citātus, un, tomēr, vienu pēdiņām, vienu pēdiņām. Izrādās C, ka tad, kad jūs vēlaties rakstīt virkni, jūs izmantot dubultās pēdiņas, tāpat kā mēs esam bijis, izmantojot visu šo laiku ar printf. 

Bet, ja jūs vēlaties, lai tiktu galā ar tikai vienots raksturs, ts char, tad jūs faktiski izmantot vienu pēdiņas. Tiem no jums, kas esam ieprogrammēts pirms, jums, iespējams, nav bija jāuztraucas par to atšķirība dažās valodās. C, tas nav jautājums. Un tad, kad man char un es gribu salīdzināt, ka char izmantojot vienāds vienāds ar kādu vēstuli, piemēram, y vai n, man, Patiešām, ir nepieciešams, lai būtu vienu pēdiņām. 

Tagad iesim uz priekšu un darīt to. Iesim uz priekšu un darīsim loģiskās dot slīpsvītra loģiski. Un tagad es esmu to pamudināja. Tātad, iespējams, labāku lietotāju pieredzi tiešām man pateikt, ko darīt šeit. Bet es esmu gatavojas tikai akli teikt y par jā, OK, jauki. 

Pieņemsim palaist vēlreiz, n ne, jauki. Pieņemsim, piemēram, dažiem cilvēkiem, es zinu, mana Caps Lock taustiņš ir ieslēgts pārāk bieži. Tāpēc man galvaspilsēta Y, ievadiet, kļūda. Labi, tas nav tieši tas, ko es esmu gaidījis. Patiešām, dators dara burtiski ko Teicu to do-- pārbaudīt mazie y un mazie burti n. Tas nav justies kā labi lietotāju pieredzi, lai gan. Ļaujiet man lūgt un pieņemt nu mazie burti vai lielie burti. Tātad izrādās, jūs varētu vēlēties pateikt kaut ko tāpat kā nulles, piemēram, burtiski vai C vienāds vienāds kapitāla vienu kotētas vec. Izrādās, C nav Tas burtisks atslēgvārdu vai. 

Bet tas ir divas vertikālas joslas. Jums ir turēt Shift parasti, ja jūs izmantojat ASV tastatūru, un hit vertikālo pārliktni Galvenais virs jūsu atgriešanās taustiņu. Bet tas vertikāla josla vertikāla josla nozīmē vai. 

Ja, savukārt, mēs vēlējāmies teikt un, līdzīgi kā nulles, mēs varētu darīt aizvieto & zīmes aizvieto & zīmes. Ka nav nekādas loģiskas jēgas šeit, jo cilvēks nevarēja iespējams ir drukāti gan y un mazie burti y un kapitāla Y kā paša rakstura. Tātad, vai ir tas, ko mēs plānojam šeit. 

Tātad, ja es to izdarītu abās vietās, vai c vienāds vienāds kapitāls N, tagad atkārto, padara loģiski, atkārto loģiski. Tagad es varu rakstīt y. Un es varu darīt to vēlreiz ar kapitāls Y, vai kapitāla N. Un es varētu pievienot papildu kombinācijas joprojām. 

Tātad tas ir loģisks Programma ciktāl tagad Es pārbaudīt loģiski par šī vērtība vai šī vērtība. Un man nav, obligāti, nākt klajā ar vēl diviem IF vai cits IFS. Es patiesībā var apvienot dažus no kas saistītas loģikas kopā šādā veidā. Tātad tas būtu labāk izstrādātas nekā vienkārši sakot, ja C vienāds mazais y, drukāt jā, cits, ja c ir vienāds kapitāla Y, drukāt jā, cits, ja c ir vienāds lower-- citiem vārdiem sakot, jums nav jābūt arvien vairāk filiāles. Jūs varat apvienot dažus ekvivalenta Nozares Loģiski, kā šādā veidā. 

Tātad, pieņemsim to apskatīt tikai vienu final sastāvdaļa, viena gala konstrukcija, ka C atļauj. Un mēs būsim atpakaļ Nākotne citiem vēl. Un tad mēs secināt, aplūkojot pie ne pareizību code-- iegūt kodu work-- bet dizains kodu, un augu tos sēklas sākumā. 

Tāpēc ļaujiet man iet uz priekšu un atvērt jaunu failu šeit. Tu zini ko? Es esmu gatavojas atkārtoti ieviest ka pati programma, bet, izmantojot citu konstrukciju. 

Tāpēc ļaujiet man ātri dot sevi piekļuve iekļaut CS50.h par CS50 bibliotēkā, standarts Io.h par printf. Dodiet man manu int galvenais tukšumu. Un tad vairāk nekā šeit, ļaujiet man iet uz priekšu un darīt to. 

Char c izpaužas saņemt char, tāpat kā līdz šim. Un es esmu gatavojas izmantot jaunu būvēt now-- slēdzis, uz kāda raksturu? Tātad slēdzis ir veids kā komutācijas vilciena dziesmas. Vai, patiešām, tas ir sava veida IF cits, ja cits, ja, bet rakstīts nedaudz savādāk. 

Slēdzis izskatās šādi. Jums ir slēdzis, un tad kāda raksturs vai numuru, kuru vēlaties apskatīt, tad daži cirtaini bikšturi patīk Scratch, tikai teikt šo stuff. Un tad jums ir dažādas lietas. 

Jūs neizmantojat ja un cits. Jūs burtiski izmantot vārdu lietu. Un tu teiktu kaut kas līdzīgs šim. 

Tātad, šajā gadījumā uz mazo y, vai gadījumā, ja kapitālu Y, iet uz priekšu un izdrukāt jā. Un tad izkļūt no slēdža. Tieši tā. Mēs esam darīts. 

Cits, ja, tā sakot, mazie burti n, vai kapitāla N, tad iet uz priekšu un izdrukāt veic ne, un tad pārtraukums. Else-- un šāda veida ir neatmaksāšanas gadījumā indeed-- printf error-- un tikai labu pasākumu, lai gan loģiski šis pārtraukums nav nepieciešams jo mēs esam beigās slēdzi anyway, Es tagad izkļūt no slēdzi. Tātad tas izskatās nedaudz atšķiras. 

Bet, loģiski, tas ir faktiski līdzvērtīgs. Un kāpēc jūs izmantojat viens virs otra? Dažreiz vienkārši personīgās vēlmes, dažreiz estētika, ja es skatienu šis tagad, tur ir kaut kas ko teikt par salasāmība šo kodu. Es domāju, nekad prātā faktu, ka šis kods ir jauns, lai daudziem no mums šajā telpā. 

Bet tas tikai veida ir diezgan. Redzi mazie y, kapitāla Y, mazie burti n, kapitāla N noklusējuma, tas tikai veida lec out pie jums tādā veidā ka, varbūt, varbūt iepriekšējais piemērs ar IF un vertikāliem stieņiem, un cits IFS, iespējams, nav. Tātad šī ir patiešām jautājums par personas izvēle, tiešām, vai lasāmību, no koda. 

Bet attiecībā uz funkcionalitāti, ļaujiet man iet uz priekšu un veikt slēdzis, dot slīpsvītru slēdzis, un tagad ierakstiet mazo y, kapitāls Y, mazie n, kapitāla N, David, mēģiniet vēlreiz, jo tas ir ne vienu rakstzīmi. Darīsim x, kļūdu, kā gaidīts. Un, logically-- un tas ir kaut kas Es aicinu in general-- pat lai gan mēs esam tikai nesaskrāpē virsma dažas no šīm funkcijām. 

Un tas var nebūt skaidrs, kad jūs pats sēsties pie klaviatūras, Kā tas darbojas? Kas būtu tas jādara? Skaista lieta, par kuru klēpjdatoru vai galda, vai piekļuves datoram ar kompilatoru, un ar koda redaktoru, piemēram, tas, ir jūs gandrīz vienmēr varat atbildēt uz šiem jautājumi sev, vienkārši mēģina. 

Piemēram, ja retorisks jautājums pie rokas bija, kas notiek, ja esat aizmirsis Jūsu pārtraukums paziņojumi? Kas ir faktiski ļoti bieži lieta, ko darīt, jo tas neizskatās kā jums tiešām ir nepieciešams. Tie nav īsti pabeigt savu domāju, piemēram, iekavās vai cirtaini lencēm dara. Iesim uz priekšu un recompile kodu un redzēt. Tātad, lai slēdzis, dot slash slēdzis. Pieņemsim rakstīt ar mazajiem burtiem y, top lieta, Enter. Tāpēc es drukāti vec. 

Programma teica jā, nē, kļūda, it kā tā maina savu prātu. Bet tas veids bija, jo tas, kas notiek ar slēdzi ir pirmais gadījums, spēles būtībā nozīmē, hey dators, izpildīt visi no koda zem tā. Un, ja jums nav teikt pauze, vai nesaku pārtraukuma, vai nav teikt pārtraukuma, dators gatavojas pūst cauri visām šīm līnijām un izpildīt visas no tām līdz tas izpaužas uz šo cirtaini lencēm. Tātad bremzes ir patiešām nepieciešams. Bet takeaway šeit ir, kad šaubāties, izmēģināt kaut ko. Varbūt saglabāt savu kodu, pirmkārt, vai saglabāt to papildu failā ja jūs patiešām uztrauc messing up un kam, lai atgūtu darbs, ka jūs zināt, strādā. 

Bet mēģināt lietas. Un nevajag tik bail, varbūt, par to, ko dators varētu darīt, vai jūs varētu pauze kaut ko. Jūs vienmēr varat atgriezties uz kādu iepriekšējo versiju. 

Tātad, pieņemsim beigt skatoties pie dizaina kodu. Mums ir šī iespēja tagad rakstīt nosacījumiem, un rakstīt cilpas, un mainīgie, un zvanu funkcijas. Tātad, atklāti sakot, mēs esam sava veida atpakaļ kur mēs bijām pirms nedēļas ar nulles, kaut arī ar mazāk pārliecinošu tekstuālu vide nekā Scratch atļauj. 

Bet paziņojums cik ātri mēs esam ieguvuši ka vārdu krājums, pat ja tas ir gatavojas pieņemt nedaudz, bet izlietne, tā ka tagad mēs varam izmantot šo vārdnīcu rakstīt vairāk interesantu programmu. Un pieņemsim bērnu soli pret, ka šādi. Ļaujiet man iet uz priekšu un izveidot jaunu failu šeit. 

Es esmu dodas uz zvanu šis prototype.c, un ieviest pirmo reizi, spēja padarīt savu funkciju. Daži no jums varētu būt izdarīts ar nulles, ar kuru jūs varat izveidot savu pašu pasūtījuma bloki nulles, un pēc tam velciet tās vietā kur vien vēlaties C Un lielākajā daļā programmēšanas valodas, jūs varat darīt tieši that-- veikt savas funkcijas, ja tie nav jau pastāv. 

Tā, piemēram, ļaujiet man iet uz priekšu un ietver CS50.h, un ietver standarta IO.h, int galvenais spēkā neesošu. Un tagad mums ir viettura gatavi iet. Es turpinu drukāšanas lietas tāpat cilvēku vārdiem šodien. Un kas jūtas like-- nebūtu jauki, ja tur bija funkciju sauc print nosaukums? Man nav izmantot printf. Man nav jāatceras visi formāta kodi. Kāpēc ne es, vai kāpēc nebija kāds pirms manis, izveidot funkciju sauc drukāt nosaukums, kas dots kādu vārdu, vienkārši izdrukā to ārā? 

Citiem vārdiem sakot, ja es saku, hey, dators, man virkni lūdzot lietotājam par, piemēram, izmantojot CS50 nokļūt string funkciju. Hey, dators, nodot, ka string mainīgais kreisajā pusē, un zvanu tas s. Un tad, hey dators, iet uz priekšu un izdrukāt, ka personas vārds, darīts. 

Tagad, tas būtu jauki, jo šo programmu, trāpīgi nosaukts, man saka, kas tas ir vajadzēja darīt veidā šie funkcija s nosaukumiem. Ļaujiet man iet un veikt prototipu, Enter. Un, diemžēl, tas nav gatavojas lidot. 

Prototype.c, līnija 7, raksturs 5, kļūda, netieši deklarācija no funkcijas drukas nosaukuma nav spēkā C99, C99 nozīmē versiju C kas iznāca 1999. gadā. Tas ir viss. 

Tāpēc es nezinu, kas tas viss nozīmē vēl. Bet man jāatzīst kļūda sarkanā krāsā. Tas ir diezgan skaidrs. 

Un šķiet, ka ar zaļā raksturs šeit, problēma ir ar drukas vārdu, atveriet paren s, tuvu paren, semikols. Bet netieši deklarācija funkcija mēs redzēt īsumā agrāk. Tas nozīmē, vienkārši, ka šķindēt nezina, ko es domāju. 

Esmu izmantojis vārdu krājums vārdu, ka tas ir nekad redzējis vai mācīts iepriekš. Un tāpēc man ir nepieciešams, lai mācītu to ko šī funkcija nozīmē. Tāpēc es esmu gatavojas iet uz priekšu un darīt. 

Es iešu uz priekšu un īstenot mana funkcija sauc Print vārds. Un es esmu gatavojas teikt, kā izriet, ka tas šo, printf, Labdien, procenti s, slīpsvītru n, nosaukums, semikols. Tātad, ko es vienkārši darīt? 

Tātad izrādās, lai īstenot savu funkciju, mēs veida aizņemties dažus tāda pati struktūra kā galvenais ka mēs esam tikko par pašsaprotamu, un es zinu tikai kopēšanu un līmēšana diezgan daudz, ko Esmu bijis rakstot pagātnē. Bet paziņojums modelis šeit. Int, Main, Void, mēs kaitināt intervālu pirms ilgi, ko tas patiesībā nozīmē. 

Bet šodien, tikai paziņojums paralēlisms. Void, drukāt nosaukums, string vārdu, tāpēc tur ir purpura atslēgvārds, kas mēs esam gatavojas sākt aicinot atgriešanās veidu, nosaukums funkciju, un pēc tam ievadi. Tātad, patiesībā, mēs varam destilēt šāda veida, piemēram, pagājušajā nedēļā jo tas ir vārds vai algoritms kodu mēs esi gatavojas write-- algoritmu pamatā kodu, mēs ejam, lai rakstītu. 

Tas ir tās ieguldījums. Tas ir tā izeja. Šī funkcija, print nosaukums, ir paredzēts veikt virkni sauc nosaukums, vai kāds, kā ievade, un tad spēkā neesošu. Tas neatgriežas neko, piemēram, saņemt virkni vai saņemt int dara. Tātad, tas notiek, lai roku man kaut ko atpakaļ. Tas ir tikai nāksies blakusparādība, tā sakot, izdrukāt personas vārdu. Tātad paziņojums, līnija 7, es var zvanīt drukas nosaukumu. 10 Line, es varu definēt vai īstenot drukas nosaukumu. Bet, diemžēl, tas nav pietiekami. 

Ļaujiet man iet uz priekšu un recompile tas pēc glābšanas. Paga, tagad, es esmu, kas to sliktāk, šķiet. Tātad netieši deklarācija funkcija print nosaukums nav derīgs. Un atkal, tur ir vairāk kļūdas. Bet kā es brīdināja iepriekš, pat ja jums overwhelmed ar, vai mazliet skumji redzēt tik daudz kļūdas, koncentrēties tikai uz pirmo sākumā, jo tas var tikai ir bijusi lavīnveida efekts. Tātad C, vai šķindēt precīzāk, joprojām neatzīst drukas nosaukumu. 

Un tas ir tāpēc, šķindēt, dizains, ir sava veida mēms. Tas tikai tas, ko tu pateikt to darīt. Un tas tikai tā rīkojas, lai kurā jums pateikt to darīt. 

Tāpēc man ir definētas galvenās tiešsaistē četriem, kā mēs esam bijuši dara diezgan bieži. Esmu definēts drukas vārdu uz līnijas 10. Bet es cenšos izmantot print vārds tiešsaistē septiņi. 

Tas ir par agru, nav vēl. Lai es varētu būt gudrs, un būt, piemēram, Labi, tāpēc pieņemsim tikai spēlēt kopā, un pārvietot drukas vārdu augšu šeit, un atkārtoti sastādīt. Ak mans Dievs. Tā strādāja. Tas bija tik vienkārši. 

Bet loģika ir tieši tā. Jums ir iemācīt šķindēt kas tas ir definējot funkciju pirmās. Tad jūs varat izmantot to. Bet, atklāti sakot, tas jūtas kā slidenas nogāzes. 

Tāpēc katru reizi, kad es palaist par problēmu, es esmu tikai dodas, lai izceltu un nokopējiet kodu Es uzrakstīju, sagriež to un ielīmējiet to šeit. Un, protams, mēs varētu pamanīties dažus scenārijus kur viena funkcija varētu jāpiezvana citu. Un jūs vienkārši nevar likt katru funkcija iepriekš katru otro. 

Tātad izrādās, tur ir labāks risinājums. Mēs varam atstāt šo būt. Un, godīgi sakot, tas ir vispār jauki, un ērts, un labs dizains likt galvenais, pirmkārt, tāpēc, ka, atkal, Galvenais, tāpat kā tad, kad zaļo karogu uzklikšķināt, ka ir funkcija, kas izpaužas izpildīts pēc noklusējuma. Tātad, jūs varētu arī nodot tā augšpusē faila lai tad, kad jūs vai kāds cits cilvēks skatās uz failu jūs zināt, kas notiek vienkārši izlasot galvenais pirmās. Tātad izrādās, mēs varam pateikt šķindēt proaktīvi, hey, šķindēt, tiešsaistē četriem, Es apsolu, lai īstenotu funkcija sauc Print Nosaukums, kas ņem string sauc vārdu kā ievade, un atgriež neko, tukšumu. Un es nopirkšu ap to īsteno vēlāk. 

Šeit nāk Main. Galvenais tagad uz līnijas 9 var izmantot Print Name jo šķindēt ir uzticoties, ka, galu galā, tas sastapsies definīciju īstenošanas Print Vārds. Tātad, pēc glābšanas manu failu, ļaujiet man iet uz priekšu un veikt prototipu, izskatās labi šoreiz. Dot slash, prototips, ļaujiet man iet uz priekšu un ierakstiet vārdu. David, hello David, Zamila, hello Zamila, un, protams, tagad tas strādā. 

Tātad sastāvdaļa šeit ir tas, ka mēs esam izgatavoti pielāgotu funkciju, piemēram, pasūtījuma Scratch bloks mēs aicinot to. Bet atšķirībā no nulles, kur var vienkārši izveidot to un sākt to lietot, Tagad mēs jābūt nedaudz vairāk pedantiska, un faktiski apmācīt šķindēt izmantot, vai gaidīt to. Tagad, kā malā, kāpēc visu šo laiku ir mēs bijuši tikai akli uz ticību, tostarp CS50.h, ieskaitot standarta IO.h? 

Nu, izrādās, starp dažām citām lietām, visu, kas ir tajās dot h failus, kas gadās būt failus. Viņi header failus, lai runāt. Viņi joprojām rakstīti C. Bet viņi cita veida failu. 

Tagad, jūs varat diezgan daudz uzņemties ka viss, kas ir iekšpusē CS50.h ir daži viena oderējumi, piemēram, tas, kas nav to funkciju sauc Print Vārds, bet Saņemt String, Get Float, un daži citi. Un tur ir līdzīgi prototipi, vienu oderējumi, iekšpusē standarta IO.h par printf, kura tagad mana Print vārds funkcija. Tātad citiem vārdiem sakot, viss šoreiz mēs esam tikko akli kopējot un ielīmējot ietver šo, ietver tas, kas notiek? Tie ir tikai sava veida clues lai šķindēt par to, kādas funkcijas ir, protams, īsteno, tikai citur dažādiem failiem kaut kur citur uz sistēmu. 

Tāpēc mēs esam jāīsteno drukas nosaukumu. Tas ir šī blakusparādība drukāšanas kaut uz ekrāna. Bet tas nav reāli roku man kaut ko atpakaļ. Kā mēs iet par programmas īstenošanas, kas tas roku man kaut ko atpakaļ? 

Nu, pieņemsim mēģināt šo. Ļaujiet man iet uz priekšu un īstenot fails sauc return.c lai mēs varētu parādīt, kā kaut ko tāpat Saņemt String, vai Get Int, faktiski atgriežas kaut atpakaļ lietotājam. Iesim uz priekšu un noteikt int galvenais tukšumu. 

Un, atkal, ka nākotnē, mēs paskaidrot, kas tas int un ka par spēkā neesošu ir faktiski dara. Bet šodien, mēs ņemt to par pašsaprotamu. Es iešu uz priekšu un printf, par labu lietotāju pieredzi, x ir. Un tad es esmu gatavojas gaidīt lietotājam dod man x ar get int. 

Un tad es iešu uz priekšu un izdrukāt x uz laukuma. Tātad, ja jums ir tikai tastatūras, cilvēki sastopamās izmantot maz burkānu simbols uz klaviatūras pārstāvēt pie varas par vai eksponents. Tātad x kvadrātā ir klāt i. 

Un tagad es esmu gatavojas darīt. Es varētu tikai do-- kas ir x kvadrātā? x kvadrātā ir x reizes x. 

Un mēs to darījām daži laiku atpakaļ jau šodien. Tas nav justies kā viss, kas liels progress. Tu zini ko? Pieņemsim sviras dažas šīs idejas No pēdējo reizi abstrakcijas. 

Vai tas nebūtu jauki, ja tur ir funkcija sauc kvadrātveida, kas dara tieši to? Tas joprojām, beigās no diena, vai to pašu math. Bet pieņemsim abstrakts prom ideja ņemšanas viens numurs reizināts ar vēl viens, un tikai dod tai nosaukumu, tāpat kvadrātveida šo vērtību. 

Un, citiem vārdiem sakot, C, pieņemsim izveidot funkciju sauc laukums, kas dara tieši tā. Tas notiek, lai varētu saukt square. Tas notiek, lai int. Un mēs būs tikai sauc to n, pēc noklusējuma. 

Bet mēs varētu to saucam par kaut ko mēs gribam. Un viss, ka tas notiek, lai do, burtiski, ir atgriešanās rezultāts n reizes n. Bet tāpēc, ka tas ir atgriežoties kaut, kas ir atslēgvārds purpura mēs esam nekad redzējis, es, on line 11, nevar vienkārši pateikt neesošu šoreiz. 

Void, piemērā mēs tikko redzējām drīzāk drukas vārda, tikai nozīmē, dari kaut ko. Bet nav roku man kaut ko atpakaļ. Šajā gadījumā, es gribu atgriezties n reizes n, vai kāds tas ir, ka numurs. 

Tāpēc es nevaru teikt, hey, dators, Es atgriešanās nekas, par spēkā neesošu. Tas notiek, lai atgrieztos, pēc būtības, int. Un tā tas ir viss, kas notiek šeit. 

Ieguldījums kvadrātveida būs int. Un tā, ka mēs varam izmantot, tas ir ir nosaukums, N. Tas būs produkciju int, ka nav nepieciešams nosaukumu. Mēs varam atstāt to galvenais, vai kurš ir izmantojot man atcerēties šo vērtību, ja mēs gribu ar savu mainīgo. 

Un atkal, vienīgais jaunais atslēgvārds šeit ir atgriešanās. Un es esmu tikai darot daži math. Ja es patiešām gribēju būt lieka, Es varētu teikt int produkts saņem n reizes n. 

Un tad es varētu teikt, atgriezt produktu. Bet, atkal, lai manām agrāk par tas vienkārši nav ir labi design-- piemēram, kāpēc ieviest vārdu, simbols, piemēram, produktu, tikai, lai uzreiz atdod to? Tas ir nedaudz tīrāku, nedaudz stingrāka, tāpēc runāt, vienkārši pateikt atgriešanās n reizes n, atbrīvoties no šīs līnijas vispār. 

Un tas ir tikai mazāk kodu, lai lasītu, mazāk iespēju kļūdām. Un pieņemsim redzēt, ja tas faktiski tagad strādā. Tagad es iešu priekšu un veikt peļņu. 

Uh-oh, netieši deklarācija funkciju. Es šo kļūdu pirms, nav liels darījumu. Ļaujiet man vienkārši ierakstiet, vai iezīmējiet un kopēt, tieši tādu pašu funkciju prototips, vai paraksts, no funkcijas šeit. Vai es varētu pārvietot visu funkciju. 

Bet tas ir mazliet slinks. Tātad mums nebūs darīt. Tagad, ļaujiet man atgriezties atkal dot slash atdevi. 

x ir 2 x kvadrātā ir 4. x ir 3. x kvadrātā ir 9. Un funkcija, šķiet, tagad strādā. Tātad, kāda ir atšķirība šeit? Man ir funkcija, kas ir sauc kvadrāts, šajā gadījumā, ko es likts uz ieejas. Un es nokļūt atpakaļ izejas. Un tomēr, agrāk, ja Es atvērt otru piemēru no agrāk, kura sauca prototype.c, Man bija drukas nosaukumu, kas atgriezās spēkā neesošu, tā sakot, Vai tas atgriezās neko, un vienkārši bija blakusparādība. 

Tātad, kas notiek šeit? Nu, apsvērt funkciju saņemt virkni tikai brīdi. Mēs esam, izmantojot funkciju saņemt virkni šādā veidā. 

Mēs esam bija funkcija nokļūt stīgu, tāpat ietver CS50.h, ietver standarta IO.h, INT, galvenais, par spēkā neesošu. Un tad katru reizi, kad es esmu sauc get string līdz šim, Es esmu teica kaut ko līdzīgu, stīgu s izpaužas saņemt virkni, jo get string-- sauksim šo get.c-- get virknes pati atgriež virkni, kas es varu tad izmantot, un teikt, hello, komats, procenti s, slīpsvītru n, s. 

Tātad, tas ir tas pats piemērs, tiešām, ka mums bija agrāk. Tātad iegūt string atgriež vērtību. Bet pirms brīža, print stīgu neatgriež vērtību. Tā vienkārši ir blakusparādība. Tātad šī ir būtiska atšķirība. Mēs esam redzējuši atšķirīgs veidu funkcijas tagad, no kuriem daži ir atgriezušies vērtības, no kuriem daži nav. Tātad, varbūt tas ir string, vai int vai peldēt. Vai varbūt tas ir tikai par spēkā neesošu. 

Un atšķirība ir ka šīs funkcijas, kas iegūtu datus un atgriež vērtību, ir faktiski celt kaut ko atpakaļ uz galda, tā sakot. So iesim uz priekšu un apskatīt vienu gala komplektu piemēri, kas rada sajūtu, tagad, no kā mēs varētu, protams, abstrakts labāk, un labāk, un labāk, vai vairāk, un vairāk, un vairāk, lai rakstīt, visbeidzot, labāku kodu. Iesim uz priekšu, un garā no nulles, rīkojieties šādi. 

Ļaujiet man iet uz priekšu un ietver CS50.h un standarta IO.h. Ļaujiet man iet uz priekšu un dot pats int, galvenais, par spēkā neesošu. Un ļaujiet man iet uz priekšu, nosaukt šo cough.c. 

Un ļaujiet man iet uz priekšu un tikai piemēram, nulles, izdrukāt klepus / n. Un es gribu to darīt trīs reizes. Tāpēc es esmu, protams, tikai iet kopēt un ielīmēt trīs reizes. Es tagad gatavojas darīt klepus dot slash klepus. Pieņemsim dot sev nedaudz vairāk vietas šeit, Enter, klepus, klepus, klepus. 

Ir, protams, jau ir iespēja uzlabojumi. Es esmu kopēt un ielīmēt dažas reizes jau šodien. Bet tas bija tikai tāpēc man nav ir rakstīt tik daudz rakstzīmes. Es joprojām mainīts ko šie rindas kods ir. 

Šie trīs līnijas ir vienādas, kas jūtas slinks un tiešām ir, un, iespējams, nav pareizā pieeja. Tātad, ar ko sastāvdaļa mēs varētu uzlabot šo kodu? Mums nav kopēt un ielīmēt kodu. 

Un, protams, jebkurā laikā jūs jūtaties yourself kopējot un ielīmējot, un nav pat mainīt kodu, izredzes ir tur ir labāks veids. Un, protams, tur ir. Ļaujiet man iet uz priekšu un darīt uz cilpas, pat ja sintakse var nebūt nāk dabiski vēl. 

Vai šo trīs reizes, vienkārši darot to following-- un es zinu, tas no prakses. Bet mums ir vairāki piemēri tagad. Un jūs redzēsiet online vairāk norādes joprojām. 

Tas ir sintakse par 6 līniju, kas līdzīgi nulles, kas atkārtojas bloks, atkārtot šādas trīs reizes. Tas ir mazliet burvju tagad. Bet tas iegūs vairāk, un vairāk pazīstams. 

Un tas notiek atkārtot line astoņas trīs reizes, tā ka, ja es atkārtoti sastādīt make klepus, dot slash klepus, klepus, klepus, klepus. Tas joprojām darbojas tāpat. Tā ka viss ir labi un labs. Bet tas nav ļoti nošķirts. 

Tas ir pilnīgi pareizi. Bet, tā uzskata, tāpat tur varētu būt iespēja, kā pasaulē Scratch, lai veida sākuma pievienot dažas semantiku šeit, lai Man nav vienkārši ir daži cilpa, un funkcija, kas saka klepus, vai arī klepus. Tu zini ko? Ļaujiet man mēģināt būt nedaudz vēsāks, nekā, un faktiski uzrakstīt funkciju, kas ir dažas blakusparādības, sauc to klepus. 

Un tas notiek ne ievadi, un atgriež nekādas vērtības kā produkciju. Bet jūs zināt, ko tā dara? Tas this-- printf, quote likt pēdiņas beigās, klepus. 

Un tagad šeit, es esmu gatavojas iet uz priekšu un uz int, i saņem nulli, i mazāk nekā 3, i plus plus. Es esmu gatavojas nedara printf, kas ir varbūt zems īstenošana detaļa. Man vienalga, kā klepus. Es tikai vēlos, lai izmantotu klepus funkciju. Un es esmu tikai gatavojas zvanīt klepus. 

Tagad paziņojums dihotomiju. Kad zvanāt funkciju, ja jums nav vēlas, lai dotu to izejvielas, pilnīgi naudas sodu. Just do atvērt iekava, close paren, un jūs darīts. 

Kad jūs noteikt funkciju, vai pasludināt funkcija ir prototips, ja jūs jau iepriekš zināt, ka tas nav gatavojas veikt nekādus argumentus, teikt neesošu šajās iekavās tur. Un kas padara pārliecināts, ka jums nebūs nejauši nepareizi to. Ļaujiet man iet uz priekšu un darīt klepus. Un, protams, es esmu kļūdījies. 

Nolāpīts, tur ir, ka netiešs deklarācija. Bet tas ir jauki. Tas ir viegli noteikt. Man tikai vajag prototips augstāk manā failā, nekā es esmu faktiski izmanto. 

Tāpēc tagad ļaujiet man klepus atkal, jauki. Tagad tā darbojas. Padarīt klepus, klepus, klepus, klepus. Tātad jūs varētu domāt, ka mēs esam patiesi tikai nedaudz vairāk engineering šo problēmu. Un, protams, mēs esam. Tas nav labi kandidāts programmu šobrīd par refactoring, un dara to, kas ir sauc hierarhiska sadalīšanās, kur jūs lietojat kādu kodu, un pēc tam jūs veida faktors lietas, tāpēc kā piedēvēt vairāk semantika tiem, un atkārtoti to galu galā ilgtermiņā. Bet tas ir pamatelements virzienā sarežģītākus programmas ka mēs sāksim rakstiski pirms ilgi, ka ļauj mums būt vārdu krājumu ar ko rakstīt labāk kodu. Un, protams, pieņemsim redzēt, ja mēs nevar vispārināt šo tālāk. 

Šķiet mazliet klibs, kas man, galvenais, jāuztraucas par šo darn uz cilpas, un aicinot klepus atkal un atkal. Kāpēc es nevaru vienkārši pateikt klepus, lūdzu klepus trīs reizes? Citiem vārdiem sakot, kāpēc es nevaru vienkārši dot ieguldījumu klepus un darīt? 

Kāpēc es nevaru vienkārši pateikt, jo Galvenais klepus trīs reizes. Un tagad, tas ir sava veida burvju. Tas ir ļoti iteratīvs šeit. Un tas, protams, bērnu soli. 

Bet tikai spēja pateikt par line astoņi, klepus trīs reizes, tas ir tikai tik daudz vieglāk lasāmu. Un, plus, man nav jāzina vai aprūpi, kā klepus tiek īstenota. Un, protams, vēlāk ilgtermiņa un gala projektiem, ja jūs risināt projektu ar klasesbiedrs vai divi klasesbiedru, jūs apzināties, ka jūs gatavojas ir, vai vēlaties, sadalīt darbus. 

Un jūs gatavojas vēlaties, lai izlemtu iepriekš, kurš gatavojas darīt to, ko, un kurā gabali? Un vai tas nebūtu jauki ja jūs, piemēram, uzņemties atbildību par rakstīšanas Main, darīts. Un jūsu kaimiņiem, vai jūsu partneris vispārīgāk, rūpējas par īstenošanas klepus. 

Un šī nodaļa, šie sienas abstrakcijas, vai slāņi abstrakcijas ja Jums ir super spēcīga, jo īpaši lielāks, sarežģītākas programmas un sistēmas, tas ļauj vairākiem cilvēkiem veidot lietas kopā, un galu galā valdziņš savu darbu kopā šādā veidā. Bet, protams, mēs vajag tagad noteikt klepus. Mums ir nepieciešams, lai pastāstītu klepus ka, hey, jūs zināt, ko? Jūs esat dodas uz nepieciešamību veikt input-- tāpēc ne par spēkā neesošu, bet int un tagad. Iesim uz priekšu un nodot klepus int. i izpaužas nulli. 

i ir mazāks nekā, cik reižu. Es teicu trīs iepriekš. Bet tas nav tas, ko es gribu. Es gribu klepus tikt vispārināti uz atbalstītu jebkuru iterāciju. 

Tātad, protams, tas ir n, ka es gribu, kāds lietotājs man saka. Tagad es varu iet uz priekšu un teikt drukas klepus. Un nav svarīgi, ko numurs lietotājs caurlaides, Es atkārtot, ka daudzas reizes. 

Tātad beigās, dienā, Programma ir identisks. Bet paziņojums visu šo stuff pat varētu būt citā failā. Patiesi, es nezinu, pie moments kā printf tiek īstenota. 

Es nezinu, brīdī, kā nokļūt string, vai saņemt int, vai iegūt peldēt tiek īstenoti. Un es negribu redzēt tos uz mana ekrāna. Kā tas ir, es esmu sāk pievērsties mana programma, nav šīs funkcijas. 

Un tā, protams, tiklīdz jūs sākt faktoringa kodu, piemēram, šo, mēs pat varētu virzīties klepus atsevišķā failā? Kāds cits varētu īstenot. Un jūs un jūsu programma kļuvusi ļoti skaisti, un viegli uztverams, varbūt, tiešām četri line programma turpat. 

So iesim uz priekšu tagad un veikt vēl vienu maiņu. Ievērojiet, ka mans prototips ir jāmaina uz augšu top. Tāpēc ļaujiet man noteikt, ka tā Man nav get kliedza uz. 

Padarīt klepus, ļaujiet man palaist klepus reizi vairāk, tomēr dara to pašu. Bet tagad, ievērosiet, mums ir sastāvdaļa vienu galīgo versiju. Tu zini ko? Es nevēlos, lai tikai klepus, obligāti. Es gribu, lai būtu kaut ko vispārīgu. Tātad, jūs zināt, ko? Es gribu to darīt. Es gribu būt, līdzīgi Scratch tas, paust viedokli bloks, bet ne tikai pateikt kaut kādu skaitu reižu. Es gribu to pateikt ļoti konkrētu virkni. Un tāpēc man nav vēlaties, lai vienkārši pateikt klepus. Es gribu to teikt visu virkne ir pieņemts. 

Tātad paziņojums, es esmu ģeneralizētas tas tā, ka tagad teiksim jūtas kā labā slava par šo, piemēram, nulles, aizņem divus argumentus, atšķirībā no nulles. Viens no tiem ir virkne. Viens ir int. 

Un es varētu ieslēgt tās. Es tikko veida, piemēram, ideju saka stīgu vispirms, un pēc tam cik reizes vēlāk. Void nozīmē to joprojām neatgriežas neko. Šie ir tikai vizuāla side efekti, piemēram, ar [? Jordan,?] mutiski blakusparādība kliegt. Tas joprojām nav kaut kas n reizes, 0 līdz, bet ne vienāds ar n. Tas nozīmē, n kopējais reizes. Un tad tikai izdrukāt lai kas virkne ir. Tāpēc es esmu patiešām vispārināt šī līnija kodu. Tāpēc tagad, kā es varu īstenot klepus funkcija? 

Es varu darīt spēkā neesošu klepus. Un es vēl joprojām var uzņemt kā daudzas reizes jūs vēlaties klepus. Bet jūs zināt, ko? Es tagad var punt teikt. 

Es varu zvanīt teikt ar vārds klepus, kas iet n. Un, ja es gribu arī īstenot, tikai par jautru, šķaudīt funkcija, Es varu šķaudīt kādu vairākas reizes. Un es varu paturēt atkārtoti N, jo paziņojums, ka m šajā kontekstā vai darbības jomu eksistē tikai šo funkciju. 

Un n šajā kontekstā tikai pastāv šajā funkciju šeit. Tātad mēs būsim atpakaļ uz šie jautājumi jomu. Un šeit, es esmu tikai gatavojas teikt, achoo, un pēc tam n reizes, semikols. 

Un tagad, man ir nepieciešams aizņemties šie funkcija paraksti šeit. Tātad klepus ir pareiza. Void šķaudīt ir pareiza tagad. 

Un es vēl tikai vajag teikt. Tāpēc es esmu gatavojas teikt, teiksim string s, int n, semikols. Tāpēc es esmu pār-inženierijas heck no šīs programmas. 

Un tas nav nenozīmē tas ir ko jums vajadzētu darīt, rakstot pat visvienkāršāko programmu. Ņem kaut kas acīmredzot patiešām vienkārša, ļoti īss, un atkārtoti īstenot izmantojot pārāk daudz kodu. Bet jūs faktiski redzēt, un laiks atskatīties uz šiem piemēriem, un realizēt, ak, tie ir soļi mēs ņēmām faktiski vispārināt, faktors kaut ko, līdz beigās, dienā mans kods ir faktiski diezgan saprātīgs. Jo, ja es gribu klepus trīs reizes, tad šķaudīt trīs reizes, Es esmu vienkārši gatavojas atkārto šo, programma padarīt klepus, un palaist klepus. Un man ir trīs klepus un trīs klepojot. 

Un tā tas ir pamata paradigma, ja jūs, par to, kā mēs varētu iet par faktiski īsteno programmu. Bet pieņemsim tikai redzēt, tagad to, kas tas ir mēs esam bijuši dara visu šo laiku, un ko daži no gala gabalu ir aiz šo vienkāršo komandu. Beigās, dienā, mēs esam bijis, izmantojot šķindēt kā mūsu kompilatoru. Mēs esam rakstiski avots kods, pārvēršot to via šķindēt mašīnu kodu. 

Un mēs esam izmantojuši Make tikko atvieglot mūsu keystrokes tik ka mums nav jāatceras šie buramvārdi no pašas šķindēt. Bet kas ir Make patiesībā dara? Un, savukārt, kas ir Šķindēt faktiski dara? 

Izrādās, lai gan mēs esam vienkāršoti šodienas diskusija, sakot, Jūs lietojat pirmkodu, nodot to kā ieeja ar kompilatoru, kas dod jums izlaide mašīna kods, izrādās tur ir daži dažādu soļi iekšā tur. Un apkopojot notiek, ir jumta termins visu ķekars soļiem. Bet pieņemsim tikai kaitināt šo, tiešām ātri. 

Izrādās, ka mēs esam bijuši dara vairāk lietas katru reizi, kad es palaist programmu, vai katru reizi, kad es sastādīt programmu šodien. Tātad preprocessing attiecas uz this-- kaut kādā C programmu, kā mēs redzēsim atkal un atkal, kas sākas ar šo hash simbolu, vai hashtag simbols šeit, nozīmē tas ir apstrādātāju direktīva. Tas nozīmē, ka šajā gadījumā, hey dators, kaut ko darīt ar šo failu Pirms jūs faktiski sastādīt savu kodu. 

Šajā gadījumā, hash ietver ir, būtībā, C veids, kā pateikt, hey dators, iet saņemt saturu no CS50.h un ielīmēt tos šeit. Hey dators, iet saņemt saturs standarta IO.h, kur tas ir par cietais disks, ielīmējiet to šeit. Tātad šīs lietas notiek Pirmais preprocessing laikā. 

Un šķindēt dara visu par mums. Un tas tiek darīts tik darn ātri, jums nav pat redzēt četras atšķirīgas lietas notiek. Bet tas ir pirmais šāds solis. 

Kas patiesībā notiek tālāk? Nu, nākamais amatpersona solis ir apkopošanai. Un izrādās, ka apkopojot programmu tehniski nozīmē iet no pirmkodu, sīkumi mēs esam rakstot šodien, lai kaut ko sauc montāža kods, kaut kas izskatās nedaudz atšķiras. 

Un, patiesībā, mēs varam redzēt šo nekustamo ātri. Ļaujiet man tiešām iet manā IDE. Ļaujiet man iet uz priekšu un atvērta hello.c, kas ir pirmā programma, ar kuru mēs sākās šodien. Un ļaujiet man iet uz priekšu un palaist šķindēt A nedaudz savādāk, šķindēt-s, hello.c, kas ir patiešām gatavojas dod man citu failu hello.s. 

Un mēs, iespējams, nekad atkal redzēt šāda veida kodu. Ja esat lietojis zemāka līmeņa sistēmas klases, piemēram, CS61, jūs redzēsiet daudz vairāk no šāda veida koda. Bet tas ir montāža valoda. Tas ir X86 montāža valoda ka CPU, kas ir pamatā CS50 IDE tiešām saprot. 

Un noslēpumains kā tas izskatās, tas ir kaut kas dators saprot diezgan labi. Sub q, tas ir atņemt. Tur ir kustības. 

Tur zvana funkciju šeit, x oring, kustība, add, pop, atgriešanās. Tātad tur ir daži ļoti zema līmeņa norādījumi ka CPU saprast, ka Man norādīja uz agrāk. Tas ir tas, ko Intel Inside. 

Ir modeļi nullēm un tiem, kas karti šiem arcanely formulēts, bet nedaudz labi nosaukts, instrukcijas, tā sakot. Tas ir tas, kas notiek, kad jūs sastādīt savu kodu. Jūs saņemsiet montāža valoda no tā, kas nozīmē, trešais solis ir apkopot ka montāža kodu, galu galā, mašīna code-- nullēm un uzņēmumiem, nevis teksts, mēs tikko redzējām pirms brīža. 

Tātad pirmapstrāde tas, ka atrast un aizstāt, un dažas citas lietas. Apkopojot ņem savu avotu kodu no C, kods ka mēs rakstījām, lai montāža kods, kas mēs vienkārši paskatījās. Montāža aizņem ka montāža kods uz nulles un vieninieku ka CPU tiešām būs saprast beigās, dienā. Un saistot ir pēdējais solis kas notiek uz us-- atkal, tik ātri mums nav pat notice-- kas saka, hey dators, veikt visus nullēm un tiem, kas radies apkopojot Dāvida kodu, un viņa galvenā funkcija šajā gadījumā. 

Un hey dators, iet saņemt visi no nullēm un tiem ka CS50 darbinieki uzrakstīja iekšpusē CS50 bibliotēkā. Sajauc tos ar David s. Un hey dators, iet saņemt visus nullēm un tie, kas kāds cits rakstīja gadi atpakaļ uz printf. Un pievienot tiem Into viss, lai mēs esam got manu nullēm un tiem, tad CS50 personāla nullēm un tiem, printf nullēm un tiem, un kaut kas cits, mēs esam, izmantojot. 

Viņi visi iegūt apvieno vienā programmu, ko sauc, šajā gadījumā, hello. Tātad turpmāk, mēs vienkārši izmantot vārdu sagatavošanā. Un mēs uzskatām par pašsaprotamu, ka tad, kad mēs sakām, sastādīt savu programmu, tas nozīmē, hey darīt priekšapstrādi, montāža, un savieno. Bet tur tiešām daži sulīgs sīkumi notiek tur zem motora pārsega. Un jo īpaši, ja jums saņemt ziņkārīgs kādu laiku, Jūs varat sākt poking ap šo zemāko līmeni. Bet tagad, saproti, ka starp takeaways par šodienu ir diezgan vienkārši sākot no procesa, iegūt apmierināti ar kaut kā Hello pasaulē. Patiešām, lielākā daļa no tā, ko mēs darījām šodien noteikti nebūs izlietne super ātri. Un tas prasīs kādu laiks, un daži prakse. Un izredzes ir, jums būs kārtot no vēlas, lai sasniegtu jūsu tastatūru vai kliegt uz ekrānu. Un visi, kas ir OK. Lai gan, iespējams, mēģiniet nav darīt to bibliotēkā tik daudz. 

Un galu galā, jūs ir iespēja, lai gan, lai sāktu redzot modeļus, gan labā kodu ka jūs esat rakstiski un kļūdām ka jūs esat veikuši. Un līdzīgi procesā kļūstot TF vai CA ir līdzīgs, jūs sākat iegūt labāku un labāk redzot šos modeļus, un vienkārši atrisināt jūsu pašu problēmas galu galā. Pa to laiku, būs daudz no mums aizdot jums atbalstu, un saņemt jūs caur šo. Un rakstīt-ups lai visas problēmas jūs vadīties caur visi no komandas ka es noteikti zinu no daudz prakses, ko tagad, bet, iespējams, ir lidojuši virs galvas tagad. Un tas ir pilnīgi naudas sodu. 

Bet, galu galā, jūs gatavojas lai sāktu redzēt modeļus parādīties. Un, kad jums pēdējo visi stulbie detaļas, piemēram, iekavās, un cirtaini bikšturi, un semikoli, un sīkumi, atklāti sakot, ka nav vispār intelektuāli interesanti. Un tas nav mērķis jebkāda ievada klasi. Ir idejas, kas gatavojas jautājums. 

Tas ir cilpas, un nosacījumiem, un funkcijas, un vēl spēcīgi ieguve, un faktoringa kodu, un labs dizains, un labi stils, un galu galā pareizību par savu kodu, tas galu galā gatavojas jautājums visvairāk. Tātad nākamnedēļ, mēs veiksim šos idejas, ka mēs pirmo reizi ieraudzīja uz nulles un tagad tulkoti ar C Un mēs sāksim iepazīstināt pirmo no Protams patiesais pasaules domēni. 

Mēs koncentrējamies uz pasaules drošībai, un precīzāk kriptogrāfija, māksla kodēšanas informāciju. Un viens no pirmajiem problēmas tu pats būs iespēja rakstīt tālāk spēlē ar dažiem sintakse un risinot daži loģiski problēmas, galu galā pirms ilgi, ir faktiski motokross, vai šifrētu, un galu galā atšifrēt informāciju. Un viss, ko mēs esam darījuši šodien, būs diezgan zems līmenis, ir tikai gatavojas, lai ļautu mums veikt vienu, un viens, un vēl viens solis pretī iepriekš rakstiski interesantāko kodu vēl. 

Tik daudz par šo nākamnedēļ. 

[VIDEO PLAYBACK] 

-Ko Jūs varat man pastāstīt par pēdējo reizi redzējāt viņu? -Ko Es varu teikt, tiešām? Es domāju, tas bija kā jebkura cita pre-production mēģinājumu, izņemot tur bija kaut viņš teica pašās beigās, kas iestrēdzis ar mani. 

-Tas Bija CS50. 

-That Ir samazināt ikvienam, liels darbs uz mēģinājumu. 

-That S pusdienas? 

-Yeah, Tu un es varu paķert sviestmaizi mazliet. Ļaujiet man tikai debrief ar David tiešām ātri. David? David? 

[END PLAYBACK] 