[MUSIC PLAYING] 

Ini adalah CS50-- Harvard pengenalan universitas dengan intelektual perusahaan ilmu komputer dan seni pemrograman. Dan nama saya David Malan, dan Aku hanya berpikir pagi ini, itu sudah biasa 20 tahun hari ini sejak saya terakhir duduk di mana kalian lakukan sekarang. 

Itu 1996. Aku kelas satu, dan saya mengambil CS50 untuk pertama kalinya. Dan aku bahkan tidak mendapat up saraf untuk mengambil sendiri tahun pertama, sebagian karena waktu. ilmu komputer untuk me adalah jenis seperti, meh. Saya sedikit geek tumbuh up, tapi aku tidak benar-benar memiliki intelektual minat pada apa yang muncul hanya menjadi sekelompok seluruh orang pemrograman sepanjang waktu. 

Dan aku takut untuk jujur. Kursus dan ilmu komputer lebih umumnya memiliki dan sampai batas tertentu, masih memiliki reputasi ini lapangan untuk berhati-hatilah, jika hanya karena begitu banyak dari kita tidak terbiasa dengan hal itu dan yakin itu. Dan itu benar-benar tidak sampai saya berbelanja kelas ini yang sophomore fall-- dan bahkan kemudian, saya hanya terdaftar karena professor-- yang salah satu mentor pertama saya, Brian Kernighan sekarang di Princeton-- memungkinkan saya untuk mengambil kelas lulus gagal. Dan memang, itulah sebabnya hari ini kita memungkinkan dan mendorong siswa untuk mengambil kelas ini duduk / unsat. 

Dan hanya kemudian, dengan akhir semester aku menyadari seperti, wow, ini itu bukan bidang yang asing tersebut. Memang, ini adalah bidang yang sangat memberdayakan, dan lebih menggairahkan, terutama di kemudian hari, saya mengambil kursus di Seni Drama 101 dan Latin A dan kemudian akhirnya arkeologi sekolah pascasarjana, aku benar-benar mulai untuk melihat persimpangan dari bidang ini, komputer ilmu pengetahuan, dengan humaniora, ilmu alam, seni, kedokteran, dan sejenisnya. Dan itulah yang hanya begitu rapi tentang ilmu komputer akhirnya, karena kami berharap Anda akan see-- adalah penerapannya untuk bidang-bidang lainnya, dan bagaimana Anda dapat mengambil beberapa hari ini dan semester ini ide-ide dan keterampilan praktis kembali ke domain Anda sendiri, dan benar-benar mengeksplorasi persimpangan ini seni liberal dan ilmu. 

Jadi 73% dari Anda, jika lalu tahun adalah indikasi, tidak pernah mengambil kursus CS sebelumnya. Jadi jika, seperti saya, Anda merasa sedikit takut, atau terus terang Anda tidak benar-benar yakin mengapa kau bahkan di sini. Mungkin Anda hanya mengikuti beberapa teman ke Sanders sekarang. Itu benar-benar baik-baik saja. Tujuannya di sini adalah untuk menghubungkan Anda dan untuk meyakinkan Anda bahwa jika Anda melihat ke kiri dan ke kanan, Anda akan melihat teman sekelas dengan sesedikit atau banyak pengalaman bahwa Anda sendiri mungkin. Dan memang, kami akan berbagi beberapa statistik hari ini seperti apa demografi kelas biasanya terlihat seperti. 

Dan sebagai tambahan reassurance-- dan kami ini maksud sejak saya mengambil alih kursus beberapa tahun ago-- di silabus kursus ini adalah ini-- bahwa apa akhirnya hal dalam kursus ini tidak begitu banyak di mana Anda berakhir up relatif terhadap teman sekelas Anda, tetapi di mana Anda di minggu 11, akhir semester, akhirnya relatif terhadap diri sendiri di minggu 0, yang merupakan di mana kita berada di sini hari ini. Dan ini adalah apa yang saya menyadari bertahun-tahun lalu. Dan saya tahu banyak Kelas mengatakan ini, tapi itu terutama berlaku dalam ilmu komputer. Pada akhir hari, bidang ini tidak familiar seperti itu kepada saya dan mungkin untuk Anda, benar-benar hanya tentang pemecahan masalah. Dan dengan demikian, itu memang memiliki ini penerapan untuk mendapatkan bidang lainnya. Dan pada kenyataannya, jika kita mencoba untuk menyaring apa artinya ini, ini adalah pemecahan masalah pada intinya, aku yakin. Ada input-- sehingga apa pun adalah bahwa Anda sedang berusaha untuk memecahkan. Ada output, yang mudah-mudahan solusi untuk masalah itu. Dan kemudian, seperti yang kita akan mengatakan dalam ilmu komputer, ada kotak hitam ini di tengah yang Anda lakukan belum tentu harus peduli tentang cara kerjanya. Anda sendiri akhirnya mungkin menerapkan apa di dalam kotak itu. Tapi untuk tujuan hari ini dan lebih umumnya dalam kehidupan, semua yang Anda pedulikan adalah bahwa masalah ini bisa diselesaikan. 

Dan apa saja hal ini akhirnya sekitar sedang menjajaki persimpangan input ini dan output, dan ini disebut algoritma, karena kami akan segera melihat, yang menerapkan apa yang di bawahnya ada, tenda. Tapi masukan tersebut dan ini outputs-- apa yang benar-benar berarti? Nah, di akhir hari, kita perlu beberapa cara untuk mewakili informasi. Hal ini terutama berlaku di komputer, yang semewah dan kompleks karena mungkin tampak, adalah perangkat yang cukup bodoh. Dibutuhkan listrik-- apakah dari kabel atau baterai sebagai input-- dan kemudian menghasilkan beberapa tanggapan preprogramed di layar. 

Tapi bagaimana kita dapatkan dari awal sampai akhir ada? Nah, apa yang masalah yang harus diselesaikan? Yah, mungkin kita mungkin, di awal semester apapun, mencoba untuk mengambil absensi di ruang seperti ini. Jadi saya akan melakukannya seperti satu, dua, tiga. Atau mungkin, jika saya melakukannya untuk semacam melacak dari myself-- untuk melacak things-- Aku bisa cepat kehabisan jari. Jadi saya mungkin hanya membuat hash marks-- satu orang, dua, tiga, empat, lima, enam, tujuh delapan. Dan kita semua memiliki mungkin melakukan ini, apakah di tangan Anda atau pada selembar kertas. Dan ini sebenarnya hanya sesuatu yang disebut unary notation-- di mana jika Anda hanya memiliki satu huruf dalam alfabet Anda, satu atau hash mark dalam kasus ini, untuk setiap masukan Anda ingin menghitung, Anda perlu meletakkan salah satu dari ini letters-- salah satu tanda ini. 

Baiklah. Itu semua baik dan bagus dan tidak semua yang rumit. Tetapi komputer tidak semua yang jauh lebih rumit. Memang, sebagian besar dari Anda mungkin tahu bahkan jika Anda sudah benar-benar dianggap apa ini berarti, bahwa komputer hanya mengerti angka nol dan ones-- yang disebut sistem biner. Kita manusia, sebaliknya, begitu jauh lebih canggih sepanjang seperti yang kita mengerti nol melalui sembilan. 

Tetapi bahkan jika biner adalah, pada awalnya Sekilas, tidak semua yang akrab, ternyata itu hanya seperti sistem dan ide-ide yang kita sudah tahu. Jadi misalnya, menganggap ini. Ini hanya urutan simbol. Dan kalian semua, ketika melirik itu, mungkin berpikir 123-- apa-apa benar-benar menarik di sana. Tapi mengapa nomor ini, 123? Ini hanya mesin terbang pada screen-- hanya pola bahwa seseorang mungkin telah ditarik atau diketik. Tetapi jika Anda seperti saya, Anda mungkin ingat dari sekolah dasar bahwa ada semacam kolom atau tempat di sini. Ada tempat seseorang dan Tempat sepuluh dan tempat ratus ini. Dan alasan bahwa ini adalah 123 dan bukan hanya pola tiga simbol karena, tentu saja, jika kita memiliki satu di tempat ratusan, Anda melakukan matematika dari 100 kali satu, dan kemudian dua di tempat sepuluh ini. Jadi itu 10 kali 2, dan kemudian tiga di tempat seseorang dan itu 1 kali 3. Dan ketika Anda menambahkan semua orang up, dari Tentu saja, Anda mendapatkan 100 ditambah 20 ditambah 3. 

Jadi kita mulai dengan hanya pola dari symbols-- sebuah alphabet-- tapi kemudian kami dipetakan makna ke dengan cara kolom ini. Nah, ternyata komputer benar-benar tidak semua yang berbeda dari Anda dan saya. Tapi alih-alih menggunakan kekuatan 10, sehingga untuk speak-- 1, 10, 100, 1000, 10.000 tempat dan sebagainya forth-- mereka benar-benar hanya menggunakan kekuatan 2-- jadi satu, 2, 4, dan kemudian jika kita menempatkan lebih banyak digit, 8, 16, 32, 64, 128, dan sebagainya. Dan jadi ini adalah bagaimana komputer akan merupakan jumlah 0, sama seperti kita manusia. 

0, 0, 0-- dan Anda mungkin bisa menebak apa pola nol dan satu, jika komputer hanya dapat berbicara 0 atau 1-- apa Pola akan mewakili jumlah kita manusia kenal sebagai 1? Yeah 0, 0, 1. Baiklah. Jadi 0, 0, 1 adalah bagaimana kami mewakili 1, sehingga Anda mungkin cenderung maka untuk mewakili nomor 2, jika Anda memiliki Tempat keempat dan tempat kedua ini sebagai satu tempat, Anda mungkin berkata, baik, jika kita memiliki 1 di tempat seseorang, dan sekarang kami ingin menghitung sampai 2, Anda mungkin melakukan ini dan meninggalkan ini menjadi nol. Tapi tentu saja ini bukan cara sistem desimal bekerja baik. Jika Anda menempatkan digit di kedua kolom tersebut, Anda harus melakukan aritmatika. Jadi jumlah apa yang saya sengaja hanya mewakili? 

Jadi itu 3, karena 2 kali 1 ditambah 1 kali 1, tentu saja, memberi kita tiga. Jadi ini akan menjadi dua. bit semacam membalik, sehingga untuk berbicara, sebagai 0 menjadi salah satu yang, seperti sebuah 9 peran lebih dan menjadi 0 saat membawa 1. Hal ini kemudian akan menjadi tiga saja. Four-- hal lain yang menarik terjadi, di mana orang-orang berguling dan Anda membawa 1, sehingga untuk berbicara. Jadi ini, tentu saja, adalah 4. 

Tapi jika Anda maju cepat sekarang, apa jumlah terbesar terjadi menjadi bahwa komputer dapat mewakili? Jadi itu hanya tujuh dalam kasus ini, kan? Karena Anda memiliki satu di empat, satu di dua, satu di salah satu. Jadi itulah 4 ditambah 2 ditambah 1. Sehingga memberikan tujuh. Dan memang, itu akan tampak pada pandangan pertama bahwa komputer dapat menghitung tidak lebih tinggi dari ini. 

Tapi ini tentu saja tidak benar. Apa yang kita manusia lakukan ketika kita ingin untuk menghitung tinggi daripada seperti 999? Hanya membawa satu dan hanya menambahkan digit keempat ke kiri. Dan memang kita bisa. Kita bisa memiliki delapan ini tempat dan tempat ke-16 ini, dan tempat 32 ini, 64, 128-- dan Anda hanya bisa terus terjadi sampai tak terhingga. Jadi nol ini dan ones-- yang disebut system-- biner adalah apa yang seorang ilmuwan komputer akan umumnya menyebutnya sedikit, atau digit biner. 

Tapi sekarang, bagaimana kita dapatkan dari konsep atau grafis dari hal-hal ini ke komputer yang sebenarnya? Kami tampaknya akan melewatkan langkah di sini. Nah, satu-satunya masukan pada akhir hari, untuk laptop saya di sini adalah aliran ini listrik. Bahkan jika itu sudah lama waktu karena Anda berpikir tentang atau tidak pernah berpikir tentang bagaimana listrik bekerja, ada elektron yang mengalir di atau keluar, dan itu semacam saya masukan. 

Jadi, jika itu yang kita mendapatkan sebagai masukan di sini, apa yang bisa kita lakukan dengan informasi itu? Yah, kita mungkin berpikir dari nol sebagai hanya ketiadaan listrik. Tidak ada yang flowinw, tidak ada yang bergerak, tidak ada yang terjadi. Itu hanya default state-- nol. Tetapi jika ada listrik yang mengalir, mengapa tidak kita hanya sewenang-wenang, tapi secara global konsisten, menyebut bahwa salah satu a. 

Jadi hanya dengan memiliki kekuatan, kami memiliki nol, ya listrik, kami memiliki satu-- kekuatan, ya kekuasaan. Dan dengan cara itu, menggunakan sesuatu lebih fisik atau elektronik kita mulai menerapkan gagasan ini sesuatu yang baik menjadi salah satu atau nol. Memang, kita hanya bisa melakukannya di sini. Jadi di sini, saya belum tiga tetapi delapan bola lampu, yang masing-masing memiliki saklar sendiri. 

Dan jadi jika saya ingin mewakili nomor tujuh di sini, Aku mungkin berubah pada tiga bola lampu tersebut. Dan memang, dalam komputer saya adalah jutaan, miliaran hal-hal yang hanya lebih kecil dari itu, yang disebut transistor, switch, bahwa Anda hanya menghidupkan dan mematikan. Jadi ini big-- relatif switch big-- dalam laptop-- saya banyak, banyak, banyak, lebih banyak switch. Tapi semua yang mereka lakukan adalah persis itu-- mengubah sesuatu pada, mengubah sesuatu off. Dan dengan demikian, komputer dapat mewakili, dengan orang-orang jutaan atau milyaran transistor, banyak dan banyak nol dan satu. Dan ada perangkat keras lainnya masih yang memungkinkan Anda menyimpan informasi jangka panjang, sehingga ketika Anda menarik pasang, Anda tidak akan kehilangan itu. Tapi itu cerita untuk hari lain. 

Jadi apa yang bisa kita lakukan dengan bit-bit? Mungkin kita hanya mengambil tekanan off dari me-- mungkin seseorang ingin datang di sini dan mempersembahkan demo? Aku melihat tangan pertama ini. Siapa namamu? Maday: Maday. DAVID Malan: Maday, datang ke atas. Senang bertemu denganmu. Maday: Senang bertemu Anda. 

DAVID Malan: Ayo cara ini. Saya tidak perlu bibir Anda. Baiklah. Jadi di sini, kita memiliki, notice-- satu, two-- kita akan mengedit bahwa out-- satu, dua, empat, delapan, 16, 32, 64, 128. Ini disengaja. Ada delapan bit sini- biner nol digits-- dan orang-orang. Dan sedikit adalah unit yang berguna measure-- tidak berguna satuan ukuran ke dirinya sendiri. Biasanya Anda ingin setidaknya delapan hal-hal ini, alias byte. Jadi kita memiliki byte bit di sini. 

Jadi jika kita ingin menantang Anda dengan, misalnya, mengeja, dalam biner, nilai ini di sini-42. Ingin mengambil bacokan di itu? 

Maday: [tidak terdengar]. DAVID Malan: Ya, hanya mendorong switch putih kecil di depan. Dan Anda ingin mengeja keluar 42, dan untuk diperebutkan adalah stres CS50 ini bola jika Anda mendapatkan ini. Baiklah. Jadi Anda memiliki 32. Kami akan membutuhkan 42. Jadi itu delapan, jadi itu 40. Dan excellent-- sangat baik dilakukan. Terima kasih. 

[TEPUK TANGAN] Baiklah. Jadi kita memiliki satu bola stres lagi. Mari kita lakukan ini sekali lagi jika kita dapat. Salah satu relawan lainnya? Bebas stres bola, bola bebas stres. BAIK. Di sini di tengah, Anda ingin turun? Baiklah. Aku tahu. Di sana kami pergi. 

Jadi angka sini-datang di bawah. Siapa namamu? 

DAVEY: Davey. 

DAVID Malan: Davey. BAIK. Ayo up, Davey. Senang bertemu denganmu. Dan apa yang kita akan memiliki Anda spell-- jika Anda bisa berlama-lama di sana hanya satu moment-- adalah nomor 50. Tapi, tapi, tapi tapi, tapi, ini magnet sekolah dasar karena suatu alasan. Baru saja sedikit lebih keras, semua yang benar? Masih ada delapan. Baiklah. Jadi apa yang kita miliki di sana? Kami memiliki 32. Bagus. 32 ditambah 16 memberi kita 48-- begitu dekat. Dan indah. Selamat kepada Davey juga. 

[TEPUK TANGAN] 

Baiklah. Jadi kita bisa melakukan ini sepanjang hari, dan tidak mendapatkan semua yang jauh lebih menarik dan lebih menantang. Tapi itu benar-benar point-- yang adalah bagaimana relatif sederhana itu, pada akhir hari, apa komputer tidak untuk menyimpan informasi, untuk menyimpan input dan akhirnya menyimpan atau mewakili mereka output. Tapi angka saja tidak semua yang menarik. 

Jadi manusia, beberapa tahun yang lalu, memutuskan, Anda tahu apa? Akan lebih baik jika komputer tidak hanya kalkulator untuk aritmatika operasi, tapi benar-benar bisa melakukan hal-hal seperti pengolah kata, atau email, atau inkarnasi yang lebih modern dari jenis-jenis teknologi. Dan dunia memutuskan sewenang-wenang, tetapi secara universal, bahwa jika Anda ingin menyimpan modal huruf A di komputer, Anda tahu apa? Mari kita semua sepakat untuk menyimpan beberapa pola nol dan ones-- bits-- yang pada akhirnya mewakili angka desimal 65. Kami hanya akan semua sepakat tentang itu. 

66 akan mewakili B, 67 akan mewakili C, dan ada tandan pola lain nol dan satu, atau angka yang mendasari, yang akan mewakili surat lain masih. Jadi jika Anda jenis mental menyerap ini sejenak, Saya sengaja memasang A melalui Aku, di mana H 72 dan I adalah 73. Jika komputer kemudian, dalam konteks program pengolah kata atau e-mail, mengungkapkan bawah tenda untuk memiliki pola-pola pola bits-- bit yang mewakili 72, kemudian 73, kemudian 33-- apa yang mungkin ini mantra dalam program itu? 

Jadi hi, dan kemudian sesuatu. Kita tidak perlu tahu, tapi memang 33-- tidak pada grafik earlier-- hanya tanda seru. Jadi 72 adalah H, 73 adalah saya, 33 terjadi menjadi tanda seru masih. Tapi itu semua baik dan bagus, dan pada kenyataannya saat ini, daripada hanya menggunakan tujuh atau delapan bit, berkat sesuatu disebut Unicode sebagai lawan ASCII kembali pada hari, kita benar-benar dapat mewakili lebih karakter yang menarik dari sekedar ini asli Inggris bias huruf. Tapi kita juga bisa mewakili bahkan hal yang lebih rapi seperti warna. 

Jika Anda pernah mendengar akronim RGB, merah, hijau, biru, yang hanya berarti bahwa komputer biasanya menggunakan tiga set bits-- beberapa jumlah bit yang mewakili nomor untuk berapa banyak merah yang Anda inginkan, set bit untuk berapa banyak hijau yang Anda inginkan, dan nomor set untuk berapa banyak biru yang Anda inginkan. Sehingga sejumlah besar berarti banyak merah, sejumlah kecil berarti tidak ada merah. Dan jadi ini adalah jenis dari nilai tengah di sini. 

Jadi memberi saya beberapa merah, memberi saya beberapa hijau, dan memberikan saya sedikit biru. Dan jika Anda mencampur tiga warna warna bersama-sama, dalam hal ini, Anda mendapatkan warna keruh ini kuning atau coklat. Tapi pola delapan ditambah delapan ditambah eight-- sehingga 24 bits-- kiri ke kanan, adalah bagaimana komputer akan mewakili warna tertentu. Sekarang ini hanya sebuah titik pada layar. Jika Anda melihat benar-benar dekat di TV Anda Anda komputer, Anda akan melihat titik-titik atau piksel. Dan jika Anda memiliki seluruh grid piksel, horizontal dan vertikal, Anda memiliki gambar. Dan kemudian jika Anda mengambil gambar dan kemudian mencuci menunjukkan diri gambar lain, lain gambar, gambar lain, gambar lain, benar-benar cepat, Anda tentu memiliki film. 

Dan begitu melihat di mana kami mulai. Kami mulai dengan nol ini dan orang-orang. Kami bekerja dari sana ke desimal angka, bagaimana kita mewakili mereka. Sekarang kita memiliki huruf alfabet. Tapi dalam konteks lain menunggu, kita bisa menggunakan beberapa bit dan mewakili warna. Segera setelah Anda memiliki kemampuan untuk mewakili warna, Anda memiliki kemampuan untuk mewakili foto, dan gifs animasi dan karakter lain seperti di layar. Dan ketika Anda memiliki sejumlah besar gambar terbang oleh manusia sekaligus, sepertinya film, dan sehingga Anda mendapatkan video juga. 

Jadi menggunakan ini sangat primitif sederhana kita memiliki cara untuk mewakili akhirnya semua bentuk media. Dan kami telah disarikan lagi dan lagi dan lagi, sampai kita dapatkan dari tingkat terendah ke level tertinggi ini. Sehingga memberi kita ini ide umum abstraksi. Tapi kita mulai di sini. 

Di sini sekarang, kita mungkin mewakili dalam komputer input kami dengan nol dan satu, output kami di nol dan satu, tapi apa yang terjadi di dalam kotak? Di situlah komputer ilmu mulai menarik. Itu di mana Anda benar-benar membawa Anda pikiran sendiri untuk menanggung untuk memecahkan masalah. Kita sekarang dapat menetapkan, untuk sisa semester, ya. Aku tahu karya bagaimana biner. Aku ingat bagaimana Ascii atau Unicode-- pemetaan untuk letters-- karya. Dan itu pasti berdiri untuk alasan kita bahwa bisa mewakili merah dan hijau dan biru, dan mewakili multimedia juga. Tapi ini adalah hal menarik. Inilah yang membuat seseorang mampu memecahkan masalah. 

Dan satu masalah seperti kami ingin lakukan, memang, mengambil kehadiran, atau melakukan hal ini algoritma. Dan lagi, saya mungkin melakukan hal ini. Saya mungkin melakukan satu, dua, tiga, empat lima, enam, tujuh, delapan sembilan. Dan aku bisa menulis bawah untuk melacak itu. Tapi itu hanya bagaimana saya akan mewakili informasi. Atau aku bisa melakukan ini faster-- dua, empat, enam, delapan, sepuluh, 12, 14, 16, 18, 20, 22-- rasanya seperti dua kali secepat tapi masih akan mengambil seluruh banyak waktu. 

Tapi ternyata, jika kita memanfaatkan belum lain resource-- dan memang komputer hari ini memiliki beberapa CPU atau otak. Ternyata komputer bisa melakukan banyak hal sekaligus, dan memang kita, di ruangan ini, mungkin mewakili persis ini. 

Jadi itu sedikit sosial canggung, tetapi jika Anda akan humor saya hanya proses tiga langkah, biarkan saya meminta semua orang di tempat sana hanya untuk berdiri sejenak. Berdiri. Jadi berpikir untuk diri sendiri, nomor satu-- sehingga semua orang di ruangan ini, kecuali orang-orang yang tidak oblige, berpikir nomor satu. Jadi yang nomor Anda sekarang. Itu adalah langkah pertama, atau sebagai ilmuwan komputer atau programmer biasanya akan lakukan, kita akan untuk mulai menghitung dari nol. Jika jumlah terkecil yang kita bisa mewakili dengan orang-bola lampu adalah nol, dengan hanya meninggalkan mereka semua ini, aku mungkin juga hanya mulai menghitung dari nol adalah bukan satu. Dan itulah yang ilmuwan komputer dilakukan. Jadi langkah nol, berdiri dan memikirkan nomor satu. Langkah berikutnya adalah pasangan ini-- off dengan seseorang berdiri dan menambahkan nomor Anda bersama-sama. Hebat. 

Jadi pada saat ini dalam waktu, secara harfiah semua orang yang berpartisipasi berpikir untuk nomor 2, kecuali untuk satu orang aneh jika kita memiliki ganjil orang di dalam ruangan. Dan sekarang langkah ketiga di sini akan akan ini-- salah satu dari kalian harus duduk. Salah satu dari kalian harus duduk, dan jika Anda masih berdiri, kembali ke langkah satu. Baiklah. Baiklah. Jadi semakin banyak orang harus bisa duduk. Perhatikan bahwa ini telah menyebabkan a loop-- semacam siklus. Beberapa dari Anda harus canggung terjebak, akan bolak-balik antara langkah satu dan dua, satu dan dua, satu dan dua. Itu OK. bug pertama kami. Kami akan berurusan dengan itu. Baiklah. Biarkan saya mencoba untuk memacu hal-hal bersama. 

Secara teori, hanya satu orang yang berdiri karena semua orang terus berpasangan. Tapi biarkan aku mempercepat dengan orang-orang masih berdiri. Apa nomor yang Anda pikirkan? 46. BAIK. Pergi ke depan dan duduk. Kalian masih berdiri. Siapa yang masih berdiri? Apa nomor yang Anda pikirkan? BAIK. 

Jadi kami akan kembali kepada Anda. Di belakang? Apa itu? 22. OK orang lain sampai top-- ya? 34. BAIK. Di sini di right-- saya di sini? 132, sangat bagus. 22? 

BAIK. Dan siapa yang masih berdiri? Disini? 46, sangat bagus. 72. Aku tidak bisa menunda lebih lama lagi. Ya? 30, bagus. Disini? 23? 23. 

Dan saya pikir itu semua orang kecuali kalian, tidak ada tekanan. Oh tunggu. 28? Hanya delapan. BAIK. Hanya delapan. Dibawah sini? 30. 23. 24. 18. Ini adalah implementasi terburuk algoritma ini pernah. BAIK. Jadi orang lain? Orang lain? BAIK. Satu lagi. 16? BAIK. 16. Baiklah. Jadi jika saya tidak melewatkan siapa pun di silau sini, ketika saya tekan Enter, kita akan melihat, algoritma, yang Jumlah orang di Sanders. Karena sekali lagi, itu seolah-olah semua orang Anda duduk, melewati nomor Anda off untuk orang lain, untuk orang lain, kepada orang lain, sehingga dalam teori, pada akhirnya, hanya satu canggung orang harus dibiarkan berdiri. Tapi itu baik-baik saja. Kami melaju hal-hal secara manual. Ini terutama sulit untuk melihat dalam ruang tertentu. 

Dan total jumlah orang kita berpikir ada di sini adalah 546. Jumlah aku tangan oleh rekan-rekan mengajar, siapa yang melakukannya lama sekolah cara lambat, adalah 820. 

[TERTAWA] 

[TEPUK TANGAN] 

Itu OK. Jadi pasti itu, ada bug ini. Dan itu baik-baik saja. Dan jadi pikirkan kembali ini pertama kalinya sesuatu Anda menulis tidak selalu bekerja. Ini telah terjadi kepada saya di sini juga. Tapi mari kita sekarang mempertimbangkan bagaimana kita mungkin menerapkan ide ini sama untuk sesuatu Anda mungkin telah melihat sebelumnya, yang adalah di sini-teknologi jadul ini buku telepon yang sangat besar. Dan anggaplah bahwa buku telepon ini memiliki 1.000 halaman dan 1.000 nama dan nomor abjad di dalamnya. 

Nah, kita bisa jenis menerapkan sejenis ide untuk masalah yang sangat fisik ini, hanya menggunakan saya. Aku hanya jenis ditipu dengan memanfaatkan semua Anda dengan banyak dan banyak CPU yang berbeda atau otak mengeksekusi beberapa algoritma. Tetapi jika itu hanya sedikit tua saya, saya masih bisa memanfaatkan bahwa esensi yang sama dari sebuah ide membagi dan menaklukkan masalah itu lagi dan lagi, dimana setengah dari Anda, setengah dari Anda, setengah dari Anda, setengah dari Anda, teoritis terus duduk, sampai kami meninggalkan, secara teoritis, dengan hanya satu orang. 

Jadi di sekolah tua ini technology-- kita tidak perlu ini map-- ini teknologi jadul, kita mungkin mulai mencari seseorang seperti Mike Smith, salah satu halaman pada satu waktu. Dan saya melihat bahwa tidak ada, Mike tidak ada di sini. Aku masih di bagian A. Akhirnya, saya menemukan sendiri di bagian B. Dan ini adalah algorithm-- langkah-demi-langkah instruksi. Mulai pada awal dan satu pada suatu waktu, mencari Mike Smith. Apakah ini correct-- ini algoritma atau pendekatan? 

Ya, itu benar. Jika Mike di sini, akhirnya Aku akan sampai ke dia. Tapi itu tidak efisien. Ini jelas sangat lambat. Jadi saya bisa memanfaatkan twosies sama mendekati. Aku bisa melakukan semacam dua, empat, enam, delapan, 10, 12. Ini dua kali lebih cepat. Aku akan sampai ke Mike cepat jika dia ada di sana. Apakah itu benar? Ya, tapi saya mendengar ada little--. Sekarang saya mendengar ada sebuah. Ya. Ada bug yang berpotensi. Mungkin Mike hanya sengaja mendapat terjepit di antara dua halaman, karena aku terbang melalui dua ini pada suatu waktu. Jadi setidaknya kita membutuhkan beberapa jenis memperbaiki bersyarat. Saya harus mengatakan, hey, jika aku memukul seseorang yang namanya dimulai dengan T bukan sebuah S, Saya lebih baik ganda kembali setidaknya satu halaman. Jadi kereta pada awalnya, tapi diperbaiki. Tapi tak satu pun dari kita akan mencari Mike Smith melalui telepon 1.000 halaman memesan satu halaman pada satu waktu. Apa orang normal akan lakukan? Anda akan pergi ke S, jika Anda tahu di mana S. Anda mungkin pergi kira-kira ke tengah atau sedikit miring menjelang akhir. Dan saya melihat di sini dan Saya di bagian M. Tapi apa yang Anda ketahui tentang masalah ini sekarang, bahwa kita tidak selalu tahu sebelum dengan semua dari kita hanya menghitung diri kita sendiri ekuivalen? Nah, Mike jelas akan berada di setengah buku ini jika dia ada di sini sama sekali karena itu diurutkan. 

Dan sehingga Anda dapat sangat dramatically-- 

[Terengah] 

Aku tahu. 

[TEPUK TANGAN] 

Ini sebenarnya sangat mudah jika Anda melakukannya bawah tulang belakang sana. Tapi Anda kemudian dapat membuang setengah dari masalah pergi. Sekarang, aku meninggalkan dengan problem-- yang sama menemukan Mike Smith di telepon book-- tapi sekarang buku telepon dimulai pada M dan pergi ke Z, tapi itu setengah besar. 

Tapi ini adalah apa yang mengesankan. Sama seperti dalam teori, kalian, ketika Anda semua duduk hanya setengah pada suatu waktu, masalah mendapat setengah besar, setengah besar, lagi dan lagi. Jadi telah masalah ini menjadi masalah yang sama tapi setengah besar. Sekarang masalah 250 halaman. Begitu aku menyadari, oh, aku di bagian T sengaja. Saya sudah terlalu jauh. Aku bisa membuang setengah dari buku telepon. Sekarang, aku turun ke seperempat masalah. 

Dan Anda dapat mengulangi, ulangi, ulangi sampai, dalam teori, Anda kiri dengan hanya satu halaman. Dan jika Mike adalah pada halaman tersebut, Sekarang saya bisa memecahkan masalah ini. Tapi seberapa cepat aku mengatasinya? Dalam kasus pertama, aku butuh seperti mungkin 1.000 langkah untuk menemukan Mike Smith. Ini mungkin telah mengambil me-- Aku mengambil buku telepon dan saya mulai mencari satu halaman pada satu waktu, dan Mike mungkin 1.000 halaman kemudian. 

Pendekatan kedua mungkin membawaku 500 langkah, karena aku terbang melalui dua pada satu waktu. Dan pendekatan ketiga meskipun, itu sangat kuat. Tapi mari kita mempertimbangkan apa yang kita benar-benar lakukan dengan pendekatan ketiga ini. Saya akan memiliki apa yang akan saya sebut saja ini laporan di sini, satu per satu. Mengambil sebuah buku telepon. Membuka ke tengah buku telepon. Lihatlah nama. Dan kemudian hal mendapatkan sedikit lebih menarik secara intelektual, jika masih sederhana. Jika Smith adalah salah satu nama pada halaman saat ini, kemudian melakukan sesuatu kondisional. Ini seperti persimpangan jalan. Menelepon Mike. Jika Mike adalah salah satu nama pada halaman tersebut, yang disebut Mike. Tapi hanya melakukan baris empat jika baris pohon, jika Anda mau, benar. Jawaban untuk pertanyaan itu adalah ya. 

Lain jika Smith adalah awal book-- yang dengan kata lain, jika saya di bagian M dan saya sedang mencari seseorang untuk kiri, lalu apa yang harus saya lakukan adalah sesuatu yang sangat mirip. Lalu aku harus membuka ke tengah dari kiri setengah dari buku. Jadi pergi kiri, dan kemudian kembali ke langkah dua. Lihatlah nama-nama di sana. 

Jadi dengan kata lain, melakukan hal yang sama, tetapi pada masalah yang telah dibelah dua. Anda tahu apa lagi? Jika Smith adalah nanti dalam buku ini berdasarkan pada halaman saya sedang melihat, terbuka untuk tengah kanan setengah dari buku dan kemudian kembali lagi ke langkah dua, else-- ada kemungkinan keempat di sini. Mike di sini atau ke kiri atau ke kanan atau tidak ada. Dan di sini kita lebih baik mempertimbangkan ini. Dan pada kenyataannya, jika Anda pernah memiliki komputer Anda hanya kecelakaan pada Anda, yang kadang-kadang, tapi tidak selalu, Hasil hanya programmer manusia tidak menyadari, oh menembak, ada sebenarnya skenario keempat ini. Dan jika Anda tidak menulis kode untuk menangani skenario itu, kadang-kadang Anda tidak tahu apa yang mungkin dilakukan komputer. Dan memang program mungkin crash. 

Tapi dalam kasus ini, saya pikir tentang hal itu, dan saya berkata, lain berhenti, karena itulah keempat logis mungkin skenario. Sekarang, mari kita tambahkan beberapa kosakata jadi kami dapat mulai untuk melemparkan sekitar istilah yang adalah jika tidak cukup intuitif. Semua hal yang saya baru saja warna kuning di sini, Aku hanya pergi ke fungsi atau prosedur. Mereka hanya jenis tindakan. Jadi mengambil, terbuka untuk, terlihat di, panggilan, terbuka, terbuka, quit-- ini hanya tindakan, atau kami akan memanggil mereka lebih formal, fungsi. 

Sementara itu, sekarang warna kuning, Aku sudah disorot hal itu-- mari kita mulai menelepon mereka kondisi atau cabang. Ini adalah keputusan poin mana Anda mungkin pergi dengan cara ini, cara ini, atau arah lain masih. Jadi mereka akan kondisi. Dan sekarang satu ini sedikit lebih menarik. Mari kita sebut pertanyaan ini ekspresi Boolean, setelah seseorang dengan nama belakang Bool. 

Dan ekspresi Boolean hanya sesuatu itu benar atau salah, ya atau tidak. Jadi pertanyaan yang jawabannya Anda peduli, sehingga dalam kondisi membuat decision-- mendapatkan kembali jawaban, dan kemudian pergi kiri atau kanan, atau sesuatu yang lain sama sekali. 

Dan kemudian terakhir, ini garis sini-kembali ke langkah dua, kembali untuk melangkah two-- kita bisa mengimplementasikan gagasan ini dengan cara yang berbeda. Dan kemudian orang-orang dari Anda dengan pengalaman pemrograman mungkin telah melakukan atau bisa membayangkan melakukan hal ini berbeda. Tapi untuk tujuan hari ini, itu hanya ide yang penting. Hal ini mendorong apa kita umumnya akan menelepon a loop-- semacam siklus, karena itu membuat saya melakukan sesuatu lagi. 

Jadi sekarang, mari kita pertimbangkan seberapa baik algoritma ini. Itu benar. Jika Mike di buku, itu salah satu empat scenarios-- lagi dan lagi dan sekali lagi, kami akan menemukannya. Tapi bagaimana yang baik itu? Yah, kita tidak memiliki menjadi terlalu formal sini. Tapi mari kita merencanakan sesuatu, x dan y, untuk mendapatkan rasa bentuk masalah ini. 

Pada sumbu x di sini adalah ukuran masalah saya. Dan mereka y-axis disini akan menjadi waktu untuk menyelesaikan. Jadi mungkin ini adalah jumlah halaman. Mungkin ini adalah detik atau Halaman turns-- apapun. Namun Anda ingin menghitung adalah apa gambar ini akan mewakili. Dan bahwa algoritma pertama, aku akan untuk menggambarkan hanya sebagai garis lurus. Jika ada n halaman di buku telepon, maka mungkin membawa saya banyak n langkah untuk menemukan Mike. Jika Verizon atau perusahaan telepon menambahkan satu lagi tahun depan, mungkin membawa saya satu lagi step-- satu unit waktu untuk menemukan Mike. Jadi hanya ada satu ini untuk satu rasio. Ini adalah lereng garis lurus. 

Sementara itu, yang kedua algorithm-- jika saya akan dua di time-- dua, empat, enam, delapan, atau double-- akan melalui halaman dua kali pada suatu waktu, dua sekaligus, itu masih garis lurus. Sekarang ada 1-2 rasio, tetapi hanya sedikit lebih rendah. Jadi jika ada ini banyak halaman pada grafik di sini dengan warna kuning, yang mungkin membawa saya ini banyak langkah atau detik, selain itu akan membawa saya dua kali lebih banyak di jalur merah. 

Tapi garis hijau adalah takeaway nyata. Ini adalah apa yang kita umumnya sebut log logorithm-- n, di mana n adalah jumlah halaman. Tapi itu bentuk yang penting hari ini, karena kita tidak memiliki untuk berpikir tentang merencanakan poin. 

Pikirkan tentang skenario ekstrim. Misalkan Verizon besok menggandakan jumlah halaman dalam buku telepon, dari 1.000 menjadi 2.000. Dalam algoritma pertama, saya mungkin buang tambahan 1.000 langkah mencari Mike, hanya karena Verizon dua kali lipat ukuran buku. Kedua algorithm-- itu mungkin membawa saya ekstra 500 langkah. 1.000 halaman lebih, aku pergi dua di time-- 500 langkah lagi untuk menemukan Mike. 

Tapi itu algoritma ketiga adalah jenis magis. Verizon ganda nomor halaman dari 1.000 ke 2.000, tapi berapa banyak lagi langkah tidak itu membawa saya untuk mencari Mike? Itu hanya satu, karena aku hanya bisa merobek buku telepon sekali lagi dari masalah 2.000 halaman ke 1.000 masalah halaman, dan voila. Saya telah mengambil gigitan besar dari itu. 

Dan jika Anda pergi benar-benar ekstrim, misalkan buku telepon Perusahaan memiliki sesuatu gila seperti telepon buku 4 miliar halaman. Nah berapa banyak langkah yang mungkin dibutuhkan untuk menemukan Mike Smith dalam 4 miliar buku telepon halaman? Ini jumlah yang besar, tetapi hanya 4 miliar untuk 2000000000-1000000000 ke 500 juta 250 million-- masih Kedengarannya seperti jumlah besar, tapi aku sangat cepat mendapatkan nilai-nilai yang lebih kecil. 

Dan pada kenyataannya, jika saya melakukan matematika benar, aku hanya bisa membagi 4 miliar oleh sekitar 32 kali sebelum Saya turun ke hanya satu. Jadi jika itu buku telepon yang 4 miliar halaman, bukan masalah besar. Dalam beberapa detik, mungkin 32 detik, saya bisa membagi menjadi dua dan akhirnya menemukan Mike atau menyimpulkan bahwa dia tidak ada. Dan itulah esensi dari sebuah algorithm-- algoritma yang baik. Dan itulah salah satu tujuan dari kelas seperti ini, sedang mencoba untuk mencari tahu bagaimana saya memecahkan masalah bukan hanya benar, seperti aku selalu tahu bagaimana melakukannya satu Halaman di time-- tapi benar dan baik. Bagaimana cara merancang baik solusi untuk masalah? Jadi mari kita sejenak di sini dan memberikan rasa sekarang dari CS50 saja itself-- memperkenalkan anggota staf beberapa kursus ini. Tepat sebelum 02:00, kita akan mengambil istirahat sejenak sehingga bagi anda yang berbelanja dapat Bebek dan mengambil melihat beberapa kelas lain dan menonton sisa online ini. Tapi untuk saat ini, izinkan saya memperkenalkan CS50, kelas itu sendiri, dan khususnya apa yang baru. 

Jadi musim semi lalu, kami menghabiskan cukup sedikit time-- Staf kursus dan aku-- berpikir tentang apa yang kita inginkan CS50 menjadi, dan akan kembali ke pertama prinsip, sehingga untuk berbicara, untuk mempertimbangkan apa yang kita inginkan Tentu saja ini terlihat seperti dan menjadi seperti untuk mahasiswa. Dan Anda akan melihat di masalah ditetapkan nol juga, undangan untuk kita lihat bahwa URL yang merangkum beberapa motivasi di balik Berikut ciri-ciri jatuh 2016. 

Sehingga Anda mungkin telah diperoleh dari TL: handout DR, silabus hari serta dari katalog saja, tahun ini di CS50, Anda hanya diharapkan untuk hadir today-- sehingga pekerjaan baik done-- dan kuliah terakhir pada tanggal 21 November. Dan kau datang tapi tidak diharapkan untuk menghadiri mereka kuliah di tengah, karena apa yang kita lakukan tahun ini, menembak secara real-time materi kursus ini. Jadi semuanya akan tinggal saat ini dan dimasukkan sebaik can-- peristiwa saat dan percakapan yang orang mungkin akan mengalami dalam industri di dunia, tetapi membuat materi yang tersedia, sebagai hasilnya, bahkan earlier-- lengkap dengan transkrip teks lengkap dan searchability dan link ke sumber informasi lainnya. 

Dan memang, kami sudah mengklaim untuk beberapa waktu dan kami sekarang percaya ini, bahwa kita dapat menciptakan, digital, lebih mendalam, lebih menarik pengalaman pendidikan, sebagai lawan untuk mengumpulkan sini sekitar 23 kali secara pribadi, mendengar seseorang seperti saya hanya berbicara tentang ilmu komputer, sebagai lawan terlibat lebih aktif. Jadi Anda akan melihat dalam silabus kursus ini sketsa semester di sini, bersama dengan saat kuliah akan difilmkan, yang Anda Selamat datang tapi tidak diharapkan, dan ketika mereka akan akan dirilis di website kursus ini. 

Dan apa yang akan kita lakukan di sini di Rabu mulai minggu depan, jauh lebih intim, dengan hanya mereka orang-orang yang ingin berpartisipasi, adalah disebut berjalan melalui, di mana saya dan kepala kursus ini benar-benar akan membuat hal-hal sedikit lebih intim di sini di orkestra bagian, masih memiliki beberapa teknologi dan berjalan melalui minggu saat ini masalah set, dan menawarkan particularly-- jika antara mereka yang kurang comfortable-- semua lebih bimbingan yang Anda mungkin ingin atau butuhkan untuk tantangan minggu. Dan juga, bagi mereka yang tidak bisa menghadiri mereka secara pribadi, bukan masalah besar. Ada akan sama dipimpin oleh salah satu staf senior saja ini, Zamalya, kesempatan yang sama tertanam dalam masalah set sendiri. 

Masalah set tahun ini akan dirilis pada hari Jumat dan tidak lagi melakukan tujuh hari kemudian, tapi 10 hari later-- sengaja tumpang tindih dengan setiap masalah mengatur, sehingga untuk lebih mengakomodasi, kami berharap, pasang surut dan mengalir dalam jadwal siswa, terutama ketika ujian tengah semester atau atletik atau akademisi atau ekstrakurikuler cenderung datang dan pergi terutama pertengahan semester. Yang seharusnya memberi Anda sedikit lebih kebijaksanaan apakah Anda depan memuat minggu Anda dengan CS50 atau beban kembali pada akhir pekan berikut ini sebagai gantinya. Jadi melihat ke silabus kursus ini di sini untuk jadwal daripadanya. Dan Anda akan melihat terlalu kalangan perubahan tahun ini, bagi mereka lebih akrab dengan pemrograman di masa lalu, kami akan mulai semester sebagai kita akan hari ini di Scratch, fokus terutama pada bahasa disebut C, dan kemudian transisi tidak untuk PHP, tapi untuk bahasa yang disebut Python menjelang akhir semester dalam konteks pemrograman web, bersama dengan SQL dan JavaScript, HTML, CSS, dan lebih banyak lagi. 

Dan untuk menjawab sebuah FAQ, itu memang terjadi bahwa CS ini tidak menakutkan seperti yang pernah pikir itu, tetapi banyak pekerjaan seperti yang saya dengar itu mungkin. Tapi ini adalah mengatakan bahwa di sini adalah beberapa statistik dari musim gugur 2015 mahasiswa, dimana garis biru horisontal merupakan jumlah rata-rata jam dilaporkan. Dan Anda akan melihat rata-rata enam sampai 10 untuk 12-- mungkin 16 atau lebih dan sebagainya, tetapi dengan varians tinggi untuk menjadi jelas. Dan menyadari bahwa ada tidak hanya siswa lebih nyaman dan kurang nyaman dalam kursus, tapi dukungan yang sesuai struktur untuk mendapatkan para pelajar melalui semester berhasil. 

Memang, untuk menjawab sebuah FAQ, harus Anda mengambil CS50 sebagai tahun pertama? Benar. Dan pada kenyataannya, saya menyesal tidak memiliki menemukan jalan atau menemukan bidang baru tahun pertama juga. Dan harus Anda ambil CS50 dengan kursus lain, tentu seperti baik dan saran umum kita mungkin memberikan siswa, yang CS50 mungkin bukan jenis kelas atau kelas intro bahwa Anda harus mengambil dengan tiga atau empat kelas p-set lainnya. Tetapi jika Anda mengambil dua p-set lainnya kelas, sesuatu yang lain, dan CS50, benar-benar dikelola. Aku sudah banyak siswa di masa lalu melakukannya cukup berhasil. 

Dan untuk mendapatkan Anda menuju bahwa menyelesaikan garis berhasil, tidak saja memiliki sections-- trek yang berbeda untuk siswa kurang nyaman, lebih nyaman, dan di suatu tempat di antara, dimana dalam perjalanan ini Masalah pertama set, Anda akan diminta untuk menggambarkan diri Anda. Dan jika Anda termasuk orang yang kurang nyaman, itu jenis hal bahwa Anda hanya suka tahu. Dan memang, yang menjadi tumbuh demografis di CS50 selama beberapa tahun. 

Pada musim gugur yang lalu untuk Misalnya, 58% dari kelas menggambarkan diri mereka sebagai antara mereka yang kurang nyaman, dengan 9% di antara mereka yang lebih nyaman, dan kemudian siswa lain ada di merah menggambarkan diri mereka sebagai suatu tempat di antara. Dan Anda akan melihat di sini topik keseluruhan dan jadwal bagian, yang semuanya ditawarkan dalam orang, di real time, dengan kursus ini menakjubkan staf fellows mengajar dan asisten saja, beberapa di antaranya Anda akan bertemu hanya dalam beberapa saat. 

Bagian diri, seperti yang Anda lihat, akan menjadi hari Senin dan Selasa dan Rabu, sehingga memungkinkan Anda untuk menyelam setelah terlibat, jika anda memilih, dalam kursus ini kuliah awal minggu itu. Dan kemudian jam kantor, yang tentu, setiap tahun, telah tidak kurang dari menantang untuk kursus. Dan tahun ini, kami berencana tidak hanya untuk memegang jabatan hours-- satu pada satu kesempatan bagi bantuan untuk siswa pada hari Rabu Kamis dan Minggu, yang terakhir dari mereka berada di sore hari dengan desain untuk mengurangi beberapa stres yang selalu muncul dengan malam p-settting dengan tenggat waktu looming-- tapi jam kantor juga akan ditawarkan pada hari Senin dan Selasa dan Rabu, dan Jumat dan Sabtu, terima kasih kepada teman-teman kita di HSA. 

CS50 sekarang memiliki ruang sendiri bagi siswa dan staf CS50, atas 67 Mount Auburn Street, tepat di Harvard Square. Visi yang adalah bahwa CS50 ini TF dan CA sepanjang minggu, cukup banyak di sebagian hari, akan berada di sana untuk dukungan. Jadi jika Anda punya beberapa pertanyaan pada p-set atau Anda merasa sedikit diblokir atau sedikit bingung, dan heck, Anda punya satu jam atau setengah jam antara kelas, terutama di square-- dapat Anda pop dan memiliki pertanyaan yang dijawab dari memiliki kebingungan yang clarified-- sangat banyak dalam roh, Anda kenal, dari matematika departemen sendiri pusat pertanyaan matematika, tapi cukup banyak sekitar jam per [? GCal?] Bahwa kami akan posting secara online. 

Bimbingan juga tersedia bagi mereka siswa, bebas dari kursus ini Staf sendiri jika Anda ingin lebih intim satu-satu, atau dua atau tiga teman sekelas saja, bekerja dengan salah satu anggota staf saja ini. Dan memang, ini di sini hanya beberapa anggota staf saja ini, beberapa di antaranya Anda akan bertemu hanya dalam beberapa saat. Bahkan, CS50 sendiri Kepala mengajar sesama, dan tentu saja kepala asisten, dan pembimbing, bisa datang ke atas, memungkinkan mereka untuk menyapa. 

[TEPUK TANGAN] SPEAKER 1: [tidak terdengar]. 

[TEPUK TANGAN] SPEAKER 2: [tidak terdengar]. 

[TEPUK TANGAN] SPEAKER 3: [tidak terdengar]. 

[TEPUK TANGAN] 

DAVID Malan: Dan memungkinkan kita untuk membawa pada papan dua CS50 paling Staf senior, Rob dan Zamayla juga. 

[TEPUK TANGAN] 

Memang, baik Rob dan Zamayla telah bersama kami begitu lama, bahwa saya mampu untuk masuk ke arsip CS50 ini dan menemukan sangat SD ini cuplikan dari mereka yang berpartisipasi di atas panggung sendiri beberapa tahun yang lalu. ROB: [tidak terdengar]. 

[TEPUK TANGAN] ZAMAYLA: [tidak terdengar] 

[TEPUK TANGAN] DAVID Malan: Terima kasih. Jadi di samping ini anggota tim di sini, CS50 memiliki tim hampir 100 anggota staf, semuanya akan tersedia untuk bagian dan jam kantor dan banyak lagi. Dan seperti Rob mengatakan juga, ini adalah overhaul paling signifikan dari CS50 dalam 10 tahun yang Aku sudah di [tidak terdengar]. [Tidak terdengar] difokuskan terutama dalam menyediakan struktur dukungan, pemangkasan pergi banyak sebagian besar yang sudah terakumulasi dalam 10 tahun perkembangan berulang pada masalah set kursus ini. 

Jadi tahun ini, tidak hanya di kelas tetapi juga dalam bentuk masalah tentu saja ini set, jika Anda menemukan hal yang akan lebih efisien, pemangkas, banyak lebih mudah ditangani daripada di tahun terakhir, seperti yang kita menumpahkan beberapa bagasi yang dikembangkan oleh alam tahun berkembang setelah tahun dan iterasi. Jadi baru dan ditingkatkan dimulai hari ini. 

Anda akan bertemu beberapa lebih dari Staf saja keluar di [tidak terdengar] at 2:30, di mana kita melayani, sebagai tradisi, kue. Ada kue sedikit lebih dari itu, tapi Anda akan bertemu Erin dan Tobias dan lain-lain masih. Dan saya memberikan tur sebelum kita mendengar dari beberapa anggota staf lain di kelas, dari apa yang menanti juga. Bahkan, kita selalu mulai CS50 ini semester ini datang Sabtu, dengan apa yang disebut CS50 Puzzle Day. 

Ini tidak ada hubungannya dengan ilmu komputer per se, tapi dengan tentang masalah pemecahan lebih umum. Dan jika Anda memilih untuk mengambil bagian, per beberapa undangan, Anda mungkin telah melihat pintu menjatuhkan atau di atas panggung di sini, ini merupakan kesempatan di tim dari dua atau tiga atau empat, untuk berpartisipasi untuk teka-teki dan pizza dan hadiah dan more-- Sabtu ini, menantikan untuk lebih. 

Anda akan menemukan juga bahwa setiap Jumat, di Fire and Ice, tidak CS50 membawa sejumlah besar siswa untuk makan siang, untuk membuat besar kelas merasa lebih intim, dan umumnya membawa bersama-sama alumni dan teman-teman dari industri untuk berbicara tentang apa yang mereka sudah telah sampai sejak lulus. Demikian pula, tahun ini, akan kita meresmikan pertama CS50 50 coding contest-- mid-semester kesempatan untuk memungkinkan semua orang pada opt dalam dasar, memiliki tantangan akal terhadap teman sekelas, lagi di tim dari dua atau tiga atau empat, hanya menggunakan pemrograman yang cerdas yang Anda kemudian harus di bawah ikat pinggang Anda setelah hanya enam atau tujuh minggu kelas, dan berpartisipasi dalam jenis kompetisi online-- jika Anda ingin mengasah Anda sendiri keterampilan semua lebih dalam tantangan itu. Pada akhir semester ini yang disebut CS50 Hackathon-- kesempatan yang dimulai pada 7:00 PM berakhir pada 7:00 AM, dan sepanjang jalan 12 jam malam di mana untuk menyelam ke project-- akhir kursus ini kesempatan untuk merancang dan menerapkan apa yang paling menarik untuk Anda dengan mengajar Anda bimbingan sesama ini. Sekitar 09:00 kita biasanya melayani pizza, 01:00, Philippe, dan beberapa dari kami yang masih terjaga di 05:00, shuttle bussed bawah jalan ke IHOP untuk sarapan. 

Dan kemudian beberapa hari kemudian adalah disebut CS50 fare-- akhir pameran semester di perayaan seberapa jauh begitu banyak dari CS50 siswa berasal dari minggu nol semua jalan ke minggu, dan dengan mengingat bahwa 73% dari mereka teman sekelas dan Anda tahun ini pernah mengambil kelas CS sebelumnya. Bahkan, untuk menekankan kembali sebanyak, di sini adalah beberapa wajah lebih dari staf CS50 ini. SPEAKER 4: [tidak terdengar]. SPEAKER 5: [tidak terdengar]. SPEAKER 6: [tidak terdengar]. SPEAKER 7: [tidak terdengar]. SPEAKER 8: [tidak terdengar] SPEAKER 9: [tidak terdengar]. 

SPEAKER 4: [tidak terdengar]. 

SPEAKER 10: [tidak terdengar]. SPEAKER 11: [tidak terdengar]. SPEAKER 12: [tidak terdengar]. SPEAKER 13: [tidak terdengar] 

SPEAKER 14: [tidak terdengar]. 

SPEAKER 13: [tidak terdengar]. SPEAKER 15: [tidak terdengar] SPEAKER 16: [tidak terdengar]. 

SPEAKER 11: [tidak terdengar] SPEAKER 5: [tidak terdengar]. DAVID Malan: Beberapa tim sendirinya belanja kelas. Tetapi jika para anggota staf CS50 di sini, bisa datang ke atas untuk sesaat. CS50 ini TF dan CA dan [? Staf?] anggota di sini-ini hanya beberapa dari faces-- salah satunya Anda hanya melihat, dan beberapa other-- dan beberapa orang lainnya masih. Mengapa kita tidak pergi ke depan dan memungkinkan kalian lima menit istirahat. Jika Anda perlu untuk bebek untuk kelas shop, itu baik-baik saja. Dan dalam lima menit, kami akan melanjutkan, mengambil melihat Scratch-- pertama bahasa pemrograman kami, memenuhi staf saja di sini lagi, dan fokus pada akhirnya pada masalah ditetapkan nol. Jadi kami akan kembali dalam lima menit. 

[TEPUK TANGAN] 

Baiklah. Jadi kita kembali. Dan di kami yang tersisa waktu hari ini, tujuannya adalah untuk tingkat lapangan dalam hal beberapa terminologi, dalam hal beberapa ide. Karena memang, sesuai beberapa grafik sebelumnya, ada akan menjadi berbagai tingkat pengalaman di kelas, beberapa yang siswa memiliki diambil beberapa program sebelumnya, beberapa di antaranya belum. Dan dengan masalah pertama ini menetapkan dan dengan bahasa pertama ini kita memiliki kesempatan untuk memulai untuk mengambil untuk diberikan setelah hari ini beberapa kosa kata umum dan ide. 

Dan kami akan melakukan ini dengan cara languages-- pertama kursus ini selain C dan Python dan JavaScript dan SQL dan HTML dan CSS, kita akan fokus pada awalnya dan hanya untuk masalah set nol bahasa grafis ini, yang disebut Scratch, yang dikembangkan oleh MIT Media Lab'S di jalan, untuk membantu mahasiswa dan anak-anak terutama mengekspresikan diri algorithmically-- dengan cara yang lebih konsisten dengan apa kita sebut berpikir komputasi. 

Dan itu bahasa berguna karena sangat cepat minggu depan di minggu satu, kita beralih ke yang lebih bahasa tradisional dan misterius yang disebut C, yang murni tekstual. Anda hanya menggunakan keyboard di untuk menulis instruksi seperti ini di layar. Tetapi bahkan jika Anda belum pernah melihat bahasa pemrograman sebelumnya, hanya melirik ini, semua akan hal itu samar, Anda mungkin bisa menebak bahwa mungkin mencetak Hello World. Tapi ada banyak overhead yang sintaksis ada. Ada hash aneh simbol atau hash tag di bagian atas. Ada kurung sudut, beberapa kurung, kurung kurawal, semi-colon-- ada begitu banyak visual yang sintaks yang mendapat di jalan. Kita mulai saja dengan Scratch sehingga untuk mendapatkan melewati semua orang intelektual gangguan tidak menarik, dan berfokus pada ide-ide. 

Bahkan, ini mungkin sebelumnya. Ini, untuk ini, minggu akan setelah. Ini, dalam grafis ini Scratch bahasa, adalah bagaimana Anda akan menerapkan bahwa sama program-- program yang ketika dijalankan, hanya menyapa dunia. Dan apa yang baik tentang Scratch adalah bahwa itu pemrograman grafis ini lingkungan yang menggunakan potongan puzzle atau blok, yang hanya berpaut bersama-sama apakah masuk akal logis untuk melakukannya. Dan dengan Scratch dapat Anda kembangkan animasi dan permainan interaktif dan seni, dan sejumlah hal yang Anda mungkin membayangkan dalam pikiran Anda sendiri, dan menerapkannya hanya dengan menyeret dan menjatuhkan potongan puzzle. 

Dan memang, kita akan memiliki kemampuan untuk mengungkapkan beberapa ide yang sama yang saya sebutkan sesaat lalu dalam konteks Mike Smith dan mencari hal-hal telepon book-- seperti fungsi, hanya tindakan, hal-hal seperti loop yang melakukan hal lagi dan lagi, variabel, yaitu sesuatu yang kita akan memperkenalkan, tapi itu akrab mungkin dari algebra-- hanya semacam placeholder untuk menyimpan beberapa nilai Anda mungkin perlu ekspresi Boolean later--, di mana orang-orang ya tidak atau benar pertanyaan palsu dari sebelumnya. Kondisi adalah mereka garpu di road-- cabang-cabang sehingga untuk berbicara. Dan kemudian ada beberapa pengujian Fitur kita akan melihat bahkan hari ini, disebut array dan benang dan peristiwa, bahwa kita akan kemudian kembali lebih waktu dalam bahasa yang berbeda. Tapi Scratch memungkinkan kita untuk mengeksplorasi semua ini. Jadi di sini di Scratch, ini ungu blok apa fungsi biasanya akan terlihat seperti. teka-teki ini sepotong ungu yang memiliki beberapa kata seperti misalnya, yang merupakan tindakan, dan kemudian mungkin memiliki argumen atau parameter-- suatu cara dari jenis menyesuaikan apa yang blok tidak sehingga tidak pra-ditentukan oleh MIT apa yang dikatakan blok ungu ini. Bahkan, Anda akan melihat dalam saat itu aku bisa mengetik kata-kata seperti dunia halo, atau Halo David, atau Halo Zamayla, atau apa pun yang saya inginkan, dalam argumen teka-teki yang piece-- kotak putih sana. Sementara itu, jika saya ingin satu lingkaran, kita akan melihat bahwa ada potongan puzzle yang yang terlihat orange kecil seperti ini. Dan bentuknya semacam menunjukkan bahwa sesuatu terjadi lagi dan lagi dalam satu siklus. 

Jadi jika saya membungkus menyapa blok dunia dengan selamanya memblokir di Scratch, itu hanya akan terus menyapa dunia selamanya, secara harfiah. Sementara itu, ada lagi jenis loop dalam Scratch bahwa kita akan see-- mengulang block-- mana, jika Anda tahu sebelumnya berapa kali Anda ingin loop untuk mengeksekusi jumlah terbatas kali di fact-- Anda dapat menentukan bahwa dengan mengetikkan nomor atau bahkan memasukkan dalam variabel, seperti x atau y seperti yang akan kita lihat. 

Bahkan, variabel seperti i dalam kasus ini, yang adalah nama umum untuk variabel integer yang hanya menyimpan number-- sebuah integer mungkin, menggunakan blok oranye ini untuk menetapkan variabel seperti saya ke nol. Berikut ini adalah contoh hijau dari ekspresi Boolean dalam Scratch. Meskipun ini terlihat seperti matematika a rumus, ketidaksetaraan matematika seperti ini benar-benar adalah ekspresi Boolean. Hal ini bisa benar atau salah. Saya kurang dari 50. Ini baik jawaban ya atau tidak atau jawaban benar atau salah. Dan kita umumnya akan menelepon mereka ekspresi Boolean. Dan itu tidak harus 50. Hal ini dapat x kurang dari y, lebih besar dari y, sama dengan y-- sejumlah lainnya pertanyaan mungkin akan diminta. 

Sekarang, pada pandangan pertama, ini mungkin terlihat tiba-tiba cukup berani di sini, dan itu. Tapi konsep bijaksana, itu cukup akrab dari sebelumnya. Jika x kurang dari y, daripada mengatakan sebanyak. Lain jika x lebih besar dari y, maka katakan sebanyak. Lain mengatakan x sama dengan y. Jadi kita memiliki contoh ada dari scenario-- ketiga satu-satunya possibility-- ketiga x adalah baik lebih besar dari, kurang dari, atau sama dengan. Jadi kita memiliki garpu tiga cara di jalan. 

Dan perhatikan apa yang keren di sini-Scratch, tampaknya, hanya memiliki satu teka-teki sepotong, dalam hal ini, kalau blok lain. Namun yang tampaknya menyiratkan Anda dapat hanya memiliki garpu dua arah di jalan. Anda dapat pergi kiri atau kanan, tapi apa tentang itu skenario ketiga? Bagaimana jika x sama dengan y? Bukan masalah besar. Ambil satu potongan puzzle, menempatkan satu lagi di dalamnya untuk menciptakan semantik setara jika, lain jika, else-- dan sekarang Anda memiliki garpu tiga jalan di jalan. Dan seperti yang akan kita lihat, potongan Scratch puzzle dapat ditarik dan tumbuh, sehingga untuk menjejalkan lebih banyak barang di dalamnya. Anda tidak harus sesuai segala sesuatu dalam ukuran default. 

Ini adalah sesuatu yang kita akan segera lihat disebut array. Ini seperti list-- beberapa cara menyimpan beberapa potongan informasi dalam variabel, bukan hanya nomor. Ini kita akan melihat perwakilan dari sesuatu yang disebut multi-threading. Bahkan, semua Anda Mac dan PC hari ini mendukung multi-threading, yang berarti Anda dapat benar-benar melakukan beberapa hal pada suatu waktu. Anda dapat memiliki Microsoft Word up di foreground, bekerja pada beberapa esai. Anda mungkin memiliki browser dalam pembukaan latar belakang G-mail atau Facebook atau sejenisnya. Komputer Anda dapat melakukan beberapa hal hari ini karena itu adalah multi-threaded, dan program mereka di dalam tertentu juga multi-ulir. 

Ada hal-hal yang disebut sebagai peristiwa baik di dunia Scratch, dan kemudian ada jalan juga, untuk membuat sendiri potongan puzzle kebiasaan kami jika hal-hal tidak benar-benar ada di muka. Jadi mari kita memotivasi ini sebagai berikut. Beberapa tahun yang lalu, ketika saya pertama kali ditemukan Scratch, ketika saya benar-benar mahasiswa pascasarjana di MIT, kami diri kita sendiri ditugaskan untuk membuat pekerjaan rumah. Dan saya implemented-- yang, dalam retrospeksi, adalah keputusan yang sangat buruk karena itu lagu yang paling menyebalkan di dunia untuk mendengarkan selama delapan jam sementara bekerja pada homework-- Anda tapi sesuatu yang saya telah disebut Oscar Time, yang mungkin lagu akrab. 

CS50s memiliki Jordan Hayashi, salah satu kita lebih anggota staf senior, telah ditingkatkan untuk tahun 2015 dan sekarang tahun 2016, sejak kembali pada hari, Aku punya semua yang hanya akan ke Oscar sampah. Sekarang kita mendukung daur ulang dan kompos. 

Tapi untuk melukis gambar dari apa yang bisa kita lakukan di sini dan untuk memotivasi beberapa contoh tingkat yang lebih rendah, bisa kita mendapatkan satu lainnya relawan hanya datang ke atas dan bermain pertama saya tugas pekerjaan rumah yang pernah? Ayo up. Siapa namamu? 

HENRY: Henry. 

DAVID Malan: Henry, datang ke atas. Ayo up. Kepala cara baik, dan Anda akan melihat dalam beberapa saat, Aku akan pergi ke depan dan memukul bendera hijau di kanan atas sudut, yang berarti pergi. Kecil berhenti ikon tanda akan mengatakan berhenti, dan saat itulah Anda mulai dan menghentikan program. Senang bertemu denganmu. Baiklah. Jadi kita akan melihat petunjuk pada layar hanya dalam beberapa saat. Dan hanya dengan memainkan game ini selama beberapa seconds-- percayalah, kita tidak akan ingin bermain semua cara untuk end-- Anda akan mendapatkan rasa apa program ini tidak. Dan lebih dari hanya fokus pada Henry menjadi baik atau buruk di game ini, fokus dan bagaimana itu dilaksanakan oleh saya awalnya dan kemudian dengan Jordan. Dengan kata lain, di mana variabel? Dimana loop? Dimana fungsi? Dan kita akan melihat apakah kita tidak melihat mereka di bawah tenda. 

Cukup klik dan tarik sampah ke bin sesuai. 

[MUSIC PLAYING] Baiklah. Itu sangat baik. Mengapa kita tidak berhenti di sana. Terima kasih. Selamat kepada Henry. Terima kasih. 

[TEPUK TANGAN] 

Bayangkan saja debugging program itu. Jika ada masalah dua menit ke song-- tapi begitu apa yang terjadi di sini benar-benar? Serumit itu mungkin mulai tampaknya mendapatkan dari waktu ke waktu, memang lebih banyak hal mulai jatuh, apa yang menarik tentang semacam ini misalnya-- dan kita akan melihat beberapa others-- adalah bahwa jika Anda melihat masa lalu kompleksitas atau kecanggihan permainan, ada sebuah bangunan yang sangat sederhana blok yang play-- yang semuanya, jika Anda menyaring mereka untuk mereka blok bangunan, yang sangat mudah dan diimplementasikan kepada diri mereka sendiri. Misalnya, itu Sudah beberapa waktu, tapi aku cukup yakin apa yang awalnya saya lakukan ketika membuat game ini untuk pertama kalinya adalah aku benar-benar seperti menunda-nunda. Saya tidak fokus sama sekali pada logika atau potongan puzzle, Saya berfokus pada grafis dan temuan jalan pos dan tempat sampah dan semua itu. Tetapi orang-orang yang diperlukan bahan pada awalnya. Dan setelah saya selesai menunda-nunda dan meletakkan kerangka menyeluruh, Aku memutuskan, saya hanya membuat satu sepotong sampah jatuh dari langit. Dan kita akan melihat Scratch mendukung hal disebut karakter sprites-- yang dapat memiliki kostum yang berbeda pada sehingga mereka terlihat berbeda. 

Dan jadi aku meletakkan sampah kostum pada satu sprite tersebut. Dan aku hanya membutuhkannya jatuh dari langit. Dan ternyata, Scratch, seperti bahasa pemrograman yang paling, mendukung nomor acak atau angka acak teknis pseudocode, sehingga dengan menyeret dan menjatuhkan potongan puzzle tertentu, Saya mampu untuk memiliki tempat sampah datang dari sebelah kiri pada awalnya. Dan kemudian pada saat jatuh, dari hak dan kemudian dari tengah. Dan semua permainan tidak hanya memiliki sampah jatuh dari langit. Anda tidak bisa menunjukkan hal itu atau klik di atasnya. Anda tidak bisa membuka tempat sampah. Anda tidak bisa melakukan apa-apa. Tapi itu langkah bayi menuju visi utama saya. 

Dan setelah itu, aku benar-benar dilaksanakan beberapa jenis penginderaan sehingga jika Anda tidak mengklik dan tarik pada sepotong sampah atas sampah, Oscar tutup akan membuka dan menutup. Tidak ada yang akan terjadi ke tempat sampah, tapi setidaknya tutupnya akan membuka dan menutup. Jadi kemudian memeriksa, langkah dua dua. Dan ini adalah apa yang akan menjadi kunci dalam kedua masalah set nol dan dalam pemrograman lebih umum, adalah untuk mengambil langkah-langkah bayi sangat disengaja. Karena bukan hanya tidak memungkinkan Anda untuk merasa jujur dicapai jauh lebih quickly-- itu adalah Hal terburuk di dunia mencoba untuk menerapkan semua Oscar Time, kemudian jam kemudian memukul bendera hijau, dan tidak ada yang berhasil seperti yang diharapkan karena di mana Anda bahkan mulai debug atau untuk memecahkan program yang? Ini hanya luar biasa. 

Dan benar-benar merangkul ide ini mengambil langkah-langkah bayi steps-- lagi dan again-- membangun sesuatu yang, pada akhirnya, benar-benar mengesankan dan kompleks, tapi pada awalnya, hampir tidak banyak sehingga. Bahkan, mari kita lakukan ini. Biarkan aku pergi ke depan dan-- Scratch itu sendiri ada di web pada Scratch.MIT.edu, dan Anda akan diberitahu sebagai banyak lagi di masalah set nol, spesifikasi untuk yang sudah di website CS50 ini. 

Tapi ini adalah apa Gores itu sendiri. Dan ada benar-benar hanya tiga bidang utama. Di kiri atas ada adalah tahap yang disebut. Ini adalah Scratch. Kostum default adalah kucing. Dan ini adalah dunia persegi panjang di yang dapat Anda move-- atas, bawah, kiri, benar dan beberapa hal lain. Di tengah di sini adalah kategori kami atau palet kami potongan puzzle, dan warna yang berbeda berarti hal yang berbeda. Dan jika Anda aduk sekitar, Anda akan melihat hal-hal seperti loop dan kondisi dan variabel dan bahan-bahan lainnya. 

Dan kemudian di sini adalah daerah skrip. Ini adalah di mana saya dapat drag dan drop potongan-potongan puzzle untuk melakukan sesuatu. Jadi mari kita melakukan satu hal seperti itu. Biarkan aku pergi ke depan dan-- dan aku tahu di mana itu. Jadi aku akan segera klik mana aku tahu hal-hal yang siap menjadi, tapi menunjuk dan mengklik dan mengaduk-aduk yang tak terelakkan. Jadi ketika bendera hijau diklik, apa yang ingin saya lakukan? Aku akan melakukan hal ini. Aku akan menyeret puzzle ungu ini sepotong, menyapa selama dua detik, dan biarkan aku memperbesar. 

Dan aku akan mengubah ini untuk menjadi apa yang saya inginkan be-- halo dunia selama dua detik baik-baik saja. Sekarang, aku akan klik bendera hijau, atau jika saya benar-benar ingin, Saya penuh dapat menyaring dan kemudian kembali. Ini hanya akan terus semuanya dalam satu jendela. Hijau flag-- halo dunia. Baiklah. Tidak semua yang menarik. Jadi biarkan aku pergi ke depan dan melakukan hal ini. Biarkan aku mencoba satu sama lain. Ketika bendera hijau clicked-- mari melakukan sesuatu seperti suara. Dan perhatikan bahwa dari kotak gratis yang Anda dapatkan suara kucing, seperti sprite default. Jadi sekarang biarkan aku pergi ke depan dan memukul bendera hijau sekarang. 

[MENGEONG] 

Aw. Itu menggemaskan. Aku pemrograman. Jadi apa yang saya lakukan? Ini adalah setara dengan sebuah program. Ini jelas super sederhana. Itu tidak benar-benar mengambil semua yang banyak usaha dan MIT melakukan sebagian besar pekerjaan, tetapi Aku menyebut fungsi. Saya telah menggunakan fungsi. Saya telah membuat beberapa tindakan, dengan hanya menggunakan yang satu ungu potongan puzzle. 

Nah, jika saya ingin melakukan tiga meows berturut-turut? Biarkan aku pergi ke depan dan melakukan dua dan tiga. Dan melihat bahwa ketika Anda arahkan terdekat sepotong puzzle, garis putih kecil muncul semacam magnetis, dan itu akan snap bersama-sama ketika Anda membiarkan pergi. Mari kita lihat apa yang terjadi di sini. 

[MENGEONG] 

Ada bug. Saya hanya mendengar satu meong. Mengapa itu terjadi? Ya? Ya. Kami tidak benar-benar mendengar itu, tapi itu intuisi yang baik. Mereka semua bermain pada waktu yang sama. Mengapa? Nah, komputer hanya akan melakukan apa yang Anda katakan untuk dilakukan. Jadi jika Anda mengatakan, bermain suara, memainkan suara, memutar suara, tetapi Anda tidak mengatakan itu untuk bermain sampai Anda sudah selesai, bermain sampai selesai, itu akan meniup melalui program benar-benar cepat dan jangan hanya apa yang Anda katakan untuk dilakukan. 

Jadi saya benar-benar harus memperbaiki ini dalam beberapa cara. Aku hanya bisa melakukan ini, menyingkirkan ini. Biarkan aku mencoba puzzle lainnya ini piece-- bermain meow suara sampai selesai, dan kemudian tarik tiga ini dan klik Play. 

[MENGEONG] 

Ini tidak benar-benar very-- terima you-- sangat alami. Jadi kenapa tidak Aku-- biarkan aku pergi untuk mengontrol sini. Bagus. Tunggu satu detik, dan sekarang biarkan aku kembali untuk suara, dan suara bermain sampai selesai, dan kemudian biarkan aku menunggu satu detik. Dan kemudian biarkan aku pergi dan mendapatkan satu lebih suara, dan di sini kita pergi. 

[MENGEONG] 

Sedikit lebih alami, tapi ini sangat tidak efisien. Seperti aku mulai bosan, semua akan sebentar, mengklik bolak-balik dan benar-benar duplikasi work-- saya cukup banyak copy dan paste. Memang, jika saya Kontrol diklik atau kanan diklik, Saya bisa saja disalin dan disisipkan. Apa yang akan menjadi lebih baik membangun untuk digunakan? Apa ide dari sebelumnya? 

Ya, jadi loop. Dan pada kenyataannya, jika kita menjulurkan sekitar, kita mungkin menemukan yang tepat. Biarkan aku pergi dengan Acara atau lebih tepatnya Control. Jadi repeat-- saya tidak ingin menjadi 10 kali. Itu akan mendapatkan menjengkelkan cepat. Tapi saya akan mengulangi tiga kali. Biarkan aku kembali terdengar dan memutar suara sampai selesai. Biarkan aku kembali ke Kontrol dan hanya menunggu satu detik. Dan pemberitahuan, Anda mungkin pikir itu tidak cocok, tapi sekali lagi jika magnetis Anda membiarkannya jepret di tempat, ia akan tumbuh untuk mengisi. Apa itu bermain sekarang? 

[MENGEONG] BAIK. Bagus. Dan ini adalah apa yang disebut sebuah program yang juga benar. Ini mengeong tiga kali cukup secara alami, tapi itu lebih baik dirancang. Saya menggunakan kurang redundansi. Saya tidak copy paste apa-apa. Aku hanya menggunakan ide yang lebih baik. 

Sekarang, ini masih tidak semua yang menarik dengan Scratch tidak melakukan apa pun. Jadi mari kita lakukan sesuatu yang lain sebagai gantinya. Mari kita lakukan sesuatu selamanya. Dan kau tahu apa? Gerak tampaknya menarik. Mari kita memiliki dia pindah 10 langkah dan tekan tombol play sekarang. 

BAIK. Nah kita bisa semacam hambatan dia kembali, dan dia masih berjalan karena dia melakukan ini selamanya. Jadi loop adalah melakukan apa itu mengatakan untuk melakukan, tapi ini tidak semua yang menarik. Ayo lakukan ini. Izinkan saya menambahkan blok kontrol, dan menggunakan satu kondisi-kondisi untuk pertama kalinya. 

Jadi itu akan bergerak 10 steps-- 10 titik, 10 piksel pada screen-- yang maka itu akan mengajukan pertanyaan ini. Jika sesuatu itu benar, maka lakukan sesuatu di dalam blok ini. Jadi ternyata penginderaan memiliki keseluruhan sekelompok expressions-- Boolean pertanyaan dari ya tidak ada atau benar palsu form-- biarkan aku melakukan hal ini. 

Jika touching-- dan kemudian ada Penurunan ini sedikit down. Saya dapat parameterize itu. Jika menyentuh edge-- mari melakukan sesuatu seperti itu. Jadi jika menyentuh edge-- biarkan aku kembali ke gerak. Dan kenapa tidak kita hanya berbalik 180 derajat? Baiklah. Jadi selamanya, bergerak 10 langkah. Jika Anda menyentuh tepi, berubah 180 derajat. Dan itu bukan akhir dari program karena Anda berada dalam selamanya memblokir, sehingga akan pergi lagi dan lagi dan lagi dan lagi. Jadi mari kita lihat apa yang terjadi. BAIK. Sebuah kereta kecil, tapi agak dingin. 

Dan kita bisa menambahkan ini beberapa hal konyol bahwa tidak semua yang intelektual menarik. Tetapi jika kita memukul ini sedikit mikrofon button-- aduh. Biarkan aku membersihkan ini. Mari saya meningkatkan ini sebagai mereka akan mengatakan di TV. Membersihkan itu, Save, dan sekarang pergi ke script. 

Dan sekarang, biarkan aku pergi terdengar. Biarkan saya memberikan nama. Saya akan menelepon ouch ini. Dan sekarang bermain Aduh suara. Perhatikan muncul di sedikit drop down menu. Ayo lihat. 

[ADUH] 

[TERTAWA] Tapi kita bisa mengubah t-nya dengan cepat. Kita bisa menjadi dua kali lebih menjengkelkan. 

[ADUH] 

Atau jika kita membuatnya seperti 1.000 langkah di time-- sebuah 

BAIK. Jadi kita akan meninggalkan satu itu saja. Jadi sekali lagi, membangun blocks-- saya dimulai dengan sesuatu yang super sederhana, dan kemudian saya menambahkan fitur, menambahkan fitur, menambahkan fitur. Dan saya tidak lagi perlu khawatir tentang bagaimana pertama fitur tersebut dilaksanakan seperti yang saya terus ke lapisan hal-hal di atas. Jadi sebenarnya, biarkan aku melakukan satu lainnya di sini. Biarkan aku pergi ke depan dan membuka file yang Aku membawa di muka, disebut Domba. 

Sehingga memiliki sedikit berbeda Karakter yang terlihat seperti ini. Dan biarkan aku melihat apakah saya tidak bisa melakukan sesuatu menggunakan counter dalam hal ini case-- variabel disebut. Aku akan pergi ke depan dan di bawah Events-- biarkan aku mendapatkan bendera hijau diklik. Lalu biarkan aku pergi ke Data, yang saya tahu dari hanya bermain-main sebelumnya, adalah di mana variabel. Dan aku akan pergi ke depan dan tarik ini. 

Jadi variabel yang disebut counter, dan Aku akan menginisialisasi ke nol. Saya bisa menyebutnya anything-- x atau y atau z-- tetapi dalam pemrograman, memanggil sesuatu dalam semantik cara yang berguna, seperti counter, yang menjelaskan apa itu, itu adalah jauh lebih mudah untuk membaca kode Anda nanti. Biarkan aku pergi ke depan dan mendapatkan selamanya memblokir sini. Dan biarkan aku pergi ke penampilan Halaman dan melakukan blok Say. Tapi apa yang keren tentang variabel adalah saya tidak perlu ketik saja sesuatu seperti halo dunia, yang kita sudah sudah dilakukan, saya malah bisa pergi ke Data dan tarik variabel saya, dan bahkan meskipun bentuknya tidak cukup terlihat seperti itu harus sesuai, akan tumbuh untuk mengisi. Dan aku hanya akan mengatakan meja untuk satu spoiler-- second-- dia akan menghitung. Kami akan mengatakannya selama satu detik. Lalu aku akan pergi dan memiliki dia menunggu satu detik, sehingga tidak menghitung terlalu cepat. Dan kemudian terakhir, mengubah meja oleh satu-- dengan kata lain, increment counter per satu nilai tambah dan melakukan ini selamanya. 

Jadi domba juga, seperti programmer, menghitung dari 0. Dan jika kita menunggu cukup lama, ia akan melakukan hal ini selamanya. Tapi itu tidak sepenuhnya benar, karena pada kenyataannya, seperti yang akan kita temukan di minggu satu, bilangan bulat dan komputer lebih umum, secara teknis hanya memiliki finite-- baik, bukan komputer, ketika mereka mewakili bilangan bulat, hanya memiliki jumlah terbatas bit. Mereka lampu ada hanya bisa menghitung begitu tinggi sebelum Anda keluar dari bola lampu. Dan komputer juga, hanya memiliki begitu banyak memori, hanya memiliki begitu banyak transistor, sehingga hanya bisa menghitung begitu tinggi. 

Jadi ternyata bahwa domba, Saya pikir, bisa menghitung sampai 2 miliar atau sesuatu yang cukup besar. Jadi kita tidak akan menunggu hal ini terjadi. Tapi akhirnya beberapa bug yang akan terjadi yang dapat memiliki beberapa dunia yang sangat nyata akibat. Tapi di luar domba, yang hanya memperkenalkan variabel. Mari kita pergi ke depan dan membuka sesuatu yang saya dilakukan di muka di sini disebut Pet yang Cat-- Pet Cat di sini. Dan perhatikan di sini itu beberapa blok, tapi ketika bendera hijau diklik, selamanya melakukan hal berikut. Jika Anda menyentuh mouse pointer-- sehingga kursor pada layar, yang arrow-- bermain meow suara dan kemudian menunggu dua detik. Dan hanya melakukan ini selamanya. Hanya terus menunggu untuk melihat apakah pointer-- yang jika kucing menyentuh pointer. 

Jadi saya tekan tombol play. Tidak ada yang terjadi. Tapi seperti yang saya gerakkan kursor kucing, 

[MENGEONG] 

Dan jika aku memindahkannya, tidak membelai kucing lagi. Jadi beberapa logika kondisional bersarang di dalam loop. Bagaimana contoh ini, sengaja disebut Jangan Pet Cat? Apa ini akan lakukan? 

[MENGEONG] 

Mengapa Anda tidak pet kucing? 

[MENGEONG] 

BAIK. Jadi ini adalah contoh dari sebuah jika yang lain. Ini adalah titik keputusan dan karena duduk dalam lingkaran, mereka berdua mendapatkan diperiksa. Apakah ini benar? Apakah ini benar? Apakah ini benar? Apakah ini benar? Dan akhirnya, salah satu dari mereka akan menerapkan dan sehingga Anda mendengar baik meow atau raungan singa dalam kasus itu. 

Nah, mari kita lakukan satu sedikit lebih mewah yang saya buat di muka too-- benang. Jadi benang adalah salah satu hal yang komputer dapat dilakukan. Jadi program multi-ulir adalah sebuah program yang dapat melakukan beberapa hal sekaligus. Dan semua contoh ini sejauh ini telah hanya satu script, sehingga untuk speak-- satu program seperti ini di sini. Tapi melihat program ini memiliki dua sprite, dua karakter. Salah satunya adalah burung. Salah satunya adalah kucing. 

Dan perhatikan ketika saya klik pada ini turun kiri, mereka masing-masing memiliki skrip mereka sendiri atau program yang terkait dengan mereka. Dan kedua dari mereka program, pemberitahuan, mulai dengan bendera clicked-- ketika hijau mari kita lihat cat-- yang ketika bendera hijau diklik. Dan memang, ketika saya tekan tombol play sekarang, dua hal yang akan terjadi sekaligus. Kucing dan burung keduanya akan beroperasi secara bersamaan untuk membuat efek ini. Dan Anda bayangkan apa yang terjadi. Ada loop dan burung dan kucing berada dalam satu kelompok. Burung itu hanya memantul seperti Saya sebelumnya ketika saya mengatakan aduh. Tapi kucing itu jelas memiliki keuntungan. Ada blok penginderaan lain yang menunjuk kucing sengaja untuk burung dalam kasus ini di sini. Jadi kita bisa menggoda terpisah, dengan melihat melalui blok-blok, apa yang terjadi. Tetapi bahan utama di sini adalah salah satu. Burung, sehingga game ini tidak benar-benar boring-- atau animation-- ini dimulai pada arah yang acak. Dan komputer adalah memilih angka antara 90 dan 180 dasarnya, sehingga itu sedikit animasi yang berbeda setiap kali. 

Dan kemudian melihat di sini, jika kucing menyentuh burung, maka bermain singa empat sound-- gemuruh. Tetapi sementara di burung palet, kita memiliki ini. Selamanya, jika tidak menyentuh kucing, terus bergerak tiga langkah. Dan maka di sini adalah potongan puzzle yang lain. Jika Anda berada di tepi, bangkit. Jadi burung ini hanya jenis mengurus bisnis sendiri, hanya terbang di sekitar dan memantul, dan itu benar-benar kucing yang memiliki logika kondisional untuk menentukan apakah itu telah menangkap burung. Baiklah. Jadi mari kita melakukan satu lain di sini, satu ini disebut Hi Hi Hi. Dan yang satu ini di sini hanya melakukan ini dalam selamanya lingkaran. Tapi notice-- bagaimana kita menghentikan program ini sangat mengganggu? Tekan tombol spasi. Karena jika saya melakukan itu, yang program-- tangan kiri melihat itu terus listening-- adalah ruang tekan tombol. Jika ruang bar ditekan, dan jika demikian, apa fungsinya? Itu tidak teknik yang sangat umum. Ini menetapkan variabel sama dengan beberapa nilai. Tapi ia mengubah nilai tersebut. [? Jadi penampilan?] berdasarkan shape-- I memiliki variabel yang saya menulis di muka disebut Diredam, yang hanya mengatakan ya atau tidak. Apakah suara dimatikan atau tidak? Benar atau salah? Dan pemberitahuan, saya katakan ini-- jika diredam adalah nol, kemudian berubah menjadi satu, lain mengatur bisu ke nol. Jadi hanya flip nilai dari nol sampai satu. Aku bisa memiliki done-- mengubahnya dari dua hingga tiga dan 3-2 atau 4-5 atau 4-6. Tapi itu tidak masalah apa angka yang saya gunakan, asalkan aku tetap mengubahnya sebaliknya. 

Dan yang paling programmer hanya akan memilih nol dan satu-- palsu dan benar, off dan on-- untuk mewakili ini. Dan ini masih berjalan. Jika saya memukul spasi lagi 

[SEAL SOUNDS] 

Program ini masih berjalan. Karena ada script lain ini yang mengatakan, selamanya melakukan hal berikut. Jika variabel diredam sama zero-- jadi jika Anda tidak diredam adalah logic-- jika itu palsu atau tidak, maka memutar suara, karena Anda tidak diredam. Anda harus bermain suara dan kemudian berpikir hi hi hi selama dua detik dan kemudian menunggu, dan melakukannya lagi dan lagi dan lagi. 

Dan dengan cara ini kita memiliki cara untuk orang to-- untuk program untuk berinteraksi. Dan mereka tidak perlu sebagaimana tanggal yang lain. Bahkan, menusuk around-- no pun intended-- seseorang menghabiskan sejumlah besar waktu di internet menerapkan PokemonGo di Scratch. Bahkan geolocates Anda di Cambridge atau Allston sini. Jadi jika Anda ingin melihat terlalu apa yang orang dapat lakukan adalah ini-- menu yang sangat mewah. Klik di sini. 

Ini aku dengan tombol panah saya sekarang. Aku akan pergi setelah ini. Klik. Dan sekarang Anda klik pokeball itu. Maksudku, saya pikir Anda seharusnya klik pokeball itu. Baiklah. Jadi saya melakukan itu. Aku bisa pergi ke sini. Dan orang ini dilaksanakan lagi Pokeballs lebih di sini-tiga Pokeballs. 

Kami akan memposting link ke ini online sehingga Anda bisa bermain. Tapi melihat ada hanya beberapa blok bangunan dasar. Ini terlihat banyak pengujian, dan itu. Hal ini mengesankan dan lebih daripada kita akan biasanya berharap, tentu untuk masalah ditetapkan nol. Saya tidak tahu berapa lama orang ini menghabiskan online. Tapi itu semua hanya satu lingkaran. Ada bermain suara. Ada beberapa jenis loop mendengarkan apakah saya memukul panah ke atas atau ke bawah panah atau kiri dan kanan, dan kemudian jika demikian, itu bergerak itu beberapa jumlah piksel. Dan kemudian jika saya klik sprite lain, ada semacam jika kondisi di sana. Ya, ini sudah terlalu intens. Kita akan berhenti. Ini semua blok bangunan yang dasar. Tidak ada bahan lain lain daripada yang kita telah melihat sudah. 

Namun di sini, biarkan aku melakukan satu set final contoh yang melukiskan gambaran terlalu dari apa yang dapat Anda lakukan di sini. Berikut adalah program yang sangat sederhana yang hanya melakukan ini-- batuk, batuk, batuk. Dan hanya berdasarkan apa yang kita telah melihat sejauh ini, di mana adalah jelas kesempatan untuk perbaikan. Program ini benar. Hal batuk tiga kali, yang merupakan apa yang dimaksudkan. Tapi itu diimplementasikan dengan buruk. Ini dirancang buruk. Mengapa? Ya. Ini bukan lingkaran. Dan itu tidak begitu banyak bahwa itu bukan lingkaran, itu bahwa ada banyak redundansi. Ada disalin dan kode disisipkan, sehingga untuk berbicara. Dan solusinya mungkin memang lingkaran. Jadi biarkan aku pergi ke depan dan memperbaiki itu. Dan aku akan menyeret ini di sini. Biarkan aku pergi ke depan dan mendapatkan mengulang blok, mengubahnya ke tiga. Aku akan membuang beberapa blok-blok. 

Dan Anda akan melihat itu cukup intuitif. Anda drag dan drop dan hal-hal muncul dan menghilang akhirnya. Dan aku hanya bisa menyeret ini di sini, dan sekarang saya memiliki versi bersih masih. Tapi kau tahu apa? Ada kesempatan ini sekarang ke abstraction-- untuk memulai untuk menentukan kosa kata baru bahwa MIT tidak mengantisipasi. Ada menunggu dan ulangi dan selamanya dan jika, tapi bagaimana jika saya ingin memperkenalkan kata batuk sebagai blok? Bagaimana jika saya ingin sepotong puzzle Tujuan yang dalam hidup adalah batuk? 

Nah, mari kita lihat versi ini di sini, yang saya dibuat sebagai berikut. Ajaib, saya telah membuat potongan puzzle ini di sini, yang Scratch memungkinkan Anda untuk melakukan. Dan memang C dan Python dan JavaScript adalah akan memungkinkan Anda untuk melakukan hal ini juga. Anda dapat membuat kustom Anda sendiri potongan-potongan yang Anda sebut apa yang Anda inginkan. Dalam hal ini, batuk terasa seperti definisi yang masuk akal. Dan kemudian dengan potongan-potongan ini turun di sini dapat Anda mendefinisikan apa artinya. 

Aku menyeret dan menjatuhkan dari palet ini di sini-lebih blocks-- ungu besar ini blok, di mana saya mengetik di batuk sebagai nama potongan puzzle baru saya. Dan kemudian saya katakan setiap kali pengguna menyebut sepotong batuk puzzle baru, melakukan katakanlah dan menunggu. Dan di sini di blok saya ulangi, Aku hanya bisa batuk tiga kali. 

Dan saya berpendapat, terutama jika sekarang Anda menyembunyikan rincian ini. Siapa yang peduli bagaimana batuk diimplementasikan? Semua saya peduli sebagai programmer yang bisa saya batuk. Saya tidak peduli bagaimana mengatakan diimplementasikan. Aku hanya peduli bahwa kucing bisa mengatakan sesuatu. Aku bisa abstrak yang rinci dan hanya fokus pada apa yang ada di layar di sini. Tapi aku bisa mengambil satu langkah lebih jauh. 

Perhatikan bahwa di sini, saya memiliki diimplementasikan loop tiga kali. Tapi bagaimana jika sebaliknya saya ambil versi ini? Dan bagaimana jika sebaliknya dalam versi ini di sini, Saya hanya mengubah potongan puzzle saya untuk mengambil argumen dan masukan kepada dirinya sendiri? Dan masukan yang dapat nomor seperti tiga. Jadi sekarang, jika saya menulis sebuah program dan saya ingin kucing batuk, Aku benar-benar dapat memberitahu teka-teki potong berapa kali batuk, karena pada bagian bawah sini, sebuah pelamun versi potongan puzzle kustom memungkinkan saya menentukan bahwa batuk benar-benar membutuhkan sebuah input-- membawa argumen seperti ini. Dan kau tahu apa? Mungkin aku menyadari, tunggu sebentar. Batuk adalah same-- yang itu dasarnya ide yang sama seperti bersin-bersin. Itu hanya berbeda kata di layar. Aku bisa abstrak lebih lanjut dan menerapkan ini versi final dari batuk, yang sekilas adalah cara yang lebih kompleks cari. Tapi perhatikan apa yang saya lakukan. Saya sekarang generalized-- genericized really-- potongan puzzle ini disebut mengatakan kata n kali. 

Dan sekarang saya memiliki dua potongan teka-teki baru di sini mendefinisikan batuk n kali. Dan apa fungsi batuk lakukan? Apa saya kustom potongan puzzle lakukan? Itu hanya panggilan blok katakanlah, lewat di kata yang saya ingin mengatakan, lewat di nomor kali saya ingin mengatakan. Karena sekarang saya bisa menerapkan bersin dengan hanya mengatakan Achoo, dalam hal ini, beberapa beberapa kali. 

Dan jadi aku layering dan layering. Dan lagi, kuncinya di sini adalah tidak bagaimana saya menerapkan itu, tetapi kenyataannya bahwa jika saya hanya benar-benar bergerak ini dari layar, melihat bagaimana sederhana jika tidak cukup program saya sekarang terlihat. Karena itu tidak apa mengatakan, saya sudah disarikan pergi apa yang di dalam kotak hitam. itu terjadi menjadi sebuah kotak ungu di sini, tapi aku terhalang jauh apa yang di dalam karena saya tidak peduli bagaimana cara kerjanya. Aku hanya peduli sekarang bahwa ia bekerja. 

Dan memang, di masalah set nol, ini adalah persis jenis layering ide Anda akan memiliki kesempatan untuk mengeksplorasi. Ini persis kesempatan untuk menerapkan pemecahan masalah teknik, apa mungkin seorang lingkungan yang asing. Dan apakah Anda sudah tidak diprogram sebelum atau diprogram sebelumnya, Anda akan menemukan bahwa ada sedikit sesuatu dalam lingkungan ini untuk semua orang. Dan dengan permasalahan yang satu dalam waktu satu minggu, kita akan dialihkan ke fokus pada bahasa tingkat tinggi yang disebut C-- atau lebih tepatnya lebih rendah bahasa tingkat disebut C-- yang bahkan lebih kuat, meskipun itu sedikit lebih samar pada pandangan pertama. 

Dan Anda akan menyadari per TL hari ini: DR, bahwa masalah ini diatur memiliki lebih pendek jendela waktu dari yang di masa depan, hanya karena Anda harus merasa cukup diakses. Dan tidak perlu khawatir jika Anda menambahkan kelas akhir. Kami akan membahas yang lama. Dan sebelum kita menunda untuk kue, mari kita selesai dengan hanya dua menit tampilan apa yang menanti Anda di sini di CS50. [MUSIC PLAYING] Baiklah. Itu saja untuk CS50. Kami akan melihat Anda segera. Kue sekarang disajikan. [MUSIC PLAYING] SPEAKER 17: Pernahkah Anda mendengar dari cuti, Chief? SPEAKER 18: Mungkin ada lebih di bawah tenda. 