ZAMYLA CHAN: זהה אותי, Zamyla. היום ב מריו, אנחנו הולכים להיות ציור הפירמידה וחצי מריו לטפס. אז בואו נדבר על שלנו מטלות של לבעיה זו. אנחנו הולכים רוצים כדי להנחות ולאמת ממשתמש קלט חוקי של איך גבוה שהם רוצים הפירמידה של מריו להיות. ואז, אנחנו הולכים לצייר אותו. אז בואו נתחיל עם מעוררים אימות המשתמש עבור הקלט שלהם. 

אנחנו יכולים לעשות שימוש פונקצית ספריית CS50 לקבל int שיבטיח המשתמש תשומות שלמות. כל מספרים שלמים חיוביים, שלילי מספרים שלמים, מספר 0 כל המשחק ההוגן. אחר, המשתמש יתבקש שוב עד קלט הוא מספר שלם חוקי. עכשיו למרות int הגט עושה הרבה בשבילנו את העבודה על מנת להבטיח כי משתמש נותן לנו מספר שלם, אנחנו עדיין צריכים לפנות קצת אילוצים נוספים על זה. אחרי הכל, אנחנו לא יכולים להיות מריו טיפוס וחצי פירמידה בגובה 12 שלילי. 

בנוסף לכך, מפרט בעיה אומר כי אנו יכולים רק לאפשר מריו לטפס פירמידה גבהים בין 0 ל -23. אוקיי, אז זה אומר שאנחנו צריכים להציג למשתמש ברציפות לתת לנו תקף מספר ורק להמשיך פעם נתנו לנו לגובה תקף. איך אנחנו עושים את זה? 

ובכן, תהליכים מתמשכים לתת לנו הרעיון של loops-- עושה משהו שוב ושוב. לולאה אחת ב- C כמו זמן לולאה כי יהיה ברציפות לבצע את הגוף של הלולאה כל עוד התנאי הנתון מוערך נכון. ברגע שהתנאים מוערך שווא, התוכנית תמשיך מה שבא לאחר מכן. אז בעוד לולאות הם דרך אחת להבטיח כי אנו ללא הרף מהמשתמש קלט חוקי. וברגע שהם נותנים לנו קלט חוקי, אנו נתחיל מה שבא ליד. אנחנו יודעים שאנחנו הולכים לבקש המשתמש עבור קלט לפחות פעם אחת. אז עכשיו אנחנו מגיעים אחות של בעוד לולאה, המהווה את המטלות בזמן לולאה. 

האם בעוד לולאות תרצנה את גוף של הלולאה לפחות פעם אחת. אז בלי בדיקת מצבו, זה יהיה להפעיל את הגוף של הלולאה. ואז לבדוק את מצבו לראות אם היא צריכה לחזור על עצמה. יכולת זו שימושית במיוחד כאשר אנחנו אימות קלט משתמש. אנחנו יודעים שאנחנו הולכים לשאול אותם לפחות פעם אחת. אז לעשות בזמן לולאה אולי נראה משהו כזה. יש לנו n שלם. ובתוך של מטלות בעוד לולאה, אנחנו מיד מהמשתמש מספר שלם. אם n אינו חוקי, אז נצטרך להנחות אותם שוב ושוב ושוב עד שהם לתת לנו שלם חוקית. לבסוף, לאחר n הוא קלט חוקי, יהיה לנו להמשיך לשאר התוכנית שלנו. 

אז בואו נחזור אל המפרט והבדיקה מה תנאי קלט חוקי זה הולך להיות. הגבהים התקפים הולכים להיות בין 0 ל -23, כולל. אז לגבהים חוקיים הולכים להיות פחות מ 0 או יותר מ -23. אז לזכור לעצב מצבך בזהירות, לדעת כי התנאי עבור מטלות בעוד לולאה צריך להיות בזמן n אינה חוקית. עכשיו זה לא הולך להיות ביטוי בוליאני אחת פשוט. אנחנו הולכים צריכים לשלב שני ביטויים שונים לעשות כל מצבנו. 

אז בואו פשוט להסתכל שולחן אמת לי כבר נתתי לך את הרמז שאנחנו הולך להיות התמודדות עם שני Booleans. אז הנה שולחן אמת איפה אני יש שני Booleans-- בוליאני 1 ו -2. אז יש לנו את האפשרות להעריך bool1 ו bool2 או bool1 או bool2. וזה יהיה נכון רק אם הן Booleans להעריך אל נכון, ואילו כל או יהיה נכון כל עוד אחד השניים Booleans מוערך נכון. אוקיי, אז לקחת רגע, להשהות זה וידאו ולעכל השולחן את האמת הזאת. אני אהיה כאן מחכה. כאשר אתם חוזרים, ראו אם אתה יכול להרכיב ביטוי בוליאני עבור שלך מצבו של n להיות קלט לא חוקי. 

אז עכשיו שיש לנו קלט משתמש חוקי, בואו אתם מוזמנים לדבר על איך אנחנו אולי לצייר את הפירמידה וחצי. כאן בעורך הטקסט הפשוט הזה, שרטטתי פירמידה מיושרת לשמאל. אבל אנחנו יודעים שאנחנו צריכים שלנו פירמידה להיות מתואמת תקינה. אז איך יכול אני עושה את זה? ובכן, אולי הייתי מנסה לדחוף הכל הצידה רק על ידי הצבת קצת אופי שביניהם. ואז, עבור הבא קו, אני הולך לשים כמה דמויות יותר לדחוף אותו יחד, ו further-- הלאה וכן הלאה forth-- עד שיש לי פירמידה מיושרת ימינה. אז יש לנו פירמידה תקינה align, אבל זה לא נראה כל כך גדול עם הנקודות. אבל אנחנו עדיין רוצים גורס כי מרווח נחמד. אז אני הולך ממש להכניס קצת רווחים. 

במקום שלוש נקודות, אני יהיה אחד לשים, שני, שלושה מקומות. על הקו השני. אני אשים אחד, שני חללים. ועל הלפני האחרון קו, יש רק מקום אחד. והנה יש לי פירמידה מיושרת ימינה. מלעשות את הדוגמה בטקסט עורך, יש לנו רעיון הדפוס כי נשתמש לצייר הפירמידה וחצי. עבור כל שורה, מה שעשינו אנו הוא להקליד כמה מקומות, ולאחר מכן הקלדת כמה hashes, ולאחר מכן הקלדה על מקש Enter, אשר הוא יצירת קו חדש. אז עכשיו יש לנו את זה, בואו נלך צעד אחד קדימה ולמצוא דפוס. 

אז אני הולך להגיד, עבור עניין של דוגמה זו, יש לנו עסק עם גובה של 8. השורה הראשונה הוא הולך להיות שני hashes העוקב שבעה מקומות. ה- Hash שלושה שהדבר--, שישה מקומות. ארבעה Hash row-- השלישי, חמש spaces-- הלאה וכן הלאה עד שנגיע לשורה המי יודע כמה. אז, אני שואל אותך עבור השורה המי יודע כמה, כמה hashes אנחנו הולכים להיות וכמה מקומות? אז זה תלוי בך כדי להבין הנוסחה לייצג כמה hashes וכמה מקומות נדרשים בשורה המי יודע כמה כאשר יש לך קצת גובה. 

עכשיו כשאתה חישוב זה החוצה, להיזהר איך אתה לאינדקס. לפי מה שאני אומר זה הוא כי בחיי היומיום כולנו מתחילים לספור, בדרך כלל על ידי 1. אבל CS50 ו במדעי המחשב בכלל, אנחנו 0 צמודים. אז בשורה הראשונה תהיה n של 0 בניגוד 1. היזהר של זה כשאתה מנסה להבין הדפוס שלך. אז עכשיו בואו נחזור לאופן אנחנו הולכים לצייר הפירמידה שלנו. עבור כל שורה, אנחנו הולכים רוצים להדפיס את החללים, להדפיס ה- Hash, ואז להדפיס שורה חדשה. הרמז כאן הוא המילה "עבור" כל שורה. ב C, יש לנו מבנה נקרא עבור לולאה, מורכב של אתחול, תנאי, עדכון, והגוף של הלולאה. 

נגיד שאני רוצה לומר, שלום בעולם, 50 פעמים, שלי עבור לולאה היה נראה משהו כזה. אני לאתחל שלם שלי 0. התנאי הוא שאני הוא פחות מ -50. ואז העדכון שלי הוא רק הגדיל לי על ידי אחד בכל פעם. גם אנחנו יכולים להשתמש בלולאות for כדי לחזר על דברים. שימו לב כאן איך לא אנחנו מקודד קשה מספר, אלא להציב את המשתנה גובה במקום את מצבו. אז מה אני עושה כאן אני iterating על כל שורה של הפירמידה. אני יכול לעשות משהו עבור כל שורה בתוך הגוף של הלולאה שלי. 

מה שאנחנו עושים בתוך הגוף של הלולאה? ובכן, כפי שכבר אמרנו, אנחנו מדפיסים רווחים ואנחנו מדפיסים hashes ואנחנו מדפיסים קו חדש. אז החיצוני שלי עבור לולאה יראה ככה. אני לחזר על כל שורה הפירמידה, באמצעות, במקרה זה, גובה כמשתנה המאחסן את גובה הפירמידה. בתוך הגוף של הלולאה כי, אני הולך להדפיס רווחים שוב ושוב, הדפסה ה- Hash שוב ושוב, ואז להדפיס שורה חדשה. 

אז עכשיו, באמצעות כל המושגים דיברתי על ב ללכת דרך זו, אתה אמור להיות מסוגל להנחות את משתמש עבור קלט, לאמת קלט, ולאחר מכן לצייר את הפירמידה וחצי. 

שמי Zamyla, וזו CS50. 