1
00:00:00,000 --> 00:00:00,500

2
00:00:00,500 --> 00:00:02,500
ZAMYLA CHAN: זהה אותי, Zamyla.

3
00:00:02,500 --> 00:00:06,910
היום ב מריו, אנחנו הולכים להיות
ציור הפירמידה וחצי מריו

4
00:00:06,910 --> 00:00:08,290
לטפס.

5
00:00:08,290 --> 00:00:11,570
>> אז בואו נדבר על שלנו
מטלות של לבעיה זו.

6
00:00:11,570 --> 00:00:13,610
אנחנו הולכים רוצים
כדי להנחות ולאמת

7
00:00:13,610 --> 00:00:18,290
ממשתמש קלט חוקי של איך
גבוה שהם רוצים הפירמידה של מריו להיות.

8
00:00:18,290 --> 00:00:20,090
ואז, אנחנו הולכים לצייר אותו.

9
00:00:20,090 --> 00:00:24,870
אז בואו נתחיל עם מעוררים
אימות המשתמש עבור הקלט שלהם.

10
00:00:24,870 --> 00:00:27,640
>> אנחנו יכולים לעשות שימוש
פונקצית ספריית CS50

11
00:00:27,640 --> 00:00:31,160
לקבל int שיבטיח
המשתמש תשומות שלמות.

12
00:00:31,160 --> 00:00:35,730
כל מספרים שלמים חיוביים, שלילי
מספרים שלמים, מספר 0 כל המשחק ההוגן.

13
00:00:35,730 --> 00:00:41,670
אחר, המשתמש יתבקש
שוב עד קלט הוא מספר שלם חוקי.

14
00:00:41,670 --> 00:00:44,210
עכשיו למרות int הגט עושה
הרבה בשבילנו את העבודה

15
00:00:44,210 --> 00:00:46,730
על מנת להבטיח כי
משתמש נותן לנו מספר שלם,

16
00:00:46,730 --> 00:00:50,760
אנחנו עדיין צריכים לפנות קצת
אילוצים נוספים על זה.

17
00:00:50,760 --> 00:00:56,420
אחרי הכל, אנחנו לא יכולים להיות מריו טיפוס
וחצי פירמידה בגובה 12 שלילי.

18
00:00:56,420 --> 00:00:59,040
>> בנוסף לכך,
מפרט בעיה

19
00:00:59,040 --> 00:01:02,490
אומר כי אנו יכולים רק
לאפשר מריו לטפס

20
00:01:02,490 --> 00:01:06,940
פירמידה גבהים בין 0 ל -23.

21
00:01:06,940 --> 00:01:11,120
אוקיי, אז זה אומר שאנחנו צריכים
להציג למשתמש ברציפות

22
00:01:11,120 --> 00:01:14,320
לתת לנו תקף
מספר ורק להמשיך

23
00:01:14,320 --> 00:01:17,120
פעם נתנו לנו לגובה תקף.

24
00:01:17,120 --> 00:01:18,720
איך אנחנו עושים את זה?

25
00:01:18,720 --> 00:01:23,760
>> ובכן, תהליכים מתמשכים לתת לנו
הרעיון של loops-- עושה משהו

26
00:01:23,760 --> 00:01:24,720
שוב ושוב.

27
00:01:24,720 --> 00:01:28,220
לולאה אחת ב- C כמו זמן
לולאה כי יהיה ברציפות

28
00:01:28,220 --> 00:01:33,480
לבצע את הגוף של הלולאה כל עוד
התנאי הנתון מוערך נכון.

29
00:01:33,480 --> 00:01:36,200
ברגע שהתנאים
מוערך שווא,

30
00:01:36,200 --> 00:01:39,770
התוכנית תמשיך
מה שבא לאחר מכן.

31
00:01:39,770 --> 00:01:43,180
אז בעוד לולאות הם דרך אחת
להבטיח כי אנו ללא הרף

32
00:01:43,180 --> 00:01:45,320
מהמשתמש קלט חוקי.

33
00:01:45,320 --> 00:01:50,070
וברגע שהם נותנים לנו קלט חוקי,
אנו נתחיל מה שבא ליד.

34
00:01:50,070 --> 00:01:54,380
אנחנו יודעים שאנחנו הולכים לבקש
המשתמש עבור קלט לפחות פעם אחת.

35
00:01:54,380 --> 00:01:59,200
אז עכשיו אנחנו מגיעים אחות של
בעוד לולאה, המהווה את המטלות בזמן לולאה.

36
00:01:59,200 --> 00:02:02,650
>> האם בעוד לולאות תרצנה את
גוף של הלולאה לפחות פעם אחת.

37
00:02:02,650 --> 00:02:06,150
אז בלי בדיקת מצבו,
זה יהיה להפעיל את הגוף של הלולאה.

38
00:02:06,150 --> 00:02:09,750
ואז לבדוק את מצבו לראות
אם היא צריכה לחזור על עצמה.

39
00:02:09,750 --> 00:02:13,080
יכולת זו שימושית במיוחד כאשר
אנחנו אימות קלט משתמש.

40
00:02:13,080 --> 00:02:15,830
אנחנו יודעים שאנחנו הולכים
לשאול אותם לפחות פעם אחת.

41
00:02:15,830 --> 00:02:18,780
אז לעשות בזמן לולאה אולי
נראה משהו כזה.

42
00:02:18,780 --> 00:02:20,090
יש לנו n שלם.

43
00:02:20,090 --> 00:02:22,760
ובתוך של מטלות
בעוד לולאה, אנחנו מיד

44
00:02:22,760 --> 00:02:24,750
מהמשתמש מספר שלם.

45
00:02:24,750 --> 00:02:29,740
אם n אינו חוקי, אז נצטרך להנחות אותם
שוב ושוב ושוב עד שהם

46
00:02:29,740 --> 00:02:31,820
לתת לנו שלם חוקית.

47
00:02:31,820 --> 00:02:37,440
לבסוף, לאחר n הוא קלט חוקי, יהיה לנו
להמשיך לשאר התוכנית שלנו.

48
00:02:37,440 --> 00:02:41,830
>> אז בואו נחזור אל המפרט והבדיקה
מה תנאי קלט חוקי

49
00:02:41,830 --> 00:02:43,670
זה הולך להיות.

50
00:02:43,670 --> 00:02:48,090
הגבהים התקפים הולכים
להיות בין 0 ל -23, כולל.

51
00:02:48,090 --> 00:02:53,350
אז לגבהים חוקיים הולכים
להיות פחות מ 0 או יותר מ -23.

52
00:02:53,350 --> 00:02:56,420
אז לזכור לעצב
מצבך בזהירות,

53
00:02:56,420 --> 00:02:58,660
לדעת כי התנאי
עבור מטלות בעוד לולאה

54
00:02:58,660 --> 00:03:01,470
צריך להיות בזמן n אינה חוקית.

55
00:03:01,470 --> 00:03:05,080
עכשיו זה לא הולך להיות
ביטוי בוליאני אחת פשוט.

56
00:03:05,080 --> 00:03:07,630
אנחנו הולכים צריכים לשלב
שני ביטויים שונים

57
00:03:07,630 --> 00:03:09,900
לעשות כל מצבנו.

58
00:03:09,900 --> 00:03:13,290
>> אז בואו פשוט להסתכל שולחן אמת לי
כבר נתתי לך את הרמז שאנחנו

59
00:03:13,290 --> 00:03:15,200
הולך להיות התמודדות עם שני Booleans.

60
00:03:15,200 --> 00:03:19,620
אז הנה שולחן אמת איפה אני
יש שני Booleans-- בוליאני 1 ו -2.

61
00:03:19,620 --> 00:03:27,050
אז יש לנו את האפשרות להעריך
bool1 ו bool2 או bool1 או bool2.

62
00:03:27,050 --> 00:03:31,980
וזה יהיה נכון רק אם הן
Booleans להעריך אל נכון, ואילו כל

63
00:03:31,980 --> 00:03:37,280
או יהיה נכון כל עוד אחד
השניים Booleans מוערך נכון.

64
00:03:37,280 --> 00:03:41,450
אוקיי, אז לקחת רגע, להשהות זה
וידאו ולעכל השולחן את האמת הזאת.

65
00:03:41,450 --> 00:03:42,930
אני אהיה כאן מחכה.

66
00:03:42,930 --> 00:03:45,760
כאשר אתם חוזרים, ראו
אם אתה יכול להרכיב

67
00:03:45,760 --> 00:03:51,910
ביטוי בוליאני עבור שלך
מצבו של n להיות קלט לא חוקי.

68
00:03:51,910 --> 00:03:54,420
>> אז עכשיו שיש לנו
קלט משתמש חוקי, בואו

69
00:03:54,420 --> 00:03:58,710
אתם מוזמנים לדבר על איך אנחנו
אולי לצייר את הפירמידה וחצי.

70
00:03:58,710 --> 00:04:03,410
כאן בעורך הטקסט הפשוט הזה,
שרטטתי פירמידה מיושרת לשמאל.

71
00:04:03,410 --> 00:04:07,050
אבל אנחנו יודעים שאנחנו צריכים שלנו
פירמידה להיות מתואמת תקינה.

72
00:04:07,050 --> 00:04:08,650
אז איך יכול אני עושה את זה?

73
00:04:08,650 --> 00:04:11,440
ובכן, אולי הייתי מנסה לדחוף
הכל הצידה

74
00:04:11,440 --> 00:04:14,880
רק על ידי הצבת קצת
אופי שביניהם.

75
00:04:14,880 --> 00:04:16,779
ואז, עבור הבא
קו, אני הולך לשים

76
00:04:16,779 --> 00:04:20,970
כמה דמויות יותר לדחוף אותו יחד,
ו further-- הלאה וכן הלאה forth--

77
00:04:20,970 --> 00:04:23,360
עד שיש לי פירמידה מיושרת ימינה.

78
00:04:23,360 --> 00:04:27,780
אז יש לנו פירמידה תקינה align, אבל
זה לא נראה כל כך גדול עם הנקודות.

79
00:04:27,780 --> 00:04:30,680
אבל אנחנו עדיין רוצים
גורס כי מרווח נחמד.

80
00:04:30,680 --> 00:04:35,260
אז אני הולך ממש
להכניס קצת רווחים.

81
00:04:35,260 --> 00:04:39,420
>> במקום שלוש נקודות, אני יהיה
אחד לשים, שני, שלושה מקומות.

82
00:04:39,420 --> 00:04:40,370
על הקו השני.

83
00:04:40,370 --> 00:04:42,640
אני אשים אחד, שני חללים.

84
00:04:42,640 --> 00:04:45,370
ועל הלפני האחרון
קו, יש רק מקום אחד.

85
00:04:45,370 --> 00:04:48,290
והנה יש לי פירמידה מיושרת ימינה.

86
00:04:48,290 --> 00:04:52,170
מלעשות את הדוגמה בטקסט
עורך, יש לנו רעיון הדפוס

87
00:04:52,170 --> 00:04:54,590
כי נשתמש לצייר הפירמידה וחצי.

88
00:04:54,590 --> 00:04:58,080
עבור כל שורה, מה שעשינו
אנו הוא להקליד כמה מקומות,

89
00:04:58,080 --> 00:05:00,170
ולאחר מכן הקלדת כמה
hashes, ולאחר מכן הקלדה

90
00:05:00,170 --> 00:05:03,020
על מקש Enter, אשר
הוא יצירת קו חדש.

91
00:05:03,020 --> 00:05:07,770
אז עכשיו יש לנו את זה, בואו נלך
צעד אחד קדימה ולמצוא דפוס.

92
00:05:07,770 --> 00:05:10,170
>> אז אני הולך להגיד, עבור
עניין של דוגמה זו,

93
00:05:10,170 --> 00:05:12,480
יש לנו עסק עם גובה של 8.

94
00:05:12,480 --> 00:05:17,100
השורה הראשונה הוא הולך להיות שני
hashes העוקב שבעה מקומות.

95
00:05:17,100 --> 00:05:20,020
ה- Hash שלושה שהדבר--, שישה מקומות.

96
00:05:20,020 --> 00:05:24,260
ארבעה Hash row-- השלישי, חמש
spaces-- הלאה וכן הלאה

97
00:05:24,260 --> 00:05:26,350
עד שנגיע לשורה המי יודע כמה.

98
00:05:26,350 --> 00:05:31,540
אז, אני שואל אותך עבור השורה המי יודע כמה,
כמה hashes אנחנו הולכים להיות

99
00:05:31,540 --> 00:05:33,120
וכמה מקומות?

100
00:05:33,120 --> 00:05:37,000
אז זה תלוי בך כדי להבין
הנוסחה לייצג כמה hashes

101
00:05:37,000 --> 00:05:42,020
וכמה מקומות נדרשים
בשורה המי יודע כמה כאשר יש לך קצת גובה.

102
00:05:42,020 --> 00:05:46,060
>> עכשיו כשאתה חישוב זה החוצה,
להיזהר איך אתה לאינדקס.

103
00:05:46,060 --> 00:05:49,170
לפי מה שאני אומר זה הוא כי
בחיי היומיום כולנו

104
00:05:49,170 --> 00:05:51,540
מתחילים לספור, בדרך כלל על ידי 1.

105
00:05:51,540 --> 00:05:55,950
אבל CS50 ו במדעי המחשב
בכלל, אנחנו 0 צמודים.

106
00:05:55,950 --> 00:06:00,620
אז בשורה הראשונה תהיה
n של 0 בניגוד 1.

107
00:06:00,620 --> 00:06:04,550
היזהר של זה כשאתה
מנסה להבין הדפוס שלך.

108
00:06:04,550 --> 00:06:07,570
אז עכשיו בואו נחזור לאופן
אנחנו הולכים לצייר הפירמידה שלנו.

109
00:06:07,570 --> 00:06:12,300
עבור כל שורה, אנחנו הולכים רוצים
להדפיס את החללים, להדפיס ה- Hash,

110
00:06:12,300 --> 00:06:14,050
ואז להדפיס שורה חדשה.

111
00:06:14,050 --> 00:06:19,160
הרמז כאן הוא
המילה "עבור" כל שורה.

112
00:06:19,160 --> 00:06:21,470
ב C, יש לנו מבנה
נקרא עבור לולאה,

113
00:06:21,470 --> 00:06:25,250
מורכב של
אתחול, תנאי, עדכון,

114
00:06:25,250 --> 00:06:26,790
והגוף של הלולאה.

115
00:06:26,790 --> 00:06:31,360
>> נגיד שאני רוצה לומר, שלום
בעולם, 50 פעמים, שלי עבור לולאה

116
00:06:31,360 --> 00:06:32,880
היה נראה משהו כזה.

117
00:06:32,880 --> 00:06:35,480
אני לאתחל שלם שלי 0.

118
00:06:35,480 --> 00:06:38,230
התנאי הוא שאני הוא פחות מ -50.

119
00:06:38,230 --> 00:06:42,350
ואז העדכון שלי הוא רק
הגדיל לי על ידי אחד בכל פעם.

120
00:06:42,350 --> 00:06:45,140
גם אנחנו יכולים להשתמש בלולאות for
כדי לחזר על דברים.

121
00:06:45,140 --> 00:06:47,820
שימו לב כאן איך לא אנחנו
מקודד קשה מספר,

122
00:06:47,820 --> 00:06:51,820
אלא להציב את המשתנה
גובה במקום את מצבו.

123
00:06:51,820 --> 00:06:56,420
אז מה אני עושה כאן אני iterating
על כל שורה של הפירמידה.

124
00:06:56,420 --> 00:07:00,160
אני יכול לעשות משהו עבור כל
שורה בתוך הגוף של הלולאה שלי.

125
00:07:00,160 --> 00:07:02,350
>> מה שאנחנו עושים בתוך
הגוף של הלולאה?

126
00:07:02,350 --> 00:07:07,120
ובכן, כפי שכבר אמרנו, אנחנו מדפיסים
רווחים ואנחנו מדפיסים hashes

127
00:07:07,120 --> 00:07:09,480
ואנחנו מדפיסים קו חדש.

128
00:07:09,480 --> 00:07:11,950
אז החיצוני שלי עבור לולאה
יראה ככה.

129
00:07:11,950 --> 00:07:15,070
אני לחזר על כל שורה
הפירמידה, באמצעות,

130
00:07:15,070 --> 00:07:18,890
במקרה זה, גובה כמשתנה
המאחסן את גובה הפירמידה.

131
00:07:18,890 --> 00:07:22,870
בתוך הגוף של הלולאה כי, אני
הולך להדפיס רווחים שוב ושוב, הדפסה

132
00:07:22,870 --> 00:07:26,730
ה- Hash שוב ושוב,
ואז להדפיס שורה חדשה.

133
00:07:26,730 --> 00:07:31,010
>> אז עכשיו, באמצעות כל המושגים
דיברתי על ב ללכת דרך זו,

134
00:07:31,010 --> 00:07:35,210
אתה אמור להיות מסוגל להנחות את
משתמש עבור קלט, לאמת קלט,

135
00:07:35,210 --> 00:07:37,370
ולאחר מכן לצייר את הפירמידה וחצי.

136
00:07:37,370 --> 00:07:41,510
>> שמי Zamyla, וזו CS50.

137
00:07:41,510 --> 00:07:43,167

