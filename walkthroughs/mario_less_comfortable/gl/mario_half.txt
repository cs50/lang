ZAMYLA CHAN: É unha me, Zamyla. Hoxe en Mario, seremos deseñar a metade da pirámide para Mario para subir. Entón imos falar sobre a nosa to-do de a este problema. Nós imos querer para solicitar e validar o usuario a unha entrada válida como alta que queren pirámide de Mario para ser. E entón, imos deséñase la. Entón, imos comezar con suxestións e validando o usuario para a súa entrada. 

Podemos facer uso da Función CS50 Biblioteca obter int que vai garantir que o usuario inserir un número enteiro. Calquera números enteiros positivos, negativos enteiros, o número 0 son todos xogo xusto. En caso contrario, o usuario será solicitada a repetir ata que a entrada dun número enteiro válido. Agora, aínda get int fai unha gran parte do traballo para nós no sentido de garantir que o do usuario dános un número enteiro, aínda necesitamos aplicar algún restricións adicionais sobre iso. Ao final, non podemos ter Mario escalada media pirámide de altura negativo de 12. 

Ademais de que, o especificación problema di que só podemos permitir que Mario para subir unha pirámide de alturas entre 0 e 23. OK, o que significa que necesitamos para alertar o usuario continuamente para dar unha válida número e só seguen xa que nos deron unha altura válida. Como podemos facer iso? 

Ben, procesos continuos darnos a idea de facer algo loops-- repetitivamente. Un circuíto en C como un tempo loop que continuamente executar o corpo do lazo mentres a condición dada é valorada como certa. Así que esta condición valorada como falsa, o programa continuar o que vén despois diso. Así, mentres loops son unha forma de garantindo que continuamente solicitar ao usuario a unha entrada válida. E xa que eles nos dan unha entrada válida, imos avanzar o que vén a continuación. Sabemos que imos pedir o usuario para a entrada de polo menos unha vez. Entón, agora chegamos a unha irmá do mentres loop, que é o loop Do While. 

Fai while executará corpo do lazo, polo menos, unha vez máis. Así, sen a comprobación da condición, el utilizará o corpo do lazo. E, a continuación, comprobar a condición para ver se se repetir. Isto vén a cadra cando estamos valida a entrada do usuario. Sabemos que imos para lles pedir polo menos unha vez. Así, un loop Do While pode algo coma isto. Temos un número enteiro n. E dentro do facer mentres loop, nós inmediatamente pedir ao usuario a un número enteiro. Se n é válido, entón imos levalos de novo e de novo e de novo ata que dar esa enteiro válido. Finalmente, xa que n é unha entrada válida, imos avance para o resto do noso programa. 

Entón, imos voltar á especificación e verificación que as condicións para unha entrada válida será. As alturas válidos van situarse entre 0 e 23, inclusive. cantos de modo non válidos van ser inferior a 0 ou máis que 23. Entón lembre de proxectar a súa condición con coidado, sabendo que a condición ao do loop while debe ser á vez n non é válido. Agora, iso non vai ser un expresión booleana simple e única. Nós imos ter que combinar dúas expresións diferentes para facer toda a nosa condición. 

Entón imos só ollar a unha táboa verdade eu teño xa lle deu a información de que estamos será xestionar dous Booleans. Entón aquí está unha táboa de verdade onde ter dous Booleans-- booleana 1 e 2. Polo tanto, temos a posibilidade de avaliar bool1 e bool2 ou bool1 ou bool2. E só será certo se ambos Booleans avaliar a realidade, mentres que as ou será certo, sempre que un de ambos Booleans valorada como certa. OK, entón bótalle un momento, deter este vídeo e dixerir esta táboa verdade. Eu estarei ben aquí esperando. Cando volver, ver se pode unir unha expresión booleana para a súa condición de n ser unha entrada válida. 

Polo tanto, agora que temos entrada do usuario válido, imos dalle falar como nos pode deseñar a metade da pirámide. Aquí neste editor de texto simple, Eu deseño dun aliñado á esquerda pirámide. Pero sabemos que necesitamos nosa pirámide para ser aliñado á dereita. Entón, como eu podería facelo? Ben, eu podería intentar empurrar todo para o lado por só poñer un pouco caracteres no medio. E, a continuación, para o próximo liña, eu vou poñer algúns personaxes para empurra-lo xunto, e further-- así por diante e así por forth-- ata que teña a pirámide aliñado á dereita. Entón temos unha pirámide align dereito, pero non parece tan grande cos puntos. Pero aínda queremos sosteñen que o espazo agradable. Entón eu vou literalmente inserir algúns espazos. 

No canto de tres puntos, eu vou poñer un, dous, tres espazos. Na segunda liña. Vou poñer un, dous espazos. E no penúltimo liña, só un espazo. E aquí eu teño unha pirámide aliñado á dereita. De facer o exemplo no texto editor, temos unha idea para o estándar que usaremos para deseñar a metade da pirámide. Para cada liña, o que fixemos é que escribir algúns espazos, e logo tecleada algúns hashes, e despois ingresaran a tecla Intro, que é a creación dunha nova liña. Polo tanto, agora que temos que imos un paso adiante e atopar un patrón. 

Entón eu vou dicir, para o interese deste exemplo, Estamos a tratar con unha altura de 8. A primeira liña terá dous hashes que segue sete espazos. Os second-- tres hash, seis espazos. Terceiros row-- catro hashes, cinco spaces-- etc. etc. ata chegar á liña nth. Así, pois, pídovos a liña nth, cantas hashes teremos e cantos espazos? Entón, cómpre a vostede a descubrir un fórmula para representar o número de hash e cantas son necesarias para espazos a liña nth cando ten algunha altura. 

Agora, cando está descubrir iso, ter coidado como está indexando. O que quero dicir con isto é que na vida cotiá de todos comezar a contar, xeralmente por 1. Pero, en CS50 e en ciencia da computación En xeral, son 0 indexado. Así, a primeira fila sería N de 0, en oposición a un. Teña coidado con iso cando está tentando descubrir o seu estándar. Entón agora imos volver a ser como imos chamar a nosa pirámide. Para cada liña, imos querer imprimir os espazos, imprimir os hashes, e, a continuación, imprimir unha nova liña. A información aquí é o palabra "para" todas as liñas. En C, que ten unha construción chamado un loop for, que está composto por un arranque, unha condición, unha actualización, eo corpo do lazo. 

Digamos que eu quería dicir, Ola mundo, 50 veces, os meus para circuito sería algo coma isto. I arrincar o meu completo a 0. A condición é que é menos que 50. E entón miña actualización é só incrementando I por un de cada vez. Tamén podemos utilizar para loops para repetir as cousas. Observe aquí como nós non ten codificado un número, senón posta a variable altura en canto sobre a condición. Entón o que eu estou facendo aquí é que estou a iteración sobre cada liña da pirámide. Podo facer algo para cada remar no interior do corpo da miña loop. 

O que estamos facendo no o corpo do loop? Ben, como xa dixemos, estamos imprimindo espazos e estamos imprimindo hashes e estamos imprimindo unha nova liña. Así, a miña externa para o lazo será coma este. Eu iterado sobre cada liña da pirámide, usando, Neste caso, a altura como a variable que almacena a altura da pirámide. Dentro do corpo daquel loop, eu son vai imprimir espazos repetido de impresión os hashes repetidamente e, a continuación, imprimir unha nova liña. 

Entón, agora, usando todos os conceptos que Eu xa falei sobre este walk-through, ten que ser capaz de levar o do usuario para entrada, validar as entradas, e despois sacar a media pirámide. 

O meu nome é Zamyla, e este é CS50. 