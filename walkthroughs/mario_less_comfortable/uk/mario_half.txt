ZAMYLA чан: Це я, Zamyla. Сьогодні в Маріо, ми збираємося бути малюнок половину піраміди для Маріо щоб піднятися вгору. Отже, давайте поговоримо про наше щоденник для цієї проблеми. Ми будемо хотіти запитувати і перевіряти користувач для правильного введення, як високо вони хочуть піраміди Маріо бути. А потім, ми будемо малювати його. Так що давайте почнемо із запитом і перевірки користувача для їх введення. 

Ми можемо використовувати з Функція CS50 Бібліотека отримати Int, що буде гарантувати, що користувач вводить ціле число. Будь-які позитивні числа, негативні цілі числа, число 0 все справедлива гра. В іншому випадку користувач буде запропоновано повторюйте, поки вони ввести допустимий ціле число. Тепер, хоча Get INT робить багато роботи для нас в забезпеченні того, Користувач дає нам ціле число, ми все ще повинні застосувати деякі додаткові обмеження на цей рахунок. Зрештою, ми не можемо мати Маріо сходження половина піраміда заввишки 12 негативною. 

На додаток до цього, Технічні проблеми каже, що ми можемо тільки Маріо дозволяють піднятися піраміда висот від 0 до 23. ОК, так що це означає, що нам потрібно безперервно запитувати користувача щоб дати нам дійсний номер і тільки продовжувати як тільки вони дали нам дійсну висоту. Як ми це робимо? 

Ну, безперервні процеси дають нам ідея loops-- робити щось повторно. Один цикл в C, як деякий час цикл, який буде безперервно виконувати тіло циклу до тих пір, дана умова обчислюється як істина. Як тільки ця умова оцінюється як помилкове, програма приступить до все, що приходить після цього. Таким чином, в той час як петлі один із способів гарантуючи, що ми постійно запитувати у користувача дійсного введення. І як тільки вони дають нам правильний вхід, ми будемо продовжувати до того, що буде далі. Ми знаємо, що ми будемо просити користувач для введення щонайменше, один раз. Так що тепер ми приходимо до сестри в той час як цикл, який є зробити під час циклу. 

Чи є в той час як петлі будуть виконуватися тіло циклу принаймні один раз. Таким чином, без перевірки стану, він буде виконуватися тіло циклу. А потім перевірте стан, щоб побачити чи потребує вона повторюватися. Це зручно, коли ми перевірки введення даних користувачем. Ми знаємо, що ми збираємося щоб запитати їх, принаймні один раз. Так робити, поки цикл може шукати щось на зразок цього. У нас є ціле п. І всередині справ в той час як петлі, ми відразу запитувати у користувача ціле. Якщо п недійсний, то ми будемо підказувати їм Бо не знову і знову і знову, поки вони дають нам, що дійсне число. Нарешті, коли п є допустимим вхід, ми будемо перейти до іншої частини нашої програми. 

Так що давайте повернемося до специфікації і перевірки які умови для дійсного входу буде. Допустимі висоти збираються перебувати в діапазоні від 0 до 23 включно. Так що недійсні висоти збираються бути менше 0 або більше 23. Так що пам'ятайте, щоб розробити ваш стан ретельно, знаючи, що умова для справ в той час як петлі має бути в той час як п є недійсним. Тепер це не буде простий одиночний логічне вираз. Ми будемо повинні об'єднати два різних вирази щоб все наше стан. 

Так що давайте просто подивимося на таблицю істинності я вже дав вам натяк, що ми матиме справу з двома Booleans. Так ось таблиця істинності, де я є два Booleans-- Boolean 1 і 2. Таким чином, у нас є можливість оцінити bool1 і bool2 або bool1 або bool2. І буде тільки справедливо, якщо обидва Booleans оцінити, правда, в той час як всі або буде вірно доти, як один з два Booleans оцінюється як істина. ОК, так що буде потрібно якийсь час, зробити паузу в цьому відео і переварити цю таблицю істинності. Я буду тут чекати. Коли ви повернетеся, см якщо ви можете шматочках логічне вираз для вашого умова п є неприпустимим вхід. 

Так що тепер у нас є дійсний для користувача введення, давайте йти вперед і говорити про те, як ми може зробити половину піраміди. Ось в цьому простому текстовому редакторі, Я намалював вирівнювання по лівому краю піраміди. Але ми знаємо, що нам потрібні наші Піраміда бути вирівняні по правому краю. Так як я можу це зробити? Ну, я міг би спробувати підштовхнути все на сторону шляхом просто покласти трохи характер між ними. А потім, на наступний лінії, я збираюся поставити ще кілька символів, щоб штовхати його вперед, і further-- так далі і так forth-- поки я не мати правильну піраміду вирівняний. Таким чином, у нас є вирівнюється по правому краю піраміди, але це не виглядає так чудово з точками. Але ми все ще хочемо підтримувати цей хороший інтервал. Так що я збираюся в буквальному сенсі слова вставити деякі прогалини. 

Замість трьох точок, я буду поклав один, два, три простору. На другому рядку. Я поставив один, два простору. А на передостанньому лінія, тільки один пробіл. А ось у мене є вирівнювання по правому краю піраміди. Від робити приклад в тексті редактор, у нас є ідея для шаблону що ми будемо використовувати, щоб зробити половину піраміди. Для кожного рядка, що ми зробили це ми вводимо деякі прогалини, а потім надрукував деякі хеші, а потім набирається клавіша Enter, яка створює нову лінію. Так що тепер у нас є, що, підемо один крок вперед і знайти шаблон. 

Так що я збираюся сказати, для Інтерес цього прикладу, ми маємо справу з висотою 8. Перший рядок буде мати два хеші, який слід сім просторів. У second-- три хеші, шість просторів. По-третє row-- чотири хеші, п'ять spaces-- так далі, і так далі поки ми не отримаємо до енної рядки. Отже, я прошу вас за NTH рядки, скільки хеші ми матимемо і скільки простору? Так що до вас, щоб з'ясувати формула для подання, скільки хеші і скільки простору необхідні для му рядку, коли у вас є якийсь висоти. 

Тепер, коли ви з'ясувати це, будьте обережні, як ви індексації. Те, що я маю на увазі, що в повсякденному житті всіх нас почати відлік, як правило, на 1. Але в CS50 і в інформатиці Загалом, ми 0 індексувати. Таким чином, перший рядок буде N 0, на відміну від 1. Будьте обережні в цьому, коли ви намагаючись з'ясувати вашу картину. Так що тепер давайте повернемося до того, як ми збираємося зробити нашу піраміду. Для кожного рядка, ми будемо хотіти друк простору, друк хеші, а потім роздрукувати новий рядок. натяк тут слово "для" кожного рядка. У C, ми маємо конструкцію називається цикл, яка складається з ініціалізація, умова, оновлення, і тіло циклу. 

Скажіть, що я хотів сказати, привіт світ, в 50 разів, мій цикл буде виглядати приблизно так. Я форматувати моє ціле число 0. Умовою є те, що я менше 50. І тоді моє оновлення просто збільшенням I на одиницю кожного разу. Ми також можемо використовувати для петель перебрати речі. Зверніть увагу на те, як тут ми не маємо жорстко закодовані номер, а помістив змінну висота замість того, щоб в стані. Так що я роблю тут я ітерація над кожного рядка піраміди. Я можу зробити щось для кожного гребти всередині тіла мого циклу. 

Що ми робимо всередині тіло циклу? Ну, як ми вже говорили, ми друку простору і ми хеші друку і ми друку новий рядок. Так що мій зовнішній цикл буде виглядати наступним чином. Я перебирати кожен рядок піраміди, використовуючи, У цьому випадку, висота в якості змінної який зберігає висота піраміди. Усередині тіла цього циклу, я збирається друкувати прогалини повторно, друк хеші повторно, а потім роздрукувати новий рядок. 

Так що тепер, використовуючи всі поняття, які Я говорив про це в прохідних, ви повинні бути в змозі підказати користувача для введення, перевірки того, що вхідний сигнал, а потім зробити половину піраміди. 

Мене звуть Zamyla, і це CS50. 