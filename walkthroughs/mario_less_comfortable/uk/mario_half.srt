1
00:00:00,000 --> 00:00:00,500

2
00:00:00,500 --> 00:00:02,500
ZAMYLA чан: Це я, Zamyla.

3
00:00:02,500 --> 00:00:06,910
Сьогодні в Маріо, ми збираємося бути
малюнок половину піраміди для Маріо

4
00:00:06,910 --> 00:00:08,290
щоб піднятися вгору.

5
00:00:08,290 --> 00:00:11,570
>> Отже, давайте поговоримо про наше
щоденник для цієї проблеми.

6
00:00:11,570 --> 00:00:13,610
Ми будемо хотіти
запитувати і перевіряти

7
00:00:13,610 --> 00:00:18,290
користувач для правильного введення, як
високо вони хочуть піраміди Маріо бути.

8
00:00:18,290 --> 00:00:20,090
А потім, ми будемо малювати його.

9
00:00:20,090 --> 00:00:24,870
Так що давайте почнемо із запитом і
перевірки користувача для їх введення.

10
00:00:24,870 --> 00:00:27,640
>> Ми можемо використовувати з
Функція CS50 Бібліотека

11
00:00:27,640 --> 00:00:31,160
отримати Int, що буде гарантувати, що
користувач вводить ціле число.

12
00:00:31,160 --> 00:00:35,730
Будь-які позитивні числа, негативні
цілі числа, число 0 все справедлива гра.

13
00:00:35,730 --> 00:00:41,670
В іншому випадку користувач буде запропоновано
повторюйте, поки вони ввести допустимий ціле число.

14
00:00:41,670 --> 00:00:44,210
Тепер, хоча Get INT робить
багато роботи для нас

15
00:00:44,210 --> 00:00:46,730
в забезпеченні того,
Користувач дає нам ціле число,

16
00:00:46,730 --> 00:00:50,760
ми все ще повинні застосувати деякі
додаткові обмеження на цей рахунок.

17
00:00:50,760 --> 00:00:56,420
Зрештою, ми не можемо мати Маріо сходження
половина піраміда заввишки 12 негативною.

18
00:00:56,420 --> 00:00:59,040
>> На додаток до цього,
Технічні проблеми

19
00:00:59,040 --> 00:01:02,490
каже, що ми можемо тільки
Маріо дозволяють піднятися

20
00:01:02,490 --> 00:01:06,940
піраміда висот від 0 до 23.

21
00:01:06,940 --> 00:01:11,120
ОК, так що це означає, що нам потрібно
безперервно запитувати користувача

22
00:01:11,120 --> 00:01:14,320
щоб дати нам дійсний
номер і тільки продовжувати

23
00:01:14,320 --> 00:01:17,120
як тільки вони дали нам дійсну висоту.

24
00:01:17,120 --> 00:01:18,720
Як ми це робимо?

25
00:01:18,720 --> 00:01:23,760
>> Ну, безперервні процеси дають нам
ідея loops-- робити щось

26
00:01:23,760 --> 00:01:24,720
повторно.

27
00:01:24,720 --> 00:01:28,220
Один цикл в C, як деякий час
цикл, який буде безперервно

28
00:01:28,220 --> 00:01:33,480
виконувати тіло циклу до тих пір,
дана умова обчислюється як істина.

29
00:01:33,480 --> 00:01:36,200
Як тільки ця умова
оцінюється як помилкове,

30
00:01:36,200 --> 00:01:39,770
програма приступить до
все, що приходить після цього.

31
00:01:39,770 --> 00:01:43,180
Таким чином, в той час як петлі один із способів
гарантуючи, що ми постійно

32
00:01:43,180 --> 00:01:45,320
запитувати у користувача дійсного введення.

33
00:01:45,320 --> 00:01:50,070
І як тільки вони дають нам правильний вхід,
ми будемо продовжувати до того, що буде далі.

34
00:01:50,070 --> 00:01:54,380
Ми знаємо, що ми будемо просити
користувач для введення щонайменше, один раз.

35
00:01:54,380 --> 00:01:59,200
Так що тепер ми приходимо до сестри
в той час як цикл, який є зробити під час циклу.

36
00:01:59,200 --> 00:02:02,650
>> Чи є в той час як петлі будуть виконуватися
тіло циклу принаймні один раз.

37
00:02:02,650 --> 00:02:06,150
Таким чином, без перевірки стану,
він буде виконуватися тіло циклу.

38
00:02:06,150 --> 00:02:09,750
А потім перевірте стан, щоб побачити
чи потребує вона повторюватися.

39
00:02:09,750 --> 00:02:13,080
Це зручно, коли
ми перевірки введення даних користувачем.

40
00:02:13,080 --> 00:02:15,830
Ми знаємо, що ми збираємося
щоб запитати їх, принаймні один раз.

41
00:02:15,830 --> 00:02:18,780
Так робити, поки цикл може
шукати щось на зразок цього.

42
00:02:18,780 --> 00:02:20,090
У нас є ціле п.

43
00:02:20,090 --> 00:02:22,760
І всередині справ
в той час як петлі, ми відразу

44
00:02:22,760 --> 00:02:24,750
запитувати у користувача ціле.

45
00:02:24,750 --> 00:02:29,740
Якщо п недійсний, то ми будемо підказувати їм
Бо не знову і знову і знову, поки вони

46
00:02:29,740 --> 00:02:31,820
дають нам, що дійсне число.

47
00:02:31,820 --> 00:02:37,440
Нарешті, коли п є допустимим вхід, ми будемо
перейти до іншої частини нашої програми.

48
00:02:37,440 --> 00:02:41,830
>> Так що давайте повернемося до специфікації і перевірки
які умови для дійсного входу

49
00:02:41,830 --> 00:02:43,670
буде.

50
00:02:43,670 --> 00:02:48,090
Допустимі висоти збираються
перебувати в діапазоні від 0 до 23 включно.

51
00:02:48,090 --> 00:02:53,350
Так що недійсні висоти збираються
бути менше 0 або більше 23.

52
00:02:53,350 --> 00:02:56,420
Так що пам'ятайте, щоб розробити
ваш стан ретельно,

53
00:02:56,420 --> 00:02:58,660
знаючи, що умова
для справ в той час як петлі

54
00:02:58,660 --> 00:03:01,470
має бути в той час як п є недійсним.

55
00:03:01,470 --> 00:03:05,080
Тепер це не буде
простий одиночний логічне вираз.

56
00:03:05,080 --> 00:03:07,630
Ми будемо повинні об'єднати
два різних вирази

57
00:03:07,630 --> 00:03:09,900
щоб все наше стан.

58
00:03:09,900 --> 00:03:13,290
>> Так що давайте просто подивимося на таблицю істинності я
вже дав вам натяк, що ми

59
00:03:13,290 --> 00:03:15,200
матиме справу з двома Booleans.

60
00:03:15,200 --> 00:03:19,620
Так ось таблиця істинності, де я
є два Booleans-- Boolean 1 і 2.

61
00:03:19,620 --> 00:03:27,050
Таким чином, у нас є можливість оцінити
bool1 і bool2 або bool1 або bool2.

62
00:03:27,050 --> 00:03:31,980
І буде тільки справедливо, якщо обидва
Booleans оцінити, правда, в той час як всі

63
00:03:31,980 --> 00:03:37,280
або буде вірно доти, як один з
два Booleans оцінюється як істина.

64
00:03:37,280 --> 00:03:41,450
ОК, так що буде потрібно якийсь час, зробити паузу в цьому
відео і переварити цю таблицю істинності.

65
00:03:41,450 --> 00:03:42,930
Я буду тут чекати.

66
00:03:42,930 --> 00:03:45,760
Коли ви повернетеся, см
якщо ви можете шматочках

67
00:03:45,760 --> 00:03:51,910
логічне вираз для вашого
умова п є неприпустимим вхід.

68
00:03:51,910 --> 00:03:54,420
>> Так що тепер у нас є
дійсний для користувача введення, давайте

69
00:03:54,420 --> 00:03:58,710
йти вперед і говорити про те, як ми
може зробити половину піраміди.

70
00:03:58,710 --> 00:04:03,410
Ось в цьому простому текстовому редакторі,
Я намалював вирівнювання по лівому краю піраміди.

71
00:04:03,410 --> 00:04:07,050
Але ми знаємо, що нам потрібні наші
Піраміда бути вирівняні по правому краю.

72
00:04:07,050 --> 00:04:08,650
Так як я можу це зробити?

73
00:04:08,650 --> 00:04:11,440
Ну, я міг би спробувати підштовхнути
все на сторону

74
00:04:11,440 --> 00:04:14,880
шляхом просто покласти трохи
характер між ними.

75
00:04:14,880 --> 00:04:16,779
А потім, на наступний
лінії, я збираюся поставити

76
00:04:16,779 --> 00:04:20,970
ще кілька символів, щоб штовхати його вперед,
і further-- так далі і так forth--

77
00:04:20,970 --> 00:04:23,360
поки я не мати правильну піраміду вирівняний.

78
00:04:23,360 --> 00:04:27,780
Таким чином, у нас є вирівнюється по правому краю піраміди, але
це не виглядає так чудово з точками.

79
00:04:27,780 --> 00:04:30,680
Але ми все ще хочемо
підтримувати цей хороший інтервал.

80
00:04:30,680 --> 00:04:35,260
Так що я збираюся в буквальному сенсі слова
вставити деякі прогалини.

81
00:04:35,260 --> 00:04:39,420
>> Замість трьох точок, я буду
поклав один, два, три простору.

82
00:04:39,420 --> 00:04:40,370
На другому рядку.

83
00:04:40,370 --> 00:04:42,640
Я поставив один, два простору.

84
00:04:42,640 --> 00:04:45,370
А на передостанньому
лінія, тільки один пробіл.

85
00:04:45,370 --> 00:04:48,290
А ось у мене є вирівнювання по правому краю піраміди.

86
00:04:48,290 --> 00:04:52,170
Від робити приклад в тексті
редактор, у нас є ідея для шаблону

87
00:04:52,170 --> 00:04:54,590
що ми будемо використовувати, щоб зробити половину піраміди.

88
00:04:54,590 --> 00:04:58,080
Для кожного рядка, що ми зробили
це ми вводимо деякі прогалини,

89
00:04:58,080 --> 00:05:00,170
а потім надрукував деякі
хеші, а потім набирається

90
00:05:00,170 --> 00:05:03,020
клавіша Enter, яка
створює нову лінію.

91
00:05:03,020 --> 00:05:07,770
Так що тепер у нас є, що, підемо
один крок вперед і знайти шаблон.

92
00:05:07,770 --> 00:05:10,170
>> Так що я збираюся сказати, для
Інтерес цього прикладу,

93
00:05:10,170 --> 00:05:12,480
ми маємо справу з висотою 8.

94
00:05:12,480 --> 00:05:17,100
Перший рядок буде мати два
хеші, який слід сім просторів.

95
00:05:17,100 --> 00:05:20,020
У second-- три хеші, шість просторів.

96
00:05:20,020 --> 00:05:24,260
По-третє row-- чотири хеші, п'ять
spaces-- так далі, і так далі

97
00:05:24,260 --> 00:05:26,350
поки ми не отримаємо до енної рядки.

98
00:05:26,350 --> 00:05:31,540
Отже, я прошу вас за NTH рядки,
скільки хеші ми матимемо

99
00:05:31,540 --> 00:05:33,120
і скільки простору?

100
00:05:33,120 --> 00:05:37,000
Так що до вас, щоб з'ясувати
формула для подання, скільки хеші

101
00:05:37,000 --> 00:05:42,020
і скільки простору необхідні для
му рядку, коли у вас є якийсь висоти.

102
00:05:42,020 --> 00:05:46,060
>> Тепер, коли ви з'ясувати це,
будьте обережні, як ви індексації.

103
00:05:46,060 --> 00:05:49,170
Те, що я маю на увазі, що
в повсякденному житті всіх нас

104
00:05:49,170 --> 00:05:51,540
почати відлік, як правило, на 1.

105
00:05:51,540 --> 00:05:55,950
Але в CS50 і в інформатиці
Загалом, ми 0 індексувати.

106
00:05:55,950 --> 00:06:00,620
Таким чином, перший рядок буде
N 0, на відміну від 1.

107
00:06:00,620 --> 00:06:04,550
Будьте обережні в цьому, коли ви
намагаючись з'ясувати вашу картину.

108
00:06:04,550 --> 00:06:07,570
Так що тепер давайте повернемося до того, як
ми збираємося зробити нашу піраміду.

109
00:06:07,570 --> 00:06:12,300
Для кожного рядка, ми будемо хотіти
друк простору, друк хеші,

110
00:06:12,300 --> 00:06:14,050
а потім роздрукувати новий рядок.

111
00:06:14,050 --> 00:06:19,160
натяк тут
слово "для" кожного рядка.

112
00:06:19,160 --> 00:06:21,470
У C, ми маємо конструкцію
називається цикл,

113
00:06:21,470 --> 00:06:25,250
яка складається з
ініціалізація, умова, оновлення,

114
00:06:25,250 --> 00:06:26,790
і тіло циклу.

115
00:06:26,790 --> 00:06:31,360
>> Скажіть, що я хотів сказати, привіт
світ, в 50 разів, мій цикл

116
00:06:31,360 --> 00:06:32,880
буде виглядати приблизно так.

117
00:06:32,880 --> 00:06:35,480
Я форматувати моє ціле число 0.

118
00:06:35,480 --> 00:06:38,230
Умовою є те, що я менше 50.

119
00:06:38,230 --> 00:06:42,350
І тоді моє оновлення просто
збільшенням I на одиницю кожного разу.

120
00:06:42,350 --> 00:06:45,140
Ми також можемо використовувати для петель
перебрати речі.

121
00:06:45,140 --> 00:06:47,820
Зверніть увагу на те, як тут ми не маємо
жорстко закодовані номер,

122
00:06:47,820 --> 00:06:51,820
а помістив змінну
висота замість того, щоб в стані.

123
00:06:51,820 --> 00:06:56,420
Так що я роблю тут я ітерація
над кожного рядка піраміди.

124
00:06:56,420 --> 00:07:00,160
Я можу зробити щось для кожного
гребти всередині тіла мого циклу.

125
00:07:00,160 --> 00:07:02,350
>> Що ми робимо всередині
тіло циклу?

126
00:07:02,350 --> 00:07:07,120
Ну, як ми вже говорили, ми друку
простору і ми хеші друку

127
00:07:07,120 --> 00:07:09,480
і ми друку новий рядок.

128
00:07:09,480 --> 00:07:11,950
Так що мій зовнішній цикл
буде виглядати наступним чином.

129
00:07:11,950 --> 00:07:15,070
Я перебирати кожен рядок
піраміди, використовуючи,

130
00:07:15,070 --> 00:07:18,890
У цьому випадку, висота в якості змінної
який зберігає висота піраміди.

131
00:07:18,890 --> 00:07:22,870
Усередині тіла цього циклу, я
збирається друкувати прогалини повторно, друк

132
00:07:22,870 --> 00:07:26,730
хеші повторно,
а потім роздрукувати новий рядок.

133
00:07:26,730 --> 00:07:31,010
>> Так що тепер, використовуючи всі поняття, які
Я говорив про це в прохідних,

134
00:07:31,010 --> 00:07:35,210
ви повинні бути в змозі підказати
користувача для введення, перевірки того, що вхідний сигнал,

135
00:07:35,210 --> 00:07:37,370
а потім зробити половину піраміди.

136
00:07:37,370 --> 00:07:41,510
>> Мене звуть Zamyla, і це CS50.

137
00:07:41,510 --> 00:07:43,167

