ZAMYLA CHAN: Tai man, Zamyla. Šiandien Mario, mes ketiname būti piešimo pusę piramidę Mario įkopti. Taigi pakalbėkime apie mūsų to-do-ųjų šią problemą. Mes ketiname norite kad tai paskatins ir patvirtinti už galiojantį įėjimo, kaip vartotojas aukštos jie nori Mario piramidės būti. Ir tada, mes ketiname jį piešti. Taigi pradėkime su paskatino ir už jų indėlį vartotoją patvirtinti. 

Mes galime pasinaudoti ir CS50 biblioteka funkcija gauti int, kad bus užtikrinti, kad vartotojas įveda sveikasis skaičius. Bet teigiami sveikieji skaičiai, neigiamas sveikieji skaičiai, skaičius 0 yra graži žaidimas. Priešingu atveju, vartotojas bus raginami bandykite dar kartą, kol jie įvesties galiojantį sveikasis skaičius. Dabar nors Gauti INT daro iš už mus daug darbo siekiant užtikrinti, kad vartotojas suteikia mums sveikasis skaičius, mes vis dar reikia taikyti kai papildomi apribojimai, kad. Galų gale, mes negalime turėti Mario laipioti pusė piramidės aukščio neigiamas 12. 

Be to, to, problema specifikacija sako, kad tik mes galime leidžia Mario lipti aukščių piramidės tarp 0 ir 23. Gerai, kad tai reiškia, kad turime nuolat raginimas vartotojui mums galiojanti skaičius ir tik toliau kai jie davė mums galiojantį aukštį. Kaip mes tai darome? 

Na, tęstinis procesas duoti mums iš loops-- darai kažką idėja pakartotinius. Vienas kilpa C kaip laiko kilpa, kad nuolat vykdyti kilpos kūną tol, kol duotas būklė įvertina tiesa. Kaip tik ši sąlyga įvertina false, programa bus pradėti kokia ateina po to. Taigi, nors kilpos vienas iš būdų užtikrinti, kad mes nuolat greitai galiojančiam įvesties vartotoją. Ir kai jie suteikia mums galiojantį įvestį, mes pereiti į ką kalbama toliau. Mes žinome, kad mes ketiname paklausti už įvesties vartotojo bent vieną kartą. Taigi dabar mes einame iki sesuo while cikle, kuris yra do while cikle. 

Daryti, o kilpos vykdys organas linijos bent vieną kartą. Taigi be tikrinant sąlygą, ši grupė vykdys kilpos kūną. Ir tada patikrinkite būklę pamatyti ar jis turi kartojasi. Tai praverčia, kai mes patvirtinti vartotojo įvestį. Mes žinome, kad mes ketiname juos užduoti bent vieną kartą. Taigi do while cikle galėtų atrodo kažkas panašaus į tai. Mes turime sveikasis skaičius n. Ir viduje darbų o kilpos, mes iš karto paskatinti už sveikasis skaičius vartotoją. Jei n yra neteisingas, tada mes greitai juos vėl ir vėl ir vėl, kol jie mums, kad galiojantį sveikasis skaičius. Galiausiai, kai n yra galiojanti įėjimas, mes pereiti prie mūsų programą poilsio. 

Taigi grįžkime prie spec ir patikrinimas kas už galiojantį įvesties sąlygos bus. Galiojantys aukščiai ketinate būti tarp 0 ir 23, imtinai. Taigi negaliojančių aukščiai ketinate negali būti mažesnis kaip 0 arba daugiau kaip 23. Taigi nepamirškite dizainas Jūsų būklė atidžiai, žinant, kad su sąlyga, už tai, o kilpos turėtų būti, o n yra negaliojantis. Dabar tai nesiruošia būti paprastas vieną Bulio logikos išraiška. Mes ketiname turėti derinti du skirtingi išsireiškimai kad visą mūsų būklę. 

Taigi tegul tiesiog pažvelgti į tiesos lentelę aš jau davė jums užuominą, kad mes bus susiję su dviem loginės reikšmės. Taigi čia tiesa stalo, kur aš turime du Booleans-- Būlio 1 ir 2. Taigi, mes turime galimybę įvertinti bool1 ir bool2 arba bool1 arba bool2. Ir bus tik tiesa, jei abu Loginę įvertinti, tiesa, kadangi visos arba bus teisinga tol, kol viena iš dvi loginės reikšmės įvertina tiesa. Gerai, kad šiek tiek laiko, pristabdyti šio vaizdo ir suvirškinti šią tiesą lentelę. Aš būsiu čia laukia. Kai grįšite, pamatyti jei galite suvesti Būlio išraiška jūsų sąlyga n invalidu įvestis. 

Taigi, dabar, kad mes turime galioja naudotojo įvesties, tegul eiti į priekį ir kalbėti apie tai, kaip mes gali atkreipti pusę piramidę. Čia šią paprastą teksto redaktorių, Aš atkreipė kairįjį suderinta piramidę. Bet mes žinome, kad reikia mūsų piramidė turi būti teisinga suderinti. Taigi, kaip galėčiau tai padaryti? Na, aš gali bandyti stumti viskas į šoną tiesiog išleisti šiek tiek charakteris tarp. Ir tada, ir kitą linija, aš ruošiuosi įdėti kai daugiau simbolių stumti jį kartu, ir further-- taip toliau ir taip forth-- kol turiu teisę suderinti piramidę. Taigi mes turime tinkamą lygiavimą piramidę, tačiau jis neatrodo toks didelis, su taškais. Bet mes vis dar norime išlaikyti tą gražią tarpai. Taigi, aš ruošiuosi pažodžiui įterpti keletą erdvių. 

Vietoj trijų taškų, aš įdėti vieną, du, tris erdves. Antroje eilutėje. Aš įdėti vieną, du erdves. Ir priešpaskutinę linija, tik vienas tarpas. Ir čia turiu teisę suderinti piramidę. Nuo daro pavyzdį tekste redaktorius, mes turime už modelio idėja kad mes naudosime atkreipti pusę piramidę. Už kiekvieną iš eilės, ką mes padarėme yra mes tipo kai erdves, ir tada atspausdinti kai maišos, tada atspausdinti klavišą Enter, kuri yra sukurti naują eilutę. Taigi, dabar, kad mes turime, kad eikime dar vieną žingsnį ir rasti modelį. 

Taigi, aš ruošiuosi pasakyti, nes interesai Šiame pavyzdyje, mes susiduriame su 8 aukštį. Pirma eilutė teks du maišos, išvardytos toliau septynias erdves. Į second-- trys maišas, šeši erdvėse. Trečiosios row-- keturi maišas, penki spaces-- taip toliau ir taip toliau kol mes gauti Neribotos eilės. Taigi, prašau jus Neribotos eilės kiek maišos mes ketiname turėti ir kiek erdves? Taigi, tai iki jums išsiaiškinti formulė atstovauti Kiek maišų ir kiek erdvės reikia Neribotos eilutėje, kai jūs turite tam tikrą aukštį. 

Dabar, kai jūs suprasti tai atlikti, būti atsargūs, kaip jūs indeksavimo. Ką reiškia tai, kad kasdieniame gyvenime mums visiems pradėti skaičiuoti, paprastai 1 d. Bet CS50 ir kompiuterių mokslo apskritai, esame 0 indeksuojami. Taigi pirmas eilėje būtų n 0, o ne 1. Būkite atsargūs tai, kai esate bando išsiaiškinti savo modelį. Taigi dabar grįžkime į tai, kaip mes ketiname padaryti mūsų piramidę. Už kiekvieną iš eilės, mes ketiname norite spausdinti erdves, spausdinti maišų, ir tada spausdinti naują eilutę. Užuomina čia yra Žodis "už" kiekvienoje eilutėje. C, turime konstruktą vadinamas for ciklas, kurią sudaro iniciacijos, sąlyga, atnaujinimas, ir kilpos kūno. 

Pasakyti, kad aš norėjau pasakyti, labas pasaulis, 50 kartų, mano for ciklas atrodytų kažką panašaus į tai. Aš inicijuoti mano sveikasis skaičius 0. Sąlyga, kad aš yra mažesnis nei 50. Ir tada mano atnaujinimas yra tik incrementing I viena kiekvieną kartą. Mes taip pat gali naudoti kilpomis į pakartoti užkliuvę. Atkreipkite dėmesį, čia, kaip mes turime ne sunku koduojami skaičių, o dedamas kintamąjį aukštis, o ne į su sąlyga,. Taigi, ką aš darau čia aš Iteracja per kiekvieną piramidės eilės. Galiu padaryti kažką kiekvienam eilutę viduje mano kilpa kūno. 

Ką mes darome vidaus iš ciklo kūnas? Na, kaip jau sakė, mes spausdinti erdves ir mes spausdinti maišų ir mes spausdinant nauja linija. Taigi, mano išorinis for ciklas atrodys taip. Aš pakartoti per kiekvieną eilutę piramidės, naudojant, šiuo atveju, aukštis yra kintamasis, , kuris saugo piramidės aukštį. Viduje tos kilpos kūną, aš ketinate spausdinti erdvių pakartotinai spausdinti pakartotinai šios maišos, ir tada spausdinti naują eilutę. 

Todėl dabar, naudojant visus iš koncepcijos, kad Aš kalbėjau apie šiame praeinamiesiems, jums turėtų būti suteikta galimybė paskatinti vartotojas įvesties, patvirtinti, kad įvesties, ir tada atkreipti pusę piramidę. 

Mano vardas Zamyla, ir tai yra CS50. 