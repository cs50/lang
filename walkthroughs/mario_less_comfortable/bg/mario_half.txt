ZAMYLA ЧАН: Това е мен, Zamyla. Днес в Mario, отиваме да бъде изготвяне на половината пирамида за Марио да се изкачи нагоре. Така че нека да говорим за нашата да-направя за този проблем. Ние ще искаме да подтикне и валидира потребителя за валиден вход как висока искат пирамида на Марио да бъде. И след това, ние ще го направи. Така че нека да започнем с което предизвика и валидиране на потребителя за тяхното въвеждане. 

Ние може да се възползва от Функция CS50 библиотека получите INT, че ще се гарантира, че потребителят въвежда цяло число. Всички положителни числа, отрицателен числа, брой 0 са честна игра. В противен случай, потребителят ще бъдете подканени да повторен опит, докато не въведете валиден число. Сега, въпреки че GET инт прави много работа за нас да гарантира, че потребителското ни дава цяло число, ние все още трябва да се прилагат някои допълнителни ограничения върху това. В края на краищата, ние не можем да имаме Марио катерене половина пирамида на височина отрицателна 12. 

В допълнение към това, спецификация проблем казва, че можем само да позволи на Марио да се изкачи пирамида на височина между 0 и 23. ОК, така че това означава, че ние се нуждаем от непрекъснато да напомни на потребителя да ни даде валиден номер и само да продължи след като сте ни предоставили валиден височина. Как да го направим? 

Е, непрекъснати процеси ни дават идеята за loops-- прави нещо многократно. Един цикъл в C, като същевременно линия, която ще непрекъснато изпълнение на тялото на цикъла, докато даденото състояние се оценява на истинската. Веднага след като това условие стойност лъжа, програмата ще се пристъпи към каквото и идва след това. Така че, докато примки са един от начините за гарантира, че ние непрекъснато напомни на потребителя за валиден вход. И след като те ни дават валиден вход, ние ще се пристъпи към каквото и идва следващата. Ние знаем, че ние ще попитам на потребителя за въвеждане на най-малко веднъж. Така че сега ние стигаме до една сестра на докато контур, който е направи, докато контур. 

Смятате докато примки ще изпълни тялото на цикъла най-малко веднъж. Така че, без проверка на състоянието, то ще се изпълни тялото на цикъла. И след това да провери състоянието, за да видите дали тя трябва да се повтори. Това е по-удобен, когато ние сме за утвърждаване приноса на потребителите. Ние знаем, че отиваме да ги попитам поне веднъж. Така че да не се прави, докато контур мощ изглежда по следния начин. Имаме цяло число п. И вътре на Do докато контур, ние веднага подкани ползвателя на цяло число. Ако N е невалиден, тогава ние ще ги подтикне отново и отново, докато да ни даде това, валидно число. Накрая, след като п е валиден вход, ние ще пристъпи към останалата част от нашата програма. 

Така че нека да се върнем към спец и проверката какви са условията за валиден вход ще бъде. Валидните височини ще да бъде между 0 и 23, включително. Така невалидни височини ще да бъде по-малко от 0 или повече от 23. Така че не забравяйте да се изработи Вашето състояние, знаейки, че условието за направите, докато контур трябва да бъде, докато п е невалиден. Сега това няма да бъде прост единичен Булев израз. Ние ще трябва да се комбинират две различни изражения да се направи цялата ни състояние. 

Така че нека просто погледнете на една маса истината съм Вече ви даде намек, че ние сме Ще се занимават с два булеви. Така че тук е една маса истина, където I има две Booleans-- Булева 1 и 2. Така че ние имаме възможност да се оцени bool1 и bool2 или bool1 или bool2. И ще бъде само вярно, ако и двете Booleans оценяват да е вярно, че всички или ще бъде вярно, докато един от на два булеви оценява да е вярно. ОК, така че отделете време, спрете тази видео и извари тази истина маса. Ще бъда точно тук, в очакване. Когато се върнеш, виж ако може да се сглоби булева израз за вашия състояние на п е невалиден вход. 

Така че сега ние имаме валиден потребителски вход, нека давай напред и да се говори за това как ние може да се направи за половин пирамидата. Тук, в този прост текстов редактор, Аз бях привлече подравняват вляво на пирамида. Но ние знаем, че имаме нужда от нашата пирамида, за да бъде дясно подравнен. Е, как може да го направя? Е, аз може да се опита да прокара всичко, за да отстрани само с удар от малък характер по средата. И тогава, за следващия линия, аз отивам да се сложи някои повече знаци, за да го бутат напред, и further-- така нататък и така forth-- докато имам дясно подравнен пирамидата. Така че ние имаме право подравняване пирамида, но тя не изглежда толкова голяма, с точките. Но ние все още искате да поддържа, че хубаво разстояние. Така че аз ще буквално вмъкнете някои пространства. 

Вместо три точки, ще сложи една, две, три помещения. На втория ред. Ще сложа една, две пространства. И в предпоследния линия, само едно пространство. И тук имам право подравнен пирамида. От това примера в текста редактор, ние имаме представа за модела че ние ще използваме, за да привлече половин пирамидата. За всеки ред, това, което направихме е ние написали някои пространства, и след това написа някои хешове, и след това напечатани Въведете ключ, който е създаването на нов ред. Така че сега ние имаме, че, нека да отидем една крачка напред и да се намери модел. 

Така че аз ще кажа, че за интерес на този пример, имаме работа с височина 8. Първият ред ще има две хешове, че следва седем пространства. На second-- три хешове, шест пространства. Трети row-- четири хешове, пет spaces-- т.н. и т.н. докато стигнем до тото ред. И така, аз ви питам за енти ред, колко хешове отиваме да има и колко пространства? Така че това е до вас, за да разбера по- формула за представяне на колко хешове и колко места са необходими за енти ред, когато имате някаква височина. 

Сега, когато сте фигуриращ това навън, бъдете внимателни как се индексира. Какво искам да кажа от това е, че в ежедневието на всички нас започнем да броим, обикновено от 1. Но в CS50 и по компютърни науки Като цяло, ние сме 0 индексиран. Така първият ред би п 0, за разлика от едно. Бъдете внимателни на това, когато сте Опитвам се да разбера вашия модел. Така че сега нека се върнем към начина, ние ще се направи нашата пирамида. За всеки ред, ние ще искаме да отпечатване на пространствата, отпечатване на хешове, и след това да отпечатате на нов ред. Намекът тук е Думата "за" всеки ред. В C, ние имаме конструкт нарича за линия, който се състои от инициализация, условие, актуализация, и тялото на цикъла. 

Да речем, което исках да кажа, здравей свят, 50 пъти, ми за цикъл ще изглежда по следния начин. Аз се инициализира ми число 0. Условието е, че аз е по-малко от 50. И тогава актуализация ми е просто Увеличаването I от един всеки път. Ние също може да се използва за електрически вериги за обхождане на нещата. Забележете, тук как ние не трябва Трудно кодиран номер, а по-скоро поставя на променливата височина вместо в състояние. Така че това, което правя тук е, че съм итерации над всеки ред на пирамидата. Мога да направя нещо за всеки ред вътре в тялото на моя цикъл. 

Какво правим вътре тялото на цикъла? Е, както вече казахме, ние сме отпечатване пространства и ние сме отпечатване хешове и ние сме отпечатването на нов ред. Така че моята външна за контур ще изглежда така. Аз обхождане всеки ред на пирамидата, като се използва, В този случай, като променливата височина която съхранява височината на пирамидата. Вътре в тялото на тази линия, аз съм ще отпечата пространства многократно, печат хешовете многократно и след това да отпечатате на нов ред. 

Така че сега, с помощта на всички от концепциите, които Аз съм говорил за това в разходка из, би трябвало да можете да промпт потребител за вход, утвърждава, че вход, и след това се привлече половин пирамидата. 

Моето име е Zamyla, и това е CS50. 