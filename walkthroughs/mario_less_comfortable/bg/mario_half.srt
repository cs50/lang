1
00:00:00,000 --> 00:00:00,500

2
00:00:00,500 --> 00:00:02,500
ZAMYLA ЧАН: Това е мен, Zamyla.

3
00:00:02,500 --> 00:00:06,910
Днес в Mario, отиваме да бъде
изготвяне на половината пирамида за Марио

4
00:00:06,910 --> 00:00:08,290
да се изкачи нагоре.

5
00:00:08,290 --> 00:00:11,570
>> Така че нека да говорим за нашата
да-направя за този проблем.

6
00:00:11,570 --> 00:00:13,610
Ние ще искаме
да подтикне и валидира

7
00:00:13,610 --> 00:00:18,290
потребителя за валиден вход как
висока искат пирамида на Марио да бъде.

8
00:00:18,290 --> 00:00:20,090
И след това, ние ще го направи.

9
00:00:20,090 --> 00:00:24,870
Така че нека да започнем с което предизвика и
валидиране на потребителя за тяхното въвеждане.

10
00:00:24,870 --> 00:00:27,640
>> Ние може да се възползва от
Функция CS50 библиотека

11
00:00:27,640 --> 00:00:31,160
получите INT, че ще се гарантира, че
потребителят въвежда цяло число.

12
00:00:31,160 --> 00:00:35,730
Всички положителни числа, отрицателен
числа, брой 0 са честна игра.

13
00:00:35,730 --> 00:00:41,670
В противен случай, потребителят ще бъдете подканени да
повторен опит, докато не въведете валиден число.

14
00:00:41,670 --> 00:00:44,210
Сега, въпреки че GET инт прави
много работа за нас

15
00:00:44,210 --> 00:00:46,730
да гарантира, че
потребителското ни дава цяло число,

16
00:00:46,730 --> 00:00:50,760
ние все още трябва да се прилагат някои
допълнителни ограничения върху това.

17
00:00:50,760 --> 00:00:56,420
В края на краищата, ние не можем да имаме Марио катерене
половина пирамида на височина отрицателна 12.

18
00:00:56,420 --> 00:00:59,040
>> В допълнение към това,
спецификация проблем

19
00:00:59,040 --> 00:01:02,490
казва, че можем само да
позволи на Марио да се изкачи

20
00:01:02,490 --> 00:01:06,940
пирамида на височина между 0 и 23.

21
00:01:06,940 --> 00:01:11,120
ОК, така че това означава, че ние се нуждаем от
непрекъснато да напомни на потребителя

22
00:01:11,120 --> 00:01:14,320
да ни даде валиден
номер и само да продължи

23
00:01:14,320 --> 00:01:17,120
след като сте ни предоставили валиден височина.

24
00:01:17,120 --> 00:01:18,720
Как да го направим?

25
00:01:18,720 --> 00:01:23,760
>> Е, непрекъснати процеси ни дават
идеята за loops-- прави нещо

26
00:01:23,760 --> 00:01:24,720
многократно.

27
00:01:24,720 --> 00:01:28,220
Един цикъл в C, като същевременно
линия, която ще непрекъснато

28
00:01:28,220 --> 00:01:33,480
изпълнение на тялото на цикъла, докато
даденото състояние се оценява на истинската.

29
00:01:33,480 --> 00:01:36,200
Веднага след като това условие
стойност лъжа,

30
00:01:36,200 --> 00:01:39,770
програмата ще се пристъпи към
каквото и идва след това.

31
00:01:39,770 --> 00:01:43,180
Така че, докато примки са един от начините за
гарантира, че ние непрекъснато

32
00:01:43,180 --> 00:01:45,320
напомни на потребителя за валиден вход.

33
00:01:45,320 --> 00:01:50,070
И след като те ни дават валиден вход,
ние ще се пристъпи към каквото и идва следващата.

34
00:01:50,070 --> 00:01:54,380
Ние знаем, че ние ще попитам
на потребителя за въвеждане на най-малко веднъж.

35
00:01:54,380 --> 00:01:59,200
Така че сега ние стигаме до една сестра на
докато контур, който е направи, докато контур.

36
00:01:59,200 --> 00:02:02,650
>> Смятате докато примки ще изпълни
тялото на цикъла най-малко веднъж.

37
00:02:02,650 --> 00:02:06,150
Така че, без проверка на състоянието,
то ще се изпълни тялото на цикъла.

38
00:02:06,150 --> 00:02:09,750
И след това да провери състоянието, за да видите
дали тя трябва да се повтори.

39
00:02:09,750 --> 00:02:13,080
Това е по-удобен, когато
ние сме за утвърждаване приноса на потребителите.

40
00:02:13,080 --> 00:02:15,830
Ние знаем, че отиваме
да ги попитам поне веднъж.

41
00:02:15,830 --> 00:02:18,780
Така че да не се прави, докато контур мощ
изглежда по следния начин.

42
00:02:18,780 --> 00:02:20,090
Имаме цяло число п.

43
00:02:20,090 --> 00:02:22,760
И вътре на Do
докато контур, ние веднага

44
00:02:22,760 --> 00:02:24,750
подкани ползвателя на цяло число.

45
00:02:24,750 --> 00:02:29,740
Ако N е невалиден, тогава ние ще ги подтикне
отново и отново, докато

46
00:02:29,740 --> 00:02:31,820
да ни даде това, валидно число.

47
00:02:31,820 --> 00:02:37,440
Накрая, след като п е валиден вход, ние ще
пристъпи към останалата част от нашата програма.

48
00:02:37,440 --> 00:02:41,830
>> Така че нека да се върнем към спец и проверката
какви са условията за валиден вход

49
00:02:41,830 --> 00:02:43,670
ще бъде.

50
00:02:43,670 --> 00:02:48,090
Валидните височини ще
да бъде между 0 и 23, включително.

51
00:02:48,090 --> 00:02:53,350
Така невалидни височини ще
да бъде по-малко от 0 или повече от 23.

52
00:02:53,350 --> 00:02:56,420
Така че не забравяйте да се изработи
Вашето състояние,

53
00:02:56,420 --> 00:02:58,660
знаейки, че условието
за направите, докато контур

54
00:02:58,660 --> 00:03:01,470
трябва да бъде, докато п е невалиден.

55
00:03:01,470 --> 00:03:05,080
Сега това няма да бъде
прост единичен Булев израз.

56
00:03:05,080 --> 00:03:07,630
Ние ще трябва да се комбинират
две различни изражения

57
00:03:07,630 --> 00:03:09,900
да се направи цялата ни състояние.

58
00:03:09,900 --> 00:03:13,290
>> Така че нека просто погледнете на една маса истината съм
Вече ви даде намек, че ние сме

59
00:03:13,290 --> 00:03:15,200
Ще се занимават с два булеви.

60
00:03:15,200 --> 00:03:19,620
Така че тук е една маса истина, където I
има две Booleans-- Булева 1 и 2.

61
00:03:19,620 --> 00:03:27,050
Така че ние имаме възможност да се оцени
bool1 и bool2 или bool1 или bool2.

62
00:03:27,050 --> 00:03:31,980
И ще бъде само вярно, ако и двете
Booleans оценяват да е вярно, че всички

63
00:03:31,980 --> 00:03:37,280
или ще бъде вярно, докато един от
на два булеви оценява да е вярно.

64
00:03:37,280 --> 00:03:41,450
ОК, така че отделете време, спрете тази
видео и извари тази истина маса.

65
00:03:41,450 --> 00:03:42,930
Ще бъда точно тук, в очакване.

66
00:03:42,930 --> 00:03:45,760
Когато се върнеш, виж
ако може да се сглоби

67
00:03:45,760 --> 00:03:51,910
булева израз за вашия
състояние на п е невалиден вход.

68
00:03:51,910 --> 00:03:54,420
>> Така че сега ние имаме
валиден потребителски вход, нека

69
00:03:54,420 --> 00:03:58,710
давай напред и да се говори за това как ние
може да се направи за половин пирамидата.

70
00:03:58,710 --> 00:04:03,410
Тук, в този прост текстов редактор,
Аз бях привлече подравняват вляво на пирамида.

71
00:04:03,410 --> 00:04:07,050
Но ние знаем, че имаме нужда от нашата
пирамида, за да бъде дясно подравнен.

72
00:04:07,050 --> 00:04:08,650
Е, как може да го направя?

73
00:04:08,650 --> 00:04:11,440
Е, аз може да се опита да прокара
всичко, за да отстрани

74
00:04:11,440 --> 00:04:14,880
само с удар от малък
характер по средата.

75
00:04:14,880 --> 00:04:16,779
И тогава, за следващия
линия, аз отивам да се сложи

76
00:04:16,779 --> 00:04:20,970
някои повече знаци, за да го бутат напред,
и further-- така нататък и така forth--

77
00:04:20,970 --> 00:04:23,360
докато имам дясно подравнен пирамидата.

78
00:04:23,360 --> 00:04:27,780
Така че ние имаме право подравняване пирамида, но
тя не изглежда толкова голяма, с точките.

79
00:04:27,780 --> 00:04:30,680
Но ние все още искате да
поддържа, че хубаво разстояние.

80
00:04:30,680 --> 00:04:35,260
Така че аз ще буквално
вмъкнете някои пространства.

81
00:04:35,260 --> 00:04:39,420
>> Вместо три точки, ще
сложи една, две, три помещения.

82
00:04:39,420 --> 00:04:40,370
На втория ред.

83
00:04:40,370 --> 00:04:42,640
Ще сложа една, две пространства.

84
00:04:42,640 --> 00:04:45,370
И в предпоследния
линия, само едно пространство.

85
00:04:45,370 --> 00:04:48,290
И тук имам право подравнен пирамида.

86
00:04:48,290 --> 00:04:52,170
От това примера в текста
редактор, ние имаме представа за модела

87
00:04:52,170 --> 00:04:54,590
че ние ще използваме, за да привлече половин пирамидата.

88
00:04:54,590 --> 00:04:58,080
За всеки ред, това, което направихме
е ние написали някои пространства,

89
00:04:58,080 --> 00:05:00,170
и след това написа някои
хешове, и след това напечатани

90
00:05:00,170 --> 00:05:03,020
Въведете ключ, който
е създаването на нов ред.

91
00:05:03,020 --> 00:05:07,770
Така че сега ние имаме, че, нека да отидем
една крачка напред и да се намери модел.

92
00:05:07,770 --> 00:05:10,170
>> Така че аз ще кажа, че за
интерес на този пример,

93
00:05:10,170 --> 00:05:12,480
имаме работа с височина 8.

94
00:05:12,480 --> 00:05:17,100
Първият ред ще има две
хешове, че следва седем пространства.

95
00:05:17,100 --> 00:05:20,020
На second-- три хешове, шест пространства.

96
00:05:20,020 --> 00:05:24,260
Трети row-- четири хешове, пет
spaces-- т.н. и т.н.

97
00:05:24,260 --> 00:05:26,350
докато стигнем до тото ред.

98
00:05:26,350 --> 00:05:31,540
И така, аз ви питам за енти ред,
колко хешове отиваме да има

99
00:05:31,540 --> 00:05:33,120
и колко пространства?

100
00:05:33,120 --> 00:05:37,000
Така че това е до вас, за да разбера по-
формула за представяне на колко хешове

101
00:05:37,000 --> 00:05:42,020
и колко места са необходими за
енти ред, когато имате някаква височина.

102
00:05:42,020 --> 00:05:46,060
>> Сега, когато сте фигуриращ това навън,
бъдете внимателни как се индексира.

103
00:05:46,060 --> 00:05:49,170
Какво искам да кажа от това е, че
в ежедневието на всички нас

104
00:05:49,170 --> 00:05:51,540
започнем да броим, обикновено от 1.

105
00:05:51,540 --> 00:05:55,950
Но в CS50 и по компютърни науки
Като цяло, ние сме 0 индексиран.

106
00:05:55,950 --> 00:06:00,620
Така първият ред би
п 0, за разлика от едно.

107
00:06:00,620 --> 00:06:04,550
Бъдете внимателни на това, когато сте
Опитвам се да разбера вашия модел.

108
00:06:04,550 --> 00:06:07,570
Така че сега нека се върнем към начина,
ние ще се направи нашата пирамида.

109
00:06:07,570 --> 00:06:12,300
За всеки ред, ние ще искаме да
отпечатване на пространствата, отпечатване на хешове,

110
00:06:12,300 --> 00:06:14,050
и след това да отпечатате на нов ред.

111
00:06:14,050 --> 00:06:19,160
Намекът тук е
Думата "за" всеки ред.

112
00:06:19,160 --> 00:06:21,470
В C, ние имаме конструкт
нарича за линия,

113
00:06:21,470 --> 00:06:25,250
който се състои от
инициализация, условие, актуализация,

114
00:06:25,250 --> 00:06:26,790
и тялото на цикъла.

115
00:06:26,790 --> 00:06:31,360
>> Да речем, което исках да кажа, здравей
свят, 50 пъти, ми за цикъл

116
00:06:31,360 --> 00:06:32,880
ще изглежда по следния начин.

117
00:06:32,880 --> 00:06:35,480
Аз се инициализира ми число 0.

118
00:06:35,480 --> 00:06:38,230
Условието е, че аз е по-малко от 50.

119
00:06:38,230 --> 00:06:42,350
И тогава актуализация ми е просто
Увеличаването I от един всеки път.

120
00:06:42,350 --> 00:06:45,140
Ние също може да се използва за електрически вериги
за обхождане на нещата.

121
00:06:45,140 --> 00:06:47,820
Забележете, тук как ние не трябва
Трудно кодиран номер,

122
00:06:47,820 --> 00:06:51,820
а по-скоро поставя на променливата
височина вместо в състояние.

123
00:06:51,820 --> 00:06:56,420
Така че това, което правя тук е, че съм итерации
над всеки ред на пирамидата.

124
00:06:56,420 --> 00:07:00,160
Мога да направя нещо за всеки
ред вътре в тялото на моя цикъл.

125
00:07:00,160 --> 00:07:02,350
>> Какво правим вътре
тялото на цикъла?

126
00:07:02,350 --> 00:07:07,120
Е, както вече казахме, ние сме отпечатване
пространства и ние сме отпечатване хешове

127
00:07:07,120 --> 00:07:09,480
и ние сме отпечатването на нов ред.

128
00:07:09,480 --> 00:07:11,950
Така че моята външна за контур
ще изглежда така.

129
00:07:11,950 --> 00:07:15,070
Аз обхождане всеки ред
на пирамидата, като се използва,

130
00:07:15,070 --> 00:07:18,890
В този случай, като променливата височина
която съхранява височината на пирамидата.

131
00:07:18,890 --> 00:07:22,870
Вътре в тялото на тази линия, аз съм
ще отпечата пространства многократно, печат

132
00:07:22,870 --> 00:07:26,730
хешовете многократно
и след това да отпечатате на нов ред.

133
00:07:26,730 --> 00:07:31,010
>> Така че сега, с помощта на всички от концепциите, които
Аз съм говорил за това в разходка из,

134
00:07:31,010 --> 00:07:35,210
би трябвало да можете да промпт
потребител за вход, утвърждава, че вход,

135
00:07:35,210 --> 00:07:37,370
и след това се привлече половин пирамидата.

136
00:07:37,370 --> 00:07:41,510
>> Моето име е Zamyla, и това е CS50.

137
00:07:41,510 --> 00:07:43,167

