ZAMYLA CHAN: És un jo, Zamyla. Avui Mario, estarem dibuixar la meitat de la piràmide de Mario per pujar. Així que anem a parlar de la nostra coses per fer per aquest problema. Anem a voler per impulsar i validar l'usuari per a una entrada vàlida de com alta que volen piràmide de Mario sigui. I després, anem a dibuixar. Així que començarem amb indicacions i validar l'usuari per a la seva entrada. 

Podem fer ús de la Biblioteca de funcions CS50 int aconseguir que assegurarà que l'usuari introdueix un nombre sencer. Qualsevol sencers positius, negatius nombres enters, nombre 0 són presa fàcil. Altrament, l'usuari se li demanarà que fins que torni a intentar introduir un nombre enter vàlid. Ara bé, tot i que get int fa una gran part de la feina per nosaltres per garantir que el usuari ens dóna un nombre enter, encara hem d'aplicar una mica restriccions addicionals al respecte. Després de tot, no podem tenir Mario escalada una mitjana piràmide d'altura negativa de 12. 

A més d'això, la especificació problema diu que només podem permet a Mario a pujar una piràmide d'altures entre 0 i 23. D'acord, pel que significa que necessitem per impulsar contínuament l'usuari per donar-nos una vàlida nombre i només continuarà una vegada que ens han donat una alçada vàlida. Com ho fem? 

Doncs bé, els processos continus ens donen la idea de fer alguna cosa loops-- repetitivament. Un bucle en C com un temps bucle que contínuament es executar el cos del bucle, sempre que la condició donada s'avalua com a veritable. Tan aviat com aquesta condició s'avalua com a falsa, el programa procedirà a el que ve després d'això. Així, mentre que els bucles són una forma de assegurar que contínuament sol·licitar a l'usuari una entrada vàlida. I una vegada que ens donen una entrada vàlida, procedirem al que vingui després. Sabem que demanarem entrada a l'usuari com a mínim una vegada. Així que ara arribem a una germana de la while, que és el do while. 

Bucle do executaran el cos del bucle almenys una vegada. Així que sense la comprovació de l'estat, s'executarà el cos del bucle. I a continuació, comprovar l'estat per veure si ha de repetir-se. Això és molt útil quan estem validar l'entrada de l'usuari. Sabem que anem per demanar-los que almenys una vegada. Pel que un bucle Do While podria una cosa semblant a això. Tenim un nombre enter n. I dins de la DO while, immediatament sol·licitar a l'usuari un nombre sencer. Si n no és vàlid, llavors anem a impulsar-los una i altra vegada i una altra fins que es donar-nos aquesta sencer vàlid. Finalment, una vegada que n és una entrada vàlida, anem a segueixi amb la resta del nostre programa. 

Així que anem a tornar a l'especificació i verificació quines són les condicions per a una entrada vàlida serà. Les altures vàlids van a de ser entre 0 i 23, inclusivament. Així d'ara no vàlids van a ser inferior a 0 o més de 23. Així que recorda al disseny el seu estat de salut atentament, sabent que la condició per al do while ha de ser mentre que n no és vàlid. Ara bé, això no serà una expressió booleana única i senzilla. Haurem de combinar dues expressions diferents perquè tota la nostra condició. 

Així que anem a veure en una taula de veritat que he ja que donat l'indici que estem va a estar tractant amb dos booleans. Així que aquí hi ha una taula de veritat on tenen dos Booleans-- booleà 1 i 2. Així que tenim l'opció d'avaluar Bool1 i Bool2 o Bool1 o Bool2. I només serà veritable si tots dos Booleans com a resultat true, mentre que tots o serà cert sempre que un els dos booleans s'avalua com a veritable. OK, així que prengui un moment, fer una pausa en aquest vídeo i pair aquesta taula de veritat. Vaig a ser aquí esperant. Quan tornis, consulteu si es pot armar una expressió booleana per a la seva condició que n és una entrada vàlida. 

Així que ara que tenim d'entrada d'usuari vàlid, anem a seguir endavant i parlar sobre com podria dibuixar la piràmide meitat. Aquí, en aquest editor de text simple, He dibuixat una piràmide alineat a l'esquerra. No obstant això, sabem que necessitem la nostra piràmide per ser alineat a la dreta. Llavors, com podria jo fer això? Bé, jo podria tractar d'empènyer tot a un costat amb només col·locar una mica caràcter en el medi. I després, per a la següent línia, vaig a posar alguns caràcters més per empènyer al llarg, i further-- així successivament i així forth-- fins que tingui la piràmide alineat a la dreta. Així que tenim una piràmide Alinea a la dreta, però no es veu tan gran amb els punts. Però encara volem mantenir aquesta bona separació. Així que vaig a, literalment, inserir alguns espais. 

En lloc de tres punts, em quedo posar un, dos, tres espais. A la segona línia. Vaig a posar una, dos espais. I en la penúltima línia, un sol espai. I aquí tinc una piràmide alineat a la dreta. De fer l'exemple en el text editor, tenim una idea per al patró que utilitzarem per dibuixar la piràmide meitat. Per a cada fila, el que vam fer està escrivim alguns espais, i després es passen alguns hashes, i després es passen la tecla Retorn, el qual és la creació d'una nova línia. Així que ara que hem de, anirem un pas més enllà i trobar un patró. 

Així que vaig a dir, per al interès d'aquest exemple, estem tractant amb una alçada de 8. La primera fila va a tenir dos hashes que segueix set espais. Els tres second-- hashes, sis espais. En tercer lloc row-- quatre, cinc hashes spaces-- així successivament i així successivament fins arribar a la fila n. Així doncs, us demano la fila n, quants hashes tindrem i el nombre d'espais? Així que depèn de vostè per trobar una fórmula per representar el nombre de hashes i quants espais són necessaris per l'enèsima fila quan es té una certa alçada. 

Ara, quan vostè està calculant tot això, tenir cura de com s'està indexant. El que vull dir amb això és que en tots nosaltres la vida quotidiana començar a comptar, en general per 1. Però en CS50 i en ciències de la computació en general, som 0 indexada. Així que la primera fila seria n de 0 a diferència d'1. Aneu amb compte d'això quan estàs tractant d'esbrinar el seu patró. Així que ara anem a tornar a la forma anem a cridar la nostra piràmide. Per a cada fila, anem a voler imprimir els espais, imprimir els valors hash, i després imprimir una nova línia. El suggeriment aquí és la paraula "perquè" cada fila. En C, tenim una construcció diu un bucle for, que es compon d'una inicialització, un estat, una actualització, i el cos del bucle. 

Dir el que volia dir, hola món, 50 vegades, els meus de bucle seria alguna cosa com això. Em inicialitzar el meu número sencer de 0. La condició és que I és menys de 50. I llavors la meva actualització és només Em incrementant en un cada vegada. També podem utilitzar els bucles per repetir les coses. Cal notar aquí la forma en què no tenim codificació fixa un nombre, sinó que més aviat es col·loca la variable d'altura en lloc de la condició. Llavors, què estic fent aquí és que estic iterant sobre cada fila de la piràmide. Puc fer alguna cosa per a cada remar a l'interior del cos de la meva bucle. 

Què estem fent a l'interior el cos del bucle? Bé, com ja vam dir, estem imprimint espais i nosaltres estem imprimint hashes i nosaltres estem imprimint una nova línia. Així que el meu cicle for exterior tindrà aquest aspecte. Em iterar sobre cada fila de la piràmide, utilitzant, en aquest cas, l'alçada com la variable que emmagatzema l'altura de la piràmide. A l'interior del cos d'aquest bucle, estic va a imprimir espais en repetides ocasions, la impressió els hashes en diverses ocasions, i després imprimir una nova línia. 

Així que ara, l'ús de tots els conceptes que He parlat en aquest recorregut, vostè ha de poder indicar al usuari per a l'entrada, validar aquesta entrada, i després dibuixar la piràmide meitat. 

El meu nom és Zamyla, i això és CS50. 