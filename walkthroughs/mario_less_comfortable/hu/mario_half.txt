ZAMYLA Chan: Ez egy nekem, Zamyla. Ma Mario, mi lesz rajz a fele piramis Mario felmászni. Tehát beszéljünk a to-do által erre a problémára. Megyünk akar azonnali és érvényesítse A felhasználó egy érvényes bemeneti hogyan magas akarnak Mario piramis lenni. Aztán megyünk rajzolni. Szóval térjünk kezdődött megkérdezése és érvényesítése a felhasználó számára a bemenet. 

Tudjuk kihasználni a CS50 Könyvtár funkció kap int, amely biztosítja, hogy a A felhasználó ezt egész. Bármilyen pozitív egész szám, negatív egészek, 0 szám minden tisztességes játék. Ellenkező esetben a felhasználó a program kérni fogja újra, amíg nem adja meg az érvényes egész. Most ugyan get int csinál sok a munka számunkra annak biztosításában, hogy a felhasználói ad nekünk egy egész, mi kell még alkalmazni néhány további korlátozásokat, hogy. Elvégre nem lehet Mario hegymászó fél piramis magassága negatív 12. 

Ezen felül, a probléma specifikáció azt mondja, hogy csak akkor tudjuk hogy Mario mászni piramis magasságát 0 és 23 között. OK, így ez azt jelenti, hogy meg kell folyamatosan figyelmezteti a felhasználót hogy nekünk egy érvényes szám, és csak tovább egyszer már adott nekünk egy érvényes magasságát. Hogyan csináljuk? 

Nos, folyamatos eljárások nekünk az ötlet, hogy valami loops-- ismétlődően. Egy hurok C egy darabig hurok, hogy folyamatosan végre a test a hurok, amíg az adott betegség értéke igaz. Amint ez a feltétel értéke hamis, A program folytassa bármi is jön utána. Tehát míg a hurok egyik módja biztosítva, hogy folyamatosan kéri a felhasználó érvényes bemenet. És ha egyszer nekünk egy érvényes bemenet, akkor folytassa bármi is jön a következő. Tudjuk, hogy mi fog kérni A felhasználó a bemeneti legalább egyszer. Tehát most jön a testvére a while ciklus, amely a do while ciklus. 

Tedd while végrehajtja a a hurok teste legalább egyszer. Tehát anélkül, állapotának ellenőrzésére, akkor végrehajtja a hurok teste. Majd ellenőrizze az állapotát, hogy hogy mire kell ismételni önmagát. Ez hasznos lehet, ha mi érvényesítése felhasználói. Tudjuk, hogy megyünk kérni őket, legalább egyszer. Tehát a do while ciklus talán valahogy így néz ki. Van egy n egész. És azon belül a do while ciklus, azonnal kérnek a felhasználótól egy egész szám. Ha n érvénytelen, akkor mi készteti újra és újra és újra, amíg nem nekünk, hogy érvényes egész. Végül, ha n érvényes bemenet választja, akkor folytassa a többi programunk. 

Akkor menjünk vissza a spec és ellenőrzés milyenek a körülmények egy érvényes bemeneti lesz. Az érvényes magasságok fognak lehet 0 és 23 között, a befogadó. Így érvénytelen magasságban fognak lehet kevesebb, mint 0, vagy több mint 23. Úgy emlékszem, hogy tervezzen Ön állapotát gondosan, tudva, hogy a feltétel a do while ciklus legyen, míg n érvénytelen. Most ez nem lesz egyszerû logikai kifejezés. Mi lesz, hogy összekapcsolják Két különböző kifejezéseket hogy az egész állapotban. 

Tehát lássuk csak nézd meg a igazságtáblázatot voltam Már megadtam a célzást, hogy mi vagyunk fog foglalkozni két Logikai. Tehát itt egy igazság táblázatot, ahol Van két Booleans-- Boole az 1. és 2.. Tehát megvan a lehetőség, hogy értékelje bool1 és bool2 vagy bool1 vagy bool2. És csak akkor lesz igaz, ha mindkét Logikai adattípus vizsgálata igaz, mivel minden vagy igaz lesz, amíg az egyik A két Logikai értéke igaz. OK, így egy pillanatra, szüneteltetéséhez video és megemészteni ezt az igazságot asztalra. Hamarosan itt vár. Ha visszajössz, lásd ha lehet összerakni a logikai kifejezés a feltétele n egy érvénytelen bemenet. 

Tehát most, hogy van érvényes felhasználói bemenet, nézzük megy előre, és beszélni, hogyan esetleg felhívni a fele piramis. Itt ebben az egyszerű szövegszerkesztő, Már húzott balra igazított piramis. De tudjuk, hogy szükségünk van a piramis kell jobbra igazítva. Tehát hogyan lehet ezt megtenni? Nos, talán próbálja nyomni mindent az oldalról módon putting egy kicsit karakter között. És akkor, a következő vonal, megyek, hogy néhány karakter tolja végig, és further-- így tovább és így forth-- amíg én a jobbra igazítva piramis. Tehát van egy jobbra igazított piramis, de nem úgy néz ki, így nagy a pontok. De még mindig szeretnénk azt állítják, hogy szép távolság. Így fogok szó beszúrni egy szóközt. 

Ahelyett, hogy három pont, én tesz egy, kettő, három terek. A második sorban. Teszek egy, kettő terek. És az utolsó előtti vonal, csak egy helyet. És itt van egy jobbra igazított piramis. Csinál a példa a szövegben szerkesztő, van egy ötletem a minta hogy fel fogjuk használni, hogy felhívja a fele piramis. Minden sorban, hogy mit tettünk A mi be is terek, majd gépelt néhány hash, majd gépelt az Enter billentyűt, amely teremt egy új sort. Tehát most, hogy van, hogy menjünk egy lépéssel tovább, és talál egy mintát. 

Így fogok mondani, az ennek érdekében például dolgunk magassága 8. Az első sorban megy, hogy két hash, hogy a következő hét szünetet. A second-- három hash hat terek. Harmadik row-- négy hash öt spaces-- így tovább és így tovább amíg eljutunk a NTH sor. Tehát, kérem, az NTH sor, hány hash megyünk, hogy és hány mezőt? Tehát ez rajtad múlik, hogy kitaláljuk, képletet mutatják, hogy hány hash és hány terek van szükség Az n-edik sorig, ha van egy kis magasságot. 

Most, amikor kitalálni ezt ki, legyen óvatos, hogyan éppen feltérképezett. Mit értek ez, hogy a mindennapi életben mindannyian elkezdi mérni, általában 1. De CS50 és számítástechnika Általában 0 indexelt. Tehát az első sorban lenne n 0, szemben az 1. Legyen óvatos az e amikor megpróbálja kitalálni a mintát. Tehát most menjünk vissza, hogy fogunk felhívni a piramis. Minden sorban, megyünk akar nyomtassa ki a terek, nyomtassa ki a hash majd nyomtasson egy új sort. A célzás itt a szó "a" minden sorban. A C-ben van egy konstrukciót hívják a hurok, amely áll egy inicializálás, a feltétel, egy frissítést, és a test a hurok. 

Mondjuk én akartam mondani, helló világ, 50-szer, a hurok valahogy így néz ki ez. Azt inicializálni én egész 0-ra. A feltétel az, hogy I kisebb, mint 50. Aztán a frissítés csak megnő én egy minden alkalommal. Mi is használjuk a hurok iterációkhoz át a dolgokat. Figyelje meg, hogyan mi nem nehéz kódolni egy számot, hanem helyezte a változó magasság helyett a feltételt. Tehát mit csinálok itt én ismételve mint minden sorban a piramis. Tudok tenni valamit az egyes sorban a testben az én hurok. 

Mit csinálunk belül a test a hurok? Nos, mint már mondtuk, nyomtatáshoz terek és mi nyomtatás hash és mi nyomtat egy új sort. Tehát a külső hurok így fog kinézni. Azt végighaladni minden sorban A piramis segítségével, Ebben az esetben a magasságban, mint a változó amely tárolja a magassága a piramis. Testében, hogy hurok vagyok nyomdába kerülés terek többször, nyomtatás A hash többször, majd nyomtasson egy új sort. 

Tehát most, felhasználva a fogalmak Már beszéltem ebben séta-át, képesnek kell lennie arra, hogy jelezzen a felhasználó bemenet, megerősíti, hogy a bemenet, majd felhívni a fele piramis. 

A nevem Zamyla, és ez CS50. 