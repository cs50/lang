ZAMYLA CHAN: Het is een me, Zamyla. Vandaag in Mario, we gaan worden het tekenen van de halve piramide voor Mario om omhoog te klimmen. Dus laten we praten over ons te doen voor dit probleem. We gaan willen te vragen en te valideren de gebruiker een geldige invoer hoe hoog ze willen piramide Mario's te zijn. En dan gaan we om het te tekenen. Dus laten we beginnen met te vragen en valideren van de gebruiker voor hun inbreng. 

We kunnen gebruik maken van de te maken CS50 Bibliotheek Functie krijg int die ervoor zullen zorgen dat de gebruiker voert een integer. Elke positieve gehele getallen, negatieve integers, nummer 0 zijn allemaal eerlijk spel. Anders wordt de gebruiker gevraagd opnieuw te proberen totdat ze het invoeren van een geldige integer. Nu hoewel get int doet veel van het werk voor ons ervoor te zorgen dat de gebruiker geeft ons een integer, we moeten nog een paar passen extra beperkingen op geven. Immers, we kunnen niet hebben Mario klimmen een half piramide van hoogte negatieve 12. 

Trouwens, de probleem specificatie zegt dat we alleen kunnen laat Mario te beklimmen een piramide van hoogten tussen 0 en 23. OK, dus dat betekent dat we nodig hebben continu prompt de gebruiker om ons een geldig geven nummer en alleen verder zodra ze ons een geldige hoogte hebt gegeven. Hoe doen we dat? 

Nou, continue processen geven ons het idee van het doen van iets loops-- herhaaldelijk. Een lus in C als een tijdje lus die continu voeren het lichaam van de lus zolang de gegeven conditie true. Zodra deze voorwaarde onwaar, het programma zal overgaan tot wat komt daarna. Dus terwijl loops zijn een manier van ervoor te zorgen dat we voortdurend vraagt ​​de gebruiker om een ​​geldige ingang. En zodra ze geven ons een geldige invoer, zullen we overgaan tot wat daarna komt. We weten dat we gaan om te vragen de gebruiker om invoer ten minste eenmaal. Dus nu komen we tot een zuster van de while lus, dat is de do while lus. 

Doe terwijl loops zal uitvoeren van de orgaan van de lus ten minste eenmaal. Dus zonder controle van de staat, zal het lichaam van de lus uit te voeren. En controleer vervolgens de voorwaarde om te zien of het moet zich herhalen. Dit is handig wanneer we valideren van input van de gebruiker. We weten dat we gaan om minstens eenmaal vragen. Dus een do while lus zou ongeveer zo uitzien. We hebben een integer n. En de binnenkant van de do while lus, zijn we onmiddellijk vraagt ​​de gebruiker om een ​​integer. Als n ongeldig is, dan zullen we ze prompt opnieuw en opnieuw en opnieuw totdat zij geef ons die geldig zijn integer. Tot slot, zodra n een geldige invoer, zullen we overgaan tot de rest van ons programma. 

Dus laten we teruggaan naar de spec en check wat de voorwaarden voor een geldige invoer wordt. De geldige hoogtes gaan tussen 0 en 23 liggen. Dus ongeldige hoogtes gaan minder dan 0 en niet meer dan 23. Dus vergeet niet om te ontwerpen uw conditie zorgvuldig, wetende dat de toestand voor de doe while lus zou moeten zijn terwijl n ongeldig is. Nu, dit is niet van plan te zijn een eenvoudige enkele Booleaanse expressie. We zullen moeten combineren twee verschillende uitdrukkingen om ons hele toestand te maken. 

Dus laten we kijken naar een waarheid tafel ik heb u al de hint dat we gezien zal te maken hebben met twee Booleans. Dus hier is een waarheid tafel waar ik twee Booleans-- Boolean 1 en 2. Dus we hebben de mogelijkheid om te evalueren bool1 en bool2 of bool1 of bool2. En uitsluitend indien beide Booleans evalueren op true, terwijl alle of zal gelden zolang een van de twee Booleans true. OK, dus neem een ​​moment pauzeren deze video en verteren deze waarheid tafel. Ik kom hier te wachten staan. Als je terug komt, ziet als je kunt stuk samen een Booleaanse uitdrukking voor uw voorwaarde n een ongeldige invoer. 

Dus nu hebben we geldige input van de gebruiker, laten we ga je gang en praten over hoe we misschien de helft piramide te trekken. Hier in dit eenvoudige tekstverwerker, Ik heb een links uitgelijnd piramide getekend. Maar we weten dat we hebben onze piramide recht om te worden uitgelijnd. Dus hoe kan ik dit doen? Nou, ik zou kunnen proberen te duwen alles aan de kant door zomaar een beetje karakter ertussen. En vervolgens voor de volgende lijn, ik ga om te zetten wat meer tekens te duwen langs, en further-- zo voort en zo forth-- totdat Ik heb het recht uitgelijnd piramide. Dus hebben we een recht align piramide, maar het ziet er niet zo geweldig met de puntjes. Maar we willen nog steeds beweren dat mooie afstand. Dus ik ga letterlijk Steek sommige ruimtes. 

In plaats van drie punten, zal ik zet een, twee, drie ruimten. Op de tweede lijn. Ik zal er één, twee ruimtes te zetten. En op de voorlaatste lijn, slechts één ruimte. En hier heb ik een rechts uitgelijnd piramide. Van het doen van het voorbeeld in de tekst editor, hebben wij een idee voor het patroon dat we gebruiken om de halve piramide te trekken. Voor elke rij, wat we deden is dat we een aantal typen ruimten, en dan typte sommige hashes, en dan typte de Enter-toets, die is het creëren van een nieuwe regel. Dus nu hebben we dat, laten we gaan een stap verder en vind een patroon. 

Dus ik ga zeggen, voor de belang van dit voorbeeld, we te maken hebben met een hoogte van 8. De eerste rij zal twee hebben hashes dat zeven ruimtes volgt. De second-- drie hashes, zes ruimtes. Derde row-- vier hashes, vijf spaces-- zo verder en zo voort totdat we bij de NTH rij. Zo dan, vraag ik u voor de zoveelste rij, hoeveel hashes gaan we hebben en hoeveel ruimte? Dus het is aan jou om erachter te komen een formule te vertegenwoordigen hoeveel hashes en hoeveel ruimte nodig voor de NTH rij als je enige hoogte. 

Nu wanneer u uitzoeken dit uit, Wees voorzichtig hoe je indexeren. Wat ik bedoel is dat in het dagelijks leven van ons allemaal beginnen te tellen, meestal door 1. Maar in CS50 en in de informatica in het algemeen zijn we 0 geïndexeerd. Dus de eerste rij zou zijn n 0 of 1 tegenover. Wees voorzichtig met dit wanneer u bent proberen te achterhalen van uw patroon. Dus laten we nu teruggaan naar hoe we gaan onze piramide te trekken. Voor elke rij, gaan we willen afdrukken van de ruimten, de hashes te drukken, en druk vervolgens een nieuwe lijn. De hint is hier de woord "voor" iedere rij. In C, we hebben een construct riep een lus, die bestaat uit een initialisatie, een aandoening, een update, en het lichaam van de lus. 

Zeggen dat ik wilde zeggen, hello wereld, 50 keer, mijn lus zou er ongeveer zo uitzien. Ik initialiseren mijn integer naar 0. Voorwaarde is dat I kleiner is dan 50. En dan is mijn update gewoon het verhogen van I met één toe telkens. We kunnen ook gebruik maken van loops te herhalen over de dingen. Merk hier hoe we hebben niet hard gecodeerd een getal, maar de variabele geplaatst hoogte in plaats daarvan in de conditie. Dus wat ik hier doe is dat ik ben itereren over elke rij van de piramide. Ik kan iets voor elkaar doen rij in het lichaam van mijn lus. 

Wat doen wij binnen het lichaam van de lus? Nou, zoals we al zeiden, we afdrukt ruimten en we printen hashes en we zijn het afdrukken van een nieuwe regel. Dus mijn buitenste lus zal er zo uitzien. Ik itereren over elke rij van de piramide, gebruik, in casu hoogte als de variabele dat slaat de hoogte van de piramide. In het lichaam van deze loop, ben ik gaat ruimtes herhaaldelijk af te drukken, print de hashes herhaaldelijk en druk vervolgens een nieuwe lijn. 

Dus nu, met behulp van alle van de concepten die Ik heb gesproken over deze walk-through, je moet in staat zijn om de prompt gebruiker om invoer, te valideren die ingang, en dan trekken de helft piramide. 

Mijn naam is Zamyla, en dit is CS50. 