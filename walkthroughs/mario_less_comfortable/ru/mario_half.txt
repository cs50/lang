ZAMYLA чан: Это я, Zamyla. Сегодня в Марио, мы собираемся быть рисунок половину пирамиды для Марио чтобы подняться вверх. Итак, давайте поговорим о нашем ежедневник для этой проблемы. Мы будем хотеть запрашивать и проверять пользователь для правильного ввода, как высоко они хотят пирамиды Марио быть. А потом, мы будем рисовать его. Так что давайте начнем с запросом и проверки пользователя для их ввода. 

Мы можем использовать из Функция CS50 Библиотека получить Int, что будет гарантировать, что пользователь вводит целое число. Любые положительные числа, отрицательные целые числа, число 0 все справедливая игра. В противном случае пользователь будет предложено повторяйте, пока они ввести допустимое целое число. Теперь, хотя Get INT делает много работы для нас в обеспечении того, Пользователь дает нам целое число, мы все еще должны применить некоторые дополнительные ограничения на этот счет. В конце концов, мы не можем иметь Марио восхождение половина пирамида высотой 12 отрицательной. 

В дополнение к этому, Технические проблемы говорит, что мы можем только Марио позволяют подняться пирамида высот от 0 до 23. ОК, так что это означает, что нам нужно непрерывно запрашивать пользователя чтобы дать нам действительный номер и только продолжать как только они дали нам действительную высоту. Как мы это делаем? 

Ну, непрерывные процессы дают нам идея loops-- делать что-то повторно. Один цикл в C, как некоторое время цикл, который будет непрерывно выполнять тело цикла до тех пор, данное условие вычисляется как истина. Как только это условие оценивается как ложное, программа приступит к все, что приходит после этого. Таким образом, в то время как петли один из способов гарантируя, что мы постоянно запрашивать у пользователя действительного ввода. И как только они дают нам правильный вход, мы будем продолжать к тому, что будет дальше. Мы знаем, что мы будем просить пользователь для ввода по меньшей мере, один раз. Так что теперь мы приходим к сестре в то время как цикл, который является сделать во время цикла. 

Есть ли в то время как петли будут выполняться тело цикла по крайней мере один раз. Таким образом, без проверки состояния, он будет выполняться тело цикла. А затем проверьте состояние, чтобы увидеть нуждается ли она повторяться. Это удобно, когда мы проверки ввода данных пользователем. Мы знаем, что мы собираемся чтобы спросить их, по крайней мере один раз. Так делать, пока цикл может искать что-то вроде этого. У нас есть целое п. И внутри дел в то время как петли, мы сразу запрашивать у пользователя целое. Если п недействителен, то мы будем подсказывать им не снова и снова и снова, пока они дают нам, что действительное число. Наконец, когда п является допустимым вход, мы будем перейти к остальной части нашей программы. 

Так что давайте вернемся к спецификации и проверки какие условия для действительного входа будет. Допустимые высоты собираются находиться в диапазоне от 0 до 23 включительно. Так что недействительные высоты собираются быть меньше 0 или более 23. Так что помните, чтобы разработать ваше состояние тщательно, зная, что условие для дел в то время как петли должно быть в то время как п является недействительным. Теперь это не будет простой одиночный логическое выражение. Мы будем должны объединить два разных выражения чтобы все наше состояние. 

Так что давайте просто посмотрим на таблицу истинности я уже дал вам намек, что мы будет иметь дело с двумя Booleans. Так вот таблица истинности, где я есть два Booleans-- Boolean 1 и 2. Таким образом, у нас есть возможность оценить bool1 и bool2 или bool1 или bool2. И будет только справедливо, если оба Booleans оценить, правда, в то время как все или будет верно до тех пор, как один из два Booleans оценивается как истина. ОК, так что потребуется некоторое время, сделать паузу в этом видео и переварить эту таблицу истинности. Я буду здесь ждать. Когда вы вернетесь, см если вы можете кусочкам логическое выражение для вашего условие п является недопустимым вход. 

Так что теперь у нас есть действительный пользовательский ввод, давайте идти вперед и говорить о том, как мы может сделать половину пирамиды. Вот в этом простом текстовом редакторе, Я нарисовал выравнивание по левому краю пирамиды. Но мы знаем, что нам нужны наши Пирамида быть выровнены по правому краю. Так как я могу это сделать? Ну, я мог бы попытаться подтолкнуть все на сторону путем просто положить немного характер между ними. А потом, на следующий линии, я собираюсь поставить еще несколько символов, чтобы толкать его вперед, и further-- так далее и так forth-- пока я не иметь правильную пирамиду выровнен. Таким образом, у нас есть выравнивается по правому краю пирамиды, но это не выглядит так великолепно с точками. Но мы все еще хотим поддерживать этот хороший интервал. Так что я собираюсь в буквальном смысле слова вставить некоторые пробелы. 

Вместо трех точек, я буду положил один, два, три пространства. На второй строке. Я поставил один, два пространства. А на предпоследнем линия, только один пробел. А вот у меня есть выравнивание по правому краю пирамиды. От делать пример в тексте редактор, у нас есть идея для шаблона что мы будем использовать, чтобы сделать половину пирамиды. Для каждой строки, что мы сделали это мы вводим некоторые пробелы, а затем напечатал некоторые хэши, а затем набирается клавиша Enter, которая создает новую линию. Так что теперь у нас есть, что, пойдем один шаг вперед и найти шаблон. 

Так что я собираюсь сказать, для Интерес этого примера, мы имеем дело с высотой 8. Первая строка будет иметь два хэши, который следует семь пространств. В second-- три хэши, шесть пространств. В-третьих row-- четыре хэши, пять spaces-- так далее, и так далее пока мы не получим до энной строки. Итак, я прошу вас за NTH строки, сколько хэши мы будем иметь и сколько пространства? Так что до вас, чтобы выяснить формула для представления, сколько хэши и сколько пространства необходимы для й строке, когда у вас есть какой-то высоты. 

Теперь, когда вы выяснить это, будьте осторожны, как вы индексации. То, что я имею в виду, что в повседневной жизни всех нас начать отсчет, как правило, на 1. Но в CS50 и в информатике В общем, мы 0 индексировать. Таким образом, первая строка будет N 0, в отличие от 1. Будьте осторожны в этом, когда вы пытаясь выяснить вашу картину. Так что теперь давайте вернемся к тому, как мы собираемся сделать нашу пирамиду. Для каждой строки, мы будем хотеть печать пространства, печать хэши, а затем распечатать новую строку. Намек здесь слово "для" каждой строки. В C, мы имеем конструкцию называется цикл, которая состоит из инициализация, условие, обновление, и тело цикла. 

Скажите, что я хотел сказать, привет мир, в 50 раз, мой цикл будет выглядеть примерно так. Я инициализировать мое целое число 0. Условием является то, что я меньше 50. И тогда мое обновление просто приращением I на единицу каждый раз. Мы также можем использовать для петель перебрать вещи. Обратите внимание на то, как здесь мы не имеем жестко закодированы номер, а поместил переменную высота вместо того, чтобы в состоянии. Так что я делаю здесь я итерация над каждой строки пирамиды. Я могу сделать что-то для каждого грести внутри тела моего цикла. 

Что мы делаем внутри тело цикла? Ну, как мы уже говорили, мы печати пространства и мы хэши печати и мы печати новую строку. Так что мой наружный цикл будет выглядеть следующим образом. Я перебирать каждую строку пирамиды, используя, В этом случае, высота в качестве переменной который хранит высота пирамиды. Внутри тела этого цикла, я собирается печатать пробелы повторно, печать хэши повторно, а затем распечатать новую строку. 

Так что теперь, используя все понятия, которые Я говорил об этом в проходных, вы должны быть в состоянии подсказать пользователя для ввода, проверки того, что входной сигнал, а затем сделать половину пирамиды. 

Меня зовут Zamyla, и это CS50. 