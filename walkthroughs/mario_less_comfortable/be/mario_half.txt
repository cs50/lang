ZAMYLA чан: Гэта я, Zamyla. Сёння ў Марыё, мы збіраемся быць малюнак палову піраміды для Марыё каб падняцца ўверх. Такім чынам, давайце пагаворым аб нашым штодзённік для гэтай праблемы. Мы будзем хацець запытваць і правяраць карыстальнік для правільнага ўводу, як высока яны хочуць піраміды Марыё быць. А потым, мы будзем маляваць яго. Так што давайце пачнем з запытам і праверкі карыстальніка для іх ўводу. 

Мы можам выкарыстоўваць з Функцыя CS50 Бібліятэка атрымаць Int, што будзе гарантаваць, што карыстач уводзіць цэлы лік. Любыя станоўчыя колькасці, адмоўныя цэлыя лікі, лік 0 ўсё справядлівая гульня. У адваротным выпадку карыстальнік будзе прапанавана паўтарайце, пакуль яны ўвесці дапушчальнае цэлы лік. Цяпер, хоць Get INT робіць шмат працы для нас ў забеспячэнні таго, Карыстальнік дае нам цэлы лік, мы ўсё яшчэ павінны ўжыць некаторыя дадатковыя абмежаванні на гэты конт. У рэшце рэшт, мы не можам мець Марыё ўзыходжанне палова піраміда вышынёй 12 адмоўнай. 

У дадатак да гэтага, тэхнічныя праблемы кажа, што мы можам толькі Марыё дазваляюць падняцца піраміда вышынь ад 0 да 23. ОК, так што гэта азначае, што нам трэба бесперапынна запытваць карыстальніка каб даць нам сапраўдны нумар і толькі працягваць як толькі яны далі нам сапраўдную вышыню. Як мы гэта робім? 

Ну, бесперапынныя працэсы даюць нам ідэя loops-- рабіць нешта паўторна. Адзін цыкл у C, як некаторы час цыкл, які будзе бесперапынна выконваць цела цыклу да таго часу, дадзенае ўмова вылічаецца як ісціна. Як толькі гэта ўмова ацэньваецца як ілжывае, праграма прыступіць да усё, што прыходзіць пасля гэтага. Такім чынам, у той час як завесы адзін са спосабаў гарантуючы, што мы ўвесь час запытваць у карыстальніка сапраўднага ўводу. І як толькі яны даюць нам правільны ўваход, мы будзем працягваць да таго, што будзе далей. Мы ведаем, што мы будзем прасіць карыстальнік для ўводу па меншай меры, адзін раз. Так што цяпер мы прыходзім да сястры у той час як цыкл, які з'яўляецца зрабіць падчас цыклу. 

Ці ёсць у той час як завесы будуць выконвацца цела цыклу па меншай меры адзін раз. Такім чынам, без праверкі стану, ён будзе выконвацца цела цыклу. А затым праверце стан, каб убачыць мае патрэбу Ці яна паўтарацца. Гэта зручна, калі мы праверкі ўводу дадзеных карыстальнікам. Мы ведаем, што мы збіраемся каб спытаць іх, па меншай меры адзін раз. Так рабіць, пакуль цыкл можа шукаць нешта накшталт гэтага. У нас ёсць цэлае п. І ўнутры спраў у той час як завесы, мы адразу запытваць у карыстальніка цэлае. Калі п ня дзейнічае, то мы будзем падказваць ім ня зноў і зноў і зноў, пакуль яны даюць нам, што сапраўдны лік. Нарэшце, калі п з'яўляецца дапушчальным ўваход, мы будзем перайсці да астатняй частцы нашай праграмы. 

Так што давайце вернемся да спецыфікацыі і праверкі якія ўмовы для сапраўднага ўваходу будзе. Дапушчальныя вышыні збіраюцца знаходзіцца ў дыяпазоне ад 0 да 23 ўключна. Так што несапраўдныя вышыні збіраюцца быць менш 0 або больш за 23. Так што памятаеце, каб распрацаваць ваш стан старанна, ведаючы, што ўмова для спраў у той час як завесы павінна быць у той час як п з'яўляецца несапраўдным. Зараз гэта не будзе просты адзіночны лагічны выраз. Мы будзем павінны аб'яднаць два розныя выразы каб усе наш стан. 

Так што давайце проста паглядзім на табліцу праўдзівасці я ужо даў вам намёк, што мы будзе мець справу з двума Booleans. Дык вось табліца праўдзівасці, дзе я ёсць два Booleans-- Boolean 1 і 2. Такім чынам, у нас ёсць магчымасць ацаніць bool1 і bool2 або bool1 або bool2. І будзе толькі справядліва, калі абодва Booleans ацаніць, праўда, у той час як усе ці будзе дакладна да таго часу, як адзін з два Booleans ацэньваецца як ісціна. ОК, так што спатрэбіцца некаторы час, зрабіць паўзу ў гэтым відэа і пераварыць гэтую табліцу праўдзівасці. Я буду тут чакаць. Калі вы вернецеся, см калі вы можаце кавалачках лагічнае выраз для вашага ўмова п з'яўляецца недапушчальным ўваход. 

Так што цяпер у нас ёсць сапраўдны карыстацкі ўвод, давайце ісці наперад і казаць пра тое, як мы можа зрабіць палову піраміды. Вось у гэтым простым тэкставым рэдактары, Я намаляваў выраўноўванне па левым краі піраміды. Але мы ведаем, што нам патрэбныя нашы Піраміда быць выраўнаваны па правым краі. Так як я магу гэта зрабіць? Ну, я мог бы паспрабаваць падштурхнуць усё на бок шляхам проста пакласці трохі характар ​​паміж імі. А потым, на наступны лініі, я збіраюся паставіць яшчэ некалькі знакаў, каб штурхаць яго наперад, і further-- гэтак далей і гэтак forth-- пакуль я не мець правільную піраміду выраўнаваны. Такім чынам, у нас ёсць выраўноўваецца па правым краі піраміды, але гэта не выглядае так пышна з кропкамі. Але мы ўсё яшчэ жадаем падтрымліваць гэты добры інтэрвал. Так што я збіраюся ў літаральным сэнсе слова ўставіць некаторыя прабелы. 

Замест трох кропак, я буду паклаў адзін, два, тры прасторы. На другім радку. Я паставіў адзін, два прасторы. А на перадапошнім лінія, толькі адзін прабел. А вось у мяне ёсць выраўнаванне па правым боку піраміды. Ад рабіць прыклад у тэксце рэдактар, у нас ёсць ідэя для шаблону што мы будзем выкарыстоўваць, каб зрабіць палову піраміды. Для кожнага радка, што мы зрабілі гэта мы ўводзім некаторыя прабелы, а затым надрукаваў некаторыя хэшы, а затым набіраецца клавіша Enter, якая стварае новую лінію. Так што цяпер у нас ёсць, што, пойдзем адзін крок наперад і знайсці шаблон. 

Так што я збіраюся сказаць, для Цікавасць гэтага прыкладу, мы маем справу з вышынёй 8. Першы радок будзе мець два хэшы, які варта сем прастор. У second-- тры хэшы, шэсць прастор. Па-трэцяе row-- чатыры хэшы, пяць spaces-- гэтак далей, і гэтак далей пакуль мы не атрымаем да энной радка. Такім чынам, я прашу вас за NTH радкі, колькі хэшы мы будзем мець і колькі прасторы? Так што да вас, каб высветліць формула для прадстаўлення, колькі хэшы і колькі прасторы неабходныя для м радку, калі ў вас ёсць нейкі вышыні. 

Зараз, калі вы высветліць гэта, будзьце асцярожныя, як вы індэксацыі. Тое, што я маю на ўвазе, што ў паўсядзённым жыцці ўсіх нас пачаць адлік, як правіла, на 1. Але ў CS50 і ў інфарматыцы Увогуле, мы 0 індэксаваць. Такім чынам, першы радок будзе N 0, у адрозненне ад 1. Будзьце асцярожныя ў гэтым, калі вы спрабуючы высветліць вашу карціну. Так што цяпер давайце вернемся да таго, як мы збіраемся зрабіць нашу піраміду. Для кожнага радка, мы будзем хацець друк прасторы, друк хэшы, а затым раздрукаваць новы радок. намёк тут слова "для" кожнага радка. У C, мы маем канструкцыю называецца цыкл, якая складаецца з ініцыялізацыя, ўмова, абнаўленне, і цела цыклу. 

Скажыце, што я хацеў сказаць, прывітанне свет, у 50 разоў, мой цыкл будзе выглядаць прыкладна так. Я ініцыялізаваць маё цэлы лік 0. Умовай з'яўляецца тое, што я менш за 50. І тады маё абнаўленне проста прырашчэннем I на адзінку кожны раз. Мы таксама можам выкарыстоўваць для завес перабраць рэчы. Звярніце ўвагу на тое, як тут мы не маем жорстка закадаваныя нумар, а змясціў зменную вышыня замест таго, каб у стане. Так што я раблю тут я ітэрацыя над кожнага радка піраміды. Я магу зрабіць што-то для кожнага веславаць ўнутры цела майго цыклу. 

Што мы робім ўнутры цела цыкла? Ну, як мы ўжо казалі, мы друку прасторы і мы хэшы друку і мы друку новы радок. Так што мой вонкавы цыкл будзе выглядаць наступным чынам. Я перабіраць кожную радок піраміды, выкарыстоўваючы, У гэтым выпадку, вышыня ў якасці зменнай які захоўвае вышыня піраміды. Ўнутры цела гэтага цыклу, я збіраецца друкаваць прабелы паўторна, друк хэшы паўторна, а затым раздрукаваць новы радок. 

Так што цяпер, выкарыстоўваючы ўсе паняцці, якія Я казаў пра гэта ў прахадных, вы павінны быць у стане падказаць карыстальніка для ўводу, праверкі таго, што ўваходны сігнал, а затым зрабіць палову піраміды. 

Мяне клічуць Zamyla, і гэта CS50. 