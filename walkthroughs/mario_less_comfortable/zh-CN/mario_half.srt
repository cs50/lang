1
00:00:00,000 --> 00:00:00,500

2
00:00:00,500 --> 00:00:02,500
陈ZAMYLA：这是一个我，Zamyla。

3
00:00:02,500 --> 00:00:06,910
今天马里奥，我们将要
图纸马里奥半金字塔

4
00:00:06,910 --> 00:00:08,290
爬了​​起来。

5
00:00:08,290 --> 00:00:11,570
>> 所以，让我们来谈谈我们
待办的这个问题。

6
00:00:11,570 --> 00:00:13,610
我们会想
提示和验证

7
00:00:13,610 --> 00:00:18,290
用户对于如何有效输入
高，他们希望马里奥的金字塔是。

8
00:00:18,290 --> 00:00:20,090
接下来，我们要画它。

9
00:00:20,090 --> 00:00:24,870
因此，让我们开始使用提示和
验证他们的用户输入。

10
00:00:24,870 --> 00:00:27,640
>> 我们可以利用的
CS50库函数

11
00:00:27,640 --> 00:00:31,160
得到INT将确保
用户输入的整数。

12
00:00:31,160 --> 00:00:35,730
任何正整数，负
整数，0号都是公平的游戏。

13
00:00:35,730 --> 00:00:41,670
否则，用户将被提示
重试，直到他们输入一个有效的整数。

14
00:00:41,670 --> 00:00:44,210
现在虽然GET INT呢
很多关于我们的工作

15
00:00:44,210 --> 00:00:46,730
在确保
用户给了我们一个整数，

16
00:00:46,730 --> 00:00:50,760
我们仍然需要应用一些
上额外的约束。

17
00:00:50,760 --> 00:00:56,420
毕竟，我们不能有马里奥攀岩
高度负12的一半的金字塔。

18
00:00:56,420 --> 00:00:59,040
>> 除此之外，该
问题说明

19
00:00:59,040 --> 00:01:02,490
说，我们只能
让马里奥爬

20
00:01:02,490 --> 00:01:06,940
高度的0到23之间的金字塔。

21
00:01:06,940 --> 00:01:11,120
好了，这意味着我们需要
连续提示用户

22
00:01:11,120 --> 00:01:14,320
给我们一个有效
数只有不断

23
00:01:14,320 --> 00:01:17,120
一旦他们已经给了我们一个有效的高度。

24
00:01:17,120 --> 00:01:18,720
我们怎么办呢？

25
00:01:18,720 --> 00:01:23,760
>> 那么，连续的过程给我们
的loops--做某事的想法

26
00:01:23,760 --> 00:01:24,720
重复。

27
00:01:24,720 --> 00:01:28,220
在C一根环路一段时间
循环将持续

28
00:01:28,220 --> 00:01:33,480
只要执行循环体
给定的条件计算为真。

29
00:01:33,480 --> 00:01:36,200
一旦这个条件
计算结果为false，

30
00:01:36,200 --> 00:01:39,770
该计划将继续进行
以后无论发生什么事。

31
00:01:39,770 --> 00:01:43,180
因此，while循环的一种方式
确保我们不断

32
00:01:43,180 --> 00:01:45,320
提示输入有效用户输入。

33
00:01:45,320 --> 00:01:50,070
一旦他们给我们一个有效的输入，
我们将继续成何体统来。

34
00:01:50,070 --> 00:01:54,380
我们知道，我们要问
用户至少一次输入。

35
00:01:54,380 --> 00:01:59,200
所以，现在我们来到的一姐
while循环，这是do while循环。

36
00:01:59,200 --> 00:02:02,650
>> do-whil​​e循环将执行
循环体至少一次。

37
00:02:02,650 --> 00:02:06,150
因此，没有检查的情况下，
它将执行循环体。

38
00:02:06,150 --> 00:02:09,750
然后检查情况看
是否需要重演。

39
00:02:09,750 --> 00:02:13,080
这是在方便的时候
我们正在验证用户输入。

40
00:02:13,080 --> 00:02:15,830
我们知道，我们要去
问他们至少一次。

41
00:02:15,830 --> 00:02:18,780
因此，一个do while循环可能
是这个样子。

42
00:02:18,780 --> 00:02:20,090
我们有一个整数n。

43
00:02:20,090 --> 00:02:22,760
而做的内部
while循环，我们马上

44
00:02:22,760 --> 00:02:24,750
提示整数用户。

45
00:02:24,750 --> 00:02:29,740
如果n是无效的，那么我们就会促使他们
一次一次又一次，直到他们

46
00:02:29,740 --> 00:02:31,820
给我们有效的整数。

47
00:02:31,820 --> 00:02:37,440
最后，当n是一个有效的投入，我们将
继续我们的节目的其余部分。

48
00:02:37,440 --> 00:02:41,830
>> 因此，让我们回到规范和检查
什么有效的输入条件

49
00:02:41,830 --> 00:02:43,670
将是。

50
00:02:43,670 --> 00:02:48,090
的有效高度要
介于0和23（含）之间。

51
00:02:48,090 --> 00:02:53,350
因此无效的高度要
小于0或大于23。

52
00:02:53,350 --> 00:02:56,420
所以请记住，设计
你的病情仔细，

53
00:02:56,420 --> 00:02:58,660
知道该条件
为do while循环

54
00:02:58,660 --> 00:03:01,470
应而n是无效的。

55
00:03:01,470 --> 00:03:05,080
现在，这不会是一个
简单的单布尔表达式。

56
00:03:05,080 --> 00:03:07,630
我们将不得不结合
两种不同的表现

57
00:03:07,630 --> 00:03:09,900
使我们的整体状态。

58
00:03:09,900 --> 00:03:13,290
>> 因此，让我们只看一个真值表我已经
已经给你，我们的提示

59
00:03:13,290 --> 00:03:15,200
将要处理两个布尔值。

60
00:03:15,200 --> 00:03:19,620
所以这里有一个真值表，我
有两个Booleans--布尔值1和2。

61
00:03:19,620 --> 00:03:27,050
因此，我们必须评估选项
BOOL1和BOOL2或BOOL1或BOOL2。

62
00:03:27,050 --> 00:03:31,980
并只当双方真实
布尔值评估为true，而所有

63
00:03:31,980 --> 00:03:37,280
或将如此只要之一
两个布尔值计算结果为true。

64
00:03:37,280 --> 00:03:41,450
OK，所以采取了片刻，暂停此
视频和消化这个道理表。

65
00:03:41,450 --> 00:03:42,930
我会在这里等候。

66
00:03:42,930 --> 00:03:45,760
当你回来时，看到
如果你能拼凑

67
00:03:45,760 --> 00:03:51,910
布尔表达式为您
n个条件是无效的输入。

68
00:03:51,910 --> 00:03:54,420
>> 所以，现在我们有
有效的用户输入，让我们

69
00:03:54,420 --> 00:03:58,710
继续前进，谈谈我们如何
可能会得出一半的金字塔。

70
00:03:58,710 --> 00:04:03,410
在这里，在这个简单的文本编辑器，
我画一个左对齐的金字塔。

71
00:04:03,410 --> 00:04:07,050
但我们知道，我们需要我们的
金字塔是正确对齐。

72
00:04:07,050 --> 00:04:08,650
所以，我怎么可以这样做？

73
00:04:08,650 --> 00:04:11,440
好吧，我可能会尝试推
一切都在一旁

74
00:04:11,440 --> 00:04:14,880
通过只把一点点
字符之间。

75
00:04:14,880 --> 00:04:16,779
然后，对于下一
行了，我打算把

76
00:04:16,779 --> 00:04:20,970
一些更多的字符，以推动它一起
和further--等等等等forth--

77
00:04:20,970 --> 00:04:23,360
直到我有右对齐金字塔。

78
00:04:23,360 --> 00:04:27,780
所以，我们有一个正确对齐的金字塔，但
它看起来并不那么大的点。

79
00:04:27,780 --> 00:04:30,680
但是，我们仍然要
保持那该多好间距。

80
00:04:30,680 --> 00:04:35,260
所以我打算从字面上
插入一些空间。

81
00:04:35,260 --> 00:04:39,420
>> 取而代之的三个点，我会
放一个，两个，三个空间。

82
00:04:39,420 --> 00:04:40,370
在第二行。

83
00:04:40,370 --> 00:04:42,640
我把一，二位。

84
00:04:42,640 --> 00:04:45,370
而在倒数第二
行，只有一个空间。

85
00:04:45,370 --> 00:04:48,290
在这里，我有一个右对齐金字塔。

86
00:04:48,290 --> 00:04:52,170
从做在文本的例子
编辑，我们有图案的想法

87
00:04:52,170 --> 00:04:54,590
我们将用它来绘制半金字塔。

88
00:04:54,590 --> 00:04:58,080
对于每一行，我们做什么
是我们键入一些空间，

89
00:04:58,080 --> 00:05:00,170
然后键入一些
散列，然后键入

90
00:05:00,170 --> 00:05:03,020
输入键，这
正在创建一个新的行。

91
00:05:03,020 --> 00:05:07,770
所以，现在，我们有，让我们去
一步，找到一个模式。

92
00:05:07,770 --> 00:05:10,170
>> 所以我要说，对于
本实施例的兴趣，

93
00:05:10,170 --> 00:05:12,480
我们正在处理的8的高度。

94
00:05:12,480 --> 00:05:17,100
第一行是要具有两个
下面7个空格的哈希值。

95
00:05:17,100 --> 00:05:20,020
该second-- 3哈希值，六个空格。

96
00:05:20,020 --> 00:05:24,260
第三row--四个散列值，五
spaces--等等等等

97
00:05:24,260 --> 00:05:26,350
直到我们得到的第n行。

98
00:05:26,350 --> 00:05:31,540
于是，我问你的第n行，
多少散列，我们将不得不

99
00:05:31,540 --> 00:05:33,120
又有多少空间？

100
00:05:33,120 --> 00:05:37,000
所以这是给你找出一个
公式来表示多少哈希

101
00:05:37,000 --> 00:05:42,020
多少空间所需的
第n行，当你有一定的高度。

102
00:05:42,020 --> 00:05:46,060
>> 现在，当你搞清楚了这一点，
小心你是如何索引。

103
00:05:46,060 --> 00:05:49,170
我的意思是说
在日常生活中我们所有人

104
00:05:49,170 --> 00:05:51,540
开始由1算起，通常。

105
00:05:51,540 --> 00:05:55,950
但在CS50和计算机科学
在一般情况下，我们是0的索引。

106
00:05:55,950 --> 00:06:00,620
因此第一行是
0 n作为反对1。

107
00:06:00,620 --> 00:06:04,550
要小心这个时候你
试图找出你的模式。

108
00:06:04,550 --> 00:06:07,570
所以，现在，让我们回去如何
我们要引起我们的金字塔。

109
00:06:07,570 --> 00:06:12,300
对于每一行，我们会想
打印空间，打印的哈希值，

110
00:06:12,300 --> 00:06:14,050
然后打印一个新行。

111
00:06:14,050 --> 00:06:19,160
这里的提示是
词“为”每一行。

112
00:06:19,160 --> 00:06:21,470
在C中，我们有一个结构
被称为一个循环，

113
00:06:21,470 --> 00:06:25,250
它包括一个
初始化，条件，更新，

114
00:06:25,250 --> 00:06:26,790
并且循环体。

115
00:06:26,790 --> 00:06:31,360
>> 说我想说的话，你好
世界上50倍，我的for循环

116
00:06:31,360 --> 00:06:32,880
会是这个样子。

117
00:06:32,880 --> 00:06:35,480
我初始化我的整数为0。

118
00:06:35,480 --> 00:06:38,230
的条件是，I小于50。

119
00:06:38,230 --> 00:06:42,350
然后我的更新仅仅是
通过每一个时间递增我。

120
00:06:42,350 --> 00:06:45,140
我们也可以使用循环
遍历的事情。

121
00:06:45,140 --> 00:06:47,820
注意这里我们怎么没有
硬编码的数，

122
00:06:47,820 --> 00:06:51,820
而是放在变量
高度而不是插入的条件。

123
00:06:51,820 --> 00:06:56,420
所以，我在做什么这里我遍历
在金字塔的每一行。

124
00:06:56,420 --> 00:07:00,160
我可以做一些对每个
排我的循环体内部。

125
00:07:00,160 --> 00:07:02,350
>> 什么是我们内部做
循环的身体？

126
00:07:02,350 --> 00:07:07,120
嗯，正如我们已经说过，我们在输出
空间和我们在输出哈希

127
00:07:07,120 --> 00:07:09,480
我们要打印一个新行。

128
00:07:09,480 --> 00:07:11,950
所以，我的外循环
看起来是这样。

129
00:07:11,950 --> 00:07:15,070
我遍历每个行
金字塔的，使用

130
00:07:15,070 --> 00:07:18,890
在这种情况下，高度可变
存储该金字塔的高度。

131
00:07:18,890 --> 00:07:22,870
该循环的身体里面，我
要重复打印空间，打印

132
00:07:22,870 --> 00:07:26,730
反复哈希值，
然后打印一个新行。

133
00:07:26,730 --> 00:07:31,010
>> 所以，现在，使用所有的概念
我在这个步行通过津津乐道，

134
00:07:31,010 --> 00:07:35,210
你应该能够提示
用户输入，验证输入，

135
00:07:35,210 --> 00:07:37,370
然后绘制一半的金字塔。

136
00:07:37,370 --> 00:07:41,510
>> 我的名字是Zamyla，这是CS50。

137
00:07:41,510 --> 00:07:43,167

