AMILA: ni pagharap sa isang bagay Caesar Hayaan. Sa Caesar, pinapayagan namin ang gumagamit upang i-encode ng isang lihim na mensahe. Kaya sabihin sumisid karapatan sa at tumingin sa aming to-dos para sa problemang ito. Kaya una, makuha namin ang susi mula sa user. Pagkatapos namin makuha ang plaintext na gusto nilang i-encode. Pagkatapos nito, Encipher namin ito para sa kanila, at sa wakas i-print namin ang kanilang ciphertext. 

Kaya sabihin magsimula sa isang halimbawa. Sabihin mo nais na gawing kowd ang buong alpabeto na may isang key ng dalawang. Well, ang iyong buong alpabeto gagawin lamang shifted sa mga titik. So A ay i-encode sa C, B sa D, C to E, iba pa at iba pa, hanggang sa makuha mo sa X, na kung saan encodes hanggang Z o zed, depende sa kung saan ikaw ay mula sa. Pagkatapos Y ay pagkatapos shift lahat ng paraan, wrapper sa paligid ng alpabeto upang makakuha ng A, at pagkatapos ay sa wakas ang huling titik ng alpabeto, Z, zed, Gusto i-encode sa B. 

nakuha mo na? Tingnan natin ang ilang halimbawa. Ang unang halimbawa dito ay halos kapareho sa kung ano lang namin ipinaliwanag sa itaas. Kaya kung i-encode ko ang ilang mga seksyon ng alpabeto, A sa pamamagitan ng L, sa pamamagitan ng isang susi ng dalawa, pagkatapos ko na lang makuha ang aking buong alpabeto shifted dalawang titik. 

Pagkatapos, sa aking mga susunod na halimbawa, ang susi ay pa rin dalawa, kaya dapat mo pa rin alam kung aling mga titik ang aasahan. Ngunit dito ito ay isang parirala. Ito ay CS50. Kaya mapapansin mo na ako mapanatili ang kaso ng aking mga titik, kaya ang anumang mga malaking titik titik ding upper case titik sa ciphertext. At anumang lowercase mga titik sa plaintext ay din lowercase mga titik sa ciphertext. Nguni't hinahampas ko ang mga titik at anumang exclamation marks o anumang iba pang bantas pareho. 

Kaya ngayon na kami ay may isang kahulugan para sa kung paano gumagana ang programa, huwag mag-atubiling upang pumunta tumakbo ng ilang mga karagdagang mga halimbawa ng iyong sarili, kung nais mo. Magsimula tayo sa pagkuha Hayaan ang susi mula sa user. Ayon sa kaugalian, na may iba pang mga problema, na namin ay bihasa sa pagkuha ng anumang mga numero na kami kailangan sa pamamagitan ng pagdikta sa gumagamit may pag-andar getint. Ngunit oras na ito ang tunay na kami ay pagpunta gamitin ang command line argument at ng isang bagong function na tinatawag na atoi. 

Kapag nagpatakbo ka ng main programa sa C, at pagkatapos na ito tumatagal sa dalawang parameters-- int argc, na kung saan ay ang bilang ng mga argumento ipinasa sa, at pagkatapos ay argv, isang array ng mga string na naglalaman ng ang listahan ng lahat ng mga argumento lumipas. Hindi mo explicitly kung upang ipahayag ang mga variable. Ang mga ito ay computed para iyo sa pamamagitan ng tagatala. Tamang paggamit para ito ay magiging para argc na dalawang sa kasong ito, dahil ang gumagamit ay may upang pumasa sa ang tawag sa programa, ./caesar, at pagkatapos ay ang key, anumang bilang gusto nila. Kaya na nangangahulugan na argc ay dapat na dalawang sa order para sa isang may-bisang paggamit ng Caesar na pinaandar. 

Kaya tingnan natin ang isang halimbawa. Sabihin na ako na nakasulat at compiled ng isang programa na tinatawag na paglipad. Kaya kung ako ang bumangga sa command line ./blastoff Team Rocket, well, pagkatapos, argc ay magiging tatlong dahil ako lumipas sa tatlong natatanging mga argumento. Pagkatapos argv ay ganito ang hitsura. Ito ay isang array, at gagawin ito naglalaman bawat isa sa tatlong mga string. ./blastoff sa unang index, team sa susunod na, at rocket sa huling. 

Pag-usapan natin arrays para sa isang sec Hayaan. Arrays ay data structures na hawak maramihang mga halaga ng parehong uri. Ito ay maaaring dumating sa madaling-gamiting kapag kami may mga listahan ng mga integers o string. Tandaan lamang mayroon silang upang maging ang parehong uri. Sa computer science, kami Gustung-gusto pagbibilang mula sa zero, kaya tandaan na arrays ding zero-index. Kaya ang unang elemento ng aking array ay pagpunta sa maging sa index zero. Kaya sa kasong ito, kapag mayroon akong isang array ng haba apat, pagkatapos ay ang huling index ng huling elemento ng aking array ay aktwal na pagpunta sa maging sa index ng tatlong, hindi apat. Dahil tandaan, kami magbilangan sa zero. 

Narito ang isang halimbawa ng kung paano mo maaaring lumikha ng isang array ng iyong sariling grupo. Kaya sinasabi ko nais na tindahan ang aking tatlong mga paboritong mga pangalan ng aso. Pagkatapos Gusto ko lumikha ng isang array ng mga string. Kaya Gusto kong ipahayag ang uri, string, at pagkatapos ay ilagay ang pangalan ng array, aso, at pagkatapos ay sa mga square bracket ilagay ang laki ng array sa kasong ito, tatlo. 

Kaya ang aking unang entry ay pagpunta upang maging aso sa index zero, at na ay pagpunta sa maging Milo. Pagkatapos aso sa index isa ay pagpunta sa maging maloko, darling Mochi, at pagkatapos ay ang huling entry, ang ikatlong entry sa index dalawa, ay magiging maganda, matamis Elphie. Mapapansin mo na ang format para sa pagpuno sa array na ito ay napaka tulad ng kung paano mo maaaring magpahayag ng anumang iba pang mga variable na kung saan ang ikaw ay may ang pangalan ng variable na sinusundan ng ang halaga na iyong nais na naka-imbak sa loob nito. Ang tanging pagkakaiba sa kasong ito ay na kayo kailangang tandaan upang ilagay ang index ng halaga sa mga square bracket. At doon na namin ang aming tatlong mga paboritong aso. 

Ngunit sayang, oras na upang makabalik sa Caesar. Tandaan na tamang paggamit para sa user ay pagpunta sa ay pagpasa sa hindi lamang ang pangalan ng programa ./caesar, ngunit din ang susi na gusto nilang i-shift kanilang plaintext sa pamamagitan ng. Kaya na nangangahulugan na argc ay dapat na dalawa. Dapat silang pumasa sa two-- hindi hihigit, walang mas mababa sa dalawang argumento command line. 

Ngayon, kung ano ang tungkol argv? Well, namin na malaman na ang array ay pagpunta sa maging ng haba dalawa, ngunit kung ano ang nakapaloob sa bawat elemento? Well, ang unang elemento ay pagpunta sa maging ./caesar, at pagkatapos ay ang susunod na elemento ay pagpunta sa naglalaman ng mga susi na ang gumagamit ay nai-type sa. Ngayon, kung ginamit nila ito nang tama para sa paggamit ng Caesar, pagkatapos ay sila ay pagpunta sa i-type sa isang numero. Ngunit kahit na ang character na sila ay uri ay isang numero, ito ay ng uri ng data string. 

Kaya paano i-convert namin na string sa isang integer? Kaya sabihin ako ng num, isang string, na naglalaman ng mga string 50. Kung gusto kong i-convert na sa isang integer, at pagkatapos ay ako lang magpahayag ng isang bagong variable, isang integer i, pagtawag atoi. Pumasa ko sa aking string variable, num, at pagkatapos ay i ay pagkatapos na maglaman ng numero 50. Siguraduhin na tingnan ang tao pahina para sa atoi function na upang tingnan kung anong library ito ay in, pati na rin ang kung ano ang halaga nito ay babalik kung ang string lumipas in ay hindi naglalaman ng lahat ng mga numero. 

Kaya ngayon na namin nakuha ang susi, ang susunod na hakbang ay upang makuha ang plaintext mula sa user. Ngayon, ito ay pagpunta sa maging mas kumplikado kaysa sa pag-navigate sa paligid ng command line argumento. Lahat ng kailangan naming gawin ay tawag ang getstring function na upang i-prompt ang user ay upang bigyan sa amin ng isang string, ngunit tandaan upang suriin ang mga pagtutukoy para sa kung paano namin maaaring nais na i-prompt ang user para sa na. 

Ngayon kami dumating sa ang puso ng problem-- kung paano Encipher ang plaintext. Well, una, sabihin makipag-usap tungkol sa kung paano upang Encipher isang character sa isang pagkakataon, at pagkatapos ay gagamitin namin matugunan kung paano umulit sa ibabaw ng buong plaintext. Ko na nakasulat ang ilang pseudocode para sa mga problema Caesar. Hinihikayat ko kayo na isulat ang iyong sarili pati na rin. Hindi ito maaaring tumingin katulad sa akin, at iyon lamang ang OK, ngunit hangga't bilang ang pangkalahatang ideya ay ang parehong. 

Ang unang tatlong mga hakbang Kayo ay nakagawa tapos namin. nakuha namin ang susi mula sa command line argument, na-on namin na susi na ito sa isang integer, at na namin sinenyasan ang user para sa plaintext na nais nilang Encipher. Kaya pagkatapos ay ang susunod na malaking tipak ay na para sa bawat karakter sa plaintext string, kung ito ay pang-abakada, gusto naming mapanatili kaso nito at maglipat dito. Sa pamamagitan ng mapanatili kaso, kung ano ang aking ibig sabihin ay na ang lahat upper case titik dapat manatili upper kaso at lahat ng maliit na mga titik dapat manatili lowercase. Nga, pagkatapos namin maglipat ng mga, pagkatapos ay i-print namin ang ciphertext. 

Narito ang tatlong mga pag-andar na pagpunta na dumating sa madaling-magamit para sa mga problemang ito. Tandaan up sa itaas kapag ako ay nagbigay ng halimbawa para sa paglilipat na ito ay CS50? Tandaan na ang 50 at ang exclamation mark ay hindi shift? Kaya kung paano maaari naming sabihin kung kami kailangan upang ilipat ang isang sulat o hindi? Well, "ay alpha," kung kayo na ipasa ito ng isang character, ay babalik true kung na karakter ay isang sulat at maling kung hindi man. Upang makatulong sa iyo na may pagpepreserba capitalization ang mga function "ay upper "at" ay mas mababa. " 

Ang dalawang mga function ring kumuha sa isang solong character bilang input at ibalik mo ang isang Boolean, alinman true o false depende sa kung character na ay malaking titik o maliit na titik. Dahil "ay itaas" at "ay mas mababang "ay Boolean function, ibig sabihin na ikaw ay bumalik sila ng isang Boolean, maaari mong gamitin ang mga ito sa iyong kondisyon. Kaya narito ang isang snippet ng code na lamang Kopya ng sulat kung ito ay itaas na kaso. Kaya ipinahayag ko ang aking karakter sulat na ang mga malaking titik zed at pagkatapos ay kung "ay itaas" returns totoo, at pagkatapos i-print ko na sulat. 

Pagbabalik sa aming simpleng halimbawa ng paglilipat ng alpabeto sa pamamagitan ng isang susi ng dalawa, paano namin talagang makakuha na sa trabaho? Well, ito ay lumiliko out na mga letra at integers ay napaka malapit na nauugnay. Ang bawat karakter ay may isang integer halaga na kaugnay may nasusumpungan man sa tsart ASCII, kung saan ASCII bawat character halaga ay ipinapakita. Kaya isang malaking titik A ay tumutugon sa isang ASCII na halaga ng 65 at isang lowercase isang to isang ASCII na halaga ng 97. 

Huwag mag-atubiling upang tumingin up anumang ASCII chart online upang makita ang mga halagang ito para sa iyong sarili. Kaya kung ano ang ibig sabihin nito ay na maaari naming gawin ang mga katangian ng mga malaking titik A, idagdag ang integer dalawang sa mga ito, at pagkatapos ay kumuha ang character upper case C bilang isang resulta. Iyon ay dahil sa 65, ang ASCII halaga para sa capital A, plus 2, ay nagbibigay sa amin ng 67, na tumutugon ang karakter ni upper case C. 

Sa kasamaang palad, ang mga bagay Hindi maa-lubos kaya simple. Mayroon kaming isang equation na mayroon kaming upang isaalang-alang. Narito ito ay nagsasabi sa amin na ang ith ciphertext sulat ay tumutugon sa ith plaintext sulat, kasama ang key-- lahat ng iyon, modular 26. Bakit na ang kaso? Natin bumalik sa aming halimbawa mula bago, kung saan capital A, plus 2, ay nagbibigay sa amin capital C. 

Kaya nag-aaplay ang equation na ang pagtutukoy ay nagbibigay sa amin, pagkatapos ay ipaalam sa tumagal ng capital A plus 2 at mod na sa pamamagitan ng 26. Kaya capital A, kapag ko bang ilagay ito sa mga single quotation marks, ay nagbibigay-daan sa akin upang gamutin ito bilang isang integer, kaya na nagpapahintulot sa ako na palabasin sa kanyang ASCII halaga, 65. 65 plus 2 ay 67. 67 mod 26 ay nagbibigay sa amin 15, ngunit na ay hindi tunay magkaroon ng kahulugan dahil alam namin na ang capital halaga ng C ASCII ay 67, hindi 15. Kaya paano namin mapagkasundo iyon? 

Well, dito Gusto kong ipagpalagay ang kuru-kuro ng isang alpabetikong index. Kaya ko na usapan natin ang tungkol sa kung paano bawat karakter ay may ASCII halaga, ngunit gusto kong sabihin, well, sabihin isipin ang tungkol sa bawat karakter din sa pagkakaroon ng isang alpabetikong index, kung saan ang A halimbawa, bilang ang unang titik ng alpabeto, ay may isang alpabetikong index ng zero. Kaya ngayon sabihin ilapat ang parehong equation tulad ng dati, ngunit ang paggamit ng isang alpabetikong index. 

So A ay zero, bilang ko na tinukoy namin. Kaya pagkatapos ay ang pagkuha zero plus dalawa, mod 26, na dalawa, mod 26, na nagbibigay sa amin dalawa. At na rin, sa mga tuntunin ng isang alpabetikong index, C ay ang ikatlong titik sa alpabeto, kaya na tumutugma sa isang alpabetikong index ng dalawa. Kaya ito tila na ang paggamit ng alpabetikong index sa kasong ito aktwal na nagbibigay sa amin ng tamang resulta. 

Kaya ngayon sabihin suriin upang makita kung ang mga gawa equation may isang alpabetikong index. alpabetikong index ni Y ay 24 bilang ang pangalawa sa huling titik sa alpabeto. Kaya nga 24 plus ang aming key ng dalawang ay nagbibigay sa amin 26. 26 mod 26 ay nagbibigay sa amin 0, kung saan, masuwerteng para sa sa amin, ay ang alpabetikong index para A. Kaya sana iyon ang sapat na patunay na ang alpabetikong index paraan gumagana. Kung hindi, huwag mag-atubiling upang subukan ang ilang mga halimbawa ng iyong sariling grupo. 

Upang maayos na wrapper sa paligid ng alpabeto at ilapat ang Caesar equation, pagkatapos ay alam namin na kailangan namin upang pakikitungo sa alpabetikong indeks. Ngunit simulan namin na may ASCII mga halaga, at lamang pagkatapos ay namin pagkatapos ay i-convert sa ang alpabetikong index. Mula doon, sa pagkakasunud-sunod upang i-print, kailangan namin upang harapin ang mga halaga ASCII muli. Kaya kailangan namin upang malaman kung paano upang pumunta mula sa ascii sa abakada at mula sa alpabetikong sa ASCII. 

Kaya mag-iwan ko ito sa iyo upang malaman kung ang pattern sa pagitan ng isang character at ang kanyang pang-abakada index at ang ASCII halaga. Ngayon, tandaan na kahit na talahanayan na ito mismo sa slide ay nagpapakita ng mga malalaking titik, kami din kailangang isaalang-alang kung o hindi isang iba't ibang mga pattern nalalapat para sa mas mababang mga letra kaso. 

Kaya ngayon na may korte out namin kung paano upang ilipat ang isang solong character, at pagkatapos ang lahat ng mayroon kaming gawin ay scale na hanggang sa pumunta sa buong plaintext. Kaya ang plaintext ay isang string. Lucky para sa amin, ang isang string ay talagang lamang ng isang array ng mga character, kaya upang ma-access ang bawat karakter ng isang string, ang kailangan mo lang gawin ay ang paggamit ng array pagtatanda. Say Mayroon akong isang variable ng uri string na tinatawag na "text = 'ito ay CS50.'" 

Well, pagkatapos, upang ma-access ang bawat karakter, lahat ng kailangan kong gawin sa ang mga variable na teksto ay sabihin na rin, text sa index zero, na tumutugon sa capital T. Text sa index isa ay tumutugon sa lower case h. Ang isa pang kapaki-pakinabang na function ay ang haba ng string function. Kaya pagpasa sa isang string sa na function ay babalik isang integer, ang haba ng na string. 

Ngayon na namin ang uusapang tungkol ang lahat ng mga iba't ibang mga elemento, sabihin ilagay ang mga ito pabalik sama-sama. Kaya bumalik sa alinman sa aking pseudocode code o ang iyong pseudocode at pumunta sa pamamagitan at siguraduhin na ikaw alam kung paano gawin ang bawat solong bagay. Getting ang key gamit argc at argv, pag-on ang key na ito sa isang integer, isang upang i, pagdikta para plaintext, getstring, at pagkatapos ay iterating sa paglipas ng bawat karakter sa plaintext string, pagpepreserba ang kaso ng bawat karakter at paglilipat na character sa pamamagitan ng ang susi, pagtiyak na ikaw ay pambalot sa paligid ng alpabeto, sa wakas pag-print na ciphertext. Ang pangalan ko ay Amila, at ito ay Caesar. 