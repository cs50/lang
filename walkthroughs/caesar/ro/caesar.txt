Amila: Să abordeze Caesar. În Caesar, permitem utilizatorului pentru a codifica un mesaj secret. Așa că hai să se arunca cu capul în dreapta și uite la noastre la-DOS pentru această problemă. Așa că în primul rând, vom obține cheia de la utilizator. Apoi vom obține plaintext- că ei doresc să codifica. După aceea, l-am cifrare pentru ei, și în final vom imprima lor ciphertext. 

Să începem cu un exemplu. Spuneți că ați vrut să codeze întregul alfabet, cu o cheie de două. Ei bine, întregul alfabet ar pur și simplu să fie mutat la litere. Deci, o s-ar codifica la C, B D, C și E, așa mai departe și așa mai departe, până când ajunge la X, care codifică la Z sau zed, în funcție de unde ești. Y ar trece apoi tot drumul, se înfășoare în jurul alfabetului pentru a ajunge la A, și apoi în cele din urmă ultima literă a alfabet, Z, Zed, s-ar codifica B. 

Ai înțeles? Să ne uităm la câteva exemple. Primul exemplu aici este foarte asemănătoare la ceea ce tocmai am explicat mai sus. Deci, dacă am codifica unele secțiune din STI alfabet, A prin L, printr-o cheie de două, apoi am obține doar întreaga mea alfabet mutat două litere. 

Apoi, în următorul meu exemplu, cheia este încă două, astfel încât ar trebui să știi încă care literele să se aștepte. Dar, aici este o frază. Acest lucru este CS50. Așa că veți observa că am păstreze cazul scrisorilor mele, astfel încât orice litere mari sunt, de asemenea, litere majuscule în textul cifrat. Și orice literă mică litere în plaintext- De asemenea, sunt litere mici litere în textul cifrat. Dar, am păstra scrisorile și orice alte semne de exclamare sau orice alte semne de punctuație la fel. 

Deci, acum că avem un sens pentru modul în care funcționează programul, se simt liber pentru a merge rula unele mai multe exemple de propriul dvs., dacă doriți. Să începem cu obținerea cheia de la utilizator. În mod tradițional, cu alte probleme, ne-am fost obișnuiți să obtinerea orice numere pe care le au nevoie de fapt care ia determinat utilizatorul cu getint funcția. Dar de data asta vom merge de fapt să folosească argumentul liniei de comandă și o nouă funcție numită atoi. 

Când executați principal Programul în C, apoi ia în două parameters-- int argc, care este numărul de argumente a trecut în, și apoi argv, o serie de siruri de caractere, care conține lista tuturor argumentelor a trecut. Nu aveți în mod explicit să declare aceste variabile. Sunt calculate pentru tu de compilator. Utilizarea corectă pentru acest lucru ar fi pentru argc să fie două în acest caz, deoarece utilizatorul trebuie să treacă în apelul la program, ./caesar, și apoi tasta, indiferent de numărul pe care doresc. Deci asta înseamnă că argc trebuie să fie de două în vederea unei utilizări valabilă a lui Cezar să fie executat. 

Așa că hai să ne uităm la un exemplu. Spune deja am scris și compilat un program numit blastoff. Deci, dacă am fugit în linia de comandă ./blastoff Rocket Team, ei bine, atunci, argc ar fi trei pentru că eu a trecut în trei argumente distincte. Apoi argv ar arăta așa. Este o matrice, și ar conțin fiecare dintre cele trei șiruri. ./blastoff în primul indice, echipa în următoarea, și racheta în ultima. 

Hai să vorbim despre tablouri pentru o secundă. Vectorii sunt structuri de date care dețin mai multe valori de același tip. Acest lucru poate veni la îndemână atunci când ne au liste de întregi sau siruri de caractere. Doar amintiți-vă că au să fie de același tip. În informatică, noi dragoste de numărare de la zero, astfel încât nu uitați că tablouri sunt de asemenea zero indexate. Deci, primul element al matrice mele va fi la indexul zero. Deci, în acest caz, atunci când am o matrice de lungime de patru, apoi ultimul index al ultimul element al meu matrice este, de fapt va fi la indexul trei, nu patru. Pentru că amintiți-vă, noi începe numărarea de la zero. 

Iată un exemplu de cum s-ar putea crea o serie de dumneavoastră. Așa că spun că am vrut să păstrez trei nume de câine favorit. Apoi, aș crea o serie de șiruri. Deci, aș declara tipul, șirul, și apoi a pus numele de matrice, câini, și apoi în cele pătrat paranteze a pus dimensiunea din array-- în acest caz, trei. 

Așa că prima mea intrare se întâmplă să fie câini, la indicele de la zero, și că va fi Milo. Apoi, câini, la indexul unu va fi Goofy, dragă Mochi, și apoi ultimul intrare, a treia intrare la indexul doi, va fi dragut, dulce Elphie. Vei observa că formatul Pentru completarea acestei matrice este foarte mult ca modul în care s-ar putea să declare orice altă variabilă în cazul în care aveți numele variabilei urmat de valoarea pe care doriți să le stocați în ea. Singura diferență în acest caz este că trebuie să-și amintească de a pune indicele din valoarea între paranteze drepte. Și acolo avem noastră trei câini favorit. 

Dar, din păcate, este timpul pentru a ajunge înapoi la Cezar. Nu uitați că utilizarea corectă pentru utilizator va fi în mod nu numai numele ./caesar programului, dar De asemenea, cheia pe care doresc să schimbe plaintext lor de către. Deci asta înseamnă că argc trebuie să fie doi. Ei trebuie să treacă în two-- nici mai mult, nici mai puțin de două argumente în linia de comandă. 

Acum, ce zici de argv? Ei bine, știm deja că matrice va fi de lungime doi, dar ceea ce se află în fiecare element? Ei bine, primul element va fi ./caesar, iar apoi elementul următor va conțin cheia pe care utilizatorul tastat. Acum, în cazul în care au folosit-o corect pentru utilizarea Cezarului, atunci ei vor introduce într-un număr. Dar, chiar dacă caracterul că ei tip este un număr, este de tipul de date șir. 

Deci, cum putem converti că string la un număr întreg? Deci, spun că am num, un șir de caractere, care conține șirul de 50 de ani. Dacă vreau să convertiți că la un număr întreg, atunci pur și simplu declară o nouă variabilă, o număr întreg i, de asteptare atoi. Eu trec în variabila mea șir de caractere, num, și atunci i se va conține apoi numărul 50. Asigurați-vă că pentru a verifica omul pagini pentru funcția atoi pentru a verifica care biblioteca este în, precum și ce valoare va reveni în cazul în care șirul trecut în nu conține toate numerele. 

Deci, acum că am ajuns cheia, următorul pas este de a obtine plaintext- de utilizator. Acum, acest lucru se va să fie mai puțin complicată decât navigarea în jurul valorii de argumente în linia de comandă. Tot ce trebuie să facem este apel funcția getstring pentru a solicita utilizatorului pentru a da ne un șir de caractere, dar nu uitați pentru a verifica specificațiile pentru modul în care am ar putea dori să solicite utilizatorului pentru acest lucru. 

Acum am ajuns la Inima problem-- cum să cifrare plaintext-. Ei bine, în primul rând, să vorbim despre modul în care la cifrare un caracter la un moment dat, și apoi vom aborda modul în care să itera pe întreaga plaintext-. Am scris niște pseudocod pentru problema Caesar. Vă încurajez să scrie opinia ta. S-ar putea să nu se uite identic cu a mea, și asta e în regulă, dar atâta timp ca idee generală este aceeași. 

Primii trei pași Deja am făcut. Am primit cheia de la argumentul liniei de comandă, ne-am transformat acea cheie într-un întreg, și ne-am a determinat utilizatorul pentru plaintext că ei doresc să cifrare. Așa că, atunci următoarea bucată mare este faptul că pentru fiecare caracter în șirul plaintext, dacă este în ordine alfabetică, dorim să păstrăm cazul său și-l schimbe. Prin păstrarea caz, ceea ce Adică este că toate cazurile de sus scrisori ar trebui să rămână superioară caz și toate literele minuscule ar trebui să rămână cu litere mici. Așa că, atunci după ce trecem de aceste, apoi vom imprima ciphertext. 

Aici sunt trei funcții care se întâmplă să vină la îndemână pentru această problemă. Amintiți-vă în sus de mai sus, când i-am dat exemplu pentru deplasarea este CS50? Amintiți-vă că 50, precum și semn de exclamare nu schimbare? Deci, cum putem spune dacă ne au nevoie pentru a schimba o literă sau nu? Ei bine, "este alfa", în cazul în care ai un caracter treci, se va întoarce adevărat dacă acel caracter este o literă și false în caz contrar. Pentru a vă ajuta cu păstrând capitalizarea sunt funcțiile "este superior "și" este mai mic. " 

Aceste două funcții, de asemenea, să ia într-un singur caracter ca intrare și returnați un boolean, fie adevărat sau fals în funcție de faptul dacă acel caracter este majuscule sau minuscule. Deoarece "este superior" și "este inferior "sunt funcții booleene, ceea ce înseamnă că ei te întorci Boolean, vă puteți utiliza în condițiile dumneavoastră. Deci, aici este un fragment de cod care numai imprimă o literă, dacă este cazul în sus. Așa că am declarat caracterul meu scrisoare care urmează să fie cazul superior zed și apoi, dacă "este superioară" se întoarce adevărat, atunci am imprima acea scrisoare. 

Să ne întoarcem la exemplul nostru simplu de deplasarea alfabetului printr-o cheie de două, cum putem obține de fapt, că la locul de muncă? Ei bine, se pare că de caractere și numere întregi sunt foarte strâns legate. Fiecare personaj are un valoare întreagă asociată cu ea a găsit în diagramă ASCII, în cazul în care ASCII fiecărui caracter Este afișată o valoare. Astfel încât un caz superior corespunde A la o valoare ASCII de 65 de ani și literele mici de la o valoare ASCII 97. 

Simțiți-vă liber să se uite în sus orice ASCII diagramă on-line pentru a vedea aceste valori pentru tine. Deci, ce înseamnă acest lucru este că putem să ia caracterul de caz superior A, se adaugă un întreg doi să-l, și apoi obține caracterul superior caz C, ca rezultat. Asta pentru 65 de ani, ASCII Valoarea pentru capitalul A, plus 2, ne dă 67, ceea ce corespunde la caracterul superior caz C. 

Din păcate, lucrurile nu va fi destul de atât de simplu. Avem o ecuație trebuie să ia în considerare. Aici ne spune că i-lea ciphertext scrisoare corespunde cu plaintext- i-lea scrisoare, plus key-- toate acestea, modulare 26. De ce este că acest caz? Să ne întoarcem la exemplul nostru de la înainte, în cazul în care capitalul A, plus 2, ne dă de capital C. 

Deci, aplicând ecuația care caietul de sarcini ne dă, apoi să ia de capital A plus 2 și mod care până la 26. Așa că de capital A, atunci când am pus-o în aceste simple ghilimele, îmi permite să-l trateze ca un număr întreg, astfel încât permite mi să-l arunce la valoarea sa ASCII, 65 de ani. 65 plus 2 este de 67. 67 mod 26 ne dă 15, dar asta nu prea sens pentru că noi știm că Capital C Valoarea ASCII este de 67, nu 15. Deci, cum putem împăca asta? 

Ei bine, aici aș vrea să postulează Noțiunea de un index alfabetic. Prin urmare, am discutat deja despre modul în care fiecare caracter are valoarea ASCII, dar aș vrea să spun, bine, hai gândiți-vă fiecare personaj, de asemenea, având în un index alfabetic, unde A, de exemplu, ca prima literă a alfabetului, are un indice alfabetic de la zero. Așa că acum să aplicați aceeași ecuație ca și mai înainte, dar utilizând un index alfabetic. 

Așa că A este zero, așa cum ne-am definit. Așa că luând apoi la zero, plus două, mod 26, care este de două, mod 26, care ne dă două. Și bine, în ceea ce privește un index alfabetic, C este a treia literă în alfabet, astfel încât să corespundă la un index alfabetic de două. Deci, se pare că utilizarea index alfabetic în acest caz de fapt, ne dă rezultatul corect. 

Așa că acum să verificați a se vedea dacă funcționează ecuatia cu un index alfabetic. indexul alfabetic Y este 24 sub numele de în al doilea rând la ultima literă din alfabet. Așa că, atunci 24 plus nostru cheie a doi ne dă 26. 26 mod 26 ne oferă 0, care, norocos pentru ne, este indexul alfabetic A. Deci sperăm că e suficient ca dovada metoda de index alfabetic funcționează. În cazul în care nu, nu ezitați să încercați câteva exemple proprii. 

Pentru a se încadra în mod corespunzător în jurul valorii de alfabet și se aplică ecuația Cezar, atunci știm că avem nevoie să face cu indici alfabetice. Dar noi începem cu ASCII valori, și numai atunci putem apoi converti la indexul alfabetic. De acolo, pentru a imprima, avem nevoie pentru a face față cu valorile ASCII din nou. Așa că trebuie să ne dăm seama cum să du-te din ASCII în alfabetic și din alfabetic în ASCII. 

Așa că am să vă las să dau seama modelul între un caracter și în ordine alfabetică sale indexul și valoarea ASCII. Acum, amintiți-vă că, chiar dacă acest drept tabel pe diapozitiv arată literele mari, noi, de asemenea, trebuie să ia în considerare dacă este sau nu aplică un model diferit pentru inferioare caracterelor. 

Deci, acum că ne-am dat seama cum să se deplaseze un singur caracter, atunci tot ce trebuie să facem este scara care până la traversa întreaga plaintext-. Asa ca plaintext- este un șir de caractere. Din fericire pentru noi, un șir de caractere este într-adevăr doar o serie de caractere, astfel încât, în scopul de a avea acces la fiecare caracter dintr-un șir de caractere, tot ce trebuie să faci este de a folosi notația matrice. Spune că am o variabilă de tip șir de caractere numit "text = 'e CS50.'" 

Ei bine, atunci, pentru a acces la fiecare caracter, tot ce trebuie să fac cu textul este variabila să spun bine, textul de la zero, indicele, că corespunde T. de capital text la indexul una corespunde cu litere mici h. O altă funcție utilă este funcția de lungime șir. Așa că trece într-un șir de caractere pentru a această funcție se va întoarce un număr întreg, lungimea acelui șir. 

Acum, că am vorbit despre toate aceste elemente diferite, Să le punem înapoi împreună. Așa că a reveni la fie pseudocod meu cod sau pseudocod tau și du-te prin intermediul și asigurați-vă că știu cum să facă fiecare lucru. Obtinerea cheii folosind argc și argv, rotirea cheii într-un întreg, o la i, fapt care ia determinat pentru plaintext, getstring, și apoi iterarea peste fiecare personaj șirul plaintext, păstrând cazul fiecărui caracter și deplasarea acel caracter de cheie, asigurându-se că sunteți în jurul valorii de ambalaj din alfabet, imprimarea în cele din urmă că ciphertext. Numele meu este Amila, iar acest lucru a fost Cezar. 