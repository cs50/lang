AMILA: Kom ons pak die keiser. In die keiser, laat ons die gebruiker om 'n geheime boodskap enkodeer. So laat ons spring sommer weg en kyk by ons aan-dos vir hierdie probleem. So die eerste, kry ons die sleutel van die gebruiker. Dan kry ons die skoonteks dat hulle wil enkodeer. Daarna het versleutelen ons dit vir hulle, en uiteindelik druk ons ​​hul kriptoteks. 

So laat ons begin met 'n voorbeeld. Sê jy wou die enkodeer hele alfabet met 'n sleutel van twee. Wel, jou hele alfabet sou net verskuif word na briewe. So 'n wil enkodeer na C, B om D, C tot E, so aan en so voort, totdat jy X, wat kodeer tot Z of Zed, afhangende van waar jy vandaan kom. Dan sou Y dan skuif al die pad, draai om die alfabet te A te kry, en dan uiteindelik die laaste letter van die alfabet, Z, Zed, sal enkodeer na B. 

Jy het dit? Kom ons kyk na 'n paar voorbeelde. Die eerste voorbeeld hier is baie soortgelyk wat ons net bo verduidelik. So as ek enkodeer paar deel van die alfabet, 'n deur L, deur 'n sleutel van twee, dan kry ek net my hele alfabet verskuif twee briewe. 

Dan, in my volgende voorbeeld, die sleutel is nog twee, sodat jy moet nog steeds weet wat briewe om te verwag. Maar hier is dit 'n frase. Dit is CS50. So jy sal sien dat ek die behoud van die geval van my briewe, sodat geen hoofletters is ook hoofletters in die kriptoteks. En enige klein briewe in die skoonteks word ook kleinletters briewe in die kriptoteks. Maar ek hou die letters en enige uitroeptekens of enige ander leestekens dieselfde. 

So nou dat ons 'n sin hoe die program werk, voel vry om te gaan hardloop 'n paar meer voorbeelde van jou eie, as jy wil. Kom ons begin met die kry die sleutel van die gebruiker. Tradisioneel, met ander probleme, ons het is gewoond aan om enige nommers wat ons moet deur waarna die gebruiker met die funksie getint. Maar hierdie keer is ons eintlik gaan om die command line argument gebruik en 'n nuwe funksie genoem atoi. 

Wanneer jy die belangrikste hardloop program in C, dan is dit neem op twee parameters-- int argc, wat is die aantal argumente geslaag, en dan argv, 'n verskeidenheid van snare wat bevat die lys van al die argumente geslaag. Jy hoef nie uitdruklik het om hierdie veranderlikes te verklaar. Hulle is bereken vir jy deur die samesteller. Korrekte gebruik vir hierdie sou wees vir argc twee wees in hierdie geval, want die gebruiker het om te slaag in die oproep tot die program, ./caesar, en dan die sleutel, ongeag aantal wat hulle wil. So dit beteken dat argc moet twee ten einde vir 'n geldige gebruik van die keiser wat uitgevoer moet word. 

So kom ons kyk na 'n voorbeeld. Sê Ek het reeds 'n skrywe en saamgestel 'n program genaamd blastoff. So as ek hardloop in die command line ./blastoff Team Rocket, wel, dan, argc sou drie wees, want ek geslaag in drie afsonderlike argumente. Dan argv sou lyk. Dit is 'n skikking, en dit sou bevat elk van die drie stringe. ./blastoff in die eerste indeks, span in die volgende, en vuurpyl in die laaste. 

Kom ons praat oor skikkings vir 'n sekonde. Skikkings is datastrukture wat hou verskeie waardes van dieselfde soort. Dit kan handig te pas kom wanneer ons het lyste van heelgetalle of snare. Onthou net hulle om dieselfde soort wees. In rekenaarwetenskap, ons lief tel van nul, so onthou dat skikkings is ook nul-geïndekseer. Dus is die eerste element van my reeks gaan wees by indeks nul. So in hierdie geval, as ek 'n verskeidenheid van lengte vier, dan is die laaste indeks van die laaste element van my reeks is eintlik gaan wees by indeks drie, nie vier. Want onthou, ons begin tel op nul. 

Hier is 'n voorbeeld van hoe jy kan 'n verskeidenheid van jou eie te skep. So sê Ek wou slaan my drie gunsteling hond name. Dan sou ek 'n verskeidenheid van snare skep. So sou ek die tipe, string te kenne gee en sit dan die naam van die skikking, honde, en dan in die vierkant hakies sit die grootte van die array-- in hierdie geval, drie. 

So my eerste inskrywing gaan honde by indeks nul, en wat gaan Milo wees. Dan honde indeks een gaan stom te wees, Darling Mochi, en dan die laaste inskrywing, die derde ingang by indeks twee, gaan oulike, soet Elphie wees. Jy sal sien dat die formaat vir die invul van hierdie reeks is baie soos hoe jy dalk verklaar enige ander veranderlike waar jy het die veranderlike naam gevolg deur die waarde wat jy wil bewaar in dit. Die enigste verskil in hierdie geval is dat jy moet onthou om die indeks te sit van die waarde in vierkantige hakies. En daar het ons ons drie gunsteling honde. 

Maar helaas, dit is tyd om terug aan die keiser te kry. Onthou dat korrekte gebruik vir die gebruiker gaan aanstuur in nie net die naam van die program ./caesar, maar ook die sleutel wat hulle wil om te skuif hul skoonteks deur. So dit beteken dat argc twee moet wees. Hulle moet slaag in two-- nie meer nie, geen minder as twee command line argumente. 

Nou, wat van argv? Wel, ons weet reeds dat die verskeidenheid gaan lengte twee te wees, maar wat in elke element? Wel, die eerste element gaan ./caesar te wees, en dan die volgende element gaan bevat die sleutel wat die gebruiker ingetik. Nou, as hulle gebruik dit korrek vir die gebruik van die keiser, dan gaan hulle in te tik 'n nommer. Maar selfs al is die karakter dat hulle tik is 'n nommer, dis van datatipe string. 

So hoe kan ons skakel dit string na 'n heelgetal? So sê Ek het NUM, 'n string, met die string 50. As ek wil om te sit wat om 'n heelgetal is, dan het ek net verklaar 'n nuwe veranderlike, 'n heel getal Ek roep atoi. Ek slaag in my stringveranderlike, NUM, en dan sal Ek dan bevat die getal 50. Maak seker dat jy die man kyk bladsye vir die atoi funksie om seker te maak wat biblioteek dis in, asook watter nut dit sal terugkeer as die string geslaag in nie al die syfers bevat. 

So nou dat ons gekry die sleutel, is die volgende stap is om die skoonteks van die gebruiker te kry. Nou, dit gaan minder ingewikkeld as opgevolg rondom die command line argumente. Al wat ons moet doen is bel die getstring funksie aan die gebruiker gevra om op te gee ons 'n string, maar onthou die spesifikasies vir hoe gaan ons dalk wil die gebruiker vir daardie vinnige. 

Nou kom ons by die hart van die problem-- hoe om die skoonteks versleutelen. Wel, in die eerste, kom ons praat oor hoe om een ​​karakter versleutelen op 'n tyd, en dan sal ons aan te spreek hoe om Itereer oor die hele plat. Ek het 'n paar pseudokode geskryf vir die keiser probleem. Ek wil u aanmoedig om skryf jou eie sowel. Dit mag dalk nie identies te kyk myne, en dit is OK, maar solank as die algemene idee is dieselfde. 

Die eerste drie stappe Ons het reeds gedoen. Ons het die sleutel van gekry die command line argument, Ons het omgedraai dat die sleutel in 'n heelgetal, en ons het daartoe gelei dat die gebruiker vir die skoonteks dat hulle wil omzetten. So dan is die volgende groot stuk is dat vir elke karakter in die skoonteks string, As dit is alfabetiese, ons wil bewaar sy saak en skuif dit. Deur te bewaar geval, wat ek beteken is dat alle hoofletters briewe moet boonste bly geval en klein letters moet klein bly. So dan na ons skuif diegene dan druk ons ​​die kriptoteks. 

Hier is drie funksies wat gaan om handig te pas kom vir hierdie probleem. Onthou bo toe ek het die voorbeeld vir die verskuiwing van hierdie is CS50? Onthou dat die 50 en die uitroepteken nie skuif? So, hoe kan ons weet of ons moet 'n brief te skuif of nie? Wel, "is Alpha" As jy slaag dit 'n karakter, sal terugkeer waar as wat karakter is 'n brief en valse anders. Om jou te help met die behoud van hoofletters is die funksies "is boonste "en" laer. " 

Hierdie twee funksies te neem ook in 'n enkele karakter as insette en terug te keer jy 'n Boole, waar of vals afhangende van of daardie karakter is hoofletters of kleinletters. Omdat "is bo" en "is laer "is Boole funksies, wat beteken dat hulle moet terugkeer jy 'n Boole, jy kan dit gebruik in jou omstandighede. So hier is 'n kode uit dat slegs druk 'n brief as dit hoofletters. So ek het my karakter verklaar brief word die hoofletters Zed en dan as "is bo" opbrengste waar is, dan druk ek die brief. 

Gaan terug na ons eenvoudige voorbeeld van verskuiwing van die alfabet met 'n sleutel van twee, hoe kan ons eintlik kry dat om te werk? Wel, dit blyk dat karakters en heelgetalle is baie nou verwant. Elke karakter het 'n heelgetal waarde wat verband hou daarmee gevind in die ASCII tabel, waar ASCII elke karakter se waarde vertoon. So 'n hoofletter A ooreenstem 'n ASCII-waarde van 65 en 'n klein 'n te 'n ASCII-waarde van 97. 

Voel vry om op te kyk enige ASCII grafiek aanlyn om hierdie waardes te sien vir jouself. So, wat dit beteken is dat ons kan neem die karakter van hoofletters A, voeg die heelgetal twee om dit, en dan kry die karakter hoofletters C as gevolg daarvan. Dit is omdat 65, die ASCII waarde vir kapitale A, plus 2, gee ons 67, wat ooreenstem om die karakter van hoofletters C. 

Ongelukkig dinge sal nie heeltemal so eenvoudig nie. Ons het 'n vergelyking wat ons het om te oorweeg. Hier is dit sê vir ons dat die et kriptoteks brief ooreenstem met die et skoonteks brief, plus die key-- al wat, modulêre 26. Hoekom is dit die geval? Kom ons gaan terug na ons voorbeeld van voor, waar kapitaal A, plus 2, gee ons kapitaal C. 

So toepassing van die vergelyking wat die spesifikasie gee ons, dan laat ons kapitaal A plus 2 en mod wat deur 26. So kapitaal A, toe ek sit dit in diegene enkele aanhalingstekens, laat my toe om dit te hanteer as 'n heelgetal, sodat toelaat my te gooi om sy ASCII waarde, 65. 65 plus 2 is 67. 67 mod 26 gee vir ons 15, Maar dit beteken nie regtig maak sin, want ons dat die ken kapitaal C ASCII waarde is 67, nie 15. So hoe kan ons versoen nie? 

Wel, hier Ek wil graag die postuleer idee van 'n alfabetiese indeks. So het ons reeds gepraat oor hoe elke karakter het sy ASCII waarde, maar ek wil sê, goed, kom ons dink oor elke karakter het ook ' 'n alfabetiese indeks, waar A byvoorbeeld as die eerste letter van die alfabet, 'n alfabetiese indeks van nul. So nou kom ons pas die Dieselfde vergelyking soos voorheen, maar met behulp van 'n alfabetiese indeks. 

So 'n nul is, soos ons gedefinieer. So dan neem nul plus twee, mod 26, dit is twee, mod 26, wat ons gee twee. En ook, in terme van 'n alfabetiese indeks, C is die derde brief in die alfabet, sodat sou ooreenstem om 'n alfabetiese indeks van twee. So dit blyk dat die gebruik van die alfabetiese indeks in hierdie geval eintlik gee ons die korrekte resultaat. 

So nou kom ons kyk na kyk of die vergelyking werke met 'n alfabetiese indeks. alfabetiese indeks Y se 24 as die tweede laaste brief in die alfabet. So dan 24 plus ons sleutel van twee gee ons 26. 26 mod 26 gee vir ons 0, wat, gelukkig vir ons is die alfabetiese indeks vir A. So hopelik dit is genoeg bewys dat die alfabetiese indeks metode werk. Indien nie, voel vry om te probeer 'n paar voorbeelde van jou eie. 

Ten einde behoorlik te draai rondom die alfabet en die toepassing van die keiser vergelyking, dan weet ons dat ons nodig het om te hanteer alfabetiese indekse. Maar ons begin met ASCII waardes, en dan eers ons dan te skakel na die alfabetiese indeks. Van daar, ten einde te druk, moet ons weer te gaan met die ASCII waardes. Daarom moet ons om uit te vind hoe om gaan van ASCII te alfabeties en uit alfabetiese om ASCII. 

So ek laat dit aan jou om uit te vind die patroon tussen 'n karakter en sy alfabetiese indeks en sy ASCII waarde. Nou, onthou dat selfs al hierdie tabel regs op die skyfie toon die hoofletters, ons ook moet oorweeg of 'n ander patroon van toepassing vir die klein letters. 

So nou dat ons het uitgepluis het hoe om 'n enkele karakter te skuif, dan sal al wat ons moet doen is skaal wat up om te gaan oor die hele plat. So het die skoonteks is 'n string. Gelukkig vir ons, 'n string is regtig net 'n verskeidenheid van karakters, so ten einde toegang tot elke karakter van 'n string, al wat jy hoef te doen is om verskeidenheid notasie gebruik. Sê Ek het 'n veranderlike van tipe string met die naam "text = 'hierdie is CS50." 

Wel, dan, ten einde toegang elke karakter, al wat ek hoef te doen met die veranderlike teks is om goed te sê, teks indeks nul, wat ooreenstem met kapitaal T. teks op indeks een stem ooreen met die laer geval h. Nog 'n nuttige funksie is die string lengte funksie. So verby in 'n tou aan daardie funksie sal terugkeer 'n heelgetal, die lengte van die string. 

Noudat ons het gepraat oor al hierdie verskillende elemente, Kom ons sit dit terug saam. So terug te keer na óf my pseudokode -kode of jou pseudokode en gaan deur en maak seker dat jy weet hoe om elke enkele ding te doen. Aan die sleutel met behulp argc en argv, draai die sleutel tot 'n heelgetal is, 'n om i, waarna vir skoonteks, getstring, en dan iterating oor elke karakter in die skoonteks string, die behoud van die geval van elke karakter en die verskuiwing van daardie karakter deur die sleutel, seker te maak dat jy wikkel om die alfabet, uiteindelik druk wat kriptoteks. My naam is Amila, en dit was die keiser. 