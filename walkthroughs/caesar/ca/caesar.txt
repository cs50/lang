Amila: Anem a fer front a César. En César, permetem que l'usuari per codificar un missatge secret. Així que anem a bussejar en dret i mirar en les nostres tasques pendents per aquest problema. Així que, primer, s'obté la clau de l'usuari. Llavors vam aconseguir el text pla que volen codificar. Després d'això, es xifren per a ells, i, finalment, és la impressió del seu text xifrat. 

Així que començarem amb un exemple. Digues que vols codificar el tota alfabet amb una clau de dos. Bé, tot l'alfabet faria acaba de ser desplaçat a les cartes. Així que seria una codificar a C, B D, C i E, així successivament i així successivament, fins a arribar a X, que codifica a la Z o zeta, depenent d'on ets. Llavors I llavors canviar tot el camí, embolicar al voltant de l'alfabet per arribar a A, i, finalment, l'última lletra de la alfabet, Z, zeta, codificaria a B. 

En això tens? Vegem alguns exemples. El primer exemple és molt similar al que s'acaba d'explicar. Així que si puc codificar alguna secció del alfabet, A a L, per una clau de dos, llavors almenys ficar tota alfabet va canviar dues cartes. 

Llavors, al meu següent exemple, la clau segueix sent dos, de manera que encara ha de saber que les lletres a esperar. Però aquí es tracta d'una frase. Això és CS50. Així s'adonarà que jo preservar el cas de les meves cartes, pel que qualsevol lletres majúscules són també les lletres majúscules en el text xifrat. I qualsevol minúscules lletres en el text pla També s'escriuen en minúscula lletres en el text xifrat. Però guardo les lletres i qualsevol signe d'exclamació o qualsevol altre puntuació la mateixa. 

Així que ara que tenim un sentit per al funcionament del programa, no dubteu a anar córrer una mica més exemples de la seva pròpia, si ho desitja. Anem a començar amb aconseguir la clau de l'usuari. Tradicionalment, amb altres problemes, hem acostumat a aconseguir qualsevol nombre que ens necessita per preguntar a l'usuari amb la getInt funció. Però aquesta vegada estem realment va utilitzar l'argument de la línia d'ordres i una nova funció anomenada atoi. 

Quan s'executa el principal programa en C, llavors es presa en dos parameters-- int argc, que és el nombre d'arguments aprovada en, i després argv, una matriu de cadenes que conté la llista de tots els arguments passat. No cal que de forma explícita per declarar aquestes variables. Estan calculats per pel compilador. L'ús correcte per això seria per argc sigui dues en aquest cas, perquè l'usuari ha de passar a la crida al programa, ./caesar, i després la tecla, qualsevol que sigui el nombre que desitgin. Això vol dir que ha d'haver dos argc Perquè un ús vàlid de César per a ser executat. 

Així que anem a veure un exemple. Diguem que ja he escrit i compilat un programa anomenat enlairament. Així que si em vaig trobar en la línia d'ordres ./blastoff Equip Rocket, bé, llavors, argc serien tres, perquè jo aprovada en tres arguments diferents. Llavors argv es veuria així. És una matriu, i seria contenir cadascuna de les tres cadenes. ./blastoff en el primer índex, l'equip en el següent, i el coet en el passat. 

Anem a parlar sobre les matrius d'un segon. Les matrius són estructures de dades que mantenen diversos valors del mateix tipus. Això pot ser útil quan ens tenir llistes de nombres sencers o cadenes. Només recorda que tenen a ser del mateix tipus. En informàtica, ens amor a comptar des de zero, per tal de recordar que les matrius són també zero-indexada. Així que el primer element de la meva matriu serà en l'índex zero. Així doncs, en aquest cas, quan tinc una matriu de longitud 4, a continuació, l'últim índex de la últim element de la meva matriu és en realitat serà en l'índex de tres, no quatre. Perquè recorda, ens començarà a comptar des de zero. 

Heus aquí un exemple de com es podria crear una matriu de la seva compte. Així que dir que volia guardar el meu tres noms gos preferit. A continuació, m'agradaria crear una matriu de cadenes. Així que m'agradaria declarar el tipus, seqüència, i a continuació, posar el nom de la matriu, gossos, i després en els quadrats suports de posar la mida de la array-- en aquest cas, tres. 

Així que la meva primera entrada va per ser gossos en l'índex zero, i que va a ser Milo. A continuació, els gossos en l'índex 1 va a ser maldestre, Mochi estimada, i després l'última entrada, la tercera entrada en l'índex 2, va a ser valent, dolç Elphie. Es donarà compte de que el format per a l'ompliment en aquesta matriu és molt semblant a com es pot declarar qualsevol altra variable on vostè té el nom de la variable seguit de el valor que voleu emmagatzemar en ell. L'única diferència en aquest cas és que es Cal recordar que posar l'índex del valor entre claudàtors. I aquí tenim la nostra tres gossos favorits. 

Però, per desgràcia, és el moment per tornar a César. Recordeu que l'ús correcte de la usuari serà passant en no només el nom de la ./caesar programa, però També la clau que volen canviar el seu text pla per. Això vol dir que argc ha d'haver dos. Ells han de passar a dos-- ni més ni menys de dos arguments de línia de comandes. 

Ara, què passa amb argv? Bé, ja sabem que la matriu tindrà una longitud de dos, però el que està continguda en cada element? Bé, el primer element serà ./caesar, i després el següent element es va a contenir la clau que l'usuari va escriure. Ara, si s'utilitzen correctament per a l'ús de César, a continuació, van a escriure un nombre. Però tot i que el caràcter que tipus és un nombre, que és de tipus cadena de dades. 

Llavors, com convertir aquest cadena en un enter? Així que dir que tinc num, una cadena, que conté la cadena 50. Si vull convertir aquest a un sencer, llavors jo simplement declarar una nova variable, un enter i, cridant atoi. Jo pas en la meva variable de cadena, num, i llavors jo llavors contindrà el número 50. Assegureu-vos de revisar l'home pàgines per a la funció atoi per comprovar quina biblioteca és en, així com quin valor retornarà si la cadena va passar en no conté tots els nombres. 

Així que ara que hem aconseguit la clau, el següent pas és aconseguir que el text en clar per part de l'usuari. Ara, això va a ser menys complicat de navegar al voltant de la arguments de línia de comandes. Tot el que hem de fer és trucar la funció getString per demanar a l'usuari per donar som una cadena, però recorda per comprovar les especificacions de la forma en què pot ser que vulgui demanar a l'usuari per això. 

Ara arribem a la cor de la problema-- com xifrar el text en clar. Bé, en primer lloc, parlarem sobre com per xifrar un caràcter alhora, i després abordarem com iterar al llarg de tot el text en clar. He escrit alguns pseudocodi per al problema de César. Us animo a escriure la seva pròpia també. Podria no semblar idèntics la meva, i això està bé, però sempre com la idea general és la mateixa. 

Els primers tres passos que ja hem fet. Hem rebut la clau de l'argument de línia d'ordres, hem donat volta a aquesta tecla en un sencer, i hem se li demanarà que el text pla que volen xifrar. Així llavors el següent tros gran és que per a cada caràcter a la cadena de text clar, si és alfabètic, volem preservar el seu cas i el desplacen. Per preservar cas, el que volen dir és que tot en majúscules cartes han de seguir sent superior cas i totes les lletres minúscules ha de romandre en minúscules. Així que a continuació, després vam canviar aquells, a continuació, vam imprimir el text xifrat. 

Aquí hi ha tres funcions que es van a ser molt útil per a aquest problema. Recordeu dalt quan em va donar el exemple per al desplaçament d'aquest és CS50? Recordeu que el 50 i el signe d'exclamació no va canviar? Llavors, com podem saber si estem que hagi de canviar una lletra o no? Bé, "és alfa," si se li passa un personatge, retornarà veritable si aquest personatge és una carta i fals en cas contrari. Per ajudar amb capitalització de la preservació són les funcions "es superior "i" és menor ". 

Aquestes dues funcions també prenen en un sol personatge com a entrada i retornar un booleà, ja sigui vertadera o falsa depenent de si aquest caràcter en majúscula o minúscula. Perquè "és superior" i "és inferior "són funcions de Boole, el que significa que es retornen un booleà, pot utilitzar aquests en les seves condicions. Així que aquí està un fragment de codi que només imprimeix una carta si és majúscula. Així que he declarat el meu personatge carta a ser la caixa superior zed i després, si "és" retorns superiors veritat, llavors puc imprimir aquesta lletra. 

Tornant al nostre exemple simple de canviant l'alfabet per una clau de dos, ¿Com podem aconseguir que funcioni? Doncs bé, resulta que els caràcters i nombres enters estan molt estretament relacionats. Cada personatge té una valor sencer associat amb el trobat en la taula ASCII, on ASCII de cada caràcter Es mostra el valor. Pel que una caixa superior correspon una a un valor ASCII de 65 i una minúscula de un valor ASCII de 97. 

No dubti a consultar qualsevol gràfic ASCII en línia per veure aquests valors per si mateix. Així que el que això significa és que podem prendre el caràcter de majúscules A, afegir el número sencer de dos a ella, i després el caràcter superior cas C com a resultat. Això es deu a 65, l'ASCII valor per al capital A, més 2, ens dóna 67, que correspon al caràcter de la caixa superior C. 

Desafortunadament, les coses es no és tan senzill. Tenim una equació que hem de considerar. Aquí se'ns diu que el text xifrat ITH lletra correspon al text clar ITH carta, a més de la key-- tot això, modular 26. Per què és aquest el cas? Tornem al nostre exemple de abans, on el capital A, més 2, ens dóna el capital C. 

Així l'aplicació de l'equació que l'especificació ens dóna, a continuació, anem a fer majúscula més 2 i mod que en un 26. Així majúscula, quan ho poso en aquestes cometes simples, em permet tractar com un nombre sencer, de manera que permet la meva intenció de posar al seu valor ASCII, de 65 anys. 65 més 2 és 67. 67 mod 26 ens dóna 15, però que en realitat no es té sentit perquè sabem que la C majúscula valor ASCII és 67, no 15. Llavors, com podem reconciliar això? 

Bé, aquí m'agradaria plantejar la noció d'un índex alfabètic. Així que ja hem parlat de com cada personatge té el seu valor ASCII, però m'agradaria dir, bé, anem a pensar en cada personatge també té un índex alfabètic, en la qual A, per exemple, com la primera lletra de l'alfabet, té un índex alfabètic de zero. Així que ara anem a aplicar la mateixa equació que abans, però l'ús d'un índex alfabètic. 

Així que A és zero, ja que hem definit. Així que després de prendre zero més dos, mod 26, això és dues, mod 26, el que ens dóna dues. I així, en termes de un índex alfabètic, C és la tercera lletra en el alfabet, de manera que correspondria a un índex alfabètic de tots dos. Per tant, sembla que l'ús de la índex alfabètic en aquest cas en realitat ens dóna el resultat correcte. 

Així que ara anem a veure a veure si les obres d'equacions amb un índex alfabètic. índex alfabètic de I és com el 24 segona a l'última lletra de l'alfabet. Així llavors 24 més la nostra clau de dues ens dóna 26. 26 mod 26 ens dóna 0, el que, per sort per a nosaltres, és l'índex alfabètic d'A Així que espero que això és suficient que la prova el mètode de l'índex alfabètic funciona. Si no és així, no dubteu a provar alguns exemples del seu propi. 

Per tal d'embolicar adequadament al voltant de la alfabet i aplicar l'equació de Cèsar, llavors sabem que necessitem fer front als índexs alfabètics. Però comencem amb ASCII valors, i només llavors Com podem llavors convertim a l'índex alfabètic. A partir d'aquí, per tal d'imprimir, ens cal per fer front als valors ASCII de nou. Així que hem de trobar la manera de anar d'ASCII alfabètics i des alfabètic per ASCII. 

Així que ho deixo a vostè per esbrinar el patró entre un caràcter i el seu alfabètic índex i el seu valor ASCII. Ara, recordeu que encara que aquesta taula a la dreta a la diapositiva Mostra el majúscules, també considerar si o no un patró diferent s'aplica per als caràcters en minúscula. 

Així que ara que hem descobert com canviar un sol caràcter, llavors tot el que hem de fer és que l'escala per anar a través de tot el text en clar. Pel que el text pla és una cadena. Per sort per a nosaltres, una cadena és realment simplement un conjunt de caràcters, així per tal d'accedir a cada caràcter d'una cadena, tot el que ha de fer és l'ús de la notació de matriu. Dir que tinc una variable de tipus cadena anomenat "text =" això és CS50. ' " 

Bé, llavors, per tal de accedir a cada personatge, tot el que he de veure amb El text variable és dir així, el text en l'índex zero, es correspon amb T majúscula de text en l'índex 1 correspon a la caixa inferior h. Una altra funció útil és la funció de longitud de la cadena. Pel que passa en una cadena de que funció retornarà un nombre sencer, la longitud d'aquesta cadena. 

Ara que ja hem parlat de tots aquests elements diferents, posarem de nou junts. Així que tornar a qualsevol de la meva pseudocodi codi o el seu pseudocodi i anar a través i assegureu-vos que vostè saber com fer cada cosa. Obtenció de la clau utilitzant argc i argv, girant la clau en un sencer, una a i, el que va portar a text pla, getString i, a continuació, la iteració sobre tots els personatges de la cadena de text clar, preservant el cas de cada caràcter i canviant el caràcter amb la tecla, assegurant que ets embolicar al voltant de l'alfabet, finalment la impressió que el text xifrat. El meu nom és Amila, i això era César. 