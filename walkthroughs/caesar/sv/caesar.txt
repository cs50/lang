Amila: Låt oss ta itu med Caesar. I Caesar, vi låter användaren att koda ett hemligt meddelande. Så låt oss dyka rätt in och titta på våra ska vara färdiga för det här problemet. Så först, vi få nyckeln från användaren. Då får vi i klartext att de vill koda. Efter att vi chiffrera det för dem, och slutligen vi skriva ut sina chiffer. 

Så låt oss börja med ett exempel. Säg att du ville koda hela alfabetet med en nyckel två. Tja, hela alfabetet skulle bara flyttas till bokstäver. Så A skulle koda till C, B D, C-E, så vidare och så vidare, tills du kommer till X, som kodar för Z eller zed, beroende på var du är från. Då Y skulle då flytta hela vägen, linda runt alfabetet att komma till A, och slutligen den sista bokstaven i alfabetet, Z, zed skulle koda till B. 

Du har det? Låt oss titta på några exempel. Det första exemplet här är mycket lika vad vi just förklarats ovan. Så om jag koda någon del av alfabet, A till L, av en nyckel av två, då får jag bara min hela alfabet skiftat två bokstäver. 

Sedan, i min nästa exempel, nyckeln är fortfarande två, så du bör ändå veta vilka bokstäver som väntar. Men här är det en fras. Detta är CS50. Så du kommer att märka att jag bevara fallet med mina brev, så att eventuella stora bokstäver är också versaler i chiffertexten. Och varje gemener bokstäver i klartext är också gemener bokstäver i chiffertexten. Men jag håller bokstäverna och eventuella utropstecken eller någon annan skiljetecken densamma. 

Så nu när vi har en känsla för hur programmet fungerar, gärna gå köra några mer exempel på egen hand, om du önskar. Låt oss börja med att få nyckeln från användaren. Traditionellt, med andra problem, vi har vant sig vid att få alla siffror som vi behöver genom att användaren tillfrågas med funktionen getInt. Men den här gången vi faktiskt kommer att använda kommandoraden argument och en ny funktion som kallas atoi. 

När du kör den huvudsakliga program i C, då det tar in två parameters-- int argc, vilket är antalet argument passerade, och sedan argv, en array med strängar som innehåller en lista över alla de argument passerat. Du behöver inte uttryckligen har att förklara dessa variabler. De är beräknade för du av kompilatorn. Korrekt användning för detta skulle vara för argc att vara två i detta fall, eftersom användaren måste passera i samtalet till programmet, ./caesar, och sedan på knappen, oavsett antal de vill. Så det betyder att argc måste vara två för att en giltig användning av Caesar som ska utföras. 

Så låt oss titta på ett exempel. Säga att jag har redan skrivit och sammanställt ett program som heter blastoff. Så om jag sprang på kommandoraden ./blastoff Team Rocket, ja, då, argc skulle vara tre eftersom jag passerade i tre olika argument. Då argv skulle se ut så här. Det är en matris, och det skulle innehålla vart och ett av de tre strängar. ./blastoff i det första indexet, lag i nästa, och raketen i den sista. 

Låt oss tala om arrayer för en sekund. Arrayer är datastrukturer som håller flera värden av samma typ. Detta kan komma till hands när vi har listor av heltal eller strängar. Kom bara ihåg att de har att vara av samma typ. I datavetenskap, vi älskar räkna från noll, så kom ihåg att arrayer är också noll-indexerad. Så det första elementet i min samling kommer att vara på index noll. Så i det här fallet, när jag har en matris med längden fyra, sedan den sista index för sista elementet i min samling faktiskt kommer att vara vid index tre, inte fyra. Eftersom minns vi börja räkna på noll. 

Här är ett exempel på hur man kan skapa en rad av dina egna. Så säger jag ville spara min tre favorit hund namn. Då skulle jag skapa en array med strängar. Så jag skulle förklara typ, sträng, och sedan lägga namnet på arrayen, hundar, och sedan i de fyrkantiga konsoler sätta storleken av array-- i detta fall tre. 

Så min första posten går att vara hundar på index noll, och det kommer att vara Milo. Sedan hundar vid index en kommer att vara fånig, Darling Mochi, och sedan den sista inträde, den tredje posten i indexet två, kommer att vara söta, söta Elphie. Du kommer att märka att formatet för att fylla i denna samling är väldigt likt hur du kan deklarera alla andra variabler där du har variabelnamnet följt av det värde som du vill lagras i den. Den enda skillnaden i det här fallet är att du måste komma ihåg att sätta Index av värdet i hakparenteser. Och det har vi vår tre favorit hundar. 

Men tyvärr är det dags att komma tillbaka till Caesar. Kom ihåg att korrekt användning för Användaren kommer att passera i inte bara namnet på programmet ./caesar, men också nyckeln att de vill flytta deras klartext av. Så det betyder att argc måste vara två. De måste passera i two-- varken mer mindre än två kommandoradsargumenten. 

Nu, hur argv? Tja, vi redan vet att array kommer att vara av längden två, men vad som finns i varje element? Tja, det första elementet kommer att bli ./caesar, och sedan nästa element kommer att innehålla nyckeln som användaren har skrivit in. Nu, om de använde den på rätt sätt för användning av Caesar, då de kommer att skriva in ett nummer. Men även om karaktären att de skriver är ett tal, Det är av typen datasträng. 

Så hur ska vi omvandla den sträng till ett heltal? Så säger jag har num, en sträng, som innehåller strängen 50. Om jag vill konvertera att till ett heltal, då jag helt enkelt deklarera en ny variabel, en heltal i, ringer atoi. Jag passerar i min strängvariabel num, och då jag kommer då att innehålla siffran 50. Se till att kontrollera mannen sidor för atoi funktion att kontrollera vilka bibliotek är det i, liksom vad värdesätter det återkommer om strängen passerade i innehåller inte alla siffror. 

Så nu när vi har fått nyckeln, nästa steg är att få klartext från användaren. Nu, detta kommer att vara mindre komplicerat än att navigera runt kommandoradsargumenten. Allt vi behöver göra är att ringa getString funktionen att uppmana användaren att ge oss en sträng, men kom ihåg att kontrollera specifikationerna för hur vi kanske vill fråga användaren om det. 

Nu kommer vi till den hjärtat av problem-- hur man kryptera klartext. Jo, först, låt oss tala om hur att chiffrera ett tecken i taget, och sedan kommer vi ta itu med hur man iterera över hela klartext. Jag har skrivit en del pseudo för Caesar problem. Jag uppmuntrar dig att skriva din egen också. Det kanske inte ser identiskt med gruvan, och det är OK, men så länge som den allmänna idén är densamma. 

De tre första stegen Vi har redan gjort. Vi har fått nyckeln från kommandoraden argument Vi har vred om nyckeln i ett heltal, och vi har uppmanas användaren att klartext att de vill kryptera. Så då nästa stora bit är att för varje tecken i klartexten strängen, om det är alfabetisk, vi vill bevara fodralet och flytta den. Genom att bevara fall vad jag menar är att alla versaler bokstäver bör förbli övre fall och gemener bör förbli gemener. Så då när vi flytta dem, då vi ut chiffertexten. 

Här är tre funktioner som kommer att komma till hands för detta problem. Kom ihåg upp ovan när jag gav exempel för att flytta detta är CS50? Kom ihåg att 50 och utropstecken inte flytta? Så hur kan vi avgöra om vi behöver flytta ett brev eller inte? Tja, "är alfa," om du passerar det ett tecken, returnerar sant om tecknet är ett brev och i annat fall false. För att hjälpa dig med bevara aktivering är funktionerna "är övre "och" är lägre. " 

Dessa två funktioner också ta i ett enstaka tecken som indata och återvänder du en Boolean, antingen sant eller falskt beroende på om det tecknet är versaler eller gemener. Eftersom "är övre" och "är lägre "är booleska funktioner, vilket innebär att de återvänder du en Boolean, du kan använda dessa i dina förhållanden. Så här är ett utdrag av kod som endast skriver ett brev om det är versaler. Så jag har förklarat min karaktär brev att det övre höljet zed och sedan om "är övre" avkastning sant, sedan skriva ut jag denna skrivelse. 

Att gå tillbaka till vår enkla exempel på skiftning av alfabetet av en nyckel av två, Hur kan vi faktiskt få det att fungera? Tja, visar det sig att tecken och heltal är mycket nära besläktade. Varje figur har en heltalsvärde associerat med det sig i ASCII-diagrammet, där varje karaktärs ASCII Värdet visas. Så en versaler A motsvarar till en ASCII-värdet på 65 och ett gement a till ett ASCII-värdet av 97. 

Titta gärna upp varje ASCII diagrammet nätet att se dessa värden själv. Så vad detta betyder är att vi kan ta karaktären av versaler A, lägga till heltal två till det, och sedan få karaktären versal C som följd. Det är därför 65, ASCII värde för kapital A, plus två, ger oss 67, vilket motsvarar till karaktären av versaler C. 

Tyvärr, saker kommer inte riktigt vara så enkelt. Vi har en ekvation som vi måste överväga. Här berättar att te chiffertexten brev motsvarar den i: te klartext brev, plus key-- allt detta, modulär 26. Varför är det så? Låt oss gå tillbaka till vårt exempel från innan, där kapital A, plus två, ger oss kapital C. 

Så att tillämpa ekvation som specifikationen ger oss, så låt oss ta kapital A plus två och mod att med 26. Så kapital A, när jag satte den i dessa enkla citattecken, tillåter mig att behandla det som ett heltal, så som gör att mig att kasta den till dess ASCII-värdet, 65. 65 plus två är 67. 67 mod 26 ger oss 15, men som egentligen inte vettigt eftersom vi vet att det huvudstad C ASCII-värdet är 67, inte 15. Så hur ska vi förena det? 

Tja, här jag vill posit den begreppet ett alfabetiskt index. Så vi har redan talat om hur varje karaktär har sitt ASCII-värdet, men jag skulle vilja säga, ja, låt oss tänka varje tecken också har ett kartotek, där A exempelvis som den första bokstaven i alfabetet, har ett alfabetiskt index på noll. Så låt oss nu tillämpa samma ekvation som tidigare, men genom att använda ett alfabetiskt index. 

Så A är noll, eftersom vi har definierat. Så då tar noll plus två, mod 26, det är två, mod 26, vilket ger oss två. Och väl, i termer av ett kartotek, C är den tredje bokstaven i alfabet, så som skulle motsvara till ett alfabetiskt index på två. Så det verkar som att använda alfabetiska index i detta fall faktiskt ger oss rätt resultat. 

Så låt oss nu kontrollera se om ekvationen verk med ett alfabetiskt index. Y alfabetiska index är 24 som näst sista bokstav i alfabetet. Alltså 24 plus vår nyckel två ger oss 26. 26 mod 26 ger oss 0, som tur för oss, är det alfabetiska indexet för A. Så förhoppningsvis det är nog att bevis det alfabetiska index metoden fungerar. Om inte, gärna prova några exempel på din egen. 

För att på rätt omsluta alfabet och tillämpa Caesar ekvationen då vet vi att vi måste itu med alfabetiska indexen. Men vi börjar med ASCII värden, och först därefter vi sedan konvertera till det alfabetiska index. Därifrån, i att kunna skriva ut, vi behöver att ta itu med de ASCII-värden igen. Så vi måste ta reda på hur man gå från ASCII alfabetisk och från alfabetisk till ASCII. 

Så jag lämnar det till dig att räkna ut mönstret mellan ett tecken och dess alfabetisk index och dess ASCII-värdet. Nu, kom ihåg att även om tabellen till höger på bilden visar versaler, vi också måste överväga huruvida ett annat mönster gäller för gemener. 

Så nu när vi har räknat ut hur man flytta en enda karaktär, då allt vi behöver göra är att skala som upp för att gå över hela klartext. Så klartexten är en sträng. Tur för oss, är en sträng verkligen bara en uppsättning av tecken, så för att få tillgång till varje tecken av en sträng, allt du behöver göra är att använda array notation. Säga att jag har en variabel av typen sträng som kallas "text =" detta är CS50. " 

Nå, i syfte att tillgång till varje tecken, allt jag har att göra med variabeln text är att säga ja, text på index noll, att motsvarar kapital T. Text på index en motsvarar den gemena h. En annan användbar funktion är stränglängd funktionen. Så passerar en sträng till denna funktion kommer att återvända ett heltal, längden på den strängen. 

Nu när vi har talat om alla dessa olika element, Låt oss sätta tillbaka dem tillsammans. Så tillbaka till antingen min pseudo kod eller din pseudo och gå igenom och se till att du vet hur man gör varje enskild sak. Få nyckeln använder argc och argv, vrida nyckeln i ett heltal, en till mig, vilket fick till klartext, getString, och sedan iteration över varje tecken i klartextsträng, bevara för varje tecken och skifta tecknet med nyckeln, se till att du är omslag runt alfabetet, slutligen skriver ut bilden chiffertexten. Mitt namn är Amila, och det var Caesar. 