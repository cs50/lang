Amila: Нека да се справи с Цезар. В Цезар, ние позволи на потребителя за кодиране на тайно послание. Така че нека да се потопите право и да погледнем в нашите списъци със задачи за този проблем. Така че на първо място, ние получите ключ от страна на потребителя. Тогава получаваме прав текст че те искат да се кодира. След това, ние го пиша с шифър за тях, и най-накрая се печата им ciphertext. 

Така че нека да започнем с един пример. Да речем, че е искал да кодират цялата азбука с ключ на две. Е, цялата си азбука би просто се измества към писма. Така че А ще се кодират за C, B, за да D, С до Е, така нататък и така нататък, докато не стигнем до X, който кодира до Z или зет, в зависимост от това къде сте от. Тогава Y ще може да премине целия път, увийте около азбуката, за да стигнем до A, и след това най-накрая последната буква на азбука, Z, зет, ще се кодират до Б. 

Имаш ли, че? Нека да разгледаме някои примери. Първият пример тук е много подобен на това, което ние просто обяснено по-горе. Така че, ако аз се кодират някои раздел на азбука, от А до L, с ключ на две, тогава аз просто да си взема цялата азбука изместен две букви. 

След това, през следващата ми например, ключът е все още двама, така че все още трябва да знаем който писма да се очаква. Но тук това е една фраза. Това е CS50. Така че вие ​​ще забележите, че аз запази случай на писмата ми, така че всички главни букви са също главни букви в ciphertext. И всеки с малки букви букви в прав текст също са малки букви букви в ciphertext. Но аз държа на буквите и всякакви удивителни знаци или всяка друга пунктуацията същото. 

Така че сега ние имаме чувство за това как работи програмата, Чувствайте се свободни да се работи повече примери на собствения си, ако желаят. Нека да започнем с получаване на ключа от потребителя. Традиционно, с други проблеми, ние сме са свикнали да получавате всякакви номера, че ние нужда от подканване на потребителя с getint на функция. Но този път ние всъщност ще да се използва аргументът на командния ред и нова функция, наречена atoi. 

Когато стартирате основните програма на С, след това отнема в две parameters-- INT argc, които е броят на аргументите преминали в, и след това argv, масив от низове, който съдържа списък на всички аргументи преминал. Не е ясно има да декларират тези променливи. Те са изчислени за ти от компилатора. Правилното използване на това ще бъде за argc да бъде две в този случай, тъй като потребителят трябва да премине през поканата към програмата, ./caesar, и след това ключът, независимо от броя желаят. Така че това означава, че argc трябва да бъде две , за валиден използване на Цезар да бъде изпълнена. 

Така че нека да разгледаме един пример. Да речем, аз вече съм писал и съставена програма, наречена изстрелване. Така че, ако аз се завтече в командния ред ./blastoff Team Rocket, добре, тогава, argc ще бъде три, защото аз преминал през три различни аргументи. Тогава argv ще изглежда така. Това е масив, и би съдържа всяка от трите струни. ./blastoff в първия индекс, екипът в следващия, и ракетата в последната. 

Нека поговорим за масиви за сек. Масивите са структури от данни, които държат няколко стойности от същия тип. Това може да дойде по-удобно, когато ние има списъци с цели числа или низове. Само не забравяйте, че имат да бъде от същия тип. В компютърните науки, ние Обичам да се брои от нула, така не забравяйте, че масиви също са нулеви индексиран. Така че първият елемент на моя масив ще бъде най-индекс нула. Така че в този случай, когато имам набор от четири дължина, след последния индекс на Последният елемент от моя масив всъщност ще бъде при индекс три, не четири. Защото не забравяйте, ние започне преброяване на нула. 

Ето един пример за това как можете може да се създаде масив от собствения си. Така се каже, че искам да се съхранява ми три любими имена куче. Тогава ще се създаде масив от низове. Така че аз ще декларира тип, низ, и След това сложи името на масива, кучета, и след това в тези квадратен скоби, поставени на размера на array-- в този случай, три. 

Така че първият ми пост ще да бъде кучета в индекса на нула, и че ще бъде Мило. Тогава кучета в индекса един ще е шантаво, скъпа Mochi, и след това последният влизане, третото влизане в индекса на две, ще бъде сладко, сладко Elphie. Ще забележите, че форматът за попълване на този масив много прилича на това как може да се декларират всяка друга променлива, където имате името на променливата, последвано от стойността, която искате да се съхранява в него. Разликата само в този случай е, че Трябва да се помни, да се постави на индекса на стойността в квадратни скоби. И там ние имаме три любими кучета. 

Но уви, това е време да се върнем към Цезар. Не забравяйте, че правилното използване на потребител ще се преминава през не само името на ./caesar програмата, но Също така ключа, че те искат да се смени тяхната прав текст от. Така че това означава, че argc трябва да е два. Те трябва да преминат през two-- нито повече, нито по-малко от две аргументи на командния ред. 

Сега, какво да кажем за argv? Е, ние вече знаем, че масив ще бъде с дължина два, но това, което се съдържа във всяка елемент? Е, първият елемент ще бъде ./caesar, и след това на следващия елемент ще съдържа ключа, че потребителят въведе вътре. Сега, ако те го използват правилно за използването на Цезар, След това те ще напишете в редица. Но въпреки че характер че те написали е число, това е от тип данни низ. 

И как ще конвертирате, че низ до цяло число? Така кажем, че имам бр, низ, съдържащ низа 50. Ако искате да конвертирате, че до цяло число, тогава просто декларира нова променлива, на цяло число аз, наричайки atoi. Минавам с низ променлива, бр, и тогава аз тогава ще съдържа номера 50. Уверете се, че за да се провери на мъжа страници за функцията atoi да се провери кои библиотека е в, както и това, което го ценим ще се върне, ако низа преминал в не съдържа всички числа. 

Така че сега, че ние сме придобили ключа, следващата стъпка е да се получи прав текст от потребителя. Сега, това ще да бъде по-сложно от навигацията около аргументи на командния ред. Всичко, което трябва да направите е повикване Функцията на getstring да подтикне потребителя да даде ни низ, но не забравяйте, да се провери спецификациите за това как ние Може би искате да напомни на потребителя за това. 

Сега стигаме до Сърцето на problem-- как да пиша с шифър на прав текст. Ами, първо, нека да говорим за това как за шифроване на един знак в момент, и след това ще разгледа как да обхождане на цялата прав текст. Аз съм писал някои Псевдокод за проблема Цезар. Препоръчвам ви да напишете своето собствено, както добре. Тя може и да не изглежда идентичен мина, и това е ОК, но толкова дълго, като общата идея е същото. 

Първите три стъпки ние вече сме направили. Ние сме придобили ключа от аргумент на командния ред, ние сме се обърна, че ключовата в цяло число, и ние сме подкана на потребителя за прав текст че те искат да шифроване. Така че след следващото голямо парче е, че за всеки един от героите в прав текст низ, ако това е азбучен, ние искаме да се запази неговото дело и го смени. Чрез запазване случай, това, което мога да кажа е, че всички главни букви писма следва да останат горната случай и всички малки букви трябва да остане само с малки букви. Така че след това, след като сме се измести тези, След това ние отпечатате ciphertext. 

Ето три функции, които ще да дойде по-удобно за този проблем. Запомни до горе, когато дадох Например за изместване това е CS50? Не забравяйте, че на 50, и удивителен знак не се смени? Така че как можем да се каже дали ние Трябва да се измести писмо или не? Е, "е алфа", ако можете да го герой мине, ще се върне вярно, ако този характер е писмо и фалшива друго. За да ви помогне с запазване капитализация са функциите "е горна "и" е по-ниска. " 

Тези две функции също така да вземат в един символ като вход и да се върнете на Булева, или вярно или невярно в зависимост от това дали този характер е с малки или главни случай. Защото "е горната" и "е по-ниски "са булеви функции, което означава, че те се върнете булева, Можете да използвате тези във вашите условия. Така че тук е фрагмент от кода, че само отпечатва писмо, ако това е горния случай. Така че аз съм обявен моя характер писмо за горния случай зет и след това, ако "е горната част на" приходи вярно, тогава аз отпечатате това писмо. 

Ако се върнем към нашия прост пример за изместване на азбуката с ключ на две, как да се получи в действителност, че да работи? Е, оказва се, че героите и числа са много тясно свързани. Всеки герой има целочислена стойност, свързана с него се намери в класацията ASCII, където ASCII всеки знак се показва стойност. Така че съответства с а главни на ASCII стойност на 65 и с малки букви а да на ASCII стойност на 97. 

Чувствайте се свободни да погледнете нагоре всеки ASCII графика онлайн за да видите тези стойности за себе си. И така, какво означава това е, че ние можем вземат характера на горния случай A, добавете цялото число два до него, и след това да получите характера главни букви C, като резултат. Това е така, защото 65, на ASCII стойност за капитал A, плюс 2, ни дава 67, което съответства за характера на горния случай C. 

За съжаление, нещата няма да доста да е толкова прост. Ние имаме едно уравнение, че ние трябва да се помисли. Ето това ни казва, че ciphertext на Ith писмо съответства на прав текст на Ith писмо, плюс key-- всичко това модулни 26. Защо е, че е така? Да се ​​върнем към нашия пример от преди, когато капитал A, плюс 2, ни дава капитал C. 

Така прилагането на уравнението, че спецификацията ни дава, тогава нека да капитал A плюс 2 и Министерството на отбраната, който от 26. Така капитал A, когато го постави в тези единични кавички, ми позволява да го третира като цяло число, така че позволява ми да я хвърли към своя ASCII стойност, 65. 65 плюс 2 е 67. 67 мод 26 ни дава 15, Но това не наистина да има смисъл, защото ние знаем, че капитал C ASCII стойност е 67, а не 15. И така, как можем да приемем, че? 

Е, тук бих искал да предпоставят понятие за азбучен индекс. Така че ние вече говорихме за това как Всеки герой има своя ASCII стойност, но бих искал да кажа, добре, нека мисля за всеки един от героите също като азбучен индекс, където А например, като първата буква от азбуката, има азбучен индекс на нула. Така че сега нека да се приложи същото уравнение, както и преди, но с помощта азбучен индекс. 

Така че A е равно на нула, тъй като ние сме определени. Така че след като нула плюс две, мод 26, това е две, мод 26, което ни дава две. И добре, от гледна точка на азбучен индекс, C е третата буква в азбука, така че да съответства да азбучен индекс на две. Така че изглежда, че използването на азбучен указател в този случай всъщност ни дава правилния резултат. 

Така че сега нека да се провери, за да видим дали уравнение работи с азбучен индекс. азбучен индекс Y е 24, като втори до последния писмо в азбуката. Така след 24 плюс нашата ключ на две ни дава 26. 26 мод 26 ни дава 0, което, късмет за нас, е азбучен индекс за A. Така че се надяваме, че това е достатъчно, че доказателството Методът на азбучен индекс работи. Ако не, не се колебайте да опитате някои примери за себе си. 

За да бъде правилно обгърне азбука и се прилага уравнението Цезар, След това ние знаем, че ние трябва да се справят с буквени индекси. Но да започнем с ASCII ценности, и едва след можем след това преобразуване на азбучния указател. От там, за да се отпечата, ние се нуждаем от да се справят с ценностите на ASCII отново. Така че ние трябва да разбера как да се премине от ASCII да азбучен и от азбучен да ASCII. 

Така че аз го оставя на вас да разбера модела между герой и неговата азбучен индекс и неговата ASCII стойност. Сега, не забравяйте, че въпреки че това право маса на слайда показва, главни букви, ние също Трябва да се помисли дали или не прилага различен модел за малки букви. 

Така че сега, че ние сме измислили как да се смени един символ, След това всички ние трябва да направим, е скала, която до отида в цялата прав текст. Така че прав текст е низ. За наше щастие, низ е наистина само един набор от символи, така че, за да получите достъп до всеки герой на низ, всичко, което трябва да направите, е да се използва масив нотация. Да речем, че имам променлива от тип низ, наречен "текст = 'това е CS50.'" 

Е, тогава, за да се достъп до всеки един от героите, всичко, което трябва да се направи с променлив текст е да се каже, добре, текст на индекса на нула, че съответства на капитала T. Текст на индекс един съответства на долната случай ч. Друга полезна функция е Функцията на дължина низ. Така че, минаваща през низ да тази функция ще се върне цяло число, дължината на тази поредица. 

Сега, когато сме говорили за всички тези различни елементи, нека да ги пуснат обратно заедно. Така се върне или да ми Псевдокод код или си Псевдокод и проверете и се уверете, че сте знаете как да направите всяко едно нещо. Първи ключът използване argc и argv, завъртане на ключа в цяло число, а да съм, с което предизвика за прав текст, getstring, и след това повтаряне над всеки герой в на прав текст низ, запазване случая на всеки един от героите и измества този характер чрез ключа, гарантира, че вие ​​сте обвивка около азбуката, накрая отпечатване че ciphertext. Моето име е Amila, и това беше Цезар. 