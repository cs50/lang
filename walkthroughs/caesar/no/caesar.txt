Amila: La oss takle Cæsar. I Caesar, tillater vi brukeren å kode en hemmelig melding. Så la oss hoppe rett inn og se på våre gjøremål for dette problemet. Så først, får vi nøkkelen fra brukeren. Så får vi klarteksten at de ønsker å kode. Etter at vi encipher det for dem, og til slutt vi skrive ut sine krypterte teksten. 

Så la oss starte med et eksempel. Si du ønsket å kode hele alfabet med en nøkkel av to. Vel, ville hele alfabetet bare bli flyttet til bokstaver. Så A vil kode til C, B til D, C til E, så videre og så videre, til du kommer til X, som koder for Z eller zed, avhengig av hvor du er fra. Deretter Y vil deretter skifte hele veien, vikle rundt alfabetet for å komme til A, og til slutt den siste bokstaven i alfabetet, Z, zed, vil kode til B. 

Du fikk det? La oss se på noen eksempler. Det første eksempelet her er meget lik til det vi nettopp har forklart ovenfor. Slik at hvis jeg kode noen del av alfabet, A til L, med en nøkkel av to, så jeg bare få min hele alfabetet flyttet to bokstaver. 

Så, i mitt neste eksempel nøkkelen fortsatt er to, så du bør likevel vite hvilke bokstaver du kan forvente. Men her er det en setning. Dette er CS50. Så vil du legge merke til at jeg bevare tilfelle av brevene, slik at eventuelle store bokstaver er også store bokstaver i krypterte teksten. Og noen små bokstaver bokstaver i klartekst er også små bokstaver bokstaver i krypterte teksten. Men jeg holder bokstavene og eventuelle utropstegn eller hvilken som helst annen tegnsetting den samme. 

Så nå som vi har en følelse for hvordan programmet fungerer, gjerne gå kjøre noen mer eksempler på egen hånd, hvis du ønsker det. La oss starte med å få nøkkelen fra brukeren. Tradisjonelt med andre problemer, har vi blitt vant til å få noen tall som vi trenger ved å spørre brukeren med funksjonen getint. Men denne gangen vi faktisk kommer å bruke kommandolinje argument og en ny funksjon som kalles atoi. 

Når du kjører hoved program i C, da det tar inn to parameters-- int argc, som er det antall argumenter vedtatt i, og deretter argv, en rekke strenger som inneholder listen over alle argumentene passert. Du trenger ikke eksplisitt har å erklære disse variablene. De er beregnet for du av kompilatoren. Riktig bruk for dette ville være for argc å være to i dette tilfellet, fordi brukeren må passere i kallet til programmet, ./caesar, og deretter tasten, uansett hvor mange de ønsker. Så det betyr at argc må være to for at et gyldig bruk av Caesar å bli henrettet. 

Så la oss se på et eksempel. Si jeg har allerede skrevet og utarbeidet et program som heter blastoff. Så hvis jeg kjørte i kommandolinjen ./blastoff team Rocket, vel, da, argc ville være tre fordi jeg vedtatt i tre forskjellige argumenter. Deretter argv ville se slik ut. Det er en matrise, og det ville inneholder hver av de tre strenger. ./blastoff i første indeksen, team i den neste, og rocket i det siste. 

La oss snakke om arrays for et sek. Arrays er datastrukturer som holder flere verdier av samme type. Dette kan komme godt med når vi har lister over heltall eller strenger. Bare husk at de har for å være av samme type. I informatikk, vi elsker å telle fra null, så husk at arrays er også null-indeksert. Så det første elementet i mitt utvalg kommer til å være på indeksen null. Så i dette tilfellet, når jeg har en oppstilling av fire lengde, da den siste indeksen i siste del av mitt utvalg faktisk kommer til å være på indeksen tre, ikke fire. Fordi husk, vi begynne å telle til null. 

Her er et eksempel på hvordan du kan skape en rekke av dine egne. Så sier jeg ønsket å lagre min tre favoritt hunden navn. Da ville jeg skape en rekke strenger. Så jeg ville erklære type, streng, og deretter sette navnet på tabellen, hunder, og deretter i de square parentes sette størrelsen av den array-- i dette tilfelle tre. 

Så min første oppføringen kommer å være hunder på indeksen null, og som kommer til å være Milo. Så hunder på indeksen en kommer til å være klønete, elskling Mochi, og deretter den siste oppføring, den tredje posten på indeksen to, kommer til å være søt, søt Elphie. Du vil merke at formatet for å fylle denne matrisen er veldig mye som hvordan du kan erklære noen annen variabel der du har variabelnavnet etterfulgt av verdien som du vil ha lagret i den. Den eneste forskjellen i dette tilfellet er at du må huske å sette indeksen av verdien i hakeparentes. Og der har vi vår tre favoritt hunder. 

Men akk, det er på tide å komme tilbake til Cæsar. Husk at riktig bruk for Brukeren skal være bestått i ikke bare navnet på programmet ./caesar, men også nøkkelen for at de ønsker å skifte deres klartekst ved. Så det betyr at argc må være to. De må passere i two-- ikke mer, ikke mindre enn to kommandolinjeargumenter. 

Nå, hva om argv? Vel, vi vet allerede at matrisen kommer til å være av lengde to, men det som finnes i hvert element? Vel, det første elementet kommer til å være ./caesar, og deretter den neste element skal inneholder nøkkelen som brukeren har skrevet inn. Nå, om de brukte det riktig for bruken av Caesar, så de kommer til å taste inn et nummer. Men selv om tegnet at de skriver er et tall, det er av datatypen string. 

Så hvordan skal vi konvertere streng til et heltall? Så sier jeg har num, en streng, inneholder strengen 50. Hvis jeg ønsker å konvertere til et heltall, da jeg rett og slett erklære en ny variabel, en heltall i, ringer atoi. Jeg passerer i min streng variabel, num, og så jeg vil da inneholde nummer 50. Sørg for å sjekke mannen sider for atoi funksjon å sjekke hvilke bibliotek det er i, samt hvilken verdi det kommer tilbake hvis strengen sendes i ikke inneholder alle tall. 

Så nå som vi har fått nøkkelen, er neste trinn er for å få den rene teksten fra brukeren. Nå, dette kommer til å være mindre komplisert enn å navigere rundt kommandolinjeargumenter. Alt vi trenger å gjøre er å ringe den getstring funksjon å be brukeren om å gi oss en streng, men husk å sjekke spesifikasjonene for hvordan vi kan det være lurt å be brukeren om det. 

Nå kommer vi til den hjertet av problem-- hvordan å encipher klarteksten. Vel, først, la oss snakke om hvordan å encipher ett tegn om gangen, og så får vi ta opp hvordan iterere over hele teksten. Jeg har skrevet noen pseudo for Caesar problem. Jeg oppfordrer deg til skrive din egen så vel. Det kanskje ikke ser identisk med min, og det er OK, men så lenge som den generelle ideen er den samme. 

De tre første trinnene vi allerede har gjort. Vi har fått nøkkelen fra kommandolinje argument, vi har slått den tasten inn et heltall, og vi har bedt brukeren for ren tekst at de ønsker å encipher. Så det neste store blings er det for hvert tegn i klartekst streng, hvis det er alfabetisk, vi ønsker å bevare sin sak og skifte den. Ved å bevare tilfelle, hva jeg mener er at alle store bokstaver brevene skal være over case og små bokstaver bør forbli små bokstaver. Så etter at vi skiftet disse, Da vi skrive ut krypterte teksten. 

Her er tre funksjoner som kommer å komme til for dette problemet. Husk opp over når jeg ga eksempel for å skifte dette er CS50? Husk at den 50 og den utropstegn ikke skifte? Så hvordan kan vi vite om vi trenger å skifte et brev eller ikke? Vel, "er alfa", hvis du passerer det et tegn, vil returnere true hvis det tegnet er et brev og falsk ellers. For å hjelpe deg med bevare kapitalisering er funksjonene "er øvre "og" lavere ". 

Disse to funksjoner også ta i et enkelt tegn som input og returnere deg en boolsk, enten sant eller usant avhengig av om det tegnet er små eller store bokstaver. Fordi "er øvre" og "er lavere "er boolske funksjoner, noe som betyr at de kommer tilbake du en boolsk, du kan bruke disse i dine forhold. Så her er en bit med kode som bare skriver et brev om det er store bokstaver. Så jeg har erklært min karakter brev til å bli den store bokstaver zed og hvis "er øvre" returnerer sant, så jeg skriver dette brevet. 

Går tilbake til vårt enkle eksempel på skiftende alfabetet ved en nøkkel av to, hvordan kan vi faktisk få det til å fungere? Vel, det viser seg at tegnene og heltall er svært nært beslektet. Hver karakter har en heltallsverdi forbundet med det som finnes i ASCII diagram, hvor hvert tegn ASCII verdien vises. Så en stor bokstav A tilsvarer til en ASCII-verdi på 65 og en liten bokstav a til en ASCII-verdi på 97. 

Føl deg fri til å se opp alle ASCII diagram online å se disse verdiene selv. Så hva dette betyr er at vi kan ta karakter av store bokstaver A, legge heltallet to til det, og så får tegnet øvre hus C som et resultat. Det er fordi 65, ASCII verdi for kapital A, pluss to, gir oss 67, som tilsvarer til karakteren av store bokstaver C. 

Dessverre, ting vil ikke helt være så enkelt. Vi har en ligning som vi må vurdere. Her forteller det oss at den it chifferteksten bokstav svarer til den i-te rene teksten brev, pluss key-- alt dette, modulære 26. Hvorfor er det slik? La oss gå tilbake til vårt eksempel fra før, der kapital A, pluss to, gir oss kapital C. 

Så å bruke ligningen som spesifikasjonen gir oss, så la oss ta kapital A pluss to og mod som med 26. Så kapital A, når jeg setter den i disse enkle anførselstegn, tillater meg å behandle det som et helt tall, slik som lar meg å kaste den til sin ASCII-verdi, 65. 65 pluss to er 67. 67 mod 26 gir oss 15, men det gjør egentlig ikke fornuftig fordi vi vet at kapital C ASCII-verdi er 67, ikke 15. Så hvordan skal vi forene det? 

Vel, her jeg ønsker å posit den Ideen om en alfabetisk indeks. Så vi har allerede snakket om hvordan hver figur har sin ASCII-verdi, men jeg vil gjerne si, vel, la oss tenke på hver karakter også ha en alfabetisk indeks, hvor A for eksempel, som den første bokstaven i alfabetet, har en alfabetisk indeks over null. Så nå kan vi bruke samme ligning som før, men ved hjelp av en alfabetisk indeks. 

Så A er null, slik vi har definert. Så da tar null pluss to, mod 26, det er to, mod 26, noe som gir oss to. Og vel, i form av en alfabetisk indeks, C er den tredje bokstaven i alfabetet, så det ville tilsvare til en alfabetisk indeks over to. Så det virker som bruker alfabetisk indeks i denne saken faktisk gir oss riktig resultat. 

Så nå la oss sjekke se om ligningen verk med en alfabetisk indeks. Ys alfabetisk indeks er 24 som nest siste bokstaven i alfabetet. Så da 24 pluss vår Nøkkelen til to gir oss 26. 26 mod 26 gir oss 0, som, heldig for oss, er den alfabetiske indeksen for A. Så forhåpentligvis det er bevis nok på at den alfabetiske indeksen metoden fungerer. Hvis ikke, må du gjerne prøve ut noen eksempler på egen hånd. 

For å kunne brytes rundt alfabet og bruke Caesar ligningen, da vet vi at vi trenger å håndtere alfabetiske indekser. Men vi starter med ASCII verdier, og bare deretter vi deretter konvertere til den alfabetiske indeksen. Derfra for å skrive ut, må vi å håndtere de ASCII-verdier igjen. Så vi må finne ut hvordan de skal gå fra ASCII til alfabetisk og fra alfabetisk til ASCII. 

Så jeg la det til deg å finne ut mønsteret mellom en karakter og dens alfabetisk indeks og dens ASCII-verdi. Nå, husk at selv om denne tabellen til høyre på lysbildet viser store bokstaver, vi også må vurdere hvorvidt et annet mønster gjelder for de små bokstaver. 

Så nå som vi har funnet ut hvordan å skifte en enkelt karakter, så alt vi trenger å gjøre er skala som opp for å gå på tvers av hele teksten. Så den rene teksten er en streng. Heldig for oss, er en streng virkelig bare en rekke tegn, så for å få tilgang til hver karakter av en streng, alt du trenger å gjøre er å bruke matrise-notasjon. Si jeg har en variabel av type strengen som kalles "text =" dette er CS50. " 

Vel, da, for å tilgang til hver karakter, alt jeg har å gjøre med variabelen teksten er å si vel, tekst indeks null, som tilsvarer kapital T. Tekst på indeksen en tilsvarende små bokstaver timer. En annen nyttig funksjon er strenglengden funksjon. Så passerer i en streng for å at funksjonen vil returnere et heltall, lengden av strengen. 

Nå som vi har snakket om Alle disse forskjellige elementer, la oss sette dem sammen igjen. Så tilbake til enten min pseudo kode eller pseudo og gå gjennom og sørg for at du vet hvordan du gjør hver eneste ting. Å få nøkkelen ved hjelp av argc og argv, dreie nøkkelen i et heltall, en å jeg, spørre for klartekst, getstring, og deretter itera over hver karakter i klarteksten streng, bevare tilfelle av hvert tegn og skiftende som tegnet av nøkkelen, sikre at du er innpakning rundt alfabetet, endelig utskrift som krypterte teksten. Mitt navn er Amila, og dette var Cæsar. 