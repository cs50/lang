Amila: Pieņemsim risināt Cēzaru. In ķeizaram, mēs ļauj lietotājam lai kodētu slepenu ziņu. Tā ļauj nirt tiesības un meklēt mūsu darāmo šīs problēmas. Tātad, pirmkārt, mēs atslēgu no lietotāja. Tad mēs iegūtu teksta, ka viņi vēlas, lai šifrēt. Pēc tam, mēs šifrēt to viņiem, un, visbeidzot, mēs drukāt savu ciphertext. 

Tāpēc sāksim ar piemēru. Say jums gribēja šifrēt Visa alfabēts ar atslēgu divi. Nu, visa jūsu alfabēts būtu vienkārši pārvietoti uz vēstulēm. Tātad varētu šifrēt uz C, B D, C līdz E, tā tālāk un tā tālāk, līdz jums X, kas kodē līdz Z vai zed, atkarībā no tā, kur jūs esat no. Tad Y tad novirzīt visu ceļu, wrap ap alfabētu, lai saņemtu A, un tad beidzot pēdējais burts alfabēts, Z, zed, būtu šifrēt uz B. 

Jums, ka? Apskatīsim dažus piemērus. Pirmais piemērs šeit ir ļoti līdzīgs ar to, ko mēs tikko paskaidrots iepriekš. Tātad, ja es kodēt kādu sekciju alfabēts, no A līdz L, ar atslēgu divi, tad es tikai saņemt savu visu vielas alfabēts pārvietoti divus burtus. 

Tad manā nākamajā piemēram, galvenais ir vēl divi, lai jūs joprojām vajadzētu zināt kas burti sagaidīt. Bet šeit tas ir frāze. Tas ir CS50. Tātad, jūs pamanīsiet, ka es saglabāt lietu manas vēstules, tāpēc jebkurš augšējo burti ir arī augšējo burti šajā ciphertext. Un jebkurš mazie burti burti teksta, ir arī mazie burti burti ciphertext. Bet es saglabāt vēstules un jebkādi izsaukuma zīmes vai jebkurš cits punktācija tāds pats. 

Tāpēc tagad, ka mums ir sajūta par to, kā programma darbojas, justies brīvi iet palaist dažas vairāk piemēri savu, ja vēlaties. Sāksim ar kļūst galvenais no lietotāja. Tradicionāli, ar citas problēmas, mēs esam pieraduši, lai iegūtu kādi skaitļi, kas mēs vajag ko pamudinot lietotājam ar funkciju getint. Bet šoreiz mēs patiesībā notiek izmantot komandrindas argumentu un jaunu funkciju sauc atoi. 

Palaižot galvenā programma C, tad tas notiek divās parameters-- int argc, kas ir skaitlis no argumentus pieņemts, un pēc tam argv, masīvs stīgām, kas satur saraksts, kas visi no argumentus pagājis. Jums nav skaidri ir atzīt šos mainīgos. Viņi aprēķināti jūs ar kompilatoru. Pareiza izmantošana tas būtu par argc būt divi, šajā gadījumā, jo lietotājs ir caurlaide zvans ar programmu ./caesar, un pēc tam taustiņu, neatkarīgi numurs viņi vēlas. Tātad tas nozīmē, ka argc jābūt divām Lai derīgu lietošanai Cēzara jāizpilda. 

Tātad aplūkosim piemēru. Teikt, es esmu jau uzrakstījis un apkopo programmu, ko sauc Blastoff. Tātad, ja es skrēja komandrindas ./blastoff Team Rocket, labi, tad, argc būtu trīs, jo I pagājuši trīs atsevišķos argumentus. Tad argv varētu izskatīties šādi. Tas ir masīvs, un tas būtu satur katra no trim stīgām. ./blastoff pirmajā indeksa, komanda nākamajā, un raķeti pēdējais. 

Parunāsim par masīvu par sek. Masīvi ir datu struktūras, kas tur vairākas vērtības viena un tā paša tipa. Tas var noderēt, ja mēs ir saraksti integers vai virknes. Tikai atceraties tie ir lai pie tā paša tipa. Datorzinātnēs, mēs mīlu skaitot no nulles, tāpēc atcerieties, ka bloki Ir arī nulles indeksēti. Tāpēc mana masīva pirmais elements būs nulles indeksu. Tātad šajā gadījumā, kad man ir masīvs garuma četri, pēc tam pēdējo indekss no pēdējais elements mana masīvs faktiski būs pie trīs, nevis četri indeksā. Jo atceros, mēs sāk skaitīt no nulles. 

Lūk, piemērs, kā jūs varētu izveidot masīvu savu. Tā teikt, es gribēju, lai saglabātu manu trīs mīļākie suņu vārdi. Tad es varētu izveidot masīvu stīgas. Tāpēc es apliecinu, tipa, stīgu, un tad ielieciet nosaukumu masīva, suņiem, un tad tajās laukumā iekavās likt izmēru no array-- šajā gadījumā, trīs. 

Tātad mans pirmais ieraksts notiek būt suņiem pie nulles indeksu, un kas būs Milo. Tad suņi vienā indeksā būs dumjš, mīļš mochi, un pēc tam pēdējais ierakstu, trešais ieraksts pie divām indeksu, būs gudrs, salds Elphie. Jūs pamanīsiet, ka formātā aizpildīšanai šajā masīvā ir ļoti daudz, piemēram, kā jūs varētu paziņot jebkuru citu mainīgo kur Jums ir mainīgā nosaukumu, kam seko vērtība, ka jūs vēlaties saglabāti tajā. Vienīgā atšķirība šī lieta ir tā, ka jums ir jāatceras, lai indeksu vērtības kvadrātiekavās. Un tur mums ir mūsu trīs mīļākie suņiem. 

Bet diemžēl, ir pienācis laiks lai saņemtu atpakaļ ķeizaram. Atcerieties, ka pareiza izmantošana par lietotājs būs iet ne tikai nosaukums programmas ./caesar, bet arī galvenais, ka viņi vēlas, lai pārslēgtos to teksta, ko. Tātad tas nozīmē, ka argc jābūt divi. Tām jāiztur in two-- ne vairāk, ne mazāk nekā divas komandrindas argumentus. 

Tagad, ko par argv? Nu, mēs jau zinām, ka masīvs būs garums divas, bet to, kas ietverts katrā elementā? Nu, pirmais elements būs ./caesar, un pēc tam nākamais elements, kas notiek pie satur atslēgu, ka lietotājs drukāti. Tagad, ja viņi to izmanto pareizi par izmantošanas ķeizaru, tad viņi gatavojas ierakstīt numuru. Bet pat ja raksturs ka tie tips ir skaitlis, tas ir datu tipa virknes. 

Tātad, kā mēs pārvērst ka string līdz veselam skaitlim? Tā teikt, man ir num, virkne, satur virkni 50. Ja es gribu, lai pārvērstu ka līdz veselam skaitlim, tad es vienkārši pasludināt jaunu mainīgo, kas ir skaitlim i, aicinot atoi. Es iet manā stīgu mainīgo, num, un tad es tam satur skaitli 50. Pārliecinieties, lai pārbaudītu vīru lapas par atoi funkcijas lai pārbaudītu, ko bibliotēka tā in, kā arī to, kas vērtība, ko tā atgriezīsies, ja virkne pagājis jo nesatur visus numurus. 

Tāpēc tagad, ka mēs esam gotten galvenais, nākamais solis ir iegūt teksta, no lietotāja. Tagad tas ir gatavojas būt mazāk sarežģīta nekā navigāciju ap komandrindas argumentus. Viss, kas mums jādara, ir zvans getstring funkcija pamudinājusi lietotājam dotu mums virkne, bet atcerieties lai pārbaudītu specifikācijas, kā mēs varētu vēlēties, lai nekavējoties lietotājam par to. 

Tagad mēs nonākam pie sirds problem-- kā šifrēt šo teksta,. Nu, pirmkārt, parunāsim par to, kā lai šifrēt vienu rakstzīmi laikā, un tad mēs jārisina kā atkārtot pār visu teksta,. Es esmu uzrakstījis dažas pseudocode par Caesar problēmu. Es aicinu jūs, lai Uzrakstiet savu, kā arī. Tas varētu neizskatās identisks raktuves, un tas ir OK, bet, kamēr kā vispārējā iecere ir tāda pati. 

Pirmie trīs soļi mēs jau esam darījuši. Mēs esam gotten atslēgu komandrindas arguments, mēs esam izrādījās, ka atslēga stājas skaitlim, un mēs esam pamudināja lietotājam par teksta, ka viņi vēlas, lai šifrēt. Tātad nākamais lielais rieciens ir tas, ka par katru rakstzīmi no teksta, virknes, ja tas ir alfabēta, mēs vēlamies saglabāt tā lieta un novirzīt to. Ar saglabāt lieta, ko es domāju, ka visiem lielajiem burtiem burti jāpaliek Augšējais lieta un visi mazie burti jāpaliek mazie burti. Tāpēc tad, kad mēs pāriet tiem, tad mēs izdrukāt ciphertext. 

Šeit ir trīs funkcijas, kas gatavojas lai noderēs šo problēmu. Atcerēties augšas, kad es deva piemērs novirzot tas ir CS50? Atcerieties, ka 50 un izsaukuma zīme nebija maiņu? Tātad, kā mēs varam pateikt, vai mēs nepieciešams pāriet vēstuli vai ne? Nu, "ir alfa," ja jums iet tas raksturs, atgriezīsies taisnība, ja tas raksturs ir burts un viltus citādi. Lai palīdzētu jums ar saglabājot kapitalizācija ir funkcijas "ir augšējais "un" ir mazāks. " 

Šīs divas funkcijas arī veikt vienā raksturs kā ieejas un atgriešanās jums Būla, nu patiess vai nepatiess atkarībā no tā, vai šo raksturu ir lielie burti vai mazo burtu. Tāpēc, ka "ir augšējā" un "ir zemāks "ir Būla funkcijas, kas nozīmē, ka viņi atgriežas jums Būla, Jūs varat izmantot šos jūsu apstākļos. Tātad, šeit ir koda fragments, ka tikai drukā vēstuli, ja tas ir lielie burti. Tāpēc es esmu atzīts par manu raksturu vēstule tiks augšējo lieta zed un tad, ja "ir augšējie" atgriežas taisnība, tad es izdrukāt šo vēstuli. 

Atgriežoties pie mūsu vienkāršu piemēru novirzot alfabētu ar atslēgu divi, kā mēs faktiski nokļūt, ka uz darbu? Nu, izrādās, ka varoņi un veseli skaitļi ir ļoti cieši saistītas. Katram no viņiem ir vesels vērtība saistīta ar to konstatēts ASCII tabulā, kur katra varoņa ASCII tiek parādīta vērtība. Tātad augšējo gadījumā Atbilst uz ASCII vērtību 65 un mazie burti a to ASCII vērtību 97. 

Jūtieties brīvi, lai uzmeklētu jebkuru ASCII diagramma online redzēt šīs vērtības pats. Tātad, ko tas nozīmē, ka mēs varam ņemt raksturu lielo burtu A, pievienot vesels skaitlis divas, lai to, un pēc tam iegūt raksturs augšējais lieta C, kā rezultātā. Tas ir tāpēc, ka 65, tad ASCII vērtība kapitāla A, plus 2, dod mums 67, kas atbilst raksturam lielo burtu C 

Diemžēl, lietas nebūs gluži tik vienkārši. Mums vienādojumu, kas mums ir jāapsver. Te tā stāsta mums, ka i-ciphertext vēstule atbilst kārtējam teksta, vēstule, plus key-- visi, kas, modulāra 26. Kāpēc ir tā, ka lieta? Iesim atpakaļ uz mūsu piemēram, no pirms, kur kapitāls A, plus 2, dod mums kapitāla C. 

Tātad, piemērojot vienādojumu ka specifikācija dod mums, tad pieņemsim kapitāla A plus 2 un mod, ka līdz 26. Tātad kapitāls A, kad man to šie vienpēdiņas, ļauj man, lai ārstētu to kā vesels skaitlis, tā, ka ļauj man mest tās ASCII vērtību, 65. 65 plus 2 ir 67. 67 mod 26 dod mums 15, bet tas nav īsti jēgas, jo mēs zinām, ka kapitāls C ASCII vērtība ir 67, nevis 15. Tātad, kā mēs saskaņot, ka? 

Nu, šeit es gribētu postulēt jēdziens no alfabētiskajā sarakstā. Tātad mēs jau runājām par to, kā Katram no viņiem ir sava ASCII vērtību, bet es gribētu teikt, labi, pieņemsim domā par katru rakstzīmi, kam arī alfabētisks indekss, kur A, piemēram, kā pirmo alfabēta burtu, ir alfabētisko indeksu nulles. Tāpēc tagad pieņemsim piemēro pats vienādojums kā iepriekš, bet, izmantojot alfabētisko rādītāju. 

Tātad ir nulle, jo mēs esam definēts. Tātad, ņemot nulle plus divi, mod 26, tas ir divi, mod 26, kas dod mums divas. Un labi, runājot par alfabētisks indekss, C ir trešais burts alfabēts, lai atbilstu ar alfabētiskajā sarakstā divi. Tāpēc šķiet, ka, izmantojot alfabētisks indekss šajā gadījumā faktiski dod mums pareizu rezultātu. 

Tāpēc tagad pieņemsim pārbaudīt, lai redzēt, ja vienādojums darbiem ar alfabētiskajā sarakstā. Y alfabētiskais rādītājs ir 24, jo otrā līdz pēdējam alfabēts. Tātad 24 plus mūsu atslēga divi dod mums 26. 26 mod 26 dod mums 0, kas, laimīgs mums, ir alfabētisko indekss A. Tik cerams, tas ir pietiekami, ka pierādījums alfabētisko indeksu metode darbojas. Ja nē, justies brīvi izmēģināt daži piemēri savu. 

Lai pareizi wrap ap alfabēts un piemērot Caesar vienādojumu, tad mēs zinām, ka mums ir nepieciešams, lai galā ar burtu indeksiem. Bet sākam ar ASCII vērtībām, un tikai tad mēs pēc tam konvertēt uz alfabētisko indeksu. No turienes, lai varētu drukāt, mums vajag galā ar ASCII vērtībām vēlreiz. Tāpēc mums ir nepieciešams, lai noskaidrotu, kā aiziet no ASCII alfabēta un no alfabētiskā ASCII. 

Tāpēc es atstāt to jums, lai noskaidrotu modelis starp raksturu un tās alfabēta indekss un tā ASCII vērtība. Tagad, atcerieties, ka, pat ja Šī tabula tiesības uz slaidu parāda lielos burtus, mēs arī ir jāapsver, vai atšķirīgs modelis attiecas par mazajiem burtiem. 

Tāpēc tagad, ka mēs esam izpētījuši, kā novirzīt vienu rakstzīmi, tad viss, kas mums ir jādara, ir skala, kas līdz iet pāri visam parastā teksta. Tātad teksta, ir virkne. Lucky mums, virkne ir patiešām tikai masīvs rakstzīmes, tāpēc, lai piekļūtu katru rakstzīmi no virknes, viss, kas jums jādara, ir izmantot masīvu notācija. Teikt, man ir mainīgo tipu stīgu sauc "text = 'tas ir CS50." 

Nu, pēc tam, lai piekļūt katru rakstzīmi, visi man ir jādara ar mainīgais teksts ir teikt labi, teksts nulles indeksu, kas atbilst kapitāls T. Teksts pie indeksa viens sakrīt ar mazo burtu h. Vēl viena noderīga funkcija ir stīgu garuma funkcija. Tik iet ar virknes ka funkcija atgriezīsies vesels skaitlis, garums no minētā virkni. 

Tagad, kad mēs esam runājuši par visi šie dažādie elementi, pieņemsim viņus atpakaļ kopā. Tāpēc atgriežas nu manu pseudocode kodu vai jūsu pseudocode un iet cauri, un pārliecinieties, ka jums zināt, kā to darīt katru lieta. Getting atslēgu izmantojot argc un argv, pagriežot atslēgu veselam skaitlim A uz i, pamudinot uz teksta,, getstring, un pēc tam, atkārtojot pār katru rakstura teksta, string, saglabājot gadījumu katru rakstzīmi un novirzot šo raksturu ar atslēgu, nodrošinot, ka jūs esat ietīšana ap alfabētu, beidzot drukāšanas šo ciphertext. Mans vārds ir Amila, un tas bija Cēzars. 