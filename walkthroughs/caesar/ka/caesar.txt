Amila: მოდით დაძლევის Caesar. კეისრის, ჩვენ არ დავუშვებთ შესახებ კოდირება საიდუმლო გაგზავნა. მოდით ჩაყვინთვის უფლება და გამოიყურება ჩვენს to-dos ამ პრობლემას. ასე რომ, პირველი, მივიღებთ გასაღები შესახებ. მაშინ მივიღებთ plaintext რომ მათ სურთ კოდირება. ამის შემდეგ, ჩვენ encipher ეს მათთვის, და ბოლოს, ჩვენ ბეჭდვა მათი ciphertext. 

მოდით დავიწყოთ მაგალითი. ამბობენ, რომ თქვენ სურდა encode მთელი ანბანი ერთად გასაღები ორი. ისე, თქვენი მთელი ანბანი გვინდა უბრალოდ გადაინაცვლებს წერილები. ასე რომ encode C, B, D, C და E, ასე შემდეგ და ასე შემდეგ, სანამ X, რომელიც აკოდირებს to Z ან zed, დამოკიდებულია სადაც თქვენ ეხლა. მაშინ Y მაშინ გადაიტანოს ყველა გზა, გადაიტანოთ გარშემო ანბანი მისაღებად, და მაშინ საბოლოოდ ბოლო წერილი ანბანი, Z, zed, რომ encode ბ 

შენ, რომ? მოდით შევხედოთ რამდენიმე მაგალითი. პირველ მაგალითად აქ არის ძალიან ჰგავს რაც ჩვენ განმარტა, ზემოთ. ასე რომ, თუ encode ზოგიერთი მონაკვეთის ანბანი, მეშვეობით L, გასაღებით ორი, მაშინ მე უბრალოდ ჩემი მთელი ანბანი გადაინაცვლებს ორი ასო. 

ამის შემდეგ, ჩემი მომავალი მაგალითად, გასაღები არის კიდევ ორი, ასე რომ თქვენ უნდა მაინც ვიცი რომელიც წერილებს ველოდებით. მაგრამ აქ ეს ფრაზა. ეს არის CS50. ასე რომ თქვენ შეამჩნევთ, რომ მე შეინარჩუნოს იმ შემთხვევაში, ჩემი წერილები, ასე რომ ნებისმიერი ზედა ასოების ასევე ზედა შემთხვევაში წერილები ciphertext. და ნებისმიერი ამას წერილები plaintext ასევე ამას წერილები ciphertext. მაგრამ მე შენარჩუნება წერილები და ნებისმიერი ძახილის ნიშნები ან რაიმე სხვა სასვენი იგივე. 

ასე რომ, ახლა, რომ ჩვენ გვაქვს გრძნობა როგორ პროგრამა მუშაობს, მოგერიდებათ წასვლა აწარმოებს კიდევ რამდენიმე მაგალითები საკუთარი, სურვილის შემთხვევაში. დავიწყოთ მიღების გასაღები შესახებ. ტრადიციულად, ერთად სხვა პრობლემები, ჩვენ უკვე მიჩვეული მიღების ნებისმიერი ციფრები, რომ ჩვენ უნდა მიერ რითაც შესახებ ფუნქცია getint. მაგრამ ამ დროს ჩვენ რეალურად აპირებს გამოიყენოთ ბრძანების არგუმენტი და ახალი ფუნქცია მოუწოდა atoi. 

როდესაც თქვენ აწარმოებს მთავარი პროგრამა C, მაშინ იგი იღებს ორ parameters-- int argc, რომელიც არის რიგი არგუმენტები გავიდა, და შემდეგ argv, მასივი სტრიქონები, რომელიც შეიცავს სიაში ყველა არგუმენტები გავიდა. თქვენ არ მკაფიოდ აქვს განაცხადოს ეს ცვლადი. ისინი გამოთვლილია თქვენ მიერ შემდგენელი. სწორი გამოყენება, ეს იქნება for argc უნდა იყოს ორი, ამ შემთხვევაში, იმიტომ, რომ მომხმარებელს აქვს გაივლის ზარი პროგრამა, ./caesar, და მაშინ გასაღები, რაც ნომერი მათ სურთ. ეს ნიშნავს, რომ argc უნდა იყოს ორი იმისათვის, რომ სწორი გამოყენების Caesar უნდა იყოს შესრულებული. 

მოდით შევხედოთ მაგალითს. ამბობენ, რომ მე უკვე დაწერილი და შედგენილი პროგრამა მოუწოდა BlastOff. ასე რომ, თუ მე გაიქცა ბრძანების ./blastoff გუნდის სარაკეტო, კარგად, მაშინ, argc იქნება სამი იმიტომ, რომ მე გავიდა სამი განსხვავებული არგუმენტები. მაშინ argv ასე გამოიყურება. ეს მასივი, და ეს შეიცავს თითოეული სამი strings. ./blastoff პირველ ინდექსი, გუნდი მომდევნო, და სარაკეტო ბოლო. 

მოდით ვისაუბროთ კოლექტორები წ. მასივები მონაცემები სტრუქტურებს, გამართავს მრავალჯერადი ღირებულებების იგივე ტიპის. ეს იქნება მოსახერხებელი, როდესაც ჩვენ გვაქვს სიები რიცხვებით ან სიმები. უბრალოდ გვახსოვდეს, რომ მათ აქვთ უნდა იყოს იგივე ტიპის. კომპიუტერულ მეცნიერებაში, ჩვენ მიყვარს დათვლის ნულიდან, ასე მახსოვს, რომ კოლექტორები ასევე ნულოვანი ინდექსირებული. ამიტომ პირველ ელემენტს ჩემი მასივი იქნება ინდექსი ნულოვანი. ასე რომ, ამ შემთხვევაში, როდესაც მე მაქვს მასივი სიგრძე ოთხი, მაშინ ბოლო ინდექსი ბოლო ელემენტს ჩემი მასივი რეალურად იქნება ინდექსი სამი, ოთხი. იმიტომ, რომ მახსოვს, ჩვენ დაიწყება დათვლის დროს ნულოვანი. 

აი მაგალითად, თუ როგორ შეიძლება შეიქმნას მასივი საკუთარი. ასე რომ ვთქვათ, მინდოდა შესანახად ჩემი სამი საყვარელი ძაღლი სახელები. მაშინ მე შექმნათ მასივი strings. ასე რომ, მე ვაცხადებ ტიპის, სიმებიანი და მაშინ დააყენა სახელი მასივი, ძაღლი, და შემდეგ იმ მოედანზე ფრჩხილებში დააყენა ზომა მასივი, ამ შემთხვევაში, სამი. 

ასე რომ, ჩემი პირველი შესვლის აპირებს უნდა იყოს ძაღლი ინდექსი ნულოვანი, და რომ იქნება Milo. მაშინ ძაღლების ინდექსი ერთი იქნება goofy, darling Mochi, და შემდეგ ბოლო შესვლის, მესამე შესვლის ინდექსი ორი, იქნება მიმზიდველი, ტკბილი Elphie. თქვენ შეამჩნევთ, რომ ფორმატი შევსების ამ მასივი ძალიან ჰგავს, თუ როგორ შეიძლება განაცხადოს ნებისმიერი სხვა ცვლადი, სადაც თქვენ გაქვთ ცვლადის სახელი მოჰყვა ღირებულება, რომელიც გსურთ ინახება იგი. ერთადერთი განსხვავება ამ შემთხვევაში, რომ თქვენ უნდა გვახსოვდეს, რომ დააყენა ინდექსი ღირებულება კვადრატულ ფრჩხილებში. და იქ ჩვენ ჩვენი სამი საყვარელი ძაღლი. 

მაგრამ ვაი, რომ დროა დავუბრუნდეთ Caesar. გახსოვდეთ, რომ სწორად გამოყენება, რომ მომხმარებელი იქნება გავლით არა მხოლოდ სახელი პროგრამა ./caesar, მაგრამ ასევე გასაღები, რომ მათ სურთ გადაიტანოს მათი დაუცველი მიერ. ეს ნიშნავს, რომ argc უნდა იყოს ორი. მათ უნდა გაიარონ in two-- არც მეტი, არც არანაკლებ ორი ბრძანების არგუმენტები. 

ახლა, რაც შეეხება argv? ასევე, ჩვენ უკვე ვიცით, რომ array იქნება სიგრძის ორი, მაგრამ რა შეიცავს თითოეულ ელემენტს? ისე, რომ პირველი ელემენტი იქნება ./caesar, და შემდეგ მომდევნო ელემენტს აპირებს შეიცავდეს გასაღები რომ მომხმარებლის აკრეფილი. ახლა, თუ ისინი გამოიყენება სწორად გამოყენების კეისრის მაშინ ისინი აპირებენ აკრიფოთ ნომერი. მიუხედავად იმისა, რომ ხასიათი რომ ისინი აკრიფოთ არის ნომერი, ეს მონაცემთა ტიპის სიმებიანი. 

ასე რომ, ჩვენ გარდაქმნას, რომ სიმებიანი რიცხვი? ასე რომ ვთქვათ, მე მაქვს num, სიმებიანი, შემცველი სიმებიანი 50. თუ მინდა, რომ გარდაქმნას, რომ მთელი რიცხვი, მაშინ მე უბრალოდ აცხადებენ, ახალი ცვლადი, რომელიც მთელი მე მოუწოდებდა atoi. მე გაივლის ჩემი სიმებიანი ცვლადი, num და მერე კი შეიცავს ნომერი 50. დარწმუნდით, რომ კაცი გვერდები atoi ფუნქცია შეამოწმეთ რომელიც ბიბლიოთეკა ეს წელს, ისევე როგორც რა ვაფასებთ მას დაბრუნდება თუ სიმებიანი გავიდა in არ შეიცავს ნომრები. 

ასე რომ, ახლა რომ ჩვენ მიღებული გასაღები, შემდეგი ნაბიჯი მიიღოს დაუცველი შესახებ. ახლა, ამ აპირებს იყოს ნაკლებად რთული ვიდრე სანავიგაციო გარშემო ბრძანების ხაზი არგუმენტები. ყველა ჩვენ უნდა გავაკეთოთ არის ზარი GetString ფუნქცია შეეკითხება მომხმარებელს მისცეს us სიმებიანი, მაგრამ მახსოვს, უნდა შეამოწმოს სპეციფიკაციები, თუ როგორ დაგვჭირდება უბიძგონ შესახებ, რომ. 

ახლა ჩვენ მოვიდა გულში პრობლემის როგორ encipher plaintext. პირველ რიგში, მოდით ვისაუბროთ, თუ როგორ to encipher ერთი ხასიათი დროს, და მაშინ ჩვენ ის, თუ როგორ გადაურბინოთ მთელი plaintext. მე დაწერილი ზოგიერთი pseudocode იმ Caesar პრობლემა. მე მოგიწოდებთ თქვენ დაწეროთ თქვენი საკუთარი, ასევე. ეს შეიძლება არ გამოიყურება იდენტურია ჩემია და რომ კარგადაა, მაგრამ სანამ როგორც იდეა არის იგივე. 

პირველი სამი ნაბიჯი ჩვენ უკვე გავაკეთეთ. ჩვენ მიღებული გასაღები ბრძანება ხაზი არგუმენტი, ჩვენ აღმოჩნდა, რომ გასაღები მთელი რიცხვი, და ჩვენ აიძულა შესახებ, რომ დაუცველი რომ მათ სურთ encipher. ასე რომ, მომავალი დიდი ბლოკი ის არის, რომ თითოეული ხასიათი ამ დაუცველი string, თუ ეს ანბანური, ჩვენ გვინდა, რომ შეინარჩუნოს მისი საქმე და გადაიტანოს ის. By შეინარჩუნოს შემთხვევაში, რაც მე იმას, რომ ყველა შემთხვევაში ზედა წერილები უნდა დარჩეს ზედა იმ შემთხვევაში და ყველა ამას წერილები უნდა დარჩეს ამას. ასე რომ, მას შემდეგ, რაც ჩვენ გადაიტანოს იმ, მაშინ ჩვენ ბეჭდვა ciphertext. 

აქ არის სამი ფუნქციები, რომლებიც აპირებენ მოდის მოსახერხებელი ამ პრობლემას. დამახსოვრება up ზემოთ, როდესაც მივეცი მაგალითად გადასვლის ეს არის CS50? გახსოვდეთ, რომ 50 და ძახილის ნიშნის არ გადაიტანოს? მაშ, როგორ შეგვიძლია ვუთხრათ თუ არა ჩვენ უნდა გადაიტანოს წერილი თუ არა? ისე, "ალფა", თუ თქვენ გაიაროს ეს ხასიათი, დაბრუნდება ნამდვილი თუ ეს ხასიათი წერილში და ცრუ სხვაგვარად. რათა დაგეხმაროთ შენარჩუნების კაპიტალიზაცია ფუნქციების "არის ზედა "და" ქვედა ". 

ეს ორი ფუნქცია ასევე მიიღოს ერთ ხასიათი, როგორც შეყვანის და დაბრუნებას თქვენ ლოგიკური, ჭეშმარიტი ან მცდარი დამოკიდებულია თუ არა, რომ ხასიათი არის ზედა ან ქვედა შემთხვევაში. იმის გამო, რომ "არის ზედა" და " ქვედა "ლოგიკური ფუნქციები, რაც იმას ნიშნავს, რომ ისინი დაბრუნდებიან თუ არა ლოგიკური, თქვენ შეგიძლიათ გამოიყენოთ ეს თქვენს პირობებს. ასე რომ, აქ სნიპეტის კოდი, რომელიც მხოლოდ ბეჭდავს წერილს, თუ ის ზედა შემთხვევაში. ამიტომ მე განაცხადა ჩემი ხასიათი წერილი უნდა ზედა შემთხვევაში zed და მაშინ, თუ "არის ზედა" ბრუნდება მართალია, მერე ბეჭდვა, რომ წერილში. 

უკან ჩვენი მარტივი მაგალითი გადასვლის ანბანი მიერ საკვანძო ორი, თუ ჩვენ რეალურად მიიღოს, რომ მუშაობს? ისე, გამოდის, რომ გმირები და რიცხვებით ძალიან მჭიდროდაა დაკავშირებული. თითოეული ხასიათი აქვს მთელი მნიშვნელობა უკავშირდება იგი ნაპოვნი ASCII სქემა, სადაც თითოეული გმირის ASCII ღირებულება არის ნაჩვენები. ასე რომ, ზედა შემთხვევაში შეესაბამება რომ ASCII ღირებულება 65 და ამას უნდა ASCII ღირებულება 97. 

მოგერიდებათ ეძებოთ ნებისმიერი ASCII ჩარტში ონლაინ ვხედავ ამ ფასეულობების თავს. ასე რომ, თუ რას ნიშნავს, რომ ჩვენ შეგვიძლია მიიღოს ხასიათი ზედა შემთხვევაში A, რჩეულებში მთელი ორი, და შემდეგ მიიღოს ხასიათი ზედა შემთხვევაში C შედეგად. ეს იმიტომ, რომ 65, ASCII მნიშვნელობის კაპიტალი, პლუს 2, გვაძლევს 67, რომელიც შეესაბამება ხასიათის ზედა C. 

სამწუხაროდ, რამ არ საკმაოდ ასე მარტივი. ჩვენ გვაქვს განტოლება, რომელიც ჩვენ უნდა განიხილოს. აქ იგი გვეუბნება, რომ შ ciphertext წერილი შეესაბამება შ plaintext წერილი, პლუს key-- ყველა რომ, მოდულური 26. რატომ არის, რომ საქმე? მოდით დავუბრუნდეთ ჩვენს მაგალითს ადრე, სადაც დედაქალაქში, პლუს 2, გვაძლევს კაპიტალის C. 

ასე რომ, გამოყენების განტოლება, რომელიც დაზუსტება გვაძლევს, შემდეგ ავიღოთ კაპიტალი plus 2 და თავდაცვის სამინისტროს, რომ 26. ასე რომ, კაპიტალის, როდესაც მე ამას იმ ერთ ციტატა ნიშნები, საშუალებას ჩემთვის მკურნალობა, როგორც მთელი რიცხვი, ამიტომ, რომელიც საშუალებას მე რომ მიიღო ის, თავისი ASCII ღირებულება, 65. 65 + 2 67. 67 mod 26 გვაძლევს 15 მაგრამ ეს ნამდვილად არ აქვს აზრი, რადგან ჩვენ ვიცით, რომ დედაქალაქში C ASCII ღირებულება 67, არა 15. ასე რომ, როგორ შევრიგდეთ, რომ? 

ისე, აქ მინდა საზღვრებიდან ცნება ანბანურ საძიებელს. ასე რომ, ჩვენ უკვე ვისაუბრეთ, თუ როგორ თითოეული ხასიათი აქვს თავისი ASCII ღირებულება, მაგრამ მე მინდა ვთქვა, კარგად, მოდით ვიფიქროთ თითოეული ხასიათი ასევე აქვს ანბანური ინდექსი, სადაც A მაგალითად, როგორც პირველი წერილი ანბანი, აქვს ანბანურ საძიებელს ნულოვანი. ასე რომ, ახლა მოდით ვრცელდება იგივე განტოლება, როგორც ადრე, მაგრამ მისი გამოყენება ანბანურ საძიებელს. 

ასე რომ, არის ნულოვანი, რადგან ჩვენ განსაზღვრული. ასე რომ, შემდეგ იღებენ ნულოვანი პლუს ორი, mod 26, რომ ორი, mod 26, რომელიც გვაძლევს ორი. და ასევე, იმ თვალსაზრისით, ანბანური ინდექსი, C მესამე წერილი ანბანი, რომელიც შეესაბამება ანბანური ინდექსი ორი. ასე რომ, როგორც ჩანს, გამოყენებით ანბანური მაჩვენებელი ამ შემთხვევაში რეალურად გვაძლევს სწორი შედეგი. 

ახლა მოდით შეამოწმეთ, თუ განტოლება სამუშაოები ერთად ანბანურ საძიებელს. Y ის ანბანური მაჩვენებელი არის 24, როგორც მეორე ბოლო წერილი ანბანი. ასე რომ, მაშინ 24 პლუს ჩვენი გასაღები ორი გვაძლევს 26. 26 mod 26 გვაძლევს 0, რაც, იღბლიანი ჩვენთვის, ანბანური მაჩვენებელი ა ასე რომ, იმედია, რომ მტკიცებულება საკმარისი, რომ ანბანური ინდექსი მეთოდი მუშაობს. თუ არა, შეგიძლიათ ცდილობენ out რამდენიმე მაგალითს საკუთარი. 

იმისათვის, რომ სათანადოდ გადაიტანოთ გარშემო ანბანი და ვრცელდება Caesar განტოლება, ჩვენ ვიცით, რომ ჩვენ უნდა გაუმკლავდეთ ანბანური ინდექსები. მაგრამ ჩვენ დავიწყებთ ASCII ღირებულებები, და მხოლოდ ამის შემდეგ ჩვენ შემდეგ კონვერტირება ანბანურ მაჩვენებელს. იქიდან, რათა ბეჭდვა, ჩვენ გვჭირდება გამკლავება ASCII ღირებულებების ერთხელ. ამიტომ, ჩვენ უნდა გაერკვნენ, თუ როგორ გადასვლა ASCII ანბანის და ანბანური to ASCII. 

ასე რომ დავტოვო ეს თქვენ უნდა გაერკვნენ ნიმუში შორის ხასიათი და მისი ანბანური ინდექსი და მისი ASCII ღირებულება. ახლა, მახსოვს, რომ მიუხედავად იმისა, ამ მაგიდასთან უფლება slide აჩვენებს ასოებით, ჩვენ ასევე უნდა განიხილოს თუ არა სხვადასხვა ნიმუში ვრცელდება ქვედა შემთხვევაში სიმბოლო. 

ასე, რომ ახლა უკვე figured out როგორ უნდა გადაიტანოს ერთი ხასიათი, მაშინ ყველა ჩვენ უნდა გავაკეთოთ არის მასშტაბის, up წასვლა მთელ plaintext. ასე რომ დაუცველი სიმებიანი. Lucky ჩვენთვის, string მართლაც მხოლოდ მასივი გმირები, ასე რომ, იმისათვის, რათა შეამოწმონ ყოველ ხასიათი სიმებიანი, ყველა თქვენ უნდა გააკეთოთ არის გამოიყენოს მასივი notation. მე მაქვს ცვლადი ტიპის სიმებიანი მოუწოდა "text = 'ეს არის CS50." 

კარგად, მაშინ, იმისათვის, რომ წვდომის თითოეული ხასიათი, ყველა მე უნდა გააკეთოს ცვლადი ტექსტი ვთქვა, ასევე, ტექსტი ინდექსი ნულოვანი, რომ შეესაბამება კაპიტალის T. ტექსტი ინდექსი ერთ-ერთი შეესაბამება ქვედა შემთხვევაში თ. კიდევ ერთი სასარგებლო ფუნქცია სიმებიანი სიგრძე ფუნქცია. ასე გავლის სიმებიანი რომ ფუნქცია დააბრუნებს რიცხვი, სიგრძეზე რომ სტრიქონს. 

ახლა, რომ ჩვენ ვისაუბრეთ ყველა ამ სხვადასხვა ელემენტები, მოდით დააყენა მათ უკან ერთად. ასე რომ დაბრუნდეს ან ჩემი pseudocode კოდი ან pseudocode და გაიაროს და დარწმუნდით, რომ თქვენ თუ როგორ უნდა გავაკეთოთ თითოეული რამ. მიღების გასაღები გამოყენებით argc და argv, გარდამტეხი გასაღები შევიდა რიცხვი, რომელიც I, რითაც დაუცველი, getstring, და შემდეგ iterating ყოველ ხასიათი დაუცველი string, შენარჩუნების შემთხვევაში თითოეული ხასიათი და გადავიდა, რომ ხასიათი გასაღები, უზრუნველსაყოფად, რომ თქვენ შესაფუთი გარშემო ანბანი, საბოლოოდ დაბეჭდვის რომ ciphertext. ჩემი სახელი არის Amila, და ეს იყო Caesar. 