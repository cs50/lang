1
00:00:00,000 --> 00:00:00,760

2
00:00:00,760 --> 00:00:02,270
>> Amila: მოდით დაძლევის Caesar.

3
00:00:02,270 --> 00:00:06,110
კეისრის, ჩვენ არ დავუშვებთ შესახებ
კოდირება საიდუმლო გაგზავნა.

4
00:00:06,110 --> 00:00:09,780
მოდით ჩაყვინთვის უფლება და გამოიყურება
ჩვენს to-dos ამ პრობლემას.

5
00:00:09,780 --> 00:00:12,210
ასე რომ, პირველი, მივიღებთ გასაღები შესახებ.

6
00:00:12,210 --> 00:00:15,210
მაშინ მივიღებთ plaintext
რომ მათ სურთ კოდირება.

7
00:00:15,210 --> 00:00:21,380
ამის შემდეგ, ჩვენ encipher ეს მათთვის,
და ბოლოს, ჩვენ ბეჭდვა მათი ciphertext.

8
00:00:21,380 --> 00:00:23,600
>> მოდით დავიწყოთ მაგალითი.

9
00:00:23,600 --> 00:00:26,920
ამბობენ, რომ თქვენ სურდა encode
მთელი ანბანი ერთად გასაღები ორი.

10
00:00:26,920 --> 00:00:31,360
ისე, თქვენი მთელი ანბანი გვინდა
უბრალოდ გადაინაცვლებს წერილები.

11
00:00:31,360 --> 00:00:37,060
ასე რომ encode C, B,
D, C და E, ასე შემდეგ და ასე შემდეგ,

12
00:00:37,060 --> 00:00:42,470
სანამ X, რომელიც აკოდირებს to Z
ან zed, დამოკიდებულია სადაც თქვენ ეხლა.

13
00:00:42,470 --> 00:00:47,445
მაშინ Y მაშინ გადაიტანოს ყველა გზა,
გადაიტანოთ გარშემო ანბანი მისაღებად,

14
00:00:47,445 --> 00:00:53,256
და მაშინ საბოლოოდ ბოლო წერილი
ანბანი, Z, zed, რომ encode ბ

15
00:00:53,256 --> 00:00:54,660
>> შენ, რომ?

16
00:00:54,660 --> 00:00:56,380
მოდით შევხედოთ რამდენიმე მაგალითი.

17
00:00:56,380 --> 00:01:00,540
პირველ მაგალითად აქ არის ძალიან ჰგავს
რაც ჩვენ განმარტა, ზემოთ.

18
00:01:00,540 --> 00:01:05,560
ასე რომ, თუ encode ზოგიერთი მონაკვეთის
ანბანი, მეშვეობით L, გასაღებით ორი,

19
00:01:05,560 --> 00:01:09,760
მაშინ მე უბრალოდ ჩემი მთელი
ანბანი გადაინაცვლებს ორი ასო.

20
00:01:09,760 --> 00:01:12,230
>> ამის შემდეგ, ჩემი მომავალი მაგალითად,
გასაღები არის კიდევ ორი,

21
00:01:12,230 --> 00:01:15,080
ასე რომ თქვენ უნდა მაინც ვიცი
რომელიც წერილებს ველოდებით.

22
00:01:15,080 --> 00:01:16,400
მაგრამ აქ ეს ფრაზა.

23
00:01:16,400 --> 00:01:18,100
ეს არის CS50.

24
00:01:18,100 --> 00:01:21,090
ასე რომ თქვენ შეამჩნევთ, რომ მე
შეინარჩუნოს იმ შემთხვევაში, ჩემი წერილები,

25
00:01:21,090 --> 00:01:25,600
ასე რომ ნებისმიერი ზედა ასოების ასევე
ზედა შემთხვევაში წერილები ciphertext.

26
00:01:25,600 --> 00:01:27,800
და ნებისმიერი ამას
წერილები plaintext

27
00:01:27,800 --> 00:01:30,640
ასევე ამას
წერილები ciphertext.

28
00:01:30,640 --> 00:01:34,020
მაგრამ მე შენარჩუნება წერილები
და ნებისმიერი ძახილის ნიშნები

29
00:01:34,020 --> 00:01:37,610
ან რაიმე სხვა სასვენი იგივე.

30
00:01:37,610 --> 00:01:40,360
>> ასე რომ, ახლა, რომ ჩვენ გვაქვს გრძნობა
როგორ პროგრამა მუშაობს,

31
00:01:40,360 --> 00:01:43,890
მოგერიდებათ წასვლა აწარმოებს კიდევ რამდენიმე
მაგალითები საკუთარი, სურვილის შემთხვევაში.

32
00:01:43,890 --> 00:01:47,072
დავიწყოთ მიღების
გასაღები შესახებ.

33
00:01:47,072 --> 00:01:48,780
ტრადიციულად, ერთად
სხვა პრობლემები, ჩვენ

34
00:01:48,780 --> 00:01:51,450
უკვე მიჩვეული მიღების
ნებისმიერი ციფრები, რომ ჩვენ

35
00:01:51,450 --> 00:01:54,710
უნდა მიერ რითაც შესახებ
ფუნქცია getint.

36
00:01:54,710 --> 00:01:58,850
მაგრამ ამ დროს ჩვენ რეალურად აპირებს
გამოიყენოთ ბრძანების არგუმენტი

37
00:01:58,850 --> 00:02:01,760
და ახალი ფუნქცია მოუწოდა atoi.

38
00:02:01,760 --> 00:02:05,130
>> როდესაც თქვენ აწარმოებს მთავარი
პროგრამა C, მაშინ იგი

39
00:02:05,130 --> 00:02:08,500
იღებს ორ parameters--
int argc, რომელიც

40
00:02:08,500 --> 00:02:11,670
არის რიგი არგუმენტები
გავიდა, და შემდეგ

41
00:02:11,670 --> 00:02:15,920
argv, მასივი სტრიქონები, რომელიც შეიცავს
სიაში ყველა არგუმენტები

42
00:02:15,920 --> 00:02:16,740
გავიდა.

43
00:02:16,740 --> 00:02:19,740
თქვენ არ მკაფიოდ აქვს
განაცხადოს ეს ცვლადი.

44
00:02:19,740 --> 00:02:22,700
ისინი გამოთვლილია
თქვენ მიერ შემდგენელი.

45
00:02:22,700 --> 00:02:28,160
სწორი გამოყენება, ეს იქნება
for argc უნდა იყოს ორი, ამ შემთხვევაში,

46
00:02:28,160 --> 00:02:32,630
იმიტომ, რომ მომხმარებელს აქვს გაივლის
ზარი პროგრამა, ./caesar,

47
00:02:32,630 --> 00:02:35,570
და მაშინ გასაღები,
რაც ნომერი მათ სურთ.

48
00:02:35,570 --> 00:02:39,920
ეს ნიშნავს, რომ argc უნდა იყოს ორი
იმისათვის, რომ სწორი გამოყენების Caesar

49
00:02:39,920 --> 00:02:41,680
უნდა იყოს შესრულებული.

50
00:02:41,680 --> 00:02:43,590
>> მოდით შევხედოთ მაგალითს.

51
00:02:43,590 --> 00:02:47,760
ამბობენ, რომ მე უკვე დაწერილი და
შედგენილი პროგრამა მოუწოდა BlastOff.

52
00:02:47,760 --> 00:02:52,670
ასე რომ, თუ მე გაიქცა ბრძანების
./blastoff გუნდის სარაკეტო, კარგად, მაშინ,

53
00:02:52,670 --> 00:02:57,750
argc იქნება სამი იმიტომ, რომ მე
გავიდა სამი განსხვავებული არგუმენტები.

54
00:02:57,750 --> 00:02:59,830
მაშინ argv ასე გამოიყურება.

55
00:02:59,830 --> 00:03:03,750
ეს მასივი, და ეს
შეიცავს თითოეული სამი strings.

56
00:03:03,750 --> 00:03:09,640
./blastoff პირველ ინდექსი, გუნდი
მომდევნო, და სარაკეტო ბოლო.

57
00:03:09,640 --> 00:03:11,610
>> მოდით ვისაუბროთ კოლექტორები წ.

58
00:03:11,610 --> 00:03:15,560
მასივები მონაცემები სტრუქტურებს, გამართავს
მრავალჯერადი ღირებულებების იგივე ტიპის.

59
00:03:15,560 --> 00:03:19,980
ეს იქნება მოსახერხებელი, როდესაც ჩვენ
გვაქვს სიები რიცხვებით ან სიმები.

60
00:03:19,980 --> 00:03:23,030
უბრალოდ გვახსოვდეს, რომ მათ აქვთ
უნდა იყოს იგივე ტიპის.

61
00:03:23,030 --> 00:03:25,310
კომპიუტერულ მეცნიერებაში, ჩვენ
მიყვარს დათვლის ნულიდან,

62
00:03:25,310 --> 00:03:29,260
ასე მახსოვს, რომ კოლექტორები
ასევე ნულოვანი ინდექსირებული.

63
00:03:29,260 --> 00:03:34,360
ამიტომ პირველ ელემენტს ჩემი მასივი
იქნება ინდექსი ნულოვანი.

64
00:03:34,360 --> 00:03:37,580
ასე რომ, ამ შემთხვევაში, როდესაც მე მაქვს
მასივი სიგრძე ოთხი,

65
00:03:37,580 --> 00:03:41,350
მაშინ ბოლო ინდექსი
ბოლო ელემენტს ჩემი მასივი

66
00:03:41,350 --> 00:03:44,970
რეალურად იქნება
ინდექსი სამი, ოთხი.

67
00:03:44,970 --> 00:03:48,880
იმიტომ, რომ მახსოვს, ჩვენ
დაიწყება დათვლის დროს ნულოვანი.

68
00:03:48,880 --> 00:03:52,530
>> აი მაგალითად, თუ როგორ
შეიძლება შეიქმნას მასივი საკუთარი.

69
00:03:52,530 --> 00:03:56,440
ასე რომ ვთქვათ, მინდოდა შესანახად ჩემი
სამი საყვარელი ძაღლი სახელები.

70
00:03:56,440 --> 00:03:59,030
მაშინ მე შექმნათ მასივი strings.

71
00:03:59,030 --> 00:04:04,450
ასე რომ, მე ვაცხადებ ტიპის, სიმებიანი და
მაშინ დააყენა სახელი მასივი, ძაღლი,

72
00:04:04,450 --> 00:04:06,450
და შემდეგ იმ მოედანზე
ფრჩხილებში დააყენა ზომა

73
00:04:06,450 --> 00:04:09,260
მასივი, ამ შემთხვევაში, სამი.

74
00:04:09,260 --> 00:04:12,690
>> ასე რომ, ჩემი პირველი შესვლის აპირებს
უნდა იყოს ძაღლი ინდექსი ნულოვანი,

75
00:04:12,690 --> 00:04:14,750
და რომ იქნება Milo.

76
00:04:14,750 --> 00:04:17,850
მაშინ ძაღლების ინდექსი ერთი
იქნება goofy,

77
00:04:17,850 --> 00:04:23,060
darling Mochi, და შემდეგ ბოლო
შესვლის, მესამე შესვლის ინდექსი ორი,

78
00:04:23,060 --> 00:04:26,130
იქნება მიმზიდველი, ტკბილი Elphie.

79
00:04:26,130 --> 00:04:28,610
თქვენ შეამჩნევთ, რომ ფორმატი
შევსების ამ მასივი

80
00:04:28,610 --> 00:04:32,150
ძალიან ჰგავს, თუ როგორ შეიძლება
განაცხადოს ნებისმიერი სხვა ცვლადი, სადაც

81
00:04:32,150 --> 00:04:36,307
თქვენ გაქვთ ცვლადის სახელი მოჰყვა
ღირებულება, რომელიც გსურთ ინახება იგი.

82
00:04:36,307 --> 00:04:38,140
ერთადერთი განსხვავება
ამ შემთხვევაში, რომ თქვენ

83
00:04:38,140 --> 00:04:42,700
უნდა გვახსოვდეს, რომ დააყენა ინდექსი
ღირებულება კვადრატულ ფრჩხილებში.

84
00:04:42,700 --> 00:04:46,420
და იქ ჩვენ ჩვენი
სამი საყვარელი ძაღლი.

85
00:04:46,420 --> 00:04:48,780
>> მაგრამ ვაი, რომ დროა
დავუბრუნდეთ Caesar.

86
00:04:48,780 --> 00:04:52,910
გახსოვდეთ, რომ სწორად გამოყენება, რომ
მომხმარებელი იქნება გავლით არა მხოლოდ

87
00:04:52,910 --> 00:04:57,430
სახელი პროგრამა ./caesar, მაგრამ
ასევე გასაღები, რომ მათ სურთ გადაიტანოს

88
00:04:57,430 --> 00:04:58,850
მათი დაუცველი მიერ.

89
00:04:58,850 --> 00:05:01,540
ეს ნიშნავს, რომ argc უნდა იყოს ორი.

90
00:05:01,540 --> 00:05:07,580
მათ უნდა გაიარონ in two-- არც მეტი, არც
არანაკლებ ორი ბრძანების არგუმენტები.

91
00:05:07,580 --> 00:05:09,050
>> ახლა, რაც შეეხება argv?

92
00:05:09,050 --> 00:05:12,880
ასევე, ჩვენ უკვე ვიცით, რომ
array იქნება სიგრძის ორი,

93
00:05:12,880 --> 00:05:15,270
მაგრამ რა შეიცავს თითოეულ ელემენტს?

94
00:05:15,270 --> 00:05:19,330
ისე, რომ პირველი ელემენტი
იქნება ./caesar,

95
00:05:19,330 --> 00:05:24,190
და შემდეგ მომდევნო ელემენტს აპირებს
შეიცავდეს გასაღები რომ მომხმარებლის აკრეფილი.

96
00:05:24,190 --> 00:05:27,480
ახლა, თუ ისინი გამოიყენება სწორად
გამოყენების კეისრის

97
00:05:27,480 --> 00:05:29,350
მაშინ ისინი აპირებენ აკრიფოთ ნომერი.

98
00:05:29,350 --> 00:05:33,260
მიუხედავად იმისა, რომ ხასიათი
რომ ისინი აკრიფოთ არის ნომერი,

99
00:05:33,260 --> 00:05:35,790
ეს მონაცემთა ტიპის სიმებიანი.

100
00:05:35,790 --> 00:05:40,390
>> ასე რომ, ჩვენ გარდაქმნას, რომ
სიმებიანი რიცხვი?

101
00:05:40,390 --> 00:05:46,680
ასე რომ ვთქვათ, მე მაქვს num, სიმებიანი,
შემცველი სიმებიანი 50.

102
00:05:46,680 --> 00:05:49,000
თუ მინდა, რომ გარდაქმნას, რომ
მთელი რიცხვი, მაშინ მე უბრალოდ

103
00:05:49,000 --> 00:05:53,340
აცხადებენ, ახალი ცვლადი, რომელიც
მთელი მე მოუწოდებდა atoi.

104
00:05:53,340 --> 00:06:01,160
მე გაივლის ჩემი სიმებიანი ცვლადი, num და
მერე კი შეიცავს ნომერი 50.

105
00:06:01,160 --> 00:06:04,350
დარწმუნდით, რომ კაცი
გვერდები atoi ფუნქცია

106
00:06:04,350 --> 00:06:07,990
შეამოწმეთ რომელიც ბიბლიოთეკა ეს
წელს, ისევე როგორც რა ვაფასებთ მას

107
00:06:07,990 --> 00:06:14,550
დაბრუნდება თუ სიმებიანი გავიდა
in არ შეიცავს ნომრები.

108
00:06:14,550 --> 00:06:16,950
>> ასე რომ, ახლა რომ ჩვენ მიღებული
გასაღები, შემდეგი ნაბიჯი

109
00:06:16,950 --> 00:06:19,430
მიიღოს დაუცველი შესახებ.

110
00:06:19,430 --> 00:06:21,170
ახლა, ამ აპირებს
იყოს ნაკლებად რთული

111
00:06:21,170 --> 00:06:23,410
ვიდრე სანავიგაციო გარშემო
ბრძანების ხაზი არგუმენტები.

112
00:06:23,410 --> 00:06:26,190
ყველა ჩვენ უნდა გავაკეთოთ არის ზარი
GetString ფუნქცია

113
00:06:26,190 --> 00:06:29,660
შეეკითხება მომხმარებელს მისცეს
us სიმებიანი, მაგრამ მახსოვს,

114
00:06:29,660 --> 00:06:34,090
უნდა შეამოწმოს სპეციფიკაციები, თუ როგორ
დაგვჭირდება უბიძგონ შესახებ, რომ.

115
00:06:34,090 --> 00:06:36,420
>> ახლა ჩვენ მოვიდა
გულში პრობლემის

116
00:06:36,420 --> 00:06:38,860
როგორ encipher plaintext.

117
00:06:38,860 --> 00:06:42,830
პირველ რიგში, მოდით ვისაუბროთ, თუ როგორ
to encipher ერთი ხასიათი დროს,

118
00:06:42,830 --> 00:06:47,370
და მაშინ ჩვენ ის, თუ როგორ
გადაურბინოთ მთელი plaintext.

119
00:06:47,370 --> 00:06:50,440
მე დაწერილი ზოგიერთი pseudocode
იმ Caesar პრობლემა.

120
00:06:50,440 --> 00:06:52,310
მე მოგიწოდებთ თქვენ
დაწეროთ თქვენი საკუთარი, ასევე.

121
00:06:52,310 --> 00:06:55,900
ეს შეიძლება არ გამოიყურება იდენტურია
ჩემია და რომ კარგადაა, მაგრამ სანამ

122
00:06:55,900 --> 00:06:58,640
როგორც იდეა არის იგივე.

123
00:06:58,640 --> 00:07:00,780
>> პირველი სამი ნაბიჯი
ჩვენ უკვე გავაკეთეთ.

124
00:07:00,780 --> 00:07:03,100
ჩვენ მიღებული გასაღები
ბრძანება ხაზი არგუმენტი,

125
00:07:03,100 --> 00:07:05,510
ჩვენ აღმოჩნდა, რომ გასაღები
მთელი რიცხვი, და ჩვენ

126
00:07:05,510 --> 00:07:09,320
აიძულა შესახებ, რომ დაუცველი
რომ მათ სურთ encipher.

127
00:07:09,320 --> 00:07:12,420
ასე რომ, მომავალი დიდი ბლოკი
ის არის, რომ თითოეული ხასიათი

128
00:07:12,420 --> 00:07:15,070
ამ დაუცველი string,
თუ ეს ანბანური,

129
00:07:15,070 --> 00:07:17,750
ჩვენ გვინდა, რომ შეინარჩუნოს
მისი საქმე და გადაიტანოს ის.

130
00:07:17,750 --> 00:07:20,900
By შეინარჩუნოს შემთხვევაში, რაც მე
იმას, რომ ყველა შემთხვევაში ზედა

131
00:07:20,900 --> 00:07:23,580
წერილები უნდა დარჩეს ზედა
იმ შემთხვევაში და ყველა ამას წერილები

132
00:07:23,580 --> 00:07:25,640
უნდა დარჩეს ამას.

133
00:07:25,640 --> 00:07:29,110
ასე რომ, მას შემდეგ, რაც ჩვენ გადაიტანოს იმ,
მაშინ ჩვენ ბეჭდვა ciphertext.

134
00:07:29,110 --> 00:07:33,100
>> აქ არის სამი ფუნქციები, რომლებიც აპირებენ
მოდის მოსახერხებელი ამ პრობლემას.

135
00:07:33,100 --> 00:07:38,010
დამახსოვრება up ზემოთ, როდესაც მივეცი
მაგალითად გადასვლის ეს არის CS50?

136
00:07:38,010 --> 00:07:41,800
გახსოვდეთ, რომ 50 და
ძახილის ნიშნის არ გადაიტანოს?

137
00:07:41,800 --> 00:07:45,680
მაშ, როგორ შეგვიძლია ვუთხრათ თუ არა ჩვენ
უნდა გადაიტანოს წერილი თუ არა?

138
00:07:45,680 --> 00:07:48,650
ისე, "ალფა", თუ
თქვენ გაიაროს ეს ხასიათი,

139
00:07:48,650 --> 00:07:54,850
დაბრუნდება ნამდვილი თუ ეს ხასიათი
წერილში და ცრუ სხვაგვარად.

140
00:07:54,850 --> 00:07:56,870
რათა დაგეხმაროთ
შენარჩუნების კაპიტალიზაცია

141
00:07:56,870 --> 00:07:59,750
ფუნქციების "არის
ზედა "და" ქვედა ".

142
00:07:59,750 --> 00:08:03,350
>> ეს ორი ფუნქცია ასევე მიიღოს
ერთ ხასიათი, როგორც შეყვანის

143
00:08:03,350 --> 00:08:06,580
და დაბრუნებას თქვენ ლოგიკური,
ჭეშმარიტი ან მცდარი

144
00:08:06,580 --> 00:08:11,280
დამოკიდებულია თუ არა, რომ ხასიათი
არის ზედა ან ქვედა შემთხვევაში.

145
00:08:11,280 --> 00:08:14,610
იმის გამო, რომ "არის ზედა" და "
ქვედა "ლოგიკური ფუნქციები,

146
00:08:14,610 --> 00:08:18,660
რაც იმას ნიშნავს, რომ ისინი დაბრუნდებიან თუ არა ლოგიკური,
თქვენ შეგიძლიათ გამოიყენოთ ეს თქვენს პირობებს.

147
00:08:18,660 --> 00:08:23,490
ასე რომ, აქ სნიპეტის კოდი, რომელიც მხოლოდ
ბეჭდავს წერილს, თუ ის ზედა შემთხვევაში.

148
00:08:23,490 --> 00:08:27,790
ამიტომ მე განაცხადა ჩემი ხასიათი
წერილი უნდა ზედა შემთხვევაში zed

149
00:08:27,790 --> 00:08:33,440
და მაშინ, თუ "არის ზედა" ბრუნდება
მართალია, მერე ბეჭდვა, რომ წერილში.

150
00:08:33,440 --> 00:08:38,200
>> უკან ჩვენი მარტივი მაგალითი
გადასვლის ანბანი მიერ საკვანძო ორი,

151
00:08:38,200 --> 00:08:41,049
თუ ჩვენ რეალურად მიიღოს, რომ მუშაობს?

152
00:08:41,049 --> 00:08:45,770
ისე, გამოდის, რომ გმირები
და რიცხვებით ძალიან მჭიდროდაა დაკავშირებული.

153
00:08:45,770 --> 00:08:48,840
თითოეული ხასიათი აქვს
მთელი მნიშვნელობა უკავშირდება

154
00:08:48,840 --> 00:08:53,260
იგი ნაპოვნი ASCII სქემა,
სადაც თითოეული გმირის ASCII

155
00:08:53,260 --> 00:08:55,380
ღირებულება არის ნაჩვენები.

156
00:08:55,380 --> 00:08:58,940
ასე რომ, ზედა შემთხვევაში შეესაბამება
რომ ASCII ღირებულება 65

157
00:08:58,940 --> 00:09:02,270
და ამას უნდა
ASCII ღირებულება 97.

158
00:09:02,270 --> 00:09:04,940
>> მოგერიდებათ ეძებოთ
ნებისმიერი ASCII ჩარტში ონლაინ

159
00:09:04,940 --> 00:09:07,720
ვხედავ ამ ფასეულობების თავს.

160
00:09:07,720 --> 00:09:12,096
ასე რომ, თუ რას ნიშნავს, რომ ჩვენ შეგვიძლია
მიიღოს ხასიათი ზედა შემთხვევაში A,

161
00:09:12,096 --> 00:09:18,200
რჩეულებში მთელი ორი, და შემდეგ მიიღოს
ხასიათი ზედა შემთხვევაში C შედეგად.

162
00:09:18,200 --> 00:09:23,720
ეს იმიტომ, რომ 65, ASCII
მნიშვნელობის კაპიტალი, პლუს 2,

163
00:09:23,720 --> 00:09:29,960
გვაძლევს 67, რომელიც შეესაბამება
ხასიათის ზედა C.

164
00:09:29,960 --> 00:09:33,480
>> სამწუხაროდ, რამ
არ საკმაოდ ასე მარტივი.

165
00:09:33,480 --> 00:09:36,980
ჩვენ გვაქვს განტოლება, რომელიც
ჩვენ უნდა განიხილოს.

166
00:09:36,980 --> 00:09:43,590
აქ იგი გვეუბნება, რომ შ ciphertext
წერილი შეესაბამება შ plaintext

167
00:09:43,590 --> 00:09:48,900
წერილი, პლუს key--
ყველა რომ, მოდულური 26.

168
00:09:48,900 --> 00:09:50,810
რატომ არის, რომ საქმე?

169
00:09:50,810 --> 00:09:55,430
მოდით დავუბრუნდეთ ჩვენს მაგალითს
ადრე, სადაც დედაქალაქში, პლუს 2,

170
00:09:55,430 --> 00:09:57,590
გვაძლევს კაპიტალის C.

171
00:09:57,590 --> 00:10:01,870
>> ასე რომ, გამოყენების განტოლება, რომელიც
დაზუსტება გვაძლევს,

172
00:10:01,870 --> 00:10:06,660
შემდეგ ავიღოთ კაპიტალი
plus 2 და თავდაცვის სამინისტროს, რომ 26.

173
00:10:06,660 --> 00:10:10,730
ასე რომ, კაპიტალის, როდესაც მე ამას
იმ ერთ ციტატა ნიშნები,

174
00:10:10,730 --> 00:10:14,010
საშუალებას ჩემთვის მკურნალობა, როგორც
მთელი რიცხვი, ამიტომ, რომელიც საშუალებას

175
00:10:14,010 --> 00:10:17,500
მე რომ მიიღო ის, თავისი ASCII ღირებულება, 65.

176
00:10:17,500 --> 00:10:20,080
65 + 2 67.

177
00:10:20,080 --> 00:10:25,210
67 mod 26 გვაძლევს 15
მაგრამ ეს ნამდვილად არ

178
00:10:25,210 --> 00:10:32,590
აქვს აზრი, რადგან ჩვენ ვიცით, რომ
დედაქალაქში C ASCII ღირებულება 67, არა 15.

179
00:10:32,590 --> 00:10:35,580
ასე რომ, როგორ შევრიგდეთ, რომ?

180
00:10:35,580 --> 00:10:39,840
>> ისე, აქ მინდა საზღვრებიდან
ცნება ანბანურ საძიებელს.

181
00:10:39,840 --> 00:10:44,010
ასე რომ, ჩვენ უკვე ვისაუბრეთ, თუ როგორ
თითოეული ხასიათი აქვს თავისი ASCII ღირებულება,

182
00:10:44,010 --> 00:10:48,810
მაგრამ მე მინდა ვთქვა, კარგად, მოდით
ვიფიქროთ თითოეული ხასიათი ასევე აქვს

183
00:10:48,810 --> 00:10:52,230
ანბანური ინდექსი,
სადაც A მაგალითად,

184
00:10:52,230 --> 00:10:58,800
როგორც პირველი წერილი ანბანი,
აქვს ანბანურ საძიებელს ნულოვანი.

185
00:10:58,800 --> 00:11:02,070
ასე რომ, ახლა მოდით ვრცელდება
იგივე განტოლება, როგორც ადრე,

186
00:11:02,070 --> 00:11:05,040
მაგრამ მისი გამოყენება ანბანურ საძიებელს.

187
00:11:05,040 --> 00:11:07,810
>> ასე რომ, არის ნულოვანი, რადგან ჩვენ განსაზღვრული.

188
00:11:07,810 --> 00:11:15,640
ასე რომ, შემდეგ იღებენ ნულოვანი პლუს ორი, mod 26,
რომ ორი, mod 26, რომელიც გვაძლევს ორი.

189
00:11:15,640 --> 00:11:18,780
და ასევე, იმ თვალსაზრისით,
ანბანური ინდექსი,

190
00:11:18,780 --> 00:11:23,930
C მესამე წერილი
ანბანი, რომელიც შეესაბამება

191
00:11:23,930 --> 00:11:26,290
ანბანური ინდექსი ორი.

192
00:11:26,290 --> 00:11:29,850
ასე რომ, როგორც ჩანს, გამოყენებით
ანბანური მაჩვენებელი ამ შემთხვევაში

193
00:11:29,850 --> 00:11:32,840
რეალურად გვაძლევს სწორი შედეგი.

194
00:11:32,840 --> 00:11:35,020
>> ახლა მოდით შეამოწმეთ,
თუ განტოლება სამუშაოები

195
00:11:35,020 --> 00:11:37,210
ერთად ანბანურ საძიებელს.

196
00:11:37,210 --> 00:11:42,540
Y ის ანბანური მაჩვენებელი არის 24, როგორც
მეორე ბოლო წერილი ანბანი.

197
00:11:42,540 --> 00:11:46,520
ასე რომ, მაშინ 24 პლუს ჩვენი
გასაღები ორი გვაძლევს 26.

198
00:11:46,520 --> 00:11:54,750
26 mod 26 გვაძლევს 0, რაც, იღბლიანი
ჩვენთვის, ანბანური მაჩვენებელი ა

199
00:11:54,750 --> 00:11:59,100
ასე რომ, იმედია, რომ მტკიცებულება საკმარისი, რომ
ანბანური ინდექსი მეთოდი მუშაობს.

200
00:11:59,100 --> 00:12:03,180
თუ არა, შეგიძლიათ ცდილობენ out
რამდენიმე მაგალითს საკუთარი.

201
00:12:03,180 --> 00:12:08,030
>> იმისათვის, რომ სათანადოდ გადაიტანოთ გარშემო
ანბანი და ვრცელდება Caesar განტოლება,

202
00:12:08,030 --> 00:12:11,280
ჩვენ ვიცით, რომ ჩვენ უნდა
გაუმკლავდეთ ანბანური ინდექსები.

203
00:12:11,280 --> 00:12:15,130
მაგრამ ჩვენ დავიწყებთ ASCII
ღირებულებები, და მხოლოდ ამის შემდეგ

204
00:12:15,130 --> 00:12:18,530
ჩვენ შემდეგ კონვერტირება
ანბანურ მაჩვენებელს.

205
00:12:18,530 --> 00:12:23,970
იქიდან, რათა ბეჭდვა, ჩვენ გვჭირდება
გამკლავება ASCII ღირებულებების ერთხელ.

206
00:12:23,970 --> 00:12:28,350
ამიტომ, ჩვენ უნდა გაერკვნენ, თუ როგორ
გადასვლა ASCII ანბანის

207
00:12:28,350 --> 00:12:31,080
და ანბანური to ASCII.

208
00:12:31,080 --> 00:12:34,910
>> ასე რომ დავტოვო ეს თქვენ უნდა გაერკვნენ
ნიმუში შორის ხასიათი

209
00:12:34,910 --> 00:12:38,590
და მისი ანბანური
ინდექსი და მისი ASCII ღირებულება.

210
00:12:38,590 --> 00:12:41,530
ახლა, მახსოვს, რომ მიუხედავად იმისა,
ამ მაგიდასთან უფლება slide

211
00:12:41,530 --> 00:12:45,630
აჩვენებს ასოებით, ჩვენ ასევე
უნდა განიხილოს თუ არა

212
00:12:45,630 --> 00:12:48,915
სხვადასხვა ნიმუში ვრცელდება
ქვედა შემთხვევაში სიმბოლო.

213
00:12:48,915 --> 00:12:52,070

214
00:12:52,070 --> 00:12:55,840
>> ასე, რომ ახლა უკვე figured out
როგორ უნდა გადაიტანოს ერთი ხასიათი,

215
00:12:55,840 --> 00:13:02,200
მაშინ ყველა ჩვენ უნდა გავაკეთოთ არის მასშტაბის,
up წასვლა მთელ plaintext.

216
00:13:02,200 --> 00:13:04,260
ასე რომ დაუცველი სიმებიანი.

217
00:13:04,260 --> 00:13:08,210
Lucky ჩვენთვის, string მართლაც
მხოლოდ მასივი გმირები,

218
00:13:08,210 --> 00:13:12,150
ასე რომ, იმისათვის, რათა შეამოწმონ ყოველ ხასიათი
სიმებიანი, ყველა თქვენ უნდა გააკეთოთ

219
00:13:12,150 --> 00:13:14,270
არის გამოიყენოს მასივი notation.

220
00:13:14,270 --> 00:13:20,270
მე მაქვს ცვლადი ტიპის
სიმებიანი მოუწოდა "text = 'ეს არის CS50."

221
00:13:20,270 --> 00:13:22,730
>> კარგად, მაშინ, იმისათვის, რომ
წვდომის თითოეული ხასიათი,

222
00:13:22,730 --> 00:13:25,880
ყველა მე უნდა გააკეთოს
ცვლადი ტექსტი

223
00:13:25,880 --> 00:13:31,660
ვთქვა, ასევე, ტექსტი ინდექსი ნულოვანი, რომ
შეესაბამება კაპიტალის T. ტექსტი ინდექსი

224
00:13:31,660 --> 00:13:35,100
ერთ-ერთი შეესაბამება ქვედა შემთხვევაში თ.

225
00:13:35,100 --> 00:13:38,110
კიდევ ერთი სასარგებლო ფუნქცია
სიმებიანი სიგრძე ფუნქცია.

226
00:13:38,110 --> 00:13:40,760
ასე გავლის სიმებიანი
რომ ფუნქცია დააბრუნებს

227
00:13:40,760 --> 00:13:44,610
რიცხვი, სიგრძეზე რომ სტრიქონს.

228
00:13:44,610 --> 00:13:47,060
>> ახლა, რომ ჩვენ ვისაუბრეთ
ყველა ამ სხვადასხვა ელემენტები,

229
00:13:47,060 --> 00:13:48,540
მოდით დააყენა მათ უკან ერთად.

230
00:13:48,540 --> 00:13:52,210
ასე რომ დაბრუნდეს ან ჩემი pseudocode
კოდი ან pseudocode

231
00:13:52,210 --> 00:13:55,920
და გაიაროს და დარწმუნდით, რომ თქვენ
თუ როგორ უნდა გავაკეთოთ თითოეული რამ.

232
00:13:55,920 --> 00:14:01,520
მიღების გასაღები გამოყენებით argc და argv,
გარდამტეხი გასაღები შევიდა რიცხვი, რომელიც

233
00:14:01,520 --> 00:14:06,840
I, რითაც დაუცველი,
getstring, და შემდეგ iterating

234
00:14:06,840 --> 00:14:09,590
ყოველ ხასიათი
დაუცველი string,

235
00:14:09,590 --> 00:14:14,910
შენარჩუნების შემთხვევაში თითოეული ხასიათი
და გადავიდა, რომ ხასიათი გასაღები,

236
00:14:14,910 --> 00:14:17,520
უზრუნველსაყოფად, რომ თქვენ
შესაფუთი გარშემო ანბანი,

237
00:14:17,520 --> 00:14:20,850
საბოლოოდ დაბეჭდვის რომ ciphertext.

238
00:14:20,850 --> 00:14:25,470
ჩემი სახელი არის Amila, და ეს იყო Caesar.

239
00:14:25,470 --> 00:14:28,448

