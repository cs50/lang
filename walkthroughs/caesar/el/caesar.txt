AMILA: Ας αντιμετωπίσουμε Καίσαρα. Σε Καίσαρα, θα επιτρέψει στο χρήστη για να κωδικοποιήσει ένα μυστικό μήνυμα. Οπότε ας βουτήξει δεξιά μέσα και φαίνονται σε μας to-dos για αυτό το πρόβλημα. Έτσι, η πρώτη, παίρνουμε το κλειδί από το χρήστη. Στη συνέχεια παίρνουμε το plaintext ότι θέλουν να κωδικοποιήσουν. Μετά από αυτό, μπορούμε να encipher γι 'αυτούς, και τέλος τυπώνουμε κρυπτοκείμενο τους. 

Έτσι, ας ξεκινήσουμε με ένα παράδειγμα. Πέστε ότι ήθελε να κωδικοποιήσει το ολόκληρο το αλφάβητο με ένα κλειδί των δύο. Λοιπόν, ολόκληρο το αλφάβητο σας θα απλά να μετατοπίζεται προς τα γράμματα. Έτσι Α θα κωδικοποιήσει σε C, B για να D, C έως Ε, ούτω καθεξής και ούτω καθεξής, μέχρι να φτάσετε στο Χ, το οποίο κωδικοποιεί το Ω ή zed, ανάλογα με το πού είστε από. Στη συνέχεια, το Υ τότε θα στραφούν σε όλη τη διαδρομή, τυλίξτε γύρω από το αλφάβητο για να φτάσετε στο A, και στη συνέχεια, τέλος, το τελευταίο γράμμα του αλφάβητο, Ζ, zed, θα κωδικοποιήσει σε Β 

Πήρατε αυτό; Ας δούμε μερικά παραδείγματα. Το πρώτο παράδειγμα εδώ είναι πολύ παρόμοια σε αυτό που μόλις εξήγησα παραπάνω. Έτσι, αν μπορώ να κωδικοποιεί κάποιο τμήμα του αλφάβητο, A έως L, με ένα κλειδί δύο, τότε απλά να πάρετε ολόκληρο μου αλφάβητο μετατοπιστεί δύο γράμματα. 

Στη συνέχεια, στο επόμενο παράδειγμα μου, το κλειδί εξακολουθεί να είναι δύο, οπότε θα πρέπει ακόμα να ξέρετε το οποίο γράμματα να περιμένουμε. Αλλά εδώ είναι μια φράση. Αυτό είναι CS50. Έτσι, θα παρατηρήσετε ότι εγώ διατηρούν την υπόθεση των επιστολών μου, έτσι ώστε οποιαδήποτε κεφαλαία γράμματα είναι επίσης κεφαλαία γράμματα στο κρυπτοκείμενο. Και κάθε πεζό γράμματα στο plaintext Επίσης, πεζά γράμματα γράμματα στο κρυπτοκείμενο. Αλλά έχω κρατήσει τα γράμματα και κάθε θαυμαστικά ή οποιαδήποτε άλλα σημεία στίξης το ίδιο. 

Έτσι τώρα που έχουμε μια αίσθηση για το πώς λειτουργεί το πρόγραμμα, αισθανθείτε ελεύθερος να πάει τρέξει λίγο περισσότερο παραδείγματα από τη δική σας, αν το επιθυμείτε. Ας ξεκινήσουμε με το να πάρει το κλειδί από το χρήστη. Παραδοσιακά, με άλλα προβλήματα, έχουμε έχουν συνηθίσει να πάρει τυχόν αριθμούς ότι εμείς Πρέπει ζητώντας από το χρήστη με την getint λειτουργία. Αλλά αυτή τη φορά είμαστε στην πραγματικότητα θα να χρησιμοποιήσει το επιχείρημα της γραμμής εντολών και μια νέα λειτουργία που ονομάζεται atoi. 

Όταν εκτελείτε το κύριο πρόγραμμα σε C, τότε λαμβάνει σε δύο parameters-- int argc, η οποία είναι ο αριθμός των επιχειρημάτων πέρασε μέσα, και στη συνέχεια argv, μια σειρά από χορδές που περιέχει ο κατάλογος όλων των επιχειρημάτων πέρασε. Δεν έχετε ρητά να δηλώσει τις μεταβλητές αυτές. Είναι υπολογίζεται για σας από τον compiler. Σωστή χρήση για αυτό θα ήταν για argc να είναι δύο σε αυτή την περίπτωση, επειδή ο χρήστης πρέπει να περάσει σε η κλήση του προγράμματος, ./caesar, και στη συνέχεια το πλήκτρο, ανεξάρτητα από τον αριθμό που επιθυμείτε. Έτσι, αυτό σημαίνει ότι argc πρέπει να είναι δύο προκειμένου για μια έγκυρη χρήση του Καίσαρα να εκτελεστεί. 

Ας δούμε ένα παράδειγμα. Να πω ότι έχω ήδη γράψει και συνέταξε ένα πρόγραμμα που ονομάζεται blastoff. Έτσι, αν έτρεξα στη γραμμή εντολών ./blastoff Rocket Team, και, στη συνέχεια, argc θα είναι τρεις, γιατί πέρασε σε τρεις διαφορετικές επιχειρήματα. Στη συνέχεια, argv θα μοιάζει με αυτό. Είναι μια σειρά, και θα περιέχουν κάθε μία από τις τρεις χορδές. ./blastoff στο πρώτο δείκτη, η ομάδα στην επόμενη, και πυραύλων στην τελευταία. 

Ας μιλήσουμε για συστοιχίες για ένα δευτερόλεπτο. Συστοιχίες είναι δομές δεδομένων που κατέχουν πολλαπλές τιμές του ίδιου τύπου. Αυτό μπορεί να έρθει σε πρακτικό όταν έχουν λίστες ακεραίων ή χορδές. Απλά να θυμάστε ότι έχουν να είναι του ίδιου τύπου. Στην επιστήμη των υπολογιστών, μπορούμε Λατρεύω μετρώντας από το μηδέν, ώστε να θυμάστε ότι συστοιχίες είναι επίσης μηδενική ευρετήριο. Έτσι, το πρώτο στοιχείο του πίνακα μου πρόκειται να είναι στο ευρετήριο μηδέν. Έτσι, σε αυτή την περίπτωση, όταν έχω μια σειρά από τέσσερα μήκος, τότε η τελευταία δείκτη του τελευταίο στοιχείο του πίνακα μου είναι πραγματικά πρόκειται να είναι στο δείκτη τρία, όχι τέσσερα. Επειδή θυμηθείτε, αρχίζουν να μετρούν από το μηδέν. 

Εδώ είναι ένα παράδειγμα για το πώς θα μπορεί να δημιουργήσει μια σειρά από δικά σας. Έτσι λένε Ήθελα να αποθηκεύσετε μου τρία αγαπημένα ονόματα σκυλιών. Τότε θα δημιουργήσει μια σειρά από χορδές. Θα ήθελα λοιπόν να δηλώσουν τον τύπο, string, και στη συνέχεια, τοποθετήστε το όνομα της συστοιχίας, τα σκυλιά, και στη συνέχεια σε αυτά τα τετραγωνικά παρένθεση βάλτε το μέγεθος της array-- στην περίπτωση αυτή, τρία. 

Έτσι, η πρώτη συμμετοχή μου συμβαίνει να είναι τα σκυλιά στο δείκτη μηδέν, και ότι πρόκειται να είναι Milo. Στη συνέχεια, τα σκυλιά στο δείκτη ένα πρόκειται να είναι ανόητος, αγάπη Mochi, και στη συνέχεια, η τελευταία καταχώρηση, η τρίτη είσοδος στο δείκτη δύο, πρόκειται να είναι χαριτωμένο, γλυκό Elphie. Θα παρατηρήσετε ότι το σχήμα για τη συμπλήρωση αυτού του πίνακα μοιάζει πολύ με το πώς μπορεί να δηλώνουν κάθε άλλη μεταβλητή, όπου έχετε το όνομα της μεταβλητής που ακολουθείται από η τιμή που θέλετε είναι αποθηκευμένα σε αυτό. Η μόνη διαφορά σε η υπόθεση αυτή είναι ότι πρέπει να θυμηθείτε να θέσει το δείκτη της αξίας σε αγκύλες. Και εκεί έχουμε μας τρεις αγαπημένες σκυλιά. 

Αλλά αλίμονο, είναι η ώρα να πάρει πίσω στον Καίσαρα. Να θυμάστε ότι η σωστή χρήση για την χρήστης πρόκειται να περνά όχι μόνο το όνομα του ./caesar προγράμματος, αλλά Επίσης, το κλειδί που θέλουν να μετατοπίσουν plaintext τους. Έτσι, αυτό σημαίνει ότι argc πρέπει να είναι δύο. Θα πρέπει να περάσει σε two-- όχι περισσότερο, όχι λιγότερο από δύο επιχειρήματα της γραμμής εντολών. 

Τώρα, τι γίνεται με argv; Λοιπόν, γνωρίζουμε ήδη ότι η συστοιχία πρόκειται να είναι μήκους δύο, αλλά αυτό που περιέχεται σε κάθε στοιχείο; Λοιπόν, το πρώτο στοιχείο πρόκειται να είναι ./caesar, και στη συνέχεια το επόμενο στοιχείο πρόκειται να περιέχουν το κλειδί που ο χρήστης πληκτρολογήσει. Τώρα, αν αυτό χρησιμοποιείται σωστά για τη χρήση του Καίσαρα, Στη συνέχεια θα πάμε για να πληκτρολογήσετε έναν αριθμό. Αλλά ακόμα κι αν ο χαρακτήρας ότι τύπος είναι ένας αριθμός, Είναι σπάγκο τύπο δεδομένων. 

Επομένως, πώς θα μετατρέψετε ότι συμβολοσειράς σε ακέραιο; Έτσι λένε έχω num, ένα string, που περιέχει τη συμβολοσειρά 50. Αν θέλω να μετατρέψετε ότι σε ακέραιο, τότε απλά δηλώνουν μια νέα μεταβλητή, ένα ακέραιο i, καλώντας atoi. Περνώ σε μεταβλητή συμβολοσειράς μου, num, και τότε εγώ τότε θα περιέχει τον αριθμό 50. Σιγουρευτείτε για να ελέγξετε τον άνθρωπο σελίδες για τη λειτουργία atoi για να ελέγξετε ποια βιβλιοθήκη είναι σε, καθώς και ό, τι εκτιμούν θα επιστρέψει, αν το string πέρασε σε δεν περιέχει όλους τους αριθμούς. 

Έτσι τώρα που έχουμε πάρει το κλειδί, το επόμενο βήμα είναι να πάρει το απλό κείμενο από το χρήστη. Τώρα, αυτό πρόκειται να να είναι λιγότερο περίπλοκη από την πλοήγηση γύρω από το επιχειρήματα της γραμμής εντολών. Το μόνο που έχετε να κάνετε είναι να καλέσετε η λειτουργία getstring να ζητήσει από το χρήστη να δώσει μας μια σειρά, αλλά να θυμάστε για να ελέγξετε τις προδιαγραφές για το πώς θα ίσως να θέλετε να ζητήσει από το χρήστη για αυτό. 

Τώρα ερχόμαστε να το καρδιά του problem-- πώς να encipher το plaintext. Λοιπόν, πρώτα, ας μιλήσουμε για το πώς για την κρυπτογράφηση ενός χαρακτήρα σε μια στιγμή, και στη συνέχεια θα αντιμετωπίσει τον τρόπο για να επαναλάβει πάνω από ολόκληρο το plaintext. Έχω γράψει κάποια ψευδοκώδικα για το πρόβλημα του Καίσαρα. Σας ενθαρρύνουμε να γράψει τη δική σας επίσης. Μπορεί να μην φαίνονται όμοια με ορυχείο, και αυτό είναι εντάξει, αλλά εφ ' καθώς η γενική ιδέα είναι η ίδια. 

Τα τρία πρώτα βήματα έχουμε ήδη κάνει. Έχουμε πάρει το κλειδί από το επιχείρημα της γραμμής εντολών, έχουμε γύρισε το κλειδί σε έναν ακέραιο αριθμό, και έχουμε ζητηθεί από το χρήστη για την plaintext ότι θέλουν να encipher. Έτσι, τότε το επόμενο μεγάλο κομμάτι είναι ότι για κάθε χαρακτήρα στο plaintext string, αν είναι αλφαβητική, θέλουμε να διατηρήσουμε περίπτωσή της και στροφή. Με τη διατήρηση περίπτωση, αυτό που να πω είναι ότι όλα τα κεφαλαία γράμματα γράμματα θα πρέπει να παραμείνει άνω περίπτωση και όλα τα πεζά γράμματα θα πρέπει να παραμείνει πεζά. Έτσι, στη συνέχεια, αφού έχουμε μετατοπίσει εκείνους, τότε μπορούμε να εκτυπώσετε το κρυπτοκείμενο. 

Εδώ είναι τρεις λειτουργίες που είναι σε εξέλιξη να έρθει σε πρακτικό για αυτό το πρόβλημα. Θυμηθείτε ψηλά όταν έδωσα το παράδειγμα για τη μετατόπιση αυτή είναι CS50; Να θυμάστε ότι το 50 και το θαυμαστικό δεν αλλάξει; Λοιπόν, πώς μπορούμε να πούμε αν είμαστε Πρέπει να μετατοπίσει ένα γράμμα ή όχι; Λοιπόν, "είναι άλφα," αν που το ένα χαρακτήρα περάσει, Θα επιστρέψει true αν ο χαρακτήρας είναι ένα γράμμα και ψεύτικες διαφορετικά. Για να σας βοηθήσει με την διατηρώντας κεφαλαιοποίηση είναι οι λειτουργίες "είναι άνω »και« είναι χαμηλότερη. " 

Αυτές οι δύο λειτουργίες λαμβάνουν επίσης σε ένα ενιαίο χαρακτήρα ως είσοδο και θα επιστρέψει μια Boolean, είτε αληθείς ή ψευδείς ανάλογα με το αν αυτό το χαρακτήρα είναι κεφαλαία ή πεζά γράμματα. Επειδή «άνω» και «είναι κάτω "είναι Boolean λειτουργίες, που σημαίνει ότι μπορείτε να επιστρέψετε ένα Boolean, μπορείτε να χρησιμοποιήσετε αυτά σε συνθήκες σας. Έτσι, εδώ είναι ένα απόσπασμα του κώδικα που μόνο εκτυπώνει ένα e-mail αν είναι κεφαλαία. Έτσι έχω δηλώσει ο χαρακτήρας μου επιστολή προς το άνω περίπτωση zed και στη συνέχεια, αν «είναι ανώτερο" επιστρέφει αληθινή, τότε θα εκτυπώσετε το έγγραφο αυτό. 

Πηγαίνοντας πίσω στο απλό παράδειγμα μας μετατοπίζοντας το αλφάβητο από ένα κλειδί των δύο, πώς μπορούμε πραγματικά να πάρει ότι για να λειτουργήσει; Λοιπόν, αποδεικνύεται ότι οι χαρακτήρες και ακέραιοι είναι πολύ στενά συνδεδεμένα. Κάθε χαρακτήρας έχει μια ακέραια τιμή που σχετίζεται με βρήκε στο διάγραμμα ASCII, όπου ASCII κάθε χαρακτήρα Εμφανίζεται αξία. Έτσι, ένα κεφαλαίο αντιστοιχεί Α σε μια τιμή ASCII 65 και ένα πεζό ένα να μια τιμή ASCII του 97. 

Μη διστάσετε να αναζητήσετε κάθε διάγραμμα ASCII σε απευθείας σύνδεση για να δείτε αυτές τις τιμές για τον εαυτό σας. Έτσι, αυτό σημαίνει ότι μπορούμε να λάβει το χαρακτήρα κεφαλαίο Α, προσθέστε το ακέραιο δύο σε αυτό, και στη συνέχεια να ο χαρακτήρας άνω υπόθεση C ως αποτέλεσμα. Αυτό συμβαίνει γιατί το 65, το ASCII αξία για το κεφάλαιο Α, συν 2, μας δίνει 67, η οποία αντιστοιχεί στο χαρακτήρα της άνω περίπτωση Γ 

Δυστυχώς, τα πράγματα δεν θα είναι αρκετά να είναι τόσο απλό. Έχουμε μια εξίσωση που πρέπει να εξετάσουμε. Εδώ μας λέει ότι το ciphertext i- γράμμα αντιστοιχεί στο plaintext i- επιστολή, συν το key-- όλα αυτά, αρθρωτή 26. Γιατί είναι ότι η υπόθεση; Ας πάμε πίσω στο παράδειγμά μας από πριν, όπου το κεφάλαιο Α, συν 2, μας δίνει κεφάλαιο Γ 

Έτσι, εφαρμόζοντας την εξίσωση που η προδιαγραφή μας δίνει, τότε ας ρίξουμε κεφάλαιο Α συν 2 και mod ότι με 26. Έτσι κεφάλαιο Α, όταν το έβαλα στο αυτά τα μονά εισαγωγικά, μου επιτρέπει να την αντιμετωπίσουμε ως ένας ακέραιος, έτσι ώστε επιτρέπει Θέλω να το ρίχνει στην τιμή ASCII του, 65. 65 συν 2 είναι 67. 67 mod 26 μας δίνει 15, αλλά αυτό δεν το κάνει πραγματικά νόημα, διότι γνωρίζουμε ότι η κεφάλαιο Γ τιμή ASCII είναι 67, όχι 15. Επομένως, πώς θα συμβιβαστεί αυτό; 

Λοιπόν, εδώ θα ήθελα να θέτουμε το έννοια της αλφαβητικό ευρετήριο. Έτσι, έχουμε ήδη μιλήσει για το πώς κάθε χαρακτήρας έχει τιμή ASCII του, αλλά θα ήθελα να πω, επίσης, ας σκεφτείτε για κάθε χαρακτήρας έχει επίσης αλφαβητικό ευρετήριο, όπου Α, για παράδειγμα, ως το πρώτο γράμμα της αλφαβήτου, έχει ένα αλφαβητικό ευρετήριο το μηδέν. Έτσι τώρα, ας εφαρμόσει το ίδια εξίσωση όπως και πριν, αλλά χρησιμοποιώντας ένα αλφαβητικό ευρετήριο. 

Έτσι Α είναι μηδέν, όπως έχουμε ορίσει. Έτσι, στη συνέχεια, λαμβάνοντας μηδέν συν δύο, mod 26, που είναι δύο, mod 26, η οποία μας δίνει δύο. Και καλά, από την άποψη της αλφαβητικό ευρετήριο, C είναι η τρίτη επιστολή στην αλφάβητο, έτσι ώστε να ανταποκρίνονται με αλφαβητικό ευρετήριο των δύο. Έτσι, φαίνεται ότι η χρήση του αλφαβητικό ευρετήριο σε αυτή την περίπτωση στην πραγματικότητα μας δίνει το σωστό αποτέλεσμα. 

Έτσι τώρα ας ελέγξει για δείτε εάν λειτουργεί εξίσωση με αλφαβητικό ευρετήριο. αλφαβητικό ευρετήριο Υ είναι 24 και η δεύτερη στο τελευταίο γράμμα του αλφαβήτου. Έτσι, στη συνέχεια 24 συν μας βασικά δύο μας δίνει 26. 26 mod 26 μας δίνει το 0, το οποίο, ευτυχώς για μας, είναι το αλφαβητικό ευρετήριο για Α Έτσι, ελπίζουμε ότι αυτό είναι αρκετό ότι η απόδειξη η μέθοδος αλφαβητικό ευρετήριο έργων. Αν όχι, μην διστάσετε να δοκιμάσετε μερικά παραδείγματα από τη δική σας. 

Για να τυλίξετε σωστά γύρω από το αλφάβητο και να εφαρμόσει την εξίσωση του Καίσαρα, τότε ξέρουμε ότι πρέπει να ασχοληθεί με αλφαβητική δείκτες. Αλλά ξεκινάμε με ASCII αξίες, και μόνο τότε μπορούμε στη συνέχεια να μετατραπούν σε το αλφαβητικό ευρετήριο. Από εκεί, προκειμένου να εκτυπώσετε, χρειαζόμαστε να ασχοληθεί με τις τιμές ASCII και πάλι. Γι 'αυτό και πρέπει να καταλάβω πώς να πάει από ASCII σε αλφαβητική και από αλφαβητική σε ASCII. 

Έτσι αφήνω σε εσάς να καταλάβω το μοτίβο μεταξύ ενός χαρακτήρα και αλφαβητική της δείκτη και τιμή ASCII του. Τώρα, να θυμάστε ότι ακόμα και αν ο πίνακας αυτός το δικαίωμα στη διαφάνεια δείχνει τα κεφαλαία γράμματα, μπορούμε επίσης να πρέπει να εξετάσει κατά πόσον ή όχι εφαρμόζει ένα διαφορετικό μοτίβο για τα πεζά χαρακτήρες. 

Έτσι τώρα που έχουμε καταλάβει πώς να μετατοπίσει ένα ενιαίο χαρακτήρα, τότε το μόνο που έχουμε να κάνουμε είναι κλίμακα που μέχρι να πάει σε όλο το απλό κείμενο. Έτσι, η plaintext είναι μια συμβολοσειρά. Ευτυχώς για μας, ένα string είναι πραγματικά απλά μια σειρά από χαρακτήρες, έτσι ώστε να έχουν πρόσβαση σε κάθε χαρακτήρα ενός string, το μόνο που έχετε να κάνετε είναι να χρησιμοποιήσετε σειρά σημειογραφία. Πω ότι έχω μια μεταβλητή του τύπου σειρά που ονομάζεται "text = 'αυτό είναι CS50." 

Λοιπόν, τότε, προκειμένου να πρόσβαση σε κάθε χαρακτήρα, το μόνο που έχω να κάνω με η μεταβλητή κειμένου είναι να πω επίσης, κείμενο σε δείκτη μηδέν, ότι αντιστοιχεί σε κεφάλαια Τ Κείμενο στο ευρετήριο ένας αντιστοιχεί στην κάτω θήκη h. Μια άλλη χρήσιμη λειτουργία είναι η λειτουργία μήκος συμβολοσειράς. Έτσι, περνώντας σε μια σειρά για να ότι η λειτουργία θα επιστρέψει ένας ακέραιος, το μήκος του εν λόγω κορδόνι. 

Τώρα που έχουμε μιλήσει για όλα αυτά τα διαφορετικά στοιχεία, ας τους βάλει πίσω από κοινού. Έτσι επιστρέφουν είτε ψευδοκώδικα μου κώδικα ή ψευδοκώδικα σας και να πάει κατευθείαν και να βεβαιωθείτε ότι έχετε ξέρουν πώς να το κάνουμε κάθε ενιαίο πράγμα. Να πάρει το κλειδί χρησιμοποιώντας argc και argv, γυρίζοντας το κλειδί σε έναν ακέραιο αριθμό, μια για i, προτρέποντας για απλό κείμενο, getstring, και στη συνέχεια την επανάληψη πάνω από κάθε χαρακτήρα η plaintext string, διατηρώντας την περίπτωση του κάθε χαρακτήρα και μετατόπιση της εν λόγω χαρακτήρας από το κλειδί, εξασφαλίζοντας ότι είστε περιτύλιγμα γύρω από το αλφάβητο, Τέλος εκτύπωση της κρυπτοκείμενο. Το όνομά μου είναι Αμίλα, και αυτό ήταν Καίσαρα. 