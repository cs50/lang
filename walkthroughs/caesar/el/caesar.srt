1
00:00:00,000 --> 00:00:00,760

2
00:00:00,760 --> 00:00:02,270
>> AMILA: Ας αντιμετωπίσουμε Καίσαρα.

3
00:00:02,270 --> 00:00:06,110
Σε Καίσαρα, θα επιτρέψει στο χρήστη
για να κωδικοποιήσει ένα μυστικό μήνυμα.

4
00:00:06,110 --> 00:00:09,780
Οπότε ας βουτήξει δεξιά μέσα και φαίνονται
σε μας to-dos για αυτό το πρόβλημα.

5
00:00:09,780 --> 00:00:12,210
Έτσι, η πρώτη, παίρνουμε το κλειδί από το χρήστη.

6
00:00:12,210 --> 00:00:15,210
Στη συνέχεια παίρνουμε το plaintext
ότι θέλουν να κωδικοποιήσουν.

7
00:00:15,210 --> 00:00:21,380
Μετά από αυτό, μπορούμε να encipher γι 'αυτούς,
και τέλος τυπώνουμε κρυπτοκείμενο τους.

8
00:00:21,380 --> 00:00:23,600
>> Έτσι, ας ξεκινήσουμε με ένα παράδειγμα.

9
00:00:23,600 --> 00:00:26,920
Πέστε ότι ήθελε να κωδικοποιήσει το
ολόκληρο το αλφάβητο με ένα κλειδί των δύο.

10
00:00:26,920 --> 00:00:31,360
Λοιπόν, ολόκληρο το αλφάβητο σας θα
απλά να μετατοπίζεται προς τα γράμματα.

11
00:00:31,360 --> 00:00:37,060
Έτσι Α θα κωδικοποιήσει σε C, B για να
D, C έως Ε, ούτω καθεξής και ούτω καθεξής,

12
00:00:37,060 --> 00:00:42,470
μέχρι να φτάσετε στο Χ, το οποίο κωδικοποιεί το Ω
ή zed, ανάλογα με το πού είστε από.

13
00:00:42,470 --> 00:00:47,445
Στη συνέχεια, το Υ τότε θα στραφούν σε όλη τη διαδρομή,
τυλίξτε γύρω από το αλφάβητο για να φτάσετε στο A,

14
00:00:47,445 --> 00:00:53,256
και στη συνέχεια, τέλος, το τελευταίο γράμμα του
αλφάβητο, Ζ, zed, θα κωδικοποιήσει σε Β

15
00:00:53,256 --> 00:00:54,660
>> Πήρατε αυτό;

16
00:00:54,660 --> 00:00:56,380
Ας δούμε μερικά παραδείγματα.

17
00:00:56,380 --> 00:01:00,540
Το πρώτο παράδειγμα εδώ είναι πολύ παρόμοια
σε αυτό που μόλις εξήγησα παραπάνω.

18
00:01:00,540 --> 00:01:05,560
Έτσι, αν μπορώ να κωδικοποιεί κάποιο τμήμα του
αλφάβητο, A έως L, με ένα κλειδί δύο,

19
00:01:05,560 --> 00:01:09,760
τότε απλά να πάρετε ολόκληρο μου
αλφάβητο μετατοπιστεί δύο γράμματα.

20
00:01:09,760 --> 00:01:12,230
>> Στη συνέχεια, στο επόμενο παράδειγμα μου,
το κλειδί εξακολουθεί να είναι δύο,

21
00:01:12,230 --> 00:01:15,080
οπότε θα πρέπει ακόμα να ξέρετε
το οποίο γράμματα να περιμένουμε.

22
00:01:15,080 --> 00:01:16,400
Αλλά εδώ είναι μια φράση.

23
00:01:16,400 --> 00:01:18,100
Αυτό είναι CS50.

24
00:01:18,100 --> 00:01:21,090
Έτσι, θα παρατηρήσετε ότι εγώ
διατηρούν την υπόθεση των επιστολών μου,

25
00:01:21,090 --> 00:01:25,600
έτσι ώστε οποιαδήποτε κεφαλαία γράμματα είναι επίσης
κεφαλαία γράμματα στο κρυπτοκείμενο.

26
00:01:25,600 --> 00:01:27,800
Και κάθε πεζό
γράμματα στο plaintext

27
00:01:27,800 --> 00:01:30,640
Επίσης, πεζά γράμματα
γράμματα στο κρυπτοκείμενο.

28
00:01:30,640 --> 00:01:34,020
Αλλά έχω κρατήσει τα γράμματα
και κάθε θαυμαστικά

29
00:01:34,020 --> 00:01:37,610
ή οποιαδήποτε άλλα σημεία στίξης το ίδιο.

30
00:01:37,610 --> 00:01:40,360
>> Έτσι τώρα που έχουμε μια αίσθηση
για το πώς λειτουργεί το πρόγραμμα,

31
00:01:40,360 --> 00:01:43,890
αισθανθείτε ελεύθερος να πάει τρέξει λίγο περισσότερο
παραδείγματα από τη δική σας, αν το επιθυμείτε.

32
00:01:43,890 --> 00:01:47,072
Ας ξεκινήσουμε με το να πάρει
το κλειδί από το χρήστη.

33
00:01:47,072 --> 00:01:48,780
Παραδοσιακά, με
άλλα προβλήματα, έχουμε

34
00:01:48,780 --> 00:01:51,450
έχουν συνηθίσει να πάρει
τυχόν αριθμούς ότι εμείς

35
00:01:51,450 --> 00:01:54,710
Πρέπει ζητώντας από το χρήστη
με την getint λειτουργία.

36
00:01:54,710 --> 00:01:58,850
Αλλά αυτή τη φορά είμαστε στην πραγματικότητα θα
να χρησιμοποιήσει το επιχείρημα της γραμμής εντολών

37
00:01:58,850 --> 00:02:01,760
και μια νέα λειτουργία που ονομάζεται atoi.

38
00:02:01,760 --> 00:02:05,130
>> Όταν εκτελείτε το κύριο
πρόγραμμα σε C, τότε

39
00:02:05,130 --> 00:02:08,500
λαμβάνει σε δύο parameters--
int argc, η οποία

40
00:02:08,500 --> 00:02:11,670
είναι ο αριθμός των επιχειρημάτων
πέρασε μέσα, και στη συνέχεια

41
00:02:11,670 --> 00:02:15,920
argv, μια σειρά από χορδές που περιέχει
ο κατάλογος όλων των επιχειρημάτων

42
00:02:15,920 --> 00:02:16,740
πέρασε.

43
00:02:16,740 --> 00:02:19,740
Δεν έχετε ρητά
να δηλώσει τις μεταβλητές αυτές.

44
00:02:19,740 --> 00:02:22,700
Είναι υπολογίζεται για
σας από τον compiler.

45
00:02:22,700 --> 00:02:28,160
Σωστή χρήση για αυτό θα ήταν
για argc να είναι δύο σε αυτή την περίπτωση,

46
00:02:28,160 --> 00:02:32,630
επειδή ο χρήστης πρέπει να περάσει σε
η κλήση του προγράμματος, ./caesar,

47
00:02:32,630 --> 00:02:35,570
και στη συνέχεια το πλήκτρο,
ανεξάρτητα από τον αριθμό που επιθυμείτε.

48
00:02:35,570 --> 00:02:39,920
Έτσι, αυτό σημαίνει ότι argc πρέπει να είναι δύο
προκειμένου για μια έγκυρη χρήση του Καίσαρα

49
00:02:39,920 --> 00:02:41,680
να εκτελεστεί.

50
00:02:41,680 --> 00:02:43,590
>> Ας δούμε ένα παράδειγμα.

51
00:02:43,590 --> 00:02:47,760
Να πω ότι έχω ήδη γράψει και
συνέταξε ένα πρόγραμμα που ονομάζεται blastoff.

52
00:02:47,760 --> 00:02:52,670
Έτσι, αν έτρεξα στη γραμμή εντολών
./blastoff Rocket Team, και, στη συνέχεια,

53
00:02:52,670 --> 00:02:57,750
argc θα είναι τρεις, γιατί
πέρασε σε τρεις διαφορετικές επιχειρήματα.

54
00:02:57,750 --> 00:02:59,830
Στη συνέχεια, argv θα μοιάζει με αυτό.

55
00:02:59,830 --> 00:03:03,750
Είναι μια σειρά, και θα
περιέχουν κάθε μία από τις τρεις χορδές.

56
00:03:03,750 --> 00:03:09,640
./blastoff στο πρώτο δείκτη, η ομάδα
στην επόμενη, και πυραύλων στην τελευταία.

57
00:03:09,640 --> 00:03:11,610
>> Ας μιλήσουμε για συστοιχίες για ένα δευτερόλεπτο.

58
00:03:11,610 --> 00:03:15,560
Συστοιχίες είναι δομές δεδομένων που κατέχουν
πολλαπλές τιμές του ίδιου τύπου.

59
00:03:15,560 --> 00:03:19,980
Αυτό μπορεί να έρθει σε πρακτικό όταν
έχουν λίστες ακεραίων ή χορδές.

60
00:03:19,980 --> 00:03:23,030
Απλά να θυμάστε ότι έχουν
να είναι του ίδιου τύπου.

61
00:03:23,030 --> 00:03:25,310
Στην επιστήμη των υπολογιστών, μπορούμε
Λατρεύω μετρώντας από το μηδέν,

62
00:03:25,310 --> 00:03:29,260
ώστε να θυμάστε ότι συστοιχίες
είναι επίσης μηδενική ευρετήριο.

63
00:03:29,260 --> 00:03:34,360
Έτσι, το πρώτο στοιχείο του πίνακα μου
πρόκειται να είναι στο ευρετήριο μηδέν.

64
00:03:34,360 --> 00:03:37,580
Έτσι, σε αυτή την περίπτωση, όταν έχω
μια σειρά από τέσσερα μήκος,

65
00:03:37,580 --> 00:03:41,350
τότε η τελευταία δείκτη του
τελευταίο στοιχείο του πίνακα μου

66
00:03:41,350 --> 00:03:44,970
είναι πραγματικά πρόκειται να είναι
στο δείκτη τρία, όχι τέσσερα.

67
00:03:44,970 --> 00:03:48,880
Επειδή θυμηθείτε,
αρχίζουν να μετρούν από το μηδέν.

68
00:03:48,880 --> 00:03:52,530
>> Εδώ είναι ένα παράδειγμα για το πώς θα
μπορεί να δημιουργήσει μια σειρά από δικά σας.

69
00:03:52,530 --> 00:03:56,440
Έτσι λένε Ήθελα να αποθηκεύσετε μου
τρία αγαπημένα ονόματα σκυλιών.

70
00:03:56,440 --> 00:03:59,030
Τότε θα δημιουργήσει μια σειρά από χορδές.

71
00:03:59,030 --> 00:04:04,450
Θα ήθελα λοιπόν να δηλώσουν τον τύπο, string, και
στη συνέχεια, τοποθετήστε το όνομα της συστοιχίας, τα σκυλιά,

72
00:04:04,450 --> 00:04:06,450
και στη συνέχεια σε αυτά τα τετραγωνικά
παρένθεση βάλτε το μέγεθος

73
00:04:06,450 --> 00:04:09,260
της array-- στην περίπτωση αυτή, τρία.

74
00:04:09,260 --> 00:04:12,690
>> Έτσι, η πρώτη συμμετοχή μου συμβαίνει
να είναι τα σκυλιά στο δείκτη μηδέν,

75
00:04:12,690 --> 00:04:14,750
και ότι πρόκειται να είναι Milo.

76
00:04:14,750 --> 00:04:17,850
Στη συνέχεια, τα σκυλιά στο δείκτη ένα
πρόκειται να είναι ανόητος,

77
00:04:17,850 --> 00:04:23,060
αγάπη Mochi, και στη συνέχεια, η τελευταία
καταχώρηση, η τρίτη είσοδος στο δείκτη δύο,

78
00:04:23,060 --> 00:04:26,130
πρόκειται να είναι χαριτωμένο, γλυκό Elphie.

79
00:04:26,130 --> 00:04:28,610
Θα παρατηρήσετε ότι το σχήμα
για τη συμπλήρωση αυτού του πίνακα

80
00:04:28,610 --> 00:04:32,150
μοιάζει πολύ με το πώς μπορεί να
δηλώνουν κάθε άλλη μεταβλητή, όπου

81
00:04:32,150 --> 00:04:36,307
έχετε το όνομα της μεταβλητής που ακολουθείται από
η τιμή που θέλετε είναι αποθηκευμένα σε αυτό.

82
00:04:36,307 --> 00:04:38,140
Η μόνη διαφορά σε
η υπόθεση αυτή είναι ότι

83
00:04:38,140 --> 00:04:42,700
πρέπει να θυμηθείτε να θέσει το δείκτη
της αξίας σε αγκύλες.

84
00:04:42,700 --> 00:04:46,420
Και εκεί έχουμε μας
τρεις αγαπημένες σκυλιά.

85
00:04:46,420 --> 00:04:48,780
>> Αλλά αλίμονο, είναι η ώρα
να πάρει πίσω στον Καίσαρα.

86
00:04:48,780 --> 00:04:52,910
Να θυμάστε ότι η σωστή χρήση για την
χρήστης πρόκειται να περνά όχι μόνο

87
00:04:52,910 --> 00:04:57,430
το όνομα του ./caesar προγράμματος, αλλά
Επίσης, το κλειδί που θέλουν να μετατοπίσουν

88
00:04:57,430 --> 00:04:58,850
plaintext τους.

89
00:04:58,850 --> 00:05:01,540
Έτσι, αυτό σημαίνει ότι argc πρέπει να είναι δύο.

90
00:05:01,540 --> 00:05:07,580
Θα πρέπει να περάσει σε two-- όχι περισσότερο, όχι
λιγότερο από δύο επιχειρήματα της γραμμής εντολών.

91
00:05:07,580 --> 00:05:09,050
>> Τώρα, τι γίνεται με argv;

92
00:05:09,050 --> 00:05:12,880
Λοιπόν, γνωρίζουμε ήδη ότι η
συστοιχία πρόκειται να είναι μήκους δύο,

93
00:05:12,880 --> 00:05:15,270
αλλά αυτό που περιέχεται σε κάθε στοιχείο;

94
00:05:15,270 --> 00:05:19,330
Λοιπόν, το πρώτο στοιχείο
πρόκειται να είναι ./caesar,

95
00:05:19,330 --> 00:05:24,190
και στη συνέχεια το επόμενο στοιχείο πρόκειται να
περιέχουν το κλειδί που ο χρήστης πληκτρολογήσει.

96
00:05:24,190 --> 00:05:27,480
Τώρα, αν αυτό χρησιμοποιείται σωστά
για τη χρήση του Καίσαρα,

97
00:05:27,480 --> 00:05:29,350
Στη συνέχεια θα πάμε για να πληκτρολογήσετε έναν αριθμό.

98
00:05:29,350 --> 00:05:33,260
Αλλά ακόμα κι αν ο χαρακτήρας
ότι τύπος είναι ένας αριθμός,

99
00:05:33,260 --> 00:05:35,790
Είναι σπάγκο τύπο δεδομένων.

100
00:05:35,790 --> 00:05:40,390
>> Επομένως, πώς θα μετατρέψετε ότι
συμβολοσειράς σε ακέραιο;

101
00:05:40,390 --> 00:05:46,680
Έτσι λένε έχω num, ένα string,
που περιέχει τη συμβολοσειρά 50.

102
00:05:46,680 --> 00:05:49,000
Αν θέλω να μετατρέψετε ότι
σε ακέραιο, τότε απλά

103
00:05:49,000 --> 00:05:53,340
δηλώνουν μια νέα μεταβλητή, ένα
ακέραιο i, καλώντας atoi.

104
00:05:53,340 --> 00:06:01,160
Περνώ σε μεταβλητή συμβολοσειράς μου, num, και
τότε εγώ τότε θα περιέχει τον αριθμό 50.

105
00:06:01,160 --> 00:06:04,350
Σιγουρευτείτε για να ελέγξετε τον άνθρωπο
σελίδες για τη λειτουργία atoi

106
00:06:04,350 --> 00:06:07,990
για να ελέγξετε ποια βιβλιοθήκη είναι
σε, καθώς και ό, τι εκτιμούν

107
00:06:07,990 --> 00:06:14,550
θα επιστρέψει, αν το string πέρασε
σε δεν περιέχει όλους τους αριθμούς.

108
00:06:14,550 --> 00:06:16,950
>> Έτσι τώρα που έχουμε πάρει
το κλειδί, το επόμενο βήμα

109
00:06:16,950 --> 00:06:19,430
είναι να πάρει το απλό κείμενο από το χρήστη.

110
00:06:19,430 --> 00:06:21,170
Τώρα, αυτό πρόκειται να
να είναι λιγότερο περίπλοκη

111
00:06:21,170 --> 00:06:23,410
από την πλοήγηση γύρω από το
επιχειρήματα της γραμμής εντολών.

112
00:06:23,410 --> 00:06:26,190
Το μόνο που έχετε να κάνετε είναι να καλέσετε
η λειτουργία getstring

113
00:06:26,190 --> 00:06:29,660
να ζητήσει από το χρήστη να δώσει
μας μια σειρά, αλλά να θυμάστε

114
00:06:29,660 --> 00:06:34,090
για να ελέγξετε τις προδιαγραφές για το πώς θα
ίσως να θέλετε να ζητήσει από το χρήστη για αυτό.

115
00:06:34,090 --> 00:06:36,420
>> Τώρα ερχόμαστε να το
καρδιά του problem--

116
00:06:36,420 --> 00:06:38,860
πώς να encipher το plaintext.

117
00:06:38,860 --> 00:06:42,830
Λοιπόν, πρώτα, ας μιλήσουμε για το πώς
για την κρυπτογράφηση ενός χαρακτήρα σε μια στιγμή,

118
00:06:42,830 --> 00:06:47,370
και στη συνέχεια θα αντιμετωπίσει τον τρόπο για να
επαναλάβει πάνω από ολόκληρο το plaintext.

119
00:06:47,370 --> 00:06:50,440
Έχω γράψει κάποια ψευδοκώδικα
για το πρόβλημα του Καίσαρα.

120
00:06:50,440 --> 00:06:52,310
Σας ενθαρρύνουμε να
γράψει τη δική σας επίσης.

121
00:06:52,310 --> 00:06:55,900
Μπορεί να μην φαίνονται όμοια με
ορυχείο, και αυτό είναι εντάξει, αλλά εφ '

122
00:06:55,900 --> 00:06:58,640
καθώς η γενική ιδέα είναι η ίδια.

123
00:06:58,640 --> 00:07:00,780
>> Τα τρία πρώτα βήματα
έχουμε ήδη κάνει.

124
00:07:00,780 --> 00:07:03,100
Έχουμε πάρει το κλειδί από
το επιχείρημα της γραμμής εντολών,

125
00:07:03,100 --> 00:07:05,510
έχουμε γύρισε το κλειδί
σε έναν ακέραιο αριθμό, και έχουμε

126
00:07:05,510 --> 00:07:09,320
ζητηθεί από το χρήστη για την plaintext
ότι θέλουν να encipher.

127
00:07:09,320 --> 00:07:12,420
Έτσι, τότε το επόμενο μεγάλο κομμάτι
είναι ότι για κάθε χαρακτήρα

128
00:07:12,420 --> 00:07:15,070
στο plaintext string,
αν είναι αλφαβητική,

129
00:07:15,070 --> 00:07:17,750
θέλουμε να διατηρήσουμε
περίπτωσή της και στροφή.

130
00:07:17,750 --> 00:07:20,900
Με τη διατήρηση περίπτωση, αυτό που
να πω είναι ότι όλα τα κεφαλαία γράμματα

131
00:07:20,900 --> 00:07:23,580
γράμματα θα πρέπει να παραμείνει άνω
περίπτωση και όλα τα πεζά γράμματα

132
00:07:23,580 --> 00:07:25,640
θα πρέπει να παραμείνει πεζά.

133
00:07:25,640 --> 00:07:29,110
Έτσι, στη συνέχεια, αφού έχουμε μετατοπίσει εκείνους,
τότε μπορούμε να εκτυπώσετε το κρυπτοκείμενο.

134
00:07:29,110 --> 00:07:33,100
>> Εδώ είναι τρεις λειτουργίες που είναι σε εξέλιξη
να έρθει σε πρακτικό για αυτό το πρόβλημα.

135
00:07:33,100 --> 00:07:38,010
Θυμηθείτε ψηλά όταν έδωσα το
παράδειγμα για τη μετατόπιση αυτή είναι CS50;

136
00:07:38,010 --> 00:07:41,800
Να θυμάστε ότι το 50 και το
θαυμαστικό δεν αλλάξει;

137
00:07:41,800 --> 00:07:45,680
Λοιπόν, πώς μπορούμε να πούμε αν είμαστε
Πρέπει να μετατοπίσει ένα γράμμα ή όχι;

138
00:07:45,680 --> 00:07:48,650
Λοιπόν, "είναι άλφα," αν
που το ένα χαρακτήρα περάσει,

139
00:07:48,650 --> 00:07:54,850
Θα επιστρέψει true αν ο χαρακτήρας
είναι ένα γράμμα και ψεύτικες διαφορετικά.

140
00:07:54,850 --> 00:07:56,870
Για να σας βοηθήσει με την
διατηρώντας κεφαλαιοποίηση

141
00:07:56,870 --> 00:07:59,750
είναι οι λειτουργίες "είναι
άνω »και« είναι χαμηλότερη. "

142
00:07:59,750 --> 00:08:03,350
>> Αυτές οι δύο λειτουργίες λαμβάνουν επίσης
σε ένα ενιαίο χαρακτήρα ως είσοδο

143
00:08:03,350 --> 00:08:06,580
και θα επιστρέψει μια Boolean,
είτε αληθείς ή ψευδείς

144
00:08:06,580 --> 00:08:11,280
ανάλογα με το αν αυτό το χαρακτήρα
είναι κεφαλαία ή πεζά γράμματα.

145
00:08:11,280 --> 00:08:14,610
Επειδή «άνω» και «είναι
κάτω "είναι Boolean λειτουργίες,

146
00:08:14,610 --> 00:08:18,660
που σημαίνει ότι μπορείτε να επιστρέψετε ένα Boolean,
μπορείτε να χρησιμοποιήσετε αυτά σε συνθήκες σας.

147
00:08:18,660 --> 00:08:23,490
Έτσι, εδώ είναι ένα απόσπασμα του κώδικα που μόνο
εκτυπώνει ένα e-mail αν είναι κεφαλαία.

148
00:08:23,490 --> 00:08:27,790
Έτσι έχω δηλώσει ο χαρακτήρας μου
επιστολή προς το άνω περίπτωση zed

149
00:08:27,790 --> 00:08:33,440
και στη συνέχεια, αν «είναι ανώτερο" επιστρέφει
αληθινή, τότε θα εκτυπώσετε το έγγραφο αυτό.

150
00:08:33,440 --> 00:08:38,200
>> Πηγαίνοντας πίσω στο απλό παράδειγμα μας
μετατοπίζοντας το αλφάβητο από ένα κλειδί των δύο,

151
00:08:38,200 --> 00:08:41,049
πώς μπορούμε πραγματικά να πάρει ότι για να λειτουργήσει;

152
00:08:41,049 --> 00:08:45,770
Λοιπόν, αποδεικνύεται ότι οι χαρακτήρες
και ακέραιοι είναι πολύ στενά συνδεδεμένα.

153
00:08:45,770 --> 00:08:48,840
Κάθε χαρακτήρας έχει μια
ακέραια τιμή που σχετίζεται

154
00:08:48,840 --> 00:08:53,260
με βρήκε στο διάγραμμα ASCII,
όπου ASCII κάθε χαρακτήρα

155
00:08:53,260 --> 00:08:55,380
Εμφανίζεται αξία.

156
00:08:55,380 --> 00:08:58,940
Έτσι, ένα κεφαλαίο αντιστοιχεί Α
σε μια τιμή ASCII 65

157
00:08:58,940 --> 00:09:02,270
και ένα πεζό ένα να
μια τιμή ASCII του 97.

158
00:09:02,270 --> 00:09:04,940
>> Μη διστάσετε να αναζητήσετε
κάθε διάγραμμα ASCII σε απευθείας σύνδεση

159
00:09:04,940 --> 00:09:07,720
για να δείτε αυτές τις τιμές για τον εαυτό σας.

160
00:09:07,720 --> 00:09:12,096
Έτσι, αυτό σημαίνει ότι μπορούμε
να λάβει το χαρακτήρα κεφαλαίο Α,

161
00:09:12,096 --> 00:09:18,200
προσθέστε το ακέραιο δύο σε αυτό, και στη συνέχεια να
ο χαρακτήρας άνω υπόθεση C ως αποτέλεσμα.

162
00:09:18,200 --> 00:09:23,720
Αυτό συμβαίνει γιατί το 65, το ASCII
αξία για το κεφάλαιο Α, συν 2,

163
00:09:23,720 --> 00:09:29,960
μας δίνει 67, η οποία αντιστοιχεί
στο χαρακτήρα της άνω περίπτωση Γ

164
00:09:29,960 --> 00:09:33,480
>> Δυστυχώς, τα πράγματα
δεν θα είναι αρκετά να είναι τόσο απλό.

165
00:09:33,480 --> 00:09:36,980
Έχουμε μια εξίσωση που
πρέπει να εξετάσουμε.

166
00:09:36,980 --> 00:09:43,590
Εδώ μας λέει ότι το ciphertext i-
γράμμα αντιστοιχεί στο plaintext i-

167
00:09:43,590 --> 00:09:48,900
επιστολή, συν το key--
όλα αυτά, αρθρωτή 26.

168
00:09:48,900 --> 00:09:50,810
Γιατί είναι ότι η υπόθεση;

169
00:09:50,810 --> 00:09:55,430
Ας πάμε πίσω στο παράδειγμά μας από
πριν, όπου το κεφάλαιο Α, συν 2,

170
00:09:55,430 --> 00:09:57,590
μας δίνει κεφάλαιο Γ

171
00:09:57,590 --> 00:10:01,870
>> Έτσι, εφαρμόζοντας την εξίσωση που
η προδιαγραφή μας δίνει,

172
00:10:01,870 --> 00:10:06,660
τότε ας ρίξουμε κεφάλαιο Α
συν 2 και mod ότι με 26.

173
00:10:06,660 --> 00:10:10,730
Έτσι κεφάλαιο Α, όταν το έβαλα στο
αυτά τα μονά εισαγωγικά,

174
00:10:10,730 --> 00:10:14,010
μου επιτρέπει να την αντιμετωπίσουμε ως
ένας ακέραιος, έτσι ώστε επιτρέπει

175
00:10:14,010 --> 00:10:17,500
Θέλω να το ρίχνει στην τιμή ASCII του, 65.

176
00:10:17,500 --> 00:10:20,080
65 συν 2 είναι 67.

177
00:10:20,080 --> 00:10:25,210
67 mod 26 μας δίνει 15,
αλλά αυτό δεν το κάνει πραγματικά

178
00:10:25,210 --> 00:10:32,590
νόημα, διότι γνωρίζουμε ότι η
κεφάλαιο Γ τιμή ASCII είναι 67, όχι 15.

179
00:10:32,590 --> 00:10:35,580
Επομένως, πώς θα συμβιβαστεί αυτό;

180
00:10:35,580 --> 00:10:39,840
>> Λοιπόν, εδώ θα ήθελα να θέτουμε το
έννοια της αλφαβητικό ευρετήριο.

181
00:10:39,840 --> 00:10:44,010
Έτσι, έχουμε ήδη μιλήσει για το πώς
κάθε χαρακτήρας έχει τιμή ASCII του,

182
00:10:44,010 --> 00:10:48,810
αλλά θα ήθελα να πω, επίσης, ας
σκεφτείτε για κάθε χαρακτήρας έχει επίσης

183
00:10:48,810 --> 00:10:52,230
αλφαβητικό ευρετήριο,
όπου Α, για παράδειγμα,

184
00:10:52,230 --> 00:10:58,800
ως το πρώτο γράμμα της αλφαβήτου,
έχει ένα αλφαβητικό ευρετήριο το μηδέν.

185
00:10:58,800 --> 00:11:02,070
Έτσι τώρα, ας εφαρμόσει το
ίδια εξίσωση όπως και πριν,

186
00:11:02,070 --> 00:11:05,040
αλλά χρησιμοποιώντας ένα αλφαβητικό ευρετήριο.

187
00:11:05,040 --> 00:11:07,810
>> Έτσι Α είναι μηδέν, όπως έχουμε ορίσει.

188
00:11:07,810 --> 00:11:15,640
Έτσι, στη συνέχεια, λαμβάνοντας μηδέν συν δύο, mod 26,
που είναι δύο, mod 26, η οποία μας δίνει δύο.

189
00:11:15,640 --> 00:11:18,780
Και καλά, από την άποψη της
αλφαβητικό ευρετήριο,

190
00:11:18,780 --> 00:11:23,930
C είναι η τρίτη επιστολή στην
αλφάβητο, έτσι ώστε να ανταποκρίνονται

191
00:11:23,930 --> 00:11:26,290
με αλφαβητικό ευρετήριο των δύο.

192
00:11:26,290 --> 00:11:29,850
Έτσι, φαίνεται ότι η χρήση του
αλφαβητικό ευρετήριο σε αυτή την περίπτωση

193
00:11:29,850 --> 00:11:32,840
στην πραγματικότητα μας δίνει το σωστό αποτέλεσμα.

194
00:11:32,840 --> 00:11:35,020
>> Έτσι τώρα ας ελέγξει για
δείτε εάν λειτουργεί εξίσωση

195
00:11:35,020 --> 00:11:37,210
με αλφαβητικό ευρετήριο.

196
00:11:37,210 --> 00:11:42,540
αλφαβητικό ευρετήριο Υ είναι 24 και η
δεύτερη στο τελευταίο γράμμα του αλφαβήτου.

197
00:11:42,540 --> 00:11:46,520
Έτσι, στη συνέχεια 24 συν μας
βασικά δύο μας δίνει 26.

198
00:11:46,520 --> 00:11:54,750
26 mod 26 μας δίνει το 0, το οποίο, ευτυχώς για
μας, είναι το αλφαβητικό ευρετήριο για Α

199
00:11:54,750 --> 00:11:59,100
Έτσι, ελπίζουμε ότι αυτό είναι αρκετό ότι η απόδειξη
η μέθοδος αλφαβητικό ευρετήριο έργων.

200
00:11:59,100 --> 00:12:03,180
Αν όχι, μην διστάσετε να δοκιμάσετε
μερικά παραδείγματα από τη δική σας.

201
00:12:03,180 --> 00:12:08,030
>> Για να τυλίξετε σωστά γύρω από το
αλφάβητο και να εφαρμόσει την εξίσωση του Καίσαρα,

202
00:12:08,030 --> 00:12:11,280
τότε ξέρουμε ότι πρέπει να
ασχοληθεί με αλφαβητική δείκτες.

203
00:12:11,280 --> 00:12:15,130
Αλλά ξεκινάμε με ASCII
αξίες, και μόνο τότε

204
00:12:15,130 --> 00:12:18,530
μπορούμε στη συνέχεια να μετατραπούν σε
το αλφαβητικό ευρετήριο.

205
00:12:18,530 --> 00:12:23,970
Από εκεί, προκειμένου να εκτυπώσετε, χρειαζόμαστε
να ασχοληθεί με τις τιμές ASCII και πάλι.

206
00:12:23,970 --> 00:12:28,350
Γι 'αυτό και πρέπει να καταλάβω πώς να
πάει από ASCII σε αλφαβητική

207
00:12:28,350 --> 00:12:31,080
και από αλφαβητική σε ASCII.

208
00:12:31,080 --> 00:12:34,910
>> Έτσι αφήνω σε εσάς να καταλάβω
το μοτίβο μεταξύ ενός χαρακτήρα

209
00:12:34,910 --> 00:12:38,590
και αλφαβητική της
δείκτη και τιμή ASCII του.

210
00:12:38,590 --> 00:12:41,530
Τώρα, να θυμάστε ότι ακόμα και αν
ο πίνακας αυτός το δικαίωμα στη διαφάνεια

211
00:12:41,530 --> 00:12:45,630
δείχνει τα κεφαλαία γράμματα, μπορούμε επίσης να
πρέπει να εξετάσει κατά πόσον ή όχι

212
00:12:45,630 --> 00:12:48,915
εφαρμόζει ένα διαφορετικό μοτίβο
για τα πεζά χαρακτήρες.

213
00:12:48,915 --> 00:12:52,070

214
00:12:52,070 --> 00:12:55,840
>> Έτσι τώρα που έχουμε καταλάβει
πώς να μετατοπίσει ένα ενιαίο χαρακτήρα,

215
00:12:55,840 --> 00:13:02,200
τότε το μόνο που έχουμε να κάνουμε είναι κλίμακα που
μέχρι να πάει σε όλο το απλό κείμενο.

216
00:13:02,200 --> 00:13:04,260
Έτσι, η plaintext είναι μια συμβολοσειρά.

217
00:13:04,260 --> 00:13:08,210
Ευτυχώς για μας, ένα string είναι πραγματικά
απλά μια σειρά από χαρακτήρες,

218
00:13:08,210 --> 00:13:12,150
έτσι ώστε να έχουν πρόσβαση σε κάθε χαρακτήρα
ενός string, το μόνο που έχετε να κάνετε

219
00:13:12,150 --> 00:13:14,270
είναι να χρησιμοποιήσετε σειρά σημειογραφία.

220
00:13:14,270 --> 00:13:20,270
Πω ότι έχω μια μεταβλητή του τύπου
σειρά που ονομάζεται "text = 'αυτό είναι CS50."

221
00:13:20,270 --> 00:13:22,730
>> Λοιπόν, τότε, προκειμένου να
πρόσβαση σε κάθε χαρακτήρα,

222
00:13:22,730 --> 00:13:25,880
το μόνο που έχω να κάνω με
η μεταβλητή κειμένου είναι

223
00:13:25,880 --> 00:13:31,660
να πω επίσης, κείμενο σε δείκτη μηδέν, ότι
αντιστοιχεί σε κεφάλαια Τ Κείμενο στο ευρετήριο

224
00:13:31,660 --> 00:13:35,100
ένας αντιστοιχεί στην κάτω θήκη h.

225
00:13:35,100 --> 00:13:38,110
Μια άλλη χρήσιμη λειτουργία είναι
η λειτουργία μήκος συμβολοσειράς.

226
00:13:38,110 --> 00:13:40,760
Έτσι, περνώντας σε μια σειρά για να
ότι η λειτουργία θα επιστρέψει

227
00:13:40,760 --> 00:13:44,610
ένας ακέραιος, το μήκος του εν λόγω κορδόνι.

228
00:13:44,610 --> 00:13:47,060
>> Τώρα που έχουμε μιλήσει για
όλα αυτά τα διαφορετικά στοιχεία,

229
00:13:47,060 --> 00:13:48,540
ας τους βάλει πίσω από κοινού.

230
00:13:48,540 --> 00:13:52,210
Έτσι επιστρέφουν είτε ψευδοκώδικα μου
κώδικα ή ψευδοκώδικα σας

231
00:13:52,210 --> 00:13:55,920
και να πάει κατευθείαν και να βεβαιωθείτε ότι έχετε
ξέρουν πώς να το κάνουμε κάθε ενιαίο πράγμα.

232
00:13:55,920 --> 00:14:01,520
Να πάρει το κλειδί χρησιμοποιώντας argc και argv,
γυρίζοντας το κλειδί σε έναν ακέραιο αριθμό, μια

233
00:14:01,520 --> 00:14:06,840
για i, προτρέποντας για απλό κείμενο,
getstring, και στη συνέχεια την επανάληψη

234
00:14:06,840 --> 00:14:09,590
πάνω από κάθε χαρακτήρα
η plaintext string,

235
00:14:09,590 --> 00:14:14,910
διατηρώντας την περίπτωση του κάθε χαρακτήρα
και μετατόπιση της εν λόγω χαρακτήρας από το κλειδί,

236
00:14:14,910 --> 00:14:17,520
εξασφαλίζοντας ότι είστε
περιτύλιγμα γύρω από το αλφάβητο,

237
00:14:17,520 --> 00:14:20,850
Τέλος εκτύπωση της κρυπτοκείμενο.

238
00:14:20,850 --> 00:14:25,470
Το όνομά μου είναι Αμίλα, και αυτό ήταν Καίσαρα.

239
00:14:25,470 --> 00:14:28,448

