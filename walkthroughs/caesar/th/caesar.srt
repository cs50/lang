1
00:00:00,000 --> 00:00:00,760

2
00:00:00,760 --> 00:00:02,270
>> Amila: ให้ต่อสู้ของซีซาร์

3
00:00:02,270 --> 00:00:06,110
ในซีซาร์เราช่วยให้ผู้ใช้
การเข้ารหัสข้อความลับ

4
00:00:06,110 --> 00:00:09,780
ดังนั้นเรามาดำน้ำที่เหมาะสมในการดูและ
ที่เรา DOS ไปสำหรับปัญหานี้

5
00:00:09,780 --> 00:00:12,210
ดังนั้นก่อนที่เราได้รับที่สำคัญจากผู้ใช้

6
00:00:12,210 --> 00:00:15,210
จากนั้นเราก็จะได้รับเท็กซ์
ว่าพวกเขาต้องการการเข้ารหัส

7
00:00:15,210 --> 00:00:21,380
หลังจากนั้นเราก็เปลี่ยนเป็นรหัสสำหรับพวกเขา
และในที่สุดเราพิมพ์ ciphertext ของพวกเขา

8
00:00:21,380 --> 00:00:23,600
>> ดังนั้นขอเริ่มต้นด้วยตัวอย่าง

9
00:00:23,600 --> 00:00:26,920
สมมติว่าคุณต้องการที่จะเข้ารหัส
ตัวอักษรทั้งหมดที่มีที่สำคัญของทั้งสอง

10
00:00:26,920 --> 00:00:31,360
ดีตัวอักษรทั้งหมดของคุณจะ
เพียงแค่จะขยับไปทางตัวอักษร

11
00:00:31,360 --> 00:00:37,060
ดังนั้นจะเข้ารหัสเพื่อ C, B ไป
D, C ถึง E, อื่น ๆ และอื่น ๆ

12
00:00:37,060 --> 00:00:42,470
จนกว่าคุณจะได้รับการ X ซึ่ง encodes ถึง Z
หรือ zed ขึ้นอยู่กับที่คุณมาจาก

13
00:00:42,470 --> 00:00:47,445
แล้ว Y จากนั้นก็จะเปลี่ยนตลอดทาง
ห่อรอบตัวอักษรที่จะได้รับ A,

14
00:00:47,445 --> 00:00:53,256
และแล้วในที่สุดจดหมายฉบับสุดท้ายของ
ตัวอักษร Z, zed จะเข้ารหัสไป B.

15
00:00:53,256 --> 00:00:54,660
>> คุณได้ที่?

16
00:00:54,660 --> 00:00:56,380
ลองดูที่ตัวอย่างบางส่วน

17
00:00:56,380 --> 00:01:00,540
ตัวอย่างแรกที่นี่จะคล้ายกันมาก
กับสิ่งที่เราเป็นเพียงแค่อธิบายข้างต้น

18
00:01:00,540 --> 00:01:05,560
ดังนั้นถ้าฉันเข้ารหัสส่วนบางส่วนของ
ตัวอักษร A ถึง L โดยที่สำคัญของทั้งสอง

19
00:01:05,560 --> 00:01:09,760
แล้วฉันเพิ่งได้รับทั้งหมดของฉัน
ตัวอักษรสองตัวอักษรขยับ

20
00:01:09,760 --> 00:01:12,230
>> จากนั้นในตัวอย่างต่อไปของฉัน
ที่สำคัญคือยังคงสอง

21
00:01:12,230 --> 00:01:15,080
ดังนั้นคุณยังควรรู้
ซึ่งตัวอักษรที่คาดหวัง

22
00:01:15,080 --> 00:01:16,400
แต่นี่มันเป็นวลี

23
00:01:16,400 --> 00:01:18,100
นี่คือ CS50

24
00:01:18,100 --> 00:01:21,090
ดังนั้นคุณจะสังเกตเห็นว่าฉัน
รักษากรณีของตัวอักษรของฉัน

25
00:01:21,090 --> 00:01:25,600
เพื่อให้ตัวอักษรบนกรณีใด ๆ นอกจากนี้ยังมี
ตัวอักษรตัวพิมพ์ใหญ่ในไซเฟอร์เท็กซ์

26
00:01:25,600 --> 00:01:27,800
และตัวพิมพ์เล็ก ๆ
ตัวอักษรในเท็กซ์

27
00:01:27,800 --> 00:01:30,640
จะเป็นตัวพิมพ์เล็กยัง
ตัวอักษรในไซเฟอร์เท็กซ์

28
00:01:30,640 --> 00:01:34,020
แต่ฉันให้ตัวอักษร
และเครื่องหมายอัศเจรีย์

29
00:01:34,020 --> 00:01:37,610
หรือเครื่องหมายวรรคตอนอื่น ๆ ที่เหมือนกัน

30
00:01:37,610 --> 00:01:40,360
>> ดังนั้นขณะนี้ที่เรามีความรู้สึก
สำหรับวิธีการทำงานของโปรแกรม

31
00:01:40,360 --> 00:01:43,890
รู้สึกอิสระที่จะไปทำงานบางมากขึ้น
ตัวอย่างของคุณเองหากคุณต้องการ

32
00:01:43,890 --> 00:01:47,072
ขอเริ่มต้นด้วยการรับ
ที่สำคัญจากผู้ใช้

33
00:01:47,072 --> 00:01:48,780
ตามเนื้อผ้าด้วย
ปัญหาอื่น ๆ เราได้

34
00:01:48,780 --> 00:01:51,450
เคยได้รับ
ตัวเลขใด ๆ ที่เรา

35
00:01:51,450 --> 00:01:54,710
โดยต้องแจ้งให้ผู้ใช้
ด้วยฟังก์ชั่น getint

36
00:01:54,710 --> 00:01:58,850
แต่เวลานี้เรากำลังจริงที่เกิดขึ้น
เพื่อใช้อาร์กิวเมนต์บรรทัดคำสั่ง

37
00:01:58,850 --> 00:02:01,760
และฟังก์ชั่นใหม่ที่เรียกว่า atoi

38
00:02:01,760 --> 00:02:05,130
>> เมื่อคุณเรียกใช้หลัก
โปรแกรมใน C แล้วมัน

39
00:02:05,130 --> 00:02:08,500
จะใช้เวลาในสอง parameters--
argc int ซึ่ง

40
00:02:08,500 --> 00:02:11,670
คือจำนวนของการขัดแย้ง
ผ่านแล้ว

41
00:02:11,670 --> 00:02:15,920
argv อาร์เรย์ของสตริงที่มี
รายการทั้งหมดของการขัดแย้ง

42
00:02:15,920 --> 00:02:16,740
ผ่าน.

43
00:02:16,740 --> 00:02:19,740
คุณไม่ชัดเจนมี
การประกาศตัวแปรเหล่านี้

44
00:02:19,740 --> 00:02:22,700
พวกเขากำลังคำนวณ
คุณโดยรวบรวม

45
00:02:22,700 --> 00:02:28,160
การใช้งานที่ถูกต้องสำหรับการนี​​้จะเป็น
สำหรับ argc จะเป็นสองในกรณีนี้

46
00:02:28,160 --> 00:02:32,630
เพราะผู้ใช้มีการส่งผ่าน
การเรียกร้องให้โปรแกรม ./caesar,

47
00:02:32,630 --> 00:02:35,570
แล้วที่สำคัญ
สิ่งที่พวกเขาต้องการจำนวน

48
00:02:35,570 --> 00:02:39,920
ดังนั้นนั่นหมายความว่าจะต้องเป็น argc สอง
ในการสั่งซื้อสำหรับการใช้งานที่ถูกต้องของซีซาร์

49
00:02:39,920 --> 00:02:41,680
ที่จะดำเนินการ

50
00:02:41,680 --> 00:02:43,590
>> ดังนั้นเรามาดูตัวอย่าง

51
00:02:43,590 --> 00:02:47,760
บอกว่าผมได้เขียนไว้แล้วและ
รวบรวมโปรแกรมที่เรียกว่า Blastoff

52
00:02:47,760 --> 00:02:52,670
ดังนั้นถ้าฉันวิ่งในบรรทัดคำสั่ง
./blastoff จรวดทีมดีแล้ว

53
00:02:52,670 --> 00:02:57,750
argc จะเป็นเพราะผมสาม
ผ่านในสามข้อโต้แย้งที่แตกต่างกัน

54
00:02:57,750 --> 00:02:59,830
แล้ว argv จะมีลักษณะเช่นนี้

55
00:02:59,830 --> 00:03:03,750
มันเป็นอาร์เรย์และมันจะ
ประกอบด้วยแต่ละสามสาย

56
00:03:03,750 --> 00:03:09,640
./blastoff ในดัชนีแรกทีม
ในถัดไปและจรวดในช่วง

57
00:03:09,640 --> 00:03:11,610
>> พูดคุยเกี่ยวกับอาร์เรย์สำหรับวินาที

58
00:03:11,610 --> 00:03:15,560
อาร์เรย์เป็นโครงสร้างข้อมูลที่ถือ
ค่าหลายชนิดเดียวกัน

59
00:03:15,560 --> 00:03:19,980
นี้สามารถเข้ามามีประโยชน์เมื่อเรา
มีรายชื่อของจำนวนเต็มหรือสตริง

60
00:03:19,980 --> 00:03:23,030
เพียงจำไว้ว่าพวกเขามี
จะเป็นชนิดเดียวกัน

61
00:03:23,030 --> 00:03:25,310
ในสาขาวิทยาศาสตร์คอมพิวเตอร์เรา
รักนับจากศูนย์

62
00:03:25,310 --> 00:03:29,260
เพื่อให้จำไว้ว่าอาร์เรย์
นอกจากนี้ยังมีศูนย์การจัดทำดัชนี

63
00:03:29,260 --> 00:03:34,360
ดังนั้นองค์ประกอบแรกของอาร์เรย์ของฉัน
เป็นไปได้ที่ดัชนีศูนย์

64
00:03:34,360 --> 00:03:37,580
ดังนั้นในกรณีนี้เมื่อฉันมี
อาร์เรย์ของความยาวสี่

65
00:03:37,580 --> 00:03:41,350
ดัชนีสุดท้ายของ
องค์ประกอบสุดท้ายของอาร์เรย์ของฉัน

66
00:03:41,350 --> 00:03:44,970
เป็นจริงไปได้
ที่ดัชนีสามสี่ไม่ได้

67
00:03:44,970 --> 00:03:48,880
เพราะจำได้ว่าเรา
เริ่มนับที่ศูนย์

68
00:03:48,880 --> 00:03:52,530
>> นี่คือตัวอย่างของวิธีการที่คุณ
อาจสร้างอาร์เรย์ของตัวคุณเอง

69
00:03:52,530 --> 00:03:56,440
เพื่อบอกว่าฉันอยากจะเก็บของฉัน
สามชื่อสุนัขที่ชื่นชอบ

70
00:03:56,440 --> 00:03:59,030
แล้วฉันจะสร้างอาร์เรย์ของสตริง

71
00:03:59,030 --> 00:04:04,450
ดังนั้นผมจะประกาศชนิดสตริงและ
แล้วใส่ชื่อของอาเรย์, สุนัข,

72
00:04:04,450 --> 00:04:06,450
และจากนั้นในตารางเหล่านั้น
วงเล็บใส่ขนาด

73
00:04:06,450 --> 00:04:09,260
ของ array-- ในกรณีนี้สาม

74
00:04:09,260 --> 00:04:12,690
>> ดังนั้นรายการแรกของฉันเป็นไป
จะเป็นสุนัขที่ดัชนีศูนย์

75
00:04:12,690 --> 00:04:14,750
และนั่นจะเป็นไมโล

76
00:04:14,750 --> 00:04:17,850
จากนั้นสุนัขที่ดัชนีหนึ่ง
เป็นไปได้โง่

77
00:04:17,850 --> 00:04:23,060
รัก Mochi แล้วสุดท้าย
รายการรายการที่สามที่ดัชนีสอง

78
00:04:23,060 --> 00:04:26,130
เป็นไปได้น่ารัก, Elphie หวาน

79
00:04:26,130 --> 00:04:28,610
คุณจะสังเกตเห็นว่ารูปแบบ
สำหรับการกรอกข้อมูลในอาร์เรย์นี้

80
00:04:28,610 --> 00:04:32,150
เป็นอย่างมากเช่นวิธีที่คุณอาจ
ประกาศตัวแปรอื่น ๆ ที่

81
00:04:32,150 --> 00:04:36,307
คุณมีชื่อตัวแปรตาม
คุ้มค่าที่คุณต้องการเก็บไว้ในนั้น

82
00:04:36,307 --> 00:04:38,140
ความแตกต่างเฉพาะใน
กรณีนี้คือการที่คุณ

83
00:04:38,140 --> 00:04:42,700
ต้องอย่าลืมใส่ดัชนี
ของค่าในวงเล็บ

84
00:04:42,700 --> 00:04:46,420
และมีเรามีของเรา
หมาสามตัวที่ชื่นชอบ

85
00:04:46,420 --> 00:04:48,780
>> แต่อนิจจามันถึงเวลาที่
ที่จะได้รับกลับไปที่ซีซาร์

86
00:04:48,780 --> 00:04:52,910
โปรดจำไว้ว่าการใช้งานที่ถูกต้องสำหรับ
ผู้ใช้จะต้องผ่านในไม่เพียง

87
00:04:52,910 --> 00:04:57,430
ชื่อของ ./caesar โปรแกรม แต่
ยังเป็นกุญแจสำคัญที่พวกเขาต้องการที่จะเปลี่ยน

88
00:04:57,430 --> 00:04:58,850
ธรรมดาของพวกเขาโดย

89
00:04:58,850 --> 00:05:01,540
ดังนั้นนั่นหมายความว่าจะต้องเป็น argc สอง

90
00:05:01,540 --> 00:05:07,580
พวกเขาจะต้องผ่านใน two-- ไม่มากไม่
น้อยกว่าสองอาร์กิวเมนต์บรรทัดคำสั่ง

91
00:05:07,580 --> 00:05:09,050
>> ตอนนี้สิ่งที่เกี่ยวกับ argv?

92
00:05:09,050 --> 00:05:12,880
ดีที่เรารู้อยู่แล้วว่า
อาร์เรย์เป็นไปได้ของความยาวสอง

93
00:05:12,880 --> 00:05:15,270
แต่สิ่งที่มีอยู่ในแต่ละองค์ประกอบ?

94
00:05:15,270 --> 00:05:19,330
ดีองค์ประกอบแรก
เป็นไปได้ ./caesar,

95
00:05:19,330 --> 00:05:24,190
แล้วองค์ประกอบถัดไปจะไป
ประกอบด้วยที่สำคัญที่ผู้ใช้พิมพ์ลงใน

96
00:05:24,190 --> 00:05:27,480
ตอนนี้ถ้าพวกเขาใช้มันอย่างถูกต้อง
สำหรับการใช้งานของซีซาร์

97
00:05:27,480 --> 00:05:29,350
แล้วพวกเขาก็กำลังจะพิมพ์ในจำนวน

98
00:05:29,350 --> 00:05:33,260
แต่ถึงแม้ตัวละคร
ว่าพวกเขาพิมพ์เป็นตัวเลข

99
00:05:33,260 --> 00:05:35,790
มันเป็นของชนิดข้อมูลสตริง

100
00:05:35,790 --> 00:05:40,390
>> ดังนั้นทำอย่างไรเราแปลงที่
สตริงเป็นจำนวนเต็ม?

101
00:05:40,390 --> 00:05:46,680
เพื่อบอกว่าฉันมี NUM, สตริง
ที่มีสตริง 50

102
00:05:46,680 --> 00:05:49,000
ถ้าผมต้องการแปลงที่
เป็นจำนวนเต็มแล้วฉันก็

103
00:05:49,000 --> 00:05:53,340
ประกาศตัวแปรใหม่เป็น
จำนวนเต็มฉันเรียก atoi

104
00:05:53,340 --> 00:06:01,160
ฉันผ่านในตัวแปรสตริงของฉัน NUM และ
แล้วจากนั้นผมก็จะมีจำนวน 50

105
00:06:01,160 --> 00:06:04,350
ตรวจสอบให้แน่ใจที่จะตรวจสอบคนที่
หน้าสำหรับการทำงาน atoi

106
00:06:04,350 --> 00:06:07,990
เพื่อตรวจสอบห้องสมุดมัน
ในเช่นเดียวกับสิ่งที่เห็นคุณค่าของมัน

107
00:06:07,990 --> 00:06:14,550
จะกลับมาถ้าสตริงที่ผ่านมา
ในไม่ได้มีตัวเลขทั้งหมด

108
00:06:14,550 --> 00:06:16,950
>> ดังนั้นตอนนี้ที่เราเคย
กุญแจสำคัญในขั้นตอนต่อไป

109
00:06:16,950 --> 00:06:19,430
คือการได้รับ plaintext จากผู้ใช้

110
00:06:19,430 --> 00:06:21,170
ตอนนี้เป็นไปได้
มีความซับซ้อนน้อยลง

111
00:06:21,170 --> 00:06:23,410
กว่าการนำไปรอบ ๆ
อาร์กิวเมนต์บรรทัดคำสั่ง

112
00:06:23,410 --> 00:06:26,190
ทั้งหมดที่เราต้องทำคือการโทร
ฟังก์ชั่น GetString

113
00:06:26,190 --> 00:06:29,660
เพื่อแจ้งให้ผู้ใช้ที่จะให้
เราสตริง แต่จำไว้

114
00:06:29,660 --> 00:06:34,090
เพื่อตรวจสอบรายละเอียดสำหรับวิธีการที่เรา
อาจต้องการที่จะแจ้งให้ผู้ใช้ว่า

115
00:06:34,090 --> 00:06:36,420
>> ตอนนี้เรามาถึง
หัวใจของ problem--

116
00:06:36,420 --> 00:06:38,860
วิธีการเข้ารหัสเท็กซ์

117
00:06:38,860 --> 00:06:42,830
ดีแรกให้มาพูดคุยเกี่ยวกับวิธีการ
การเข้ารหัสตัวละครตัวหนึ่งที่เวลา

118
00:06:42,830 --> 00:06:47,370
แล้วเราจะอยู่ที่วิธีการ
ย้ำมากกว่าธรรมดาทั้งหมด

119
00:06:47,370 --> 00:06:50,440
ผมเคยเขียน pseudocode บาง
สำหรับปัญหาของซีซาร์

120
00:06:50,440 --> 00:06:52,310
ผมแนะนำให้คุณ
เขียนของคุณเองได้เป็นอย่างดี

121
00:06:52,310 --> 00:06:55,900
มันอาจจะดูไม่เหมือนกัน
เหมืองแร่และที่ตกลง แต่ตราบใด

122
00:06:55,900 --> 00:06:58,640
เป็นความคิดทั่วไปเหมือนกัน

123
00:06:58,640 --> 00:07:00,780
>> สามขั้นตอนแรก
ที่เราเคยทำมาแล้ว

124
00:07:00,780 --> 00:07:03,100
เราเคยสำคัญจาก
อาร์กิวเมนต์บรรทัดคำสั่ง

125
00:07:03,100 --> 00:07:05,510
เราได้เปิดที่สำคัญที่
เป็นจำนวนเต็มและเราได้

126
00:07:05,510 --> 00:07:09,320
ได้รับแจ้งให้ผู้ใช้เท็กซ์
ว่าพวกเขาต้องการที่จะเข้ารหัส

127
00:07:09,320 --> 00:07:12,420
ดังนั้นแล้วก้อนใหญ่ต่อไป
เป็นที่สำหรับตัวละครแต่ละตัว

128
00:07:12,420 --> 00:07:15,070
ในสตริงข้อความธรรมดา
ถ้าหากมันเป็นตัวอักษร

129
00:07:15,070 --> 00:07:17,750
เราต้องการที่จะรักษา
กรณีของตนและเปลี่ยนมัน

130
00:07:17,750 --> 00:07:20,900
โดยการรักษากรณีที่สิ่งที่ฉัน
หมายความว่ากรณีบนทั้งหมด

131
00:07:20,900 --> 00:07:23,580
ตัวอักษรที่ควรจะอยู่บน
กรณีและตัวอักษรพิมพ์เล็กทั้งหมด

132
00:07:23,580 --> 00:07:25,640
จะยังคงเป็นตัวพิมพ์เล็ก

133
00:07:25,640 --> 00:07:29,110
ดังนั้นแล้วหลังจากที่เราเปลี่ยนเหล่านั้น
แล้วเราพิมพ์ไซเฟอร์เท็กซ์

134
00:07:29,110 --> 00:07:33,100
>> ที่นี่มีสามฟังก์ชั่นที่กำลังจะมี
ที่จะเข้ามามีประโยชน์สำหรับปัญหานี้

135
00:07:33,100 --> 00:07:38,010
โปรดจำไว้ขึ้นไปข้างบนเมื่อฉันให้
ตัวอย่างสำหรับการขยับนี้อยู่ CS50?

136
00:07:38,010 --> 00:07:41,800
โปรดจำไว้ว่า 50 และ
เครื่องหมายอัศเจรีย์ไม่เปลี่ยน?

137
00:07:41,800 --> 00:07:45,680
ดังนั้นวิธีที่เราสามารถบอกได้ว่าเรา
ต้องการที่จะเปลี่ยนเป็นตัวอักษรหรือไม่?

138
00:07:45,680 --> 00:07:48,650
ดี "เป็นอัลฟา" ถ้า
คุณผ่านมันตัวอักษร

139
00:07:48,650 --> 00:07:54,850
จะกลับมาจริงถ้าตัวละครที่
เป็นตัวอักษรและตัวเลขที่มิฉะนั้นเท็จ

140
00:07:54,850 --> 00:07:56,870
ที่จะช่วยให้คุณมี
การรักษาโครงสร้างเงินทุน

141
00:07:56,870 --> 00:07:59,750
มีฟังก์ชั่น "คือ
บน "และ" ต่ำ ".

142
00:07:59,750 --> 00:08:03,350
>> ทั้งสองฟังก์ชั่นยังใช้
ในตัวเดียวเป็น input

143
00:08:03,350 --> 00:08:06,580
และกลับคุณบูลีน
จริงหรือเท็จ

144
00:08:06,580 --> 00:08:11,280
ขึ้นอยู่กับว่าตัวละครที่
เป็นกรณีบนหรือกรณีที่ต่ำกว่า

145
00:08:11,280 --> 00:08:14,610
เพราะ "เป็นสังคม" และ "เป็น
ที่ต่ำกว่า "มีฟังก์ชั่นบูลีน

146
00:08:14,610 --> 00:08:18,660
หมายความว่าพวกเขาจะกลับคุณบูลีน
คุณสามารถใช้เหล่านี้ในเงื่อนไขของคุณ

147
00:08:18,660 --> 00:08:23,490
ดังนั้นนี่คือข้อมูลโค้ดที่เท่านั้น
พิมพ์ตัวอักษรถ้าเป็นกรณีที่ส่วนบน

148
00:08:23,490 --> 00:08:27,790
ดังนั้นผมจึงได้ประกาศตัวละครของฉัน
ตัวอักษรจะเป็นกรณีบน zed

149
00:08:27,790 --> 00:08:33,440
แล้วถ้า "เป็นสังคม" ผลตอบแทน
ความจริงแล้วฉันจะพิมพ์ตัวอักษรว่า

150
00:08:33,440 --> 00:08:38,200
>> จะกลับไปตัวอย่างง่ายๆของเรา
ขยับตัวอักษรโดยที่สำคัญของทั้งสอง

151
00:08:38,200 --> 00:08:41,049
อย่างไรเราได้รับจริงว่าในการทำงานอย่างไร

152
00:08:41,049 --> 00:08:45,770
ดีก็ปรากฎว่าตัวละคร
และจำนวนเต็มมีความสัมพันธ์อย่างใกล้ชิด

153
00:08:45,770 --> 00:08:48,840
ตัวละครแต่ละตัวมี
ค่าจำนวนเต็มเกี่ยวข้อง

154
00:08:48,840 --> 00:08:53,260
กับมันพบในแผนภูมิ ASCII ที่
ที่ ASCII ของตัวละครแต่ละคน

155
00:08:53,260 --> 00:08:55,380
ค่าจะปรากฏขึ้น

156
00:08:55,380 --> 00:08:58,940
ดังนั้นสอดคล้องกับกรณีบน
เป็นค่า ASCII 65

157
00:08:58,940 --> 00:09:02,270
และตัวพิมพ์เล็กให้
ค่า ASCII ที่ 97

158
00:09:02,270 --> 00:09:04,940
>> รู้สึกอิสระที่จะเงยหน้าขึ้นมอง
แผนภูมิ ASCII ออนไลน์ใด ๆ

159
00:09:04,940 --> 00:09:07,720
เพื่อดูค่าเหล่านี้ด้วยตัวคุณเอง

160
00:09:07,720 --> 00:09:12,096
ดังนั้นสิ่งนี้หมายความว่าเราสามารถทำได้
ใช้ตัวอักษรกรณีส่วนบนที่

161
00:09:12,096 --> 00:09:18,200
เพิ่มจำนวนเต็มสองไปแล้วได้รับ
ตัวอักษรบนกรณี C เป็นผล

162
00:09:18,200 --> 00:09:23,720
นั่นเป็นเพราะ 65, แอสกี
ความคุ้มค่าต่อเงินทุนบวก 2

163
00:09:23,720 --> 00:09:29,960
จะช่วยให้เรา 67 ซึ่งสอดคล้อง
กับตัวละครของคดีซีบน

164
00:09:29,960 --> 00:09:33,480
>> แต่น่าเสียดายที่สิ่ง
จะไม่ได้ค่อนข้างง่ายดังนั้น

165
00:09:33,480 --> 00:09:36,980
เรามีสมการที่
เราต้องพิจารณา

166
00:09:36,980 --> 00:09:43,590
นี่มันบอกเราว่า ciphertext ที่ i
จดหมายสอดคล้องกับธรรมดาที่ i

167
00:09:43,590 --> 00:09:48,900
ตัวอักษรบวก key--
ทั้งหมดที่โมดูลาร์ 26

168
00:09:48,900 --> 00:09:50,810
ทำไมถึงเป็นกรณี?

169
00:09:50,810 --> 00:09:55,430
ลองกลับไปที่ตัวอย่างของเราจาก
ก่อนที่เงินทุนบวก 2

170
00:09:55,430 --> 00:09:57,590
ทำให้เรามีเงินทุนซี

171
00:09:57,590 --> 00:10:01,870
>> ดังนั้นการใช้สมการว่า
สเปคจะช่วยให้เรา

172
00:10:01,870 --> 00:10:06,660
แล้วลองทุน
บวก 2 และสมัยที่ 26

173
00:10:06,660 --> 00:10:10,730
ดังนั้นเงินทุนเมื่อฉันใส่ไว้ใน
บรรดาเครื่องหมายคำพูดเดียว

174
00:10:10,730 --> 00:10:14,010
ช่วยให้ฉันเพื่อรักษามันเป็น
จำนวนเต็มเพื่อที่จะช่วยให้

175
00:10:14,010 --> 00:10:17,500
ฉันไปทิ้งให้ค่า ASCII ของ 65

176
00:10:17,500 --> 00:10:20,080
65 บวก 2 คือ 67

177
00:10:20,080 --> 00:10:25,210
67 สมัยที่ 26 จะช่วยให้เรา 15
แต่นั่นไม่ได้จริงๆ

178
00:10:25,210 --> 00:10:32,590
ทำให้ความรู้สึกเพราะเรารู้ว่า
ทุน C ค่า ASCII คือ 67, 15 ไม่ได้

179
00:10:32,590 --> 00:10:35,580
ดังนั้นทำอย่างไรเราตกลงกันได้ที่?

180
00:10:35,580 --> 00:10:39,840
>> ดีที่นี่ฉันต้องการที่จะวางตัว
ความคิดของดัชนีเรียงตามตัวอักษร

181
00:10:39,840 --> 00:10:44,010
ดังนั้นเราจึงได้พูดคุยแล้วเกี่ยวกับวิธีการ
ตัวละครแต่ละตัวมีค่า ASCII ของตน

182
00:10:44,010 --> 00:10:48,810
แต่ผมอยากจะบอกว่าดีขอ
คิดเกี่ยวกับตัวละครแต่ละตัวนอกจากนี้ยังมี

183
00:10:48,810 --> 00:10:52,230
ดัชนีตัวอักษร
โดยที่ A ตัวอย่างเช่น

184
00:10:52,230 --> 00:10:58,800
เป็นอักษรตัวแรกของตัวอักษร
มีดัชนีเรียงตามตัวอักษรศูนย์

185
00:10:58,800 --> 00:11:02,070
ดังนั้นตอนนี้ขอใช้
สมการเช่นเดียวกับก่อน

186
00:11:02,070 --> 00:11:05,040
แต่การใช้ดัชนีเรียงตามตัวอักษร

187
00:11:05,040 --> 00:11:07,810
>> เพื่อให้เป็นศูนย์ในขณะที่เราได้กำหนดไว้

188
00:11:07,810 --> 00:11:15,640
ดังนั้นแล้วการศูนย์บวกสอง, MOD 26
ที่สองสมัยที่ 26 ซึ่งจะช่วยให้เราสอง

189
00:11:15,640 --> 00:11:18,780
และดีในแง่ของการ
ดัชนีตัวอักษร

190
00:11:18,780 --> 00:11:23,930
C คืออักษรที่สามใน
ตัวอักษรเพื่อที่จะสอดคล้อง

191
00:11:23,930 --> 00:11:26,290
เพื่อเป็นดัชนีตัวอักษรของทั้งสอง

192
00:11:26,290 --> 00:11:29,850
ดังนั้นดูเหมือนว่าการใช้
เรียงตามลำดับอักษรในกรณีนี้

193
00:11:29,850 --> 00:11:32,840
จะช่วยให้เราจริงผลที่ถูกต้อง

194
00:11:32,840 --> 00:11:35,020
>> ดังนั้นตอนนี้ขอตรวจสอบ
ดูว่าการทำงานของสมการ

195
00:11:35,020 --> 00:11:37,210
ด้วยการเรียงตามลำดับอักษร

196
00:11:37,210 --> 00:11:42,540
เรียงตามลำดับอักษร Y คือ 24 เป็น
ที่สองให้กับตัวอักษรตัวสุดท้ายในตัวอักษร

197
00:11:42,540 --> 00:11:46,520
ดังนั้นแล้ว 24 บวกของเรา
ที่สำคัญของทั้งสองจะช่วยให้เรา 26

198
00:11:46,520 --> 00:11:54,750
26 สมัยที่ 26 จะช่วยให้เรา 0 ซึ่งโชคดีสำหรับ
เราเป็นดัชนีตัวอักษรสำหรับเอ

199
00:11:54,750 --> 00:11:59,100
เพื่อหวังว่าหลักฐานพอที่จะทำให้
วิธีการเรียงตามลำดับอักษรงาน

200
00:11:59,100 --> 00:12:03,180
ถ้าไม่ได้ให้ความรู้สึกอิสระที่จะลอง
ตัวอย่างบางส่วนของคุณเอง

201
00:12:03,180 --> 00:12:08,030
>> เพื่อให้ถูกต้องห่อรอบ
ตัวอักษรและใช้สมซีซาร์

202
00:12:08,030 --> 00:12:11,280
แล้วเรารู้ว่าเราจำเป็นที่จะต้อง
จัดการกับดัชนีเรียงตามตัวอักษร

203
00:12:11,280 --> 00:12:15,130
แต่เราเริ่มต้นด้วย ASCII
ค่านิยมและเพียงแล้ว

204
00:12:15,130 --> 00:12:18,530
เราทำแล้วแปลงไป
ดัชนีเรียงตามตัวอักษร

205
00:12:18,530 --> 00:12:23,970
จากนั้นในการพิมพ์ที่เราต้องการ
ที่จะจัดการกับค่า ASCII อีกครั้ง

206
00:12:23,970 --> 00:12:28,350
ดังนั้นเราจึงจำเป็นที่จะต้องคิดออกว่าจะ
ไปจาก ASCII เพื่อตามตัวอักษร

207
00:12:28,350 --> 00:12:31,080
และจากตัวอักษรที่จะ ASCII

208
00:12:31,080 --> 00:12:34,910
>> ดังนั้นผมจึงปล่อยให้มันอยู่กับคุณที่จะคิดออก
รูปแบบระหว่างตัวละคร

209
00:12:34,910 --> 00:12:38,590
และตัวอักษรของมัน
ดัชนีและค่า ASCII ของมัน

210
00:12:38,590 --> 00:12:41,530
ตอนนี้จำได้ว่าถึงแม้
นี้ได้ในตารางบนสไลด์

211
00:12:41,530 --> 00:12:45,630
แสดงให้เห็นตัวอักษรที่เรายัง
มีการพิจารณาหรือไม่

212
00:12:45,630 --> 00:12:48,915
รูปแบบที่แตกต่างออกไป
สำหรับตัวอักษรกรณีที่ต่ำกว่า

213
00:12:48,915 --> 00:12:52,070

214
00:12:52,070 --> 00:12:55,840
>> ดังนั้นขณะนี้ที่เราได้คิดออก
วิธีการที่จะเปลี่ยนเป็นตัวอักษรเดียว

215
00:12:55,840 --> 00:13:02,200
แล้วสิ่งที่เราต้องทำคือขนาดที่
ขึ้นไปทั่วทั้งธรรมดา

216
00:13:02,200 --> 00:13:04,260
ดังนั้น plaintext เป็นสตริง

217
00:13:04,260 --> 00:13:08,210
โชคดีที่เราสตริงเป็นจริง
เพียงอาร์เรย์ของตัวอักษร

218
00:13:08,210 --> 00:13:12,150
ดังนั้นเพื่อที่จะเข้าถึงตัวละครทุกตัว
ของสตริงทั้งหมดที่คุณต้องทำ

219
00:13:12,150 --> 00:13:14,270
คือการใช้สัญกรณ์อาร์เรย์

220
00:13:14,270 --> 00:13:20,270
ว่าฉันมีตัวแปรประเภท
สตริงที่เรียกว่า "ข้อความ = 'นี่คือ CS50.'"

221
00:13:20,270 --> 00:13:22,730
>> อืมแล้วเพื่อที่จะ
เข้าถึงตัวละครแต่ละตัว

222
00:13:22,730 --> 00:13:25,880
สิ่งที่ฉันต้องทำอย่างไรกับ
ข้อความที่เป็นตัวแปร

223
00:13:25,880 --> 00:13:31,660
ที่จะบอกว่าดีข้อความที่ดัชนีศูนย์ว่า
สอดคล้องกับตันทุนที่ดัชนีข้อความ

224
00:13:31,660 --> 00:13:35,100
หนึ่งสอดคล้องกับกรณีที่ต่ำกว่าชั่วโมง

225
00:13:35,100 --> 00:13:38,110
อีกฟังก์ชั่นที่มีประโยชน์
ฟังก์ชั่นความยาวสาย

226
00:13:38,110 --> 00:13:40,760
ดังนั้นผ่านในสายไปยัง
ฟังก์ชั่นที่จะกลับมา

227
00:13:40,760 --> 00:13:44,610
จำนวนเต็มยาวของสตริงว่า

228
00:13:44,610 --> 00:13:47,060
>> ตอนนี้เราได้พูดคุยเกี่ยวกับ
ทุกองค์ประกอบที่แตกต่างเหล่านี้

229
00:13:47,060 --> 00:13:48,540
ขอนำพวกเขากลับมารวมกัน

230
00:13:48,540 --> 00:13:52,210
ดังนั้นกลับไปทั้ง pseudocode ของฉัน
รหัสหรือ pseudocode ของคุณ

231
00:13:52,210 --> 00:13:55,920
และไปถึงและให้แน่ใจว่าคุณ
รู้วิธีการทำทุกสิ่งเดียว

232
00:13:55,920 --> 00:14:01,520
การเดินทางที่สำคัญโดยใช้ argc และ argv,
เปลี่ยนที่สำคัญเป็นจำนวนเต็มเป็น

233
00:14:01,520 --> 00:14:06,840
เพื่อผมกระตุ้นสำหรับข้อความธรรมดา
GetString และจากนั้นทำซ้ำ

234
00:14:06,840 --> 00:14:09,590
มากกว่าตัวละครในทุก
สตริงธรรมดา

235
00:14:09,590 --> 00:14:14,910
การรักษากรณีของตัวละครแต่ละตัว
และขยับตัวละครที่โดยที่สำคัญ

236
00:14:14,910 --> 00:14:17,520
เพื่อให้มั่นใจว่าคุณ
ห่อรอบตัวอักษร

237
00:14:17,520 --> 00:14:20,850
ในที่สุดการพิมพ์ ciphertext ว่า

238
00:14:20,850 --> 00:14:25,470
ชื่อของฉันคือ Amila และนี่คือซีซาร์

239
00:14:25,470 --> 00:14:28,448

