Аміла: Давайте вирішувати Цезар. У Цезаря, ми дозволяємо користувачу для кодування секретне повідомлення. Так що давайте пірнати прямо і дивитися у наших к-DOS для цього завдання. Таким чином, по-перше, ми отримуємо ключ від користувача. Тоді ми отримаємо відкритий текст що вони хочуть, щоб кодувати. Після цього, ми зашифрувати це для них, і, нарешті, ми виводимо їх шифротекста. 

Отже, давайте почнемо з прикладу. Припустимо, ви хотіли, щоб кодувати Весь алфавіт з ключем двох. Ну, весь ваш алфавіт буде просто бути зміщені на листи. Таким чином, буде кодувати C, B до D, С до Е, так далі і тому подібне, поки ви не отримаєте до X, який кодує до Z або зет, в залежності від того, звідки ви. Тоді Y буде потім перекласти всю дорогу, обернути навколо алфавіту, щоб дістатися до A, а потім, нарешті, остання буква алфавіту, Z, зет, буде кодувати B. 

Ви отримали це? Давайте подивимося на деякі приклади. Перший приклад тут дуже схожий до того, що ми тільки що описано вище. Так що якщо я закодувати деяку секцію алфавіт, А через L, за допомогою ключа з двох, тоді я просто отримати вся моя алфавіт зрушені дві букви. 

Тоді, в моєму наступному прикладі, ключ все ще два, так що ви повинні знати, як і раніше які букви очікувати. Але ось це фраза. Це CS50. Таким чином, ви помітили, що я зберегти випадок моїх листів, тому будь-які великі літери також заголовні букви в зашифрованому тексті. І будь-який нижній регістр букви в незашифрованому Також в нижньому регістрі букви в зашифрованому тексті. Але я тримаю листи і будь-які знаки оклику або будь-які інші знаки пунктуації те ж саме. 

Так що тепер у нас є почуття за те, як працює програма, не соромтеся йти працювати ще трохи приклади самостійно, якщо ви хочете. Давайте почнемо з отриманням ключ від користувача. Традиційно, з інші проблеми, ми звикли до отримання будь-які цифри, які ми потрібно шляхом підказки користувачеві з функцією GetInt. Але на цей раз ми насправді відбувається використовувати аргумент командного рядка і нова функція називається atoi. 

При запуску основної Програма в С, то вона приймає в двох parameters-- INT ARGC, який це число аргументів пройшло, і потім ARGV, масив рядків, який містить список всіх аргументів пройшло. Ви явно не мають оголосити ці змінні. Вони розраховані для Ви компілятором. Правильне використання для цього було б для ARGC бути в даному випадку два, тому що користувач повинен пройти в виклик програми, ./caesar, а потім ключ, яке б число вони бажають. Таким чином, це означає, що ARGC має бути два для того, щоб дійсного використання Цезаря для виконання. 

Отже, давайте розглянемо приклад. Скажімо, я вже написав і склав програму під назвою Бластоф. Так що, якщо я побіг в командному рядку ./blastoff Rocket Team, ну, тоді, ARGC б три, тому що я пройшло в трьох різних аргументів. Тоді ARGV буде виглядати наступним чином. Це масив, і це було б містять кожен з трьох рядків. ./blastoff в першому індексу, команда в наступному, і ракети в останній. 

Давайте поговоримо про масивах на секунду. Масиви являють собою структури даних, які тримають кілька значень одного і того ж типу. Це може стати в нагоді, коли ми є списки цілих чисел або рядків. Просто пам'ятайте, у них є щоб бути того ж типу. У комп'ютерній науці, ми любов рахуючи від нуля, так що пам'ятаєте, що масиви також нульовий проіндексовані. Так що перший елемент мого масиву буде індексом нуль. Так що в цьому випадку, коли у мене є масив довжини чотири, то останній індекс вставленого Останній елемент мого масиву насправді буде за індексом три, а не чотири. Тому що пам'ятайте, що ми почати відлік з нуля. 

Ось приклад того, як ви може створити масив самостійно. Так що сказати, що я хотів, щоб зберегти мій три улюблені назви собаки. Тоді я хотів би створити масив рядків. Тому я хотів би оголосити тип, рядок, і потім помістити ім'я масиву, собаки, а потім в тих квадраті дужки поставити розмір з array-- в даному випадку, три. 

Так що моя перша запис буде щоб собаки з індексом нуль, і що буде Майло. Тоді собаки з індексом однієї буде недолугої, дорога Моті, а потім останній запис, третя запис на індексу два, буде мило, солодкий Elphie. Ви помітите, що формат для заповнення цього масиву дуже схоже, як ви могли б оголосити будь-яку іншу змінну, в якій у вас є ім'я змінної, за якою слідує значення, яке ви хочете зберігати в ньому. Єдина відмінність в цей випадок є те, що вам повинні пам'ятати, щоб поставити індекс значення в квадратних дужках. І там у нас є наші три улюблені собаки. 

Але, на жаль, прийшов час щоб повернутися до Цезарю. Пам'ятайте, що правильне використання для користувач буде проходить не тільки в назва програми ./caesar, але також ключ, що вони хочуть перекласти їх відкритого тексту за допомогою. Таким чином, це означає, що ARGC має бути два. Вони повинні пройти в two-- ні більше, ні менше двох аргументів командного рядка. 

Тепер, що стосується ARGV? Ну, ми вже знаємо, що масив буде мати довжину два, але те, що міститься в кожному елементі? Ну, перший елемент буде ./caesar, а потім наступний елемент буде містять ключ, який користувач надрукували. Тепер, якщо вони використовували його правильно для використання Цезаря, Потім вони збираються ввести номер. Але навіть якщо характер що вони друкують це число, це типу даних рядка. 

Так як же ми перетворимо, що рядок в ціле число? Так що у мене є Num, рядок, містить рядок 50. Якщо я хочу, щоб перетворити його в ціле число, то я просто оголосити нову змінної, цілого г, називаючи atoi. Я проходжу в моїй змінної рядка, Num і Потім я міститиме номер 50. Переконайтеся в тому, щоб перевірити чоловіка сторінки для функції atoi щоб перевірити, яка бібліотека це в, а також те, що значення його повернеться, якщо рядок, передана в містить не всі номери. 

Так що тепер ми отримали ключ, наступний крок щоб отримати відкритий текст від користувача. Тепер, це буде бути менш складним ніж навігації по аргументи командного рядка. Все, що нам потрібно зробити, це виклик функція GetString підказати користувачу, щоб дати нам рядок, але пам'ятайте, щоб перевірити специфікації для того, як ми може знадобитися підказати користувачу для цього. 

Тепер ми підійшли до серце problem-- як зашифрувати відкритий текст. Ну, по-перше, давайте поговоримо про те, як зашифрувати один символ в той час, і тоді ми будемо вирішувати, як перебирати весь відкритий текст. Я написав деякі псевдокод для завдання Цезаря. Я закликаю вас написати свій власний, а також. Він не може виглядати ідентично моє, і це нормально, але до тих пір, як загальна ідея та ж. 

Перші три кроки ми вже зробили. Ми отримали ключ від аргумент командного рядка, ми перетворили цей ключ в ціле число, і ми запит користувача для відкритого тексту що вони хочуть, щоб зашифрувати. Так тоді наступний великий шматок в тому, що для кожного символу в рядку відкритого тексту, якщо це алфавітний, ми хочемо зберегти її корпус і зрушити його. За зберегти справу, що я означає, що великі букви букви повинні залишатися Upper Корпус і всі літери нижнього регістру повинні залишатися в нижньому регістрі. Отже, після ми переміщаємо ті, Потім ми виводимо шифротекста. 

Ось три функції, які збираються щоб прийти в зручний для цієї проблеми. Пам'ятайте, нагорі, коли я дав Приклад для зсуву це CS50? Пам'ятайте, що 50 і Знак оклику не перекладав? Так як же ми можемо сказати, чи є ми необхідно перемістити лист чи ні? Ну, "альфа", якщо ви передаєте його персонаж, повертає істину, якщо цей символ цей лист і брехня в іншому випадку. Щоб допомогти вам збереження капіталізації є функціями "є верхній "і" нижче ". 

Ці дві функції також беруть в один символ в якості вхідних даних і повернути вам логічне значення, істинним або хибним в залежності від того, що характер в верхньому регістрі або нижньому регістрі. Тому що "зверху" і "є нижче "є булеві функції, Це означає, що вони повертають вам логічне значення, Ви можете використовувати їх в своїх умовах. Так ось фрагмент коду, який тільки друкує лист, якщо це в верхньому регістрі. Так що я оголосив мій характер листи в верхній корпус зет а потім, якщо "зверху" повертається правда, то я друкую цей лист. 

Повертаючись до нашого простий приклад зрушуючи алфавіт ключем з двох, як же ми насправді отримати, щоб працювати? Що ж, виходить, що персонажі і цілі числа дуже тісно пов'язані між собою. Кожен персонаж має ціле значення, пов'язане з ним знаходиться в ASCII графіку, де ASCII кожного символу відображається значення. Так що відповідає верхній регістр A до значення ASCII 65 і рядкової а до Значення ASCII з 97. 

Не соромтеся дивитися будь-ASCII діаграми онлайн щоб побачити ці цінності для себе. Так що ж це означає, що ми можемо приймають характер верхнього регістру A, додати ціле два до нього, а потім отримати символ верхнього регістру C в результаті. Це тому, що 65 років ASCII значення капіталу А, плюс 2, дає нам 67, що відповідає характером верхнього регістру С. 

На жаль, справи не зовсім так просто. У нас є рівняння, ми повинні розглянути. Тут він говорить про те, що г-й шифротекста буква відповідає г-й відкритий текст лист, плюс key-- все це модульна 26. Чому це так? Давайте повернемося до нашого прикладу з до того, де капітал А, плюс 2, дає нам капітал C. 

Таким чином, застосовуючи рівняння, специфікація дає нам, то давайте візьмемо капітал A плюс 2 і мод, який на 26. Так капітал А, коли я поклав його в ці одиничні лапки, дозволяє мені розглядати його як ціле число, так що дозволяє мені кинути його в ASCII-значення, 65. 65 плюс 2 67. 67 мод 26 дає нам 15, але це насправді не має сенс, тому що ми знаємо, що капітал C значення ASCII становить 67, а не 15. Так як же нам примирити це? 

Ну, тут я хотів би постулювати Поняття алфавітним покажчиком. Таким чином, ми вже говорили про те, як кожен символ має ASCII-значення, але я хотів би сказати, ну, давайте думати про кожен символ, що має також алфавітний покажчик, де А, наприклад, як перша буква алфавіту, має алфавітний покажчик нуля. Отже, тепер давайте застосуємо таке ж рівняння, як і раніше, але за допомогою алфавітного покажчика. 

Таким чином, дорівнює нулю, так як ми визначили. Таким чином, то, взявши нуль плюс два, по модулю 26, це два, по модулю 26, який дає нам два. І добре, в термінах алфавітний покажчик, C є третя буква в алфавіт, так що буде відповідати до алфавітному покажчику двох. Таким чином, здається, що за допомогою алфавітний покажчик в цьому випадку насправді дає нам правильний результат. 

Так що тепер давайте перевіримо на см, якщо рівняння робіт з алфавітним покажчиком. алфавітний покажчик Y є 24, як друге місце останньої букви в алфавіті. Отже 24 плюс наш Ключ двох дає нам 26. 26 мод 26 дає нам 0, що, на щастя для нас, і є алфавітний покажчик для А. Таким чином, ми сподіваємося, що досить того, що доказ алфавітний індексний метод працює. Якщо ні, не соромтеся спробувати деякі приклади самостійно. 

Для того, щоб належним чином обернути навколо алфавіт і застосувати рівняння Цезар, то ми знаємо, що нам потрібно мати справу з літерними індексами. Але ми починаємо з ASCII значення, і тільки потім ми потім перетворити в алфавітний покажчик. Звідти, щоб надрукувати, нам потрібно мати справу зі значеннями ASCII знову. Таким чином, ми повинні з'ясувати, як перейти від ASCII до алфавітного і від алфавітного в ASCII. 

Так що я залишаю вам, щоб з'ясувати, шаблон між характером і його алфавітний Індекс і його ASCII значення. Отже, пам'ятайте, що навіть якщо цю таблицю прямо на слайді показує, заголовні букви, ми також повинні розглянути питання про доцільність чи ні застосовується інший шаблон для нижнього регістра. 

Так що тепер, коли ми з'ясували, як перемістити один символ, то все, що ми повинні зробити, це шкала, щоб йти через весь текст. Таким чином, вихідний текст є рядком. На щастя для нас, рядок дійсно просто масив символів, тому для того, щоб отримати доступ кожен символ рядки, все, що вам потрібно зробити, полягає у використанні масиву позначення. Скажімо, у мене є змінна типу рядок називається "текст = 'це CS50.'" 

Ну, тоді, для того, щоб доступ кожного символу, все, що я повинен робити з змінна текст сказати, добре, текст з індексом нуль, то відповідає капіталу Т. Текст за індексом один відповідає рядкової ч. Ще одна корисна функція функція довжини рядка. Так переходячи в рядок, щоб що функція буде повертати ціле число, довжина цього рядка. 

Тепер, коли ми говорили про всі ці різні елементи, давайте їх разом. Так що повернутися до будь-якої моєї псевдокоді код або ваш псевдокод і йти до кінця і переконайтеся, що ви знають, як зробити кожну річ. Отримання ключа за допомогою ARGC і ARGV, поворотом ключа в ціле число, до I, запитуючи відкритого тексту, GetString, а потім переборі над кожним символом в незашифрованому рядок, зберігаючи випадок кожного символу і перехід цей символ за допомогою ключа, забезпечення того, щоб ви обтікання алфавіту, нарешті друк, що шифротекста. Мене звуть Аміла, і це був Цезар. 