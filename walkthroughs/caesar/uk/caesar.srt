1
00:00:00,000 --> 00:00:00,760

2
00:00:00,760 --> 00:00:02,270
>> Аміла: Давайте вирішувати Цезар.

3
00:00:02,270 --> 00:00:06,110
У Цезаря, ми дозволяємо користувачу
для кодування секретне повідомлення.

4
00:00:06,110 --> 00:00:09,780
Так що давайте пірнати прямо і дивитися
у наших к-DOS для цього завдання.

5
00:00:09,780 --> 00:00:12,210
Таким чином, по-перше, ми отримуємо ключ від користувача.

6
00:00:12,210 --> 00:00:15,210
Тоді ми отримаємо відкритий текст
що вони хочуть, щоб кодувати.

7
00:00:15,210 --> 00:00:21,380
Після цього, ми зашифрувати це для них,
і, нарешті, ми виводимо їх шифротекста.

8
00:00:21,380 --> 00:00:23,600
>> Отже, давайте почнемо з прикладу.

9
00:00:23,600 --> 00:00:26,920
Припустимо, ви хотіли, щоб кодувати
Весь алфавіт з ключем двох.

10
00:00:26,920 --> 00:00:31,360
Ну, весь ваш алфавіт буде
просто бути зміщені на листи.

11
00:00:31,360 --> 00:00:37,060
Таким чином, буде кодувати C, B до
D, С до Е, так далі і тому подібне,

12
00:00:37,060 --> 00:00:42,470
поки ви не отримаєте до X, який кодує до Z
або зет, в залежності від того, звідки ви.

13
00:00:42,470 --> 00:00:47,445
Тоді Y буде потім перекласти всю дорогу,
обернути навколо алфавіту, щоб дістатися до A,

14
00:00:47,445 --> 00:00:53,256
а потім, нарешті, остання буква
алфавіту, Z, зет, буде кодувати B.

15
00:00:53,256 --> 00:00:54,660
>> Ви отримали це?

16
00:00:54,660 --> 00:00:56,380
Давайте подивимося на деякі приклади.

17
00:00:56,380 --> 00:01:00,540
Перший приклад тут дуже схожий
до того, що ми тільки що описано вище.

18
00:01:00,540 --> 00:01:05,560
Так що якщо я закодувати деяку секцію
алфавіт, А через L, за допомогою ключа з двох,

19
00:01:05,560 --> 00:01:09,760
тоді я просто отримати вся моя
алфавіт зрушені дві букви.

20
00:01:09,760 --> 00:01:12,230
>> Тоді, в моєму наступному прикладі,
ключ все ще два,

21
00:01:12,230 --> 00:01:15,080
так що ви повинні знати, як і раніше
які букви очікувати.

22
00:01:15,080 --> 00:01:16,400
Але ось це фраза.

23
00:01:16,400 --> 00:01:18,100
Це CS50.

24
00:01:18,100 --> 00:01:21,090
Таким чином, ви помітили, що я
зберегти випадок моїх листів,

25
00:01:21,090 --> 00:01:25,600
тому будь-які великі літери також
заголовні букви в зашифрованому тексті.

26
00:01:25,600 --> 00:01:27,800
І будь-який нижній регістр
букви в незашифрованому

27
00:01:27,800 --> 00:01:30,640
Також в нижньому регістрі
букви в зашифрованому тексті.

28
00:01:30,640 --> 00:01:34,020
Але я тримаю листи
і будь-які знаки оклику

29
00:01:34,020 --> 00:01:37,610
або будь-які інші знаки пунктуації те ж саме.

30
00:01:37,610 --> 00:01:40,360
>> Так що тепер у нас є почуття
за те, як працює програма,

31
00:01:40,360 --> 00:01:43,890
не соромтеся йти працювати ще трохи
приклади самостійно, якщо ви хочете.

32
00:01:43,890 --> 00:01:47,072
Давайте почнемо з отриманням
ключ від користувача.

33
00:01:47,072 --> 00:01:48,780
Традиційно, з
інші проблеми, ми

34
00:01:48,780 --> 00:01:51,450
звикли до отримання
будь-які цифри, які ми

35
00:01:51,450 --> 00:01:54,710
потрібно шляхом підказки користувачеві
з функцією GetInt.

36
00:01:54,710 --> 00:01:58,850
Але на цей раз ми насправді відбувається
використовувати аргумент командного рядка

37
00:01:58,850 --> 00:02:01,760
і нова функція називається atoi.

38
00:02:01,760 --> 00:02:05,130
>> При запуску основної
Програма в С, то вона

39
00:02:05,130 --> 00:02:08,500
приймає в двох parameters--
INT ARGC, який

40
00:02:08,500 --> 00:02:11,670
це число аргументів
пройшло, і потім

41
00:02:11,670 --> 00:02:15,920
ARGV, масив рядків, який містить
список всіх аргументів

42
00:02:15,920 --> 00:02:16,740
пройшло.

43
00:02:16,740 --> 00:02:19,740
Ви явно не мають
оголосити ці змінні.

44
00:02:19,740 --> 00:02:22,700
Вони розраховані для
Ви компілятором.

45
00:02:22,700 --> 00:02:28,160
Правильне використання для цього було б
для ARGC бути в даному випадку два,

46
00:02:28,160 --> 00:02:32,630
тому що користувач повинен пройти в
виклик програми, ./caesar,

47
00:02:32,630 --> 00:02:35,570
а потім ключ,
яке б число вони бажають.

48
00:02:35,570 --> 00:02:39,920
Таким чином, це означає, що ARGC має бути два
для того, щоб дійсного використання Цезаря

49
00:02:39,920 --> 00:02:41,680
для виконання.

50
00:02:41,680 --> 00:02:43,590
>> Отже, давайте розглянемо приклад.

51
00:02:43,590 --> 00:02:47,760
Скажімо, я вже написав і
склав програму під назвою Бластоф.

52
00:02:47,760 --> 00:02:52,670
Так що, якщо я побіг в командному рядку
./blastoff Rocket Team, ну, тоді,

53
00:02:52,670 --> 00:02:57,750
ARGC б три, тому що я
пройшло в трьох різних аргументів.

54
00:02:57,750 --> 00:02:59,830
Тоді ARGV буде виглядати наступним чином.

55
00:02:59,830 --> 00:03:03,750
Це масив, і це було б
містять кожен з трьох рядків.

56
00:03:03,750 --> 00:03:09,640
./blastoff в першому індексу, команда
в наступному, і ракети в останній.

57
00:03:09,640 --> 00:03:11,610
>> Давайте поговоримо про масивах на секунду.

58
00:03:11,610 --> 00:03:15,560
Масиви являють собою структури даних, які тримають
кілька значень одного і того ж типу.

59
00:03:15,560 --> 00:03:19,980
Це може стати в нагоді, коли ми
є списки цілих чисел або рядків.

60
00:03:19,980 --> 00:03:23,030
Просто пам'ятайте, у них є
щоб бути того ж типу.

61
00:03:23,030 --> 00:03:25,310
У комп'ютерній науці, ми
любов рахуючи від нуля,

62
00:03:25,310 --> 00:03:29,260
так що пам'ятаєте, що масиви
також нульовий проіндексовані.

63
00:03:29,260 --> 00:03:34,360
Так що перший елемент мого масиву
буде індексом нуль.

64
00:03:34,360 --> 00:03:37,580
Так що в цьому випадку, коли у мене є
масив довжини чотири,

65
00:03:37,580 --> 00:03:41,350
то останній індекс вставленого
Останній елемент мого масиву

66
00:03:41,350 --> 00:03:44,970
насправді буде
за індексом три, а не чотири.

67
00:03:44,970 --> 00:03:48,880
Тому що пам'ятайте, що ми
почати відлік з нуля.

68
00:03:48,880 --> 00:03:52,530
>> Ось приклад того, як ви
може створити масив самостійно.

69
00:03:52,530 --> 00:03:56,440
Так що сказати, що я хотів, щоб зберегти мій
три улюблені назви собаки.

70
00:03:56,440 --> 00:03:59,030
Тоді я хотів би створити масив рядків.

71
00:03:59,030 --> 00:04:04,450
Тому я хотів би оголосити тип, рядок, і
потім помістити ім'я масиву, собаки,

72
00:04:04,450 --> 00:04:06,450
а потім в тих квадраті
дужки поставити розмір

73
00:04:06,450 --> 00:04:09,260
з array-- в даному випадку, три.

74
00:04:09,260 --> 00:04:12,690
>> Так що моя перша запис буде
щоб собаки з індексом нуль,

75
00:04:12,690 --> 00:04:14,750
і що буде Майло.

76
00:04:14,750 --> 00:04:17,850
Тоді собаки з індексом однієї
буде недолугої,

77
00:04:17,850 --> 00:04:23,060
дорога Моті, а потім останній
запис, третя запис на індексу два,

78
00:04:23,060 --> 00:04:26,130
буде мило, солодкий Elphie.

79
00:04:26,130 --> 00:04:28,610
Ви помітите, що формат
для заповнення цього масиву

80
00:04:28,610 --> 00:04:32,150
дуже схоже, як ви могли б
оголосити будь-яку іншу змінну, в якій

81
00:04:32,150 --> 00:04:36,307
у вас є ім'я змінної, за якою слідує
значення, яке ви хочете зберігати в ньому.

82
00:04:36,307 --> 00:04:38,140
Єдина відмінність в
цей випадок є те, що вам

83
00:04:38,140 --> 00:04:42,700
повинні пам'ятати, щоб поставити індекс
значення в квадратних дужках.

84
00:04:42,700 --> 00:04:46,420
І там у нас є наші
три улюблені собаки.

85
00:04:46,420 --> 00:04:48,780
>> Але, на жаль, прийшов час
щоб повернутися до Цезарю.

86
00:04:48,780 --> 00:04:52,910
Пам'ятайте, що правильне використання для
користувач буде проходить не тільки в

87
00:04:52,910 --> 00:04:57,430
назва програми ./caesar, але
також ключ, що вони хочуть перекласти

88
00:04:57,430 --> 00:04:58,850
їх відкритого тексту за допомогою.

89
00:04:58,850 --> 00:05:01,540
Таким чином, це означає, що ARGC має бути два.

90
00:05:01,540 --> 00:05:07,580
Вони повинні пройти в two-- ні більше, ні
менше двох аргументів командного рядка.

91
00:05:07,580 --> 00:05:09,050
>> Тепер, що стосується ARGV?

92
00:05:09,050 --> 00:05:12,880
Ну, ми вже знаємо, що
масив буде мати довжину два,

93
00:05:12,880 --> 00:05:15,270
але те, що міститься в кожному елементі?

94
00:05:15,270 --> 00:05:19,330
Ну, перший елемент
буде ./caesar,

95
00:05:19,330 --> 00:05:24,190
а потім наступний елемент буде
містять ключ, який користувач надрукували.

96
00:05:24,190 --> 00:05:27,480
Тепер, якщо вони використовували його правильно
для використання Цезаря,

97
00:05:27,480 --> 00:05:29,350
Потім вони збираються ввести номер.

98
00:05:29,350 --> 00:05:33,260
Але навіть якщо характер
що вони друкують це число,

99
00:05:33,260 --> 00:05:35,790
це типу даних рядка.

100
00:05:35,790 --> 00:05:40,390
>> Так як же ми перетворимо, що
рядок в ціле число?

101
00:05:40,390 --> 00:05:46,680
Так що у мене є Num, рядок,
містить рядок 50.

102
00:05:46,680 --> 00:05:49,000
Якщо я хочу, щоб перетворити його
в ціле число, то я просто

103
00:05:49,000 --> 00:05:53,340
оголосити нову змінної,
цілого г, називаючи atoi.

104
00:05:53,340 --> 00:06:01,160
Я проходжу в моїй змінної рядка, Num і
Потім я міститиме номер 50.

105
00:06:01,160 --> 00:06:04,350
Переконайтеся в тому, щоб перевірити чоловіка
сторінки для функції atoi

106
00:06:04,350 --> 00:06:07,990
щоб перевірити, яка бібліотека це
в, а також те, що значення його

107
00:06:07,990 --> 00:06:14,550
повернеться, якщо рядок, передана
в містить не всі номери.

108
00:06:14,550 --> 00:06:16,950
>> Так що тепер ми отримали
ключ, наступний крок

109
00:06:16,950 --> 00:06:19,430
щоб отримати відкритий текст від користувача.

110
00:06:19,430 --> 00:06:21,170
Тепер, це буде
бути менш складним

111
00:06:21,170 --> 00:06:23,410
ніж навігації по
аргументи командного рядка.

112
00:06:23,410 --> 00:06:26,190
Все, що нам потрібно зробити, це виклик
функція GetString

113
00:06:26,190 --> 00:06:29,660
підказати користувачу, щоб дати
нам рядок, але пам'ятайте,

114
00:06:29,660 --> 00:06:34,090
щоб перевірити специфікації для того, як ми
може знадобитися підказати користувачу для цього.

115
00:06:34,090 --> 00:06:36,420
>> Тепер ми підійшли до
серце problem--

116
00:06:36,420 --> 00:06:38,860
як зашифрувати відкритий текст.

117
00:06:38,860 --> 00:06:42,830
Ну, по-перше, давайте поговоримо про те, як
зашифрувати один символ в той час,

118
00:06:42,830 --> 00:06:47,370
і тоді ми будемо вирішувати, як
перебирати весь відкритий текст.

119
00:06:47,370 --> 00:06:50,440
Я написав деякі псевдокод
для завдання Цезаря.

120
00:06:50,440 --> 00:06:52,310
Я закликаю вас
написати свій власний, а також.

121
00:06:52,310 --> 00:06:55,900
Він не може виглядати ідентично
моє, і це нормально, але до тих пір,

122
00:06:55,900 --> 00:06:58,640
як загальна ідея та ж.

123
00:06:58,640 --> 00:07:00,780
>> Перші три кроки
ми вже зробили.

124
00:07:00,780 --> 00:07:03,100
Ми отримали ключ від
аргумент командного рядка,

125
00:07:03,100 --> 00:07:05,510
ми перетворили цей ключ
в ціле число, і ми

126
00:07:05,510 --> 00:07:09,320
запит користувача для відкритого тексту
що вони хочуть, щоб зашифрувати.

127
00:07:09,320 --> 00:07:12,420
Так тоді наступний великий шматок
в тому, що для кожного символу

128
00:07:12,420 --> 00:07:15,070
в рядку відкритого тексту,
якщо це алфавітний,

129
00:07:15,070 --> 00:07:17,750
ми хочемо зберегти
її корпус і зрушити його.

130
00:07:17,750 --> 00:07:20,900
За зберегти справу, що я
означає, що великі букви

131
00:07:20,900 --> 00:07:23,580
букви повинні залишатися Upper
Корпус і всі літери нижнього регістру

132
00:07:23,580 --> 00:07:25,640
повинні залишатися в нижньому регістрі.

133
00:07:25,640 --> 00:07:29,110
Отже, після ми переміщаємо ті,
Потім ми виводимо шифротекста.

134
00:07:29,110 --> 00:07:33,100
>> Ось три функції, які збираються
щоб прийти в зручний для цієї проблеми.

135
00:07:33,100 --> 00:07:38,010
Пам'ятайте, нагорі, коли я дав
Приклад для зсуву це CS50?

136
00:07:38,010 --> 00:07:41,800
Пам'ятайте, що 50 і
Знак оклику не перекладав?

137
00:07:41,800 --> 00:07:45,680
Так як же ми можемо сказати, чи є ми
необхідно перемістити лист чи ні?

138
00:07:45,680 --> 00:07:48,650
Ну, "альфа", якщо
ви передаєте його персонаж,

139
00:07:48,650 --> 00:07:54,850
повертає істину, якщо цей символ
цей лист і брехня в іншому випадку.

140
00:07:54,850 --> 00:07:56,870
Щоб допомогти вам
збереження капіталізації

141
00:07:56,870 --> 00:07:59,750
є функціями "є
верхній "і" нижче ".

142
00:07:59,750 --> 00:08:03,350
>> Ці дві функції також беруть
в один символ в якості вхідних даних

143
00:08:03,350 --> 00:08:06,580
і повернути вам логічне значення,
істинним або хибним

144
00:08:06,580 --> 00:08:11,280
в залежності від того, що характер
в верхньому регістрі або нижньому регістрі.

145
00:08:11,280 --> 00:08:14,610
Тому що "зверху" і "є
нижче "є булеві функції,

146
00:08:14,610 --> 00:08:18,660
Це означає, що вони повертають вам логічне значення,
Ви можете використовувати їх в своїх умовах.

147
00:08:18,660 --> 00:08:23,490
Так ось фрагмент коду, який тільки
друкує лист, якщо це в верхньому регістрі.

148
00:08:23,490 --> 00:08:27,790
Так що я оголосив мій характер
листи в верхній корпус зет

149
00:08:27,790 --> 00:08:33,440
а потім, якщо "зверху" повертається
правда, то я друкую цей лист.

150
00:08:33,440 --> 00:08:38,200
>> Повертаючись до нашого простий приклад
зрушуючи алфавіт ключем з двох,

151
00:08:38,200 --> 00:08:41,049
як же ми насправді отримати, щоб працювати?

152
00:08:41,049 --> 00:08:45,770
Що ж, виходить, що персонажі
і цілі числа дуже тісно пов'язані між собою.

153
00:08:45,770 --> 00:08:48,840
Кожен персонаж має
ціле значення, пов'язане

154
00:08:48,840 --> 00:08:53,260
з ним знаходиться в ASCII графіку,
де ASCII кожного символу

155
00:08:53,260 --> 00:08:55,380
відображається значення.

156
00:08:55,380 --> 00:08:58,940
Так що відповідає верхній регістр A
до значення ASCII 65

157
00:08:58,940 --> 00:09:02,270
і рядкової а до
Значення ASCII з 97.

158
00:09:02,270 --> 00:09:04,940
>> Не соромтеся дивитися
будь-ASCII діаграми онлайн

159
00:09:04,940 --> 00:09:07,720
щоб побачити ці цінності для себе.

160
00:09:07,720 --> 00:09:12,096
Так що ж це означає, що ми можемо
приймають характер верхнього регістру A,

161
00:09:12,096 --> 00:09:18,200
додати ціле два до нього, а потім отримати
символ верхнього регістру C в результаті.

162
00:09:18,200 --> 00:09:23,720
Це тому, що 65 років ASCII
значення капіталу А, плюс 2,

163
00:09:23,720 --> 00:09:29,960
дає нам 67, що відповідає
характером верхнього регістру С.

164
00:09:29,960 --> 00:09:33,480
>> На жаль, справи
не зовсім так просто.

165
00:09:33,480 --> 00:09:36,980
У нас є рівняння,
ми повинні розглянути.

166
00:09:36,980 --> 00:09:43,590
Тут він говорить про те, що г-й шифротекста
буква відповідає г-й відкритий текст

167
00:09:43,590 --> 00:09:48,900
лист, плюс key--
все це модульна 26.

168
00:09:48,900 --> 00:09:50,810
Чому це так?

169
00:09:50,810 --> 00:09:55,430
Давайте повернемося до нашого прикладу з
до того, де капітал А, плюс 2,

170
00:09:55,430 --> 00:09:57,590
дає нам капітал C.

171
00:09:57,590 --> 00:10:01,870
>> Таким чином, застосовуючи рівняння,
специфікація дає нам,

172
00:10:01,870 --> 00:10:06,660
то давайте візьмемо капітал A
плюс 2 і мод, який на 26.

173
00:10:06,660 --> 00:10:10,730
Так капітал А, коли я поклав його в
ці одиничні лапки,

174
00:10:10,730 --> 00:10:14,010
дозволяє мені розглядати його як
ціле число, так що дозволяє

175
00:10:14,010 --> 00:10:17,500
мені кинути його в ASCII-значення, 65.

176
00:10:17,500 --> 00:10:20,080
65 плюс 2 67.

177
00:10:20,080 --> 00:10:25,210
67 мод 26 дає нам 15,
але це насправді не

178
00:10:25,210 --> 00:10:32,590
має сенс, тому що ми знаємо, що
капітал C значення ASCII становить 67, а не 15.

179
00:10:32,590 --> 00:10:35,580
Так як же нам примирити це?

180
00:10:35,580 --> 00:10:39,840
>> Ну, тут я хотів би постулювати
Поняття алфавітним покажчиком.

181
00:10:39,840 --> 00:10:44,010
Таким чином, ми вже говорили про те, як
кожен символ має ASCII-значення,

182
00:10:44,010 --> 00:10:48,810
але я хотів би сказати, ну, давайте
думати про кожен символ, що має також

183
00:10:48,810 --> 00:10:52,230
алфавітний покажчик,
де А, наприклад,

184
00:10:52,230 --> 00:10:58,800
як перша буква алфавіту,
має алфавітний покажчик нуля.

185
00:10:58,800 --> 00:11:02,070
Отже, тепер давайте застосуємо
таке ж рівняння, як і раніше,

186
00:11:02,070 --> 00:11:05,040
але за допомогою алфавітного покажчика.

187
00:11:05,040 --> 00:11:07,810
>> Таким чином, дорівнює нулю, так як ми визначили.

188
00:11:07,810 --> 00:11:15,640
Таким чином, то, взявши нуль плюс два, по модулю 26,
це два, по модулю 26, який дає нам два.

189
00:11:15,640 --> 00:11:18,780
І добре, в термінах
алфавітний покажчик,

190
00:11:18,780 --> 00:11:23,930
C є третя буква в
алфавіт, так що буде відповідати

191
00:11:23,930 --> 00:11:26,290
до алфавітному покажчику двох.

192
00:11:26,290 --> 00:11:29,850
Таким чином, здається, що за допомогою
алфавітний покажчик в цьому випадку

193
00:11:29,850 --> 00:11:32,840
насправді дає нам правильний результат.

194
00:11:32,840 --> 00:11:35,020
>> Так що тепер давайте перевіримо на
см, якщо рівняння робіт

195
00:11:35,020 --> 00:11:37,210
з алфавітним покажчиком.

196
00:11:37,210 --> 00:11:42,540
алфавітний покажчик Y є 24, як
друге місце останньої букви в алфавіті.

197
00:11:42,540 --> 00:11:46,520
Отже 24 плюс наш
Ключ двох дає нам 26.

198
00:11:46,520 --> 00:11:54,750
26 мод 26 дає нам 0, що, на щастя для
нас, і є алфавітний покажчик для А.

199
00:11:54,750 --> 00:11:59,100
Таким чином, ми сподіваємося, що досить того, що доказ
алфавітний індексний метод працює.

200
00:11:59,100 --> 00:12:03,180
Якщо ні, не соромтеся спробувати
деякі приклади самостійно.

201
00:12:03,180 --> 00:12:08,030
>> Для того, щоб належним чином обернути навколо
алфавіт і застосувати рівняння Цезар,

202
00:12:08,030 --> 00:12:11,280
то ми знаємо, що нам потрібно
мати справу з літерними індексами.

203
00:12:11,280 --> 00:12:15,130
Але ми починаємо з ASCII
значення, і тільки потім

204
00:12:15,130 --> 00:12:18,530
ми потім перетворити в
алфавітний покажчик.

205
00:12:18,530 --> 00:12:23,970
Звідти, щоб надрукувати, нам потрібно
мати справу зі значеннями ASCII знову.

206
00:12:23,970 --> 00:12:28,350
Таким чином, ми повинні з'ясувати, як
перейти від ASCII до алфавітного

207
00:12:28,350 --> 00:12:31,080
і від алфавітного в ASCII.

208
00:12:31,080 --> 00:12:34,910
>> Так що я залишаю вам, щоб з'ясувати,
шаблон між характером

209
00:12:34,910 --> 00:12:38,590
і його алфавітний
Індекс і його ASCII значення.

210
00:12:38,590 --> 00:12:41,530
Отже, пам'ятайте, що навіть якщо
цю таблицю прямо на слайді

211
00:12:41,530 --> 00:12:45,630
показує, заголовні букви, ми також
повинні розглянути питання про доцільність чи ні

212
00:12:45,630 --> 00:12:48,915
застосовується інший шаблон
для нижнього регістра.

213
00:12:48,915 --> 00:12:52,070

214
00:12:52,070 --> 00:12:55,840
>> Так що тепер, коли ми з'ясували,
як перемістити один символ,

215
00:12:55,840 --> 00:13:02,200
то все, що ми повинні зробити, це шкала,
щоб йти через весь текст.

216
00:13:02,200 --> 00:13:04,260
Таким чином, вихідний текст є рядком.

217
00:13:04,260 --> 00:13:08,210
На щастя для нас, рядок дійсно
просто масив символів,

218
00:13:08,210 --> 00:13:12,150
тому для того, щоб отримати доступ кожен символ
рядки, все, що вам потрібно зробити,

219
00:13:12,150 --> 00:13:14,270
полягає у використанні масиву позначення.

220
00:13:14,270 --> 00:13:20,270
Скажімо, у мене є змінна типу
рядок називається "текст = 'це CS50.'"

221
00:13:20,270 --> 00:13:22,730
>> Ну, тоді, для того, щоб
доступ кожного символу,

222
00:13:22,730 --> 00:13:25,880
все, що я повинен робити з
змінна текст

223
00:13:25,880 --> 00:13:31,660
сказати, добре, текст з індексом нуль, то
відповідає капіталу Т. Текст за індексом

224
00:13:31,660 --> 00:13:35,100
один відповідає рядкової ч.

225
00:13:35,100 --> 00:13:38,110
Ще одна корисна функція
функція довжини рядка.

226
00:13:38,110 --> 00:13:40,760
Так переходячи в рядок, щоб
що функція буде повертати

227
00:13:40,760 --> 00:13:44,610
ціле число, довжина цього рядка.

228
00:13:44,610 --> 00:13:47,060
>> Тепер, коли ми говорили про
всі ці різні елементи,

229
00:13:47,060 --> 00:13:48,540
давайте їх разом.

230
00:13:48,540 --> 00:13:52,210
Так що повернутися до будь-якої моєї псевдокоді
код або ваш псевдокод

231
00:13:52,210 --> 00:13:55,920
і йти до кінця і переконайтеся, що ви
знають, як зробити кожну річ.

232
00:13:55,920 --> 00:14:01,520
Отримання ключа за допомогою ARGC і ARGV,
поворотом ключа в ціле число,

233
00:14:01,520 --> 00:14:06,840
до I, запитуючи відкритого тексту,
GetString, а потім переборі

234
00:14:06,840 --> 00:14:09,590
над кожним символом в
незашифрованому рядок,

235
00:14:09,590 --> 00:14:14,910
зберігаючи випадок кожного символу
і перехід цей символ за допомогою ключа,

236
00:14:14,910 --> 00:14:17,520
забезпечення того, щоб ви
обтікання алфавіту,

237
00:14:17,520 --> 00:14:20,850
нарешті друк, що шифротекста.

238
00:14:20,850 --> 00:14:25,470
Мене звуть Аміла, і це був Цезар.

239
00:14:25,470 --> 00:14:28,448

