Amila: Imos abordar César. En César, que permiten que o usuario para codificar unha mensaxe secreta. Entón, imos mergullar na dereita e ollar nas nosas to-dos a este problema. Entón, primeiro, temos a clave do usuario. Entón, temos o texto plano querer codificar. Despois diso, nós cifrar-lo para eles, e, finalmente, imprimir o seu texto cifrado. 

Entón, imos comezar cun exemplo. Digamos que quería para codificar o toda alfabeto cunha chave de dúas. Ben, todo o seu alfabeto sería só ser desprazado para letras. Así, un ía codificar para C, B para D, C e E, así por diante e así por diante, ata chegar ao X, que codifica a Z ou zed, dependendo de onde é. Entón Y, entón, cambiar toda a maneira, participa en torno do alfabeto para chegar a A, e logo, finalmente, a última letra da alfabeto, Z, zed, que codifican para B. 

Vostede entendeu? Vexamos algúns exemplos. O primeiro exemplo é moi semellante ao que só se explica anteriormente. Entón, se eu codificar algunha sección do alfabeto, de A a G, por unha chave de dúas, entón eu só incorporarse miña enteira alfabeto desprazou dúas cartas. 

Entón, o meu seguinte exemplo, a clave é aínda dous, así aínda que saber que as letras que esperar. Pero aquí é unha frase. Este é CS50. Entón vai entender que eu preservar o caso miñas cartas, polo que todas as letras maiúsculas son tamén maiúsculas no texto cifrado. E calquera minúsculas letras en texto tamén son minúsculas letras no texto cifrado. Pero eu sigo as letras e os puntos de exclamación ou calquera outro tipo de puntuación da mesma. 

Polo tanto, agora que temos un sentido de como traballa o programa, Sinto-se libre para ir correr un pouco máis exemplos do seu propio país, se o desexa. Imos comezar coa obtención a clave do usuario. Tradicionalmente, con outros problemas, temos foi acostumado a obter todos os números que Debe avisar o usuario coa getInt función. Pero esta vez imos realmente usar o argumento da liña de comandos e unha nova función chamada atoi. 

Cando fai o principal programa en C, entón leva en dous parameters-- int argc, que é o número de argumentos transmitido, e entón argv, unha matriz de cadeas que contén unha lista de todos os argumentos pasado. Non ten explicitamente para declarar estas variables. Están computados para vostede polo compilador. uso correcto para iso sería argc para ser dúas neste caso porque o usuario ten que pasar en a chamada ao programa, ./caesar, e, a continuación, a tecla, calquera número que desexa. Entón isto significa que argc debe ser dous Para que un uso válida de César para ser executado. 

Entón, imos ollar un exemplo. Digamos que eu xa escribín e compilado un programa chamado blastoff. Entón, se eu execute na liña de comandos ./blastoff Equipo Rocket, ben, entón, argc serían tres, porque pasados ​​en tres argumentos distintos. Entón argv quedaría así. É unha matriz, e sería conter cada un dos tres cordas. ./blastoff o primeiro índice, equipo o próximo, e foguete no último. 

Imos falar sobre matrices para un segundo. Matrices son estruturas de datos que almacenan varios valores do mesmo tipo. Isto pode vir a cadra cando teñen listas de números enteiros ou cadeas. Basta lembrar que teñen para ser do mesmo tipo. Na ciencia da computación, nós amor contando desde cero, entón recorda que as matrices tamén están con índice cero. Así, o primeiro elemento da miña matriz será no índice cero. Polo tanto, neste caso, cando teño unha matriz de lonxitude de catro, a continuación, o último índice do último elemento da miña matriz é realmente vai ser no índice tres, non catro. Porque lembre, nós comezar a contar en cero. 

Aquí está un exemplo de como Pode crear unha matriz de seu propio país. Entón, digamos que eu quería para gardar a miña tres nomes favoritos do can. Entón eu ía crear unha matriz de cadeas. Así, quere declarar o tipo, corda, e a continuación, colocar o nome da matriz, cans, e, a continuación, os cadrados soportes de poñer o tamaño do array-- neste caso tres. 

Así, a miña primeira entrada vai para ser cans no índice cero, e que será Milo. Entón cans nun índice de será pateta, querida Mochi, e, a continuación, o último entrada, a terceira entrada no índice dous, vai ser bonito, doce Elphie. Vai notar que o formato para cubrir esa matriz é moi parecido como pode declarar outra variable, onde ten o nome da variable seguido o valor que quere almacenados nel. A única diferenza en Neste caso é que Ten que se lembrar de poñer o índice do valor entre corchetes. E aí temos o noso tres cans favoritos. 

Pero, desgraciadamente, é hora para volver a César. Lembre que o uso correcto para o usuario estará pasando, non só o nome do programa ./caesar pero tamén a clave que queren cambiar seu texto por. Entón isto significa que argc debe ser dous. Deben pasar dois-- nin máis, nin menos de dous argumentos de liña de comandos. 

Agora, que tal argv? Ben, xa sabemos que a matriz será de lonxitude dous, pero o que está contido en cada elemento? Ben, o primeiro elemento será ./caesar, e, a continuación, o seguinte elemento vai conter a clave que o usuario inseriu. Agora, se utilizaban-lo correctamente para o uso de César, A continuación, eles van para inserir un número. Pero aínda que o personaxe que tipo é un número, é do tipo cadea de datos. 

Entón, como imos converter esta cadea para un enteiro? Entón, dicir que teño un, unha corda, que contén a cadea 50. Se eu queira converter ese para un enteiro, entón eu simplemente declarar unha nova variable, un enteiro I, chamando atoi. Pasar o meu variable de cadea, nun, e entón eu conterá entón o número 50. Asegúrese de comprobar o home páxinas para a función atoi para comprobar cal biblioteca é no, así como o valor que volverá a cadea pasada en non conter todos os números. 

Polo tanto, agora que obtivemos a clave, o seguinte paso é facer que o texto orixinal do usuario. Agora, iso vai ser menos complicada que navegar arredor do argumentos de liña de comandos. Todo o que temos que facer é chamar a función getString para pedir ao usuario para dar -Nos unha corda, pero lembre se para comprobar as especificacións de como nós Pode querer para solicitar ao usuario para iso. 

Agora chegamos á corazón do problema-- como cifrar o texto plano. Ben, en primeiro lugar, imos falar sobre como para cifrar un carácter de cada vez, e despois imos abordar como iterado sobre todo o texto simple. Escribín algúns pseudocódigo ao problema de César. Estimula-vos a escribir o seu propio ben. Pode non parecer idéntico á meu, e iso é OK, pero sempre como a idea xeral é a mesma. 

Os tres primeiros pasos xa fixemos. Comezamos a clave argumento da liña de comandos, nós transformamos esa chave nun número enteiro, e solicitado ao usuario para o texto que queren cifrar. Entón a próxima gran peza é que, para cada carácter na secuencia de texto, se é alfabético, queremos conservar o caso e transferir-lo. Ao conservar a caso, o que eu quero dicir é que todas as letras maiúsculas letras debe permanecer superior caso e todas as letras minúsculas debe permanecer en minúsculas. Entón, a continuación, despois de cambiar os, entón imprimir o texto cifrado. 

Aquí están tres funcións que van de vir a cadra para este problema. Marca-se por riba cando eu dei o exemplo para desprazarse este é CS50? Lembre que o 50 eo signo de exclamación non cambiar? Entón, como podemos dicir si que cambiar unha letra ou non? Ben, "é alfa," se vostede pasalo un personaxe, volverá true se ese personaxe é unha letra e falso se non. Para axudar con preservando capitalización son as funcións "está superior "e" inferior é. " 

Estas dúas funcións tamén tomar nun único carácter como entrada e voltar un booleano, verdadeiro ou falso dependendo se ese personaxe é maiúsculas ou minúsculas. Porque "é superior" e "é inferior "son funcións booleanas, o que significa que eles retornan un booleano, podes usalos nas súas condicións. Entón aquí está o treito de código que só imprime carta se é maiúscula. Entón eu dixo a miña personaxe carta para ser o caso superior zed e entón, se "é superior" retorno verdade, entón eu imprimir esta letra. 

Volvendo ao noso exemplo simple desprazando o alfabeto por unha chave de dúas, como é que imos realmente ter que traballar? Ben, acontece que personaxes e enteiros están intimamente relacionados. Cada personaxe ten unha valor enteiro asociado con el atopou no gráfico ASCII, onde ASCII de cada personaxe valor aparece. Así, un corresponde un caso superior para un valor ASCII de 65 e unha minúscula ao un valor ASCII de 97. 

Sinto-se libre para mirar para arriba calquera gráfico ASCII en liña para ver eses valores para si mesmo. Entón, o que isto significa que podemos asumir o carácter de maiúsculas A, engadir o número enteiro de dous a ela, e logo, obter o caso de caracteres C superior como resultado. Porque 65, o ASCII valor para o capital de A, máis 2, ofrécenos 67, o que corresponde ao carácter de maiúsculas C. 

Desafortunadamente, as cousas non moi ser tan sinxelo. Temos unha ecuación que debemos considerar. Aquí nos di que o texto cifrado om letra corresponde ao texto om carta, ademais da key-- todo isto, modular 26. Por que é este o caso? Imos volver ao noso exemplo de antes, onde o capital A, máis 2, dános de capital C. 

Así que a aplicación da ecuación especificación dános, logo imos dar maiúsculo ademais de 2 e mod que 26. Así, o capital A, cando poñelas esas comiñas, permíteme a trata-lo como un número enteiro, de xeito que permite me para lanzalo ao seu valor ASCII, 65. 65 + 2 e 67. 67 mod 26 dános 15, pero iso realmente non ten sentido, porque sabemos que o capital de valor ASCII C é de 67, e non 15. Entón, como podemos conciliar iso? 

Ben, aquí gustaríame postular a noción dun índice alfabético. Entón, nós xa falamos de como Cada personaxe ten o seu valor ASCII, pero gustaríame dicir, ben, imos pensar en cada personaxe ter un índice alfabético, onde A, por exemplo, como a primeira letra do alfabeto, ten un índice alfabético de cero. Entón agora imos aplicar o mesma ecuación, como antes, pero usando un índice alfabético. 

Entón A é cero, como xa definido. Entón, a continuación, tendo cero dous, mod 26, que é dous, mod 26, o que nos dá dous. E así, en termos de un índice alfabético, C é a terceira letra na alfabeto, de xeito que correspondería para un índice alfabético de dous. Así, parece que a utilización do Índice alfabético, neste caso, realmente nos dá o resultado correcto. 

Entón agora imos comprobar a ver as obras de ecuacións cun índice alfabético. Índice alfabético de Y é de 24 como a segundo a última letra do alfabeto. Así entón 24 máis a nosa clave de dous dános 26. 26 mod 26 dános 0, o que, por sorte nós, é o índice alfabético para A. Polo tanto, esperamos que iso é proba suficiente de que o método índice alfabético funciona. Se non, Sinto-se libre para probar algúns exemplos do seu propio país. 

A fin de involucrar adecuadamente en torno á alfabeto e aplicar a ecuación de César, entón sabemos que necesitamos xestionar índices alfabéticos. Pero imos comezar con ASCII valores, e só entón nós, logo converter a o índice alfabético. De alí, a fin de imprimir, cómpre para xestionar os valores ASCII novo. Entón, necesitamos descubrir como ir de ASCII a orde alfabética e de alfabética para ASCII. 

Entón eu deixo para descubrir o estándar entre un personaxe e os seus alfabética Índice eo seu valor ASCII. Agora lembre que, a pesar de este dereito táboa no slide mostra as maiúsculas, nós tamén Ten que considerar se é ou non un patrón diferente aplicable para os caracteres minúsculos. 

Polo tanto, agora que descubrimos como cambiar un único personaxe, logo todos temos que facer é escala que -Se para ir ao longo de todo o texto plano. Así, o texto orixinal é unha cadea. Sorte para nós, unha cadea é realmente só un array de caracteres, por iso, para acceder cada personaxe dunha cadea, o único que tes que facer é usar a notación de matriz. Digamos que teña unha variable do tipo cadea chamada "text =" este é CS50 '. " 

Pois ben, a fin de acceder cada personaxe, todo o que teño que ver con O texto variable é para dicir ben, o texto no índice cero, que corresponde ao capital T. texto no índice unha corresponde ao caso inferior h. Outra función útil é a función lonxitude da corda. Entón, pasando nunha cadea que a función pode voltar un enteiro, a lonxitude desta corda. 

Agora que xa falamos sobre todos estes elementos diferentes, imos xuntalos de novo. Entón, volver en calquera meu pseudocódigo código é o pseudocódigo e pasar por e asegúrese de que sabe como facer cada cousa. Obtendo a chave a usar argc e argv, xirando a clave para un número enteiro, un para i, alertando para texto, getString, a continuación, a iteración sobre cada personaxe a cadea de texto, preservando o caso de cada carácter e cambiando ese carácter pola chave, garantir que está enrolar o alfabeto, finalmente, imprimir o texto cifrado. O meu nome é Amila, e esta era César. 