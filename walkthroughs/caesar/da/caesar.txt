Amila: Lad os tage fat Cæsar. I Caesar, vi tillader brugeren at indkode en hemmelig besked. Så lad os dykke ret i og se på vore gøremål for dette problem. Så først, får vi nøglen fra brugeren. Derefter får vi den alm at de ønsker at indkode. Efter at vi kryptere det for dem, og endelig vi printe deres ciphertext. 

Så lad os starte med et eksempel. Sig du ønskede at indkode hele alfabetet med en nøgle af to. Nå, hele din alfabetet ville bare blive flyttet til bogstaver. Så en ville kode til C, B til D, C til E, så videre og så videre, indtil du kommer til X, som koder til Z eller Zed, afhængigt af hvor du er fra. Så er Y ville derefter flytte hele vejen, wrap omkring alfabetet for at komme til A, og så endelig den sidste bogstav i alfabet, Z, zed, ville kode til B. 

Du fik det? Lad os se på nogle eksempler. Det første eksempel her er meget ens til, hvad vi netop forklaret ovenfor. Så hvis jeg indkode nogle afsnit af alfabetet, A til L, med en nøgle på to, så jeg bare får min hele alfabet flyttet to bogstaver. 

Så i min næste eksempel, nøglen er stadig to, så du skal stadig vide hvilke bogstaver forvente. Men her er det en sætning. Dette er CS50. Så du vil opdage, at jeg bevare tilfælde af mine breve, så eventuelle store bogstaver er også store bogstaver i ciphertext. Og enhver små bogstaver bogstaver i klartekst er også små bogstaver bogstaver i ciphertext. Men jeg holder bogstaverne og eventuelle udråbstegn eller enhver anden tegnsætning samme. 

Så nu, at vi har en fornemmelse for, hvordan programmet virker, velkommen til at gå køre nogle mere eksempler på dine egne, hvis du ønsker det. Lad os starte med at få nøglen fra brugeren. Traditionelt med andre problemer, vi har været vant til at få nogen numre, som vi brug ved at spørge brugeren med funktionen getint. Men denne gang vi faktisk vil at bruge kommandolinjen argument og en ny funktion kaldet atoi. 

Når du kører det vigtigste program i C, så er det tager i to parameters-- int argc, som er antallet af argumenter bestået i, og derefter argv, et array af strenge, der indeholder listen over alle de argumenter øjeblikkeligt. Du behøver ikke udtrykkeligt har at erklære disse variabler. De er beregnet til du af compileren. Korrekt brug for dette ville være for argc at være to i denne sag, fordi brugeren skal passere i opkaldet til programmet, ./caesar, og derefter på tasten, uanset antal, de ønsker. Så det betyder, at argc skal være to For at en gyldig anvendelse af Caesar der skal udføres. 

Så lad os se på et eksempel. Sig Jeg har allerede skrevet og udarbejdet et program kaldet blastoff. Så hvis jeg løb i kommandolinjen ./blastoff Team Rocket, ja, så, argc ville være tre, fordi jeg bestået i tre forskellige argumenter. Så argv ville se sådan ud. Det er et array, og det ville indeholde hver af de tre strenge. ./blastoff i første indeks, hold i den næste, og raket i den sidste. 

Lad os tale om arrays til en sec. Arrays er datastrukturer, der holder flere værdier af samme type. Dette kan komme i handy, når vi har lister af heltal eller strenge. Bare husk at de har at være den samme type. I datalogi, vi elsker at tælle fra nul, så husk at arrays er også nul-indekseret. Så den første del af min matrix vil være ved indeks nul. Så i dette tilfælde, når jeg har et array af længde fire, derefter sidst indeks for sidste element i min matrix rent faktisk vil være ved indeks tre, ikke fire. Fordi husk, vi begynde at tælle ved nul. 

Her er et eksempel på, hvordan du kunne skabe en række af dine egne. Så siger jeg ønskede at gemme min tre foretrukne hund navne. Så ville jeg skabe en række strenge. Så jeg ville erklære den type, snor, og derefter sætte navnet på arrayet, hunde, og derefter i de firkantede parentes sætte størrelsen af array-- i dette tilfælde tre. 

Så mit første post går at være hunde ved indeks nul, og det kommer til at være Milo. Så hunde på indeks én vil være goofy, Darling Mochi, og derefter den sidste post, den tredje indrejse ved indeks to, kommer til at være sød, sød Elphie. Du vil opdage, at formatet til at udfylde dette array er meget gerne, hvordan du måske erklære enhver anden variabel, hvor du har variabelnavnet efterfulgt af den værdi, du ønsker gemt i det. Den eneste forskel i dette tilfælde er, at du skal huske at sætte indekset af værdien i firkantede parenteser. Og der har vi vores tre foretrukne hunde. 

Men ak, er det tid at komme tilbage til Cæsar. Husk, at korrekt brug for Brugeren vil være passerer i ikke bare navnet på det program ./caesar, men også nøglen at de ønsker at flytte deres klartekst ved. Så det betyder, at argc skal være to. De skal passere i to-- ikke mere, ikke mindre end to kommandolinjeargumenter. 

Nu, hvad argv? Nå, vi allerede ved, at matrix vil være af en længde to, men hvad der er indeholdt i hver element? Nå, det første element vil være ./caesar, og derefter den næste element vil indeholde den nøgle, brugeren har indtastet. Nu, hvis de brugte det korrekt for brugen af ​​Cæsar, så de kommer til at indtaste et nummer. Men selv om tegnet at de type er et tal, det er af datatypen string. 

Så hvordan kan vi konvertere denne streng til et heltal? Så siger jeg har num, en streng, indeholdende strengen 50. Hvis jeg ønsker at konvertere, at til et heltal, så jeg simpelthen erklære en ny variabel, en heltal jeg, kalder atoi. Jeg passerer i min streng variabel, num, og så vil jeg da indeholde nummer 50. Sørg for at tjekke manden sider til atoi funktionen at kontrollere, hvilket bibliotek det er i, samt hvilken værdi den vil vende tilbage, hvis strengen bestået i indeholder ikke alle numre. 

Så nu, at vi har fået nøglen, det næste trin er at få klartekst fra brugeren. Nu, dette kommer til at være mindre kompliceret end at navigere rundt i kommandolinjeargumenter. Alt, hvad vi skal gøre er at ringe den getString funktionen til at bede brugeren, hvilket gav os en streng, men husk at kontrollere specifikationerne for, hvordan vi måske ønsker at bede brugeren om det. 

Nu kommer vi til hjertet af problem-- hvordan man kryptere alm. Nå, først, lad os tale om, hvordan at kryptere et tegn ad gangen, og så vil vi tage fat på, hvordan man gentage over hele klartekst. Jeg har skrevet nogle pseudokode for Cæsar problemet. Jeg opfordrer dig til at skriv din egen såvel. Det ser måske ikke identisk med mine, og det er OK, men så længe som den generelle idé er den samme. 

De tre første trin Vi har allerede gjort. Vi har fået nøglen fra kommandolinjen argument, Vi har slået denne nøgle i et helt tal, og vi har bedt brugeren til klartekst at de ønsker at kryptere. Så den næste store luns er, at for hver karakter i klartekst streng, hvis det er alfabetiske, vi ønsker at bevare sin sag og flytte det. Ved bevare tilfælde, hvad jeg mener er, at alle store bogstaver breve bør forblive øvre sag og alle små bogstaver bør forblive små bogstaver. Så efter vi flytte dem, så vi udskrive ciphertext. 

Her er tre funktioner, der går at komme i handy for dette problem. Husk op over, da jeg gav eksempel for at flytte dette er CS50? Husk, at 50 og udråbstegn ikke flytte? Så hvordan kan vi fortælle, om vi nødt til at flytte et brev eller ej? Nå, "er alpha," hvis du passerer det et tegn, vil returnere sand, hvis denne karakter er et brev og falsk ellers. For at hjælpe dig med bevare kapitalisering er funktionerne "er øvre "og" er lavere. " 

Disse to funktioner også tage i et enkelt tegn som input og returnere dig en boolesk, enten sandt eller falsk alt efter om denne karakter er store eller små bogstaver. Fordi "er øvre" og "er lavere "er Boolske funktioner, hvilket betyder, at de vender tilbage dig en boolesk, du kan bruge disse i dine forhold. Så her er en stump kode, som kun udskriver et brev, hvis det er store bogstaver. Så jeg har erklæret min karakter brev skal den store bogstaver zed og derefter, hvis "er øverste" returnerer sandt, så jeg udskrive det bogstav. 

Går tilbage til vores simpelt eksempel på forskydning alfabetet med en nøgle på to, hvordan får vi rent faktisk få det til at virke? Tja, det viser sig, at tegn og heltal er meget nært beslægtet. Hver figur har en heltalsværdi forbundet med det konstateret i ASCII diagram, hvor hver figurs ASCII værdi vises. Så en store bogstaver A svarer til en ASCII værdi på 65 og et lille a til en ASCII værdi på 97. 

Du er velkommen til at kigge op enhver ASCII diagram online at se disse værdier for dig selv. Så hvad dette betyder, at vi kan tage karakter af store bogstaver A, føje heltal to til det, og derefter få tegnet store bogstaver C som følge heraf. Det er fordi 65, ASCII værdi for kapital A, plus 2, giver os 67, som svarer til karakteren af ​​store bogstaver C. 

Desværre er tingene vil ikke helt være så simpelt. Vi har en ligning, der vi nødt til at overveje. Her fortæller os, at den i'te ciphertext brev svarer til den i'te klartekst brev, plus key-- alt dette, modulære 26. Hvorfor er det tilfældet? Lad os gå tilbage til vores eksempel fra før, hvor stort A, plus 2, giver os kapital C. 

Så anvende ligning, specifikationen giver os, så lad os tage kapital A plus 2 og mod at ved 26. Så stort A, når jeg sætter det i disse enkelte anførselstegn, tillader mig at behandle det som et heltal, således at tillader mig til at kaste det for sin ASCII værdi, 65. 65 plus 2 er 67. 67 mod 26 giver os 15, men det betyder ikke rigtig give mening, fordi vi ved, at kapital C ASCII værdi er 67, ikke 15. Så hvordan kan vi forene det? 

Nå, her vil jeg gerne postulere den Begrebet et alfabetisk indeks. Så vi har allerede talt om, hvordan hver karakter har sin ASCII værdi, men jeg vil gerne sige, godt, lad os tænke over hver karakter også har et alfabetisk indeks, hvor A for eksempel, som det første bogstav i alfabetet, har et alfabetisk indeks på nul. Så lad os nu anvende den samme ligning som før, men under anvendelse af et alfabetisk indeks. 

Så A er nul, da vi har defineret. Så tager nul plus to, mod 26, det er to, mod 26, hvilket giver os to. Og godt, i form af et alfabetisk indeks, C er det tredje bogstav i alfabet, således at ville svare til et alfabetisk indeks på to. Så det lader til, at anvendelse af alfabetisk indeks i dette tilfælde faktisk giver os det korrekte resultat. 

Så lad os nu kontrollere se om ligningen værker med et alfabetisk indeks. Y s alfabetiske indeks er 24 som den næstsidste bogstav i alfabetet. Så 24 plus vores nøgle af to giver os 26. 26 mod 26 giver os 0, hvilket heldig for os, er det alfabetiske indeks for A. Så forhåbentlig er bevis nok, at det alfabetiske indeks metoden fungerer. Hvis ikke, er du velkommen til at prøve nogle eksempler på din egen. 

For at kunne vikle omkring alfabet og anvende Cæsar ligningen, så ved vi, at vi er nødt til behandle alfabetiske indekser. Men vi starter med ASCII værdier, og først derefter vi derefter konvertere til det alfabetiske indeks. Derfra for at kunne udskrive, har vi brug at beskæftige sig med ASCII-værdier igen. Så vi er nødt til at finde ud af at gå fra ASCII til alfabetisk og fra alfabetisk til ASCII. 

Så jeg overlade det til dig at finde ud mønstret mellem et tegn og dens alfabetisk indeks og dets ASCII værdi. Husk nu, at selvom denne tabel højre på dias viser de store bogstaver, vi også nødt til at overveje, hvorvidt et andet mønster gælder for de små bogstaver. 

Så nu, at vi har fundet ud af hvordan at flytte et enkelt tegn, så alt vi skal gøre, er at skala, som op for at gå på tværs af hele klartekst. Så klartekst er en streng. Lucky for os, en streng er virkelig blot et array af tegn, så for at få adgang til alle tegn af en streng, alt du skal gøre er at bruge matrix notation. Sige, at jeg har en variabel af typen streng kaldet "text =" dette er CS50. ' " 

Nå, så for at adgang hver karakter, alt jeg har at gøre med den variable tekst er at sige godt, tekst indeks nul, at svarer til kapital T. Tekst på indeks man svarer til det nedre hus h. En anden nyttig funktion er snor længde funktionen. Så passerer i en streng til at funktionen vil returnere et helt tal, længden af ​​denne streng. 

Nu, hvor vi har talt om alle disse forskellige elementer, lad os sætte dem sammen igen. Så tilbage til enten min pseudokode kode eller din pseudokode og gå igennem, og sørg for, at du ved hvordan man gør hver eneste ting. At få nøglen ved hjælp argc og argv, dreje nøglen i et heltal, et til jeg, hvilket fik til klartekst, getString, og derefter iteration over hver karakter i plaintext streng, bevare tilfælde af hvert tegn og flytte denne karakter af nøglen, at sikre, at du er indpakning omkring alfabetet, endelig udskriver ciphertext. Mit navn er Amila, og dette var Cæsar. 