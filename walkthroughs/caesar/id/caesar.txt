Amila: Mari kita mengatasi Caesar. Di Caesar, kami memungkinkan pengguna untuk mengkodekan pesan rahasia. Jadi mari kita menyelam kanan dan terlihat di kami to-dos untuk masalah ini. Jadi pertama, kita mendapatkan kunci dari pengguna. Maka kita mendapatkan plaintext bahwa mereka ingin mengkodekan. Setelah itu, kami menulis dlm kode untuk mereka, dan akhirnya kami mencetak ciphertext mereka. 

Jadi mari kita mulai dengan sebuah contoh. Katakanlah Anda ingin menyandikan Seluruh alfabet dengan kunci dari dua. Nah, seluruh alfabet Anda akan hanya bergeser ke huruf. Jadi A akan menyandikan ke C, B ke D, C ke E, seterusnya dan sebagainya, sampai Anda mendapatkan ke X, yang mengkode untuk Z atau zed, tergantung di mana Anda dari. Kemudian Y maka akan menggeser semua jalan, membungkus alfabet untuk mendapatkan A, dan akhirnya surat terakhir dari alfabet, Z, zed, akan menyandikan ke B. 

Kau mengerti? Mari kita lihat beberapa contoh. Contoh pertama di sini sangat mirip untuk apa yang baru saja kami jelaskan di atas. Jadi jika saya mengkodekan beberapa bagian dari alfabet, A sampai L, dengan kunci dari dua, maka saya hanya mendapatkan seluruh saya alfabet bergeser dua surat. 

Kemudian, dalam contoh berikutnya, kuncinya adalah masih dua, sehingga Anda masih harus tahu yang surat yang diharapkan. Tapi di sini itu frase. Ini adalah CS50. Jadi Anda akan melihat bahwa saya melestarikan kasus surat saya, sehingga setiap huruf besar juga huruf besar di ciphertext. Dan huruf kecil saja huruf dalam plaintext juga huruf kecil huruf dalam ciphertext. Tapi aku tetap huruf dan setiap tanda seru atau tanda baca lainnya yang sama. 

Jadi sekarang kita memiliki arti untuk bagaimana program itu bekerja, merasa bebas untuk pergi berjalan lagi contoh Anda sendiri, jika Anda inginkan. Mari kita mulai dengan mendapatkan kunci dari pengguna. Secara tradisional, dengan masalah lain, kami telah terbiasa mendapatkan setiap nomor yang kita butuhkan dengan mendorong pengguna dengan fungsi getInt. Tapi kali ini kami benar-benar akan menggunakan argumen baris perintah dan fungsi baru yang disebut atoi. 

Ketika Anda menjalankan utama Program di C, maka Dibutuhkan dua parameters-- int argc, yang adalah jumlah argumen berlalu dalam, dan kemudian argv, array string yang berisi daftar semua argumen berlalu. Anda tidak secara eksplisit memiliki untuk mendeklarasikan variabel tersebut. Mereka dihitung untuk Anda oleh compiler. penggunaan yang benar untuk ini akan menjadi untuk argc menjadi dua dalam hal ini, karena pengguna harus lulus dalam panggilan untuk program, ./caesar, dan kemudian kunci, nomor apa pun yang mereka inginkan. Sehingga berarti bahwa argc harus dua agar penggunaan valid Caesar akan dieksekusi. 

Jadi mari kita lihat contoh. Mengatakan saya sudah menulis dan disusun sebuah program yang disebut blastoff. Jadi jika aku berlari pada command line ./blastoff Team Rocket, baik, kemudian, argc akan menjadi tiga karena saya disahkan pada tiga argumen yang berbeda. Kemudian argv akan terlihat seperti ini. Ini sebuah array, dan itu akan berisi masing-masing tiga senar. ./blastoff dalam indeks pertama, tim di depan, dan roket di terakhir. 

Mari kita bicara tentang array untuk sebentar. Array adalah struktur data yang terus beberapa nilai dari jenis yang sama. Ini dapat berguna ketika kita memiliki daftar integer atau string. Hanya ingat mereka memiliki menjadi jenis yang sama. Dalam ilmu komputer, kita suka menghitung dari nol, jadi ingatlah bahwa array juga nol-diindeks. Jadi elemen pertama dari array saya akan berada di indeks nol. Jadi dalam hal ini, ketika saya memiliki array panjang empat, maka indeks terakhir dari elemen terakhir dari array saya sebenarnya akan menjadi pada indeks tiga, bukan empat. Karena ingat, kita mulai menghitung dari nol. 

Berikut adalah contoh bagaimana Anda mungkin membuat sebuah array dari Anda sendiri. Jadi mengatakan saya ingin menyimpan saya tiga nama anjing favorit. Maka saya akan membuat sebuah array dari string. Jadi saya akan menyatakan jenis, string, dan kemudian menempatkan nama dari array, anjing, dan kemudian di alun-alun tersebut kurung menempatkan ukuran dari array-- dalam kasus ini, tiga. 

Jadi entri pertama saya akan menjadi anjing di indeks nol, dan itu akan menjadi Milo. Kemudian anjing pada indeks satu akan menjadi konyol, Sayang Mochi, dan kemudian yang terakhir entri, entri ketiga pada indeks dua, akan menjadi lucu, manis Elphie. Anda akan melihat bahwa format untuk mengisi array ini sangat banyak seperti bagaimana Anda mungkin mendeklarasikan variabel lain di mana Anda memiliki nama variabel diikuti dengan nilai yang Anda ingin disimpan di dalamnya. Satu-satunya perbedaan di hal ini adalah bahwa Anda harus ingat untuk menempatkan indeks dari nilai dalam kurung persegi. Dan di sana kita harus kami tiga anjing favorit. 

Tapi sayangnya, sudah waktunya untuk kembali ke Caesar. Ingat bahwa penggunaan yang benar untuk pengguna akan melintas di tidak hanya nama program ./caesar, tapi juga kunci yang mereka ingin menggeser plaintext mereka dengan. Sehingga berarti bahwa argc harus dua. Mereka harus lulus dalam two-- tidak lebih, tidak kurang dari dua argumen baris perintah. 

Sekarang, bagaimana dengan argv? Nah, kita sudah tahu bahwa array akan menjadi panjang dua, tapi apa yang terkandung dalam setiap elemen? Nah, elemen pertama akan menjadi ./caesar, dan kemudian elemen berikutnya akan berisi kunci bahwa pengguna mengetik. Sekarang, jika mereka digunakan dengan benar untuk penggunaan Caesar, maka mereka akan mengetikkan nomor. Tapi meskipun karakter yang mereka ketik adalah angka, itu tipe data string. 

Jadi bagaimana kita mengkonversi String ke integer? Jadi mengatakan bahwa saya memiliki num, string, mengandung string 50. Jika saya ingin mengkonversi ke integer, maka saya hanya mendeklarasikan variabel baru, bilangan bulat i, memanggil atoi. Aku lulus dalam variabel string saya, num, dan maka saya kemudian akan berisi nomor 50. Pastikan untuk memeriksa orang halaman untuk fungsi atoi untuk memeriksa perpustakaan itu di, serta nilai apa akan kembali jika string berlalu di tidak mengandung semua nomor. 

Jadi sekarang kita sudah kunci, langkah berikutnya adalah untuk mendapatkan plaintext dari pengguna. Sekarang, ini akan kurang rumit dari navigasi di sekitar argumen baris perintah. Yang harus kita lakukan adalah panggilan fungsi GetString untuk meminta pengguna untuk memberikan kami string, tapi ingat untuk memeriksa spesifikasi untuk bagaimana kita mungkin ingin meminta pengguna untuk itu. 

Sekarang kita sampai pada jantung problem-- yang bagaimana menulis dlm kode plaintext. Yah, pertama, mari kita bicara tentang bagaimana untuk menulis dlm kode satu karakter pada satu waktu, dan kemudian kita akan membahas bagaimana iterate atas seluruh plaintext. Saya telah menulis beberapa pseudocode untuk masalah Caesar. Saya mendorong Anda untuk menulis sendiri juga. Ini mungkin tidak terlihat sama tambang, dan itu OK, tapi selama sebagai ide umum adalah sama. 

Tiga langkah pertama kami sudah melakukan. Kami telah mendapat kunci dari argumen baris perintah, kami telah berpaling kunci yang ke integer, dan kami sudah mendorong pengguna untuk plaintext bahwa mereka ingin menulis dlm kode. Jadi potongan besar berikutnya adalah bahwa untuk setiap karakter dalam string plaintext, jika itu abjad, kami ingin melestarikan kasus dan bergeser. Dengan melestarikan kasus, apa yang saya maksud adalah bahwa semua huruf surat harus tetap atas kasus dan semua huruf kecil harus tetap huruf kecil. Jadi setelah kita menggeser mereka, kemudian kami cetak ciphertext. 

Berikut adalah tiga fungsi yang akan untuk berguna untuk masalah ini. Ingat di atas ketika saya memberi Misalnya untuk memindahkan ini CS50? Ingat bahwa 50 dan tanda seru tidak bergeser? Jadi bagaimana kita bisa tahu apakah kita perlu menggeser surat atau tidak? Nah, "adalah alpha," jika Anda lulus karakter, akan mengembalikan true jika karakter yang adalah surat dan palsu sebaliknya. Untuk membantu Anda dengan melestarikan kapitalisasi adalah fungsi "yang atas "dan" lebih rendah. " 

Kedua fungsi juga mengambil di satu karakter sebagai masukan dan kembali Anda Boolean, benar atau salah tergantung pada apakah karakter yang adalah huruf atau huruf kecil. Karena "adalah atas" dan "adalah lebih rendah "adalah fungsi Boolean, yang berarti bahwa mereka kembali Anda Boolean, Anda dapat menggunakan ini dalam kondisi Anda. Jadi di sini adalah potongan kode yang hanya mencetak surat jika huruf. Jadi saya sudah menyatakan karakter saya surat untuk kasus atas zed dan kemudian jika "adalah atas" kembali benar, maka saya mencetak surat itu. 

Kembali ke contoh sederhana kami pergeseran alfabet dengan kunci dari dua, bagaimana kita benar-benar mendapatkan yang bekerja? Nah, ternyata karakter dan bilangan bulat sangat erat. Masing-masing karakter memiliki nilai integer terkait dengan itu ditemukan dalam grafik ASCII, mana ASCII masing-masing karakter nilai ditampilkan. Jadi kasus atas A berkorespondensi ke nilai ASCII dari 65 dan huruf kecil untuk nilai ASCII dari 97. 

Jangan ragu untuk mencari setiap ASCII grafik secara online untuk melihat nilai-nilai ini untuk diri sendiri. Jadi apa artinya ini adalah bahwa kita bisa mengambil karakter huruf A, menambahkan integer dua untuk itu, dan kemudian mendapatkan karakter atas kasus C sebagai hasilnya. Itu karena 65, ASCII Nilai untuk modal A, ditambah 2, memberi kita 67, yang sesuai dengan karakter huruf C. 

Sayangnya, hal tidak akan cukup begitu sederhana. Kami memiliki persamaan yang kita harus mempertimbangkan. Di sini memberitahu kita bahwa ciphertext i surat sesuai dengan plaintext engan surat, ditambah KEY- yang semua itu, modular 26. Mengapa itu terjadi? Mari kita kembali ke contoh kita dari sebelumnya, di mana modal A, ditambah 2, memberi kita modal C. 

Jadi menerapkan persamaan yang spesifikasi memberi kita, maka mari kita mengambil modal A ditambah 2 dan mod bahwa dengan 26. Jadi modal A, ketika saya memasukkannya ke dalam mereka tanda kutip tunggal, memungkinkan saya untuk memperlakukannya sebagai integer, sehingga memungkinkan saya untuk dilemparkan ke nilai ASCII, 65. 65 ditambah 2 adalah 67. 67 mod 26 memberi kita 15, tapi itu tidak benar-benar masuk akal karena kita tahu bahwa modal C nilai ASCII adalah 67, bukan 15. Jadi bagaimana kita mendamaikan itu? 

Nah, di sini saya ingin mengandaikan Gagasan indeks abjad. Jadi kita sudah bicara tentang bagaimana masing-masing karakter memiliki nilai ASCII, tapi saya ingin mengatakan, baik, mari kita berpikir tentang masing-masing karakter juga memiliki indeks abjad, di mana A misalnya, sebagai huruf pertama dari alfabet, memiliki indeks abjad dari nol. Jadi sekarang mari kita menerapkan persamaan yang sama seperti sebelumnya, tetapi menggunakan indeks abjad. 

Jadi A adalah nol, seperti yang kita telah ditentukan. Jadi kemudian mengambil nol ditambah dua, mod 26, itu dua, mod 26, yang memberi kami dua. Dan juga, dalam hal indeks abjad, C adalah huruf ketiga dalam alfabet, sehingga akan sesuai untuk indeks abjad dari dua. Jadi sepertinya bahwa menggunakan indeks alfabet dalam kasus ini benar-benar memberikan kita hasil yang benar. 

Jadi sekarang mari kita periksa untuk melihat apakah karya persamaan dengan indeks abjad. Indeks abjad Y adalah 24 sebagai kedua huruf terakhir dalam alfabet. Jadi 24 ditambah kami kunci dari dua memberi kita 26. 26 mod 26 memberi kita 0, yang, beruntung bagi kami, adalah indeks abjad untuk A. Jadi mudah-mudahan itu cukup bahwa bukti metode indeks alfabet bekerja. Jika tidak, jangan ragu untuk mencoba beberapa contoh Anda sendiri. 

Dalam rangka untuk benar membungkus alfabet dan menerapkan persamaan Caesar, maka kita tahu bahwa kita perlu berurusan dengan indeks abjad. Tapi kita mulai dengan ASCII nilai-nilai, dan hanya kemudian kita kemudian dikonversi ke indeks alfabet. Dari sana, dalam rangka untuk mencetak, kita perlu berurusan dengan nilai-nilai ASCII lagi. Jadi kita perlu mencari cara untuk pergi dari ASCII ke abjad dan dari abjad ke ASCII. 

Jadi saya menyerahkan kepada Anda untuk mencari tahu pola antara karakter dan abjad yang indeks dan nilai ASCII. Sekarang, ingat bahwa meskipun tabel ini tepat pada slide menunjukkan huruf besar, kami juga harus mempertimbangkan apakah atau tidak pola yang berbeda berlaku untuk karakter huruf kecil. 

Jadi sekarang kita sudah tahu bagaimana menggeser satu karakter, maka yang harus kita lakukan adalah skala yang untuk pergi di seluruh plaintext. Jadi plaintext adalah string. Beruntung bagi kami, string adalah benar-benar hanya sebuah array karakter, sehingga untuk mengakses setiap karakter string, yang harus Anda lakukan adalah dengan menggunakan notasi array. Katakanlah saya memiliki variabel jenis string disebut "text = 'ini CS50.'" 

Nah, kemudian, untuk mengakses masing-masing karakter, semua saya harus lakukan dengan teks variabel mengatakan baik, teks pada indeks nol, yang sesuai dengan T. modal Teks pada indeks salah satu sesuai dengan kasus h rendah. Fungsi lain yang berguna adalah fungsi panjang string. Jadi lewat di string ke fungsi yang akan kembali integer, panjang string itu. 

Sekarang kita sudah berbicara tentang semua elemen yang berbeda, mari kita menempatkan mereka kembali bersama-sama. Jadi kembali ke salah satu pseudocode saya kode atau pseudocode Anda dan pergi melalui dan pastikan bahwa Anda tahu bagaimana melakukan setiap hal. Mendapatkan kunci menggunakan argc dan argv, memutar kunci ke integer, sebuah untuk i, disuruh untuk plaintext, GetString, dan kemudian iterasi lebih dari setiap karakter di string plaintext, melestarikan kasus masing-masing karakter dan pergeseran karakter yang oleh kunci, memastikan bahwa Anda membungkus di sekitar alfabet, akhirnya mencetak ciphertext itu. Nama saya Amila, dan ini adalah Caesar. 