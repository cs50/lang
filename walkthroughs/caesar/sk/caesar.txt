Amila: Poďme riešiť Caesara. V Caesar, necháme užívateľovi zakódovať tajnú správu. Takže poďme sa rovno dovnútra a hľadať u našich TO-DOS tohto problému. Takže prvý, dostaneme kľúč od užívateľa. Potom dostaneme holý text že chcú kódovať. Za to, že sme to zašifrovať pre nich, a nakoniec sme tlačiť ich ciphertext. 

Takže začnime s príkladom. Povedzme, že ste chceli zakódovať Celá abeceda s kľúčom dva. Tak by celá vaša abeceda len sa presunul na listy. Tak by sa kódovať C, B D, C až E, a tak ďalej a tak ďalej, až sa dostanete k X, ktorá kóduje od A do Z alebo múr, v závislosti na tom, kde ste od. Potom Y by potom posunúť celú cestu, zábal okolo abecedy sa dostať do A, a potom konečne posledné písmeno abeceda, Z, múr, bude kódovať do bodu B. 

Je to jasné? Pozrime sa na niektoré príklady. Prvým príkladom je veľmi podobná s tým, čo sme práve vysvetlené vyššie. Takže keď som zakódovať nejaký úsek abeceda, A až L, kľúčom dvoch, Potom som len dostať svoju celokrajné abeceda posunul dva listy. 

Potom, v mojom ďalšom príklade, kľúč je stále dva, takže by ste mali ešte vedieť ktorý listy očakávať. Ale tu je to fráza. To je CS50. Takže si všimnete, že ja zachovať prípad mojich listov, takže akékoľvek veľké písmená sú tiež veľké písmená v ciphertext. A akákoľvek malé písmená listov v holom texte sú tiež malé písmená Písmená v ciphertext. Ale stále písmená a prípadné výkričníky alebo akékoľvek iné interpunkcie rovnaké. 

Takže teraz, že máme pocit za to, ako program funguje, neváhajte ísť bežať niečo viac príklady svoje vlastné, ak si budete priať. Začnime s dostať kľúč od užívateľa. Tradične, s ďalšie problémy, máme boli zvyknutí na získanie akékoľvek čísla, ktorá my Potrebujete tým vyzvanie užívateľa s funkciou getint. Ale tentoraz sme vlastne deje používať príkazový riadok argumentu a nová funkcia nazvaná atoi. 

Pri spustení hlavného Program v C, potom sa sa v dvoch parameters-- int argc, ktorý je počet argumentov prešiel v roku, a potom argv, pole reťazcov, ktoré obsahujú zoznam všetkých argumentov prešiel. Nemusíte mať explicitne deklarovať tieto premenné. Sú vypočítané pre ste kompilátorom. Správne využitie pre to by bolo Pre argc byť dve v tomto prípade, pretože užívateľ musí odovzdať hovor s programom, ./caesar, a kľúč, bez ohľadu na počet chcú. Tak, že znamená, že musí byť dva argc K tomu, aby platnú použitie Caesar ktoré majú byť vykonané. 

Takže poďme sa pozrieť na príklad. Povedzme, že som už napísal a zostavili program s názvom odpálenie. Takže keď som bežal do príkazového riadku ./blastoff Team Rocket, dobre, potom, argc by mali byť tri, pretože som prešiel v troch rôznych argumentov. Potom argv bude vyzerať takto. Je to pole, a to by obsahuje každú z troch reťazcov. ./blastoff v prvom indexe, tímu v budúcom, a rakety v poslednej. 

Hovorme o poliach na chvíľku. Polia sú dátové štruktúry, ktoré držia viac hodnôt rovnakého typu. To sa môže hodiť, keď sme k dispozícii zoznam čísel alebo reťazcov. Len nezabudnite, že majú byť rovnakého typu. Vo vede o počítačoch, my love počítanie od nuly, takže si uvedomiť, že pole sú takisto nulové indexovaný. Takže prvý prvok mojej poľa bude na indexe nula. Takže v tomto prípade, keď mám poľa dĺžky štyri, potom posledný index Posledným prvkom môjho poľa je v skutočnosti bude indexom tri, nie štyri. Vzhľadom k tomu, pamätajte, my začať počítať od nuly. 

Tu je príklad toho, ako ste by mohlo vytvoriť pole vlastné. Takže povedať, chcel som Store Môj tri najobľúbenejšie mená psa. Potom by som vytvoriť pole reťazcov. Takže by som vyhlásiť typ, reťazec, a potom dal názov poľa, psy, a potom v tých námestí držiaky dal veľkosti z array-- v tomto prípade tri. 

Takže môj prvý vstup sa deje byť psy na indexe nula, a že to bude Milo. Potom psy na indexe jednom bude praštěná, miláčik Mocha, a potom posledný entry, tretí vstup na indexe dva, bude roztomilý, sladký Elphie. Všimnite si, že formát pre vyplnenie tohto poľa Je veľmi podobné, ako by ste mohli deklarovať akoukoľvek inou premennou kde Máte názov premennej nasledované hodnota, ktorú chcete uložené v ňom. Jediný rozdiel v Tento prípad je, že vás mať na pamäti, dať indexu hodnoty v hranatých zátvorkách. A tam Máme Tri obľúbené psy. 

Ale beda, je čas vrátiť sa k cisárovi. Nezabudnite, že správne použitie pre The Užívateľ sa bude odovzdaním nielen názov programu ./caesar, ale tiež kľúčom, že chcú posunúť Ich plaintext tým. Tak, že znamená, že argc musí byť dva. Musia vyhovieť v two-- nie viac, nie menej ako dva argumenty príkazového riadka. 

A teraz, čo argv? No, my už vieme, že pole bude mať dĺžku dvoch, ale to, čo je obsiahnuté v každom prvku? No, prvý element bude ./caesar, a potom ďalší prvok bude obsahujú kľúč, ktorý užívateľ zadať. Teraz, keď to správne používané Pre využitie Caesar, potom idú na zadanie čísla. Ale aj keď charakter že typ je číslo, to je dátového typu string. 

Ako teda previesť, že reťazec na celé číslo? Takže povedať, že mám num, reťazec, obsahujúce reťazec 50. Ak chcem previesť, že na celé číslo, potom som jednoducho deklarovať novú premennú, čo celé číslo i, volá atoi. Aj prejsť vo svojom reťazcové premenné, num, a Potom som potom bude obsahovať číslo 50. Uistite sa muža Stránky pre funkciu atoi skontrolovať, ktoré knižnica je to v, rovnako ako to, čo sa cení ak vráti odovzdaný reťazec v neobsahuje všetky čísla. 

Takže teraz, že sme dostali kľúčom, ďalším krokom je dostať holý od užívateľa. Teraz to bude menej komplikované než navigovanie okolo príkazového riadka argumenty. Všetko, čo musíme urobiť, je výzva funkcia getString vyzvať používateľa, čím sa získa us reťazec, ale pamätajte, skontrolovať špecifikácie, ako chcieť vyzvať užívateľa za to. 

Teraz sa dostávame k srdcom problem-- Ako zašifrovať holý text. Tak za prvé, poďme hovoriť o tom, ako zašifrovať jeden znak v čase, a potom sa budeme zaoberať otázkou, ako sa iteráciu cez celý holý. Napísal som nejaké pseudocode za problém Caesar. Povzbudzujem vás, aby ste napísať svoj vlastný rovnako. To nemusí vyzerať totožný s baňa, a to je v poriadku, ale kým ako všeobecný princíp je rovnaký. 

Prvé tri kroky sme už urobili. Sme dostali kľúče od Argument príkazového riadku, sme sa obrátil ten kľúč na celé číslo, a my sme vyzvanie užívateľa na zadanie holého textu že chcú zašifrovať. Takže potom ďalší veľký kus je to, že pre každý znak V holého textu reťazci, ak je to abecedný, Ak chceme zachovať svojho prípadu a posunúť ju. Tým zachovať prípad, čo som znamenať, že všetky veľkými písmenami listy by mali zostať Horný púzdro a malé písmená by mali zostať malé písmená. Takže potom, čo sme sa posunúť tie, potom vytlačiť ciphertext. 

Tu sú tri funkcie, ktoré idú prísť vhod tohto problému. Nezabudnite, hore, keď som dal Príkladom pre to je posun CS50? Uvedomte si, že 50 a výkričník nezmenil? Ako teda môžeme povedať, či sme treba posunúť list, alebo nie? No, "je alfa," pokiaľ ste to znak prejsť, vráti true, ak je tento znak je písmeno a falošné inak. Ktoré vám pomôžu s zachovanie kapitalizácie sú funkcie "je horný "a" nižšia ". 

Tieto dve funkcie tiež vziať v jeden znak ako vstup a vráti vám logickú, true alebo false V závislosti na tom, či tento znak Je veľké písmená alebo malé písmená. Vzhľadom k tomu, "je horná" a "je nižšia "sú logické funkcie, To znamená, že sa vráti vám logickú, môžete použiť tieto vo svojich podmienkach. Takže tu je úryvok kódu, ktorý iba vytlačí list, či je to veľké písmená. Tak som deklaroval svoju postavu List má byť verzálky múr a potom, ak "je horná" sa vracia pravda, potom som vytlačiť ten list. 

Vráťme sa späť k nášmu jednoduchý príklad posunutie abecedy kľúčom dvoch, Ako sme vlastne dostať, že do práce? No, ukázalo sa, že znaky a celé čísla sú veľmi úzko súvisí. Každá postava má celočíselná hodnota spojená s tým nájdený v ASCII tabuľke, kde ASCII každá postava má Zobrazí sa hodnota. Takže an zodpovedá veľké písmená A na hodnotu ASCII 65 a malé písmená a až Hodnota ASCII 97. 

Nebojte sa pozrieť hore akýkoľvek ASCII tabuľka on-line vidieť tieto hodnoty pre seba. Takže to, čo to znamená, že môžeme mať charakter veľké písmená A, pridať číslo dva na neho, a potom sa znak veľké písmená C ako výsledok. To preto, že 65 rokov, ASCII hodnota kapitálové A plus 2, nám dáva 67, čo zodpovedá charakteru veľké písmená C. 

Bohužiaľ, veci nebude úplne tak jednoduché. Máme rovnicu, ktorá musíme vziať do úvahy. Tu nám hovorí, že i-tej ciphertext písmeno zodpovedá i-tej holého textu list, plus key-- všetko, modulárne 26. Prečo je to tak? Vráťme sa k nášmu príkladu z predtým, kde kapitál A, a naviac 2, nám dáva kapitálovú C. 

Takže použitie rovnice, ktorá špecifikácia nám dáva, Potom sa poďme kapitálu a 2 a mod, že 26 rokov. Takže kapitál A, keď som ju v tieto jednoduché úvodzovky, mi umožňuje zaobchádzať ako celé číslo, tak, že umožňuje me hodiť ho jeho ASCII hodnota 65. 65 a 2 je 67. 67 mod 26 nám dáva 15, ale to nie je naozaj zmysel, pretože vieme, že kapitál C ASCII hodnota je 67, nie 15. Tak ako sme sa zmieriť, že? 

No, tu by som chcel predpokladať Pojem abecednom indexu. Tak už sme hovorili o tom, ako každá postava má svoj ASCII hodnotu, ale ja by som rád povedal, dobre, poďme premýšľať o tom, každá postava má takisto abecedný register, kde A napríklad, ako prvé písmeno v abecede, má abecedný zoznam nula. Takže teraz poďme uplatňovať rovnaké rovnice ako predtým, ale za použitia abecedný register. 

Tak je nulová, ako sme definované. Takže potom brať nula plus dva, MOD 26, To sú dva, mod 26, čo nám dáva dve. A dobre, v rámci abecedný register, C je tretie písmeno v abeceda, aby zodpovedalo do abecedného indexu dva. Zdá sa teda, že využitie abecedný register v tomto prípade v skutočnosti nám dáva správny výsledok. 

Takže teraz poďme skontrolovať, či rovnicou prác abecedný register. abecedný register Y je 24, pretože Druhý na posledné písmeno v abecede. Takže 24 a naše Kľúčovým dvoch nám dáva 26. 26 mod 26 nám dáva 0, čo, našťastie pre us, je abecedný zoznam pre A. Takže dúfajme, že to stačí, že dôkaz abecedný register metóda funguje. Ak tomu tak nie je, neváhajte vyskúšať niektoré príklady sami. 

Aby bolo možné správne zabaliť okolo abecedy a aplikovať Caesar rovnice, potom vieme, že musíme vysporiadať s abecedný indexy. Ale začneme s ASCII hodnôt a až potom my potom previesť do abecedný register. Odtiaľ, aby bolo možné tlačiť, musíme vysporiadať s hodnotami ASCII znova. Takže musíme vymyslieť, ako prejsť z ASCII do abecedný az abecednom na ASCII. 

Tak Nechám na vás, aby ste zistili vzor medzi charakterom a jeho abecedný index a jeho hodnota ASCII. Teraz si uvedomiť, že hoci toto právo tabuľka na snímke zobrazuje veľké písmená, sme tiež musieť zvážiť, či je alebo nie je iný vzor platí Pre malými písmenami. 

Takže teraz, keď sme zistili Ako posunúť jeden znak, potom všetko, čo musíme urobiť, je meradlo, ktoré up ísť v celej obyčajného textu. Takže holý text je reťazec. Našťastie pre nás, reťazec je naozaj Len rada postáv, tak, aby sa prístup každý znak z reťazca, všetko, čo musíte urobiť, je použitie poľa notáciu. Povedzme, že mám premennú typu string nazvaný "text = 'Toto je CS50." 

Tak, aby sa pristupovať každý znak, všetko, čo mám robiť s premenná text hovoriť dobre, textu na indexe nula, že zodpovedá kapitál T. Text na indexe jeden zodpovedá malými písmenami h. Ďalšou užitočnou funkciou je Funkcia dĺžka reťazca. Takže prejde v reťazci že funkcia vráti celé číslo, je dĺžka tohto reťazca. 

Teraz, keď sme hovorili o Všetky tieto rôzne prvky, poďme dať je zase dohromady. Takže návrat k jednej mojej pseudokódu kód alebo Váš pseudocode a prejsť a uistiť sa, že vás vedieť, ako sa to robí každý jednotlivý vec. Získanie kľúč pomocou argc a argv, otočením kľúča do celé číslo, je až i výzvou pre holého textu, getString, a potom iterácie cez každý znak v holý text reťazec, zachovanie prípad každého znaku a presúva tento znak kľúčom, zabezpečenie toho, že ste obal okolo abecedy, Nakoniec tlačou danej ciphertext. Volám sa Amila, a to bol Caesar. 