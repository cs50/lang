AMILA :하자 시저를 해결하자. 시저에서, 우리는 사용자로 하여금 비밀 메시지를 인코딩합니다. 그럼 바로 뛰어들 수 있도록 해 봐 이 문제에 대한 우리의에-DOS에서. 그래서 첫째, 우리는 사용자로부터 키를 얻을. 그 다음 우리는 일반 텍스트를 얻을 수 그들은 인코딩 할 것인지. 그 후, 우리는 그들을 위해 그것을 암호화하기, 그리고 마지막으로 우리는 자신의 암호문을 인쇄 할 수 있습니다. 

그럼 예를 들어 시작하자. 당신이를 인코딩하고 싶어 말 둘의 키 전체 알파벳입니다. 음, 전체 알파벳 것 그냥 문자로 전환 될 수있다. 그래서 A는 C, B로에 인코딩 것 D, C E에, 등등 등등, 당신은 Z로 인코딩 X,에 도달 할 때까지 또는에서있어 위치에 따라, 데이빗. 그러면 Y는 모든 방법을 전환 할 A를 얻을 수있는 알파벳의 주위에 포장, 의 다음 마지막으로 마지막 문자 알파벳, Z, 데이빗, B로 인코딩 것 

당신은있어? 의 몇 가지 예를 살펴 보자. 여기에 첫 번째 예는 매우 유사하다 우리가 위에서 설명한 것과. 내가 어떤 부분을 인코딩한다면 알파벳하는 L을 통해 두 아이의 키를 기준으로, 나는 그냥 내 전체를 얻을 수 알파벳 두 글자를 이동했다. 

그런 다음, 나의 다음 예에서, 키는 여전히 2 개인 그래서 당신은 여전히​​ 알아야한다 어떤 글자 기대합니다. 그러나 여기이 문구입니다. 이 CS50입니다. 그래서 당신은 I를 알 수 있습니다 내 편지의 경우를 보존, 그래서 어떤 대문자도 있습니다 암호문에 대문자. 그리고 모든 소문자 평문 문자 또한 소문자 암호문의 문자. 하지만 문자를 유지 어떤 느낌표 또는 다른 문장 부호 같은. 

그래서 지금 우리가 감각을 가지고 프로그램이 어떻게 작동하는지에 대한, 좀 더 실행 갈 주시기 바랍니다 자신의 예를 들면, 당신이 원하는 경우. 의 점점 시작하자 사용자로부터 키. 전통적으로 다른 문제, 우리는했습니다 점점 익숙해되어 임의의 숫자를 우리가 사용자에게 메시지를 표시하여 필요 함수의 getInt와. 하지만 이번에는 우리가 실제로거야 명령 줄 인수를 사용하는 새로운 기능은 atoi 함수를 호출. 

당신이 주를 실행할 때 C에서 프로그램, 다음 이 parameters--에 소요 INT의는 argc, 어떤 인수의 수는 전달하고 포함 argv를, 문자열 배열 인수의 모든 목록 통과했다. 명시 적없는 이러한 변수를 선언합니다. 그들은 대해 계산하고 컴파일러에 의해 당신. 이것에 대한 올바른 사용이 될 것이다 는 argc이 경우에 두를 수하기 위해, 사용자에 통과하기 때문에 프로그램에 대한 호출, ./caesar, 다음 키, 어떤 수 그들은 바랍니다. 그래서는 argc가 있어야한다는 것을 의미 두 시저의 올바른 사용을위한 순서 실행한다. 

그럼 예를 살펴 보자. 이미 쓴 말과 Blastoff (발사)라는 프로그램을 컴파일. 그래서 만약 내가 명령 줄에서 실행 ./blastoff 팀 로켓, 음, 다음, 는 argc 세 것 I 때문에 세 가지 인수를 전달. 다음 변수는 argv는 다음과 같이한다. 이 배열이고, 그것은 것 세 개의 문자열을 각각 포함되어 있습니다. 첫 번째 인덱스, 팀 ./blastoff 마지막에서 다음과 로켓입니다. 

의는 초 배열에 대해 얘기하자. 배열은 보유 데이터 구조입니다 동일한 유형의 여러 값. 때이 편리하게 할 수 있습니다 정수 또는 문자열의 목록을 가지고있다. 그냥 그들이 가지고있는 기억 동일한 유형이어야합니다. 컴퓨터 과학에서, 우리 0부터 계산 사랑, 그래서 배열 것을 기억 또한 제로 인덱스입니다. 내 어레이의 첫 번째 요소 그래서 인덱스 제로가 될 것입니다. 이 경우, 나는 경우가 길이 네 배열 의 다음 마지막 인덱스 내 배열의 마지막 요소 실제로이 될 것입니다 인덱스 셋이 아닌 넷에서. 우리를 기억하기 때문에 제로 카운트 시작합니다. 

여기에 방법의 예 자신의 배열을 만들 수 있습니다. 그래서 저장하고 싶어 말을 내 세 좋아하는 강아지 이름. 그럼 난 문자열 배열을 만들 것입니다. 그래서 나는 유형, 문자열을 선언하고 것 그 배열의 이름을 넣어, 개 다음 그 광장 브래킷 크기 넣어 이 경우, 세 가지의 array--의. 

그래서 내 첫 번째 항목 것입니다 인덱스 제로 개하기 위해, 그것은 마일로 될 것입니다. 그런 다음 인덱스 하나에 개 바보가 될 것입니다, 다음 사랑 떡, 마지막 항목 인덱스 두에서 세 번째 항목, 귀여운, 달콤한 Elphie 될 것입니다. 당신은 형식 것을 알 수 있습니다 이 배열에 작성을위한 어떻게 수도처럼 아주 많이 다른 변수 어디 선언 당신은 다음에 변수 이름이 당신이 그것을에 저장하려는 값. 의 유일한 차이점 이 경우는 것입니다 인덱스를 넣어 기억해야 대괄호 값. 그리고 거기에서 우리는 우리가 세 좋아하는 개. 

그러나 슬프게도, 그것은 시간이다 다시 황제로 얻을 수 있습니다. 에 대한 그 올바른 사용법을 기억 사용자뿐만 아니라 전달 될 것입니다 프로그램 ./caesar 이름이지만 그들이 이동하려는 또한 키 에 의해 자신의 일반 텍스트. 그래서는 argc 두 가지를해야한다는 것을 의미한다. 그들은 아니, 2가 있으며 더 이상에 통과해야합니다 두 개의 명령 줄 인수보다. 

자, 변수는 argv는 어떻습니까? 글쎄, 우리는 이미 알고 배열은 길이이 될 것입니다 하지만 각 요소에 포함 된거야? 음, 첫 번째 요소 ./caesar 될 것입니다, 다음 다음 요소로 이동한다 사용자가에 입력 한 키가 포함되어 있습니다. 이제 한 경우에는 올바르게 사용 시저의 사용에 대한, 그들은 숫자를 입력하는 것입니다. 그러나 심지어 문자 불구하고 그들이 입력했는지 것은 숫자입니다 이 데이터 유형 문자열입니다. 

그래서 우리는 것을 어떻게 변환합니까 정수로 문자열? 그래서 납입이 있다고, 문자열, 문자열 (50)를 포함. 그 변환하려면 정수로, 나는 단순히 새로운 변수를 선언 atoi 함수를 호출, 내가 정수. 나는 납입, 내 문자열 변수를 전달하고, 그럼 내가 다음 수 (50)를 포함 할 것이다. 확인 사람을 확인하시기 바랍니다 atoi 함수 기능을위한 페이지 그것의 어떤 라이브러리 확인 에서뿐만 아니라 그것의 가치를 무엇으로 문자열이 전달 된 경우 반환됩니다 의 모든 숫자가 포함되어 있지 않습니다. 

그래서 지금 우리가 입수 한 것을 중요한 다음 단계 사용자로부터 평문을 얻을 수있다. 지금,이 것입니다 덜 복잡 주위에 탐색보다 명령 줄 인수. 우리가 할 일은 호출입니다 에는 getString 기능 제공하기 위해 사용자에게 메시지를 표시합니다 우리 문자열,하지만 기억 방법에 대한 사양을 확인 우리 그것에 대해 사용자에게 메시지를 표시 할 수 있습니다. 

이제 우리는 온 problem--의 마음 어떻게 일반 텍스트를 암호화하기합니다. 음, 처음의 방법에 대해 이야기하자 한번에 한 문자를 암호화하기 위해, 그리고, 우리는 방법을 해결합니다 전체 일반 텍스트를 반복. 나는 약간의 의사를 서면으로 작성했습니다 황제의 문제. 나는 보시기 바랍니다 뿐만 아니라 자신의 물품. 그것은 동일 보이지 않을 수도 광산, 그것은 OK,하지만 오래입니다 일반적인 생각과 동일합니다. 

처음 세 단계 우리는 이미 완료했습니다. 우리는에서 키를 쪘 명령 행 인수 우리는 그 키를 설정 한 정수로, 우리는했습니다 평문에 대해 사용자에게 프롬프트 그들은 암호화하기 것인지. 그래서 그 다음 큰 덩어리 즉, 각 캐릭터 인 일반 텍스트 문자열, 이 알파벳의 경우, 우리는 보존하려면 케이스와 그것을 이동. , 경우 보존함으로써 내가 말은 모두 대문자로 그 편지 상위를 유지해야 케이스와 소문자 소문자로 남아 있어야한다. 그럼 우리가 사람들을 이동 한 후, 우리는 암호문을 인쇄 할 수 있습니다. 

여기가는 세 가지 기능은 이 문제에 대한 편리합니다. 내가 준 경우 위까지 기억 이 이동에 대한 예는 CS50입니까? 기억 그 (50)와 느낌표는 이동하지 않았다? 그래서 우리는 우리 여부를 어떻게 알 수 편지를 이동 여부를해야합니까? 음,이 "알파입니다" 당신은 문자 통과, 해당 문자가있는 경우 true를 돌려줍니다 그렇지 않으면 편지 거짓이다. 당신을 돕기 위해 보존 대문자 기능은 "입니다 상단 "과"하단이다. " 

이 두 기능도 수행 입력으로 하나의 문자에 그리고, 당신은 부울을 반환 참 또는 거짓 해당 문자 여부에 따라 대문자 또는 소문자입니다. "위는"때문에 "입니다 낮은 "부울 기능은, 그들이 당신에게 부울을 반환한다는 것을 의미, 당신은 당신의 상황에서 이러한 사용할 수 있습니다. 그래서 여기에 코드 조각입니다 만 이 대문자 인 경우 편지를 인쇄합니다. 그래서 난 내 캐릭터를 선언했습니다 문자는 대문자 데이빗한다 다음 경우는 반환 "위입니다" 사실, 그때 그 편지를 인쇄 할 수 있습니다. 

우리의 간단한 예제로 돌아 간다 두 가지의 핵심으로 알파벳을 이동, 어떻게 우리가 실제로 그 일을 어떻게해야합니까? 음, 문자 밝혀 및 정수는 매우 밀접하게 관련되어있다. 각 문자는이 관련 정수 값 그것은 ASCII 차트에서 발견하여, 여기서 각 문자의 ASCII 값이 표시됩니다. 그래서 대문자 A가 대응 (65)의 ASCII 값 와 소문자 a를에 97의 ASCII 값입니다. 

찾아 주시기 바랍니다 온라인 어떤 ASCII 차트 자신을 위해이 값을 볼 수 있습니다. 그래서 이것이 의미하는 것은 우리가 할 수있는 것입니다 대문자 A의 특성을 그것에 정수 개의 추가하고 얻을 결과로서 문자 대문자 C. 즉, (65) 때문에, ASCII의 자본 A의 값, 플러스 2, 해당하는 우리에게 67을 제공합니다 대문자 C의 문자 

불행하게도, 일 아주 간단하지 않습니다. 우리는 방정식을 가질 수 우리는 고려해야한다. 다음은 i 번째 암호문 것을 우리에게 알려줍니다 문자 i 번째 평문에 대응 편지 플러스 key-- 이 모든 모듈 26. 이유 경우입니까? 이제부터 우리의 예를 다시 가자 전에 여기서 자본 A, 플러스 2, 우리에게 자본 C.을 제공합니다 

그래서 방정식이 적용 사양은, 우리를 제공합니다 다음의 자본 A를 보자 (2) 및 (26)에 의한 모드 플러스. 그래서 자본 A, 때 나는에 넣어 그 작은 따옴표, 내게로 처리 할 수​​ 있습니다 정수, 그래서 허용 내게는 ASCII 값 (65)에 캐스팅합니다. 65 플러스 2는 67입니다. 67 모드 (26)는, 우리에게 15을 제공합니다 하지만 그건 정말하지 않습니다 우리가 알고 있기 때문에 이해 자본 C의 ASCII 값은 67이 아니라 15입니다. 그렇다면 우리는 화해합니까? 

음, 여기 난을 단정하고 싶습니다 알파벳 인덱스의 개념. 그래서 우리는 이미 방법에 대해 얘기했습니다 각 캐릭터는 자신 ASCII 값을 갖는다 하지만 난 잘하자, 말을하고 싶습니다 각 문자는 것에 대한 생각 알파벳 인덱스, 어디 예를 들어, 알파벳의 첫 글자로, 제로의 알파벳 색인이 있습니다. 그래서 지금의은을 적용 할 수 같은 식 이전과, 하지만 알파벳 인덱스를 사용. 

우리가 정의한 그래서 A는 제로이다. 그럼 제로 플러스 두 모드 (26)를 복용, 즉,이 두가 우리에게주는 모드 26입니다. 의 잘,의 용어 알파벳 인덱스, C는 세 번째 문자입니다 알파벳, 그래서는 해당 것 두 가지의 알파벳 색인. 그래서을 사용하는 것 같다 이 경우 알파벳순 색인 실제로 우리에게 올바른 결과를 제공합니다. 

그래서 지금의 확인하자에 방정식 작동하는지 확인 알파벳 인덱스. Y의 알파벳 지수는 24이다 알파벳의 마지막 글자에 두 번째. 그럼 24 플러스 우리의 두 가지의 핵심은 우리에게 26을 제공합니다. 26 모드 (26)는 우리에게 0, 대한, 행운을 제공합니다 우리는, A.의 알파벳 인덱스 그래서 잘하면 그것으로 충분 그 증거 알파벳 색인 방법을 사용할 수 있습니다. 그렇지 않은 경우, 시도해 주시기 바랍니다 자신의 몇 가지 예입니다. 

적절하게 감싸는 위해서 알파벳과 시저 방정식을 적용, 우리는 우리가해야 할 것을 알고있다 알파벳 인덱스 처리합니다. 그러나 우리는 ASCII로 시작 단지 다음 값 및 우리는 그 다음에 변환합니까 알파벳 인덱스입니다. 거기에서 인쇄하기 위해, 우리는 필요 다시 ASCII 값을 처리합니다. 그래서 우리는 방법을 강구해야 알파벳순 ASCII에서 이동 및 알파벳에서 ASCII한다. 

그래서 알아 내기 위해 당신에게 맡겨 문자 사이의 패턴 그 알파벳 인덱스와 ASCII 값입니다. 지금, 비록 그 기억 슬라이드에이 테이블 오른쪽 우리는 또한 대문자를 보여줍니다 여부를 고려해야합니다 다른 패턴을 적용한다 소문자 문자. 

그래서 지금 우리가 알아 냈으니 단일 문자를 이동하는 방법, 우리가 할 일은 규모입니다 최대는 전체 일반 텍스트를 가로 질러 이동합니다. 그래서 일반 텍스트 문자열입니다. 우리에게 운이 문자열은 정말 문자 다만 배열, 그래서 모든 문자에 액세스하기 위해, 문자열의 모든 당신이해야 할 배열 표기법을 사용하는 것이다. 내가 유형의 변수가 있다고 가정 라는 문자열 "텍스트 = '이 CS50입니다." 

그럼, 순서에 각 문자를 액세스, 모든 내가 함께 할 수있다 변수 텍스트는 것을, 잘 말할 인덱스 제로에서 텍스트하기 인덱스 자본 T. 텍스트에 해당 하나는 하부 케이스 H에 상당한다. 또 다른 유용한 기능입니다 문자열 길이 기능. 그래서에 문자열 전달 이 함수는 반환합니다 정수, 그 문자열의 길이. 

우리가 이야기 한 지금 이러한 모든 다른 요소, 의 함께 그들을 다시 넣어 보자. 그러니 내 의사로 복귀 코드 또는 의사 및 통과하고 있는지 확인하십시오 당신이 매일 일을하는 방법을 알고있다. 는 argc와 argv를를 사용하여 키를 가져 오기, 정수로 키를 회전하는 난에 일반 텍스트에 대한 메시지를 표시, getString에, 다음 반복 모든 문자에 이상 일반 텍스트 문자열 각 문자의 경우 보존 그리고 키에 의해 그 문자를 이동, 당신이있어 보장 알파벳의 주위에 포장, 마지막으로 그 암호문을 인쇄. 내 이름은 Amila이며,이 카이사르였다. 