1
00:00:00,000 --> 00:00:00,760

2
00:00:00,760 --> 00:00:02,270
>> AMILA :하자 시저를 해결하자.

3
00:00:02,270 --> 00:00:06,110
시저에서, 우리는 사용자로 하여금
비밀 메시지를 인코딩합니다.

4
00:00:06,110 --> 00:00:09,780
그럼 바로 뛰어들 수 있도록 해 봐
이 문제에 대한 우리의에-DOS에서.

5
00:00:09,780 --> 00:00:12,210
그래서 첫째, 우리는 사용자로부터 키를 얻을.

6
00:00:12,210 --> 00:00:15,210
그 다음 우리는 일반 텍스트를 얻을 수
그들은 인코딩 할 것인지.

7
00:00:15,210 --> 00:00:21,380
그 후, 우리는 그들을 위해 그것을 암호화하기,
그리고 마지막으로 우리는 자신의 암호문을 인쇄 할 수 있습니다.

8
00:00:21,380 --> 00:00:23,600
>> 그럼 예를 들어 시작하자.

9
00:00:23,600 --> 00:00:26,920
당신이를 인코딩하고 싶어 말
둘의 키 전체 알파벳입니다.

10
00:00:26,920 --> 00:00:31,360
음, 전체 알파벳 것
그냥 문자로 전환 될 수있다.

11
00:00:31,360 --> 00:00:37,060
그래서 A는 C, B로에 인코딩 것
D, C E에, 등등 등등,

12
00:00:37,060 --> 00:00:42,470
당신은 Z로 인코딩 X,에 도달 할 때까지
또는에서있어 위치에 따라, 데이빗.

13
00:00:42,470 --> 00:00:47,445
그러면 Y는 모든 방법을 전환 할
A를 얻을 수있는 알파벳의 주위에 포장,

14
00:00:47,445 --> 00:00:53,256
의 다음 마지막으로 마지막 문자
알파벳, Z, 데이빗, B로 인코딩 것

15
00:00:53,256 --> 00:00:54,660
>> 당신은있어?

16
00:00:54,660 --> 00:00:56,380
의 몇 가지 예를 살펴 보자.

17
00:00:56,380 --> 00:01:00,540
여기에 첫 번째 예는 매우 유사하다
우리가 위에서 설명한 것과.

18
00:01:00,540 --> 00:01:05,560
내가 어떤 부분을 인코딩한다면
알파벳하는 L을 통해 두 아이의 키를 기준으로,

19
00:01:05,560 --> 00:01:09,760
나는 그냥 내 전체를 얻을 수
알파벳 두 글자를 이동했다.

20
00:01:09,760 --> 00:01:12,230
>> 그런 다음, 나의 다음 예에서,
키는 여전히 2 개인

21
00:01:12,230 --> 00:01:15,080
그래서 당신은 여전히​​ 알아야한다
어떤 글자 기대합니다.

22
00:01:15,080 --> 00:01:16,400
그러나 여기이 문구입니다.

23
00:01:16,400 --> 00:01:18,100
이 CS50입니다.

24
00:01:18,100 --> 00:01:21,090
그래서 당신은 I를 알 수 있습니다
내 편지의 경우를 보존,

25
00:01:21,090 --> 00:01:25,600
그래서 어떤 대문자도 있습니다
암호문에 대문자.

26
00:01:25,600 --> 00:01:27,800
그리고 모든 소문자
평문 문자

27
00:01:27,800 --> 00:01:30,640
또한 소문자
암호문의 문자.

28
00:01:30,640 --> 00:01:34,020
하지만 문자를 유지
어떤 느낌표

29
00:01:34,020 --> 00:01:37,610
또는 다른 문장 부호 같은.

30
00:01:37,610 --> 00:01:40,360
>> 그래서 지금 우리가 감각을 가지고
프로그램이 어떻게 작동하는지에 대한,

31
00:01:40,360 --> 00:01:43,890
좀 더 실행 갈 주시기 바랍니다
자신의 예를 들면, 당신이 원하는 경우.

32
00:01:43,890 --> 00:01:47,072
의 점점 시작하자
사용자로부터 키.

33
00:01:47,072 --> 00:01:48,780
전통적으로
다른 문제, 우리는했습니다

34
00:01:48,780 --> 00:01:51,450
점점 익숙해되어
임의의 숫자를 우리가

35
00:01:51,450 --> 00:01:54,710
사용자에게 메시지를 표시하여 필요
함수의 getInt와.

36
00:01:54,710 --> 00:01:58,850
하지만 이번에는 우리가 실제로거야
명령 줄 인수를 사용하는

37
00:01:58,850 --> 00:02:01,760
새로운 기능은 atoi 함수를 호출.

38
00:02:01,760 --> 00:02:05,130
>> 당신이 주를 실행할 때
C에서 프로그램, 다음

39
00:02:05,130 --> 00:02:08,500
이 parameters--에 소요
INT의는 argc, 어떤

40
00:02:08,500 --> 00:02:11,670
인수의 수는
전달하고

41
00:02:11,670 --> 00:02:15,920
포함 argv를, 문자열 배열
인수의 모든 목록

42
00:02:15,920 --> 00:02:16,740
통과했다.

43
00:02:16,740 --> 00:02:19,740
명시 적없는
이러한 변수를 선언합니다.

44
00:02:19,740 --> 00:02:22,700
그들은 대해 계산하고
컴파일러에 의해 당신.

45
00:02:22,700 --> 00:02:28,160
이것에 대한 올바른 사용이 될 것이다
는 argc이 경우에 두를 수하기 위해,

46
00:02:28,160 --> 00:02:32,630
사용자에 통과하기 때문에
프로그램에 대한 호출, ./caesar,

47
00:02:32,630 --> 00:02:35,570
다음 키,
어떤 수 그들은 바랍니다.

48
00:02:35,570 --> 00:02:39,920
그래서는 argc가 있어야한다는 것을 의미 두
시저의 올바른 사용을위한 순서

49
00:02:39,920 --> 00:02:41,680
실행한다.

50
00:02:41,680 --> 00:02:43,590
>> 그럼 예를 살펴 보자.

51
00:02:43,590 --> 00:02:47,760
이미 쓴 말과
Blastoff (발사)라는 프로그램을 컴파일.

52
00:02:47,760 --> 00:02:52,670
그래서 만약 내가 명령 줄에서 실행
./blastoff 팀 로켓, 음, 다음,

53
00:02:52,670 --> 00:02:57,750
는 argc 세 것 I 때문에
세 가지 인수를 전달.

54
00:02:57,750 --> 00:02:59,830
다음 변수는 argv는 다음과 같이한다.

55
00:02:59,830 --> 00:03:03,750
이 배열이고, 그것은 것
세 개의 문자열을 각각 포함되어 있습니다.

56
00:03:03,750 --> 00:03:09,640
첫 번째 인덱스, 팀 ./blastoff
마지막에서 다음과 로켓입니다.

57
00:03:09,640 --> 00:03:11,610
>> 의는 초 배열에 대해 얘기하자.

58
00:03:11,610 --> 00:03:15,560
배열은 보유 데이터 구조입니다
동일한 유형의 여러 값.

59
00:03:15,560 --> 00:03:19,980
때이 편리하게 할 수 있습니다
정수 또는 문자열의 목록을 가지고있다.

60
00:03:19,980 --> 00:03:23,030
그냥 그들이 가지고있는 기억
동일한 유형이어야합니다.

61
00:03:23,030 --> 00:03:25,310
컴퓨터 과학에서, 우리
0부터 계산 사랑,

62
00:03:25,310 --> 00:03:29,260
그래서 배열 것을 기억
또한 제로 인덱스입니다.

63
00:03:29,260 --> 00:03:34,360
내 어레이의 첫 번째 요소 그래서
인덱스 제로가 될 것입니다.

64
00:03:34,360 --> 00:03:37,580
이 경우, 나는 경우가
길이 네 배열

65
00:03:37,580 --> 00:03:41,350
의 다음 마지막 인덱스
내 배열의 마지막 요소

66
00:03:41,350 --> 00:03:44,970
실제로이 될 것입니다
인덱스 셋이 아닌 넷에서.

67
00:03:44,970 --> 00:03:48,880
우리를 기억하기 때문에
제로 카운트 시작합니다.

68
00:03:48,880 --> 00:03:52,530
>> 여기에 방법의 예
자신의 배열을 만들 수 있습니다.

69
00:03:52,530 --> 00:03:56,440
그래서 저장하고 싶어 말을 내
세 좋아하는 강아지 이름.

70
00:03:56,440 --> 00:03:59,030
그럼 난 문자열 배열을 만들 것입니다.

71
00:03:59,030 --> 00:04:04,450
그래서 나는 유형, 문자열을 선언하고 것
그 배열의 이름을 넣어, 개

72
00:04:04,450 --> 00:04:06,450
다음 그 광장
브래킷 크기 넣어

73
00:04:06,450 --> 00:04:09,260
이 경우, 세 가지의 array--의.

74
00:04:09,260 --> 00:04:12,690
>> 그래서 내 첫 번째 항목 것입니다
인덱스 제로 개하기 위해,

75
00:04:12,690 --> 00:04:14,750
그것은 마일로 될 것입니다.

76
00:04:14,750 --> 00:04:17,850
그런 다음 인덱스 하나에 개
바보가 될 것입니다,

77
00:04:17,850 --> 00:04:23,060
다음 사랑 떡, 마지막
항목 인덱스 두에서 세 번째 항목,

78
00:04:23,060 --> 00:04:26,130
귀여운, 달콤한 Elphie 될 것입니다.

79
00:04:26,130 --> 00:04:28,610
당신은 형식 것을 알 수 있습니다
이 배열에 작성을위한

80
00:04:28,610 --> 00:04:32,150
어떻게 수도처럼 아주 많이
다른 변수 어디 선언

81
00:04:32,150 --> 00:04:36,307
당신은 다음에 변수 이름이
당신이 그것을에 저장하려는 값.

82
00:04:36,307 --> 00:04:38,140
의 유일한 차이점
이 경우는 것입니다

83
00:04:38,140 --> 00:04:42,700
인덱스를 넣어 기억해야
대괄호 값.

84
00:04:42,700 --> 00:04:46,420
그리고 거기에서 우리는 우리가
세 좋아하는 개.

85
00:04:46,420 --> 00:04:48,780
>> 그러나 슬프게도, 그것은 시간이다
다시 황제로 얻을 수 있습니다.

86
00:04:48,780 --> 00:04:52,910
에 대한 그 올바른 사용법을 기억
사용자뿐만 아니라 전달 될 것입니다

87
00:04:52,910 --> 00:04:57,430
프로그램 ./caesar 이름이지만
그들이 이동하려는 또한 키

88
00:04:57,430 --> 00:04:58,850
에 의해 자신의 일반 텍스트.

89
00:04:58,850 --> 00:05:01,540
그래서는 argc 두 가지를해야한다는 것을 의미한다.

90
00:05:01,540 --> 00:05:07,580
그들은 아니, 2가 있으며 더 이상에 통과해야합니다
두 개의 명령 줄 인수보다.

91
00:05:07,580 --> 00:05:09,050
>> 자, 변수는 argv는 어떻습니까?

92
00:05:09,050 --> 00:05:12,880
글쎄, 우리는 이미 알고
배열은 길이이 될 것입니다

93
00:05:12,880 --> 00:05:15,270
하지만 각 요소에 포함 된거야?

94
00:05:15,270 --> 00:05:19,330
음, 첫 번째 요소
./caesar 될 것입니다,

95
00:05:19,330 --> 00:05:24,190
다음 다음 요소로 이동한다
사용자가에 입력 한 키가 포함되어 있습니다.

96
00:05:24,190 --> 00:05:27,480
이제 한 경우에는 올바르게 사용
시저의 사용에 대한,

97
00:05:27,480 --> 00:05:29,350
그들은 숫자를 입력하는 것입니다.

98
00:05:29,350 --> 00:05:33,260
그러나 심지어 문자 불구하고
그들이 입력했는지 것은 숫자입니다

99
00:05:33,260 --> 00:05:35,790
이 데이터 유형 문자열입니다.

100
00:05:35,790 --> 00:05:40,390
>> 그래서 우리는 것을 어떻게 변환합니까
정수로 문자열?

101
00:05:40,390 --> 00:05:46,680
그래서 납입이 있다고, 문자열,
문자열 (50)를 포함.

102
00:05:46,680 --> 00:05:49,000
그 변환하려면
정수로, 나는 단순히

103
00:05:49,000 --> 00:05:53,340
새로운 변수를 선언
atoi 함수를 호출, 내가 정수.

104
00:05:53,340 --> 00:06:01,160
나는 납입, 내 문자열 변수를 전달하고,
그럼 내가 다음 수 (50)를 포함 할 것이다.

105
00:06:01,160 --> 00:06:04,350
확인 사람을 확인하시기 바랍니다
atoi 함수 기능을위한 페이지

106
00:06:04,350 --> 00:06:07,990
그것의 어떤 라이브러리 확인
에서뿐만 아니라 그것의 가치를 무엇으로

107
00:06:07,990 --> 00:06:14,550
문자열이 전달 된 경우 반환됩니다
의 모든 숫자가 포함되어 있지 않습니다.

108
00:06:14,550 --> 00:06:16,950
>> 그래서 지금 우리가 입수 한 것을
중요한 다음 단계

109
00:06:16,950 --> 00:06:19,430
사용자로부터 평문을 얻을 수있다.

110
00:06:19,430 --> 00:06:21,170
지금,이 것입니다
덜 복잡

111
00:06:21,170 --> 00:06:23,410
주위에 탐색보다
명령 줄 인수.

112
00:06:23,410 --> 00:06:26,190
우리가 할 일은 호출입니다
에는 getString 기능

113
00:06:26,190 --> 00:06:29,660
제공하기 위해 사용자에게 메시지를 표시합니다
우리 문자열,하지만 기억

114
00:06:29,660 --> 00:06:34,090
방법에 대한 사양을 확인 우리
그것에 대해 사용자에게 메시지를 표시 할 수 있습니다.

115
00:06:34,090 --> 00:06:36,420
>> 이제 우리는 온
problem--의 마음

116
00:06:36,420 --> 00:06:38,860
어떻게 일반 텍스트를 암호화하기합니다.

117
00:06:38,860 --> 00:06:42,830
음, 처음의 방법에 대해 이야기하자
한번에 한 문자를 암호화하기 위해,

118
00:06:42,830 --> 00:06:47,370
그리고, 우리는 방법을 해결합니다
전체 일반 텍스트를 반복.

119
00:06:47,370 --> 00:06:50,440
나는 약간의 의사를 서면으로 작성했습니다
황제의 문제.

120
00:06:50,440 --> 00:06:52,310
나는 보시기 바랍니다
뿐만 아니라 자신의 물품.

121
00:06:52,310 --> 00:06:55,900
그것은 동일 보이지 않을 수도
광산, 그것은 OK,하지만 오래입니다

122
00:06:55,900 --> 00:06:58,640
일반적인 생각과 동일합니다.

123
00:06:58,640 --> 00:07:00,780
>> 처음 세 단계
우리는 이미 완료했습니다.

124
00:07:00,780 --> 00:07:03,100
우리는에서 키를 쪘
명령 행 인수

125
00:07:03,100 --> 00:07:05,510
우리는 그 키를 설정 한
정수로, 우리는했습니다

126
00:07:05,510 --> 00:07:09,320
평문에 대해 사용자에게 프롬프트
그들은 암호화하기 것인지.

127
00:07:09,320 --> 00:07:12,420
그래서 그 다음 큰 덩어리
즉, 각 캐릭터 인

128
00:07:12,420 --> 00:07:15,070
일반 텍스트 문자열,
이 알파벳의 경우,

129
00:07:15,070 --> 00:07:17,750
우리는 보존하려면
케이스와 그것을 이동.

130
00:07:17,750 --> 00:07:20,900
, 경우 보존함으로써 내가
말은 모두 대문자로 그

131
00:07:20,900 --> 00:07:23,580
편지 상위를 유지해야
케이스와 소문자

132
00:07:23,580 --> 00:07:25,640
소문자로 남아 있어야한다.

133
00:07:25,640 --> 00:07:29,110
그럼 우리가 사람들을 이동 한 후,
우리는 암호문을 인쇄 할 수 있습니다.

134
00:07:29,110 --> 00:07:33,100
>> 여기가는 세 가지 기능은
이 문제에 대한 편리합니다.

135
00:07:33,100 --> 00:07:38,010
내가 준 경우 위까지 기억
이 이동에 대한 예는 CS50입니까?

136
00:07:38,010 --> 00:07:41,800
기억 그 (50)와
느낌표는 이동하지 않았다?

137
00:07:41,800 --> 00:07:45,680
그래서 우리는 우리 여부를 어떻게 알 수
편지를 이동 여부를해야합니까?

138
00:07:45,680 --> 00:07:48,650
음,이 "알파입니다"
당신은 문자 통과,

139
00:07:48,650 --> 00:07:54,850
해당 문자가있는 경우 true를 돌려줍니다
그렇지 않으면 편지 거짓이다.

140
00:07:54,850 --> 00:07:56,870
당신을 돕기 위해
보존 대문자

141
00:07:56,870 --> 00:07:59,750
기능은 "입니다
상단 "과"하단이다. "

142
00:07:59,750 --> 00:08:03,350
>> 이 두 기능도 수행
입력으로 하나의 문자에

143
00:08:03,350 --> 00:08:06,580
그리고, 당신은 부울을 반환
참 또는 거짓

144
00:08:06,580 --> 00:08:11,280
해당 문자 여부에 따라
대문자 또는 소문자입니다.

145
00:08:11,280 --> 00:08:14,610
"위는"때문에 "입니다
낮은 "부울 기능은,

146
00:08:14,610 --> 00:08:18,660
그들이 당신에게 부울을 반환한다는 것을 의미,
당신은 당신의 상황에서 이러한 사용할 수 있습니다.

147
00:08:18,660 --> 00:08:23,490
그래서 여기에 코드 조각입니다 만
이 대문자 인 경우 편지를 인쇄합니다.

148
00:08:23,490 --> 00:08:27,790
그래서 난 내 캐릭터를 선언했습니다
문자는 대문자 데이빗한다

149
00:08:27,790 --> 00:08:33,440
다음 경우는 반환 "위입니다"
사실, 그때 그 편지를 인쇄 할 수 있습니다.

150
00:08:33,440 --> 00:08:38,200
>> 우리의 간단한 예제로 돌아 간다
두 가지의 핵심으로 알파벳을 이동,

151
00:08:38,200 --> 00:08:41,049
어떻게 우리가 실제로 그 일을 어떻게해야합니까?

152
00:08:41,049 --> 00:08:45,770
음, 문자 밝혀
및 정수는 매우 밀접하게 관련되어있다.

153
00:08:45,770 --> 00:08:48,840
각 문자는이
관련 정수 값

154
00:08:48,840 --> 00:08:53,260
그것은 ASCII 차트에서 발견하여,
여기서 각 문자의 ASCII

155
00:08:53,260 --> 00:08:55,380
값이 표시됩니다.

156
00:08:55,380 --> 00:08:58,940
그래서 대문자 A가 대응
(65)의 ASCII 값

157
00:08:58,940 --> 00:09:02,270
와 소문자 a를에
97의 ASCII 값입니다.

158
00:09:02,270 --> 00:09:04,940
>> 찾아 주시기 바랍니다
온라인 어떤 ASCII 차트

159
00:09:04,940 --> 00:09:07,720
자신을 위해이 값을 볼 수 있습니다.

160
00:09:07,720 --> 00:09:12,096
그래서 이것이 의미하는 것은 우리가 할 수있는 것입니다
대문자 A의 특성을

161
00:09:12,096 --> 00:09:18,200
그것에 정수 개의 추가하고 얻을
결과로서 문자 대문자 C.

162
00:09:18,200 --> 00:09:23,720
즉, (65) 때문에, ASCII의
자본 A의 값, 플러스 2,

163
00:09:23,720 --> 00:09:29,960
해당하는 우리에게 67을 제공합니다
대문자 C의 문자

164
00:09:29,960 --> 00:09:33,480
>> 불행하게도, 일
아주 간단하지 않습니다.

165
00:09:33,480 --> 00:09:36,980
우리는 방정식을 가질 수
우리는 고려해야한다.

166
00:09:36,980 --> 00:09:43,590
다음은 i 번째 암호문 것을 우리에게 알려줍니다
문자 i 번째 평문에 대응

167
00:09:43,590 --> 00:09:48,900
편지 플러스 key--
이 모든 모듈 26.

168
00:09:48,900 --> 00:09:50,810
이유 경우입니까?

169
00:09:50,810 --> 00:09:55,430
이제부터 우리의 예를 다시 가자
전에 여기서 자본 A, 플러스 2,

170
00:09:55,430 --> 00:09:57,590
우리에게 자본 C.을 제공합니다

171
00:09:57,590 --> 00:10:01,870
>> 그래서 방정식이 적용
사양은, 우리를 제공합니다

172
00:10:01,870 --> 00:10:06,660
다음의 자본 A를 보자
(2) 및 (26)에 의한 모드 플러스.

173
00:10:06,660 --> 00:10:10,730
그래서 자본 A, 때 나는에 넣어
그 작은 따옴표,

174
00:10:10,730 --> 00:10:14,010
내게로 처리 할 수​​ 있습니다
정수, 그래서 허용

175
00:10:14,010 --> 00:10:17,500
내게는 ASCII 값 (65)에 캐스팅합니다.

176
00:10:17,500 --> 00:10:20,080
65 플러스 2는 67입니다.

177
00:10:20,080 --> 00:10:25,210
67 모드 (26)는, 우리에게 15을 제공합니다
하지만 그건 정말하지 않습니다

178
00:10:25,210 --> 00:10:32,590
우리가 알고 있기 때문에 이해
자본 C의 ASCII 값은 67이 아니라 15입니다.

179
00:10:32,590 --> 00:10:35,580
그렇다면 우리는 화해합니까?

180
00:10:35,580 --> 00:10:39,840
>> 음, 여기 난을 단정하고 싶습니다
알파벳 인덱스의 개념.

181
00:10:39,840 --> 00:10:44,010
그래서 우리는 이미 방법에 대해 얘기했습니다
각 캐릭터는 자신 ASCII 값을 갖는다

182
00:10:44,010 --> 00:10:48,810
하지만 난 잘하자, 말을하고 싶습니다
각 문자는 것에 대한 생각

183
00:10:48,810 --> 00:10:52,230
알파벳 인덱스,
어디 예를 들어,

184
00:10:52,230 --> 00:10:58,800
알파벳의 첫 글자로,
제로의 알파벳 색인이 있습니다.

185
00:10:58,800 --> 00:11:02,070
그래서 지금의은을 적용 할 수
같은 식 이전과,

186
00:11:02,070 --> 00:11:05,040
하지만 알파벳 인덱스를 사용.

187
00:11:05,040 --> 00:11:07,810
>> 우리가 정의한 그래서 A는 제로이다.

188
00:11:07,810 --> 00:11:15,640
그럼 제로 플러스 두 모드 (26)를 복용,
즉,이 두가 우리에게주는 모드 26입니다.

189
00:11:15,640 --> 00:11:18,780
의 잘,의 용어
알파벳 인덱스,

190
00:11:18,780 --> 00:11:23,930
C는 세 번째 문자입니다
알파벳, 그래서는 해당 것

191
00:11:23,930 --> 00:11:26,290
두 가지의 알파벳 색인.

192
00:11:26,290 --> 00:11:29,850
그래서을 사용하는 것 같다
이 경우 알파벳순 색인

193
00:11:29,850 --> 00:11:32,840
실제로 우리에게 올바른 결과를 제공합니다.

194
00:11:32,840 --> 00:11:35,020
>> 그래서 지금의 확인하자에
방정식 작동하는지 확인

195
00:11:35,020 --> 00:11:37,210
알파벳 인덱스.

196
00:11:37,210 --> 00:11:42,540
Y의 알파벳 지수는 24이다
알파벳의 마지막 글자에 두 번째.

197
00:11:42,540 --> 00:11:46,520
그럼 24 플러스 우리의
두 가지의 핵심은 우리에게 26을 제공합니다.

198
00:11:46,520 --> 00:11:54,750
26 모드 (26)는 우리에게 0, 대한, 행운을 제공합니다
우리는, A.의 알파벳 인덱스

199
00:11:54,750 --> 00:11:59,100
그래서 잘하면 그것으로 충분 그 증거
알파벳 색인 방법을 사용할 수 있습니다.

200
00:11:59,100 --> 00:12:03,180
그렇지 않은 경우, 시도해 주시기 바랍니다
자신의 몇 가지 예입니다.

201
00:12:03,180 --> 00:12:08,030
>> 적절하게 감싸는 위해서
알파벳과 시저 방정식을 적용,

202
00:12:08,030 --> 00:12:11,280
우리는 우리가해야 할 것을 알고있다
알파벳 인덱스 처리합니다.

203
00:12:11,280 --> 00:12:15,130
그러나 우리는 ASCII로 시작
단지 다음 값 및

204
00:12:15,130 --> 00:12:18,530
우리는 그 다음에 변환합니까
알파벳 인덱스입니다.

205
00:12:18,530 --> 00:12:23,970
거기에서 인쇄하기 위해, 우리는 필요
다시 ASCII 값을 처리합니다.

206
00:12:23,970 --> 00:12:28,350
그래서 우리는 방법을 강구해야
알파벳순 ASCII에서 이동

207
00:12:28,350 --> 00:12:31,080
및 알파벳에서 ASCII한다.

208
00:12:31,080 --> 00:12:34,910
>> 그래서 알아 내기 위해 당신에게 맡겨
문자 사이의 패턴

209
00:12:34,910 --> 00:12:38,590
그 알파벳
인덱스와 ASCII 값입니다.

210
00:12:38,590 --> 00:12:41,530
지금, 비록 그 기억
슬라이드에이 테이블 오른쪽

211
00:12:41,530 --> 00:12:45,630
우리는 또한 대문자를 보여줍니다
여부를 고려해야합니다

212
00:12:45,630 --> 00:12:48,915
다른 패턴을 적용한다
소문자 문자.

213
00:12:48,915 --> 00:12:52,070

214
00:12:52,070 --> 00:12:55,840
>> 그래서 지금 우리가 알아 냈으니
단일 문자를 이동하는 방법,

215
00:12:55,840 --> 00:13:02,200
우리가 할 일은 규모입니다
최대는 전체 일반 텍스트를 가로 질러 이동합니다.

216
00:13:02,200 --> 00:13:04,260
그래서 일반 텍스트 문자열입니다.

217
00:13:04,260 --> 00:13:08,210
우리에게 운이 문자열은 정말
문자 다만 배열,

218
00:13:08,210 --> 00:13:12,150
그래서 모든 문자에 액세스하기 위해,
문자열의 모든 당신이해야 할

219
00:13:12,150 --> 00:13:14,270
배열 표기법을 사용하는 것이다.

220
00:13:14,270 --> 00:13:20,270
내가 유형의 변수가 있다고 가정
라는 문자열 "텍스트 = '이 CS50입니다."

221
00:13:20,270 --> 00:13:22,730
>> 그럼, 순서에
각 문자를 액세스,

222
00:13:22,730 --> 00:13:25,880
모든 내가 함께 할 수있다
변수 텍스트는

223
00:13:25,880 --> 00:13:31,660
것을, 잘 말할 인덱스 제로에서 텍스트하기
인덱스 자본 T. 텍스트에 해당

224
00:13:31,660 --> 00:13:35,100
하나는 하부 케이스 H에 상당한다.

225
00:13:35,100 --> 00:13:38,110
또 다른 유용한 기능입니다
문자열 길이 기능.

226
00:13:38,110 --> 00:13:40,760
그래서에 문자열 전달
이 함수는 반환합니다

227
00:13:40,760 --> 00:13:44,610
정수, 그 문자열의 길이.

228
00:13:44,610 --> 00:13:47,060
>> 우리가 이야기 한 지금
이러한 모든 다른 요소,

229
00:13:47,060 --> 00:13:48,540
의 함께 그들을 다시 넣어 보자.

230
00:13:48,540 --> 00:13:52,210
그러니 내 의사로 복귀
코드 또는 의사

231
00:13:52,210 --> 00:13:55,920
및 통과하고 있는지 확인하십시오 당신이
매일 일을하는 방법을 알고있다.

232
00:13:55,920 --> 00:14:01,520
는 argc와 argv를를 사용하여 키를 가져 오기,
정수로 키를 회전하는

233
00:14:01,520 --> 00:14:06,840
난에 일반 텍스트에 대한 메시지를 표시,
getString에, 다음 반복

234
00:14:06,840 --> 00:14:09,590
모든 문자에 이상
일반 텍스트 문자열

235
00:14:09,590 --> 00:14:14,910
각 문자의 경우 보존
그리고 키에 의해 그 문자를 이동,

236
00:14:14,910 --> 00:14:17,520
당신이있어 보장
알파벳의 주위에 포장,

237
00:14:17,520 --> 00:14:20,850
마지막으로 그 암호문을 인쇄.

238
00:14:20,850 --> 00:14:25,470
내 이름은 Amila이며,이 카이사르였다.

239
00:14:25,470 --> 00:14:28,448

