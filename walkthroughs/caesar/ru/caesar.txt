Амила: Давайте решать Цезарь. В Цезаря, мы позволяем пользователю для кодирования секретное сообщение. Так что давайте нырять прямо и смотреть у наших к-DOS для этой задачи. Таким образом, во-первых, мы получаем ключ от пользователя. Тогда мы получим открытый текст что они хотят, чтобы кодировать. После этого, мы зашифровать это для них, и, наконец, мы выводим их шифротекста. 

Итак, давайте начнем с примера. Допустим, вы хотели, чтобы кодировать Весь алфавит с ключом двух. Ну, весь ваш алфавит будет просто быть сдвинуты на письма. Таким образом, будет кодировать C, B к D, С к Е, так далее и тому подобное, пока вы не получите до X, который кодирует до Z или зет, в зависимости от того, откуда вы. Тогда Y будет затем переложить всю дорогу, обернуть вокруг алфавита, чтобы добраться до A, а затем, наконец, последняя буква алфавита, Z, зет, будет кодировать B. 

Ты понял? Давайте посмотрим на некоторые примеры. Первый пример здесь очень похож к тому, что мы только что описано выше. Так что если я закодировать некоторую секцию алфавит, А через L, с помощью ключа из двух, тогда я просто получить вся моя алфавит сдвинуты две буквы. 

Тогда, в моем следующем примере, ключ все еще два, так что вы должны знать, по-прежнему какие буквы ожидать. Но вот это фраза. Это CS50. Таким образом, вы заметили, что я сохранить случай моих писем, поэтому любые заглавные буквы также заглавные буквы в зашифрованном тексте. И любой нижний регистр буквы в незашифрованном Также в нижнем регистре буквы в зашифрованном тексте. Но я держу письма и любые восклицательные знаки или любые другие знаки пунктуации то же самое. 

Так что теперь у нас есть чувство за то, как работает программа, не стесняйтесь идти работать еще немного примеры самостоятельно, если вы хотите. Давайте начнем с получением ключ от пользователя. Традиционно, с другие проблемы, мы привыкли к получению любые цифры, которые мы нужно путем подсказки пользователю с функцией GetInt. Но на этот раз мы на самом деле происходит использовать аргумент командной строки и новая функция называется atoi. 

При запуске основной Программа в С, то она принимает в двух parameters-- INT ARGC, который это число аргументов прошло, и затем ARGV, массив строк, который содержит список всех аргументов прошло. Вы явно не имеют объявить эти переменные. Они рассчитаны для Вы компилятором. Правильное использование для этого было бы для ARGC быть в данном случае два, потому что пользователь должен пройти в вызов программы, ./caesar, а затем ключ, какое бы число они желают. Таким образом, это означает, что ARGC должно быть два для того, чтобы действительного использования Цезаря для выполнения. 

Итак, давайте рассмотрим пример. Скажем, я уже написал и составил программу под названием Бластоф. Так что, если я побежал в командной строке ./blastoff Rocket Team, ну, тогда, ARGC бы три, потому что я прошло в трех различных аргументов. Тогда ARGV будет выглядеть следующим образом. Это массив, и это было бы содержат каждый из трех строк. ./blastoff в первом индекса, команда в следующем, и ракеты в последний. 

Давайте поговорим о массивах на секунду. Массивы представляют собой структуры данных, которые держат несколько значений одного и того же типа. Это может пригодиться, когда мы есть списки целых чисел или строк. Просто помните, у них есть чтобы быть того же типа. В компьютерной науке, мы любовь считая от нуля, так что помните, что массивы также нулевой проиндексированы. Так что первый элемент моего массива будет индексом ноль. Так что в этом случае, когда у меня есть массив длины четыре, то последний индекс вставленного Последний элемент моего массива на самом деле будет по индексу три, а не четыре. Потому что помните, что мы начать отсчет с нуля. 

Вот пример того, как вы может создать массив самостоятельно. Так что сказать, что я хотел, чтобы сохранить мой три любимые названия собаки. Тогда я хотел бы создать массив строк. Поэтому я хотел бы объявить тип, строку, и затем поместить имя массива, собаки, а затем в тех квадрате скобки поставить размер из array-- в данном случае, три. 

Так что моя первая запись будет чтобы собаки с индексом ноль, и что будет Майло. Тогда собаки с индексом одной будет бестолковой, дорогая Моти, а затем последний запись, третья запись на индекса два, будет мило, сладкий Elphie. Вы заметите, что формат для заполнения этого массива очень похоже, как вы могли бы объявить любую другую переменную, в которой у вас есть имя переменной, за которой следует значение, которое вы хотите хранить в нем. Единственное различие в этот случай является то, что вам должны помнить, чтобы поставить индекс значения в квадратных скобках. И там у нас есть наши три любимые собаки. 

Но, увы, пришло время чтобы вернуться к Цезарю. Помните, что правильное использование для пользователь будет проходит не только в название программы ./caesar, но также ключ, что они хотят переложить их открытого текста с помощью. Таким образом, это означает, что ARGC должно быть два. Они должны пройти в two-- ни больше, ни менее двух аргументов командной строки. 

Теперь, что касается ARGV? Ну, мы уже знаем, что массив будет иметь длину два, но то, что содержится в каждом элементе? Ну, первый элемент будет ./caesar, а затем следующий элемент будет содержат ключ, который пользователь напечатали. Теперь, если они использовали его правильно для использования Цезаря, Затем они собираются ввести номер. Но даже если характер что они печатают это число, это типа данных строки. 

Так как же мы преобразуем, что строка в целое число? Так что у меня есть Num, строка, содержащая строку 50. Если я хочу, чтобы преобразовать его в целое число, то я просто объявить новую переменной, целого г, называя atoi. Я прохожу в моей переменной строки, Num и Затем я будет содержать номер 50. Убедитесь в том, чтобы проверить мужчину страницы для функции atoi чтобы проверить, какая библиотека это в, а также то, что значение его вернется, если строка, переданная в содержит не все номера. 

Так что теперь мы получили ключ, следующий шаг чтобы получить открытый текст от пользователя. Теперь, это будет быть менее сложным чем навигации по аргументы командной строки. Все, что нам нужно сделать, это вызов функция GetString подсказать пользователю, чтобы дать нам строка, но помните, чтобы проверить спецификации для того, как мы может потребоваться подсказать пользователю для этого. 

Теперь мы подошли к Сердце problem-- как зашифровать открытый текст. Ну, во-первых, давайте поговорим о том, как зашифровать один символ в то время, и тогда мы будем решать, как перебирать весь открытый текст. Я написал некоторые псевдокод для задачи Цезаря. Я призываю вас написать свой собственный, а также. Он не может выглядеть идентично мое, и это нормально, но до тех пор, как общая идея та же. 

Первые три шага мы уже сделали. Мы получили ключ от аргумент командной строки, мы превратили этот ключ в целое число, и мы запрос пользователя для открытого текста что они хотят, чтобы зашифровать. Так тогда следующий большой кусок в том, что для каждого символа в строке открытого текста, если это алфавитный, мы хотим сохранить ее корпус и сдвинуть его. По сохранить дело, что я означает, что верхний регистр буквы должны оставаться Upper Корпус и все буквы нижнего регистра должны оставаться в нижнем регистре. Итак, после мы перемещаем те, Затем мы выводим шифротекста. 

Вот три функции, которые собираются чтобы прийти в удобный для этой проблемы. Помните, наверху, когда я дал Пример для сдвига это CS50? Помните, что 50 и Восклицательный знак не перекладывал? Так как же мы можем сказать, является ли мы необходимо переместить письмо или нет? Ну, "альфа", если вы передаете его персонаж, возвращает истину, если этот символ это письмо и ложь в противном случае. Чтобы помочь вам сохранение капитализации являются функциями "является верхний "и" ниже ". 

Эти две функции также принимают в один символ в качестве входных данных и вернуть вам логическое значение, истинным или ложным в зависимости от того, что характер в верхнем регистре или нижнем регистре. Потому что "сверху" и "является ниже "являются булевы функции, Это означает, что они возвращают вам логическое значение, Вы можете использовать их в своих условиях. Так вот фрагмент кода, который только печатает письмо, если это в верхнем регистре. Так что я объявил мой характер письма в верхний корпус зет а затем, если "сверху" возвращается правда, то я печатаю это письмо. 

Возвращаясь к нашему простой пример сдвигая алфавит ключом из двух, как же мы на самом деле получить, чтобы работать? Что ж, получается, что персонажи и целые числа очень тесно связаны между собой. Каждый персонаж имеет целое значение, связанное с ним находится в ASCII графике, где ASCII каждого символа отображается значение. Так что соответствует верхний регистр A к значению ASCII 65 и строчной а к Значение ASCII из 97. 

Не стесняйтесь смотреть любой ASCII диаграммы онлайн чтобы увидеть эти ценности для себя. Так что же это означает, что мы можем принимают характер верхнего регистра A, добавить целое два к нему, а затем получить символ верхнего регистра C в результате. Это потому, что 65 лет ASCII значение капитала А, плюс 2, дает нам 67, что соответствует характеру верхнего регистра С. 

К сожалению, дела не совсем так просто. У нас есть уравнение, мы должны рассмотреть. Здесь он говорит о том, что г-й шифротекста буква соответствует г-й открытый текст письмо, плюс key-- все это модульная 26. Почему это так? Давайте вернемся к нашему примеру с до того, где капитал А, плюс 2, дает нам капитал C. 

Таким образом, применяя уравнения, спецификация дает нам, то давайте возьмем капитал A плюс 2 и мод, который на 26. Так капитал А, когда я положил его в эти одиночные кавычки, позволяет мне рассматривать его как целое число, так что позволяет мне бросить его в ASCII-значения, 65. 65 плюс 2 67. 67 мод 26 дает нам 15, но это на самом деле не имеет смысл, потому что мы знаем, что капитал C значение ASCII составляет 67, а не 15. Так как же нам примирить это? 

Ну, здесь я хотел бы постулировать Понятие алфавитным указателем. Таким образом, мы уже говорили о том, как каждый символ имеет ASCII-значение, но я хотел бы сказать, ну, давайте думать о каждый символ, имеющий также алфавитный указатель, где А, например, как первая буква алфавита, имеет алфавитный указатель нуля. Итак, теперь давайте применим такое же уравнение, как и раньше, но с помощью алфавитного указателя. 

Таким образом, равна нулю, так как мы определили. Таким образом, то, взяв ноль плюс два, по модулю 26, это два, по модулю 26, который дает нам два. И хорошо, в терминах алфавитный указатель, C является третья буква в алфавит, так что будет соответствовать к алфавитному указателю двух. Таким образом, кажется, что с помощью алфавитный указатель в этом случае на самом деле дает нам правильный результат. 

Так что теперь давайте проверим на см, если уравнение работ с алфавитным указателем. алфавитный указатель Y является 24, как второе место последней буквы в алфавите. Итак 24 плюс наш Ключ двух дает нам 26. 26 мод 26 дает нам 0, что, к счастью для нас, и есть алфавитный указатель для А. Таким образом, мы надеемся, что достаточно того, что доказательство алфавитный индексный метод работает. Если нет, не стесняйтесь попробовать некоторые примеры самостоятельно. 

Для того, чтобы должным образом обернуть вокруг алфавит и применить уравнение Цезарь, то мы знаем, что нам нужно иметь дело с буквенными индексами. Но мы начинаем с ASCII значения, и только потом мы затем преобразовать в алфавитный указатель. Оттуда, чтобы напечатать, нам нужно иметь дело со значениями ASCII снова. Таким образом, мы должны выяснить, как перейти от ASCII к алфавитной и от алфавитного в ASCII. 

Так что я оставляю вам, чтобы выяснить, шаблон между характером и его алфавитный Индекс и его ASCII значение. Итак, помните, что даже если эту таблицу прямо на слайде показывает, заглавные буквы, мы также должны рассмотреть вопрос о целесообразности или нет применяется другой шаблон для нижнего регистра. 

Так что теперь, когда мы выяснили, как переместить один символ, то все, что мы должны сделать, это шкала, чтобы идти через весь текст. Таким образом, исходный текст является строкой. К счастью для нас, строка действительно просто массив символов, поэтому для того, чтобы получить доступ каждый символ строки, все, что вам нужно сделать, заключается в использовании массива обозначения. Скажем, у меня есть переменная типа строка называется "текст = 'это CS50.'" 

Ну, тогда, для того, чтобы доступ каждого символа, все, что я должен делать с переменная текст сказать, хорошо, текст с индексом ноль, то соответствует капитала Т. Текст по индексу один соответствует строчной ч. Еще одна полезная функция функция длины строки. Так переходя в строку, чтобы что функция будет возвращать целое число, длина этой строки. 

Теперь, когда мы говорили о все эти различные элементы, давайте их вместе. Так что вернуться к любой моей псевдокоде код или ваш псевдокод и идти до конца и убедитесь, что вы знают, как сделать каждую вещь. Получение ключа с помощью ARGC и ARGV, поворотом ключа в целое число, к I, запрашивая открытого текста, GetString, а затем переборе над каждым символом в незашифрованная строка, сохраняя случай каждого символа и переход этот символ с помощью ключа, обеспечение того, чтобы вы обтекание алфавита, наконец-то печать, что шифротекста. Меня зовут Амила, и это был Цезарь. 