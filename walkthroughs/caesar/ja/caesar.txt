AMILA：それでは、カエサルに取り組むみましょう。 シーザーでは、ユーザーを許可します 秘密のメッセージを符号化します。 それでは、右ダイビングしましょう​​と見て この問題のために、私たちに-DOSで。 だから最初は、ユーザーからキーを取得します。 その後、我々は平文を得ます 彼らはエンコードすること。 その後、我々は彼らのためにそれを暗号化、 そして最終的に我々は彼らの暗号文を印刷します。 

それでは、例から始めてみましょう。 あなたがエンコードしたかったと言います 2のキーで全体のアルファベット。 さて、あなたの全体のアルファベットがあろう ただ文字にシフトします。 だからC、Bににエンコードし D、C、Eに、というようになど、 あなたはZにエンコードX、に到達するまで またはあなたからしている場所に応じて、ZED。 そして、Yは、その後、すべての方法をシフトします に到達するためにアルファベットを包み込みます、 のそして最後に最後の手紙 アルファベット、Z、ZED、Bにエンコードし 

あなたはそれを得ましたか。 いくつかの例を見てみましょう。 ここでの最初の例は非常に似ています 私たちは上記で説明したものと。 だから私はいくつかのセクションをエンコードする場合 アルファベット、A Lを介して、2のキーで、 その後、私はちょうど私の全体を取得します アルファベットは二文字をシフト。 

そして、私の次の例では、 キーは、まだ2です だからあなたはまだ知っている必要があります その手紙期待します。 しかし、ここでそれはフレーズです。 これはCS50です。 だから、その私がわかります 私の文字の大文字と小文字を保持、 ので、任意の大文字でもあります 暗号文で大文字。 そして、任意の小文字 平文の文字 また、小文字 暗号文の文字。 しかし、私は手紙を保ちます そして、任意の感嘆符 またはその他の句読点同じ。 

だから今、私たちが意味を持っていること プログラムがどのように動作するかのために、 いくつかの詳細を実行行く気軽に あなた自身の例は、ご希望の場合。 のが得てから始めましょう ユーザーからのキー。 伝統的に、と 他の問題は、我々はしました 取得に慣れて その私たちは任意の数字 ユーザを促すことにより、必要とします 関数GetIntで持ちます。 しかし、今回は実際に行っています コマンドライン引数を使用するには そして新しい機能はatoi関数と呼ばれます。 

あなたは、メインを実行すると、 C言語でプログラム、それ 2 parameters--に取り int型のargc、どの 引数の数であります 渡され、その後、 ARGV、含まれている文字列の配列 すべての引数のリスト 渡されました。 あなたは明示的に持っていません これらの変数を宣言します。 彼らはのために計算しています コンパイラによってあなた。 このための正しい使用法は次のようになります ARGCのための2つは、この場合であると、 ユーザーが渡す必要があるため、 プログラムの呼び出し、./caesar、 そして、キー、 どんな数彼らが望みます。 だからのargcは2でなければならないことを意味します シーザーの有効な使用のための順序で 実行されます。 

それでは、例を見てみましょう。 私はすでに書いたと言うと、 blastoffと呼ばれるプログラムをコンパイル。 だから私は、コマンドラインで実行した場合 ./blastoffロケット団、よく、その後、 argc 3になる私のため 三つの異なる引数で渡されました。 その後、argvが次のようになります。 それは、配列だし、それは希望 3つの文字列のそれぞれを含んでいます。 最初のインデックス、チームの./blastoff 次の、そしてロケットの最後のインチ 

それでは、秒間配列についてお話しましょう​​。 配列は保持データ構造です 同じタイプの複数の値。 ときに我々これは便利になることができます 整数や文字列のリストを持っています。 ただ、彼らが持っている覚えています 同じタイプです。 コンピュータサイエンスでは、我々 ゼロから数え愛、 その結果、配列を覚えています また、ゼロから始まるインデックスです。 私の配列の最初の要素だから インデックスはゼロであることを行っています。 したがって、この場合には、ときに私が持っています 長さ4の配列、 の後、最後のインデックス 私の配列の最後の要素 実際になるだろう インデックス3、ない4時。 そのため、私たちを覚えています ゼロからカウントを開始。 

ここではどのようにあなたの例です。 あなた自身の配列を作成することができます。 だから私は私を保存したかったと言います 3好きな犬の名前。 それから私は、文字列の配列を作成します。 だから私は、文字列をタイプを宣言して、 その後、アレイ、犬の名前を入れて、 次にそれらの広場で ブラケットはサイズを置きます この場合array--の、3。 

だから私の最初のエントリが起こっています インデックスゼロで犬であるためには、 それはミロになるだろう。 そして、インデックス1で犬 間抜けになるだろう、 その後ダーリン餅、そして最後 エントリ、インデックス2で3番目のエントリ、 かわいい、甘いElphieになるだろう。 あなたは形式ことに気づくでしょう この配列を埋めます 非常にどのようにあなたがかもしれないようなものです ここで、他の変数を宣言 あなたが続いて変数名を持っています 必要な値は、それに格納されています。 の唯一の違い この場合は、あなたのことです インデックスを入れて覚えておく必要が 角括弧内の値の。 そして、そこに私たちがを持っています 3好きな犬。 

しかし悲しいかな、それは時間です バックシーザーに取得します。 以下のための正しい使用法を覚えておいてください ユーザーがいないだけに渡すことになるだろう プログラム./caesarの名前が、 彼らがシフトしたいことも鍵 によるそれらの平文。 だからのargcは2でなければならないことを意味します。 彼らはありません、two--それ以上に渡す必要があります 以下の2つのコマンドライン引数。 

さて、何argvのでしょうか？ まあ、我々はすでにことを知っています アレイは、長さが2であることが起こっています しかし、何が各要素に含まれるのですか？ さて、最初の要素 ./caesarになるだろう、 そして、次の要素がに起こっています ユーザーが入力したキーが含まれています。 今、彼らはそれを正しく使用した場合 シーザーの使用のために、 その後、彼らは数を入力しようとしています。 しかし、たとえ文字かかわらず、 彼らが入力することは、数あります それは、データの文字列型です。 

だから我々はそれをどのように変換します 整数に文字列？ だから、私はnumは、文字列を持っていると言います 文字列50を含みます。 私はそれを変換したい場合 単に整数へ、そして私 、新しい変数を宣言 整数私、atoi関数を呼び出します。 私はnumは、私の文字列変数に渡し、 その後、私はその後、数50が含まれています。 男を確認してください ATOI機能のためのページ それはだどのライブラリをチェックします で、だけでなく、それを大切にするもの 文字列が渡された場合に返されます 中には、すべての数字が含まれていません。 

だから今我々が得ていること キー、次のステップ ユーザから平文を取得することです。 さて、これがために起こっています それほど複雑で 周りをナビゲートするよりも コマンドライン引数。 私たちがしなければならないのは、呼び出しです GetString機能 与えるために、ユーザを促します 私たちの文字列が、覚えています どのように我々の仕様をチェックします そのためにユーザに要求することもできます。 

今、私たちはに来て problem--の心 平文を暗号化する方法について説明します。 さて、まず、の方法について話しましょう 一度に1文字を暗号化するために、 し、我々はどのように対処します 全体の平文を反復処理。 私はいくつかの擬似コードを書いています シーザーの問題のために。 私はになることをお勧め 同様にあなた自身を書きます。 これは、同一の見ていない可能性があります 鉱山、それはOK、しかし限りです 一般的な考え方と同じです。 

最初の3つのステップ 我々はすでにやりました。 私たちは、からキーを得ています コマンドライン引数、 私たちは、そのキーを回してきました 整数に、私たちはしました 平文のためのユーザを促し 彼らは暗号化するしたいこと。 それでは、次の大きなチャンク それは、各文字のためのものです プレーンテキスト文字列で、 それはアルファベットだ場合、 我々は維持したいです その場合、それをシフトします。 大文字と小文字を保持することにより、どのようなI 意味そのすべて大文字であります 手紙は、上部ままにしてください ケースとすべて小文字 小文字のままにしてください。 それでは、私たちはそれらをシフトした後、 その後、我々は暗号文を印刷します。 

ここで行っている3つの関数があります この問題のために重宝します。 私が与えた場合、上記のアップを忘れないでください これをシフトするための例は、CS50のですか？ 覚えて50と 感嘆符がシフトしなかったのですか？ だから我々は我々かどうかをどのように伝えることができます 手紙かどうかをシフトする必要がありますか？ まあ、あれば」、アルファです」 あなたはそれの文字通過し、 その文字場合にtrueを返します。 そうでない場合は、文字とfalseです。 のお手伝いをするために、 大文字と小文字を保存します 機能は "されています 上」と「下で」。 

これらの2つの機能は、また取ります 入力として単一の文字で そして、あなたのブールを返します trueまたはfalse その文字かどうかに応じて 大文字または小文字です。 「上で」と「であるため、 下の「ブール関数であり、 彼らはあなたにブールを返すことを意味し、 あなたの条件にこれらを使用することができます。 だからここのコードスニペットは、唯一のことです それが大文字だ場合の文字を印刷します。 だから、私は文字を宣言しました 文字は大文字にZEDします そしてその後、戻り、「上位である」場合 trueの場合、私はその文字を印刷します。 

私たちの単純な例に戻って 2のキーでアルファベットをシフト、 どのように我々は実際にそれが動作するのですか？ まあ、それは文字ことが判明します そして、整数は、非常に密接に関連しています。 各文字は、持っています 関連する整数値 それは、ASCIIチャートで見て、 ここで、各文字のASCII 値が表示されます。 だから、大文字のAの対応 65のASCII値に そして、小文字のaに 97のASCII値。 

ルックアップしてお気軽に オンライン任意のASCIIチャート 自分のためにこれらの値を確認します。 それでは、これが意味する私たちができることです 大文字のAの文字を取り、 それに整数2を追加し、取得 結果として、文字大文字のC。 65ので、それは、ASCIIです 大文字のAの値は、プラス2、 対応している、私たちに67を与えます 上部ケースCの文字へ 

残念ながら、物事 それほど単純ではありません。 私たちは、その方程式を持っています 我々が考えなければなりません。 ここでは、i番目の暗号文を教えてくれる 手紙は、i番目の平文に対応します 手紙、プラスkey-- そのすべて、モジュラー26。 なぜそのような場合ですか？ のから私たちの例に戻りましょう 前に、ここで、大文字のA、プラス2、 資本C.は私たちに与えます 

その結果、式を適用すること 仕様は、私たちを与えます その後の資本Aを見てみましょう 2および26によってそのモッズプラス。 私はそれを置くだから、大文字のA、 これらの単一引用符、 私のようにそれを扱うことができます 整数なので、それが可能に 私はそのASCII値、65にキャストします。 65プラス2は67です。 67モッズ26は、私たちに15を与えます それは本当にありません 私たちがいることを知っているので、意味をなします 資本CのASCII値は67、いない15です。 それでは、どのよう我々はそれを調整しますか？ 

さて、ここで私は断定したいのですが アルファベット順のインデックスの概念。 だから我々はすでに方法について説明しました 各文字は、そのASCII値を持ちます 私はよく、してみましょう、言いたいです 各文字も持っていることについて考えます アルファベット順索引、 ここで、例えばA、 アルファベットの最初の文字として、 ゼロのアルファベット順の索引があります。 だから今のは適用でき 前と同じ式、 しかし、アルファベット順の索引を使用して。 

我々が定義したように、Aは、ゼロです。 それでは、ゼロプラス2、モッズ26を取って、 それは私たちに2を与える2、モッズ26、です。 よく、の観点から アルファベット順索引、 Cは中3番目の文字であります アルファベット、そのためには、対応するであろう 2のアルファベット順のインデックスに。 だから、使用しているようです この場合のアルファベット順索引 実際に私たちに正しい結果を与えます。 

だから今のは、にチェックしてみましょう 式が動作するかどうかを確認 アルファベット順のインデックスを持ちます。 Yのアルファベット順のインデックスは、24であります アルファベットの最後の文字に2番目。 それでは、24プラス、当社 2の鍵は、私たちに26を与えます。 26モッズ26は私たちに0、のために、幸運を与えます 私たちは、Aのアルファベット順の索引です だから、うまくいけば、それは十分な証拠です アルファベット順のインデックスメソッドが動作します。 ない場合は、試してみるお気軽に あなた自身のいくつかの例。 

適切に包み込むために、 アルファベットとシーザー方程式を適用し、 その後、我々は我々がする必要があることを知っています アルファベット順のインデックスを扱います。 しかし、我々は、ASCIIで始まります のみ、値、および 私たちは、その後に変換ん アルファベット順の索引。 そこから、印刷するために、我々は、必要 再びASCII値に対処します。 だから我々はどのように把握する必要があり アルファベット順ASCIIから行きます アルファベットからASCIIへ。 

だから私は把握するあなたにそれを残します 文字間のパターン そのアルファベット 指標とそのASCII値。 今、たとえていることを覚えています スライド上で、この表の右側 我々はまた、大文字を示しています かどうかを検討する必要があります 異なるパターンが適用されます 小文字用。 

だから今我々が考え出したこと 単一の文字をシフトする方法、 その後、私たちがしなければならないすべては、スケールがあること 全体の平文を渡るまでの。 だから、平文は文字列です。 私たちにとってラッキー、文字列が実際にあります 文字の配列だけ、 ので、すべての文字にアクセスするために 文字列の、すべてあなたがしなければなりません 配列表記を使用することです。 私は型の変数を持っていると言います 文字列」テキストは= 'これはCS50です。」」 

さて、その後、順番にへ 各文字にアクセスし、 私がしなければならないすべて 変数テキストです ことを、よくインデックスゼロでテキストを避けます インデックスでは、大文字のTテキストに対応 1は、小文字のhに相当します。 別の有用な機能です 文字列の長さの関数。 だからに文字列を渡します その関数は戻ります 整数、その​​文字列の長さ。 

今、私たちは約話したこと すべてのこれらの異なる要素、 それでは、それらを一緒に戻しましょう​​。 だから私の擬似コードのいずれかに戻ります コー​​ドまたはあなたの擬似コード 貫​​通行くと必ずことを確認 一つ一つのことを行う方法を知っています。 argcとargvのを使用してキーを取得します、 整数にキーを回し、A 私に、平文の入力を求めます、 GetStringメソッド、およびその後反復 内のすべての文字を超えます 平文の文字列、 各文字の大文字と小文字を保存します そしてキーでその文字をシフト、 あなたがしていることを確実にすること アルファベットの周りに巻き付け、 最終的にはその暗号文を印刷します。 私の名前はAmilaであり、これはシーザーでした。 