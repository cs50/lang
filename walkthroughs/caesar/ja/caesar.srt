1
00:00:00,000 --> 00:00:00,760

2
00:00:00,760 --> 00:00:02,270
>> AMILA：それでは、カエサルに取り組むみましょう。

3
00:00:02,270 --> 00:00:06,110
シーザーでは、ユーザーを許可します
秘密のメッセージを符号化します。

4
00:00:06,110 --> 00:00:09,780
それでは、右ダイビングしましょう​​と見て
この問題のために、私たちに-DOSで。

5
00:00:09,780 --> 00:00:12,210
だから最初は、ユーザーからキーを取得します。

6
00:00:12,210 --> 00:00:15,210
その後、我々は平文を得ます
彼らはエンコードすること。

7
00:00:15,210 --> 00:00:21,380
その後、我々は彼らのためにそれを暗号化、
そして最終的に我々は彼らの暗号文を印刷します。

8
00:00:21,380 --> 00:00:23,600
>> それでは、例から始めてみましょう。

9
00:00:23,600 --> 00:00:26,920
あなたがエンコードしたかったと言います
2のキーで全体のアルファベット。

10
00:00:26,920 --> 00:00:31,360
さて、あなたの全体のアルファベットがあろう
ただ文字にシフトします。

11
00:00:31,360 --> 00:00:37,060
だからC、Bににエンコードし
D、C、Eに、というようになど、

12
00:00:37,060 --> 00:00:42,470
あなたはZにエンコードX、に到達するまで
またはあなたからしている場所に応じて、ZED。

13
00:00:42,470 --> 00:00:47,445
そして、Yは、その後、すべての方法をシフトします
に到達するためにアルファベットを包み込みます、

14
00:00:47,445 --> 00:00:53,256
のそして最後に最後の手紙
アルファベット、Z、ZED、Bにエンコードし

15
00:00:53,256 --> 00:00:54,660
>> あなたはそれを得ましたか。

16
00:00:54,660 --> 00:00:56,380
いくつかの例を見てみましょう。

17
00:00:56,380 --> 00:01:00,540
ここでの最初の例は非常に似ています
私たちは上記で説明したものと。

18
00:01:00,540 --> 00:01:05,560
だから私はいくつかのセクションをエンコードする場合
アルファベット、A Lを介して、2のキーで、

19
00:01:05,560 --> 00:01:09,760
その後、私はちょうど私の全体を取得します
アルファベットは二文字をシフト。

20
00:01:09,760 --> 00:01:12,230
>> そして、私の次の例では、
キーは、まだ2です

21
00:01:12,230 --> 00:01:15,080
だからあなたはまだ知っている必要があります
その手紙期待します。

22
00:01:15,080 --> 00:01:16,400
しかし、ここでそれはフレーズです。

23
00:01:16,400 --> 00:01:18,100
これはCS50です。

24
00:01:18,100 --> 00:01:21,090
だから、その私がわかります
私の文字の大文字と小文字を保持、

25
00:01:21,090 --> 00:01:25,600
ので、任意の大文字でもあります
暗号文で大文字。

26
00:01:25,600 --> 00:01:27,800
そして、任意の小文字
平文の文字

27
00:01:27,800 --> 00:01:30,640
また、小文字
暗号文の文字。

28
00:01:30,640 --> 00:01:34,020
しかし、私は手紙を保ちます
そして、任意の感嘆符

29
00:01:34,020 --> 00:01:37,610
またはその他の句読点同じ。

30
00:01:37,610 --> 00:01:40,360
>> だから今、私たちが意味を持っていること
プログラムがどのように動作するかのために、

31
00:01:40,360 --> 00:01:43,890
いくつかの詳細を実行行く気軽に
あなた自身の例は、ご希望の場合。

32
00:01:43,890 --> 00:01:47,072
のが得てから始めましょう
ユーザーからのキー。

33
00:01:47,072 --> 00:01:48,780
伝統的に、と
他の問題は、我々はしました

34
00:01:48,780 --> 00:01:51,450
取得に慣れて
その私たちは任意の数字

35
00:01:51,450 --> 00:01:54,710
ユーザを促すことにより、必要とします
関数GetIntで持ちます。

36
00:01:54,710 --> 00:01:58,850
しかし、今回は実際に行っています
コマンドライン引数を使用するには

37
00:01:58,850 --> 00:02:01,760
そして新しい機能はatoi関数と呼ばれます。

38
00:02:01,760 --> 00:02:05,130
>> あなたは、メインを実行すると、
C言語でプログラム、それ

39
00:02:05,130 --> 00:02:08,500
2 parameters--に取り
int型のargc、どの

40
00:02:08,500 --> 00:02:11,670
引数の数であります
渡され、その後、

41
00:02:11,670 --> 00:02:15,920
ARGV、含まれている文字列の配列
すべての引数のリスト

42
00:02:15,920 --> 00:02:16,740
渡されました。

43
00:02:16,740 --> 00:02:19,740
あなたは明示的に持っていません
これらの変数を宣言します。

44
00:02:19,740 --> 00:02:22,700
彼らはのために計算しています
コンパイラによってあなた。

45
00:02:22,700 --> 00:02:28,160
このための正しい使用法は次のようになります
ARGCのための2つは、この場合であると、

46
00:02:28,160 --> 00:02:32,630
ユーザーが渡す必要があるため、
プログラムの呼び出し、./caesar、

47
00:02:32,630 --> 00:02:35,570
そして、キー、
どんな数彼らが望みます。

48
00:02:35,570 --> 00:02:39,920
だからのargcは2でなければならないことを意味します
シーザーの有効な使用のための順序で

49
00:02:39,920 --> 00:02:41,680
実行されます。

50
00:02:41,680 --> 00:02:43,590
>> それでは、例を見てみましょう。

51
00:02:43,590 --> 00:02:47,760
私はすでに書いたと言うと、
blastoffと呼ばれるプログラムをコンパイル。

52
00:02:47,760 --> 00:02:52,670
だから私は、コマンドラインで実行した場合
./blastoffロケット団、よく、その後、

53
00:02:52,670 --> 00:02:57,750
argc 3になる私のため
三つの異なる引数で渡されました。

54
00:02:57,750 --> 00:02:59,830
その後、argvが次のようになります。

55
00:02:59,830 --> 00:03:03,750
それは、配列だし、それは希望
3つの文字列のそれぞれを含んでいます。

56
00:03:03,750 --> 00:03:09,640
最初のインデックス、チームの./blastoff
次の、そしてロケットの最後のインチ

57
00:03:09,640 --> 00:03:11,610
>> それでは、秒間配列についてお話しましょう​​。

58
00:03:11,610 --> 00:03:15,560
配列は保持データ構造です
同じタイプの複数の値。

59
00:03:15,560 --> 00:03:19,980
ときに我々これは便利になることができます
整数や文字列のリストを持っています。

60
00:03:19,980 --> 00:03:23,030
ただ、彼らが持っている覚えています
同じタイプです。

61
00:03:23,030 --> 00:03:25,310
コンピュータサイエンスでは、我々
ゼロから数え愛、

62
00:03:25,310 --> 00:03:29,260
その結果、配列を覚えています
また、ゼロから始まるインデックスです。

63
00:03:29,260 --> 00:03:34,360
私の配列の最初の要素だから
インデックスはゼロであることを行っています。

64
00:03:34,360 --> 00:03:37,580
したがって、この場合には、ときに私が持っています
長さ4の配列、

65
00:03:37,580 --> 00:03:41,350
の後、最後のインデックス
私の配列の最後の要素

66
00:03:41,350 --> 00:03:44,970
実際になるだろう
インデックス3、ない4時。

67
00:03:44,970 --> 00:03:48,880
そのため、私たちを覚えています
ゼロからカウントを開始。

68
00:03:48,880 --> 00:03:52,530
>> ここではどのようにあなたの例です。
あなた自身の配列を作成することができます。

69
00:03:52,530 --> 00:03:56,440
だから私は私を保存したかったと言います
3好きな犬の名前。

70
00:03:56,440 --> 00:03:59,030
それから私は、文字列の配列を作成します。

71
00:03:59,030 --> 00:04:04,450
だから私は、文字列をタイプを宣言して、
その後、アレイ、犬の名前を入れて、

72
00:04:04,450 --> 00:04:06,450
次にそれらの広場で
ブラケットはサイズを置きます

73
00:04:06,450 --> 00:04:09,260
この場合array--の、3。

74
00:04:09,260 --> 00:04:12,690
>> だから私の最初のエントリが起こっています
インデックスゼロで犬であるためには、

75
00:04:12,690 --> 00:04:14,750
それはミロになるだろう。

76
00:04:14,750 --> 00:04:17,850
そして、インデックス1で犬
間抜けになるだろう、

77
00:04:17,850 --> 00:04:23,060
その後ダーリン餅、そして最後
エントリ、インデックス2で3番目のエントリ、

78
00:04:23,060 --> 00:04:26,130
かわいい、甘いElphieになるだろう。

79
00:04:26,130 --> 00:04:28,610
あなたは形式ことに気づくでしょう
この配列を埋めます

80
00:04:28,610 --> 00:04:32,150
非常にどのようにあなたがかもしれないようなものです
ここで、他の変数を宣言

81
00:04:32,150 --> 00:04:36,307
あなたが続いて変数名を持っています
必要な値は、それに格納されています。

82
00:04:36,307 --> 00:04:38,140
の唯一の違い
この場合は、あなたのことです

83
00:04:38,140 --> 00:04:42,700
インデックスを入れて覚えておく必要が
角括弧内の値の。

84
00:04:42,700 --> 00:04:46,420
そして、そこに私たちがを持っています
3好きな犬。

85
00:04:46,420 --> 00:04:48,780
>> しかし悲しいかな、それは時間です
バックシーザーに取得します。

86
00:04:48,780 --> 00:04:52,910
以下のための正しい使用法を覚えておいてください
ユーザーがいないだけに渡すことになるだろう

87
00:04:52,910 --> 00:04:57,430
プログラム./caesarの名前が、
彼らがシフトしたいことも鍵

88
00:04:57,430 --> 00:04:58,850
によるそれらの平文。

89
00:04:58,850 --> 00:05:01,540
だからのargcは2でなければならないことを意味します。

90
00:05:01,540 --> 00:05:07,580
彼らはありません、two--それ以上に渡す必要があります
以下の2つのコマンドライン引数。

91
00:05:07,580 --> 00:05:09,050
>> さて、何argvのでしょうか？

92
00:05:09,050 --> 00:05:12,880
まあ、我々はすでにことを知っています
アレイは、長さが2であることが起こっています

93
00:05:12,880 --> 00:05:15,270
しかし、何が各要素に含まれるのですか？

94
00:05:15,270 --> 00:05:19,330
さて、最初の要素
./caesarになるだろう、

95
00:05:19,330 --> 00:05:24,190
そして、次の要素がに起こっています
ユーザーが入力したキーが含まれています。

96
00:05:24,190 --> 00:05:27,480
今、彼らはそれを正しく使用した場合
シーザーの使用のために、

97
00:05:27,480 --> 00:05:29,350
その後、彼らは数を入力しようとしています。

98
00:05:29,350 --> 00:05:33,260
しかし、たとえ文字かかわらず、
彼らが入力することは、数あります

99
00:05:33,260 --> 00:05:35,790
それは、データの文字列型です。

100
00:05:35,790 --> 00:05:40,390
>> だから我々はそれをどのように変換します
整数に文字列？

101
00:05:40,390 --> 00:05:46,680
だから、私はnumは、文字列を持っていると言います
文字列50を含みます。

102
00:05:46,680 --> 00:05:49,000
私はそれを変換したい場合
単に整数へ、そして私

103
00:05:49,000 --> 00:05:53,340
、新しい変数を宣言
整数私、atoi関数を呼び出します。

104
00:05:53,340 --> 00:06:01,160
私はnumは、私の文字列変数に渡し、
その後、私はその後、数50が含まれています。

105
00:06:01,160 --> 00:06:04,350
男を確認してください
ATOI機能のためのページ

106
00:06:04,350 --> 00:06:07,990
それはだどのライブラリをチェックします
で、だけでなく、それを大切にするもの

107
00:06:07,990 --> 00:06:14,550
文字列が渡された場合に返されます
中には、すべての数字が含まれていません。

108
00:06:14,550 --> 00:06:16,950
>> だから今我々が得ていること
キー、次のステップ

109
00:06:16,950 --> 00:06:19,430
ユーザから平文を取得することです。

110
00:06:19,430 --> 00:06:21,170
さて、これがために起こっています
それほど複雑で

111
00:06:21,170 --> 00:06:23,410
周りをナビゲートするよりも
コマンドライン引数。

112
00:06:23,410 --> 00:06:26,190
私たちがしなければならないのは、呼び出しです
GetString機能

113
00:06:26,190 --> 00:06:29,660
与えるために、ユーザを促します
私たちの文字列が、覚えています

114
00:06:29,660 --> 00:06:34,090
どのように我々の仕様をチェックします
そのためにユーザに要求することもできます。

115
00:06:34,090 --> 00:06:36,420
>> 今、私たちはに来て
problem--の心

116
00:06:36,420 --> 00:06:38,860
平文を暗号化する方法について説明します。

117
00:06:38,860 --> 00:06:42,830
さて、まず、の方法について話しましょう
一度に1文字を暗号化するために、

118
00:06:42,830 --> 00:06:47,370
し、我々はどのように対処します
全体の平文を反復処理。

119
00:06:47,370 --> 00:06:50,440
私はいくつかの擬似コードを書いています
シーザーの問題のために。

120
00:06:50,440 --> 00:06:52,310
私はになることをお勧め
同様にあなた自身を書きます。

121
00:06:52,310 --> 00:06:55,900
これは、同一の見ていない可能性があります
鉱山、それはOK、しかし限りです

122
00:06:55,900 --> 00:06:58,640
一般的な考え方と同じです。

123
00:06:58,640 --> 00:07:00,780
>> 最初の3つのステップ
我々はすでにやりました。

124
00:07:00,780 --> 00:07:03,100
私たちは、からキーを得ています
コマンドライン引数、

125
00:07:03,100 --> 00:07:05,510
私たちは、そのキーを回してきました
整数に、私たちはしました

126
00:07:05,510 --> 00:07:09,320
平文のためのユーザを促し
彼らは暗号化するしたいこと。

127
00:07:09,320 --> 00:07:12,420
それでは、次の大きなチャンク
それは、各文字のためのものです

128
00:07:12,420 --> 00:07:15,070
プレーンテキスト文字列で、
それはアルファベットだ場合、

129
00:07:15,070 --> 00:07:17,750
我々は維持したいです
その場合、それをシフトします。

130
00:07:17,750 --> 00:07:20,900
大文字と小文字を保持することにより、どのようなI
意味そのすべて大文字であります

131
00:07:20,900 --> 00:07:23,580
手紙は、上部ままにしてください
ケースとすべて小文字

132
00:07:23,580 --> 00:07:25,640
小文字のままにしてください。

133
00:07:25,640 --> 00:07:29,110
それでは、私たちはそれらをシフトした後、
その後、我々は暗号文を印刷します。

134
00:07:29,110 --> 00:07:33,100
>> ここで行っている3つの関数があります
この問題のために重宝します。

135
00:07:33,100 --> 00:07:38,010
私が与えた場合、上記のアップを忘れないでください
これをシフトするための例は、CS50のですか？

136
00:07:38,010 --> 00:07:41,800
覚えて50と
感嘆符がシフトしなかったのですか？

137
00:07:41,800 --> 00:07:45,680
だから我々は我々かどうかをどのように伝えることができます
手紙かどうかをシフトする必要がありますか？

138
00:07:45,680 --> 00:07:48,650
まあ、あれば」、アルファです」
あなたはそれの文字通過し、

139
00:07:48,650 --> 00:07:54,850
その文字場合にtrueを返します。
そうでない場合は、文字とfalseです。

140
00:07:54,850 --> 00:07:56,870
のお手伝いをするために、
大文字と小文字を保存します

141
00:07:56,870 --> 00:07:59,750
機能は "されています
上」と「下で」。

142
00:07:59,750 --> 00:08:03,350
>> これらの2つの機能は、また取ります
入力として単一の文字で

143
00:08:03,350 --> 00:08:06,580
そして、あなたのブールを返します
trueまたはfalse

144
00:08:06,580 --> 00:08:11,280
その文字かどうかに応じて
大文字または小文字です。

145
00:08:11,280 --> 00:08:14,610
「上で」と「であるため、
下の「ブール関数であり、

146
00:08:14,610 --> 00:08:18,660
彼らはあなたにブールを返すことを意味し、
あなたの条件にこれらを使用することができます。

147
00:08:18,660 --> 00:08:23,490
だからここのコードスニペットは、唯一のことです
それが大文字だ場合の文字を印刷します。

148
00:08:23,490 --> 00:08:27,790
だから、私は文字を宣言しました
文字は大文字にZEDします

149
00:08:27,790 --> 00:08:33,440
そしてその後、戻り、「上位である」場合
trueの場合、私はその文字を印刷します。

150
00:08:33,440 --> 00:08:38,200
>> 私たちの単純な例に戻って
2のキーでアルファベットをシフト、

151
00:08:38,200 --> 00:08:41,049
どのように我々は実際にそれが動作するのですか？

152
00:08:41,049 --> 00:08:45,770
まあ、それは文字ことが判明します
そして、整数は、非常に密接に関連しています。

153
00:08:45,770 --> 00:08:48,840
各文字は、持っています
関連する整数値

154
00:08:48,840 --> 00:08:53,260
それは、ASCIIチャートで見て、
ここで、各文字のASCII

155
00:08:53,260 --> 00:08:55,380
値が表示されます。

156
00:08:55,380 --> 00:08:58,940
だから、大文字のAの対応
65のASCII値に

157
00:08:58,940 --> 00:09:02,270
そして、小文字のaに
97のASCII値。

158
00:09:02,270 --> 00:09:04,940
>> ルックアップしてお気軽に
オンライン任意のASCIIチャート

159
00:09:04,940 --> 00:09:07,720
自分のためにこれらの値を確認します。

160
00:09:07,720 --> 00:09:12,096
それでは、これが意味する私たちができることです
大文字のAの文字を取り、

161
00:09:12,096 --> 00:09:18,200
それに整数2を追加し、取得
結果として、文字大文字のC。

162
00:09:18,200 --> 00:09:23,720
65ので、それは、ASCIIです
大文字のAの値は、プラス2、

163
00:09:23,720 --> 00:09:29,960
対応している、私たちに67を与えます
上部ケースCの文字へ

164
00:09:29,960 --> 00:09:33,480
>> 残念ながら、物事
それほど単純ではありません。

165
00:09:33,480 --> 00:09:36,980
私たちは、その方程式を持っています
我々が考えなければなりません。

166
00:09:36,980 --> 00:09:43,590
ここでは、i番目の暗号文を教えてくれる
手紙は、i番目の平文に対応します

167
00:09:43,590 --> 00:09:48,900
手紙、プラスkey--
そのすべて、モジュラー26。

168
00:09:48,900 --> 00:09:50,810
なぜそのような場合ですか？

169
00:09:50,810 --> 00:09:55,430
のから私たちの例に戻りましょう
前に、ここで、大文字のA、プラス2、

170
00:09:55,430 --> 00:09:57,590
資本C.は私たちに与えます

171
00:09:57,590 --> 00:10:01,870
>> その結果、式を適用すること
仕様は、私たちを与えます

172
00:10:01,870 --> 00:10:06,660
その後の資本Aを見てみましょう
2および26によってそのモッズプラス。

173
00:10:06,660 --> 00:10:10,730
私はそれを置くだから、大文字のA、
これらの単一引用符、

174
00:10:10,730 --> 00:10:14,010
私のようにそれを扱うことができます
整数なので、それが可能に

175
00:10:14,010 --> 00:10:17,500
私はそのASCII値、65にキャストします。

176
00:10:17,500 --> 00:10:20,080
65プラス2は67です。

177
00:10:20,080 --> 00:10:25,210
67モッズ26は、私たちに15を与えます
それは本当にありません

178
00:10:25,210 --> 00:10:32,590
私たちがいることを知っているので、意味をなします
資本CのASCII値は67、いない15です。

179
00:10:32,590 --> 00:10:35,580
それでは、どのよう我々はそれを調整しますか？

180
00:10:35,580 --> 00:10:39,840
>> さて、ここで私は断定したいのですが
アルファベット順のインデックスの概念。

181
00:10:39,840 --> 00:10:44,010
だから我々はすでに方法について説明しました
各文字は、そのASCII値を持ちます

182
00:10:44,010 --> 00:10:48,810
私はよく、してみましょう、言いたいです
各文字も持っていることについて考えます

183
00:10:48,810 --> 00:10:52,230
アルファベット順索引、
ここで、例えばA、

184
00:10:52,230 --> 00:10:58,800
アルファベットの最初の文字として、
ゼロのアルファベット順の索引があります。

185
00:10:58,800 --> 00:11:02,070
だから今のは適用でき
前と同じ式、

186
00:11:02,070 --> 00:11:05,040
しかし、アルファベット順の索引を使用して。

187
00:11:05,040 --> 00:11:07,810
>> 我々が定義したように、Aは、ゼロです。

188
00:11:07,810 --> 00:11:15,640
それでは、ゼロプラス2、モッズ26を取って、
それは私たちに2を与える2、モッズ26、です。

189
00:11:15,640 --> 00:11:18,780
よく、の観点から
アルファベット順索引、

190
00:11:18,780 --> 00:11:23,930
Cは中3番目の文字であります
アルファベット、そのためには、対応するであろう

191
00:11:23,930 --> 00:11:26,290
2のアルファベット順のインデックスに。

192
00:11:26,290 --> 00:11:29,850
だから、使用しているようです
この場合のアルファベット順索引

193
00:11:29,850 --> 00:11:32,840
実際に私たちに正しい結果を与えます。

194
00:11:32,840 --> 00:11:35,020
>> だから今のは、にチェックしてみましょう
式が動作するかどうかを確認

195
00:11:35,020 --> 00:11:37,210
アルファベット順のインデックスを持ちます。

196
00:11:37,210 --> 00:11:42,540
Yのアルファベット順のインデックスは、24であります
アルファベットの最後の文字に2番目。

197
00:11:42,540 --> 00:11:46,520
それでは、24プラス、当社
2の鍵は、私たちに26を与えます。

198
00:11:46,520 --> 00:11:54,750
26モッズ26は私たちに0、のために、幸運を与えます
私たちは、Aのアルファベット順の索引です

199
00:11:54,750 --> 00:11:59,100
だから、うまくいけば、それは十分な証拠です
アルファベット順のインデックスメソッドが動作します。

200
00:11:59,100 --> 00:12:03,180
ない場合は、試してみるお気軽に
あなた自身のいくつかの例。

201
00:12:03,180 --> 00:12:08,030
>> 適切に包み込むために、
アルファベットとシーザー方程式を適用し、

202
00:12:08,030 --> 00:12:11,280
その後、我々は我々がする必要があることを知っています
アルファベット順のインデックスを扱います。

203
00:12:11,280 --> 00:12:15,130
しかし、我々は、ASCIIで始まります
のみ、値、および

204
00:12:15,130 --> 00:12:18,530
私たちは、その後に変換ん
アルファベット順の索引。

205
00:12:18,530 --> 00:12:23,970
そこから、印刷するために、我々は、必要
再びASCII値に対処します。

206
00:12:23,970 --> 00:12:28,350
だから我々はどのように把握する必要があり
アルファベット順ASCIIから行きます

207
00:12:28,350 --> 00:12:31,080
アルファベットからASCIIへ。

208
00:12:31,080 --> 00:12:34,910
>> だから私は把握するあなたにそれを残します
文字間のパターン

209
00:12:34,910 --> 00:12:38,590
そのアルファベット
指標とそのASCII値。

210
00:12:38,590 --> 00:12:41,530
今、たとえていることを覚えています
スライド上で、この表の右側

211
00:12:41,530 --> 00:12:45,630
我々はまた、大文字を示しています
かどうかを検討する必要があります

212
00:12:45,630 --> 00:12:48,915
異なるパターンが適用されます
小文字用。

213
00:12:48,915 --> 00:12:52,070

214
00:12:52,070 --> 00:12:55,840
>> だから今我々が考え出したこと
単一の文字をシフトする方法、

215
00:12:55,840 --> 00:13:02,200
その後、私たちがしなければならないすべては、スケールがあること
全体の平文を渡るまでの。

216
00:13:02,200 --> 00:13:04,260
だから、平文は文字列です。

217
00:13:04,260 --> 00:13:08,210
私たちにとってラッキー、文字列が実際にあります
文字の配列だけ、

218
00:13:08,210 --> 00:13:12,150
ので、すべての文字にアクセスするために
文字列の、すべてあなたがしなければなりません

219
00:13:12,150 --> 00:13:14,270
配列表記を使用することです。

220
00:13:14,270 --> 00:13:20,270
私は型の変数を持っていると言います
文字列」テキストは= 'これはCS50です。」」

221
00:13:20,270 --> 00:13:22,730
>> さて、その後、順番にへ
各文字にアクセスし、

222
00:13:22,730 --> 00:13:25,880
私がしなければならないすべて
変数テキストです

223
00:13:25,880 --> 00:13:31,660
ことを、よくインデックスゼロでテキストを避けます
インデックスでは、大文字のTテキストに対応

224
00:13:31,660 --> 00:13:35,100
1は、小文字のhに相当します。

225
00:13:35,100 --> 00:13:38,110
別の有用な機能です
文字列の長さの関数。

226
00:13:38,110 --> 00:13:40,760
だからに文字列を渡します
その関数は戻ります

227
00:13:40,760 --> 00:13:44,610
整数、その​​文字列の長さ。

228
00:13:44,610 --> 00:13:47,060
>> 今、私たちは約話したこと
すべてのこれらの異なる要素、

229
00:13:47,060 --> 00:13:48,540
それでは、それらを一緒に戻しましょう​​。

230
00:13:48,540 --> 00:13:52,210
だから私の擬似コードのいずれかに戻ります
コー​​ドまたはあなたの擬似コード

231
00:13:52,210 --> 00:13:55,920
貫​​通行くと必ずことを確認
一つ一つのことを行う方法を知っています。

232
00:13:55,920 --> 00:14:01,520
argcとargvのを使用してキーを取得します、
整数にキーを回し、A

233
00:14:01,520 --> 00:14:06,840
私に、平文の入力を求めます、
GetStringメソッド、およびその後反復

234
00:14:06,840 --> 00:14:09,590
内のすべての文字を超えます
平文の文字列、

235
00:14:09,590 --> 00:14:14,910
各文字の大文字と小文字を保存します
そしてキーでその文字をシフト、

236
00:14:14,910 --> 00:14:17,520
あなたがしていることを確実にすること
アルファベットの周りに巻き付け、

237
00:14:17,520 --> 00:14:20,850
最終的にはその暗号文を印刷します。

238
00:14:20,850 --> 00:14:25,470
私の名前はAmilaであり、これはシーザーでした。

239
00:14:25,470 --> 00:14:28,448

