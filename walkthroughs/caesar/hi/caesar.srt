1
00:00:00,000 --> 00:00:00,760

2
00:00:00,760 --> 00:00:02,270
>> Amila: चलो कैसर से निपटने।

3
00:00:02,270 --> 00:00:06,110
सीज़र में, हम उपयोगकर्ता की अनुमति
एक गुप्त संदेश सांकेतिक शब्दों में बदलना।

4
00:00:06,110 --> 00:00:09,780
तो चलो सही में गोता करते हैं और देखो
इस समस्या के लिए हमारे डॉस पर।

5
00:00:09,780 --> 00:00:12,210
तो सबसे पहले, हम उपयोगकर्ता से कुंजी मिलता है।

6
00:00:12,210 --> 00:00:15,210
तो फिर हम प्लेन मिल
वे सांकेतिक शब्दों में बदलना चाहते हैं।

7
00:00:15,210 --> 00:00:21,380
उसके बाद, हम यह उनके लिए कूटलेखन,
और अंत में हम उनकी सिफर प्रिंट।

8
00:00:21,380 --> 00:00:23,600
>> तो चलो एक उदाहरण के साथ शुरू करते हैं।

9
00:00:23,600 --> 00:00:26,920
आप सांकेतिक शब्दों में बदलना चाहता था
दो में से एक कुंजी के साथ पूरी वर्णमाला।

10
00:00:26,920 --> 00:00:31,360
खैर, अपने पूरे वर्णमाला होगा
सिर्फ पत्र के लिए स्थानांतरित कर दिया।

11
00:00:31,360 --> 00:00:37,060
तो एक के लिए सी, बी सांकेतिक शब्दों में बदलना होगा
डी, सी ई करने के लिए, इतने पर और बहुत आगे है,

12
00:00:37,060 --> 00:00:42,470
जब तक आप एक्स, जो Z करने के लिए कूटबद्ध करने के लिए मिलता है
या जेड, तुम कहाँ से हो पर निर्भर करता है।

13
00:00:42,470 --> 00:00:47,445
तो y तो सभी तरह से बदलाव होगा,
वर्णमाला के आसपास लपेटो एक को पाने के लिए,

14
00:00:47,445 --> 00:00:53,256
और फिर अंत का अंतिम पत्र
वर्णमाला, जेड, जेड, बी सांकेतिक शब्दों में बदलना होगा

15
00:00:53,256 --> 00:00:54,660
>> तुम्हें वह मिल गया?

16
00:00:54,660 --> 00:00:56,380
कुछ उदाहरणों पर नजर डालते हैं।

17
00:00:56,380 --> 00:01:00,540
यहां पहला उदाहरण बहुत समान है
क्या हम सिर्फ ऊपर बताया गया है।

18
00:01:00,540 --> 00:01:05,560
तो अगर मैं के कुछ खंड सांकेतिक शब्दों में बदलना
वर्णमाला, ए एल के माध्यम से, दो में से एक प्रमुख द्वारा,

19
00:01:05,560 --> 00:01:09,760
तो मैं सिर्फ अपने पूरे मिलता है
वर्णमाला दो पत्र स्थानांतरित कर दिया।

20
00:01:09,760 --> 00:01:12,230
>> फिर, मेरे अगले उदाहरण में,
कुंजी अभी भी दो है,

21
00:01:12,230 --> 00:01:15,080
तो आप अभी भी पता होना चाहिए
जो पत्र की उम्मीद है।

22
00:01:15,080 --> 00:01:16,400
लेकिन यहाँ यह एक मुहावरा है।

23
00:01:16,400 --> 00:01:18,100
इस CS50 है।

24
00:01:18,100 --> 00:01:21,090
तो आपको लगता है कि मैं नोटिस देंगे
मेरे पत्र के मामले की रक्षा,

25
00:01:21,090 --> 00:01:25,600
इसलिए किसी भी ऊपरी मामले पत्र भी कर रहे हैं
सिफर में ऊपरी मामले पत्र।

26
00:01:25,600 --> 00:01:27,800
और किसी भी लोअरकेस
प्लेन में पत्र

27
00:01:27,800 --> 00:01:30,640
यह भी लोअरकेस हैं
सिफर में पत्र।

28
00:01:30,640 --> 00:01:34,020
लेकिन मैं पत्र रखने के
और किसी भी विस्मयादिबोधक चिह्न

29
00:01:34,020 --> 00:01:37,610
या किसी अन्य विराम ही है।

30
00:01:37,610 --> 00:01:40,360
>> तो अब हम एक भावना है कि
कैसे कार्यक्रम काम करता है के लिए,

31
00:01:40,360 --> 00:01:43,890
चलाने के कुछ और जाने के लिए स्वतंत्र महसूस हो रहा है
अपने स्वयं के उदाहरण हैं, आप चाहते हैं।

32
00:01:43,890 --> 00:01:47,072
के साथ हो रही शुरू करते हैं
उपयोगकर्ता से कुंजी।

33
00:01:47,072 --> 00:01:48,780
परंपरागत रूप से, के साथ
अन्य समस्याओं, हम है

34
00:01:48,780 --> 00:01:51,450
हो रही करने के आदी किया गया
कि किसी भी संख्या हम

35
00:01:51,450 --> 00:01:54,710
उपयोगकर्ता उत्साह से की जरूरत है
समारोह GetInt के साथ।

36
00:01:54,710 --> 00:01:58,850
लेकिन इस बार हम वास्तव में जा रहे हैं
कमांड लाइन तर्क का उपयोग करने के लिए

37
00:01:58,850 --> 00:02:01,760
और एक नया समारोह atoi बुलाया।

38
00:02:01,760 --> 00:02:05,130
>> आप मुख्य चलाते हैं
सी में प्रोग्राम, तो यह

39
00:02:05,130 --> 00:02:08,500
दो parameters-- में ले जाता है
int argc, जो

40
00:02:08,500 --> 00:02:11,670
तर्क की संख्या है
में पारित कर दिया, और उसके बाद

41
00:02:11,670 --> 00:02:15,920
argv, तारों की एक सरणी शामिल हैं जो
तर्क के सभी की सूची

42
00:02:15,920 --> 00:02:16,740
बीतने के।

43
00:02:16,740 --> 00:02:19,740
आप स्पष्ट की जरूरत नहीं है
इन चर घोषित करने के लिए।

44
00:02:19,740 --> 00:02:22,700
वे के लिए गणना कर रहे हैं
संकलक द्वारा आप।

45
00:02:22,700 --> 00:02:28,160
इस के लिए सही उपयोग होगा
argc इस मामले में दो होने के लिए,

46
00:02:28,160 --> 00:02:32,630
उपयोगकर्ता में पारित करने के लिए है क्योंकि
कार्यक्रम के लिए कॉल, ./caesar,

47
00:02:32,630 --> 00:02:35,570
और फिर कुंजी,
जो संख्या में वे चाहते हैं।

48
00:02:35,570 --> 00:02:39,920
तो इसका मतलब है कि argc होना चाहिए दो
सीजर की एक वैध उपयोग के लिए आदेश में

49
00:02:39,920 --> 00:02:41,680
निष्पादित किए जाने के लिए।

50
00:02:41,680 --> 00:02:43,590
>> तो चलो एक उदाहरण को देखो।

51
00:02:43,590 --> 00:02:47,760
मैं पहले से ही लिखा है कहो और
एक कार्यक्रम चालू बुलाया संकलित।

52
00:02:47,760 --> 00:02:52,670
तो अगर मैं कमांड लाइन में दौड़ा
./blastoff टीम रॉकेट, ठीक है, तो,

53
00:02:52,670 --> 00:02:57,750
argc तीन हो सकता है क्योंकि मैं
तीन अलग बहस में पारित कर दिया।

54
00:02:57,750 --> 00:02:59,830
तब argv इस तरह दिखेगा।

55
00:02:59,830 --> 00:03:03,750
यह एक सरणी है, और यह होगा
तीन तार में से प्रत्येक के होते हैं।

56
00:03:03,750 --> 00:03:09,640
पहले सूचकांक, टीम में ./blastoff
बगल में है, और अंत में रॉकेट में।

57
00:03:09,640 --> 00:03:11,610
>> के एक सेकंड के लिए सरणियों के बारे में बात करते हैं।

58
00:03:11,610 --> 00:03:15,560
सारणियों डेटा संरचनाओं कि पकड़ रहे हैं
एक ही प्रकार के एकाधिक मानों।

59
00:03:15,560 --> 00:03:19,980
जब हम इस काम में आ सकता है
पूर्णांकों या तार की सूची है।

60
00:03:19,980 --> 00:03:23,030
बस याद है वे हैं
एक ही प्रकार का हो सकता है।

61
00:03:23,030 --> 00:03:25,310
कंप्यूटर विज्ञान में, हम
शून्य से गिनती प्यार करता हूँ,

62
00:03:25,310 --> 00:03:29,260
इतना याद है कि सरणियों
यह भी शून्य अनुक्रमित रहे हैं।

63
00:03:29,260 --> 00:03:34,360
अपने सरणी के पहले तत्व तो
सूचकांक शून्य पर होने जा रहा है।

64
00:03:34,360 --> 00:03:37,580
तो इस मामले में, जब मेरे पास है
लंबाई चार की एक सरणी,

65
00:03:37,580 --> 00:03:41,350
तब के अंतिम सूचकांक
अपने सरणी के अंतिम तत्व

66
00:03:41,350 --> 00:03:44,970
वास्तव में होने जा रहा है
सूचकांक तीन, चार पर।

67
00:03:44,970 --> 00:03:48,880
क्योंकि याद है, हम
शून्य पर गिनती शुरू।

68
00:03:48,880 --> 00:03:52,530
>> यहाँ आप कैसे का एक उदाहरण है
अपनी खुद की एक सरणी बना सकता है।

69
00:03:52,530 --> 00:03:56,440
तो मैं दुकान करना चाहते थे कहना है कि मेरे
तीन पसंदीदा कुत्ते के नाम।

70
00:03:56,440 --> 00:03:59,030
तब मैं तारों की एक सरणी पैदा होगा।

71
00:03:59,030 --> 00:04:04,450
तो मैं प्रकार, स्ट्रिंग घोषित होगा, और
तब सरणी के नाम पर रखा, कुत्तों,

72
00:04:04,450 --> 00:04:06,450
और फिर उन वर्ग में
कोष्ठक आकार डाल

73
00:04:06,450 --> 00:04:09,260
इस मामले में, तीन में array-- की।

74
00:04:09,260 --> 00:04:12,690
>> इसलिए मेरी पहली प्रविष्टि जा रहा है
सूचकांक शून्य पर कुत्तों को हो सकता है,

75
00:04:12,690 --> 00:04:14,750
और उस मिलो होने जा रहा है।

76
00:04:14,750 --> 00:04:17,850
तो सूचकांक एक में कुत्तों
नासमझ होने जा रहा है,

77
00:04:17,850 --> 00:04:23,060
प्रिय मोची, और फिर पिछले
प्रविष्टि, सूचकांक दो में तीसरी प्रविष्टि,

78
00:04:23,060 --> 00:04:26,130
प्यारा, मिठाई Elphie होने जा रहा है।

79
00:04:26,130 --> 00:04:28,610
तुम्हें पता है कि प्रारूप पर ध्यान देंगे
इस सरणी में भरने के लिए

80
00:04:28,610 --> 00:04:32,150
जैसे आप कैसे हो सकता है बहुत ज्यादा है
किसी भी अन्य चर जहां घोषित

81
00:04:32,150 --> 00:04:36,307
आप चर नाम से पीछा किया है
मूल्य है कि आप इसे में संग्रहीत करना चाहते हैं।

82
00:04:36,307 --> 00:04:38,140
में फर्क सिर्फ इतना है
इस मामले में है कि आप है

83
00:04:38,140 --> 00:04:42,700
सूचकांक डाल करने के लिए याद करने की जरूरत
वर्ग कोष्ठक में मूल्य का।

84
00:04:42,700 --> 00:04:46,420
और वहाँ हम हमारे राशि
तीन पसंदीदा कुत्तों।

85
00:04:46,420 --> 00:04:48,780
>> लेकिन अफसोस, यह समय है
वापस कैसर को पाने के लिए।

86
00:04:48,780 --> 00:04:52,910
याद रखें कि सही उपयोग
उपयोगकर्ता न केवल में पारित होने के लिए जा रहा है

87
00:04:52,910 --> 00:04:57,430
कार्यक्रम ./caesar का नाम है, लेकिन
यह भी महत्वपूर्ण है कि वे बदलाव चाहते हैं

88
00:04:57,430 --> 00:04:58,850
द्वारा उनके प्लेन।

89
00:04:58,850 --> 00:05:01,540
तो इसका मतलब है कि argc दो होना चाहिए।

90
00:05:01,540 --> 00:05:07,580
वे two-- कोई और अधिक में देनी होगी कोई
दो कमांड लाइन तर्क से भी कम है।

91
00:05:07,580 --> 00:05:09,050
>> अब, argv के बारे में क्या?

92
00:05:09,050 --> 00:05:12,880
ठीक है, हम पहले से ही जानते हैं कि
सरणी, लंबाई दो से होने जा रहा है

93
00:05:12,880 --> 00:05:15,270
लेकिन क्या प्रत्येक तत्व में निहित है?

94
00:05:15,270 --> 00:05:19,330
खैर, सबसे पहले तत्व
./caesar होने जा रहा है,

95
00:05:19,330 --> 00:05:24,190
और फिर अगले तत्व जा रहा है
महत्वपूर्ण यह है कि उपयोगकर्ता में टाइप होते हैं।

96
00:05:24,190 --> 00:05:27,480
अब, अगर वे इसे सही ढंग से इस्तेमाल किया
सीज़र के उपयोग के लिए,

97
00:05:27,480 --> 00:05:29,350
फिर वे एक संख्या में टाइप करने के लिए जा रहे हैं।

98
00:05:29,350 --> 00:05:33,260
लेकिन फिर भी चरित्र यद्यपि
वे प्रकार है कि एक संख्या है,

99
00:05:33,260 --> 00:05:35,790
यह डेटा प्रकार स्ट्रिंग की है।

100
00:05:35,790 --> 00:05:40,390
>> तो हम कैसे परिवर्तित करते हैं कि
एक पूर्णांक के लिए स्ट्रिंग?

101
00:05:40,390 --> 00:05:46,680
तो कहते हैं कि मैं NUM है, एक स्ट्रिंग,
स्ट्रिंग 50 से युक्त।

102
00:05:46,680 --> 00:05:49,000
मैं परिवर्तित करने के लिए कि चाहते हैं
एक पूर्णांक के लिए, तो मैं बस

103
00:05:49,000 --> 00:05:53,340
एक नया चर घोषित, एक
मैं पूर्णांक, atoi बुला रही है।

104
00:05:53,340 --> 00:06:01,160
मैं अपने स्ट्रिंग चर में पारित, संख्या, और
तो मैं तो नंबर 50 में शामिल होंगे।

105
00:06:01,160 --> 00:06:04,350
बनाओ आदमी की जांच कर लें
atoi समारोह के लिए पृष्ठों

106
00:06:04,350 --> 00:06:07,990
जो पुस्तकालय यह जाँच करने के लिए
में, साथ ही क्या यह मान के रूप में

107
00:06:07,990 --> 00:06:14,550
यदि स्ट्रिंग पारित कर वापस आ जाएगी
में सभी नंबरों को शामिल नहीं करता है।

108
00:06:14,550 --> 00:06:16,950
>> तो अब है कि हम मिल गया है
कुंजी, अगले कदम

109
00:06:16,950 --> 00:06:19,430
उपयोगकर्ता से प्लेन को मिल रहा है।

110
00:06:19,430 --> 00:06:21,170
अब, यह करने के लिए जा रहा है
कम जटिल हो

111
00:06:21,170 --> 00:06:23,410
आसपास नेविगेट से
कमांड लाइन तर्क।

112
00:06:23,410 --> 00:06:26,190
हम सभी को करना है फोन है
GetString समारोह

113
00:06:26,190 --> 00:06:29,660
देने के लिए उपयोगकर्ता संकेत करने के लिए
हमें एक स्ट्रिंग है, लेकिन याद

114
00:06:29,660 --> 00:06:34,090
के लिए कैसे विशिष्टताओं की जांच करने के लिए हम
इसके लिए उपयोगकर्ता संकेत करने के लिए चाहते हो सकता है।

115
00:06:34,090 --> 00:06:36,420
>> अब हम करने के लिए आ
problem-- का दिल

116
00:06:36,420 --> 00:06:38,860
कैसे प्लेन कूटलेखन के लिए।

117
00:06:38,860 --> 00:06:42,830
खैर, सबसे पहले, के बारे में कैसे बात करते हैं
एक समय में एक चरित्र कूटलेखन के लिए,

118
00:06:42,830 --> 00:06:47,370
और फिर हम कैसे को संबोधित करेंगे
पूरे प्लेन पर पुनरावृति।

119
00:06:47,370 --> 00:06:50,440
मैं कुछ pseudocode लिखा है
सीजर की समस्या के लिए।

120
00:06:50,440 --> 00:06:52,310
मैं तुम्हें करने के लिए प्रोत्साहित
अपने खुद के रूप में अच्छी तरह से लिखते हैं।

121
00:06:52,310 --> 00:06:55,900
यह करने के लिए समान नहीं लग सकता है
मेरा है, और कहा कि ठीक है, लेकिन जब तक है

122
00:06:55,900 --> 00:06:58,640
सामान्य विचार के रूप में ही है।

123
00:06:58,640 --> 00:07:00,780
>> पहले तीन चरणों
हम पहले से ही किया है।

124
00:07:00,780 --> 00:07:03,100
हम से चाबी मिल गया है
कमांड लाइन तर्क है,

125
00:07:03,100 --> 00:07:05,510
हम उस कुंजी बदल दिया है
एक पूर्णांक में, और हम है

126
00:07:05,510 --> 00:07:09,320
प्लेन के लिए उपयोगकर्ता के लिए प्रेरित किया
वे कूटलेखन के लिए चाहते हैं।

127
00:07:09,320 --> 00:07:12,420
तो फिर अगले बड़ा हिस्सा
कि हर किरदार के लिए है

128
00:07:12,420 --> 00:07:15,070
सादा पाठ स्ट्रिंग में,
यह वर्णमाला है, तो

129
00:07:15,070 --> 00:07:17,750
हम रक्षा करना चाहते हैं
इसकी मामला है और यह बदलाव।

130
00:07:17,750 --> 00:07:20,900
द्वारा मामले की रक्षा, क्या मैं
इसका मतलब यह है ऊपरी मामले में है कि

131
00:07:20,900 --> 00:07:23,580
पत्र ऊपरी रहना चाहिए
मामला है और सभी छोटे अक्षरों

132
00:07:23,580 --> 00:07:25,640
लोअरकेस रहना चाहिए।

133
00:07:25,640 --> 00:07:29,110
तो फिर उसके बाद हम उन पाली,
फिर हम सिफर प्रिंट।

134
00:07:29,110 --> 00:07:33,100
>> यहाँ तीन कार्य करता है कि जा रहे हैं
इस समस्या के लिए काम में आने के लिए।

135
00:07:33,100 --> 00:07:38,010
ऊपर जब मैं दे दिया अप याद रखें
इस स्थानांतरण के लिए उदाहरण CS50 है?

136
00:07:38,010 --> 00:07:41,800
याद रखें कि 50 और
विस्मयादिबोधक चिह्न बदलाव नहीं किया?

137
00:07:41,800 --> 00:07:45,680
इसलिए हम चाहे हम कैसे बता सकते हैं
एक पत्र नहीं पाली या करने की जरूरत है?

138
00:07:45,680 --> 00:07:48,650
वैसे, अगर "अल्फा है,"
आप इसे एक चरित्र से गुजरती हैं,

139
00:07:48,650 --> 00:07:54,850
यदि उस चरित्र सच में वापस आ जाएगी
एक पत्र और झूठे अन्यथा है।

140
00:07:54,850 --> 00:07:56,870
के साथ आप मदद करने के लिए
संरक्षण पूंजीकरण

141
00:07:56,870 --> 00:07:59,750
कार्य कर रहे हैं "है
ऊपरी "और" कम है। "

142
00:07:59,750 --> 00:08:03,350
>> इन दोनों कार्यों को भी पकड़ लिया
इनपुट के रूप में एक ही चरित्र में

143
00:08:03,350 --> 00:08:06,580
और आप एक बूलियन वापसी,
या तो सही है या गलत

144
00:08:06,580 --> 00:08:11,280
क्या है कि चरित्र पर निर्भर करता है
ऊपरी या निचले मामले मामला है।

145
00:08:11,280 --> 00:08:14,610
क्योंकि "ऊपरी है" और "है
कम "बूलियन कार्य कर रहे हैं,

146
00:08:14,610 --> 00:08:18,660
जिसका अर्थ है कि वे तुम्हें एक बूलियन वापसी,
आप अपनी परिस्थितियों में इन का उपयोग कर सकते हैं।

147
00:08:18,660 --> 00:08:23,490
तो यहाँ कोड का एक टुकड़ा है कि केवल
एक पत्र प्रिंट अगर यह ऊपरी मामला है।

148
00:08:23,490 --> 00:08:27,790
तो मैं अपने चरित्र घोषित कर दिया है
पत्र ऊपरी मामले जेड जा करने के लिए

149
00:08:27,790 --> 00:08:33,440
और फिर अगर रिटर्न "ऊपरी है"
यह सच है, तो मैं उस पत्र मुद्रित।

150
00:08:33,440 --> 00:08:38,200
>> के बारे में हमारी सरल उदाहरण के लिए वापस जा रहे हैं
दो में से एक प्रमुख द्वारा वर्णमाला स्थानांतरण,

151
00:08:38,200 --> 00:08:41,049
कैसे हम वास्तव में है कि काम करने के लिए मिलता है?

152
00:08:41,049 --> 00:08:45,770
खैर, यह है कि पात्रों को पता चला है
और पूर्णांकों बहुत निकट से संबंधित हैं।

153
00:08:45,770 --> 00:08:48,840
प्रत्येक चरित्र एक है
जुड़े पूर्णांक मान

154
00:08:48,840 --> 00:08:53,260
यह ASCII चार्ट में पाया के साथ,
जहां प्रत्येक चरित्र के ASCII

155
00:08:53,260 --> 00:08:55,380
मूल्य प्रदर्शित किया जाता है।

156
00:08:55,380 --> 00:08:58,940
तो एक ऊपरी मामले एक मेल खाती है
65 वर्ष की एक ASCII मूल्य के लिए

157
00:08:58,940 --> 00:09:02,270
और एक छोटे से एक के लिए
97 में से एक ASCII मूल्य।

158
00:09:02,270 --> 00:09:04,940
>> देखने के लिए स्वतंत्र महसूस
किसी भी ASCII चार्ट ऑनलाइन

159
00:09:04,940 --> 00:09:07,720
खुद के लिए इन मूल्यों को देखने के लिए।

160
00:09:07,720 --> 00:09:12,096
तो क्या इसका मतलब यह है कि हम यह कर सकते हैं वह यह है कि
, ऊपरी मामले एक के चरित्र लेने

161
00:09:12,096 --> 00:09:18,200
यह करने के लिए पूर्णांक दो जोड़ने के लिए, और उसके बाद मिलता है
एक परिणाम के रूप में चरित्र ऊपरी मामले सी।

162
00:09:18,200 --> 00:09:23,720
वजह यह है कि 65, ASCII है
राजधानी में एक के लिए मूल्य, प्लस 2,

163
00:09:23,720 --> 00:09:29,960
हमें 67 देता है, जो मेल खाती है
ऊपरी मामले सी के चरित्र को

164
00:09:29,960 --> 00:09:33,480
>> दुर्भाग्य से, चीजें
काफी इतना आसान नहीं होगा।

165
00:09:33,480 --> 00:09:36,980
हम एक समीकरण है
हम पर विचार किया है।

166
00:09:36,980 --> 00:09:43,590
यहाँ यह है कि हमें बताता है ith सिफर
पत्र ith प्लेन से मेल खाती है

167
00:09:43,590 --> 00:09:48,900
पत्र, प्लस key--
मॉड्यूलर है कि सभी 26।

168
00:09:48,900 --> 00:09:50,810
वह मामला क्या है?

169
00:09:50,810 --> 00:09:55,430
से हमारे उदाहरण के लिए वापस जाओ
इससे पहले, जहां पूंजी ए, प्लस 2,

170
00:09:55,430 --> 00:09:57,590
अमेरिका की राजधानी सी देता है

171
00:09:57,590 --> 00:10:01,870
>> तो समीकरण है कि आवेदन करने वाले
विनिर्देश हमें देता है,

172
00:10:01,870 --> 00:10:06,660
उसके बाद की राजधानी में एक ले चलो
2 और कहा कि 26 से आधुनिक प्लस।

173
00:10:06,660 --> 00:10:10,730
तो राजधानी ए, जब मैं इसे में डाल
उन एकल उद्धरण चिह्न,

174
00:10:10,730 --> 00:10:14,010
मुझे यह रूप में व्यवहार करने के लिए अनुमति देता है
एक पूर्णांक है, ताकि अनुमति देता है

175
00:10:14,010 --> 00:10:17,500
मुझे यह अपने ASCII मूल्य, 65 के लिए डाली।

176
00:10:17,500 --> 00:10:20,080
65 प्लस 2 67 है।

177
00:10:20,080 --> 00:10:25,210
67 आधुनिक 26 हमें 15 देता है,
लेकिन लगता है कि वास्तव में नहीं है

178
00:10:25,210 --> 00:10:32,590
समझ बनाने के लिए है क्योंकि हम जानते हैं कि
राजधानी सी ASCII मूल्य 67, 15 नहीं है।

179
00:10:32,590 --> 00:10:35,580
तो हम कैसे सामंजस्य है?

180
00:10:35,580 --> 00:10:39,840
>> वैसे, यहाँ मैं मंज़ूर करना चाहते हैं
एक वर्णमाला सूचकांक की धारणा।

181
00:10:39,840 --> 00:10:44,010
इसलिए हम पहले से ही के बारे में कैसे बात की है
हर किरदार अपने ASCII मूल्य है,

182
00:10:44,010 --> 00:10:48,810
लेकिन मैं कहना ठीक है, चलो चलो चाहूँगा
हर किरदार भी होने के बारे में सोचते हैं

183
00:10:48,810 --> 00:10:52,230
एक वर्णमाला सूचकांक,
जहां एक उदाहरण के लिए,

184
00:10:52,230 --> 00:10:58,800
वर्णमाला के पहले अक्षर के रूप में,
शून्य की एक वर्णमाला सूचकांक है।

185
00:10:58,800 --> 00:11:02,070
तो अब लागू होते हैं
एक ही समीकरण के रूप में पहले,

186
00:11:02,070 --> 00:11:05,040
लेकिन एक वर्णमाला सूचकांक का उपयोग कर।

187
00:11:05,040 --> 00:11:07,810
>> तो एक शून्य, के रूप में हम परिभाषित किया गया है।

188
00:11:07,810 --> 00:11:15,640
तो फिर शून्य प्लस दो, आधुनिक 26 ले रही है,
कि दो, आधुनिक 26 है, जो हमें दो देता है।

189
00:11:15,640 --> 00:11:18,780
और अच्छी तरह से करने के मामले में
एक वर्णमाला सूचकांक,

190
00:11:18,780 --> 00:11:23,930
सी में तीसरे पत्र है
वर्णमाला, इतना है कि अनुरूप होगा

191
00:11:23,930 --> 00:11:26,290
दो में से एक वर्णमाला सूचकांक करने के लिए।

192
00:11:26,290 --> 00:11:29,850
तो यह है कि प्रयोग लगती है
इस मामले में वर्णमाला सूचकांक

193
00:11:29,850 --> 00:11:32,840
वास्तव में हमें सही परिणाम देता है।

194
00:11:32,840 --> 00:11:35,020
>> तो अब जाँच जाने के लिए
यदि समीकरण कामों को देखकर

195
00:11:35,020 --> 00:11:37,210
एक वर्णमाला सूचकांक के साथ।

196
00:11:37,210 --> 00:11:42,540
वाई वर्णमाला सूचकांक 24 के रूप में है
वर्णमाला में अंतिम पत्र के लिए दूसरा।

197
00:11:42,540 --> 00:11:46,520
तो फिर 24 प्लस हमारे
दो की कुंजी हमें 26 देता है।

198
00:11:46,520 --> 00:11:54,750
26 आधुनिक 26 अमेरिकी 0, जो, के लिए भाग्यशाली देता है
हमें, ए के लिए वर्णमाला सूचकांक है

199
00:11:54,750 --> 00:11:59,100
तो उम्मीद है कि पर्याप्त है कि सबूत है
वर्णमाला सूचकांक विधि काम करता है।

200
00:11:59,100 --> 00:12:03,180
यदि नहीं, तो बाहर की कोशिश करने के लिए स्वतंत्र महसूस हो रहा है
अपने स्वयं के कुछ उदाहरण हैं।

201
00:12:03,180 --> 00:12:08,030
>> क्रम में ठीक से आसपास लपेटो करने के लिए
वर्णमाला और सीज़र समीकरण लागू होते हैं,

202
00:12:08,030 --> 00:12:11,280
तो हम जानते हैं कि हम करने की जरूरत है
वर्णमाला सूचकांकों के साथ सौदा।

203
00:12:11,280 --> 00:12:15,130
लेकिन हम ASCII के साथ शुरू
मूल्यों, और उसके बाद ही

204
00:12:15,130 --> 00:12:18,530
हम तो करने के लिए परिवर्तित करते हैं
वर्णमाला सूचकांक।

205
00:12:18,530 --> 00:12:23,970
वहाँ से, करने के लिए प्रिंटर, हम की जरूरत है
फिर ASCII मूल्यों के साथ सौदा करने के लिए।

206
00:12:23,970 --> 00:12:28,350
तो हम कैसे यह पता लगाने की जरूरत है
वर्णमाला के लिए ASCII से जाना

207
00:12:28,350 --> 00:12:31,080
और वर्णमाला से ASCII करने के लिए।

208
00:12:31,080 --> 00:12:34,910
>> तो मैं इसे आप के लिए छोड़ बाहर निकालने के लिए
एक चरित्र के बीच पैटर्न

209
00:12:34,910 --> 00:12:38,590
और उसके वर्णमाला
सूचकांक और अपने ASCII मूल्य।

210
00:12:38,590 --> 00:12:41,530
अब, याद है कि भले ही
स्लाइड पर इस तालिका सही

211
00:12:41,530 --> 00:12:45,630
यह भी राजधानी पत्र से पता चलता है, हम
चाहे या नहीं पर विचार किया है

212
00:12:45,630 --> 00:12:48,915
एक अलग पैटर्न लागू होता है
कम मामले पात्रों के लिए।

213
00:12:48,915 --> 00:12:52,070

214
00:12:52,070 --> 00:12:55,840
>> तो अब है कि हम पता लगा लिया है
एक ही चरित्र को शिफ्ट करने के लिए कैसे,

215
00:12:55,840 --> 00:13:02,200
तो सब हमें क्या करना है पैमाने पर है कि
पूरे प्लेन के पार जाने के लिए।

216
00:13:02,200 --> 00:13:04,260
तो प्लेन एक स्ट्रिंग है।

217
00:13:04,260 --> 00:13:08,210
हमारे लिए भाग्यशाली, एक स्ट्रिंग वास्तव में है
सिर्फ पात्रों में से एक सरणी,

218
00:13:08,210 --> 00:13:12,150
इसलिए हर चरित्र उपयोग करने के क्रम में
एक स्ट्रिंग की, आप सभी के लिए है

219
00:13:12,150 --> 00:13:14,270
सरणी संकेतन का उपयोग करने के लिए है।

220
00:13:14,270 --> 00:13:20,270
मैं प्रकार की एक चर राशि
स्ट्रिंग कहा "पाठ = 'इस CS50 है।' '

221
00:13:20,270 --> 00:13:22,730
>> ठीक है, तो, क्रम में करने के लिए
प्रत्येक वर्ण का उपयोग,

222
00:13:22,730 --> 00:13:25,880
मैं सभी के साथ क्या करना है
चर पाठ इस प्रकार है

223
00:13:25,880 --> 00:13:31,660
अच्छी तरह से कहने के लिए, सूचकांक शून्य पर पाठ, कि
सूचकांक में राजधानी टी पाठ से मेल खाती है

224
00:13:31,660 --> 00:13:35,100
एक कम मामले ज से मेल खाती है।

225
00:13:35,100 --> 00:13:38,110
एक और उपयोगी समारोह है
स्ट्रिंग की लंबाई समारोह।

226
00:13:38,110 --> 00:13:40,760
तो के लिए एक स्ट्रिंग में गुजर रहा है
उस समारोह से वापस आ जाएगी

227
00:13:40,760 --> 00:13:44,610
एक पूर्णांक, कि स्ट्रिंग की लंबाई।

228
00:13:44,610 --> 00:13:47,060
>> हम के बारे में बात की है कि अब
इन सभी विभिन्न तत्वों,

229
00:13:47,060 --> 00:13:48,540
उन्हें एक साथ वापस डाल दिया।

230
00:13:48,540 --> 00:13:52,210
तो या तो मेरे pseudocode करने के लिए वापस
कोड या अपने pseudocode

231
00:13:52,210 --> 00:13:55,920
और के माध्यम से जाने के लिए और यह सुनिश्चित कर लें कि आप
जानते हैं कि कैसे हर एक बात करने के लिए।

232
00:13:55,920 --> 00:14:01,520
argc और argv का उपयोग कर कुंजी हो रही है,
एक पूर्णांक में महत्वपूर्ण मोड़ है, एक

233
00:14:01,520 --> 00:14:06,840
मैं करने के लिए, सादा पाठ के लिए उत्साह,
GetString, और फिर पुनरावृति

234
00:14:06,840 --> 00:14:09,590
में हर चरित्र पर
सादा पाठ स्ट्रिंग,

235
00:14:09,590 --> 00:14:14,910
प्रत्येक चरित्र के मामले संरक्षण
और चाबी से उस चरित्र स्थानांतरण,

236
00:14:14,910 --> 00:14:17,520
सुनिश्चित करना है कि आप कर रहे हैं
वर्णमाला के चारों ओर लपेटकर,

237
00:14:17,520 --> 00:14:20,850
अंततः कि सिफर मुद्रण।

238
00:14:20,850 --> 00:14:25,470
मेरा नाम Amila है, और इस सीज़र था।

239
00:14:25,470 --> 00:14:28,448

