AMILA: Ајде да се справи со Цезар. Во Цезар, ќе им овозможи на корисникот за шифрирање тајна порака. Значи, да се нурне во право и се погледне во нашиот треба да се направат за овој проблем. Значи прво, ние го добиете клучот од корисникот. Тогаш ќе го добиеме чист текст дека тие сакаат да се кодираат. После тоа, ние го шифрирање за нив, и на крајот се печати нивните ciphertext. 

Значи, да почнеме со еден пример. Велат дека си сакал да се кодираат целата азбука со клуч на две деца. Па, целиот азбуката ќе само да се префрли на букви. Значи, ќе се кодира на C, B до D, C до Д, па натаму и така натаму, додека не се дојде до X, кој го енкодира до Ш или Zed, во зависност од тоа каде сте од. Тогаш Y, тогаш ќе се префрлат сите на патот, навиват азбуката да се дојде до, а потоа, конечно, последната буква од писмо, Z, Зед, ќе се кодираат до Б. 

Имаш ли тоа? Ајде да погледнеме неколку примери. Првиот пример, тука е многу слична на она што ние само што е објаснето погоре. Значи, ако јас се кодираат некои дел од писмо, A до L, со клуч на две деца, тогаш јас само се добие целиот мој азбука префрли две букви. 

Потоа, во мојата следна пример, клучот е уште двајца, така што ќе треба да ги знаете кој писма да се очекува. Но, тука е фраза. Ова е CS50. Така ќе се забележи дека јас зачувување на случај на моите писма, па сите големи букви, исто така, големи букви во ciphertext. И било мали букви букви во чист текст исто така, се во мали букви букви во ciphertext. Но, јас ги буквите и било фантастичен марки или било кој друг интерпункциски исти. 

Па сега дека имате смисла за тоа како работи програмата, се чувствуваат слободни да се кандидира на некои повеќе примери на свој, ако сакате. Да почнеме со добивање на клучот од корисникот. Традиционално, со други проблеми, ние сме се навикнати да се сите броеви кои ги треба со прашува корисникот со GetInt функцијата. Но, овој пат ние сме всушност ќе да се користи аргументите на командната линија и нова функција наречена atoi. 

Кога ќе ја стартувате главната програма во C, тогаш тоа зема во две parameters-- int argc, која е бројот на аргументи донесен во, а потоа argv, низа од стрингови кои содржат листата на сите аргументи помина. Вие не мора експлицитно да ги пријават овие варијабли. Тие се пресметува за вас од страна на компајлерот. Правилна употреба за ова ќе биде за argc да биде два во овој случај, бидејќи корисникот е да се помине во на повикот на програмата, ./caesar, а потоа на копчето, без оглед на бројот тие сакаат. Па тоа значи дека мора да биде argc две со цел за валидна употреба на Цезар да биде погубен. 

Па ајде да погледнеме еден пример. Велат дека веќе напишано и Составувач е на програма наречена blastoff. Значи, ако јас се стрча во командната линија ./blastoff тимот ракета, добро, тогаш, argc ќе биде три, бидејќи јас донесен во три различни аргументи. Потоа argv ќе изгледа вака. Тоа е низа, и тоа ќе ги содржи сите три жици. ./blastoff во првиот индекс, тим во следната, и ракетни во минатата година. 

Ајде да зборуваме за низи за една секунда. Низи се структури на податоци кои имаат повеќе вредности од ист вид. Ова може да ни се најде кога ќе имаат листи на цели броеви или жици. Само се сеќавам тие имаат да бидат од ист тип. Во компјутерската наука, љубов, сметајќи од нула, па се сеќавам дека низи Исто така, нула-индексирани. Така, првиот елемент на мојот низа се случува да се биде на индекс нула. Значи во овој случај, кога имам низа со должина од четири, тогаш на последниот индекс на Последниот елемент на мојот низа е, всушност, ќе биде на индекс три, не четири. Бидејќи се сеќавам, ние почне пребројување на нула. 

Еве еден пример за тоа како може да се создаде низа на своја. Така велат сакав да ги соберам три омилени имиња куче. Јас тогаш ќе се создаде низа од стрингови. Па јас ќе го прогласи тип, стринг, и а потоа се стави името на низата, кучиња, а потоа и во оние квадратен загради стави на големина на array-- во овој случај, три. 

Значи мојот прв влез се случува да биде кучиња во индекс нула, и тоа се случува да биде Мило. Потоа кучиња во индекс на еден се случува да се биде глупав, мила Mochi, а потоа во последните влез, третиот влез на индекс две, се случува да биде симпатична, слатка Elphie. Ќе забележите дека форматот за пополнување на оваа низа е многу слично како може да се пријават други променливи каде имаш променлива име проследено со вредноста што сакате складирани во него. Единствената разлика во овој случај е тоа што мора да се сеќавам да се стави на индексот од вредноста во квадратни загради. И ние имаме три омилени кучиња. 

Но, за жал, тоа е време да се вратам на Цезар. Запомнете дека правилната употреба за корисникот ќе се поминува не само името на ./caesar на програмата, но исто така клучна дека тие сакаат да се префрлат нивниот чист текст од. Па тоа значи дека argc мора да биде два. Тие мора да помине со two-- нема повеќе, не помалку од два аргументи на командната линија. 

Сега, она што за argv? Па, ние веќе знаеме дека низа ќе биде со должина од две, но она што се содржани во секој елемент? Па, првиот елемент ќе биде ./caesar, и потоа на следниот елемент ќе се содржи клучот на корисникот внесе во. Сега, ако тие го користат правилно за користење на Цезар, тогаш тие се случува да напишеш во голем број. Но, иако карактер дека тие тип е број, тоа е од типот на податоци стринг. 

Па, како да го конвертирате дека стринг во цел број? Така велат имам бр, стринг, содржи низа 50. Ако сакам да го конвертирате дека на цел број, тогаш едноставно прогласи нова променлива, на цел број i, повикувајќи atoi. Минувам во мојот стринг променлива, бр, и тогаш јас тогаш ќе го содржи бројот 50. Бидете сигурни да проверите на човекот страници за функција atoi да се провери кој библиотека тоа е во, како и она што го вредност ќе се врати ако стрингот донесе во не ги содржи сите броеви. 

Па сега дека сте добиле клуч, следниот чекор е да се добие чист текст од корисникот. Сега, ова ќе се да биде помалку комплицирани од навигацијата низ аргументи на командната линија. Сите ние треба да направите е да се јавиш функцијата GetString да го извести корисникот да се даде ни стринг, но се сеќавам да се провери спецификации за тоа како ние можеби ќе сакате да го извести корисникот за тоа. 

Сега доаѓаме до срцето на problem-- како да шифрирање на чист текст. Па, прво, ајде да разговараме за тоа како за шифрирање еден лик во еден момент, а потоа да се занимава со тоа како да се iterate во текот на целиот чист текст. Што сум напишал некои pseudocode за проблемот Цезар. Јас ве охрабруваме да напишете своја сопствена, како и. Тоа не може да изгледа идентично на рудникот, а тоа е во ред, но се додека како општа идеја е иста. 

Првите три чекори ние веќе го направиле. Сме добиле клучот од аргументите на командната линија, се претворивме дека клучните во цел број, и ние сме предочено на корисникот за чист текст дека тие сакаат да шифрирање. Па тогаш следниот голем дел е дека за секој лик во чист текст стринг, ако тоа е алфабетско, сакаме да го сочуваме својот случај и да ја префрли. Со зачувување на случај, она што можам да кажам е дека сите големи букви букви треба да остане во горниот случајот и сите мали букви треба да останат мали букви. Па потоа откако ќе ги префрли тие, тогаш ние печати на ciphertext. 

Еве три функции што се случува да ни се најде за овој проблем. Запомни горе кога дадов пример за менувањето ова е CS50? Имајте на ум дека 50 и извичник не се префрлат? Па како може да се каже дали ние треба да се префрлат на писмо или не? Па, "е алфа", ако го лик помине, ќе се врати ако е вистина дека карактерот е писмо и лажни поинаку. За да ви помогнеме со зачувување на капитализација се функциите "се Горна "и" е помал. " 

Овие две функции, исто така, се во еден лик како влез и ќе се врати на Булова, точно или неточно зависност од тоа дали тој лик е големи букви или мали букви. Затоа што "е Горна" и "е пониски "се Буловите функции, што значи дека тие ќе се вратат на Булова, Може да ја користите во вашите услови. Значи тука е програмка на код кој само отпечатоци писмо и ако тоа е голема буква. Па јас сум прогласена за мојот карактер писмо да биде во горниот случај Zed а потоа, ако "е горниот" се враќа точно, тогаш јас се печати таа буква. 

Да се ​​вратам на нашите едноставен пример менувањето на писмото со клуч на две деца, како ние всушност се дека да се работи? Па, излегува дека карактери и цели броеви се многу тесно поврзани. Секој карактер има целобројна вредност поврзани со тоа се најде во табелата ASCII, каде ASCII секој карактер е се прикажува вредност. Значи одговара А големи букви на ASCII вредност од 65 и мали букви од А до на ASCII вредност од 97. 

Слободно можете да се погледне до било ASCII табелата онлајн да ги види овие вредности за себе. Значи она што ова значи е дека можеме да се на ликот на големи букви А, додадете број два до неа, а потоа се ликот големи букви Ц, како резултат. Тоа е затоа што 65 години, ASCII вредност за капитал, плус 2, ни дава 67, што одговара карактерот на големи букви В. 

За жал, работите не сосема ќе биде толку едноставно. Имаме равенката која ние треба да се разгледа. Еве што ни кажува дека ciphertext на о писмо одговара на текстуална о писмо, плус key-- сето тоа, модуларен 26. Зошто е тоа така? Да се ​​вратиме на примерот од пред, каде што капиталот А, плус 2, ни дава капитал В. 

Значи примена на равенката со која се спецификација ни ја дава, тогаш ајде да ги капитал плус 2 и МО дека до 26. Значи, капиталот А, кога ќе го стави во оние кои се еден наводници, ми дозволува да го третираат како цел број, така што им овозможува на мене да го фрли нејзиниот ASCII вредност, 65. 65 плус 2 е 67. 67 mod 26 ни дава 15, Но, тоа не навистина да има смисла, затоа што знаеме дека капитал C ASCII вредност е 67, а не 15. Па, како да се помират дека? 

Па, тука би сакал да го воспостави поимот на азбучен индекс. Па ние веќе разговаравме за тоа како секој лик има ASCII вредност, но јас би сакал да се каже, добро, ајде мислам за секој лик, исто така, имаат азбучен индекс, каде што A, на пример, како на првата буква од азбуката, има азбучен индекс на нула. Па сега ајде да се применуваат истата равенка како и досега, но со користење на азбучен индекс. 

Па е нула, како што ние си дефинирани. Па потоа земајќи нула плус два, mod 26, Тоа е два, современи 26, што ни дава две. И добро, во смисла на азбучен индекс, C е третата буква во писмо, така што ќе соодветствува на азбучен индекс на две деца. Така, се чини дека со користење на азбучен индекс во овој случај всушност, ни дава точниот резултат. 

Па сега ајде да се провери да се види дали равенката работи со азбучниот индекс. Азбучен индекс Y е 24 како втор на последната буква од азбуката. Па тогаш 24 плус нашите клуч на две ни дава 26. 26 mod 26 ни дава 0, која, за среќа нас, е азбучен индекс за А. Па се надевам дека е доволно што доказ методот на азбучен индекс работи. Ако не е, се чувствуваат слободни да го пробате некои примери на своја. 

Со цел правилно да се заврши околу азбука и да ги применуваат равенката Цезар, тогаш знаеме дека ние треба да се се справи со азбучни индекси. Но, да почнеме со ASCII вредности, и само тогаш ние потоа се претворат во азбучниот индекс. Од таму, со цел да се печати, ние треба да се справи со вредностите на ASCII повторно. Значи ние треба да дознаам како да се одат од ASCII да Азбучно и од азбучен на ASCII. 

Па јас го оставам сами да дознаам шемата помеѓу карактер и по азбучен ред индекс и нејзиниот ASCII вредност. Сега, не заборавајте дека и покрај тоа што ова право табела на слајд покажува големи букви, ние, исто така, треба да се разгледа дали или не се однесува на различен за мали знаци. 

Па сега дека ние сме сфатиле како да се префрли еден лик, тогаш сите ние треба да направите е скала која да одат низ целиот чист текст. Така чист текст е стринг. Среќа за нас, стринг е навистина само низа од карактери, па со цел да пристапите до секој карактер на низа, сите што треба да направите е да се користи низа нотација. Велат дека имаат променлива од тип низа наречен "text =" ова е CS50. " 

Па, тогаш, со цел да се пристап до секој карактер, сите што треба да направите со променлива текст е да се каже добро, текст индекс нула, дека одговара на капитал Т. текст индекс еден одговара на долниот дел од куќиштето h. Друга корисна функција е функција на должината на стрингот. Така поминува во низа на таа функција ќе се врати цел број, должината на стрингот. 

Сега дека ние сме зборуваше за сите овие различни елементи, ајде да ги стави повторно заедно. Па се врати или да ми pseudocode код или вашиот pseudocode и да си одат преку и да бидете сигурни дека ќе знаат како да се направи секоја работа. Добивање на клучни користење argc и argv, вртење на клучот во цел број, а до јас, прашува за чист текст, GetString, а потоа процесирањето во текот на секој лик во чист текст стринг, зачувување на случајот на секој карактер и менувањето на тој лик со клучот, се осигура дека ќе се завиткување околу азбуката, конечно ја печатите таа ciphertext. Моето име е Amila, и тоа беше Цезар. 