1
00:00:00,000 --> 00:00:00,760

2
00:00:00,760 --> 00:00:02,270
>> AMILA: Ајде да се справи со Цезар.

3
00:00:02,270 --> 00:00:06,110
Во Цезар, ќе им овозможи на корисникот
за шифрирање тајна порака.

4
00:00:06,110 --> 00:00:09,780
Значи, да се нурне во право и се погледне
во нашиот треба да се направат за овој проблем.

5
00:00:09,780 --> 00:00:12,210
Значи прво, ние го добиете клучот од корисникот.

6
00:00:12,210 --> 00:00:15,210
Тогаш ќе го добиеме чист текст
дека тие сакаат да се кодираат.

7
00:00:15,210 --> 00:00:21,380
После тоа, ние го шифрирање за нив,
и на крајот се печати нивните ciphertext.

8
00:00:21,380 --> 00:00:23,600
>> Значи, да почнеме со еден пример.

9
00:00:23,600 --> 00:00:26,920
Велат дека си сакал да се кодираат
целата азбука со клуч на две деца.

10
00:00:26,920 --> 00:00:31,360
Па, целиот азбуката ќе
само да се префрли на букви.

11
00:00:31,360 --> 00:00:37,060
Значи, ќе се кодира на C, B до
D, C до Д, па натаму и така натаму,

12
00:00:37,060 --> 00:00:42,470
додека не се дојде до X, кој го енкодира до Ш
или Zed, во зависност од тоа каде сте од.

13
00:00:42,470 --> 00:00:47,445
Тогаш Y, тогаш ќе се префрлат сите на патот,
навиват азбуката да се дојде до,

14
00:00:47,445 --> 00:00:53,256
а потоа, конечно, последната буква од
писмо, Z, Зед, ќе се кодираат до Б.

15
00:00:53,256 --> 00:00:54,660
>> Имаш ли тоа?

16
00:00:54,660 --> 00:00:56,380
Ајде да погледнеме неколку примери.

17
00:00:56,380 --> 00:01:00,540
Првиот пример, тука е многу слична
на она што ние само што е објаснето погоре.

18
00:01:00,540 --> 00:01:05,560
Значи, ако јас се кодираат некои дел од
писмо, A до L, со клуч на две деца,

19
00:01:05,560 --> 00:01:09,760
тогаш јас само се добие целиот мој
азбука префрли две букви.

20
00:01:09,760 --> 00:01:12,230
>> Потоа, во мојата следна пример,
клучот е уште двајца,

21
00:01:12,230 --> 00:01:15,080
така што ќе треба да ги знаете
кој писма да се очекува.

22
00:01:15,080 --> 00:01:16,400
Но, тука е фраза.

23
00:01:16,400 --> 00:01:18,100
Ова е CS50.

24
00:01:18,100 --> 00:01:21,090
Така ќе се забележи дека јас
зачувување на случај на моите писма,

25
00:01:21,090 --> 00:01:25,600
па сите големи букви, исто така,
големи букви во ciphertext.

26
00:01:25,600 --> 00:01:27,800
И било мали букви
букви во чист текст

27
00:01:27,800 --> 00:01:30,640
исто така, се во мали букви
букви во ciphertext.

28
00:01:30,640 --> 00:01:34,020
Но, јас ги буквите
и било фантастичен марки

29
00:01:34,020 --> 00:01:37,610
или било кој друг интерпункциски исти.

30
00:01:37,610 --> 00:01:40,360
>> Па сега дека имате смисла
за тоа како работи програмата,

31
00:01:40,360 --> 00:01:43,890
се чувствуваат слободни да се кандидира на некои повеќе
примери на свој, ако сакате.

32
00:01:43,890 --> 00:01:47,072
Да почнеме со добивање на
клучот од корисникот.

33
00:01:47,072 --> 00:01:48,780
Традиционално, со
други проблеми, ние сме

34
00:01:48,780 --> 00:01:51,450
се навикнати да се
сите броеви кои ги

35
00:01:51,450 --> 00:01:54,710
треба со прашува корисникот
со GetInt функцијата.

36
00:01:54,710 --> 00:01:58,850
Но, овој пат ние сме всушност ќе
да се користи аргументите на командната линија

37
00:01:58,850 --> 00:02:01,760
и нова функција наречена atoi.

38
00:02:01,760 --> 00:02:05,130
>> Кога ќе ја стартувате главната
програма во C, тогаш тоа

39
00:02:05,130 --> 00:02:08,500
зема во две parameters--
int argc, која

40
00:02:08,500 --> 00:02:11,670
е бројот на аргументи
донесен во, а потоа

41
00:02:11,670 --> 00:02:15,920
argv, низа од стрингови кои содржат
листата на сите аргументи

42
00:02:15,920 --> 00:02:16,740
помина.

43
00:02:16,740 --> 00:02:19,740
Вие не мора експлицитно
да ги пријават овие варијабли.

44
00:02:19,740 --> 00:02:22,700
Тие се пресметува за
вас од страна на компајлерот.

45
00:02:22,700 --> 00:02:28,160
Правилна употреба за ова ќе биде
за argc да биде два во овој случај,

46
00:02:28,160 --> 00:02:32,630
бидејќи корисникот е да се помине во
на повикот на програмата, ./caesar,

47
00:02:32,630 --> 00:02:35,570
а потоа на копчето,
без оглед на бројот тие сакаат.

48
00:02:35,570 --> 00:02:39,920
Па тоа значи дека мора да биде argc две
со цел за валидна употреба на Цезар

49
00:02:39,920 --> 00:02:41,680
да биде погубен.

50
00:02:41,680 --> 00:02:43,590
>> Па ајде да погледнеме еден пример.

51
00:02:43,590 --> 00:02:47,760
Велат дека веќе напишано и
Составувач е на програма наречена blastoff.

52
00:02:47,760 --> 00:02:52,670
Значи, ако јас се стрча во командната линија
./blastoff тимот ракета, добро, тогаш,

53
00:02:52,670 --> 00:02:57,750
argc ќе биде три, бидејќи јас
донесен во три различни аргументи.

54
00:02:57,750 --> 00:02:59,830
Потоа argv ќе изгледа вака.

55
00:02:59,830 --> 00:03:03,750
Тоа е низа, и тоа ќе
ги содржи сите три жици.

56
00:03:03,750 --> 00:03:09,640
./blastoff во првиот индекс, тим
во следната, и ракетни во минатата година.

57
00:03:09,640 --> 00:03:11,610
>> Ајде да зборуваме за низи за една секунда.

58
00:03:11,610 --> 00:03:15,560
Низи се структури на податоци кои имаат
повеќе вредности од ист вид.

59
00:03:15,560 --> 00:03:19,980
Ова може да ни се најде кога ќе
имаат листи на цели броеви или жици.

60
00:03:19,980 --> 00:03:23,030
Само се сеќавам тие имаат
да бидат од ист тип.

61
00:03:23,030 --> 00:03:25,310
Во компјутерската наука,
љубов, сметајќи од нула,

62
00:03:25,310 --> 00:03:29,260
па се сеќавам дека низи
Исто така, нула-индексирани.

63
00:03:29,260 --> 00:03:34,360
Така, првиот елемент на мојот низа
се случува да се биде на индекс нула.

64
00:03:34,360 --> 00:03:37,580
Значи во овој случај, кога имам
низа со должина од четири,

65
00:03:37,580 --> 00:03:41,350
тогаш на последниот индекс на
Последниот елемент на мојот низа

66
00:03:41,350 --> 00:03:44,970
е, всушност, ќе биде
на индекс три, не четири.

67
00:03:44,970 --> 00:03:48,880
Бидејќи се сеќавам, ние
почне пребројување на нула.

68
00:03:48,880 --> 00:03:52,530
>> Еве еден пример за тоа како
може да се создаде низа на своја.

69
00:03:52,530 --> 00:03:56,440
Така велат сакав да ги соберам
три омилени имиња куче.

70
00:03:56,440 --> 00:03:59,030
Јас тогаш ќе се создаде низа од стрингови.

71
00:03:59,030 --> 00:04:04,450
Па јас ќе го прогласи тип, стринг, и
а потоа се стави името на низата, кучиња,

72
00:04:04,450 --> 00:04:06,450
а потоа и во оние квадратен
загради стави на големина

73
00:04:06,450 --> 00:04:09,260
на array-- во овој случај, три.

74
00:04:09,260 --> 00:04:12,690
>> Значи мојот прв влез се случува
да биде кучиња во индекс нула,

75
00:04:12,690 --> 00:04:14,750
и тоа се случува да биде Мило.

76
00:04:14,750 --> 00:04:17,850
Потоа кучиња во индекс на еден
се случува да се биде глупав,

77
00:04:17,850 --> 00:04:23,060
мила Mochi, а потоа во последните
влез, третиот влез на индекс две,

78
00:04:23,060 --> 00:04:26,130
се случува да биде симпатична, слатка Elphie.

79
00:04:26,130 --> 00:04:28,610
Ќе забележите дека форматот
за пополнување на оваа низа

80
00:04:28,610 --> 00:04:32,150
е многу слично како може да се
пријават други променливи каде

81
00:04:32,150 --> 00:04:36,307
имаш променлива име проследено со
вредноста што сакате складирани во него.

82
00:04:36,307 --> 00:04:38,140
Единствената разлика во
овој случај е тоа што

83
00:04:38,140 --> 00:04:42,700
мора да се сеќавам да се стави на индексот
од вредноста во квадратни загради.

84
00:04:42,700 --> 00:04:46,420
И ние имаме
три омилени кучиња.

85
00:04:46,420 --> 00:04:48,780
>> Но, за жал, тоа е време
да се вратам на Цезар.

86
00:04:48,780 --> 00:04:52,910
Запомнете дека правилната употреба за
корисникот ќе се поминува не само

87
00:04:52,910 --> 00:04:57,430
името на ./caesar на програмата, но
исто така клучна дека тие сакаат да се префрлат

88
00:04:57,430 --> 00:04:58,850
нивниот чист текст од.

89
00:04:58,850 --> 00:05:01,540
Па тоа значи дека argc мора да биде два.

90
00:05:01,540 --> 00:05:07,580
Тие мора да помине со two-- нема повеќе, не
помалку од два аргументи на командната линија.

91
00:05:07,580 --> 00:05:09,050
>> Сега, она што за argv?

92
00:05:09,050 --> 00:05:12,880
Па, ние веќе знаеме дека
низа ќе биде со должина од две,

93
00:05:12,880 --> 00:05:15,270
но она што се содржани во секој елемент?

94
00:05:15,270 --> 00:05:19,330
Па, првиот елемент
ќе биде ./caesar,

95
00:05:19,330 --> 00:05:24,190
и потоа на следниот елемент ќе се
содржи клучот на корисникот внесе во.

96
00:05:24,190 --> 00:05:27,480
Сега, ако тие го користат правилно
за користење на Цезар,

97
00:05:27,480 --> 00:05:29,350
тогаш тие се случува да напишеш во голем број.

98
00:05:29,350 --> 00:05:33,260
Но, иако карактер
дека тие тип е број,

99
00:05:33,260 --> 00:05:35,790
тоа е од типот на податоци стринг.

100
00:05:35,790 --> 00:05:40,390
>> Па, како да го конвертирате дека
стринг во цел број?

101
00:05:40,390 --> 00:05:46,680
Така велат имам бр, стринг,
содржи низа 50.

102
00:05:46,680 --> 00:05:49,000
Ако сакам да го конвертирате дека
на цел број, тогаш едноставно

103
00:05:49,000 --> 00:05:53,340
прогласи нова променлива, на
цел број i, повикувајќи atoi.

104
00:05:53,340 --> 00:06:01,160
Минувам во мојот стринг променлива, бр, и
тогаш јас тогаш ќе го содржи бројот 50.

105
00:06:01,160 --> 00:06:04,350
Бидете сигурни да проверите на човекот
страници за функција atoi

106
00:06:04,350 --> 00:06:07,990
да се провери кој библиотека тоа е
во, како и она што го вредност

107
00:06:07,990 --> 00:06:14,550
ќе се врати ако стрингот донесе
во не ги содржи сите броеви.

108
00:06:14,550 --> 00:06:16,950
>> Па сега дека сте добиле
клуч, следниот чекор

109
00:06:16,950 --> 00:06:19,430
е да се добие чист текст од корисникот.

110
00:06:19,430 --> 00:06:21,170
Сега, ова ќе се
да биде помалку комплицирани

111
00:06:21,170 --> 00:06:23,410
од навигацијата низ
аргументи на командната линија.

112
00:06:23,410 --> 00:06:26,190
Сите ние треба да направите е да се јавиш
функцијата GetString

113
00:06:26,190 --> 00:06:29,660
да го извести корисникот да се даде
ни стринг, но се сеќавам

114
00:06:29,660 --> 00:06:34,090
да се провери спецификации за тоа како ние
можеби ќе сакате да го извести корисникот за тоа.

115
00:06:34,090 --> 00:06:36,420
>> Сега доаѓаме до
срцето на problem--

116
00:06:36,420 --> 00:06:38,860
како да шифрирање на чист текст.

117
00:06:38,860 --> 00:06:42,830
Па, прво, ајде да разговараме за тоа како
за шифрирање еден лик во еден момент,

118
00:06:42,830 --> 00:06:47,370
а потоа да се занимава со тоа како да се
iterate во текот на целиот чист текст.

119
00:06:47,370 --> 00:06:50,440
Што сум напишал некои pseudocode
за проблемот Цезар.

120
00:06:50,440 --> 00:06:52,310
Јас ве охрабруваме да
напишете своја сопствена, како и.

121
00:06:52,310 --> 00:06:55,900
Тоа не може да изгледа идентично на
рудникот, а тоа е во ред, но се додека

122
00:06:55,900 --> 00:06:58,640
како општа идеја е иста.

123
00:06:58,640 --> 00:07:00,780
>> Првите три чекори
ние веќе го направиле.

124
00:07:00,780 --> 00:07:03,100
Сме добиле клучот од
аргументите на командната линија,

125
00:07:03,100 --> 00:07:05,510
се претворивме дека клучните
во цел број, и ние сме

126
00:07:05,510 --> 00:07:09,320
предочено на корисникот за чист текст
дека тие сакаат да шифрирање.

127
00:07:09,320 --> 00:07:12,420
Па тогаш следниот голем дел
е дека за секој лик

128
00:07:12,420 --> 00:07:15,070
во чист текст стринг,
ако тоа е алфабетско,

129
00:07:15,070 --> 00:07:17,750
сакаме да го сочуваме
својот случај и да ја префрли.

130
00:07:17,750 --> 00:07:20,900
Со зачувување на случај, она што можам
да кажам е дека сите големи букви

131
00:07:20,900 --> 00:07:23,580
букви треба да остане во горниот
случајот и сите мали букви

132
00:07:23,580 --> 00:07:25,640
треба да останат мали букви.

133
00:07:25,640 --> 00:07:29,110
Па потоа откако ќе ги префрли тие,
тогаш ние печати на ciphertext.

134
00:07:29,110 --> 00:07:33,100
>> Еве три функции што се случува
да ни се најде за овој проблем.

135
00:07:33,100 --> 00:07:38,010
Запомни горе кога дадов
пример за менувањето ова е CS50?

136
00:07:38,010 --> 00:07:41,800
Имајте на ум дека 50 и
извичник не се префрлат?

137
00:07:41,800 --> 00:07:45,680
Па како може да се каже дали ние
треба да се префрлат на писмо или не?

138
00:07:45,680 --> 00:07:48,650
Па, "е алфа", ако
го лик помине,

139
00:07:48,650 --> 00:07:54,850
ќе се врати ако е вистина дека карактерот
е писмо и лажни поинаку.

140
00:07:54,850 --> 00:07:56,870
За да ви помогнеме со
зачувување на капитализација

141
00:07:56,870 --> 00:07:59,750
се функциите "се
Горна "и" е помал. "

142
00:07:59,750 --> 00:08:03,350
>> Овие две функции, исто така, се
во еден лик како влез

143
00:08:03,350 --> 00:08:06,580
и ќе се врати на Булова,
точно или неточно

144
00:08:06,580 --> 00:08:11,280
зависност од тоа дали тој лик
е големи букви или мали букви.

145
00:08:11,280 --> 00:08:14,610
Затоа што "е Горна" и "е
пониски "се Буловите функции,

146
00:08:14,610 --> 00:08:18,660
што значи дека тие ќе се вратат на Булова,
Може да ја користите во вашите услови.

147
00:08:18,660 --> 00:08:23,490
Значи тука е програмка на код кој само
отпечатоци писмо и ако тоа е голема буква.

148
00:08:23,490 --> 00:08:27,790
Па јас сум прогласена за мојот карактер
писмо да биде во горниот случај Zed

149
00:08:27,790 --> 00:08:33,440
а потоа, ако "е горниот" се враќа
точно, тогаш јас се печати таа буква.

150
00:08:33,440 --> 00:08:38,200
>> Да се ​​вратам на нашите едноставен пример
менувањето на писмото со клуч на две деца,

151
00:08:38,200 --> 00:08:41,049
како ние всушност се дека да се работи?

152
00:08:41,049 --> 00:08:45,770
Па, излегува дека карактери
и цели броеви се многу тесно поврзани.

153
00:08:45,770 --> 00:08:48,840
Секој карактер има
целобројна вредност поврзани

154
00:08:48,840 --> 00:08:53,260
со тоа се најде во табелата ASCII,
каде ASCII секој карактер е

155
00:08:53,260 --> 00:08:55,380
се прикажува вредност.

156
00:08:55,380 --> 00:08:58,940
Значи одговара А големи букви
на ASCII вредност од 65

157
00:08:58,940 --> 00:09:02,270
и мали букви од А до
на ASCII вредност од 97.

158
00:09:02,270 --> 00:09:04,940
>> Слободно можете да се погледне до
било ASCII табелата онлајн

159
00:09:04,940 --> 00:09:07,720
да ги види овие вредности за себе.

160
00:09:07,720 --> 00:09:12,096
Значи она што ова значи е дека можеме да
се на ликот на големи букви А,

161
00:09:12,096 --> 00:09:18,200
додадете број два до неа, а потоа се
ликот големи букви Ц, како резултат.

162
00:09:18,200 --> 00:09:23,720
Тоа е затоа што 65 години, ASCII
вредност за капитал, плус 2,

163
00:09:23,720 --> 00:09:29,960
ни дава 67, што одговара
карактерот на големи букви В.

164
00:09:29,960 --> 00:09:33,480
>> За жал, работите
не сосема ќе биде толку едноставно.

165
00:09:33,480 --> 00:09:36,980
Имаме равенката која
ние треба да се разгледа.

166
00:09:36,980 --> 00:09:43,590
Еве што ни кажува дека ciphertext на о
писмо одговара на текстуална о

167
00:09:43,590 --> 00:09:48,900
писмо, плус key--
сето тоа, модуларен 26.

168
00:09:48,900 --> 00:09:50,810
Зошто е тоа така?

169
00:09:50,810 --> 00:09:55,430
Да се ​​вратиме на примерот од
пред, каде што капиталот А, плус 2,

170
00:09:55,430 --> 00:09:57,590
ни дава капитал В.

171
00:09:57,590 --> 00:10:01,870
>> Значи примена на равенката со која се
спецификација ни ја дава,

172
00:10:01,870 --> 00:10:06,660
тогаш ајде да ги капитал
плус 2 и МО дека до 26.

173
00:10:06,660 --> 00:10:10,730
Значи, капиталот А, кога ќе го стави во
оние кои се еден наводници,

174
00:10:10,730 --> 00:10:14,010
ми дозволува да го третираат како
цел број, така што им овозможува на

175
00:10:14,010 --> 00:10:17,500
мене да го фрли нејзиниот ASCII вредност, 65.

176
00:10:17,500 --> 00:10:20,080
65 плус 2 е 67.

177
00:10:20,080 --> 00:10:25,210
67 mod 26 ни дава 15,
Но, тоа не навистина

178
00:10:25,210 --> 00:10:32,590
да има смисла, затоа што знаеме дека
капитал C ASCII вредност е 67, а не 15.

179
00:10:32,590 --> 00:10:35,580
Па, како да се помират дека?

180
00:10:35,580 --> 00:10:39,840
>> Па, тука би сакал да го воспостави
поимот на азбучен индекс.

181
00:10:39,840 --> 00:10:44,010
Па ние веќе разговаравме за тоа како
секој лик има ASCII вредност,

182
00:10:44,010 --> 00:10:48,810
но јас би сакал да се каже, добро, ајде
мислам за секој лик, исто така, имаат

183
00:10:48,810 --> 00:10:52,230
азбучен индекс,
каде што A, на пример,

184
00:10:52,230 --> 00:10:58,800
како на првата буква од азбуката,
има азбучен индекс на нула.

185
00:10:58,800 --> 00:11:02,070
Па сега ајде да се применуваат
истата равенка како и досега,

186
00:11:02,070 --> 00:11:05,040
но со користење на азбучен индекс.

187
00:11:05,040 --> 00:11:07,810
>> Па е нула, како што ние си дефинирани.

188
00:11:07,810 --> 00:11:15,640
Па потоа земајќи нула плус два, mod 26,
Тоа е два, современи 26, што ни дава две.

189
00:11:15,640 --> 00:11:18,780
И добро, во смисла на
азбучен индекс,

190
00:11:18,780 --> 00:11:23,930
C е третата буква во
писмо, така што ќе соодветствува

191
00:11:23,930 --> 00:11:26,290
на азбучен индекс на две деца.

192
00:11:26,290 --> 00:11:29,850
Така, се чини дека со користење на
азбучен индекс во овој случај

193
00:11:29,850 --> 00:11:32,840
всушност, ни дава точниот резултат.

194
00:11:32,840 --> 00:11:35,020
>> Па сега ајде да се провери да се
види дали равенката работи

195
00:11:35,020 --> 00:11:37,210
со азбучниот индекс.

196
00:11:37,210 --> 00:11:42,540
Азбучен индекс Y е 24 како
втор на последната буква од азбуката.

197
00:11:42,540 --> 00:11:46,520
Па тогаш 24 плус нашите
клуч на две ни дава 26.

198
00:11:46,520 --> 00:11:54,750
26 mod 26 ни дава 0, која, за среќа
нас, е азбучен индекс за А.

199
00:11:54,750 --> 00:11:59,100
Па се надевам дека е доволно што доказ
методот на азбучен индекс работи.

200
00:11:59,100 --> 00:12:03,180
Ако не е, се чувствуваат слободни да го пробате
некои примери на своја.

201
00:12:03,180 --> 00:12:08,030
>> Со цел правилно да се заврши околу
азбука и да ги применуваат равенката Цезар,

202
00:12:08,030 --> 00:12:11,280
тогаш знаеме дека ние треба да се
се справи со азбучни индекси.

203
00:12:11,280 --> 00:12:15,130
Но, да почнеме со ASCII
вредности, и само тогаш

204
00:12:15,130 --> 00:12:18,530
ние потоа се претворат во
азбучниот индекс.

205
00:12:18,530 --> 00:12:23,970
Од таму, со цел да се печати, ние треба
да се справи со вредностите на ASCII повторно.

206
00:12:23,970 --> 00:12:28,350
Значи ние треба да дознаам како да се
одат од ASCII да Азбучно

207
00:12:28,350 --> 00:12:31,080
и од азбучен на ASCII.

208
00:12:31,080 --> 00:12:34,910
>> Па јас го оставам сами да дознаам
шемата помеѓу карактер

209
00:12:34,910 --> 00:12:38,590
и по азбучен ред
индекс и нејзиниот ASCII вредност.

210
00:12:38,590 --> 00:12:41,530
Сега, не заборавајте дека и покрај тоа што
ова право табела на слајд

211
00:12:41,530 --> 00:12:45,630
покажува големи букви, ние, исто така,
треба да се разгледа дали или не

212
00:12:45,630 --> 00:12:48,915
се однесува на различен
за мали знаци.

213
00:12:48,915 --> 00:12:52,070

214
00:12:52,070 --> 00:12:55,840
>> Па сега дека ние сме сфатиле
како да се префрли еден лик,

215
00:12:55,840 --> 00:13:02,200
тогаш сите ние треба да направите е скала која
да одат низ целиот чист текст.

216
00:13:02,200 --> 00:13:04,260
Така чист текст е стринг.

217
00:13:04,260 --> 00:13:08,210
Среќа за нас, стринг е навистина
само низа од карактери,

218
00:13:08,210 --> 00:13:12,150
па со цел да пристапите до секој карактер
на низа, сите што треба да направите

219
00:13:12,150 --> 00:13:14,270
е да се користи низа нотација.

220
00:13:14,270 --> 00:13:20,270
Велат дека имаат променлива од тип
низа наречен "text =" ова е CS50. "

221
00:13:20,270 --> 00:13:22,730
>> Па, тогаш, со цел да се
пристап до секој карактер,

222
00:13:22,730 --> 00:13:25,880
сите што треба да направите со
променлива текст е

223
00:13:25,880 --> 00:13:31,660
да се каже добро, текст индекс нула, дека
одговара на капитал Т. текст индекс

224
00:13:31,660 --> 00:13:35,100
еден одговара на долниот дел од куќиштето h.

225
00:13:35,100 --> 00:13:38,110
Друга корисна функција е
функција на должината на стрингот.

226
00:13:38,110 --> 00:13:40,760
Така поминува во низа на
таа функција ќе се врати

227
00:13:40,760 --> 00:13:44,610
цел број, должината на стрингот.

228
00:13:44,610 --> 00:13:47,060
>> Сега дека ние сме зборуваше за
сите овие различни елементи,

229
00:13:47,060 --> 00:13:48,540
ајде да ги стави повторно заедно.

230
00:13:48,540 --> 00:13:52,210
Па се врати или да ми pseudocode
код или вашиот pseudocode

231
00:13:52,210 --> 00:13:55,920
и да си одат преку и да бидете сигурни дека ќе
знаат како да се направи секоја работа.

232
00:13:55,920 --> 00:14:01,520
Добивање на клучни користење argc и argv,
вртење на клучот во цел број, а

233
00:14:01,520 --> 00:14:06,840
до јас, прашува за чист текст,
GetString, а потоа процесирањето

234
00:14:06,840 --> 00:14:09,590
во текот на секој лик во
чист текст стринг,

235
00:14:09,590 --> 00:14:14,910
зачувување на случајот на секој карактер
и менувањето на тој лик со клучот,

236
00:14:14,910 --> 00:14:17,520
се осигура дека ќе се
завиткување околу азбуката,

237
00:14:17,520 --> 00:14:20,850
конечно ја печатите таа ciphertext.

238
00:14:20,850 --> 00:14:25,470
Моето име е Amila, и тоа беше Цезар.

239
00:14:25,470 --> 00:14:28,448

