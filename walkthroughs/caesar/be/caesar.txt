Аміла: Давайце вырашаць Цэзар. У Цэзара, мы дазваляем карыстачу для кадавання сакрэтнае паведамленне. Так што давайце ныраць прама і глядзець у нашых да-DOS для гэтай задачы. Такім чынам, па-першае, мы атрымліваем ключ ад карыстальніка. Тады мы атрымаем адкрыты тэкст што яны хочуць, каб кадзіраваць. Пасля гэтага, мы зашыфраваць гэта для іх, і, нарэшце, мы выводзім іх шифротекста. 

Такім чынам, давайце пачнем з прыкладу. Дапусцім, вы хацелі, каб кадзіраваць Ўвесь алфавіт з ключом двух. Ну, увесь ваш алфавіт будзе проста быць ссунутыя на лісты. Такім чынам, будзе кадзіраваць C, B да D, З да Е, гэтак далей і да таго падобнае, пакуль вы не атрымаеце да X, які кадуе да Z або Зэт, у залежнасці ад таго, адкуль вы. Тады Y будзе затым перакласці ўсю дарогу, абгарнуць вакол алфавіту, каб дабрацца да A, а затым, нарэшце, апошняя літара алфавіту, Z, Зэт, будзе кадзіраваць B. 

Вы атрымалі гэта? Давайце паглядзім на некаторыя прыклады. Першы прыклад тут вельмі падобны да таго, што мы толькі што апісана вышэй. Так што калі я закадаваць некаторую секцыю алфавіт, А праз L, з дапамогай ключа з двух, тады я проста атрымаць ўся мая алфавіт ссунутыя две буквы. 

Тады, у маім наступным прыкладзе, ключ ўсё яшчэ два, так што вы павінны ведаць, па-ранейшаму якія літары чакаць. Але вось гэта фраза. Гэта CS50. Такім чынам, вы заўважылі, што я захаваць выпадак маіх лістоў, таму любыя загалоўныя літары таксама загалоўныя літары ў зашыфраваным тэксце. І любы ніжні рэгістр літары ў незашыфраваным Таксама ў ніжнім рэгістры літары ў зашыфраваным тэксце. Але я трымаю лісты і любыя клічнікі або любыя іншыя знакі пунктуацыі тое ж самае. 

Так што цяпер у нас ёсць пачуццё за тое, як працуе праграма, не саромейцеся ісці працаваць яшчэ трохі прыклады самастойна, калі вы хочаце. Давайце пачнем з атрыманнем ключ ад карыстальніка. Традыцыйна, з іншыя праблемы, мы прывыклі да атрымання любыя лічбы, якія мы трэба шляхам падказкі карыстачу з функцыяй GetInt. Але гэтым разам мы на самай справе адбываецца выкарыстоўваць аргумент каманднага радка і новая функцыя называецца atoi. 

Пры запуску асноўнай Праграма ў С, то яна прымае ў двух parameters-- INT ARGC, які гэты лік аргументаў прайшло, і затым ARGV, масіў радкоў, які змяшчае спіс усіх аргументаў прайшло. Вы відавочна не маюць аб'явіць гэтыя зменныя. Яны разлічаны для Вы кампілятарам. Правільнае выкарыстанне для гэтага было б для ARGC быць у дадзеным выпадку два, таму што карыстальнік павінен прайсці ў выклік праграмы, ./caesar, а затым ключ, якую б лічбу яны жадаюць. Такім чынам, гэта азначае, што ARGC павінна быць два для таго, каб сапраўднага выкарыстання Цэзара для выканання. 

Такім чынам, давайце разгледзім прыклад. Скажам, я ўжо напісаў і склаў праграму пад назвай Бластоф. Так што, калі я пабег у камандным радку ./blastoff Rocket Team, ну, тады, ARGC бы тры, таму што я прайшло ў трох розных аргументаў. Тады ARGV будзе выглядаць наступным чынам. Гэта масіў, і гэта было б ўтрымліваюць кожны з трох радкоў. ./blastoff ў першым індэкса, каманда у наступным, і ракеты ў апошні. 

Давайце пагаворым аб масівах на секунду. Масівы ўяўляюць сабой структуры дадзеных, якія трымаюць некалькі значэнняў аднаго і таго ж тыпу. Гэта можа спатрэбіцца, калі мы ёсць спісы цэлых лікаў або радкоў. Проста памятаеце, у іх ёсць каб быць таго ж тыпу. У кампутарнай навуцы, мы каханне лічачы ад нуля, так што памятаеце, што масівы таксама нулявы праіндэксаваныя. Так што першы элемент майго масіва будзе індэксам нуль. Так што ў гэтым выпадку, калі ў мяне ёсць масіў даўжыні чатыры, то апошні індэкс устаўленага Апошні элемент майго масіва на самай справе будзе па індэксе тры, а не чатыры. Таму што памятаеце, што мы пачаць адлік з нуля. 

Вось прыклад таго, як вы можа стварыць масіў самастойна. Так што сказаць, што я хацеў, каб захаваць мой тры любімыя назвы сабакі. Тады я хацеў бы стварыць масіў радкоў. Таму я хацеў бы абвясціць тып, радок, і затым змясціць імя масіва, сабакі, а затым у тых квадраце дужкі паставіць памер з array-- у дадзеным выпадку, тры. 

Так што мая першая запіс будзе каб сабакі з індэксам нуль, і што будзе майл. Тады сабакі з індэксам адной будзе бесталковай, дарагая Матывацыйнай сфер асо, а затым апошні запіс, трэцяя запіс на індэкса два, будзе міла, салодкі Elphie. Вы заўважыце, што фармат для запаўнення гэтага масіва вельмі падобна, як вы маглі б аб'явіць любую іншую зменную, у якой ў вас ёсць імя зменнай, за якой варта значэнне, якое вы хочаце захоўваць у ім. Адзінае адрозненне ў гэты выпадак з'яўляецца тое, што вам павінны памятаць, каб паставіць індэкс значэння ў квадратных дужках. І там у нас ёсць нашы тры любімыя сабакі. 

Але, на жаль, прыйшоў час каб вярнуцца да Цэзару. Памятаеце, што правільнае выкарыстанне для карыстальнік будзе праходзіць не толькі ў назва праграмы ./caesar, але таксама ключ, што яны хочуць перакласці іх адкрытага тэксту з дапамогай. Такім чынам, гэта азначае, што ARGC павінна быць два. Яны павінны прайсці ў two-- ні больш, ні менш за два аргументаў каманднага радка. 

Цяпер, што тычыцца ARGV? Ну, мы ўжо ведаем, што масіў будзе мець даўжыню два, але тое, што змяшчаецца ў кожным элеменце? Ну, першы элемент будзе ./caesar, а затым наступны элемент будзе ўтрымліваюць ключ, які карыстальнік надрукавалі. Цяпер, калі яны выкарыстоўвалі яго правільна для выкарыстання Цэзара, Затым яны збіраюцца ўвесці нумар. Але нават калі характар што яны друкуюць гэты лік, гэта тыпу дадзеных радка. 

Дык як жа мы преобразуем, што радок у цэлы лік? Так што ў мяне ёсць Num, радок, якая змяшчае радок 50. Калі я хачу, каб пераўтварыць яго ў цэлы лік, то я проста абвясціць новую зменнай, цэлага г, называючы atoi. Я праходжу ў маёй зменнай радкі, Num і Затым я будзе ўтрымліваць нумар 50. Пераканайцеся ў тым, каб праверыць мужчыну старонкі для функцыі atoi каб праверыць, якая бібліятэка гэта у, а таксама тое, што сутнасьць яго вернецца, калі радок, перададзеная у ўтрымлівае не ўсе нумары. 

Так што цяпер мы атрымалі ключ, наступны крок каб атрымаць адкрыты тэкст ад карыстальніка. Цяпер, гэта будзе быць менш складаным чым навігацыі па аргументы каманднага радка. Усё, што нам трэба зрабіць, гэта выклік функцыя GetString падказаць карыстачу, каб даць нам радок, але памятайце, каб праверыць спецыфікацыі для таго, як мы можа спатрэбіцца падказаць карыстачу для гэтага. 

Цяпер мы падышлі да сэрца problem-- як зашыфраваць адкрыты тэкст. Ну, па-першае, давайце пагаворым пра тое, як зашыфраваць адзін знак у той час, і тады мы будзем вырашаць, як перабіраць ўвесь адкрыты тэкст. Я напісаў некаторыя псевдокод для задачы Цэзара. Я заклікаю вас напісаць свой уласны, а таксама. Ён не можа выглядаць ідэнтычна маё, і гэта нармальна, але да таго часу, як агульная ідэя тая ж. 

Першыя тры крокі мы ўжо зрабілі. Мы атрымалі ключ ад аргумент каманднага радка, мы ператварылі гэты ключ ў цэлы лік, і мы запыт карыстальніка для адкрытага тэксту што яны хочуць, каб зашыфраваць. Так тады наступны вялікі кавалак у тым, што для кожнага знака у радку адкрытага тэксту, калі гэта алфавітны, мы хочам захаваць яе корпус і зрушыць яго. Па захаваць справа, што я азначае, што верхні рэгістр літары павінны заставацца Upper Корпус і ўсе літары ніжняга рэгістра павінны заставацца ў ніжнім рэгістры. Такім чынам, пасля мы перамяшчаем тыя, Затым мы выводзім шифротекста. 

Вось тры функцыі, якія збіраюцца каб прыйсці ў зручны для гэтай праблемы. Памятаеце, наверсе, калі я даў Прыклад для зруху гэта CS50? Памятаеце, што 50 і Клічнік ня перакладаў? Дык як жа мы можам сказаць, ці з'яўляецца мы неабходна перамясціць ліст ці не? Ну, "альфа", калі вы перадаеце яго персанаж, вяртае ісціну, калі гэты сімвал гэты ліст і хлусня ў адваротным выпадку. Каб дапамагчы вам захаванне капіталізацыі з'яўляюцца функцыямі "з'яўляецца верхні "і" ніжэй ". 

Гэтыя дзве функцыі таксама прымаюць у адзін знак у якасці ўваходных дадзеных і вярнуць вам лагічнае значэнне, сапраўдным або ілжывым у залежнасці ад таго, што характар ў верхнім рэгістры або ніжнім рэгістры. Таму што "зверху" і "з'яўляецца ніжэй "з'яўляюцца Булевы функцыі, Гэта азначае, што яны вяртаюць вам лагічнае значэнне, Вы можаце выкарыстоўваць іх у сваіх умовах. Дык вось фрагмент кода, які толькі друкуе ліст, калі гэта ў верхнім рэгістры. Так што я абвясціў мой характар лісты ў верхні корпус Зэт а затым, калі "зверху" вяртаецца праўда, то я друкую гэты ліст. 

Вяртаючыся да нашага просты прыклад зрушваючы алфавіт ключом з двух, як жа мы на самой справе атрымаць, каб працаваць? Што ж, атрымліваецца, што персанажы і цэлыя лікі вельмі цесна звязаныя паміж сабой. Кожны персанаж мае цэлае значэнне, звязанае з ім знаходзіцца ў ASCII графіцы, дзе ASCII кожнага сімвала адлюстроўваецца значэнне. Так што адпавядае верхні рэгістр A да значэння ASCII 65 і малой а да Значэнне ASCII з 97. 

Не саромейцеся глядзець любы ASCII дыяграмы онлайн каб убачыць гэтыя каштоўнасці для сябе. Дык што ж гэта азначае, што мы можам прымаюць характар ​​верхняга рэгістра A, дадаць цэлае два да яго, а затым атрымаць сімвал верхняга рэгістра C у выніку. Гэта таму, што 65 гадоў ASCII значэнне капіталу А, плюс 2, дае нам 67, што адпавядае характары верхняга рэгістра С. 

На жаль, справы не зусім так проста. У нас ёсць раўнанне, мы павінны разгледзець. Тут ён кажа пра тое, што г-й шифротекста літара адпавядае г-ы адкрыты тэкст ліст, плюс key-- усё гэта модульная 26. Чаму гэта так? Давайце вернемся да нашага прыкладу з да таго, дзе капітал А, плюс 2, дае нам капітал C. 

Такім чынам, ужываючы ўраўненні, спецыфікацыя дае нам, то давайце возьмем капітал A плюс 2 і мод, які на 26. Так капітал А, калі я паклаў яго ў гэтыя адзінкавыя двукоссі, дазваляе мне разглядаць яго як цэлы лік, так што дазваляе мне кінуць яго ў ASCII-значэння, 65. 65 плюс 2 67. 67 мод 26 дае нам 15, але гэта на самай справе не мае сэнс, таму што мы ведаем, што капітал C значэнне ASCII складае 67, а не 15. Так як жа нам прымірыць гэта? 

Ну, тут я хацеў бы пастуляваць Паняцце алфавітным паказальнікам. Такім чынам, мы ўжо казалі пра тое, як кожны знак мае ASCII-значэнне, але я хацеў бы сказаць, ну, давайце думаць пра кожны знак, які мае таксама алфавітны паказальнік, дзе А, напрыклад, як першая літара алфавіту, мае алфавітны паказальнік нуля. Такім чынам, цяпер давайце выкарыстоўваецца і ў дачыненні такое ж раўнанне, як і раней, але з дапамогай алфавітнага паказальніка. 

Такім чынам, роўная нулю, так як мы вызначылі. Такім чынам, тое, узяўшы нуль плюс два, па модулю 26, гэта два, па модулю 26, які дае нам два. І добра, у тэрмінах алфавітны паказальнік, C з'яўляецца трэцяя літара ў алфавіт, так што будзе адпавядаць да алфавітным паказальніку двух. Такім чынам, здаецца, што з дапамогай алфавітны паказальнік у гэтым выпадку на самай справе дае нам правільны вынік. 

Так што цяпер давайце праверым на см, калі раўнанне работ з алфавітным паказальнікам. алфавітны паказальнік Y з'яўляецца 24, як другое месца апошняй літары ў алфавіце. Такім чынам 24 плюс наш Ключ двух дае нам 26. 26 мод 26 дае нам 0, што, на шчасце для нас, і ёсць алфавітны паказальнік для А. Такім чынам, мы спадзяемся, што дастаткова таго, што доказ алфавітны індэксны метад працуе. Калі няма, не саромейцеся паспрабаваць некаторыя прыклады самастойна. 

Для таго, каб належным чынам абгарнуць вакол алфавіт і прымяніць раўнанне Цэзар, то мы ведаем, што нам трэба мець справу з літарнымі індэксамі. Але мы пачынаем з ASCII значэння, і толькі потым мы затым пераўтварыць у алфавітны паказальнік. Адтуль, каб надрукаваць, нам трэба мець справу са значэннямі ASCII зноў. Такім чынам, мы павінны высветліць, як перайсці ад ASCII да алфавітнай і ад алфавітнага ў ASCII. 

Так што я пакідаю вам, каб высветліць, шаблон паміж характарам і яго алфавітны Індэкс і яго ASCII значэнне. Такім чынам, памятаеце, што нават калі гэтую табліцу прама на слайдзе паказвае, загалоўныя літары, мы таксама павінны разгледзець пытанне аб мэтазгоднасці або няма ўжываецца іншы шаблон для ніжняга рэгістра. 

Так што цяпер, калі мы высветлілі, як перамясціць адзін знак, то ўсё, што мы павінны зрабіць, гэта шкала, каб ісці праз увесь тэкст. Такім чынам, зыходны тэкст з'яўляецца радком. На шчасце для нас, радок сапраўды проста масіў сімвалаў, таму для таго, каб атрымаць доступ кожны знак радкі, усё, што вам трэба зрабіць, заключаецца ў выкарыстанні масіва абазначэння. Скажам, у мяне ёсць пераменная тыпу радок называецца "тэкст = 'гэта CS50.'" 

Ну, тады, для таго, каб доступ кожнага знака, усё, што я павінен рабіць з пераменная тэкст сказаць, добра, тэкст з індэксам нуль, то адпавядае капіталу Т. Тэкст па індэксе адзін адпавядае маленькай ч. Яшчэ адна карысная функцыя функцыя даўжыні радка. Так пераходзячы ў радок, каб што функцыя будзе вяртаць цэлы лік, даўжыня гэтага радка. 

Цяпер, калі мы казалі пра усе гэтыя розныя элементы, давайце іх разам. Так што вярнуцца да любой маёй псевдокоде код або ваш псевдокод і ісці да канца і пераканайцеся, што вы ведаюць, як зрабіць любую рэч. Атрыманне ключа з дапамогай ARGC і ARGV, паваротам ключа ў цэлы лік, да I, запытваючы адкрытага тэксту, GetString, а затым пераборы над кожным сімвалам ў незашыфраванымі радок, захоўваючы выпадак кожнага сімвала і пераход гэты сімвал з дапамогай ключа, забеспячэнне таго, каб вы обцяканьне алфавіту, нарэшце-то друк, што шифротекста. Мяне клічуць аміла, і гэта быў Цэзар. 