AMILA: Abordons César. Dans Caesar, nous permettons à l'utilisateur pour coder un message secret. Donc, nous allons plonger à droite et regarder à nos à-dos pour ce problème. Alors d'abord, nous obtenons la clé de l'utilisateur. Ensuite, nous obtenons le plaintext qu'ils veulent coder. Après cela, nous Chiffrer pour eux, et enfin nous imprimons leur cryptogramme. 

Commençons donc par un exemple. Dites que vous vouliez encoder le alphabet entier avec une clé de deux. Eh bien, l'ensemble de votre alphabet serait juste être déplacé aux lettres. Donc, A serait coder à C, B à D, C et E, ainsi de suite et ainsi de suite, jusqu'à ce que vous obtenez à X, qui code à Z ou zed, selon l'endroit où vous venez. Alors Y serait alors déplacer tout le chemin, enrouler autour de l'alphabet pour se rendre à A, puis enfin la dernière lettre de la alphabet, Z, zed, serait encoder B. 

Vous avez obtenu cela? Regardons quelques exemples. Le premier exemple est très semblable à ce que nous venons de l'expliquer ci-dessus. Donc, si j'encoder une certaine section de la alphabet, A à L, par une clé de deux, alors je viens d'obtenir mon entière alphabet déplacé deux lettres. 

Puis, dans mon prochain exemple, la clé est encore deux, de sorte que vous devriez toujours savoir dont les lettres d'attendre. Mais ici, il est une phrase. Ceci est CS50. Donc, vous remarquerez que je préserver le cas de mes lettres, de sorte que toute les lettres majuscules sont également les lettres majuscules dans le texte chiffré. Et tout en minuscules lettres dans le texte en clair sont également minuscules lettres du cryptogramme. Mais je garde les lettres et tous les points d'exclamation ou tout autre signe de ponctuation identiques. 

Alors, maintenant que nous avons un sens pour le fonctionnement du programme, se sentir libre d'aller courir un peu plus des exemples de votre propre, si vous le souhaitez. Commençons par obtenir la clé de l'utilisateur. Traditionnellement, avec d'autres problèmes, nous avons été habitués à obtenir les chiffres qui nous besoin en invitant l'utilisateur avec la fonction getint. Mais cette fois, nous allons en fait d'utiliser l'argument de ligne de commande et une nouvelle fonction appelée atoi. 

Lorsque vous exécutez la principale programme en C, alors il prend en deux parameters-- int argc, qui est le nombre d'arguments passé dans, puis argv, un tableau de chaînes qui contient la liste de tous les arguments adopté. Vous ne devez pas explicitement de déclarer ces variables. Ils sont calculés pour vous par le compilateur. L'utilisation correcte car ce serait pour argc d'être deux dans ce cas, parce que l'utilisateur doit passer en l'appel au programme, ./caesar, puis sur la touche, quel que soit le numéro qu'ils souhaitent. Cela signifie donc que argc doit être deux pour qu'une utilisation valable de César être éxecuté. 

Alors regardons un exemple. Dire que je l'ai déjà écrit et compilé un programme appelé blastoff. Donc, si je suis tombé dans la ligne de commande ./blastoff Team Rocket, bien, alors, argc serait trois parce que je adoptée en trois arguments distincts. Alors argv ressemblerait à ceci. Il est un tableau, et il serait contiennent chacune des trois chaînes. ./blastoff dans le premier index, équipe dans l'autre, et à la roquette dans la dernière. 

Parlons de tableaux pour une seconde. Les tableaux sont des structures de données qui détiennent plusieurs valeurs du même type. Cela peut être utile lorsque nous avoir des listes d'entiers ou des chaînes. Rappelez-vous qu'ils ont être du même type. En informatique, nous amour à compter de zéro, alors rappelez-vous que les tableaux sont également zéro indexées. Donc, le premier élément de mon tableau va être à l'indice zéro. Donc dans ce cas, quand je dois un tableau de longueur quatre, puis le dernier indice de la dernier élément de mon tableau est en fait va être à l'index de trois, pas quatre. Parce que rappelez-vous, nous commencer à compter à zéro. 

Voici un exemple de la façon dont vous pourrait créer un tableau de votre propre. Alors dis que je voulais conserver mon trois noms de chiens préférés. Ensuite, je voudrais créer un tableau de chaînes. Je voudrais donc déclarer le type, la chaîne, et puis mettre le nom du tableau, les chiens, puis dans ceux carré crochets mis la taille du array-- dans ce cas, trois. 

Donc, ma première entrée va pour être des chiens à l'indice zéro, et que ça va être Milo. chiens Puis à l'index un va être maladroit, chérie Mochi, puis le dernier entrée, la troisième entrée à l'index deux, va être mignon, doux Elphie. Vous remarquerez que le format pour remplir ce tableau est très semblable à la façon dont vous pourriez déclarer toute autre variable où vous avez le nom de la variable suivie la valeur que vous voulez stockées. La seule différence ce cas est que vous se rappeler de mettre l'index de la valeur entre crochets. Et là, nous avons notre trois chiens préférés. 

Mais hélas, il est temps pour revenir à César. Rappelez-vous que l'utilisation correcte de la l'utilisateur va se passer, non seulement le nom du ./caesar du programme, mais aussi la clé qu'ils veulent changer leur plaintext par. Cela signifie donc que argc doit être deux. Ils doivent passer en two-- ni plus, ni moins de deux arguments de ligne de commande. 

Maintenant, qu'en argv? Eh bien, nous savons déjà que le tableau va être d'une longueur de deux, mais ce qui est contenu dans chaque élément? Eh bien, le premier élément va être ./caesar, puis l'élément suivant va contenir la clé que l'utilisateur a tapé dans. Maintenant, s'ils l'ont utilisé correctement pour l'utilisation de César, puis ils vont taper un numéro. Mais même si le caractère que leur type est un nombre, il est du type de données chaîne. 

Alors, comment pouvons-nous convertissons que chaîne en entier? Donc, dire que j'ai num, une chaîne, contenant la chaîne 50. Si je veux convertir cette à un nombre entier, alors je simplement déclarer une nouvelle variable, un entier i, appelant atoi. Je passe dans ma variable de chaîne, num, et alors je vais alors contenir le numéro 50. Assurez-vous de vérifier l'homme pages pour la fonction atoi pour vérifier quelle bibliothèque il est dans, ainsi que ce que l'apprécier sera de retour si la chaîne passée en ne contient pas tous les numéros. 

Alors, maintenant que nous avons obtenu la clé, l'étape suivante est d'obtenir le texte en clair de l'utilisateur. Maintenant, cela va moins compliqué que de naviguer à travers le arguments de ligne de commande. Tout ce que nous avons à faire est d'appeler la fonction getString pour inviter l'utilisateur à donner nous une chaîne, mais rappelez-vous de vérifier les spécifications pour la façon dont nous pourrait vouloir demander à l'utilisateur pour cela. 

Maintenant, nous arrivons à la fond du problème-- comment chiffrer le texte en clair. Eh bien, d'abord, nous allons parler de la façon dont pour chiffrer un caractère à la fois, et puis nous allons aborder comment itérer sur l'ensemble du texte brut. Je l'ai écrit quelque pseudocode pour le problème César. Je vous encourage à écrire votre propre bien. Il peut ne pas sembler identique à le mien, et c'est OK, mais aussi longtemps que l'idée générale est la même. 

Les trois premières étapes nous avons déjà fait. Nous avons obtenu la clé de l'argument de ligne de commande, nous avons tourné cette clé en un entier, et nous avons invite l'utilisateur pour le texte en clair qu'ils veulent chiffrer. Alors la prochaine gros morceau est que pour chaque caractère dans la chaîne en clair, si elle est alphabétique, nous voulons préserver son cas et le déplacer. En cas de préserver, ce que je dire est que tous les majuscules les lettres doivent rester supérieure cas et toutes les lettres minuscules devrait rester en minuscules. Alors après nous changeons ceux, puis nous imprimons le cryptogramme. 

Voici trois fonctions qui vont à venir dans maniable pour ce problème. Rappelez-vous au-dessus quand je l'ai par exemple pour déplacer c'est CS50? Rappelez-vous que le 50 et le exclamation ne se déplace pas? Alors, comment pouvons-nous dire si nous besoin de changer une lettre ou non? Eh bien, "est l'alpha," si vous passez un caractère, retourne vrai si ce caractère est une lettre et false sinon. Pour vous aider à capitalisation préservant sont les fonctions "est supérieure "et" inférieure ". 

Ces deux fonctions prennent également dans un seul caractère en entrée et vous retourne un booléen, vrai ou faux selon que ce caractère est en majuscules ou minuscules. Parce que "est supérieure" et "est inférieur "sont des fonctions booléennes, ce qui signifie qu'ils vous renvoient un booléen, vous pouvez utiliser dans vos conditions. Alors, voici un extrait de code qui ne imprime une lettre si elle est en majuscules. Donc, je l'ai déclaré mon caractère lettre à la boîte supérieure zed et puis si "est supérieure" retours vrai, alors j'imprimer cette lettre. 

Pour en revenir à notre exemple simple de décaler l'alphabet par une clé de deux, comment pouvons-nous réellement que pour travailler? Eh bien, il se trouve que des caractères et les entiers sont très étroitement liés. Chaque personnage a un valeur entière associée avec elle a trouvé dans le tableau ASCII, où ASCII de chaque caractère valeur est affichée. Donc, un boîtier supérieur correspond A à une valeur ASCII 65 et minuscule à une une valeur ASCII de 97. 

Ne hésitez pas à consulter tout graphique ASCII en ligne de voir ces valeurs pour vous-même. Donc, cela signifie que nous pouvons prendre le caractère de majuscules A, ajouter le nombre entier de deux à elle, et ensuite obtenir le caractère majuscule C en conséquence. En effet, 65 ans, l'ASCII valeur pour le capital A, majoré de 2, nous donne 67, ce qui correspond au caractère de majuscules C. 

Malheureusement, les choses ne sera pas tout à fait être si simple. Nous avons une équation nous devons considérer. Ici, il nous dit que le cryptogramme ième lettre correspond au texte en clair ième lettre, ainsi que la KEY-- tout cela, modulaire 26. Pourquoi est-ce le cas? Revenons à notre exemple de avant, où le capital A, majoré de 2, nous donne le capital C. 

Donc, l'application de l'équation le cahier des charges nous donne, puis nous allons prendre le capital A plus 2 et mod que par 26. Donc, le capital A, quand je le mets dans ces apostrophes, me permet de traiter comme un nombre entier, ce qui permet me jette à sa valeur ASCII, 65. 65 ans et plus 2 est 67. 67 mod 26 nous donne 15, mais qui n'a pas vraiment sens parce que nous savons que la C majuscule valeur ASCII est de 67, et non 15. Alors, comment peut-on concilier cela? 

Eh bien, ici, je voudrais poser la notion d'un index alphabétique. Donc, nous avons déjà parlé de la façon chaque personnage a sa valeur ASCII, mais je voudrais dire, eh bien, nous allons penser à chaque caractère ayant aussi un index alphabétique, où A par exemple, comme la première lettre de l'alphabet, a un index alphabétique de zéro. Alors maintenant, nous allons appliquer la même équation que précédemment, mais en utilisant un index alphabétique. 

Donc, A est égal à zéro, que nous avons défini. Alors prenant zéro plus deux, mod 26, ça fait deux, mod 26, ce qui nous donne deux. Et ainsi, en termes de un index alphabétique, C est la troisième lettre de l' alphabet, de sorte que correspondrait à un index alphabétique des deux. Il semble donc que l'utilisation du index alphabétique dans ce cas nous donne en fait le résultat correct. 

Alors maintenant, nous allons vérifier à voir si les travaux de l'équation avec un index alphabétique. index alphabétique des Y est 24 comme deuxième à la dernière lettre de l'alphabet. Alors 24 plus notre clé de deux nous donne 26. 26 mod 26 nous donne 0, qui, heureusement pour nous, est l'index alphabétique pour A. Donc, nous espérons que cela suffit que la preuve la méthode index alphabétique fonctionne. Sinon, vous pouvez essayer quelques exemples de votre propre. 

Pour envelopper correctement autour de la alphabet et appliquer l'équation César, alors nous savons que nous devons traiter avec des indices alphabétiques. Mais nous commençons avec ASCII les valeurs, et alors seulement ne nous convertissons alors l'index alphabétique. De là, afin d'imprimer, nous avons besoin de traiter avec les valeurs ASCII à nouveau. Donc, nous avons besoin de comprendre comment aller de ASCII alphabétiques et à partir alphabétique en ASCII. 

Donc, je vous laisse le soin de comprendre le motif entre un personnage et son alphabétique index et sa valeur ASCII. Maintenant, rappelez-vous que même si ce droit de table sur la diapositive montre les lettres majuscules, nous avons également examiner si ou non un modèle différent applique pour les caractères minuscules. 

Maintenant que nous avons compris comment changer un seul caractère, alors tout ce que nous avons à faire est échelle jusqu'à aller sur l'ensemble du texte brut. Donc, le texte en clair est une chaîne. Heureusement pour nous, une chaîne est vraiment juste un tableau de caractères, ainsi afin d'accéder à tous les caractères d'une chaîne, tout ce que vous avez à faire est d'utiliser la notation de tableau. Dire que j'ai une variable de type chaîne appelée "text = 'ceci est CS50.'" 

Eh bien, alors, afin de accéder à chaque caractère, tout ce que je dois faire avec le texte variable est dire ainsi, le texte à l'indice zéro, ce correspond à T. capitale texte à l'index l'un correspond au cas inférieure h. Une autre fonction utile est la fonction de la longueur de chaîne. Donc, en passant dans une chaîne de cette fonction sera de retour un nombre entier, la longueur de cette chaîne. 

Maintenant que nous avons parlé tous ces différents éléments, nous allons les remettre ensemble. Donc revenir soit mon pseudocode code ou votre pseudo et passer par et assurez-vous que vous savoir comment faire chaque chose. Obtenir la clé en utilisant argc et argv, tourner la clé dans un nombre entier, un i, invitant à plaintext, getString, puis itérer sur tous les caractères de la chaîne en clair, en préservant le cas de chaque personnage et décaler ce caractère par la clé, veiller à ce que vous êtes enroulant autour de l'alphabet, enfin l'impression que cryptogramme. Mon nom est Amila, et ce fut César. 