Amila: Idemo u obrani Cezara. U caru ćemo dopustiti korisniku kodirati jednu tajnu. Tako ćemo roniti u pravu i gledati u našim zadatke za ovaj problem. Dakle, prvo smo dobili ključ od korisnika. Onda smo dobili cisti da oni žele da se kodirati. Nakon toga, mi ga za šifriranje za njih, i na kraju mi ​​ispisati svoje šifrirana. 

Počnimo s primjerom. Recimo da je želio kodiraju Cijela abeceda s ključem od dva. Pa, cijeli alfabet bi Samo se pomaknuo na slova. Tako da bi se kodirati u C, B D, C u E, tako dalje i tako dalje, dok ne dođete do X, koji kodira do Z ili zed, ovisno o tome gdje ste iz. Tada je Y bi onda prebaciti sve na putu, zaokrenuti abecede doći do A, a onda na kraju posljednje slovo abeceda, Z, zed, će kodirati do točke B. 

Imaš li to? Pogledajmo neke primjere. Prvi primjer ovdje je vrlo sličan na ono što smo upravo objašnjeno gore. Dakle, ako sam kodirati neki dio od abeceda, A do L, pomoću ključa za dva, onda sam samo dobiti moj cijeli abeceda pomaknuo dva slova. 

Zatim, u mom sljedećem primjeru, ključ je još dva, tako da i dalje treba znati koja slova očekivati. No, ovdje je fraza. Ovo je CS50. Tako ćete primijetiti da ja sačuvati slučaj mojih slova, tako da bilo gornji slova su također gornja slova u šifrirana. I bilo mala slova u čistim Također su mala slova slova u šifrirana. Ali držim slova i bilo uskličnike ili bilo koje druge interpunkcije isti. 

Tako da sada imamo osjećaj za kako program radi, slobodno otići raditi nešto više primjeri svoj vlastiti, ako želite. Počnimo s dobiti ključ od korisnika. Tradicionalno, s drugih problema, mi smo navikli na dobivanje Bilo koji broj da mi potrebno tako potiče korisnika s funkcijom getint. Ali ovaj put mi zapravo idemo za korištenje naredbenog retka argumente i nova funkcija zove atoi. 

Kada pokrenete glavni Program u C, a zatim ga Potrebno je u dva parameters-- int argc, što je broj argumenata donesen, a potom argv, niz nizova koji sadrži popis sve argumente prošao. Vi izričito ne moraju proglasiti ove varijable. Oni računaju za što je prevodilac. Ispravno korištenje za to će biti za argc biti dva, u ovom slučaju, jer korisnik mora proći poziv za program, ./caesar, a onda ključ, bez obzira na broj žele. Dakle, to znači da argc moraju biti dva kako za valjanu upotrebu Cezara treba izvršiti. 

Pa pogledajmo primjer. Recimo Već sam napisao i sastaviti program koji se zove Blastoff. Dakle, ako sam išla u naredbenom retku ./blastoff Tim Raketa, pa, dakle, argc će biti tri, jer sam donesen u tri različite argumente. Zatim argv će izgledati ovako. To je polje, a to bi sadrže svaki od tri žice. ./blastoff u prvom registriranom tima u sljedećem, a raketa u posljednja. 

Razgovarajmo o polja za sekundu. Nizovi su strukture podataka koji drže više vrijednosti iste vrste. To može doći u ruci kada smo imaju popise brojeva ili žice. Dovoljno je sjetiti da su biti isti tip. U računalnoj znanosti, mi volim brojati od nule, pa ne zaboravite da nizovi također nula indeksiraju. Dakle, prvi element mog niza će biti na indeks nula. Dakle, u ovom slučaju, kad sam polje duljine četiri, onda posljednji indeks Posljednji element mog niza zapravo će biti na indeksu tri, a ne četiri. Jer zapamtite, mi početi računajući na nulu. 

Evo jedan primjer kako vas može stvoriti niz svoju vlastitu. Tako kažu ja sam htjela spremiti moj tri omiljena pas imena. Tada bih stvoriti niz žice. Tako bih proglasiti tip, niz, a zatim staviti naziv polja, psi, a onda u tim kvadrata zagrade stavio veličinu od array-- u ovom slučaju, tri. 

Dakle, moj prvi ulazak ide da se psi na indeks nula, i da će biti Milo. Zatim psi na indeksu jednom će biti glup, draga Mochi, a zatim posljednja ulaz, treći ulaz u indeksu dva, će biti slatka, slatka Elphie. Primijetit ćete da formatu za popunjavanje ovog polja je vrlo mnogo kao kako biste mogli proglasiti bilo koju drugu varijablu gdje imate naziv varijable slijedi vrijednost koju želite pohraniti u njoj. Jedina razlika u ovaj slučaj je da vas imati na umu da se stavi indeksa vrijednosti u uglatim zagradama. I tamo imamo naše tri omiljena pasa. 

No, nažalost, to je vrijeme da se vratim na cara. Sjeti se da ispravnog korištenja za Korisnik će biti u prolazu, ne samo naziv programa ./caesar, ali također ključ koji žele pomak njihov cisti strane. Dakle, to znači da argc moraju biti dva. Oni moraju proći two-- ništa više ni manje od dva argumente naredbenog retka. 

Sada, što je argv? Pa, mi već znamo da je polje će biti dužine dva, ali ono što je sadržano u svakom elementu? Pa, prvi element će biti ./caesar, a onda sljedeći element koji će se sadrži ključ koji je korisnik upisali u. Sada, ako su ga se koristi ispravno za korištenje Cezara, onda oni će upisati broj. No, iako je karaktera da tip je broj, to je od tipa podataka string. 

Pa kako ćemo pretvoriti da string na cijeli broj? Tako da imam broj, niz, sadrži niz 50. Ako želim pretvoriti da u cijeli broj, onda sam jednostavno proglasiti novu varijablu cijeli broj ja, pozivajući atoi. I prođe u mom string varijablu broj, a onda ću onda redni broj 50. Svakako provjerite čovjeka stranice za funkciju atoi provjeriti koje knjižnica je u, kao što je to vrijednost vratit će se ako je string prošao u ne sadrži sve brojeve. 

Sada kada smo stečen ključ, sljedeći korak je da se cisti od korisnika. Sada, to će biti manje komplicirana od navigacije oko argumente naredbenog retka. Sve što morate učiniti je poziv funkcija getstring potaknuti korisnika da daju nas niz, ali ne zaboravite provjeriti specifikacije po kojima bismo možda žele brz korisnik za to. 

Sada smo došli do Srce problem-- Kako za šifriranje na čistim. Pa, kao prvo, pričajmo o tome za šifriranje jedan znak na vrijeme, a zatim ćemo se obratiti kako ponoviti po cijeloj čistim. Napisao sam neki pseudokod za Caesar problem. Ja vas potaknuti da Napišite vlastiti, kao dobro. To ne može izgledati identično mina, i to je u redu, ali sve dok kao opće ideje je isti. 

Prva tri koraka već smo učinili. Mi smo stečen ključ iz komandna linija argument, mi smo se okrenuo taj ključ u cijeli broj, a mi smo zatraži od korisnika za čistim da žele šifriranje. Pa onda sljedeći veliki komad je da za svaki znak u čistim niza, ako je traka, želimo sačuvati njegov slučaj i pomak. Do sačuvati slučaj, što sam znači da je sve velika slova slova treba ostati Gornji Slučaj i sve mala slova treba ostati mala. Dakle, nakon što smo pomak one, onda ćemo ispisati šifrirana. 

Ovdje su tri funkcije koje će doći u ruci za ovaj problem. Sjeti se iznad kad sam dao Primjer za pomicanje ovo je CS50? Sjeti se da je 50 i uskličnik nije pomak? Pa kako možemo reći da li mi treba da promijenimo pismo ili ne? Pa, "alfa", ako što je to lik prođe, vratit će se vrijedi ako taj lik je pismo i lažno drugačije. Da bi vam pomoći s očuvanje kapitalizacija su funkcije "se gornja "i" niži ". 

Ove dvije funkcije također uzeti u jednom karaktera kao ulaz i vratiti vam Boolean, true ili false ovisno o tome je li taj lik je veliko ili malo slovo. Budući da "je gornja" i "je niži "su Booleova funkcija, što znači da su vam vratiti Boolean, možete koristiti ove u svojim uvjetima. Dakle, ovdje je isječak koda koji samo ispisuje slovo ako je gornji slučaj. Tako sam proglasio moj karakter Pismo se gornji slučaj zed i onda ako "je gornji" povrati istina, onda sam ispisati pismo. 

Vraćajući se na naše jednostavnom primjeru prebacuje abecedu pomoću ključa za dva, Kako ćemo zaista dobiti taj posao? Pa, ispada da likovi i cijeli brojevi su vrlo usko povezani. Svaki lik ima cijeli broj povezan uz to naći u ASCII tablicu, gdje je svaki lik u ASCII Prikazuje vrijednost. Tako da se velika slova A odgovara da ASCII vrijednost od 65 i mala slova a da ASCII vrijednost od 97. 

Slobodno pogledati bilo ASCII tablica na internetu vidjeti te vrijednosti za sebe. Dakle, što to znači da možemo uzeti karakter velika slova A, dodati cijeli broj dva na njega, a zatim se znak velika slova C kao rezultat. To je zato 65, ASCII Vrijednost za kapitalne A, plus 2, daje nam 67, što odgovara karakteru gornjeg slučaja C. 

Nažalost, stvari neće baš biti tako jednostavna. Imamo jednadžbu koja moramo uzeti u obzir. Evo što nam govori da je i-tog šifrirana Pismo odgovara i-tog otvorenog teksta pismo, plus key-- sve to, modularni 26. Zašto je to tako? Vratimo se našem primjeru iz prije, gdje je glavni A, plus 2, daje nam kapital C. 

Dakle, primjenom jednadžbe koja specifikacija nam daje, onda uzmimo kapitalu plus 2 i mod da do 26. Dakle, glavni A, kada sam ga stavio u ti navodnika, mi omogućuje da ga tretiraju kao cijeli broj, tako da se dopušta mi da ga baci u svoj ASCII vrijednosti, 65. 65 plus 2 je 67. 67 mod 26 daje nam 15, ali to ne stvarno smisla, jer znamo da je kapital C ASCII vrijednost 67, a ne 15. Pa kako ćemo pomiriti to? 

Pa, ovdje bih naciju Pojam abecedi indeksa. Dakle, već smo razgovarali o tome kako svaki lik ima svoj ASCII vrijednost, ali ja bih reći, dobro, neka je razmišljati o tome svaki lik također imaju abecedni indeks, gdje su A, na primjer, kao prvo slovo abecede, ima abecedni indeks nula. Dakle, sada ćemo primijeniti Ista jednadžba kao i prije, ali pomoću abecednog kazala. 

Tako je nula, kao što smo definirano. Pa onda da nula plus dva, mod 26, to je dva, mod 26, što nam daje dva. I dobro, s obzirom na abecedni indeks, C je treće slovo u abeceda, da bi odgovaralo do abecedni popis dvoje. Tako se čini da pomoću abecedni popis u ovom slučaju zapravo nam daje ispravan rezultat. 

Dakle, sada ćemo provjeriti vidjeti ako je jednadžba djela s abecednim indeksa. Y je abecedni indeks je 24 kao Drugi na zadnju riječ u abecede. Dakle 24 plus naš Ključ od dva daje nam 26. 26 mod 26 daje nam 0, koji je, na sreću za nas, je abecedni indeks za A. Dakle, nadam se da je dovoljno da je dokaz abecedni metoda indeks radi. Ako ne, slobodno isprobati neki primjeri svoj vlastiti. 

Da bi se pravilno omotati oko abeceda i primijeniti Caesar jednadžbe, onda znamo da moramo bave abecednom indeksa. Ali mi početi s ASCII vrijednosti, a tek onda mi onda pretvoriti u abecedni indeks. Od tamo, kako bi se ispisati, moramo se nositi s ASCII vrijednostima opet. Dakle, moramo shvatiti kako ići od ASCII prema abecednom i od abecednom u ASCII. 

Tako sam ga ostaviti na vas shvatiti uzorak između lika a njegov abecedni Indeks i njegov ASCII vrijednost. Sada, sjetite se da, iako ova tablica pravo na zatvaraču pokazuje velika slova, mi također uzeti u obzir da li ili ne vrijedi drugačiji uzorak za malih slova. 

Dakle, sada kada smo shvatili kako prebaciti jedan znak, onda sve što morate učiniti je mjerilo koje spreman ići preko cijelog čistim. Tako je cisti je niz. Srećom po nas, niz je stvarno samo niz znakova, tako da bi mogli pristupiti svaki lik od niza, sve što morate učiniti je koristiti array zapis. Recimo imam varijablu tipa niz pod nazivom "text = 'Ovo je CS50." 

Onda, kako bi se pristupiti svaki lik, sve što ima veze s varijabla tekst reći dobro, tekst na indeksu nulu, da odgovara kapital T. Tekst na indeks jedan odgovara donjem slučaju h. Još jedna korisna funkcija funkcija Duljina niza. Tako prolaze u nizu na da je funkcija će se vratiti cijeli broj, duljina toga niza. 

Sada kada smo govorili o svi ti različiti elementi, neka je staviti ih zajedno. Tako se vratiti na bilo moje pseudokod broj ili tvoj pseudokod i proći i biti sigurni da vam znati kako to učiniti svaku stvar. Dobivanje ključ pomoću argc i argv, zakretanjem ključa u cijeli broj, A na i, što je navelo za čistim, getstring, a zatim ponavljanjem nad svakim lika u cisti string, očuvanje slučaj svaki znak i prebacujući taj lik pomoću ključa, osiguravajući da ste omotava oko abecede, napokon ispisivanja tog šifrirana. Moje ime je Amila, a to je Cezar. 