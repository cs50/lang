AMILA: Mari kita menangani Caesar. Dalam Caesar, kami membenarkan pengguna untuk mengekod mesej rahsia. Jadi mari kita menyelam kanan dalam dan melihat pada tugasan kami untuk masalah ini. Jadi pertama, kita akan mendapat kunci dari pengguna. Kemudian kami mendapatkan plaintext yang yang mereka mahu untuk mengekod. Selepas itu, kami menulis dlm kod untuk mereka, dan akhirnya kita mencetak tulisan rahsia mereka. 

Jadi mari kita mulakan dengan contoh. Katakanlah anda mahu mengekod abjad keseluruhan dengan kunci dua. Well, abjad keseluruhan anda akan hanya akan beralih kepada huruf. Jadi A akan mengekod kepada C, B untuk D, C hingga E, sebagainya dan sebagainya, sehingga anda sampai ke X, yang mengkod ke Z atau zed, bergantung kepada di mana anda daripada. Kemudian Y kemudian akan beralih sepanjang jalan, membungkus abjad untuk sampai ke A, dan akhirnya surat terakhir abjad, Z, zed, akan mengekod ke B. 

Anda mendapat bahawa? Mari kita lihat beberapa contoh. Contoh yang pertama di sini adalah hampir sama dengan apa yang kita hanya diterangkan di atas. Jadi jika saya mengekod beberapa bahagian daripada abjad, A hingga L, oleh kunci dua, maka saya hanya mendapat keseluruhan saya abjad beralih dua huruf. 

Kemudian, dalam contoh saya akan datang, kunci masih dua, jadi anda masih perlu tahu yang surat yang diharapkan. Tetapi di sini ia adalah frasa. Ini adalah CS50. Jadi, anda akan notis bahawa saya memelihara kes surat saya, jadi apa-apa huruf besar juga huruf besar dalam tulisan rahsia. Dan mana-mana huruf kecil huruf dalam plaintext yang juga huruf kecil huruf dalam tulisan rahsia. Tetapi saya terus huruf dan apa-apa tanda seru atau apa-apa tanda baca lain yang sama. 

Jadi sekarang kita mempunyai perasaan yang untuk bagaimana program ini berfungsi, berasa bebas untuk pergi menjalankan beberapa lebih contoh anda sendiri, jika anda mahu. Mari kita mulakan dengan mendapatkan kunci dari pengguna. Secara tradisinya, dengan masalah lain, kami telah sudah biasa dengan mendapat mana-mana nombor yang kita perlukan dengan mendorong pengguna dengan GetInt fungsi. Tetapi kali ini kita sebenarnya akan untuk menggunakan hujah baris arahan dan fungsi baru yang dipanggil atoi. 

Apabila anda menjalankan utama program dalam C, maka ia mengambil masa dalam dua parameters-- int argc, yang adalah bilangan hujah diluluskan pada, dan kemudian argv, pelbagai rentetan yang mengandungi senarai semua hujah-hujah berlalu. Anda tidak jelas mempunyai untuk mengisytiharkan pembolehubah ini. Mereka dikira bagi anda oleh pengkompil. penggunaan yang betul untuk ini akan menjadi untuk argc menjadi dua dalam kes ini, kerana pengguna mempunyai untuk lulus dalam panggilan untuk program ini, ./caesar, dan kemudian kunci, apa bilangan mereka mahu. Ini bermakna bahawa argc mesti dua dalam usaha untuk kegunaan yang sah Caesar yang akan dilaksanakan. 

Jadi mari kita lihat satu contoh. Mengatakan saya sudah menulis dan menyusun program yang dikenali sebagai BlastOff. Jadi jika saya berlari dalam baris arahan ./blastoff pasukan roket, baik, maka, argc akan menjadi tiga kerana saya diluluskan pada tiga hujah yang berbeza. Kemudian argv akan kelihatan seperti ini. Ia adalah pelbagai, dan ia akan mengandungi setiap satu daripada tiga tali. ./blastoff indeks, pasukan pertama di depan, dan roket di lepas. 

Mari kita bercakap tentang tatasusunan sekejap. Tatasusunan adalah struktur data yang memegang pelbagai nilai dari jenis yang sama. Ini boleh datang dalam berguna apabila kita mempunyai senarai integer atau tali. Hanya ingat mereka mempunyai menjadi jenis yang sama. Dalam sains komputer, kita suka mengira dari sifar, jadi ingat bahawa tatasusunan juga sifar diindeks. Jadi elemen pertama pelbagai saya akan menjadi pada indeks sifar. Jadi dalam kes ini, apabila saya mempunyai pelbagai panjang empat, maka indeks terakhir elemen terakhir pelbagai saya sebenarnya akan menjadi pada indeks tiga, bukan empat. Kerana ingat, kita mula mengira pada sifar. 

Berikut adalah contoh bagaimana anda mungkin mewujudkan pelbagai anda sendiri. Jadi mengatakan saya mahu menyimpan saya tiga nama anjing kegemaran. Kemudian saya akan mewujudkan pelbagai rentetan. Jadi, saya akan mengisytiharkan jenis, tali, dan kemudian meletakkan nama array, anjing, dan kemudian di dataran yang kurungan meletakkan saiz daripada array-- dalam kes ini, tiga. 

Jadi kemasukan pertama saya akan menjadi anjing pada indeks sifar, dan itu akan menjadi Milo. Kemudian Anjing pada indeks satu akan menjadi bodoh, darling Mochi, dan kemudian yang terakhir kemasukan, pintu yang ketiga pada indeks dua, akan menjadi comel, manis Elphie. Anda akan melihat bahawa format untuk mengisi dalam pelbagai ini adalah seperti bagaimana anda boleh mengisytiharkan mana-mana pembolehubah lain di mana anda mempunyai nama pembolehubah diikuti oleh nilai yang anda mahu disimpan di dalamnya. Satu-satunya perbezaan dalam kes ini adalah bahawa anda perlu ingat untuk meletakkan indeks nilai dalam kurungan persegi. Dan kita ada kami tiga anjing kegemaran. 

Tetapi malangnya, ia adalah masa untuk kembali kepada Kaisar. Ingat bahawa penggunaan yang betul bagi pengguna akan dapat lulus dalam bukan sahaja nama ./caesar program ini, tetapi juga kunci yang mereka mahu beralih plaintext mereka dengan. Ini bermakna bahawa argc mesti dua. Mereka mesti lulus dalam two-- tidak lebih, tidak kurang daripada dua hujah baris arahan. 

Sekarang, bagaimana pula argv? Nah, kita sudah tahu bahawa pelbagai akan menjadi panjang dua, tetapi apa yang terkandung dalam setiap elemen? Well, elemen pertama akan menjadi ./caesar, dan kemudian elemen seterusnya akan mengandungi kunci yang pengguna ditaip. Sekarang, jika mereka menggunakan dengan betul untuk kegunaan Caesar, kemudian mereka akan menaip nombor. Tetapi walaupun watak bahawa mereka menaip nombor, ia adalah jenis data rentetan. 

Jadi bagaimana kita menukar yang rentetan kepada integer? Jadi mengatakan saya mempunyai num, rentetan, yang mengandungi rentetan 50. Jika saya mahu menukar yang kepada integer, maka saya hanya mengisytiharkan pembolehubah baru, integer i, memanggil atoi. Saya lulus dalam pembolehubah rentetan saya, num, dan kemudian saya akan mengandungi nombor 50. Pastikan untuk memeriksa lelaki itu muka surat untuk fungsi atoi yang untuk memeriksa perpustakaan itu dalam, dan juga apa yang menghargainya akan kembali jika rentetan diluluskan dalam tidak mengandungi semua nombor. 

Jadi sekarang kita telah mendapat kunci, langkah seterusnya adalah untuk mendapatkan plaintext dari pengguna. Sekarang, ini akan menjadi lebih mudah daripada mengemudi sekitar hujah baris arahan. Apa yang perlu kita lakukan adalah panggilan fungsi getstring yang untuk meminta pengguna untuk memberikan kita rentetan, tetapi ingat untuk memeriksa spesifikasi untuk bagaimana kita mungkin mahu meminta pengguna untuk itu. 

Sekarang kita sampai kepada tengah-tengah problem-- yang bagaimana untuk menulis dlm kod plaintext itu. Well, pertama, mari kita bercakap tentang bagaimana untuk menulis dlm kod satu aksara pada satu masa, dan kemudian kami akan menangani bagaimana untuk melelar atas seluruh plaintext itu. Saya telah menulis beberapa kod pseudo untuk masalah Caesar. Saya menggalakkan anda untuk tulis sendiri juga. Ia mungkin tidak kelihatan sama dengan saya, dan tidak apa-apa, tetapi selagi sebagai idea umum adalah sama. 

Tiga langkah pertama kami telah bekerja di. Kami telah mendapat kunci dari hujah baris arahan, kami telah berpaling kunci yang ke dalam integer, dan kami telah mendorong pengguna untuk plaintext yang bahawa mereka mahu menulis dlm kod. Oleh itu, maka sebahagian besar yang akan datang adalah bahawa untuk setiap watak dalam rentetan plaintext, jika ia abjad, kita mahu mengekalkan kes dan beralih. Dengan memelihara kes, apa yang saya maksudkan adalah bahawa semua huruf besar surat harus kekal atas kes dan semua huruf kecil perlu kekal kecil. Sebab itu selepas kita beralih itu, maka kita mencetak tulisan rahsia. 

Berikut adalah tiga fungsi yang akan datang berguna untuk masalah ini. Ingat sehingga di atas apabila aku memberikan contoh untuk beralih ini adalah CS50? Ingatlah bahawa 50 dan tanda seru tidak beralih? Jadi bagaimana kita boleh memberitahu sama ada kita perlu beralih surat atau tidak? Nah, "adalah alpha," jika anda lulus watak, akan kembali benar jika watak yang adalah surat dan palsu sebaliknya. Untuk membantu anda dengan memelihara permodalan adalah fungsi "adalah atas "dan" lebih rendah. " 

Kedua-dua fungsi juga mengambil dalam watak tunggal sebagai input dan anda akan kembali Boolean, sama ada benar atau palsu bergantung kepada sama ada watak yang adalah huruf besar atau huruf kecil. Kerana "adalah atas" dan "adalah lebih rendah "adalah fungsi Boolean, yang bererti bahawa mereka mengembalikan kamu yang Boolean, anda boleh menggunakan ini dalam keadaan anda. Jadi di sini adalah coretan kod yang hanya mencetak surat jika ia huruf besar. Jadi saya telah diisytiharkan watak saya bertulis ke kes atas zed dan kemudian jika "adalah atas" pulangan benar, maka saya mencetak surat itu. 

Kembali kepada contoh mudah kami beralih abjad dengan kunci dua, bagaimana kita benar-benar mendapatkan yang bekerja? Nah, ternyata bahawa watak-watak dan bilangan bulat sangat berkait rapat. Setiap watak mempunyai nilai integer yang berkaitan dengan itu dijumpai di dalam carta ASCII, mana ASCII setiap watak itu nilai dipaparkan. Jadi satu huruf sepadan A kepada nilai ASCII 65 dan huruf kecil untuk nilai ASCII 97. 

Jangan ragu untuk melihat ke atas mana-mana carta ASCII talian untuk melihat nilai-nilai ini untuk diri sendiri. Jadi apa ini bermakna bahawa kita boleh mengambil watak huruf besar A, menambah integer dua kepadanya, dan kemudian mendapatkan watak atas kes C akibat. Ini kerana 65, ASCII Nilai untuk modal A, campur 2, memberikan kita 67, yang sepadan kepada watak huruf C. 

Malangnya, perkara tidak akan cukup menjadi begitu mudah. Kami mempunyai persamaan yang kita perlu mempertimbangkan. Di sini ia memberitahu kita bahawa tulisan rahsia-i surat sepadan dengan plaintext engan surat, ditambah key-- yang semua itu, modular 26. Mengapa keadaan tersebut berlaku? Mari kita kembali kepada contoh dari sebelum ini, di mana modal A, campur 2, memberikan kita modal C. 

Jadi menggunakan persamaan yang spesifikasi yang memberikan kita, maka mari kita mengambil modal A ditambah 2 dan mod dengan 26. Jadi modal A, apabila saya memasukkannya ke dalam mereka tanda petikan tunggal, membolehkan saya untuk merawat sebagai integer, supaya membolehkan saya melemparkannya kepada nilai ASCII kemuncak, 65. 65 campur 2 ialah 67. 67 mod 26 memberikan kita 15, tetapi itu tidak benar-benar masuk akal kerana kita tahu bahawa modal C nilai ASCII adalah 67, bukan 15. Jadi bagaimana kita mendamaikan itu? 

Nah, di sini saya ingin menempatkan yang tanggapan indeks mengikut abjad. Oleh itu, kita telah bercakap tentang bagaimana setiap watak mempunyai nilai ASCII itu, tetapi saya ingin berkata, baik, mari kita berfikir tentang setiap watak juga mempunyai indeks mengikut abjad, di mana A misalnya, sebagai huruf pertama abjad, mempunyai indeks mengikut abjad sifar. Jadi sekarang mari kita memohon Persamaan yang sama seperti sebelum ini, tetapi menggunakan indeks mengikut abjad. 

Jadi A adalah sifar, seperti yang kita telah ditakrifkan. Sebab itu mengambil sifar campur dua, mod 26, yang dua, mod 26, yang memberikan kita dua. Dan juga, dari segi indeks mengikut abjad, C adalah huruf ketiga dalam abjad, supaya akan sesuai kepada indeks abjad dua. Oleh itu, ia seolah-olah bahawa menggunakan indeks mengikut abjad dalam kes ini sebenarnya memberikan kita keputusan yang betul. 

Jadi sekarang mari kita lihat kepada melihat jika kerja-kerja persamaan dengan indeks abjad. indeks abjad Y adalah 24 sebagai kedua untuk surat terakhir dalam abjad. Oleh itu, maka 24 plus kami utama dua memberikan kita 26. 26 mod 26 memberikan kita 0, yang, bertuah untuk kita, adalah indeks abjad untuk A. Jadi diharapkan itu sudah cukup bahawa bukti kaedah indeks abjad berfungsi. Jika tidak, jangan ragu untuk mencuba beberapa contoh anda sendiri. 

Untuk betul membalut sekitar abjad dan menggunakan persamaan Caesar, maka kita tahu bahawa kita perlu menangani indeks abjad. Tetapi kita mulakan dengan ASCII nilai-nilai, dan hanya kemudian kita kemudian memeluk indeks abjad. Dari situ, untuk mencetak, kita perlu untuk berurusan dengan nilai ASCII lagi. Oleh itu, kita perlu memikirkan bagaimana untuk pergi dari ASCII untuk abjad dan dari abjad untuk ASCII. 

Jadi saya serahkan kepada anda untuk memikirkan corak di antara watak dan abjad yang indeks dan nilai ASCII itu. Sekarang, ingat bahawa walaupun jadual ini tepat pada slaid menunjukkan huruf besar, kami juga perlu mengambil kira sama ada atau tidak corak yang berbeza dikenakan untuk watak-watak huruf kecil. 

Jadi sekarang kita telah anda ketahui bagaimana untuk beralih watak tunggal, maka apa yang harus kita lakukan adalah skala yang sehingga pergi di seluruh plaintext itu. Jadi plaintext adalah rentetan. Bagi kita sekarang, rentetan adalah benar-benar hanya pelbagai aksara, jadi untuk mengakses setiap watak tali, semua yang anda perlu lakukan adalah dengan menggunakan pelbagai notasi. Katakanlah saya mempunyai pembolehubah jenis rentetan dipanggil "text = 'ini adalah CS50." 

Nah, kemudian, untuk mengakses setiap watak, semua yang saya perlu lakukan dengan teks yang berubah-ubah adalah untuk mengatakan baik, teks pada indeks sifar, yang sepadan dengan modal T. Teks pada indeks satu sepadan dengan mana-mana yang h lebih rendah. Satu lagi fungsi yang berguna adalah fungsi panjang tali. Jadi lulus dalam rentetan kepada fungsi yang akan kembali integer, panjang tali itu. 

Sekarang kita telah bercakap tentang semua unsur-unsur yang berbeza, mari kita meletakkan mereka kembali bersama-sama. Jadi kembali ke sama ada pseudokod saya kod atau pseudokod anda dan pergi melalui dan memastikan bahawa anda tahu bagaimana untuk melakukan setiap perkara. Mendapatkan kunci menggunakan argc dan argv, beralih kunci ke dalam integer, yang untuk i, menggesa untuk plaintext, getstring, dan kemudian iterating atas setiap watak dalam tali plaintext, memelihara kes setiap watak dan beralih watak dengan kekunci, memastikan bahawa anda melingkari abjad, akhirnya mencetak tulisan rahsia itu. Nama saya Amila, dan ini adalah Caesar. 