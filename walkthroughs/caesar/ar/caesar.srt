1
00:00:00,000 --> 00:00:00,760

2
00:00:00,760 --> 00:00:02,270
>> AMILA: دعونا معالجة قيصر.

3
00:00:02,270 --> 00:00:06,110
في قيصر، نحن تسمح للمستخدم
لتشفير رسالة سرية.

4
00:00:06,110 --> 00:00:09,780
لذلك دعونا الغوص الحق في والبحث
في جهدنا لدوس لهذه المشكلة.

5
00:00:09,780 --> 00:00:12,210
لذلك أولا، نحصل على مفتاح من المستخدم.

6
00:00:12,210 --> 00:00:15,210
ثم نحصل على نص عادي
انهم يريدون لترميز.

7
00:00:15,210 --> 00:00:21,380
بعد ذلك، ونحن شفر ذلك بالنسبة لهم،
وأخيرا فإننا طباعة النص المشفر بهم.

8
00:00:21,380 --> 00:00:23,600
>> لذلك دعونا نبدأ مع مثال على ذلك.

9
00:00:23,600 --> 00:00:26,920
يقول أنك أردت ترميز
الأبجدية كاملة مع مفتاح اثنين.

10
00:00:26,920 --> 00:00:31,360
حسنا، سوف الأبجدية بأكملها
مجرد أن تحول إلى حروف.

11
00:00:31,360 --> 00:00:37,060
لذلك سوف ترميز إلى C، B ل
D، C إلى E، هلم جرا وهكذا دواليك،

12
00:00:37,060 --> 00:00:42,470
حتى تحصل على X، الذي يشفر الألف إلى الياء
أو زيد، اعتمادا على من أين أنت.

13
00:00:42,470 --> 00:00:47,445
بعد ذلك Y ثم تحول كل وسيلة،
التفاف حول الأبجدية للوصول الى هناك،

14
00:00:47,445 --> 00:00:53,256
ثم أخيرا الحرف الأخير من
الأبجدية، Z، زيد، أن ترميز إلى B.

15
00:00:53,256 --> 00:00:54,660
>> فهمت ذلك؟

16
00:00:54,660 --> 00:00:56,380
دعونا نلقي نظرة على بعض الأمثلة.

17
00:00:56,380 --> 00:01:00,540
المثال الأول هنا هي مشابهة جدا
ما شرحنا فوق.

18
00:01:00,540 --> 00:01:05,560
حتى لو كنت ترميز بعض جزء من
الأبجدية، ومن خلال L، بواسطة مفتاح من اثنين،

19
00:01:05,560 --> 00:01:09,760
ثم أنا مجرد الحصول على بلدي كامل
انتقلت الأبجدية رسالتين.

20
00:01:09,760 --> 00:01:12,230
>> ثم، في بلدي على سبيل المثال المقبل،
والمفتاح هو لا يزال اثنين،

21
00:01:12,230 --> 00:01:15,080
لذلك يجب أن لا تزال تعرف
الذي رسائل الى نتوقع.

22
00:01:15,080 --> 00:01:16,400
ولكن هنا انها عبارة.

23
00:01:16,400 --> 00:01:18,100
هذا هو CS50.

24
00:01:18,100 --> 00:01:21,090
لذلك عليك أن تلاحظ أنني
الحفاظ على حالة من رسائلي،

25
00:01:21,090 --> 00:01:25,600
لذلك أي الأحرف الكبيرة هي أيضا
حالة الأحرف في النص المشفر.

26
00:01:25,600 --> 00:01:27,800
وأي صغيرة
الرسائل في نص عادي

27
00:01:27,800 --> 00:01:30,640
وأحرف صغيرة أيضا
الحروف في النص المشفر.

28
00:01:30,640 --> 00:01:34,020
ولكن أظل الحروف
وأي علامات التعجب

29
00:01:34,020 --> 00:01:37,610
أو أي علامات الترقيم الأخرى نفس الشيء.

30
00:01:37,610 --> 00:01:40,360
>> حتى الآن أن لدينا إحساس
لكيفية عمل البرنامج،

31
00:01:40,360 --> 00:01:43,890
لا تتردد في الذهاب تشغيل بعض أكثر
أمثلة خاصة بك، إذا كنت ترغب في ذلك.

32
00:01:43,890 --> 00:01:47,072
دعونا نبدأ مع الحصول على
المفتاح من قبل المستخدم.

33
00:01:47,072 --> 00:01:48,780
تقليديا، مع
مشاكل أخرى، لدينا

34
00:01:48,780 --> 00:01:51,450
تم اعتادوا على الحصول على
أي الأرقام التي لدينا

35
00:01:51,450 --> 00:01:54,710
تحتاج إليها عن طريق مطالبة المستخدم
مع getint وظيفة.

36
00:01:54,710 --> 00:01:58,850
ولكن هذه المرة نحن ذاهبون فعلا
استخدام وسيطة سطر الأوامر

37
00:01:58,850 --> 00:02:01,760
وظيفة جديدة تسمى atoi.

38
00:02:01,760 --> 00:02:05,130
>> عند تشغيل الرئيسي
برنامج في C، ثم

39
00:02:05,130 --> 00:02:08,500
يأخذ في اثنين parameters--
ARGC كثافة العمليات، التي

40
00:02:08,500 --> 00:02:11,670
هو عدد من الحجج
صدر في، ومن ثم

41
00:02:11,670 --> 00:02:15,920
ARGV، مجموعة من السلاسل التي تحتوي على
قائمة بجميع الحجج

42
00:02:15,920 --> 00:02:16,740
مرت.

43
00:02:16,740 --> 00:02:19,740
لم يكن لديك صراحة
ليعلن هذه المتغيرات.

44
00:02:19,740 --> 00:02:22,700
انهم حسابها ل
كنت من قبل المجمع.

45
00:02:22,700 --> 00:02:28,160
ان الاستخدام الصحيح لهذا أن يكون
لARGC أن يكون اثنين في هذه الحالة،

46
00:02:28,160 --> 00:02:32,630
لأن المستخدم أن تمر في
الدعوة إلى البرنامج، ./caesar،

47
00:02:32,630 --> 00:02:35,570
ثم مفتاح،
أيا كان عدد رغبوا في ذلك.

48
00:02:35,570 --> 00:02:39,920
وهذا يعني أن ARGC يجب أن يكون اثنين
من أجل استخدام صحيح للقيصر

49
00:02:39,920 --> 00:02:41,680
ليتم تنفيذها.

50
00:02:41,680 --> 00:02:43,590
>> لذلك دعونا ننظر على سبيل المثال.

51
00:02:43,590 --> 00:02:47,760
أقول لقد كتبت بالفعل و
جمعت برنامج يسمى من انطلاقه.

52
00:02:47,760 --> 00:02:52,670
حتى إذا ركضت في سطر الأوامر
./blastoff صاروخ فريق، حسنا، ثم،

53
00:02:52,670 --> 00:02:57,750
ARGC سيكون ثلاثة لأنني
مرت في ثلاث حجج مختلفة.

54
00:02:57,750 --> 00:02:59,830
ثم ARGV ستبدو هذه.

55
00:02:59,830 --> 00:03:03,750
انها مجموعة، وذلك من شأنه
يحتوي كل من السلاسل الثلاثة.

56
00:03:03,750 --> 00:03:09,640
./blastoff في المؤشر الأول، فريق
في القادم، والصواريخ في الماضي.

57
00:03:09,640 --> 00:03:11,610
>> دعونا نتحدث عن المصفوفات لثانية.

58
00:03:11,610 --> 00:03:15,560
المصفوفات هي هياكل البيانات التي تحمل
قيم متعددة من نفس النوع.

59
00:03:15,560 --> 00:03:19,980
هذا يمكن أن تأتي في متناول اليدين عندما كنا
لدينا قوائم من الأعداد الصحيحة أو سلاسل.

60
00:03:19,980 --> 00:03:23,030
فقط تذكر لديهم
أن تكون من نفس النوع.

61
00:03:23,030 --> 00:03:25,310
في علوم الكمبيوتر، ونحن
أحب العد من الصفر،

62
00:03:25,310 --> 00:03:29,260
لذلك تذكر أن المصفوفات
أيضا عدم فهرستها.

63
00:03:29,260 --> 00:03:34,360
ولذلك فإن العنصر الأول من بلدي مجموعة
سوف تكون على مؤشر الصفر.

64
00:03:34,360 --> 00:03:37,580
حتى في هذه الحالة، عندما يكون لدي
مجموعة من طول أربعة،

65
00:03:37,580 --> 00:03:41,350
ثم مؤشر الأخير من
العنصر الأخير من بلدي مجموعة

66
00:03:41,350 --> 00:03:44,970
يجري فعلا أن يكون
في مؤشر ثلاثة، وليس أربعة.

67
00:03:44,970 --> 00:03:48,880
لأن نتذكر، نحن
بدء العد عند مستوى الصفر.

68
00:03:48,880 --> 00:03:52,530
>> وهنا مثال على كيف
قد تخلق مجموعة خاصة بك.

69
00:03:52,530 --> 00:03:56,440
لذلك أقول إنني أردت تخزين بلدي
ثلاثة أسماء الكلب المفضلة.

70
00:03:56,440 --> 00:03:59,030
ثم أود أن إنشاء مجموعة من السلاسل.

71
00:03:59,030 --> 00:04:04,450
لذلك أود أن أعلن نوع، سلسلة، و
ثم وضع اسم مجموعة، الكلاب،

72
00:04:04,450 --> 00:04:06,450
وبعد ذلك في تلك الساحة
بين قوسين وضعت حجم

73
00:04:06,450 --> 00:04:09,260
من array-- في هذه الحالة، ثلاثة.

74
00:04:09,260 --> 00:04:12,690
>> لذلك أول دخول لي يجري
أن تكون الكلاب في مؤشر الصفر،

75
00:04:12,690 --> 00:04:14,750
والتي ستكون ميلو.

76
00:04:14,750 --> 00:04:17,850
ثم الكلاب في مؤشر واحد
سيكون أحمق،

77
00:04:17,850 --> 00:04:23,060
حبيبي موتشي، ثم آخر
دخول، المدخل الثالث في الفهرس اثنين،

78
00:04:23,060 --> 00:04:26,130
سيكون لطيف، والحلو Elphie.

79
00:04:26,130 --> 00:04:28,610
ستلاحظ أن شكل
لملء هذه المجموعة

80
00:04:28,610 --> 00:04:32,150
تشبه إلى حد كبير الطريقة التي قد
الإعلان عن أي متغير آخر حيث

81
00:04:32,150 --> 00:04:36,307
لديك اسم المتغير تليها
القيمة التي تريد تخزينها فيه.

82
00:04:36,307 --> 00:04:38,140
والفرق الوحيد في
هذه الحالة هي أنك

83
00:04:38,140 --> 00:04:42,700
علينا أن نتذكر لوضع مؤشر
من قيمة بين قوسين معقوفين.

84
00:04:42,700 --> 00:04:46,420
وهناك لدينا
ثلاثة كلاب المفضلة.

85
00:04:46,420 --> 00:04:48,780
>> ولكن للأسف، لقد حان الوقت
لنعود لقيصر.

86
00:04:48,780 --> 00:04:52,910
تذكر أن الاستخدام الصحيح لل
المستخدم سوف يتم تمرير ليس فقط

87
00:04:52,910 --> 00:04:57,430
اسم ./caesar البرنامج، ولكن
أيضا المفتاح الذي يريدون تحويل

88
00:04:57,430 --> 00:04:58,850
عادي من قبل.

89
00:04:58,850 --> 00:05:01,540
وهذا يعني أن ARGC يجب أن يكون اثنين.

90
00:05:01,540 --> 00:05:07,580
يجب أن يمر في two-- لا أكثر ولا
أقل من اثنين من وسائط سطر الأوامر.

91
00:05:07,580 --> 00:05:09,050
>> الآن، ماذا عن ARGV؟

92
00:05:09,050 --> 00:05:12,880
حسنا، نحن نعرف بالفعل أن
مجموعة ستكون من طول اثنين،

93
00:05:12,880 --> 00:05:15,270
ولكن ما يرد في كل عنصر؟

94
00:05:15,270 --> 00:05:19,330
حسنا، العنصر الأول
سيكون ./caesar،

95
00:05:19,330 --> 00:05:24,190
ثم العنصر التالي سوف
تحتوي على مفتاح أن المستخدم كتابة في.

96
00:05:24,190 --> 00:05:27,480
الآن، إذا ما استخدمت بشكل صحيح
لاستخدام قيصر،

97
00:05:27,480 --> 00:05:29,350
ثم انهم ذاهبون لكتابة رقم.

98
00:05:29,350 --> 00:05:33,260
ولكن على الرغم من أن شخصية
أنهم اكتب هو رقم،

99
00:05:33,260 --> 00:05:35,790
انها من نوع بيانات سلسلة.

100
00:05:35,790 --> 00:05:40,390
>> لذلك كيف يمكننا تحويل ذلك
سلسلة إلى عدد صحيح؟

101
00:05:40,390 --> 00:05:46,680
أقول ذلك لدي الأسطوانات، سلسلة،
تتضمن السلسلة 50.

102
00:05:46,680 --> 00:05:49,000
إذا كنت ترغب في تحويل هذه
إلى عدد صحيح، ثم أنا ببساطة

103
00:05:49,000 --> 00:05:53,340
تعريف متغير جديد، وهو
عدد صحيح ط، داعيا atoi.

104
00:05:53,340 --> 00:06:01,160
أمرر في متغير سلسلة بلدي، الأسطوانات، و
وبعد ذلك سوف ثم تحتوي على رقم 50.

105
00:06:01,160 --> 00:06:04,350
تأكد للتحقق من الرجل
صفحات للوظيفة atoi

106
00:06:04,350 --> 00:06:07,990
للتحقق من مكتبة انها
في، وكذلك ما يقدرون عليه

107
00:06:07,990 --> 00:06:14,550
سيعود إذا مرت سلسلة
في لا يحتوي على جميع الأرقام.

108
00:06:14,550 --> 00:06:16,950
>> حتى الآن بعد أن حصلنا على
المفتاح، فإن الخطوة التالية

109
00:06:16,950 --> 00:06:19,430
هو الحصول على نص عادي من المستخدم.

110
00:06:19,430 --> 00:06:21,170
الآن، هذا هو الذهاب الى
تكون أقل تعقيدا

111
00:06:21,170 --> 00:06:23,410
من التنقل في جميع أنحاء
وسائط سطر الأوامر.

112
00:06:23,410 --> 00:06:26,190
كل ما علينا فعله هو الدعوة
وظيفة getstring

113
00:06:26,190 --> 00:06:29,660
مطالبة المستخدم لإعطاء
لنا سلسلة، ولكن تذكر

114
00:06:29,660 --> 00:06:34,090
للتحقق من مواصفات لكيفية
قد ترغب في مطالبة المستخدم لذلك.

115
00:06:34,090 --> 00:06:36,420
>> الآن نأتي إلى
قلب problem--

116
00:06:36,420 --> 00:06:38,860
كيفية شفر النص الأصلي.

117
00:06:38,860 --> 00:06:42,830
حسنا، أولا، دعونا نتحدث عن كيفية
لشفر حرف واحد في وقت واحد،

118
00:06:42,830 --> 00:06:47,370
وبعد ذلك سنقوم معالجة كيفية
تكرار عبر عادي بأكمله.

119
00:06:47,370 --> 00:06:50,440
لقد كتبت بعض شبة الكود
للمشكلة قيصر.

120
00:06:50,440 --> 00:06:52,310
أنا أشجعكم على
الكتابة الخاصة بك أيضا.

121
00:06:52,310 --> 00:06:55,900
قد لا تبدو متطابقة ل
الألغام، وهذا موافق، ولكن طالما

122
00:06:55,900 --> 00:06:58,640
والفكرة العامة هي نفسها.

123
00:06:58,640 --> 00:07:00,780
>> الخطوات الثلاث الأولى
قمنا به بالفعل.

124
00:07:00,780 --> 00:07:03,100
لقد حصلت على مفتاح من
وسيطة سطر الأوامر،

125
00:07:03,100 --> 00:07:05,510
لقد تحول هذا المفتاح
إلى عدد صحيح، ولقد

126
00:07:05,510 --> 00:07:09,320
مطالبة المستخدم للعادي
انهم يريدون شفر.

127
00:07:09,320 --> 00:07:12,420
لذلك فإن جزءا كبيرا القادمة
غير أن لكل حرف

128
00:07:12,420 --> 00:07:15,070
في سلسلة مشفرة،
اذا كان أبجدية،

129
00:07:15,070 --> 00:07:17,750
نحن نريد للحفاظ على
القضية والتي تحول إليها.

130
00:07:17,750 --> 00:07:20,900
من خلال الحفاظ على الحالة، ما أنا
يعني أن كل حالة العلوي

131
00:07:20,900 --> 00:07:23,580
وينبغي أن تظل الرسائل العلوي
القضية وكافة الأحرف الصغيرة

132
00:07:23,580 --> 00:07:25,640
ينبغي أن تظل صغيرة.

133
00:07:25,640 --> 00:07:29,110
حتى ذلك الحين بعد أن تحول تلك،
ثم نحن طباعة النص المشفر.

134
00:07:29,110 --> 00:07:33,100
>> وفيما يلي ثلاث وظائف التي تجري
لتكون في متناول اليدين لهذه المشكلة.

135
00:07:33,100 --> 00:07:38,010
تذكر حتى أعلاه عندما أعطى
مثال لتحويل هذا هو CS50؟

136
00:07:38,010 --> 00:07:41,800
تذكر أن 50 و
لم علامة تعجب لا تتغير؟

137
00:07:41,800 --> 00:07:45,680
فكيف يمكن أن نقول ما إذا كنا
تحتاج إلى تحويل بريد إلكتروني أو لا؟

138
00:07:45,680 --> 00:07:48,650
حسنا، "هو ألفا،" إذا
يمكنك تمرير أنه حرف،

139
00:07:48,650 --> 00:07:54,850
سيعود صحيح إذا كان هذا الطابع
هو خطاب وكاذبة خلاف ذلك.

140
00:07:54,850 --> 00:07:56,870
لمساعدتك في
الحفاظ على رأس المال

141
00:07:56,870 --> 00:07:59,750
هي وظائف "و
العلوي "و" هو أقل ".

142
00:07:59,750 --> 00:08:03,350
>> هاتين الوظيفتين أيضا أن تأخذ
في حرف واحد كمدخل

143
00:08:03,350 --> 00:08:06,580
ونعود لكم منطقية،
إما صحيحة أو خاطئة

144
00:08:06,580 --> 00:08:11,280
اعتمادا على ما إذا كان هذا الحرف
هي حالة العلوي أو السفلي القضية.

145
00:08:11,280 --> 00:08:14,610
لأن "هو الجزء العلوي" و "غير
أقل "هي وظائف منطقية،

146
00:08:14,610 --> 00:08:18,660
وهذا يعني أن يردوكم منطقية،
يمكنك استخدام هذه في ظروف الخاصة بك.

147
00:08:18,660 --> 00:08:23,490
حتى هنا مقتطف من التعليمات البرمجية التي فقط
طباعة بريد إلكتروني إذا كان الحالة العلوي.

148
00:08:23,490 --> 00:08:27,790
حتى لقد أعلن شخصيتي
بريد إلكتروني إلى أن حالة العليا زيد

149
00:08:27,790 --> 00:08:33,440
ثم لو "هو العليا" العودة
صحيح، ثم أقوم بطباعة تلك الرسالة.

150
00:08:33,440 --> 00:08:38,200
>> وبالعودة الى مثالنا البسيط
تحويل الحروف بواسطة مفتاح من اثنين،

151
00:08:38,200 --> 00:08:41,049
كيف يمكننا في الواقع الحصول على هذا العمل؟

152
00:08:41,049 --> 00:08:45,770
حسنا، اتضح أن الأحرف
وصحيحة ترتبط ارتباطا وثيقا جدا.

153
00:08:45,770 --> 00:08:48,840
كل حرف له
قيمة صحيحة المرتبطة

154
00:08:48,840 --> 00:08:53,260
مع أنها وجدت في الرسم البياني ASCII،
حيث ASCII كل حرف

155
00:08:53,260 --> 00:08:55,380
يتم عرض القيمة.

156
00:08:55,380 --> 00:08:58,940
لذلك فإن الحالة العلوي يقابل
إلى قيمة ASCII من 65

157
00:08:58,940 --> 00:09:02,270
وصغيرة في ل
قيمة ASCII من 97.

158
00:09:02,270 --> 00:09:04,940
>> لا تتردد في البحث عن
أي مخطط ASCII على الانترنت

159
00:09:04,940 --> 00:09:07,720
لرؤية هذه القيم لنفسك.

160
00:09:07,720 --> 00:09:12,096
ذلك ما يعنيه هذا هو ما في وسعنا
تأخذ طابع العلوي حالة A،

161
00:09:12,096 --> 00:09:18,200
إضافة عدد صحيح اثنين لذلك، ومن ثم الحصول على
الطابع العلوي حالة C نتيجة لذلك.

162
00:09:18,200 --> 00:09:23,720
ذلك لأن 65 في ASCII
قيمة لرأس المال A، بالإضافة إلى 2،

163
00:09:23,720 --> 00:09:29,960
يعطينا 67، والتي تتطابق
إلى طابع العلوي حالة C.

164
00:09:29,960 --> 00:09:33,480
>> لسوء الحظ، فإن الأمور
لن تكون تماما بهذه البساطة.

165
00:09:33,480 --> 00:09:36,980
لدينا معادلة
علينا أن ننظر.

166
00:09:36,980 --> 00:09:43,590
هنا يخبرنا بأن النص المشفر إيث
بريد إلكتروني يتوافق مع نص عادي إيث

167
00:09:43,590 --> 00:09:48,900
بريد إلكتروني، بالإضافة إلى key--
كل ذلك، وحدات 26.

168
00:09:48,900 --> 00:09:50,810
لماذا هو أن هذه القضية؟

169
00:09:50,810 --> 00:09:55,430
دعونا نعود إلى مثالنا من
من قبل، حيث أن رأس المال A، بالإضافة إلى 2،

170
00:09:55,430 --> 00:09:57,590
يعطينا جيم العاصمة

171
00:09:57,590 --> 00:10:01,870
>> ذلك بتطبيق المعادلة التي
مواصفات يعطينا،

172
00:10:01,870 --> 00:10:06,660
ثم دعونا نلقي العاصمة و
زائد 2 وزارة الدفاع التي كتبها 26.

173
00:10:06,660 --> 00:10:10,730
من رأس المال A، عندما وضعه في
تلك علامات الاقتباس المفردة،

174
00:10:10,730 --> 00:10:14,010
يسمح لي أن التعامل معها على أنها
عدد صحيح، بحيث يسمح

175
00:10:14,010 --> 00:10:17,500
لي أن يطرح للقيمة ASCII لها، 65.

176
00:10:17,500 --> 00:10:20,080
65 زائد 2 هو 67.

177
00:10:20,080 --> 00:10:25,210
67 وزارة الدفاع 26 يعطينا 15،
لكن هذا لا حقا

178
00:10:25,210 --> 00:10:32,590
معنى لأننا نعلم أن
عاصمة C قيمة ASCII هو 67 وليس 15.

179
00:10:32,590 --> 00:10:35,580
فكيف نوفق بين ذلك؟

180
00:10:35,580 --> 00:10:39,840
>> حسنا، هنا أود أن نفترض أن
فكرة وجود فهرس أبجدي.

181
00:10:39,840 --> 00:10:44,010
لذلك قمنا بالفعل تحدث عن كيف
كل حرف له قيمة ASCII لها،

182
00:10:44,010 --> 00:10:48,810
ولكن أود أن أقول، حسنا، دعنا
التفكير في وجود كل حرف أيضا

183
00:10:48,810 --> 00:10:52,230
مؤشر الأبجدي،
حيث A على سبيل المثال،

184
00:10:52,230 --> 00:10:58,800
كما الحرف الأول من الأبجدية،
يحتوي فهرس أبجدي من الصفر.

185
00:10:58,800 --> 00:11:02,070
حتى الآن دعونا تطبيق
نفس المعادلة كما كان من قبل،

186
00:11:02,070 --> 00:11:05,040
ولكن باستخدام فهرس أبجدي.

187
00:11:05,040 --> 00:11:07,810
>> لذلك هو الصفر، كما حددناها.

188
00:11:07,810 --> 00:11:15,640
حتى ذلك الحين أخذ الصفر زائد اثنين، وزارة الدفاع 26،
هذا اثنان، وزارة الدفاع 26، مما يعطينا اثنين.

189
00:11:15,640 --> 00:11:18,780
وأيضا، من حيث
مؤشر الأبجدي،

190
00:11:18,780 --> 00:11:23,930
C هو حرف الثالث في
الأبجدية، بحيث تتوافق

191
00:11:23,930 --> 00:11:26,290
إلى فهرس أبجدي من اثنين.

192
00:11:26,290 --> 00:11:29,850
لذلك يبدو أن استخدام
فهرس أبجدي في هذه الحالة

193
00:11:29,850 --> 00:11:32,840
الواقع يعطي لنا النتيجة الصحيحة.

194
00:11:32,840 --> 00:11:35,020
>> حتى الآن دعونا تحقق ل
معرفة ما إذا كان يعمل المعادلة

195
00:11:35,020 --> 00:11:37,210
مع فهرس أبجدي.

196
00:11:37,210 --> 00:11:42,540
فهرس أبجدي Y هو 24 كما في
الثانية إلى الحرف الأخير في الأبجدية.

197
00:11:42,540 --> 00:11:46,520
حتى ذلك الحين 24 زائد لدينا
مفتاح اثنين من يعطينا 26.

198
00:11:46,520 --> 00:11:54,750
26 وزارة الدفاع 26 يعطينا 0، والذي، محظوظ ل
لنا، هو مؤشر الأبجدي لأ.

199
00:11:54,750 --> 00:11:59,100
لذلك نأمل هذا دليل كافي أن
يعمل الأسلوب فهرس أبجدي.

200
00:11:59,100 --> 00:12:03,180
إن لم يكن، لا تتردد لمحاولة الخروج
بعض الأمثلة الخاصة بك.

201
00:12:03,180 --> 00:12:08,030
>> من أجل التفاف بشكل صحيح في جميع أنحاء
الأبجدية وتطبيق المعادلة قيصر،

202
00:12:08,030 --> 00:12:11,280
ثم نحن نعلم أننا بحاجة ل
التعامل مع مؤشرات أبجدية.

203
00:12:11,280 --> 00:12:15,130
ولكن علينا أن نبدأ مع ASCII
القيم، وعندئذ فقط

204
00:12:15,130 --> 00:12:18,530
نقوم بعد ذلك اعتناق
مؤشر الأبجدي.

205
00:12:18,530 --> 00:12:23,970
من هناك، من أجل طباعة، نحتاج
للتعامل مع القيم ASCII مرة أخرى.

206
00:12:23,970 --> 00:12:28,350
لذلك نحن بحاجة لمعرفة كيفية
الانتقال من ASCII إلى الترتيب الأبجدي

207
00:12:28,350 --> 00:12:31,080
ومن الأبجدية إلى ASCII.

208
00:12:31,080 --> 00:12:34,910
>> لذا أترك الأمر لك لمعرفة
نمط بين شخصية

209
00:12:34,910 --> 00:12:38,590
والأبجدية لها
مؤشر وقيمة ASCII لها.

210
00:12:38,590 --> 00:12:41,530
الآن، تذكر أنه على الرغم من
هذا الحق الجدول على الشريحة

211
00:12:41,530 --> 00:12:45,630
يدل على حروف وأرقام، ونحن أيضا
أن تنظر أم لا

212
00:12:45,630 --> 00:12:48,915
ينطبق نمطا مختلفا
للشخصيات الحالة الأدنى.

213
00:12:48,915 --> 00:12:52,070

214
00:12:52,070 --> 00:12:55,840
>> حتى الآن بعد أن قمنا أحسب
كيفية تحويل حرف واحد،

215
00:12:55,840 --> 00:13:02,200
ثم كل ما عليك القيام به هو مقياس
حتى انتقل عبر عادي بأكمله.

216
00:13:02,200 --> 00:13:04,260
لذلك عادي هو سلسلة.

217
00:13:04,260 --> 00:13:08,210
الحظ بالنسبة لنا، سلسلة حقا
مجرد مجموعة من الشخصيات،

218
00:13:08,210 --> 00:13:12,150
وذلك من أجل الوصول إلى كل حرف
من سلسلة، كل ما عليك القيام به

219
00:13:12,150 --> 00:13:14,270
هو استخدام مجموعة التدوين.

220
00:13:14,270 --> 00:13:20,270
يقول لدي متغير من نوع
سلسلة تسمى "النص = 'هذا هو CS50".

221
00:13:20,270 --> 00:13:22,730
>> حسنا، إذن، من أجل
الوصول إلى كل حرف،

222
00:13:22,730 --> 00:13:25,880
جميع يجب أن أقوم به مع
النص المتغير

223
00:13:25,880 --> 00:13:31,660
القول أيضا، نص على مؤشر الصفر، أن
يتوافق مع نص T. العاصمة في الفهرس

224
00:13:31,660 --> 00:13:35,100
واحد يتوافق مع انخفاض الحالة ح.

225
00:13:35,100 --> 00:13:38,110
وظيفة أخرى مفيدة هي
وظيفة طول السلسلة.

226
00:13:38,110 --> 00:13:40,760
حتى يمر في سلسلة ل
وأن الدالة بإرجاع

227
00:13:40,760 --> 00:13:44,610
عدد صحيح، وطول هذه السلسلة.

228
00:13:44,610 --> 00:13:47,060
>> الآن وبعد أن تحدثنا عن
كل هذه العناصر المختلفة،

229
00:13:47,060 --> 00:13:48,540
دعونا وضعها معا مرة أخرى.

230
00:13:48,540 --> 00:13:52,210
ذلك يعود إما إلى بلدي شبة الكود
كود أو شبة الكود الخاص بك

231
00:13:52,210 --> 00:13:55,920
وتذهب من خلال وتأكد من
تعرف كيف تفعل كل شيء واحد.

232
00:13:55,920 --> 00:14:01,520
الحصول على المفتاح باستخدام ARGC وARGV،
تحويل المفتاح إلى عدد صحيح، ل

233
00:14:01,520 --> 00:14:06,840
إلى i، المطالبة عادي،
getstring، ثم بالتكرار

234
00:14:06,840 --> 00:14:09,590
على كل حرف في
سلسلة مشفرة،

235
00:14:09,590 --> 00:14:14,910
الحفاظ على حالة كل حرف
وتحول هذا الحرف بواسطة مفتاح،

236
00:14:14,910 --> 00:14:17,520
ضمان أن كنت
التفاف حول الأبجدية،

237
00:14:17,520 --> 00:14:20,850
أخيرا طباعة هذا النص المشفر.

238
00:14:20,850 --> 00:14:25,470
اسمي أميلا، وكان هذا قيصر.

239
00:14:25,470 --> 00:14:28,448

