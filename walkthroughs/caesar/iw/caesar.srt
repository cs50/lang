1
00:00:00,000 --> 00:00:00,760

2
00:00:00,760 --> 00:00:02,270
>> AMILA: בואו להתמודד קיסר.

3
00:00:02,270 --> 00:00:06,110
קיסר, אנחנו מאפשרים למשתמש
לקידוד מסר סודי.

4
00:00:06,110 --> 00:00:09,780
אז בואו לצלול ישר פנימה להסתכל
ב ל- DOS שלנו לבעיה זו.

5
00:00:09,780 --> 00:00:12,210
אז קודם כל, אנחנו מקבלים את המפתח מהמשתמש.

6
00:00:12,210 --> 00:00:15,210
אז אנחנו מקבלים בטקסט
כי הם רוצים לקודד.

7
00:00:15,210 --> 00:00:21,380
לאחר מכן, אנו להצפין את זה בשבילם,
ולבסוף אנו להדפיס המוצפן שלהם.

8
00:00:21,380 --> 00:00:23,600
>> אז בואו נתחיל עם דוגמה.

9
00:00:23,600 --> 00:00:26,920
תגיד אתה רוצה לקודד את
האלפבית כולו עם מפתח של השני.

10
00:00:26,920 --> 00:00:31,360
ובכן, האלפבית כולו שלך היה
רק להיות מוזז לאותיות.

11
00:00:31,360 --> 00:00:37,060
כך היה לקודד ל- C, B כדי
D, C עד ה ', וכך הלאה וכך הלאה,

12
00:00:37,060 --> 00:00:42,470
עד שתגיע X, מקודד עד ת
או Zed, תלוי מאיפה אתה.

13
00:00:42,470 --> 00:00:47,445
ואז Y היה אז להעביר את כל הדרך,
לעטוף את האלפבית להגיע A,

14
00:00:47,445 --> 00:00:53,256
ואז סוף סוף את המכתב האחרון של
האלפבית, Z, Zed, היה לקודד ל B.

15
00:00:53,256 --> 00:00:54,660
>> יש לך את זה?

16
00:00:54,660 --> 00:00:56,380
בואו נסתכל על כמה דוגמאות.

17
00:00:56,380 --> 00:01:00,540
הדוגמא הראשונה כאן דומה מאוד
למה אנחנו רק שהוסבר לעיל.

18
00:01:00,540 --> 00:01:05,560
אז אם אני לקודד מקטע מסוים של
האלפבית, א 'עד L, על ידי מפתח של השני,

19
00:01:05,560 --> 00:01:09,760
אז אני פשוט מקבל כולו שלי
האלפבית מוזז שני מכתבים.

20
00:01:09,760 --> 00:01:12,230
>> אז, בדוגמה הבאה שלי,
המפתח הוא עדיין שני,

21
00:01:12,230 --> 00:01:15,080
אז אתה עדיין צריך לדעת
אילו אותיות לצפות.

22
00:01:15,080 --> 00:01:16,400
אבל כאן זה ביטוי.

23
00:01:16,400 --> 00:01:18,100
זהו CS50.

24
00:01:18,100 --> 00:01:21,090
אז תבחין שאני
לשמר במקרה של המכתבים שלי,

25
00:01:21,090 --> 00:01:25,600
ולכן כל אותיות גדולות הן גם
אותיות גדולות של המוצפן.

26
00:01:25,600 --> 00:01:27,800
וכל קטן
אותיות בטקסט

27
00:01:27,800 --> 00:01:30,640
גם לאותיות קטנות
אותיות המוצפנות.

28
00:01:30,640 --> 00:01:34,020
אבל אני שומר את המכתבים
וכל סימני קריאה

29
00:01:34,020 --> 00:01:37,610
או סימני פיסוק אחר באותו.

30
00:01:37,610 --> 00:01:40,360
>> אז עכשיו שיש לנו תחושה
עבור כיצד התוכנית פועלת,

31
00:01:40,360 --> 00:01:43,890
אל תהסס ללכת לנהל איזה יותר
דוגמאות משלך, אם תרצה בכך.

32
00:01:43,890 --> 00:01:47,072
בואו נתחיל עם מקבל
המפתח מהמשתמש.

33
00:01:47,072 --> 00:01:48,780
באופן מסורתי, עם
בעיות אחרות, יש לנו

34
00:01:48,780 --> 00:01:51,450
כבר רגיל מקבל
כל מספרים שאנחנו

35
00:01:51,450 --> 00:01:54,710
צריך על ידי לשאול את המשתמש
עם הפונקציה getint.

36
00:01:54,710 --> 00:01:58,850
אבל הפעם אנחנו באמת הולכים
להשתמש את טענת שורת הפקודה

37
00:01:58,850 --> 00:02:01,760
ופונקציה חדשה בשם atoi.

38
00:02:01,760 --> 00:02:05,130
>> כאשר אתה מפעיל את הראשי
תוכנית ב- C, אז זה

39
00:02:05,130 --> 00:02:08,500
לוקח בשתי parameters--
argc int, אשר

40
00:02:08,500 --> 00:02:11,670
הוא מספר הארגומנטים
עבר, ולאחר מכן

41
00:02:11,670 --> 00:02:15,920
argv, מערך של מחרוזות אשר מכיל
את רשימת כל הטיעונים

42
00:02:15,920 --> 00:02:16,740
חלפו.

43
00:02:16,740 --> 00:02:19,740
אתה לא במפורש יש
להצהיר על משתנים אלה.

44
00:02:19,740 --> 00:02:22,700
הם שחושב
אתה על ידי המהדר.

45
00:02:22,700 --> 00:02:28,160
בעזרת שימוש נכון לכך יהיה
עבור argc להיות שניים במקרה הזה,

46
00:02:28,160 --> 00:02:32,630
יש משום שהמשתמש לעבור ב
השיחה לתוכנית, ./caesar,

47
00:02:32,630 --> 00:02:35,570
ולאחר מכן על המקש,
מה מספר שהם רוצים.

48
00:02:35,570 --> 00:02:39,920
אז זה אומר כי argc חייב להיות שני
על מנת שע שימוש חוקי קיסר

49
00:02:39,920 --> 00:02:41,680
להיות מוצא להורג.

50
00:02:41,680 --> 00:02:43,590
>> אז בואו נסתכל על דוגמא.

51
00:02:43,590 --> 00:02:47,760
תגיד כבר כתבתי ו
הידור תוכנית בשם blastoff.

52
00:02:47,760 --> 00:02:52,670
אז אם רצתי בשורת הפקודה
צוות רוקט ./blastoff, טוב, אז,

53
00:02:52,670 --> 00:02:57,750
argc יהיה שלוש כי אני
עברו שלוש טענות נפרדות.

54
00:02:57,750 --> 00:02:59,830
ואז argv ייראה כך.

55
00:02:59,830 --> 00:03:03,750
זה מערך, וזה היה
מכילים כל אחד משלושת המיתרים.

56
00:03:03,750 --> 00:03:09,640
./blastoff במדד, הקבוצה הראשונה
ב, והרקטות הבאות האחרון.

57
00:03:09,640 --> 00:03:11,610
>> בואו נדבר על מערכים עבור שניות.

58
00:03:11,610 --> 00:03:15,560
מערכים הם מבני נתונים אשר מחזיקים
ערכים מרובים מאותו הסוג.

59
00:03:15,560 --> 00:03:19,980
זה יכול להיות שימושי כאשר אנו
יש רשימות של מספרים שלמים או מחרוזות.

60
00:03:19,980 --> 00:03:23,030
רק תזכור שיש להם
כדי להיות מאותו הסוג.

61
00:03:23,030 --> 00:03:25,310
במדעי המחשב, אנחנו
אוהב לספור מאפס,

62
00:03:25,310 --> 00:03:29,260
כך זוכר שמערכים
הם גם צמודות אפס.

63
00:03:29,260 --> 00:03:34,360
אז האלמנט הראשון של המערך שלי
הולך להיות מדד אפס.

64
00:03:34,360 --> 00:03:37,580
אז במקרה הזה, כאשר יש לי
מערך באורך ארבעה,

65
00:03:37,580 --> 00:03:41,350
אז המדד האחרון של
האלמנט האחרון של המערך שלי

66
00:03:41,350 --> 00:03:44,970
בעצם הולך להיות
ב מדד שלוש, לא ארבע.

67
00:03:44,970 --> 00:03:48,880
כי יש לזכור, אנחנו
מתחילים לספור על אפס.

68
00:03:48,880 --> 00:03:52,530
>> הנה דוגמה לאופן שבו אתה
עשוי ליצור מערך משלך.

69
00:03:52,530 --> 00:03:56,440
אז נגיד שאני רוצה לאחסן שלי
שלושה שמות כלב אהובים.

70
00:03:56,440 --> 00:03:59,030
אחר כך הייתי ליצור מערך של מחרוזות.

71
00:03:59,030 --> 00:04:04,450
אז הייתי להכריז על סוג, מחרוזת, ו
ואז לשים את השם של המערך, כלבים,

72
00:04:04,450 --> 00:04:06,450
ואז באותם מרובע
בסוגריים לשים את הגודל

73
00:04:06,450 --> 00:04:09,260
של array-- במקרה זה, שלוש.

74
00:04:09,260 --> 00:04:12,690
>> וכך, הרישום הראשון שלי הולך
להיות כלבי מדד אפס,

75
00:04:12,690 --> 00:04:14,750
וזה הולך להיות מילוא.

76
00:04:14,750 --> 00:04:17,850
אז כלבי מדד אחד
הולך להיות טפש,

77
00:04:17,850 --> 00:04:23,060
יקירי מוצ'י, ולאחר מכן האחרון
כניסה, הכניסה השלישית במדד שני,

78
00:04:23,060 --> 00:04:26,130
הולך להיות Elphie חמוד, מתוק.

79
00:04:26,130 --> 00:04:28,610
תוכל להבחין כי בפורמט
למילוי מערך זה

80
00:04:28,610 --> 00:04:32,150
מאוד דומה לאופן שבו כדאי
להכריז על כל משתנה אחר שבו

81
00:04:32,150 --> 00:04:36,307
יש לך את השם משתנה ואחריו
הערך שאתה רוצה לאחסן אותו.

82
00:04:36,307 --> 00:04:38,140
ההבדל היחיד
במקרה זה הוא שאתה

83
00:04:38,140 --> 00:04:42,700
צריך לזכור לשים את המדד
של הערך בסוגריים מרובעים.

84
00:04:42,700 --> 00:04:46,420
ויש לנו את שלנו
שלושה כלבים אהובים.

85
00:04:46,420 --> 00:04:48,780
>> אך אבוי, זה הזמן
לחזור קיסר.

86
00:04:48,780 --> 00:04:52,910
זכור כי שימוש נכון עבור
המשתמש הוא הולך להיות עובר לא רק

87
00:04:52,910 --> 00:04:57,430
השם של התוכנית ./caesar, אבל
גם המפתח שהם רוצים להעביר

88
00:04:57,430 --> 00:04:58,850
בטקסט שלהם על ידי.

89
00:04:58,850 --> 00:05:01,540
אז זה אומר כי argc חייב להיות שני.

90
00:05:01,540 --> 00:05:07,580
הם חייבים לעבור two-- לא יותר, לא
פחות משני הארגומנטים של שורת הפקודה.

91
00:05:07,580 --> 00:05:09,050
>> עכשיו, מה לגבי argv?

92
00:05:09,050 --> 00:05:12,880
ובכן, אנחנו כבר יודעים כי
מערך הולך להיות באורך שני,

93
00:05:12,880 --> 00:05:15,270
אבל מה הכלול כל רכיב?

94
00:05:15,270 --> 00:05:19,330
ובכן, הרכיב הראשון
הולך להיות ./caesar,

95
00:05:19,330 --> 00:05:24,190
ואז האלמנט הבא הולך
להכיל את המפתח שהמשתמש הקליד.

96
00:05:24,190 --> 00:05:27,480
עכשיו, אם הם השתמשו בו בצורה נכונה
עבור השימוש של קיסר,

97
00:05:27,480 --> 00:05:29,350
אז הם הולכים להקליד מספר.

98
00:05:29,350 --> 00:05:33,260
אבל אף על פי אופי
שהם מקלידים הוא מספר,

99
00:05:33,260 --> 00:05:35,790
זה של מחרוזת סוג הנתונים.

100
00:05:35,790 --> 00:05:40,390
>> אז איך אנחנו להמיר כי
מחרוזת למספר שלם?

101
00:05:40,390 --> 00:05:46,680
אז נגיד שיש לי num, מחרוזת,
המכיל את המחרוזת 50.

102
00:05:46,680 --> 00:05:49,000
אם אני רוצה להמיר את
למספר שלם, אז אני פשוט

103
00:05:49,000 --> 00:05:53,340
מכריז על משתנה חדש,
integer אני, קורא atoi.

104
00:05:53,340 --> 00:06:01,160
אני עובר במשתנה החוט שלי, num, ו
אז אני אז אכיל את המספר 50.

105
00:06:01,160 --> 00:06:04,350
הקפידו לבדוק את האיש
דפים לתפקוד atoi

106
00:06:04,350 --> 00:06:07,990
כדי לבדוק איזה ספרייה זה
ב, כמו גם מה ערך

107
00:06:07,990 --> 00:06:14,550
יחזור אם המחרוזת עברה
ב אינו מכיל את כל המספרים.

108
00:06:14,550 --> 00:06:16,950
>> אז עכשיו קיבלנו
המפתח, הצעד הבא

109
00:06:16,950 --> 00:06:19,430
היא להשיג את בטקסט מהמשתמש.

110
00:06:19,430 --> 00:06:21,170
עכשיו, זה הולך
להיות פחות מסובך

111
00:06:21,170 --> 00:06:23,410
מאשר לנווט ברחבי
ארגומנטים משורת הפקודה.

112
00:06:23,410 --> 00:06:26,190
כל שעלינו לעשות הוא להתקשר
פונקצית getstring

113
00:06:26,190 --> 00:06:29,660
לבקש מהמשתמש לתת
לנו מחרוזת, אך יש לזכור

114
00:06:29,660 --> 00:06:34,090
כדי לבדוק את המפרט על האופן שבו אנו
אולי כדאי להציג למשתמש על כך.

115
00:06:34,090 --> 00:06:36,420
>> כעת אנו מגיעים אל
בלב problem--

116
00:06:36,420 --> 00:06:38,860
איך להצפין בטקסט.

117
00:06:38,860 --> 00:06:42,830
ובכן, ראשית, בואו נדבר על איך
כדי להצפין תו אחד בכל פעם,

118
00:06:42,830 --> 00:06:47,370
ואז נצטרך להתייחס איך
לחזר על בטקסט כולו.

119
00:06:47,370 --> 00:06:50,440
כתבתי כמה פסאודו קוד
לבעיית קיסר.

120
00:06:50,440 --> 00:06:52,310
אני ממליץ לך
לכתוב בעצמך גם כן.

121
00:06:52,310 --> 00:06:55,900
זה אולי לא נראה זהה
שלי, וזה בסדר, אבל כל עוד

122
00:06:55,900 --> 00:06:58,640
כמו הרעיון הכללי הוא זהה.

123
00:06:58,640 --> 00:07:00,780
>> שלושת הצעדים הראשונים
כבר עשינו.

124
00:07:00,780 --> 00:07:03,100
קיבלנו את המפתח
את טענת שורת הפקודה,

125
00:07:03,100 --> 00:07:05,510
הפכנו מפתח
לתוך שלם, ויש לנו

126
00:07:05,510 --> 00:07:09,320
מתבקש המשתמש עבור בטקסט
כי הם רוצים להצפין.

127
00:07:09,320 --> 00:07:12,420
אז את הנתח הגדול הבא
כלומר עבור כל תו

128
00:07:12,420 --> 00:07:15,070
במחרוזת טקסט פשוט,
אם זה האלפביתי,

129
00:07:15,070 --> 00:07:17,750
אנחנו רוצים לשמר את
במקרה שלה ולהעביר אותה.

130
00:07:17,750 --> 00:07:20,900
על ידי לשמר מקרה, מה שאני
אומר הוא שכל רישית

131
00:07:20,900 --> 00:07:23,580
מכתבים צריכים להישאר עליונים
במקרה וכל אותיות קטנות

132
00:07:23,580 --> 00:07:25,640
צריך להישאר קטן.

133
00:07:25,640 --> 00:07:29,110
אז אחרי שאנחנו "מיליידיי",
אז אנחנו להדפיס את המוצפן.

134
00:07:29,110 --> 00:07:33,100
>> הנה שלוש פונקציות כי הם הולכים
כדי להיות שימושי עבור בעיה זו.

135
00:07:33,100 --> 00:07:38,010
זכור למעלה, כשנתתי את
למשל עבור הסטה זו היא CS50?

136
00:07:38,010 --> 00:07:41,800
זכור כי 50 ואת
סימן קריאה לא משמרת?

137
00:07:41,800 --> 00:07:45,680
אז איך אנחנו יכולים לדעת אם אנחנו
צריך להסיט מכתב או לא?

138
00:07:45,680 --> 00:07:48,650
ובכן, "הוא אלפא," אם
אתה עובר לו אופי,

139
00:07:48,650 --> 00:07:54,850
יחזיר אמת אם כי אופי
הוא אחרת מכתב ושקרי.

140
00:07:54,850 --> 00:07:56,870
כדי לעזור לך עם
היוון שמירה

141
00:07:56,870 --> 00:07:59,750
הן פונקציות "הוא
העליון "ו" נמוך יותר. "

142
00:07:59,750 --> 00:08:03,350
>> שני תפקידים אלה גם לקחת
ב תו בודד כקלט

143
00:08:03,350 --> 00:08:06,580
ולהחזיר לך בוליאני,
או אמת או שקר

144
00:08:06,580 --> 00:08:11,280
תלוי אם כי אופי
הוא במקרה גדול או קטן.

145
00:08:11,280 --> 00:08:14,610
בגלל "הוא עליון" ואת "הוא
"נמוך הן פונקציות בוליאניות,

146
00:08:14,610 --> 00:08:18,660
כלומר הם חוזרים לך בוליאני,
אתה יכול להשתמש אלה בתנאים שלך.

147
00:08:18,660 --> 00:08:23,490
אז הנה קטע קוד שרק
מדפיס מכתב אם זה רישית.

148
00:08:23,490 --> 00:08:27,790
אז אני כבר הכרזתי הדמות שלי
במכתב להיות המקרה העליון zed

149
00:08:27,790 --> 00:08:33,440
ואז אם "הוא עליונות" חזרות
נכון, אז אני להדפיס את המכתב ההוא.

150
00:08:33,440 --> 00:08:38,200
>> אחזור הדוגמא הפשוטה שלנו
הסטה האלפבית ידי מפתח של השני,

151
00:08:38,200 --> 00:08:41,049
איך אנחנו בעצם מקבלים כי לעבוד?

152
00:08:41,049 --> 00:08:45,770
ובכן, מתברר כי תווים
ו שלמים מאוד קשורים זה לזה.

153
00:08:45,770 --> 00:08:48,840
לכל אחת מהדמויות יש
ערך שלם הקשורים

154
00:08:48,840 --> 00:08:53,260
עם זאת נמצאת תרשים ASCII,
כאשר כל ASCII של התו

155
00:08:53,260 --> 00:08:55,380
הערך מוצג.

156
00:08:55,380 --> 00:08:58,940
אז מקבילת מקרה עליון
לערך ASCII של 65

157
00:08:58,940 --> 00:09:02,270
וחוש קטן כדי
ערך ASCII של 97.

158
00:09:02,270 --> 00:09:04,940
>> תרגיש חופשי להסתכל למעלה
כל תרשים ASCII באינטרנט

159
00:09:04,940 --> 00:09:07,720
לראות את הערכים הללו בעצמך.

160
00:09:07,720 --> 00:09:12,096
אז מה שזה אומר זה שאנחנו יכולים
לקחת את אופיו של אותיות גדולות,

161
00:09:12,096 --> 00:09:18,200
להוסיף את המספר השלם שתי אליו, ולאחר מכן לקבל
ג רישית אופי כתוצאה מכך.

162
00:09:18,200 --> 00:09:23,720
הסיבה לכך היא 65, ASCII
ערך עבור הון, בתוספת 2,

163
00:09:23,720 --> 00:09:29,960
נותן לנו 67, אשר תואם
על אופיו של ג רישית

164
00:09:29,960 --> 00:09:33,480
>> למרבה הצער, דברים
לא יהיה פשוט כל כך.

165
00:09:33,480 --> 00:09:36,980
יש לנו משוואה
אנחנו צריכים לשקול.

166
00:09:36,980 --> 00:09:43,590
הנה זה אומר לנו כי מוצפן ה- i
מכתב תואם את בטקסט ה- i

167
00:09:43,590 --> 00:09:48,900
מכתב, בתוספת key--
כל זה, מודולרי 26.

168
00:09:48,900 --> 00:09:50,810
מדוע זה כך?

169
00:09:50,810 --> 00:09:55,430
בואו נחזור לדוגמא שלנו מ
לפני, בירה שם, בתוספת 2,

170
00:09:55,430 --> 00:09:57,590
נותן לנו ג ההון

171
00:09:57,590 --> 00:10:01,870
>> אז החל למשוואה
המפרט נותן לנו,

172
00:10:01,870 --> 00:10:06,660
אז בואו ניקח הון
בתוספת 2 ו mod כי ב -26.

173
00:10:06,660 --> 00:10:10,730
אז ההון A, כאשר שמתי אותו
אלה גרשיים,

174
00:10:10,730 --> 00:10:14,010
מאפשר לי להתייחס אליו כאל
מספר שלם, כך מאפשר

175
00:10:14,010 --> 00:10:17,500
לי להפיל אותו לשווי ASCII שלו, 65.

176
00:10:17,500 --> 00:10:20,080
65 פלוס 2 הוא 67.

177
00:10:20,080 --> 00:10:25,210
67 mod 26 נותן לנו 15,
אבל זה לא באמת

178
00:10:25,210 --> 00:10:32,590
הגיוני כי אנחנו יודעים כי
ערך ASCII הון C הוא 67, לא 15.

179
00:10:32,590 --> 00:10:35,580
אז איך אפשר ליישב את זה?

180
00:10:35,580 --> 00:10:39,840
>> ובכן, כאן אני רוצה להניח
הרעיון של אינדקס אלפביתי.

181
00:10:39,840 --> 00:10:44,010
אז אנחנו כבר דיברנו על איך
יש כל תו ערך ASCII שלה,

182
00:10:44,010 --> 00:10:48,810
אבל אני רוצה לומר, טוב, בוא
לחשוב על כל תו גם שיש

183
00:10:48,810 --> 00:10:52,230
אינדקס אלפביתי,
כאשר A למשל,

184
00:10:52,230 --> 00:10:58,800
כמו האות הראשונה של האלף-בית,
יש אינדקס אלפביתי של אפס.

185
00:10:58,800 --> 00:11:02,070
אז עכשיו בואו ליישם את
משוואה זהה לפני,

186
00:11:02,070 --> 00:11:05,040
אבל שימוש באינדקס אלפביתי.

187
00:11:05,040 --> 00:11:07,810
>> אז A הוא אפס, כפי שהגדרנו.

188
00:11:07,810 --> 00:11:15,640
אז לוקחים אפס פלוס שניים, mod 26,
זה שני, mod 26, אשר נותן לנו שני.

189
00:11:15,640 --> 00:11:18,780
וזה טוב, במונחים של
אינדקס אלפביתי,

190
00:11:18,780 --> 00:11:23,930
C היא האות השלישית
האלפבית, כך יתאים

191
00:11:23,930 --> 00:11:26,290
למדד אלפביתי של השני.

192
00:11:26,290 --> 00:11:29,850
לכן נראה כי באמצעות
אינדקס אלפביתי במקרה זה

193
00:11:29,850 --> 00:11:32,840
למעשה נותן לנו את התוצאה הנכונה.

194
00:11:32,840 --> 00:11:35,020
>> אז עכשיו בואו לבדוק כדי
לראות אם עבודות המשוואה

195
00:11:35,020 --> 00:11:37,210
עם אינדקס אלפביתי.

196
00:11:37,210 --> 00:11:42,540
אינדקס אלפביתי של Y הוא 24 כמו
שני האות האחרונה באלפבית.

197
00:11:42,540 --> 00:11:46,520
אז 24 פלוס שלנו
המפתח של שני נותן לנו 26.

198
00:11:46,520 --> 00:11:54,750
26 mod 26 נותן לנו 0, אשר, מזל
לנו, הוא המדד אלפביתי עבור א

199
00:11:54,750 --> 00:11:59,100
אז אני מקווה שזה מספיק ראיות לכך
שיטת אינדקס אלפביתי עובדת.

200
00:11:59,100 --> 00:12:03,180
אם לא, אל תהססו לנסות
כמה דוגמאות משלך.

201
00:12:03,180 --> 00:12:08,030
>> כדי לעטוף כראוי סביב
האלפבית ולהחיל את המשוואה קיסר,

202
00:12:08,030 --> 00:12:11,280
אז אנחנו יודעים שאנחנו צריכים
להתמודד עם מדדי אלפביתי.

203
00:12:11,280 --> 00:12:15,130
אבל נתחיל עם ASCII
ערכים, ורק אז

204
00:12:15,130 --> 00:12:18,530
אנחנו מכן להמיר
מדד אלפביתי.

205
00:12:18,530 --> 00:12:23,970
משם, כדי להדפיס, אנחנו צריכים
כדי להתמודד עם ערכי ASCII שוב.

206
00:12:23,970 --> 00:12:28,350
אז אנחנו צריכים להבין איך
עובר מ ASCII כדי אלפביתי

207
00:12:28,350 --> 00:12:31,080
ומן אלפביתי כדי ASCII.

208
00:12:31,080 --> 00:12:34,910
>> אז אני משאיר לך את זה כדי להבין
התבנית בין דמות

209
00:12:34,910 --> 00:12:38,590
אלפביתי שלה
מדד וערך ASCII שלו.

210
00:12:38,590 --> 00:12:41,530
עכשיו, יש לזכור כי למרות
נכון בטבלה זו בשקופית

211
00:12:41,530 --> 00:12:45,630
מציגים את האותיות הגדולות, אנחנו גם
יש לשקול אם או לא

212
00:12:45,630 --> 00:12:48,915
דפוס שונה חל
עבור תווים באותיות קטנות.

213
00:12:48,915 --> 00:12:52,070

214
00:12:52,070 --> 00:12:55,840
>> אז עכשיו הבנו
איך להעביר תו בודד,

215
00:12:55,840 --> 00:13:02,200
אז כל מה שאנחנו צריכים לעשות זה בקנה מידה
עד לחצות בטקסט כולו.

216
00:13:02,200 --> 00:13:04,260
אז בטקסט הוא מחרוזת.

217
00:13:04,260 --> 00:13:08,210
למזלנו, מחרוזת הוא באמת
רק מערך של תווים,

218
00:13:08,210 --> 00:13:12,150
זאת על מנת לגשת לכל תו
של מחרוזת, כל מה שאתה צריך לעשות

219
00:13:12,150 --> 00:13:14,270
הוא להשתמש בסימון מערך.

220
00:13:14,270 --> 00:13:20,270
נגיד שיש לי משתנה מסוג
מחרוזת בשם "text =" זה CS50. ' "

221
00:13:20,270 --> 00:13:22,730
>> ובכן, אם כן, על מנת
לגשת כל תו,

222
00:13:22,730 --> 00:13:25,880
כל מה שאני צריך לעשות עם
הטקסט משתנה הוא

223
00:13:25,880 --> 00:13:31,660
לומר כן, טקסט מדד אפס, כי
מתאים טקסט ט הון מדד

224
00:13:31,660 --> 00:13:35,100
עם ציון במקרה h הנמוך.

225
00:13:35,100 --> 00:13:38,110
פונקציה שימושית נוספת היא
פונקצית אורך חוט.

226
00:13:38,110 --> 00:13:40,760
אז עובר מחרוזת
הפונקציה תחזור

227
00:13:40,760 --> 00:13:44,610
מספר שלם, לכל האורך של מחרוזת.

228
00:13:44,610 --> 00:13:47,060
>> עכשיו שאנחנו כבר דברנו על
כל הגורמים האלה,

229
00:13:47,060 --> 00:13:48,540
בואו להחזיר אותם ביחד.

230
00:13:48,540 --> 00:13:52,210
אז לחזור או פסאודו קוד שלי
קוד או פסאודו קוד שלך

231
00:13:52,210 --> 00:13:55,920
ולעבור ולוודא כי אתה
יודע איך לעשות כל דבר ודבר.

232
00:13:55,920 --> 00:14:01,520
כיצד משיגים את המפתח באמצעות argc ו argv,
סיבוב המפתח לתוך מספר שלם,

233
00:14:01,520 --> 00:14:06,840
ל i, מה שגרם עבור בטקסט,
getstring, ולאחר מכן חזרה על

234
00:14:06,840 --> 00:14:09,590
על כל דמות
מחרוזת בטקסט,

235
00:14:09,590 --> 00:14:14,910
שמירה על המקרה של כל דמות
הסטה כי אופי לפי המפתח,

236
00:14:14,910 --> 00:14:17,520
הבטחת שאתה
גלישה סביב האלפבית,

237
00:14:17,520 --> 00:14:20,850
ולבסוף הדפסת מוצפן זה.

238
00:14:20,850 --> 00:14:25,470
שמי Amila, וזה היה קיסר.

239
00:14:25,470 --> 00:14:28,448

