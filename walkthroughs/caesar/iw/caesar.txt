AMILA: בואו להתמודד קיסר. קיסר, אנחנו מאפשרים למשתמש לקידוד מסר סודי. אז בואו לצלול ישר פנימה להסתכל ב ל- DOS שלנו לבעיה זו. אז קודם כל, אנחנו מקבלים את המפתח מהמשתמש. אז אנחנו מקבלים בטקסט כי הם רוצים לקודד. לאחר מכן, אנו להצפין את זה בשבילם, ולבסוף אנו להדפיס המוצפן שלהם. 

אז בואו נתחיל עם דוגמה. תגיד אתה רוצה לקודד את האלפבית כולו עם מפתח של השני. ובכן, האלפבית כולו שלך היה רק להיות מוזז לאותיות. כך היה לקודד ל- C, B כדי D, C עד ה ', וכך הלאה וכך הלאה, עד שתגיע X, מקודד עד ת או Zed, תלוי מאיפה אתה. ואז Y היה אז להעביר את כל הדרך, לעטוף את האלפבית להגיע A, ואז סוף סוף את המכתב האחרון של האלפבית, Z, Zed, היה לקודד ל B. 

יש לך את זה? בואו נסתכל על כמה דוגמאות. הדוגמא הראשונה כאן דומה מאוד למה אנחנו רק שהוסבר לעיל. אז אם אני לקודד מקטע מסוים של האלפבית, א 'עד L, על ידי מפתח של השני, אז אני פשוט מקבל כולו שלי האלפבית מוזז שני מכתבים. 

אז, בדוגמה הבאה שלי, המפתח הוא עדיין שני, אז אתה עדיין צריך לדעת אילו אותיות לצפות. אבל כאן זה ביטוי. זהו CS50. אז תבחין שאני לשמר במקרה של המכתבים שלי, ולכן כל אותיות גדולות הן גם אותיות גדולות של המוצפן. וכל קטן אותיות בטקסט גם לאותיות קטנות אותיות המוצפנות. אבל אני שומר את המכתבים וכל סימני קריאה או סימני פיסוק אחר באותו. 

אז עכשיו שיש לנו תחושה עבור כיצד התוכנית פועלת, אל תהסס ללכת לנהל איזה יותר דוגמאות משלך, אם תרצה בכך. בואו נתחיל עם מקבל המפתח מהמשתמש. באופן מסורתי, עם בעיות אחרות, יש לנו כבר רגיל מקבל כל מספרים שאנחנו צריך על ידי לשאול את המשתמש עם הפונקציה getint. אבל הפעם אנחנו באמת הולכים להשתמש את טענת שורת הפקודה ופונקציה חדשה בשם atoi. 

כאשר אתה מפעיל את הראשי תוכנית ב- C, אז זה לוקח בשתי parameters-- argc int, אשר הוא מספר הארגומנטים עבר, ולאחר מכן argv, מערך של מחרוזות אשר מכיל את רשימת כל הטיעונים חלפו. אתה לא במפורש יש להצהיר על משתנים אלה. הם שחושב אתה על ידי המהדר. בעזרת שימוש נכון לכך יהיה עבור argc להיות שניים במקרה הזה, יש משום שהמשתמש לעבור ב השיחה לתוכנית, ./caesar, ולאחר מכן על המקש, מה מספר שהם רוצים. אז זה אומר כי argc חייב להיות שני על מנת שע שימוש חוקי קיסר להיות מוצא להורג. 

אז בואו נסתכל על דוגמא. תגיד כבר כתבתי ו הידור תוכנית בשם blastoff. אז אם רצתי בשורת הפקודה צוות רוקט ./blastoff, טוב, אז, argc יהיה שלוש כי אני עברו שלוש טענות נפרדות. ואז argv ייראה כך. זה מערך, וזה היה מכילים כל אחד משלושת המיתרים. ./blastoff במדד, הקבוצה הראשונה ב, והרקטות הבאות האחרון. 

בואו נדבר על מערכים עבור שניות. מערכים הם מבני נתונים אשר מחזיקים ערכים מרובים מאותו הסוג. זה יכול להיות שימושי כאשר אנו יש רשימות של מספרים שלמים או מחרוזות. רק תזכור שיש להם כדי להיות מאותו הסוג. במדעי המחשב, אנחנו אוהב לספור מאפס, כך זוכר שמערכים הם גם צמודות אפס. אז האלמנט הראשון של המערך שלי הולך להיות מדד אפס. אז במקרה הזה, כאשר יש לי מערך באורך ארבעה, אז המדד האחרון של האלמנט האחרון של המערך שלי בעצם הולך להיות ב מדד שלוש, לא ארבע. כי יש לזכור, אנחנו מתחילים לספור על אפס. 

הנה דוגמה לאופן שבו אתה עשוי ליצור מערך משלך. אז נגיד שאני רוצה לאחסן שלי שלושה שמות כלב אהובים. אחר כך הייתי ליצור מערך של מחרוזות. אז הייתי להכריז על סוג, מחרוזת, ו ואז לשים את השם של המערך, כלבים, ואז באותם מרובע בסוגריים לשים את הגודל של array-- במקרה זה, שלוש. 

וכך, הרישום הראשון שלי הולך להיות כלבי מדד אפס, וזה הולך להיות מילוא. אז כלבי מדד אחד הולך להיות טפש, יקירי מוצ'י, ולאחר מכן האחרון כניסה, הכניסה השלישית במדד שני, הולך להיות Elphie חמוד, מתוק. תוכל להבחין כי בפורמט למילוי מערך זה מאוד דומה לאופן שבו כדאי להכריז על כל משתנה אחר שבו יש לך את השם משתנה ואחריו הערך שאתה רוצה לאחסן אותו. ההבדל היחיד במקרה זה הוא שאתה צריך לזכור לשים את המדד של הערך בסוגריים מרובעים. ויש לנו את שלנו שלושה כלבים אהובים. 

אך אבוי, זה הזמן לחזור קיסר. זכור כי שימוש נכון עבור המשתמש הוא הולך להיות עובר לא רק השם של התוכנית ./caesar, אבל גם המפתח שהם רוצים להעביר בטקסט שלהם על ידי. אז זה אומר כי argc חייב להיות שני. הם חייבים לעבור two-- לא יותר, לא פחות משני הארגומנטים של שורת הפקודה. 

עכשיו, מה לגבי argv? ובכן, אנחנו כבר יודעים כי מערך הולך להיות באורך שני, אבל מה הכלול כל רכיב? ובכן, הרכיב הראשון הולך להיות ./caesar, ואז האלמנט הבא הולך להכיל את המפתח שהמשתמש הקליד. עכשיו, אם הם השתמשו בו בצורה נכונה עבור השימוש של קיסר, אז הם הולכים להקליד מספר. אבל אף על פי אופי שהם מקלידים הוא מספר, זה של מחרוזת סוג הנתונים. 

אז איך אנחנו להמיר כי מחרוזת למספר שלם? אז נגיד שיש לי num, מחרוזת, המכיל את המחרוזת 50. אם אני רוצה להמיר את למספר שלם, אז אני פשוט מכריז על משתנה חדש, integer אני, קורא atoi. אני עובר במשתנה החוט שלי, num, ו אז אני אז אכיל את המספר 50. הקפידו לבדוק את האיש דפים לתפקוד atoi כדי לבדוק איזה ספרייה זה ב, כמו גם מה ערך יחזור אם המחרוזת עברה ב אינו מכיל את כל המספרים. 

אז עכשיו קיבלנו המפתח, הצעד הבא היא להשיג את בטקסט מהמשתמש. עכשיו, זה הולך להיות פחות מסובך מאשר לנווט ברחבי ארגומנטים משורת הפקודה. כל שעלינו לעשות הוא להתקשר פונקצית getstring לבקש מהמשתמש לתת לנו מחרוזת, אך יש לזכור כדי לבדוק את המפרט על האופן שבו אנו אולי כדאי להציג למשתמש על כך. 

כעת אנו מגיעים אל בלב problem-- איך להצפין בטקסט. ובכן, ראשית, בואו נדבר על איך כדי להצפין תו אחד בכל פעם, ואז נצטרך להתייחס איך לחזר על בטקסט כולו. כתבתי כמה פסאודו קוד לבעיית קיסר. אני ממליץ לך לכתוב בעצמך גם כן. זה אולי לא נראה זהה שלי, וזה בסדר, אבל כל עוד כמו הרעיון הכללי הוא זהה. 

שלושת הצעדים הראשונים כבר עשינו. קיבלנו את המפתח את טענת שורת הפקודה, הפכנו מפתח לתוך שלם, ויש לנו מתבקש המשתמש עבור בטקסט כי הם רוצים להצפין. אז את הנתח הגדול הבא כלומר עבור כל תו במחרוזת טקסט פשוט, אם זה האלפביתי, אנחנו רוצים לשמר את במקרה שלה ולהעביר אותה. על ידי לשמר מקרה, מה שאני אומר הוא שכל רישית מכתבים צריכים להישאר עליונים במקרה וכל אותיות קטנות צריך להישאר קטן. אז אחרי שאנחנו "מיליידיי", אז אנחנו להדפיס את המוצפן. 

הנה שלוש פונקציות כי הם הולכים כדי להיות שימושי עבור בעיה זו. זכור למעלה, כשנתתי את למשל עבור הסטה זו היא CS50? זכור כי 50 ואת סימן קריאה לא משמרת? אז איך אנחנו יכולים לדעת אם אנחנו צריך להסיט מכתב או לא? ובכן, "הוא אלפא," אם אתה עובר לו אופי, יחזיר אמת אם כי אופי הוא אחרת מכתב ושקרי. כדי לעזור לך עם היוון שמירה הן פונקציות "הוא העליון "ו" נמוך יותר. " 

שני תפקידים אלה גם לקחת ב תו בודד כקלט ולהחזיר לך בוליאני, או אמת או שקר תלוי אם כי אופי הוא במקרה גדול או קטן. בגלל "הוא עליון" ואת "הוא "נמוך הן פונקציות בוליאניות, כלומר הם חוזרים לך בוליאני, אתה יכול להשתמש אלה בתנאים שלך. אז הנה קטע קוד שרק מדפיס מכתב אם זה רישית. אז אני כבר הכרזתי הדמות שלי במכתב להיות המקרה העליון zed ואז אם "הוא עליונות" חזרות נכון, אז אני להדפיס את המכתב ההוא. 

אחזור הדוגמא הפשוטה שלנו הסטה האלפבית ידי מפתח של השני, איך אנחנו בעצם מקבלים כי לעבוד? ובכן, מתברר כי תווים ו שלמים מאוד קשורים זה לזה. לכל אחת מהדמויות יש ערך שלם הקשורים עם זאת נמצאת תרשים ASCII, כאשר כל ASCII של התו הערך מוצג. אז מקבילת מקרה עליון לערך ASCII של 65 וחוש קטן כדי ערך ASCII של 97. 

תרגיש חופשי להסתכל למעלה כל תרשים ASCII באינטרנט לראות את הערכים הללו בעצמך. אז מה שזה אומר זה שאנחנו יכולים לקחת את אופיו של אותיות גדולות, להוסיף את המספר השלם שתי אליו, ולאחר מכן לקבל ג רישית אופי כתוצאה מכך. הסיבה לכך היא 65, ASCII ערך עבור הון, בתוספת 2, נותן לנו 67, אשר תואם על אופיו של ג רישית 

למרבה הצער, דברים לא יהיה פשוט כל כך. יש לנו משוואה אנחנו צריכים לשקול. הנה זה אומר לנו כי מוצפן ה- i מכתב תואם את בטקסט ה- i מכתב, בתוספת key-- כל זה, מודולרי 26. מדוע זה כך? בואו נחזור לדוגמא שלנו מ לפני, בירה שם, בתוספת 2, נותן לנו ג ההון 

אז החל למשוואה המפרט נותן לנו, אז בואו ניקח הון בתוספת 2 ו mod כי ב -26. אז ההון A, כאשר שמתי אותו אלה גרשיים, מאפשר לי להתייחס אליו כאל מספר שלם, כך מאפשר לי להפיל אותו לשווי ASCII שלו, 65. 65 פלוס 2 הוא 67. 67 mod 26 נותן לנו 15, אבל זה לא באמת הגיוני כי אנחנו יודעים כי ערך ASCII הון C הוא 67, לא 15. אז איך אפשר ליישב את זה? 

ובכן, כאן אני רוצה להניח הרעיון של אינדקס אלפביתי. אז אנחנו כבר דיברנו על איך יש כל תו ערך ASCII שלה, אבל אני רוצה לומר, טוב, בוא לחשוב על כל תו גם שיש אינדקס אלפביתי, כאשר A למשל, כמו האות הראשונה של האלף-בית, יש אינדקס אלפביתי של אפס. אז עכשיו בואו ליישם את משוואה זהה לפני, אבל שימוש באינדקס אלפביתי. 

אז A הוא אפס, כפי שהגדרנו. אז לוקחים אפס פלוס שניים, mod 26, זה שני, mod 26, אשר נותן לנו שני. וזה טוב, במונחים של אינדקס אלפביתי, C היא האות השלישית האלפבית, כך יתאים למדד אלפביתי של השני. לכן נראה כי באמצעות אינדקס אלפביתי במקרה זה למעשה נותן לנו את התוצאה הנכונה. 

אז עכשיו בואו לבדוק כדי לראות אם עבודות המשוואה עם אינדקס אלפביתי. אינדקס אלפביתי של Y הוא 24 כמו שני האות האחרונה באלפבית. אז 24 פלוס שלנו המפתח של שני נותן לנו 26. 26 mod 26 נותן לנו 0, אשר, מזל לנו, הוא המדד אלפביתי עבור א אז אני מקווה שזה מספיק ראיות לכך שיטת אינדקס אלפביתי עובדת. אם לא, אל תהססו לנסות כמה דוגמאות משלך. 

כדי לעטוף כראוי סביב האלפבית ולהחיל את המשוואה קיסר, אז אנחנו יודעים שאנחנו צריכים להתמודד עם מדדי אלפביתי. אבל נתחיל עם ASCII ערכים, ורק אז אנחנו מכן להמיר מדד אלפביתי. משם, כדי להדפיס, אנחנו צריכים כדי להתמודד עם ערכי ASCII שוב. אז אנחנו צריכים להבין איך עובר מ ASCII כדי אלפביתי ומן אלפביתי כדי ASCII. 

אז אני משאיר לך את זה כדי להבין התבנית בין דמות אלפביתי שלה מדד וערך ASCII שלו. עכשיו, יש לזכור כי למרות נכון בטבלה זו בשקופית מציגים את האותיות הגדולות, אנחנו גם יש לשקול אם או לא דפוס שונה חל עבור תווים באותיות קטנות. 

אז עכשיו הבנו איך להעביר תו בודד, אז כל מה שאנחנו צריכים לעשות זה בקנה מידה עד לחצות בטקסט כולו. אז בטקסט הוא מחרוזת. למזלנו, מחרוזת הוא באמת רק מערך של תווים, זאת על מנת לגשת לכל תו של מחרוזת, כל מה שאתה צריך לעשות הוא להשתמש בסימון מערך. נגיד שיש לי משתנה מסוג מחרוזת בשם "text =" זה CS50. ' " 

ובכן, אם כן, על מנת לגשת כל תו, כל מה שאני צריך לעשות עם הטקסט משתנה הוא לומר כן, טקסט מדד אפס, כי מתאים טקסט ט הון מדד עם ציון במקרה h הנמוך. פונקציה שימושית נוספת היא פונקצית אורך חוט. אז עובר מחרוזת הפונקציה תחזור מספר שלם, לכל האורך של מחרוזת. 

עכשיו שאנחנו כבר דברנו על כל הגורמים האלה, בואו להחזיר אותם ביחד. אז לחזור או פסאודו קוד שלי קוד או פסאודו קוד שלך ולעבור ולוודא כי אתה יודע איך לעשות כל דבר ודבר. כיצד משיגים את המפתח באמצעות argc ו argv, סיבוב המפתח לתוך מספר שלם, ל i, מה שגרם עבור בטקסט, getstring, ולאחר מכן חזרה על על כל דמות מחרוזת בטקסט, שמירה על המקרה של כל דמות הסטה כי אופי לפי המפתח, הבטחת שאתה גלישה סביב האלפבית, ולבסוף הדפסת מוצפן זה. שמי Amila, וזה היה קיסר. 