Amila: Leiskite spręsti tiktai ciesorių ". Be Cezaris, mes leisti vartotojui koduoti slaptą žinutę. Taigi leiskite pasinerti į dešinę ir ieškoti mūsų TO-DOS šią problemą. Todėl pirmiausia, mes gauti raktą iš vartotojo. Tada mes gauti paprastojo kad jie nori koduoti. Po to, mes šifruoti už jį, ir pagaliau mes spausdinti savo ciphertext. 

Taigi pradėkime su pavyzdys. Pasakykite, kad norėjo koduoti Visa abėcėlė su dviejų raktu. Na, visą savo abėcėlė būtų tiesiog būti perkeltas į laiškus. Taigi būtų koduoti C, B D, C-E, taip toliau ir taip toliau, kol gausite į X, kuris koduoja iki Z arba Zed, priklausomai nuo to, kur esate iš. Tada Y tuomet pereiti visą kelią, apvynioti abėcėlės patekti į A, ir galiausiai paskutinis laiškas abėcėlė, Z Zed, bus koduoti į tašką B. 

Jūs turite tai? Pažvelkime į keletą pavyzdžių. Pirmasis pavyzdys čia yra labai panašus kas mes ką tik paaiškinta pirmiau. Taigi, jei aš koduoti kai skirsnį abėcėlė, nuo A iki L, iš dviejų raktą, tada aš tiesiog gauti savo visą abėcėlė perėjo dvi raides. 

Tada, mano kitą, pavyzdžiui, svarbiausia yra dar du, todėl jūs vis dar reikia žinoti kokios raidės tikėtis. Bet čia tai frazė. Tai CS50. Taigi, jūs pastebėsite, kad aš išsaugoti savo laiškuose bylą, taip bet didžiosios raidės, taip pat didžiosios raidės į ciphertext. Ir bet mažosiomis raidėmis raidės paprastojo taip pat mažąsias raidės ciphertext. Bet aš nuolat raides ir bet šauktukai arba bet kuri kita skyryba tą patį. 

Taigi dabar, kad mes turime jausmą už tai, kaip programa veikia, nedvejodami eiti paleisti kai daugiau pavyzdžių savo, jei norite. Pradėkime su vis raktas nuo naudotojo. Tradiciškai su kitų problemų, mes buvo įpratę gauti bet numeriai, kad mes reikia iki paskatino vartotoją su funkcija getint. Bet šį kartą mes iš tikrųjų ketiname naudoti komandinės eilutės argumentus ir nauja funkcija vadinama atoi. 

Paleidus pagrindinis programa C, tada jis trunka dvi parameters-- INT argc, kuris yra argumentų skaičius priimtas, ir tada argv, kurio stygos masyvas, kuriame yra kai visų iš argumentų sąrašas praėjo. Jūs neturite aiškiai turi pripažinti šiuos kintamuosius. Jie apskaičiuojami Jūs sudarytojas. Teisingas naudojimas tai būtų už argc būti du šiuo atveju, nes vartotojas turi pereiti į kvietimas į programą, ./caesar, ir tada raktas, kokia numerį jie nori. Taigi, tai reiškia, kad argc turi būti du tam, kad galiojantis naudojimo Cezaris turi būti vykdomi. 

Taigi pažvelkime pavyzdys. Pasakyti, kad aš jau parašyta ir parengė programą "blastoff. Taigi, jei išbėgau į komandų eilutę ./blastoff Komanda raketų, gerai, tada, argc būtų tris, nes aš praėjo trys atskiri argumentais. Tada argv atrodytų taip. Tai masyvas, ir tai būtų būti kiekvieną iš trijų stygos. ./blastoff pirmoje indekso, komanda į kitą, ir raketų paskutinis. 

Pakalbėkime apie masyvų DĖL sek. Masyvai yra duomenų struktūros, turinčių keletą reikšmių, tos pačios rūšies. Tai gali praversti, kai mes turi sąrašus sveikieji ar tinkleliuose. Tiesiog neužmirškite, jie turi būti to paties tipo. Computer Science, mes myliu skaičiuoti nuo nulio, todėl nepamirškite, kad masyvai Taip pat yra nulinės indeksuojami. Taip pirmojo elemento savo masyvo bus ne indeksą nulio. Šiuo atveju taip, kai aš turėti kurio ilgis keturių masyvas, tada paskutinis indeksas paskutinis elementas mano masyvo iš tikrųjų bus ne trys, o ne keturi indeksą. Nes atsimenu, mes pradėti skaičiuoti iki nulio. 

Štai kaip jūs pavyzdys gali sukurti jūsų pačių masyvo. Taigi pasakyti, kad aš norėjau išsaugoti savo trys mėgstamiausios Šunų vardai. Tada aš norėčiau sukurti eilučių masyvo. Taigi norėčiau juos paskelbti tipo, eilutę, ir tada įdėti pavadinimą masyvo, Šunys, ir tada tose aikštėje skliausteliuose įdėti dydį iš šiuo atveju, trijų array--. 

Taigi mano pirmasis įrašas vyksta būti šunų indeksas lygus nuliui, ir tai bus Milo. Tada šunims indeksą vieno bus Goofy, Darling Moto, tada paskutinis įrašas, trečias įrašas dviejų indeksas, bus mielas, saldus Elphie. Jūs pastebėsite, kad formatu pildymo šio masyvo yra labai panašūs kaip galite pranešti apie bet kokią kitą kintamąjį kur Jūs turite kintamojo pavadinimą, po to vertė, kuriuos norite laikyti jį. Vienintelis skirtumas šiuo atveju yra tai, kad jums prisiminti įdėti indeksą iš kvadrātiekavām vertės. Ir mes turime trys mėgstamiausios šunys. 

Bet deja, atėjo laikas grįžti į Cezaris. Atminkite, kad teisingą naudojimą už vartotojas bus einančios į ne tik iš programos ./caesar vardas, bet Taip pat svarbu, kad jie nori pereiti jų paprastasis iki. Taigi, tai reiškia, kad argc turi būti du. Jie turi praeiti two-- ne daugiau ir ne mažiau nei du komandinės eilutės argumentus. 

Dabar, ką apie argv? Na, mes jau žinome, kad masyvas bus Ilgio du, bet kas esantis kiekvieno elemento? Na, pirmasis elementas bus ./caesar, ir tada kitas elementas ketina yra raktas, kad vartotojas turi įvesti. Dabar, jei jie naudojami teisingai už Cezaris naudojimas, tada jie ketina įvesti skaičių. Bet nors charakterio kad jie tipo yra skaičius, tai duomenų tipas eilutę. 

Taigi, kaip mes konvertuoti, kad eilutė iki sveikojo skaičiaus? Taigi sako Turiu num, styginių, kuriame eilutę 50. Jei aš noriu konvertuoti, kad iki sveikojo skaičiaus, tada aš tiesiog paskelbti naują kintamąjį, sveikasis skaičius i, telefonu atoi. Galiu perduoti mano styginių kintamojo, num, ir tada aš tada yra skaičių 50. Įsitikinkite, kad patikrinti vyro puslapių, atoi funkcija patikrinti, kurie biblioteka tai į, taip pat, kas jį vertina grįš jei eilutė praėjo į nėra visų numerius. 

Taigi, dabar, kad mes Dotarłeś raktas, kitas žingsnis yra gauti paprastojo iš vartotojo. Dabar tai vyksta į būti mažiau sudėtingas nei naršyti aplink komandinės eilutės argumentai. Visi mes turime padaryti, tai paskambinti getstring funkcija kad tai paskatins vartotoją duoti mums eilutę, tačiau nepamirškite, patikrinti kiek specifikacijas mes galbūt norėsite greitai už tą vartotoją. 

Dabar mes einame į širdis problem-- Kaip šifruoti paprastojo. Na, visų pirma, pakalbėkime apie tai, kaip į šifruoti vieną simbolį vienu metu, ir tada mes spręsti, kaip pakartoti per visą paprastojo. Aš parašiau šiek tiek Pseudocode už Cezario problema. Raginu jus Parašykite savo taip pat. Tai gali ne atrodo identiškas mano, ir kad viskas OK, bet kaip ilgai kaip bendra idėja yra ta pati. 

Pirmieji trys žingsniai mes jau padaryta. Mes Dotarłeś raktą iš komandinės eilutės argumentas, mes pasuko tą raktą į sveikojo skaičiaus, ir mes paskatino dėl paprastojo vartotoją kad jie nori šifruoti. Taigi šalia didelis gabalas yra tai, kad kiekvieną simbolį į paprastojo eilutę, jei tai Abėcėlinis, norime išsaugoti savo argumentus ir perkelti ją. Iki išsaugoti atveju, ką aš reiškia, kad visi didžiosiomis raidėmis raidės turi išlikti Aukštutinė atveju ir mažosiomis raidėmis turėtų likti mažosiomis raidėmis. Taigi, kai mes pereiti tiems, tada mes spausdinti ciphertext. 

Čia yra trys funkcijos, kurie ketina ateiti patogu šią problemą. Įsiminti iki aukščiau, kai daviau pavyzdys perkeliant tai CS50? Atminkite, kad 50 ir šauktukas nebuvo perkelti? Taigi, kaip mes galime pasakyti, ar mes reikia perkelti laišką ar ne? Na, "yra alfa", jei pereisite tai charakteris, grįš tiesa, jei tai charakteris yra raidė ir false kitaip. Norėdami padėti jums su išsaugoti kapitalizacija yra funkcijos "yra viršutinis "ir" yra mažesnis. " 

Šios dvi funkcijos taip pat imtis vienu pobūdžio kaip įėjimo ir grąžinti jums Būlio, arba true arba false priklausomai nuo to, ar tą charakterio yra didžiosiomis arba mažosiomis raidėmis. Nes "yra viršutinio" ir "yra mažesnis "yra Bulio funkcijos, tai reiškia, kad jie grįžta jums Būlio, Galite naudoti šias savo sąlygas. Taigi čia kodo fragmentą, kad tik spausdina laišką, jei tai viršutinė atveju. Taigi aš paskelbė savo charakterį laiškas turi būti viršutinis dėklas Zed ir tada, jei "yra viršutinis" grįžta tiesa, tada atspausdinti šį laišką. 

Grįžtant prie mūsų paprastą pavyzdį perkeliant abėcėlė iš dviejų raktą, kaip mes iš tikrųjų gauti, kad į darbą? Na, paaiškėja, kad simbolių ir sveikieji skaičiai yra labai glaudžiai susiję. Kiekvienas personažas turi sveikas reikšmė, susijusi su juo rasti ASCII lentelę, kur kiekvienas simbolis yra ASCII rodoma reikšmė. Taigi viršutinę atveju Atitinka į ASCII vertės 65 ir mažosiomis raidėmis nuo A iki ASCII vertė 97. 

Jauskitės laisvai ieškoti bet ascii diagrama internete pamatyti šias vertybes sau. Taigi, ką tai reiškia, kad mes galime imtis iš didžiųjų raidžių simbolį, pridėti sveiką skaičių nuo dviejų iki jį, ir tada gauti simbolis viršutinė byla C, kaip rezultatas. Tai todėl, kad 65, ASCII Vertė kapitalo A, plius 2, suteikia mums 67, o tai atitinka į didžiųjų raidžių C pobūdžio 

Deja, viskas nebus gana būti taip paprasta. Mes turime lygtį, kad mes turime apsvarstyti. Čia jis pasakoja, kad i-tojo ciphertext laiškas atitinka i-ajai paprastojo laiškas, plius key-- visa tai, modulinė 26. Kodėl yra tai, kad tuo atveju? Grįžkime prie mūsų pavyzdžio iš anksčiau, kur kapitalas A plius 2, suteikia mums kapitalo C. 

Taigi taikant lygtį, kad specifikacija suteikia mums, tada galime imtis kapitalo A plius 2 ir mod, kad 26. Taigi kapitalo A, kai aš įdėti jį į tie viengubų kabučių, leidžia man ją gydyti, kaip sveikas skaičius, taip, kad leidžia man mesti savo ASCII vertės, 65. 65 plius 2 yra 67. 67 mod 26 suteikia mums 15, bet tikrai ne prasmės, nes mes žinome, kad kapitalas, C ASCII reikšmė yra 67, o ne 15. Taigi, kaip mes suderinti, kad? 

Na, čia aš norėčiau Teigti sąvoka abėcėlinė rodyklė. Taigi, mes jau kalbėjome apie tai, kaip Kiekvienas personažas turi savo ASCII vertę, bet aš norėčiau pasakyti, gerai, tegul galvoti apie kiekvienas simbolis, taip pat turintys abėcėlinė rodyklė, kur A pavyzdžiui, kaip pirmąją abėcėlės raidė, turi abėcėlinė rodyklė nulio. Taigi dabar galime taikyti tas pats lygtis kaip ir anksčiau, bet naudojant abėcėlinę rodyklę. 

Taigi A yra nulis, kaip mes apibrėžti. Taigi atsižvelgiant nulis plius du, mod 26, tai du, mod 26, kuris suteikia mums du. Ir gerai, kalbant apie abėcėlinė rodyklė, C yra trečioji raidė abėcėlės, taip, kad atitiktų į abėcėlinė rodyklė dviejų. Taigi atrodo, kad naudojant abėcėlinė rodyklė šiuo atveju iš tikrųjų mums suteikia teisingą rezultatą. 

Taigi dabar galime patikrinti, pamatyti, jei lygties darbų su abėcėlinė rodyklė. Y raidiniai indeksas yra 24, nes Antrasis į paskutinę raidę abėcėlėje. Taigi 24 plius mūsų pagrindinis iš dviejų suteikia mums 26. 26 mod 26 suteikia mums 0, kuris, Lucky mums, yra abėcėlinis indeksas A. Taigi tikiuosi, kad tai pakankamai, kad įrodymas Abėcėlinis indekso metodas veikia. Jei ne, nedvejodami išbandyti kai savo pavyzdžių. 

Siekiant tinkamai apvynioti abėcėlė ir taikyti Caesar lygtį, tada mes žinome, kad reikia susidoroti su abėcėlės indeksus. Bet mes pradėti su ASCII vertės, ir tik tada mes tada konvertuoti į Abėcėlinis indeksas. Iš ten, kad būtų atspausdinti, turime susidoroti su ASCII vertybių dar kartą. Taigi, mes turime išsiaiškinti, kaip eik iš ASCII abėcėlės ir nuo abėcėlę ASCII. 

Taigi, aš palikti jį jums išsiaiškinti tarp personažo modelis ir jos pagal abėcėlę indeksas ir jo ASCII reikšmė. Dabar, prisiminkite, kad nors Šioje lentelėje tiesiai ant skaidrės rodo didžiosios raidės, mes taip pat turi apsvarstyti, ar taikomas kitoks modelis žemesnių raidėmis. 

Taigi, dabar, kad mes suprato, kaip pereiti vieną simbolį, tada visi mes turime padaryti, tai masto, kad iki go visoje paprastojo. Taigi paprastasis yra eilutė. Lucky mus seka yra tikrai tik simbolių masyvas, taip, kad būtų pasiekti kiekvieną požymį Styga, viskas, ką turite daryti yra naudoti masyvo notacijos. Pasakykite turiu tipo kintamasis eilutė vadinama "tekstas =" tai CS50 ". 

Gerai, tada, tam, kad prieigos prie kiekvieno charakterį, viskas, ką turiu daryti su kintamasis tekstas pasakyti gerai, tekstas ne indeksą nulio, kad atitinka kapitalo T. tekstą indeksą vienas atitinka mažąją h. Dar viena naudinga funkcija yra eilutė ilgis funkcija. Taigi einančios į eilutę kad funkcija grįš sveikas skaičius, šios eilutės ilgis. 

Dabar, kad mes kalbėjome apie Visi šie skirtingi elementai, tegul juos atgal kartu. Taigi sugrįžti į bet mano Pseudocode kodas arba jūsų Pseudocode ir eiti per ir įsitikinkite, kad jums žinoti, kaip tai padaryti kiekvienas dalykas. Kelionė raktą naudojant argc ir argv, sukdami raktą į visumą A I, stebinčių paprastojo, getstring, tada Iteracja per kiekvieną personažo paprastojo eilutė, išlaikant kiekvieno pobūdžio bylą ir perkelia tą simbolį raktą, užtikrinti, kad esate vyniojimo aplink abėcėlės, pagaliau spausdinant kad ciphertext. Mano vardas Amila, ir tai buvo Cezaris. 