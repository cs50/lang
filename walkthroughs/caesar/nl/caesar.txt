Amila: Laten we pakken Caesar. In Caesar, laten we de gebruiker een geheime boodschap coderen. Dus laten we duiken recht in en kijk onze Taken voor dit probleem. Dus eerst, krijgen we de sleutel van de gebruiker. Dan krijgen we de plaintext dat ze willen coderen. Daarna vercijferen we het voor hen, en ten slotte een afdruk van hun cijfertekst. 

Dus laten we beginnen met een voorbeeld. Stel dat je wilde het coderen volledige alfabet met een sleutel van twee. Nou, je hele alfabet zou gewoon worden verschoven naar letters. Dus A zou coderen naar C, B aan D, C naar E, enzovoort enzovoort, totdat je bij X, dat codeert tot Z of zed, afhankelijk van waar je vandaan komt. Dan zou Y dan verschuiven de hele weg, wikkel rond het alfabet om A te krijgen, en dan eindelijk de laatste letter van de alfabet, Z, zed, zou coderen naar B. 

Je hebt het? Laten we eens kijken naar enkele voorbeelden. Het eerste voorbeeld is hier vergelijkbaar met wat we net boven uitgelegd. Dus als ik het coderen van een aantal deel van de alfabet A tot L, met een sleutel van twee, dan krijg ik gewoon mijn hele alfabet verschoven twee letters. 

Dan, in mijn volgende voorbeeld, de sleutel nog twee dus je moet nog steeds weten die brieven te verwachten. Maar hier is het een zin. Dit is CS50. Dus je zult merken dat ik het behoud van het geval van mijn brieven, dus elke hoofdletters zijn ook hoofdletters in de cijfertekst. En alle kleine letters letters in het leesbare Ook kleine letters letters in de cijfertekst. Maar ik blijf de letters en eventuele uitroeptekens of andere leestekens hetzelfde. 

Dus nu hebben we een gevoel voor hoe het programma werkt, voel je vrij om te gaan lopen wat meer voorbeelden van je eigen, als je wilt. Laten we beginnen met het krijgen van de sleutel van de gebruiker. Traditioneel, met andere problemen, we hebben gewend aan het krijgen alle nummers die we moet door de gebruiker wordt gevraagd met de functie getint. Maar deze keer zijn we eigenlijk aan de hand aan de opdrachtregel argument gebruiken en een nieuwe functie genaamd atoi. 

Wanneer u de belangrijkste run programma in C, dan neemt in twee parameters-- int argc, die is het aantal argumenten doorgegeven, en dan argv, een array van strings die bevat de lijst van alle argumenten doorgegeven. Je hoeft niet expliciet hebben deze variabelen verklaren. Ze zijn berekend voor u door de compiler. Correct gebruik hiervoor zou zijn voor argc twee in dit geval, omdat de gebruiker door te geven in de oproep tot het programma, ./caesar, en dan de sleutel, welk nummer ze willen. Dus dat betekent dat argc moeten twee Om een ​​geldig gebruik van Caesar worden uitgevoerd. 

Dus laten we eens kijken naar een voorbeeld. Zeggen dat ik heb al geschreven en stelde een programma genaamd blastoff. Dus als ik liep in de opdrachtregel ./blastoff Team Rocket, nou, dan, argc zou drie zijn, want ik aangenomen in drie verschillende argumenten. Dan argv zou er zo uitzien. Het is een array en het zou bevatten elk van de drie snaren. ./blastoff de eerste index, team in de volgende, en de raket in de laatste. 

Laten we praten over arrays voor een sec. Arrays zijn datastructuren die in het bezit meerdere waarden van hetzelfde type. Dit kan van pas komen wanneer we hebben lijsten van integers of strings. Vergeet niet ze hebben hetzelfde type zijn. In de informatica, we hou tellen van nul, dus vergeet niet dat arrays Ook nul geïndexeerd. Dus het eerste element van mijn serie gaat worden op index nul. Dus in dit geval, als ik een array met lengte vier, dan is de laatste index van de laatste element van mijn serie is eigenlijk gaat worden bij index drie, niet vier. Want vergeet niet, we beginnen te tellen bij nul. 

Hier is een voorbeeld van hoe u misschien een reeks van je eigen te maken. Dus zeg ik wilde slaan mijn drie favoriete hond namen. Dan zou ik een array van strings te creëren. Dus ik zou het soort, touwtje te verklaren, en zet dan de naam van de array, honden, en dan in die vierkante haakjes zet de grootte van de array-- in dit geval drie. 

Dus mijn eerste binnenkomst gaat voor honden op index nul, en dat gaat Milo zijn. Dan honden bij index één goofy zal zijn, lieveling Mochi, en dan de laatste binnenkomst, de derde ingang op index twee, gaat schattig, lief Elphie zijn. U zult merken dat het formaat voor het invullen van deze array lijkt erg op hoe je misschien verklaren een andere variabele, waar je hebt de naam van de variabele, gevolgd door de waarde die u wilt opslaan in. Het enige verschil in dit geval is dat je aan te denken om de index te zetten van de waarde tussen vierkante haken. En daar hebben we onze drie favoriete honden. 

Maar helaas, het is tijd terug naar Caesar te krijgen. Vergeet niet dat het juiste gebruik van de gebruiker zal passeren in niet alleen de naam van het programma ./caesar, maar ook de sleutel die ze willen verschuiven hun plaintext door. Dus dat betekent dat argc twee moeten zijn. Zij moeten passeren two-- niet meer, niet minder dan twee command line argumenten. 

Nu, hoe zit het met argv? Nou, we weten al dat de reeks gaat lengte twee zijn, maar wat er in elk element? Nou, het eerste element zal ./caesar zijn, en dan de volgende element gaat bevat de sleutel die de gebruiker getypt. Nu, als ze gebruikt correct voor het gebruik van Caesar, dan zijn ze gaan in een getal. Maar hoewel het karakter dat ze typen een getal, het is van het type data string. 

Dus hoe kunnen we zetten dat string naar een integer? Dus zeg ik num, een string, met het koord 50. Als ik wil om te zetten die naar een integer, dan heb ik gewoon verklaren een nieuwe variabele, een integer i, belt atoi. Ik pas in mijn stringvariabele, num, en dan zal ik dan bevat het nummer 50. Zorg ervoor dat u de man te controleren pagina's voor de atoi functie om te controleren welke bibliotheek het is in, en welke waarde het zal terugkeren als de string doorgegeven in niet alle nummers bevatten. 

Dus nu dat we hebben gekregen de sleutel, de volgende stap is het leesbare van de gebruiker ontvangen. Nu, dit gaat minder ingewikkeld dan navigeren rond de command line argumenten. Alles wat we moeten doen is bellen de getString functie om de gebruiker te vragen geven ons een string, maar vergeet niet aan de specificaties voor de manier waarop we controleren Wellicht wilt u de gebruiker voor die vragen. 

Nu komen we bij de hart van de probleem-- hoe de plaintext vercijferen. Nou, ten eerste, laten we praten over hoe een teken vercijferen tegelijk, en dan zullen we pakken hoe itereren over de hele plaintext. Ik heb een aantal pseudocode geschreven voor de Caesar probleem. Ik moedig u aan schrijf uw eigen ook. Het is misschien niet identiek te kijken de mijne, en dat is OK, maar zolang de algemene idee is hetzelfde. 

De eerste drie stappen hebben we al gedaan. We hebben de sleutel van gekregen de command line argument, we hebben bleek dat de belangrijkste in een integer, en we hebben gevraagd de gebruiker voor de plaintext dat ze willen vercijferen. Dus dan is de volgende grote brok dat voor elke letter in het leesbare tekenreeks, als het alfabetisch, we willen behouden haar zaak en verschuiven. Door het behoud van het geval, wat ik bedoel is dat alle hoofdletters brieven moeten bovenste blijven zaak en kleine letters moet blijven kleine letters. Dan, nadat we verschuiven die, vervolgens afdrukken we de cijfertekst. 

Hier zijn drie functies die gaan te pas komen voor dit probleem. Vergeet niet boven toen ik gaf de Bijvoorbeeld voor het verschuiven is CS50? Vergeet niet dat de 50 en de uitroepteken niet verschuiven? Dus hoe kunnen we zeggen of we nodig hebt om een ​​brief te verschuiven of niet? Nou, "is alpha," als passeer je het een karakter, zal terugkeren waar als dat personage is een brief en anders false. Om u te helpen bij behoud van kapitalisatie zijn de functies "wordt bovenste "en" lager ". 

Deze twee functies houden ook in een enkel karakter als input en keert u terug een Booleaanse, waar of onwaar gelang dat teken is hoofdletters of kleine letters. Omdat "is boven" en "is lager "zijn Booleaanse functies, wat betekent dat zij terugkeren u een Booleaanse, kunt u deze gebruiken in uw omstandigheden. Dus hier is een stukje code dat alleen drukt een brief als het hoofdletters. Dus ik heb mijn karakter verklaard brief worden de hoofdletters zed en dan als "is de bovenste" returns waar is, dan printen ik die brief. 

Teruggaan naar onze eenvoudig voorbeeld van verschuiven van het alfabet met een sleutel van twee, hoe kunnen we eigenlijk die aan het werk? Nou, het blijkt dat de personages en integers zijn zeer nauw verwant. Elk personage heeft een integer waarde geassocieerd met het gevonden in de ASCII grafiek, waarbij ASCII elk personage waarde wordt weergegeven. Dus een hoofdletter A correspondeert een ASCII-waarde van 65 en een kleine naar een een ASCII-waarde van 97. 

Voel je vrij om te zoeken elke ASCII grafiek online om deze waarden te zien voor jezelf. Dus wat dit betekent is dat we kunnen neem het karakter van hoofdletter A, voeg de integer twee om het, en dan krijg het karakter hoofdletter C als gevolg. Dat komt omdat 65, de ASCII waarde voor het kapitaal A, plus 2, geeft ons 67, wat overeenkomt om het karakter van hoofdletter C. 

Helaas, dingen zal niet helemaal zo eenvoudig. We hebben een vergelijking die we moeten overwegen. Hier vertelt ons dat de ide ciphertext letter correspondeert met de i-plaintext letter, plus de key-- dat alles, modulaire 26. Waarom is dat zo? Laten we teruggaan naar ons voorbeeld van vóór, waar de hoofdletter A, plus 2, geeft ons kapitaal C. 

Dus het aanbrengen van de vergelijking die de specificatie geeft ons, dan laten we kapitaal A plus 2 en mod die met 26. Dus hoofdletter A, toen ik het in die enkele aanhalingstekens, stelt me ​​in staat om het te behandelen als een integer, zodat toelaat me om het te werpen om de ASCII-waarde, 65. 65 plus 2 is 67. 67 mod 26 geeft ons 15, maar dat niet echt zinvol, omdat we dat weten hoofdletter C ASCII-waarde is 67, niet 15. Dus hoe kunnen we dat met elkaar te verzoenen? 

Nou, hier wil ik het poneren notie van een alfabetische index. Dus we hebben al gesproken over hoe elk personage heeft zijn ASCII-waarde, maar ik zou willen zeggen, nou ja, laten we na te denken over elk personage ook met een alfabetische index, waarbij A bijvoorbeeld als de eerste letter van het alfabet, heeft een alfabetische index van nul. Dus laten we nu toepassen dezelfde vergelijking als voorheen, maar met behulp van een alfabetische index. 

Dus A nul is, zoals we hebben gedefinieerd. Dus vervolgens het nemen van nul plus twee, mod 26, dat is twee, mod 26, die geeft ons twee. En ja, in termen van een alfabetische index, C is de derde letter in de alfabet, dat overeenkomt naar een alfabetische index van twee. Dus lijkt het erop dat met de alfabetische index in dit geval eigenlijk geeft ons het juiste resultaat. 

Dus laten we nu controleren zien of de vergelijking werken met een alfabetische index. alfabetische index Y is 24 als de na laatste letter in het alfabet. Dus dan 24 plus onze sleutel van twee geeft ons 26. 26 mod 26 geeft ons 0, die, gelukkig voor ons, is de alfabetische index voor A. Dus hopelijk dat is bewijs genoeg dat de alfabetische index methode werkt. Zo niet, dan voel je vrij om uit te proberen enkele voorbeelden van uw eigen. 

Om goed te wikkelen rond de alfabet en breng de Caesar vergelijking, dan weten we dat we moeten omgaan met alfabetische indices. Maar we beginnen met ASCII waarden, en dan pas Doen wij dan om te zetten in de alfabetische index. Vandaar, om te kunnen afdrukken, moeten we opnieuw te behandelen met ASCII waarden. Dus we moeten uitzoeken hoe om te gaan van ASCII naar alfabetische en van alfabetisch naar ASCII. 

Dus ik laat het aan u om erachter te komen het patroon tussen een personage en zijn alfabetisch index en de ASCII-waarde. Nu, vergeet niet dat ook al deze tabel rechts op de dia toont de hoofdletters, wij ook moeten overwegen of niet een ander patroon van toepassing voor de kleine letters. 

Dus nu hebben we bedacht hoe je een enkel karakter te verschuiven, dan alles wat we moeten doen, is schaal die up te gaan over de hele plaintext. Dus de plaintext is een string. Gelukkig voor ons, een string is echt slechts een array van karakters, dus in om toegang te krijgen tot elk karakter van een string, alles wat je hoeft te doen is array notatie. Zeggen dat ik een variabele van het type tekenreeks genaamd "text = 'dit is CS50.' ' 

Nou, dan, met het oog op toegang tot elk karakter, alles wat ik heb te maken met de variabele tekst is om goed te zeggen, tekst bij index nul, dat komt overeen met het kapitaal T. tekst bij index men overeen met de kleine letters h. Een andere handige functie is de lengte van de string functie. Zo passeren in een string die functie zal terugkeren een geheel getal dat de lengte van string. 

Nu we hebben gesproken over al deze elementen, laten we ze weer bij elkaar. Dus terug naar ofwel mijn pseudocode code of uw pseudocode en ga door en zorg ervoor dat u weten hoe ze elk ding te doen. Het verkrijgen van de sleutel met behulp van argc en argv, de sleutel tot een geheel getal, een i, wordt gevraagd voor platte tekst, getString, en dan itereren meer dan elk karakter in het leesbare tekenreeks, bewaren bij elk teken en het verschuiven van dat karakter door de sleutel, ervoor te zorgen dat u bent wikkelen rond het alfabet, eindelijk afdrukt dat cijfertekst. Mijn naam is Amila, en dit was Caesar. 