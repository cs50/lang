1
00:00:00,000 --> 00:00:00,760

2
00:00:00,760 --> 00:00:02,270
>> AMILA：让我们来解决凯撒。

3
00:00:02,270 --> 00:00:06,110
在凯撒，我们允许用户
编码一个秘密消息。

4
00:00:06,110 --> 00:00:09,780
因此，让我们言归正传，来看看
在我们的待办事项这个问题。

5
00:00:09,780 --> 00:00:12,210
因此，首先，我们从用户的关键。

6
00:00:12,210 --> 00:00:15,210
然后，我们得到明文
他们要编码。

7
00:00:15,210 --> 00:00:21,380
在那之后，我们进行加密为他们，
最后我们打印他们的密文。

8
00:00:21,380 --> 00:00:23,600
>> 所以，让我们先从一个例子。

9
00:00:23,600 --> 00:00:26,920
假设你想编码
整个字母表与两个键。

10
00:00:26,920 --> 00:00:31,360
那么，你的整个字母表会
只是转移到字母。

11
00:00:31,360 --> 00:00:37,060
因此，A将编码为C，B，以
D，C至E，等等等等，

12
00:00:37,060 --> 00:00:42,470
直到进入X，编码到Z
捷思还是取决于你来自哪里。

13
00:00:42,470 --> 00:00:47,445
那么Y就再移位一路，
环绕字母去A，

14
00:00:47,445 --> 00:00:53,256
然后最后的最后一个字母
字母表，Z，捷思，将编码为B.

15
00:00:53,256 --> 00:00:54,660
>> 你明白了吗？

16
00:00:54,660 --> 00:00:56,380
让我们来看一些例子。

17
00:00:56,380 --> 00:01:00,540
这里的第一实施例非常相似
什么，我们只是上面的解释。

18
00:01:00,540 --> 00:01:05,560
所以，如果我编码的某些部分
字母A至L，由二的关键，

19
00:01:05,560 --> 00:01:09,760
然后，我只是得到我的整个
字母表转移两个字母。

20
00:01:09,760 --> 00:01:12,230
>> 然后，在我的下一个例子，
关键还是二，

21
00:01:12,230 --> 00:01:15,080
所以你还应该知道
该信件的期望。

22
00:01:15,080 --> 00:01:16,400
但在这里它是一个短语。

23
00:01:16,400 --> 00:01:18,100
这是CS50。

24
00:01:18,100 --> 00:01:21,090
所以，你会发现，我
保存了我的信的情况下，

25
00:01:21,090 --> 00:01:25,600
所以任何大写字母也
大写字母的密文。

26
00:01:25,600 --> 00:01:27,800
和任何一个小写
明文中的信

27
00:01:27,800 --> 00:01:30,640
也小写
信中的密文。

28
00:01:30,640 --> 00:01:34,020
但我一直字母
任何感叹号

29
00:01:34,020 --> 00:01:37,610
或任何其他标​​点符号一样。

30
00:01:37,610 --> 00:01:40,360
>> 所以，现在我们有一个感觉
该计划是如何工作的，

31
00:01:40,360 --> 00:01:43,890
随意去跑多一些
你自己的例子，如果你想。

32
00:01:43,890 --> 00:01:47,072
让我们开始越来越
来自用户的键。

33
00:01:47,072 --> 00:01:48,780
传统上，用
其他的问题，我们已经

34
00:01:48,780 --> 00:01:51,450
已经习惯了越来越
任何数字，我们

35
00:01:51,450 --> 00:01:54,710
需要通过提示用户
用函数调用getInt。

36
00:01:54,710 --> 00:01:58,850
但是，这一次，我们真的要
使用命令行参数

37
00:01:58,850 --> 00:02:01,760
和一个新的函数调用的atoi。

38
00:02:01,760 --> 00:02:05,130
>> 当您运行主
程序用C，然后将其

39
00:02:05,130 --> 00:02:08,500
接受两个parameters--
INT ARGC，这

40
00:02:08,500 --> 00:02:11,670
是参数的数量
传递，然后

41
00:02:11,670 --> 00:02:15,920
ARGV，字符串数组，其中包含
所有的参数列表

42
00:02:15,920 --> 00:02:16,740
通过。

43
00:02:16,740 --> 00:02:19,740
你没有明确有
声明这些变量。

44
00:02:19,740 --> 00:02:22,700
他们计算了
您可以通过编译器。

45
00:02:22,700 --> 00:02:28,160
这个正确的用法是
为的argc是两个在这种情况下，

46
00:02:28,160 --> 00:02:32,630
因为用户必须通过在
在调用程序，./caesar，

47
00:02:32,630 --> 00:02:35,570
然后钥匙，
无论数量他们的愿望。

48
00:02:35,570 --> 00:02:39,920
这样就意味着的argc必须有两个
为了有效利用恺撒

49
00:02:39,920 --> 00:02:41,680
被执行。

50
00:02:41,680 --> 00:02:43,590
>> 所以，让我们来看一个例子。

51
00:02:43,590 --> 00:02:47,760
说我已经写和
编译一个名为升空计划。

52
00:02:47,760 --> 00:02:52,670
所以，如果我在命令行运行
./blastoff火箭队，顺利的话，

53
00:02:52,670 --> 00:02:57,750
ARGC将有三个，因为我
在三个不同的参数传递。

54
00:02:57,750 --> 00:02:59,830
然后argv的是这样的。

55
00:02:59,830 --> 00:03:03,750
这是一个数组，它会
包含这三个串。

56
00:03:03,750 --> 00:03:09,640
./blastoff在第一索引，队
在接下来的，并且在过去的火箭。

57
00:03:09,640 --> 00:03:11,610
>> 让我们来谈谈对秒的阵列。

58
00:03:11,610 --> 00:03:15,560
数组是保存数据结构
相同类型的多个值。

59
00:03:15,560 --> 00:03:19,980
这可以派上用场的时候，我们
有整数或字符串列表。

60
00:03:19,980 --> 00:03:23,030
只要记住他们
向是相同的类型。

61
00:03:23,030 --> 00:03:25,310
在计算机科学中，我们
爱从零开始计数，

62
00:03:25,310 --> 00:03:29,260
所以记住，数组
也是零索引。

63
00:03:29,260 --> 00:03:34,360
所以，我的数组的第一个元素
将是在指数为零。

64
00:03:34,360 --> 00:03:37,580
因此，在这种情况下，当我有
长度为4的阵列，

65
00:03:37,580 --> 00:03:41,350
随后的的最后一个索引
我的数组中最后一个元素

66
00:03:41,350 --> 00:03:44,970
实际上将是
在指数三，不是四个。

67
00:03:44,970 --> 00:03:48,880
因为记得，我们
从零开始计数。

68
00:03:48,880 --> 00:03:52,530
>> 这里有一个如何你一个例子
可以创建自己的数组。

69
00:03:52,530 --> 00:03:56,440
所以说，我想我的存储
最喜欢的三狗的名字。

70
00:03:56,440 --> 00:03:59,030
然后，我会创建一个字符串数组。

71
00:03:59,030 --> 00:04:04,450
因此，我想声明的类型，字符串，
然后把阵列的名称，狗，

72
00:04:04,450 --> 00:04:06,450
然后在这些方
括号把大小

73
00:04:06,450 --> 00:04:09,260
在这种情况下，三个array--。

74
00:04:09,260 --> 00:04:12,690
>> 所以我的第一个条目是怎么回事
是狗在指数为零，

75
00:04:12,690 --> 00:04:14,750
而这将是米洛。

76
00:04:14,750 --> 00:04:17,850
然后，狗是索引一
将是愚蠢的，

77
00:04:17,850 --> 00:04:23,060
宠儿年糕，然后在最后
项，在指数两个第三项，

78
00:04:23,060 --> 00:04:26,130
将是可爱，甜美Elphie。

79
00:04:26,130 --> 00:04:28,610
你会发现，格式
对于此数组中填充

80
00:04:28,610 --> 00:04:32,150
很像你怎么可能
声明任何其他变量，其中

81
00:04:32,150 --> 00:04:36,307
你有变量名后跟
你想存储在其中的价值。

82
00:04:36,307 --> 00:04:38,140
在唯一的区别
这种情况下，是你

83
00:04:38,140 --> 00:04:42,700
一定要记得把指数
在方括号内的数值。

84
00:04:42,700 --> 00:04:46,420
还有，我们有我们
最喜欢的三个狗。

85
00:04:46,420 --> 00:04:48,780
>> 但很可惜，它的时间
要回撒。

86
00:04:48,780 --> 00:04:52,910
记住那个在正确的使用方法
用户将被传递不仅

87
00:04:52,910 --> 00:04:57,430
程序./caesar的名称，但
同时，他们希望转移的关键

88
00:04:57,430 --> 00:04:58,850
其明文。

89
00:04:58,850 --> 00:05:01,540
这样就意味着的argc必须有两个。

90
00:05:01,540 --> 00:05:07,580
他们必须通过two--，不多也
不到两年的命令行参数。

91
00:05:07,580 --> 00:05:09,050
>> 现在，有关的argv？

92
00:05:09,050 --> 00:05:12,880
好了，我们已经知道，
阵列将是长度为二，

93
00:05:12,880 --> 00:05:15,270
但什么是包含在每一个元素？

94
00:05:15,270 --> 00:05:19,330
好了，第一个元素
将是./caesar，

95
00:05:19,330 --> 00:05:24,190
然后下一个元素是要
包含用户键入的键。

96
00:05:24,190 --> 00:05:27,480
现在，如果他们正确使用它
凯撒的使用，

97
00:05:27,480 --> 00:05:29,350
然后他们会在键入一个数字。

98
00:05:29,350 --> 00:05:33,260
但是，即使人物
他们Type是一个数字，

99
00:05:33,260 --> 00:05:35,790
它的数据类型为字符串。

100
00:05:35,790 --> 00:05:40,390
>> 那么，我们如何将其转换
字符串的整数

101
00:05:40,390 --> 00:05:46,680
所以说，我有NUM，字符串
包含字符串50。

102
00:05:46,680 --> 00:05:49,000
如果我想将其转换
为整数，那么我干脆

103
00:05:49,000 --> 00:05:53,340
声明一个新的变量，
整数i，调用的atoi。

104
00:05:53,340 --> 00:06:01,160
我通过我的字符串变量，NUM和
然后我会再包含数字50。

105
00:06:01,160 --> 00:06:04,350
确保检查的人
对于atoi函数页面

106
00:06:04,350 --> 00:06:07,990
要检查它的哪个库
在，还有什么价值它

107
00:06:07,990 --> 00:06:14,550
将返回如果字符串传递
在不包含所有的数字。

108
00:06:14,550 --> 00:06:16,950
>> 所以，现在我们已经得到
键，下一个步骤

109
00:06:16,950 --> 00:06:19,430
是获得来自用户的明文。

110
00:06:19,430 --> 00:06:21,170
现在，这是怎么回事
不太复杂

111
00:06:21,170 --> 00:06:23,410
不是围绕导航
命令行参数。

112
00:06:23,410 --> 00:06:26,190
我们所要做的就是调用
在GetString函数

113
00:06:26,190 --> 00:06:29,660
以提示用户，得到
我们一个字符串，但要记住

114
00:06:29,660 --> 00:06:34,090
检查如何规范我们
可能要提示用户。

115
00:06:34,090 --> 00:06:36,420
>> 现在我们就来了
在problem--的心脏

116
00:06:36,420 --> 00:06:38,860
如何进行加密的明文。

117
00:06:38,860 --> 00:06:42,830
嗯，首先，让我们来谈谈如何
在一个时间来加密一个字符，

118
00:06:42,830 --> 00:06:47,370
然后我们将讨论如何
遍历整个明文。

119
00:06:47,370 --> 00:06:50,440
我已经写了一些伪代码
对于凯撒的问题。

120
00:06:50,440 --> 00:06:52,310
我鼓励你
写自己的为好。

121
00:06:52,310 --> 00:06:55,900
它可能看起来不相同
我的，这是确定的，但只要

122
00:06:55,900 --> 00:06:58,640
作为一般的想法是一致的。

123
00:06:58,640 --> 00:07:00,780
>> 前三个步骤
我们已经做了。

124
00:07:00,780 --> 00:07:03,100
我们已经得到了从关键
命令行参数，

125
00:07:03,100 --> 00:07:05,510
我们已经变成了关键
成的整数，我们已经

126
00:07:05,510 --> 00:07:09,320
提示明文用户
他们要进行加密。

127
00:07:09,320 --> 00:07:12,420
于是接下来的大块
的是，对每个字符

128
00:07:12,420 --> 00:07:15,070
在明文串，
如果是字母，

129
00:07:15,070 --> 00:07:17,750
我们希望保留
它的外壳和移动它。

130
00:07:17,750 --> 00:07:20,900
通过保留的情况下，我
意思是说，所有的大写

131
00:07:20,900 --> 00:07:23,580
信件应保持上
外壳和全小写字母

132
00:07:23,580 --> 00:07:25,640
应保持小写。

133
00:07:25,640 --> 00:07:29,110
于是当我们转向那些，
那么我们打印密文。

134
00:07:29,110 --> 00:07:33,100
>> 这里有三个函数会
就派上用场了这个问题。

135
00:07:33,100 --> 00:07:38,010
记住了上面的时候我给了
例如用于移动，这是CS50？

136
00:07:38,010 --> 00:07:41,800
请记住，50和
感叹号没有转移？

137
00:07:41,800 --> 00:07:45,680
那么怎样才能知道我们是否
需要转向一个字母或不？

138
00:07:45,680 --> 00:07:48,650
嗯，“阿尔法是，”如果
你传递一个字符，

139
00:07:48,650 --> 00:07:54,850
将返回如果该字符真
是一个字母，否则为假。

140
00:07:54,850 --> 00:07:56,870
为了帮助您
保持资本

141
00:07:56,870 --> 00:07:59,750
是功能“的
上“和”低“。

142
00:07:59,750 --> 00:08:03,350
>> 这两个功能还需要
在一个单一的字符作为输入

143
00:08:03,350 --> 00:08:06,580
并返回一个布尔值，
无论是真的还是假的

144
00:08:06,580 --> 00:08:11,280
取决于是否该字符
是大写或小写。

145
00:08:11,280 --> 00:08:14,610
因为“是上”和“是
下“布尔函数，

146
00:08:14,610 --> 00:08:18,660
这意味着他们回报你一个布尔值，
你可以在你的条件下使用它们。

147
00:08:18,660 --> 00:08:23,490
因此，这里的一个代码片段，只有
打印的信，如果是大写。

148
00:08:23,490 --> 00:08:27,790
所以我宣布我的性格
信中大写捷思

149
00:08:27,790 --> 00:08:33,440
然后，如果“为上”的回报
真的，那我打印的信。

150
00:08:33,440 --> 00:08:38,200
>> 回到我们的简单例子
通过两个关键移位字母表

151
00:08:38,200 --> 00:08:41,049
我们如何真正得到工作？

152
00:08:41,049 --> 00:08:45,770
那么，事实证明，字符
和整数的关系非常密切。

153
00:08:45,770 --> 00:08:48,840
每个人物都有一个
相关的整数值

154
00:08:48,840 --> 00:08:53,260
与它的ASCII表中发现，
其中每个字符的ASCII

155
00:08:53,260 --> 00:08:55,380
显示值。

156
00:08:55,380 --> 00:08:58,940
因此，一个大写字母A对应
到65 ASCII值

157
00:08:58,940 --> 00:09:02,270
和小写的a到
97 ASCII值。

158
00:09:02,270 --> 00:09:04,940
>> 随意查询
网上的任何ASCII表

159
00:09:04,940 --> 00:09:07,720
看到自己这些值。

160
00:09:07,720 --> 00:09:12,096
所以，这是什么意思是，我们可以
采取大写A的角色，

161
00:09:12,096 --> 00:09:18,200
整数两个附加给它，然后得到
字符大写C作为一个结果。

162
00:09:18,200 --> 00:09:23,720
这是因为65，ASCII
资本值，加2，

163
00:09:23,720 --> 00:09:29,960
为我们提供了67，其对应于
到上壳体C的字符

164
00:09:29,960 --> 00:09:33,480
>> 不幸的是，事情
将不完全是那么简单。

165
00:09:33,480 --> 00:09:36,980
我们有一个方程
我们要考虑的。

166
00:09:36,980 --> 00:09:43,590
这告诉我们，第i个密文
信对应于第i个明文

167
00:09:43,590 --> 00:09:48,900
信，加上key--
所有这一切，模块化的26。

168
00:09:48,900 --> 00:09:50,810
为什么会这样呢？

169
00:09:50,810 --> 00:09:55,430
让我们回到我们的例子，从
之前，在资本A，加2，

170
00:09:55,430 --> 00:09:57,590
给我们的资本C.

171
00:09:57,590 --> 00:10:01,870
>> 因此，运用方程
规范给我们，

172
00:10:01,870 --> 00:10:06,660
接下来就让我们一大写A
加上2和MOD由26。

173
00:10:06,660 --> 00:10:10,730
所以资本A，当我把它放在
那些单引号，

174
00:10:10,730 --> 00:10:14,010
让我把它当作
的整数，以便允许

175
00:10:14,010 --> 00:10:17,500
我把它转换为字符的ASCII值，65。

176
00:10:17,500 --> 00:10:20,080
65加2是67。

177
00:10:20,080 --> 00:10:25,210
67国防部26给了我们15，
但是这并没有真正

178
00:10:25,210 --> 00:10:32,590
很有道理，因为我们知道，
大写字母C的ASCII值是67，而不是15。

179
00:10:32,590 --> 00:10:35,580
那么，我们如何调和？

180
00:10:35,580 --> 00:10:39,840
>> 那么，在这里我想断定的
一个字母索引的概念。

181
00:10:39,840 --> 00:10:44,010
因此，我们已经谈到了如何
每个角色都有它的ASCII值，

182
00:10:44,010 --> 00:10:48,810
但我想说，好吧，让我们
想想每个字符也有

183
00:10:48,810 --> 00:10:52,230
一个字母索引，
其中A例如，

184
00:10:52,230 --> 00:10:58,800
作为拼音的第一个字母，
具有零字母索引。

185
00:10:58,800 --> 00:11:02,070
所以，现在，让我们的应用
相同的公式之前，

186
00:11:02,070 --> 00:11:05,040
但使用字母索引。

187
00:11:05,040 --> 00:11:07,810
>> 所以A是零，因为我们已经定义。

188
00:11:07,810 --> 00:11:15,640
于是采取零加二，国防部26日，
这是二，国防部26日，这给了我们两个。

189
00:11:15,640 --> 00:11:18,780
和好，在以下方面
一个字母索引，

190
00:11:18,780 --> 00:11:23,930
C是在第三信
字母，以便将对应

191
00:11:23,930 --> 00:11:26,290
为两个的字母索引。

192
00:11:26,290 --> 00:11:29,850
如此看来，使用
在这种情况下，字母索引

193
00:11:29,850 --> 00:11:32,840
实际上给了我们正确的结果。

194
00:11:32,840 --> 00:11:35,020
>> 所以，现在，让我们检查
看到，如果方程作品

195
00:11:35,020 --> 00:11:37,210
以字母索引。

196
00:11:37,210 --> 00:11:42,540
个Y字母索引是24作为
第二个字母表中的最后一个字母。

197
00:11:42,540 --> 00:11:46,520
于是24加上我们
两个关键给了我们26。

198
00:11:46,520 --> 00:11:54,750
26模26给我们0，，幸运
我们是A.字母索引

199
00:11:54,750 --> 00:11:59,100
所以希望这足以证明这一点
字母索引方法的工作。

200
00:11:59,100 --> 00:12:03,180
如果没有，随意试用
自己的一些例子。

201
00:12:03,180 --> 00:12:08,030
>> 为了周围的正常包装
字母和应用凯撒方程，

202
00:12:08,030 --> 00:12:11,280
那么我们知道，我们需要
处理的字母索引。

203
00:12:11,280 --> 00:12:15,130
但是，我们开始与ASCII
值，才把

204
00:12:15,130 --> 00:12:18,530
我们再转换为
字母索引。

205
00:12:18,530 --> 00:12:23,970
从那里，为了打印，就需要
再次处理的ASCII值。

206
00:12:23,970 --> 00:12:28,350
因此，我们需要弄清楚如何
从ASCII去英文字母

207
00:12:28,350 --> 00:12:31,080
从按字母顺序排列为ASCII。

208
00:12:31,080 --> 00:12:34,910
>> 所以我把它留给你找出
一个字符之间的模式

209
00:12:34,910 --> 00:12:38,590
其英文字母
指数及其ASCII值。

210
00:12:38,590 --> 00:12:41,530
现在，请记住，即使
在幻灯片上的这个表正确

211
00:12:41,530 --> 00:12:45,630
显示大写字母，我们也
要考虑是不是

212
00:12:45,630 --> 00:12:48,915
不同的应用模式
为小写字符。

213
00:12:48,915 --> 00:12:52,070

214
00:12:52,070 --> 00:12:55,840
>> 所以，现在我们已经想通了
如何将单个字符移位，

215
00:12:55,840 --> 00:13:02,200
那么我们需要做的就是规模的
到整个明文去。

216
00:13:02,200 --> 00:13:04,260
所以明文是一个字符串。

217
00:13:04,260 --> 00:13:08,210
我们是幸运的，一个字符串是真的
只是字符数组，

218
00:13:08,210 --> 00:13:12,150
所以为了访问每一个字符
一个字符串，所有你需要做的

219
00:13:12,150 --> 00:13:14,270
是使用数组表示法。

220
00:13:14,270 --> 00:13:20,270
说我有类型的变量
字符串被称为“文字='这是CS50。'”

221
00:13:20,270 --> 00:13:22,730
>> 好吧，那么，为了
访问每个字符，

222
00:13:22,730 --> 00:13:25,880
所有我必须做
可变文本

223
00:13:25,880 --> 00:13:31,660
说好了，在指数为零的文字，那
对应于资本T.文本索引

224
00:13:31,660 --> 00:13:35,100
一者对应于下壳体小时。

225
00:13:35,100 --> 00:13:38,110
另一个有用的功能是
字符串长度的功能。

226
00:13:38,110 --> 00:13:40,760
所以传递一个字符串
该函数将返回

227
00:13:40,760 --> 00:13:44,610
的整数，该字符串的长度。

228
00:13:44,610 --> 00:13:47,060
>> 现在我们已经谈过
所有这些不同的元素，

229
00:13:47,060 --> 00:13:48,540
让我们把他们重新走到一起。

230
00:13:48,540 --> 00:13:52,210
所以，回到我的任伪
代码或伪代码

231
00:13:52,210 --> 00:13:55,920
并通过，并确保你
知道怎么做的每一件事。

232
00:13:55,920 --> 00:14:01,520
获取使用argc和argv的关键，
转动钥匙进入的整数，一个

233
00:14:01,520 --> 00:14:06,840
到我，提示明文，
GetString的，然后遍历

234
00:14:06,840 --> 00:14:09,590
在以上每一个字符
明文字符串，

235
00:14:09,590 --> 00:14:14,910
保存每个字符的情况下
以及按键转移该字符，

236
00:14:14,910 --> 00:14:17,520
确保你
缠绕的字母，

237
00:14:17,520 --> 00:14:20,850
最后打印的密文。

238
00:14:20,850 --> 00:14:25,470
我的名字是Amila，这是凯撒。

239
00:14:25,470 --> 00:14:28,448

