AMILA: Le të merret me Cezarin. Në Cezarit, ne të lejojë përdoruesit për të shifroj një mesazh të fshehtë. Pra, le të zhyten të drejtë në dhe të kërkoni në tonë për-dos për këtë problem. Pra, së pari, ne kemi marrë çelësin nga përdoruesit. Pastaj ne kemi marrë plaintext se ata duan për të kodifikuar. Pas kësaj, ne shifroj atë për ta, dhe më në fund ne të shtypura koduar tyre. 

Pra, le të fillojmë me një shembull. Thuaj ju të kërkuar për të shifroj tërë alfabeti me një çelës të dy. E pra, tërë alfabeti yt do vetëm të jetë zhvendosur në letra. Pra A do të shifroj të C, B për D, C për E, kështu me radhë e kështu me radhë, deri sa ju të merrni për X, i cili kodon për Z ose zed, në varësi se ku ju jeni nga. Pastaj Y më pas do të zhvendoset të gjithë rrugën, përfundojë rreth alfabetit për të marrë në A, dhe pastaj në fund letra e fundit e Alfabeti, Z, zed, do të shifroj të B. 

Ju mori atë? Le të shikojmë disa shembuj. Shembulli i parë këtu është shumë e ngjashme me atë që ne vetëm shpjeguar më lart. Pra, nëse unë të shifroj një pjesë e të Alfabeti, A me L, nga një çelës të dy, atëherë unë vetëm të marrë të tërë e mia alfabeti zhvendosur dy letra. 

Pastaj, në shembullin tim të ardhshëm, çelësi është ende dy, kështu që ju duhet ende të dini të cilat letra të presin. Por këtu është një frazë. Kjo është CS50. Pra, ju do të vëreni se unë ruajnë rastin e letrave të mia, kështu që çdo letra e sipërme rast edhe letra e sipërme rast në ciphertext. Dhe çdo të vogla letra në plaintext janë jo kapitale gjithashtu letra në ciphertext. Por unë të mbajtur letrat dhe çdo shënon çuditëse ose çdo pikësimi tjetër të njëjta. 

Pra, tani që ne kemi një kuptim për mënyrën se si punon programi, të ndjehen të lirë për të shkuar të kandiduar disa më shumë shembuj të tuaj, nëse ju dëshironi. Le të fillojmë me marrjen çelësi nga përdoruesit. Tradicionalisht, me probleme të tjera, ne kemi janë mësuar me marrjen e çdo numër që ne nevojë duke bërë që përdoruesit me funksion të GetInt. Por këtë herë ne jemi të vërtetë do për të përdorur argumentin command line dhe një funksion të ri të quajtur atoi. 

Kur ju drejtuar kryesore program në C, atëherë ajo merr në dy parameters-- int argc, e cila është numri i argumenteve kaluar ne, dhe pastaj argv, një grup i cili përmban vargjet lista e të gjitha argumenteve kaloi. Ju nuk keni eksplicite për të deklaruar këto variabla. Ata janë llogaritur për ju nga përpiluesit. Përdorimi i saktë për këtë do të jetë për argc të jenë të dy në këtë rast, për shkak se përdoruesi ka për të kaluar në thirrja për programin, ./caesar, dhe pastaj çelësi, çfarëdo numri që ata dëshirojnë. Kështu që do të thotë se argc duhet të jetë dy në mënyrë që për një përdorim të vlefshme të Cezarit që do të ekzekutohet. 

Pra, le të shikojmë një shembull. Thonë se unë kam shkruar tashmë dhe hartuar një program të quajtur nisje. Pra, nëse unë u zhvillua në command line ./blastoff Rocket Team, mirë, atëherë, argc do të jetë tre për shkak se unë kaluar në tri argumente të ndryshme. Pastaj argv do të duket si ky. Kjo është një grup, dhe kjo do të përmbajnë secili prej tre vargjet. ./blastoff në treguesin e parë, ekipi në tjetër, dhe raketa në të fundit. 

Le të flasim për vargjeve për një sec. Vargjeve janë strukturat e të dhënave që mbajnë Vlerat e shumëfishta të të njëjtit lloj. Kjo mund të jetë në dispozicion, kur ne kanë listat e integers ose strings. Vetëm mos harroni se ata kanë të jenë të njëjta tipi. Në shkenca kompjuterike, ne dashuri llogaritur nga zero, kështu që mos harroni se vargjeve edhe zero-indeksuar. Pra, elementin e parë të vektorit tim do të jetë në indeksin zero. Pra, në këtë rast, kur unë kam një grup i gjatësisë katër, atëherë indeksi i fundit Elementi i fundit i vektorit tim është në të vërtetë do të jetë në indeksin e tre, jo katër. Sepse mos harroni, ne fillojë numërimi në zero. 

Ja një shembull se si ju mund të krijojë një grup nga mesi juaj. Pra, thonë se unë të kërkuar për të ruajtur tim tre qen emra të preferuar. Atëherë unë do të krijojë një rrjet të strings. Kështu që unë do të deklarojë llojin, string, dhe pastaj emrin e array, qentë, dhe më pas në ato shesh kllapa vënë madhësinë e array-- në këtë rast, tre. 

Pra, hyrja ime e parë do të jenë qentë në indeksin zero, dhe kjo do të jetë Milo. Pastaj qentë në indeksin një do të jetë budalla, darling Mochi, dhe pastaj e fundit hyrje, hyrja e tretë në indeksin dy, do të jetë e bukur, e ëmbël Elphie. Ju do të vëreni se format për të plotësuar në këtë grup është shumë i ngjashëm se si ju mund të deklarojë ndonjë variabël tjetër ku ju keni emrin e ndryshueshme e ndjekur nga vlera që ju doni të ruajtura në të. Dallimi i vetëm në ky rast është se ju duhet të mbani mend për të vënë në indeks e vlerës në kllapa katrore. Dhe nuk kemi tonë tre qentë preferuar. 

Por mjerisht, është koha të kthehet Cezarit. Mos harroni se përdorimi korrekt për Përdorues do të jetë duke kaluar jo vetëm emri i ./caesar programit, por edhe çelësi që ata duan për të zhvendosur plaintext i tyre nga. Kështu që do të thotë se argc duhet të jetë dy. Ata duhet të kalojë në two-- jo më shumë, jo më më pak se dy argumente command line. 

Tani, ajo që për argv? E pra, ne tashmë e dimë se grup do të jetë me gjatësi dy, por ajo që është të përfshira në çdo element? E pra, elementi i parë do të jetë ./caesar, dhe pastaj elementi tjetër do të përmbajnë çelësin që përdoruesi shtypur në. Tani, në qoftë se ata kanë përdorur atë siç duhet për përdorimin e Cezarit, atëherë ata do të shkruani në një numër. Por edhe pse personazhi se tipit është një numër, kjo është e tipit të dhënave string. 

Deri sa nuk kemi kthyer atë string për një numër të plotë? Pra, thonë se unë kam num, një varg, përmban vargun 50. Nëse unë dua të kthyer që për një numër të plotë, atëherë unë thjesht deklarojë një ndryshore të re, një Integer i, duke e quajtur atoi. I kalojnë në variabël string tim, num, dhe atëherë unë do të përmbajë numrin 50. Sigurohuni që të kontrolloni njeriun faqet për funksionin atoi për të kontrolluar të cilat biblioteka është e në, si dhe atë që e vlerësojmë atë do të kthehet nëse vargu kaluar në nuk përmban të gjitha numrat. 

Pra, tani që ne kemi marrë çelësi, hapi tjetër është për të marrë plaintext nga përdoruesit. Tani, kjo do të të jetë më pak e komplikuar se lundrimit rreth argumente command line. Të gjithë ne duhet të bëni është thirrje funksioni getString të menjëhershëm të përdoruesit për të dhënë ne një varg, por mos harroni për të kontrolluar specifikimet për mënyrën se si ne mund të dëshironi të menjëhershëm të përdoruesit për këtë. 

Tani kemi ardhur të Zemra e problem-- Si për të shifroj plaintext. E pra, së pari, le të flasim rreth asaj se si për shifroj një karakter në një kohë, dhe pastaj ne do të trajtojë si të iterate mbi të gjithë plaintext. Unë kam shkruar disa pseudokod për problemin e Cezarit. Unë ju inkurajoj që të të shkruani tuaj si. Kjo nuk mund të duket identike me imja, dhe kjo është në rregull, por për aq kohë si ide përgjithshme është e njëjtë. 

Tre Hapat e parë ne kemi bërë tashmë. Ne kemi marrë çelësin nga argumenti command line, ne kemi kthyer atë çelës në një numër të plotë, dhe ne kemi nxitur përdoruesit për plaintext se ata duan të shifroj. Pra, atëherë copë tjetër i madh është se për çdo karakter në vargun plaintext, nëse është e alfabetik, ne duam të ruajmë Rasti i saj dhe të ndryshojë atë. Duke ruajtur kështu, atë që kam do të thotë është se të gjitha rastet e sipërme Letrat duhet të mbetet Epërme rast dhe të gjithë shkronja te vogla duhet të mbeten të vogla. Pra, atëherë, pasi ne ndryshim ata, pastaj ne të shtypura të koduar. 

Këtu janë tri funksione që janë në vazhdim e sipër për të të jetë në dispozicion për këtë problem. Mos harroni lart kur i dha Shembull për këtë është zhvendosur CS50? Mos harroni se 50 dhe pikëçuditëse nuk ka ndryshim? Pra, si mund të them nëse ne duhet të zhvendoset një letër apo jo? E pra, "është alfa," nëse ju të kalojë atë një karakter, do të kthehet e vërtetë në qoftë se karakteri është një letër dhe të rreme ndryshe. Për t'ju ndihmuar me ruajtjen e kapitalizimit janë funksionet "është sipërme "dhe" është më i ulët ". 

Këto dy funksione të marrë në një karakter të vetëm si të dhëna dhe ju kthehet një Boolean, ose vërtetë apo e rreme varësi të faktit nëse atë karakter është rasti e sipërme apo të poshtme. Sepse "është sipërme" dhe "është më të ulët "janë funksione Boolean, që do të thotë se ata të kthehen një Boolean, ju mund të përdorni këto në kushtet tuaja. Kështu që këtu është një copë e kodit që vetëm printon një letër në qoftë se është rasti e sipërme. Kështu që unë kam shpallur karakterin tim letër të rastit sipërme zed dhe pastaj në qoftë se "është e sipërme" kthehet e vërtetë, atëherë unë të shtypura atë letër. 

Duke iu rikthyer shembullit tonë të thjeshtë të zhvendosur alfabetin me një çelës të dy, si nuk kemi të vërtetë të merrni atë për të punuar? E pra, ajo rezulton se personazhet dhe integers janë të lidhura shumë ngushtë. Secili karakter ka një vlerë e plotë lidhur me atë të gjetur në tabelë ASCII, ku ASCII çdo karakter Vlera shfaqet. Kështu një rast sipërme A korrespondon një vlerë ASCII 65 dhe një vogle a të një vlerë ASCII e 97. 

Ndjehen të lirë për të parë deri çdo tabelë ASCII internet për të parë këto vlera për veten tuaj. Pra, çfarë kjo do të thotë është se ne mund të të marrë karakterin e rastit sipërme A, shtoni integer dy për të, dhe pastaj të marrë karakteri sipërme rasti C, si rezultat i kësaj. Kjo është për shkak se 65 vjet, do ASCII Vlera për kapital A, plus 2, na jep 67, që i korrespondon për karakterin e sipërme rast C. 

Për fat të keq, gjërat e nuk do të mjaft të jetë aq e thjeshtë. Ne kemi një ekuacion që ne duhet të marrin në konsideratë. Këtu na tregon se të ciphertext ith Letra korrespondon me plaintext ith letër, plus key-- të gjithë se, modulare 26. Pse është kështu? Le të kthehemi në shembullin tonë nga më parë, ku kapitali A, plus 2, na jep kapitalit C. 

Pra, duke zbatuar ekuacionin se specifikimi na jep, atëherë le të marrin kapital A plus 2 dhe mod që nga 26. Pra kapitali A, kur kam vënë atë në ato shenja të vetme citat, lejon mua për të trajtuar atë si një numër i plotë, kështu që lejon mua për të hedhur atë për vlerën e saj ASCII, 65 vjeç. 65 plus 2 është 67. 67 mod 26 na jep 15, por kjo nuk ka të vërtetë kuptim sepse ne e dimë se Kapitali C vlera ASCII është 67, e jo 15. Deri sa nuk kemi pajtohen se? 

E pra, këtu unë do të doja të parashtroj Nocioni i një indeks alfabetik. Pra, ne kemi folur tashmë për mënyrën se si çdo karakter ka vlerën e saj ASCII, por unë do të doja të them, mirë, le të mendoni për çdo karakter të paturit një indeks alfabetik, ku A për shembull, si shkronjës së parë të alfabetit, ka një indeks alfabetik zero. Pra, tani le të zbatohet njëjti ekuacion si më parë, por duke përdorur një indeks alfabetik. 

Pra A është zero, siç e kemi përcaktuar. Kështu, pra, duke marrë zero plus dy, mod 26, kjo është dy, mod 26, i cili na jep dy. Dhe dhe, në kushtet e një indeks alfabetik, C është letra e tretë në alfabeti, kështu që do të korrespondojnë me një indeks alfabetik të dy. Pra, duket se duke përdorur Indeksi alfabetik në këtë rast në fakt na jep rezultat të saktë. 

Pra, tani le të kontrolloni për të të parë nëse veprat ekuacionit me një indeks alfabetik. Indeksi alfabetik Y është 24 si e dytë të letrës së fundit në alfabetin. Kështu, pra 24 plus tonë Çelësi i dy na jep 26. 26 mod 26 na jep 0, e cila, për fat ne, është indeksi alfabetik për A. Pra, shpresojmë se kjo është provë e mjaftueshme që metoda alfabetik indeksi punon. Nëse jo, të ndjehen të lirë për të provoni disa shembuj të tuaj. 

Në mënyrë për të përfunduar si duhet rreth alfabeti dhe të zbatojë ekuacionin Cezarit, atëherë ne e dimë se kemi nevojë të merren me indekseve alfabetike. Por ne fillim me ASCII vlerat, dhe vetëm atëherë nuk kemi më pas konvertohet në indeksi alfabetik. Nga atje, në mënyrë që të shtypura, ne kemi nevojë për t'u marrë me vlerat ASCII përsëri. Pra, ne duhet të kuptoj se si për të shkojnë nga ASCII për alfabetik dhe nga alfabetike të ASCII. 

Kështu që unë po e lë për ju që të kuptoj se model mes një karakter dhe alfabetik saj indeksi dhe vlera e saj ASCII. Tani, mos harroni se edhe pse kjo e drejtë Tabela në rrëshqitje tregon shkronja kapitale, ne gjithashtu duhet të marrin në konsideratë nëse janë apo jo zbatohet një model të ndryshëm për personazhet vogla. 

Pra, tani që ne kemi realizuar artistikisht Si për të zhvendosur një karakter të vetëm, atëherë të gjithë ne duhet të bëni është shkallë që për të shkuar në të gjithë plaintext. Pra plaintext është një string. Me fat për ne, një varg është me të vërtetë vetëm një grup të karaktereve, kështu që në mënyrë për të hyrë në çdo karakter nga një varg, të gjithë ju duhet të bëni është që të përdorin array simbol. Thonë se unë kam një variabël të tipit string quajtur "text =" kjo është CS50. '' 

E pra, atëherë, në mënyrë që të hyni në çdo karakter, të gjitha unë duhet të bëni me teksti variabël është do të thotë mirë, teksti në indeksin zero, që korrespondon me T. kryeqyteti Tekst në indeksin një korrespondon h poshtme e rastit. Një tjetër funksion i dobishëm është funksioni gjatësia string. Pra, duke kaluar në një varg të se funksioni do të kthehet një numër i plotë, gjatësia e atë varg. 

Tani që ne kemi biseduar rreth të gjitha këto elemente të ndryshme, le të vënë ato përsëri së bashku. Pra, kthehen në të dyja pseudokod tim Kodi ose pseudocode tuaj dhe të kalojnë nëpër të dhe të sigurohemi që ju e di se si për të bërë çdo gjë të vetme. Getting çelësin përdorur argc dhe argv, duke e kthyer çelësin në një numër të plotë, një të i, duke nxitur për plaintext, getString, dhe pastaj iterating mbi çdo karakter në string plaintext, ruajtjen rastin e çdo karakter dhe zhvendosur atë karakter me kyç, duke siguruar që ju jeni të mbështjellës rreth alfabetit, në fund shtypjes se koduar. Emri im është Amila, dhe kjo ishte Cezari. 