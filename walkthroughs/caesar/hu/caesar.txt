Amila: Lássuk a Caesar. Caesar, hagyjuk, hogy a felhasználó kódolni egy titkos üzenetet. Tehát lássuk zuhanásra, és nézd a mi to-dos erre a problémára. Tehát először is, hogy a kulcs a felhasználó. Akkor megkapjuk az egyszerű szöveges hogy akarnak kódolni. Ezt követően, sifríroz ez nekik, és végül kinyomtathatják rejtjelezett. 

Tehát kezdjük egy példát. Tegyük fel akarta kódolásához teljes ábécé kulcsfontosságú a kettő. Nos, az egész ábécé lenne Csak eltolható leveleket. Tehát egy kódolják a C, B D, C-E, így tovább és így tovább, amíg eljut X, amely kódolja a Z vagy Zed, attól függően, hogy honnan jöttél. Akkor Y aztán váltás egészen, körbefogja az ábécé, hogy az A, és végül az utolsó levél a abc, Z, Zed, kódolják a B. 

Megkaptad? Nézzünk néhány példát. Az első példa itt nagyon hasonló hogy amit most kifejtettük. Tehát, ha azt kódolja néhány szakasza a ábécé, AL, egy kulcs, két, akkor csak kap az egész ábécé eltolt két betű. 

Aztán az én következő példában, A kulcs még mindig két, ezért mindig tudom mely betűk számíthat. De itt ez a kifejezés. Ez CS50. Így láthatja, hogy én megőrzése esetén a leveleimet, így minden nagybetűket is nagybetűket a rejtjelezett. És minden kisbetűs betűk a titkosítatlan is kisbetűs betűk a rejtjelezett. De én is a leveleket és bármely felkiáltójelek vagy bármely más írásjelek ugyanaz. 

Tehát most, hogy van értelme hogyan működik a program, nyugodtan menjen még néhány példákat a saját, ha akarja. Kezdjük szerzés a kulcsot a felhasználó. Hagyományosan, a más problémák, most már megszokta, hogy egyre számot sem, hogy mi szükség szerint a felhasználó megkérdezése A funkció getint. De ezúttal mi történt valójában használja a parancssori argumentum és az új funkció az úgynevezett atoi. 

Amikor futtatja a fő program C, majd azt vesz két parameters-- int argc, ami az argumentumok számát telt el, majd argv egy tömböt, amely tartalmazza A lista az összes érvet elmúlt. Nem kifejezetten rendelkezik nyilatkozni a változókat. Ők számítanának Ön a fordító. Helyes használat erre lenne A ARGC, hogy két ebben az esetben, mert a felhasználónak át kell haladnia a A hívást a programot, ./caesar, majd a kulcsot, bármilyen számot akarnak. Tehát ez azt jelenti, hogy argc kell két Annak érdekében, hogy egy érvényes használata Caesar végre kell hajtani. 

Tehát nézzük meg egy példát. Mondjuk én már írtam, és összeállított program neve kilövésre. Tehát, ha én futott a parancssorból ./blastoff Rakéta csapat, nos, akkor, argc lenne három, mert telt három különböző érveket. Akkor argv nézne ki. Ez egy tömb, és ez tartalmazzák mindhárom szálakat. ./blastoff az első index, csapat A következő, és rakéta az utolsó. 

Beszéljünk tömbök egy percet. A tömbök adatszerkezetek, hogy tartsa több értéke azonos típusú. Ez jól jöhet, amikor Van listák egész számok vagy karakterláncok. Csak arra emlékszem, hogy van hogy az azonos típusú. Számítástechnika, mi Szeretem számítva nulla, úgy emlékszem, hogy a tömbök szintén nulla indexelt. Tehát az első eleme az én tömb lesz indexen nulla. Tehát ebben az esetben, ha van tömb hossza négy, majd az utolsó indexe utolsó eleme az én tömb valóban lesz indexű három, nem négy. Mert emlékszem, mi elkezd számolás nulla. 

Íme egy példa arra, hogy hogyan létrehozhat egy sor saját. Tehát mondjuk akartam tárolni én három kedvenc kutya nevét. Aztán lenne létrehozni egy tömböt. Tehát azt állapítsa meg a típusát, húr, és majd fel a nevét a tömb, kutyák, majd az említett tér zárójelben rész méretét A array-- ebben az esetben három. 

Tehát az első bejegyzés lesz hogy kutyák index nulla, és hogy lesz Milo. Aztán kutyák index egy lesz ostoba, drágám Mochi, majd az utolsó bejegyzés, a harmadik belépést index két, lesz aranyos, édes Elphie. Észre fogod venni, hogy a formátum kitöltési ez a tömb nagyon hasonlít arra, hogyan lehet bejelenteni minden más változót, ahol akkor a változó nevét, majd az értéket, amit szeretne tárolni benne. Az egyetlen különbség a Ebben az esetben az, hogy meg kell emlékezni, hogy az index Az érték a szögletes zárójelben. És ott van a mi három kedvenc kutyákat. 

De sajnos, itt az ideje, hogy újra Caesar. Ne feledje, hogy helyes használata a felhasználó lesz átadva nemcsak A program neve ./caesar, de továbbá a legfontosabb, hogy meg akarják váltani a nyílt szöveg által. Tehát ez azt jelenti, hogy argc kell kettő. Meg kell felelniük a two-- nem több, nem Kevesebb, mint két parancssori paramétereket. 

De mi a helyzet argv? Nos, azt már tudjuk, hogy a tömb lesz a hossza két, de mit tartalmazott minden eleme? Nos, az első elem lesz ./caesar, majd a következő elem fog tartalmazzák a legfontosabb, hogy a felhasználó beírta. Most, ha használják helyesen a használat Caesar, akkor fognak írja be a számot. De még ha a karakter hogy írjon egy számot, ez az adat string típusú. 

Szóval hogyan lehet átalakítani, hogy húr egy egész? Tehát mondjuk van num, egy string, karakterláncot tartalmazó 50. Ha szeretnék átalakítani, hogy a az egész, akkor egyszerűen állapítsa meg egy új változót, egy integer i, amelyben atoi. Elmegyek én string változó, num, és akkor én majd tartalmazza a szám 50. Győződjön meg arról, hogy ellenőrizze a férfi oldalakon a atoi funkció hogy ellenőrizze, hogy melyik könyvtárból ez a, valamint milyen értéket majd vissza, ha a húr át az nem tartalmazza az összes számot. 

Most, hogy ütött a kulcsot, a következő lépés az, hogy a nyílt szöveg a felhasználó. Nos, ez fog kevésbé bonyolult mint a navigációt a parancssori paramétereket. Mindössze annyit kell tennie, hogy hívja A getstring funkció figyelmezteti a felhasználót, hogy nekünk egy húr, de ne feledje, hogy ellenőrizze az előírások arra nézve, hogyan Lehet, hogy figyelmezteti a felhasználót, hogy. 

Most jön a szívében problem-- hogyan sifríroz az egyszerű szöveges. Nos, először is, beszéljünk arról, hogyan a titkosítás egy karakter egy időben, aztán majd foglalkozik az végighaladni az egész nyílt szöveg. Írtam néhány pszeudokód A Caesar probléma. Azt javasoljuk, hogy írhatunk is. Lehet, hogy nem néz azonosak az enyém, és ez rendben van, de amíg mint az általános ötlet ugyanaz. 

Az első három lépés ezt már megtettük. Kaptunk a kulcsot A parancssori argumentum már kiderült, hogy a legfontosabb egy egész, és mi már kéri a felhasználótól a nyílt szöveg hogy akarnak titkosítás. Így aztán a következő nagy darab az, hogy minden egyes karakter Az egyszerű szöveges karakterlánc, ha ez az alfabetikus, meg akarjuk őrizni tokjába és műszak. By megőrzése esetén, amit én jelenti, hogy az összes nagybetűk leveleket kell maradnia a felső esetében és minden kisbetű maradjon kisbetűs. Így aztán, miután váltani azokat, majd kiírjuk a rejtjelezett. 

Íme három funkciót folynak jól jöhet erre a problémára. Emlékezz fönt, amikor adtam a például változó ez CS50? Ne feledje, hogy a 50 és a felkiáltójel nem váltás? Tehát hogyan tudjuk megmondani, hogy mi kell váltani írni, vagy nem? Nos, "alfa", ha adsz meg egy karaktert, true értéket ad vissza, ha a karakter egy levelet, és egyébként false. Hogy segítsen megőrzése kapitalizáció azok a funkciók "van felső "és" alacsonyabb ". 

Ez a két funkció is figyelembe egyetlen karakter, mint bemenet és visszatér a logikai, igaz vagy hamis attól függően, hogy az adott karakter nagybetűs vagy kisbetűs. Mivel a "a felső" és "a alsó "Boole-függvények, ami azt jelenti, hogy visszatér a logikai, használhatja ezeket a feltételeket. Tehát itt egy kódrészletet, hogy csak a nyomtat írni, ha ez a felső burkolatot. Úgyhogy nyilvánították a karakterem levél a nagybetűk zed és ha "a felső" visszatér igaz, akkor tudok nyomtatni azt a levelet. 

Visszatérve a mi egyszerű példa változó az ábécé egy kulcs két, hogyan valóban kap, hogy működjön? Nos, kiderült, hogy a karakterek és egész nagyon közel állnak egymáshoz. Minden karakternek van egy kapcsolódóan egy egész értéket vele megtalálható az ASCII táblázatban, ahol minden egyes karakter ASCII érték jelenik meg. Így egy nagybetű A megfelel ASCII értéke 65 és egy kisbetűs egy a ASCII értéke 97. 

Nyugodtan nézz fel ASCII táblázat Online hogy ezek az értékek magad. Tehát ez mit jelent az, hogy tudjuk, hogy a karakter a nagybetűk A, hozzá az egész két hozzá, és akkor kap a karakter nagybetű C ennek eredményeként. Ennek oka, hogy a 65, az ASCII érték tőke A, plusz 2, ad 67, ami megfelel a karakter nagybetű C. 

Sajnos, a dolgok Nem egészen ilyen egyszerű. Van egy egyenletet, hogy figyelembe kell vennünk. Itt azt mondja, hogy az i-edik rejtjelezett levél megfelel az i-edik egyszerű szöveges levél, valamint a key-- minden, hogy a moduláris 26. Miért van ez így? Térjünk vissza a példát előtt, ahol a tőke egy, plusz 2, ad nekünk tőke C. 

Tehát alkalmazása egyenlet A leírás ad nekünk, akkor vessünk tőke A plusz 2 és a mod, hogy a 26. Tehát a tőke A, amikor betette ezek egyszeres idézőjelbe, lehetővé teszi, hogy kezelje azt egy egész szám, úgy, hogy lehetővé teszi, hogy engem vesd annak ASCII értéke 65. 65 plusz 2 67. 67 mod 26 ad 15, de ez nem igazán értelme, mert tudjuk, hogy a tőke C ASCII értéke 67, és nem 15. Szóval hogyan lehet összeegyeztetni ezt? 

Nos, itt szeretnék állít a fogalmát betűrendes index. Tehát mi már beszéltünk arról, hogyan Minden karakternek megvan a ASCII értéke, de azt szeretném mondani, nos, gondolni minden egyes karakter is, amelyek betűrendes index, ahol A például mint az első betű az ábécé, van egy alfabetikus index nulla. Így most nézzük alkalmazza azonos egyenlet, mint korábban, de a betűrendes index. 

Tehát egy nulla, ahogy már megadott. Tehát figyelembe nulla, plusz két, mod 26, ez a két, mod 26, ami számunkra kettő. És hát, tekintve betűrendes index, C a harmadik betű a ábécé, így felelne egy alfabetikus index kettő. Tehát úgy tűnik, hogy a alfabetikus index ebben az esetben valóban ad nekünk a helyes eredményt. 

Tehát most nézzük, hogy hátha az egyenlet munkák egy alfabetikus index. Y alfabetikus index 24, mint a második az utolsó betű az ábécé. Így aztán 24 plusz a gombot két számunkra 26. 26 mod 26 ad 0, ami szerencsés minket, az alfabetikus index A. Így remélhetőleg ez elég bizonyíték, hogy betűrendes mutató módszer működik. Ha nem, nyugodtan próbálja ki Néhány példa a saját. 

Annak érdekében, hogy megfelelően beburkolják az ábécé és alkalmazza a Caesar-egyenlet akkor tudjuk, hogy meg kell foglalkoznak ABC indexek. De kezdjük az ASCII értékeket, és csak ezután tudjuk majd áttért a betűrendes mutató. Onnan, hogy nyomtatni, meg kell foglalkozni az ASCII értékek újra. Tehát meg kell kitalálni, hogyan megy ASCII alphabetical és ABC ASCII. 

Szóval hagyjuk, hogy ki lehessen deríteni, a minta között egy karakter és annak ábécé index és ASCII értéke. Emlékszel, hogy bár E táblázat jobb a dián mutatja a nagybetűket, mi is kell vizsgálni, hogy az egy másik mintát kell alkalmazni A kisbetűk. 

Most, hogy kitaláltam hogyan kell váltani egy karaktert, akkor minden meg kell tennünk az, hogy skála fel menni az egész nyílt szöveg. Tehát a nyílt szöveg egy szöveg. Szerencsénkre, egy húr valóban Csak egy sor karakterek, így annak érdekében, hogy hozzáférést minden karakter egy string, mindössze annyit kell tennie, az, hogy az array jelöléssel. Mondom, van egy változó típusú karakterláncot az úgynevezett "text = 'ez CS50." 

Nos, akkor annak érdekében, hogy hozzáférhet minden karaktert, minden, amit meg kell csinálni A változó szöveg azt is, szöveget index nulla, hogy megfelel tőke T. szöveg indexen az egyik megfelel a kisbetűs H. Egy másik hasznos funkció a húr hossza funkciót. Így halad egy string hogy függvény visszatérési egy egész, a hossza a húr. 

Most, hogy már beszéltünk ezeket a különböző elemeket, tegyük őket újra együtt. Így vissza, hogy akár én pszeudokód kódot vagy a pszeudokód és megy keresztül, és győződjön meg arról, hogy tudja, hogyan kell csinálni minden egyes dolog. Ismerkedés a kulcsot argc és argv, a kulcs elfordítása egy egész, az i, kéri az egyszerű szöveges, getString, majd iterációjával mint minden karakter Az egyszerű szöveges karakterlánc, megőrizve az esetben minden egyes karakter és igyekszik, hogy a karakter a kulcsot, annak biztosítása, hogy te körülveszik az ábécé, végül a nyomtatás, hogy rejtjelezett. A nevem Amila, és ez volt Caesar. 