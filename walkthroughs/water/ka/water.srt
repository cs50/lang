1
00:00:00,000 --> 00:00:00,500

2
00:00:00,500 --> 00:00:01,960
დინამიკები 1: მოდით ვისაუბროთ წყალი.

3
00:00:01,960 --> 00:00:07,280
ამ პრობლემას, ჩვენ ვთხოვთ მომხმარებელი ვუთხრა
ჩვენს რამდენად ხანგრძლივი წუთებში მათი საშხაპე იყო

4
00:00:07,280 --> 00:00:11,040
და მაშინ ჩვენ გამოვთვალოთ ექვივალენტი
ნომერი ბოთლი წყალი

5
00:00:11,040 --> 00:00:12,970
რომ მათი შხაპი გამოიყენება.

6
00:00:12,970 --> 00:00:16,379
>> ასე რომ, რა არის ჩვენი to-do ს
ამ პრობლემას?

7
00:00:16,379 --> 00:00:20,050
პირველ რიგში, ჩვენ ვაპირებთ, რომ გსურთ
შეეკითხება და შემდეგ შეამოწმოს

8
00:00:20,050 --> 00:00:22,100
შეყვანის რომ მომხმარებელს გვაძლევს.

9
00:00:22,100 --> 00:00:24,790
მას შემდეგ, რაც ჩვენ უზრუნველყოს, რომ ჩვენ
აქვს მოქმედი მომხმარებლის input,

10
00:00:24,790 --> 00:00:28,230
ჩვენ ვაპირებთ, რომ გამოვთვალოთ
ექვივალენტი ნომერი ბოთლი წყალი

11
00:00:28,230 --> 00:00:30,770
რომ მომხმარებელს ჰქონდა
მათი შხაპი, და მაშინ ჩვენ

12
00:00:30,770 --> 00:00:33,720
მინდა გითხრათ, მათ მიერ
დაბეჭდვისას რომ ნომერი.

13
00:00:33,720 --> 00:00:37,230
>> მოდით დაძლევის ჩვენი პირველი
ამოცანა, რითაც და წევრები

14
00:00:37,230 --> 00:00:38,550
მომხმარებლის შეყვანის.

15
00:00:38,550 --> 00:00:40,910
ამისათვის ჩვენ დავწერეთ
ფუნქცია მოუწოდა

16
00:00:40,910 --> 00:00:43,950
get_int მდებარეობს CS50 ბიბლიოთეკა.

17
00:00:43,950 --> 00:00:48,710
get_int უზრუნველყოფს, რომ მომხმარებლის საშუალებებით
მთელი რიცხვი, ასე რომ რაიმე დადებითი ციფრები,

18
00:00:48,710 --> 00:00:51,700
უარყოფითი რიცხვები, ან
ნულოვანი ყველა მიღებული.

19
00:00:51,700 --> 00:00:55,900
მაგრამ, თუ მომხმარებლის საშუალებებით არაფერი,
ასე რომ ნებისმიერი კომბინაცია წერილები და ციფრები

20
00:00:55,900 --> 00:00:59,710
ან ათობითი ნომრები, მაშინ
მომხმარებლის იქნება აიძულა კვლავ სცადოთ

21
00:00:59,710 --> 00:01:04,319
და ფუნქცია არ მიიღოს არაფერი
სანამ მომხმარებელს საშუალებას აძლევს, მათ რიცხვი.

22
00:01:04,319 --> 00:01:06,410
>> ასე რომ, ჩვენ ვიყენებთ get_int?

23
00:01:06,410 --> 00:01:10,830
თუ თქვენ გახსნა თქვენი სამუშაო გარემოს და
შევქმნათ ფაილი სახელად integer.c მოდით

24
00:01:10,830 --> 00:01:12,110
აკრიფოთ შემდეგ.

25
00:01:12,110 --> 00:01:14,760
Hashtag მოიცავს cs50.h.

26
00:01:14,760 --> 00:01:18,480
ეს აუცილებელია, რადგან get_int
არის CS50 ბიბლიოთეკის ფუნქცია,

27
00:01:18,480 --> 00:01:21,890
ამიტომ ჩვენ უნდა HASHTAG მოიცავს
მისი დეკლარაცია, რათა

28
00:01:21,890 --> 00:01:23,370
გამოყენება ფუნქცია.

29
00:01:23,370 --> 00:01:26,570
და მაშინ ჩემი მთავარი
ფუნქციონირებს მე უბრალოდ აპირებს

30
00:01:26,570 --> 00:01:29,560
უბრალოდ მოვუწოდებთ ფუნქცია get_int.

31
00:01:29,560 --> 00:01:31,750
>> მოდით აწარმოებს და ვხედავთ, როგორ მუშაობს.

32
00:01:31,750 --> 00:01:35,092
მე უკვე შედგენილი, მოდით
უბრალოდ წავიდეთ წინ და აწარმოებს ამ პროგრამის,

33
00:01:35,092 --> 00:01:36,480
./integer.

34
00:01:36,480 --> 00:01:39,880
აქ მაქვს სწრაფი და
აქ, სადაც მე შეყვანის ღირებულება.

35
00:01:39,880 --> 00:01:44,880
ამბობენ, რომ მე დააყენა მხოლოდ რამდენიმე რიცხვი,
50, პროგრამა, გარდა და ტოვებს

36
00:01:44,880 --> 00:01:45,960
და ეს რომ.

37
00:01:45,960 --> 00:01:49,350
>> მაგრამ ამბობენ, რომ მე აწარმოებს ეს ისევ და
მე input რაღაც.

38
00:01:49,350 --> 00:01:51,350
ალბათ, hello მსოფლიოში.

39
00:01:51,350 --> 00:01:55,660
ეს არ არის მთელი რიცხვი, ასე რომ
პროგრამის შეეკითხება მომეცით გაიმეორეთ.

40
00:01:55,660 --> 00:01:59,160
მოდით სცადოთ
ალბათ ათობითი ამ დროს.

41
00:01:59,160 --> 00:02:03,450
0.5, კიდევ ერთხელ, არ არის მთელი რიცხვი, ასე
პროგრამა არ მიიღებს

42
00:02:03,450 --> 00:02:05,290
და ეს კიდე მეუბნებოდა კვლავ სცადოთ.

43
00:02:05,290 --> 00:02:07,070
მოდით მივცეთ მას კიდევ ერთი ნომერი.

44
00:02:07,070 --> 00:02:09,830
პროგრამა იღებს,
ტოვებს, და ჩვენ გავაკეთეთ.

45
00:02:09,830 --> 00:02:13,520
>> ასე რომ, ახლა ჩვენ გვაქვს ფუნქცია
რომელიც საშუალებას გვაძლევს, და უზრუნველყოფს

46
00:02:13,520 --> 00:02:16,790
რომ მომხმარებლის საშუალებებით
რიცხვი, მაგრამ როგორ შეგვიძლია

47
00:02:16,790 --> 00:02:20,330
რეალურად შენარჩუნება სიმღერა
მთელი შეყვანილი მომხმარებლის მიერ?

48
00:02:20,330 --> 00:02:25,260
ისე, ყველა ჩვენ ყველაფერს გავაკეთებთ არის მაღაზია
ამ ღირებულების ცვლადი, ვთქვათ, n.

49
00:02:25,260 --> 00:02:30,580
ასე რომ, თუ განაცხადოს რიცხვი n,
I მითითებული, რომ მნიშვნელობა get_int,

50
00:02:30,580 --> 00:02:34,700
მაშინ n შემდეგ შესანახად რასაც
ვაფასებთ მომხმარებლის inputted.

51
00:02:34,700 --> 00:02:38,620
>> ყველა უფლება, ასე რომ, ახლა ჩვენ დარწმუნდა, რომ
მომხმარებლის მოგვცემს რიცხვი

52
00:02:38,620 --> 00:02:42,550
და ჩვენ ვიცით, თუ როგორ უნდა შევინარჩუნოთ სიმღერა
მთელი რიცხვი, მაგრამ მახსოვს,

53
00:02:42,550 --> 00:02:45,610
რიცხვებით როგორც დადებითი და უარყოფითი.

54
00:02:45,610 --> 00:02:49,110
ასე რომ, ეს ნამდვილად არ აქვს აზრი
კონტექსტში ამ პრობლემის

55
00:02:49,110 --> 00:02:53,570
რომ მომხმარებელს იღებს საშხაპე
ამბობენ, უარყოფით 12-ე წუთზე.

56
00:02:53,570 --> 00:02:59,310
ასე რომ, ჩვენ უნდა დავრწმუნდეთ, რომ მომხმარებელს
რეალურად გვაძლევს დადებითი მთელი რიცხვი.

57
00:02:59,310 --> 00:03:02,130
ახლა ჩვენ არ გვაქვს მხოლოდ
ერთი ფუნქცია, რომ,

58
00:03:02,130 --> 00:03:04,620
ასე რომ, ჩვენ ვაპირებთ, რომ
შექმნა, რომ საკუთარ თავს.

59
00:03:04,620 --> 00:03:07,190
>> ასე რომ ჩვენ გვინდა, რომ მუდმივად
უბიძგონ შესახებ

60
00:03:07,190 --> 00:03:09,730
სანამ მათ მოგვცეს დადებითი მთელი რიცხვი.

61
00:03:09,730 --> 00:03:14,300
თუ მე ვაკეთებ რაღაც მუდმივად შემდეგ
რომ არის akin რომ მარყუჟის, განმეორება.

62
00:03:14,300 --> 00:03:19,130
ასე რომ, ერთი აშენებს, რომ ჩვენ ვიყენებთ
გ განახორციელოს განმეორება და მარყუჟების

63
00:03:19,130 --> 00:03:20,410
ხოლო loop.

64
00:03:20,410 --> 00:03:23,020
ასე რომ, ხოლო მარყუჟის, როგორც
აქ ნაჩვენები, შეასრულოს

65
00:03:23,020 --> 00:03:27,030
რაც არის სხეულში მარყუჟის, როგორც
სანამ მოცემულ მდგომარეობა აფასებს

66
00:03:27,030 --> 00:03:27,900
ჭეშმარიტი.

67
00:03:27,900 --> 00:03:30,640
როგორც კი მდგომარეობა
აფასებს მცდარია, მაშინ

68
00:03:30,640 --> 00:03:34,830
პროგრამის გაგრძელება, რასაც
მას შემდეგ, რაც ორგანოს loop.

69
00:03:34,830 --> 00:03:39,400
>> ასე რომ, ხოლო მარყუჟების აპირებს
უნდა იყოს ნამდვილად სასარგებლო CS50.

70
00:03:39,400 --> 00:03:42,590
მაგრამ ამ კონკრეტულ
შემთხვევაში, ჩვენ ვიცით, რომ ჩვენ

71
00:03:42,590 --> 00:03:48,140
აპირებს შეეკითხება მომხმარებელს მინიმუმ
ერთხელ და მხოლოდ მაშინ loop საჭიროების შემთხვევაში.

72
00:03:48,140 --> 00:03:51,080
ასე რომ, აქ მივალთ
სპეციალური შენება და ეს არის ის,

73
00:03:51,080 --> 00:03:55,020
ძალიან ჰგავს, ხოლო
მარყუჟის მოუწოდა do- ხოლო loop.

74
00:03:55,020 --> 00:03:58,840
>> ასე რომ do ხოლო მარყუჟის გაუშვებს
ორგანოს მარყუჟის ერთხელ მაინც

75
00:03:58,840 --> 00:04:01,750
და მაშინ იგი ამოწმებს
თუ არა ეს უნდა შეასრულოს,

76
00:04:01,750 --> 00:04:05,310
როგორც ეწინააღმდეგებოდა ხოლო მარყუჟის,
რომელიც შეამოწმოს მდგომარეობა

77
00:04:05,310 --> 00:04:07,200
და მაშინ შეასრულოს ორგანოს.

78
00:04:07,200 --> 00:04:11,880
ასე რომ, do-loop ხოლო ის, რაც შეიძლება
გავაკეთოთ არის უბიძგონ შესახებ რიცხვი,

79
00:04:11,880 --> 00:04:14,450
და შემდეგ შეამოწმოს, თუ ეს არასწორია ან არა.

80
00:04:14,450 --> 00:04:18,130
თუ ეს არასწორია, მაშინ ჩვენ
ვიმეორებ, ამ პროცესში ითხოვს შესახებ

81
00:04:18,130 --> 00:04:22,290
მოგვცეს კიდევ ერთი რიცხვი, და შემდეგ
მხოლოდ მაშინ, როდესაც ეს რიცხვი არის მოქმედი,

82
00:04:22,290 --> 00:04:25,060
ჩვენ გავაგრძელებთ
რაც შეეხება შემდგომ.

83
00:04:25,060 --> 00:04:28,030
>> ახლა თქვენ შეამჩნევთ, რომ
დეკლარაცია რიცხვი n

84
00:04:28,030 --> 00:04:31,670
ოდნავ განსხვავებული, რაც ჩვენ
გავაკეთეთ ადრე წინა მაგალითად

85
00:04:31,670 --> 00:04:33,640
და ეს იმიტომ, რომ ფარგლებს.

86
00:04:33,640 --> 00:04:37,920
თუ ჩვენ განაცხადა რიცხვი n შიგნით
ორგანოს do- ხოლო loop,

87
00:04:37,920 --> 00:04:42,640
მაშინ ჩვენ არ უნდა შეეძლოს წვდომა
რომ ღირებულება n გარეთ იმ curly

88
00:04:42,640 --> 00:04:45,050
braces მითითებით ორგანოს loop.

89
00:04:45,050 --> 00:04:51,080
მაგრამ ჩვენ, ფაქტობრივად, გინდათ შესვლა
ღირებულება N მოგვიანებით ჩვენი პროგრამა.

90
00:04:51,080 --> 00:04:55,730
>> OK, ასე რომ, ახლა მოდით ვისაუბროთ
რა ამ მდგომარეობაში უნდა იყოს.

91
00:04:55,730 --> 00:05:00,400
ჩვენ გვინდა, რომ მხოლოდ reprompt
შესახებ, რადგან n არასწორია.

92
00:05:00,400 --> 00:05:04,640
ასე რომ, ვფიქრობ, რომ საკუთარ თავს, რა არასწორი
მთელი მნიშვნელობა არ ჰგავს

93
00:05:04,640 --> 00:05:08,060
და შემდეგ შექმნა ლოგიკური
გამოხატვის გამოთქვას, რომ.

94
00:05:08,060 --> 00:05:13,070
>> ჩვენ თითქმის დასრულდა ჩვენი subtask
რითაც და წევრები მომხმარებლის შეყვანის.

95
00:05:13,070 --> 00:05:16,010
ასე რომ, მოდით ეს ცოტა
ცოტა უფრო მოსახერხებელი

96
00:05:16,010 --> 00:05:18,390
და მისცეს მომხმარებლის პატარა
უფრო მეტი ინფორმაცია

97
00:05:18,390 --> 00:05:20,510
რა ჩვენ რითაც მათ.

98
00:05:20,510 --> 00:05:24,500
მოდით შეეკითხება მომხმარებელს, თითო
სპეც, სიმებიანი წუთი.

99
00:05:24,500 --> 00:05:28,935
ასე გამოყენებით თქვენი printf განცხადებები, რომ
დარწმუნდით, რომ თქვენ არ შეესაბამება ზუსტად.

100
00:05:28,935 --> 00:05:30,230
>> კარგი.

101
00:05:30,230 --> 00:05:33,840
ასე რომ, ახლა ჩვენ გვაქვს სწორი შესახებ
input, დადებითი რიცხვი

102
00:05:33,840 --> 00:05:37,400
მნიშვნელობა რამდენი წუთი
მათ გაატარეს საშხაპე.

103
00:05:37,400 --> 00:05:41,300
ასე რომ, რა არის შემდეგი გამოთვლა
ეკვივალენტს ნომერი ბოთლი.

104
00:05:41,300 --> 00:05:45,250
ის, რასაც ჩვენ ვაპირებთ, რომ აქ შეიძლება
იყოს ძალიან ნათელია, პირველ რიგში,

105
00:05:45,250 --> 00:05:46,640
და რომ კარგადაა.

106
00:05:46,640 --> 00:05:49,320
რაც ჩვენ გვინდა გავაკეთოთ არის
მინდა, რომ დაიწყოს პრაქტიკოსი

107
00:05:49,320 --> 00:05:53,810
იდეა გამოვლენის ნიმუშების და
განვითარებადი ფორმულები პრობლემა.

108
00:05:53,810 --> 00:05:57,200
>> ასე რომ, ჩვენ გვეუბნებიან, თითო სპეც
რომ ერთი წუთი შხაპი

109
00:05:57,200 --> 00:05:59,960
ეკვივალენტია
12 ბოთლი წყალი.

110
00:05:59,960 --> 00:06:03,020
ასე რომ, შემდეგ ორი წუთის გვინდა
გათანაბრებულია 24,

111
00:06:03,020 --> 00:06:05,850
და ხუთი წუთის გვინდა
ტოლფასია 60.

112
00:06:05,850 --> 00:06:08,390
ასე რომ, ახლა, თუ ფიქრობთ,
თქვენ მოხვდით, მაშინ მოდით

113
00:06:08,390 --> 00:06:10,390
ვხედავ თუ შეგიძლიათ ამუშავება
ნიმუში ან ფორმულით

114
00:06:10,390 --> 00:06:14,990
გამოხატოს, თუ ჩვენ არ ამბობენ, n
ე წუთზე, რამდენი ბოთლი წყალი

115
00:06:14,990 --> 00:06:17,930
მინდა, რომ იყოს გამოხატული n?

116
00:06:17,930 --> 00:06:20,680
>> ისევ და ისევ, მიუხედავად იმისა, რომ ამ
შეიძლება იყოს მარტივი, პირველ რიგში,

117
00:06:20,680 --> 00:06:23,240
მოგვიანებით, როდესაც ჩვენ ვიღებთ
უფრო რთული პრობლემები

118
00:06:23,240 --> 00:06:26,360
ჩვენ ვაპირებთ, რომ სურს შეღწევას
პრაქტიკა საიდენტიფიკაციო

119
00:06:26,360 --> 00:06:30,120
ნიმუშების და განვითარებადი ფორმულები
უნდა გაერკვნენ ამ რამ გარეთ.

120
00:06:30,120 --> 00:06:33,450
>> გ თქვენ გაქვთ წვდომა
სტანდარტული არითმეტიკული ოპერაციების,

121
00:06:33,450 --> 00:06:36,520
გარდა ამისა, გამოკლება,
გამრავლება და გაყოფა.

122
00:06:36,520 --> 00:06:38,420
ასე რომ, მე დავტოვებთ მას
თქვენ ახლა უნდა გაერკვნენ,

123
00:06:38,420 --> 00:06:41,300
როგორ გამოვხატო
ექვივალენტი რაოდენობით ბოთლი

124
00:06:41,300 --> 00:06:43,990
რომ მომხმარებელს მოხმარებული
დროს საშხაპე.

125
00:06:43,990 --> 00:06:45,700
>> ყველა უფლება, ჩვენ თითქმის გაკეთდეს.

126
00:06:45,700 --> 00:06:50,650
ჩვენ აიძულა შესახებ მათი შეყვანა,
ჩვენ დარწმუნდა, რომ ეს არის სწორი შეყვანის,

127
00:06:50,650 --> 00:06:53,330
და მაშინ ჩვენ figured, თუ როგორ
გამოვთვალოთ ექვივალენტი

128
00:06:53,330 --> 00:06:55,480
ნომერი ბოთლი, რომ მოხმარებული.

129
00:06:55,480 --> 00:06:59,430
ასე რომ, ბოლო, რაც უნდა გააკეთოთ, რომ გამომავალი
ეკვივალენტს რაოდენობით ბოთლი

130
00:06:59,430 --> 00:07:02,410
და იმედია წაახალისოს
მათ შენარჩუნებას წყალი.

131
00:07:02,410 --> 00:07:06,270
>> Outputting ღირებულება იქნება
იყოს printf განცხადებაში.

132
00:07:06,270 --> 00:07:09,720
თუ მე მინდა გითხრათ, რომ მე
აქვს სამი pets, მაგალითად,

133
00:07:09,720 --> 00:07:13,090
შეიძლება გამოიყენოს printf განაცხადი
რომელიც ასე გამოიყურება.

134
00:07:13,090 --> 00:07:15,880
მაქვს სამი pets და ახალი
ხაზი ლამაზი გაფორმებით.

135
00:07:15,880 --> 00:07:17,880
>> ახლა ჩვენ არ გვინდა, რომ
უბრალოდ მძიმე კოდი რამ.

136
00:07:17,880 --> 00:07:20,740
ამბობენ, რომ ჩემმა
pets იცვლება დროთა განმავლობაში.

137
00:07:20,740 --> 00:07:25,080
ამის შემდეგ მე ვაპირებ, რათა გამოყენების
ჩანაცვლების ჩემი printf განცხადება.

138
00:07:25,080 --> 00:07:27,350
ასე რომ, აქ ჩემი ნომერი არის მთელი რიცხვი.

139
00:07:27,350 --> 00:07:31,480
ამიტომ, მე ვაპირებ, რომ placeholder
რიცხვი გამოყენებით% i.

140
00:07:31,480 --> 00:07:33,930
მე ვაპირებ დაწერა სიმებიანი,
და შემდეგ სიმებიანი

141
00:07:33,930 --> 00:07:38,000
ვწერ მძიმით და შემდეგ
ცვლადი, რომელიც მინდა ბეჭდვა.

142
00:07:38,000 --> 00:07:42,730
ასე რომ, მნიშვნელობა დაიბეჭდება
ნაცვლად, რომ placeholder,% i.

143
00:07:42,730 --> 00:07:47,630
>> თქვენ შეგიძლიათ გამოიყენოთ placeholders, როგორც
ასევე, მოძრავი ერთად% f.

144
00:07:47,630 --> 00:07:50,420
ასევე შეგიძლიათ მქონდეს
ჩანაცვლების სიმებიანი.

145
00:07:50,420 --> 00:07:53,950
მაგალითად, თუ მაქვს გარკვეული რაოდენობის
ძაღლების და გარკვეული რაოდენობის კატა,

146
00:07:53,950 --> 00:07:59,210
მე ზუსტად ორი placeholders აქ და შემდეგ
ჩემი ორი ცვლადის შესაბამისი ბრძანებით.

147
00:07:59,210 --> 00:08:03,130
>> ასე, რომ ახლა ჩვენ ვიცით, როგორ ბეჭდვა
ღირებულებების ინახება ცვლადები,

148
00:08:03,130 --> 00:08:06,030
ძალიან ბოლო რამ
გავაკეთოთ არის ის, რომ ჩვენ

149
00:08:06,030 --> 00:08:10,920
ბეჭდვა ღირებულება ზუსტი ფორმატი
მითითებული დაზუსტება.

150
00:08:10,920 --> 00:08:14,990
ამასთან, ჩვენ აიძულა
შესახებ და დამტკიცდა მათი შეყვანა.

151
00:08:14,990 --> 00:08:17,920
ჩვენ მაშინ გამოითვლება ექვივალენტი
ნომერი ბოთლი წყალი

152
00:08:17,920 --> 00:08:22,100
რომ ისინი მოიხმარენ დროს საშხაპე,
და ჩვენ outputted რომ ღირებულება მათ.

153
00:08:22,100 --> 00:08:24,440
ასე რომ, ჩვენ უკვე დასრულდა წყალი.

154
00:08:24,440 --> 00:08:28,730
>> მე მქვია [? Zamila,?]
და ეს არის CS50.

155
00:08:28,730 --> 00:08:29,909

