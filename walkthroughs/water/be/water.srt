1
00:00:00,000 --> 00:00:00,500

2
00:00:00,500 --> 00:00:01,960
Вядучыя 1. Давайце пагаворым пра ваду.

3
00:00:01,960 --> 00:00:07,280
У гэтай задачы, мы просім карыстальніка паведаміць
нам, як доўга на працягу некалькіх хвілін іх душ

4
00:00:07,280 --> 00:00:11,040
а затым вылічыць эквівалент
колькасць бутэлек вады

5
00:00:11,040 --> 00:00:12,970
якія выкарыстоўвалі іх душ.

6
00:00:12,970 --> 00:00:16,379
>> Дык што ж наша да рабіць,
для гэтай праблемы?

7
00:00:16,379 --> 00:00:20,050
Па-першае, мы будзем хацець
запытваць і затым пацвердзіць

8
00:00:20,050 --> 00:00:22,100
ўваход, які карыстальнік дае нам.

9
00:00:22,100 --> 00:00:24,790
Пасля таго, як мы гарантуем, што мы
мець сапраўдны карыстацкі ўвод,

10
00:00:24,790 --> 00:00:28,230
мы будзем вылічаць
эквівалентнае колькасць бутэлек вады

11
00:00:28,230 --> 00:00:30,770
што карыстач меў на працягу
іх душ, а потым мы

12
00:00:30,770 --> 00:00:33,720
збіраецца распавесці іх
вывад на друк гэты нумар.

13
00:00:33,720 --> 00:00:37,230
>> Так што давайце вырашаць наш першы
Задача, падахвочваючы і праверкі

14
00:00:37,230 --> 00:00:38,550
карыстацкі ўвод.

15
00:00:38,550 --> 00:00:40,910
Для гэтага мы напісалі
Функцыя для вас называецца

16
00:00:40,910 --> 00:00:43,950
get_int знаходзіцца ў Бібліятэцы CS50.

17
00:00:43,950 --> 00:00:48,710
get_int гарантуе, што ўваходы карыстальнікаў
цэлы лік, так што любыя станоўчыя колькасці,

18
00:00:48,710 --> 00:00:51,700
адмоўныя лікі, або
нуль ўсё.

19
00:00:51,700 --> 00:00:55,900
Але калі карыстальнік ўводзіць што-небудзь яшчэ,
так што любая камбінацыя літар або лічбаў

20
00:00:55,900 --> 00:00:59,710
або дзесятковых лікаў, то
карыстальніку будзе прапанавана паўтарыць спробу

21
00:00:59,710 --> 00:01:04,319
і функцыя нічога не прымае
да таго часу, пакуль карыстальнік не дае ім цэлы лік.

22
00:01:04,319 --> 00:01:06,410
>> Дык як жа мы выкарыстоўваем get_int?

23
00:01:06,410 --> 00:01:10,830
Калі вы адкрыеце сваё працоўнае прастору і
стварыць файл з імем integer.c давайце

24
00:01:10,830 --> 00:01:12,110
увядзіце наступную каманду.

25
00:01:12,110 --> 00:01:14,760
Хэштэгу ўключаюць cs50.h.

26
00:01:14,760 --> 00:01:18,480
Гэта неабходна таму, што get_int
з'яўляецца функцыяй бібліятэкі CS50,

27
00:01:18,480 --> 00:01:21,890
таму мы павінны ўключаць хэштэгу
яго заяву ў парадку

28
00:01:21,890 --> 00:01:23,370
каб выкарыстоўваць гэтую функцыю.

29
00:01:23,370 --> 00:01:26,570
А потым у маёй асноўнай
функцыянаваць Я проста

30
00:01:26,570 --> 00:01:29,560
каб проста выклікаць функцыю get_int.

31
00:01:29,560 --> 00:01:31,750
>> Так што давайце запусцім і паглядзім, як гэта працуе.

32
00:01:31,750 --> 00:01:35,092
Я ўжо склаў яго, так што давайце
проста ісці наперад і запусціць гэтую праграму,

33
00:01:35,092 --> 00:01:36,480
./integer.

34
00:01:36,480 --> 00:01:39,880
Тут у мяне ёсць запрашэнне і
вось дзе ўваход я значэнне.

35
00:01:39,880 --> 00:01:44,880
Скажам, я ўставіў толькі некаторы цэлы лік,
50, праграма і квіты лічыць дзейнасці

36
00:01:44,880 --> 00:01:45,960
і што гэта такое.

37
00:01:45,960 --> 00:01:49,350
>> Але сказаць, што я запусціць яго зноў і
Я ўводжу нешта іншае.

38
00:01:49,350 --> 00:01:51,350
Можа быць, прывітанне свет.

39
00:01:51,350 --> 00:01:55,660
Гэта не з'яўляецца цэлым лікам, так што
праграма прапануе мне паўтарыць.

40
00:01:55,660 --> 00:01:59,160
Давайце паспрабуем яшчэ раз з
магчыма, дзесятковую на гэты раз.

41
00:01:59,160 --> 00:02:03,450
0,5, зноў жа, не з'яўляецца цэлым лікам, так
праграма не прыме

42
00:02:03,450 --> 00:02:05,290
і ён скажа мне, каб паўтарыць спробу.

43
00:02:05,290 --> 00:02:07,070
Так давайце дамо яму яшчэ адзін нумар.

44
00:02:07,070 --> 00:02:09,830
Праграма прымае яго,
завяршае працу, і мы зрабілі.

45
00:02:09,830 --> 00:02:13,520
>> Так што цяпер у нас ёсць функцыя
што дазваляе нам і забяспечвае

46
00:02:13,520 --> 00:02:16,790
што карыстач уводзіць
цэлы лік, але як мы можам

47
00:02:16,790 --> 00:02:20,330
на самай справе сачыць з
цэлы лік, уведзенай карыстальнікам?

48
00:02:20,330 --> 00:02:25,260
Ну, усё, што мы зробім, гэта крама
гэта значэнне ў зменнай, скажам, п.

49
00:02:25,260 --> 00:02:30,580
Так што, калі я абвяшчаю цэлы лік п,
і я ўсталяваў, што значэнне get_int,

50
00:02:30,580 --> 00:02:34,700
то п будзе захоўваць усе,
карыстальнікам значэнне уведзеную.

51
00:02:34,700 --> 00:02:38,620
>> Добра, так што зараз мы забяспечылі, што
карыстальнік дасць нам цэлы лік

52
00:02:38,620 --> 00:02:42,550
і мы ведаем, як сачыць
цэлага ліку, але памятайце,

53
00:02:42,550 --> 00:02:45,610
цэлыя лікі, як станоўчыя, так і адмоўныя.

54
00:02:45,610 --> 00:02:49,110
Так што гэта на самай справе не мае сэнсу
У кантэксце гэтай праблемы

55
00:02:49,110 --> 00:02:53,570
што карыстальнік прымае душ
, Скажам, негатыўныя 12 хвілін.

56
00:02:53,570 --> 00:02:59,310
Такім чынам, мы павінны пераканацца, што карыстальнік
на самай справе дае нам станоўчае цэлы лік.

57
00:02:59,310 --> 00:03:02,130
Цяпер у нас няма проста
адна функцыя для гэтага,

58
00:03:02,130 --> 00:03:04,620
такім чынам, мы будзем мець
каб стварыць гэта самі.

59
00:03:04,620 --> 00:03:07,190
>> Таму мы хочам, каб пастаянна
прапануе карыстачу

60
00:03:07,190 --> 00:03:09,730
пакуль яны не даюць нам станоўчае цэлы лік.

61
00:03:09,730 --> 00:03:14,300
Калі я раблю нешта пастаянна, то
што падобна пятлі, паўтор.

62
00:03:14,300 --> 00:03:19,130
Такім чынам, адной з канструкцый, якія мы выкарыстоўваем
ў C для выканання паўтарэння і завесы

63
00:03:19,130 --> 00:03:20,410
пятля ў той час.

64
00:03:20,410 --> 00:03:23,020
Такім чынам, у той час як контур, як і
паказаны тут, будзе выконвацца

65
00:03:23,020 --> 00:03:27,030
усё, што знаходзіцца ў целе цыклу, як
Пакуль дадзеных ўмова прымае значэнне

66
00:03:27,030 --> 00:03:27,900
да ісціны.

67
00:03:27,900 --> 00:03:30,640
Як толькі гэта ўмова
ацэньваецца як ілжывае, то

68
00:03:30,640 --> 00:03:34,830
праграма пяройдзе да таго, што
прыходзіць пасля таго, як цела цыклу.

69
00:03:34,830 --> 00:03:39,400
>> Такім чынам, у той час як завесы збіраюцца
быць вельмі карысным у CS50.

70
00:03:39,400 --> 00:03:42,590
Але ў дадзеным канкрэтным
выпадак, мы ведаем, што мы

71
00:03:42,590 --> 00:03:48,140
збіраецца прапанаваць карыстачу па меншай меры,
адзін раз і затым толькі контур, калі гэта неабходна.

72
00:03:48,140 --> 00:03:51,080
Такім чынам, тут мы прыходзім да
Спецыяльная канструкцыя і гэта

73
00:03:51,080 --> 00:03:55,020
вельмі падобна на некаторы час
пятля называецца петляў зрабі час.

74
00:03:55,020 --> 00:03:58,840
>> Такім чынам, цыкл Do-то час выконвае
цела цыклу па меншай меры адзін раз

75
00:03:58,840 --> 00:04:01,750
а затым ён правярае
ці павінен ён выканаць,

76
00:04:01,750 --> 00:04:05,310
у адрозненне ад цыклу у той час як,
якая будзе правяраць стан

77
00:04:05,310 --> 00:04:07,200
а затым выканаць цела.

78
00:04:07,200 --> 00:04:11,880
Такім чынам, у цыкле рабіць-а тое, што мы маглі б
зрабіць, гэта прапанаваць карыстачу цэлы лік,

79
00:04:11,880 --> 00:04:14,450
а затым праверыць, калі гэта інвалід ці не.

80
00:04:14,450 --> 00:04:18,130
Калі гэта ня дзейнічае, то мы будзем
паўторыце працэс, якое прапануе карыстачу

81
00:04:18,130 --> 00:04:22,290
каб даць нам яшчэ адно цэлае лік, а затым
толькі тады, калі, што цэлы лік з'яўляецца сапраўдным,

82
00:04:22,290 --> 00:04:25,060
мы працягнем
усё, што прыходзіць пасля гэтага.

83
00:04:25,060 --> 00:04:28,030
>> Цяпер вы заўважыце, што
дэкларацыя цэлага ліку п

84
00:04:28,030 --> 00:04:31,670
трохі адрозніваецца ад таго, што мы
гэта рабілі раней у папярэднім прыкладзе

85
00:04:31,670 --> 00:04:33,640
і гэта з-за аб'ёму.

86
00:04:33,640 --> 00:04:37,920
Калі б мы абвясцілі лік п ўнутры
у целе цыклу Do-у той час як,

87
00:04:37,920 --> 00:04:42,640
то мы не змаглі б атрымаць доступ
што значэнне п за межамі гэтых кучаравых

88
00:04:42,640 --> 00:04:45,050
расчалок з указаннем цела цыклу.

89
00:04:45,050 --> 00:04:51,080
Але мы на самай справе хочам, каб атрымаць доступ да
значэнне п ў далейшым у нашай праграме.

90
00:04:51,080 --> 00:04:55,730
>> ОК, так што зараз давайце пагаворым пра тое
тое, што гэта ўмова павінна быць.

91
00:04:55,730 --> 00:05:00,400
Мы хочам толькі reprompt
Карыстальнік, пакуль п з'яўляецца несапраўдным.

92
00:05:00,400 --> 00:05:04,640
Так што думайце самі, што для інваліда
цэлае значэнне будзе выглядаць

93
00:05:04,640 --> 00:05:08,060
а затым стварыць лагічны значэнне
выраз, каб выказаць гэта.

94
00:05:08,060 --> 00:05:13,070
>> Мы амаль скончылі з нашым подзадачи
падказак і праверкі карыстацкага ўводу.

95
00:05:13,070 --> 00:05:16,010
Дык давайце гэта трохі зрабіць
трохі больш дружалюбным да карыстача

96
00:05:16,010 --> 00:05:18,390
і даць карыстальніку трохі
крыху больш інфармацыі

97
00:05:18,390 --> 00:05:20,510
пра тое, што мы падахвочваючы іх.

98
00:05:20,510 --> 00:05:24,500
Так што давайце падкажа карыстачу, згодна з
спецыфікацыі, са радком хвілін.

99
00:05:24,500 --> 00:05:28,935
Такім чынам, выкарыстоўваючы вашыя PRINTF заявы, зрабіць
Пераканайцеся, што вы падыходзіце гэта дакладна.

100
00:05:28,935 --> 00:05:30,230
>> Добра.

101
00:05:30,230 --> 00:05:33,840
Так што цяпер у нас ёсць сапраўдны карыстальнік
ўваход, станоўчае цэлы лік

102
00:05:33,840 --> 00:05:37,400
значэнне колькі хвілін
яны правялі ў душы.

103
00:05:37,400 --> 00:05:41,300
Дык што ж далей, каб разлічыць
эквівалентнае колькасць бутэлек.

104
00:05:41,300 --> 00:05:45,250
Што мы будзем рабіць тут, магчыма,
быць вельмі відавочна для вас, па-першае,

105
00:05:45,250 --> 00:05:46,640
і гэта нармальна.

106
00:05:46,640 --> 00:05:49,320
Тое, што мы хочам зрабіць, гэта мы
хочуць, каб пачаць практыкаваць

107
00:05:49,320 --> 00:05:53,810
ідэя выяўлення заканамернасцяў і
распрацоўцы формулы для задачы.

108
00:05:53,810 --> 00:05:57,200
>> Такім чынам, мы сказалі ў спецыфікацыі
што адна хвіліна ў душы

109
00:05:57,200 --> 00:05:59,960
Гэта эквівалентна прыблізна
12 бутэлек вады.

110
00:05:59,960 --> 00:06:03,020
Такім чынам дзве хвіліны будзе
быць эквівалентна 24,

111
00:06:03,020 --> 00:06:05,850
і праз пяць хвілін будзе
эквівалентна 60.

112
00:06:05,850 --> 00:06:08,390
Так што цяпер, калі вы думаеце,
ў вас ёсць гэта, то давайце

113
00:06:08,390 --> 00:06:10,390
убачыць, калі вы можаце прыдумаць
з малюнкам або формулы

114
00:06:10,390 --> 00:06:14,990
каб выказаць, калі мы сказаць, п
хвілін, колькі бутэлек вады

115
00:06:14,990 --> 00:06:17,930
б, што выяўляецца праз п?

116
00:06:17,930 --> 00:06:20,680
>> Зноў жа, нават калі гэта
можа быць проста на першы погляд,

117
00:06:20,680 --> 00:06:23,240
пазней, калі мы атрымліваем
больш складаныя задачы

118
00:06:23,240 --> 00:06:26,360
мы будзем хацець, каб патрапіць у
практыка выяўлення

119
00:06:26,360 --> 00:06:30,120
ўзоры і развіваюцца формулы
каб зразумець гэтыя рэчы.

120
00:06:30,120 --> 00:06:33,450
>> У C вы маеце доступ да
стандартныя арыфметычныя аперацыі,

121
00:06:33,450 --> 00:06:36,520
складанне, адніманне,
множанне і дзяленне.

122
00:06:36,520 --> 00:06:38,420
Так што я пакіну яго
цяпер, каб высветліць,

123
00:06:38,420 --> 00:06:41,300
як выказаць
эквівалентнае колькасць бутэлек

124
00:06:41,300 --> 00:06:43,990
што карыстальнік спажывацца
падчас іх душ.

125
00:06:43,990 --> 00:06:45,700
>> Добра, мы амаль скончылі.

126
00:06:45,700 --> 00:06:50,650
Мы заахвоцілі карыстальніка для іх ўводу,
мы забяспечылі, што яна дзейнічае на ўваход,

127
00:06:50,650 --> 00:06:53,330
а потым мы высветлілі, як
вылічыць эквівалентнае

128
00:06:53,330 --> 00:06:55,480
колькасць бутэлек, якія яны спажывалі.

129
00:06:55,480 --> 00:06:59,430
Такім чынам, апошняе, што трэба зрабіць, гэта выхад
эквівалентнае колькасць бутэлек

130
00:06:59,430 --> 00:07:02,410
і, мы спадзяемся заахвочваць
іх эканоміі вады.

131
00:07:02,410 --> 00:07:06,270
>> Вывядзенне значэнне будзе
быць Printf заяву.

132
00:07:06,270 --> 00:07:09,720
Калі б я хацеў сказаць вам, што я
ёсць тры хатніх жывёл, напрыклад,

133
00:07:09,720 --> 00:07:13,090
Я мог бы выкарыстаць PRINTF заяву
што выглядае прыкладна так.

134
00:07:13,090 --> 00:07:15,880
У мяне ёсць тры хатніх жывёл, і новы
лінія для прыемнага фарматавання.

135
00:07:15,880 --> 00:07:17,880
>> Цяпер мы не хочам
проста жорсткі код рэчы.

136
00:07:17,880 --> 00:07:20,740
Скажам, лік маіх
хатнія жывёлы змяняюцца з цягам часу.

137
00:07:20,740 --> 00:07:25,080
Тады я буду выкарыстоўваць
запаўняльнікі ў маім PRINTF заяве.

138
00:07:25,080 --> 00:07:27,350
Дык вось маё лік цэлае.

139
00:07:27,350 --> 00:07:31,480
Так што я збіраюся зрабіць запаўняльнік
для цэлага, выкарыстоўваючы% I.

140
00:07:31,480 --> 00:07:33,930
Я збіраюся напісаць радок,
а затым пасля радка

141
00:07:33,930 --> 00:07:38,000
Я пішу коску і затым
зменная, якую я хачу надрукаваць.

142
00:07:38,000 --> 00:07:42,730
Такім чынам, гэта значэнне будзе надрукавана
замест гэтага запаўняльнік,% I.

143
00:07:42,730 --> 00:07:47,630
>> Вы можаце выкарыстоўваць запаўняльнікі, як і
ну, для паплаўкоў з% F.

144
00:07:47,630 --> 00:07:50,420
Вы таксама можаце мець некалькі
запаўняльнікі ў радку.

145
00:07:50,420 --> 00:07:53,950
Напрыклад, калі ў мяне ёсць некаторая колькасць
сабак і некаторы колькасць котак,

146
00:07:53,950 --> 00:07:59,210
Я паклаў два запаўняльнікі тут, а затым
мае дзве зменныя ў адпаведным парадку.

147
00:07:59,210 --> 00:08:03,130
>> Так што цяпер мы ведаем, як друкаваць
значэння, якія захоўваюцца ў зменных,

148
00:08:03,130 --> 00:08:06,030
самая апошняя рэч
зрабіць, гэта пераканацца, што мы

149
00:08:06,030 --> 00:08:10,920
надрукаваць значэнне ў дакладнай фармаце
паказана ў спецыфікацыі.

150
00:08:10,920 --> 00:08:14,990
З гэтымі словамі, мы заахвоціла
карыстальніка і пацверджана іх уклад.

151
00:08:14,990 --> 00:08:17,920
Мы тады разлічылі эквівалент
колькасць бутэлек вады

152
00:08:17,920 --> 00:08:22,100
што яны спажываюць падчас іх душ,
і мы выводны, што для іх значэння.

153
00:08:22,100 --> 00:08:24,440
Такім чынам, мы завяршылі ваду.

154
00:08:24,440 --> 00:08:28,730
>> Мяне завуць [? Zamila ,?]
і гэта CS50.

155
00:08:28,730 --> 00:08:29,909

