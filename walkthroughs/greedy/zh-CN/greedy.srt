1
00:00:00,000 --> 00:00:00,710

2
00:00:00,710 --> 00:00:02,900
>> 让我们贪婪。

3
00:00:02,900 --> 00:00:06,810
在贪婪的，我们的工作就是玩
贪婪收银员的角色。

4
00:00:06,810 --> 00:00:09,750
用户将告诉我们如何
太大的变化，我们欠他们的，

5
00:00:09,750 --> 00:00:13,520
然后我们的工作就是计算
硬币的最小数量

6
00:00:13,520 --> 00:00:17,240
我们可以用它来制作
变化量。

7
00:00:17,240 --> 00:00:19,560
>> 让我们先从一个例子。

8
00:00:19,560 --> 00:00:23,170
假设用户需要$ 0.32回来。

9
00:00:23,170 --> 00:00:28,960
我们可以通过给做
他们32便士，每一分钱。

10
00:00:28,960 --> 00:00:35,180
或者，我也可以用五年coins--通过
给他们三天硬币，$ 0.10，

11
00:00:35,180 --> 00:00:38,060
两便士，$ 0.02每。

12
00:00:38,060 --> 00:00:42,580
但是，我们可以使用，甚至
更少的硬币做的？

13
00:00:42,580 --> 00:00:45,100
>> 在greedy--整体战术
是一个贪婪的cashier--

14
00:00:45,100 --> 00:00:47,600
是使用最大硬币可能。

15
00:00:47,600 --> 00:00:50,670
所以每当我们有
宿舍，我们将使用它们。

16
00:00:50,670 --> 00:00:54,100
然后，一旦这些用完，
我们将使用硬币，每个$ 0.10

17
00:00:54,100 --> 00:00:58,840
然后镍，每次5美分，而
再往下便士，每一分钱。

18
00:00:58,840 --> 00:01:01,792
通过使用最大的硬币
只要有可能，我们可以，

19
00:01:01,792 --> 00:01:07,350
我们必须确保我们用最少数量的
硬币的可能作出改变。

20
00:01:07,350 --> 00:01:09,180
>> 因此，让我们走在这条通过。

21
00:01:09,180 --> 00:01:11,660
用户需要$ 0.32。

22
00:01:11,660 --> 00:01:14,200
因此，我们扪心自问，
我们可以用四分之一？

23
00:01:14,200 --> 00:01:15,560
嗯，是的，我们可以。

24
00:01:15,560 --> 00:01:19,720
所以，现在我们只知道他们
$ 0.07，我们用一个硬币。

25
00:01:19,720 --> 00:01:20,970
>> 我们可以用一个季度？

26
00:01:20,970 --> 00:01:21,890
哦，不。

27
00:01:21,890 --> 00:01:27,570
$为0.07少于$ 0.25，所以我们进行
可用下一个最大的硬币。

28
00:01:27,570 --> 00:01:30,690
角钱为$ 0.10和
再次，我们不能用角钱。

29
00:01:30,690 --> 00:01:35,480
由于硬币是值得$ 0.10这
比变化的欠款金额。

30
00:01:35,480 --> 00:01:36,790
>> 我们去镍。

31
00:01:36,790 --> 00:01:40,890
而且，是真的，$是0.05小于
$ 0.10--所以我们可以使用镍。

32
00:01:40,890 --> 00:01:46,104
所以，现在我们只欠用户$ 0.02
而且到目前为止我们用了两个硬币。

33
00:01:46,104 --> 00:01:47,270
我们不能用另一个镍。

34
00:01:47,270 --> 00:01:51,140
于是我们进行了最后一枚硬币在
我们所掌握的，哪些是便士。

35
00:01:51,140 --> 00:01:52,270
>> 我们可以用一分钱？

36
00:01:52,270 --> 00:01:59,060
好吧，yes--和我们最终使用两个
便士总共四个硬币。

37
00:01:59,060 --> 00:02:01,430
>> 一旦你完成后，
程序会这个样子。

38
00:02:01,430 --> 00:02:03,710
一旦用户运行
贪婪的计划，他们将

39
00:02:03,710 --> 00:02:07,270
被提示以得到的量
以美元计价的变化，他们正在欠款。

40
00:02:07,270 --> 00:02:11,140
然后你的程序将输出
硬币的最小量

41
00:02:11,140 --> 00:02:14,740
该贪婪的收银员会用
做出改变的量。

42
00:02:14,740 --> 00:02:18,160
>> 所以，现在让我们来打破这种
下到我们的子任务。

43
00:02:18,160 --> 00:02:21,410
首先我们要提醒我们
用户对变化量。

44
00:02:21,410 --> 00:02:25,630
并且，与任何用户输入，我们希望
确保我们验证输入

45
00:02:25,630 --> 00:02:29,360
并确保我们可以使用
输入对我们的节目的其余部分。

46
00:02:29,360 --> 00:02:32,480
然后，我们要始终
使用最大可能点

47
00:02:32,480 --> 00:02:35,240
并跟踪使用的硬币。

48
00:02:35,240 --> 00:02:39,080
最后，打印最终
我们使用硬币的数目。

49
00:02:39,080 --> 00:02:40,970
>> 所以，让我们来谈谈提示。

50
00:02:40,970 --> 00:02:43,550
量必须美分，
这也是美元。

51
00:02:43,550 --> 00:02:48,440
因此对于美元，我们要去
使用浮点变量类型。

52
00:02:48,440 --> 00:02:52,390
现在，每当你问一个用户输入，
要确保它是有效的。

53
00:02:52,390 --> 00:02:56,640
所以在这里我们想利用
的do-whil​​e循环结构。

54
00:02:56,640 --> 00:03:00,320
>> 一个do-whil​​e循环将执行
循环体至少一次。

55
00:03:00,320 --> 00:03:01,650
所以这个就派上用场了。

56
00:03:01,650 --> 00:03:05,510
我们知道，我们需要提示
用户至少一次的浮动。

57
00:03:05,510 --> 00:03:07,100
现在，如果花车是有效的。

58
00:03:07,100 --> 00:03:07,710
那很棒。

59
00:03:07,710 --> 00:03:08,460
我们继续前进。

60
00:03:08,460 --> 00:03:11,910
但如果没有，则循环将确保
我们得到适当浮动

61
00:03:11,910 --> 00:03:16,810
通过不断重复，直到
用户为我们提供了一个有效的值。

62
00:03:16,810 --> 00:03:18,760
>> 现在的DO-而
环情况下，我们需要

63
00:03:18,760 --> 00:03:22,000
考虑是什么意思
有一个无效的浮动。

64
00:03:22,000 --> 00:03:24,220
所以为的范围内
此问题，可能

65
00:03:24,220 --> 00:03:27,450
这是有道理的只是
接受正值。

66
00:03:27,450 --> 00:03:32,010
>> 因此，移动on--，我们已经获得了
在来自用户的美元值。

67
00:03:32,010 --> 00:03:35,380
但是，我们正在处理的硬币，
这是完全美分。

68
00:03:35,380 --> 00:03:38,660
$ 1等价于100美分。

69
00:03:38,660 --> 00:03:43,670
因此，一个好东西做的是
转换这些值转换成美分。

70
00:03:43,670 --> 00:03:48,380
>> 现在从一个浮动转换时
为整数，所以美元美分，

71
00:03:48,380 --> 00:03:52,230
我们要确保我们很小心
有关浮点不精确。

72
00:03:52,230 --> 00:03:55,260
因此，这意味着that--说
我的美元value--我的浮法

73
00:03:55,260 --> 00:04:00,260
value--是偶数2 $，仍有
可能是在那里一些流浪的数字。

74
00:04:00,260 --> 00:04:04,590
因此，我们要确保，不仅
我们乘以100，以获得美分，

75
00:04:04,590 --> 00:04:06,480
但我们也圆其关闭。

76
00:04:06,480 --> 00:04:09,210
>> 所以现在我们有量
改变欠给用户。

77
00:04:09,210 --> 00:04:13,430
我们最初得到的以美元，
现在我们将它转​​换为美分。

78
00:04:13,430 --> 00:04:17,029
所以，现在我们可以用的心脏进行
贪心算法，这始终是

79
00:04:17,029 --> 00:04:19,220
用最大的硬币可能。

80
00:04:19,220 --> 00:04:21,930
虽然我们这样做，
这是至关重要的，我们也

81
00:04:21,930 --> 00:04:25,360
跟踪有多少硬币是
将要返回给用户

82
00:04:25,360 --> 00:04:28,630
以及剩余的
改变欠给用户。

83
00:04:28,630 --> 00:04:31,130
>> 该程序会
这样的事情。

84
00:04:31,130 --> 00:04:34,190
你得到后的金额
美元和转换，要美分，

85
00:04:34,190 --> 00:04:35,790
那么你会进入一个循环。

86
00:04:35,790 --> 00:04:38,400
虽然宿舍可
used--也就是说

87
00:04:38,400 --> 00:04:43,660
而变化的欠量
用户是大于或等于$ 0.25，

88
00:04:43,660 --> 00:04:45,040
您将使用的四分之一。

89
00:04:45,040 --> 00:04:47,000
>> 现在做什么用的四分之一意味着什么？

90
00:04:47,000 --> 00:04:51,280
好吧，one--你会增加硬币
算要返回给用户。

91
00:04:51,280 --> 00:04:55,890
其次，你会减少电流
变化量欠回用户

92
00:04:55,890 --> 00:04:57,520
由$ 0.25。

93
00:04:57,520 --> 00:05:00,680
>> 重复直到后
小区可以不再使用，

94
00:05:00,680 --> 00:05:04,630
进行到下一个最大的
coin--在这种情况下硬币，$ 0.10

95
00:05:04,630 --> 00:05:07,750
所以你输入循环，直到
你可以不再使用角钱。

96
00:05:07,750 --> 00:05:10,720
然后继续下一个
最大的硬币，镍。

97
00:05:10,720 --> 00:05:14,810
后镍不能再被使用，
使用便士的剩余量。

98
00:05:14,810 --> 00:05:17,800
最后，打印
使用硬币的数目。

99
00:05:17,800 --> 00:05:20,350
>> 另一种方式，你可以
接近贪婪的问题

100
00:05:20,350 --> 00:05:22,950
是使用模数的方法。

101
00:05:22,950 --> 00:05:25,690
模是一个操作符
返回剩余

102
00:05:25,690 --> 00:05:27,680
的两个数字之间的分工。

103
00:05:27,680 --> 00:05:30,270
说我有50个MOD 5。

104
00:05:30,270 --> 00:05:34,070
那么，5是50倍，
所以，其余为0。

105
00:05:34,070 --> 00:05:39,230
50 MOD 10--好，10也是一个因素
50，所以余数也为0。

106
00:05:39,230 --> 00:05:43,660
50 MOD 50--好，任何数量的国防部本身
不会有任何剩余部分。

107
00:05:43,660 --> 00:05:45,510
>> 什么50国防部49？

108
00:05:45,510 --> 00:05:47,910
那么，只有49进入50次。

109
00:05:47,910 --> 00:05:50,290
因此，其余部分将是1。

110
00:05:50,290 --> 00:05:55,180
53 MOD 50将
给你3余数。

111
00:05:55,180 --> 00:05:59,120
>> 那么，如何才能用模
也许有些分裂

112
00:05:59,120 --> 00:06:01,690
实现我们的贪心算法？

113
00:06:01,690 --> 00:06:05,550
好了，我们还是要留真实的
贪心算法 - 即心脏的

114
00:06:05,550 --> 00:06:07,910
使用是最大的硬币可能。

115
00:06:07,910 --> 00:06:14,570
>> 因此，让我们扪心自问，我们可以使用任何
季度返回$ 0.32〜用户。

116
00:06:14,570 --> 00:06:20,070
那么，32国防部25给
我们的$为0.07剩余部分。

117
00:06:20,070 --> 00:06:24,500
所以这告诉我们，我们绝对可以
用一个季度的$为0.07剩余。

118
00:06:24,500 --> 00:06:26,180
>> 然后我们可以使用任何银币吗？

119
00:06:26,180 --> 00:06:32,740
那么，no--因为0.07 $ MOD
$ 0.10为我们提供了7余数。

120
00:06:32,740 --> 00:06:34,960
10不进入7可言。

121
00:06:34,960 --> 00:06:36,390
>> 这样，我们才能使用镍？

122
00:06:36,390 --> 00:06:40,490
嗯$为0.07国防部5美分
给了我们两个剩余。

123
00:06:40,490 --> 00:06:42,930
最后，我们可以使用任何便士？

124
00:06:42,930 --> 00:06:45,930
2 MOD 1给了我们0，
这是什么最终

125
00:06:45,930 --> 00:06:48,160
我们希望，因为那时，
也就是说，我们已经返回

126
00:06:48,160 --> 00:06:50,160
给用户的所有变化的欠款。

127
00:06:50,160 --> 00:06:54,320
>> 所以，现在你有两种可能的方式
实施贪心算法 - 

128
00:06:54,320 --> 00:06:59,230
一个用环和一个具有
模和除法的组合。

129
00:06:59,230 --> 00:07:03,010
所以最后，我们只需要
打印硬币的最终数目。

130
00:07:03,010 --> 00:07:06,520
>> 如果我想告诉你，我有
3宠物和这个值硬编码，

131
00:07:06,520 --> 00:07:09,240
然后，我可以只使用一个
简单的打印测试声明。

132
00:07:09,240 --> 00:07:12,320
但是，我们的价值实际上是
存储在变量。

133
00:07:12,320 --> 00:07:15,260
那么，你如何打印
存储在变量的值？

134
00:07:15,260 --> 00:07:17,880
>> 为此，我们采取
优势占位符。

135
00:07:17,880 --> 00:07:21,540
说我已经宣布
初始化的整数n。

136
00:07:21,540 --> 00:07:25,170
再后来，如果我想打印
值，那么我会写的字符串。

137
00:07:25,170 --> 00:07:30,500
和而不是价值，我会用
对于integer--％我的占位符。

138
00:07:30,500 --> 00:07:33,800
然后，后弦，我有一个
逗号，其次是可变

139
00:07:33,800 --> 00:07:34,950
我想打印。

140
00:07:34,950 --> 00:07:38,550
而后来，当它打印，
它会打印n的值。

141
00:07:38,550 --> 00:07:41,570
>> 我还可以使用一个占位符
为浮点数，例如。

142
00:07:41,570 --> 00:07:44,000
如果我想告诉你如何
多少现金我在我的口袋里，

143
00:07:44,000 --> 00:07:46,820
然后，我可以说我有％F美元。

144
00:07:46,820 --> 00:07:51,330
而后来当它打印，则n会
采取该地方持有人的地方。

145
00:07:51,330 --> 00:07:55,530
我还，例如，使用几个
占位符的几个变量。

146
00:07:55,530 --> 00:07:57,590
所以只要我列出
他们为了，那我

147
00:07:57,590 --> 00:08:00,390
可以告诉你有多少
狗和猫我有。

148
00:08:00,390 --> 00:08:03,710
>> 现在我们知道如何提示
用户对变化量，

149
00:08:03,710 --> 00:08:06,130
确保该输入
是有效的，然后我们

150
00:08:06,130 --> 00:08:10,370
实施有两种可能的方式
始终使用的贪心算法

151
00:08:10,370 --> 00:08:12,090
最大的硬币可能。

152
00:08:12,090 --> 00:08:15,050
因为我们已经把轨道
我们有多少硬币使用，

153
00:08:15,050 --> 00:08:19,210
那么我们可以打印在最后的价值，
告诉他们有多少硬币是用户

154
00:08:19,210 --> 00:08:20,240
取回。

155
00:08:20,240 --> 00:08:24,240
>> 我的名字是Amayla，这是CS50。

156
00:08:24,240 --> 00:08:25,915

