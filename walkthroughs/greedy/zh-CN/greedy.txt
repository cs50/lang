让我们贪婪。 在贪婪的，我们的工作就是玩 贪婪收银员的角色。 用户将告诉我们如何 太大的变化，我们欠他们的， 然后我们的工作就是计算 硬币的最小数量 我们可以用它来制作 变化量。 

让我们先从一个例子。 假设用户需要$ 0.32回来。 我们可以通过给做 他们32便士，每一分钱。 或者，我也可以用五年coins--通过 给他们三天硬币，$ 0.10， 两便士，$ 0.02每。 但是，我们可以使用，甚至 更少的硬币做的？ 

在greedy--整体战术 是一个贪婪的cashier-- 是使用最大硬币可能。 所以每当我们有 宿舍，我们将使用它们。 然后，一旦这些用完， 我们将使用硬币，每个$ 0.10 然后镍，每次5美分，而 再往下便士，每一分钱。 通过使用最大的硬币 只要有可能，我们可以， 我们必须确保我们用最少数量的 硬币的可能作出改变。 

因此，让我们走在这条通过。 用户需要$ 0.32。 因此，我们扪心自问， 我们可以用四分之一？ 嗯，是的，我们可以。 所以，现在我们只知道他们 $ 0.07，我们用一个硬币。 

我们可以用一个季度？ 哦，不。 $为0.07少于$ 0.25，所以我们进行 可用下一个最大的硬币。 角钱为$ 0.10和 再次，我们不能用角钱。 由于硬币是值得$ 0.10这 比变化的欠款金额。 

我们去镍。 而且，是真的，$是0.05小于 $ 0.10--所以我们可以使用镍。 所以，现在我们只欠用户$ 0.02 而且到目前为止我们用了两个硬币。 我们不能用另一个镍。 于是我们进行了最后一枚硬币在 我们所掌握的，哪些是便士。 

我们可以用一分钱？ 好吧，yes--和我们最终使用两个 便士总共四个硬币。 

一旦你完成后， 程序会这个样子。 一旦用户运行 贪婪的计划，他们将 被提示以得到的量 以美元计价的变化，他们正在欠款。 然后你的程序将输出 硬币的最小量 该贪婪的收银员会用 做出改变的量。 

所以，现在让我们来打破这种 下到我们的子任务。 首先我们要提醒我们 用户对变化量。 并且，与任何用户输入，我们希望 确保我们验证输入 并确保我们可以使用 输入对我们的节目的其余部分。 然后，我们要始终 使用最大可能点 并跟踪使用的硬币。 最后，打印最终 我们使用硬币的数目。 

所以，让我们来谈谈提示。 量必须美分， 这也是美元。 因此对于美元，我们要去 使用浮点变量类型。 现在，每当你问一个用户输入， 要确保它是有效的。 所以在这里我们想利用 的do-whil​​e循环结构。 

一个do-whil​​e循环将执行 循环体至少一次。 所以这个就派上用场了。 我们知道，我们需要提示 用户至少一次的浮动。 现在，如果花车是有效的。 那很棒。 我们继续前进。 但如果没有，则循环将确保 我们得到适当浮动 通过不断重复，直到 用户为我们提供了一个有效的值。 

现在的DO-而 环情况下，我们需要 考虑是什么意思 有一个无效的浮动。 所以为的范围内 此问题，可能 这是有道理的只是 接受正值。 

因此，移动on--，我们已经获得了 在来自用户的美元值。 但是，我们正在处理的硬币， 这是完全美分。 $ 1等价于100美分。 因此，一个好东西做的是 转换这些值转换成美分。 

现在从一个浮动转换时 为整数，所以美元美分， 我们要确保我们很小心 有关浮点不精确。 因此，这意味着that--说 我的美元value--我的浮法 value--是偶数2 $，仍有 可能是在那里一些流浪的数字。 因此，我们要确保，不仅 我们乘以100，以获得美分， 但我们也圆其关闭。 

所以现在我们有量 改变欠给用户。 我们最初得到的以美元， 现在我们将它转​​换为美分。 所以，现在我们可以用的心脏进行 贪心算法，这始终是 用最大的硬币可能。 虽然我们这样做， 这是至关重要的，我们也 跟踪有多少硬币是 将要返回给用户 以及剩余的 改变欠给用户。 

该程序会 这样的事情。 你得到后的金额 美元和转换，要美分， 那么你会进入一个循环。 虽然宿舍可 used--也就是说 而变化的欠量 用户是大于或等于$ 0.25， 您将使用的四分之一。 

现在做什么用的四分之一意味着什么？ 好吧，one--你会增加硬币 算要返回给用户。 其次，你会减少电流 变化量欠回用户 由$ 0.25。 

重复直到后 小区可以不再使用， 进行到下一个最大的 coin--在这种情况下硬币，$ 0.10 所以你输入循环，直到 你可以不再使用角钱。 然后继续下一个 最大的硬币，镍。 后镍不能再被使用， 使用便士的剩余量。 最后，打印 使用硬币的数目。 

另一种方式，你可以 接近贪婪的问题 是使用模数的方法。 模是一个操作符 返回剩余 的两个数字之间的分工。 说我有50个MOD 5。 那么，5是50倍， 所以，其余为0。 50 MOD 10--好，10也是一个因素 50，所以余数也为0。 50 MOD 50--好，任何数量的国防部本身 不会有任何剩余部分。 

什么50国防部49？ 那么，只有49进入50次。 因此，其余部分将是1。 53 MOD 50将 给你3余数。 

那么，如何才能用模 也许有些分裂 实现我们的贪心算法？ 好了，我们还是要留真实的 贪心算法 - 即心脏的 使用是最大的硬币可能。 

因此，让我们扪心自问，我们可以使用任何 季度返回$ 0.32〜用户。 那么，32国防部25给 我们的$为0.07剩余部分。 所以这告诉我们，我们绝对可以 用一个季度的$为0.07剩余。 

然后我们可以使用任何银币吗？ 那么，no--因为0.07 $ MOD $ 0.10为我们提供了7余数。 10不进入7可言。 

这样，我们才能使用镍？ 嗯$为0.07国防部5美分 给了我们两个剩余。 最后，我们可以使用任何便士？ 2 MOD 1给了我们0， 这是什么最终 我们希望，因为那时， 也就是说，我们已经返回 给用户的所有变化的欠款。 

所以，现在你有两种可能的方式 实施贪心算法 -  一个用环和一个具有 模和除法的组合。 所以最后，我们只需要 打印硬币的最终数目。 

如果我想告诉你，我有 3宠物和这个值硬编码， 然后，我可以只使用一个 简单的打印测试声明。 但是，我们的价值实际上是 存储在变量。 那么，你如何打印 存储在变量的值？ 

为此，我们采取 优势占位符。 说我已经宣布 初始化的整数n。 再后来，如果我想打印 值，那么我会写的字符串。 和而不是价值，我会用 对于integer--％我的占位符。 然后，后弦，我有一个 逗号，其次是可变 我想打印。 而后来，当它打印， 它会打印n的值。 

我还可以使用一个占位符 为浮点数，例如。 如果我想告诉你如何 多少现金我在我的口袋里， 然后，我可以说我有％F美元。 而后来当它打印，则n会 采取该地方持有人的地方。 我还，例如，使用几个 占位符的几个变量。 所以只要我列出 他们为了，那我 可以告诉你有多少 狗和猫我有。 

现在我们知道如何提示 用户对变化量， 确保该输入 是有效的，然后我们 实施有两种可能的方式 始终使用的贪心算法 最大的硬币可能。 因为我们已经把轨道 我们有多少硬币使用， 那么我们可以打印在最后的价值， 告诉他们有多少硬币是用户 取回。 

我的名字是Amayla，这是CS50。 