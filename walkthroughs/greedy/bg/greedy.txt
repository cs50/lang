Да се ​​алчни. В алчни, нашата работа е да играе ролята на алчен касиер. Потребителят ще ни каже как много промени ние ги дължа, и след това нашата работа е да се изчисли минималният брой на монети че можем да използваме, за да се направи че стойността на промяната. 

Нека да започнем с един пример. Кажете на потребителя изисква $ 0,32 обратно. Бихме могли да направим това, като дава тях 32 стотинки, един цент всяка. Или аз също може да използва пет coins-- от давайки им три десетки цента $ 0.10 всеки, и две пенита, $ 0,02 всяка. Но бихме могли да използваме дори по-малко монети, за да направят това? 

Цялата тактика в greedy-- да бъде алчен cashier-- е да се използва възможно най-голямата монета. Така че всеки път, когато имаме квартали ние ще ги използват. И тогава, след като тези, които се изчерпи, ние ще използваме Dimes, $ 0,10 всяка. Тогава петачета, 5 цента всяка, и след това до жълти стотинки, един цент всяка. С помощта на най-голямата монета възможно винаги, когато можем, ние сме сигурни, че използвате най-малък брой на възможно монети, за да направите промяната. 

Така че нека да ходят това сам. Потребителят трябва $ 0,32. Така че ние се питаме, можем да използваме една четвърт? Е, да можем. Така че сега ние само ги знам $ 0,07, и ние използвахме една монета. 

Можем ли да използваме друг квартал? Е, не. $ 0,07 е по-малко от $ 0,25, така че ние се процедира на следващия по големина монетата разположение. Dimes са на стойност $ 0,10, и отново, ние не може да използва десетки цента. Защото Dimes са на стойност $ 0,10, което е по-малък от размера на промяна дължи. 

Ходим петачета. И, да наистина, $ 0,05 е по-малко от $ 0.10-- така че ние може да се използва никел. Така че сега ние само дължа на потребителя $ 0,02, и ние сме толкова далеч използва две монети. Ние не може да се използва друг никел. Така че след това се пристъпва към последната монета в наше разположение, които са стотинките. 

И можем да използваме стотинка? Е, yes-- и ние в крайна сметка с помощта на две пенита за общо четири монети. 

След като сте готови, за програма ще изглежда по този начин. След като потребителят управлява алчни програма, те ще бъдете подканени да даде сумата на промяна в долари, че те са дължими. И тогава вашата програма ще изведе минималният размер на монети че алчни касата ще използва да се направи, че стойността на промяната. 

Така че сега нека да се разбие надолу в нашите подзадачи. Първо ние ще подкани ни потребител за сума от промяна. И, както при всеки вход от потребителя, ние искаме да уверете се, че ние потвърдим, че вход и да се гарантира, че можем да използваме, че вход за останалата част от нашата програма. След това ние ще винаги използвате възможно най-голямата точка и да следите на монетите, използвани. И най-накрая, отпечатване на финала брой монети, които се използват. 

Така че нека да говорим за напомняне. Сумата трябва да се направи цента, и това е в долари. И така в продължение на долара, отиваме да използвате тип плувка променлива. Сега, когато ви задам един потребител за вход, вие искате да се уверите, че това е валидно. И така, тук сме искали да се възползваме на линия конструкт направи-а. 

А да не се прави, докато линия ще изпълни тялото на цикъла най-малко веднъж. Така че това е по-удобен. Ние знаем, че ние трябва да се промпт потребителя най-малко веднъж на плувка. Сега, ако това плувка е валиден. Това е страхотно. Ние се премине. Но ако не, цикълът ще се гарантира, че ние получите правилното плувка чрез повтаряне непрекъснато, докато потребителят ни дава валидна стойност. 

Сега за да не се прави докато състояние линия, ние се нуждаем от да се помисли какво означава да има невалиден плувка. Така контекста на този проблем, вероятно че има смисъл само, за да приемам положителни стойности. 

Така че се движат on-- сме получили стойност в долари от страна на потребителя. Но си имаме работа с монети, които са изцяло в цента. $ 1 е равно на 100 цента. Така че по-добре да се направи, е да се конвертирате тези стойности в цента. 

Сега при конвертиране от един поплавък до цяло число, така долара до цента, ние искаме да сме сигурни, че сте внимателни за плаваща запетая неточност. Така че това означава, че that-- каже моя долар value-- ми плувка value-- беше още $ 2, все още могат да бъдат някои бездомни номера в там. Така че ние искаме да се уверите, че не само можем да се умножи по 100, за да получите най-цента, но ние също го закръглят. 

Така че сега ние имаме сумата на климата, дължима от потребителя. Ние първоначално е получила в долари, и сега сме го превръща в цента. Така че сега ние можем да се пристъпи към сърцето на алчни алгоритъм, който е винаги използване на възможно най-голяма монета. Докато ние правим това, това е важно, че ние също да следите колко монети са ще бъдат върнати на потребителя както и останалите промените, дължима от потребителя. 

Програмата ще изглежда нещо като това. След като получите сумата на долара и конвертирате, че да цента, а след това ще влезе в цикъл. Докато могат да бъдат четвърти used-- тоест докато стойността на промяната, дължими на потребител е по-голямо от или равно на 0,25 $, ще използвате една четвърт. 

Сега това, което прави, използвайки една четвърт доведе? Е, one-- ще се увеличи на монетата разчита да се връща на потребителя. И второ, че ще намали тока размер на промяна дължи обратно на потребителя от $ 0,25. 

След повтаряне, че докато квартали вече не могат да бъдат използвани, пристъпи към следващата по големина coin-- в този случай Dimes, $ 0,10. Така че ще влиза, че цикъл, докато вие вече не може да използва десетки цента. След това преминете към следващата най-голямата монета, петачета. След петачета вече не могат да бъдат използвани, използвате останалата част от сумата в пари. И най-накрая, отпечатване на брой монети използва. 

Друг начин, по който можете да доближава до алчни проблема е да се използва подхода на модул. Modulo е оператор че се връща остатъка на разделението между две числа. Да речем, имах 50 мод 5. Е, 5 е фактор 50, така остатъка ще бъде 0. 50 мод 10-- добре, 10 също е фактор 50, така че останалата част е 0. 50 мод 50-- добре, всеки брой самия мод няма да имат всички остатъци. 

Какво ще кажете за 50 мод 49? Е, 49 отива само в 50 веднъж. Така че остатъка ще бъде 1. 53 мод 50 ще ви даде остатък от 3. 

И така, как можем да използваме по модул и може би някои разделение за изпълнение на нашия алчен алгоритъм? Е, ние все още искат да останат верни на Сърцето на алчните algorithm-- че е с помощта на възможно най-голямата монета. 

Така че нека да се запитаме дали ние можем да използваме всеки квартали, за да се върнат $ 0,32 до потребителя. Е, 32 мод 25 дава ни остатък от $ 0,07. Така че ни казва, че ние определено може да използват една четвърт с $ 0,07 оставащото. 

Можем ли тогава използвайте Dimes? Е, no-- защото $ 0,07 мод $ 0,10 ни дава остатък от 7. 10 не влиза в 7 изобщо. 

След това можем да използваме петачета? Е $ 0,07 мод 5 цента дава ни двамата останали. И накрая, можем да използваме някакви пари? 2 мод 1 ни дава 0, което е в крайна сметка това, което ние искаме, защото след това, че означава, че сме се завръща за потребителя всичко на промяната дължи. 

Така че сега имате два възможни начини за прилагане на алчни algorithm-- един с вериги и един с комбинация от модул и разделение. Така че най-накрая, ние просто трябва да се отпечатване на окончателния брой на монети. 

Ако исках да ви, че имах кажа 3 домашни любимци и тази стойност е кодиран, тогава бих могъл просто да се използва прост изявление тест печат. Но нашата стойност е действително съхранява в променлива. Е, как да печатате на ценности, съхранявани в променливи? 

За това ние приемаме предимство на контейнери. Да речем, че вече е обявил подготвен за число п. След това по-късно, ако исках да отпечатате, че стойност, тогава аз ще пиша на низа. И вместо тази стойност бих използвал контейнер за които integer--% аз. Тогава, след низа, имам запетая, последвано от променливата че искам да отпечатате. И по-късно, когато се отпечата, той ще отпечата стойността на п. 

Аз също може да се използва контейнер за поплавък, например. Ако исках да ви кажа как много пари имам в джоба си, След това мога да кажа, че има% F долара. И по-късно, когато се отпечата, тогава п ще заеме мястото на този притежател на място. Аз също може, например, да се използва няколко Запазено място за няколко променливи. Така че, докато съм се изброят ги в ред, тогава аз мога да ви кажа колко кучета и котки, които имам. 

Сега ние знаем как да промпт потребител за сума от промяна, гарантира, че вход е валидно, и тогава ние има два възможни начина на прилагане алчни алгоритъм на винаги използвайки възможно най-голямата монета. Тъй като ние сме следили колко монети, което използваме, тогава можем да отпечатате тази стойност в края, съобщи на потребителя колко монети те са да се върна. 

Моето име е Amayla, и това е CS50. 