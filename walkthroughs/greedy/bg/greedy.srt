1
00:00:00,000 --> 00:00:00,710

2
00:00:00,710 --> 00:00:02,900
>> Да се ​​алчни.

3
00:00:02,900 --> 00:00:06,810
В алчни, нашата работа е да играе
ролята на алчен касиер.

4
00:00:06,810 --> 00:00:09,750
Потребителят ще ни каже как
много промени ние ги дължа,

5
00:00:09,750 --> 00:00:13,520
и след това нашата работа е да се изчисли
минималният брой на монети

6
00:00:13,520 --> 00:00:17,240
че можем да използваме, за да се направи
че стойността на промяната.

7
00:00:17,240 --> 00:00:19,560
>> Нека да започнем с един пример.

8
00:00:19,560 --> 00:00:23,170
Кажете на потребителя изисква $ 0,32 обратно.

9
00:00:23,170 --> 00:00:28,960
Бихме могли да направим това, като дава
тях 32 стотинки, един цент всяка.

10
00:00:28,960 --> 00:00:35,180
Или аз също може да използва пет coins-- от
давайки им три десетки цента $ 0.10 всеки,

11
00:00:35,180 --> 00:00:38,060
и две пенита, $ 0,02 всяка.

12
00:00:38,060 --> 00:00:42,580
Но бихме могли да използваме дори
по-малко монети, за да направят това?

13
00:00:42,580 --> 00:00:45,100
>> Цялата тактика в greedy--
да бъде алчен cashier--

14
00:00:45,100 --> 00:00:47,600
е да се използва възможно най-голямата монета.

15
00:00:47,600 --> 00:00:50,670
Така че всеки път, когато имаме
квартали ние ще ги използват.

16
00:00:50,670 --> 00:00:54,100
И тогава, след като тези, които се изчерпи,
ние ще използваме Dimes, $ 0,10 всяка.

17
00:00:54,100 --> 00:00:58,840
Тогава петачета, 5 цента всяка, и
след това до жълти стотинки, един цент всяка.

18
00:00:58,840 --> 00:01:01,792
С помощта на най-голямата монета
възможно винаги, когато можем,

19
00:01:01,792 --> 00:01:07,350
ние сме сигурни, че използвате най-малък брой
на възможно монети, за да направите промяната.

20
00:01:07,350 --> 00:01:09,180
>> Така че нека да ходят това сам.

21
00:01:09,180 --> 00:01:11,660
Потребителят трябва $ 0,32.

22
00:01:11,660 --> 00:01:14,200
Така че ние се питаме,
можем да използваме една четвърт?

23
00:01:14,200 --> 00:01:15,560
Е, да можем.

24
00:01:15,560 --> 00:01:19,720
Така че сега ние само ги знам
$ 0,07, и ние използвахме една монета.

25
00:01:19,720 --> 00:01:20,970
>> Можем ли да използваме друг квартал?

26
00:01:20,970 --> 00:01:21,890
Е, не.

27
00:01:21,890 --> 00:01:27,570
$ 0,07 е по-малко от $ 0,25, така че ние се процедира
на следващия по големина монетата разположение.

28
00:01:27,570 --> 00:01:30,690
Dimes са на стойност $ 0,10, и
отново, ние не може да използва десетки цента.

29
00:01:30,690 --> 00:01:35,480
Защото Dimes са на стойност $ 0,10, което
е по-малък от размера на промяна дължи.

30
00:01:35,480 --> 00:01:36,790
>> Ходим петачета.

31
00:01:36,790 --> 00:01:40,890
И, да наистина, $ 0,05 е по-малко от
$ 0.10-- така че ние може да се използва никел.

32
00:01:40,890 --> 00:01:46,104
Така че сега ние само дължа на потребителя $ 0,02,
и ние сме толкова далеч използва две монети.

33
00:01:46,104 --> 00:01:47,270
Ние не може да се използва друг никел.

34
00:01:47,270 --> 00:01:51,140
Така че след това се пристъпва към последната монета в
наше разположение, които са стотинките.

35
00:01:51,140 --> 00:01:52,270
>> И можем да използваме стотинка?

36
00:01:52,270 --> 00:01:59,060
Е, yes-- и ние в крайна сметка с помощта на две
пенита за общо четири монети.

37
00:01:59,060 --> 00:02:01,430
>> След като сте готови, за
програма ще изглежда по този начин.

38
00:02:01,430 --> 00:02:03,710
След като потребителят управлява
алчни програма, те ще

39
00:02:03,710 --> 00:02:07,270
бъдете подканени да даде сумата на
промяна в долари, че те са дължими.

40
00:02:07,270 --> 00:02:11,140
И тогава вашата програма ще изведе
минималният размер на монети

41
00:02:11,140 --> 00:02:14,740
че алчни касата ще използва
да се направи, че стойността на промяната.

42
00:02:14,740 --> 00:02:18,160
>> Така че сега нека да се разбие
надолу в нашите подзадачи.

43
00:02:18,160 --> 00:02:21,410
Първо ние ще подкани ни
потребител за сума от промяна.

44
00:02:21,410 --> 00:02:25,630
И, както при всеки вход от потребителя, ние искаме да
уверете се, че ние потвърдим, че вход

45
00:02:25,630 --> 00:02:29,360
и да се гарантира, че можем да използваме, че
вход за останалата част от нашата програма.

46
00:02:29,360 --> 00:02:32,480
След това ние ще винаги
използвате възможно най-голямата точка

47
00:02:32,480 --> 00:02:35,240
и да следите на монетите, използвани.

48
00:02:35,240 --> 00:02:39,080
И най-накрая, отпечатване на финала
брой монети, които се използват.

49
00:02:39,080 --> 00:02:40,970
>> Така че нека да говорим за напомняне.

50
00:02:40,970 --> 00:02:43,550
Сумата трябва да се направи цента,
и това е в долари.

51
00:02:43,550 --> 00:02:48,440
И така в продължение на долара, отиваме
да използвате тип плувка променлива.

52
00:02:48,440 --> 00:02:52,390
Сега, когато ви задам един потребител за вход,
вие искате да се уверите, че това е валидно.

53
00:02:52,390 --> 00:02:56,640
И така, тук сме искали да се възползваме
на линия конструкт направи-а.

54
00:02:56,640 --> 00:03:00,320
>> А да не се прави, докато линия ще изпълни
тялото на цикъла най-малко веднъж.

55
00:03:00,320 --> 00:03:01,650
Така че това е по-удобен.

56
00:03:01,650 --> 00:03:05,510
Ние знаем, че ние трябва да се промпт
потребителя най-малко веднъж на плувка.

57
00:03:05,510 --> 00:03:07,100
Сега, ако това плувка е валиден.

58
00:03:07,100 --> 00:03:07,710
Това е страхотно.

59
00:03:07,710 --> 00:03:08,460
Ние се премине.

60
00:03:08,460 --> 00:03:11,910
Но ако не, цикълът ще се гарантира,
че ние получите правилното плувка

61
00:03:11,910 --> 00:03:16,810
чрез повтаряне непрекъснато, докато
потребителят ни дава валидна стойност.

62
00:03:16,810 --> 00:03:18,760
>> Сега за да не се прави докато
състояние линия, ние се нуждаем от

63
00:03:18,760 --> 00:03:22,000
да се помисли какво означава
да има невалиден плувка.

64
00:03:22,000 --> 00:03:24,220
Така контекста на
този проблем, вероятно

65
00:03:24,220 --> 00:03:27,450
че има смисъл само, за да
приемам положителни стойности.

66
00:03:27,450 --> 00:03:32,010
>> Така че се движат on-- сме получили
стойност в долари от страна на потребителя.

67
00:03:32,010 --> 00:03:35,380
Но си имаме работа с монети,
които са изцяло в цента.

68
00:03:35,380 --> 00:03:38,660
$ 1 е равно на 100 цента.

69
00:03:38,660 --> 00:03:43,670
Така че по-добре да се направи, е да се
конвертирате тези стойности в цента.

70
00:03:43,670 --> 00:03:48,380
>> Сега при конвертиране от един поплавък
до цяло число, така долара до цента,

71
00:03:48,380 --> 00:03:52,230
ние искаме да сме сигурни, че сте внимателни
за плаваща запетая неточност.

72
00:03:52,230 --> 00:03:55,260
Така че това означава, че that-- каже
моя долар value-- ми плувка

73
00:03:55,260 --> 00:04:00,260
value-- беше още $ 2, все още
могат да бъдат някои бездомни номера в там.

74
00:04:00,260 --> 00:04:04,590
Така че ние искаме да се уверите, че не само
можем да се умножи по 100, за да получите най-цента,

75
00:04:04,590 --> 00:04:06,480
но ние също го закръглят.

76
00:04:06,480 --> 00:04:09,210
>> Така че сега ние имаме сумата
на климата, дължима от потребителя.

77
00:04:09,210 --> 00:04:13,430
Ние първоначално е получила в долари,
и сега сме го превръща в цента.

78
00:04:13,430 --> 00:04:17,029
Така че сега ние можем да се пристъпи към сърцето на
алчни алгоритъм, който е винаги

79
00:04:17,029 --> 00:04:19,220
използване на възможно най-голяма монета.

80
00:04:19,220 --> 00:04:21,930
Докато ние правим това,
това е важно, че ние също

81
00:04:21,930 --> 00:04:25,360
да следите колко монети са
ще бъдат върнати на потребителя

82
00:04:25,360 --> 00:04:28,630
както и останалите
промените, дължима от потребителя.

83
00:04:28,630 --> 00:04:31,130
>> Програмата ще изглежда
нещо като това.

84
00:04:31,130 --> 00:04:34,190
След като получите сумата на
долара и конвертирате, че да цента,

85
00:04:34,190 --> 00:04:35,790
а след това ще влезе в цикъл.

86
00:04:35,790 --> 00:04:38,400
Докато могат да бъдат четвърти
used-- тоест

87
00:04:38,400 --> 00:04:43,660
докато стойността на промяната, дължими на
потребител е по-голямо от или равно на 0,25 $,

88
00:04:43,660 --> 00:04:45,040
ще използвате една четвърт.

89
00:04:45,040 --> 00:04:47,000
>> Сега това, което прави, използвайки една четвърт доведе?

90
00:04:47,000 --> 00:04:51,280
Е, one-- ще се увеличи на монетата
разчита да се връща на потребителя.

91
00:04:51,280 --> 00:04:55,890
И второ, че ще намали тока
размер на промяна дължи обратно на потребителя

92
00:04:55,890 --> 00:04:57,520
от $ 0,25.

93
00:04:57,520 --> 00:05:00,680
>> След повтаряне, че докато
квартали вече не могат да бъдат използвани,

94
00:05:00,680 --> 00:05:04,630
пристъпи към следващата по големина
coin-- в този случай Dimes, $ 0,10.

95
00:05:04,630 --> 00:05:07,750
Така че ще влиза, че цикъл, докато
вие вече не може да използва десетки цента.

96
00:05:07,750 --> 00:05:10,720
След това преминете към следващата
най-голямата монета, петачета.

97
00:05:10,720 --> 00:05:14,810
След петачета вече не могат да бъдат използвани,
използвате останалата част от сумата в пари.

98
00:05:14,810 --> 00:05:17,800
И най-накрая, отпечатване на
брой монети използва.

99
00:05:17,800 --> 00:05:20,350
>> Друг начин, по който можете да
доближава до алчни проблема

100
00:05:20,350 --> 00:05:22,950
е да се използва подхода на модул.

101
00:05:22,950 --> 00:05:25,690
Modulo е оператор
че се връща остатъка

102
00:05:25,690 --> 00:05:27,680
на разделението между две числа.

103
00:05:27,680 --> 00:05:30,270
Да речем, имах 50 мод 5.

104
00:05:30,270 --> 00:05:34,070
Е, 5 е фактор 50,
така остатъка ще бъде 0.

105
00:05:34,070 --> 00:05:39,230
50 мод 10-- добре, 10 също е фактор
50, така че останалата част е 0.

106
00:05:39,230 --> 00:05:43,660
50 мод 50-- добре, всеки брой самия мод
няма да имат всички остатъци.

107
00:05:43,660 --> 00:05:45,510
>> Какво ще кажете за 50 мод 49?

108
00:05:45,510 --> 00:05:47,910
Е, 49 отива само в 50 веднъж.

109
00:05:47,910 --> 00:05:50,290
Така че остатъка ще бъде 1.

110
00:05:50,290 --> 00:05:55,180
53 мод 50 ще
ви даде остатък от 3.

111
00:05:55,180 --> 00:05:59,120
>> И така, как можем да използваме по модул
и може би някои разделение

112
00:05:59,120 --> 00:06:01,690
за изпълнение на нашия алчен алгоритъм?

113
00:06:01,690 --> 00:06:05,550
Е, ние все още искат да останат верни на
Сърцето на алчните algorithm-- че

114
00:06:05,550 --> 00:06:07,910
е с помощта на възможно най-голямата монета.

115
00:06:07,910 --> 00:06:14,570
>> Така че нека да се запитаме дали ние можем да използваме всеки
квартали, за да се върнат $ 0,32 до потребителя.

116
00:06:14,570 --> 00:06:20,070
Е, 32 мод 25 дава
ни остатък от $ 0,07.

117
00:06:20,070 --> 00:06:24,500
Така че ни казва, че ние определено може да
използват една четвърт с $ 0,07 оставащото.

118
00:06:24,500 --> 00:06:26,180
>> Можем ли тогава използвайте Dimes?

119
00:06:26,180 --> 00:06:32,740
Е, no-- защото $ 0,07 мод
$ 0,10 ни дава остатък от 7.

120
00:06:32,740 --> 00:06:34,960
10 не влиза в 7 изобщо.

121
00:06:34,960 --> 00:06:36,390
>> След това можем да използваме петачета?

122
00:06:36,390 --> 00:06:40,490
Е $ 0,07 мод 5 цента
дава ни двамата останали.

123
00:06:40,490 --> 00:06:42,930
И накрая, можем да използваме някакви пари?

124
00:06:42,930 --> 00:06:45,930
2 мод 1 ни дава 0,
което е в крайна сметка това, което

125
00:06:45,930 --> 00:06:48,160
ние искаме, защото след това, че
означава, че сме се завръща

126
00:06:48,160 --> 00:06:50,160
за потребителя всичко на промяната дължи.

127
00:06:50,160 --> 00:06:54,320
>> Така че сега имате два възможни начини за
прилагане на алчни algorithm--

128
00:06:54,320 --> 00:06:59,230
един с вериги и един с
комбинация от модул и разделение.

129
00:06:59,230 --> 00:07:03,010
Така че най-накрая, ние просто трябва да се
отпечатване на окончателния брой на монети.

130
00:07:03,010 --> 00:07:06,520
>> Ако исках да ви, че имах кажа
3 домашни любимци и тази стойност е кодиран,

131
00:07:06,520 --> 00:07:09,240
тогава бих могъл просто да се използва
прост изявление тест печат.

132
00:07:09,240 --> 00:07:12,320
Но нашата стойност е действително
съхранява в променлива.

133
00:07:12,320 --> 00:07:15,260
Е, как да печатате на
ценности, съхранявани в променливи?

134
00:07:15,260 --> 00:07:17,880
>> За това ние приемаме
предимство на контейнери.

135
00:07:17,880 --> 00:07:21,540
Да речем, че вече е обявил
подготвен за число п.

136
00:07:21,540 --> 00:07:25,170
След това по-късно, ако исках да отпечатате, че
стойност, тогава аз ще пиша на низа.

137
00:07:25,170 --> 00:07:30,500
И вместо тази стойност бих използвал
контейнер за които integer--% аз.

138
00:07:30,500 --> 00:07:33,800
Тогава, след низа, имам
запетая, последвано от променливата

139
00:07:33,800 --> 00:07:34,950
че искам да отпечатате.

140
00:07:34,950 --> 00:07:38,550
И по-късно, когато се отпечата,
той ще отпечата стойността на п.

141
00:07:38,550 --> 00:07:41,570
>> Аз също може да се използва контейнер
за поплавък, например.

142
00:07:41,570 --> 00:07:44,000
Ако исках да ви кажа как
много пари имам в джоба си,

143
00:07:44,000 --> 00:07:46,820
След това мога да кажа, че има% F долара.

144
00:07:46,820 --> 00:07:51,330
И по-късно, когато се отпечата, тогава п ще
заеме мястото на този притежател на място.

145
00:07:51,330 --> 00:07:55,530
Аз също може, например, да се използва няколко
Запазено място за няколко променливи.

146
00:07:55,530 --> 00:07:57,590
Така че, докато съм се изброят
ги в ред, тогава аз

147
00:07:57,590 --> 00:08:00,390
мога да ви кажа колко
кучета и котки, които имам.

148
00:08:00,390 --> 00:08:03,710
>> Сега ние знаем как да промпт
потребител за сума от промяна,

149
00:08:03,710 --> 00:08:06,130
гарантира, че вход
е валидно, и тогава ние

150
00:08:06,130 --> 00:08:10,370
има два възможни начина на прилагане
алчни алгоритъм на винаги използвайки

151
00:08:10,370 --> 00:08:12,090
възможно най-голямата монета.

152
00:08:12,090 --> 00:08:15,050
Тъй като ние сме следили
колко монети, което използваме,

153
00:08:15,050 --> 00:08:19,210
тогава можем да отпечатате тази стойност в края,
съобщи на потребителя колко монети те са

154
00:08:19,210 --> 00:08:20,240
да се върна.

155
00:08:20,240 --> 00:08:24,240
>> Моето име е Amayla, и това е CS50.

156
00:08:24,240 --> 00:08:25,915

