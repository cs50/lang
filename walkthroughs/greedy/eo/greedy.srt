1
00:00:00,000 --> 00:00:00,710

2
00:00:00,710 --> 00:00:02,900
>> Ni ricevas avidaj.

3
00:00:02,900 --> 00:00:06,810
En avida, nia tasko estas ludi
la rolo de avara kasisto.

4
00:00:06,810 --> 00:00:09,750
La uzanto rakontos nin kiel
multe ŝanĝon ni ŝuldas ilin,

5
00:00:09,750 --> 00:00:13,520
kaj tiam nia tasko estas kalkuli
la minimuma nombro da moneroj

6
00:00:13,520 --> 00:00:17,240
ke ni povas uzi por fari
tiu kvanto de ŝanĝiĝo.

7
00:00:17,240 --> 00:00:19,560
>> Komencu kun ekzemplo.

8
00:00:19,560 --> 00:00:23,170
Diri la uzanto postulas $ 0.32 reen.

9
00:00:23,170 --> 00:00:28,960
Ni povus fari tion donante
ilin 32 pencoj, unu cendo ĉiu.

10
00:00:28,960 --> 00:00:35,180
Aŭ mi povus ankaŭ uzi kvin coins-- per
donante ilin tri dimes, $ 0.10 ĉiu,

11
00:00:35,180 --> 00:00:38,060
kaj du pencoj, $ 0.02 ĉiu.

12
00:00:38,060 --> 00:00:42,580
Sed ni povus uzi eĉ
malpli moneroj fari tiun?

13
00:00:42,580 --> 00:00:45,100
>> La tuta taktiko en greedy--
esti avidaj cashier--

14
00:00:45,100 --> 00:00:47,600
estas uzi la plej granda monero eble.

15
00:00:47,600 --> 00:00:50,670
Do kiam ajn ni havas
kvaronoj ni uzos ilin.

16
00:00:50,670 --> 00:00:54,100
Kaj tiam iam tiuj elĉerpas,
ni uzos dimes, $ 0.10 ĉiu.

17
00:00:54,100 --> 00:00:58,840
Tiam Nickels, 5 cendoj ĉiu, kaj
tiam malsupren al pencoj, unu cendo ĉiu.

18
00:00:58,840 --> 00:01:01,792
Uzante la plej granda monero
ebla kiam ajn eble,

19
00:01:01,792 --> 00:01:07,350
ni certigi ke ni uzu la plej malmultaj nombro
de moneroj eblas fari la ŝanĝon.

20
00:01:07,350 --> 00:01:09,180
>> Do ni iradas ĉi tra.

21
00:01:09,180 --> 00:01:11,660
La uzanto bezonas $ 0.32.

22
00:01:11,660 --> 00:01:14,200
Tial oni demandas sin,
ni povas uzi kvarono?

23
00:01:14,200 --> 00:01:15,560
Nu, jes ni povas.

24
00:01:15,560 --> 00:01:19,720
Do nun ni nur konas ilin
$ 0.07, kaj ni uzis unu monero.

25
00:01:19,720 --> 00:01:20,970
>> Ni povas uzi alian kvaronon?

26
00:01:20,970 --> 00:01:21,890
Nu, ne.

27
00:01:21,890 --> 00:01:27,570
$ 0.07 malpli ol $ 0.25, tiel ni procedi
al la sekva plej granda monero havebla.

28
00:01:27,570 --> 00:01:30,690
Dimes estas $ 0.10, kaj
denove, ni ne povas uzi dimes.

29
00:01:30,690 --> 00:01:35,480
Ĉar dimes valoras $ 0.10, kio
estas pli ol la kvanto de ŝanĝo ŝuldita.

30
00:01:35,480 --> 00:01:36,790
>> Ni iru Nickels.

31
00:01:36,790 --> 00:01:40,890
Kaj, jes ja, $ 0.05 malpli ol
$ 0.10-- do ni povas uzi nikelo.

32
00:01:40,890 --> 00:01:46,104
Do nun ni nur ŝuldas la uzanto $ 0.02,
kaj ni ĝis nun uzis du moneroj.

33
00:01:46,104 --> 00:01:47,270
Ni ne povas uzi alian nikelo.

34
00:01:47,270 --> 00:01:51,140
Tial ni eliru al la lasta monero ĉe
nia dispono, kiuj estas la moneroj.

35
00:01:51,140 --> 00:01:52,270
>> Kaj ni povas uzi denaro?

36
00:01:52,270 --> 00:01:59,060
Nu, yes-- kaj ni finas uzante du
pencoj por totalo de kvar moneroj.

37
00:01:59,060 --> 00:02:01,430
>> Unufoje vi finis, la
programo similos tion.

38
00:02:01,430 --> 00:02:03,710
Iam la uzanto kuras la
avidaj programo, ili timige

39
00:02:03,710 --> 00:02:07,270
petata doni la kvanto de
ŝanĝo en dolaroj ke ili estas ŝuldita.

40
00:02:07,270 --> 00:02:11,140
Kaj tiam via programo volo eligo
la minimuma kvanto de moneroj

41
00:02:11,140 --> 00:02:14,740
ke la avidaj kasisto uzus
fari ke kvanto de ŝanĝo.

42
00:02:14,740 --> 00:02:18,160
>> Do nun ni rompos ĉi
malsupren en nian subtareas.

43
00:02:18,160 --> 00:02:21,410
Unua ni tuj instigas niajn
uzanto por kvanto de ŝanĝo.

44
00:02:21,410 --> 00:02:25,630
Kaj, kiel kun ajna uzanto enigo, ni volas
certigi ke ni validigi ke enigo

45
00:02:25,630 --> 00:02:29,360
kaj certigi ke ni povas uzi tiun
enigo por la resto de nia programo.

46
00:02:29,360 --> 00:02:32,480
Tiam ni tuj ĉiam
uzi la plej grandan punkton ebla

47
00:02:32,480 --> 00:02:35,240
kaj sekvigi la moneroj uzataj.

48
00:02:35,240 --> 00:02:39,080
Kaj fine, montri la finan
numeron de moneroj kiujn ni uzas.

49
00:02:39,080 --> 00:02:40,970
>> Do ni parolu pri instigante.

50
00:02:40,970 --> 00:02:43,550
La kvanto devas fari cendoj,
kaj tio estas en dolaroj.

51
00:02:43,550 --> 00:02:48,440
Kaj tiel por dolaroj, ni tuj
uzi la kaleŝego variablo tipo.

52
00:02:48,440 --> 00:02:52,390
Nun kiam vi demandas uzanto por enigo,
Vi volas certigi ke ĝi estas valida.

53
00:02:52,390 --> 00:02:56,640
Kaj tiel tie ni ŝatus utiligi
de la do-dum buklo konstruo.

54
00:02:56,640 --> 00:03:00,320
>> Al do-dum buklo ekzekutos la
korpo de la ciklo almenaŭ unufoje.

55
00:03:00,320 --> 00:03:01,650
Do ĉi venas en oportuna.

56
00:03:01,650 --> 00:03:05,510
Ni scias ke ni devas instigi la
uzanto almenaŭ unufoje por kaleŝego.

57
00:03:05,510 --> 00:03:07,100
Nun se kiu flosas validas.

58
00:03:07,100 --> 00:03:07,710
Tio estas granda.

59
00:03:07,710 --> 00:03:08,460
Ni pluiru.

60
00:03:08,460 --> 00:03:11,910
Sed se ne, la buklo certigos
ke ni ricevos konvenan kaleŝego

61
00:03:11,910 --> 00:03:16,810
ripetante senĉese ĝis
la uzanto donas al ni validan valoron.

62
00:03:16,810 --> 00:03:18,760
>> Nun por la do-dum
buklo kondiĉo, ni bezonas

63
00:03:18,760 --> 00:03:22,000
konsideri kion signifas
havas nevalidan kaleŝego.

64
00:03:22,000 --> 00:03:24,220
Tiel por la kunteksto de
tiu problemo, probable

65
00:03:24,220 --> 00:03:27,450
ĝi havas sencon nur por
akcepti pozitivaj valoroj.

66
00:03:27,450 --> 00:03:32,010
>> Do movi on-- ni akiris
valoro en dolaroj de la uzanto.

67
00:03:32,010 --> 00:03:35,380
Sed ni pritraktas moneroj,
kiu estas tute en cendoj.

68
00:03:35,380 --> 00:03:38,660
$ 1 estas ekvivalenta al 100 cendoj.

69
00:03:38,660 --> 00:03:43,670
Tiel bona afero fari estas
konverti tiujn valorojn en cendoj.

70
00:03:43,670 --> 00:03:48,380
>> Nun kiam konvertanta de kaleŝego
por entjero, do dolaroj al cendoj,

71
00:03:48,380 --> 00:03:52,230
Ni volas certigi ke ni estas zorgema
pri punkto flotante imprecision.

72
00:03:52,230 --> 00:03:55,260
Do tio signifas that-- diri
mian dolaron value-- mia kaleŝego

73
00:03:55,260 --> 00:04:00,260
value-- estis eĉ $ 2, ekzistas ankoraŭ
Eble iuj devagaj nombroj en tie.

74
00:04:00,260 --> 00:04:04,590
Do ni volas certigi, ke ne nur
ni multipliki per 100 por akiri la cendojn,

75
00:04:04,590 --> 00:04:06,480
sed ni ankaŭ cxirkauxtondu ĝin.

76
00:04:06,480 --> 00:04:09,210
>> Do nun ni havas la kvanton
de ŝanĝo ŝuldita al la uzanto.

77
00:04:09,210 --> 00:04:13,430
Ni origine akiris ĝin en dolaroj,
kaj nun ni konvertis ĝin al cendoj.

78
00:04:13,430 --> 00:04:17,029
Do nun ni povas procedi kun la koro de
la avida algoritmo, kiu estas ĉiam

79
00:04:17,029 --> 00:04:19,220
uzante la plej granda monero eble.

80
00:04:19,220 --> 00:04:21,930
Dum ni faras tion,
ĝi estas esenca ke ni ankaŭ

81
00:04:21,930 --> 00:04:25,360
sekvigi kiom moneroj estas
tuj revenos al la uzanto

82
00:04:25,360 --> 00:04:28,630
krom la ceteraj
ŝanĝi ŝuldis al la uzanto.

83
00:04:28,630 --> 00:04:31,130
>> La programo aspektos
io tiamaniere.

84
00:04:31,130 --> 00:04:34,190
Post vi ricevas la kvanton de
dolaroj kaj konverti ke al cendoj,

85
00:04:34,190 --> 00:04:35,790
tiam vi eniras banton.

86
00:04:35,790 --> 00:04:38,400
Dum kvaronoj povas esti
used-- tio estas

87
00:04:38,400 --> 00:04:43,660
dum la kvanto de ŝanĝo ŝuldita al la
uzanto estas pli granda ol aŭ egala al $ 0.25,

88
00:04:43,660 --> 00:04:45,040
vi uzos kvarono.

89
00:04:45,040 --> 00:04:47,000
>> Kion faras uzante kvarono kunportas?

90
00:04:47,000 --> 00:04:51,280
Nu, one-- vi pliigi la monero
kalkuli esti resendita al la uzanto.

91
00:04:51,280 --> 00:04:55,890
Kaj duan vi malpliigi la aktualan
kvanto de ŝanĝo ŝuldita al la uzanto

92
00:04:55,890 --> 00:04:57,520
de $ 0.25.

93
00:04:57,520 --> 00:05:00,680
>> Post ripeti ke ĝis
kvaronoj ne plu povas esti uzataj,

94
00:05:00,680 --> 00:05:04,630
procedi al la sekva plej granda
coin-- tiukaze dimes, $ 0.10.

95
00:05:04,630 --> 00:05:07,750
Tiel vi eniru ke buklo ĝis
vi ne plu povas uzi dimes.

96
00:05:07,750 --> 00:05:10,720
Tiam procedi al la sekvanta
plej granda monero, Nickels.

97
00:05:10,720 --> 00:05:14,810
Post Nickels ne plu povas esti uzataj,
uzi la restanta kvanto en pencoj.

98
00:05:14,810 --> 00:05:17,800
Kaj fine, montri la
numeron de moneroj uzataj.

99
00:05:17,800 --> 00:05:20,350
>> Alia vojo ke vi povas
alproksimigi la avidaj problemo

100
00:05:20,350 --> 00:05:22,950
estas uzi la module alproksimiĝo.

101
00:05:22,950 --> 00:05:25,690
Module estas operatoro
ke redonas la reston

102
00:05:25,690 --> 00:05:27,680
de la divido inter du nombroj.

103
00:05:27,680 --> 00:05:30,270
Diru mi havis 50 mod 5.

104
00:05:30,270 --> 00:05:34,070
Nu, 5 estas faktoro de 50,
tial la resto estos 0.

105
00:05:34,070 --> 00:05:39,230
50 mod 10-- bone, 10 estas ankaŭ faktoro
de 50, tial la resto estas ankaŭ 0.

106
00:05:39,230 --> 00:05:43,660
50 mod 50-- bone, ajna nombro mod mem
ne tuj havos neniun reston.

107
00:05:43,660 --> 00:05:45,510
>> Kio pri 50 mod 49?

108
00:05:45,510 --> 00:05:47,910
Nu, 49 nur iras en 50 iam.

109
00:05:47,910 --> 00:05:50,290
Do la resto estas iranta esti 1.

110
00:05:50,290 --> 00:05:55,180
53 mod 50 tuj
al vi restaĵo de 3.

111
00:05:55,180 --> 00:05:59,120
>> Do kiel ni povas uzi module
kaj eble iu divido

112
00:05:59,120 --> 00:06:01,690
apliki niajn avidaj algoritmo?

113
00:06:01,690 --> 00:06:05,550
Nu, ni ankoraŭ volas resti fidela al la
koro de la avara algorithm-- ke

114
00:06:05,550 --> 00:06:07,910
estas uzanta la plej granda monero eble.

115
00:06:07,910 --> 00:06:14,570
>> Do ni demandos nin se ni povas uzi ajnan
kvaronoj reveni $ 0.32 por la uzanto.

116
00:06:14,570 --> 00:06:20,070
Nu, 32 mod 25 donas
ni restaĵo de $ 0.07.

117
00:06:20,070 --> 00:06:24,500
Por ke nin diras ke ni povas definitive
uzi unu kvarono kun $ 0.07 ceteraj.

118
00:06:24,500 --> 00:06:26,180
>> Ni povas tiam uzi ajnan dimes?

119
00:06:26,180 --> 00:06:32,740
Nu, no-- ĉar $ 0.07 mod
$ 0.10 al ni restaĵo de 7.

120
00:06:32,740 --> 00:06:34,960
10 eniras ne en 7 entute.

121
00:06:34,960 --> 00:06:36,390
>> Tiam ni povas uzi Nickels?

122
00:06:36,390 --> 00:06:40,490
Nu $ 0.07 mod 5 cendoj
donas al ni du ceteraj.

123
00:06:40,490 --> 00:06:42,930
Kaj laste, ni povas uzi ajnan pencoj?

124
00:06:42,930 --> 00:06:45,930
2 mod 1 donas ni 0:
kiu estas finfine kio

125
00:06:45,930 --> 00:06:48,160
ni volas ĉar tiam ke
signifas ke ni revenis

126
00:06:48,160 --> 00:06:50,160
al la uzanto ĉiuj ŝanĝo ŝuldita.

127
00:06:50,160 --> 00:06:54,320
>> Do nun vi havas du eblajn manierojn
efektiviganta la avidaj algorithm--

128
00:06:54,320 --> 00:06:59,230
kun maŝojn kaj unu kun
kombino de module kaj divido.

129
00:06:59,230 --> 00:07:03,010
Do fine, ni nur bezonas
presi la fina nombro de moneroj.

130
00:07:03,010 --> 00:07:06,520
>> Se mi volis diri al vi, ke mi havis
3 dorlotbestoj kaj tiu valoro estis hardcoded,

131
00:07:06,520 --> 00:07:09,240
tiam mi povus simple uzi
simpla print testo komunikaĵo.

132
00:07:09,240 --> 00:07:12,320
Sed nia valoro estas fakte
stokitaj en variablo.

133
00:07:12,320 --> 00:07:15,260
Do kiel vi presi la
valoroj stokitaj en variabloj?

134
00:07:15,260 --> 00:07:17,880
>> Por tio ni preni
avantaĝo de anstataŭaĵojn.

135
00:07:17,880 --> 00:07:21,540
Diri Mi jam deklaris
an inicializado entjero n.

136
00:07:21,540 --> 00:07:25,170
Tiam poste se mi volis printi ke
valoro, tiam mi skribus la kordo.

137
00:07:25,170 --> 00:07:30,500
Kaj anstataŭ ke valoro mi uzus
lokokupilo por ke integer--% i.

138
00:07:30,500 --> 00:07:33,800
Tiam post la ligilo, mi havas
komo, sekvita de la variablo

139
00:07:33,800 --> 00:07:34,950
ke mi volas presi.

140
00:07:34,950 --> 00:07:38,550
Kaj poste, kiam ĝi presas,
ĝi devos presi la valoro de n.

141
00:07:38,550 --> 00:07:41,570
>> Mi povus ankaŭ uzi lokokupilo
por kaleŝego, ekzemple.

142
00:07:41,570 --> 00:07:44,000
Se mi volis diri al vi kiom
multa mono mi havas en mia poŝo,

143
00:07:44,000 --> 00:07:46,820
tiam mi povus diri ke mi havas% f dolaroj.

144
00:07:46,820 --> 00:07:51,330
Kaj poste kiam presas, tiam n volas
preni la lokon de tiu loko posedanto.

145
00:07:51,330 --> 00:07:55,530
Mi povus ankaŭ, ekzemple, uzi pluraj
anstataŭaĵojn por pluraj variabloj.

146
00:07:55,530 --> 00:07:57,590
Do, dum mi listo
ilin en ordo, tiam mi

147
00:07:57,590 --> 00:08:00,390
povas diri al vi kiom da
hundoj kaj katoj mi.

148
00:08:00,390 --> 00:08:03,710
>> Nun ni scias kiel instigas la
uzanto por kvanto de ŝanĝo,

149
00:08:03,710 --> 00:08:06,130
certigi ke tiu enigo
validas, kaj poste ni

150
00:08:06,130 --> 00:08:10,370
havas du eblaj manieroj de implementar
la avida algoritmo de ĉiam uzi

151
00:08:10,370 --> 00:08:12,090
la plej granda monero eble.

152
00:08:12,090 --> 00:08:15,050
Ĉar ni konservis spuron de
kiom da moneroj ni uzas,

153
00:08:15,050 --> 00:08:19,210
ni tiam povas presi tiu valoro ĉe la fino,
dirante al la uzanto kiom da moneroj ili estas

154
00:08:19,210 --> 00:08:20,240
reatingas.

155
00:08:20,240 --> 00:08:24,240
>> Mia nomo estas Amayla, kaj ĉi tiu estas CS50.

156
00:08:24,240 --> 00:08:25,915

