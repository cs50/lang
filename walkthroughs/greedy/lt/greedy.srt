1
00:00:00,000 --> 00:00:00,710

2
00:00:00,710 --> 00:00:02,900
>> Leiskite gauti gobšus.

3
00:00:02,900 --> 00:00:06,810
Be gobšus, mūsų darbas yra žaisti
iš gobšus kasininko vaidmenį.

4
00:00:06,810 --> 00:00:09,750
Vartotojas mums pasakyti, kaip
daug pokyčių mes skolingi jiems,

5
00:00:09,750 --> 00:00:13,520
ir tada mūsų darbas yra apskaičiuoti
minimalus skaičius monetų

6
00:00:13,520 --> 00:00:17,240
kad mes galime naudoti, kad
kad pokyčio sumą.

7
00:00:17,240 --> 00:00:19,560
>> Pradėkime pavyzdys.

8
00:00:19,560 --> 00:00:23,170
Pasakykite vartotojas reikalauja 0,32 $ atgal.

9
00:00:23,170 --> 00:00:28,960
Mes galime tai padaryti, suteikiant
jiems 32 centus, vienu centu kiekvienam.

10
00:00:28,960 --> 00:00:35,180
Arba aš taip pat galėtų naudoti penkis coins-- iki
suteikiant jiems tris dimes, kiekvienas $ 0.10

11
00:00:35,180 --> 00:00:38,060
ir du centus, kiekvienas $ 0,02.

12
00:00:38,060 --> 00:00:42,580
Bet ar mes naudojame net
mažiau monetų padaryti, kad?

13
00:00:42,580 --> 00:00:45,100
>> Visa taktika greedy--
būti godus cashier--

14
00:00:45,100 --> 00:00:47,600
yra naudoti prie didžiausios monetos įmanoma.

15
00:00:47,600 --> 00:00:50,670
Taigi, jei mes turime
ketvirčius mes juos naudoti.

16
00:00:50,670 --> 00:00:54,100
Ir tada, kai tie baigsis,
mes naudosime dimes, kiekviena 0,10 $.

17
00:00:54,100 --> 00:00:58,840
Tada Nickels, 5 centų už kiekvieną, ir
tada žemyn į centus, vienu centu kiekvienam.

18
00:00:58,840 --> 00:01:01,792
Naudojant didžiausią monetą
įmanoma, kai galime,

19
00:01:01,792 --> 00:01:07,350
mes užtikriname, kad mes naudojame mažiausią skaičių
monetų įmanoma, kad pakeisti.

20
00:01:07,350 --> 00:01:09,180
>> Taigi leiskite eiti tai per.

21
00:01:09,180 --> 00:01:11,660
Vartotojas turi 0,32 $.

22
00:01:11,660 --> 00:01:14,200
Taigi, mes klausiame savęs,
mes galime naudoti ketvirtį?

23
00:01:14,200 --> 00:01:15,560
Na, taip, mes galime.

24
00:01:15,560 --> 00:01:19,720
Taigi dabar mes tik žinome, juos
0,07 $, o mes naudojome vieną monetą.

25
00:01:19,720 --> 00:01:20,970
>> Ar mes galime naudoti kitą ketvirtį?

26
00:01:20,970 --> 00:01:21,890
Na, ne.

27
00:01:21,890 --> 00:01:27,570
0,07 $ yra mažiau nei $ 0,25, todėl mes pereisime
į kitą didžiausių monetos prieinama.

28
00:01:27,570 --> 00:01:30,690
Monetos yra $ 0.10 ir
vėl, mes negalime naudoti dimes.

29
00:01:30,690 --> 00:01:35,480
Kadangi monetos yra verta $ 0.10, kuris
yra daugiau nei pokyčių mokėtinos sumos.

30
00:01:35,480 --> 00:01:36,790
>> Mes einame į Nickels.

31
00:01:36,790 --> 00:01:40,890
Ir, taip iš tikrųjų, 0,05 $ yra mažiau nei
$ 0.10-- todėl mes galime naudoti nikelio.

32
00:01:40,890 --> 00:01:46,104
Taigi, dabar mes tik skolingas naudotojas $ 0,02,
ir mes iki šiol naudojami du monetas.

33
00:01:46,104 --> 00:01:47,270
Mes negalime naudoti kitą nikelio.

34
00:01:47,270 --> 00:01:51,140
Taigi mes pereisime prie paskutinės monetos ne
mūsų žinioje, kuris yra kapeikos.

35
00:01:51,140 --> 00:01:52,270
>> Ir mes galime naudoti cento?

36
00:01:52,270 --> 00:01:59,060
Na, yes-- ir mes galų gale naudojant du
centus ketverių monetų iš viso.

37
00:01:59,060 --> 00:02:01,430
>> Kai esate baigtas,
programa atrodys taip.

38
00:02:01,430 --> 00:02:03,710
Kai vartotojas "valdo
gobšus programa, jie

39
00:02:03,710 --> 00:02:07,270
paraginti duoti iš sumą
pokytis dolerių, kad jie skolingi.

40
00:02:07,270 --> 00:02:11,140
Ir tada jūsų programa bus išėjimas
minimali suma monetų

41
00:02:11,140 --> 00:02:14,740
kad godus kasininkas būtų naudoti
padaryti, kad pokyčio sumą.

42
00:02:14,740 --> 00:02:18,160
>> Taigi dabar galime padalyti
žemyn į mūsų smulkesnes užduotis.

43
00:02:18,160 --> 00:02:21,410
Pirmiausia mes ketiname greitai mūsų
vartotojas už pokyčių sumos.

44
00:02:21,410 --> 00:02:25,630
Ir, kaip ir su bet naudotojo įvesties, mes norime
įsitikinkite, kad mes patikrinti, kad pirkimo

45
00:02:25,630 --> 00:02:29,360
ir užtikrinti, kad mes galime naudoti, kad
indėlis į mūsų programą poilsio.

46
00:02:29,360 --> 00:02:32,480
Tada mes ketiname visada
naudoti prie didžiausios tašką galimą

47
00:02:32,480 --> 00:02:35,240
ir sekti monetų, naudojamų.

48
00:02:35,240 --> 00:02:39,080
Ir pagaliau, spausdinti galutinis
monetų skaičiaus, kad mes, naudojamų.

49
00:02:39,080 --> 00:02:40,970
>> Taigi pakalbėkime apie raginimo.

50
00:02:40,970 --> 00:02:43,550
Suma turi padaryti centų,
ir tai yra JAV doleriais.

51
00:02:43,550 --> 00:02:48,440
Ir taip dolerių, mes ketiname
naudoti plūdę kintamojo tipą.

52
00:02:48,440 --> 00:02:52,390
Dabar, kai jūs paprašykite vartotoją įvesties,
Jūs norite įsitikinti, kad tai galioja.

53
00:02:52,390 --> 00:02:56,640
Ir todėl čia mes norėtume pasinaudoti
iš Do-while cikle konstruktą.

54
00:02:56,640 --> 00:03:00,320
>> Daug ką, o kilpa vykdys
organas linijos bent vieną kartą.

55
00:03:00,320 --> 00:03:01,650
Taigi tai praverčia.

56
00:03:01,650 --> 00:03:05,510
Mes žinome, kad turime tai paskatins
vartotojas bent vieną kartą plūdės.

57
00:03:05,510 --> 00:03:07,100
Taigi, jei plūdė galioja.

58
00:03:07,100 --> 00:03:07,710
Tai puiku.

59
00:03:07,710 --> 00:03:08,460
Mes judėti.

60
00:03:08,460 --> 00:03:11,910
Bet jei ne, kilpa užtikrins
kad mes gauti tinkamą plūdę

61
00:03:11,910 --> 00:03:16,810
kartojant nuolat, kol
vartotojas suteikia mums galiojantį vertę.

62
00:03:16,810 --> 00:03:18,760
>> Dabar do-o
kilpa sąlyga, turime

63
00:03:18,760 --> 00:03:22,000
apsvarstyti, ką tai reiškia
turėti neteisingą plūdę.

64
00:03:22,000 --> 00:03:24,220
Tokios veiklos kontekste
Ši problema, tikriausiai

65
00:03:24,220 --> 00:03:27,450
prasminga tik
priimti teigiamas vertybes.

66
00:03:27,450 --> 00:03:32,010
>> Taigi juda on-- mes gaunamas
vertė doleriais nuo naudotojo.

67
00:03:32,010 --> 00:03:35,380
Bet mes susiduriame su monetomis,
kurios yra visiškai centų.

68
00:03:35,380 --> 00:03:38,660
$ 1 lygus 100 centų.

69
00:03:38,660 --> 00:03:43,670
Taigi geras dalykas padaryti, tai
konvertuoti šias vertybes į centų.

70
00:03:43,670 --> 00:03:48,380
>> Dabar, kai konvertuoti iš flotacinio
iki sveikojo skaičiaus, todėl dolerių centų,

71
00:03:48,380 --> 00:03:52,230
mes norime įsitikinti, kad mes atsargūs
apie netikslumą slankiojo kablelio.

72
00:03:52,230 --> 00:03:55,260
Taigi tai reiškia, kad that-- pasakyti
Mano doleris value-- mano plūdę

73
00:03:55,260 --> 00:04:00,260
value-- ten buvo net $ 2, dar
Gali būti keletas benamių skaičių ten.

74
00:04:00,260 --> 00:04:04,590
Taigi mes norime įsitikinti, kad ne tik
mes padauginti 100 gauti centų,

75
00:04:04,590 --> 00:04:06,480
bet mes taip pat suapvalinti ant kojų.

76
00:04:06,480 --> 00:04:09,210
>> Taigi dabar mes turime sumą
pokyčių skolingi vartotojui.

77
00:04:09,210 --> 00:04:13,430
Mes iš pradžių gauti jį dolerių,
ir dabar mes konvertuoti jį centų.

78
00:04:13,430 --> 00:04:17,029
Taigi, dabar mes galime pradėti su širdies
gobšus algoritmas, kuris visada yra

79
00:04:17,029 --> 00:04:19,220
naudojant prie didžiausios monetos įmanoma.

80
00:04:19,220 --> 00:04:21,930
Nors mes darome tai,
labai svarbu, kad mes taip pat

81
00:04:21,930 --> 00:04:25,360
sekti, kiek monetų
bus grąžintas vartotojui

82
00:04:25,360 --> 00:04:28,630
taip pat likusi
pakeisti skolingi vartotojui.

83
00:04:28,630 --> 00:04:31,130
>> Programa atrodys
kažkas panašaus į tai.

84
00:04:31,130 --> 00:04:34,190
Po gausite sumą
dolerių ir konvertuoti, kad centais,

85
00:04:34,190 --> 00:04:35,790
tada jums reikės įvesti kilpą.

86
00:04:35,790 --> 00:04:38,400
Nors ketvirtadaliai gali būti
used-- ty

87
00:04:38,400 --> 00:04:43,660
o pokyčio suma skolingi
vartotojas yra didesnis nei arba lygus 0,25 $,

88
00:04:43,660 --> 00:04:45,040
jums naudoti ketvirtį.

89
00:04:45,040 --> 00:04:47,000
>> Dabar ką naudojate ketvirtadalis reiškia?

90
00:04:47,000 --> 00:04:51,280
Na, one-- jums padidinti monetą
suskaičiuokite iki grąžinami vartotojui.

91
00:04:51,280 --> 00:04:55,890
Ir antra jums sumažinti einamosios
suma pokyčių skolinga atgal į vartotojo

92
00:04:55,890 --> 00:04:57,520
iki 0,25 $.

93
00:04:57,520 --> 00:05:00,680
>> Po kartoti, kad iki
ketvirčių nebegali būti naudojamas,

94
00:05:00,680 --> 00:05:04,630
pereiti į kitą dydį
coin-- šiuo atveju dimes, 0,10 $.

95
00:05:04,630 --> 00:05:07,750
Taigi jums įvesti tą kilpą iki
tu nebegali naudotis dimes.

96
00:05:07,750 --> 00:05:10,720
Tada pereikite prie kito
Didžiausias moneta, Nickels.

97
00:05:10,720 --> 00:05:14,810
Po Nickels nebegali būti naudojami,
naudoti likusią sumą į centus.

98
00:05:14,810 --> 00:05:17,800
Ir, pagaliau, išspausdinti
naudojami monetų skaičiaus.

99
00:05:17,800 --> 00:05:20,350
>> Kitas būdas, kad galite
kreiptis į gobšus problemą

100
00:05:20,350 --> 00:05:22,950
yra naudoti Modulo požiūris.

101
00:05:22,950 --> 00:05:25,690
Modulo yra operatorius
kad grąžina likusią

102
00:05:25,690 --> 00:05:27,680
tarp dviejų skaičių pasidalijimas.

103
00:05:27,680 --> 00:05:30,270
Pasakyti, kad aš turėjo 50 mod 5.

104
00:05:30,270 --> 00:05:34,070
Na, 5 yra 50 veiksnys,
todėl likusi bus 0.

105
00:05:34,070 --> 00:05:39,230
50 mod 10-- gerai, 10 taip pat yra veiksnys
of 50, todėl likusi dalis yra taip pat 0.

106
00:05:39,230 --> 00:05:43,660
50 mod 50-- gerai, bet koks skaičius mod save
nesiruošia turėti bet koks likutis.

107
00:05:43,660 --> 00:05:45,510
>> Ką apie 50 mod 49?

108
00:05:45,510 --> 00:05:47,910
Na, 49 eina tik į 50 kartą.

109
00:05:47,910 --> 00:05:50,290
Taigi, likusi dalis bus 1 d.

110
00:05:50,290 --> 00:05:55,180
53 mod 50 ketina
jums 3 dalį.

111
00:05:55,180 --> 00:05:59,120
>> Taigi, kaip mes galime naudoti modulo
o gal kai padalinys

112
00:05:59,120 --> 00:06:01,690
įgyvendinti mūsų gobšus algoritmą?

113
00:06:01,690 --> 00:06:05,550
Na, mes vis dar norime išlikti teisinga
širdis gobšus algorithm-- kad

114
00:06:05,550 --> 00:06:07,910
yra naudojant prie didžiausios monetos įmanoma.

115
00:06:07,910 --> 00:06:14,570
>> Taigi leiskite paklausti savęs, ar mes galime naudoti bet
ketvirčių grįžti $ 0,32 vartotojui.

116
00:06:14,570 --> 00:06:20,070
Na, 32 mod 25 suteikia
mums $ 0,07 likusi.

117
00:06:20,070 --> 00:06:24,500
Taigi, kad mums sako, kad mes galime tikrai
naudoti vieną kėlinį 0,07 $ likę.

118
00:06:24,500 --> 00:06:26,180
>> Ar mes tada naudoti bet kokias dimes?

119
00:06:26,180 --> 00:06:32,740
Na, no-- nes 0,07 $ mod
$ 0,10 suteikia mums 7 dalį.

120
00:06:32,740 --> 00:06:34,960
10 neviršijama į 7 ne visiems.

121
00:06:34,960 --> 00:06:36,390
>> Tada mes galime naudoti Nickels?

122
00:06:36,390 --> 00:06:40,490
Na $ 0.07 mod 5 centai
suteikia mums du likusius.

123
00:06:40,490 --> 00:06:42,930
Ir galiausiai, mes galime naudoti bet kokias centus?

124
00:06:42,930 --> 00:06:45,930
2 Mod 1 suteikia mums 0,
kuri galiausiai ką

125
00:06:45,930 --> 00:06:48,160
mes norime, nes tada
reiškia, kad mes grįžo

126
00:06:48,160 --> 00:06:50,160
vartotojui visą kaitos skolinga.

127
00:06:50,160 --> 00:06:54,320
>> Taigi, dabar jūs turite du galimus būdus
Įgyvendinant gobšus algorithm--

128
00:06:54,320 --> 00:06:59,230
vienas su vyriais ir vienas su
kombinaciją Modulo ir pasidalijimas.

129
00:06:59,230 --> 00:07:03,010
Taigi, pagaliau, mes tiesiog reikia
spausdinti galutinį skaičių monetų.

130
00:07:03,010 --> 00:07:06,520
>> Jei aš norėjau, kad turėjau pasakyti
3 Gyvūnai, ir ši vertė buvo kieta,

131
00:07:06,520 --> 00:07:09,240
tada galėčiau tiesiog naudoti
paprastas spausdinimo testas pareiškimas.

132
00:07:09,240 --> 00:07:12,320
Tačiau mūsų vertė yra iš tikrųjų
saugomi į kintamąjį.

133
00:07:12,320 --> 00:07:15,260
Taigi, kaip jums išspausdinti
vertės saugomi kintamieji?

134
00:07:15,260 --> 00:07:17,880
>> Už tai mes
privalumas yra rezervuotos vietos.

135
00:07:17,880 --> 00:07:21,540
Pasakyti, kad aš jau pareiškė
inicializuoti sveikasis skaičius n.

136
00:07:21,540 --> 00:07:25,170
Tada vėliau, jei aš norėjau spausdinti, kad
vertė, tada rašyčiau eilutę.

137
00:07:25,170 --> 00:07:30,500
Ir vietoj tos vertės Norėčiau naudoti
rezervuota vieta už tą integer--% i.

138
00:07:30,500 --> 00:07:33,800
Tada po eilutę, aš turiu
kableliais, po kurio kintamojo

139
00:07:33,800 --> 00:07:34,950
kad aš noriu spausdinti.

140
00:07:34,950 --> 00:07:38,550
Ir vėliau, kai jis spausdina,
jis bus išspausdinti n vertę.

141
00:07:38,550 --> 00:07:41,570
>> Aš taip pat galėtų naudoti vietos rezervavimo ženklą
dėl plūdės, pavyzdžiui.

142
00:07:41,570 --> 00:07:44,000
Jei aš norėjau pasakyti, kaip
daug pinigų turiu kišenę,

143
00:07:44,000 --> 00:07:46,820
tada galėčiau pasakyti turiu% f dolerių.

144
00:07:46,820 --> 00:07:51,330
Ir vėliau, kai jis spausdina, tai n bus
imtis tos vietos savininkas vietą.

145
00:07:51,330 --> 00:07:55,530
Aš taip pat galėtų, pavyzdžiui, naudoti kelis
pamainymai už kelių kintamųjų.

146
00:07:55,530 --> 00:07:57,590
Taigi, kaip ilgai, kaip aš sąrašas
juos, kad, tada aš

147
00:07:57,590 --> 00:08:00,390
galiu pasakyti, kiek
šunys ir katės turiu.

148
00:08:00,390 --> 00:08:03,710
>> Dabar mes žinome, kaip paskatinti
vartotojas už pokyčio sumą,

149
00:08:03,710 --> 00:08:06,130
užtikrinti, kad tą indėlį
galioja, ir tada mes

150
00:08:06,130 --> 00:08:10,370
turi du galimus būdus, kaip įgyvendinti
gobšus algoritmas visada naudojant

151
00:08:10,370 --> 00:08:12,090
didžiausias moneta įmanoma.

152
00:08:12,090 --> 00:08:15,050
Kadangi mes nuolat stebėti
kiek monetų mes naudojame,

153
00:08:15,050 --> 00:08:19,210
tada mes galime spausdinti, kad vertę pabaigoje,
vartotojui pranešti, kiek monetų jie

154
00:08:19,210 --> 00:08:20,240
Grįžti.

155
00:08:20,240 --> 00:08:24,240
>> Mano vardas yra Amayla, ir tai yra CS50.

156
00:08:24,240 --> 00:08:25,915

