Leiskite gauti gobšus. Be gobšus, mūsų darbas yra žaisti iš gobšus kasininko vaidmenį. Vartotojas mums pasakyti, kaip daug pokyčių mes skolingi jiems, ir tada mūsų darbas yra apskaičiuoti minimalus skaičius monetų kad mes galime naudoti, kad kad pokyčio sumą. 

Pradėkime pavyzdys. Pasakykite vartotojas reikalauja 0,32 $ atgal. Mes galime tai padaryti, suteikiant jiems 32 centus, vienu centu kiekvienam. Arba aš taip pat galėtų naudoti penkis coins-- iki suteikiant jiems tris dimes, kiekvienas $ 0.10 ir du centus, kiekvienas $ 0,02. Bet ar mes naudojame net mažiau monetų padaryti, kad? 

Visa taktika greedy-- būti godus cashier-- yra naudoti prie didžiausios monetos įmanoma. Taigi, jei mes turime ketvirčius mes juos naudoti. Ir tada, kai tie baigsis, mes naudosime dimes, kiekviena 0,10 $. Tada Nickels, 5 centų už kiekvieną, ir tada žemyn į centus, vienu centu kiekvienam. Naudojant didžiausią monetą įmanoma, kai galime, mes užtikriname, kad mes naudojame mažiausią skaičių monetų įmanoma, kad pakeisti. 

Taigi leiskite eiti tai per. Vartotojas turi 0,32 $. Taigi, mes klausiame savęs, mes galime naudoti ketvirtį? Na, taip, mes galime. Taigi dabar mes tik žinome, juos 0,07 $, o mes naudojome vieną monetą. 

Ar mes galime naudoti kitą ketvirtį? Na, ne. 0,07 $ yra mažiau nei $ 0,25, todėl mes pereisime į kitą didžiausių monetos prieinama. Monetos yra $ 0.10 ir vėl, mes negalime naudoti dimes. Kadangi monetos yra verta $ 0.10, kuris yra daugiau nei pokyčių mokėtinos sumos. 

Mes einame į Nickels. Ir, taip iš tikrųjų, 0,05 $ yra mažiau nei $ 0.10-- todėl mes galime naudoti nikelio. Taigi, dabar mes tik skolingas naudotojas $ 0,02, ir mes iki šiol naudojami du monetas. Mes negalime naudoti kitą nikelio. Taigi mes pereisime prie paskutinės monetos ne mūsų žinioje, kuris yra kapeikos. 

Ir mes galime naudoti cento? Na, yes-- ir mes galų gale naudojant du centus ketverių monetų iš viso. 

Kai esate baigtas, programa atrodys taip. Kai vartotojas "valdo gobšus programa, jie paraginti duoti iš sumą pokytis dolerių, kad jie skolingi. Ir tada jūsų programa bus išėjimas minimali suma monetų kad godus kasininkas būtų naudoti padaryti, kad pokyčio sumą. 

Taigi dabar galime padalyti žemyn į mūsų smulkesnes užduotis. Pirmiausia mes ketiname greitai mūsų vartotojas už pokyčių sumos. Ir, kaip ir su bet naudotojo įvesties, mes norime įsitikinkite, kad mes patikrinti, kad pirkimo ir užtikrinti, kad mes galime naudoti, kad indėlis į mūsų programą poilsio. Tada mes ketiname visada naudoti prie didžiausios tašką galimą ir sekti monetų, naudojamų. Ir pagaliau, spausdinti galutinis monetų skaičiaus, kad mes, naudojamų. 

Taigi pakalbėkime apie raginimo. Suma turi padaryti centų, ir tai yra JAV doleriais. Ir taip dolerių, mes ketiname naudoti plūdę kintamojo tipą. Dabar, kai jūs paprašykite vartotoją įvesties, Jūs norite įsitikinti, kad tai galioja. Ir todėl čia mes norėtume pasinaudoti iš Do-while cikle konstruktą. 

Daug ką, o kilpa vykdys organas linijos bent vieną kartą. Taigi tai praverčia. Mes žinome, kad turime tai paskatins vartotojas bent vieną kartą plūdės. Taigi, jei plūdė galioja. Tai puiku. Mes judėti. Bet jei ne, kilpa užtikrins kad mes gauti tinkamą plūdę kartojant nuolat, kol vartotojas suteikia mums galiojantį vertę. 

Dabar do-o kilpa sąlyga, turime apsvarstyti, ką tai reiškia turėti neteisingą plūdę. Tokios veiklos kontekste Ši problema, tikriausiai prasminga tik priimti teigiamas vertybes. 

Taigi juda on-- mes gaunamas vertė doleriais nuo naudotojo. Bet mes susiduriame su monetomis, kurios yra visiškai centų. $ 1 lygus 100 centų. Taigi geras dalykas padaryti, tai konvertuoti šias vertybes į centų. 

Dabar, kai konvertuoti iš flotacinio iki sveikojo skaičiaus, todėl dolerių centų, mes norime įsitikinti, kad mes atsargūs apie netikslumą slankiojo kablelio. Taigi tai reiškia, kad that-- pasakyti Mano doleris value-- mano plūdę value-- ten buvo net $ 2, dar Gali būti keletas benamių skaičių ten. Taigi mes norime įsitikinti, kad ne tik mes padauginti 100 gauti centų, bet mes taip pat suapvalinti ant kojų. 

Taigi dabar mes turime sumą pokyčių skolingi vartotojui. Mes iš pradžių gauti jį dolerių, ir dabar mes konvertuoti jį centų. Taigi, dabar mes galime pradėti su širdies gobšus algoritmas, kuris visada yra naudojant prie didžiausios monetos įmanoma. Nors mes darome tai, labai svarbu, kad mes taip pat sekti, kiek monetų bus grąžintas vartotojui taip pat likusi pakeisti skolingi vartotojui. 

Programa atrodys kažkas panašaus į tai. Po gausite sumą dolerių ir konvertuoti, kad centais, tada jums reikės įvesti kilpą. Nors ketvirtadaliai gali būti used-- ty o pokyčio suma skolingi vartotojas yra didesnis nei arba lygus 0,25 $, jums naudoti ketvirtį. 

Dabar ką naudojate ketvirtadalis reiškia? Na, one-- jums padidinti monetą suskaičiuokite iki grąžinami vartotojui. Ir antra jums sumažinti einamosios suma pokyčių skolinga atgal į vartotojo iki 0,25 $. 

Po kartoti, kad iki ketvirčių nebegali būti naudojamas, pereiti į kitą dydį coin-- šiuo atveju dimes, 0,10 $. Taigi jums įvesti tą kilpą iki tu nebegali naudotis dimes. Tada pereikite prie kito Didžiausias moneta, Nickels. Po Nickels nebegali būti naudojami, naudoti likusią sumą į centus. Ir, pagaliau, išspausdinti naudojami monetų skaičiaus. 

Kitas būdas, kad galite kreiptis į gobšus problemą yra naudoti Modulo požiūris. Modulo yra operatorius kad grąžina likusią tarp dviejų skaičių pasidalijimas. Pasakyti, kad aš turėjo 50 mod 5. Na, 5 yra 50 veiksnys, todėl likusi bus 0. 50 mod 10-- gerai, 10 taip pat yra veiksnys of 50, todėl likusi dalis yra taip pat 0. 50 mod 50-- gerai, bet koks skaičius mod save nesiruošia turėti bet koks likutis. 

Ką apie 50 mod 49? Na, 49 eina tik į 50 kartą. Taigi, likusi dalis bus 1 d. 53 mod 50 ketina jums 3 dalį. 

Taigi, kaip mes galime naudoti modulo o gal kai padalinys įgyvendinti mūsų gobšus algoritmą? Na, mes vis dar norime išlikti teisinga širdis gobšus algorithm-- kad yra naudojant prie didžiausios monetos įmanoma. 

Taigi leiskite paklausti savęs, ar mes galime naudoti bet ketvirčių grįžti $ 0,32 vartotojui. Na, 32 mod 25 suteikia mums $ 0,07 likusi. Taigi, kad mums sako, kad mes galime tikrai naudoti vieną kėlinį 0,07 $ likę. 

Ar mes tada naudoti bet kokias dimes? Na, no-- nes 0,07 $ mod $ 0,10 suteikia mums 7 dalį. 10 neviršijama į 7 ne visiems. 

Tada mes galime naudoti Nickels? Na $ 0.07 mod 5 centai suteikia mums du likusius. Ir galiausiai, mes galime naudoti bet kokias centus? 2 Mod 1 suteikia mums 0, kuri galiausiai ką mes norime, nes tada reiškia, kad mes grįžo vartotojui visą kaitos skolinga. 

Taigi, dabar jūs turite du galimus būdus Įgyvendinant gobšus algorithm-- vienas su vyriais ir vienas su kombinaciją Modulo ir pasidalijimas. Taigi, pagaliau, mes tiesiog reikia spausdinti galutinį skaičių monetų. 

Jei aš norėjau, kad turėjau pasakyti 3 Gyvūnai, ir ši vertė buvo kieta, tada galėčiau tiesiog naudoti paprastas spausdinimo testas pareiškimas. Tačiau mūsų vertė yra iš tikrųjų saugomi į kintamąjį. Taigi, kaip jums išspausdinti vertės saugomi kintamieji? 

Už tai mes privalumas yra rezervuotos vietos. Pasakyti, kad aš jau pareiškė inicializuoti sveikasis skaičius n. Tada vėliau, jei aš norėjau spausdinti, kad vertė, tada rašyčiau eilutę. Ir vietoj tos vertės Norėčiau naudoti rezervuota vieta už tą integer--% i. Tada po eilutę, aš turiu kableliais, po kurio kintamojo kad aš noriu spausdinti. Ir vėliau, kai jis spausdina, jis bus išspausdinti n vertę. 

Aš taip pat galėtų naudoti vietos rezervavimo ženklą dėl plūdės, pavyzdžiui. Jei aš norėjau pasakyti, kaip daug pinigų turiu kišenę, tada galėčiau pasakyti turiu% f dolerių. Ir vėliau, kai jis spausdina, tai n bus imtis tos vietos savininkas vietą. Aš taip pat galėtų, pavyzdžiui, naudoti kelis pamainymai už kelių kintamųjų. Taigi, kaip ilgai, kaip aš sąrašas juos, kad, tada aš galiu pasakyti, kiek šunys ir katės turiu. 

Dabar mes žinome, kaip paskatinti vartotojas už pokyčio sumą, užtikrinti, kad tą indėlį galioja, ir tada mes turi du galimus būdus, kaip įgyvendinti gobšus algoritmas visada naudojant didžiausias moneta įmanoma. Kadangi mes nuolat stebėti kiek monetų mes naudojame, tada mes galime spausdinti, kad vertę pabaigoje, vartotojui pranešti, kiek monetų jie Grįžti. 

Mano vardas yra Amayla, ir tai yra CS50. 