1
00:00:00,000 --> 00:00:00,710

2
00:00:00,710 --> 00:00:02,900
>> के लालची मिलता है।

3
00:00:02,900 --> 00:00:06,810
लालची, हमारे काम खेलने के लिए है
एक लालची खजांची की भूमिका।

4
00:00:06,810 --> 00:00:09,750
उपयोगकर्ता हमें बताओ कैसे होगा
ज्यादा बदलाव हम उन्हें देने हैं,

5
00:00:09,750 --> 00:00:13,520
और फिर हमारे काम की गणना करने के लिए है
सिक्कों की न्यूनतम संख्या

6
00:00:13,520 --> 00:00:17,240
हम बनाने के लिए उपयोग कर सकते हैं कि
परिवर्तन की है कि राशि।

7
00:00:17,240 --> 00:00:19,560
>> चलो एक उदाहरण के साथ शुरू करते हैं।

8
00:00:19,560 --> 00:00:23,170
उपयोगकर्ता $ 0.32 वापस आवश्यकता कहो।

9
00:00:23,170 --> 00:00:28,960
हम देकर यह कर सकता है
उन्हें 32 पैसे, एक प्रतिशत प्रत्येक।

10
00:00:28,960 --> 00:00:35,180
या मैं भी द्वारा पांच coins-- इस्तेमाल कर सकते हैं
उन्हें तीन ऑफ डाइम्स दे रही है, $ 0.10 प्रत्येक,

11
00:00:35,180 --> 00:00:38,060
और दो पैसे, $ 0.02 प्रत्येक।

12
00:00:38,060 --> 00:00:42,580
लेकिन हम भी इस्तेमाल कर सकते हैं
कम सिक्कों कि बनाने के लिए?

13
00:00:42,580 --> 00:00:45,100
>> greedy-- में पूरी रणनीति
एक लालची cashier-- होना करने के लिए

14
00:00:45,100 --> 00:00:47,600
सबसे बड़ा सिक्का संभव का उपयोग करने के लिए है।

15
00:00:47,600 --> 00:00:50,670
तो जब भी हमारे पास है
क्वार्टर हम उन्हें इस्तेमाल करेंगे।

16
00:00:50,670 --> 00:00:54,100
और फिर उन बाहर चला एक बार,
हम डाइम्स, $ 0.10 प्रत्येक इस्तेमाल करेंगे।

17
00:00:54,100 --> 00:00:58,840
तब nickels, 5 सेंट प्रत्येक, और
तो पैसे के लिए नीचे, एक प्रतिशत प्रत्येक।

18
00:00:58,840 --> 00:01:01,792
सबसे बड़ा सिक्का का उपयोग करके
संभव है जब भी हम कर सकते हैं,

19
00:01:01,792 --> 00:01:07,350
हम यह सुनिश्चित करना है कि हम सबसे कम संख्या का उपयोग
संभव सिक्कों की परिवर्तन करने के लिए।

20
00:01:07,350 --> 00:01:09,180
>> तो चलो इस के माध्यम से चलते हैं।

21
00:01:09,180 --> 00:01:11,660
उपयोगकर्ता $ 0.32 की जरूरत है।

22
00:01:11,660 --> 00:01:14,200
इसलिए हम अपने आप से पूछना,
हम एक चौथाई उपयोग कर सकते हैं?

23
00:01:14,200 --> 00:01:15,560
खैर, हाँ हम कर सकते हैं।

24
00:01:15,560 --> 00:01:19,720
तो अब हम केवल उन्हें पता है
$ 0.07 है, और हम एक सिक्का इस्तेमाल किया।

25
00:01:19,720 --> 00:01:20,970
>> हम एक और तिमाही का उपयोग कर सकते हैं?

26
00:01:20,970 --> 00:01:21,890
नहीं।

27
00:01:21,890 --> 00:01:27,570
$ 0.07 $ 0.25 की तुलना में कम है, इसलिए हम आगे बढ़ना
अगले सबसे बड़ा सिक्का उपलब्ध है।

28
00:01:27,570 --> 00:01:30,690
ऑफ डाइम्स $ 0.10 रहे हैं, और
फिर, हम डाइम्स का उपयोग नहीं कर सकते हैं।

29
00:01:30,690 --> 00:01:35,480
क्योंकि ऑफ डाइम्स $ 0.10, लायक हैं जो
परिवर्तन की बकाया राशि की तुलना में अधिक है।

30
00:01:35,480 --> 00:01:36,790
>> हम nickels के पास जाओ।

31
00:01:36,790 --> 00:01:40,890
और, हाँ, वास्तव में, $ 0.05 की तुलना में कम है
$ 0.10-- तो हम एक निकल उपयोग कर सकते हैं।

32
00:01:40,890 --> 00:01:46,104
तो अब हम केवल $ 0.02 उपयोगकर्ता कर्ज़दार
और हम अब तक दो सिक्के का उपयोग किया है।

33
00:01:46,104 --> 00:01:47,270
हम एक और निकल का उपयोग नहीं कर सकते हैं।

34
00:01:47,270 --> 00:01:51,140
तो फिर हम पर पिछले सिक्का के लिए आगे बढ़ना
हमारे निपटान, जो पैसे हैं।

35
00:01:51,140 --> 00:01:52,270
>> और हम पैसा का उपयोग कर सकते हैं?

36
00:01:52,270 --> 00:01:59,060
खैर, yes-- और हम दो का उपयोग कर खत्म
चार सिक्के की कुल के लिए पैसे।

37
00:01:59,060 --> 00:02:01,430
>> एक बार जब आप समाप्त कर रहे हैं,
कार्यक्रम इस तरह दिखेगा।

38
00:02:01,430 --> 00:02:03,710
एक बार जब उपयोगकर्ता चलाता
लालची कार्यक्रम, वे

39
00:02:03,710 --> 00:02:07,270
की राशि देने के लिए प्रेरित किया
डॉलर में परिवर्तन है कि वे बकाया कर रहे हैं।

40
00:02:07,270 --> 00:02:11,140
और फिर अपने कार्यक्रम होगा उत्पादन
सिक्कों की न्यूनतम राशि

41
00:02:11,140 --> 00:02:14,740
कि लालची खजांची का प्रयोग करेंगे
परिवर्तन की है कि राशि बनाने के लिए।

42
00:02:14,740 --> 00:02:18,160
>> तो अब इस तोड़ देना
हमारे subtasks में नीचे।

43
00:02:18,160 --> 00:02:21,410
सबसे पहले हम शीघ्र करने जा रहे हैं हमारे
परिवर्तन की राशि के लिए उपयोगकर्ता।

44
00:02:21,410 --> 00:02:25,630
और, किसी भी उपयोगकर्ता इनपुट के साथ के रूप में, हम चाहते हैं
यकीन है कि हम उस इनपुट को मान्य करना

45
00:02:25,630 --> 00:02:29,360
और यह सुनिश्चित करना है कि हम उस का उपयोग कर सकते हैं कि
हमारे कार्यक्रम के आराम के लिए इनपुट।

46
00:02:29,360 --> 00:02:32,480
तो फिर हम हमेशा के लिए जा रहे हैं
सबसे बड़ा मुद्दा यह संभव का उपयोग

47
00:02:32,480 --> 00:02:35,240
और इस्तेमाल के सिक्कों का ट्रैक रखने के लिए।

48
00:02:35,240 --> 00:02:39,080
और अंत में, अंतिम प्रिंट
सिक्कों कि हम इस्तेमाल की संख्या।

49
00:02:39,080 --> 00:02:40,970
>> तो चलो उत्साह के बारे में बात करते हैं।

50
00:02:40,970 --> 00:02:43,550
राशि, सेंट करना चाहिए
और यह डॉलर में है।

51
00:02:43,550 --> 00:02:48,440
और तो डॉलर के लिए, हम जा रहे हैं
नाव चर प्रकार का उपयोग करने के लिए।

52
00:02:48,440 --> 00:02:52,390
अब जब भी आप निवेश के लिए एक उपयोगकर्ता से पूछते हैं,
आपको लगता है कि यह वैध है बनाना चाहते हैं।

53
00:02:52,390 --> 00:02:56,640
और यहाँ तो हम लाभ लेना चाहते
मत करो हालांकि पाश निर्माण के।

54
00:02:56,640 --> 00:03:00,320
>> एक है, जबकि पाश अमल करेंगे
लूप के शरीर पर कम से कम एक बार।

55
00:03:00,320 --> 00:03:01,650
इसलिए इस काम में आता है।

56
00:03:01,650 --> 00:03:05,510
हम जानते हैं कि हम शीघ्र करने की जरूरत है
उपयोगकर्ता एक नाव के लिए कम से कम एक बार।

57
00:03:05,510 --> 00:03:07,100
अब अगर है कि नाव वैध है।

58
00:03:07,100 --> 00:03:07,710
एक दम बढ़िया।

59
00:03:07,710 --> 00:03:08,460
हम आगे बढ़ते हैं।

60
00:03:08,460 --> 00:03:11,910
लेकिन अगर नहीं, पाश यह सुनिश्चित करेंगे
हम एक उचित नाव मिलता है कि

61
00:03:11,910 --> 00:03:16,810
जब तक लगातार दोहरा द्वारा
उपयोगकर्ता हमें एक मान्य मान देता है।

62
00:03:16,810 --> 00:03:18,760
>> अब क्या-थोड़ी देर के लिए
पाश की स्थिति, हम की जरूरत है

63
00:03:18,760 --> 00:03:22,000
विचार करने के लिए इसका क्या मतलब
गलत नाव है।

64
00:03:22,000 --> 00:03:24,220
के संदर्भ के लिए तो
इस समस्या है, शायद

65
00:03:24,220 --> 00:03:27,450
यह सिर्फ समझ में आता है
सकारात्मक मूल्यों को स्वीकार करते हैं।

66
00:03:27,450 --> 00:03:32,010
>> तो on-- चलती हम प्राप्त की है एक
उपयोगकर्ता से डॉलर में मूल्य।

67
00:03:32,010 --> 00:03:35,380
लेकिन हम सिक्कों के साथ काम कर रहे हैं,
जो सेंट में पूरी तरह से कर रहे हैं।

68
00:03:35,380 --> 00:03:38,660
$ 1 100 सेंट के बराबर है।

69
00:03:38,660 --> 00:03:43,670
ऐसा करने के लिए एक अच्छी बात है
सेंट में उन मूल्यों को बदलने का।

70
00:03:43,670 --> 00:03:48,380
>> अब जब एक नाव से परिवर्तित
एक पूर्णांक के लिए, सेंट करने के लिए डॉलर हां,

71
00:03:48,380 --> 00:03:52,230
हमें यकीन है कि हम सावधान कर रहे हैं बनाना चाहते
चल बिन्दु अस्पष्टता के बारे में।

72
00:03:52,230 --> 00:03:55,260
तो यह है कि that-- का कहना है कि इसका मतलब है
मेरे डॉलर मेरी नाव value--

73
00:03:55,260 --> 00:04:00,260
value-- एक भी $ 2, वहाँ अभी भी था
वहाँ में कुछ आवारा संख्या हो सकती है।

74
00:04:00,260 --> 00:04:04,590
इसलिए हम चाहते हैं कि यह सुनिश्चित करना चाहते न केवल
हम 100 से गुणा सेंट पाने के लिए करते हैं,

75
00:04:04,590 --> 00:04:06,480
लेकिन हम भी इसे बंद दौर।

76
00:04:06,480 --> 00:04:09,210
>> तो अब हम मात्रा में है
परिवर्तन के उपयोगकर्ता के लिए होता था।

77
00:04:09,210 --> 00:04:13,430
हम मूल रूप से डॉलर में इसे प्राप्त की,
और अब हम सेंट करने के लिए इसे बदल दिया है।

78
00:04:13,430 --> 00:04:17,029
अब तो हम के दिल के साथ आगे बढ़ सकते हैं
लालची एल्गोरिथ्म, जो हमेशा होता है

79
00:04:17,029 --> 00:04:19,220
सबसे बड़ा सिक्का संभव का उपयोग कर।

80
00:04:19,220 --> 00:04:21,930
जब तक हम यह कर रहे हैं,
ऐसा नहीं है कि हम भी जरूरी है

81
00:04:21,930 --> 00:04:25,360
कितने सिक्के हैं का ट्रैक रखने
उपयोगकर्ता को लौट होने जा रहा

82
00:04:25,360 --> 00:04:28,630
के साथ-साथ शेष
उपयोगकर्ता को बकाया बदल जाते हैं।

83
00:04:28,630 --> 00:04:31,130
>> कार्यक्रम दिखेगा
कुछ इस तरह।

84
00:04:31,130 --> 00:04:34,190
आप के बाद की राशि प्राप्त
डॉलर और सेंट करने के लिए कि परिवर्तित,

85
00:04:34,190 --> 00:04:35,790
तो आप एक पाश में प्रवेश करेंगे।

86
00:04:35,790 --> 00:04:38,400
तिमाहियों हो सकता है
used-- कि कहने के लिए है

87
00:04:38,400 --> 00:04:43,660
जबकि परिवर्तन की राशि को बकाया
उपयोगकर्ता से अधिक या $ 0.25 के बराबर है,

88
00:04:43,660 --> 00:04:45,040
आप एक चौथाई इस्तेमाल करेंगे।

89
00:04:45,040 --> 00:04:47,000
>> अब क्या एक चौथाई आवश्यक का उपयोग करता है?

90
00:04:47,000 --> 00:04:51,280
खैर, आप one-- सिक्का में वृद्धि होगी
उपयोगकर्ता को लौट जा गिनती।

91
00:04:51,280 --> 00:04:55,890
और दूसरा आप वर्तमान में कमी करेंगे
परिवर्तन की राशि उपयोगकर्ता को वापस बकाया

92
00:04:55,890 --> 00:04:57,520
$ 0.25।

93
00:04:57,520 --> 00:05:00,680
>> दोहरा कि बाद जब तक
तिमाहियों अब नहीं किया जा सकता है,

94
00:05:00,680 --> 00:05:04,630
अगले सबसे बड़ा करने के लिए आगे बढ़ें
$ 0.10 इस मामले ऑफ डाइम्स में coin--।

95
00:05:04,630 --> 00:05:07,750
तो आप जब तक कि पाश में प्रवेश करेंगे
आप नहीं रह ऑफ डाइम्स उपयोग कर सकते हैं।

96
00:05:07,750 --> 00:05:10,720
फिर अगले करने के लिए आगे बढ़ें
सबसे बड़ा सिक्का, nickels।

97
00:05:10,720 --> 00:05:14,810
nickels अब नहीं किया जा सकता है के बाद,
पैसे में शेष राशि का उपयोग करें।

98
00:05:14,810 --> 00:05:17,800
और अंत में, मुद्रित
सिक्कों की संख्या का इस्तेमाल किया।

99
00:05:17,800 --> 00:05:20,350
>> एक और तरीका है कि आप कर सकते हैं
लालची समस्या दृष्टिकोण

100
00:05:20,350 --> 00:05:22,950
सापेक्ष दृष्टिकोण का उपयोग करने के लिए है।

101
00:05:22,950 --> 00:05:25,690
Modulo एक ऑपरेटर है
कि शेष रिटर्न

102
00:05:25,690 --> 00:05:27,680
दो संख्याओं के बीच विभाजन की।

103
00:05:27,680 --> 00:05:30,270
मैं 50 आधुनिक 5 था कहो।

104
00:05:30,270 --> 00:05:34,070
खैर, 5 से 50 का एक पहलू है,
इसलिए शेष 0 होगा।

105
00:05:34,070 --> 00:05:39,230
50 आधुनिक 10-- अच्छी तरह से, 10 में भी एक कारक है
50 साल की है, तो शेष भी 0 है।

106
00:05:39,230 --> 00:05:43,660
50 आधुनिक 50-- खैर, किसी भी संख्या ही आधुनिक
किसी भी शेष राशि के लिए नहीं जा रहा है।

107
00:05:43,660 --> 00:05:45,510
>> क्या 50 आधुनिक 49 के बारे में?

108
00:05:45,510 --> 00:05:47,910
खैर, 49 केवल एक बार 50 में चला जाता है।

109
00:05:47,910 --> 00:05:50,290
तो शेष 1 होने जा रहा है।

110
00:05:50,290 --> 00:05:55,180
53 आधुनिक 50 करने जा रहा है
आप 3 की शेष दे।

111
00:05:55,180 --> 00:05:59,120
>> इसलिए हम सापेक्ष कैसे उपयोग कर सकते हैं
और शायद कुछ विभाजन

112
00:05:59,120 --> 00:06:01,690
हमारे लालची कलन विधि को लागू करने के लिए?

113
00:06:01,690 --> 00:06:05,550
ठीक है, हम अभी भी करने के सच्चे रहना चाहते हैं
कि algorithm-- लालची का दिल

114
00:06:05,550 --> 00:06:07,910
सबसे बड़ा सिक्का संभव का उपयोग कर रहा है।

115
00:06:07,910 --> 00:06:14,570
>> तो अगर हम किसी भी उपयोग कर सकते हैं की अपने आप से पूछना
क्वार्टर उपयोगकर्ता के लिए $ 0.32 लौटने के लिए।

116
00:06:14,570 --> 00:06:20,070
खैर, 32 आधुनिक 25 देता है
अमेरिका $ 0.07 शेष।

117
00:06:20,070 --> 00:06:24,500
तो यह है कि हमें बताता है कि हम निश्चित रूप से कर सकते हैं
$ 0.07 शेष के साथ एक चौथाई का उपयोग करें।

118
00:06:24,500 --> 00:06:26,180
>> हम तो किसी भी ऑफ डाइम्स का उपयोग कर सकते हैं?

119
00:06:26,180 --> 00:06:32,740
खैर, no-- क्योंकि $ 0.07 आधुनिक
$ 0.10 हमें 7 का शेष देता है।

120
00:06:32,740 --> 00:06:34,960
10 7 में बिल्कुल नहीं जाना है।

121
00:06:34,960 --> 00:06:36,390
>> तो फिर हम nickels उपयोग कर सकते हैं?

122
00:06:36,390 --> 00:06:40,490
अच्छी तरह से $ 0.07 आधुनिक 5 सेंट
हमें दो शेष देता है।

123
00:06:40,490 --> 00:06:42,930
और अंत में, हम किसी भी पैसे का उपयोग कर सकते हैं?

124
00:06:42,930 --> 00:06:45,930
2 आधुनिक 1 हमें 0 देता है,
जो अंततः क्या है

125
00:06:45,930 --> 00:06:48,160
हम तो यह है कि क्योंकि चाहते हैं
इसका मतलब है कि हम लौटा दिया है

126
00:06:48,160 --> 00:06:50,160
उपयोगकर्ता के लिए परिवर्तन के सभी बकाया है।

127
00:06:50,160 --> 00:06:54,320
>> तो अब आप के दो संभव तरीके हैं
लालची algorithm-- को लागू

128
00:06:54,320 --> 00:06:59,230
छोरों के साथ एक और एक के साथ एक
सापेक्ष और विभाजन का संयोजन।

129
00:06:59,230 --> 00:07:03,010
तो अंत में, हम सिर्फ करने की जरूरत है
सिक्कों की अंतिम संख्या मुद्रित।

130
00:07:03,010 --> 00:07:06,520
>> अगर मैं तुम्हें कि मैं था बताना चाहता था
3 पालतू जानवर और इस मूल्य हार्डकोडेड किया गया था,

131
00:07:06,520 --> 00:07:09,240
फिर मैं तो बस एक इस्तेमाल कर सकते हैं
सरल प्रिंट परीक्षण बयान।

132
00:07:09,240 --> 00:07:12,320
लेकिन हमारे मूल्य वास्तव में है
एक चर में संग्रहीत।

133
00:07:12,320 --> 00:07:15,260
तो कैसे आप प्रिंट करना
मूल्यों चर में संग्रहीत?

134
00:07:15,260 --> 00:07:17,880
>> इसके लिए हम लेते हैं
प्लेसहोल्डर्स का लाभ।

135
00:07:17,880 --> 00:07:21,540
मैं पहले से ही घोषित कर दिया था कहो
एक initialized पूर्णांक।

136
00:07:21,540 --> 00:07:25,170
फिर बाद में अगर मैं चाहता था कि मुद्रित करने के लिए
मूल्य, तो मैं स्ट्रिंग लिखना होगा।

137
00:07:25,170 --> 00:07:30,500
और कहा कि मूल्य के बजाय मैं प्रयोग करेंगे
कि integer--% i के लिए एक प्लेसहोल्डर।

138
00:07:30,500 --> 00:07:33,800
एक तो स्ट्रिंग के बाद, मेरे पास है
अल्पविराम, चर के द्वारा पीछा

139
00:07:33,800 --> 00:07:34,950
मैं मुद्रित करने के लिए चाहते हैं।

140
00:07:34,950 --> 00:07:38,550
और बाद में, जब यह प्रिंट,
यह n के मूल्य प्रिंट हूँ।

141
00:07:38,550 --> 00:07:41,570
>> मैं भी एक प्लेसहोल्डर इस्तेमाल कर सकते हैं
एक नाव, उदाहरण के लिए के लिए।

142
00:07:41,570 --> 00:07:44,000
अगर मैं आपको बता कैसे करना चाहता था
ज्यादा नकदी मैं अपनी जेब में है,

143
00:07:44,000 --> 00:07:46,820
तो मैं कह सकता मैं% च डॉलर है।

144
00:07:46,820 --> 00:07:51,330
और बाद में जब यह प्रिंट पर, तो n होगा
उस जगह धारक की जगह ले।

145
00:07:51,330 --> 00:07:55,530
मैं भी, उदाहरण के लिए, कई इस्तेमाल कर सकते हैं
कई चर के लिए प्लेसहोल्डर्स।

146
00:07:55,530 --> 00:07:57,590
तो जब तक मैं सूची
उन्हें क्रम में, तो मैं

147
00:07:57,590 --> 00:08:00,390
आपको बता सकते हैं कि कितने
कुत्तों और बिल्लियों मेरे पास है।

148
00:08:00,390 --> 00:08:03,710
>> अब हम जानते हैं कि संकेत करने के लिए कैसे
परिवर्तन की राशि के लिए उपयोगकर्ता,

149
00:08:03,710 --> 00:08:06,130
यह सुनिश्चित करें कि कि इनपुट
वैध है, और फिर हम

150
00:08:06,130 --> 00:08:10,370
लागू करने के दो तरीके हैं संभव
हमेशा का उपयोग करने का लालची एल्गोरिथ्म

151
00:08:10,370 --> 00:08:12,090
सबसे बड़ा सिक्का संभव।

152
00:08:12,090 --> 00:08:15,050
क्योंकि हम का ट्रैक रखा है
कितने सिक्के हम प्रयोग कर रहे हैं,

153
00:08:15,050 --> 00:08:19,210
हम तो अंत में है कि मूल्य मुद्रित कर सकते हैं,
उपयोगकर्ता कितने सिक्के वे कर रहे हैं कह रही

154
00:08:19,210 --> 00:08:20,240
वापस हो रही है।

155
00:08:20,240 --> 00:08:24,240
>> मेरा नाम Amayla है, और इस CS50 है।

156
00:08:24,240 --> 00:08:25,915

