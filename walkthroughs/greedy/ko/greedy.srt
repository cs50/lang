1
00:00:00,000 --> 00:00:00,710

2
00:00:00,710 --> 00:00:02,900
>> 의 욕심하자.

3
00:00:02,900 --> 00:00:06,810
욕심, 우리의 작업은 재생하는 것입니다
욕심 점원의 역할.

4
00:00:06,810 --> 00:00:09,750
사용자는 어떻게 우리를 알려줍니다
우리가 빚을 많이 변화,

5
00:00:09,750 --> 00:00:13,520
다음 우리의 작업은 계산하는 것입니다
동전의 최소 개수

6
00:00:13,520 --> 00:00:17,240
우리는 확인하는 데 사용할 수있는
변화의 양.

7
00:00:17,240 --> 00:00:19,560
>> 예제를 시작하자.

8
00:00:19,560 --> 00:00:23,170
사용자가 다시 $ 0.32을 필요로 말한다.

9
00:00:23,170 --> 00:00:28,960
우리는 제공하여이 작업을 수행 할 수
그 32 페니, 하나 센트 각각.

10
00:00:28,960 --> 00:00:35,180
아니면 내가 또한 의해 다섯 coins--을 사용할 수 있습니다
세 센트를주고, $ 0.10 각,

11
00:00:35,180 --> 00:00:38,060
두 개의 동전, $ 0.02 각.

12
00:00:38,060 --> 00:00:42,580
그러나 우리는 심지어 사용할 수 있습니다
적은 동전은 만들려면?

13
00:00:42,580 --> 00:00:45,100
>> greedy--의 전체 전술
욕심 cashier-- 될 수 있습니다

14
00:00:45,100 --> 00:00:47,600
가능한 가장 큰 동전을 사용하는 것입니다.

15
00:00:47,600 --> 00:00:50,670
그래서 때마다 우리가
4 분 우리는 그들을 사용합니다.

16
00:00:50,670 --> 00:00:54,100
그리고 사람들은 밖으로 실행하면
우리는 센트, $ 0.10를 각각 사용합니다.

17
00:00:54,100 --> 00:00:58,840
그런 다음 센트, 5 센트, 그리고
다음 동전에 이르기까지, 하나 센트 각각.

18
00:00:58,840 --> 00:01:01,792
큰 동전을 사용하여
때마다 우리가 할 수있는 가능

19
00:01:01,792 --> 00:01:07,350
우리는 우리가 가장 적은 수를 사용하는지 확인
가능한 동전은 변경 사항을 확인합니다.

20
00:01:07,350 --> 00:01:09,180
>> 그래서이를 통해 살펴 보겠습니다.

21
00:01:09,180 --> 00:01:11,660
사용자는 $ 0.32이 필요합니다.

22
00:01:11,660 --> 00:01:14,200
그래서 우리는 우리 자신에게 물어,
우리는 분기 사용할 수 있습니까?

23
00:01:14,200 --> 00:01:15,560
음, 그래 우리는 할 수 있습니다.

24
00:01:15,560 --> 00:01:19,720
그래서 지금 우리는 그들을 알고
$ 0.07, 우리는 하나의 동전을 사용했다.

25
00:01:19,720 --> 00:01:20,970
>> 우리는 또 다른 분기를 사용할 수 있습니까?

26
00:01:20,970 --> 00:01:21,890
음 ... 아니.

27
00:01:21,890 --> 00:01:27,570
$ 0.07는 $ 0.25 미만, 그래서 우리는 계속
사용할 수있는 다음으로 큰 동전합니다.

28
00:01:27,570 --> 00:01:30,690
임은 $ 0.10이며,
다시, 우리는 센트를 사용할 수 없습니다.

29
00:01:30,690 --> 00:01:35,480
임은 $ 0.10, 가치가 있기 때문에 어떤
빚 변화의 양보다 더 많은 것이다.

30
00:01:35,480 --> 00:01:36,790
>> 우리는 니켈로 이동합니다.

31
00:01:36,790 --> 00:01:40,890
그리고, 그래 참, $ 0.05 미만
$ 0.10-- 그래서 우리는 니켈을 사용할 수 있습니다.

32
00:01:40,890 --> 00:01:46,104
그래서 지금 우리는, $ 0.02 사용자를 빚
우리는 지금까지 두 개의 동전을 사용했습니다.

33
00:01:46,104 --> 00:01:47,270
우리는 다른 니켈을 사용할 수 없습니다.

34
00:01:47,270 --> 00:01:51,140
그럼 우리의 마지막 동전으로 이동
페니 우리의 처분.

35
00:01:51,140 --> 00:01:52,270
>> 그리고 우리는 페니를 사용할 수 있습니까?

36
00:01:52,270 --> 00:01:59,060
음, 어마, 우리는 두 가지를 사용하게
네 동전의 총 동전.

37
00:01:59,060 --> 00:02:01,430
>> 당신이 완료되면,
프로그램은 다음과 같이 표시됩니다.

38
00:02:01,430 --> 00:02:03,710
사용자가 실행되면
욕심 프로그램, 그들은거야

39
00:02:03,710 --> 00:02:07,270
의 양을 제공하라는 메시지가
그들이 빚지고있는 달러의 변화.

40
00:02:07,270 --> 00:02:11,140
다음 프로그램 출력됩니다
동전 최소량

41
00:02:11,140 --> 00:02:14,740
욕심 점원 사용할 것
변화의 양을 확인합니다.

42
00:02:14,740 --> 00:02:18,160
>> 그래서 지금의이 휴식 할 수
아래 우리의 하위에.

43
00:02:18,160 --> 00:02:21,410
처음에 우리는 메시지를 표시거야 우리
변화의 금액에 대한 사용자.

44
00:02:21,410 --> 00:02:25,630
그리고, 사용자 입력에, 우리는 원하는
우리가 그 입력의 유효성을 검사해야합니다

45
00:02:25,630 --> 00:02:29,360
우리가 그것을 사용할 수있는 및 확인
우리의 프로그램의 나머지 부분에 대한 입력.

46
00:02:29,360 --> 00:02:32,480
그런 다음 우리는 항상에거야
가능한 가장 큰 지점을 사용

47
00:02:32,480 --> 00:02:35,240
사용 된 동전을 추적.

48
00:02:35,240 --> 00:02:39,080
그리고 마지막으로, 최종 인쇄
우리가 사용하는 동전의 수입니다.

49
00:02:39,080 --> 00:02:40,970
>> 그럼 프롬프트에 대해 이야기 할 수 있습니다.

50
00:02:40,970 --> 00:02:43,550
금액은 센트를해야합니다
이 달러입니다.

51
00:02:43,550 --> 00:02:48,440
그래서 달러, 우리는거야
플로트 변수 유형을 사용합니다.

52
00:02:48,440 --> 00:02:52,390
이제 입력을 사용자에게 물어 때마다,
당신은 유효하다는 있는지 확인하려면.

53
00:02:52,390 --> 00:02:56,640
그래서 여기에 우리가 활용할 수 좋아
DO-whil​​e 루프 구조의.

54
00:02:56,640 --> 00:03:00,320
>> 할 - while 루프가 실행됩니다
적어도 한 번 루프의 몸.

55
00:03:00,320 --> 00:03:01,650
그래서이 유용합니다.

56
00:03:01,650 --> 00:03:05,510
우리는 우리가 메시지를 표시해야한다는 것을 알고있다
한 번 이상 부동의 사용자.

57
00:03:05,510 --> 00:03:07,100
이제 플로트는 유효합니다.

58
00:03:07,100 --> 00:03:07,710
잘 됐네요.

59
00:03:07,710 --> 00:03:08,460
우리는 이동합니다.

60
00:03:08,460 --> 00:03:11,910
하지만하지 않으면 것은 루프가 보장합니다
우리는 적절한 플로트를 얻을

61
00:03:11,910 --> 00:03:16,810
때까지 계속 반복하여
사용자는 우리에게 유효한 값을 제공합니다.

62
00:03:16,810 --> 00:03:18,760
>> 이제 DO-동안
루프 조건, 우리는 필요

63
00:03:18,760 --> 00:03:22,000
그것이 무엇을 의미하는지 고려
잘못된 플로트가 있습니다.

64
00:03:22,000 --> 00:03:24,220
의 컨텍스트에 대한 그래서
이 문제를 아마

65
00:03:24,220 --> 00:03:27,450
그것은 단지에 의미가 있습니다
양의 값을 받아들입니다.

66
00:03:27,450 --> 00:03:32,010
>> 그래서 on-- 이동 우리가 획득 한
사용자의 달러 값입니다.

67
00:03:32,010 --> 00:03:35,380
그러나 우리는 동전을 처리하고,
센트에 전적으로 어떤 있습니다.

68
00:03:35,380 --> 00:03:38,660
$ 1 100 센트에 해당합니다.

69
00:03:38,660 --> 00:03:43,670
그래서 할 수있는 좋은 일이다
센트에 그 값을 변환합니다.

70
00:03:43,670 --> 00:03:48,380
>> 이제 부동 소수점으로 변환 할 때
정수로, 센트 달러 그래서

71
00:03:48,380 --> 00:03:52,230
우리는 우리가 조심있어이 있는지 확인하려면
부동 소수점 부정확성에 대한.

72
00:03:52,230 --> 00:03:55,260
그래서 that-- 말을 의미
내 달러 내 플로트를 value--

73
00:03:55,260 --> 00:04:00,260
value-- 여전히 더 $ (2)이 있었다
거기에 몇 가지 길잃은 숫자 일 수있다.

74
00:04:00,260 --> 00:04:04,590
그래서 우리는이 있는지 확인하려면뿐만 아니라,
우리가 센트를 얻기 위해 100을 곱 않습니다,

75
00:04:04,590 --> 00:04:06,480
그러나 우리는 또한 반올림.

76
00:04:06,480 --> 00:04:09,210
>> 그래서 지금 우리는 양이
변화의 사용자에게 빚진.

77
00:04:09,210 --> 00:04:13,430
우리는 원래 달러를 획득
지금 우리는 센트에 변환했습니다.

78
00:04:13,430 --> 00:04:17,029
지금 우리의 마음을 진행할 수 있습니다
항상 욕심 알고리즘,

79
00:04:17,029 --> 00:04:19,220
가능한 가장 큰 동전을 사용.

80
00:04:19,220 --> 00:04:21,930
우리는이 일을하는 동안
그것은 또한 우리가 중요합니다

81
00:04:21,930 --> 00:04:25,360
얼마나 많은 동전입니다 추적
사용자에게 반환 될 것

82
00:04:25,360 --> 00:04:28,630
뿐만 아니라 나머지
사용자에게 빚을 변경합니다.

83
00:04:28,630 --> 00:04:31,130
>> 이 프로그램은 볼 것이다
이 같은.

84
00:04:31,130 --> 00:04:34,190
후에의 양을 얻을
달러와 센트에 그 변환,

85
00:04:34,190 --> 00:04:35,790
당신은 루프를 입력합니다.

86
00:04:35,790 --> 00:04:38,400
분기가 될 수 있지만
used-- 그 말을하는 것입니다

87
00:04:38,400 --> 00:04:43,660
반면에 빚의 변화량
유저는 이상의 $ 0.25과 같다

88
00:04:43,660 --> 00:04:45,040
당신은 분기를 사용합니다.

89
00:04:45,040 --> 00:04:47,000
>> 지금 무슨 일이 4 분의 수반 사용합니까?

90
00:04:47,000 --> 00:04:51,280
글쎄, 당신은 동전을 one-- 증가합니다
사용자에게 반환되도록 계산.

91
00:04:51,280 --> 00:04:55,890
그리고 두 번째는 전류를 감소합니다
변화량이 사용자에게 다시 빚

92
00:04:55,890 --> 00:04:57,520
$ 0.25로.

93
00:04:57,520 --> 00:05:00,680
>> 때까지 반복 한 후
분기는 더 이상 사용할 수 없습니다,

94
00:05:00,680 --> 00:05:04,630
다음 최대로 진행
$ 0.10,이 경우 임에 coin--.

95
00:05:04,630 --> 00:05:07,750
그래서 당신은 때까지 루프를 입력합니다
더 이상 센트를 사용할 수 없습니다.

96
00:05:07,750 --> 00:05:10,720
그런 다음에 진행
가장 큰 동전, 센트.

97
00:05:10,720 --> 00:05:14,810
센트는 더 이상 사용할 수 없습니다 후,
동전의 나머지 양을 사용한다.

98
00:05:14,810 --> 00:05:17,800
그리고 마지막으로, 인쇄
동전의 수는 사용했다.

99
00:05:17,800 --> 00:05:20,350
>> 또 다른 방법은 당신이 할 수있는
욕심 문제를 접근

100
00:05:20,350 --> 00:05:22,950
모듈러 방식을 사용하는 것이다.

101
00:05:22,950 --> 00:05:25,690
모듈은 연산자
그 나머지를 반환

102
00:05:25,690 --> 00:05:27,680
두 숫자 사이의 분열.

103
00:05:27,680 --> 00:05:30,270
나는 50 모드 5를 가지고 말.

104
00:05:30,270 --> 00:05:34,070
그런데,도 5는 50의 팩터이며,
그래서 나머지는 0이됩니다.

105
00:05:34,070 --> 00:05:39,230
모드 (50)는 10--도, 10도 요인이다
(50), 그래서 나머지는 0이다.

106
00:05:39,230 --> 00:05:43,660
50 모드 50-- 아니라, 임의의 수의 자체 모드 (mod)
모든 나머지를해야 할 것하지 않습니다.

107
00:05:43,660 --> 00:05:45,510
>> 어떤 모드 49 (50)에 대한?

108
00:05:45,510 --> 00:05:47,910
음, 49 번만 (50)로 들어갑니다.

109
00:05:47,910 --> 00:05:50,290
그래서 나머지가 1이 될 것입니다.

110
00:05:50,290 --> 00:05:55,180
53 모드 (50)로 이동된다
당신에게 (3)의 나머지를 제공합니다.

111
00:05:55,180 --> 00:05:59,120
>> 그래서 우리는 어떻게 모듈을 사용할 수 있습니다
아마도 일부 부문

112
00:05:59,120 --> 00:06:01,690
우리의 욕심 알고리즘을 구현하는 방법?

113
00:06:01,690 --> 00:06:05,550
글쎄, 우리는 여전히에 충실 할
그 algorithm-- 욕심의 마음

114
00:06:05,550 --> 00:06:07,910
가능한 가장 큰 동전을 사용하고 있습니다.

115
00:06:07,910 --> 00:06:14,570
>> 그래서 우리는 하나를 사용할 수 있는지 스스로 물어 보자
분기는 사용자에게 $ 0.32를 반환합니다.

116
00:06:14,570 --> 00:06:20,070
음, 32 모드 25 제공
US $ 0.07의 나머지.

117
00:06:20,070 --> 00:06:24,500
즉 우리에게 그래서 우리는 확실히 할 수
나머지 $ 0.07와 1/4 사용합니다.

118
00:06:24,500 --> 00:06:26,180
>> 우리는 어떤 센트를 사용할 수 있습니까?

119
00:06:26,180 --> 00:06:32,740
음, 말아요 - $ 0.07 모드 때문에
$ 0.10는 우리에게 (7)의 나머지를 제공합니다.

120
00:06:32,740 --> 00:06:34,960
(10)는 모두 7로 이동하지 않습니다.

121
00:06:34,960 --> 00:06:36,390
>> 그 다음 우리는 센트를 사용할 수 있습니까?

122
00:06:36,390 --> 00:06:40,490
그럼 $ 0.07 모드 5 센트
우리 두 사람은 남아 있습니다.

123
00:06:40,490 --> 00:06:42,930
그리고 마지막으로, 우리는 동전을 사용할 수 있습니까?

124
00:06:42,930 --> 00:06:45,930
2 모드 1, 우리에게 공을 준다
궁극적으로 무엇이다

125
00:06:45,930 --> 00:06:48,160
우리는 그 때문에 원하는
우리가 반환 한 것을 의미한다

126
00:06:48,160 --> 00:06:50,160
사용자에게 변화의 모든 빚.

127
00:06:50,160 --> 00:06:54,320
>> 이제 당신은 두 가지 방법이
욕심 algorithm--를 구현

128
00:06:54,320 --> 00:06:59,230
루프 하나와 하나
모듈과 분열의 조합.

129
00:06:59,230 --> 00:07:03,010
그래서 마지막으로, 우리는 단지 필요
동전의 마지막 번호를 인쇄 할 수 있습니다.

130
00:07:03,010 --> 00:07:06,520
>> 난 당신이 내가 가진 것을 말하고 싶었다면
3 애완 동물이 값은 하드 코딩 된,

131
00:07:06,520 --> 00:07:09,240
나는 그냥 사용할 수
간단한 인쇄 테스트 문.

132
00:07:09,240 --> 00:07:12,320
그러나 우리의 값은 실제로
변수에 저장된다.

133
00:07:12,320 --> 00:07:15,260
그래서 당신은을 인쇄하는 방법
값은 변수에 저장?

134
00:07:15,260 --> 00:07:17,880
>> 이를 위해 우리는 가지고
자리의 장점.

135
00:07:17,880 --> 00:07:21,540
이미 선언 한 말
초기화 정수 n.

136
00:07:21,540 --> 00:07:25,170
그리고 나중에 그 인쇄하기를 원한다면
값은, 그때 문자열을 작성합니다.

137
00:07:25,170 --> 00:07:30,500
대신 그 값의 내가 사용하는 것이
그 integer-- % 난에 대한 자리 표시 자.

138
00:07:30,500 --> 00:07:33,800
그런 다음 문자열 후, 내가 가지고
변수 다음에 쉼표,

139
00:07:33,800 --> 00:07:34,950
나는 인쇄 할 것이다.

140
00:07:34,950 --> 00:07:38,550
그리고 나중에, 그것은 인쇄 할 때,
그것은 n의 값을 인쇄 할 수 있습니다.

141
00:07:38,550 --> 00:07:41,570
>> 또한 자리를 사용할 수 있습니다
예를 들어 부동 소수점을위한.

142
00:07:41,570 --> 00:07:44,000
내가 방법을 말하려고하는 경우
내 주머니에있는 많은 현금,

143
00:07:44,000 --> 00:07:46,820
나는 내가 % f를 달러를 말할 수 있습니다.

144
00:07:46,820 --> 00:07:51,330
그리고 나중에는 N 것이다 다음 인쇄를 할 때
그 장소 홀더의 자리를 차지할.

145
00:07:51,330 --> 00:07:55,530
또한, 예를 들면, 여러 가지를 사용할 수
여러 변수에 대한 자리.

146
00:07:55,530 --> 00:07:57,590
그래서 한 나는 목록으로
다음 그들을 위해, I

147
00:07:57,590 --> 00:08:00,390
당신에게 얼마나 많은 말할 수
개와 고양이는 I 있습니다.

148
00:08:00,390 --> 00:08:03,710
>> 이제 우리는 메시지를 표시하는 방법을 알고
변화의 금액에 대한 사용자,

149
00:08:03,710 --> 00:08:06,130
이 입력되었는지 확인
유효하고 우리

150
00:08:06,130 --> 00:08:10,370
구현하는 두 가지 방법이있다
항상 사용하는 욕심 알고리즘

151
00:08:10,370 --> 00:08:12,090
가능한 가장 큰 동전입니다.

152
00:08:12,090 --> 00:08:15,050
우리는 추적을 유지했기 때문에
우리가 사용하고 얼마나 많은 동전,

153
00:08:15,050 --> 00:08:19,210
그런 다음, 마지막에 그 값을 출력 할 수
그들이있어 얼마나 많은 동전 사용자 이야기

154
00:08:19,210 --> 00:08:20,240
다시 받고.

155
00:08:20,240 --> 00:08:24,240
>> 나의 이름은 Amayla이며, 이것은 CS50이다.

156
00:08:24,240 --> 00:08:25,915

