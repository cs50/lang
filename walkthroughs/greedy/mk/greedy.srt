1
00:00:00,000 --> 00:00:00,710

2
00:00:00,710 --> 00:00:02,900
>> Ајде да се алчни.

3
00:00:02,900 --> 00:00:06,810
Во алчен, наша работа е да се игра
улогата на алчен касата.

4
00:00:06,810 --> 00:00:09,750
Корисникот ќе ни каже како
многу промени што ги должам,

5
00:00:09,750 --> 00:00:13,520
а потоа наша работа е да се пресмета
минималниот број на монети,

6
00:00:13,520 --> 00:00:17,240
кои може да се користат да се направи
дека износот на промена.

7
00:00:17,240 --> 00:00:19,560
>> Да почнеме со еден пример.

8
00:00:19,560 --> 00:00:23,170
Велат дека корисникот бара $ 0.32 назад.

9
00:00:23,170 --> 00:00:28,960
Ние би можеле да го направите тоа со давање на
нив 32 пени, еден цент секоја од нив.

10
00:00:28,960 --> 00:00:35,180
Или јас исто така може да се користи од страна на пет coins--
давајќи им три dimes, $ 0,10 секој,

11
00:00:35,180 --> 00:00:38,060
и два пени, 0,02 $ секоја од нив.

12
00:00:38,060 --> 00:00:42,580
Но, ние може да се користи дури и
помалку пари да се направи тоа?

13
00:00:42,580 --> 00:00:45,100
>> Целата тактика во greedy--
да се биде алчен cashier--

14
00:00:45,100 --> 00:00:47,600
е да се користи најголем можен паричка.

15
00:00:47,600 --> 00:00:50,670
Значи секогаш кога имаме
четвртини ние ќе ги користите.

16
00:00:50,670 --> 00:00:54,100
А потоа, откако тие трчаат надвор,
ние ќе користат dimes, $ 0,10 секоја од нив.

17
00:00:54,100 --> 00:00:58,840
Потоа nickels, 5 центи, секој, и
се надолу до пени, еден цент секоја од нив.

18
00:00:58,840 --> 00:01:01,792
Со користење на најголемиот паричка
е можно кога ќе ни се,

19
00:01:01,792 --> 00:01:07,350
ние се осигура дека ние ги користиме на најмали број
на можни монети за да се направи промена.

20
00:01:07,350 --> 00:01:09,180
>> Па ајде да одиме по овој преку.

21
00:01:09,180 --> 00:01:11,660
Корисникот треба $ 0.32.

22
00:01:11,660 --> 00:01:14,200
Значи, ние да се запрашаме,
можеме да го користиме една четвртина?

23
00:01:14,200 --> 00:01:15,560
Па, да можеме.

24
00:01:15,560 --> 00:01:19,720
Па сега ние само ги знаете
$ 0,07, и ние се користи една монета.

25
00:01:19,720 --> 00:01:20,970
>> Можеме да го користиме уште една четвртина?

26
00:01:20,970 --> 00:01:21,890
Па, бр.

27
00:01:21,890 --> 00:01:27,570
$ 0,07 е помалку од $ 0,25, за да можеме да продолжи
на следниот најголем паричка на располагање.

28
00:01:27,570 --> 00:01:30,690
Dimes се $ 0,10, и
Повторно, ние не може да се користи dimes.

29
00:01:30,690 --> 00:01:35,480
Бидејќи dimes се во вредност од $ 0,10, што
е повеќе од износот на промената се должи.

30
00:01:35,480 --> 00:01:36,790
>> Ние одиме на nickels.

31
00:01:36,790 --> 00:01:40,890
И, да, навистина, $ 0,05 е помалку од
$ 0.10-- па ние може да се користи никел.

32
00:01:40,890 --> 00:01:46,104
Па сега ние само должиме на корисникот $ 0,02,
и ние досега се користат две парички.

33
00:01:46,104 --> 00:01:47,270
Ние не може да користи друг никел.

34
00:01:47,270 --> 00:01:51,140
Па потоа да продолжиме на последната паричка во
ни се на располагање, кои се пени.

35
00:01:51,140 --> 00:01:52,270
>> И можеме да го користиме денар?

36
00:01:52,270 --> 00:01:59,060
Па, yes-- и на крајот ќе заврши со користење на два
пени за вкупно четири монети.

37
00:01:59,060 --> 00:02:01,430
>> Откако ќе се заврши,
Програмата ќе изгледа вака.

38
00:02:01,430 --> 00:02:03,710
Откако корисникот ќе раководи со органот на
алчен програма, тие ќе

39
00:02:03,710 --> 00:02:07,270
да биде побарано да се даде на износот на
промена во долари, кои тие се должи.

40
00:02:07,270 --> 00:02:11,140
И тогаш вашата програма ќе излез
минималниот износ на пари

41
00:02:11,140 --> 00:02:14,740
дека алчните касиерот ќе се користи
да го направат тој износ на промена.

42
00:02:14,740 --> 00:02:18,160
>> Па сега ајде да се скрши оваа
долу во нашите подзадачи.

43
00:02:18,160 --> 00:02:21,410
Прво ние си оди за да се поттикне нашите
корисник за износот на промена.

44
00:02:21,410 --> 00:02:25,630
И, како и со било кој корисник влез, ние сакаме да
бидете сигурни дека ние се провери дека влез

45
00:02:25,630 --> 00:02:29,360
и да се осигура дека ние може да го користат
влез за остатокот од нашата програма.

46
00:02:29,360 --> 00:02:32,480
Тогаш ние се случува да се секогаш
користете најголемата можна точка

47
00:02:32,480 --> 00:02:35,240
и да ги пратите на монети што се користат.

48
00:02:35,240 --> 00:02:39,080
И, конечно, печатење на финалната
бројот на монетите што ги користат.

49
00:02:39,080 --> 00:02:40,970
>> Па ајде да разговараме за прашува.

50
00:02:40,970 --> 00:02:43,550
Износот мора да се направи центи,
и ова е во долари.

51
00:02:43,550 --> 00:02:48,440
И така за долари, ние ќе
да се користи со пливка променлива.

52
00:02:48,440 --> 00:02:52,390
Сега секогаш кога ќе побара корисникот за влез,
вие сакате да бидете сигурни дека тоа е валидна.

53
00:02:52,390 --> 00:02:56,640
И така, тука сме да ги искористат предностите
на јамка изградба на не-време.

54
00:02:56,640 --> 00:03:00,320
>> А не-додека јамка ќе се изврши на
телото на јамка барем еднаш.

55
00:03:00,320 --> 00:03:01,650
Значи ова доаѓа во удобен.

56
00:03:01,650 --> 00:03:05,510
Ние знаеме дека ние треба да го извести
корисникот барем еднаш за да се одржи.

57
00:03:05,510 --> 00:03:07,100
Сега, ако тоа плови е валидна.

58
00:03:07,100 --> 00:03:07,710
Тоа е супер.

59
00:03:07,710 --> 00:03:08,460
Да продолжат понатаму.

60
00:03:08,460 --> 00:03:11,910
Но, ако не, циклусот ќе се обезбеди
кои ги добие соодветна плови

61
00:03:11,910 --> 00:03:16,810
со повторување непрекинато до
корисникот ни дава важечка вредност.

62
00:03:16,810 --> 00:03:18,760
>> Сега за не-а
состојба јамка, ние треба

63
00:03:18,760 --> 00:03:22,000
да се разгледа она што значи
има неважечки плови.

64
00:03:22,000 --> 00:03:24,220
Така и за контекстот на
овој проблем, веројатно

65
00:03:24,220 --> 00:03:27,450
тоа го прави смисла само за да
прифати позитивни вредности.

66
00:03:27,450 --> 00:03:32,010
>> Значи се движат on-- имаме добиено
вредност во долари од страна на корисникот.

67
00:03:32,010 --> 00:03:35,380
Но, ние не се занимаваат со монети,
кои се целосно во центи.

68
00:03:35,380 --> 00:03:38,660
$ 1 е еквивалентно на 100 центи.

69
00:03:38,660 --> 00:03:43,670
Па добра работа да се направи е да се
се претворат оние вредности во центи.

70
00:03:43,670 --> 00:03:48,380
>> Сега кога конвертирање од плови
на цел број, па долари за да центи,

71
00:03:48,380 --> 00:03:52,230
ние сакаме да бидете сигурни дека ние сме внимателни
во врска со подвижна точка непрецизност.

72
00:03:52,230 --> 00:03:55,260
Па тоа значи дека that-- каже
мојот долар value-- мојот плови

73
00:03:55,260 --> 00:04:00,260
value-- беше уште $ 2, се уште
може да има некои скитници броеви во таму.

74
00:04:00,260 --> 00:04:04,590
Затоа сакаме да бидете сигурни дека не само што
ние множи со 100 за да се добие центи,

75
00:04:04,590 --> 00:04:06,480
но ние исто така, го заокружуваат.

76
00:04:06,480 --> 00:04:09,210
>> Така, сега имаме износот
на промени се должат на корисникот.

77
00:04:09,210 --> 00:04:13,430
Ние првично добиени во долари,
а сега ние сме го претвора во центи.

78
00:04:13,430 --> 00:04:17,029
Па сега можеме да продолжиме со срцето
алчен алгоритам, кој е секогаш

79
00:04:17,029 --> 00:04:19,220
користење на најголем можен паричка.

80
00:04:19,220 --> 00:04:21,930
И покрај тоа што го правиме ова,
тоа е од суштинско значење дека ние, исто така,

81
00:04:21,930 --> 00:04:25,360
ги пратите на тоа колку пари се
ќе треба да се врати на корисник

82
00:04:25,360 --> 00:04:28,630
како и останатите
промени се должат на корисникот.

83
00:04:28,630 --> 00:04:31,130
>> На програмата ќе се погледне
нешто како ова.

84
00:04:31,130 --> 00:04:34,190
Откако ќе се добие износот на
долари и конвертирате дека центи,

85
00:04:34,190 --> 00:04:35,790
тогаш ќе влезат во еден циклус.

86
00:04:35,790 --> 00:04:38,400
Додека четвртини може да биде
used-- односно

87
00:04:38,400 --> 00:04:43,660
додека износот на промени се должат на
корисникот е поголема или еднаква на $ 0,25,

88
00:04:43,660 --> 00:04:45,040
ќе се користи за една четвртина.

89
00:04:45,040 --> 00:04:47,000
>> Сега она што го прави со користење на една четвртина повлекува?

90
00:04:47,000 --> 00:04:51,280
Па, one-- ќе се зголеми на проблемот
се смета дека ќе се вратат на корисникот.

91
00:04:51,280 --> 00:04:55,890
И второ ќе се намали сегашната
износот на промената се должи назад до корисникот

92
00:04:55,890 --> 00:04:57,520
од $ 0,25.

93
00:04:57,520 --> 00:05:00,680
>> По повторува дека до
четвртини веќе не може да се користи,

94
00:05:00,680 --> 00:05:04,630
продолжи кон следниот најголем
coin-- во овој случај dimes, $ 0,10.

95
00:05:04,630 --> 00:05:07,750
Па ќе влезе во таа јамка се додека
веќе не може да се користи dimes.

96
00:05:07,750 --> 00:05:10,720
Потоа да продолжи со следниот
најголемиот монета, nickels.

97
00:05:10,720 --> 00:05:14,810
По nickels веќе не може да се користи,
користење на преостанатиот износ на пени.

98
00:05:14,810 --> 00:05:17,800
И, конечно, печатење на
бројот на монетите се користи.

99
00:05:17,800 --> 00:05:20,350
>> Друг начин на кој може да се
пријде на алчен проблем

100
00:05:20,350 --> 00:05:22,950
е да се користи пристапот на modulo.

101
00:05:22,950 --> 00:05:25,690
Modulo е оператор
кој се враќа остатокот

102
00:05:25,690 --> 00:05:27,680
на поделбата помеѓу два броја.

103
00:05:27,680 --> 00:05:30,270
Да кажам дека имаше 50 современи 5.

104
00:05:30,270 --> 00:05:34,070
Па, 5 е фактор на 50,
така што остатокот ќе биде 0.

105
00:05:34,070 --> 00:05:39,230
50 современи 10-- добро, 10 исто така е фактор
од 50, па остатокот е, исто така, 0.

106
00:05:39,230 --> 00:05:43,660
50 современи 50-- добро, било кој број се современи
нема да има никакви остатокот.

107
00:05:43,660 --> 00:05:45,510
>> Што е со 50 mod 49?

108
00:05:45,510 --> 00:05:47,910
Па, 49 оди само во 50 еднаш.

109
00:05:47,910 --> 00:05:50,290
Значи остатокот ќе биде 1.

110
00:05:50,290 --> 00:05:55,180
53 mod 50 ќе се
ви даде остатокот од 3.

111
00:05:55,180 --> 00:05:59,120
>> Па како можеме да го користиме modulo
а можеби и некои поделба

112
00:05:59,120 --> 00:06:01,690
да ја оствариме нашата алчен алгоритам?

113
00:06:01,690 --> 00:06:05,550
Па, сепак сакам да останам верен на
срцето на алчните algorithm-- дека

114
00:06:05,550 --> 00:06:07,910
е користење на најголем можен паричка.

115
00:06:07,910 --> 00:06:14,570
>> Па ајде да се запрашаме дали можеме да се користи било кој
четвртини да се врати $ 0.32 за корисникот.

116
00:06:14,570 --> 00:06:20,070
Па, 32 mod 25 дава
ни остатокот од $ 0,07.

117
00:06:20,070 --> 00:06:24,500
Така што ни кажува дека ние може да дефинитивно
користите една четвртина со $ 0,07 до крајот.

118
00:06:24,500 --> 00:06:26,180
>> Може ли да потоа се користи било dimes?

119
00:06:26,180 --> 00:06:32,740
Па, затоа no-- $ 0,07 МО
$ 0,10 ни дава остатокот од 7.

120
00:06:32,740 --> 00:06:34,960
10 не оди во 7 на сите.

121
00:06:34,960 --> 00:06:36,390
>> Тогаш можеме да го користиме парички?

122
00:06:36,390 --> 00:06:40,490
Па $ 0,07 МО 5 центи
ни дава преостанатите двајца.

123
00:06:40,490 --> 00:06:42,930
И на крај, ние може да се користи било кој пени?

124
00:06:42,930 --> 00:06:45,930
2 МО 1 ни дава 0,
што е она што на крајот

125
00:06:45,930 --> 00:06:48,160
сакаме затоа што тогаш тоа
значи дека ние се врати

126
00:06:48,160 --> 00:06:50,160
на корисникот на сите промени што се должи.

127
00:06:50,160 --> 00:06:54,320
>> Така, сега имате два начина
спроведување на алчен algorithm--

128
00:06:54,320 --> 00:06:59,230
еден со јамки и еден со
комбинација на modulo и поделба.

129
00:06:59,230 --> 00:07:03,010
Значи, конечно, ние само треба да се
печати конечниот број на монети.

130
00:07:03,010 --> 00:07:06,520
>> Ако сакав да ви кажам дека имав
3 домашни миленици и оваа вредност е Hardcoded,

131
00:07:06,520 --> 00:07:09,240
тогаш јас само може да се користи
едноставна изјава тест печатење.

132
00:07:09,240 --> 00:07:12,320
Но, нашата вредност е, всушност,
складирани во променлива.

133
00:07:12,320 --> 00:07:15,260
Па, како да го испечатите
вредностите зачувани во променливи?

134
00:07:15,260 --> 00:07:17,880
>> За ова се
Предноста на места за чување.

135
00:07:17,880 --> 00:07:21,540
Велат дека веќе имаше прогласено
на иницијализира цел број n.

136
00:07:21,540 --> 00:07:25,170
Потоа подоцна, ако сакав да се печати кои
вредност, а потоа јас ќе пишувам на стринг.

137
00:07:25,170 --> 00:07:30,500
И наместо таа вредност јас ќе го користи
случаеви за кои integer--% i.

138
00:07:30,500 --> 00:07:33,800
Потоа, по низа, имам
запирка, а потоа со променлива

139
00:07:33,800 --> 00:07:34,950
што сакате да печатите.

140
00:07:34,950 --> 00:07:38,550
И подоцна, кога тоа отпечатоци,
тоа ќе се печати вредноста на n.

141
00:07:38,550 --> 00:07:41,570
>> Јас би можеле да го користат за да зачува место
за број со подвижна запирка, на пример.

142
00:07:41,570 --> 00:07:44,000
Ако сакав да ви кажам како
Имам многу пари во џебот,

143
00:07:44,000 --> 00:07:46,820
тогаш можам да кажам имам% f долари.

144
00:07:46,820 --> 00:07:51,330
И подоцна, кога тоа отпечатоци, тогаш n ќе
заземе местото на имателот место.

145
00:07:51,330 --> 00:07:55,530
Јас исто така би можеле, на пример, се користи неколку
резервирани места за неколку променливи.

146
00:07:55,530 --> 00:07:57,590
Така што додека јас листата
нив, со цел, тогаш јас

147
00:07:57,590 --> 00:08:00,390
да ви кажам колку
кучиња и мачки што го имам.

148
00:08:00,390 --> 00:08:03,710
>> Сега знаеме како да го извести
корисникот за износ на промени,

149
00:08:03,710 --> 00:08:06,130
се осигура дека таа влез
е валиден, а потоа ние

150
00:08:06,130 --> 00:08:10,370
има две можни начини на спроведување на
алчен алгоритам за секогаш користејќи

151
00:08:10,370 --> 00:08:12,090
најголем можен паричка.

152
00:08:12,090 --> 00:08:15,050
Затоа што ние сме водел сметка
колку пари ние сме со користење,

153
00:08:15,050 --> 00:08:19,210
тогаш можеме да се печати дека вредноста на крајот,
објаснување за корисникот како многу монети што тие се

154
00:08:19,210 --> 00:08:20,240
добивање назад.

155
00:08:20,240 --> 00:08:24,240
>> Моето име е Amayla, и ова е CS50.

156
00:08:24,240 --> 00:08:25,915

