1
00:00:00,000 --> 00:00:00,710

2
00:00:00,710 --> 00:00:02,900
>> Давайте жадный.

3
00:00:02,900 --> 00:00:06,810
В жадный, наша работа состоит в том, чтобы играть
роль жадного кассира.

4
00:00:06,810 --> 00:00:09,750
Пользователь расскажет нам, как
много изменений, которые мы им обязаны,

5
00:00:09,750 --> 00:00:13,520
и наша работа состоит в том, чтобы вычислить
минимальное количество монет

6
00:00:13,520 --> 00:00:17,240
что мы можем использовать, чтобы сделать
что количество изменений.

7
00:00:17,240 --> 00:00:19,560
>> Давайте начнем с примера.

8
00:00:19,560 --> 00:00:23,170
Скажем, пользователю требуется $ 0,32 обратно.

9
00:00:23,170 --> 00:00:28,960
Мы могли бы сделать это, давая
их 32 копейки, один цент каждая.

10
00:00:28,960 --> 00:00:35,180
Или я мог бы также использовать пять coins-- путем
давая им трех пятаков, $ 0,10 каждая,

11
00:00:35,180 --> 00:00:38,060
и две копейки, $ 0,02 каждая.

12
00:00:38,060 --> 00:00:42,580
Но мы могли бы использовать даже
меньше монет, чтобы сделать это?

13
00:00:42,580 --> 00:00:45,100
>> Вся тактика в greedy--
быть жадным cashier--

14
00:00:45,100 --> 00:00:47,600
является использование наибольшую возможную монету.

15
00:00:47,600 --> 00:00:50,670
Таким образом, всякий раз, когда у нас есть
четверти мы будем использовать их.

16
00:00:50,670 --> 00:00:54,100
А потом, как только те закончились,
мы будем использовать пятаков, $ 0,10 каждая.

17
00:00:54,100 --> 00:00:58,840
Тогда никелевые, 5 центов каждый, и
затем вниз к гроши, один цент каждая.

18
00:00:58,840 --> 00:01:01,792
Используя самую большую монету
возможно всякий раз, когда мы можем,

19
00:01:01,792 --> 00:01:07,350
мы гарантируем, что мы используем наименьшее число
монет можно сделать изменения.

20
00:01:07,350 --> 00:01:09,180
>> Так давайте пройдем через это.

21
00:01:09,180 --> 00:01:11,660
Пользователю нужно $ 0,32.

22
00:01:11,660 --> 00:01:14,200
Таким образом, мы спрашиваем себя,
мы можем использовать четверть?

23
00:01:14,200 --> 00:01:15,560
Ну, да, мы можем.

24
00:01:15,560 --> 00:01:19,720
Так что теперь мы знаем только их
$ 0,07, и мы использовали одну монету.

25
00:01:19,720 --> 00:01:20,970
>> Можем ли мы использовать еще четверть?

26
00:01:20,970 --> 00:01:21,890
Ну нет.

27
00:01:21,890 --> 00:01:27,570
$ 0,07 меньше, чем $ 0,25, поэтому мы переходим
к следующему по величине доступной монеты.

28
00:01:27,570 --> 00:01:30,690
Dimes составляет $ 0,10, и
опять же, мы не можем использовать пятаков.

29
00:01:30,690 --> 00:01:35,480
Потому что пятаков стоит $ 0.10, который
больше, чем сумма изменения задолженности.

30
00:01:35,480 --> 00:01:36,790
>> Мы идем к никелевые.

31
00:01:36,790 --> 00:01:40,890
И, да, действительно, $ 0,05 меньше
$ 0.10-- поэтому мы можем использовать никель.

32
00:01:40,890 --> 00:01:46,104
Итак, теперь мы только обязаны пользователю $ 0,02,
и мы до сих пор использовали две монеты.

33
00:01:46,104 --> 00:01:47,270
Мы не можем использовать еще один никель.

34
00:01:47,270 --> 00:01:51,140
Итак, мы переходим к последней монеты в
нашем распоряжении, которые являются гроши.

35
00:01:51,140 --> 00:01:52,270
>> И можем ли мы использовать пенни?

36
00:01:52,270 --> 00:01:59,060
Ну, yes-- и мы в конечном итоге с помощью двух
пенсы в общей сложности четыре монеты.

37
00:01:59,060 --> 00:02:01,430
>> После того, как вы закончите,
Программа будет выглядеть следующим образом.

38
00:02:01,430 --> 00:02:03,710
После того, как пользователь запускает
жадные программа, они будут

39
00:02:03,710 --> 00:02:07,270
будет предложено дать сумму
Изменение в долларах, что они должны.

40
00:02:07,270 --> 00:02:11,140
И тогда ваш вывод программы будет
минимальное количество монет

41
00:02:11,140 --> 00:02:14,740
что жадные кассира будет использовать
чтобы сделать такое количество изменений.

42
00:02:14,740 --> 00:02:18,160
>> Так что теперь давайте разберем этот
вниз в наших подзадач.

43
00:02:18,160 --> 00:02:21,410
Во-первых, мы собираемся, чтобы наша
пользователя на сумму изменения.

44
00:02:21,410 --> 00:02:25,630
И, как и с любым пользовательским вводом, мы хотим
убедитесь, что мы утверждаем, что ввод

45
00:02:25,630 --> 00:02:29,360
и убедитесь, что мы можем использовать
вход для остальной части нашей программы.

46
00:02:29,360 --> 00:02:32,480
Тогда мы будем всегда
использовать самую большую точку возможного

47
00:02:32,480 --> 00:02:35,240
и следить за монет, используемых.

48
00:02:35,240 --> 00:02:39,080
И, наконец, распечатать окончательное
количество монет, которые мы использовали.

49
00:02:39,080 --> 00:02:40,970
>> Итак, давайте поговорим о побуждая.

50
00:02:40,970 --> 00:02:43,550
Сумма должна сделать центов,
и это в долларах.

51
00:02:43,550 --> 00:02:48,440
И так за доллары, мы будем
использовать тип переменной с плавающей точкой.

52
00:02:48,440 --> 00:02:52,390
Теперь, когда вы попросите пользователя для ввода,
Вы хотите, чтобы убедиться, что она действует.

53
00:02:52,390 --> 00:02:56,640
И поэтому здесь мы хотели бы воспользоваться
конструкта сделай время цикла.

54
00:02:56,640 --> 00:03:00,320
>> Цикл Do-то время будет выполнять
тело цикла по крайней мере один раз.

55
00:03:00,320 --> 00:03:01,650
Так что это очень удобно.

56
00:03:01,650 --> 00:03:05,510
Мы знаем, что нам нужно, чтобы побудить
пользователь по меньшей мере, один раз за поплавком.

57
00:03:05,510 --> 00:03:07,100
Теперь, если это поплавок действует.

58
00:03:07,100 --> 00:03:07,710
Замечательно.

59
00:03:07,710 --> 00:03:08,460
Мы идем дальше.

60
00:03:08,460 --> 00:03:11,910
Но если нет, то цикл будет обеспечивать
что мы получаем правильный поплавок

61
00:03:11,910 --> 00:03:16,810
путем непрерывного повторения до тех пор,
пользователь дает нам действительное значение.

62
00:03:16,810 --> 00:03:18,760
>> Теперь сделай время
условие цикла, мы должны

63
00:03:18,760 --> 00:03:22,000
рассмотреть вопрос о том, что значит
иметь недопустимый поплавок.

64
00:03:22,000 --> 00:03:24,220
Так что для контекста
эта проблема, вероятно,

65
00:03:24,220 --> 00:03:27,450
это имеет смысл только
принимают положительные значения.

66
00:03:27,450 --> 00:03:32,010
>> Таким образом, перемещение on-- мы получали
стоимость в долларах от пользователя.

67
00:03:32,010 --> 00:03:35,380
Но мы имеем дело с монетами,
которые полностью в центах.

68
00:03:35,380 --> 00:03:38,660
$ 1 эквивалентно 100 центов.

69
00:03:38,660 --> 00:03:43,670
Так что хорошая вещь, чтобы сделать, это
преобразовать эти значения в центов.

70
00:03:43,670 --> 00:03:48,380
>> Теперь при преобразовании из поплавка
в целое число, так что доллары в центов,

71
00:03:48,380 --> 00:03:52,230
мы хотим, чтобы убедиться, что мы осторожны
о плавающей точкой неточностей.

72
00:03:52,230 --> 00:03:55,260
Так что означает that-- сказать
мой доллар value-- мой поплавок

73
00:03:55,260 --> 00:04:00,260
value-- был еще $ 2, до сих пор
могут быть некоторые паразитные числа там.

74
00:04:00,260 --> 00:04:04,590
Поэтому мы хотим, чтобы убедиться, что не только
мы умножаем на 100, чтобы получить центов,

75
00:04:04,590 --> 00:04:06,480
но мы также довершении.

76
00:04:06,480 --> 00:04:09,210
>> Так что теперь мы имеем сумму
изменения задолженности перед пользователем.

77
00:04:09,210 --> 00:04:13,430
Первоначально мы получили его в долларах,
и теперь мы превратили его в центов.

78
00:04:13,430 --> 00:04:17,029
Так что теперь мы можем перейти с сердцем
жадный алгоритм, который всегда

79
00:04:17,029 --> 00:04:19,220
используя самую большую монету возможно.

80
00:04:19,220 --> 00:04:21,930
Несмотря на то, что мы делаем это,
очень важно, что мы также

81
00:04:21,930 --> 00:04:25,360
отслеживать, сколько монеты
будет возвращена пользователю

82
00:04:25,360 --> 00:04:28,630
а также остальные
изменить причитающиеся к пользователю.

83
00:04:28,630 --> 00:04:31,130
>> Программа будет выглядеть
что-то вроде этого.

84
00:04:31,130 --> 00:04:34,190
После того, как вы получите сумму
долларов и конвертировать, что в центов,

85
00:04:34,190 --> 00:04:35,790
то вам нужно будет ввести петлю.

86
00:04:35,790 --> 00:04:38,400
В то время как помещения могут быть
used-- т.е.

87
00:04:38,400 --> 00:04:43,660
в то время как количество изменений, причитающихся
Пользователь больше или равна $ 0,25,

88
00:04:43,660 --> 00:04:45,040
вы будете использовать четверть.

89
00:04:45,040 --> 00:04:47,000
>> Теперь то, что делает с помощью четверть влечет за собой?

90
00:04:47,000 --> 00:04:51,280
Ну, одно-- вы увеличите монету
рассчитывать, чтобы быть возвращены пользователю.

91
00:04:51,280 --> 00:04:55,890
И во-вторых вы будете уменьшать ток
величина изменения задолжал обратно пользователю

92
00:04:55,890 --> 00:04:57,520
на $ 0,25.

93
00:04:57,520 --> 00:05:00,680
>> После того, как не повторять, что до тех пор,
четверти не может быть больше не используется,

94
00:05:00,680 --> 00:05:04,630
перейти к следующему по величине
coin-- в этом случае пятаков, $ 0.10.

95
00:05:04,630 --> 00:05:07,750
Таким образом, вы не будете ввести этот цикл до тех пор,
Вы больше не можете использовать пятаков.

96
00:05:07,750 --> 00:05:10,720
Затем переходите к следующему
по величине монета, никелевые.

97
00:05:10,720 --> 00:05:14,810
После того, как никелевые больше не могут быть использованы,
использовать оставшуюся сумму в гроши.

98
00:05:14,810 --> 00:05:17,800
И, наконец, распечатать
количество монет используется.

99
00:05:17,800 --> 00:05:20,350
>> Другой способ, который вы можете
подойти к жадному проблемы

100
00:05:20,350 --> 00:05:22,950
заключается в использовании по модулю подход.

101
00:05:22,950 --> 00:05:25,690
Модульное является оператором
что возвращает остаток

102
00:05:25,690 --> 00:05:27,680
разделения между двумя числами.

103
00:05:27,680 --> 00:05:30,270
Скажем, у меня было 50 мод 5.

104
00:05:30,270 --> 00:05:34,070
Ну, 5 является фактором 50,
так что остаток будет равен 0.

105
00:05:34,070 --> 00:05:39,230
50 мод 10-- хорошо, 10 также является фактором
50, так что остальные тоже 0.

106
00:05:39,230 --> 00:05:43,660
50 мод 50-- хорошо, любое число мод сам
не будет иметь какой-либо остаток.

107
00:05:43,660 --> 00:05:45,510
>> А как насчет 50 мод 49?

108
00:05:45,510 --> 00:05:47,910
Что ж, 49 идет только в 50 раз.

109
00:05:47,910 --> 00:05:50,290
Таким образом, остаток будет 1.

110
00:05:50,290 --> 00:05:55,180
53 мод 50 собирается
дать вам оставшуюся часть 3.

111
00:05:55,180 --> 00:05:59,120
>> Так как мы можем использовать по модулю
и, возможно, некоторые деление

112
00:05:59,120 --> 00:06:01,690
реализовать наш жадный алгоритм?

113
00:06:01,690 --> 00:06:05,550
Ну, мы все еще хотим остаться верным
Сердце жадный algorithm--, что

114
00:06:05,550 --> 00:06:07,910
использует самую большую монету возможно.

115
00:06:07,910 --> 00:06:14,570
>> Итак, давайте спросим себя, если мы можем использовать любой
четверти, чтобы вернуть $ 0,32 к пользователю.

116
00:06:14,570 --> 00:06:20,070
Ну, 32 мод 25 дает
мы остаток от $ 0,07.

117
00:06:20,070 --> 00:06:24,500
Так что говорит нам, что мы можем определенно
использовать одну четверть с $ 0,07 до конца.

118
00:06:24,500 --> 00:06:26,180
>> Можем ли мы использовать любые пятаков?

119
00:06:26,180 --> 00:06:32,740
Ну, потому что no-- $ 0,07 мод
$ 0.10 дает нам остаток от 7.

120
00:06:32,740 --> 00:06:34,960
10 не входит в 7 вообще.

121
00:06:34,960 --> 00:06:36,390
>> Тогда мы можем использовать никелевые?

122
00:06:36,390 --> 00:06:40,490
Хорошо $ 0.07 мода 5 центов
дает нам два оставшихся.

123
00:06:40,490 --> 00:06:42,930
И, наконец, мы можем использовать любые гроши?

124
00:06:42,930 --> 00:06:45,930
2 мод 1 дает нам 0,
которая в конечном счете, что

125
00:06:45,930 --> 00:06:48,160
мы хотим, потому что тогда, что
означает, что мы вернулись

126
00:06:48,160 --> 00:06:50,160
пользователю все изменения должны.

127
00:06:50,160 --> 00:06:54,320
>> Так что теперь у вас есть два возможных пути
реализации жадный algorithm--

128
00:06:54,320 --> 00:06:59,230
одна с петель и одна с
комбинация по модулю и деления.

129
00:06:59,230 --> 00:07:03,010
Таким образом, в конце концов, нам просто нужно
печать итоговое количество монет.

130
00:07:03,010 --> 00:07:06,520
>> Если бы я хотел сказать вам, что я имел
3 домашних животных, и это значение было жёстко,

131
00:07:06,520 --> 00:07:09,240
то я мог бы просто использовать
простой тест оператор печати.

132
00:07:09,240 --> 00:07:12,320
Но наша ценность на самом деле
хранится в переменной.

133
00:07:12,320 --> 00:07:15,260
Так как же вы напечатать
Значения сохраняются в переменных?

134
00:07:15,260 --> 00:07:17,880
>> Для этого мы берем
Преимущество заполнителей.

135
00:07:17,880 --> 00:07:21,540
Скажем, у меня уже объявили
инициализированная целое число п.

136
00:07:21,540 --> 00:07:25,170
Тогда в дальнейшем, если я хотел напечатать, что
значение, то я хотел бы написать строку.

137
00:07:25,170 --> 00:07:30,500
И вместо этого значения я хотел бы использовать
заполнитель для этого integer--% я.

138
00:07:30,500 --> 00:07:33,800
Затем после строки, у меня есть
запятая, а затем переменной

139
00:07:33,800 --> 00:07:34,950
что я хочу, чтобы напечатать.

140
00:07:34,950 --> 00:07:38,550
И позже, когда он печатает,
он будет выводить значение п.

141
00:07:38,550 --> 00:07:41,570
>> Я мог бы также использовать заполнитель
для поплавком, например.

142
00:07:41,570 --> 00:07:44,000
Если бы я хотел сказать вам, как
сколько денег у меня в кармане,

143
00:07:44,000 --> 00:07:46,820
то я мог бы сказать, что я% F долларов.

144
00:07:46,820 --> 00:07:51,330
И позже, когда он печатает, то п будет
занять место этого держателя место.

145
00:07:51,330 --> 00:07:55,530
Я мог бы также, например, использовать несколько
заполнители для нескольких переменных.

146
00:07:55,530 --> 00:07:57,590
Так что до тех пор, как я список
они в порядке, то я

147
00:07:57,590 --> 00:08:00,390
могу вам сказать, сколько
собаки и кошки, у меня есть.

148
00:08:00,390 --> 00:08:03,710
>> Теперь мы знаем, как побудить
пользователя на сумму изменения,

149
00:08:03,710 --> 00:08:06,130
убедитесь, что этот вход
является действительным, и тогда мы

150
00:08:06,130 --> 00:08:10,370
есть два возможных пути реализации
жадный алгоритм всегда используя

151
00:08:10,370 --> 00:08:12,090
самая большая монета возможно.

152
00:08:12,090 --> 00:08:15,050
Поскольку мы отслеживали
сколько монет мы используем,

153
00:08:15,050 --> 00:08:19,210
мы можем напечатать это значение в конце,
который сообщает пользователю, сколько монет они

154
00:08:19,210 --> 00:08:20,240
возвращаться.

155
00:08:20,240 --> 00:08:24,240
>> Меня зовут Amayla, и это CS50.

156
00:08:24,240 --> 00:08:25,915

