1
00:00:00,000 --> 00:00:00,710

2
00:00:00,710 --> 00:00:02,900
>> Ας πάρει άπληστοι.

3
00:00:02,900 --> 00:00:06,810
Σε άπληστοι, η δουλειά μας είναι να παίξει
ο ρόλος ενός άπληστοι ταμία.

4
00:00:06,810 --> 00:00:09,750
Ο χρήστης θα μας πει πώς
πολλές αλλαγές τους οφείλουμε,

5
00:00:09,750 --> 00:00:13,520
και, στη συνέχεια, η δουλειά μας είναι να υπολογίσει
ο ελάχιστος αριθμός κερμάτων

6
00:00:13,520 --> 00:00:17,240
ότι μπορούμε να χρησιμοποιήσουμε για να κάνουν
ότι το ποσό της αλλαγής.

7
00:00:17,240 --> 00:00:19,560
>> Ας ξεκινήσουμε με ένα παράδειγμα.

8
00:00:19,560 --> 00:00:23,170
Πείτε το χρήστη απαιτεί $ 0.32 πίσω.

9
00:00:23,170 --> 00:00:28,960
Θα μπορούσαμε να το κάνουμε αυτό, δίνοντας
τους 32 πένες, ένα σεντ η κάθε μία.

10
00:00:28,960 --> 00:00:35,180
Ή θα μπορούσε επίσης να χρησιμοποιήσει πέντε coins-- από
δίνοντάς τους τρεις δεκάρες, $ 0,10 η κάθε μία,

11
00:00:35,180 --> 00:00:38,060
και δύο πένες, $ 0,02 η κάθε μία.

12
00:00:38,060 --> 00:00:42,580
Αλλά θα μπορούσαμε να χρησιμοποιήσει ακόμη
λιγότερα κέρματα για να κάνει αυτό;

13
00:00:42,580 --> 00:00:45,100
>> Η όλη τακτική στην greedy--
να είναι ένας άπληστος cashier--

14
00:00:45,100 --> 00:00:47,600
είναι να χρησιμοποιήσει όσο το δυνατόν μεγαλύτερο κέρμα.

15
00:00:47,600 --> 00:00:50,670
Έτσι, κάθε φορά που έχουμε
τρίμηνα θα τα χρησιμοποιούν.

16
00:00:50,670 --> 00:00:54,100
Και στη συνέχεια μία φορά εκείνους εξαντληθεί,
θα χρησιμοποιήσουμε δεκάρες, $ 0,10 η κάθε μία.

17
00:00:54,100 --> 00:00:58,840
Στη συνέχεια επινικελώνουν, 5 σεντ η κάθε μία, και
στη συνέχεια, σε πένες, ένα σεντ έκαστη.

18
00:00:58,840 --> 00:01:01,792
Με τη χρήση του μεγαλύτερη κέρμα
δυνατόν όποτε μπορούμε,

19
00:01:01,792 --> 00:01:07,350
μπορούμε να διασφαλίσουμε ότι θα χρησιμοποιήσετε το μικρότερο αριθμό
κερμάτων δυνατόν να γίνει η αλλαγή.

20
00:01:07,350 --> 00:01:09,180
>> Ας περπατήσει αυτό μέσω.

21
00:01:09,180 --> 00:01:11,660
Ο χρήστης χρειάζεται $ 0,32.

22
00:01:11,660 --> 00:01:14,200
Έτσι μπορούμε να αναρωτηθούμε,
μπορούμε να χρησιμοποιήσουμε το ένα τέταρτο;

23
00:01:14,200 --> 00:01:15,560
Λοιπόν, ναι, μπορούμε.

24
00:01:15,560 --> 00:01:19,720
Έτσι τώρα μπορούμε να τα γνωρίζουμε μόνο
$ 0,07, και χρησιμοποιήσαμε ένα κέρμα.

25
00:01:19,720 --> 00:01:20,970
>> Μπορούμε να χρησιμοποιήσουμε άλλο ένα τέταρτο;

26
00:01:20,970 --> 00:01:21,890
Λοιπόν όχι.

27
00:01:21,890 --> 00:01:27,570
$ 0.07 είναι λιγότερο από $ 0,25, έτσι προχωράμε
στην επόμενη μεγαλύτερη διαθέσιμη νομίσματος.

28
00:01:27,570 --> 00:01:30,690
Δεκάρες είναι $ 0,10, και
και πάλι, δεν μπορούμε να χρησιμοποιήσουμε δεκάρες.

29
00:01:30,690 --> 00:01:35,480
Επειδή δεκάρες είναι αξίας $ 0,10, το οποίο
είναι κάτι περισσότερο από το ποσό της μεταβολής οφείλεται.

30
00:01:35,480 --> 00:01:36,790
>> Εμείς πάμε για να επινικελώνουν.

31
00:01:36,790 --> 00:01:40,890
Και, ναι πράγματι, $ 0.05 είναι μικρότερη από
$ 0.10-- έτσι μπορούμε να χρησιμοποιήσουμε ένα νικελίου.

32
00:01:40,890 --> 00:01:46,104
Έτσι τώρα χρωστάμε μόνο το χρήστη $ 0,02,
και έχουμε χρησιμοποιήσει μέχρι τώρα δύο νομίσματα.

33
00:01:46,104 --> 00:01:47,270
Δεν μπορούμε να χρησιμοποιήσουμε μια άλλη νικελίου.

34
00:01:47,270 --> 00:01:51,140
Έτσι, τότε προχωρούμε στο τελευταίο κέρμα στο
διάθεσή μας, που είναι οι πένες.

35
00:01:51,140 --> 00:01:52,270
>> Και μπορούμε να χρησιμοποιήσουμε δεκάρα;

36
00:01:52,270 --> 00:01:59,060
Λοιπόν, yes-- και καταλήγουμε με τη χρήση δύο
πένες για ένα σύνολο τεσσάρων κερμάτων.

37
00:01:59,060 --> 00:02:01,430
>> Μόλις τελειώσετε, το
πρόγραμμα θα μοιάζει με αυτό.

38
00:02:01,430 --> 00:02:03,710
Μόλις ο χρήστης τρέχει το
άπληστοι πρόγραμμα, θα

39
00:02:03,710 --> 00:02:07,270
ζητηθεί να δώσει το ποσό των
αλλαγή σε δολάρια που από όπου και αν οφείλεται.

40
00:02:07,270 --> 00:02:11,140
Και τότε η έξοδος του προγράμματος θέλησή σας
το ελάχιστο ποσό των κερμάτων

41
00:02:11,140 --> 00:02:14,740
ότι ο άπληστος ταμείο θα χρησιμοποιήσετε
για να κάνουν το ποσό της αλλαγής.

42
00:02:14,740 --> 00:02:18,160
>> Έτσι τώρα ας σπάσει αυτό το
κάτω σε δευτερεύουσες εργασίες μας.

43
00:02:18,160 --> 00:02:21,410
Πρώτα θα πάμε να παρακινήσει μας
χρήστη για το ποσό της αλλαγής.

44
00:02:21,410 --> 00:02:25,630
Και, όπως συμβαίνει με κάθε είσοδο του χρήστη, θέλουμε να
βεβαιωθείτε ότι θα επικυρώσετε ότι εισόδου

45
00:02:25,630 --> 00:02:29,360
και να διασφαλίσουμε ότι μπορούμε να χρησιμοποιήσουμε ότι
εισόδου για το υπόλοιπο του προγράμματος μας.

46
00:02:29,360 --> 00:02:32,480
Στη συνέχεια θα πάμε να είναι πάντα
χρησιμοποιούν το μεγαλύτερο δυνατό σημείο

47
00:02:32,480 --> 00:02:35,240
και να παρακολουθείτε τα νομίσματα που χρησιμοποιούνται.

48
00:02:35,240 --> 00:02:39,080
Και τέλος, να εκτυπώσετε την τελική
αριθμός των κερμάτων που χρησιμοποιήσαμε.

49
00:02:39,080 --> 00:02:40,970
>> Έτσι, ας μιλήσουμε για ειδοποίηση.

50
00:02:40,970 --> 00:02:43,550
Το ποσό που πρέπει να κάνει σεντ,
και αυτό είναι σε δολάρια.

51
00:02:43,550 --> 00:02:48,440
Και έτσι για δολάρια, θα πάμε
να χρησιμοποιήσει τον τύπο μεταβλητής πλωτήρα.

52
00:02:48,440 --> 00:02:52,390
Τώρα κάθε φορά που θα ζητήσετε από ένα χρήστη για την είσοδο,
θέλετε να βεβαιωθείτε ότι είναι έγκυρο.

53
00:02:52,390 --> 00:02:56,640
Και έτσι εδώ θα ήθελα να επωφεληθώ
της κατασκευής do-while loop.

54
00:02:56,640 --> 00:03:00,320
>> Μια do-while loop θα εκτελέσει το
σώμα του βρόχου τουλάχιστον μία φορά.

55
00:03:00,320 --> 00:03:01,650
Έτσι, αυτό έρχεται σε πρακτικό.

56
00:03:01,650 --> 00:03:05,510
Γνωρίζουμε ότι πρέπει να ζητήσει η
χρήστη, τουλάχιστον μία φορά για ένα πλωτήρα.

57
00:03:05,510 --> 00:03:07,100
Τώρα αν αυτό float είναι έγκυρη.

58
00:03:07,100 --> 00:03:07,710
Αυτό είναι υπέροχο.

59
00:03:07,710 --> 00:03:08,460
Μπορούμε να προχωρήσουμε.

60
00:03:08,460 --> 00:03:11,910
Αλλά αν όχι, ο βρόχος θα εξασφαλίσει
ότι έχουμε μια σωστή πλωτήρα

61
00:03:11,910 --> 00:03:16,810
επαναλαμβάνοντας συνεχώς μέχρι
ο χρήστης μας δίνει μια έγκυρη τιμή.

62
00:03:16,810 --> 00:03:18,760
>> Τώρα για το do-while
προϋπόθεση του βρόχου, χρειαζόμαστε

63
00:03:18,760 --> 00:03:22,000
να εξετάσει τι σημαίνει
να έχουν μια μη έγκυρη float.

64
00:03:22,000 --> 00:03:24,220
Έτσι, για το πλαίσιο της
αυτό το πρόβλημα, ίσως

65
00:03:24,220 --> 00:03:27,450
είναι λογικό μόνο για να
δεχθεί θετικές τιμές.

66
00:03:27,450 --> 00:03:32,010
>> Έτσι κινείται on-- έχουμε λαμβάνεται μια
αξία σε δολάρια από το χρήστη.

67
00:03:32,010 --> 00:03:35,380
Αλλά έχουμε να κάνουμε με κέρματα,
τα οποία είναι εξ ολοκλήρου σε σεντ.

68
00:03:35,380 --> 00:03:38,660
$ 1 ισοδυναμεί με 100 cents.

69
00:03:38,660 --> 00:03:43,670
Έτσι, ένα καλό πράγμα που πρέπει να κάνουμε είναι να
μετατρέπουν αυτές τις αξίες σε σεντ.

70
00:03:43,670 --> 00:03:48,380
>> Τώρα, κατά τη μετατροπή από ένα πλωτήρα
σε ακέραιο, έτσι δολάρια για να σεντς,

71
00:03:48,380 --> 00:03:52,230
θέλουμε να διασφαλίσουμε ότι είμαστε προσεκτικοί
σχετικά με floating-point ανακρίβεια.

72
00:03:52,230 --> 00:03:55,260
Έτσι, αυτό σημαίνει ότι ερμήνευα-- λένε
δολάριο μου value-- float μου

73
00:03:55,260 --> 00:04:00,260
value-- ήταν ένα ακόμη $ 2, εξακολουθούν να υπάρχουν
μπορεί να είναι κάποια αδέσποτα αριθμούς εκεί.

74
00:04:00,260 --> 00:04:04,590
Έτσι, θέλουμε να βεβαιωθείτε ότι δεν είναι μόνο
εμείς πολλαπλασιάζουμε με το 100 για να πάρει τα σεντ,

75
00:04:04,590 --> 00:04:06,480
αλλά το στρογγυλοποιεί επίσης μακριά.

76
00:04:06,480 --> 00:04:09,210
>> Έτσι τώρα έχουμε το ποσό
της αλλαγής οφείλεται στον χρήστη.

77
00:04:09,210 --> 00:04:13,430
Εμείς απέκτησε αρχικά σε δολάρια,
και τώρα το έχουμε μετατραπεί σε σεντ.

78
00:04:13,430 --> 00:04:17,029
Έτσι τώρα μπορούμε να προχωρήσουμε με την καρδιά της
ο άπληστος αλγόριθμος, ο οποίος είναι πάντα

79
00:04:17,029 --> 00:04:19,220
χρησιμοποιώντας το μεγαλύτερο κέρμα είναι δυνατόν.

80
00:04:19,220 --> 00:04:21,930
Ενώ κάνουμε αυτό,
Είναι σημαντικό να έχουμε επίσης

81
00:04:21,930 --> 00:04:25,360
να παρακολουθείτε πόσα κέρματα
πρόκειται να επιστραφεί στον χρήστη

82
00:04:25,360 --> 00:04:28,630
καθώς επίσης και το υπόλοιπο
αλλάξετε οφείλεται στον χρήστη.

83
00:04:28,630 --> 00:04:31,130
>> Το πρόγραμμα θα εξετάσει
κάτι σαν αυτό.

84
00:04:31,130 --> 00:04:34,190
Μετά μπορείτε να πάρετε το ποσό της
δολάρια και να μετατρέψει αυτό σε σεντ,

85
00:04:34,190 --> 00:04:35,790
τότε θα εισάγετε ένα βρόχο.

86
00:04:35,790 --> 00:04:38,400
Ενώ τρίμηνα μπορεί να είναι
used-- δηλαδή

87
00:04:38,400 --> 00:04:43,660
ενώ το ποσό της μεταβολής που οφείλονται στην
αυτό είναι μεγαλύτερο από ή ίσο με το $ 0,25,

88
00:04:43,660 --> 00:04:45,040
θα χρησιμοποιήσετε ένα τέταρτο.

89
00:04:45,040 --> 00:04:47,000
>> Τώρα τι κάνει χρησιμοποιώντας ένα τέταρτο συνεπάγεται;

90
00:04:47,000 --> 00:04:51,280
Λοιπόν, ένα-- θα αυξήσετε το κέρμα
υπολογίζει να επιστρέψει στον χρήστη.

91
00:04:51,280 --> 00:04:55,890
Και δεύτερο, θα μειώσετε την τρέχουσα
ποσό της μεταβολής οφείλεται πίσω στο χρήστη

92
00:04:55,890 --> 00:04:57,520
από $ 0,25.

93
00:04:57,520 --> 00:05:00,680
>> Μετά επαναλαμβάνοντας ότι μέχρι
τρίμηνα δεν μπορεί πλέον να χρησιμοποιηθεί,

94
00:05:00,680 --> 00:05:04,630
προχωρήστε στο επόμενο μεγαλύτερο
coin-- σε αυτήν την περίπτωση δεκάρες, $ 0.10.

95
00:05:04,630 --> 00:05:07,750
Έτσι θα εισέλθει σε αυτή τη θηλιά μέχρι
δεν μπορείτε πλέον να χρησιμοποιήσετε δεκάρες.

96
00:05:07,750 --> 00:05:10,720
Στη συνέχεια, προχωρήστε στο επόμενο
μεγαλύτερο κέρμα, επινικελώνουν.

97
00:05:10,720 --> 00:05:14,810
Μετά δεν μπορεί πλέον να χρησιμοποιηθεί επινικελώνουν,
χρησιμοποιήσετε το υπόλοιπο ποσό σε πένες.

98
00:05:14,810 --> 00:05:17,800
Και τέλος, εκτυπώστε το
αριθμός κερμάτων που χρησιμοποιείται.

99
00:05:17,800 --> 00:05:20,350
>> Ένας άλλος τρόπος που μπορείτε να
προσεγγίσει το πρόβλημα άπληστους

100
00:05:20,350 --> 00:05:22,950
είναι να χρησιμοποιήσετε την προσέγγιση modulo.

101
00:05:22,950 --> 00:05:25,690
Modulo είναι ένας φορέας
ότι επιστρέφει το υπόλοιπο

102
00:05:25,690 --> 00:05:27,680
της διαίρεσης μεταξύ των δύο αριθμών.

103
00:05:27,680 --> 00:05:30,270
Πω ότι είχα 50 mod 5.

104
00:05:30,270 --> 00:05:34,070
Λοιπόν, 5 είναι ένας παράγοντας του 50,
οπότε το υπόλοιπο θα είναι 0.

105
00:05:34,070 --> 00:05:39,230
50 mod 10-- καλά, 10 είναι επίσης ένας παράγοντας
50, έτσι ώστε το υπόλοιπο είναι επίσης μηδέν.

106
00:05:39,230 --> 00:05:43,660
50 mod 50-- καλά, οποιοσδήποτε αριθμός ίδια mod
δεν πρόκειται να έχουν κανένα υπόλοιπο.

107
00:05:43,660 --> 00:05:45,510
>> Τι περίπου 50 mod 49;

108
00:05:45,510 --> 00:05:47,910
Λοιπόν, 49 πηγαίνει μόνο στο 50 μία φορά.

109
00:05:47,910 --> 00:05:50,290
Έτσι, το υπόλοιπο θα είναι 1.

110
00:05:50,290 --> 00:05:55,180
53 mod 50 πρόκειται να
σας δώσει ένα υπόλοιπο 3.

111
00:05:55,180 --> 00:05:59,120
>> Λοιπόν, πώς μπορούμε να χρησιμοποιήσουμε modulo
και ίσως κάποια διαίρεση

112
00:05:59,120 --> 00:06:01,690
για την εφαρμογή άπληστος αλγόριθμος μας;

113
00:06:01,690 --> 00:06:05,550
Λοιπόν, εμείς εξακολουθούμε να θέλουμε να μείνει πιστή στην
καρδιά του άπληστοι algorithm-- ότι

114
00:06:05,550 --> 00:06:07,910
είναι με τη χρήση όσο το δυνατόν μεγαλύτερο κέρμα.

115
00:06:07,910 --> 00:06:14,570
>> Ας αναρωτηθούμε αν μπορούμε να χρησιμοποιήσουμε οποιοδήποτε
τρίμηνα για να επιστρέψει $ 0,32 για το χρήστη.

116
00:06:14,570 --> 00:06:20,070
Λοιπόν, 32 mod 25 δίνει
μας ένα υπόλοιπο $ 0.07.

117
00:06:20,070 --> 00:06:24,500
Έτσι ώστε να μας λέει ότι μπορούμε σίγουρα
χρησιμοποιήστε ένα τέταρτο με $ 0.07 υπόλοιπα.

118
00:06:24,500 --> 00:06:26,180
>> Μπορούμε στη συνέχεια να χρησιμοποιήσουν οποιαδήποτε δεκάρες;

119
00:06:26,180 --> 00:06:32,740
Λοιπόν, no-- επειδή $ 0.07 mod
$ 0.10 μας δίνει ένα υπόλοιπο 7.

120
00:06:32,740 --> 00:06:34,960
10 δεν πάει σε 7 καθόλου.

121
00:06:34,960 --> 00:06:36,390
>> Στη συνέχεια, μπορούμε να χρησιμοποιήσουμε σεντς;

122
00:06:36,390 --> 00:06:40,490
Λοιπόν $ 0.07 mod 5 σεντ
μας δίνει δύο που απομένουν.

123
00:06:40,490 --> 00:06:42,930
Και τέλος, μπορούμε να χρησιμοποιήσουμε οποιαδήποτε πένες;

124
00:06:42,930 --> 00:06:45,930
2 mod 1 μας δίνει 0,
το οποίο είναι τελικά αυτό

125
00:06:45,930 --> 00:06:48,160
θέλουμε γιατί τότε ότι
σημαίνει ότι έχουμε επιστρέψει

126
00:06:48,160 --> 00:06:50,160
στο χρήστη όλες οι μεταβολές που οφείλονται.

127
00:06:50,160 --> 00:06:54,320
>> Έτσι τώρα έχετε δύο πιθανούς τρόπους
για την εφαρμογή της άπληστοι algorithm--

128
00:06:54,320 --> 00:06:59,230
ένα με βρόχους και ένα με ένα
συνδυασμός modulo και της διαίρεσης.

129
00:06:59,230 --> 00:07:03,010
Έτσι, τελικά, εμείς απλά πρέπει να
εκτυπώστε το τελικό αριθμό των κερμάτων.

130
00:07:03,010 --> 00:07:06,520
>> Αν ήθελα να σας πω ότι είχα πει
3 κατοικίδια ζώα και αυτή η αξία είναι ενσωματωμένες,

131
00:07:06,520 --> 00:07:09,240
τότε θα μπορούσε να χρησιμοποιήσει μόνο ένα
απλή δήλωση δοκιμαστικής εκτύπωσης.

132
00:07:09,240 --> 00:07:12,320
Αλλά η αξία μας είναι στην πραγματικότητα
αποθηκεύεται σε μια μεταβλητή.

133
00:07:12,320 --> 00:07:15,260
Τόσο πώς μπορείτε να εκτυπώσετε το
τιμές που αποθηκεύονται στις μεταβλητές;

134
00:07:15,260 --> 00:07:17,880
>> Γι 'αυτό παίρνουμε
πλεονέκτημα της κράτησης θέσης.

135
00:07:17,880 --> 00:07:21,540
Πείτε μου είχε ήδη δηλωθεί
προετοιμασμένου ακέραιο n.

136
00:07:21,540 --> 00:07:25,170
Στη συνέχεια, αργότερα, αν ήθελα να εκτυπώσετε ότι
αξίας, τότε θα ήθελα να γράψω το string.

137
00:07:25,170 --> 00:07:30,500
Και αντί αυτής της αξίας θα χρησιμοποιήσετε
ένα σύμβολο κράτησης θέσης για το συγκεκριμένο integer--% i.

138
00:07:30,500 --> 00:07:33,800
Στη συνέχεια, μετά το string, έχω ένα
κόμμα, ακολουθούμενη από την μεταβλητή

139
00:07:33,800 --> 00:07:34,950
ότι θέλω να εκτυπώσετε.

140
00:07:34,950 --> 00:07:38,550
Και αργότερα, όταν εκτυπώνει,
αυτό θα εκτυπώσετε την τιμή του n.

141
00:07:38,550 --> 00:07:41,570
>> Θα μπορούσα επίσης να χρησιμοποιήσετε ένα σύμβολο κράτησης θέσης
για ένα φλοτέρ, για παράδειγμα.

142
00:07:41,570 --> 00:07:44,000
Αν ήθελα να σας πω πόσο
πολύ χρήμα έχω στην τσέπη μου,

143
00:07:44,000 --> 00:07:46,820
τότε θα μπορούσα να πω ότι έχω δολάρια% f.

144
00:07:46,820 --> 00:07:51,330
Και αργότερα, όταν εκτυπώνεται, τότε η θα
να πάρει τη θέση του εν λόγω κατόχου θέση.

145
00:07:51,330 --> 00:07:55,530
Θα μπορούσε επίσης, για παράδειγμα, να χρησιμοποιούν διάφορες
κράτησης θέσης για αρκετές μεταβλητές.

146
00:07:55,530 --> 00:07:57,590
Έτσι, όσο μπορώ λίστα
τους, προκειμένου, στη συνέχεια, θα

147
00:07:57,590 --> 00:08:00,390
μπορεί να σας πει πόσα
σκύλους και γάτες που έχω.

148
00:08:00,390 --> 00:08:03,710
>> Τώρα ξέρουμε πώς να παρακινήσει το
χρήστη για ένα ποσό της μεταβολής,

149
00:08:03,710 --> 00:08:06,130
διασφαλιστεί ότι εισόδου
είναι έγκυρη, και στη συνέχεια θα

150
00:08:06,130 --> 00:08:10,370
έχει δύο δυνατούς τρόπους εφαρμογής
ο άπληστος αλγόριθμος χρησιμοποιώντας πάντα

151
00:08:10,370 --> 00:08:12,090
ο μεγαλύτερος δυνατός κέρμα.

152
00:08:12,090 --> 00:08:15,050
Επειδή έχουμε κρατήσει παρακολουθείτε
πόσα κέρματα που χρησιμοποιούμε,

153
00:08:15,050 --> 00:08:19,210
μπορούμε στη συνέχεια να εκτυπώσετε την τιμή αυτή στο τέλος,
λέει στον χρήστη πόσα κέρματα από όπου και αν

154
00:08:19,210 --> 00:08:20,240
να πάρει πίσω.

155
00:08:20,240 --> 00:08:24,240
>> Το όνομά μου είναι ο Amayla, και αυτό είναι CS50.

156
00:08:24,240 --> 00:08:25,915

