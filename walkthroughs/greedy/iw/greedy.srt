1
00:00:00,000 --> 00:00:00,710

2
00:00:00,710 --> 00:00:02,900
>> בואו נעשים חמדנים.

3
00:00:02,900 --> 00:00:06,810
בשנת חמדנים, תפקידנו הוא לשחק
את התפקיד של קופאית חמדנים.

4
00:00:06,810 --> 00:00:09,750
המשתמש יגיד לנו איך
שינוי הרבה שאנו חייבים להם,

5
00:00:09,750 --> 00:00:13,520
ואז תפקידנו הוא לחשב
המספר המזערי של מטבעות

6
00:00:13,520 --> 00:00:17,240
כי אנחנו יכולים להשתמש בו כדי להפוך את
כי סכום השינוי.

7
00:00:17,240 --> 00:00:19,560
>> בואו נתחיל עם דוגמה.

8
00:00:19,560 --> 00:00:23,170
תגיד המשתמש דורש 0.32 $ בחזרה.

9
00:00:23,170 --> 00:00:28,960
אנחנו יכולים לעשות זאת על ידי מתן
אותם 32 פרוטות, סנט אחד כל אחד.

10
00:00:28,960 --> 00:00:35,180
או שאני יכול להשתמש גם חמישה coins-- ידי
לתת להם שלושה מטבעות, 0.10 $ כל אחד,

11
00:00:35,180 --> 00:00:38,060
ושתי פרוטות, 0.02 $ כל אחד.

12
00:00:38,060 --> 00:00:42,580
אבל אנחנו יכולים להשתמש גם
מטבעות פחות לעשות את זה?

13
00:00:42,580 --> 00:00:45,100
>> הטקטיקה השלמה greedy--
להיות cashier-- חמדנים

14
00:00:45,100 --> 00:00:47,600
היא להשתמש האפשר את המטבעות הגדולים.

15
00:00:47,600 --> 00:00:50,670
לכן, בכל פעם שיש לנו
רבעים נשתמש בהן.

16
00:00:50,670 --> 00:00:54,100
ואז פעם אלה נגמרים,
נשתמש מטבעות, 0.10 $ כל אחד.

17
00:00:54,100 --> 00:00:58,840
ואז מטבעות, 5 סנט כל אחד,
אז עד פרוטות, סנט אחד כל אחד.

18
00:00:58,840 --> 00:01:01,792
באמצעות המטבעות הגדולים
אפשרי בכל פעם שאנחנו יכולים,

19
00:01:01,792 --> 00:01:07,350
אנו מבטיחים כי אנו משתמשים המספר הקטן ביותר
מטבעות ניתן לבצע את השינוי.

20
00:01:07,350 --> 00:01:09,180
>> אז נעבור זה.

21
00:01:09,180 --> 00:01:11,660
המשתמש צריך 0.32 $.

22
00:01:11,660 --> 00:01:14,200
אז אנחנו שואלים את עצמנו,
אנחנו יכולים להשתמש רק ברבע?

23
00:01:14,200 --> 00:01:15,560
ובכן, כן, אנחנו יכולים.

24
00:01:15,560 --> 00:01:19,720
אז עכשיו אנחנו רק יודעים אותם
0.07 $, והשתמשנו מטבע אחד.

25
00:01:19,720 --> 00:01:20,970
>> האם אנחנו יכולים להשתמש רבעון נוסף?

26
00:01:20,970 --> 00:01:21,890
ובכן לא.

27
00:01:21,890 --> 00:01:27,570
0.07 $ הם פחות מ 0.25 $, ולכן נתקדם
אל המטבעות הגדולים הזמין הבא.

28
00:01:27,570 --> 00:01:30,690
פרוטות הן 0.10 $, ו
שוב, אנחנו לא יכולים להשתמש מטבעות.

29
00:01:30,690 --> 00:01:35,480
מכיוון מטבעות שווות 0.10 $, אשר
הוא יותר מאשר סכום השינוי חייב.

30
00:01:35,480 --> 00:01:36,790
>> אנחנו הולכים מטבעות.

31
00:01:36,790 --> 00:01:40,890
וגם, אכן כן, 0.05 $ הם פחות מ
0.10-- $ כדי שנוכל להשתמש ניקל.

32
00:01:40,890 --> 00:01:46,104
אז עכשיו אנחנו רק חייבים המשתמשים 0.02 $,
ואנחנו עד כה השתמשנו שני מטבעים.

33
00:01:46,104 --> 00:01:47,270
אנחנו לא יכולים להשתמש ניקל אחר.

34
00:01:47,270 --> 00:01:51,140
אז נמשיך המטבע האחרון
לרשותנו, אשר הן פרוט.

35
00:01:51,140 --> 00:01:52,270
>> ואנחנו יכולים להשתמש אגורה?

36
00:01:52,270 --> 00:01:59,060
ובכן, yes-- ואנחנו בסופו של דבר באמצעות שני
פרוטות עבור סכום כולל של ארבע מטבעות.

37
00:01:59,060 --> 00:02:01,430
>> לאחר שתסיים, את
תוכנית יראה ככה.

38
00:02:01,430 --> 00:02:03,710
ברגע שהמשתמש מפעיל את
יהיו תכנית חמדנים, הם

39
00:02:03,710 --> 00:02:07,270
שיתבקש לתת את הסכום של
שינוי בדולרים שהם חייבים.

40
00:02:07,270 --> 00:02:11,140
ואז פלט יתכנת שלך
את הסכום המינימלי של מטבעות

41
00:02:11,140 --> 00:02:14,740
כי קופאית החמדנים תשתמש
כדי לעשות את זה סכום השינוי.

42
00:02:14,740 --> 00:02:18,160
>> אז עכשיו בואו לשבור את זה
למטה לתוך תת הפעילויות שלנו.

43
00:02:18,160 --> 00:02:21,410
ראשית אנחנו הולכים לבקש שלנו
המשתמש בסכום של שינוי.

44
00:02:21,410 --> 00:02:25,630
וגם, כמו עם כל קלט משתמש, אנחנו רוצים
לוודא שאנחנו לאמת קלט

45
00:02:25,630 --> 00:02:29,360
ולהבטיח כי אנו יכולים להשתמש בזה
קלט עבור שאר התוכנית שלנו.

46
00:02:29,360 --> 00:02:32,480
ואז אנחנו הולכים תמיד
להשתמש בנקודה הגדולה ביותר האפשרית

47
00:02:32,480 --> 00:02:35,240
ולעקוב אחר של מטבעות בשימוש.

48
00:02:35,240 --> 00:02:39,080
ולבסוף, להדפיס בגמר
מספר המטבעות כי השתמשנו.

49
00:02:39,080 --> 00:02:40,970
>> אז בואו נדבר על מה שגרם.

50
00:02:40,970 --> 00:02:43,550
הסכום חייב לעשות סנט,
וזה בדולרים.

51
00:02:43,550 --> 00:02:48,440
וכך במשך דולרים, אנחנו הולכים
כדי להשתמש בסוג המשתנה לצוף.

52
00:02:48,440 --> 00:02:52,390
עכשיו בכל פעם אתה שואל משתמש עבור קלט,
אתה רוצה לוודא שזה חוקי.

53
00:02:52,390 --> 00:02:56,640
אז הנה אנחנו אוהבים לנצל
של לבנות לולאה עשה מה.

54
00:02:56,640 --> 00:03:00,320
>> לולאת do-תוך תריץ את
גוף של הלולאה לפחות פעם אחת.

55
00:03:00,320 --> 00:03:01,650
אז זה שימושי.

56
00:03:01,650 --> 00:03:05,510
אנחנו יודעים שאנחנו צריכים להנחות את
המשתמש לפחות פעם אחת עבור לצוף.

57
00:03:05,510 --> 00:03:07,100
עכשיו, אם כי לצוף תקף.

58
00:03:07,100 --> 00:03:07,710
זה מצוין.

59
00:03:07,710 --> 00:03:08,460
אנחנו עוברים הלאה.

60
00:03:08,460 --> 00:03:11,910
אבל אם לא, את הלולאה תבטיח
כי אנחנו מקבלים לצוף נאה

61
00:03:11,910 --> 00:03:16,810
על ידי חזרה ברציפות עד
המשתמש נותן לנו ערך חוקי.

62
00:03:16,810 --> 00:03:18,760
>> עכשיו עבור-בזמן מטלות
תנאי לולאה, אנחנו צריכים

63
00:03:18,760 --> 00:03:22,000
לשקול מה זה אומר
צריך לצוף חוקי.

64
00:03:22,000 --> 00:03:24,220
אז עבור בהקשר של
בעיה זו, כנראה

65
00:03:24,220 --> 00:03:27,450
זה הגיוני רק כדי
לקבל ערכים חיוביים.

66
00:03:27,450 --> 00:03:32,010
>> אז נעים on-- שמנו השיג
ערך בדולרים מהמשתמש.

67
00:03:32,010 --> 00:03:35,380
אבל יש לנו עסק עם מטבעות,
שהן לגמרי בסנטים.

68
00:03:35,380 --> 00:03:38,660
1 $ שווה 100 סנט.

69
00:03:38,660 --> 00:03:43,670
אז דבר טוב לעשות הוא
להמיר את הערכים האלה לתוך הסנאט.

70
00:03:43,670 --> 00:03:48,380
>> עכשיו בעת המרה מתוך לצוף
למספר שלם, ולכן דולרים סנט,

71
00:03:48,380 --> 00:03:52,230
אנחנו רוצים לוודא כי שנזהרנו
על חוסר הדיוק של נקודה צפה.

72
00:03:52,230 --> 00:03:55,260
אז זה אומר ש-- לומר
הדולר שלי value-- לצוף שלי

73
00:03:55,260 --> 00:04:00,260
value-- היה אפילו 2 $, עדיין שם
יכול להיות כמה מספרים תועה שם.

74
00:04:00,260 --> 00:04:04,590
אז אנחנו רוצים לוודא כי לא רק
אנחנו להכפיל ב -100 כדי לקבל את הסנאט,

75
00:04:04,590 --> 00:04:06,480
אבל אנחנו גם נעגל.

76
00:04:06,480 --> 00:04:09,210
>> אז עכשיו יש לנו את הסכום
השינוי חייב למשתמש.

77
00:04:09,210 --> 00:04:13,430
אנחנו במקור השיגו אותם בדולרים,
ועכשיו אנחנו כבר תרגמנו אותו הסנאט.

78
00:04:13,430 --> 00:04:17,029
אז עכשיו אנחנו יכולים להמשיך עם הלב
אלגוריתם החמדנים, וזה תמיד

79
00:04:17,029 --> 00:04:19,220
באמצעות המטבע הגדול ביותר האפשרי.

80
00:04:19,220 --> 00:04:21,930
למרות שאנו עושים את זה,
זה חשוב כי אנחנו גם

81
00:04:21,930 --> 00:04:25,360
לעקוב אחר כמה מטבעות הם
הולך להיות חזר המשתמש

82
00:04:25,360 --> 00:04:28,630
כמו גם את הנותרים
לשנות מגיעי המשתמש.

83
00:04:28,630 --> 00:04:31,130
>> התכנית תיראה
משהו כזה.

84
00:04:31,130 --> 00:04:34,190
לאחר שתקבל את הסכום של
דולרים ולהמיר שכדי סנט,

85
00:04:34,190 --> 00:04:35,790
ולאחר מכן תזין לולאה.

86
00:04:35,790 --> 00:04:38,400
בעוד רבע יכולים להיות
used-- כלומר

87
00:04:38,400 --> 00:04:43,660
בעוד סכום השינוי המגיעים
המשתמש הוא גדול או שווה ל 0.25 $,

88
00:04:43,660 --> 00:04:45,040
תוכל להשתמש רק ברבע.

89
00:04:45,040 --> 00:04:47,000
>> עכשיו מה עושה שימוש רבע כרוך?

90
00:04:47,000 --> 00:04:51,280
ובכן, one-- תוכל להגדיל את המטבע
לספור עד יוחזר אל המשתמש.

91
00:04:51,280 --> 00:04:55,890
ושנית זה יקטין את הנוכחי
סכום השינוי חייב בחזרה למשתמש

92
00:04:55,890 --> 00:04:57,520
ב -0.25 $.

93
00:04:57,520 --> 00:05:00,680
>> לאחר שנה נוספת שעד
רבעים לא ניתן עוד להשתמש,

94
00:05:00,680 --> 00:05:04,630
להמשיך למקום הבא הגדול
coin-- ב מטבעות במקרה זה, 0.10 $.

95
00:05:04,630 --> 00:05:07,750
אז תזין כי לולאה עד
אתה כבר לא יכול להשתמש מטבעות.

96
00:05:07,750 --> 00:05:10,720
ואז להמשיך לשלב הבא
מטבעים גדולים, מטבעות.

97
00:05:10,720 --> 00:05:14,810
לאחר מטבעות כבר לא יכול לשמש,
להשתמש הסכום הנותר פרוטות.

98
00:05:14,810 --> 00:05:17,800
ולבסוף, להדפיס את
מספר המטבעות בשימוש.

99
00:05:17,800 --> 00:05:20,350
>> דרך נוספת שאתה יכול
ניגשים לבעיה חמדנים

100
00:05:20,350 --> 00:05:22,950
הוא להשתמש בגישת מודולו.

101
00:05:22,950 --> 00:05:25,690
מודולו הוא מפעיל
המחזיר את השארית

102
00:05:25,690 --> 00:05:27,680
של החלוקה בין שני מספרים.

103
00:05:27,680 --> 00:05:30,270
שאצהיר 50 mod 5.

104
00:05:30,270 --> 00:05:34,070
ובכן, 5 הוא גורם של 50,
כך והשאר יהיה 0.

105
00:05:34,070 --> 00:05:39,230
50 mod 10-- היטב, 10 הוא גם גורם
של 50, אז השארית היא גם 0.

106
00:05:39,230 --> 00:05:43,660
50 mod 50-- היטב, כל מספר mod עצמו
לא הולך להיות כל שארית.

107
00:05:43,660 --> 00:05:45,510
>> מה לגבי 50 mod 49?

108
00:05:45,510 --> 00:05:47,910
ובכן, 49 רק נכנס 50 פעם.

109
00:05:47,910 --> 00:05:50,290
אז והשאר הולך להיות 1.

110
00:05:50,290 --> 00:05:55,180
53 mod 50 הולכים
לתת לך שארית 3.

111
00:05:55,180 --> 00:05:59,120
>> אז איך אנחנו יכולים להשתמש מודולו
ואולי קצת חלוקה

112
00:05:59,120 --> 00:06:01,690
ליישם אלגוריתם חמדן שלנו?

113
00:06:01,690 --> 00:06:05,550
ובכן, אנחנו עדיין רוצים להישאר נאמנים
בלב החמדנים algorithm-- כי

114
00:06:05,550 --> 00:06:07,910
הוא באמצעות המטבע הגדול ביותר האפשרי.

115
00:06:07,910 --> 00:06:14,570
>> אז בואו נשאל את עצמנו אם אנחנו יכולים להשתמש בכל
רבע לחזור 0.32 $ למשתמש.

116
00:06:14,570 --> 00:06:20,070
ובכן, 32 mod 25 נותן
לנו שארית 0.07 $.

117
00:06:20,070 --> 00:06:24,500
אז זה אומר לנו שאנחנו יכולים בהחלט
להשתמש רבע עם 0.07 $ הנותרים.

118
00:06:24,500 --> 00:06:26,180
>> אז אנחנו יכולים להשתמש בכל מטבעות?

119
00:06:26,180 --> 00:06:32,740
ובכן, no-- משום 0.07 $ mod
0.10 $ נותנים לנו שארית 7.

120
00:06:32,740 --> 00:06:34,960
10 אינו נכנס 7 בכלל.

121
00:06:34,960 --> 00:06:36,390
>> אז נוכל להשתמש מטבעות?

122
00:06:36,390 --> 00:06:40,490
ובכן 0.07 $ mod 5 סנט
נותן לנו שני הנותרים.

123
00:06:40,490 --> 00:06:42,930
ולבסוף, אנו יכולים להשתמש בכל פרוטות?

124
00:06:42,930 --> 00:06:45,930
2 mod 1 נותן לנו 0,
וזה בסופו של דבר מה

125
00:06:45,930 --> 00:06:48,160
אנחנו רוצים כי אז כי
כלומר חזרנו

126
00:06:48,160 --> 00:06:50,160
למשתמש כל שינוי חייב.

127
00:06:50,160 --> 00:06:54,320
>> אז עכשיו יש לך שתי אפשרויות
יישום algorithm-- החמדנים

128
00:06:54,320 --> 00:06:59,230
אחד עם לולאות אחד עם
שילוב של מודולו וחילוק.

129
00:06:59,230 --> 00:07:03,010
אז בסופו של דבר, אנחנו רק צריכים
להדפיס את מספר המטבעות הסופי.

130
00:07:03,010 --> 00:07:06,520
>> אם רציתי לספר לך שיש לי
3 חיות מחמד וערך זה hardcoded,

131
00:07:06,520 --> 00:07:09,240
אז אני רק יכול להשתמש
הצהרת מבחן הדפסה פשוט.

132
00:07:09,240 --> 00:07:12,320
אבל הערך שלנו הוא למעשה
מאוחסן במשתנה.

133
00:07:12,320 --> 00:07:15,260
אז איך אתה להדפיס את
ערכים מאוחסנים המשתנים?

134
00:07:15,260 --> 00:07:17,880
>> בשביל זה אנחנו לוקחים
היתרון של מצייני מיקום.

135
00:07:17,880 --> 00:07:21,540
תגיד לי כבר הכריז
n השלם מאותחל.

136
00:07:21,540 --> 00:07:25,170
ואז מאוחר יותר אם אני רוצה להדפיס כי
ערך, אז הייתי כותב את המחרוזת.

137
00:07:25,170 --> 00:07:30,500
ובמקום ערך כי הייתי משתמש
מציין מיקום עבור% integer-- i.

138
00:07:30,500 --> 00:07:33,800
ואז אחרי המחרוזת, יש לי
פסיק, ואחריו המשתנה

139
00:07:33,800 --> 00:07:34,950
כי אני רוצה להדפיס.

140
00:07:34,950 --> 00:07:38,550
ובהמשך, כאשר היא מדפיסה,
זה יהיה להדפיס את הערך של n.

141
00:07:38,550 --> 00:07:41,570
>> יכולתי גם להשתמש מציין מיקום
עבור לצוף, למשל.

142
00:07:41,570 --> 00:07:44,000
אם רציתי לספר לך איך
הרבה מזומנים יש לי בכיס שלי,

143
00:07:44,000 --> 00:07:46,820
אז אני יכול לומר שיש לי דולרים% f.

144
00:07:46,820 --> 00:07:51,330
ובהמשך כאשר היא מדפיסה, אז n יהיה
לתפוס את מקומו של בעל המקום ההוא.

145
00:07:51,330 --> 00:07:55,530
יכולתי גם, למשל, להשתמש בכמה
מצייני מיקום עבור מספר משתנים.

146
00:07:55,530 --> 00:07:57,590
אז כל עוד אני ברשימה
אותם בסדר, אז אני

147
00:07:57,590 --> 00:08:00,390
יכול להגיד לך כמה
כלבים וחתולים יש לי.

148
00:08:00,390 --> 00:08:03,710
>> עכשיו אנחנו יודעים כיצד להנחות את
המשתמשים בסכום של שינוי,

149
00:08:03,710 --> 00:08:06,130
להבטיח כי קלט
הוא תקף, ולאחר מכן אנו

150
00:08:06,130 --> 00:08:10,370
יש שתי דרכים אפשריות של יישום
אלגוריתם החמדנים של תמיד באמצעות

151
00:08:10,370 --> 00:08:12,090
המטבע הגדול ביותר האפשרי.

152
00:08:12,090 --> 00:08:15,050
מכיוון שאנחנו כבר ניהלו מעקב אחר
כמה מטבעות אנו משתמשים,

153
00:08:15,050 --> 00:08:19,210
אז אנחנו יכולים להדפיס ערך כי בסוף,
המתריעה בפני המשתמש כמה מטבעות שהם

154
00:08:19,210 --> 00:08:20,240
לחזור.

155
00:08:20,240 --> 00:08:24,240
>> שמי הוא Amayla, וזו CS50.

156
00:08:24,240 --> 00:08:25,915

