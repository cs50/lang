1
00:00:00,000 --> 00:00:00,710

2
00:00:00,710 --> 00:00:02,900
>> მოდით მისაღებად ხარბ.

3
00:00:02,900 --> 00:00:06,810
ხარბ, ჩვენი საქმეა ითამაშოს
როლი ხარბ მოლარე.

4
00:00:06,810 --> 00:00:09,750
მომხმარებლის გეტყვით, თუ როგორ
ბევრი ცვლილება ჩვენ ვალში მათ,

5
00:00:09,750 --> 00:00:13,520
და მაშინ ჩვენი საქმეა გამოთვლა
მინიმალური რაოდენობის მონეტები

6
00:00:13,520 --> 00:00:17,240
რომ ჩვენ შეგვიძლია გამოვიყენოთ, რათა
რომ თანხის ცვლილებას.

7
00:00:17,240 --> 00:00:19,560
>> დავიწყოთ მაგალითად.

8
00:00:19,560 --> 00:00:23,170
ანუ, მომხმარებელს მოითხოვს $ 0.32 უკან.

9
00:00:23,170 --> 00:00:28,960
ჩვენ შეგვიძლია ამის გაკეთება მიერ აძლევდა
მათ 32 pennies, ერთი პროცენტი თითოეული.

10
00:00:28,960 --> 00:00:35,180
ან მე ვერ ხუთ coins-- მიერ
მათთვის სამი dimes, $ 0.10 ყოველი,

11
00:00:35,180 --> 00:00:38,060
და ორი pennies, $ 0.02 თითოეული.

12
00:00:38,060 --> 00:00:42,580
მაგრამ შეიძლება ჩვენ ვიყენებთ კი
ნაკლები მონეტები, რათა, რომ?

13
00:00:42,580 --> 00:00:45,100
>> მთელი ტაქტიკა greedy--
უნდა ხარბ cashier--

14
00:00:45,100 --> 00:00:47,600
არის გამოიყენოს უდიდესი მონეტა შესაძლებელი.

15
00:00:47,600 --> 00:00:50,670
ასე რომ, როდესაც ჩვენ
მეოთხედი ჩვენ ვიყენებთ მათ.

16
00:00:50,670 --> 00:00:54,100
და მერე კიდევ იმ ამოიწურა,
ჩვენ ვიყენებთ dimes, $ 0.10 თითოეული.

17
00:00:54,100 --> 00:00:58,840
შემდეგ nickels, 5 ცენტი ყოველი, და
მაშინ ქვემოთ pennies, ერთი პროცენტი თითოეული.

18
00:00:58,840 --> 00:01:01,792
გამოყენებით უდიდესი მონეტა
შესაძლებელია, როდესაც შეგვიძლია,

19
00:01:01,792 --> 00:01:07,350
ჩვენ უზრუნველყოს, რომ ჩვენ ვიყენებთ ნაკლები
მონეტები შესაძლებელია, რათა ცვლილება.

20
00:01:07,350 --> 00:01:09,180
>> მოდით ფეხით ამ გზით.

21
00:01:09,180 --> 00:01:11,660
მომხმარებელს სჭირდება $ 0.32.

22
00:01:11,660 --> 00:01:14,200
ასე რომ დავუსვათ საკუთარ თავს,
შეგვიძლია გამოვიყენოთ მეოთხედი?

23
00:01:14,200 --> 00:01:15,560
ისე, დიახ, ჩვენ შეგვიძლია.

24
00:01:15,560 --> 00:01:19,720
ასე რომ, ახლა ჩვენ მხოლოდ ვიცით, მათ
$ 0.07, და ჩვენ ერთი მონეტა.

25
00:01:19,720 --> 00:01:20,970
>> შეგვიძლია გამოვიყენოთ სხვა კვარტალში?

26
00:01:20,970 --> 00:01:21,890
ისე, არ.

27
00:01:21,890 --> 00:01:27,570
$ 0.07 ნაკლებია, ვიდრე $ 0.25, ამიტომ ჩვენ გააგრძელოს
მომდევნო უდიდესი მონეტა შესაძლებელი.

28
00:01:27,570 --> 00:01:30,690
Dimes არის $ 0.10, და
კიდევ ერთხელ, ჩვენ ვერ გამოიყენებს dimes.

29
00:01:30,690 --> 00:01:35,480
იმის გამო, რომ dimes ღირს $ 0.10, რომელიც
უფრო მეტია, ვიდრე თანხის ცვლილება კუთვნილს.

30
00:01:35,480 --> 00:01:36,790
>> ჩვენ წასვლა nickels.

31
00:01:36,790 --> 00:01:40,890
და, დიახ, მართლაც, $ 0.05 ნაკლებია, ვიდრე
$ 0.10-- ასე რომ ჩვენ შეგვიძლია გამოვიყენოთ ნიკელის.

32
00:01:40,890 --> 00:01:46,104
ასე რომ, ახლა ჩვენ მხოლოდ ვალში შესახებ $ 0.02
და ჩვენ ჯერჯერობით გამოიყენება ორი მონეტა.

33
00:01:46,104 --> 00:01:47,270
ჩვენ არ შეგვიძლია გამოვიყენოთ სხვა ნიკელს.

34
00:01:47,270 --> 00:01:51,140
ასე რომ, ჩვენ გააგრძელოთ ბოლო მონეტა
ჩვენს ხელთ, რომლებიც pennies.

35
00:01:51,140 --> 00:01:52,270
>> და შეგვიძლია გამოვიყენოთ penny?

36
00:01:52,270 --> 00:01:59,060
ისე, yes-- და ჩვენ დასრულდება მდე გამოყენებით ორი
pennies for სულ ოთხი მონეტები.

37
00:01:59,060 --> 00:02:01,430
>> მას შემდეგ, რაც თქვენ დასრულდა,
პროგრამა გამოიყურება მოსწონს ეს.

38
00:02:01,430 --> 00:02:03,710
მას შემდეგ, რაც შესახებ ეშვება
ხარბ პროგრამა, ისინი

39
00:02:03,710 --> 00:02:07,270
მოთხოვნილია იძლევა თანხის
ცვლილება დოლარი, რომ ისინი კუთვნილს.

40
00:02:07,270 --> 00:02:11,140
და შემდეგ თქვენი პროგრამა დაბეჭდავს
მინიმალური მონეტები

41
00:02:11,140 --> 00:02:14,740
რომ ხარბ მოლარე გამოიყენოს,
რათა, რომ თანხის ცვლილებას.

42
00:02:14,740 --> 00:02:18,160
>> ასე რომ, ახლა მოდით დაარღვიოს ეს
ქვემოთ შევიდა ჩვენი subtasks.

43
00:02:18,160 --> 00:02:21,410
პირველი, ჩვენ ვაპირებთ, რომ შემოგთავაზოთ ჩვენი
მომხმარებელს თანხის ცვლილებას.

44
00:02:21,410 --> 00:02:25,630
და, როგორც ნებისმიერი მომხმარებლის input, ჩვენ გვინდა, რომ
დარწმუნდით, რომ ჩვენ ვამტკიცებთ, რომ შეყვანის

45
00:02:25,630 --> 00:02:29,360
და იმისათვის, რომ ჩვენ შეგვიძლია გამოვიყენოთ,
შეყვანის დანარჩენი ჩვენი პროგრამა.

46
00:02:29,360 --> 00:02:32,480
მაშინ ჩვენ ვაპირებთ, რომ ყოველთვის
გამოყენება უდიდესი ეტაპზე შესაძლებელია

47
00:02:32,480 --> 00:02:35,240
და შენარჩუნება სიმღერა მონეტები გამოიყენება.

48
00:02:35,240 --> 00:02:39,080
და ბოლოს, ბეჭდვა საბოლოო
რაოდენობის მონეტები, რომ ჩვენ გამოიყენება.

49
00:02:39,080 --> 00:02:40,970
>> ასე რომ, მოდით ვისაუბროთ რითაც.

50
00:02:40,970 --> 00:02:43,550
თანხა უნდა მიიღოს ცენტი,
და ეს არის დოლარი.

51
00:02:43,550 --> 00:02:48,440
ასე რომ, დოლარი, ჩვენ ვაპირებთ
გამოიყენოს float ცვლადი ტიპის.

52
00:02:48,440 --> 00:02:52,390
ახლა როდესაც თქვენ ვთხოვო შესახებ შეყვანის,
გსურთ დარწმუნდით, რომ ის მოქმედებს.

53
00:02:52,390 --> 00:02:56,640
ასე რომ, აქ ჩვენ გვსურს ისარგებლოს
საქართველოს do- ხოლო loop შენება.

54
00:02:56,640 --> 00:03:00,320
>> Do- ხოლო loop განახორციელებს
ორგანოს მარყუჟის ერთხელ მაინც.

55
00:03:00,320 --> 00:03:01,650
ასე რომ, ეს მოდის მოსახერხებელი.

56
00:03:01,650 --> 00:03:05,510
ჩვენ ვიცით, რომ ჩვენ უნდა უბიძგონ
შესახებ ერთხელ მაინც float.

57
00:03:05,510 --> 00:03:07,100
ახლა, თუ რომ float მოქმედებს.

58
00:03:07,100 --> 00:03:07,710
დიდებულია.

59
00:03:07,710 --> 00:03:08,460
ჩვენ გადაადგილება.

60
00:03:08,460 --> 00:03:11,910
მაგრამ თუ არა, ციკლი, რომელიც უზრუნველყოფს
რომ მივიღებთ სათანადო float

61
00:03:11,910 --> 00:03:16,810
იმეორებს მუდმივად სანამ
მომხმარებლის გვაძლევს სწორი მნიშვნელობა.

62
00:03:16,810 --> 00:03:18,760
>> ახლა do- ხოლო
loop მდგომარეობა, ჩვენ გვჭირდება

63
00:03:18,760 --> 00:03:22,000
განიხილოს, თუ რას ნიშნავს
აქვს არასწორი float.

64
00:03:22,000 --> 00:03:24,220
ასე რომ კონტექსტში
ეს პრობლემა, ალბათ,

65
00:03:24,220 --> 00:03:27,450
ეს აზრი, უბრალოდ
მიიღოს დადებითი მნიშვნელობები.

66
00:03:27,450 --> 00:03:32,010
>> ასე რომ, მოძრავი on-- ჩვენ მოიპოვა
ღირებულების დოლარი შესახებ.

67
00:03:32,010 --> 00:03:35,380
მაგრამ ჩვენ საქმე მონეტები,
რომლებიც მთლიანად ცენტი.

68
00:03:35,380 --> 00:03:38,660
$ 1 უდრის 100 ცენტს.

69
00:03:38,660 --> 00:03:43,670
ასე რომ, კარგია, რომ გააკეთოთ, არის
კონვერტირება იმ ღირებულებების ცენტი.

70
00:03:43,670 --> 00:03:48,380
>> ახლა, როდესაც კონვერტაცია საწყისი float
მთელი რიცხვი, ასე დოლარი ცენტი,

71
00:03:48,380 --> 00:03:52,230
ჩვენ გვინდა დავრწმუნდეთ, რომ ჩვენ ფრთხილად
მცურავი პუნქტიანი ორაზროვნება.

72
00:03:52,230 --> 00:03:55,260
ასე რომ, ეს ნიშნავს, რომ that-- ამბობენ
ჩემი დოლარი value-- ჩემი float

73
00:03:55,260 --> 00:04:00,260
value-- იყო კიდევ $ 2, ჯერ კიდევ
შეიძლება ზოგიერთი მაწანწალა ნომრები არსებობს.

74
00:04:00,260 --> 00:04:04,590
ამიტომ, ჩვენ გვინდა დავრწმუნდეთ, რომ არა მხოლოდ
ჩვენ ვამრავლებთ 100 მისაღებად ცენტი,

75
00:04:04,590 --> 00:04:06,480
მაგრამ ჩვენ ასევე მრგვალ ეს off.

76
00:04:06,480 --> 00:04:09,210
>> ახლა ჩვენ გვაქვს თანხა
ცვლილება კუთვნილს შესახებ.

77
00:04:09,210 --> 00:04:13,430
ჩვენ თავდაპირველად მიღებული ის დოლარი,
და ახლა ჩვენ მოაქცია იგი ცენტი.

78
00:04:13,430 --> 00:04:17,029
ასე რომ, ახლა ჩვენ შეგვიძლია გააგრძელოს გულში
ხარბ ალგორითმი, რომელიც ყოველთვის

79
00:04:17,029 --> 00:04:19,220
გამოყენებით უდიდესი მონეტა შესაძლებელი.

80
00:04:19,220 --> 00:04:21,930
მიუხედავად იმისა, რომ ჩვენ ამით,
ეს აუცილებელია, რომ ჩვენ ასევე

81
00:04:21,930 --> 00:04:25,360
ტრეკზე რამდენი მონეტები
აპირებს უბრუნდება შესახებ

82
00:04:25,360 --> 00:04:28,630
ისევე როგორც დარჩენილი
შეცვლის კუთვნილს შესახებ.

83
00:04:28,630 --> 00:04:31,130
>> პროგრამა გამოიყურება
რაღაც მსგავსი.

84
00:04:31,130 --> 00:04:34,190
მას შემდეგ, რაც თქვენ ოდენობით
დოლარი და გარდაქმნას, რომ ცენტი,

85
00:04:34,190 --> 00:04:35,790
მაშინ თქვენ შეიტანეთ loop.

86
00:04:35,790 --> 00:04:38,400
ხოლო მეოთხედი შეიძლება
used-- რომ ვთქვა

87
00:04:38,400 --> 00:04:43,660
ხოლო თანხის ცვლილება კუთვნილს
მომხმარებლის მეტია ან ტოლია $ 0.25

88
00:04:43,660 --> 00:04:45,040
თქვენ გამოიყენოთ კვარტალში.

89
00:04:45,040 --> 00:04:47,000
>> რას გამოყენებით კვარტალში იწვევს?

90
00:04:47,000 --> 00:04:51,280
ისე, one-- თქვენ გაზრდის მონეტა
იმედი უნდა დაუბრუნდეს მომხმარებელს.

91
00:04:51,280 --> 00:04:55,890
და მეორე თქვენ შეამცირებს მიმდინარე
თანხის ცვლილება კუთვნილს თავში შესახებ

92
00:04:55,890 --> 00:04:57,520
მიერ $ 0.25.

93
00:04:57,520 --> 00:05:00,680
>> მას შემდეგ, რაც იმეორებს, რომ მანამ, სანამ
მეოთხედი შეიძლება აღარ იყოს გამოყენებული,

94
00:05:00,680 --> 00:05:04,630
გაგრძელება შემდეგ უდიდესი
coin-- ამ შემთხვევაში dimes, $ 0.10.

95
00:05:04,630 --> 00:05:07,750
ასე რომ, თქვენ შეიტანეთ რომ მარყუჟი სანამ
თქვენ აღარ უნდა გამოიყენოს dimes.

96
00:05:07,750 --> 00:05:10,720
შემდეგ გააგრძელოთ შემდეგი
უდიდესი მონეტა, nickels.

97
00:05:10,720 --> 00:05:14,810
მას შემდეგ, რაც nickels შეიძლება აღარ იყოს გამოყენებული,
გამოვიყენოთ დარჩენილი თანხის pennies.

98
00:05:14,810 --> 00:05:17,800
და ბოლოს, ბეჭდვა
რაოდენობის მონეტები.

99
00:05:17,800 --> 00:05:20,350
>> კიდევ ერთი გზა, რომ თქვენ
მიახლოება ხარბ პრობლემა

100
00:05:20,350 --> 00:05:22,950
არის გამოიყენოს modulo მიდგომა.

101
00:05:22,950 --> 00:05:25,690
Modulo არის ოპერატორი
რომ დააბრუნებს დარჩენილი

102
00:05:25,690 --> 00:05:27,680
სამმართველოს შორის ორი ნომერი.

103
00:05:27,680 --> 00:05:30,270
ვთქვათ მე მქონდა 50 mod 5.

104
00:05:30,270 --> 00:05:34,070
ისე, 5 ფაქტორი 50,
ასე რომ, დანარჩენი იქნება 0.

105
00:05:34,070 --> 00:05:39,230
50 mod 10-- კარგად, 10 ფაქტორი
50, ასე რომ დარჩენილი ასევე 0.

106
00:05:39,230 --> 00:05:43,660
50 mod 50-- ასევე, ნებისმიერი რაოდენობის mod თავად
არ აპირებს რაიმე დარჩენილი.

107
00:05:43,660 --> 00:05:45,510
>> რაც შეეხება 50 mod 49?

108
00:05:45,510 --> 00:05:47,910
ისე, 49 მხოლოდ გადადის 50 ერთხელ.

109
00:05:47,910 --> 00:05:50,290
ასე რომ, დანარჩენი იქნება 1.

110
00:05:50,290 --> 00:05:55,180
53 mod 50 აპირებს
გაძლევთ დარჩენილი 3.

111
00:05:55,180 --> 00:05:59,120
>> ასე რომ, როგორ შეგვიძლია გამოვიყენოთ modulo
და ალბათ ზოგიერთი სამმართველოს

112
00:05:59,120 --> 00:06:01,690
განვახორციელოთ ხარბ ალგორითმი?

113
00:06:01,690 --> 00:06:05,550
ისე, ჩვენ მაინც გვინდა დარჩება ჭეშმარიტი
გულში ხარბ ალგორითმი, რომ

114
00:06:05,550 --> 00:06:07,910
არის გამოყენებით უდიდესი მონეტა შესაძლებელი.

115
00:06:07,910 --> 00:06:14,570
>> მოდით, ვკითხოთ საკუთარ თავს, თუ ჩვენ შეგვიძლია გამოვიყენოთ ნებისმიერი
მეოთხედი დაბრუნდეს $ 0.32 შესახებ.

116
00:06:14,570 --> 00:06:20,070
ისე, 32 mod 25 აძლევს
აშშ დარჩენილი $ 0.07.

117
00:06:20,070 --> 00:06:24,500
ასე რომ, რომელიც გვეუბნება, რომ ჩვენ შეგვიძლია ნამდვილად
გამოყენება ერთი კვარტლის ერთად $ 0.07 დარჩენილი.

118
00:06:24,500 --> 00:06:26,180
>> მაშინ, შეგვიძლია გამოვიყენოთ ნებისმიერი dimes?

119
00:06:26,180 --> 00:06:32,740
ისე, no-- იმიტომ $ 0.07 mod
$ 0.10 გვაძლევს დარჩენილი 7.

120
00:06:32,740 --> 00:06:34,960
10 არ წასვლას 7-ში.

121
00:06:34,960 --> 00:06:36,390
>> მაშინ შეგვიძლია გამოვიყენოთ nickels?

122
00:06:36,390 --> 00:06:40,490
ისე $ 0.07 mod 5 ცენტი
გვაძლევს ორი დარჩენილი.

123
00:06:40,490 --> 00:06:42,930
და ბოლოს, შეგვიძლია გამოვიყენოთ ნებისმიერი pennies?

124
00:06:42,930 --> 00:06:45,930
2 mod 1 გვაძლევს 0,
რაც საბოლოო ჯამში, რა

125
00:06:45,930 --> 00:06:48,160
ჩვენ გვინდა, იმიტომ, რომ მაშინ, რომ
იმას ნიშნავს, რომ ჩვენ დაბრუნდა

126
00:06:48,160 --> 00:06:50,160
იმ მომხმარებლის ყველა ცვლილება კუთვნილს.

127
00:06:50,160 --> 00:06:54,320
>> ასე რომ, ახლა თქვენ გაქვთ ორი შესაძლო გზები
ახორციელებს ხარბ ალგორითმი

128
00:06:54,320 --> 00:06:59,230
ერთი მარყუჟების და ერთი
კომბინაცია modulo და გაყოფა.

129
00:06:59,230 --> 00:07:03,010
ასე რომ, საბოლოოდ, ჩვენ უბრალოდ უნდა
ბეჭდვა საბოლოო რაოდენობის მონეტები.

130
00:07:03,010 --> 00:07:06,520
>> თუ მე მინდა გითხრათ, რომ მე მქონდა
3 pets და ეს ღირებულება hardcoded,

131
00:07:06,520 --> 00:07:09,240
მაშინ მე უბრალოდ გამოიყენოთ
მარტივი ბეჭდვითი ტესტი განცხადებაში.

132
00:07:09,240 --> 00:07:12,320
მაგრამ ჩვენი მნიშვნელობა რეალურად
ცვლადად.

133
00:07:12,320 --> 00:07:15,260
ასე რომ, თუ თქვენ ბეჭდვა
ღირებულებები შენახული ცვლადები?

134
00:07:15,260 --> 00:07:17,880
>> ამისათვის ჩვენ მიიღოს
უპირატესობა placeholders.

135
00:07:17,880 --> 00:07:21,540
ამბობენ, რომ მე უკვე განაცხადა,
ინიციალიზაცია რიცხვი n.

136
00:07:21,540 --> 00:07:25,170
მაშინ მოგვიანებით, თუ მინდოდა ბეჭდვა, რომ
ღირებულება, მაშინ მე წერენ სიმებიანი.

137
00:07:25,170 --> 00:07:30,500
და ნაცვლად, რომ ღირებულება მე გამოიყენოს
ეს placeholder, რომ რიცხვი% i.

138
00:07:30,500 --> 00:07:33,800
მას შემდეგ, რაც სიმებიანი, მაქვს
მძიმე, რასაც მოჰყვა ცვლადი

139
00:07:33,800 --> 00:07:34,950
რომ მინდა ბეჭდვა.

140
00:07:34,950 --> 00:07:38,550
მოგვიანებით, როდესაც იგი ბეჭდავს,
ეს კიდე ბეჭდვა ღირებულება n.

141
00:07:38,550 --> 00:07:41,570
>> მე შეიძლება ასევე გამოიყენოს placeholder
float, მაგალითად.

142
00:07:41,570 --> 00:07:44,000
თუ მინდოდა გითხრათ, თუ როგორ
ბევრი ფული მაქვს ჯიბეში,

143
00:07:44,000 --> 00:07:46,820
მაშინ მე ვერ ვიტყვი მე% f დოლარი.

144
00:07:46,820 --> 00:07:51,330
და მოგვიანებით, როდესაც იგი ბეჭდავს, მაშინ n იქნება
ჩაენაცვლოს, რომ ადგილის მფლობელი.

145
00:07:51,330 --> 00:07:55,530
მე შეიძლება, მაგალითად, გამოიყენოთ რამდენიმე
ჩანაცვლების რამდენიმე ცვლადი.

146
00:07:55,530 --> 00:07:57,590
ასე რომ, სანამ მე სიაში
მათ, რათა, მაშინ მე

147
00:07:57,590 --> 00:08:00,390
შემიძლია გითხრათ, რამდენი
ძაღლი და კატა მაქვს.

148
00:08:00,390 --> 00:08:03,710
>> ახლა ჩვენ ვიცით, როგორ უნდა უბიძგონ
მომხმარებელს თანხის ცვლილება,

149
00:08:03,710 --> 00:08:06,130
უზრუნველყოს, რომ input
მოქმედებს, და მაშინ ჩვენ

150
00:08:06,130 --> 00:08:10,370
აქვს ორი შესაძლო გზები ახორციელებს
ხარბ ალგორითმი ყოველთვის გამოყენებით

151
00:08:10,370 --> 00:08:12,090
უდიდესი მონეტა შესაძლებელი.

152
00:08:12,090 --> 00:08:15,050
იმიტომ, რომ ჩვენ ინახება სიმღერა
რამდენი მონეტები ჩვენ გამოყენებით,

153
00:08:15,050 --> 00:08:19,210
ჩვენ შეგვიძლია შემდეგ ბეჭდვა, რომ მნიშვნელობა ბოლოს,
ვეუბნებოდი შესახებ რამდენი მონეტები ისინი

154
00:08:19,210 --> 00:08:20,240
უკან დაბრუნება.

155
00:08:20,240 --> 00:08:24,240
>> ჩემი სახელი არის Amayla, და ეს არის CS50.

156
00:08:24,240 --> 00:08:25,915

