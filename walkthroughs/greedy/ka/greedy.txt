მოდით მისაღებად ხარბ. ხარბ, ჩვენი საქმეა ითამაშოს როლი ხარბ მოლარე. მომხმარებლის გეტყვით, თუ როგორ ბევრი ცვლილება ჩვენ ვალში მათ, და მაშინ ჩვენი საქმეა გამოთვლა მინიმალური რაოდენობის მონეტები რომ ჩვენ შეგვიძლია გამოვიყენოთ, რათა რომ თანხის ცვლილებას. 

დავიწყოთ მაგალითად. ანუ, მომხმარებელს მოითხოვს $ 0.32 უკან. ჩვენ შეგვიძლია ამის გაკეთება მიერ აძლევდა მათ 32 pennies, ერთი პროცენტი თითოეული. ან მე ვერ ხუთ coins-- მიერ მათთვის სამი dimes, $ 0.10 ყოველი, და ორი pennies, $ 0.02 თითოეული. მაგრამ შეიძლება ჩვენ ვიყენებთ კი ნაკლები მონეტები, რათა, რომ? 

მთელი ტაქტიკა greedy-- უნდა ხარბ cashier-- არის გამოიყენოს უდიდესი მონეტა შესაძლებელი. ასე რომ, როდესაც ჩვენ მეოთხედი ჩვენ ვიყენებთ მათ. და მერე კიდევ იმ ამოიწურა, ჩვენ ვიყენებთ dimes, $ 0.10 თითოეული. შემდეგ nickels, 5 ცენტი ყოველი, და მაშინ ქვემოთ pennies, ერთი პროცენტი თითოეული. გამოყენებით უდიდესი მონეტა შესაძლებელია, როდესაც შეგვიძლია, ჩვენ უზრუნველყოს, რომ ჩვენ ვიყენებთ ნაკლები მონეტები შესაძლებელია, რათა ცვლილება. 

მოდით ფეხით ამ გზით. მომხმარებელს სჭირდება $ 0.32. ასე რომ დავუსვათ საკუთარ თავს, შეგვიძლია გამოვიყენოთ მეოთხედი? ისე, დიახ, ჩვენ შეგვიძლია. ასე რომ, ახლა ჩვენ მხოლოდ ვიცით, მათ $ 0.07, და ჩვენ ერთი მონეტა. 

შეგვიძლია გამოვიყენოთ სხვა კვარტალში? ისე, არ. $ 0.07 ნაკლებია, ვიდრე $ 0.25, ამიტომ ჩვენ გააგრძელოს მომდევნო უდიდესი მონეტა შესაძლებელი. Dimes არის $ 0.10, და კიდევ ერთხელ, ჩვენ ვერ გამოიყენებს dimes. იმის გამო, რომ dimes ღირს $ 0.10, რომელიც უფრო მეტია, ვიდრე თანხის ცვლილება კუთვნილს. 

ჩვენ წასვლა nickels. და, დიახ, მართლაც, $ 0.05 ნაკლებია, ვიდრე $ 0.10-- ასე რომ ჩვენ შეგვიძლია გამოვიყენოთ ნიკელის. ასე რომ, ახლა ჩვენ მხოლოდ ვალში შესახებ $ 0.02 და ჩვენ ჯერჯერობით გამოიყენება ორი მონეტა. ჩვენ არ შეგვიძლია გამოვიყენოთ სხვა ნიკელს. ასე რომ, ჩვენ გააგრძელოთ ბოლო მონეტა ჩვენს ხელთ, რომლებიც pennies. 

და შეგვიძლია გამოვიყენოთ penny? ისე, yes-- და ჩვენ დასრულდება მდე გამოყენებით ორი pennies for სულ ოთხი მონეტები. 

მას შემდეგ, რაც თქვენ დასრულდა, პროგრამა გამოიყურება მოსწონს ეს. მას შემდეგ, რაც შესახებ ეშვება ხარბ პროგრამა, ისინი მოთხოვნილია იძლევა თანხის ცვლილება დოლარი, რომ ისინი კუთვნილს. და შემდეგ თქვენი პროგრამა დაბეჭდავს მინიმალური მონეტები რომ ხარბ მოლარე გამოიყენოს, რათა, რომ თანხის ცვლილებას. 

ასე რომ, ახლა მოდით დაარღვიოს ეს ქვემოთ შევიდა ჩვენი subtasks. პირველი, ჩვენ ვაპირებთ, რომ შემოგთავაზოთ ჩვენი მომხმარებელს თანხის ცვლილებას. და, როგორც ნებისმიერი მომხმარებლის input, ჩვენ გვინდა, რომ დარწმუნდით, რომ ჩვენ ვამტკიცებთ, რომ შეყვანის და იმისათვის, რომ ჩვენ შეგვიძლია გამოვიყენოთ, შეყვანის დანარჩენი ჩვენი პროგრამა. მაშინ ჩვენ ვაპირებთ, რომ ყოველთვის გამოყენება უდიდესი ეტაპზე შესაძლებელია და შენარჩუნება სიმღერა მონეტები გამოიყენება. და ბოლოს, ბეჭდვა საბოლოო რაოდენობის მონეტები, რომ ჩვენ გამოიყენება. 

ასე რომ, მოდით ვისაუბროთ რითაც. თანხა უნდა მიიღოს ცენტი, და ეს არის დოლარი. ასე რომ, დოლარი, ჩვენ ვაპირებთ გამოიყენოს float ცვლადი ტიპის. ახლა როდესაც თქვენ ვთხოვო შესახებ შეყვანის, გსურთ დარწმუნდით, რომ ის მოქმედებს. ასე რომ, აქ ჩვენ გვსურს ისარგებლოს საქართველოს do- ხოლო loop შენება. 

Do- ხოლო loop განახორციელებს ორგანოს მარყუჟის ერთხელ მაინც. ასე რომ, ეს მოდის მოსახერხებელი. ჩვენ ვიცით, რომ ჩვენ უნდა უბიძგონ შესახებ ერთხელ მაინც float. ახლა, თუ რომ float მოქმედებს. დიდებულია. ჩვენ გადაადგილება. მაგრამ თუ არა, ციკლი, რომელიც უზრუნველყოფს რომ მივიღებთ სათანადო float იმეორებს მუდმივად სანამ მომხმარებლის გვაძლევს სწორი მნიშვნელობა. 

ახლა do- ხოლო loop მდგომარეობა, ჩვენ გვჭირდება განიხილოს, თუ რას ნიშნავს აქვს არასწორი float. ასე რომ კონტექსტში ეს პრობლემა, ალბათ, ეს აზრი, უბრალოდ მიიღოს დადებითი მნიშვნელობები. 

ასე რომ, მოძრავი on-- ჩვენ მოიპოვა ღირებულების დოლარი შესახებ. მაგრამ ჩვენ საქმე მონეტები, რომლებიც მთლიანად ცენტი. $ 1 უდრის 100 ცენტს. ასე რომ, კარგია, რომ გააკეთოთ, არის კონვერტირება იმ ღირებულებების ცენტი. 

ახლა, როდესაც კონვერტაცია საწყისი float მთელი რიცხვი, ასე დოლარი ცენტი, ჩვენ გვინდა დავრწმუნდეთ, რომ ჩვენ ფრთხილად მცურავი პუნქტიანი ორაზროვნება. ასე რომ, ეს ნიშნავს, რომ that-- ამბობენ ჩემი დოლარი value-- ჩემი float value-- იყო კიდევ $ 2, ჯერ კიდევ შეიძლება ზოგიერთი მაწანწალა ნომრები არსებობს. ამიტომ, ჩვენ გვინდა დავრწმუნდეთ, რომ არა მხოლოდ ჩვენ ვამრავლებთ 100 მისაღებად ცენტი, მაგრამ ჩვენ ასევე მრგვალ ეს off. 

ახლა ჩვენ გვაქვს თანხა ცვლილება კუთვნილს შესახებ. ჩვენ თავდაპირველად მიღებული ის დოლარი, და ახლა ჩვენ მოაქცია იგი ცენტი. ასე რომ, ახლა ჩვენ შეგვიძლია გააგრძელოს გულში ხარბ ალგორითმი, რომელიც ყოველთვის გამოყენებით უდიდესი მონეტა შესაძლებელი. მიუხედავად იმისა, რომ ჩვენ ამით, ეს აუცილებელია, რომ ჩვენ ასევე ტრეკზე რამდენი მონეტები აპირებს უბრუნდება შესახებ ისევე როგორც დარჩენილი შეცვლის კუთვნილს შესახებ. 

პროგრამა გამოიყურება რაღაც მსგავსი. მას შემდეგ, რაც თქვენ ოდენობით დოლარი და გარდაქმნას, რომ ცენტი, მაშინ თქვენ შეიტანეთ loop. ხოლო მეოთხედი შეიძლება used-- რომ ვთქვა ხოლო თანხის ცვლილება კუთვნილს მომხმარებლის მეტია ან ტოლია $ 0.25 თქვენ გამოიყენოთ კვარტალში. 

რას გამოყენებით კვარტალში იწვევს? ისე, one-- თქვენ გაზრდის მონეტა იმედი უნდა დაუბრუნდეს მომხმარებელს. და მეორე თქვენ შეამცირებს მიმდინარე თანხის ცვლილება კუთვნილს თავში შესახებ მიერ $ 0.25. 

მას შემდეგ, რაც იმეორებს, რომ მანამ, სანამ მეოთხედი შეიძლება აღარ იყოს გამოყენებული, გაგრძელება შემდეგ უდიდესი coin-- ამ შემთხვევაში dimes, $ 0.10. ასე რომ, თქვენ შეიტანეთ რომ მარყუჟი სანამ თქვენ აღარ უნდა გამოიყენოს dimes. შემდეგ გააგრძელოთ შემდეგი უდიდესი მონეტა, nickels. მას შემდეგ, რაც nickels შეიძლება აღარ იყოს გამოყენებული, გამოვიყენოთ დარჩენილი თანხის pennies. და ბოლოს, ბეჭდვა რაოდენობის მონეტები. 

კიდევ ერთი გზა, რომ თქვენ მიახლოება ხარბ პრობლემა არის გამოიყენოს modulo მიდგომა. Modulo არის ოპერატორი რომ დააბრუნებს დარჩენილი სამმართველოს შორის ორი ნომერი. ვთქვათ მე მქონდა 50 mod 5. ისე, 5 ფაქტორი 50, ასე რომ, დანარჩენი იქნება 0. 50 mod 10-- კარგად, 10 ფაქტორი 50, ასე რომ დარჩენილი ასევე 0. 50 mod 50-- ასევე, ნებისმიერი რაოდენობის mod თავად არ აპირებს რაიმე დარჩენილი. 

რაც შეეხება 50 mod 49? ისე, 49 მხოლოდ გადადის 50 ერთხელ. ასე რომ, დანარჩენი იქნება 1. 53 mod 50 აპირებს გაძლევთ დარჩენილი 3. 

ასე რომ, როგორ შეგვიძლია გამოვიყენოთ modulo და ალბათ ზოგიერთი სამმართველოს განვახორციელოთ ხარბ ალგორითმი? ისე, ჩვენ მაინც გვინდა დარჩება ჭეშმარიტი გულში ხარბ ალგორითმი, რომ არის გამოყენებით უდიდესი მონეტა შესაძლებელი. 

მოდით, ვკითხოთ საკუთარ თავს, თუ ჩვენ შეგვიძლია გამოვიყენოთ ნებისმიერი მეოთხედი დაბრუნდეს $ 0.32 შესახებ. ისე, 32 mod 25 აძლევს აშშ დარჩენილი $ 0.07. ასე რომ, რომელიც გვეუბნება, რომ ჩვენ შეგვიძლია ნამდვილად გამოყენება ერთი კვარტლის ერთად $ 0.07 დარჩენილი. 

მაშინ, შეგვიძლია გამოვიყენოთ ნებისმიერი dimes? ისე, no-- იმიტომ $ 0.07 mod $ 0.10 გვაძლევს დარჩენილი 7. 10 არ წასვლას 7-ში. 

მაშინ შეგვიძლია გამოვიყენოთ nickels? ისე $ 0.07 mod 5 ცენტი გვაძლევს ორი დარჩენილი. და ბოლოს, შეგვიძლია გამოვიყენოთ ნებისმიერი pennies? 2 mod 1 გვაძლევს 0, რაც საბოლოო ჯამში, რა ჩვენ გვინდა, იმიტომ, რომ მაშინ, რომ იმას ნიშნავს, რომ ჩვენ დაბრუნდა იმ მომხმარებლის ყველა ცვლილება კუთვნილს. 

ასე რომ, ახლა თქვენ გაქვთ ორი შესაძლო გზები ახორციელებს ხარბ ალგორითმი ერთი მარყუჟების და ერთი კომბინაცია modulo და გაყოფა. ასე რომ, საბოლოოდ, ჩვენ უბრალოდ უნდა ბეჭდვა საბოლოო რაოდენობის მონეტები. 

თუ მე მინდა გითხრათ, რომ მე მქონდა 3 pets და ეს ღირებულება hardcoded, მაშინ მე უბრალოდ გამოიყენოთ მარტივი ბეჭდვითი ტესტი განცხადებაში. მაგრამ ჩვენი მნიშვნელობა რეალურად ცვლადად. ასე რომ, თუ თქვენ ბეჭდვა ღირებულებები შენახული ცვლადები? 

ამისათვის ჩვენ მიიღოს უპირატესობა placeholders. ამბობენ, რომ მე უკვე განაცხადა, ინიციალიზაცია რიცხვი n. მაშინ მოგვიანებით, თუ მინდოდა ბეჭდვა, რომ ღირებულება, მაშინ მე წერენ სიმებიანი. და ნაცვლად, რომ ღირებულება მე გამოიყენოს ეს placeholder, რომ რიცხვი% i. მას შემდეგ, რაც სიმებიანი, მაქვს მძიმე, რასაც მოჰყვა ცვლადი რომ მინდა ბეჭდვა. მოგვიანებით, როდესაც იგი ბეჭდავს, ეს კიდე ბეჭდვა ღირებულება n. 

მე შეიძლება ასევე გამოიყენოს placeholder float, მაგალითად. თუ მინდოდა გითხრათ, თუ როგორ ბევრი ფული მაქვს ჯიბეში, მაშინ მე ვერ ვიტყვი მე% f დოლარი. და მოგვიანებით, როდესაც იგი ბეჭდავს, მაშინ n იქნება ჩაენაცვლოს, რომ ადგილის მფლობელი. მე შეიძლება, მაგალითად, გამოიყენოთ რამდენიმე ჩანაცვლების რამდენიმე ცვლადი. ასე რომ, სანამ მე სიაში მათ, რათა, მაშინ მე შემიძლია გითხრათ, რამდენი ძაღლი და კატა მაქვს. 

ახლა ჩვენ ვიცით, როგორ უნდა უბიძგონ მომხმარებელს თანხის ცვლილება, უზრუნველყოს, რომ input მოქმედებს, და მაშინ ჩვენ აქვს ორი შესაძლო გზები ახორციელებს ხარბ ალგორითმი ყოველთვის გამოყენებით უდიდესი მონეტა შესაძლებელი. იმიტომ, რომ ჩვენ ინახება სიმღერა რამდენი მონეტები ჩვენ გამოყენებით, ჩვენ შეგვიძლია შემდეგ ბეჭდვა, რომ მნიშვნელობა ბოლოს, ვეუბნებოდი შესახებ რამდენი მონეტები ისინი უკან დაბრუნება. 

ჩემი სახელი არის Amayla, და ეს არის CS50. 