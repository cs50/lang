1
00:00:00,000 --> 00:00:00,710

2
00:00:00,710 --> 00:00:02,900
>> それでは、貪欲取得してみましょう。

3
00:00:02,900 --> 00:00:06,810
貪欲で、私たちの仕事は、再生することです
貪欲レジの役割。

4
00:00:06,810 --> 00:00:09,750
ユーザーはどのように私たちに教えてくれます
我々は彼らを借りて多くの変更、

5
00:00:09,750 --> 00:00:13,520
そしてその後、私たちの仕事は、計算することです。
コインの最小数

6
00:00:13,520 --> 00:00:17,240
我々が作るために使用することができます
変化の量。

7
00:00:17,240 --> 00:00:19,560
>> 例を見てみましょう。

8
00:00:19,560 --> 00:00:23,170
ユーザーがバック$ 0.32必要と言います。

9
00:00:23,170 --> 00:00:28,960
私たちは、与えることによってこれを行うことができます
それらの32ペニー、1セントそれぞれ。

10
00:00:28,960 --> 00:00:35,180
それとも私はまたによって5 coins--を使用することができます
3ダイムそれらを与え、$ 0.10それぞれ、

11
00:00:35,180 --> 00:00:38,060
そして、2ペニー、$ 0.02各。

12
00:00:38,060 --> 00:00:42,580
しかし、私たちも使用することができます
少ないコインはそれを作るには？

13
00:00:42,580 --> 00:00:45,100
>> greedy--全体戦術
貪欲cashier--ことにします

14
00:00:45,100 --> 00:00:47,600
可能な最大のコインを使用することです。

15
00:00:47,600 --> 00:00:50,670
だから私たちはいつでも
四半期は、我々はそれらを使用します。

16
00:00:50,670 --> 00:00:54,100
そしてそれらは、不足してしまうと
我々はダイム、$ 0.10をそれぞれ使用します。

17
00:00:54,100 --> 00:00:58,840
次に硬貨、5セントごと、および
その後、ペニーに至るまで、1セントそれぞれ。

18
00:00:58,840 --> 00:01:01,792
最大のコインを使用して
可能な限り我々はできます、

19
00:01:01,792 --> 00:01:07,350
我々は、最も少ない数を使用していることを確認します
変更をすることが可能コインの。

20
00:01:07,350 --> 00:01:09,180
>> それでは、これを見てみましょう。

21
00:01:09,180 --> 00:01:11,660
ユーザーは$ 0.32必要があります。

22
00:01:11,660 --> 00:01:14,200
だから我々は自問し、
我々は四半期を使用できますか？

23
00:01:14,200 --> 00:01:15,560
まあ、はい我々はできます。

24
00:01:15,560 --> 00:01:19,720
だから今我々は彼らを知っています
$ 0.07私たちは1コインを使用していました。

25
00:01:19,720 --> 00:01:20,970
>> 我々は別の四半期を使用することはできますか？

26
00:01:20,970 --> 00:01:21,890
うーん、ダメ。

27
00:01:21,890 --> 00:01:27,570
$ 0.07 $ 0.25以下であるので、我々は続行します
次に利用可能な最大のコインへ。

28
00:01:27,570 --> 00:01:30,690
ダイムは$ 0.10であり、
再び、我々はダイムを使用することはできません。

29
00:01:30,690 --> 00:01:35,480
ダイムは$ 0.10の価値があるのでれます
未払いの変化量よりも多いです。

30
00:01:35,480 --> 00:01:36,790
>> 私たちは、硬貨に行きます。

31
00:01:36,790 --> 00:01:40,890
そして、はい確かに、$ 0.05未満であります
$ 0.10--ので、私たちは、ニッケルを使用することができます。

32
00:01:40,890 --> 00:01:46,104
だから今、私たちはユーザーのみ$ 0.02借りて、
我々はこれまでに2枚のコインを使用しました。

33
00:01:46,104 --> 00:01:47,270
私たちは別のニッケルを使用することはできません。

34
00:01:47,270 --> 00:01:51,140
それでは、私たちはで最後のコインに進みます
ペニーている私たちの処分、。

35
00:01:51,140 --> 00:01:52,270
>> そして、私たちはペニーを使用できますか？

36
00:01:52,270 --> 00:01:59,060
まあ、yes--と我々は2を使用して終了
4コインの合計のためのペニー。

37
00:01:59,060 --> 00:02:01,430
>> 設定が完了したら、
プログラムは次のようになります。

38
00:02:01,430 --> 00:02:03,710
ユーザーが実行されると
貪欲プログラム、彼らはよ

39
00:02:03,710 --> 00:02:07,270
の量を与えるように求めるメッセージが表示され
彼らが負っているドルの変化。

40
00:02:07,270 --> 00:02:11,140
そして、あなたのプログラムが出力されます
コインの最小量

41
00:02:11,140 --> 00:02:14,740
貪欲なレジ係が使用することを
変化の量を作るために。

42
00:02:14,740 --> 00:02:18,160
>> だから今、これを破るのを聞かせて
私たちのサブタスクにダウン。

43
00:02:18,160 --> 00:02:21,410
まず、私たちの入力を要求するつもりです
変化量のためのユーザー。

44
00:02:21,410 --> 00:02:25,630
そして、任意のユーザの入力と同じように、私たちがしたいです
私たちはその入力を検証していることを確認してください

45
00:02:25,630 --> 00:02:29,360
そして、我々はそれを使用できることを確認
私たちのプログラムの残りの部分のための入力。

46
00:02:29,360 --> 00:02:32,480
その後、我々は常にしようとしています
可能な最大のポイントを使用

47
00:02:32,480 --> 00:02:35,240
そして、使用コインを追跡します。

48
00:02:35,240 --> 00:02:39,080
そして最後に、最終の印刷
我々が使用したコインの数。

49
00:02:39,080 --> 00:02:40,970
>> それでは、プロンプトについて話しましょう​​。

50
00:02:40,970 --> 00:02:43,550
量は、セントを作る必要があります
これはドルです。

51
00:02:43,550 --> 00:02:48,440
だからドルのために、我々はつもりです
フロート変数の型を使用します。

52
00:02:48,440 --> 00:02:52,390
今、あなたが入力をユーザーに要求するたびに、
あなたはそれが有効だことを確認します。

53
00:02:52,390 --> 00:02:56,640
だからここでは、優位性を利用したいです
DO-whil​​eループ構築物の。

54
00:02:56,640 --> 00:03:00,320
>> DO-whil​​eループが実行されます
ループの本体に少なくとも一回。

55
00:03:00,320 --> 00:03:01,650
だから、これは便利です。

56
00:03:01,650 --> 00:03:05,510
我々は促すために必要があることを知っています
少なくとも一度フロートのためのユーザー。

57
00:03:05,510 --> 00:03:07,100
今でフロートが有効である場合。

58
00:03:07,100 --> 00:03:07,710
それは素晴らしいことです。

59
00:03:07,710 --> 00:03:08,460
私たちは、上に移動します。

60
00:03:08,460 --> 00:03:11,910
ない場合は、ループが保証されます
我々は適切なフロートを取得すること

61
00:03:11,910 --> 00:03:16,810
まで連続繰り返すことにより、
ユーザーは、私たちに有効な値を提供します。

62
00:03:16,810 --> 00:03:18,760
>> 今DO-しばらくの間
ループ条件、我々が必要です

63
00:03:18,760 --> 00:03:22,000
それが何を意味するのかを検討します
無効なフロートを持っています。

64
00:03:22,000 --> 00:03:24,220
との関連についてはこれ
おそらく、この問題は、

65
00:03:24,220 --> 00:03:27,450
それだけで理にかなって
正の値を受け入れます。

66
00:03:27,450 --> 00:03:32,010
>> だからon--移動我々が得てきました
ユーザーからのドルの値。

67
00:03:32,010 --> 00:03:35,380
しかし、我々は、コインを扱っています、
これはセントで完全にされています。

68
00:03:35,380 --> 00:03:38,660
$ 1は100セントに相当します。

69
00:03:38,660 --> 00:03:43,670
これを行うには良いことがにあります
これらの値は、セントに変換します。

70
00:03:43,670 --> 00:03:48,380
>> 今フロートから変換するとき
整数に、セントドルので、

71
00:03:48,380 --> 00:03:52,230
我々は慎重にしていることを確認します
浮動小数点の不正確さについて。

72
00:03:52,230 --> 00:03:55,260
だからthat--が言う意味します
私のドルは私のフロートをvalue--

73
00:03:55,260 --> 00:04:00,260
value--はまだ、あっても$ 2が存在しました
そこにいくつかの浮遊数字であってもよいです。

74
00:04:00,260 --> 00:04:04,590
だから我々はそれを確認するだけでなく、
私たちはセントを取得するために100を掛けますか、

75
00:04:04,590 --> 00:04:06,480
私たちもそれを丸めます。

76
00:04:06,480 --> 00:04:09,210
>> だから今、私たちは量を持っています
変更のユーザーに支払うべき。

77
00:04:09,210 --> 00:04:13,430
私たちは、もともとドルでそれを得ました、
そして今、私たちはセントにそれを変換しました。

78
00:04:13,430 --> 00:04:17,029
だから今、私たちはの中心部に進むことができます
常に貪欲アルゴリズム、

79
00:04:17,029 --> 00:04:19,220
可能な最大のコインを使用して。

80
00:04:19,220 --> 00:04:21,930
我々はこれをやっているが、
それは、我々も不可欠です

81
00:04:21,930 --> 00:04:25,360
どのように多くのコインを追跡
ユーザに返されるつもり

82
00:04:25,360 --> 00:04:28,630
同様に残りの
ユーザーに支払うべき変更。

83
00:04:28,630 --> 00:04:31,130
>> プログラムが検索されます
このようなもの。

84
00:04:31,130 --> 00:04:34,190
あなたは量を取得した後
ドルとセントにそれを変換し、

85
00:04:34,190 --> 00:04:35,790
あなたは、ループを入力します。

86
00:04:35,790 --> 00:04:38,400
四半期にはなることができますが
そのused--と言うことです

87
00:04:38,400 --> 00:04:43,660
しばらくに対する債務の変化量
ユーザは、より大きいまたは$ 0.25等しく、

88
00:04:43,660 --> 00:04:45,040
あなたは四半期を使用します。

89
00:04:45,040 --> 00:04:47,000
>> 今、何が伴う四半期を使用していますか？

90
00:04:47,000 --> 00:04:51,280
さて、あなたはコインを増やします選びます - 
ユーザーに返される数えます。

91
00:04:51,280 --> 00:04:55,890
そして第二に、あなたは電流を低減します
変化の量は、ユーザに戻って負っ

92
00:04:55,890 --> 00:04:57,520
$ 0.25。

93
00:04:57,520 --> 00:05:00,680
>> までこれを繰り返した後
四半期は、もはや使用することができ、

94
00:05:00,680 --> 00:05:04,630
次の最大に進みます
この場合、ダイム、$ 0.10 coin--。

95
00:05:04,630 --> 00:05:07,750
だから、まで、そのループを入力します
あなたは、もはやダイムを使用することはできません。

96
00:05:07,750 --> 00:05:10,720
その後、次へ進みます
最大コイン、硬貨。

97
00:05:10,720 --> 00:05:14,810
硬貨は、もはや使用することができた後、
ペニーで残量を使用しています。

98
00:05:14,810 --> 00:05:17,800
そして最後に、印刷
使用コインの枚数。

99
00:05:17,800 --> 00:05:20,350
>> もう一つの方法のことができます。
貪欲な問題に取り組みます

100
00:05:20,350 --> 00:05:22,950
モジュロアプローチを使用することです。

101
00:05:22,950 --> 00:05:25,690
モジュロ演算子であります
それは、剰余を返します

102
00:05:25,690 --> 00:05:27,680
2つの数の間の分裂の。

103
00:05:27,680 --> 00:05:30,270
私は50モッズ5を持っていたと言います。

104
00:05:30,270 --> 00:05:34,070
さて、5は50の要因です、
だから余りが0になります。

105
00:05:34,070 --> 00:05:39,230
50モッズ10--だけでなく、10も要因であります
50のため、残りも0です。

106
00:05:39,230 --> 00:05:43,660
50モッズ50--よく、任意の数のモッズ自体
任意の残りの部分を持っているつもりはありません。

107
00:05:43,660 --> 00:05:45,510
>> 何のmod 49〜約50？

108
00:05:45,510 --> 00:05:47,910
まあ、49のみ50回になります。

109
00:05:47,910 --> 00:05:50,290
だから、残りは1になるだろう。

110
00:05:50,290 --> 00:05:55,180
53モッズ50に起こっています
あなたの3の残りの部分を与えます。

111
00:05:55,180 --> 00:05:59,120
>> では、どのよう剰余を使用することができます
そしておそらくいくつかの部門

112
00:05:59,120 --> 00:06:01,690
私たちの貪欲なアルゴリズムを実装するには？

113
00:06:01,690 --> 00:06:05,550
まあ、我々はまだに忠実であり続けるしたいです
そのalgorithm--貪欲の心

114
00:06:05,550 --> 00:06:07,910
可能な最大のコインを使用しています。

115
00:06:07,910 --> 00:06:14,570
>> だから我々は、いずれかを使用することができるかどうかを自問してみましょう
四半期は、ユーザーに$ 0.32戻ります。

116
00:06:14,570 --> 00:06:20,070
まあ、32モッズ25与えます
US $ 0.07残りの部分。

117
00:06:20,070 --> 00:06:24,500
だから、私たちは間違いなくできることを教えてくれる
$ 0.07残っている四分の一を使用します。

118
00:06:24,500 --> 00:06:26,180
>> 我々は、任意のダイムを使用することはできますか？

119
00:06:26,180 --> 00:06:32,740
まあ、no--ために$ 0.07のmod
$ 0.10私たちに7の残りの部分を提供します。

120
00:06:32,740 --> 00:06:34,960
10は、すべて7になりません。

121
00:06:34,960 --> 00:06:36,390
>> その後、我々は硬貨を使用できますか？

122
00:06:36,390 --> 00:06:40,490
まあ$ 0.07のmod 5セント
私たちの残りの2を与えます。

123
00:06:40,490 --> 00:06:42,930
そして最後に、私たちはあらゆるペニーを使用できますか？

124
00:06:42,930 --> 00:06:45,930
2のmod 1は、私たちに0を与えます
これは最終的に何をされ

125
00:06:45,930 --> 00:06:48,160
我々はそのために必要な
私たちが戻ってきたことを意味し

126
00:06:48,160 --> 00:06:50,160
ユーザーに変更をすべて負っ。

127
00:06:50,160 --> 00:06:54,320
>> だから今は、の2つの方法を持っています
貪欲algorithm--を実装

128
00:06:54,320 --> 00:06:59,230
ループと1とで1
モジュロ除算の組み合わせ。

129
00:06:59,230 --> 00:07:03,010
だから最終的に、私たちはする必要があり
コインの最終的な数を印刷します。

130
00:07:03,010 --> 00:07:06,520
>> 私は私が持っていたことを伝えたかった場合
3ペットとこの値はハードコードされました、

131
00:07:06,520 --> 00:07:09,240
その後、私はちょうど使用することができます
簡易印刷テストステートメント。

132
00:07:09,240 --> 00:07:12,320
しかし、私たちの価値は実際にあります
変数に格納されています。

133
00:07:12,320 --> 00:07:15,260
だから、どのように印刷します
変数に格納されている値？

134
00:07:15,260 --> 00:07:17,880
>> このために我々は取ります
プレースホルダの利点。

135
00:07:17,880 --> 00:07:21,540
私はすでに宣言していたと言います
初期化された整数n。

136
00:07:21,540 --> 00:07:25,170
そして、後で私がいることを印刷したい場合
値は、その後、私は、文字列を記述します。

137
00:07:25,170 --> 00:07:30,500
その代わりに私が使用するその値の
そのinteger--％私のプレースホルダ。

138
00:07:30,500 --> 00:07:33,800
次に文字列の後に、私が持っています
変数が続くカンマ、

139
00:07:33,800 --> 00:07:34,950
私は印刷すること。

140
00:07:34,950 --> 00:07:38,550
そして後に、それは印刷したときに、
それはnの値を印刷します。

141
00:07:38,550 --> 00:07:41,570
>> 私はまた、プレースホルダを使用することができます
フロートのための、例えば。

142
00:07:41,570 --> 00:07:44,000
私はどのようにあなたに伝えたい場合
私は私のポケットの中に持っている多くの現金、

143
00:07:44,000 --> 00:07:46,820
その後、私は％fがドルを持って言うことができます。

144
00:07:46,820 --> 00:07:51,330
そして後には印刷したときに、その後のn意志に
そのプレースホルダの場所を取ります。

145
00:07:51,330 --> 00:07:55,530
私はまた、例えば、いくつかを使用することができます
いくつかの変数のプレースホルダ。

146
00:07:55,530 --> 00:07:57,590
だから限り、私はリストとして
その後、それらのためには、I

147
00:07:57,590 --> 00:08:00,390
どのように多くを伝えることができます
犬や猫は私が持っています。

148
00:08:00,390 --> 00:08:03,710
>> 今、私たちは要求するように方法を知っています
変化量のためのユーザー、

149
00:08:03,710 --> 00:08:06,130
すなわち、入力を確実
私たちは、その後、有効であり、

150
00:08:06,130 --> 00:08:10,370
実装の2つの方法を持っています
常に使用しての欲張りアルゴリズム

151
00:08:10,370 --> 00:08:12,090
可能な最大のコイン。

152
00:08:12,090 --> 00:08:15,050
我々はトラックを維持したので
我々が使っているどのように多くのコイン、

153
00:08:15,050 --> 00:08:19,210
私たちは、その後、最後にその値を印刷することができます
彼らがしているどのように多くのコインをユーザーに伝えます

154
00:08:19,210 --> 00:08:20,240
取り戻します。

155
00:08:20,240 --> 00:08:24,240
>> 私の名前はAmaylaであり、これはCS50です。

156
00:08:24,240 --> 00:08:25,915

