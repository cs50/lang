それでは、貪欲取得してみましょう。 貪欲で、私たちの仕事は、再生することです 貪欲レジの役割。 ユーザーはどのように私たちに教えてくれます 我々は彼らを借りて多くの変更、 そしてその後、私たちの仕事は、計算することです。 コインの最小数 我々が作るために使用することができます 変化の量。 

例を見てみましょう。 ユーザーがバック$ 0.32必要と言います。 私たちは、与えることによってこれを行うことができます それらの32ペニー、1セントそれぞれ。 それとも私はまたによって5 coins--を使用することができます 3ダイムそれらを与え、$ 0.10それぞれ、 そして、2ペニー、$ 0.02各。 しかし、私たちも使用することができます 少ないコインはそれを作るには？ 

greedy--全体戦術 貪欲cashier--ことにします 可能な最大のコインを使用することです。 だから私たちはいつでも 四半期は、我々はそれらを使用します。 そしてそれらは、不足してしまうと 我々はダイム、$ 0.10をそれぞれ使用します。 次に硬貨、5セントごと、および その後、ペニーに至るまで、1セントそれぞれ。 最大のコインを使用して 可能な限り我々はできます、 我々は、最も少ない数を使用していることを確認します 変更をすることが可能コインの。 

それでは、これを見てみましょう。 ユーザーは$ 0.32必要があります。 だから我々は自問し、 我々は四半期を使用できますか？ まあ、はい我々はできます。 だから今我々は彼らを知っています $ 0.07私たちは1コインを使用していました。 

我々は別の四半期を使用することはできますか？ うーん、ダメ。 $ 0.07 $ 0.25以下であるので、我々は続行します 次に利用可能な最大のコインへ。 ダイムは$ 0.10であり、 再び、我々はダイムを使用することはできません。 ダイムは$ 0.10の価値があるのでれます 未払いの変化量よりも多いです。 

私たちは、硬貨に行きます。 そして、はい確かに、$ 0.05未満であります $ 0.10--ので、私たちは、ニッケルを使用することができます。 だから今、私たちはユーザーのみ$ 0.02借りて、 我々はこれまでに2枚のコインを使用しました。 私たちは別のニッケルを使用することはできません。 それでは、私たちはで最後のコインに進みます ペニーている私たちの処分、。 

そして、私たちはペニーを使用できますか？ まあ、yes--と我々は2を使用して終了 4コインの合計のためのペニー。 

設定が完了したら、 プログラムは次のようになります。 ユーザーが実行されると 貪欲プログラム、彼らはよ の量を与えるように求めるメッセージが表示され 彼らが負っているドルの変化。 そして、あなたのプログラムが出力されます コインの最小量 貪欲なレジ係が使用することを 変化の量を作るために。 

だから今、これを破るのを聞かせて 私たちのサブタスクにダウン。 まず、私たちの入力を要求するつもりです 変化量のためのユーザー。 そして、任意のユーザの入力と同じように、私たちがしたいです 私たちはその入力を検証していることを確認してください そして、我々はそれを使用できることを確認 私たちのプログラムの残りの部分のための入力。 その後、我々は常にしようとしています 可能な最大のポイントを使用 そして、使用コインを追跡します。 そして最後に、最終の印刷 我々が使用したコインの数。 

それでは、プロンプトについて話しましょう​​。 量は、セントを作る必要があります これはドルです。 だからドルのために、我々はつもりです フロート変数の型を使用します。 今、あなたが入力をユーザーに要求するたびに、 あなたはそれが有効だことを確認します。 だからここでは、優位性を利用したいです DO-whil​​eループ構築物の。 

DO-whil​​eループが実行されます ループの本体に少なくとも一回。 だから、これは便利です。 我々は促すために必要があることを知っています 少なくとも一度フロートのためのユーザー。 今でフロートが有効である場合。 それは素晴らしいことです。 私たちは、上に移動します。 ない場合は、ループが保証されます 我々は適切なフロートを取得すること まで連続繰り返すことにより、 ユーザーは、私たちに有効な値を提供します。 

今DO-しばらくの間 ループ条件、我々が必要です それが何を意味するのかを検討します 無効なフロートを持っています。 との関連についてはこれ おそらく、この問題は、 それだけで理にかなって 正の値を受け入れます。 

だからon--移動我々が得てきました ユーザーからのドルの値。 しかし、我々は、コインを扱っています、 これはセントで完全にされています。 $ 1は100セントに相当します。 これを行うには良いことがにあります これらの値は、セントに変換します。 

今フロートから変換するとき 整数に、セントドルので、 我々は慎重にしていることを確認します 浮動小数点の不正確さについて。 だからthat--が言う意味します 私のドルは私のフロートをvalue-- value--はまだ、あっても$ 2が存在しました そこにいくつかの浮遊数字であってもよいです。 だから我々はそれを確認するだけでなく、 私たちはセントを取得するために100を掛けますか、 私たちもそれを丸めます。 

だから今、私たちは量を持っています 変更のユーザーに支払うべき。 私たちは、もともとドルでそれを得ました、 そして今、私たちはセントにそれを変換しました。 だから今、私たちはの中心部に進むことができます 常に貪欲アルゴリズム、 可能な最大のコインを使用して。 我々はこれをやっているが、 それは、我々も不可欠です どのように多くのコインを追跡 ユーザに返されるつもり 同様に残りの ユーザーに支払うべき変更。 

プログラムが検索されます このようなもの。 あなたは量を取得した後 ドルとセントにそれを変換し、 あなたは、ループを入力します。 四半期にはなることができますが そのused--と言うことです しばらくに対する債務の変化量 ユーザは、より大きいまたは$ 0.25等しく、 あなたは四半期を使用します。 

今、何が伴う四半期を使用していますか？ さて、あなたはコインを増やします選びます -  ユーザーに返される数えます。 そして第二に、あなたは電流を低減します 変化の量は、ユーザに戻って負っ $ 0.25。 

までこれを繰り返した後 四半期は、もはや使用することができ、 次の最大に進みます この場合、ダイム、$ 0.10 coin--。 だから、まで、そのループを入力します あなたは、もはやダイムを使用することはできません。 その後、次へ進みます 最大コイン、硬貨。 硬貨は、もはや使用することができた後、 ペニーで残量を使用しています。 そして最後に、印刷 使用コインの枚数。 

もう一つの方法のことができます。 貪欲な問題に取り組みます モジュロアプローチを使用することです。 モジュロ演算子であります それは、剰余を返します 2つの数の間の分裂の。 私は50モッズ5を持っていたと言います。 さて、5は50の要因です、 だから余りが0になります。 50モッズ10--だけでなく、10も要因であります 50のため、残りも0です。 50モッズ50--よく、任意の数のモッズ自体 任意の残りの部分を持っているつもりはありません。 

何のmod 49〜約50？ まあ、49のみ50回になります。 だから、残りは1になるだろう。 53モッズ50に起こっています あなたの3の残りの部分を与えます。 

では、どのよう剰余を使用することができます そしておそらくいくつかの部門 私たちの貪欲なアルゴリズムを実装するには？ まあ、我々はまだに忠実であり続けるしたいです そのalgorithm--貪欲の心 可能な最大のコインを使用しています。 

だから我々は、いずれかを使用することができるかどうかを自問してみましょう 四半期は、ユーザーに$ 0.32戻ります。 まあ、32モッズ25与えます US $ 0.07残りの部分。 だから、私たちは間違いなくできることを教えてくれる $ 0.07残っている四分の一を使用します。 

我々は、任意のダイムを使用することはできますか？ まあ、no--ために$ 0.07のmod $ 0.10私たちに7の残りの部分を提供します。 10は、すべて7になりません。 

その後、我々は硬貨を使用できますか？ まあ$ 0.07のmod 5セント 私たちの残りの2を与えます。 そして最後に、私たちはあらゆるペニーを使用できますか？ 2のmod 1は、私たちに0を与えます これは最終的に何をされ 我々はそのために必要な 私たちが戻ってきたことを意味し ユーザーに変更をすべて負っ。 

だから今は、の2つの方法を持っています 貪欲algorithm--を実装 ループと1とで1 モジュロ除算の組み合わせ。 だから最終的に、私たちはする必要があり コインの最終的な数を印刷します。 

私は私が持っていたことを伝えたかった場合 3ペットとこの値はハードコードされました、 その後、私はちょうど使用することができます 簡易印刷テストステートメント。 しかし、私たちの価値は実際にあります 変数に格納されています。 だから、どのように印刷します 変数に格納されている値？ 

このために我々は取ります プレースホルダの利点。 私はすでに宣言していたと言います 初期化された整数n。 そして、後で私がいることを印刷したい場合 値は、その後、私は、文字列を記述します。 その代わりに私が使用するその値の そのinteger--％私のプレースホルダ。 次に文字列の後に、私が持っています 変数が続くカンマ、 私は印刷すること。 そして後に、それは印刷したときに、 それはnの値を印刷します。 

私はまた、プレースホルダを使用することができます フロートのための、例えば。 私はどのようにあなたに伝えたい場合 私は私のポケットの中に持っている多くの現金、 その後、私は％fがドルを持って言うことができます。 そして後には印刷したときに、その後のn意志に そのプレースホルダの場所を取ります。 私はまた、例えば、いくつかを使用することができます いくつかの変数のプレースホルダ。 だから限り、私はリストとして その後、それらのためには、I どのように多くを伝えることができます 犬や猫は私が持っています。 

今、私たちは要求するように方法を知っています 変化量のためのユーザー、 すなわち、入力を確実 私たちは、その後、有効であり、 実装の2つの方法を持っています 常に使用しての欲張りアルゴリズム 可能な最大のコイン。 我々はトラックを維持したので 我々が使っているどのように多くのコイン、 私たちは、その後、最後にその値を印刷することができます 彼らがしているどのように多くのコインをユーザーに伝えます 取り戻します。 

私の名前はAmaylaであり、これはCS50です。 