Давайте жадібний. У жодній, наша робота полягає в тому, щоб грати роль жодного касира. Користувач розповість нам, як багато змін, які ми їм зобов'язані, і наша робота полягає в тому, щоб обчислити мінімальна кількість монет що ми можемо використовувати, щоб зробити що кількість змін. 

Давайте почнемо з прикладу. Скажімо, користувачеві потрібно $ 0,32 назад. Ми могли б зробити це, даючи їх 32 копійки, один цент кожна. Або я міг би також використовувати п'ять coins-- шляхом даючи їм трьох п'ятаків, $ 0,10 кожна, і дві копійки, $ 0,02 кожна. Але ми могли б використовувати навіть менше монет, щоб зробити це? 

Вся тактика в greedy-- бути жадібним cashier-- є використання найбільшу можливу монету. Таким чином, всякий раз, коли у нас є чверті ми будемо використовувати їх. А потім, як тільки ті закінчилися, ми будемо використовувати п'ятаків, $ 0,10 кожна. Тоді нікелеві, 5 центів кожен, і потім вниз до копійки, один цент кожна. Використовуючи найбільшу монету можливо всякий раз, коли ми можемо, ми гарантуємо, що ми використовуємо найменше число монет можна зробити зміни. 

Так давайте пройдемо через це. Користувачеві потрібно $ 0,32. Таким чином, ми запитуємо себе, ми можемо використовувати чверть? Ну, да, ми можемо. Так що тепер ми знаємо тільки їх $ 0,07, і ми використовували одну монету. 

Чи можемо ми використовувати ще чверть? Ну, немає. $ 0,07 менше, ніж $ 0,25, тому ми переходимо до наступного за величиною доступною монети. Dimes становить $ 0,10, і знову ж таки, ми не можемо використовувати п'ятаків. Тому що п'ятаків коштує $ 0.10, який більше, ніж сума зміни заборгованості. 

Ми йдемо до нікелеві. І, так, дійсно, $ 0,05 менше $ 0.10-- тому ми можемо використовувати нікель. Отже, тепер ми тільки зобов'язані користувачеві $ 0,02, і ми до сих пір використовували дві монети. Ми не можемо використовувати ще один нікель. Отже, ми переходимо до останньої монети в нашому розпорядженні, які є гроші. 

І чи можемо ми використовувати пенні? Ну, yes-- і ми в кінцевому підсумку за допомогою двох пенси в цілому чотири монети. 

Після того, як ви закінчите, Програма буде виглядати наступним чином. Після того, як користувач запускає жадібні програма, вони будуть буде запропоновано дати суму Зміна в доларах, що вони повинні. І тоді ваш висновок програми буде мінімальна кількість монет що жадібні касира буде використовувати щоб зробити таку кількість змін. 

Так що тепер давайте розберемо цей вниз в наших підзадач. По-перше, ми збираємося, щоб наша користувача на суму зміни. І, як і з будь-яким призначеним для користувача введенням, ми хочемо переконайтеся, що ми стверджуємо, що введення і переконайтеся, що ми можемо використовувати вхід для іншої частини нашої програми. Тоді ми будемо завжди використовувати найбільшу точку можливого і стежити за монет, які використовуються. І, нарешті, роздрукувати остаточне кількість монет, які ми використовували. 

Отже, давайте поговоримо про спонукаючи. Сума повинна зробити центів, і це в доларах. І так за долари, ми будемо використовувати тип змінної з плаваючою точкою. Тепер, коли ви попросите користувача для введення, Ви хочете, щоб переконатися, що вона діє. І тому тут ми хотіли б скористатися конструкту зроби час циклу. 

Цикл Do-то час буде виконувати тіло циклу принаймні один раз. Так що це дуже зручно. Ми знаємо, що нам потрібно, щоб спонукати користувач щонайменше, один раз за поплавком. Тепер, якщо це поплавок діє. Це чудово. Ми йдемо далі. Але якщо немає, то цикл буде забезпечувати що ми отримуємо правильний поплавок шляхом безперервного повторення до тих пір, користувач дає нам дійсне значення. 

Тепер зроби час умова циклу, ми повинні розглянути питання про те, що значить мати неприпустимий поплавок. Так що для контексту ця проблема, ймовірно, це має сенс тільки приймають позитивні значення. 

Таким чином, переміщення on-- ми отримували вартість в доларах від користувача. Але ми маємо справу з монетами, які повністю в центах. $ 1 еквівалентно 100 центів. Так що хороша річ, щоб зробити, це перетворити ці значення в центів. 

Тепер при перетворенні з поплавка в ціле число, так що долари в центів, ми хочемо, щоб переконатися, що ми обережні про плаваючою точкою неточностей. Так що означає that-- сказати мій долар value-- мій поплавок value-- був ще $ 2, до цих пір можуть бути деякі паразитні числа там. Тому ми хочемо, щоб переконатися, що не тільки ми множимо на 100, щоб отримати центів, але ми також довершення. 

Так що тепер ми маємо суму зміни заборгованості перед користувачем. Спочатку ми отримали його в доларах, і тепер ми перетворили його в центів. Так що тепер ми можемо перейти з серцем жадібний алгоритм, який завжди використовуючи найбільшу монету можливо. Незважаючи на те, що ми робимо це, дуже важливо, що ми також відслідковувати, скільки монети буде повернута користувачеві а також інші змінити належні до користувача. 

Програма буде виглядати щось на зразок цього. Після того, як ви отримаєте суму доларів і конвертувати, що в центів, то вам потрібно буде ввести петлю. У той час як приміщення можуть бути used-- тобто в той час як кількість змін, належних Користувач більше або дорівнює $ 0,25, ви будете використовувати чверть. 

Тепер те, що робить за допомогою чверть тягне за собою? Ну, одно-- ви збільшите монету розраховувати, щоб бути повернуті користувачеві. І по-друге ви будете зменшувати струм величина зміни заборгував назад користувачеві на $ 0,25. 

Після того, як не повторювати, що до тих пір, чверті не може бути більше не використовується, перейти до наступного за величиною coin-- в цьому випадку п'ятаків, $ 0.10. Таким чином, ви не будете ввести цей цикл до тих пір, Ви більше не можете використовувати п'ятаків. Потім переходьте до наступного за величиною монета, нікелеві. Після того, як нікелеві більше не можуть бути використані, використовувати решту суми в гроші. І, нарешті, роздрукувати кількість монет використовується. 

Інший спосіб, який ви можете підійти до жадібному проблеми полягає в використанні по модулю підхід. Модульне є оператором що повертає залишок поділу між двома числами. Скажімо, у мене було 50 мод 5. Ну, 5 є фактором 50, так що залишок буде дорівнює 0. 50 мод 10-- добре, 10 також є фактором 50, так що інші теж 0. 50 мод 50-- добре, будь-яке число мод сам не матиме будь-якої залишок. 

А як щодо 50 мод 49? Що ж, 49 йде тільки в 50 разів. Таким чином, залишок буде 1. 53 мод 50 збирається дати вам решту 3. 

Так як ми можемо використовувати по модулю і, можливо, деякі розподіл реалізувати наш жадібний алгоритм? Ну, ми все ще хочемо залишитися вірним Серце жадібний algorithm--, що використовує найбільшу монету можливо. 

Отже, давайте запитаємо себе, якщо ми можемо використовувати будь-який чверті, щоб повернути $ 0,32 до користувача. Ну, 32 мод 25 дає ми залишок від $ 0,07. Так що говорить нам, що ми можемо впевнено використовувати одну чверть з $ 0,07 до кінця. 

Чи можемо ми використовувати будь-які п'ятаків? Ну, тому що no-- $ 0,07 мод $ 0.10 дає нам залишок від 7. 10 не входить в 7 взагалі. 

Тоді ми можемо використовувати нікелеві? Добре $ 0.07 мода 5 центів дає нам два залишилися. І, нарешті, ми можемо використовувати будь-які гроші? 2 мод 1 дає нам 0, яка в кінцевому рахунку, що ми хочемо, тому що тоді, що означає, що ми повернулися користувачеві всі зміни повинні. 

Так що тепер у вас є два можливих шляхи реалізації жадібний algorithm-- одна з петель і одна з комбінація по модулю і ділення. Таким чином, в кінці кінців, нам просто потрібно друк підсумкове кількість монет. 

Якби я хотів сказати вам, що я мав 3 домашніх тварин, і це значення було жорстко, то я міг би просто використовувати простий тест оператор друку. Але наша цінність насправді зберігається в змінної. Так як же ви надрукувати Значення зберігаються в змінних? 

Для цього ми беремо Перевага наповнювачів. Скажімо, у мене вже оголосили ініціалізованих ціле число п. Тоді в подальшому, якщо я хотів надрукувати, що значення, то я хотів би написати рядок. І замість цього значення я хотів би використовувати заповнювач для цього integer -% я. Потім після рядка, у мене є кома, а потім змінної що я хочу, щоб надрукувати. І пізніше, коли він друкує, він буде виводити значення п. 

Я міг би також використовувати заповнювач для поплавком, наприклад. Якби я хотів сказати вам, як скільки грошей у мене в кишені, то я міг би сказати, що я% F доларів. І пізніше, коли він друкує, то п буде зайняти місце цього власника місце. Я міг би також, наприклад, використовувати кілька наповнювачі для декількох змінних. Так що до тих пір, як я список вони в порядку, то я можу вам сказати, скільки собаки і кішки, у мене є. 

Тепер ми знаємо, як спонукати користувача на суму зміни, переконайтеся, що цей вхід є дійсним, і тоді ми є два можливих шляхи реалізації жадібний алгоритм завжди використовуючи найбільша монета можливо. Оскільки ми відстежували скільки монет ми використовуємо, ми можемо надрукувати це значення в кінці, який повідомляє користувачеві, скільки монет вони повертатися. 

Мене звуть Amayla, і це CS50. 