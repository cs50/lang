1
00:00:00,000 --> 00:00:00,710

2
00:00:00,710 --> 00:00:02,900
>> Давайте жадібний.

3
00:00:02,900 --> 00:00:06,810
У жодній, наша робота полягає в тому, щоб грати
роль жодного касира.

4
00:00:06,810 --> 00:00:09,750
Користувач розповість нам, як
багато змін, які ми їм зобов'язані,

5
00:00:09,750 --> 00:00:13,520
і наша робота полягає в тому, щоб обчислити
мінімальна кількість монет

6
00:00:13,520 --> 00:00:17,240
що ми можемо використовувати, щоб зробити
що кількість змін.

7
00:00:17,240 --> 00:00:19,560
>> Давайте почнемо з прикладу.

8
00:00:19,560 --> 00:00:23,170
Скажімо, користувачеві потрібно $ 0,32 назад.

9
00:00:23,170 --> 00:00:28,960
Ми могли б зробити це, даючи
їх 32 копійки, один цент кожна.

10
00:00:28,960 --> 00:00:35,180
Або я міг би також використовувати п'ять coins-- шляхом
даючи їм трьох п'ятаків, $ 0,10 кожна,

11
00:00:35,180 --> 00:00:38,060
і дві копійки, $ 0,02 кожна.

12
00:00:38,060 --> 00:00:42,580
Але ми могли б використовувати навіть
менше монет, щоб зробити це?

13
00:00:42,580 --> 00:00:45,100
>> Вся тактика в greedy--
бути жадібним cashier--

14
00:00:45,100 --> 00:00:47,600
є використання найбільшу можливу монету.

15
00:00:47,600 --> 00:00:50,670
Таким чином, всякий раз, коли у нас є
чверті ми будемо використовувати їх.

16
00:00:50,670 --> 00:00:54,100
А потім, як тільки ті закінчилися,
ми будемо використовувати п'ятаків, $ 0,10 кожна.

17
00:00:54,100 --> 00:00:58,840
Тоді нікелеві, 5 центів кожен, і
потім вниз до копійки, один цент кожна.

18
00:00:58,840 --> 00:01:01,792
Використовуючи найбільшу монету
можливо всякий раз, коли ми можемо,

19
00:01:01,792 --> 00:01:07,350
ми гарантуємо, що ми використовуємо найменше число
монет можна зробити зміни.

20
00:01:07,350 --> 00:01:09,180
>> Так давайте пройдемо через це.

21
00:01:09,180 --> 00:01:11,660
Користувачеві потрібно $ 0,32.

22
00:01:11,660 --> 00:01:14,200
Таким чином, ми запитуємо себе,
ми можемо використовувати чверть?

23
00:01:14,200 --> 00:01:15,560
Ну, да, ми можемо.

24
00:01:15,560 --> 00:01:19,720
Так що тепер ми знаємо тільки їх
$ 0,07, і ми використовували одну монету.

25
00:01:19,720 --> 00:01:20,970
>> Чи можемо ми використовувати ще чверть?

26
00:01:20,970 --> 00:01:21,890
Ну, немає.

27
00:01:21,890 --> 00:01:27,570
$ 0,07 менше, ніж $ 0,25, тому ми переходимо
до наступного за величиною доступною монети.

28
00:01:27,570 --> 00:01:30,690
Dimes становить $ 0,10, і
знову ж таки, ми не можемо використовувати п'ятаків.

29
00:01:30,690 --> 00:01:35,480
Тому що п'ятаків коштує $ 0.10, який
більше, ніж сума зміни заборгованості.

30
00:01:35,480 --> 00:01:36,790
>> Ми йдемо до нікелеві.

31
00:01:36,790 --> 00:01:40,890
І, так, дійсно, $ 0,05 менше
$ 0.10-- тому ми можемо використовувати нікель.

32
00:01:40,890 --> 00:01:46,104
Отже, тепер ми тільки зобов'язані користувачеві $ 0,02,
і ми до сих пір використовували дві монети.

33
00:01:46,104 --> 00:01:47,270
Ми не можемо використовувати ще один нікель.

34
00:01:47,270 --> 00:01:51,140
Отже, ми переходимо до останньої монети в
нашому розпорядженні, які є гроші.

35
00:01:51,140 --> 00:01:52,270
>> І чи можемо ми використовувати пенні?

36
00:01:52,270 --> 00:01:59,060
Ну, yes-- і ми в кінцевому підсумку за допомогою двох
пенси в цілому чотири монети.

37
00:01:59,060 --> 00:02:01,430
>> Після того, як ви закінчите,
Програма буде виглядати наступним чином.

38
00:02:01,430 --> 00:02:03,710
Після того, як користувач запускає
жадібні програма, вони будуть

39
00:02:03,710 --> 00:02:07,270
буде запропоновано дати суму
Зміна в доларах, що вони повинні.

40
00:02:07,270 --> 00:02:11,140
І тоді ваш висновок програми буде
мінімальна кількість монет

41
00:02:11,140 --> 00:02:14,740
що жадібні касира буде використовувати
щоб зробити таку кількість змін.

42
00:02:14,740 --> 00:02:18,160
>> Так що тепер давайте розберемо цей
вниз в наших підзадач.

43
00:02:18,160 --> 00:02:21,410
По-перше, ми збираємося, щоб наша
користувача на суму зміни.

44
00:02:21,410 --> 00:02:25,630
І, як і з будь-яким призначеним для користувача введенням, ми хочемо
переконайтеся, що ми стверджуємо, що введення

45
00:02:25,630 --> 00:02:29,360
і переконайтеся, що ми можемо використовувати
вхід для іншої частини нашої програми.

46
00:02:29,360 --> 00:02:32,480
Тоді ми будемо завжди
використовувати найбільшу точку можливого

47
00:02:32,480 --> 00:02:35,240
і стежити за монет, які використовуються.

48
00:02:35,240 --> 00:02:39,080
І, нарешті, роздрукувати остаточне
кількість монет, які ми використовували.

49
00:02:39,080 --> 00:02:40,970
>> Отже, давайте поговоримо про спонукаючи.

50
00:02:40,970 --> 00:02:43,550
Сума повинна зробити центів,
і це в доларах.

51
00:02:43,550 --> 00:02:48,440
І так за долари, ми будемо
використовувати тип змінної з плаваючою точкою.

52
00:02:48,440 --> 00:02:52,390
Тепер, коли ви попросите користувача для введення,
Ви хочете, щоб переконатися, що вона діє.

53
00:02:52,390 --> 00:02:56,640
І тому тут ми хотіли б скористатися
конструкту зроби час циклу.

54
00:02:56,640 --> 00:03:00,320
>> Цикл Do-то час буде виконувати
тіло циклу принаймні один раз.

55
00:03:00,320 --> 00:03:01,650
Так що це дуже зручно.

56
00:03:01,650 --> 00:03:05,510
Ми знаємо, що нам потрібно, щоб спонукати
користувач щонайменше, один раз за поплавком.

57
00:03:05,510 --> 00:03:07,100
Тепер, якщо це поплавок діє.

58
00:03:07,100 --> 00:03:07,710
Це чудово.

59
00:03:07,710 --> 00:03:08,460
Ми йдемо далі.

60
00:03:08,460 --> 00:03:11,910
Але якщо немає, то цикл буде забезпечувати
що ми отримуємо правильний поплавок

61
00:03:11,910 --> 00:03:16,810
шляхом безперервного повторення до тих пір,
користувач дає нам дійсне значення.

62
00:03:16,810 --> 00:03:18,760
>> Тепер зроби час
умова циклу, ми повинні

63
00:03:18,760 --> 00:03:22,000
розглянути питання про те, що значить
мати неприпустимий поплавок.

64
00:03:22,000 --> 00:03:24,220
Так що для контексту
ця проблема, ймовірно,

65
00:03:24,220 --> 00:03:27,450
це має сенс тільки
приймають позитивні значення.

66
00:03:27,450 --> 00:03:32,010
>> Таким чином, переміщення on-- ми отримували
вартість в доларах від користувача.

67
00:03:32,010 --> 00:03:35,380
Але ми маємо справу з монетами,
які повністю в центах.

68
00:03:35,380 --> 00:03:38,660
$ 1 еквівалентно 100 центів.

69
00:03:38,660 --> 00:03:43,670
Так що хороша річ, щоб зробити, це
перетворити ці значення в центів.

70
00:03:43,670 --> 00:03:48,380
>> Тепер при перетворенні з поплавка
в ціле число, так що долари в центів,

71
00:03:48,380 --> 00:03:52,230
ми хочемо, щоб переконатися, що ми обережні
про плаваючою точкою неточностей.

72
00:03:52,230 --> 00:03:55,260
Так що означає that-- сказати
мій долар value-- мій поплавок

73
00:03:55,260 --> 00:04:00,260
value-- був ще $ 2, до цих пір
можуть бути деякі паразитні числа там.

74
00:04:00,260 --> 00:04:04,590
Тому ми хочемо, щоб переконатися, що не тільки
ми множимо на 100, щоб отримати центів,

75
00:04:04,590 --> 00:04:06,480
але ми також довершення.

76
00:04:06,480 --> 00:04:09,210
>> Так що тепер ми маємо суму
зміни заборгованості перед користувачем.

77
00:04:09,210 --> 00:04:13,430
Спочатку ми отримали його в доларах,
і тепер ми перетворили його в центів.

78
00:04:13,430 --> 00:04:17,029
Так що тепер ми можемо перейти з серцем
жадібний алгоритм, який завжди

79
00:04:17,029 --> 00:04:19,220
використовуючи найбільшу монету можливо.

80
00:04:19,220 --> 00:04:21,930
Незважаючи на те, що ми робимо це,
дуже важливо, що ми також

81
00:04:21,930 --> 00:04:25,360
відслідковувати, скільки монети
буде повернута користувачеві

82
00:04:25,360 --> 00:04:28,630
а також інші
змінити належні до користувача.

83
00:04:28,630 --> 00:04:31,130
>> Програма буде виглядати
щось на зразок цього.

84
00:04:31,130 --> 00:04:34,190
Після того, як ви отримаєте суму
доларів і конвертувати, що в центів,

85
00:04:34,190 --> 00:04:35,790
то вам потрібно буде ввести петлю.

86
00:04:35,790 --> 00:04:38,400
У той час як приміщення можуть бути
used-- тобто

87
00:04:38,400 --> 00:04:43,660
в той час як кількість змін, належних
Користувач більше або дорівнює $ 0,25,

88
00:04:43,660 --> 00:04:45,040
ви будете використовувати чверть.

89
00:04:45,040 --> 00:04:47,000
>> Тепер те, що робить за допомогою чверть тягне за собою?

90
00:04:47,000 --> 00:04:51,280
Ну, одно-- ви збільшите монету
розраховувати, щоб бути повернуті користувачеві.

91
00:04:51,280 --> 00:04:55,890
І по-друге ви будете зменшувати струм
величина зміни заборгував назад користувачеві

92
00:04:55,890 --> 00:04:57,520
на $ 0,25.

93
00:04:57,520 --> 00:05:00,680
>> Після того, як не повторювати, що до тих пір,
чверті не може бути більше не використовується,

94
00:05:00,680 --> 00:05:04,630
перейти до наступного за величиною
coin-- в цьому випадку п'ятаків, $ 0.10.

95
00:05:04,630 --> 00:05:07,750
Таким чином, ви не будете ввести цей цикл до тих пір,
Ви більше не можете використовувати п'ятаків.

96
00:05:07,750 --> 00:05:10,720
Потім переходьте до наступного
за величиною монета, нікелеві.

97
00:05:10,720 --> 00:05:14,810
Після того, як нікелеві більше не можуть бути використані,
використовувати решту суми в гроші.

98
00:05:14,810 --> 00:05:17,800
І, нарешті, роздрукувати
кількість монет використовується.

99
00:05:17,800 --> 00:05:20,350
>> Інший спосіб, який ви можете
підійти до жадібному проблеми

100
00:05:20,350 --> 00:05:22,950
полягає в використанні по модулю підхід.

101
00:05:22,950 --> 00:05:25,690
Модульне є оператором
що повертає залишок

102
00:05:25,690 --> 00:05:27,680
поділу між двома числами.

103
00:05:27,680 --> 00:05:30,270
Скажімо, у мене було 50 мод 5.

104
00:05:30,270 --> 00:05:34,070
Ну, 5 є фактором 50,
так що залишок буде дорівнює 0.

105
00:05:34,070 --> 00:05:39,230
50 мод 10-- добре, 10 також є фактором
50, так що інші теж 0.

106
00:05:39,230 --> 00:05:43,660
50 мод 50-- добре, будь-яке число мод сам
не матиме будь-якої залишок.

107
00:05:43,660 --> 00:05:45,510
>> А як щодо 50 мод 49?

108
00:05:45,510 --> 00:05:47,910
Що ж, 49 йде тільки в 50 разів.

109
00:05:47,910 --> 00:05:50,290
Таким чином, залишок буде 1.

110
00:05:50,290 --> 00:05:55,180
53 мод 50 збирається
дати вам решту 3.

111
00:05:55,180 --> 00:05:59,120
>> Так як ми можемо використовувати по модулю
і, можливо, деякі розподіл

112
00:05:59,120 --> 00:06:01,690
реалізувати наш жадібний алгоритм?

113
00:06:01,690 --> 00:06:05,550
Ну, ми все ще хочемо залишитися вірним
Серце жадібний algorithm--, що

114
00:06:05,550 --> 00:06:07,910
використовує найбільшу монету можливо.

115
00:06:07,910 --> 00:06:14,570
>> Отже, давайте запитаємо себе, якщо ми можемо використовувати будь-який
чверті, щоб повернути $ 0,32 до користувача.

116
00:06:14,570 --> 00:06:20,070
Ну, 32 мод 25 дає
ми залишок від $ 0,07.

117
00:06:20,070 --> 00:06:24,500
Так що говорить нам, що ми можемо впевнено
використовувати одну чверть з $ 0,07 до кінця.

118
00:06:24,500 --> 00:06:26,180
>> Чи можемо ми використовувати будь-які п'ятаків?

119
00:06:26,180 --> 00:06:32,740
Ну, тому що no-- $ 0,07 мод
$ 0.10 дає нам залишок від 7.

120
00:06:32,740 --> 00:06:34,960
10 не входить в 7 взагалі.

121
00:06:34,960 --> 00:06:36,390
>> Тоді ми можемо використовувати нікелеві?

122
00:06:36,390 --> 00:06:40,490
Добре $ 0.07 мода 5 центів
дає нам два залишилися.

123
00:06:40,490 --> 00:06:42,930
І, нарешті, ми можемо використовувати будь-які гроші?

124
00:06:42,930 --> 00:06:45,930
2 мод 1 дає нам 0,
яка в кінцевому рахунку, що

125
00:06:45,930 --> 00:06:48,160
ми хочемо, тому що тоді, що
означає, що ми повернулися

126
00:06:48,160 --> 00:06:50,160
користувачеві всі зміни повинні.

127
00:06:50,160 --> 00:06:54,320
>> Так що тепер у вас є два можливих шляхи
реалізації жадібний algorithm--

128
00:06:54,320 --> 00:06:59,230
одна з петель і одна з
комбінація по модулю і ділення.

129
00:06:59,230 --> 00:07:03,010
Таким чином, в кінці кінців, нам просто потрібно
друк підсумкове кількість монет.

130
00:07:03,010 --> 00:07:06,520
>> Якби я хотів сказати вам, що я мав
3 домашніх тварин, і це значення було жорстко,

131
00:07:06,520 --> 00:07:09,240
то я міг би просто використовувати
простий тест оператор друку.

132
00:07:09,240 --> 00:07:12,320
Але наша цінність насправді
зберігається в змінної.

133
00:07:12,320 --> 00:07:15,260
Так як же ви надрукувати
Значення зберігаються в змінних?

134
00:07:15,260 --> 00:07:17,880
>> Для цього ми беремо
Перевага наповнювачів.

135
00:07:17,880 --> 00:07:21,540
Скажімо, у мене вже оголосили
ініціалізованих ціле число п.

136
00:07:21,540 --> 00:07:25,170
Тоді в подальшому, якщо я хотів надрукувати, що
значення, то я хотів би написати рядок.

137
00:07:25,170 --> 00:07:30,500
І замість цього значення я хотів би використовувати
заповнювач для цього integer -% я.

138
00:07:30,500 --> 00:07:33,800
Потім після рядка, у мене є
кома, а потім змінної

139
00:07:33,800 --> 00:07:34,950
що я хочу, щоб надрукувати.

140
00:07:34,950 --> 00:07:38,550
І пізніше, коли він друкує,
він буде виводити значення п.

141
00:07:38,550 --> 00:07:41,570
>> Я міг би також використовувати заповнювач
для поплавком, наприклад.

142
00:07:41,570 --> 00:07:44,000
Якби я хотів сказати вам, як
скільки грошей у мене в кишені,

143
00:07:44,000 --> 00:07:46,820
то я міг би сказати, що я% F доларів.

144
00:07:46,820 --> 00:07:51,330
І пізніше, коли він друкує, то п буде
зайняти місце цього власника місце.

145
00:07:51,330 --> 00:07:55,530
Я міг би також, наприклад, використовувати кілька
наповнювачі для декількох змінних.

146
00:07:55,530 --> 00:07:57,590
Так що до тих пір, як я список
вони в порядку, то я

147
00:07:57,590 --> 00:08:00,390
можу вам сказати, скільки
собаки і кішки, у мене є.

148
00:08:00,390 --> 00:08:03,710
>> Тепер ми знаємо, як спонукати
користувача на суму зміни,

149
00:08:03,710 --> 00:08:06,130
переконайтеся, що цей вхід
є дійсним, і тоді ми

150
00:08:06,130 --> 00:08:10,370
є два можливих шляхи реалізації
жадібний алгоритм завжди використовуючи

151
00:08:10,370 --> 00:08:12,090
найбільша монета можливо.

152
00:08:12,090 --> 00:08:15,050
Оскільки ми відстежували
скільки монет ми використовуємо,

153
00:08:15,050 --> 00:08:19,210
ми можемо надрукувати це значення в кінці,
який повідомляє користувачеві, скільки монет вони

154
00:08:19,210 --> 00:08:20,240
повертатися.

155
00:08:20,240 --> 00:08:24,240
>> Мене звуть Amayla, і це CS50.

156
00:08:24,240 --> 00:08:25,915

