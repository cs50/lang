1
00:00:00,000 --> 00:00:00,710

2
00:00:00,710 --> 00:00:02,900
>> 讓我們貪婪。

3
00:00:02,900 --> 00:00:06,810
在貪婪的，我們的工作就是玩
貪婪收銀員的角色。

4
00:00:06,810 --> 00:00:09,750
用戶將告訴我們如何
太大的變化，我們欠他們的，

5
00:00:09,750 --> 00:00:13,520
然後我們的工作就是計算
硬幣的最小數量

6
00:00:13,520 --> 00:00:17,240
我們可以用它來製作
變化量。

7
00:00:17,240 --> 00:00:19,560
>> 讓我們先從一個例子。

8
00:00:19,560 --> 00:00:23,170
假設用戶需要$ 0.32回來。

9
00:00:23,170 --> 00:00:28,960
我們可以通過給做
他們32便士，每一分錢。

10
00:00:28,960 --> 00:00:35,180
或者，我也可以用五年coins--通過
給他們三天硬幣，$ 0.10，

11
00:00:35,180 --> 00:00:38,060
兩便士，$ 0.02每。

12
00:00:38,060 --> 00:00:42,580
但是，我們可以使用，甚至
更少的硬幣做的？

13
00:00:42,580 --> 00:00:45,100
>> 在greedy--整體戰術
是一個貪婪的cashier--

14
00:00:45,100 --> 00:00:47,600
是使用最大硬幣可能。

15
00:00:47,600 --> 00:00:50,670
所以每當我們有
宿舍，我們將使用它們。

16
00:00:50,670 --> 00:00:54,100
然後，一旦這些用完，
我們將使用硬幣，每個$ 0.10

17
00:00:54,100 --> 00:00:58,840
然後鎳，每次5美分，而
再往下便士，每一分錢。

18
00:00:58,840 --> 00:01:01,792
通過使用最大的硬幣
只要有可能，我們可以，

19
00:01:01,792 --> 00:01:07,350
我們必須確保我們用最少數量的
硬幣的可能作出改變。

20
00:01:07,350 --> 00:01:09,180
>> 因此，讓我們走在這條通過。

21
00:01:09,180 --> 00:01:11,660
用戶需要$ 0.32。

22
00:01:11,660 --> 00:01:14,200
因此，我們捫心自問，
我們可以用四分之一？

23
00:01:14,200 --> 00:01:15,560
嗯，是的，我們可以。

24
00:01:15,560 --> 00:01:19,720
所以，現在我們只知道他們
$ 0.07，我們用一個硬幣。

25
00:01:19,720 --> 00:01:20,970
>> 我們可以用一個季度？

26
00:01:20,970 --> 00:01:21,890
哦，不。

27
00:01:21,890 --> 00:01:27,570
$為0.07少於$ 0.25，所以我們進行
可用下一個最大的硬幣。

28
00:01:27,570 --> 00:01:30,690
角錢為$ 0.10和
再次，我們不能用角錢。

29
00:01:30,690 --> 00:01:35,480
由於硬幣是值得$ 0.10這
比變化的欠款金額。

30
00:01:35,480 --> 00:01:36,790
>> 我們去鎳。

31
00:01:36,790 --> 00:01:40,890
而且，是真的，$是0.05小於
$ 0.10--所以我們可以使用鎳。

32
00:01:40,890 --> 00:01:46,104
所以，現在我們只欠用戶$ 0.02
而且到目前為止我們用了兩個硬幣。

33
00:01:46,104 --> 00:01:47,270
我們不能用另一個鎳。

34
00:01:47,270 --> 00:01:51,140
於是我們進行了最後一枚硬幣在
我們所掌握的，哪些是便士。

35
00:01:51,140 --> 00:01:52,270
>> 我們可以用一分錢？

36
00:01:52,270 --> 00:01:59,060
好吧，yes--和我們最終使用兩個
便士總共四個硬幣。

37
00:01:59,060 --> 00:02:01,430
>> 一旦你完成後，
程序會這個樣子。

38
00:02:01,430 --> 00:02:03,710
一旦用戶運行
貪婪的計劃，他們將

39
00:02:03,710 --> 00:02:07,270
被提示以得到的量
以美元計價的變化，他們正在欠款。

40
00:02:07,270 --> 00:02:11,140
然後你的程序將輸出
硬幣的最小量

41
00:02:11,140 --> 00:02:14,740
該貪婪的收銀員會用
做出改變的量。

42
00:02:14,740 --> 00:02:18,160
>> 所以，現在讓我們來打破這種
下到我們的子任務。

43
00:02:18,160 --> 00:02:21,410
首先我們要提醒我們
用戶對變化量。

44
00:02:21,410 --> 00:02:25,630
並且，與任何用戶輸入，我們希望
確保我們驗證輸入

45
00:02:25,630 --> 00:02:29,360
並確保我們可以使用
輸入對我們的節目的其餘部分。

46
00:02:29,360 --> 00:02:32,480
然後，我們要始終
使用最大可能點

47
00:02:32,480 --> 00:02:35,240
並跟踪使用的硬幣。

48
00:02:35,240 --> 00:02:39,080
最後，打印最終
我們使用硬幣的數目。

49
00:02:39,080 --> 00:02:40,970
>> 所以，讓我們來談談提示。

50
00:02:40,970 --> 00:02:43,550
量必須美分，
這也是美元。

51
00:02:43,550 --> 00:02:48,440
因此對於美元，我們要去
使用浮點變量類型。

52
00:02:48,440 --> 00:02:52,390
現在，每當你問一個用戶輸入，
要確保它是有效的。

53
00:02:52,390 --> 00:02:56,640
所以在這裡我們想利用
的do-whil​​e循環結構。

54
00:02:56,640 --> 00:03:00,320
>> 一個do-whil​​e循環將執行
循環體至少一次。

55
00:03:00,320 --> 00:03:01,650
所以這個就派上用場了。

56
00:03:01,650 --> 00:03:05,510
我們知道，我們需要提示
用戶至少一次的浮動。

57
00:03:05,510 --> 00:03:07,100
現在，如果花車是有效的。

58
00:03:07,100 --> 00:03:07,710
那很棒。

59
00:03:07,710 --> 00:03:08,460
我們繼續前進。

60
00:03:08,460 --> 00:03:11,910
但如果沒有，則循環將確保
我們得到適當浮動

61
00:03:11,910 --> 00:03:16,810
通過不斷重複，直到
用戶為我們提供了一個有效的值。

62
00:03:16,810 --> 00:03:18,760
>> 現在的DO-而
環情況下，我們需要

63
00:03:18,760 --> 00:03:22,000
考慮是什麼意思
有一個無效的浮動。

64
00:03:22,000 --> 00:03:24,220
所以為的範圍內
此問題，​​可能

65
00:03:24,220 --> 00:03:27,450
這是有道理的只是
接受正值。

66
00:03:27,450 --> 00:03:32,010
>> 因此，移動on--，我們已經獲得了
在來自用戶的美元值。

67
00:03:32,010 --> 00:03:35,380
但是，我們正在處理的硬幣，
這是完全美分。

68
00:03:35,380 --> 00:03:38,660
$ 1等價於100美分。

69
00:03:38,660 --> 00:03:43,670
因此，一個好東西做的是
轉換這些值轉換成美分。

70
00:03:43,670 --> 00:03:48,380
>> 現在從一個浮動轉換時
為整數，所以美元美分，

71
00:03:48,380 --> 00:03:52,230
我們要確保我們很小心
有關浮點不精確。

72
00:03:52,230 --> 00:03:55,260
因此，這意味著that--說
我的美元value--我的浮法

73
00:03:55,260 --> 00:04:00,260
value--是偶數2 $，仍有
可能是在那裡一些流浪的數字。

74
00:04:00,260 --> 00:04:04,590
因此，我們要確保，不僅
我們乘以100，以獲得美分，

75
00:04:04,590 --> 00:04:06,480
但我們也圓其關閉。

76
00:04:06,480 --> 00:04:09,210
>> 所以現在我們有量
改變欠給用戶。

77
00:04:09,210 --> 00:04:13,430
我們最初得到的以美元，
現在我們將它轉換為美分。

78
00:04:13,430 --> 00:04:17,029
所以，現在我們可以用的心臟進行
貪心算法，這始終是

79
00:04:17,029 --> 00:04:19,220
用最大的硬幣可能。

80
00:04:19,220 --> 00:04:21,930
雖然我們這樣做，
這是至關重要的，我們也

81
00:04:21,930 --> 00:04:25,360
跟踪有多少硬幣是
將要返回給用戶

82
00:04:25,360 --> 00:04:28,630
以及剩餘的
改變欠給用戶。

83
00:04:28,630 --> 00:04:31,130
>> 該程序會
這樣的事情。

84
00:04:31,130 --> 00:04:34,190
你得到後的金額
美元和轉換，要美分，

85
00:04:34,190 --> 00:04:35,790
那麼你會進入一個循環。

86
00:04:35,790 --> 00:04:38,400
雖然宿舍可
used--也就是說

87
00:04:38,400 --> 00:04:43,660
而變化的欠量
用戶是大於或等於$ 0.25，

88
00:04:43,660 --> 00:04:45,040
您將使用的四分之一。

89
00:04:45,040 --> 00:04:47,000
>> 現在做什麼用的四分之一意味著什麼？

90
00:04:47,000 --> 00:04:51,280
好吧，one--你會增加硬幣
算要返回給用戶。

91
00:04:51,280 --> 00:04:55,890
其次，你會減少電流
變化量欠回用戶

92
00:04:55,890 --> 00:04:57,520
由$ 0.25。

93
00:04:57,520 --> 00:05:00,680
>> 重複直到後
小區可以不再使用，

94
00:05:00,680 --> 00:05:04,630
進行到下一個最大的
coin--在這種情況下硬幣，$ 0.10

95
00:05:04,630 --> 00:05:07,750
所以你輸入循環，直到
你可以不再使用角錢。

96
00:05:07,750 --> 00:05:10,720
然後繼續下一個
最大的硬幣，鎳。

97
00:05:10,720 --> 00:05:14,810
後鎳不能再被使用，
使用便士的剩餘量。

98
00:05:14,810 --> 00:05:17,800
最後，打印
使用硬幣的數目。

99
00:05:17,800 --> 00:05:20,350
>> 另一種方式，你可以
接近貪婪的問題

100
00:05:20,350 --> 00:05:22,950
是使用模數的方法。

101
00:05:22,950 --> 00:05:25,690
模是一個操作符
返回剩餘

102
00:05:25,690 --> 00:05:27,680
的兩個數字之間的分工。

103
00:05:27,680 --> 00:05:30,270
說我有50個MOD 5。

104
00:05:30,270 --> 00:05:34,070
那麼，5是50倍，
所以，其餘為0。

105
00:05:34,070 --> 00:05:39,230
50 MOD 10--好，10也是一個因素
50，所以餘數也為0。

106
00:05:39,230 --> 00:05:43,660
50 MOD 50--好，任何數量的國防部本身
不會有任何剩餘部分。

107
00:05:43,660 --> 00:05:45,510
>> 什麼50國防部49？

108
00:05:45,510 --> 00:05:47,910
那麼，只有49進入50次。

109
00:05:47,910 --> 00:05:50,290
因此，其餘部分將是1。

110
00:05:50,290 --> 00:05:55,180
53 MOD 50將
給你3餘數。

111
00:05:55,180 --> 00:05:59,120
>> 那麼，如何才能用模
也許有些分裂

112
00:05:59,120 --> 00:06:01,690
實現我們的貪心算法？

113
00:06:01,690 --> 00:06:05,550
好了，我們還是要留真實的
貪心算法 - 即心臟的

114
00:06:05,550 --> 00:06:07,910
使用是最大的硬幣可能。

115
00:06:07,910 --> 00:06:14,570
>> 因此，讓我們捫心自問，我們可以使用任何
季度返回$ 0.32〜用戶。

116
00:06:14,570 --> 00:06:20,070
那麼，32國防部25給
我們的$為0.07剩餘部分。

117
00:06:20,070 --> 00:06:24,500
所以這告訴我們，我們絕對可以
用一個季度的$為0.07剩餘。

118
00:06:24,500 --> 00:06:26,180
>> 然後我們可以使用任何銀幣嗎？

119
00:06:26,180 --> 00:06:32,740
那麼，no--因為0.07 $ MOD
$ 0.10為我們提供了7餘數。

120
00:06:32,740 --> 00:06:34,960
10不進入7可言。

121
00:06:34,960 --> 00:06:36,390
>> 這樣，我們才能使用鎳？

122
00:06:36,390 --> 00:06:40,490
嗯$為0.07國防部5美分
給了我們兩個剩餘。

123
00:06:40,490 --> 00:06:42,930
最後，我們可以使用任何便士？

124
00:06:42,930 --> 00:06:45,930
2 MOD 1給了我們0，
這是什麼最終

125
00:06:45,930 --> 00:06:48,160
我們希望，因為那時，
也就是說，我們已經返回

126
00:06:48,160 --> 00:06:50,160
給用戶的所有變化的欠款。

127
00:06:50,160 --> 00:06:54,320
>> 所以，現在你有兩種可能的方式
實施貪心算法 - 

128
00:06:54,320 --> 00:06:59,230
一個用環和一個具有
模和除法的組合。

129
00:06:59,230 --> 00:07:03,010
所以最後，我們只需要
打印硬幣的最終數目。

130
00:07:03,010 --> 00:07:06,520
>> 如果我想告訴你，我有
3寵物和這個值硬編碼，

131
00:07:06,520 --> 00:07:09,240
然後，我可以只使用一個
簡單的打印測試聲明。

132
00:07:09,240 --> 00:07:12,320
但是，我們的價值實際上是
存儲在變量。

133
00:07:12,320 --> 00:07:15,260
那麼，你如何打印
存儲在變量的值？

134
00:07:15,260 --> 00:07:17,880
>> 為此，我們採取
優勢佔位符。

135
00:07:17,880 --> 00:07:21,540
說我已經宣布
初始化的整數n。

136
00:07:21,540 --> 00:07:25,170
再後來，如果我想打印
值，那麼我會寫的字符串。

137
00:07:25,170 --> 00:07:30,500
和而不是價值，我會用
對於integer--％我的佔位符。

138
00:07:30,500 --> 00:07:33,800
然後，後弦，我有一個
逗號，其次是可變

139
00:07:33,800 --> 00:07:34,950
我想打印。

140
00:07:34,950 --> 00:07:38,550
而後來，當它打印，
它會打印n的值。

141
00:07:38,550 --> 00:07:41,570
>> 我還可以使用一個佔位符
為浮點數，例如。

142
00:07:41,570 --> 00:07:44,000
如果我想告訴你如何
多少現金我在我的口袋裡，

143
00:07:44,000 --> 00:07:46,820
然後，我可以說我有％F美元。

144
00:07:46,820 --> 00:07:51,330
而後來當它打印，則n會
採取該地方持有人的地方。

145
00:07:51,330 --> 00:07:55,530
我還，例如，使用幾個
佔位符的幾個變量。

146
00:07:55,530 --> 00:07:57,590
所以只要我列出
他們為了，那我

147
00:07:57,590 --> 00:08:00,390
可以告訴你有多少
狗和貓我有。

148
00:08:00,390 --> 00:08:03,710
>> 現在我們知道如何提示
用戶對變化量，

149
00:08:03,710 --> 00:08:06,130
確保該輸入
是有效的，然後我們

150
00:08:06,130 --> 00:08:10,370
實施有兩種可能的方式
始終使用的貪心算法

151
00:08:10,370 --> 00:08:12,090
最大的硬幣可能。

152
00:08:12,090 --> 00:08:15,050
因為我們已經把軌道
我們有多少硬幣使用，

153
00:08:15,050 --> 00:08:19,210
那麼我們可以打印在最後的價值，
告訴他們有多少硬幣是用戶

154
00:08:19,210 --> 00:08:20,240
取回。

155
00:08:20,240 --> 00:08:24,240
>> 我的名字是Amayla，這是CS50。

156
00:08:24,240 --> 00:08:25,915

