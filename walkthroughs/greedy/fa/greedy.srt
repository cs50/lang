1
00:00:00,000 --> 00:00:00,710

2
00:00:00,710 --> 00:00:02,900
>> بیایید حریص.

3
00:00:02,900 --> 00:00:06,810
در حریص، کار ما این است به بازی
نقش یک صندوقدار حریص.

4
00:00:06,810 --> 00:00:09,750
کاربر خواهد به ما بگویید چگونه
تغییر زیادی ما به آنها مدیون،

5
00:00:09,750 --> 00:00:13,520
و پس از آن کار ما این است برای محاسبه
حداقل تعداد سکه

6
00:00:13,520 --> 00:00:17,240
که ما می توانیم با استفاده از به
که مقدار تغییر.

7
00:00:17,240 --> 00:00:19,560
>> بیایید با یک مثال شروع می شود.

8
00:00:19,560 --> 00:00:23,170
می گویند که کاربر نیاز 0.32 $ است.

9
00:00:23,170 --> 00:00:28,960
ما می توانیم این کار را انجام دادن
آنها 32 سکه، هر یک درصد است.

10
00:00:28,960 --> 00:00:35,180
یا من هم می تواند پنج coins-- استفاده شده توسط
به آنها سه از dimes، 0.10 $ هر،

11
00:00:35,180 --> 00:00:38,060
و دو سکه، 0.02 $ هر.

12
00:00:38,060 --> 00:00:42,580
اما می تواند با استفاده از ما حتی
سکه کمتر را که؟

13
00:00:42,580 --> 00:00:45,100
>> طیف تاکتیک در greedy--
به یک cashier-- حریص

14
00:00:45,100 --> 00:00:47,600
است که استفاده از بزرگترین سکه امکان پذیر است.

15
00:00:47,600 --> 00:00:50,670
بنابراین هر زمان که ما
چهارم ما آنها را استفاده کنید.

16
00:00:50,670 --> 00:00:54,100
و سپس یک بار آن را اجرا کنید،
ما از dimes، 0.10 $ هر استفاده کنید.

17
00:00:54,100 --> 00:00:58,840
سپس نیکل، هر 5 سنت، و
پس از آن به سکه، هر یک درصد است.

18
00:00:58,840 --> 00:01:01,792
با استفاده از بزرگترین سکه
ممکن هر زمان که ما می توانیم،

19
00:01:01,792 --> 00:01:07,350
ما اطمینان حاصل شود که ما با استفاده از کمترین تعداد
سکه ممکن است به تغییر.

20
00:01:07,350 --> 00:01:09,180
>> بنابراین اجازه دهید این طریق راه رفتن.

21
00:01:09,180 --> 00:01:11,660
کاربر نیاز 0.32 $.

22
00:01:11,660 --> 00:01:14,200
بنابراین ما از خودمان بپرسیم،
می تواند ما را به یک چهارم استفاده کنید؟

23
00:01:14,200 --> 00:01:15,560
خوب، بله ما می توانیم.

24
00:01:15,560 --> 00:01:19,720
بنابراین در حال حاضر ما تنها آنها را می دانیم
$ 0.07، و ما استفاده یک سکه.

25
00:01:19,720 --> 00:01:20,970
>> آیا ما می توانیم یک چهارم استفاده کنید؟

26
00:01:20,970 --> 00:01:21,890
خب نه.

27
00:01:21,890 --> 00:01:27,570
0.07 $ کمتر از 0.25 $ است، بنابراین ما ادامه
به بعد بزرگترین سکه های موجود.

28
00:01:27,570 --> 00:01:30,690
از dimes هستند 0.10 $، و
دوباره، ما می توانیم از dimes استفاده نمی کند.

29
00:01:30,690 --> 00:01:35,480
از آنجا که از dimes به ارزش $ 0.10، هستند که
بیش از مقدار تغییر بدهکار است.

30
00:01:35,480 --> 00:01:36,790
>> ما به نیکل است.

31
00:01:36,790 --> 00:01:40,890
و بله واقعا 0.05 $ کمتر از است
0.10-- $ بنابراین ما می توانیم یک نیکل استفاده کنید.

32
00:01:40,890 --> 00:01:46,104
بنابراین در حال حاضر ما تنها مدیون کاربران 0.02 $،
و ما تا کنون با استفاده از دو سکه ها.

33
00:01:46,104 --> 00:01:47,270
ما می توانیم نیکل دیگر استفاده نمی کند.

34
00:01:47,270 --> 00:01:51,140
پس ما به آخرین سکه ادامه در
اختیار ما، که سکه می باشد.

35
00:01:51,140 --> 00:01:52,270
>> و می تواند ما پنی استفاده کنید؟

36
00:01:52,270 --> 00:01:59,060
خب، yes-- و ما تا پایان با استفاده از دو
سکه در مجموع از چهار سکه.

37
00:01:59,060 --> 00:02:01,430
>> هنگامی که شما به پایان رسید،
برنامه شبیه به این.

38
00:02:01,430 --> 00:02:03,710
هنگامی که کاربر اجرا می شود
برنامه حریص، آنها را

39
00:02:03,710 --> 00:02:07,270
باعث می شود به مقدار
تغییر در دلار که آنها بدهکار.

40
00:02:07,270 --> 00:02:11,140
و سپس خروجی برنامه خود را
حداقل مقدار از سکه

41
00:02:11,140 --> 00:02:14,740
که صندوقدار حریص استفاده کنید
را که مقدار تغییر.

42
00:02:14,740 --> 00:02:18,160
>> بنابراین در حال حاضر اجازه دهید این شکستن
پایین به کارهای فرعی است.

43
00:02:18,160 --> 00:02:21,410
در ابتدا ما در حال رفتن به موقع ما را
کاربران برای یک مقدار را تغییر دهید.

44
00:02:21,410 --> 00:02:25,630
و، با هر ورودی کاربر، ما می خواهیم
مطمئن شوید که ما اعتبار است که ورودی

45
00:02:25,630 --> 00:02:29,360
و اطمینان حاصل شود که ما می توانیم که با استفاده از
ورودی برای بقیه برنامه های ما.

46
00:02:29,360 --> 00:02:32,480
سپس ما قصد داریم برای همیشه
استفاده از بزرگترین نقطه ممکن

47
00:02:32,480 --> 00:02:35,240
و پیگیری سکه استفاده می شود.

48
00:02:35,240 --> 00:02:39,080
و در نهایت، چاپ نهایی
تعداد سکه های که ما استفاده می شود.

49
00:02:39,080 --> 00:02:40,970
>> بنابراین اجازه دهید در مورد باعث صحبت کنید.

50
00:02:40,970 --> 00:02:43,550
مقدار باید سنت را،
و این در دلار است.

51
00:02:43,550 --> 00:02:48,440
و به این ترتیب برای دلار، ما در حال رفتن
به استفاده از نوع متغیر شناور.

52
00:02:48,440 --> 00:02:52,390
حالا هر زمان که شما بخواهید کاربر برای ورودی،
شما می خواهید مطمئن شوید که آن را معتبر.

53
00:02:52,390 --> 00:02:56,640
و بنابراین در اینجا ما دوست داریم به استفاده
از انجام دهند در حالی ساختار حلقه.

54
00:02:56,640 --> 00:03:00,320
>> یک حلقه انجام دهند در حالی اجرا خواهد شد
بدنه حلقه حداقل یک بار.

55
00:03:00,320 --> 00:03:01,650
بنابراین این می آید در دستی.

56
00:03:01,650 --> 00:03:05,510
ما می دانیم که ما نیاز به اعلان
کاربران حداقل یک بار برای یک شناور.

57
00:03:05,510 --> 00:03:07,100
حال اگر که شناور معتبر است.

58
00:03:07,100 --> 00:03:07,710
عالیه.

59
00:03:07,710 --> 00:03:08,460
ما در حرکت.

60
00:03:08,460 --> 00:03:11,910
اما اگر نه، حلقه را تضمین خواهد کرد
که ما یک شناور مناسب

61
00:03:11,910 --> 00:03:16,810
با تکرار مداوم تا زمانی که
کاربر به ما می دهد یک مقدار معتبر.

62
00:03:16,810 --> 00:03:18,760
>> در حال حاضر برای انجام دهند در حالی
شرایط حلقه، ما نیاز

63
00:03:18,760 --> 00:03:22,000
در نظر گرفتن آنچه در آن به معنی
به یک شناور نامعتبر است.

64
00:03:22,000 --> 00:03:24,220
بنابراین برای زمینه
این مشکل، احتمالا

65
00:03:24,220 --> 00:03:27,450
آن را حس می فقط به
ارزش های مثبت را بپذیرید.

66
00:03:27,450 --> 00:03:32,010
>> بنابراین در حال حرکت کنین ما به دست آمده ام
ارزش به دلار از کاربر.

67
00:03:32,010 --> 00:03:35,380
اما ما در حال برخورد با سکه ها،
که به طور کامل در سنت.

68
00:03:35,380 --> 00:03:38,660
1 $ معادل 100 سنت است.

69
00:03:38,660 --> 00:03:43,670
بنابراین یک چیز خوب به انجام آن به
تبدیل آن ارزش به سنت است.

70
00:03:43,670 --> 00:03:48,380
>> در حال حاضر در هنگام تبدیل از یک شناور
به یک عدد صحیح، به طوری که دلار به سنت،

71
00:03:48,380 --> 00:03:52,230
ما می خواهیم به مطمئن شوید که ما مراقب باشید
در مورد عدم دقت ممیز شناور.

72
00:03:52,230 --> 00:03:55,260
بنابراین این بدان معناست که-- می گویند
دلار من value-- شناور من

73
00:03:55,260 --> 00:04:00,260
value-- حتی 2 $ وجود دارد هنوز هم،
ممکن است برخی از اعداد ولگرد در وجود دارد.

74
00:04:00,260 --> 00:04:04,590
بنابراین ما می خواهیم مطمئن شوید که نه تنها
ما با 100 ضرب کنید برای دریافت سنت،

75
00:04:04,590 --> 00:04:06,480
اما ما نیز آن را دور کردن.

76
00:04:06,480 --> 00:04:09,210
>> بنابراین در حال حاضر ما باید مقدار
تغییر به کاربر بدهکار است.

77
00:04:09,210 --> 00:04:13,430
ما اصل آن را در دلار به دست آمده،
و در حال حاضر ما آن را به سنت تبدیل شده است.

78
00:04:13,430 --> 00:04:17,029
بنابراین در حال حاضر ما می توانیم با قلب ادامه
الگوریتم حریص، که همیشه

79
00:04:17,029 --> 00:04:19,220
با استفاده از بزرگترین سکه امکان پذیر است.

80
00:04:19,220 --> 00:04:21,930
در حالی که ما در حال انجام این،
آن را ضروری است که ما نیز

81
00:04:21,930 --> 00:04:25,360
پیگیری چگونه بسیاری از سکه هستند
رفتن به بازگشت به کاربر می شود

82
00:04:25,360 --> 00:04:28,630
و همچنین به عنوان باقی مانده
تغییر بدهکار به کاربر.

83
00:04:28,630 --> 00:04:31,130
>> این برنامه را نگاه خواهد کرد
چیزی شبیه به این.

84
00:04:31,130 --> 00:04:34,190
شما بعد از دریافت مقدار
دلار و تبدیل که به سنت،

85
00:04:34,190 --> 00:04:35,790
پس از آن شما یک حلقه را وارد کنید.

86
00:04:35,790 --> 00:04:38,400
در حالی که می تواند چهارم
used-- است که می گویند

87
00:04:38,400 --> 00:04:43,660
در حالی که مقدار تغییر بدهکار به
کاربران بزرگتر یا 0.25 $ برابر است،

88
00:04:43,660 --> 00:04:45,040
شما یک چهارم استفاده کنید.

89
00:04:45,040 --> 00:04:47,000
>> در حال حاضر چه با استفاده از یک چهارم به همراه دارد؟

90
00:04:47,000 --> 00:04:51,280
خب، one-- شما سکه افزایش
تعداد به به کاربر برگردانده می شود.

91
00:04:51,280 --> 00:04:55,890
و دوم شما در حال حاضر کاهش
مقدار تغییر بدهکار به کاربر

92
00:04:55,890 --> 00:04:57,520
0.25 $.

93
00:04:57,520 --> 00:05:00,680
>> پس از تکرار که تا
چهارم دیگر نمی تواند مورد استفاده قرار گیرد،

94
00:05:00,680 --> 00:05:04,630
ادامه به بعد بزرگترین
coin-- در این مورد از dimes، 0.10 $.

95
00:05:04,630 --> 00:05:07,750
بنابراین شما که حلقه را وارد کنید تا
شما دیگر می توانید استفاده کنید از dimes.

96
00:05:07,750 --> 00:05:10,720
پس از آن به بعد بروید
بزرگترین سکه، نیکل.

97
00:05:10,720 --> 00:05:14,810
پس از نیکل دیگر نمی تواند مورد استفاده قرار گیرد،
استفاده از مقدار باقی مانده در سکه.

98
00:05:14,810 --> 00:05:17,800
و در نهایت، چاپ
تعداد سکه استفاده می شود.

99
00:05:17,800 --> 00:05:20,350
>> راه دیگر که شما می توانید
رویکرد مشکل حریص

100
00:05:20,350 --> 00:05:22,950
است که استفاده از روش پیمانه است.

101
00:05:22,950 --> 00:05:25,690
پیمانه یک عملگر است
که باقی مانده باز می گردد

102
00:05:25,690 --> 00:05:27,680
از تقسیم بین دو عدد.

103
00:05:27,680 --> 00:05:30,270
بگو من تا به حال 50 وزارت دفاع 5.

104
00:05:30,270 --> 00:05:34,070
خب، 5 یک عامل از 50 است،
بنابراین باقی مانده خواهد شد 0.

105
00:05:34,070 --> 00:05:39,230
50 وزارت دفاع 10-- خوب، 10 نیز یک عامل
50، به طوری که باقی مانده است 0.

106
00:05:39,230 --> 00:05:43,660
50 وزارت دفاع 50-- خوب، هر تعداد خود وزارت دفاع
رفتن به هر گونه باقی مانده است.

107
00:05:43,660 --> 00:05:45,510
>> آنچه در مورد 50 وزارت دفاع 49؟

108
00:05:45,510 --> 00:05:47,910
خوب، 49 تنها به 50 می رود یک بار.

109
00:05:47,910 --> 00:05:50,290
بنابراین باقی مانده است برای رفتن به 1.

110
00:05:50,290 --> 00:05:55,180
53 وزارت دفاع 50 است که به
شما یک باقی مانده از 3 است.

111
00:05:55,180 --> 00:05:59,120
>> پس چگونه می توان با استفاده از پیمانه
و شاید برخی از بخش

112
00:05:59,120 --> 00:06:01,690
برای پیاده سازی الگوریتم حریصانه ما؟

113
00:06:01,690 --> 00:06:05,550
خب، ما هنوز هم می خواهید به واقعی به ماندن
قلب حریص الگوریتم که

114
00:06:05,550 --> 00:06:07,910
است با استفاده از بزرگترین سکه امکان پذیر است.

115
00:06:07,910 --> 00:06:14,570
>> بنابراین اجازه دهید از خود بپرسیم اگر ما می توانیم هر گونه استفاده
چهارم به بازگشت 0.32 $ به کاربر.

116
00:06:14,570 --> 00:06:20,070
خوب، 32 وزارت دفاع 25 می دهد
ما باقی مانده از 0.07 $.

117
00:06:20,070 --> 00:06:24,500
به طوری که ما می گوید که ما قطعا می تواند
استفاده از یک چهارم با 0.07 $ باقی مانده است.

118
00:06:24,500 --> 00:06:26,180
>> آیا ما می توانیم پس از آن استفاده از هر از dimes؟

119
00:06:26,180 --> 00:06:32,740
خب، no-- به دلیل 0.07 $ وزارت دفاع
0.10 $ به ما می دهد باقی مانده از 7.

120
00:06:32,740 --> 00:06:34,960
10 را به 7 رفتن نیست.

121
00:06:34,960 --> 00:06:36,390
>> سپس می توانید نیکل استفاده می کنیم؟

122
00:06:36,390 --> 00:06:40,490
خب 0.07 $ وزارت دفاع 5 سنت
به ما می دهد دو باقی مانده است.

123
00:06:40,490 --> 00:06:42,930
و در آخر، می تواند ما را هر سکه استفاده کنید؟

124
00:06:42,930 --> 00:06:45,930
2 مد 1 به ما می دهد 0،
که در نهایت چیزی است که

125
00:06:45,930 --> 00:06:48,160
ما چون پس از آن که می خواهید
معنی است که ما بازگشته ام

126
00:06:48,160 --> 00:06:50,160
به کاربر همه از تغییر بدهکار است.

127
00:06:50,160 --> 00:06:54,320
>> بنابراین در حال حاضر شما دو راه ممکن است از
اجرای الگوریتم حریص

128
00:06:54,320 --> 00:06:59,230
با حلقه و با یک
ترکیبی از پیمانه و تقسیم.

129
00:06:59,230 --> 00:07:03,010
پس در نهایت، ما فقط نیاز به
چاپ تعداد نهایی از سکه ها.

130
00:07:03,010 --> 00:07:06,520
>> اگر من می خواستم به شما که من تا به حال به
3 حیوانات خانگی و این مقدار شده سخت بود،

131
00:07:06,520 --> 00:07:09,240
پس از آن من فقط می تواند با استفاده از یک
ساده بیانیه تست چاپ کنید.

132
00:07:09,240 --> 00:07:12,320
اما ارزش ما است که در واقع
ذخیره شده در یک متغیر است.

133
00:07:12,320 --> 00:07:15,260
پس چگونه شما چاپ
ارزش ها در متغیرهای ذخیره شده؟

134
00:07:15,260 --> 00:07:17,880
>> برای این که ما را
استفاده از متغیرهایی.

135
00:07:17,880 --> 00:07:21,540
می گویند من در حال حاضر اعلام کرده بود
یک n عدد صحیح اولیه.

136
00:07:21,540 --> 00:07:25,170
سپس بعد از اگر من می خواستم برای چاپ که
ارزش، پس من رشته ارسال.

137
00:07:25,170 --> 00:07:30,500
و به جای آن ارزش من استفاده
یک حفره یا سوراخ برای من که٪ integer--.

138
00:07:30,500 --> 00:07:33,800
پس از آن پس از رشته، من
کاما از هم، به دنبال آن متغیر

139
00:07:33,800 --> 00:07:34,950
که من می خواهم برای چاپ.

140
00:07:34,950 --> 00:07:38,550
و بعد از آن، هنگامی که آن را چاپ،
آن را به مقدار n را چاپ کنید.

141
00:07:38,550 --> 00:07:41,570
>> من هم می تواند یک حفره یا سوراخ استفاده
برای شناور، به عنوان مثال.

142
00:07:41,570 --> 00:07:44,000
اگر من می خواستم به شما بگویم که چگونه
پول نقد بسیار من در جیب من،

143
00:07:44,000 --> 00:07:46,820
پس از آن من می توانم بگویم که دلار٪ F.

144
00:07:46,820 --> 00:07:51,330
و بعدا در زمانی که آن را چاپ، و سپس N خواهد شد
به جای که دارنده محل.

145
00:07:51,330 --> 00:07:55,530
من هم می تواند، به عنوان مثال، استفاده از چند
متغیرهایی برای چند متغیر.

146
00:07:55,530 --> 00:07:57,590
بنابراین تا زمانی که من لیست
آنها را به ترتیب، پس من

147
00:07:57,590 --> 00:08:00,390
می تواند به شما بگوید که چگونه بسیاری
سگ و گربه من.

148
00:08:00,390 --> 00:08:03,710
>> در حال حاضر ما می دانیم که چگونه به اعلان
کاربران برای یک مقدار تغییر،

149
00:08:03,710 --> 00:08:06,130
اطمینان حاصل شود که که ورودی
معتبر است، و سپس ما

150
00:08:06,130 --> 00:08:10,370
دو راه ممکن است از اجرای
الگوریتم حریص همیشه با استفاده از

151
00:08:10,370 --> 00:08:12,090
بزرگترین سکه امکان پذیر است.

152
00:08:12,090 --> 00:08:15,050
از آنجا که ما پیگیری نگه داشته ام
چگونه بسیاری از سکه ما با استفاده از،

153
00:08:15,050 --> 00:08:19,210
پس از آن ما می توانیم چاپ که ارزش در پایان،
گفتن کاربر چگونه بسیاری از سکه آنها

154
00:08:19,210 --> 00:08:20,240
برگشت.

155
00:08:20,240 --> 00:08:24,240
>> نام من Amayla است، و این CS50 است.

156
00:08:24,240 --> 00:08:25,915

