بیایید حریص. در حریص، کار ما این است به بازی نقش یک صندوقدار حریص. کاربر خواهد به ما بگویید چگونه تغییر زیادی ما به آنها مدیون، و پس از آن کار ما این است برای محاسبه حداقل تعداد سکه که ما می توانیم با استفاده از به که مقدار تغییر. 

بیایید با یک مثال شروع می شود. می گویند که کاربر نیاز 0.32 $ است. ما می توانیم این کار را انجام دادن آنها 32 سکه، هر یک درصد است. یا من هم می تواند پنج coins-- استفاده شده توسط به آنها سه از dimes، 0.10 $ هر، و دو سکه، 0.02 $ هر. اما می تواند با استفاده از ما حتی سکه کمتر را که؟ 

طیف تاکتیک در greedy-- به یک cashier-- حریص است که استفاده از بزرگترین سکه امکان پذیر است. بنابراین هر زمان که ما چهارم ما آنها را استفاده کنید. و سپس یک بار آن را اجرا کنید، ما از dimes، 0.10 $ هر استفاده کنید. سپس نیکل، هر 5 سنت، و پس از آن به سکه، هر یک درصد است. با استفاده از بزرگترین سکه ممکن هر زمان که ما می توانیم، ما اطمینان حاصل شود که ما با استفاده از کمترین تعداد سکه ممکن است به تغییر. 

بنابراین اجازه دهید این طریق راه رفتن. کاربر نیاز 0.32 $. بنابراین ما از خودمان بپرسیم، می تواند ما را به یک چهارم استفاده کنید؟ خوب، بله ما می توانیم. بنابراین در حال حاضر ما تنها آنها را می دانیم $ 0.07، و ما استفاده یک سکه. 

آیا ما می توانیم یک چهارم استفاده کنید؟ خب نه. 0.07 $ کمتر از 0.25 $ است، بنابراین ما ادامه به بعد بزرگترین سکه های موجود. از dimes هستند 0.10 $، و دوباره، ما می توانیم از dimes استفاده نمی کند. از آنجا که از dimes به ارزش $ 0.10، هستند که بیش از مقدار تغییر بدهکار است. 

ما به نیکل است. و بله واقعا 0.05 $ کمتر از است 0.10-- $ بنابراین ما می توانیم یک نیکل استفاده کنید. بنابراین در حال حاضر ما تنها مدیون کاربران 0.02 $، و ما تا کنون با استفاده از دو سکه ها. ما می توانیم نیکل دیگر استفاده نمی کند. پس ما به آخرین سکه ادامه در اختیار ما، که سکه می باشد. 

و می تواند ما پنی استفاده کنید؟ خب، yes-- و ما تا پایان با استفاده از دو سکه در مجموع از چهار سکه. 

هنگامی که شما به پایان رسید، برنامه شبیه به این. هنگامی که کاربر اجرا می شود برنامه حریص، آنها را باعث می شود به مقدار تغییر در دلار که آنها بدهکار. و سپس خروجی برنامه خود را حداقل مقدار از سکه که صندوقدار حریص استفاده کنید را که مقدار تغییر. 

بنابراین در حال حاضر اجازه دهید این شکستن پایین به کارهای فرعی است. در ابتدا ما در حال رفتن به موقع ما را کاربران برای یک مقدار را تغییر دهید. و، با هر ورودی کاربر، ما می خواهیم مطمئن شوید که ما اعتبار است که ورودی و اطمینان حاصل شود که ما می توانیم که با استفاده از ورودی برای بقیه برنامه های ما. سپس ما قصد داریم برای همیشه استفاده از بزرگترین نقطه ممکن و پیگیری سکه استفاده می شود. و در نهایت، چاپ نهایی تعداد سکه های که ما استفاده می شود. 

بنابراین اجازه دهید در مورد باعث صحبت کنید. مقدار باید سنت را، و این در دلار است. و به این ترتیب برای دلار، ما در حال رفتن به استفاده از نوع متغیر شناور. حالا هر زمان که شما بخواهید کاربر برای ورودی، شما می خواهید مطمئن شوید که آن را معتبر. و بنابراین در اینجا ما دوست داریم به استفاده از انجام دهند در حالی ساختار حلقه. 

یک حلقه انجام دهند در حالی اجرا خواهد شد بدنه حلقه حداقل یک بار. بنابراین این می آید در دستی. ما می دانیم که ما نیاز به اعلان کاربران حداقل یک بار برای یک شناور. حال اگر که شناور معتبر است. عالیه. ما در حرکت. اما اگر نه، حلقه را تضمین خواهد کرد که ما یک شناور مناسب با تکرار مداوم تا زمانی که کاربر به ما می دهد یک مقدار معتبر. 

در حال حاضر برای انجام دهند در حالی شرایط حلقه، ما نیاز در نظر گرفتن آنچه در آن به معنی به یک شناور نامعتبر است. بنابراین برای زمینه این مشکل، احتمالا آن را حس می فقط به ارزش های مثبت را بپذیرید. 

بنابراین در حال حرکت کنین ما به دست آمده ام ارزش به دلار از کاربر. اما ما در حال برخورد با سکه ها، که به طور کامل در سنت. 1 $ معادل 100 سنت است. بنابراین یک چیز خوب به انجام آن به تبدیل آن ارزش به سنت است. 

در حال حاضر در هنگام تبدیل از یک شناور به یک عدد صحیح، به طوری که دلار به سنت، ما می خواهیم به مطمئن شوید که ما مراقب باشید در مورد عدم دقت ممیز شناور. بنابراین این بدان معناست که-- می گویند دلار من value-- شناور من value-- حتی 2 $ وجود دارد هنوز هم، ممکن است برخی از اعداد ولگرد در وجود دارد. بنابراین ما می خواهیم مطمئن شوید که نه تنها ما با 100 ضرب کنید برای دریافت سنت، اما ما نیز آن را دور کردن. 

بنابراین در حال حاضر ما باید مقدار تغییر به کاربر بدهکار است. ما اصل آن را در دلار به دست آمده، و در حال حاضر ما آن را به سنت تبدیل شده است. بنابراین در حال حاضر ما می توانیم با قلب ادامه الگوریتم حریص، که همیشه با استفاده از بزرگترین سکه امکان پذیر است. در حالی که ما در حال انجام این، آن را ضروری است که ما نیز پیگیری چگونه بسیاری از سکه هستند رفتن به بازگشت به کاربر می شود و همچنین به عنوان باقی مانده تغییر بدهکار به کاربر. 

این برنامه را نگاه خواهد کرد چیزی شبیه به این. شما بعد از دریافت مقدار دلار و تبدیل که به سنت، پس از آن شما یک حلقه را وارد کنید. در حالی که می تواند چهارم used-- است که می گویند در حالی که مقدار تغییر بدهکار به کاربران بزرگتر یا 0.25 $ برابر است، شما یک چهارم استفاده کنید. 

در حال حاضر چه با استفاده از یک چهارم به همراه دارد؟ خب، one-- شما سکه افزایش تعداد به به کاربر برگردانده می شود. و دوم شما در حال حاضر کاهش مقدار تغییر بدهکار به کاربر 0.25 $. 

پس از تکرار که تا چهارم دیگر نمی تواند مورد استفاده قرار گیرد، ادامه به بعد بزرگترین coin-- در این مورد از dimes، 0.10 $. بنابراین شما که حلقه را وارد کنید تا شما دیگر می توانید استفاده کنید از dimes. پس از آن به بعد بروید بزرگترین سکه، نیکل. پس از نیکل دیگر نمی تواند مورد استفاده قرار گیرد، استفاده از مقدار باقی مانده در سکه. و در نهایت، چاپ تعداد سکه استفاده می شود. 

راه دیگر که شما می توانید رویکرد مشکل حریص است که استفاده از روش پیمانه است. پیمانه یک عملگر است که باقی مانده باز می گردد از تقسیم بین دو عدد. بگو من تا به حال 50 وزارت دفاع 5. خب، 5 یک عامل از 50 است، بنابراین باقی مانده خواهد شد 0. 50 وزارت دفاع 10-- خوب، 10 نیز یک عامل 50، به طوری که باقی مانده است 0. 50 وزارت دفاع 50-- خوب، هر تعداد خود وزارت دفاع رفتن به هر گونه باقی مانده است. 

آنچه در مورد 50 وزارت دفاع 49؟ خوب، 49 تنها به 50 می رود یک بار. بنابراین باقی مانده است برای رفتن به 1. 53 وزارت دفاع 50 است که به شما یک باقی مانده از 3 است. 

پس چگونه می توان با استفاده از پیمانه و شاید برخی از بخش برای پیاده سازی الگوریتم حریصانه ما؟ خب، ما هنوز هم می خواهید به واقعی به ماندن قلب حریص الگوریتم که است با استفاده از بزرگترین سکه امکان پذیر است. 

بنابراین اجازه دهید از خود بپرسیم اگر ما می توانیم هر گونه استفاده چهارم به بازگشت 0.32 $ به کاربر. خوب، 32 وزارت دفاع 25 می دهد ما باقی مانده از 0.07 $. به طوری که ما می گوید که ما قطعا می تواند استفاده از یک چهارم با 0.07 $ باقی مانده است. 

آیا ما می توانیم پس از آن استفاده از هر از dimes؟ خب، no-- به دلیل 0.07 $ وزارت دفاع 0.10 $ به ما می دهد باقی مانده از 7. 10 را به 7 رفتن نیست. 

سپس می توانید نیکل استفاده می کنیم؟ خب 0.07 $ وزارت دفاع 5 سنت به ما می دهد دو باقی مانده است. و در آخر، می تواند ما را هر سکه استفاده کنید؟ 2 مد 1 به ما می دهد 0، که در نهایت چیزی است که ما چون پس از آن که می خواهید معنی است که ما بازگشته ام به کاربر همه از تغییر بدهکار است. 

بنابراین در حال حاضر شما دو راه ممکن است از اجرای الگوریتم حریص با حلقه و با یک ترکیبی از پیمانه و تقسیم. پس در نهایت، ما فقط نیاز به چاپ تعداد نهایی از سکه ها. 

اگر من می خواستم به شما که من تا به حال به 3 حیوانات خانگی و این مقدار شده سخت بود، پس از آن من فقط می تواند با استفاده از یک ساده بیانیه تست چاپ کنید. اما ارزش ما است که در واقع ذخیره شده در یک متغیر است. پس چگونه شما چاپ ارزش ها در متغیرهای ذخیره شده؟ 

برای این که ما را استفاده از متغیرهایی. می گویند من در حال حاضر اعلام کرده بود یک n عدد صحیح اولیه. سپس بعد از اگر من می خواستم برای چاپ که ارزش، پس من رشته ارسال. و به جای آن ارزش من استفاده یک حفره یا سوراخ برای من که٪ integer--. پس از آن پس از رشته، من کاما از هم، به دنبال آن متغیر که من می خواهم برای چاپ. و بعد از آن، هنگامی که آن را چاپ، آن را به مقدار n را چاپ کنید. 

من هم می تواند یک حفره یا سوراخ استفاده برای شناور، به عنوان مثال. اگر من می خواستم به شما بگویم که چگونه پول نقد بسیار من در جیب من، پس از آن من می توانم بگویم که دلار٪ F. و بعدا در زمانی که آن را چاپ، و سپس N خواهد شد به جای که دارنده محل. من هم می تواند، به عنوان مثال، استفاده از چند متغیرهایی برای چند متغیر. بنابراین تا زمانی که من لیست آنها را به ترتیب، پس من می تواند به شما بگوید که چگونه بسیاری سگ و گربه من. 

در حال حاضر ما می دانیم که چگونه به اعلان کاربران برای یک مقدار تغییر، اطمینان حاصل شود که که ورودی معتبر است، و سپس ما دو راه ممکن است از اجرای الگوریتم حریص همیشه با استفاده از بزرگترین سکه امکان پذیر است. از آنجا که ما پیگیری نگه داشته ام چگونه بسیاری از سکه ما با استفاده از، پس از آن ما می توانیم چاپ که ارزش در پایان، گفتن کاربر چگونه بسیاری از سکه آنها برگشت. 

نام من Amayla است، و این CS50 است. 