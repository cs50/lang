Zamyla Chan: Ng hakbang up Hayaan ang aming laro sa Vigenere cipher. Ang Vigenere cipher ay halos kapareho sa Caesar, maliban sa Caesar ipinasa namin sa isang solong integer bilang aming key. Sa Vigenere kami ay pagpunta upang pumasa sa isang keyword. Kaya, kung nais ko upang ilipat ang ciphertext na ito ay CS 50 sa pamamagitan ng ohai, pagkatapos na nangangahulugan na ang bawat titik sa ohai ay pagpunta upang maglingkod bilang ang susi, at pupuntahan ko upang umikot sa ibabaw na keyword para sa aking shift paggawa ng ciphertext isang pulutong mas mahirap i-decode. 

Ano ang ibig sabihin ng pag- shift sa pamamagitan ng keyword? Well, ang keyword ay isang string kung saan ang bawat titik ay tumutugon sa ilang shift integer. Kaya, ang o ay tumutugon sa isang susi na 14, h sa isang key ng 7, isang may isang key ng 0, sa gayon ay hindi baguhin ang anumang bagay, at pagkatapos ay i ay may isang key ng 8. 

Sinasabi ko tumakbo Vigenere A sa plain text na ito ay CS50 mabuti, na lang bigyan sa akin ng isang hindi nabago string. Pansinin na ito ay katumbas ng tumatakbo Caesar na may isang key ng zero. Sa katunayan, tumatakbo Vigenere sa anumang solong character ay katumbas ng tumatakbo Caesar sa na parehong integer. 

O sige, kaya, dahil ang mga ito ay kaya katulad gusto ko talagang pinapayo na kung ikaw nais maaari mo lamang kopyahin ang iyong mga Caesar code sa iyong Vigenere code. Mga bagay ay magbabago, ngunit hindi bababa sa ikaw ay may ilang backbone na maaari mong magtrabaho sa. Dahil ang TODOs ay pareho ang gusto namin upang makuha ang key, makuha ang plain text, ensayper na plain text, at pagkatapos ay i-print na out. 

Katulad ng Caesar ang susi ay pagpunta sa maipasa sa bilang ang pangalawang command line argument na nakapaloob sa argv index 1, ngunit ito ay naiiba oras na ito dahil ito ay dapat alphabetical. Kaya, kailangan namin upang umulit sa paglipas ng bawat solong character sa key na na ang gumagamit ay ipinasa sa, at masiguro na ang bawat karakter ay pang-abakada upang magpatuloy. 

Sa sandaling tapos na kami na, pagkatapos namin maaaring makuha ang string mula sa gumagamit, tulad ng ginawa namin bago. At ngayon, dumating kami sa gitna ng problema para sa Vigenere, na kung saan ay tulad ng Caesar, kung paano malaman ang mga enciphering pattern at equation, at ensayper ang buong plaintext. 

Kaya, mapapansin mo na ang equation para sa Vigenere shift ay halos kapareho sa Caesar isa. Ang pagkakaiba lamang ay na sa halip ng isang solong variable k bago, ngayon k ay may subscript, na nagpapahiwatig ng JTH titik ng key. 

Ni maglakad sa pamamagitan ng isang halimbawa. Say gusto mong pumasa sa isang lihim na mensahe papunta sa iyong crush, gusto ko sa iyo. Well, para sa iyong mga susi mo pumili ng isang bagay na ang iyong alam crush alam na gusto mo, pandas. O sige, kaya paano shift namin ito? 

Well, mayroon kaming ang aming plaintext index. Iyan ay sa ang unang titik at sa gayon ay ang index para sa aming mga key kung saan ay sa p, ang unang sulat sa aming panda salita. Kaya, paglilipat ko sa pamamagitan ng p ay nagbibigay sa amin x, pagkatapos namin isulong ang plaintext index. Ito ay makakakuha ng sa amin sa isang space. Ngayon, ang puwang na karakter ay non-abakada, kaya na nangangahulugan na, na lamang transfers karapatan sa paglipas ng sa ciphertext, inilalagay namin ang isang puwang doon, at ginagawa namin hindi isulong ang index para sa aming mga key. Kaya, kami ay pa rin sa p sa puntong ito. 

advance namin sa susunod na index sa aming plaintext. At ngayon, dahil na ay isang sulat, ang lowercase l, shift namin na sa pamamagitan ng susunod na index sa aming key. Alin ang isang, na kung saan ay isang zero shift upang ang lamang nagiging isang l sa aming ciphertext. Pagkatapos, mag-advance namin pareho ang plaintext, at ang susi index dahil ito ay pang-abakada. Kaya nga kami ay patuloy na hanggang sa makuha namin sa e sa gusto. 

O sige, kaya mapapansin mo na ito sa ituro na, sa mga tuntunin ng aming mga key index, naabot namin na ang pinakadulo ng ang panda salita, kaya kung ano ang ang mangyayari kapag makuha namin sa susunod na alphabetic titik sa plaintext? Well, ang lahat ng mangyayari namin wrapper sa paligid sa simula, sa unang index ng aming key. Kaya, pagkatapos namin shift na y sa pamamagitan ng p upang bigyan kami ng n. At pagkatapos, patuloy naming pagtatapos encoding aming plaintext upang makakuha x lvne noh. 

Mula sa halimbawa na ito, ako nagpakita na lamang naming isulong sa susunod na titik sa keyword kung ang character sa plain text ay isang sulat kaya ang isalpha function na ay darating sa madaling-gamiting dito. At, tulad ng sa Caesar, nais naming mapanatili ang kaso, isupper at islower. Kaya, idagdag ang maliit na piraso in sa iyong pseudocode. 

Kaya paano namin isinasali ang susi shifts? Well, kung ang pagpapabalik sa iyo ang aming discussion sa alpabetikong indeks sa Caesar problema, ito ay halos katulad na. 

Saan A ay tumutugon sa isang ascii halaga ng 65 ngunit isang shift ng 0, at pagkatapos ay ang huling sulat sa alpabeto, Z, ay kumakatawan sa isang shift ng 25. Mapapansin mo na ang shift ay kapareho kung o hindi ang sulat ay malaking titik o maliit na titik. 

OK, kaya ngayon na kayo malaman kung paano upang malaman kung ang numerical shift na ay kumakatawan sa isang solong character sabihin bumalik sa aming equation. Dahil mayroon kaming dalawang magkaibang subscripts dito, i at j, iyan ay isang pahiwatig na gusto naming subaybayan ng parehong aming posisyon sa plaintext pati na rin ang aming posisyon sa keyword, kaya ang mga ito ay dalawang magkahiwalay na mga variable na gusto naming panatilihin ang isang hold ng. 

Ngayon, ang posisyon sa aming plaintext ay pagpunta sa taasan ang bawat oras, kaya na ay pagpunta sa maging isang bit mas tuwid forward na taliwas sa mga posisyon ng keyword, kung saan alam namin ay may sa wrapper sa paligid, at kung minsan dagdagan, minsan mananatiling pareho. Kaya, paano namin ipatupad ang pag-andar sa wrapper sa paligid ng index para sa mga keyword? 

Ako pagpunta sa gamitin ang count off halimbawa. Nagbibilang off ay isang popular na paraan upang hatiin ang mga tao sa mga grupo. Sinasabi ko ay 5 tao at nais kong split up ang mga ito sa tatlong grupo, kung sa gayon Gusto ko simulan sa pamamagitan ng pagbibilang off. Ang unang tao gagawin sabihin Ako team numero ng isa, sa susunod na tao ay magiging number team dalawa, ikatlong tao team number tatlo. Ngayon, gusto ko lang tatlong grupo kaya ang ika-apat na tao gagawin talaga magsimula sa simula at sabihin, well, ako team number one pati na rin, at ang susunod na tao ay magiging team bilang dalawang. At, mula doon, maaari nilang pagkatapos ay hiwalay sa kanilang mga grupo. 

Kaya, kung paano maaari ko bang gamitin modulo upang makatulong sa akin ipatupad ito count off pambalot sa paligid function? Well, ang unang tao numero 1, mod 3 ay nagbibigay sa amin 1. 2 mod 3 ay nagbibigay sa amin 2, at 3 mod 3 ay nagbibigay sa amin 0. 

Ang ika-apat na tao, numero 4, mod 3 ay nagbibigay sa amin 1, at pagkatapos ay 5 mod 3 ay nagbibigay sa amin 2. Kaya, na mapapansin mo na kahit na ang bilang ng mga tao na mayroon akong nagdaragdag, at ito ay sa itaas 3, dahil ako modding sa pamamagitan ng 3 Ako palaging makakuha ng mga numero ng 0, 1, at 2. Hindi ako makakuha ng mas malaki kaysa sa 3. Kaya nga, kahit na kung ako ay nagkaroon ng 10 mga tao, at pagkatapos ang lahat ng mga tao ay pa rin sa loob ng mga grupo 1, 2, o 0. 

Kaya, ngayon alam namin na kung kami ay may isang grupo 5 at mod namin ang lahat ng mga sa pamamagitan ng 3, pagkatapos ay hindi kailanman kami ay pagpunta sa lumampas grupo 0, 1, o 2. Kaya, kami ay hindi kailanman pagpunta upang makakuha ng isang grupo number na katumbas ng 3 o sa itaas. Kaya, kahit na kung ako magdadagdag ng limang higit pang mga mga tao, at pagkatapos ang lahat ng mga ito Gusto pa rin italaga sa grupo 0, 1, o 2 dahil ako modding sa pamamagitan ng 3. hindi ako pagpunta sa lumampas na cap. 

OK, kaya sabihin makita kung maaari naming mag-aplay ito konsepto ng paggamit ng modulo sa wrapper sa paligid ng numero ng grupo at mag-aplay ito sa Vigenere kung saan nais namin gamitin modulo sa wrapper sa paligid ang index para sa mga keyword. Kahit na kami ay incrementing ang index lagi naming gusto mong siguraduhin na lagi naming wrapper sa paligid sa pinakadulo simula hindi lalampas sa haba ng string. 

OK, kaya alam ko ito ay maaaring maging isang maliit na bit napakalaki. May isang pulutong ng higit na gawin sa ganitong p set. Kaya, siguraduhin na isulat mo out isang magandang pseudocode para sa iyong sarili na nauunawaan mo at na makakakuha ng trabaho tapos na. Subukan at matugunan ang bawat solong linya nang nakapag-iisa figuring out lahat ng mga maliit maliit na piraso ng puzzle bago ilagay ito nang magkasama. 

Tiyakin na maaari kang makakuha ng ang susi mula sa command line at tiyakin na ito ay pang-abakada, makuha ang plain text mula sa gumagamit, at pagkatapos ay sa enciphering, siguraduhin na ikaw alam kung paano Encipher isang solong titik, at pagkatapos ay pagsulong sa buong string sa lahat ng mga pambalot sa paligid function. Sa wakas, maaari mong i-print ang ciphertext. 

Ang pangalan ko ay isang Zamyla, at ito ay Vigenere. 