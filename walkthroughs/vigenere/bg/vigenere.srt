1
00:00:00,000 --> 00:00:00,930

2
00:00:00,930 --> 00:00:04,030
>> Zamyla Chan: Да се ​​засили нашата
игра с шифъра на vigenere.

3
00:00:04,030 --> 00:00:06,710
шифъра на vigenere е
много подобен на Цезар,

4
00:00:06,710 --> 00:00:11,060
освен в Caesar минахме през
едно цяло число, както е нашата ключ.

5
00:00:11,060 --> 00:00:14,100
В vigenere отиваме
да премине в една ключова дума.

6
00:00:14,100 --> 00:00:19,400
Така че, ако исках да измести
ciphertext това е CS 50 от Ohai,

7
00:00:19,400 --> 00:00:23,260
тогава това означава, че всяка буква в
Ohai ще служи като ключ,

8
00:00:23,260 --> 00:00:27,160
и аз ще цикъл над
че ключовата дума за моята смяна

9
00:00:27,160 --> 00:00:31,930
вземане на ciphertext
много по-трудно да се декодира.

10
00:00:31,930 --> 00:00:34,540
>> Какво означава да
измести от ключова дума?

11
00:00:34,540 --> 00:00:38,610
Е, ключовата дума е низ
където всяка буква съответства

12
00:00:38,610 --> 00:00:41,080
до известна число смяна.

13
00:00:41,080 --> 00:00:49,310
Така че, о съответства на ключова от 14,
ч до ключ на 7, а има ключова 0,

14
00:00:49,310 --> 00:00:54,670
така че няма да промени нищо,
и тогава аз има ключова от 8.

15
00:00:54,670 --> 00:01:00,000
>> Да речем, аз се завтече vigenere А с
обикновен текст това е CS50 добре,

16
00:01:00,000 --> 00:01:02,800
че просто ще даде
ми непроменен низ.

17
00:01:02,800 --> 00:01:08,170
Забележете, че това е еквивалентно на
течаща Цезар с ключ на нула.

18
00:01:08,170 --> 00:01:12,070
В действителност, течаща vigenere
с всеки един символ

19
00:01:12,070 --> 00:01:17,070
би било равносилно на бягане
Цезар със същото число.

20
00:01:17,070 --> 00:01:20,400
>> Добре, това е така, тъй като
те са толкова сходни, че ще е

21
00:01:20,400 --> 00:01:24,300
всъщност препоръчвам, че ако
искате, можете да копирате само си Цезар

22
00:01:24,300 --> 00:01:26,932
код в vigenere код.

23
00:01:26,932 --> 00:01:28,640
Нещата ще се променят,
но поне имате

24
00:01:28,640 --> 00:01:31,110
някои гръбнак, че можете да работите.

25
00:01:31,110 --> 00:01:36,410
Тъй като Todos са едни и същи, което искаме
да получите ключ, вземи обикновен текст,

26
00:01:36,410 --> 00:01:40,690
шифроване, че обикновен текст,
и след това да отпечатате, че навън.

27
00:01:40,690 --> 00:01:44,980
>> Точно като Цезар ключът ще
се предава в като втори команден ред

28
00:01:44,980 --> 00:01:50,540
аргумент, съдържаща се в индекса argv
1, но това е различно този път

29
00:01:50,540 --> 00:01:52,560
защото тя трябва да бъде азбучен.

30
00:01:52,560 --> 00:01:56,390
Така че, ние трябва да обхождане на всеки
един символ в този ключ

31
00:01:56,390 --> 00:02:00,800
че потребителят подаде в, и да гарантират,
че всеки герой е азбучен

32
00:02:00,800 --> 00:02:02,800
с цел да се продължи.

33
00:02:02,800 --> 00:02:05,560
>> След като сме направили това, тогава ние
може да получите на низ от страна на потребителя,

34
00:02:05,560 --> 00:02:07,560
точно както направихме преди.

35
00:02:07,560 --> 00:02:10,520
И сега, ние стигаме до сърцето
на проблема за vigenere,

36
00:02:10,520 --> 00:02:14,665
което е точно като Цезар, как да се
разбера модела шифриране

37
00:02:14,665 --> 00:02:19,760
и уравнение, и пиша с шифър
цялата прав текст.

38
00:02:19,760 --> 00:02:23,280
>> Така че, вие ще забележите, че
уравнение за смяна на vigenere

39
00:02:23,280 --> 00:02:25,610
е много подобен на този на Цезар.

40
00:02:25,610 --> 00:02:29,780
Единствената разлика е, че
вместо единичен вариабилен к

41
00:02:29,780 --> 00:02:37,270
преди, сега к има индекс,
посочващ jth буква на клавиша.

42
00:02:37,270 --> 00:02:39,560
>> Да разгледаме един пример.

43
00:02:39,560 --> 00:02:43,830
Да речем, че иска да премине в тайна
съобщение на вашия смаже, аз те харесвам.

44
00:02:43,830 --> 00:02:46,325
Е, за ключовата си ти
изберете нещо, което си

45
00:02:46,325 --> 00:02:49,790
знам смаже знае, че ви харесва, панди.

46
00:02:49,790 --> 00:02:52,290
Добре, така че как да се смени това?

47
00:02:52,290 --> 00:02:55,500
>> Е, ние имаме прав текст индекс.

48
00:02:55,500 --> 00:02:59,160
Това е най-първата буква и
така е индексът за нашия ключ

49
00:02:59,160 --> 00:03:02,830
който е в Р, първият
писмо в нашия панда дума.

50
00:03:02,830 --> 00:03:08,590
Така че, изместване I от стр ни х дава,
След това ние напредък в прав текст индекса.

51
00:03:08,590 --> 00:03:10,460
Това ни получава за интервал.

52
00:03:10,460 --> 00:03:13,540
Сега, характера пространство
не е азбучен,

53
00:03:13,540 --> 00:03:16,930
така че означава, че това просто
трансфери полето над към ciphertext,

54
00:03:16,930 --> 00:03:23,430
сложим пространство там, и ние не правим
преминете на индекса за нашия ключ.

55
00:03:23,430 --> 00:03:25,820
Така че, ние сме все още на стр в този момент.

56
00:03:25,820 --> 00:03:30,130
>> Ние преминете към следващия
индекс в нашия прав текст.

57
00:03:30,130 --> 00:03:34,030
И сега, защото това е
писмо, с малки букви L,

58
00:03:34,030 --> 00:03:37,920
ние се измести, че от
Следващата индекс в нашия ключ.

59
00:03:37,920 --> 00:03:42,360
Което е, която е нула,
смяна, така че просто се превръща

60
00:03:42,360 --> 00:03:44,370
на л в нашия ciphertext.

61
00:03:44,370 --> 00:03:51,120
След това, ние предварително както на прав текст, и
ключовият индекс защото е буквен.

62
00:03:51,120 --> 00:03:56,210
Така че след това ние продължаваме, че
докато стигнем до електронното в подобно.

63
00:03:56,210 --> 00:04:01,090
>> Добре, така че вие ​​ще забележите в тази
отбележа, че, от гледна точка на нашия ключов индекс,

64
00:04:01,090 --> 00:04:03,940
ние сме достигнали края на
панда думата, така че това,

65
00:04:03,940 --> 00:04:08,750
се случва, когато стигнем до следващото
азбучен писмо в прав текст?

66
00:04:08,750 --> 00:04:12,180
Е, всичко, което се случва, е, че ние
обгърне в началото,

67
00:04:12,180 --> 00:04:14,710
на първия индекс на нашия ключ.

68
00:04:14,710 --> 00:04:19,570
Така че, след това ние се измести, че
ш от стр да ни даде п.

69
00:04:19,570 --> 00:04:26,860
И след това, ние продължаваме довършителни кодиране
нашата прав текст, за да се получи х lvne NOH.

70
00:04:26,860 --> 00:04:29,300
>> От този пример I
показа, че ние само напред

71
00:04:29,300 --> 00:04:33,140
към следващата буква в Мрежа
ако героя в обикновен текст

72
00:04:33,140 --> 00:04:37,480
е писмо, така че isalpha
функция ще дойде по-удобно тук.

73
00:04:37,480 --> 00:04:43,030
И, точно както в Цезар, ние искаме да
запази случай, isupper и islower.

74
00:04:43,030 --> 00:04:46,100
Така че, добавете това малко
в в своя Псевдокод.

75
00:04:46,100 --> 00:04:48,510
>> И как ще разбера ключовите смени?

76
00:04:48,510 --> 00:04:53,030
Е, ако си припомним нашата дискусия
по азбучен индекси в Цезар

77
00:04:53,030 --> 00:04:55,370
проблем, това е много подобен.

78
00:04:55,370 --> 00:05:01,130
>> Когато А съответства на ASCII
стойност на 65, но промяна на 0,

79
00:05:01,130 --> 00:05:03,550
и след последната буква
в азбуката, Z,

80
00:05:03,550 --> 00:05:06,940
съответства на преминаването на 25.

81
00:05:06,940 --> 00:05:10,320
Ще забележите, че промяната
е идентичен или не

82
00:05:10,320 --> 00:05:14,880
писмото е с малки или главни случай.

83
00:05:14,880 --> 00:05:17,700
>> ОК, така че сега, че сте
знаят как да разбера

84
00:05:17,700 --> 00:05:21,470
цифровата смяна че
съответства на един символ

85
00:05:21,470 --> 00:05:24,050
нека се върнем към нашия уравнение.

86
00:05:24,050 --> 00:05:28,180
Защото ние имаме две различни
индекси тук, и й,

87
00:05:28,180 --> 00:05:32,130
това е намек, че ние искаме да следите
на двете ни позиция в прав текст

88
00:05:32,130 --> 00:05:36,600
както и нашата позиция в тази ключова дума,
така че тези два отделни променливи

89
00:05:36,600 --> 00:05:39,010
че искаме да могат да се задържат на.

90
00:05:39,010 --> 00:05:42,580
>> Сега, положението в нашата прав текст
ще се увеличава всеки път,

91
00:05:42,580 --> 00:05:45,530
така че ще бъде по-
малко по-чисти напред

92
00:05:45,530 --> 00:05:49,750
за разлика от положението на ключовата дума,
което ние знаем, трябва да обгърне,

93
00:05:49,750 --> 00:05:52,910
а понякога и прираста,
понякога останат същите.

94
00:05:52,910 --> 00:05:55,430
Така че, как да се приложат
функционалността

95
00:05:55,430 --> 00:05:59,820
да обгърне
индекс на ключовата дума?

96
00:05:59,820 --> 00:06:01,640
>> Отивам да се използва броиш пример.

97
00:06:01,640 --> 00:06:06,100
Преброяване на разстояние е популярен начин
да се разделят хората на групи.

98
00:06:06,100 --> 00:06:10,660
Кажете имах 5 души и аз исках да
ги разделят на три групи,

99
00:06:10,660 --> 00:06:13,640
добре тогава аз ще започна с отброяващ.

100
00:06:13,640 --> 00:06:16,980
Първият човек би
кажа, че съм отбор номер едно,

101
00:06:16,980 --> 00:06:21,030
на следващия човек ще бъде номер отбор
две, броят на отбора трето лице

102
00:06:21,030 --> 00:06:21,910
три.

103
00:06:21,910 --> 00:06:25,910
Сега, аз само искам три групи, така
четвъртия човек би действително

104
00:06:25,910 --> 00:06:30,160
започнем от самото начало и да кажа,
добре, аз съм отбор номер едно, както и,

105
00:06:30,160 --> 00:06:32,890
и на следващия човек
ще бъде отбор номер две.

106
00:06:32,890 --> 00:06:37,660
И от там, те могат след това да
разпределете в техните групи.

107
00:06:37,660 --> 00:06:41,130
>> Така че, как бих могъл да се използва по модул
да ми помогне да приложат

108
00:06:41,130 --> 00:06:44,160
това броиш разгънатата функция?

109
00:06:44,160 --> 00:06:50,140
Е, първият човек,
номер 1, мод 3 ни дава 1.

110
00:06:50,140 --> 00:06:54,690
2 мод 3 ни дава 2,
и 3 мод 3 ни дава 0.

111
00:06:54,690 --> 00:07:02,140
>> Четвъртото лице, номер 4, мод 3
ни дава 1, и след това 5 мод 3 ни дава 2.

112
00:07:02,140 --> 00:07:05,370
Така че, вие ще забележите, че въпреки че
броят на хората, които имам

113
00:07:05,370 --> 00:07:11,210
увеличава, и е по-
3, тъй като аз съм модифициране от 3

114
00:07:11,210 --> 00:07:15,250
Аз винаги се числа 0, 1, и 2.

115
00:07:15,250 --> 00:07:19,040
Никога не съм се по-голям от 3.

116
00:07:19,040 --> 00:07:22,630
Така че след това, дори ако имах 10
хора, а след това всички от тези хора,

117
00:07:22,630 --> 00:07:27,430
все още ще бъде в рамките на групи 1, 2, или 0.

118
00:07:27,430 --> 00:07:33,560
>> Така че, сега ние знаем, че ако имаме група
5 и моден всички тези с 3,

119
00:07:33,560 --> 00:07:38,180
След това ние никога няма да
превишава групи 0, 1, или 2.

120
00:07:38,180 --> 00:07:43,430
Така че, ние никога няма да се получи една група
номер, който е равен на 3 или по-висока.

121
00:07:43,430 --> 00:07:46,980
Така че, дори ако добавя още пет
хора, а след това всички от тях

122
00:07:46,980 --> 00:07:53,150
все пак ще бъдат причислени към групи
0, 1, или 2, защото аз съм модифициране от 3.

123
00:07:53,150 --> 00:07:56,510
Аз никога няма да надвишава тази капачка.

124
00:07:56,510 --> 00:08:00,800
>> ОК, така че нека да видим дали можем да прилага
тази концепция за използване на модул

125
00:08:00,800 --> 00:08:03,710
да обгърне
номера на групата и се прилага

126
00:08:03,710 --> 00:08:08,000
тя да vigenere където искаме
да използвате модул за увиване около

127
00:08:08,000 --> 00:08:10,220
индекса за ключовата дума.

128
00:08:10,220 --> 00:08:12,830
Въпреки, че ние сме увеличаване
индекса ние винаги

129
00:08:12,830 --> 00:08:17,260
искате да се уверите, че ние винаги
обгърне в самото начало

130
00:08:17,260 --> 00:08:20,050
никога не надвишава
дължина на низа.

131
00:08:20,050 --> 00:08:23,510
>> ОК, така че аз знам, че може да е
малко поразителен.

132
00:08:23,510 --> 00:08:26,670
Има още много да се направи в тази стр набор.

133
00:08:26,670 --> 00:08:30,050
Така че, уверете се, че пиша
добър Псевдокод за себе си

134
00:08:30,050 --> 00:08:32,870
че разбирате и
че върши работа.

135
00:08:32,870 --> 00:08:35,580
Опитайте и адрес на всеки
един ред независимо

136
00:08:35,580 --> 00:08:38,370
фигуриращ всички малки
малки парченца от пъзела

137
00:08:38,370 --> 00:08:40,260
преди да я сложите заедно.

138
00:08:40,260 --> 00:08:43,110
>> Уверете се, че можете да получите
ключът от командния ред

139
00:08:43,110 --> 00:08:46,780
и да се гарантира, че това е азбучен,
получите най-обикновен текст от потребителя,

140
00:08:46,780 --> 00:08:51,010
и след това в шифриране, се уверете, че сте
знам как да пиша с шифър една буква,

141
00:08:51,010 --> 00:08:56,130
и след това преминаване към целия низ
с всички разгъната функции.

142
00:08:56,130 --> 00:08:59,610
И накрая, можете да отпечатате ciphertext.

143
00:08:59,610 --> 00:09:04,050
>> Моето име е Zamyla,
и това беше vigenere.

144
00:09:04,050 --> 00:09:07,757

