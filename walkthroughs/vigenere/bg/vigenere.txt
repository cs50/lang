Zamyla Chan: Да се ​​засили нашата игра с шифъра на vigenere. шифъра на vigenere е много подобен на Цезар, освен в Caesar минахме през едно цяло число, както е нашата ключ. В vigenere отиваме да премине в една ключова дума. Така че, ако исках да измести ciphertext това е CS 50 от Ohai, тогава това означава, че всяка буква в Ohai ще служи като ключ, и аз ще цикъл над че ключовата дума за моята смяна вземане на ciphertext много по-трудно да се декодира. 

Какво означава да измести от ключова дума? Е, ключовата дума е низ където всяка буква съответства до известна число смяна. Така че, о съответства на ключова от 14, ч до ключ на 7, а има ключова 0, така че няма да промени нищо, и тогава аз има ключова от 8. 

Да речем, аз се завтече vigenere А с обикновен текст това е CS50 добре, че просто ще даде ми непроменен низ. Забележете, че това е еквивалентно на течаща Цезар с ключ на нула. В действителност, течаща vigenere с всеки един символ би било равносилно на бягане Цезар със същото число. 

Добре, това е така, тъй като те са толкова сходни, че ще е всъщност препоръчвам, че ако искате, можете да копирате само си Цезар код в vigenere код. Нещата ще се променят, но поне имате някои гръбнак, че можете да работите. Тъй като Todos са едни и същи, което искаме да получите ключ, вземи обикновен текст, шифроване, че обикновен текст, и след това да отпечатате, че навън. 

Точно като Цезар ключът ще се предава в като втори команден ред аргумент, съдържаща се в индекса argv 1, но това е различно този път защото тя трябва да бъде азбучен. Така че, ние трябва да обхождане на всеки един символ в този ключ че потребителят подаде в, и да гарантират, че всеки герой е азбучен с цел да се продължи. 

След като сме направили това, тогава ние може да получите на низ от страна на потребителя, точно както направихме преди. И сега, ние стигаме до сърцето на проблема за vigenere, което е точно като Цезар, как да се разбера модела шифриране и уравнение, и пиша с шифър цялата прав текст. 

Така че, вие ще забележите, че уравнение за смяна на vigenere е много подобен на този на Цезар. Единствената разлика е, че вместо единичен вариабилен к преди, сега к има индекс, посочващ jth буква на клавиша. 

Да разгледаме един пример. Да речем, че иска да премине в тайна съобщение на вашия смаже, аз те харесвам. Е, за ключовата си ти изберете нещо, което си знам смаже знае, че ви харесва, панди. Добре, така че как да се смени това? 

Е, ние имаме прав текст индекс. Това е най-първата буква и така е индексът за нашия ключ който е в Р, първият писмо в нашия панда дума. Така че, изместване I от стр ни х дава, След това ние напредък в прав текст индекса. Това ни получава за интервал. Сега, характера пространство не е азбучен, така че означава, че това просто трансфери полето над към ciphertext, сложим пространство там, и ние не правим преминете на индекса за нашия ключ. Така че, ние сме все още на стр в този момент. 

Ние преминете към следващия индекс в нашия прав текст. И сега, защото това е писмо, с малки букви L, ние се измести, че от Следващата индекс в нашия ключ. Което е, която е нула, смяна, така че просто се превръща на л в нашия ciphertext. След това, ние предварително както на прав текст, и ключовият индекс защото е буквен. Така че след това ние продължаваме, че докато стигнем до електронното в подобно. 

Добре, така че вие ​​ще забележите в тази отбележа, че, от гледна точка на нашия ключов индекс, ние сме достигнали края на панда думата, така че това, се случва, когато стигнем до следващото азбучен писмо в прав текст? Е, всичко, което се случва, е, че ние обгърне в началото, на първия индекс на нашия ключ. Така че, след това ние се измести, че ш от стр да ни даде п. И след това, ние продължаваме довършителни кодиране нашата прав текст, за да се получи х lvne NOH. 

От този пример I показа, че ние само напред към следващата буква в Мрежа ако героя в обикновен текст е писмо, така че isalpha функция ще дойде по-удобно тук. И, точно както в Цезар, ние искаме да запази случай, isupper и islower. Така че, добавете това малко в в своя Псевдокод. 

И как ще разбера ключовите смени? Е, ако си припомним нашата дискусия по азбучен индекси в Цезар проблем, това е много подобен. 

Когато А съответства на ASCII стойност на 65, но промяна на 0, и след последната буква в азбуката, Z, съответства на преминаването на 25. Ще забележите, че промяната е идентичен или не писмото е с малки или главни случай. 

ОК, така че сега, че сте знаят как да разбера цифровата смяна че съответства на един символ нека се върнем към нашия уравнение. Защото ние имаме две различни индекси тук, и й, това е намек, че ние искаме да следите на двете ни позиция в прав текст както и нашата позиция в тази ключова дума, така че тези два отделни променливи че искаме да могат да се задържат на. 

Сега, положението в нашата прав текст ще се увеличава всеки път, така че ще бъде по- малко по-чисти напред за разлика от положението на ключовата дума, което ние знаем, трябва да обгърне, а понякога и прираста, понякога останат същите. Така че, как да се приложат функционалността да обгърне индекс на ключовата дума? 

Отивам да се използва броиш пример. Преброяване на разстояние е популярен начин да се разделят хората на групи. Кажете имах 5 души и аз исках да ги разделят на три групи, добре тогава аз ще започна с отброяващ. Първият човек би кажа, че съм отбор номер едно, на следващия човек ще бъде номер отбор две, броят на отбора трето лице три. Сега, аз само искам три групи, така четвъртия човек би действително започнем от самото начало и да кажа, добре, аз съм отбор номер едно, както и, и на следващия човек ще бъде отбор номер две. И от там, те могат след това да разпределете в техните групи. 

Така че, как бих могъл да се използва по модул да ми помогне да приложат това броиш разгънатата функция? Е, първият човек, номер 1, мод 3 ни дава 1. 2 мод 3 ни дава 2, и 3 мод 3 ни дава 0. 

Четвъртото лице, номер 4, мод 3 ни дава 1, и след това 5 мод 3 ни дава 2. Така че, вие ще забележите, че въпреки че броят на хората, които имам увеличава, и е по- 3, тъй като аз съм модифициране от 3 Аз винаги се числа 0, 1, и 2. Никога не съм се по-голям от 3. Така че след това, дори ако имах 10 хора, а след това всички от тези хора, все още ще бъде в рамките на групи 1, 2, или 0. 

Така че, сега ние знаем, че ако имаме група 5 и моден всички тези с 3, След това ние никога няма да превишава групи 0, 1, или 2. Така че, ние никога няма да се получи една група номер, който е равен на 3 или по-висока. Така че, дори ако добавя още пет хора, а след това всички от тях все пак ще бъдат причислени към групи 0, 1, или 2, защото аз съм модифициране от 3. Аз никога няма да надвишава тази капачка. 

ОК, така че нека да видим дали можем да прилага тази концепция за използване на модул да обгърне номера на групата и се прилага тя да vigenere където искаме да използвате модул за увиване около индекса за ключовата дума. Въпреки, че ние сме увеличаване индекса ние винаги искате да се уверите, че ние винаги обгърне в самото начало никога не надвишава дължина на низа. 

ОК, така че аз знам, че може да е малко поразителен. Има още много да се направи в тази стр набор. Така че, уверете се, че пиша добър Псевдокод за себе си че разбирате и че върши работа. Опитайте и адрес на всеки един ред независимо фигуриращ всички малки малки парченца от пъзела преди да я сложите заедно. 

Уверете се, че можете да получите ключът от командния ред и да се гарантира, че това е азбучен, получите най-обикновен текст от потребителя, и след това в шифриране, се уверете, че сте знам как да пиша с шифър една буква, и след това преминаване към целия низ с всички разгъната функции. И накрая, можете да отпечатате ciphertext. 

Моето име е Zamyla, и това беше vigenere. 