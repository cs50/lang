1
00:00:00,000 --> 00:00:00,930

2
00:00:00,930 --> 00:00:04,030
>> Zamyla Чан: Давайте активизировать наши
игра с Vigenere шифра.

3
00:00:04,030 --> 00:00:06,710
Vigenere шифр
очень похож на Цезаря,

4
00:00:06,710 --> 00:00:11,060
кроме Цезаря мы прошли в
одно целое, как наш ключ.

5
00:00:11,060 --> 00:00:14,100
В Vigenere мы собираемся
передать в качестве ключевого слова.

6
00:00:14,100 --> 00:00:19,400
Так что, если бы я хотел, чтобы сдвинуть
шифротекста это CS 50 от ohai,

7
00:00:19,400 --> 00:00:23,260
то это означает, что каждая буква в
ohai будет служить в качестве ключа,

8
00:00:23,260 --> 00:00:27,160
и я собираюсь цикла над
что ключевое слово для моего сдвига

9
00:00:27,160 --> 00:00:31,930
что делает зашифрованного
гораздо труднее расшифровать.

10
00:00:31,930 --> 00:00:34,540
>> Что это значит
сдвиг по ключевому слову?

11
00:00:34,540 --> 00:00:38,610
Ну, ключевое слово является строкой
где каждая буква соответствует

12
00:00:38,610 --> 00:00:41,080
до некоторого целого сдвига.

13
00:00:41,080 --> 00:00:49,310
Таким образом, O соответствует ключу 14,
ч к ключу 7, имеет ключ от 0,

14
00:00:49,310 --> 00:00:54,670
так что ничего не изменило бы,
а затем я есть ключ 8.

15
00:00:54,670 --> 00:01:00,000
>> Скажем, я побежал Vigenere А с
простой текст это хорошо CS50,

16
00:01:00,000 --> 00:01:02,800
что бы просто дать
мне неизменную строку.

17
00:01:02,800 --> 00:01:08,170
Обратите внимание на то, что это эквивалентно
Цезарь работает с ключом, равным нулю.

18
00:01:08,170 --> 00:01:12,070
На самом деле, бег Vigenere
с любым одиночным символом

19
00:01:12,070 --> 00:01:17,070
будет эквивалентно запуску
Цезарь с тем же числом.

20
00:01:17,070 --> 00:01:20,400
>> Хорошо, так, так как
они настолько похожи, я бы

21
00:01:20,400 --> 00:01:24,300
на самом деле рекомендую, если вам
хотите, вы можете просто скопировать Цезарь

22
00:01:24,300 --> 00:01:26,932
код в код Vigenere.

23
00:01:26,932 --> 00:01:28,640
Все изменится,
но по крайней мере у вас есть

24
00:01:28,640 --> 00:01:31,110
некоторые позвоночник, что вы можете работать с.

25
00:01:31,110 --> 00:01:36,410
Поскольку TODOS такие же мы хотим
чтобы получить ключ, получить простой текст,

26
00:01:36,410 --> 00:01:40,690
зашифровывать, что обычный текст,
а затем распечатать это.

27
00:01:40,690 --> 00:01:44,980
>> Так же, как Цезарь ключ собирается
быть принят в качестве второй командной строки

28
00:01:44,980 --> 00:01:50,540
аргумент, содержащийся в индексе ARGV
1, но это по-другому на этот раз

29
00:01:50,540 --> 00:01:52,560
потому что она должна быть в алфавитном порядке.

30
00:01:52,560 --> 00:01:56,390
Таким образом, мы должны перебрать каждый
один символ в этом ключе

31
00:01:56,390 --> 00:02:00,800
что пользователь прошел в, а также обеспечить
что каждый символ буквенный

32
00:02:00,800 --> 00:02:02,800
для того, чтобы продолжить.

33
00:02:02,800 --> 00:02:05,560
>> После того, как мы сделали это, то мы
может получить строку от пользователя,

34
00:02:05,560 --> 00:02:07,560
так же, как мы делали раньше.

35
00:02:07,560 --> 00:02:10,520
И теперь, мы приходим к сердцу
проблемы для Vigenere,

36
00:02:10,520 --> 00:02:14,665
который так же, как Цезарь, то как к
выяснить картину шифровании

37
00:02:14,665 --> 00:02:19,760
и уравнение, и зашифровывать
весь открытый текст.

38
00:02:19,760 --> 00:02:23,280
>> Таким образом, вы заметите, что
Уравнение для Vigenere сдвига

39
00:02:23,280 --> 00:02:25,610
очень похож на Цезаря один.

40
00:02:25,610 --> 00:02:29,780
Единственное отличие состоит в том, что
вместо одной переменной к

41
00:02:29,780 --> 00:02:37,270
раньше, теперь к имеет индекс,
с указанием -ю букву ключа.

42
00:02:37,270 --> 00:02:39,560
>> Давайте разберем пример.

43
00:02:39,560 --> 00:02:43,830
Допустим, вы хотели передать секрет
сообщение на ваш давка, что ты мне нравишься.

44
00:02:43,830 --> 00:02:46,325
Ну, для вашего ключа, который вы
выбрать что-то, что ваш

45
00:02:46,325 --> 00:02:49,790
знаю, давка знает, что вам нравится, панд.

46
00:02:49,790 --> 00:02:52,290
Хорошо, так как мы сдвинем это?

47
00:02:52,290 --> 00:02:55,500
>> Ну, у нас есть наш индекс открытого текста.

48
00:02:55,500 --> 00:02:59,160
Вот в первом письме и
так это индекс для нашего ключа

49
00:02:59,160 --> 00:03:02,830
которая находится на р, первый
буква в нашем панды слове.

50
00:03:02,830 --> 00:03:08,590
Таким образом, смещение I р дает нам х,
Затем мы продвигаемся открытого текста индекс.

51
00:03:08,590 --> 00:03:10,460
Это заставляет нас пространство.

52
00:03:10,460 --> 00:03:13,540
Теперь, символ пробела
не является алфавитным,

53
00:03:13,540 --> 00:03:16,930
так что это означает, что, что как раз
передает прямо к шифротекста,

54
00:03:16,930 --> 00:03:23,430
мы помещаем пространство там, и мы не делаем
продвигать индекс для нашего ключа.

55
00:03:23,430 --> 00:03:25,820
Таким образом, мы все еще на р в этой точке.

56
00:03:25,820 --> 00:03:30,130
>> Мы перейти к следующему
Индекс в нашем открытого текста.

57
00:03:30,130 --> 00:03:34,030
А теперь, потому что это
буква, нижний регистр л,

58
00:03:34,030 --> 00:03:37,920
мы переходим что к
Следующий индекс в нашем ключе.

59
00:03:37,920 --> 00:03:42,360
Который является, который является нулевым
сдвиг, так что просто становится

60
00:03:42,360 --> 00:03:44,370
л в нашем шифротекста.

61
00:03:44,370 --> 00:03:51,120
Затем мы продвигаемся как открытый текст, и
ключ индекса, потому что это буквенный.

62
00:03:51,120 --> 00:03:56,210
Итак, мы продолжаем, что
пока мы не получим на электронный адрес в подобном.

63
00:03:56,210 --> 00:04:01,090
>> Хорошо, так что вы увидите в этом
указывают, что, с точки зрения нашего ключевого индекса,

64
00:04:01,090 --> 00:04:03,940
мы достигли конца
панда слово, так, что

65
00:04:03,940 --> 00:04:08,750
происходит, когда мы перейдем к следующему
алфавитный буква в незашифрованном виде?

66
00:04:08,750 --> 00:04:12,180
Ну, все, что происходит, мы
обернуть вокруг начала,

67
00:04:12,180 --> 00:04:14,710
к первому индексу нашего ключа.

68
00:04:14,710 --> 00:04:19,570
Так, тогда мы перемещаем, что
у р, чтобы дать нам п.

69
00:04:19,570 --> 00:04:26,860
И потом, мы продолжаем отделочные кодирование
наш открытый текст, чтобы получить х lvne NOH.

70
00:04:26,860 --> 00:04:29,300
>> Из этого примера, я
показали, что мы только заранее

71
00:04:29,300 --> 00:04:33,140
к следующей букве в ключевых словах
если символ в виде обычного текста

72
00:04:33,140 --> 00:04:37,480
это письмо так что IsAlpha
функция пригодится здесь.

73
00:04:37,480 --> 00:04:43,030
И, так же, как в Цезарь, мы хотим
сохранить дела, ISUPPER и ISLOWER.

74
00:04:43,030 --> 00:04:46,100
Так, добавьте немного
в в ваш псевдокоде.

75
00:04:46,100 --> 00:04:48,510
>> Так как же нам выяснить ключевые сдвиги?

76
00:04:48,510 --> 00:04:53,030
Ну, если вы помните нашу дискуссию
на буквенных индексов в Цезаре

77
00:04:53,030 --> 00:04:55,370
проблема, это очень похоже.

78
00:04:55,370 --> 00:05:01,130
>> Где A соответствует ASCII
значение 65, но смещение 0,

79
00:05:01,130 --> 00:05:03,550
а затем последняя буква
в алфавите, Z,

80
00:05:03,550 --> 00:05:06,940
соответствует сдвигу 25.

81
00:05:06,940 --> 00:05:10,320
Вы заметите, что сдвиг
идентична или нет

82
00:05:10,320 --> 00:05:14,880
буква в верхнем регистре или нижнем регистре.

83
00:05:14,880 --> 00:05:17,700
>> ОК, так что теперь, когда вы
знают, как выяснить,

84
00:05:17,700 --> 00:05:21,470
численный сдвиг,
соответствует одному символу

85
00:05:21,470 --> 00:05:24,050
давайте вернемся к нашему уравнению.

86
00:05:24,050 --> 00:05:28,180
Потому что мы имеем два различных
индексы здесь, я и J,

87
00:05:28,180 --> 00:05:32,130
это намек, что мы хотим, чтобы следить
и нашей позиции в незашифрованном

88
00:05:32,130 --> 00:05:36,600
а также нашей позиции в ключевых словах,
так что те две отдельные переменные

89
00:05:36,600 --> 00:05:39,010
что мы хотим сохранить владение.

90
00:05:39,010 --> 00:05:42,580
>> Теперь положение в нашем незашифрованном
будет увеличиваться каждый раз,

91
00:05:42,580 --> 00:05:45,530
так что это будет
немного более прямо вперед

92
00:05:45,530 --> 00:05:49,750
в отличие от позиции ключевых слов,
который мы знаем, есть обернуть вокруг,

93
00:05:49,750 --> 00:05:52,910
а иногда и приращение,
иногда остаются теми же.

94
00:05:52,910 --> 00:05:55,430
Итак, как же мы реализуем
функциональность

95
00:05:55,430 --> 00:05:59,820
чтобы обернуть вокруг
Индекс для ключевого слова?

96
00:05:59,820 --> 00:06:01,640
>> Я собираюсь использовать отсчитать пример.

97
00:06:01,640 --> 00:06:06,100
Отсчитывая является популярным способом
чтобы разделить людей на группы.

98
00:06:06,100 --> 00:06:10,660
Скажем, у меня было 5 человек, и я хотел
разделить их на три группы,

99
00:06:10,660 --> 00:06:13,640
ну тогда я хотел бы начать с загибать.

100
00:06:13,640 --> 00:06:16,980
Первый человек будет
сказать, что я команда номер один,

101
00:06:16,980 --> 00:06:21,030
следующий человек будет номер команды
два, третье лицо номер команды

102
00:06:21,030 --> 00:06:21,910
три.

103
00:06:21,910 --> 00:06:25,910
Теперь, я хочу только три группы так,
четвертый человек будет на самом деле

104
00:06:25,910 --> 00:06:30,160
начать с самого начала, и говорят,
ну, я команда номер один, а также,

105
00:06:30,160 --> 00:06:32,890
и следующий человек
будет команда номер два.

106
00:06:32,890 --> 00:06:37,660
И оттуда, они могут
разделяются на свои группы.

107
00:06:37,660 --> 00:06:41,130
>> Итак, как я мог бы использовать по модулю
чтобы помочь мне реализовать

108
00:06:41,130 --> 00:06:44,160
это отсчитать обтекать функции?

109
00:06:44,160 --> 00:06:50,140
Ну, первый человек,
номер 1, по модулю 3 дает нам 1.

110
00:06:50,140 --> 00:06:54,690
2 мод 3 дает нам 2,
и 3 по модулю 3 дает нам 0.

111
00:06:54,690 --> 00:07:02,140
>> Четвертый человек, номер 4, мод 3
дает нам 1, а затем 5 мод 3 дает нам 2.

112
00:07:02,140 --> 00:07:05,370
Таким образом, можно заметить, что несмотря на то,
число людей, что у меня есть

113
00:07:05,370 --> 00:07:11,210
увеличивается, и выше
3, так как я моддинга на 3

114
00:07:11,210 --> 00:07:15,250
Я всегда получаю числа 0, 1 и 2.

115
00:07:15,250 --> 00:07:19,040
Я никогда не получаю больше, чем 3.

116
00:07:19,040 --> 00:07:22,630
Итак, даже если у меня было 10
люди, то все из тех людей,

117
00:07:22,630 --> 00:07:27,430
будет по-прежнему находиться в группах 1, 2 или 0.

118
00:07:27,430 --> 00:07:33,560
>> Итак, теперь мы знаем, что если мы имеем группу
5 и мы мод все те, на 3,

119
00:07:33,560 --> 00:07:38,180
то мы никогда не будем
превышать группы 0, 1 или 2.

120
00:07:38,180 --> 00:07:43,430
Таким образом, мы никогда не собираемся, чтобы получить группу
число, это равно 3 или выше.

121
00:07:43,430 --> 00:07:46,980
Таким образом, даже если я добавлю еще пять
люди, то все из них

122
00:07:46,980 --> 00:07:53,150
будет по-прежнему быть назначены группам
0, 1 или 2, потому что я моддинга на 3.

123
00:07:53,150 --> 00:07:56,510
Я никогда не будет превышать эту крышку.

124
00:07:56,510 --> 00:08:00,800
>> ОК, так что давайте посмотрим, если мы можем применить
это понятие использования по модулю

125
00:08:00,800 --> 00:08:03,710
чтобы обернуть вокруг
номера групп и применить

126
00:08:03,710 --> 00:08:08,000
это Vigenere, где мы хотим
использовать по модулю, чтобы обернуть вокруг

127
00:08:08,000 --> 00:08:10,220
индекс по ключевому слову.

128
00:08:10,220 --> 00:08:12,830
Несмотря на то, что мы приращением
индекс мы всегда

129
00:08:12,830 --> 00:08:17,260
хотите, чтобы убедиться, что мы всегда
обтекать к самому началу

130
00:08:17,260 --> 00:08:20,050
никогда не превышая
длина строки.

131
00:08:20,050 --> 00:08:23,510
>> ОК, так что я знаю, что это может быть
немного подавляющим.

132
00:08:23,510 --> 00:08:26,670
Там очень много больше, чтобы сделать в этом р наборе.

133
00:08:26,670 --> 00:08:30,050
Итак, убедитесь, что вы пишете из
хороший псевдокод для себя

134
00:08:30,050 --> 00:08:32,870
что вы понимаете и
что выполняет свою работу.

135
00:08:32,870 --> 00:08:35,580
Попробуйте обратиться каждый
одиночная линия независимо друг от друга

136
00:08:35,580 --> 00:08:38,370
выяснить все мало
небольшие кусочки головоломки

137
00:08:38,370 --> 00:08:40,260
прежде чем положить его вместе.

138
00:08:40,260 --> 00:08:43,110
>> Убедитесь, что вы можете получить
ключ из командной строки

139
00:08:43,110 --> 00:08:46,780
и убедитесь, что это алфавитный,
получить простой текст от пользователя,

140
00:08:46,780 --> 00:08:51,010
а затем в шифровании, убедитесь, что вы
знают, как зашифровать одну букву,

141
00:08:51,010 --> 00:08:56,130
а затем переходите на всю строку
со всеми обернуть вокруг функций.

142
00:08:56,130 --> 00:08:59,610
И, наконец, вы можете распечатать шифротекста.

143
00:08:59,610 --> 00:09:04,050
>> Меня зовут это Zamyla,
и это было Vigenere.

144
00:09:04,050 --> 00:09:07,757

