1
00:00:00,000 --> 00:00:00,930

2
00:00:00,930 --> 00:00:04,030
>> Zamyla陈：我们加强我们的
游戏与V @ genere加密。

3
00:00:04,030 --> 00:00:06,710
在V @ genere加密是
非常相似，凯撒，

4
00:00:06,710 --> 00:00:11,060
除了凯撒，我们通过在
一个整数作为我们的重点。

5
00:00:11,060 --> 00:00:14,100
在的V @ genere我们要去
一个关键字来传递。

6
00:00:14,100 --> 00:00:19,400
所以，如果我想转移
密文，这是CS 50由ohai，

7
00:00:19,400 --> 00:00:23,260
那么这意味着在每个信
ohai是要作为重点，

8
00:00:23,260 --> 00:00:27,160
而我要在循环
该关键字为我的转变

9
00:00:27,160 --> 00:00:31,930
使得密文
很多难以解码。

10
00:00:31,930 --> 00:00:34,540
>> 什么意思
由关键字转移？

11
00:00:34,540 --> 00:00:38,610
好了，关键字是一个字符串
其中的每个字母对应

12
00:00:38,610 --> 00:00:41,080
一些整数转变。

13
00:00:41,080 --> 00:00:49,310
因此，邻相当于14的关键，
小时至7的键，一个具有0的一个关键，

14
00:00:49,310 --> 00:00:54,670
这样，才不会改变什么，
然后我有8个关键。

15
00:00:54,670 --> 00:01:00,000
>> 说我跑的V @ genere A在
纯文本，这是很好CS50，

16
00:01:00,000 --> 00:01:02,800
这将简单地给
我一个不变的字符串。

17
00:01:02,800 --> 00:01:08,170
注意，这是相当于
为零的关键运行凯撒。

18
00:01:08,170 --> 00:01:12,070
事实上，在运行的V @ genere
与任何单个字符

19
00:01:12,070 --> 00:01:17,070
将相当于跑步
凯撒与相同的整数。

20
00:01:17,070 --> 00:01:20,400
>> 好吧，那么，由于
他们是如此的相似我最好

21
00:01:20,400 --> 00:01:24,300
其实建议，如果您
希望你可以复制你的恺撒

22
00:01:24,300 --> 00:01:26,932
代码到你的V @ genere代码。

23
00:01:26,932 --> 00:01:28,640
事情会改变，
但至少有

24
00:01:28,640 --> 00:01:31,110
一些骨干，你可以工作。

25
00:01:31,110 --> 00:01:36,410
因为TODOS是我们想的一样
拿到钥匙，拿到纯文本，

26
00:01:36,410 --> 00:01:40,690
加密器是纯文本，
然后打印了这一点。

27
00:01:40,690 --> 00:01:44,980
>> 就像凯撒的关键是要
传递中作为第二个命令行

28
00:01:44,980 --> 00:01:50,540
包含argv中索引参数
1，但它的不同，这一次

29
00:01:50,540 --> 00:01:52,560
因为它必须是字母。

30
00:01:52,560 --> 00:01:56,390
所以，我们需要遍历每个
在这关键的单个字符

31
00:01:56,390 --> 00:02:00,800
该用户通过在，并确保
每一个字符是字母

32
00:02:00,800 --> 00:02:02,800
以继续。

33
00:02:02,800 --> 00:02:05,560
>> 一旦我们做到了这一点，那么我们
可以从用户获取字符串，

34
00:02:05,560 --> 00:02:07,560
就像我们以前那样。

35
00:02:07,560 --> 00:02:10,520
而现在，我们来到了心脏
对的V @ genere的问题，

36
00:02:10,520 --> 00:02:14,665
这就像撒，怎么
找出加密模式

37
00:02:14,665 --> 00:02:19,760
和方程，和加密器
整个明文。

38
00:02:19,760 --> 00:02:23,280
>> 所以，你会发现，
公式为的V @ genere转变

39
00:02:23,280 --> 00:02:25,610
是非常相似的凯撒之一。

40
00:02:25,610 --> 00:02:29,780
唯一的区别在于
代替一个单一的变量k

41
00:02:29,780 --> 00:02:37,270
之前，目前k的下标，
指示密钥的第j个信。

42
00:02:37,270 --> 00:02:39,560
>> 让我们通过一个例子。

43
00:02:39,560 --> 00:02:43,830
假设你想通过一个秘密
消息到你的美眉，我喜欢你。

44
00:02:43,830 --> 00:02:46,325
嗯，你的钥匙，你
选择一些你

45
00:02:46,325 --> 00:02:49,790
知道美眉都知道，你喜欢，熊猫。

46
00:02:49,790 --> 00:02:52,290
好吧，那么我们如何转变呢？

47
00:02:52,290 --> 00:02:55,500
>> 好了，我们有明文的索引。

48
00:02:55,500 --> 00:02:59,160
这是在第一个字母，
所以是我们的关键指标

49
00:02:59,160 --> 00:03:02,830
这是在p，第一
信我们的熊猫字。

50
00:03:02,830 --> 00:03:08,590
所以，用p转移我给我们的x，
那么我们提前明文指数。

51
00:03:08,590 --> 00:03:10,460
这得到我们的空间。

52
00:03:10,460 --> 00:03:13,540
现在，空格字符
非字母，

53
00:03:13,540 --> 00:03:16,930
这样就意味着，这只是
就在以密文传输，

54
00:03:16,930 --> 00:03:23,430
我们把一个空间，在那里，我们不
为推进我们的重要指标。

55
00:03:23,430 --> 00:03:25,820
因此，我们仍然在P在这一点上。

56
00:03:25,820 --> 00:03:30,130
>> 我们前进到下一个
指数在我们的明文。

57
00:03:30,130 --> 00:03:34,030
而现在，因为那是
一个字母，小写的L，

58
00:03:34,030 --> 00:03:37,920
我们转变，由
在我们的下一个关键指标。

59
00:03:37,920 --> 00:03:42,360
其是，这是一个零
移，使得刚变得

60
00:03:42,360 --> 00:03:44,370
一个l在我们的密文。

61
00:03:44,370 --> 00:03:51,120
然后，我们提前两个明文和
关键指标，因为它是字母。

62
00:03:51,120 --> 00:03:56,210
于是我们继续认为
直到我们得到电子的等。

63
00:03:56,210 --> 00:04:01,090
>> 好吧，所以你会在这个通知
指出的是，在我们的关键指标方面，

64
00:04:01,090 --> 00:04:03,940
我们已经达到的结束
熊猫的话，那又怎样

65
00:04:03,940 --> 00:04:08,750
当我们到接下来会发生
在明文字母文字？

66
00:04:08,750 --> 00:04:12,180
那么，所发生的一切是我们
环绕的开始，

67
00:04:12,180 --> 00:04:14,710
我们关键的第一个索引。

68
00:04:14,710 --> 00:04:19,570
这样，那么我们移
Ÿ用p给我们ñ。

69
00:04:19,570 --> 00:04:26,860
然后，我们继续整理编码
我们的明文时得到对X lvne能乐。

70
00:04:26,860 --> 00:04:29,300
>> 从这个例子中，我
表明我们只前进

71
00:04:29,300 --> 00:04:33,140
在关键字的下一个字母
如果以纯文本字符

72
00:04:33,140 --> 00:04:37,480
是一个字母所以因而isalpha
功能将在这里派上用场。

73
00:04:37,480 --> 00:04:43,030
而且，正如恺撒，我们要
保留的情况下，isupper和islower判断。

74
00:04:43,030 --> 00:04:46,100
因此，加这一点点
在进入你的伪代码。

75
00:04:46,100 --> 00:04:48,510
>> 那么，我们如何找出关键的变化？

76
00:04:48,510 --> 00:04:53,030
好吧，如果你还记得我们的讨论
在凯撒的字母索引

77
00:04:53,030 --> 00:04:55,370
的问题，这是非常相似的。

78
00:04:55,370 --> 00:05:01,130
>> 其中，A对应的ASCII
65值而是0的移位，

79
00:05:01,130 --> 00:05:03,550
然后最后一个字母
在字母表，Z，

80
00:05:03,550 --> 00:05:06,940
对应于25的移位。

81
00:05:06,940 --> 00:05:10,320
你会注意到，移位
是相同与否

82
00:05:10,320 --> 00:05:14,880
字母为大写或小写。

83
00:05:14,880 --> 00:05:17,700
>> 好了，现在你
知道如何找出

84
00:05:17,700 --> 00:05:21,470
数字的转变，
对应于单个字符

85
00:05:21,470 --> 00:05:24,050
让我们回到我们的方程。

86
00:05:24,050 --> 00:05:28,180
因为我们有两个不同的
这里下标i和j，

87
00:05:28,180 --> 00:05:32,130
这就是我们要跟踪的提示
我们在这两个明文位置

88
00:05:32,130 --> 00:05:36,600
以及我们在关键字的位置，
所以这些都是两个独立的变量

89
00:05:36,600 --> 00:05:39,010
我们要保持的保持。

90
00:05:39,010 --> 00:05:42,580
>> 现在，在我们的明文的位置
将会增加每次

91
00:05:42,580 --> 00:05:45,530
所以这将是一个
有点更直截了当

92
00:05:45,530 --> 00:05:49,750
相对于位置的关键字，
我们知道有环绕，

93
00:05:49,750 --> 00:05:52,910
有时增加，
有时会保持不变。

94
00:05:52,910 --> 00:05:55,430
那么，我们如何实现
功能

95
00:05:55,430 --> 00:05:59,820
环绕的
索引关键字？

96
00:05:59,820 --> 00:06:01,640
>> 我将使用报数的例子。

97
00:06:01,640 --> 00:06:06,100
关闭计数是一种流行的方式
人分成组。

98
00:06:06,100 --> 00:06:10,660
说我有5人，我想
将它们分割成三组，

99
00:06:10,660 --> 00:06:13,640
还有那么我会通过计算关闭启动。

100
00:06:13,640 --> 00:06:16,980
第一个人会
说我是球队的头号，

101
00:06:16,980 --> 00:06:21,030
旁边的人将是球队数
二，第三人的团队数

102
00:06:21,030 --> 00:06:21,910
三。

103
00:06:21,910 --> 00:06:25,910
现在，我只希望三组这样
第四人实际上

104
00:06:25,910 --> 00:06:30,160
创业之初，说：
好，我是球队的头号为好，

105
00:06:30,160 --> 00:06:32,890
和旁边的人
是球队的二号。

106
00:06:32,890 --> 00:06:37,660
而且，从那里，他们可以再
分解成多个小组。

107
00:06:37,660 --> 00:06:41,130
>> 所以，我怎么可能会使用模
帮我实现

108
00:06:41,130 --> 00:06:44,160
这算脱围功能包？

109
00:06:44,160 --> 00:06:50,140
那么，第一人
1号，3 MOD给了我们1。

110
00:06:50,140 --> 00:06:54,690
2模3给了我们2，
3 MOD 3给我们0。

111
00:06:54,690 --> 00:07:02,140
>> 第四个人，4号，国防部3
给了我们1，然后5 MOD 3给了我们2。

112
00:07:02,140 --> 00:07:05,370
所以，你会发现，即使
我有多少人

113
00:07:05,370 --> 00:07:11,210
增加，并且是上述
3，因为我3改装

114
00:07:11,210 --> 00:07:15,250
我总是得到的数字0，1，2。

115
00:07:15,250 --> 00:07:19,040
我从来没有得到大于3。

116
00:07:19,040 --> 00:07:22,630
那么，即使我有10个
人，那么这些人的

117
00:07:22,630 --> 00:07:27,430
仍然会组1,2，或0内。

118
00:07:27,430 --> 00:07:33,560
>> 所以，现在我们知道，如果我们有一组
5，我们国防部所有那些由3，

119
00:07:33,560 --> 00:07:38,180
那么我们永远不会
超过基0，1或2。

120
00:07:38,180 --> 00:07:43,430
所以，我们永远不会得到一组
号这等于3或以上。

121
00:07:43,430 --> 00:07:46,980
所以，即使我想补充五个
人，然后将其全部

122
00:07:46,980 --> 00:07:53,150
仍然会分配给组
0，1，或2个是因为我被3改装。

123
00:07:53,150 --> 00:07:56,510
我永远不会超过这一上限。

124
00:07:56,510 --> 00:08:00,800
>> OK，让我们看看我们是否可以申请
使用模的概念

125
00:08:00,800 --> 00:08:03,710
环绕的
组号和应用

126
00:08:03,710 --> 00:08:08,000
它的V @ genere我们想要
使用模环绕

127
00:08:08,000 --> 00:08:10,220
索引关键字。

128
00:08:10,220 --> 00:08:12,830
即使我们递增
该指数我们始终

129
00:08:12,830 --> 00:08:17,260
要确保我们始终
环绕到最开始

130
00:08:17,260 --> 00:08:20,050
从来没有超过
字符串的长度。

131
00:08:20,050 --> 00:08:23,510
>> 好了，我知道这可能是
有点势不可挡。

132
00:08:23,510 --> 00:08:26,670
还有很多工作要做在该p集。

133
00:08:26,670 --> 00:08:30,050
因此，请确保你写出来的
一个良好的伪代码为自己

134
00:08:30,050 --> 00:08:32,870
您理解并
即能够完成任务。

135
00:08:32,870 --> 00:08:35,580
尝试并解决每一个
单行独立

136
00:08:35,580 --> 00:08:38,370
搞清楚所有的小
小块拼图

137
00:08:38,370 --> 00:08:40,260
之前把它在一起。

138
00:08:40,260 --> 00:08:43,110
>> 请确保你可以得到
在命令行的关键

139
00:08:43,110 --> 00:08:46,780
并确保它的字母，
从用户那里得到的纯文本，

140
00:08:46,780 --> 00:08:51,010
然后加密，请确保您
知道如何来加密一个字母，

141
00:08:51,010 --> 00:08:56,130
然后发展到整个字符串
与各地的功能包的。

142
00:08:56,130 --> 00:08:59,610
最后，你可以打印密文。

143
00:08:59,610 --> 00:09:04,050
>> 我的名字是一个Zamyla，
并且这是的V @ genere。

144
00:09:04,050 --> 00:09:07,757

