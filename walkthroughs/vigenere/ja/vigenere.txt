Zamylaチャン：私たちのステップアップしてみましょう ヴィジュネル暗号との試合。 ヴィジュネル暗号です シーザーと非常に似て、 シーザーを除いて、我々は、渡されました 私たちのキーとして単一の整数。 vigenereにおいて、我々はつもりです キーワードに渡します。 だから、私はシフトしたい場合 これはohaiによりCS 50である暗号文、 そして、それは内の各文字のことを意味し ohaiはキーとして機能するように起こっています、 そして、私は以上のサイクルに行きますよ 私のシフトのために、そのキーワード 暗号文を作ります 復号化する多くの困難。 

それはに何を意味します キーワードによるシフト？ まあ、キーワードが文字列であります ここで、すべての文字が対応 いくつかの整数シフトに。 そのように、oは14のキーに対応し、 7のキーの時間は、Aは、0のキーを有します そのためには、何も変わらないだろう そして私は8の鍵を持っています。 

私はvigenereのAを実行したと言います プレーンテキストは、これはよくCS50あり、 それは単に与えるだろう 私不変の文字列。 これはと等価であることに注意してください ゼロのキーでシーザーを実行しています。 実際には、実行中のvigenere 任意の単一文字と ランニングに相当します その同じ整数とシーザー。 

すべての権利、そう、以来、 彼らは私がしたいので、似ています 実際にあなたの場合することをお勧めします あなたは自分のシーザーをコピーすることができますしたいです あなたのvigenereコードにコード。 物事は変化します、 しかし、少なくともあなたが持っています あなたと働くことができるいくつかのバックボーン。 TODOのは、私たちが望む同じであるため キーを取得するには、プレーンテキストを取得し、 暗号化することプレーンテキスト、 そしてその後、それをプリントアウト。 

ただ、シーザーのようにキーをしようとしています 第2のコマンドラインとして渡され argvインデックスに含まれる引数 1が、それが今回は違います それは、アルファベットでなければなりませんので。 そこで、我々は、すべてを反復処理する必要があります そのキーで単一の文字 ユーザーが渡されたこと、および確保 すべての文字はアルファベットであること 継続するためです。 

私たちは、その後、それをやった後は ユーザーから文字列を取得することができ、 我々は以前と同じように。 そして今、私たちは心に来ます vigenereのための問題の、 ちょうどシーザーのようにこれは、どのように 暗号化パターンを把握 と式、および暗号化します 全体の平文。 

だから、あなたがいることに気づくでしょう vigenereシフトのための方程式 シーザーの1と非常によく似ています。 唯一の違いは、ということです 代わりに、単一の変数kの 前に、今kは添え字を持って、 鍵のj番目の文字を示します。 

例を見てみましょう。 あなたが秘密を渡したいと言います あなたのクラッシュへのメッセージは、私はあなたが好きです。 さて、あなたのキーのためのあなた そのあなたの何かを選びます クラッシュは、あなたが、パンダが好きなことを知っている知っています。 すべての権利、私たちはこれをどのようにシフトしていますか？ 

さて、私たちは平文のインデックスを持っています。 つまり、最初の文字でだと そのように私たちのキーのインデックスです これは、pで、最初のものです 私たちのパンダの単語の文字。 だから、pで私をシフトすることは、私たちのx与え、 その後、我々は平文のインデックスを進めます。 これは、スペースに私たちを取得します。 さて、スペース文字 非アルファベットは、 そのためには、ちょうど、そのことを意味します 右の暗号文に渡って転送、 我々はそこにスペースを入れて、我々はしないでください 私たちのキーのインデックスを進めます。 そこで、我々は、この時点でのpではまだです。 

私たちは、次へ進みます 私たちの平文のインデックス。 そして今、それがあるため 文字、小文字のL、 我々はによりことをシフト 私たちのキーに次のインデックス。 ゼロである、これであります シフトだけになるように、 私たちの暗号文でリットル。 その後、我々は平文の両方を進めると、 キーインデックスそれはアルファベットのだから。 それでは、私たちはそれを続けます 私たちは、などに電子を得るまで。 

あなたはこの時にわかりますので、すべての権利、 当社の主要指標の面で、それを指して、 我々はの終わりに達しました パンダの言葉なので、どのような 我々は次に行くときに発生 平文でのアルファベット？ まあ、それが起こるすべてが私たちです 先頭にラップアラウンド、 私たちのキーの最初のインデックスへ。 だから、我々はことをシフト nは私たちを与えるためにPでyの。 そして、私たちは、エンコーディングを終え続けます 私たちの平文は、x lvneの能楽を取得します。 

この例から、I 我々は唯一進めることが示されました キーワードの次の文字に プレーンテキストの文字の場合 isalphaはとても文字です 関数は、ここに便利になるだろう。 そして、ちょうどシーザーのように、私たちがしたいです ケース、isupperとislowerはを保ちます。 だから、この小さなビットを追加 あなたの擬似コードにインチ 

では、どのようにキーのシフトを把握するのですか？ さて、あなたは我々の議論を思い出す場合 シーザーでアルファベット順のインデックスに 問題は、それは非常に似ています。 

Aは、ASCIIに対応しています 65の値が、0のシフト、 そして、最後の手紙 アルファベットで、Z、 25のシフトに対応します。 あなたは、シフトことに気づくでしょう 同一であるか否かを判定する 文字は大文字または小文字です。 

[OK]を、今あなたのこと 把握する方法を知っています 数値シフトこと 単一の文字に対応 私たちの式に戻ってみましょう。 私たちは別の2を持っているので、 ここで添字、iとj、 それは我々がトラックを維持したいのヒントです 平文での当社の立場の両方の 同様に、キーワードでの我々の立場として、 ので、これらは、2つの別々の変数であります 我々はのホールドを維持したいということ。 

私たちの平文で今、位置 毎回を増加しようとしています、 そのためには、になるだろう もう少しまっすぐ進みます 位置キーワードとは対照的に、 私たちは知っているが一周しなければならず、 そして時にはインクリメント、 時々同じまま。 だから、どのように実装しますか 機能性 包み込むします キーワードのインデックス？ 

私はオフ数える例を使用するつもりです。 オフ数えるのは一般的な方法です グループに人々を分割します。 私は5人を持っていたし、私が望んでいたと言います 三つのグループにそれらを分割し、 よく、私はオフにカウントすることにより開始します。 最初の人だろう 、私はチームのナンバーワンだと言います 次の人は、チーム数になります 2、三人のチーム番号 三。 今、私はそのように三つのグループにしたいです 四人は、実際に希望 初めに開始し、言います、 よく、私もチームのナンバーワンです、 そして次の人 チーム番号2になります。 そして、そこから、彼らはその後、缶 彼らのグループに分けます。 

だから、どのように私は剰余を使用する場合があります 私は実装を支援します これは、関数の周りにラップをオフに数えますか？ さて、最初の人 番号1、MOD 3は私たちに1を与えます。 2のmod 3は、私たちに2を与えます そして3のmod 3は私たちに0を与えます。 

四人、数4、モッズ3 私たちに1を与え、その後、5 MOD 3は私たちに2を与えます。 だから、あなたもかかわらず、ことがわかります 私が持っている人々の数 増加し、上記で 3、私は3によって改造てるので、 私はいつも数字0、1、および2を取得します。 私は3よりも大きくなることはありません。 それでは、私は10を持っていた場合でも、 その後、人々、それらの人々のすべて まだグループ1、2、または0の範囲内であろう。 

だから、今、私たちは知っている私たちは、グループがある場合 、5の我々は3によってそれらのすべてをMOD その後、我々はするつもりはありませんしています グループ0、1、または2を超えます。 だから、私たちはグループを取得するつもりはありませんしています 3以上に等しいです数。 だから、私は5以上を追加する場合でも、 その後、人々、それらのすべて まだグループに割り当てられることになります 0、1、または2、私は3によって改造だから。 私はその上限を超えて行くことはありませんよ。 

[OK]を、私たちが適用できるかどうかを見てみましょう モジュロを使用するこの概念 包み込むします グループ番号と適用 私たちが望むどこにvigenereします ラップアラウンドする剰余を使用します キーワードのインデックス。 我々はインクリメントしているにもかかわらず インデックスは常に我々 必ず私たちは常にことにしたいです 非常に先頭にラップアラウンド 超えることはありません 文字列の長さ。 

[OK]をので、私はそれがあるかもしれない知っています 少し圧倒。 このp個のセットで行うことが、より多くのがあります。 だから、あなたが書くことを確認してください あなた自身のために良い擬似コード あなたが理解していることと、 それは仕事を取得します。 試してみて、すべての対処 独立して単一行 すべての少しを考え出します パズルの小片 一緒にそれを置く前に。 

あなたが得ることができることを確認します コマンドラインからキー そして、それはアルファベットだことを確認してください ユーザーからのプレーンテキストを取得し、 そしてその後、暗号化には、あなたのことを確認してください 単一の文字を暗号化する方法を知っています、 そしてその後、文字列全体に進行 機能ラップアラウンドのすべてと。 最後に、暗号文を印刷することができます。 

私の名前は、Zamylaです これはvigenereました。 