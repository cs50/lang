1
00:00:00,000 --> 00:00:00,930

2
00:00:00,930 --> 00:00:04,030
>> Zamylaチャン：私たちのステップアップしてみましょう
ヴィジュネル暗号との試合。

3
00:00:04,030 --> 00:00:06,710
ヴィジュネル暗号です
シーザーと非常に似て、

4
00:00:06,710 --> 00:00:11,060
シーザーを除いて、我々は、渡されました
私たちのキーとして単一の整数。

5
00:00:11,060 --> 00:00:14,100
vigenereにおいて、我々はつもりです
キーワードに渡します。

6
00:00:14,100 --> 00:00:19,400
だから、私はシフトしたい場合
これはohaiによりCS 50である暗号文、

7
00:00:19,400 --> 00:00:23,260
そして、それは内の各文字のことを意味し
ohaiはキーとして機能するように起こっています、

8
00:00:23,260 --> 00:00:27,160
そして、私は以上のサイクルに行きますよ
私のシフトのために、そのキーワード

9
00:00:27,160 --> 00:00:31,930
暗号文を作ります
復号化する多くの困難。

10
00:00:31,930 --> 00:00:34,540
>> それはに何を意味します
キーワードによるシフト？

11
00:00:34,540 --> 00:00:38,610
まあ、キーワードが文字列であります
ここで、すべての文字が対応

12
00:00:38,610 --> 00:00:41,080
いくつかの整数シフトに。

13
00:00:41,080 --> 00:00:49,310
そのように、oは14のキーに対応し、
7のキーの時間は、Aは、0のキーを有します

14
00:00:49,310 --> 00:00:54,670
そのためには、何も変わらないだろう
そして私は8の鍵を持っています。

15
00:00:54,670 --> 00:01:00,000
>> 私はvigenereのAを実行したと言います
プレーンテキストは、これはよくCS50あり、

16
00:01:00,000 --> 00:01:02,800
それは単に与えるだろう
私不変の文字列。

17
00:01:02,800 --> 00:01:08,170
これはと等価であることに注意してください
ゼロのキーでシーザーを実行しています。

18
00:01:08,170 --> 00:01:12,070
実際には、実行中のvigenere
任意の単一文字と

19
00:01:12,070 --> 00:01:17,070
ランニングに相当します
その同じ整数とシーザー。

20
00:01:17,070 --> 00:01:20,400
>> すべての権利、そう、以来、
彼らは私がしたいので、似ています

21
00:01:20,400 --> 00:01:24,300
実際にあなたの場合することをお勧めします
あなたは自分のシーザーをコピーすることができますしたいです

22
00:01:24,300 --> 00:01:26,932
あなたのvigenereコードにコード。

23
00:01:26,932 --> 00:01:28,640
物事は変化します、
しかし、少なくともあなたが持っています

24
00:01:28,640 --> 00:01:31,110
あなたと働くことができるいくつかのバックボーン。

25
00:01:31,110 --> 00:01:36,410
TODOのは、私たちが望む同じであるため
キーを取得するには、プレーンテキストを取得し、

26
00:01:36,410 --> 00:01:40,690
暗号化することプレーンテキスト、
そしてその後、それをプリントアウト。

27
00:01:40,690 --> 00:01:44,980
>> ただ、シーザーのようにキーをしようとしています
第2のコマンドラインとして渡され

28
00:01:44,980 --> 00:01:50,540
argvインデックスに含まれる引数
1が、それが今回は違います

29
00:01:50,540 --> 00:01:52,560
それは、アルファベットでなければなりませんので。

30
00:01:52,560 --> 00:01:56,390
そこで、我々は、すべてを反復処理する必要があります
そのキーで単一の文字

31
00:01:56,390 --> 00:02:00,800
ユーザーが渡されたこと、および確保
すべての文字はアルファベットであること

32
00:02:00,800 --> 00:02:02,800
継続するためです。

33
00:02:02,800 --> 00:02:05,560
>> 私たちは、その後、それをやった後は
ユーザーから文字列を取得することができ、

34
00:02:05,560 --> 00:02:07,560
我々は以前と同じように。

35
00:02:07,560 --> 00:02:10,520
そして今、私たちは心に来ます
vigenereのための問題の、

36
00:02:10,520 --> 00:02:14,665
ちょうどシーザーのようにこれは、どのように
暗号化パターンを把握

37
00:02:14,665 --> 00:02:19,760
と式、および暗号化します
全体の平文。

38
00:02:19,760 --> 00:02:23,280
>> だから、あなたがいることに気づくでしょう
vigenereシフトのための方程式

39
00:02:23,280 --> 00:02:25,610
シーザーの1と非常によく似ています。

40
00:02:25,610 --> 00:02:29,780
唯一の違いは、ということです
代わりに、単一の変数kの

41
00:02:29,780 --> 00:02:37,270
前に、今kは添え字を持って、
鍵のj番目の文字を示します。

42
00:02:37,270 --> 00:02:39,560
>> 例を見てみましょう。

43
00:02:39,560 --> 00:02:43,830
あなたが秘密を渡したいと言います
あなたのクラッシュへのメッセージは、私はあなたが好きです。

44
00:02:43,830 --> 00:02:46,325
さて、あなたのキーのためのあなた
そのあなたの何かを選びます

45
00:02:46,325 --> 00:02:49,790
クラッシュは、あなたが、パンダが好きなことを知っている知っています。

46
00:02:49,790 --> 00:02:52,290
すべての権利、私たちはこれをどのようにシフトしていますか？

47
00:02:52,290 --> 00:02:55,500
>> さて、私たちは平文のインデックスを持っています。

48
00:02:55,500 --> 00:02:59,160
つまり、最初の文字でだと
そのように私たちのキーのインデックスです

49
00:02:59,160 --> 00:03:02,830
これは、pで、最初のものです
私たちのパンダの単語の文字。

50
00:03:02,830 --> 00:03:08,590
だから、pで私をシフトすることは、私たちのx与え、
その後、我々は平文のインデックスを進めます。

51
00:03:08,590 --> 00:03:10,460
これは、スペースに私たちを取得します。

52
00:03:10,460 --> 00:03:13,540
さて、スペース文字
非アルファベットは、

53
00:03:13,540 --> 00:03:16,930
そのためには、ちょうど、そのことを意味します
右の暗号文に渡って転送、

54
00:03:16,930 --> 00:03:23,430
我々はそこにスペースを入れて、我々はしないでください
私たちのキーのインデックスを進めます。

55
00:03:23,430 --> 00:03:25,820
そこで、我々は、この時点でのpではまだです。

56
00:03:25,820 --> 00:03:30,130
>> 私たちは、次へ進みます
私たちの平文のインデックス。

57
00:03:30,130 --> 00:03:34,030
そして今、それがあるため
文字、小文字のL、

58
00:03:34,030 --> 00:03:37,920
我々はによりことをシフト
私たちのキーに次のインデックス。

59
00:03:37,920 --> 00:03:42,360
ゼロである、これであります
シフトだけになるように、

60
00:03:42,360 --> 00:03:44,370
私たちの暗号文でリットル。

61
00:03:44,370 --> 00:03:51,120
その後、我々は平文の両方を進めると、
キーインデックスそれはアルファベットのだから。

62
00:03:51,120 --> 00:03:56,210
それでは、私たちはそれを続けます
私たちは、などに電子を得るまで。

63
00:03:56,210 --> 00:04:01,090
>> あなたはこの時にわかりますので、すべての権利、
当社の主要指標の面で、それを指して、

64
00:04:01,090 --> 00:04:03,940
我々はの終わりに達しました
パンダの言葉なので、どのような

65
00:04:03,940 --> 00:04:08,750
我々は次に行くときに発生
平文でのアルファベット？

66
00:04:08,750 --> 00:04:12,180
まあ、それが起こるすべてが私たちです
先頭にラップアラウンド、

67
00:04:12,180 --> 00:04:14,710
私たちのキーの最初のインデックスへ。

68
00:04:14,710 --> 00:04:19,570
だから、我々はことをシフト
nは私たちを与えるためにPでyの。

69
00:04:19,570 --> 00:04:26,860
そして、私たちは、エンコーディングを終え続けます
私たちの平文は、x lvneの能楽を取得します。

70
00:04:26,860 --> 00:04:29,300
>> この例から、I
我々は唯一進めることが示されました

71
00:04:29,300 --> 00:04:33,140
キーワードの次の文字に
プレーンテキストの文字の場合

72
00:04:33,140 --> 00:04:37,480
isalphaはとても文字です
関数は、ここに便利になるだろう。

73
00:04:37,480 --> 00:04:43,030
そして、ちょうどシーザーのように、私たちがしたいです
ケース、isupperとislowerはを保ちます。

74
00:04:43,030 --> 00:04:46,100
だから、この小さなビットを追加
あなたの擬似コードにインチ

75
00:04:46,100 --> 00:04:48,510
>> では、どのようにキーのシフトを把握するのですか？

76
00:04:48,510 --> 00:04:53,030
さて、あなたは我々の議論を思い出す場合
シーザーでアルファベット順のインデックスに

77
00:04:53,030 --> 00:04:55,370
問題は、それは非常に似ています。

78
00:04:55,370 --> 00:05:01,130
>> Aは、ASCIIに対応しています
65の値が、0のシフト、

79
00:05:01,130 --> 00:05:03,550
そして、最後の手紙
アルファベットで、Z、

80
00:05:03,550 --> 00:05:06,940
25のシフトに対応します。

81
00:05:06,940 --> 00:05:10,320
あなたは、シフトことに気づくでしょう
同一であるか否かを判定する

82
00:05:10,320 --> 00:05:14,880
文字は大文字または小文字です。

83
00:05:14,880 --> 00:05:17,700
>> [OK]を、今あなたのこと
把握する方法を知っています

84
00:05:17,700 --> 00:05:21,470
数値シフトこと
単一の文字に対応

85
00:05:21,470 --> 00:05:24,050
私たちの式に戻ってみましょう。

86
00:05:24,050 --> 00:05:28,180
私たちは別の2を持っているので、
ここで添字、iとj、

87
00:05:28,180 --> 00:05:32,130
それは我々がトラックを維持したいのヒントです
平文での当社の立場の両方の

88
00:05:32,130 --> 00:05:36,600
同様に、キーワードでの我々の立場として、
ので、これらは、2つの別々の変数であります

89
00:05:36,600 --> 00:05:39,010
我々はのホールドを維持したいということ。

90
00:05:39,010 --> 00:05:42,580
>> 私たちの平文で今、位置
毎回を増加しようとしています、

91
00:05:42,580 --> 00:05:45,530
そのためには、になるだろう
もう少しまっすぐ進みます

92
00:05:45,530 --> 00:05:49,750
位置キーワードとは対照的に、
私たちは知っているが一周しなければならず、

93
00:05:49,750 --> 00:05:52,910
そして時にはインクリメント、
時々同じまま。

94
00:05:52,910 --> 00:05:55,430
だから、どのように実装しますか
機能性

95
00:05:55,430 --> 00:05:59,820
包み込むします
キーワードのインデックス？

96
00:05:59,820 --> 00:06:01,640
>> 私はオフ数える例を使用するつもりです。

97
00:06:01,640 --> 00:06:06,100
オフ数えるのは一般的な方法です
グループに人々を分割します。

98
00:06:06,100 --> 00:06:10,660
私は5人を持っていたし、私が望んでいたと言います
三つのグループにそれらを分割し、

99
00:06:10,660 --> 00:06:13,640
よく、私はオフにカウントすることにより開始します。

100
00:06:13,640 --> 00:06:16,980
最初の人だろう
、私はチームのナンバーワンだと言います

101
00:06:16,980 --> 00:06:21,030
次の人は、チーム数になります
2、三人のチーム番号

102
00:06:21,030 --> 00:06:21,910
三。

103
00:06:21,910 --> 00:06:25,910
今、私はそのように三つのグループにしたいです
四人は、実際に希望

104
00:06:25,910 --> 00:06:30,160
初めに開始し、言います、
よく、私もチームのナンバーワンです、

105
00:06:30,160 --> 00:06:32,890
そして次の人
チーム番号2になります。

106
00:06:32,890 --> 00:06:37,660
そして、そこから、彼らはその後、缶
彼らのグループに分けます。

107
00:06:37,660 --> 00:06:41,130
>> だから、どのように私は剰余を使用する場合があります
私は実装を支援します

108
00:06:41,130 --> 00:06:44,160
これは、関数の周りにラップをオフに数えますか？

109
00:06:44,160 --> 00:06:50,140
さて、最初の人
番号1、MOD 3は私たちに1を与えます。

110
00:06:50,140 --> 00:06:54,690
2のmod 3は、私たちに2を与えます
そして3のmod 3は私たちに0を与えます。

111
00:06:54,690 --> 00:07:02,140
>> 四人、数4、モッズ3
私たちに1を与え、その後、5 MOD 3は私たちに2を与えます。

112
00:07:02,140 --> 00:07:05,370
だから、あなたもかかわらず、ことがわかります
私が持っている人々の数

113
00:07:05,370 --> 00:07:11,210
増加し、上記で
3、私は3によって改造てるので、

114
00:07:11,210 --> 00:07:15,250
私はいつも数字0、1、および2を取得します。

115
00:07:15,250 --> 00:07:19,040
私は3よりも大きくなることはありません。

116
00:07:19,040 --> 00:07:22,630
それでは、私は10を持っていた場合でも、
その後、人々、それらの人々のすべて

117
00:07:22,630 --> 00:07:27,430
まだグループ1、2、または0の範囲内であろう。

118
00:07:27,430 --> 00:07:33,560
>> だから、今、私たちは知っている私たちは、グループがある場合
、5の我々は3によってそれらのすべてをMOD

119
00:07:33,560 --> 00:07:38,180
その後、我々はするつもりはありませんしています
グループ0、1、または2を超えます。

120
00:07:38,180 --> 00:07:43,430
だから、私たちはグループを取得するつもりはありませんしています
3以上に等しいです数。

121
00:07:43,430 --> 00:07:46,980
だから、私は5以上を追加する場合でも、
その後、人々、それらのすべて

122
00:07:46,980 --> 00:07:53,150
まだグループに割り当てられることになります
0、1、または2、私は3によって改造だから。

123
00:07:53,150 --> 00:07:56,510
私はその上限を超えて行くことはありませんよ。

124
00:07:56,510 --> 00:08:00,800
>> [OK]を、私たちが適用できるかどうかを見てみましょう
モジュロを使用するこの概念

125
00:08:00,800 --> 00:08:03,710
包み込むします
グループ番号と適用

126
00:08:03,710 --> 00:08:08,000
私たちが望むどこにvigenereします
ラップアラウンドする剰余を使用します

127
00:08:08,000 --> 00:08:10,220
キーワードのインデックス。

128
00:08:10,220 --> 00:08:12,830
我々はインクリメントしているにもかかわらず
インデックスは常に我々

129
00:08:12,830 --> 00:08:17,260
必ず私たちは常にことにしたいです
非常に先頭にラップアラウンド

130
00:08:17,260 --> 00:08:20,050
超えることはありません
文字列の長さ。

131
00:08:20,050 --> 00:08:23,510
>> [OK]をので、私はそれがあるかもしれない知っています
少し圧倒。

132
00:08:23,510 --> 00:08:26,670
このp個のセットで行うことが、より多くのがあります。

133
00:08:26,670 --> 00:08:30,050
だから、あなたが書くことを確認してください
あなた自身のために良い擬似コード

134
00:08:30,050 --> 00:08:32,870
あなたが理解していることと、
それは仕事を取得します。

135
00:08:32,870 --> 00:08:35,580
試してみて、すべての対処
独立して単一行

136
00:08:35,580 --> 00:08:38,370
すべての少しを考え出します
パズルの小片

137
00:08:38,370 --> 00:08:40,260
一緒にそれを置く前に。

138
00:08:40,260 --> 00:08:43,110
>> あなたが得ることができることを確認します
コマンドラインからキー

139
00:08:43,110 --> 00:08:46,780
そして、それはアルファベットだことを確認してください
ユーザーからのプレーンテキストを取得し、

140
00:08:46,780 --> 00:08:51,010
そしてその後、暗号化には、あなたのことを確認してください
単一の文字を暗号化する方法を知っています、

141
00:08:51,010 --> 00:08:56,130
そしてその後、文字列全体に進行
機能ラップアラウンドのすべてと。

142
00:08:56,130 --> 00:08:59,610
最後に、暗号文を印刷することができます。

143
00:08:59,610 --> 00:09:04,050
>> 私の名前は、Zamylaです
これはvigenereました。

144
00:09:04,050 --> 00:09:07,757

