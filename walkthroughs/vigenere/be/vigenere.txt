Zamyla Чан: Давайце актывізаваць нашы гульня з Vigenere шыфра. Vigenere шыфр вельмі падобны на Цэзара, акрамя Цэзара мы прайшлі ў адно цэлае, як наш ключ. У Vigenere мы збіраемся перадаць у якасці ключавога слова. Так што, калі б я хацеў, каб зрушыць шифротекста гэта CS 50 ад ohai, то гэта азначае, што кожная літара ў ohai будзе служыць у якасці ключа, і я збіраюся цыклу над што ключавое слова для майго зруху што робіць зашыфраванага значна цяжэй расшыфраваць. 

Што гэта значыць зрух па ключавым слове? Ну, ключавое слова з'яўляецца радком дзе кожная літара адпавядае да некаторага цэлага зруху. Такім чынам, O адпавядае ключу 14, ч да ключа 7, мае ключ ад 0, так што нічога не змяніла б, а затым я ёсць ключ 8. 

Скажам, я пабег Vigenere А з просты тэкст гэта добра CS50, што б проста даць мне нязменную радок. Звярніце ўвагу на тое, што гэта эквівалентна Цэзар працуе з ключом, роўным нулю. На самай справе, бег Vigenere з любым адзінкавым сімвалам будзе эквівалентна запуску Цэзар з тым жа лікам. 

Добра, так, так як яны настолькі падобныя, я б на самай справе рэкамендую, калі вам хочаце, вы можаце проста скапіяваць Цэзар код у код Vigenere. Ўсё будзе мяняцца, але па меншай меры ў вас ёсць некаторыя пазваночнік, што вы можаце працаваць з. Паколькі TODOS такія ж мы хочам каб атрымаць ключ, атрымаць просты тэкст, зашыфроўваць, што звычайны тэкст, а затым раздрукаваць гэта. 

Гэтак жа, як Цэзар ключ збіраецца быць прыняты ў якасці другой каманднага радка аргумент, які змяшчаецца ў індэксе ARGV 1, але гэта па-іншаму на гэты раз таму што яна павінна быць у алфавітным парадку. Такім чынам, мы павінны перабраць кожны адзін знак у гэтым ключы што карыстальнік прайшоў у, а таксама забяспечыць што кожны знак літарны для таго, каб працягнуць. 

Пасля таго, як мы зрабілі гэта, то мы можа атрымаць радок ад карыстальніка, гэтак жа, як мы рабілі раней. І зараз, мы прыходзім да сэрца праблемы для Vigenere, які гэтак жа, як Цэзар, то як да высветліць карціну шыфраванні і раўнанне, і зашыфроўваць ўвесь адкрыты тэкст. 

Такім чынам, вы заўважыце, што Раўнанне для Vigenere зруху вельмі падобны на Цэзара адзін. Адзінае адрозненне складаецца ў тым, што замест адной зменнай да раней, цяпер да мае індэкс, з указаннем -ю літару ключа. 

Давайце разбярэм прыклад. Дапусцім, вы хацелі перадаць сакрэт паведамленне на ваш цісканіна, што ты мне падабаешся. Ну, для вашага ключа, які вы выбраць нешта, што ваш ведаю, цісканіна ведае, што вам падабаецца, панд. Добра, так як мы ссунем гэта? 

Ну, у нас ёсць наш індэкс адкрытага тэксту. Вось у першым лісце і так гэта індэкс для нашага ключа якая знаходзіцца на р, першы літара ў нашым панды слове. Такім чынам, зрушэнне I р дае нам х, Затым мы рухаемся наперад адкрытага тэксту індэкс. Гэта прымушае нас прастору. Цяпер, сімвал прабелу не з'яўляецца алфавітным, так што гэта азначае, што, што якраз перадае прама да шифротекста, мы змяшчаем прастору там, і мы не робім прасоўваць індэкс для нашага ключа. Такім чынам, мы ўсё яшчэ на р у гэтай кропцы. 

Мы перайсці да наступнага Індэкс ў нашым адкрытага тэксту. А цяпер, таму што гэта літара, ніжні рэгістр л, мы пераходзім што да Наступны індэкс ў нашым ключы. Які з'яўляецца, які з'яўляецца нулявым зрух, так што проста становіцца л ў нашым шифротекста. Затым мы рухаемся наперад як адкрыты тэкст, і ключ індэкса, таму што гэта літарны. Такім чынам, мы працягваем, што пакуль мы не атрымаем на электронны адрас у падобным. 

Добра, так што вы ўбачыце ў гэтым паказваюць, што, з пункту гледжання нашага ключавога індэкса, мы дасягнулі канца панда слова, так, што адбываецца, калі мы пяройдзем да наступнага алфавітны літара ў незашыфраваным выглядзе? Ну, усё, што адбываецца, мы абгарнуць вакол пачатку, да першага індэксе нашага ключа. Так, тады мы перамяшчаем, што у р, каб даць нам п. І потым, мы працягваем аддзелачныя кадаваньне наш адкрыты тэкст, каб атрымаць х lvne NOH. 

З гэтага прыкладу, я паказалі, што мы толькі загадзя да наступнай літары ў ключавых словах калі знак у выглядзе звычайнага тэксту гэты ліст так што IsAlpha функцыя спатрэбіцца тут. І, гэтак жа, як у Цэзар, мы хочам захаваць справы, ISUPPER і ISLOWER. Так, дадайце трохі ва ў ваш псевдокоде. 

Так як жа нам высветліць ключавыя зрухі? Ну, калі вы памятаеце нашу дыскусію на літарных індэксаў у Цэзару праблема, гэта вельмі падобна. 

Дзе A адпавядае ASCII значэнне 65, але зрушэнне 0, а затым апошняя літара у алфавіце, Z, адпавядае зруху 25. Вы заўважыце, што зрух ідэнтычная ці не літара ў верхнім рэгістры або ніжнім рэгістры. 

ОК, так што зараз, калі вы ведаюць, як высветліць, колькасны зрух, адпавядае аднаму знаку давайце вернемся да нашага раўнанні. Таму што мы маем два розных індэксы тут, я і J, гэта намёк, што мы хочам, каб сачыць і нашай пазіцыі ў незашыфраваным а таксама нашай пазіцыі ў ключавых словах, так што тыя дзве асобныя зменныя што мы хочам захаваць валоданне. 

Цяпер становішча ў нашым незашыфраваным будзе павялічвацца кожны раз, так што гэта будзе трохі больш прама наперад у адрозненне ад пазіцыі ключавых слоў, які мы ведаем, ёсць абгарнуць вакол, а часам і прырашчэнне, часам застаюцца тымі ж. Такім чынам, як жа мы рэалізуем функцыянальнасць каб абгарнуць вакол Індэкс для ключавога слова? 

Я збіраюся выкарыстоўваць адлічыць прыклад. Адлічваючы з'яўляецца папулярным спосабам каб падзяліць людзей на групы. Скажам, у мяне было 5 чалавек, і я хацеў падзяліць іх на тры групы, ну тады я хацеў бы пачаць з загінаць. Першы чалавек будзе сказаць, што я каманда нумар адзін, наступны чалавек будзе нумар каманды два, трэцяя асоба нумар каманды тры. Зараз, я хачу толькі тры групы так, чацвёрты чалавек будзе на самой справе пачаць з самага пачатку, і кажуць, ну, я каманда нумар адзін, а таксама, і наступны чалавек будзе каманда нумар два. І адтуль, яны могуць падзяляюцца на свае групы. 

Такім чынам, як я мог бы выкарыстаць па модулю каб дапамагчы мне рэалізаваць гэта адлічыць абгарнуць вакол функцыі? Ну, першы чалавек, нумар 1, па модулю 3 дае нам 1. 2 мод 3 дае нам 2, і 3 па модулю 3 дае нам 0. 

Чацвёрты чалавек, нумар 4, мод 3 дае нам 1, а затым 5 мод 3 дае нам 2. Такім чынам, можна заўважыць, што нягледзячы на ​​тое, лік людзей, што ў мяне ёсць павялічваецца, і вышэй 3, так як я модынгу на 3 Я заўсёды атрымліваю колькасці 0, 1 і 2. Я ніколі не атрымліваю больш, чым 3. Такім чынам, нават калі ў мяне было 10 людзі, то ўсе з тых людзей, будзе па-ранейшаму знаходзіцца ў групах 1, 2 ці 0. 

Такім чынам, зараз мы ведаем, што калі мы маем групу 5 і мы мод ўсе тыя, на 3, то мы ніколі не будзем перавышаць групы 0, 1 або 2. Такім чынам, мы ніколі не збіраемся, каб атрымаць групу лік, гэта роўна 3 або вышэй. Такім чынам, нават калі я дадам яшчэ пяць людзі, то ўсе з іх будзе па-ранейшаму быць прызначаныя групам 0, 1 або 2, таму што я модынгу на 3. Я ніколі не будзе перавышаць гэтую крышку. 

ОК, так што давайце паглядзім, калі мы можам прымяніць гэта паняцце выкарыстання па модулю каб абгарнуць вакол нумары груп і прымяніць гэта Vigenere, дзе мы хочам выкарыстоўваць па модулю, каб абгарнуць вакол індэкс па ключавым слове. Нягледзячы на ​​тое, што мы прырашчэннем індэкс мы заўсёды хочаце, каб пераканацца, што мы заўсёды абгарнуць да самага пачатку ніколі не перавышаючы даўжыня радка. 

ОК, так што я ведаю, што гэта можа быць трохі пераважнай. Там вельмі шмат больш, каб зрабіць у гэтым р наборы. Такім чынам, пераканайцеся, што вы пішаце з добры псевдокод для сябе што вы разумееце і што выконвае сваю працу. Паспрабуйце звярнуцца кожны адзінкавая лінія незалежна адзін ад аднаго высветліць усе мала невялікія кавалачкі галаваломкі перш чым пакласці яго разам. 

Пераканайцеся, што вы можаце атрымаць ключ з каманднага радка і пераканайцеся, што гэта алфавітны, атрымаць просты тэкст ад карыстальніка, а затым у шыфраванні, пераканайцеся, што вы ведаюць, як зашыфраваць адну літару, а затым пераходзіце на ўсю радок з усімі абгарнуць вакол функцый. І, нарэшце, вы можаце раздрукаваць шифротекста. 

Мяне клічуць гэта Zamyla, і гэта было Vigenere. 