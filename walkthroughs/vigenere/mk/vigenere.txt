Zamyla Чан: Да се ​​засили нашите игра со шифра на vigenere. шифра на vigenere е многу сличен на Цезар, освен во Цезар го поминавме во еден цел број како што е нашата клуч. Во vigenere ние ќе да се помине во клучен збор. Значи, ако сакав да се префрлат на ciphertext ова е CS 50 од ohai, тогаш тоа значи дека секоја буква ohai се случува да им служи како клуч, а јас ќе одам да се движите повеќе кои клучни зборови за мојата смена изработка на ciphertext Многу е потешко да се декодира. 

Што значи тоа да се промена од страна на клучни зборови? Па, клучниот збор е стринг каде што секоја буква одговара до одреден број смена. Значи, о одговара на клучот на 14, h до копче на 7, односно има клучот на 0, така што нема да се промени ништо, и тогаш ќе има клучна 8. 

Велат дека налетав vigenere A со обичен текст ова е CS50 добро, кои едноставно ќе им даде ме непроменета стринг. Забележете дека ова е еквивалент на Цезар работи со клуч од нула. Всушност, трчање vigenere со секој еден знак ќе биде еднаков на трчање Цезар со истиот број. 

Сите во право, па, бидејќи тие се толку слични што би всушност препорачуваме дека ако сакам само да копирате вашите Цезар код во вашиот vigenere код. Работите ќе се сменат, но барем ќе имаат некои 'рбетот што ќе може да се работи со. Бидејќи Todos се исти сакаме да го добиете клучот, да добијат обичен текст, написвам со Воице дека обичен текст, а потоа печати тоа. 

Исто како Цезар клучот ќе се да се донесе во што вториот командната линија аргумент содржани во индексот argv 1, но тоа е различно ова време поради тоа што мора да биде азбучен. Значи, ние треба да iterate во текот на секој еден лик во тој клуч дека корисникот донесен во, и да се обезбеди дека секој лик е по азбучен ред со цел да се продолжи. 

Откако сме го направиле тоа, тогаш ние може да се добие стринг од корисникот, исто како што беше порано. И сега, ние се дојде до срцето на проблемот за vigenere, што е само како Цезар, како да дознаам модел enciphering и равенка, и написвам со Воице целиот чист текст. 

Значи, ќе се забележи дека Равенката за промена на vigenere е многу слична на онаа на Цезар. Единствената разлика е во тоа што наместо на една променлива k пред, сега k има индекс, што укажува на jth буква на копчето. 

Ајде да одиме преку еден пример. Велат дека си сакал да го помине на тајна порака на вашиот здроби, ми се допаѓаш. Па, за вашиот клуч ќе изберете нешто што вашиот знам здроби знае дека ви се допаѓа, панди. Сите во право, па како да се префрлат ова? 

Па, ние си имаме чист текст индекс. Кој е на првата буква и така е и индексот за нашите клучни кој е во P, првиот збор во нашите панда збор. Значи, јас менувањето од P x ни дава, тогаш ние однапред чист текст индекс. Ова ни добива простор. Сега, ликот простор не е алфабетско, па тоа значи дека, дека само трансфери право во текот на ciphertext, ќе стави простор таму, а ние не унапредување на индексот за нашите клучни. Значи, ние сме се уште на стр во овој момент. 

Ние преминете на следното индекс во нашата чист текст. И сега, бидејќи тоа е писмо, со мали букви l, ние смена дека со Наредниот индекс во нашите клучни. Која е, кој е нула промена, така што само станува на L во нашата ciphertext. Потоа, ние однапред и на чист текст, и клучниот индекс, бидејќи тоа е по азбучен ред. Па тогаш ние продолжуваме дека додека не се добие на е во слично. 

Добро, така што ќе забележите во овој укажуваат дека, во однос на нашите клучни индекс, ние сме стигнале до крајот на панда збор, така што се случува кога ќе се дојде до следното алфабетското писмо во чист текст? Па, сето она што се случува е дека ние навиват на почетокот, првиот индекс од нашите клучни. Па, тогаш префрлат дека Y p за да ни даде n. И тогаш, ние продолжуваме завршувањето на кодирање нашите чист текст за да се добие x lvne Noh. 

Од овој пример, јас Покажавме дека сме само однапред на следната буква во клучен збор ако карактерот во обичен текст е писмо па isalpha функција ќе ни се најде тука. И, исто како и во Цезар, ние сакаме да зачувување на случај, isupper и islower. Значи, да додадете ова малку во во вашиот pseudocode. 

Па, како да дознаам клучните смени? Па, ако се потсетиме на нашата дискусија на азбучен индекси во Цезар проблем, тоа е многу сличен. 

Каде што одговара на ASCII вредност од 65, но промена на 0, а потоа и последната буква во азбуката, Z, одговара на смена од 25 години. Ќе забележите дека промената е идентичен со или без писмото е големи букви или мали букви. 

Добро, па сега дека сте знае како да дознаам нумеричките промена која одговара на еден лик ајде да се вратиме на нашата равенка. Бидејќи имаме две различни индекси тука, i и j, тоа е знак дека ние сакаме да ги пратите на двете нашата позиција во чист текст како и нашата позиција на клучни зборови, Значи тоа се две одделни променливи дека ние сакаме да се задржи одржи на. 

Сега, на позиција во нашиот чист текст ќе се зголеми во секое време, така што ќе биде малку повеќе право напред што е спротивно на позицијата на клучен збор, кои знаеме мора да заврши околу, а понекогаш и зголемување, понекогаш ќе останат исти. Значи, како да се имплементираат функционалноста да се заврши околу Индекс на клучни зборови? 

Одам да се користи одброите пример. Одбројува е популарен начин да се подели луѓето во групи. Да кажам дека имаше 5 луѓе и јас сакав да им се поделат во три групи, и тогаш јас ќе започне со одбројува. Првиот човек би да кажам дека сум тим број еден, следниот лице ќе биде бројот тим две, бројот на тим трето лице три. Сега, јас само сакаат три групи, четвртото лице всушност ќе да започне на почетокот и да каже, добро, јас сум број еден тим, како и, и следниот лице ќе биде тим број два. И од таму, тогаш тие можат да одвои во нивните групи. 

Значи, како може да го користам modulo да ми помогне да се спроведе ова одброите навиват функција? Па, прво лице број 1, 3 МО ни дава 1. 2 3 МО ни дава 2, и 3 МО 3 ни дава 0. 

Четвртото лице, број 4, современи 3 ни дава 1, а потоа 5 мод 3 ни дава 2. Значи, ќе забележите дека и покрај тоа бројот на луѓе кои ги имаат се зголемува, и е над 3, бидејќи јас сум modding од 3 Зошто секогаш се броеви од 0, 1 и 2. Јас никогаш не се поголеми од 3. Па тогаш, дури и ако имав 10 луѓе, тогаш сите тие луѓе сепак, ќе биде во рамките на групите 1, 2, или 0. 

Значи, сега знаеме дека ако ние имаме група на 5 и современи сите оние од 3, тогаш ние никогаш нема да надминува групи 0, 1, или 2. Значи, ние никогаш нема да добие група број кој што е еднакво на 3 или погоре. Значи, дури и ако додадам уште пет луѓе, тогаш сите од нив сепак, ќе бидат доделени на групи 0, 1 или 2, бидејќи јас сум modding од 3. Јас никогаш нема да биде поголем од капа. 

Добро, па ајде да видиме дали можеме да се применуваат овој концепт на користење modulo да се заврши околу бројките од групата и да ги применуваат да vigenere каде што сакаме да се користи modulo да се заврши околу индексот за клучниот збор. И покрај тоа што ние сме ја зголемува индексот ние секогаш сакате да бидете сигурни дека ние секогаш навиват на самиот почеток никогаш не надминуваат должината на стрингот. 

Добро, така што знам дека тоа би можело да биде малку преголема. Има многу повеќе да се направи во оваа стр сет. Значи, бидете сигурни дека ќе напише добра pseudocode за себе дека ќе се разбере и кои се на работа. Обидете се и да ги реши сите една линија на независно пронајдат сите мали мали парчиња од сложувалката пред тоа ставање заедно. 

Бидете сигурни дека ќе може да се добие клучот од командната линија и да се обезбеди дека тоа е алфабетско, се обичен текст од страна на корисникот, а потоа и во enciphering, погрижете се да знаат како да шифрирање една буква, а потоа напредокот на цела низа со сите навиват функции. Конечно, можете да печатите на ciphertext. 

Моето име е Zamyla, и тоа беше vigenere. 