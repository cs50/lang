1
00:00:00,000 --> 00:00:00,930

2
00:00:00,930 --> 00:00:04,030
>> Zamyla Чан: Да се ​​засили нашите
игра со шифра на vigenere.

3
00:00:04,030 --> 00:00:06,710
шифра на vigenere е
многу сличен на Цезар,

4
00:00:06,710 --> 00:00:11,060
освен во Цезар го поминавме во
еден цел број како што е нашата клуч.

5
00:00:11,060 --> 00:00:14,100
Во vigenere ние ќе
да се помине во клучен збор.

6
00:00:14,100 --> 00:00:19,400
Значи, ако сакав да се префрлат на
ciphertext ова е CS 50 од ohai,

7
00:00:19,400 --> 00:00:23,260
тогаш тоа значи дека секоја буква
ohai се случува да им служи како клуч,

8
00:00:23,260 --> 00:00:27,160
а јас ќе одам да се движите повеќе
кои клучни зборови за мојата смена

9
00:00:27,160 --> 00:00:31,930
изработка на ciphertext
Многу е потешко да се декодира.

10
00:00:31,930 --> 00:00:34,540
>> Што значи тоа да се
промена од страна на клучни зборови?

11
00:00:34,540 --> 00:00:38,610
Па, клучниот збор е стринг
каде што секоја буква одговара

12
00:00:38,610 --> 00:00:41,080
до одреден број смена.

13
00:00:41,080 --> 00:00:49,310
Значи, о одговара на клучот на 14,
h до копче на 7, односно има клучот на 0,

14
00:00:49,310 --> 00:00:54,670
така што нема да се промени ништо,
и тогаш ќе има клучна 8.

15
00:00:54,670 --> 00:01:00,000
>> Велат дека налетав vigenere A со
обичен текст ова е CS50 добро,

16
00:01:00,000 --> 00:01:02,800
кои едноставно ќе им даде
ме непроменета стринг.

17
00:01:02,800 --> 00:01:08,170
Забележете дека ова е еквивалент на
Цезар работи со клуч од нула.

18
00:01:08,170 --> 00:01:12,070
Всушност, трчање vigenere
со секој еден знак

19
00:01:12,070 --> 00:01:17,070
ќе биде еднаков на трчање
Цезар со истиот број.

20
00:01:17,070 --> 00:01:20,400
>> Сите во право, па, бидејќи
тие се толку слични што би

21
00:01:20,400 --> 00:01:24,300
всушност препорачуваме дека ако
сакам само да копирате вашите Цезар

22
00:01:24,300 --> 00:01:26,932
код во вашиот vigenere код.

23
00:01:26,932 --> 00:01:28,640
Работите ќе се сменат,
но барем ќе имаат

24
00:01:28,640 --> 00:01:31,110
некои 'рбетот што ќе може да се работи со.

25
00:01:31,110 --> 00:01:36,410
Бидејќи Todos се исти сакаме
да го добиете клучот, да добијат обичен текст,

26
00:01:36,410 --> 00:01:40,690
написвам со Воице дека обичен текст,
а потоа печати тоа.

27
00:01:40,690 --> 00:01:44,980
>> Исто како Цезар клучот ќе се
да се донесе во што вториот командната линија

28
00:01:44,980 --> 00:01:50,540
аргумент содржани во индексот argv
1, но тоа е различно ова време

29
00:01:50,540 --> 00:01:52,560
поради тоа што мора да биде азбучен.

30
00:01:52,560 --> 00:01:56,390
Значи, ние треба да iterate во текот на секој
еден лик во тој клуч

31
00:01:56,390 --> 00:02:00,800
дека корисникот донесен во, и да се обезбеди
дека секој лик е по азбучен ред

32
00:02:00,800 --> 00:02:02,800
со цел да се продолжи.

33
00:02:02,800 --> 00:02:05,560
>> Откако сме го направиле тоа, тогаш ние
може да се добие стринг од корисникот,

34
00:02:05,560 --> 00:02:07,560
исто како што беше порано.

35
00:02:07,560 --> 00:02:10,520
И сега, ние се дојде до срцето
на проблемот за vigenere,

36
00:02:10,520 --> 00:02:14,665
што е само како Цезар, како да
дознаам модел enciphering

37
00:02:14,665 --> 00:02:19,760
и равенка, и написвам со Воице
целиот чист текст.

38
00:02:19,760 --> 00:02:23,280
>> Значи, ќе се забележи дека
Равенката за промена на vigenere

39
00:02:23,280 --> 00:02:25,610
е многу слична на онаа на Цезар.

40
00:02:25,610 --> 00:02:29,780
Единствената разлика е во тоа што
наместо на една променлива k

41
00:02:29,780 --> 00:02:37,270
пред, сега k има индекс,
што укажува на jth буква на копчето.

42
00:02:37,270 --> 00:02:39,560
>> Ајде да одиме преку еден пример.

43
00:02:39,560 --> 00:02:43,830
Велат дека си сакал да го помине на тајна
порака на вашиот здроби, ми се допаѓаш.

44
00:02:43,830 --> 00:02:46,325
Па, за вашиот клуч ќе
изберете нешто што вашиот

45
00:02:46,325 --> 00:02:49,790
знам здроби знае дека ви се допаѓа, панди.

46
00:02:49,790 --> 00:02:52,290
Сите во право, па како да се префрлат ова?

47
00:02:52,290 --> 00:02:55,500
>> Па, ние си имаме чист текст индекс.

48
00:02:55,500 --> 00:02:59,160
Кој е на првата буква и
така е и индексот за нашите клучни

49
00:02:59,160 --> 00:03:02,830
кој е во P, првиот
збор во нашите панда збор.

50
00:03:02,830 --> 00:03:08,590
Значи, јас менувањето од P x ни дава,
тогаш ние однапред чист текст индекс.

51
00:03:08,590 --> 00:03:10,460
Ова ни добива простор.

52
00:03:10,460 --> 00:03:13,540
Сега, ликот простор
не е алфабетско,

53
00:03:13,540 --> 00:03:16,930
па тоа значи дека, дека само
трансфери право во текот на ciphertext,

54
00:03:16,930 --> 00:03:23,430
ќе стави простор таму, а ние не
унапредување на индексот за нашите клучни.

55
00:03:23,430 --> 00:03:25,820
Значи, ние сме се уште на стр во овој момент.

56
00:03:25,820 --> 00:03:30,130
>> Ние преминете на следното
индекс во нашата чист текст.

57
00:03:30,130 --> 00:03:34,030
И сега, бидејќи тоа е
писмо, со мали букви l,

58
00:03:34,030 --> 00:03:37,920
ние смена дека со
Наредниот индекс во нашите клучни.

59
00:03:37,920 --> 00:03:42,360
Која е, кој е нула
промена, така што само станува

60
00:03:42,360 --> 00:03:44,370
на L во нашата ciphertext.

61
00:03:44,370 --> 00:03:51,120
Потоа, ние однапред и на чист текст, и
клучниот индекс, бидејќи тоа е по азбучен ред.

62
00:03:51,120 --> 00:03:56,210
Па тогаш ние продолжуваме дека
додека не се добие на е во слично.

63
00:03:56,210 --> 00:04:01,090
>> Добро, така што ќе забележите во овој
укажуваат дека, во однос на нашите клучни индекс,

64
00:04:01,090 --> 00:04:03,940
ние сме стигнале до крајот на
панда збор, така што

65
00:04:03,940 --> 00:04:08,750
се случува кога ќе се дојде до следното
алфабетското писмо во чист текст?

66
00:04:08,750 --> 00:04:12,180
Па, сето она што се случува е дека ние
навиват на почетокот,

67
00:04:12,180 --> 00:04:14,710
првиот индекс од нашите клучни.

68
00:04:14,710 --> 00:04:19,570
Па, тогаш префрлат дека
Y p за да ни даде n.

69
00:04:19,570 --> 00:04:26,860
И тогаш, ние продолжуваме завршувањето на кодирање
нашите чист текст за да се добие x lvne Noh.

70
00:04:26,860 --> 00:04:29,300
>> Од овој пример, јас
Покажавме дека сме само однапред

71
00:04:29,300 --> 00:04:33,140
на следната буква во клучен збор
ако карактерот во обичен текст

72
00:04:33,140 --> 00:04:37,480
е писмо па isalpha
функција ќе ни се најде тука.

73
00:04:37,480 --> 00:04:43,030
И, исто како и во Цезар, ние сакаме да
зачувување на случај, isupper и islower.

74
00:04:43,030 --> 00:04:46,100
Значи, да додадете ова малку
во во вашиот pseudocode.

75
00:04:46,100 --> 00:04:48,510
>> Па, како да дознаам клучните смени?

76
00:04:48,510 --> 00:04:53,030
Па, ако се потсетиме на нашата дискусија
на азбучен индекси во Цезар

77
00:04:53,030 --> 00:04:55,370
проблем, тоа е многу сличен.

78
00:04:55,370 --> 00:05:01,130
>> Каде што одговара на ASCII
вредност од 65, но промена на 0,

79
00:05:01,130 --> 00:05:03,550
а потоа и последната буква
во азбуката, Z,

80
00:05:03,550 --> 00:05:06,940
одговара на смена од 25 години.

81
00:05:06,940 --> 00:05:10,320
Ќе забележите дека промената
е идентичен со или без

82
00:05:10,320 --> 00:05:14,880
писмото е големи букви или мали букви.

83
00:05:14,880 --> 00:05:17,700
>> Добро, па сега дека сте
знае како да дознаам

84
00:05:17,700 --> 00:05:21,470
нумеричките промена која
одговара на еден лик

85
00:05:21,470 --> 00:05:24,050
ајде да се вратиме на нашата равенка.

86
00:05:24,050 --> 00:05:28,180
Бидејќи имаме две различни
индекси тука, i и j,

87
00:05:28,180 --> 00:05:32,130
тоа е знак дека ние сакаме да ги пратите
на двете нашата позиција во чист текст

88
00:05:32,130 --> 00:05:36,600
како и нашата позиција на клучни зборови,
Значи тоа се две одделни променливи

89
00:05:36,600 --> 00:05:39,010
дека ние сакаме да се задржи одржи на.

90
00:05:39,010 --> 00:05:42,580
>> Сега, на позиција во нашиот чист текст
ќе се зголеми во секое време,

91
00:05:42,580 --> 00:05:45,530
така што ќе биде
малку повеќе право напред

92
00:05:45,530 --> 00:05:49,750
што е спротивно на позицијата на клучен збор,
кои знаеме мора да заврши околу,

93
00:05:49,750 --> 00:05:52,910
а понекогаш и зголемување,
понекогаш ќе останат исти.

94
00:05:52,910 --> 00:05:55,430
Значи, како да се имплементираат
функционалноста

95
00:05:55,430 --> 00:05:59,820
да се заврши околу
Индекс на клучни зборови?

96
00:05:59,820 --> 00:06:01,640
>> Одам да се користи одброите пример.

97
00:06:01,640 --> 00:06:06,100
Одбројува е популарен начин
да се подели луѓето во групи.

98
00:06:06,100 --> 00:06:10,660
Да кажам дека имаше 5 луѓе и јас сакав да
им се поделат во три групи,

99
00:06:10,660 --> 00:06:13,640
и тогаш јас ќе започне со одбројува.

100
00:06:13,640 --> 00:06:16,980
Првиот човек би
да кажам дека сум тим број еден,

101
00:06:16,980 --> 00:06:21,030
следниот лице ќе биде бројот тим
две, бројот на тим трето лице

102
00:06:21,030 --> 00:06:21,910
три.

103
00:06:21,910 --> 00:06:25,910
Сега, јас само сакаат три групи,
четвртото лице всушност ќе

104
00:06:25,910 --> 00:06:30,160
да започне на почетокот и да каже,
добро, јас сум број еден тим, како и,

105
00:06:30,160 --> 00:06:32,890
и следниот лице
ќе биде тим број два.

106
00:06:32,890 --> 00:06:37,660
И од таму, тогаш тие можат да
одвои во нивните групи.

107
00:06:37,660 --> 00:06:41,130
>> Значи, како може да го користам modulo
да ми помогне да се спроведе

108
00:06:41,130 --> 00:06:44,160
ова одброите навиват функција?

109
00:06:44,160 --> 00:06:50,140
Па, прво лице
број 1, 3 МО ни дава 1.

110
00:06:50,140 --> 00:06:54,690
2 3 МО ни дава 2,
и 3 МО 3 ни дава 0.

111
00:06:54,690 --> 00:07:02,140
>> Четвртото лице, број 4, современи 3
ни дава 1, а потоа 5 мод 3 ни дава 2.

112
00:07:02,140 --> 00:07:05,370
Значи, ќе забележите дека и покрај тоа
бројот на луѓе кои ги имаат

113
00:07:05,370 --> 00:07:11,210
се зголемува, и е над
3, бидејќи јас сум modding од 3

114
00:07:11,210 --> 00:07:15,250
Зошто секогаш се броеви од 0, 1 и 2.

115
00:07:15,250 --> 00:07:19,040
Јас никогаш не се поголеми од 3.

116
00:07:19,040 --> 00:07:22,630
Па тогаш, дури и ако имав 10
луѓе, тогаш сите тие луѓе

117
00:07:22,630 --> 00:07:27,430
сепак, ќе биде во рамките на групите 1, 2, или 0.

118
00:07:27,430 --> 00:07:33,560
>> Значи, сега знаеме дека ако ние имаме група
на 5 и современи сите оние од 3,

119
00:07:33,560 --> 00:07:38,180
тогаш ние никогаш нема да
надминува групи 0, 1, или 2.

120
00:07:38,180 --> 00:07:43,430
Значи, ние никогаш нема да добие група
број кој што е еднакво на 3 или погоре.

121
00:07:43,430 --> 00:07:46,980
Значи, дури и ако додадам уште пет
луѓе, тогаш сите од нив

122
00:07:46,980 --> 00:07:53,150
сепак, ќе бидат доделени на групи
0, 1 или 2, бидејќи јас сум modding од 3.

123
00:07:53,150 --> 00:07:56,510
Јас никогаш нема да биде поголем од капа.

124
00:07:56,510 --> 00:08:00,800
>> Добро, па ајде да видиме дали можеме да се применуваат
овој концепт на користење modulo

125
00:08:00,800 --> 00:08:03,710
да се заврши околу
бројките од групата и да ги применуваат

126
00:08:03,710 --> 00:08:08,000
да vigenere каде што сакаме
да се користи modulo да се заврши околу

127
00:08:08,000 --> 00:08:10,220
индексот за клучниот збор.

128
00:08:10,220 --> 00:08:12,830
И покрај тоа што ние сме ја зголемува
индексот ние секогаш

129
00:08:12,830 --> 00:08:17,260
сакате да бидете сигурни дека ние секогаш
навиват на самиот почеток

130
00:08:17,260 --> 00:08:20,050
никогаш не надминуваат
должината на стрингот.

131
00:08:20,050 --> 00:08:23,510
>> Добро, така што знам дека тоа би можело да биде
малку преголема.

132
00:08:23,510 --> 00:08:26,670
Има многу повеќе да се направи во оваа стр сет.

133
00:08:26,670 --> 00:08:30,050
Значи, бидете сигурни дека ќе напише
добра pseudocode за себе

134
00:08:30,050 --> 00:08:32,870
дека ќе се разбере и
кои се на работа.

135
00:08:32,870 --> 00:08:35,580
Обидете се и да ги реши сите
една линија на независно

136
00:08:35,580 --> 00:08:38,370
пронајдат сите мали
мали парчиња од сложувалката

137
00:08:38,370 --> 00:08:40,260
пред тоа ставање заедно.

138
00:08:40,260 --> 00:08:43,110
>> Бидете сигурни дека ќе може да се добие
клучот од командната линија

139
00:08:43,110 --> 00:08:46,780
и да се обезбеди дека тоа е алфабетско,
се обичен текст од страна на корисникот,

140
00:08:46,780 --> 00:08:51,010
а потоа и во enciphering, погрижете се да
знаат како да шифрирање една буква,

141
00:08:51,010 --> 00:08:56,130
а потоа напредокот на цела низа
со сите навиват функции.

142
00:08:56,130 --> 00:08:59,610
Конечно, можете да печатите на ciphertext.

143
00:08:59,610 --> 00:09:04,050
>> Моето име е Zamyla,
и тоа беше vigenere.

144
00:09:04,050 --> 00:09:07,757

