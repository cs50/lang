Zamyla Chan: მოდით გავაძლიეროთ თამაში vigenere cipher. Vigenere cipher არის ძალიან ჰგავს Caesar, გარდა Caesar ჩვენ გავიდა ერთი რიცხვი, როგორც ჩვენი გასაღები. In vigenere ჩვენ ვაპირებთ კორიდორი სიტყვით. ასე რომ, თუ მინდოდა გადაიტანოს Ciphertext ეს არის CS 50 ohai, მაშინ ეს იმას ნიშნავს, რომ თითოეული წერილი ohai მოემსახურება როგორც გასაღები, და მე ვაპირებ ციკლის მეტი რომ სიტყვით ჩემი ცვლა მიღების ciphertext ბევრი რთული decode. 

რას ნიშნავს, რომ გადაიტანოს მიერ სიტყვით? ასევე, სიტყვით სიმებიანი სადაც ყოველი წერილი შეესაბამება ზოგიერთი რიცხვი ცვლა. ასე რომ, o შეესაბამება გასაღები 14 თ გასაღები 7, აქვს გასაღები, 0, ისე, რომ არაფერი შეიცვლება და მერე აქვს გასაღები 8. 

ამბობენ, რომ მე გაიქცა vigenere ინტერვიუ ძირითადი ტექსტი ეს არის CS50 კარგად, რომ უბრალოდ მისცეს me უცვლელი სიმებიანი. გაითვალისწინეთ, რომ ეს უდრის გაშვებული ცეზარი გასაღები ნულოვანი. ფაქტობრივად, გაშვებული vigenere ნებისმიერი ერთი ხასიათი ტოლფასი იქნებოდა გაშვებული Caesar, რომ იგივე რიცხვი. 

ყველა უფლება, ასე რომ, მას შემდეგ, რაც ისინი იმდენად მსგავსია, რომ მე სინამდვილეში რეკომენდაცია, რომ თუ გსურთ შეგიძლიათ უბრალოდ დააკოპირეთ თქვენი Caesar კოდი თქვენს vigenere კოდი. შეიცვლება, მაგრამ მაინც აქვს ზოგიერთი ხერხემალი რომ თქვენ შეგიძლიათ მუშაობა. იმის გამო, რომ TODOs იგივეა ჩვენ გვინდა მიიღოს გასაღები, მიიღოს ძირითადი ტექსტი, encipher, რომ ძირითადი ტექსტი, და შემდეგ ბეჭდვა, რომ. 

ისევე, როგორც Caesar გასაღები აპირებს ძალაში შევიდა, როგორც მეორე ბრძანების არგუმენტი შეიცავს argv ინდექსი 1, მაგრამ ეს განსხვავებული ამ დროს იმიტომ, რომ ეს უნდა იყოს ანბანური. ასე რომ, ჩვენ უნდა iterate ზე ყოველ ერთი პერსონაჟი, რომ გასაღები რომ მომხმარებელს გავიდა, და უზრუნველყოს, რომ ყველა გმირი არის ანბანურ იმისათვის, რომ გააგრძელოს. 

მას შემდეგ, რაც ჩვენ გავაკეთეთ, მაშინ ჩვენ შეგიძლიათ მიიღოთ სიმებიანი შესახებ, ისევე, როგორც ეს ადრე იყო. და ახლა, ჩვენ მოვიდა გულში ერთი პრობლემა vigenere, რომელიც ისევე, Caesar, თუ როგორ უნდა გაერკვნენ enciphering ნიმუში და განტოლება, და encipher მთელი plaintext. 

ასე რომ, თქვენ შეამჩნევთ, რომ განტოლება vigenere ცვლა ძალიან ჰგავს კეისრის ერთი. ერთადერთი განსხვავება ის არის, რომ ნაცვლად ერთი ცვლადი k ადრე, ახლა k აქვს წარწერის, მითითებით jth წერილი გასაღები. 

მოდით გავლა მაგალითი. ამბობენ, რომ თქვენ სურდა, რომ გაივლის საიდუმლო გაგზავნა გადატანა თქვენი crush, მე მინდა თქვენ. ისე, თქვენი გასაღების აირჩიოს ის, რაც თქვენი ვიცი crush იცის, რომ გსურთ, pandas. ყველა უფლება, ასე რომ, თუ ჩვენ გადაიტანოს ეს? 

ისე, ჩვენ გვაქვს ჩვენი დაუცველი ინდექსი. სწორედ ამ დროს პირველი წერილი და ასე რომ, არის მაჩვენებელი ჩვენი გასაღები რომელიც არის p, პირველი წერილი ჩვენი panda სიტყვა. ასე რომ, გადასვლის I მიერ p გვაძლევს x, მაშინ ჩვენ წინასწარ დაუცველი ინდექსი. ეს იღებს us სივრცეში. ახლა, სივრცის ხასიათი არასამთავრობო ანბანურ, ასე რომ, ეს იმას ნიშნავს, რომ, რომ უბრალოდ გზავნილების უფლება გადასცა ciphertext, ჩვენ სივრცე არსებობს, და ჩვენ არ წინსვლის მაჩვენებელი ჩვენი გასაღები. ასე რომ, ჩვენ ჯერ კიდევ p ამ ეტაპზე. 

ჩვენ წინსვლის შემდეგ ინდექსი ჩვენს plaintext. და ახლა, იმიტომ, რომ წერილი, ამას ლ, ჩვენ გადაეტანა, რომ იმ შემდეგი ინდექსი ჩვენს გასაღები. რა არის, რომელიც არის ნულოვანი ცვლის ისე, რომ უბრალოდ ხდება ლ ჩვენი ciphertext. ამის შემდეგ, ჩვენ წინასწარ, როგორც დაუცველი და ძირითადი ინდექსი იმიტომ, რომ ეს ანბანური. ასე რომ, ჩვენ გაგრძელებას სანამ არ მივიღებთ ელექტრონულ მსგავსად. 

ყველა უფლება, თქვენ შეამჩნევთ ამ აღვნიშნო, რომ, იმ თვალსაზრისით, ჩვენი ძირითადი ინდექსი, ჩვენ მიაღწია ბოლოს პანდა სიტყვა, ასე რომ, ხდება, როდესაც ჩვენ მისაღებად შემდეგი ანბანური წერილი დაუცველი? ისე, რომ ყველა ხდება ჩვენ გადაიტანოთ გარშემო დასაწყისში, პირველი ინდექსი ჩვენი გასაღები. ასე რომ, მაშინ ჩვენ გადაეტანა, რომ y მიერ p მოგვცეს n. და შემდეგ, ჩვენ ვაგრძელებთ დასრულების კოდირების ჩვენი დაუცველი მისაღებად x lvne noh. 

ამ მაგალითად, მე აჩვენა, რომ ჩვენ მხოლოდ წინასწარ შემდეგი წერილი სიტყვით თუ ხასიათი ძირითადი ტექსტი წერილში ასე isalpha ფუნქცია მოვა მოსახერხებელი აქ. და ისევე, როგორც კეისრის, ჩვენ გვინდა შეინარჩუნოს შემთხვევაში, isupper და islower. ასე რომ, დაამატოთ ეს ცოტა in თქვენს pseudocode. 

ასე რომ, ჩვენ გაერკვნენ გასაღები ძვრები? ისე, თუ გავიხსენებთ ჩვენი დისკუსია on ანბანური ინდექსების Caesar პრობლემა, ეს ძალიან ჰგავს. 

სადაც შეესაბამება ASCII ღირებულება 65 მაგრამ ცვლა 0, და შემდეგ ბოლო წერილი ანბანი, Z, შეესაბამება ცვლის 25. თქვენ შეამჩნევთ, რომ ცვლის იდენტურია თუ არა წერილში არის ზედა ან ქვედა შემთხვევაში. 

OK, ასე რომ, ახლა, რომ თქვენ იცით, როგორ უნდა გაერკვნენ რიცხვითი ცვლა, რომ შეესაბამება ერთი ხასიათი მოდით დავუბრუნდეთ ჩვენს განტოლებას. იმიტომ, რომ ჩვენ გვაქვს ორი სხვადასხვა subscripts აქ, i და j, რომ ის მინიშნება, რომ ჩვენ გვინდა, რომ შევინარჩუნოთ სიმღერა როგორც ჩვენი პოზიცია plaintext ისევე, როგორც ჩვენი პოზიცია სიტყვით, ასე რომ, ეს არის ორი ცალკე ცვლადები ჩვენ გვინდა, რომ შევინარჩუნოთ ხელში. 

ახლა, პოზიცია ჩვენი plaintext აპირებს გაზარდოს ყოველ ჯერზე, ასე რომ, ეს იქნება ცოტა მეტი სწორი ნაბიჯია როგორც ეწინააღმდეგებოდა პოზიცია სიტყვით, რომელიც ვიცით გადაიტანოთ გარშემო, და ზოგჯერ წუთობრივი, ზოგჯერ უცვლელი დარჩება. ასე რომ, როგორ განვახორციელოთ ფუნქციონალური გადაიტანოთ გარშემო ინდექსი სიტყვით? 

მე ვაპირებ გამოიყენოთ ითვლიან off მაგალითად. დათვლა off არის პოპულარული გზა ხალხის დაყოფა ჯგუფებად. ვთქვათ მე მქონდა 5 ადამიანი და მინდოდა გაყოფილი მათ სამ ჯგუფად, კარგად, მაშინ მე დაიწყოს დამთვლელი off. პირველი პირი ვთქვა, მე ვარ გუნდის ნომერ, შემდეგი პირი იქნება გუნდის ნომერი ორი, მესამე პირი გუნდის ნომერი სამი. ახლა, მე მხოლოდ მინდა სამი ჯგუფების მეოთხე პირი, ფაქტობრივად, დაიწყება და აცხადებენ, ასევე, მე გუნდის ნომერი ერთი ასევე, და მომდევნო პირი იქნება გუნდის ნომერი ორი. და იქიდან, მათ შეუძლიათ შემდეგ ცალკე თავიანთ ჯგუფებში. 

ასე რომ, როგორ შეიძლება გამოვიყენო modulo რომ დამეხმარება განახორციელოს ეს იმედი off გადატანა გარშემო ფუნქცია? ისე, პირველი პირის ნომერი 1, mod 3 გვაძლევს 1. 2 mod 3 გვაძლევს 2, და 3 mod 3 გვაძლევს 0. 

მეოთხე პირი, 4, mod 3 გვაძლევს 1 და შემდეგ 5 mod 3 გვაძლევს 2. ასე რომ, თქვენ შეამჩნევთ, რომ მიუხედავად იმისა, რომ იმ ადამიანთა რიცხვი, რომ მაქვს იზრდება, და ზემოთ 3, ვინაიდან მე კლუბი 3 მე ყოველთვის ნომრები 0, 1 და 2. მე არასოდეს აღემატება 3. ასე რომ, მაშინაც კი, თუ მქონდა 10 ადამიანი, მაშინ ყველა იმ ხალხს მაინც იყოს ფარგლებში ჯგუფების 1, 2, ან 0. 

ასე რომ, ახლა ჩვენ ვიცით, რომ, თუ ჩვენ გვაქვს ჯგუფი 5 და ჩვენ თავდაცვის სამინისტროს ყველა იმ 3, მაშინ ჩვენ არ აპირებს აღემატებოდეს ჯგუფების 0, 1, ან 2. ასე რომ, ჩვენ არასოდეს აპირებს მიიღოს ჯგუფი ნომერი, რომელიც უდრის 3 ან ზემოთ. ასე რომ, მაშინაც კი, თუ დავამატო კიდევ ხუთი ადამიანი, მაშინ ყველა მათგანი მაინც ჯგუფებს 0, 1, ან 2 იმიტომ, რომ მე კლუბი 3. მე არასდროს უნდა აღემატებოდეს, რომ cap. 

OK, ასე რომ, ვნახოთ, თუ ჩვენ შეუძლია ამ კონცეფციის გამოყენების modulo გადაიტანოთ გარშემო ჯგუფი ნომრები და ვრცელდება მას vigenere სადაც ჩვენ გვინდა გამოიყენოთ modulo გადაიტანოთ გარშემო ინდექსს სიტყვით. მიუხედავად იმისა, რომ ჩვენ დამატება ინდექსის ჩვენ ყოველთვის გვინდა დავრწმუნდეთ, რომ ჩვენ ყოველთვის გადაიტანოთ გარშემო თავიდანვე არასოდეს აღემატება სიგრძეზე სიმებიანი. 

OK, ასე რომ მე ვიცი, ეს შეიძლება იყოს ცოტა გადაჭარბებული. არსებობს კიდევ ბევრი უნდა გააკეთოს ამ P კომპლექტი. ასე რომ, დარწმუნდით, რომ წერთ კარგი pseudocode თავს რომ გესმით და რომ იღებს გაწეული სამუშაო. სცადეთ და მიმართავს ყველა ერთი ხაზი დამოუკიდებლად მჭიდროდაა ყველა პატარა პატარა ცალი თავსატეხი წინაშე აყენებს ერთად. 

დარწმუნდით, რომ თქვენ შეგიძლიათ მიიღოთ გასაღები ბრძანების და უზრუნველყოს, რომ ეს ანბანური, მიიღეთ ჩვეულებრივი ტექსტური შესახებ, და შემდეგ enciphering, დარწმუნდით, რომ თქვენ იცით, თუ როგორ encipher ერთი წერილი, და შემდეგ პროგრესს მთელი სიმებიანი ყველა გადატანა გარშემო ფუნქციები. და ბოლოს, თქვენ შეგიძლიათ ამობეჭდოთ ciphertext. 

ჩემი სახელი არის Zamyla, და ეს იყო vigenere. 