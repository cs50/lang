1
00:00:00,000 --> 00:00:00,930

2
00:00:00,930 --> 00:00:04,030
>> Zamyla 찬 :하자 스텝 업하자 우리
비즈 네르 암호와 게임.

3
00:00:04,030 --> 00:00:06,710
비즈 네르 암호입니다
시저와 매우 유사합니다,

4
00:00:06,710 --> 00:00:11,060
시저를 제외하고 우리가 전달
우리의 키와 하나의 정수입니다.

5
00:00:11,060 --> 00:00:14,100
vigenere에서 우리는거야
키워드에 전달합니다.

6
00:00:14,100 --> 00:00:19,400
내가 원하는 경우 그래서를 이동합니다
이 ohai에서 CS 50 암호문,

7
00:00:19,400 --> 00:00:23,260
그 다음은 각 문자 것을 의미한다
ohai 키 역할을 할 것입니다,

8
00:00:23,260 --> 00:00:27,160
나는 사이클을 통해 갈거야
내 변화에 대한 키워드

9
00:00:27,160 --> 00:00:31,930
암호문을
더 열심히 많이 디코딩합니다.

10
00:00:31,930 --> 00:00:34,540
>> 그것은 무엇을 의미 하는가
키워드에 의해 이동?

11
00:00:34,540 --> 00:00:38,610
음, 키워드는 문자열입니다
여기서 모든 문자에 대응

12
00:00:38,610 --> 00:00:41,080
일부 정수 이동합니다.

13
00:00:41,080 --> 00:00:49,310
따라서, O (14)의 키에 대응
(7)의 키 (H)는 0의 키가

14
00:00:49,310 --> 00:00:54,670
그래서는 아무것도 변하지 않을 것
다음 나는 8의 키가 있습니다.

15
00:00:54,670 --> 00:01:00,000
>> 내가 함께 vigenere A를 실행 말
일반 텍스트이 CS50 잘가,

16
00:01:00,000 --> 00:01:02,800
그것은 단순히 줄 것이다
나 변경되지 않은 문자열입니다.

17
00:01:02,800 --> 00:01:08,170
이 같다는 점을 주목하라
0의 키와 시저를 실행.

18
00:01:08,170 --> 00:01:12,070
사실, 실행 vigenere
단일 문자

19
00:01:12,070 --> 00:01:17,070
실행에 해당 될 것
같은 정수 시저.

20
00:01:17,070 --> 00:01:20,400
>> 좋아, 그래서, 이후
그들은 내가 거라고 매우 유사하다

21
00:01:20,400 --> 00:01:24,300
실제로 것이 좋습니다 경우
당신은 당신의 시저를 복사 할 수 있습니다 원하는

22
00:01:24,300 --> 00:01:26,932
당신의 vigenere 코드로 코드입니다.

23
00:01:26,932 --> 00:01:28,640
상황이 변경됩니다
그러나 적어도, 당신은

24
00:01:28,640 --> 00:01:31,110
당신이 일 수있는 백본.

25
00:01:31,110 --> 00:01:36,410
왜 그렇게 우리가 원하는 동일하기 때문에
키를 얻으려면, 일반 텍스트를 가져,

26
00:01:36,410 --> 00:01:40,690
인사이이 일반 텍스트,
다음이를 인쇄 할 수 있습니다.

27
00:01:40,690 --> 00:01:44,980
>> 그냥 시저 같은 키에 가고
두 번째 명령 줄로 전달

28
00:01:44,980 --> 00:01:50,540
인수는 argv 인덱스에 포함
일이지만 이때 다르다

29
00:01:50,540 --> 00:01:52,560
이 알파벳해야하기 때문이다.

30
00:01:52,560 --> 00:01:56,390
그래서 우리는 모든을 반복 할 필요가
그 키에 하나의 문자

31
00:01:56,390 --> 00:02:00,800
사용자는 전달하고 있는지 확인
모든 문자는 알파벳입니다

32
00:02:00,800 --> 00:02:02,800
계속하려면있다.

33
00:02:02,800 --> 00:02:05,560
>> 우리는 그 다음 것을 수행하면 우리
사용자로부터 문자열을 얻을 수 있습니다,

34
00:02:05,560 --> 00:02:07,560
단지 우리가 전에했던있다.

35
00:02:07,560 --> 00:02:10,520
그리고 지금, 우리는 마음에 와서
vigenere에 대한 문제,

36
00:02:10,520 --> 00:02:14,665
이는 단지 방법 시저처럼
함으로써 암호화 패턴을 알아낼

37
00:02:14,665 --> 00:02:19,760
및 식 및 인사이
전체 일반 텍스트.

38
00:02:19,760 --> 00:02:23,280
>> 그래서, 당신은 있음을 알 수 있습니다
vigenere 변화에 대한 방정식

39
00:02:23,280 --> 00:02:25,610
황제의 것과 매우 유사하다.

40
00:02:25,610 --> 00:02:29,780
유일한 차이점은 있다는
대신 하나의 변수 k의

41
00:02:29,780 --> 00:02:37,270
전에, 지금 k는 첨자를 가지고,
키의 j 번째 편지를 나타낸다.

42
00:02:37,270 --> 00:02:39,560
>> 예제를 통해 살펴 보겠습니다.

43
00:02:39,560 --> 00:02:43,830
당신이 비밀을 전달하고 싶었다 말
당신의 호감 위에 메시지가 당신을 좋아합니다.

44
00:02:43,830 --> 00:02:46,325
음, 키에 대한
무언가를 선택하여

45
00:02:46,325 --> 00:02:49,790
알고 호감은, 팬더를 좋아하는 것을 알고있다.

46
00:02:49,790 --> 00:02:52,290
좋아, 그래서 우리는이 문제를 어떻게 이동합니까?

47
00:02:52,290 --> 00:02:55,500
>> 음, 우리는 우리의 일반 텍스트 색인이 있습니다.

48
00:02:55,500 --> 00:02:59,160
즉 첫 글자로 그리고
그래서 우리의 키에 대한 인덱스이다

49
00:02:59,160 --> 00:03:02,830
이는 P는, 제 1 인
우리의 팬더 단어 문자입니다.

50
00:03:02,830 --> 00:03:08,590
따라서, P에 의해 I를 이동하는 것은 우리 X 준다,
우리는 일반 텍스트 인덱스를 진행합니다.

51
00:03:08,590 --> 00:03:10,460
이 공간에 우리를 가져옵니다.

52
00:03:10,460 --> 00:03:13,540
자, 공백 문자
비 알파벳이며,

53
00:03:13,540 --> 00:03:16,930
그래서 의미, 즉 그 단지
바로 암호문을 통해 전송,

54
00:03:16,930 --> 00:03:23,430
우리는 거기에 공간을두고, 우리는하지 않습니다
우리의 키에 대한 인덱스를 진행합니다.

55
00:03:23,430 --> 00:03:25,820
그래서 우리는이 시점에서 페이지에서 여전히입니다.

56
00:03:25,820 --> 00:03:30,130
>> 우리는 다음 단계로 진행
우리의 일반 텍스트의 인덱스입니다.

57
00:03:30,130 --> 00:03:34,030
그리고 지금은, 때문에
편지, 소문자 리터,

58
00:03:34,030 --> 00:03:37,920
우리는에 의해 그 이동
우리의 키에 다음 인덱스입니다.

59
00:03:37,920 --> 00:03:42,360
이는 제로 인 A는
변화하는 것이 단지가되도록

60
00:03:42,360 --> 00:03:44,370
우리의 암호문의 리터.

61
00:03:44,370 --> 00:03:51,120
그런 다음, 우리는 일반 텍스트를 모두 진행하고,
키 인덱스는 알파벳 때문에.

62
00:03:51,120 --> 00:03:56,210
그래서 우리는 계속
우리는 같은에서 전자에 도달 할 때까지.

63
00:03:56,210 --> 00:04:01,090
>> 이에 알 수 있도록 모든 권리,
우리의 키 인덱스의 측면에서, 그 포인트,

64
00:04:01,090 --> 00:04:03,940
우리의 끝에 도달했습니다
팬더 단어, 그래서 뭐

65
00:04:03,940 --> 00:04:08,750
우리가 다음에 도착할 때 발생
평문에서 알파벳 문자?

66
00:04:08,750 --> 00:04:12,180
음, 어떻게 모든 우리입니다
처음으로 랩 어라운드,

67
00:04:12,180 --> 00:04:14,710
우리의 키의 첫 번째 인덱스에.

68
00:04:14,710 --> 00:04:19,570
그래서, 우리는 것을 이동
P로 y를 우리에게 N을 얻었다.

69
00:04:19,570 --> 00:04:26,860
그리고, 우리는 인코딩을 마무리 계속
우리의 일반 텍스트는 X의 lvne 노를 얻을 수 있습니다.

70
00:04:26,860 --> 00:04:29,300
>> 이 예에서, I
우리는 전진 것으로 나타났다

71
00:04:29,300 --> 00:04:33,140
키워드의 다음 문자로
경우 일반 텍스트 문자

72
00:04:33,140 --> 00:04:37,480
isalpha에 이렇게 편지입니다
함수는 여기에 유용합니다.

73
00:04:37,480 --> 00:04:43,030
그리고, 단지 시저에서, 우리는 원하는
경우, isupper와 islower와 보존.

74
00:04:43,030 --> 00:04:46,100
그래서,이 조금 추가
당신의 의사에있다.

75
00:04:46,100 --> 00:04:48,510
>> 그렇다면 우리는 주요 변화를 알아낼 수 있습니까?

76
00:04:48,510 --> 00:04:53,030
글쎄, 당신은 우리의 논의를 기억하는 경우
황제의 알파벳 인덱스에

77
00:04:53,030 --> 00:04:55,370
문제는, 그것은 매우 유사합니다.

78
00:04:55,370 --> 00:05:01,130
>> A는 ASCII에 해당하는 경우
65의 값하지만 0의 변화,

79
00:05:01,130 --> 00:05:03,550
다음 마지막 편지
알파벳, Z,

80
00:05:03,550 --> 00:05:06,940
25의 변화에​​ 대응한다.

81
00:05:06,940 --> 00:05:10,320
당신은 변화 것을 알 수 있습니다
동일 여부

82
00:05:10,320 --> 00:05:14,880
문자는 대문자 또는 소문자입니다.

83
00:05:14,880 --> 00:05:17,700
>> 좋아, 그럼 이제 그
파악하는 방법을 알고

84
00:05:17,700 --> 00:05:21,470
수치 변화가
하나의 문자에 대응

85
00:05:21,470 --> 00:05:24,050
의 우리 식으로 돌아 가자.

86
00:05:24,050 --> 00:05:28,180
우리가 다른이를 가지고 있기 때문에
여기 첨자, i와 j,

87
00:05:28,180 --> 00:05:32,130
그것은 우리가 추적하고자하는 힌트
일반 텍스트 모두 우리의 위치

88
00:05:32,130 --> 00:05:36,600
뿐만 아니라 키워드에있는 우리의 위치로,
그래서 사람들은 두 개의 별도의 변수는

89
00:05:36,600 --> 00:05:39,010
우리의 보류를 유지하려는 것이다.

90
00:05:39,010 --> 00:05:42,580
>> 우리의 일반 텍스트에서 지금 위치
모든 시간을 증가시킬 것입니다,

91
00:05:42,580 --> 00:05:45,530
그래서이 될 것
좀 더 정직하고

92
00:05:45,530 --> 00:05:49,750
위치 키워드 반대로,
우리가 알고있는 주위에 래핑합니다,

93
00:05:49,750 --> 00:05:52,910
때때로 증가,
때로는 동일하게 유지.

94
00:05:52,910 --> 00:05:55,430
그래서, 우리가 어떻게 구현합니까
기능

95
00:05:55,430 --> 00:05:59,820
주위에 포장하기
키워드에 대한 인덱스?

96
00:05:59,820 --> 00:06:01,640
>> 나는 오프 계산 예제를 사용하는거야.

97
00:06:01,640 --> 00:06:06,100
오프 계산하는 인기있는 방법입니다
그룹으로 사람을 분리합니다.

98
00:06:06,100 --> 00:06:10,660
말 나는 오명을했고 나는 싶었
세 그룹으로 나누어,

99
00:06:10,660 --> 00:06:13,640
그럼 내가 오프 계산하여 시작합니다.

100
00:06:13,640 --> 00:06:16,980
첫 번째 사람 것
나는 팀 번호 사람이야 말

101
00:06:16,980 --> 00:06:21,030
다음 사람은 팀 번호 것
두, 세 번째 사람이 팀 번호

102
00:06:21,030 --> 00:06:21,910
세.

103
00:06:21,910 --> 00:06:25,910
지금, 나는 단지 세 그룹 정도합니다
네 번째 사람은 실제로 것

104
00:06:25,910 --> 00:06:30,160
처음에 시작하고 말하고,
물론, 나뿐만 아니라 팀 번호를 하나 있어요,

105
00:06:30,160 --> 00:06:32,890
그리고 다음 사람
팀의 두 번째 것입니다.

106
00:06:32,890 --> 00:06:37,660
그리고, 거기에서 그들은 다음 수
자신의 그룹으로 구분합니다.

107
00:06:37,660 --> 00:06:41,130
>> 그래서, 어떻게 모듈을 사용할 수 있습니다
저를 구현하는 데 도움이

108
00:06:41,130 --> 00:06:44,160
이 기능의 주위에 랩을 계산?

109
00:06:44,160 --> 00:06:50,140
음, 첫 번째 사람
숫자 1, 모드 3은 우리에게 일을 제공합니다.

110
00:06:50,140 --> 00:06:54,690
2 모드 3은, 우리에게이 있습니다
3 모드 3은 우리에게 공을 준다.

111
00:06:54,690 --> 00:07:02,140
>> 네 번째 사람, 번호 4, 모드 3
우리에게 일을 제공하고 5 모드 3은 우리에게이 있습니다.

112
00:07:02,140 --> 00:07:05,370
그래서, 당신은 비록 것을 알 수 있습니다
내가 가지고있는 사람의 수

113
00:07:05,370 --> 00:07:11,210
증가 시키며, 상기 인
3, 이후 3으로 모딩 해요

114
00:07:11,210 --> 00:07:15,250
난 항상 숫자 0, 1, 2 찾으실 수 있습니다.

115
00:07:15,250 --> 00:07:19,040
나는 3보다 큰 얻을하지 않습니다.

116
00:07:19,040 --> 00:07:22,630
그럼, 나는 10를했다하더라도
다음 사람, 그 사람의 모든

117
00:07:22,630 --> 00:07:27,430
여전히 그룹 1, 2, 또는 0 내에있을 것이다.

118
00:07:27,430 --> 00:07:33,560
>> 그래서, 지금 우리가 알고있는 우리는 그룹이있는 경우
5 중 우리가 3에 의하여 그 모든 모드 (mod),

119
00:07:33,560 --> 00:07:38,180
우리는 결코에 않을거야
그룹 0, 1 또는 2를 초과한다.

120
00:07:38,180 --> 00:07:43,430
그래서, 우리는 결코 그룹을 얻을 않을거야
3 이상 동일의 수입니다.

121
00:07:43,430 --> 00:07:46,980
그래서 나는 다섯을 추가하는 경우에도
다음 사람들, 그들 모두

122
00:07:46,980 --> 00:07:53,150
여전히 그룹에 할당 될
0, 1, 또는 2 나 3으로 모딩 야하기 때문이다.

123
00:07:53,150 --> 00:07:56,510
나는 결코 캡을 초과 않을거야.

124
00:07:56,510 --> 00:08:00,800
>> OK, 우리가 적용 할 수 있는지 보자
모듈 사용의 개념

125
00:08:00,800 --> 00:08:03,710
주위에 포장하기
그룹 번호 및 적용

126
00:08:03,710 --> 00:08:08,000
우리가 원하는 곳은 vigenere하기
주위에 포장 모듈을 사용하는

127
00:08:08,000 --> 00:08:10,220
키워드에 대한 인덱스입니다.

128
00:08:10,220 --> 00:08:12,830
심지어 우리는 증가하고 있지만
인덱스 항상 우리

129
00:08:12,830 --> 00:08:17,260
있는지 항상 우리 것을 확인하려면
맨 처음에 랩 어라운드

130
00:08:17,260 --> 00:08:20,050
결코 초과
문자열의 길이.

131
00:08:20,050 --> 00:08:23,510
>> 좋아, 그럼 나는 수 있습니다 알고
조금 압도적.

132
00:08:23,510 --> 00:08:26,670
이 페이지 설정에서 할 더 많은이있다.

133
00:08:26,670 --> 00:08:30,050
그래서, 당신이 써 있는지 확인
자신에 대한 좋은 의사

134
00:08:30,050 --> 00:08:32,870
당신이 이해하고
그 일을 가져옵니다.

135
00:08:32,870 --> 00:08:35,580
시도하고 모든 주소
단 한 줄의 독립적

136
00:08:35,580 --> 00:08:38,370
알아내는 모든 작은
퍼즐의 작은 조각

137
00:08:38,370 --> 00:08:40,260
함께 퍼팅하기 전에.

138
00:08:40,260 --> 00:08:43,110
>> 당신이 얻을 수 있는지 확인
명령 줄에서 키

139
00:08:43,110 --> 00:08:46,780
그리고,이 알파벳의 보장
사용자에서 일반 텍스트를 가져,

140
00:08:46,780 --> 00:08:51,010
다음 암호화 할, 당신이 있는지를 확인
단일 문자를 암호화하기 방법을 알고,

141
00:08:51,010 --> 00:08:56,130
다음 전체 문자열로 진행
기능의 주위에 랩을 모두와 함께.

142
00:08:56,130 --> 00:08:59,610
마지막으로, 당신은 암호문을 인쇄 할 수 있습니다.

143
00:08:59,610 --> 00:09:04,050
>> 내 이름은 Zamyla입니다
이것은 vigenere했다.

144
00:09:04,050 --> 00:09:07,757

