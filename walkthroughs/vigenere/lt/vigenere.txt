Zamyla Kubilas: Leiskite paspartinti mūsų žaidimas su vigenere šifras. Vigenere šifras yra labai panašus į Cezaris, išskyrus Cezario mes priimtas vienas sveikasis skaičius, nes mūsų raktu. Be vigenere mes ketiname perduoti į raktinį žodį. Taigi, jei aš norėjau perkelti ciphertext tai AP 50 iki ohai, tada tai reiškia, kad kiekvieno rašto ohai ketina tapti raktu, ir aš ruošiuosi ciklo per kad raktažodis mano pamainą priėmimo ciphertext daug sunkiau iššifruoti. 

Ką tai reiškia, kad pereiti prie raktinį žodį? Na, raktinis žodis yra eilutė kur kiekvienas laiškas atitinka tam tikru sveikasis pamainą. Taigi, o atitinka 14 raktu, h iki ne daugiau kaip 7 raktą, yra turi 0 raktą, taip, kad nekeistų nieko, ir tada i turi 8 raktą. 

Pasakykite išbėgau vigenere A su teksto tai CS50 gerai, kad būtų tiesiog duoti man nepakitęs eilutė. Atkreipkite dėmesį, kad tai atitinka veikia Cezaris su nulinės raktu. Tiesą sakant, veikia vigenere su bet kokį vieną simbolį būtų lygiavertis veikia Cezaris su tuo pačiu sveikojo skaičiaus. 

Gerai, taip, nes jie tokie panašūs, aš tikrai rekomenduoju, kad jei norite, galite tiesiog nukopijuoti Cezaris kodą į savo vigenere kodą. Kas pasikeis, bet bent jau turite kai stuburas, kad jūs galite dirbti. Nes Todos yra tokie patys norime gauti raktą, gauti teksto, Zaszyfrować, kad teksto, ir tada spausdinti, kad iš. 

Tiesiog kaip Cezaris raktas ketina būtų perduodama kaip antrasis komandų eilutę argumentas esančius argv indeksą 1, bet tai skirtingi šį kartą nes ji turi būti abėcėlinis. Taigi, mes turime kartoti per kiekvieną vienas simbolis toje raktą , kad vartotojo priimtas, ir užtikrinti, kad kiekvienas personažas yra abėcėlinis siekiant toliau. 

Kai mes padarėme, kad tada mes gali gauti eilutę iš naudotojo, kaip mes anksčiau. Ir dabar, mes prieiname prie širdies iš už vigenere problemos, kuris yra kaip Cezaris, kaip išsiaiškinti šifravimo modelį ir lygtis ir Zaszyfrować visa paprastasis. 

Taigi, jūs pastebėsite, kad lygtis vigenere pamainą yra labai panašus į Cezariu. Vienintelis skirtumas yra tas, kad vietoje vieno kintamojo k anksčiau, dabar K turi apatinis indeksas, nurodant JTH rakto laišką. 

Apžvelkime pavyzdys. Pasakykite, kad norėjo perduoti paslaptį žinutė ant jūsų sutraiškyti, man patinka jums. Na, jūsų rakto Jums pasirinkti kažką, kad jūsų žinoti traiškyti žino, kad jums patinka, panda. Gerai, taip, kaip mes perkelti tai? 

Na, mes turime paprastojo indeksą. Štai pirmajame laiške, ir taip yra mūsų raktas puslapis kuris yra bent P, pirmasis laiškas mūsų Panda žodį. Taigi, aš perjungimo P suteikia mums x tada mes iš anksto paprastojo indeksą. Tai pasireiškia mus į kosmosą. Dabar, tarpas yra ne Abėcėlinis, taip, kad reiškia, kad, kad tik perdavimus per į ciphertext, mes padėkite tarpą ten, ir mes ne anksto mūsų raktas indeksą. Taigi, mes vis dar p šiuo metu. 

Mes iš anksto į kitą rodiklis mūsų paprastojo. Ir dabar, nes tai yra laišką, mažąją l mes pereiti, kad iki Kitas puslapis mūsų raktu. Kuris yra, kuris yra nulis perėjimas, kad tik tampa in mūsų ciphertext l. Tada mes iš anksto tiek paprastojo ir pagrindinis puslapis, nes tai Abėcėlinis. Taigi mes ir toliau, kad kol mes gauti e į pan. 

Visos teisės, todėl jūs pastebėsite, ne tai punktas, kad, kalbant apie mūsų pagrindiniu rodikliu, mes pasiekė pabaigą Panda žodis, tai kas atsitinka, kai mes gauti į kitą Abėcėlinis laiškas į paprastojo? Na, viskas, kas vyksta, mes apvynioti į pradžią, į pirmąjį indeksą mūsų raktu. Taigi, tada mes pereiti, kad Y P mums n. Ir tada, mes ir toliau apdailos koduotę Mūsų paprastasis gauti x lvne Noh. 

Iš šio pavyzdžio, aš parodė, kad mes tik iš anksto į kitą raidę raktinį žodį jei paprasto teksto simbolių yra todėl IsAlpha laiškas funkcija bus naudinga čia. Ir, kaip ir Cezaris, mes norime išsaugoti atveju isupper ir islower. Taigi, pridėkite šį šiek tiek į į jūsų Pseudocode. 

Taigi, kaip mes išsiaiškinti pagrindinius pokyčius? Na, jei jūs prisimenate mūsų diskusiją nuo abėcėlės indeksai Cezaris problema, tai labai panašus. 

Kai atitinka ASCII vertė 65, bet nuo 0 perėjimas, ir tada paskutinė jo raidė abėcėlėje, Z, atitinka 25 d pamainą. Jūs pastebėsite, kad pamainos yra identiškas ar ne laiškas yra didžiosiomis arba mažosiomis raidėmis. 

Gerai, kad dabar, kad jūs žinoti, kaip išsiaiškinti, skaitmeninė perėjimas, kad atitinka vienas simbolis grįžkime prie mūsų lygtį. Kadangi mes turime dvi skirtingas indeksai čia, i ir j, tai užuomina, kad mes norime sekti Abu mūsų padėtį paprastojo taip pat mūsų poziciją raktažodį todėl tiems, yra du atskiri kintamieji kad mes norime saugoti griebtis. 

Dabar, mūsų paprastojo pozicija ketina padidinti kiekvieną kartą, kad ketina būti tiek daugiau tiesiai į priekį o ne pozicijos raktažodis, kurią mes žinome, turi apvynioti, o kartais prieaugio, kartais lieka tos pačios. Taigi, kaip mes įgyvendinti funkcionalumas į kuriuos vyniojami aplink indeksas raktažodį? 

Aš ruošiuosi naudoti tikėtis ne pavyzdys. Skaičiavimas išjungti yra populiarus būdas padalinti žmones į grupes. Pasakykite turėjau 5 žmonės, ir aš norėjau juos padalinti į tris grupes, gerai, tada norėčiau pradėti skaičiuoti išjungtas. Pirmasis asmuo būtų pasakyti, kad esu komanda numeris vienas, kitas asmuo būtų komanda skaičius du, trečiasis asmuo komanda skaičius trys. Dabar, aš tik noriu tris grupes, ketvirtas žmogus iš tikrųjų pradėti iš pradžių ir pasakyti, Na, aš komanda numeris vienas, taip pat, ir kitam asmeniui, Būtų komanda numeris du. Ir iš ten, jie gali atskirti į savo grupes. 

Taigi, kaip galėčiau naudoti modulo padėti man įgyvendinti tai skaičiuoti nuo apvynioti funkcija? Na, pirmas žmogus skaičius 1, mod 3 suteikia mums 1 d. 2 mod 3 suteikia mums 2, ir 3 mod 3 suteikia mums 0. 

Ketvirtasis asmuo, numeris 4, mod 3 suteikia mums 1, ir tada 5 Mod 3 suteikia mums 2. Taigi, jūs pastebėsite, kad nors žmonių skaičius, kad turiu padidina, ir yra didesnis už 3, nes aš modding iš 3 Aš visada gauti skaičiai nuo 0, 1 ir 2. Aš niekada didesnis nei 3. Taigi, net jei aš turėjo 10 žmonių, tada visi iš tų žmonių, vis tiek būtų per 1, 2, arba 0 grupių. 

Taigi, dabar mes žinome, kad jei mes turime grupę 5, ir mes mod visi tie 3, tada mes niekada viršyti grupes 0, 1, arba 2. Taigi, mes niekada gauti grupę numeris, kuris priklauso lygus 3 arba aukščiau. Taigi, net jei aš įdėti penki žmonės, visi iš jų vis tiek priskirti grupėms 0, 1 arba 2, nes aš modding iš 3. Aš niekada viršytų tą dangtelį. 

Gerai, kad galime pamatyti, jei mes galime taikyti ši koncepcija naudojant modulo į kuriuos vyniojami aplink grupė numeriai ir taikyti ji vigenere kur mes norime naudoti modulo wrap aplink už žodį indeksas. Nors mes incrementing indeksas mes visada norite įsitikinti, kad mes visada apvynioti į pačią pradžią niekada viršijamas ilgis eilutę. 

Gerai, kad aš žinau, tai gali būti šiek tiek absoliuti. Yra daug daugiau nuveikti šioje p rinkinys. Taigi, įsitikinkite, kad jums parašyti geras Pseudocode sau kad jums suprasti ir kad gauna darbą. Išbandykite ir spręsti kiekvieną vienos linijos nepriklausomai suprasti, visi mažai maži dėlionės prieš išleidimą kartu. 

Įsitikinkite, kad jūs galite gauti raktas iš komandinės eilutės ir užtikrinti, kad tai Abėcėlinis, gauti paprastą tekstą iš vartotojo, ir tada šifravimo, įsitikinkite, kad jūs žinoti, kaip šifruoti vieną raidę, ir tada pereiti į visą eilutę su visais aplink funkcijų plėvele. Galiausiai, jūs galite spausdinti ciphertext. 

Mano vardas yra Zamyla, ir tai buvo vigenere. 