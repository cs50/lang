Zamyla Чан: Давайте активізувати наші гра з Vigenere шифру. Vigenere шифр дуже схожий на Цезаря, крім Цезаря ми пройшли в одне ціле, як наш ключ. У Vigenere ми збираємося передати в якості ключового слова. Так що, якщо б я хотів, щоб зрушити шифротекста це CS 50 від ohai, то це означає, що кожна буква в ohai служитиме в якості ключа, і я збираюся циклу над що ключове слово для мого зсуву що робить зашифрованого набагато важче розшифрувати. 

Що це означає зрушення за ключовим словом? Ну, ключове слово є рядком де кожна буква відповідає до деякого цілого зсуву. Таким чином, O відповідає ключу 14, ч до ключу 7, має ключ від 0, так що нічого не змінило б, а потім я є ключ 8. 

Скажімо, я побіг Vigenere А з простий текст це добре CS50, що б просто дати мені незмінну рядок. Зверніть увагу на те, що це еквівалентно Цезар працює з ключем, рівним нулю. Насправді, біг Vigenere з будь-яким одиночним символом буде еквівалентно запуску Цезар з тим же числом. 

Добре, так, так як вони настільки схожі, я б насправді рекомендую, якщо вам хочете, ви можете просто скопіювати Цезар код в код Vigenere. Все буде змінюватися, але принаймні у вас є деякі хребет, що ви можете працювати з. Оскільки TODOS такі ж ми хочемо щоб отримати ключ, отримати простий текст, зашифровувати, що звичайний текст, а потім роздрукувати це. 

Так само, як Цезар ключ збирається бути прийнятий в якості другої командного рядка аргумент, що міститься в індексі ARGV 1, але це по-іншому на цей раз тому що вона повинна бути в алфавітному порядку. Таким чином, ми повинні перебрати кожен один символ в цьому ключі що користувач пройшов в, а також забезпечити що кожен символ є літерою для того, щоб продовжити. 

Після того, як ми зробили це, то ми може отримати рядок від користувача, так само, як ми робили раніше. І тепер, ми приходимо до серця проблеми для Vigenere, який так само, як Цезар, то як до з'ясувати картину шифруванні і рівняння, і зашифровувати весь відкритий текст. 

Таким чином, ви помітите, що Рівняння для Vigenere зсуву дуже схожий на Цезаря один. Єдина відмінність полягає в тому, що замість однієї змінної до раніше, тепер до має індекс, із зазначенням -ю букву ключа. 

Давайте розберемо приклад. Припустимо, ви хотіли передати секрет повідомлення на ваш тиснява, що ти мені подобаєшся. Ну, для вашого ключа, який ви вибрати щось, що ваш знаю, тиснява знає, що вам подобається, панд. Добре, так як ми зрушимо це? 

Ну, у нас є наш індекс відкритого тексту. Ось в першому листі і так це індекс для нашого ключа яка знаходиться на р, перший буква в нашому панди слові. Таким чином, зміщення I р дає нам х, Потім ми просуваємося відкритого тексту індекс. Це змушує нас простір. Тепер, символ пробілу не є алфавітним, так що це означає, що, що як раз передає прямо до шифротекста, ми поміщаємо простір там, і ми не робимо просувати індекс для нашого ключа. Таким чином, ми все ще на р в цій точці. 

Ми перейти до наступного Індекс в нашому відкритого тексту. А тепер, тому що це буква, нижній регістр л, ми переходимо що до Наступний індекс в нашому ключі. Який є, який є нульовим зрушення, так що просто стає л в нашому шифротекста. Потім ми просуваємося як відкритий текст, і ключ індексу, тому що це буквений. Отже, ми продовжуємо, що поки ми не отримаємо на електронну адресу в подібному. 

Добре, так що ви побачите в цьому вказують, що, з точки зору нашого ключового індексу, ми досягли кінця панда слово, так, що відбувається, коли ми перейдемо до наступного алфавітний буква в незашифрованому вигляді? Ну, все, що відбувається, ми обернути навколо початку, до першого індексу нашого ключа. Так, тоді ми переміщаємо, що у р, щоб дати нам п. І потім, ми продовжуємо оздоблювальні кодування наш відкритий текст, щоб отримати х lvne NOH. 

З цього прикладу, я показали, що ми тільки заздалегідь до наступної букви в ключових словах якщо символ у вигляді звичайного тексту цей лист так що IsAlpha функція стане в нагоді тут. І, так само, як в Цезарь, ми хочемо зберегти справи, ISUPPER і ISLOWER. Так, додайте трохи в в ваш псевдокоді. 

Так як же нам з'ясувати ключові зрушення? Ну, якщо ви пам'ятаєте нашу дискусію на буквених індексів в Цезарі проблема, це дуже схоже. 

Де A відповідає ASCII значення 65, але зміщення 0, а потім остання буква в алфавіті, Z, відповідає зрушенню 25. Ви помітите, що зрушення ідентична чи ні буква в верхньому регістрі або нижньому регістрі. 

ОК, так що тепер, коли ви знають, як з'ясувати, чисельний зрушення, відповідає одному символу давайте повернемося до нашого рівняння. Тому що ми маємо два різних індекси тут, я і J, це натяк, що ми хочемо, щоб стежити і нашу позицію в незашифрованому а також нашої позиції в ключових словах, так що ті дві окремі змінні що ми хочемо зберегти володіння. 

Тепер становище в нашому незашифрованому буде збільшуватися кожного разу, так що це буде трохи пряміше вперед на відміну від позиції ключових слів, який ми знаємо, є обернути навколо, а іноді і збільшення, іноді залишаються тими ж. Отже, як же ми реалізуємо функціональність щоб обернути навколо Індекс для ключового слова? 

Я збираюся використовувати відрахувати приклад. Відраховуючи є популярним способом щоб розділити людей на групи. Скажімо, у мене було 5 чоловік, і я хотів розділити їх на три групи, ну тоді я хотів би почати з загинати. Перша людина буде сказати, що я команда номер один, наступна людина буде номер команди два, третя особа номер команди три. Тепер, я хочу тільки три групи так, четверта людина буде насправді почати з самого початку, і кажуть, ну, я команда номер один, а також, і наступна людина буде команда номер два. І звідти, вони можуть поділяються на свої групи. 

Отже, як я міг би використовувати по модулю щоб допомогти мені реалізувати це відрахувати обтікати функції? Ну, перша людина, номер 1, по модулю 3 дає нам 1. 2 мод 3 дає нам 2, і 3 по модулю 3 дає нам 0. 

Четверта людина, номер 4, мод 3 дає нам 1, а потім 5 мод 3 дає нам 2. Таким чином, можна помітити, що незважаючи на те, число людей, що у мене є збільшується, і вище 3, так як я моддинга на 3 Я завжди отримую числа 0, 1 і 2. Я ніколи не отримую більше, ніж 3. Отже, навіть якщо у мене було 10 люди, то все з тих людей, буде як і раніше перебувати в групах 1, 2 або 0. 

Отже, тепер ми знаємо, що якщо ми маємо групу 5 і ми мод все ті, на 3, то ми ніколи не будемо перевищувати групи 0, 1 або 2. Таким чином, ми ніколи не збираємося, щоб отримати групу число, це дорівнює 3 або вище. Таким чином, навіть якщо я додам ще п'ять люди, то все з них буде як і раніше бути призначені групам 0, 1 або 2, тому що я моддинга на 3. Я ніколи не буде перевищувати цю кришку. 

ОК, так що давайте подивимося, якщо ми можемо застосувати це поняття використання по модулю щоб обернути навколо номера груп і застосувати це Vigenere, де ми хочемо використовувати по модулю, щоб обернути навколо індекс за ключовим словом. Незважаючи на те, що ми збільшенням індекс ми завжди хочете, щоб переконатися, що ми завжди обтікати до самого початку ніколи не перевищуючи довжина рядка. 

ОК, так що я знаю, що це може бути трохи переважною. Там дуже багато більше, щоб зробити в цьому р наборі. Отже, переконайтеся, що ви пишете з хороший псевдокод для себе що ви розумієте і що виконує свою роботу. Спробуйте звернутися кожен одиночна лінія незалежно один від одного з'ясувати всі мало невеликі шматочки головоломки перш ніж покласти його разом. 

Переконайтеся, що ви можете отримати ключ з командного рядка і переконайтеся, що це алфавітний, отримати простий текст від користувача, а потім в шифруванні, переконайтеся, що ви знають, як зашифрувати одну букву, а потім переходите на всю рядок з усіма обернути навколо функцій. І, нарешті, ви можете роздрукувати шифротекста. 

Мене звуть це Zamyla, і це було Vigenere. 