1
00:00:00,000 --> 00:00:00,500

2
00:00:00,500 --> 00:00:02,640
ZAMYLA chan: ეს არის-me, Zamyla.

3
00:00:02,640 --> 00:00:06,950
დღეს, ჩვენ ვაპირებთ განახორციელოს
Mario, სადაც ჩვენ მიაპყროს Mario

4
00:00:06,950 --> 00:00:10,730
სრული პირამიდის მას ნახტომი მეტი.

5
00:00:10,730 --> 00:00:14,430
მოდით ჩაიშალოს
ქვე-ამოცანები ამ პრობლემას.

6
00:00:14,430 --> 00:00:17,930
>> პირველი, ჩვენ გვინდა უბიძგონ შესახებ
სიმაღლე პირამიდის.

7
00:00:17,930 --> 00:00:20,510
და მაშინ ჩვენ გვინდა დავრწმუნდეთ
რომ შეყვანის მოქმედებს.

8
00:00:20,510 --> 00:00:23,280
და მაშინ ჩვენ ვაპირებთ
მინდა გავამახვილო პირამიდის.

9
00:00:23,280 --> 00:00:26,850
>> ასე რომ, მოდით ვისაუბროთ რითაც
და წევრები მომხმარებლის შეყვანის.

10
00:00:26,850 --> 00:00:29,920
ეს შეიძლება რაღაც
ამ, do- ხოლო მარყუჟის, რომ

11
00:00:29,920 --> 00:00:33,250
თხოვს მომხმარებელს
რიცხვი და შემდეგ მხოლოდ იმეორებს

12
00:00:33,250 --> 00:00:35,700
თუ ეს რიცხვი არასწორია.

13
00:00:35,700 --> 00:00:38,220
რა უნდა ამ მდგომარეობაში უნდა იყოს?

14
00:00:38,220 --> 00:00:40,630
>> ამ, მოდით დავუბრუნდეთ
დაზუსტება.

15
00:00:40,630 --> 00:00:46,240
ისე, სპეც გვეუბნება, რომ ნებისმიერი მოქმედი
სიმაღლე იქნება 0-დან 23,

16
00:00:46,240 --> 00:00:47,350
ჩათვლით.

17
00:00:47,350 --> 00:00:51,400
ასე რომ, გამოდის, რომ ნებისმიერი არასწორი
სიმაღლე იქნება ნაკლები 0

18
00:00:51,400 --> 00:00:53,840
ან მეტი 23.

19
00:00:53,840 --> 00:00:57,220
>> ასე რომ, ახლა რომ ჩვენ გვაქვს ეს ინფორმაცია,
მოდით დიზაინი ჩვენი მდგომარეობა.

20
00:00:57,220 --> 00:00:59,230
მაგრამ ჩვენ უნდა ვიყოთ ფრთხილად,
რადგან ახლა ჩვენ გვაქვს

21
00:00:59,230 --> 00:01:02,130
ორი Booleans, რომ ჩვენ გვინდა შევაფასოთ.

22
00:01:02,130 --> 00:01:04,150
>> აქ მე იმ პირობით, თქვენ
ერთად სიმართლე მაგიდა.

23
00:01:04,150 --> 00:01:07,520
ეს საშუალებას გვაძლევს, რომ ორი
Booleans, ლოგიკური ერთი და ორი.

24
00:01:07,520 --> 00:01:13,600
და ჩვენ შეგვიძლია შევაფასოთ ან bool1
და bool2 ან bool1 ან bool2.

25
00:01:13,600 --> 00:01:17,390
>> ასე რომ, რა არის განსხვავება
შორის და და ან?

26
00:01:17,390 --> 00:01:21,810
ისე, bool1 და bool2 იქნება
შეაფასოს ჭეშმარიტი, თუ და მხოლოდ

27
00:01:21,810 --> 00:01:25,680
თუ ორივე Booleans არის ჭეშმარიტი,
იმის გამო, რომ ან ექსპლუატაციის

28
00:01:25,680 --> 00:01:30,190
იქნება ნამდვილი თუ არც ერთი
Booleans ან ორივე არის ჭეშმარიტი.

29
00:01:30,190 --> 00:01:33,110
ასე რომ, ამ აზრით,
თუ თქვენ შეგიძლიათ გაერკვნენ

30
00:01:33,110 --> 00:01:37,460
რა შესაბამისი პირობა
თქვენი do-loop ხოლო არასწორი n

31
00:01:37,460 --> 00:01:38,850
იქნება.

32
00:01:38,850 --> 00:01:43,540
>> ამასთან, ჩვენ აიძულა და დამტკიცდა
მომხმარებელი სიმაღლე პირამიდის

33
00:01:43,540 --> 00:01:44,550
რომ მათ სურთ.

34
00:01:44,550 --> 00:01:47,740
ასე რომ, ახლა, ეს ჩვენთვის
მიაპყროს პირამიდის.

35
00:01:47,740 --> 00:01:50,520
სრული პირამიდის ამ
პრობლემა გამოიყურება ცოტა

36
00:01:50,520 --> 00:01:56,340
მსგავსი, სადაც ჩვენ გვაქვს მარცხენა პირამიდის,
გარკვეული შეუსაბამობა, და შემდეგ მარჯვენა პირამიდის.

37
00:01:56,340 --> 00:01:58,630
მოდით დაარღვიოს ეს ქვემოთ ცოტა.

38
00:01:58,630 --> 00:02:03,510
>> თუ მე ჩემი ტექსტური რედაქტორი, აქ მე
შედგენილი us მარცხენა სწორებით პირამიდის.

39
00:02:03,510 --> 00:02:05,160
მაგრამ, რომ არ გააკეთებს.

40
00:02:05,160 --> 00:02:10,139
ის, რაც ჩვენ გვსურს რომ არის ჩვენ გვინდა
შექმნა მარჯვენა სწორებით პირამიდის პირველი.

41
00:02:10,139 --> 00:02:13,580
ასე რომ ამის გაკეთება, უბრალოდ დააყენებს
ჩემი ჰეშები გასწვრივ მხარეს,

42
00:02:13,580 --> 00:02:18,240
მე უბრალოდ აპირებს დააყენოს გარკვეული სიმბოლოები
შორის, მხოლოდ ამ წერტილები.

43
00:02:18,240 --> 00:02:22,560
ამის შემდეგ მე ვაპირებ, რომ ბოლო ორი წლის
შემდეგი ხაზი, და ერთი, რომ ხაზი.

44
00:02:22,560 --> 00:02:26,070
ასე რომ, აქ მაქვს
მარჯვენა სწორებით პირამიდის.

45
00:02:26,070 --> 00:02:28,540
>> ამის შემდეგ, მე ვაპირებ
დაბრუნდეს დაბრუნება ზედიზედ

46
00:02:28,540 --> 00:02:33,930
და ამით უფსკრული, რომელიც
არის, თითო სპეც, ორი სივრცეებს.

47
00:02:33,930 --> 00:02:37,680
ამის შემდეგ მე ვაპირებ შევსება
მეორე მხარეს პირამიდის.

48
00:02:37,680 --> 00:02:42,030
მე ვაპირებ წასვლა მეორე რიგის, წერა
ორი ფართების უფსკრული და შემდეგ ორი

49
00:02:42,030 --> 00:02:42,920
ჰეშები.

50
00:02:42,920 --> 00:02:47,020
უკან მესამე რიგის, ორი ფართები
ხარვეზის და სამი ჰეშები.

51
00:02:47,020 --> 00:02:51,480
და ბოლოს, ორი ფართები
ხარვეზის და ოთხი ჰეშები.

52
00:02:51,480 --> 00:02:54,400
ასე რომ, რაც სრული
პირამიდის გამოიყურება.

53
00:02:54,400 --> 00:02:57,260
>> რა თქმა უნდა, ჩვენ არ გვინდა,
ეს წერტილები გზა.

54
00:02:57,260 --> 00:03:01,220
ასე რომ, ჩვენ ვაპირებთ, რომ შეცვალოს ეს
წერტილები აყენებს ზოგიერთი ფართები.

55
00:03:01,220 --> 00:03:03,720
ერთი, ორი, სამი, პირველი ხაზი.

56
00:03:03,720 --> 00:03:05,650
ერთი, ორი მეორე.

57
00:03:05,650 --> 00:03:08,200
და ერთი მესამე ხაზი.

58
00:03:08,200 --> 00:03:12,060
ასე რომ, ეს არის ის, რაც ჩვენ ყველაფერს გააკეთებს, თუ ჩვენ
მინდოდა უბრალოდ მიიღოს სრული პირამიდის,

59
00:03:12,060 --> 00:03:13,700
ამბობენ, ჩვენი ტექსტური რედაქტორი.

60
00:03:13,700 --> 00:03:15,860
>> ასე რომ, მოდით ეს,
გაგება იმ ნიმუშების,

61
00:03:15,860 --> 00:03:19,870
და დააკონვერტიროთ ის მეტი ზოგიერთი pseudocode.

62
00:03:19,870 --> 00:03:24,500
თითოეული ზედიზედ პირამიდის, ჩვენ გვინდა
ბეჭდვა მარცხენა პირამიდის და შემდეგ

63
00:03:24,500 --> 00:03:26,580
უფსკრული და შემდეგ მარჯვენა პირამიდის.

64
00:03:26,580 --> 00:03:30,260
მარცხენა პირამიდის, ჩვენ ბეჭდვა
საჭირო თანხის ფართები,

65
00:03:30,260 --> 00:03:31,740
მოჰყვა ჰეშები.

66
00:03:31,740 --> 00:03:35,030
მაშინ ჩვენ ბეჭდვა უფსკრული, რომელიც
მხოლოდ ორი ფართები ყოველ ჯერზე.

67
00:03:35,030 --> 00:03:38,080
და სწორი პირამიდის, ჩვენ ბეჭდვა
საჭირო რაოდენობის ჰეშები.

68
00:03:38,080 --> 00:03:41,410
>> მეორე რიგის, ჩავატარეთ
ზუსტად იგივე პროცესი.

69
00:03:41,410 --> 00:03:44,510
ჩვენ ბეჭდვა ფართები მარცხენა
პირამიდა, საჭირო თანხა

70
00:03:44,510 --> 00:03:49,930
ჰეშები, უფსკრული, ორი ფართების, და
მაშინ ჰეშები უფლება პირამიდა.

71
00:03:49,930 --> 00:03:52,490
>> მოდით დაძლევის ნიმუში
მარცხენა პირამიდის.

72
00:03:52,490 --> 00:03:55,660
თუ მქონდა, იმ მიზნით,
ამ მაგალითად, სიმაღლე

73
00:03:55,660 --> 00:03:58,790
რვა მიერ მოთხოვნილი
შესახებ, მაშინ ჩემი პირველი რიგის

74
00:03:58,790 --> 00:04:01,020
ექნება ერთი hash და შვიდი სივრცეებს.

75
00:04:01,020 --> 00:04:03,860
ჩემი მეორე რიგის ექნება
ორი ჰეშები, ექვსი ფართები.

76
00:04:03,860 --> 00:04:06,749
მესამე რიგის, სამი ჰეშები, ხუთ ფართები.

77
00:04:06,749 --> 00:04:09,040
თქვენ ალბათ შეუძლია ამის გაკეთება
თავის სიმაღლე რვა

78
00:04:09,040 --> 00:04:13,470
და განსაზღვრავს თითოეული ზედიზედ რამდენი
ჰეშები და რამდენი ფართები გჭირდებათ.

79
00:04:13,470 --> 00:04:16,209
მაგრამ ის, რაც ჩვენ გვინდა გავაკეთოთ არის
ჩვენ გვინდა, რომ აბსტრაქტული იგი.

80
00:04:16,209 --> 00:04:22,660
ასე რომ, გთხოვთ ნებისმიერი nth ზედიზედ რამდენი
ჰეშები და რამდენი ფართები გვჭირდება?

81
00:04:22,660 --> 00:04:25,410
>> ახლა, როგორც თქვენ განსაზღვრავს
ნიმუში რამდენი ჰეშები

82
00:04:25,410 --> 00:04:29,920
და რამდენი ფართები გჭირდებათ
ნებისმიერი nth ზედიზედ მოცემული სიმაღლე,

83
00:04:29,920 --> 00:04:32,910
გვახსოვდეს, რომ ფრთხილად
როგორ თქვენ ინდექსირებას.

84
00:04:32,910 --> 00:04:37,160
რა ნიშნავს ეს, რომ ყოველდღიურ
ცხოვრებაში ყველაზე მეტად ჩვენს დაიწყება დათვლის ერთი.

85
00:04:37,160 --> 00:04:39,680
ასე რომ, პირველი რიგის იქნება ნომერ.

86
00:04:39,680 --> 00:04:43,620
მეორე რიგში იქნება ზედიზედ
ნომერი ორი, და ასე შემდეგ.

87
00:04:43,620 --> 00:04:47,620
>> მაგრამ კომპიუტერულ მეცნიერებათა და
CS50, ჩვენ ნულოვანი ინდექსირებული.

88
00:04:47,620 --> 00:04:50,750
ასე რომ, ჩვენ რეალურად დაიწყოს დათვლის დროს ნულოვანი.

89
00:04:50,750 --> 00:04:54,020
ასე რომ, პირველი რიგის გვინდა
იყოს რიგის ნომერი ნულოვანი.

90
00:04:54,020 --> 00:04:56,640
და მეორე რიგის
იქნება ზედიზედ ნომერ პირველი.

91
00:04:56,640 --> 00:05:02,510
ასე რომ, თუ მე მქონდა სიმაღლე რვა
ჩემი პირამიდის, მაშინ ბოლო ღირებულება N

92
00:05:02,510 --> 00:05:05,850
რეალურად იყოს შვიდი და არა რვა.

93
00:05:05,850 --> 00:05:07,010
>> ასე რომ, ფრთხილად შესახებ.

94
00:05:07,010 --> 00:05:10,750
და უნდა იცოდეს, როდესაც თქვენ განსაზღვრის
თქვენი ნიმუში თუ არა თქვენი ნულოვანი ინდექსირებული

95
00:05:10,750 --> 00:05:12,360
ან ერთი ინდექსირებული

96
00:05:12,360 --> 00:05:13,070
>> კარგი.

97
00:05:13,070 --> 00:05:15,380
ასე რომ, ახლა, რომ ჩვენ გვაქვს
ნიმუში მარცხენა პირამიდის,

98
00:05:15,380 --> 00:05:18,650
ჩვენ გვჭირდება, რათა დადგინდეს
ნიმუში უფსკრული.

99
00:05:18,650 --> 00:05:20,480
საბედნიეროდ, ეს მართლაც მარტივია.

100
00:05:20,480 --> 00:05:22,690
ეს უბრალოდ ყოველთვის ორი სივრცეებს.

101
00:05:22,690 --> 00:05:25,240
>> ასე რომ, ახლა ჩვენ გაგრძელება მარჯვნივ ნიმუში.

102
00:05:25,240 --> 00:05:27,220
პირველ რიგში მოგიწევთ ერთ hash.

103
00:05:27,220 --> 00:05:28,640
მეორე რიგის, ორი.

104
00:05:28,640 --> 00:05:29,530
მესამე რიგის, სამი.

105
00:05:29,530 --> 00:05:30,790
და ასე შემდეგ.

106
00:05:30,790 --> 00:05:35,540
ასე რომ კიდევ ერთხელ, განსაზღვრავს ნებისმიერი აბსტრაქტული
n და ნებისმიერ სიმაღლეზე რამდენი ჰეშები

107
00:05:35,540 --> 00:05:38,810
და რამდენი ფართები
თითოეული ზედიზედ უნდა ჰქონდეს.

108
00:05:38,810 --> 00:05:39,700
>> კარგი.

109
00:05:39,700 --> 00:05:45,050
ჩვენ ვიცით, რომ თითოეული ზედიზედ ჩვენ
უნდა ჩაატაროს გარკვეული პროცესი.

110
00:05:45,050 --> 00:05:46,600
როგორ უნდა გავაკეთოთ, რომ?

111
00:05:46,600 --> 00:05:50,440
ასევე, ჩვენ ვიყენებთ იმ მარყუჟის მშენებლობა,
შედგება ინიციალიზაციისას,

112
00:05:50,440 --> 00:05:52,310
მდგომარეობა, და განახლება.

113
00:05:52,310 --> 00:05:54,830
მარყუჟების შეიძლება იქნას გამოყენებული
გავიმეორო პროცესებში.

114
00:05:54,830 --> 00:05:59,610
>> ასე ვთქვათ, მე მინდა, რომ მიესალმები,
მსოფლიოს 50-ჯერ, მაშინ ჩემი ამისთვის loop

115
00:05:59,610 --> 00:06:03,510
გამოიყურება რაღაც მსგავსი, სადაც
მე ვრთავ ჩემს ცვლადი ნულოვანი.

116
00:06:03,510 --> 00:06:06,200
მდგომარეობა არის, რომ მე ნაკლებია, ვიდრე 50.

117
00:06:06,200 --> 00:06:09,670
და შემდეგ განახლება არის ის, რომ
მდე ერთი ყოველ ჯერზე.

118
00:06:09,670 --> 00:06:14,700
ასე რომ, რა ამ ყველაფერს გააკეთებს იქნება
ბეჭდვა hello, world 50-ჯერ ზედიზედ.

119
00:06:14,700 --> 00:06:18,080
>> ახლა ამბობენ, რომ მინდოდა iterate
მეტი სიმაღლე პირამიდის.

120
00:06:18,080 --> 00:06:21,560
მაშინ ნაცვლად კოდირების
გარკვეული მნიშვნელობა პირობა,

121
00:06:21,560 --> 00:06:23,280
მე უბრალოდ გამოიყენოთ ცვლადი სიმაღლე.

122
00:06:23,280 --> 00:06:27,180
ასე რომ, რა ამ ყველაფერს გააკეთებს iterate
მეტი სიმაღლე თითოეული მწკრივი.

123
00:06:27,180 --> 00:06:30,280
და შემიძლია რაღაც შიგნით
ორგანოს, რომელიც loop.

124
00:06:30,280 --> 00:06:32,710
>> რა გვინდა ჩვენ უნდა გავაკეთოთ
შიგნით ორგანოს მარყუჟის?

125
00:06:32,710 --> 00:06:36,550
ისე, როგორც ჩვენ აღვნიშნეთ, ჩვენ გვინდა
ბეჭდვა ფართები და ჰეშები

126
00:06:36,550 --> 00:06:40,730
მარცხენა პირამიდის და შემდეგ ბეჭდვა
ორი ფართები და შემდეგ ბეჭდვა ჰეშები.

127
00:06:40,730 --> 00:06:42,500
ასე რომ, ჩვენ უკვე figured, რომ.

128
00:06:42,500 --> 00:06:45,670
ასე რომ ჩვენ შეგვიძლია დავიწყოთ შეავსოთ
ჩვენი პროგრამა ბევრი სხვა.

129
00:06:45,670 --> 00:06:49,850
>> აქ მაქვს გარე მარყუჟის რომ
iterates მეტი ყოველ ზედიზედ პირამიდის.

130
00:06:49,850 --> 00:06:53,340
და შიგნით რომ სხეულში მე ვაპირებ
ბეჭდვა ფართები არაერთგზის,

131
00:06:53,340 --> 00:06:56,860
ჰეშები არაერთხელ, და მაშინ უფსკრული,
და მაშინ ჰეშები უფლება პირამიდა,

132
00:06:56,860 --> 00:07:00,440
და მაშინ, საბოლოოდ, ახალი
ხაზი უნდა დაიწყოს მომდევნო ზედიზედ.

133
00:07:00,440 --> 00:07:02,860
>> ამასთან, ჩვენ აიძულა
მომხმარებლის შეყვანის.

134
00:07:02,860 --> 00:07:04,510
ჩვენ დარწმუნებული ვართ, რომ ეს მოქმედებს.

135
00:07:04,510 --> 00:07:06,280
და მაშინ ჩვენ შედგენილი პირამიდის.

136
00:07:06,280 --> 00:07:09,540
ასე რომ, ბენ შეუძლია წარმატებით
ასვლა პირამიდის.

137
00:07:09,540 --> 00:07:10,970
>> ჩემი სახელი არის Zamyla.

138
00:07:10,970 --> 00:07:13,840
და ეს არის CS50.

139
00:07:13,840 --> 00:07:15,419

