ZAMYLA CHAN: זהו-לי, Zamyla. היום, אנחנו הולכים ליישם מריו, שבו אנו מפנים את מריו פירמידה מלאה בשבילו כדי לקפוץ מעל. בואו לשבור את תת משימות עבור בעיה זו. ראשית, אנחנו רוצים להציג למשתמש עבור גובה הפירמידה. ואז אנחנו רוצים לוודא כי קלט כי הוא תקף. ואז אנחנו הולכים רוצה לצייר את הפירמידה. 

אז בואו נדבר על מה שגרם ואימות קלט משתמש. זה עשוי להיראות משהו כמו זה, לולאת while מטלות כי מציג למשתמש עבור חוזר שלם וגם אז רק אם מספר שלם שאינו חוקי. אז מה צריך את המצב הזה להיות? 

לשם כך, בואו נחזור למפרט. ובכן, המפרט אומר לנו שכל חוקי גובה הולך להיות בין 0 ל -23, כָּלוּל. אז זה אומר שכל חוקי גובה הולך להיות פחות מ 0 או יותר מ -23. 

אז עכשיו שיש לנו את המידע הזה, בואו לעצב מצבנו. אבל אנחנו צריכים להיות זהירים, כי עכשיו יש לנו שני Booleans שאנחנו רוצים להעריך. 

כאן סיפקתי לך עם שולחן אמת. זה מאפשר לנו לקחת שני Booleans, בוליאני אחד ושני. ואנחנו יכולים להעריך או bool1 ו bool2 או bool1 או bool2. 

אז מה ההבדל בין לבין ו או? ובכן, bool1 ו bool2 יהיה להעריך כאמת אם ורק אם הן Booleans נכון, ואילו או בהפעלתה יהיה נכון אם של אחד מהם Booleans או שניהם נכונים. אז עם זה בחשבון, לראות אם אתה יכול להבין מה מצבו המתאים הלולאה עשה בזמן שלך עבור n חוקי זה הולך להיות. 

עם זאת, אנו פועלים מתבקשים ומאומתים המשתמש עבור גובה הפירמידה כי הם רוצים. אז עכשיו, זה תלוי בנו לצייר הפירמידה. הפירמידה המלאה לכך בעיה תיראה קצת ככה, יש לנו שם פירמידת שמאל, כמה פער, ולאחר מכן פירמידה תקינה. אז בואו לשבור את זה למטה קצת. 

אם אלך עורך הטקסט שלי, כאן אין לי נמשך לנו פירמידה מזדהה שמאל. אבל זה לא יעשה. מה שאנחנו רוצים לעשות הוא שאנחנו רוצים ליצור פירמידה מיושרת לימין ראשון. אז כדי לעשות את זה, פשוט לדחוף hashes שלי יחד לצד, אני רק הולך לשים כמה תווים בין לבין, רק הנקודות הללו. אז אני הולך לשים שתי על השורה הבאה, ואחד על הקו. אז הנה יש לי מיושר לימין הפירמידה. 

אחרי זה, אני הולך לחזור בשורה העליונה ולשים את הפער, אשר הוא, על פי המפרט, שני חללים. אז אני הולך למלא את הצד השני של הפירמידה. אני הולך ללכת בשורה השנייה, לכתוב שני חללים לפער ולאחר מכן שני hashes. חזרה בשורה השלישית, שני חללים לפער ושלושה אלגוריתמי Hash. ובסוף, שני חללים לפער וארבעה אלגוריתמי Hash. אז זה מה מלא פירמידה תיראה. 

כמובן, אנחנו לא רוצים נקודות אלו בדרך. אז אנחנו הולכים להחליף את אלה נקודות על ידי צבת קצת רווחים. אחת, שתיים, שלוש בשורה הראשונה. אחת, שתיים על השני. ואחד על השורה השלישית. אז זה מה היינו עושים אם אנחנו רציתי רק לעשות פירמידה מלאה, אומרים, בעורך הטקסט שלנו. 

אז בואו ניקח את זה, הבנת הדפוסים, ולהמיר אותו אל כמה פסאודו קוד. עבור כל שורה של הפירמידה, אנחנו רוצים להדפיס הפירמידה שמאלה ואחר כך הפער ואז הפירמידה התקינה. עבור פירמידת השמאל, נדפיס כמות המקומות הנדרשת, ואחריו ה- Hash. אז אנחנו להדפיס את הפער, אשר הוא רק שני מקומות בכל פעם. וגם הפירמידה צודקת, אנחנו להדפיס מספר hashes הנדרש. 

לקבלה בשורה השנייה, ערכנו באותו התהליך המדויק. אנו מדפיסים את החללים לשמאל פירמידה, נחיצות הכמות של Hash, הפער, שני חללים, ו אז ה- Hash עבור הפירמידה התקינה. 

בואו להתמודד הדפוס עבור פירמידת השמאל. אם היה לי, למטרות דוגמה זו, לגובה שמונה מבוקש על ידי משתמשים, אז בשורה הראשונה שלי יצטרך חשיש אחד ושבעה חללים. בשורה השנייה שלי תצטרך שני אלגוריתמים Hash, שישה מקומות. שורה שלישית, שלוש hashes, חמישה מקומות. אתה בטח יכול לעשות את זה עצמך לגובה של שמונה ולקבוע עבור כל שורה כמה hashes וכמה מקומות שאתה צריך. אבל מה שאנחנו רוצים לעשות הוא אנחנו רוצים מופשט זה. אז אני שואל אותך לכל שורה המי יודע כמה, כמה hashes וכמה מקומות אנחנו צריכים? 

עכשיו, כפי שאתה לקבוע את דפוס ולכמה hashes רב וכמה מקומות שאתה צריך בשביל כל שורה המי יודע כמה על גובה נתון, לזכור להיזהר איך אתה לאינדקס. לפי מה שאני אומר זה הוא כי כל יום חיים רובנו מתחילים לספור על ידי אחד. אז בשורה הראשונה תהיה מספר אחת. וגם בשורה השנייה תהיה בשורה מספר שתיים, הלאה וכן הלאה. 

אבל במדעי המחשב CS50, אנחנו אפס צמודים. אז אנחנו בעצם מתחילים לספור על אפס. אז בשורה הראשונה הייתה בשורה להיות מספר אפס. וגם בשורה השנייה יהיה בשורה מספר אחד. אז אם היה לי לגובה של שמונה עבור הפירמידה שלי, אז הערך האחרון של n למעשה יהיה שבע ולא שמונה. 

אז להיות זהירים לגבי זה. ולהיות מודע כשאתה קביעה הדפוס שלך אם אפס צמודות שלך או אחד צמודות 

בסדר. אז עכשיו שיש לנו את דפוס עבור פירמידת השמאל, אנחנו צריכים לקבוע התבנית לפער. למזלנו, זה ממש קל. זה פשוט תמיד שני חללים. 

אז עכשיו נתקדם התבנית הנכונה. השורה הראשונה תהיה חשיש אחד. בשורה השנייה, שני. שורה שלישית, שלוש. כן הלאה וכן הלאה. אז שוב, לקבוע עבור כל מופשטים n וכל בגובה כמה hashes וכמה מקומות צריכה בכל שורה. 

בסדר. כך אנו יודעים כי עבור כל שורה אנחנו צריך לנהל איזה תהליך. איך אנחנו עושים את זה? ובכן, אנו משתמשים עבור מבנה הלולאה, מורכב של אתחול, מצב, ועדכון. לקבלת ניתן להשתמש לולאות לחזור על תהליכים. 

אז להגיד שאני רוצה את זה כדי לומר שלום, 50 פעמים בעולם, אז שלי עבור לולאה היה נראה משהו כזה, שבו אני לאתחל משתנה שלי ירדה לאפס. התנאי הוא כי אני הוא פחות מ -50. ואז העדכון הוא שהיא התוספות אחד בכל פעם. אז מה זה יעשה יהיה להדפיס שלום, עולם 50 פעמים ברציפות. 

עכשיו, נגיד שאני רוצה לחזר על הגובה של הפירמידה. אז במקום קידוד קשה כמה ערך במצבו, אני פשוט להשתמש הגובה המשתנה. אז מה זה יעשה הוא לחזר על הגובה בכל שורה. ואני יכול לעשות משהו בפנים של הגוף של לולאה זה. 

מה אנחנו רוצים לעשות בתוך הגוף של הלולאה? ובכן, כפי שצוין קודם לכן, אנחנו רוצים להדפיס את החללים ואת hashes עבור הפירמידה שמאלה ולאחר מכן הדפסה שני חללים ולאחר מכן להדפיס את אלגוריתמי Hash. אז אנחנו כבר הבנו את זה. אז אנחנו יכולים להתחיל למלא בתוכנית שלנו הרבה יותר. 

כאן יש לי חיצוני עבור לולאה סובב על כל שורה בפירמידה. ובתוך הגוף כי אני הולך להדפיס רווחים שוב ושוב, hashes שוב ושוב, ולאחר מכן את הפער, ואז hashes עבור הפירמידה התקינה, ואז, סוף סוף, חדש בתור כדי להתחיל את השורה הבאה. 

עם זאת, אנו פועלים נתבקש המשתמש עבור הקלט. ביצענו בטוח שזה חוקי. ואז אנחנו שציירנו הפירמידה. אז מריו מצליח לטפס על הפירמידה. 

שמי Zamyla. וזה CS50. 