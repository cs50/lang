1
00:00:00,000 --> 00:00:00,820

2
00:00:00,820 --> 00:00:02,560
>> Zamyla צ'אן: בואו לבדוק את האשראי שלך.

3
00:00:02,560 --> 00:00:06,360
בבעיה זו, נצטרך להציג למשתמש
עבור הזנה של מספר כרטיס אשראי.

4
00:00:06,360 --> 00:00:10,090
אז אנחנו נפעיל שכרטיס האשראי
מספר כדי לראות אם זה חוקי.

5
00:00:10,090 --> 00:00:13,430
אם כן, אנו נדפיס החברה
כי כרטיס האשראי שייך.

6
00:00:13,430 --> 00:00:17,520
אחרת, אנחנו נגיד המשתמש
כי כרטיס זה אינו חוקי.

7
00:00:17,520 --> 00:00:20,210
>> בואו לקפוץ ישר פנימה עם
הצגת בקשת קלט משתמש.

8
00:00:20,210 --> 00:00:23,080
מספר כרטיס האשראי הוא
של long_long סוג הנתונים,

9
00:00:23,080 --> 00:00:27,190
אז פונקצית ספריית CS50
get_long_long יהיה שימושי למדי.

10
00:00:27,190 --> 00:00:30,690
אבל פונקציה זו מבטיחה
המשתמש תשומות כל מספר שלם.

11
00:00:30,690 --> 00:00:34,730
אז כל מספרים שלמים חיוביים, שלילי
מספרים שלמים, או אפס הוא הכל בסדר.

12
00:00:34,730 --> 00:00:37,560
אז תלוי בך כדי נוספים
לאמת אם לאו

13
00:00:37,560 --> 00:00:41,770
המשתמש נתן לנו תקף
מספר סוג כרטיס אשראי.

14
00:00:41,770 --> 00:00:44,560
>> עכשיו שיש לנו כרטיס אשראי
מספר מהמשתמש, ואז

15
00:00:44,560 --> 00:00:46,580
אנחנו צריכים לחשב את הבדיקה.

16
00:00:46,580 --> 00:00:49,780
אז checksums כרטיס אשראי
מחושבים כדלקמן.

17
00:00:49,780 --> 00:00:54,370
החל מ השני כדי הספרה האחרונה,
נכפיל כל ספרה שנייה על ידי 2.

18
00:00:54,370 --> 00:00:57,060
אז נוסיף אלה
מוצרים "ספרות יחד.

19
00:00:57,060 --> 00:01:00,140
מאותו תוסיפו את
סכום הספרות כי

20
00:01:00,140 --> 00:01:03,780
לא הוכפל ב 2 לזה
הסכום קודם כי חשבנו.

21
00:01:03,780 --> 00:01:08,480
לבסוף, אם מספר המסתיים
ב 0, ולאחר מכן את המספר תקף.

22
00:01:08,480 --> 00:01:11,760
>> בואו נעבור דוגמא
ולקחת את זה צעד אחר צעד.

23
00:01:11,760 --> 00:01:14,930
אז הצעד הראשון שלנו הוא להתחיל
מהקומה השנייה עד הספרה האחרונה

24
00:01:14,930 --> 00:01:18,080
ולהתרבות כל ספרה שנייה על ידי שתי.

25
00:01:18,080 --> 00:01:22,240
עכשיו, אם אני מאוחסן בכרטיס האשראי
מספר מספר CC נקרא משתנה,

26
00:01:22,240 --> 00:01:26,060
אז modding שעד 10 היה
תן לי את הספרה האחרונה מאוד.

27
00:01:26,060 --> 00:01:28,910
אז כיצד ניתן לגשת
השני הספרה האחרונה?

28
00:01:28,910 --> 00:01:32,030
>> אוקיי, אז ברגע שאנחנו כבר נצפינו
השני הספרה האחרונה,

29
00:01:32,030 --> 00:01:35,790
אז נצטרך לחזר דרך
הכפלה כל ספרה שנייה על ידי 2.

30
00:01:35,790 --> 00:01:38,620
ברגע שיש לנו את זה, אז
ניקח אותם מוצרים

31
00:01:38,620 --> 00:01:41,350
ולהוסיף ספרות "מוצרים אלה יחד.

32
00:01:41,350 --> 00:01:43,830
אז הנה יש לי אחת
ספרות, אז זה בסדר.

33
00:01:43,830 --> 00:01:47,480
אבל אז ברגע שאגיע שלי האחרון
number-- 7 מוכפל 2--

34
00:01:47,480 --> 00:01:52,080
אני מוסיף את 1 ו -4 לתת לי 27.

35
00:01:52,080 --> 00:01:55,980
משם, נוסיף כי product--
27-- לסכום של ספרות

36
00:01:55,980 --> 00:01:57,790
לא הוכפל ב 2.

37
00:01:57,790 --> 00:02:01,070
>> אז הנה הדגשתי כל
של המספרים האלה בכתום.

38
00:02:01,070 --> 00:02:04,900
ברגע שאנו להוסיף הספרות האלה, אז
אנחנו מקבלים מספר הבדיקה הסופי שלנו.

39
00:02:04,900 --> 00:02:09,120
אז אנחנו לאמת אותו על ידי ביצוע
בטוח כי הספרה האחרונה היא 0.

40
00:02:09,120 --> 00:02:12,635
אם הבדיקה אינה מסתיימת ב
0, ולאחר מכן את מספר כרטיס האשראי

41
00:02:12,635 --> 00:02:14,400
בהחלט אינו חוקי.

42
00:02:14,400 --> 00:02:17,840
אחרת, בואו נלך על מנת
לבדוק את זיהה החברה

43
00:02:17,840 --> 00:02:19,870
ואת אורך מספר כרטיס אשראי.

44
00:02:19,870 --> 00:02:21,830
>> צירפנו רשימה
של שלוש חברות,

45
00:02:21,830 --> 00:02:25,940
יחד עם זאת, המספר של מספרים שלמים
יש כי מספרי כרטיסי האשראי שלהם.

46
00:02:25,940 --> 00:02:29,630
ואז שתי הספרות הראשונות כי
כרטיסים אלה עשויים להתחיל עם.

47
00:02:29,630 --> 00:02:34,070
אז תלוי בך כדי לעקוב אחר
שתי הספרות הראשונות של כרטיס האשראי

48
00:02:34,070 --> 00:02:37,620
ומספר מספרי שלמי כרטיס זה.

49
00:02:37,620 --> 00:02:40,110
ועם זה, יש לך
סיים את הבעיה.

50
00:02:40,110 --> 00:02:44,210
שמי Zamyla, וזה היה אשראי.

51
00:02:44,210 --> 00:02:45,859

