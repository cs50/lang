Zamyla 찬 :의 신용을 확인하자. 이 문제에서 우리는 사용자에게 메시지를 표시합니다 신용 카드 번호의 입력. 그런 다음 우리는 신용 카드를 실행합니다 이 유효 인 경우 번호를 확인합니다. 그렇다면, 우리는 회사를 인쇄 할 수 있습니다 것을 그 신용 카드에 속한다. 그렇지 않으면, 우리는 사용자 말해주지 것을 그 카드가 유효하지 않습니다. 

그럼으로 바로 점프하자 사용자 입력에 대한 프롬프트. 신용 카드 번호는 데이터 유형 long_long의 그래서 CS50 라이브러리 함수 get_long_long은 매우 유용 할 것이다. 그러나이 기능 보장 사용자는 임의의 정수를 입력한다. 그래서 어떤 양의 정수, 음의 정수, 또는 0 모든 괜찮습니다. 최대 당신에게 그래서 더 여부 확인 사용자는 우리에게 유효한 주신 신용 카드 타입 번호. 

우리는 신용 카드가 지금 다음, 사용자로부터 숫자 우리는 체크섬을 계산해야합니다. 그래서 신용 카드 체크 다음과 같이 계산된다. 마지막 숫자 두 번째에서 시작, 우리는 2로 다른 모든 숫자를 곱합니다. 그 다음 우리는 그 추가 함께 제품의 숫자. 우리가를 추가에서 숫자의 합이 그 2를 곱한되지 않았다 우리가 계산 이전의 합계입니다. 마지막으로, 그 숫자는 끝나는 경우 0, 다음 수는 유효합니다. 

예제를 통해 가자 단계로이 단계를 수행. 그래서 우리의 첫 번째 단계는 시작하는 것입니다 마지막 숫자 두 번째에서 두에 의해 다른 모든 숫자를 곱합니다. 지금, 나는 신용 카드를 저장하는 경우 변수라는 CC 번호 번호, 다음 (10)에 의해 그 모딩 것 나에게 매우 마지막 자리를 제공합니다. 그래서 당신은 어떻게 액세스 할 수 있습니다 마지막 숫자 두 번째? 

좋아, 그럼 한 번 우리는 액세스 한 마지막 숫자에 두 번째, 우리는을 통해 반복합니다 (2)에 의해 다른 모든 숫자를 곱하여. 우리는 그 다음 것을 일단 우리는 이러한 제품 할게요 함께 그 제품의 숫자를 추가합니다. 그래서 여기 내가 하나가 자리는, 그래서 괜찮아요. 그러나 나는 나의 마지막에 도착하면 number-- 7 2--를 곱한 나는 하나 추가하고 4는 나에게 27을주고. 거기에서, 우리는 product-- 것을 추가 27-- 숫자의 합에 해당 이 승산되지 않았다. 

그래서 여기에 나는 모든 강조했습니다 오렌지 그 숫자의. 우리가 그 숫자를 추가하면, 다음 우리는 우리의 최종 검사 번호를. 그래서 우리가 만들어 그것을 확인 확실히 마지막 숫자는 0이다. 체크섬에 종료되지 않는 경우 0 후, 신용 카드 번호 확실히 잘못되었습니다. 그렇지 않으면,의가에 가자 회사 ID를 확인 및 신용 카드 번호 길이. 

우리는 목록을 제공 한 세 회사의, 그와 함께, 정수의 수 신용 카드 번호를 가지고있다. 그리고 처음 두 자릿수 그 그 카드로 시작 수 있습니다. 당신까지 추적 할 수 있도록 신용 카드의 처음 두 자릿수 그 카드 정수의 수입니다. 그리고, 당신은했습니다 문제를 마쳤다. 내 이름은 Zamyla이며,이 신용이었다. 