1
00:00:00,000 --> 00:00:00,832
DAVID MALAN: All right.

2
00:00:00,832 --> 00:00:03,748
Well, let's pick up now where we
left off talking a bit more generally

3
00:00:03,748 --> 00:00:06,596
about technology stacks and
topics like frameworks-- which

4
00:00:06,596 --> 00:00:11,370
is a word that came up earlier--
and libraries, and design patterns,

5
00:00:11,370 --> 00:00:16,460
and approaches to building software,
and bring to bear to this conversation

6
00:00:16,460 --> 00:00:20,160
some examples of data
structures and algorithms

7
00:00:20,160 --> 00:00:22,090
that are part of the
programming process,

8
00:00:22,090 --> 00:00:23,950
but for generally part
of problem solving

9
00:00:23,950 --> 00:00:27,910
and are often handed to programmers
these days in the form of libraries.

10
00:00:27,910 --> 00:00:32,689
Indeed one of the other reasons to
use certain languages over others

11
00:00:32,689 --> 00:00:34,670
is that they just come
with more functionality.

12
00:00:34,670 --> 00:00:38,227
For instance, C, the language with
which I wrote Hello World earlier,

13
00:00:38,227 --> 00:00:39,810
does not come with much functionality.

14
00:00:39,810 --> 00:00:41,430
Anything you want that
language to do, you pretty much

15
00:00:41,430 --> 00:00:44,471
have to implement it yourself, which
means writing lots and lots and lots

16
00:00:44,471 --> 00:00:48,590
and lots into code even to implement
something relatively simple,

17
00:00:48,590 --> 00:00:50,920
like web pages, as I alluded to earlier.

18
00:00:50,920 --> 00:00:54,330
But with something like PHP, or Python,
or Ruby, or Java, or other languages,

19
00:00:54,330 --> 00:00:56,820
you have like a kitchen
sink of functionality

20
00:00:56,820 --> 00:01:00,173
that companies like Oracle
or others have given

21
00:01:00,173 --> 00:01:02,420
to you in the form of that language.

22
00:01:02,420 --> 00:01:07,050
That functionality is often packaged
up in something called a library.

23
00:01:07,050 --> 00:01:11,490
A library is just a set of programs,
or really a set of functionality

24
00:01:11,490 --> 00:01:14,710
that someone else has written that
you can integrate into your own work,

25
00:01:14,710 --> 00:01:16,307
so as not to reinvent those wheels.

26
00:01:16,307 --> 00:01:18,390
And indeed, if you think
about it, even though you

27
00:01:18,390 --> 00:01:21,950
might be the only programmer on
a project or on a small team,

28
00:01:21,950 --> 00:01:27,570
you could certainly not have enough
time to build an entire-- not only a web

29
00:01:27,570 --> 00:01:31,890
application, but the web server that
understands HTTP and spits that out,

30
00:01:31,890 --> 00:01:35,430
let alone the device drivers that I had
been talking about at this lower level

31
00:01:35,430 --> 00:01:36,112
earlier.

32
00:01:36,112 --> 00:01:37,820
And so you want to
stand on the shoulders

33
00:01:37,820 --> 00:01:38,870
of people that have come before you.

34
00:01:38,870 --> 00:01:41,286
And thankfully, especially
thanks to open source software,

35
00:01:41,286 --> 00:01:43,960
there's a huge community of
freely available software

36
00:01:43,960 --> 00:01:45,340
that helps people solve problems.

37
00:01:45,340 --> 00:01:47,798
And let's consider one of the
simplest problems first using

38
00:01:47,798 --> 00:01:50,240
one of the simplest
data structures, whereby

39
00:01:50,240 --> 00:01:57,050
data structure is a way of organizing
data inside your computer's memory.

40
00:01:57,050 --> 00:02:01,140
So you can think of your computer's
memory, for instance, this,

41
00:02:01,140 --> 00:02:04,530
as-- and let's pull up a picture.

42
00:02:04,530 --> 00:02:05,550
RAM DIMM.

43
00:02:05,550 --> 00:02:08,001
A dual in-line memory module.

44
00:02:08,001 --> 00:02:10,250
It's something that looks a
little something like this

45
00:02:10,250 --> 00:02:13,515
and-- Okay, it doesn't look like
that, but might as well, perhaps.

46
00:02:13,515 --> 00:02:16,390


47
00:02:16,390 --> 00:02:18,810
These are DIMMs, dual
in-line memory modules.

48
00:02:18,810 --> 00:02:20,810
Bigger for desktops,
smaller for laptops.

49
00:02:20,810 --> 00:02:24,000
And some of you might have actually
handled or used some of these things

50
00:02:24,000 --> 00:02:28,340
before in the past, but increasingly
these are not serviceable parts.

51
00:02:28,340 --> 00:02:31,830
Apple's known for not letting you
open the computer add more RAM.

52
00:02:31,830 --> 00:02:34,390
But inside of your Mac and
your PC are things like this.

53
00:02:34,390 --> 00:02:38,640
And those chips, the little black
chips, represent some kind of technology

54
00:02:38,640 --> 00:02:41,820
that allows you to store zeros and
ones to the tune of several gigabytes

55
00:02:41,820 --> 00:02:44,360
typically these days, in total.

56
00:02:44,360 --> 00:02:51,230
So if you think of that as really just
a sequence of bytes-- so if one of those

57
00:02:51,230 --> 00:02:54,920
sticks is one gigabyte,
that's one billion bytes.

58
00:02:54,920 --> 00:02:58,940
Maybe this rectangular region of my
screen represents a billion bytes.

59
00:02:58,940 --> 00:03:01,000
I'm only going to draw
some of those bytes.

60
00:03:01,000 --> 00:03:03,904
But if I have bytes one,
two, three, four, five,

61
00:03:03,904 --> 00:03:07,155
I'm going to draw them each as
just a little cell on the screen.

62
00:03:07,155 --> 00:03:11,690
So I'm just going have
these rows and columns.

63
00:03:11,690 --> 00:03:16,654
Each of whose cells ultimately
represents one byte.

64
00:03:16,654 --> 00:03:24,055
And we'll pretend that there's actually
a billion such boxes on the screen

65
00:03:24,055 --> 00:03:25,720
as for the dot, dot, dot.

66
00:03:25,720 --> 00:03:29,540
So if each of these boxes represents
one byte, just to be clear,

67
00:03:29,540 --> 00:03:32,082
how many bits does each box represent?

68
00:03:32,082 --> 00:03:33,230
STUDENT: Eight?

69
00:03:33,230 --> 00:03:34,230
DAVID MALAN: Eight bits.

70
00:03:34,230 --> 00:03:37,504
So there are eight times whatever number
of bits pictured here on the screen.

71
00:03:37,504 --> 00:03:39,420
And I could permute the
zeros and ones however

72
00:03:39,420 --> 00:03:41,310
we want, but bits is
all about yesterday.

73
00:03:41,310 --> 00:03:44,435
Today we're just going to talk in terms
of number and letter, and so forth.

74
00:03:44,435 --> 00:03:46,890
So I can just think of this
now as memory storage space.

75
00:03:46,890 --> 00:03:49,764
And this is essentially equivalent
to one of those rectangular things

76
00:03:49,764 --> 00:03:50,660
on the screen there.

77
00:03:50,660 --> 00:03:54,710
So what can I actually do with
this in order to organize memory?

78
00:03:54,710 --> 00:03:58,590
Well, suppose that I'm
implementing a calculator.

79
00:03:58,590 --> 00:04:00,800
And much like an accountant
might want to just keep

80
00:04:00,800 --> 00:04:04,780
hitting numbers, plus numbers, plus
numbers, plus numbers, plus enter

81
00:04:04,780 --> 00:04:07,152
and then get some total,
it stands to reason

82
00:04:07,152 --> 00:04:10,110
that you need to store those numbers
somewhere so that you can actually

83
00:04:10,110 --> 00:04:11,550
do the arithmetic.

84
00:04:11,550 --> 00:04:15,670
And suppose that, for the sake
of discussion, all we want to do

85
00:04:15,670 --> 00:04:18,990
is allow the user to type
in a bunch of dollar amounts

86
00:04:18,990 --> 00:04:21,490
and see how much we've spent
on the business this month.

87
00:04:21,490 --> 00:04:27,450
So the first such number might be-- all
right, well, we spent $100 at first.

88
00:04:27,450 --> 00:04:32,460
And then we spent $50 the next
transaction, and then $150,

89
00:04:32,460 --> 00:04:35,770
and then that's it, for the moment.

90
00:04:35,770 --> 00:04:37,310
Where might I store this data?

91
00:04:37,310 --> 00:04:41,247
Well, if each of these
numbers is less than 255,

92
00:04:41,247 --> 00:04:42,580
I can store it in just one byte.

93
00:04:42,580 --> 00:04:44,830
So I'm just using small
numbers to keep things simple.

94
00:04:44,830 --> 00:04:47,550
But realistically these should
be 32-bit chunks of memory,

95
00:04:47,550 --> 00:04:49,930
but we would have to use more
blocks to represent them.

96
00:04:49,930 --> 00:04:54,060
So we're going to use small
numbers for the sake of discussion.

97
00:04:54,060 --> 00:04:57,680
In terms of hardware, this is where
your information might end up--

98
00:04:57,680 --> 00:05:00,330
underneath the hood, inside
of those little green sticks.

99
00:05:00,330 --> 00:05:03,070
And if I hit the equal sign
on my little calculator,

100
00:05:03,070 --> 00:05:07,700
this might then give me a new value--
namely, 300-- that goes in that box

101
00:05:07,700 --> 00:05:08,640
there.

102
00:05:08,640 --> 00:05:11,890
And in fact, if your computer has
the ability to undo-- like backspace,

103
00:05:11,890 --> 00:05:14,710
backspace, backspace, or
something like that-- this helps

104
00:05:14,710 --> 00:05:16,060
explain why that's possible.

105
00:05:16,060 --> 00:05:18,450
Because if the computer's
remembering all of the things

106
00:05:18,450 --> 00:05:22,610
you previously typed in, clearly there's
a way logically to undo things work,

107
00:05:22,610 --> 00:05:24,070
or see them still on the screen.

108
00:05:24,070 --> 00:05:28,790
And indeed, a calculator like
the one I keep using here-- you

109
00:05:28,790 --> 00:05:33,450
can imagine that when
I do 100, plus 150,

110
00:05:33,450 --> 00:05:36,542
plus 50-- how are each of these
symbols remaining on the screen?

111
00:05:36,542 --> 00:05:38,250
Well, they're stored
somewhere in memory.

112
00:05:38,250 --> 00:05:40,930
And my screen is constantly
refreshing itself with lights

113
00:05:40,930 --> 00:05:42,060
so that I can see it.

114
00:05:42,060 --> 00:05:44,250
And so that's somewhere
underneath the hood.

115
00:05:44,250 --> 00:05:45,890
And that's where we're looking now.

116
00:05:45,890 --> 00:05:48,910
Now in a computer
program, ideally we don't

117
00:05:48,910 --> 00:05:53,650
want to have to think about our
memory at this super, super low level.

118
00:05:53,650 --> 00:05:56,970
But we do want to have the ability
to organize our information.

119
00:05:56,970 --> 00:05:59,855
So for instance, let me just
pull up a representative program.

120
00:05:59,855 --> 00:06:02,950


121
00:06:02,950 --> 00:06:07,240
I'll use C, just because we keep
using that example from earlier.

122
00:06:07,240 --> 00:06:09,160
So suppose that this
is a program written

123
00:06:09,160 --> 00:06:14,910
in C. And suppose that-- actually
let's say-- yeah, we'll use C here.

124
00:06:14,910 --> 00:06:18,650
So suppose I want to store
one number in my calculator.

125
00:06:18,650 --> 00:06:23,060
I might call that first number x, based
on my recollection of algebra and grade

126
00:06:23,060 --> 00:06:23,750
school.

127
00:06:23,750 --> 00:06:26,880
So int x would give me
an integer called x.

128
00:06:26,880 --> 00:06:32,720
And while I'm coding this, I'm going to
call a function get_number_from_user.

129
00:06:32,720 --> 00:06:34,650
So this is just pseudocode now.

130
00:06:34,650 --> 00:06:37,640
It's a mix of C and pseudocode
where this function is somehow

131
00:06:37,640 --> 00:06:39,200
going to get a number from the user.

132
00:06:39,200 --> 00:06:42,860
And then if I do this again, I might
want to store a second number in y.

133
00:06:42,860 --> 00:06:47,200
And if I do this a third time, I
might want to get a third number

134
00:06:47,200 --> 00:06:48,480
and store it in z.

135
00:06:48,480 --> 00:06:50,760
And then maybe I want
to compute the sum.

136
00:06:50,760 --> 00:06:53,930
So I'm going to declare a
fourth variable called sum

137
00:06:53,930 --> 00:06:57,010
and have this be equal
to x plus y plus z.

138
00:06:57,010 --> 00:06:59,640
So at this point in
the story, essentially

139
00:06:59,640 --> 00:07:03,780
I'm treating this as x, this as
y, this as z, and this as sum.

140
00:07:03,780 --> 00:07:07,390
So each of those bytes
represents a variable.

141
00:07:07,390 --> 00:07:09,480
Again, an integer
would typically bigger.

142
00:07:09,480 --> 00:07:10,269
It'd be 32 bits.

143
00:07:10,269 --> 00:07:11,060
So I'm simplifying.

144
00:07:11,060 --> 00:07:15,620
But it's just eight bits,
or one byte, in this case.

145
00:07:15,620 --> 00:07:17,370
This doesn't really scale very well.

146
00:07:17,370 --> 00:07:21,570
I seem to have implemented a calculator
that's only capable of adding maximally

147
00:07:21,570 --> 00:07:24,695
three numbers, which is a
pretty subpar calculator.

148
00:07:24,695 --> 00:07:26,801
I want to be able to store more.

149
00:07:26,801 --> 00:07:28,550
And so, all right, you
want to store more.

150
00:07:28,550 --> 00:07:30,590
Well, I already used x, y, z.

151
00:07:30,590 --> 00:07:31,490
So you know what?

152
00:07:31,490 --> 00:07:33,250
I'm going to just start to use a.

153
00:07:33,250 --> 00:07:35,360
And if you need another
one, I'm going to get be.

154
00:07:35,360 --> 00:07:38,027
And I'm going to add a c and then d.

155
00:07:38,027 --> 00:07:39,110
Or this is a little messy.

156
00:07:39,110 --> 00:07:39,890
You know what?

157
00:07:39,890 --> 00:07:41,120
I could do better that that.

158
00:07:41,120 --> 00:07:43,840
Let me just call this x1.

159
00:07:43,840 --> 00:07:45,350
This will be x2.

160
00:07:45,350 --> 00:07:47,020
This will be x3.

161
00:07:47,020 --> 00:07:48,380
This will be x4.

162
00:07:48,380 --> 00:07:52,050
And the mere fact that I'm literally
copying and pasting while writing code?

163
00:07:52,050 --> 00:07:53,120
Very bad.

164
00:07:53,120 --> 00:07:56,457
It might be reasonable to do it
once, maybe twice, in a program.

165
00:07:56,457 --> 00:07:59,290
But as soon as you find yourself
copying and pasting as a developer,

166
00:07:59,290 --> 00:08:02,000
generally speaking, this
is a bad habit to get into,

167
00:08:02,000 --> 00:08:03,710
because you're duplicating code.

168
00:08:03,710 --> 00:08:06,220
You're creating twice
or thrice many places

169
00:08:06,220 --> 00:08:07,760
where there might be a mistake now.

170
00:08:07,760 --> 00:08:12,020
Much better to write one line of
code once and somehow reuse in a way.

171
00:08:12,020 --> 00:08:18,610
And a data structure called an
array allows us to do exactly this.

172
00:08:18,610 --> 00:08:22,200
An array is a feature of
many programming languages

173
00:08:22,200 --> 00:08:27,680
that lets you declare one variable but
store multiple pieces of data inside

174
00:08:27,680 --> 00:08:30,650
of it, back to back to
back to back, literally

175
00:08:30,650 --> 00:08:31,990
underneath the hood like this.

176
00:08:31,990 --> 00:08:35,620
So instead of having this situation
devolve into x1, x2-- I mean,

177
00:08:35,620 --> 00:08:36,480
this is just messy.

178
00:08:36,480 --> 00:08:37,570
This is not descriptive.

179
00:08:37,570 --> 00:08:40,289
It's just kind of
hackish, one might say.

180
00:08:40,289 --> 00:08:47,510
I'm instead going to say give me an
array of four integers, for instance.

181
00:08:47,510 --> 00:08:49,240
And the syntax I'm going to use is that.

182
00:08:49,240 --> 00:08:51,040
So it's a little more
cryptic at first glance.

183
00:08:51,040 --> 00:08:53,000
But most languages would have
you do something like this.

184
00:08:53,000 --> 00:08:56,450
You say, give me an int-- wait a minute,
how many of them?-- in square brackets.

185
00:08:56,450 --> 00:08:59,900
Give me four ints and
collectively call those ints x.

186
00:08:59,900 --> 00:09:02,770
And x is no longer or never
really was descriptive.

187
00:09:02,770 --> 00:09:05,690
Let's just call this array numbers.

188
00:09:05,690 --> 00:09:11,560
So what this means underneath
the hood is that-- this

189
00:09:11,560 --> 00:09:12,900
is what's inside of my computer.

190
00:09:12,900 --> 00:09:14,550
This is how it's physically organized.

191
00:09:14,550 --> 00:09:17,460
But so far as the computer's
concerned-- or rather,

192
00:09:17,460 --> 00:09:23,600
so far as my program is concerned, I
can think of this whole block of memory

193
00:09:23,600 --> 00:09:27,560
as one variable called numbers.

194
00:09:27,560 --> 00:09:31,242
And I've abstracted away the
underlying implementation detail.

195
00:09:31,242 --> 00:09:33,450
I don't have to know about
this whole grid of memory.

196
00:09:33,450 --> 00:09:35,170
All I care about is, give me four ints.

197
00:09:35,170 --> 00:09:37,560
Put them wherever you want,
but give me four integers.

198
00:09:37,560 --> 00:09:40,210
And syntactically, in
a language like this,

199
00:09:40,210 --> 00:09:42,590
I would then do this kind of syntax.

200
00:09:42,590 --> 00:09:46,950
Numbers bracket 0 gets--
what did I call it?

201
00:09:46,950 --> 00:09:50,550
get_number_from_user Yeah,
get_number_from_user.

202
00:09:50,550 --> 00:09:53,050
From user.

203
00:09:53,050 --> 00:09:54,790
And now, I would do this.

204
00:09:54,790 --> 00:09:58,300
One, two, three.

205
00:09:58,300 --> 00:10:03,240
And now, I would say int
sum gets numbers bracket 0

206
00:10:03,240 --> 00:10:06,710
plus numbers bracket 1
plus numbers bracket 2.

207
00:10:06,710 --> 00:10:10,140
And now, because I've declared
it of size four total,

208
00:10:10,140 --> 00:10:14,180
I can add four numbers together, which
is one more than I could earlier.

209
00:10:14,180 --> 00:10:17,400
Give me one justification for
counting from zero instead of one

210
00:10:17,400 --> 00:10:19,192
like a normal person.

211
00:10:19,192 --> 00:10:22,222
STUDENT: Because everybody
using C starts indexing at zero?

212
00:10:22,222 --> 00:10:23,305
DAVID MALAN: That is true.

213
00:10:23,305 --> 00:10:25,750
But you're really just
describing the situation.

214
00:10:25,750 --> 00:10:27,050
Explain the situation.

215
00:10:27,050 --> 00:10:28,941
Why do we start counting at zero?

216
00:10:28,941 --> 00:10:29,440
David?

217
00:10:29,440 --> 00:10:32,793
DAVID: I didn't hear it, but I was
going to say that bits-- don't they

218
00:10:32,793 --> 00:10:34,210
start with zero-zero?

219
00:10:34,210 --> 00:10:35,960
DAVID MALAN: That's
the underlying reason.

220
00:10:35,960 --> 00:10:38,880
If we rewind to yesterday-- if
you have some number of bits,

221
00:10:38,880 --> 00:10:42,150
the smallest number you can represent
is just setting all those bits to zero.

222
00:10:42,150 --> 00:10:44,484
And so it's just arguably
natural in computer science

223
00:10:44,484 --> 00:10:45,900
and in programming more generally.

224
00:10:45,900 --> 00:10:47,950
Once you understand
what's going on, if feels

225
00:10:47,950 --> 00:10:49,575
only natural to start counting at zero.

226
00:10:49,575 --> 00:10:53,490
Because if you don't, you're
essentially throwing that value away,

227
00:10:53,490 --> 00:10:55,490
because you still have
that series of bits.

228
00:10:55,490 --> 00:10:57,870
But if you don't use zero
ever, it's not all that useful.

229
00:10:57,870 --> 00:10:59,620
So in this case we
start counting at zero.

230
00:10:59,620 --> 00:11:00,790
There's still four elements.

231
00:11:00,790 --> 00:11:03,601
It just so happens that the
highest numbered one of them

232
00:11:03,601 --> 00:11:05,600
happens to be three, as
a result. This is what's

233
00:11:05,600 --> 00:11:08,020
called zero indexing, so to speak.

234
00:11:08,020 --> 00:11:08,520
OK.

235
00:11:08,520 --> 00:11:12,030
So this looks more
cryptic now, to be sure.

236
00:11:12,030 --> 00:11:14,060
But what's clean about
it fundamentally is

237
00:11:14,060 --> 00:11:18,150
that there's only one variable
for all four of those values.

238
00:11:18,150 --> 00:11:20,570
It's a variable called numbers.

239
00:11:20,570 --> 00:11:24,420
And the type of that variable
is what we would call an array.

240
00:11:24,420 --> 00:11:30,000
An array is a way of
storing data contiguously--

241
00:11:30,000 --> 00:11:33,950
back to back to back to back-- by
just using one descriptor for it,

242
00:11:33,950 --> 00:11:35,050
like the word numbers.

243
00:11:35,050 --> 00:11:36,970
And we could have called
it anything we want.

244
00:11:36,970 --> 00:11:40,010
So there's a few things
that are nice about this.

245
00:11:40,010 --> 00:11:46,650
In fact, let me draw a slightly
larger example of a few numbers here.

246
00:11:46,650 --> 00:11:58,800
Suppose I have the number--
let's say, 7, 4, 3, 2, 5, 1, 6.

247
00:11:58,800 --> 00:11:59,300
OK.

248
00:11:59,300 --> 00:12:01,270
So I've drawn seven
numbers on the board.

249
00:12:01,270 --> 00:12:03,340
They're in random order.

250
00:12:03,340 --> 00:12:06,540
And suppose now, for the
sake of discussion, that I've

251
00:12:06,540 --> 00:12:11,370
stored them in an array like this.

252
00:12:11,370 --> 00:12:14,980
So suppose that this is now a
program whose purpose in life

253
00:12:14,980 --> 00:12:19,900
is to allow me to search an array.

254
00:12:19,900 --> 00:12:21,810
Suppose we're building
a search algorithm.

255
00:12:21,810 --> 00:12:23,935
And we're just using numbers
to keep things simple,

256
00:12:23,935 --> 00:12:27,600
but these could be words
that are in English.

257
00:12:27,600 --> 00:12:29,175
How would I go about finding a value?

258
00:12:29,175 --> 00:12:31,800
Well, it turns out that when
you're programming, even though we

259
00:12:31,800 --> 00:12:33,830
humans can kind of glance
at the board and-- oh, OK.

260
00:12:33,830 --> 00:12:35,050
I see seven numbers there.

261
00:12:35,050 --> 00:12:36,170
A computer cannot do that.

262
00:12:36,170 --> 00:12:38,950
A computer can only look at
one piece of memory at a time.

263
00:12:38,950 --> 00:12:41,890
And in fact, if you recall earlier
when I pulled up some sample code

264
00:12:41,890 --> 00:12:45,200
and I mentioned the load operator,
that's sort of a manifestation of this.

265
00:12:45,200 --> 00:12:46,640
You can load a value.

266
00:12:46,640 --> 00:12:49,645
You can't say go load a whole bunch
of things all at once necessarily.

267
00:12:49,645 --> 00:12:52,070
It has to be more low-level than that.

268
00:12:52,070 --> 00:12:54,280
So even though we, the
humans, see the whole thing,

269
00:12:54,280 --> 00:12:56,380
think of it like a
horse with blinders on.

270
00:12:56,380 --> 00:12:58,460
You can only see one value at a time.

271
00:12:58,460 --> 00:13:02,550
And you can ultimately see all of them,
but you have to iterate, so to speak.

272
00:13:02,550 --> 00:13:05,510
You have to look at
one element at a time.

273
00:13:05,510 --> 00:13:09,060
So what programming construct does
this perhaps remind you of from Scratch

274
00:13:09,060 --> 00:13:11,740
before lunch?

275
00:13:11,740 --> 00:13:15,240
What puzzle piece would allow you to
implement this idea of doing something

276
00:13:15,240 --> 00:13:17,830
again and again?

277
00:13:17,830 --> 00:13:18,440
Yeah, Grace?

278
00:13:18,440 --> 00:13:19,023
GRACE: Repeat.

279
00:13:19,023 --> 00:13:19,640
The repeat.

280
00:13:19,640 --> 00:13:20,390
DAVID MALAN: Yeah.

281
00:13:20,390 --> 00:13:22,790
Like repeat seven, instead
of the default repeat 10.

282
00:13:22,790 --> 00:13:24,170
Why don't we repeat seven times?

283
00:13:24,170 --> 00:13:25,878
Forever feels bad,
because then I'm going

284
00:13:25,878 --> 00:13:27,420
to go way past the edge of the board.

285
00:13:27,420 --> 00:13:28,752
And who knows what might happen?

286
00:13:28,752 --> 00:13:30,170
That's when computers might crash.

287
00:13:30,170 --> 00:13:32,003
But if we repeat seven
times, we can iterate

288
00:13:32,003 --> 00:13:34,090
over looking at each of these elements.

289
00:13:34,090 --> 00:13:39,400
So with that said, looking at this
array, how would you as a computer

290
00:13:39,400 --> 00:13:43,730
go about finding the numeric
equivalent of Mike Smith?

291
00:13:43,730 --> 00:13:49,020
How might you go about finding the
number six in an array of numbers?

292
00:13:49,020 --> 00:13:52,040
Well, turns out by convention,
when you have an array--

293
00:13:52,040 --> 00:13:54,394
you can technically start at
the left or the right end,

294
00:13:54,394 --> 00:13:57,560
but it's almost always the case you
just start arbitrarily, but consistently

295
00:13:57,560 --> 00:13:58,600
at the left end.

296
00:13:58,600 --> 00:14:03,010
Which means you can look at the seven
first, then you can look at the four,

297
00:14:03,010 --> 00:14:07,220
then the three, then the two, then
the five, then the one, then the six.

298
00:14:07,220 --> 00:14:07,720
Aha!

299
00:14:07,720 --> 00:14:08,700
It's there.

300
00:14:08,700 --> 00:14:11,491
And if you go all the way and you
don't find it, then you conclude,

301
00:14:11,491 --> 00:14:13,210
oh, this number's not in the array.

302
00:14:13,210 --> 00:14:17,220
So let's describe the running
time of searching an array.

303
00:14:17,220 --> 00:14:19,060
In other words, how
many steps does it take

304
00:14:19,060 --> 00:14:21,480
to find an arbitrary number
in this kind of array?

305
00:14:21,480 --> 00:14:23,615


306
00:14:23,615 --> 00:14:25,990
STUDENT: As many steps as
there are numbers in the array?

307
00:14:25,990 --> 00:14:26,570
DAVID MALAN: Yeah.

308
00:14:26,570 --> 00:14:28,611
In the worst case, the
number you're looking for,

309
00:14:28,611 --> 00:14:31,490
like six-- deliberately chosen--
might be all the way at the end.

310
00:14:31,490 --> 00:14:33,390
So you've got to search
the whole darn thing.

311
00:14:33,390 --> 00:14:37,330
Now, this is very arbitrary example,
so describing the efficiency of arrays

312
00:14:37,330 --> 00:14:39,900
as seven is kind of meaningless.

313
00:14:39,900 --> 00:14:43,481
But if you think of the length of
this whole thing-- in general is n,

314
00:14:43,481 --> 00:14:46,730
just like yesterday with the number of
pages in the phone book-- we would say,

315
00:14:46,730 --> 00:14:50,040
and I used the syntax
yesterday, the running time

316
00:14:50,040 --> 00:14:55,090
of searching an array linearly
left to right is on the order of n.

317
00:14:55,090 --> 00:14:57,414
Maybe it's less than n.

318
00:14:57,414 --> 00:14:58,580
It's not going to be more n.

319
00:14:58,580 --> 00:15:00,920
Maybe it's a few steps less than
n, depending on where the six is.

320
00:15:00,920 --> 00:15:03,150
Maybe you get really lucky
and it's only one step.

321
00:15:03,150 --> 00:15:07,520
But if we use this special capitalized
O rotation called big O notation,

322
00:15:07,520 --> 00:15:11,190
that describes in this case an
upper bound on how many steps

323
00:15:11,190 --> 00:15:13,610
it might take us to find this element.

324
00:15:13,610 --> 00:15:15,370
OK, that's all fine and good.

325
00:15:15,370 --> 00:15:17,260
But seven is pretty tenable.

326
00:15:17,260 --> 00:15:20,050
What if it's like
seven billion elements?

327
00:15:20,050 --> 00:15:22,660
Well, that's going to be on the
order of seven billion steps,

328
00:15:22,660 --> 00:15:25,670
and that kind of invites an
opportunity for smarter algorithms.

329
00:15:25,670 --> 00:15:28,790
And what was the smarter
algorithm we introduced yesterday

330
00:15:28,790 --> 00:15:33,040
that solved search problems much
faster than this linear left-to-right

331
00:15:33,040 --> 00:15:34,304
approach?

332
00:15:34,304 --> 00:15:35,470
STUDENT: Divide and conquer.

333
00:15:35,470 --> 00:15:38,120
DAVID MALAN: Yeah, that
divide and conquer strategy.

334
00:15:38,120 --> 00:15:40,210
Can I use that here?

335
00:15:40,210 --> 00:15:43,840
If I think of the phone book
as the analog yesterday,

336
00:15:43,840 --> 00:15:46,250
I might look at the middle
of the array, which I can do.

337
00:15:46,250 --> 00:15:47,666
I don't have to start at the left.

338
00:15:47,666 --> 00:15:54,064
Because what's nice is, because I know
that this is location 0, 1, 2, 3, 4, 5,

339
00:15:54,064 --> 00:15:59,080
6, I know I can go immediately
to the middle of the array

340
00:15:59,080 --> 00:16:00,900
just by knowing its length.

341
00:16:00,900 --> 00:16:03,830
If I know the length is
seven, I can divide it by two.

342
00:16:03,830 --> 00:16:05,890
That unfortunately gives me 3 and 1/2.

343
00:16:05,890 --> 00:16:07,660
But if I round down,
that gives me three.

344
00:16:07,660 --> 00:16:10,220
So where's the middle of the array?

345
00:16:10,220 --> 00:16:12,639
I can look immediately at
the middle of the array.

346
00:16:12,639 --> 00:16:15,180
So the computer doesn't strictly
have to start left to right,

347
00:16:15,180 --> 00:16:18,460
because if it knows its length, it
has what's called random access.

348
00:16:18,460 --> 00:16:23,390
It can jump randomly to any element
just by doing a bit of arithmetic.

349
00:16:23,390 --> 00:16:24,790
Thus was born the name RAM.

350
00:16:24,790 --> 00:16:28,120
Random access memory is
memory that looks like this.

351
00:16:28,120 --> 00:16:31,490
And it's random access in the
sense that using simple arithmetic,

352
00:16:31,490 --> 00:16:35,030
you can jump to any random
location that you might like.

353
00:16:35,030 --> 00:16:37,480
You don't have to search
the whole thing per se.

354
00:16:37,480 --> 00:16:41,710
Now can we leverage simple
arithmetic and divide

355
00:16:41,710 --> 00:16:43,960
and conquer to find
the number six faster?

356
00:16:43,960 --> 00:16:44,985
So I look at the middle.

357
00:16:44,985 --> 00:16:45,485
Aha!

358
00:16:45,485 --> 00:16:47,580
It's the number two.

359
00:16:47,580 --> 00:16:50,276
Six should be to the
right or to the left?

360
00:16:50,276 --> 00:16:51,560
STUDENT 5: To the right.

361
00:16:51,560 --> 00:16:53,880
DAVID MALAN: Well, I
mean, it is to the right.

362
00:16:53,880 --> 00:16:57,000
But most of you are
questioning this logic.

363
00:16:57,000 --> 00:16:57,500
Why?

364
00:16:57,500 --> 00:16:58,885
What's flawed about it?

365
00:16:58,885 --> 00:17:00,262
STUDENT 6: It's not sorted.

366
00:17:00,262 --> 00:17:01,470
DAVID MALAN: It's not sorted.

367
00:17:01,470 --> 00:17:01,750
Right?

368
00:17:01,750 --> 00:17:03,980
The whole beauty of the
phone book and the reason

369
00:17:03,980 --> 00:17:08,829
we could apply divide and
conquer is because it was sorted.

370
00:17:08,829 --> 00:17:12,859
So you knew s was after m and
not in just some random location.

371
00:17:12,859 --> 00:17:17,390
So unfortunately here, if this array--
even though it gives us random access,

372
00:17:17,390 --> 00:17:20,770
that's useless in this case
insofar as it doesn't actually

373
00:17:20,770 --> 00:17:23,890
let us search it any more effectively.

374
00:17:23,890 --> 00:17:30,990
So what if we did have random
access but also a sorted array,

375
00:17:30,990 --> 00:17:34,730
such that-- now I'll use some
different numbers just so it's not just

376
00:17:34,730 --> 00:17:36,400
a silly example with 0 through 6.

377
00:17:36,400 --> 00:17:46,740
Suppose we have the number 5,
10, 20, 32, 42, 50, and 99.

378
00:17:46,740 --> 00:17:52,230
And suppose now I'm searching for
the number 42-- meaning of life,

379
00:17:52,230 --> 00:17:53,780
the universe, everything.

380
00:17:53,780 --> 00:17:54,960
So where do I begin?

381
00:17:54,960 --> 00:17:57,010
It's sorted, and I know that in advance.

382
00:17:57,010 --> 00:18:00,920
So I jump to 3.5, or
round down, so it's 3.

383
00:18:00,920 --> 00:18:02,640
Now I know it's here.

384
00:18:02,640 --> 00:18:05,620
And what's nice now is that
I have a well-defined middle.

385
00:18:05,620 --> 00:18:08,890
I chose the number seven deliberately,
so that it would look nice and pretty.

386
00:18:08,890 --> 00:18:11,180
But 32 is less than 42.

387
00:18:11,180 --> 00:18:14,780
So I know 42 must be, if
anywhere, to the right.

388
00:18:14,780 --> 00:18:19,250
So I can figuratively and literally
throw this half of the problem

389
00:18:19,250 --> 00:18:23,589
away, leaving me now with a nicely
symmetric three element array.

390
00:18:23,589 --> 00:18:25,130
I look at the middle of this one, 50.

391
00:18:25,130 --> 00:18:26,370
Ah, 50 is too big.

392
00:18:26,370 --> 00:18:27,940
It's bigger than 42.

393
00:18:27,940 --> 00:18:30,120
So I can throw this half
of the problem away,

394
00:18:30,120 --> 00:18:33,420
including the number I'm looking
at, and look now to left.

395
00:18:33,420 --> 00:18:34,170
I see.

396
00:18:34,170 --> 00:18:35,110
Now I got lucky.

397
00:18:35,110 --> 00:18:37,740
But it's also the last
element, so voila!

398
00:18:37,740 --> 00:18:38,890
I'm done.

399
00:18:38,890 --> 00:18:41,964
And this took how many steps?

400
00:18:41,964 --> 00:18:42,930
STUDENT: Three?

401
00:18:42,930 --> 00:18:43,971
DAVID MALAN: Three steps.

402
00:18:43,971 --> 00:18:46,820
I went here, then I went
here, then I went here.

403
00:18:46,820 --> 00:18:50,590
And you can kind of see that
insofar as how many times can you

404
00:18:50,590 --> 00:18:53,040
split seven elements?

405
00:18:53,040 --> 00:18:57,701
Log base 2 of 7 will give us,
indeed, 3 in this case, give or take.

406
00:18:57,701 --> 00:18:59,450
But don't worry if
that's unfamiliar math.

407
00:18:59,450 --> 00:19:00,420
But that's how we got there.

408
00:19:00,420 --> 00:19:02,480
How many times can you
divide it again and again?

409
00:19:02,480 --> 00:19:05,810
So this is to say ultimately,
what's the running time of searching

410
00:19:05,810 --> 00:19:07,655
an array if it is sorted?

411
00:19:07,655 --> 00:19:11,506


412
00:19:11,506 --> 00:19:12,960
It's big O of?

413
00:19:12,960 --> 00:19:13,810
STUDENT: [INAUDIBLE]

414
00:19:13,810 --> 00:19:14,660
STUDENT: Log base 2.

415
00:19:14,660 --> 00:19:15,410
DAVID MALAN: Yeah.

416
00:19:15,410 --> 00:19:17,610
So log base 2 of n.

417
00:19:17,610 --> 00:19:19,870
Because again, if unfamiliar
or you don't recall,

418
00:19:19,870 --> 00:19:22,830
logarithm base 2 is just how many
times can you divide, divide, divide,

419
00:19:22,830 --> 00:19:24,244
divide until you get to one.

420
00:19:24,244 --> 00:19:26,160
And frankly, most computer
scientists wouldn't

421
00:19:26,160 --> 00:19:29,020
bother writing constant
numbers, like the number 2.

422
00:19:29,020 --> 00:19:30,980
We would just write it
more simply like this.

423
00:19:30,980 --> 00:19:35,200
But this is smaller than this, certainly
for sufficiently large values of n.

424
00:19:35,200 --> 00:19:36,960
So this is a more appealing algorithm.

425
00:19:36,960 --> 00:19:40,140
And this now is the more formal way of
describing what I described yesterday

426
00:19:40,140 --> 00:19:42,820
as the first approach,
turning one page at a time,

427
00:19:42,820 --> 00:19:46,160
versus the third approach, which
was dividing and conquering.

428
00:19:46,160 --> 00:19:47,110
So this is great.

429
00:19:47,110 --> 00:19:52,757
We seem to have found now an application
of that high-level phone book

430
00:19:52,757 --> 00:19:55,340
idea to actually solving problems
that a computer might solve.

431
00:19:55,340 --> 00:19:57,131
And again, even though
we're using numbers,

432
00:19:57,131 --> 00:20:00,540
imagine this being words or web pages
in a database, or anything that's

433
00:20:00,540 --> 00:20:02,370
actually more interesting than numbers.

434
00:20:02,370 --> 00:20:04,440
Unfortunately, there's a problem.

435
00:20:04,440 --> 00:20:09,630
With an array like
this one here, suppose

436
00:20:09,630 --> 00:20:15,150
I'm dealing not with some
calculator but with sorted data.

437
00:20:15,150 --> 00:20:18,660
Because we seem to be at the point
in the story where keeping your data

438
00:20:18,660 --> 00:20:20,310
sorted seems to be advantageous.

439
00:20:20,310 --> 00:20:21,680
You can search it faster.

440
00:20:21,680 --> 00:20:29,500
So suppose those numbers again are
5, 10, 20, 32, 42, 50, and then,

441
00:20:29,500 --> 00:20:30,350
who knows what else?

442
00:20:30,350 --> 00:20:31,709
After that, it's just undefined.

443
00:20:31,709 --> 00:20:33,000
Question marks everywhere else.

444
00:20:33,000 --> 00:20:33,499
Yeah.

445
00:20:33,499 --> 00:20:35,517
STUDENT: What if they're
completely unsorted?

446
00:20:35,517 --> 00:20:37,350
DAVID MALAN: If they're
completely unsorted,

447
00:20:37,350 --> 00:20:40,058
we're in the former scenario,
where we have to use linear search,

448
00:20:40,058 --> 00:20:42,060
left to right.

449
00:20:42,060 --> 00:20:45,107
So what the narrative here is,
if they're completely unsorted,

450
00:20:45,107 --> 00:20:47,690
you can do no better than looking
through the whole darn list.

451
00:20:47,690 --> 00:20:48,940
And maybe you get lucky
and it's early on,

452
00:20:48,940 --> 00:20:50,481
but you have to check the whole list.

453
00:20:50,481 --> 00:20:54,410
If it's somehow sorted, either because
you did it or because the user did it,

454
00:20:54,410 --> 00:20:56,830
then you can leverage
something like binary search.

455
00:20:56,830 --> 00:21:01,030
But that win, which seems to be
an improvement, comes at a cost

456
00:21:01,030 --> 00:21:03,020
by using an array.

457
00:21:03,020 --> 00:21:05,340
Binary search, as it's
called-- bi meaning two,

458
00:21:05,340 --> 00:21:09,170
splitting the list again and again--
assumes that the array is sorted,

459
00:21:09,170 --> 00:21:13,310
but it also assumes that your data
structure gives you random access.

460
00:21:13,310 --> 00:21:17,610
Because how did I know to
go to element 3.5, or 3?

461
00:21:17,610 --> 00:21:18,430
Like arithmetic.

462
00:21:18,430 --> 00:21:20,870
I needed to know the lower
bound and the upper bound,

463
00:21:20,870 --> 00:21:23,820
so that I could jump
right to the middle.

464
00:21:23,820 --> 00:21:25,530
Unfortunately, this comes at a cost.

465
00:21:25,530 --> 00:21:27,530
If you're storing all of
your data back to back

466
00:21:27,530 --> 00:21:30,080
to back to back to back in this way.

467
00:21:30,080 --> 00:21:36,660
Suppose I want to insert the
number 21 into this data structure.

468
00:21:36,660 --> 00:21:39,195
Where does it belong if I
want to keep my data sorted,

469
00:21:39,195 --> 00:21:42,070
which seems to be in my best interest,
because then search is faster?

470
00:21:42,070 --> 00:21:43,111
Where does it have to go?

471
00:21:43,111 --> 00:21:45,732


472
00:21:45,732 --> 00:21:48,740
Yeah, after 20, and before 32.

473
00:21:48,740 --> 00:21:51,030
And while I could cheat
with a whiteboard marker

474
00:21:51,030 --> 00:21:55,110
and just draw it wherever I want,
that's not how memory works.

475
00:21:55,110 --> 00:21:57,970
These are actual 0's and
1's underneath the hood.

476
00:21:57,970 --> 00:22:00,330
So if I want to keep
the list in sorted order

477
00:22:00,330 --> 00:22:07,617
and insert 21 in between 20
and 32, how do we fix this?

478
00:22:07,617 --> 00:22:09,200
And I guess I shouldn't show you this.

479
00:22:09,200 --> 00:22:11,890
How do we fix this?

480
00:22:11,890 --> 00:22:13,760
STUDENT: Delete the
last three and add it?

481
00:22:13,760 --> 00:22:14,510
DAVID MALAN: Yeah.

482
00:22:14,510 --> 00:22:15,680
Delete the last three.

483
00:22:15,680 --> 00:22:18,410
And maybe not just
delete them, but rather

484
00:22:18,410 --> 00:22:23,650
maybe make a copy of the last element
and then erase it or change it.

485
00:22:23,650 --> 00:22:27,379
Then make a copy of the second-to-last
number and move it over.

486
00:22:27,379 --> 00:22:29,420
And notice, the order of
operations is important.

487
00:22:29,420 --> 00:22:30,930
If I blindly do this, damn it.

488
00:22:30,930 --> 00:22:32,150
What do I need to write down?

489
00:22:32,150 --> 00:22:35,360
A computer's just going to forget unless
the computer remembers it somewhere.

490
00:22:35,360 --> 00:22:37,110
So this has to be done
in the right order.

491
00:22:37,110 --> 00:22:38,650
So this might be 32.

492
00:22:38,650 --> 00:22:43,630
Now I can put the number 21 here.

493
00:22:43,630 --> 00:22:45,360
So it's fixable, this problem.

494
00:22:45,360 --> 00:22:46,790
We still have sorted order.

495
00:22:46,790 --> 00:22:48,350
We still have random access.

496
00:22:48,350 --> 00:22:51,030
And we have the ability to
insert new data into this list.

497
00:22:51,030 --> 00:22:52,970
That seems like
everything you might want.

498
00:22:52,970 --> 00:22:56,940
But I would argue that
that was expensive.

499
00:22:56,940 --> 00:22:59,750
That was a minorly painful
and certainly would be painful

500
00:22:59,750 --> 00:23:02,950
if this list were bigger than seven.

501
00:23:02,950 --> 00:23:05,865
What price did I just pay for
keeping all of these features?

502
00:23:05,865 --> 00:23:11,320


503
00:23:11,320 --> 00:23:12,176
STUDENT: Time.

504
00:23:12,176 --> 00:23:13,300
DAVID MALAN: It takes time.

505
00:23:13,300 --> 00:23:14,446
I did it somewhat quickly.

506
00:23:14,446 --> 00:23:15,570
It was only three elements.

507
00:23:15,570 --> 00:23:17,750
But again, if it's a million
elements in the list,

508
00:23:17,750 --> 00:23:21,230
that might take me half a million
steps to make room or move things over.

509
00:23:21,230 --> 00:23:24,610
That's going to cost me and the
computer time, but it does work.

510
00:23:24,610 --> 00:23:26,660
So that's one of the
prices you pay of arrays.

511
00:23:26,660 --> 00:23:29,890
It's again this balancing act,
whereby it feels like win-win-win, ah,

512
00:23:29,890 --> 00:23:30,640
but wait a minute.

513
00:23:30,640 --> 00:23:33,140
Inserting data just got very expensive.

514
00:23:33,140 --> 00:23:35,890
Deleting data is going to get very
expensive, because then I have

515
00:23:35,890 --> 00:23:38,240
to go in and keep everything compact.

516
00:23:38,240 --> 00:23:42,070
I could just start deleting
things and creating holes my data.

517
00:23:42,070 --> 00:23:45,070
And then when I insert data, I could
just put it in any random location,

518
00:23:45,070 --> 00:23:48,034
but the problem there is we
sacrifice the sortability,

519
00:23:48,034 --> 00:23:49,200
the sorted-ness of the list.

520
00:23:49,200 --> 00:23:51,750
And we sacrifice the
ability to jump predictably

521
00:23:51,750 --> 00:23:54,470
to elements that are in the list.

522
00:23:54,470 --> 00:23:56,170
So how do we fix this?

523
00:23:56,170 --> 00:23:59,370
I feel like I would really
like to be able to insert data

524
00:23:59,370 --> 00:24:04,020
into the list faster without having
to move every darn thing around.

525
00:24:04,020 --> 00:24:07,360


526
00:24:07,360 --> 00:24:09,360
STUDENT: We'd use a directory?

527
00:24:09,360 --> 00:24:11,160
DAVID MALAN: A directory.

528
00:24:11,160 --> 00:24:11,899
OK, yeah.

529
00:24:11,899 --> 00:24:13,440
Actually, let me-- hold that thought.

530
00:24:13,440 --> 00:24:15,800
So that's good and
that's a nice way framing

531
00:24:15,800 --> 00:24:18,710
something that's going to be
called a hash table in a bit.

532
00:24:18,710 --> 00:24:20,610
Let me propose that's
even more sophisticated

533
00:24:20,610 --> 00:24:21,880
than we need at this point.

534
00:24:21,880 --> 00:24:22,380
Grace?

535
00:24:22,380 --> 00:24:23,770
GRACE: No, never mind.

536
00:24:23,770 --> 00:24:23,930
DAVID MALAN: Alicia?

537
00:24:23,930 --> 00:24:25,820
ALICIA: Could you just
do an insert command?

538
00:24:25,820 --> 00:24:27,111
DAVID MALAN: An insert command.

539
00:24:27,111 --> 00:24:32,160
OK, but we are implementing the insert
command today, so that's not an option.

540
00:24:32,160 --> 00:24:32,660
Yeah.

541
00:24:32,660 --> 00:24:33,160
Dan?

542
00:24:33,160 --> 00:24:34,330
DAN: Create it as you go?

543
00:24:34,330 --> 00:24:38,000
And just have the list
changing one piece at a time?

544
00:24:38,000 --> 00:24:38,750
DAVID MALAN: Yeah.

545
00:24:38,750 --> 00:24:40,980
Why don't we create the list as we go?

546
00:24:40,980 --> 00:24:44,210
And this will be easier to
look at first in the abstract.

547
00:24:44,210 --> 00:24:45,540
So let's do it this way.

548
00:24:45,540 --> 00:24:50,090
Suppose that the first number I insert
into this list, by whatever sequence

549
00:24:50,090 --> 00:24:52,191
of real world events, is the number 20.

550
00:24:52,191 --> 00:24:54,440
So I'm just going to draw
the number 20 on the screen.

551
00:24:54,440 --> 00:24:56,780
And just for kicks, I'm going to draw
it in a box, so it looks like this.

552
00:24:56,780 --> 00:24:57,750
That's it.

553
00:24:57,750 --> 00:25:02,010
Now suppose the next number I want
to insert into this list is 50.

554
00:25:02,010 --> 00:25:04,490
So I'm going to assume
for now-- I'm just

555
00:25:04,490 --> 00:25:07,100
going to keep track of
where that first element is.

556
00:25:07,100 --> 00:25:08,980
So this small little
dot here on the screen

557
00:25:08,980 --> 00:25:11,790
just represents-- that's the
beginning of my list that I'm making.

558
00:25:11,790 --> 00:25:13,040
So now I insert the number 50.

559
00:25:13,040 --> 00:25:14,414
Where, of course, does it belong?

560
00:25:14,414 --> 00:25:16,360
To the left or to the right of the 20?

561
00:25:16,360 --> 00:25:17,860
So obviously to the right.

562
00:25:17,860 --> 00:25:19,940
So I start here and I follow this.

563
00:25:19,940 --> 00:25:21,680
Oh no, it belongs to the right.

564
00:25:21,680 --> 00:25:23,500
So now, I create a new box.

565
00:25:23,500 --> 00:25:26,970
In other words, I ask Mac OS or Windows,
give me a little more memory please.

566
00:25:26,970 --> 00:25:28,370
I plop a number in it.

567
00:25:28,370 --> 00:25:31,980
And I somehow have to do the
equivalent digitally of this arrow.

568
00:25:31,980 --> 00:25:34,990
But for now, we'll keep it abstract
with just an arrow on the board.

569
00:25:34,990 --> 00:25:36,499
Now I insert the number 32.

570
00:25:36,499 --> 00:25:37,290
Where does that go?

571
00:25:37,290 --> 00:25:40,380


572
00:25:40,380 --> 00:25:41,610
Obviously in between.

573
00:25:41,610 --> 00:25:45,400
And now previously, I would have
drawn a new node, so to speak.

574
00:25:45,400 --> 00:25:47,420
These squares-- we would
generally call nodes.

575
00:25:47,420 --> 00:25:50,541
I would erase this and
then insert the new one.

576
00:25:50,541 --> 00:25:52,790
But because of these arrows,
we don't need to do that.

577
00:25:52,790 --> 00:25:55,580
Because to Dan's point,
why don't we just again ask

578
00:25:55,580 --> 00:25:58,110
Mac OS or Windows for
memory-- and that's

579
00:25:58,110 --> 00:26:02,520
going to give me this chunk
here represented with a box.

580
00:26:02,520 --> 00:26:05,180
But if we're just kind of
allocating, so to speak,

581
00:26:05,180 --> 00:26:08,670
or creating these things as we go, I
don't need to touch the 20 or the 50,

582
00:26:08,670 --> 00:26:09,900
per se.

583
00:26:09,900 --> 00:26:14,580
Why don't I just change
what points to what?

584
00:26:14,580 --> 00:26:18,790
And so in this way,
these numbers literally

585
00:26:18,790 --> 00:26:21,690
don't need to be back to
back to back in this grid.

586
00:26:21,690 --> 00:26:24,660
They could literally be one up
here, one over here, one over here.

587
00:26:24,660 --> 00:26:26,790
And so long as in code,
I have the ability

588
00:26:26,790 --> 00:26:29,830
to draw the equivalent
of arrows on the board,

589
00:26:29,830 --> 00:26:32,060
I can somehow link all
of these things together.

590
00:26:32,060 --> 00:26:35,000
And indeed, version two
of our data structure

591
00:26:35,000 --> 00:26:37,320
would be what most people
would call a linked

592
00:26:37,320 --> 00:26:39,850
list, which is fairly self descriptive.

593
00:26:39,850 --> 00:26:42,780
And the upside of this,
now, is that I don't

594
00:26:42,780 --> 00:26:45,910
have to do a massive amount
of movement of nodes,

595
00:26:45,910 --> 00:26:47,680
which can be costly and time-consuming.

596
00:26:47,680 --> 00:26:49,637
I still have to find where it belongs.

597
00:26:49,637 --> 00:26:50,970
So there's a bit of a trade off.

598
00:26:50,970 --> 00:26:53,720
I can't jump immediately to the
middle of a linked list, because I

599
00:26:53,720 --> 00:26:56,730
claim the only way you
keep track of a linked list

600
00:26:56,730 --> 00:27:00,507
is by way of this first
node-- this pointer over here.

601
00:27:00,507 --> 00:27:02,340
But that's OK, because
at least I don't have

602
00:27:02,340 --> 00:27:04,580
to do all that deletion
and movement of space.

603
00:27:04,580 --> 00:27:10,210
Moreover, even more compellingly, in the
world of arrays-- in this world here,

604
00:27:10,210 --> 00:27:12,660
suppose that this is
the list I start with.

605
00:27:12,660 --> 00:27:15,860
If I have in advance asked
operating system, Mac OS or Windows,

606
00:27:15,860 --> 00:27:19,539
give me space for eight numbers, it
will hand you back the equivalent

607
00:27:19,539 --> 00:27:20,830
of a chunk of memory like this.

608
00:27:20,830 --> 00:27:23,040
Essentially it'll hand
me back instructions.

609
00:27:23,040 --> 00:27:26,500
All right, David, you can store
it at location 0 through 7.

610
00:27:26,500 --> 00:27:29,050
And that's all the operating
system is committing to.

611
00:27:29,050 --> 00:27:31,210
Because another constraint
of arrays is you

612
00:27:31,210 --> 00:27:33,770
must decide in advance
how big it is going to be.

613
00:27:33,770 --> 00:27:35,480
If you want eight numbers, that's fine.

614
00:27:35,480 --> 00:27:36,140
Tell the OS.

615
00:27:36,140 --> 00:27:37,870
You'll get space for eight numbers.

616
00:27:37,870 --> 00:27:40,760
But the operating system
reserves the right

617
00:27:40,760 --> 00:27:44,350
to plop other stuff right
after your chunk of memory.

618
00:27:44,350 --> 00:27:47,770
So suppose that something else is
going on in your program or computer,

619
00:27:47,770 --> 00:27:49,725
like the user has just
typed in their name.

620
00:27:49,725 --> 00:27:53,786
And so D-A-V-I-D might end up here.

621
00:27:53,786 --> 00:27:56,160
And then some other program
is running, and so the number

622
00:27:56,160 --> 00:27:58,460
88 and then 99 ends up here.

623
00:27:58,460 --> 00:27:59,700
Whatever those mean.

624
00:27:59,700 --> 00:28:05,380
But the point is that your data is now
bumping up against some other data.

625
00:28:05,380 --> 00:28:08,730
So the next time your program
says, hey, operating system.

626
00:28:08,730 --> 00:28:10,990
The user wants to insert the number 22.

627
00:28:10,990 --> 00:28:12,490
I need more space.

628
00:28:12,490 --> 00:28:15,900
What you can't do in an array
is-- all right, damn it.

629
00:28:15,900 --> 00:28:16,570
Uh, 50.

630
00:28:16,570 --> 00:28:18,640
All right, I have a
free space over here.

631
00:28:18,640 --> 00:28:22,330
Let me put the 50 here,
and that moves the 42.

632
00:28:22,330 --> 00:28:26,841
Then let me move the--
let's see, the 32 goes here.

633
00:28:26,841 --> 00:28:27,840
And that frees up space.

634
00:28:27,840 --> 00:28:30,910
Oh, and now I can put the 22.

635
00:28:30,910 --> 00:28:32,190
I mean, I could do that.

636
00:28:32,190 --> 00:28:34,351
But you're violating the
definition of an array.

637
00:28:34,351 --> 00:28:34,850
Why?

638
00:28:34,850 --> 00:28:37,610


639
00:28:37,610 --> 00:28:38,940
It's out of order.

640
00:28:38,940 --> 00:28:42,370
I mean, it's still kind of increasing
in order, left to right, top to bottom.

641
00:28:42,370 --> 00:28:45,060
But it's no longer contiguous.

642
00:28:45,060 --> 00:28:50,460
And the contiguousness property is
requisite for what functionality?

643
00:28:50,460 --> 00:28:52,190
Search, for random access.

644
00:28:52,190 --> 00:28:52,810
Right?

645
00:28:52,810 --> 00:28:56,780
I know my array might be length 9
now, because I can keep track of that

646
00:28:56,780 --> 00:28:58,980
with like a variable,
somewhere in memory.

647
00:28:58,980 --> 00:29:02,162
But the 50 is not next
to the 42, which means

648
00:29:02,162 --> 00:29:05,245
if I'm jumping to the middle of this
list, god knows where I might end up.

649
00:29:05,245 --> 00:29:06,410
I might end up at the i.

650
00:29:06,410 --> 00:29:09,159
And that makes no sense, because
it's a letter, not even a number.

651
00:29:09,159 --> 00:29:12,380
So arrays are problematic, because you
kind of paint yourself into a corner.

652
00:29:12,380 --> 00:29:16,250
Deliberately, it's a plus,
insofar as you get random access.

653
00:29:16,250 --> 00:29:18,300
But you also kind of
shoot yourself in the foot

654
00:29:18,300 --> 00:29:21,130
for future additions to the list.

655
00:29:21,130 --> 00:29:22,630
So what might you do to avoid this?

656
00:29:22,630 --> 00:29:25,110
Well, maybe the first time
I ask the OS for memory,

657
00:29:25,110 --> 00:29:28,940
maybe I shouldn't be so short-sighted
and instead of asking for, like,

658
00:29:28,940 --> 00:29:30,380
eight elements.

659
00:29:30,380 --> 00:29:31,670
Let me just round up.

660
00:29:31,670 --> 00:29:34,460
Give me space for 100 numbers.

661
00:29:34,460 --> 00:29:37,950
Why not just preemptively do that so
that most of the board stays free?

662
00:29:37,950 --> 00:29:39,700
And then if the user
types his name in, it

663
00:29:39,700 --> 00:29:43,310
ends up at least down here, so I
have a little bit of breathing room.

664
00:29:43,310 --> 00:29:45,985
What's bad about that solution?

665
00:29:45,985 --> 00:29:48,880


666
00:29:48,880 --> 00:29:49,810
Grace?

667
00:29:49,810 --> 00:29:51,682
Or Alicia?

668
00:29:51,682 --> 00:29:54,670
STUDENT: It's very expensive.

669
00:29:54,670 --> 00:29:55,420
DAVID MALAN: Yeah.

670
00:29:55,420 --> 00:29:56,003
It's wasteful.

671
00:29:56,003 --> 00:29:57,210
It's extravagant.

672
00:29:57,210 --> 00:30:00,190
Yes, it's self defense, so
that you have room to grow.

673
00:30:00,190 --> 00:30:03,477
But one, you're going
to consume more memory.

674
00:30:03,477 --> 00:30:06,310
And we know from yesterday, you
only have a finite amount of memory.

675
00:30:06,310 --> 00:30:07,750
So now, thanks to
virtual memory, now you

676
00:30:07,750 --> 00:30:10,291
might actually be slowing down
the computer as a side effect,

677
00:30:10,291 --> 00:30:13,201
because you're so greedy asking
for memory you might not ever use.

678
00:30:13,201 --> 00:30:15,700
Moreover, it doesn't really
fundamentally solve the problem.

679
00:30:15,700 --> 00:30:19,210
Because eventually, the user's going
to ask potentially for more memory

680
00:30:19,210 --> 00:30:20,854
than you preemptively chose.

681
00:30:20,854 --> 00:30:24,020
So you've just kind of postponed the
problem, which might help a little bit.

682
00:30:24,020 --> 00:30:25,830
But it doesn't solve the problem.

683
00:30:25,830 --> 00:30:30,700
So linked lists by contrast,
here, allow us to just plop

684
00:30:30,700 --> 00:30:33,540
our numbers wherever we want in RAM.

685
00:30:33,540 --> 00:30:36,807
And we just have to somehow draw the
digital equivalent of these arrows,

686
00:30:36,807 --> 00:30:38,640
so as to sort of stitch
everything together,

687
00:30:38,640 --> 00:30:42,577
like popcorn on a Christmas tree,
that kind of linked list kind of feel.

688
00:30:42,577 --> 00:30:43,910
But this can't be all good like.

689
00:30:43,910 --> 00:30:46,260
Literally nothing we've
done yesterday or today ends

690
00:30:46,260 --> 00:30:48,880
with a perfectly happy ending.

691
00:30:48,880 --> 00:30:51,582
So what's the downside of a linked list?

692
00:30:51,582 --> 00:30:52,791
STUDENT: You can't search it.

693
00:30:52,791 --> 00:30:54,831
DAVID MALAN: You can't
search it in the same way.

694
00:30:54,831 --> 00:30:56,930
You can't do binary
search, because you don't

695
00:30:56,930 --> 00:30:59,320
have random access, because
literally the thing might

696
00:30:59,320 --> 00:31:02,360
be all over your computer's memory.

697
00:31:02,360 --> 00:31:05,620
The upside of which though, to be clear,
is you can grow and even shrink it

698
00:31:05,620 --> 00:31:08,860
dynamically without having to worry
about the annoying back-to-back-to-back

699
00:31:08,860 --> 00:31:09,567
property.

700
00:31:09,567 --> 00:31:10,775
But there's another downside.

701
00:31:10,775 --> 00:31:19,809


702
00:31:19,809 --> 00:31:21,350
STUDENT: If one of the arrows breaks?

703
00:31:21,350 --> 00:31:21,720
DAVID MALAN: OK.

704
00:31:21,720 --> 00:31:23,094
What if one of the arrows breaks?

705
00:31:23,094 --> 00:31:23,750
Could be.

706
00:31:23,750 --> 00:31:25,850
So it's not going to break
on its own, to be fair.

707
00:31:25,850 --> 00:31:27,970
But it is indeed the case.

708
00:31:27,970 --> 00:31:31,300
And one of the reasons that so
few-- well, one of the reasons

709
00:31:31,300 --> 00:31:36,130
C has fallen into disfavor as a go-to
language for many applications is it's

710
00:31:36,130 --> 00:31:37,860
so easy to make mistakes.

711
00:31:37,860 --> 00:31:41,340
Because it turns out when you write
code, it's so easy in a language

712
00:31:41,340 --> 00:31:45,160
like we have on the screen here to make
a typographical error or logical error,

713
00:31:45,160 --> 00:31:48,980
such that the arrow breaks because
you put it in the wrong place.

714
00:31:48,980 --> 00:31:52,340
So it's not going to happen on its
own, but human error is very possible.

715
00:31:52,340 --> 00:31:56,310
And a lot of the sources of problems
in C programs is related to memory.

716
00:31:56,310 --> 00:31:56,926
Yeah?

717
00:31:56,926 --> 00:31:57,759
STUDENT: [INAUDIBLE]

718
00:31:57,759 --> 00:32:01,630


719
00:32:01,630 --> 00:32:02,650
DAVID MALAN: True.

720
00:32:02,650 --> 00:32:03,150
That's true.

721
00:32:03,150 --> 00:32:06,550
So you give up random access, but that's
kind of equivalent to no binary search,

722
00:32:06,550 --> 00:32:09,620
because those are reduced
to the same issue.

723
00:32:09,620 --> 00:32:12,315
STUDENT: Is it difficult
to delete one entry?

724
00:32:12,315 --> 00:32:13,940
DAVID MALAN: Is it difficult to delete?

725
00:32:13,940 --> 00:32:16,045
No, I mean you have to
write the code for it.

726
00:32:16,045 --> 00:32:16,860
It's a few steps.

727
00:32:16,860 --> 00:32:18,150
But once you get it, no.

728
00:32:18,150 --> 00:32:20,100
Then it just works.

729
00:32:20,100 --> 00:32:21,854
So not worrisome.

730
00:32:21,854 --> 00:32:22,808
Yeah, Avi?

731
00:32:22,808 --> 00:32:24,821
AVI: [INAUDIBLE]

732
00:32:24,821 --> 00:32:26,320
DAVID MALAN: Yeah, that's the catch.

733
00:32:26,320 --> 00:32:29,370
It's nice and fine to talk
about things in the abstract.

734
00:32:29,370 --> 00:32:32,750
But as soon as we go back to the
lower level-- at the end of the day,

735
00:32:32,750 --> 00:32:34,040
this is our canvas.

736
00:32:34,040 --> 00:32:36,440
Any ideas we come up
with here verbally, we

737
00:32:36,440 --> 00:32:39,260
have to implement at the end
of the day using just this

738
00:32:39,260 --> 00:32:41,650
as our storage mechanism.

739
00:32:41,650 --> 00:32:44,280
So where do I put all of these arrows?

740
00:32:44,280 --> 00:32:45,000
Well, let's see.

741
00:32:45,000 --> 00:32:50,010
Let me go ahead and erase
all of this for just a moment

742
00:32:50,010 --> 00:32:53,660
and consider just the numbers
in question, the three

743
00:32:53,660 --> 00:32:56,240
that we have at the moment.

744
00:32:56,240 --> 00:32:57,670
And those things look like this.

745
00:32:57,670 --> 00:33:00,970
It was number 20, 32, and 50.

746
00:33:00,970 --> 00:33:02,880
And I'll draw them
roughly the same location.

747
00:33:02,880 --> 00:33:10,630
So 20, 50-- so 20, 32, 50.

748
00:33:10,630 --> 00:33:13,820
So that's roughly where they are, though
I kind of blew it up deliberately.

749
00:33:13,820 --> 00:33:17,620
So previously, I had drawn
arrows from one to the other,

750
00:33:17,620 --> 00:33:19,840
but I can't cross
boundaries like that here.

751
00:33:19,840 --> 00:33:23,040
I can't just draw
arrows anywhere I want.

752
00:33:23,040 --> 00:33:26,640
So the only basic primitive
I have is addressing.

753
00:33:26,640 --> 00:33:33,630
Recall that this is element 0, 1, 2,
3, 4, 5, 6-- it'll be tedious for just

754
00:33:33,630 --> 00:33:42,600
a moment-- 7, 8, 9, 10, 11, 12, 13,
14, 15, 16, 17-- it's going to get

755
00:33:42,600 --> 00:33:48,769
increasingly illegible--
19, 20, 21, 22, 23, 24.

756
00:33:48,769 --> 00:33:50,310
Should've drawn them closer together.

757
00:33:50,310 --> 00:33:51,710
All right.

758
00:33:51,710 --> 00:33:52,360
That's it.

759
00:33:52,360 --> 00:33:53,350
That is our canvas.

760
00:33:53,350 --> 00:33:56,450
That is the extent of the technology
underlying our Macs and PCs

761
00:33:56,450 --> 00:33:57,450
when it comes to memory.

762
00:33:57,450 --> 00:33:58,870
So how do we implement arrows?

763
00:33:58,870 --> 00:34:02,020


764
00:34:02,020 --> 00:34:04,577
STUDENT: Each one takes up
[INAUDIBLE] an extra byte?

765
00:34:04,577 --> 00:34:05,910
DAVID MALAN: An extra bite Yeah.

766
00:34:05,910 --> 00:34:06,650
Let's do that.

767
00:34:06,650 --> 00:34:07,960
Let's be a little greedy.

768
00:34:07,960 --> 00:34:08,810
And you know what?

769
00:34:08,810 --> 00:34:12,050
I can use memory anywhere I want with
this scheme, so let me just go ahead

770
00:34:12,050 --> 00:34:15,610
and say, all right, this
guy-- I'm just going

771
00:34:15,610 --> 00:34:19,960
to draw the border darker-- that
is now one node, so to speak.

772
00:34:19,960 --> 00:34:22,190
It's going to take up two
bytes instead of one byte.

773
00:34:22,190 --> 00:34:22,889
But why?

774
00:34:22,889 --> 00:34:24,439
What did you want to use this for?

775
00:34:24,439 --> 00:34:25,230
STUDENT: A pointer.

776
00:34:25,230 --> 00:34:26,190
DAVID MALAN: A pointer.

777
00:34:26,190 --> 00:34:26,850
The arrow.

778
00:34:26,850 --> 00:34:30,229
So if all I have in terms
of my vocabulary here

779
00:34:30,229 --> 00:34:32,770
is the ability to write down
numbers-- at the end of the day,

780
00:34:32,770 --> 00:34:36,533
addresses-- well, what number
should I put at location 9?

781
00:34:36,533 --> 00:34:38,609
STUDENT: 32?

782
00:34:38,609 --> 00:34:39,400
DAVID MALAN: Close.

783
00:34:39,400 --> 00:34:40,730
You just pointed me over here.

784
00:34:40,730 --> 00:34:41,563
STUDENT: [INAUDIBLE]

785
00:34:41,563 --> 00:34:42,420
DAVID MALAN: 24.

786
00:34:42,420 --> 00:34:46,080
In other words, if I want to
create a sort of treasure map

787
00:34:46,080 --> 00:34:48,150
that leads from one
node to another, just

788
00:34:48,150 --> 00:34:51,389
put the address of the
destination in the map.

789
00:34:51,389 --> 00:34:55,980
So if the address of this byte-- this
is byte number 24, which zero-indexed

790
00:34:55,980 --> 00:34:57,970
is the 25th byte on the screen.

791
00:34:57,970 --> 00:34:59,960
That's just an implementation detail.

792
00:34:59,960 --> 00:35:05,040
Put this here, because now this is
sufficient information-- a breadcrumb,

793
00:35:05,040 --> 00:35:07,890
if you will-- to lead you to
the next number in the list.

794
00:35:07,890 --> 00:35:09,900
Meanwhile, the next number here.

795
00:35:09,900 --> 00:35:12,430
Let's cheat here-- or rather, not cheat.

796
00:35:12,430 --> 00:35:16,760
Let's just be greedy and steal a second
byte, box it in just to stand out.

797
00:35:16,760 --> 00:35:19,550
What number goes here?

798
00:35:19,550 --> 00:35:20,630
12.

799
00:35:20,630 --> 00:35:22,750
Because we want to go to location 12.

800
00:35:22,750 --> 00:35:25,310
So I'm going to put the number 12 here.

801
00:35:25,310 --> 00:35:28,870
And then finally, this guy
here, just for consistency,

802
00:35:28,870 --> 00:35:30,770
I'm going to give him two bytes.

803
00:35:30,770 --> 00:35:33,566
What should go in his second byte?

804
00:35:33,566 --> 00:35:34,462
STUDENT: Eight?

805
00:35:34,462 --> 00:35:35,253
DAVID MALAN: Eight.

806
00:35:35,253 --> 00:35:36,240
Eight, eight, eight.

807
00:35:36,240 --> 00:35:36,740
OK.

808
00:35:36,740 --> 00:35:39,030
If you want to make it a
circular list, perhaps.

809
00:35:39,030 --> 00:35:40,300
So that's possible.

810
00:35:40,300 --> 00:35:44,320
That is a type of data structure,
a linked list that is circular.

811
00:35:44,320 --> 00:35:44,920
Or what else?

812
00:35:44,920 --> 00:35:46,200
What's an alternative?

813
00:35:46,200 --> 00:35:48,824
Because I worry that's going to
get me into dangerous territory

814
00:35:48,824 --> 00:35:53,070
unless I code that properly, because
I could end up searching forever

815
00:35:53,070 --> 00:35:54,636
and never find something.

816
00:35:54,636 --> 00:35:56,630
STUDENT: Essentially a period?

817
00:35:56,630 --> 00:35:57,380
DAVID MALAN: Yeah.

818
00:35:57,380 --> 00:35:59,370
So the computer
equivalent of just period.

819
00:35:59,370 --> 00:36:01,790
And the convention-- there
is no notion of a period

820
00:36:01,790 --> 00:36:03,920
if all we have are
numbers in this context,

821
00:36:03,920 --> 00:36:06,330
so it's actually common
to just put a zero.

822
00:36:06,330 --> 00:36:10,130
So technically, what this means
and what most computers do

823
00:36:10,130 --> 00:36:13,730
is-- there is an address 0, but
you're never allowed to use it.

824
00:36:13,730 --> 00:36:15,090
We steal at least one byte.

825
00:36:15,090 --> 00:36:17,020
In reality, we steal
a bit more than that.

826
00:36:17,020 --> 00:36:20,560
But we deliberately steal
it so that that is invalid.

827
00:36:20,560 --> 00:36:23,320
This is what would be called, if
you've ever heard the term, null.

828
00:36:23,320 --> 00:36:28,677
N-U-L-L. And it's sort of
a black hole, so to speak.

829
00:36:28,677 --> 00:36:29,260
But that's it.

830
00:36:29,260 --> 00:36:31,970
And this is what's kind of cool, I
think, about programming and even just

831
00:36:31,970 --> 00:36:33,303
getting a bit of exposure to it.

832
00:36:33,303 --> 00:36:38,040
As complicated as all of
this might look conceptually

833
00:36:38,040 --> 00:36:40,920
and as ridiculous as the code
might look, at the end of the day

834
00:36:40,920 --> 00:36:43,370
it can't possibly be that
complex, because this

835
00:36:43,370 --> 00:36:46,680
is all it reduces to
underneath the hood,

836
00:36:46,680 --> 00:36:48,650
at least when it comes to storing data.

837
00:36:48,650 --> 00:36:53,630
So there's only so many ways we humans
can come up with ways of storing data.

838
00:36:53,630 --> 00:36:56,470
And we might come up with fancier
ways or more human-friendly ways

839
00:36:56,470 --> 00:36:58,500
of talking about that data.

840
00:36:58,500 --> 00:37:03,250
But it just has to map to fairly
simple primitives, if you will.

841
00:37:03,250 --> 00:37:04,810
All right, still can't be all good.

842
00:37:04,810 --> 00:37:09,180


843
00:37:09,180 --> 00:37:10,500
What price have we paid?

844
00:37:10,500 --> 00:37:14,640
Well, now to your suggestion earlier--
we had three bytes in use earlier,

845
00:37:14,640 --> 00:37:17,520
now how many do we have?

846
00:37:17,520 --> 00:37:20,080
Six now, or seven if we include null.

847
00:37:20,080 --> 00:37:22,710
So we've doubled the
amount of space required.

848
00:37:22,710 --> 00:37:23,990
Now maybe that's negligible.

849
00:37:23,990 --> 00:37:24,740
Maybe it's not.

850
00:37:24,740 --> 00:37:27,120
Back in the day, it probably
wasn't to just double

851
00:37:27,120 --> 00:37:28,720
the amount of memory you're using.

852
00:37:28,720 --> 00:37:31,367
So a linked list is more of an
extravagance, at least, back

853
00:37:31,367 --> 00:37:33,200
when computers had very,
very little memory.

854
00:37:33,200 --> 00:37:35,170
Nowadays if you've got
two gigabytes of memory,

855
00:37:35,170 --> 00:37:39,350
using a bit more space for a pointer,
so to speak-- each of these addresses

856
00:37:39,350 --> 00:37:43,982
is what people would call a
pointer-- is probably reasonable.

857
00:37:43,982 --> 00:37:45,530
But can we do better?

858
00:37:45,530 --> 00:37:48,990
Well, what is the running time
of searching a linked list?

859
00:37:48,990 --> 00:37:55,130
Previously with an array, we had--
let's keep a running list here.

860
00:37:55,130 --> 00:38:00,017
So previously, an array we
said might be as bad as linear,

861
00:38:00,017 --> 00:38:01,350
because if it's in random order.

862
00:38:01,350 --> 00:38:02,600
But we could do better.

863
00:38:02,600 --> 00:38:05,670
It could also be
logarithmic, if it's sorted.

864
00:38:05,670 --> 00:38:06,510
That was good.

865
00:38:06,510 --> 00:38:12,400
A linked list, though, takes how much
time to search in the worst case?

866
00:38:12,400 --> 00:38:15,510


867
00:38:15,510 --> 00:38:16,010
I

868
00:38:16,010 --> 00:38:18,301
Again, n is the length of
the linked list in this case,

869
00:38:18,301 --> 00:38:23,270
so how many steps might it take
us to find someone or some number

870
00:38:23,270 --> 00:38:24,220
in a linked list?

871
00:38:24,220 --> 00:38:26,442
STUDENT: n times 2?

872
00:38:26,442 --> 00:38:27,400
DAVID MALAN: n times 2?

873
00:38:27,400 --> 00:38:28,636
Why that?

874
00:38:28,636 --> 00:38:30,694
STUDENT: [INAUDIBLE]

875
00:38:30,694 --> 00:38:31,610
DAVID MALAN: OK, yeah.

876
00:38:31,610 --> 00:38:34,822
And it's not quite--
yeah, if we're really

877
00:38:34,822 --> 00:38:36,780
going to count the number
of steps, absolutely.

878
00:38:36,780 --> 00:38:38,980
But it's on the order of-- and
this is where computer scientists

879
00:38:38,980 --> 00:38:40,090
would cut verbal corners.

880
00:38:40,090 --> 00:38:43,050
It's on the order of
n-- 2n, 3n, whatever.

881
00:38:43,050 --> 00:38:45,920
A function of n is the
variable for the formula.

882
00:38:45,920 --> 00:38:47,157
So I would write it as that.

883
00:38:47,157 --> 00:38:47,740
Wait a minute.

884
00:38:47,740 --> 00:38:51,937
What if the linked
list is sorted though?

885
00:38:51,937 --> 00:38:52,645
Can we do better?

886
00:38:52,645 --> 00:39:01,192


887
00:39:01,192 --> 00:39:02,696
STUDENT: Can't do binary.

888
00:39:02,696 --> 00:39:03,945
DAVID MALAN: No random access.

889
00:39:03,945 --> 00:39:06,730


890
00:39:06,730 --> 00:39:07,710
STUDENT: [INAUDIBLE]

891
00:39:07,710 --> 00:39:09,060
DAVID MALAN: Yeah, so damn it.

892
00:39:09,060 --> 00:39:11,660
If we haven't shot ourselves
in the foot in this sense,

893
00:39:11,660 --> 00:39:16,270
even if we maintain the linked list
as sorted, at the end of the day,

894
00:39:16,270 --> 00:39:18,310
we might have to search the whole thing.

895
00:39:18,310 --> 00:39:20,782
Even though you might
get lucky, where you just

896
00:39:20,782 --> 00:39:23,490
find it at the beginning of the
list, some number, the worst case

897
00:39:23,490 --> 00:39:24,770
it's going to be at the end of the list.

898
00:39:24,770 --> 00:39:27,436
Or the worst, worst case, it's
not even going to be in the list.

899
00:39:27,436 --> 00:39:30,654
And you're only going to know that once
you've gone through the whole thing.

900
00:39:30,654 --> 00:39:32,070
So that's the worst case scenario.

901
00:39:32,070 --> 00:39:36,230
So the upper bound is
instead big O of n now.

902
00:39:36,230 --> 00:39:37,140
So again, trade off.

903
00:39:37,140 --> 00:39:39,181
Just when it felt like we
were getting somewhere,

904
00:39:39,181 --> 00:39:42,520
now we've kind of hurt ourselves again.

905
00:39:42,520 --> 00:39:46,620
So what might be better than this?

906
00:39:46,620 --> 00:39:49,349
What else could we do?

907
00:39:49,349 --> 00:39:51,640
Well, it turns out there's
other data structures still.

908
00:39:51,640 --> 00:39:53,880
And now we'll move away
from the low level details.

909
00:39:53,880 --> 00:39:56,800
Because again, just like yesterday,
once you get stuck in the weeds,

910
00:39:56,800 --> 00:40:00,830
it very quickly becomes sort
of boring, if not complicated.

911
00:40:00,830 --> 00:40:02,040
Let's just do a picture.

912
00:40:02,040 --> 00:40:07,580
Well, it turns out that a
variation on using a linked list

913
00:40:07,580 --> 00:40:12,100
would be to use this new feature--
these arrows, AKA pointers--

914
00:40:12,100 --> 00:40:14,940
but create the equivalent
of a family tree.

915
00:40:14,940 --> 00:40:17,490
So for instance, if I've
got a whole bunch of numbers

916
00:40:17,490 --> 00:40:23,922
here, like the number 32-- I'm
going to draw it as just a circle

917
00:40:23,922 --> 00:40:26,630
to be different this time, just
to be consistent with convention.

918
00:40:26,630 --> 00:40:28,700
I'm going to draw 32 here.

919
00:40:28,700 --> 00:40:34,860
I'm going to draw let's say, 50 here.

920
00:40:34,860 --> 00:40:38,499
And then see if you can infer
where I'm going with this.

921
00:40:38,499 --> 00:40:40,790
What two numbers should I
put on the left and the right

922
00:40:40,790 --> 00:40:44,405
respectively, if again I'm stealing
those same seven numbers as before?

923
00:40:44,405 --> 00:40:47,770


924
00:40:47,770 --> 00:40:49,886
I heard 42 and then 99.

925
00:40:49,886 --> 00:40:51,560
So let's try that.

926
00:40:51,560 --> 00:40:52,240
Whoops.

927
00:40:52,240 --> 00:40:53,520
Or 49.

928
00:40:53,520 --> 00:40:55,650
42.

929
00:40:55,650 --> 00:40:56,420
99.

930
00:40:56,420 --> 00:40:58,450
And let me fill in the blank here now.

931
00:40:58,450 --> 00:41:01,550
I'm going to put three circles here.

932
00:41:01,550 --> 00:41:05,930
What would you propose I put left,
middle, right, in that order?

933
00:41:05,930 --> 00:41:08,500


934
00:41:08,500 --> 00:41:11,770
5, 10, 20.

935
00:41:11,770 --> 00:41:15,970
Now, in fairness we've just
transcribed left to right everything.

936
00:41:15,970 --> 00:41:17,600
So maybe we're getting lucky.

937
00:41:17,600 --> 00:41:20,360
But there's some logic to this.

938
00:41:20,360 --> 00:41:23,270
What is true about this structure?

939
00:41:23,270 --> 00:41:27,470
There's a property, if you will.

940
00:41:27,470 --> 00:41:29,321
This was either lucky or smart.

941
00:41:29,321 --> 00:41:29,820
Or both.

942
00:41:29,820 --> 00:41:35,320


943
00:41:35,320 --> 00:41:37,920
STUDENT: [INAUDIBLE]

944
00:41:37,920 --> 00:41:38,670
DAVID MALAN: True.

945
00:41:38,670 --> 00:41:40,790
That's in the center, but that's
not really a generalization.

946
00:41:40,790 --> 00:41:41,870
Give me something deeper.

947
00:41:41,870 --> 00:41:43,880
STUDENT: It gets you
anywhere in three steps.

948
00:41:43,880 --> 00:41:45,921
DAVID MALAN: It gets you
anywhere in three steps.

949
00:41:45,921 --> 00:41:46,980
That is true.

950
00:41:46,980 --> 00:41:51,087
But if I start adding more data,
that's not general enough for me.

951
00:41:51,087 --> 00:41:51,920
STUDENT: [INAUDIBLE]

952
00:41:51,920 --> 00:41:55,140


953
00:41:55,140 --> 00:41:57,000
DAVID MALAN: The array,
specifically the--

954
00:41:57,000 --> 00:41:57,760
STUDENT: The log.

955
00:41:57,760 --> 00:41:58,510
DAVID MALAN: Yeah.

956
00:41:58,510 --> 00:42:00,100
We have this logarithmic property.

957
00:42:00,100 --> 00:42:05,600
It's viewed from a different angle,
because if you think of the--

958
00:42:05,600 --> 00:42:10,000
Log n actually describes the height
of this family tree, if you will--

959
00:42:10,000 --> 00:42:12,840
or one, two, three, so
height minus 1 of this tree.

960
00:42:12,840 --> 00:42:17,772
If the height is 1, 2, log base 2
of eight elements or seven elements

961
00:42:17,772 --> 00:42:18,480
is going to be 3.

962
00:42:18,480 --> 00:42:20,467
So it's about that.

963
00:42:20,467 --> 00:42:22,425
But there's another
property here. [INAUDIBLE]?

964
00:42:22,425 --> 00:42:24,299
STUDENT: You don't have
to search every node.

965
00:42:24,299 --> 00:42:27,808


966
00:42:27,808 --> 00:42:31,446
The top of the node is the middle one.

967
00:42:31,446 --> 00:42:32,320
DAVID MALAN: Exactly.

968
00:42:32,320 --> 00:42:34,890
Or put more formally,
each of these nodes

969
00:42:34,890 --> 00:42:38,880
represents the root of a binary
tree, as we would call it--

970
00:42:38,880 --> 00:42:42,740
a binary tree meaning a tree
whose nodes have zero, one,

971
00:42:42,740 --> 00:42:44,440
or two maximally children.

972
00:42:44,440 --> 00:42:47,240
So bi meaning two, two children max.

973
00:42:47,240 --> 00:42:49,670
And more specifically,
every node in this tree

974
00:42:49,670 --> 00:42:53,810
is a binary search tree, which has
exactly [INAUDIBLE] property, which

975
00:42:53,810 --> 00:42:58,850
is the left child is smaller
than the root and the right child

976
00:42:58,850 --> 00:43:00,110
is greater than the root.

977
00:43:00,110 --> 00:43:02,380
And this was the
general definition I was

978
00:43:02,380 --> 00:43:04,680
looking for whereby I
could make that sentence

979
00:43:04,680 --> 00:43:07,350
hold for every one of
the nodes in the tree,

980
00:43:07,350 --> 00:43:09,550
irrespective of how big the
tree is and irrespective

981
00:43:09,550 --> 00:43:10,770
of the numbers in the tree.

982
00:43:10,770 --> 00:43:13,840
So yes 32's in the top,
but that's uninteresting.

983
00:43:13,840 --> 00:43:19,500
What's interesting is that 32 is bigger
than 10, and 32 is smaller than 50.

984
00:43:19,500 --> 00:43:23,490
42 is smaller than 50,
and 99 is bigger than 50.

985
00:43:23,490 --> 00:43:25,660
That same relationship
holds at every node.

986
00:43:25,660 --> 00:43:26,760
So what does this mean?

987
00:43:26,760 --> 00:43:30,349
If now I only have access-- as would
be the convention in a computer,

988
00:43:30,349 --> 00:43:33,140
I only have the ability to look at
one thing at a time, by default,

989
00:43:33,140 --> 00:43:36,380
I'm always going to look at the top
rather than some arbitrary element.

990
00:43:36,380 --> 00:43:39,770
So if I always have a pointer, so
to speak, to the root of this tree,

991
00:43:39,770 --> 00:43:41,760
how many steps now does
it take me maximally

992
00:43:41,760 --> 00:43:44,780
to find any element in the tree?

993
00:43:44,780 --> 00:43:45,780
Three.

994
00:43:45,780 --> 00:43:47,540
Because I look at the top.

995
00:43:47,540 --> 00:43:49,630
If it's not there, I
go left or I go right.

996
00:43:49,630 --> 00:43:51,590
If it's not there, I
go left or I go right.

997
00:43:51,590 --> 00:43:53,780
And then I'm at the leaves
of the tree, so I'm done.

998
00:43:53,780 --> 00:43:55,870
So it's either there or it isn't.

999
00:43:55,870 --> 00:43:58,700
So now we've borrowed ideas from both.

1000
00:43:58,700 --> 00:44:02,100
We still don't have random
access, but because we've

1001
00:44:02,100 --> 00:44:04,430
made this a two-dimensional
data structure and not

1002
00:44:04,430 --> 00:44:07,010
a one-dimensional data
structure, this depth

1003
00:44:07,010 --> 00:44:10,480
is allowing us to bring
back that feature of divide

1004
00:44:10,480 --> 00:44:15,240
and conquer by just laying things
out in memory a little more cleverly.

1005
00:44:15,240 --> 00:44:18,970
So if we now have what's called,
again, a binary search tree--

1006
00:44:18,970 --> 00:44:25,864
BST-- the maximum number of steps it
might take us to find a number is what?

1007
00:44:25,864 --> 00:44:26,720
STUDENT: Log n.

1008
00:44:26,720 --> 00:44:27,850
DAVID MALAN: Log n, again.

1009
00:44:27,850 --> 00:44:32,720
So we've done better now
than the linked list.

1010
00:44:32,720 --> 00:44:36,230
So what's the downside?

1011
00:44:36,230 --> 00:44:39,140
Always a catch.

1012
00:44:39,140 --> 00:44:41,911
What's the catch this time?

1013
00:44:41,911 --> 00:44:46,300
STUDENT: How much space does two
pointers from each data point--

1014
00:44:46,300 --> 00:44:47,320
DAVID MALAN: Good catch.

1015
00:44:47,320 --> 00:44:47,820
Yes.

1016
00:44:47,820 --> 00:44:49,150
So three, technically.

1017
00:44:49,150 --> 00:44:53,470
So if we look back at our memory, to
implement a binary search tree node,

1018
00:44:53,470 --> 00:44:56,360
now we need one, two,
three, one two three.

1019
00:44:56,360 --> 00:44:57,650
So we pay a bit of a price.

1020
00:44:57,650 --> 00:44:58,880
So more memory for sure.

1021
00:44:58,880 --> 00:45:02,600


1022
00:45:02,600 --> 00:45:07,042
And what else might
bite us in the end here?

1023
00:45:07,042 --> 00:45:08,300
STUDENT: [INAUDIBLE]

1024
00:45:08,300 --> 00:45:09,050
DAVID MALAN: Yeah.

1025
00:45:09,050 --> 00:45:11,440
How do we add stuff in the middle?

1026
00:45:11,440 --> 00:45:12,460
So it's possible.

1027
00:45:12,460 --> 00:45:15,560
Suppose I want to add the number 21.

1028
00:45:15,560 --> 00:45:18,870
A naive approach might be--
OK, start where the root is.

1029
00:45:18,870 --> 00:45:20,880
And I know 21 is smaller,
so I go this way.

1030
00:45:20,880 --> 00:45:22,460
I know 21 is bigger than 10.

1031
00:45:22,460 --> 00:45:23,260
So I go this way.

1032
00:45:23,260 --> 00:45:24,810
I know 21 is bigger than 20.

1033
00:45:24,810 --> 00:45:26,620
OK, there's nowhere more to go.

1034
00:45:26,620 --> 00:45:29,760
So let me just create a new arrow--
so use that additional byte--

1035
00:45:29,760 --> 00:45:31,890
and put 21 here.

1036
00:45:31,890 --> 00:45:35,160
But an interesting issue now
is-- suppose I want to insert 22.

1037
00:45:35,160 --> 00:45:35,920
Where does it go?

1038
00:45:35,920 --> 00:45:38,620


1039
00:45:38,620 --> 00:45:40,350
Logically, we can skip the verbal steps.

1040
00:45:40,350 --> 00:45:41,180
22's down there.

1041
00:45:41,180 --> 00:45:43,300
Where does 23 go?

1042
00:45:43,300 --> 00:45:44,254
How about 24?

1043
00:45:44,254 --> 00:45:44,753
25?

1044
00:45:44,753 --> 00:45:45,204
26?

1045
00:45:45,204 --> 00:45:45,655
27?

1046
00:45:45,655 --> 00:45:46,154
28?

1047
00:45:46,154 --> 00:45:46,720
29?

1048
00:45:46,720 --> 00:45:49,000
I'm not going to bother drawing it,
partly because I've run out of space,

1049
00:45:49,000 --> 00:45:50,840
because I didn't anticipate this.

1050
00:45:50,840 --> 00:45:53,860
But what does this kind of
devolve into eventually?

1051
00:45:53,860 --> 00:45:54,914
STUDENT: An array.

1052
00:45:54,914 --> 00:45:55,830
DAVID MALAN: An array.

1053
00:45:55,830 --> 00:46:00,440
Well, not an array, because
it's still non-contiguous.

1054
00:46:00,440 --> 00:46:01,960
A linked list.

1055
00:46:01,960 --> 00:46:05,120
So indeed, depending on
the order in which we first

1056
00:46:05,120 --> 00:46:08,010
insert these nodes, if we
have the same numbers again--

1057
00:46:08,010 --> 00:46:10,640
suppose I start with an
empty binary search tree

1058
00:46:10,640 --> 00:46:12,030
and I insert the first number 5.

1059
00:46:12,030 --> 00:46:14,200
It's going to go there, because
it's got to go at the top.

1060
00:46:14,200 --> 00:46:15,720
And then I insert the number 10.

1061
00:46:15,720 --> 00:46:16,740
Where does it go?

1062
00:46:16,740 --> 00:46:18,230
Well, to the right.

1063
00:46:18,230 --> 00:46:19,720
Well, where do I put the number 20?

1064
00:46:19,720 --> 00:46:20,730
Well, to the right.

1065
00:46:20,730 --> 00:46:22,210
Where does 32 go?

1066
00:46:22,210 --> 00:46:23,110
To the right.

1067
00:46:23,110 --> 00:46:25,640
And then so you can very
easily construct a scenario

1068
00:46:25,640 --> 00:46:27,810
where it's not even
problematic eventually--

1069
00:46:27,810 --> 00:46:29,380
it's a problem from the outset.

1070
00:46:29,380 --> 00:46:35,200
If you get unlucky and you have
just a bad sequence of insertions,

1071
00:46:35,200 --> 00:46:37,220
you end up really with a linked list.

1072
00:46:37,220 --> 00:46:38,910
So damn it.

1073
00:46:38,910 --> 00:46:40,180
How do we fix this now?

1074
00:46:40,180 --> 00:46:43,390


1075
00:46:43,390 --> 00:46:45,380
Now as I hear myself
bemoaning the trade-offs,

1076
00:46:45,380 --> 00:46:47,796
I feel like no one's should
ever go into computer science,

1077
00:46:47,796 --> 00:46:50,000
because it's completely frustrating.

1078
00:46:50,000 --> 00:46:53,000
But so be it.

1079
00:46:53,000 --> 00:46:54,190
How do we fix this?

1080
00:46:54,190 --> 00:46:59,470


1081
00:46:59,470 --> 00:47:03,170
STUDENT: Make new numbers in the nodes.

1082
00:47:03,170 --> 00:47:05,120
DAVID MALAN: Make new
numbers in the nodes.

1083
00:47:05,120 --> 00:47:08,100
OK, so we could start
changing what's in the-- OK,

1084
00:47:08,100 --> 00:47:11,560
so we can make sure that we always
build a tree that look structurally

1085
00:47:11,560 --> 00:47:14,320
like our original one here--
nicely balanced, so to speak--

1086
00:47:14,320 --> 00:47:16,445
and we just move the numbers
around or change them.

1087
00:47:16,445 --> 00:47:17,400
So that's fine.

1088
00:47:17,400 --> 00:47:20,540
I would argue-- it's
definitely doable in code,

1089
00:47:20,540 --> 00:47:23,125
but you start moving
so much stuff around.

1090
00:47:23,125 --> 00:47:29,410
It's perhaps not ideal necessarily
to just start moving too much around.

1091
00:47:29,410 --> 00:47:35,077
But that's actually halfway to
what's the common solution here.

1092
00:47:35,077 --> 00:47:35,910
STUDENT: [INAUDIBLE]

1093
00:47:35,910 --> 00:47:39,080


1094
00:47:39,080 --> 00:47:39,830
DAVID MALAN: Yeah.

1095
00:47:39,830 --> 00:47:40,862
Thank about this.

1096
00:47:40,862 --> 00:47:42,570
Let's take this simple
example where this

1097
00:47:42,570 --> 00:47:45,730
was starting to devolve into
just an annoying linked list.

1098
00:47:45,730 --> 00:47:46,880
How can I fix this?

1099
00:47:46,880 --> 00:47:47,860
Forget about 23.

1100
00:47:47,860 --> 00:47:48,730
We're not there yet.

1101
00:47:48,730 --> 00:47:52,020
All we've done is insert 20, 21, and 22.

1102
00:47:52,020 --> 00:47:55,140
How could I fix this so that
it doesn't devolve subsequently

1103
00:47:55,140 --> 00:47:56,510
back into a linked list?

1104
00:47:56,510 --> 00:48:00,510
There's an easy tweak I can
make an eraser and a marker.

1105
00:48:00,510 --> 00:48:01,360
Yeah, Dan?

1106
00:48:01,360 --> 00:48:07,656
DAN: We could go to the next
[INAUDIBLE] the empty option,

1107
00:48:07,656 --> 00:48:12,044
where you would go to
the left of 42, instead--

1108
00:48:12,044 --> 00:48:13,210
DAVID MALAN: The left of 42.

1109
00:48:13,210 --> 00:48:13,709
OK.

1110
00:48:13,709 --> 00:48:18,170
So but that's going to violate
the recursive property that

1111
00:48:18,170 --> 00:48:23,484
says 32 has to be smaller than
all the elements to the right.

1112
00:48:23,484 --> 00:48:25,400
And that's not technically
what I said before,

1113
00:48:25,400 --> 00:48:28,605
but it follows through transitivity
by looking respectively

1114
00:48:28,605 --> 00:48:33,590
at each of the children, which has to be
larger than its parent on that branch.

1115
00:48:33,590 --> 00:48:34,362
Yeah?

1116
00:48:34,362 --> 00:48:36,250
STUDENT: Instead of
rewriting the tree, just

1117
00:48:36,250 --> 00:48:41,190
go to the leaf of the smallest node
that you could just rewrite a subset.

1118
00:48:41,190 --> 00:48:42,740
DAVID MALAN: Yeah, so just a subset.

1119
00:48:42,740 --> 00:48:44,600
So let's merge your ideas.

1120
00:48:44,600 --> 00:48:51,200
And I feel like if I had scissors, I
might snip it right here, for instance,

1121
00:48:51,200 --> 00:48:53,570
thereby detaching this little chain.

1122
00:48:53,570 --> 00:48:58,070
And who would make a better candidate
as the root of this mini tree?

1123
00:48:58,070 --> 00:48:59,080
Yeah, so 21.

1124
00:48:59,080 --> 00:49:00,480
So let me just fix this.

1125
00:49:00,480 --> 00:49:02,570
And I can use the same
memory, but the eraser's

1126
00:49:02,570 --> 00:49:05,290
easier to do mechanically here.

1127
00:49:05,290 --> 00:49:11,460
So what if I redraw this as 20,
21, 22, and make 21 the new node.

1128
00:49:11,460 --> 00:49:15,500
So this is similar in spirit to what
I think Dan was getting at earlier,

1129
00:49:15,500 --> 00:49:17,380
or to what Griff was getting at earlier.

1130
00:49:17,380 --> 00:49:19,640
But instead of rewriting
too much of this tree,

1131
00:49:19,640 --> 00:49:22,050
we could really just
focus on the subtree

1132
00:49:22,050 --> 00:49:25,120
into which we want to insert this node.

1133
00:49:25,120 --> 00:49:29,100
And indeed, now it's still getting
a little long on this side,

1134
00:49:29,100 --> 00:49:31,290
but we're not in such bad shape yet.

1135
00:49:31,290 --> 00:49:36,160
Because if we end up getting more
nodes here and here, then maybe

1136
00:49:36,160 --> 00:49:40,652
here and here, and here and
here, here and here-- which

1137
00:49:40,652 --> 00:49:43,610
you could imagine coming up with the
numbers to make sure that happens,

1138
00:49:43,610 --> 00:49:46,672
eventually the tree gets a little
long and stringy on the left.

1139
00:49:46,672 --> 00:49:48,880
So fundamentally what do we
have to do at that point?

1140
00:49:48,880 --> 00:49:51,450


1141
00:49:51,450 --> 00:49:55,200
Yeah, so instead of using 32 as
the node, maybe what I want to do

1142
00:49:55,200 --> 00:49:58,565
is snip, snip there, rotate
the tree a little bit--

1143
00:49:58,565 --> 00:50:00,190
and I have to fix some of the pointers.

1144
00:50:00,190 --> 00:50:03,650
I have to make a few snips this
time, because the problem is so big.

1145
00:50:03,650 --> 00:50:06,790
But it turns out that I can
fix this by really just making

1146
00:50:06,790 --> 00:50:11,390
one snip and rotation per
height of the tree-- which

1147
00:50:11,390 --> 00:50:14,940
is to say that per our
running time earlier,

1148
00:50:14,940 --> 00:50:18,400
it might take me log of n steps to
figure out where the new node goes,

1149
00:50:18,400 --> 00:50:21,820
and then I regret it because damn, now
the tree's getting a little stringy.

1150
00:50:21,820 --> 00:50:22,660
It's OK.

1151
00:50:22,660 --> 00:50:25,440
Just by going back up
the tree log n steps,

1152
00:50:25,440 --> 00:50:28,960
I can kind of rotate things
over-- snip, snip, reattach--

1153
00:50:28,960 --> 00:50:31,110
in roughly the same number of steps.

1154
00:50:31,110 --> 00:50:34,530
So it's two times log of n, which
is surely bigger than just log of n.

1155
00:50:34,530 --> 00:50:37,530
But again, to my claim earlier that
a computer scientist would generally

1156
00:50:37,530 --> 00:50:40,310
ignore these constant
numbers like two, the reality

1157
00:50:40,310 --> 00:50:43,020
is, in practice, doing log
n steps versus two log n

1158
00:50:43,020 --> 00:50:44,920
steps-- it's almost the same thing.

1159
00:50:44,920 --> 00:50:46,780
It's not worrisome fundamentally.

1160
00:50:46,780 --> 00:50:49,870
What's more worrisome is
if it's like n squared or n

1161
00:50:49,870 --> 00:50:53,340
cubed, when it's the big number that
depends on the size of the problem.

1162
00:50:53,340 --> 00:50:58,000
Constant numbers, like multiplying by
2, we don't really care theoretically.

1163
00:50:58,000 --> 00:51:03,620
So the binary search tree can
remain this if we balance it.

1164
00:51:03,620 --> 00:51:10,910
And so technically, a binary
search tree is big O of n,

1165
00:51:10,910 --> 00:51:14,010
Because technically a linked
list is a binary search tree.

1166
00:51:14,010 --> 00:51:16,590
It's just a crazy incarnation of one.

1167
00:51:16,590 --> 00:51:18,500
But what we're describing
here is something

1168
00:51:18,500 --> 00:51:22,770
that's generally called an AVL
tree, which is still a binary tree,

1169
00:51:22,770 --> 00:51:27,820
but by its own definition it maintains
balance by doing the snip-snip approach

1170
00:51:27,820 --> 00:51:31,520
and rotating as needed in order to
make sure it's not devolving back

1171
00:51:31,520 --> 00:51:34,020
into a linked list.

1172
00:51:34,020 --> 00:51:34,610
All right.

1173
00:51:34,610 --> 00:51:36,370
So now we seem to be getting somewhere.

1174
00:51:36,370 --> 00:51:39,040


1175
00:51:39,040 --> 00:51:45,070
What goals might we still have when
it comes to data and data structures?

1176
00:51:45,070 --> 00:51:46,285
How could we do even better?

1177
00:51:46,285 --> 00:51:50,370


1178
00:51:50,370 --> 00:51:50,870
Yeah?

1179
00:51:50,870 --> 00:51:53,066
STUDENT: How about dedicating memory?

1180
00:51:53,066 --> 00:51:55,970
I know graphs are able to dedicate
memory just for their own options,

1181
00:51:55,970 --> 00:52:00,810
then just leaving integers and
zeros if they're not being used.

1182
00:52:00,810 --> 00:52:03,250
So you can just do--

1183
00:52:03,250 --> 00:52:04,320
DAVID MALAN: Yeah.

1184
00:52:04,320 --> 00:52:06,330
So that's perfectly fine.

1185
00:52:06,330 --> 00:52:08,200
It doesn't fundamentally
solve the problem,

1186
00:52:08,200 --> 00:52:11,870
because even they have to decide in
advance how much memory to allocate.

1187
00:52:11,870 --> 00:52:13,209
And arguably, it's wasteful.

1188
00:52:13,209 --> 00:52:15,500
And you might feel that,
because if you're like a gamer

1189
00:52:15,500 --> 00:52:18,640
and you install your own
graphics card to speed things up,

1190
00:52:18,640 --> 00:52:22,800
you're literally spending more money to
get that feature, so totally possible.

1191
00:52:22,800 --> 00:52:23,700
But it's a trade-off.

1192
00:52:23,700 --> 00:52:27,200
You're being somewhat
more wasteful as a result.

1193
00:52:27,200 --> 00:52:29,856
Good question.

1194
00:52:29,856 --> 00:52:30,480
Other thoughts?

1195
00:52:30,480 --> 00:52:34,030


1196
00:52:34,030 --> 00:52:36,989
I mean, what's better
than big O of log n?

1197
00:52:36,989 --> 00:52:38,530
That feels like it's the progression.

1198
00:52:38,530 --> 00:52:40,200
We're chipping away at the problem.

1199
00:52:40,200 --> 00:52:41,350
So what should come next?

1200
00:52:41,350 --> 00:52:44,411


1201
00:52:44,411 --> 00:52:45,410
What would be the ideal?

1202
00:52:45,410 --> 00:52:48,470
What's the holy grail of search times?

1203
00:52:48,470 --> 00:52:51,470
What's the fewest number
of steps you would enjoy

1204
00:52:51,470 --> 00:52:54,590
allowing to find some piece of data?

1205
00:52:54,590 --> 00:52:55,090
One!

1206
00:52:55,090 --> 00:52:57,560
Feels like-- I mean, it can't be
zero, because that makes no sense.

1207
00:52:57,560 --> 00:52:58,140
You're doing no work.

1208
00:52:58,140 --> 00:52:59,181
You have to do some work.

1209
00:52:59,181 --> 00:53:00,550
Well, one step.

1210
00:53:00,550 --> 00:53:01,720
So can we get there?

1211
00:53:01,720 --> 00:53:09,300
Well, turns out there's a data
structure that aspires to be big O of 1.

1212
00:53:09,300 --> 00:53:10,180
This is misleading.

1213
00:53:10,180 --> 00:53:14,200
It's not actually typically big
O of 1, but that's the ideal.

1214
00:53:14,200 --> 00:53:16,400
And how can we implement
something like that?

1215
00:53:16,400 --> 00:53:21,250
Well, turns out that a hash table and--
you mentioned earlier a dictionary.

1216
00:53:21,250 --> 00:53:25,040
A dictionary actually
is the high level term

1217
00:53:25,040 --> 00:53:28,820
used to describe the functionality
that a hash table gives you.

1218
00:53:28,820 --> 00:53:31,410
A hash table would typically do this.

1219
00:53:31,410 --> 00:53:33,865
Just as we've seen a
binary search tree--

1220
00:53:33,865 --> 00:53:38,165
it can borrow ideas from say,
an array and a linked list.

1221
00:53:38,165 --> 00:53:45,050
A hash table, in turn, can borrow
ideas from an array and a linked list,

1222
00:53:45,050 --> 00:53:46,350
but in a different way.

1223
00:53:46,350 --> 00:53:48,300
What a hash table
typically does is this.

1224
00:53:48,300 --> 00:53:53,780
Suppose we're implementing a hash
table for everyone's birthdays

1225
00:53:53,780 --> 00:53:55,960
in the room or birth months, let's say.

1226
00:53:55,960 --> 00:53:58,520
So we want to put everyone
in this room into a bucket--

1227
00:53:58,520 --> 00:54:01,290
January, February, March, April,
May, all the way to December.

1228
00:54:01,290 --> 00:54:08,350
So the problem here is that we
could use, for instance, an array.

1229
00:54:08,350 --> 00:54:10,220
So let's draw it like this.

1230
00:54:10,220 --> 00:54:10,720
[INAUDIBLE]

1231
00:54:10,720 --> 00:54:16,000


1232
00:54:16,000 --> 00:54:19,030
1, 2, 3, 4, 5 6, 7, 8, 9, 10, 11, 12.

1233
00:54:19,030 --> 00:54:26,507
So this is January, February,
March, dot, dot, dot, December.

1234
00:54:26,507 --> 00:54:27,340
So this is an array.

1235
00:54:27,340 --> 00:54:30,570
And rather than talking about numbers,
we can talk about people's names.

1236
00:54:30,570 --> 00:54:35,660
And just for demonstration's sake,
does anyone have a January birthday?

1237
00:54:35,660 --> 00:54:37,220
OK, so Shivang?

1238
00:54:37,220 --> 00:54:42,150
So Shivang and just Shivang.

1239
00:54:42,150 --> 00:54:43,810
How about-- oh, and Dan.

1240
00:54:43,810 --> 00:54:44,740
Perfect!

1241
00:54:44,740 --> 00:54:46,307
Already we have a problem.

1242
00:54:46,307 --> 00:54:48,640
I can only fit one of you in
this data structure, right?

1243
00:54:48,640 --> 00:54:52,300
Because if we try to put
Dan in the same bucket--

1244
00:54:52,300 --> 00:54:53,790
this is finite amount of memory.

1245
00:54:53,790 --> 00:54:57,220
And maybe it's more than one byte now,
because we need to tolerate names.

1246
00:54:57,220 --> 00:54:59,780
But we can only put one name
at the time, I claim today.

1247
00:54:59,780 --> 00:55:02,710
So Dan or Shivang,
one of you's gotta go.

1248
00:55:02,710 --> 00:55:04,580
So where could we put you?

1249
00:55:04,580 --> 00:55:08,504
Where could we put Dan if Shivang's
already taking up that space?

1250
00:55:08,504 --> 00:55:09,800
STUDENT: In February.

1251
00:55:09,800 --> 00:55:10,841
DAVID MALAN: In February.

1252
00:55:10,841 --> 00:55:11,560
So we could.

1253
00:55:11,560 --> 00:55:15,270
Unfortunately, we're just kind
of ignoring the problem, which

1254
00:55:15,270 --> 00:55:16,420
might get us through.

1255
00:55:16,420 --> 00:55:19,670
But unfortunately with 20
plus people and 12 buckets,

1256
00:55:19,670 --> 00:55:22,650
somebody's going to be left without
a chair, so to speak, at the end.

1257
00:55:22,650 --> 00:55:25,120
For instance, does anyone
have a February birthday?

1258
00:55:25,120 --> 00:55:27,400
So Shawn and Owen.

1259
00:55:27,400 --> 00:55:28,580
So now, OK.

1260
00:55:28,580 --> 00:55:31,610
So how about one of you
moves to March and April?

1261
00:55:31,610 --> 00:55:35,570
And so this is actually an example
of a technique called linear probing,

1262
00:55:35,570 --> 00:55:37,580
whereby you have a data structure.

1263
00:55:37,580 --> 00:55:41,280
You try to put the data where
you intend for it to go.

1264
00:55:41,280 --> 00:55:45,920
But if not, you probe progressively
for an additional free spot,

1265
00:55:45,920 --> 00:55:48,370
so as to at least fit the
data into the data structure.

1266
00:55:48,370 --> 00:55:50,400
So in the best case,
it's where you expect.

1267
00:55:50,400 --> 00:55:55,490
But in the worst case, where
might Dan or Owen actually end up

1268
00:55:55,490 --> 00:55:58,570
if we keep running into these
collisions where two names are

1269
00:55:58,570 --> 00:56:01,256
trying to go in the same place?

1270
00:56:01,256 --> 00:56:04,590
In the worst case, Owen and Dan
might end up all the way in December,

1271
00:56:04,590 --> 00:56:07,960
especially if there's more people with
February or March or April birthdays.

1272
00:56:07,960 --> 00:56:11,120
So at the end of the day, we're
trying to get to constant time.

1273
00:56:11,120 --> 00:56:12,450
One step to find Dan.

1274
00:56:12,450 --> 00:56:14,950
One step to find Owen and Shivang.

1275
00:56:14,950 --> 00:56:20,920
But if we're arbitrarily as a hack
moving Owen or Shawn over here,

1276
00:56:20,920 --> 00:56:23,270
then it's just back to linear.

1277
00:56:23,270 --> 00:56:26,680
And we seem to have regressed
back to where we were earlier.

1278
00:56:26,680 --> 00:56:28,730
So how do we fix this fundamentally?

1279
00:56:28,730 --> 00:56:33,220
It's not good if we can only handle
12 students in a '20 plus student

1280
00:56:33,220 --> 00:56:34,240
classroom.

1281
00:56:34,240 --> 00:56:38,400
We want to handle everyone, and we want
to remember everyone's birthday month.

1282
00:56:38,400 --> 00:56:40,770
What could we do pictorially
to deal with this?

1283
00:56:40,770 --> 00:56:41,980
What would you do?

1284
00:56:41,980 --> 00:56:43,860
STUDENT: [INAUDIBLE]

1285
00:56:43,860 --> 00:56:45,110
DAVID MALAN: So cut into half.

1286
00:56:45,110 --> 00:56:46,984
Unfortunately, if I do
this, we're only going

1287
00:56:46,984 --> 00:56:51,730
to fit like "Ow" here and "Sh" for
Shawn, because it's finite memory.

1288
00:56:51,730 --> 00:56:57,430
So it's not quite as simple as just
chopping the chunks of memory in half.

1289
00:56:57,430 --> 00:56:59,360
What else could we do?

1290
00:56:59,360 --> 00:57:01,199
STUDENT: Add a second byte.

1291
00:57:01,199 --> 00:57:02,490
DAVID MALAN: Add a second byte.

1292
00:57:02,490 --> 00:57:05,254
So we can't necessarily steal
February's byte like before

1293
00:57:05,254 --> 00:57:07,420
and merge January and
February, because we'd devolve

1294
00:57:07,420 --> 00:57:08,878
right back into the same situation.

1295
00:57:08,878 --> 00:57:12,160
We can only do that like six
times before we're out of memory.

1296
00:57:12,160 --> 00:57:14,870
But where could we
steal another byte from?

1297
00:57:14,870 --> 00:57:15,990
I've only drawn this.

1298
00:57:15,990 --> 00:57:17,740
But this is the high
level representation.

1299
00:57:17,740 --> 00:57:20,110
At the end of the day,
this is our canvas.

1300
00:57:20,110 --> 00:57:22,130
So, so to speak, we could go below it.

1301
00:57:22,130 --> 00:57:26,460
And again, the grid here
is just a conceptual thing.

1302
00:57:26,460 --> 00:57:28,090
It's just a sequence of bytes.

1303
00:57:28,090 --> 00:57:29,490
But we could certainly do this.

1304
00:57:29,490 --> 00:57:33,180
And in fact, you know what--
it's not available here.

1305
00:57:33,180 --> 00:57:36,339
There's no free memory right
here in our other picture.

1306
00:57:36,339 --> 00:57:38,630
But maybe there's some over
here, over here, over here.

1307
00:57:38,630 --> 00:57:40,180
So let's borrow some of those ideas.

1308
00:57:40,180 --> 00:57:45,377
What do we do to give some
extra space to January?

1309
00:57:45,377 --> 00:57:47,210
STUDENT: Make it into
another twelve months?

1310
00:57:47,210 --> 00:57:47,940
DAVID MALAN: Make it into a what?

1311
00:57:47,940 --> 00:57:49,100
STUDENT: Another twelve months.

1312
00:57:49,100 --> 00:57:50,180
DAVID MALAN: Another 12 months.

1313
00:57:50,180 --> 00:57:51,888
So we could do that,
but that's overkill.

1314
00:57:51,888 --> 00:57:54,250
I just need room for
like Shawn and Owen here.

1315
00:57:54,250 --> 00:57:57,560
We just need to create a little
bit of space, not 12 more spaces.

1316
00:57:57,560 --> 00:57:59,365
Grace?

1317
00:57:59,365 --> 00:58:04,215
GRACE: So if Shawn and Owen, you
each-- you give to each of them

1318
00:58:04,215 --> 00:58:08,095
two spaces somewhere else,
and then one is their name,

1319
00:58:08,095 --> 00:58:10,144
the other is their
reference back to January.

1320
00:58:10,144 --> 00:58:10,810
DAVID MALAN: OK.

1321
00:58:10,810 --> 00:58:14,550
So we could have used this
pointer idea from before.

1322
00:58:14,550 --> 00:58:17,410
But I daresay we're making it
harder than it needs to be.

1323
00:58:17,410 --> 00:58:21,140
This is an array, because we know a
priori there are 12 months in a year.

1324
00:58:21,140 --> 00:58:23,390
And we're pretty
comfortable hardcoding that.

1325
00:58:23,390 --> 00:58:24,660
That's not going to change.

1326
00:58:24,660 --> 00:58:26,900
What is going to change is how
many people are in the room

1327
00:58:26,900 --> 00:58:29,399
and how many people we want to
fit into this data structure.

1328
00:58:29,399 --> 00:58:32,647
So what is the data structure that
gives us that kind of dynamism?

1329
00:58:32,647 --> 00:58:33,747
STUDENT: Search tree.

1330
00:58:33,747 --> 00:58:34,580
DAVID MALAN: Oh, OK.

1331
00:58:34,580 --> 00:58:36,730
We could do a search tree, but I
don't care so much about search.

1332
00:58:36,730 --> 00:58:38,021
What's the simpler incarnation?

1333
00:58:38,021 --> 00:58:40,810


1334
00:58:40,810 --> 00:58:42,260
Just a linked list, right?

1335
00:58:42,260 --> 00:58:47,364
If this is fixed on our horizontal axis
visually, why don't I grab more space,

1336
00:58:47,364 --> 00:58:49,780
but if there's a block of
memory over here-- so let's see,

1337
00:58:49,780 --> 00:58:51,050
I've already forgotten where we started.

1338
00:58:51,050 --> 00:58:52,477
But Shivang was in January.

1339
00:58:52,477 --> 00:58:53,310
And then was it Dan?

1340
00:58:53,310 --> 00:58:55,390
You're also January?

1341
00:58:55,390 --> 00:58:56,660
So Dan is January.

1342
00:58:56,660 --> 00:58:57,190
You know, what I'm going to do?

1343
00:58:57,190 --> 00:58:58,620
I'm not going to put Shivang here.

1344
00:58:58,620 --> 00:59:03,550
Instead I'm going to have an
array of 12 pointers-- arrows

1345
00:59:03,550 --> 00:59:05,810
if you will-- that
are initially nothing.

1346
00:59:05,810 --> 00:59:07,610
They're just zeros, or
pointing to nothing.

1347
00:59:07,610 --> 00:59:11,060
But as soon as I find, ooh,
someone has a January birthday,

1348
00:59:11,060 --> 00:59:13,522
I'm going to go ahead and
write his or her name here.

1349
00:59:13,522 --> 00:59:16,230
And as soon as we encounter another
such student-- you know what,

1350
00:59:16,230 --> 00:59:18,480
I'm just going to draw another
arrow to another block.

1351
00:59:18,480 --> 00:59:20,270
And each of these
blocks can be anywhere.

1352
00:59:20,270 --> 00:59:22,640
The only one that has to
be contiguous is this one.

1353
00:59:22,640 --> 00:59:25,270
So I could put Dan over here.

1354
00:59:25,270 --> 00:59:28,696
So we're no longer resorting to
linear probing where we're just

1355
00:59:28,696 --> 00:59:31,570
hoping-- I got to find a space for
Dan, got to find a space for Dan--

1356
00:59:31,570 --> 00:59:34,650
because that can devolve into him
being way at the end of the list

1357
00:59:34,650 --> 00:59:36,390
after all of our other data.

1358
00:59:36,390 --> 00:59:40,210
Now at least, we can start to
plot people where they belong,

1359
00:59:40,210 --> 00:59:43,670
but just kind of growing
that data structure.

1360
00:59:43,670 --> 00:59:48,890
So in an ideal world, we would put just
one person in each of these months,

1361
00:59:48,890 --> 00:59:50,530
but that's obviously not realistic.

1362
00:59:50,530 --> 00:59:53,030
We have to decide in advance
typically when writing software

1363
00:59:53,030 --> 00:59:54,550
like how big a data
structure's going to be,

1364
00:59:54,550 --> 00:59:56,360
at least if it's an array like this.

1365
00:59:56,360 --> 00:59:59,870
But 12 feels reasonable if we're
bucketizing people, so to speak,

1366
00:59:59,870 --> 01:00:01,520
by their birthday months.

1367
01:00:01,520 --> 01:00:04,250
But the linked list kind of
gives us the best of both worlds.

1368
01:00:04,250 --> 01:00:07,080
We can immediately find
all the January people

1369
01:00:07,080 --> 01:00:09,826
and then I can tell you one at
a time who those people are.

1370
01:00:09,826 --> 01:00:12,200
I can immediately find all
the December people just using

1371
01:00:12,200 --> 01:00:14,920
arithmetic and random access,
and then I can rattle off

1372
01:00:14,920 --> 01:00:16,470
who the December people are.

1373
01:00:16,470 --> 01:00:18,560
So the fact that there's
a linear aspect here

1374
01:00:18,560 --> 01:00:21,530
isn't such a big deal if the goal
is just to remember everyone.

1375
01:00:21,530 --> 01:00:24,240
You've got to follow some
kind of bread crumbs.

1376
01:00:24,240 --> 01:00:26,730
But if we want to search them,
this will be problematic,

1377
01:00:26,730 --> 01:00:29,700
especially since I've put them--
it would seem out of order,

1378
01:00:29,700 --> 01:00:31,830
reverse alphabetical order.

1379
01:00:31,830 --> 01:00:34,542
So a hash table is this.

1380
01:00:34,542 --> 01:00:37,970
This is one of the most in common
incarnations of a hash table

1381
01:00:37,970 --> 01:00:40,170
whereby for each of
these months, you might

1382
01:00:40,170 --> 01:00:42,910
have a different length linked list.

1383
01:00:42,910 --> 01:00:49,900
But in an ideal world, each of these
linked lists is as short as possible.

1384
01:00:49,900 --> 01:00:53,050
And while I've chosen for the
sake of discussion birthday months

1385
01:00:53,050 --> 01:00:58,380
as the number of elements in our
array, that was just arbitrary.

1386
01:00:58,380 --> 01:01:02,740
And a good hash table will actually
choose a much bigger number than 12.

1387
01:01:02,740 --> 01:01:06,350
So if there are 26 people in this
room, hopefully the hash table

1388
01:01:06,350 --> 01:01:10,570
is actually going to be
at least 26, if not 200.

1389
01:01:10,570 --> 01:01:12,900
So a little bit wasteful,
but that minimizes

1390
01:01:12,900 --> 01:01:16,601
the probability of there being these
collisions or reduces the probability.

1391
01:01:16,601 --> 01:01:18,350
But even if there are
collisions, it's OK.

1392
01:01:18,350 --> 01:01:21,036
We have a plan B. We'll
introduce linked list.

1393
01:01:21,036 --> 01:01:23,910
Now hopefully there won't be too
many collisions, and when there are,

1394
01:01:23,910 --> 01:01:26,020
they'll be relatively few.

1395
01:01:26,020 --> 01:01:31,820
And so a hash table is technically
not in this form constant time,

1396
01:01:31,820 --> 01:01:33,210
instant access.

1397
01:01:33,210 --> 01:01:37,540
But it's much closer to instant
access than any of the data structures

1398
01:01:37,540 --> 01:01:38,940
we've looked at before.

1399
01:01:38,940 --> 01:01:42,920
Because if there's 26 people
in the room, it might take us,

1400
01:01:42,920 --> 01:01:46,030
what, four or five steps
if we did a binary search

1401
01:01:46,030 --> 01:01:49,650
tree to traverse that many
people-- log base 2 of 26.

1402
01:01:49,650 --> 01:01:52,870
If we did linear search,
it might take us 26 steps.

1403
01:01:52,870 --> 01:01:56,440
But in this scenario, it looks
I can find Shivang and Dan

1404
01:01:56,440 --> 01:02:00,880
in two steps, one steps-- which is
just proof by example, to be fair.

1405
01:02:00,880 --> 01:02:04,870
But it is fewer than those ballpark
numbers I mentioned earlier.

1406
01:02:04,870 --> 01:02:06,950
So a hash table gets
us much closer to this.

1407
01:02:06,950 --> 01:02:08,960
And the knobs a developer
would turn-- someone

1408
01:02:08,960 --> 01:02:12,830
who's implementing a library that
we would use in our own software

1409
01:02:12,830 --> 01:02:15,240
would generally try to use
some sophisticated math,

1410
01:02:15,240 --> 01:02:18,650
and if not some statistics
or just some heuristics,

1411
01:02:18,650 --> 01:02:21,030
to decide how big the
hash table should be

1412
01:02:21,030 --> 01:02:25,760
and maybe once it even reaches a
certain size how to reorganize the data.

1413
01:02:25,760 --> 01:02:28,250
And indeed one of the
features of databases today

1414
01:02:28,250 --> 01:02:32,050
like Oracle and MySQL and
PostgreSQL is underneath the hood,

1415
01:02:32,050 --> 01:02:34,250
one of the reasons they
are able to give you back

1416
01:02:34,250 --> 01:02:37,750
your data faster than just
searching it in like an Excel file,

1417
01:02:37,750 --> 01:02:41,090
top to bottom, or over a file
system, a folder of files,

1418
01:02:41,090 --> 01:02:44,970
is they are doing fancy structures
like this, like our tree structures.

1419
01:02:44,970 --> 01:02:50,650
In fact, the B-tree is a common data
structure that a database would use.

1420
01:02:50,650 --> 01:02:54,080
And it's similar in spirit to the BSTs
and the AVLs but just with more nodes.

1421
01:02:54,080 --> 01:02:56,120
It's even shorter.

1422
01:02:56,120 --> 01:03:00,820
It's just much wider, because each node
has more than two children, typically.

1423
01:03:00,820 --> 01:03:01,572
Yeah?

1424
01:03:01,572 --> 01:03:03,882
STUDENT: How does it know
which month to start on?

1425
01:03:03,882 --> 01:03:06,340
DAVID MALAN: How does it know--
what do you mean, start on?

1426
01:03:06,340 --> 01:03:08,465
STUDENT: Compared to the
array, where originally it

1427
01:03:08,465 --> 01:03:11,809
would be sort of a habit with binary
search, how does it know to go to March

1428
01:03:11,809 --> 01:03:13,260
or go to December?

1429
01:03:13,260 --> 01:03:17,240
DAVID MALAN: So in this case,
I'm assuming that these 12

1430
01:03:17,240 --> 01:03:18,470
elements have some meaning.

1431
01:03:18,470 --> 01:03:21,270
So January will be represented
with 0 and December

1432
01:03:21,270 --> 01:03:22,957
will be represented with 11.

1433
01:03:22,957 --> 01:03:24,290
And that's actually very common.

1434
01:03:24,290 --> 01:03:27,840
In programming languages, if you
want to print out the month December,

1435
01:03:27,840 --> 01:03:31,110
you will know or hard code in
your software the number 11,

1436
01:03:31,110 --> 01:03:35,010
by convention for exactly that reason.

1437
01:03:35,010 --> 01:03:35,980
Yeah, Vanessa?

1438
01:03:35,980 --> 01:03:38,980
VANESSA: So I can imagine that
whenever you start a project,

1439
01:03:38,980 --> 01:03:43,480
you have a particular focus
and a particular data structure

1440
01:03:43,480 --> 01:03:47,480
that you think would be suited for
that, and as that project evolves,

1441
01:03:47,480 --> 01:03:51,730
there would be even further
complexity or different direction that

1442
01:03:51,730 --> 01:03:55,411
might require you to change or
migrate or update your data structure?

1443
01:03:55,411 --> 01:03:56,410
DAVID MALAN: Absolutely.

1444
01:03:56,410 --> 01:03:59,800
Over time integer problems change you
might need to change your underlying

1445
01:03:59,800 --> 01:04:00,710
data structures.

1446
01:04:00,710 --> 01:04:05,040
However, I would say it's typically
only certain types of companies

1447
01:04:05,040 --> 01:04:08,172
that would focus-- well, is that fair?

1448
01:04:08,172 --> 01:04:09,630
No, that would be an overstatement.

1449
01:04:09,630 --> 01:04:11,400
So short answer, yes.

1450
01:04:11,400 --> 01:04:13,680
As your data changes
or as you realize you

1451
01:04:13,680 --> 01:04:15,990
have so much data that
your algorithm is slow,

1452
01:04:15,990 --> 01:04:20,120
you would absolutely re-engineer
how you're implementing things.

1453
01:04:20,120 --> 01:04:23,510
For instance, if you have only a few
hundred things in your-- few hundred

1454
01:04:23,510 --> 01:04:25,809
customers or few thousand
customers, frankly,

1455
01:04:25,809 --> 01:04:28,600
when you load those into memory,
you can just put them in an array,

1456
01:04:28,600 --> 01:04:29,475
search them linearly.

1457
01:04:29,475 --> 01:04:32,270
Because a computer can search
a thousand elements super fast.

1458
01:04:32,270 --> 01:04:33,520
No one's going to notice.

1459
01:04:33,520 --> 01:04:37,300
But eventually-- it's
a bad design decision.

1460
01:04:37,300 --> 01:04:39,204
But it's maybe a good
business decision if it

1461
01:04:39,204 --> 01:04:41,120
means you can ship the
software faster than it

1462
01:04:41,120 --> 01:04:43,050
would take to actually
engineer something fancier,

1463
01:04:43,050 --> 01:04:44,490
like we've been discussing here.

1464
01:04:44,490 --> 01:04:46,281
But this is how companies
accrue what would

1465
01:04:46,281 --> 01:04:49,619
be called technical debt, whereby you
keep cutting a corner, cut a corner.

1466
01:04:49,619 --> 01:04:51,660
You go the cheap route,
cheap route, cheap route.

1467
01:04:51,660 --> 01:04:53,760
Eventually you're going to
have to really pay the price.

1468
01:04:53,760 --> 01:04:55,650
Because when you have
a wonderful success,

1469
01:04:55,650 --> 01:04:57,230
like all these customers
suddenly sign up,

1470
01:04:57,230 --> 01:04:59,563
now your software doesn't
even work, because you haven't

1471
01:04:59,563 --> 01:05:02,000
anticipated the load on your servers.

1472
01:05:02,000 --> 01:05:04,340
And then you have to go
back and re-engineer things.

1473
01:05:04,340 --> 01:05:07,700
Technical debt can also be accrued in
the sense of-- if you let your team

1474
01:05:07,700 --> 01:05:10,620
or yourself just be sloppy with
your code-- you're not commenting

1475
01:05:10,620 --> 01:05:13,120
or describing it, or you're
just copying and pasting code

1476
01:05:13,120 --> 01:05:16,372
rather than really thinking through
how you can factor things out-- you

1477
01:05:16,372 --> 01:05:18,830
accrue technical debt that
eventually you have to pay back.

1478
01:05:18,830 --> 01:05:21,330
And that's generally in
the form of time, which

1479
01:05:21,330 --> 01:05:23,300
can be bad to postpone in that way.

1480
01:05:23,300 --> 01:05:24,010
So absolutely.

1481
01:05:24,010 --> 01:05:26,320
It's an evolving cycle.

1482
01:05:26,320 --> 01:05:29,400
And I would say that what you
pay companies like Oracle for

1483
01:05:29,400 --> 01:05:32,460
is that secret sauce,
among other things,

1484
01:05:32,460 --> 01:05:35,082
for-- they're faster than the
competition, for instance,

1485
01:05:35,082 --> 01:05:35,665
if they claim.

1486
01:05:35,665 --> 01:05:37,780
Well, there's probably
some science behind that

1487
01:05:37,780 --> 01:05:41,300
and some theoretical
arguments to back it up.

1488
01:05:41,300 --> 01:05:43,810
Now as an aside, it is
technically possible

1489
01:05:43,810 --> 01:05:50,260
to get constant time access
in the following way.

1490
01:05:50,260 --> 01:05:51,680
There's another data structure.

1491
01:05:51,680 --> 01:05:54,230
Let me wave my hands at
the details and call it

1492
01:05:54,230 --> 01:05:57,180
a try-- which is short for
retrieval, which is still

1493
01:05:57,180 --> 01:05:58,840
pronounced strangely different.

1494
01:05:58,840 --> 01:06:04,020
But a try does actually give you what
folks would call big O of 1 time.

1495
01:06:04,020 --> 01:06:07,720
And it would often be used
for a dictionary of words.

1496
01:06:07,720 --> 01:06:10,050
Not a directory, rather a dictionary.

1497
01:06:10,050 --> 01:06:11,270
Oh, I misspoke earlier.

1498
01:06:11,270 --> 01:06:12,960
You said directory, not dictionary.

1499
01:06:12,960 --> 01:06:18,320
Dictionary is the fancy speak for a
hash table, or an incarnation of it.

1500
01:06:18,320 --> 01:06:21,480
But a try could give us
constant time as well.

1501
01:06:21,480 --> 01:06:24,190
But let's not go too far down
the rabbit hole just yet.

1502
01:06:24,190 --> 01:06:27,400
But this is why I would argue
computer science is fun or software

1503
01:06:27,400 --> 01:06:29,430
engineering is fun and also hard.

1504
01:06:29,430 --> 01:06:32,540
Again, you can cut corners so easily
when your data sets are small,

1505
01:06:32,540 --> 01:06:35,984
but the reason that Google and
Microsoft and Facebook and Twitter

1506
01:06:35,984 --> 01:06:38,650
have such smart people working
for them is that these are really

1507
01:06:38,650 --> 01:06:40,249
non-obvious problems sometimes.

1508
01:06:40,249 --> 01:06:43,290
And indeed, what's been new about big
data, so to speak, in recent years,

1509
01:06:43,290 --> 01:06:46,390
especially Twitter-- Twitter
was horrible initially

1510
01:06:46,390 --> 01:06:49,710
at actually keeping up with
the rate of their success.

1511
01:06:49,710 --> 01:06:52,410
And the fail whale used to
be a thing, if you recall?

1512
01:06:52,410 --> 01:06:55,662
Thankfully, that's been
decommissioned in recent years.

1513
01:06:55,662 --> 01:06:57,370
But they used to
struggle under the load,

1514
01:06:57,370 --> 01:06:59,547
so much so that you
couldn't access twitter.com,

1515
01:06:59,547 --> 01:07:01,130
and that's because this stuff is hard.

1516
01:07:01,130 --> 01:07:04,560
When you have thousands or millions
of transactions per day or per minute,

1517
01:07:04,560 --> 01:07:06,840
you actually need to think
about things to this level.

1518
01:07:06,840 --> 01:07:09,990
And so these are just some of the
basic building blocks early on.

1519
01:07:09,990 --> 01:07:16,880
And people build on these general
ideas to make fancier software still.

1520
01:07:16,880 --> 01:07:20,080
Any questions?

1521
01:07:20,080 --> 01:07:23,510
All right, well, let's just round this
out with a bit of a laundry list just

1522
01:07:23,510 --> 01:07:25,920
to take it up a higher
level, just to make

1523
01:07:25,920 --> 01:07:28,080
mention of some of the
tools and ingredients

1524
01:07:28,080 --> 01:07:31,280
that we might use on the context
of frameworks and libraries.

1525
01:07:31,280 --> 01:07:33,436
So we had this laundry
list of languages earlier.

1526
01:07:33,436 --> 01:07:35,310
Unfortunately, I claimed
that it's not always

1527
01:07:35,310 --> 01:07:40,060
super easy to use Java out of the
box for web programming, or Python,

1528
01:07:40,060 --> 01:07:42,480
or Ruby, and certainly
not C. And so there

1529
01:07:42,480 --> 01:07:44,510
exists some very popular
libraries out there

1530
01:07:44,510 --> 01:07:47,050
that people have started
to use and popularize,

1531
01:07:47,050 --> 01:07:50,450
especially because of open source,
that are just worth knowing about.

1532
01:07:50,450 --> 01:07:53,690
So we'll talk more after
our break about jQuery.

1533
01:07:53,690 --> 01:07:58,370
But jQuery is a very popular library
for the language called JavaScript.

1534
01:07:58,370 --> 01:08:01,840
And this just makes JavaScript
arguably easier to write,

1535
01:08:01,840 --> 01:08:05,660
because it comes with a lot more
functionality than the language itself.

1536
01:08:05,660 --> 01:08:08,850
So it's worth noting.

1537
01:08:08,850 --> 01:08:11,340
JQuery in particular is
so popular that it's not

1538
01:08:11,340 --> 01:08:13,721
uncommon to see people
list it on a resume as part

1539
01:08:13,721 --> 01:08:16,929
of a list of, I know this language, this
language, this language, and jQuery.

1540
01:08:16,929 --> 01:08:18,140
It's not a language.

1541
01:08:18,140 --> 01:08:20,330
And frankly, when people
don't quite realize that,

1542
01:08:20,330 --> 01:08:24,490
that itself can be kind of a hint of
their sophistication, I would argue.

1543
01:08:24,490 --> 01:08:26,600
But it's so popular, that
most people essentially

1544
01:08:26,600 --> 01:08:28,090
equate it with the language itself.

1545
01:08:28,090 --> 01:08:31,006
It's used in so many places, though
there's a bit of a turn against it

1546
01:08:31,006 --> 01:08:33,210
now, because it's become
so big and weighty.

1547
01:08:33,210 --> 01:08:34,970
So it's not requisite.

1548
01:08:34,970 --> 01:08:37,821
Ruby on Rails is a
very popular framework.

1549
01:08:37,821 --> 01:08:41,029
And actually, let me keep these in two
separate columns so as not to mislead.

1550
01:08:41,029 --> 01:08:45,810


1551
01:08:45,810 --> 01:08:51,210
So we'll have libraries over here--
and frankly, sometimes the line

1552
01:08:51,210 --> 01:08:55,760
will get blurry-- frameworks over here.

1553
01:08:55,760 --> 01:08:59,600
And this is an infinite list, not
unlike the languages one we saw before.

1554
01:08:59,600 --> 01:09:06,550
So jQuery for JavaScript,
Rails for Ruby.

1555
01:09:06,550 --> 01:09:10,840
Django is a very popular
framework for Python.

1556
01:09:10,840 --> 01:09:14,864
Flask, and now we have another
category, called microframeworks.

1557
01:09:14,864 --> 01:09:16,680
Let me distill this in a moment.

1558
01:09:16,680 --> 01:09:22,674
Frameworks, which are things
like Flask, dot, dot, dot.

1559
01:09:22,674 --> 01:09:24,090
And these are the kinds of things.

1560
01:09:24,090 --> 01:09:25,799
There's no way we
could give you the fire

1561
01:09:25,799 --> 01:09:28,631
hose of all these possible things,
because these are the things that

1562
01:09:28,631 --> 01:09:29,779
are constantly changing.

1563
01:09:29,779 --> 01:09:32,309
So let me give some
high-level takeaways.

1564
01:09:32,309 --> 01:09:34,600
There's often this ebb and
flow in technology certainly

1565
01:09:34,600 --> 01:09:38,630
in recent years as to, what's popular
or the right way to do things?

1566
01:09:38,630 --> 01:09:42,010
And this is in part a function of
people learning better techniques.

1567
01:09:42,010 --> 01:09:43,959
We live with some languages
for a little while

1568
01:09:43,959 --> 01:09:47,129
and we realize, damn, it's annoying to
write certain stuff in this language.

1569
01:09:47,129 --> 01:09:49,920
Let's come up with a new language,
or let's write a library of code

1570
01:09:49,920 --> 01:09:51,961
that we can make freely
available to other people

1571
01:09:51,961 --> 01:09:53,840
to sort of stand on
each other's shoulders.

1572
01:09:53,840 --> 01:09:57,780
Or let's start to a change to a
different approach altogether.

1573
01:09:57,780 --> 01:09:59,970
So jQuery's an answer
to that first scenario.

1574
01:09:59,970 --> 01:10:03,660
Like wow, this is an annoying
language to write in certain patterns.

1575
01:10:03,660 --> 01:10:06,910
So thus was born libraries like jQuery.

1576
01:10:06,910 --> 01:10:10,125
Frameworks-- like Rails for
Ruby and Django for Python

1577
01:10:10,125 --> 01:10:12,590
and yet others-- were
introduced to make it

1578
01:10:12,590 --> 01:10:15,040
easier and more
pleasurable to actually use

1579
01:10:15,040 --> 01:10:18,320
Ruby and Python and similar
languages for web development.

1580
01:10:18,320 --> 01:10:22,240
And they themselves just get so popular
that these are still too pretty popular

1581
01:10:22,240 --> 01:10:23,840
go-to places.

1582
01:10:23,840 --> 01:10:27,591
Node.js-- kind of framework,
I'd say, although it's

1583
01:10:27,591 --> 01:10:28,840
a little different from these.

1584
01:10:28,840 --> 01:10:30,690
The lines start to get a little murky.

1585
01:10:30,690 --> 01:10:35,140
Node.js is a way of using a language
called JavaScript on the server side.

1586
01:10:35,140 --> 01:10:37,610
And we'll talk about JavaScript
after our break in a few,

1587
01:10:37,610 --> 01:10:42,300
but Node.js has been in
recent years popular for using

1588
01:10:42,300 --> 01:10:45,280
a language in a way it wasn't
initially intended for.

1589
01:10:45,280 --> 01:10:47,960
But it allows you a different
way of programming still.

1590
01:10:47,960 --> 01:10:52,470
Microframeworks are kind of a reaction
to the proliferation of frameworks.

1591
01:10:52,470 --> 01:10:57,430
Frameworks are essentially--
it's collections of libraries,

1592
01:10:57,430 --> 01:10:58,550
might be fair?

1593
01:10:58,550 --> 01:11:00,860
It's perhaps a whole
bunch of libraries you

1594
01:11:00,860 --> 01:11:03,780
use to accomplish some goal--
a library for sending email,

1595
01:11:03,780 --> 01:11:06,567
a library for talking to a
database, some low-level stuff

1596
01:11:06,567 --> 01:11:08,650
often that you yourself
don't want to think about.

1597
01:11:08,650 --> 01:11:11,066
You want to build a business
that just needs to send email

1598
01:11:11,066 --> 01:11:12,860
and needs to use a database.

1599
01:11:12,860 --> 01:11:16,800
Frameworks are collections of libraries
and also with sets of conventions.

1600
01:11:16,800 --> 01:11:20,310
And so one of the downsides
of choosing a framework

1601
01:11:20,310 --> 01:11:23,510
is that you pretty much have
to follow their documentation

1602
01:11:23,510 --> 01:11:25,430
and you have to organize your code.

1603
01:11:25,430 --> 01:11:28,450
You have to organize your
files and folders in a way that

1604
01:11:28,450 --> 01:11:30,090
is compatible with that framework.

1605
01:11:30,090 --> 01:11:33,140
And that's fine, because
there's an advantage sometimes

1606
01:11:33,140 --> 01:11:34,960
to doing what other people are doing.

1607
01:11:34,960 --> 01:11:37,980
But it also creates a
bit of buy-in or lock-in,

1608
01:11:37,980 --> 01:11:41,210
whereby if you decide or your
staff changes and you're like,

1609
01:11:41,210 --> 01:11:42,690
we're tired of using Rails.

1610
01:11:42,690 --> 01:11:44,110
We want to use something else.

1611
01:11:44,110 --> 01:11:46,530
You have to do some
nontrivial architecting

1612
01:11:46,530 --> 01:11:50,306
or rearchitecting-- redesigning to
actually change over to something else.

1613
01:11:50,306 --> 01:11:52,180
So these are the kinds
of decisions that when

1614
01:11:52,180 --> 01:11:56,690
first building a prototype of
something or deciding on a technology

1615
01:11:56,690 --> 01:11:58,940
stack, so to speak-- a
collection of technologies

1616
01:11:58,940 --> 01:12:01,750
your business is going to use--
it's worth spending more time

1617
01:12:01,750 --> 01:12:05,680
upfront discussing, researching,
arguing about, whiteboarding

1618
01:12:05,680 --> 01:12:08,160
the possible approaches
so that when you dive in,

1619
01:12:08,160 --> 01:12:11,250
you actually know what
you're getting yourself into.

1620
01:12:11,250 --> 01:12:14,050
And of course, if you hire certain
people who have good experience,

1621
01:12:14,050 --> 01:12:17,920
they'll too bring their own biases,
their own expertise to bear as well.

1622
01:12:17,920 --> 01:12:20,410
And microframeworks,
to wrap up this part,

1623
01:12:20,410 --> 01:12:24,530
is a reaction to frameworks, which
have gotten very bulky-- just so

1624
01:12:24,530 --> 01:12:29,420
many libraries and so much code, like
truly the kitchen sink of software.

1625
01:12:29,420 --> 01:12:33,090
So microframeworks are a reaction to
that approach, whereby microframeworks

1626
01:12:33,090 --> 01:12:36,720
tend to do just one thing,
or one or two things.

1627
01:12:36,720 --> 01:12:38,730
And let me put this into context.

1628
01:12:38,730 --> 01:12:45,470
For instance, a popular framework
for PHP is called Laravel.

1629
01:12:45,470 --> 01:12:50,990
And if I pull up its documentation,
it does a whole bunch of stuff.

1630
01:12:50,990 --> 01:12:55,310
So routing, which refers to how you
get your HTTP request to the right

1631
01:12:55,310 --> 01:12:56,540
file on your server.

1632
01:12:56,540 --> 01:12:59,280


1633
01:12:59,280 --> 01:13:02,040
Views, which has to do with
the aesthetics of your site.

1634
01:13:02,040 --> 01:13:04,110
How do you present data to users?

1635
01:13:04,110 --> 01:13:04,990
Scrolling down here.

1636
01:13:04,990 --> 01:13:08,530
Authentication, how you log
users in; authorization,

1637
01:13:08,530 --> 01:13:12,000
how you decide whether or not
to allow a certain operation;

1638
01:13:12,000 --> 01:13:16,000
billing, how you bill your
customers; caching; encryption,

1639
01:13:16,000 --> 01:13:18,790
how you encrypt your data--
and I'm skipping over ones

1640
01:13:18,790 --> 01:13:19,870
I'm not even sure of.

1641
01:13:19,870 --> 01:13:21,450
Mail, how you send mail.

1642
01:13:21,450 --> 01:13:23,560
So when I say kitchen
sink, I just mean-- Laravel

1643
01:13:23,560 --> 01:13:25,460
comes with all of this functionality.

1644
01:13:25,460 --> 01:13:28,040
And this too creates
all the more lock-in.

1645
01:13:28,040 --> 01:13:32,130
And if you start Googling around,
you'll often find performance benchmarks

1646
01:13:32,130 --> 01:13:37,420
on libraries or frameworks, whereby
someone will compare A to B to C

1647
01:13:37,420 --> 01:13:40,945
and make the claim, credibly or not,
that one library or framework is better

1648
01:13:40,945 --> 01:13:43,070
than the other, because
look how much faster it is!

1649
01:13:43,070 --> 01:13:44,640
You should always take
that with a grain of salt,

1650
01:13:44,640 --> 01:13:47,515
because so often do people run
different code on different platforms.

1651
01:13:47,515 --> 01:13:50,473
And some frameworks might be good at
one thing, worse at another thing,

1652
01:13:50,473 --> 01:13:52,440
so it's really not
apples and apples always.

1653
01:13:52,440 --> 01:13:56,330
But the fact that there's so much
code baked into certain frameworks

1654
01:13:56,330 --> 01:13:58,970
means they are a little
bit slower than others.

1655
01:13:58,970 --> 01:14:03,190
And so microframeworks do maybe
one thing, but only one thing.

1656
01:14:03,190 --> 01:14:06,560
And so you use this micro
framework for problem A,

1657
01:14:06,560 --> 01:14:09,180
this microframework for
problem B, and so forth.

1658
01:14:09,180 --> 01:14:11,930
So on the one hand, it's both fun
in that the technology is always

1659
01:14:11,930 --> 01:14:15,470
changing, on the other hand, it is so
frustrating and so hard to keep up,

1660
01:14:15,470 --> 01:14:17,680
or time-consuming to
keep up that you really

1661
01:14:17,680 --> 01:14:25,310
have to have passion or a foot in
the game to-- hand in the game?

1662
01:14:25,310 --> 01:14:26,130
Skin in the game!

1663
01:14:26,130 --> 01:14:26,630
All right.

1664
01:14:26,630 --> 01:14:30,230
I'm picking wrong body parts--
in order to stay current

1665
01:14:30,230 --> 01:14:31,230
with this kind of stuff.

1666
01:14:31,230 --> 01:14:32,100
Griff?

1667
01:14:32,100 --> 01:14:34,910
GRIFF: So frameworks are
essentially collections of libraries

1668
01:14:34,910 --> 01:14:38,676
and microframeworks are smaller
collections of libraries.

1669
01:14:38,676 --> 01:14:42,660
What's the dividing line between
a library and a framework?

1670
01:14:42,660 --> 01:14:44,150
DAVID MALAN: It's a good question.

1671
01:14:44,150 --> 01:14:46,780
I wouldn't say there's one
more formal definition,

1672
01:14:46,780 --> 01:14:50,330
but a library is code
that someone else has

1673
01:14:50,330 --> 01:14:52,860
written that accomplishes
some goal that you

1674
01:14:52,860 --> 01:14:55,177
were integrating into your own project.

1675
01:14:55,177 --> 01:14:57,510
So that might be a library
that gives you functionality,

1676
01:14:57,510 --> 01:14:59,610
gives you a puzzle piece
that lets you send email.

1677
01:14:59,610 --> 01:15:01,220
That would be a library, for instance.

1678
01:15:01,220 --> 01:15:05,840
Or actually, Scratch is not
a bad example as a metaphor.

1679
01:15:05,840 --> 01:15:12,630
If we had this palette here, I would
argue that each of these categories

1680
01:15:12,630 --> 01:15:14,600
is a library.

1681
01:15:14,600 --> 01:15:17,580
This is a library of motion-related
puzzle pieces, a library

1682
01:15:17,580 --> 01:15:19,130
of looks-related puzzle pieces.

1683
01:15:19,130 --> 01:15:21,370
So that's a good way of
thinking about a library.

1684
01:15:21,370 --> 01:15:25,000
It's related pieces of functionality
that you can use in your own projects.

1685
01:15:25,000 --> 01:15:27,390
A framework would be
something like Scratch.

1686
01:15:27,390 --> 01:15:29,960
If your goal is to
implement a program that

1687
01:15:29,960 --> 01:15:32,870
implements a cat saying
hello world, Scratch

1688
01:15:32,870 --> 01:15:35,880
is one of the frameworks you
can use to implement that.

1689
01:15:35,880 --> 01:15:39,270
Because the framework comes
with a whole bunch of libraries.

1690
01:15:39,270 --> 01:15:42,240
It also comes with a set of
conventions-- hey, here's our cat.

1691
01:15:42,240 --> 01:15:43,280
Hey, here's our script.

1692
01:15:43,280 --> 01:15:44,400
And so forth.

1693
01:15:44,400 --> 01:15:47,270
And so if you want to implement a
cat that says hello world, Scratch

1694
01:15:47,270 --> 01:15:48,800
one of the frameworks you can use.

1695
01:15:48,800 --> 01:15:53,280
Unfortunately, you have to go all
in and use MIT's application or not,

1696
01:15:53,280 --> 01:15:55,110
and so there's that lock-in aspect.

1697
01:15:55,110 --> 01:15:57,450
By contrast, you could
use something like OpenGL,

1698
01:15:57,450 --> 01:16:01,880
which is a framework and a set of
libraries for actually implementing

1699
01:16:01,880 --> 01:16:03,820
graphical software to
a much lower level,

1700
01:16:03,820 --> 01:16:04,980
but it's going to be a lot harder.

1701
01:16:04,980 --> 01:16:07,021
It's going to be a lot
more arcane than something

1702
01:16:07,021 --> 01:16:08,780
like this drag and drop language.

1703
01:16:08,780 --> 01:16:16,660
So a framework, rather
a micro framework--

1704
01:16:16,660 --> 01:16:21,590
it's kind of equivalent to a library
with better branding, perhaps.

1705
01:16:21,590 --> 01:16:26,070
It's a library that does one
or few tasks that might also

1706
01:16:26,070 --> 01:16:28,300
come with it some conventions.

1707
01:16:28,300 --> 01:16:35,660
So a microframework like Flask might
prescribe how you organize your code

1708
01:16:35,660 --> 01:16:40,560
and how you organize your files
and directories, I would say.

1709
01:16:40,560 --> 01:16:43,120


1710
01:16:43,120 --> 01:16:43,918
Yeah, Alicia?

1711
01:16:43,918 --> 01:16:46,293
ALICIA: So if you [INAUDIBLE]
a framework from a library,

1712
01:16:46,293 --> 01:16:47,822
you're kind of locked in.

1713
01:16:47,822 --> 01:16:53,190
If you use C or C++ on its own, you
get complete control of the palettes.

1714
01:16:53,190 --> 01:16:54,440
DAVID MALAN: That is correct.

1715
01:16:54,440 --> 01:16:55,414
ALICIA: So, for
instance, in my industry,

1716
01:16:55,414 --> 01:16:58,092
Goldman-Sachs is known for coming
up with their own language,

1717
01:16:58,092 --> 01:17:00,729
meaning they don't want
to control everything.

1718
01:17:00,729 --> 01:17:02,353
Is that more of a time to market thing?

1719
01:17:02,353 --> 01:17:04,667
So if you were a startup
and wanted to get started,

1720
01:17:04,667 --> 01:17:07,041
you're probably want to leverage
frameworks and libraries

1721
01:17:07,041 --> 01:17:11,142
and not just be a purist and say we're
going to write every piece of code--

1722
01:17:11,142 --> 01:17:14,100
DAVID MALAN: Yeah, a startup should
absolutely use off-the-shelf tools.

1723
01:17:14,100 --> 01:17:17,870
And it is an indulgence for sure
to have the resources to come up

1724
01:17:17,870 --> 01:17:18,950
with your own language.

1725
01:17:18,950 --> 01:17:20,950
That would be a very uncommon case.

1726
01:17:20,950 --> 01:17:24,030
And if not that, it's
perhaps a way of explaining

1727
01:17:24,030 --> 01:17:25,670
why you have so much legacy code.

1728
01:17:25,670 --> 01:17:29,140
You've bought in so much that you have
your own language, because you never

1729
01:17:29,140 --> 01:17:30,880
sort of adapted to industry trends.

1730
01:17:30,880 --> 01:17:31,900
If it works, it works.

1731
01:17:31,900 --> 01:17:33,710
That's fine.

1732
01:17:33,710 --> 01:17:34,240
But yeah.

1733
01:17:34,240 --> 01:17:36,170
A startup should be using
the kind of laundry list

1734
01:17:36,170 --> 01:17:38,410
we've been tossing on the
board yesterday and today.

1735
01:17:38,410 --> 01:17:41,344
ALICIA: Is there a security
features without [INAUDIBLE]?

1736
01:17:41,344 --> 01:17:46,240


1737
01:17:46,240 --> 01:17:47,600
DAVID MALAN: That is true.

1738
01:17:47,600 --> 01:17:51,180
The less you rely on other
people's code, the fewer threats

1739
01:17:51,180 --> 01:17:54,700
you expose yourself to, because
there's less code to worry about.

1740
01:17:54,700 --> 01:17:57,870
But that assumes you are better
at writing code than other people.

1741
01:17:57,870 --> 01:18:00,740
And that's a risky claim to make.

1742
01:18:00,740 --> 01:18:03,340
The upside of open source
software too or an upside

1743
01:18:03,340 --> 01:18:05,610
is, you have more eyes
in the community on it.

1744
01:18:05,610 --> 01:18:07,960
Now those eyes might be
good and bad programmers,

1745
01:18:07,960 --> 01:18:09,950
so that may be a good or a bad thing.

1746
01:18:09,950 --> 01:18:12,240
But openness of software
is generally a good thing,

1747
01:18:12,240 --> 01:18:15,364
because you would think asymptotically
you approach perfect software, which

1748
01:18:15,364 --> 01:18:17,550
is more people contributing to it.

1749
01:18:17,550 --> 01:18:19,170
So it goes both ways.

1750
01:18:19,170 --> 01:18:23,076
But even then, a company
would be naive if they think,

1751
01:18:23,076 --> 01:18:25,200
well, we're only using
tools we developed in-house.

1752
01:18:25,200 --> 01:18:27,658
Because odds are, at the end
of the day, they're absolutely

1753
01:18:27,658 --> 01:18:29,800
using a compiler someone else wrote.

1754
01:18:29,800 --> 01:18:32,530
Unless they're going back to
the equivalent of punch cards,

1755
01:18:32,530 --> 01:18:36,580
there's no way that's even tenable.

1756
01:18:36,580 --> 01:18:39,190
Other questions?

1757
01:18:39,190 --> 01:18:39,720
All right.

1758
01:18:39,720 --> 01:18:43,046
So next up is going to be a
little bit of web programming

1759
01:18:43,046 --> 01:18:44,920
and some of the technologies
related thereto.

1760
01:18:44,920 --> 01:18:48,100
We'll talk a bit about JavaScript,
which is commonly used on the front end.

1761
01:18:48,100 --> 01:18:49,600
And that's where we'll play with it.

1762
01:18:49,600 --> 01:18:52,390
But it can be used, as I mentioned,
with Node.js on the back end.

1763
01:18:52,390 --> 01:18:54,030
And that will tie everything together.

1764
01:18:54,030 --> 01:18:56,520
Hopefully, we'll fill in some blanks.

1765
01:18:56,520 --> 01:18:59,250
I'm still thinking about what
my answer is what's the future.

1766
01:18:59,250 --> 01:19:03,370
But let's go ahead now and take a 15
minute break and we'll resume at 3:15.

1767
01:19:03,370 --> 01:19:04,973