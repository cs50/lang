1
00:00:00,000 --> 00:00:00,030

2
00:00:00,030 --> 00:00:00,460
>> დავით Malan ყველა უფლება.

3
00:00:00,460 --> 00:00:01,094
ჩვენ დავბრუნდით.

4
00:00:01,094 --> 00:00:04,260
ასე რომ, ამ სეგმენტის პროგრამირების რა
მე ვფიქრობდი, რომ ჩვენ გვინდა გავაკეთოთ არის ნაზავი რამ.

5
00:00:04,260 --> 00:00:06,340
ერთი, რომ ცოტა
რაღაც პრაქტიკული,

6
00:00:06,340 --> 00:00:08,690
თუმცა გამოყენებით უფრო playful
პროგრამირების environment--

7
00:00:08,690 --> 00:00:11,620
ერთი, რომ საჩვენებელი of
ზუსტად სახის იდეები

8
00:00:11,620 --> 00:00:14,220
ჩვენ ვლაპარაკობდით,
მაგრამ ცოტა უფრო ფორმალურად.

9
00:00:14,220 --> 00:00:18,200
ორი, შევხედოთ ზოგიერთი
უფრო ტექნიკური გზები

10
00:00:18,200 --> 00:00:21,520
რომ პროგრამისტი, რომ რეალურად მოგვარება
პრობლემებს, როგორებიცაა ეძებს პრობლემა

11
00:00:21,520 --> 00:00:24,530
რომ ჩვენ შევხედე და მის
ასევე უფრო ფუნდამენტურად

12
00:00:24,530 --> 00:00:26,020
საინტერესო პრობლემა დახარისხება.

13
00:00:26,020 --> 00:00:28,840
>> ჩვენ მხოლოდ ვივარაუდოთ მისაღებად წასვლა
, რომ სატელეფონო წიგნი იყო დახარისხებული,

14
00:00:28,840 --> 00:00:31,980
მაგრამ რომ მარტო რეალურად სახის
მძიმე პრობლემა ბევრი სხვადასხვა გზა

15
00:00:31,980 --> 00:00:32,479
გადაჭრას.

16
00:00:32,479 --> 00:00:34,366
ასე რომ, ჩვენ გამოვიყენებთ ამ, როგორც
კლასი პრობლემები

17
00:00:34,366 --> 00:00:36,740
წარმომადგენელი რამ, რომ
შეიძლება მოგვარდეს კულტურას.

18
00:00:36,740 --> 00:00:38,980
და მაშინ ჩვენ გაიგო
შესახებ ზოგიერთი დეტალი რა

19
00:00:38,980 --> 00:00:42,360
ეწოდება მონაცემების structures--
fancier გზა, როგორიც დაკავშირებული სიები

20
00:00:42,360 --> 00:00:46,290
და hash მაგიდები და ხეები,
პროგრამისტი, ფაქტობრივად,

21
00:00:46,290 --> 00:00:48,890
გამოყენება და ზოგადად გამოიყენოთ
on დაფა ხატავს

22
00:00:48,890 --> 00:00:51,840
სურათს, რაც მას
ითვალისწინებს განხორციელების

23
00:00:51,840 --> 00:00:52,980
რამდენიმე ნაჭერი პროგრამული უზრუნველყოფა.

24
00:00:52,980 --> 00:00:55,130
>> მოდით გავაკეთოთ პრაქტიკული ნაწილი პირველი.

25
00:00:55,130 --> 00:01:00,090
ასე რომ, უბრალოდ მიიღოთ თქვენი ხელები ბინძური ერთად
გარემოს უწოდა scratch.mit.edu.

26
00:01:00,090 --> 00:01:02,636
ეს არის ინსტრუმენტი, რომელიც ჩვენ ვიყენებთ
ჩვენი ბაკალავრიატის კლასში.

27
00:01:02,636 --> 00:01:04,510
მიუხედავად იმისა, რომ ის შექმნილია
ასაკის 12 და,

28
00:01:04,510 --> 00:01:07,570
ჩვენ ვიყენებთ მას up
ნაწილი, რომელიც საკმაოდ მწირი

29
00:01:07,570 --> 00:01:10,020
მას შემდეგ, რაც ის ლამაზი, მხიარული
გრაფიკული გზა სწავლის

30
00:01:10,020 --> 00:01:12,160
ცოტა რამე პროგრამირების.

31
00:01:12,160 --> 00:01:17,600
ასე რომ, უფროსი რომ URL, სადაც თქვენ
უნდა დაინახოს გვერდი საკმაოდ მოსწონს,

32
00:01:17,600 --> 00:01:23,330
და წავიდეთ წინ და დააჭირეთ
რეგ Scratch ზედა მარჯვენა

33
00:01:23,330 --> 00:01:28,300
და აირჩიოს სახელი და
პაროლი და საბოლოოდ მისაღებად

34
00:01:28,300 --> 00:01:29,970
account-- scratch.mit.edu.

35
00:01:29,970 --> 00:01:32,165

36
00:01:32,165 --> 00:01:34,665
მეგონა მე გამოიყენოს ეს როგორც
შესაძლებლობა პირველი, რათა ეს.

37
00:01:34,665 --> 00:01:39,120
კითხვა გამოვიდა შესვენების დროს
იმაზე, თუ რა კოდი რეალურად გამოიყურება.

38
00:01:39,120 --> 00:01:41,315
და ჩვენ ვსაუბრობთ
შესვენების დროს C,

39
00:01:41,315 --> 00:01:45,060
ში კერძოდ, განსაკუთრებით
ქვედა დონეზე ხანდაზმული ენაზე.

40
00:01:45,060 --> 00:01:47,750
და მე უბრალოდ სწრაფი
Google მოძებნოთ C კოდი

41
00:01:47,750 --> 00:01:51,574
ბინარული ძებნის ალგორითმი, რომ ჩვენ
გამოიყენება მოძებნოთ, რომ სატელეფონო წიგნი ადრე.

42
00:01:51,574 --> 00:01:54,240
ამ კონკრეტულ მაგალითს, რა თქმა უნდა,
არ ეძებს სატელეფონო წიგნი.

43
00:01:54,240 --> 00:01:57,840
ეს უბრალოდ ეძებს მთელი bunch
ნომრები კომპიუტერის მეხსიერებაში.

44
00:01:57,840 --> 00:02:01,000
მაგრამ თუ გსურთ, რომ უბრალოდ ვიზუალური
გრძნობა, რაც ფაქტობრივი პროგრამირების

45
00:02:01,000 --> 00:02:05,370
ენის ჰგავს, ეს გამოიყურება
პატარა რაღაც მსგავსი.

46
00:02:05,370 --> 00:02:09,759
ასე რომ, ეს დაახლოებით 20-plus,
30 ან იმდენად ხაზი კოდი,

47
00:02:09,759 --> 00:02:12,640
მაგრამ საუბარი ჩვენ
იყო, რომელსაც მეტი შესვენების

48
00:02:12,640 --> 00:02:16,000
იმის შესახებ, თუ როგორ ეს რეალურად
იღებს გადაიზარდა zeros და პირობა

49
00:02:16,000 --> 00:02:19,200
და თუ თქვენ არ შეუძლიათ უბრალოდ აღადგინოთ, რომ
დამუშავება და წავიდეთ zeros და პირობა

50
00:02:19,200 --> 00:02:20,210
თავში კოდი.

51
00:02:20,210 --> 00:02:22,620
>> სამწუხაროდ, პროცესი
ასე ტრანსფორმაციული

52
00:02:22,620 --> 00:02:24,890
ის, რომ ბევრი ადვილია, ვიდრე გაკეთება.

53
00:02:24,890 --> 00:02:29,400
მივედი ადრე და რეალურად აღმოჩნდა
ეს პროგრამა, ორობითი ძებნა,

54
00:02:29,400 --> 00:02:32,700
zeros და პირობა გზით
პროგრამა მოუწოდა შემდგენელი რომ მე

55
00:02:32,700 --> 00:02:34,400
მოხდება აქ უფლება ჩემი Mac.

56
00:02:34,400 --> 00:02:37,850
და თუ თქვენ შეხედეთ ეკრანზე
აქ აქცენტს

57
00:02:37,850 --> 00:02:43,520
ამ შუა ექვსი სვეტი მხოლოდ,
დაინახავთ მხოლოდ zeros და პირობა.

58
00:02:43,520 --> 00:02:48,290
და ეს არის zeros და პირობა, რომ
დაკომპლექტებას ზუსტად რომ სამძებრო პროგრამა.

59
00:02:48,290 --> 00:02:53,720
>> ასე რომ, თითოეული ბლოკი ხუთ ბიტი,
თითოეული ბაიტი zeros და პირობა აქ,

60
00:02:53,720 --> 00:02:57,310
წარმოადგენს რამდენიმე დავალებით
როგორც წესი, შიგნით კომპიუტერი.

61
00:02:57,310 --> 00:03:00,730
და სინამდვილეში, თუ თქვენ მოვისმინე
მარკეტინგული სლოგანი "Intel შიგნით", - რომ,

62
00:03:00,730 --> 00:03:04,610
რა თქმა უნდა, მხოლოდ იმას ნიშნავს, თქვენ გაქვთ
Intel CPU ან ტვინის შიგნით კომპიუტერი.

63
00:03:04,610 --> 00:03:08,000
ეს კი იმას ნიშნავს, რომ CPU არის
რომ თქვენ გაქვთ ინსტრუქციის კომპლექტი,

64
00:03:08,000 --> 00:03:08,840
ასე ვთქვათ.

65
00:03:08,840 --> 00:03:11,620
>> ყოველ CPU მსოფლიოში, ბევრი
მათ მიერ Intel ამ დღეებში,

66
00:03:11,620 --> 00:03:13,690
ესმის სასრული
ნომერი ინსტრუქციები.

67
00:03:13,690 --> 00:03:18,690
და იმ ინსტრუქციას იმდენად დაბალი დონე
როგორც დაამატოთ ეს ორი ნომრები ერთად,

68
00:03:18,690 --> 00:03:22,560
გავამრავლოთ ეს ორი ნომრები ერთად,
გადაადგილება ამ ნაჭერი მონაცემები აქ

69
00:03:22,560 --> 00:03:27,340
აქ მეხსიერებაში, გარდა ამ
ინფორმაცია აქედან აქ მეხსიერება,

70
00:03:27,340 --> 00:03:32,200
და ასე forth-- ასე რომ ძალიან,
დაბალი დონის, თითქმის ელექტრონული დეტალები.

71
00:03:32,200 --> 00:03:34,780
მაგრამ იმ მათემატიკის
ოპერაციების რასაც

72
00:03:34,780 --> 00:03:37,410
რაც ჩვენ განვიხილეთ ადრე,
წარმომადგენლობა მონაცემები

73
00:03:37,410 --> 00:03:40,450
როგორც zeros და პირობა, შეუძლია
თქვენ დაამყარონ ყველაფერი

74
00:03:40,450 --> 00:03:44,180
რომ კომპიუტერი დღეს შეგვიძლია, თუ არა
ეს ტექსტური, გრაფიკული, მუსიკალური,

75
00:03:44,180 --> 00:03:45,580
ან სხვაგვარად.

76
00:03:45,580 --> 00:03:49,450
>> ასე რომ, ეს ძალიან ადვილია
დაკარგული სარეველა სწრაფად.

77
00:03:49,450 --> 00:03:52,150
და იქ არის ბევრი
სინტაქსური გამოწვევები

78
00:03:52,150 --> 00:03:56,630
რომლის მიხედვითაც, თუ თქვენ მიიღოს მარტივი,
stupidest of typos არცერთი პროგრამა

79
00:03:56,630 --> 00:03:57,860
იმუშავებს განაწილებაზე.

80
00:03:57,860 --> 00:04:00,366
ასე რომ, ნაცვლად გამოყენებით
ენა, როგორიცაა C ამ დილით,

81
00:04:00,366 --> 00:04:02,240
მე ვფიქრობდი, რომ ეს იქნება
უფრო სახალისო რეალურად

82
00:04:02,240 --> 00:04:04,840
რაღაც უფრო ვიზუალური, რომელიც
ხოლო განკუთვნილია ბავშვებისთვის

83
00:04:04,840 --> 00:04:08,079
ფაქტიურად სრულყოფილი გამოვლინება
ფაქტობრივი პროგრამირების

84
00:04:08,079 --> 00:04:10,370
language-- რაღაც
გამოიყენოთ სურათები ნაცვლად ტექსტი

85
00:04:10,370 --> 00:04:11,710
წარმოადგენს იმ იდეებს.

86
00:04:11,710 --> 00:04:15,470
>> ასე რომ, კიდევ მართლაც აქვს
ანგარიშის scratch.mit.edu,

87
00:04:15,470 --> 00:04:21,070
შესაქმნელად დააჭირეთ ღილაკს
ზედა მარცხენა საიტზე.

88
00:04:21,070 --> 00:04:24,620
და თქვენ უნდა დაინახოს გარემოში, როგორიცაა
ერთი მე ვარ დაახლოებით ვხედავ ჩემს ეკრანზე

89
00:04:24,620 --> 00:04:26,310
აქ.

90
00:04:26,310 --> 00:04:29,350
და ჩვენ გაატაროთ მხოლოდ პატარა
ცოტა დრო თამაშობენ აქ.

91
00:04:29,350 --> 00:04:34,080
მოდით ვნახოთ, თუ ჩვენ არ შეგვიძლია ყველა გადაწყვიტოს ზოგიერთი
პრობლემები ერთად შემდეგ გზა.

92
00:04:34,080 --> 00:04:39,420
>> ასე რომ, რა დაინახავთ ამ
environment-- და რეალურად მხოლოდ ნება

93
00:04:39,420 --> 00:04:40,050
მე პაუზის.

94
00:04:40,050 --> 00:04:42,680
არის ვინმე არ არის აქ?

95
00:04:42,680 --> 00:04:45,070
აქ არა?

96
00:04:45,070 --> 00:04:45,800
კარგი.

97
00:04:45,800 --> 00:04:49,030
ნება მომეცით აღვნიშნო, რამდენიმე
მახასიათებლები ამ გარემოში.

98
00:04:49,030 --> 00:04:55,024
>> ასე რომ, ზედა მარცხენა ეკრანზე, ჩვენ
აქვს Scratch ეტაპზე, ასე ვთქვათ.

99
00:04:55,024 --> 00:04:57,440
Scratch არ არის მხოლოდ სახელი
ამ პროგრამირების ენა;

100
00:04:57,440 --> 00:05:00,356
ის ასევე სახელი კატა, რომელიც
ხედავთ იყოს იქ ფორთოხლის.

101
00:05:00,356 --> 00:05:02,160
ის სცენაზე, ისე,
ჰგავს მე აღწერილი

102
00:05:02,160 --> 00:05:05,770
კუს ადრე მყოფი
მართკუთხა თეთრი ფორუმში გარემო.

103
00:05:05,770 --> 00:05:09,800
ეს კატა მსოფლიოში შემოიფარგლა
რომ ოთხკუთხედი up ზედა არსებობს.

104
00:05:09,800 --> 00:05:12,210
>> იმავდროულად, მარჯვენა
მხარეს აქ, ეს

105
00:05:12,210 --> 00:05:15,610
მხოლოდ სკრიპტები ტერიტორია,
ცარიელი ფურცლიდან თუ.

106
00:05:15,610 --> 00:05:18,590
ეს არის სადაც ჩვენ ვაპირებთ დავწეროთ
ჩვენი პროგრამების რაღაც მომენტში.

107
00:05:18,590 --> 00:05:22,935
და სამშენებლო ბლოკები, რომ ჩვენ უნდა
გამოიყენოთ დაწერა ამ პროგრამის თავსატეხი

108
00:05:22,935 --> 00:05:25,310
ცალი, თუ will-- არიან
იმ უფლება აქ შუა,

109
00:05:25,310 --> 00:05:27,500
და ისინი დაუხარისხებელი
ფუნქციონირება.

110
00:05:27,500 --> 00:05:31,000
ასე, მაგალითად, მე ვაპირებ წავიდეთ წინ
და ვაჩვენოთ მინიმუმ ერთი ასეთი.

111
00:05:31,000 --> 00:05:33,690
მე ვაპირებ წავიდეთ წინ და დააჭირეთ
კონტროლის კატეგორიაში დაბრუნება.

112
00:05:33,690 --> 00:05:35,720
>> ასე რომ ეს არის კატეგორია up დაბრუნება.

113
00:05:35,720 --> 00:05:39,410
მე ვაპირებ დააჭირეთ კონტროლის გარეშე.

114
00:05:39,410 --> 00:05:44,020
პირიქით, მე ვაპირებ დააჭირეთ თარიღები
მიხედვით, პირველი ერთი up დაბრუნება.

115
00:05:44,020 --> 00:05:47,790
და თუ გსურთ, რომ დაიცვას გასწვრივ კი
როგორც ჩვენ ამისათვის, თქვენ საკმაოდ მივესალმებით.

116
00:05:47,790 --> 00:05:52,180
მე ვაპირებ დაწკაპეთ და გადაიტანეთ ეს
პირველი ", როდესაც მწვანე დროშა დააწკაპებთ".

117
00:05:52,180 --> 00:05:58,410
და შემდეგ მე ვაპირებ ჩამოაგდეს ის მხოლოდ
უხეშად ზედა ჩემი ცარიელი დაფები.

118
00:05:58,410 --> 00:06:01,450
>> და რა ლამაზი Scratch
არის, რომ ეს თავსატეხი ცალი, როდესაც

119
00:06:01,450 --> 00:06:04,560
ერთმანეთთანაა სხვა თავსატეხი
ცალი, აპირებს ფაქტიურად

120
00:06:04,560 --> 00:06:06,460
რა იმ თავსატეხი ცალი ამბობენ, ამის გაკეთება.

121
00:06:06,460 --> 00:06:09,710
ასე, მაგალითად, Scratch არის სწორი
ახლა შუა თავის სამყაროს.

122
00:06:09,710 --> 00:06:14,660
მე ვაპირებ წავიდეთ წინ და აირჩიოს
ახლა, მოდით ვთქვათ, მოძრაობის გარეშე,

123
00:06:14,660 --> 00:06:18,000
თუ გსურთ, რომ გავაკეთოთ
same-- Motion კატეგორიაში.

124
00:06:18,000 --> 00:06:20,430
და ახლა შეამჩნია მე მაქვს მთელი
bunch of თავსატეხი ცალი აქ

125
00:06:20,430 --> 00:06:23,370
რომ, კიდევ ერთხელ, სახის გავაკეთოთ, რას ამბობენ.

126
00:06:23,370 --> 00:06:28,110
და მე ვაპირებ წავიდეთ წინ და გადაიტანეთ
ვარდნა ნაბიჯი ბლოკი უფლება აქ.

127
00:06:28,110 --> 00:06:31,860
>> და შენიშნავს, რომ, როგორც კი თქვენ
ახლოს ბოლოში "მწვანე დროშა

128
00:06:31,860 --> 00:06:34,580
აირჩიეთ "ღილაკს, ცნობა
როგორ თეთრი ხაზი, როგორც ჩანს,

129
00:06:34,580 --> 00:06:36,950
თითქოს ეს თითქმის
მაგნიტური, მას სურს, რომ იქ წასვლა.

130
00:06:36,950 --> 00:06:43,070
უბრალოდ გაუშვებენ, და ეს იქნება ვადამდელი
ერთად და ფორმებს შეესაბამება.

131
00:06:43,070 --> 00:06:46,620
და ახლა თქვენ შეგიძლიათ ალბათ, თითქმის
ვხვდები, სადაც ჩვენ ვაპირებთ ამ.

132
00:06:46,620 --> 00:06:51,570
>> თუ გადავხედავთ Scratch ეტაპზე
აქ და ვუყურებთ თავზე,

133
00:06:51,570 --> 00:06:55,142
დაინახავთ წითელი მსუბუქი,
გაჩერების ნიშანი, და მწვანე დროშა.

134
00:06:55,142 --> 00:06:57,100
და მე ვაპირებ წავიდეთ წინ
და ნახოთ ჩემი ეკრანზე

135
00:06:57,100 --> 00:06:58,460
მხოლოდ ერთი წუთით, თუ შეიძლება.

136
00:06:58,460 --> 00:07:01,960
მე ვაპირებ დააჭირეთ
მწვანე დროშა ახლა,

137
00:07:01,960 --> 00:07:07,850
და ის გადავიდა, რაც, როგორც ჩანს, 10 ნაბიჯები
ან 10 pixels, 10 წერტილები, ეკრანზე.

138
00:07:07,850 --> 00:07:13,390
>> ასე რომ, არ არის, რომ საინტერესო,
მაგრამ ნება მომეცით შესთავაზოს

139
00:07:13,390 --> 00:07:17,440
გარეშე კი ასწავლის, უბრალოდ
გამოყენებით საკუთარი საკუთარი intuition-- let

140
00:07:17,440 --> 00:07:22,560
მე ვთავაზობ, რომ თქვენ გაერკვნენ, თუ როგორ
რათა Scratch გასეირნების უფლება off ეტაპზე.

141
00:07:22,560 --> 00:07:28,700
მას, რათა გზა მარჯვენა მხარეს
ეკრანზე, ყველა გზა უფლება.

142
00:07:28,700 --> 00:07:32,200
ნება მიბოძეთ, ერთი წუთით
ან ასე ჭიდაობა რომ.

143
00:07:32,200 --> 00:07:37,681
დაგვჭირდება შევხედოთ
სხვა კატეგორია ბლოკები.

144
00:07:37,681 --> 00:07:38,180
კარგი.

145
00:07:38,180 --> 00:07:41,290
ასე რომ მხოლოდ recap, როდესაც ჩვენ
მწვანე დროშა დააწკაპებთ აქ

146
00:07:41,290 --> 00:07:44,850
და გადაადგილება 10 ნაბიჯები არის
მხოლოდ დავალებით, ყოველ ჯერზე მე

147
00:07:44,850 --> 00:07:46,720
დააჭირეთ მწვანე დროშა, რა ხდება?

148
00:07:46,720 --> 00:07:50,070
ისე, რომ გაშვებული პროგრამა.

149
00:07:50,070 --> 00:07:52,450
ასე რომ, მე ვერ გავაკეთებ ამ
იქნებ 10-ჯერ ხელით,

150
00:07:52,450 --> 00:07:55,130
მაგრამ ეს გრძნობს პატარა
ცოტა hackish, ასე ვთქვათ,

151
00:07:55,130 --> 00:07:57,480
რომლის დროსაც მე არ ვარ ნამდვილად
პრობლემის გადაჭრის.

152
00:07:57,480 --> 00:08:00,530
მე უბრალოდ ცდილობს ერთხელ და
ისევ და ისევ და ისევ

153
00:08:00,530 --> 00:08:03,180
სანამ მე ერთგვარი შემთხვევით
მისაღწევად დირექტივა

154
00:08:03,180 --> 00:08:05,560
რომ მე შეიქმნა იმისათვის, რომ მივაღწიოთ ადრე.

155
00:08:05,560 --> 00:08:08,200
>> მაგრამ ჩვენ ვიცით, ჩვენი
pseudocode ადრე, რომ იქ

156
00:08:08,200 --> 00:08:11,870
ეს ცნება პროგრამირების looping,
თავისსავე ისევ და ისევ.

157
00:08:11,870 --> 00:08:14,888
ასე რომ, მე დავინახე, რომ რამოდენიმე თქვენ
მიაღწია რა თავსატეხი ცალი?

158
00:08:14,888 --> 00:08:17,870

159
00:08:17,870 --> 00:08:18,730
ვიმეორებ, სანამ.

160
00:08:18,730 --> 00:08:21,400
ასე რომ, ჩვენ შეიძლება რაღაც
როგორიცაა ვიმეორებ, სანამ.

161
00:08:21,400 --> 00:08:23,760
და რა თქვენ ვიმეორებ, სანამ ზუსტად?

162
00:08:23,760 --> 00:08:27,720

163
00:08:27,720 --> 00:08:28,540
>> კარგი.

164
00:08:28,540 --> 00:08:31,974
და ნება მომეცით წავიდეთ ერთად ერთი, რომ
გარკვეულწილად მარტივია რაღაც მომენტში.

165
00:08:31,974 --> 00:08:33,140
ნება მომეცით წავიდეთ წინ და ამის გაკეთება.

166
00:08:33,140 --> 00:08:35,559
გაითვალისწინეთ, რომ, როგორც თქვენ შეიძლება ჰქონდეს
აღმოაჩინა კონტროლის ქვეშ,

167
00:08:35,559 --> 00:08:38,409
არ არის ეს განმეორებითი ბლოკი, რომელიც
არ ჰგავს ის, რომ დიდი.

168
00:08:38,409 --> 00:08:41,039
იქ არ არის ბევრი ოთახი
შორის ორი ყვითელი ხაზები.

169
00:08:41,039 --> 00:08:43,539
მაგრამ, როგორც ზოგიერთი ალბათ
შენიშნა, თუ გადააადგილება,

170
00:08:43,539 --> 00:08:45,150
შეამჩნევთ, თუ როგორ იზრდება შეავსოთ ფორმა.

171
00:08:45,150 --> 00:08:46,274
>> და თქვენ შეგიძლიათ კიდევ cram მეტი.

172
00:08:46,274 --> 00:08:48,670
ეს უბრალოდ შენარჩუნება იზრდება თუ
თქვენ გადაიტანეთ და hover მას.

173
00:08:48,670 --> 00:08:51,110
და მე არ ვიცი, რა არის
საუკეთესო აქ, მოდით

174
00:08:51,110 --> 00:08:54,760
ყოველ შემთხვევაში ჩემთვის ვიმეორებ ხუთ ჯერ,
მაგალითად, და შემდეგ დაბრუნდეს სცენაზე

175
00:08:54,760 --> 00:08:56,720
და დააჭირეთ მწვანე დროშა.

176
00:08:56,720 --> 00:08:59,110
და ახლა შეამჩნია, რომ ეს არ არის იქ.

177
00:08:59,110 --> 00:09:02,400
>> ახლა ზოგიერთი თქვენ შესთავაზა, როგორც
Victoria უბრალოდ არ, ვიმეორებ 10 ჯერ.

178
00:09:02,400 --> 00:09:05,140
და რომ საერთოდ
მისაღებად მას ყველა გზა,

179
00:09:05,140 --> 00:09:10,510
მაგრამ არ იყოს უფრო ძლიერი
გზა, ვიდრე თვითნებურად მჭიდროდაა

180
00:09:10,510 --> 00:09:12,640
რამდენი ნაბიჯები, რათა?

181
00:09:12,640 --> 00:09:17,680
რა შეიძლება იყოს უკეთესი ბლოკი
ვიდრე ვიმეორებ 10 ჯერ იყოს?

182
00:09:17,680 --> 00:09:20,380
>> ჰო, ისე, რატომ არ უნდა გავაკეთოთ რაღაც სამუდამოდ?

183
00:09:20,380 --> 00:09:24,390
ახლა კი ნება მომეცით გადავიდეს ამ თავსატეხი ცალი
შიგნით არსებობს და მოშორება ეს ერთი.

184
00:09:24,390 --> 00:09:28,300
ახლა შეამჩნია, არ აქვს მნიშვნელობა, სადაც Scratch
იწყება, ის მიდის პირას.

185
00:09:28,300 --> 00:09:30,700
და საბედნიეროდ MIT,
რომელიც იღებს Scratch, უბრალოდ

186
00:09:30,700 --> 00:09:33,190
რაც დარწმუნებული ვარ, რომ ის არასდროს
ქრება მთლიანად.

187
00:09:33,190 --> 00:09:35,360
თქვენ ყოველთვის შეგიძლიათ დაიბრუნოს მისი კუდი.

188
00:09:35,360 --> 00:09:37,680
>> და მხოლოდ ინტუიციურად,
რატომ შენარჩუნება მოძრავი?

189
00:09:37,680 --> 00:09:38,892
აქ რა ხდება?

190
00:09:38,892 --> 00:09:41,440

191
00:09:41,440 --> 00:09:43,824
მან, როგორც ჩანს, არ გაჩერდა, მაგრამ
თუ მე შეარჩიო და გადაიტანეთ

192
00:09:43,824 --> 00:09:45,240
იგი ინარჩუნებს უნდოდა წასვლა, იქ.

193
00:09:45,240 --> 00:09:46,123
რატომ არის, რომ?

194
00:09:46,123 --> 00:09:51,610

195
00:09:51,610 --> 00:09:54,360
მართლაც, კომპიუტერი ფაქტიურად
აპირებს თუ რა გითხრათ, ეს უნდა გააკეთოს.

196
00:09:54,360 --> 00:09:58,380
ასე რომ, თუ უთხრეს, რომ ეს ადრე გააკეთოთ
შემდეგ, რაც სამუდამოდ, გადაადგილება 10 ნაბიჯები,

197
00:09:58,380 --> 00:10:01,860
ის აპირებს შენარჩუნებას აპირებს და აპირებს
სანამ მოხვდა წითელი გაჩერების ნიშანი

198
00:10:01,860 --> 00:10:04,620
და შეწყვიტოს პროგრამა საერთოდ.

199
00:10:04,620 --> 00:10:06,610
>> ასე რომ, თუ თქვენ არ
ამისათვის, როგორ შეიძლება მე

200
00:10:06,610 --> 00:10:09,510
რათა Scratch ნაბიჯი სწრაფად
მთელს ეკრანზე?

201
00:10:09,510 --> 00:10:12,060

202
00:10:12,060 --> 00:10:13,280
სხვა ნაბიჯები, არა?

203
00:10:13,280 --> 00:10:15,710
ასე რომ ნაცვლად აკეთებს 10
იმ დროს, რატომ არ გვაქვს

204
00:10:15,710 --> 00:10:20,100
წავიდეთ წინ და შეცვალოს იგი, რომელთა მიზანია
რას შესთავაზოს 50?

205
00:10:20,100 --> 00:10:24,410
ასე რომ, ახლა მე ვაპირებ დააჭირეთ მწვანე
დროშა, და მართლაც, ის მიდის მართლაც სწრაფი.

206
00:10:24,410 --> 00:10:27,180
>> და ეს, რა თქმა უნდა, მხოლოდ
გამოვლინება ანიმაცია.

207
00:10:27,180 --> 00:10:28,060
რა არის ანიმაცია?

208
00:10:28,060 --> 00:10:33,090
უბრალოდ გვიჩვენებს, თუ ადამიანის
მთელი bunch of ჯერ კიდევ სურათები მართლაც,

209
00:10:33,090 --> 00:10:34,160
რეალურად, მართლაც სწრაფად.

210
00:10:34,160 --> 00:10:36,500
ასე რომ, თუ ჩვენ უბრალოდ ვეუბნებოდი
მას გადაადგილება უფრო ნაბიჯები,

211
00:10:36,500 --> 00:10:39,750
ჩვენ უბრალოდ მქონე ეფექტი იყოს
ცვლილება, სადაც ის არის ეკრანზე

212
00:10:39,750 --> 00:10:42,900
ყველა უფრო სწრაფად ერთეულის დრო.

213
00:10:42,900 --> 00:10:46,454
>> ახლა შემდეგი გამოწვევა, რომელიც მე შევთავაზე
იყო, რომ მის ახსნას off ზღვარზე.

214
00:10:46,454 --> 00:10:49,120
და გარეშე იცის რა თავსატეხი
ცალი exist-- იმიტომ, რომ ეს ჯარიმა

215
00:10:49,120 --> 00:10:53,030
თუ არ უნდა, რომ
ეტაპზე გამოწვევა, რაც

216
00:10:53,030 --> 00:10:54,280
გინდა ამის ინტუიციურად?

217
00:10:54,280 --> 00:10:58,030
როგორ გვაქვს მას ახსნას უკან და
მეოთხე, შორის მარცხენა და მარჯვენა?

218
00:10:58,030 --> 00:11:02,630

219
00:11:02,630 --> 00:11:03,810
>> ჰო.

220
00:11:03,810 --> 00:11:05,680
ასე რომ, ჩვენ გვჭირდება გარკვეული
მდგომარეობა, და ჩვენ

221
00:11:05,680 --> 00:11:09,710
როგორც ჩანს, აქვს პირობით, ასე
საუბარი, კონტროლის ქვეშ კატეგორიაში.

222
00:11:09,710 --> 00:11:14,110
რომელიც ამ ბლოკის
ჩვენ, ალბათ, სურს?

223
00:11:14,110 --> 00:11:15,200
ჰო, ალბათ, "თუ შემდეგ."

224
00:11:15,200 --> 00:11:18,780
ასე რომ შეამჩნია, რომ მათ შორის ყვითელი ბლოკები
ჩვენ აქ, არ არის ეს "თუ"

225
00:11:18,780 --> 00:11:23,920
ან ეს "თუ სხვაგან," ბლოკი, რომელიც
საშუალებას მოგვცემს, რომ მიიღოს გადაწყვეტილება, რომ ამის გაკეთება

226
00:11:23,920 --> 00:11:25,000
და ამის გაკეთება.

227
00:11:25,000 --> 00:11:27,380
და თქვენ შეგიძლიათ კიდევ ბუდე მათ
გავაკეთოთ მრავალჯერადი რამ.

228
00:11:27,380 --> 00:11:34,910
ან თუ თქვენ არ წავიდა არის აქ,
წავიდეთ წინ ზონდირება კატეგორიაში

229
00:11:34,910 --> 00:11:39,612
and-- ვნახოთ, თუ ის აქ.

230
00:11:39,612 --> 00:11:43,050

231
00:11:43,050 --> 00:11:52,050
>> ასე რომ, რა ბლოკი შეიძლება იყოს სასარგებლო, აქ
აღმოაჩინოს თუ ის off ეტაპზე?

232
00:11:52,050 --> 00:11:56,740
ჰო, რომ ზოგიერთი ამ ბლოკის
შეიძლება parametrized, ასე ვთქვათ.

233
00:11:56,740 --> 00:12:00,706
ისინი შეიძლება ერთგვარი მორგებული, არ
განსხვავებით HTML გუშინ ატრიბუტები,

234
00:12:00,706 --> 00:12:03,330
სადაც იმ ატრიბუტებს სახის
სახის ქცევა აქვს.

235
00:12:03,330 --> 00:12:08,880
ანალოგიურად აქ, შეიძლება მე დაიბრუნოს ეს ეხება
ბლოკი და ცვლილება და ვთხოვო კითხვა,

236
00:12:08,880 --> 00:12:11,500
თქვენ ეხება თაგვის
მაჩვენებელი, როგორც კურსორი

237
00:12:11,500 --> 00:12:13,250
ან თქვენ ეხება ზღვარზე?

238
00:12:13,250 --> 00:12:15,210
>> ნება მომეცით, წავიდეთ და ამის გაკეთება.

239
00:12:15,210 --> 00:12:18,130
მე ვაპირებ დააშორებს მომენტში.

240
00:12:18,130 --> 00:12:21,320
ნება მიბოძეთ აითვისებდა ამ თავსატეხი ცალი
აქ, ამ თავსატეხი ცალი ამ,

241
00:12:21,320 --> 00:12:24,570
და მე ვაპირებ Jumble
მათ მხოლოდ ერთი წუთით.

242
00:12:24,570 --> 00:12:27,620
მე ვაპირებ გადაადგილება ამ,
შეცვალოს ეს ეხება პირას,

243
00:12:27,620 --> 00:12:38,590
და მე ვაპირებ მოძრაობის გაკეთება.

244
00:12:38,590 --> 00:12:40,490
ასე რომ, აქ არის გარკვეული ინგრედიენტები.

245
00:12:40,490 --> 00:12:42,570
მე ვფიქრობ, რომ მაქვს ყველაფერი მინდა.

246
00:12:42,570 --> 00:12:47,710
>> რომ ვინმე მინდა შესთავაზოს, თუ მე
შეგიძლიათ დაკავშირება ეს, ალბათ, ყველაზე ქვედა

247
00:12:47,710 --> 00:12:52,020
იმისათვის, რომ ამ პრობლემის მოსაგვარებლად, რომელსაც
Scratch ნაბიჯი უფლება მარცხნიდან მარჯვნივ

248
00:12:52,020 --> 00:12:57,020
მარცხნიდან მარჯვნივ მარცხნივ, თითოეულ
დრო მხოლოდ bouncing off კედელზე?

249
00:12:57,020 --> 00:12:58,050
რა უნდა გავაკეთოთ?

250
00:12:58,050 --> 00:13:01,097
რომელი ბლოკი უნდა დაკავშირება
"როდესაც მწვანე დროშის დაწკაპავთ პირველი"?

251
00:13:01,097 --> 00:13:04,060

252
00:13:04,060 --> 00:13:06,200
>> OK, ასე რომ დავიწყოთ "სამუდამოდ".

253
00:13:06,200 --> 00:13:07,170
რა მიდის შიგნით შემდეგი?

254
00:13:07,170 --> 00:13:10,290
ვიღაც სხვა.

255
00:13:10,290 --> 00:13:11,850
OK, გადაადგილება ნაბიჯები.

256
00:13:11,850 --> 00:13:12,350
კარგი.

257
00:13:12,350 --> 00:13:14,470
მერე რა?

258
00:13:14,470 --> 00:13:15,120
ასე რომ, თუ.

259
00:13:15,120 --> 00:13:17,720
და შეამჩნია, მიუხედავად იმისა, რომ გამოიყურება
მოქცეული ერთად მჭიდროდ,

260
00:13:17,720 --> 00:13:19,500
ეს იქნება მხოლოდ იზრდება შევსება.

261
00:13:19,500 --> 00:13:21,500
ეს უბრალოდ ხტომა სადაც მე მინდა.

262
00:13:21,500 --> 00:13:25,920
>> და რა შემიძლია დააყენა შორის
თუ და მაშინ?

263
00:13:25,920 --> 00:13:27,180
სავარაუდოდ, "იმ შემთხვევაში, თუ ეხება პირას."

264
00:13:27,180 --> 00:13:31,800
და შეამჩნია, კიდევ ერთხელ, ეს არის ძალიან დიდი
მას, მაგრამ ეს გაიზრდება შევსება.

265
00:13:31,800 --> 00:13:35,002
და მერე 15 გრადუსი?

266
00:13:35,002 --> 00:13:35,710
რამდენი გრადუსი?

267
00:13:35,710 --> 00:13:38,800

268
00:13:38,800 --> 00:13:41,196
ჰო, ასე რომ 180 დაიძაბება
ჩემთვის ყველა გზა გარშემო.

269
00:13:41,196 --> 00:13:42,570
მოდით ვნახოთ, თუ მე მივიღე ეს უფლება.

270
00:13:42,570 --> 00:13:43,930
ნება მომეცით დააშორებს.

271
00:13:43,930 --> 00:13:45,130
>> მიადევნე თვალი გადაიტანეთ Scratch up.

272
00:13:45,130 --> 00:13:50,030
ასე რომ, ის ცოტა დამახინჯებული
ახლა, მაგრამ ეს ჯარიმა.

273
00:13:50,030 --> 00:13:52,231
როგორ შევცვალო მას ადვილად?

274
00:13:52,231 --> 00:13:59,879

275
00:13:59,879 --> 00:14:01,045
მე ვაპირებ მოტყუებას ოდნავ.

276
00:14:01,045 --> 00:14:04,074

277
00:14:04,074 --> 00:14:05,990
ასე რომ, მე კიდევ ერთი
ბლოკი, უბრალოდ უნდა იყოს მკაფიო.

278
00:14:05,990 --> 00:14:08,424
მინდა, აღვნიშნო, 90 გრადუსი
მარჯვნივ ჩვეულებრივ,

279
00:14:08,424 --> 00:14:10,840
ასე რომ, მე ვაპირებ ვუთხრა მას,
უნდა გავაკეთოთ, რომ პროგრამულად.

280
00:14:10,840 --> 00:14:11,632
და აქ ჩვენ მივდივართ.

281
00:14:11,632 --> 00:14:14,740

282
00:14:14,740 --> 00:14:15,740
ჩვენ, როგორც ჩანს არ გააკეთებდა.

283
00:14:15,740 --> 00:14:19,980
ეს ცოტა უცნაურია, რადგან
ის ფეხით თავდაყირა.

284
00:14:19,980 --> 00:14:21,250
მოდით მოვუწოდებთ, რომ შეცდომა.

285
00:14:21,250 --> 00:14:22,120
ეს არის შეცდომა.

286
00:14:22,120 --> 00:14:27,320
ხარვეზის არის შეცდომა პროგრამა,
ლოგიკური შეცდომა, რომ მე, ადამიანური, გააკეთა.

287
00:14:27,320 --> 00:14:28,985
რატომ არის იგი აპირებს თავდაყირა?

288
00:14:28,985 --> 00:14:33,560

289
00:14:33,560 --> 00:14:35,250
არ MIT ხრახნიანი ან არ მინდა?

290
00:14:35,250 --> 00:14:38,840

291
00:14:38,840 --> 00:14:42,550
>> ჰო, მე ვგულისხმობ, რომ ეს არ არის MIT- ის
ბრალია. მომცეს თავსატეხი ცალი

292
00:14:42,550 --> 00:14:44,970
რომელიც ამბობს, რომ გახდეს ზოგიერთი რაოდენობა გრადუსი.

293
00:14:44,970 --> 00:14:47,672
და ვიქტორია წინადადება,
მე გარდამტეხი 180 გრადუსი,

294
00:14:47,672 --> 00:14:48,880
რაც სწორი ინტუიცია.

295
00:14:48,880 --> 00:14:53,700
მაგრამ გარდამტეხი 180 გრადუსი ფაქტიურად
ნიშნავს იმას, რომ 180 გრადუსი,

296
00:14:53,700 --> 00:14:55,860
და ეს არ არის ნამდვილად
რაც მე მინდა, როგორც ჩანს.

297
00:14:55,860 --> 00:14:58,026
იმის გამო, რომ მაინც ის არის
ეს ორგანზომილებიანი მსოფლიოში,

298
00:14:58,026 --> 00:15:00,740
ასე გადამწყვეტი ხდება სინამდვილეში
Flip, მას თავდაყირა.

299
00:15:00,740 --> 00:15:04,030
>> მე, ალბათ, სურს გამოიყენოს რა ბლოკი
ნაცვლად, ეფუძნება რა ხედავთ აქ?

300
00:15:04,030 --> 00:15:11,890

301
00:15:11,890 --> 00:15:14,790
როგორ შეიძლება მოვაგვაროთ ეს პრობლემა?

302
00:15:14,790 --> 00:15:18,380
ჰო, ამიტომ, შესაძლოა,
საპირისპირო მიმართულებით.

303
00:15:18,380 --> 00:15:22,300
და რეალურად კი, რომ
არ იქნება საკმარისი,

304
00:15:22,300 --> 00:15:26,410
იმიტომ, რომ ჩვენ მხოლოდ მძიმე კოდი
მიუთითებს მარცხნივ ან მარჯვნივ.

305
00:15:26,410 --> 00:15:27,920
>> თქვენ იცით, რა შეგვიძლია გავაკეთოთ?

306
00:15:27,920 --> 00:15:30,160
როგორც ჩანს, ჩვენ გვაქვს
ფონდის ბლოკის აქ.

307
00:15:30,160 --> 00:15:32,987
თუ ზომით, ვხედავ
ის, რომ ჩვენ აქ?

308
00:15:32,987 --> 00:15:36,120

309
00:15:36,120 --> 00:15:40,020
ასე გამოიყურება MIT აქვს
აბსტრაქცია აშენდა აქ.

310
00:15:40,020 --> 00:15:45,440
ამ ბლოკში, როგორც ჩანს ექვივალენტი
რომლის სხვა ბლოკები, მრავლობითი?

311
00:15:45,440 --> 00:15:49,510
>> ეს ერთი ბლოკი, როგორც ჩანს ექვივალენტი
მთელი ამ ტრიო ბლოკები

312
00:15:49,510 --> 00:15:50,880
რომ ჩვენ გვაქვს აქ.

313
00:15:50,880 --> 00:15:54,670
გამოდის, რომ მე შეიძლება გამარტივდეს ჩემი
პროგრამის მიერ მოშორების ყველა იმ

314
00:15:54,670 --> 00:15:58,270
და უბრალოდ დააყენა ამ აქ.

315
00:15:58,270 --> 00:16:01,620
და ახლა ის ჯერ კიდევ პატარა
buggy, და ეს ჯარიმა არის.

316
00:16:01,620 --> 00:16:03,370
ჩვენ დავტოვებთ, რომ იყოს.

317
00:16:03,370 --> 00:16:06,000
მაგრამ ჩემი პროგრამა კი
მარტივი და ეს, ძალიან,

318
00:16:06,000 --> 00:16:09,060
იქნება წარმომადგენელი
ერთი მიზანი პროგრამირების

319
00:16:09,060 --> 00:16:13,430
არის იდეალურად თქვენი კოდი, როგორც
მარტივი, როგორც კომპაქტური რაც შეიძლება,

320
00:16:13,430 --> 00:16:15,650
მიუხედავად იმისა, როგორც
იკითხება როგორც შესაძლებელი.

321
00:16:15,650 --> 00:16:20,310
თქვენ არ სურს ისე, ლაკონური
, რომ ეს რთული გასაგებია.

322
00:16:20,310 --> 00:16:22,826
>> მაგრამ შეამჩნია მე შეცვალა
სამ ერთი,

323
00:16:22,826 --> 00:16:24,200
და ეს, ალბათ, კარგია.

324
00:16:24,200 --> 00:16:27,280
მე ამოღებული მოშორებით ცნება
შემოწმების თუ თქვენ

325
00:16:27,280 --> 00:16:29,120
ზღვარზე მხოლოდ ერთი ბლოკი.

326
00:16:29,120 --> 00:16:31,520
ახლა ჩვენ შეგვიძლია დაათვალიერეთ ეს, ფაქტობრივად.

327
00:16:31,520 --> 00:16:35,790
ეს არ დაამატოთ იმდენად
ინტელექტუალური ღირებულება, მაგრამ playful ღირებულება.

328
00:16:35,790 --> 00:16:39,730
მე ვაპირებ წავიდეთ წინ
და დაიბრუნოს ეს ხმა აქ.

329
00:16:39,730 --> 00:16:42,900

330
00:16:42,900 --> 00:16:46,420
ნება მომეცით წავიდეთ წინ, და ნება მომეცით
გადაცემის შეჩერება ერთი წუთით.

331
00:16:46,420 --> 00:16:52,070
მე ვაპირებ ჩაწერას შემდეგ,
საშუალებას აძლევს ხელმისაწვდომობის ჩემი მიკროფონი.

332
00:16:52,070 --> 00:16:53,181
>> აქ ჩვენ მივდივართ.

333
00:16:53,181 --> 00:16:53,680
Ouch.

334
00:16:53,680 --> 00:16:58,710

335
00:16:58,710 --> 00:17:01,140
შევეცადოთ ეს კიდევ ერთხელ.

336
00:17:01,140 --> 00:17:02,279
აქ ჩვენ მივდივართ.

337
00:17:02,279 --> 00:17:03,570
OK, მე ჩაწერილი არასწორია.

338
00:17:03,570 --> 00:17:04,580
აქ ჩვენ მივდივართ.

339
00:17:04,580 --> 00:17:05,080
Ouch.

340
00:17:05,080 --> 00:17:07,910

341
00:17:07,910 --> 00:17:08,800
Ouch.

342
00:17:08,800 --> 00:17:09,300
კარგი.

343
00:17:09,300 --> 00:17:10,791
ახლა მე უნდა დაეღწია, რომ.

344
00:17:10,791 --> 00:17:11,290
კარგი.

345
00:17:11,290 --> 00:17:13,950
>> ასე რომ, ახლა მე მაქვს
ჩაწერა მხოლოდ "ouch".

346
00:17:13,950 --> 00:17:18,040
ასე რომ, ახლა მე ვაპირებ წასვლა
წინ და დაარქვით "ouch".

347
00:17:18,040 --> 00:17:20,270
მე ვაპირებ დაბრუნდეს
ჩემი სკრიპტები, და ახლა

348
00:17:20,270 --> 00:17:25,460
გაფრთხილების ამ ბლოკის რომ ე.წ.
თამაში ხმის "Meow" და თამაში ხმის "ouch".

349
00:17:25,460 --> 00:17:28,920
მე ვაპირებ გადაიტანეთ ეს, და სადაც
უნდა დააყენოს ამ კომიკური ეფექტი?

350
00:17:28,920 --> 00:17:31,740

351
00:17:31,740 --> 00:17:37,860
ჰო, ასე რომ, ახლა ეს სახის
buggy, რადგან ახლა ეს ბლოკი

352
00:17:37,860 --> 00:17:42,050
შეამჩნევთ, თუ როგორ ეს "თუ პირას,
bounce "არის ერთგვარი თვითმმართველობის შეიცავს.

353
00:17:42,050 --> 00:17:43,704
ასე რომ, მე და ეს უნდა გამოვასწოროთ.

354
00:17:43,704 --> 00:17:44,870
ნება მომეცით წავიდეთ წინ და ამის გაკეთება.

355
00:17:44,870 --> 00:17:48,630
ნება მომეცით დაეღწია ამ და დაბრუნდეს
ჩვენი ორიგინალური, უფრო მიზანმიმართული

356
00:17:48,630 --> 00:17:49,870
ფუნქცია.

357
00:17:49,870 --> 00:18:01,080
ასე რომ, "თუ ეხება ზღვარზე, მაშინ" მინდა
თავის მხრივ, როგორც Victoria შემოთავაზებული,

358
00:18:01,080 --> 00:18:02,480
180 გრადუსი.

359
00:18:02,480 --> 00:18:05,497
და მე მინდა, რომ ითამაშოს
ხმა "ouch" არსებობს?

360
00:18:05,497 --> 00:18:11,800

361
00:18:11,800 --> 00:18:15,580
>> ჰო, შენიშნავს, რომ ის გარეთ
ყვითელი ბლოკი.

362
00:18:15,580 --> 00:18:17,680
ასე რომ, ეს, ძალიან, იქნება
bug, მაგრამ მე ეს შენიშნეს.

363
00:18:17,680 --> 00:18:21,290
ამიტომ, მე ვაპირებ გადაიტანეთ აქ,
და შეამჩნია, ახლა შიგნით "თუ".

364
00:18:21,290 --> 00:18:24,250
ასე რომ, "თუ" არის ამ სახის
მოსწონს arm მსგავსი blot

365
00:18:24,250 --> 00:18:26,260
რომ მხოლოდ აპირებს
გავაკეთოთ რა შიგნით მას.

366
00:18:26,260 --> 00:18:30,216
ასე რომ, ახლა თუ დააშორებს ზე
რისკი annoying--

367
00:18:30,216 --> 00:18:32,860

368
00:18:32,860 --> 00:18:36,470
>> კომპიუტერული: Ouch, ouch, ouch.

369
00:18:36,470 --> 00:18:39,910
>> დავით Malan: ეს
მხოლოდ გაგრძელდება სამუდამოდ.

370
00:18:39,910 --> 00:18:44,160
ახლა მხოლოდ დააჩქაროს რამ
აქ, ნება მომეცით წავიდეთ წინ და გახსენით,

371
00:18:44,160 --> 00:18:50,460
ვთქვათ ნება მომეცით წავიდეთ ზოგიერთი
ჩემი საკუთარი პერსონალის კლასში.

372
00:18:50,460 --> 00:18:53,000

373
00:18:53,000 --> 00:19:00,220
და ნება მომეცით გახსნა, ვთქვათ, ამ
ერთი გააკეთა ერთი ჩვენი სწავლების პრაქტიკის

374
00:19:00,220 --> 00:19:01,500
რამდენიმე წლის წინ.

375
00:19:01,500 --> 00:19:04,732
ასე რომ, ზოგიერთ თქვენგანს შეიძლება გავიხსენოთ
ამ თამაშში წარსულის,

376
00:19:04,732 --> 00:19:05,940
და ეს, ფაქტობრივად, აღსანიშნავია.

377
00:19:05,940 --> 00:19:08,190
მიუხედავად იმისა, რომ ჩვენ გავაკეთეთ
მარტივი პროგრამების ახლა,

378
00:19:08,190 --> 00:19:09,980
განვიხილოთ, რა არის ეს
რეალურად გამოიყურება.

379
00:19:09,980 --> 00:19:10,650
მიადევნე თვალი მოხვდა პიესა.

380
00:19:10,650 --> 00:19:14,210

381
00:19:14,210 --> 00:19:18,980
>> ასე რომ ამ თამაშში, ჩვენ გვაქვს
ბაყაყი და გამოყენებით arrow keys--

382
00:19:18,980 --> 00:19:23,340
იგი იღებს უფრო დიდი ნაბიჯები, ვიდრე მე გვახსოვდეს
მაქვს კონტროლი ამ frog.

383
00:19:23,340 --> 00:19:29,630
და მიზანია, რომ მასშტაბით დაკავებულია
გზის გარეშე გაშვებული შევიდა მანქანა.

384
00:19:29,630 --> 00:19:34,735
და ვნახოთ, თუ მე აქ, მე
უნდა ველოდოთ შესვლა გადახვევა მიერ.

385
00:19:34,735 --> 00:19:38,130

386
00:19:38,130 --> 00:19:39,274
ეს იგრძნობა bug.

387
00:19:39,274 --> 00:19:42,240

388
00:19:42,240 --> 00:19:43,495
ეს არის ერთგვარი შეცდომა.

389
00:19:43,495 --> 00:19:45,980

390
00:19:45,980 --> 00:19:46,480
კარგი.

391
00:19:46,480 --> 00:19:51,550
მე ვარ აქ,
იქ, და მაშინ თქვენ გაქვთ

392
00:19:51,550 --> 00:19:54,100
აპირებს, სანამ თქვენ ყველა
ბაყაყები ლილი ბალიშები.

393
00:19:54,100 --> 00:19:55,920
ახლა ეს შეიძლება გამოიყურებოდეს
ყველა უფრო რთული,

394
00:19:55,920 --> 00:19:57,840
მაგრამ მოდით ცდილობენ დაარღვიოს
ქვემოთ გონებრივად

395
00:19:57,840 --> 00:20:00,040
და სიტყვიერი შევიდა მისი შემადგენელი ბლოკები.

396
00:20:00,040 --> 00:20:03,910
ასე რომ, ალბათ, თავსატეხი
ნაჭერი, რომ ჩვენ არ ჩანს

397
00:20:03,910 --> 00:20:07,440
მაგრამ, რომ რეაგირების keystrokes,
რამ მე მოხვდა კლავიატურაზე.

398
00:20:07,440 --> 00:20:11,660
>> ასე რომ, ალბათ, გარკვეული სახის
ბლოკი, რომელიც ამბობს, თუ გასაღები შეადგენს up,

399
00:20:11,660 --> 00:20:15,965
მაშინ ნუ რაღაც ნულიდან
შესაძლოა გადავიდეს ეს 10 ნაბიჯები ამ გზით.

400
00:20:15,965 --> 00:20:20,240
თუ ქვემოთ გასაღები დაპრესილი, გადაადგილება 10 ნაბიჯები
ამ გზით, და მარცხენა ღილაკს, გადაადგილება 10 ნაბიჯები

401
00:20:20,240 --> 00:20:21,710
ამ გზით, 10 ნაბიჯი, რომელიც.

402
00:20:21,710 --> 00:20:23,644
მე ნათლად აღმოჩნდა კატა შევიდა frog.

403
00:20:23,644 --> 00:20:26,060
ასე რომ, მხოლოდ, სადაც
costume, როგორც Scratch ზარები it-- ჩვენ

404
00:20:26,060 --> 00:20:28,440
მხოლოდ იმპორტირებული სურათს frog.

405
00:20:28,440 --> 00:20:29,570
>> მაგრამ რა ხდება?

406
00:20:29,570 --> 00:20:32,794
სხვა რა ხაზი კოდი,
სხვა რა თავსატეხი ცალი

407
00:20:32,794 --> 00:20:35,460
გააკეთა ბლეიკი, ჩვენი სწავლების თანამემამულე,
გამოყენება ამ პროგრამის, როგორც ჩანს?

408
00:20:35,460 --> 00:20:38,320

409
00:20:38,320 --> 00:20:42,730
რა ყველაფრის გადაადგილება
რა პროგრამირების მშენებლობა?

410
00:20:42,730 --> 00:20:44,950
>> Motion, sure-- ასე
გადაადგილება ბლოკი, დარწმუნებული ვარ.

411
00:20:44,950 --> 00:20:49,330
და რა არის, რომ ეს ნაბიჯი ბლოკი
შიგნით, სავარაუდოდ?

412
00:20:49,330 --> 00:20:52,850
ჰო, რაღაც სახის მარყუჟის, იქნებ
სამუდამოდ დაბლოკოს, შესაძლოა, განმეორებითი ბლოკი

413
00:20:52,850 --> 00:20:54,070
ვიმეორებ, სანამ ბლოკი.

414
00:20:54,070 --> 00:20:57,330
და რომ ის, რაც მიღების ჟურნალი და
ლილი ბალიშები და ყველაფერი ნაბიჯი

415
00:20:57,330 --> 00:20:57,990
უკან და მეოთხე.

416
00:20:57,990 --> 00:21:00,270
ეს უბრალოდ ხდება უსასრულოდ.

417
00:21:00,270 --> 00:21:03,180
>> რატომ არის ზოგიერთი მანქანა
მოძრავი სწრაფად, ვიდრე სხვები?

418
00:21:03,180 --> 00:21:06,607
რით განსხვავდება იმ პროგრამებს?

419
00:21:06,607 --> 00:21:09,690
ჰო, ალბათ ზოგიერთი მათგანი იღებენ
მეტი ნაბიჯები ერთდროულად და ზოგიერთი მათგანი

420
00:21:09,690 --> 00:21:10,690
ნაკლები ნაბიჯები ერთდროულად.

421
00:21:10,690 --> 00:21:14,670
და ვიზუალური ეფექტი
არის სწრაფი წინააღმდეგ ნელი.

422
00:21:14,670 --> 00:21:16,030
>> როგორ ფიქრობთ, რა მოხდა?

423
00:21:16,030 --> 00:21:19,700
როდესაც მე მივიღე ჩემი frog ყველა გზა
მოპირდაპირე მხარეს და მდინარე

424
00:21:19,700 --> 00:21:23,560
გადატანა ლილი pad, რაღაც
აღსანიშნავია მოხდა.

425
00:21:23,560 --> 00:21:26,540
რა მოხდა, როგორც კი მე რომ?

426
00:21:26,540 --> 00:21:27,210
იგი შეჩერდა.

427
00:21:27,210 --> 00:21:29,680
რომ frog შეწყვიტა და
მე მივიღე მეორე frog.

428
00:21:29,680 --> 00:21:33,155
ასე რომ, რა შენება უნდა იყოს
გამოიყენება იქ, რა ფუნქცია?

429
00:21:33,155 --> 00:21:36,020

430
00:21:36,020 --> 00:21:38,660
>> ჰო, ასე რომ გარკვეული სახის
"თუ" მდგომარეობაშია იქ, ძალიან.

431
00:21:38,660 --> 00:21:41,909
და თურმე out-- ჩვენ არ ვხედავთ ამას
მაგრამ არსებობს სხვა ბლოკები, რომ

432
00:21:41,909 --> 00:21:45,300
შეიძლება ითქვას, რომ, თუ თქვენ ეხება
კიდევ ერთი რამ ეკრანზე,

433
00:21:45,300 --> 00:21:47,720
თუ თქვენ ეხება lily pad ", მაშინ".

434
00:21:47,720 --> 00:21:50,810
და მაშინ, რომ მაშინ, როდესაც ჩვენ
მიიღოს მეორე frog გამოჩნდება.

435
00:21:50,810 --> 00:21:54,969
მიუხედავად იმისა, რომ ეს თამაში არის, რა თქმა უნდა
ძალიან დათარიღებული, მიუხედავად იმისა, რომ ერთი შეხედვით

436
00:21:54,969 --> 00:21:58,010
იქ იმდენად აპირებს on-- და ბლეიკი
არ whip ამ up ორ წუთში,

437
00:21:58,010 --> 00:22:00,390
ეს, ალბათ, წაიყვანეს რამდენიმე
საათის შექმნათ თამაში

438
00:22:00,390 --> 00:22:03,850
საფუძველზე მის ხსოვნას და ვიდეო
წარსულის ვერსიას იგი.

439
00:22:03,850 --> 00:22:07,940
მაგრამ ყველა ეს პატარა რამ
აპირებს ეკრანზე იზოლაცია

440
00:22:07,940 --> 00:22:11,550
მოვხარშოთ ქვემოთ ეს ძალიან მარტივია
constructs-- მოძრაობები და განცხადებები

441
00:22:11,550 --> 00:22:15,519
როგორც ჩვენ განვიხილეთ, მარყუჟების და
პირობები, და რომ ამის შესახებ.

442
00:22:15,519 --> 00:22:17,060
არსებობს რამდენიმე სხვა fancier თვისებები.

443
00:22:17,060 --> 00:22:19,130
ზოგიერთი მათგანი წმინდა
ესთეტიკური და აკუსტიკური,

444
00:22:19,130 --> 00:22:20,964
როგორც კინო უბრალოდ ითამაშა.

445
00:22:20,964 --> 00:22:23,380
მაგრამ იმ ნაწილს, თქვენ
აქვს ამ ენაზე, Scratch,

446
00:22:23,380 --> 00:22:25,350
ყველა ფუნდამენტური
სამშენებლო ბლოკები, რომ თქვენ

447
00:22:25,350 --> 00:22:29,280
აქვს C, Java, JavaScript,
PHP, Ruby, Python,

448
00:22:29,280 --> 00:22:32,960
და ნებისმიერი რაოდენობის სხვა ენებზე.

449
00:22:32,960 --> 00:22:36,720
რაიმე შეკითხვები Scratch?

450
00:22:36,720 --> 00:22:37,220
კარგი.

451
00:22:37,220 --> 00:22:40,303
ასე რომ, ჩვენ არ ჩაყვინთვის ღრმა Scratch,
მიუხედავად იმისა, რომ თქვენ მივესალმებით ამ კვირის ბოლოს,

452
00:22:40,303 --> 00:22:42,860
განსაკუთრებით თუ თქვენ გაქვთ ბავშვები ან
ძმისწულები და ძმისწულები და ასეთი,

453
00:22:42,860 --> 00:22:44,220
გააცნოს მათ Scratch.

454
00:22:44,220 --> 00:22:47,960
ეს, ფაქტობრივად, შესანიშნავად playful
გარემოს, როგორც მისი ავტორები აცხადებენ,

455
00:22:47,960 --> 00:22:49,120
ძალიან მაღალი ჭერით.

456
00:22:49,120 --> 00:22:51,670
მიუხედავად იმისა, რომ ჩვენ დავიწყეთ
ძალიან დაბალი დონის დეტალები,

457
00:22:51,670 --> 00:22:54,890
თქვენ შეიძლება მართლაც საკმაოდ მწირი
მას, და ეს არის ალბათ

458
00:22:54,890 --> 00:22:57,360
დემონსტრირება ზუსტად რომ.

459
00:22:57,360 --> 00:23:02,920
>> მაგრამ მოდით ახლა გადასვლას კიდევ რამდენიმე
დახვეწილი პრობლემები, თუ გნებავთ,

460
00:23:02,920 --> 00:23:05,870
ცნობილია, როგორც "ძიება" და
"დახარისხება", უფრო ზოგადად.

461
00:23:05,870 --> 00:23:09,500
ჩვენ გვქონდა ამ სატელეფონო წიგნი ადრე აქ არის
კიდევ ერთი მხოლოდ discussion--

462
00:23:09,500 --> 00:23:13,460
რომ ჩვენ შევძელით ძიება
უფრო ეფექტურად, რადგან

463
00:23:13,460 --> 00:23:15,270
მნიშვნელოვანი ვარაუდი.

464
00:23:15,270 --> 00:23:17,655
და უბრალოდ უნდა იყოს ნათელი, თუ რა
მოსაზრება იყო, მე მიღების

465
00:23:17,655 --> 00:23:19,280
როცა ძებნას ამ სატელეფონო წიგნი?

466
00:23:19,280 --> 00:23:23,342

467
00:23:23,342 --> 00:23:25,300
რომ მაიკ სმიტი იყო
სატელეფონო წიგნი, მიუხედავად იმისა, რომ

468
00:23:25,300 --> 00:23:27,410
შეძლებს გაუმკლავდეს
სცენარის მის გარეშე

469
00:23:27,410 --> 00:23:30,720
არსებობს თუ უბრალოდ შეწყვიტა ნაადრევად.

470
00:23:30,720 --> 00:23:31,806
წიგნი ანბანური.

471
00:23:31,806 --> 00:23:33,930
და ეს ძალიან კეთილშობილური
ვარაუდი, იმიტომ, რომ

472
00:23:33,930 --> 00:23:36,580
ნიშნავს someone-- მე სახის
ჭრის კუთხეში,

473
00:23:36,580 --> 00:23:40,580
როგორიც მე ვარ, უფრო სწრაფად, რადგან ვინმე
სხვა ძალიან ბევრი შრომა ჩემთვის.

474
00:23:40,580 --> 00:23:43,120
>> მაგრამ რა, თუ ტელეფონი
წიგნი იყო დაუხარისხებელი?

475
00:23:43,120 --> 00:23:47,050
იქნებ Verizon მიიღო ზარმაცი, უბრალოდ ესროლა
ყველას სახელები და ნომრები არ

476
00:23:47,050 --> 00:23:50,120
შესაძლოა, იმისათვის, რომელშიც ისინი
მოაწერა ხელი სატელეფონო მომსახურების.

477
00:23:50,120 --> 00:23:54,570
და რამდენი დრო სჭირდება me
რათა იპოვოს ადამიანი, როგორიც მაიკ სმიტი?

478
00:23:54,570 --> 00:23:58,160
1000 გვერდი ტელეფონი book-- რამდენი
გვერდებზე მაქვს გაეცნონ?

479
00:23:58,160 --> 00:23:58,905
>> ყველა მათგანი.

480
00:23:58,905 --> 00:24:00,030
თქვენ ერთგვარი out of luck.

481
00:24:00,030 --> 00:24:03,420
თქვენ სიტყვასიტყვით უნდა შევხედოთ ყველა
გვერდი, თუ ტელეფონი წიგნი მხოლოდ

482
00:24:03,420 --> 00:24:04,450
შემთხვევით გადანაწილებული.

483
00:24:04,450 --> 00:24:06,910
თქვენ შეიძლება გაუმართლა და იპოვოს Mike
პირველივე გვერდზე, იმიტომ, რომ ის

484
00:24:06,910 --> 00:24:08,826
იყო პირველი მომხმარებელს
შეკვეთა სატელეფონო მომსახურების.

485
00:24:08,826 --> 00:24:10,760
მაგრამ ის შეიძლება ყოფილიყო, ბოლო, ძალიან.

486
00:24:10,760 --> 00:24:12,500
>> ასე რომ, შემთხვევითი მიზნით არ არის კარგი.

487
00:24:12,500 --> 00:24:16,750
ასე რომ, ვფიქრობ, ჩვენ უნდა დასალაგებლად
სატელეფონო წიგნი და ზოგადად სახის მონაცემები

488
00:24:16,750 --> 00:24:18,520
ჩვენ უკვე ეძლევა.

489
00:24:18,520 --> 00:24:19,440
როგორ შეგვიძლია ამის გაკეთება?

490
00:24:19,440 --> 00:24:21,360
>> ასევე, ნება მომეცით უბრალოდ ცდილობენ
უბრალო მაგალითი აქ.

491
00:24:21,360 --> 00:24:24,290
ნება მომეცით წავიდეთ წინ და toss
რამდენიმე ნომრები ფორუმში.

492
00:24:24,290 --> 00:24:35,480
დავუშვათ, ნომრები ჩვენ ვართ,
ვთქვათ, ოთხი, ორი, ერთი და სამი.

493
00:24:35,480 --> 00:24:38,390
და, ბენ, დასალაგებლად ამ ნომრებზე ჩვენთვის.

494
00:24:38,390 --> 00:24:39,017
>> კარგი, კარგია.

495
00:24:39,017 --> 00:24:39,850
როგორ ფიქრობთ, რომ?

496
00:24:39,850 --> 00:24:42,731

497
00:24:42,731 --> 00:24:43,230
კარგი.

498
00:24:43,230 --> 00:24:44,710
ასე იწყება პატარა
მნიშვნელობა და უმაღლესი,

499
00:24:44,710 --> 00:24:46,084
და ეს მართლაც კარგი ინტუიცია.

500
00:24:46,084 --> 00:24:48,080
და გააცნობიეროს, რომ ჩვენ
ადამიანები რეალურად საკმაოდ

501
00:24:48,080 --> 00:24:49,913
კარგი პრობლემების გადაჭრის
როგორც ეს, მინიმუმ

502
00:24:49,913 --> 00:24:51,810
როდესაც მონაცემები შედარებით მცირე.

503
00:24:51,810 --> 00:24:54,860
როგორც კი დაიწყება ასობით
ციფრები, ათასობით ნომრები,

504
00:24:54,860 --> 00:24:58,440
მილიონობით ნომრები, ბენ ალბათ
ამის გაკეთება არ შეეძლო საკმაოდ, რომ სწრაფი,

505
00:24:58,440 --> 00:25:00,620
თუ გავითვალისწინებთ, რომ არ იყო
ხარვეზები ნომრები.

506
00:25:00,620 --> 00:25:03,450
საკმაოდ ადვილი ითვლიან მილიონი
წინააღმდეგ შემთხვევაში, უბრალოდ დროს მოითხოვს.

507
00:25:03,450 --> 00:25:07,150
>> ასე რომ, ალგორითმი, რომ ეს ხმები
ისევე როგორც ბენ გამოიყენება მხოლოდ ახლა

508
00:25:07,150 --> 00:25:08,930
იყო ძიება მცირე რაოდენობის.

509
00:25:08,930 --> 00:25:12,900
მიუხედავად იმისა, რომ ჩვენ, ადამიანები, შეუძლია მიიღოს
ბევრი ინფორმაცია ვიზუალურად,

510
00:25:12,900 --> 00:25:14,830
კომპიუტერი არის რეალურად
ცოტა უფრო შეზღუდულია.

511
00:25:14,830 --> 00:25:17,560
კომპიუტერული მხოლოდ
შეხედეთ ერთი byte დროს

512
00:25:17,560 --> 00:25:20,770
ან იქნებ ოთხი ბაიტი time--
ამ დღეებში, შესაძლოა, 8 ბაიტი time--

513
00:25:20,770 --> 00:25:24,450
მაგრამ ძალიან მცირე რაოდენობით
ბაიტი მოცემულ დროს.

514
00:25:24,450 --> 00:25:28,480
>> ასე რომ, იმის გათვალისწინებით, რომ ჩვენ ნამდვილად გვაქვს
ოთხი ღირებულებები აქ

515
00:25:28,480 --> 00:25:32,440
და შეგიძლიათ წარმოიდგინოთ, ბენ, როგორც
blinders შესახებ, თუ ის იყო კომპიუტერი, როგორიცაა

516
00:25:32,440 --> 00:25:36,450
რომ იგი ვერ ხედავს რაიმე სხვა
ვიდრე ერთი ნომრის time--

517
00:25:36,450 --> 00:25:39,720
ასე რომ, ჩვენ ზოგადად ვივარაუდოთ, ისევე როგორც
ინგლისური, ჩვენ წაიკითხა მარჯვნიდან მარცხნივ.

518
00:25:39,720 --> 00:25:42,870
ასე რომ, პირველი ნომერი ბენ ალბათ ჩანდა
at ოთხი და შემდეგ ძალიან სწრაფად

519
00:25:42,870 --> 00:25:44,770
მიხვდა, რომ საკმაოდ დიდი
რიცხვი მიადევნე თვალი შენარჩუნება ეძებს.

520
00:25:44,770 --> 00:25:45,357
>> არსებობს ორი.

521
00:25:45,357 --> 00:25:45,940
ერთი წუთი მაცადე.

522
00:25:45,940 --> 00:25:47,070
ორი მცირეა ოთხ.

523
00:25:47,070 --> 00:25:47,986
მე ვაპირებ მახსოვს.

524
00:25:47,986 --> 00:25:49,070
ორი არის პატარა.

525
00:25:49,070 --> 00:25:50,417
ახლა one--, რომ უფრო უკეთესი.

526
00:25:50,417 --> 00:25:51,250
ეს არის ის, თუნდაც მცირე.

527
00:25:51,250 --> 00:25:54,000
მე ვაპირებ დაივიწყოს ორი
და უბრალოდ მახსოვს ერთი ახლა.

528
00:25:54,000 --> 00:25:56,550
>> და შეიძლება მან შეწყვიტოს ეძებს?

529
00:25:56,550 --> 00:25:58,360
ისე, რომ იგი შეიძლება დაფუძნებული
ამ ინფორმაციას,

530
00:25:58,360 --> 00:26:00,477
მაგრამ მან უმჯობესია ძიება
დანარჩენი სიაში.

531
00:26:00,477 --> 00:26:02,060
რადგან რა, თუ ნულოვანი იყო სიაში?

532
00:26:02,060 --> 00:26:03,643
რა მოხდება, თუ უარყოფითი იყო სიაში?

533
00:26:03,643 --> 00:26:07,720
მან მხოლოდ იცის, რომ მისი პასუხი
სწორია თუ ის ამომწურავად

534
00:26:07,720 --> 00:26:08,729
შემოწმდება მთელი სია.

535
00:26:08,729 --> 00:26:10,020
ამიტომ, ჩვენ შევხედოთ დანარჩენი ამ.

536
00:26:10,020 --> 00:26:11,394
Three-- რომ იყო ნარჩენები დრო.

537
00:26:11,394 --> 00:26:13,540
მიიღო უიღბლო იყო, მაგრამ მე
მაინც სწორი ამის გაკეთება.

538
00:26:13,540 --> 00:26:17,857
ასე რომ, ახლა იგი, სავარაუდოდ,
შერჩეული მცირე რაოდენობის

539
00:26:17,857 --> 00:26:20,440
და მხოლოდ დააყენა ის დასაწყისში
სია, როგორც მე გავაკეთებ აქ.

540
00:26:20,440 --> 00:26:23,480
ახლა რას აკეთებთ შემდეგ, მიუხედავად იმისა, რომ
თქვენ არ ვიფიქროთ, რომ თითქმის

541
00:26:23,480 --> 00:26:25,962
ამ მხრივ?

542
00:26:25,962 --> 00:26:27,670
გაიმეორეთ პროცესი,
ასე რომ, გარკვეული ციკლი.

543
00:26:27,670 --> 00:26:28,920
იქ ნაცნობი იდეა.

544
00:26:28,920 --> 00:26:30,860
ასე რომ, აქ არის ოთხი.

545
00:26:30,860 --> 00:26:32,110
სწორედ გაკეთებული პატარა.

546
00:26:32,110 --> 00:26:33,220
სწორედ კანდიდატი.

547
00:26:33,220 --> 00:26:33,900
უკვე აღარ.

548
00:26:33,900 --> 00:26:34,770
ახლა მე ვნახე ორი.

549
00:26:34,770 --> 00:26:36,630
სწორედ შემდეგი პატარა ელემენტს.

550
00:26:36,630 --> 00:26:40,800
Three-- ეს არ არის პატარა, ისე,
ახლა ბენ შეიძლება pluck გარეთ ორი.

551
00:26:40,800 --> 00:26:44,510
>> და ახლა ჩვენ ვიმეორებ პროცესში და
რა თქმა უნდა, სამი იღებს გაყვანილია მომავალი.

552
00:26:44,510 --> 00:26:45,420
ვიმეორებ პროცესში.

553
00:26:45,420 --> 00:26:46,990
ოთხი იღებს გაყვანილია.

554
00:26:46,990 --> 00:26:50,140
და ახლა ჩვენ out ნომრები,
ასე რომ სია უნდა იყოს დახარისხებული.

555
00:26:50,140 --> 00:26:51,960
>> მართლაც, ეს არის ფორმალური ალგორითმი.

556
00:26:51,960 --> 00:26:56,610
კომპიუტერული მეცნიერი იქნებოდა
მოვუწოდებთ ამ "შერჩევის დალაგების"

557
00:26:56,610 --> 00:27:00,880
იდეა მყოფი დასალაგებლად
სიაში iteratively-- ერთხელ

558
00:27:00,880 --> 00:27:03,807
და ისევ და ისევ შერჩევით
ყველაზე პატარა ნომერი.

559
00:27:03,807 --> 00:27:06,140
და რა ლამაზი შესახებ არის ის,
ეს მხოლოდ ასე darn ინტუიციური.

560
00:27:06,140 --> 00:27:07,470
ეს ასე მარტივი.

561
00:27:07,470 --> 00:27:11,100
და შეგიძლიათ გაიმეოროს იგივე
ოპერაცია ისევ და ისევ.

562
00:27:11,100 --> 00:27:12,150
ეს მარტივია.

563
00:27:12,150 --> 00:27:17,170
>> ამ შემთხვევაში ეს იყო სწრაფი, მაგრამ
რამდენი ხანი რეალურად?

564
00:27:17,170 --> 00:27:19,880
მოდით ეს, როგორც ჩანს, და
ვგრძნობ ცოტა მეტი tedious.

565
00:27:19,880 --> 00:27:24,150
ასე რომ, ერთი, ორი, სამი, ოთხი, ხუთი, ექვსი,
შვიდი, რვა, ცხრა, 10, 11, 12, 13, 14,

566
00:27:24,150 --> 00:27:26,160
15 16-- თვითნებური რაოდენობა.

567
00:27:26,160 --> 00:27:28,780
მე უბრალოდ მინდოდა უფრო მეტი ამ
დრო, ვიდრე მხოლოდ ოთხი.

568
00:27:28,780 --> 00:27:30,780
ასე რომ, თუ მე მაქვს მთელი
რამოდენიმე ნომრები, ახლა ეს

569
00:27:30,780 --> 00:27:32,420
კი არ აქვს მნიშვნელობა
რაც მათ are-- მოდით

570
00:27:32,420 --> 00:27:34,380
დაფიქრდით რას
ალგორითმი მართლაც ჰგავს.

571
00:27:34,380 --> 00:27:35,857
>> დავუშვათ, რომ არსებობს ნომერს.

572
00:27:35,857 --> 00:27:38,190
კიდევ ერთხელ, არ აქვს მნიშვნელობა, რა
ისინი, მაგრამ ისინი შემთხვევითი.

573
00:27:38,190 --> 00:27:39,679
მე გამოყენებით ბენ ალგორითმი.

574
00:27:39,679 --> 00:27:41,220
მე უნდა აირჩიოთ ყველაზე პატარა ნომერი.

575
00:27:41,220 --> 00:27:41,761
რას ვაკეთებ?

576
00:27:41,761 --> 00:27:44,240
და მე ვაპირებ, რომ ფიზიკურად
იგი ამ დროს იმოქმედოს ის.

577
00:27:44,240 --> 00:27:46,099
ეძებს, ეძებს,
ეძებს, ეძებს, ეძებს.

578
00:27:46,099 --> 00:27:48,140
მხოლოდ დრო მივიღებ
ბოლოს სია შეიძლება

579
00:27:48,140 --> 00:27:51,230
ვხვდები პატარა
ნომერი ორი ამ დროს.

580
00:27:51,230 --> 00:27:52,720
ერთი არ არის სიაში.

581
00:27:52,720 --> 00:27:54,400
ასე რომ, მე ჩაახშო ორი.

582
00:27:54,400 --> 00:27:55,590
>> რა გავაკეთო შემდეგი?

583
00:27:55,590 --> 00:27:58,600
ეძებს, ეძებს, ეძებს, ეძებს.

584
00:27:58,600 --> 00:28:02,250
ახლა მივხვდი, რომ ნომერი შვიდი, რადგან
არსებობს ხარვეზები ამ ნომრებზე

585
00:28:02,250 --> 00:28:03,300
მაგრამ მხოლოდ უკანონო.

586
00:28:03,300 --> 00:28:03,800
კარგი.

587
00:28:03,800 --> 00:28:06,030
ახლა შემიძლია ჩასახშობად შვიდი.

588
00:28:06,030 --> 00:28:08,860
ვეძებთ ეძებს, ეძებს.

589
00:28:08,860 --> 00:28:11,030
>> ახლა მე ვთქვათ,
რა თქმა უნდა, რომ ბენ არ

590
00:28:11,030 --> 00:28:14,780
აქვს დამატებითი RAM, დამატებითი
მეხსიერება, იმიტომ, რომ, რა თქმა უნდა,

591
00:28:14,780 --> 00:28:16,080
ვეძებ ამავე ნომერი.

592
00:28:16,080 --> 00:28:18,246
რა თქმა უნდა, მე ვერ გაიხსენა
ყველა იმ ნომრები,

593
00:28:18,246 --> 00:28:19,930
და ეს აბსოლუტურად მართალია.

594
00:28:19,930 --> 00:28:22,610
მაგრამ თუ ბენ ახსოვს ყველა
ნომრები ის ჩანს,

595
00:28:22,610 --> 00:28:24,430
მას არ ნამდვილად გააკეთა
ძირითადი პროგრესი

596
00:28:24,430 --> 00:28:26,170
იმიტომ, რომ მას უკვე აქვს
უნარი ძებნის

597
00:28:26,170 --> 00:28:27,540
მეშვეობით ნომრები ფორუმში.

598
00:28:27,540 --> 00:28:29,373
გავიხსენოთ ყველა
ნომრები არ დაეხმარება,

599
00:28:29,373 --> 00:28:32,490
იმიტომ, რომ მას ჯერ კიდევ შეუძლია, როგორც კომპიუტერი
მხოლოდ შევხედოთ, ჩვენ ვთქვით, ერთი ნომერი

600
00:28:32,490 --> 00:28:33,080
დროულად.

601
00:28:33,080 --> 00:28:35,760
ასე რომ არ არსებობს ერთგვარი cheat
იქ რომ შეგიძლიათ ბერკეტები.

602
00:28:35,760 --> 00:28:39,170
>> ასე რომ, სინამდვილეში, როგორც მე
მოიძიებ სიაში,

603
00:28:39,170 --> 00:28:44,200
მე ფაქტიურად მხოლოდ შენარჩუნებას აპირებს
უკან და მეოთხე მეშვეობით, plucking out

604
00:28:44,200 --> 00:28:45,710
შემდეგი ყველაზე პატარა ნომერი.

605
00:28:45,710 --> 00:28:48,810
და თქვენ შეგიძლიათ სახის infer
ჩემი სულელური მოძრაობები,

606
00:28:48,810 --> 00:28:50,860
ეს მხოლოდ იღებს ძალიან
tedious, ძალიან სწრაფად,

607
00:28:50,860 --> 00:28:54,850
და მე, როგორც ჩანს ბრუნდება და
მეოთხე, და უკან საკმაოდ მწირი.

608
00:28:54,850 --> 00:29:03,220
ახლა უნდა იყოს სამართლიანი, მე არ უნდა წავიდეს
საკმაოდ, ასევე, ვნახოთ უნდა იყოს სამართლიანი,

609
00:29:03,220 --> 00:29:06,310
მე არ უნდა ფეხით საკმაოდ
როგორც ბევრი ნაბიჯები ყოველ ჯერზე.

610
00:29:06,310 --> 00:29:09,200
იმის გამო, რომ, რა თქმა უნდა, როგორც მე
აირჩიეთ ნომრები სიიდან,

611
00:29:09,200 --> 00:29:11,860
დარჩენილი სიაში დღითიდღე უფრო მოკლეა.

612
00:29:11,860 --> 00:29:14,240
>> ასე რომ, მოდით ვიფიქროთ
რამდენი ნაბიჯები მე რეალურად

613
00:29:14,240 --> 00:29:16,010
traipsing მეშვეობით ყოველ ჯერზე.

614
00:29:16,010 --> 00:29:18,950
პირველივე სიტუაცია
ჩვენ გვქონდა 16 ნომრები,

615
00:29:18,950 --> 00:29:22,210
და ასე maximally-- მოდით უბრალოდ
ამის გაკეთება discussion--

616
00:29:22,210 --> 00:29:25,640
მე უნდა გაეცნონ 16
ნომრები მოძიების პატარა.

617
00:29:25,640 --> 00:29:28,420
მაგრამ ერთხელ ამოაგდო
მცირე რაოდენობის, როგორ

618
00:29:28,420 --> 00:29:30,590
ხანგრძლივი იყო დარჩენილი სიაში, რა თქმა უნდა?

619
00:29:30,590 --> 00:29:31,420
მხოლოდ 15.

620
00:29:31,420 --> 00:29:34,670
ასე რომ, რამდენი ნომრები გააკეთა Ben ან მე არ მაქვს
გაეცნონ მეორედ?

621
00:29:34,670 --> 00:29:36,832
15, უბრალოდ წასვლა და იპოვოს პატარა.

622
00:29:36,832 --> 00:29:39,540
მაგრამ ახლა, რა თქმა უნდა, სიაში არის,
ძალიან, პატარა, ვიდრე ეს იყო ადრე.

623
00:29:39,540 --> 00:29:42,540
ასე რომ, რამდენი ნაბიჯები არ მინდა
უნდა მიიღოს მომავალი დრო?

624
00:29:42,540 --> 00:29:49,970
14 და შემდეგ 13 და შემდეგ 12, პლიუს dot,
dot, dot, სანამ მე დარჩა მხოლოდ ერთი.

625
00:29:49,970 --> 00:29:53,146
ასე რომ, ახლა კომპიუტერის მეცნიერი იქნებოდა
ვთხოვთ, ისე, რა, რომ ყველა ერთნაირია?

626
00:29:53,146 --> 00:29:55,770
ეს ფაქტიურად უტოლდება კონკრეტული
ნომერი, რომელიც ჩვენ ნამდვილად

627
00:29:55,770 --> 00:30:00,490
ამის arithmetically, მაგრამ ჩვენ გვინდა, რომ გაიგო
ეფექტურობის შესახებ ალგორითმები

628
00:30:00,490 --> 00:30:04,940
ცოტა მეტი formulaically,
დამოუკიდებელი რამდენი ხანი სია.

629
00:30:04,940 --> 00:30:06,240
>> და ასე რომ თქვენ იცით, რა?

630
00:30:06,240 --> 00:30:09,860
ეს არის 16, მაგრამ, როგორც ვთქვი,
მოდით უბრალოდ მოვუწოდებთ ზომის პრობლემა

631
00:30:09,860 --> 00:30:10,970
n, სადაც n არის გარკვეული რაოდენობა.

632
00:30:10,970 --> 00:30:13,220
შესაძლოა, ეს 16, იქნებ ეს
სამი, შესაძლოა, ეს მილიონი.

633
00:30:13,220 --> 00:30:13,761
მე არ ვიცი.

634
00:30:13,761 --> 00:30:14,390
მე არ მაინტერესებს.

635
00:30:14,390 --> 00:30:16,520
რაც მე მინდა არის
ფორმულა, რომელიც შემიძლია

636
00:30:16,520 --> 00:30:19,420
გამოიყენოთ შედარება ეს ალგორითმი
სხვა ალგორითმები

637
00:30:19,420 --> 00:30:22,350
რომ ვინმე შეიძლება ითქვას,
უკეთესი ან უარესი.

638
00:30:22,350 --> 00:30:25,430
>> ასე რომ, თურმე, და მე მხოლოდ
ვიცი, რომ ეს კლასის სკოლა,

639
00:30:25,430 --> 00:30:34,790
რომ ამ რეალურად მუშაობს, რათა იგივე
რამ, როგორც n მეტი N პლუს ერთი ორი.

640
00:30:34,790 --> 00:30:40,020
და ეს მოხდება, თანაბარი პირობების
რა თქმა უნდა, n კვადრატში + N ორი.

641
00:30:40,020 --> 00:30:43,250
ასე რომ, თუ მინდოდა ფორმულა
რამდენი ნაბიჯები

642
00:30:43,250 --> 00:30:46,330
ჩართული იყო ეძებს ყველა
იმ ნომრები ისევ და ისევ

643
00:30:46,330 --> 00:30:52,681
და ისევ და ისევ, მე ვიტყოდი,
ის n კვადრატში + N ორი.

644
00:30:52,681 --> 00:30:53,430
მაგრამ იცით, რა?

645
00:30:53,430 --> 00:30:54,500
ეს უბრალოდ გამოიყურება ბინძურ.

646
00:30:54,500 --> 00:30:56,470
მე ნამდვილად მინდა
ზოგადი გაგებით რამ.

647
00:30:56,470 --> 00:30:58,810
და თქვენ შეიძლება გავიხსენოთ
საშუალო სკოლა, რომ

648
00:30:58,810 --> 00:31:00,660
არის ცნება უმაღლესი მიზნით ვადით.

649
00:31:00,660 --> 00:31:05,300
რომელიც ამ თვალსაზრისით, n
კვადრატი, ო, ან ნახევარი,

650
00:31:05,300 --> 00:31:07,550
აქვს ყველაზე გავლენა დროთა განმავლობაში?

651
00:31:07,550 --> 00:31:11,920
უფრო დიდი ო იღებს, რომელიც
ამ საკითხებზე ყველაზე მეტად?

652
00:31:11,920 --> 00:31:15,560
>> სხვა სიტყვებით, თუ მე შეაერთედ
მილიონი, n კვადრატში

653
00:31:15,560 --> 00:31:17,900
იქნება სავარაუდოდ
გამორჩეული ფაქტორი,

654
00:31:17,900 --> 00:31:21,670
იმიტომ, რომ მილიონი ჯერ
თავად არის ბევრი დიდი

655
00:31:21,670 --> 00:31:23,682
ვიდრე დამატებული მლნ.

656
00:31:23,682 --> 00:31:24,390
ასე, რომ თქვენ იცით, რა?

657
00:31:24,390 --> 00:31:27,305
ეს არის ისეთი darn დიდი
ნომერი თუ მოედანზე ნომერი.

658
00:31:27,305 --> 00:31:28,430
ეს ნამდვილად არ აქვს.

659
00:31:28,430 --> 00:31:30,596
ჩვენ უბრალოდ აპირებს ჯვარი
და დაივიწყოს იგი.

660
00:31:30,596 --> 00:31:34,250
ასე რომ, კომპიუტერის მეცნიერი ვიტყოდი
რომ ეფექტურობის ეს ალგორითმი

661
00:31:34,250 --> 00:31:37,850
არის ბრძანებით N კვადრატი
ვგულისხმობ ნამდვილად დაახლოებას.

662
00:31:37,850 --> 00:31:40,810
ეს არის ერთგვარი უხეშად n კვადრატში.

663
00:31:40,810 --> 00:31:44,130
დროთა განმავლობაში, მით უფრო დიდია
და დიდი ო იღებს, ეს

664
00:31:44,130 --> 00:31:47,610
არის კარგი შეფასებით, რა
ეფექტურობის ან ნაკლებობა ეფექტურობის

665
00:31:47,610 --> 00:31:49,400
ეს ალგორითმი რეალურად არის.

666
00:31:49,400 --> 00:31:52,040
და მე გამომდინარეობს, რომ, რა თქმა უნდა,
რეალურად აკეთებს მათემატიკის.

667
00:31:52,040 --> 00:31:54,040
მაგრამ ახლა მე უბრალოდ ვნახე
ხელები, რადგან მე მხოლოდ

668
00:31:54,040 --> 00:31:55,790
მინდა, ზოგადი გაგებით, ეს ალგორითმი.

669
00:31:55,790 --> 00:31:58,850
>> ასე რომ, იმავე ლოგიკით, იმავდროულად,
განვიხილოთ კიდევ ერთი ალგორითმი

670
00:31:58,850 --> 00:32:01,162
ჩვენ უკვე შევხედეთ ხაზოვანი ძებნა.

671
00:32:01,162 --> 00:32:02,870
როცა მე ეძებს
ტელეფონი book--

672
00:32:02,870 --> 00:32:05,980
არ დახარისხება ის, ეძებს
სატელეფონო book--

673
00:32:05,980 --> 00:32:09,197
ჩვენ ამბობდა, რომ ეს იყო
1000 ნაბიჯი, ან 500 ნაბიჯები.

674
00:32:09,197 --> 00:32:10,280
მაგრამ მოდით განზოგადება, რომ.

675
00:32:10,280 --> 00:32:12,860
თუ არსებობს n გვერდები
სატელეფონო წიგნი, რა არის

676
00:32:12,860 --> 00:32:17,250
ქრონომეტრაჟი ან
ეფექტურობის ხაზოვანი ძებნა?

677
00:32:17,250 --> 00:32:19,750
ეს ბრძანებით
რამდენი ნაბიჯები, რათა იპოვოს

678
00:32:19,750 --> 00:32:24,210
მაიკ სმიტი გამოყენებით ხაზოვანი ძებნა,
პირველი ალგორითმი, ან თუნდაც მეორე?

679
00:32:24,210 --> 00:32:27,240

680
00:32:27,240 --> 00:32:31,710
>> უარეს შემთხვევაში, მაიკ
ბოლოს წიგნი.

681
00:32:31,710 --> 00:32:35,590
ასე რომ, თუ სატელეფონო წიგნი 1000 გვერდებზე,
ჩვენ ვთქვით, რომ ბოლო დროს, უარეს შემთხვევაში,

682
00:32:35,590 --> 00:32:38,380
შესაძლოა, უხეშად, თუ როგორ
ბევრი გვერდებზე, რათა Mike?

683
00:32:38,380 --> 00:32:38,990
1000.

684
00:32:38,990 --> 00:32:39,830
ეს არის ზედა ზღვარი.

685
00:32:39,830 --> 00:32:41,790
ეს არის ყველაზე უარესი სიტუაცია.

686
00:32:41,790 --> 00:32:44,410
მაგრამ კიდევ ერთხელ, ჩვენ მოძრავი დაშორებით
საწყისი ნომრები 1000 ახლა.

687
00:32:44,410 --> 00:32:45,730
ეს არის უბრალოდ n.

688
00:32:45,730 --> 00:32:47,470
>> ასე რომ, რა არის ლოგიკური დასკვნა?

689
00:32:47,470 --> 00:32:50,210
მოძიება მაიკ ტელეფონი
წიგნი, რომელიც n გვერდები

690
00:32:50,210 --> 00:32:55,280
შესაძლოა, ძალიან უარეს შემთხვევაში,
რამდენი ნაბიჯები ბრძანებით N?

691
00:32:55,280 --> 00:32:58,110
და მართლაც კომპიუტერი
მეცნიერი ვიტყოდი

692
00:32:58,110 --> 00:33:02,340
რომ გაშვებული დრო, ან
შესრულების ან ეფექტურობის

693
00:33:02,340 --> 00:33:07,470
და არაეფექტურობა, ალგორითმი, როგორიცაა
ხაზოვანი ძებნა არის ბრძანებით ო.

694
00:33:07,470 --> 00:33:10,010
და ჩვენ შეგვიძლია იგივე
ლოგიკა გადაკვეთის რაღაც გარეთ

695
00:33:10,010 --> 00:33:13,170
როგორც მე უბრალოდ მეორე
ალგორითმი, რომ ჩვენ გვქონდა სატელეფონო წიგნი,

696
00:33:13,170 --> 00:33:16,040
სადაც წავედით ორი გვერდებზე დროს.

697
00:33:16,040 --> 00:33:20,120
>> ასე რომ, 1000 გვერდი სატელეფონო წიგნი შეიძლება
წაგვიყვანს 500 გვერდი მონაცვლეობით, პლუს ერთი

698
00:33:20,120 --> 00:33:21,910
თუ ჩვენ ორმაგად უკან ცოტა.

699
00:33:21,910 --> 00:33:26,590
ასე რომ, თუ სატელეფონო წიგნი n გვერდები, მაგრამ
ჩვენ ვაკეთებთ ორ გვერდს დროს,

700
00:33:26,590 --> 00:33:28,900
რომ უხეშად რა?

701
00:33:28,900 --> 00:33:33,190
N ორი, ასე რომ, როგორც N ორი.

702
00:33:33,190 --> 00:33:38,490
მაგრამ მე მივიღე მოპოვებას
მომენტში წინ, რომ n მეტი two--

703
00:33:38,490 --> 00:33:41,060
ეს ერთგვარი იგივე, რაც უბრალოდ n.

704
00:33:41,060 --> 00:33:44,050
ეს არის მხოლოდ მუდმივი ფაქტორი,
კომპიუტერული მეცნიერები ვიტყოდი.

705
00:33:44,050 --> 00:33:45,970
მოდით მხოლოდ ფოკუსირება
ცვლადები, ნამდვილად

706
00:33:45,970 --> 00:33:47,780
ყველაზე დიდი ცვლადები წელს განტოლება.

707
00:33:47,780 --> 00:33:52,530
>> ასე რომ წრფივი ძიება, თუ არა გაკეთდეს ერთი
გვერდზე დროს ან ორი გვერდებზე დროს,

708
00:33:52,530 --> 00:33:54,810
სახის ფუნდამენტურად იგივე.

709
00:33:54,810 --> 00:33:56,880
ეს ჯერ კიდევ ბრძანებით n.

710
00:33:56,880 --> 00:34:01,930
მაგრამ მე აცხადებდა ჩემი სურათი ადრე
რომ მესამე ალგორითმი არ იყო

711
00:34:01,930 --> 00:34:02,480
წრფივი.

712
00:34:02,480 --> 00:34:03,605
ეს არ იყო სწორი ხაზი.

713
00:34:03,605 --> 00:34:08,659
ეს იყო, რომ curved ხაზი, და
მათემატიკური ფორმულა იყო რა?

714
00:34:08,659 --> 00:34:11,812
შესვლა N-- ასე ჟურნალი ბაზა ორ ო.

715
00:34:11,812 --> 00:34:14,520
და ჩვენ არ უნდა წასვლას ძალიან
ბევრი დეტალი on logarithms დღეს,

716
00:34:14,520 --> 00:34:17,394
მაგრამ ყველაზე კომპიუტერის მეცნიერები რომ არ
კი გეტყვით, თუ რა ბაზა.

717
00:34:17,394 --> 00:34:20,639
იმის გამო, რომ ეს ყველაფერი მხოლოდ
მუდმივი ფაქტორი, ასე ვთქვათ,

718
00:34:20,639 --> 00:34:22,659
მხოლოდ უმნიშვნელო რიცხვითი განსხვავებები.

719
00:34:22,659 --> 00:34:31,179
ასე რომ, ეს იქნება ძალიან გავრცელებული
გზა განსაკუთრებით ფორმალური კომპიუტერული

720
00:34:31,179 --> 00:34:33,949
მეცნიერთა საბჭოს ან
პროგრამისტები თეთრ დაფაზე

721
00:34:33,949 --> 00:34:36,889
რეალურად კამათი, რომელიც
ალგორითმი ისინი გამოიყენოთ

722
00:34:36,889 --> 00:34:39,500
ან რა ეფექტურობის
მათი ალგორითმი.

723
00:34:39,500 --> 00:34:42,960
>> და ეს არ არის აუცილებლად რაღაც
თქვენ განიხილოს ნებისმიერი დიდი დეტალი,

724
00:34:42,960 --> 00:34:47,889
მაგრამ კარგი პროგრამისტი არის ვინმე
რომელსაც აქვს მყარი, ფორმალური ფონზე.

725
00:34:47,889 --> 00:34:50,120
ის ლაპარაკი
თქვენ ამ სახის გზა

726
00:34:50,120 --> 00:34:53,350
და რეალურად
ხარისხიანი არგუმენტები

727
00:34:53,350 --> 00:34:56,870
თუ რატომ ერთი ალგორითმი ან
ერთი ნაჭერი პროგრამული უზრუნველყოფა

728
00:34:56,870 --> 00:35:00,165
უმაღლესი რამდენიმე გზა სხვა.

729
00:35:00,165 --> 00:35:02,540
იმის გამო, რომ თქვენ ნამდვილად
მხოლოდ აწარმოებს ერთი პიროვნების პროგრამა

730
00:35:02,540 --> 00:35:04,980
და იმედი რაოდენობა წამში
სჭირდება დასალაგებლად ზოგიერთი ნომრები,

731
00:35:04,980 --> 00:35:06,710
და თქვენ შეგიძლიათ აწარმოებს რამდენიმე
სხვა პირის მიერ პროგრამის

732
00:35:06,710 --> 00:35:08,418
და იმედი რაოდენობა
წამში სჭირდება.

733
00:35:08,418 --> 00:35:12,840
მაგრამ ეს არის უფრო ზოგადი, ისე, რომ
თქვენ შეგიძლიათ გამოიყენოთ ანალიზი ალგორითმები,

734
00:35:12,840 --> 00:35:15,520
თუ თქვენ, უბრალოდ
ქაღალდის ან უბრალოდ სიტყვიერი შეურაცხყოფა მიაყენეს.

735
00:35:15,520 --> 00:35:18,430
გარეშე კი გაშვებული ის გარეშე
კი ცდილობს ნიმუში საშუალებებით,

736
00:35:18,430 --> 00:35:20,180
შეგიძლიათ უბრალოდ მიზეზი მეშვეობით.

737
00:35:20,180 --> 00:35:24,670
ასე რომ აყვანის დეველოპერი ან თუ
რომელსაც მას ერთგვარი ამტკიცებენ, რომ თქვენ

738
00:35:24,670 --> 00:35:28,460
რატომ მათი ალგორითმი, მათი საიდუმლო
სოუსი ეძებს მილიარდობით

739
00:35:28,460 --> 00:35:30,580
ვებ გვერდების თქვენი
კომპანია არის უკეთესი, ამ

740
00:35:30,580 --> 00:35:33,302
არიან სახის არგუმენტები მათ
უნდა იდეალურად შეძლებს მიიღოს.

741
00:35:33,302 --> 00:35:35,010
ან თუნდაც ეს არის
სახის რამ,

742
00:35:35,010 --> 00:35:40,211
რომ ამუშავება დისკუსია, at
სულ მცირე, ძალიან ფორმალური განხილვა.

743
00:35:40,211 --> 00:35:40,710
კარგი.

744
00:35:40,710 --> 00:35:44,400
ასე რომ, ბენ შემოთავაზებული რაღაც
მოუწოდა შერჩევა ერთგვარი.

745
00:35:44,400 --> 00:35:48,200
მაგრამ მე ვაპირებ შესთავაზოს, რომ არსებობს
სხვა გზები ამით, ძალიან.

746
00:35:48,200 --> 00:35:50,400
რა მე ნამდვილად არ მინდა
ბენ ის ალგორითმი

747
00:35:50,400 --> 00:35:54,400
ის არის, რომ დადიოდა, ან
რომელმაც მე ფეხით, უკან და მეოთხე

748
00:35:54,400 --> 00:35:56,930
და უკან და უკან და მეოთხე.

749
00:35:56,930 --> 00:36:04,130
რა მოხდება, თუ ნაცვლად მე უნდა გავაკეთოთ
რაღაც ამ ნომრებზე აქ

750
00:36:04,130 --> 00:36:08,200
და მე მხოლოდ გაუმკლავდეთ თითოეული
ნომერი, თავის მხრივ, როგორც მე მომცეს?

751
00:36:08,200 --> 00:36:10,780
>> სხვა სიტყვებით, აქ არის
ჩემს სიაში ნომრები.

752
00:36:10,780 --> 00:36:12,944
ოთხი, ერთი, სამი, ორი.

753
00:36:12,944 --> 00:36:14,360
და მე ვაპირებ ამის შემდეგ.

754
00:36:14,360 --> 00:36:17,230
მე ვაპირებ ჩადეთ ნომრები
სადაც მათ ეკუთვნის საკმაოდ

755
00:36:17,230 --> 00:36:18,980
ვიდრე შერჩევით მათ ერთ დროს.

756
00:36:18,980 --> 00:36:20,820
სხვა სიტყვებით, აქ არის ნომერი ოთხი.

757
00:36:20,820 --> 00:36:22,430
>> აი ჩემი ორიგინალური სიაში.

758
00:36:22,430 --> 00:36:25,290
და მე ვაპირებ, რომ შევინარჩუნოთ
არსებითად ახალ სიას აქ.

759
00:36:25,290 --> 00:36:26,710
ასე რომ, ეს არის ძველი სიაში.

760
00:36:26,710 --> 00:36:28,560
ეს არის ახალი სია.

761
00:36:28,560 --> 00:36:30,220
ვხედავ ნომერი ოთხი პირველი.

762
00:36:30,220 --> 00:36:34,500
ჩემი ახალი სიაში თავდაპირველად ცარიელი,
ასე რომ trivially შემთხვევაში

763
00:36:34,500 --> 00:36:36,410
რომ ოთხი ახლა ასორტი სიაში.

764
00:36:36,410 --> 00:36:39,560
მე უბრალოდ აღების ხმების მე ეძლევა,
და მე აყენებს ეს ჩემი ახალი სია.

765
00:36:39,560 --> 00:36:41,460
>> არის ეს ახალი სია დალაგებულია?

766
00:36:41,460 --> 00:36:41,990
ჰო.

767
00:36:41,990 --> 00:36:45,090
ეს სულელური იმიტომ, რომ იქ მხოლოდ ერთი
ელემენტს, მაგრამ ის აბსოლუტურად გადანაწილებული.

768
00:36:45,090 --> 00:36:46,390
არაფერია გარეთ ადგილი.

769
00:36:46,390 --> 00:36:49,290
ეს არის უფრო საინტერესო, ეს ალგორითმი,
როცა გადავა მომდევნო ნაბიჯი.

770
00:36:49,290 --> 00:36:50,550
>> ახლა მე მაქვს ერთი.

771
00:36:50,550 --> 00:36:55,430
ასე რომ, რა თქმა უნდა, ეკუთვნის დროს
დასაწყისში ან დასასრულს ამ ახალ სიაში?

772
00:36:55,430 --> 00:36:56,360
დასაწყისი.

773
00:36:56,360 --> 00:36:58,530
ასე რომ, მე უნდა გავაკეთოთ ზოგიერთი მუშაობა ახლა.

774
00:36:58,530 --> 00:37:01,410
მე უკვე გარკვეული
თავისუფლებების ჩემი marker

775
00:37:01,410 --> 00:37:03,120
მხოლოდ ხატვის რამ
სადაც მე მინდა მათ,

776
00:37:03,120 --> 00:37:05,320
მაგრამ ეს არ არის ნამდვილად
ზუსტი კომპიუტერი.

777
00:37:05,320 --> 00:37:08,530
კომპიუტერი, როგორც ვიცით, არ აქვს
RAM, ან ოპერატიული მეხსიერება,

778
00:37:08,530 --> 00:37:12,411
და რომ ერთი byte და
კიდევ ერთი ბაიტი და კიდევ ერთი ბაიტი.

779
00:37:12,411 --> 00:37:14,910
და თუ თქვენ გაქვთ გბ
RAM, თქვენ გაქვთ მილიარდი bytes,

780
00:37:14,910 --> 00:37:16,680
მაგრამ ისინი ფიზიკურად ერთ ადგილას.

781
00:37:16,680 --> 00:37:19,540
თქვენ არ შეგიძლიათ უბრალოდ გადაადგილება პერსონალის გარშემო
აღებით ის ფორუმში

782
00:37:19,540 --> 00:37:20,750
სადაც გინდა.

783
00:37:20,750 --> 00:37:24,090
ასე რომ, თუ ჩემი ახალი სია
ოთხ ადგილას მეხსიერებაში,

784
00:37:24,090 --> 00:37:27,480
სამწუხაროდ, ოთხი
უკვე არასწორ ადგილას.

785
00:37:27,480 --> 00:37:30,410
>> ასე რომ ჩადეთ ნომერი ერთი
მე არ შემიძლია დავხაზო აქ.

786
00:37:30,410 --> 00:37:31,901
ეს მეხსიერების არ არსებობს.

787
00:37:31,901 --> 00:37:35,150
ეს იქნება ღალატი, და მე
ღალატი ილუსტრირებული რამდენიმე წუთში

788
00:37:35,150 --> 00:37:35,800
აქ.

789
00:37:35,800 --> 00:37:40,950
ასე ნამდვილად, თუ მინდა, რომ აქ,
მაქვს დროებით ასლი ოთხ

790
00:37:40,950 --> 00:37:43,030
და შემდეგ დააყენა ერთი არსებობს.

791
00:37:43,030 --> 00:37:45,500
>> ეს ჯარიმა, რომ სწორი,
რომ ტექნიკურად შესაძლებელია,

792
00:37:45,500 --> 00:37:48,410
მაგრამ მიხვდებიან, რომ ზედმეტი მუშაობა.

793
00:37:48,410 --> 00:37:50,460
მე არ დააყენა ნომერი ადგილზე.

794
00:37:50,460 --> 00:37:53,026
მე პირველად მქონდა გადაადგილება
ნომერი, მაშინ, რომ ეს ადგილი,

795
00:37:53,026 --> 00:37:54,650
ამიტომ ასეთი გაორმაგდა ჩემი ოდენობით მუშაობა.

796
00:37:54,650 --> 00:37:55,660
ასე რომ შევინარჩუნოთ ამის გათვალისწინებით.

797
00:37:55,660 --> 00:37:57,120
>> მაგრამ მე ახლა კეთდება ამ ელემენტს.

798
00:37:57,120 --> 00:37:59,056
ახლა მინდა, რომ დაიბრუნოს ნომერი სამი.

799
00:37:59,056 --> 00:38:00,430
სად, რა თქმა უნდა, ეს არ ეკუთვნის?

800
00:38:00,430 --> 00:38:01,480
შორის.

801
00:38:01,480 --> 00:38:03,650
მე ვერ მოტყუებას აღარ
და მხოლოდ დააყენოს ის არსებობს,

802
00:38:03,650 --> 00:38:06,770
რადგან, კიდევ ერთხელ, ამ მეხსიერების
არის ფიზიკური ადგილას.

803
00:38:06,770 --> 00:38:10,900
ასე რომ, მე უნდა კოპირება ოთხ
და ბოლო სამი აქ.

804
00:38:10,900 --> 00:38:11,550
დიდი არაფერი.

805
00:38:11,550 --> 00:38:14,610
ეს მხოლოდ ერთი ზედმეტი ნაბიჯი
ერთხელ გრძნობს ძალიან იაფია.

806
00:38:14,610 --> 00:38:16,445
>> მაგრამ ახლა მე გადაადგილება, რათა ორი.

807
00:38:16,445 --> 00:38:17,820
ორი, რა თქმა უნდა, ეკუთვნის აქ.

808
00:38:17,820 --> 00:38:20,990
ახლა დაიწყება ვხედავთ, თუ როგორ
მუშაობა შეიძლება წყობის up.

809
00:38:20,990 --> 00:38:23,520
ახლა რა უნდა გავაკეთოთ?

810
00:38:23,520 --> 00:38:28,570
ჰო, მე უნდა გადავიდეს ოთხი,
მე მაშინ უნდა კოპირება სამი,

811
00:38:28,570 --> 00:38:31,200
და ახლა მე ჩადეთ ორი.

812
00:38:31,200 --> 00:38:34,460
და დაჭერა ამ
ალგორითმი, საინტერესოა,

813
00:38:34,460 --> 00:38:41,050
არის, რომ ვივარაუდოთ, რომ ჩვენ გვაქვს უფრო ექსტრემალური
შემთხვევაში, თუ ის, მოდით ვთქვათ, რვა, შვიდი,

814
00:38:41,050 --> 00:38:45,150
ექვსი, ხუთი, ოთხი, სამი, ორი, ერთი.

815
00:38:45,150 --> 00:38:49,450
ეს არის, ბევრ კონტექსტში,
უარეს შემთხვევაში,

816
00:38:49,450 --> 00:38:51,570
იმის გამო, რომ darn რამ
ფაქტიურად უკან.

817
00:38:51,570 --> 00:38:53,670
>> ეს ნამდვილად არ აქვს
იმოქმედებს ბენ ალგორითმი,

818
00:38:53,670 --> 00:38:55,940
იმიტომ, რომ ბენ შერჩევა
ერთგვარი ის აპირებს შენარჩუნება

819
00:38:55,940 --> 00:38:58,359
ბრუნდება და მეოთხე მეშვეობით სიაში.

820
00:38:58,359 --> 00:39:01,150
და რადგან იგი ყოველთვის ეძებს
მთელი დარჩენილი სია,

821
00:39:01,150 --> 00:39:02,858
მნიშვნელობა არ აქვს,
სადაც ელემენტები არიან.

822
00:39:02,858 --> 00:39:05,630
მაგრამ ამ შემთხვევაში ჩემი ჩასმა
მიდგომა მოდით ცდილობენ ამ.

823
00:39:05,630 --> 00:39:08,616
>> ასე რომ, ერთი, ორი, სამი, ოთხი,
ხუთი, ექვსი, შვიდი, რვა.

824
00:39:08,616 --> 00:39:11,630
ერთი ორი სამი ოთხი,
ხუთი, ექვსი, შვიდი, რვა.

825
00:39:11,630 --> 00:39:14,320
მე ვაპირებ რვა,
და სადაც მე ამას?

826
00:39:14,320 --> 00:39:17,260
ისე, დასაწყისში ჩემი სია,
იმიტომ, რომ ეს ახალი სია დალაგებულია.

827
00:39:17,260 --> 00:39:18,760
და მე გადაკვეთა ის.

828
00:39:18,760 --> 00:39:20,551
>> სად დააყენა შვიდი?

829
00:39:20,551 --> 00:39:21,050
Darn იგი.

830
00:39:21,050 --> 00:39:23,174
ის უნდა წავიდეს იქ, ასე რომ
მე უნდა გავაკეთოთ ზოგიერთი გადაწერა.

831
00:39:23,174 --> 00:39:26,820

832
00:39:26,820 --> 00:39:28,480
და ახლა შვიდი მიდის აქ.

833
00:39:28,480 --> 00:39:29,860
ახლა მე გადაადგილება, რათა ექვსი.

834
00:39:29,860 --> 00:39:30,980
ახლა ეს კიდევ უფრო მეტი მუშაობა.

835
00:39:30,980 --> 00:39:32,570
>> რვა წასვლა აქ.

836
00:39:32,570 --> 00:39:33,920
Seven უნდა წავიდეს აქ.

837
00:39:33,920 --> 00:39:35,450
ახლა ექვსი შეგვიძლია წავიდეთ აქ.

838
00:39:35,450 --> 00:39:37,950
ახლა მე დაიბრუნოს ხუთ.

839
00:39:37,950 --> 00:39:40,560
ახლა რვა უნდა წავიდეს
აქ, შვიდი უნდა წავიდეს აქ,

840
00:39:40,560 --> 00:39:43,650
ექვსი წასვლა აქ და
ახლა ხუთ და ვიმეორებ.

841
00:39:43,650 --> 00:39:46,610
და მე საკმაოდ ბევრი
მოძრავი მას მუდმივად.

842
00:39:46,610 --> 00:39:52,950
>> ასე რომ, საბოლოოდ, ეს ალგორითმი ჩვენ გამოგიგზავნით
ეძახით ჩასმა დალაგება რეალურად

843
00:39:52,950 --> 00:39:55,020
აქვს ბევრი სამუშაოა, ძალიან.

844
00:39:55,020 --> 00:39:56,970
ეს უბრალოდ სხვადასხვა
სახის სამუშაო, ვიდრე ბენ.

845
00:39:56,970 --> 00:40:00,090
ბენ მუშაობის ჰქონდა ჩემთვის აპირებს
უკან და მეოთხე, ყველა დროის,

846
00:40:00,090 --> 00:40:03,510
შერჩევის შემდეგი ყველაზე პატარა
ელემენტი ისევ და ისევ.

847
00:40:03,510 --> 00:40:06,660
ასე რომ, ამ ძალიან ვიზუალური სახის სამუშაო.

848
00:40:06,660 --> 00:40:10,600
>> ეს სხვა ალგორითმი, რომელიც ჯერ კიდევ
correct-- ის მიიღებს სამუშაოს done--

849
00:40:10,600 --> 00:40:12,800
უბრალოდ ცვლის ოდენობით მუშაობა.

850
00:40:12,800 --> 00:40:15,420
როგორც ჩანს, თავდაპირველად თქვენ
გადარჩენის, რადგან თქვენ მხოლოდ

851
00:40:15,420 --> 00:40:19,190
საქმე თითოეული ელემენტის
წინა გარეშე ფეხით ყველა

852
00:40:19,190 --> 00:40:20,930
გზას სია, ისევე როგორც ბენ იყო.

853
00:40:20,930 --> 00:40:25,300
მაგრამ პრობლემა ის არის, განსაკუთრებით ეს
გიჟები შემთხვევებში, როდესაც ეს ყველაფერი უკან,

854
00:40:25,300 --> 00:40:27,830
თქვენ უბრალოდ სახის
გადადების მძიმე სამუშაოს

855
00:40:27,830 --> 00:40:30,360
სანამ არ დაფიქსირება თქვენი შეცდომები.

856
00:40:30,360 --> 00:40:33,919
>> ასე რომ, თუ თქვენ წარმოიდგინეთ, ეს
რვა და შვიდი და ექვსი და ხუთი

857
00:40:33,919 --> 00:40:36,710
და შემდეგ ოთხი და სამი და ორი
მოძრავი მათი მეშვეობით სია,

858
00:40:36,710 --> 00:40:39,060
ჩვენ უბრალოდ შეცვალა
ტიპის მუშაობა ვაკეთებთ.

859
00:40:39,060 --> 00:40:42,340
ნაცვლად იმისა, რომ იგი
დაწყებული ჩემი iteration,

860
00:40:42,340 --> 00:40:45,250
მე უბრალოდ აკეთებს იგი
ყოველი მცდელობაა.

861
00:40:45,250 --> 00:40:50,550
გამოდის, რომ ეს ალგორითმი,
ძალიან, ზოგადად მოუწოდა Insertion დალაგების,

862
00:40:50,550 --> 00:40:52,190
ასევე ბრძანებით N კვადრატში.

863
00:40:52,190 --> 00:40:56,480
ეს, ფაქტობრივად, არ არის უკეთესი,
არსებობს უკეთესი ყველა.

864
00:40:56,480 --> 00:41:00,810
>> თუმცა, არსებობს მესამე მიდგომა
მე მოგიწოდებთ განვიხილოთ,

865
00:41:00,810 --> 00:41:02,970
რომელიც ამ.

866
00:41:02,970 --> 00:41:07,850
ასე რომ, ვფიქრობ, ჩემი სია, სიმარტივის
კიდევ ერთხელ, არის ოთხი, ერთი, სამი,

867
00:41:07,850 --> 00:41:11,080
two-- მხოლოდ ოთხი ნომრები.

868
00:41:11,080 --> 00:41:13,300
ბენ ჰქონდა კარგი ინტუიცია,
კარგი ადამიანის ინტუიცია

869
00:41:13,300 --> 00:41:16,340
ადრე, რომლითაც ჩვენ დაფიქსირდა მთელი
სიაში eventually-- Insertion დალაგების.

870
00:41:16,340 --> 00:41:18,020
მე coaxed ჩვენთან ერთად.

871
00:41:18,020 --> 00:41:22,530
მაგრამ მოდით განიხილავს
უმარტივესი გზა დაფიქსირება ამ სიაში.

872
00:41:22,530 --> 00:41:24,110
>> ამ სიაში არ არის გადანაწილებული.

873
00:41:24,110 --> 00:41:26,130
რატომ?

874
00:41:26,130 --> 00:41:31,920
ინგლისურ, რატომ
ეს არ არის რეალურად გადანაწილებული.

875
00:41:31,920 --> 00:41:33,400
რას ნიშნავს, არ უნდა იყოს გადანაწილებული?

876
00:41:33,400 --> 00:41:34,220
>> სტუდენტი: ეს არ არის თანმიმდევრული.

877
00:41:34,220 --> 00:41:34,990
>> დავით Malan: არ თანმიმდევრული.

878
00:41:34,990 --> 00:41:35,822
მომეცი მაგალითი.

879
00:41:35,822 --> 00:41:37,180
>> სტუდენტი: განათავსეთ მათ მიზნით.

880
00:41:37,180 --> 00:41:37,440
>> დავით Malan: OK.

881
00:41:37,440 --> 00:41:38,790
მომეცი უფრო კონკრეტული მაგალითი.

882
00:41:38,790 --> 00:41:39,832
>> სტუდენტი: მიმდევრობით.

883
00:41:39,832 --> 00:41:41,206
დავით Malan: არ მიმდევრობით.

884
00:41:41,206 --> 00:41:42,100
უფრო სწორად.

885
00:41:42,100 --> 00:41:45,190
მე არ ვიცი, რას ნიშნავს აღმავალი.

886
00:41:45,190 --> 00:41:47,150
რა მოხდა?

887
00:41:47,150 --> 00:41:49,930
>> სტუდენტი: პატარა
ციფრები არ არის პირველი სივრცეში.

888
00:41:49,930 --> 00:41:51,140
>> დავით Malan: პატარა ნომრის
არა პირველ სივრცეში.

889
00:41:51,140 --> 00:41:52,120
უფრო კონკრეტულად.

890
00:41:52,120 --> 00:41:55,000
მე დაწყებული დაჭერა.

891
00:41:55,000 --> 00:41:59,470
ჩვენ იმედი, მაგრამ
რა არის მწყობრიდან აქ?

892
00:41:59,470 --> 00:42:00,707
>> STUDENT რიცხვითი თანმიმდევრობა.

893
00:42:00,707 --> 00:42:02,040
დავით Malan: რიცხვითი თანმიმდევრობა.

894
00:42:02,040 --> 00:42:04,248
ყველას სახის შენახვის
ის აქ ძალიან მაღალ დონეზე.

895
00:42:04,248 --> 00:42:07,450
უბრალოდ სიტყვასიტყვით მეუბნებოდა, თუ რა არის
არასწორი, როგორც ხუთი წლის შეიძლება.

896
00:42:07,450 --> 00:42:08,310
>> სტუდენტი: პლუს ერთი.

897
00:42:08,310 --> 00:42:08,750
>> დავით Malan: რა არის ეს?

898
00:42:08,750 --> 00:42:09,610
>> სტუდენტი: პლუს ერთი.

899
00:42:09,610 --> 00:42:11,235
>> დავით Malan: რას ნიშნავს პლუს ერთი?

900
00:42:11,235 --> 00:42:12,754

901
00:42:12,754 --> 00:42:14,170
მომეცი სხვადასხვა ხუთი წლის.

902
00:42:14,170 --> 00:42:16,840

903
00:42:16,840 --> 00:42:18,330
რა არის არასწორი, დედა?

904
00:42:18,330 --> 00:42:19,940
რა არის არასწორი, მამა?

905
00:42:19,940 --> 00:42:22,808
რას ნიშნავს ეს არ არის გადანაწილებული?

906
00:42:22,808 --> 00:42:24,370
>> სტუდენტი: ეს არ არის სწორი ადგილი.

907
00:42:24,370 --> 00:42:25,580
>> დავით Malan: რა არის
არ არის სწორი ადგილი?

908
00:42:25,580 --> 00:42:26,174
>> სტუდენტი: Four.

909
00:42:26,174 --> 00:42:27,090
დავით Malan: კარგი, კარგი.

910
00:42:27,090 --> 00:42:29,110
ასე რომ ოთხი არ არის, სადაც ეს უნდა იყოს.

911
00:42:29,110 --> 00:42:30,590
კერძოდ, ეს უფლება?

912
00:42:30,590 --> 00:42:33,000
ოთხი და ერთი, პირველი
ორი რიცხვის ვხედავ.

913
00:42:33,000 --> 00:42:34,930
არის თუ არა ეს უფლება?

914
00:42:34,930 --> 00:42:36,427
არა, ისინი მწყობრიდან, არა?

915
00:42:36,427 --> 00:42:38,135
სინამდვილეში, ვფიქრობ, ახლა
შესახებ კომპიუტერი, ძალიან.

916
00:42:38,135 --> 00:42:40,824
ეს შეიძლება მხოლოდ შევხედოთ იქნებ ერთი,
იქნებ ორი რამ once--

917
00:42:40,824 --> 00:42:43,240
და რეალურად მხოლოდ ერთი რამ
იმ დროს, მაგრამ ეს შეიძლება მინიმუმ

918
00:42:43,240 --> 00:42:45,790
შეხედეთ ერთი რამ მაშინ
შემდეგი რამ უფლება შემდეგ იგი.

919
00:42:45,790 --> 00:42:47,380
>> ასე რომ, ეს, რათა?

920
00:42:47,380 --> 00:42:48,032
რათქმაუნდა არა.

921
00:42:48,032 --> 00:42:48,740
ასე, რომ თქვენ იცით, რა?

922
00:42:48,740 --> 00:42:51,020
რატომ არ ვიღებთ ბავშვი
ნაბიჯები აფიქსირებს ამ პრობლემას

923
00:42:51,020 --> 00:42:53,410
ნაცვლად აკეთებს ამ ლამაზი
ალგორითმები ისევე როგორც ბენ, სადაც

924
00:42:53,410 --> 00:42:56,440
ის ერთგვარი აფიქსირებს, რომ ის მიერ
looping მეშვეობით სია

925
00:42:56,440 --> 00:42:59,670
ნაცვლად აკეთებს, რა გავაკეთე, სადაც
მე უბრალოდ სახის დაფიქსირდა, როგორც ჩვენ წავიდეთ?

926
00:42:59,670 --> 00:43:03,650
მოდით უბრალოდ სიტყვასიტყვით ჩაიშალოს
ცნება order-- რიცხვითი მიზნით,

927
00:43:03,650 --> 00:43:06,990
ეძახით რასაც თქვენ want--
შევიდა ამ pairwise შედარება.

928
00:43:06,990 --> 00:43:07,590
>> ოთხი და ერთი.

929
00:43:07,590 --> 00:43:09,970
არის თუ არა ეს სწორი მიზნით?

930
00:43:09,970 --> 00:43:11,310
მოდით დაფიქსირება, რომ.

931
00:43:11,310 --> 00:43:14,700
ერთი და ოთხი და შემდეგ
ჩვენ უბრალოდ კოპირება.

932
00:43:14,700 --> 00:43:15,560
ყველა უფლება, კარგი.

933
00:43:15,560 --> 00:43:17,022
მე დაფიქსირდა ერთი და ოთხი.

934
00:43:17,022 --> 00:43:18,320
სამი და ორი?

935
00:43:18,320 --> 00:43:18,820
No.

936
00:43:18,820 --> 00:43:21,690
მოდით, ჩემი სიტყვა ემთხვევა ჩემი თითების.

937
00:43:21,690 --> 00:43:23,695
ოთხი და სამი?

938
00:43:23,695 --> 00:43:27,930
>> ეს არ არის იმისათვის, ასე რომ მე ვაპირებ
გავაკეთოთ ერთი, სამი, ოთხი, ორი.

939
00:43:27,930 --> 00:43:28,680
კარგი, კარგია.

940
00:43:28,680 --> 00:43:32,310
ახლა ოთხი და ორი?

941
00:43:32,310 --> 00:43:33,370
ჩვენ ეს უნდა გამოვასწოროთ, ძალიან.

942
00:43:33,370 --> 00:43:36,700
ასე რომ, ერთი, სამი, ორი, ოთხი.

943
00:43:36,700 --> 00:43:39,820
ასე რომ, ის გადანაწილებული?

944
00:43:39,820 --> 00:43:43,170
არა, მაგრამ იგი უფრო ახლოს გადანაწილებული?

945
00:43:43,170 --> 00:43:48,930
>> ეს არის, იმიტომ, რომ ჩვენ დაფიქსირდა ეს
შეცდომა, ჩვენ ფიქსირებული ეს შეცდომა,

946
00:43:48,930 --> 00:43:50,370
და ჩვენ ფიქსირებული ეს შეცდომა.

947
00:43:50,370 --> 00:43:52,420
ასე რომ, ჩვენ დაფიქსირდა სამი შეცდომები, ალბათ.

948
00:43:52,420 --> 00:43:58,100
ჯერ კიდევ ნამდვილად არ გამოიყურება დახარისხებული, მაგრამ
ის ობიექტურად დაახლოება დახარისხებული

949
00:43:58,100 --> 00:44:00,080
იმიტომ, რომ ჩვენ დაფიქსირდა რამდენიმე იმ შეცდომების.

950
00:44:00,080 --> 00:44:02,047
>> ახლა რა გავაკეთოთ შემდეგი?

951
00:44:02,047 --> 00:44:03,630
I ტიპის მიაღწია ბოლოს სიაში.

952
00:44:03,630 --> 00:44:05,680
როგორც ჩანს, არ დაფიქსირდა
ყველა შეცდომა, მაგრამ არა.

953
00:44:05,680 --> 00:44:08,510
იმის გამო, რომ ამ შემთხვევაში, ზოგიერთი ნომრები
ალბათ bubbled უფრო მჭიდრო

954
00:44:08,510 --> 00:44:10,410
სხვა ნომრები,
ჯერ კიდევ მწყობრიდან.

955
00:44:10,410 --> 00:44:12,951
ასე რომ, მოდით ეს კიდევ ერთხელ, და მე
უბრალოდ ის ადგილი ამ დროს.

956
00:44:12,951 --> 00:44:14,170
ერთი და სამი?

957
00:44:14,170 --> 00:44:14,720
ეს ჯარიმა.

958
00:44:14,720 --> 00:44:16,070
სამი და ორი?

959
00:44:16,070 --> 00:44:17,560
რა თქმა უნდა, არ არის, ასე რომ, მოდით შეცვლის.

960
00:44:17,560 --> 00:44:19,160
ასე რომ, ორი, სამი.

961
00:44:19,160 --> 00:44:21,340
სამი და ოთხი?

962
00:44:21,340 --> 00:44:24,370
და ახლა მოდით უბრალოდ იყოს
განსაკუთრებით pedantic აქ.

963
00:44:24,370 --> 00:44:26,350
არის ის გადანაწილებული?

964
00:44:26,350 --> 00:44:29,280
თქვენ ადამიანები ვიცით, ეს დახარისხებული.

965
00:44:29,280 --> 00:44:30,400
>> მე უნდა ვეცადოთ ერთხელ.

966
00:44:30,400 --> 00:44:31,900
ასე რომ, Olivia სთავაზობს ვცდილობ კიდევ ერთხელ.

967
00:44:31,900 --> 00:44:32,530
რატომ?

968
00:44:32,530 --> 00:44:35,810
იმის გამო, რომ კომპიუტერი არ
ფუფუნება ჩვენი თვალით

969
00:44:35,810 --> 00:44:38,080
მხოლოდ გადავავლე back-- OK, მე გაკეთდეს.

970
00:44:38,080 --> 00:44:41,610
რა კომპიუტერი განსაზღვრავს
რომ სიაში არის გადანაწილებული?

971
00:44:41,610 --> 00:44:44,590
მექანიკურად.

972
00:44:44,590 --> 00:44:47,650
>> მე უნდა გაიაროს
კიდევ ერთხელ, და თუ მე

973
00:44:47,650 --> 00:44:51,190
არ მიიღოს / იპოვით ნებისმიერი შეცდომა შეიძლება მე
მაშინ დავასკვნათ, როგორც კომპიუტერი, yep,

974
00:44:51,190 --> 00:44:51,980
ჩვენ კარგი წასვლა.

975
00:44:51,980 --> 00:44:54,850
ასე რომ, ერთი და ორი, და
სამი, სამი და ოთხი.

976
00:44:54,850 --> 00:44:58,030
ახლა მე შეიძლება საბოლოოდ ვთქვა, ეს არის
დახარისხებული, იმიტომ, რომ მე არ შეუცვლია.

977
00:44:58,030 --> 00:45:01,940
ახლა ეს იქნება შეცდომა და მხოლოდ
სულელური, თუ მე, კომპიუტერი,

978
00:45:01,940 --> 00:45:05,640
კითხვაზე, იმ იგივე კითხვები ისევ
ველოდებით სხვადასხვა პასუხი.

979
00:45:05,640 --> 00:45:07,110
არ უნდა მოხდეს.

980
00:45:07,110 --> 00:45:08,600
>> ასე რომ, ახლა სია დალაგებულია.

981
00:45:08,600 --> 00:45:12,630
სამწუხაროდ, ქრონომეტრაჟი
ეს ალგორითმი ასევე n კვადრატში.

982
00:45:12,630 --> 00:45:13,130
რატომ?

983
00:45:13,130 --> 00:45:19,520
იმის გამო, რომ თქვენ გაქვთ N ნომრები, და
უარეს შემთხვევაში, თქვენ უნდა გადავიდეს N ნომრები

984
00:45:19,520 --> 00:45:23,637
n ჯერ იმიტომ, რომ თქვენ უნდა შევინარჩუნოთ აპირებს
უკან შემოწმება და პოტენციურად დაფიქსირება

985
00:45:23,637 --> 00:45:24,220
ამ ნომრებზე.

986
00:45:24,220 --> 00:45:26,280
და ჩვენ შეგვიძლია გავაკეთოთ უფრო
ფორმალური ანალიზის, ძალიან.

987
00:45:26,280 --> 00:45:29,530
>> ასე რომ, ეს არის ყველა, რომ ვთქვათ, ჩვენ მიღებული
სამი განსხვავებული მიდგომები, ერთი

988
00:45:29,530 --> 00:45:32,210
მათგანი მაშინვე ინტუიციური
off bat, ბენ

989
00:45:32,210 --> 00:45:35,170
ჩემი ვარაუდით ჩასმა
დალაგება ეს ერთი

990
00:45:35,170 --> 00:45:38,540
სადაც თქვენ სახის დაკარგავს დანახვაზე
ტყეში ხეები თავდაპირველად.

991
00:45:38,540 --> 00:45:41,760
მაგრამ თუ თქვენ მიიღოს უკან გადადგმული ნაბიჯია,
voila, ჩვენ დაფიქსირდა დახარისხება ცნება.

992
00:45:41,760 --> 00:45:43,824
ასე რომ, ეს, ვთქვათ,
ქვედა დონეზე, ალბათ,

993
00:45:43,824 --> 00:45:45,740
ვიდრე ზოგიერთი იმ სხვა
ალგორითმები, მაგრამ მოდით,

994
00:45:45,740 --> 00:45:48,550
თუ ჩვენ ვერ ვიზუალიზაციისთვის
ამ გზით ეს.

995
00:45:48,550 --> 00:45:51,450
>> ასე რომ, ეს არის ლამაზი
პროგრამული უზრუნველყოფა, რომ ვინმე

996
00:45:51,450 --> 00:45:56,110
წერდა გამოყენებით ფერადი ბარები, რომ
აპირებს ამის შემდეგ ჩვენთვის.

997
00:45:56,110 --> 00:45:57,736
თითოეული ეს ბარები წარმოადგენს ნომერი.

998
00:45:57,736 --> 00:46:00,026
Taller ბარი, მით უფრო დიდია
ნომერი, პატარა ბარი,

999
00:46:00,026 --> 00:46:00,990
პატარა ნომერი.

1000
00:46:00,990 --> 00:46:05,880
ასე რომ იდეალურად ჩვენ გვინდა ლამაზი პირამიდის
სადაც იგი იწყებს მცირე და იღებს დიდი,

1001
00:46:05,880 --> 00:46:08,330
რაც ნიშნავს იმას, რომ
ამ ბარები დახარისხებული.

1002
00:46:08,330 --> 00:46:11,200
ამიტომ, მე ვაპირებ წავიდეთ წინ და აირჩიოს,
მაგალითად, ბენ ალგორითმი

1003
00:46:11,200 --> 00:46:13,990
, პირველი შერჩევა ერთგვარი.

1004
00:46:13,990 --> 00:46:16,220
>> და შენიშნავს, რასაც ის აკეთებს.

1005
00:46:16,220 --> 00:46:18,670
გზა ისინი არჩეული
ვიზუალურად ეს ალგორითმი

1006
00:46:18,670 --> 00:46:22,090
ის არის, რომ, ისევე, როგორც მე ვიყავი
გავლით ჩემს სიაში,

1007
00:46:22,090 --> 00:46:24,710
ეს პროგრამა ფეხით
თავისი სიაში ნომრები,

1008
00:46:24,710 --> 00:46:28,160
ხაზს უსვამს ვარდისფერი თითოეულ
ნომერი რომ ის ეძებს.

1009
00:46:28,160 --> 00:46:32,360
და რა უნდა მოხდეს ახლა?

1010
00:46:32,360 --> 00:46:35,154
>> ყველაზე პატარა ნომერი, რომელიც
მე და ბენ ნაპოვნი მოულოდნელად

1011
00:46:35,154 --> 00:46:36,820
იღებს გადავიდა დასაწყისში სიაში.

1012
00:46:36,820 --> 00:46:40,037
და შეამჩნია ისინი არ გაყრის
ნომერი, რომელიც იქ იყო,

1013
00:46:40,037 --> 00:46:41,120
და რომ შესანიშნავად ჯარიმა.

1014
00:46:41,120 --> 00:46:42,600
მე არ მოხვდება, რომ დონეზე დეტალურად.

1015
00:46:42,600 --> 00:46:44,308
მაგრამ ჩვენ უნდა დააყენოს
რომ ნომერი, სადღაც,

1016
00:46:44,308 --> 00:46:47,775
ასე რომ ჩვენ უბრალოდ გადაიტანეს
ღია ადგილზე, რომელიც შეიქმნა.

1017
00:46:47,775 --> 00:46:49,900
ამიტომ, მე ვაპირებ, რათა დაჩქარდეს ეს
up, იმიტომ, რომ წინააღმდეგ შემთხვევაში, ეს

1018
00:46:49,900 --> 00:46:51,871
ხდება ძალიან რუტინული სწრაფად.

1019
00:46:51,871 --> 00:46:55,800

1020
00:46:55,800 --> 00:46:58,600
ანიმაციები speed-- იქ ჩვენ წავიდეთ.

1021
00:46:58,600 --> 00:47:01,850
ასე რომ, ახლა იგივე პრინციპი
მე მსჯელობა, მაგრამ თქვენ

1022
00:47:01,850 --> 00:47:06,540
შეიძლება დაიწყოს გრძნობენ ალგორითმი, თუ
ნება, ან დანახვა ცოტა უფრო ნათლად.

1023
00:47:06,540 --> 00:47:13,190
და ეს ალგორითმი აქვს ეფექტი
შერჩევის შემდეგი ყველაზე პატარა ელემენტი,

1024
00:47:13,190 --> 00:47:16,422
ასე რომ თქვენ აპირებთ უნდა დაიწყოს
ვხედავ, რომ გაეზარდათ მარცხენა.

1025
00:47:16,422 --> 00:47:19,130
და თითოეულ iteration, როგორც მე
შემოთავაზებული, ეს იმას ცოტა ნაკლები მუშაობა.

1026
00:47:19,130 --> 00:47:21,921
ეს არ უნდა წავიდეთ ყველა გზა
უკან მარცხენა ბოლოს სიაში,

1027
00:47:21,921 --> 00:47:23,900
იმიტომ, რომ ეს უკვე
იცნობს დახარისხებული.

1028
00:47:23,900 --> 00:47:28,129
ასე რომ, ეს სახის იგრძნობა ეს
დაჩქარება, მიუხედავად იმისა, რომ ყოველი ნაბიჯი არის

1029
00:47:28,129 --> 00:47:29,420
იღებენ იგივე დროის.

1030
00:47:29,420 --> 00:47:31,600
არსებობს მხოლოდ ნაკლები ნაბიჯები დარჩენილი.

1031
00:47:31,600 --> 00:47:35,240
და ახლა თქვენ შეგიძლიათ სახის გრძნობს
ალგორითმი გაწმენდის ბოლომდე,

1032
00:47:35,240 --> 00:47:37,040
და მართლაც, ახლა ის გადანაწილებული.

1033
00:47:37,040 --> 00:47:41,620
>> ასე რომ, Insertion დალაგების არის ყველაფერი კეთდება.

1034
00:47:41,620 --> 00:47:43,600
მე უნდა ხელახლა randomize მასივი.

1035
00:47:43,600 --> 00:47:45,940
და შენიშნავს, მე შემიძლია უბრალოდ
შენარჩუნება randomizing მას,

1036
00:47:45,940 --> 00:47:50,630
და ჩვენ კიდევ დაახლოებას
იგივე მიდგომა, Insertion დალაგების.

1037
00:47:50,630 --> 00:47:55,050
მიადევნე თვალი ნელი მას აქ.

1038
00:47:55,050 --> 00:47:56,915
დავიწყოთ, რომ დასრულდა.

1039
00:47:56,915 --> 00:47:57,414
შეჩერება.

1040
00:47:57,414 --> 00:48:00,662

1041
00:48:00,662 --> 00:48:02,410
>> მოდით გაფართოებული ოთხ.

1042
00:48:02,410 --> 00:48:03,200
იქ ჩვენ წავიდეთ.

1043
00:48:03,200 --> 00:48:04,190
Randomize ისინი მასივი.

1044
00:48:04,190 --> 00:48:05,555
და აქ ჩვენ go-- Insertion დალაგების.

1045
00:48:05,555 --> 00:48:10,260

1046
00:48:10,260 --> 00:48:12,800
თამაში.

1047
00:48:12,800 --> 00:48:17,280
გაითვალისწინეთ, რომ ეს საქმე ყოველი
ელემენტი ეს შეტაკებები დაუყოვნებლივ,

1048
00:48:17,280 --> 00:48:20,282
მაგრამ თუ მას ეკუთვნის
არასწორი ადგილი ცნობა

1049
00:48:20,282 --> 00:48:21,740
ყველა სამუშაო, რომელიც უნდა მოხდეს.

1050
00:48:21,740 --> 00:48:24,700
ჩვენ უნდა შევინარჩუნოთ გადასვლის მეტი
და სხვა ელემენტები, რათა ოთახი

1051
00:48:24,700 --> 00:48:27,340
ერთი, ჩვენ გვინდა, რომ ადგილზე.

1052
00:48:27,340 --> 00:48:30,740
>> ასე რომ, ჩვენ აქცენტი
მარცხენა ბოლოს სია.

1053
00:48:30,740 --> 00:48:34,460
გაითვალისწინეთ ჩვენ კი არ შევხედეთ ჩვენ
არ მონიშნულია ვარდისფერი არაფერი

1054
00:48:34,460 --> 00:48:35,610
მარჯვნივ.

1055
00:48:35,610 --> 00:48:38,180
ჩვენ უბრალოდ საქმე
პრობლემების, როგორც ჩვენ წავიდეთ

1056
00:48:38,180 --> 00:48:40,430
მაგრამ ჩვენ შექმნის ბევრი
მუშაობა საკუთარ თავს მაინც.

1057
00:48:40,430 --> 00:48:44,410
ასე რომ, თუ ჩვენ დაჩქარდეს ეს
ახლა წასვლა დასრულების შემდეგ,

1058
00:48:44,410 --> 00:48:46,210
მას აქვს სხვადასხვა ფიქრობს, რომ ის მართლაც.

1059
00:48:46,210 --> 00:48:50,150
უბრალოდ აქცენტი მარცხენა ბოლოს, მაგრამ
ამით ცოტა მეტი მუშაობა, როგორც needed--

1060
00:48:50,150 --> 00:48:53,230
სახის დამარბილებელი რამ
მეტი, აფიქსირებს რამ,

1061
00:48:53,230 --> 00:48:58,350
მაგრამ საქმე საბოლოო ჯამში
თითოეული ელემენტის ერთ დროს

1062
00:48:58,350 --> 00:49:07,740
სანამ არ მივიღებთ the-- კარგად, ჩვენ
ყველამ ვიცით, თუ როგორ აპირებს დასრულდება,

1063
00:49:07,740 --> 00:49:09,700
ასე რომ, ეს არის პატარა underwhelming ალბათ.

1064
00:49:09,700 --> 00:49:12,830
>> მაგრამ სიაში end--
spoiler-- იქნება გადანაწილებული.

1065
00:49:12,830 --> 00:49:15,300
მოდით შევხედოთ ერთი ბოლო.

1066
00:49:15,300 --> 00:49:16,840
ჩვენ არ შეგვიძლია უბრალოდ გამოტოვოთ ახლა.

1067
00:49:16,840 --> 00:49:18,000
ჩვენ თითქმის არ არსებობს.

1068
00:49:18,000 --> 00:49:19,980
ორი წასვლა, ერთი უნდა წავიდეს.

1069
00:49:19,980 --> 00:49:22,680
და voila.

1070
00:49:22,680 --> 00:49:23,450
შესანიშნავი.

1071
00:49:23,450 --> 00:49:27,220
>> ასე რომ, ახლა მოდით ერთი ბოლო,
ხელახლა randomizing ერთად bubble sort.

1072
00:49:27,220 --> 00:49:31,690
და შენიშნავს, აქ, განსაკუთრებით, თუ მე ნელი ის
ქვემოთ, ეს იმას შენარჩუნება swooping მეშვეობით.

1073
00:49:31,690 --> 00:49:36,830
მაგრამ შეამჩნია ეს მხოლოდ იღებს pairwise
comparisons-- ერთგვარი ადგილობრივი გადაწყვეტილებები.

1074
00:49:36,830 --> 00:49:39,050
მაგრამ, როგორც კი მივიღებთ, რომ
ბოლოს სიის ვარდისფერი,

1075
00:49:39,050 --> 00:49:40,690
რა ხდება უნდა მოხდეს?

1076
00:49:40,690 --> 00:49:44,539

1077
00:49:44,539 --> 00:49:46,830
ჰო, ის აპირებს უნდა
დაიწყოს, რადგან ეს მხოლოდ

1078
00:49:46,830 --> 00:49:49,870
ფიქსირებული pairwise შეცდომები.

1079
00:49:49,870 --> 00:49:53,120
და რომ შეიძლება არ გამოვლინდა კიდევ სხვები.

1080
00:49:53,120 --> 00:49:58,950
ასე რომ, თუ დაჩქარდეს ეს, თქვენ
ვხედავთ, რომ, ისევე როგორც სახელი გულისხმობს,

1081
00:49:58,950 --> 00:50:01,870
პატარა ელემენტებს უფრო სწორად,
დიდი ელემენტებს ვიწყებთ

1082
00:50:01,870 --> 00:50:03,740
ბუშტი მდე დაბრუნება, თუ გნებავთ.

1083
00:50:03,740 --> 00:50:07,380
და პატარა ელემენტები არიან
დაწყებული bubble ქვემოთ მარცხენა.

1084
00:50:07,380 --> 00:50:10,780
და მართლაც, რომ სახის
ვიზუალური ეფექტი, ისევე.

1085
00:50:10,780 --> 00:50:17,150
ასე რომ, ეს დასრულდება მდე დასრულების
ძალიან მსგავსი გზით, ძალიან.

1086
00:50:17,150 --> 00:50:19,160
>> ჩვენ არ გვაქვს, რომ არენაზე
ამ კონკრეტულ შემთხვევაში.

1087
00:50:19,160 --> 00:50:21,010
ნება მომეცით გახსნა ახლა, ძალიან.

1088
00:50:21,010 --> 00:50:24,040
არსებობს რამდენიმე სხვა დახარისხება ალგორითმები
მსოფლიოში, რამდენიმე რომლის

1089
00:50:24,040 --> 00:50:25,580
ტყვედ აქ.

1090
00:50:25,580 --> 00:50:29,960
და, განსაკუთრებით, მოსწავლეების, რომლებიც არ არიან
აუცილებლად ვიზუალური და მათემატიკის,

1091
00:50:29,960 --> 00:50:31,930
როგორც ჩვენ გავაკეთეთ ადრე, ჩვენ შეგვიძლია
ასევე ამის გაკეთება audially

1092
00:50:31,930 --> 00:50:34,210
თუ ჩვენ ასოცირდება ხმა ამ.

1093
00:50:34,210 --> 00:50:36,990
და უბრალოდ for fun, აქ არის
რამდენიმე სხვადასხვა ალგორითმები,

1094
00:50:36,990 --> 00:50:40,950
ერთ-ერთი მათგანი, კერძოდ, თქვენ
აპირებს შეამჩნია ეწოდება "შერწყმა დალაგების".

1095
00:50:40,950 --> 00:50:43,250
>> სინამდვილეში ეს არის ფუნდამენტურად
უკეთესი ალგორითმი,

1096
00:50:43,250 --> 00:50:45,860
ისეთი, რომ შერწყმა დალაგების, ერთ-ერთი
პირობა თქვენ შესახებ, რომ ნახოთ,

1097
00:50:45,860 --> 00:50:49,170
არ არის ბრძანებით N კვადრატში.

1098
00:50:49,170 --> 00:50:57,280
ეს ბრძანებით N ჯერ შესვლა of
n, რომელიც რეალურად პატარა და ამით

1099
00:50:57,280 --> 00:50:58,940
უფრო სწრაფად, ვიდრე სხვა სამი.

1100
00:50:58,940 --> 00:51:00,670
და იქ რამდენიმე სხვა
სულელური პირობა, რომ ჩვენ დავინახავთ.

1101
00:51:00,670 --> 00:51:01,933
>> ასე რომ, აქ ჩვენ წავიდეთ ერთად ხმა.

1102
00:51:01,933 --> 00:51:06,620

1103
00:51:06,620 --> 00:51:10,490
ეს არის Insertion დალაგების, ასე რომ კიდევ ერთხელ
ეს უბრალოდ საქმე ელემენტები

1104
00:51:10,490 --> 00:51:13,420
როგორც ისინი.

1105
00:51:13,420 --> 00:51:17,180
ეს არის bubble sort, ამიტომ
იმის გათვალისწინებით, მათ წყვილი დროს.

1106
00:51:17,180 --> 00:51:22,030

1107
00:51:22,030 --> 00:51:24,490
ისევ და ისევ, დიდი ელემენტები
არიან bubbling მდე დაბრუნება.

1108
00:51:24,490 --> 00:51:38,098

1109
00:51:38,098 --> 00:51:41,710
>> შემდეგი up შერჩევა ერთგვარი.

1110
00:51:41,710 --> 00:51:45,420
ეს არის ბენ ალგორითმი, სადაც
ერთხელ ის შერჩევით iteratively

1111
00:51:45,420 --> 00:51:46,843
შემდეგი ყველაზე პატარა ელემენტს.

1112
00:51:46,843 --> 00:51:49,801

1113
00:51:49,801 --> 00:51:53,900
ისევ და ისევ, ახლა შეგიძლიათ ნამდვილად მესმის, რომ
ის დაჩქარებას, მაგრამ მხოლოდ იმდენად, რამდენადაც

1114
00:51:53,900 --> 00:51:58,230
როგორც ის აკეთებს და უფრო ნაკლებად
მუშაობა თითოეული მცდელობაა.

1115
00:51:58,230 --> 00:52:04,170
ეს არის სწრაფად ერთი, შერწყმა დალაგების,
რომელიც დახარისხება მტევანი ნომრები

1116
00:52:04,170 --> 00:52:05,971
ერთად და შემდეგ აერთიანებს მათ.

1117
00:52:05,971 --> 00:52:07,720
ასე რომ, look-- მარცხენა
ნახევარი უკვე დახარისხებული.

1118
00:52:07,720 --> 00:52:14,165
>> ახლა ის დახარისხება მარჯვენა ნახევარში, და
ახლა ის აპირებს აერთიანებს მათ ერთ.

1119
00:52:14,165 --> 00:52:19,160
ეს არის რაღაც მოუწოდა "Gnome სახის".

1120
00:52:19,160 --> 00:52:23,460
და თქვენ შეგიძლიათ სახის ვხედავ, რომ
ის აპირებს უკან და მეოთხე,

1121
00:52:23,460 --> 00:52:27,950
აფიქსირებს მუშაობა ცოტა აქ და
იქ ადრე იგი აგრძელებს ახალი სამუშაო.

1122
00:52:27,950 --> 00:52:32,900

1123
00:52:32,900 --> 00:52:33,692
და ეს არის ის.

1124
00:52:33,692 --> 00:52:36,400
არსებობს კიდევ ერთი დალაგების, რომელიც
მართლაც მხოლოდ აკადემიური მიზნებისათვის,

1125
00:52:36,400 --> 00:52:40,980
სახელწოდებით "სულელური ერთგვარი", რომელიც იღებს
თქვენი მონაცემები, ჯიშები ის შემთხვევით,

1126
00:52:40,980 --> 00:52:43,350
და შემდეგ ამოწმებს, თუ ის გადანაწილებული.

1127
00:52:43,350 --> 00:52:47,880
და თუ ეს ასე არ არის, იგი ხელახლა ჯიშები ეს
შემთხვევით, ამოწმებს, თუ ეს დახარისხებული,

1128
00:52:47,880 --> 00:52:49,440
და თუ არ იმეორებს.

1129
00:52:49,440 --> 00:52:52,660
და თეორიულად probabilistically
ეს დაასრულებს,

1130
00:52:52,660 --> 00:52:54,140
მაგრამ მას შემდეგ, საკმაოდ ცოტა დრო.

1131
00:52:54,140 --> 00:52:56,930
ეს არ არის ყველაზე
ეფექტური ალგორითმები.

1132
00:52:56,930 --> 00:53:02,550
ასე რომ ნებისმიერი კითხვებს იმ
კერძოდ ალგორითმები ან არაფერი

1133
00:53:02,550 --> 00:53:04,720
დაკავშირებული იქ, ძალიან?

1134
00:53:04,720 --> 00:53:09,430
>> მოდით, ახლა აჯავრებენ გარდა რა ყველა
ეს ხაზები, რომ მე უკვე ხატვის

1135
00:53:09,430 --> 00:53:15,090
და რა მე თუ ვთქვათ კომპიუტერული
შეგიძლიათ გააკეთოთ ქვეშ hood.

1136
00:53:15,090 --> 00:53:18,650
მე ვიტყოდი, რომ ყველა ამ ნომრებზე
მე შენარჩუნება drawing-- მათ უნდა მიიღონ

1137
00:53:18,650 --> 00:53:21,330
შენახული სადღაც მეხსიერებაში.

1138
00:53:21,330 --> 00:53:24,130
ჩვენ თავი დაეღწია ამ ბიჭი, ძალიან.

1139
00:53:24,130 --> 00:53:30,110
>> ასე ცალი მეხსიერების
კომპიუტერში ასე RAM DIMM არის

1140
00:53:30,110 --> 00:53:35,480
ის, რაც ჩვენ ჩხრეკა გუშინ, ორმაგი
inline მეხსიერება module-- ასე გამოიყურება.

1141
00:53:35,480 --> 00:53:39,370
და თითოეულ ამ პატარა შავი ჩიპი
არის გარკვეული რაოდენობის ბაიტი, როგორც წესი.

1142
00:53:39,370 --> 00:53:44,380
და მაშინ ოქროს ქინძისთავები ჰგვანან
ხაზები, დააკავშირებს მას კომპიუტერი,

1143
00:53:44,380 --> 00:53:47,521
და მწვანე სილიკონის საბჭოს მხოლოდ
რა ინახავს ყველაფერს ერთად.

1144
00:53:47,521 --> 00:53:48,770
ასე რომ, რას ნიშნავს რეალურად?

1145
00:53:48,770 --> 00:53:53,180
თუ ასეთი მიაპყროს იგივე სურათი,
მოდით ვივარაუდოთ, სიმარტივის

1146
00:53:53,180 --> 00:53:55,280
რომ ეს DIMM, ორმაგი
inline მეხსიერების მოდული,

1147
00:53:55,280 --> 00:54:00,530
ერთ-ერთი გბ RAM, ერთი Gigabyte of
მეხსიერება, რომელიც რამდენი ბაიტი სულ?

1148
00:54:00,530 --> 00:54:02,100
ერთი Gigabyte რამდენი ბაიტი?

1149
00:54:02,100 --> 00:54:04,860

1150
00:54:04,860 --> 00:54:06,030
მეტია.

1151
00:54:06,030 --> 00:54:09,960
1,124 არის კილო, 1000.

1152
00:54:09,960 --> 00:54:11,730
Mega არის მლნ.

1153
00:54:11,730 --> 00:54:14,570
გიგა არის მილიარდი.

1154
00:54:14,570 --> 00:54:15,070
>> ვარ მე ცრუობს?

1155
00:54:15,070 --> 00:54:16,670
შეგვიძლია კი წავიკითხე ეტიკეტზე?

1156
00:54:16,670 --> 00:54:19,920
ეს არის რეალურად 128
გიგაბაიტი, ასე რომ მეტი.

1157
00:54:19,920 --> 00:54:22,130
მაგრამ ჩვენ პრეტენზია ამ
არის მხოლოდ ერთი gigabyte.

1158
00:54:22,130 --> 00:54:25,640
ასე რომ, ეს ნიშნავს, რომ იქ მილიარდი
ბაიტი მეხსიერება ხელმისაწვდომია ჩემთვის

1159
00:54:25,640 --> 00:54:29,770
ან 8 მილიარდი ბიტი, მაგრამ ჩვენ ვაპირებთ
გაიგო თვალსაზრისით ბაიტი ახლა,

1160
00:54:29,770 --> 00:54:30,750
წინ მოძრაობა.

1161
00:54:30,750 --> 00:54:36,330
>> ასე რომ, იმას ნიშნავს, რომ ეს არის
ერთი ბაიტი, ეს არის კიდევ ერთი ბაიტი,

1162
00:54:36,330 --> 00:54:38,680
ეს არის კიდევ ერთი ბაიტი,
და თუ ჩვენ ნამდვილად სურდა

1163
00:54:38,680 --> 00:54:43,280
უნდა იყოს კონკრეტული, ჩვენ უნდა
მიაპყროს მილიარდი პატარა მოედნები.

1164
00:54:43,280 --> 00:54:44,320
მაგრამ რას ნიშნავს ეს?

1165
00:54:44,320 --> 00:54:46,420
ასევე, ნება მომეცით უბრალოდ მიუახლოვდით
წელს ამ სურათს.

1166
00:54:46,420 --> 00:54:50,900
თუ მაქვს, რომ რაღაც გამოიყურება
მოსწონს ეს ახლა, რომ ოთხი ბაიტი.

1167
00:54:50,900 --> 00:54:53,710
>> ასე რომ, მე ვერ დააყენა ოთხი ნომრები აქ.

1168
00:54:53,710 --> 00:54:54,990
ერთი ორი სამი ოთხი.

1169
00:54:54,990 --> 00:55:00,170
ან მე ვერ დააყენა ოთხი ასო ან სიმბოლო.

1170
00:55:00,170 --> 00:55:02,620
"Hey!" შეიძლება წავიდეს იქ,
იმიტომ, რომ თითოეული ასო,

1171
00:55:02,620 --> 00:55:04,370
ჩვენ განვიხილეთ ადრე,
შეიძლება წარმოდგენილი იყოს

1172
00:55:04,370 --> 00:55:06,650
რვა ბიტი და ASCII ან byte.

1173
00:55:06,650 --> 00:55:09,370
სხვა სიტყვებით, თქვენ შეგიძლიათ
ბოლო 8 მილიარდი რამ შიგნით

1174
00:55:09,370 --> 00:55:11,137
ამ ერთი ჯოხი მეხსიერება.

1175
00:55:11,137 --> 00:55:14,345
ახლა ეს რას ნიშნავს, რომ რამ უკან
თავში დაბრუნება მეხსიერებაში, როგორც ეს?

1176
00:55:14,345 --> 00:55:17,330
ეს არის ის, რაც პროგრამისტი
რომ დარეკოთ "მასივი".

1177
00:55:17,330 --> 00:55:21,250
კომპიუტერული პროგრამა, თქვენ არ ვფიქრობ
შესახებ ძირითადი აპარატურა, თავისთავად.

1178
00:55:21,250 --> 00:55:24,427
უბრალოდ ვფიქრობ თავს, როგორც
ხელმისაწვდომობის მილიარდი bytes სულ

1179
00:55:24,427 --> 00:55:26,010
და თქვენ შეგიძლიათ არაფერი გსურთ იგი.

1180
00:55:26,010 --> 00:55:27,880
მაგრამ მოხერხებულობის
ეს არის ზოგადად სასარგებლო

1181
00:55:27,880 --> 00:55:31,202
თქვენი მეხსიერება უფლება
შემდეგი ერთმანეთს მოსწონს ეს.

1182
00:55:31,202 --> 00:55:33,660
ასე რომ, თუ მე მიუახლოვდით ამ
იმიტომ, რომ ჩვენ, რა თქმა უნდა არ აპირებს

1183
00:55:33,660 --> 00:55:39,310
მიაპყროს მილიარდი პატარა squares--
მოდით ვივარაუდოთ, რომ ამ ფორუმში წარმოადგენს

1184
00:55:39,310 --> 00:55:40,610
რომ ჯოხი მეხსიერების ახლა.

1185
00:55:40,610 --> 00:55:43,800
და მე უბრალოდ მიაპყროს როგორც ბევრი როგორც ჩემი
marker მთავრდება მაძლევს აქ.

1186
00:55:43,800 --> 00:55:46,420

1187
00:55:46,420 --> 00:55:52,300
ახლა ჩვენ გვაქვს ჯოხი
მეხსიერების ფორუმში

1188
00:55:52,300 --> 00:55:56,400
რომ ერთი, ორი, სამი, ოთხი, ხუთი,
ექვსი, ერთი, ორი, სამი, ოთხი, ხუთი, ექვსი,

1189
00:55:56,400 --> 00:56:01,130
seven-- ასე 42 ბაიტი
მეხსიერების ეკრანზე სულ.

1190
00:56:01,130 --> 00:56:01,630
გმადლობთ.

1191
00:56:01,630 --> 00:56:02,838
დიახ, გავაკეთე არითმეტიკული უფლება.

1192
00:56:02,838 --> 00:56:05,120
ასე რომ, 42 ბაიტი მეხსიერება აქ.

1193
00:56:05,120 --> 00:56:06,660
ასე რომ, რას ნიშნავს რეალურად?

1194
00:56:06,660 --> 00:56:09,830
ისე, პროგრამისტად
რომ რეალურად ზოგადად

1195
00:56:09,830 --> 00:56:12,450
ვფიქრობ, ეს მეხსიერებაში, როგორც სამისამართო.

1196
00:56:12,450 --> 00:56:16,630
სხვა სიტყვებით, ყველა ერთი ასეთი
ადგილას მეხსიერება, ტექნიკა,

1197
00:56:16,630 --> 00:56:18,030
აქვს უნიკალური მისამართზე.

1198
00:56:18,030 --> 00:56:22,020
>> ეს არ არის ისეთი რთული, როგორც ერთ-ერთი brattle
მოედანზე, კემბრიჯის, Mass., 02138.

1199
00:56:22,020 --> 00:56:23,830
სამაგიეროდ, ეს მხოლოდ ნომერი.

1200
00:56:23,830 --> 00:56:27,930
ეს არის byte ხმების ნულოვანი, ეს არის
ერთი, ეს არის ორი, ეს არის სამი,

1201
00:56:27,930 --> 00:56:30,327
და ეს არის 41.

1202
00:56:30,327 --> 00:56:30,910
ერთი წუთი მაცადე.

1203
00:56:30,910 --> 00:56:32,510
ვფიქრობდი, 42 მომენტში წინ.

1204
00:56:32,510 --> 00:56:35,050

1205
00:56:35,050 --> 00:56:37,772
დავიწყე დათვლის დროს ნულოვანი,
ასე რომ, რეალურად სწორი.

1206
00:56:37,772 --> 00:56:40,980
ახლა ჩვენ არ უნდა დახატავდი მას
როგორც ქსელის, და თუ თქვენ მიაპყროს, როგორც ქსელის

1207
00:56:40,980 --> 00:56:43,520
მე ვფიქრობ, რამ რეალურად
კიდევ ცოტა შეცდომაში შეყვანას.

1208
00:56:43,520 --> 00:56:46,650
რა პროგრამისტი იქნებოდა,
მისი აზრით,

1209
00:56:46,650 --> 00:56:50,310
ზოგადად ვფიქრობ, ამ
მეხსიერება, ისევე, როგორც ფირზე,

1210
00:56:50,310 --> 00:56:53,340
როგორც ნაჭერი masking ფირზე
რომ მიდის და სამუდამოდ

1211
00:56:53,340 --> 00:56:54,980
ან სანამ ამოიწურა მეხსიერება.

1212
00:56:54,980 --> 00:56:59,200
ასე რომ, უფრო გავრცელებული გზა მიაპყროს
და უბრალოდ ვიფიქროთ მეხსიერება

1213
00:56:59,200 --> 00:57:03,710
იქნებოდა, რომ ეს არის byte ნულოვანი, ერთი,
ორი, სამი, და შემდეგ dot, dot, dot.

1214
00:57:03,710 --> 00:57:07,650
და თქვენ უნდა 42 ასეთი bytes სულ, მაშინაც კი,
მიუხედავად იმისა, რომ ფიზიკურად შეიძლება რეალურად

1215
00:57:07,650 --> 00:57:09,480
რაღაც უფრო მოსწონს ეს.

1216
00:57:09,480 --> 00:57:12,850
>> ასე რომ, თუ ახლა ვფიქრობ, რომ თქვენი
მეხსიერება, ეს, ისევე, როგორც ფირზე,

1217
00:57:12,850 --> 00:57:17,640
ეს არის ის, რაც პროგრამისტი ერთხელ
მინდა მოვუწოდო მასივი მეხსიერება.

1218
00:57:17,640 --> 00:57:20,660
და როცა მინდა, რომ რეალურად შესანახად
რაღაც კომპიუტერის მეხსიერებაში,

1219
00:57:20,660 --> 00:57:23,290
თქვენ ზოგადად მაღაზიაში რამ
უკან-to-back უკან-to-back.

1220
00:57:23,290 --> 00:57:25,010
ასე რომ, ჩვენ ვლაპარაკობდით ნომრები.

1221
00:57:25,010 --> 00:57:30,880
და როცა მინდოდა პრობლემების მოსაგვარებლად
როგორც ოთხი, ერთი, სამი, ორი,

1222
00:57:30,880 --> 00:57:33,820
მიუხედავად იმისა, რომ მე უბრალოდ ხატვის
მხოლოდ ნომრები ოთხი, ერთი, სამი,

1223
00:57:33,820 --> 00:57:39,490
ორი ფორუმში, კომპიუტერი
ნამდვილად აქვს ამ setup მეხსიერებაში.

1224
00:57:39,490 --> 00:57:43,347
>> და რა იქნება შემდეგი
ორი კომპიუტერის მეხსიერებაში?

1225
00:57:43,347 --> 00:57:44,680
ასევე, არ არსებობს პასუხი რომ.

1226
00:57:44,680 --> 00:57:45,770
ჩვენ ნამდვილად არ ვიცი.

1227
00:57:45,770 --> 00:57:48,200
ასე რომ, სანამ
კომპიუტერი არ სჭირდება,

1228
00:57:48,200 --> 00:57:51,440
ეს არ უნდა იზრუნოს რა არის შემდეგი
ნომრები, რომ ეს არ აინტერესებს.

1229
00:57:51,440 --> 00:57:55,130
და როცა განაცხადა, რომ კომპიუტერი
შეიძლება მხოლოდ შევხედოთ ერთი მისამართი დროს,

1230
00:57:55,130 --> 00:57:56,170
ეს არის ერთგვარი რატომ.

1231
00:57:56,170 --> 00:57:59,490
>> არ არის განსხვავებით ჩანაწერი
მოთამაშე და კითხულობს უფროსი

1232
00:57:59,490 --> 00:58:03,030
მხოლოდ მას შეუძლია შევხედოთ გარკვეული
groove ფიზიკური ძველი სკოლა ჩანაწერი

1233
00:58:03,030 --> 00:58:06,500
იმ დროს, ასევე
შეუძლია კომპიუტერის მადლობა

1234
00:58:06,500 --> 00:58:09,810
მისი CPU და მისი
Intel ინსტრუქციის კომპლექტი,

1235
00:58:09,810 --> 00:58:12,480
შორის, რომლის მითითების
წაკითხვის მეხსიერების

1236
00:58:12,480 --> 00:58:15,590
ან შენახვა memory--
კომპიუტერი შეიძლება მხოლოდ გამოიყურება

1237
00:58:15,590 --> 00:58:19,210
ერთ ადგილმდებარეობა გამართულ time--
ზოგჯერ კომბინაცია მათ,

1238
00:58:19,210 --> 00:58:21,770
მაგრამ რეალურად მხოლოდ ერთ ადგილას დროს.

1239
00:58:21,770 --> 00:58:24,770
ასე რომ, როცა ვაკეთებდით
ამ სხვადასხვა ალგორითმები,

1240
00:58:24,770 --> 00:58:28,110
მე არა მხოლოდ წერა
vacuum-- ოთხი, ერთი, სამი, ორი.

1241
00:58:28,110 --> 00:58:30,849
ეს ციფრები რეალურად ეკუთვნის
სადღაც ფიზიკური მეხსიერებაში.

1242
00:58:30,849 --> 00:58:32,890
ასე რომ, არსებობს პატარა
ტრანზისტორი ან რაიმე სახის

1243
00:58:32,890 --> 00:58:35,840
ელექტრონიკა ქვეშ
hood შენახვის ამ ღირებულებებს.

1244
00:58:35,840 --> 00:58:40,460
>> და სულ რამდენი ბიტი
ჩართული ახლა, უბრალოდ უნდა იყოს მკაფიო?

1245
00:58:40,460 --> 00:58:45,580
ასე რომ, ეს არის ოთხი ბაიტი, ან
ახლა ის 32 ბიტი სულ.

1246
00:58:45,580 --> 00:58:49,280
ასე რომ, არსებობს 32 zeros და
პირობა საკომპოზიტორო ამ ოთხი რამ.

1247
00:58:49,280 --> 00:58:52,070
იქ კიდევ უფრო მეტი აქ, მაგრამ
ერთხელ ჩვენ არ გვაღელვებს.

1248
00:58:52,070 --> 00:58:55,120
>> ახლა მოდით ვთხოვო სხვა
კითხვა გამოყენებით მეხსიერება,

1249
00:58:55,120 --> 00:58:57,519
იმიტომ, რომ ბოლოს
დღის არის ეწინააღმდეგება.

1250
00:58:57,519 --> 00:59:00,310
არ აქვს მნიშვნელობა რა შეიძლება გავაკეთოთ ერთად
კომპიუტერი, ბოლოს დღეს

1251
00:59:00,310 --> 00:59:02,560
აპარატურა არის კიდევ
იგივე ქვეშ hood.

1252
00:59:02,560 --> 00:59:04,670
როგორ მე შესანახად სიტყვა აქ?

1253
00:59:04,670 --> 00:59:09,710
ისე, სიტყვა კომპიუტერის
"Hey!" იქნება შენახული, ისევე, როგორც ეს.

1254
00:59:09,710 --> 00:59:12,300
და თუ უნდოდა აღარ
სიტყვა, შეგიძლიათ უბრალოდ

1255
00:59:12,300 --> 00:59:19,120
გადაწერა, რომ და აცხადებენ, რომ
როგორც "Hello" და მაღაზია რომ აქ.

1256
00:59:19,120 --> 00:59:23,930
>> ასე რომ, აქ, ძალიან, ეს contiguousness
არის რეალურად უპირატესობა,

1257
00:59:23,930 --> 00:59:26,530
იმიტომ, რომ კომპიუტერი შეიძლება მხოლოდ
წაკითხვის უფლება მარცხენა.

1258
00:59:26,530 --> 00:59:28,680
მაგრამ აქ არის შეკითხვა.

1259
00:59:28,680 --> 00:59:33,480
ამ კონტექსტში ეს სიტყვა,
თ-ე-ლ-l-o, ძახილის წერტილი,

1260
00:59:33,480 --> 00:59:38,740
როგორ შეიძლება კომპიუტერის ვიცი, სადაც
სიტყვა იწყება და სადაც სიტყვა მთავრდება?

1261
00:59:38,740 --> 00:59:41,690

1262
00:59:41,690 --> 00:59:43,800
კონტექსტში ნომრები,
რა კომპიუტერი

1263
00:59:43,800 --> 00:59:48,396
ვიცი, რამდენ ხანს თანმიმდევრობა
ნომრები არის ან სად იწყება?

1264
00:59:48,396 --> 00:59:50,270
ასევე, თურმე out--
და ჩვენ არ წავიდეთ ძალიან ბევრი

1265
00:59:50,270 --> 00:59:54,970
ამ დონის detail--
კომპიუტერები გადაადგილება პერსონალის გარშემო მეხსიერება

1266
00:59:54,970 --> 00:59:57,800
ფაქტიურად გზით ამ მისამართები.

1267
00:59:57,800 --> 01:00:02,080
ასე რომ, კომპიუტერი, თუ თქვენ
წერა კოდი შესანახად რამ

1268
01:00:02,080 --> 01:00:05,800
როგორიცაა სიტყვა, რაც თქვენ
ნამდვილად აკეთებს აკრეფით

1269
01:00:05,800 --> 01:00:11,320
გამოთქმები, რომ მახსოვს, სადაც
კომპიუტერის მეხსიერებაში ეს სიტყვები.

1270
01:00:11,320 --> 01:00:14,370
ნება მომეცით, ამის გაკეთება ძალიან,
ძალიან მარტივი მაგალითი.

1271
01:00:14,370 --> 01:00:18,260
>> მე ვაპირებ წავიდეთ წინ და
გახსენით უბრალო ტექსტური პროგრამა,

1272
01:00:18,260 --> 01:00:20,330
და მე ვაპირებ, რომ შევქმნათ
ფაილი სახელად hello.c.

1273
01:00:20,330 --> 01:00:22,849
ყველაზე ამ ინფორმაციას ჩვენ
არ წასვლას დიდი დეტალურად,

1274
01:00:22,849 --> 01:00:25,140
მაგრამ მე ვაპირებ დაწერა
პროგრამა, რომ ერთსა და იმავე ენაზე,

1275
01:00:25,140 --> 01:00:31,140
C. ეს არის ბევრად უფრო დაშინებას,
მე ვიტყოდი, რომ, ვიდრე Scratch,

1276
01:00:31,140 --> 01:00:32,490
მაგრამ ეს ძალიან გავს სულითა.

1277
01:00:32,490 --> 01:00:34,364
ფაქტობრივად, ეს curly
აფრთხილებს შეგიძლიათ სახის

1278
01:00:34,364 --> 01:00:37,820
ვფიქრობ, თუ რა მე უბრალოდ, როგორც ეს.

1279
01:00:37,820 --> 01:00:39,240
>> მოდით ეს, ფაქტობრივად.

1280
01:00:39,240 --> 01:00:45,100
როდესაც მწვანე დროშა დააწკაპებთ,
ამის შემდეგ.

1281
01:00:45,100 --> 01:00:50,210
მინდა ამობეჭდოთ "Hello".

1282
01:00:50,210 --> 01:00:51,500
ასე რომ, ეს არის pseudocode.

1283
01:00:51,500 --> 01:00:53,000
მე სახის ბუნდოვანი ხაზები.

1284
01:00:53,000 --> 01:00:56,750
C, ამ ენის ვსაუბრობ
შესახებ, ამ ხაზის ბეჭდვა hello

1285
01:00:56,750 --> 01:01:01,940
რეალურად ხდება "printf" ერთად
ზოგიერთი ფრჩხილებში და ნახევრად მსხვილი ნაწლავის.

1286
01:01:01,940 --> 01:01:03,480
>> მაგრამ ეს ზუსტად იგივე იდეა.

1287
01:01:03,480 --> 01:01:06,730
და ეს ძალიან მოსახერხებელი
"როდესაც მწვანე დროშის დაწკაპავთ" ხდება

1288
01:01:06,730 --> 01:01:10,182
ბევრად უფრო arcane "int ძირითადი ბათილად."

1289
01:01:10,182 --> 01:01:12,890
და ეს ნამდვილად არ აქვს რუკების,
ასე რომ, მე უბრალოდ აპირებს იგნორირება, რომ.

1290
01:01:12,890 --> 01:01:17,210
მაგრამ curly აფრთხილებს, როგორიცაა
curved თავსატეხი ცალი მოსწონს ეს.

1291
01:01:17,210 --> 01:01:18,700
>> ასე რომ თქვენ შეგიძლიათ სახის ვხვდები.

1292
01:01:18,700 --> 01:01:22,357
მაშინაც კი, თუ თქვენ არასდროს დაპროგრამებულია ადრე,
რას ამ პროგრამის ალბათ?

1293
01:01:22,357 --> 01:01:25,560

1294
01:01:25,560 --> 01:01:28,000
ალბათ ბეჭდავს კომენტარი
ძახილის წერტილი.

1295
01:01:28,000 --> 01:01:29,150
>> მოდით ვეცადოთ, რომ.

1296
01:01:29,150 --> 01:01:30,800
მე ვაპირებ გადარჩენა იგი.

1297
01:01:30,800 --> 01:01:34,000
და ეს არის, კიდევ ერთხელ, ძალიან
ძველი სკოლა გარემო.

1298
01:01:34,000 --> 01:01:35,420
მე ვერ დააჭირეთ, მე ვერ გადაიტანეთ.

1299
01:01:35,420 --> 01:01:36,910
მე უნდა აკრიფოთ ბრძანებები.

1300
01:01:36,910 --> 01:01:41,320
ამიტომ, მე მინდა, რომ აწარმოებს ჩემი პროგრამა, ასე
მე შეიძლება ამის გაკეთება, როგორც hello.c.

1301
01:01:41,320 --> 01:01:42,292
ეს ფაილი, მე გაიქცა.

1302
01:01:42,292 --> 01:01:43,500
მაგრამ დაველოდოთ, მე დაკარგული ნაბიჯი.

1303
01:01:43,500 --> 01:01:46,470
რა ვამბობთ, არის აუცილებელი
ნაბიჯი ენა, როგორიცაა C?

1304
01:01:46,470 --> 01:01:49,470
მე მხოლოდ წერილობითი წყარო
კოდი, მაგრამ, რა უნდა?

1305
01:01:49,470 --> 01:01:50,670
ჰო, მე უნდა შემდგენელი.

1306
01:01:50,670 --> 01:01:57,670
ასე რომ, ჩემს Mac აქ, მაქვს
პროგრამა მოუწოდა GCC, GNU C შემდგენელი,

1307
01:01:57,670 --> 01:02:03,990
რომელიც საშუალებას აძლევს ჩემთვის ამას, თავის მხრივ,
ჩემი კოდის, ჩვენ მოვუწოდებთ მას,

1308
01:02:03,990 --> 01:02:04,930
მანქანა კოდი.

1309
01:02:04,930 --> 01:02:10,180
>> და მე ვხედავ, რომ,
ერთხელ, ასეთია, ამ

1310
01:02:10,180 --> 01:02:14,090
არიან zeros და პირობა უბრალოდ
შეიქმნა ჩემი წყარო კოდი

1311
01:02:14,090 --> 01:02:15,730
ყველა zeros და პირობა.

1312
01:02:15,730 --> 01:02:17,770
და თუ მინდა აწარმოებს
ჩემი პროგრამაში ხდება,

1313
01:02:17,770 --> 01:02:23,010
ეწოდოს a.out for
ისტორიული reasons-- "Hello".

1314
01:02:23,010 --> 01:02:24,070
შემიძლია გაუშვით ერთხელ.

1315
01:02:24,070 --> 01:02:25,690
გამარჯობა გამარჯობა გამარჯობა.

1316
01:02:25,690 --> 01:02:27,430
და, როგორც ჩანს, სამუშაო.

1317
01:02:27,430 --> 01:02:31,000
>> მაგრამ ეს ნიშნავს, სადღაც ჩემი
კომპიუტერის მეხსიერებაში არის სიტყვა

1318
01:02:31,000 --> 01:02:35,279
თ-ე-ლ-l-o, ძახილის წერტილი.

1319
01:02:35,279 --> 01:02:38,070
და აღმოჩნდება, ისევე, როგორც განზე,
რა კომპიუტერი, როგორც წესი,

1320
01:02:38,070 --> 01:02:40,550
ასე, რომ იცის, სადაც
რამ დაიწყება და end-- ეს

1321
01:02:40,550 --> 01:02:42,460
აპირებს დააყენოს სპეციალური სიმბოლო აქ.

1322
01:02:42,460 --> 01:02:46,064
და კონვენცია არის იმისათვის, რომ
ხმების ნულოვანი ბოლოს სიტყვა

1323
01:02:46,064 --> 01:02:48,230
ასე რომ თქვენ იცით, სადაც იგი
რეალურად მთავრდება, ასე რომ თქვენ

1324
01:02:48,230 --> 01:02:52,750
არ შეინარჩუნოს ბეჭდვის უფრო და უფრო
პერსონაჟი, ვიდრე თქვენ რეალურად აპირებს.

1325
01:02:52,750 --> 01:02:55,400
>> მაგრამ takeaway აქ, მაშინაც კი,
მიუხედავად იმისა, რომ ეს არის საკმაოდ arcane,

1326
01:02:55,400 --> 01:02:58,140
არის ის, რომ, საბოლოო ჯამში,
შედარებით მარტივი.

1327
01:02:58,140 --> 01:03:04,550
თქვენ გადაეცათ ერთგვარი ფირზე, ცარიელი
სივრცე, სადაც შეგიძლიათ წერენ წერილებს.

1328
01:03:04,550 --> 01:03:07,150
თქვენ უბრალოდ უნდა ჰქონდეს
სპეციალური სიმბოლო, როგორც თვითნებურად

1329
01:03:07,150 --> 01:03:10,316
ხმების ნულოვანი, იმისათვის, რომ ბოლოს
თქვენი სიტყვები, ასე რომ კომპიუტერი იცის,

1330
01:03:10,316 --> 01:03:13,410
oh, მე უნდა შეწყვიტოს ბეჭდვის შემდეგ
მე ვხედავ ძახილის წერტილი.

1331
01:03:13,410 --> 01:03:16,090
იმის გამო, რომ შემდეგი რამ არ
არის ASCII ღირებულება ნულოვანი,

1332
01:03:16,090 --> 01:03:19,125
ან null ხასიათი, როგორც
ვინმეს ეძახით.

1333
01:03:19,125 --> 01:03:21,500
მაგრამ არსებობს ასეთი პრობლემა
აქ და მოდით აღადგინოთ უკან

1334
01:03:21,500 --> 01:03:23,320
ნომრები მომენტში.

1335
01:03:23,320 --> 01:03:28,720
დავუშვათ, რომ მე, ფაქტობრივად,
მასივი ნომრები,

1336
01:03:28,720 --> 01:03:30,730
და ვარაუდობენ, რომ
პროგრამის მე წერა არის

1337
01:03:30,730 --> 01:03:34,680
მოსწონს კლასის წიგნი მასწავლებლის
და მასწავლებელი კლასის.

1338
01:03:34,680 --> 01:03:38,720
ეს პროგრამა საშუალებას აძლევს მას
ჩაწერეთ მოსწავლეების ქულები

1339
01:03:38,720 --> 01:03:39,960
შესახებ ვიქტორინებში.

1340
01:03:39,960 --> 01:03:43,750
და ვფიქრობ, რომ სტუდენტი მიიღებს
100 მათი ინტელექტუალური, შესაძლოა,

1341
01:03:43,750 --> 01:03:49,920
როგორც 80 წლის შემდეგ, მაშინ
75, მაშინ 90 წლის მეოთხე ვიქტორინა.

1342
01:03:49,920 --> 01:03:54,150
>> ამრიგად, ამ ეტაპზე იმ ამბავს,
მასივი ზომა ოთხ.

1343
01:03:54,150 --> 01:03:58,470
იქ აბსოლუტურად მეტი მეხსიერების
კომპიუტერი, მაგრამ მასივი, ასე ვთქვათ,

1344
01:03:58,470 --> 01:04:00,350
არის ზომა ოთხ.

1345
01:04:00,350 --> 01:04:06,060
ვარაუდობენ, რომ მასწავლებელი სურს
მივანიჭოთ მეხუთე ინტელექტუალური კლასი.

1346
01:04:06,060 --> 01:04:08,510
ისე, ერთი რამ, ის
და იგი აპირებს უნდა გავაკეთოთ

1347
01:04:08,510 --> 01:04:10,650
ახლა შესანახად დამატებითი ღირებულების აქ.

1348
01:04:10,650 --> 01:04:15,490
მაგრამ თუ მასივში პედაგოგი
შექმნა ამ პროგრამაში, ზომა,

1349
01:04:15,490 --> 01:04:22,440
ერთ-ერთი პრობლემა მასივი, რომ
თქვენ არ შეგიძლიათ უბრალოდ შეინახოს დასძინა ხსოვნას.

1350
01:04:22,440 --> 01:04:26,470
რადგან რა, თუ მეორე ნაწილი
პროგრამას აქვს სიტყვა "hey" უფლება არსებობს?

1351
01:04:26,470 --> 01:04:29,650
>> სხვა სიტყვებით, ჩემი მეხსიერება შეიძლება იყოს
გამოიყენება არაფერი პროგრამა.

1352
01:04:29,650 --> 01:04:33,250
და თუ წინასწარ მე აკრეფილი, hey,
მინდა შეყვანის ოთხი Quiz ქულით,

1353
01:04:33,250 --> 01:04:34,784
მათ შეიძლება წავიდეთ აქ და აქ.

1354
01:04:34,784 --> 01:04:37,700
და თუ თქვენ მოულოდნელად შეიცვალოს თქვენი აზრით
მოგვიანებით და ვთქვათ მე მინდა მეხუთე ვიქტორინა

1355
01:04:37,700 --> 01:04:40,872
ანგარიში, თქვენ შეგიძლიათ არა მხოლოდ
განათავსოთ სადაც გსურთ,

1356
01:04:40,872 --> 01:04:42,580
იმიტომ, რომ თუ ეს
მეხსიერების გამოიყენება

1357
01:04:42,580 --> 01:04:45,990
რაღაც else-- სხვა პროგრამა
ან სხვა თვისება პროგრამა

1358
01:04:45,990 --> 01:04:46,910
რომ თქვენ გაშვებული?

1359
01:04:46,910 --> 01:04:50,650
ასე რომ თქვენ უნდა ვიფიქროთ წინასწარ
როგორ გსურთ შეინახოთ თქვენი მონაცემები,

1360
01:04:50,650 --> 01:04:54,480
რადგან ახლა თქვენ მოხატული
თავს შევიდა ციფრული კუთხეში.

1361
01:04:54,480 --> 01:04:57,280
>> ასე რომ, პედაგოგი პირიქით,
ამბობენ, როდესაც წერილობით პროგრამა

1362
01:04:57,280 --> 01:04:59,360
შესანახად მისი
შეფასება, იცით, რა?

1363
01:04:59,360 --> 01:05:04,180
ვაპირებ მოითხოვოს,
როდესაც წერა ჩემი პროგრამა,

1364
01:05:04,180 --> 01:05:12,070
რომ მე მინდა ნულოვანი, ერთი, ორი, სამი,
ოთხი, ხუთი, ექვსი, რვა შეფასება საერთო.

1365
01:05:12,070 --> 01:05:15,320
ასე რომ, ერთი, ორი, სამი, ოთხი,
ხუთი, ექვსი, შვიდი, რვა.

1366
01:05:15,320 --> 01:05:18,612
მასწავლებელს შეუძლია უბრალოდ ზედმეტად გამოყოფს
მეხსიერების როდესაც წერილობით მისი პროგრამა

1367
01:05:18,612 --> 01:05:19,570
და ამბობენ, იცით, რა?

1368
01:05:19,570 --> 01:05:22,236
მე არასდროს დაავალოს მეტი
ვიდრე რვა ტესტებში სემესტრში.

1369
01:05:22,236 --> 01:05:23,130
ეს არის მხოლოდ გიჟები.

1370
01:05:23,130 --> 01:05:24,470
მე არასოდეს გამოყოფს, რომ.

1371
01:05:24,470 --> 01:05:28,270
ასე რომ, ამ გზით მას აქვს
მოქნილობა მაღაზია სტუდენტი ქულა,

1372
01:05:28,270 --> 01:05:33,010
მოსწონს 75, 90, და, შესაძლოა, ერთი ზედმეტი, სადაც
მოსწავლემ დამატებითი საკრედიტო, 105.

1373
01:05:33,010 --> 01:05:36,130
>> მაგრამ, თუ მასწავლებელი არ
იყენებს ამ სამი ფართები,

1374
01:05:36,130 --> 01:05:38,860
იქ ინტუიციური takeaway აქ.

1375
01:05:38,860 --> 01:05:41,410
იგი უბრალოდ დროის გაყვანაა სივრცეში.

1376
01:05:41,410 --> 01:05:44,790
ასე რომ, სხვა სიტყვებით, არ არის ეს
საერთო tradeoff პროგრამირებაში

1377
01:05:44,790 --> 01:05:48,241
სადაც შეგიძლიათ გამოყოფს
ზუსტად იმდენი მეხსიერება, როგორც გსურთ,

1378
01:05:48,241 --> 01:05:51,490
თავდაყირა, რომელიც არის ის, რომ თქვენ სუპერ
efficient-- თქვენ არ მიმდინარეობს არარაციონალური

1379
01:05:51,490 --> 01:05:54,640
at ყველა მაგრამ downside რომლის
არის რა, თუ თქვენ შეცვლის თქვენი გონება, როდესაც

1380
01:05:54,640 --> 01:05:58,780
გამოყენებით პროგრამა, რომელიც გსურთ შეინახოთ
მეტი მონაცემები, ვიდრე თქვენ თავდაპირველად გამიზნული.

1381
01:05:58,780 --> 01:06:03,030
>> ასე რომ, შესაძლოა გამოსავალი არის, მაშინ,
დაწერეთ თქვენი პროგრამები იმგვარად

1382
01:06:03,030 --> 01:06:05,605
რომ ისინი იყენებენ უფრო მეტი მეხსიერება
ვიდრე სინამდვილეში გვჭირდება.

1383
01:06:05,605 --> 01:06:07,730
ამ გზით თქვენ არ აპირებს
გადაეყარონ, რომ პრობლემა,

1384
01:06:07,730 --> 01:06:09,730
მაგრამ თქვენ, რომ ფუჭია და უსარგებლო.

1385
01:06:09,730 --> 01:06:12,960
და მეტი მეხსიერების თქვენი პროგრამა იყენებს,
როგორც ჩვენ განვიხილეთ გუშინ, ნაკლებად

1386
01:06:12,960 --> 01:06:15,410
მეხსიერება, რომელიც არ არის შესაძლებელი
სხვა პროგრამებს,

1387
01:06:15,410 --> 01:06:18,790
მით უფრო რომ თქვენი კომპიუტერი შეიძლება ნელი
ქვემოთ გამო ვირტუალური მეხსიერება.

1388
01:06:18,790 --> 01:06:22,670
ასე რომ, იდეალური გადაწყვეტა შეიძლება იყოს რა?

1389
01:06:22,670 --> 01:06:24,610
>> Under-გამოყოფისას ჩანს ცუდი.

1390
01:06:24,610 --> 01:06:27,030
Over-გამოყოფისას ჩანს ცუდი.

1391
01:06:27,030 --> 01:06:31,120
ასე რომ, რა შეიძლება იყოს უკეთესი?

1392
01:06:31,120 --> 01:06:32,390
გადანაწილება.

1393
01:06:32,390 --> 01:06:33,590
უფრო დინამიური იქნება.

1394
01:06:33,590 --> 01:06:37,520
არ აიძულოს თავს აირჩიოს
აპრიორი, დასაწყისში, რაც გსურთ.

1395
01:06:37,520 --> 01:06:41,370
და რა თქმა უნდა, არა ზედმეტად გამოყოფს,
მცირეოდენ თქვენ უნდა wasteful.

1396
01:06:41,370 --> 01:06:45,770
>> ასე რომ, ამ მიზნის მისაღწევად, ჩვენ
საჭიროა იმისათვის, რომ ამ მონაცემების სტრუქტურას,

1397
01:06:45,770 --> 01:06:48,100
ასე ვთქვათ, მოშორებით.

1398
01:06:48,100 --> 01:06:51,080
ასე რომ, რა პროგრამისტი
როგორც წესი, იყენებენ

1399
01:06:51,080 --> 01:06:55,940
არის რაღაც მოუწოდა არ არის
მასივი, მაგრამ უკავშირდება სიაში.

1400
01:06:55,940 --> 01:07:00,860
სხვა სიტყვებით, იგი
დავიწყოთ ფიქრი მათი მეხსიერება

1401
01:07:00,860 --> 01:07:05,280
როგორც სახის ფორმა, რომელიც მათ
შეგიძლიათ დახაზოთ შემდეგ გზა.

1402
01:07:05,280 --> 01:07:08,520
თუ მინდა შესანახად ერთი ნომერი
პროგრამაში ასე რომ, სექტემბერი,

1403
01:07:08,520 --> 01:07:12,600
მეც გავაკეთე სტუდენტები ვიქტორინა; მე მინდა
შესანახად სტუდენტთა ინტელექტუალური,

1404
01:07:12,600 --> 01:07:16,220
და მიიღეს 100 it-- I
ვაპირებ ვკითხო ჩემი კომპიუტერი,

1405
01:07:16,220 --> 01:07:19,540
გზით პროგრამის მე
დაწერილი, ერთი ბლოკი მეხსიერება.

1406
01:07:19,540 --> 01:07:22,570
და მე ვაპირებ შესანახად
ნომერი 100, და ეს არის ის.

1407
01:07:22,570 --> 01:07:24,820
>> შემდეგ რამდენიმე კვირის შემდეგ
როდესაც ჩემს მეორე ვიქტორინა,

1408
01:07:24,820 --> 01:07:27,890
და დროა აკრიფოთ
იმ 90%, მე ვაპირებ

1409
01:07:27,890 --> 01:07:32,129
ვთხოვო კომპიუტერი, hey, კომპიუტერი,
შეიძლება მე მაქვს კიდევ ერთი ბლოკი მეხსიერება?

1410
01:07:32,129 --> 01:07:34,170
ის აპირებს მომეცი ამ
ცარიელი ბლოკი მეხსიერება.

1411
01:07:34,170 --> 01:07:39,370
მე ვაპირებ დააყენა ნომერი 90,
მაგრამ, ჩემი პროგრამა რატომღაც ან other--

1412
01:07:39,370 --> 01:07:42,100
და ჩვენ არ აღელვებს
სინტაქსი ამას მე უნდა

1413
01:07:42,100 --> 01:07:44,430
როგორმე ჯაჭვის ეს ყველაფერი ერთად.

1414
01:07:44,430 --> 01:07:47,430
და მე ჯაჭვის მათ ერთად
რა ჰგავს ისარი აქ.

1415
01:07:47,430 --> 01:07:50,050
>> მესამე ვიქტორინა, რომელიც მოდის,
მე ვაპირებ ვთქვა, hey, კომპიუტერი,

1416
01:07:50,050 --> 01:07:51,680
მომეცი კიდევ ერთი ბლოკი მეხსიერება.

1417
01:07:51,680 --> 01:07:54,660
და მე ვაპირებ ჩასახშობად
რაც არ იყო, ისევე, როგორც 75,

1418
01:07:54,660 --> 01:07:56,920
და მე უნდა ჯაჭვის ამ
ერთად ახლა რატომღაც.

1419
01:07:56,920 --> 01:08:00,290
მეოთხე ინტელექტუალური მოდის, და, შესაძლოა,
რომ ის მიმართ სემესტრის ბოლოს.

1420
01:08:00,290 --> 01:08:03,140
და რომ წერტილი ჩემი პროგრამა
შეიძლება იყოს გამოყენებით მეხსიერება

1421
01:08:03,140 --> 01:08:05,540
მთელი ადგილი, მთელი ფიზიკურად.

1422
01:08:05,540 --> 01:08:08,170
ასე რომ, მხოლოდ ჩათვლით, მე
ვაპირებ შევაჩერო ამ მეოთხე

1423
01:08:08,170 --> 01:08:11,260
quiz-- მე დაგვავიწყდეს, რა იყო ეს; მე
ვფიქრობ, იქნებ 80 ან რაღაც

1424
01:08:11,260 --> 01:08:12,500
გზა აქ.

1425
01:08:12,500 --> 01:08:15,920
>> მაგრამ ეს ჯარიმა, რადგან ხატოვნად
მე ვაპირებ შევაჩერო ეს ხაზი.

1426
01:08:15,920 --> 01:08:19,063
სხვა სიტყვებით, სინამდვილეში,
თქვენი კომპიუტერის ტექნიკა,

1427
01:08:19,063 --> 01:08:20,979
პირველი ანგარიშით შეიძლება
დასრულდება მდე აქ იმიტომ, რომ ეს

1428
01:08:20,979 --> 01:08:22,529
უფლება დაწყების სემესტრში.

1429
01:08:22,529 --> 01:08:25,810
შემდეგი შეიძლება დასრულდება მდე აქ
იმიტომ, რომ ცოტა დრო გავიდა

1430
01:08:25,810 --> 01:08:27,210
და პროგრამა ინახავს გაშვებული.

1431
01:08:27,210 --> 01:08:30,060
შემდეგი ანგარიშით, რომელიც იყო
75, შეიძლება იყოს აქ.

1432
01:08:30,060 --> 01:08:33,420
და ბოლოს, ანგარიში შეიძლება იყოს
80, რომელიც აქ.

1433
01:08:33,420 --> 01:08:38,729
>> ასე რომ, რეალურად, ფიზიკურად, ეს შეიძლება იყოს
რა თქვენი კომპიუტერის მეხსიერების ჰგავს.

1434
01:08:38,729 --> 01:08:41,569
მაგრამ ეს არ არის სასარგებლო ფსიქიკური
პარადიგმა კომპიუტერის პროგრამისტი.

1435
01:08:41,569 --> 01:08:44,649
რატომ უნდა იზრუნოს, სადაც
heck თქვენი მონაცემები დამთავრებული?

1436
01:08:44,649 --> 01:08:46,200
თქვენ უბრალოდ უნდა ჩაწეროთ მონაცემები.

1437
01:08:46,200 --> 01:08:49,390
>> ეს არის სახის მოსწონს ჩვენი დისკუსია
ადრე ხატვის კუბი.

1438
01:08:49,390 --> 01:08:52,200
რატომ აინტერესებს, თუ რა
კუთხე კუბი

1439
01:08:52,200 --> 01:08:53,740
და როგორ უნდა მივმართოთ მიაპყროს ეს?

1440
01:08:53,740 --> 01:08:54,950
უბრალოდ კუბი.

1441
01:08:54,950 --> 01:08:57,359
ანალოგიურად აქ, თქვენ
უბრალოდ მინდა, რომ კლასის წიგნში.

1442
01:08:57,359 --> 01:08:59,559
თქვენ უბრალოდ უნდა ვიფიქროთ,
ეს, როგორც სიაში ნომრები.

1443
01:08:59,559 --> 01:09:01,350
ვინ ზრუნავს, თუ როგორ ეს
განხორციელებული ტექნიკა?

1444
01:09:01,350 --> 01:09:05,180
>> ასე რომ, აბსტრაქცია ახლა
ეს სურათი აქ.

1445
01:09:05,180 --> 01:09:07,580
ეს არის უკავშირდება სიაში, როგორც
პროგრამისტი მოვუწოდებთ,

1446
01:09:07,580 --> 01:09:10,640
იმდენად, რამდენადაც თქვენ გაქვთ
სია, ცხადია, ნომრები.

1447
01:09:10,640 --> 01:09:14,990
მაგრამ ეს უკავშირდება ხატოვნად
გზით ამ ისრებით,

1448
01:09:14,990 --> 01:09:18,510
და ყველა ამ ისრებით are-- ქვეშ
hood, თუ თქვენ აინტერესებს,

1449
01:09:18,510 --> 01:09:23,210
გავიხსენოთ, რომ ჩვენი ფიზიკური ტექნიკის
მისამართები ნულოვანი, ერთი, ორი, სამი, ოთხი.

1450
01:09:23,210 --> 01:09:28,465
ყველა ამ ისრებით ჰგავს რუკა
ან მიმართულებით, სადაც, თუ 90 is-- ახლა

1451
01:09:28,465 --> 01:09:29,090
მე მივიღე ითვლიან.

1452
01:09:29,090 --> 01:09:31,750
>> ნულოვანი, ერთი, ორი, სამი,
ოთხი, ხუთი, ექვსი, შვიდი.

1453
01:09:31,750 --> 01:09:35,640
როგორც ჩანს, 90 საათზე
მეხსიერების მისამართი ნომერი შვიდი.

1454
01:09:35,640 --> 01:09:38,460
ყველა ამ ისრებით არის
როგორც პატარა ჯართი ქაღალდი

1455
01:09:38,460 --> 01:09:42,439
რომ აძლევდა
პროგრამა, რომელიც ამბობს დაიცვას ეს რუკა

1456
01:09:42,439 --> 01:09:43,880
მისაღებად ადგილმდებარეობა შვიდი.

1457
01:09:43,880 --> 01:09:46,680
და იქ თქვენ იხილავთ
სტუდენტის მეორე ვიქტორინა ანგარიში.

1458
01:09:46,680 --> 01:09:52,100
იმავდროულად, 75-- თუ მე გააგრძელებს,
ეს არის შვიდი, რვა, ცხრა, 10, 11, 12,

1459
01:09:52,100 --> 01:09:54,240
13, 14, 15.

1460
01:09:54,240 --> 01:09:59,080
>> ეს სხვა arrow უბრალოდ წარმოადგენს
რუკაზე მეხსიერების 15.

1461
01:09:59,080 --> 01:10:02,550
მაგრამ ერთხელ, პროგრამისტი საერთოდ
არ აინტერესებს ამ დონის დეტალურად.

1462
01:10:02,550 --> 01:10:05,530
და საუკეთესო ყველა პროგრამირების
ენის დღეს, პროგრამისტი

1463
01:10:05,530 --> 01:10:10,490
კი არ ვიცი, სადაც მეხსიერება
ეს ციფრები რეალურად არიან.

1464
01:10:10,490 --> 01:10:14,830
ყველა მას უნდა ზრუნავდეს არის
რომ ისინი როგორმე გაერთიანებულს

1465
01:10:14,830 --> 01:10:18,390
მონაცემები სტრუქტურა მოსწონს ეს.

1466
01:10:18,390 --> 01:10:21,580
>> მაგრამ აღმოჩნდება, რომ არ
მიიღოთ ძალიან ტექნიკური.

1467
01:10:21,580 --> 01:10:27,430
მაგრამ მხოლოდ იმიტომ, რომ ჩვენ, ალბათ,
საშუალება აქვს ეს განხილვა აქ,

1468
01:10:27,430 --> 01:10:33,630
ვარაუდობენ, რომ ჩვენ დავუბრუნდეთ
ეს საკითხი აქ მასივი.

1469
01:10:33,630 --> 01:10:35,780
მოდით ვნახოთ, თუ ჩვენ ვწუხვართ აპირებს აქ.

1470
01:10:35,780 --> 01:10:42,950
ეს არის 100, 90, 75, 80.

1471
01:10:42,950 --> 01:10:44,980
>> მომეცით, მოკლედ, რომ ეს სარჩელი.

1472
01:10:44,980 --> 01:10:48,980
ეს არის მასივი, და კიდევ ერთხელ,
გახმაურებული დამახასიათებელი მასივი

1473
01:10:48,980 --> 01:10:52,400
ის არის, რომ ყველა თქვენი მონაცემები დაბრუნდა
უკან უკან memory-- ფაქტიურად

1474
01:10:52,400 --> 01:10:56,830
ერთი ბაიტი ან იქნებ ოთხი ბაიტი,
გარკვეული ფიქსირებული რაოდენობის bytes მოშორებით.

1475
01:10:56,830 --> 01:11:00,710
უკავშირდება სიაში, რომელიც ჩვენ შეიძლება შევაჩერო
როგორც ეს, ქვეშ hood, რომელიც

1476
01:11:00,710 --> 01:11:02,000
იცის, სად, რომ პერსონალი არის?

1477
01:11:02,000 --> 01:11:03,630
ეს იმას კი არ უნდა შემოვა მოსწონს ეს.

1478
01:11:03,630 --> 01:11:06,050
ზოგიერთი მონაცემები შეიძლება იყოს
უკან დარჩა იქ.

1479
01:11:06,050 --> 01:11:07,530
თქვენ კი არ ვიცი.

1480
01:11:07,530 --> 01:11:15,430
>> და ასე მასივი, თქვენ გაქვთ
ფუნქცია ცნობილია, როგორც წვდომის.

1481
01:11:15,430 --> 01:11:20,570
და რა წვდომის საშუალება არის
რომ კომპიუტერი გადადით მყისიერად

1482
01:11:20,570 --> 01:11:22,730
ნებისმიერ ადგილას მასივი.

1483
01:11:22,730 --> 01:11:23,580
რატომ?

1484
01:11:23,580 --> 01:11:26,000
იმის გამო, რომ კომპიუტერი იცის
რომ პირველი ადგილმდებარეობა

1485
01:11:26,000 --> 01:11:29,540
ნულოვანი, ერთი, ორი, სამი.

1486
01:11:29,540 --> 01:11:33,890
>> ასე რომ, თუ გსურთ გადასვლა
ამ ელემენტს მომდევნო ელემენტს,

1487
01:11:33,890 --> 01:11:36,099
თქვენ ფაქტიურად, ამ
კომპიუტერის გონება, უბრალოდ დაამატოთ ერთი.

1488
01:11:36,099 --> 01:11:39,140
თუ გსურთ წასვლა მესამე ელემენტს,
უბრალოდ დაამატოთ one-- შემდეგი ელემენტის, უბრალოდ

1489
01:11:39,140 --> 01:11:40,290
დაამატოთ ერთი.

1490
01:11:40,290 --> 01:11:42,980
თუმცა, ეს ვერსია
ამბავი, ვფიქრობ,

1491
01:11:42,980 --> 01:11:46,080
კომპიუტერული გაკეთებული ეძებს
ან საქმე ნომერი 100.

1492
01:11:46,080 --> 01:11:49,770
როგორ იღებთ შემდეგი
კლასის grade წიგნი?

1493
01:11:49,770 --> 01:11:52,560
>> თქვენ უნდა მიიღოს შვიდი
ნაბიჯები, რომელიც არის უკანონო.

1494
01:11:52,560 --> 01:11:58,120
იმისათვის რომ მომდევნო ერთი, თქვენ უნდა
მიიღოს კიდევ რვა ნაბიჯები, რათა კიდევ 15.

1495
01:11:58,120 --> 01:12:02,250
სხვა სიტყვებით, ეს არ არის
მუდმივი უფსკრული ნომრები,

1496
01:12:02,250 --> 01:12:04,857
და ასე უბრალოდ იღებს
კომპიუტერული მეტი დრო არის წერტილი.

1497
01:12:04,857 --> 01:12:06,940
კომპიუტერი უნდა ვეძებოთ
მეშვეობით მეხსიერება, რათა

1498
01:12:06,940 --> 01:12:08,990
იპოვოს ის, რაც თქვენ ეძებთ.

1499
01:12:08,990 --> 01:12:14,260
>> ასე რომ, ხოლო მასივი tends უნდა იყოს
სწრაფი მონაცემები სტრუქტურა იმიტომ, რომ თქვენ

1500
01:12:14,260 --> 01:12:17,610
ფაქტიურად მხოლოდ ამის მარტივი არითმეტიკა
და მისაღებად, სადაც გსურთ დამატებით ერთი,

1501
01:12:17,610 --> 01:12:21,300
for instance-- უკავშირდება სია,
შესწირონ, რომ ფუნქცია.

1502
01:12:21,300 --> 01:12:24,020
თქვენ არ შეგიძლიათ უბრალოდ პირველი
მეორე მესამე მეოთხე.

1503
01:12:24,020 --> 01:12:25,240
თქვენ უნდა დაიცვას რუკაზე.

1504
01:12:25,240 --> 01:12:28,160
თქვენ უნდა მიიღოს მეტი ნაბიჯები
მიიღოს იმ ღირებულებებს, რომლებიც

1505
01:12:28,160 --> 01:12:30,230
რომ როგორც ჩანს, დასძინა ღირებულება.

1506
01:12:30,230 --> 01:12:35,910
ასე რომ, ჩვენ გადამხდელი ფასი, მაგრამ რა იყო
ფუნქცია, რომელიც Dan ეძებდა აქ?

1507
01:12:35,910 --> 01:12:38,110
რას უკავშირდება სიაში
როგორც ჩანს, საშუალებას გვაძლევს გავაკეთოთ,

1508
01:12:38,110 --> 01:12:40,240
რომელიც იყო წარმოშობის
ამ კონკრეტულ ამბავი?

1509
01:12:40,240 --> 01:12:43,250

1510
01:12:43,250 --> 01:12:43,830
>> ზუსტად.

1511
01:12:43,830 --> 01:12:46,220
დინამიური ზომა, რათა.

1512
01:12:46,220 --> 01:12:48,040
ჩვენ შეგიძლიათ ამ სიაში.

1513
01:12:48,040 --> 01:12:51,430
ჩვენ კი შემცირება სიაში, ასე
რომ ჩვენ მხოლოდ გამოყენებით იმდენი მეხსიერება

1514
01:12:51,430 --> 01:12:55,560
როგორც ჩვენ რეალურად გვინდა, და ასე
ჩვენ არასდროს ზედმეტად გამოყოფისას.

1515
01:12:55,560 --> 01:12:58,470
>> ახლა უბრალოდ უნდა იყოს ნამდვილად Nit-picky,
არსებობს ფარული ღირებულება.

1516
01:12:58,470 --> 01:13:01,980
ასე, რომ თქვენ უნდა არა მხოლოდ მიადევნე თვალი დაარწმუნოს
რომ ეს არის მყარი იდგა.

1517
01:13:01,980 --> 01:13:04,190
არსებობს კიდევ ერთი ფარული ღირებულება აქ.

1518
01:13:04,190 --> 01:13:06,550
სასარგებლოდ, უნდა იყოს ნათელი,
არის, რომ ჩვენ კიდევ დინამიკას.

1519
01:13:06,550 --> 01:13:10,359
თუ მე მინდა კიდევ ერთი ელემენტი, მე შემიძლია უბრალოდ
მიაპყროს და დააყენოს ნომერი არსებობს.

1520
01:13:10,359 --> 01:13:12,150
და მერე შეიძლება ბმული
სურათს აქ,

1521
01:13:12,150 --> 01:13:14,970
იმის გამო, რომ სწორედ აქ, კიდევ ერთხელ, თუ მე
მოხატული თავს კუთხეში,

1522
01:13:14,970 --> 01:13:19,410
თუ რაღაც უკვე გამოყენებით
მეხსიერების აქ, მე out of luck.

1523
01:13:19,410 --> 01:13:21,700
მე მოხატული თავს შევიდა კუთხეში.

1524
01:13:21,700 --> 01:13:24,390
>> მაგრამ რა არის ფარული
ღირს ამ სურათში?

1525
01:13:24,390 --> 01:13:27,690
ეს არ არის მხოლოდ თანხის
დრო, რომელიც სჭირდება

1526
01:13:27,690 --> 01:13:29,870
უნდა წავიდეს აქ,
რაც არის შვიდი ნაბიჯები, მაშინ

1527
01:13:29,870 --> 01:13:32,820
რვა ნაბიჯი, რომელიც უფრო მეტია, ვიდრე ერთი.

1528
01:13:32,820 --> 01:13:34,830
რა არის კიდევ ერთი ფარული ღირებულება?

1529
01:13:34,830 --> 01:13:35,440
არა მხოლოდ დროს.

1530
01:13:35,440 --> 01:13:44,790

1531
01:13:44,790 --> 01:13:49,940
დამატებითი ინფორმაცია
აუცილებელია, რათა მივაღწიოთ ამ სურათს.

1532
01:13:49,940 --> 01:13:53,210
>> ჰო, რუკა, იმ პატარა ცალი
ქაღალდი, მე შენარჩუნება აღწერს მათ.

1533
01:13:53,210 --> 01:13:55,650
ეს arrows-- ის არ არის თავისუფალი.

1534
01:13:55,650 --> 01:13:57,660
კომპიუტერი თქვენ იცით,
რა კომპიუტერი აქვს.

1535
01:13:57,660 --> 01:13:58,790
მას აქვს zeros და პირობა.

1536
01:13:58,790 --> 01:14:03,170
თუ გსურთ წარმოადგენს ისარი ან
რუკაზე ან ნომერი, თქვენ უნდა მეხსიერება.

1537
01:14:03,170 --> 01:14:05,950
ასე რომ, სხვა ფასი თქვენ
გადახდა უკავშირდება სია,

1538
01:14:05,950 --> 01:14:09,070
საერთო კომპიუტერულ მეცნიერებათა
რესურსი, ასევე სივრცეში.

1539
01:14:09,070 --> 01:14:11,710
>> და მართლაც, ასე რომ ხშირად,
შორის tradeoffs

1540
01:14:11,710 --> 01:14:15,580
შექმნასა პროგრამული საინჟინრო
სისტემები დრო და სივრცე

1541
01:14:15,580 --> 01:14:18,596
ორი თქვენი ინგრედიენტები, ორი
თქვენი ყველაზე ძვირადღირებული ინგრედიენტები.

1542
01:14:18,596 --> 01:14:21,220
ეს არის რაზეც მე მეტი დრო
იმიტომ, რომ მე უნდა დაიცვას ეს რუკა,

1543
01:14:21,220 --> 01:14:25,730
მაგრამ ის ასევე რაზეც მე მეტი სივრცე
იმიტომ, რომ მე, რომ ეს რუკა გარშემო.

1544
01:14:25,730 --> 01:14:28,730
ასე რომ, იმედი მაქვს, როგორც ჩვენ სახის
დისკუსია გუშინ და დღეს,

1545
01:14:28,730 --> 01:14:31,720
არის, რომ სარგებელი
გადაწონის ხარჯები.

1546
01:14:31,720 --> 01:14:33,870
>> მაგრამ არ არსებობს აშკარა გადაწყვეტა აქ.

1547
01:14:33,870 --> 01:14:35,870
იქნებ ეს არის better--
a la სწრაფი და ბინძური,

1548
01:14:35,870 --> 01:14:38,660
როგორც Kareem შემოთავაზებული ადრე
იმისათვის, მეხსიერების პრობლემა.

1549
01:14:38,660 --> 01:14:42,520
მხოლოდ ყიდვა მეხსიერება, ვფიქრობ, ნაკლებად
ძნელია იმის შესახებ, პრობლემის გადაჭრის,

1550
01:14:42,520 --> 01:14:44,595
და გადაწყვიტოს იგი უფრო ადვილი გზა.

1551
01:14:44,595 --> 01:14:46,720
და მართლაც ადრე, როდესაც
ჩვენ ვისაუბრეთ tradeoffs,

1552
01:14:46,720 --> 01:14:49,190
ეს არ იყო სივრცე
კომპიუტერი და დრო.

1553
01:14:49,190 --> 01:14:51,810
ეს იყო დეველოპერი დრო, რომელიც
კიდევ ერთი რესურსი.

1554
01:14:51,810 --> 01:14:54,829
>> ასე რომ, კიდევ ერთხელ, ეს გაწონასწორებული
ცდილობს გადაწყვიტოს, რომელი ერთი იმ რამ,

1555
01:14:54,829 --> 01:14:55,870
თქვენ სურვილი დახარჯოს?

1556
01:14:55,870 --> 01:14:57,380
რომელიც ყველაზე ნაკლებად ძვირი?

1557
01:14:57,380 --> 01:15:01,040
რომელიც უკომპრომისო უკეთესი შედეგები?

1558
01:15:01,040 --> 01:15:01,540
ჰო?

1559
01:15:01,540 --> 01:15:11,310

1560
01:15:11,310 --> 01:15:12,580
>> ნამდვილად.

1561
01:15:12,580 --> 01:15:15,970
ამ შემთხვევაში, თუ თქვენ
წარმოადგენს ნომრები maps--

1562
01:15:15,970 --> 01:15:18,820
ეს ეწოდება მრავალ ენაზე
"მითითებას" ან "მისამართები" -

1563
01:15:18,820 --> 01:15:20,390
ეს ორმაგი სივრცეში.

1564
01:15:20,390 --> 01:15:24,390
ეს არ უნდა იყოს, როგორც ცუდი როგორც ორმაგი თუ
ახლა ჩვენ მხოლოდ შენახვის ნომრები.

1565
01:15:24,390 --> 01:15:27,410
დავუშვათ, რომ ჩვენ შენახვის
პაციენტის ჩანაწერი hospital--

1566
01:15:27,410 --> 01:15:30,870
ასე პირსონი სახელები, ტელეფონის ნომრები,
სოციალური უსაფრთხოების ნომერი, ექიმი

1567
01:15:30,870 --> 01:15:31,540
ისტორია.

1568
01:15:31,540 --> 01:15:34,160
ეს ყუთი შეიძლება იყოს ბევრი,
გაცილებით დიდია, ამ შემთხვევაში

1569
01:15:34,160 --> 01:15:38,000
პატარა მაჩვენებელი, მისამართი
შემდეგი element-- ეს არ არის დიდი გარიგება.

1570
01:15:38,000 --> 01:15:40,620
ეს ისეთი fringe
ღირს რომ არ აქვს მნიშვნელობა.

1571
01:15:40,620 --> 01:15:43,210
მაგრამ ამ შემთხვევაში, yeah, ეს გაორმაგება.

1572
01:15:43,210 --> 01:15:45,290
კარგი კითხვაა.

1573
01:15:45,290 --> 01:15:47,900
>> მოდით ვისაუბროთ დროს
ცოტა უფრო კონკრეტულად.

1574
01:15:47,900 --> 01:15:50,380
რა არის ქრონომეტრაჟი
ძიების ამ სიაში?

1575
01:15:50,380 --> 01:15:53,640
დავუშვათ, რომ მინდოდა ძიება
ყველა სტუდენტთა შეფასება,

1576
01:15:53,640 --> 01:15:55,980
და იქ n შეფასება
ამ მონაცემების სტრუქტურას.

1577
01:15:55,980 --> 01:15:58,830
აქაც, ჩვენ შეგვიძლია სესხება
ლექსიკის ადრე.

1578
01:15:58,830 --> 01:16:00,890
ეს არის წრფივი მონაცემების სტრუქტურას.

1579
01:16:00,890 --> 01:16:04,570
>> დიდი ო ო არის ის, რაც საჭირო მისაღებად
ბოლოს ამ მონაცემების სტრუქტურას,

1580
01:16:04,570 --> 01:16:08,410
whereas-- და ჩვენ არ მინახავს
ეს ადრე მასივი გაძლევთ

1581
01:16:08,410 --> 01:16:13,555
რასაც მუდმივი, რაც იმას ნიშნავს,
ერთი ნაბიჯი ან ორი ნაბიჯი ან 10 ნაბიჯების

1582
01:16:13,555 --> 01:16:14,180
მნიშვნელობა არ აქვს.

1583
01:16:14,180 --> 01:16:15,440
ეს არის ფიქსირებული ნომერი.

1584
01:16:15,440 --> 01:16:17,440
მას აქვს არაფერ შუაშია
ზომა მასივი.

1585
01:16:17,440 --> 01:16:20,130
და მიზეზი, რომ
კიდევ ერთხელ, არის წვდომის.

1586
01:16:20,130 --> 01:16:23,180
კომპიუტერული შეუძლია მხოლოდ დაუყოვნებლივ
გადასვლა სხვა ადგილას,

1587
01:16:23,180 --> 01:16:27,770
იმიტომ, რომ ისინი ყველა ერთი და იგივე
დაშორება ყველაფერი.

1588
01:16:27,770 --> 01:16:29,112
არ არის აზროვნების ჩართული.

1589
01:16:29,112 --> 01:16:31,900

1590
01:16:31,900 --> 01:16:32,400
კარგი.

1591
01:16:32,400 --> 01:16:39,230
ასე რომ, თუ მე არ შემიძლია, ნება მომეცით, ცდილობენ
ხატვა ორი საბოლოო სურათები.

1592
01:16:39,230 --> 01:16:42,830
ძალიან გავრცელებული ერთ-ერთი ცნობილია, როგორც hash მაგიდა.

1593
01:16:42,830 --> 01:16:51,120
ასე რომ მოტივაცია ამ დისკუსია,
მიადევნე თვალი ვიფიქროთ, თუ როგორ უნდა გავაკეთოთ ეს.

1594
01:16:51,120 --> 01:16:52,610
>> ასე რომ, თუ ამის შესახებ?

1595
01:16:52,610 --> 01:16:55,160
ვივარაუდოთ, რომ პრობლემის
ჩვენ გვინდა, რომ გადაწყვიტოს ახლა

1596
01:16:55,160 --> 01:16:58,360
ახორციელებს in a dictionary--
ასე რომ, მთელი bunch of ინგლისური სიტყვა

1597
01:16:58,360 --> 01:16:59,330
ან რასაც.

1598
01:16:59,330 --> 01:17:02,724
და მიზანი არის, რომ შეძლებს უპასუხოს
კითხვებს ფორმა არის ეს სიტყვა?

1599
01:17:02,724 --> 01:17:04,640
ასე, რომ თქვენ უნდა განახორციელოს
მართლწერის შემოწმება, უბრალოდ

1600
01:17:04,640 --> 01:17:07,220
როგორც ფიზიკური ლექსიკონი
რომელიც შეგიძლიათ გამოიყურება რამ up.

1601
01:17:07,220 --> 01:17:10,490
დავუშვათ, რომ მე უნდა გავაკეთოთ ამ მასივი.

1602
01:17:10,490 --> 01:17:12,590
მე ვერ გავაკეთებ ამ.

1603
01:17:12,590 --> 01:17:20,756
>> და ვფიქრობ, სიტყვები ვაშლის
და ბანანის და ნესვი.

1604
01:17:20,756 --> 01:17:23,330

1605
01:17:23,330 --> 01:17:26,465
და მე არ ვფიქრობ, რომ ხილი
რომ იწყება d, ასე რომ, ჩვენ მხოლოდ

1606
01:17:26,465 --> 01:17:27,590
აპირებენ სამი ხილი.

1607
01:17:27,590 --> 01:17:31,510
ასე რომ, ეს არის მასივი, და ჩვენ
შენახვის ყველა ეს სიტყვები

1608
01:17:31,510 --> 01:17:34,200
ამ ლექსიკონი, როგორც მასივი.

1609
01:17:34,200 --> 01:17:39,350
კითხვაზე, მაშინ, როგორ სხვაგან
შეიძლება თქვენ შესანახად ეს ინფორმაცია?

1610
01:17:39,350 --> 01:17:43,160
>> ისე, მე სახის მოტყუების აქ, იმიტომ,
თითოეული ეს ასო სიტყვის

1611
01:17:43,160 --> 01:17:44,490
მართლაც ინდივიდუალური ბაიტი.

1612
01:17:44,490 --> 01:17:46,740
ასე რომ, თუ მე ნამდვილად მინდოდა, რომ იყოს
nit-picky, მე ნამდვილად უნდა

1613
01:17:46,740 --> 01:17:49,600
უნდა გამყოფი ამ დაყოფილია ბევრი
მცირე მოცულობით მეხსიერება,

1614
01:17:49,600 --> 01:17:51,289
და ჩვენ შეგვიძლია გავაკეთოთ ზუსტად რომ.

1615
01:17:51,289 --> 01:17:53,580
მაგრამ ჩვენ ვაპირებთ გადაეყარონ
იგივე პრობლემა, როგორც ადრე.

1616
01:17:53,580 --> 01:17:56,674
რა მოხდება, თუ, როგორც Merriam Webster და Oxford
აკეთებს ყოველ წლამდე ისინი დაამატოთ სიტყვა

1617
01:17:56,674 --> 01:17:59,340
რომ dictionary-- ჩვენ არ
აუცილებლად მინდა ხატვა თავს

1618
01:17:59,340 --> 01:18:00,780
კუთხეში მასივი?

1619
01:18:00,780 --> 01:18:05,710
>> ასე რომ, ნაცვლად, შესაძლოა, მსოფლიოს სასურველი სტუმარი გახდებით მიდგომა
იმისათვის, რომ ვაშლის საკუთარი კვანძის ან ყუთი,

1620
01:18:05,710 --> 01:18:11,190
როგორც ჩვენ ვიტყოდი, ბანანის და
მაშინ აქ ჩვენ გვაქვს cantaloupe.

1621
01:18:11,190 --> 01:18:14,990

1622
01:18:14,990 --> 01:18:16,790
ჩვენ string ეს ყველაფერი ერთად.

1623
01:18:16,790 --> 01:18:19,980
ასე რომ, ეს არის მასივი, და
ეს არის დაკავშირებული სიაში.

1624
01:18:19,980 --> 01:18:23,300
თუ თქვენ ვერ საკმაოდ დანახვა, ეს მხოლოდ
ამბობს: "მასივი", და ეს ამბობს "სიაში."

1625
01:18:23,300 --> 01:18:25,780
>> ასე რომ, ჩვენ გვაქვს იგივე
ზუსტი საკითხები, როგორც ადრე,

1626
01:18:25,780 --> 01:18:28,600
რომლის დროსაც ჩვენ ახლა აქვს
დინამიზმის ჩვენს უკავშირდება სიაში.

1627
01:18:28,600 --> 01:18:31,090
მაგრამ ჩვენ გვაქვს საკმაოდ ნელი ლექსიკონი.

1628
01:18:31,090 --> 01:18:32,870
დავუშვათ, მინდა ეძებოთ სიტყვა.

1629
01:18:32,870 --> 01:18:35,430
ეს შეიძლება მიიღოს ჩემთვის დიდი ო ო
ნაბიჯები, რადგან სიტყვა შეიძლება

1630
01:18:35,430 --> 01:18:37,840
იყოს ყველა გზა ბოლოს
სია, როგორიცაა cantaloupe.

1631
01:18:37,840 --> 01:18:40,600
და აღმოჩნდება, რომ
პროგრამირებაში, ერთგვარი

1632
01:18:40,600 --> 01:18:42,700
წმინდა გრაალი მონაცემები
სტრუქტურები, არის ის,

1633
01:18:42,700 --> 01:18:46,620
რომელიც გაძლევთ მუდმივი
დრო მასივი

1634
01:18:46,620 --> 01:18:50,870
მაგრამ ჯერ კიდევ გაძლევთ დინამიკას.

1635
01:18:50,870 --> 01:18:52,940
>> ასე რომ, ჩვენ გვაქვს საუკეთესო ორივე სამყაროს?

1636
01:18:52,940 --> 01:18:55,570
და მართლაც, იქ არის რაღაც
მოუწოდა hash მაგიდა

1637
01:18:55,570 --> 01:18:59,320
რომელიც საშუალებას გაძლევთ ზუსტად
რომ, თუმცა დაახლოებით.

1638
01:18:59,320 --> 01:19:03,140
Hash მაგიდა არის fancier
მონაცემები სტრუქტურა, რომელიც ჩვენ

1639
01:19:03,140 --> 01:19:06,340
შეიძლება ვიფიქროთ, როგორც
კომბინაცია მასივი

1640
01:19:06,340 --> 01:19:12,390
და მე ვაპირებ შევაჩერო ეს
მოსწონს ეს და დაკავშირებული სიები

1641
01:19:12,390 --> 01:19:17,310
რომ მე მიაპყროს მსგავსი აქ.

1642
01:19:17,310 --> 01:19:19,760
>> და გზა ამ რამ
სამუშაოები ასეთია.

1643
01:19:19,760 --> 01:19:23,310

1644
01:19:23,310 --> 01:19:29,540
თუ ეს, ახლა hash მაგიდასთან
ჩემი მესამე მონაცემების სტრუქტურას,

1645
01:19:29,540 --> 01:19:32,590
და მე მინდა შესანახად
სიტყვა, მე არ

1646
01:19:32,590 --> 01:19:35,440
მინდა, რომ მხოლოდ შესანახად ყველა
სიტყვა თავში დაბრუნება თავში დაბრუნება.

1647
01:19:35,440 --> 01:19:37,430
მინდა ბერკეტები ზოგიერთი
ინფორმაცია

1648
01:19:37,430 --> 01:19:40,330
შესახებ სიტყვა, რომ შევძლებთ
ჩემთვის მისაღებად, სადაც ის სწრაფად.

1649
01:19:40,330 --> 01:19:43,666
>> ასე რომ, მოცემულ სიტყვები ვაშლის
და ბანანის და cantaloupe,

1650
01:19:43,666 --> 01:19:45,040
მე შეგნებულად აირჩია ეს სიტყვები.

1651
01:19:45,040 --> 01:19:45,340
რატომ?

1652
01:19:45,340 --> 01:19:47,631
რა არის სახის ფუნდამენტურად
სხვადასხვა დაახლოებით სამი?

1653
01:19:47,631 --> 01:19:49,950

1654
01:19:49,950 --> 01:19:51,484
რა არის აშკარა?

1655
01:19:51,484 --> 01:19:52,900
ისინი იწყება სხვადასხვა წერილებს.

1656
01:19:52,900 --> 01:19:53,900
>> ასე, რომ თქვენ იცით, რა?

1657
01:19:53,900 --> 01:19:57,120
იმის ნაცვლად, რომ ყველა ჩემი სიტყვები
იმავე bucket, ასე ვთქვათ,

1658
01:19:57,120 --> 01:20:00,390
ისევე, როგორც ერთ-ერთი დიდი სია, რატომ არ
მე მაინც ცდილობენ ოპტიმიზაცია

1659
01:20:00,390 --> 01:20:04,180
და ჩემი სიები 1/26 გრძელი.

1660
01:20:04,180 --> 01:20:07,440
მყარი ოპტიმიზაცია
შეიძლება იყოს რატომ არ

1661
01:20:07,440 --> 01:20:10,650
არ მე როცა ჩასმა სიტყვა
ამ მონაცემების სტრუქტურას,

1662
01:20:10,650 --> 01:20:14,300
შევიდა კომპიუტერის მეხსიერებაში, რატომ
არ მე ყველაფერს "ა" სიტყვები,

1663
01:20:14,300 --> 01:20:17,270
ყველა "ბ" სიტყვები,
და ყველა "გ" სიტყვა აქ?

1664
01:20:17,270 --> 01:20:24,610
ასე რომ, ეს მთავრდება აყენებს ვაშლის
აქ, ბანანის აქ, cantaloupe აქ,

1665
01:20:24,610 --> 01:20:25,730
და ასე შემდეგ.

1666
01:20:25,730 --> 01:20:31,700
>> და თუ მაქვს დამატებითი
სიტყვა მოსწონს რა არის კიდევ?

1667
01:20:31,700 --> 01:20:36,640
Apple, banana, მსხალი.

1668
01:20:36,640 --> 01:20:39,370
ვინმეს ვფიქრობ ხილი
რომელიც იწყება, B ან C?

1669
01:20:39,370 --> 01:20:40,570
Blueberry-- სრულყოფილი.

1670
01:20:40,570 --> 01:20:43,990
რომ აპირებს დასრულდება მდე აქ.

1671
01:20:43,990 --> 01:20:47,530
ასე რომ, ჩვენ, როგორც ჩანს,
ოდნავ უკეთესი,

1672
01:20:47,530 --> 01:20:50,820
იმიტომ, რომ ახლა თუ მინდა
მოძიება ვაშლის, I

1673
01:20:50,820 --> 01:20:53,200
, პირველი მე არ dive
ჩემი მონაცემები სტრუქტურა.

1674
01:20:53,200 --> 01:20:54,850
მე არ ჩაყვინთვის შევიდა ჩემი კომპიუტერის მეხსიერებაში.

1675
01:20:54,850 --> 01:20:56,530
მე პირველად შევხედოთ პირველი წერილი.

1676
01:20:56,530 --> 01:20:58,610
>> და ეს არის ის, რაც კომპიუტერში
მეცნიერი ვიტყოდი.

1677
01:20:58,610 --> 01:21:00,760
თქვენ hash თქვენი მონაცემები სტრუქტურა.

1678
01:21:00,760 --> 01:21:04,100
თქვენ თქვენი input, რომელიც
ამ შემთხვევაში არის სიტყვა, როგორიცაა ვაშლი.

1679
01:21:04,100 --> 01:21:07,150
თქვენ გაანალიზება, ეძებს
პირველი წერილი ამ შემთხვევაში,

1680
01:21:07,150 --> 01:21:08,340
ამით ჰეშირება იგი.

1681
01:21:08,340 --> 01:21:10,950
ჰეშირება არის ზოგადი ტერმინი, რომლის დროსაც
შენ რაღაც, როგორც შეყვანის

1682
01:21:10,950 --> 01:21:12,116
და თქვენ აწარმოოს გარკვეული გამომავალი.

1683
01:21:12,116 --> 01:21:15,090
და გამომავალი, რომ
საქმე ის არის, ადგილმდებარეობა

1684
01:21:15,090 --> 01:21:18,150
გსურთ მოძებნოთ, პირველი
ადგილმდებარეობა, მეორე ადგილას, მესამე.

1685
01:21:18,150 --> 01:21:22,160
ასე რომ შეყვანის არის ვაშლის,
გამომავალი პირველი.

1686
01:21:22,160 --> 01:21:25,054
შეყვანის ბანანის,
გამომავალი უნდა იყოს მეორე.

1687
01:21:25,054 --> 01:21:27,220
შეყვანის cantaloupe,
გამომავალი უნდა იყოს მესამე.

1688
01:21:27,220 --> 01:21:30,320
შეყვანის მოცვის, რომ
გამომავალი უნდა კვლავ იყოს მეორე.

1689
01:21:30,320 --> 01:21:34,010
და ის, რაც ეხმარება თქვენ
shortcuts თქვენი მეხსიერება

1690
01:21:34,010 --> 01:21:39,050
იმისათვის, რომ მიიღოთ სიტყვა
ან მონაცემების უფრო ეფექტურად.

1691
01:21:39,050 --> 01:21:43,330
>> ახლა ეს წყვეტს ქვემოთ ჩვენი დროის პოტენციურად
ისევე როგორც ყოველი 26

1692
01:21:43,330 --> 01:21:45,850
იმიტომ, რომ თუ ვივარაუდოთ, რომ თქვენ
იმდენი "ა" სიტყვები "z"

1693
01:21:45,850 --> 01:21:48,080
სიტყვა, როგორც "q" სიტყვა, რომელიც
არ არის ნამდვილად realistic--

1694
01:21:48,080 --> 01:21:50,830
თქვენ ვაპირებთ აქვს skew მასშტაბით
გარკვეული ასო alphabet--

1695
01:21:50,830 --> 01:21:53,204
მაგრამ ეს იქნება დამატებითი
მიდგომა, რომელიც არ იძლევა

1696
01:21:53,204 --> 01:21:55,930
მიიღოთ სიტყვა ბევრად უფრო სწრაფად.

1697
01:21:55,930 --> 01:21:59,660
და რეალურად, დახვეწილი
პროგრამა, Google- ის მსოფლიოში,

1698
01:21:59,660 --> 01:22:02,180
Facebooks საქართველოს world--
ისინი გამოიყენოთ hash მაგიდა

1699
01:22:02,180 --> 01:22:03,740
ბევრი სხვადასხვა მიზნით.

1700
01:22:03,740 --> 01:22:06,590
მაგრამ ისინი არ იქნება ისეთი მიამიტი
უბრალოდ შეხედეთ პირველი წერილი

1701
01:22:06,590 --> 01:22:09,700
ვაშლის ან ბანანის ან
მსხალი ან cantaloupe,

1702
01:22:09,700 --> 01:22:13,420
იმიტომ, რომ, როგორც ხედავთ, ამ
სიები შეიძლება მაინც ხანგრძლივი.

1703
01:22:13,420 --> 01:22:17,130
>> ასე რომ, ეს შეიძლება კვლავ ერთგვარი
of linear-- ასე რომ, ერთგვარი ნელი,

1704
01:22:17,130 --> 01:22:19,980
ისევე, როგორც დიდი ო ო
რომელიც ჩვენ განვიხილეთ ადრე.

1705
01:22:19,980 --> 01:22:25,290
ასე რომ, რა რეალური კარგი hash მაგიდა,
გავაკეთოთ მას მოუწევს ბევრად უფრო დიდი მასივი.

1706
01:22:25,290 --> 01:22:28,574
და ის გამოყენება ბევრად უფრო
დახვეწილი hashing ფუნქცია,

1707
01:22:28,574 --> 01:22:30,240
ასე, რომ ეს არ არის მხოლოდ შევხედოთ "ა".

1708
01:22:30,240 --> 01:22:35,480
იქნებ ეს უყურებს "a-p-p-l-ე" და
რატომღაც აკონვერტებს იმ ხუთ წერილები

1709
01:22:35,480 --> 01:22:38,400
შევიდა იმ ადგილას, სადაც
ვაშლის უნდა იყოს შენახული.

1710
01:22:38,400 --> 01:22:42,660
ჩვენ უბრალოდ გულუბრყვილოდ გამოყენებით ასო 'a'
მარტო იმიტომ, რომ ეს არის ლამაზი და მარტივი.

1711
01:22:42,660 --> 01:22:44,600
>> მაგრამ hash მაგიდა,
და ბოლოს, თქვენ შეიძლება ვიფიქროთ

1712
01:22:44,600 --> 01:22:47,270
როგორც კომბინაცია
მასივი, რომელთაგან თითოეული

1713
01:22:47,270 --> 01:22:51,700
აქვს უკავშირდება სიაში, რომელიც იდეალურად
უნდა იყოს რაც შეიძლება მოკლე.

1714
01:22:51,700 --> 01:22:54,364
და ეს არ არის აშკარა გადაწყვეტა.

1715
01:22:54,364 --> 01:22:57,280
სინამდვილეში, ბევრი ჯარიმა tuning
რომ მიდის ქვეშ hood როდესაც

1716
01:22:57,280 --> 01:22:59,654
ახორციელებს ამ სახის
დახვეწილი მონაცემთა სტრუქტურები

1717
01:22:59,654 --> 01:23:01,640
არის ის, რაც არის სწორი
სიგრძეზე მასივი?

1718
01:23:01,640 --> 01:23:03,250
რა არის სწორი ქეშირების ფუნქცია?

1719
01:23:03,250 --> 01:23:04,830
როგორ ჩაწეროთ რამ მეხსიერებაში?

1720
01:23:04,830 --> 01:23:07,249
>> მაგრამ გააცნობიეროს, რამდენად სწრაფად
ეს ერთგვარი დისკუსია

1721
01:23:07,249 --> 01:23:10,540
გამწვავდა, არც ისე შორს, რომ ეს არის სახის
მეტი ერთი ხელმძღვანელი ამ ეტაპზე, რომელიც

1722
01:23:10,540 --> 01:23:11,360
კარგად არის.

1723
01:23:11,360 --> 01:23:18,820
მაგრამ ჩვენ დავიწყეთ, გავიხსენოთ, ნამდვილად
რაღაც დაბალი დონის და ელექტრონული.

1724
01:23:18,820 --> 01:23:20,819
ასე რომ, ეს კიდევ ერთხელ არის ამ
თემა აბსტრაქციის

1725
01:23:20,819 --> 01:23:23,610
სადაც ერთხელ თქვენ დაიწყოს მიიღოს
მინიჭებული, OK, მაქვს it-- არსებობს

1726
01:23:23,610 --> 01:23:26,680
ფიზიკური მეხსიერება, კარგი, გასაგებია, ყოველ
ფიზიკური ადგილმდებარეობა აქვს მისამართი,

1727
01:23:26,680 --> 01:23:29,910
OK, მე მივიღე ეს, მე შემიძლია წარმოადგენს
იმ მისამართები როგორც arrows--

1728
01:23:29,910 --> 01:23:34,650
თქვენ შეგიძლიათ ძალიან სწრაფად დაიწყება
უფრო დახვეწილი საუბარი, რომ

1729
01:23:34,650 --> 01:23:38,360
საბოლოოდ, როგორც ჩანს, რომელიც საშუალებას მოგვცემს
პრობლემების მოსაგვარებლად, როგორიცაა ეძებს

1730
01:23:38,360 --> 01:23:41,620
და დახარისხება უფრო ეფექტურად.

1731
01:23:41,620 --> 01:23:44,190
ხოლო დანარჩენი დავრწმუნდი, ძალიან
იმიტომ, რომ მე ვფიქრობ, რომ ეს

1732
01:23:44,190 --> 01:23:48,700
არის ღრმა ჩვენ წავიდა ზოგიერთი
ამ CS თემა proper-- ჩვენ

1733
01:23:48,700 --> 01:23:51,880
კეთდება დღეში და ნახევარი ამ
მეტიც, თუ რა შეიძლება, როგორც წესი, მეტი

1734
01:23:51,880 --> 01:23:55,520
რა თქმა უნდა, რვა კვირის სემესტრში.

1735
01:23:55,520 --> 01:23:59,670
>> ნებისმიერი კითხვები ამ?

1736
01:23:59,670 --> 01:24:01,100
არ არის?

1737
01:24:01,100 --> 01:24:01,940
კარგი.

1738
01:24:01,940 --> 01:24:05,610
ისე, რატომ არ გავჩერდეთ იქ,
დაიწყოს ლანჩი რამდენიმე წუთის დასაწყისში,

1739
01:24:05,610 --> 01:24:07,052
განახლდება მხოლოდ ერთი საათის განმავლობაში?

1740
01:24:07,052 --> 01:24:08,760
და მე, linger
ცოტა შეკითხვებს.

1741
01:24:08,760 --> 01:24:11,343
ამის შემდეგ მე ვაპირებ, რომ უნდა წავიდეს
მიიღოს რამდენიმე ზარები, თუ, რომ კარგადაა.

1742
01:24:11,343 --> 01:24:15,000
მე ჩართოთ რამდენიმე მუსიკალური იმავდროულად,
მაგრამ ლანჩი უნდა იყოს გარშემო კუთხეში.

1743
01:24:15,000 --> 01:24:17,862

