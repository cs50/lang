डेविड मालन: ठीक है। हम वापस आ गए। प्रोग्रामिंग पर इस क्षेत्र में तो क्या हुआ मैंने सोचा कि हम क्या करना चाहते हैं चीजों का एक मिश्रण है। एक, एक छोटा सा कर कुछ के हाथ पर, एक अधिक चंचल का उपयोग कर यद्यपि प्रोग्रामिंग environment-- एक बात का ठोस है वास्तव में विचारों के प्रकार हम के बारे में बात कर रहा है लेकिन एक छोटे से अधिक औपचारिक रूप से। दो में से कुछ को देखो अधिक तकनीकी तरीके कि एक प्रोग्रामर वास्तव में समाधान होगा खोज समस्या जैसी समस्याओं कि हम पहले देखा और यह भी एक अधिक मौलिक छंटाई के दिलचस्प समस्या है। 

हम बस मिल जाने से ग्रहण किया वह यह है कि फोन की किताब हल किया गया था, लेकिन अकेले कि वास्तव में है एक तरह से एक कई अलग अलग तरीकों से कठिन समस्या इसे हल करने के लिए। इसलिए हम के रूप में इन इस्तेमाल करेंगे समस्याओं का एक वर्ग बातों का प्रतिनिधि है कि सामान्य रूप से हल किया जा सकता है। और फिर हम बात करेंगे कुछ विस्तार के बारे में क्या डेटा कहा जाता है structures-- लिंक सूचियों की तरह शौक़ीन तरीके और हैश टेबल और पेड़ है कि एक प्रोग्रामर वास्तव में होगा का उपयोग करें और आम तौर पर उपयोग एक whiteboard पर पेंट करने के लिए की एक तस्वीर क्या वह या वह लागू करने के लिए envisions सॉफ्टवेयर के कुछ टुकड़े। 

तो चलो पहले भाग पर हाथ-करते हैं। तो बस अपने हाथ एक साथ गंदे हो पर्यावरण scratch.mit.edu बुलाया। यह एक उपकरण है कि हम का उपयोग है हमारे स्नातक कक्षा में। हालांकि यह बनाया गया है उम्र 12 और ऊपर के लिए, हम अप के लिए इसका इस्तेमाल कि काफी एक सा का हिस्सा क्योंकि यह एक अच्छा है, मजेदार है सीखने की चित्रमय तरीका प्रोग्रामिंग के बारे में एक छोटे से कुछ। तो, कि यूआरएल के लिए सिर जहां आप काफी इस तरह एक पृष्ठ देखना चाहिए, और आगे जाना है और क्लिक करें शीर्ष सही पर खरोंच जुडें और एक उपयोगकर्ता नाम और एक का चयन पासवर्ड और अंत में अपने आप को मिल एक account-- scratch.mit.edu। मैंने सोचा कि मैं एक के रूप में इस का उपयोग होता है अवसर पहली बार इस दिखाने के लिए। एक सवाल के ब्रेक के दौरान आया था के बारे में क्या वास्तव में कोड की तरह लग रहा है। और हम बात कर रहे थे सी के बारे में ब्रेक के दौरान, में विशेष रूप से एक particular-- एक पुराने भाषा में निचले स्तर पर। और मैं सिर्फ एक त्वरित किया गूगल सी कोड खोजने के लिए खोज द्विआधारी खोज, एल्गोरिथ्म के लिए है कि हम इससे पहले कि फोन की किताब खोज करने के लिए इस्तेमाल किया। इस विशिष्ट उदाहरण है, ज़ाहिर है, एक फोन की किताब खोज नहीं करता। यह बस की एक पूरी गुच्छा खोज कंप्यूटर की स्मृति में संख्या। लेकिन तुम सिर्फ एक दृश्य प्राप्त करना चाहते हैं, तो क्या एक वास्तविक प्रोग्रामिंग की भावना भाषा की तरह लग रहा है, ऐसा लगता है एक छोटे से कुछ इस तरह। इसलिए इसके बारे में 20 से अधिक है, कोड की 30 या तो लाइनों, लेकिन बातचीत हम तोड़ने पर कर रहे थे के बारे में कैसे यह वास्तव में था शून्य और लोगों में तब्दील हो जाता है और अगर आप सिर्फ इतना है कि वापस नहीं कर सकते प्रक्रिया और शून्य और लोगों से जाना कोड के लिए वापस। 

दुर्भाग्य से, प्रक्रिया इसलिए परिवर्तनकारी है यह है कि यह एक बहुत आसान है किया तुलना में कहा। मैं आगे चला गया है और वास्तव में कर दिया कि कार्यक्रम, द्विआधारी खोज, शून्य और एक के माध्यम से लोगों में कार्यक्रम संकलक कहा जाता है कि मैं अपने मैक पर यहीं के लिए होता है। और अगर आप स्क्रीन पर देखने के इधर, विशेष रूप से ध्यान केंद्रित इन बीच छह स्तंभों पर ही है, आप केवल शून्य और लोगों देखेंगे। और उन शून्य और लोगों रहे हैं कि ठीक है कि खोज कार्यक्रम की रचना। 

और तो पांच बिट्स के प्रत्येक हिस्सा, शून्य और लोगों की हर बाइट यहाँ, कुछ शिक्षा का प्रतिनिधित्व आम तौर पर एक कंप्यूटर के अंदर। और वास्तव में, तुम सुना है विपणन नारा "इंटेल के अंदर" - कि, बेशक, सिर्फ मतलब है कि आप एक है इंटेल सीपीयू या कंप्यूटर के अंदर मस्तिष्क। और क्या है कि होने के लिए एक सीपीयू है इसका मतलब है आप एक निर्देश निर्धारित किया है कि, इतनी बात करने के लिए। 

दुनिया में हर सीपीयू, की कई उन्हें इन दिनों इंटेल द्वारा बनाई गई, एक परिमित समझता निर्देश की संख्या। तथा उन निर्देशों इतने निम्न स्तर पर हैं के रूप में एक साथ इन दो नंबरों को जोड़ने, इन दो नंबरों को एक साथ गुणा, यहाँ से डेटा के इस टुकड़े को स्थानांतरित यहाँ स्मृति में करने के लिए, इस बचा यहाँ से जानकारी स्मृति में यहां के लिए, और इतने forth-- तो बहुत, बहुत निम्न स्तर, लगभग इलेक्ट्रॉनिक विवरण। लेकिन जो गणितीय के साथ संचालन युग्मित क्या हम पहले चर्चा के साथ, डेटा का प्रतिनिधित्व शून्य और लोगों, के रूप में कर सकते हैं आप सब कुछ का निर्माण एक कंप्यूटर आज कर सकते हैं कि, चाहे यह शाब्दिक, चित्रमय, संगीत है, या अन्यथा। 

तो इस पाने के लिए बहुत आसान है जल्दी के मातम में खो दिया है। और वहाँ की एक बहुत कुछ है वाक्य चुनौतियों जिससे आप सरल बनाने के लिए अगर, कार्यक्रम के Typos से कोई भी बेवकूफी जो भी काम करेंगे। और तो बजाय एक का उपयोग कर आज सुबह सी की तरह भाषा, मैंने सोचा कि यह होगा अधिक मज़ा वास्तव में क्या करने के लिए कुछ और अधिक दृश्य है, जो जबकि बच्चों के लिए बनाया वास्तव में एक आदर्श मिसाल है एक वास्तविक प्रोग्रामिंग की language-- अभी के लिए होता है पाठ के बजाय चित्रों का उपयोग उन विचारों का प्रतिनिधित्व करने के लिए। 

तो एक बार आप वास्तव में एक है scratch.mit.edu पर खाते, बनाएं बटन क्लिक करें शीर्ष पर साइट के लिए छोड़ दिया। और अगर आप की तरह एक वातावरण देखना चाहिए एक मैं के बारे में मेरी स्क्रीन पर देखने के लिए कर रहा हूँ यहाँ। और हम सिर्फ एक छोटे से खर्च करेंगे समय का सा यहां खेल रहे थे। चलो देखते हैं अगर हम सब कुछ हल नहीं कर सकते हैं देखें निम्नलिखित तरीके में समस्याओं का एक साथ। 

तो क्या आप इस के भीतर देखेंगे environment-- और वास्तव में बस जाने मुझे थामने। किसी को भी यहाँ नहीं है? यहाँ नहीं? ठीक। तो मुझे कुछ बाहर बात करते हैं इस माहौल की विशेषताओं। 

स्क्रीन के ऊपर छोड़ दिया पर तो, हम स्क्रैच की अवस्था है, तो बात करो। स्क्रैच न केवल नाम है इस प्रोग्रामिंग भाषा के; यह भी बिल्ली का नाम है कि आप नारंगी में वहाँ डिफ़ॉल्ट रूप से देखते हैं। उन्होंने कहा, एक मंच पर है, इसलिए बहुत पसंद है मैं वर्णित पहले कछुआ एक में होने के रूप में आयताकार सफेद बोर्ड वातावरण। इस बिल्ली की दुनिया पूरी तरह से सीमित है वहाँ है कि आयत को दीजिए। 

इस बीच, सही पर हाथ यहाँ पक्ष है, यह सिर्फ एक स्क्रिप्ट का क्षेत्र, एक खाली स्लेट अगर तुम जाएगा। यह जहां हम लिखने जा रहे है बस एक पल में हमारे कार्यक्रमों। और इमारत ब्लॉकों है कि हम करेंगे इस पहेली program-- लिखने के लिए उपयोग टुकड़े, अगर आप will-- हैं उन यहीं बीच में, और वे वर्गीकृत कर रहे हैं कार्यक्षमता द्वारा। तो, उदाहरण के लिए, मैं आगे जाने के लिए जा रहा हूँ और इनमें से कम से कम एक प्रदर्शित करता है। मुझे आगे जाना है और क्लिक करने के लिए जा रहा हूँ ऊपर शीर्ष नियंत्रण श्रेणी। 

इसलिए इन शीर्ष अप श्रेणियां हैं। मैं नियंत्रण श्रेणी क्लिक करने के लिए जा रहा हूँ। बल्कि, मैं घटनाओं क्लिक करने के लिए जा रहा हूँ श्रेणी, बहुत पहले एक ऊपर। और तुम भी साथ पालन करना चाहते हैं तो के रूप में हम ऐसा करते हैं, तो आप काफी करने के लिए स्वागत कर रहे हैं। मैं क्लिक करें और इस खींचें करने के लिए जा रहा हूँ पहले एक, "जब हरे रंग का झंडा क्लिक किया।" और फिर मैं यह सिर्फ ड्रॉप करने के लिए जा रहा हूँ मोटे तौर पर मेरे खाली स्लेट के शीर्ष पर। 

और क्या खरोंच के बारे में अच्छा है इस पहेली टुकड़ा है, जब कि अन्य पहेली के साथ interlocked टुकड़े, सचमुच क्या करने जा रहा है उन पहेली टुकड़े करने के लिए कहा है। तो, उदाहरण के लिए, स्क्रैच सही है अब उसकी दुनिया के बीच में। मुझे आगे जाना है और चयन करने के लिए जा रहा हूँ अब, हम कहते हैं, मोशन श्रेणी, आप क्या करना चाहते हैं, तो same-- मोशन श्रेणी। और अब नोटिस मैं एक पूरी राशि यहाँ पहेली टुकड़े का गुच्छा कि, फिर से, एक तरह से है कि वे क्या कहते हैं। और मैं आगे जाना है और खींचें करने के लिए जा रहा हूँ यहीं पर स्थानांतरित ब्लॉक ड्रॉप। 

और नोटिस के रूप में जल्द ही है कि आप प्राप्त के रूप में "हरे झंडे के नीचे बंद क्लिक "बटन, नोटिस कैसे एक सफेद लाइन प्रतीत होता है, के रूप में यह लगभग है, हालांकि चुंबकीय, यह वहाँ जाना चाहता है। अभी चलते हैं, और यह तस्वीर होगी एक साथ और आकार मैच होगा। शायद लगभग और अब आप कर सकते हैं लगता है, जहां हम इस के साथ जा रहे हैं। 

आप स्क्रैच मंच पर नजर डालें तो यहाँ और अधिक से अधिक यह की चोटी पर लग रही है, आप एक लाल बत्ती देखेंगे, एक संकेत है, और एक हरे रंग का झंडा बंद करो। और मैं आगे जाने के लिए जा रहा हूँ और मेरी screen-- देखना बस एक पल के लिए, अगर तुम सकता है। मैं क्लिक करने के लिए जा रहा हूँ हरे रंग का झंडा अब ठीक है, और वह चले गए क्या 10 कदम प्रतीत होता है या 10 पिक्सल, 10 डॉट्स, स्क्रीन पर। 

और इतना है कि रोमांचक नहीं, लेकिन मुझे का प्रस्ताव यहां तक ​​कि इस शिक्षण के बिना, बस खुद अपने दम intuition-- चलो का उपयोग कर मेरे प्रस्ताव है कि आप यह पता लगाने के लिए कैसे सही मंच से स्क्रैच चलना है। उसके दाहिने ओर के लिए रास्ता बनाना है स्क्रीन, सही करने के लिए सभी तरह। मुझे आप एक पल दे या तो यह है कि के साथ कुश्ती। आप एक बार देख लेने के लिए चाहते हो सकता है ब्लॉक की अन्य श्रेणियों पर। ठीक है। तो बस संक्षिप्त करने के लिए, हम है जब हरे रंग का झंडा यहां क्लिक किया और 10 कदम कदम है केवल शिक्षा, हर बार जब मैं हरे रंग का झंडा क्लिक करें, क्या हो रहा है? वैसे, यह मेरे कार्यक्रम चल रहा है। इसलिए मैं यह कर सकता है शायद 10 बार मैन्युअल लेकिन यह एक छोटे से लगता है बिट hackish, तो बात करने के लिए जिससे मैं वास्तव में नहीं हूँ समस्या को सुलझाने। मैं सिर्फ फिर से कोशिश कर रहा हूँ और बार बार जब तक मैं इस तरह की गलती निर्देश प्राप्त करने के कि मैंने पहले प्राप्त करने के लिए निकल पड़े। 

लेकिन हम जानते हैं कि हमारे से pseudocode पहले वहाँ है कि पाशन की प्रोग्रामिंग में इस धारणा, कुछ फिर से और फिर से कर रहे हैं। और तो मैंने देखा कि आप का एक गुच्छा क्या पहेली टुकड़े के लिए पहुंच गया? दोहराओ जब तक। इसलिए हम कुछ कर सकता है जैसे जब तक दोहराएँ। और आप वास्तव में जब तक क्या दोहराने किया? 

ठीक। और मुझे एक है के साथ जाने दिया कुछ हद तक बस एक पल के लिए सरल। मुझे आगे जाना है और यह करते हैं। सूचना है कि, हो सकता है आप के रूप में नियंत्रण के तहत पता चला है, वहाँ इस दोहराने ब्लॉक है, जो यह पसंद नहीं लगता है कि बड़ा है। वहाँ में बहुत ज्यादा नहीं कमरा है उन दो पीले लाइनों के बीच। लेकिन आप में से कुछ के रूप में हो सकता है गौर यदि आप खींचें और ड्रॉप, सूचना है कि यह कैसे आकार को भरने के लिए बढ़ता है। 

और आप और भी अधिक रटना कर सकते हैं। यह सिर्फ अगर बढ़ रहा रखेंगे आप खींचें और इस पर होवर करें। और मैं क्या है पता नहीं है यहाँ सबसे अच्छा, तो चलो मुझे कम से कम पांच बार दोहराने के लिए उदाहरण के लिए, और फिर चरण के लिए वापस जाने के लिए और हरे रंग का झंडा क्लिक करें। और अब यह काफी नोटिस वहाँ नहीं है। 

अब आप में से कुछ के रूप में, प्रस्तावित विक्टोरिया अभी किया, 10 बार दोहराएँ। और कहा कि आम तौर पर करता है उसे सभी तरह से मिलता है, लेकिन वहाँ नहीं होगा एक और अधिक मजबूत हो मनमाने ढंग से बाहर लगाना से रास्ता कितने चालें बनाने के लिए? क्या एक बेहतर ब्लॉक हो सकता है दोहराने की तुलना में 10 गुना हो सकता है? 

हाँ, तो क्यों हमेशा के लिए कुछ करना नहीं है? और अब मुझे इस पहेली टुकड़ा चलते हैं वहाँ के अंदर और यह एक से छुटकारा मिलता है। अब कोई फर्क नहीं पड़ता, जहां स्क्रैच नोटिस शुरू होता है, वह किनारे करने के लिए चला जाता है। और शुक्र एमआईटी, जो शून्य बना देता है, बस सुनिश्चित करता है कि वह कभी नहीं पूरी तरह से गायब हो जाता है। तुम हमेशा उसकी पूंछ हड़पने कर सकते हैं। 

और बस intuitively, यही कारण है कि वह आगे बढ़ते रहना है? यहाँ क्या हो रहा है? उन्होंने बंद कर दिया है लगता है, लेकिन फिर अगर मैं और खींचें उठाओ वह वहाँ पर जाने के लिए इच्छुक रहता है। ऐसा क्यों है? सच में, एक कंप्यूटर का शाब्दिक है आप क्या करना है यह बताने में क्या करने जा। तो अगर आप यह बताया कि पहले करना बात हमेशा के लिए निम्नलिखित, 10 कदम ले जाते हैं, यह जा रहा है और जा रहा रखने के लिए जा रहा है जब तक मैं लाल बंद हस्ताक्षर मारा और इस कार्यक्रम को पूरी तरह बंद। 

तो भी अगर तुम नहीं किया यह करते हैं, मैं कैसे कर सकता है स्क्रैच चाल तेज कर परदे के पार? अधिक कदम, है ना? तो बजाय 10 कर के एक समय में, हम क्यों नहीं आगे बढ़ो और इसे बदलने के है-- क्या आप 50 propose-- होगा? तो अब मैं क्लिक करने के लिए हरी जा रहा हूँ झंडा, और वास्तव में, वह वास्तव में तेजी से चला जाता है। 

और यह, ज़ाहिर है, बस है एनीमेशन की एक मिसाल। एनीमेशन क्या है? यह सिर्फ आप दिखा रहा है मानव एक अभी भी छवियों की पूरी गुच्छा वास्तव में, वास्तव में, वास्तव में तेजी से। और इसलिए अगर हम सिर्फ कह रहे हैं उसे और अधिक कदम स्थानांतरित करने के लिए, हम सिर्फ प्रभाव के लिए हो रही हो, परिवर्तन जहां वह स्क्रीन पर है सभी को और अधिक तेजी से समय की प्रति इकाई। 

अब अगली चुनौती है कि मैं प्रस्तावित उसे किनारे से दूर उछाल के लिए गया था। और जानने के बिना क्या पहेली टुकड़े exist-- क्योंकि यह ठीक है आप के लिए नहीं मिलता है, तो challenge-- की अवस्था क्या तुम intuitively क्या करना चाहते हैं? कैसे हम उसे वापस उछाल होगा और आगे, छोड़ दिया और सही के बीच? 

हाँ। इसलिए हम किसी तरह की जरूरत हालत की है, और हम सशर्त है, इसलिए करने लगते हैं बात करते हैं, नियंत्रण श्रेणी के अंतर्गत। इन ब्लॉकों में से कौन सा हम शायद चाहते हैं? हाँ, शायद "है, तो।" तो नोटिस पीले रंग ब्लॉकों के बीच में है कि हम यहाँ है, वहाँ इस "अगर" है या इस "हैं, और" ब्लॉक कि करेंगे हमें यह करने के लिए एक निर्णय करने के लिए अनुमति देते हैं या कि क्या करना है। यहां तक ​​कि उन्हें घोंसला और आप कर सकते हैं कई बातें करने के लिए। या फिर आप यहां अभी तक नहीं किया है, तो सेंसिंग श्रेणी के लिए आगे बढ़ो और-- चलो देखते हैं अगर इसे यहाँ चलो। 

तो क्या ब्लॉक यहाँ मददगार हो सकती है अगर वह मंच से है पता लगाने के लिए? हाँ, यह है कि इन ब्लॉकों में से कुछ को नोटिस parametrized जा सकता है, तो बात करो। वे एक तरह से अनुकूलित किया जा सकता है, न एचटीएमएल के विपरीत कल विशेषताओं के साथ, जहां उन विशेषताओं तरह का एक टैग के व्यवहार को अनुकूलित। इसी तरह यहां, मैं इस मार्मिक हड़पने कर सकते हैं ब्लॉक और परिवर्तन और सवाल पूछना, आप माउस को छू रहे हैं कर्सर की तरह सूचक या आप किनारे छू रहे हैं? 

तो मुझ में जाने के लिए और यह करते हैं। मैं एक पल के लिए बाहर ज़ूम करने के लिए जा रहा हूँ। मुझे इस पहेली टुकड़ा ले लो इधर, इस पहेली टुकड़ा यह, और मैं गड़बड़ी करने जा रहा हूँ बस एक पल के लिए उन्हें। मैं इस स्थानांतरित करने के लिए जा रहा हूँ, दिल को छू लेने किनारे करने के लिए यह परिवर्तन और मैं गति के लिए जा रहा हूँ यह करते हैं। तो यहाँ कुछ तत्व हैं। मैं मैं सब कुछ मैं चाहता हूँ मिल गया है लगता है। 

किसी को कैसे प्रस्ताव करना चाहते हैं मैं कनेक्ट कर सकते हैं इन शायद नीचे से ऊपर होने की समस्या हल करने के लिए स्क्रैच इस कदम को सही करने के लिए छोड़ दिया करने के लिए सही दाएँ से बाएँ, प्रत्येक के लिए छोड़ दिया समय बस दीवार से उछल? मेरी क्या करने की इच्छा है? जो ब्लॉक में खोज करने के लिए कनेक्ट होना चाहिए "जब हरे रंग का झंडा पहली क्लिक किया?" 

ठीक है, तो साथ शुरू करते हैं "हमेशा के लिए।" आगे क्या अंदर चला जाता है? कोई और। ठीक है, कदम चलते हैं। ठीक है। फिर क्या? तो फिर यदि। और नोटिस, भले ही यह लग रहा है एक साथ कसकर बैठा, यह सिर्फ भरने के लिए विकसित होगा। यह बस में जहां मैं यह चाहता कूद जाएगा। 

और क्या मैं के बीच रखा है यदि और उसके बाद? शायद "अगर बढ़त को छू।" और नोटिस, फिर से, यह बहुत बड़ा है इसके लिए, लेकिन इसे भरने के लिए विकसित होगा। और फिर 15 डिग्री बारी? कितनी डिग्री? हाँ, तो 180 स्पिन जाएगा मुझे सभी तरह के आसपास। तो चलो देखते हैं अगर मैं यह अधिकार मिल जाने। मुझे बाहर ज़ूम करते हैं। 

मुझे खरोंच ऊपर खींचें करते हैं। तो वह एक छोटे से विकृत है अब, लेकिन वह ठीक है। मैं कैसे उसे आसानी से रीसेट कर सकते हैं? मैं थोड़ा धोखा देने के लिए जा रहा हूँ। तो मैं एक और जोड़ रहा हूँ ब्लॉक, अभी स्पष्ट होना करने के लिए। मैं उसे 90 डिग्री बात करना चाहता हूँ डिफ़ॉल्ट रूप से सही करने के लिए, इसलिए मैं सिर्फ उसे बताने जा रहा हूँ कि प्रोग्राम के लिए करते हैं। और अब हम चले। हम यह किया है लगता है। यह थोड़ा अजीब है, क्योंकि वह उल्टा चल रहा है। की एक बग है कि कहते हैं। यही कारण है कि एक गलती है। एक बग एक कार्यक्रम, एक में एक गलती है तार्किक त्रुटि है कि मैं, मानव, बना दिया। क्यों वह उल्टा हो रहा है? एमआईटी पेंच या मैंने किया था? 

हाँ, मेरा मतलब है, यह नहीं है एमआईटी गलती। वे मुझे एक पहेली टुकड़ा दिया कि डिग्री की कुछ संख्या बारी कहते हैं। और विक्टोरिया के सुझाव पर, मैं 180 डिग्री बदल रहा हूँ, जो सही अंतर्ज्ञान है। लेकिन 180 डिग्री सचमुच मोड़ 180 डिग्री मोड़ का मतलब है, और कहा कि वास्तव में नहीं है मैं चाहता हूँ, जाहिरा तौर पर। क्योंकि कम से कम वह में है इस दो आयामी दुनिया, इसलिए मोड़ वास्तव में जा रहा है उसे फ्लिप करने के लिए उल्टा। 

मैं शायद क्या ब्लॉक का उपयोग करना चाहते हैं इसके बजाय, आधारित तुम यहाँ क्या देख पर? हम यह कैसे तय कर सकता है? हाँ, तो हम बात कर सकता है विपरीत दिशा में। और वास्तव में यह भी है कि है पर्याप्त नहीं किया जा रहा है, क्योंकि हम केवल कठिन कोड कर सकते हैं बाईं या दाईं ओर इशारा करते हुए। 

आप जानते हैं कि हम क्या कर सकता है? ऐसा लगता है जैसे हम एक है सुविधा ब्लॉक यहाँ। अगर मैं में ज़ूम, देखना कुछ हम यहाँ पसंद है? तो ऐसा लगता है जैसे एक एमआईटी है अमूर्त यहाँ में बनाया। इस ब्लॉक के बराबर हो रहा है जो करने के लिए अन्य ब्लॉक, बहुवचन? 

यह एक ब्लॉक के बराबर हो रहा है ब्लॉक के इस पूरे तिकड़ी कि हम यहाँ है। तो यह पता चला मैं सरल कर सकते हैं मेरे द्वारा उस का सब से छुटकारा मिल रहा है कार्यक्रम और बस यहाँ में इस डाल दिया। और अब वह अभी भी एक छोटी सी है छोटी गाड़ी है, और कहा कि अब के लिए ठीक है। हम जानते हैं कि हो छोड़ देंगे। लेकिन मेरे कार्यक्रम भी है सरल, और यह भी, प्रतिनिधि होगा programming-- में एक लक्ष्य की आदर्श रूप में अपने कोड बनाने के लिए है सरल, संभव के रूप में कॉम्पैक्ट के रूप में, अभी भी रूप में किया जा रहा है, जबकि संभव के रूप में पठनीय। आप यह इतना संक्षिप्त बनाने के लिए नहीं करना चाहती समझते हैं कि यह मुश्किल है। 

लेकिन नोटिस मैं जगह है एक साथ तीन ब्लॉक, और कहा कि यकीनन एक अच्छी बात है। मैं दूर धारणा अनमना गए की जाँच कर रहे हैं कि क्या आप सिर्फ एक ब्लॉक के साथ किनारे पर। अब हम वास्तव में इस के साथ मजा कर सकते हैं। यह इतना जोड़ नहीं है बौद्धिक मूल्य है, लेकिन चंचल मूल्य। मैं आगे जाने के लिए जा रहा हूँ और इस ध्वनि यहाँ ले लो। तो मुझे आगे चलते हैं, और मुझे जाने एक पल के लिए कार्यक्रम बंद करो। मैं निम्नलिखित रिकॉर्ड करने के लिए जा रहा हूँ, मेरे माइक्रोफोन के लिए उपयोग की अनुमति है। 

ये रहा। आउच। चलो इस फिर से कोशिश करते हैं। ये रहा। ठीक है, मैं गलत बात दर्ज की गई। ये रहा। आउच। आउच। ठीक है। अब मैं उस से छुटकारा पाने की जरूरत है। ठीक है। 

एक तो अब मेरे पास है बस की रिकॉर्डिंग "आहा।" अब तो मैं जाने के लिए जा रहा हूँ आगे और इस "आहा कहते हैं।" मैं वापस जाने के लिए जा रहा हूँ मेरी स्क्रिप्ट के लिए, और अब सूचना है कि इस ब्लॉक कि कहा जाता है ध्वनि "म्याऊ" खेलने के लिए या ध्वनि खेलने "आहा।" मैं इस खींचें करने के लिए जा रहा हूँ, और जहां मैं अनोखा प्रभाव के लिए इस रखना चाहिए? हाँ, तो अब यह किस तरह का है छोटी गाड़ी है, क्योंकि अब इस block-- नोटिस कैसे इस "अगर किनारे पर, उछाल "घुन्ना की तरह है। इसलिए मैं इसे ठीक करने की जरूरत है। मुझे आगे जाना है और यह करते हैं। मुझे इस से छुटकारा मिलता है और वापस जाने के लिए हमारे मूल करने के लिए, और अधिक जानबूझकर कार्यक्षमता। तो "अगर बढ़त को छू, तो" मैं चाहता हूँ चालू करने के लिए, के रूप में विक्टोरिया का प्रस्ताव रखा, 180 डिग्री। और मैं खेलने के लिए करना चाहते हैं ध्वनि "आउच" वहाँ? 

हाँ, यह नोटिस के बाहर है कि पीले ब्लॉक। एक यह इसलिए भी है, हो सकता है बग, लेकिन मैं इसे देखा है। तो मैं यहाँ यह ऊपर खींचें करने के लिए जा रहा हूँ, और अब यह नोटिस के अंदर है "है।" तो "अगर" इस ​​प्रकार है जैसे हाथ-तरह की धब्बा कि केवल करने के लिए जा रहा है क्या इसके अंदर का रहा है। तो अब अगर मैं बाहर ज़ूम annoying-- का खतरा 

कंप्यूटर: आहा, आहा, आहा। 

डेविड मालन: और यह बस हमेशा के लिए पर जाना होगा। अब सिर्फ बातें तेजी लाने के लिए इधर, मुझे आगे जाना है और ऊपर खुला, चलो मुझे कुछ करने के लिए जाना जाने say-- क्लास से अपने खुद के सामान की। और मुझे खोलने का कहना है, इस चलो, एक हमारे शिक्षण साथियों में से एक ने बनाया कुछ साल पहले। तो आप में से कुछ याद हो सकता है पहल साल से इस खेल, और यह वास्तव में उल्लेखनीय है। हालांकि हम किया है कार्यक्रमों का सरलतम अब ठीक है, क्या इस पर विचार करते हैं वास्तव में की तरह लग रहा है। मुझे खेलने मारा। 

तो इस खेल में, हम एक है मेंढक, और तीर का उपयोग keys-- वह बड़ा कदम की तुलना में मैं remember-- लेता है मैं इस मेंढक पर नियंत्रण है। और लक्ष्य व्यस्त पार पाने के लिए है कारों में चलने के बिना सड़क। और अगर मैं यहाँ ऊपर जाने के see-- चलो, मैं एक लॉग से स्क्रॉल करने के लिए इंतज़ार करना होगा। यह एक बग की तरह लगता है। यह एक बग की तरह है। ठीक है। मैं यहाँ इस पर हूँ, वहाँ, और फिर तुम रख जब तक आप सभी मिल जा रहा लिली पैड के लिए मेंढक। अब इस लग सकता है सभी को और अधिक जटिल है, लेकिन हम तोड़ने की कोशिश करते हैं यह नीचे मानसिक रूप से और उसके घटक ब्लॉकों में मौखिक रूप से। तो वहाँ शायद एक पहेली है टुकड़ा है कि हम अभी तक नहीं देखा है लेकिन लगता है कि कीस्ट्रोक्स का जवाब है, बातें करने के लिए मैं कीबोर्ड पर मारा। 

तो वहाँ शायद किसी तरह का है ब्लॉक का कहना है कि, अगर कुंजी के बराबर होती है, तो Scratch-- के साथ कुछ करना हो सकता है यह 10 कदम इस तरह से चलते हैं। नीचे कुंजी दबाया जाता है, तो 10 कदम के लिए कदम इस तरह से, या बाएं कुंजी, 10 कदम के लिए कदम इस तरह से, 10 कदम है। मैं स्पष्ट रूप से एक मेंढक में बिल्ली बदल दिया है। तो यह है कि अभी कहाँ है स्क्रैच कॉल हम it-- पोशाक, के रूप में सिर्फ मेंढक की एक तस्वीर आयात किया। 

लेकिन और क्या हो रहा है? क्या कोड के अन्य लाइनों, क्या अन्य पहेली टुकड़े ब्लेक किया था, हमारे शिक्षण साथी, इस कार्यक्रम में उपयोग करते हैं, जाहिरा तौर पर? क्या सब कुछ बना रहा है move-- क्या प्रोग्रामिंग का निर्माण? 

मोशन, तो sure-- ब्लॉक ले जाने के लिए यकीन है। और क्या है कि इस कदम से ब्लॉक की सबसे अधिक संभावना है अंदर? हाँ, पाश किसी तरह का है, शायद एक हमेशा के लिए ब्लॉक, शायद एक दोहराने block-- ब्लॉक जब तक दोहराएँ। और कहा कि क्या लॉग बना रही है और लिली पैड और बाकी सब चाल आगे पीछे। यह सिर्फ अंतहीन हो रहा है। 

क्यों कारों में से कुछ हैं दूसरों की तुलना में तेजी से बढ़ रहा? उन कार्यक्रमों के बारे में अलग क्या है? हाँ, शायद उनमें से कुछ ले जा रहे हैं एक बार में अधिक कदम और उनमें से कुछ एक बार में कम कदम। और दृश्य प्रभाव बनाम धीमी गति से तेज है। 

आपको क्या लगता है क्या हुआ? जब मैं अपने मेंढक मिला सभी तरह सड़क और नदी के उस पार लिली पैड, कुछ पर उल्लेखनीय है कि क्या हुआ। जैसे ही मैंने किया है कि क्या हुआ? यह रुक गया। यही कारण है कि मेंढक बंद कर दिया, और मैं एक दूसरे मेंढक मिला है। तो क्या निर्माण होना चाहिए वहाँ इस्तेमाल किया, क्या सुविधा? 

हाँ, तो वहां किसी तरह का है "अगर" वहाँ भी हालत,। और यह बदल जाता है out-- हम this-- नहीं देखा था लेकिन वहाँ उस में अन्य ब्लॉकों है कह सकते हैं, अगर आप को छू रहे हैं स्क्रीन पर एक और बात, आप लिली पैड को छू रहे हैं "तो।" और फिर यह है कि जब हम है दूसरे मेंढक दिखाई देते हैं। तो फिर भी इस खेल निश्चित रूप से है बहुत पुराने है, यहां तक ​​कि पहली नज़र में, हालांकि इतना जा रहा है वहाँ on-- और ब्लेक दो मिनट में इस कोड़ा नहीं था, यह शायद उसे कई ले लिया घंटे के इस खेल बनाने के लिए उनकी स्मृति या वीडियो के आधार पर इसके बारे में पहले साल के संस्करण की। लेकिन इन छोटी चीजों के सभी अलगाव में स्क्रीन पर जा रहा ये बहुत ही सरल करने के लिए नीचे फोड़ा constructs-- आंदोलनों या बयान जैसे हम पर चर्चा की है, छोरों और स्थिति, और कहा कि इसके बारे में। वहाँ कुछ अन्य शौक़ीन सुविधाओं है। उनमें से कुछ विशुद्ध रूप से कर रहे हैं सौंदर्य या ध्वनिक, लगता है जैसे मैं बस के साथ खेला। लेकिन सबसे अधिक भाग के लिए, आप इस भाषा, स्क्रैच में है, मौलिक के सभी कि इमारत ब्लॉकों आप सी, जावा, जावास्क्रिप्ट में है, पीएचपी, रूबी, अजगर, और अन्य भाषाओं के किसी भी संख्या। स्क्रैच के बारे में कोई सवाल? ठीक है। इसलिए हम खरोंच करने के लिए गहरे में डुबकी नहीं होगा, यद्यपि आप इस सप्ताह के अंत में स्वागत है, आप बच्चे हैं, खासकर यदि या भतीजियों और भतीजे और इस तरह, उन्हें खरोंच करने के लिए लागू करने के लिए। यह वास्तव में एक अद्भुत चंचल है पर्यावरण के साथ, जैसा कि इसके लेखकों का कहना है, बहुत ऊँची छत। हालांकि हम साथ शुरू कर दिया बहुत कम स्तर के विवरण, आप वास्तव में काफी एक बिट कर सकते हैं इसके साथ, और यह शायद है ठीक है कि के एक प्रदर्शन। 

लेकिन अब कुछ और करने के लिए संक्रमण करते हैं परिष्कृत समस्याओं, अगर तुम जाएगा, "खोज" के रूप में जाना जाता है और "छँटाई," आम तौर पर और अधिक। हम इस फोन की किताब earlier-- यहाँ है था सिर्फ discussion-- के लिए एक दूसरे से हम खोज करने में सक्षम थे कि और अधिक कुशलता क्योंकि एक महत्वपूर्ण धारणा की। और अभी स्पष्ट होना करने के लिए, क्या धारणा मैं बना रहा था जब इस फोन की किताब के माध्यम से खोज? माइक स्मिथ में था कि फोन की किताब, हालांकि मैं संभाल करने में सक्षम होगा उसके बिना परिदृश्य वहाँ अगर मैं सिर्फ समय से पहले ही बंद कर दिया। पुस्तक वर्णमाला है। और वह एक बहुत ही उदार है धारणा यह है कि क्योंकि इसका मतलब है someone-- मैं तरह कर रहा हूँ एक कोने में कटौती की, जैसे मैं तेजी से किसी क्योंकि हूं वरना मेरे लिए कड़ी मेहनत का एक बहुत कुछ किया है। 

लेकिन क्या अगर फोन पुस्तक unsorted रहे थे? हो सकता है कि Verizon आलसी हो गया, बस फेंक दिया हर किसी का नाम और नंबर वहाँ में शायद क्रम में जिसमें वे फोन सेवा के लिए साइन अप। और कितना समय यह मुझे ले करता है माइक स्मिथ की तरह किसी को खोजने के लिए? 1,000 पेज फोन book-- कितने पृष्ठों मैं के माध्यम से देखने के लिए क्या करना है? 

उन सभी को। आप की तरह भाग्य से बाहर रहे। तुम सचमुच में हर देखने के लिए है पेज यदि फोन की किताब बस है बेतरतीब ढंग से हल किया। तुम भाग्यशाली हो और माइक मिल सकता है , क्योंकि वह बहुत पहले पृष्ठ पर पहले ग्राहक था फोन सेवा के आदेश। लेकिन वह पिछले है, भी हो सकता है। 

तो यादृच्छिक क्रम अच्छा नहीं है। ऐसा लगता है कि हम हल करना होगा फोन की किताब या सामान्य प्रकार का डेटा में कि हम भी दिया। हम वह कैसे कर सकते हैं? 

खैर, मुझे बस कोशिश करते हैं यहाँ एक सरल उदाहरण है। मुझे आगे जाना है और एक टॉस चलो बोर्ड पर कुछ संख्या। संख्या हम कर रहे हैं लगता है, हम कहते हैं कि, चार, दो, एक, तीन और दो। और, बेन, हमारे लिए इन नंबरों से सुलझाने। 

ठीक अच्छा। आपने ऐसा कैसे किया? ठीक है। तो छोटी से छोटी के साथ शुरू मूल्य और उच्चतम, और कहा कि वास्तव में अच्छा अंतर्ज्ञान है। और कहा कि हम महसूस करते हैं मनुष्य वास्तव में सुंदर हैं समस्याओं को सुलझाने में अच्छा इस तरह से, कम से कम जब डेटा अपेक्षाकृत छोटा है। जैसे ही आप सैकड़ों करने के लिए शुरू के रूप में संख्या की, संख्या के हजारों, नंबरों के लाखों लोगों की, बेन शायद यह काफी है कि तेजी से नहीं कर सकता है, यह सोचते हैं कि वहाँ थे संख्या में अंतराल। सुंदर एक लाख से गिनती करने के लिए आसान अन्यथा, बस समय लगता है। 

तो एल्गोरिथ्म यह लग रहा है जैसे बेन अब सिर्फ इस्तेमाल किया सबसे छोटी संख्या के लिए खोज रहा था। तो फिर भी हम इंसानों ले जा सकते हैं नेत्रहीन जानकारी का एक बहुत में, एक कंप्यूटर वास्तव में है एक छोटे से अधिक सीमित है। कंप्यूटर ही कर सकते हैं एक समय में एक बाइट को देखो या शायद एक time-- पर चार बाइट्स इन दिनों शायद एक time-- पर 8 बाइट्स लेकिन एक बहुत छोटी संख्या की एक निश्चित समय पर बाइट्स। 

इसलिए हम वास्तव में दिया है कि चार अलग-अलग मूल्यों here-- और आप कर के रूप में बेन के बारे में सोच सकते हैं अगर वह एक कंप्यूटर ऐसे थे पर blinders वह अन्य कुछ भी नहीं देख सकते हैं कि एक time-- पर एक नंबर से तो हम आम तौर पर जैसे ग्रहण करेंगे, अंग्रेजी, हम छोड़ दिया सही से पढ़ा हूँ। तो पहले नंबर बेन शायद देखा पर बहुत जल्दी चार थी और उसके बाद महसूस किया कि एक बहुत बड़ा है संख्या-मेरे तलाश में रहते हैं चलो। 

वहाँ दो है। एक मिनट रुकिए। दो चार से छोटी है। मैं याद करने जा रहा हूँ। दो अभी छोटी है। अब one-- वह भी बेहतर है। यही कारण है कि यहां तक ​​कि छोटे है। मैं के बारे में दो भूल जाने के लिए जा रहा हूँ और अभी एक याद है। 

और वह देख नहीं रोक सकता है? खैर, वह आधार पर कर सकता है इस सूचना के आधार पर, लेकिन वह बेहतर खोज चाहते हैं सूची के बाकी। क्योंकि सूची में क्या शून्य है, तो कर रहे थे? क्या होगा यदि एक नकारात्मक सूची में थे? वह ही जानता है कि उसका जवाब सही है, तो वह विस्तृत रूप है पूरी सूची की जाँच की। इसलिए हम इस के बाकी को देखो। कि Three-- समय की बर्बादी थी। अशुभ हो गया है, लेकिन मैं था अभी भी ऐसा करने के लिए सही है। और इसलिए अब वह संभवतः चुने गए सबसे छोटी संख्या और सिर्फ शुरुआत में इसे रखा सूची की, मैं यहाँ क्या करेंगे के रूप में। अब क्या आप आगे क्या करना था, भले ही आप इसके बारे में नहीं सोचा था कि लगभग इस सीमा तक? प्रक्रिया को दोहराएं, इसलिए पाश किसी तरह का। वहाँ एक परिचित विचार है। तो यहाँ चार है। कि वर्तमान में सबसे छोटी है। यही कारण है कि एक उम्मीदवार है। अब और नहीं। अब मैं दो देखा है। यही कारण है कि छोटी अगले तत्व है। Three-- कि छोटे नहीं है, इसलिए अब बेन दो से छीन कर सकते हैं। 

और अब हम इस प्रक्रिया को दोहराने, और बेशक तीन अगले बाहर निकाला जाता है। प्रक्रिया को दोहराएं। चार को बाहर निकाला जाता है। और अब हम नंबरों से बाहर रहे हैं, इसलिए सूची हल किया जाना चाहिए। 

और वास्तव में, यह एक औपचारिक एल्गोरिथ्म है। एक कंप्यूटर वैज्ञानिक होगा इस "चयन प्रकार," कॉल विचार किया जा रहा है एक प्रकार का iteratively-- फिर से सूची और फिर और फिर का चयन सबसे छोटी संख्या। और क्या अच्छा के बारे में ऐसा ही है यह सिर्फ इतना रफ़ू सहज है। ये इतना सरल है। और अगर आप एक ही दोहरा सकते हैं फिर से और फिर से आपरेशन। यह आसान है। 

इस मामले में यह तेजी से गया था, लेकिन कब तक यह वास्तव में ले करता है? चलो यह लग कर दूं और एक छोटे से अधिक थकाऊ महसूस करते हैं। तो एक, दो, तीन, चार, पांच से छह, सात, आठ, नौ, 10, 11, 12, 13, 14, 15, 16-- मनमाना संख्या। मैं तो बस अधिक इस चाहता था सिर्फ चार से अधिक समय। तो मैं एक पूरी मिल गया है संख्या का गुच्छा यह now-- यहां तक ​​कि कोई फर्क नहीं पड़ता क्या वे चलो are-- इस बारे में क्या सोचते हैं एल्गोरिथ्म वास्तव में की तरह है। 

मान लीजिए वहाँ वहाँ संख्या रहे हैं। फिर, क्या फर्क नहीं पड़ता वे कर रहे हैं, लेकिन वे यादृच्छिक रहे हैं। मैं बेन एल्गोरिथ्म आवेदन कर रहा हूँ। मैं सबसे छोटी संख्या का चयन करने की जरूरत है। मैं क्या करूं? और मैं शारीरिक रूप से करने के लिए जा रहा हूँ यह इस समय इसे बाहर कार्य करने के लिए करते हैं। देख रहे हैं, देख, देख, देख, देख रहे हैं। केवल समय मैं करने के लिए मिल द्वारा सूची के अंत कर सकते हैं मैं सबसे छोटी एहसास नंबर दो इस समय था। एक सूची में नहीं है। तो मैं दो नीचे डाल दिया। 

अब मुझे आगे क्या करना है? , की तलाश में लग रही है, देख, देख रहे हैं। अब मैं नंबर सात पाया, क्योंकि वहाँ इन numbers-- में अंतराल है लेकिन सिर्फ मनमाना। ठीक है। तो अब मैं नीचे सात डाल सकते हैं। की तलाश में लग रही है, देख रहे हैं। 

अब मैं, के मान रहा हूँ बेशक, ऐसा नहीं है कि बेन करता है अतिरिक्त रैम है, अतिरिक्त स्मृति, क्योंकि जाहिर है, मैं एक ही नंबर पर देख रहा हूँ। निश्चित रूप से मैं याद कर सकते थे उन लोगों की संख्या के सभी, और कहा कि बिल्कुल सच है। लेकिन अगर बेन सब याद है संख्या की वह देखा है, वह वास्तव में नहीं किया गया है मौलिक प्रगति वह पहले से ही है क्योंकि खोज करने की क्षमता बोर्ड पर नंबर के माध्यम से। सभी को याद नंबरों मदद नहीं करता है, क्योंकि वह अभी भी एक कंप्यूटर के रूप में कर सकते हैं केवल में, हम कहा है, एक नंबर लग समय पर। तो वहाँ धोखा का कोई प्रकार है तुम वहाँ उत्तोलन कर सकते हैं कि। 

तो वास्तव में, के रूप में मैं खोज की सूची में रखने के लिए, मैं सचमुच सिर्फ जा रहा रखने के लिए किया है इसके माध्यम से आगे और पीछे, बाहर तोड़ अगले सबसे छोटी संख्या। और जैसा कि आप किस तरह का अनुमान कर सकते हैं मेरे मूर्ख आंदोलनों से, इस बस बहुत हो जाता है बहुत जल्दी थकाऊ, और मैं वापस जा रहा होने लगते हैं और आगे, आगे और पीछे काफी एक सा है। अब निष्पक्ष हो, मैं जाने के लिए नहीं है काफी के रूप में, ठीक है, चलो निष्पक्ष होना see-- करते हैं, मैं काफी चलने के लिए नहीं है के रूप में कई कदम हर बार। क्योंकि, ज़ाहिर है, मैं के रूप में सूची से नंबर का चयन करें, शेष सूची कम हो रही है। 

और तो बारे में सोचते हैं कितने कदम मैं वास्तव में हूँ हर बार के माध्यम से traipsing। बहुत पहले की स्थिति में हम 16 नंबर था, और इतने maximally-- के बस जाने एक discussion-- के लिए ऐसा करते हैं मैं 16 के माध्यम से देखने के लिए किया था छोटी से छोटी संख्या खोजने के लिए। लेकिन एक बार मैं उखाड़ने सबसे छोटी संख्या है, कैसे लंबे पाठ्यक्रम के शेष सूची, था? सिर्फ 15। तो कितने संख्या बेन या मैं क्या ज़रूरत थी दूसरी बार के आसपास के माध्यम से देखने के लिए? 15, बस जाओ और छोटी से छोटी खोजने के लिए। लेकिन अब, बेशक, इस सूची है, भी, छोटे से पहले था। तो कितने कदम मैंने किया अगली बार ले जाना है? 14 और फिर 13 और उसके बाद 12, प्लस डॉट, डॉट, डॉट जब तक मैं सिर्फ एक साथ रह रहा हूँ। तो अब एक कंप्यूटर वैज्ञानिक होगा पूछते हैं, ठीक है, कि सब बराबर क्या करता है? यह वास्तव में कुछ ठोस बराबर होती है नंबर है कि हम निश्चित रूप से कर सकता है हिसाब से करते हैं, लेकिन हम बात करना चाहते हैं एल्गोरिदम की दक्षता के बारे में एक छोटे से अधिक formulaically, कैसे लंबी सूची है की स्वतंत्र। 

और इसलिए तुम जानते हो क्या? यह 16 है, लेकिन जैसा मैंने पहले कहा, चलो बस समस्या के आकार फोन n, जहाँ n कुछ संख्या है। हो सकता है कि यह 16 है, शायद यह है तीन, शायद यह एक लाख है। मुझे नहीं पता। मुझे परवाह नहीं है। मैं वास्तव में क्या चाहते है एक सूत्र है कि मैं कर सकता हूँ इस एल्गोरिथ्म तुलना करने के लिए उपयोग करें अन्य एल्गोरिदम के खिलाफ कि किसी का दावा कर सकता है बेहतर या बदतर हैं। 

तो यह पता चला है, और मैं केवल ग्रेड स्कूल से यह पता है, यह वास्तव में एक ही करने के लिए बाहर काम करता है कि प्लस n पर n के रूप में बात दो से अधिक एक। और यह, के बराबर करने के लिए होता है बेशक, n चुकता प्लस दो एन। तो अगर मैं एक सूत्र चाहता था कितने कदम के लिए सब पर तलाश में शामिल थे फिर से और फिर उन लोगों की संख्या की और फिर और फिर, मैं कहूँगा यह n चुकता है प्लस दो ओवर एन। लेकिन तुम जानते हो क्या? यह सिर्फ गन्दा लग रहा है। मैं सिर्फ सच में एक चाहते हैं बातों का सामान्य अर्थ। और तुम से याद हो सकता है हाई स्कूल है कि वहाँ सर्वोच्च क्रम अवधि की धारणा है। इन शर्तों में से कौन सा, एन चुकता, एन, या आधा, समय के साथ सबसे अधिक प्रभाव पड़ता है? बड़ा एन, हो जाता है जो इन सबसे ज्यादा मायने रखती है? 

दूसरे शब्दों में, अगर मैं प्लग एक लाख में, एन चुकता सबसे अधिक संभावना होने जा रहा है हावी कारक, एक लाख क्योंकि बार अपने आप में एक बहुत बड़ा है से अधिक एक लाख अतिरिक्त। तो तुम जानते हो क्या? इस तरह के एक रफ़ू बड़ा है नंबर आप एक नंबर वर्ग है। यह वास्तव में कोई फर्क नहीं है। हम सिर्फ पार जा रहे हैं कि बाहर और इसके बारे में भूल जाते हैं। और इसलिए एक कंप्यूटर वैज्ञानिक कहेंगे कि इस एल्गोरिथ्म की दक्षता n के आदेश पर है चुकता मैं वास्तव में एक सन्निकटन मतलब है। यह एक तरह से मोटे तौर n चुकता है। समय के साथ, बड़ा और बड़ा एन, हो जाता है यह क्या एक अच्छा अनुमान है दक्षता या दक्षता की कमी इस एल्गोरिथ्म के वास्तव में है। और मैं निकाले जाते हैं कि, ज़ाहिर है, वास्तव में गणित कर रही हैं। लेकिन अब मैं सिर्फ लहराते कर रहा हूँ मेरे हाथ, क्योंकि मैं तो बस इस एल्गोरिथ्म के एक सामान्य समझ चाहते हैं। 

तो एक ही तर्क का उपयोग, इस बीच, चलो एक और कलन विधि पर विचार करते हैं हम पहले से ही at-- रैखिक खोज देखा। जब मैं खोज रहा था फोन book-- के लिए यह छंटाई नहीं, खोज फोन के माध्यम से book-- हम कह रही है कि यह किया गया था रखा 1,000 कदम, या 500 कदम। लेकिन यह है कि सामान्यीकरण करते हैं। अगर वहाँ में एन पृष्ठों है फोन की किताब, क्या है समय चल रहा है या रैखिक खोज की दक्षता? यह के आदेश पर है कितने कदम लगाने के लिए माइक स्मिथ रैखिक खोज का उपयोग कर, पहले एल्गोरिथ्म, या यहां तक ​​कि दूसरी? 

सबसे खराब स्थिति, माइक में पुस्तक के अंत में है। तो अगर फोन की किताब 1,000 पृष्ठों की है, हम पिछली बार कहा था, सबसे खराब स्थिति में, यह मोटे तौर पर कैसे ले सकता है कई पन्नों माइक खोजने के लिए? 1,000 की तरह। यह एक ऊपरी बाध्य है। यह एक सबसे खराब संभव स्थिति है। लेकिन फिर, हम दूर जा रहे हैं 1,000 अब इस तरह की संख्या से। यह सिर्फ N है। 

तो तार्किक निष्कर्ष क्या है? एक फोन में माइक ढूँढना पुस्तक n पृष्ठों की है कि बहुत बुरी स्थिति में ले सकता है, कितने n के आदेश पर कदम? और वास्तव में एक कंप्यूटर वैज्ञानिक कहेंगे कि समय चल रहा है, या प्रदर्शन या दक्षता या अक्षमता, जैसे एक एल्गोरिथ्म की एक रेखीय खोज n के आदेश पर है। और हम एक ही आवेदन कर सकते हैं कुछ बाहर पार करने के तर्क के रूप में मैं सिर्फ दूसरे के लिए किया था एल्गोरिथ्म हम फोन की किताब के साथ की थी, जहां हम एक समय में दो पृष्ठों के लिए चला गया। 

तो 1,000 पेज फोन की किताब हो सकता है हमें लेने के लिए 500 पेज बदल जाता है, प्लस एक अगर हम थोड़ा पीछे दोगुना है। तो अगर एक फोन की किताब n पृष्ठों की है, लेकिन हम एक समय में दो पृष्ठों कर रहे हैं, कि मोटे तौर पर क्या है? दो से अधिक एन, इतना है कि दो से अधिक n की तरह है। लेकिन मैं दावे के एक बना पल पहले two-- के ऊपर है कि n कि सिर्फ n के रूप में ही की तरह है। यह सिर्फ एक निरंतर कारक है, कंप्यूटर वैज्ञानिकों कहेंगे। चलो केवल पर ध्यान केंद्रित चर, really-- समीकरण में सबसे बड़ी चर। 

तो रैखिक खोज, चाहे एक किया एक समय में पेज या एक बार में दो पृष्ठों, एक तरह से मौलिक ही है। यह n के आदेश पर अब भी है। लेकिन जैसा कि मैंने पहले मेरी तस्वीर के साथ दावा किया तीसरे एल्गोरिथ्म नहीं था कि रैखिक। यह एक सीधी रेखा नहीं था। ऐसा नहीं है कि वक्र रेखा थी, और बीजीय वहाँ फार्मूला क्या था? N-- का लॉग इसलिए n के आधार दो लॉग ऑन करें। और हम भी में जाने की जरूरत नहीं है लघुगणक पर ज्यादा विस्तार आज लेकिन अधिकांश कंप्यूटर वैज्ञानिकों नहीं होगा यहां तक ​​कि तुम बताओ कि क्या आधार है। सभी क्योंकि यह सिर्फ निरंतर कारक है, तो बात है, सिर्फ मामूली संख्यात्मक मतभेद। और इसलिए यह एक बहुत ही सामान्य हो जाएगा विशेष रूप से औपचारिक कंप्यूटर के लिए रास्ता एक बोर्ड पर वैज्ञानिकों या एक सफेद बोर्ड पर प्रोग्रामर वास्तव में उनका तर्क है जो एल्गोरिथ्म वे का प्रयोग करेंगे या क्या दक्षता के अपने एल्गोरिथ्म है। 

और यह जरूरी कुछ नहीं है आप किसी भी बड़े विस्तार से चर्चा करते हैं, लेकिन एक अच्छा प्रोग्रामर किसी को है जो एक ठोस, औपचारिक पृष्ठभूमि है। वह करने के लिए बात करने में सक्षम है आप जिस तरह के इस प्रकार में और वास्तव में बनाना के रूप में गुणात्मक तर्क के रूप में क्यों एक एल्गोरिथ्म या सॉफ्टवेयर का एक टुकड़ा दूसरे के लिए कुछ रास्ते में बेहतर है। क्योंकि आप निश्चित रूप से कर सकता है सिर्फ एक व्यक्ति के कार्यक्रम चलाने के लिए और सेकंड की संख्या गिनती यह कुछ नंबरों से हल करने के लिए ले जाता है, और आप कुछ चला सकते हैं दूसरे व्यक्ति के कार्यक्रम और संख्या की गिनती सेकंड की यह लेता है। लेकिन यह एक अधिक सामान्य तरीका है कि आप एल्गोरिदम का विश्लेषण करने के लिए उपयोग कर सकते हैं, अगर तुम जाएगा, बस पर कागज या सिर्फ मौखिक रूप से। बिना भी यह चल रहा है, बिना यहां तक ​​कि, नमूना आदानों की कोशिश कर रहा आप बस के माध्यम से कारण कर सकते हैं। और तो एक डेवलपर या यदि काम पर रखने के साथ उसे होने या उसके प्रकार की आप के लिए लोगों का तर्क यही कारण है कि उनके एल्गोरिथ्म, उनके रहस्य अरबों खोज के लिए सॉस के लिए वेब पृष्ठों के अपने कंपनी बेहतर है इन बहस के प्रकार के होते हैं वे आदर्श बनाने के लिए सक्षम होना चाहिए। या कम से कम इन कर रहे हैं चीजों की तरह उस पर चर्चा में आ जाएगा, एक बहुत ही औपचारिक चर्चा में कम से कम। ठीक है। इसलिए बेन कुछ प्रस्तावित चयन प्रकार का आह्वान किया। लेकिन मैं यह है कि वहाँ का प्रस्ताव करने जा रहा हूँ यह भी करने के अन्य तरीके। क्या मैं वास्तव में पसंद नहीं आया बेन एल्गोरिथ्म के बारे में कि वह चलने रखा है, या मुझे चलना रही है, आगे और पीछे और आगे और पीछे और आगे और पीछे। यदि इसके बजाय मैं क्या कर रहे थे इन नंबरों की तरह यहाँ कुछ और मैं सिर्फ एक से निपटने के लिए थे नंबर बदले में के रूप में मैं यह दिया हूँ? 

दूसरे शब्दों में, यहाँ है नंबरों की सूची। चार, एक, तीन, दो। और मैं निम्नलिखित क्या करने जा रहा हूँ। मैं नंबर डालने के लिए जा रहा हूँ जहां वे बल्कि संबंधित हैं उन्हें एक बार में एक को चुनने की तुलना में। दूसरे शब्दों में, यहाँ संख्या चार है। 

यहाँ अपने मूल सूची है। और मैं बनाए रखने के लिए जा रहा हूँ अनिवार्य रूप से एक नया यहाँ की सूची। इसलिए इस वर्ष सूची है। इस नई सूची है। मैं नंबर चार पहले देखते हैं। मेरी नई सूची के शुरू में खाली है, इसलिए यह तुच्छता मामला है कि चार अब सूची मिश्रित है। मैं तो बस, मैं नंबर दिया हूँ ले जा रहा हूँ और मैं अपने नए सूची में डाल रहा हूँ। 

इस नई सूची हल है? हाँ। यह बेवकूफ है सिर्फ एक है क्योंकि वहाँ तत्व है, लेकिन यह पूरी तरह से हल किया है। वहाँ जगह से बाहर कुछ भी नहीं है। यह और अधिक दिलचस्प है, इस एल्गोरिथ्म, जब मैं अगले कदम के लिए कदम। 

अब मैं एक है। एक तो, ज़ाहिर है, पर अंतर्गत आता है शुरुआत या इस नई सूची का अंत? शुरुवात। तो अब मैं कुछ काम करना है। मैं कुछ ले जा रहा है मेरे मार्कर के साथ स्वतंत्रता सिर्फ बातें ड्राइंग द्वारा जहां मैं उन्हें चाहते हैं, लेकिन लगता है कि वास्तव में नहीं है एक कंप्यूटर में सही। एक कंप्यूटर, जैसा कि हम जानते हैं, रैम, या रैंडम एक्सेस मेमोरी, और कहा कि एक बाइट है और एक और बाइट और एक अन्य बाइट। और तुम में से एक गीगाबाइट है तो रैम, आप एक अरब बाइट्स है, लेकिन वे एक ही स्थान में शारीरिक रूप से कर रहे हैं। तुम बस के चारों ओर सामान नहीं ले जा सकता बोर्ड पर ड्राइंग द्वारा जहाँ भी आप चाहते हैं। तो अगर मेरी नई सूची है स्मृति में चार स्थानों, दुर्भाग्य से चार है पहले से ही गलत जगह में। 

तो नंबर डालने के लिए एक मैं सिर्फ यह यहां आकर्षित नहीं कर सकते। इस स्मृति स्थान मौजूद नहीं है। कि धोखा होगा, और मैंने किया गया है कुछ मिनट के लिए pictorially धोखा दे यहाँ। तो सच में, मैं यहाँ एक डाल करना चाहते हैं, मैं अस्थायी रूप से चार की नकल है और फिर एक वहाँ डाल दिया। 

यह ठीक है, यह सही है, कि तकनीकी रूप से संभव है, लेकिन पता है कि अतिरिक्त काम है। मैं सिर्फ जगह में नंबर नहीं डाली। मैं पहली बार एक कदम था संख्या है, तो यह जगह में डाल दिया, इसलिए मैं एक तरह से काम करने की अपनी राशि दोगुनी हो। इसलिए इस बात का ध्यान रखें। 

लेकिन अब मैं इस तत्व के साथ काम कर रहा हूँ। अब मैं नंबर तीन हड़पने के लिए चाहते हैं। कहाँ है, जाहिर है, यह हैं करता है? के बीच में। मैं अब और धोखा नहीं दे सकती और सिर्फ यह वहाँ डाल दिया, क्योंकि, फिर से, इस स्मृति भौतिक स्थानों में है। तो मैं चार की नकल है और यहाँ पर तीन डाल दिया। कोई बड़ी बात नहीं। यह सिर्फ एक अतिरिक्त कदम है again-- बहुत सस्ती लगता है। 

लेकिन अब मैं दो पर चलते हैं। दो, ज़ाहिर है, यहां अंतर्गत आता है। अब आप कैसे देखना शुरू काम को ढेर कर सकते हैं। अब मुझे क्या करना है? हाँ, मैं चार कदम है, मैं तो तीन की नकल है, और अब मैं दो सम्मिलित कर सकते हैं। और इस के साथ पकड़ एल्गोरिथ्म, काफी दिलचस्प है, कि हम एक और अधिक चरम है लगता है इस मामले में जहां यह आठ, सात का कहना है कि चलो छह, पांच, चार, तीन, दो, एक। यह कई संदर्भों में, है, सबसे खराब स्थिति, क्योंकि रफ़ू बात सचमुच पीछे की ओर है। 

यह सच नहीं है बेन कलन विधि को प्रभावित, क्योंकि बेन के चयन में क्रमबद्ध वह रखने के लिए जा रहा है आगे और पीछे सूची के माध्यम से चल रहा है। और क्योंकि वह हमेशा देख रहा था पूरे शेष सूची के माध्यम से, कोई फर्क नहीं पड़ता कि जहां तत्व हैं। लेकिन मेरे डालने के साथ इस मामले में approach-- की इस कोशिश करते हैं। 

तो एक, दो, तीन, चार, पांच, छह, सात, आठ। एक दो तीन चार, पांच, छह, सात, आठ। मैं आठ लेने के लिए जा रहा हूँ, और मैं कहाँ रखा है? खैर, मेरे सूची की शुरुआत में, क्योंकि इस नई सूची हल है। और मैं इसे बाहर पार। 

मैं सात कहाँ रखा है? इसे रफू करें। यह वहाँ से जाने की जरूरत है ताकि मैं कुछ नकल करना है। और अब सात यहाँ जाता है। अब मैं छह पर चलते हैं। अब यह और भी अधिक काम है। 

आठ यहाँ से जाना है। सात यहाँ से जाना है। अब छह यहां जा सकते हैं। अब मैं पाँच हड़पने। अब आठ जाना पड़ता है इधर, सात यहाँ से जाना है, छह यहाँ से जाना है, और अब पांच और दोहराने। और मैं बहुत ज्यादा कर रहा हूँ यह लगातार बढ़ रहा है। 

तो अंत में, इस algorithm-- हम करेंगे इसे कहते हैं प्रविष्टि वास्तव में sort-- बहुत काम की है, भी है। यह सिर्फ अलग है बेन की तुलना में जिस तरह का काम। बेन के काम मुझे जा रहा था आगे और पीछे हर समय, छोटी अगले का चयन तत्व फिर से और फिर से। इसलिए यह काम के इस बहुत ही दृश्य तरह का था। 

यह अन्य एल्गोरिथ्म, जो अब भी है correct-- यह नौकरी मिल जाएगी done-- सिर्फ काम की राशि बदलता है। ऐसा लगता है कि शुरू में आप कर रहे हैं की तरह बचत, क्योंकि आप सिर्फ रहे हैं प्रत्येक तत्व के साथ काम अप सामने सब चलने के बिना बेन की तरह सूची के माध्यम से रास्ता था। लेकिन समस्या यह है विशेष रूप से इन में पागल मामलों में जहां यह सब पीछे की ओर है, आप बस की तरह कर रहे हैं कड़ी मेहनत स्थगित जब तक आप अपनी गलतियों को ठीक करने के लिए है। 

और अगर ऐसा है तो आप यह कल्पना कर सकते आठ और सात और छह और पांच और बाद में चार और तीन और दो सूची के माध्यम से अपने तरीके से चलती है, हम बस बदल दिया है काम के प्रकार हम कर रहे हैं। इसके बजाय पर इसे करने का मेरा चलना की शुरुआत, मैं सिर्फ यह कर रहा हूँ हर चलना के अंत। तो यह इस एल्गोरिथ्म है कि पता चला है, भी है, आम तौर पर कहा जाता है प्रविष्टि प्रकार, आदेश n चुकता पर भी है। यह वास्तव में कोई बेहतर है, कोई बेहतर सब पर। 

हालांकि, वहाँ एक तिहाई दृष्टिकोण है मैं हमारे विचार करने के लिए प्रोत्साहित करेगा, जो इस प्रकार है। तो सादगी के लिए अपनी सूची लगता है, फिर, चार, एक, तीन, सिर्फ चार नंबर two--। बेन, अच्छा अंतर्ज्ञान था अच्छा मानव अंतर्ज्ञान इससे पहले, जिसके द्वारा हम पूरे तय अंततः प्रविष्टि प्रकार की सूची। मैं हमारे साथ राजी कर लिया। लेकिन हम विचार करते हैं इस सूची को ठीक करने के लिए सबसे आसान तरीका है। 

इस सूची में हल नहीं है। क्यूं कर? अंग्रेजी में, क्यों समझा यह वास्तव में हल नहीं है। क्या यह नहीं मतलब है हल किया जा करने के लिए? 

छात्र: यह अनुक्रमिक नहीं है। 

डेविड मालन: अनुक्रमिक नहीं। मुझे एक उदाहरण दे। 

छात्र: उन्हें क्रम में डाल दिया। 

डेविड मालन: ठीक है। मुझे एक और अधिक विशिष्ट उदाहरण दे। 

छात्र: आरोही क्रम। डेविड मालन: आरोही क्रम नहीं। अधिक सटीक हो। मैं तुम्हें आरोही से क्या मतलब पता नहीं है। क्या गलत है? 

छात्र: की छोटी से छोटी संख्या पहला अंतरिक्ष में नहीं है। 

डेविड मालन: सबसे छोटी संख्या के नहीं पहले अंतरिक्ष में। थोड़ा और विस्तार में बताओ। मैं पर पकड़ने के लिए शुरू कर रहा हूँ। हम भरोसा कर रहे हैं, लेकिन क्या आदेश यहाँ से बाहर है? 

छात्र: संख्यात्मक अनुक्रम। डेविड मालन: संख्यात्मक अनुक्रम। रखने का हर किसी की तरह यह बहुत ही उच्च स्तर here--। बस सचमुच मुझे बताओ कि क्या एक पांच वर्षीय सकता है की तरह गलत है। 

छात्र: प्लस एक। 

डेविड मालन: वह क्या है? 

छात्र: प्लस एक। 

डेविड मालन: क्या आप प्लस एक मतलब है? मुझे एक अलग पांच वर्षीय दीजिए। गलत है, माँ क्या है? गलत, पिताजी क्या है? तुम क्या मतलब है इस हल नहीं है? 

छात्र: यह सही जगह नहीं है। 

डेविड मालन: क्या है न सही जगह में? 

छात्र: चार। डेविड मालन: ठीक है, अच्छा है। तो चार जहां यह होना चाहिए नहीं है। विशेष रूप से, यह सही है? चार और एक, पहले दो नंबर मैं देख रहा हूँ। क्या यह सही है? नहीं, वे आदेश से बाहर रहे हैं, है ना? वास्तव में, अब लगता है एक कंप्यूटर के बारे में भी है। यह केवल शायद एक पर देख सकते हैं, once-- पर शायद दो बातें और वास्तव में केवल एक ही बात एक समय में है, लेकिन यह कर सकते हैं तो कम से कम एक बात पर तो देखो ठीक उसके बगल में अगली बात। 

तो क्रम में इन कर रहे हैं? बिलकूल नही। तो तुम जानते हो क्या? क्यों हम बच्चे नहीं लेते इस समस्या फिक्सिंग कदम बजाय इन फैंसी कर के बेन, जहां की तरह एल्गोरिदम वह की तरह से यह तय है सूची के माध्यम से पाशन इसके बजाय मैं क्या किया कर रही है, जहां की के रूप में हम चले मैं बस की तरह यह तय हो? चलो बस सचमुच टूट order-- संख्यात्मक क्रम की धारणा, आप उसे जो चाहें कहें-- इन जोड़ो में तुलना में। 

चार और एक। यह सही आदेश है? तो चलो कि तय करते हैं। एक और चार, और फिर हम बस कॉपी करेंगे। ठीक है, अच्छा है। मैं एक और चार तय की। तीन और दो? नहीं। मेरे शब्दों को मेरी उंगलियों से मेल करते हैं। चार और तीन? 

यह क्रम में नहीं है, तो मैं जा रहा हूँ एक, तीन, चार, दो करने के लिए। ठीक अच्छा। अब चार और दो? हम यह भी तय की जरूरत है। तो एक, तीन, दो, चार। इसलिए इसे हल किया जाता है? नहीं है, लेकिन यह करीब क्रमबद्ध है? 

ऐसा नहीं है, क्योंकि हम यह तय गलती की है, हम इस गलती तय, और हम इस गलती को तय की। इसलिए हम तीन गलतियों यकीनन तय की। अभी भी वास्तव में हल नहीं लगती है, लेकिन यह निष्पक्ष हल करने के लिए करीब है क्योंकि हम उन गलतियों से कुछ तय की। 

अब मैं आगे क्या करना है? मैं एक तरह की सूची के अंत पर पहुंच गया। मैं तय कर दी है लग रहा था सभी गलतियों, लेकिन नहीं। क्योंकि इस मामले में, कुछ नंबरों करीब bubbled हो सकता है दूसरे नंबर करने के लिए कि अभी भी क्रम से बाहर हैं। तो चलो इसे फिर से करते हैं, और मैं हूँ सिर्फ जगह में इस समय इसे करते हैं। एक और तीन? यह ठीक है। तीन और दो? बेशक नहीं, तो चलो कि बदल सकते हैं। तो दो, तीन। तीन और चार? और अब चलो बस हो विशेष रूप से यहां पंडिताऊ। यह हल है? तुम मनुष्यों को पता है यह हल है। 

मैं फिर से कोशिश करनी चाहिए। तो ओलिविया मैं फिर से कोशिश प्रस्ताव है। क्यूं कर? एक कंप्यूटर नहीं है क्योंकि हमारे मानव आंखों की विलासिता की बस back-- ठीक glancing, मैं कर रहा हूँ। कैसे कंप्यूटर का निर्धारण करता है उस सूची में अब हल है? यंत्रवत्। 

मैं के माध्यम से जाना चाहिए एक बार फिर, और तभी मैं नहीं बनाते हैं / किसी भी गलती पा सकते हैं मैं तो, हां कंप्यूटर के रूप में समाप्त हम जाने के लिए अच्छा कर रहे हैं। तो एक और दो, दो और तीन, तीन और चार। अब मैं निश्चित रूप से कह सकते हैं कि यह है हल, क्योंकि मैं कोई बदलाव नहीं किया। अब यह एक बग हो सकता है और सिर्फ होगा यदि मूर्ख मैं, कंप्यूटर, वे एक ही सवाल पूछा फिर से अलग अलग जवाब की उम्मीद थी। ऐसा नहीं होना चाहिए। 

और इसलिए अब सूची हल है। दुर्भाग्य से, चलाने का समय इस एल्गोरिथ्म भी चुकता n है। क्यूं कर? क्योंकि तुम n संख्या, और में सबसे खराब स्थिति आप n संख्या बढ़ना है एन बार क्योंकि तुम जा रहा रखने के लिए किया है वापस जाँच करने के लिए और संभावित ठीक इन नंबरों। और हम एक अधिक कर सकते हैं औपचारिक विश्लेषण भी। 

तो यह कहते हैं कि हम ले लिया है सब है तीन अलग अलग दृष्टिकोण, एक उनमें से तुरंत सहज ज्ञान युक्त बेन से बल्ले से मेरा सुझाव प्रविष्टि के लिए इस एक के प्रकार जहां आप की तरह की दृष्टि खो पेड़ के शुरू के लिए जंगल। लेकिन फिर अगर आप एक कदम वापस ले, देखा, तो हम छँटाई धारणा तय कर दी है। तो यह है, हिम्मत का कहना है एक निचले स्तर शायद उन अन्य की तुलना में कुछ एल्गोरिदम, लेकिन चलो देखते हैं अगर हम कल्पना नहीं कर सकते इस के माध्यम से इन। 

तो यह कुछ अच्छा है सॉफ्टवेयर है कि किसी को रंगीन सलाखों है कि का उपयोग कर लिखा है हमारे लिए निम्न कार्य करने के लिए जा रहा है। इन सलाखों में से प्रत्येक एक नंबर का प्रतिनिधित्व करता है। लम्बे बार, बड़ा संख्या, छोटे बार, नंबर छोटे। इसलिए आदर्श रूप में हम एक अच्छा पिरामिड चाहते हैं जहां यह छोटे शुरू होता है और बड़ा हो जाता है, और कहा कि इसका मतलब यह होगा इन सलाखों के अनुसार क्रमबद्ध हैं। इसलिए मुझे लगता है, आगे बढ़ो और चयन करने के लिए जा रहा हूँ उदाहरण के लिए, बेन एल्गोरिथ्म first-- चयन तरह। 

और नोटिस क्या कर रहा है। जिस तरह से वे के लिए चुना है इस एल्गोरिथ्म कल्पना कि, जैसे मैं था मेरी सूची के माध्यम से चल रहा है, इस कार्यक्रम चल रहा है नंबरों की अपनी सूची के माध्यम से, गुलाबी प्रत्येक में प्रकाश डाला कि यह देख रही है संख्या। और क्या अभी ऐसा करने के बारे में है? 

सबसे छोटी संख्या है कि मैं या बेन अचानक पाया सूची की शुरुआत करने के लिए ले जाया जाता है। और वे बेदखल किया नोटिस संख्या है कि वहां गया था, और कहा कि पूरी तरह से ठीक है। मैं विस्तार के उस स्तर में नहीं मिला है। लेकिन हम डाल करने की आवश्यकता कहीं न कहीं उस नंबर, तो हम सिर्फ यह करने के लिए ले जाया गया खुली जगह में बनाया गया था कि। इसलिए मैं इस तेजी लाने के लिए जा रहा हूँ अप, क्योंकि अन्यथा यह जल्दी बहुत कठिन हो जाता है। एनीमेशन वहाँ speed-- हम चले। तो अब एक ही सिद्धांत मैं आवेदन किया गया है, लेकिन आप , एल्गोरिथ्म महसूस करने के लिए अगर आप शुरू कर सकते हैं होगा, या यह एक छोटे से अधिक स्पष्ट रूप से देखते हैं। और इस एल्गोरिथ्म के प्रभाव पड़ता है अगले छोटी तत्व का चयन, ताकि आप को शुरू करने के लिए जा रहे हैं यह बाईं तरफ रैंप देखें। और प्रत्येक चलना पर, मैं के रूप में प्रस्तावित है, यह एक छोटे से कम काम करता है। यह सभी तरह से जाना नहीं है वापस सूची के बाईं अंत करने के लिए, क्योंकि यह पहले से ही उन क्रमबद्ध हैं जानता है। तो यह एक तरह से लगता है ऐसा लगता है जैसे तेजी, भले ही हर कदम है समय का एक ही राशि ले रही है। वहाँ सिर्फ कम कदम शेष है। और अब आप की तरह महसूस कर सकते हैं एल्गोरिथ्म यह के अंत की सफाई, और वास्तव में अब यह हल है। 

तो प्रविष्टि प्रकार सब कुछ किया है। मैं सरणी फिर से randomize करने की जरूरत है। और मैं सिर्फ नोटिस कर सकते हैं यह randomizing रखने के लिए, और हम में से एक सन्निकटन मिल जाएगा एक ही दृष्टिकोण, प्रविष्टि तरह। मुझे यहाँ यह करने के लिए धीमा। की है कि अधिक से शुरू करते हैं। रूक जा। 

चार को छोड़ दें। हम वहाँ चलें। वे सरणी अनियमित करें। और यहाँ हम प्रविष्टि प्रकार go--। प्ले। सूचना है कि यह प्रत्येक के साथ काम कर रहा है तत्व यह सही दूर का सामना करना पड़ता, लेकिन अगर यह अंतर्गत आता है गलत जगह नोटिस काम हो गया है कि सब के सब। हम और अधिक स्थानांतरण रखना है और अधिक तत्वों जगह बनाने के लिए एक के लिए हम जगह में डाल करना चाहते हैं। 

इसलिए हम पर ध्यान केंद्रित कर रहे हैं केवल सूची के बाएँ छोर। नोटिस हम भी हम at-- देखा नहीं है गुलाबी किसी भी चीज़ में नहीं डाला है दांई ओर। हम बस के साथ काम कर रहे हैं समस्याओं को हम जाने के रूप में, लेकिन हम में से एक बहुत पैदा कर रहे हैं अभी भी खुद के लिए काम करते हैं। और हम इस में तेजी लाने, इसलिए यदि अब पूरा करने के लिए जाना है, यह वास्तव में यह करने के लिए एक अलग अनुभव होता है। यह सिर्फ बाएँ छोर पर ध्यान केंद्रित कर रही है, लेकिन needed-- के रूप में एक छोटे से अधिक काम कर रही है चौरसाई चीजों की तरह से अधिक है, बातें फिक्सिंग, लेकिन साथ अंततः निपटने एक समय में प्रत्येक तत्व एक जब तक हम अच्छी तरह से the-- करने के लिए मिलता है, हम सभी जानते हैं कि यह कैसे खत्म हो रहा है, तो यह थोड़ा underwhelming शायद है। 

लेकिन end-- में सूची spoiler-- हल किया जा रहा है। तो चलो एक पिछले एक को देखो। हम तो बस अब छोड़ नहीं सकते। हम बस पहुँच गए। दो जाने के लिए, एक जाने के लिए। और देखा। अति उत्कृष्ट। 

तो अब एक पिछले एक करते हैं, फिर से randomizing बुलबुला प्रकार के साथ। और यहाँ नोटिस, खासकर अगर मैं यह धीमी गति से नीचे, इस के माध्यम से swooping रखता है। लेकिन यह सिर्फ नोटिस जोड़ो में बनाता है स्थानीय समाधान के comparisons-- तरह। लेकिन जैसे ही हम करने के लिए मिल के रूप में गुलाबी रंग में सूची के अंत में, क्या फिर से ऐसा करने के लिए जा रहा है? हाँ, यह करने के लिए जा रहा है शुरू से अधिक है, क्योंकि यह केवल निश्चित जोड़ो में गलतियों। और कहा कि अभी तक दूसरों से पता चला है हो सकता है। और अगर ऐसा है तो आप इस तेजी लाने, तुम हूँ देखते हैं कि, ज्यादा के रूप में नाम का अर्थ है, छोटे elements-- या यों कहें, बड़ा elements-- शुरू कर रहे हैं बुलबुले के लिए शीर्ष करने के लिए, अगर तुम जाएगा। और छोटे तत्व हैं बुलबुले के लिए शुरू बाईं ओर नीचे। और वास्तव में, उस तरह का है के रूप में अच्छी तरह से दृश्य प्रभाव। और इसलिए इस को खत्म हो जाएगा परिष्करण एक बहुत ही इसी तरह, भी। 

हम ध्यान केन्द्रित करने के लिए नहीं है यह विशेष रूप से एक पर। मुझे इस अब भी खुला है, चलो। वहाँ कुछ अन्य छँटाई एल्गोरिदम है दुनिया में है, जिनमें से कुछ यहां कब्जा कर रहे हैं। और विशेष रूप से शिक्षार्थियों के लिए जो नहीं हैं जरूरी दृश्य या गणितीय, जैसा कि हम पहले किया था, हम कर सकते हैं यह भी audially ऐसा करने हम इस के साथ एक ध्वनि सहयोगी हैं। एक और सिर्फ मनोरंजन के लिए, यहाँ है कुछ अलग एल्गोरिदम, विशेष रूप से उनमें से एक है और आप कर रहे हैं नोटिस के लिए बुलाया जा रहा "मर्ज तरह।" 

यह वास्तव में एक मौलिक है बेहतर एल्गोरिथ्म, ऐसी है कि तरह विलय, में से एक लोगों को आप कर रहे हैं के बारे में, देखने के लिए n के आदेश चुकता नहीं है। यह आदेश n के समय के प्रवेश पर है n, जो वास्तव में छोटे होते हैं और इस प्रकार है उन तीन अन्य की तुलना में तेजी। और वहाँ अन्य एक जोड़ी है मूर्ख हैं कि हम देखेंगे। 

यहाँ तो हम कुछ ध्वनि के साथ चलते हैं। इस प्रविष्टि प्रकार का है, तो फिर से है यह सिर्फ तत्वों के साथ काम कर रहा है वे आते हैं। यह बुलबुला तरह है, तो यह है उन्हें एक बार में जोड़े पर विचार। और फिर, सबसे बड़ी तत्वों शीर्ष करने के लिए बुदबुदाती कर रहे हैं। 

अगले ऊपर चयन तरह। यह बेन एल्गोरिथ्म, जहां है फिर वह iteratively का चयन किया है अगले छोटी तत्व। और फिर, अब आप वास्तव में सुन सकते हैं यह तेजी से ऊपर है, लेकिन अब तक केवल में के रूप में यह और कम से कम कर रहा है प्रत्येक यात्रा पर काम करते हैं। यह तेजी से एक है, की तरह विलय, नंबरों के समूहों छँटाई है जो एक साथ और फिर उन्हें संयोजन। तो बाएं look-- आधे पहले से ही हल है। 

अब यह ठीक आधे छँटाई है, और अब यह उन्हें एक में गठबंधन करने के लिए जा रहा है। यह कुछ ऐसा कहा जाता है "सूक्ति तरह।" और आप देख सकते हैं कि किस तरह का यह आगे और पीछे जा रहा है एक छोटा सा काम यहाँ फिक्सिंग और वहाँ से पहले ही नए काम के लिए आय। और बस। वहाँ एक और प्रकार है, जो है वास्तव में सिर्फ शैक्षिक उद्देश्यों के लिए, "बेवकूफ प्रकार," जो लेता बुलाया अपने डेटा, यह बेतरतीब ढंग से तरह, और फिर जाँच करता है अगर यह हल है। और अगर ऐसा नहीं है, यह फिर से तरह यह बेतरतीब ढंग से, चेक, अगर यह हल है, और अगर दोहराता नहीं। और सिद्धांत में, संभवतया यही नहीं, पूरा हो जाएगा लेकिन काफी समय की एक बिट के बाद। यह सबसे अधिक नहीं है एल्गोरिदम के कुशल है। उन पर तो कोई प्रश्न विशेष एल्गोरिदम या कुछ भी वहाँ भी संबंधित है,? 

खैर, चलो अब क्या सब के अलावा तंग इन लाइनों है कि मैं ड्राइंग गया है रहे हैं और क्या मैं कंप्यूटर मान रहा हूँ हुड के नीचे क्या कर सकते हैं। मैं तर्क होता है इन नंबरों के सभी कि मुझे लगता है वे प्राप्त करने की आवश्यकता drawing-- रखने स्मृति में कहीं संग्रहीत। हम इस आदमी से छुटकारा अब भी मिल जाएगा। 

एक में स्मृति की तो एक टुकड़ा computer-- इसलिए रैम DIMM है क्या हम कल, दोहरी के लिए खोज इनलाइन स्मृति module-- इस तरह दिखता है। और इन छोटे काले चिप्स के प्रत्येक बाइट्स की कुछ संख्या है, आम तौर पर है। और फिर सोने की पिन की तरह हैं तारों कि यह कंप्यूटर से कनेक्ट करते हैं, और हरी सिलिकॉन बोर्ड सिर्फ है क्या सब कुछ सब एक साथ रहता है। तो यह वास्तव में क्या मतलब है? मैं एक तरह से यह एक ही तस्वीर खींचना है, तो सादगी के लिए लगता हैं कि इस DIMM, दोहरी इनलाइन स्मृति मॉड्यूल, राम के एक गीगाबाइट, की एक गीगाबाइट है स्मृति है, जो कितने बाइट्स कुल है? एक गीगाबाइट कितने बाइट्स है? उस से भी अधिक। 1,124 किलो, 1000 है। मेगा मिलियन है। Giga एक अरब है। 

मैं झूठ बोल रहा हूँ? हम भी लेबल पढ़ सकते हैं? यह वास्तव में 128 है गीगाबाइट है, तो यह और भी है। लेकिन हम इस नाटक करेंगे सिर्फ एक गीगाबाइट है। तो इसका मतलब है कि वहाँ एक अरब है स्मृति के बाइट्स मेरे लिए उपलब्ध या 8 अरब बिट्स, लेकिन हम जा रहे हैं बाइट्स के मामले में अब बात करते हैं, आगे बढ़ते हुए। 

तो क्या इसका मतलब है कि यह है एक बाइट, यह एक और बाइट है, यह एक और बाइट है, और अगर हम वास्तव में चाहते थे विशिष्ट हम करना होगा होना करने के लिए एक अरब से थोड़ा चौकों आकर्षित। लेकिन इसका क्या मतलब है? खैर, मुझे बस ज़ूम इस तस्वीर पर। मैं कुछ मिल गया है कि लग रहा है इस तरह अब यह है कि चार बाइट्स है। 

और इसलिए मैं चार की संख्या में यहाँ डाल सकता है। एक दो तीन चार। या मैं चार पत्र या प्रतीकों डाल सकता है। "अरे!" सही वहाँ जा सकते हैं, पत्र के प्रत्येक क्योंकि, हम पहले भी चर्चा की, प्रतिनिधित्व किया जा सकता आठ बिट्स या ASCII या एक बाइट के साथ। तो दूसरे शब्दों में, आप कर सकते हैं 8 अरब चीजों के अंदर डाल स्मृति के इस एक छड़ी की। अब क्या यह चीजों को वापस डाल करने के लिए क्या मतलब है इस तरह स्मृति में वापस करने के लिए वापस करने के लिए? यह वही है जो एक प्रोग्रामर है एक "सरणी।" कहेंगे एक कंप्यूटर प्रोग्राम में, आप नहीं लगता है अंतर्निहित हार्डवेयर के बारे में, प्रति से। तुम बस अपने आप के बारे में सोच के रूप में होने एक अरब बाइट्स कुल करने के लिए उपयोग, और आप कुछ भी आप इसके साथ चाहते हैं। लेकिन सुविधा के लिए यह आम तौर पर उपयोगी है अपनी याददाश्त सही रखने के लिए इस तरह एक दूसरे के बगल में। तो अगर मैं this-- पर ज़ूम क्योंकि हम निश्चित रूप से नहीं जा रहे हैं एक अरब से थोड़ा squares-- आकर्षित करने के लिए चलो लगता है कि इस बोर्ड का प्रतिनिधित्व करते हैं स्मृति की है कि छड़ी अब। और मैं बस के रूप में के रूप में कई आकर्षित करेंगे मेरी मार्कर मुझे यहाँ दे रही समाप्त होता है। तो अब हम एक छड़ी है बोर्ड पर स्मृति की कि मिल गया है एक, दो, तीन, चार, पांच, छह, एक, दो, तीन, चार, पांच, छह, की तो 42 बाइट्स seven-- स्क्रीन पर स्मृति कुल। धन्यवाद। हाँ, मेरे गणित सही किया। यहाँ स्मृति की तो 42 बाइट्स। तो यह वास्तव में क्या मतलब है? खैर, एक कंप्यूटर प्रोग्रामर वास्तव में आम तौर पर होता है पता के रूप में इस स्मृति का लगता है। दूसरे शब्दों में, इनमें से हर एक को स्मृति में स्थानों, हार्डवेयर में, एक विशिष्ट पता है। 

यह एक Brattle के रूप में के रूप में जटिल नहीं है स्क्वायर, कैम्ब्रिज, मास।, 02138। इसके बजाय, यह सिर्फ एक संख्या है। इस बाइट संख्या शून्य, यह है है एक, यह दो है, इस तीन है, और यह 41 है। एक मिनट रुकिए। मैंने सोचा कि मैं 42 ने कहा कि एक पल पहले। मैं शून्य पर गिनती शुरू कर दिया, इतना है कि वास्तव में सही है। अब हम वास्तव में इसे आकर्षित करने के लिए नहीं है एक ग्रिड के रूप में, और आप इसे एक ग्रिड के रूप में आकर्षित करता है, तो मैं चीजों को वास्तव में लगता है एक भ्रामक सा मिलता है। क्या एक प्रोग्रामर होगा, अपने या अपने खुद के मन में, आम तौर पर इस के बारे में सोच स्मृति के रूप में सिर्फ एक टेप की तरह है, मास्किंग टेप के एक टुकड़े की तरह कि बस पर और पर हमेशा के लिए चला जाता है या आप स्मृति से बाहर चला जब तक। तो एक अधिक सामान्य तरीका आकर्षित करने के लिए और सिर्फ स्मृति के बारे में सोचते हो सकता है कि इस बाइट शून्य, एक है, दो, तीन, और फिर डॉट, डॉट, डॉट। और अगर आप इस तरह के 42 बाइट्स कुल की है, यहां तक ​​कि हालांकि शारीरिक रूप से यह वास्तव में हो सकता है इस तरह से अधिक कुछ हो। 

तो अगर आप अभी से लगता है कि अपने स्मृति इस रूप में, सिर्फ एक टेप की तरह, यह वही है जो एक प्रोग्रामर फिर से है स्मृति की एक सरणी फोन होगा। और आप वास्तव में संग्रहीत करना चाहते हैं जब कंप्यूटर की स्मृति में कुछ है, आप आम तौर पर दुकान बातें करते हैं बैक-टू-बैक वापस करने के लिए वापस करने के लिए। इसलिए हम संख्या के बारे में बात कर रहा है। और समस्याओं को हल करने के लिए जब मैं चाहता था जैसे चार, एक, तीन, दो, यहां तक ​​कि मैं सिर्फ ड्राइंग था, हालांकि केवल संख्या चार, एक, तीन, बोर्ड पर दो, कंप्यूटर होगा वास्तव में स्मृति में इस सेटअप है। 

और क्या करने के लिए अगले होगा कंप्यूटर की स्मृति में दो? खैर, उस का कोई जवाब नहीं है। हम वास्तव में नहीं पता है। और इसलिए जब तक यह कंप्यूटर की जरूरत नहीं है, यह देखभाल करने के लिए आगे क्या है नहीं है नंबरों के लिए इसके बारे में परवाह नहीं करता है। और जब मैंने पहले एक कंप्यूटर है कि कहा एक बार में केवल एक ही पते पर देख सकते हैं, यही कारण है की तरह है। 

नहीं एक रिकार्ड के विपरीत खिलाड़ी और एक पढ़ने सिर केवल एक निश्चित को देखने के लिए सक्षम होने के नाते एक भौतिक पुराने स्कूल रिकॉर्ड में नाली एक समय में, इसी तरह एक कंप्यूटर धन्यवाद कर सकते हैं अपने सीपीयू और इसके लिए इंटेल अनुदेश सेट, जिसका अनुदेश के बीच स्मृति से पढ़ा जाता है या एक memory-- को बचाने के कंप्यूटर केवल देख सकते हैं एक time-- में एक स्थान पर कभी कभी उनमें से एक संयोजन, लेकिन एक समय में वास्तव में सिर्फ एक स्थान। तो जब हम क्या कर रहे थे इन विभिन्न एल्गोरिदम, मैं सिर्फ एक में नहीं लिख रहा हूँ vacuum-- चार, एक, तीन, दो। उन लोगों की संख्या वास्तव में संबंधित हैं कहीं स्मृति में शारीरिक। तो वहाँ छोटे छोटे हैं ट्रांजिस्टर या किसी तरह का नीचे इलेक्ट्रॉनिक्स के हुड इन मूल्यों भंडारण। 

और कुल में, कितने टुकड़े कर रहे हैं अब ठीक है शामिल है, अभी स्पष्ट होना करने के लिए? तो यह चार बाइट्स है, या अब यह 32 बिट कुल है। तो वहाँ वास्तव में 32 शून्य कर रहे हैं और इन चार बातों रचना वाले। यहाँ पर और भी अधिक है, लेकिन फिर हम उस के बारे में परवाह नहीं है। 

तो अब एक और पूछना स्मृति का उपयोग सवाल है, क्योंकि है कि अंत में दिन के विचरण में है। कोई फर्क नहीं पड़ता है कि हम साथ क्या हो सकता है कंप्यूटर, दिन के अंत में हार्डवेयर अभी भी है हुड के नीचे ही है। कैसे मैं यहाँ में एक शब्द की दुकान होगी? वैसे, एक कंप्यूटर में एक शब्द की तरह "अरे!" सिर्फ इस तरह संग्रहीत किया जाएगा। और अगर आप एक लंबी चाहता था शब्द, आप बस कर सकते हैं ऊपर लिख है कि और कुछ कहना "नमस्ते" और दुकान है कि यहाँ की तरह। 

और तो यहां भी, इस contiguousness , वास्तव में एक फायदा है क्योंकि एक कंप्यूटर सिर्फ कर सकते हैं दाएँ से बाएँ से पढ़ें। लेकिन यहाँ एक सवाल है। इस शब्द के संदर्भ में, एच-ई-एल-एल ओ, विस्मयादिबोधक बिंदु, कैसे कंप्यूटर जानते हो सकता है जहां शब्द शुरू होता है और जहां वचन समाप्त होता है? संख्या के संदर्भ में, कैसे कंप्यूटर करता है पता है कितनी देर के अनुक्रम संख्या है या जहां यह शुरू होता है? खैर, यह out-- बदल जाता है और हम बहुत ज्यादा नहीं जाना होगा detail-- के इस स्तर में कंप्यूटर स्मृति में चारों ओर ले जाने के लिए सामान सचमुच इन पतों के माध्यम से। एक कंप्यूटर में तो, अगर आप कर रहे हैं चीजों को स्टोर करने के लिए कोड लिखने शब्दों की तरह है, तो आप क्या कर रहे हैं वास्तव में कर रही टाइपिंग है भाव यह है कि जहां में याद कंप्यूटर की मेमोरी इन शब्द हैं। तो मुझे एक बहुत करते हैं, बहुत ही सरल उदाहरण है। 

मैं आगे जाने के लिए जा रहा हूँ और एक साधारण पाठ कार्यक्रम को खोलने, और मैं बनाने जा रहा हूँ एक फ़ाइल hello.c कहा जाता है। इस जानकारी के अधिकांश हम महान विस्तार में नहीं जाऊँगा, लेकिन मैं एक लिखने जा रहा हूँ उसी भाषा में कार्यक्रम सी यह कहीं अधिक डरा देता है, मैं तर्क होता है, स्क्रैच से, लेकिन यह भावना में बहुत समान है। वास्तव में, इन घुंघराले एक तरह से आप कर सकते हैं braces-- क्या मैं सिर्फ इस रूप में किया था के बारे में सोच। 

चलो इस वास्तव में करते हैं, करते हैं। जब हरे रंग का झंडा क्लिक किया, निम्नलिखित है। मैं बाहर मुद्रित करना चाहते हैं "नमस्ते।" तो यह अब pseudocode है। मैं एक तरह से रेखा को धुंधला कर रहा हूँ। सी में, इस भाषा मैं बात कर रहा हूँ के बारे में, इस लाइन प्रिंट हैलो वास्तव में के साथ "printf" हो जाता है कुछ कोष्ठकों और एक अर्धविराम। 

लेकिन यह ठीक उसी विचार है। और यह बहुत उपयोगकर्ता के अनुकूल "जब हरे रंग का झंडा क्लिक" हो जाता है बहुत अधिक रहस्यमय "int मुख्य शून्य।" और यह वास्तव में कोई मैपिंग है, इसलिए मैं सिर्फ इतना है कि अनदेखी करने के लिए जा रहा हूँ। लेकिन घुंघराले ब्रेसिज़ की तरह हैं इस तरह घुमावदार पहेली टुकड़े। 

तो आप की तरह कर सकते हैं लगता है। यहां तक ​​कि अगर आप पहले कभी नहीं प्रोग्राम किया गया है, क्या इस कार्यक्रम शायद क्या करता है? शायद हैलो प्रिंट एक विस्मयादिबोधक बिंदु के साथ। 

तो चलो कि कोशिश करते हैं। मैं इसे बचाने के लिए जा रहा हूँ। और यह है, फिर से, एक बहुत पुराने स्कूल के वातावरण। मैं क्लिक नहीं कर सकता, मैं नहीं खींच सकते हैं। मैं आदेश टाइप करने के लिए की है। तो मैं अपने कार्यक्रम चलाने के लिए चाहते हैं, तो मैं hello.c की तरह यह कर सकता है। वह फाइल मैं भाग गया है। लेकिन रुकिए, मैं एक कदम याद आ रही है। क्या किया था कि हम कहते हैं कि एक आवश्यक है सी की तरह एक भाषा के लिए कदम? मैं सिर्फ लिखा है स्रोत कोड, लेकिन मैं क्या जरूरत है? हाँ, मैं एक संकलक की जरूरत है। एक तो यहाँ मेरी मैक पर, मेरे पास है कार्यक्रम जीसीसी कहा जाता है, जीएनयू सी संकलक, जो मुझे this-- बारी करने के लिए अनुमति देता है में अपने स्रोत कोड, हम यह फोन करता हूँ, मशीन कोड। 

और मुझे लगता है कि देख सकते हैं, फिर, इस प्रकार है, इन शून्य और लोगों को मैं कर रहे हैं बस अपने स्रोत कोड से बनाई गई है, शून्य और लोगों के सभी। और मैं चलाना चाहते हैं मेरे program-- ऐसा होता है के लिए a.out के नाम से जाना ऐतिहासिक reasons-- "नमस्ते।" मैं इसे फिर से चला सकते हैं। हैलो हैलो हैलो। और लगता है यह काम कर रहा है। 

लेकिन उस में कहीं न कहीं इसका मतलब है मेरी कंप्यूटर की मेमोरी शब्द हैं एच-ई-एल-एल ओ, विस्मयादिबोधक बिंदु। और इसे रद्द सिर्फ एक के रूप में पता चला है, क्या एक कंप्यूटर आम तौर पर होता है इतना है कि यह जानता है, जहां कर बातें शुरू और end-- यह है यहाँ एक विशेष प्रतीक डाल करने के लिए जा रहा है। और कन्वेंशन डाल दिया है एक शब्द के अंत में संख्या शून्य इतनी है कि आप जानते हैं कि यह जहां वास्तव में समाप्त हो जाती है, ताकि आप अधिक से अधिक मुद्रण बाहर नहीं रखते आप की तुलना में पात्रों वास्तव में चाहते हैं। 

लेकिन यहाँ takeaway, यहां तक ​​कि हालांकि यह काफी रहस्यमय है, कि यह अंततः है अपेक्षाकृत सरल। आप एक टेप की तरह दिए गए थे, एक खाली अंतरिक्ष जिस पर आपको पत्र लिख सकते हैं। आप बस एक के लिए है विशेष प्रतीक, मनमाने ढंग से की तरह संख्या शून्य, के अंत में डाल करने के लिए अपने शब्दों को इतना है कि कंप्यूटर जानता है, ओह, मैं के बाद मुद्रण बंद कर देना चाहिए मैं विस्मयादिबोधक बिंदु देखते हैं। क्योंकि वहाँ अगली बात शून्य से एक ASCII मूल्य है, या के रूप में अशक्त चरित्र किसी को यह नहीं कह सकता। लेकिन एक समस्या की तरह है यहाँ, और हम वापस लौट जाने एक पल के लिए संख्या है। मान लीजिए कि मैं क्या, वास्तव में, , संख्या की एक सरणी है और लगता है कि कार्यक्रम मैं लिख रहा हूँ एक शिक्षक के लिए एक ग्रेड किताब की तरह और एक शिक्षक कक्षा। और इस कार्यक्रम की अनुमति देता है उसे या उसके अपने छात्रों के स्कोर में टाइप करने के लिए क्विज़ पर। और कहा कि छात्र हो जाता है लगता है 100 अपनी पहली प्रश्नोत्तरी पर, हो सकता है अगले एक पर एक 80 है, तो एक तरह 75 है, तो चौथे प्रश्नोत्तरी पर एक 90। 

तो कहानी में इस बिंदु पर, सरणी चार आकार का है। वहाँ में पूरी तरह से और अधिक स्मृति है कंप्यूटर, लेकिन सरणी, तो बात करने के लिए चार आकार का है। अब मान लीजिए कि शिक्षक चाहता है वर्ग के लिए एक पांचवें प्रश्नोत्तरी आवंटित करने के लिए। खैर, चीजों में से एक वह या वह क्या करने के लिए किया जा रहा है अब यहाँ एक अतिरिक्त मूल्य की दुकान है। लेकिन सरणी यदि शिक्षक है इस कार्यक्रम में बनाया है, के लिए आकार का है एक सरणी के साथ समस्या में से एक यह है कि आप सिर्फ स्मृति को जोड़कर रखना नहीं कर सकता। क्योंकि क्या करता है, तो के दूसरे भाग कार्यक्रम शब्द "हे" सही वहाँ है? 

दूसरे शब्दों में, मेरी स्मृति हो सकता है एक कार्यक्रम में कुछ के लिए इस्तेमाल किया। और अगर अग्रिम में मैं में टाइप, हे, मैं इनपुट चार प्रश्नोत्तरी स्कोर करना चाहते हैं, वे यहाँ और यहाँ जाना हो सकता है। और अगर आप अचानक अपने दिमाग को बदल बाद में और कहते हैं कि मैं एक पांचवें प्रश्नोत्तरी चाहते हैं स्कोर, आप अभी नहीं कर सकता इसे डाल जहाँ आप चाहते हैं, क्योंकि क्या यह अगर स्मृति का उपयोग किया जा रहा है कुछ के लिए कुछ अन्य कार्यक्रम else-- या कार्यक्रम के कुछ अन्य सुविधा आप चला रहे हैं? तो आप अग्रिम में सोचना है कैसे आप अपने डेटा स्टोर करना चाहते हैं, क्योंकि अब आप चित्रित किया अपने आप को एक डिजिटल कोने में। 

तो एक शिक्षक के बजाय हो सकता है कहते हैं कि जब एक प्रोग्राम लिखने स्टोर करने के लिए अपने या अपने ग्रेड, तुम जानते हो क्या? मैं, अनुरोध करने के लिए जा रहा हूँ जब मेरे कार्यक्रम लेखन, मैं चाहता हूँ कि शून्य, एक, दो, तीन, चार, पांच, छह, आठ ग्रेड कुल। तो एक, दो, तीन, चार, पांच, छह, सात, आठ। शिक्षक बस पर आवंटित कर सकते हैं स्मृति जब अपने या अपने कार्यक्रम लेखन और आप जानते हैं कि क्या कहना है? मैं कभी अधिक आवंटित करने के लिए जा रहा हूँ एक सेमेस्टर में आठ क्विज़ से। वह सिर्फ पागल है। मैं आवंटित कभी नहीं करेंगे। तो वह या वह है कि इस तरह से दुकान छात्र स्कोर करने के लिए लचीलापन, 75, 90, और शायद एक अतिरिक्त जहां की तरह छात्र, 105 अतिरिक्त ऋण मिला है। 

लेकिन अगर शिक्षक कभी नहीं इन तीन स्थान का उपयोग करता है, वहाँ यहाँ एक सहज ज्ञान युक्त takeaway है। वह या वह सिर्फ अंतरिक्ष बर्बाद कर रहे है। तो दूसरे शब्दों में, वहाँ इस है प्रोग्रामिंग में आम tradeoff जहाँ आप या तो आवंटित कर सकते हैं बिल्कुल के रूप में ज्यादा स्मृति के रूप में आप चाहते हैं, जो के ऊपर है कि आप सुपर रहे है efficient-- आप बेकार नहीं हो रहा है पर all-- लेकिन जो के नकारात्मक पक्ष क्या आप अपने मन जब बदल अगर प्रोग्राम है कि आप संग्रहीत करना चाहते हैं का उपयोग कर आप अधिक से अधिक डेटा मूल उद्देश्य। 

इसलिए हो सकता है समाधान है, तो है, इस तरह से अपने कार्यक्रमों के बारे में कि वे और अधिक स्मृति का उपयोग की तुलना में वे वास्तव में जरूरत है। इस तरह आप नहीं जा रहे हैं उस समस्या में चलाने के लिए, लेकिन आप बेकार जा रहा हो। और अधिक स्मृति आपके प्रोग्राम का उपयोग करता है, हम कल चर्चा की, कम स्मृति कि उपलब्ध है अन्य कार्यक्रमों के लिए, जल्दी ही आपके कंप्यूटर को धीमा हो सकता है नीचे आभासी स्मृति की वजह से। और तो आदर्श समाधान क्या हो सकता है? 

अंडर आवंटन बुरा लगता है। से अधिक का आवंटन बुरा लगता है। तो क्या एक बेहतर समाधान हो सकता है? पुनः दिए। अधिक गतिशील हो। अपने आप को एक चुनने के लिए मजबूर मत करो प्राथमिकताओं, शुरुआत में, आप क्या चाहते हैं। और निश्चित रूप से नहीं पर आवंटित है, आप ऐसा न हो कि बेकार हो। 

और इतना है कि लक्ष्य को प्राप्त करने के लिए, हम इस डेटा संरचना फेंकने की जरूरत है, तो बात है, दूर। और तो क्या एक प्रोग्रामर आम तौर पर प्रयोग करेंगे कुछ एक नहीं कहा जाता है सरणी लेकिन एक लिंक सूची। दूसरे शब्दों में, वह या वह होगा उनकी स्मृति के बारे में सोचना शुरू एक आकार की जा रही है प्रकार के रूप में है कि वे निम्नलिखित तरीके से आकर्षित कर सकते हैं। मैं एक संख्या में स्टोर करना चाहते हैं एक program-- इसलिए यह सितंबर है, मैं अपने छात्रों को एक प्रश्नोत्तरी दिया है; मुझे चाहिए छात्रों की पहली प्रश्नोत्तरी स्टोर करने के लिए, और वे it-- मैं पर एक 100 मिली अपने कंप्यूटर में पूछने के लिए जा रहा हूँ, कार्यक्रम मैं के माध्यम से लिखा है, स्मृति का एक हिस्सा के लिए। और मैं स्टोर करने के लिए जा रहा हूँ यह संख्या 100 है, और यह बात है। 

फिर कुछ ही हफ्ते बाद जब मैं अपने दूसरे प्रश्नोत्तरी मिलता है, और इसे टाइप करने के लिए समय आ गया है कि 90% में, मैं जा रहा हूँ कंप्यूटर से पूछते हैं, अरे, कंप्यूटर, मैं स्मृति का एक और हिस्सा हो सकती है? इससे मुझे यह देने के लिए जा रहा है स्मृति के खाली हिस्सा। मैं नंबर 90 में डालने के लिए जा रहा हूँ, लेकिन मेरे कार्यक्रम में किसी भी तरह या other-- और हम के बारे में चिंता नहीं होगी वाक्य रचना this-- के लिए मैं की जरूरत है किसी भी तरह के लिए इन बातों को एक साथ श्रृंखला। और मैं उन्हें एक साथ के साथ श्रृंखला करेंगे क्या एक तीर यहाँ की तरह दिखता है। 

तीसरे प्रश्नोत्तरी कि ऊपर आता है, मैं कहने जा रहा हूँ, हे, कंप्यूटर, मेरे स्मृति का एक और हिस्सा दे। और मैं नीचे डाल करने के लिए जा रहा हूँ जो कुछ भी था, 75 की तरह, और मैं इस श्रृंखला के लिए किया है अब एक साथ किसी भी तरह। चौथा प्रश्नोत्तरी के साथ आता है, और हो सकता है कि सेमेस्टर के अंत की ओर है। और उस बिंदु अपने कार्यक्रम से स्मृति का उपयोग हो सकता है सभी जगह पर, सभी शारीरिक रूप से अधिक है। और तो बस kicks के लिए, मैं हूँ इस आगे आकर्षित करने के लिए जा रहा quiz-- मैं भूल गया कि वह क्या था; मैं एक 80 या something-- लगता है शायद रास्ते पर यहाँ। 

लेकिन यह है कि ठीक है, क्योंकि pictorially मैं इस लाइन आकर्षित करने के लिए जा रहा हूँ। दूसरे शब्दों में, वास्तव में, आपके कंप्यूटर के हार्डवेयर में, पहली स्कोर हो सकता है यहाँ अंत में यह है क्योंकि सही सेमेस्टर के शुरू में। अगले एक यहाँ खत्म हो सकता है क्योंकि समय का एक सा बीत चुका है और कार्यक्रम चल रहता है। अगले स्कोर, जो था एक 75, यहाँ पर हो सकता है। और पिछले स्कोर हो सकता है एक 80 है, जो यहाँ खत्म हो गया है। 

तो वास्तव में, शारीरिक रूप से, यह हो सकता है क्या आपके कंप्यूटर की स्मृति की तरह लग रहा है। लेकिन यह एक उपयोगी मानसिक नहीं है एक कंप्यूटर प्रोग्रामर के लिए प्रतिमान। तुम क्यों परवाह करना चाहिए जहां बिल्ली अपने डेटा को खत्म हो रही है? तुम बस डाटा स्टोर करना चाहते हैं। 

इस तरह की हमारी चर्चा की तरह है घन ड्राइंग के पहले। तुम क्यों परवाह क्या कोण घन की है और आप कैसे यह आकर्षित करने के लिए बारी है? तुम सिर्फ एक घन चाहते हैं। इसी तरह यहां आप अभी ग्रेड बुक करना चाहते हैं। तुम बस के बारे में सोचना चाहते हैं नंबरों की सूची के रूप में इस। कौन परवाह करता है कि यह कैसे है हार्डवेयर में कार्यान्वित? 

अमूर्त अब तो इस तस्वीर में यहाँ है। यह एक जुड़ा हुआ है सूची, के रूप में एक प्रोग्रामर यह नहीं कह सकता, आप एक है जहां तक सूची, संख्या के जाहिर है। लेकिन यह pictorially जुड़ा हुआ है इन तीरों के माध्यम से, और इन सभी तीर नीचे are-- डाकू, यदि आप उत्सुक हैं, याद आता है हमारे भौतिक हार्डवेयर है कि पतों शून्य, एक, दो, तीन, चार। इन सभी तीर हैं एक मैप की तरह है या निर्देश, जहां अगर 90 है- अब मैं गिनती करने के लिए मिला है। 

शून्य, एक, दो, तीन, चार, पांच, छह, सात। ऐसा लगता है कि 90 की तरह है स्मृति पता नंबर सात। इन सभी तीर हैं कागज के एक छोटे से स्क्रैप की तरह कि के लिए निर्देश दे रही है कार्यक्रम का कहना है कि इस नक्शे का पालन करें स्थान सात को पाने के लिए। और वहाँ आप पाएंगे छात्र की दूसरी प्रश्नोत्तरी स्कोर। इस बीच, 75-- अगर मैं यह जारी है, इस सात, आठ, नौ, 10, 11, 12, 13, 14, 15। 

यह अन्य तीर सिर्फ प्रतिनिधित्व स्मृति स्थान से 15 एक नक्शा। लेकिन फिर, प्रोग्रामर आम तौर पर करता है विस्तार के इस स्तर के बारे में परवाह नहीं है। और सबसे अधिक हर प्रोग्रामिंग में भाषा आज, प्रोग्रामर यहां तक ​​कि जहां स्मृति में पता नहीं होगा इन नंबरों को वास्तव में कर रहे हैं। सभी वह या वह है देखभाल करने के बारे में है कि वे किसी भी तरह से एक साथ जुड़े हुए हैं इस तरह एक डेटा संरचना में। 

लेकिन यह नहीं पता चला है भी तकनीकी पाने के लिए। लेकिन सिर्फ इसलिए कि हम शायद कर सकते हैं यहाँ इस चर्चा का खर्च वहन, लगता है कि हम फिर से आना इस मुद्दे को एक सरणी के यहाँ। चलो देखते हैं अगर हम यहाँ जा रहा खेद है। यह 100, 90, 75, और 80 है। 

मुझे संक्षेप में यह दावा करते हैं। यह एक सरणी है, और फिर, एक सरणी की मुख्य विशेषता अपने डेटा के सभी के लिए वापस आ गया है वह यह है कि वापस सचमुच memory-- में वापस करने के लिए एक बाइट या शायद चार बाइट्स, बाइट्स के कुछ निश्चित संख्या दूर। एक लिंक सूची में, हम आकर्षित हो सकता है इस तरह, हुड के नीचे जो जानता है, जहां कि सामान है? यह भी इस तरह के प्रवाह की जरूरत नहीं है। डेटा के कुछ हो सकता है वहाँ वापस छोड़ दिया है। तुम भी पता नहीं है। 

और हां एक सरणी के साथ, आप एक है रैंडम एक्सेस की सुविधा के रूप में जाना। और क्या रैंडम एक्सेस साधन है कि कंप्यूटर तुरन्त कूद कर सकते हैं एक सरणी में किसी भी स्थान पर। क्यूं कर? क्योंकि कंप्यूटर जानता है कि पहला स्थान है शून्य, एक, दो, तीन और। 

और अगर आप से जाना चाहते हैं तो अगले तत्व को यह तत्व, आप सचमुच में कंप्यूटर के मन, सिर्फ एक जोड़ें। आप तीसरे तत्व करने के लिए जाना चाहते हैं, बस अगले तत्व one-- जोड़ने, बस एक जोड़ें। हालांकि, इस संस्करण में कहानी का, मान लीजिए कंप्यूटर वर्तमान में देख रहा है पर या नंबर 100 के साथ काम कर रहे हैं। आप अगले करने के लिए कैसे मिलता है ग्रेड किताब में ग्रेड? 

आप सात लेने के लिए है कदम है, जो मनमाना है। अगले एक को पाने के लिए, आप के लिए है एक और आठ कदम उठाने के लिए 15 को पाने के लिए। दूसरे शब्दों में, यह एक नहीं है संख्याओं के बीच लगातार अंतर है, और तो यह सिर्फ लेता है कंप्यूटर और अधिक समय की बात है। कंप्यूटर खोज करने के लिए है आदेश में स्मृति के माध्यम से आप के लिए क्या देख रहे हो खोजने के लिए। 

तो, जबकि एक सरणी एक हो जाता है तेजी से डाटा structure-- आप क्योंकि सचमुच सिर्फ सरल गणित क्या कर सकते हैं और एक जोड़कर आप चाहते हैं जहां मिलता है, एक लिंक सूची instance-- के लिए, आप उस सुविधा का त्याग। तुम बस पहले से नहीं जा सकते दूसरे, तीसरे करने के लिए चौथे करने के लिए। आप नक्शे पालन किया है। आप और अधिक कदम उठाने होंगे उन मूल्यों, को पाने के लिए जो एक लागत को जोड़ने होना प्रतीत होता है। तो हम एक कीमत चुका रहे हैं, लेकिन क्या था विशेषता यह है कि दान यहाँ की मांग कर रहा था? क्या एक लिंक सूची करता है जाहिरा तौर पर हमें ऐसा करने की अनुमति, जो की उत्पत्ति था यह विशेष रूप से कहानी? 

ठीक ठीक। यह करने के लिए एक गतिशील आकार। हम इस सूची में जोड़ सकते हैं। हम भी सूची सिकुड़ कर सकते हैं, तो हम केवल स्मृति के रूप में ज्यादा प्रयोग कर रहे हैं कि जैसा कि हम वास्तव में चाहते हैं और इसलिए हम पर आवंटन नहीं कर रहे हैं। 

अब सिर्फ सच में लीख picky हो, वहाँ एक छिपा लागत है। तो तुम सिर्फ मुझे समझाने ऐसा नहीं होना चाहिए आप इस एक सम्मोहक tradeoff है। वहाँ एक और छिपा लागत यहाँ है। लाभ, स्पष्ट होना, कि हम गतिशीलता मिल रहा है। अगर मैं एक और तत्व चाहता, मैं सिर्फ यह कर सकते हैं यह आकर्षित और वहाँ में एक नंबर डाल दिया। और फिर मैं यह लिंक कर सकते हैं यहाँ एक तस्वीर के साथ, यहाँ पर जबकि, फिर, अगर मैं अपने आप को एक कोने में चित्रित, अगर कुछ और पहले से ही उपयोग कर रहा है स्मृति यहां, मैं भाग्य से बाहर हूँ। मैं अपने आप को कोने में चित्रित किया है। 

लेकिन क्या छिपा है इस तस्वीर में खर्च करते हैं? यह सिर्फ राशि नहीं है समय है कि यह लेता है यहाँ से यहां के लिए जाना है, जो सात चरणों में है, तो है आठ कदम है, जो एक से अधिक है। एक और छिपा लागत क्या है? इतना ही नहीं समय। अतिरिक्त जानकारी है इस तस्वीर के लिए आवश्यक प्राप्त करने के लिए। 

हाँ, यह नक्शा, के उन छोटे स्क्रैप कागज, के रूप में मैं उन के रूप का वर्णन रहते हैं। उन arrows-- ये मुक्त नहीं हैं। एक computer-- आप जानते क्या एक कंप्यूटर है। यह शून्य और लोगों की है। आप एक तीर या एक का प्रतिनिधित्व करना चाहते हैं नक्शा या एक संख्या है, आप कुछ स्मृति की जरूरत है। अन्य कीमत तो तुम एक लिंक सूची के लिए भुगतान करते हैं, एक आम कंप्यूटर विज्ञान संसाधन भी जगह नहीं है। 

और वास्तव में ऐसा है, तो आमतौर पर, tradeoffs के बीच सॉफ्टवेयर इंजीनियरिंग डिजाइन करने में सिस्टम समय और space-- है अपनी सामग्री के दो हैं, दो अपने सबसे महंगा अवयवों की। यह मुझे और अधिक समय की लागत है क्योंकि मैं इस नक्शे का पालन किया है, लेकिन यह भी मुझे अधिक स्थान की लागत है क्योंकि मैं इस नक्शे के आसपास रख दिया है। उम्मीद है, के रूप में हम किस तरह का है कल और आज के ऊपर चर्चा की, कि लाभ है लागत पल्ला झुकना होगा। 

लेकिन यहाँ कोई स्पष्ट समाधान है। शायद यह है better-- एक ला त्वरित और गंदे, करीम earlier-- प्रस्तावित के रूप में समस्या पर स्मृति फेंक करने के लिए। बस और अधिक स्मृति खरीदने के लिए, कम लगता है समस्या को हल करने के बारे में मुश्किल है, और एक आसान तरीके से इसे हल। और वास्तव में इससे पहले, जब हम tradeoffs के बारे में बात की थी, उस में स्थान नहीं था कंप्यूटर और समय। यह डेवलपर समय था, जो अभी तक एक संसाधन है। 

तो फिर, यह इस संतुलन साधने है तय की कोशिश कर उन चीजों में से जो आप खर्च करने को तैयार हैं? जो कम से कम महंगा है? कौन सा बेहतर परिणाम पैदावार? हाँ? 

वास्तव में। इस मामले में, आप कर रहे हैं maps-- में संख्या का प्रतिनिधित्व इनमें से कई भाषाओं में कहा जाता है "संकेत" या "पतों" - यह डबल जगह है। यही कारण है कि डबल यदि जितनी खराब होने की जरूरत नहीं अभी हम सिर्फ संख्या भंडारण कर रहे हैं। मान लीजिए कि हम भंडारण के थे एक hospital-- में रोगी रिकॉर्ड इसलिए पियर्सन के नाम, फोन नंबर, सामाजिक सुरक्षा नंबर, डॉक्टर इतिहास। इस बॉक्स में ज्यादा हो सकता है, बहुत बड़ा है, जो मामले में एक छोटे सूचक, का पता अगले element-- यह एक बड़ा सौदा नहीं है। यह इस तरह के एक किनारे है लागत यह बात नहीं है। लेकिन इस मामले में, हाँ, यह एक दोहरीकरण है। अच्छा प्रश्न। 

के समय के बारे में बात करते हैं अधिक concretely थोड़ा। समय चल रहा है क्या है की इस सूची खोज? मान लीजिए कि मैं खोज करना चाहता था सभी छात्रों के ग्रेड के माध्यम से, और वहाँ n ग्रेड है इस डेटा संरचना में। यहां भी, हम उधार ले सकते हैं पहले की शब्दावली। यह एक रेखीय डेटा संरचना है। 

n के बड़ी हे है क्या पाने के लिए आवश्यक है इस डेटा संरचना का अंत करने के लिए, whereas-- और हम नहीं देखा है यह एक सरणी आप देता before-- क्या लगातार समय कहा जाता है, जिसका अर्थ है एक या दो कदम कदम या 10 steps-- कोई फर्क नहीं पड़ता। यह एक निश्चित संख्या है। इसके साथ कुछ नहीं करना है सरणी के आकार। और उस के लिए कारण, फिर, रैंडम एक्सेस है। कंप्यूटर कर सकते हैं बस तुरंत किसी अन्य स्थान के लिए कूद, क्योंकि वे सब एक ही कर रहे बाकी सब से दूरी। इसमें कोई सोच शामिल है। ठीक है। तो अगर मैं कर सकता हूँ, मेरे लिए कोशिश करते हैं दो अंतिम चित्रों के रंग। एक बहुत ही आम एक एक हैश तालिका के रूप में जाना जाता है। तो इस चर्चा को प्रेरित करने के लिए, मुझे यह कैसे करना है के बारे में सोचते हैं। 

तो कैसे इस बारे में? मान लीजिए कि समस्या यह है कि अब हम हल करना चाहते हैं एक dictionary-- में लागू कर रहा है इसलिए अंग्रेजी शब्दों की एक पूरी गुच्छा जो कुछ भी। और लक्ष्य के जवाब देने में सक्षम होने के लिए है फार्म के सवालों के इस एक शब्द है? तो अगर आप लागू करना चाहते हैं एक जादू चेकर, बस एक भौतिक शब्दकोश की तरह आप में चीजों को देख सकते हैं कि। मान लीजिए कि मैं एक सरणी के साथ ऐसा कर रहे थे। मैं यह कर सकता है। 

मान लीजिए और शब्द सेब हैं और केले और खरबूजा। और मैं फल के बारे में सोच नहीं कर सकते कि डी के साथ शुरू करते हैं, तो हम सिर्फ रहे हैं तीन फल है करने के लिए जा रहा है। तो यह एक सरणी है, और हम कर रहे हैं इन शब्दों के सभी के भंडारण इस शब्दकोश एक सरणी के रूप में। सवाल है, तो, कैसे और क्या है आप इस जानकारी स्टोर कर सकता है? 

खैर, मैं एक तरह से यहां धोखा दे रहा हूँ, क्योंकि शब्द में इन पत्रों में से प्रत्येक के वास्तव में एक व्यक्ति बाइट है। तो अगर मैं वास्तव में होना चाहता था लीख picky, मैं सच में करना चाहिए इतना में विभाजित किया स्मृति की छोटी मात्रा, और हम वास्तव में ऐसा कर सकता है। लेकिन हम में चलाने के लिए जा रहे हैं पहले की तरह ही समस्या है। मरियम वेबस्टर या ऑक्सफोर्ड के रूप में, तो क्या होगा हर वे शब्दों को जोड़ने year-- करता है dictionary-- करने के लिए हम नहीं जरूरी खुद पेंट करना चाहते हैं एक सरणी के साथ एक कोने में? 

तो बजाय, शायद एक चालाक दृष्टिकोण अपने स्वयं के नोड या बॉक्स में सेब डाल दिया है, हम कह सकते हैं, केला, और तो यहाँ हम खरबूजा है। और हम स्ट्रिंग इन बातों को एक साथ। तो इस सरणी है, और इस लिंक सूची है। आप काफी नहीं देख सकते हैं, यह सिर्फ कहते हैं, "सरणी," और यह कहते हैं, "सूची।" 

तो हम एक ही है पहले के रूप में सटीक मुद्दों, जिससे अब हम हमारे लिंक सूची में गतिशीलता। लेकिन हम एक काफी धीमी शब्दकोश है। मान लीजिए कि मैं एक शब्द को देखने के लिए चाहते हैं। यह मेरे n के बड़े हे ले सकता है कदम, क्योंकि शब्द हो सकता है के अंत में सभी तरह हो सूची, खरबूजा की तरह। और यह पता चला है कि प्रोग्रामिंग में, प्रकार डेटा की होली ग्रेल की संरचनाओं, कुछ है कि आप निरंतर देता है एक सरणी की तरह समय लेकिन लगता है कि अभी भी आप गतिशीलता देता है। 

इसलिए हम दोनों दुनिया के सर्वश्रेष्ठ हो सकती है? और वास्तव में, वहाँ कुछ है हैश तालिका बुलाया कि आप ठीक करने के लिए अनुमति देता है कि, यद्यपि लगभग। एक हैश तालिका एक शौक़ीन है डेटा संरचना है कि हम के रूप में के बारे में सोच सकते हैं एक array-- का संयोजन और मैं इसे आकर्षित करने के लिए जा रहा हूँ this-- और लिंक सूचियों की तरह कि मैं यहाँ पर इस तरह आकर्षित करेंगे। 

और वैसे भी इस बात को काम करता है इस प्रकार है। यदि यह table-- हैश now-- मेरी तीसरी डेटा संरचना है, और मैं संग्रहीत करना चाहते हैं इस में शब्द, मैं नहीं अभी के सभी स्टोर करना चाहते हैं शब्दों को वापस वापस करने के लिए वापस करने के लिए वापस करने के लिए। मैं कुछ और सुधार करना चाहते हैं जानकारी का अंश शब्द देना होगा कि के बारे में जहां यह तेजी से है मुझे यह मिलता है। 

तो शब्द सेब दी और केले और खरबूजा, मैं जानबूझ कर उन शब्दों को चुना है। क्यूं कर? किस तरह के मौलिक है तीन के बारे में अलग है? क्या स्पष्ट है? वे अलग अलग पत्र के साथ शुरू करते हैं। 

तो तुम जानते हो क्या? बजाय मेरे सारे शब्दों को डाल दिया एक ही बाल्टी, तो बात है, की तरह एक बड़ी सूची में, क्यों नहीं करते मैं कम से कम एक अनुकूलन की कोशिश और मेरी सूचियां 1/26 के रूप में लंबे समय के हैं। एक सम्मोहक अनुकूलन हो सकता है कि क्यों नहीं करते I-- जब एक शब्द डालने इस डेटा संरचना में, कंप्यूटर की मेमोरी, क्यों में न मैं सभी 'ए' शब्द यहाँ रखा है, सभी 'बी' शब्द यहाँ, और सभी 'सी' शब्द यहाँ? तो यह एक सेब डाल समाप्त होता है यहाँ, यहाँ केला, खरबूजा यहाँ, इत्यादि। 

और अगर मैं एक अतिरिक्त राशि शब्द like-- क्या एक और है? सेब, केला, नाशपाती। किसी को भी एक फल के बारे में सोच कि ए, बी, या सी के साथ शुरू होता है? Blueberry-- एकदम सही है। यही कारण है कि यहां खत्म होता जा रहा है। और इसलिए हम एक है लगता है मामूली बेहतर समाधान है, क्योंकि अब अगर मैं चाहता हूँ एप्पल के लिए खोज करने के लिए, मैं first-- मैं सिर्फ गोता नहीं है अपने डेटा संरचना में। मैं अपने कंप्यूटर की स्मृति में गोता लगाने के लिए नहीं है। मैं पहली बार पहले अक्षर को देखो। 

और यह है कि एक कंप्यूटर है वैज्ञानिक कहेंगे। आप अपने डेटा संरचना में हैश। आप अपने इनपुट, जिसमें लेने के लिए इस मामले में एप्पल की तरह एक शब्द है। आप यह विश्लेषण, पर देख रहे हैं इस मामले में पहले अक्षर, जिससे यह hashing। हैशिंग एक सामान्य शब्द है जिससे है आप इनपुट के रूप में कुछ लेने और आप कुछ उत्पादन का उत्पादन। और कहा कि उत्पादन में मामले स्थान है आप खोज करने के लिए, पहली चाहते हैं स्थान, दूसरा स्थान, तीसरे। तो इनपुट सेब है, उत्पादन पहला है। इनपुट केला, है उत्पादन दूसरे होना चाहिए। इनपुट, खरबूजा है उत्पादन तीसरे होना चाहिए। इनपुट ब्लूबेरी है, उत्पादन फिर दूसरी होना चाहिए। और है कि क्या आप लेने में मदद करता है अपनी स्मृति के माध्यम से शॉर्टकट आदेश शब्दों को पाने के लिए या डेटा अधिक प्रभावी ढंग से। 

अब इस संभावित हमारे समय नीचे में कटौती के रूप में ज्यादा 26 में से एक के रूप में, क्योंकि अगर आप मानते हैं कि आप के रूप में कई "एक" "जेड" के रूप में शब्द है 'क्यू' शब्द, के रूप में जो बातें वास्तव में realistic-- नहीं है तुम भर में तिरछा लिए जा रहे हैं alphabet-- के कुछ पत्र लेकिन यह एक वृद्धिशील होगा दृष्टिकोण है कि अनुमति नहीं है आप शब्दों को ज्यादा जल्दी पाने के लिए। और वास्तव में, एक परिष्कृत कार्यक्रम, दुनिया के गूगल, world-- की Facebooks वे एक हैश तालिका का प्रयोग करेंगे विभिन्न प्रयोजनों के लिए एक बहुत। लेकिन वे इतनी के रूप में अनुभवहीन नहीं होगा सिर्फ पहले अक्षर को देखने के लिए सेब या केले में या नाशपाती या खरबूजा, क्योंकि जैसा कि आप देख सकते हैं इन सूचियों अभी भी लंबे समय मिल सकता है। 

और इसलिए यह अभी भी प्रकार का हो सकता है के linear-- इतनी तरह की धीमी गति से, n के बड़े हे के साथ की तरह कि हम पहले भी चर्चा की। तो क्या एक वास्तविक अच्छा हैश तालिका होगा do-- यह एक बहुत बड़ा सरणी होगा। और यह एक बहुत अधिक उपयोग करेगा परिष्कृत हैशिंग समारोह, तो यह है कि यह सिर्फ पर नहीं दिखता है "एक।" हो सकता है कि यह कम से लग रहा है "एक-पी-पी-एल-ई" और किसी भी तरह उन पाँच पत्र धर्मान्तरित जहां स्थान में सेब संग्रहित किया जाना चाहिए। हम सिर्फ भोलेपन से पत्र 'ए' का उपयोग कर रहे हम अकेले हैं, क्योंकि यह अच्छा है और आसान है। 

लेकिन एक हैश तालिका में, अंत में, आप सोच सकते हैं के का एक संयोजन के रूप में एक सरणी, जिनमें से प्रत्येक एक लिंक सूची है कि आदर्श है जितना संभव हो कम होना चाहिए। और यह एक स्पष्ट समाधान नहीं है। वास्तव में, ठीक ट्यूनिंग के ज्यादा कि हुड जब नीचे चला जाता है के इन प्रकार को लागू परिष्कृत डेटा संरचनाओं क्या सही है सरणी की लंबाई? सही हैश कार्य क्या है? कैसे आप स्मृति में चीजों की दुकान है? 

लेकिन पता है कि कैसे जल्दी से चर्चा इस तरह की परिवर्धित, या तो इतनी दूर है कि यह एक तरह है के इस मोड़ पर एक के सिर, पर जो ठीक है। लेकिन हम शुरू कर दिया है, याद है, सच के साथ कुछ निम्न स्तर और इलेक्ट्रानिक। और इसलिए इस बार फिर यह है अमूर्त के विषय, जहां एक बार आप के लिए लेने के लिए शुरू दी, ठीक है, मैं it-- मिल गया है वहाँ भौतिक स्मृति, ठीक है, यह मिल गया, हर भौतिक स्थान एक पते है, ठीक है, मैं यह मिल गया, मैं प्रतिनिधित्व कर सकते हैं arrows-- के रूप में उन पतों आप बहुत जल्दी है करने के लिए शुरू कर सकते हैं और अधिक परिष्कृत है कि बातचीत अंत में हमें की अनुमति होने लगते हैं खोज की तरह समस्याओं का समाधान और छंटनी अधिक प्रभावी ढंग से। और बाकी का आश्वासन दिया, too-- क्योंकि मैं इस बारे में सोच गहरी हम कुछ में चला गया है है इन विषयों सीएस proper-- हम है की इस पर एक दिन और एक आधे में किया क्या बात है आप आम तौर पर खत्म कर सकता है आठ हफ्तों के दौरान एक सेमेस्टर में। 

इन पर कोई प्रश्न? नहीं? ठीक है। ठीक है, क्यों हम वहाँ रोक नहीं है, कुछ ही मिनटों में जल्दी दोपहर के भोजन के शुरू, सिर्फ एक घंटे के बारे में फिर से शुरू? और मैं के लिए भटकती करेंगे सवालों के साथ एक सा है। तब मैं जाने के लिए जा रहा हूँ एक जोड़े को फोन ले कि अगर ठीक है। मैं, इस बीच में कुछ संगीत पर बारी होगी लेकिन दोपहर के भोजन के कोने के आसपास होना चाहिए। 