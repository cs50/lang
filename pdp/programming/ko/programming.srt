1
00:00:00,000 --> 00:00:00,030

2
00:00:00,030 --> 00:00:00,460
>> DAVID 마란 : 좋습니다.

3
00:00:00,460 --> 00:00:01,094
우리는 다시 수 있습니다.

4
00:00:01,094 --> 00:00:04,260
프로그래밍에이 분야에 그래서
나는 우리가 사물의 혼합이다 할 거라고 생각했다.

5
00:00:04,260 --> 00:00:06,340
하나는 조금 할
뭔가 손에,

6
00:00:06,340 --> 00:00:08,690
더 장난을 사용하여이기는하지만
프로그래밍 environment--

7
00:00:08,690 --> 00:00:11,620
의 실증 하나
아이디어 정확히 종류

8
00:00:11,620 --> 00:00:14,220
우리는 얘기를했습니다
하지만 좀 더 공식적으로.

9
00:00:14,220 --> 00:00:18,200
두, 일부 봐
더 기술적 인 방법

10
00:00:18,200 --> 00:00:21,520
프로그래머 실제로 해결한다고
탐색 문제 같은 문제

11
00:00:21,520 --> 00:00:24,530
우리가 전에에서 본과
또한보다 근본적으로

12
00:00:24,530 --> 00:00:26,020
정렬의 흥미로운 문제.

13
00:00:26,020 --> 00:00:28,840
>> 우리는 그냥 가서 얻을에서 가정
그 전화 번호부가 분류되었다,

14
00:00:28,840 --> 00:00:31,980
하지만 혼자가 실제로 종류의
여러 가지 방법으로 어려운 문제

15
00:00:31,980 --> 00:00:32,479
그것을 해결합니다.

16
00:00:32,479 --> 00:00:34,366
그래서 우리는 이러한를 사용합니다
문제 클래스

17
00:00:34,366 --> 00:00:36,740
사물의 대표가
일반적으로 해결 될 수 있습니다.

18
00:00:36,740 --> 00:00:38,980
그리고 우리는 얘기하자
몇 가지 세부 사항에 대한 내용

19
00:00:38,980 --> 00:00:42,360
데이터라고 structures--
연결리스트와 같은 애호가 방법

20
00:00:42,360 --> 00:00:46,290
및 해시 테이블과 나무 그
프로그래머 실제로 것

21
00:00:46,290 --> 00:00:48,890
사용 일반적으로 사용
화이트 보드에 페인트

22
00:00:48,890 --> 00:00:51,840
의 사진 그가 또는 그녀
구현하기위한 구상

23
00:00:51,840 --> 00:00:52,980
소프트웨어의 일부 조각.

24
00:00:52,980 --> 00:00:55,130
>> 그럼 제 1 부분에 손 - 더 할 수 있습니다.

25
00:00:55,130 --> 00:01:00,090
그래서 그냥 더러운 손을 얻을
환경이라고 scratch.mit.edu.

26
00:01:00,090 --> 00:01:02,636
이것은 우리가 사용하는 도구입니다
우리 학부 클래스입니다.

27
00:01:02,636 --> 00:01:04,510
그것은 설계에도 불구하고
12 세까지를위한,

28
00:01:04,510 --> 00:01:07,570
우리는 위쪽을 위해 사용
그 아주 조금의 일부

29
00:01:07,570 --> 00:01:10,020
그것은 좋은 재미 이후
학습의 그래픽 방법

30
00:01:10,020 --> 00:01:12,160
프로그래밍에 대한 작은 선물.

31
00:01:12,160 --> 00:01:17,600
그래서 어디를 그 URL에 머리
확실히이 같은 페이지가 표시됩니다,

32
00:01:17,600 --> 00:01:23,330
그리고 가서 클릭
오른쪽 상단에 스크래치 가입

33
00:01:23,330 --> 00:01:28,300
및 사용자 이름과 선택
암호 궁극적으로 자신을 얻을

34
00:01:28,300 --> 00:01:29,970
account-- scratch.mit.edu.

35
00:01:29,970 --> 00:01:32,165

36
00:01:32,165 --> 00:01:34,665
나는 내가로 사용할 것이라고 생각합니다
기회는 먼저이를 표시합니다.

37
00:01:34,665 --> 00:01:39,120
질문은 휴식 시간 중 등장
무엇에 대한 코드는 실제로처럼 보인다.

38
00:01:39,120 --> 00:01:41,315
그리고 우리가 얘기했다
C에 대한 휴식 시간 중,

39
00:01:41,315 --> 00:01:45,060
에 particular-- 특히
이전 언어로 낮은 수준.

40
00:01:45,060 --> 00:01:47,750
그리고 난 그냥 빨리했다
구글 C 코드를 찾기 위해 검색

41
00:01:47,750 --> 00:01:51,574
이진 검색 알고리즘에 대한 그 우리
일찍 전화 번호부를 검색하는 데 사용됩니다.

42
00:01:51,574 --> 00:01:54,240
이 특별한 예, 물론,
전화 번호부를 검색하지 않습니다.

43
00:01:54,240 --> 00:01:57,840
그것은 단지의 전체 무리를 검색
컴퓨터 메모리의 숫자.

44
00:01:57,840 --> 00:02:01,000
하지만 당신은 단지 시각을 얻을하려는 경우
어떤 실제 프로그래밍의 의미

45
00:02:01,000 --> 00:02:05,370
, 보이는 것처럼 언어 보인다
이 같은 작은 선물.

46
00:02:05,370 --> 00:02:09,759
그래서, 약 20 플러스의
코드의 30 정도 선,

47
00:02:09,759 --> 00:02:12,640
그러나 대화 우리
휴식 시간 동안 가지고 있었던

48
00:02:12,640 --> 00:02:16,000
어떻게이 사실에 있었다
0과 1로 변신됩니다

49
00:02:16,000 --> 00:02:19,200
당신은 단지 그것을 되돌릴 수없는 경우
처리하고 0과 1로 이동

50
00:02:19,200 --> 00:02:20,210
코드에 백업합니다.

51
00:02:20,210 --> 00:02:22,620
>> 불행하게도, 공정
이렇게 변형입니다

52
00:02:22,620 --> 00:02:24,890
그것은 훨씬 쉽게 있다고 말하기는.

53
00:02:24,890 --> 00:02:29,400
내가 나서서 실제로 설정
그 프로그램, 이진 검색,

54
00:02:29,400 --> 00:02:32,700
(A)의 방법에 의해 0과 1로
프로그램은 컴파일러를 호출하는 I

55
00:02:32,700 --> 00:02:34,400
내 Mac에서 바로 여기가하는 일.

56
00:02:34,400 --> 00:02:37,850
그리고 당신은 화면을 보면
여기에 특별히 초점을 맞추고

57
00:02:37,850 --> 00:02:43,520
이 가운데 여섯 컬럼 만,
당신은 단지 0과 1을 볼 수 있습니다.

58
00:02:43,520 --> 00:02:48,290
그리고 그는 0과 1이다 그
정확하게 검색 프로그램을 구성한다.

59
00:02:48,290 --> 00:02:53,720
>> 그리고 5 비트의 각 청크,
여기에 0과 1의 각 바이트,

60
00:02:53,720 --> 00:02:57,310
일부 명령을 나타냅니다
일반적으로 컴퓨터의 내부.

61
00:02:57,310 --> 00:03:00,730
그리고 사실, 당신이 들었어요 경우
마케팅 슬로건 "인텔 인사이드"- 즉,

62
00:03:00,730 --> 00:03:04,610
물론, 당신은이 의미
컴퓨터 내부의 인텔 CPU 또는 뇌.

63
00:03:04,610 --> 00:03:08,000
그리고는 CPU가된다는 것이 무엇을 의미하는지
당신은 명령어 세트를 가지고,

64
00:03:08,000 --> 00:03:08,840
말하자면.

65
00:03:08,840 --> 00:03:11,620
>> 많은 세계의 모든 CPU,
그들에게이 일 인텔에 의해,

66
00:03:11,620 --> 00:03:13,690
유한 이해
지침의 수입니다.

67
00:03:13,690 --> 00:03:18,690
그리고 그 명령은 매우 낮은 수준이다
으로는,이 두 번호를 추가

68
00:03:18,690 --> 00:03:22,560
이 두 숫자를 곱하면,
여기에서 데이터의이 조각을 이동

69
00:03:22,560 --> 00:03:27,340
여기에 메모리에이를 저장
여기에서 정보는 메모리에 여기까지

70
00:03:27,340 --> 00:03:32,200
그래서 forth-- 때문에 매우
낮은 수준의 거의 전자 세부 사항.

71
00:03:32,200 --> 00:03:34,780
하지만 그 수학적으로
작업 결합

72
00:03:34,780 --> 00:03:37,410
우리는 앞에서 설명한 것과,
데이터의 표현

73
00:03:37,410 --> 00:03:40,450
수 0과 같은
당신은 모든 것을 구축

74
00:03:40,450 --> 00:03:44,180
컴퓨터가 있는지, 오늘 할 수있는
그것은, 텍스트, 그래픽, 음악의

75
00:03:44,180 --> 00:03:45,580
또는 그렇지 않으면.

76
00:03:45,580 --> 00:03:49,450
>> 그래서이 얻을 매우 쉽습니다
신속의 잡초에 잃었다.

77
00:03:49,450 --> 00:03:52,150
그리고 많은있다
구문 도전

78
00:03:52,150 --> 00:03:56,630
이에는 간단한 할 경우,
프로그램의 오타 없음의 멍청한

79
00:03:56,630 --> 00:03:57,860
무엇이든지 작동합니다.

80
00:03:57,860 --> 00:04:00,366
그래서 대신를 사용하여
C와 같은 언어 오늘 아침,

81
00:04:00,366 --> 00:04:02,240
나는 것이라고 생각
더 재미있는 사실은해야 할 일

82
00:04:02,240 --> 00:04:04,840
시각적 뭔가하는
아이들을위한 설계하면서

83
00:04:04,840 --> 00:04:08,079
완벽한 표현은 실제로
실제 프로그래밍

84
00:04:08,079 --> 00:04:10,370
language-- 단지에 발생
텍스트 대신 이미지를 사용

85
00:04:10,370 --> 00:04:11,710
그 아이디어를 나타냅니다.

86
00:04:11,710 --> 00:04:15,470
>> 당신은 참으로이되면 그래서
scratch.mit.edu에 계정,

87
00:04:15,470 --> 00:04:21,070
버튼 만들기 클릭
상단에있는 사이트의 왼쪽.

88
00:04:21,070 --> 00:04:24,620
그리고 당신은 같은 환경을 볼 수
내 화면에 표시하려고 해요 하나

89
00:04:24,620 --> 00:04:26,310
이리.

90
00:04:26,310 --> 00:04:29,350
그리고 우리는 조금을 보내고 있습니다
시간의 비트가 여기에 재생합니다.

91
00:04:29,350 --> 00:04:34,080
우리는 모두 몇 가지를 해결할 수없는 경우 보자
다음과 같은 방식으로 함께 문제.

92
00:04:34,080 --> 00:04:39,420
>> 그래서 당신이 내 볼 수 있습니다
environment-- 실제로 그냥하자

93
00:04:39,420 --> 00:04:40,050
나 일시 중지합니다.

94
00:04:40,050 --> 00:04:42,680
사람이 여기 없어?

95
00:04:42,680 --> 00:04:45,070
여기가 아님?

96
00:04:45,070 --> 00:04:45,800
승인.

97
00:04:45,800 --> 00:04:49,030
그래서 내가 몇 가지를 지적하자
이 환경의 특성.

98
00:04:49,030 --> 00:04:55,024
>> 화면의 왼쪽 상단 그래서, 우리
스크래치의 무대를 가지고, 말하자면.

99
00:04:55,024 --> 00:04:57,440
스크래치뿐만 아니라 이름입니다
이 프로그래밍 언어의;

100
00:04:57,440 --> 00:05:00,356
또한 고양이의 이름의 그
당신은 오렌지가 기본적으로 참조하십시오.

101
00:05:00,356 --> 00:05:02,160
그는, 무대에 너무
많은 내가 설명 등

102
00:05:02,160 --> 00:05:05,770
A의 인 것으로 이전 거북이
직사각형 화이트 보드 환경을 제공합니다.

103
00:05:05,770 --> 00:05:09,800
이 고양이의 세계는 완전히 한정된다
거기에 그 사각형까지 가기.

104
00:05:09,800 --> 00:05:12,210
>> 한편, 오른쪽에
여기서 편, 그것의

105
00:05:12,210 --> 00:05:15,610
그냥 스크립트 영역,
빈 슬레이트가됩니다.

106
00:05:15,610 --> 00:05:18,590
이것은 우리가 쓸거야 어디
그냥 순간에 우리의 프로그램.

107
00:05:18,590 --> 00:05:22,935
그리고 빌딩 블록을 우리가하여야한다
이 퍼즐을 program-- 작성하는 데 사용할

108
00:05:22,935 --> 00:05:25,310
조각, 당신이 will-- 경우
중간에 바로 여기,

109
00:05:25,310 --> 00:05:27,500
그들은 분류하고
기능에 의해.

110
00:05:27,500 --> 00:05:31,000
그래서, 예를 들어, 내가 가서거야
이들 중 적어도 하나를 보여준다.

111
00:05:31,000 --> 00:05:33,690
내가 가서 클릭거야
맨 위로 제어 범주.

112
00:05:33,690 --> 00:05:35,720
>> 그래서이 최고 최대 범주입니다.

113
00:05:35,720 --> 00:05:39,410
나는 컨트롤 범주를 클릭거야.

114
00:05:39,410 --> 00:05:44,020
오히려, 나는 이벤트를 클릭거야
카테고리, 맨 처음 일까지 최고.

115
00:05:44,020 --> 00:05:47,790
그리고 당신도 함께 수행하려는 경우
우리가 이렇게, 당신은 아주 환영합니다.

116
00:05:47,790 --> 00:05:52,180
나는 클릭하고이를 끌어 갈거야
첫 번째, "녹색 깃발을 클릭."

117
00:05:52,180 --> 00:05:58,410
그리고 난 그냥 드롭거야
대략 내 빈 슬레이트의 상단에.

118
00:05:58,410 --> 00:06:01,450
>> 그리고 스크래치에 대한 좋은거야
인이 퍼즐 조각, 때

119
00:06:01,450 --> 00:06:04,560
다른 퍼즐과 연동
조각, 문자 그대로 할 것입니다

120
00:06:04,560 --> 00:06:06,460
그 퍼즐 조각은 할 말.

121
00:06:06,460 --> 00:06:09,710
그래서, 예를 들어, 스크래치가 맞다
지금 자신의 세계의 중간에있다.

122
00:06:09,710 --> 00:06:14,660
내가 가서 선택하는거야
지금의 말을하자, 모션 카테고리,

123
00:06:14,660 --> 00:06:18,000
당신은 작업을 수행하려는 경우
모션 카테고리를 똑같이,.

124
00:06:18,000 --> 00:06:20,430
그리고 지금은 전체가 알
여기에 퍼즐 조각의 무리

125
00:06:20,430 --> 00:06:23,370
다시 종류의 할 것을 그들이 무슨 말을.

126
00:06:23,370 --> 00:06:28,110
내가 가서 끌어거야
바로 여기 이동 블록을 놓습니다.

127
00:06:28,110 --> 00:06:31,860
>> 그리고 그 즉시 당신이 얻을로 주목
은 "녹색 깃발의 바닥에 근접

128
00:06:31,860 --> 00:06:34,580
클릭 "버튼 예고
방법 흰색 선이 나타납니다,

129
00:06:34,580 --> 00:06:36,950
거의 비록로
자기, 거기 가고 싶어.

130
00:06:36,950 --> 00:06:43,070
그냥 가자, 그리고 스냅됩니다
함께와 모양이 일치합니다.

131
00:06:43,070 --> 00:06:46,620
그리고 지금 당신이 할 수있는, 아마도 거의
우리가 함께가는 곳 같아요.

132
00:06:46,620 --> 00:06:51,570
>> 당신은 스크래치 단계에서 보면
여기에 그것을의 상단에 보면,

133
00:06:51,570 --> 00:06:55,142
당신은 붉은 빛을 볼 수하는
기호 및 녹색 깃발을 중지합니다.

134
00:06:55,142 --> 00:06:57,100
그리고 앞서 갈거야
내 screen--를보고

135
00:06:57,100 --> 00:06:58,460
단지 순간을 위해, 당신이 할 수있는 경우.

136
00:06:58,460 --> 00:07:01,960
난을 클릭거야
지금 깃발을 녹색,

137
00:07:01,960 --> 00:07:07,850
그는 10 단계로 보이는 이동
또는 화면에 10 픽셀, 10 점.

138
00:07:07,850 --> 00:07:13,390
>> 그리고 그 흥분하지,
하지만 내가 제안하자

139
00:07:13,390 --> 00:07:17,440
심지어이 교육없이 바로
자신의 intuition--하자 자신을 사용하여

140
00:07:17,440 --> 00:07:22,560
나 당신이 방법을 알아낼 것을 제안한다
바로 단계 떨어져 스크래치 산책을합니다.

141
00:07:22,560 --> 00:07:28,700
그를의 오른쪽위한 방법을 만들기 적이
화면 오른쪽 끝까지.

142
00:07:28,700 --> 00:07:32,200
내가 당신에게 잠시 시간을 줘 보자
정도 그와 씨름합니다.

143
00:07:32,200 --> 00:07:37,681
당신이보고 싶을 수도
블록의 다른 카테고리에서.

144
00:07:37,681 --> 00:07:38,180
괜찮아.

145
00:07:38,180 --> 00:07:41,290
그래서 그냥 우리가있을 때, 요약하자면
녹색 깃발은 여기를 클릭

146
00:07:41,290 --> 00:07:44,850
10 단계를입니다 이동
전용 명령어마다 I

147
00:07:44,850 --> 00:07:46,720
녹색 깃발을 클릭, 무슨 일이야?

148
00:07:46,720 --> 00:07:50,070
글쎄, 내 프로그램을 실행합니다.

149
00:07:50,070 --> 00:07:52,450
그래서 나는이 작업을 수행 할 수
아마 수동으로 10 배,

150
00:07:52,450 --> 00:07:55,130
그러나 이것은 조금 느낌
비트 hackish 때문에, 말하자면

151
00:07:55,130 --> 00:07:57,480
이에 정말 아니에요
과제를 해결하기.

152
00:07:57,480 --> 00:08:00,530
난 그냥 다시 노력하고있어 및
다시 또 다시

153
00:08:00,530 --> 00:08:03,180
때까지 나는 종류의 실수
지시문을 달성

154
00:08:03,180 --> 00:08:05,560
것을 나는 이전에 달성하기 위해 밖으로 설정합니다.

155
00:08:05,560 --> 00:08:08,200
>> 그러나 우리는 알고 우리의
의사 이전이 있다고

156
00:08:08,200 --> 00:08:11,870
루프의 프로그램에서이 개념,
또 다시 일을하고.

157
00:08:11,870 --> 00:08:14,888
그리고 내가 본 당신의 무리
어떤 퍼즐 조각을 위해 도달?

158
00:08:14,888 --> 00:08:17,870

159
00:08:17,870 --> 00:08:18,730
때까지 반복합니다.

160
00:08:18,730 --> 00:08:21,400
그래서 우리는 뭔가를 할 수
같은 때까지 반복합니다.

161
00:08:21,400 --> 00:08:23,760
그리고 당신은 정확히까지 무엇을 반복 했습니까?

162
00:08:23,760 --> 00:08:27,720

163
00:08:27,720 --> 00:08:28,540
>> 승인.

164
00:08:28,540 --> 00:08:31,974
그리고 나에게있어 하나 가자
단지 잠시 동안 다소 간단합니다.

165
00:08:31,974 --> 00:08:33,140
내가 가서이 작업을 수행 할 수 있습니다.

166
00:08:33,140 --> 00:08:35,559
당신이 가진 수 있으므로, 그 주목
컨트롤에서 발견,

167
00:08:35,559 --> 00:08:38,409
이 반복 블록은 존재하는
그것처럼 보이지 않는 것은이 크다.

168
00:08:38,409 --> 00:08:41,039
에하지 여지가있다
그 두 개의 노란색 선 사이.

169
00:08:41,039 --> 00:08:43,539
그러나로 당신의 일부는있을 수 있습니다
드래그 앤 드롭하면, 발견,

170
00:08:43,539 --> 00:08:45,150
이 모양을 채우기 위해 성장하는 방법을 알 수 있습니다.

171
00:08:45,150 --> 00:08:46,274
>> 그리고 당신은 더 많은 벼락 공부 할 수 있습니다.

172
00:08:46,274 --> 00:08:48,670
그냥 경우 성장하겠습니다
당신은 드래그하고 위에 마우스를 올려.

173
00:08:48,670 --> 00:08:51,110
그리고 나는 무엇을 모른다
여기에 가장 좋은, 그래서하자

174
00:08:51,110 --> 00:08:54,760
나 이상에 대해 5 회 반복
인스턴스는 다음 단계로 돌아가

175
00:08:54,760 --> 00:08:56,720
및 녹색 깃발을 클릭합니다.

176
00:08:56,720 --> 00:08:59,110
그리고 지금은 꽤가 아니라 알 수 있습니다.

177
00:08:59,110 --> 00:09:02,400
>> 이제 여러분 중 일부는 다음과 같이 제안
빅토리아는 10 번 반복했다.

178
00:09:02,400 --> 00:09:05,140
그리고 일반적으로 수행
모든 방법을 잡을,

179
00:09:05,140 --> 00:09:10,510
하지만 거기하고자하면보다 강력한 될
임의의 파악보다 훨씬

180
00:09:10,510 --> 00:09:12,640
얼마나 많은 움직임을 만들어?

181
00:09:12,640 --> 00:09:17,680
무엇이 더 나은 블록 수 있습니다
반복보다 10 배는 될?

182
00:09:17,680 --> 00:09:20,380
>> 그래, 왜 영원히 뭔가를하지?

183
00:09:20,380 --> 00:09:24,390
그리고 지금 내가이 퍼즐 조각을 이동하자
이 안에이 하나 제거.

184
00:09:24,390 --> 00:09:28,300
지금 어디 스크래치없이 통지
시작, 그는 가장자리로 이동합니다.

185
00:09:28,300 --> 00:09:30,700
그리고 다행히도 MIT,
누가 그냥 스크래치를 만든다

186
00:09:30,700 --> 00:09:33,190
확실히 그는 그 절대하지 않습니다
완전히 사라집니다.

187
00:09:33,190 --> 00:09:35,360
당신은 항상 자신의 꼬리를 잡을 수 있습니다.

188
00:09:35,360 --> 00:09:37,680
>> 그리고 바로 직관적으로,
왜 그는 계속 움직이고 있습니까?

189
00:09:37,680 --> 00:09:38,892
무슨 일이야?

190
00:09:38,892 --> 00:09:41,440

191
00:09:41,440 --> 00:09:43,824
그는 중지 한 것으로 보이지만
나는 드래그를 선택 후 경우

192
00:09:43,824 --> 00:09:45,240
그는 거기 가고 싶은 유지합니다.

193
00:09:45,240 --> 00:09:46,123
그 이유는 무엇입니까?

194
00:09:46,123 --> 00:09:51,610

195
00:09:51,610 --> 00:09:54,360
정말, 컴퓨터는 그대로입니다
당신이 그것을 말해 무엇을 할 것.

196
00:09:54,360 --> 00:09:58,380
당신이 그것을 말했다 그래서 만약 이전을
영원히 일을 다음, 10 단계를 이동,

197
00:09:58,380 --> 00:10:01,860
가서 계속 것
나는 붉은 정지 신호를 칠 때까지

198
00:10:01,860 --> 00:10:04,620
그리고 모두 프로그램을 중지합니다.

199
00:10:04,620 --> 00:10:06,610
>> 당신은하지 않았다 그래서 경우에도
이렇게, 어떻게 내가 할 수

200
00:10:06,610 --> 00:10:09,510
빠른 스크래치 이동을
화면에서?

201
00:10:09,510 --> 00:10:12,060

202
00:10:12,060 --> 00:10:13,280
더 많은 단계, 오른쪽?

203
00:10:13,280 --> 00:10:15,710
그래서 그 대신 10 일을
한 번에, 왜 우리는하지 않습니다

204
00:10:15,710 --> 00:10:20,100
가서 그것을 건 ... 변경
당신은 (50)은 무엇 propose-- 것인가?

205
00:10:20,100 --> 00:10:24,410
그래서 지금은 녹색을 클릭거야
플래그는, 실제로, 그는 정말 빨리 간다.

206
00:10:24,410 --> 00:10:27,180
>> 물론 이것은 그냥
애니메이션의 표현.

207
00:10:27,180 --> 00:10:28,060
애니메이션은 무엇입니까?

208
00:10:28,060 --> 00:10:33,090
그것은 단지 당신에게 인간의을 보여주는 것
정말 정지 영상의 전체 무리,

209
00:10:33,090 --> 00:10:34,160
정말, 정말 빨라요.

210
00:10:34,160 --> 00:10:36,500
그리고 그래서 만약 우리가 그냥 말하는 거
그에게 더 많은 단계를 이동,

211
00:10:36,500 --> 00:10:39,750
우리는 단지 효과가있을 데있어
그 화면에 변화

212
00:10:39,750 --> 00:10:42,900
시간을 더욱 빠르게 당 단위.

213
00:10:42,900 --> 00:10:46,454
>> 내가 제안 이제 다음 도전
그 가장자리를 반송해야하는 것이 었습니다.

214
00:10:46,454 --> 00:10:49,120
그리고 무엇 퍼즐 모르고
그것을 잘 때문에 조각 exist--

215
00:10:49,120 --> 00:10:53,030
당신은에 도착하지 않는 경우
challenge--의 단계 무엇을

216
00:10:53,030 --> 00:10:54,280
당신은 직관적으로 수행 할 수 있습니까?

217
00:10:54,280 --> 00:10:58,030
어떻게 우리가 그를 다시 반송해야하고
항 좌우 사이?

218
00:10:58,030 --> 00:11:02,630

219
00:11:02,630 --> 00:11:03,810
>> 네.

220
00:11:03,810 --> 00:11:05,680
그래서 우리는 어떤 종류의 필요
조건, 그리고 우리

221
00:11:05,680 --> 00:11:09,710
에, 그래서 조건문을 갖고있는 것 같다
컨트롤 범주, 말한다.

222
00:11:09,710 --> 00:11:14,110
이들 블록 중
우리는 아마 하시겠습니까?

223
00:11:14,110 --> 00:11:15,200
그래, 어쩌면 "만약, 그럼."

224
00:11:15,200 --> 00:11:18,780
그래서 노란색 블록 사이에 그 통지
우리는이 "만일"이 여기에있다

225
00:11:18,780 --> 00:11:23,920
또는이 "만약, 다른"방어 것
우리 이렇게 결정을 내릴 수 있도록

226
00:11:23,920 --> 00:11:25,000
또는 그렇게 할 수 있습니다.

227
00:11:25,000 --> 00:11:27,380
그리고 당신이 할 수도 둥지를
여러 일을 할 수 있습니다.

228
00:11:27,380 --> 00:11:34,910
아니면 아직 여기 사라없는 한 경우,
감지 범주에 가서

229
00:11:34,910 --> 00:11:39,612
그리고 -이 여기에 있는지 보자.

230
00:11:39,612 --> 00:11:43,050

231
00:11:43,050 --> 00:11:52,050
>> 그래서 블록 여기에 도움이 될 수 있습니다
그가 단계 떨어져 있는지 감지하는 방법?

232
00:11:52,050 --> 00:11:56,740
그래,이 블록의 일부를 알
매개 변수화 될 수있다, 말하자면.

233
00:11:56,740 --> 00:12:00,706
그들은 일종의 아니라 사용자 정의 할 수 있습니다
HTML과는 달리 어제 속성,

234
00:12:00,706 --> 00:12:03,330
어디 그 속성의 종류
태그의 동작을 사용자 정의 할 수 있습니다.

235
00:12:03,330 --> 00:12:08,880
마찬가지로 여기,이 감동을 잡을 수 있습니다
블록과 변화와 질문을,

236
00:12:08,880 --> 00:12:11,500
당신은 마우스를 건드리지있다
커서와 같은 포인터

237
00:12:11,500 --> 00:12:13,250
또는 당신은 가장자리를 만지고있다?

238
00:12:13,250 --> 00:12:15,210
>> 그래서 내가 가서이 작업을 수행 할 수 있습니다.

239
00:12:15,210 --> 00:12:18,130
나는 잠시 축소거야.

240
00:12:18,130 --> 00:12:21,320
날이 퍼즐 조각을 잡아 보자
여기,이 퍼즐 조각이,

241
00:12:21,320 --> 00:12:24,570
나는 뒤범벅거야
단지 잠시 동안 그들입니다.

242
00:12:24,570 --> 00:12:27,620
나는이 이동거야
감동 가장자리로 변경,

243
00:12:27,620 --> 00:12:38,590
이렇게 나는 운동에 갈거야.

244
00:12:38,590 --> 00:12:40,490
그래서 여기에 몇 가지 성분입니다.

245
00:12:40,490 --> 00:12:42,570
나는 내가 원하는 모든 것을 가지고 생각합니다.

246
00:12:42,570 --> 00:12:47,710
>> 누군가가 방법을 제안 하시겠습니까 I
이 아마 위에서 아래로 연결할 수 있습니다

247
00:12:47,710 --> 00:12:52,020
갖는 문제를 해결하기 위해서
스크래치 이동에 왼쪽에서 오른쪽으로 오른쪽

248
00:12:52,020 --> 00:12:57,020
각 왼쪽으로 왼쪽에서 오른쪽으로
시간은 벽 떨어져 튀는?

249
00:12:57,020 --> 00:12:58,050
내가 뭘 할 수 있습니까?

250
00:12:58,050 --> 00:13:01,097
어떤 블록 내가 연결해야
"녹색 깃발 먼저 클릭"?

251
00:13:01,097 --> 00:13:04,060

252
00:13:04,060 --> 00:13:06,200
>> OK, 그래서이 시작하자 "영원히."

253
00:13:06,200 --> 00:13:07,170
무엇 다음 내부 간다?

254
00:13:07,170 --> 00:13:10,290
다른 사람.

255
00:13:10,290 --> 00:13:11,850
확인 단계를 이동합니다.

256
00:13:11,850 --> 00:13:12,350
괜찮아.

257
00:13:12,350 --> 00:13:14,470
그리고 뭐?

258
00:13:14,470 --> 00:13:15,120
그래서 다음 경우.

259
00:13:15,120 --> 00:13:17,720
그리고 보이는 경우에도 통지
단단히 함께 샌드위치,

260
00:13:17,720 --> 00:13:19,500
그냥 채우기 위해 성장할 것입니다.

261
00:13:19,500 --> 00:13:21,500
그것은 단지 내가 원하는 위치로 이동합니다.

262
00:13:21,500 --> 00:13:25,920
>> 그리고 사이에 무엇을 넣을까요
는 IF와 다음?

263
00:13:25,920 --> 00:13:27,180
아마 "경우 가장자리를 터치."

264
00:13:27,180 --> 00:13:31,800
통지는, 다시, 너무 크다
그것을 위해,하지만 채우기 위해 성장할 것입니다.

265
00:13:31,800 --> 00:13:35,002
그리고 15도 회전?

266
00:13:35,002 --> 00:13:35,710
몇도?

267
00:13:35,710 --> 00:13:38,800

268
00:13:38,800 --> 00:13:41,196
그래, 그래서 (180)는 회전합니다
내 주위 모든 방법.

269
00:13:41,196 --> 00:13:42,570
그래서이 권리를 가지고 있는지 알아 보자.

270
00:13:42,570 --> 00:13:43,930
나 축소 할 수 있습니다.

271
00:13:43,930 --> 00:13:45,130
>> 나 스크래치까지 드래그 할 수 있습니다.

272
00:13:45,130 --> 00:13:50,030
그래서 그는 왜곡 약간의
지금,하지만 괜찮아요.

273
00:13:50,030 --> 00:13:52,231
어떻게 쉽게 그를 다시 할 수 있습니까?

274
00:13:52,231 --> 00:13:59,879

275
00:13:59,879 --> 00:14:01,045
나는 약간 속이려고하고있다.

276
00:14:01,045 --> 00:14:04,074

277
00:14:04,074 --> 00:14:05,990
그래서 다른 추가 해요
블록은 단지 명확합니다.

278
00:14:05,990 --> 00:14:08,424
나는 그 90도를 가리 키도록 할
기본적으로 오른쪽으로,

279
00:14:08,424 --> 00:14:10,840
그래서 난 그냥 그에게거야
프로그래밍 방식으로 그렇게 할 수 있습니다.

280
00:14:10,840 --> 00:14:11,632
그리고 여기 우리는 간다.

281
00:14:11,632 --> 00:14:14,740

282
00:14:14,740 --> 00:14:15,740
우리는 그것을 한 것 같다.

283
00:14:15,740 --> 00:14:19,980
이 때문에, 조금 이상한
그는 거꾸로 걸어.

284
00:14:19,980 --> 00:14:21,250
의 버그 있음을 부르 자.

285
00:14:21,250 --> 00:14:22,120
그건 실수.

286
00:14:22,120 --> 00:14:27,320
버그 프로그램,의 실수
I, 인간이 만든 논리 오류가 발생했습니다.

287
00:14:27,320 --> 00:14:28,985
왜 거꾸로거야?

288
00:14:28,985 --> 00:14:33,560

289
00:14:33,560 --> 00:14:35,250
MIT는 망치 또는 I을했다나요?

290
00:14:35,250 --> 00:14:38,840

291
00:14:38,840 --> 00:14:42,550
>> 그래, 내 말은, 그것은 MIT의 아니에요
결점. 그들은 나에게 퍼즐 조각을했다

292
00:14:42,550 --> 00:14:44,970
그 정도의 어떤 수를 설정했다.

293
00:14:44,970 --> 00:14:47,672
그리고 빅토리아의 제안에,
나는 180도 회전하고있어,

294
00:14:47,672 --> 00:14:48,880
이는 바로 직관이다.

295
00:14:48,880 --> 00:14:53,700
그러나 사실상 180도 선회
180 ° 회전 수단

296
00:14:53,700 --> 00:14:55,860
그것은 정말 아니다
내가 원하는, 분명히.

297
00:14:55,860 --> 00:14:58,026
적어도 그가에있어 때문에
이 2 차원의 세계,

298
00:14:58,026 --> 00:15:00,740
그래서 터닝 정말 가고
거꾸로 그를 플립합니다.

299
00:15:00,740 --> 00:15:04,030
>> 아마 어떤 블록을 사용하려면
당신이 여기에서 무엇을 볼 대신에, 기초?

300
00:15:04,030 --> 00:15:11,890

301
00:15:11,890 --> 00:15:14,790
우리는 어떻게이 해결할 수 있습니까?

302
00:15:14,790 --> 00:15:18,380
그래, 그래서 우리는 지점 수
반대 방향이다.

303
00:15:18,380 --> 00:15:22,300
그리고 실제로 심지어이다
충분히 될 수 없습니다,

304
00:15:22,300 --> 00:15:26,410
우리는 하드 코드 할 수 있기 때문에
왼쪽이나 오른쪽을 가리키는 것이다.

305
00:15:26,410 --> 00:15:27,920
>> 당신은 우리가 무엇을 할 수 있는지 알아?

306
00:15:27,920 --> 00:15:30,160
우리는이 것 같습니다
여기에 편의를 블록.

307
00:15:30,160 --> 00:15:32,987
내가 확대 할 경우, 참조
뭔가 우리가 여기 좋아?

308
00:15:32,987 --> 00:15:36,120

309
00:15:36,120 --> 00:15:40,020
MIT는이 같은 그것은 본다
추상화는 여기에 내장.

310
00:15:40,020 --> 00:15:45,440
이 블록은 동등한 것으로 보인다
다른 블록, 복수하는에?

311
00:15:45,440 --> 00:15:49,510
>> 이 하나의 블록은 동등한 것으로 보인다
블록이 전체의 트리오에

312
00:15:49,510 --> 00:15:50,880
것을 우리는 여기에 있습니다.

313
00:15:50,880 --> 00:15:54,670
이 밝혀 그래서 나는 단순화 할 수 있습니다 내
이 모든 치우는에 의해 프로그램

314
00:15:54,670 --> 00:15:58,270
바로 여기에 넣고.

315
00:15:58,270 --> 00:16:01,620
그리고 지금 그는 여전히 약간의
버그, 그리고 지금은 괜찮습니다.

316
00:16:01,620 --> 00:16:03,370
우리는이 떠날 것입니다.

317
00:16:03,370 --> 00:16:06,000
하지만 내 프로그램은 짝수
간단하게,이 역시

318
00:16:06,000 --> 00:16:09,060
대표적인 것
programming--의 목표

319
00:16:09,060 --> 00:16:13,430
이상적으로 코드를 확인하는 것입니다
간단한 가능한 분체,

320
00:16:13,430 --> 00:16:15,650
여전히 같이하면서
가능한 읽을.

321
00:16:15,650 --> 00:16:20,310
당신은 너무 간결하게하고 싶지 않아
이 어려운 것을 이해합니다.

322
00:16:20,310 --> 00:16:22,826
>> 하지만 교체 한 알
하나 세 블록,

323
00:16:22,826 --> 00:16:24,200
그것은 틀림없이 좋은 일이다.

324
00:16:24,200 --> 00:16:27,280
나는 개념을 멀리 추상화 한
의 당신이있어 여부를 확인

325
00:16:27,280 --> 00:16:29,120
한 블록 가장자리에.

326
00:16:29,120 --> 00:16:31,520
이제 우리는 사실이 재미를 가질 수 있습니다.

327
00:16:31,520 --> 00:16:35,790
이것은 너무 많이 추가하지 않습니다
지적 값하지만 장난 값입니다.

328
00:16:35,790 --> 00:16:39,730
나는 앞서 갈거야
여기에이 소리를 잡아.

329
00:16:39,730 --> 00:16:42,900

330
00:16:42,900 --> 00:16:46,420
그래서 내가 가서 보자, 나를 보자
잠시 프로그램을 중지합니다.

331
00:16:46,420 --> 00:16:52,070
나는 다음을 기록하는거야,
내 마이크에 대한 액세스를 허용한다.

332
00:16:52,070 --> 00:16:53,181
>> 여기에서 우리는 간다.

333
00:16:53,181 --> 00:16:53,680
아야.

334
00:16:53,680 --> 00:16:58,710

335
00:16:58,710 --> 00:17:01,140
이제 다시 해보자.

336
00:17:01,140 --> 00:17:02,279
여기에서 우리는 간다.

337
00:17:02,279 --> 00:17:03,570
OK, 나는 잘못된 일을 기록했다.

338
00:17:03,570 --> 00:17:04,580
여기에서 우리는 간다.

339
00:17:04,580 --> 00:17:05,080
아야.

340
00:17:05,080 --> 00:17:07,910

341
00:17:07,910 --> 00:17:08,800
아야.

342
00:17:08,800 --> 00:17:09,300
괜찮아.

343
00:17:09,300 --> 00:17:10,791
지금은 그 제거해야합니다.

344
00:17:10,791 --> 00:17:11,290
괜찮아.

345
00:17:11,290 --> 00:17:13,950
>> 그래서 지금 내가 가지고
단지의 기록 "아야."

346
00:17:13,950 --> 00:17:18,040
지금 그래서 내가 갈거야
앞서이 "아야."전화

347
00:17:18,040 --> 00:17:20,270
나는 돌아갈거야
내 스크립트, 그리고 지금

348
00:17:20,270 --> 00:17:25,460
통지라고이 블록이있다
사운드 "야옹"을 재생하거나 사운드를 재생 "아야."

349
00:17:25,460 --> 00:17:28,920
나는이 끌어 가고, 어디 있어요
나는 코믹 효과를 위해이를 넣어해야합니까?

350
00:17:28,920 --> 00:17:31,740

351
00:17:31,740 --> 00:17:37,860
그래, 그래서 지금은 가지입니다
버그가 있기 때문에 지금이 block--

352
00:17:37,860 --> 00:17:42,050
알 방법이 "가장자리에있는 경우,
바운스는 "급식의 일종이다.

353
00:17:42,050 --> 00:17:43,704
그래서이 문제를 해결해야합니다.

354
00:17:43,704 --> 00:17:44,870
내가 가서이 작업을 수행 할 수 있습니다.

355
00:17:44,870 --> 00:17:48,630
날이 없애 보자 돌아가
우리의 원래의,보다 신중한

356
00:17:48,630 --> 00:17:49,870
기능을 제공합니다.

357
00:17:49,870 --> 00:18:01,080
"가장자리를 터치하면 다음"그래서 내가 원하는
빅토리아는 제안으로, 회전하기,

358
00:18:01,080 --> 00:18:02,480
180도.

359
00:18:02,480 --> 00:18:05,497
그리고 내가 놀고 싶어 할
이 "아야"소리?

360
00:18:05,497 --> 00:18:11,800

361
00:18:11,800 --> 00:18:15,580
>> 그래, 외부의 알
그 노란색 블록.

362
00:18:15,580 --> 00:18:17,680
이 때문에, 너무 될 것
버그,하지만 난 그것을 나타났습니다.

363
00:18:17,680 --> 00:18:21,290
그래서 여기에 그것을 끌어거야,
통지 지금은 내부의 "만약."

364
00:18:21,290 --> 00:18:24,250
은 "만약"그래서 이런 종류입니다
같은 암 같은 오의

365
00:18:24,250 --> 00:18:26,260
그는 것
그 안에 무엇이 않습니다.

366
00:18:26,260 --> 00:18:30,216
그래서 지금은에서 축소하는 경우
annoying--의 위험

367
00:18:30,216 --> 00:18:32,860

368
00:18:32,860 --> 00:18:36,470
>> 컴퓨터 : 아야, 아야, 아야.

369
00:18:36,470 --> 00:18:39,910
>> DAVID 마란 : 그리고
그냥 영원히 갈 것입니다.

370
00:18:39,910 --> 00:18:44,160
지금은 단지 물건을 가속
여기, 내가 가서 열어 보자,

371
00:18:44,160 --> 00:18:50,460
의 날 일부에 가자 say--하자
클래스 내 자신의 물건.

372
00:18:50,460 --> 00:18:53,000

373
00:18:53,000 --> 00:19:00,220
그리고 이제,이 말을하자, 나를 열어 보자
하나는 우리의 교육 동료 중 하나에 의해 만들어진

374
00:19:00,220 --> 00:19:01,500
몇 년 전에.

375
00:19:01,500 --> 00:19:04,732
그래서 일부는 기억 수도 있습니다
작년부터이 게임,

376
00:19:04,732 --> 00:19:05,940
그것은 놀라운 사실이다.

377
00:19:05,940 --> 00:19:08,190
우리가 한 경우에도
지금은 프로그램의 간단한,

378
00:19:08,190 --> 00:19:09,980
의 어떤이를 생각해 보자
실제로처럼 보인다.

379
00:19:09,980 --> 00:19:10,650
내가 플레이를 공격 할 수 있습니다.

380
00:19:10,650 --> 00:19:14,210

381
00:19:14,210 --> 00:19:18,980
>> 그래서이 게임에서, 우리는이
개구리, 화살표를 사용하여 keys--

382
00:19:18,980 --> 00:19:23,340
그는 내가 꼭 기억해보다 더 큰 조치를 취하고
나는이 개구리 제어 할 수 있습니다.

383
00:19:23,340 --> 00:19:29,630
그리고 목표는 바쁜에서 얻을 수 있습니다
자동차로 실행하지 않고 도로​​.

384
00:19:29,630 --> 00:19:34,735
그리고, 내가 여기 가면의이 see--하자 I
로그가로 스크롤 할 때까지 기다릴 필요가.

385
00:19:34,735 --> 00:19:38,130

386
00:19:38,130 --> 00:19:39,274
이 버그 같은 느낌이 든다.

387
00:19:39,274 --> 00:19:42,240

388
00:19:42,240 --> 00:19:43,495
이 버그의 일종이다.

389
00:19:43,495 --> 00:19:45,980

390
00:19:45,980 --> 00:19:46,480
괜찮아.

391
00:19:46,480 --> 00:19:51,550
나는 여기에있어
거기에, 그리고 당신은 유지

392
00:19:51,550 --> 00:19:54,100
모든 얻을 때까지가는
릴리 패드에 개구리.

393
00:19:54,100 --> 00:19:55,920
지금이 보일 수 있습니다
더욱 복잡한

394
00:19:55,920 --> 00:19:57,840
하지만의 휴식을 시도하자
이 아래로 정신적으로

395
00:19:57,840 --> 00:20:00,040
구두 및 그 구성 블록으로.

396
00:20:00,040 --> 00:20:03,910
그래서 아마 퍼즐있다
우리가 아직 보지 못한 작품

397
00:20:03,910 --> 00:20:07,440
하지만 키 입력에 응답하는 것,
일에 나는 키보드했다​​.

398
00:20:07,440 --> 00:20:11,660
>> 그래서 아마 어떤 종류의있다
키가 동일한 경우는 말한다 블록,

399
00:20:11,660 --> 00:20:15,965
다음 Scratch--으로 뭔가를 할
아마 10 단계 이러한 방법으로 이동합니다.

400
00:20:15,965 --> 00:20:20,240
다운 키를 누르면, 10 단계 이동할
이러한 방법으로, 또는 왼쪽 키를 10 단계로 이동

401
00:20:20,240 --> 00:20:21,710
이 방법 (10)은 단계.

402
00:20:21,710 --> 00:20:23,644
나는 분명히 개구리에 고양이를 설정했습니다.

403
00:20:23,644 --> 00:20:26,060
그래서 그냥 어디있어
스크래치 호출은 우리를 그건 ... 의상으로

404
00:20:26,060 --> 00:20:28,440
그냥 개구리의 사진을 가져 왔습니다.

405
00:20:28,440 --> 00:20:29,570
>> 하지만 무슨 일이 일어나고 그 밖의 무엇?

406
00:20:29,570 --> 00:20:32,794
어떤 코드의 다른 라인,
어떤 다른 퍼즐 조각

407
00:20:32,794 --> 00:20:35,460
블레이크했던, 우리의 교육 동료,
분명히,이 프로그램에 사용할 수 있습니까?

408
00:20:35,460 --> 00:20:38,320

409
00:20:38,320 --> 00:20:42,730
어떻게 모든 것을 만들고있어 난 그러고
어떤 프로그램 구성?

410
00:20:42,730 --> 00:20:44,950
>> 모션, 그래서 sure--
확실히, 블록을 이동합니다.

411
00:20:44,950 --> 00:20:49,330
그리고 그 움직임 블록 무엇
, 대부분의 내부?

412
00:20:49,330 --> 00:20:52,850
그래, 루프의 일종, 아마
영원히 어쩌면 반복, 차단 block--

413
00:20:52,850 --> 00:20:54,070
블록까지 반복합니다.

414
00:20:54,070 --> 00:20:57,330
그리고 그 어떤 로그를 만들고있다 및
릴리 패드와 모든 다른 이동

415
00:20:57,330 --> 00:20:57,990
이리저리.

416
00:20:57,990 --> 00:21:00,270
그것은 단지 끝없이 일어나고.

417
00:21:00,270 --> 00:21:03,180
>> 이유는 자동차의 일부입니다
다른 사람보다 더 빨리 이동?

418
00:21:03,180 --> 00:21:06,607
해당 프로그램에 대해 다른 무엇입니까?

419
00:21:06,607 --> 00:21:09,690
네, 아마 그들 중 일부는 복용
번에 단계 그들 중 일부

420
00:21:09,690 --> 00:21:10,690
한 번에 적은 단계.

421
00:21:10,690 --> 00:21:14,670
그리고 시각 효과
느린 대 빠릅니다.

422
00:21:14,670 --> 00:21:16,030
>> 당신은 무슨 일이 어떻게 생각하십니까?

423
00:21:16,030 --> 00:21:19,700
내가 개구리를 가지고있는 모든 방법
거리와 강을 가로 질러

424
00:21:19,700 --> 00:21:23,560
백합 패드, 뭔가 상
주목할만한 일어났다.

425
00:21:23,560 --> 00:21:26,540
어떻게 최대한 빨리 그처럼 일어 났는가?

426
00:21:26,540 --> 00:21:27,210
이 멈췄다.

427
00:21:27,210 --> 00:21:29,680
그 개구리를 중지하고,
나는 두 번째 개구리를 얻었다.

428
00:21:29,680 --> 00:21:33,155
그래서 구조를해야합니다
거기에 사용, 어떤 기능이?

429
00:21:33,155 --> 00:21:36,020

430
00:21:36,020 --> 00:21:38,660
>> 그래, 그래서 어떤 종류의있다
너무, 거기 컨디셔닝 "만일".

431
00:21:38,660 --> 00:21:41,909
우리는이 항아리 보지 않았다해서 돌출 그리고집니다
그러나이 점에서 다른 블록을 거기에

432
00:21:41,909 --> 00:21:45,300
당신이 접촉하는 경우, 말할 수있다
화면에 다른 것,

433
00:21:45,300 --> 00:21:47,720
당신은 "다음."백합 패드를 터치하는 경우

434
00:21:47,720 --> 00:21:50,810
그리고 그 때 우리를이다
두 번째 개구리를 표시합니다.

435
00:21:50,810 --> 00:21:54,969
그래서이 게임은 확실히 경우에도
매우 심지어 첫눈에 있지만, 일자

436
00:21:54,969 --> 00:21:58,010
거기에 너무 많은 on--와 블레이크가는
2 분이 재빨리하지 않았다,

437
00:21:58,010 --> 00:22:00,390
그것은 아마 그가 몇했다
시간이 게임을 만들 수 있습니다

438
00:22:00,390 --> 00:22:03,850
그의 기억이나 동영상을 기반으로
그것의 왕년의 버전.

439
00:22:03,850 --> 00:22:07,940
그러나 이러한 작은 것들의 모든
격리에서 화면에 가고

440
00:22:07,940 --> 00:22:11,550
이러한 매우 간단합니다 아래로 비등
constructs-- 운동 또는 문

441
00:22:11,550 --> 00:22:15,519
우리가 언급 한 같은, 루프 및
조건, 그리고 그것에 대해이야.

442
00:22:15,519 --> 00:22:17,060
몇 가지 다른 애호가 기능이있다.

443
00:22:17,060 --> 00:22:19,130
그들 중 일부는 순수하다
미적 또는 음향,

444
00:22:19,130 --> 00:22:20,964
소리처럼 그냥 함께했다.

445
00:22:20,964 --> 00:22:23,380
그러나 대부분의 경우, 당신
이 언어, 스크래치에있는,

446
00:22:23,380 --> 00:22:25,350
기본의 모든
빌딩 블록 당신이

447
00:22:25,350 --> 00:22:29,280
C, 자바, 자바 스크립트에있는,
PHP, 루비, 파이썬,

448
00:22:29,280 --> 00:22:32,960
다른 언어의 수.

449
00:22:32,960 --> 00:22:36,720
스크래치에 대한 질문?

450
00:22:36,720 --> 00:22:37,220
괜찮아.

451
00:22:37,220 --> 00:22:40,303
그래서 우리는 스크래치에 깊은 다이빙하지 않습니다,
이번 주말 환영합니다 있지만,

452
00:22:40,303 --> 00:22:42,860
특히 당신은 아이가있는 경우 또는
조카 등,

453
00:22:42,860 --> 00:22:44,220
스크래치에 소개합니다.

454
00:22:44,220 --> 00:22:47,960
실제로 훌륭하게 장난이야
환경과 그 저자가 말하는 것처럼,

455
00:22:47,960 --> 00:22:49,120
매우 높은 천장.

456
00:22:49,120 --> 00:22:51,670
우리는 시작하더라도
매우 낮은 수준의 세부 정보,

457
00:22:51,670 --> 00:22:54,890
당신은 정말 꽤 작업을 수행 할 수 있습니다
그것으로, 이는 아마도

458
00:22:54,890 --> 00:22:57,360
정확히의 데모.

459
00:22:57,360 --> 00:23:02,920
>> 그러나의 지금은 좀 더로 전환하자
복잡한 문제, 만약에 당신,

460
00:23:02,920 --> 00:23:05,870
"검색"으로 알려져 있으며,
더 일반적으로 "정렬".

461
00:23:05,870 --> 00:23:09,500
우리는이 전화 번호부는 earlier-- 여기에 있었다
다만 discussion-- 또 다른 하나

462
00:23:09,500 --> 00:23:13,460
우리는 검색 할 수 있었다
보다 효율적으로하기 때문에

463
00:23:13,460 --> 00:23:15,270
중요한 가정의.

464
00:23:15,270 --> 00:23:17,655
그리고 그냥 명확하게하는 것
가정은 내가 결정했다

465
00:23:17,655 --> 00:23:19,280
이 전화 번호부를 통해 검색 할 때?

466
00:23:19,280 --> 00:23:23,342

467
00:23:23,342 --> 00:23:25,300
마이크 스미스 있다는
전화 번호부, I 불구하고

468
00:23:25,300 --> 00:23:27,410
처리 할 수​​있을 것입니다
그없이 시나리오

469
00:23:27,410 --> 00:23:30,720
난 그냥 조기가 정지합니다.

470
00:23:30,720 --> 00:23:31,806
이 책은 알파벳입니다.

471
00:23:31,806 --> 00:23:33,930
그리고 그것은 매우 관대이야
가정, 그 때문에

472
00:23:33,930 --> 00:23:36,580
나는 친절 해요 누굴 의미
코너 절단,

473
00:23:36,580 --> 00:23:40,580
같은 나는 누군가 때문에 빠른 오전
다른 나를 위해 많은 노력을했다.

474
00:23:40,580 --> 00:23:43,120
>> 그러나 만약 전화
이 책은 정렬되지 않은가요?

475
00:23:43,120 --> 00:23:47,050
아마 버라이존이 게으른있어, 그냥 던져
모든 사람의 이름과 번호가에

476
00:23:47,050 --> 00:23:50,120
아마 순서대로하는 그들
전화 서비스에 가입.

477
00:23:50,120 --> 00:23:54,570
그리고 얼마나 많은 시간을하면 나를 걸립니까
마이크 스미스 같은 사람을 찾는 방법은?

478
00:23:54,570 --> 00:23:58,160
1000 페이지의 전화가 얼마나 많은 book--
페이지는 내가 통해보고해야합니까?

479
00:23:58,160 --> 00:23:58,905
>> 그들 모두.

480
00:23:58,905 --> 00:24:00,030
당신은 운이 일종의입니다.

481
00:24:00,030 --> 00:24:03,420
당신은 말 그대로에서 모든보고있다
페이지 전화 번호부 그냥 경우

482
00:24:03,420 --> 00:24:04,450
무작위로 분류.

483
00:24:04,450 --> 00:24:06,910
당신은 운이 마이크를 찾을 수 있습니다
맨 처음 페이지에, 그 때문에

484
00:24:06,910 --> 00:24:08,826
첫 번째 고객이었다
전화 서비스를 주문합니다.

485
00:24:08,826 --> 00:24:10,760
그러나 그는 역시 마지막되었을 수 있습니다.

486
00:24:10,760 --> 00:24:12,500
>> 따라서 임의의 순서는 좋지 않다.

487
00:24:12,500 --> 00:24:16,750
그래서 우리는 정렬이 있다고 가정
전화 번호부 또는 일반 정렬 데이터

488
00:24:16,750 --> 00:24:18,520
것을 우리는 주어진했습니다.

489
00:24:18,520 --> 00:24:19,440
우리는 어떻게 할 수 있습니까?

490
00:24:19,440 --> 00:24:21,360
>> 음, 나 그냥 해보자
여기에 간단한 예.

491
00:24:21,360 --> 00:24:24,290
내가 앞으로 가서 던져 보자
칠판에 몇 번호.

492
00:24:24,290 --> 00:24:35,480
이다 우리가 숫자를 가정
이제, 네, 둘, 하나, 3을 가정 해 봅시다.

493
00:24:35,480 --> 00:24:38,390
그리고, 벤, 우리를 위해이 숫자를 정렬합니다.

494
00:24:38,390 --> 00:24:39,017
>> 그래 좋아.

495
00:24:39,017 --> 00:24:39,850
당신은 그렇게 않았다 방법?

496
00:24:39,850 --> 00:24:42,731

497
00:24:42,731 --> 00:24:43,230
괜찮아.

498
00:24:43,230 --> 00:24:44,710
그래서 작은 시작
값이 가장 높은,

499
00:24:44,710 --> 00:24:46,084
그것은 정말 좋은 직관이다.

500
00:24:46,084 --> 00:24:48,080
그리고 우리를 실현
인간은 실제로 꽤 있습니다

501
00:24:48,080 --> 00:24:49,913
문제 해결에 좋은
이런 식으로, 적어도

502
00:24:49,913 --> 00:24:51,810
데이터가 상대적으로 작은 경우.

503
00:24:51,810 --> 00:24:54,860
즉시 수백을 시작으로
숫자, 숫자의 수천,

504
00:24:54,860 --> 00:24:58,440
숫자의 수백만, 벤 아마
아주 그렇게 빨리 그것을 할 수 없었다,

505
00:24:58,440 --> 00:25:00,620
가 있다고 가정
숫자의 간격.

506
00:25:00,620 --> 00:25:03,450
만에 카운트 아주 쉽게
그렇지 않으면, 단지 시간이 많이 소요.

507
00:25:03,450 --> 00:25:07,150
>> 따라서 알고리즘이 들린다
벤 지금 바로 사용 등

508
00:25:07,150 --> 00:25:08,930
가장 작은 번호를 검색했다.

509
00:25:08,930 --> 00:25:12,900
그래서 우리 인간은 걸릴 수 있지만
시각적으로 많은 정보에,

510
00:25:12,900 --> 00:25:14,830
컴퓨터는 실제로
좀 더 제한.

511
00:25:14,830 --> 00:25:17,560
컴퓨터 수 있습니다 만
한 번에 한 바이트 보면

512
00:25:17,560 --> 00:25:20,770
으로 ..에서 아니면 4 바이트
으로 ..에서 요즘은 아마 8 바이트

513
00:25:20,770 --> 00:25:24,450
그러나 극소수
주어진 시간에 바이트.

514
00:25:24,450 --> 00:25:28,480
>> 그래서 우리가 정말이 주어진
네 개의 개별 값 here--

515
00:25:28,480 --> 00:25:32,440
당신은 것으로 벤 생각할 수
그는 컴퓨터 등을 인 경우에 곁​​눈 가리개

516
00:25:32,440 --> 00:25:36,450
그는 다른 것을 볼 수 없습니다
으로 .. 하나의 수보다

517
00:25:36,450 --> 00:25:39,720
그래서 우리는 일반적으로처럼, 가정합니다
영어, 우리는 오른쪽에서 왼쪽으로 읽을 수 있습니다.

518
00:25:39,720 --> 00:25:42,870
그래서 첫 번째 숫자 벤은 아마 보았다
에서 매우 빠르게 다음 네이었고,

519
00:25:42,870 --> 00:25:44,770
그것은 꽤 큰의 실현
number-- 나를 계속 찾아 보자.

520
00:25:44,770 --> 00:25:45,357
>> 두 가지가있다.

521
00:25:45,357 --> 00:25:45,940
분을 기다립니다.

522
00:25:45,940 --> 00:25:47,070
두 네보다 작다.

523
00:25:47,070 --> 00:25:47,986
내가 기억하는거야.

524
00:25:47,986 --> 00:25:49,070
두 이제 작다.

525
00:25:49,070 --> 00:25:50,417
지금 one--이 더 나은입니다.

526
00:25:50,417 --> 00:25:51,250
즉, 더 작은입니다.

527
00:25:51,250 --> 00:25:54,000
나는 약 2를 잊어 버린거야
그리고 지금 일을 기억한다.

528
00:25:54,000 --> 00:25:56,550
>> 그리고 그는 찾고 막을 수?

529
00:25:56,550 --> 00:25:58,360
글쎄, 그는 기초 수
이 정보에,

530
00:25:58,360 --> 00:26:00,477
그러나 그는 더 나은 검색을 거라고
목록의 나머지.

531
00:26:00,477 --> 00:26:02,060
목록에 무엇 제로 경우했기 때문에?

532
00:26:02,060 --> 00:26:03,643
어떤 하나의 제외가 목록에 있다면?

533
00:26:03,643 --> 00:26:07,720
그는 단지 그의 대답 것을 알고있다
그는 철저하게인지 정확

534
00:26:07,720 --> 00:26:08,729
전체 목록을 확인.

535
00:26:08,729 --> 00:26:10,020
그래서 우리는 나머지 봐.

536
00:26:10,020 --> 00:26:11,394
그 셋 ... 시간 낭비였다.

537
00:26:11,394 --> 00:26:13,540
불운있어,하지만 난이었다
그렇게 할 올바른 여전히.

538
00:26:13,540 --> 00:26:17,857
그리고 지금 그는 아마도
작은 수를 선택

539
00:26:17,857 --> 00:26:20,440
그냥 처음에 넣어
목록, 나는 여기 다하겠습니다있다.

540
00:26:20,440 --> 00:26:23,480
지금은 비록, 다음에 무엇을 했는가
당신은 거의 그것에 대해 생각하지 않았다

541
00:26:23,480 --> 00:26:25,962
이 정도?

542
00:26:25,962 --> 00:26:27,670
이 과정을 반복,
루프 그래서 어떤 종류.

543
00:26:27,670 --> 00:26:28,920
친숙한 아이디어가있다.

544
00:26:28,920 --> 00:26:30,860
그래서 여기에 네 가지입니다.

545
00:26:30,860 --> 00:26:32,110
즉, 현재 가장 작은입니다.

546
00:26:32,110 --> 00:26:33,220
즉, 후보입니다.

547
00:26:33,220 --> 00:26:33,900
아니 더 이상.

548
00:26:33,900 --> 00:26:34,770
지금은 두 가지를 보았다.

549
00:26:34,770 --> 00:26:36,630
그 다음 가장 작은 요소입니다.

550
00:26:36,630 --> 00:26:40,800
그 때문에, 작지의 셋 ...
지금 벤은 두 가지를 뽑아 수 있습니다.

551
00:26:40,800 --> 00:26:44,510
>> 그리고 지금 우리는이 과정을 반복하고,
물론 세 다음에 꺼내됩니다.

552
00:26:44,510 --> 00:26:45,420
이 과정을 반복합니다.

553
00:26:45,420 --> 00:26:46,990
네 꺼내됩니다.

554
00:26:46,990 --> 00:26:50,140
그리고 지금 우리가 숫자에서있어,
그래서 목록 정렬해야합니다.

555
00:26:50,140 --> 00:26:51,960
>> 실제로,이 공식 알고리즘이다.

556
00:26:51,960 --> 00:26:56,610
컴퓨터 과학자 것
"선택 정렬"이 전화

557
00:26:56,610 --> 00:27:00,880
아이디어는 일종의있는 Being
다시 iteratively-- 목록

558
00:27:00,880 --> 00:27:03,807
다시 다시 선택
가장 작은 수입니다.

559
00:27:03,807 --> 00:27:06,140
그것이 대해 좋은거야
그것은 너무 터무니없는 직관적입니다.

560
00:27:06,140 --> 00:27:07,470
너무 간단합니다.

561
00:27:07,470 --> 00:27:11,100
그리고 당신은 동일한 작업을 반복 할 수 있습니다
작업을 다시하고 다시.

562
00:27:11,100 --> 00:27:12,150
그것은 간단합니다.

563
00:27:12,150 --> 00:27:17,170
>> 이 경우 빠른했지만
실제로 얼마나 걸립니까?

564
00:27:17,170 --> 00:27:19,880
의 그것을 보이게하자
좀 더 지루한 느낌.

565
00:27:19,880 --> 00:27:24,150
따라서 하나, 둘, 셋, 넷, 다섯 여섯
7, 8, 9, 10, 11, 12, 13, 14,

566
00:27:24,150 --> 00:27:26,160
15, 16-- 임의의 숫자.

567
00:27:26,160 --> 00:27:28,780
난 그냥보기를 원했다
바로 사보다 시간입니다.

568
00:27:28,780 --> 00:27:30,780
그래서 전체를 가지고있는 경우
숫자의 무리를 now--

569
00:27:30,780 --> 00:27:32,420
심지어는 중요하지 않습니다
그들은하자의를으로 죠 무엇

570
00:27:32,420 --> 00:27:34,380
어떤이 생각
알고리즘은 정말 좋아합니다.

571
00:27:34,380 --> 00:27:35,857
>> 이 숫자가 가정하자.

572
00:27:35,857 --> 00:27:38,190
또, 중요하지 않습니다 무슨
그들은,하지만 그들은 무작위입니다.

573
00:27:38,190 --> 00:27:39,679
나는 벤의 알고리즘을 적용하고있다.

574
00:27:39,679 --> 00:27:41,220
나는 가장 작은 수를 선택해야합니다.

575
00:27:41,220 --> 00:27:41,761
어떻게해야합니까?

576
00:27:41,761 --> 00:27:44,240
그리고 육체적에 갈거야
그것은 그것을 행동이 시간을한다.

577
00:27:44,240 --> 00:27:46,099
찾고 찾고,
찾고 찾고 찾고.

578
00:27:46,099 --> 00:27:48,140
단지 내가 도착 시간에 의해
리스트의 종료 할

579
00:27:48,140 --> 00:27:51,230
나는 작은 실현
수는 2이 시간이었다.

580
00:27:51,230 --> 00:27:52,720
하나는 목록에 없습니다.

581
00:27:52,720 --> 00:27:54,400
그래서 두 사람은 내려 놔.

582
00:27:54,400 --> 00:27:55,590
>> 나는 다음에 무엇을해야합니까?

583
00:27:55,590 --> 00:27:58,600
찾고 찾고 찾고 찾고.

584
00:27:58,600 --> 00:28:02,250
지금 나는 때문에, 숫자 일곱 발견
이 numbers--에 간격이있어

585
00:28:02,250 --> 00:28:03,300
그러나 다만 임의.

586
00:28:03,300 --> 00:28:03,800
괜찮아.

587
00:28:03,800 --> 00:28:06,030
그래서 지금은 일곱을 넣을 수 있습니다.

588
00:28:06,030 --> 00:28:08,860
찾고 찾고 찾고입니다.

589
00:28:08,860 --> 00:28:11,030
>> 지금은,의 있으리라 믿고있어
물론, 벤이하는 것을하지

590
00:28:11,030 --> 00:28:14,780
여분의 RAM을 가지고 추가
메모리 때문에 물론

591
00:28:14,780 --> 00:28:16,080
저도 같은 번호로 찾고 있어요.

592
00:28:16,080 --> 00:28:18,246
확실히 나는 기억하고 있었다
그 숫자의 모든

593
00:28:18,246 --> 00:28:19,930
그것은 절대적으로 사실입니다.

594
00:28:19,930 --> 00:28:22,610
그러나 벤 모든 기억 경우
숫자의 그가 본 것,

595
00:28:22,610 --> 00:28:24,430
그는 정말 만든되지 않았습니다
기본적인 진행

596
00:28:24,430 --> 00:28:26,170
그는 이미 가지고 있기 때문에
검색 기능

597
00:28:26,170 --> 00:28:27,540
보드의 숫자를 통해.

598
00:28:27,540 --> 00:28:29,373
의 모든 기억
숫자는 도움이되지 않습니다

599
00:28:29,373 --> 00:28:32,490
그는 컴퓨터와 정지 할 수 있기 때문에
단지, 우리가 말한, 하나의 숫자를 보면

600
00:28:32,490 --> 00:28:33,080
한번에.

601
00:28:33,080 --> 00:28:35,760
그래서 속임수의 어떤 종류가 없습니다
당신은 거기 활용할 수있다.

602
00:28:35,760 --> 00:28:39,170
>> 현실에서, 같은 그래서
목록을 검색 유지,

603
00:28:39,170 --> 00:28:44,200
말 그대로 그냥 계속해야
앞뒤로 그것을 통해 밖으로 따 버릴

604
00:28:44,200 --> 00:28:45,710
다음 작은 수입니다.

605
00:28:45,710 --> 00:28:48,810
그리고 같은 당신이 가지 추론 할 수있다
내 어리석은 움직임에서,

606
00:28:48,810 --> 00:28:50,860
이 단지 매우 도착
매우 빠르게 지루한,

607
00:28:50,860 --> 00:28:54,850
내가 다시 갈 것와
앞으로, 뒤로 꽤.

608
00:28:54,850 --> 00:29:03,220
지금 공정하게, 내가 갈 필요가 없습니다
확실히, 음, 공정하게 see--하자,

609
00:29:03,220 --> 00:29:06,310
꽤 걸을 필요가 없습니다
많은 단계마다.

610
00:29:06,310 --> 00:29:09,200
왜냐하면 물론, I 등
목록에서 번호를 선택,

611
00:29:09,200 --> 00:29:11,860
나머지 목록은 짧아지고 있습니다.

612
00:29:11,860 --> 00:29:14,240
>> 그리고의에 대해 생각해 봅시다
얼마나 많은 단계를 사실이야

613
00:29:14,240 --> 00:29:16,010
각각의 시간을 통해 와가.

614
00:29:16,010 --> 00:29:18,950
최초 상황에서
우리는 16 숫자를했다

615
00:29:18,950 --> 00:29:22,210
등의 그냥하자 maximally--
discussion--에 대해이 작업을 수행

616
00:29:22,210 --> 00:29:25,640
나는 (16)를 통해 볼 수밖에 없었습니다
숫자는 작은을 찾을 수 있습니다.

617
00:29:25,640 --> 00:29:28,420
하지만 일단 내가 밖으로 뽑아
적은 수의 방법

618
00:29:28,420 --> 00:29:30,590
긴 물론 나머지 목록을했다?

619
00:29:30,590 --> 00:29:31,420
15.

620
00:29:31,420 --> 00:29:34,670
그래서 얼마나 많은 숫자는 벤 또는 내가 가지고 있었다
주위에 두 번째 시간을 통해 찾으려면?

621
00:29:34,670 --> 00:29:36,832
15, 그냥 가서 작은을 찾을 수 있습니다.

622
00:29:36,832 --> 00:29:39,540
하지만 지금은, 물론, 목록이며,
또한, 그것은 이전보다 작다.

623
00:29:39,540 --> 00:29:42,540
그래서 얼마나 많은 단계를 내가했다
다음에 시간이 걸릴해야?

624
00:29:42,540 --> 00:29:49,970
14 다음 13 다음 12 플러스 점,
난 그냥 하나 남아있어까지 점, 점.

625
00:29:49,970 --> 00:29:53,146
그래서 지금 컴퓨터 과학자는 것
모두 동일한 것이 무엇을 잘 물어?

626
00:29:53,146 --> 00:29:55,770
실제로 일부 콘크리트와 동일
숫자는 우리는 확실히 할 수

627
00:29:55,770 --> 00:30:00,490
산술적으로, 그러나 우리는 얘기하고 싶지
알고리즘의 효율성에 대한

628
00:30:00,490 --> 00:30:04,940
더 많은 공식을 통해 (formulaically) 조금,
리스트가 얼마나 독립적.

629
00:30:04,940 --> 00:30:06,240
>> 그리고 그거 알아?

630
00:30:06,240 --> 00:30:09,860
이 16이지만, 같은 내가 전에 말했듯이,
그냥 문제의 크기를 호출하도록

631
00:30:09,860 --> 00:30:10,970
n은 어떤 숫자 n을.

632
00:30:10,970 --> 00:30:13,220
아마 어쩌면 그것의 16의
세, 어쩌면 백만입니다.

633
00:30:13,220 --> 00:30:13,761
모르겠어요.

634
00:30:13,761 --> 00:30:14,390
난 상관 없어.

635
00:30:14,390 --> 00:30:16,520
내가 진정으로 원하는 것은
수식 내가 할 수있는

636
00:30:16,520 --> 00:30:19,420
이 알고리즘을 비교하는 데 사용
다른 알고리즘에 대하여

637
00:30:19,420 --> 00:30:22,350
누군가가 주장 수도
좋든 나쁘 있습니다.

638
00:30:22,350 --> 00:30:25,430
>> 그래서 그것은 밝혀, 단지 I
초등학교에서이 알고,

639
00:30:25,430 --> 00:30:34,790
이 사실은 같은 밖으로 작동
N을 통해 n은 일 더하기 이상 2 일.

640
00:30:34,790 --> 00:30:40,020
그리고 이것은,의 동일하게 발생
과정은 플러스 N 이상 2 제곱 N.

641
00:30:40,020 --> 00:30:43,250
그래서 만약 내가 수식을 원했다
얼마나 많은 단계

642
00:30:43,250 --> 00:30:46,330
모든보고에 참여했다
또 다시 그 숫자의

643
00:30:46,330 --> 00:30:52,681
다시 다시, 나는 말할 것
그것은 N 플러스 N 이상 2 제곱입니다.

644
00:30:52,681 --> 00:30:53,430
하지만 당신은 알아?

645
00:30:53,430 --> 00:30:54,500
이것은 단지 지저분 해 보인다.

646
00:30:54,500 --> 00:30:56,470
난 그냥 정말 원하는
사물의 일반적인 의미.

647
00:30:56,470 --> 00:30:58,810
그리고 당신은 기억 할 수
고등학교가있다

648
00:30:58,810 --> 00:31:00,660
최상위 용어의 개념입니다.

649
00:31:00,660 --> 00:31:05,300
이 기간 중, n 개의
상기 N, 또는 절반 제곱

650
00:31:05,300 --> 00:31:07,550
시간이 지남에 가장 영향을?

651
00:31:07,550 --> 00:31:11,920
더 큰 n은 얻을 수있는
대부분의 이러한 문제의?

652
00:31:11,920 --> 00:31:15,560
>> 즉, I는 연결하면
만에, N 제곱

653
00:31:15,560 --> 00:31:17,900
가장 가능성이 될 것입니다
지배 인자,

654
00:31:17,900 --> 00:31:21,670
때문에 만 번
자체가 많이 크다

655
00:31:21,670 --> 00:31:23,682
보다 더한 백만 추가.

656
00:31:23,682 --> 00:31:24,390
그래서 당신은 무엇인지?

657
00:31:24,390 --> 00:31:27,305
이 같은 이놈이 큰
숫자는 숫자를 제곱합니다.

658
00:31:27,305 --> 00:31:28,430
이건 정말 문제가되지 않습니다.

659
00:31:28,430 --> 00:31:30,596
우리는 십자가를 겁니다 그
아웃 그것에 대해 잊어 버려요.

660
00:31:30,596 --> 00:31:34,250
그래서 컴퓨터 과학자는 말할 것
그 알고리즘의 효율성

661
00:31:34,250 --> 00:31:37,850
N 정도이다 squared--
나는 진정으로 근사치를 의미한다.

662
00:31:37,850 --> 00:31:40,810
그것은 종류의 약 N 제곱된다.

663
00:31:40,810 --> 00:31:44,130
시간이 지남에, 더 큰
더 큰 N이 가져옵니다

664
00:31:44,130 --> 00:31:47,610
무엇에 대한 좋은 평가입니다
효율성이나 효율성의 부족

665
00:31:47,610 --> 00:31:49,400
이 알고리즘의 사실이다.

666
00:31:49,400 --> 00:31:52,040
내가 유도하는, 물론,
실제로 수학을하고부터.

667
00:31:52,040 --> 00:31:54,040
하지만 지금은 물결 치는거야
내 손에, I 때문에 단지

668
00:31:54,040 --> 00:31:55,790
이 알고리즘의 일반적인 의미 할 수 있습니다.

669
00:31:55,790 --> 00:31:58,850
>> 그래서 동일한 로직을 사용하는 한편,
의 다른 알고리즘을 생각해 보자

670
00:31:58,850 --> 00:32:01,162
우리는 이미 at-- 선형 검색을 보였다.

671
00:32:01,162 --> 00:32:02,870
언제이 검색되었습니다
전화 book--에 대한

672
00:32:02,870 --> 00:32:05,980
찾고이를 정렬되지
전화 book--을 통해

673
00:32:05,980 --> 00:32:09,197
우리는 것을 말하고 있었다
1000 단계 또는 500 단계.

674
00:32:09,197 --> 00:32:10,280
그러나 이제 그 일반화 할 수 있습니다.

675
00:32:10,280 --> 00:32:12,860
n 개의 페이지가 있다면
전화 번호부, 무슨 일이야

676
00:32:12,860 --> 00:32:17,250
실행 시간 또는
선형 검색의 효율성?

677
00:32:17,250 --> 00:32:19,750
이 순서에의
얼마나 많은 단계하면 찾을 수 있습니다

678
00:32:19,750 --> 00:32:24,210
마이크 스미스 선형 검색을 사용하여
첫째 알고리즘 또는 제?

679
00:32:24,210 --> 00:32:27,240

680
00:32:27,240 --> 00:32:31,710
>> 최악의 경우, 마이크에서
책의 끝 부분이다.

681
00:32:31,710 --> 00:32:35,590
전화 번호부는 1,000 페이지가 있다면,
우리는, 최악의 경우에는, 상기 전회

682
00:32:35,590 --> 00:32:38,380
그것은 대략 얼마나 걸릴 수 있습니다
많은 페이지는 마이크를 찾는 방법은?

683
00:32:38,380 --> 00:32:38,990
1000 등을들 수있다.

684
00:32:38,990 --> 00:32:39,830
그것은 상한입니다.

685
00:32:39,830 --> 00:32:41,790
그것은 최악의 상황이다.

686
00:32:41,790 --> 00:32:44,410
그러나 다시, 우리는 멀리 이동하고
지금 1000과 같은 숫자에서.

687
00:32:44,410 --> 00:32:45,730
그것은 단지 N입니다.

688
00:32:45,730 --> 00:32:47,470
>> 그래서 논리적 인 결론은 무엇인가?

689
00:32:47,470 --> 00:32:50,210
전화에서 마이크 찾기
n 개의 페이지가 책

690
00:32:50,210 --> 00:32:55,280
아주 최악의 경우에, 걸릴 수 있습니다,
얼마나 많은 N 정도의 단계?

691
00:32:55,280 --> 00:32:58,110
그리고 실제로 컴퓨터
과학자는 말할 것

692
00:32:58,110 --> 00:33:02,340
실행 시간, 또는 그
성능이나 효율

693
00:33:02,340 --> 00:33:07,470
알고리즘 등의 또는 비 효율성,
선형 검색 (n)의 순서입니다.

694
00:33:07,470 --> 00:33:10,010
그리고 우리는 동일하게 적용 할 수 있습니다
무언가를 건너의 논리

695
00:33:10,010 --> 00:33:13,170
난 그냥 초에했던 것처럼
알고리즘 우리는 전화 번호부로했다

696
00:33:13,170 --> 00:33:16,040
여기서 우리는 한 번에 두 페이지를 갔다.

697
00:33:16,040 --> 00:33:20,120
>> 그래서 1000 페이지 전화 번호부 수도
500 페이지 교대로 우리를 데려, 더하기 하나

698
00:33:20,120 --> 00:33:21,910
우리는 조금 뒤로 두 번합니다.

699
00:33:21,910 --> 00:33:26,590
그래서 전화 번호부 N 개의 페이지를 포함하지만
우리는 한 번에 두 페이지를하고있는

700
00:33:26,590 --> 00:33:28,900
그 대략 무엇입니까?

701
00:33:28,900 --> 00:33:33,190
이상 2 N, 그래서 두 가지 이상의 N 같아요.

702
00:33:33,190 --> 00:33:38,490
그러나 나는 주장 a를 만든
2가 있으며 넘는 순간 전 그 N

703
00:33:38,490 --> 00:33:41,060
그것은 단지 n은 같은 종류입니다.

704
00:33:41,060 --> 00:33:44,050
그것은 단지 일정한 요인이다
컴퓨터 과학자들은 말할 것이다.

705
00:33:44,050 --> 00:33:45,970
의 만 집중하자
변수, 정말 ..

706
00:33:45,970 --> 00:33:47,780
식에서의 큰 변수.

707
00:33:47,780 --> 00:33:52,530
>> 하나를 수행할지 여부 그래서 선형 검색,
한번에 페이지 또는 한 번에 두 개의 페이지,

708
00:33:52,530 --> 00:33:54,810
일종의 근본적으로 동일하다.

709
00:33:54,810 --> 00:33:56,880
그것은 N의 순서에 아직.

710
00:33:56,880 --> 00:34:01,930
그러나 나는 이전에 내 사진과 함께 주장
세 번째 알고리즘은 아니었다

711
00:34:01,930 --> 00:34:02,480
선의.

712
00:34:02,480 --> 00:34:03,605
그것은 직선이 아니었다.

713
00:34:03,605 --> 00:34:08,659
그것은 그 곡선이고,
대수 공식이 무엇입니까?

714
00:34:08,659 --> 00:34:11,812
N--의 로그인 그래서 N의 기본이를 기록합니다.

715
00:34:11,812 --> 00:34:14,520
그리고 우리는 너무로 갈 필요가 없습니다
대수에 자세히 오늘,

716
00:34:14,520 --> 00:34:17,394
하지만 대부분의 컴퓨터 과학자는 않을 것
심지어 기본이 무엇을 알려줍니다.

717
00:34:17,394 --> 00:34:20,639
이 때문에 모든 단지
상수 요인 때문에, 말하자면

718
00:34:20,639 --> 00:34:22,659
단지 약간의 수치 차이.

719
00:34:22,659 --> 00:34:31,179
그리고 이것은 매우 일반적인 일 것
특히 형식적인 컴퓨터 방법

720
00:34:31,179 --> 00:34:33,949
보드 과학자 또는
화이트 보드에 프로그래머

721
00:34:33,949 --> 00:34:36,889
실제로 주장하는
그들이 사용하는 것이 알고리즘

722
00:34:36,889 --> 00:34:39,500
또는 무엇 효율성
그들의 알고리즘이다.

723
00:34:39,500 --> 00:34:42,960
>> 그리고 이것은 반드시 무언가가 아니다
당신은 어떤 훌륭한 세부 사항 논의

724
00:34:42,960 --> 00:34:47,889
하지만 좋은 프로그래머는 사람이다
누가 고체, 형식적인 배경을 가지고있다.

725
00:34:47,889 --> 00:34:50,120
그는 이야기 할 수 있어요
방법의이 종류에서 당신

726
00:34:50,120 --> 00:34:53,350
실제로 확인
같은 질적 인수

727
00:34:53,350 --> 00:34:56,870
에 이유 한 알고리즘 또는
소프트웨어의 한 조각

728
00:34:56,870 --> 00:35:00,165
다른 어떤 방법으로 우수하다.

729
00:35:00,165 --> 00:35:02,540
당신이 확실히 할 수 있기 때문에
한 사람의 프로그램을 실행

730
00:35:02,540 --> 00:35:04,980
및 초 카운트
그것은 몇 가지 숫자를 정렬하는 데 걸리는,

731
00:35:04,980 --> 00:35:06,710
당신은 몇 가지를 실행할 수 있습니다
다른 사람의 프로그램

732
00:35:06,710 --> 00:35:08,418
및 수를 카운트
초의이 걸립니다.

733
00:35:08,418 --> 00:35:12,840
그러나, 이는보다 일반적인 방법은 그
는 알고리즘을 분석하는 데 사용할 수있는,

734
00:35:12,840 --> 00:35:15,520
단지에, 만약에 당신
종이하거나 구두로.

735
00:35:15,520 --> 00:35:18,430
없이도없이 그것을 실행
짝수 샘플 입력하려고

736
00:35:18,430 --> 00:35:20,180
당신은 그것을 통해 추론 할 수 있습니다.

737
00:35:20,180 --> 00:35:24,670
그래서 개발자 나 경우 고용과
그를 갖는 또는 그녀는 일종의 당신에게 주장

738
00:35:24,670 --> 00:35:28,460
왜 자신의 알고리즘, 자신의 비밀
수십억을 검색하기위한 소스

739
00:35:28,460 --> 00:35:30,580
에 대한 웹 페이지의 사용자
회사는이 더 나은입니다

740
00:35:30,580 --> 00:35:33,302
인수의 종류는 그들이
이상적으로 만들 수 있어야합니다.

741
00:35:33,302 --> 00:35:35,010
아니면 적어도이 있습니다
물건의 종류

742
00:35:35,010 --> 00:35:40,211
그에서, 토론에 올 것
매우 형식적인 토론에서 적어도.

743
00:35:40,211 --> 00:35:40,710
괜찮아.

744
00:35:40,710 --> 00:35:44,400
그래서 벤 뭔가를 제안
선택 정렬했다.

745
00:35:44,400 --> 00:35:48,200
하지만이 있다고 제안거야
또한,이 일을 다른 방법.

746
00:35:48,200 --> 00:35:50,400
난 정말 좋아하지 않았다 무엇
벤의 알고리즘에 대한

747
00:35:50,400 --> 00:35:54,400
그가 걷고 있었다, 또는이다
나 앞뒤로 걷고, 한

748
00:35:54,400 --> 00:35:56,930
앞뒤로 앞뒤로.

749
00:35:56,930 --> 00:36:04,130
대신 경우 어떻게 할 것 인 무엇
여기에이 숫자 같은 것을

750
00:36:04,130 --> 00:36:08,200
난 그냥 각각 처리했다
수 차례에 나는 그것을 제공하고 있습니다로?

751
00:36:08,200 --> 00:36:10,780
>> 즉, 여기에
숫자의 내 목록입니다.

752
00:36:10,780 --> 00:36:12,944
네 번, 세 개의.

753
00:36:12,944 --> 00:36:14,360
그리고 난 다음을 수행하겠습니다.

754
00:36:14,360 --> 00:36:17,230
나는 숫자를 삽입하는거야
그들은 오히려 속하는 경우

755
00:36:17,230 --> 00:36:18,980
한 번에 하나씩 선택보다.

756
00:36:18,980 --> 00:36:20,820
즉, 여기에서 네 번째이다.

757
00:36:20,820 --> 00:36:22,430
>> 여기에 내 원래의 목록입니다.

758
00:36:22,430 --> 00:36:25,290
그리고 유지하려고 해요
여기에 기본적으로 새로운 목록입니다.

759
00:36:25,290 --> 00:36:26,710
그래서이 이전 목록입니다.

760
00:36:26,710 --> 00:36:28,560
이 새로운 목록입니다.

761
00:36:28,560 --> 00:36:30,220
나는 네 번째는 첫 번째 참조하십시오.

762
00:36:30,220 --> 00:36:34,500
나의 새로운 목록은 처음에 비어
그래서 하찮게의 경우

763
00:36:34,500 --> 00:36:36,410
그 네 이제 목록을 모듬된다.

764
00:36:36,410 --> 00:36:39,560
난 그냥, 내가 주어진거야 수를 데려 갈거야
그리고 나는 나의 새 목록에 넣어 해요.

765
00:36:39,560 --> 00:36:41,460
>> 이 새로운 목록 정렬되어 있습니까?

766
00:36:41,460 --> 00:36:41,990
네.

767
00:36:41,990 --> 00:36:45,090
한 거기 때문에 바보
소자 있지만 반드시 정렬있다.

768
00:36:45,090 --> 00:36:46,390
장소 중 아무것도 없습니다.

769
00:36:46,390 --> 00:36:49,290
그것은 더 흥미로운,이 알고리즘,
I는 다음 단계로 이동합니다.

770
00:36:49,290 --> 00:36:50,550
>> 지금은 일이있다.

771
00:36:50,550 --> 00:36:55,430
그래서 하나 물론에 속하는
시작하거나 새 목록의 끝?

772
00:36:55,430 --> 00:36:56,360
시작입니다.

773
00:36:56,360 --> 00:36:58,530
그래서 나는 지금 어떤 일을해야합니다.

774
00:36:58,530 --> 00:37:01,410
나는 몇 가지를 복용 한
내 마커의 자유

775
00:37:01,410 --> 00:37:03,120
그냥 일을 그려서
나는 그들을 원하는 곳,

776
00:37:03,120 --> 00:37:05,320
하지만 그건 정말 아니다
컴퓨터에서 정확한.

777
00:37:05,320 --> 00:37:08,530
우리가 아는 한 컴퓨터는있다
RAM, 또는 랜덤 액세스 메모리,

778
00:37:08,530 --> 00:37:12,411
그 하나의 바이트이고
다른 바이트 다른 바이트.

779
00:37:12,411 --> 00:37:14,910
그리고 당신의 기가 바이트가있는 경우
RAM, 당신은 억 바이트를,

780
00:37:14,910 --> 00:37:16,680
그러나 그들은 한 위치에 물리적으로입니다.

781
00:37:16,680 --> 00:37:19,540
당신은 주위에 물건을 이동할 수 없습니다
칠판에 그려서

782
00:37:19,540 --> 00:37:20,750
네가 원하는 어디든지.

783
00:37:20,750 --> 00:37:24,090
나의 새로운 목록이 있다면
메모리에 4 곳,

784
00:37:24,090 --> 00:37:27,480
불행하게도 네입니다
이미 잘못된 장소입니다.

785
00:37:27,480 --> 00:37:30,410
>> 그래서 수를 삽입 한
난 그냥 여기 그릴 수 없습니다.

786
00:37:30,410 --> 00:37:31,901
이 메모리 위치가 존재하지 않습니다.

787
00:37:31,901 --> 00:37:35,150
즉 부정 될 것이다, 내가왔다
몇 분 동안 그림으로 부정 행위

788
00:37:35,150 --> 00:37:35,800
이리.

789
00:37:35,800 --> 00:37:40,950
그래서 정말, 내가 여기에 하나를 넣어하려는 경우,
나는 일시적으로 사를 복사해야

790
00:37:40,950 --> 00:37:43,030
다음 거기에 1 점을 추가하는 듯.

791
00:37:43,030 --> 00:37:45,500
>> 즉, 그것은 맞습니다, 괜찮아요
즉, 기술적으로 가능

792
00:37:45,500 --> 00:37:48,410
하지만 추가 작업의 실현.

793
00:37:48,410 --> 00:37:50,460
난 그냥 자리에 수를 두지 않았다.

794
00:37:50,460 --> 00:37:53,026
내가 먼저 이동했다
숫자이어서, 장소에 보관

795
00:37:53,026 --> 00:37:54,650
그래서 나는 종류의 작업 내 양을 두 배로.

796
00:37:54,650 --> 00:37:55,660
그래서 마음에 보관하십시오.

797
00:37:55,660 --> 00:37:57,120
>> 그러나 지금은이 요소에 끝났어요.

798
00:37:57,120 --> 00:37:59,056
지금은 세 번째를 잡아 싶어요.

799
00:37:59,056 --> 00:38:00,430
어디 물론, 그것은 속해 있습니까?

800
00:38:00,430 --> 00:38:01,480
사이.

801
00:38:01,480 --> 00:38:03,650
더 이상 속일 수 없다
단지, 거기에 넣어

802
00:38:03,650 --> 00:38:06,770
또,이 때문에 메모리
물리적 위치에 있습니다.

803
00:38:06,770 --> 00:38:10,900
그래서 사를 복사해야
그리고 여기에 세 가지를 넣어.

804
00:38:10,900 --> 00:38:11,550
아니 큰 문제.

805
00:38:11,550 --> 00:38:14,610
그것은 단지 하나 추가 단계입니다
again-- 매우 저렴 느낀다.

806
00:38:14,610 --> 00:38:16,445
>> 하지만 지금은 두 가지로 이동합니다.

807
00:38:16,445 --> 00:38:17,820
둘은 물론, 여기에 속한다.

808
00:38:17,820 --> 00:38:20,990
지금 당신은 어떻게보고 시작
작업이 무더기로 쌓이기 수 있습니다.

809
00:38:20,990 --> 00:38:23,520
이제 무엇을해야합니까?

810
00:38:23,520 --> 00:38:28,570
그래, 난 네를 이동해야,
그때 세 가지 복사 할

811
00:38:28,570 --> 00:38:31,200
지금은 두 가지를 삽입 할 수 있습니다.

812
00:38:31,200 --> 00:38:34,460
그리고이와 캐치
알고리즘, 흥미롭게도,

813
00:38:34,460 --> 00:38:41,050
그것은 우리가 더 극단적 있다고 가정한다
그것의 여덟, 일곱 가정 해 봅시다의 경우,

814
00:38:41,050 --> 00:38:45,150
6, 5, 4, 3, 2, 하나.

815
00:38:45,150 --> 00:38:49,450
이것은 많은 상황에서, 인,
최악의 경우,

816
00:38:49,450 --> 00:38:51,570
이놈의 일 때문에
말 그대로 거꾸로입니다.

817
00:38:51,570 --> 00:38:53,670
>> 정말하지 않습니다
벤의 알고리즘에 영향을 미칠

818
00:38:53,670 --> 00:38:55,940
때문에 벤의 선택에
정렬 그는 계속 것

819
00:38:55,940 --> 00:38:58,359
앞뒤로 목록을 것.

820
00:38:58,359 --> 00:39:01,150
그리고 그는 항상 찾고 있었기 때문에
전체 나머지 목록을,

821
00:39:01,150 --> 00:39:02,858
그것은 중요하지 않습니다
요소가있는 곳.

822
00:39:02,858 --> 00:39:05,630
하지만 내 삽입이 경우
approach--의이 시도 할 수 있습니다.

823
00:39:05,630 --> 00:39:08,616
>> 따라서 하나, 둘, 셋, 넷,
다섯, 여섯, 일곱, 여덟.

824
00:39:08,616 --> 00:39:11,630
하나 둘 셋 넷,
다섯, 여섯, 일곱, 여덟.

825
00:39:11,630 --> 00:39:14,320
나는 팔을거야
어디서 나는 그것을 배치해야합니까?

826
00:39:14,320 --> 00:39:17,260
글쎄, 내 목록의 시작 부분에서,
이 새로운 목록이 정렬되어 있기 때문이다.

827
00:39:17,260 --> 00:39:18,760
그리고 나는 그것을 밖으로 교차합니다.

828
00:39:18,760 --> 00:39:20,551
>> 어디 칠을 배치해야합니까?

829
00:39:20,551 --> 00:39:21,050
그것을 터무니.

830
00:39:21,050 --> 00:39:23,174
그것은, 거기에 갈 필요가 그래서
나는 약간의 복사를해야한다.

831
00:39:23,174 --> 00:39:26,820

832
00:39:26,820 --> 00:39:28,480
이제 일곱 여기 간다.

833
00:39:28,480 --> 00:39:29,860
지금은 여섯로 이동합니다.

834
00:39:29,860 --> 00:39:30,980
지금은 더 많은 작품입니다.

835
00:39:30,980 --> 00:39:32,570
>> 여덟는 여기에있다.

836
00:39:32,570 --> 00:39:33,920
세븐은 여기에있다.

837
00:39:33,920 --> 00:39:35,450
이제 여섯 여기에 갈 수 있습니다.

838
00:39:35,450 --> 00:39:37,950
지금은 다섯을 잡아.

839
00:39:37,950 --> 00:39:40,560
이제 팔 가고있다
여기에, 칠이 여기에있다,

840
00:39:40,560 --> 00:39:43,650
여섯 여기에 있고,
이제 다섯 반복합니다.

841
00:39:43,650 --> 00:39:46,610
그리고 나는 꽤 많이 해요
끊임없이 이동.

842
00:39:46,610 --> 00:39:52,950
>> 그래서 결국에,이 algorithm-- 우리는거야
삽입 실제로 sort-- 호출

843
00:39:52,950 --> 00:39:55,020
너무 많은 일이있다.

844
00:39:55,020 --> 00:39:56,970
그냥 다르다
벤의보다 작업의 종류.

845
00:39:56,970 --> 00:40:00,090
벤의 작품은 나를 가고 있었다
앞뒤로 항상,

846
00:40:00,090 --> 00:40:03,510
작은 다음을 선택
요소 다시 다시.

847
00:40:03,510 --> 00:40:06,660
그래서 작업이 매우 시각적 인 친절했다.

848
00:40:06,660 --> 00:40:10,600
>> 아직이 다른 알고리즘,
correct--이 작업을 얻을 것이다 done--

849
00:40:10,600 --> 00:40:12,800
단지 작업의 양을 변경합니다.

850
00:40:12,800 --> 00:40:15,420
처음에 당신이있어 것 같습니다
당신은 단지이기 때문에, 저장

851
00:40:15,420 --> 00:40:19,190
각 요소를 처리
앞까지의 모든 산책없이

852
00:40:19,190 --> 00:40:20,930
벤과 같은 목록을하는 방식이었다.

853
00:40:20,930 --> 00:40:25,300
그러나 문제는 특히 이들에서,
이 모든 이전 버전의 미친 경우,

854
00:40:25,300 --> 00:40:27,830
당신은 종류의 단지 것
열심히 연기

855
00:40:27,830 --> 00:40:30,360
당신은 당신의 실수를 해결하기 위해 때까지.

856
00:40:30,360 --> 00:40:33,919
>> 그리고, 그래서 만약 당신이 상상할 수
여덟 일곱 여섯 다섯

857
00:40:33,919 --> 00:40:36,710
이상 네, 셋, 둘
목록을 자신의 길을 이동,

858
00:40:36,710 --> 00:40:39,060
우리가 변경 한
작업의 종류는 우리가 일을하고 있습니다.

859
00:40:39,060 --> 00:40:42,340
대신에 그 일의
내 반복의 시작,

860
00:40:42,340 --> 00:40:45,250
난 그냥 그것을하고 있어요
모든 반복의 끝.

861
00:40:45,250 --> 00:40:50,550
그래서,이 알고리즘 밝혀
또한, 일반적으로 불리는 삽입 정렬,

862
00:40:50,550 --> 00:40:52,190
제곱 N의 순서이기도하다.

863
00:40:52,190 --> 00:40:56,480
그것은 더 좋은 사실은 없다
더 좋은 전혀 없습니다.

864
00:40:56,480 --> 00:41:00,810
>> 그러나, 세 번째 방법이있다
내가 생각하는 우리를 격려 것

865
00:41:00,810 --> 00:41:02,970
어떤이있다.

866
00:41:02,970 --> 00:41:07,850
그래서 간단하게하기 위해, 내 목록을 가정
또, 4 개의 번, 세

867
00:41:07,850 --> 00:41:11,080
단지 네 개의 숫자 2가 있으며.

868
00:41:11,080 --> 00:41:13,300
벤, 좋은 직감했다
좋은 인간의 직관

869
00:41:13,300 --> 00:41:16,340
전에,하는 우리는 전체를 고정
eventually-- 삽입 정렬을 나열합니다.

870
00:41:16,340 --> 00:41:18,020
나는 우리를 따라 구슬려.

871
00:41:18,020 --> 00:41:22,530
그러나의은을 살펴 보자
이 목록을 해결하는 간단한 방법.

872
00:41:22,530 --> 00:41:24,110
>> 이 목록은 분류되지 않습니다.

873
00:41:24,110 --> 00:41:26,130
왜?

874
00:41:26,130 --> 00:41:31,920
영어, 이유를 설명
그것은 실제로 분류 아니에요.

875
00:41:31,920 --> 00:41:33,400
이 분류되지 무엇을 의미 하는가?

876
00:41:33,400 --> 00:41:34,220
>> 학생 : 그것은 순차적 아닙니다.

877
00:41:34,220 --> 00:41:34,990
>> DAVID 마란 : 순차적하지 않습니다.

878
00:41:34,990 --> 00:41:35,822
나에게 예를 제공합니다.

879
00:41:35,822 --> 00:41:37,180
>> 학생 : 순서에 넣어.

880
00:41:37,180 --> 00:41:37,440
>> DAVID 마란 : OK.

881
00:41:37,440 --> 00:41:38,790
나에게 더 구체적인 예를 제공합니다.

882
00:41:38,790 --> 00:41:39,832
>> 학생 : 순서를 오름차순.

883
00:41:39,832 --> 00:41:41,206
DAVID 마란 : 오름차순 없습니다.

884
00:41:41,206 --> 00:41:42,100
더 정확합니다.

885
00:41:42,100 --> 00:41:45,190
난 당신이 상승 무슨 뜻인지 모르겠어요.

886
00:41:45,190 --> 00:41:47,150
뭐가 문제 야?

887
00:41:47,150 --> 00:41:49,930
>> 학생 :의 가장 작은
숫자는 최초의 우주에 있지 않습니다.

888
00:41:49,930 --> 00:41:51,140
>> DAVID 마란 : 작은 수의
하지 첫 번째 공간입니다.

889
00:41:51,140 --> 00:41:52,120
더 구체적으로.

890
00:41:52,120 --> 00:41:55,000
내가 잡을 시작 했어.

891
00:41:55,000 --> 00:41:59,470
우리는 계산 만하고
여기 순서가 무엇입니까?

892
00:41:59,470 --> 00:42:00,707
>> 학생 : 수치 순서.

893
00:42:00,707 --> 00:42:02,040
DAVID 마란 : 수치 순서.

894
00:42:02,040 --> 00:42:04,248
유지의 모든 사람의 종류
그것은 매우 높은 수준을 here--.

895
00:42:04,248 --> 00:42:07,450
그냥 말 그대로 무엇을 말해
5 년 된 힘과 같은 잘못된.

896
00:42:07,450 --> 00:42:08,310
>> 학생 : 플러스 하나.

897
00:42:08,310 --> 00:42:08,750
>> DAVID 마란 : 무엇입니까?

898
00:42:08,750 --> 00:42:09,610
>> 학생 : 플러스 하나.

899
00:42:09,610 --> 00:42:11,235
>> 데이비드 마란은 : 당신은 무엇을 더한을 의미합니까?

900
00:42:11,235 --> 00:42:12,754

901
00:42:12,754 --> 00:42:14,170
나에게 다른 다섯 살주세요.

902
00:42:14,170 --> 00:42:16,840

903
00:42:16,840 --> 00:42:18,330
잘못된, 엄마는 무엇입니까?

904
00:42:18,330 --> 00:42:19,940
잘못된, 아빠는 무엇입니까?

905
00:42:19,940 --> 00:42:22,808
이 정렬되지 않습니다 무엇을 의미합니까?

906
00:42:22,808 --> 00:42:24,370
>> 학생 : 그것은 바로 이곳이 아니다.

907
00:42:24,370 --> 00:42:25,580
>> DAVID 마란 : 무슨 일이야
하지 않을 권리 장소에서?

908
00:42:25,580 --> 00:42:26,174
>> 학생 : 네.

909
00:42:26,174 --> 00:42:27,090
DAVID 마란 : OK, 좋아.

910
00:42:27,090 --> 00:42:29,110
그것이 있어야 할 곳에 따라서 네 가지가 아니다.

911
00:42:29,110 --> 00:42:30,590
특히,이 권리는?

912
00:42:30,590 --> 00:42:33,000
네 하나, 제
내가 보는 두 개의 숫자.

913
00:42:33,000 --> 00:42:34,930
이 권리인가?

914
00:42:34,930 --> 00:42:36,427
아니, 순서가있어, 오른쪽?

915
00:42:36,427 --> 00:42:38,135
사실, 지금 생각
또한, 컴퓨터에 대한.

916
00:42:38,135 --> 00:42:40,824
그것은 단지, 아마 한 곳에서 볼 수 있습니다
once--에서 아마 두 가지

917
00:42:40,824 --> 00:42:43,240
실제로 단 한 가지
한번에 있지만 수있는 적어도

918
00:42:43,240 --> 00:42:45,790
한 가지에서 다음을 보면
바로 옆에 다음 일은.

919
00:42:45,790 --> 00:42:47,380
>> 그래서이 순서대로인가?

920
00:42:47,380 --> 00:42:48,032
당연히 아니지.

921
00:42:48,032 --> 00:42:48,740
그래서 당신은 무엇인지?

922
00:42:48,740 --> 00:42:51,020
왜 우리는 아기를하지 않습니다
이 문제를 해결 단계

923
00:42:51,020 --> 00:42:53,410
대신이 멋진 일을
벤, 같은 알고리즘

924
00:42:53,410 --> 00:42:56,440
그는 일종의하여 고정이야
목록을 반복

925
00:42:56,440 --> 00:42:59,670
대신, 여기서 내가 한 일을의
우리가 가서 그냥 가지를 고정?

926
00:42:59,670 --> 00:43:03,650
그냥 그대로를 분해하자
order-- 숫자 순서의 개념,

927
00:43:03,650 --> 00:43:06,990
당신이 원합니까 어떤 호출
이 페어의 비교에.

928
00:43:06,990 --> 00:43:07,590
>> 네 하나.

929
00:43:07,590 --> 00:43:09,970
이 올바른 순서는?

930
00:43:09,970 --> 00:43:11,310
그래서 그 문제를 해결 할 수 있습니다.

931
00:43:11,310 --> 00:43:14,700
하나 네, 다음
우리는 그냥 복사됩니다.

932
00:43:14,700 --> 00:43:15,560
좋아, 좋아.

933
00:43:15,560 --> 00:43:17,022
내가 하나 사 고정.

934
00:43:17,022 --> 00:43:18,320
세 및이?

935
00:43:18,320 --> 00:43:18,820
아니.

936
00:43:18,820 --> 00:43:21,690
내 말은 내 손가락과 일치 할 수 있습니다.

937
00:43:21,690 --> 00:43:23,695
네 세?

938
00:43:23,695 --> 00:43:27,930
>> 그것은 순서가 아닌, 그래서 나는거야
하나, 셋, 넷, 두 가지를 할 수 있습니다.

939
00:43:27,930 --> 00:43:28,680
그래 좋아.

940
00:43:28,680 --> 00:43:32,310
지금 사 및이?

941
00:43:32,310 --> 00:43:33,370
우리는 너무,이 문제를 해결해야합니다.

942
00:43:33,370 --> 00:43:36,700
따라서 하나, 셋, 2, 4.

943
00:43:36,700 --> 00:43:39,820
그래서 정렬?

944
00:43:39,820 --> 00:43:43,170
아니하지만 정렬에 가까운?

945
00:43:43,170 --> 00:43:48,930
>> 우리는이 문제를 해결하기 때문이다
실수, 우리는이 실수를 고정

946
00:43:48,930 --> 00:43:50,370
우리는이 실수를 고정.

947
00:43:50,370 --> 00:43:52,420
그래서 우리는 틀림없이 세 가지 실수를 고정.

948
00:43:52,420 --> 00:43:58,100
아직도 정말 정렬 보이지만하지 않습니다
그것은 정렬을 객관적으로 가까운

949
00:43:58,100 --> 00:44:00,080
우리는 그 실수의 일부를 고정하기 때문이다.

950
00:44:00,080 --> 00:44:02,047
>> 지금은 다음에 무엇을해야합니까?

951
00:44:02,047 --> 00:44:03,630
I 일종의 목록의 끝에 도달 하였다.

952
00:44:03,630 --> 00:44:05,680
내가 해결 한 듯
모든 실수 있지만.

953
00:44:05,680 --> 00:44:08,510
이 경우, 어떤 숫자 때문에
가까이까지 버블 수도

954
00:44:08,510 --> 00:44:10,410
다른 숫자에 해당
순서가 아직.

955
00:44:10,410 --> 00:44:12,951
그럼 다시하자, 나는거야
단지 장소에서이 시간을 해.

956
00:44:12,951 --> 00:44:14,170
한 세?

957
00:44:14,170 --> 00:44:14,720
괜찮아.

958
00:44:14,720 --> 00:44:16,070
세 및이?

959
00:44:16,070 --> 00:44:17,560
물론 아니, 그래서 그것을 변경할 수 있습니다.

960
00:44:17,560 --> 00:44:19,160
그래서 둘, 셋.

961
00:44:19,160 --> 00:44:21,340
셋, 넷?

962
00:44:21,340 --> 00:44:24,370
그리고 지금은 그냥하자
여기에 특히 현학적.

963
00:44:24,370 --> 00:44:26,350
이 분류되어 있습니까?

964
00:44:26,350 --> 00:44:29,280
당신 인간은이 분류 압니다.

965
00:44:29,280 --> 00:44:30,400
>> 나는 다시 시도해야합니다.

966
00:44:30,400 --> 00:44:31,900
그래서 올리비아 내가 다시 시도 제안하고있다.

967
00:44:31,900 --> 00:44:32,530
왜?

968
00:44:32,530 --> 00:44:35,810
컴퓨터가 없기 때문에
우리 인간의 눈의 고급

969
00:44:35,810 --> 00:44:38,080
단지 back-- 확인을이기는, 난 끝났어요.

970
00:44:38,080 --> 00:44:41,610
어떻게 컴퓨터가 결정 하는가
목록이 이제 정렬되어 있는지?

971
00:44:41,610 --> 00:44:44,590
기계적.

972
00:44:44,590 --> 00:44:47,650
>> 나는 통과한다
다시 한 번, 그리고 경우에만 I

973
00:44:47,650 --> 00:44:51,190
나는 어떤 실수를 찾을 수 / 수하지 않습니다
다음 네, 컴퓨터로 결론,

974
00:44:51,190 --> 00:44:51,980
우리가 갈 수 있어요.

975
00:44:51,980 --> 00:44:54,850
그래서 하나, 둘, 둘,
셋, 셋, 넷.

976
00:44:54,850 --> 00:44:58,030
지금은 확실히이 말할 수 있습니다
내가 변경하지 때문에, 분류.

977
00:44:58,030 --> 00:45:01,940
지금은 버그 단지 것
어리석은 나는 경우, 컴퓨터,

978
00:45:01,940 --> 00:45:05,640
다시 그 같은 질문과 대답
다른 대답을 기대.

979
00:45:05,640 --> 00:45:07,110
일이 안된다.

980
00:45:07,110 --> 00:45:08,600
>> 그리고 이제 목록이 정렬됩니다.

981
00:45:08,600 --> 00:45:12,630
불행하게도, 시간을 실행
이 알고리즘은 제곱 N된다.

982
00:45:12,630 --> 00:45:13,130
왜?

983
00:45:13,130 --> 00:45:19,520
는 N 개의 숫자 및에 가지고 있기 때문에
최악의 경우는 n 개의 번호를 이동해야

984
00:45:19,520 --> 00:45:23,637
n 배 당신이 계속해야하기 때문에
다시 확인하고 잠재적으로 수정

985
00:45:23,637 --> 00:45:24,220
이 숫자.

986
00:45:24,220 --> 00:45:26,280
그리고 우리는 더 많은 일을 할 수 있습니다
너무 형식적인 분석.

987
00:45:26,280 --> 00:45:29,530
>> 그래서 이것은 우리가 촬영 한 말을 전부입니다
세 가지 다른 접근 방식, 하나

988
00:45:29,530 --> 00:45:32,210
그 즉시 직관적
벤에서 박쥐

989
00:45:32,210 --> 00:45:35,170
내 제안 삽입에
이것에 정렬

990
00:45:35,170 --> 00:45:38,540
당신은 종류의 시력을 잃을 경우
처음에는 나무의 숲입니다.

991
00:45:38,540 --> 00:45:41,760
하지만 당신은 다시 조치를 취할 경우
짜잔, 우리는 분류 개념을 수정했습니다.

992
00:45:41,760 --> 00:45:43,824
그래서이는 말을 감히된다
낮은 수준 아마도

993
00:45:43,824 --> 00:45:45,740
그 다른 어떤 것보다
알고리즘,하지만하자의

994
00:45:45,740 --> 00:45:48,550
우리가 시각화 할 수 있는지
이러한 방법에 의해이.

995
00:45:48,550 --> 00:45:51,450
>> 그래서 몇 가지 좋은
소프트웨어 누군가

996
00:45:51,450 --> 00:45:56,110
의 다채로운 막대를 사용하여 작성
우리를 위해 다음을 수행 할 것.

997
00:45:56,110 --> 00:45:57,736
이 바의 각각의 숫자를 나타낸다.

998
00:45:57,736 --> 00:46:00,026
더 큰, 바 키도 커 보이죠
수, 작은 바,

999
00:46:00,026 --> 00:46:00,990
수 작은.

1000
00:46:00,990 --> 00:46:05,880
그래서 이상적으로 우리는 멋진 피라미드를 원하는
그것은 작은 시작, 큰 얻을 경우,

1001
00:46:05,880 --> 00:46:08,330
그리고 그런 의미
이 바는 분류되어 있습니다.

1002
00:46:08,330 --> 00:46:11,200
그래서, 가서 선택하는거야
예를 들어, 벤의 알고리즘

1003
00:46:11,200 --> 00:46:13,990
first-- 선택 정렬.

1004
00:46:13,990 --> 00:46:16,220
>> 그리고 그것은 무엇을하고 있는지 알 수 있습니다.

1005
00:46:16,220 --> 00:46:18,670
그들이가 선택한 방법
이 알고리즘을 시각화

1006
00:46:18,670 --> 00:46:22,090
I이었다처럼이다
내 목록을 걷고,

1007
00:46:22,090 --> 00:46:24,710
이 프로그램은 걷고있다
번호의 목록을,

1008
00:46:24,710 --> 00:46:28,160
핑크 각 강조
이를 찾고 번호.

1009
00:46:28,160 --> 00:46:32,360
그리고 지금 일이에 대해 무엇입니까?

1010
00:46:32,360 --> 00:46:35,154
>> 가장 작은 번호가
I 또는 벤은 갑자기 발견

1011
00:46:35,154 --> 00:46:36,820
리스트의 시작 부분으로 이동 도착.

1012
00:46:36,820 --> 00:46:40,037
그리고 그들은 퇴거를 한주의 사항
거기 수,

1013
00:46:40,037 --> 00:46:41,120
그것은 완벽하게 괜찮아요.

1014
00:46:41,120 --> 00:46:42,600
나는 세부 사항의 수준에하지 않았다.

1015
00:46:42,600 --> 00:46:44,308
그러나 우리는 둘 필요가
어딘가에 그 번호,

1016
00:46:44,308 --> 00:46:47,775
그래서 우리는 단지로 이동
생성 된 열린 자리.

1017
00:46:47,775 --> 00:46:49,900
그래서 나는이 속도를하려고 해요
최대, 그렇지 않으면 때문에

1018
00:46:49,900 --> 00:46:51,871
신속 매우 지루한된다.

1019
00:46:51,871 --> 00:46:55,800

1020
00:46:55,800 --> 00:46:58,600
애니메이션이 speed-- 우리는 간다.

1021
00:46:58,600 --> 00:47:01,850
그래서 지금 같은 원리
I 적용하고 있지만,

1022
00:47:01,850 --> 00:47:06,540
이 경우, 알고리즘을 느끼기 시작할 수 있습니다
것, 또는 좀 더 명확하게 참조하십시오.

1023
00:47:06,540 --> 00:47:13,190
본 알고리즘의 효과를 갖는다
그 다음 최소의 요소를 선택

1024
00:47:13,190 --> 00:47:16,422
그래서 당신은에 시작하는거야
그 왼쪽에 진입로를 참조하십시오.

1025
00:47:16,422 --> 00:47:19,130
그리고 각각의 반복에, I는
제안, 그것은 좀 덜 작업을 수행합니다.

1026
00:47:19,130 --> 00:47:21,921
그것은 모든 길을 갈 필요가 없습니다
다시 목록의 좌단,

1027
00:47:21,921 --> 00:47:23,900
이미 때문에
분류되어 사람들은 알고있다.

1028
00:47:23,900 --> 00:47:28,129
이처럼 그래서 종류의 느낌
각 단계이더라도 가속

1029
00:47:28,129 --> 00:47:29,420
동일한 시간 복용.

1030
00:47:29,420 --> 00:47:31,600
나머지 단지 적은 단계가있다.

1031
00:47:31,600 --> 00:47:35,240
그리고 지금 당신은 이러한 종류의를 느낄 수있다
알고리즘은 그것의 단부를 청소

1032
00:47:35,240 --> 00:47:37,040
실제로 지금이 분류되어있어.

1033
00:47:37,040 --> 00:47:41,620
>> 그래서 삽입 정렬은 모든 수행합니다.

1034
00:47:41,620 --> 00:47:43,600
나는 배열을 다시 무작위해야합니다.

1035
00:47:43,600 --> 00:47:45,940
그리고 알 난 그냥 수
그것을 무작위 유지,

1036
00:47:45,940 --> 00:47:50,630
그리고 우리의 근사치를 얻을 수 있습니다
같은 방법, 삽입 정렬.

1037
00:47:50,630 --> 00:47:55,050
내가 여기에 속도를 느리게 할 수 있습니다.

1038
00:47:55,050 --> 00:47:56,915
이제 그 시작하자.

1039
00:47:56,915 --> 00:47:57,414
중지.

1040
00:47:57,414 --> 00:48:00,662

1041
00:48:00,662 --> 00:48:02,410
>> 의 네를 건너 뛸 수 있습니다.

1042
00:48:02,410 --> 00:48:03,200
우리는 거기에 갈.

1043
00:48:03,200 --> 00:48:04,190
그들은 배열을 무작위.

1044
00:48:04,190 --> 00:48:05,555
그리고 여기에 우리가 삽입 정렬을 나아갈.

1045
00:48:05,555 --> 00:48:10,260

1046
00:48:10,260 --> 00:48:12,800
놀이.

1047
00:48:12,800 --> 00:48:17,280
그것은 각 다루는 것납니다
그것은 바로 발생 요소,

1048
00:48:17,280 --> 00:48:20,282
하지만에 속하는 경우
잘못된 장소 고지

1049
00:48:20,282 --> 00:48:21,740
일어날 수있는 모든 작업.

1050
00:48:21,740 --> 00:48:24,700
우리는 더 많은 변화 유지해야
많은 요소가 공간을 확보하기 위해

1051
00:48:24,700 --> 00:48:27,340
하나의 위해 우리는 장소에 넣어 싶습니다.

1052
00:48:27,340 --> 00:48:30,740
>> 그래서 우리는에 초점을 맞추고있어
리스트 만의 왼쪽 끝.

1053
00:48:30,740 --> 00:48:34,460
우리는 심지어 우리 at-- 못 봤어주의 사항
핑크 아무것도 강조하지 않은

1054
00:48:34,460 --> 00:48:35,610
오른쪽으로.

1055
00:48:35,610 --> 00:48:38,180
우리는 상대하고
문제는 우리가 가서

1056
00:48:38,180 --> 00:48:40,430
그러나 우리는 많이 만들
여전히 자신을 위해 일한다.

1057
00:48:40,430 --> 00:48:44,410
그리고 우리는이 속도를 그렇다면
현재 완료로 이동하고,

1058
00:48:44,410 --> 00:48:46,210
그것은 참으로 그것에 다른 느낌이있다.

1059
00:48:46,210 --> 00:48:50,150
그것은 단지 왼쪽 끝 부분에 초점을 맞추고 있지만,
needed--으로 좀 더 일을

1060
00:48:50,150 --> 00:48:53,230
스무딩 가지의 종류
이상 물건을 고정,

1061
00:48:53,230 --> 00:48:58,350
하지만 함께 궁극적으로 다루고
한 번에 각 요소 하나

1062
00:48:58,350 --> 00:49:07,740
우리가 잘 가까이 대고 할 때까지, 우리
모든이 끝날 것입니다 방법을 알고,

1063
00:49:07,740 --> 00:49:09,700
그래서 조금 실망 아마입니다.

1064
00:49:09,700 --> 00:49:12,830
>> 그러나 end--의 목록
spoiler-- 정렬 할 것입니다.

1065
00:49:12,830 --> 00:49:15,300
그럼 마지막으로 하나 살펴 보자.

1066
00:49:15,300 --> 00:49:16,840
우리는 지금 막 건너 뛸 수 없습니다.

1067
00:49:16,840 --> 00:49:18,000
우리는 거의 다 왔어.

1068
00:49:18,000 --> 00:49:19,980
두 사람은 가고, 이동합니다.

1069
00:49:19,980 --> 00:49:22,680
그리고 짜잔.

1070
00:49:22,680 --> 00:49:23,450
우수한.

1071
00:49:23,450 --> 00:49:27,220
>> 그래서 지금의이 마지막 일을하자,
다시 무작위 거품 정렬과 함께.

1072
00:49:27,220 --> 00:49:31,690
그리고 나는 그것을 천천히 특히, 여기에 주목
아래로,이를 통해 습격 유지 않습니다.

1073
00:49:31,690 --> 00:49:36,830
그러나 그것은 단지 페어를하게 알
로컬 솔루션 comparisons-- 종류.

1074
00:49:36,830 --> 00:49:39,050
그러나 곧 우리에 얻을로
핑크리스트의 말미에,

1075
00:49:39,050 --> 00:49:40,690
어떻게 다시 일해야하는거야?

1076
00:49:40,690 --> 00:49:44,539

1077
00:49:44,539 --> 00:49:46,830
그래,에있는 것
, 시작 그것 때문에 만

1078
00:49:46,830 --> 00:49:49,870
고정 페어의 실수.

1079
00:49:49,870 --> 00:49:53,120
그리고 아직 다른 사람을 공개했을 수 있습니다.

1080
00:49:53,120 --> 00:49:58,950
이 속도를 만약 그렇다면, 당신은거야
이름이 의미하는만큼, 그 참조

1081
00:49:58,950 --> 00:50:01,870
의 elements-- 작거나 오히려
큰 elements--은 시작

1082
00:50:01,870 --> 00:50:03,740
거품에 가기까지, 당신이됩니다.

1083
00:50:03,740 --> 00:50:07,380
그리고 작은 요소는
아래 왼쪽에 거품을 시작.

1084
00:50:07,380 --> 00:50:10,780
그리고 실제로, 그 가지의
뿐만 아니라 시각적 효과.

1085
00:50:10,780 --> 00:50:17,150
그리고이 마무리 종료됩니다
너무 매우 유사한 방식이다.

1086
00:50:17,150 --> 00:50:19,160
>> 우리는 거주 할 필요가 없습니다
이 특정 일에.

1087
00:50:19,160 --> 00:50:21,010
나 역시 지금을 열 수 있습니다.

1088
00:50:21,010 --> 00:50:24,040
몇 가지 다른 정렬 알고리즘이있다
세계에서 몇 어떤의

1089
00:50:24,040 --> 00:50:25,580
여기에 캡처됩니다.

1090
00:50:25,580 --> 00:50:29,960
특히 학습자 사람 아니다
반드시 시각적 또는 수학,

1091
00:50:29,960 --> 00:50:31,930
우리가 전에했던 것처럼, 우리는 할 수
또한 audially 이렇게

1092
00:50:31,930 --> 00:50:34,210
우리는이와 소리를 연결합니다.

1093
00:50:34,210 --> 00:50:36,990
그리고 그냥 재미, 여기에
몇 가지 알고리즘,

1094
00:50:36,990 --> 00:50:40,950
당신이있어 특히 그들 중 하나
라고 알 것 "병합 정렬."

1095
00:50:40,950 --> 00:50:43,250
>> 실제로 근본적이다
더 나은 알고리즘,

1096
00:50:43,250 --> 00:50:45,860
한 종류의 병합되도록
당신이 볼하려고하고있는 것,

1097
00:50:45,860 --> 00:50:49,170
제곱 (n)의 순서가 아닙니다.

1098
00:50:49,170 --> 00:50:57,280
그것은 N의 시간의 기록 순서에의
실제로 작고 따라서 인 N,

1099
00:50:57,280 --> 00:50:58,940
그 다른 세보다 빠르다.

1100
00:50:58,940 --> 00:51:00,670
그리고 다른 몇 가지있다
우리가 볼 수 바보들.

1101
00:51:00,670 --> 00:51:01,933
>> 그래서 여기에 우리는 몇 가지 소리와 함께 이동합니다.

1102
00:51:01,933 --> 00:51:06,620

1103
00:51:06,620 --> 00:51:10,490
이 때문에 다시 삽입 정렬입니다
그냥 요소를 다루는 것

1104
00:51:10,490 --> 00:51:13,420
그들은 와서.

1105
00:51:13,420 --> 00:51:17,180
이는 거품 정렬이므로있어
그들에게 한 번에 쌍을 고려.

1106
00:51:17,180 --> 00:51:22,030

1107
00:51:22,030 --> 00:51:24,490
그리고 또, 가장 큰 요소
가기까지 버블 링됩니다.

1108
00:51:24,490 --> 00:51:38,098

1109
00:51:38,098 --> 00:51:41,710
>> 위로 다음 선택 정렬.

1110
00:51:41,710 --> 00:51:45,420
이 벤의 알고리즘입니다
다시 그는 반복적으로 선택하는 것

1111
00:51:45,420 --> 00:51:46,843
다음 작은 요소입니다.

1112
00:51:46,843 --> 00:51:49,801

1113
00:51:49,801 --> 00:51:53,900
그리고 또, 지금 당신은 정말 그 소리를들을 수
그것은하지만 지금까지 최대 속도이야

1114
00:51:53,900 --> 00:51:58,230
이 갈수록를하고있어로
각 반복에서 작동합니다.

1115
00:51:58,230 --> 00:52:04,170
이 빠른에게 하나, 일종의 병합,
수의 클러스터를 분류하는

1116
00:52:04,170 --> 00:52:05,971
함께 한 다음 결합.

1117
00:52:05,971 --> 00:52:07,720
그래서 왼쪽 저게 ...
절반은 이미 정렬됩니다.

1118
00:52:07,720 --> 00:52:14,165
>> 지금은 오른쪽 절반을 정렬하고있어
지금은 하나로 결합하는 것입니다.

1119
00:52:14,165 --> 00:52:19,160
이것은라는 뭔가 "그놈 정렬."

1120
00:52:19,160 --> 00:52:23,460
그리고 당신은 종류의 것을 볼 수 있습니다
그것은 앞뒤로거야

1121
00:52:23,460 --> 00:52:27,950
조금 여기에 작품을 고정하고
그것은 새로운 일에이 진행되기 전에.

1122
00:52:27,950 --> 00:52:32,900

1123
00:52:32,900 --> 00:52:33,692
그리고 그게 다입니다.

1124
00:52:33,692 --> 00:52:36,400
또 다른 종류가있다
정말 학문적 목적을 위해,

1125
00:52:36,400 --> 00:52:40,980
소요 "바보 같은 종류"라고
데이터는 무작위로 정렬

1126
00:52:40,980 --> 00:52:43,350
이 분류되는 경우 다음 확인합니다.

1127
00:52:43,350 --> 00:52:47,880
그렇지 않은 경우, 그것은 다시 정렬을
이 분류되어있어 경우 무작위 검사,

1128
00:52:47,880 --> 00:52:49,440
그리고 반복하지 않을 경우.

1129
00:52:49,440 --> 00:52:52,660
그리고 이론, 확률
이것은 완료

1130
00:52:52,660 --> 00:52:54,140
하지만 시간이 꽤 후.

1131
00:52:54,140 --> 00:52:56,930
그것은 가장 아니에요
알고리즘의 효율적입니다.

1132
00:52:56,930 --> 00:53:02,550
사람들에 따라서 질문
특정 알고리즘 또는 아무것도

1133
00:53:02,550 --> 00:53:04,720
도, 거기에 관련?

1134
00:53:04,720 --> 00:53:09,430
>> 음, 지금 무엇을 모두 떨어져 애타게하자
이 라인은 내가 그리기 봤는데 있습니다

1135
00:53:09,430 --> 00:53:15,090
그리고 내가 컴퓨터를 있으리라 믿고있어
후드 아래에 수행 할 수 있습니다.

1136
00:53:15,090 --> 00:53:18,650
나는이 숫자의 모든 것을 주장
나는 그들이 얻을 필요가 drawing-- 유지

1137
00:53:18,650 --> 00:53:21,330
메모리 어딘가에 저장됩니다.

1138
00:53:21,330 --> 00:53:24,130
우리는 너무, 지금이 사람을 제거 얻을 것이다.

1139
00:53:24,130 --> 00:53:30,110
>> A의 메모리 그래서 조각
그래서 RAM DIMM은 computer--

1140
00:53:30,110 --> 00:53:35,480
우리는 어제, 듀얼 검색 무엇을
다음과 같습니다 module-- 인라인 메모리.

1141
00:53:35,480 --> 00:53:39,370
그리고이 작은 검은 칩의 각
일반적으로, 바이트의 몇 가지 숫자입니다.

1142
00:53:39,370 --> 00:53:44,380
그리고 금 핀은 같다
컴퓨터에 연결 와이어

1143
00:53:44,380 --> 00:53:47,521
및 녹색 실리콘 기판은 그냥
무슨 일이 모두 함께 모든 것을 유지합니다.

1144
00:53:47,521 --> 00:53:48,770
그래서이 정말 무엇을 의미합니까?

1145
00:53:48,770 --> 00:53:53,180
나는 종류의이 같은 그림을 그릴 경우,
의는 단순화를 위해 가정하자

1146
00:53:53,180 --> 00:53:55,280
이 DIMM, 이중 그
인라인 메모리 모듈

1147
00:53:55,280 --> 00:54:00,530
RAM 1 기가 바이트, 1 기가 바이트입니다
얼마나 많은 바이트 전체가 메모리?

1148
00:54:00,530 --> 00:54:02,100
1 기가 바이트는 얼마나 많은 바이트?

1149
00:54:02,100 --> 00:54:04,860

1150
00:54:04,860 --> 00:54:06,030
그 이상.

1151
00:54:06,030 --> 00:54:09,960
1124은 킬로 1000입니다.

1152
00:54:09,960 --> 00:54:11,730
메가 백만원입니다.

1153
00:54:11,730 --> 00:54:14,570
Giga는 억이다.

1154
00:54:14,570 --> 00:54:15,070
>> 나는 거짓말을하고 있는가?

1155
00:54:15,070 --> 00:54:16,670
우리는 심지어 라벨을 읽을 수 있습니까?

1156
00:54:16,670 --> 00:54:19,920
이것은 실제로 128
기가 바이트, 그래서 더 많은입니다.

1157
00:54:19,920 --> 00:54:22,130
그러나 우리는이 척합니다
한 기가 바이트입니다.

1158
00:54:22,130 --> 00:54:25,640
뜻 그래서 억있다
나에 사용할 수있는 메모리의 바이트

1159
00:54:25,640 --> 00:54:29,770
8 억 비트,하지만 우리는거야
지금 바이트의 관점에서 이야기하고,

1160
00:54:29,770 --> 00:54:30,750
앞으로 나아가 다.

1161
00:54:30,750 --> 00:54:36,330
>> 그래서 그 의미하는 것은 이것이다
1 바이트, 이것은 또 다른 바이트,

1162
00:54:36,330 --> 00:54:38,680
이 다른 바이트,
우리가 정말 원하는 경우

1163
00:54:38,680 --> 00:54:43,280
우리가해야 구체적으로
억 작은 사각형을 그립니다.

1164
00:54:43,280 --> 00:54:44,320
그러나 그것은 무엇을 의미 하는가?

1165
00:54:44,320 --> 00:54:46,420
글쎄, 내가 단지 확대하자
이 사진에있다.

1166
00:54:46,420 --> 00:54:50,900
내가 뭔가를 가지고 있다면 그 보인다
이 지금처럼 그 4 바이트를합니다.

1167
00:54:50,900 --> 00:54:53,710
>> 그래서 내가 여기에 네 개의 숫자를 넣을 수 있습니다.

1168
00:54:53,710 --> 00:54:54,990
하나 둘 셋 넷.

1169
00:54:54,990 --> 00:55:00,170
아니면 내가 네 글자 나 기호를 넣을 수 있습니다.

1170
00:55:00,170 --> 00:55:02,620
"이봐!" 바로 거기에 갈 수있다,
문자의 각 때문에,

1171
00:55:02,620 --> 00:55:04,370
우리는 앞에서 언급
표현 될 수

1172
00:55:04,370 --> 00:55:06,650
8 비트 또는 ASCII 또는 바이트와 함께.

1173
00:55:06,650 --> 00:55:09,370
그래서 다른 말로하면, 당신은 할 수
내부 80 억 물건을 넣어

1174
00:55:09,370 --> 00:55:11,137
기억이 하나의 스틱.

1175
00:55:11,137 --> 00:55:14,345
지금은 다시 물건을 넣어 무엇을 의미 하는가
이 같은 메모리에 백업하는 백업하는 방법?

1176
00:55:14,345 --> 00:55:17,330
이것은 어떤 프로그래머입니다
에 "배열을."부를 것이다

1177
00:55:17,330 --> 00:55:21,250
컴퓨터 프로그램, 당신은 생각하지 않는다
기본 하드웨어에 대한이, 그 자체.

1178
00:55:21,250 --> 00:55:24,427
것으로 당신은 자신의 생각
억 바이트 전체에 대한 액세스,

1179
00:55:24,427 --> 00:55:26,010
당신은 아무것도 당신이 그것으로 할 수 있습니다.

1180
00:55:26,010 --> 00:55:27,880
그러나 편의를 위해
그것은 일반적으로 유용

1181
00:55:27,880 --> 00:55:31,202
메모리 권리를 유지
이 같은 서로 옆에.

1182
00:55:31,202 --> 00:55:33,660
그래서이 항아리를 확대하는 경우
우리가 확실하지 않을거야 때문에

1183
00:55:33,660 --> 00:55:39,310
억 조금 squares--을 그리는
의이 보드가 나타내는 가정하자

1184
00:55:39,310 --> 00:55:40,610
이제 메모리의 스틱.

1185
00:55:40,610 --> 00:55:43,800
그리고 난 그냥만큼으로 그릴 거 야 내
마커는 여기에 저를주고 끝납니다.

1186
00:55:43,800 --> 00:55:46,420

1187
00:55:46,420 --> 00:55:52,300
그래서 지금 우리는 막대기를 가지고
보드의 메모리

1188
00:55:52,300 --> 00:55:56,400
즉이있어 하나, 둘, 셋, 넷, 다섯,
여섯, 하나, 둘, 셋, 넷, 다섯, 여섯,

1189
00:55:56,400 --> 00:56:01,130
그렇게 42 바이트를 seven--
화면 전체에 메모리.

1190
00:56:01,130 --> 00:56:01,630
고맙습니다.

1191
00:56:01,630 --> 00:56:02,838
예, 산술 잘했다.

1192
00:56:02,838 --> 00:56:05,120
여기에 메모리 그래서 42 바이트.

1193
00:56:05,120 --> 00:56:06,660
그래서이 사실은 무엇을 의미합니까?

1194
00:56:06,660 --> 00:56:09,830
음, 컴퓨터 프로그래머
것 실제로 일반적으로

1195
00:56:09,830 --> 00:56:12,450
주소 등이 메모리 생각합니다.

1196
00:56:12,450 --> 00:56:16,630
즉, 이들 중 각자
메모리 위치, 하드웨어,

1197
00:56:16,630 --> 00:56:18,030
고유 한 주소가 있습니다.

1198
00:56:18,030 --> 00:56:22,020
>> 그것은 하나의 덜컹 덜컹 울리다만큼 복잡하지입니다
광장, 캠브리지, 질량., 02138.

1199
00:56:22,020 --> 00:56:23,830
대신에, 단지 수있다.

1200
00:56:23,830 --> 00:56:27,930
이 바이트 숫자 0, 이것은이다
하나,이 두 가지이며,이 세 가지이며,

1201
00:56:27,930 --> 00:56:30,327
이 41이다.

1202
00:56:30,327 --> 00:56:30,910
분을 기다립니다.

1203
00:56:30,910 --> 00:56:32,510
나는 잠시 전 (42)을했다 생각했다.

1204
00:56:32,510 --> 00:56:35,050

1205
00:56:35,050 --> 00:56:37,772
나는 제로 카운트 시작
그래서 실제로 맞습니다.

1206
00:56:37,772 --> 00:56:40,980
이제 우리는 실제로 그것을 그릴 필요가 없습니다
그리드로, 당신은 그리드로 그리면

1207
00:56:40,980 --> 00:56:43,520
나는 것을 실제로 생각
약간 오해의 소지가 얻을.

1208
00:56:43,520 --> 00:56:46,650
어떤 프로그래머는 것,
자신의 마음에,

1209
00:56:46,650 --> 00:56:50,310
일반적으로 생각
메모리 단지 테이프처럼로서,

1210
00:56:50,310 --> 00:56:53,340
마스킹 테이프의 조각 같은
그것은 단지와에 영원히 간다

1211
00:56:53,340 --> 00:56:54,980
또는 당신은 메모리가 부족할 때까지.

1212
00:56:54,980 --> 00:56:59,200
그래서 더 일반적인 방법은 그릴
그냥 메모리에 대한 생각

1213
00:56:59,200 --> 00:57:03,710
이 바이트 0 개, 1 개입니다 것입니다,
둘, 셋하고는 점 도트 도트.

1214
00:57:03,710 --> 00:57:07,650
그리고 당신도, (42) 바이트 총이
물리적으로 실제로 수도 있지만

1215
00:57:07,650 --> 00:57:09,480
이 같은 더 뭔가.

1216
00:57:09,480 --> 00:57:12,850
>> 지금 생각하면 그래서
메모리이 같은 단지 테이프처럼,

1217
00:57:12,850 --> 00:57:17,640
이것은 무엇 프로그래머 다시입니다
메모리 어레이 부를 것이다.

1218
00:57:17,640 --> 00:57:20,660
그리고 당신은 실제로 저장하고자 할 때
컴퓨터의 메모리에 뭔가,

1219
00:57:20,660 --> 00:57:23,290
당신은 일반적으로 저장하는 일을
백 - 투 - 다시 다시 - 투 - 다시 할 수 있습니다.

1220
00:57:23,290 --> 00:57:25,010
그래서 우리는 숫자에 대해 이야기했습니다.

1221
00:57:25,010 --> 00:57:30,880
그리고 싶어 할 때 문제를 해결하기 위해
같은 네 번, 세 개의,

1222
00:57:30,880 --> 00:57:33,820
심지어 그냥 그리기되었다하지만
숫자 만 네 번, 세

1223
00:57:33,820 --> 00:57:39,490
보드에 두 컴퓨터는 것
정말 메모리에이 설정이 있습니다.

1224
00:57:39,490 --> 00:57:43,347
>> 그리고 옆에 무엇을 것
컴퓨터의 메모리에 두?

1225
00:57:43,347 --> 00:57:44,680
음, 아무 대답이 없다.

1226
00:57:44,680 --> 00:57:45,770
우리는 정말 모른다.

1227
00:57:45,770 --> 00:57:48,200
그리고 같은 너무 오래
컴퓨터가 필요하지 않습니다,

1228
00:57:48,200 --> 00:57:51,440
옆에 무엇을 상관 할 필요가 없습니다
숫자로는 치료에 대한 않습니다.

1229
00:57:51,440 --> 00:57:55,130
그리고 이전 컴퓨터 상기 할 때
한 번에 하나의 어드레스에서 볼 수 있으며,

1230
00:57:55,130 --> 00:57:56,170
이 이유의 일종이다.

1231
00:57:56,170 --> 00:57:59,490
>> 아니 기록과는 달리
플레이어와 판독 헤드

1232
00:57:59,490 --> 00:58:03,030
단지 특정 볼 수있는
물리적 구식 레코드의 홈

1233
00:58:03,030 --> 00:58:06,500
한번에 마찬가지로
컴퓨터 덕분에 수

1234
00:58:06,500 --> 00:58:09,810
그 CPU와에
인텔 명령어 세트

1235
00:58:09,810 --> 00:58:12,480
누구의 명령 중
메모리에서 읽어

1236
00:58:12,480 --> 00:58:15,590
또는를 memory--에 저장
컴퓨터는 볼 수

1237
00:58:15,590 --> 00:58:19,210
으로 .. 하나의 위치에서
때때로 이들의 조합,

1238
00:58:19,210 --> 00:58:21,770
하지만 한 번에 정말 하나의 위치입니다.

1239
00:58:21,770 --> 00:58:24,770
그래서 때 우리가 뭘하고 있었
이러한 다양한 알고리즘,

1240
00:58:24,770 --> 00:58:28,110
난 그냥 쓰고 있지 않다
vacuum-- 네, 하나, 셋, 둘.

1241
00:58:28,110 --> 00:58:30,849
그 숫자는 실제로 속해
메모리의 물리적 곳.

1242
00:58:30,849 --> 00:58:32,890
그래서 작은 작은있다
트랜지스터 또는 어떤 종류의

1243
00:58:32,890 --> 00:58:35,840
밑에서 전자
후드는 이들 값을 기억.

1244
00:58:35,840 --> 00:58:40,460
>> 그리고 총에, 얼마나 많은 비트는
지금 참여, 단지 명확하게하는 방법?

1245
00:58:40,460 --> 00:58:45,580
그래서이 4 바이트, 또는
지금은 32 비트 총입니다.

1246
00:58:45,580 --> 00:58:49,280
그래서 실제로 32 제로가와
이 네 가지를 구성하는 것.

1247
00:58:49,280 --> 00:58:52,070
여기에 더가있다하지만,
다시 우리는 걱정하지 않는다.

1248
00:58:52,070 --> 00:58:55,120
>> 그래서 지금의 다른 물어 보자
메모리를 사용하여 질문

1249
00:58:55,120 --> 00:58:57,519
끝에 그 때문에
오늘의 분산이다.

1250
00:58:57,519 --> 00:59:00,310
아무리 우리가 할 수있는 것
하루의 끝에 컴퓨터,

1251
00:59:00,310 --> 00:59:02,560
하드웨어는 여전히 인
후드 아래 같은.

1252
00:59:02,560 --> 00:59:04,670
어떻게 여기에 단어를 저장할 것인가?

1253
00:59:04,670 --> 00:59:09,710
음, 컴퓨터에서 단어처럼
"이봐!" 다만 다음과 같이 저장됩니다.

1254
00:59:09,710 --> 00:59:12,300
그리고 당신은 더 이상을 원한다면
단어, 당신은 단순히 수

1255
00:59:12,300 --> 00:59:19,120
그 덮어 쓰기 뭔가 말
여기에 "안녕하세요"와 상점이있다.

1256
00:59:19,120 --> 00:59:23,930
>> 그리고 여기, 너무,이 인접에
이점은, 실제로

1257
00:59:23,930 --> 00:59:26,530
컴퓨터가 단지 수 있으므로
오른쪽에서 왼쪽으로 읽습니다.

1258
00:59:26,530 --> 00:59:28,680
그러나 여기 질문입니다.

1259
00:59:28,680 --> 00:59:33,480
이 단어의 맥락에서,
H-전자 1-1 - 오, 느낌표,

1260
00:59:33,480 --> 00:59:38,740
컴퓨터가 위치를 알 수있는 방법
단어가 시작되고 말씀이 끝나는?

1261
00:59:38,740 --> 00:59:41,690

1262
00:59:41,690 --> 00:59:43,800
숫자의 맥락에서,
방법을 컴퓨터가 수행

1263
00:59:43,800 --> 00:59:48,396
노하우 순서의 길이
숫자 또는이 시작하는 위치를?

1264
00:59:48,396 --> 00:59:50,270
글쎄, 그것은해서 돌출집니다
우리는 너무 많이 가지 않을 것이다

1265
00:59:50,270 --> 00:59:54,970
detail--이 수준에
컴퓨터 메모리에 주위에 물건을 이동

1266
00:59:54,970 --> 00:59:57,800
말 그대로이 주소의 방법으로.

1267
00:59:57,800 --> 01:00:02,080
당신이 있다면, 컴퓨터에 따라서
코드를 작성하는 일을 저장하기

1268
01:00:02,080 --> 01:00:05,800
말처럼, 당신은 무엇이야
정말 입력됩니다 일

1269
01:00:05,800 --> 01:00:11,320
에 기억 식
컴퓨터의 메모리 이러한 단어입니다.

1270
01:00:11,320 --> 01:00:14,370
그래서 나를 매우을하자,
아주 간단한 예.

1271
01:00:14,370 --> 01:00:18,260
>> 내가 가서거야 및
간단한 텍스트 프로그램을 열고,

1272
01:00:18,260 --> 01:00:20,330
내가 만들거야
파일은에서는 hello.c했다.

1273
01:00:20,330 --> 01:00:22,849
이 정보의 대부분은 우리
훌륭한 세부 사항에로 가지 않을 것이다,

1274
01:00:22,849 --> 01:00:25,140
그러나 나는 쓰기거야
같은 언어 프로그램,

1275
01:00:25,140 --> 01:00:31,140
C. 이는 훨씬 더 협박
나는, 스크래치보다 주장

1276
01:00:31,140 --> 01:00:32,490
하지만 정신에 매우 유사합니다.

1277
01:00:32,490 --> 01:00:34,364
사실,이 곱슬
braces-- 당신이 할 수있는 종류의

1278
01:00:34,364 --> 01:00:37,820
난 그냥이 같은 짓을 생각합니다.

1279
01:00:37,820 --> 01:00:39,240
>> 의 실제로,이 작업을 수행 할 수 있습니다.

1280
01:00:39,240 --> 01:00:45,100
녹색 깃발을 클릭하면,
다음을 수행하십시오.

1281
01:00:45,100 --> 01:00:50,210
나는 인쇄 할 "안녕하세요."

1282
01:00:50,210 --> 01:00:51,500
그래서 지금은 의사입니다.

1283
01:00:51,500 --> 01:00:53,000
나는 종류의 라인을 흐리게하고있다.

1284
01:00:53,000 --> 01:00:56,750
C에서,이 언어 내가 말하는거야
약이 줄 인쇄 인사

1285
01:00:56,750 --> 01:01:01,940
실제로 "의 printf"으로된다
일부 괄호와 세미콜론.

1286
01:01:01,940 --> 01:01:03,480
>> 그러나 똑같은 생각이다.

1287
01:01:03,480 --> 01:01:06,730
그리고 이것은 매우 사용하기 쉬운
"녹색 깃발을 클릭하면"된다

1288
01:01:06,730 --> 01:01:10,182
훨씬 더 난해한 "INT 주요 무효."

1289
01:01:10,182 --> 01:01:12,890
그리고 이것은 정말 매핑이 없습니다,
그래서 나는 그냥 무시하는거야.

1290
01:01:12,890 --> 01:01:17,210
그러나 중괄호는 같다
이 같은 곡선 퍼즐 조각.

1291
01:01:17,210 --> 01:01:18,700
>> 그래서 당신이 할 수있는 종류의 같아요.

1292
01:01:18,700 --> 01:01:22,357
심지어, 이전에 프로그램 된 적이없는 경우
이 프로그램은 아마도 무엇을합니까?

1293
01:01:22,357 --> 01:01:25,560

1294
01:01:25,560 --> 01:01:28,000
아마 안녕하세요 인쇄
느낌표.

1295
01:01:28,000 --> 01:01:29,150
>> 그럼 그 시도 할 수 있습니다.

1296
01:01:29,150 --> 01:01:30,800
나는 그것을 저장하는거야.

1297
01:01:30,800 --> 01:01:34,000
그리고 이것은 다시, 아주이다
오래된 학교 환경을 제공합니다.

1298
01:01:34,000 --> 01:01:35,420
내가 드래그 할 수 클릭 할 수 없습니다.

1299
01:01:35,420 --> 01:01:36,910
나는 명령을 입력해야합니다.

1300
01:01:36,910 --> 01:01:41,320
그래서 정말, 내 프로그램을 실행하려면
나는에서는 hello.c처럼,이 작업을 수행 할 수 있습니다.

1301
01:01:41,320 --> 01:01:42,292
그건 내가 실행 파일입니다.

1302
01:01:42,292 --> 01:01:43,500
하지만이 단계를 실종 해요 기다립니다.

1303
01:01:43,500 --> 01:01:46,470
무엇 않았다 우리가 말할 것은 필요하다
C와 같은 언어 단계?

1304
01:01:46,470 --> 01:01:49,470
난 그냥 소스를 작성했습니다
코드, 그러나 나는 무엇을해야합니까?

1305
01:01:49,470 --> 01:01:50,670
네, 컴파일러가 필요합니다.

1306
01:01:50,670 --> 01:01:57,670
여기 내 Mac에서 그래서, 내가 가지고
GCC 호출 된 프로그램, GNU C 컴파일러,

1307
01:01:57,670 --> 01:02:03,990
어느 날이 항아리 회전을 수행 할 수 있습니다
내 소스 코드에, 우리는 그것을 전화 할게,

1308
01:02:03,990 --> 01:02:04,930
기계 코드.

1309
01:02:04,930 --> 01:02:10,180
>> 그리고 나는 그것을 볼 수 있습니다,
또, 다음과 같이, 이러한

1310
01:02:10,180 --> 01:02:14,090
0과 나는 단지
내 소스 코드에서 생성,

1311
01:02:14,090 --> 01:02:15,730
0과 1의 모든.

1312
01:02:15,730 --> 01:02:17,770
그리고 실행하려면
내 program--이 발생

1313
01:02:17,770 --> 01:02:23,010
대한 a.out의 호출되는
역사적 reasons-- "안녕하세요."

1314
01:02:23,010 --> 01:02:24,070
나는 다시 실행할 수 있습니다.

1315
01:02:24,070 --> 01:02:25,690
안녕 안녕 안녕.

1316
01:02:25,690 --> 01:02:27,430
그리고 그것은 작동하는 것 같군.

1317
01:02:27,430 --> 01:02:31,000
>> 그러나 그것은 어딘가에 의미 내
컴퓨터의 메모리 단어입니다

1318
01:02:31,000 --> 01:02:35,279
H-전자 1-1 - 오, 느낌표.

1319
01:02:35,279 --> 01:02:38,070
그리고, 옆 단지로 판명
어떤 컴퓨터는 일반적으로 것

1320
01:02:38,070 --> 01:02:40,550
그래서 위치를 알고 그렇게
일 시작하고 그것의 end--

1321
01:02:40,550 --> 01:02:42,460
여기에 특수 기호를 넣을 것.

1322
01:02:42,460 --> 01:02:46,064
그리고 규칙은 넣어하는 것입니다
단어의 끝 수가 제로

1323
01:02:46,064 --> 01:02:48,230
당신은 어디를 알 수 있도록
실제로, 종료 있도록

1324
01:02:48,230 --> 01:02:52,750
더 자세한 내용을 인쇄 보관하지 마십시오
당신보다 문자가 실제로 계획입니다.

1325
01:02:52,750 --> 01:02:55,400
>> 그러나 여기 테이크 아웃도
이 상당히 비밀입니다 만,

1326
01:02:55,400 --> 01:02:58,140
그것은 궁극적으로는 것이다
비교적 간단합니다.

1327
01:02:58,140 --> 01:03:04,550
당신은 빈 테이프의 종류를 부여했다
당신이 편지를 쓸 수있는 공간입니다.

1328
01:03:04,550 --> 01:03:07,150
당신은 단순히 있어야
임의 같은 특수 기호,

1329
01:03:07,150 --> 01:03:10,316
수 제로의 단부에 넣어
단어 즉 컴퓨터가 인식 할 수 있도록,

1330
01:03:10,316 --> 01:03:13,410
오, 나는 후 인쇄를 중지해야합니다
나는 느낌표를 참조하십시오.

1331
01:03:13,410 --> 01:03:16,090
이 다음 일 때문에
제로의 ASCII 값이며,

1332
01:03:16,090 --> 01:03:19,125
또는 null 문자로
누군가를 부를 것이다.

1333
01:03:19,125 --> 01:03:21,500
그러나 문제의 종류있다
여기에, 그리고 이제 되돌릴 수 있습니다

1334
01:03:21,500 --> 01:03:23,320
잠시 숫자.

1335
01:03:23,320 --> 01:03:28,720
내가 가정 해 있다는 사실,
숫자의 배열을 가지고

1336
01:03:28,720 --> 01:03:30,730
하고 있음을 가정
내가 쓰고 있어요 프로그램입니다

1337
01:03:30,730 --> 01:03:34,680
교사에 대한 등급 책 등
그리고 교사 교실.

1338
01:03:34,680 --> 01:03:38,720
그리고이 프로그램은 그 사람이나 그 여자를 수
학생들의 점수를 입력합니다

1339
01:03:38,720 --> 01:03:39,960
퀴즈에.

1340
01:03:39,960 --> 01:03:43,750
그리고 학생이 도착한다고 가정
첫 퀴즈 100, 어쩌면

1341
01:03:43,750 --> 01:03:49,920
다음 다음 하나에 80, 등
(75) 다음, 제 90 퀴즈.

1342
01:03:49,920 --> 01:03:54,150
>> 이야기를이 시점에서 그래서,
어레이 크기가 네이다.

1343
01:03:54,150 --> 01:03:58,470
절대적으로 더 많은 메모리가에있다
컴퓨터가 있지만, 배열 때문에, 말하자면

1344
01:03:58,470 --> 01:04:00,350
네 크기이다.

1345
01:04:00,350 --> 01:04:06,060
교사가 원하는 것을 지금 가정
클래스에 다섯 번째 퀴즈를 할당합니다.

1346
01:04:06,060 --> 01:04:08,510
음, 것들 중 하나 그는
또는 그녀는해야 할 것입니다

1347
01:04:08,510 --> 01:04:10,650
지금 여기에 추가로 값을 저장합니다.

1348
01:04:10,650 --> 01:04:15,490
하지만 배열의 경우 교사는이
이 프로그램에서 만든이, 대한 크기입니다

1349
01:04:15,490 --> 01:04:22,440
어레이의 문제점 중 하나는이고
당신은 메모리에 계속 추가 할 수 없습니다.

1350
01:04:22,440 --> 01:04:26,470
때문에 어떤 경우의 다른 부분
프로그램은 바로 "안녕하세요"라는 단어가?

1351
01:04:26,470 --> 01:04:29,650
>> 즉, 내 메모리가 될 수있다
프로그램에서 아무것도에 사용됩니다.

1352
01:04:29,650 --> 01:04:33,250
그리고 사전에 나는, 헤이에 입력 한 경우
I 입력 사 퀴즈 점수하려는,

1353
01:04:33,250 --> 01:04:34,784
그들은 여기와 여기에 갈 수 있습니다.

1354
01:04:34,784 --> 01:04:37,700
그리고 당신은 갑자기 당신의 마음을 변경하는 경우
이상과 내가 다섯 번째 퀴즈 싶은 말

1355
01:04:37,700 --> 01:04:40,872
점수, 당신은 할 수 없습니다 만
당신이 원하는 목적지 넣어,

1356
01:04:40,872 --> 01:04:42,580
때문에 어떤이있는 경우
메모리가 사용되고

1357
01:04:42,580 --> 01:04:45,990
뭔가 다른 프로그램을 else--
또는 프로그램의 다른 기능

1358
01:04:45,990 --> 01:04:46,910
당신은 실행하고 있는지?

1359
01:04:46,910 --> 01:04:50,650
그래서 당신은 사전에 생각해야
당신이 당신의 데이터를 저장하는 방법,

1360
01:04:50,650 --> 01:04:54,480
지금 당신이 그린 것 때문에
자신 디지털 코너에.

1361
01:04:54,480 --> 01:04:57,280
>> 그래서 선생님이 대신 수도
프로그램을 작성할 때 말

1362
01:04:57,280 --> 01:04:59,360
저장하기 위해 자신의
등급, 그거 알아?

1363
01:04:59,360 --> 01:05:04,180
나는 요청할 예정
내 프로그램을 작성할 때,

1364
01:05:04,180 --> 01:05:12,070
I이 원하는 제로, 하나, 둘, 셋,
넷, 다섯, 여섯, 여덟 등급 총.

1365
01:05:12,070 --> 01:05:15,320
따라서 하나, 둘, 셋, 넷,
다섯, 여섯, 일곱, 여덟.

1366
01:05:15,320 --> 01:05:18,612
선생님은 그냥-할당 할 수 있습니다
메모리는 자신의 프로그램을 작성할 때

1367
01:05:18,612 --> 01:05:19,570
당신이 무엇을 알고, 말?

1368
01:05:19,570 --> 01:05:22,236
나는 결코 더 할당 않을거야
한 학기에 팔 퀴즈보다.

1369
01:05:22,236 --> 01:05:23,130
그건 그냥 미친 짓이야.

1370
01:05:23,130 --> 01:05:24,470
나는 그것을 할당하지 않을 것이다.

1371
01:05:24,470 --> 01:05:28,270
이 방법은 자신이을 갖도록
매장 학생 점수 유연성,

1372
01:05:28,270 --> 01:05:33,010
75, 90, 어쩌면 하나의 추가 등
학생은 105 여분의 신용을 얻었다.

1373
01:05:33,010 --> 01:05:36,130
>> 그러나 만약 교사 결코
이 세 공간을 사용,

1374
01:05:36,130 --> 01:05:38,860
여기에 직관적 인 테이크 아웃이있다.

1375
01:05:38,860 --> 01:05:41,410
그 또는 그녀는 단지 공간을 낭비한다.

1376
01:05:41,410 --> 01:05:44,790
환언하면,이 거기
프로그래밍에서 흔히 트레이드 오프

1377
01:05:44,790 --> 01:05:48,241
당신도 할당 할 수있는
정확하게 많은 메모리 당신이 원하는대로,

1378
01:05:48,241 --> 01:05:51,490
의 상승은 슈퍼 걸이다
efficient-- 당신은 낭비되지 않는 것

1379
01:05:51,490 --> 01:05:54,640
에서 all-- 만의 단점
무엇 당신은 당신의 마음 때를 변경하는 경우

1380
01:05:54,640 --> 01:05:58,780
저장하려는 프로그램을 사용하여
당신보다 더 많은 데이터가 원래 의도.

1381
01:05:58,780 --> 01:06:03,030
>> 그래서 어쩌면 용액 후이며
이와 같은 방법으로 프로그램을 작성

1382
01:06:03,030 --> 01:06:05,605
그들은 더 많은 메모리를 사용하는 것이
그들은 실제로 필요한 것보다.

1383
01:06:05,605 --> 01:06:07,730
당신은하지 않을거야 이런 식으로
그 문제로 실행하려면,

1384
01:06:07,730 --> 01:06:09,730
하지만 당신은 낭비되고 있습니다.

1385
01:06:09,730 --> 01:06:12,960
그리고 프로그램이 사용하는 메모리,
우리는 어제 한 바와 같이, 이하

1386
01:06:12,960 --> 01:06:15,410
가능한 메모리
다른 프로그램,

1387
01:06:15,410 --> 01:06:18,790
빨리 컴퓨터가 느려질 수 있습니다
아래로 인해 가상 메모리.

1388
01:06:18,790 --> 01:06:22,670
그래서 이상적인 솔루션은 무엇을 할 수 있는가?

1389
01:06:22,670 --> 01:06:24,610
>> 에서 할당하는 나쁜 것 같다.

1390
01:06:24,610 --> 01:06:27,030
오버 할당하는 나쁜 것 같다.

1391
01:06:27,030 --> 01:06:31,120
그래서 더 나은 해결책이 될 수 있는가?

1392
01:06:31,120 --> 01:06:32,390
재 할당.

1393
01:06:32,390 --> 01:06:33,590
보다 역동적합니다.

1394
01:06:33,590 --> 01:06:37,520
을 선택하는 자신을 강요하지 마십시오
사전은, 처음에, 당신은 무엇을 할 수 있습니다.

1395
01:06:37,520 --> 01:06:41,370
그리고 확실히, 과다 할당하지 않습니다
당신 않도록 낭비.

1396
01:06:41,370 --> 01:06:45,770
>> 그리고 그 목표를 달성하기 위해, 우리
이 데이터 구조를 던질 필요가있다,

1397
01:06:45,770 --> 01:06:48,100
그래서 멀리, 말을합니다.

1398
01:06:48,100 --> 01:06:51,080
그래서 어떤 프로그래머
일반적으로 사용합니다

1399
01:06:51,080 --> 01:06:55,940
아닌 뭔가라고
배열하지만,​​ 연결리스트.

1400
01:06:55,940 --> 01:07:00,860
환언하면, 그 또는 그녀는 것
자신의 메모리를 생각하기 시작

1401
01:07:00,860 --> 01:07:05,280
모양의있는 일종의 그들이
다음과 같은 방법으로 그릴 수 있습니다.

1402
01:07:05,280 --> 01:07:08,520
나는 하나의 번호를 저장하려면
그것은 9 월 있도록 program--,

1403
01:07:08,520 --> 01:07:12,600
나는 학생들에게 퀴즈를 준; 내가 원하는
학생들의 첫 번째 퀴즈를 저장,

1404
01:07:12,600 --> 01:07:16,220
그들은 그건 ... I에 100있어
내 컴퓨터를 요청할 예정이다,

1405
01:07:16,220 --> 01:07:19,540
나는했습니다 프로그램의 방법으로
메모리의 청크에 대한 서면.

1406
01:07:19,540 --> 01:07:22,570
그리고 나는를 저장하는거야
거기에 번호 100, 그게입니다.

1407
01:07:22,570 --> 01:07:24,820
>> 그리고 몇 주 후
내 두 번째 퀴즈를 얻을 때,

1408
01:07:24,820 --> 01:07:27,890
그리고 입력하는 시간
그 90 %에, 내가 갈거야

1409
01:07:27,890 --> 01:07:32,129
컴퓨터를 물어, 헤이, 컴퓨터,
나는 메모리의 다른 청크를 가질 수있다?

1410
01:07:32,129 --> 01:07:34,170
나에게이 줄거야
메모리의 빈 덩어리.

1411
01:07:34,170 --> 01:07:39,370
나는 숫자 90에 넣어거야
하지만 내 프로그램에 어떻게 든 또는 다른 것이라면

1412
01:07:39,370 --> 01:07:42,100
우리는 걱정하지 않습니다
내가 필요로하는이 항아리에 대한 구문

1413
01:07:42,100 --> 01:07:44,430
어떻게 든에 함께이 일을 체인.

1414
01:07:44,430 --> 01:07:47,430
그리고 함께 그들을 체인 것
무슨 일이 여기에 화살처럼 보인다.

1415
01:07:47,430 --> 01:07:50,050
>> 온다 세 번째 퀴즈,
내가 말할거야, 이봐, 컴퓨터,

1416
01:07:50,050 --> 01:07:51,680
나에게 메모리의 다른 청크를 제공합니다.

1417
01:07:51,680 --> 01:07:54,660
내가 내려 갈거야
어떤 것은 75와 마찬가지로했다

1418
01:07:54,660 --> 01:07:56,920
나는 체인이에있다
함께 지금 어떻게 든.

1419
01:07:56,920 --> 01:08:00,290
네 번째 퀴즈는 따라오고, 어쩌면
그 학기의 끝을 향해입니다.

1420
01:08:00,290 --> 01:08:03,140
그리고 그 때 내 프로그램에 의해
메모리를 사용 될 수 있습니다

1421
01:08:03,140 --> 01:08:05,540
도처에, 모든 물리적으로 이상.

1422
01:08:05,540 --> 01:08:08,170
그래서 그냥 재미로 들어 난
이 규정 그릴 예정

1423
01:08:08,170 --> 01:08:11,260
quiz-- 나는 그것이 무엇인지 잊어; 나는
어쩌면 생각 80 또는 뭔가 ...

1424
01:08:11,260 --> 01:08:12,500
방법을 통해 여기에.

1425
01:08:12,500 --> 01:08:15,920
>> 하지만 그 때문에 그림으로, 괜찮아요
나는이 선을 그릴거야.

1426
01:08:15,920 --> 01:08:19,063
즉, 실제로
컴퓨터의 하드웨어,

1427
01:08:19,063 --> 01:08:20,979
첫 번째 점수 수도
그것 때문에 여기까지

1428
01:08:20,979 --> 01:08:22,529
바로 학기의 시작.

1429
01:08:22,529 --> 01:08:25,810
다음 하나는 여기에 끝낼 수 있습니다
약간의 시간이 경과했기 때문에

1430
01:08:25,810 --> 01:08:27,210
프로그램 실행 유지합니다.

1431
01:08:27,210 --> 01:08:30,060
이었다 다음 점수,
75는 여기에있을 수 있습니다.

1432
01:08:30,060 --> 01:08:33,420
그리고 마지막 점수 수 있습니다
여기있는 80.

1433
01:08:33,420 --> 01:08:38,729
>> 그래서 현실에서, 물리적,이있을 수 있습니다
어떤 컴퓨터의 메모리는 것 같습니다.

1434
01:08:38,729 --> 01:08:41,569
그러나 유용한 정신 아니다
컴퓨터 프로그래머를위한 패러다임.

1435
01:08:41,569 --> 01:08:44,649
왜 당신이 어디에 관심을 가져야
도대체 데이터가 끝나는입니까?

1436
01:08:44,649 --> 01:08:46,200
당신은 데이터를 저장할.

1437
01:08:46,200 --> 01:08:49,390
>> 이것은 우리의 토론과 같은 종류의 것입니다
큐브를 그리기 이전.

1438
01:08:49,390 --> 01:08:52,200
왜 상관이야 무엇
각도 큐브 인

1439
01:08:52,200 --> 01:08:53,740
어떻게 당신은 그것을 그릴 설정해야?

1440
01:08:53,740 --> 01:08:54,950
당신은 큐브를 할 수 있습니다.

1441
01:08:54,950 --> 01:08:57,359
마찬가지로 여기, 당신을
단지 학년 책합니다.

1442
01:08:57,359 --> 01:08:59,559
당신은 생각 할
번호의 목록 등이.

1443
01:08:59,559 --> 01:09:01,350
그것의 방법을 누가 관심
하드웨어로 구현?

1444
01:09:01,350 --> 01:09:05,180
>> 이제 추상화 그래서
여기이 사진입니다.

1445
01:09:05,180 --> 01:09:07,580
이 같이 목록에서 연결된한다
프로그래머는 부를 것이다,

1446
01:09:07,580 --> 01:09:10,640
당신은이하는 한
목록, 분명 번호.

1447
01:09:10,640 --> 01:09:14,990
그러나 그림으로 연결되어있어
이 화살표의 방법으로,

1448
01:09:14,990 --> 01:09:18,510
이 모든 화살표가 아래으로 죠
후드, 당신은 호기심이 있다면,

1449
01:09:18,510 --> 01:09:23,210
우리의 물리적 하드웨어가 가지고있는 기억
주소는 하나, 둘, 셋, 넷 제로.

1450
01:09:23,210 --> 01:09:28,465
이러한 모든 화살표는지도처럼
또는 방향의 경우 90 is-- 지금

1451
01:09:28,465 --> 01:09:29,090
나는 계산되었다.

1452
01:09:29,090 --> 01:09:31,750
>> 제로, 하나, 둘, 셋,
넷, 다섯, 여섯, 일곱.

1453
01:09:31,750 --> 01:09:35,640
90가에있을 것 같습니다
메모리 주소 번호 일곱.

1454
01:09:35,640 --> 01:09:38,460
이러한 모든 화살표는있다
종이의 작은 스크랩 등

1455
01:09:38,460 --> 01:09:42,439
그것은에 방향을주고
이지도를 따라 말한다 프로그램

1456
01:09:42,439 --> 01:09:43,880
위치 일곱에 도착합니다.

1457
01:09:43,880 --> 01:09:46,680
그리고 거기 당신은 찾을 수
학생의 두 번째 퀴즈 점수.

1458
01:09:46,680 --> 01:09:52,100
한편, 75-- 나는 이것을 계속하면,
이 일곱, 여덟, 아홉, 열, 11, 12,

1459
01:09:52,100 --> 01:09:54,240
13, 14, 15.

1460
01:09:54,240 --> 01:09:59,080
>> 이 다른 화살표는 나타냅니다
메모리 위치 (15)에 대한지도.

1461
01:09:59,080 --> 01:10:02,550
그러나 다시, 프로그래머는 일반적으로 수행
세부 사항이 수준에 대해 걱정하지.

1462
01:10:02,550 --> 01:10:05,530
그리고 대부분의 모든 프로그래밍
언어 오늘, 프로그래머

1463
01:10:05,530 --> 01:10:10,490
경우에도 메모리에 알 수 없습니다
이 숫자는 사실이다.

1464
01:10:10,490 --> 01:10:14,830
그 또는 그녀가이 모든 약 한 관심
그들은 어떻게 든 서로 연결되어 있음

1465
01:10:14,830 --> 01:10:18,390
이와 같은 데이터 구조이다.

1466
01:10:18,390 --> 01:10:21,580
>> 그러나 그렇지 밝혀
너무 기술적 얻을 수 있습니다.

1467
01:10:21,580 --> 01:10:27,430
그냥 있기 때문에 우리는 아마도 수
여기 토론을 할 여유,

1468
01:10:27,430 --> 01:10:33,630
우리가 방문한다고 가정
여기에 배열의이 문제.

1469
01:10:33,630 --> 01:10:35,780
우리가 여기가는 후회하는 경우 보자.

1470
01:10:35,780 --> 01:10:42,950
이것은 100, 90, 75, 80이다.

1471
01:10:42,950 --> 01:10:44,980
>> 내가 간단히 이러한 주장을 만들어 보자.

1472
01:10:44,980 --> 01:10:48,980
이 배열하고, 다시,
배열의 두드러진 특징

1473
01:10:48,980 --> 01:10:52,400
모든 데이터는 다시 있다는
다시 말 그대로 me​​mory--에 백업 할

1474
01:10:52,400 --> 01:10:56,830
한 바이트 또는 어쩌면 4 바이트,
멀리 바이트의 몇 가지 고정 된 수의.

1475
01:10:56,830 --> 01:11:00,710
링크 된 목록에서, 우리는 그릴 수있는
이 같은 후드 아래에있는 사람

1476
01:11:00,710 --> 01:11:02,000
그 물건이 어디 있는지 아는 사람?

1477
01:11:02,000 --> 01:11:03,630
심지어이 같은 흐름 필요가 없습니다.

1478
01:11:03,630 --> 01:11:06,050
데이터의 일부가 될 수있다
다시는 거기에서 왼쪽으로.

1479
01:11:06,050 --> 01:11:07,530
당신은 몰라.

1480
01:11:07,530 --> 01:11:15,430
>> 그래서 배열과 함께, 당신은이
랜덤 액세스로 알려진 기능입니다.

1481
01:11:15,430 --> 01:11:20,570
그리고 무엇 랜덤 액세스 수단 것은
컴퓨터가 즉시 이동할 수 있음

1482
01:11:20,570 --> 01:11:22,730
배열의 모든 위치.

1483
01:11:22,730 --> 01:11:23,580
왜?

1484
01:11:23,580 --> 01:11:26,000
컴퓨터가 알고 있기 때문에
첫 번째 위치는 그

1485
01:11:26,000 --> 01:11:29,540
영, 하나, 둘, 3.

1486
01:11:29,540 --> 01:11:33,890
>> 그래서 당신이에서 가고 싶은 경우
다음 요소로이 요소,

1487
01:11:33,890 --> 01:11:36,099
당신 그대로의
컴퓨터의 마음은 하나를 추가합니다.

1488
01:11:36,099 --> 01:11:39,140
세 번째 요소로 이동하려면,
그냥, 다음 요소 one-- 추가

1489
01:11:39,140 --> 01:11:40,290
하나를 추가 할 수 있습니다.

1490
01:11:40,290 --> 01:11:42,980
그러나이 버전의
이야기의, 가정

1491
01:11:42,980 --> 01:11:46,080
컴퓨터가 현재 찾고
이나 수 (100)를 처리.

1492
01:11:46,080 --> 01:11:49,770
어떻게 당신이 다음에 어떻게해야합니까
학년 책에 등급?

1493
01:11:49,770 --> 01:11:52,560
>> 당신은 칠을해야
임의 단계.

1494
01:11:52,560 --> 01:11:58,120
다음 단계로 얻으려면, 당신은에 있습니다
(15)에 도착하는 또 다른 팔 조치를 취합니다.

1495
01:11:58,120 --> 01:12:02,250
즉,이 아니다
숫자 사이에 일정한 갭

1496
01:12:02,250 --> 01:12:04,857
그래서 그냥 소요
컴퓨터에 더 많은 시간이 포인트입니다.

1497
01:12:04,857 --> 01:12:06,940
컴퓨터가 검색 할 수있다
위해 메모리를 통해

1498
01:12:06,940 --> 01:12:08,990
당신이 찾고있는 것을 찾을 수 있습니다.

1499
01:12:08,990 --> 01:12:14,260
>> 배열이 될 경향이있는 반면 그래서
빠른 데이터 structure-- 당신 때문에

1500
01:12:14,260 --> 01:12:17,610
말 그대로 단순한 연산을 수행 할 수 있습니다
하나를 추가하여 원하는 위치를 얻을,

1501
01:12:17,610 --> 01:12:21,300
링크 된 목록을 instance--를 들어,
해당 기능을 희생.

1502
01:12:21,300 --> 01:12:24,020
당신은 처음부터 갈 수 없어
두 번째 세 번째에에 네 번째이다.

1503
01:12:24,020 --> 01:12:25,240
당신은지도를 수행해야합니다.

1504
01:12:25,240 --> 01:12:28,160
당신은 더 많은 조치를 취할 필요가
그 값을 얻을 수있는

1505
01:12:28,160 --> 01:12:30,230
비용을 추가로 보인다.

1506
01:12:30,230 --> 01:12:35,910
그래서 우리는 가격을 지불하지만, 무엇 이었습니까하고
단 여기서 추구하는 것을 특징?

1507
01:12:35,910 --> 01:12:38,110
무엇 링크 된 목록을 수행
분명히 우리가 할 수 있도록,

1508
01:12:38,110 --> 01:12:40,240
어떤의 기원이었다
이 특별한 이야기​​?

1509
01:12:40,240 --> 01:12:43,250

1510
01:12:43,250 --> 01:12:43,830
>> 정확하게.

1511
01:12:43,830 --> 01:12:46,220
그것을 동적 크기입니다.

1512
01:12:46,220 --> 01:12:48,040
우리는이 목록에 추가 할 수 있습니다.

1513
01:12:48,040 --> 01:12:51,430
우리는 심지어 그래서 목록을 축소 할 수 있습니다
우리는 많은 메모리를 사용하고 있는지

1514
01:12:51,430 --> 01:12:55,560
우리가 실제로 원하는 등
우리는 과도하게 할당하는 적이있어 없습니다.

1515
01:12:55,560 --> 01:12:58,470
>> 지금 바로, 정말 NIT-까다 롭고 될 수 있습니다
숨겨진 비용이있다.

1516
01:12:58,470 --> 01:13:01,980
그래서 당신은 나를 설득 못하게한다
당신이 강제적 절충된다.

1517
01:13:01,980 --> 01:13:04,190
여기에 또 다른 숨겨진 비용이있다.

1518
01:13:04,190 --> 01:13:06,550
이점은 명확합니다
우리가 활력을 얻을 것입니다.

1519
01:13:06,550 --> 01:13:10,359
나는 다른 요소를 원하는 경우에, 난 그냥 수
그것은을 그리고 거기에 숫자를 넣어.

1520
01:13:10,359 --> 01:13:12,150
그리고 나는 그것을 연결할 수 있습니다
여기에 사진과 함께,

1521
01:13:12,150 --> 01:13:14,970
여기 반면, 다시, 나는했습니다 경우
, 구석으로 자신을 그린

1522
01:13:14,970 --> 01:13:19,410
뭔가가 이미 사용하고있는 경우
여기에 메모리, I는 운입니다.

1523
01:13:19,410 --> 01:13:21,700
나는 구석으로 자신을 그린했습니다.

1524
01:13:21,700 --> 01:13:24,390
>> 그러나 숨겨진을 무엇
이 그림에서 비용?

1525
01:13:24,390 --> 01:13:27,690
그것은 단지 양이 아니다
걸리는 시간

1526
01:13:27,690 --> 01:13:29,870
여기에 여기에서 이동합니다,
이는 다음, 일곱 단계입니다

1527
01:13:29,870 --> 01:13:32,820
이상입니다 여덟 단계.

1528
01:13:32,820 --> 01:13:34,830
또 다른 숨겨진 비용은 무엇입니까?

1529
01:13:34,830 --> 01:13:35,440
다만 시간.

1530
01:13:35,440 --> 01:13:44,790

1531
01:13:44,790 --> 01:13:49,940
추가 정보는
필요한이 사진을 달성했다.

1532
01:13:49,940 --> 01:13:53,210
>> 그래,지도,의 그 작은 조각
종이, 내가 그들을 설명하는 유지로.

1533
01:13:53,210 --> 01:13:55,650
그 arrows--이 무료하지 않습니다.

1534
01:13:55,650 --> 01:13:57,660
당신이 알고있는 computer--
컴퓨터는 무슨.

1535
01:13:57,660 --> 01:13:58,790
그것은 0과 1을 보유하고 있습니다.

1536
01:13:58,790 --> 01:14:03,170
당신은 화살표 또는를 표현하려면
지도 또는 숫자, 당신은 일부 메모리가 필요합니다.

1537
01:14:03,170 --> 01:14:05,950
다른 가격 그래서
링크 된 목록을 지불,

1538
01:14:05,950 --> 01:14:09,070
일반적인 컴퓨터 과학
자원은 또한 공간이다.

1539
01:14:09,070 --> 01:14:11,710
>> 그리고 실제로 그렇게 때문에 일반적으로,
장단점 중

1540
01:14:11,710 --> 01:14:15,580
소프트웨어 공학 설계에
시스템 시간이다 space--

1541
01:14:15,580 --> 01:14:18,596
당신의 재료의 두 ​​개의
가장 비용이 많이 드는 재료.

1542
01:14:18,596 --> 01:14:21,220
이것은 나에게 더 많은 시간을 원가 계산된다
나는이지도를 수행해야하기 때문에,

1543
01:14:21,220 --> 01:14:25,730
그러나 그것은 또한 나에게 더 많은 공간을 비용 것
나는이지도를 계속해야하기 때문이다.

1544
01:14:25,730 --> 01:14:28,730
그래서 희망으로 우리는 가지했습니다
어제와 오늘에 걸쳐 논의,

1545
01:14:28,730 --> 01:14:31,720
이점이다
비용을보다 중요한 것입니다.

1546
01:14:31,720 --> 01:14:33,870
>> 그러나 여기에는 확실한 해결책은 없습니다.

1547
01:14:33,870 --> 01:14:35,870
아마 better--입니다
라 신속하고 더러운,

1548
01:14:35,870 --> 01:14:38,660
카림은 earlier-- 제안으로
문제의 메모리를 던져.

1549
01:14:38,660 --> 01:14:42,520
그냥 더 많은 메모리를 구입, 덜 생각
문제 해결에 대한 하드,

1550
01:14:42,520 --> 01:14:44,595
하고 쉬운 방법으로 그것을 해결.

1551
01:14:44,595 --> 01:14:46,720
그리고 실제로 이전 할 때
우리는 장단점에 대해 이야기,

1552
01:14:46,720 --> 01:14:49,190
그것은 공간이 아니었다
컴퓨터 및 시간입니다.

1553
01:14:49,190 --> 01:14:51,810
그것은 개발자의 시간이었다
또 다른 자원이다.

1554
01:14:51,810 --> 01:14:54,829
>> 그래서 다시,이 조정 행위이다
결정하려고 그런 일이있는

1555
01:14:54,829 --> 01:14:55,870
당신이 지출 할 수 있습니까?

1556
01:14:55,870 --> 01:14:57,380
가장 저렴한는 무엇입니까?

1557
01:14:57,380 --> 01:15:01,040
어느 것이 더 나은 결과를 얻을?

1558
01:15:01,040 --> 01:15:01,540
네?

1559
01:15:01,540 --> 01:15:11,310

1560
01:15:11,310 --> 01:15:12,580
>> 과연.

1561
01:15:12,580 --> 01:15:15,970
이 경우라면
maps--의 숫자를 나타내는

1562
01:15:15,970 --> 01:15:18,820
이러한 많은 언어라고합니다
"포인터"또는 "주소"-

1563
01:15:18,820 --> 01:15:20,390
이 두 공간입니다.

1564
01:15:20,390 --> 01:15:24,390
그 경우 이중으로 나쁜 일 필요는 없다
지금 우리는 단지 숫자를 저장하고 있습니다.

1565
01:15:24,390 --> 01:15:27,410
우리가 저장되었다고 가정하자
hospital--에서 환자 기록

1566
01:15:27,410 --> 01:15:30,870
피어슨의 이름, 전화 번호 때문에,
사회 보장 번호, 의사

1567
01:15:30,870 --> 01:15:31,540
역사.

1568
01:15:31,540 --> 01:15:34,160
이 상자는, 많은 수 있습니다
훨씬 더 큰 경우에

1569
01:15:34,160 --> 01:15:38,000
작은 작은 포인터의 주소
다음은 큰 문제가 아니다 element--.

1570
01:15:38,000 --> 01:15:40,620
그러한 프린지의
그것은 중요하지 않습니다 비용.

1571
01:15:40,620 --> 01:15:43,210
그러나이 경우, 그래, 그것은 두 배입니다.

1572
01:15:43,210 --> 01:15:45,290
좋은 질문.

1573
01:15:45,290 --> 01:15:47,900
>> 의 시간 a를 이야기하자
보다 구체적으로 조금.

1574
01:15:47,900 --> 01:15:50,380
실행 시간 무엇입니까
이 목록을 검색하는?

1575
01:15:50,380 --> 01:15:53,640
내가 검색을 원 가정
모든 학생들의 성적을 통해,

1576
01:15:53,640 --> 01:15:55,980
n은 성적을 거기에
데이터 구조이다.

1577
01:15:55,980 --> 01:15:58,830
여기에서도 우리는 빌릴 수
이전의 어휘.

1578
01:15:58,830 --> 01:16:00,890
이것은 선형 데이터 구조이다.

1579
01:16:00,890 --> 01:16:04,570
>> (n)의 빅 O를 얻을 필요가있는 무슨이다
데이터 구조의 끝,

1580
01:16:04,570 --> 01:16:08,410
whereas-- 우리는 보지 못했어요
이 배열을 제공 before--

1581
01:16:08,410 --> 01:16:13,555
무엇을 의미하는 일정 시간이라고
한 단계 또는 두 단계 또는 10 steps--

1582
01:16:13,555 --> 01:16:14,180
중요하지 않습니다.

1583
01:16:14,180 --> 01:16:15,440
그것은 고정 된 수 있습니다.

1584
01:16:15,440 --> 01:16:17,440
그것은 함께 할 수 없다
배열 크기.

1585
01:16:17,440 --> 01:16:20,130
그리고 그 이유,
또, 랜덤 액세스이다.

1586
01:16:20,130 --> 01:16:23,180
컴퓨터 수 단지 바로
다른 위치로 이동,

1587
01:16:23,180 --> 01:16:27,770
그들은 모두 같은이기 때문에
다른 모든 것들로부터 거리.

1588
01:16:27,770 --> 01:16:29,112
반군 생각은 없습니다.

1589
01:16:29,112 --> 01:16:31,900

1590
01:16:31,900 --> 01:16:32,400
괜찮아.

1591
01:16:32,400 --> 01:16:39,230
내가 할 수있는 경우에 그래서, 내가하려고하자
이 마지막 사진을 페인트.

1592
01:16:39,230 --> 01:16:42,830
해시 테이블로 알려진 매우 일반적인 일.

1593
01:16:42,830 --> 01:16:51,120
그래서이 토론 동기를 부여하고,
내가이 작업을 수행하는 방법에 대해 생각해 보자.

1594
01:16:51,120 --> 01:16:52,610
>> 그래서 방법에 대해?

1595
01:16:52,610 --> 01:16:55,160
문제가 있다고 가정
우리는 지금 해결하려는

1596
01:16:55,160 --> 01:16:58,360
dictionary--에서 구현된다
영어 단어 때문에 전체 무리

1597
01:16:58,360 --> 01:16:59,330
또는 무엇 이건.

1598
01:16:59,330 --> 01:17:02,724
그리고 목표는 대답 할 수있을 것입니다
형태의 질문이있는 단어입니다?

1599
01:17:02,724 --> 01:17:04,640
그래서 당신이 구현하려는
맞춤법 검사기, 단지

1600
01:17:04,640 --> 01:17:07,220
물리적 사전 등
당신이 물건을 검색 할 수.

1601
01:17:07,220 --> 01:17:10,490
내가 배열이 작업을 수행하는 가정하자.

1602
01:17:10,490 --> 01:17:12,590
나는이 작업을 수행 할 수 있습니다.

1603
01:17:12,590 --> 01:17:20,756
>> 그리고 단어가 사과입니다 가정
바나나와 멜론.

1604
01:17:20,756 --> 01:17:23,330

1605
01:17:23,330 --> 01:17:26,465
그리고 나는 과일 생각할 수 없다
즉, D로 시작하는, 그래서 우리는 그냥있어

1606
01:17:26,465 --> 01:17:27,590
세 가지 과일을해야 할 것.

1607
01:17:27,590 --> 01:17:31,510
그래서이 배열이며, 우리는있어
이 모든 단어를 저장

1608
01:17:31,510 --> 01:17:34,200
배열 등이 사전입니다.

1609
01:17:34,200 --> 01:17:39,350
문제는, 그 후, 다른 방법 인
이 정보를 저장할 수 있을까?

1610
01:17:39,350 --> 01:17:43,160
>> 글쎄, 난 가지 있기 때문에, 여기에 바람을 피우고있어
단어 이러한 문자의 각

1611
01:17:43,160 --> 01:17:44,490
정말 개인 바이트입니다.

1612
01:17:44,490 --> 01:17:46,740
그래서 내가 정말되고 싶어하는 경우
알 - 까다 롭고, 정말해야

1613
01:17:46,740 --> 01:17:49,600
많은이 점을 나누어 할 수
메모리의 작은 덩어​​리,

1614
01:17:49,600 --> 01:17:51,289
우리는 정확하게 할 수 있습니다.

1615
01:17:51,289 --> 01:17:53,580
그러나 우리는로 실행거야
이전과 같은 문제.

1616
01:17:53,580 --> 01:17:56,674
뭐, 만약 메리 엄 웹스터 또는 옥스포드 등
모든 그들이 단어를 추가 연도 - 않습니다

1617
01:17:56,674 --> 01:17:59,340
dictionary--에 우리는하지 않습니다
반드시 자신을 페인트 할

1618
01:17:59,340 --> 01:18:00,780
배열 함께 한 구석에?

1619
01:18:00,780 --> 01:18:05,710
>> 그래서 그 대신, 어쩌면 현명한 방법
자신의 노드 또는 상자에 사과를 넣어하는 것입니다,

1620
01:18:05,710 --> 01:18:11,190
우리가 말할 것 같은, 바나나,과
여기에 우리는 멜론이 있습니다.

1621
01:18:11,190 --> 01:18:14,990

1622
01:18:14,990 --> 01:18:16,790
이러한 것들을 함께 그리고 우리 문자열입니다.

1623
01:18:16,790 --> 01:18:19,980
그래서 배열이고,
이 링크 된 목록입니다.

1624
01:18:19,980 --> 01:18:23,300
당신은 매우 볼 수없는 경우, 단지
말한다 "배열"이 말한다 "목록을."

1625
01:18:23,300 --> 01:18:25,780
>> 그래서 우리는 같은이
이전과 정확한 문제,

1626
01:18:25,780 --> 01:18:28,600
이에 우리가 지금해야
우리의 연결리스트의 역 동성.

1627
01:18:28,600 --> 01:18:31,090
그러나 우리는 상당히 느린 사전을 가지고있다.

1628
01:18:31,090 --> 01:18:32,870
나는 단어를 검색한다고 가정.

1629
01:18:32,870 --> 01:18:35,430
그것은 나에게 (n)의 큰 O 걸릴 수 있습니다
단계, 단어 수 있기 때문에

1630
01:18:35,430 --> 01:18:37,840
끝에서 끝까지 될
멜론 같은 목록.

1631
01:18:37,840 --> 01:18:40,600
그리고 그것은 밝혀
프로그래밍 정렬

1632
01:18:40,600 --> 01:18:42,700
데이터의 성배의
구조, 뭔가

1633
01:18:42,700 --> 01:18:46,620
그건 당신이 상수 제공
배열과 같은 시간

1634
01:18:46,620 --> 01:18:50,870
하지만 여전히 당신에게 활력을 제공합니다.

1635
01:18:50,870 --> 01:18:52,940
>> 그래서 우리는 두 세계의 최고를 가질 수있다?

1636
01:18:52,940 --> 01:18:55,570
그리고 실제로 뭔가가있다
해시 테이블이라고

1637
01:18:55,570 --> 01:18:59,320
그건 당신이 정확하게 수행 할 수 있습니다
이기는하지만 약, 그.

1638
01:18:59,320 --> 01:19:03,140
해시 테이블은 애호가입니다
데이터 구조가 우리

1639
01:19:03,140 --> 01:19:06,340
로 생각할 수 있습니다
array--의 조합

1640
01:19:06,340 --> 01:19:12,390
나는 그것을 그릴거야
이 항아리와 연결리스트 등

1641
01:19:12,390 --> 01:19:17,310
나는 여기에 다음과 같이 그릴거야.

1642
01:19:17,310 --> 01:19:19,760
>> 이 일 그리고 방법
다음과 같은 작품이다.

1643
01:19:19,760 --> 01:19:23,310

1644
01:19:23,310 --> 01:19:29,540
이 table-- 해시 now-- 경우
제 3 데이터 구조이며,

1645
01:19:29,540 --> 01:19:32,590
나는 저장할
이 단어, 난 몰라

1646
01:19:32,590 --> 01:19:35,440
그냥 모두를 저장할
말은 다시 다시 다시 다시합니다.

1647
01:19:35,440 --> 01:19:37,430
나는 몇 가지를 활용하려면
정보의 조각

1648
01:19:37,430 --> 01:19:40,330
드릴 것입니다 단어에 대한
더 빨리 어디 내가 그것을 얻을.

1649
01:19:40,330 --> 01:19:43,666
>> 그래서 단어 사과를 부여
바나나, 멜론,

1650
01:19:43,666 --> 01:19:45,040
나는 일부러 그 단어를 선택했다.

1651
01:19:45,040 --> 01:19:45,340
왜?

1652
01:19:45,340 --> 01:19:47,631
무엇의 근본적 일종의
세 가지에 대해 다른?

1653
01:19:47,631 --> 01:19:49,950

1654
01:19:49,950 --> 01:19:51,484
명백한은 무엇입니까?

1655
01:19:51,484 --> 01:19:52,900
그들은 서로 다른 문자로 시작합니다.

1656
01:19:52,900 --> 01:19:53,900
>> 그래서 당신은 무엇인지?

1657
01:19:53,900 --> 01:19:57,120
모든 내 말을 넣어보다는
같은 버킷은, 그래서, 말하자면

1658
01:19:57,120 --> 01:20:00,390
같은 하나의 큰 목록에서 왜하지
나는 적어도 최적화를 시도

1659
01:20:00,390 --> 01:20:04,180
내 목록을 1/26로 긴합니다.

1660
01:20:04,180 --> 01:20:07,440
눈길을 끄는 최적화
하지 않는 이유가 될 수 있습니다

1661
01:20:07,440 --> 01:20:10,650
난 ... 때 단어를 삽입
데이터 구조로,

1662
01:20:10,650 --> 01:20:14,300
컴퓨터의 메모리, 왜에
나는 여기에 모든 '은'단어를 넣어하지 않습니다

1663
01:20:14,300 --> 01:20:17,270
모든 여기에 'B'즉,
여기에 모든 'C'단어?

1664
01:20:17,270 --> 01:20:24,610
그래서이 사과를 넣어 끝
여기, 여기 여기 바나나, 멜론,

1665
01:20:24,610 --> 01:20:25,730
기타 등등.

1666
01:20:25,730 --> 01:20:31,700
>> 그리고 추가로있는 경우
말은 다른 무엇 이렇게 ...?

1667
01:20:31,700 --> 01:20:36,640
사과, 바나나, 배.

1668
01:20:36,640 --> 01:20:39,370
사람은 과일의 생각
즉 A, B 또는 C로 시작?

1669
01:20:39,370 --> 01:20:40,570
Blueberry-- 완벽한.

1670
01:20:40,570 --> 01:20:43,990
즉, 여기에 끝날 것입니다.

1671
01:20:43,990 --> 01:20:47,530
그래서 우리는 것 같다
소폭 더 나은 솔루션,

1672
01:20:47,530 --> 01:20:50,820
지금 내가 원하는 경우 때문에
사과를 검색하려면, I

1673
01:20:50,820 --> 01:20:53,200
first-- 난 그냥 다이빙을하지 않습니다
내 데이터 구조로.

1674
01:20:53,200 --> 01:20:54,850
내 컴퓨터의 메모리에 뛰어하지 않습니다.

1675
01:20:54,850 --> 01:20:56,530
내가 먼저 첫 글자를 봐주세요.

1676
01:20:56,530 --> 01:20:58,610
>> 그리고 이것은 어떤 컴퓨터입니다
과학자는 말할 것입니다.

1677
01:20:58,610 --> 01:21:00,760
당신은 당신의 데이터 구조로 해시.

1678
01:21:00,760 --> 01:21:04,100
당신은 당신의 입력에 걸릴
이 경우는 사과와 같은 단어입니다.

1679
01:21:04,100 --> 01:21:07,150
당신은보고, 그것을 분석
이 경우 첫 글자,

1680
01:21:07,150 --> 01:21:08,340
따라서 그것을 해시.

1681
01:21:08,340 --> 01:21:10,950
해싱은 일반적인 용어된다이다
당신은 입력으로 뭔가를 취할

1682
01:21:10,950 --> 01:21:12,116
당신은 몇 가지 출력을 생성합니다.

1683
01:21:12,116 --> 01:21:15,090
그리고에서 출력
경우는 위치입니다

1684
01:21:15,090 --> 01:21:18,150
만약 제를 검색 할
위치, 두 번째 위치, 세 번째.

1685
01:21:18,150 --> 01:21:22,160
그래서 입력 사과입니다,
출력은 처음이다.

1686
01:21:22,160 --> 01:21:25,054
입력은 바나나의입니다
출력은 두 번째 있어야합니다.

1687
01:21:25,054 --> 01:21:27,220
입력은, 멜론입니다
출력은 세 번째해야한다.

1688
01:21:27,220 --> 01:21:30,320
입력은 베리이며
출력은 다시 두 번째 있어야합니다.

1689
01:21:30,320 --> 01:21:34,010
그리고 당신이 걸릴 수 있습니다 무엇
당신의 기억을 통해 바로 가기

1690
01:21:34,010 --> 01:21:39,050
단어에 도착하기 위해
또는 데이터를보다 효율적으로.

1691
01:21:39,050 --> 01:21:43,330
>> 지금 이것은 잠재적으로 우리의 시간을 줄인다
많은 26 중 하나에 의해,

1692
01:21:43,330 --> 01:21:45,850
당신이 가정한다면 당신 때문에 그
"Z"많은 "에"단어가

1693
01:21:45,850 --> 01:21:48,080
"Q"단어와 같은 단어한다
정말 realistic--되지 않습니다

1694
01:21:48,080 --> 01:21:50,830
당신은에 걸쳐 왜곡을 할거야
alphabet--의 특정 문자

1695
01:21:50,830 --> 01:21:53,204
하지만이 증가 될 것
수 않는 방법

1696
01:21:53,204 --> 01:21:55,930
당신은 훨씬 빠르게 단어를 얻을 수 있습니다.

1697
01:21:55,930 --> 01:21:59,660
그리고 현실에서, 정교한
프로그램, 세계의 구글,

1698
01:21:59,660 --> 01:22:02,180
을 전 세계의 Facebooks
이들은 해시 테이블을 사용

1699
01:22:02,180 --> 01:22:03,740
다른 목적을 많이합니다.

1700
01:22:03,740 --> 01:22:06,590
그러나 그들은 같은 순진되지 않을 것
단지 첫 글자를보고

1701
01:22:06,590 --> 01:22:09,700
사과 또는 바나나 또는
배 또는 멜론,

1702
01:22:09,700 --> 01:22:13,420
당신이 볼 수 있기 때문에
목록은 여전히​​ 긴 얻을 수 있습니다.

1703
01:22:13,420 --> 01:22:17,130
>> 그리고이 여전히 종류의 수 있습니다
의 linear-- 그래서 일종의 느린,

1704
01:22:17,130 --> 01:22:19,980
N의 큰 O와 같은
것을 우리는 앞에서 언급.

1705
01:22:19,980 --> 01:22:25,290
그래서 정말 좋은 해시 테이블 것
그것은 훨씬 더 큰 배열을해야합니다 do--.

1706
01:22:25,290 --> 01:22:28,574
그리고 그것은 훨씬 더를 사용합니다
정교한 해시 함수

1707
01:22:28,574 --> 01:22:30,240
있도록 그냥 보지 않는다 "는."

1708
01:22:30,240 --> 01:22:35,480
어쩌면 그것은 보인다 "는-P-P-1-전자"와
어떻게 든 그 다섯 글자로 변환

1709
01:22:35,480 --> 01:22:38,400
어디 위치에
사과 저장해야합니다.

1710
01:22:38,400 --> 01:22:42,660
우리는 순진 문자 'A'를 사용하는
혼자, 그것은 좋은 간단하기 때문이다.

1711
01:22:42,660 --> 01:22:44,600
>> 그러나 해시 테이블에
결국, 당신은 생각할 수

1712
01:22:44,600 --> 01:22:47,270
의 조합으로서
어레이, 각각의

1713
01:22:47,270 --> 01:22:51,700
그 이상적으로 링크 된 목록을 가지고
가능한 한 짧아야한다.

1714
01:22:51,700 --> 01:22:54,364
그리고 이것은 명백한 해결책이 아니다.

1715
01:22:54,364 --> 01:22:57,280
미세 조정의 사실, 많은
즉, 후드 때 아래에 간다

1716
01:22:57,280 --> 01:22:59,654
이러한 종류의 구현
복잡한 데이터 구조

1717
01:22:59,654 --> 01:23:01,640
오른쪽은 무엇인가
어레이의 길이?

1718
01:23:01,640 --> 01:23:03,250
오른쪽 해시 함수는 무엇인가?

1719
01:23:03,250 --> 01:23:04,830
어떻게 메모리에 물건을 저장합니까?

1720
01:23:04,830 --> 01:23:07,249
>> 하지만 얼마나 빨리 실현
토론 이러한 종류의

1721
01:23:07,249 --> 01:23:10,540
이 종류의 것을, 중 지금까지 에스컬레이션
이 시점에서 하나의 머리 위에있는

1722
01:23:10,540 --> 01:23:11,360
괜찮습니다.

1723
01:23:11,360 --> 01:23:18,820
그러나 우리는 진정으로, 리콜을 시작
뭔가 낮은 수준의 전자.

1724
01:23:18,820 --> 01:23:20,819
그리고 이것은 다시입니다
추상화의 테마,

1725
01:23:20,819 --> 01:23:23,610
어디 걸릴하기 시작하면
부여, OK, 나는 거기에 그건 ...에게있어

1726
01:23:23,610 --> 01:23:26,680
실제 메모리, OK, 모든, 그것을 가지고
물리적 위치는 주소를 가지고

1727
01:23:26,680 --> 01:23:29,910
OK, 그것을 가지고 내가, 내가 표현할 수있다
arrows--으로 해당 주소

1728
01:23:29,910 --> 01:23:34,650
당신은 매우 신속하게 가지고 시작할 수 있습니다
보다 정교한 대화가

1729
01:23:34,650 --> 01:23:38,360
결국 우리를 허용 할 것
검색 같은 문제점을 해결하기 위하여

1730
01:23:38,360 --> 01:23:41,620
보다 효과적으로 정렬.

1731
01:23:41,620 --> 01:23:44,190
그리고, 너무 ... 안심
나는 이것을 생각하기 때문에

1732
01:23:44,190 --> 01:23:48,700
우리는 몇 가지로 갔어요 깊은이다
우리가했습니다 proper--이 CS 주제

1733
01:23:48,700 --> 01:23:51,880
이에서 하루 반에서 수행
당신은 일반적으로 이상 할 수있는 것을 가리 킵니다

1734
01:23:51,880 --> 01:23:55,520
한 학기에 8 주 과정.

1735
01:23:55,520 --> 01:23:59,670
>> 이들에 대한 질문?

1736
01:23:59,670 --> 01:24:01,100
아니?

1737
01:24:01,100 --> 01:24:01,940
괜찮아.

1738
01:24:01,940 --> 01:24:05,610
그럼, 왜 우리가 일시 중지하지 않습니다,
몇 분 일찍 점심을 시작,

1739
01:24:05,610 --> 01:24:07,052
단지 한 시간 정도에 재개?

1740
01:24:07,052 --> 01:24:08,760
그리고 난에 대한 남아 있습니다
질문 좀.

1741
01:24:08,760 --> 01:24:11,343
그럼 내가 가야 할거야
그 확인의 경우 몇 전화를 가져 가라.

1742
01:24:11,343 --> 01:24:15,000
나는 그 동안 어떤 음악을 설정합니다
하지만 점심 모퉁이해야합니다.

1743
01:24:15,000 --> 01:24:17,862

