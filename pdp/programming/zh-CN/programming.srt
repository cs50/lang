1
00:00:00,000 --> 00:00:00,030

2
00:00:00,030 --> 00:00:00,460
>> DAVID MALAN：好的。

3
00:00:00,460 --> 00:00:01,094
我们回来了。

4
00:00:01,094 --> 00:00:04,260
因此，在编程这一部分是什么
我以为我们会做的是一个事物的组合。

5
00:00:04,260 --> 00:00:06,340
一，做一点点
东西动手，

6
00:00:06,340 --> 00:00:08,690
虽然使用的是更好玩
编程environment--

7
00:00:08,690 --> 00:00:11,620
一个是示范的
正是种思路

8
00:00:11,620 --> 00:00:14,220
我们一直在谈论，
而多了几分正式挂牌。

9
00:00:14,220 --> 00:00:18,200
二，看一些
更多的技术途径

10
00:00:18,200 --> 00:00:21,520
一个程序员实际上解决
像搜索问题的问题

11
00:00:21,520 --> 00:00:24,530
我们看了前
也有更根本

12
00:00:24,530 --> 00:00:26,020
排序的有趣的问题。

13
00:00:26,020 --> 00:00:28,840
>> 我们刚刚从一开始走假设
这是电话本进行了排序，

14
00:00:28,840 --> 00:00:31,980
但仅凭这实际上是种
硬问题有许多不同的方式

15
00:00:31,980 --> 00:00:32,479
解决它。

16
00:00:32,479 --> 00:00:34,366
因此，我们将使用这些作为
一类问题

17
00:00:34,366 --> 00:00:36,740
代表性的东西，
可能一般的解决。

18
00:00:36,740 --> 00:00:38,980
然后我们再说吧
大约在一些细节什么

19
00:00:38,980 --> 00:00:42,360
称为数据structures--
奇的方法类似链表

20
00:00:42,360 --> 00:00:46,290
和哈希表和树木
一个程序员实际上

21
00:00:46,290 --> 00:00:48,890
使用一般采用
在白板上画

22
00:00:48,890 --> 00:00:51,840
的画面是什么，他或她
设想用于实施

23
00:00:51,840 --> 00:00:52,980
一些的软件。

24
00:00:52,980 --> 00:00:55,130
>> 因此，让我们做动手部分第一。

25
00:00:55,130 --> 00:01:00,090
因此，只要把你的手脏了
环境调用s​​cratch.mit.edu。

26
00:01:00,090 --> 00:01:02,636
这是我们使用的工具
在我们的本科班。

27
00:01:02,636 --> 00:01:04,510
尽管它的设计
适合12岁及以上，

28
00:01:04,510 --> 00:01:07,570
我们将其用于向上
那相当多的一部分

29
00:01:07,570 --> 00:01:10,020
因为它是一个不错的，好玩的
学习图形化的方式

30
00:01:10,020 --> 00:01:12,160
少了一些有关编程。

31
00:01:12,160 --> 00:01:17,600
让头部的网址，在那里你
应该看到一个页面很喜欢这个，

32
00:01:17,600 --> 00:01:23,330
并直接点击
在右上角加入划痕

33
00:01:23,330 --> 00:01:28,300
并选择一个用户名和
密码并最终让自己

34
00:01:28,300 --> 00:01:29,970
一个account-- scratch.mit.edu。

35
00:01:29,970 --> 00:01:32,165

36
00:01:32,165 --> 00:01:34,665
我以为我会以此为
第一次有机会展示这一点。

37
00:01:34,665 --> 00:01:39,120
一个问题在休息的时候来到了
什么代码实际上样子。

38
00:01:39,120 --> 00:01:41,315
和我们谈话
关于C在休息的时候，

39
00:01:41,315 --> 00:01:45,060
在particular--特别是
在一个较旧的语言较低的水平。

40
00:01:45,060 --> 00:01:47,750
而我只是做了一个快速
谷歌搜索找到的C代码

41
00:01:47,750 --> 00:01:51,574
对于二进制搜索，算法，我们
用于早期的搜索该电话簿。

42
00:01:51,574 --> 00:01:54,240
这个特殊的例子，当然，
不搜索电话簿。

43
00:01:54,240 --> 00:01:57,840
它只是搜索一大堆
号码在计算机的存储器中。

44
00:01:57,840 --> 00:02:01,000
但是，如果你想只得到一个视觉
什么实际的编程意识

45
00:02:01,000 --> 00:02:05,370
语言的样子，看起来
有点像这样。

46
00:02:05,370 --> 00:02:09,759
因此，这20多名，
30左右的行代码，

47
00:02:09,759 --> 00:02:12,640
但我们的谈话
是具有超挖

48
00:02:12,640 --> 00:02:16,000
是有关如何这实际上
被演变成零和一

49
00:02:16,000 --> 00:02:19,200
如果你不能只是说恢复
处理和从零和一去

50
00:02:19,200 --> 00:02:20,210
回代码。

51
00:02:20,210 --> 00:02:22,620
>> 不幸的是，该方法
如此变革

52
00:02:22,620 --> 00:02:24,890
这是一个很多谈何容易。

53
00:02:24,890 --> 00:02:29,400
我说干就干，居然变成
该程序，二进制搜索，

54
00:02:29,400 --> 00:02:32,700
成的一个方式的零和一
程序调用编译器，我

55
00:02:32,700 --> 00:02:34,400
碰巧的权利在这里我的Mac上。

56
00:02:34,400 --> 00:02:37,850
如果你看一下屏幕
在这里，特别是重点

57
00:02:37,850 --> 00:02:43,520
这些中间六列只，
你会看到只有零和的。

58
00:02:43,520 --> 00:02:48,290
而这些都是在零和一的
究竟该组合搜索程序。

59
00:02:48,290 --> 00:02:53,720
>> 等五个位的每个块，
零和一的每个字节在这里，

60
00:02:53,720 --> 00:02:57,310
代表一些指令
通常是计算机的内部。

61
00:02:57,310 --> 00:03:00,730
而事实上，如果你听说过
营销口号“Intel Inside”的 - 即，

62
00:03:00,730 --> 00:03:04,610
当然，只是意味着你有一个
在计算机内部的Intel CPU或大脑。

63
00:03:04,610 --> 00:03:08,000
而这意味着什么是一个CPU是
你有一个指令集，

64
00:03:08,000 --> 00:03:08,840
可以这么说。

65
00:03:08,840 --> 00:03:11,620
>> 世界上每一个CPU，很多
它们由英特尔这些天发，

66
00:03:11,620 --> 00:03:13,690
了解有限
指令数。

67
00:03:13,690 --> 00:03:18,690
而这些指令是如此之低的水平
因为这两个数字加在一起，

68
00:03:18,690 --> 00:03:22,560
乘这两个数字加在一起，
从这里移动这一块的数据

69
00:03:22,560 --> 00:03:27,340
这里在内存中，这种保存
从这里的信息存储器到这里，

70
00:03:27,340 --> 00:03:32,200
所以forth--非常非常
低的水平，几乎电子信息。

71
00:03:32,200 --> 00:03:34,780
但与那些数学
加之操作

72
00:03:34,780 --> 00:03:37,410
与我们前面讨论的，
数据的表示

73
00:03:37,410 --> 00:03:40,450
作为零和的，可
你建立起来的一切

74
00:03:40,450 --> 00:03:44,180
一台计算机今天能做的，无论是
它的文本，图形，音乐，

75
00:03:44,180 --> 00:03:45,580
或以其他方式。

76
00:03:45,580 --> 00:03:49,450
>> 所以这是很容易得到
迷失在快速的杂草。

77
00:03:49,450 --> 00:03:52,150
而且还有很多的
语法挑战

78
00:03:52,150 --> 00:03:56,630
因此，如果你做的最简单，
没有错别字方案的愚蠢

79
00:03:56,630 --> 00:03:57,860
将任何工作。

80
00:03:57,860 --> 00:04:00,366
因此，而不是使用
语言如C今天上午，

81
00:04:00,366 --> 00:04:02,240
我认为这将是
更多的乐趣，真正做到

82
00:04:02,240 --> 00:04:04,840
一些更直观，这
而专为儿童设计

83
00:04:04,840 --> 00:04:08,079
实际上是一个完美的表现
实际编程

84
00:04:08,079 --> 00:04:10,370
language--恰好
使用图片代替文字

85
00:04:10,370 --> 00:04:11,710
代表这些想法。

86
00:04:11,710 --> 00:04:15,470
>> 所以一旦你确实有一个
帐户scratch.mit.edu，

87
00:04:15,470 --> 00:04:21,070
点击创建按钮
在左上方的网站。

88
00:04:21,070 --> 00:04:24,620
你应该看到这样一个环境
一，我要看到我的屏幕上

89
00:04:24,620 --> 00:04:26,310
这里。

90
00:04:26,310 --> 00:04:29,350
我们会花一点点
时间位在这里踢球。

91
00:04:29,350 --> 00:04:34,080
让我们看看，如果我们不能全部解决一些
问题一起以下述方式。

92
00:04:34,080 --> 00:04:39,420
>> 那么，您会在此看到
environment--实际上只是让

93
00:04:39,420 --> 00:04:40,050
我停下来。

94
00:04:40,050 --> 00:04:42,680
有没有人不在这里？

95
00:04:42,680 --> 00:04:45,070
不在这里？

96
00:04:45,070 --> 00:04:45,800
好。

97
00:04:45,800 --> 00:04:49,030
所以让我指出一些
这种环境的特点。

98
00:04:49,030 --> 00:04:55,024
>> 所以在屏幕的左上角，我们
有划痕的舞台，可以这么说。

99
00:04:55,024 --> 00:04:57,440
刮不仅是名称
此编程语言;

100
00:04:57,440 --> 00:05:00,356
这也是猫的名称
您可以通过在橙色默认情况下有看到。

101
00:05:00,356 --> 00:05:02,160
他是在一个阶段，所以
就像我描述

102
00:05:02,160 --> 00:05:05,770
龟作为较早在被
长方形的白板环境。

103
00:05:05,770 --> 00:05:09,800
这种猫的世界完全局限
该矩形向上顶在那里。

104
00:05:09,800 --> 00:05:12,210
>> 同时，在右侧
这里右手边，它的

105
00:05:12,210 --> 00:05:15,610
只是一个脚本区，
如果你将空白的石板。

106
00:05:15,610 --> 00:05:18,590
这就是我们要去的地方写
我们在短短的时刻节目。

107
00:05:18,590 --> 00:05:22,935
和基石，我们将
用它来写这个program--拼图

108
00:05:22,935 --> 00:05:25,310
件，如果你will--是
那些在这里在中间，

109
00:05:25,310 --> 00:05:27,500
他们正在分类
按功能。

110
00:05:27,500 --> 00:05:31,000
所以，举例来说，我要继续前进
和展示的这些的至少一种。

111
00:05:31,000 --> 00:05:33,690
我要继续前进，然后点击
控制类别向上顶。

112
00:05:33,690 --> 00:05:35,720
>> 因此，这些都是分类往上顶。

113
00:05:35,720 --> 00:05:39,410
我要点击控件类。

114
00:05:39,410 --> 00:05:44,020
相反，我要单击事件
类别中，最前面的一个往上顶。

115
00:05:44,020 --> 00:05:47,790
如果你想沿着甚至跟随
因为我们这样做，你很欢迎。

116
00:05:47,790 --> 00:05:52,180
我要单击并拖动这个
第一个，“当绿旗点击。”

117
00:05:52,180 --> 00:05:58,410
然后，我会刚落
大约在我一张白纸的顶部。

118
00:05:58,410 --> 00:06:01,450
>> 什么是关于临时不错
是，这一块拼图，当

119
00:06:01,450 --> 00:06:04,560
与其他拼图互锁
件，是要做到逐字

120
00:06:04,560 --> 00:06:06,460
这些东西拼图要说到做到。

121
00:06:06,460 --> 00:06:09,710
因此，例如，临时是右
现在在他的世界的中间。

122
00:06:09,710 --> 00:06:14,660
我要继续前进，并选择
现在，让我们说，运动类，

123
00:06:14,660 --> 00:06:18,000
如果你想要做的
same--运动类别。

124
00:06:18,000 --> 00:06:20,430
现在我发现有一个整体的
一堆拼图这里

125
00:06:20,430 --> 00:06:23,370
他们说什么，同样，那种事。

126
00:06:23,370 --> 00:06:28,110
而且我要继续前进，拖放
降此举块就在这里。

127
00:06:28,110 --> 00:06:31,860
>> 并注意，一旦你得到
接近“绿色环保标志的底部

128
00:06:31,860 --> 00:06:34,580
点击“按钮，通知
怎么会出现一条白线，

129
00:06:34,580 --> 00:06:36,950
就好像它几乎
磁性，它想要去那里。

130
00:06:36,950 --> 00:06:43,070
刚松手，它会捕捉
一起和形状将匹配。

131
00:06:43,070 --> 00:06:46,620
现在你可以或许差不多
猜出我们这个打算。

132
00:06:46,620 --> 00:06:51,570
>> 如果你看一下划痕阶段
在这里，并期待它的顶部，

133
00:06:51,570 --> 00:06:55,142
你会看到一个红色的灯，
停车标志和环保标志。

134
00:06:55,142 --> 00:06:57,100
而且我要继续前进
看着我的screen--

135
00:06:57,100 --> 00:06:58,460
就一下，如果你能。

136
00:06:58,460 --> 00:07:01,960
我要点击
绿色环保标志，现在，

137
00:07:01,960 --> 00:07:07,850
他搬到这似乎是10个步骤
或10个像素，10个点，在屏幕上。

138
00:07:07,850 --> 00:07:13,390
>> 所以也不那么令人振奋，
但让我求婚

139
00:07:13,390 --> 00:07:17,440
甚至没有教这个，就
用自己的自己intuition--让利

140
00:07:17,440 --> 00:07:22,560
我建议你​​弄清楚如何
使刮走正确的扫尾阶段。

141
00:07:22,560 --> 00:07:28,700
让他让路的右侧
屏幕，一路到右侧。

142
00:07:28,700 --> 00:07:32,200
让我给你一个时刻
左右与搏斗。

143
00:07:32,200 --> 00:07:37,681
你可能想看看
在其他类别的块。

144
00:07:37,681 --> 00:07:38,180
好吧。

145
00:07:38,180 --> 00:07:41,290
所以只是为了回顾一下，当我们有
绿旗点击这里

146
00:07:41,290 --> 00:07:44,850
移动10步是
只有指令，每次我

147
00:07:44,850 --> 00:07:46,720
点击绿色旗帜，是怎么回事？

148
00:07:46,720 --> 00:07:50,070
嗯，这是我的运行程序。

149
00:07:50,070 --> 00:07:52,450
所以，我能做到这一点
也许手动的10倍，

150
00:07:52,450 --> 00:07:55,130
但这种感觉有点
有点hackish，可以这么说，

151
00:07:55,130 --> 00:07:57,480
因此我不是真的
解决这个问题。

152
00:07:57,480 --> 00:08:00,530
我只是试图再次和
再，再而三

153
00:08:00,530 --> 00:08:03,180
直到我有点意外
实现了指令

154
00:08:03,180 --> 00:08:05,560
我提早出门来实现。

155
00:08:05,560 --> 00:08:08,200
>> 但我们知道我们的
伪早些时候有

156
00:08:08,200 --> 00:08:11,870
这一想法在循环编程，
一次又一次地做一些事情。

157
00:08:11,870 --> 00:08:14,888
于是，我看到了一堆你
达到什么一块拼图？

158
00:08:14,888 --> 00:08:17,870

159
00:08:17,870 --> 00:08:18,730
重复，直到。

160
00:08:18,730 --> 00:08:21,400
因此，我们可以做一些
喜欢重复，直到。

161
00:08:21,400 --> 00:08:23,760
你是怎么重复，直到到底是什么？

162
00:08:23,760 --> 00:08:27,720

163
00:08:27,720 --> 00:08:28,540
>> 好。

164
00:08:28,540 --> 00:08:31,974
让我去一个是
稍微简单一些只是一瞬间。

165
00:08:31,974 --> 00:08:33,140
让我继续前进，做到这一点。

166
00:08:33,140 --> 00:08:35,559
请注意，你可能有
控制之下发现，

167
00:08:35,559 --> 00:08:38,409
有这种重复块，这
看起来并不像它的那么大。

168
00:08:38,409 --> 00:08:41,039
这里没有多少空间
这两个黄色线之间。

169
00:08:41,039 --> 00:08:43,539
但正如一些你可能有
注意，如果你拖放，

170
00:08:43,539 --> 00:08:45,150
注意它是如何成长为填充形状。

171
00:08:45,150 --> 00:08:46,274
>> 你甚至可以塞进更多。

172
00:08:46,274 --> 00:08:48,670
它只会保持增长，如果
拖动和悬停。

173
00:08:48,670 --> 00:08:51,110
我不知道什么是
最好在这里，让我们

174
00:08:51,110 --> 00:08:54,760
我至少重复五次，为
实例，然后再回到舞台

175
00:08:54,760 --> 00:08:56,720
然后单击绿色标志。

176
00:08:56,720 --> 00:08:59,110
而现在发现它并不令人信服。

177
00:08:59,110 --> 00:09:02,400
>> 现在，你们中的一些建议，如
维多利亚只是没有，重复10次。

178
00:09:02,400 --> 00:09:05,140
而且一般不
得到他所有的方式，

179
00:09:05,140 --> 00:09:10,510
但不会有成为一个更强大的
方式比任意搞清楚

180
00:09:10,510 --> 00:09:12,640
有多少动作做？

181
00:09:12,640 --> 00:09:17,680
什么可能是一个更好的块
不是重复10次呢？

182
00:09:17,680 --> 00:09:20,380
>> 是啊，为什么不能做一些事情永远不会消失？

183
00:09:20,380 --> 00:09:24,390
现在让我搬这个拼图
里面，远离之一。

184
00:09:24,390 --> 00:09:28,300
现在注意无论身在何处划痕
开始，他去的边缘。

185
00:09:28,300 --> 00:09:30,700
幸好麻省理工学院，
谁使划痕，只是

186
00:09:30,700 --> 00:09:33,190
可以确保他从来没有
完全消失。

187
00:09:33,190 --> 00:09:35,360
您可以随时抓住他的尾巴。

188
00:09:35,360 --> 00:09:37,680
>> 而就直观，
为什么他继续前进？

189
00:09:37,680 --> 00:09:38,892
这里发生了什么？

190
00:09:38,892 --> 00:09:41,440

191
00:09:41,440 --> 00:09:43,824
他似乎已经停止，但
那么如果我拿起并拖动

192
00:09:43,824 --> 00:09:45,240
他一直想要去那边。

193
00:09:45,240 --> 00:09:46,123
这是为什么？

194
00:09:46,123 --> 00:09:51,610

195
00:09:51,610 --> 00:09:54,360
诚然，一台电脑是从字面上
要做到你告诉它做什么。

196
00:09:54,360 --> 00:09:58,380
所以，如果你告诉它前面做
永继的事情，移动10步，

197
00:09:58,380 --> 00:10:01,860
它会一直走下去，去
直到我打红色停车标志

198
00:10:01,860 --> 00:10:04,620
和完全停止该程序。

199
00:10:04,620 --> 00:10:06,610
>> 所以，即使你没有
做到这一点，我怎么会

200
00:10:06,610 --> 00:10:09,510
使划痕移动速度更快
在屏幕上？

201
00:10:09,510 --> 00:10:12,060

202
00:10:12,060 --> 00:10:13,280
更多的步骤，对不对？

203
00:10:13,280 --> 00:10:15,710
因此，而不是做10
在同一时间，我们为什么不

204
00:10:15,710 --> 00:10:20,100
继续前进，改变中场休息
你会propose-- 50？

205
00:10:20,100 --> 00:10:24,410
所以现在我要点击绿色的
旗帜，而事实上，他也快。

206
00:10:24,410 --> 00:10:27,180
>> 与此，当然，只是
动画的一种表现。

207
00:10:27,180 --> 00:10:28,060
什么是动画？

208
00:10:28,060 --> 00:10:33,090
它只是显示你的人一个
静止图像的一大堆真的，

209
00:10:33,090 --> 00:10:34,160
真的，真的快。

210
00:10:34,160 --> 00:10:36,500
所以，如果我们只告诉
他将更多的步骤，

211
00:10:36,500 --> 00:10:39,750
我们只是有效果是
改变他在屏幕上

212
00:10:39,750 --> 00:10:42,900
所有的更迅速的每单位时间的。

213
00:10:42,900 --> 00:10:46,454
>> 现在，我提出的下一个挑战
是让他反弹的边缘。

214
00:10:46,454 --> 00:10:49,120
而且不知道什么谜
件exist--因为它的罚款

215
00:10:49,120 --> 00:10:53,030
如果你没有得到的
在challenge--的阶段是什么

216
00:10:53,030 --> 00:10:54,280
你想直观地做什么？

217
00:10:54,280 --> 00:10:58,030
我们如何要他反弹和
特征在于，在左右之间？

218
00:10:58,030 --> 00:11:02,630

219
00:11:02,630 --> 00:11:03,810
>> 是啊。

220
00:11:03,810 --> 00:11:05,680
因此，我们需要某种
的条件下，与我们

221
00:11:05,680 --> 00:11:09,710
似乎有条件句，所以要
控制类别下说话。

222
00:11:09,710 --> 00:11:14,110
其中这些块
我们可能希望？

223
00:11:14,110 --> 00:11:15,200
是的，也许“的话，那么”。

224
00:11:15,200 --> 00:11:18,780
所以注意到黄色块之中
我们这里有，有这个“如果”

225
00:11:18,780 --> 00:11:23,920
或本“的话，否则”块会
让我们做出决定，这样做

226
00:11:23,920 --> 00:11:25,000
或者这样做。

227
00:11:25,000 --> 00:11:27,380
甚至你可以嵌套这些
做多件事情。

228
00:11:27,380 --> 00:11:34,910
或者，如果你已经不在这里了呢，
继续前进，传感类

229
00:11:34,910 --> 00:11:39,612
还有 - 让我们看看它在这里。

230
00:11:39,612 --> 00:11:43,050

231
00:11:43,050 --> 00:11:52,050
>> 那么，什么块可能会有所帮助这里
检测如果他离开舞台？

232
00:11:52,050 --> 00:11:56,740
是啊，注意到一些，这些块
可参数化的，可以这么说。

233
00:11:56,740 --> 00:12:00,706
它们可以排序的定制，而不是
不像HTML昨天属性，

234
00:12:00,706 --> 00:12:03,330
其中，这些属性样的
自定义标签的行为。

235
00:12:03,330 --> 00:12:08,880
同样在这里，我可以抓住这个动人
块与变化，提出这样的问题，

236
00:12:08,880 --> 00:12:11,500
你去摸鼠标
指针像游标

237
00:12:11,500 --> 00:12:13,250
或者是你接触的边缘？

238
00:12:13,250 --> 00:12:15,210
>> 因此，让我进去，做到这一点。

239
00:12:15,210 --> 00:12:18,130
我要缩小了一会儿。

240
00:12:18,130 --> 00:12:21,320
让我抓住这个拼图
这里，这一块拼图这一点，

241
00:12:21,320 --> 00:12:24,570
我要去混杂
它们只是一瞬间。

242
00:12:24,570 --> 00:12:27,620
我要动这个，
改变这感人的优势，

243
00:12:27,620 --> 00:12:38,590
我要去运动做到这一点。

244
00:12:38,590 --> 00:12:40,490
因此，这里有一些成分。

245
00:12:40,490 --> 00:12:42,570
我想我已经得到了我想要的一切。

246
00:12:42,570 --> 00:12:47,710
>> 会有人想提出我怎么
可以连接这些也许从上到下

247
00:12:47,710 --> 00:12:52,020
为了解决具有的问题
刮动右向左向右

248
00:12:52,020 --> 00:12:57,020
左到右到左，每
时间刚刚反弹的墙？

249
00:12:57,020 --> 00:12:58,050
我想要什么呢？

250
00:12:58,050 --> 00:13:01,097
哪个块我应该连接到
“当绿旗点击第一”？

251
00:13:01,097 --> 00:13:04,060

252
00:13:04,060 --> 00:13:06,200
>> 好了，让我们开始用“永远。”

253
00:13:06,200 --> 00:13:07,170
善有善报，里面下？

254
00:13:07,170 --> 00:13:10,290
其他人。

255
00:13:10,290 --> 00:13:11,850
OK，移动步骤。

256
00:13:11,850 --> 00:13:12,350
好吧。

257
00:13:12,350 --> 00:13:14,470
然后呢？

258
00:13:14,470 --> 00:13:15,120
所以后来的如果。

259
00:13:15,120 --> 00:13:17,720
并注意，尽管它看起来
夹紧紧联系在一起，

260
00:13:17,720 --> 00:13:19,500
它只会增长到填满。

261
00:13:19,500 --> 00:13:21,500
它只是将跳在我想要它。

262
00:13:21,500 --> 00:13:25,920
>> 而我该怎么放的
IF和当时的？

263
00:13:25,920 --> 00:13:27,180
也许“是在触摸的优势。”

264
00:13:27,180 --> 00:13:31,800
和通知，再次，它太大了
对于它，但它会增长到填满。

265
00:13:31,800 --> 00:13:35,002
然后转15度？

266
00:13:35,002 --> 00:13:35,710
多少度？

267
00:13:35,710 --> 00:13:38,800

268
00:13:38,800 --> 00:13:41,196
是啊，所以180会打滑
我所有的相反。

269
00:13:41,196 --> 00:13:42,570
因此，让我们看看，如果我得到这个权利。

270
00:13:42,570 --> 00:13:43,930
让我缩小。

271
00:13:43,930 --> 00:13:45,130
>> 让我拖刮了。

272
00:13:45,130 --> 00:13:50,030
于是，他有点扭曲
现在，但是这很好。

273
00:13:50,030 --> 00:13:52,231
我怎样才能轻松重置他吗？

274
00:13:52,231 --> 00:13:59,879

275
00:13:59,879 --> 00:14:01,045
我要稍微作弊。

276
00:14:01,045 --> 00:14:04,074

277
00:14:04,074 --> 00:14:05,990
所以我又增加
块，仅仅是明确的。

278
00:14:05,990 --> 00:14:08,424
我要他点90度
在默认情况下的权利，

279
00:14:08,424 --> 00:14:10,840
所以我只是要告诉他
要做到这一点编程。

280
00:14:10,840 --> 00:14:11,632
现在我们开始。

281
00:14:11,632 --> 00:14:14,740

282
00:14:14,740 --> 00:14:15,740
我们似乎都做到了。

283
00:14:15,740 --> 00:14:19,980
这是一个有点古怪，因为
他走倒挂。

284
00:14:19,980 --> 00:14:21,250
让我们把一个错误。

285
00:14:21,250 --> 00:14:22,120
这是一个错误。

286
00:14:22,120 --> 00:14:27,320
一个错误是一个程序，一个错误
逻辑错误，我的人，做。

287
00:14:27,320 --> 00:14:28,985
他为什么会颠倒？

288
00:14:28,985 --> 00:14:33,560

289
00:14:33,560 --> 00:14:35,250
MIT有没有搞砸了还是我？

290
00:14:35,250 --> 00:14:38,840

291
00:14:38,840 --> 00:14:42,550
>> 是的，我的意思是，这不是麻省理工学院
故障。他们给了我一块拼图

292
00:14:42,550 --> 00:14:44,970
上面写着转的度一定数目。

293
00:14:44,970 --> 00:14:47,672
而在维多利亚的建议，
我转180度，

294
00:14:47,672 --> 00:14:48,880
这是正确的直觉。

295
00:14:48,880 --> 00:14:53,700
但转弯180度，从字面上
装置转动180度，

296
00:14:53,700 --> 00:14:55,860
而这不是真的
我想要的东西，显然。

297
00:14:55,860 --> 00:14:58,026
因为至少他在
这个二维世界，

298
00:14:58,026 --> 00:15:00,740
所以转折点是真的
翻转他倒挂。

299
00:15:00,740 --> 00:15:04,030
>> 我可能要使用的块
相反，根据你所看到的吗？

300
00:15:04,030 --> 00:15:11,890

301
00:15:11,890 --> 00:15:14,790
我们如何解决这个问题？

302
00:15:14,790 --> 00:15:18,380
是啊，所以我们可以点
在相反的方向。

303
00:15:18,380 --> 00:15:22,300
而实际上，即使这
不会是不够的，

304
00:15:22,300 --> 00:15:26,410
因为我们只能硬编码
指点左侧或右侧。

305
00:15:26,410 --> 00:15:27,920
>> 你知道我们能做什么？

306
00:15:27,920 --> 00:15:30,160
看起来我们有一个
便利块在这里。

307
00:15:30,160 --> 00:15:32,987
如果我放大，看到
这是我们喜欢在这里？

308
00:15:32,987 --> 00:15:36,120

309
00:15:36,120 --> 00:15:40,020
所以它看起来像麻省理工学院有一个
抽象建在这里。

310
00:15:40,020 --> 00:15:45,440
此块似乎是等效
到其它块，复数？

311
00:15:45,440 --> 00:15:49,510
>> 这一块似乎是等同
以块的这整个三人组

312
00:15:49,510 --> 00:15:50,880
我们这里有。

313
00:15:50,880 --> 00:15:54,670
因此，原来我可以简化我的
通过摆脱这一切的程序

314
00:15:54,670 --> 00:15:58,270
而只是把这个在这里。

315
00:15:58,270 --> 00:16:01,620
而现在，他仍然是一个小
越野车，而现在的罚款。

316
00:16:01,620 --> 00:16:03,370
我们把它留给定。

317
00:16:03,370 --> 00:16:06,000
但我的计划是，即使
简单，而且这也

318
00:16:06,000 --> 00:16:09,060
会代表
在programming--目标

319
00:16:09,060 --> 00:16:13,430
是理想使你的代码
简单，尽可能紧凑，

320
00:16:13,430 --> 00:16:15,650
同时仍然为
可读越好。

321
00:16:15,650 --> 00:16:20,310
你不想让它尽量简洁
这很难理解。

322
00:16:20,310 --> 00:16:22,826
>> 但是请注意，我把它换成
三个块一个，

323
00:16:22,826 --> 00:16:24,200
那可以说是一件好事。

324
00:16:24,200 --> 00:16:27,280
我抽象出来的​​概念
抽查不管你是

325
00:16:27,280 --> 00:16:29,120
与仅一个街区的边缘。

326
00:16:29,120 --> 00:16:31,520
现在，我们可以有乐趣与此，事实上。

327
00:16:31,520 --> 00:16:35,790
这不会加那么多
知识产权价值，但顽皮的价值。

328
00:16:35,790 --> 00:16:39,730
我要继续前进
在这里抓住这个声音。

329
00:16:39,730 --> 00:16:42,900

330
00:16:42,900 --> 00:16:46,420
因此，让我先走了，让我
停了片刻程序。

331
00:16:46,420 --> 00:16:52,070
我要记录以下，
允许访问我的麦克风。

332
00:16:52,070 --> 00:16:53,181
>> 开始了。

333
00:16:53,181 --> 00:16:53,680
哎哟。

334
00:16:53,680 --> 00:16:58,710

335
00:16:58,710 --> 00:17:01,140
让我们再试试这个。

336
00:17:01,140 --> 00:17:02,279
开始了。

337
00:17:02,279 --> 00:17:03,570
好吧，我录了错误的事情。

338
00:17:03,570 --> 00:17:04,580
开始了。

339
00:17:04,580 --> 00:17:05,080
哎哟。

340
00:17:05,080 --> 00:17:07,910

341
00:17:07,910 --> 00:17:08,800
哎哟。

342
00:17:08,800 --> 00:17:09,300
好吧。

343
00:17:09,300 --> 00:17:10,791
现在我需要摆脱的。

344
00:17:10,791 --> 00:17:11,290
好吧。

345
00:17:11,290 --> 00:17:13,950
>> 所以现在我有一个
只是记录“哎哟”。

346
00:17:13,950 --> 00:17:18,040
所以，现在我要去
进取，称之为“哎哟”。

347
00:17:18,040 --> 00:17:20,270
我要回去
我的剧本，现在

348
00:17:20,270 --> 00:17:25,460
通知有该块被称为
播放声音“喵喵”或播放声音“哎哟”。

349
00:17:25,460 --> 00:17:28,920
我要去拖这一点，并在
我应该把这个滑稽的效果？

350
00:17:28,920 --> 00:17:31,740

351
00:17:31,740 --> 00:17:37,860
是啊，所以现在它是一种
越野车，因为现在这个block--

352
00:17:37,860 --> 00:17:42,050
注意如何“如果边缘，
反弹“是一种自成体系。

353
00:17:42,050 --> 00:17:43,704
所以，我需要解决这个问题。

354
00:17:43,704 --> 00:17:44,870
让我继续前进，做到这一点。

355
00:17:44,870 --> 00:17:48,630
让我摆脱这一点，回去
我们原来的，更深思熟虑

356
00:17:48,630 --> 00:17:49,870
功能。

357
00:17:49,870 --> 00:18:01,080
因此，“如果触及边缘，然后在”我想
转，维多利亚提出，

358
00:18:01,080 --> 00:18:02,480
180度。

359
00:18:02,480 --> 00:18:05,497
那我要玩
声“哎哟”呢？

360
00:18:05,497 --> 00:18:11,800

361
00:18:11,800 --> 00:18:15,580
>> 是啊，察觉到它的外
那个黄色的块状。

362
00:18:15,580 --> 00:18:17,680
因此，这也将是一个
错误，但我已经注意到了这一点。

363
00:18:17,680 --> 00:18:21,290
所以我要在这里拖起来，
并注意现在是里面的“如果”。

364
00:18:21,290 --> 00:18:24,250
因此，“如果”这算哪门子
像臂形印迹

365
00:18:24,250 --> 00:18:26,260
那唯一的打算
做什么是它里面。

366
00:18:26,260 --> 00:18:30,216
所以，现在，如果我缩小在
annoying--的风险

367
00:18:30,216 --> 00:18:32,860

368
00:18:32,860 --> 00:18:36,470
>> 计算机：哎哟，哎哟，哎哟。

369
00:18:36,470 --> 00:18:39,910
>> DAVID MALAN：它
只是永远持续下去。

370
00:18:39,910 --> 00:18:44,160
现在只是加快东西
在这里，让我去进取，不断开拓，

371
00:18:44,160 --> 00:18:50,460
让我们say--让我去一些
从类我自己的东西。

372
00:18:50,460 --> 00:18:53,000

373
00:18:53,000 --> 00:19:00,220
让我开拓，让我们说，这
一个接我们的教学研究员之一制成

374
00:19:00,220 --> 00:19:01,500
两三年前。

375
00:19:01,500 --> 00:19:04,732
所以，有些人可能还记得
本场比赛从昔日的，

376
00:19:04,732 --> 00:19:05,940
它实际上是显着的。

377
00:19:05,940 --> 00:19:08,190
尽管我们已经做了
最简单的方案，现在，

378
00:19:08,190 --> 00:19:09,980
让我们来考虑一下这个
实际上样子。

379
00:19:09,980 --> 00:19:10,650
让我打比赛。

380
00:19:10,650 --> 00:19:14,210

381
00:19:14,210 --> 00:19:18,980
>> 因此，在这场比赛中，我们有一个
青蛙，并使用箭头keys--

382
00:19:18,980 --> 00:19:23,340
他需要比我脖子了更大的步伐
我有过这种青蛙的控制。

383
00:19:23,340 --> 00:19:29,630
其目标是跨越繁忙的获得
路不跑入汽车。

384
00:19:29,630 --> 00:19:34,735
而让我要是在这里上去的see--，我
必须等待日志被滚动。

385
00:19:34,735 --> 00:19:38,130

386
00:19:38,130 --> 00:19:39,274
这感觉就像一个错误。

387
00:19:39,274 --> 00:19:42,240

388
00:19:42,240 --> 00:19:43,495
这是怎样的一个错误。

389
00:19:43,495 --> 00:19:45,980

390
00:19:45,980 --> 00:19:46,480
好吧。

391
00:19:46,480 --> 00:19:51,550
我在这里这样，
在那里，然后你继续

392
00:19:51,550 --> 00:19:54,100
走，直到你得到所有
青蛙的睡莲。

393
00:19:54,100 --> 00:19:55,920
现在，这可能看起来
所有的更复杂，

394
00:19:55,920 --> 00:19:57,840
但让我们尝试突破
下来弱智

395
00:19:57,840 --> 00:20:00,040
并口头成其组件块。

396
00:20:00,040 --> 00:20:03,910
因此，有可能是一个谜
我们还没有看到一块

397
00:20:03,910 --> 00:20:07,440
但是这响应按键，
的事情我按下键盘上。

398
00:20:07,440 --> 00:20:11,660
>> 因此，有可能是某种
块说，如果key等于起来，

399
00:20:11,660 --> 00:20:15,965
然后做一些Scratch--
也许移动10步这种方式。

400
00:20:15,965 --> 00:20:20,240
如果向下键，移动10步
这样一来，或者左键，将10个步骤

401
00:20:20,240 --> 00:20:21,710
通过这种方式，10的步骤。

402
00:20:21,710 --> 00:20:23,644
我已经清楚地变成猫变成了青蛙。

403
00:20:23,644 --> 00:20:26,060
所以，这只是其中
服装，刮擦调用它 - 我们

404
00:20:26,060 --> 00:20:28,440
刚刚导入的青蛙的图片。

405
00:20:28,440 --> 00:20:29,570
>> 还有什么是怎么回事？

406
00:20:29,570 --> 00:20:32,794
什么其他代码行，
还有什么其他拼图

407
00:20:32,794 --> 00:20:35,460
布雷克那样，我们的教学老乡，
在这个程序中使用，显然是？

408
00:20:35,460 --> 00:20:38,320

409
00:20:38,320 --> 00:20:42,730
什么是使一切move--
什么编程构建？

410
00:20:42,730 --> 00:20:44,950
>> 运动，sure--所以
移动块，肯定的。

411
00:20:44,950 --> 00:20:49,330
而那是什么举动块
里面，最有可能的？

412
00:20:49,330 --> 00:20:52,850
是的，某种循环，也许
永远阻止，也许是重复block--

413
00:20:52,850 --> 00:20:54,070
重复，直到块。

414
00:20:54,070 --> 00:20:57,330
这就是什么使日志和
百合垫和其他一切举动

415
00:20:57,330 --> 00:20:57,990
来来回回。

416
00:20:57,990 --> 00:21:00,270
这只是发生不休。

417
00:21:00,270 --> 00:21:03,180
>> 为什么有些车
移动速度比别人快？

418
00:21:03,180 --> 00:21:06,607
什么是关于这些程序有什么不同？

419
00:21:06,607 --> 00:21:09,690
是啊，也许他们中的一些正在服用
同时更多的步骤，其中一些

420
00:21:09,690 --> 00:21:10,690
同时更少的步骤。

421
00:21:10,690 --> 00:21:14,670
和视觉效果
快与慢。

422
00:21:14,670 --> 00:21:16,030
>> 你认为发生了什么？

423
00:21:16,030 --> 00:21:19,700
当我得到了我的青蛙一路
在街对面，河

424
00:21:19,700 --> 00:21:23,560
到蕸，东西
值得一提的事。

425
00:21:23,560 --> 00:21:26,540
什么，只要我这样做了？

426
00:21:26,540 --> 00:21:27,210
停了。

427
00:21:27,210 --> 00:21:29,680
青蛙停了下来，
我得到了第二只青蛙。

428
00:21:29,680 --> 00:21:33,155
那么，什么结构必须是
使用有什么功能？

429
00:21:33,155 --> 00:21:36,020

430
00:21:36,020 --> 00:21:38,660
>> 是啊，所以有某种
“if”条件在那里，太。

431
00:21:38,660 --> 00:21:41,909
而事实证明out--我们没有看到this--
但有在那里，其他块

432
00:21:41,909 --> 00:21:45,300
可以说，如果你是感人
屏幕上的另一件事，

433
00:21:45,300 --> 00:21:47,720
如果你触摸蕸，“然后”。

434
00:21:47,720 --> 00:21:50,810
然后那个时候我们
使第二只青蛙出现。

435
00:21:50,810 --> 00:21:54,969
因此，即使这场比赛肯定是
很过时，尽管乍一看

436
00:21:54,969 --> 00:21:58,010
有这么多的事情on--和布雷克
在两分钟内没有掀起这件事，

437
00:21:58,010 --> 00:22:00,390
大概花了他几
小时创造这个游戏

438
00:22:00,390 --> 00:22:03,850
根据他的记忆或视频
昔日的的版本吧。

439
00:22:03,850 --> 00:22:07,940
但是，所有的这些小事
要在隔离的屏幕上

440
00:22:07,940 --> 00:22:11,550
归结为这些很简单
constructs--运动或声明

441
00:22:11,550 --> 00:22:15,519
就像我们已经讨论过，循环和
条件，这就是它。

442
00:22:15,519 --> 00:22:17,060
还有一些其他鸽友功能。

443
00:22:17,060 --> 00:22:19,130
其中有些是纯粹的
审美或声，

444
00:22:19,130 --> 00:22:20,964
喜欢的声音我只是打了。

445
00:22:20,964 --> 00:22:23,380
但在大多数情况下，则
没有这个语言，从无到有，

446
00:22:23,380 --> 00:22:25,350
所有基本的
积木您

447
00:22:25,350 --> 00:22:29,280
在C，Java的，JavaScript中，
PHP和Ruby，Python和

448
00:22:29,280 --> 00:22:32,960
和任意数量的其他语言。

449
00:22:32,960 --> 00:22:36,720
关于临时有问题吗？

450
00:22:36,720 --> 00:22:37,220
好吧。

451
00:22:37,220 --> 00:22:40,303
所以我们不会在更深的下潜划伤，
虽然你这个周末是受欢迎的，

452
00:22:40,303 --> 00:22:42,860
特别是如果你有孩子，或
侄女和侄子这样，

453
00:22:42,860 --> 00:22:44,220
向他们介绍划伤。

454
00:22:44,220 --> 00:22:47,960
它实际上是一个奇妙的俏皮
环境，因为它的作者说，

455
00:22:47,960 --> 00:22:49,120
天花板很高。

456
00:22:49,120 --> 00:22:51,670
尽管我们开始
非常低层次的细节，

457
00:22:51,670 --> 00:22:54,890
你真的可以做相当多的
用它，这或许是

458
00:22:54,890 --> 00:22:57,360
正好一个示范。

459
00:22:57,360 --> 00:23:02,920
>> 但是，让我们现在过渡到一些
复杂的问题，如果你愿意，

460
00:23:02,920 --> 00:23:05,870
称为“搜索”和
“排序”，更普遍。

461
00:23:05,870 --> 00:23:09,500
我们必须在这里先前已经本电话簿的
另一只为discussion--

462
00:23:09,500 --> 00:23:13,460
我们能够搜索
更有效，因为

463
00:23:13,460 --> 00:23:15,270
的一个显著假设。

464
00:23:15,270 --> 00:23:17,655
而仅仅是明确的，是什么
假设是我做

465
00:23:17,655 --> 00:23:19,280
通过这个电话本搜索时？

466
00:23:19,280 --> 00:23:23,342

467
00:23:23,342 --> 00:23:25,300
迈克·史密斯在
电话本，虽然我

468
00:23:25,300 --> 00:23:27,410
将能够处理
没有他场景

469
00:23:27,410 --> 00:23:30,720
还有，如果我只是提前停止。

470
00:23:30,720 --> 00:23:31,806
这本书是按字母顺序。

471
00:23:31,806 --> 00:23:33,930
这是一个非常慷慨
假设，因为这

472
00:23:33,930 --> 00:23:36,580
意味着someone--我有点
切割角，

473
00:23:36,580 --> 00:23:40,580
像我，因为有人快
别人做了很多艰苦的工作对我来说。

474
00:23:40,580 --> 00:23:43,120
>> 但是，如果手机
本书是不排序？

475
00:23:43,120 --> 00:23:47,050
也许Verizon的偷懒，只是把
每个人的姓名和电话号码在那里

476
00:23:47,050 --> 00:23:50,120
也许在顺序他们
签署了电话服务。

477
00:23:50,120 --> 00:23:54,570
多少时间，它带我
找一个像迈克·史密斯？

478
00:23:54,570 --> 00:23:58,160
1000页的电话book--多少
网页做我不得不通过看？

479
00:23:58,160 --> 00:23:58,905
>> 他们全部。

480
00:23:58,905 --> 00:24:00,030
你是那种倒霉。

481
00:24:00,030 --> 00:24:03,420
你从字面上来看看每
如果电话簿只是页面

482
00:24:03,420 --> 00:24:04,450
随机排序。

483
00:24:04,450 --> 00:24:06,910
你可能会得到幸运，找到迈克
书的第一页上，因为他

484
00:24:06,910 --> 00:24:08,826
是第一个客户
订购电话服务。

485
00:24:08,826 --> 00:24:10,760
但他可能是最后一次了。

486
00:24:10,760 --> 00:24:12,500
>> 所以随机顺序并不好。

487
00:24:12,500 --> 00:24:16,750
因此，假设我们要排序
电话簿或一般的数据排序

488
00:24:16,750 --> 00:24:18,520
我们一直在考虑。

489
00:24:18,520 --> 00:24:19,440
我们怎样才能做到这一点？

490
00:24:19,440 --> 00:24:21,360
>> 那么，就让我只是尝试
这里一个简单的例子。

491
00:24:21,360 --> 00:24:24,290
让我继续前进，折腾
在黑板上几号。

492
00:24:24,290 --> 00:24:35,480
假设我们有是数字，
比方说，四，二，一，三。

493
00:24:35,480 --> 00:24:38,390
而且，本，这些数字对我们进行排序。

494
00:24:38,390 --> 00:24:39,017
>> OK，不错。

495
00:24:39,017 --> 00:24:39,850
你怎么做到的？

496
00:24:39,850 --> 00:24:42,731

497
00:24:42,731 --> 00:24:43,230
好吧。

498
00:24:43,230 --> 00:24:44,710
因此，与最小的开始
值和最高的，

499
00:24:44,710 --> 00:24:46,084
这就是真正的好直觉。

500
00:24:46,084 --> 00:24:48,080
并意识到我们
人类实际上是相当

501
00:24:48,080 --> 00:24:49,913
善于解决问题
这样，至少

502
00:24:49,913 --> 00:24:51,810
当数据是比较小的。

503
00:24:51,810 --> 00:24:54,860
一旦你开始有上百
数字，数千数字，

504
00:24:54,860 --> 00:24:58,440
数以百万计的数字，大概奔
不能做到这一点想象中的那么快，

505
00:24:58,440 --> 00:25:00,620
假设有
中的数字的空白。

506
00:25:00,620 --> 00:25:03,450
很容易数到一百万
否则，只是费时。

507
00:25:03,450 --> 00:25:07,150
>> 所以算法听起来
像本现在用刚

508
00:25:07,150 --> 00:25:08,930
是搜索的最小数目。

509
00:25:08,930 --> 00:25:12,900
因此，即使我们人类可以采取
在大量的信息可视化，

510
00:25:12,900 --> 00:25:14,830
计算机实际上是
多一点有限的。

511
00:25:14,830 --> 00:25:17,560
计算机只能
看一个字节在一个时间

512
00:25:17,560 --> 00:25:20,770
或在一个时间 - 也许四个字节
在时间 - 这些天，也许8个字节

513
00:25:20,770 --> 00:25:24,450
但极少数
的字节在给定的时间。

514
00:25:24,450 --> 00:25:28,480
>> 因此，考虑到我们真的有
四个单独的值这里 - 

515
00:25:28,480 --> 00:25:32,440
你能想到奔具有
对，如果他是一个计算机，例如一叶障目

516
00:25:32,440 --> 00:25:36,450
他看不到任何其他
不是在时间 - 一个号码

517
00:25:36,450 --> 00:25:39,720
所以我们一般会认为，像
英语中，我们将从右至左读。

518
00:25:39,720 --> 00:25:42,870
因此，第一个数字奔大概看了
在四岁，然后很快

519
00:25:42,870 --> 00:25:44,770
意识到是一个相当大
number--让我继续寻找。

520
00:25:44,770 --> 00:25:45,357
>> 有两项。

521
00:25:45,357 --> 00:25:45,940
等一下。

522
00:25:45,940 --> 00:25:47,070
二是超过四个小。

523
00:25:47,070 --> 00:25:47,986
我会记住。

524
00:25:47,986 --> 00:25:49,070
现在二是最小的。

525
00:25:49,070 --> 00:25:50,417
现在one--那就更好了。

526
00:25:50,417 --> 00:25:51,250
这是更小。

527
00:25:51,250 --> 00:25:54,000
我要忘了约两
，只是记住一个现在。

528
00:25:54,000 --> 00:25:56,550
>> 而且他可以停止寻找？

529
00:25:56,550 --> 00:25:58,360
嗯，他可以根据
该信息，

530
00:25:58,360 --> 00:26:00,477
但他最好的搜索
列表的其余部分。

531
00:26:00,477 --> 00:26:02,060
因为什么，如果是零列表中？

532
00:26:02,060 --> 00:26:03,643
如果负一人在列表中？

533
00:26:03,643 --> 00:26:07,720
他只知道，他的回答
是正确的，如果他的详尽

534
00:26:07,720 --> 00:26:08,729
检查整个列表。

535
00:26:08,729 --> 00:26:10,020
所以，我们看一下这个休息。

536
00:26:10,020 --> 00:26:11,394
Three--那是浪费时间。

537
00:26:11,394 --> 00:26:13,540
倒霉的了，但我是
还是正确的这样做。

538
00:26:13,540 --> 00:26:17,857
所以现在他大概
选择的最小的数

539
00:26:17,857 --> 00:26:20,440
而只是把它开头
名单，因为我会在这里做的。

540
00:26:20,440 --> 00:26:23,480
现在，你做了什么接下来，即使
你不想想近

541
00:26:23,480 --> 00:26:25,962
到这个地步？

542
00:26:25,962 --> 00:26:27,670
重复这个过程，
所以某种循环。

543
00:26:27,670 --> 00:26:28,920
有一个熟悉的概念。

544
00:26:28,920 --> 00:26:30,860
因此，这里是四人。

545
00:26:30,860 --> 00:26:32,110
这是目前国内最小的。

546
00:26:32,110 --> 00:26:33,220
这是一个候选人。

547
00:26:33,220 --> 00:26:33,900
不再。

548
00:26:33,900 --> 00:26:34,770
现在，我已经看到了两个。

549
00:26:34,770 --> 00:26:36,630
这是下一个最小的元素。

550
00:26:36,630 --> 00:26:40,800
Three--那不是更小，所以
现在本可以挖出两个。

551
00:26:40,800 --> 00:26:44,510
>> 而现在我们重复的过程中，
当然3下一个被拉出。

552
00:26:44,510 --> 00:26:45,420
重复上述过程。

553
00:26:45,420 --> 00:26:46,990
四个被拉出。

554
00:26:46,990 --> 00:26:50,140
而现在我们出数字，
因此列表必须被排序。

555
00:26:50,140 --> 00:26:51,960
>> 事实上，这是一个正式的算法。

556
00:26:51,960 --> 00:26:56,610
计算机科学家会
称之为“选择排序”

557
00:26:56,610 --> 00:27:00,880
这个想法是一个排序
再次列出iteratively--

558
00:27:00,880 --> 00:27:03,807
一次又一次选择
的最小数字。

559
00:27:03,807 --> 00:27:06,140
而且它是什么太好
它只是这么混账直观。

560
00:27:06,140 --> 00:27:07,470
它是如此简单。

561
00:27:07,470 --> 00:27:11,100
你可以重复同样的
连连操作。

562
00:27:11,100 --> 00:27:12,150
这很简单。

563
00:27:12,150 --> 00:27:17,170
>> 在这种情况下，它是速度快，但
多长时间居然拿？

564
00:27:17,170 --> 00:27:19,880
让我们把它似乎并
觉得有点单调乏味。

565
00:27:19,880 --> 00:27:24,150
所以一，二，三，四，五六百，
七，八，九，十，十一，十二，十三，十四，

566
00:27:24,150 --> 00:27:26,160
15，16--任意数。

567
00:27:26,160 --> 00:27:28,780
我只是想这多
时间不仅仅是四个。

568
00:27:28,780 --> 00:27:30,780
所以，如果我有一个整体
一串数字now--它

569
00:27:30,780 --> 00:27:32,420
甚至没有关系
他们are--让我们

570
00:27:32,420 --> 00:27:34,380
想想这
算法真的是喜欢。

571
00:27:34,380 --> 00:27:35,857
>> 假设有数字存在。

572
00:27:35,857 --> 00:27:38,190
再次，什么都无所谓
他们，但他们是随机的。

573
00:27:38,190 --> 00:27:39,679
我申请本的算法。

574
00:27:39,679 --> 00:27:41,220
我需要选择最小的数字。

575
00:27:41,220 --> 00:27:41,761
我该怎么办？

576
00:27:41,761 --> 00:27:44,240
而我要去物理
做这次表演出来。

577
00:27:44,240 --> 00:27:46,099
寻找，寻找，
寻找，寻找，寻找。

578
00:27:46,099 --> 00:27:48,140
只有时间我去
列表的末尾可以

579
00:27:48,140 --> 00:27:51,230
我意识到最小
根数为两根这个时候。

580
00:27:51,230 --> 00:27:52,720
一个不是在列表中。

581
00:27:52,720 --> 00:27:54,400
于是，我放下了两项。

582
00:27:54,400 --> 00:27:55,590
>> 我该怎么做？

583
00:27:55,590 --> 00:27:58,600
寻找，寻找，寻找，寻找。

584
00:27:58,600 --> 00:28:02,250
现在我找到了七位数，是因为
有这些numbers--差距

585
00:28:02,250 --> 00:28:03,300
只是随心所欲。

586
00:28:03,300 --> 00:28:03,800
好吧。

587
00:28:03,800 --> 00:28:06,030
所以，现在我可以放下七人。

588
00:28:06,030 --> 00:28:08,860
展望寻找，寻找。

589
00:28:08,860 --> 00:28:11,030
>> 现在我假设的
当然，这本不

590
00:28:11,030 --> 00:28:14,780
有额外内存，额外
存储器，因为，当然，

591
00:28:14,780 --> 00:28:16,080
我期待在相同的号码。

592
00:28:16,080 --> 00:28:18,246
当然，我可以记得
所有这些数字的，

593
00:28:18,246 --> 00:28:19,930
这就是千真万确的。

594
00:28:19,930 --> 00:28:22,610
但是，如果本·记住所有
数字的，他已经看到，

595
00:28:22,610 --> 00:28:24,430
他还没有决定
根本的进步

596
00:28:24,430 --> 00:28:26,170
因为他已经有
搜索能力

597
00:28:26,170 --> 00:28:27,540
通过主板上的号码。

598
00:28:27,540 --> 00:28:29,373
记住所有的
数字没有帮助，

599
00:28:29,373 --> 00:28:32,490
因为他依然可以作为一台电脑
仅看，我们已经说过了，一个号码

600
00:28:32,490 --> 00:28:33,080
在一个时间。

601
00:28:33,080 --> 00:28:35,760
因此，有没有那种骗
那里，你可以利用。

602
00:28:35,760 --> 00:28:39,170
>> 因此，在现实中，如我
继续搜索列表，

603
00:28:39,170 --> 00:28:44,200
我简直要只是不停
通过来回，采摘出来

604
00:28:44,200 --> 00:28:45,710
下一个最小号。

605
00:28:45,710 --> 00:28:48,810
正如你可以种推断
从我的愚蠢的动作，

606
00:28:48,810 --> 00:28:50,860
这只是变得非常
乏味的速度非常快，

607
00:28:50,860 --> 00:28:54,850
我似乎回去和
第四，来回还真不少。

608
00:28:54,850 --> 00:29:03,220
现在是公平的，我没有去
作为比较，好了，让我们see--是公平的，

609
00:29:03,220 --> 00:29:06,310
我不必走很
每次尽可能多的步骤。

610
00:29:06,310 --> 00:29:09,200
因为，当然，我
从列表中选择号码，

611
00:29:09,200 --> 00:29:11,860
剩下的名单也越来越短。

612
00:29:11,860 --> 00:29:14,240
>> 因此，让我们想想
其实，我要走多少步是

613
00:29:14,240 --> 00:29:16,010
通过每个疲惫地走时间。

614
00:29:16,010 --> 00:29:18,950
在第一次的情况
我们有16个数字，

615
00:29:18,950 --> 00:29:22,210
所以maximally--我们只是
对于discussion--做到这一点

616
00:29:22,210 --> 00:29:25,640
我不得不通过16看
编号，以找到最小。

617
00:29:25,640 --> 00:29:28,420
但是，一旦我拔光了
最小的数，如何

618
00:29:28,420 --> 00:29:30,590
长得其余名单，当然，？

619
00:29:30,590 --> 00:29:31,420
只有15。

620
00:29:31,420 --> 00:29:34,670
那么有多少数字做本或我有
通过第二次左右看？

621
00:29:34,670 --> 00:29:36,832
15，只是去寻找最小。

622
00:29:36,832 --> 00:29:39,540
但现在，当然，列表是，
也小于以前。

623
00:29:39,540 --> 00:29:42,540
那么有多少步骤，做了我
必须采取下一次？

624
00:29:42,540 --> 00:29:49,970
14，然后13，然后12，加点，
点，点，直到我留下了只有一个。

625
00:29:49,970 --> 00:29:53,146
所以，现在的计算机科学家会
问，好，是什么人人平等？

626
00:29:53,146 --> 00:29:55,770
这实际上等于一些具体
数字，我们当然可以

627
00:29:55,770 --> 00:30:00,490
做算术，但是我们要谈
关于算法的效率

628
00:30:00,490 --> 00:30:04,940
多一点通过公式，
独立的列表是多久。

629
00:30:04,940 --> 00:30:06,240
>> 所以，你知道吗？

630
00:30:06,240 --> 00:30:09,860
这是16日，但就像我之前说的，
我们只需要调用这个问题的规模

631
00:30:09,860 --> 00:30:10,970
n，其中n是一些数字。

632
00:30:10,970 --> 00:30:13,220
也许是16，也许这是
三，也许这是一个亿。

633
00:30:13,220 --> 00:30:13,761
我不知道。

634
00:30:13,761 --> 00:30:14,390
我不在乎。

635
00:30:14,390 --> 00:30:16,520
我真正想要的是
一个公式，我可以

636
00:30:16,520 --> 00:30:19,420
使用比较算法
与其他算法

637
00:30:19,420 --> 00:30:22,350
有人可能声称
是好还是坏。

638
00:30:22,350 --> 00:30:25,430
>> 因此，原来，只有我
从小学知道这一点，

639
00:30:25,430 --> 00:30:34,790
这实际上工程以相同
事为n在N加一两岁多。

640
00:30:34,790 --> 00:30:40,020
而这恰好相等，的
当然，N的平方加N超过两。

641
00:30:40,020 --> 00:30:43,250
所以，如果我想要一个公式
有多少步

642
00:30:43,250 --> 00:30:46,330
参与看着都
连连这些数字的

643
00:30:46,330 --> 00:30:52,681
一次又一次，我会说
它n值的平方加N超过两。

644
00:30:52,681 --> 00:30:53,430
但是，你知道吗？

645
00:30:53,430 --> 00:30:54,500
这只是看起来凌乱。

646
00:30:54,500 --> 00:30:56,470
我真的不想一个
的东西一般意义。

647
00:30:56,470 --> 00:30:58,810
你可能还记得，从
高中有

648
00:30:58,810 --> 00:31:00,660
是最高阶术语的概念。

649
00:31:00,660 --> 00:31:05,300
其中这些条款，第n
的平方，在n或半

650
00:31:05,300 --> 00:31:07,550
随着时间的影响最大？

651
00:31:07,550 --> 00:31:11,920
更大的n变，这
这些问题的是什么？

652
00:31:11,920 --> 00:31:15,560
>> 换句话说，如果我插
中了一千万，N平方

653
00:31:15,560 --> 00:31:17,900
将是最有可能的
的主导因素，

654
00:31:17,900 --> 00:31:21,670
因为一百万次
本身是大了很多

655
00:31:21,670 --> 00:31:23,682
比加一个附加万元。

656
00:31:23,682 --> 00:31:24,390
所以，你知道吗？

657
00:31:24,390 --> 00:31:27,305
这是多么大的混账
号，如果你一个平方数。

658
00:31:27,305 --> 00:31:28,430
这其实并不重要。

659
00:31:28,430 --> 00:31:30,596
我们只是十字架
并忘掉它。

660
00:31:30,596 --> 00:31:34,250
所以，一个计算机科学家会说
该算法的效率

661
00:31:34,250 --> 00:31:37,850
为n的量级squared--
我的意思是真正的近似值。

662
00:31:37,850 --> 00:31:40,810
它是那种大约N个平方。

663
00:31:40,810 --> 00:31:44,130
随着时间的推移，做大
和更大的n变，这

664
00:31:44,130 --> 00:31:47,610
是什么一个很好的估计
效率或缺乏效率

665
00:31:47,610 --> 00:31:49,400
这种算法实际上是。

666
00:31:49,400 --> 00:31:52,040
我推导出，当然，
从实际上做数学。

667
00:31:52,040 --> 00:31:54,040
但现在我只是挥手
我的手，因为我只是

668
00:31:54,040 --> 00:31:55,790
希望这种算法的一般意义。

669
00:31:55,790 --> 00:31:58,850
>> 因此，使用相同的逻辑，同时，
让我们考虑另一种算法

670
00:31:58,850 --> 00:32:01,162
我们已经看到at--线性搜索。

671
00:32:01,162 --> 00:32:02,870
当我搜索
为手机book--

672
00:32:02,870 --> 00:32:05,980
不选它，搜索
通过电话book--

673
00:32:05,980 --> 00:32:09,197
我们一直在说，这是
1000步，或500步。

674
00:32:09,197 --> 00:32:10,280
但是，让我们笼统地说。

675
00:32:10,280 --> 00:32:12,860
如果有n个网页
电话本，有什么

676
00:32:12,860 --> 00:32:17,250
运行时间或
线性搜索的效率？

677
00:32:17,250 --> 00:32:19,750
它的顺序
多少个步骤，找到

678
00:32:19,750 --> 00:32:24,210
用迈克·史密斯线性搜索，该
第一算法，或者甚至第二？

679
00:32:24,210 --> 00:32:27,240

680
00:32:27,240 --> 00:32:31,710
>> 在最坏的情况下，麦克
是在书的末尾。

681
00:32:31,710 --> 00:32:35,590
因此，如果电话本有1000页，
我们说最后一次，在最坏的情况下，

682
00:32:35,590 --> 00:32:38,380
它可能需要大致有
很多网页找迈克？

683
00:32:38,380 --> 00:32:38,990
像1000。

684
00:32:38,990 --> 00:32:39,830
这是一个上限。

685
00:32:39,830 --> 00:32:41,790
这是最坏的可能发生的情况。

686
00:32:41,790 --> 00:32:44,410
但同样，我们正在走
从1000像现在的数字。

687
00:32:44,410 --> 00:32:45,730
这只是ñ。

688
00:32:45,730 --> 00:32:47,470
>> 那么什么是合乎逻辑的结论？

689
00:32:47,470 --> 00:32:50,210
在电话找到麦克
书中有n页

690
00:32:50,210 --> 00:32:55,280
可能需要在很​​最坏的情况下，
有多少n的顺序步骤？

691
00:32:55,280 --> 00:32:58,110
的确计算机
科学家会说

692
00:32:58,110 --> 00:33:02,340
正在运行的时间，或
性能和效率

693
00:33:02,340 --> 00:33:07,470
或低效率的算法类的，
线性搜索是n的量级。

694
00:33:07,470 --> 00:33:10,010
我们可以采用同样的
穿越出来的东西逻辑

695
00:33:10,010 --> 00:33:13,170
因为我只是做了第二个
算法中，我们曾与电话本，

696
00:33:13,170 --> 00:33:16,040
在这里我们去一次两页。

697
00:33:16,040 --> 00:33:20,120
>> 因此，1000页的电话本可能
带我们500翻页，加一

698
00:33:20,120 --> 00:33:21,910
如果我们加倍回位。

699
00:33:21,910 --> 00:33:26,590
因此，如果一个电话本有n个网页，但
我们正在做的一次两页，

700
00:33:26,590 --> 00:33:28,900
这大概是什么？

701
00:33:28,900 --> 00:33:33,190
ñ了两个，所以这是如N超过两。

702
00:33:33,190 --> 00:33:38,490
但我做了一个索赔
刚才是n超过two--

703
00:33:38,490 --> 00:33:41,060
这是一种相同的是仅仅局限于N。

704
00:33:41,060 --> 00:33:44,050
这只是一个常数因子，
计算机科学家会说。

705
00:33:44,050 --> 00:33:45,970
让我们只专注于
变量，真的 - 

706
00:33:45,970 --> 00:33:47,780
公式中的最大变量。

707
00:33:47,780 --> 00:33:52,530
>> 所以线性搜索，无论是做了一个
在同一时间或页面同时两页，

708
00:33:52,530 --> 00:33:54,810
是那种基本上是相同的。

709
00:33:54,810 --> 00:33:56,880
它仍然是n的顺序。

710
00:33:56,880 --> 00:34:01,930
但是，我有我的照片早前声称
该第三算法不是

711
00:34:01,930 --> 00:34:02,480
线性的。

712
00:34:02,480 --> 00:34:03,605
它不是一条直线。

713
00:34:03,605 --> 00:34:08,659
它是弯曲的线，且
代数公式有什么呢？

714
00:34:08,659 --> 00:34:11,812
N--的日志记录这样的n基地二期。

715
00:34:11,812 --> 00:34:14,520
而且我们没有进入过
今天对数的细节，

716
00:34:14,520 --> 00:34:17,394
但大多数计算机科学家不会
甚至告诉你基础是什么。

717
00:34:17,394 --> 00:34:20,639
因为这一切都只是
持续性因素，可以这么说，

718
00:34:20,639 --> 00:34:22,659
只是轻微的数值差异。

719
00:34:22,659 --> 00:34:31,179
因此，这将是一个非常普遍的
对于这样特别正式的计算机

720
00:34:31,179 --> 00:34:33,949
科学家在一次董事会或
在白板程序员

721
00:34:33,949 --> 00:34:36,889
其实这争论
算法，他们将使用

722
00:34:36,889 --> 00:34:39,500
还是什么效率
他们的算法。

723
00:34:39,500 --> 00:34:42,960
>> 这未必是
你在任何伟大的详细讨论，

724
00:34:42,960 --> 00:34:47,889
但一个优秀的程序员是谁家
谁拥有了坚实的，正式的背景。

725
00:34:47,889 --> 00:34:50,120
他能操
你在这种方式

726
00:34:50,120 --> 00:34:53,350
，实际上使
定性的论据，

727
00:34:53,350 --> 00:34:56,870
为什么一种算法或
一个软件

728
00:34:56,870 --> 00:35:00,165
在某些方面，以另一种优越。

729
00:35:00,165 --> 00:35:02,540
因为你肯定能
只要运行一个人的计划

730
00:35:02,540 --> 00:35:04,980
和计数的秒数
花费一些数字排序，

731
00:35:04,980 --> 00:35:06,710
你可以运行一些
其他人的计划

732
00:35:06,710 --> 00:35:08,418
和计数数
几秒钟需要。

733
00:35:08,418 --> 00:35:12,840
但是，这是一个更一般的方式
你可以用它来分析算法，

734
00:35:12,840 --> 00:35:15,520
如果你愿意，只是
纸张或口头刚。

735
00:35:15,520 --> 00:35:18,430
甚至没有运行它，没有
甚至还试图采样输入，

736
00:35:18,430 --> 00:35:20,180
你可以通过讲道理了。

737
00:35:20,180 --> 00:35:24,670
所以，与聘请开发商或者
有他或她之类的争论给你

738
00:35:24,670 --> 00:35:28,460
为什么他们的算法，他们的秘密
酱搜索数十亿美元

739
00:35:28,460 --> 00:35:30,580
的网页为您的
公司是更好的，这些

740
00:35:30,580 --> 00:35:33,302
是种参数它们
最好应该能够做出。

741
00:35:33,302 --> 00:35:35,010
或者至少这些都是
这样的东西

742
00:35:35,010 --> 00:35:40,211
这将拿出讨论，在
起码在一个非常正式的讨论。

743
00:35:40,211 --> 00:35:40,710
好吧。

744
00:35:40,710 --> 00:35:44,400
因此，本建议的东西
所谓的选择排序。

745
00:35:44,400 --> 00:35:48,200
不过，我要提出有
这样，太的其他方式。

746
00:35:48,200 --> 00:35:50,400
我真的不喜欢
有关本的算法

747
00:35:50,400 --> 00:35:54,400
是他继续往前走，或
有我走，来回

748
00:35:54,400 --> 00:35:56,930
和来回和来回。

749
00:35:56,930 --> 00:36:04,130
如果不是我是做
像这里这些数字

750
00:36:04,130 --> 00:36:08,200
和我只处理每
数字又因为我给它？

751
00:36:08,200 --> 00:36:10,780
>> 换句话说，这里的
我的号码列表。

752
00:36:10,780 --> 00:36:12,944
四，一，三，二。

753
00:36:12,944 --> 00:36:14,360
而且我要做到以下几点。

754
00:36:14,360 --> 00:36:17,230
我要插入的数字
属于他们的地方，而

755
00:36:17,230 --> 00:36:18,980
比选择它们一次一个。

756
00:36:18,980 --> 00:36:20,820
换句话说，这里的四个号码。

757
00:36:20,820 --> 00:36:22,430
>> 这是我最初的名单。

758
00:36:22,430 --> 00:36:25,290
我要去维护
实际上这里的新列表。

759
00:36:25,290 --> 00:36:26,710
因此，这是旧的列表。

760
00:36:26,710 --> 00:36:28,560
这是新的列表。

761
00:36:28,560 --> 00:36:30,220
我看到的数字四个第一。

762
00:36:30,220 --> 00:36:34,500
我的新列表最初是空的，
因此它是平凡的情况下

763
00:36:34,500 --> 00:36:36,410
四个现在什锦列表。

764
00:36:36,410 --> 00:36:39,560
我只是把我提供的电话号码，
而我把它在我的新名单。

765
00:36:39,560 --> 00:36:41,460
>> 这是新的列表排序？

766
00:36:41,460 --> 00:36:41,990
是啊。

767
00:36:41,990 --> 00:36:45,090
这是愚蠢的，因为只有一个
元素，但它绝对排序。

768
00:36:45,090 --> 00:36:46,390
没有什么不合适的。

769
00:36:46,390 --> 00:36:49,290
这是更有趣，这种算法，
当我移动到下一个步骤。

770
00:36:49,290 --> 00:36:50,550
>> 现在我有一个。

771
00:36:50,550 --> 00:36:55,430
因此，人们当然，属于在
开始的时候还是这个新的列表的末尾？

772
00:36:55,430 --> 00:36:56,360
开始的时候。

773
00:36:56,360 --> 00:36:58,530
所以，我现在要做的一些工作。

774
00:36:58,530 --> 00:37:01,410
我已经采取了一些
我的标记自由

775
00:37:01,410 --> 00:37:03,120
通过只绘制的东西
在这里我想他们，

776
00:37:03,120 --> 00:37:05,320
但是这不是真的
准确在计算机中。

777
00:37:05,320 --> 00:37:08,530
一台电脑，因为我们知道，有
RAM或随机存取存储器，

778
00:37:08,530 --> 00:37:12,411
这就是一个字节，
另一个字节一个字节。

779
00:37:12,411 --> 00:37:14,910
如果你有一个千兆字节
RAM，你有十亿字节，

780
00:37:14,910 --> 00:37:16,680
但他们身在一个位置。

781
00:37:16,680 --> 00:37:19,540
你不能只是移动的东西左右
通过绘制在黑板上

782
00:37:19,540 --> 00:37:20,750
哪里都行。

783
00:37:20,750 --> 00:37:24,090
所以，如果我的新名单有
在内存四个地点，

784
00:37:24,090 --> 00:37:27,480
不幸的是，四是
已经在错误的地方。

785
00:37:27,480 --> 00:37:30,410
>> 因此，要插入的头号
我不能只是画在这里。

786
00:37:30,410 --> 00:37:31,901
此存储器位置不存在。

787
00:37:31,901 --> 00:37:35,150
这将是欺骗，我一直
形象地欺骗几分钟

788
00:37:35,150 --> 00:37:35,800
这里。

789
00:37:35,800 --> 00:37:40,950
所以真的，如果我想提出一个在这里，
我不得不暂时复制四个

790
00:37:40,950 --> 00:37:43,030
然后把一个人也没有。

791
00:37:43,030 --> 00:37:45,500
>> 这很好，这是正确的，
这是技术上是可行的，

792
00:37:45,500 --> 00:37:48,410
但知道这是额外的工作。

793
00:37:48,410 --> 00:37:50,460
我不只是把数字到位。

794
00:37:50,460 --> 00:37:53,026
我首先要移动
号码，然后把它放到地方，

795
00:37:53,026 --> 00:37:54,650
让我有种我一倍的工作量。

796
00:37:54,650 --> 00:37:55,660
所以记住这一点。

797
00:37:55,660 --> 00:37:57,120
>> 但我现在有了这个元素来完成。

798
00:37:57,120 --> 00:37:59,056
现在，我要抢位列第三。

799
00:37:59,056 --> 00:38:00,430
其中，当然，它属于？

800
00:38:00,430 --> 00:38:01,480
在这两者之间。

801
00:38:01,480 --> 00:38:03,650
我不能再骗
，只是把它放在那里，

802
00:38:03,650 --> 00:38:06,770
因为，再一次，这种记忆
在物理位置。

803
00:38:06,770 --> 00:38:10,900
所以我要复制四个
并把三个在这里。

804
00:38:10,900 --> 00:38:11,550
没什么大不了的。

805
00:38:11,550 --> 00:38:14,610
这只是一个额外的步骤
again--感觉很便宜。

806
00:38:14,610 --> 00:38:16,445
>> 但现在我移动到两个。

807
00:38:16,445 --> 00:38:17,820
这两个，当然，属于这里。

808
00:38:17,820 --> 00:38:20,990
现在你开始怎么看
工作可以堆积起来。

809
00:38:20,990 --> 00:38:23,520
现在，我有什么做的？

810
00:38:23,520 --> 00:38:28,570
是的，我要搬到四，
然后，我有三个拷贝，

811
00:38:28,570 --> 00:38:31,200
现在我可以插入两个。

812
00:38:31,200 --> 00:38:34,460
而赶上这个
算法，有趣的是，

813
00:38:34,460 --> 00:38:41,050
是，假设我们有一个更极端
情况是假设八，七，

814
00:38:41,050 --> 00:38:45,150
六个五，四，三，二，一。

815
00:38:45,150 --> 00:38:49,450
这一点，在许多情况下，
最坏的情况下，

816
00:38:49,450 --> 00:38:51,570
因为混账东西
简直是倒退。

817
00:38:51,570 --> 00:38:53,670
>> 它并不真正的
本影响的算法，

818
00:38:53,670 --> 00:38:55,940
因为Ben的选择
排序他要保持

819
00:38:55,940 --> 00:38:58,359
来回通过列表。

820
00:38:58,359 --> 00:39:01,150
而且，因为他总是在寻找
通过整个其余列表

821
00:39:01,150 --> 00:39:02,858
没关系
其中元件是。

822
00:39:02,858 --> 00:39:05,630
但是，在这种情况下，我插
approach--让我们试试这个。

823
00:39:05,630 --> 00:39:08,616
>> 这样一，二，三，四，
五，六，七，八。

824
00:39:08,616 --> 00:39:11,630
一二三四，
五，六，七，八。

825
00:39:11,630 --> 00:39:14,320
我将采取八，
和我在哪里把它？

826
00:39:14,320 --> 00:39:17,260
好吧，在我名单的开始，
因为这个新列表进行排序。

827
00:39:17,260 --> 00:39:18,760
我把它划掉。

828
00:39:18,760 --> 00:39:20,551
>> 我在哪里把七？

829
00:39:20,551 --> 00:39:21,050
该死。

830
00:39:21,050 --> 00:39:23,174
它需要去那里，所以
我必须做一些复制。

831
00:39:23,174 --> 00:39:26,820

832
00:39:26,820 --> 00:39:28,480
而现在的七个放在这里。

833
00:39:28,480 --> 00:39:29,860
现在，我移动到六人。

834
00:39:29,860 --> 00:39:30,980
现在，甚至更多的工作。

835
00:39:30,980 --> 00:39:32,570
>> 八就到这里去。

836
00:39:32,570 --> 00:39:33,920
七就到这里去。

837
00:39:33,920 --> 00:39:35,450
现在的六个可以去这里。

838
00:39:35,450 --> 00:39:37,950
现在我抢五。

839
00:39:37,950 --> 00:39:40,560
现在八已去
在这里，七就到这里去，

840
00:39:40,560 --> 00:39:43,650
Six于这里走，
现在五，重复动作。

841
00:39:43,650 --> 00:39:46,610
而且我非常
不断移动它。

842
00:39:46,610 --> 00:39:52,950
>> 所以最终，这个算法 - 我们将
把它插入实际上类别 - 

843
00:39:52,950 --> 00:39:55,020
有很多工作了。

844
00:39:55,020 --> 00:39:56,970
这只是不同
实物比本的工作。

845
00:39:56,970 --> 00:40:00,090
Ben的工作已让我相信
来回所有的时间，

846
00:40:00,090 --> 00:40:03,510
选择下一个最小的
连连元件。

847
00:40:03,510 --> 00:40:06,660
所以这是这个极具视觉方面的工作。

848
00:40:06,660 --> 00:40:10,600
>> 此其它算法，这仍然是
correct--会得到这份工作done--

849
00:40:10,600 --> 00:40:12,800
只是改变的工作量。

850
00:40:12,800 --> 00:40:15,420
它看起来像最初你
节约，因为你只是

851
00:40:15,420 --> 00:40:19,190
处理每个元素
前面不走所有

852
00:40:19,190 --> 00:40:20,930
通过列表像本的方式了。

853
00:40:20,930 --> 00:40:25,300
但问题是，尤其是在这些
疯狂的情况下，这一切都反了，

854
00:40:25,300 --> 00:40:27,830
你是那种只
推迟的辛勤工作

855
00:40:27,830 --> 00:40:30,360
直到你有修正自己的错误。

856
00:40:30,360 --> 00:40:33,919
>> 所以，如果你能想象这
八七十六加五

857
00:40:33,919 --> 00:40:36,710
后来四加三和二
在列表中移动自己的方式，

858
00:40:36,710 --> 00:40:39,060
我们只是改变了
工种我们正在做的。

859
00:40:39,060 --> 00:40:42,340
而不是在做
开始我的迭代，

860
00:40:42,340 --> 00:40:45,250
我只是在做它在
每次迭代结束。

861
00:40:45,250 --> 00:40:50,550
因此，事实证明，这种算法，
同样，一般称为插入排序，

862
00:40:50,550 --> 00:40:52,190
也是为n的平方的数量级。

863
00:40:52,190 --> 00:40:56,480
它实际上是没有更好的，
没有更好的。

864
00:40:56,480 --> 00:41:00,810
>> 但是，有一个第三个方法
我会鼓励我们考虑，

865
00:41:00,810 --> 00:41:02,970
这是这样的。

866
00:41:02,970 --> 00:41:07,850
因此，假设我的名单，为简单起见
再次，为四，一，三，

867
00:41:07,850 --> 00:41:11,080
two--只有四个数字。

868
00:41:11,080 --> 00:41:13,300
本有很好的直觉，
良好的人的直觉

869
00:41:13,300 --> 00:41:16,340
之前，由我们解决了整个
列出eventually--插入排序。

870
00:41:16,340 --> 00:41:18,020
我哄我们一起。

871
00:41:18,020 --> 00:41:22,530
但是让我们考虑
解决这个列表最简单的方法。

872
00:41:22,530 --> 00:41:24,110
>> 未排序此列表。

873
00:41:24,110 --> 00:41:26,130
为什么？

874
00:41:26,130 --> 00:41:31,920
在英语中，解释原因
它实际上没有进行排序。

875
00:41:31,920 --> 00:41:33,400
是什么意思不进行排序？

876
00:41:33,400 --> 00:41:34,220
>> 学生：这不是连续的。

877
00:41:34,220 --> 00:41:34,990
>> DAVID MALAN：不是顺序。

878
00:41:34,990 --> 00:41:35,822
给我一个例子。

879
00:41:35,822 --> 00:41:37,180
>> 学生：把它们的顺序。

880
00:41:37,180 --> 00:41:37,440
>> DAVID MALAN：OK。

881
00:41:37,440 --> 00:41:38,790
给我一个更具体的例子。

882
00:41:38,790 --> 00:41:39,832
>> 学生：升序排列。

883
00:41:39,832 --> 00:41:41,206
DAVID MALAN：不按升序排列。

884
00:41:41,206 --> 00:41:42,100
更精确。

885
00:41:42,100 --> 00:41:45,190
我不知道你的上升是什么意思。

886
00:41:45,190 --> 00:41:47,150
怎么了？

887
00:41:47,150 --> 00:41:49,930
>> 学生：最小的
号码是不是在第一空间。

888
00:41:49,930 --> 00:41:51,140
>> DAVID MALAN：最小号的
未在第一空间。

889
00:41:51,140 --> 00:41:52,120
更加具体。

890
00:41:52,120 --> 00:41:55,000
我开始流行起来。

891
00:41:55,000 --> 00:41:59,470
我们计算，但
什么是坏了吗？

892
00:41:59,470 --> 00:42:00,707
>> 学生：数值序列。

893
00:42:00,707 --> 00:42:02,040
DAVID MALAN：数值序列。

894
00:42:02,040 --> 00:42:04,248
每个人的一种保管的
它这里 - 非常高的水平。

895
00:42:04,248 --> 00:42:07,450
只是从字面上告诉我什么
错误就像一个五十岁的威力。

896
00:42:07,450 --> 00:42:08,310
>> 学生：加一。

897
00:42:08,310 --> 00:42:08,750
>> DAVID MALAN：那是什么？

898
00:42:08,750 --> 00:42:09,610
>> 学生：加一。

899
00:42:09,610 --> 00:42:11,235
>> DAVID MALAN：你的意思是加一？

900
00:42:11,235 --> 00:42:12,754

901
00:42:12,754 --> 00:42:14,170
给我一个不同的五十岁。

902
00:42:14,170 --> 00:42:16,840

903
00:42:16,840 --> 00:42:18,330
怎么了，妈妈？

904
00:42:18,330 --> 00:42:19,940
有什么不对，爸爸？

905
00:42:19,940 --> 00:42:22,808
你是什​​么意思这是没有排序？

906
00:42:22,808 --> 00:42:24,370
>> 学生：这是不正确的地方。

907
00:42:24,370 --> 00:42:25,580
>> DAVID MALAN：什么是
不正确的地方？

908
00:42:25,580 --> 00:42:26,174
>> 学生：四。

909
00:42:26,174 --> 00:42:27,090
DAVID MALAN：OK，好了。

910
00:42:27,090 --> 00:42:29,110
因此，四是不是哪里它应该是。

911
00:42:29,110 --> 00:42:30,590
特别是，这是正确的？

912
00:42:30,590 --> 00:42:33,000
四一，第一
两个数字我明白了。

913
00:42:33,000 --> 00:42:34,930
这是正确的吗？

914
00:42:34,930 --> 00:42:36,427
不，他们不按顺序，对不对？

915
00:42:36,427 --> 00:42:38,135
其实，现在想想
关于计算机了。

916
00:42:38,135 --> 00:42:40,824
它只能看看也许有，
在once--也许两件事

917
00:42:40,824 --> 00:42:43,240
实际上只做一件事
的时间，但它可以至少

918
00:42:43,240 --> 00:42:45,790
看一件事则
紧挨着它未来的事情。

919
00:42:45,790 --> 00:42:47,380
>> 所以这些都是为了？

920
00:42:47,380 --> 00:42:48,032
当然不是。

921
00:42:48,032 --> 00:42:48,740
所以，你知道吗？

922
00:42:48,740 --> 00:42:51,020
我们为什么不带宝贝
步骤解决这个问题

923
00:42:51,020 --> 00:42:53,410
而不是做这些花哨
算法，如奔，其中

924
00:42:53,410 --> 00:42:56,440
他用那种固定它
通过该列表循环

925
00:42:56,440 --> 00:42:59,670
而不是做我做什么，在哪里
因为我们去我只是一种固定的呢？

926
00:42:59,670 --> 00:43:03,650
我们只是从字面上打破
order--数字顺序的概念，

927
00:43:03,650 --> 00:43:06,990
调用它不管你want--
在这些两两比较。

928
00:43:06,990 --> 00:43:07,590
>> 四一。

929
00:43:07,590 --> 00:43:09,970
这是正确的顺序？

930
00:43:09,970 --> 00:43:11,310
因此，让我们解决这个问题。

931
00:43:11,310 --> 00:43:14,700
一和四，然后
我们只是复制。

932
00:43:14,700 --> 00:43:15,560
好吧，好了。

933
00:43:15,560 --> 00:43:17,022
我固定的一到四。

934
00:43:17,022 --> 00:43:18,320
三加二？

935
00:43:18,320 --> 00:43:18,820
没有。

936
00:43:18,820 --> 00:43:21,690
让我说的话我的手指相匹配。

937
00:43:21,690 --> 00:43:23,695
四加三？

938
00:43:23,695 --> 00:43:27,930
>> 这不是为了，所以我打算
做一，三，四两。

939
00:43:27,930 --> 00:43:28,680
OK，不错。

940
00:43:28,680 --> 00:43:32,310
现在，四个和两个？

941
00:43:32,310 --> 00:43:33,370
我们需要解决这个问题了。

942
00:43:33,370 --> 00:43:36,700
这样一，三，二，四。

943
00:43:36,700 --> 00:43:39,820
因此，它是排序？

944
00:43:39,820 --> 00:43:43,170
没有，但它是更接近排序？

945
00:43:43,170 --> 00:43:48,930
>> 这是因为我们解决了这个
错，我们修正了这个错误，

946
00:43:48,930 --> 00:43:50,370
我们修正了这个错误。

947
00:43:50,370 --> 00:43:52,420
因此，我们只有三种错误可以说。

948
00:43:52,420 --> 00:43:58,100
仍然没有真正审视排序，但
它客观上更接近排序

949
00:43:58,100 --> 00:44:00,080
因为我们修正了一些这些错误的。

950
00:44:00,080 --> 00:44:02,047
>> 现在我该怎么做？

951
00:44:02,047 --> 00:44:03,630
我有种到达列表的末尾。

952
00:44:03,630 --> 00:44:05,680
我似乎已经固定
所有的错误，但没有。

953
00:44:05,680 --> 00:44:08,510
因为在这种情况下，一些数字
可能已经接近向上冒泡

954
00:44:08,510 --> 00:44:10,410
其他数字，
还是乱序。

955
00:44:10,410 --> 00:44:12,951
因此，让我们做一遍，我会
只是做的地方这个时候。

956
00:44:12,951 --> 00:44:14,170
一个和三个？

957
00:44:14,170 --> 00:44:14,720
没关系。

958
00:44:14,720 --> 00:44:16,070
三加二？

959
00:44:16,070 --> 00:44:17,560
当然没有，所以让我们改变这种状况。

960
00:44:17,560 --> 00:44:19,160
所以，二，三。

961
00:44:19,160 --> 00:44:21,340
三，四？

962
00:44:21,340 --> 00:44:24,370
现在，让我们只是
尤其是迂腐在这里。

963
00:44:24,370 --> 00:44:26,350
难道排序？

964
00:44:26,350 --> 00:44:29,280
你们人类知道它的排序。

965
00:44:29,280 --> 00:44:30,400
>> 我应该再次尝试。

966
00:44:30,400 --> 00:44:31,900
所以奥利维亚提议我再试试。

967
00:44:31,900 --> 00:44:32,530
为什么？

968
00:44:32,530 --> 00:44:35,810
因为计算机没有
我们人眼的奢侈

969
00:44:35,810 --> 00:44:38,080
只是一眼back-- OK，我完成了。

970
00:44:38,080 --> 00:44:41,610
如何计算机确定
该列表现在排序？

971
00:44:41,610 --> 00:44:44,590
机械。

972
00:44:44,590 --> 00:44:47,650
>> 我应该通过
一次，且仅当我

973
00:44:47,650 --> 00:44:51,190
不做/发现任何错误我可以
然后得出结论：随着计算机，是的，

974
00:44:51,190 --> 00:44:51,980
我们是好去。

975
00:44:51,980 --> 00:44:54,850
所以一和二，二和
三，三，四。

976
00:44:54,850 --> 00:44:58,030
现在我可以明确地说，这是
排序，因为我不需要做任何改变。

977
00:44:58,030 --> 00:45:01,940
现在，这将是一个错误，只是
如果我愚蠢，电脑，

978
00:45:01,940 --> 00:45:05,640
又问那些相同的问题
期待不同的答案。

979
00:45:05,640 --> 00:45:07,110
不应该发生。

980
00:45:07,110 --> 00:45:08,600
>> 所以现在的列表进行排序。

981
00:45:08,600 --> 00:45:12,630
不幸的是，运行时间
该算法也可为N的平方。

982
00:45:12,630 --> 00:45:13,130
为什么？

983
00:45:13,130 --> 00:45:19,520
因为你有n个数，并在
最坏的情况下，你必须移动n个数

984
00:45:19,520 --> 00:45:23,637
n次，因为你必须坚持下去
回查和潜在的修复

985
00:45:23,637 --> 00:45:24,220
这些数字。

986
00:45:24,220 --> 00:45:26,280
我们可以做的更
正式的分析了。

987
00:45:26,280 --> 00:45:29,530
>> 所以这是大家说，我们已经采取了
三种不同的方法，一是

988
00:45:29,530 --> 00:45:32,210
他们立即直观
关闭距离Ben蝙蝠

989
00:45:32,210 --> 00:45:35,170
我的建议的插入
排序这个

990
00:45:35,170 --> 00:45:38,540
在这里你那种忽视
林为最初的树木。

991
00:45:38,540 --> 00:45:41,760
不过，如果你退一步，
瞧，我们已经解决了分拣概念。

992
00:45:41,760 --> 00:45:43,824
因此，这是，敢说，
一个较低的水平也许

993
00:45:43,824 --> 00:45:45,740
比一些其他的
算法，但让我们

994
00:45:45,740 --> 00:45:48,550
看看我们能不能​​想象
这些通过这种方式。

995
00:45:48,550 --> 00:45:51,450
>> 因此，这是一些很不错的
软件，有人

996
00:45:51,450 --> 00:45:56,110
使用丰富多彩的酒吧这是写
要做到以下几点我们。

997
00:45:56,110 --> 00:45:57,736
每个这些棒的代表编号。

998
00:45:57,736 --> 00:46:00,026
德勒酒吧，大
数目，更小的吧，

999
00:46:00,026 --> 00:46:00,990
数越小。

1000
00:46:00,990 --> 00:46:05,880
因此，最好我们希望有一个漂亮的金字塔
它开始时很小，并得到大，

1001
00:46:05,880 --> 00:46:08,330
这将意味着
这些酒吧进行排序。

1002
00:46:08,330 --> 00:46:11,200
所以我要继续前进，选择，
例如，本算法

1003
00:46:11,200 --> 00:46:13,990
序曲一选择排序。

1004
00:46:13,990 --> 00:46:16,220
>> 并注意它在做什么。

1005
00:46:16,220 --> 00:46:18,670
他们选择的方式
想象这个算法

1006
00:46:18,670 --> 00:46:22,090
是的，就像我是
通过我的名单散步，

1007
00:46:22,090 --> 00:46:24,710
这一计划是走
通过其号码列表，

1008
00:46:24,710 --> 00:46:28,160
突出每个粉红色
它在看数字。

1009
00:46:28,160 --> 00:46:32,360
什么是关于现在发生？

1010
00:46:32,360 --> 00:46:35,154
>> 最小数
我还是奔突然发现

1011
00:46:35,154 --> 00:46:36,820
被移动到列表的开头。

1012
00:46:36,820 --> 00:46:40,037
并注意他们做了逐出
这是有数字，

1013
00:46:40,037 --> 00:46:41,120
这就是完美的罚款。

1014
00:46:41,120 --> 00:46:42,600
我没有进入详细程度。

1015
00:46:42,600 --> 00:46:44,308
但是，我们需要把
这个数字的地方，

1016
00:46:44,308 --> 00:46:47,775
所以我们只是把它移到
已创建空位。

1017
00:46:47,775 --> 00:46:49,900
所以，我要加速这一
起来，因为否则它

1018
00:46:49,900 --> 00:46:51,871
变得非常乏味迅速。

1019
00:46:51,871 --> 00:46:55,800

1020
00:46:55,800 --> 00:46:58,600
动画speed--我们走吧。

1021
00:46:58,600 --> 00:47:01,850
所以，现在同样的原理
我申请，但你

1022
00:47:01,850 --> 00:47:06,540
可以开始感受算法，如果你
会的，或者看它多一点清晰。

1023
00:47:06,540 --> 00:47:13,190
并且该算法具有的效果
选择下一个最小的元素，

1024
00:47:13,190 --> 00:47:16,422
所以你要开始
看到它坡道在左边。

1025
00:47:16,422 --> 00:47:19,130
并在每次迭代中，我
提出的，它确实有点不太工作。

1026
00:47:19,130 --> 00:47:21,921
它没有走一路
返回清单的左端，

1027
00:47:21,921 --> 00:47:23,900
因为它已经
那些知道的排序。

1028
00:47:23,900 --> 00:47:28,129
因此，那种感觉就像是
加速，即使每个步骤是

1029
00:47:28,129 --> 00:47:29,420
取的时间相同。

1030
00:47:29,420 --> 00:47:31,600
这里还有剩余更少的步骤。

1031
00:47:31,600 --> 00:47:35,240
现在你可以种感受
算法清理它的结束，

1032
00:47:35,240 --> 00:47:37,040
实际上现在它的排序。

1033
00:47:37,040 --> 00:47:41,620
>> 所以插入排序是全部完成。

1034
00:47:41,620 --> 00:47:43,600
我需要重新随机阵列。

1035
00:47:43,600 --> 00:47:45,940
并注意我可以
保持它随机化，

1036
00:47:45,940 --> 00:47:50,630
我们会得到一个近似
同样的方法，插入排序。

1037
00:47:50,630 --> 00:47:55,050
让我慢下来到这里。

1038
00:47:55,050 --> 00:47:56,915
让我们开始，超过。

1039
00:47:56,915 --> 00:47:57,414
停止。

1040
00:47:57,414 --> 00:48:00,662

1041
00:48:00,662 --> 00:48:02,410
>> 让我们跳过四人。

1042
00:48:02,410 --> 00:48:03,200
在那里，我们走了。

1043
00:48:03,200 --> 00:48:04,190
他们随机排列。

1044
00:48:04,190 --> 00:48:05,555
在这里，我们go--插入排序。

1045
00:48:05,555 --> 00:48:10,260

1046
00:48:10,260 --> 00:48:12,800
玩。

1047
00:48:12,800 --> 00:48:17,280
请注意，它在处理每
元素遇到向右走，

1048
00:48:17,280 --> 00:48:20,282
但是，如果它是属于在
放错了地方的通知

1049
00:48:20,282 --> 00:48:21,740
所有这些都发生在工作。

1050
00:48:21,740 --> 00:48:24,700
我们必须保持更多的转移
和以上的元素，以腾出空间

1051
00:48:24,700 --> 00:48:27,340
对于一个我们要到位。

1052
00:48:27,340 --> 00:48:30,740
>> 因此，我们专注于
仅列表的左端。

1053
00:48:30,740 --> 00:48:34,460
请注意，我们甚至还没有看at--我们
在粉红色的东西都没有突出

1054
00:48:34,460 --> 00:48:35,610
在右边。

1055
00:48:35,610 --> 00:48:38,180
我们只是处理
这些问题，因为我们去，

1056
00:48:38,180 --> 00:48:40,430
但我们创造了很多
为自己的工作依然。

1057
00:48:40,430 --> 00:48:44,410
所以，如果我们加快这
现在去完成，

1058
00:48:44,410 --> 00:48:46,210
它有不同的感觉确实如此。

1059
00:48:46,210 --> 00:48:50,150
这只是专注于左侧，但到底
做一个小更多的工作作为needed--

1060
00:48:50,150 --> 00:48:53,230
一种平滑的事情
过去，固定的东西，

1061
00:48:53,230 --> 00:48:58,350
但最终处理
每个元素一次一个

1062
00:48:58,350 --> 00:49:07,740
直到我们到达曲风很好，我们
都知道这是怎么回事结束，

1063
00:49:07,740 --> 00:49:09,700
所以这是一个有点或许给人留下深刻印象。

1064
00:49:09,700 --> 00:49:12,830
>> 但清单中end--
spoiler--将被排序。

1065
00:49:12,830 --> 00:49:15,300
因此，让我们来看看最后一之一。

1066
00:49:15,300 --> 00:49:16,840
我们不能只是现在跳过。

1067
00:49:16,840 --> 00:49:18,000
我们快到了。

1068
00:49:18,000 --> 00:49:19,980
二去，一去。

1069
00:49:19,980 --> 00:49:22,680
瞧。

1070
00:49:22,680 --> 00:49:23,450
优秀。

1071
00:49:23,450 --> 00:49:27,220
>> 所以，现在让我们做最后一人一个，
再以随机冒泡排序。

1072
00:49:27,220 --> 00:49:31,690
并注意这里，尤其是如果我慢
下来，这也保持俯冲通过。

1073
00:49:31,690 --> 00:49:36,830
但是请注意，它只是使成对
comparisons--排序当地的解决方案。

1074
00:49:36,830 --> 00:49:39,050
但是，只要我们得到
在粉红色的列表的末尾，

1075
00:49:39,050 --> 00:49:40,690
什么将不得不再次发生？

1076
00:49:40,690 --> 00:49:44,539

1077
00:49:44,539 --> 00:49:46,830
是的，这将有
重新开始，因为它只

1078
00:49:46,830 --> 00:49:49,870
固定配对错误。

1079
00:49:49,870 --> 00:49:53,120
和可能已揭示还有一些。

1080
00:49:53,120 --> 00:49:58,950
所以，如果你的速度这件事，你会
看到的是，多顾名思义，

1081
00:49:58,950 --> 00:50:01,870
较小的elements--或者说，
大elements--开始

1082
00:50:01,870 --> 00:50:03,740
泡到顶部，如果你愿意。

1083
00:50:03,740 --> 00:50:07,380
和较小的元素是
开始气泡向下到左侧。

1084
00:50:07,380 --> 00:50:10,780
事实上，这是一种
视觉效果为好。

1085
00:50:10,780 --> 00:50:17,150
所以这将结束整理
在一个非常类似的方式，也是。

1086
00:50:17,150 --> 00:50:19,160
>> 我们不必纠缠
在这个特别的。

1087
00:50:19,160 --> 00:50:21,010
现在让我开这个。

1088
00:50:21,010 --> 00:50:24,040
还有一些其他的排序算法
在世界上，几其中

1089
00:50:24,040 --> 00:50:25,580
在这里拍摄的。

1090
00:50:25,580 --> 00:50:29,960
尤其是对学习者谁不
一定视觉或数学，

1091
00:50:29,960 --> 00:50:31,930
因为我们以前那样，我们可以
也做到这一点audially

1092
00:50:31,930 --> 00:50:34,210
如果我们完善与此相关联。

1093
00:50:34,210 --> 00:50:36,990
而只是为了好玩，这里有一个
几个不同的算法，

1094
00:50:36,990 --> 00:50:40,950
特别是其中一个你
要注意的是所谓的“合并排序”。

1095
00:50:40,950 --> 00:50:43,250
>> 它实际上是一个根本
更好的算法，

1096
00:50:43,250 --> 00:50:45,860
这样归并排序，一
你即将看到的那些，

1097
00:50:45,860 --> 00:50:49,170
不是n阶平方。

1098
00:50:49,170 --> 00:50:57,280
它的n倍登录的顺序
N，这实际上是小的，因此

1099
00:50:57,280 --> 00:50:58,940
比其他三个更快。

1100
00:50:58,940 --> 00:51:00,670
而且还有其他的一对夫妇
傻那些我们拭目以待。

1101
00:51:00,670 --> 00:51:01,933
>> 所以在这里，我们去一些声音。

1102
00:51:01,933 --> 00:51:06,620

1103
00:51:06,620 --> 00:51:10,490
这是插入排序，如此反复
它只是处理的元素

1104
00:51:10,490 --> 00:51:13,420
因为他们来。

1105
00:51:13,420 --> 00:51:17,180
这是冒泡排序，所以它的
考虑到他们在同一时间对。

1106
00:51:17,180 --> 00:51:22,030

1107
00:51:22,030 --> 00:51:24,490
再次，最大的元素
被鼓泡到顶部。

1108
00:51:24,490 --> 00:51:38,098

1109
00:51:38,098 --> 00:51:41,710
>> 接下来选择排序。

1110
00:51:41,710 --> 00:51:45,420
这是Ben的算法，其中
他再次选择的迭代

1111
00:51:45,420 --> 00:51:46,843
下一个最小的元素。

1112
00:51:46,843 --> 00:51:49,801

1113
00:51:49,801 --> 00:51:53,900
再次，现在你真的可以听到
它加快了，但只有在目前为止

1114
00:51:53,900 --> 00:51:58,230
因为它做的越来越少
在每次迭代运行。

1115
00:51:58,230 --> 00:52:04,170
这是一个更快，归并排序，
这是排序的数字集群

1116
00:52:04,170 --> 00:52:05,971
在一起，然后将它们结合起来。

1117
00:52:05,971 --> 00:52:07,720
所以look--左
一半已经排序。

1118
00:52:07,720 --> 00:52:14,165
>> 现在它的分选的右半和
现在它打算将它们合二为一。

1119
00:52:14,165 --> 00:52:19,160
这就是所谓的“侏儒排序。”

1120
00:52:19,160 --> 00:52:23,460
你可以种看到
它会来回，

1121
00:52:23,460 --> 00:52:27,950
一点点在这里固定的工作，
那里之前它进入新的工作。

1122
00:52:27,950 --> 00:52:32,900

1123
00:52:32,900 --> 00:52:33,692
就是这样。

1124
00:52:33,692 --> 00:52:36,400
还有另外一种，这是
真的只是为学术目的，

1125
00:52:36,400 --> 00:52:40,980
所谓的“愚蠢的排序，”这需要
您的数据，随机进行排序，

1126
00:52:40,980 --> 00:52:43,350
如果是排序，然后检查。

1127
00:52:43,350 --> 00:52:47,880
如果不是的话，它重新排序它
随机，检查它是否排序，

1128
00:52:47,880 --> 00:52:49,440
如果不重复。

1129
00:52:49,440 --> 00:52:52,660
在理论上，概率性
这将完成，

1130
00:52:52,660 --> 00:52:54,140
但经过相当多的时间。

1131
00:52:54,140 --> 00:52:56,930
这还不是最
高效的算法。

1132
00:52:56,930 --> 00:53:02,550
因此，对这些有任何疑问
特殊的算法或任何

1133
00:53:02,550 --> 00:53:04,720
相关那里吗？

1134
00:53:04,720 --> 00:53:09,430
>> 好了，现在让我们梳理出什么都
这些线，我一直在画

1135
00:53:09,430 --> 00:53:15,090
什么我假设电脑
可以引擎盖下做的。

1136
00:53:15,090 --> 00:53:18,650
我认为，所有这些数字
我一直drawing--他们需要得到

1137
00:53:18,650 --> 00:53:21,330
某处存储在存储器中。

1138
00:53:21,330 --> 00:53:24,130
现在，我们要摆脱这个家伙了。

1139
00:53:24,130 --> 00:53:30,110
>> 所以在一块内存
computer--所以RAM DIMM是

1140
00:53:30,110 --> 00:53:35,480
我们搜索了昨天，双
列直插式内存module--看起来是这样的。

1141
00:53:35,480 --> 00:53:39,370
并且每个这些小的黑色芯片
是一定数量的字节，一般。

1142
00:53:39,370 --> 00:53:44,380
然后将金销仿若
它连接到计算机电线，

1143
00:53:44,380 --> 00:53:47,521
和绿碳化硅板仅仅是
是什么让一切都在一起。

1144
00:53:47,521 --> 00:53:48,770
那么，这究竟意味着什么？

1145
00:53:48,770 --> 00:53:53,180
如果我有点画这个同样的画面，
让我们假设为简单

1146
00:53:53,180 --> 00:53:55,280
这DIMM，双
列直插内存模块，

1147
00:53:55,280 --> 00:54:00,530
是的RAM一千兆的一千兆字节
记忆，这是多少字节总数是多少？

1148
00:54:00,530 --> 00:54:02,100
一千兆是多少字节？

1149
00:54:02,100 --> 00:54:04,860

1150
00:54:04,860 --> 00:54:06,030
比那更多的。

1151
00:54:06,030 --> 00:54:09,960
1124是公斤，1000。

1152
00:54:09,960 --> 00:54:11,730
米加是万人。

1153
00:54:11,730 --> 00:54:14,570
GIGA是一个数十亿。

1154
00:54:14,570 --> 00:54:15,070
>> 我在撒谎？

1155
00:54:15,070 --> 00:54:16,670
我们甚至可以读取标签？

1156
00:54:16,670 --> 00:54:19,920
这实际上是128
千兆字节，所以它的更多。

1157
00:54:19,920 --> 00:54:22,130
但我们会假装这
仅仅是一千兆字节。

1158
00:54:22,130 --> 00:54:25,640
因此，这意味着有一个十亿
提供给我的内存字节

1159
00:54:25,640 --> 00:54:29,770
或8十亿位，但我们要
在字节方面谈现在，

1160
00:54:29,770 --> 00:54:30,750
向前进。

1161
00:54:30,750 --> 00:54:36,330
>> 所以，这是什么意思是，这是
一个字节，这是另外一个字节，

1162
00:54:36,330 --> 00:54:38,680
这是另外一个字节，
如果我们真的想

1163
00:54:38,680 --> 00:54:43,280
要具体我们将不得不
画一个十亿的小广场。

1164
00:54:43,280 --> 00:54:44,320
但是，这是什么意思？

1165
00:54:44,320 --> 00:54:46,420
好吧，让我放大
在这张图片。

1166
00:54:46,420 --> 00:54:50,900
如果我已经得到的东西看起来
现在这个样子，这是四个字节。

1167
00:54:50,900 --> 00:54:53,710
>> 所以，我可以把四个数字在这里。

1168
00:54:53,710 --> 00:54:54,990
一二三四。

1169
00:54:54,990 --> 00:55:00,170
或者，我可以把四个字母或符号。

1170
00:55:00,170 --> 00:55:02,620
“嘿！”可以去那里，
因为每个字母，

1171
00:55:02,620 --> 00:55:04,370
我们前面所讨论的，
可以表示

1172
00:55:04,370 --> 00:55:06,650
用八位或ASCII或一个字节。

1173
00:55:06,650 --> 00:55:09,370
所以，换句话说，你可以
把8个十亿里面的东西

1174
00:55:09,370 --> 00:55:11,137
的记忆这一棒。

1175
00:55:11,137 --> 00:55:14,345
现在，这是什么意思把东西背
备份内存来支持这样吗？

1176
00:55:14,345 --> 00:55:17,330
这是一个程序员
称之为“阵列”。

1177
00:55:17,330 --> 00:55:21,250
在计算机程序中，你不觉得
关于底层硬件本身。

1178
00:55:21,250 --> 00:55:24,427
你只是觉得自己的作为有
访问十亿字节总，

1179
00:55:24,427 --> 00:55:26,010
你可以任何你想做的事情。

1180
00:55:26,010 --> 00:55:27,880
但为了方便
这是一般有用

1181
00:55:27,880 --> 00:55:31,202
保持你的记忆权
彼此相邻这样。

1182
00:55:31,202 --> 00:55:33,660
所以，如果我放大this--
因为我们肯定不会

1183
00:55:33,660 --> 00:55:39,310
画一个小十亿squares--
让我们假设这个委员会代表

1184
00:55:39,310 --> 00:55:40,610
的内存棒了。

1185
00:55:40,610 --> 00:55:43,800
而我就画多达我
标记结束了在这里给我的。

1186
00:55:43,800 --> 00:55:46,420

1187
00:55:46,420 --> 00:55:52,300
所以现在我们有一棒
对板载内存

1188
00:55:52,300 --> 00:55:56,400
那种有一，二，三，四，五，
六个一，二，三，四，五，六，

1189
00:55:56,400 --> 00:56:01,130
seven--所以42字节
存储器上的屏幕总。

1190
00:56:01,130 --> 00:56:01,630
谢谢。

1191
00:56:01,630 --> 00:56:02,838
是的，我做算术的权利。

1192
00:56:02,838 --> 00:56:05,120
所以42字节的内存在这里。

1193
00:56:05,120 --> 00:56:06,660
那么，这实际上意味着什么呢？

1194
00:56:06,660 --> 00:56:09,830
那么，一个计算机程序员
实际上一般

1195
00:56:09,830 --> 00:56:12,450
认为这种内存寻址。

1196
00:56:12,450 --> 00:56:16,630
换句话说，每一个这些
在存储器位置，在硬件，

1197
00:56:16,630 --> 00:56:18,030
具有唯一的地址。

1198
00:56:18,030 --> 00:56:22,020
>> 它不是一体布​​拉特尔复杂
广场，剑桥，马萨诸塞州，02138。

1199
00:56:22,020 --> 00:56:23,830
相反，它只是一个数字。

1200
00:56:23,830 --> 00:56:27,930
这是字节数为零，这是
之一，这是二，这是三个

1201
00:56:27,930 --> 00:56:30,327
这就是41。

1202
00:56:30,327 --> 00:56:30,910
等一下。

1203
00:56:30,910 --> 00:56:32,510
我想我说42刚才。

1204
00:56:32,510 --> 00:56:35,050

1205
00:56:35,050 --> 00:56:37,772
我开始在零算起，
所以这实际上是正确的。

1206
00:56:37,772 --> 00:56:40,980
现在我们不必实际绘制它
作为一个网格，如果它画成网格

1207
00:56:40,980 --> 00:56:43,520
我觉得其实事情
会有点误导。

1208
00:56:43,520 --> 00:56:46,650
什么是程序员，
在他或她自己的头脑，

1209
00:56:46,650 --> 00:56:50,310
一般认为这
内存就像磁带，

1210
00:56:50,310 --> 00:56:53,340
像一块遮蔽胶带
只是推移和永远

1211
00:56:53,340 --> 00:56:54,980
或者直到你耗尽内存。

1212
00:56:54,980 --> 00:56:59,200
所以，一种较为常见的方式绘制
而只是想想内存

1213
00:56:59,200 --> 00:57:03,710
会，这是字节零个，一个
两个，三个，然后点，小点，小点。

1214
00:57:03,710 --> 00:57:07,650
你总有这样的42个字节，甚至
虽然身体上它实际上可能

1215
00:57:07,650 --> 00:57:09,480
更多的东西这样。

1216
00:57:09,480 --> 00:57:12,850
>> 所以，如果你觉得现在的你
内存因为这，就像磁带，

1217
00:57:12,850 --> 00:57:17,640
这是一个程序员再次
将要求的存储器阵列。

1218
00:57:17,640 --> 00:57:20,660
而当你想实际存储
东西在计算机的内存，

1219
00:57:20,660 --> 00:57:23,290
你一般做店里的东西
后端到背靠背到后端。

1220
00:57:23,290 --> 00:57:25,010
因此，我们一直在谈论数字。

1221
00:57:25,010 --> 00:57:30,880
而当我想解决问题
样四，一，三，二，

1222
00:57:30,880 --> 00:57:33,820
即使我只是画
只有数字四个一，三，

1223
00:57:33,820 --> 00:57:39,490
两个在板，而电脑会
真的有这样的设置在内存中。

1224
00:57:39,490 --> 00:57:43,347
>> 而这将是旁边
两人在计算机的内存？

1225
00:57:43,347 --> 00:57:44,680
那么，有没有答案。

1226
00:57:44,680 --> 00:57:45,770
我们真的不知道。

1227
00:57:45,770 --> 00:57:48,200
并且，只要该
电脑并不需要它，

1228
00:57:48,200 --> 00:57:51,440
它不必关心什么是下一个
该数字确实关心。

1229
00:57:51,440 --> 00:57:55,130
而当我在前面一台电脑说
只能看一眼地址的时间，

1230
00:57:55,130 --> 00:57:56,170
这是种原因。

1231
00:57:56,170 --> 00:57:59,490
>> 不不同于记录
播放器和读取头

1232
00:57:59,490 --> 00:58:03,030
只能够看着某
槽在物理老派的纪录

1233
00:58:03,030 --> 00:58:06,500
在一个时间，同样地
可以在计算机的感谢

1234
00:58:06,500 --> 00:58:09,810
到其CPU和其
英特尔指令集，

1235
00:58:09,810 --> 00:58:12,480
其指令中
从存储器中读

1236
00:58:12,480 --> 00:58:15,590
或保存到一个memory--
电脑只能看

1237
00:58:15,590 --> 00:58:19,210
在以时间 - 一个位置
有时它们的组合，

1238
00:58:19,210 --> 00:58:21,770
但在同一时间真的只是一个地点。

1239
00:58:21,770 --> 00:58:24,770
所以，当我们在做
这些不同的算法，

1240
00:58:24,770 --> 00:58:28,110
我不只是写在
vacuum--四，一，三，二。

1241
00:58:28,110 --> 00:58:30,849
这些数字实际上属于
某处物理存储器中。

1242
00:58:30,849 --> 00:58:32,890
因此，有小小的
晶体管或某种

1243
00:58:32,890 --> 00:58:35,840
下面的电子的
罩存储这些值。

1244
00:58:35,840 --> 00:58:40,460
>> 和总共多少比特
现在参与其中，只是要清楚吗？

1245
00:58:40,460 --> 00:58:45,580
因此，这是四个字节，或者
现在它的32位总。

1246
00:58:45,580 --> 00:58:49,280
因此，实际上有32个零和
那些组成这四件事。

1247
00:58:49,280 --> 00:58:52,070
甚至还有更多的在这里，但
再次，我们不关心这个。

1248
00:58:52,070 --> 00:58:55,120
>> 所以，现在让我们来问另外一个
问题使用内存，

1249
00:58:55,120 --> 00:58:57,519
因为，在端
这一天是方差。

1250
00:58:57,519 --> 00:59:00,310
不管是什么，我们可能会做
的计算机上，在一天结束时

1251
00:59:00,310 --> 00:59:02,560
硬件仍是
同样的引擎盖下面。

1252
00:59:02,560 --> 00:59:04,670
我将如何存储一个字吗？

1253
00:59:04,670 --> 00:59:09,710
那么，在一台电脑一个字像
“嘿！”将存储就是这样的。

1254
00:59:09,710 --> 00:59:12,300
如果你想要一个更长
一句话，你可以简单地

1255
00:59:12,300 --> 00:59:19,120
覆盖该说点什么
如“你好”，并存储在这里。

1256
00:59:19,120 --> 00:59:23,930
>> 所以在这里，这contiguousness
实际上是一个优势，

1257
00:59:23,930 --> 00:59:26,530
因为一台电脑可以只
从右至左读。

1258
00:59:26,530 --> 00:59:28,680
但这里有一个问题。

1259
00:59:28,680 --> 00:59:33,480
在这个词的范围内，
H-E-L-L-O，感叹号，

1260
00:59:33,480 --> 00:59:38,740
如何才能对计算机知道在哪里
字开始，这里所说的结束？

1261
00:59:38,740 --> 00:59:41,690

1262
00:59:41,690 --> 00:59:43,800
在数字的情况下，
如何做电脑

1263
00:59:43,800 --> 00:59:48,396
不知过了多久序列
数字是或者它启动？

1264
00:59:48,396 --> 00:59:50,270
哦，原来out--
我们不会去过多

1265
00:59:50,270 --> 00:59:54,970
这个级别的detail--
电脑在内存中移动的东西

1266
00:59:54,970 --> 00:59:57,800
从字面上这些地址的方式。

1267
00:59:57,800 --> 01:00:02,080
因此，在一台电脑，如果你
编写代码来存储的东西

1268
01:00:02,080 --> 01:00:05,800
喜欢的话，你在做什么
真正做的是打字

1269
01:00:05,800 --> 01:00:11,320
那记得在表达式
计算机的内存这话。

1270
01:00:11,320 --> 01:00:14,370
因此，让我做一个非常，
很简单的例子。

1271
01:00:14,370 --> 01:00:18,260
>> 我要继续前进，
打开一个简单的文本程序，

1272
01:00:18,260 --> 01:00:20,330
我要去创造
一个名为hello.c的。

1273
01:00:20,330 --> 01:00:22,849
大多数的这些信息，我们
不会进入的很详细，

1274
01:00:22,849 --> 01:00:25,140
但我会写一
计划在同日而语，

1275
01:00:25,140 --> 01:00:31,140
C.这是更为吓人，
我认为，不是从无到有，

1276
01:00:31,140 --> 01:00:32,490
但它的精神非常相似。

1277
01:00:32,490 --> 01:00:34,364
事实上，这些卷曲
braces--你可以种

1278
01:00:34,364 --> 01:00:37,820
想到了什么我只是做的了。

1279
01:00:37,820 --> 01:00:39,240
>> 让我们做到这一点，其实。

1280
01:00:39,240 --> 01:00:45,100
当绿旗点击，
做到以下几点。

1281
01:00:45,100 --> 01:00:50,210
我想打印出“你好”。

1282
01:00:50,210 --> 01:00:51,500
因此，这是现在的伪代码。

1283
01:00:51,500 --> 01:00:53,000
我有点模糊的线条。

1284
01:00:53,000 --> 01:00:56,750
在C，这种语言我说
一下，这条线的打印打招呼

1285
01:00:56,750 --> 01:01:01,940
实际上变成的“printf”与
一些括号和分号。

1286
01:01:01,940 --> 01:01:03,480
>> 但它是完全一样的想法。

1287
01:01:03,480 --> 01:01:06,730
而这种非常人性化
“当绿旗点击”变

1288
01:01:06,730 --> 01:01:10,182
在更为神秘的“INT主要作废。”

1289
01:01:10,182 --> 01:01:12,890
这确实没有映射，
所以我只是要忽略。

1290
01:01:12,890 --> 01:01:17,210
不过，花括号，如
弧形拼图这样。

1291
01:01:17,210 --> 01:01:18,700
>> 所以，你可以种猜测。

1292
01:01:18,700 --> 01:01:22,357
即使你以前从未编程，
这是什么程序可能吗？

1293
01:01:22,357 --> 01:01:25,560

1294
01:01:25,560 --> 01:01:28,000
可能是打印Hello
带有感叹号。

1295
01:01:28,000 --> 01:01:29,150
>> 因此，让我们试试吧。

1296
01:01:29,150 --> 01:01:30,800
我要保存它。

1297
01:01:30,800 --> 01:01:34,000
而这又正是一个非常
老学校环境。

1298
01:01:34,000 --> 01:01:35,420
我无法点击，我不能再拖累。

1299
01:01:35,420 --> 01:01:36,910
我必须键入命令。

1300
01:01:36,910 --> 01:01:41,320
所以我想运行我的程序，所以
我可以这样做，喜欢的hello.c。

1301
01:01:41,320 --> 01:01:42,292
这是我跑的文件。

1302
01:01:42,292 --> 01:01:43,500
别急，我缺​​少的一个步骤。

1303
01:01:43,500 --> 01:01:46,470
什么了，我们说是一个必要的
步骤，如C语言？

1304
01:01:46,470 --> 01:01:49,470
我刚刚编写的源
代码，但我还需要什么呢？

1305
01:01:49,470 --> 01:01:50,670
是的，我需要一个编译器。

1306
01:01:50,670 --> 01:01:57,670
所以在这里我的Mac电脑上，我有一个
程序调用GCC，GNU C编译器，

1307
01:01:57,670 --> 01:02:03,990
这让我做this--转
我的源代码之中，我们会打电话给它，

1308
01:02:03,990 --> 01:02:04,930
机器代码。

1309
01:02:04,930 --> 01:02:10,180
>> 我可以看到的是，
再次，如下，这些

1310
01:02:10,180 --> 01:02:14,090
是零和我
从我的源代码创建的，

1311
01:02:14,090 --> 01:02:15,730
所有的零和一。

1312
01:02:15,730 --> 01:02:17,770
如果我想运行
我的程序 - 它将发生

1313
01:02:17,770 --> 01:02:23,010
被调用的a.out为
历史reasons--“你好”。

1314
01:02:23,010 --> 01:02:24,070
我可以再次运行。

1315
01:02:24,070 --> 01:02:25,690
你好你好你好。

1316
01:02:25,690 --> 01:02:27,430
它似乎是工作。

1317
01:02:27,430 --> 01:02:31,000
>> 但是，在某处意味着我
计算机的内存是词语

1318
01:02:31,000 --> 01:02:35,279
H-E-L-L-O，感叹号。

1319
01:02:35,279 --> 01:02:38,070
而事实证明，就像顺便说一句，
什么是计算机通常会

1320
01:02:38,070 --> 01:02:40,550
这样做，它知道在哪里
事情开始并end--它的

1321
01:02:40,550 --> 01:02:42,460
要在这里把一个特殊符号。

1322
01:02:42,460 --> 01:02:46,064
和公约是把
在单词的末尾数为零

1323
01:02:46,064 --> 01:02:48,230
让你知道它在哪里
实际上结束，这样你

1324
01:02:48,230 --> 01:02:52,750
不要让打印出越来越多
人物比你实际打算。

1325
01:02:52,750 --> 01:02:55,400
>> 但这里的外卖，甚至
虽然这是相当神秘，

1326
01:02:55,400 --> 01:02:58,140
是它的最终
相对简单。

1327
01:02:58,140 --> 01:03:04,550
你被赋予某种磁带，空白
上，你可以写信空间。

1328
01:03:04,550 --> 01:03:07,150
您只需有一个
特殊符号，如随意

1329
01:03:07,150 --> 01:03:10,316
数字零，将在年底
你的话让计算机知道，

1330
01:03:10,316 --> 01:03:13,410
哦，我应该后停止打印
我看到了感叹号。

1331
01:03:13,410 --> 01:03:16,090
因为接下来的事情有
是零ASCII值，

1332
01:03:16,090 --> 01:03:19,125
或空字符作为
有人会调用它。

1333
01:03:19,125 --> 01:03:21,500
但有样的问题
在这里，让我们恢复

1334
01:03:21,500 --> 01:03:23,320
到了一会儿号码。

1335
01:03:23,320 --> 01:03:28,720
假设我这样做，事实上，
有数字数组，

1336
01:03:28,720 --> 01:03:30,730
并假设
节目我写的

1337
01:03:30,730 --> 01:03:34,680
就像一个档次书老师
和老师的课堂。

1338
01:03:34,680 --> 01:03:38,720
而这个程序可以让他或她
输入他们的学生成绩

1339
01:03:38,720 --> 01:03:39,960
在测验。

1340
01:03:39,960 --> 01:03:43,750
并假设学生得到
100他们的第一次测验，也许

1341
01:03:43,750 --> 01:03:49,920
像80上的下一个，那么一个
75，然后在第四测验90。

1342
01:03:49,920 --> 01:03:54,150
>> 所以在这个故事这一点上，
数组大小四。

1343
01:03:54,150 --> 01:03:58,470
还有更绝的内存在
计算机，但该阵列，可以这么说，

1344
01:03:58,470 --> 01:04:00,350
是规模四。

1345
01:04:00,350 --> 01:04:06,060
假设现在老师要
分配第五测验的类。

1346
01:04:06,060 --> 01:04:08,510
好了，事情之一，他
或她将不得不做

1347
01:04:08,510 --> 01:04:10,650
现在是这里存储一个额外的价值。

1348
01:04:10,650 --> 01:04:15,490
但是，如果阵列的老师有
在这个程序中创建的大小的，

1349
01:04:15,490 --> 01:04:22,440
与阵列的问题之一是
你不能只是不断加入到内存。

1350
01:04:22,440 --> 01:04:26,470
因为如果有什么的另一部分
程序有单词“哎”就在那里？

1351
01:04:26,470 --> 01:04:29,650
>> 换句话说，我的记忆可以
用于在程序什么。

1352
01:04:29,650 --> 01:04:33,250
如果事先我输入的，嘿嘿，
我想输入4测验分数，

1353
01:04:33,250 --> 01:04:34,784
他们可能会去这里和这里。

1354
01:04:34,784 --> 01:04:37,700
如果你突然改变了主意
后来，说我想第五测验

1355
01:04:37,700 --> 01:04:40,872
分数，你不能只是
把它放在任何你想要的，

1356
01:04:40,872 --> 01:04:42,580
因为如果这个
存储器正在被使用

1357
01:04:42,580 --> 01:04:45,990
东西else--其他程序
或程序的某些其他特征

1358
01:04:45,990 --> 01:04:46,910
你正在运行？

1359
01:04:46,910 --> 01:04:50,650
所以，你必须想提前
要如何存储你的数据，

1360
01:04:50,650 --> 01:04:54,480
因为现在你已经绘
自己变成一个数字角落。

1361
01:04:54,480 --> 01:04:57,280
>> 因此，老师可能代替
编写一个程序时说

1362
01:04:57,280 --> 01:04:59,360
存储他或她的
档次，你知道吗？

1363
01:04:59,360 --> 01:05:04,180
我要提出要求，
我写程序时，

1364
01:05:04,180 --> 01:05:12,070
我想零，一，二，三，
四，五，六，八年级总。

1365
01:05:12,070 --> 01:05:15,320
这样一，二，三，四，
五，六，七，八。

1366
01:05:15,320 --> 01:05:18,612
教师可以刚过分配
写他或她的节目时记忆

1367
01:05:18,612 --> 01:05:19,570
并说，你知道吗？

1368
01:05:19,570 --> 01:05:22,236
我永远不会分配更多
不是在一个学期8测验。

1369
01:05:22,236 --> 01:05:23,130
这只是疯狂。

1370
01:05:23,130 --> 01:05:24,470
我永远也不会分配的。

1371
01:05:24,470 --> 01:05:28,270
使这样，他或她有
灵活存储学生的分数，

1372
01:05:28,270 --> 01:05:33,010
像75，90，也许一个额外的地方
学生获得加分，105。

1373
01:05:33,010 --> 01:05:36,130
>> 但是，如果老师从来不
使用这些三个空格，

1374
01:05:36,130 --> 01:05:38,860
这里有一个直观的外卖。

1375
01:05:38,860 --> 01:05:41,410
他或她只是浪费空间。

1376
01:05:41,410 --> 01:05:44,790
因此，换句话说，有这
在编程中常见的权衡

1377
01:05:44,790 --> 01:05:48,241
在这里你可以分配
正是尽可能多的内存，只要你想，

1378
01:05:48,241 --> 01:05:51,490
它的好处是，你是超级
efficient--你不会被浪费

1379
01:05:51,490 --> 01:05:54,640
在all--但其缺点
是什么，如果你改变主意的时候

1380
01:05:54,640 --> 01:05:58,780
使用要存储方案
比你更多的数据原本打算。

1381
01:05:58,780 --> 01:06:03,030
>> 因此，也许解决的办法是，那么，
编写程序以这样的方式

1382
01:06:03,030 --> 01:06:05,605
他们使用更多的内存
比他们实际需要。

1383
01:06:05,605 --> 01:06:07,730
这样，你就不会
运行到该问题，

1384
01:06:07,730 --> 01:06:09,730
但你是浪费的。

1385
01:06:09,730 --> 01:06:12,960
而更多的内存，你的程序使用，
正如我们昨天所讨论的，少

1386
01:06:12,960 --> 01:06:15,410
内存可用
对于其他方案，

1387
01:06:15,410 --> 01:06:18,790
你的电脑可能会降低越快
下来，因为虚拟内存。

1388
01:06:18,790 --> 01:06:22,670
所以，理想的解决方案可能是什么？

1389
01:06:22,670 --> 01:06:24,610
>> 欠清分似乎不好。

1390
01:06:24,610 --> 01:06:27,030
过度分配显得不好。

1391
01:06:27,030 --> 01:06:31,120
那么，什么可能是一个更好的解决办法？

1392
01:06:31,120 --> 01:06:32,390
重新分配。

1393
01:06:32,390 --> 01:06:33,590
更有活力​​。

1394
01:06:33,590 --> 01:06:37,520
不要强迫自己选择
先验的，在开始的时候，你想要什么。

1395
01:06:37,520 --> 01:06:41,370
而且绝对不要过度分配，
免得你是一种浪费。

1396
01:06:41,370 --> 01:06:45,770
>> 所以要实现这个目标，我们
需要抛出这个数据结构，

1397
01:06:45,770 --> 01:06:48,100
可以这么说，流连忘返。

1398
01:06:48,100 --> 01:06:51,080
还等什么程序员
通常会使用

1399
01:06:51,080 --> 01:06:55,940
被称为不是东西
数组，但一个链表。

1400
01:06:55,940 --> 01:07:00,860
换句话说，他或她会
开始思考自己的记忆

1401
01:07:00,860 --> 01:07:05,280
作为善良的形状，他们
可以通过以下方式绘制。

1402
01:07:05,280 --> 01:07:08,520
如果我想存储在一个数
一个program--所以它的九月，

1403
01:07:08,520 --> 01:07:12,600
我给我的学生进行测试;我想要
存储学生的第一次测验，

1404
01:07:12,600 --> 01:07:16,220
他们在它 - 我得到了100
要问我的电脑，

1405
01:07:16,220 --> 01:07:19,540
由我有计划的方式
写的，对于一个内存块。

1406
01:07:19,540 --> 01:07:22,570
我要去存储
在其100号，仅此而已。

1407
01:07:22,570 --> 01:07:24,820
>> 然后，几个星期后
当我拿到我的第二个测验，

1408
01:07:24,820 --> 01:07:27,890
它的时间输入
在这90％，我准备

1409
01:07:27,890 --> 01:07:32,129
问电脑，哎，电脑，
我可以有内存另一块？

1410
01:07:32,129 --> 01:07:34,170
这是怎么回事给我这个
记忆空块。

1411
01:07:34,170 --> 01:07:39,370
我打算把在90号，
但在我的程序以某种方式或other--

1412
01:07:39,370 --> 01:07:42,100
我们不会担心
对于this--我需要的语法

1413
01:07:42,100 --> 01:07:44,430
以某种方式链接这些东西放在一起。

1414
01:07:44,430 --> 01:07:47,430
我将它们连起来用
看起来像这里的箭头。

1415
01:07:47,430 --> 01:07:50,050
>> 出现的第三次测验，
我会说，哎，电脑，

1416
01:07:50,050 --> 01:07:51,680
给我的记忆另一块。

1417
01:07:51,680 --> 01:07:54,660
而且我要放下
不管是什么，像75，

1418
01:07:54,660 --> 01:07:56,920
我有这个链条
现在一起莫名其妙。

1419
01:07:56,920 --> 01:08:00,290
四测验到来，也许
这是朝着学期结束。

1420
01:08:00,290 --> 01:08:03,140
而到那个时候我的程序
可能是使用内存

1421
01:08:03,140 --> 01:08:05,540
所有的地方，遍布身体。

1422
01:08:05,540 --> 01:08:08,170
所以只是踢，我
要得出这样的规定

1423
01:08:08,170 --> 01:08:11,260
quiz--我忘了那是什么;一世
想也许80或something--

1424
01:08:11,260 --> 01:08:12,500
来这里的路上。

1425
01:08:12,500 --> 01:08:15,920
>> 但是，这很好，因为形象地
我要画这条线。

1426
01:08:15,920 --> 01:08:19,063
换句话说，在现实中，
在您的计算机硬件，

1427
01:08:19,063 --> 01:08:20,979
首次得分可能
在这里结束，因为它是

1428
01:08:20,979 --> 01:08:22,529
就在学期的开始。

1429
01:08:22,529 --> 01:08:25,810
下一个可能会在这里结束
因为时间有点已过

1430
01:08:25,810 --> 01:08:27,210
并且程序继续运行。

1431
01:08:27,210 --> 01:08:30,060
接下来的成绩，这是
75，可能是在这里。

1432
01:08:30,060 --> 01:08:33,420
而最后的比分可能是
80，这是在这里。

1433
01:08:33,420 --> 01:08:38,729
>> 因此，在现实中，身体上，这可能是
你的计算机内存的模样。

1434
01:08:38,729 --> 01:08:41,569
但是，这不是一个有用的精神
范式的计算机程序员。

1435
01:08:41,569 --> 01:08:44,649
为什么要关注所在
赫克您的数据结束了？

1436
01:08:44,649 --> 01:08:46,200
你只是想存储数据。

1437
01:08:46,200 --> 01:08:49,390
>> 这有点像我们的讨论
早期绘制立方体。

1438
01:08:49,390 --> 01:08:52,200
为什么你关心什么
的角度为立方体

1439
01:08:52,200 --> 01:08:53,740
你怎么也得把画呢？

1440
01:08:53,740 --> 01:08:54,950
你只想要一个立方体。

1441
01:08:54,950 --> 01:08:57,359
同样在这里，你
只是想成绩簿。

1442
01:08:57,359 --> 01:08:59,559
你只是要考虑的
此作为数字列表。

1443
01:08:59,559 --> 01:09:01,350
谁在乎它是如何的
在硬件中实现？

1444
01:09:01,350 --> 01:09:05,180
>> 因此，现在的抽象
在这里这张图片。

1445
01:09:05,180 --> 01:09:07,580
这是一个链表，如
程序员会调用它，

1446
01:09:07,580 --> 01:09:10,640
只要你有一个
名单，显然数字。

1447
01:09:10,640 --> 01:09:14,990
但它形象地联系在一起
通过这些箭头的方式，

1448
01:09:14,990 --> 01:09:18,510
所有这些箭头are--下方
油烟机，如果你好奇，

1449
01:09:18,510 --> 01:09:23,210
回想起我们的物理硬件有
地址零，一，二，三，四。

1450
01:09:23,210 --> 01:09:28,465
所有这些箭头就像一张地图
或指示，如果在那里90 is--现在

1451
01:09:28,465 --> 01:09:29,090
我计数。

1452
01:09:29,090 --> 01:09:31,750
>> 零，一，二，三，
四，五，六，七。

1453
01:09:31,750 --> 01:09:35,640
它看起来像90处于
内存地址七位数。

1454
01:09:35,640 --> 01:09:38,460
所有这些箭头都是
就像一张小废

1455
01:09:38,460 --> 01:09:42,439
这是给予指示，
程序，说按照这个地图

1456
01:09:42,439 --> 01:09:43,880
去的位置七人。

1457
01:09:43,880 --> 01:09:46,680
在那里你会发现
学生的测验第二次得分。

1458
01:09:46,680 --> 01:09:52,100
同时，75--如果我继续这样，
这是七，八，九，10，11，12，

1459
01:09:52,100 --> 01:09:54,240
13，14，15。

1460
01:09:54,240 --> 01:09:59,080
>> 这等箭头只是代表
一个地图存储位置15。

1461
01:09:59,080 --> 01:10:02,550
但同样，程序员一般不
不会在意这些细节。

1462
01:10:02,550 --> 01:10:05,530
而且在大多数所有的编程
今天语言，程序员

1463
01:10:05,530 --> 01:10:10,490
甚至不知道在内存
这些数字实际上是。

1464
01:10:10,490 --> 01:10:14,830
所有他或她必须关心的是
它们以某种方式连接在一起

1465
01:10:14,830 --> 01:10:18,390
在像这样的数据结构。

1466
01:10:18,390 --> 01:10:21,580
>> 但事实证明，没有
让过于技术化。

1467
01:10:21,580 --> 01:10:27,430
但是，仅仅因为我们可以或许
买得起这里有这样的讨论，

1468
01:10:27,430 --> 01:10:33,630
假设我们重温
这里一个数组的这个问题。

1469
01:10:33,630 --> 01:10:35,780
让我们来看看，如果我们去后悔这里。

1470
01:10:35,780 --> 01:10:42,950
这是100，90，75，和80。

1471
01:10:42,950 --> 01:10:44,980
>> 让我简要地做了这种说法。

1472
01:10:44,980 --> 01:10:48,980
这是一个数组，并且再次，在
阵列的显着特征

1473
01:10:48,980 --> 01:10:52,400
是所有的数据都回
返回到memory--回字面上

1474
01:10:52,400 --> 01:10:56,830
一个字节或者四个字节，
字节的一些固定数目之遥。

1475
01:10:56,830 --> 01:11:00,710
在一个链表，这是我们可以借鉴
这样，在底层谁

1476
01:11:00,710 --> 01:11:02,000
知道哪里的东西是什么？

1477
01:11:02,000 --> 01:11:03,630
它甚至不需要流这样。

1478
01:11:03,630 --> 01:11:06,050
一些数据可能是
回左那里。

1479
01:11:06,050 --> 01:11:07,530
你甚至不知道。

1480
01:11:07,530 --> 01:11:15,430
>> 所以用一个数组，你有一个
特征称为随机存取。

1481
01:11:15,430 --> 01:11:20,570
及什么随机存取装置是
计算机可以立即跳到

1482
01:11:20,570 --> 01:11:22,730
到在阵列的任何位置。

1483
01:11:22,730 --> 01:11:23,580
为什么？

1484
01:11:23,580 --> 01:11:26,000
由于计算机知道
该第一位置是

1485
01:11:26,000 --> 01:11:29,540
零个，一个，两个，和三个。

1486
01:11:29,540 --> 01:11:33,890
>> 所以，如果你想从去
这个元素到下一个元素，

1487
01:11:33,890 --> 01:11:36,099
你从字面上看，在
计算机的心思，只是增加一个。

1488
01:11:36,099 --> 01:11:39,140
如果你想要去的第三个元素，
只需添加one--下一个元素，只是

1489
01:11:39,140 --> 01:11:40,290
加之一。

1490
01:11:40,290 --> 01:11:42,980
然而，在该版本
故事的，假设

1491
01:11:42,980 --> 01:11:46,080
目前的计算机正在
在或处理的数量100。

1492
01:11:46,080 --> 01:11:49,770
你怎么下
年级成绩簿？

1493
01:11:49,770 --> 01:11:52,560
>> 你要取七
步骤，这是任意的。

1494
01:11:52,560 --> 01:11:58,120
要进入下一个，你必须
采取另一种八个步骤去15。

1495
01:11:58,120 --> 01:12:02,250
换句话说，它不是一个
数字之间一定的间隙，

1496
01:12:02,250 --> 01:12:04,857
所以它只是需要的
计算机更多的时间点。

1497
01:12:04,857 --> 01:12:06,940
计算机有要搜索
通过订单记录

1498
01:12:06,940 --> 01:12:08,990
找到你要找的内容。

1499
01:12:08,990 --> 01:12:14,260
>> 因此而阵列往往是一个
快速的数据结构 - 因为你

1500
01:12:14,260 --> 01:12:17,610
可以从字面上只是做简单的算术题
并得到你想要通过添加一个，

1501
01:12:17,610 --> 01:12:21,300
为instance--一个链表，
你牺牲该功能。

1502
01:12:21,300 --> 01:12:24,020
你不能只从第一次去
第二至第三到第四。

1503
01:12:24,020 --> 01:12:25,240
你必须遵循的地图。

1504
01:12:25,240 --> 01:12:28,160
你必须采取更多的措施
获得这些价值，这

1505
01:12:28,160 --> 01:12:30,230
似乎是增加了成本。

1506
01:12:30,230 --> 01:12:35,910
因此，我们付出的代价，但什么是
该功能丹正在寻求在这里？

1507
01:12:35,910 --> 01:12:38,110
什么链表
显然允许我们这样做，

1508
01:12:38,110 --> 01:12:40,240
这是的原点
这个特别的故事吗？

1509
01:12:40,240 --> 01:12:43,250

1510
01:12:43,250 --> 01:12:43,830
>> 究竟。

1511
01:12:43,830 --> 01:12:46,220
一个充满活力的大小吧。

1512
01:12:46,220 --> 01:12:48,040
我们可以添加到这个列表。

1513
01:12:48,040 --> 01:12:51,430
我们甚至可以缩小列表，因此
那我们只使用尽可能多的内存

1514
01:12:51,430 --> 01:12:55,560
因为我们其实是想等
我们永远都不会过度分配。

1515
01:12:55,560 --> 01:12:58,470
>> 现在只要是真正挑剔的，
有一个隐藏的成本。

1516
01:12:58,470 --> 01:13:01,980
所以，你不应该只是让我信服
你认为这是一个引人注目的权衡。

1517
01:13:01,980 --> 01:13:04,190
这里有另一个隐藏的成本。

1518
01:13:04,190 --> 01:13:06,550
这样做的好处，是明确的，
是我们获得活力。

1519
01:13:06,550 --> 01:13:10,359
如果我想另一个元素，我可以
绘制和摆在那里的一个数字。

1520
01:13:10,359 --> 01:13:12,150
然后，我可以链接它
用图片这里，

1521
01:13:12,150 --> 01:13:14,970
而在这里，再一次，如果我
自己画到一个角落里，

1522
01:13:14,970 --> 01:13:19,410
如果别的东西已经在使用
这里的记忆，我的运气。

1523
01:13:19,410 --> 01:13:21,700
我自己画成​​角。

1524
01:13:21,700 --> 01:13:24,390
>> 但是，什么是隐藏
在这张照片的成本？

1525
01:13:24,390 --> 01:13:27,690
这不只是量
的时间，它需要

1526
01:13:27,690 --> 01:13:29,870
从这里到这里，
这七个步骤，然后

1527
01:13:29,870 --> 01:13:32,820
八步，这是一个以上。

1528
01:13:32,820 --> 01:13:34,830
什么是另一个隐藏的成本是多少？

1529
01:13:34,830 --> 01:13:35,440
不仅仅是时间。

1530
01:13:35,440 --> 01:13:44,790

1531
01:13:44,790 --> 01:13:49,940
其他信息
要实现这个图象。

1532
01:13:49,940 --> 01:13:53,210
>> 是啊，地图，这些小碎片
纸张，因为我把他们描述为。

1533
01:13:53,210 --> 01:13:55,650
这些arrows--那些不是免费的。

1534
01:13:55,650 --> 01:13:57,660
你知道computer--
什么是计算机。

1535
01:13:57,660 --> 01:13:58,790
它具有零和一。

1536
01:13:58,790 --> 01:14:03,170
如果你想表示箭头或
图或一个数字，你需要一些内存。

1537
01:14:03,170 --> 01:14:05,950
所以其他的价格你
支付一个链表，

1538
01:14:05,950 --> 01:14:09,070
一个共同的计算机科学
资源，也是空间。

1539
01:14:09,070 --> 01:14:11,710
>> 的确如此，所以常见的是，
权衡之中

1540
01:14:11,710 --> 01:14:15,580
设计软件工程
系统的时间和space--

1541
01:14:15,580 --> 01:14:18,596
您的成分是二，二生
你最昂贵的成分。

1542
01:14:18,596 --> 01:14:21,220
这是我花费更多的时间
因为我要遵守这个地图，

1543
01:14:21,220 --> 01:14:25,730
但它也花费了我更多的空间
因为我要保持这种地图各处。

1544
01:14:25,730 --> 01:14:28,730
因此希望，因为我们已经种
在昨天和今天的讨论，

1545
01:14:28,730 --> 01:14:31,720
是的好处
将大于成本。

1546
01:14:31,720 --> 01:14:33,870
>> 但是，这里没有明显的解决方案。

1547
01:14:33,870 --> 01:14:35,870
也许这是better--
一拉快速​​和肮脏的，

1548
01:14:35,870 --> 01:14:38,660
作为贾巴尔先前已经提出
在问题扔存储器。

1549
01:14:38,660 --> 01:14:42,520
随便买更多的内存，少思考
好好的解决这个问题，

1550
01:14:42,520 --> 01:14:44,595
并解决它更简单的方法。

1551
01:14:44,595 --> 01:14:46,720
事实上更早的时候，
我们谈到了权衡，

1552
01:14:46,720 --> 01:14:49,190
它不是空间
计算机和时间。

1553
01:14:49,190 --> 01:14:51,810
它是显影剂的时间，这
是另一个的资源。

1554
01:14:51,810 --> 01:14:54,829
>> 如此反复，正是这种平衡行为
试图决定其中那些事

1555
01:14:54,829 --> 01:14:55,870
你愿意花？

1556
01:14:55,870 --> 01:14:57,380
这是最便宜的？

1557
01:14:57,380 --> 01:15:01,040
这产生更好的结果？

1558
01:15:01,040 --> 01:15:01,540
是吗？

1559
01:15:01,540 --> 01:15:11,310

1560
01:15:11,310 --> 01:15:12,580
>> 的确。

1561
01:15:12,580 --> 01:15:15,970
在这种情况下，如果你
表示在maps--号码

1562
01:15:15,970 --> 01:15:18,820
这些被称为在许多语言
“指针”或“地址” - 

1563
01:15:18,820 --> 01:15:20,390
它的双空间。

1564
01:15:20,390 --> 01:15:24,390
这不一定是为双如果那样糟糕
现在我们只是存储号码。

1565
01:15:24,390 --> 01:15:27,410
假设我们被存储
在hospital--患者记录

1566
01:15:27,410 --> 01:15:30,870
所以皮尔森的姓名，电话号码，
社会安全号码，医生

1567
01:15:30,870 --> 01:15:31,540
历史。

1568
01:15:31,540 --> 01:15:34,160
这个盒子可能是多了，
更大，在这种情况

1569
01:15:34,160 --> 01:15:38,000
一个小小的指针的地址
接下来element--这不是什么大不了的事。

1570
01:15:38,000 --> 01:15:40,620
它是这样一个边缘
成本也没关系。

1571
01:15:40,620 --> 01:15:43,210
但是，在这种情况下，是啊，这是一个增加一倍。

1572
01:15:43,210 --> 01:15:45,290
好问题。

1573
01:15:45,290 --> 01:15:47,900
>> 让我们来谈谈时间
有点更具体。

1574
01:15:47,900 --> 01:15:50,380
什么是运行时间
进行搜索这个名单？

1575
01:15:50,380 --> 01:15:53,640
假设我想查询
通过所有学生的成绩，

1576
01:15:53,640 --> 01:15:55,980
有n值等级
在此数据结构中。

1577
01:15:55,980 --> 01:15:58,830
在这里，我们可以借
早期的词汇。

1578
01:15:58,830 --> 01:16:00,890
这是一个线性数据结构。

1579
01:16:00,890 --> 01:16:04,570
>> 为n的大O是什么需要得到
该数据结构的末尾，

1580
01:16:04,570 --> 01:16:08,410
whereas--，我们还没有看到
这before--数组给你

1581
01:16:08,410 --> 01:16:13,555
什么叫做固定的时间，这意味着
一个步骤或两个步骤或10 steps--

1582
01:16:13,555 --> 01:16:14,180
没关系。

1583
01:16:14,180 --> 01:16:15,440
它是一个固定的数目。

1584
01:16:15,440 --> 01:16:17,440
它无关
该数组的大小。

1585
01:16:17,440 --> 01:16:20,130
和其中的原因，
再次，是随机接入。

1586
01:16:20,130 --> 01:16:23,180
电脑可以立即刚
跳到另一个位置，

1587
01:16:23,180 --> 01:16:27,770
因为它们都是一样的
从一切距离。

1588
01:16:27,770 --> 01:16:29,112
没有涉及的想法。

1589
01:16:29,112 --> 01:16:31,900

1590
01:16:31,900 --> 01:16:32,400
好吧。

1591
01:16:32,400 --> 01:16:39,230
所以，如果我可以，让我尝试
画两个最终的照片。

1592
01:16:39,230 --> 01:16:42,830
一个非常常见的被称为哈希表。

1593
01:16:42,830 --> 01:16:51,120
所以激励的讨论，
让我想想如何做到这一点。

1594
01:16:51,120 --> 01:16:52,610
>> 那么这个怎么样？

1595
01:16:52,610 --> 01:16:55,160
假设该问题
我们现在要解决

1596
01:16:55,160 --> 01:16:58,360
在dictionary--正在实施
所以一大堆英文单词

1597
01:16:58,360 --> 01:16:59,330
管他呢。

1598
01:16:59,330 --> 01:17:02,724
和目标是能够回答
形式的问题，这是一个字？

1599
01:17:02,724 --> 01:17:04,640
所以，你想实现
拼写检查，只

1600
01:17:04,640 --> 01:17:07,220
像物理字典
，你可以看看东西英寸

1601
01:17:07,220 --> 01:17:10,490
假设我是用一个数组来做到这一点。

1602
01:17:10,490 --> 01:17:12,590
我能做到这一点。

1603
01:17:12,590 --> 01:17:20,756
>> 并假设的话是苹果
和香蕉和哈密瓜。

1604
01:17:20,756 --> 01:17:23,330

1605
01:17:23,330 --> 01:17:26,465
而且我想不出水果
即开始研发，所以我们只是

1606
01:17:26,465 --> 01:17:27,590
将有三种水果。

1607
01:17:27,590 --> 01:17:31,510
所以这是一个数组，我们
存储所有这些词

1608
01:17:31,510 --> 01:17:34,200
在本词典作为数组。

1609
01:17:34,200 --> 01:17:39,350
现在的问题，那么，是怎么回事
你能存储这些信息？

1610
01:17:39,350 --> 01:17:43,160
>> 好吧，我有点欺骗在这里，因为
每个字这些信件

1611
01:17:43,160 --> 01:17:44,490
真的是单个字节。

1612
01:17:44,490 --> 01:17:46,740
所以，如果我真的想成为
挑剔的，我真的应该

1613
01:17:46,740 --> 01:17:49,600
被除以成多
内存较小的块，

1614
01:17:49,600 --> 01:17:51,289
我们可以这样做。

1615
01:17:51,289 --> 01:17:53,580
但是，我们要碰上
同样的问题之前。

1616
01:17:53,580 --> 01:17:56,674
如果，因为韦氏或牛津
确实每year--他们添加单词

1617
01:17:56,674 --> 01:17:59,340
到dictionary--我们不
一定要画自己

1618
01:17:59,340 --> 01:18:00,780
与阵列的角落？

1619
01:18:00,780 --> 01:18:05,710
>> 因此，不是，也许是一个更聪明的方法
是把苹果在其自己的节点或箱，

1620
01:18:05,710 --> 01:18:11,190
因为我们会说，香蕉和
那么在这里，我们有哈密瓜。

1621
01:18:11,190 --> 01:18:14,990

1622
01:18:14,990 --> 01:18:16,790
而我们这些串起来的东西。

1623
01:18:16,790 --> 01:18:19,980
因此，这是该数组，
这是链表。

1624
01:18:19,980 --> 01:18:23,300
如果你不能完全看到，它只是
说“数组”，这表示“名单。”

1625
01:18:23,300 --> 01:18:25,780
>> 因此，我们有相同的
确切的问题和以前一样，

1626
01:18:25,780 --> 01:18:28,600
因此我们现在有
活力在我们的链接列表。

1627
01:18:28,600 --> 01:18:31,090
但是，我们有一个相当缓慢的字典。

1628
01:18:31,090 --> 01:18:32,870
假设我要查找一个字。

1629
01:18:32,870 --> 01:18:35,430
这可能需要我的n大O字
步骤，因为这个词可能

1630
01:18:35,430 --> 01:18:37,840
是一路在年底
列表，像哈密瓜。

1631
01:18:37,840 --> 01:18:40,600
而事实证明，
在编程，排序

1632
01:18:40,600 --> 01:18:42,700
数据的圣杯
结构是什么

1633
01:18:42,700 --> 01:18:46,620
，让你不断
时间像一个数组

1634
01:18:46,620 --> 01:18:50,870
但是仍然给你活力。

1635
01:18:50,870 --> 01:18:52,940
>> 因此，我们可以有两全其美？

1636
01:18:52,940 --> 01:18:55,570
事实上，也有一些是
称为哈希表

1637
01:18:55,570 --> 01:18:59,320
这可以让你做的正是
即，尽管近。

1638
01:18:59,320 --> 01:19:03,140
哈希表是一个票友
数据结构，我们

1639
01:19:03,140 --> 01:19:06,340
能想到的
一个array--组合

1640
01:19:06,340 --> 01:19:12,390
而我要画它
像this--和链表

1641
01:19:12,390 --> 01:19:17,310
我就画这样的在这里。

1642
01:19:17,310 --> 01:19:19,760
>> 而办法的事情
作品如下。

1643
01:19:19,760 --> 01:19:23,310

1644
01:19:23,310 --> 01:19:29,540
如果这个now--哈希table--
是我第三次的数据结构，

1645
01:19:29,540 --> 01:19:32,590
我想存储
在这句话，我不

1646
01:19:32,590 --> 01:19:35,440
只想存储所有的
也就是说背靠背背靠背。

1647
01:19:35,440 --> 01:19:37,430
我想利用一些
片的信息

1648
01:19:37,430 --> 01:19:40,330
有关会让词
我得到它，它的速度更快。

1649
01:19:40,330 --> 01:19:43,666
>> 因此，考虑的话苹果
和香蕉和哈密瓜，

1650
01:19:43,666 --> 01:19:45,040
我特意选择了这些话。

1651
01:19:45,040 --> 01:19:45,340
为什么？

1652
01:19:45,340 --> 01:19:47,631
什么样的根本
对三种不同？

1653
01:19:47,631 --> 01:19:49,950

1654
01:19:49,950 --> 01:19:51,484
什么是显而易见的？

1655
01:19:51,484 --> 01:19:52,900
他们开始与不同的字母。

1656
01:19:52,900 --> 01:19:53,900
>> 所以，你知道吗？

1657
01:19:53,900 --> 01:19:57,120
而不是把我所有的词语
同一个桶，可以这么说，

1658
01:19:57,120 --> 01:20:00,390
就像在一个大名单，为什么不
我至少尝试优化

1659
01:20:00,390 --> 01:20:04,180
并让我的名单1/26一样长。

1660
01:20:04,180 --> 01:20:07,440
一个引人注目的优化
可能是为什么不

1661
01:20:07,440 --> 01:20:10,650
我 - 当插入一个字
入这​​种数据结构，

1662
01:20:10,650 --> 01:20:14,300
到计算机的内存，为什么
不要我把所有的'一'字在这里，

1663
01:20:14,300 --> 01:20:17,270
这里所有的“B”字，
和所有的“C”字在这里？

1664
01:20:17,270 --> 01:20:24,610
因此，这最终将一个苹果
这里，这里这里的香蕉，哈密瓜，

1665
01:20:24,610 --> 01:20:25,730
等等。

1666
01:20:25,730 --> 01:20:31,700
>> 如果我有一个额外的
字like--什么其他？

1667
01:20:31,700 --> 01:20:36,640
苹果，香蕉，梨。

1668
01:20:36,640 --> 01:20:39,370
有人认为水果的
与一个，b或c开始？

1669
01:20:39,370 --> 01:20:40,570
Blueberry--完善。

1670
01:20:40,570 --> 01:20:43,990
那就是要在这里结束。

1671
01:20:43,990 --> 01:20:47,530
因此，我们似乎有一个
稍微更好的解决方案，

1672
01:20:47,530 --> 01:20:50,820
因为现在如果我想
搜索苹果，我

1673
01:20:50,820 --> 01:20:53,200
序曲一我不只是潜水
进入我的数据结构。

1674
01:20:53,200 --> 01:20:54,850
我不潜入我的电脑的内存中。

1675
01:20:54,850 --> 01:20:56,530
我先来看看第一个字母。

1676
01:20:56,530 --> 01:20:58,610
>> 这是一台电脑
科学家会说。

1677
01:20:58,610 --> 01:21:00,760
您散列到你的数据结构。

1678
01:21:00,760 --> 01:21:04,100
你把你的输入，这在
这种情况就像是苹果的一个字。

1679
01:21:04,100 --> 01:21:07,150
你分析它，看着
在这种情况下，第一个字母，

1680
01:21:07,150 --> 01:21:08,340
从而哈希处理。

1681
01:21:08,340 --> 01:21:10,950
散列是一个通用术语，由此
你拿东西作为输入

1682
01:21:10,950 --> 01:21:12,116
你产生一些输出。

1683
01:21:12,116 --> 01:21:15,090
并且，所述输出
情况是位置

1684
01:21:15,090 --> 01:21:18,150
要搜索，第一
位置，第二是地段，第三。

1685
01:21:18,150 --> 01:21:22,160
所以输入是苹果，
输出第一。

1686
01:21:22,160 --> 01:21:25,054
输入是香蕉，所述
输出应该是第二位。

1687
01:21:25,054 --> 01:21:27,220
输入是哈密瓜，
输出应该是第三个。

1688
01:21:27,220 --> 01:21:30,320
输入是蓝莓，该
输出应该再次成为第二位。

1689
01:21:30,320 --> 01:21:34,010
这就是可以帮助你拿
通过你的记忆快捷键

1690
01:21:34,010 --> 01:21:39,050
为了得到对话
或数据更加有效。

1691
01:21:39,050 --> 01:21:43,330
>> 现在，这种潜在的减少了我们的时间
多达三分之一的26

1692
01:21:43,330 --> 01:21:45,850
因为如果你认为你
有尽可能多的“一”字为“Z”

1693
01:21:45,850 --> 01:21:48,080
单词作为“Q”字，这
是不是真的realistic--

1694
01:21:48,080 --> 01:21:50,830
你将有跨越歪斜
在alphabet--的某些字母

1695
01:21:50,830 --> 01:21:53,204
但是，这将是一个增量
方法，确实允许

1696
01:21:53,204 --> 01:21:55,930
你去的话更迅速。

1697
01:21:55,930 --> 01:21:59,660
与在现实中，一复杂的
程序，世界的谷歌，

1698
01:21:59,660 --> 01:22:02,180
在天下 - 的Facebook的
他们将使用一个哈希表

1699
01:22:02,180 --> 01:22:03,740
对于很多不同的目的。

1700
01:22:03,740 --> 01:22:06,590
但是，他们不会如此天真
光看第一个字母

1701
01:22:06,590 --> 01:22:09,700
在苹果或香蕉或
梨或哈密瓜，

1702
01:22:09,700 --> 01:22:13,420
因为你可以看到这些
名单仍然可以长期做下去。

1703
01:22:13,420 --> 01:22:17,130
>> 所以这仍然可能是排序
的linear--所以有点慢，

1704
01:22:17,130 --> 01:22:19,980
像n的大O字
我们前面讨论。

1705
01:22:19,980 --> 01:22:25,290
那么什么是真正的好哈希表会
do--它将具有更大的阵列。

1706
01:22:25,290 --> 01:22:28,574
而且它会使用一个更
复杂的哈希函数，

1707
01:22:28,574 --> 01:22:30,240
因此，它不只是看看“一个。”

1708
01:22:30,240 --> 01:22:35,480
也许它着眼于“一个-P-P-L-e”和
不知何故这些转换五个字母

1709
01:22:35,480 --> 01:22:38,400
入位置，其中
苹果应存放。

1710
01:22:38,400 --> 01:22:42,660
我们只是天真地使用字母“A”
独自一人，因为它的简单好用。

1711
01:22:42,660 --> 01:22:44,600
>> 但哈希表，在
最后，你能想到的

1712
01:22:44,600 --> 01:22:47,270
作为组合
阵列，其中每一个

1713
01:22:47,270 --> 01:22:51,700
有一个链表，理想
应尽可能的短。

1714
01:22:51,700 --> 01:22:54,364
而这不是一个明显的解决方案。

1715
01:22:54,364 --> 01:22:57,280
事实上，大部分的微调
该那张引擎盖下方时

1716
01:22:57,280 --> 01:22:59,654
实施这些种类的
复杂的数据结构

1717
01:22:59,654 --> 01:23:01,640
是什么是正确的
所述阵列的长度是多少？

1718
01:23:01,640 --> 01:23:03,250
什么是正确的散列函数？

1719
01:23:03,250 --> 01:23:04,830
你如何保存，留作回忆？

1720
01:23:04,830 --> 01:23:07,249
>> 但是，如何实现快速
这种讨论

1721
01:23:07,249 --> 01:23:10,540
升级，无论是到目前为止，它是一种
超过一个人的头部在这一点上，这

1722
01:23:10,540 --> 01:23:11,360
是罚款。

1723
01:23:11,360 --> 01:23:18,820
但是，我们开始回忆，真
一些低级别和电子。

1724
01:23:18,820 --> 01:23:20,819
因此这又是本
抽象的主题，

1725
01:23:20,819 --> 01:23:23,610
在这里，一旦你开始采取
理所当然的，好了，我已经得到了它 - 有

1726
01:23:23,610 --> 01:23:26,680
物理内存，好，我知道，每
物理位置有一个地址，

1727
01:23:26,680 --> 01:23:29,910
好吧，我知道了，我可以代表
这些地址为arrows--

1728
01:23:29,910 --> 01:23:34,650
您可以非常迅速地开始有
更复杂的对话

1729
01:23:34,650 --> 01:23:38,360
到底似乎允许我们
要解决类似的问题搜索

1730
01:23:38,360 --> 01:23:41,620
和排序更有效。

1731
01:23:41,620 --> 01:23:44,190
放心吧，太...
因为我觉得这

1732
01:23:44,190 --> 01:23:48,700
是我们已经进入了一些最深
的proper--我们这些已经CS主题

1733
01:23:48,700 --> 01:23:51,880
在这一天半完成
点你通常会做主持

1734
01:23:51,880 --> 01:23:55,520
八周在一学期的课程。

1735
01:23:55,520 --> 01:23:59,670
>> 对这些有问题吗？

1736
01:23:59,670 --> 01:24:01,100
没有？

1737
01:24:01,100 --> 01:24:01,940
好吧。

1738
01:24:01,940 --> 01:24:05,610
那么，我们为什么不停在那里，
午餐开始提前几分钟，

1739
01:24:05,610 --> 01:24:07,052
恢复只需大约一个小时？

1740
01:24:07,052 --> 01:24:08,760
我会萦绕
有点用的问题。

1741
01:24:08,760 --> 01:24:11,343
然后，我将不得不去
采取一对夫妇的电话，如果这是确定。

1742
01:24:11,343 --> 01:24:15,000
我会在此期间开启一段音乐，
但午餐应该是指日可待。

1743
01:24:15,000 --> 01:24:17,862

