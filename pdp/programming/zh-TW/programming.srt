1
00:00:00,000 --> 00:00:00,030

2
00:00:00,030 --> 00:00:00,460
>> DAVID MALAN：好的。

3
00:00:00,460 --> 00:00:01,094
我們回來了。

4
00:00:01,094 --> 00:00:04,260
因此，在規劃這一領域是什麼
我以為我們會做的是一個事物的組合。

5
00:00:04,260 --> 00:00:06,340
一，做一點點
東西動手，

6
00:00:06,340 --> 00:00:08,690
雖然使用的是更好玩
編程environment--

7
00:00:08,690 --> 00:00:11,620
一個是示範的
正是種思路

8
00:00:11,620 --> 00:00:14,220
我們一直在談論，
而多了幾分正式掛牌。

9
00:00:14,220 --> 00:00:18,200
二，看一些
更多的技術途徑

10
00:00:18,200 --> 00:00:21,520
一個程序員實際上解決
像搜索問題的問題

11
00:00:21,520 --> 00:00:24,530
我們看了前
也有更根本

12
00:00:24,530 --> 00:00:26,020
排序的有趣的問題。

13
00:00:26,020 --> 00:00:28,840
>> 我們剛剛從一開始走假設
這是電話本進行了排序，

14
00:00:28,840 --> 00:00:31,980
但僅憑這實際上是種
硬問題有許多不同的方式

15
00:00:31,980 --> 00:00:32,479
解決它。

16
00:00:32,479 --> 00:00:34,366
因此，我們將使用這些作為
一類問題

17
00:00:34,366 --> 00:00:36,740
代表性的東西，
可能一般的解決。

18
00:00:36,740 --> 00:00:38,980
然後我們再說吧
大約在一些細節什麼

19
00:00:38,980 --> 00:00:42,360
稱為數據structures--
奇的方法類似鍊錶

20
00:00:42,360 --> 00:00:46,290
和哈希表和樹木
一個程序員實際上

21
00:00:46,290 --> 00:00:48,890
使用，一般使用
在白板上畫

22
00:00:48,890 --> 00:00:51,840
的畫面是什麼，他或她
設想用於實施

23
00:00:51,840 --> 00:00:52,980
一些的軟件。

24
00:00:52,980 --> 00:00:55,130
>> 因此，讓我們做動手部分第一。

25
00:00:55,130 --> 00:01:00,090
因此，只要把你的手臟了
環境調用scratch.mit.edu。

26
00:01:00,090 --> 00:01:02,636
這是我們使用的工具
在我們的本科班。

27
00:01:02,636 --> 00:01:04,510
儘管它的設計
適合12歲及以上，

28
00:01:04,510 --> 00:01:07,570
我們將其用於向上
那相當多的一部分

29
00:01:07,570 --> 00:01:10,020
因為它是一個不錯的，好玩的
學習圖形化的方式

30
00:01:10,020 --> 00:01:12,160
少了一些有關編程。

31
00:01:12,160 --> 00:01:17,600
讓頭部的網址，在那裡你
應該看到一個頁面很喜歡​​這個，

32
00:01:17,600 --> 00:01:23,330
並直接點擊
在右上角加入划痕

33
00:01:23,330 --> 00:01:28,300
並選擇一個用戶名和
密碼並最終讓自己

34
00:01:28,300 --> 00:01:29,970
一個account-- scratch.mit.edu。

35
00:01:29,970 --> 00:01:32,165

36
00:01:32,165 --> 00:01:34,665
我以為我會以此為
機會首次證明這一點。

37
00:01:34,665 --> 00:01:39,120
一個問題在休息的時候來到了
什麼代碼實際上樣子。

38
00:01:39,120 --> 00:01:41,315
和我們談話
關於C在休息的時候，

39
00:01:41,315 --> 00:01:45,060
在particular--特別是
在一個較舊的語言較低的水平。

40
00:01:45,060 --> 00:01:47,750
而我只是做了一個快速
谷歌搜索找到的C代碼

41
00:01:47,750 --> 00:01:51,574
對於二進制搜索，算法，我們
用於在先檢索的電話簿。

42
00:01:51,574 --> 00:01:54,240
這個特殊的例子，當然，
不搜索電話簿。

43
00:01:54,240 --> 00:01:57,840
它只是搜索一大堆
號碼在計算機的存儲器中。

44
00:01:57,840 --> 00:02:01,000
但是，如果你想只得到一個視覺
什麼實際的編程意識

45
00:02:01,000 --> 00:02:05,370
語言的樣子，看起來
有點像這樣。

46
00:02:05,370 --> 00:02:09,759
因此，這20多名，
30行左右的代碼，

47
00:02:09,759 --> 00:02:12,640
但談話我們
分別有過破發

48
00:02:12,640 --> 00:02:16,000
是關於如何真正
被演變成零和一

49
00:02:16,000 --> 00:02:19,200
如果你不能只恢復了
處理和從零和一去

50
00:02:19,200 --> 00:02:20,210
回代碼。

51
00:02:20,210 --> 00:02:22,620
>> 不幸的是，該方法
如此變革

52
00:02:22,620 --> 00:02:24,890
這是一個很多談何容易。

53
00:02:24,890 --> 00:02:29,400
我說乾就幹，居然變成
該程序，二進制搜索，

54
00:02:29,400 --> 00:02:32,700
成的一個方式的零和一
程序調用編譯器，我

55
00:02:32,700 --> 00:02:34,400
碰巧的權利在這裡我的Mac上。

56
00:02:34,400 --> 00:02:37,850
如果你看一下屏幕
在這裡，重點明確

57
00:02:37,850 --> 00:02:43,520
這些中間六列只，
你會看到只有零和的。

58
00:02:43,520 --> 00:02:48,290
而這些都是在零和一的
正是撰寫的搜索程序。

59
00:02:48,290 --> 00:02:53,720
>> 等五個位的每個塊，
零和一的每個字節在這裡，

60
00:02:53,720 --> 00:02:57,310
代表一些指令
通常是計算機的內部。

61
00:02:57,310 --> 00:03:00,730
而事實上，如果你聽說過
營銷口號“Intel Inside”的 - 即，

62
00:03:00,730 --> 00:03:04,610
當然，只是意味著你有一個
電腦內的英特爾CPU或大腦。

63
00:03:04,610 --> 00:03:08,000
而這意味著什麼是一個CPU是
你有一個指令集，

64
00:03:08,000 --> 00:03:08,840
可以這麼說。

65
00:03:08,840 --> 00:03:11,620
>> 世界上每一個CPU，很多
它們由英特爾這些天發，

66
00:03:11,620 --> 00:03:13,690
了解有限
指令數。

67
00:03:13,690 --> 00:03:18,690
而這些指令是如此之低的水平
因為這兩個數字加在一起，

68
00:03:18,690 --> 00:03:22,560
乘這兩個數字加在一起，
從這裡移動這一塊的數據

69
00:03:22,560 --> 00:03:27,340
這裡在內存中，保存此
從這裡的信息存儲器到這裡，

70
00:03:27,340 --> 00:03:32,200
所以forth--非常非常
低的水平，幾乎電子信息。

71
00:03:32,200 --> 00:03:34,780
但與那些數學
操作加上

72
00:03:34,780 --> 00:03:37,410
與我們前面討論的，
數據的表示

73
00:03:37,410 --> 00:03:40,450
作為零和的，可
你建立起來的一切

74
00:03:40,450 --> 00:03:44,180
一台計算機今天能做的，無論是
它的文本，圖形，音樂，

75
00:03:44,180 --> 00:03:45,580
或以其他方式。

76
00:03:45,580 --> 00:03:49,450
>> 所以這是很容易得到
迷失在快速的雜草。

77
00:03:49,450 --> 00:03:52,150
而且還有很多的
語法挑戰

78
00:03:52,150 --> 00:03:56,630
因此，如果你做的最簡單，
錯別字沒有方案的愚蠢

79
00:03:56,630 --> 00:03:57,860
將任何工作。

80
00:03:57,860 --> 00:04:00,366
因此，而不是使用
語言如C今天上午，

81
00:04:00,366 --> 00:04:02,240
我認為這將是
更多的樂趣，真正做到

82
00:04:02,240 --> 00:04:04,840
一些更直觀，這
而專為兒童設計

83
00:04:04,840 --> 00:04:08,079
實際上是一個完美的表現
實際編程

84
00:04:08,079 --> 00:04:10,370
language--恰好
使用圖片代替文字

85
00:04:10,370 --> 00:04:11,710
代表這些想法。

86
00:04:11,710 --> 00:04:15,470
>> 所以一旦你確實有一個
帳戶scratch.mit.edu，

87
00:04:15,470 --> 00:04:21,070
點擊創建按鈕
在左上方的網站。

88
00:04:21,070 --> 00:04:24,620
你應該看到這樣一個環境
一，我要看到我的屏幕上

89
00:04:24,620 --> 00:04:26,310
這裡。

90
00:04:26,310 --> 00:04:29,350
我們會花一點點
時間位在這裡踢球。

91
00:04:29,350 --> 00:04:34,080
讓我們看看，如果我們不能全部解決一些
問題一起以下述方式。

92
00:04:34,080 --> 00:04:39,420
>> 那麼，您會在此看到
environment--實際上只是讓

93
00:04:39,420 --> 00:04:40,050
我停下來。

94
00:04:40,050 --> 00:04:42,680
有沒有人不在這裡？

95
00:04:42,680 --> 00:04:45,070
不在這裡？

96
00:04:45,070 --> 00:04:45,800
好。

97
00:04:45,800 --> 00:04:49,030
所以讓我指出一些
這種環境的特點。

98
00:04:49,030 --> 00:04:55,024
>> 所以在屏幕的左上角，我們
有划痕的舞台，可以這麼說。

99
00:04:55,024 --> 00:04:57,440
刮不僅是名稱
此編程語言;

100
00:04:57,440 --> 00:05:00,356
這也是貓的名稱
您可以通過在橙色默認情況下有看到。

101
00:05:00,356 --> 00:05:02,160
他是在一個階段，所以
就像我描述

102
00:05:02,160 --> 00:05:05,770
龜早些時候在一個被
長方形的白板環境。

103
00:05:05,770 --> 00:05:09,800
這種貓的世界完全局限
該矩形向上頂在那裡。

104
00:05:09,800 --> 00:05:12,210
>> 同時，在右側
這裡右手邊，它的

105
00:05:12,210 --> 00:05:15,610
只是一個腳本區，
如果你將空白的石​​板。

106
00:05:15,610 --> 00:05:18,590
這就是我們要去的地方寫
我們在短短的時刻節目。

107
00:05:18,590 --> 00:05:22,935
和基石，我們將
用它來寫這個program--拼圖

108
00:05:22,935 --> 00:05:25,310
件，如果你will--是
那些在這裡在中間，

109
00:05:25,310 --> 00:05:27,500
他們正在分類
按功能。

110
00:05:27,500 --> 00:05:31,000
所以，舉例來說，我要繼續前進
和展示的這些的至少一種。

111
00:05:31,000 --> 00:05:33,690
我要繼續前進，然後點擊
控制類別向上頂。

112
00:05:33,690 --> 00:05:35,720
>> 因此，這些都是分類往上頂。

113
00:05:35,720 --> 00:05:39,410
我要點擊控件類。

114
00:05:39,410 --> 00:05:44,020
相反，我要單擊事件
類別中，最前面的一個往上頂。

115
00:05:44,020 --> 00:05:47,790
如果你想沿著甚至跟隨
因為我們這樣做，你很歡迎。

116
00:05:47,790 --> 00:05:52,180
我要單擊並拖動這個
第一個，“當綠旗點擊。”

117
00:05:52,180 --> 00:05:58,410
然後，我會剛落
大約在我一張白紙的頂部。

118
00:05:58,410 --> 00:06:01,450
>> 什麼是關於臨時不錯
是，這一塊拼圖，當

119
00:06:01,450 --> 00:06:04,560
與其他拼圖互鎖
件，打算從字面上做

120
00:06:04,560 --> 00:06:06,460
什麼樣的拼圖要說到做到。

121
00:06:06,460 --> 00:06:09,710
因此，例如，臨時是右
現在在他的世界的中間。

122
00:06:09,710 --> 00:06:14,660
我要繼續前進，並選擇
現在，讓我們說，運動類，

123
00:06:14,660 --> 00:06:18,000
如果你想要做的
same--運動類別。

124
00:06:18,000 --> 00:06:20,430
現在發現我有一個整體的
一堆拼圖這裡

125
00:06:20,430 --> 00:06:23,370
他們說什麼，同樣，那種事。

126
00:06:23,370 --> 00:06:28,110
而且我要繼續前進，拖放
降此舉塊就在這裡。

127
00:06:28,110 --> 00:06:31,860
>> 並注意，一旦你得到
接近“綠色環保標誌的底部

128
00:06:31,860 --> 00:06:34,580
點擊“按鈕，通知
怎麼會出現一條白線，

129
00:06:34,580 --> 00:06:36,950
就好像它幾乎
磁性，它想要去那裡。

130
00:06:36,950 --> 00:06:43,070
剛鬆手，它會捕捉
一起和形狀將匹配。

131
00:06:43,070 --> 00:06:46,620
現在你可以或許差不多
猜我們正在與這個部落格。

132
00:06:46,620 --> 00:06:51,570
>> 如果你看一下划痕階段
在這裡，並期待它的頂部，

133
00:06:51,570 --> 00:06:55,142
你會看到一個紅色的燈，
停車標誌和綠色標誌。

134
00:06:55,142 --> 00:06:57,100
而且我要繼續前進
看著我的screen--

135
00:06:57,100 --> 00:06:58,460
就一下，如果你能。

136
00:06:58,460 --> 00:07:01,960
我要點擊
綠色環保標誌，現在，

137
00:07:01,960 --> 00:07:07,850
他搬到這似乎是10個步驟
或10個像素，10個點，在屏幕上。

138
00:07:07,850 --> 00:07:13,390
>> 所以也不那麼令人振奮，
但讓​​我求婚

139
00:07:13,390 --> 00:07:17,440
甚至沒有教這個，就
用自己的自己intuition--讓利

140
00:07:17,440 --> 00:07:22,560
我建議你找出如何
使刮走正確的掃尾階段。

141
00:07:22,560 --> 00:07:28,700
讓他讓路的右側
屏幕，一路到右側。

142
00:07:28,700 --> 00:07:32,200
讓我給你一個時刻
左右與搏鬥。

143
00:07:32,200 --> 00:07:37,681
你可能想看看
在其他類別的塊。

144
00:07:37,681 --> 00:07:38,180
好吧。

145
00:07:38,180 --> 00:07:41,290
所以只是為了回顧一下，當我們有
綠旗點擊這裡

146
00:07:41,290 --> 00:07:44,850
移動10步是
只有指令，每次我

147
00:07:44,850 --> 00:07:46,720
點擊綠色旗幟，是怎麼回事？

148
00:07:46,720 --> 00:07:50,070
嗯，這是運行我的程序。

149
00:07:50,070 --> 00:07:52,450
所以，我能做到這一點
也許手動的10倍，

150
00:07:52,450 --> 00:07:55,130
但這種感覺有點
有點hackish，可以這麼說，

151
00:07:55,130 --> 00:07:57,480
因此我不是真的
解決這個問題。

152
00:07:57,480 --> 00:08:00,530
我只是再次嘗試，
再，再而三

153
00:08:00,530 --> 00:08:03,180
直到我有點意外
實現了指令

154
00:08:03,180 --> 00:08:05,560
我提早出門來實現。

155
00:08:05,560 --> 00:08:08,200
>> 但是，我們知道，從我們的
偽早些時候有

156
00:08:08,200 --> 00:08:11,870
這一想法在循環編程，
一次又一次地做一些事情。

157
00:08:11,870 --> 00:08:14,888
於是，我看到了一堆你
達到什麼一塊拼圖？

158
00:08:14,888 --> 00:08:17,870

159
00:08:17,870 --> 00:08:18,730
重複，直到。

160
00:08:18,730 --> 00:08:21,400
因此，我們可以做一些
喜歡重複，直到。

161
00:08:21,400 --> 00:08:23,760
你是怎麼重複，直到到底是什麼？

162
00:08:23,760 --> 00:08:27,720

163
00:08:27,720 --> 00:08:28,540
>> 好。

164
00:08:28,540 --> 00:08:31,974
讓我去一個是
稍微簡單一些只是一瞬間。

165
00:08:31,974 --> 00:08:33,140
讓我繼續前進，做到這一點。

166
00:08:33,140 --> 00:08:35,559
請注意，你可能有
控制之下發現，

167
00:08:35,559 --> 00:08:38,409
有這種重複塊，這
看起來並不像它的那麼大。

168
00:08:38,409 --> 00:08:41,039
這裡沒有多少空間
這兩個黃色線之間。

169
00:08:41,039 --> 00:08:43,539
但正如一些你可能有
注意，如果你拖放，

170
00:08:43,539 --> 00:08:45,150
注意它是如何成長為填充形狀。

171
00:08:45,150 --> 00:08:46,274
>> 你甚至可以塞進更多。

172
00:08:46,274 --> 00:08:48,670
它只會保持增長，如果
拖動和懸停。

173
00:08:48,670 --> 00:08:51,110
我不知道什麼是
最好在這裡，讓我們

174
00:08:51,110 --> 00:08:54,760
我至少重複五次，為
實例，然後再回到舞台

175
00:08:54,760 --> 00:08:56,720
然後單擊綠色標誌。

176
00:08:56,720 --> 00:08:59,110
而現在發現它並不令人信服。

177
00:08:59,110 --> 00:09:02,400
>> 現在，你們中的一些建議，如
維多利亞只是沒有，重複10次。

178
00:09:02,400 --> 00:09:05,140
而且一般不
得到他所有的方式，

179
00:09:05,140 --> 00:09:10,510
但不會有成為一個更強大的
方式不是隨意搞清楚

180
00:09:10,510 --> 00:09:12,640
有多少動作做？

181
00:09:12,640 --> 00:09:17,680
什麼可能是一個更好的塊
不是重複10次呢？

182
00:09:17,680 --> 00:09:20,380
>> 是啊，為什麼不能做一些事情永遠不會消失？

183
00:09:20,380 --> 00:09:24,390
現在讓我搬這個拼圖
裡面，遠離之一。

184
00:09:24,390 --> 00:09:28,300
現在注意無論身在何處划痕
開始，他去的邊緣。

185
00:09:28,300 --> 00:09:30,700
而值得慶幸的是麻省理工學院，
誰使划痕，只是

186
00:09:30,700 --> 00:09:33,190
可以確保他從來沒有
完全消失。

187
00:09:33,190 --> 00:09:35,360
你總是可以抓住他的尾巴。

188
00:09:35,360 --> 00:09:37,680
>> 而就直觀，
為什麼他繼續前進？

189
00:09:37,680 --> 00:09:38,892
這裡發生了什麼？

190
00:09:38,892 --> 00:09:41,440

191
00:09:41,440 --> 00:09:43,824
他似乎已經停止，但
那麼如果我拿起並拖動

192
00:09:43,824 --> 00:09:45,240
他一直想要去那邊。

193
00:09:45,240 --> 00:09:46,123
這是為什麼？

194
00:09:46,123 --> 00:09:51,610

195
00:09:51,610 --> 00:09:54,360
誠然，一台電腦是從字面上
要做到你告訴它做什麼。

196
00:09:54,360 --> 00:09:58,380
所以，如果你告訴它前面做
永繼的事情，移動10步，

197
00:09:58,380 --> 00:10:01,860
它會一直走下去，去
直到我打紅色停車標誌

198
00:10:01,860 --> 00:10:04,620
和完全停止該程序。

199
00:10:04,620 --> 00:10:06,610
>> 所以，即使你沒有
做到這一點，我怎麼會

200
00:10:06,610 --> 00:10:09,510
使划痕移動速度更快
在屏幕上？

201
00:10:09,510 --> 00:10:12,060

202
00:10:12,060 --> 00:10:13,280
更多的步驟，對不對？

203
00:10:13,280 --> 00:10:15,710
因此，而不是做10
在同一時間，我們為什麼不

204
00:10:15,710 --> 00:10:20,100
繼續前進，改變中場休息
你會propose-- 50？

205
00:10:20,100 --> 00:10:24,410
所以現在我要點擊綠色的
旗幟，而事實上，他也快。

206
00:10:24,410 --> 00:10:27,180
>> 與此，當然，只是
動畫的一種表現。

207
00:10:27,180 --> 00:10:28,060
什麼是動畫？

208
00:10:28,060 --> 00:10:33,090
它只是顯示你的人一個
靜止圖像的一大堆真的，

209
00:10:33,090 --> 00:10:34,160
真的，真的快。

210
00:10:34,160 --> 00:10:36,500
所以，如果我們只告訴
他將更多的步驟，

211
00:10:36,500 --> 00:10:39,750
我們只是有效果是
改變他在屏幕上

212
00:10:39,750 --> 00:10:42,900
所有的更迅速的每單位時間的。

213
00:10:42,900 --> 00:10:46,454
>> 現在，我提出的下一個挑戰
是讓他反彈的邊緣。

214
00:10:46,454 --> 00:10:49,120
而且不知道什麼謎
件exist--因為它的罰款

215
00:10:49,120 --> 00:10:53,030
如果你沒有得到的
在challenge--的階段是什麼

216
00:10:53,030 --> 00:10:54,280
你想直觀地做什麼？

217
00:10:54,280 --> 00:10:58,030
我們怎麼會有他的反彈和
特徵在於，在左右之間？

218
00:10:58,030 --> 00:11:02,630

219
00:11:02,630 --> 00:11:03,810
>> 是啊。

220
00:11:03,810 --> 00:11:05,680
因此，我們需要某種
的條件下，與我們

221
00:11:05,680 --> 00:11:09,710
似乎有條件句，所以要
控制類別下說話。

222
00:11:09,710 --> 00:11:14,110
其中這些塊
我們可能希望？

223
00:11:14,110 --> 00:11:15,200
是的，也許“的話，那麼”。

224
00:11:15,200 --> 00:11:18,780
所以注意到黃色塊之中
我們這裡有，有這個“如果”

225
00:11:18,780 --> 00:11:23,920
或本“的話，否則”塊會
讓我們做出決定，這樣做

226
00:11:23,920 --> 00:11:25,000
或者這樣做。

227
00:11:25,000 --> 00:11:27,380
甚至你可以嵌套這些
做多件事情。

228
00:11:27,380 --> 00:11:34,910
或者，如果你已經不在這裡了呢，
繼續前進，傳感類

229
00:11:34,910 --> 00:11:39,612
還有 - 讓我們看看它在這裡。

230
00:11:39,612 --> 00:11:43,050

231
00:11:43,050 --> 00:11:52,050
>> 那麼，什麼塊可能會有所幫助這裡
檢測如果他離開舞台？

232
00:11:52,050 --> 00:11:56,740
是啊，注意到一些，這些塊
可參數化的，可以這麼說。

233
00:11:56,740 --> 00:12:00,706
它們可以排序的定制，而不是
不像HTML昨天屬性，

234
00:12:00,706 --> 00:12:03,330
其中，這些屬性樣的
自定義標籤的行為。

235
00:12:03,330 --> 00:12:08,880
同樣在這裡，我可以抓住這個動人
塊與變化，提出這樣的問題，

236
00:12:08,880 --> 00:12:11,500
你去摸鼠標
指針像游標

237
00:12:11,500 --> 00:12:13,250
或者是你接觸的邊緣？

238
00:12:13,250 --> 00:12:15,210
>> 因此，讓我進去，做到這一點。

239
00:12:15,210 --> 00:12:18,130
我要縮小了一會兒。

240
00:12:18,130 --> 00:12:21,320
讓我抓住這個拼圖
這裡，這一塊拼圖這一點，

241
00:12:21,320 --> 00:12:24,570
我要去混雜
它們只是一瞬間。

242
00:12:24,570 --> 00:12:27,620
我要遷此，
改變這感人的優勢，

243
00:12:27,620 --> 00:12:38,590
我要去運動做到這一點。

244
00:12:38,590 --> 00:12:40,490
因此，這裡有一些成分。

245
00:12:40,490 --> 00:12:42,570
我想我已經得到了我想要的一切。

246
00:12:42,570 --> 00:12:47,710
>> 會有人想提出我怎麼
可以連接這些也許從上到下

247
00:12:47,710 --> 00:12:52,020
為了解決具有的問題
刮動右向左向右

248
00:12:52,020 --> 00:12:57,020
左到右到左，每
時間剛剛反彈的牆？

249
00:12:57,020 --> 00:12:58,050
我想要什麼呢？

250
00:12:58,050 --> 00:13:01,097
哪個塊我應該連接到
“當綠旗點擊第一”？

251
00:13:01,097 --> 00:13:04,060

252
00:13:04,060 --> 00:13:06,200
>> 好了，讓我們開始用“永遠。”

253
00:13:06,200 --> 00:13:07,170
善有善報，裡面下？

254
00:13:07,170 --> 00:13:10,290
其他人。

255
00:13:10,290 --> 00:13:11,850
OK，移動步驟。

256
00:13:11,850 --> 00:13:12,350
好吧。

257
00:13:12,350 --> 00:13:14,470
然後呢？

258
00:13:14,470 --> 00:13:15,120
所以，那麼如果。

259
00:13:15,120 --> 00:13:17,720
並注意，儘管它看起來
夾緊緊聯繫在一起，

260
00:13:17,720 --> 00:13:19,500
它只會增長到填滿。

261
00:13:19,500 --> 00:13:21,500
它只會跳，我想它。

262
00:13:21,500 --> 00:13:25,920
>> 而我該怎麼放的
IF和當時的？

263
00:13:25,920 --> 00:13:27,180
也許“是在觸摸的優勢。”

264
00:13:27,180 --> 00:13:31,800
和通知，再次，它太大了
對於它，但它會增長到填滿。

265
00:13:31,800 --> 00:13:35,002
然後轉15度？

266
00:13:35,002 --> 00:13:35,710
多少度？

267
00:13:35,710 --> 00:13:38,800

268
00:13:38,800 --> 00:13:41,196
是啊，所以180會打滑
我所有的相反。

269
00:13:41,196 --> 00:13:42,570
因此，讓我們看看，如果我得到這個權利。

270
00:13:42,570 --> 00:13:43,930
讓我縮小。

271
00:13:43,930 --> 00:13:45,130
>> 讓我拖刮了。

272
00:13:45,130 --> 00:13:50,030
於是，他有點扭曲
現在，但是這很好。

273
00:13:50,030 --> 00:13:52,231
我怎樣才能輕鬆重置他嗎？

274
00:13:52,231 --> 00:13:59,879

275
00:13:59,879 --> 00:14:01,045
我要稍微作弊。

276
00:14:01,045 --> 00:14:04,074

277
00:14:04,074 --> 00:14:05,990
所以我又增加
塊，僅僅是明確的。

278
00:14:05,990 --> 00:14:08,424
我要他點90度
在默認情況下的權利，

279
00:14:08,424 --> 00:14:10,840
所以我只是要告訴他
要做到這一點編程。

280
00:14:10,840 --> 00:14:11,632
現在我們開始。

281
00:14:11,632 --> 00:14:14,740

282
00:14:14,740 --> 00:14:15,740
我們似乎都做到了。

283
00:14:15,740 --> 00:14:19,980
這是一個有點古怪，因為
他走倒掛。

284
00:14:19,980 --> 00:14:21,250
讓我們把一個錯誤。

285
00:14:21,250 --> 00:14:22,120
這是一個錯誤。

286
00:14:22,120 --> 00:14:27,320
一個錯誤是一個程序，一個錯誤
邏輯錯誤，我的人，做。

287
00:14:27,320 --> 00:14:28,985
他為什麼會顛倒？

288
00:14:28,985 --> 00:14:33,560

289
00:14:33,560 --> 00:14:35,250
難道MIT搞砸了還是我？

290
00:14:35,250 --> 00:14:38,840

291
00:14:38,840 --> 00:14:42,550
>> 是的，我的意思是，這不是麻省理工學院
故障。他們給了我一塊拼圖

292
00:14:42,550 --> 00:14:44,970
上面寫著轉的度的某個數。

293
00:14:44,970 --> 00:14:47,672
而在維多利亞的建議，
我轉180度，

294
00:14:47,672 --> 00:14:48,880
這是正確的直覺。

295
00:14:48,880 --> 00:14:53,700
但轉彎180度，從字面上
裝置轉動180度，

296
00:14:53,700 --> 00:14:55,860
這不是真的
我想要的東西，顯然。

297
00:14:55,860 --> 00:14:58,026
因為至少他在
這個二維世界，

298
00:14:58,026 --> 00:15:00,740
所以轉折點是真的
翻轉他倒掛。

299
00:15:00,740 --> 00:15:04,030
>> 我可能要使用的塊
相反，根據你所看到的嗎？

300
00:15:04,030 --> 00:15:11,890

301
00:15:11,890 --> 00:15:14,790
我們如何解決這個問題？

302
00:15:14,790 --> 00:15:18,380
是啊，所以我們可以點
在相反的方向。

303
00:15:18,380 --> 00:15:22,300
而實際上，即使這
不會是不夠的，

304
00:15:22,300 --> 00:15:26,410
因為我們只能硬編碼
指點左側或右側。

305
00:15:26,410 --> 00:15:27,920
>> 你知道我們能做什麼？

306
00:15:27,920 --> 00:15:30,160
看起來我們有一個
便利塊在這裡。

307
00:15:30,160 --> 00:15:32,987
如果我放大，看到
這是我們喜歡在這裡？

308
00:15:32,987 --> 00:15:36,120

309
00:15:36,120 --> 00:15:40,020
所以它看起來像麻省理工學院有一個
抽象建在這裡。

310
00:15:40,020 --> 00:15:45,440
此塊似乎是等效
到其它塊，複數？

311
00:15:45,440 --> 00:15:49,510
>> 這一塊似乎是等同
以塊的這整個三人組

312
00:15:49,510 --> 00:15:50,880
我們這裡有。

313
00:15:50,880 --> 00:15:54,670
因此，原來我可以簡化我的
通過擺脫這一切的程序

314
00:15:54,670 --> 00:15:58,270
而只是把這個在這裡。

315
00:15:58,270 --> 00:16:01,620
而現在，他仍然是一個小
越野車，而現在的罰款。

316
00:16:01,620 --> 00:16:03,370
我們把它留給定。

317
00:16:03,370 --> 00:16:06,000
但我的計劃是，即使
簡單，而且這也

318
00:16:06,000 --> 00:16:09,060
會代表
在programming--目標

319
00:16:09,060 --> 00:16:13,430
是理想使你的代碼
簡單，盡可能緊湊，

320
00:16:13,430 --> 00:16:15,650
同時仍然為
可讀越好。

321
00:16:15,650 --> 00:16:20,310
你不想讓它盡量簡潔
這很難理解。

322
00:16:20,310 --> 00:16:22,826
>> 但是請注意，我把它換成
三個塊一個，

323
00:16:22,826 --> 00:16:24,200
那可以說是一件好事。

324
00:16:24,200 --> 00:16:27,280
我抽象出來的概念
抽查不管你是

325
00:16:27,280 --> 00:16:29,120
與僅一個街區的邊緣。

326
00:16:29,120 --> 00:16:31,520
現在，我們可以有樂趣與此，事實上。

327
00:16:31,520 --> 00:16:35,790
這不會加那麼多
知識產權價值，但頑皮的價值。

328
00:16:35,790 --> 00:16:39,730
我要繼續前進
在這裡抓住這個聲音。

329
00:16:39,730 --> 00:16:42,900

330
00:16:42,900 --> 00:16:46,420
因此，讓我先走了，讓我
停了片刻程序。

331
00:16:46,420 --> 00:16:52,070
我要記錄以下，
允許訪問我的麥克風。

332
00:16:52,070 --> 00:16:53,181
>> 開始了。

333
00:16:53,181 --> 00:16:53,680
哎喲。

334
00:16:53,680 --> 00:16:58,710

335
00:16:58,710 --> 00:17:01,140
讓我們再試試這個。

336
00:17:01,140 --> 00:17:02,279
開始了。

337
00:17:02,279 --> 00:17:03,570
好吧，我錄了錯誤的事情。

338
00:17:03,570 --> 00:17:04,580
開始了。

339
00:17:04,580 --> 00:17:05,080
哎喲。

340
00:17:05,080 --> 00:17:07,910

341
00:17:07,910 --> 00:17:08,800
哎喲。

342
00:17:08,800 --> 00:17:09,300
好吧。

343
00:17:09,300 --> 00:17:10,791
現在我需要擺脫的。

344
00:17:10,791 --> 00:17:11,290
好吧。

345
00:17:11,290 --> 00:17:13,950
>> 所以現在我有一個
只是記錄“哎喲”。

346
00:17:13,950 --> 00:17:18,040
所以，現在我要去
進取，稱之為“哎喲”。

347
00:17:18,040 --> 00:17:20,270
我要回去
我的劇本，現在

348
00:17:20,270 --> 00:17:25,460
通知有該塊被稱為
播放聲音“喵喵”或播放聲音“哎喲”。

349
00:17:25,460 --> 00:17:28,920
我要去拖這一點，並在
我應該把這個為滑稽的效果呢？

350
00:17:28,920 --> 00:17:31,740

351
00:17:31,740 --> 00:17:37,860
是啊，所以現在它是一種
越野車，因為現在這個block--

352
00:17:37,860 --> 00:17:42,050
注意如何“如果邊緣，
反彈“是一種自成體系。

353
00:17:42,050 --> 00:17:43,704
所以，我需要解決這個問題。

354
00:17:43,704 --> 00:17:44,870
讓我繼續前進，做到這一點。

355
00:17:44,870 --> 00:17:48,630
讓我擺脫這一點，回去
我們原來的，更深思熟慮

356
00:17:48,630 --> 00:17:49,870
功能。

357
00:17:49,870 --> 00:18:01,080
因此，“如果觸及邊緣，然後在”我想
轉，維多利亞提出，

358
00:18:01,080 --> 00:18:02,480
180度。

359
00:18:02,480 --> 00:18:05,497
那我要玩
聲“哎喲”呢？

360
00:18:05,497 --> 00:18:11,800

361
00:18:11,800 --> 00:18:15,580
>> 是啊，察覺到它的外
那個黃色的塊狀。

362
00:18:15,580 --> 00:18:17,680
因此，這也將是一個
錯誤，但我已經注意到了這一點。

363
00:18:17,680 --> 00:18:21,290
所以我要在這裡拖起來，
並注意現在是裡面的“如果”。

364
00:18:21,290 --> 00:18:24,250
因此，“如果”這算哪門子
像臂形印跡

365
00:18:24,250 --> 00:18:26,260
那唯一的打算
做什麼是它裡面。

366
00:18:26,260 --> 00:18:30,216
所以，現在，如果我縮小在
annoying--的風險

367
00:18:30,216 --> 00:18:32,860

368
00:18:32,860 --> 00:18:36,470
>> 計算機：哎喲，哎喲，哎喲。

369
00:18:36,470 --> 00:18:39,910
>> DAVID MALAN：它
只是永遠持續下去。

370
00:18:39,910 --> 00:18:44,160
現在只是為了加快東西
在這裡，讓我去進取，不斷開拓，

371
00:18:44,160 --> 00:18:50,460
讓我們say--讓我去一些
從類我自己的東西。

372
00:18:50,460 --> 00:18:53,000

373
00:18:53,000 --> 00:19:00,220
讓我開拓，讓我們說，這
一個接我們的教學研究員之一製成

374
00:19:00,220 --> 00:19:01,500
兩三年前。

375
00:19:01,500 --> 00:19:04,732
所以，有些人可能還記得
本場比賽從昔日的，

376
00:19:04,732 --> 00:19:05,940
它實際上是顯著的。

377
00:19:05,940 --> 00:19:08,190
儘管我們已經做了
最簡單的方案，現在，

378
00:19:08,190 --> 00:19:09,980
讓我們來考慮一下這個
實際上看起來像。

379
00:19:09,980 --> 00:19:10,650
讓我打比賽。

380
00:19:10,650 --> 00:19:14,210

381
00:19:14,210 --> 00:19:18,980
>> 因此，在這場比賽中，我們有一個
青蛙，並使用箭頭keys--

382
00:19:18,980 --> 00:19:23,340
他花費的時間比我脖子了更大的步伐
我有過這種青蛙的控制。

383
00:19:23,340 --> 00:19:29,630
其目標是跨越繁忙的獲得
路不跑入汽車。

384
00:19:29,630 --> 00:19:34,735
而讓，如果我在這裡上去的see--，我
必須等待日誌被滾動。

385
00:19:34,735 --> 00:19:38,130

386
00:19:38,130 --> 00:19:39,274
這感覺就像一個錯誤。

387
00:19:39,274 --> 00:19:42,240

388
00:19:42,240 --> 00:19:43,495
這是怎樣的一個錯誤。

389
00:19:43,495 --> 00:19:45,980

390
00:19:45,980 --> 00:19:46,480
好吧。

391
00:19:46,480 --> 00:19:51,550
我在這個位置，
在那裡，然後你繼續

392
00:19:51,550 --> 00:19:54,100
走，直到你得到所有
青蛙的睡蓮。

393
00:19:54,100 --> 00:19:55,920
現在，這可能看起來
所有的更複雜，

394
00:19:55,920 --> 00:19:57,840
但讓​​我們嘗試突破
下來弱智

395
00:19:57,840 --> 00:20:00,040
並口頭成其組件塊。

396
00:20:00,040 --> 00:20:03,910
因此，有可能是一個謎
我們還沒有看到一塊

397
00:20:03,910 --> 00:20:07,440
但是這響應按鍵，
的事情我按下鍵盤上。

398
00:20:07,440 --> 00:20:11,660
>> 因此，有可能是某種
塊，上面寫著，如果key等於起來，

399
00:20:11,660 --> 00:20:15,965
然後做Scratch--事
也許移動10步這種方式。

400
00:20:15,965 --> 00:20:20,240
如果向下鍵，移動10步
這樣一來，或者左鍵，將10個步驟

401
00:20:20,240 --> 00:20:21,710
通過這種方式，10的步驟。

402
00:20:21,710 --> 00:20:23,644
我已經清楚地變成貓變成了青蛙。

403
00:20:23,644 --> 00:20:26,060
所以，這只是其中
服裝，刮擦調用它 - 我們

404
00:20:26,060 --> 00:20:28,440
剛剛導入的青蛙的圖片。

405
00:20:28,440 --> 00:20:29,570
>> 還有什麼是怎麼回事？

406
00:20:29,570 --> 00:20:32,794
什麼其他代碼行，
還有什麼其他拼圖

407
00:20:32,794 --> 00:20:35,460
做布雷克，我們的教學老鄉，
在這個程序中使用，顯然是？

408
00:20:35,460 --> 00:20:38,320

409
00:20:38,320 --> 00:20:42,730
什麼是使一切move--
什麼編程構建？

410
00:20:42,730 --> 00:20:44,950
>> 運動，sure--所以
移動塊，肯定的。

411
00:20:44,950 --> 00:20:49,330
而那是什麼舉動塊
裡面，最有可能的？

412
00:20:49,330 --> 00:20:52,850
是的，有些類型的循環，也許
永遠阻止，也許是重複block--

413
00:20:52,850 --> 00:20:54,070
重複，直到塊。

414
00:20:54,070 --> 00:20:57,330
這就是什麼使日誌和
百合墊和其他一切舉動

415
00:20:57,330 --> 00:20:57,990
來來回回。

416
00:20:57,990 --> 00:21:00,270
這只是發生不休。

417
00:21:00,270 --> 00:21:03,180
>> 為什麼有些車
移動速度比別人快？

418
00:21:03,180 --> 00:21:06,607
什麼是關於這些程序有什麼不同？

419
00:21:06,607 --> 00:21:09,690
是啊，也許他們中的一些正在服用
同時更多的步驟，其中一些

420
00:21:09,690 --> 00:21:10,690
同時更少的步驟。

421
00:21:10,690 --> 00:21:14,670
和視覺效果
快與慢。

422
00:21:14,670 --> 00:21:16,030
>> 你認為發生了什麼？

423
00:21:16,030 --> 00:21:19,700
當我得到了我的青蛙一路
在街對面，河

424
00:21:19,700 --> 00:21:23,560
到蕸，東西
值得一提的事。

425
00:21:23,560 --> 00:21:26,540
什麼，只要我這樣做了？

426
00:21:26,540 --> 00:21:27,210
停了。

427
00:21:27,210 --> 00:21:29,680
青蛙停了下來，
我得到了第二只青蛙。

428
00:21:29,680 --> 00:21:33,155
那麼，什麼結構必須是
使用有什麼功能？

429
00:21:33,155 --> 00:21:36,020

430
00:21:36,020 --> 00:21:38,660
>> 是啊，所以有某種
“if”條件在那裡，太。

431
00:21:38,660 --> 00:21:41,909
而事實證明out--我們沒有看到this--
但有一個在那裡，其他塊

432
00:21:41,909 --> 00:21:45,300
可以說，如果你是感人
屏幕上的另一件事，

433
00:21:45,300 --> 00:21:47,720
如果你觸摸蕸，“然後”。

434
00:21:47,720 --> 00:21:50,810
然後那個時候我們
使第二只青蛙出現。

435
00:21:50,810 --> 00:21:54,969
因此，即使這場比賽肯定是
很過時，儘管乍一看

436
00:21:54,969 --> 00:21:58,010
有這麼多的事情on--和布雷克
在兩分鐘內沒有掀起這件事，

437
00:21:58,010 --> 00:22:00,390
大概花了他幾
小時創造這個遊戲

438
00:22:00,390 --> 00:22:03,850
根據他的記憶或視頻
的昔日的版本吧。

439
00:22:03,850 --> 00:22:07,940
但是，所有的這些小事
要在隔離的屏幕上

440
00:22:07,940 --> 00:22:11,550
歸結為這些很簡單
constructs--運動或聲明

441
00:22:11,550 --> 00:22:15,519
就像我們已經討論過，循環和
條件，這就是它。

442
00:22:15,519 --> 00:22:17,060
還有一些其他鴿友功能。

443
00:22:17,060 --> 00:22:19,130
其中有些是純粹的
審美或聲，

444
00:22:19,130 --> 00:22:20,964
喜歡的聲音我只是打了。

445
00:22:20,964 --> 00:22:23,380
但在大多數情況下，則
沒有這個語言，從無到有，

446
00:22:23,380 --> 00:22:25,350
所有基本的
積木您

447
00:22:25,350 --> 00:22:29,280
在C，Java的，JavaScript中，
PHP和Ruby，Python和

448
00:22:29,280 --> 00:22:32,960
和任意數量的其他語言。

449
00:22:32,960 --> 00:22:36,720
關於臨時有問題嗎？

450
00:22:36,720 --> 00:22:37,220
好吧。

451
00:22:37,220 --> 00:22:40,303
因此，我們將不會在更深的下潛劃傷，
雖然你這個週末是受歡迎的，

452
00:22:40,303 --> 00:22:42,860
特別是如果你有孩子，或
侄女和侄子這樣，

453
00:22:42,860 --> 00:22:44,220
向他們介紹劃傷。

454
00:22:44,220 --> 00:22:47,960
它實際上是一個奇妙的俏皮
環境，因為它的作者說，

455
00:22:47,960 --> 00:22:49,120
天花板很高。

456
00:22:49,120 --> 00:22:51,670
儘管我們開始
非常低層次的細節，

457
00:22:51,670 --> 00:22:54,890
你真的可以做相當多的
用它，這或許是

458
00:22:54,890 --> 00:22:57,360
正好一個示範。

459
00:22:57,360 --> 00:23:02,920
>> 但是，讓我們現在過渡到一些
複雜的問題，如果你願意，

460
00:23:02,920 --> 00:23:05,870
稱為“搜索”和
“排序”，更普遍。

461
00:23:05,870 --> 00:23:09,500
我們有先前已經在這裡這款手機本書
另一只為discussion--

462
00:23:09,500 --> 00:23:13,460
我們能夠搜索
更有效，因為

463
00:23:13,460 --> 00:23:15,270
的一個顯著假設。

464
00:23:15,270 --> 00:23:17,655
而僅僅是明確的，是什麼
假設是我做

465
00:23:17,655 --> 00:23:19,280
通過這個電話本搜索時？

466
00:23:19,280 --> 00:23:23,342

467
00:23:23,342 --> 00:23:25,300
邁克·史密斯在
電話本，雖然我

468
00:23:25,300 --> 00:23:27,410
將能夠處理
沒有他的情況下

469
00:23:27,410 --> 00:23:30,720
還有，如果我只是提前停止。

470
00:23:30,720 --> 00:23:31,806
書是按字母順序排列。

471
00:23:31,806 --> 00:23:33,930
這是一個非常慷慨
假設，因為這

472
00:23:33,930 --> 00:23:36,580
意味著someone--我有點
切割角，

473
00:23:36,580 --> 00:23:40,580
像我，因為有人快
別人做了很多艱苦的工作對我來說。

474
00:23:40,580 --> 00:23:43,120
>> 但是，如果手機
本書是不排序？

475
00:23:43,120 --> 00:23:47,050
也許Verizon的偷懶，只是把
每個人的姓名和電話號碼在那裡

476
00:23:47,050 --> 00:23:50,120
也許在順序他們
簽署了電話服務。

477
00:23:50,120 --> 00:23:54,570
多少時間，它帶我
找一個像邁克·史密斯？

478
00:23:54,570 --> 00:23:58,160
1000頁的電話book--多少
網頁做我不得不通過看？

479
00:23:58,160 --> 00:23:58,905
>> 他們全部。

480
00:23:58,905 --> 00:24:00,030
你是那種倒霉。

481
00:24:00,030 --> 00:24:03,420
你從字面上來看看每
如果電話簿只是頁面

482
00:24:03,420 --> 00:24:04,450
隨機排序。

483
00:24:04,450 --> 00:24:06,910
你可能會得到幸運，找到邁克
在第一頁上，因為他

484
00:24:06,910 --> 00:24:08,826
是第一個客戶
訂購電話服務。

485
00:24:08,826 --> 00:24:10,760
但他可能是最後一次了。

486
00:24:10,760 --> 00:24:12,500
>> 所以隨機順序並不好。

487
00:24:12,500 --> 00:24:16,750
因此，假設我們要排序
電話簿或一般類型的數據

488
00:24:16,750 --> 00:24:18,520
我們已經給出。

489
00:24:18,520 --> 00:24:19,440
我們怎樣才能做到這一點？

490
00:24:19,440 --> 00:24:21,360
>> 好吧，讓我試試
這裡一個簡單的例子。

491
00:24:21,360 --> 00:24:24,290
讓我繼續前進，折騰
在黑板上幾號。

492
00:24:24,290 --> 00:24:35,480
假設我們有是數字，
比方說，四，二，一，三。

493
00:24:35,480 --> 00:24:38,390
而且，本，這些數字對我們進行排序。

494
00:24:38,390 --> 00:24:39,017
>> OK，不錯。

495
00:24:39,017 --> 00:24:39,850
你怎麼做到的？

496
00:24:39,850 --> 00:24:42,731

497
00:24:42,731 --> 00:24:43,230
好吧。

498
00:24:43,230 --> 00:24:44,710
因此，與最小的開始
值和最高的，

499
00:24:44,710 --> 00:24:46,084
這就是真正的好直覺。

500
00:24:46,084 --> 00:24:48,080
並意識到我們
人類實際上是相當

501
00:24:48,080 --> 00:24:49,913
善於解決問題
這樣，至少

502
00:24:49,913 --> 00:24:51,810
當數據是比較小的。

503
00:24:51,810 --> 00:24:54,860
一旦你開始有上百
數字，數千數字，

504
00:24:54,860 --> 00:24:58,440
數以百萬計的數字，本大概
不能做到這一點想像中的那麼快，

505
00:24:58,440 --> 00:25:00,620
假設有
中的數字的空白。

506
00:25:00,620 --> 00:25:03,450
很容易數到一百萬
否則，只是費時。

507
00:25:03,450 --> 00:25:07,150
>> 所以算法聽起來
像本現在只使用了

508
00:25:07,150 --> 00:25:08,930
是搜索的最小數目。

509
00:25:08,930 --> 00:25:12,900
因此，即使我們人類可以採取
在大量的信息可視化，

510
00:25:12,900 --> 00:25:14,830
計算機實際上是
多一點有限的。

511
00:25:14,830 --> 00:25:17,560
計算機只能
看一個字節在一個時間

512
00:25:17,560 --> 00:25:20,770
或在一個時間 - 也許四個字節
在時間 - 這些天，也許8個字節

513
00:25:20,770 --> 00:25:24,450
但極少數
的字節在給定的時間。

514
00:25:24,450 --> 00:25:28,480
>> 因此，考慮到我們真的有
四個單獨的值這裡 - 

515
00:25:28,480 --> 00:25:32,440
你能想到奔具有
對，如果他是一個電腦等一葉障目

516
00:25:32,440 --> 00:25:36,450
他看不到其他任何東西
不是在一個時間 - 一個號碼

517
00:25:36,450 --> 00:25:39,720
所以我們一般會認為，像
英語中，我們將從右至左讀。

518
00:25:39,720 --> 00:25:42,870
因此，第一個數字奔大概看了
在四歲然後很迅速

519
00:25:42,870 --> 00:25:44,770
意識到這是一個相當大的
number--讓我繼續尋找。

520
00:25:44,770 --> 00:25:45,357
>> 有兩項。

521
00:25:45,357 --> 00:25:45,940
等一下。

522
00:25:45,940 --> 00:25:47,070
二是超過四個小。

523
00:25:47,070 --> 00:25:47,986
我會記住。

524
00:25:47,986 --> 00:25:49,070
現在二是最小的。

525
00:25:49,070 --> 00:25:50,417
現在one--那就更好了。

526
00:25:50,417 --> 00:25:51,250
這是更小。

527
00:25:51,250 --> 00:25:54,000
我要忘了約兩
，只是記住一個現在。

528
00:25:54,000 --> 00:25:56,550
>> 並可能他停止尋找？

529
00:25:56,550 --> 00:25:58,360
嗯，他可以根據
該信息，

530
00:25:58,360 --> 00:26:00,477
但他最好的搜索
列表的其餘部分。

531
00:26:00,477 --> 00:26:02,060
因為如果零是在列表中？

532
00:26:02,060 --> 00:26:03,643
如果負一人在列表中？

533
00:26:03,643 --> 00:26:07,720
他只知道，他的回答
是正確的，如果他的詳盡

534
00:26:07,720 --> 00:26:08,729
檢查整個列表。

535
00:26:08,729 --> 00:26:10,020
所以，我們看一下這個休息。

536
00:26:10,020 --> 00:26:11,394
Three--那是浪費時間。

537
00:26:11,394 --> 00:26:13,540
有倒霉，但我
還是正確的這樣做。

538
00:26:13,540 --> 00:26:17,857
所以現在他大概
選擇的最小的數

539
00:26:17,857 --> 00:26:20,440
而只是把它開頭
名單，因為我會在這裡做的。

540
00:26:20,440 --> 00:26:23,480
現在，你做了什麼接下來，即使
你不想想近

541
00:26:23,480 --> 00:26:25,962
到這個地步？

542
00:26:25,962 --> 00:26:27,670
重複這個過程，
所以某種循環。

543
00:26:27,670 --> 00:26:28,920
有一個熟悉的概念。

544
00:26:28,920 --> 00:26:30,860
因此，這裡是四人。

545
00:26:30,860 --> 00:26:32,110
這是目前國內最小的。

546
00:26:32,110 --> 00:26:33,220
這是一個候選人。

547
00:26:33,220 --> 00:26:33,900
不再。

548
00:26:33,900 --> 00:26:34,770
現在，我已經看到了兩個。

549
00:26:34,770 --> 00:26:36,630
這是下一個最小的元素。

550
00:26:36,630 --> 00:26:40,800
Three--那不是更小，所以
現在本可以挖出兩個。

551
00:26:40,800 --> 00:26:44,510
>> 而現在，我們重複此過程，
當然3被旁邊拉出。

552
00:26:44,510 --> 00:26:45,420
重複上述過程。

553
00:26:45,420 --> 00:26:46,990
四個被拉出。

554
00:26:46,990 --> 00:26:50,140
而現在我們出數字，
因此列表必須被排序。

555
00:26:50,140 --> 00:26:51,960
>> 事實上，這是一個正式的算法。

556
00:26:51,960 --> 00:26:56,610
計算機科學家會
稱之為“選擇排序”

557
00:26:56,610 --> 00:27:00,880
這個想法是那種一
再次列出iteratively--

558
00:27:00,880 --> 00:27:03,807
一次又一次選擇
的最小數字。

559
00:27:03,807 --> 00:27:06,140
而且它是什麼太好
它只是這麼混賬直觀。

560
00:27:06,140 --> 00:27:07,470
它是如此簡單。

561
00:27:07,470 --> 00:27:11,100
你可以重複同樣的
連連操作。

562
00:27:11,100 --> 00:27:12,150
這很簡單。

563
00:27:12,150 --> 00:27:17,170
>> 在這種情況下，它是速度快，但
多長時間居然拿？

564
00:27:17,170 --> 00:27:19,880
讓我們把它似乎並
覺得有點單調乏味。

565
00:27:19,880 --> 00:27:24,150
所以一，二，三，四，五六百，
七，八，九，十，十一，十二，十三，十四，

566
00:27:24,150 --> 00:27:26,160
15，16--任意數。

567
00:27:26,160 --> 00:27:28,780
我只是想多本
時間不僅僅是四個。

568
00:27:28,780 --> 00:27:30,780
所以，如果我有一個整體
一串數字now--它

569
00:27:30,780 --> 00:27:32,420
甚至沒有關係
他們are--讓我們

570
00:27:32,420 --> 00:27:34,380
想想這
算法真的很喜歡。

571
00:27:34,380 --> 00:27:35,857
>> 假設有數字存在。

572
00:27:35,857 --> 00:27:38,190
再次，什麼都無所謂
他們，但他們是隨機的。

573
00:27:38,190 --> 00:27:39,679
我申請本的算法。

574
00:27:39,679 --> 00:27:41,220
我需要選擇最小的數字。

575
00:27:41,220 --> 00:27:41,761
我該怎麼辦？

576
00:27:41,761 --> 00:27:44,240
而我要去物理
做這次表演出來。

577
00:27:44,240 --> 00:27:46,099
尋找，尋找，
尋找，尋找，尋找。

578
00:27:46,099 --> 00:27:48,140
只有時間我去
列表的末尾可以

579
00:27:48,140 --> 00:27:51,230
我意識到最小
根數為兩根這個時候。

580
00:27:51,230 --> 00:27:52,720
一個不是在列表中。

581
00:27:52,720 --> 00:27:54,400
於是，我放下了兩項。

582
00:27:54,400 --> 00:27:55,590
>> 我該怎麼做？

583
00:27:55,590 --> 00:27:58,600
尋找，尋找，尋找，尋找。

584
00:27:58,600 --> 00:28:02,250
現在我找到了七位數，是因為
有這些numbers--差距

585
00:28:02,250 --> 00:28:03,300
只是隨心所欲。

586
00:28:03,300 --> 00:28:03,800
好吧。

587
00:28:03,800 --> 00:28:06,030
所以，現在我可以放下七人。

588
00:28:06,030 --> 00:28:08,860
展望尋找，尋找。

589
00:28:08,860 --> 00:28:11,030
>> 現在我假設的
當然，這本不

590
00:28:11,030 --> 00:28:14,780
有額外內存，額外
存儲器，因為，當然，

591
00:28:14,780 --> 00:28:16,080
我期待在相同的號碼。

592
00:28:16,080 --> 00:28:18,246
當然，我可以記得
所有這些數字的，

593
00:28:18,246 --> 00:28:19,930
這就是千真萬確的。

594
00:28:19,930 --> 00:28:22,610
但是，如果本·記住所有
數字的，他已經看到，

595
00:28:22,610 --> 00:28:24,430
他還沒有決定
根本的進步

596
00:28:24,430 --> 00:28:26,170
因為他已經有
搜索能力

597
00:28:26,170 --> 00:28:27,540
通過主板上的號碼。

598
00:28:27,540 --> 00:28:29,373
記住所有的
數字沒有幫助，

599
00:28:29,373 --> 00:28:32,490
因為他依然可以作為一台電腦
僅看，我們已經說過了，一個號碼

600
00:28:32,490 --> 00:28:33,080
在一個時間。

601
00:28:33,080 --> 00:28:35,760
因此，有沒有那種騙
那裡，你可以利用。

602
00:28:35,760 --> 00:28:39,170
>> 因此，在現實中，如我
繼續搜索列表，

603
00:28:39,170 --> 00:28:44,200
我從字面上只是繼續前進
通過來回，採摘出來

604
00:28:44,200 --> 00:28:45,710
下一個最小號。

605
00:28:45,710 --> 00:28:48,810
正如你可以種推斷
從我的愚蠢的動作，

606
00:28:48,810 --> 00:28:50,860
這只是變得非常
乏味的速度非常快，

607
00:28:50,860 --> 00:28:54,850
我似乎是想回來，
第四，來回還真不少。

608
00:28:54,850 --> 00:29:03,220
現在是公平的，我沒有去
相當的，好了，讓我們see--是公平的，

609
00:29:03,220 --> 00:29:06,310
我沒有相當走路
每次盡可能多的步驟。

610
00:29:06,310 --> 00:29:09,200
因為，當然，我
從列表中選擇號碼，

611
00:29:09,200 --> 00:29:11,860
剩下的名單也越來越短。

612
00:29:11,860 --> 00:29:14,240
>> 因此，讓我們想想
其實，我要走多少步是

613
00:29:14,240 --> 00:29:16,010
通過每次疲憊地走。

614
00:29:16,010 --> 00:29:18,950
在第一次的情況
我們有16個數字，

615
00:29:18,950 --> 00:29:22,210
所以maximally--我們只是
對於discussion--做到這一點

616
00:29:22,210 --> 00:29:25,640
我不得不通過16看
編號，以找到最小。

617
00:29:25,640 --> 00:29:28,420
但是，一旦我拔光了
最小的數，如何

618
00:29:28,420 --> 00:29:30,590
長得剩下的列表，當然，？

619
00:29:30,590 --> 00:29:31,420
只有15。

620
00:29:31,420 --> 00:29:34,670
那麼有多少數字做本或我有
通過第二次左右看？

621
00:29:34,670 --> 00:29:36,832
15，只是去尋找最小。

622
00:29:36,832 --> 00:29:39,540
但現在，當然，列表是，
也小於以前。

623
00:29:39,540 --> 00:29:42,540
那麼有多少步驟，做了我
必須採取下一次？

624
00:29:42,540 --> 00:29:49,970
14，然後13，然後12，加點，
點，點，直到我留下了只有一個。

625
00:29:49,970 --> 00:29:53,146
所以，現在的計算機科學家會
問：那麼，這是否人人平等？

626
00:29:53,146 --> 00:29:55,770
這實際上等於一些具體
數字，我們當然可以

627
00:29:55,770 --> 00:30:00,490
做算術，但是我們要談
關於算法的效率

628
00:30:00,490 --> 00:30:04,940
多一點通過公式，
獨立的列表是多久。

629
00:30:04,940 --> 00:30:06,240
>> 所以，你知道嗎？

630
00:30:06,240 --> 00:30:09,860
這是16日，但就像我之前說的，
我們只需要調用這個問題的規模

631
00:30:09,860 --> 00:30:10,970
n，其中n是一些數字。

632
00:30:10,970 --> 00:30:13,220
也許是16，也許這是
三，也許這是一個億。

633
00:30:13,220 --> 00:30:13,761
我不知道。

634
00:30:13,761 --> 00:30:14,390
我不在乎。

635
00:30:14,390 --> 00:30:16,520
我真正想要的是
一個公式，我可以

636
00:30:16,520 --> 00:30:19,420
用它來比較這算法
與其他算法

637
00:30:19,420 --> 00:30:22,350
有人可能聲稱
是好還是壞。

638
00:30:22,350 --> 00:30:25,430
>> 因此，原來，只有我
從小學知道這一點，

639
00:30:25,430 --> 00:30:34,790
這實際上工程以相同
事為n在N加一兩歲多。

640
00:30:34,790 --> 00:30:40,020
而這恰好相等，的
當然，N的平方加N超過兩。

641
00:30:40,020 --> 00:30:43,250
所以，如果我想要一個公式
有多少步

642
00:30:43,250 --> 00:30:46,330
參與看著都
連連這些數字的

643
00:30:46,330 --> 00:30:52,681
一次又一次，我會說
它n值的平方加N超過兩。

644
00:30:52,681 --> 00:30:53,430
但是，你知道嗎？

645
00:30:53,430 --> 00:30:54,500
這只是看起來凌亂。

646
00:30:54,500 --> 00:30:56,470
我真的很想要一個
的東西一般意義。

647
00:30:56,470 --> 00:30:58,810
你可能會從召回
高中有

648
00:30:58,810 --> 00:31:00,660
是最高階術語的概念。

649
00:31:00,660 --> 00:31:05,300
其中這些條款，第n
的平方，在n或半

650
00:31:05,300 --> 00:31:07,550
隨著時間的影響最大？

651
00:31:07,550 --> 00:31:11,920
更大的n變，這
這些問題的是什麼？

652
00:31:11,920 --> 00:31:15,560
>> 換句話說，如果我插
中了一千萬，N平方

653
00:31:15,560 --> 00:31:17,900
將是最有可能的
的主導因素，

654
00:31:17,900 --> 00:31:21,670
因為一百萬次
本身是大了很多

655
00:31:21,670 --> 00:31:23,682
比加一個附加萬元。

656
00:31:23,682 --> 00:31:24,390
所以，你知道嗎？

657
00:31:24,390 --> 00:31:27,305
這就是這樣一個混賬大
號，如果你方的數字。

658
00:31:27,305 --> 00:31:28,430
這其實並不重要。

659
00:31:28,430 --> 00:31:30,596
我們只是十字架
並忘掉它。

660
00:31:30,596 --> 00:31:34,250
所以，一個計算機科學家會說
該算法的效率

661
00:31:34,250 --> 00:31:37,850
為n的量級squared--
我的意思是真正的近似值。

662
00:31:37,850 --> 00:31:40,810
它是那種大約N個平方。

663
00:31:40,810 --> 00:31:44,130
隨著時間的推移，做大
和更大的n變，這

664
00:31:44,130 --> 00:31:47,610
是什麼樣的一個很好的估計
效率或缺乏效率

665
00:31:47,610 --> 00:31:49,400
這種算法實際上是。

666
00:31:49,400 --> 00:31:52,040
而我得到的，當然，
從實際上做數學。

667
00:31:52,040 --> 00:31:54,040
但現在我只是揮手
我的手，因為我只是

668
00:31:54,040 --> 00:31:55,790
希望這種算法的一般意義。

669
00:31:55,790 --> 00:31:58,850
>> 因此，使用相同的邏輯，同時，
讓我們考慮另一種算法

670
00:31:58,850 --> 00:32:01,162
我們已經看到at--線性搜索。

671
00:32:01,162 --> 00:32:02,870
當我搜索
為手機book--

672
00:32:02,870 --> 00:32:05,980
不選它，搜索
通過電話book--

673
00:32:05,980 --> 00:32:09,197
我們一直在說，這是
1000步，或500步。

674
00:32:09,197 --> 00:32:10,280
但是，讓我們籠統地說。

675
00:32:10,280 --> 00:32:12,860
如果有n個網頁
電話本，有什麼

676
00:32:12,860 --> 00:32:17,250
運行時間或
線性搜索的效率？

677
00:32:17,250 --> 00:32:19,750
它的順序
多少個步驟，找到

678
00:32:19,750 --> 00:32:24,210
用邁克·史密斯線性搜索，該
第一算法，或者甚至第二？

679
00:32:24,210 --> 00:32:27,240

680
00:32:27,240 --> 00:32:31,710
>> 在最壞的情況下，麥克
是在書的末尾。

681
00:32:31,710 --> 00:32:35,590
因此，如果電話本有1000頁，
我們說最後一次，在最壞的情況下，

682
00:32:35,590 --> 00:32:38,380
它可能需要大致有
很多網頁找邁克？

683
00:32:38,380 --> 00:32:38,990
像1000。

684
00:32:38,990 --> 00:32:39,830
這是一個上限。

685
00:32:39,830 --> 00:32:41,790
這是一個最壞的可能情況。

686
00:32:41,790 --> 00:32:44,410
但同樣，我們正在走
從像1000現在的號碼。

687
00:32:44,410 --> 00:32:45,730
這只是ñ。

688
00:32:45,730 --> 00:32:47,470
>> 那麼什麼是合乎邏輯的結論？

689
00:32:47,470 --> 00:32:50,210
在電話找到麥克
書中有n頁

690
00:32:50,210 --> 00:32:55,280
可能需要在最糟糕的情況下，
有多少n的順序步驟？

691
00:32:55,280 --> 00:32:58,110
的確計算機
科學家會說

692
00:32:58,110 --> 00:33:02,340
正在運行的時間，或
性能和效率

693
00:33:02,340 --> 00:33:07,470
或低效率的算法類的，
線性搜索是n的量級。

694
00:33:07,470 --> 00:33:10,010
我們可以採用同樣的
穿越出來的東西邏輯

695
00:33:10,010 --> 00:33:13,170
因為我只是做了第二個
算法中，我們曾與電話本，

696
00:33:13,170 --> 00:33:16,040
在這裡我們去一次兩頁。

697
00:33:16,040 --> 00:33:20,120
>> 因此，1000頁的電話本可能
帶我們500翻頁，加一

698
00:33:20,120 --> 00:33:21,910
如果我們加倍回位。

699
00:33:21,910 --> 00:33:26,590
因此，如果一個電話本有n個網頁，但
我們正在做的一次兩頁，

700
00:33:26,590 --> 00:33:28,900
這大概是什麼？

701
00:33:28,900 --> 00:33:33,190
ñ了兩個，所以這是如N超過兩。

702
00:33:33,190 --> 00:33:38,490
但是，我提出索賠一
剛才是n超過two--

703
00:33:38,490 --> 00:33:41,060
這是一種相同的是僅僅局限於N。

704
00:33:41,060 --> 00:33:44,050
這只是一個常數因子，
計算機科學家會說。

705
00:33:44,050 --> 00:33:45,970
讓我們只專注於
變量，真的 - 

706
00:33:45,970 --> 00:33:47,780
公式中的最大變量。

707
00:33:47,780 --> 00:33:52,530
>> 所以線性搜索，無論是做了一個
在同一時間或頁面同時兩頁，

708
00:33:52,530 --> 00:33:54,810
是那種基本上是相同的。

709
00:33:54,810 --> 00:33:56,880
它仍然是n的順序。

710
00:33:56,880 --> 00:34:01,930
但是，我有我的照片聲稱較早
該第三算法不是

711
00:34:01,930 --> 00:34:02,480
線性的。

712
00:34:02,480 --> 00:34:03,605
它不是一條直線。

713
00:34:03,605 --> 00:34:08,659
它是彎曲的線，且
代數公式有什麼呢？

714
00:34:08,659 --> 00:34:11,812
的N--日誌，以便日誌N的基地二期。

715
00:34:11,812 --> 00:34:14,520
同時，我們也沒有去考慮太多
今天對數的細節，

716
00:34:14,520 --> 00:34:17,394
但大多數計算機科學家不會
甚至告訴你基礎是什麼。

717
00:34:17,394 --> 00:34:20,639
因為這一切都只是
持續性因素，可以這麼說，

718
00:34:20,639 --> 00:34:22,659
只是輕微的數值差異。

719
00:34:22,659 --> 00:34:31,179
因此，這將是一個非常普遍的
這樣的特別正式的計算機

720
00:34:31,179 --> 00:34:33,949
科學家在一次董事會或
在白板程序員

721
00:34:33,949 --> 00:34:36,889
其實爭論這些
算法，他們將使用

722
00:34:36,889 --> 00:34:39,500
還是什麼效率
他們的算法。

723
00:34:39,500 --> 00:34:42,960
>> 這未必是
你在任何偉大的詳細討論，

724
00:34:42,960 --> 00:34:47,889
但一個優秀的程序員是誰家
誰擁有了堅實的，正式的背景。

725
00:34:47,889 --> 00:34:50,120
他能操
你在這種方式

726
00:34:50,120 --> 00:34:53,350
而實際上使
定性的論據，

727
00:34:53,350 --> 00:34:56,870
為什麼一種算法或
一個軟件

728
00:34:56,870 --> 00:35:00,165
在某些方面，以另一種優越。

729
00:35:00,165 --> 00:35:02,540
因為你肯定能
只要運行一個人的計劃

730
00:35:02,540 --> 00:35:04,980
和計數的秒數
花費一些數字排序，

731
00:35:04,980 --> 00:35:06,710
你可以運行一些
其他人的計劃

732
00:35:06,710 --> 00:35:08,418
和計數數
幾秒鐘需要。

733
00:35:08,418 --> 00:35:12,840
但是，這是一個更一般的方式
你可以用它來分析算法，

734
00:35:12,840 --> 00:35:15,520
如果你願意，只是
紙或只是口頭上。

735
00:35:15,520 --> 00:35:18,430
甚至沒有運行它，沒有
甚至還試圖採樣輸入，

736
00:35:18,430 --> 00:35:20,180
你可以正當理由通過它。

737
00:35:20,180 --> 00:35:24,670
因此與招聘開發人員，或者如果
有他或她之類的爭論給你

738
00:35:24,670 --> 00:35:28,460
為什麼他們的算法，他們的秘密
醬搜索數十億美元

739
00:35:28,460 --> 00:35:30,580
的網頁為您的
公司是更好的，這些

740
00:35:30,580 --> 00:35:33,302
是種參數它們
最好應該能夠做出。

741
00:35:33,302 --> 00:35:35,010
或者至少這些都是
這樣的東西

742
00:35:35,010 --> 00:35:40,211
這將拿出討論，在
至少在一個非常正式的討論。

743
00:35:40,211 --> 00:35:40,710
好吧。

744
00:35:40,710 --> 00:35:44,400
因此，本建議的東西
所謂的選擇排序。

745
00:35:44,400 --> 00:35:48,200
不過，我要提出有
這樣，太的其他方式。

746
00:35:48,200 --> 00:35:50,400
我真的不喜歡
有關本的算法

747
00:35:50,400 --> 00:35:54,400
是他繼續往前走，或
有我走，來回

748
00:35:54,400 --> 00:35:56,930
和來回和來回。

749
00:35:56,930 --> 00:36:04,130
如果不是我是做
像這裡這些數字

750
00:36:04,130 --> 00:36:08,200
和我只處理每
數字又因為我給它？

751
00:36:08,200 --> 00:36:10,780
>> 換句話說，這裡的
我的號碼列表。

752
00:36:10,780 --> 00:36:12,944
四，一，三，二。

753
00:36:12,944 --> 00:36:14,360
而且我要做到以下幾點。

754
00:36:14,360 --> 00:36:17,230
我要插入的數字
屬於他們的地方，而

755
00:36:17,230 --> 00:36:18,980
比選擇它們一次一個。

756
00:36:18,980 --> 00:36:20,820
換句話說，這裡的四個號碼。

757
00:36:20,820 --> 00:36:22,430
>> 這是我最初的名單。

758
00:36:22,430 --> 00:36:25,290
我要去維護
實際上在這裡一個新的列表。

759
00:36:25,290 --> 00:36:26,710
因此，這是舊的列表。

760
00:36:26,710 --> 00:36:28,560
這是新的列表。

761
00:36:28,560 --> 00:36:30,220
我看到的數字四個第一。

762
00:36:30,220 --> 00:36:34,500
我的新列表最初是空的，
因此它是平凡的情況下

763
00:36:34,500 --> 00:36:36,410
四個現在什錦列表。

764
00:36:36,410 --> 00:36:39,560
我只是把我提供的電話號碼，
而我把它在我的新名單。

765
00:36:39,560 --> 00:36:41,460
>> 正在這個新的列表排序？

766
00:36:41,460 --> 00:36:41,990
是啊。

767
00:36:41,990 --> 00:36:45,090
這是愚蠢的，因為只有一個
元素，但它絕對排序。

768
00:36:45,090 --> 00:36:46,390
沒有什麼不合適的。

769
00:36:46,390 --> 00:36:49,290
這是更有趣，這種算法，
當我移動到下一個步驟。

770
00:36:49,290 --> 00:36:50,550
>> 現在我有一個。

771
00:36:50,550 --> 00:36:55,430
因此，人們當然，屬於在
開始的時候還是這個新的列表的末尾？

772
00:36:55,430 --> 00:36:56,360
開始的時候。

773
00:36:56,360 --> 00:36:58,530
所以，我現在要做的一些工作。

774
00:36:58,530 --> 00:37:01,410
我已經採取了一些
我的標記自由

775
00:37:01,410 --> 00:37:03,120
通過只繪製的東西
在這裡我想他們，

776
00:37:03,120 --> 00:37:05,320
但是這不是真的
準確在計算機中。

777
00:37:05,320 --> 00:37:08,530
一台電腦，因為我們知道，有
RAM或隨機存取存儲器，

778
00:37:08,530 --> 00:37:12,411
這就是一個字節，
另一個字節一個字節。

779
00:37:12,411 --> 00:37:14,910
如果你有一個千兆字節
RAM，你有十億字節，

780
00:37:14,910 --> 00:37:16,680
但他們身在一個位置。

781
00:37:16,680 --> 00:37:19,540
你不能只是移動的東西左右
通過繪製在黑板上

782
00:37:19,540 --> 00:37:20,750
哪裡都行。

783
00:37:20,750 --> 00:37:24,090
所以，如果我的新名單有
在內存四個地點，

784
00:37:24,090 --> 00:37:27,480
不幸的是，四是
已經在錯誤的地方。

785
00:37:27,480 --> 00:37:30,410
>> 因此，要插入的頭號
我不能只是畫在這裡。

786
00:37:30,410 --> 00:37:31,901
此存儲器位置不存在。

787
00:37:31,901 --> 00:37:35,150
這將是欺騙，我一直
形象地欺騙幾分鐘

788
00:37:35,150 --> 00:37:35,800
這裡。

789
00:37:35,800 --> 00:37:40,950
所以真的，如果我想提出一個在這裡，
我不得不暫時複製四個

790
00:37:40,950 --> 00:37:43,030
然後把一個人也沒有。

791
00:37:43,030 --> 00:37:45,500
>> 這很好，這是正確的，
這是技術上是可行的，

792
00:37:45,500 --> 00:37:48,410
但知道這是額外的工作。

793
00:37:48,410 --> 00:37:50,460
我不只是把數字到位。

794
00:37:50,460 --> 00:37:53,026
我首先要移動
號碼，然後把它放到地方，

795
00:37:53,026 --> 00:37:54,650
讓我有種翻了一番我的工作量。

796
00:37:54,650 --> 00:37:55,660
所以記住這一點。

797
00:37:55,660 --> 00:37:57,120
>> 但我現在有了這個元素來完成。

798
00:37:57,120 --> 00:37:59,056
現在，我要搶位列第三。

799
00:37:59,056 --> 00:38:00,430
其中，當然，它屬於？

800
00:38:00,430 --> 00:38:01,480
在這兩者之間。

801
00:38:01,480 --> 00:38:03,650
我不能騙了
，只是把它放在那裡，

802
00:38:03,650 --> 00:38:06,770
因為，再一次，這種記憶
在物理位置。

803
00:38:06,770 --> 00:38:10,900
所以我要複製四個
並把三個在這裡。

804
00:38:10,900 --> 00:38:11,550
沒什麼大不了的。

805
00:38:11,550 --> 00:38:14,610
這只是一個額外的步驟
again--感覺很便宜。

806
00:38:14,610 --> 00:38:16,445
>> 但現在我移動到兩個。

807
00:38:16,445 --> 00:38:17,820
這兩個，當然，屬於這裡。

808
00:38:17,820 --> 00:38:20,990
現在你開始怎麼看
工作可以堆積起來。

809
00:38:20,990 --> 00:38:23,520
現在，我有什麼做的？

810
00:38:23,520 --> 00:38:28,570
是的，我要搬到四，
然後，我有三個拷貝，

811
00:38:28,570 --> 00:38:31,200
現在我可以插入兩個。

812
00:38:31,200 --> 00:38:34,460
而趕上這個
算法，有趣的是，

813
00:38:34,460 --> 00:38:41,050
是，假設我們有一個更極端
情況是假設八，七，

814
00:38:41,050 --> 00:38:45,150
六個五，四，三，二，一。

815
00:38:45,150 --> 00:38:49,450
這一點，在許多情況下，
最壞的情況下，

816
00:38:49,450 --> 00:38:51,570
因為混賬東西
簡直是倒退。

817
00:38:51,570 --> 00:38:53,670
>> 它並不真正的
影響本的算法，

818
00:38:53,670 --> 00:38:55,940
因為Ben的選擇
排序，他會一直

819
00:38:55,940 --> 00:38:58,359
來回通過列表。

820
00:38:58,359 --> 00:39:01,150
而且，因為他總是在尋找
通過整個其餘列表

821
00:39:01,150 --> 00:39:02,858
沒關係
其中元件是。

822
00:39:02,858 --> 00:39:05,630
但是，在這種情況下，我插
approach--讓我們試試這個。

823
00:39:05,630 --> 00:39:08,616
>> 這樣一，二，三，四，
五，六，七，八。

824
00:39:08,616 --> 00:39:11,630
一二三四，
五，六，七，八。

825
00:39:11,630 --> 00:39:14,320
我將採取八，
和我在哪裡把它？

826
00:39:14,320 --> 00:39:17,260
好吧，在我的名單開始，
因為這個新列表進行排序。

827
00:39:17,260 --> 00:39:18,760
我把它劃掉。

828
00:39:18,760 --> 00:39:20,551
>> 我在哪裡把七？

829
00:39:20,551 --> 00:39:21,050
該死。

830
00:39:21,050 --> 00:39:23,174
它需要去那裡，所以
我必須做一些複製。

831
00:39:23,174 --> 00:39:26,820

832
00:39:26,820 --> 00:39:28,480
而現在的七個放在這裡。

833
00:39:28,480 --> 00:39:29,860
現在，我移動到六人。

834
00:39:29,860 --> 00:39:30,980
現在，甚至更多的工作。

835
00:39:30,980 --> 00:39:32,570
>> 八就到這裡去。

836
00:39:32,570 --> 00:39:33,920
七就到這裡去。

837
00:39:33,920 --> 00:39:35,450
現在的六個可以去這裡。

838
00:39:35,450 --> 00:39:37,950
現在我搶五。

839
00:39:37,950 --> 00:39:40,560
現在八已去
在這裡，七就到這裡去，

840
00:39:40,560 --> 00:39:43,650
Six於這裡走，
現在五，重複動作。

841
00:39:43,650 --> 00:39:46,610
而且我非常
不斷移動它。

842
00:39:46,610 --> 00:39:52,950
>> 所以最終，這個算法 - 我們將
把它插入實際上類別 - 

843
00:39:52,950 --> 00:39:55,020
有很多工作了。

844
00:39:55,020 --> 00:39:56,970
這只是不同
實物比本的工作。

845
00:39:56,970 --> 00:40:00,090
Ben的工作讓我去
來回所有的時間，

846
00:40:00,090 --> 00:40:03,510
選擇下一個最小的
連連元件。

847
00:40:03,510 --> 00:40:06,660
所以這是這個極具視覺方面的工作。

848
00:40:06,660 --> 00:40:10,600
>> 此其它算法，這仍然是
correct--會得到這份工作done--

849
00:40:10,600 --> 00:40:12,800
只是改變的工作量。

850
00:40:12,800 --> 00:40:15,420
它看起來像最初你
節約，因為你只是

851
00:40:15,420 --> 00:40:19,190
處理每個元素
前面不走所有

852
00:40:19,190 --> 00:40:20,930
通過列表像本的方式了。

853
00:40:20,930 --> 00:40:25,300
但問題是，尤其是在這些
瘋狂的情況下，這一切都反了，

854
00:40:25,300 --> 00:40:27,830
你是那種只
推遲的辛勤工作

855
00:40:27,830 --> 00:40:30,360
直到你有修正自己的錯誤。

856
00:40:30,360 --> 00:40:33,919
>> 所以，如果你能想像這
八七十六加五

857
00:40:33,919 --> 00:40:36,710
後來四加三和二
在列表中移動自己的方式，

858
00:40:36,710 --> 00:40:39,060
我們只是改變了
工種我們正在做的。

859
00:40:39,060 --> 00:40:42,340
而不是在做
開始我的迭代，

860
00:40:42,340 --> 00:40:45,250
我只是在做它在
每次迭代結束。

861
00:40:45,250 --> 00:40:50,550
所以，事實證明，這個算法，
同樣，一般稱為插入排序，

862
00:40:50,550 --> 00:40:52,190
也是為n的平方的數量級。

863
00:40:52,190 --> 00:40:56,480
它實際上是沒有更好的，
沒有更好的。

864
00:40:56,480 --> 00:41:00,810
>> 但是，有一個第三個方法
我會鼓勵我們考慮，

865
00:41:00,810 --> 00:41:02,970
這是這樣的。

866
00:41:02,970 --> 00:41:07,850
因此，假設我的名單，為簡單起見
再次，為四，一，三，

867
00:41:07,850 --> 00:41:11,080
two--只有四個數字。

868
00:41:11,080 --> 00:41:13,300
本有很好的直覺，
良好的人的直覺

869
00:41:13,300 --> 00:41:16,340
之前，由我們解決了整個
列出eventually--插入排序。

870
00:41:16,340 --> 00:41:18,020
我哄我們一起。

871
00:41:18,020 --> 00:41:22,530
但是讓我們考慮
要解決這個列表最簡單的方法。

872
00:41:22,530 --> 00:41:24,110
>> 未排序此列表。

873
00:41:24,110 --> 00:41:26,130
為什麼？

874
00:41:26,130 --> 00:41:31,920
在英語中，解釋原因
它實際上沒有進行排序。

875
00:41:31,920 --> 00:41:33,400
是什麼意思不進行排序？

876
00:41:33,400 --> 00:41:34,220
>> 學生：這不是連續的。

877
00:41:34,220 --> 00:41:34,990
>> DAVID MALAN：不連續的。

878
00:41:34,990 --> 00:41:35,822
給我一個例子。

879
00:41:35,822 --> 00:41:37,180
>> 學生：把它們的順序。

880
00:41:37,180 --> 00:41:37,440
>> DAVID MALAN：OK。

881
00:41:37,440 --> 00:41:38,790
給我一個更具體的例子。

882
00:41:38,790 --> 00:41:39,832
>> 學生：升序排列。

883
00:41:39,832 --> 00:41:41,206
DAVID MALAN：不按升序排列。

884
00:41:41,206 --> 00:41:42,100
更精確。

885
00:41:42,100 --> 00:41:45,190
我不知道你的上升是什麼意思。

886
00:41:45,190 --> 00:41:47,150
怎麼了？

887
00:41:47,150 --> 00:41:49,930
>> 學生：最小的
號碼是不是在第一空間。

888
00:41:49,930 --> 00:41:51,140
>> DAVID MALAN：最小號的
未在第一空間。

889
00:41:51,140 --> 00:41:52,120
更加具體。

890
00:41:52,120 --> 00:41:55,000
我開始流行起來。

891
00:41:55,000 --> 00:41:59,470
我們計算，但
什麼是壞了嗎？

892
00:41:59,470 --> 00:42:00,707
>> 學生：數值序列。

893
00:42:00,707 --> 00:42:02,040
DAVID MALAN：數值序列。

894
00:42:02,040 --> 00:42:04,248
每個人的一種飼養的
它這裡 - 非常高的水平。

895
00:42:04,248 --> 00:42:07,450
只是從字面上告訴我什麼
錯誤就像一個五十歲的威力。

896
00:42:07,450 --> 00:42:08,310
>> 學生：加一。

897
00:42:08,310 --> 00:42:08,750
>> DAVID MALAN：那是什麼？

898
00:42:08,750 --> 00:42:09,610
>> 學生：加一。

899
00:42:09,610 --> 00:42:11,235
>> DAVID MALAN：你的意思是加一？

900
00:42:11,235 --> 00:42:12,754

901
00:42:12,754 --> 00:42:14,170
給我一個不同的五十歲。

902
00:42:14,170 --> 00:42:16,840

903
00:42:16,840 --> 00:42:18,330
怎麼了，媽媽？

904
00:42:18,330 --> 00:42:19,940
有什麼不對，爸爸？

905
00:42:19,940 --> 00:42:22,808
你是什​​麼意思這是沒有排序？

906
00:42:22,808 --> 00:42:24,370
>> 學生：這是不正確的地方。

907
00:42:24,370 --> 00:42:25,580
>> DAVID MALAN：什麼是
不正確的地方？

908
00:42:25,580 --> 00:42:26,174
>> 學生：四。

909
00:42:26,174 --> 00:42:27,090
DAVID MALAN：OK，好了。

910
00:42:27,090 --> 00:42:29,110
因此，四是不是哪裡它應該是。

911
00:42:29,110 --> 00:42:30,590
特別是，這是正確的？

912
00:42:30,590 --> 00:42:33,000
四一，第一
兩個數字我明白了。

913
00:42:33,000 --> 00:42:34,930
這是正確的嗎？

914
00:42:34,930 --> 00:42:36,427
不，他們不按順序，對不對？

915
00:42:36,427 --> 00:42:38,135
其實，現在想想
關於計算機了。

916
00:42:38,135 --> 00:42:40,824
它只能看看也許有，
在once--也許是兩件事

917
00:42:40,824 --> 00:42:43,240
實際上只做一件事
的時間，但它可以至少

918
00:42:43,240 --> 00:42:45,790
看一件事則
緊挨著它未來的事情。

919
00:42:45,790 --> 00:42:47,380
>> 那麼，這些才能？

920
00:42:47,380 --> 00:42:48,032
當然不是。

921
00:42:48,032 --> 00:42:48,740
所以，你知道嗎？

922
00:42:48,740 --> 00:42:51,020
我們為什麼不帶寶貝
步驟解決這個問題

923
00:42:51,020 --> 00:42:53,410
而不是做這些花哨
算法，如奔，其中

924
00:42:53,410 --> 00:42:56,440
他用那種固定它
通過該列表循環

925
00:42:56,440 --> 00:42:59,670
而不是做我做什麼，在哪裡
因為我們去我只是一種固定的呢？

926
00:42:59,670 --> 00:43:03,650
我們只是從字面上打破
order--數字順序的概念，

927
00:43:03,650 --> 00:43:06,990
調用它不管你want--
在這些兩兩比較。

928
00:43:06,990 --> 00:43:07,590
>> 四一。

929
00:43:07,590 --> 00:43:09,970
這是正確的順序？

930
00:43:09,970 --> 00:43:11,310
因此，讓我們解決這個問題。

931
00:43:11,310 --> 00:43:14,700
一和四，然後
我們只是複製。

932
00:43:14,700 --> 00:43:15,560
好吧，好了。

933
00:43:15,560 --> 00:43:17,022
我固定的一到四。

934
00:43:17,022 --> 00:43:18,320
三加二？

935
00:43:18,320 --> 00:43:18,820
沒有。

936
00:43:18,820 --> 00:43:21,690
讓我說的話我的手指相匹配。

937
00:43:21,690 --> 00:43:23,695
四加三？

938
00:43:23,695 --> 00:43:27,930
>> 這不是為了，所以我打算
做一，三，四兩。

939
00:43:27,930 --> 00:43:28,680
OK，不錯。

940
00:43:28,680 --> 00:43:32,310
現在，四個和兩個？

941
00:43:32,310 --> 00:43:33,370
我們需要解決這個問題了。

942
00:43:33,370 --> 00:43:36,700
這樣一，三，二，四。

943
00:43:36,700 --> 00:43:39,820
因此，它是排序？

944
00:43:39,820 --> 00:43:43,170
沒有，但它是更接近排序？

945
00:43:43,170 --> 00:43:48,930
>> 這是因為我們解決了這個
錯，我們修正了這個錯誤，

946
00:43:48,930 --> 00:43:50,370
我們修正了這個錯誤。

947
00:43:50,370 --> 00:43:52,420
因此，我們定三大誤區無疑。

948
00:43:52,420 --> 00:43:58,100
仍然沒有真正審視排序，但
它客觀上更接近排序

949
00:43:58,100 --> 00:44:00,080
因為我們固定其中的一些錯誤。

950
00:44:00,080 --> 00:44:02,047
>> 現在我該怎麼做？

951
00:44:02,047 --> 00:44:03,630
我有種到達列表的末尾。

952
00:44:03,630 --> 00:44:05,680
我似乎已經固定
所有的錯誤，但沒有。

953
00:44:05,680 --> 00:44:08,510
因為在這種情況下，一些數字
可能接近已冒泡

954
00:44:08,510 --> 00:44:10,410
其他數字，
還是亂序。

955
00:44:10,410 --> 00:44:12,951
因此，讓我們做一遍，我會
只是做的地方這個時候。

956
00:44:12,951 --> 00:44:14,170
一個和三個？

957
00:44:14,170 --> 00:44:14,720
沒關係。

958
00:44:14,720 --> 00:44:16,070
三加二？

959
00:44:16,070 --> 00:44:17,560
當然沒有，所以讓我們改變這種狀況。

960
00:44:17,560 --> 00:44:19,160
所以，二，三。

961
00:44:19,160 --> 00:44:21,340
三，四？

962
00:44:21,340 --> 00:44:24,370
現在，讓我們只是
尤其是迂腐在這裡。

963
00:44:24,370 --> 00:44:26,350
難道排序？

964
00:44:26,350 --> 00:44:29,280
你們人類知道它的排序。

965
00:44:29,280 --> 00:44:30,400
>> 我應該再次嘗試。

966
00:44:30,400 --> 00:44:31,900
所以奧利維亞提議我再試試。

967
00:44:31,900 --> 00:44:32,530
為什麼？

968
00:44:32,530 --> 00:44:35,810
因為計算機沒有
我們人眼的奢侈

969
00:44:35,810 --> 00:44:38,080
只是一眼back-- OK，我完成了。

970
00:44:38,080 --> 00:44:41,610
如何計算機確定
該列表現在排序？

971
00:44:41,610 --> 00:44:44,590
機械。

972
00:44:44,590 --> 00:44:47,650
>> 我應該通過
一次，且僅當我

973
00:44:47,650 --> 00:44:51,190
不做/發現任何錯誤我可以
然後得出結論：隨著計算機，是的，

974
00:44:51,190 --> 00:44:51,980
我們是好去。

975
00:44:51,980 --> 00:44:54,850
所以一和二，二和
三，三，四。

976
00:44:54,850 --> 00:44:58,030
現在我可以明確地說，這是
排序，因為我不需要做任何改變。

977
00:44:58,030 --> 00:45:01,940
現在，這將是一個錯誤，只是
如果我愚蠢，電腦，

978
00:45:01,940 --> 00:45:05,640
又問那些相同的問題
期待不同的答案。

979
00:45:05,640 --> 00:45:07,110
不應該發生。

980
00:45:07,110 --> 00:45:08,600
>> 所以現在的列表進行排序。

981
00:45:08,600 --> 00:45:12,630
不幸的是，運行時間
該算法也可為N的平方。

982
00:45:12,630 --> 00:45:13,130
為什麼？

983
00:45:13,130 --> 00:45:19,520
因為你有n個數，並在
最壞的情況下，你必須移動n個數

984
00:45:19,520 --> 00:45:23,637
n次，因為你必須堅持下去
回查和潛在的修復

985
00:45:23,637 --> 00:45:24,220
這些數字。

986
00:45:24,220 --> 00:45:26,280
我們可以做的更
正式的分析了。

987
00:45:26,280 --> 00:45:29,530
>> 所以這是大家說，我們已經採取了
三種不同的方法，一是

988
00:45:29,530 --> 00:45:32,210
他們立即直觀
關閉距離Ben蝙蝠

989
00:45:32,210 --> 00:45:35,170
我的建議的插入
排序這個

990
00:45:35,170 --> 00:45:38,540
在這裡你那種忽視
林為最初的樹木。

991
00:45:38,540 --> 00:45:41,760
不過，如果你退一步，
瞧，我們已經解決了分揀概念。

992
00:45:41,760 --> 00:45:43,824
因此，這是，敢說，
一個較低的水平也許

993
00:45:43,824 --> 00:45:45,740
比一些其他的
算法，但讓我們

994
00:45:45,740 --> 00:45:48,550
看看我們能不能想像
這些通過這種方式。

995
00:45:48,550 --> 00:45:51,450
>> 因此，這是一些很不錯的
軟件，有人

996
00:45:51,450 --> 00:45:56,110
用豐富多彩的酒吧這是寫
要做到以下幾點我們。

997
00:45:56,110 --> 00:45:57,736
每個這些棒的代表編號。

998
00:45:57,736 --> 00:46:00,026
德勒酒吧，大
數目，更小的吧，

999
00:46:00,026 --> 00:46:00,990
數越小。

1000
00:46:00,990 --> 00:46:05,880
因此，理想的，我們希望有一個漂亮的金字塔
它開始時很小，並得到大，

1001
00:46:05,880 --> 00:46:08,330
這將意味著
這些酒吧進行排序。

1002
00:46:08,330 --> 00:46:11,200
所以我要繼續前進，選擇，
例如，本算法

1003
00:46:11,200 --> 00:46:13,990
序曲一選擇排序。

1004
00:46:13,990 --> 00:46:16,220
>> 並注意它在做什麼。

1005
00:46:16,220 --> 00:46:18,670
他們選擇的方式
想像這個算法

1006
00:46:18,670 --> 00:46:22,090
是的，就像我是
通過我的名單散步，

1007
00:46:22,090 --> 00:46:24,710
這一計劃是走
通過其號碼列表，

1008
00:46:24,710 --> 00:46:28,160
突出每個粉紅色
它在看數字。

1009
00:46:28,160 --> 00:46:32,360
什麼是關於現在發生？

1010
00:46:32,360 --> 00:46:35,154
>> 最小數
我還是奔發現突然

1011
00:46:35,154 --> 00:46:36,820
被移動到列表的開頭。

1012
00:46:36,820 --> 00:46:40,037
並注意他們做了逐出
這是有數字，

1013
00:46:40,037 --> 00:46:41,120
這就是完美的罰款。

1014
00:46:41,120 --> 00:46:42,600
我沒有進入詳細程度。

1015
00:46:42,600 --> 00:46:44,308
但是，我們需要把
這個數字的地方，

1016
00:46:44,308 --> 00:46:47,775
所以我們只是把它移到
已創建空位。

1017
00:46:47,775 --> 00:46:49,900
所以，我要加速這一
起來，因為否則它

1018
00:46:49,900 --> 00:46:51,871
變得非常乏味迅速。

1019
00:46:51,871 --> 00:46:55,800

1020
00:46:55,800 --> 00:46:58,600
動畫speed--我們走吧。

1021
00:46:58,600 --> 00:47:01,850
所以，現在同樣的原理
我申請，但你

1022
00:47:01,850 --> 00:47:06,540
可以開始感受算法，如果你
會的，或者看它多一點清晰。

1023
00:47:06,540 --> 00:47:13,190
並且該算法具有的效果
選擇下一個最小的元素，

1024
00:47:13,190 --> 00:47:16,422
所以你要開始
看到它坡道在左邊。

1025
00:47:16,422 --> 00:47:19,130
並在每次迭代中，我
提出的，它確實有點不太工作。

1026
00:47:19,130 --> 00:47:21,921
它沒有走一路
返回清單的左端，

1027
00:47:21,921 --> 00:47:23,900
因為它已經
知道這些排序。

1028
00:47:23,900 --> 00:47:28,129
因此，那種感覺就像是
加速，即使每個步驟是

1029
00:47:28,129 --> 00:47:29,420
取的時間相同。

1030
00:47:29,420 --> 00:47:31,600
這裡還有剩餘更少的步驟。

1031
00:47:31,600 --> 00:47:35,240
現在你可以種感受
算法清理它的結束，

1032
00:47:35,240 --> 00:47:37,040
實際上現在它的排序。

1033
00:47:37,040 --> 00:47:41,620
>> 所以插入排序是全部完成。

1034
00:47:41,620 --> 00:47:43,600
我需要重新隨機陣列。

1035
00:47:43,600 --> 00:47:45,940
並注意我可以
保持隨機的，

1036
00:47:45,940 --> 00:47:50,630
我們會得到一個近似
同樣的方法，插入排序。

1037
00:47:50,630 --> 00:47:55,050
讓我慢下來到這裡。

1038
00:47:55,050 --> 00:47:56,915
讓我們開始，超過。

1039
00:47:56,915 --> 00:47:57,414
停止。

1040
00:47:57,414 --> 00:48:00,662

1041
00:48:00,662 --> 00:48:02,410
>> 讓我們跳過四人。

1042
00:48:02,410 --> 00:48:03,200
在那裡，我們走了。

1043
00:48:03,200 --> 00:48:04,190
隨機他們陣。

1044
00:48:04,190 --> 00:48:05,555
在這裡，我們go--插入排序。

1045
00:48:05,555 --> 00:48:10,260

1046
00:48:10,260 --> 00:48:12,800
玩。

1047
00:48:12,800 --> 00:48:17,280
請注意，它在處理每
元素遇到向右走，

1048
00:48:17,280 --> 00:48:20,282
但是，如果它是屬於在
放錯了地方的通知

1049
00:48:20,282 --> 00:48:21,740
所有這些都發生在工作。

1050
00:48:21,740 --> 00:48:24,700
我們必須繼續將更多
和以上的元素，以騰出空間

1051
00:48:24,700 --> 00:48:27,340
對於一個我們要到位。

1052
00:48:27,340 --> 00:48:30,740
>> 因此，我們專注於
僅列表的左端。

1053
00:48:30,740 --> 00:48:34,460
請注意，我們甚至還沒有看at--我們
在粉紅色的東西都沒有突出

1054
00:48:34,460 --> 00:48:35,610
在右邊。

1055
00:48:35,610 --> 00:48:38,180
我們只是處理
這些問題，因為我們去，

1056
00:48:38,180 --> 00:48:40,430
但我們創造了很多
為自己的工作依然。

1057
00:48:40,430 --> 00:48:44,410
所以，如果我們加快這
現在去完成，

1058
00:48:44,410 --> 00:48:46,210
它有不同的感覺確實如此。

1059
00:48:46,210 --> 00:48:50,150
這只是專注於最左端，但
做多一點的工作作為needed--

1060
00:48:50,150 --> 00:48:53,230
一種平滑的事情
過去，固定的東西，

1061
00:48:53,230 --> 00:48:58,350
但最終處理
每個元素一次一個

1062
00:48:58,350 --> 00:49:07,740
直到我們到達曲風很好，我們
都知道這是怎麼回事結束，

1063
00:49:07,740 --> 00:49:09,700
所以這是一個有點給人留下深刻印象也許吧。

1064
00:49:09,700 --> 00:49:12,830
>> 但清單中end--
spoiler--將被排序。

1065
00:49:12,830 --> 00:49:15,300
因此，讓我們來看看最後一之一。

1066
00:49:15,300 --> 00:49:16,840
我們不能只是現在跳過。

1067
00:49:16,840 --> 00:49:18,000
我們快到了。

1068
00:49:18,000 --> 00:49:19,980
二去，一去。

1069
00:49:19,980 --> 00:49:22,680
瞧。

1070
00:49:22,680 --> 00:49:23,450
優秀。

1071
00:49:23,450 --> 00:49:27,220
>> 所以，現在讓我們做最後一人一個，
重新隨機與冒泡排序。

1072
00:49:27,220 --> 00:49:31,690
並注意這裡，尤其是如果我慢
下來，這也保持俯衝通過。

1073
00:49:31,690 --> 00:49:36,830
但是請注意，它只是使成對
comparisons--排序當地的解決方案。

1074
00:49:36,830 --> 00:49:39,050
但是，只要我們得到
在粉紅色的列表的末尾，

1075
00:49:39,050 --> 00:49:40,690
什麼將不得不再次發生？

1076
00:49:40,690 --> 00:49:44,539

1077
00:49:44,539 --> 00:49:46,830
是的，這將有
重新開始，因為它只

1078
00:49:46,830 --> 00:49:49,870
固定配對錯誤。

1079
00:49:49,870 --> 00:49:53,120
和可能已揭示還有一些。

1080
00:49:53,120 --> 00:49:58,950
所以，如果你的速度這件事，你會
看到的是，多顧名思義，

1081
00:49:58,950 --> 00:50:01,870
較小的elements--或者說，
大elements--開始

1082
00:50:01,870 --> 00:50:03,740
泡到頂部，如果你願意。

1083
00:50:03,740 --> 00:50:07,380
和較小的元素是
開始氣泡向下到左側。

1084
00:50:07,380 --> 00:50:10,780
事實上，這是一種
視覺效果為好。

1085
00:50:10,780 --> 00:50:17,150
所以這將結束整理
在一個非常類似的方式，也是。

1086
00:50:17,150 --> 00:50:19,160
>> 我們不必糾纏
在這個特別的。

1087
00:50:19,160 --> 00:50:21,010
現在讓我開這個。

1088
00:50:21,010 --> 00:50:24,040
還有一些其他的排序算法
在世界上，幾其中

1089
00:50:24,040 --> 00:50:25,580
在這裡拍攝的。

1090
00:50:25,580 --> 00:50:29,960
尤其是對學習者誰不
一定視覺或數學，

1091
00:50:29,960 --> 00:50:31,930
因為我們以前那樣，我們可以
也做到這一點audially

1092
00:50:31,930 --> 00:50:34,210
如果我們完善與此相關聯。

1093
00:50:34,210 --> 00:50:36,990
而只是為了好玩，這裡有一個
幾個不同的算法，

1094
00:50:36,990 --> 00:50:40,950
特別是其中一個你
要注意的是所謂的“合併排序”。

1095
00:50:40,950 --> 00:50:43,250
>> 它實際上是一個根本
更好的算法，

1096
00:50:43,250 --> 00:50:45,860
這樣歸併排序，一
你即將看到的那些，

1097
00:50:45,860 --> 00:50:49,170
不是n階平方。

1098
00:50:49,170 --> 00:50:57,280
它的n倍登錄的順序
N，這實際上是小的，因此

1099
00:50:57,280 --> 00:50:58,940
比其他三個更快。

1100
00:50:58,940 --> 00:51:00,670
而且還有其他的一對夫婦
愚蠢的人，我們拭目以待。

1101
00:51:00,670 --> 00:51:01,933
>> 所以在這裡，我們去一些聲音。

1102
00:51:01,933 --> 00:51:06,620

1103
00:51:06,620 --> 00:51:10,490
這是插入排序，如此反复
它只是處理的元素

1104
00:51:10,490 --> 00:51:13,420
因為他們來。

1105
00:51:13,420 --> 00:51:17,180
這是冒泡排序，所以它的
考慮到他們在同一時間對。

1106
00:51:17,180 --> 00:51:22,030

1107
00:51:22,030 --> 00:51:24,490
再次，最大的元素
被鼓泡到頂部。

1108
00:51:24,490 --> 00:51:38,098

1109
00:51:38,098 --> 00:51:41,710
>> 接下來選擇排序。

1110
00:51:41,710 --> 00:51:45,420
這是Ben的算法，其中
再次，他的選擇反复

1111
00:51:45,420 --> 00:51:46,843
下一個最小的元素。

1112
00:51:46,843 --> 00:51:49,801

1113
00:51:49,801 --> 00:51:53,900
再次，現在你真的可以聽到
它加快了，但只有在目前為止

1114
00:51:53,900 --> 00:51:58,230
因為它做的越來越少
在每次迭代運行。

1115
00:51:58,230 --> 00:52:04,170
這是一個更快，歸併排序，
這是排序的數字集群

1116
00:52:04,170 --> 00:52:05,971
在一起，然後將它們結合起來。

1117
00:52:05,971 --> 00:52:07,720
所以look--左
一半已經排序。

1118
00:52:07,720 --> 00:52:14,165
>> 現在它的分選的右半和
現在它打算將它們合二為一。

1119
00:52:14,165 --> 00:52:19,160
這就是所謂的“侏儒排序。”

1120
00:52:19,160 --> 00:52:23,460
你可以種看到
它會來回，

1121
00:52:23,460 --> 00:52:27,950
一點點在這裡固定的工作，
那裡之前它進入新的工作。

1122
00:52:27,950 --> 00:52:32,900

1123
00:52:32,900 --> 00:52:33,692
就是這樣。

1124
00:52:33,692 --> 00:52:36,400
還有另外一種，這是
真的只是為學術目的，

1125
00:52:36,400 --> 00:52:40,980
所謂的“愚蠢的排序，”這需要
您的數據，隨機進行排序，

1126
00:52:40,980 --> 00:52:43,350
如果是排序，然後檢查。

1127
00:52:43,350 --> 00:52:47,880
如果不是的話，它重新排序它
隨機，檢查它是否排序，

1128
00:52:47,880 --> 00:52:49,440
如果不重複。

1129
00:52:49,440 --> 00:52:52,660
在理論上，概率性
這將完成，

1130
00:52:52,660 --> 00:52:54,140
但經過相當多的時間。

1131
00:52:54,140 --> 00:52:56,930
這還不是最
高效的算法。

1132
00:52:56,930 --> 00:53:02,550
因此，對這些有任何疑問
特殊的算法或任何

1133
00:53:02,550 --> 00:53:04,720
相關那裡嗎？

1134
00:53:04,720 --> 00:53:09,430
>> 好了，現在讓我們梳理出什麼都
這些線，我一直在畫

1135
00:53:09,430 --> 00:53:15,090
什麼我假設電腦
可在引擎蓋下面做的。

1136
00:53:15,090 --> 00:53:18,650
我認為，所有這些數字
我一直drawing--他們需要得到

1137
00:53:18,650 --> 00:53:21,330
某處存儲在存儲器中。

1138
00:53:21,330 --> 00:53:24,130
現在，我們要擺脫這個傢伙了。

1139
00:53:24,130 --> 00:53:30,110
>> 所以在一塊內存
computer--所以RAM DIMM是

1140
00:53:30,110 --> 00:53:35,480
我們搜索了昨天，雙
列直插式內存module--看起來是這樣的。

1141
00:53:35,480 --> 00:53:39,370
而每這些黑色小芯片
是一定數量的字節，一般。

1142
00:53:39,370 --> 00:53:44,380
然後將金銷彷若
它連接到計算機電線，

1143
00:53:44,380 --> 00:53:47,521
和綠碳化矽板僅僅是
是什麼讓一切都在一起。

1144
00:53:47,521 --> 00:53:48,770
那麼，這究竟意味著什麼？

1145
00:53:48,770 --> 00:53:53,180
如果我有點畫同樣的畫面，
讓我們假設為簡單

1146
00:53:53,180 --> 00:53:55,280
這DIMM，雙
列直插內存模塊，

1147
00:53:55,280 --> 00:54:00,530
是的RAM一千兆的一千兆字節
記憶，這是多少字節總數是多少？

1148
00:54:00,530 --> 00:54:02,100
一千兆是多少字節？

1149
00:54:02,100 --> 00:54:04,860

1150
00:54:04,860 --> 00:54:06,030
比那更多的。

1151
00:54:06,030 --> 00:54:09,960
1124是公斤，1000。

1152
00:54:09,960 --> 00:54:11,730
米加是萬人。

1153
00:54:11,730 --> 00:54:14,570
GIGA是一個數十億。

1154
00:54:14,570 --> 00:54:15,070
>> 我在撒謊？

1155
00:54:15,070 --> 00:54:16,670
我們甚至可以讀取標籤？

1156
00:54:16,670 --> 00:54:19,920
這實際上是128
千兆字節，所以它的更多。

1157
00:54:19,920 --> 00:54:22,130
但我們會假裝這
僅僅是一千兆字節。

1158
00:54:22,130 --> 00:54:25,640
因此，這意味著有一個十億
提供給我的內存字節

1159
00:54:25,640 --> 00:54:29,770
或8十億位，但我們要
在字節方面談現在，

1160
00:54:29,770 --> 00:54:30,750
向前進。

1161
00:54:30,750 --> 00:54:36,330
>> 所以，這是什麼意思是，這是
一個字節，這是另外一個字節，

1162
00:54:36,330 --> 00:54:38,680
這是另外一個字節，
如果我們真的想

1163
00:54:38,680 --> 00:54:43,280
要具體我們將不得不
畫一個十億的小廣場。

1164
00:54:43,280 --> 00:54:44,320
但是，這是什麼意思？

1165
00:54:44,320 --> 00:54:46,420
好吧，讓我放大
在這張圖片。

1166
00:54:46,420 --> 00:54:50,900
如果我已經得到的東西看起來
現在這個樣子，這是四個字節。

1167
00:54:50,900 --> 00:54:53,710
>> 所以，我可以把四個數字在這裡。

1168
00:54:53,710 --> 00:54:54,990
一二三四。

1169
00:54:54,990 --> 00:55:00,170
或者，我可以把四個字母或符號。

1170
00:55:00,170 --> 00:55:02,620
“嘿！”可以去那裡，
因為每個字母，

1171
00:55:02,620 --> 00:55:04,370
我們前面所討論的，
可以表示

1172
00:55:04,370 --> 00:55:06,650
用八位或ASCII或一個字節。

1173
00:55:06,650 --> 00:55:09,370
所以，換句話說，你可以
把8個十億裡面的東西

1174
00:55:09,370 --> 00:55:11,137
的記憶這一棒。

1175
00:55:11,137 --> 00:55:14,345
現在是什麼意思把東西背
備份內存來支持這樣嗎？

1176
00:55:14,345 --> 00:55:17,330
這是一個程序員
稱之為“陣列”。

1177
00:55:17,330 --> 00:55:21,250
在計算機程序中，你不覺得
關於底層硬件本身。

1178
00:55:21,250 --> 00:55:24,427
你只是覺得自己是有
訪問十億字節總，

1179
00:55:24,427 --> 00:55:26,010
你可以任何你想做的事情。

1180
00:55:26,010 --> 00:55:27,880
但為了方便
這是一般有用

1181
00:55:27,880 --> 00:55:31,202
保持你的記憶權
彼此相鄰這樣。

1182
00:55:31,202 --> 00:55:33,660
所以，如果我放大this--
因為我們肯定不會

1183
00:55:33,660 --> 00:55:39,310
畫一個十億一點squares--
讓我們假設這個委員會代表

1184
00:55:39,310 --> 00:55:40,610
的內存棒了。

1185
00:55:40,610 --> 00:55:43,800
而我就畫多達我
標記結束了在這裡給我的。

1186
00:55:43,800 --> 00:55:46,420

1187
00:55:46,420 --> 00:55:52,300
所以現在我們有一棒
對板載內存

1188
00:55:52,300 --> 00:55:56,400
那種有一，二，三，四，五，
六個一，二，三，四，五，六，

1189
00:55:56,400 --> 00:56:01,130
seven--所以42字節
存儲器上的屏幕總。

1190
00:56:01,130 --> 00:56:01,630
謝謝。

1191
00:56:01,630 --> 00:56:02,838
是的，沒有我的算術右移。

1192
00:56:02,838 --> 00:56:05,120
所以42字節的內存在這裡。

1193
00:56:05,120 --> 00:56:06,660
那麼，這實際上意味著什麼呢？

1194
00:56:06,660 --> 00:56:09,830
那麼，一個計算機程序員
實際上一般

1195
00:56:09,830 --> 00:56:12,450
認為這種內存尋址。

1196
00:56:12,450 --> 00:56:16,630
換句話說，每一個這些
在存儲器位置，在硬件，

1197
00:56:16,630 --> 00:56:18,030
具有唯一的地址。

1198
00:56:18,030 --> 00:56:22,020
>> 它並不像一個布拉特爾複雜
廣場，劍橋，馬薩諸塞州，02138。

1199
00:56:22,020 --> 00:56:23,830
相反，它只是一個數字。

1200
00:56:23,830 --> 00:56:27,930
這是字節數為零，這是
之一，這是二，這是三個

1201
00:56:27,930 --> 00:56:30,327
這就是41。

1202
00:56:30,327 --> 00:56:30,910
等一下。

1203
00:56:30,910 --> 00:56:32,510
我想我說42剛才。

1204
00:56:32,510 --> 00:56:35,050

1205
00:56:35,050 --> 00:56:37,772
我開始在零算起，
所以這實際上是正確的。

1206
00:56:37,772 --> 00:56:40,980
現在我們不必實際繪製它
作為一個網格，如果它畫成網格

1207
00:56:40,980 --> 00:56:43,520
我覺得其實事情
會有點誤導。

1208
00:56:43,520 --> 00:56:46,650
什麼是程序員，
在他或她自己的頭腦，

1209
00:56:46,650 --> 00:56:50,310
一般認為這
內存就像磁帶，

1210
00:56:50,310 --> 00:56:53,340
像一塊遮蔽膠帶
只是推移和永遠

1211
00:56:53,340 --> 00:56:54,980
或者直到你耗盡內存。

1212
00:56:54,980 --> 00:56:59,200
因此，一個比較常見的辦法畫
而只是想想內存

1213
00:56:59,200 --> 00:57:03,710
會，這是字節零個，一個
兩個，三個，然後點，小點，小點。

1214
00:57:03,710 --> 00:57:07,650
你共有42這樣的字節，即使
雖然身體上它實際上可能

1215
00:57:07,650 --> 00:57:09,480
更多的東西這樣。

1216
00:57:09,480 --> 00:57:12,850
>> 所以，如果你覺得現在的你
內存因為這，就像磁帶，

1217
00:57:12,850 --> 00:57:17,640
這是一個程序員再次
將要求的存儲器陣列。

1218
00:57:17,640 --> 00:57:20,660
而當你想實際存儲
東西在計算機的內存，

1219
00:57:20,660 --> 00:57:23,290
你一般做店裡的東西
後端到背靠背到後端。

1220
00:57:23,290 --> 00:57:25,010
因此，我們一直在談論數字。

1221
00:57:25,010 --> 00:57:30,880
而當我想解決問題
樣四，一，三，二，

1222
00:57:30,880 --> 00:57:33,820
即使我只是畫
只有數字四個一，三，

1223
00:57:33,820 --> 00:57:39,490
兩個在板，而電腦會
真的有這樣的設置在內存中。

1224
00:57:39,490 --> 00:57:43,347
>> 而這將是旁邊
兩人在計算機的內存？

1225
00:57:43,347 --> 00:57:44,680
那麼，有沒有答案。

1226
00:57:44,680 --> 00:57:45,770
我們真的不知道。

1227
00:57:45,770 --> 00:57:48,200
並且，只要該
電腦並不需要它，

1228
00:57:48,200 --> 00:57:51,440
它不必關心什麼是下一個
該數字確實關心。

1229
00:57:51,440 --> 00:57:55,130
而當我在前面一台電腦說
只能看一眼地址的時間，

1230
00:57:55,130 --> 00:57:56,170
這是種原因。

1231
00:57:56,170 --> 00:57:59,490
>> 不不同於記錄
播放器和讀取頭

1232
00:57:59,490 --> 00:58:03,030
只能夠看在一定的
槽在物理老派的紀錄

1233
00:58:03,030 --> 00:58:06,500
在一個時間，同樣地
可以在計算機的感謝

1234
00:58:06,500 --> 00:58:09,810
到其CPU和其
英特爾指令集，

1235
00:58:09,810 --> 00:58:12,480
其教學之中
從存儲器中讀

1236
00:58:12,480 --> 00:58:15,590
或保存到memory--一個
電腦只能看

1237
00:58:15,590 --> 00:58:19,210
在以時間 - 一個位置
有時它們的組合，

1238
00:58:19,210 --> 00:58:21,770
但在同一時間真的只是一個地點。

1239
00:58:21,770 --> 00:58:24,770
所以，當我們在做
這些不同的算法，

1240
00:58:24,770 --> 00:58:28,110
我不只是寫在
vacuum--四，一，三，二。

1241
00:58:28,110 --> 00:58:30,849
這些數字實際上屬於
某處物理存儲器中。

1242
00:58:30,849 --> 00:58:32,890
因此，有小小的
晶體管或某種

1243
00:58:32,890 --> 00:58:35,840
下面的電子的
罩存儲這些值。

1244
00:58:35,840 --> 00:58:40,460
>> 和總共多少比特
現在參與其中，只是要清楚嗎？

1245
00:58:40,460 --> 00:58:45,580
因此，這是四個字節，或者
現在它的32位總。

1246
00:58:45,580 --> 00:58:49,280
因此，實際上有32個零和
那些組成這四件事。

1247
00:58:49,280 --> 00:58:52,070
甚至還有更多的在這裡，但
再次，我們不關心這個。

1248
00:58:52,070 --> 00:58:55,120
>> 所以，現在讓我們來問另外一個
問題使用內存，

1249
00:58:55,120 --> 00:58:57,519
因為，在端
這一天是方差。

1250
00:58:57,519 --> 00:59:00,310
不管是什麼，我們可能會做
的計算機上，在一天結束時

1251
00:59:00,310 --> 00:59:02,560
硬件仍是
同樣的引擎蓋下面。

1252
00:59:02,560 --> 00:59:04,670
我將如何存儲一個字嗎？

1253
00:59:04,670 --> 00:59:09,710
那麼，在一台電腦一個字像
“嘿！”將存儲就是這樣的。

1254
00:59:09,710 --> 00:59:12,300
如果你需要一個較長的
一句話，你可以簡單地

1255
00:59:12,300 --> 00:59:19,120
覆蓋該說點什麼
如“你好”，並存儲在這裡。

1256
00:59:19,120 --> 00:59:23,930
>> 所以在這裡，這contiguousness
實際上是一個優勢，

1257
00:59:23,930 --> 00:59:26,530
因為一台電腦可以只
從右至左讀。

1258
00:59:26,530 --> 00:59:28,680
但這裡有一個問題。

1259
00:59:28,680 --> 00:59:33,480
在這個詞的範圍內，
H-E-L-L-O，感嘆號，

1260
00:59:33,480 --> 00:59:38,740
如何才能對計算機知道在哪裡
字開始，這裡所說的結束？

1261
00:59:38,740 --> 00:59:41,690

1262
00:59:41,690 --> 00:59:43,800
在數字的情況下，
如何做電腦

1263
00:59:43,800 --> 00:59:48,396
不知過了多久序列
數字是或地方開始？

1264
00:59:48,396 --> 00:59:50,270
哦，原來out--
我們不會去過多

1265
00:59:50,270 --> 00:59:54,970
這個級別的detail--
電腦在內存中移動的東西

1266
00:59:54,970 --> 00:59:57,800
從字面上這些地址的方式。

1267
00:59:57,800 --> 01:00:02,080
因此，在一台電腦，如果你
編寫代碼來存儲的東西

1268
01:00:02,080 --> 01:00:05,800
喜歡的話，你在做什麼
真正做的是打字

1269
01:00:05,800 --> 01:00:11,320
那記得在表達式
計算機的內存這話。

1270
01:00:11,320 --> 01:00:14,370
因此，讓我做一個非常，
很簡單的例子。

1271
01:00:14,370 --> 01:00:18,260
>> 我要繼續前進，
打開一個簡單的文本程序，

1272
01:00:18,260 --> 01:00:20,330
我要去創造
一個名為hello.c的。

1273
01:00:20,330 --> 01:00:22,849
大多數的這些信息，我們
不會進入的很詳細，

1274
01:00:22,849 --> 01:00:25,140
但我會寫一
計劃在同日而語，

1275
01:00:25,140 --> 01:00:31,140
C.這是更為嚇人，
我認為，不是從無到有，

1276
01:00:31,140 --> 01:00:32,490
但它的精神非常相似。

1277
01:00:32,490 --> 01:00:34,364
事實上，這些捲曲
braces--你可以種

1278
01:00:34,364 --> 01:00:37,820
想到了什麼我只是做的了。

1279
01:00:37,820 --> 01:00:39,240
>> 讓我們做到這一點，其實。

1280
01:00:39,240 --> 01:00:45,100
當綠旗點擊，
做到以下幾點。

1281
01:00:45,100 --> 01:00:50,210
我想打印出“你好”。

1282
01:00:50,210 --> 01:00:51,500
因此，這是現在的偽代碼。

1283
01:00:51,500 --> 01:00:53,000
我有點模糊的線條。

1284
01:00:53,000 --> 01:00:56,750
在C，這種語言我說
一下，這條線的打印打招呼

1285
01:00:56,750 --> 01:01:01,940
實際上變成的“printf”與
一些括號和分號。

1286
01:01:01,940 --> 01:01:03,480
>> 但它是完全一樣的想法。

1287
01:01:03,480 --> 01:01:06,730
而這種非常人性化
“當綠旗點擊”變

1288
01:01:06,730 --> 01:01:10,182
在更為神秘的“INT主要作廢。”

1289
01:01:10,182 --> 01:01:12,890
這確實沒有映射，
所以我只是要忽略。

1290
01:01:12,890 --> 01:01:17,210
不過，花括號，如
弧形拼圖這樣。

1291
01:01:17,210 --> 01:01:18,700
>> 所以，你可以種猜測。

1292
01:01:18,700 --> 01:01:22,357
即使你以前從未編程，
這是什麼程序可能嗎？

1293
01:01:22,357 --> 01:01:25,560

1294
01:01:25,560 --> 01:01:28,000
可能是打印Hello
帶有感嘆號。

1295
01:01:28,000 --> 01:01:29,150
>> 因此，讓我們試試吧。

1296
01:01:29,150 --> 01:01:30,800
我要保存它。

1297
01:01:30,800 --> 01:01:34,000
而這又正是一個非常
老學校環境。

1298
01:01:34,000 --> 01:01:35,420
我無法點擊，我不能再拖累。

1299
01:01:35,420 --> 01:01:36,910
我必須鍵入命令。

1300
01:01:36,910 --> 01:01:41,320
所以我想運行我的程序，所以
我可以這樣做，喜歡的hello.c。

1301
01:01:41,320 --> 01:01:42,292
這是我跑的文件。

1302
01:01:42,292 --> 01:01:43,500
別急，我缺少的一個步驟。

1303
01:01:43,500 --> 01:01:46,470
那麼，我們能說的是一個必要的
步驟，如C語言？

1304
01:01:46,470 --> 01:01:49,470
我剛剛編寫的源
代碼，但我還需要什麼呢？

1305
01:01:49,470 --> 01:01:50,670
是的，我需要一個編譯器。

1306
01:01:50,670 --> 01:01:57,670
所以在這裡我的Mac電腦上，我有一個
程序調用GCC，GNU C編譯器，

1307
01:01:57,670 --> 01:02:03,990
這讓我做this--轉
我的源代碼之中，我們會打電話給它，

1308
01:02:03,990 --> 01:02:04,930
機器代碼。

1309
01:02:04,930 --> 01:02:10,180
>> 我可以看到的是，
再次，如下，這些

1310
01:02:10,180 --> 01:02:14,090
是零和我
從我的源代碼創建的，

1311
01:02:14,090 --> 01:02:15,730
所有的零和一。

1312
01:02:15,730 --> 01:02:17,770
如果我想運行
我的程序 - 它將發生

1313
01:02:17,770 --> 01:02:23,010
被調用的a.out為
歷史reasons--“你好”。

1314
01:02:23,010 --> 01:02:24,070
我可以再次運行。

1315
01:02:24,070 --> 01:02:25,690
你好你好你好。

1316
01:02:25,690 --> 01:02:27,430
它似乎是工作。

1317
01:02:27,430 --> 01:02:31,000
>> 但是，在意味著什麼地方我
計算機的內存是詞語

1318
01:02:31,000 --> 01:02:35,279
H-E-L-L-O，感嘆號。

1319
01:02:35,279 --> 01:02:38,070
而事實證明，就像順便說一句，
什麼是電腦就不一般

1320
01:02:38,070 --> 01:02:40,550
這樣做，它知道在哪裡
事情開始並end--它的

1321
01:02:40,550 --> 01:02:42,460
要在這裡把一個特殊符號。

1322
01:02:42,460 --> 01:02:46,064
和公約是把
在單詞的末尾數為零

1323
01:02:46,064 --> 01:02:48,230
讓你知道它在哪裡
實際上結束，這樣你

1324
01:02:48,230 --> 01:02:52,750
不要讓打印出越來越多
人物比你實際打算。

1325
01:02:52,750 --> 01:02:55,400
>> 但這裡的外賣，甚至
雖然這是相當神秘，

1326
01:02:55,400 --> 01:02:58,140
是它的最終
相對簡單。

1327
01:02:58,140 --> 01:03:04,550
你被賦予某種磁帶，空白
上，你可以寫信空間。

1328
01:03:04,550 --> 01:03:07,150
你只需要有一個
特殊符號，如隨意

1329
01:03:07,150 --> 01:03:10,316
數字零，將在年底
你的話讓計算機知道，

1330
01:03:10,316 --> 01:03:13,410
哦，我應該後停止打印
我看到了感嘆號。

1331
01:03:13,410 --> 01:03:16,090
因為接下來的事情有
是零的ASCII值，

1332
01:03:16,090 --> 01:03:19,125
或空字符作為
有人會調用它。

1333
01:03:19,125 --> 01:03:21,500
但有樣的問題
在這裡，讓我們恢復

1334
01:03:21,500 --> 01:03:23,320
到了一會兒號碼。

1335
01:03:23,320 --> 01:03:28,720
假設我這樣做，事實上，
有數字數組，

1336
01:03:28,720 --> 01:03:30,730
並假設
節目我寫的

1337
01:03:30,730 --> 01:03:34,680
就像一個檔次書老師
和老師的課堂。

1338
01:03:34,680 --> 01:03:38,720
而這個程序可以讓他或她
輸入他們的學生成績

1339
01:03:38,720 --> 01:03:39,960
在測驗。

1340
01:03:39,960 --> 01:03:43,750
並假設學生得到
100他們的第一次測驗，也許

1341
01:03:43,750 --> 01:03:49,920
像80上的下一個，那麼一個
75，然後在第四測驗90。

1342
01:03:49,920 --> 01:03:54,150
>> 所以在這個故事這一點上，
數組大小四。

1343
01:03:54,150 --> 01:03:58,470
但絕對更多的內存在
計算機，但該陣列，可以這麼說，

1344
01:03:58,470 --> 01:04:00,350
是規模四。

1345
01:04:00,350 --> 01:04:06,060
假設現在老師要
分配第五測驗的類。

1346
01:04:06,060 --> 01:04:08,510
好了，事情之一，他
或她將不得不做

1347
01:04:08,510 --> 01:04:10,650
現在是這裡存儲的附加價值。

1348
01:04:10,650 --> 01:04:15,490
但是，如果陣列的老師有
在該程序創建的大小的，

1349
01:04:15,490 --> 01:04:22,440
與陣列的問題之一是
你不能只是不斷加入到內存。

1350
01:04:22,440 --> 01:04:26,470
因為如果的另一部分
程序有單詞“哎”就在那裡？

1351
01:04:26,470 --> 01:04:29,650
>> 換句話說，我的記憶可以
用於在程序什麼。

1352
01:04:29,650 --> 01:04:33,250
如果事先我輸入了，嘿嘿，
我想輸入4測驗分數，

1353
01:04:33,250 --> 01:04:34,784
他們可能會去這裡和這裡。

1354
01:04:34,784 --> 01:04:37,700
如果你突然改變了主意
後來，說我想第五測驗

1355
01:04:37,700 --> 01:04:40,872
分數，你不能只是
把它放在任何你想要的，

1356
01:04:40,872 --> 01:04:42,580
因為如果這個
存儲器正在被使用

1357
01:04:42,580 --> 01:04:45,990
東西else--其他程序
或程序的某些其他特徵

1358
01:04:45,990 --> 01:04:46,910
你正在運行？

1359
01:04:46,910 --> 01:04:50,650
所以，你必須想提前
要如何存儲你的數據，

1360
01:04:50,650 --> 01:04:54,480
因為現在你已經繪
自己變成一個數字角落。

1361
01:04:54,480 --> 01:04:57,280
>> 因此，老師可能代替
編寫一個程序時說

1362
01:04:57,280 --> 01:04:59,360
存儲他或她的
檔次，你知道嗎？

1363
01:04:59,360 --> 01:05:04,180
我要提出要求，
寫我的程序時，

1364
01:05:04,180 --> 01:05:12,070
我想零，一，二，三，
四，五，六，八年級人數。

1365
01:05:12,070 --> 01:05:15,320
這樣一，二，三，四，
五，六，七，八。

1366
01:05:15,320 --> 01:05:18,612
教師可以剛過分配
寫他或她的節目時記憶

1367
01:05:18,612 --> 01:05:19,570
並說，你知道嗎？

1368
01:05:19,570 --> 01:05:22,236
我永遠不會分配更多
不是在一個學期8測驗。

1369
01:05:22,236 --> 01:05:23,130
這只是瘋狂。

1370
01:05:23,130 --> 01:05:24,470
我永遠也不會分配的。

1371
01:05:24,470 --> 01:05:28,270
使這樣，他或她有
靈活存儲學生的分數，

1372
01:05:28,270 --> 01:05:33,010
像75，90，也許一個額外的地方
學生獲得加分，105。

1373
01:05:33,010 --> 01:05:36,130
>> 但是，如果老師從來不
使用這些三個空格，

1374
01:05:36,130 --> 01:05:38,860
這裡有一個直觀的外賣。

1375
01:05:38,860 --> 01:05:41,410
他或她只是浪費空間。

1376
01:05:41,410 --> 01:05:44,790
因此，換句話說，有這
在編程中常見的權衡

1377
01:05:44,790 --> 01:05:48,241
在這裡你可以分配
正是盡可能多的內存，只要你想，

1378
01:05:48,241 --> 01:05:51,490
它的好處是，你是超級
efficient--你不會被浪費

1379
01:05:51,490 --> 01:05:54,640
在all--但其缺點
是什麼，如果你改變主意的時候

1380
01:05:54,640 --> 01:05:58,780
使用要存儲方案
比你更多的數據原本打算。

1381
01:05:58,780 --> 01:06:03,030
>> 因此，也許該解決方案的話，那麼，
編寫程序以這樣的方式

1382
01:06:03,030 --> 01:06:05,605
他們使用更多的內存
比他們實際需要。

1383
01:06:05,605 --> 01:06:07,730
這樣，你就不會
運行到該問題，

1384
01:06:07,730 --> 01:06:09,730
但你是浪費的。

1385
01:06:09,730 --> 01:06:12,960
而更多的內存，你的程序使用，
正如我們昨天所討論的，少

1386
01:06:12,960 --> 01:06:15,410
內存可用
對於其他方案，

1387
01:06:15,410 --> 01:06:18,790
你的電腦可能會降低越快
下來，因為虛擬內存。

1388
01:06:18,790 --> 01:06:22,670
所以，理想的解決方案可能是什麼？

1389
01:06:22,670 --> 01:06:24,610
>> 欠清分似乎不好。

1390
01:06:24,610 --> 01:06:27,030
過度分配顯得不好。

1391
01:06:27,030 --> 01:06:31,120
那麼，什麼可能是一個更好的解決辦法？

1392
01:06:31,120 --> 01:06:32,390
重新分配。

1393
01:06:32,390 --> 01:06:33,590
更有活力​​。

1394
01:06:33,590 --> 01:06:37,520
不要強迫自己選擇
先驗的，在開始的時候，你想要什麼。

1395
01:06:37,520 --> 01:06:41,370
而且絕對不要過度分配，
免得你是一種浪費。

1396
01:06:41,370 --> 01:06:45,770
>> 所以要實現這個目標，我們
需要拋出這個數據結構，

1397
01:06:45,770 --> 01:06:48,100
可以這麼說，流連忘返。

1398
01:06:48,100 --> 01:06:51,080
還等什麼程序員
通常會使用

1399
01:06:51,080 --> 01:06:55,940
被稱為不是東西
數組，但一個鍊錶。

1400
01:06:55,940 --> 01:07:00,860
換句話說，他或她會
開始思考自己的記憶

1401
01:07:00,860 --> 01:07:05,280
作為是一種形狀的，他們
可以通過以下方式繪製。

1402
01:07:05,280 --> 01:07:08,520
如果我想存儲在一個數
一個program--所以它的九月，

1403
01:07:08,520 --> 01:07:12,600
我給我的學生進行測試;我想要
存儲學生的第一次測驗，

1404
01:07:12,600 --> 01:07:16,220
他們在它 - 我得到了100
要問我的電腦，

1405
01:07:16,220 --> 01:07:19,540
由我有計劃的方式
寫的，對於一個內存塊。

1406
01:07:19,540 --> 01:07:22,570
我要去存儲
在其100號，僅此而已。

1407
01:07:22,570 --> 01:07:24,820
>> 然後，幾個星期後
當我拿到我的第二個測驗，

1408
01:07:24,820 --> 01:07:27,890
它的時間輸入
在這90％，我準備

1409
01:07:27,890 --> 01:07:32,129
問電腦，哎，電腦，
我可以有內存另一塊？

1410
01:07:32,129 --> 01:07:34,170
這是怎麼回事給我這個
記憶空塊。

1411
01:07:34,170 --> 01:07:39,370
我打算把在90號，
但在我的程序以某種方式或other--

1412
01:07:39,370 --> 01:07:42,100
我們不會擔心
對於this--我需要的語法

1413
01:07:42,100 --> 01:07:44,430
以某種方式鏈接這些東西放在一起。

1414
01:07:44,430 --> 01:07:47,430
我將它們連起來用
看起來像這裡的箭頭。

1415
01:07:47,430 --> 01:07:50,050
>> 出現的第三次測驗，
我會說，哎，電腦，

1416
01:07:50,050 --> 01:07:51,680
給我的記憶另一塊。

1417
01:07:51,680 --> 01:07:54,660
而且我要放下
不管是什麼，像75，

1418
01:07:54,660 --> 01:07:56,920
我不得不鏈本
現在一起莫名其妙。

1419
01:07:56,920 --> 01:08:00,290
四測驗到來，也許
這是朝著學期結束。

1420
01:08:00,290 --> 01:08:03,140
而到那個時候我的程序
可能是使用內存

1421
01:08:03,140 --> 01:08:05,540
所有的地方，遍布身體。

1422
01:08:05,540 --> 01:08:08,170
所以只是踢，我
要得出這樣的規定

1423
01:08:08,170 --> 01:08:11,260
quiz--我忘了那是什麼;一世
想也許80或something--

1424
01:08:11,260 --> 01:08:12,500
來這裡的路上。

1425
01:08:12,500 --> 01:08:15,920
>> 但是，這很好，因為形象地
我要畫這條線。

1426
01:08:15,920 --> 01:08:19,063
換句話說，在現實中，
在您的計算機硬件，

1427
01:08:19,063 --> 01:08:20,979
首次得分可能
在這裡結束，因為它是

1428
01:08:20,979 --> 01:08:22,529
就在本學期的開始。

1429
01:08:22,529 --> 01:08:25,810
下一個可能會在這裡結束
因為時間有點已過

1430
01:08:25,810 --> 01:08:27,210
並且程序繼續運行。

1431
01:08:27,210 --> 01:08:30,060
接下來的成績，這是
75，可能是在這裡。

1432
01:08:30,060 --> 01:08:33,420
而最後的比分可能是
80，這是在這裡。

1433
01:08:33,420 --> 01:08:38,729
>> 因此，在現實中，身體上，這可能是
你的計算機內存的模樣。

1434
01:08:38,729 --> 01:08:41,569
但是，這不是一個有用的精神
範式的計算機程序員。

1435
01:08:41,569 --> 01:08:44,649
為什麼要關注所在
赫克您的數據結束了？

1436
01:08:44,649 --> 01:08:46,200
你只是想存儲的數據。

1437
01:08:46,200 --> 01:08:49,390
>> 這有點像我們的討論
早期繪製立方體。

1438
01:08:49,390 --> 01:08:52,200
為什麼你關心什麼
的角度為立方體

1439
01:08:52,200 --> 01:08:53,740
你怎麼也得把畫呢？

1440
01:08:53,740 --> 01:08:54,950
你只想要一個立方體。

1441
01:08:54,950 --> 01:08:57,359
同樣在這裡，你
只是想成績簿。

1442
01:08:57,359 --> 01:08:59,559
你只是要考慮的
此作為數字列表。

1443
01:08:59,559 --> 01:09:01,350
誰在乎它是如何的
在硬件中實現？

1444
01:09:01,350 --> 01:09:05,180
>> 因此，抽象，現在
在這裡這張圖片。

1445
01:09:05,180 --> 01:09:07,580
這是一個鍊錶，如
一個程序員調用它，

1446
01:09:07,580 --> 01:09:10,640
只要你有一個
名單，顯然數字。

1447
01:09:10,640 --> 01:09:14,990
但它形象地聯繫在一起
通過這些箭頭的方式，

1448
01:09:14,990 --> 01:09:18,510
所有這些箭頭are--下方
油煙機，如果你很好奇，

1449
01:09:18,510 --> 01:09:23,210
回想起我們的物理硬件有
地址零，一，二，三，四。

1450
01:09:23,210 --> 01:09:28,465
所有這些箭頭就像一張地圖
或指示，如果在那裡90 is--現在

1451
01:09:28,465 --> 01:09:29,090
我計數。

1452
01:09:29,090 --> 01:09:31,750
>> 零，一，二，三，
四，五，六，七。

1453
01:09:31,750 --> 01:09:35,640
它看起來像90處於
內存地址七位數。

1454
01:09:35,640 --> 01:09:38,460
所有這些箭頭都是
就像一張小廢

1455
01:09:38,460 --> 01:09:42,439
這是給予指示，
程序表示關注該地圖

1456
01:09:42,439 --> 01:09:43,880
去的位置七人。

1457
01:09:43,880 --> 01:09:46,680
在那裡你會發現
學生的第二次測驗的分數。

1458
01:09:46,680 --> 01:09:52,100
同時，75--如果我繼續這樣，
這是七，八，九，10，11，12，

1459
01:09:52,100 --> 01:09:54,240
13，14，15。

1460
01:09:54,240 --> 01:09:59,080
>> 這等方向正好代表
一個地圖存儲位置15。

1461
01:09:59,080 --> 01:10:02,550
但同樣，程序員一般不
不會在意這些細節。

1462
01:10:02,550 --> 01:10:05,530
而在幾乎每個節目
今天語言，程序員

1463
01:10:05,530 --> 01:10:10,490
甚至不知道在內存
這些數字實際上是。

1464
01:10:10,490 --> 01:10:14,830
所有他或她必須關心的是
它們以某種方式連接在一起

1465
01:10:14,830 --> 01:10:18,390
在像這樣的數據結構。

1466
01:10:18,390 --> 01:10:21,580
>> 但事實證明，沒有
讓過於技術化。

1467
01:10:21,580 --> 01:10:27,430
但是，僅僅因為我們可以或許
買得起這裡有這樣的討論，

1468
01:10:27,430 --> 01:10:33,630
假設我們重溫
這裡一個數組的這個問題。

1469
01:10:33,630 --> 01:10:35,780
讓我們來看看，如果我們後悔打算在這裡。

1470
01:10:35,780 --> 01:10:42,950
這是100，90，75，和80。

1471
01:10:42,950 --> 01:10:44,980
>> 讓我簡要地做了這種說法。

1472
01:10:44,980 --> 01:10:48,980
這是一個數組，並且再次，在
陣列的顯著特徵

1473
01:10:48,980 --> 01:10:52,400
是你所有的數據都回
返回到memory--回字面上

1474
01:10:52,400 --> 01:10:56,830
一個字節或者四個字節，
字節的一些固定數目之遙。

1475
01:10:56,830 --> 01:11:00,710
在一個鍊錶，這是我們可以借鑒
這樣，下方的引擎蓋誰

1476
01:11:00,710 --> 01:11:02,000
知道哪裡的東西是什麼？

1477
01:11:02,000 --> 01:11:03,630
它甚至不需要流這樣。

1478
01:11:03,630 --> 01:11:06,050
一些數據可能是
回左那裡。

1479
01:11:06,050 --> 01:11:07,530
你甚至不知道。

1480
01:11:07,530 --> 01:11:15,430
>> 所以用一個數組，你有一個
特徵稱為隨機存取。

1481
01:11:15,430 --> 01:11:20,570
及什麼隨機存取裝置是
計算機可以立即跳到

1482
01:11:20,570 --> 01:11:22,730
到在陣列的任何位置。

1483
01:11:22,730 --> 01:11:23,580
為什麼？

1484
01:11:23,580 --> 01:11:26,000
由於計算機知道
該第一位置是

1485
01:11:26,000 --> 01:11:29,540
零個，一個，兩個，和三個。

1486
01:11:29,540 --> 01:11:33,890
>> 所以，如果你想從去
這個元素到下一個元素，

1487
01:11:33,890 --> 01:11:36,099
你從字面上看，在
計算機的心思，只是增加一個。

1488
01:11:36,099 --> 01:11:39,140
如果你想要去的第三個元素，
只需添加one--下一個元素，只是

1489
01:11:39,140 --> 01:11:40,290
加之一。

1490
01:11:40,290 --> 01:11:42,980
然而，在該版本
故事的，假設

1491
01:11:42,980 --> 01:11:46,080
目前的計算機正在
在或處理的數量100。

1492
01:11:46,080 --> 01:11:49,770
你怎麼下
年級成績簿？

1493
01:11:49,770 --> 01:11:52,560
>> 你要取七
步驟，這是任意的。

1494
01:11:52,560 --> 01:11:58,120
要進入下一個，你必須
採取另一種八個步驟去15。

1495
01:11:58,120 --> 01:12:02,250
換句話說，它不是一個
數字之間一定的間隙，

1496
01:12:02,250 --> 01:12:04,857
所以它只是需要的
計算機更多的時間點。

1497
01:12:04,857 --> 01:12:06,940
計算機有要搜索
通過訂單記錄

1498
01:12:06,940 --> 01:12:08,990
找到你要找的內容。

1499
01:12:08,990 --> 01:12:14,260
>> 因此而陣列往往是一個
快速的數據結構 - 因為你

1500
01:12:14,260 --> 01:12:17,610
可以從字面上只是做簡單的算術題
並得到你想要通過添加一個，

1501
01:12:17,610 --> 01:12:21,300
為instance--一個鍊錶，
你犧牲該功能。

1502
01:12:21,300 --> 01:12:24,020
你不能只從第一次去
第二至第三至第四位。

1503
01:12:24,020 --> 01:12:25,240
你必須遵循的地圖。

1504
01:12:25,240 --> 01:12:28,160
你必須採取更多的步驟
獲得這些價值，這

1505
01:12:28,160 --> 01:12:30,230
似乎是增加了成本。

1506
01:12:30,230 --> 01:12:35,910
因此，我們付出的代價，但什麼是
該功能丹正在尋求在這裡？

1507
01:12:35,910 --> 01:12:38,110
什麼鍊錶
顯然允許我們這樣做，

1508
01:12:38,110 --> 01:12:40,240
這是的原點
這個特別的故事嗎？

1509
01:12:40,240 --> 01:12:43,250

1510
01:12:43,250 --> 01:12:43,830
>> 究竟。

1511
01:12:43,830 --> 01:12:46,220
一個充滿活力的大小吧。

1512
01:12:46,220 --> 01:12:48,040
我們可以添加到這個列表。

1513
01:12:48,040 --> 01:12:51,430
我們甚至可以縮小列表，因此
那我們只使用盡可能多的內存

1514
01:12:51,430 --> 01:12:55,560
因為我們其實是想等
我們永遠都不會過度分配。

1515
01:12:55,560 --> 01:12:58,470
>> 現在只要是真正挑剔的，
有一個隱藏的成本。

1516
01:12:58,470 --> 01:13:01,980
所以，你不應該只是讓我信服
你認為這是一個引人注目的權衡。

1517
01:13:01,980 --> 01:13:04,190
這裡有另一個隱藏的成本。

1518
01:13:04,190 --> 01:13:06,550
這樣做的好處，是明確的，
是我們獲得活力。

1519
01:13:06,550 --> 01:13:10,359
如果我想另一個元素，我可以
繪製和擺在那裡的一個數字。

1520
01:13:10,359 --> 01:13:12,150
然後，我可以鏈接它
用圖片這裡，

1521
01:13:12,150 --> 01:13:14,970
而在這裡，再一次，如果我
畫自己到一個角落裡，

1522
01:13:14,970 --> 01:13:19,410
如果別的東西已經在使用
這裡的記憶，我的運氣。

1523
01:13:19,410 --> 01:13:21,700
我自己畫成角。

1524
01:13:21,700 --> 01:13:24,390
>> 但是，什麼是隱藏
在這張照片的成本？

1525
01:13:24,390 --> 01:13:27,690
這不只是量
的時間，它需要

1526
01:13:27,690 --> 01:13:29,870
從這裡到這裡，
這七個步驟，然後

1527
01:13:29,870 --> 01:13:32,820
八步，這是一個以上。

1528
01:13:32,820 --> 01:13:34,830
什麼是另一個隱藏的成本是多少？

1529
01:13:34,830 --> 01:13:35,440
不僅僅是時間。

1530
01:13:35,440 --> 01:13:44,790

1531
01:13:44,790 --> 01:13:49,940
其他信息
要實現這個圖像。

1532
01:13:49,940 --> 01:13:53,210
>> 是啊，地圖，這些小碎片
紙張，因為我將說明他們作為。

1533
01:13:53,210 --> 01:13:55,650
這些arrows--這些都不是免費的。

1534
01:13:55,650 --> 01:13:57,660
你知道computer--
什麼是計算機。

1535
01:13:57,660 --> 01:13:58,790
它具有零和一。

1536
01:13:58,790 --> 01:14:03,170
如果你想表示箭頭或
圖或一個數字，你需要一些內存。

1537
01:14:03,170 --> 01:14:05,950
所以，等價格你
支付一個鍊錶，

1538
01:14:05,950 --> 01:14:09,070
一個共同的計算機科學
資源，也是空間。

1539
01:14:09,070 --> 01:14:11,710
>> 的確如此，所以常見的是，
權衡之中

1540
01:14:11,710 --> 01:14:15,580
設計軟件工程
系統的時間和space--

1541
01:14:15,580 --> 01:14:18,596
您的成分是二，二生
你最昂貴的成分。

1542
01:14:18,596 --> 01:14:21,220
這花費了我更多的時間
因為我要遵守這個地圖，

1543
01:14:21,220 --> 01:14:25,730
但它也花費了我更多的空間
因為我要保持這種地圖各處。

1544
01:14:25,730 --> 01:14:28,730
所以，希望，因為我們已經種
在昨天和今天的討論，

1545
01:14:28,730 --> 01:14:31,720
是的好處
將大於成本。

1546
01:14:31,720 --> 01:14:33,870
>> 但是，這裡沒有明顯的解決方案。

1547
01:14:33,870 --> 01:14:35,870
也許這是better--
一拉快速​​和骯髒的，

1548
01:14:35,870 --> 01:14:38,660
作為賈巴爾提出先前已經
在問題扔存儲器。

1549
01:14:38,660 --> 01:14:42,520
隨便買更多的內存，覺得少
認真思考解決問題，

1550
01:14:42,520 --> 01:14:44,595
並解決它更簡單的方法。

1551
01:14:44,595 --> 01:14:46,720
事實上更早的時候，
我們談到了權衡，

1552
01:14:46,720 --> 01:14:49,190
它不是空間
計算機和時間。

1553
01:14:49,190 --> 01:14:51,810
它是顯影劑的時間，這
是另一個的資源。

1554
01:14:51,810 --> 01:14:54,829
>> 如此反复，正是這種平衡行為
試圖決定其中哪些東西

1555
01:14:54,829 --> 01:14:55,870
你願意花？

1556
01:14:55,870 --> 01:14:57,380
這是最便宜的？

1557
01:14:57,380 --> 01:15:01,040
這將產生更好的結果嗎？

1558
01:15:01,040 --> 01:15:01,540
是嗎？

1559
01:15:01,540 --> 01:15:11,310

1560
01:15:11,310 --> 01:15:12,580
>> 的確。

1561
01:15:12,580 --> 01:15:15,970
在這種情況下，如果你
表示在maps--號碼

1562
01:15:15,970 --> 01:15:18,820
這些被稱為在許多語言
“指針”或“地址” - 

1563
01:15:18,820 --> 01:15:20,390
它的雙空間。

1564
01:15:20,390 --> 01:15:24,390
這不一定是為雙如果那樣糟糕
現在我們只是存儲號碼。

1565
01:15:24,390 --> 01:15:27,410
假設我們被存儲
在hospital--患者記錄

1566
01:15:27,410 --> 01:15:30,870
所以皮爾森的姓名，電話號碼，
社會安全號碼，醫生

1567
01:15:30,870 --> 01:15:31,540
歷史。

1568
01:15:31,540 --> 01:15:34,160
這個盒子可能是多了，
更大，在這種情況

1569
01:15:34,160 --> 01:15:38,000
一個小小的指針的地址
接下來element--這不是什麼大不了的事。

1570
01:15:38,000 --> 01:15:40,620
它是這樣一個邊緣
成本也沒關係。

1571
01:15:40,620 --> 01:15:43,210
但是，在這種情況下，是啊，這是一個增加一倍。

1572
01:15:43,210 --> 01:15:45,290
好問題。

1573
01:15:45,290 --> 01:15:47,900
>> 讓我們來談談時間
有點更具體。

1574
01:15:47,900 --> 01:15:50,380
什麼是運行時間
的搜索這個名單？

1575
01:15:50,380 --> 01:15:53,640
假設我想查詢
通過所有學生的成績，

1576
01:15:53,640 --> 01:15:55,980
有n值等級
在此數據結構中。

1577
01:15:55,980 --> 01:15:58,830
在這裡，我們可以借
早期的詞彙。

1578
01:15:58,830 --> 01:16:00,890
這是一個線性數據結構。

1579
01:16:00,890 --> 01:16:04,570
>> 為n的大O是什麼需要得到
該數據結構的末尾，

1580
01:16:04,570 --> 01:16:08,410
whereas--，我們還沒有看到
這before--數組給你

1581
01:16:08,410 --> 01:16:13,555
什麼叫做固定的時間，這意味著
一個步驟或兩個步驟或10 steps--

1582
01:16:13,555 --> 01:16:14,180
沒關係。

1583
01:16:14,180 --> 01:16:15,440
它是一個固定的數目。

1584
01:16:15,440 --> 01:16:17,440
它無關
該數組的大小。

1585
01:16:17,440 --> 01:16:20,130
和其中的原因，
再次，是隨機接入。

1586
01:16:20,130 --> 01:16:23,180
電腦可以只是立即
跳到另一個位置，

1587
01:16:23,180 --> 01:16:27,770
因為它們都是一樣的
從一切距離。

1588
01:16:27,770 --> 01:16:29,112
沒有涉及的想法。

1589
01:16:29,112 --> 01:16:31,900

1590
01:16:31,900 --> 01:16:32,400
好吧。

1591
01:16:32,400 --> 01:16:39,230
所以，如果我可以，讓我嘗試
畫兩個最終的照片。

1592
01:16:39,230 --> 01:16:42,830
一個非常常見的被稱為哈希表。

1593
01:16:42,830 --> 01:16:51,120
所以激勵的討論，
讓我想想如何做到這一點。

1594
01:16:51,120 --> 01:16:52,610
>> 那麼這個怎麼樣？

1595
01:16:52,610 --> 01:16:55,160
假設該問題
我們現在要解決

1596
01:16:55,160 --> 01:16:58,360
在dictionary--正在實施
所以一大堆英文單詞

1597
01:16:58,360 --> 01:16:59,330
管他呢。

1598
01:16:59,330 --> 01:17:02,724
和目標是能夠回答
形式的問題，這是一個字？

1599
01:17:02,724 --> 01:17:04,640
所以，你想實現
拼寫檢查，只

1600
01:17:04,640 --> 01:17:07,220
像物理字典
，你可以看看東西英寸

1601
01:17:07,220 --> 01:17:10,490
假設我是用一個數組來做到這一點。

1602
01:17:10,490 --> 01:17:12,590
我能做到這一點。

1603
01:17:12,590 --> 01:17:20,756
>> 並假設的話是蘋果
和香蕉和哈密瓜。

1604
01:17:20,756 --> 01:17:23,330

1605
01:17:23,330 --> 01:17:26,465
而且我想不出水果
即開始研發，所以我們只是

1606
01:17:26,465 --> 01:17:27,590
將有三種水果。

1607
01:17:27,590 --> 01:17:31,510
所以這是一個數組，我們
存儲所有這些詞

1608
01:17:31,510 --> 01:17:34,200
在本詞典作為數組。

1609
01:17:34,200 --> 01:17:39,350
現在的問題，那麼，是怎麼回事
你能存儲這些信息？

1610
01:17:39,350 --> 01:17:43,160
>> 好吧，我有點欺騙在這裡，因為
每個字這些信件

1611
01:17:43,160 --> 01:17:44,490
真的是單個字節。

1612
01:17:44,490 --> 01:17:46,740
所以，如果我真的想成為
挑剔的，我真的

1613
01:17:46,740 --> 01:17:49,600
被除以成多
內存較小的塊，

1614
01:17:49,600 --> 01:17:51,289
我們可以這樣做。

1615
01:17:51,289 --> 01:17:53,580
但是，我們要碰上
同樣的問題之前。

1616
01:17:53,580 --> 01:17:56,674
如果，因為韋氏或牛津
確實每year--他們添加單詞

1617
01:17:56,674 --> 01:17:59,340
到dictionary--我們不
一定要畫自己

1618
01:17:59,340 --> 01:18:00,780
與陣列的角落？

1619
01:18:00,780 --> 01:18:05,710
>> 因此，不是，也許是更明智的做法
是把蘋果在其自己的節點或箱，

1620
01:18:05,710 --> 01:18:11,190
因為我們會說，香蕉和
那麼在這裡，我們有哈密瓜。

1621
01:18:11,190 --> 01:18:14,990

1622
01:18:14,990 --> 01:18:16,790
而我們的字符串，這些東西放在一起。

1623
01:18:16,790 --> 01:18:19,980
因此，這是該數組，
這是鍊錶。

1624
01:18:19,980 --> 01:18:23,300
如果你不能完全看到，它只是
說“數組”，這表示“名單。”

1625
01:18:23,300 --> 01:18:25,780
>> 因此，我們有相同的
確切的問題和以前一樣，

1626
01:18:25,780 --> 01:18:28,600
因此我們現在有
活力在我們的鏈接列表。

1627
01:18:28,600 --> 01:18:31,090
但是，我們有一個相當緩慢的字典。

1628
01:18:31,090 --> 01:18:32,870
假設我要查找一個字。

1629
01:18:32,870 --> 01:18:35,430
這可能需要我的n大O字
步驟，因為這個詞可能

1630
01:18:35,430 --> 01:18:37,840
是一路在年底
列表，像哈密瓜。

1631
01:18:37,840 --> 01:18:40,600
而事實證明，
在編程，排序

1632
01:18:40,600 --> 01:18:42,700
數據的聖杯
結構是什麼

1633
01:18:42,700 --> 01:18:46,620
，讓你不斷
時間像一個數組

1634
01:18:46,620 --> 01:18:50,870
但仍然給您的活力。

1635
01:18:50,870 --> 01:18:52,940
>> 因此，我們可以有兩全其美？

1636
01:18:52,940 --> 01:18:55,570
事實上，也有一些是
稱為哈希表

1637
01:18:55,570 --> 01:18:59,320
它允許你做的正是
即，儘管近。

1638
01:18:59,320 --> 01:19:03,140
哈希表是一個票友
數據結構，我們

1639
01:19:03,140 --> 01:19:06,340
能想到的
一個array--組合

1640
01:19:06,340 --> 01:19:12,390
而我要畫它
像this--和鍊錶

1641
01:19:12,390 --> 01:19:17,310
我就畫這樣的在這裡。

1642
01:19:17,310 --> 01:19:19,760
>> 而辦法的事情
作品如下。

1643
01:19:19,760 --> 01:19:23,310

1644
01:19:23,310 --> 01:19:29,540
如果這個now--哈希table--
是我的第三個數據結構，

1645
01:19:29,540 --> 01:19:32,590
我想存儲
在這句話，我不

1646
01:19:32,590 --> 01:19:35,440
只想存儲所有的
也就是說背靠背背靠背。

1647
01:19:35,440 --> 01:19:37,430
我想利用一些
片的信息

1648
01:19:37,430 --> 01:19:40,330
有關會讓詞
我得到它，它的速度更快。

1649
01:19:40,330 --> 01:19:43,666
>> 因此，考慮的話蘋果
和香蕉和哈密瓜，

1650
01:19:43,666 --> 01:19:45,040
我特意選擇了這些話。

1651
01:19:45,040 --> 01:19:45,340
為什麼？

1652
01:19:45,340 --> 01:19:47,631
有什麼樣的根本
對三種不同？

1653
01:19:47,631 --> 01:19:49,950

1654
01:19:49,950 --> 01:19:51,484
什麼是顯而易見的？

1655
01:19:51,484 --> 01:19:52,900
他們開始用不同的字母。

1656
01:19:52,900 --> 01:19:53,900
>> 所以，你知道嗎？

1657
01:19:53,900 --> 01:19:57,120
而不是把我所有的詞語
同一個桶，可以這麼說，

1658
01:19:57,120 --> 01:20:00,390
就像在一個大名單，為什麼不
我至少嘗試優化

1659
01:20:00,390 --> 01:20:04,180
並讓我的名單1/26一樣長。

1660
01:20:04,180 --> 01:20:07,440
一個引人注目的優化
可能是為什麼不

1661
01:20:07,440 --> 01:20:10,650
我 - 當插入一個字
入這種數據結構，

1662
01:20:10,650 --> 01:20:14,300
到計算機的內存，為什麼
不要我把所有的'一'字在這裡，

1663
01:20:14,300 --> 01:20:17,270
這裡所有的“B”字，
和所有的'C'在這裡的話嗎？

1664
01:20:17,270 --> 01:20:24,610
因此，這最終將一個蘋果
這裡，這裡的香蕉在這裡，香瓜，

1665
01:20:24,610 --> 01:20:25,730
等等。

1666
01:20:25,730 --> 01:20:31,700
>> 如果我有一個額外的
字like--什麼其他？

1667
01:20:31,700 --> 01:20:36,640
蘋果，香蕉，梨。

1668
01:20:36,640 --> 01:20:39,370
有人認為水果的
與一個，b或c開始？

1669
01:20:39,370 --> 01:20:40,570
Blueberry--完善。

1670
01:20:40,570 --> 01:20:43,990
那就是要在這裡結束。

1671
01:20:43,990 --> 01:20:47,530
因此，我們似乎有一個
稍微更好的解決方案，

1672
01:20:47,530 --> 01:20:50,820
因為現在如果我想
搜索蘋果，我

1673
01:20:50,820 --> 01:20:53,200
序曲一我不只是潛水
進入我的數據結構。

1674
01:20:53,200 --> 01:20:54,850
我不潛入我的電腦的內存中。

1675
01:20:54,850 --> 01:20:56,530
我先來看看第一個字母。

1676
01:20:56,530 --> 01:20:58,610
>> 這是一台電腦
科學家會說。

1677
01:20:58,610 --> 01:21:00,760
您散列到你的數據結構。

1678
01:21:00,760 --> 01:21:04,100
你把你的輸入，這在
這種情況下，就像蘋果一個字。

1679
01:21:04,100 --> 01:21:07,150
你分析它，看著
在這種情況下，第一個字母，

1680
01:21:07,150 --> 01:21:08,340
從而哈希處理。

1681
01:21:08,340 --> 01:21:10,950
散列是一個通用術語，由此
你拿東西作為輸入

1682
01:21:10,950 --> 01:21:12,116
和你產生某種輸出。

1683
01:21:12,116 --> 01:21:15,090
並且，所述輸出
情況是位置

1684
01:21:15,090 --> 01:21:18,150
要搜索，第一
位置，第二是地段，第三。

1685
01:21:18,150 --> 01:21:22,160
所以輸入是蘋果，
輸出第一。

1686
01:21:22,160 --> 01:21:25,054
輸入是香蕉，所述
輸出應該是第二位。

1687
01:21:25,054 --> 01:21:27,220
輸入是哈密瓜，
輸出應該是第三個。

1688
01:21:27,220 --> 01:21:30,320
輸入是藍莓，該
輸出應該再次被秒。

1689
01:21:30,320 --> 01:21:34,010
這就是可以幫助你拿
通過你的記憶快捷鍵

1690
01:21:34,010 --> 01:21:39,050
為了得到對話
或數據更加有效。

1691
01:21:39,050 --> 01:21:43,330
>> 現在，這種潛在的減少了我們的時間
多達三分之一的26

1692
01:21:43,330 --> 01:21:45,850
因為如果你認為你
有盡可能多的“一”字為“Z”

1693
01:21:45,850 --> 01:21:48,080
詞為“Q”字，這
是不是真的realistic--

1694
01:21:48,080 --> 01:21:50,830
你會為橫向偏移
在alphabet--的某些字母

1695
01:21:50,830 --> 01:21:53,204
但是，這將是一個增量
方法，它允許

1696
01:21:53,204 --> 01:21:55,930
你去的話更迅速。

1697
01:21:55,930 --> 01:21:59,660
與在現實中，一複雜的
程序，世界的谷歌，

1698
01:21:59,660 --> 01:22:02,180
在天下 - 的Facebook的
他們將使用一個哈希表

1699
01:22:02,180 --> 01:22:03,740
對於很多不同的目的。

1700
01:22:03,740 --> 01:22:06,590
但是，他們不會如此天真
光看第一個字母

1701
01:22:06,590 --> 01:22:09,700
在蘋果或香蕉或
梨或哈密瓜，

1702
01:22:09,700 --> 01:22:13,420
因為你可以看到這些
名單仍可能長期做下去。

1703
01:22:13,420 --> 01:22:17,130
>> 所以這仍然可能是排序
的linear--所以有點慢，

1704
01:22:17,130 --> 01:22:19,980
像n的大O字
我們前面討論。

1705
01:22:19,980 --> 01:22:25,290
那麼什麼是真正的好哈希表會
do--它將具有更大的陣列。

1706
01:22:25,290 --> 01:22:28,574
而且它會使用一個更
複雜的哈希函數，

1707
01:22:28,574 --> 01:22:30,240
因此，它不只是看看“一個。”

1708
01:22:30,240 --> 01:22:35,480
也許它著眼於“一個-P-P-L-e”和
不知何故轉換這五個字母

1709
01:22:35,480 --> 01:22:38,400
入位置，其中
蘋果應存放。

1710
01:22:38,400 --> 01:22:42,660
我們只是天真地使用字母“A”
獨自一人，因為它的簡單好用。

1711
01:22:42,660 --> 01:22:44,600
>> 但哈希表，在
最後，你能想到的

1712
01:22:44,600 --> 01:22:47,270
作為組合
陣列，其中每一個

1713
01:22:47,270 --> 01:22:51,700
有一個鍊錶，理想
應盡可能的短。

1714
01:22:51,700 --> 01:22:54,364
而這不是一個明顯的解決方案。

1715
01:22:54,364 --> 01:22:57,280
事實上，大部分的微調
該那張引擎蓋時，底下

1716
01:22:57,280 --> 01:22:59,654
實施這些種類的
複雜的數據結構

1717
01:22:59,654 --> 01:23:01,640
是什麼是正確的
所述陣列的長度是多少？

1718
01:23:01,640 --> 01:23:03,250
什麼是正確的散列函數？

1719
01:23:03,250 --> 01:23:04,830
你如何保存，留作回憶？

1720
01:23:04,830 --> 01:23:07,249
>> 但是，如何實現快速
這種討論

1721
01:23:07,249 --> 01:23:10,540
升級，無論是到目前為止，它是一種
超過一個人的頭部在這一點上，這

1722
01:23:10,540 --> 01:23:11,360
是罰款。

1723
01:23:11,360 --> 01:23:18,820
但是，我們開始回憶，真
一些低級別和電子。

1724
01:23:18,820 --> 01:23:20,819
因此這又是本
抽象的主題，

1725
01:23:20,819 --> 01:23:23,610
在這裡，一旦你開始採取
理所當然的，好了，我已經得到了它 - 有

1726
01:23:23,610 --> 01:23:26,680
物理內存，好，我知道，每
物理位置有一個地址，

1727
01:23:26,680 --> 01:23:29,910
好吧，我知道了，我可以代表
這些地址為arrows--

1728
01:23:29,910 --> 01:23:34,650
您可以非常迅速地開始有
更複雜的談話說

1729
01:23:34,650 --> 01:23:38,360
到底似乎允許我們
解決類似搜索的問題

1730
01:23:38,360 --> 01:23:41,620
和排序更有效。

1731
01:23:41,620 --> 01:23:44,190
放心吧，太...
因為我覺得這

1732
01:23:44,190 --> 01:23:48,700
是我們已經進入了一些最深
的proper--我們已經這些CS主題

1733
01:23:48,700 --> 01:23:51,880
在這一天半完成
點你可能通常做主持

1734
01:23:51,880 --> 01:23:55,520
八週在一學期的課程。

1735
01:23:55,520 --> 01:23:59,670
>> 對這些有問題嗎？

1736
01:23:59,670 --> 01:24:01,100
沒有？

1737
01:24:01,100 --> 01:24:01,940
好吧。

1738
01:24:01,940 --> 01:24:05,610
那麼，我們為什麼不停在那裡，
開始吃午飯早幾分鐘，

1739
01:24:05,610 --> 01:24:07,052
恢復在短短約一個小時？

1740
01:24:07,052 --> 01:24:08,760
我會縈繞
有點用的問題。

1741
01:24:08,760 --> 01:24:11,343
然後，我將不得不去
走了幾個電話，如果這是確定。

1742
01:24:11,343 --> 01:24:15,000
我會在此期間開啟一段音樂，
但午餐應該是指日可待。

1743
01:24:15,000 --> 01:24:17,862

