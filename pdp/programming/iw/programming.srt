1
00:00:00,000 --> 00:00:00,030

2
00:00:00,030 --> 00:00:00,460
>> DAVID מלאן: בסדר.

3
00:00:00,460 --> 00:00:01,094
חזרנו.

4
00:00:01,094 --> 00:00:04,260
אז במגזר זה על תכנות מה
חשבתי שכדאי לעשות הוא שילוב של דברים.

5
00:00:04,260 --> 00:00:06,340
אחת, לעשות קצת
משהו על הידיים,

6
00:00:06,340 --> 00:00:08,690
אם כי באמצעות יותר שובב
תכנות environment--

7
00:00:08,690 --> 00:00:11,620
אחד כי הוא מופגן של
בדיוק מיני רעיונות

8
00:00:11,620 --> 00:00:14,220
אנחנו כבר מדברים על,
אבל קצת יותר רשמית.

9
00:00:14,220 --> 00:00:18,200
שני, להסתכל על כמה
הדרכים הטכניות נוסף

10
00:00:18,200 --> 00:00:21,520
כי מתכנת היה למעשה לפתור
בעיות כמו בעיית החיפוש

11
00:00:21,520 --> 00:00:24,530
כי הסתכלנו לפני
גם יותר מן היסוד

12
00:00:24,530 --> 00:00:26,020
בעיה מעניינת של מיון.

13
00:00:26,020 --> 00:00:28,840
>> אנחנו פשוט להניח מן לקבל ללכת
כי בספר טלפונים מוין,

14
00:00:28,840 --> 00:00:31,980
אבל זה לבדו הוא בעצם סוג של
בעיה קשה עם דרכים שונות

15
00:00:31,980 --> 00:00:32,479
כדי לפתור אותה.

16
00:00:32,479 --> 00:00:34,366
אז נשתמש אלה
מחלקה של בעיות

17
00:00:34,366 --> 00:00:36,740
נציג של דברים
ניתן לפתור אותה בכלל.

18
00:00:36,740 --> 00:00:38,980
ואז נדבר
לעיסוק מפורט יותר מה

19
00:00:38,980 --> 00:00:42,360
נקראים נתונים structures--
דרכים להשתכלל כמו רשימות מקושרות

20
00:00:42,360 --> 00:00:46,290
ושולחנות חשיש ועצים
מתכנת היה למעשה

21
00:00:46,290 --> 00:00:48,890
להשתמש ובדרך כלל משתמשים
על לוח לצייר

22
00:00:48,890 --> 00:00:51,840
תמונה של מה שהוא או היא
חוזה עבור יישום

23
00:00:51,840 --> 00:00:52,980
כמה פיסת תוכנה.

24
00:00:52,980 --> 00:00:55,130
>> אז בוא נעשה את הידיים על החלק הראשון.

25
00:00:55,130 --> 00:01:00,090
אז פשוט לקבל את הידות מלוכלכות עם
בסביבה קרא scratch.mit.edu.

26
00:01:00,090 --> 00:01:02,636
זהו כלים שאנו משתמשים
בכיתה הראשונה שלנו.

27
00:01:02,636 --> 00:01:04,510
למרות שהוא מתוכנן
לגילאי 12 ומעלה,

28
00:01:04,510 --> 00:01:07,570
אנו משתמשים בו עבור למעלה
חלק למדי כי קצת

29
00:01:07,570 --> 00:01:10,020
כיוון שזה כיף, נחמד
בצורה גרפית של למידה

30
00:01:10,020 --> 00:01:12,160
משהו קטן על תכנות.

31
00:01:12,160 --> 00:01:17,600
אז לכו ל- URL כי, שבו אתה
צריך לראות דף בצורה כזאת,

32
00:01:17,600 --> 00:01:23,330
וללכת קדימה ולחץ
הצטרף Scratch בצד ימין למעלה

33
00:01:23,330 --> 00:01:28,300
ולבחור את שם המשתמש ואת
סיסמא ובסופו של דבר לקבל את עצמך

34
00:01:28,300 --> 00:01:29,970
scratch.mit.edu account--.

35
00:01:29,970 --> 00:01:32,165

36
00:01:32,165 --> 00:01:34,665
חשבתי שאשתמש בזה בתור
ההזדמנות הראשונה להראות זאת.

37
00:01:34,665 --> 00:01:39,120
שאלה שהתעוררה במהלך ההפסקה
על מה קוד באמת נראה כמו.

38
00:01:39,120 --> 00:01:41,315
ואנחנו מדברים
במהלך ההפסקה על C,

39
00:01:41,315 --> 00:01:45,060
ב particular-- ובמיוחד
רמה נמוכה ב שפה קדומה.

40
00:01:45,060 --> 00:01:47,750
ואני רק עשיתי מהיר
החיפוש של גוגל כדי למצוא קוד C

41
00:01:47,750 --> 00:01:51,574
עבור חיפוש בינארי, האלגוריתם שאנחנו
המשמש לחיפוש שספר טלפון קודם לכן.

42
00:01:51,574 --> 00:01:54,240
בדוגמה זו בפרט, כמובן,
אינו מחפש ספר טלפונים.

43
00:01:54,240 --> 00:01:57,840
זה פשוט מחפש חבורה שלמה של
מספרים בזיכרון המחשב.

44
00:01:57,840 --> 00:02:01,000
אבל אם אתה רוצה רק לקבל חזותי
תחושת איזה תכנות בפועל

45
00:02:01,000 --> 00:02:05,370
שפה נראית, זה נראה
משהו קטן כזה.

46
00:02:05,370 --> 00:02:09,759
אז זה בערך 20 פלוס,
שורות קוד 30 או משהו כזה,

47
00:02:09,759 --> 00:02:12,640
אבל השיחה אנחנו
נהלו בחופשה

48
00:02:12,640 --> 00:02:16,000
היה על איך זה בעצם
מקבל נהפך אפסים ואחדים

49
00:02:16,000 --> 00:02:19,200
ואם אתה לא יכול פשוט לחזור כי
לעבד וללכת אפסים ואחדים

50
00:02:19,200 --> 00:02:20,210
לגבות לקוד.

51
00:02:20,210 --> 00:02:22,620
>> למרבה הצער, את התהליך
הוא כל כך טרנספורמטיבי

52
00:02:22,620 --> 00:02:24,890
שזה הרבה יותר קל לומר מאשר לעשות.

53
00:02:24,890 --> 00:02:29,400
הלכתי קדימה ולמעשה הפכתי
תכנית, חיפוש בינארי,

54
00:02:29,400 --> 00:02:32,700
לתוך אפסים ואחדים בדרך של
תוכנית בשם המהדר שאני

55
00:02:32,700 --> 00:02:34,400
במקרה יש כאן ממש על Mac שלי.

56
00:02:34,400 --> 00:02:37,850
ואם אתה מסתכל על המסך
כאן, מתמקד במיוחד

57
00:02:37,850 --> 00:02:43,520
על שישה עמודים באמצע אלו בלבד,
תראה אפסים יחידים.

58
00:02:43,520 --> 00:02:48,290
ואלה הם האפסים ואחדים כי
להלחין בדיוק שתוכנית חיפוש.

59
00:02:48,290 --> 00:02:53,720
>> וכך כל חתיכה של חמש חתיכות,
בייט אחד של אפסים ואחדים כאן,

60
00:02:53,720 --> 00:02:57,310
לייצג קצת הדרכה
בדרך כלל פנימי של מחשב.

61
00:02:57,310 --> 00:03:00,730
ואכן, אם שמעת את
סיסמה שיווקית "בתוך אינטל" - כי,

62
00:03:00,730 --> 00:03:04,610
כמובן, רק אומר שיש לך
המעבד או במוח אינטל בתוך המחשב.

63
00:03:04,610 --> 00:03:08,000
ומה זה אומר להיות מעבד הוא
יש כי לך סט פקוד,

64
00:03:08,000 --> 00:03:08,840
כביכול.

65
00:03:08,840 --> 00:03:11,620
>> כל מעבד בעולם, רב
אותם שנעשו על ידי אינטל בימים אלה,

66
00:03:11,620 --> 00:03:13,690
ומבין סופית
מספר הוראות.

67
00:03:13,690 --> 00:03:18,690
והוראות אלה הן כל כך ברמה נמוכה
כמו להוסיף שני המספרים הללו יחד,

68
00:03:18,690 --> 00:03:22,560
להכפיל שני מספרים אלה יחד,
להזיז את הכלי של נתונים מכאן

69
00:03:22,560 --> 00:03:27,340
לכאן בזיכרון, לחסוך זה
מידע מכאן עד להודעה חדשה בזיכרון,

70
00:03:27,340 --> 00:03:32,200
וכך forth-- כך מאוד, מאוד
ברמה נמוכה, פרטים אלקטרוניים כמעט.

71
00:03:32,200 --> 00:03:34,780
אבל עם אלה מתמטיים
פעולות מצמידות

72
00:03:34,780 --> 00:03:37,410
עם מה שהזכרנו קודם לכן,
הייצוג של נתונים

73
00:03:37,410 --> 00:03:40,450
כמו אפסים ואחדים, יכול
אתם בונים הכל

74
00:03:40,450 --> 00:03:44,180
כי מחשב יכול לעשות היום, אם
זה טקסטואלי, גרפי, מוסיקלי,

75
00:03:44,180 --> 00:03:45,580
אחרת.

76
00:03:45,580 --> 00:03:49,450
>> אז זה מאוד קל להגיע
לאיבוד העשבים של במהירות.

77
00:03:49,450 --> 00:03:52,150
ויש הרבה
אתגרים תחביריים

78
00:03:52,150 --> 00:03:56,630
לפיו אם תבצע את הפשוטה,
טיפשי של אף שגיאות הקלדה של התכנית

79
00:03:56,630 --> 00:03:57,860
יעבוד כלל.

80
00:03:57,860 --> 00:04:00,366
וכך במקום להשתמש
בשפה כמו C הבוקר,

81
00:04:00,366 --> 00:04:02,240
חשבתי שזה יהיה
כיף יותר כדי באמת לעשות

82
00:04:02,240 --> 00:04:04,840
ויזואלית יותר משהו, אשר
בעוד המיועדות לילדים

83
00:04:04,840 --> 00:04:08,079
למעשה הוא ביטוי מושלם
של התכנות בפועל

84
00:04:08,079 --> 00:04:10,370
language-- פשוט קורה
להשתמש בתמונות במקום טקסט

85
00:04:10,370 --> 00:04:11,710
לייצג רעיונות אלה.

86
00:04:11,710 --> 00:04:15,470
>> אז פעם אכן יש לך
חשבון על scratch.mit.edu,

87
00:04:15,470 --> 00:04:21,070
לחץ על לחצן צור
בחלק העליון השמאלי של האתר.

88
00:04:21,070 --> 00:04:24,620
ואתה צריך לראות בסביבה כמו
אחד אני עומד לראות על המסך שלי

89
00:04:24,620 --> 00:04:26,310
כאן.

90
00:04:26,310 --> 00:04:29,350
ונבלה קצת
קצת זמן לשחק כאן.

91
00:04:29,350 --> 00:04:34,080
בוא נראה אם ​​אנחנו לא יכולים כל לפתור חלק
בעיות ביחד באופן הבא.

92
00:04:34,080 --> 00:04:39,420
>> אז מה תראה בתוך זה
environment-- ולמעשה רק תן

93
00:04:39,420 --> 00:04:40,050
שתעצור.

94
00:04:40,050 --> 00:04:42,680
האם מישהו לא כאן?

95
00:04:42,680 --> 00:04:45,070
לא כאן?

96
00:04:45,070 --> 00:04:45,800
בסדר.

97
00:04:45,800 --> 00:04:49,030
אז תנו לי להצביע על כמה
מאפיינים של סביבה זו.

98
00:04:49,030 --> 00:04:55,024
>> אז בפינה השמאלית העליונה של המסך, אנחנו
יש שלב של גרד, אם אפשר לומר כך.

99
00:04:55,024 --> 00:04:57,440
שריטה היא לא רק שם
של שפת התכנות הזאת;

100
00:04:57,440 --> 00:05:00,356
זה גם השם של החתול
אתה רואה כברירת מחדל יש בכתום.

101
00:05:00,356 --> 00:05:02,160
הוא נמצא על הבמה, כך
בדומה תיארתי

102
00:05:02,160 --> 00:05:05,770
הצב קודם לכן כמו להיות בתוך
סביבת לוח לבן מלבני.

103
00:05:05,770 --> 00:05:09,800
העולם של חתול זו הוא מוגבל לחלוטין
לזה העליון מלבן שם למעלה.

104
00:05:09,800 --> 00:05:12,210
>> בינתיים, בצד ימין
מצד כאן, זה

105
00:05:12,210 --> 00:05:15,610
רק אזור סקריפטים,
לוח חלק, אם תרצה.

106
00:05:15,610 --> 00:05:18,590
זה המקום שבו אנחנו הולכים לכתוב
התוכניות שלנו בעוד רגע.

107
00:05:18,590 --> 00:05:22,935
וגם את אבני הבניין מהן נעמוד
להשתמש בו כדי לכתוב את זה program-- את הפאזל

108
00:05:22,935 --> 00:05:25,310
חתיכות, אם אתה will-- הוא
אלה ממש כאן באמצע,

109
00:05:25,310 --> 00:05:27,500
והם מסווגים
לפי פונקציונלי.

110
00:05:27,500 --> 00:05:31,000
כך, למשל, אני הולך קדימה
ולהפגין לפחות אחד מאלה.

111
00:05:31,000 --> 00:05:33,690
אני הולך קדימה, לחץ
בקטגוריה Control למעלה.

112
00:05:33,690 --> 00:05:35,720
>> אז אלו הם בקטגוריות למעלה.

113
00:05:35,720 --> 00:05:39,410
אני הולך ללחוץ על קטגורית הבקרה.

114
00:05:39,410 --> 00:05:44,020
במקום זאת, אני הולך ללחוץ על האירועים
בקטגוריה, העליון עד מאוד ראשון.

115
00:05:44,020 --> 00:05:47,790
ואם תרצה לבצע יחד אפילו
כפי שאנו עושים זאת, אתה די מוזמן.

116
00:05:47,790 --> 00:05:52,180
אני הולך ללחוץ ולגרור זה
ראשון, "כאשר הדגל ירוק נסגר."

117
00:05:52,180 --> 00:05:58,410
ואז אני הולכת להפיל אותו רק
בערך בראש הצפחות ​​הריקות שלי.

118
00:05:58,410 --> 00:06:01,450
>> ומה שיפה Scratch
הוא פיסת הפאזל הזה, כאשר

119
00:06:01,450 --> 00:06:04,560
בזה עם פאזל אחר
חתיכות, הוא הולך לעשות, פשוטו כמשמעו

120
00:06:04,560 --> 00:06:06,460
מה אלה חתיכות הפאזל אומרים לעשות.

121
00:06:06,460 --> 00:06:09,710
כך, למשל, Scratch נכון
עכשיו באמצע עולמו.

122
00:06:09,710 --> 00:06:14,660
אני הולך קדימה, לבחור
עכשיו, נניח, בקטגורית Motion,

123
00:06:14,660 --> 00:06:18,000
אם תרצה לעשות את
same-- קטגוריה Motion.

124
00:06:18,000 --> 00:06:20,430
ועכשיו לב יש לי כל
חבורה של חתיכות פאזל כאן

125
00:06:20,430 --> 00:06:23,370
כי, שוב, סוג של לעשות את מה שהם אומרים.

126
00:06:23,370 --> 00:06:28,110
ואני הולך קדימה, לגרור
ושחרר את הבלוק הצעד הנכון כאן.

127
00:06:28,110 --> 00:06:31,860
>> ושימו לב כי ברגע שאתה מקבל
קרוב לתחתית של "הדגל הירוק

128
00:06:31,860 --> 00:06:34,580
"כפתור, הודעה לוחצת
איך מופיע פס לבן,

129
00:06:34,580 --> 00:06:36,950
כאילו זה כמעט
מגנטי, היא רוצה ללכת לשם.

130
00:06:36,950 --> 00:06:43,070
פשוט להרפות, וזה יהיה לצלם
יחד ואת הצורות תתאמנה.

131
00:06:43,070 --> 00:06:46,620
ועכשיו אתה יכול אולי כמעט
לנחש לאן אנחנו הולכים עם זה.

132
00:06:46,620 --> 00:06:51,570
>> אם אתה מסתכל על במת Scratch
כאן ולשאת מבט על גבי זה,

133
00:06:51,570 --> 00:06:55,142
תראה אור אדום,
תמרור עצור, ודגל ירוק.

134
00:06:55,142 --> 00:06:57,100
ואני הולך קדימה
ולצפות screen-- שלי

135
00:06:57,100 --> 00:06:58,460
רק לרגע, אם אתה יכול.

136
00:06:58,460 --> 00:07:01,960
אני הולך ללחוץ על
ירוק דגל עכשיו,

137
00:07:01,960 --> 00:07:07,850
והוא עבר מה שנראה 10 צעדים
או 10 פיקסלים, 10 נקודות, על המסך.

138
00:07:07,850 --> 00:07:13,390
>> וכך לא מרגש,
אבל הרשו לי להעלות

139
00:07:13,390 --> 00:07:17,440
אפילו בלי התורה הזאת, רק
באמצעות עצמו let intuition-- משלך

140
00:07:17,440 --> 00:07:22,560
לי להציע לך להבין כיצד
לעשות הליכה Scratch תקין מהבמה.

141
00:07:22,560 --> 00:07:28,700
תגיד לו לפנות מקום בצד ימין של
המסך, כל הדרך בצד ימין.

142
00:07:28,700 --> 00:07:32,200
תן לי לתת לך רגע
או משהו כזה כדי להתמודד עם זה.

143
00:07:32,200 --> 00:07:37,681
אולי אתה רוצה להעיף מבט
ב בקטגוריות אחרות של בלוקים.

144
00:07:37,681 --> 00:07:38,180
בסדר.

145
00:07:38,180 --> 00:07:41,290
אז רק כדי לסכם, וכשיש לנו
הדגל הירוק לחצו כאן

146
00:07:41,290 --> 00:07:44,850
ולעבור 10 שלבים הוא
ההנחיה היחידה, כל לי זמן

147
00:07:44,850 --> 00:07:46,720
לחץ על הדגל הירוק, מה קורה?

148
00:07:46,720 --> 00:07:50,070
ובכן, זה פועל התוכנית שלי.

149
00:07:50,070 --> 00:07:52,450
אז אני יכול לעשות את זה
אולי 10 פעמים באופן ידני,

150
00:07:52,450 --> 00:07:55,130
אבל זה מרגיש קצת
קצת hackish, אם אפשר לומר כך,

151
00:07:55,130 --> 00:07:57,480
לפיה אני לא ממש
לפתרון הבעיה.

152
00:07:57,480 --> 00:08:00,530
אני רק מנסה שוב
שוב ושוב ושוב

153
00:08:00,530 --> 00:08:03,180
עד שאני מעין בטעות
להשיג את ההוראה

154
00:08:03,180 --> 00:08:05,560
כי יצאתי להשיג קודם לכן.

155
00:08:05,560 --> 00:08:08,200
>> אך אנו יודעים מן שלנו
פסאודו קוד קודם לכן כי יש

156
00:08:08,200 --> 00:08:11,870
הרעיון הזה בתכנות looping,
עושה משהו שוב ושוב.

157
00:08:11,870 --> 00:08:14,888
וכך ראיתי חבורה מכם
הגיע חתיכה מה הפאזל?

158
00:08:14,888 --> 00:08:17,870

159
00:08:17,870 --> 00:08:18,730
חזור על הפעולה עד.

160
00:08:18,730 --> 00:08:21,400
אז אנחנו יכולים לעשות משהו
כמו לחזור עד.

161
00:08:21,400 --> 00:08:23,760
ומה אתה חוזר עד בדיוק?

162
00:08:23,760 --> 00:08:27,720

163
00:08:27,720 --> 00:08:28,540
>> בסדר.

164
00:08:28,540 --> 00:08:31,974
ותן לי ללכת עם אחד זה
מעט פשוט רק לרגע.

165
00:08:31,974 --> 00:08:33,140
תן לי להמשיך לעשות את זה.

166
00:08:33,140 --> 00:08:35,559
שים לב כי, כפי שאתה יכול להיות
גילה תחת שליטה,

167
00:08:35,559 --> 00:08:38,409
יש לחסום חזור על פעולה זו, אשר
לא נראה כאילו זה כל כך גדול.

168
00:08:38,409 --> 00:08:41,039
אין הרבה מקום
בין אותם שני קווים צהובים.

169
00:08:41,039 --> 00:08:43,539
אבל כפי שחלקכם אולי יש
לב, אם אתה גרור ושחרר,

170
00:08:43,539 --> 00:08:45,150
שימו לב איך הוא גדל כדי למלא את הצורה.

171
00:08:45,150 --> 00:08:46,274
>> ואתה יכול גם לדחוס יותר.

172
00:08:46,274 --> 00:08:48,670
זה פשוט ימשיך גדל אם
יש לגרור מרחף מעליו.

173
00:08:48,670 --> 00:08:51,110
ואני לא יודע מה
הכי טוב כאן, אז בואו

174
00:08:51,110 --> 00:08:54,760
לי לפחות לחזור חמש פעמים, עבור
למשל, ולאחר מכן לחזור אל הבמה

175
00:08:54,760 --> 00:08:56,720
ולחץ על הדגל הירוק.

176
00:08:56,720 --> 00:08:59,110
ועכשיו שימי לב שזו לא ממש שם.

177
00:08:59,110 --> 00:09:02,400
>> עכשיו חלק מכם מוצע, כמו
ויקטוריה פשוט לא, לחזור 10 פעמים.

178
00:09:02,400 --> 00:09:05,140
וזה עושה בדרך כלל
לקבל אותו כל הדרך,

179
00:09:05,140 --> 00:09:10,510
אבל לא היה מעניק יש להיות יותר חזק
הדרך מאשר להבין באופן שרירותי

180
00:09:10,510 --> 00:09:12,640
כמה צעדים לעשות?

181
00:09:12,640 --> 00:09:17,680
מה יכול להיות טוב יותר בלוק
חוץ מחזרה 10 פעמים להיות?

182
00:09:17,680 --> 00:09:20,380
>> כן, אז למה לא לעשות משהו לנצח?

183
00:09:20,380 --> 00:09:24,390
ועכשיו תן לי לעבור פיסת הפאזל הזה
פנימה וללכת להיפטר אחת זה.

184
00:09:24,390 --> 00:09:28,300
עכשיו שם לב, לא משנה היכן Scratch
מתחיל, הוא הולך אל הקצה.

185
00:09:28,300 --> 00:09:30,700
ותודה לאל MIT,
מי עושה שריטה, רק

186
00:09:30,700 --> 00:09:33,190
מוודא שהוא לעולם
נעלם לחלוטין.

187
00:09:33,190 --> 00:09:35,360
אתה תמיד יכול לתפוס בזנבו.

188
00:09:35,360 --> 00:09:37,680
>> ובדיוק באופן אינטואיטיבי,
למה הוא לא מפסיק לנוע?

189
00:09:37,680 --> 00:09:38,892
מה קורה כאן?

190
00:09:38,892 --> 00:09:41,440

191
00:09:41,440 --> 00:09:43,824
הוא כנראה הפסיק, אבל
אז אם אני מרים וגרור

192
00:09:43,824 --> 00:09:45,240
הוא מתעקש ללכת לשם.

193
00:09:45,240 --> 00:09:46,123
למה זה?

194
00:09:46,123 --> 00:09:51,610

195
00:09:51,610 --> 00:09:54,360
באמת, מחשב הוא פשוטו כמשמעו
הולך לעשות מה שאתה אומר את זה כדי לעשות.

196
00:09:54,360 --> 00:09:58,380
אז אם אמרת את זה קודם לכן לעשות את
בעקבות דבר לנצח, לעבור 10 צעדים,

197
00:09:58,380 --> 00:10:01,860
זה הולך להמשיך וללכת
עד שאני פגעתי בתמרור העצור האדום

198
00:10:01,860 --> 00:10:04,620
ולעצור את התוכנית כליל.

199
00:10:04,620 --> 00:10:06,610
>> אז גם אם אתם לא
לעשות זאת, איך יכולתי

200
00:10:06,610 --> 00:10:09,510
לעשות את הצעד Scratch מהר
על פני המסך?

201
00:10:09,510 --> 00:10:12,060

202
00:10:12,060 --> 00:10:13,280
עוד צעדים, נכון?

203
00:10:13,280 --> 00:10:15,710
אז במקום לעשות 10
בכל פעם, למה לא אנחנו

204
00:10:15,710 --> 00:10:20,100
קדימה ולשנות אותו עם--
מה היית propose-- 50?

205
00:10:20,100 --> 00:10:24,410
אז עכשיו אני הולך ללחוץ על ירוק
דגל, ואכן, הוא הולך ממש מהר.

206
00:10:24,410 --> 00:10:27,180
>> וזה, כמובן, הוא רק
ביטוי של אנימציה.

207
00:10:27,180 --> 00:10:28,060
מהו אנימציה?

208
00:10:28,060 --> 00:10:33,090
זה רק מראה לך את האדם
חבורה שלמה של תמונות סטילס ממש,

209
00:10:33,090 --> 00:10:34,160
באמת, ממש מהר.

210
00:10:34,160 --> 00:10:36,500
וכך אם אנחנו רק אומרים
לו לזוז יותר שלבים,

211
00:10:36,500 --> 00:10:39,750
אנחנו רק בעלת ההשפעה להיות
שינוי שם הוא נמצא על המסך

212
00:10:39,750 --> 00:10:42,900
כל במהירות רבה יותר ליחידת זמן.

213
00:10:42,900 --> 00:10:46,454
>> עכשיו האתגר הבא כי הצעתי
היה אמור להיות לו להקפיץ את הקצה.

214
00:10:46,454 --> 00:10:49,120
ובלי לדעת מה פאזל
חתיכות exist-- כי זה בסדר

215
00:10:49,120 --> 00:10:53,030
אם אתה לא מקבל את
שלב של challenge-- מה

216
00:10:53,030 --> 00:10:54,280
אתה רוצה לעשות באופן אינטואיטיבי?

217
00:10:54,280 --> 00:10:58,030
איך היינו לו להקפיץ הלוך
ושוב, בין שמאל וימין?

218
00:10:58,030 --> 00:11:02,630

219
00:11:02,630 --> 00:11:03,810
>> כֵּן.

220
00:11:03,810 --> 00:11:05,680
אז אנחנו צריכים איזושהי
של מצב, ואנחנו

221
00:11:05,680 --> 00:11:09,710
נראה שיש תנאים, כך
לדבר, תחת קטגורית הבקרה.

222
00:11:09,710 --> 00:11:14,110
איזה בלוקים אלה
אנחנו כנראה רוצים?

223
00:11:14,110 --> 00:11:15,200
כן, אולי "אם, אז."

224
00:11:15,200 --> 00:11:18,780
אז להבחין כי בין אבני צהוב
יש לנו כאן, המסר הוא "אם"

225
00:11:18,780 --> 00:11:23,920
"אם, אחר" בלוק זה או אחר יהיה
מאפשר לנו לקבל החלטה לעשות את זה

226
00:11:23,920 --> 00:11:25,000
או לעשות את זה.

227
00:11:25,000 --> 00:11:27,380
ואתה יכול אפילו קן אותם
לעשות דברים מרובים.

228
00:11:27,380 --> 00:11:34,910
לחלופין, אם אתה כבר לא הלכת כאן עדיין,
קדימה לקטגורית החישה

229
00:11:34,910 --> 00:11:39,612
ו-- בוא נראה אם ​​זה כאן.

230
00:11:39,612 --> 00:11:43,050

231
00:11:43,050 --> 00:11:52,050
>> אז מה לחסום עשויה להועיל כאן
כדי לזהות אם הוא מהבמה?

232
00:11:52,050 --> 00:11:56,740
כן, שימו לב כי חלק אלה בלוקים
ניתן parametrized, אם אפשר לומר כך.

233
00:11:56,740 --> 00:12:00,706
הם יכולים להיות מעין אישית, לא
בניגוד HTML אתמול עם תכונות,

234
00:12:00,706 --> 00:12:03,330
איפה אלה תכונות מין
להתאים אישית את ההתנהגות של תג.

235
00:12:03,330 --> 00:12:08,880
באופן דומה כאן, אני יכול לתפוס זה לגעת
בלוק ושינוי ולשאול את השאלה,

236
00:12:08,880 --> 00:12:11,500
אתה נוגע בעכבר
מצביע כמו הסמן

237
00:12:11,500 --> 00:12:13,250
או שאת נוגעת בקצה?

238
00:12:13,250 --> 00:12:15,210
>> אז תן לי ללכת ולעשות את זה.

239
00:12:15,210 --> 00:12:18,130
אני הולך כדי להתרחק לרגע.

240
00:12:18,130 --> 00:12:21,320
תן לי לתפוס פיסת הפאזל הזה
כאן, פיסת הפאזל הזה זה,

241
00:12:21,320 --> 00:12:24,570
ואני הולך מתערבב לך
אותם לרגע.

242
00:12:24,570 --> 00:12:27,620
אני הולך להעביר את זה,
לשנות את זה לקצה נגיעה,

243
00:12:27,620 --> 00:12:38,590
ואני הולך לעשות את זה בתנועה.

244
00:12:38,590 --> 00:12:40,490
אז הנה כמה מרכיבים.

245
00:12:40,490 --> 00:12:42,570
אני חושב שיש לי את כל מה שאני רוצה.

246
00:12:42,570 --> 00:12:47,710
>> האם מישהו רוצה להציע איך אני
יכול להתחבר אולי אלה מלמעלה למטה

247
00:12:47,710 --> 00:12:52,020
על מנת לפתור את הבעיה של צורך
Scratch צעד נכון כדי משמאל לימין כדי

248
00:12:52,020 --> 00:12:57,020
משמאל לימין לשמאל, כל
זמן פשוט מקפץ מהקיר?

249
00:12:57,020 --> 00:12:58,050
מה אני רוצה לעשות?

250
00:12:58,050 --> 00:13:01,097
איזה בלוק כדאי לי להתחבר
"כאשר הדגל ירוק לחץ ראשון"?

251
00:13:01,097 --> 00:13:04,060

252
00:13:04,060 --> 00:13:06,200
>> אוקיי, אז בואו נתחיל עם "לנצח".

253
00:13:06,200 --> 00:13:07,170
מה הולך בפנים הבא?

254
00:13:07,170 --> 00:13:10,290
מישהו אחר.

255
00:13:10,290 --> 00:13:11,850
בסדר, עבר צעדים.

256
00:13:11,850 --> 00:13:12,350
בסדר.

257
00:13:12,350 --> 00:13:14,470
ואז מה?

258
00:13:14,470 --> 00:13:15,120
אז אז אם.

259
00:13:15,120 --> 00:13:17,720
ושימו לב, למרות שזה נראה
דחוק בחוזקה,

260
00:13:17,720 --> 00:13:19,500
זה יהיה פשוט לגדול למלא.

261
00:13:19,500 --> 00:13:21,500
זה פשוט יקפוץ למקום שאני רוצה שיהיה.

262
00:13:21,500 --> 00:13:25,920
>> ומה אני יכול לשים בין
ה- if ואת אז?

263
00:13:25,920 --> 00:13:27,180
כנראה "אם נוגעים קצה."

264
00:13:27,180 --> 00:13:31,800
ושימו לב, שוב, זה גדול מדי
עבור זה, אבל זה יגדל למלא.

265
00:13:31,800 --> 00:13:35,002
ואז להפוך 15 מעלות?

266
00:13:35,002 --> 00:13:35,710
כמה מעלות?

267
00:13:35,710 --> 00:13:38,800

268
00:13:38,800 --> 00:13:41,196
כן, אז 180 יסתובבו
לי כל הדרך מסביב.

269
00:13:41,196 --> 00:13:42,570
אז בואו נראה אם ​​יש לי זכות זו.

270
00:13:42,570 --> 00:13:43,930
תן לי להתרחק.

271
00:13:43,930 --> 00:13:45,130
>> תן לי לגרור את Scratch.

272
00:13:45,130 --> 00:13:50,030
אז הוא קצת מעווה
עכשיו, אבל זה בסדר.

273
00:13:50,030 --> 00:13:52,231
איך אני יכול לאפס אותו בקלות?

274
00:13:52,231 --> 00:13:59,879

275
00:13:59,879 --> 00:14:01,045
אני הולך לרמות מעט.

276
00:14:01,045 --> 00:14:04,074

277
00:14:04,074 --> 00:14:05,990
אז אני מוסיף עוד
בלוק, רק כדי להיות ברור.

278
00:14:05,990 --> 00:14:08,424
אני רוצה שהוא יפנה 90 מעלות
ימינה כברירת מחדל,

279
00:14:08,424 --> 00:14:10,840
אז אני פשוט הולך לספר לו
כדי לעשות את זה באופן תכנותי.

280
00:14:10,840 --> 00:14:11,632
והנה אנחנו הולכים.

281
00:14:11,632 --> 00:14:14,740

282
00:14:14,740 --> 00:14:15,740
נראה שהצלחנו לעשות את זה.

283
00:14:15,740 --> 00:14:19,980
זה קצת מוזר, כי
הוא צועד במהופך.

284
00:14:19,980 --> 00:14:21,250
בואו לקרוא כי באג.

285
00:14:21,250 --> 00:14:22,120
זו טעות.

286
00:14:22,120 --> 00:14:27,320
באג הוא טעות תוכנית,
טעות לוגית כי אני, האדם, עושה.

287
00:14:27,320 --> 00:14:28,985
למה הוא הולך הפוך?

288
00:14:28,985 --> 00:14:33,560

289
00:14:33,560 --> 00:14:35,250
האם MIT לפשל או אני?

290
00:14:35,250 --> 00:14:38,840

291
00:14:38,840 --> 00:14:42,550
>> כן, אני מתכוון, זה לא MIT של
אשמה. הם נתנו לי פיסת הפאזל

292
00:14:42,550 --> 00:14:44,970
שאומר להפוך חלק במספר מעלות.

293
00:14:44,970 --> 00:14:47,672
וגם על פי עצתו של ויקטוריה,
אני פונה 180 מעלות,

294
00:14:47,672 --> 00:14:48,880
המהווה את האינטואיציה התקינה.

295
00:14:48,880 --> 00:14:53,700
אבל להפוך 180 מעלות, פשוטו כמשמעו
משמעותו הפיכה 180 מעלות,

296
00:14:53,700 --> 00:14:55,860
וזה לא ממש
מה שאני רוצה, כנראה.

297
00:14:55,860 --> 00:14:58,026
בגלל לפחות הוא נמצא
דו ממדים זה בעולם,

298
00:14:58,026 --> 00:15:00,740
כך מפנה הוא באמת הולך
כדי להעיף אותו עם הראש למטה.

299
00:15:00,740 --> 00:15:04,030
>> אני כנראה רוצה להשתמש במה בלוק
במקום, על סמך מה אתה רואה כאן?

300
00:15:04,030 --> 00:15:11,890

301
00:15:11,890 --> 00:15:14,790
איך נוכל לתקן את זה?

302
00:15:14,790 --> 00:15:18,380
כן, כדי שנוכל להצביע
בכיוון ההפוך.

303
00:15:18,380 --> 00:15:22,300
ובעצם אפילו זה
לא הולך להיות מספיק,

304
00:15:22,300 --> 00:15:26,410
כי אנחנו יכולים קוד קשה רק
כדי הצבעה שמאלה או ימינה.

305
00:15:26,410 --> 00:15:27,920
>> אתה יודע מה אנחנו יכולים לעשות?

306
00:15:27,920 --> 00:15:30,160
זה נראה כאילו יש לנו
בלוק נוחות כאן.

307
00:15:30,160 --> 00:15:32,987
אם אני להתקרב, לראות
משהו שאנחנו אוהבים כאן?

308
00:15:32,987 --> 00:15:36,120

309
00:15:36,120 --> 00:15:40,020
אז זה נראה כאילו יש MIT
הפשטה נבנתה כאן.

310
00:15:40,020 --> 00:15:45,440
בלוק זה נראה שווה
כדי חוסם אחר, רב?

311
00:15:45,440 --> 00:15:49,510
>> בלוק אחד זה נראה שווה
לשלישייה הזאת של רחובות

312
00:15:49,510 --> 00:15:50,880
שיש לנו כאן.

313
00:15:50,880 --> 00:15:54,670
אז מתברר שאני יכול לפשט שלי
תכנית על ידי להיפטר מכל זה

314
00:15:54,670 --> 00:15:58,270
ופשוט לשים את זה כאן.

315
00:15:58,270 --> 00:16:01,620
ועכשיו הוא עדיין קצת
מרכבה, וזה בסדר לעת עתה.

316
00:16:01,620 --> 00:16:03,370
נשאיר כי להיות.

317
00:16:03,370 --> 00:16:06,000
אבל התוכנית שלי היא אפילו
פשוט, וזה גם

318
00:16:06,000 --> 00:16:09,060
יהיה נציג
של מטרה programming--

319
00:16:09,060 --> 00:16:13,430
באופן אידיאלי הוא להפוך את הקוד שלך כמו
פשוט, קומפקטי ככל האפשר,

320
00:16:13,430 --> 00:16:15,650
ועדיין להיות כמו
קריא ככל האפשר.

321
00:16:15,650 --> 00:16:20,310
אתה לא רוצה לעשות את זה כל כך תמציתי
שזה קשה להבין.

322
00:16:20,310 --> 00:16:22,826
>> אבל שם לב שאני כבר אחליף
שלושה רחובות עם אחד,

323
00:16:22,826 --> 00:16:24,200
וזה ללא ספק דבר טוב.

324
00:16:24,200 --> 00:16:27,280
אני הפשטה משם את הרעיון
לבדוק אם אתה

325
00:16:27,280 --> 00:16:29,120
על הקצה עם רק בלוק אחד.

326
00:16:29,120 --> 00:16:31,520
עכשיו אנחנו יכולים להשתעשע עם זה, למעשה.

327
00:16:31,520 --> 00:16:35,790
זה לא מוסיף כל כך הרבה
ערך אינטלקטואלי אבל ערך שובב.

328
00:16:35,790 --> 00:16:39,730
אני הולך קדימה
לתפוס את הצליל הזה כאן.

329
00:16:39,730 --> 00:16:42,900

330
00:16:42,900 --> 00:16:46,420
אז תן לי ללכת קדימה, ולתת לי
לעצור את התכנית לרגע.

331
00:16:46,420 --> 00:16:52,070
אני הולך לומר את הבאות,
המאפשר גישה למיקרופון שלי.

332
00:16:52,070 --> 00:16:53,181
>> מתחילים.

333
00:16:53,181 --> 00:16:53,680
אאוץ.

334
00:16:53,680 --> 00:16:58,710

335
00:16:58,710 --> 00:17:01,140
בואו ננסה את זה שוב.

336
00:17:01,140 --> 00:17:02,279
מתחילים.

337
00:17:02,279 --> 00:17:03,570
אישור, הקלטתי את הדבר הלא נכון.

338
00:17:03,570 --> 00:17:04,580
מתחילים.

339
00:17:04,580 --> 00:17:05,080
אאוץ.

340
00:17:05,080 --> 00:17:07,910

341
00:17:07,910 --> 00:17:08,800
אאוץ.

342
00:17:08,800 --> 00:17:09,300
בסדר.

343
00:17:09,300 --> 00:17:10,791
עכשיו אני צריך להיפטר מזה.

344
00:17:10,791 --> 00:17:11,290
בסדר.

345
00:17:11,290 --> 00:17:13,950
>> אז עכשיו יש לי
הקלטה של ​​רק "אאוץ '."

346
00:17:13,950 --> 00:17:18,040
אז עכשיו אני הולך
קדימה קוראים לזה "אאוץ '."

347
00:17:18,040 --> 00:17:20,270
אני הולך לחזור
לסקריפטים שלי, ועכשיו

348
00:17:20,270 --> 00:17:25,460
בהודעה יש בלוק זה זה נקרא
לנגן צליל "מיאו" או לנגן צליל "אאוץ '."

349
00:17:25,460 --> 00:17:28,920
אני הולך לגרור אותו, והיכן
אני צריך לשים את זה על אפקט קומי?

350
00:17:28,920 --> 00:17:31,740

351
00:17:31,740 --> 00:17:37,860
כן, אז עכשיו זה סוג של
מרכבה, כי עכשיו זה block--

352
00:17:37,860 --> 00:17:42,050
שימו לב איך קצה "אם על זה,
להקפיץ "הוא סוג של עצמאי.

353
00:17:42,050 --> 00:17:43,704
אז אני צריך לתקן את זה.

354
00:17:43,704 --> 00:17:44,870
תן לי להמשיך לעשות את זה.

355
00:17:44,870 --> 00:17:48,630
תן לי להיפטר זה ולחזור
כדי המקורי שלנו, יותר מכוון

356
00:17:48,630 --> 00:17:49,870
פונקציונלי.

357
00:17:49,870 --> 00:18:01,080
אז "אם נוגעים קצה, ואז" אני רוצה
לפנות, כמו ויקטוריה מוצעת,

358
00:18:01,080 --> 00:18:02,480
180 מעלות.

359
00:18:02,480 --> 00:18:05,497
והאם אני רוצה לשחק
את הצליל "אאוץ '" שם?

360
00:18:05,497 --> 00:18:11,800

361
00:18:11,800 --> 00:18:15,580
>> כן, שימי לב שזו מחוץ
בלוק צהוב.

362
00:18:15,580 --> 00:18:17,680
אז זה גם יהיה
באג, אבל אני שמתי לב לזה.

363
00:18:17,680 --> 00:18:21,290
אז אני הולך לגרור אותו כאן,
והודעה עכשיו זה בתוך "אם".

364
00:18:21,290 --> 00:18:24,250
אז "אם" הוא מסוג זה
של כתם זרוע דמוי כמו

365
00:18:24,250 --> 00:18:26,260
זה רק הולך
לעשות מה בתוכו.

366
00:18:26,260 --> 00:18:30,216
אז עכשיו אם אני Zoom החוצה
את הסיכון annoying--

367
00:18:30,216 --> 00:18:32,860

368
00:18:32,860 --> 00:18:36,470
>> COMPUTER: אאוץ ', אאוץ', אאוץ '.

369
00:18:36,470 --> 00:18:39,910
>> DAVID מלאן: וזה
פשוט להמשיך לנצח.

370
00:18:39,910 --> 00:18:44,160
עכשיו רק כדי להאיץ דברים
כאן, תן לי להמשיך ולפתוח,

371
00:18:44,160 --> 00:18:50,460
בואו say-- תנו לי ללכת כמה
דברים משלי מהכיתה.

372
00:18:50,460 --> 00:18:53,000

373
00:18:53,000 --> 00:19:00,220
ותנו לי להיפתח, נניח, זה
אחד שנעשה על ידי אחד עמיתי ההוראה שלנו

374
00:19:00,220 --> 00:19:01,500
לפני כמה שנים.

375
00:19:01,500 --> 00:19:04,732
אז חלקכם אולי זוכרים
המשחק הזה פעם,

376
00:19:04,732 --> 00:19:05,940
וזה בעצם מדהים.

377
00:19:05,940 --> 00:19:08,190
למרות שעשינו את
פשוט של תוכניות עכשיו,

378
00:19:08,190 --> 00:19:09,980
הבה נבחן מה זה
למעשה נראה.

379
00:19:09,980 --> 00:19:10,650
תן לי פגע לשחק.

380
00:19:10,650 --> 00:19:14,210

381
00:19:14,210 --> 00:19:18,980
>> אז במשחק הזה, יש לנו
צפרדע, ושימוש בחץ keys--

382
00:19:18,980 --> 00:19:23,340
הוא נוקט צעדים יותר גדולים ממה שאני remember--
יש לי שליטה על זה צפרדע.

383
00:19:23,340 --> 00:19:29,630
והמטרה היא להשיג פני עסוק
כביש מבלי להיתקל המכוניות.

384
00:19:29,630 --> 00:19:34,735
ובואו see-- אם אלך לישון כאן, אני
צריך לחכות יומן כדי לגלול על ידי.

385
00:19:34,735 --> 00:19:38,130

386
00:19:38,130 --> 00:19:39,274
זה מרגיש כמו ג'וק.

387
00:19:39,274 --> 00:19:42,240

388
00:19:42,240 --> 00:19:43,495
זהו סוג של באג.

389
00:19:43,495 --> 00:19:45,980

390
00:19:45,980 --> 00:19:46,480
בסדר.

391
00:19:46,480 --> 00:19:51,550
אני על זה כאן,
שם, ולאחר מכן אתה שומר

392
00:19:51,550 --> 00:19:54,100
הולך עד שאתה מקבל את כל
הצפרדעים אל חבצלות מים.

393
00:19:54,100 --> 00:19:55,920
עכשיו זה אולי נראה
כל מורכבות יותר,

394
00:19:55,920 --> 00:19:57,840
אבל בואו ננסה לשבור
זה למטה נפשי

395
00:19:57,840 --> 00:20:00,040
ומילולי לגושים המרכיבים אותו.

396
00:20:00,040 --> 00:20:03,910
אז יש כנראה חידה
חתיכה כי לא ראינו עדיין

397
00:20:03,910 --> 00:20:07,440
אבל זה להגיב הקשות,
לדברים שאני מכה על המקלדת.

398
00:20:07,440 --> 00:20:11,660
>> אז יש כנראה איזשהו
בלוק שאומר, אם המפתח שווה עד,

399
00:20:11,660 --> 00:20:15,965
אז לעשות משהו עם Scratch--
אולי להזיז אותו 10 צעדים לכאן.

400
00:20:15,965 --> 00:20:20,240
אם המפתח למטה נלחץ, להעביר 10 צעדים
בדרך זו, או מקש שמאל, להעביר 10 צעדים

401
00:20:20,240 --> 00:20:21,710
בדרך זו, 10 צעדים זה.

402
00:20:21,710 --> 00:20:23,644
אני כבר בבירור הפכתי את החתול לצפרדע.

403
00:20:23,644 --> 00:20:26,060
אז זה רק שם
תחפושת, כשיחות Scratch it-- אנחנו

404
00:20:26,060 --> 00:20:28,440
רק מיובאים תמונה של הצפרדע.

405
00:20:28,440 --> 00:20:29,570
>> אבל מה עוד קורה?

406
00:20:29,570 --> 00:20:32,794
מה קווים אחרים של קוד,
מה חתיכות פאזל אחרות

407
00:20:32,794 --> 00:20:35,460
עשה בלייק, בחור ההוראה שלנו,
להשתמש בתוכנית זו, כנראה?

408
00:20:35,460 --> 00:20:38,320

409
00:20:38,320 --> 00:20:42,730
מה עושה הכל move--
מה התכנות לבנות?

410
00:20:42,730 --> 00:20:44,950
>> Motion, sure-- כך
להזיז בלוק, בוודאות.

411
00:20:44,950 --> 00:20:49,330
ומה זה לחסום העבר
בתוך, קרוב לוודאי?

412
00:20:49,330 --> 00:20:52,850
כן, איזה לולאה, אולי
לנצח לחסום, אולי חזרה block--

413
00:20:52,850 --> 00:20:54,070
לחזור עד לחסום.

414
00:20:54,070 --> 00:20:57,330
וזה מה עושה את היומנים
חבצלות המים ואת מהלך כל השאר

415
00:20:57,330 --> 00:20:57,990
הלוך ושוב.

416
00:20:57,990 --> 00:21:00,270
זה פשוט קורה בלי סוף.

417
00:21:00,270 --> 00:21:03,180
>> מדוע חלק מהמכוניות
נע מהר יותר מהאחרים?

418
00:21:03,180 --> 00:21:06,607
מה שונה על תוכניות אלה?

419
00:21:06,607 --> 00:21:09,690
כן, כנראה חלק מהם נוטלים
צעדים יותר בו-זמנית וחלקם

420
00:21:09,690 --> 00:21:10,690
פחות שלבים בבת אחת.

421
00:21:10,690 --> 00:21:14,670
ואת האפקט החזותי
הוא מהיר לעומת איטי.

422
00:21:14,670 --> 00:21:16,030
>> מה אתה חושב שקרה?

423
00:21:16,030 --> 00:21:19,700
כשהגעתי הצפרדע שלי כל הדרך
מעבר לרחוב והנהר

424
00:21:19,700 --> 00:21:23,560
על כרית, משהו שושן
קרה ראוי לציון.

425
00:21:23,560 --> 00:21:26,540
מה קרה ברגע שעשיתי את זה?

426
00:21:26,540 --> 00:21:27,210
היא נעצרה.

427
00:21:27,210 --> 00:21:29,680
צפרדע זה נעצר,
קבלתי צפרדע שנייה.

428
00:21:29,680 --> 00:21:33,155
אז מה מבנה חייב להיות
השתמשו שם, מה מאפיין?

429
00:21:33,155 --> 00:21:36,020

430
00:21:36,020 --> 00:21:38,660
>> כן, אז יש איזשהו
"אם" להתנות שם למעלה, מדי.

431
00:21:38,660 --> 00:21:41,909
וזה הופך out-- לא ראינו זה-
אבל יש בלוקים אחרים שם

432
00:21:41,909 --> 00:21:45,300
ניתן לומר, אם אתה נוגע ללב
עוד דבר על המסך,

433
00:21:45,300 --> 00:21:47,720
אם אתה נוגע כרית שושן, "אז."

434
00:21:47,720 --> 00:21:50,810
ואז זה כשאנחנו
להפוך את הצפרדע השנייה להופיע.

435
00:21:50,810 --> 00:21:54,969
אז למרות המשחק הזה הוא בהחלט
מאוד מיום, למרות שבמבט ראשון

436
00:21:54,969 --> 00:21:58,010
יש כל כך הרבה קורה on-- ובלייק
לא להלהיב זאת בשתי דקות,

437
00:21:58,010 --> 00:22:00,390
זה בטח לקח לו כמה
שעות כדי ליצור את המשחק הזה

438
00:22:00,390 --> 00:22:03,850
מבוסס על זיכרון או סרטי הווידאו שלו
גרסה של פעם ממנו.

439
00:22:03,850 --> 00:22:07,940
אבל כל הדברים הקטנים האלה
הולך על המסך בבידוד

440
00:22:07,940 --> 00:22:11,550
להרתיח עד מאוד אלה פשוט
תנועות או הצהרות constructs--

441
00:22:11,550 --> 00:22:15,519
כמו שאמרנו, לולאות
תנאים, וזה על זה.

442
00:22:15,519 --> 00:22:17,060
יש כמה תכונות מגדלת אחרות.

443
00:22:17,060 --> 00:22:19,130
חלקם גרידא
אסתטי או אקוסטי,

444
00:22:19,130 --> 00:22:20,964
כמו הצלילים פשוט שיחקתי עם.

445
00:22:20,964 --> 00:22:23,380
אבל על פי רוב, אתה
יש ב Scratch השפה, זה,

446
00:22:23,380 --> 00:22:25,350
כל יסוד
אבני הבניין שאתה

447
00:22:25,350 --> 00:22:29,280
יש ב- C, Java, JavaScript,
PHP, Ruby, Python,

448
00:22:29,280 --> 00:22:32,960
וכל מספר בשפות אחרות.

449
00:22:32,960 --> 00:22:36,720
בכל שאלה אודות Scratch?

450
00:22:36,720 --> 00:22:37,220
בסדר.

451
00:22:37,220 --> 00:22:40,303
אז אנחנו לא לצלול עמוק יותר אל Scratch,
אם אתה מוזמן בסוף השבוע,

452
00:22:40,303 --> 00:22:42,860
במיוחד אם יש לך ילדים או
אחיינים כזה,

453
00:22:42,860 --> 00:22:44,220
כדי להציג בפניהם את Scratch.

454
00:22:44,220 --> 00:22:47,960
זהו בעצם להפליא שובבה
סביבה עם, כמו מחבריו לומר,

455
00:22:47,960 --> 00:22:49,120
תקרות גבוהות מאוד.

456
00:22:49,120 --> 00:22:51,670
למרות שהתחלנו עם
מאוד פרטים ברמה נמוכה,

457
00:22:51,670 --> 00:22:54,890
אתה באמת יכול לעשות לא מעט
עם זה, וזה אולי

458
00:22:54,890 --> 00:22:57,360
הפגנה של בדיוק את זה.

459
00:22:57,360 --> 00:23:02,920
>> אבל בואו עכשיו לעבור עוד קצת
בעיות מתוחכמות, אם תרצה,

460
00:23:02,920 --> 00:23:05,870
המכונה "המחפש '
"מיון" באופן כללי יותר.

461
00:23:05,870 --> 00:23:09,500
נאלצנו ספר הטלפון הזה earlier-- הנה
עוד אחד רק בשביל discussion--

462
00:23:09,500 --> 00:23:13,460
כי הצלחנו לחפש
ביעילות רבה יותר בגלל

463
00:23:13,460 --> 00:23:15,270
של הנחה משמעותית.

464
00:23:15,270 --> 00:23:17,655
ורק שיהיה ברור, מה
ההנחה הייתה שאני עושה

465
00:23:17,655 --> 00:23:19,280
בעת חיפוש באמצעות ספר הטלפון הזה?

466
00:23:19,280 --> 00:23:23,342

467
00:23:23,342 --> 00:23:25,300
זה מייק סמית הייתה
בספר הטלפונים, אם כי אני

468
00:23:25,300 --> 00:23:27,410
יהיה מסוגל להתמודד
התרחיש בלעדיו

469
00:23:27,410 --> 00:23:30,720
שם אם אני פשוט הפסקתי בטרם עת.

470
00:23:30,720 --> 00:23:31,806
הספר הוא אלפביתי.

471
00:23:31,806 --> 00:23:33,930
וזה מאוד נדיב
הנחה, כי

472
00:23:33,930 --> 00:23:36,580
פירושו someone-- אני קצת
חיתוך פינה,

473
00:23:36,580 --> 00:23:40,580
כאילו אני מהר כי מישהו
אחר עשה הרבה עבודה קשה בשבילי.

474
00:23:40,580 --> 00:23:43,120
>> אבל מה אם הטלפון
הספר היה ממוין?

475
00:23:43,120 --> 00:23:47,050
אולי Verizon יש עצלן, פשוט זרק
שמות ומספרים של כולם שם

476
00:23:47,050 --> 00:23:50,120
אולי את הסדר שבו הם
רשום לשירות הטלפון.

477
00:23:50,120 --> 00:23:54,570
וכמה זמן לוקח לי
למצוא מישהו כמו מייק סמית?

478
00:23:54,570 --> 00:23:58,160
1,000 טלפון דף book-- כמה
דפים אני צריך להסתכל דרך?

479
00:23:58,160 --> 00:23:58,905
>> כולם.

480
00:23:58,905 --> 00:24:00,030
אתה סוג של מזל.

481
00:24:00,030 --> 00:24:03,420
אתה ממש צריך להסתכל על כל
דף אם את ספר הטלפונים הוא רק

482
00:24:03,420 --> 00:24:04,450
מסודרים באופן אקראי.

483
00:24:04,450 --> 00:24:06,910
אתה עלול לקבל מזל למצוא מייק
בדף הראשון, כי הוא

484
00:24:06,910 --> 00:24:08,826
היה הלקוח הראשון
להורות שירות הטלפון.

485
00:24:08,826 --> 00:24:10,760
אבל יכול להיות שהוא היה אחרון, מדי.

486
00:24:10,760 --> 00:24:12,500
>> אז בסדר אקראי הוא לא טוב.

487
00:24:12,500 --> 00:24:16,750
אז נניח שיש לנו כדי למיין את
ספר טלפונים או בנתונים מסוג כלליים

488
00:24:16,750 --> 00:24:18,520
כי כבר קיבלנו.

489
00:24:18,520 --> 00:24:19,440
איך אנחנו יכולים לעשות את זה?

490
00:24:19,440 --> 00:24:21,360
>> ובכן, הרשו לי לנסות
דוגמא פשוטה כאן.

491
00:24:21,360 --> 00:24:24,290
תן לי להמשיך לזרוק
כמה מספרים על הלוח.

492
00:24:24,290 --> 00:24:35,480
תניח מספרים שיש לנו הם,
נניח, ארבע, שתיים, אחת, ושלוש.

493
00:24:35,480 --> 00:24:38,390
וגם, בן, למיין את המספרים האלה בשבילנו.

494
00:24:38,390 --> 00:24:39,017
>> בסדר, טוב.

495
00:24:39,017 --> 00:24:39,850
איך עשית את זה?

496
00:24:39,850 --> 00:24:42,731

497
00:24:42,731 --> 00:24:43,230
בסדר.

498
00:24:43,230 --> 00:24:44,710
אז להתחיל עם הקטן
ערך הגבוה ביותר,

499
00:24:44,710 --> 00:24:46,084
וזה באמת אינטואיציה טובה.

500
00:24:46,084 --> 00:24:48,080
וגם להבין שאנחנו כי
בני אדם הם בעצם די

501
00:24:48,080 --> 00:24:49,913
טוב לפתרון בעיות
ככה, לפחות

502
00:24:49,913 --> 00:24:51,810
כאשר הנתונים הם קטנים יחסית.

503
00:24:51,810 --> 00:24:54,860
ברגע שאתה מתחיל לקבל מאה
מספרים, אלף מספרים,

504
00:24:54,860 --> 00:24:58,440
מיליוני מספרים, בן כנראה
לא יכול לעשות את זה די מהר כי,

505
00:24:58,440 --> 00:25:00,620
בהנחה שיש
פערים המספרים.

506
00:25:00,620 --> 00:25:03,450
די קל לספור עד מיליון
אחרת, רק זמן רב.

507
00:25:03,450 --> 00:25:07,150
>> אז האלגוריתם שזה נשמע
כמו בן השתמש רק עכשיו

508
00:25:07,150 --> 00:25:08,930
החיפוש נערך אחרי המספר הקטן ביותר.

509
00:25:08,930 --> 00:25:12,900
אז למרות שאנחנו בני אדם יכול לקחת
ב הרבה מידע חזותי,

510
00:25:12,900 --> 00:25:14,830
מחשב הוא למעשה
קצת יותר מוגבל.

511
00:25:14,830 --> 00:25:17,560
המחשב יכול רק
להסתכל בית אחד בכל פעם

512
00:25:17,560 --> 00:25:20,770
או אולי ארבעה בתים בכל הבאה--
בימים אלה אולי 8 בתים בכל הבאה--

513
00:25:20,770 --> 00:25:24,450
אבל מספר קטן מאוד
של בתים בכל זמן נתון.

514
00:25:24,450 --> 00:25:28,480
>> כך שבהתחשב בכך שיש לנו באמת
ארבעה ערכים נפרדים כאן--

515
00:25:28,480 --> 00:25:32,440
ואתה יכול לחשוב על בן כבעל
סכי עיניים כאילו היה מחשב כזה

516
00:25:32,440 --> 00:25:36,450
כי הוא לא יכול לראות שום דבר אחר
ממספר אחד בכל הבאה--

517
00:25:36,450 --> 00:25:39,720
אז אנחנו בדרך כלל יהיה להניח, כמו
אנגלית, נצטרך לקרוא מימין לשמאל.

518
00:25:39,720 --> 00:25:42,870
אז את המספר הראשון בן כנראה נראה
בבית בן ארבע ואז מהר מאוד

519
00:25:42,870 --> 00:25:44,770
הבנתי שזה די גדול
number-- תן לי להמשיך לחפש.

520
00:25:44,770 --> 00:25:45,357
>> יש שני.

521
00:25:45,357 --> 00:25:45,940
חכה דקה.

522
00:25:45,940 --> 00:25:47,070
השני הוא קטן יותר מאשר ארבעה.

523
00:25:47,070 --> 00:25:47,986
אני הולך לזכור.

524
00:25:47,986 --> 00:25:49,070
שני עכשיו הקטן.

525
00:25:49,070 --> 00:25:50,417
עכשיו one-- זה אפילו טוב יותר.

526
00:25:50,417 --> 00:25:51,250
זה עוד יותר.

527
00:25:51,250 --> 00:25:54,000
אני הולך לשכוח שני
ופשוט לזכור אחד עכשיו.

528
00:25:54,000 --> 00:25:56,550
>> והוא יכול להפסיק להסתכל?

529
00:25:56,550 --> 00:25:58,360
טוב, הוא יכול מבוסס
על מידע זה,

530
00:25:58,360 --> 00:26:00,477
אבל כדאי לו חיפוש טוב יותר
שאר הרשימה.

531
00:26:00,477 --> 00:26:02,060
כי מה אם אפס היו ברשימה?

532
00:26:02,060 --> 00:26:03,643
מה אם אחד שלילי היו ברשימה?

533
00:26:03,643 --> 00:26:07,720
הוא רק יודע שתשובתו
נכון אם הוא ממצה

534
00:26:07,720 --> 00:26:08,729
בדוק את הרשימה כולה.

535
00:26:08,729 --> 00:26:10,020
אז נסתכל על שאר זה.

536
00:26:10,020 --> 00:26:11,394
שלוש-- כי היה בזבוז זמן.

537
00:26:11,394 --> 00:26:13,540
יש מזל, אבל אני הייתי
עדיין נכון לעשות זאת.

538
00:26:13,540 --> 00:26:17,857
אז עכשיו הוא כנראה
נבחר את המספר הקטן ביותר

539
00:26:17,857 --> 00:26:20,440
ופשוט לשים אותו בתחילה
הרשימה, כפי שאני אעשה כאן.

540
00:26:20,440 --> 00:26:23,480
עכשיו מה עשית הבא, למרות
אתה לא חושב על זה כמעט

541
00:26:23,480 --> 00:26:25,962
במידה זו?

542
00:26:25,962 --> 00:26:27,670
חזור על התהליך,
כך איזשהו לולאה.

543
00:26:27,670 --> 00:26:28,920
יש רעיון מוכר.

544
00:26:28,920 --> 00:26:30,860
אז הנה ארבעה.

545
00:26:30,860 --> 00:26:32,110
זה כרגע הקטן.

546
00:26:32,110 --> 00:26:33,220
זהו מועמד.

547
00:26:33,220 --> 00:26:33,900
לא עוד.

548
00:26:33,900 --> 00:26:34,770
עכשיו ראיתי שני.

549
00:26:34,770 --> 00:26:36,630
זהו האלמנט הבא הקטן ביותר.

550
00:26:36,630 --> 00:26:40,800
שלוש-- זה לא קטן, כל כך
עכשיו בן יכול לתלוש השניים.

551
00:26:40,800 --> 00:26:44,510
>> ועכשיו אנו חוזרים על התהליך,
כמובן שלוש מקבלים שלף הבא.

552
00:26:44,510 --> 00:26:45,420
חזור על התהליך.

553
00:26:45,420 --> 00:26:46,990
ארבעה מקבל שלף.

554
00:26:46,990 --> 00:26:50,140
ועכשיו אנחנו מחוץ מספרים,
כך הרשימה חייבת להיות מסודרת.

555
00:26:50,140 --> 00:26:51,960
>> ואכן, זהו אלגוריתם רשמי.

556
00:26:51,960 --> 00:26:56,610
מדען מחשב היה
קוראים לזה "מיון בחירה,"

557
00:26:56,610 --> 00:27:00,880
כשהרעיון הוא מעין סד
רשימת iteratively-- שוב

558
00:27:00,880 --> 00:27:03,807
ושוב ושוב בחירה
המספר הקטן ביותר.

559
00:27:03,807 --> 00:27:06,140
ומה שיפה זה
זה פשוט כל כך לעזאזל אינטואיטיבי.

560
00:27:06,140 --> 00:27:07,470
זה כל כך פשוט.

561
00:27:07,470 --> 00:27:11,100
ואתה יכול לחזור על אותו
פעולה שוב ושוב.

562
00:27:11,100 --> 00:27:12,150
זה פשוט.

563
00:27:12,150 --> 00:27:17,170
>> במקרה זה היה מהיר, אך
כמה זמן לוקח באמת?

564
00:27:17,170 --> 00:27:19,880
בואו נעשה את זה נראה ו
מרגיש קצת יותר משעמם.

565
00:27:19,880 --> 00:27:24,150
אז אחת, שתיים, שלוש, ארבע, חמש ושש,
שבע, שמונה, תשע, 10, 11, 12, 13, 14,

566
00:27:24,150 --> 00:27:26,160
15, 16-- מספר שרירותי.

567
00:27:26,160 --> 00:27:28,780
רציתי פשוט יותר זה
זמן מאשר רק ארבע.

568
00:27:28,780 --> 00:27:30,780
אז אם יש לי כל
חבורה של מספרים now-- זה

569
00:27:30,780 --> 00:27:32,420
אפילו לא משנה
מה הוא שהן-- בואו

570
00:27:32,420 --> 00:27:34,380
לחשוב על מה זה
האלגוריתם באמת כמו.

571
00:27:34,380 --> 00:27:35,857
>> נניח שיש מספרים שם.

572
00:27:35,857 --> 00:27:38,190
שוב, לא משנה מה
הם, אבל הם אקראיים.

573
00:27:38,190 --> 00:27:39,679
אני מיישם אלגוריתם של בן.

574
00:27:39,679 --> 00:27:41,220
אני צריך לבחור את המספר הקטן ביותר.

575
00:27:41,220 --> 00:27:41,761
מה אני עושה?

576
00:27:41,761 --> 00:27:44,240
ואני הולך פיזית
לעשות את זה הפעם כדי לעשות את זה.

577
00:27:44,240 --> 00:27:46,099
להסתכל, להסתכל,
להסתכל, להסתכל, להסתכל.

578
00:27:46,099 --> 00:27:48,140
רק שעד שאגיע
סוף הרשימה יכול

579
00:27:48,140 --> 00:27:51,230
אני מבין את הקטן
המספר היה שני פעם.

580
00:27:51,230 --> 00:27:52,720
אחת לא ברשימה.

581
00:27:52,720 --> 00:27:54,400
אז הנחתי את השנייה.

582
00:27:54,400 --> 00:27:55,590
>> מה עלי לעשות עכשיו?

583
00:27:55,590 --> 00:27:58,600
להסתכל, להסתכל, להסתכל, להסתכל.

584
00:27:58,600 --> 00:28:02,250
כעת מצאתי את המספר שבע, כי
יש פערים numbers-- אלה

585
00:28:02,250 --> 00:28:03,300
אבל רק שרירותי.

586
00:28:03,300 --> 00:28:03,800
בסדר.

587
00:28:03,800 --> 00:28:06,030
אז עכשיו אני יכול לשים למטה שבע.

588
00:28:06,030 --> 00:28:08,860
במבט להסתכל, להסתכל.

589
00:28:08,860 --> 00:28:11,030
>> עכשיו אני מניח, של
כמובן, כי בן לא

590
00:28:11,030 --> 00:28:14,780
יש RAM נוסף, תוספת
זיכרון, כי, כמובן,

591
00:28:14,780 --> 00:28:16,080
אני מסתכל על אותו המספר.

592
00:28:16,080 --> 00:28:18,246
אין ספק שיכולתי לזכור
כל המספרים האלה,

593
00:28:18,246 --> 00:28:19,930
וזה בהחלט נכון.

594
00:28:19,930 --> 00:28:22,610
אבל אם בן זוכר את כל
המספרים שהוא ראה,

595
00:28:22,610 --> 00:28:24,430
הוא לא באמת עשה
התקדמות יסוד

596
00:28:24,430 --> 00:28:26,170
כי כבר יש לו
היכולת לחפש

597
00:28:26,170 --> 00:28:27,540
דרך המספרים על הלוח.

598
00:28:27,540 --> 00:28:29,373
זוכר את כל
מספרים לא עוזרים,

599
00:28:29,373 --> 00:28:32,490
כי הוא יכול עדיין כמחשב
רק להסתכל, שאמרנו, מספר אחד

600
00:28:32,490 --> 00:28:33,080
בכל פעם.

601
00:28:33,080 --> 00:28:35,760
אז אין שום סוג של רמאי
שם כי אתה יכול למנף.

602
00:28:35,760 --> 00:28:39,170
>> אז במציאות, כפי שאני
להמשיך לחפש את הרשימה,

603
00:28:39,170 --> 00:28:44,200
אני ממש צריך פשוט להמשיך
הלוך ושוב דרך זה, תולש

604
00:28:44,200 --> 00:28:45,710
המספר הקטן הבא.

605
00:28:45,710 --> 00:28:48,810
וכפי שאתה יכול מעין להסיק
מהתנועות המטופשות שלי,

606
00:28:48,810 --> 00:28:50,860
זה רק נהיה מאוד
משעמם מאוד מהר,

607
00:28:50,860 --> 00:28:54,850
ואני נראה הולך הלוך
ושוב, הלוך ושוב לא מעט.

608
00:28:54,850 --> 00:29:03,220
עכשיו כדי להיות הוגן, אני לא צריך ללכת
כמו די, נו, בואו see-- להיות הוגן,

609
00:29:03,220 --> 00:29:06,310
אני לא צריך ללכת די
כמו רבים צעדים בכל פעם.

610
00:29:06,310 --> 00:29:09,200
זאת, כמובן, כפי שאני
לבחור מספרים מהרשימה,

611
00:29:09,200 --> 00:29:11,860
הרשימה הנותרת מתקצרת.

612
00:29:11,860 --> 00:29:14,240
>> וכך בואו נחשוב על
כמה צעדים אני בעצם

613
00:29:14,240 --> 00:29:16,010
לשוטט דרך בכל פעם.

614
00:29:16,010 --> 00:29:18,950
במצב הראשון
היו לנו 16 מספרים,

615
00:29:18,950 --> 00:29:22,210
וכך maximally-- בואו פשוט
עושה את זה בשביל discussion--

616
00:29:22,210 --> 00:29:25,640
הייתי צריך לחפש דרך 16
מספרים כדי למצוא את הקטן.

617
00:29:25,640 --> 00:29:28,420
אבל ברגע שאני ותלשתי
המספר הקטן ביותר, איך

618
00:29:28,420 --> 00:29:30,590
ארוכה היא רשימת הנותרים, כמובן?

619
00:29:30,590 --> 00:29:31,420
רק 15.

620
00:29:31,420 --> 00:29:34,670
אז כמה מספרים עשו בן או שאני צריך
להסתכל דרך בפעם השנייה?

621
00:29:34,670 --> 00:29:36,832
15, רק כדי ללכת ולמצוא את הקטן.

622
00:29:36,832 --> 00:29:39,540
אבל עכשיו, כמובן, הרשימה היא,
גם קטן ממה שהוא היה לפני.

623
00:29:39,540 --> 00:29:42,540
אז כמה צעדים עשו לי
יש לקחת בפעם הבאה?

624
00:29:42,540 --> 00:29:49,970
14 ואז 13 ואז 12, פלוס נקודה,
נקודה, נקודה, עד שאני נשאר רק עם אחד.

625
00:29:49,970 --> 00:29:53,146
אז עכשיו מדען מחשב היה
לשאול, ובכן, מה עושה את זה כולם שווה?

626
00:29:53,146 --> 00:29:55,770
זה בעצם מסתכם ב כ בטון
מספר שאנחנו יכולים בהחלט

627
00:29:55,770 --> 00:30:00,490
אריתמטית לעשות, אבל אנחנו רוצים לדבר
על היעילות של אלגוריתמים

628
00:30:00,490 --> 00:30:04,940
קצת יותר formulaically,
עצמאי של כמה זמן והרשימה.

629
00:30:04,940 --> 00:30:06,240
>> אז אתה יודע מה?

630
00:30:06,240 --> 00:30:09,860
זהו 16, אבל כמו שאמרתי קודם,
בואו פשוט נקרא את גודל הבעיה

631
00:30:09,860 --> 00:30:10,970
n, כאשר n הוא מספר כלשהו.

632
00:30:10,970 --> 00:30:13,220
אולי זה 16, אולי זה
שלושה, אולי זה מיליון.

633
00:30:13,220 --> 00:30:13,761
אֲנִי לֹא יוֹדֵעַ.

634
00:30:13,761 --> 00:30:14,390
לא אכפת לי.

635
00:30:14,390 --> 00:30:16,520
מה שאני באמת רוצה זה
נוסחה שאני יכול

636
00:30:16,520 --> 00:30:19,420
להשתמש בו כדי להשוות אלגוריתם זה
נגד אלגוריתמים אחרים

637
00:30:19,420 --> 00:30:22,350
כי מישהו עלול לטעון
הם לטוב ולרע.

638
00:30:22,350 --> 00:30:25,430
>> אז מתברר, ואני רק
יודע זה מבית הספר היסודי,

639
00:30:25,430 --> 00:30:34,790
כי זה בעצם פועל יוצא באותו
דבר כמו n מעל n פלוס אחד על פני השני.

640
00:30:34,790 --> 00:30:40,020
וזה קורה שווה, של
כמובן, n בריבוע פלוס n מעל השנייה.

641
00:30:40,020 --> 00:30:43,250
אז אם אני רוצה נוסחה
עבור כמה מדרגות

642
00:30:43,250 --> 00:30:46,330
היו מעורבים מחפש בכלל
של המספרים האלה שוב ושוב

643
00:30:46,330 --> 00:30:52,681
ושוב ושוב, הייתי אומר
זה n בריבוע פלוס n מעל השנייה.

644
00:30:52,681 --> 00:30:53,430
אבל אתה יודע מה?

645
00:30:53,430 --> 00:30:54,500
זה פשוט נראה מבולגן.

646
00:30:54,500 --> 00:30:56,470
אני פשוט באמת רוצה
תחושה כללית של דברים.

647
00:30:56,470 --> 00:30:58,810
ואתם עשויים להיזכר מ
בתיכון שיש

648
00:30:58,810 --> 00:31:00,660
הוא הרעיון של טווח מהמדרגה הראשונה.

649
00:31:00,660 --> 00:31:05,300
אילו תנאים אלה, את n
בריבוע, את n, או במחצית,

650
00:31:05,300 --> 00:31:07,550
יש את ההשפעה הגדולה ביותר על פני זמן?

651
00:31:07,550 --> 00:31:11,920
ה- N הגדול מקבל, אשר
בנושאים אלה הכי הרבה?

652
00:31:11,920 --> 00:31:15,560
>> במילים אחרות, אם אני מחבר
בעוד מיליון, n בריבוע

653
00:31:15,560 --> 00:31:17,900
הולך להיות ככל הנראה
הגורם הבולט,

654
00:31:17,900 --> 00:31:21,670
משום מיליון פעמים
עצמו הוא הרבה יותר גדול

655
00:31:21,670 --> 00:31:23,682
מ פלוס אחד נוסף מ'.

656
00:31:23,682 --> 00:31:24,390
אז אתה יודע מה?

657
00:31:24,390 --> 00:31:27,305
זהו המעצבן הזה כל כך גדול
מספר אם אתה לרבע מספר.

658
00:31:27,305 --> 00:31:28,430
זה לא ממש משנה.

659
00:31:28,430 --> 00:31:30,596
אנחנו פשוט הולכים צלב כי
מתוך ולשכוח ממנה.

660
00:31:30,596 --> 00:31:34,250
וכך מדען מחשב היה אומר
כי היעילות של האלגוריתם הזה

661
00:31:34,250 --> 00:31:37,850
הוא בסדר גודל של n squared--
אני מתכוון באמת קירוב.

662
00:31:37,850 --> 00:31:40,810
זה באמת קצת בערך n בריבוע.

663
00:31:40,810 --> 00:31:44,130
במשך הזמן, את גדולה
יותר ויותר n מקבל, זה

664
00:31:44,130 --> 00:31:47,610
היא אמידה טובה מה
יעיל או חוסר היעילות

665
00:31:47,610 --> 00:31:49,400
אלגוריתם זה הוא למעשה.

666
00:31:49,400 --> 00:31:52,040
ואני לגזור כי, כמובן,
מ ממש עושה את המתמטיקה.

667
00:31:52,040 --> 00:31:54,040
אבל עכשיו אני רק מנופף
הידיים שלי, כי אני פשוט

668
00:31:54,040 --> 00:31:55,790
רוצה תחושה כללית של אלגוריתם זה.

669
00:31:55,790 --> 00:31:58,850
>> אז עם אותו ההיגיון, בינתיים,
הבה נבחן אלגוריתם אחר

670
00:31:58,850 --> 00:32:01,162
אנחנו כבר נראינו at-- חיפוש ליניארי.

671
00:32:01,162 --> 00:32:02,870
כאשר חיפשתי
עבור הטלפון book--

672
00:32:02,870 --> 00:32:05,980
לא מיון, חיפוש
דרך הטלפון book--

673
00:32:05,980 --> 00:32:09,197
אנחנו כל הזמן אמר שזה היה
1,000 צעדים, או 500 צעדים.

674
00:32:09,197 --> 00:32:10,280
אבל בואו להכליל את זה.

675
00:32:10,280 --> 00:32:12,860
אם יש n עמודים
בספר הטלפונים, מה

676
00:32:12,860 --> 00:32:17,250
הזמן רץ או
היעילות של חיפוש ליניארי?

677
00:32:17,250 --> 00:32:19,750
זה בסדר גודל של
כמה צעדים כדי למצוא

678
00:32:19,750 --> 00:32:24,210
מייק סמית באמצעות חיפוש ליניארי,
אלגוריתם ראשון, או אפילו שני?

679
00:32:24,210 --> 00:32:27,240

680
00:32:27,240 --> 00:32:31,710
>> במקרה הגרוע ביותר, מייק
הוא בסוף הספר.

681
00:32:31,710 --> 00:32:35,590
אז אם את ספר הטלפונים יש 1,000 דפים,
אמרנו בפעם האחרונה, במקרה הגרוע,

682
00:32:35,590 --> 00:32:38,380
זה עלול לקחת בערך איך
דפים רבים כדי למצוא מייק?

683
00:32:38,380 --> 00:32:38,990
כמו 1,000.

684
00:32:38,990 --> 00:32:39,830
זה חסם עליון.

685
00:32:39,830 --> 00:32:41,790
זהו המצב הגרוע ביותר האפשרי.

686
00:32:41,790 --> 00:32:44,410
אבל שוב, אנחנו מתרחקים
ממספרים כמו 1,000 עכשיו.

687
00:32:44,410 --> 00:32:45,730
זה פשוט n.

688
00:32:45,730 --> 00:32:47,470
>> אז מה המסקנה ההגיונית?

689
00:32:47,470 --> 00:32:50,210
מציאת מייק בטלפון
ספר שיש בו דפי n

690
00:32:50,210 --> 00:32:55,280
עלול לקחת, במקרה הגרוע ביותר,
כמה צעדים בסדר גודל של n?

691
00:32:55,280 --> 00:32:58,110
ואכן מחשב
מדען יגיד

692
00:32:58,110 --> 00:33:02,340
כי הזמן פועל, או
ביצועים או היעיל

693
00:33:02,340 --> 00:33:07,470
או חוסר יעילות, של אלגוריתם כמו
חיפוש ליניארי הוא בסדר גודל של n.

694
00:33:07,470 --> 00:33:10,010
ואנחנו יכולים להחיל אותו
ההיגיון של חציית משהו

695
00:33:10,010 --> 00:33:13,170
כמו פשוט עשיתי את השני
אלגוריתם שקיימנו עם ספר טלפונים,

696
00:33:13,170 --> 00:33:16,040
לאן הלכנו שני עמודים בכל פעם.

697
00:33:16,040 --> 00:33:20,120
>> אז 1,000 דף בספר טלפונים אולי
לקחת אותנו 500 פניות דף, ועוד אחד

698
00:33:20,120 --> 00:33:21,910
אם נכפיל קצת אחורה.

699
00:33:21,910 --> 00:33:26,590
אז אם בספר טלפונים יש דפי n, אבל
אנחנו עושים שני עמודים בכל פעם,

700
00:33:26,590 --> 00:33:28,900
זה פחות או יותר מה?

701
00:33:28,900 --> 00:33:33,190
N מעל השנייה, אז זה כמו n מעל השנייה.

702
00:33:33,190 --> 00:33:38,490
אבל אני עשיתי את התביעה
רגע לפני כי n מעל two--

703
00:33:38,490 --> 00:33:41,060
זה סוג של זהה רק n.

704
00:33:41,060 --> 00:33:44,050
זה פשוט גורם קבוע,
מדעני מחשב יגידו.

705
00:33:44,050 --> 00:33:45,970
בואו רק להתמקד
המשתנים, באמת--

706
00:33:45,970 --> 00:33:47,780
המשתנים הגדולים במשוואה.

707
00:33:47,780 --> 00:33:52,530
>> אז ליניארי חיפוש, בין אם נעשה אחד
דף אחד בכל פעם או שני עמודים בכל פעם,

708
00:33:52,530 --> 00:33:54,810
מעין ביסודו זהה.

709
00:33:54,810 --> 00:33:56,880
זה עדיין בסדר גודל של n.

710
00:33:56,880 --> 00:34:01,930
אבל טענתי עם התמונה שלי קודם לכן
כי האלגוריתם השלישי לא היה

711
00:34:01,930 --> 00:34:02,480
ליניארי.

712
00:34:02,480 --> 00:34:03,605
זה לא היה קו ישר.

713
00:34:03,605 --> 00:34:08,659
זה היה קו עקום, ואת
נוסחה אלגברית היה מה?

714
00:34:08,659 --> 00:34:11,812
יומן של n-- כך בסיס לוגריתם שניים n.

715
00:34:11,812 --> 00:34:14,520
ואנחנו לא צריכים להיכנס מדי
בפירוט רב על לוגריתמים היום,

716
00:34:14,520 --> 00:34:17,394
אבל רוב מדעני מחשב לא היו
אפילו להגיד לך מה הוא הבסיס.

717
00:34:17,394 --> 00:34:20,639
בגלל שזה הכול
גורמים קבועים, כביכול,

718
00:34:20,639 --> 00:34:22,659
רק הבדלים מספריים קלים.

719
00:34:22,659 --> 00:34:31,179
וכך זה יהיה מאוד נפוץ
דרך מחשב רשמי במיוחד

720
00:34:31,179 --> 00:34:33,949
מדעני קרש או
מתכנת על לוח לבן

721
00:34:33,949 --> 00:34:36,889
למעשה בטענה אשר
אלגוריתם הם ישתמשו

722
00:34:36,889 --> 00:34:39,500
או מה את היעילות
של האלגוריתם שלהם הוא.

723
00:34:39,500 --> 00:34:42,960
>> וזה לא בהכרח משהו
אתה לדון בכל בפירוט רב,

724
00:34:42,960 --> 00:34:47,889
אבל מתכנת טוב הוא מישהו
יש להם רקע מוצק, פורמלית.

725
00:34:47,889 --> 00:34:50,120
הוא מסוגל לדבר
אתה בסוג זה של הדרך

726
00:34:50,120 --> 00:34:53,350
ולמעשה להפוך
טיעונים איכותיים כמו

727
00:34:53,350 --> 00:34:56,870
מדוע אלגוריתם אחד או
חתיכה אחת של תוכנה

728
00:34:56,870 --> 00:35:00,165
עדיפה באופן כלשהו למשנהו.

729
00:35:00,165 --> 00:35:02,540
כי אתה יכול בהחלט
רק להפעיל תוכנית של אדם אחד

730
00:35:02,540 --> 00:35:04,980
ולספור את מספר השניות
שנדרש כדי למיין כמה מספרים,

731
00:35:04,980 --> 00:35:06,710
ואתה יכול להריץ כמה
התוכנית של האדם האחר

732
00:35:06,710 --> 00:35:08,418
ולספור את המספר
שניות שלוקח.

733
00:35:08,418 --> 00:35:12,840
אבל זו היא דרך כללית יותר
אתה יכול להשתמש בו כדי לנתח אלגוריתמים,

734
00:35:12,840 --> 00:35:15,520
אם תרצו, רק על
נייר או רק באופן מילולי.

735
00:35:15,520 --> 00:35:18,430
אפילו בלי מפעיל אותו, ללא
אפילו מנסה תשומות מדגם,

736
00:35:18,430 --> 00:35:20,180
אתה פשוט יכול לדבר בהיגיון דרכו.

737
00:35:20,180 --> 00:35:24,670
וכך עם שכירת מפתח או אם
שיש לו או לה מעין להתווכח איתך

738
00:35:24,670 --> 00:35:28,460
למה האלגוריתם שלהם, סודם
רוטב לחיפוש מיליארדים

739
00:35:28,460 --> 00:35:30,580
של דפי אינטרנט עבור שלך
חברה טובה יותר, אלה

740
00:35:30,580 --> 00:35:33,302
הם סוגים של טיעונים שהם
אידיאלי צריך להיות מסוגל לעשות.

741
00:35:33,302 --> 00:35:35,010
או לפחות אלה
את מיני דברים

742
00:35:35,010 --> 00:35:40,211
כי היו ניגשים בדיון, ב
לפחות בדיון רשמי מאוד.

743
00:35:40,211 --> 00:35:40,710
בסדר.

744
00:35:40,710 --> 00:35:44,400
אז הבן הציע משהו
קרא מיון בחירה.

745
00:35:44,400 --> 00:35:48,200
אבל אני הולך להציע כי יש
דרכים אחרות לעשות את זה, מדי.

746
00:35:48,200 --> 00:35:50,400
מה עשיתי לא באמת אוהב
על האלגוריתם של בן

747
00:35:50,400 --> 00:35:54,400
הוא המשיך ללכת, או
לאחר לי ללכת, קדימה ואחורה

748
00:35:54,400 --> 00:35:56,930
ו הלוך ושוב הלוך ושוב.

749
00:35:56,930 --> 00:36:04,130
מה אם במקום הייתי עושה
משהו כמו המספרים האלה כאן

750
00:36:04,130 --> 00:36:08,200
ואני היינו רק כדי להתמודד עם כל
מספר בתורו כמו שאני מקבל את זה?

751
00:36:08,200 --> 00:36:10,780
>> במילים אחרות, הנה
רשימת המספרים שלי.

752
00:36:10,780 --> 00:36:12,944
ארבעה, אחד, שלוש, שתיים.

753
00:36:12,944 --> 00:36:14,360
ואני הולך לעשות את הדברים הבאים.

754
00:36:14,360 --> 00:36:17,230
אני הולך להכניס את המספרים
לאן הוא שייך למדי

755
00:36:17,230 --> 00:36:18,980
מ בחירתן אחד בכל פעם.

756
00:36:18,980 --> 00:36:20,820
במילים אחרות, והנה המספר ארבע.

757
00:36:20,820 --> 00:36:22,430
>> הנה הרשימה המקורית שלי.

758
00:36:22,430 --> 00:36:25,290
ואני הולך לשמור
בעצם רשימה חדשה כאן.

759
00:36:25,290 --> 00:36:26,710
אז זוהי הרשימה הישנה.

760
00:36:26,710 --> 00:36:28,560
זוהי הרשימה החדשה.

761
00:36:28,560 --> 00:36:30,220
אני רואה את מספר ארבע הראשונות.

762
00:36:30,220 --> 00:36:34,500
הרשימה החדשה שלי היא בתחילה ריקה,
אז זה טריוויאלי במקרה

763
00:36:34,500 --> 00:36:36,410
ארבעה, כי הוא עלה מגוון רחב של רשימה עכשיו.

764
00:36:36,410 --> 00:36:39,560
אני רק לוקח את המספר אני נתון,
ואני לשים אותו ברשימה החדשה שלי.

765
00:36:39,560 --> 00:36:41,460
>> ממוינת על רשימה חדשה זו?

766
00:36:41,460 --> 00:36:41,990
כֵּן.

767
00:36:41,990 --> 00:36:45,090
זה טיפשי כי יש רק אחד
אלמנט, אבל זה מסודר לחלוטין.

768
00:36:45,090 --> 00:36:46,390
אין שום דבר מחוץ למקום.

769
00:36:46,390 --> 00:36:49,290
זה יותר מעניין, אלגוריתם זה,
כשאני לעבור לשלב הבא.

770
00:36:49,290 --> 00:36:50,550
>> עכשיו אני צריך אחד.

771
00:36:50,550 --> 00:36:55,430
אז אחד, כמובן, שייך לעבר
בתחילתו או בסופו של רשימה חדשה זו?

772
00:36:55,430 --> 00:36:56,360
ההתחלה.

773
00:36:56,360 --> 00:36:58,530
אז אני צריך לעשות קצת עבודה עם חברה.

774
00:36:58,530 --> 00:37:01,410
הייתי לוקח כמה
חירויות בטוש שלי

775
00:37:01,410 --> 00:37:03,120
רק על ידי ציור דברים
איפה אני רוצה מהם,

776
00:37:03,120 --> 00:37:05,320
אבל זה לא באמת
מדויק מחשב.

777
00:37:05,320 --> 00:37:08,530
מחשב, כפי שאנו מכירים, יש
RAM, או זיכרון גישה אקראית,

778
00:37:08,530 --> 00:37:12,411
וזה בית אחד
אחר בייט ו בייט אחר.

779
00:37:12,411 --> 00:37:14,910
ואם יש לך ג'יגה
RAM, יש לך מיליארד בייטים,

780
00:37:14,910 --> 00:37:16,680
אבל הם פיזית במיקום אחד.

781
00:37:16,680 --> 00:37:19,540
אתה לא יכול פשוט להזיז דברים מסביב
על ידי ציור אותו על הלוח

782
00:37:19,540 --> 00:37:20,750
לאן שאתה רוצה.

783
00:37:20,750 --> 00:37:24,090
אז אם הרשימה החדשה שלי יש
ארבעה מקומות בזיכרון,

784
00:37:24,090 --> 00:37:27,480
לצערי הארבעה הם
כבר במקום הלא נכון.

785
00:37:27,480 --> 00:37:30,410
>> אז להכניס את מספר אחד
אני לא יכול פשוט לצייר אותו כאן.

786
00:37:30,410 --> 00:37:31,901
מיקום הזיכרון הזה לא קיים.

787
00:37:31,901 --> 00:37:35,150
זה יהיה בוגד, ואני כבר
רמאות ציורית במשך כמה דקות

788
00:37:35,150 --> 00:37:35,800
כאן.

789
00:37:35,800 --> 00:37:40,950
אז באמת, אם אני רוצה לשים אחד כאן,
אני צריך להעתיק באופן זמני את הארבעה

790
00:37:40,950 --> 00:37:43,030
ואז לשים את אחד שם.

791
00:37:43,030 --> 00:37:45,500
>> זה בסדר גמור, זה נכון,
זה אפשרי מבחינה טכנית,

792
00:37:45,500 --> 00:37:48,410
אבל מבין שזו עבודה נוספת.

793
00:37:48,410 --> 00:37:50,460
לא פשוט לשים את המספר במקום.

794
00:37:50,460 --> 00:37:53,026
ראשית אני חייב להעביר
מספר, ואז לשים אותו במקום,

795
00:37:53,026 --> 00:37:54,650
אז אני סוג של הוכפל כמות העבודה שלי.

796
00:37:54,650 --> 00:37:55,660
אז לזכור את זה.

797
00:37:55,660 --> 00:37:57,120
>> אבל עכשיו אני גמרתי עם האלמנט הזה.

798
00:37:57,120 --> 00:37:59,056
עכשיו אני רוצה לתפוס את המספר שלוש.

799
00:37:59,056 --> 00:38:00,430
איפה, כמובן, אין זה שייך?

800
00:38:00,430 --> 00:38:01,480
בין לבין.

801
00:38:01,480 --> 00:38:03,650
אני לא יכול לרמות יותר
ופשוט לשים אותו שם,

802
00:38:03,650 --> 00:38:06,770
כי, שוב, זיכרון זה
נמצא מיקומים פיזיים.

803
00:38:06,770 --> 00:38:10,900
אז אני צריך להעתיק את הארבעה
ולשים את השלושה לכאן.

804
00:38:10,900 --> 00:38:11,550
לא סיפור גדול.

805
00:38:11,550 --> 00:38:14,610
זה רק עוד שלב אחד נוסף
again-- מרגיש מאוד זול.

806
00:38:14,610 --> 00:38:16,445
>> אבל עכשיו אני עובר השניים.

807
00:38:16,445 --> 00:38:17,820
השניים, כמובן, שייך לכאן.

808
00:38:17,820 --> 00:38:20,990
עכשיו אתה מתחיל לראות איך
העבודה יכולה להצטבר.

809
00:38:20,990 --> 00:38:23,520
עכשיו מה אני צריך לעשות?

810
00:38:23,520 --> 00:38:28,570
כן, אני צריך להזיז את הארבעה,
אז אני צריך להעתיק את השלוש,

811
00:38:28,570 --> 00:38:31,200
ועכשיו אני יכול להכניס את השנייה.

812
00:38:31,200 --> 00:38:34,460
ואת תופסת עם זה
אלגוריתם, מעניין מספיק,

813
00:38:34,460 --> 00:38:41,050
כי הוא מניח שיש לנו יותר קיצוני
במקרה איפה זה יניח שמונה, שבע,

814
00:38:41,050 --> 00:38:45,150
שש, חמש, ארבע, שלוש, שתיים, אחת.

815
00:38:45,150 --> 00:38:49,450
זהו, בהקשרים רבים,
במקרה הגרוע ביותר,

816
00:38:49,450 --> 00:38:51,570
כי את הדבר המעצבן הזה
הוא ממש אחורה.

817
00:38:51,570 --> 00:38:53,670
>> זה לא ממש
להשפיע האלגוריתם של בן,

818
00:38:53,670 --> 00:38:55,940
כי הבחירה של בן
סוג שהוא מתכוון להמשיך

819
00:38:55,940 --> 00:38:58,359
הלוך ושוב עובר הרשימה.

820
00:38:58,359 --> 00:39:01,150
ומפני שהוא תמיד חיפש
דרך הרשימה הנותרים כולו,

821
00:39:01,150 --> 00:39:02,858
זה לא משנה
שלושת היסודות נפרדים.

822
00:39:02,858 --> 00:39:05,630
אבל במקרה הזה עם ההחדרה שלי
approach-- בואו ננסה את זה.

823
00:39:05,630 --> 00:39:08,616
>> אז אחת, שתיים, שלוש, ארבע,
חמש, שש, שבע, שמונה.

824
00:39:08,616 --> 00:39:11,630
אחת שתיים שלוש ארבע,
חמש, שש, שבע, שמונה.

825
00:39:11,630 --> 00:39:14,320
אני הולך לקחת את שמונה,
והיכן אפשר לשים אותו?

826
00:39:14,320 --> 00:39:17,260
ובכן, בתחילה ברשימה שלי,
כי הרשימה החדשה הזו ממוינת.

827
00:39:17,260 --> 00:39:18,760
וגם אני מוחק את זה.

828
00:39:18,760 --> 00:39:20,551
>> איפה אני יכול לשים את שבע?

829
00:39:20,551 --> 00:39:21,050
לעזאזל.

830
00:39:21,050 --> 00:39:23,174
זה צריך ללכת לשם, כל כך
אני צריך לעשות קצת העתקה.

831
00:39:23,174 --> 00:39:26,820

832
00:39:26,820 --> 00:39:28,480
ועכשיו השבעה הולכים כאן.

833
00:39:28,480 --> 00:39:29,860
עכשיו אני לעבור השש.

834
00:39:29,860 --> 00:39:30,980
עכשיו זה אפילו יותר עבודה.

835
00:39:30,980 --> 00:39:32,570
>> שמונה צריכים ללכת כאן.

836
00:39:32,570 --> 00:39:33,920
יש שבע ללכת כאן.

837
00:39:33,920 --> 00:39:35,450
עכשיו בשישה יכולים ללכת כאן.

838
00:39:35,450 --> 00:39:37,950
עכשיו אני תופס את החמש.

839
00:39:37,950 --> 00:39:40,560
עכשיו שמונה צריך ללכת
כאן, שבע יש ללכת כאן,

840
00:39:40,560 --> 00:39:43,650
יש שש ללכת כאן,
עכשיו בחמש וחזור.

841
00:39:43,650 --> 00:39:46,610
ואני פחות או יותר
הזזתו ללא הרף.

842
00:39:46,610 --> 00:39:52,950
>> אז בסוף, algorithm-- זה נציג
קוראים לזה הכניסה sort-- למעשה

843
00:39:52,950 --> 00:39:55,020
יש הרבה עבודה, מדי.

844
00:39:55,020 --> 00:39:56,970
זה פשוט שונה
סוג של עבודה מאשר בן של.

845
00:39:56,970 --> 00:40:00,090
עבודתו של בן הייתה לי הולך
הלוך ושוב כל הזמן,

846
00:40:00,090 --> 00:40:03,510
בחירת הבא הקטן ביותר
אלמנט שוב ​​ושוב.

847
00:40:03,510 --> 00:40:06,660
אז זה היה סוג מאוד ויזואלית זה של עבודה.

848
00:40:06,660 --> 00:40:10,600
>> אלגוריתם אחר זה, אשר עדיין
correct-- זה יקבל את העבודה done--

849
00:40:10,600 --> 00:40:12,800
רק משנה את כמות העבודה.

850
00:40:12,800 --> 00:40:15,420
נראה בתחילה אתה
חיסכון, כי אתה פשוט

851
00:40:15,420 --> 00:40:19,190
התמודדות עם כל רכיב
מלפנים ללא הליכה כל

852
00:40:19,190 --> 00:40:20,930
הדרך דרך הרשימה כמו הבן הייתה.

853
00:40:20,930 --> 00:40:25,300
אבל הבעיה היא, במיוחד אלה
במקרים מטורפים שיש בו רק לאחור,

854
00:40:25,300 --> 00:40:27,830
אתה פשוט סוג של
דחיית העבודה הקשה

855
00:40:27,830 --> 00:40:30,360
עד שאתה צריך לתקן את הטעויות שלך.

856
00:40:30,360 --> 00:40:33,919
>> ולכן אם אתה יכול לדמיין את זה
שמונה ושבע ושישה וחמישה

857
00:40:33,919 --> 00:40:36,710
וכעבור ארבעה ושלושה ושני
נע דרכם דרך הרשימה,

858
00:40:36,710 --> 00:40:39,060
רק שינינו את
סוג העבודה שאנחנו עושים.

859
00:40:39,060 --> 00:40:42,340
במקום לעשות את זה בבית
תחילת איטרציה שלי,

860
00:40:42,340 --> 00:40:45,250
אני פשוט עושה את זה בבית
בסוף כל איטרציה.

861
00:40:45,250 --> 00:40:50,550
אז מתברר כי אלגוריתם זה,
מדי, מיון הכנסה שנקרא בדרך כלל,

862
00:40:50,550 --> 00:40:52,190
גם הוא בסדר גודל של n בריבוע.

863
00:40:52,190 --> 00:40:56,480
זה בעצם לא יותר טוב,
לא טוב בכלל.

864
00:40:56,480 --> 00:41:00,810
>> עם זאת, יש גישה שלישית
הייתי ממליץ לפתחנו,

865
00:41:00,810 --> 00:41:02,970
וזה זה.

866
00:41:02,970 --> 00:41:07,850
אז תניח ברשימה שלי, לפשטות
שוב, ארבעה, שנה, שלוש,

867
00:41:07,850 --> 00:41:11,080
two-- רק ארבעה מספרים.

868
00:41:11,080 --> 00:41:13,300
בן היה אינטואיציה טובה,
אינטואיציה אנושית טובה

869
00:41:13,300 --> 00:41:16,340
לפני, שבאמצעותו אנו תיקנו את כולו
רשימת eventually-- מיון הכנסה.

870
00:41:16,340 --> 00:41:18,020
אני שידל יחד איתנו.

871
00:41:18,020 --> 00:41:22,530
אבל הבה נבחן את
הדרך הפשוטה ביותר לתקן רשימה זו.

872
00:41:22,530 --> 00:41:24,110
>> רשימה זו אינה מסודרת.

873
00:41:24,110 --> 00:41:26,130
למה?

874
00:41:26,130 --> 00:41:31,920
באנגלית, להסביר מדוע
זה לא מסודר למעשה.

875
00:41:31,920 --> 00:41:33,400
מה זה אומר להיות מסודר לא?

876
00:41:33,400 --> 00:41:34,220
>> סטודנט: זה לא רציף.

877
00:41:34,220 --> 00:41:34,990
>> DAVID מלאן: לא רציף.

878
00:41:34,990 --> 00:41:35,822
תן לי דוגמה.

879
00:41:35,822 --> 00:41:37,180
>> סטודנט: שים אותם לפי סדר.

880
00:41:37,180 --> 00:41:37,440
>> DAVID מלאן: אישור.

881
00:41:37,440 --> 00:41:38,790
תן לי דוגמה ספציפית יותר.

882
00:41:38,790 --> 00:41:39,832
>> סטודנט: עולה סדר.

883
00:41:39,832 --> 00:41:41,206
DAVID מלאן: לא עולה.

884
00:41:41,206 --> 00:41:42,100
ליתר דיוק.

885
00:41:42,100 --> 00:41:45,190
אני לא יודע למה אתה מתכוון על ידי עולה.

886
00:41:45,190 --> 00:41:47,150
מה לא בסדר?

887
00:41:47,150 --> 00:41:49,930
>> סטודנט: הקטן של
מספרים לא במרחב הראשון.

888
00:41:49,930 --> 00:41:51,140
>> DAVID מלאן: המספר הקטן ביותר של
לא במרחב הראשון.

889
00:41:51,140 --> 00:41:52,120
תהיה יותר ספציפי.

890
00:41:52,120 --> 00:41:55,000
אני מתחיל לתפוס.

891
00:41:55,000 --> 00:41:59,470
אנו אתה סומך, אבל
מה מקולקל כאן?

892
00:41:59,470 --> 00:42:00,707
>> סטודנט: רצף נומרית.

893
00:42:00,707 --> 00:42:02,040
DAVID מלאן: רצף נומרית.

894
00:42:02,040 --> 00:42:04,248
סוג של כולם של שמירה
זה כאן-- ברמה גבוהה מאוד.

895
00:42:04,248 --> 00:42:07,450
רק ממש לספר לי מה
בסדר כמו כוח חמש-בת.

896
00:42:07,450 --> 00:42:08,310
>> סטודנט: פלוס אחד.

897
00:42:08,310 --> 00:42:08,750
>> DAVID מלאן: מה זה?

898
00:42:08,750 --> 00:42:09,610
>> סטודנט: פלוס אחד.

899
00:42:09,610 --> 00:42:11,235
>> DAVID מלאן: למה אתה מתכוון אחד ועוד?

900
00:42:11,235 --> 00:42:12,754

901
00:42:12,754 --> 00:42:14,170
תן לי חמש-בת שונה.

902
00:42:14,170 --> 00:42:16,840

903
00:42:16,840 --> 00:42:18,330
מה לא בסדר, אמא?

904
00:42:18,330 --> 00:42:19,940
מה לא בסדר, אבא?

905
00:42:19,940 --> 00:42:22,808
למה אתה מתכוון זה לא מסודר?

906
00:42:22,808 --> 00:42:24,370
>> סטודנט: זה לא המקום הנכון.

907
00:42:24,370 --> 00:42:25,580
>> DAVID מלאן: מה
לא במקום הנכון?

908
00:42:25,580 --> 00:42:26,174
>> סטודנט: ארבעה.

909
00:42:26,174 --> 00:42:27,090
DAVID מלאן: מניח את הדעת, טוב.

910
00:42:27,090 --> 00:42:29,110
אז ארבעה הם לא איפה שהוא צריך להיות.

911
00:42:29,110 --> 00:42:30,590
בפרט, היא זכות זו?

912
00:42:30,590 --> 00:42:33,000
ארבעה ואחד, הראשון
שני מספרים אני רואה.

913
00:42:33,000 --> 00:42:34,930
האם זה נכון?

914
00:42:34,930 --> 00:42:36,427
לא, הם מקולקלים, נכון?

915
00:42:36,427 --> 00:42:38,135
למעשה, חושב עכשיו
על מחשב, מדי.

916
00:42:38,135 --> 00:42:40,824
זה יכול רק להסתכל אולי אחד,
אולי שני דברים בבת once--

917
00:42:40,824 --> 00:42:43,240
ולמעשה רק דבר אחד
בכל פעם, אבל היא יכולה לפחות

918
00:42:43,240 --> 00:42:45,790
להסתכל דבר אחד ואז
הדבר הבא ממש ליד זה.

919
00:42:45,790 --> 00:42:47,380
>> אז הם אלה כדי?

920
00:42:47,380 --> 00:42:48,032
ברור שלא.

921
00:42:48,032 --> 00:42:48,740
אז אתה יודע מה?

922
00:42:48,740 --> 00:42:51,020
למה שלא ניקח תינוק
צעדים לתיקון בעיה זו

923
00:42:51,020 --> 00:42:53,410
במקום לעשות כלים יקרים
אלגוריתמים כמו בן, שם

924
00:42:53,410 --> 00:42:56,440
הוא די לתקן את זה על ידי
looping דרך הרשימה

925
00:42:56,440 --> 00:42:59,670
במקום לעשות את מה שעשיתי, שם
אני פשוט סוג של קבוע זה כמו שאנחנו הולכים?

926
00:42:59,670 --> 00:43:03,650
בואו פשוט ממש לשבור את
הרעיון של סדר מספרי order--,

927
00:43:03,650 --> 00:43:06,990
לקרוא לזה איך שאתה want--
אל השוואות pairwise אלה.

928
00:43:06,990 --> 00:43:07,590
>> ארבע ואחד.

929
00:43:07,590 --> 00:43:09,970
האם זה בסדר הנכון?

930
00:43:09,970 --> 00:43:11,310
אז בואו לתקן את זה.

931
00:43:11,310 --> 00:43:14,700
אחד וארבעה, ולאחר מכן
אנחנו פשוט להעתיק את זה.

932
00:43:14,700 --> 00:43:15,560
בסדר, טוב.

933
00:43:15,560 --> 00:43:17,022
תיקנתי אחת לארבע.

934
00:43:17,022 --> 00:43:18,320
שלוש ושני?

935
00:43:18,320 --> 00:43:18,820
לא.

936
00:43:18,820 --> 00:43:21,690
תן את המילים שלי להתאים את אצבעותי.

937
00:43:21,690 --> 00:43:23,695
ארבעה ושלושה?

938
00:43:23,695 --> 00:43:27,930
>> זה לא בסדר, אז אני הולך
לעשות אחד, שלוש, ארבע, שתיים.

939
00:43:27,930 --> 00:43:28,680
בסדר, טוב.

940
00:43:28,680 --> 00:43:32,310
עכשיו ארבע ושנתיים?

941
00:43:32,310 --> 00:43:33,370
אנחנו צריכים לתקן את זה, מדי.

942
00:43:33,370 --> 00:43:36,700
אז אחד, שלוש, שתיים, ארבע.

943
00:43:36,700 --> 00:43:39,820
אז הוא זה מסודר?

944
00:43:39,820 --> 00:43:43,170
לא, אבל זה קרוב יותר מסודר?

945
00:43:43,170 --> 00:43:48,930
>> זה, כי סידרנו זה
טעות, סידרנו את הטעות הזאת,

946
00:43:48,930 --> 00:43:50,370
וקבענו את הטעות הזאת.

947
00:43:50,370 --> 00:43:52,420
אז סידרנו שלוש טעויות לטעון.

948
00:43:52,420 --> 00:43:58,100
עדיין לא ממש נראה ממוין, אבל
היא קרובה באופן אובייקטיבי מיון

949
00:43:58,100 --> 00:44:00,080
כי סידרנו כמה טעויות אלה.

950
00:44:00,080 --> 00:44:02,047
>> עכשיו מה עלי לעשות עכשיו?

951
00:44:02,047 --> 00:44:03,630
אני די הגעתי לסוף הרשימה.

952
00:44:03,630 --> 00:44:05,680
הרגשתי שאין לי קבוע
כל הטעויות, אבל לא.

953
00:44:05,680 --> 00:44:08,510
כי במקרה הזה, כמה מספרים
אולי מבעבע קרוב

954
00:44:08,510 --> 00:44:10,410
למספרי אחרים
עדיין מקולקל.

955
00:44:10,410 --> 00:44:12,951
אז בואו נעשה את זה שוב, ואני
פשוט לעשות את זה במקום הפעם.

956
00:44:12,951 --> 00:44:14,170
אחת ושלוש?

957
00:44:14,170 --> 00:44:14,720
זה בסדר.

958
00:44:14,720 --> 00:44:16,070
שלוש ושני?

959
00:44:16,070 --> 00:44:17,560
כמובן לא, אז בואו לשנות את זה.

960
00:44:17,560 --> 00:44:19,160
אז שתיים, שלוש.

961
00:44:19,160 --> 00:44:21,340
שלושה וארבעה?

962
00:44:21,340 --> 00:44:24,370
ועכשיו בואו פשוט להיות
במיוחד קפדן כאן.

963
00:44:24,370 --> 00:44:26,350
האם זה מסודר?

964
00:44:26,350 --> 00:44:29,280
אתה האדם יודע שזה מסודר.

965
00:44:29,280 --> 00:44:30,400
>> אני צריך לנסות שוב.

966
00:44:30,400 --> 00:44:31,900
אז אוליביה מציעה אני מנסה שוב.

967
00:44:31,900 --> 00:44:32,530
למה?

968
00:44:32,530 --> 00:44:35,810
בגלל מחשב אין
את המותרות של העין האנושית שלנו

969
00:44:35,810 --> 00:44:38,080
רק מציץ back-- אישור, סיימתי.

970
00:44:38,080 --> 00:44:41,610
איך מפעילים את המחשב לקבוע
כי הרשימה ממוינת עכשיו?

971
00:44:41,610 --> 00:44:44,590
מבחינה מכנית.

972
00:44:44,590 --> 00:44:47,650
>> אני צריכה לעבור
פעם נוספת, ורק אם אני

973
00:44:47,650 --> 00:44:51,190
לא עושה / למצוא טעויות אני יכול
אז להסיק כמו המחשב, כן,

974
00:44:51,190 --> 00:44:51,980
אנחנו טוב ללכת.

975
00:44:51,980 --> 00:44:54,850
אז אחד ושני, שתיים
שלוש, שלוש וארבע.

976
00:44:54,850 --> 00:44:58,030
עכשיו אני בוודאות יכול להגיד את זה הוא
לא מסודר, כי עשיתי שינויים.

977
00:44:58,030 --> 00:45:01,940
עכשיו זה יהיה באג ופשוט
אם היא טיפשה בעיני, המחשב,

978
00:45:01,940 --> 00:45:05,640
שאל אותם שאלות שוב
מצפה תשובות שונות.

979
00:45:05,640 --> 00:45:07,110
לא צריך לקרות.

980
00:45:07,110 --> 00:45:08,600
>> אז עכשיו הרשימה ממוינת.

981
00:45:08,600 --> 00:45:12,630
למרבה הצער, זמן ריצה של
אלגוריתם זה גם N בריבוע.

982
00:45:12,630 --> 00:45:13,130
למה?

983
00:45:13,130 --> 00:45:19,520
בגלל שיש לך מספרים n, וב
במקרה הגרוע ביותר אתה צריך להזיז מספרי n

984
00:45:19,520 --> 00:45:23,637
n פעמים כי אתה צריך להמשיך
חזרה לבדוק ואפשרות לתקן

985
00:45:23,637 --> 00:45:24,220
המספרים האלה.

986
00:45:24,220 --> 00:45:26,280
ואנחנו יכולים לעשות יותר
ניתוח פורמלי, מדי.

987
00:45:26,280 --> 00:45:29,530
>> אז זה כל מה לומר שנקטנו
שלוש גישות שונות, אחד

988
00:45:29,530 --> 00:45:32,210
מהם מיד אינטואיטיבי
עטלף מבן

989
00:45:32,210 --> 00:45:35,170
הרכבתן שאני מציע
מהסוג הזה

990
00:45:35,170 --> 00:45:38,540
שבו אתה סוג של לאבד
את היער מרוב העצים בתחילה.

991
00:45:38,540 --> 00:45:41,760
אבל אז אם אתה לוקח צעד אחורה,
וואלה, שיפצנו את הרעיון מיון.

992
00:45:41,760 --> 00:45:43,824
אז זה, מעז לומר,
רמה נמוכה יותר אולי

993
00:45:43,824 --> 00:45:45,740
מאשר כמה מאותם אחרים
אלגוריתמים, אבל בואו

994
00:45:45,740 --> 00:45:48,550
נראה אם ​​אנחנו לא יכולים לדמיין
אלה בדרך של זה.

995
00:45:48,550 --> 00:45:51,450
>> אז זה קצת נחמד
תוכנה שמישהו

996
00:45:51,450 --> 00:45:56,110
כתב באמצעות מוטות צבעוניות זה
הולך לעשות עבורנו את הדברים כדלקמן.

997
00:45:56,110 --> 00:45:57,736
כל הברים האלה מייצגים מספר.

998
00:45:57,736 --> 00:46:00,026
Taller הבר, גדול
את המספר, בר קטן,

999
00:46:00,026 --> 00:46:00,990
קטן מספר.

1000
00:46:00,990 --> 00:46:05,880
אז באופן אידיאלי נרצה פירמידה נחמדת
איפה זה מתחיל קטן ומקבל גדול,

1001
00:46:05,880 --> 00:46:08,330
וזה היה אומר
ברים אלה מסודרים.

1002
00:46:08,330 --> 00:46:11,200
אז אני הולך קדימה, לבחור,
למשל, האלגוריתם של בן

1003
00:46:11,200 --> 00:46:13,990
מיון בחירה הראשון--.

1004
00:46:13,990 --> 00:46:16,220
>> ושימו לב מה הוא עושה.

1005
00:46:16,220 --> 00:46:18,670
הדרך שהם בחרו
לדמיין אלגוריתם זה

1006
00:46:18,670 --> 00:46:22,090
הוא, בדיוק כמו שאני
הליכה דרך ברשימה שלי,

1007
00:46:22,090 --> 00:46:24,710
תוכנית זו היא הליכה
באמצעות רשימת המספרים שלה,

1008
00:46:24,710 --> 00:46:28,160
הדגשה בוורוד כל
מספר כי הוא מסתכל.

1009
00:46:28,160 --> 00:46:32,360
ומה עומד לקרות עכשיו?

1010
00:46:32,360 --> 00:46:35,154
>> המספר הקטן ביותר כי
אני או בן גילו לפתע

1011
00:46:35,154 --> 00:46:36,820
מקבל עבר לתחילת הרשימה.

1012
00:46:36,820 --> 00:46:40,037
והודעה שעשה לפנות
מספר כי היה שם,

1013
00:46:40,037 --> 00:46:41,120
וזה בסדר גמור.

1014
00:46:41,120 --> 00:46:42,600
לא להיכנס לזה רמת הפירוט.

1015
00:46:42,600 --> 00:46:44,308
אבל אנחנו צריכים לשים
כי מספר איפשהו,

1016
00:46:44,308 --> 00:46:47,775
אז אנחנו פשוט עברנו אותו
מקום פתוח שנוצר.

1017
00:46:47,775 --> 00:46:49,900
אז אני הולך להאיץ זו
עד, כי אחר זה

1018
00:46:49,900 --> 00:46:51,871
הופך להיות מאוד משעמם במהירות.

1019
00:46:51,871 --> 00:46:55,800

1020
00:46:55,800 --> 00:46:58,600
אנימציה speed-- שם אנחנו הולכים.

1021
00:46:58,600 --> 00:47:01,850
אז עכשיו אותו עיקרון
אנסה להתקבל, אבל אתה

1022
00:47:01,850 --> 00:47:06,540
יכול להתחיל להרגיש את האלגוריתם, אם אתה
יהיה, או לראות את זה בצורה קצת יותר ברור.

1023
00:47:06,540 --> 00:47:13,190
אלגוריתם זה יש השפעה של
בחירת היסוד הקטן הבא,

1024
00:47:13,190 --> 00:47:16,422
אז אתה הולך להתחיל
לראות את זה יעלה מהשמאל.

1025
00:47:16,422 --> 00:47:19,130
ועל כל איטרציה, כפי שאני
מוצע, הוא עושה עבודה קצת פחות.

1026
00:47:19,130 --> 00:47:21,921
זה לא חייב ללכת עד הסוף
בחזרה אל הקצה השמאלי של הרשימה,

1027
00:47:21,921 --> 00:47:23,900
כי זה כבר
יודעים אלה מסודרים.

1028
00:47:23,900 --> 00:47:28,129
אז זה סוג של מרגיש כאילו זה
מאיץ, למרות כל צעד הוא

1029
00:47:28,129 --> 00:47:29,420
לוקח את אותה כמות של זמן.

1030
00:47:29,420 --> 00:47:31,600
יש רק פחות שלבים הנותרים.

1031
00:47:31,600 --> 00:47:35,240
ועכשיו אתה יכול סוג של לחוש
האלגוריתם לנקות את סוף הסיפור,

1032
00:47:35,240 --> 00:47:37,040
ואכן עכשיו זה מסודר.

1033
00:47:37,040 --> 00:47:41,620
>> אז מיון הכנסה הוא הכל נעשה.

1034
00:47:41,620 --> 00:47:43,600
אני צריך מחדש באקראי המערך.

1035
00:47:43,600 --> 00:47:45,940
ושימו לב שאני יכול רק
לשמור אקראי זה,

1036
00:47:45,940 --> 00:47:50,630
ונקבל קירוב
באותה גישה, מיון הכנסה.

1037
00:47:50,630 --> 00:47:55,050
תן לי להאט אותה לכאן.

1038
00:47:55,050 --> 00:47:56,915
נתחיל כי למעלה.

1039
00:47:56,915 --> 00:47:57,414
תפסיק.

1040
00:47:57,414 --> 00:48:00,662

1041
00:48:00,662 --> 00:48:02,410
>> בואו לדלג ארבע.

1042
00:48:02,410 --> 00:48:03,200
הנה.

1043
00:48:03,200 --> 00:48:04,190
בחר באקראי המערך הם.

1044
00:48:04,190 --> 00:48:05,555
וכאן אנו go-- מיון הכנסה.

1045
00:48:05,555 --> 00:48:10,260

1046
00:48:10,260 --> 00:48:12,800
לְשַׂחֵק.

1047
00:48:12,800 --> 00:48:17,280
שימו לב כי זה להתמודד עם כל
אלמנט הוא נתקל מיד,

1048
00:48:17,280 --> 00:48:20,282
אבל אם זה שייך
ההודעה במקום הלא נכון

1049
00:48:20,282 --> 00:48:21,740
כל העבודה שחייבת להתרחש.

1050
00:48:21,740 --> 00:48:24,700
אנחנו צריכים לשמור על הפניית חלק גדול יותר
ועוד אלמנטים כדי לפנות מקום

1051
00:48:24,700 --> 00:48:27,340
עבור אחד אנחנו רוצים לשים במקום.

1052
00:48:27,340 --> 00:48:30,740
>> אז אנחנו מתמקדים
בקצה השמאלי של הרשימה בלבד.

1053
00:48:30,740 --> 00:48:34,460
שם לב שאנחנו אפילו לא הסתכלנו at-- אנחנו
לא מודגש דבר ורוד

1054
00:48:34,460 --> 00:48:35,610
לימין.

1055
00:48:35,610 --> 00:48:38,180
אנחנו פשוט להתמודד עם
הבעיות כמו שאנחנו הולכים,

1056
00:48:38,180 --> 00:48:40,430
אבל אנחנו יוצרים הרבה
לעבוד עבור עצמנו עדיין.

1057
00:48:40,430 --> 00:48:44,410
וכך אם אנו לזרז את זה
עכשיו ללכת עד להשלמתו,

1058
00:48:44,410 --> 00:48:46,210
יש לו תחושה שונה אליו באמת.

1059
00:48:46,210 --> 00:48:50,150
זה רק התמקדות בקצה השמאלי אבל
עושה קצת יותר עבודה כמו needed--

1060
00:48:50,150 --> 00:48:53,230
סוג של דברים חלקים
מעל, לתקן דברים,

1061
00:48:53,230 --> 00:48:58,350
אלא יודע להתמודד בסופו של דבר עם
כל רכיב אחד בכל פעם

1062
00:48:58,350 --> 00:49:07,740
עד שנגיע אולי-- טוב, אנחנו
כולם יודעים איך זה הולך להיגמר,

1063
00:49:07,740 --> 00:49:09,700
כך שזה משעמם מעט אולי.

1064
00:49:09,700 --> 00:49:12,830
>> אבל הרשימה end--
spoiler-- הולך להיות מסודר.

1065
00:49:12,830 --> 00:49:15,300
אז בואו נסתכל על איזה אחד אחרון.

1066
00:49:15,300 --> 00:49:16,840
אנחנו לא יכולים פשוט לדלג כעת.

1067
00:49:16,840 --> 00:49:18,000
אנחנו כמעט שם.

1068
00:49:18,000 --> 00:49:19,980
נשארו לנו עוד שניים, אחד ללכת.

1069
00:49:19,980 --> 00:49:22,680
וזהו.

1070
00:49:22,680 --> 00:49:23,450
מְעוּלֶה.

1071
00:49:23,450 --> 00:49:27,220
>> אז עכשיו בואו נעשים אחד אחד אחרון,
מחדש באופן אקראי עם מיון בועות.

1072
00:49:27,220 --> 00:49:31,690
ושימו לב כאן, במיוחד אם אני מאט זה
למטה, זה לשמור צוללים לאורך.

1073
00:49:31,690 --> 00:49:36,830
אבל שם לב רק זה גורם pairwise
מיין comparisons-- של פתרונות מקומיים.

1074
00:49:36,830 --> 00:49:39,050
אבל ברגע שנגיע
סוף הרשימה בורוד,

1075
00:49:39,050 --> 00:49:40,690
מה הולך צריך לקרות שוב?

1076
00:49:40,690 --> 00:49:44,539

1077
00:49:44,539 --> 00:49:46,830
כן, זה הולך צריך
להתחיל מחדש, כי זה רק

1078
00:49:46,830 --> 00:49:49,870
טעויות pairwise קבועות.

1079
00:49:49,870 --> 00:49:53,120
וזה אולי חשף עדיין לאחרים.

1080
00:49:53,120 --> 00:49:58,950
וכך אם אתה לזרז את זה, אתה תהיה
לראות את זה, הרבה כפי שרומז השם,

1081
00:49:58,950 --> 00:50:01,870
קטן elements-- או ליתר דיוק,
elements-- הגדול מתחיל

1082
00:50:01,870 --> 00:50:03,740
לבעבע עד לקצה, אם תרצו.

1083
00:50:03,740 --> 00:50:07,380
ואת האלמנטים הקטנים הם
החל לבעבע למטה משמאל.

1084
00:50:07,380 --> 00:50:10,780
ואכן, זה סוג של
את האפקט החזותי גם כן.

1085
00:50:10,780 --> 00:50:17,150
וכך זה יהיה בסופו של דבר מסיים
בצורה דומה מאוד, מדי.

1086
00:50:17,150 --> 00:50:19,160
>> אין לנו להתעכב
על זה במיוחד.

1087
00:50:19,160 --> 00:50:21,010
הרשו לי לפתוח את זה עכשיו, מדי.

1088
00:50:21,010 --> 00:50:24,040
יש כמה אלגוריתמים מיון אחרים
בעולם, כמה מהם

1089
00:50:24,040 --> 00:50:25,580
נלכדים כאן.

1090
00:50:25,580 --> 00:50:29,960
ובעיקר ללומדים שאינם
בהכרח חזותי או מתמטי,

1091
00:50:29,960 --> 00:50:31,930
כפי שעשינו בעבר, אנחנו יכולים
גם לעשות זאת audially

1092
00:50:31,930 --> 00:50:34,210
אם אנו מקשרים צליל עם זה.

1093
00:50:34,210 --> 00:50:36,990
ובדיוק בשביל הכיף, הנה
אלגוריתמים שונים כמה,

1094
00:50:36,990 --> 00:50:40,950
ואחד מהם בפרט שאתה
ישים לב נקרא "מיון מיזוג."

1095
00:50:40,950 --> 00:50:43,250
>> זהו למעשה מן היסוד
אלגוריתם טוב יותר,

1096
00:50:43,250 --> 00:50:45,860
כך מיון מיזוג, אחד
אלה שאתה עומד לראות,

1097
00:50:45,860 --> 00:50:49,170
לא הוא בסדר גודל של n בריבוע.

1098
00:50:49,170 --> 00:50:57,280
זה בסדר גודל של n פעמים להיכנס של
n, שהוא למעשה קטן ובכך

1099
00:50:57,280 --> 00:50:58,940
מהר יותר מאשר שלושת האחרים.

1100
00:50:58,940 --> 00:51:00,670
ויש כמה אחרים
אלה טיפשיים שנראה.

1101
00:51:00,670 --> 00:51:01,933
>> אז הנה אנחנו מתחילים עם צליל מסוים.

1102
00:51:01,933 --> 00:51:06,620

1103
00:51:06,620 --> 00:51:10,490
זהו מיון הכנסה, אז שוב
זה רק התמודדות עם איתני הטבע

1104
00:51:10,490 --> 00:51:13,420
כפי שהם באים.

1105
00:51:13,420 --> 00:51:17,180
זהו מעין בועה, אז זה
בהתחשב אותם זוגות בכל פעם.

1106
00:51:17,180 --> 00:51:22,030

1107
00:51:22,030 --> 00:51:24,490
ושוב, האלמנטים הגדולים
מבעבע עד לקצה.

1108
00:51:24,490 --> 00:51:38,098

1109
00:51:38,098 --> 00:51:41,710
>> הבא למעלה מיון בחירה.

1110
00:51:41,710 --> 00:51:45,420
זהו האלגוריתם של בן, שם
שוב הוא בחירת איטרטיבי

1111
00:51:45,420 --> 00:51:46,843
היסוד הקטן הבא.

1112
00:51:46,843 --> 00:51:49,801

1113
00:51:49,801 --> 00:51:53,900
ושוב, עכשיו אתה באמת יכול לשמוע
זה זירוז אבל רק במידה

1114
00:51:53,900 --> 00:51:58,230
כפי שהוא עושה פחות ופחות
לעבוד על כל איטרציה.

1115
00:51:58,230 --> 00:52:04,170
זהו מהר אחד, מיון מיזוג,
אשר מיון אשכולות של מספרים

1116
00:52:04,170 --> 00:52:05,971
יחד ולאחר מכן ומשלב אותם.

1117
00:52:05,971 --> 00:52:07,720
אז תראה-- שמאל
חצי כבר ממוין.

1118
00:52:07,720 --> 00:52:14,165
>> עכשיו זה מיון החצי הימני, ו
עכשיו זה הולך לשלב אותם לתוך אחד.

1119
00:52:14,165 --> 00:52:19,160
זהו משהו שנקרא "מיין Gnome."

1120
00:52:19,160 --> 00:52:23,460
ואתה סוג יכול של לראות כי
זה הולך הלוך ושוב,

1121
00:52:23,460 --> 00:52:27,950
תיקון עבודה קצת פה
שם ולפני שימשיך לעבודה חדשה.

1122
00:52:27,950 --> 00:52:32,900

1123
00:52:32,900 --> 00:52:33,692
וזה הכל.

1124
00:52:33,692 --> 00:52:36,400
יש סוג אחר, שהוא
באמת רק למטרות אקדמיות,

1125
00:52:36,400 --> 00:52:40,980
בשם "מטופש," אשר לוקח
הנתונים שלך, ממיין אותו באקראי,

1126
00:52:40,980 --> 00:52:43,350
ואז בודק אם הוא מסודר.

1127
00:52:43,350 --> 00:52:47,880
ואם זה לא, זה מחדש ממיין אותו
באופן אקראי, בודק אם הוא מסודר,

1128
00:52:47,880 --> 00:52:49,440
ואם לא חוזר.

1129
00:52:49,440 --> 00:52:52,660
ו בתיאוריה, ההסתברות
זה ישלים,

1130
00:52:52,660 --> 00:52:54,140
אבל אחרי לא מעט זמן.

1131
00:52:54,140 --> 00:52:56,930
זה לא הכי
יעיל של אלגוריתמים.

1132
00:52:56,930 --> 00:53:02,550
אז שאלות על אלה
אלגוריתמים או משהו מסוימים

1133
00:53:02,550 --> 00:53:04,720
הקשורים גם שם?

1134
00:53:04,720 --> 00:53:09,430
>> ובכן, בואו עכשיו ניסינו להפריד מה כל
שורות אלה כי אני כבר ציור

1135
00:53:09,430 --> 00:53:15,090
ומה אני מניח את המחשב
יכול לעשות מתחת למכסה המנוע.

1136
00:53:15,090 --> 00:53:18,650
ברצוני לטעון כי כל המספרים האלה
אני כל הזמן drawing-- שהם צריכים לקבל

1137
00:53:18,650 --> 00:53:21,330
מאוחסן במקום כלשהו בזיכרון.

1138
00:53:21,330 --> 00:53:24,130
נצטרך להיפטר הבחור הזה עכשיו, מדי.

1139
00:53:24,130 --> 00:53:30,110
>> אז פיסת זיכרון בבית
computer-- כך RAM DIMM הוא

1140
00:53:30,110 --> 00:53:35,480
מה שחיפשנו אתמול, כפול
זיכרון פנימי module-- נראה כך.

1141
00:53:35,480 --> 00:53:39,370
וכל אחד שבבי השחורים הקטנים האלה
כמה מספר הבתים הוא, בדרך כלל.

1142
00:53:39,370 --> 00:53:44,380
ואז פיני הזהב הם כמו
חוטים שמחברים אותו למחשב,

1143
00:53:44,380 --> 00:53:47,521
ואת לוח סיליקון הירוק הוא רק
מה שמחזיק הכל הכל ביחד.

1144
00:53:47,521 --> 00:53:48,770
אז מה זה באמת אומר?

1145
00:53:48,770 --> 00:53:53,180
אם אני סוג של לצייר תמונה ממש,
הבה נניח לפשטות

1146
00:53:53,180 --> 00:53:55,280
כי DIMM זה, כפול
מודול זיכרון פנימי,

1147
00:53:55,280 --> 00:54:00,530
ג'יגה של זיכרון RAM אחד הוא, אחד ג'יגה של
הזיכרון, וכך הכולל בתים רבים?

1148
00:54:00,530 --> 00:54:02,100
ג'יגה אחת היא כמה בתים?

1149
00:54:02,100 --> 00:54:04,860

1150
00:54:04,860 --> 00:54:06,030
יותר מזה.

1151
00:54:06,030 --> 00:54:09,960
1,124 הוא קילו, 1,000.

1152
00:54:09,960 --> 00:54:11,730
מגה מיליון.

1153
00:54:11,730 --> 00:54:14,570
גיגה הוא מיליארדים.

1154
00:54:14,570 --> 00:54:15,070
>> אני משקר?

1155
00:54:15,070 --> 00:54:16,670
האם אנחנו יכולים אפילו לקרוא את התווית?

1156
00:54:16,670 --> 00:54:19,920
זהו למעשה 128
ג 'יגה בייט, אז זה יותר.

1157
00:54:19,920 --> 00:54:22,130
אבל נעמיד פנים זו
הוא רק ג'יגה אחד.

1158
00:54:22,130 --> 00:54:25,640
אז זה אומר שיש מיליארדים
בתים של זיכרון זמין לי

1159
00:54:25,640 --> 00:54:29,770
או 8 מיליארד ביטים, אבל אנחנו הולכים
לדבר במונחים של בתים עכשיו,

1160
00:54:29,770 --> 00:54:30,750
לנוע קדימה.

1161
00:54:30,750 --> 00:54:36,330
>> אז מה זה אומר הוא זה
אחד בייט, זה בייט אחר,

1162
00:54:36,330 --> 00:54:38,680
זה עוד בתים,
ואם אנחנו באמת רוצים

1163
00:54:38,680 --> 00:54:43,280
להיות ספציפי שנצטרך
לצייר מיליארד ריבועים קטנים.

1164
00:54:43,280 --> 00:54:44,320
אבל מה זה אומר?

1165
00:54:44,320 --> 00:54:46,420
ובכן, הרשו לי רק זום
ב על התמונה הזאת.

1166
00:54:46,420 --> 00:54:50,900
אם יש לי משהו שנראה
כמו עכשיו זה, זה ארבעה בתים.

1167
00:54:50,900 --> 00:54:53,710
>> וכך יכולתי לשים ארבעה מספרים כאן.

1168
00:54:53,710 --> 00:54:54,990
אחת שתיים שלוש ארבע.

1169
00:54:54,990 --> 00:55:00,170
או שאני יכול לשים ארבע אותיות או סימנים.

1170
00:55:00,170 --> 00:55:02,620
"היי!" יכול ללכת מכות על המקום,
כי כל אחד מהמכתבים,

1171
00:55:02,620 --> 00:55:04,370
שהזכרנו קודם לכן,
יכול להיות מיוצג

1172
00:55:04,370 --> 00:55:06,650
עם שמונה סיביות או ASCII או בייט.

1173
00:55:06,650 --> 00:55:09,370
אז במילים אחרות, אתה יכול
לשים 8 מיליארד דברים בפנים

1174
00:55:09,370 --> 00:55:11,137
של מקל אחד זה של זיכרון.

1175
00:55:11,137 --> 00:55:14,345
עכשיו מה זה אומר לשים את הדברים בחזרה
לגבות לגבות בזיכרון כזה?

1176
00:55:14,345 --> 00:55:17,330
זה מה מתכנת
ייקרא "מערך."

1177
00:55:17,330 --> 00:55:21,250
בשנת תוכנת מחשב, אתה לא חושב
אודות החומרה הבסיסית, כשלעצמה.

1178
00:55:21,250 --> 00:55:24,427
אתה רק חושב על עצמך כבעל
גישה סך מיליארד בייטים,

1179
00:55:24,427 --> 00:55:26,010
ואתה יכול כל דבר שאתה רוצה עם זה.

1180
00:55:26,010 --> 00:55:27,880
אבל מטעמי נוחות
זה בדרך כלל שימושי

1181
00:55:27,880 --> 00:55:31,202
כדי לשמור על זכות הזיכרון שלך
אחד ליד השני ככה.

1182
00:55:31,202 --> 00:55:33,660
אז אם אני להתמקד על זה-
בגלל שאנחנו בהחלט לא הולכים

1183
00:55:33,660 --> 00:55:39,310
לצייר squares-- מעט מיליארד
הבה נניח כי הלוח הזה מייצג

1184
00:55:39,310 --> 00:55:40,610
עכשיו מקל הזיכרון.

1185
00:55:40,610 --> 00:55:43,800
ואני רק אצייר רב ככל שלי
סמן בסופו נותן לי כאן.

1186
00:55:43,800 --> 00:55:46,420

1187
00:55:46,420 --> 00:55:52,300
אז עכשיו יש לנו מקל
של זיכרון על הלוח

1188
00:55:52,300 --> 00:55:56,400
כי יש אחד, שניים, שלושה, ארבעה, חמישה,
שש, אחת, שתיים, שלוש, ארבע, חמש, שש,

1189
00:55:56,400 --> 00:56:01,130
seven-- כך 42 בתים של
זיכרון על סך המסך.

1190
00:56:01,130 --> 00:56:01,630
תודה רבה לך.

1191
00:56:01,630 --> 00:56:02,838
כן, עשיתי חישוב נכון.

1192
00:56:02,838 --> 00:56:05,120
אז 42 בתים של זיכרון כאן.

1193
00:56:05,120 --> 00:56:06,660
אז מה זה בעצם אומר?

1194
00:56:06,660 --> 00:56:09,830
ובכן, מתכנת מחשבים
היה למעשה בדרך כלל

1195
00:56:09,830 --> 00:56:12,450
לחשוב על הזיכרון הזה כמו למיעון.

1196
00:56:12,450 --> 00:56:16,630
במילים אחרות, כל אחד מאלה
מקומות בזיכרון, בחומרה,

1197
00:56:16,630 --> 00:56:18,030
יש כתובת ייחודית.

1198
00:56:18,030 --> 00:56:22,020
>> זה לא מורכב כמו אחת ברטל
כיכר, קיימברידג ', מסצ'וסטס., 02138.

1199
00:56:22,020 --> 00:56:23,830
במקום זאת, זה רק מספר.

1200
00:56:23,830 --> 00:56:27,930
זהו מספר בתי אפס, זה
אחד, זה יהיה שני דירקטורים, זה שלוש,

1201
00:56:27,930 --> 00:56:30,327
וזה 41.

1202
00:56:30,327 --> 00:56:30,910
חכה דקה.

1203
00:56:30,910 --> 00:56:32,510
חשבתי אמרתי 42 לפני רגע.

1204
00:56:32,510 --> 00:56:35,050

1205
00:56:35,050 --> 00:56:37,772
התחלתי לספור על אפס,
אז זה בעצם נכון.

1206
00:56:37,772 --> 00:56:40,980
עכשיו אנחנו לא באמת צריכים לצייר אותו
כמו רשת, ואם אתה מצייר את זה בצורת גריד

1207
00:56:40,980 --> 00:56:43,520
אני חושב דברים ממש
לקבל קצת מטעה.

1208
00:56:43,520 --> 00:56:46,650
איזה מתכנת היה,
במוחו או שלה,

1209
00:56:46,650 --> 00:56:50,310
מקובל לחשוב על זה
הזיכרון הוא בדיוק כמו קלטת,

1210
00:56:50,310 --> 00:56:53,340
כמו חתיכת סרט מיסוך
כי רק נמשך ונמשך לנצח

1211
00:56:53,340 --> 00:56:54,980
או עד שאתה נגמר הזיכרון.

1212
00:56:54,980 --> 00:56:59,200
אז דרך מקובלת יותר לצייר
ופשוט לחשוב על זיכרון

1213
00:56:59,200 --> 00:57:03,710
יהיה שזהו בייט אפס, אחד,
שתיים, שלוש, ולאחר מכן נקודה, נקודה, נקודה.

1214
00:57:03,710 --> 00:57:07,650
ויש לך 42 בתים כאלה בסך הכל, אפילו
אם פיזית זה באמת עשוי

1215
00:57:07,650 --> 00:57:09,480
להיות משהו יותר כמו זה.

1216
00:57:09,480 --> 00:57:12,850
>> אז אם אתה מוכן אפילו לחשוב על שלך
הזיכרון הזה, בדיוק כמו קלטת,

1217
00:57:12,850 --> 00:57:17,640
זה מה מתכנת שוב
יקרא מערך של הזיכרון.

1218
00:57:17,640 --> 00:57:20,660
וכאשר אתה רוצה באמת לאחסן
משהו בזיכרון של המחשב,

1219
00:57:20,660 --> 00:57:23,290
אתה עושה בדרך כלל דברים בחנות
גב אל גב אל גב-אל-גב.

1220
00:57:23,290 --> 00:57:25,010
אז אנחנו כבר מדברים על מספרים.

1221
00:57:25,010 --> 00:57:30,880
וכאשר רציתי לפתור בעיות
כמו ארבע, אחת, שלוש, שתיים,

1222
00:57:30,880 --> 00:57:33,820
למרות שאני רק ציור
רק המספרים ארבעה, שנה, שלוש,

1223
00:57:33,820 --> 00:57:39,490
שני על הלוח, המחשב יוכל
באמת יש התקנה זו בזיכרון.

1224
00:57:39,490 --> 00:57:43,347
>> ומה יהיה ליד
שני בזיכרון המחשב?

1225
00:57:43,347 --> 00:57:44,680
ובכן, אין תשובה לזה.

1226
00:57:44,680 --> 00:57:45,770
אנחנו לא באמת יודעים.

1227
00:57:45,770 --> 00:57:48,200
וכך עוד
המחשב לא צריך את זה,

1228
00:57:48,200 --> 00:57:51,440
זה לא צריך היה אכפת לי מה הוא בא
למספרים שהיא עושה אכפת.

1229
00:57:51,440 --> 00:57:55,130
וכשאני אמרתי מוקדם יותר כי מחשב
אפשר להסתכל רק בכתובת אחת בכל פעם,

1230
00:57:55,130 --> 00:57:56,170
זה סוג של למה.

1231
00:57:56,170 --> 00:57:59,490
>> לא כל כך שונה שיא
שחקן וראש קריאה

1232
00:57:59,490 --> 00:58:03,030
רק להיות מסוגל להסתכל על בטוח
חריץ שיא אסכולה ישנה פיזי

1233
00:58:03,030 --> 00:58:06,500
בכל פעם, באופן דומה
יכולה מחשב תודה

1234
00:58:06,500 --> 00:58:09,810
למעבד שלה שלה
סט פקוד אינטל,

1235
00:58:09,810 --> 00:58:12,480
בין שאת ההוראה
הוא לקריאה מהזיכרון

1236
00:58:12,480 --> 00:58:15,590
או לשמור memory--
מחשב יכול רק להסתכל

1237
00:58:15,590 --> 00:58:19,210
במיקום אחד בכל הבאה--
לפעמים שילוב שלהם,

1238
00:58:19,210 --> 00:58:21,770
אבל באמת רק במקום אחד בכל פעם.

1239
00:58:21,770 --> 00:58:24,770
לכן, כאשר אנחנו עושים
אלה אלגוריתמים שונים,

1240
00:58:24,770 --> 00:58:28,110
אני רק לא כותב בתוך
vacuum-- ארבע, אחת, שלוש, שתיים.

1241
00:58:28,110 --> 00:58:30,849
המספרים האלה בעצם שייכים
איפשהו פיזי בזיכרון.

1242
00:58:30,849 --> 00:58:32,890
אז יש קטנטן
טרנזיסטורים או איזשהו

1243
00:58:32,890 --> 00:58:35,840
אלקטרוניקה מתחת
מכסה המנוע לאחסון ערכים אלה.

1244
00:58:35,840 --> 00:58:40,460
>> ובסך הכל, כמה ביטים הם
מעורב עכשיו, רק כדי להיות ברור?

1245
00:58:40,460 --> 00:58:45,580
אז זהו ארבעה בתים, או
עכשיו זה 32 סיבי הכולל.

1246
00:58:45,580 --> 00:58:49,280
אז למעשה יש 32 אפסים
אלה להלחין ארבעה דברים אלה.

1247
00:58:49,280 --> 00:58:52,070
יש אפילו יותר לכאן, אבל
שוב לא אכפת לנו על זה.

1248
00:58:52,070 --> 00:58:55,120
>> אז עכשיו בואו לשאול עוד
שאלת זיכרון באמצעות,

1249
00:58:55,120 --> 00:58:57,519
כי בסוף
היום הוא בשונות.

1250
00:58:57,519 --> 00:59:00,310
לא משנה מה אנחנו יכולים לעשות עם
המחשב, בסוף היום

1251
00:59:00,310 --> 00:59:02,560
החומרה היא עדיין
אותו מתחת למכסה המנוע.

1252
00:59:02,560 --> 00:59:04,670
איך הייתי לאחסן מילה כאן?

1253
00:59:04,670 --> 00:59:09,710
ובכן, מילה במחשב כמו
"היי!" יאוכסן בדיוק כמו זה.

1254
00:59:09,710 --> 00:59:12,300
ואם אתה רוצה עוד
מילה, אתה יכול פשוט

1255
00:59:12,300 --> 00:59:19,120
לדרוס זה ואומר משהו
כמו "שלום" וחנות שכאן.

1256
00:59:19,120 --> 00:59:23,930
>> וכך גם כאן, contiguousness זה
למעשה יתרון,

1257
00:59:23,930 --> 00:59:26,530
כי מחשב יכול פשוט
לקרוא מימין לשמאל.

1258
00:59:26,530 --> 00:59:28,680
אבל הנה שאלה.

1259
00:59:28,680 --> 00:59:33,480
בהקשר של מילה זו,
ח-י-י-י-ם, סימן קריאה,

1260
00:59:33,480 --> 00:59:38,740
איך ייתכן שהמחשב יודע איפה
מילה מתחילה ואיפה המילה מסתיימת?

1261
00:59:38,740 --> 00:59:41,690

1262
00:59:41,690 --> 00:59:43,800
בהקשר של מספרים,
איך מפעיל את המחשב

1263
00:59:43,800 --> 00:59:48,396
יודע כמה זמן את הרצף
מספרים או איפה זה מתחיל?

1264
00:59:48,396 --> 00:59:50,270
ובכן, מסתבר out--
ואנחנו לא נלך יותר מדי

1265
00:59:50,270 --> 00:59:54,970
אל רמה זו של detail--
מחשבים להזיז דברים מסביב לזכרו

1266
00:59:54,970 --> 00:59:57,800
ממש בדרך של כתובות אלה.

1267
00:59:57,800 --> 01:00:02,080
אז במחשב, אם אתה
כתיבת קוד כדי לאחסן דברים

1268
01:00:02,080 --> 01:00:05,800
כמו מילים, מה אתה
באמת עושה הוא להקליד

1269
01:00:05,800 --> 01:00:11,320
ביטויים זוכרים איפה
בזיכרון של המחשב המילים האלה.

1270
01:00:11,320 --> 01:00:14,370
אז תנו לי לעשות מאוד,
דוגמא פשוטה מאוד.

1271
01:00:14,370 --> 01:00:18,260
>> אני הולך קדימה,
להיפתח תוכנית טקסט פשוט,

1272
01:00:18,260 --> 01:00:20,330
ואני הולך ליצור
קובץ בשם hello.c.

1273
01:00:20,330 --> 01:00:22,849
רוב המידע הזה אנו
לא אכנס בפירוט רב,

1274
01:00:22,849 --> 01:00:25,140
אבל אני הולך לכתוב
תכנית באותה שפה,

1275
01:00:25,140 --> 01:00:31,140
C. זהו הרבה יותר מאיים,
ברצוני לטעון, מ Scratch,

1276
01:00:31,140 --> 01:00:32,490
אבל זה מאוד דומה ברוחה.

1277
01:00:32,490 --> 01:00:34,364
למעשה, אלה מתולתלים
braces-- שתוכל סוג של

1278
01:00:34,364 --> 01:00:37,820
לחשוב על מה שעשיתי כמו זה.

1279
01:00:37,820 --> 01:00:39,240
>> בוא נעשה את זה, בעצם.

1280
01:00:39,240 --> 01:00:45,100
כאשר דגל ירוק לוחץ,
לבצע את הפעולות הבאות.

1281
01:00:45,100 --> 01:00:50,210
אני רוצה להדפיס "שלום."

1282
01:00:50,210 --> 01:00:51,500
אז זהו עכשיו פסאודו קוד.

1283
01:00:51,500 --> 01:00:53,000
אני סוג של טשטוש הגבולות.

1284
01:00:53,000 --> 01:00:56,750
ב C, השפה הזאת אני מדבר
על, הדפסת קו זה שלום

1285
01:00:56,750 --> 01:01:01,940
למעשה הופך להיות "printf" עם
בסוגריים כמה וא-פסיק.

1286
01:01:01,940 --> 01:01:03,480
>> אבל זה אותו רעיון בדיוק.

1287
01:01:03,480 --> 01:01:06,730
וזה מאוד ידידותי למשתמש
"כאשר הדגל ירוק לוחץ" הופך

1288
01:01:06,730 --> 01:01:10,182
את "void main int." הרבה יותר המסתורי

1289
01:01:10,182 --> 01:01:12,890
וזה באמת אין מיפוי,
אז אני פשוט הולך להתעלם מזה.

1290
01:01:12,890 --> 01:01:17,210
אבל סוגריים מסולסלים הם כמו
חתיכות הפאזל מעוקלות כזה.

1291
01:01:17,210 --> 01:01:18,700
>> אז אתה יכול סוג של לנחש.

1292
01:01:18,700 --> 01:01:22,357
גם אם אף פעם לא מתוכן לפני,
מה עושה תוכנית זו עושה כנראה?

1293
01:01:22,357 --> 01:01:25,560

1294
01:01:25,560 --> 01:01:28,000
כנראה מדפיסה שלום
עם סימן קריאה.

1295
01:01:28,000 --> 01:01:29,150
>> אז בואו לנסות את זה.

1296
01:01:29,150 --> 01:01:30,800
אני הולך לשמור אותו.

1297
01:01:30,800 --> 01:01:34,000
וזה, שוב, מאוד
סביבת בית ספר ישנה.

1298
01:01:34,000 --> 01:01:35,420
אני לא יכול ללחוץ, אני לא יכול לגרור.

1299
01:01:35,420 --> 01:01:36,910
אני צריך להקליד פקודות.

1300
01:01:36,910 --> 01:01:41,320
אז אני רוצה להריץ את התוכנית שלי, אז
אני עלול לעשות את זה, כמו hello.c.

1301
01:01:41,320 --> 01:01:42,292
זהו קובץ רצתי.

1302
01:01:42,292 --> 01:01:43,500
אבל רגע, אני חסר צעד.

1303
01:01:43,500 --> 01:01:46,470
מה עשה לנו לומר הוא הכרחי
צעד אחר שפה כמו C?

1304
01:01:46,470 --> 01:01:49,470
רק כתבתי מקור
קוד, אבל מה אני צריך לעשות?

1305
01:01:49,470 --> 01:01:50,670
כן, אני צריך מהדר.

1306
01:01:50,670 --> 01:01:57,670
אז ב- Mac שלי כאן, יש לי
תוכנית בשם GCC, מהדר ה- C של גנו,

1307
01:01:57,670 --> 01:02:03,990
אשר מאפשר לי לעשות זה- בתורו
קוד המקור שלי לתוך, אנחנו קוראים לזה,

1308
01:02:03,990 --> 01:02:04,930
קוד מכונה.

1309
01:02:04,930 --> 01:02:10,180
>> ואני יכול לראות את זה,
שוב, כדלקמן, אלה

1310
01:02:10,180 --> 01:02:14,090
הם אפסים ואחדות אני פשוט
נוצר מקוד המקור שלי,

1311
01:02:14,090 --> 01:02:15,730
כל האפסים ואחדים.

1312
01:02:15,730 --> 01:02:17,770
ואם אני רוצה לרוץ
שלי program-- זה קורה

1313
01:02:17,770 --> 01:02:23,010
להיקרא a.out עבור
reasons-- ההיסטורית "שלום."

1314
01:02:23,010 --> 01:02:24,070
אני יכול להפעיל אותו שוב.

1315
01:02:24,070 --> 01:02:25,690
שלום שלום שלום.

1316
01:02:25,690 --> 01:02:27,430
וזה נראה שזה עובד.

1317
01:02:27,430 --> 01:02:31,000
>> אבל זה אומר איפשהו שלי
הזיכרון של המחשב הם המילים

1318
01:02:31,000 --> 01:02:35,279
ח-י-י-י-ם, סימן קריאה.

1319
01:02:35,279 --> 01:02:38,070
ומתברר, בדיוק כמו במאמר מוסגר,
איזה מחשב היה בדרך כלל

1320
01:02:38,070 --> 01:02:40,550
לעשות כך שהוא יודע היכן
הדברים התחילו end-- זה

1321
01:02:40,550 --> 01:02:42,460
הולך לשים כאן סמל מיוחד.

1322
01:02:42,460 --> 01:02:46,064
והאמנה היא לשים את
מספר אפס בסוף מילה

1323
01:02:46,064 --> 01:02:48,230
כך אתה יודע איפה זה
למעשה מסתיים, כך שאתה

1324
01:02:48,230 --> 01:02:52,750
לא לשמור ולהדפסה יותר ויותר
דמויות ממה שאתה מתכוון באמת.

1325
01:02:52,750 --> 01:02:55,400
>> אבל האוכל המוכן כאן, אפילו
אם כי זה די מסתורי,

1326
01:02:55,400 --> 01:02:58,140
הוא שזה בסופו של דבר
פשוט יחסית.

1327
01:02:58,140 --> 01:03:04,550
אתה ניתנת מעין קלטת, ריק
מקום שבו אתה יכול לכתוב מכתבים.

1328
01:03:04,550 --> 01:03:07,150
אתה פשוט צריך שיהיה לך
סמל מיוחד, כמו שרירותי

1329
01:03:07,150 --> 01:03:10,316
מספר אפס, לשים בסוף
דבריך כך שהמחשב יודע,

1330
01:03:10,316 --> 01:03:13,410
הו, אני צריך להפסיק את ההדפסה לאחר
אני רואה את סימן הקריאה.

1331
01:03:13,410 --> 01:03:16,090
כי הדבר הבא שיש
הוא ערך ASCII של אפס,

1332
01:03:16,090 --> 01:03:19,125
או התו הריק כמו
שמישהו יקרא את זה.

1333
01:03:19,125 --> 01:03:21,500
אבל יש סוג של בעיה
כאן, ובואו לחזור

1334
01:03:21,500 --> 01:03:23,320
למספרים לרגע.

1335
01:03:23,320 --> 01:03:28,720
נניח שאני עושה, למעשה,
יש מערך של מספרים,

1336
01:03:28,720 --> 01:03:30,730
ונניח כי
תכנית שאני כותב היא

1337
01:03:30,730 --> 01:03:34,680
כמו ספר כיתה מורה
וכן בכיתת מורים.

1338
01:03:34,680 --> 01:03:38,720
תוכנית זו מאפשרת לו או לה
להקליד ציוניהם של התלמידים שלהם

1339
01:03:38,720 --> 01:03:39,960
על חידונים.

1340
01:03:39,960 --> 01:03:43,750
ונניח לעובדה שהתלמיד רוכש
100 על החידון הראשון שלהם, אולי

1341
01:03:43,750 --> 01:03:49,920
כמו 80 על הבא, ולאחר מכן
75, אז 90 על החידון הרביעי.

1342
01:03:49,920 --> 01:03:54,150
>> לכן בשלב זה של הסיפור,
המערך הוא בגודל ארבעה.

1343
01:03:54,150 --> 01:03:58,470
אין שום יותר זיכרון
מחשב, אבל המערך, אם אפשר לומר כך,

1344
01:03:58,470 --> 01:04:00,350
הוא בגודל ארבעה.

1345
01:04:00,350 --> 01:04:06,060
נניח כעת כי המורה רוצה
להקצות חידון חמישי בפני הכיתה.

1346
01:04:06,060 --> 01:04:08,510
ובכן, אחד הדברים שהם
או שהיא הולכת לעשות

1347
01:04:08,510 --> 01:04:10,650
כרגע הוא לאחסן ערך נוסף כאן.

1348
01:04:10,650 --> 01:04:15,490
אבל אם מערך המורה יש
נוצר בתוכנית זו היא של גודל עבור,

1349
01:04:15,490 --> 01:04:22,440
אחד הבעיה עם מערך זה
אתה לא יכול פשוט לשמור על הוספת זיכרון.

1350
01:04:22,440 --> 01:04:26,470
כי מה אם בחלק אחר של
יש תוכנית המילה "היי" ממש שם?

1351
01:04:26,470 --> 01:04:29,650
>> במילים אחרות, הזיכרון שלי יכול להיות
נעשה בו כל שימוש בתוכנית.

1352
01:04:29,650 --> 01:04:33,250
ואם מראש הקלדתי, היי,
אני רוצה ציונים קלט ארבעה חידון,

1353
01:04:33,250 --> 01:04:34,784
הם עלולים ללכת כאן וכאן.

1354
01:04:34,784 --> 01:04:37,700
ואם אתה פתאום לשנות את דעתך
לאחר מכן ולומר אני רוצה חידון חמישי

1355
01:04:37,700 --> 01:04:40,872
ציון, אתה לא יכול פשוט
לשים אותו לאן שאתה רוצה,

1356
01:04:40,872 --> 01:04:42,580
כי מה אם זה
הזיכרון נמצא בשימוש

1357
01:04:42,580 --> 01:04:45,990
למשהו else-- תוכנית אחרת
או כמה תכונה אחרת של התוכנית

1358
01:04:45,990 --> 01:04:46,910
כי אתה מפעיל?

1359
01:04:46,910 --> 01:04:50,650
אז אתה צריך לחשוב מראש
איך אתה רוצה לאחסן את הנתונים,

1360
01:04:50,650 --> 01:04:54,480
כי עכשיו שציירת
את עצמך לפינה דיגיטלית.

1361
01:04:54,480 --> 01:04:57,280
>> אז מורה עלולה במקום
לומר בעת כתיבת תוכנית

1362
01:04:57,280 --> 01:04:59,360
לאחסן שלו או שלה
ציונים, אתה יודע מה?

1363
01:04:59,360 --> 01:05:04,180
אני הולך לבקש,
בעת כתיבת התוכנית שלי,

1364
01:05:04,180 --> 01:05:12,070
כי אני רוצה אפס, אחת, שתיים, שלוש,
ארבע, חמש, שש, שמונה כיתות להסתכם.

1365
01:05:12,070 --> 01:05:15,320
אז אחת, שתיים, שלוש, ארבע,
חמש, שש, שבע, שמונה.

1366
01:05:15,320 --> 01:05:18,612
המורה יכול רק יתר להקצות
זיכרון בעת ​​כתיבת התוכנית שלו או שלה

1367
01:05:18,612 --> 01:05:19,570
ואומר, אתה יודע מה?

1368
01:05:19,570 --> 01:05:22,236
ואני לא מתכוון להקצות יותר
משמונה חידונים ב סמסטר.

1369
01:05:22,236 --> 01:05:23,130
זה פשוט מטורף.

1370
01:05:23,130 --> 01:05:24,470
אני לעולם לא להקצות את זה.

1371
01:05:24,470 --> 01:05:28,270
אז ככה זה הוא או היא כוללת את
גמישות ציון תלמידי חנות,

1372
01:05:28,270 --> 01:05:33,010
כמו 75, 90, ואולי אחד נוסף שבו
התלמיד קיבל אשראי נוסף, 105.

1373
01:05:33,010 --> 01:05:36,130
>> אבל אם המורה לא
משתמש בשלושת מקומות אלה,

1374
01:05:36,130 --> 01:05:38,860
קיימת ממסעדה אינטואיטיבי כאן.

1375
01:05:38,860 --> 01:05:41,410
הוא או הוא פשוט מבזבז מקום.

1376
01:05:41,410 --> 01:05:44,790
אז במילים אחרות, יש את זה
תחלופה נפוצה בתכנות

1377
01:05:44,790 --> 01:05:48,241
שבו אתה יכול גם להקצות
בדיוק כמו הרבה זיכרון כמו שאתה רוצה,

1378
01:05:48,241 --> 01:05:51,490
הפוך מהם הוא שאתה סופר
efficient-- שאתה לא להיות בזבזני

1379
01:05:51,490 --> 01:05:54,640
ב כל-- אבל החיסרון של אשר
מה הוא אם תשנה את דעתך כאשר

1380
01:05:54,640 --> 01:05:58,780
באמצעות התוכנית שברצונך לאחסן
נתונים יותר ממה שאתה שתכננתי לעשות מלכתחילה.

1381
01:05:58,780 --> 01:06:03,030
>> אז אולי הפתרון הוא, אם כן,
לכתוב את התוכניות שלך בצורה כזאת

1382
01:06:03,030 --> 01:06:05,605
כי הם משתמשים יותר זיכרון
ממה שהם באמת צריכים.

1383
01:06:05,605 --> 01:06:07,730
בדרך זו אתה לא הולך
להיתקל בבעיה,

1384
01:06:07,730 --> 01:06:09,730
אבל אתה פשוט מתנהג בזבזן.

1385
01:06:09,730 --> 01:06:12,960
והזיכרון יותר התוכנית שלך משתמשת,
כמו שדיברנו אתמול, פחות

1386
01:06:12,960 --> 01:06:15,410
זיכרון זה זמין
עבור תוכניות אחרות,

1387
01:06:15,410 --> 01:06:18,790
במוקדם ייתכן שהמחשב איטי
למטה בגלל הזיכרון הווירטואלי.

1388
01:06:18,790 --> 01:06:22,670
וכך הפתרון האידיאלי עשוי להיות מה?

1389
01:06:22,670 --> 01:06:24,610
>> תת הקצאה נראה רע.

1390
01:06:24,610 --> 01:06:27,030
יתר ההקצאה נראית רעה.

1391
01:06:27,030 --> 01:06:31,120
אז מה יכול להיות פתרון טוב יותר?

1392
01:06:31,120 --> 01:06:32,390
הקצאה מחדש.

1393
01:06:32,390 --> 01:06:33,590
להיות יותר דינמיים.

1394
01:06:33,590 --> 01:06:37,520
אל תכריחו את עצמכם לבחור
אפריורי, בהתחלה, מה שאתה רוצה.

1395
01:06:37,520 --> 01:06:41,370
ובוודאי לא על-להקצות,
שמא אתה להיות בזבזני.

1396
01:06:41,370 --> 01:06:45,770
>> וכך כדי להשיג מטרה זו, אנו
צריך לזרוק מבנה נתונים זה,

1397
01:06:45,770 --> 01:06:48,100
כביכול, משם.

1398
01:06:48,100 --> 01:06:51,080
אז מה מתכנת
בדרך כלל ישתמש

1399
01:06:51,080 --> 01:06:55,940
הוא משהו שנקרא לא
מערך אבל רשימה מקושרת.

1400
01:06:55,940 --> 01:07:00,860
במילים אחרות, הוא או היא
להתחיל לחשוב על הזיכרון שלהם

1401
01:07:00,860 --> 01:07:05,280
כמו להיות סוג של צורה שהם
יכול לצייר באופן הבא.

1402
01:07:05,280 --> 01:07:08,520
אם אני רוצה לאחסן מספר אחת
program-- אז זה בספטמבר

1403
01:07:08,520 --> 01:07:12,600
נתתי לתלמידים שלי חידון; אני רוצה
כדי לאחסן את החידון הראשון של התלמידים,

1404
01:07:12,600 --> 01:07:16,220
והם קיבלו 100 והלאה אני it--
אני אזמין את המחשב שלי,

1405
01:07:16,220 --> 01:07:19,540
בדרך של התוכנית לי
בכתב, עבור נתח של זיכרון אחד.

1406
01:07:19,540 --> 01:07:22,570
ואני הולך לאחסן את
מספר 100 בו, וזהו.

1407
01:07:22,570 --> 01:07:24,820
>> אז כמה שבועות מאוחר יותר
כשאגיע החידון השני שלי,

1408
01:07:24,820 --> 01:07:27,890
וזה זמן להקליד
ב ש -90%, אני הולך

1409
01:07:27,890 --> 01:07:32,129
לשאול את המחשב, היי, מחשב,
אני יכול לקבל עוד נתח של זיכרון?

1410
01:07:32,129 --> 01:07:34,170
זה הולך לתת לי את זה
נתח של זיכרון ריק.

1411
01:07:34,170 --> 01:07:39,370
אני הולך לשים את המספר 90,
אבל בתוכנית שלי איכשהו או other--

1412
01:07:39,370 --> 01:07:42,100
ואנחנו לא לדאוג
התחביר של זה- אני צריך

1413
01:07:42,100 --> 01:07:44,430
איכשהו שרשרת מחוברת הדברים האלה.

1414
01:07:44,430 --> 01:07:47,430
ואני וקושר אותם יחד עם
מה שנראה כמו חץ כאן.

1415
01:07:47,430 --> 01:07:50,050
>> החידון השלישי שעולה,
אני הולך להגיד, היי, מחשב,

1416
01:07:50,050 --> 01:07:51,680
תן לי עוד נתח של זיכרון.

1417
01:07:51,680 --> 01:07:54,660
ואני הולך לשים למטה
מה שזה לא היה, כמו 75,

1418
01:07:54,660 --> 01:07:56,920
ואני צריך שרשרת זו
יחד עם חברה איכשהו.

1419
01:07:56,920 --> 01:08:00,290
החידון רביעי מגיע, ואולי
זה לקראת סוף הסמסטר.

1420
01:08:00,290 --> 01:08:03,140
ועל ידי כך נקודת התוכנית שלי
יכול להיות באמצעות זיכרון

1421
01:08:03,140 --> 01:08:05,540
בכל מקום, בכל רחבי פיזית.

1422
01:08:05,540 --> 01:08:08,170
וכך סתם בשביל הכיף, אני
הולך למשוך הלאה זה

1423
01:08:08,170 --> 01:08:11,260
quiz-- שכחתי מה זה היה; אני
חושב אולי 80 או משהו--

1424
01:08:11,260 --> 01:08:12,500
בדרך לכאן.

1425
01:08:12,500 --> 01:08:15,920
>> אבל זה בסדר, כי באופן ציורי
אני הולך לצייר את הקו הזה.

1426
01:08:15,920 --> 01:08:19,063
במילים אחרות, במציאות,
בחומרה של המחשב,

1427
01:08:19,063 --> 01:08:20,979
התוצאה הראשונה אולי
בסופו של דבר כאן כי זה

1428
01:08:20,979 --> 01:08:22,529
ממש בהתחלה של הסמסטר.

1429
01:08:22,529 --> 01:08:25,810
השלב הבא עלול בסופו של דבר כאן
כי קצת זמן עבר

1430
01:08:25,810 --> 01:08:27,210
והתכנית ממשיכה לפעול.

1431
01:08:27,210 --> 01:08:30,060
הציון הבא, שהיה
75, עלולים להיות כאן.

1432
01:08:30,060 --> 01:08:33,420
ואת הציון האחרון עלול להיות
80, אשר נגמר כאן.

1433
01:08:33,420 --> 01:08:38,729
>> אז במציאות, פיזי, זה יכול להיות
מה הזיכרון של המחשב שלך נראה.

1434
01:08:38,729 --> 01:08:41,569
אבל זה אינו נפשי שימושי
פרדיגמה עבור מתכנת מחשבים.

1435
01:08:41,569 --> 01:08:44,649
למה שיהיה אכפת לך איפה
לעזאזל הנתונים שלך מסתיים?

1436
01:08:44,649 --> 01:08:46,200
אתה רק רוצה לאחסן נתונים.

1437
01:08:46,200 --> 01:08:49,390
>> זה כמו סוג של דיוננו
מוקדם של ציור הקוביה.

1438
01:08:49,390 --> 01:08:52,200
למה אכפת לך מה
הזווית היא של הקובייה

1439
01:08:52,200 --> 01:08:53,740
ואיך אתה צריך לפנות לצייר אותו?

1440
01:08:53,740 --> 01:08:54,950
אתה רק רוצה קוביה.

1441
01:08:54,950 --> 01:08:57,359
באופן דומה כאן, אתה
רק רוצה ספר בכיתה.

1442
01:08:57,359 --> 01:08:59,559
אתה רק רוצה לחשוב
זה כרשימה של מספרים.

1443
01:08:59,559 --> 01:09:01,350
למי אכפת איך זה
מיושם חומרה?

1444
01:09:01,350 --> 01:09:05,180
>> אז ההפשטה עכשיו
בתמונה היא כאן.

1445
01:09:05,180 --> 01:09:07,580
זהו מקושרי רשימה, כפי
מתכנת הייתי קורא לזה,

1446
01:09:07,580 --> 01:09:10,640
ככל שיש לך
הרשימה, כמובן של מספרים.

1447
01:09:10,640 --> 01:09:14,990
אבל היא קשורה באופן ציורי
בדרך החצים האלה,

1448
01:09:14,990 --> 01:09:18,510
וכל החצים הללו שהן-- מתחת
את מכסה המנוע, אם אתה סקרן,

1449
01:09:18,510 --> 01:09:23,210
זוכרים כי יש החומרה הפיזית שלנו
כתובות אפס, אחת, שתיים, שלוש, ארבע.

1450
01:09:23,210 --> 01:09:28,465
כל החצים האלה הם הוא כמו מפה
או כיוונים, שבו אם 90 הוא-- עכשיו

1451
01:09:28,465 --> 01:09:29,090
קיבלתי לספור.

1452
01:09:29,090 --> 01:09:31,750
>> אפס, אחת, שתיים, שלוש,
ארבע, חמש, שש, שבע.

1453
01:09:31,750 --> 01:09:35,640
זה נראה כמו 90 הוא ב
כתובת זיכרון מספר שבע.

1454
01:09:35,640 --> 01:09:38,460
כל החצים האלה הם הוא
כמו פיסת נייר קטנה

1455
01:09:38,460 --> 01:09:42,439
כי נותן הנחיות כיצד להגיע אל
תוכנית שאומרת לפי המפה זה

1456
01:09:42,439 --> 01:09:43,880
כדי להגיע למיקום שבע.

1457
01:09:43,880 --> 01:09:46,680
ויש תמצא את
ציון החידון השני של התלמיד.

1458
01:09:46,680 --> 01:09:52,100
בינתיים, 75-- אם אני ממשיך זה,
זה שבעה, שמונה, תשע, 10, 11, 12,

1459
01:09:52,100 --> 01:09:54,240
13, 14, 15.

1460
01:09:54,240 --> 01:09:59,080
>> חץ אחר זה פשוט מייצג
מפה למיקום זיכרון 15.

1461
01:09:59,080 --> 01:10:02,550
אבל שוב, מתכנת בדרך כלל עושה
לא אכפת את רמת הפירוט הזו.

1462
01:10:02,550 --> 01:10:05,530
וברוב כל התכנות
שפה היום, המתכנת

1463
01:10:05,530 --> 01:10:10,490
אפילו לא ידע איפה לזכרו
מספרים אלה הם למעשה.

1464
01:10:10,490 --> 01:10:14,830
כל מה שהוא או היא צריכה אכפת הוא
כי הם איכשהו קשורים יחד

1465
01:10:14,830 --> 01:10:18,390
ב מבנה נתונים כזה.

1466
01:10:18,390 --> 01:10:21,580
>> אבל מתברר שלא
כדי לקבל טכני מדי.

1467
01:10:21,580 --> 01:10:27,430
אבל רק משום שאנו יכולים אולי
להרשות לנהל את הדיון הזה כאן,

1468
01:10:27,430 --> 01:10:33,630
נניח כי אנו שוב
בעיה זו כאן של מערך.

1469
01:10:33,630 --> 01:10:35,780
בואו נראים אם אנחנו מצטערים שבאנו לכאן.

1470
01:10:35,780 --> 01:10:42,950
זהו 100, 90, 75, ו -80.

1471
01:10:42,950 --> 01:10:44,980
>> הרשו לי בקצרה לטעון את הטענה הזו.

1472
01:10:44,980 --> 01:10:48,980
זהו מערך, ושוב,
מאפיין בולט של מערך

1473
01:10:48,980 --> 01:10:52,400
הוא שכל הנתונים שלך חזרה
גב אל גב ב memory-- פשוטו כמשמעו

1474
01:10:52,400 --> 01:10:56,830
אחד בייט או אולי ארבעה בתים,
כמה מספר הבתים קבוע משם.

1475
01:10:56,830 --> 01:11:00,710
ברשימה מקושרת, אשר נוכל לצייר
ככה, מתחת למכסה המנוע אשר

1476
01:11:00,710 --> 01:11:02,000
יודע לאן דברים זה?

1477
01:11:02,000 --> 01:11:03,630
זה אפילו לא צריך לזרום ככה.

1478
01:11:03,630 --> 01:11:06,050
חלק מהנתונים יכול להיות
בחזרה שמאלה שם למעלה.

1479
01:11:06,050 --> 01:11:07,530
אתה אפילו לא יודע.

1480
01:11:07,530 --> 01:11:15,430
>> וכך עם מערך, יש לך
תכונה המכונה גישה אקראית.

1481
01:11:15,430 --> 01:11:20,570
ומה אמצעי גישה אקראית הוא
שהמחשב יכול לקפוץ מיד

1482
01:11:20,570 --> 01:11:22,730
לכל מקום במערך.

1483
01:11:22,730 --> 01:11:23,580
למה?

1484
01:11:23,580 --> 01:11:26,000
היות שהמחשב יודע
שהמיקום הראשון הוא

1485
01:11:26,000 --> 01:11:29,540
אפס, אחת, שתיים, שלוש.

1486
01:11:29,540 --> 01:11:33,890
>> ולכן אם אתה רוצה ללכת מ
האלמנט הזה לאלמנט הבא,

1487
01:11:33,890 --> 01:11:36,099
אתה ממש, ב
המוח של המחשב, פשוט להוסיף אחד.

1488
01:11:36,099 --> 01:11:39,140
אם אתה רוצה ללכת על הרכיב השלישי,
רק להוסיף one-- האלמנט הבא, רק

1489
01:11:39,140 --> 01:11:40,290
להוסיף אחד.

1490
01:11:40,290 --> 01:11:42,980
עם זאת, בגרסה זו
של הסיפור, תניח

1491
01:11:42,980 --> 01:11:46,080
המחשב בוחן בימים אלו
בבית או להתמודד עם המספר 100.

1492
01:11:46,080 --> 01:11:49,770
איך אתה משיג למשנהו
כיתה בבית הספר בכיתה?

1493
01:11:49,770 --> 01:11:52,560
>> אתה צריך לקחת שבע
צעדים, אשר היא שרירותית.

1494
01:11:52,560 --> 01:11:58,120
כדי להגיע אל השלב הבא, אתה צריך
לקחת שמונה שלבים נוספים להגיע 15.

1495
01:11:58,120 --> 01:12:02,250
במילים אחרות, זה לא
פער קבוע בין המספרים,

1496
01:12:02,250 --> 01:12:04,857
וכך זה פשוט לוקח את
זמן מחשב יותר הנקודה.

1497
01:12:04,857 --> 01:12:06,940
המחשב יש לחפש
דרך זיכרון כדי

1498
01:12:06,940 --> 01:12:08,990
כדי למצוא את מה שאתה מחפש.

1499
01:12:08,990 --> 01:12:14,260
>> אז בעוד מערך נוטה להיות
structure-- נתונים מהירים כי אתה

1500
01:12:14,260 --> 01:12:17,610
ממש יכול פשוט לעשות חשבון פשוט
ו להגיע לאן שאתה רוצה על ידי הוספת אחד,

1501
01:12:17,610 --> 01:12:21,300
עבור instance-- רשימה מקושרת,
אתה להקריב תכונה.

1502
01:12:21,300 --> 01:12:24,020
אתה לא יכול פשוט ללכת מן ראשון
שני לשלישי כדי רביעי.

1503
01:12:24,020 --> 01:12:25,240
אתה חייב לבצע את המפה.

1504
01:12:25,240 --> 01:12:28,160
אתה צריך לקחת צעדים נוספים
כדי להגיע לערכים האלה, אשר

1505
01:12:28,160 --> 01:12:30,230
היה נראה הוספת עלות.

1506
01:12:30,230 --> 01:12:35,910
אז אנחנו משלמים מחיר, אבל מה היה
התכונה שדן חיפש כאן?

1507
01:12:35,910 --> 01:12:38,110
מה עושה רשימה מקושרת
כנראה מאפשר לנו לעשות,

1508
01:12:38,110 --> 01:12:40,240
אשר היה המוצא
הסיפור המסוים הזה?

1509
01:12:40,240 --> 01:12:43,250

1510
01:12:43,250 --> 01:12:43,830
>> בְּדִיוּק.

1511
01:12:43,830 --> 01:12:46,220
גודל דינמי אליו.

1512
01:12:46,220 --> 01:12:48,040
אנחנו יכולים להוסיף לרשימה זו.

1513
01:12:48,040 --> 01:12:51,430
אנחנו יכולים אפילו לכווץ את הרשימה, כך
כי אנחנו רק באמצעות זיכרון הרבה

1514
01:12:51,430 --> 01:12:55,560
כפי שאנו באמת רוצים וכן הלאה
אנחנו אף פעם לא יתר ההקצאה.

1515
01:12:55,560 --> 01:12:58,470
>> עכשיו רק כדי להיות באמת טומטום-בררן,
יש עלות נסתרת.

1516
01:12:58,470 --> 01:13:01,980
אז אתה צריך לא רק תן לי לשכנע
אתה שזהו איזון משכנע.

1517
01:13:01,980 --> 01:13:04,190
יש עוד עלות נסתרת כאן.

1518
01:13:04,190 --> 01:13:06,550
היתרון, כדי שיהיה ברור,
הוא שאנו מקבלים דינמיים.

1519
01:13:06,550 --> 01:13:10,359
אם אני רוצה אלמנט אחר, אני יכול רק
לצייר אותו ולשים מספר שם.

1520
01:13:10,359 --> 01:13:12,150
ואז אני יכול לקשר את זה
עם תמונה כאן,

1521
01:13:12,150 --> 01:13:14,970
ואילו כאן, שוב, אם יהיה לי
צייר את עצמי לפינה,

1522
01:13:14,970 --> 01:13:19,410
אם משהו אחר כבר משתמש
הזיכרון כאן, אני מחוץ מזל.

1523
01:13:19,410 --> 01:13:21,700
ציירתי את עצמי לפינה.

1524
01:13:21,700 --> 01:13:24,390
>> אבל מה את הנסתר
עלות בתמונה הזאת?

1525
01:13:24,390 --> 01:13:27,690
זה לא רק את הסכום
של הזמן שלוקח

1526
01:13:27,690 --> 01:13:29,870
ללכת מכאן עד להודעה חדשה,
וזה שבעה צעדים, ואז

1527
01:13:29,870 --> 01:13:32,820
שמונה שלבים, אשר הוא יותר מאחד.

1528
01:13:32,820 --> 01:13:34,830
מה עוד עלות נסתרת?

1529
01:13:34,830 --> 01:13:35,440
לא רק זמן.

1530
01:13:35,440 --> 01:13:44,790

1531
01:13:44,790 --> 01:13:49,940
מידע נוסף הוא
דרושים כדי להשיג את התמונה הזאת.

1532
01:13:49,940 --> 01:13:53,210
>> כן, כי המפה, פיסות קטנות אלה של
נייר, כפי שאני חוזר המתאר כמוהם.

1533
01:13:53,210 --> 01:13:55,650
אלה arrows-- אלה אינם כרוכים בתשלום.

1534
01:13:55,650 --> 01:13:57,660
Computer-- אתה יודע
מה יש מחשב.

1535
01:13:57,660 --> 01:13:58,790
יש לו אפסים ואחדים.

1536
01:13:58,790 --> 01:14:03,170
אם אתה רוצה לייצג חץ או
למפות או מספר, אתה צריך קצת זיכרון.

1537
01:14:03,170 --> 01:14:05,950
אז המחיר האחר אתה
לשלם עבור רשימה מקושרת,

1538
01:14:05,950 --> 01:14:09,070
מדע מחשב משותף
משאב, הוא גם מקום.

1539
01:14:09,070 --> 01:14:11,710
>> ואכן כך, כל כך נפוץ,
בין הפשרות

1540
01:14:11,710 --> 01:14:15,580
בעיצוב הנדסת תוכנה
מערכות הן זמן space--

1541
01:14:15,580 --> 01:14:18,596
הם שני המרכיבים שלך, שני
המצרכים היקרים ביותר שלך.

1542
01:14:18,596 --> 01:14:21,220
זה עולה לי יותר זמן
כי אני צריך לבצע את המפה הזאת,

1543
01:14:21,220 --> 01:14:25,730
אבל זה גם עולה לי יותר מקום
כי אני צריך לשמור את המפה סביב.

1544
01:14:25,730 --> 01:14:28,730
אז בתקווה, כפי שכבר מין
לשיחתנו אתמול והיום,

1545
01:14:28,730 --> 01:14:31,720
הוא שההטבות
יהיה להכריע את העלויות.

1546
01:14:31,720 --> 01:14:33,870
>> אבל אין פתרון ברור כאן.

1547
01:14:33,870 --> 01:14:35,870
אולי זה better--
מהיר la ומלוכלך,

1548
01:14:35,870 --> 01:14:38,660
כמו כרים המוצעים earlier--
לזרוק זיכרון הבעיה.

1549
01:14:38,660 --> 01:14:42,520
רק לקנות עוד זיכרון, חושב פחות
קשה על פתרון הבעיה,

1550
01:14:42,520 --> 01:14:44,595
ולפתור אותה בצורה קלה יותר.

1551
01:14:44,595 --> 01:14:46,720
ואכן קודם לכן, כאשר
דיברנו על פשרות,

1552
01:14:46,720 --> 01:14:49,190
זה לא היה מקום
המחשב וזמן.

1553
01:14:49,190 --> 01:14:51,810
הגיע זמן מפתח, אשר
עדיין הוא משאב אחר.

1554
01:14:51,810 --> 01:14:54,829
>> אז שוב, זה זה איזון מעשה
מנסה להחליט איזה מאותם דברים

1555
01:14:54,829 --> 01:14:55,870
אתה מוכן להשקיע?

1556
01:14:55,870 --> 01:14:57,380
וזה לא פחות יקר?

1557
01:14:57,380 --> 01:15:01,040
אשר מניב תוצאות טובות יותר?

1558
01:15:01,040 --> 01:15:01,540
כֵּן?

1559
01:15:01,540 --> 01:15:11,310

1560
01:15:11,310 --> 01:15:12,580
>> אכן.

1561
01:15:12,580 --> 01:15:15,970
במקרה זה, אם אתה
מייצג מספרי maps--

1562
01:15:15,970 --> 01:15:18,820
אלה נקראים בשפות רבות
"עצות" או "כתובות" -

1563
01:15:18,820 --> 01:15:20,390
זה להכפיל את השטח.

1564
01:15:20,390 --> 01:15:24,390
זה לא צריך להיות רע כמו פעמיים אם
עכשיו אנחנו רק אחסון מספרים.

1565
01:15:24,390 --> 01:15:27,410
נניח שאנחנו לאחסון
רשומות חולה בתוך hospital--

1566
01:15:27,410 --> 01:15:30,870
כך שמות של פירסון, מספרי טלפון,
מספרי ביטוח לאומי, רופא

1567
01:15:30,870 --> 01:15:31,540
הִיסטוֹרִיָה.

1568
01:15:31,540 --> 01:15:34,160
תיבה זו יכולה להיות הרבה,
הרבה יותר גדול, ובמקרה

1569
01:15:34,160 --> 01:15:38,000
מצביע קטנטן, את הכתובת של
הבא element-- זה לא עניין גדול.

1570
01:15:38,000 --> 01:15:40,620
זה כזה שולי
עלות זה לא משנה.

1571
01:15:40,620 --> 01:15:43,210
אבל במקרה הזה, כן, זה הכפלה.

1572
01:15:43,210 --> 01:15:45,290
שאלה טובה.

1573
01:15:45,290 --> 01:15:47,900
>> בואו נדבר על זמן
קצת יותר קונקרטי.

1574
01:15:47,900 --> 01:15:50,380
מה השעה פועל
לחפש רשימה זו?

1575
01:15:50,380 --> 01:15:53,640
נניח שאני רוצה לחפש
דרך כל ציוני התלמידים,

1576
01:15:53,640 --> 01:15:55,980
ויש ציוני n
במבנה נתונים זה.

1577
01:15:55,980 --> 01:15:58,830
גם כאן, אנו יכולים ללוות
אוצר המילים של קודם לכן.

1578
01:15:58,830 --> 01:16:00,890
זהו מבנה נתונים ליניארי.

1579
01:16:00,890 --> 01:16:04,570
>> O ביג של n הוא מה נדרש כדי לקבל
עד הסוף של מבנה נתונים זה,

1580
01:16:04,570 --> 01:16:08,410
whereas-- ולא ראינו
זה before-- מערך נותן לך

1581
01:16:08,410 --> 01:16:13,555
מה שנקרא זמן קבוע, כלומר
צעד אחד או שני צעדים או 10 steps--

1582
01:16:13,555 --> 01:16:14,180
לא משנה.

1583
01:16:14,180 --> 01:16:15,440
זה מספר קבוע.

1584
01:16:15,440 --> 01:16:17,440
יש לזה שום קשר עם
את גודל המערך.

1585
01:16:17,440 --> 01:16:20,130
והסיבה לכך,
שוב, היא גישה אקראית.

1586
01:16:20,130 --> 01:16:23,180
המחשב יכול רק מיד
לקפוץ למקום אחר,

1587
01:16:23,180 --> 01:16:27,770
כי הם כולם אותו הדבר
המרחק בין כל דבר אחר.

1588
01:16:27,770 --> 01:16:29,112
אין מחשבה שהושקעה.

1589
01:16:29,112 --> 01:16:31,900

1590
01:16:31,900 --> 01:16:32,400
בסדר.

1591
01:16:32,400 --> 01:16:39,230
אז אם אני יכול, תן לי לנסות
לצייר שתי תמונות סופיות.

1592
01:16:39,230 --> 01:16:42,830
אחד נפוץ מאוד המכונה טבלת גיבוב.

1593
01:16:42,830 --> 01:16:51,120
אז כדי להניע את הדיון הזה,
תן לי לחשוב על איך לעשות את זה.

1594
01:16:51,120 --> 01:16:52,610
>> אז מה דעתכם על זה?

1595
01:16:52,610 --> 01:16:55,160
נניח שהבעיה
אנחנו רוצים לפתור עכשיו

1596
01:16:55,160 --> 01:16:58,360
מיישם בתוך dictionary--
כך חבורה שלמה של מילים באנגלית

1597
01:16:58,360 --> 01:16:59,330
או מה שלא יהיה.

1598
01:16:59,330 --> 01:17:02,724
והמטרה היא להיות מסוגל לענות
שאלות של הטופס היא זו מילה?

1599
01:17:02,724 --> 01:17:04,640
אז אתה רוצה ליישם
בודק איות, רק

1600
01:17:04,640 --> 01:17:07,220
כמו מילון פיזי
כי אתה יכול להסתכל דברים למעלה.

1601
01:17:07,220 --> 01:17:10,490
נניח שהייתי עושה את זה עם מערך.

1602
01:17:10,490 --> 01:17:12,590
יכולתי לעשות את זה.

1603
01:17:12,590 --> 01:17:20,756
>> ותניח המילים הן תפוחות
בננה ומלון.

1604
01:17:20,756 --> 01:17:23,330

1605
01:17:23,330 --> 01:17:26,465
ואני לא יכול לחשוב על פירות
שמתחילים באות ד, אז אנחנו פשוט

1606
01:17:26,465 --> 01:17:27,590
הולך להיות שלושה פירות.

1607
01:17:27,590 --> 01:17:31,510
אז זה הוא מערך, ואנחנו
אחסון כל המילים האלה

1608
01:17:31,510 --> 01:17:34,200
במילון זה כמערך.

1609
01:17:34,200 --> 01:17:39,350
השאלה, אם כן, היא איך עוד
אתה יכול לאחסן את המידע הזה?

1610
01:17:39,350 --> 01:17:43,160
>> ובכן, אני סוג של רמאות כאן, כי
כל המכתבים האלה במילה

1611
01:17:43,160 --> 01:17:44,490
באמת בייט בודד.

1612
01:17:44,490 --> 01:17:46,740
אז אם באמת רציתי להיות
ניט-בררן, אני באמת צריך

1613
01:17:46,740 --> 01:17:49,600
להיות חלוקה לתוך הרבה
נתחים קטנים של זיכרון,

1614
01:17:49,600 --> 01:17:51,289
ואנחנו יכולים לעשות בדיוק את זה.

1615
01:17:51,289 --> 01:17:53,580
אבל אנחנו הולכים להיתקל
אותה הבעיה כמו קודם.

1616
01:17:53,580 --> 01:17:56,674
מה אם, כפי Merriam Webster או אוקספורד
כמדי year-- הם מוסיפים מילים

1617
01:17:56,674 --> 01:17:59,340
אל dictionary-- שאנחנו עושים לא
בהכרח רוצה לצייר את עצמנו

1618
01:17:59,340 --> 01:18:00,780
לפינה עם מערך?

1619
01:18:00,780 --> 01:18:05,710
>> אז במקום, אולי גישה חכמה
היא לשים תפוח הצומת או התיבה משלה,

1620
01:18:05,710 --> 01:18:11,190
כמו שהיינו אומרים, בננה,
אז הנה יש לנו מלון.

1621
01:18:11,190 --> 01:18:14,990

1622
01:18:14,990 --> 01:18:16,790
ומחרוזת אנחנו ביחד הדברים האלה.

1623
01:18:16,790 --> 01:18:19,980
אז זהו המערך,
זוהי הרשימה המקושרת.

1624
01:18:19,980 --> 01:18:23,300
אם אתה לא ממש יכול לראות, זה פשוט
אומר "מערך", וזה אומר "רשימה."

1625
01:18:23,300 --> 01:18:25,780
>> אז יש לנו את אותו
בעיות בדיוק כמו לפני,

1626
01:18:25,780 --> 01:18:28,600
לפיה יש לנו עכשיו
והדינמיות הרשימה המקושרת שלנו.

1627
01:18:28,600 --> 01:18:31,090
אבל יש לנו מילון איטי למדי.

1628
01:18:31,090 --> 01:18:32,870
נניח אני רוצה לחפש מילה.

1629
01:18:32,870 --> 01:18:35,430
זה עלול לקחת לי גדול O של n
צעדים, כי המילה אולי

1630
01:18:35,430 --> 01:18:37,840
להיות כל הדרך בסוף
הרשימה, כמו מלון.

1631
01:18:37,840 --> 01:18:40,600
ומתברר כי
בתכנות, למיין

1632
01:18:40,600 --> 01:18:42,700
של הגביע של נתונים הקדוש
מבנים, הוא משהו

1633
01:18:42,700 --> 01:18:46,620
זה נותן לך קבוע
זמן כמו מערך

1634
01:18:46,620 --> 01:18:50,870
אבל זה עדיין נותן לך דינמי.

1635
01:18:50,870 --> 01:18:52,940
>> כדי שתהיה לנו את הטוב שבשני העולמות?

1636
01:18:52,940 --> 01:18:55,570
ואכן, יש משהו
קרא שולחן החשיש

1637
01:18:55,570 --> 01:18:59,320
המאפשר לך לעשות בדיוק
כי, אם כי כ.

1638
01:18:59,320 --> 01:19:03,140
טבלת גיבוב היא מגדלת
מבנה נתונים שאנחנו

1639
01:19:03,140 --> 01:19:06,340
יכול לחשוב כמו
שילוב של array--

1640
01:19:06,340 --> 01:19:12,390
ואני הולך לצייר אותו
כך-- ואת רשימות מקושרות

1641
01:19:12,390 --> 01:19:17,310
שאני אצייר ככה לכאן.

1642
01:19:17,310 --> 01:19:19,760
>> ודרך הדבר הזה
עובד הוא כדלקמן.

1643
01:19:19,760 --> 01:19:23,310

1644
01:19:23,310 --> 01:19:29,540
אם זה now-- חשיש table--
הוא מבנה הנתונים השלישי שלי,

1645
01:19:29,540 --> 01:19:32,590
ואני רוצה לאחסן
מילים זה, אני לא

1646
01:19:32,590 --> 01:19:35,440
רוצה רק לאחסן את כל החומר
מילים גב אל גב אל גב אל גב.

1647
01:19:35,440 --> 01:19:37,430
אני רוצה למנף חלק
פיסת מידע

1648
01:19:37,430 --> 01:19:40,330
על המילים אשר תאפשרנה
לי לקבל את זה שם זה יותר מהר.

1649
01:19:40,330 --> 01:19:43,666
>> כך שבהתחשב התפוח מילים
בננה ומלון,

1650
01:19:43,666 --> 01:19:45,040
אני בכוונה בחרתי את המילים האלה.

1651
01:19:45,040 --> 01:19:45,340
למה?

1652
01:19:45,340 --> 01:19:47,631
מה סוג של ביסודו
שונה על שלוש?

1653
01:19:47,631 --> 01:19:49,950

1654
01:19:49,950 --> 01:19:51,484
מה את המובן מאליו?

1655
01:19:51,484 --> 01:19:52,900
הם מתחילים עם אותיות שונות.

1656
01:19:52,900 --> 01:19:53,900
>> אז אתה יודע מה?

1657
01:19:53,900 --> 01:19:57,120
במקום לשים את כל המילים שלי
דלי זהה, אם אפשר לומר כך,

1658
01:19:57,120 --> 01:20:00,390
כמו ברשימה אחת גדולה, מדוע לא
אני לפחות לנסות אופטימיזציה

1659
01:20:00,390 --> 01:20:04,180
ולעשות הרשימות שלי 1/26 עוד.

1660
01:20:04,180 --> 01:20:07,440
אופטימיזציה משכנעת
אולי בגלל זה לא

1661
01:20:07,440 --> 01:20:10,650
אני- בעת הכנסת מילה
לתוך מבנה נתונים זה,

1662
01:20:10,650 --> 01:20:14,300
לתוך הזיכרון של המחשב, למה
לא שמתי את כל המילים 'a' כאן,

1663
01:20:14,300 --> 01:20:17,270
כל המילים ב 'כאן,
וכל המילים 'ג' כאן?

1664
01:20:17,270 --> 01:20:24,610
אז זה בסופו של דבר לשים תפוח
כאן, בננה כאן, מלון כאן,

1665
01:20:24,610 --> 01:20:25,730
וכן הלאה.

1666
01:20:25,730 --> 01:20:31,700
>> ואם יש לי תוספת
מילה בהדגשה כמו מה עוד?

1667
01:20:31,700 --> 01:20:36,640
תפוח, בננה, אגס.

1668
01:20:36,640 --> 01:20:39,370
כל אחד רשאי לחשוב על פירות
שמתחיל עם a, b, או ג?

1669
01:20:39,370 --> 01:20:40,570
מושלם Blueberry--.

1670
01:20:40,570 --> 01:20:43,990
זה הולך בסופו של דבר כאן.

1671
01:20:43,990 --> 01:20:47,530
וכך אנו נראים שיש
שולי פתרון טוב יותר,

1672
01:20:47,530 --> 01:20:50,820
כי עכשיו אם אני רוצה
לחפש תפוח, אני

1673
01:20:50,820 --> 01:20:53,200
הראשון-- שאני עושה לא רק לצלול
לתוך מבנה הנתונים שלי.

1674
01:20:53,200 --> 01:20:54,850
אני לא לצלול לתוך הזיכרון של המחשב שלי.

1675
01:20:54,850 --> 01:20:56,530
אני ראשון מסתכל האות הראשונה.

1676
01:20:56,530 --> 01:20:58,610
>> וזה מה מחשב
מדען יגיד.

1677
01:20:58,610 --> 01:21:00,760
אתה חשיש לתוך מבנה הנתונים שלך.

1678
01:21:00,760 --> 01:21:04,100
אתה לקחת קלט שלך, אשר
במקרה זה הוא מילה כמו תפוח.

1679
01:21:04,100 --> 01:21:07,150
אתה לנתח אותו, מביט
האות הראשונה במקרה זה,

1680
01:21:07,150 --> 01:21:08,340
ובכך וליבון זה.

1681
01:21:08,340 --> 01:21:10,950
וליבון הוא לפיו מונח כללי
אתה לוקח משהו כקלט

1682
01:21:10,950 --> 01:21:12,116
ואתה לייצר כמה פלט.

1683
01:21:12,116 --> 01:21:15,090
ואת התפוקה ב כי
במקרה הוא המיקום

1684
01:21:15,090 --> 01:21:18,150
אתה רוצה לחפש, ראשון
מיקום, מיקום שני, שלישי.

1685
01:21:18,150 --> 01:21:22,160
אז הקלט הוא תפוח,
הפלט הוא ראשון.

1686
01:21:22,160 --> 01:21:25,054
הקלט הוא בננה,
פלט צריך להיות שני.

1687
01:21:25,054 --> 01:21:27,220
הקלט הוא מלון,
הפלט יהיה שלישי.

1688
01:21:27,220 --> 01:21:30,320
הקלט הוא אוכמניות, את
פלט צריך שוב להיות שני.

1689
01:21:30,320 --> 01:21:34,010
וזה מה שעוזר לך לקחת
קיצורי דרך הזיכרון שלך

1690
01:21:34,010 --> 01:21:39,050
כדי להגיע מילים
או נתונים בצורה יעילה יותר.

1691
01:21:39,050 --> 01:21:43,330
>> עכשיו זה יצמצם זמננו פוטנציאלי
על ידי ככל אחד מתוך 26,

1692
01:21:43,330 --> 01:21:45,850
כי אם אתה מניח שאתה
יש כמה "a" מילים כמו "z"

1693
01:21:45,850 --> 01:21:48,080
מילים כמילים "q", אשר
הוא לא ממש realistic--

1694
01:21:48,080 --> 01:21:50,830
אתה הולך יש להטות פני
אותיות מסוימות של alphabet--

1695
01:21:50,830 --> 01:21:53,204
אבל זה יהיה מצטבר
הגישה כי אין לאפשר

1696
01:21:53,204 --> 01:21:55,930
לך להגיע מילים הרבה יותר מהר.

1697
01:21:55,930 --> 01:21:59,660
וגם במציאות, מתוחכם
התוכנית, גוגל של העולם,

1698
01:21:59,660 --> 01:22:02,180
Facebooks של בעולם--
הם ישתמשו טבלת גיבוב

1699
01:22:02,180 --> 01:22:03,740
עבור הרבה מטרות שונות.

1700
01:22:03,740 --> 01:22:06,590
אבל הם לא יהיו עד כדי כך נאיבי
רק להסתכל על האות הראשונה

1701
01:22:06,590 --> 01:22:09,700
תפוח או בננה או
אגס או מלון,

1702
01:22:09,700 --> 01:22:13,420
כי כפי שאתה יכול לראות אותם
רשימות עדיין יכולות לקבל ארוכה.

1703
01:22:13,420 --> 01:22:17,130
>> וכך זה עדיין עשוי להיות מעין
של linear-- כך מעין איטית,

1704
01:22:17,130 --> 01:22:19,980
כמו עם O הגדולה של n
כי שהזכרנו קודם לכן.

1705
01:22:19,980 --> 01:22:25,290
אז מה טבלת גיבוב ממש טובה תהיה
לבצע-- יהיה לו מערך הרבה יותר גדול.

1706
01:22:25,290 --> 01:22:28,574
וזה ישתמש הרבה יותר
פונקצית hashing מתוחכמת,

1707
01:22:28,574 --> 01:22:30,240
כך שזה לא רק להסתכל על "א."

1708
01:22:30,240 --> 01:22:35,480
אולי זה נראה ב "א-p-p-l-e" ו
איכשהו ממירה אותם חמישה מכתבים

1709
01:22:35,480 --> 01:22:38,400
אל המיקום שבו
יש לאחסן תפוחים.

1710
01:22:38,400 --> 01:22:42,660
אנחנו רק בתמימות באמצעות מכתב א '
לבד, כי זה נחמד ופשוט.

1711
01:22:42,660 --> 01:22:44,600
>> אבל טבלת גיבוב, ב
בסופו של דבר, אתה יכול לחשוב

1712
01:22:44,600 --> 01:22:47,270
של כשילוב של
מערך, שכל אחת מהן

1713
01:22:47,270 --> 01:22:51,700
יש רשימה מקושרת כי באופן אידיאלי
צריך להיות קצר ככל האפשר.

1714
01:22:51,700 --> 01:22:54,364
וזה לא פתרון ברור.

1715
01:22:54,364 --> 01:22:57,280
למעשה, חלק גדול של הכוונון העדין
מה שקורה מתחת למכסה המנוע כאשר

1716
01:22:57,280 --> 01:22:59,654
יישום מסוג זה
מבני נתונים מתוחכמים

1717
01:22:59,654 --> 01:23:01,640
מה היא הזכות
האורך של המערך?

1718
01:23:01,640 --> 01:23:03,250
מהי פונקציית hash נכון?

1719
01:23:03,250 --> 01:23:04,830
איך אתה לאחסן דברים לזכרו?

1720
01:23:04,830 --> 01:23:07,249
>> אבל מבין עד כמה מהר
סוג זה של הדיון

1721
01:23:07,249 --> 01:23:10,540
סלים, משני עד כה שזה סוג
של מעל ראשו של אחד בשלב זה, אשר

1722
01:23:10,540 --> 01:23:11,360
זה בסדר.

1723
01:23:11,360 --> 01:23:18,820
אבל התחלנו, כזכור, עם באמת
ברמה נמוכה משהו ואלקטרוניקה.

1724
01:23:18,820 --> 01:23:20,819
וכך זה שוב הוא זה
הנושא של הפשטה,

1725
01:23:20,819 --> 01:23:23,610
שם ברגע שאתה מתחיל לקחת עבור
כמובן מאליו, אישור, יש לי it-- יש

1726
01:23:23,610 --> 01:23:26,680
זיכרון פיזי, אוקיי, הבנתי, כל
יש מיקום פיזי כתובת,

1727
01:23:26,680 --> 01:23:29,910
בסדר, יש לי את זה, אני יכול לייצג
אלה כתובות כמו arrows--

1728
01:23:29,910 --> 01:23:34,650
אתה יכול מהר מאוד מתחיל יש
שיחות מתוחכמות יותר,

1729
01:23:34,650 --> 01:23:38,360
בסופו של דבר נראה מה שמאפשר לנו
כדי לפתור בעיות כמו חיפוש

1730
01:23:38,360 --> 01:23:41,620
ומיון יעיל יותר.

1731
01:23:41,620 --> 01:23:44,190
היה סמוך ובטוח, מדי--
כי אני חושב שזה

1732
01:23:44,190 --> 01:23:48,700
הוא העמוק ביותר שאנחנו מתרחקים לתוך כמה
נושאים CS אלה proper-- יש לנו

1733
01:23:48,700 --> 01:23:51,880
נעשה יום וחצי בבית הזה
להצביע מה שאפשר בדרך כלל לעשות מעל

1734
01:23:51,880 --> 01:23:55,520
במשך שמונה שבועות סמסטר.

1735
01:23:55,520 --> 01:23:59,670
>> כל שאלות על אלה?

1736
01:23:59,670 --> 01:24:01,100
לא?

1737
01:24:01,100 --> 01:24:01,940
בסדר.

1738
01:24:01,940 --> 01:24:05,610
ובכן, למה אנחנו לא שם עצירה,
להתחיל צהריים כמה דקות מוקדם,

1739
01:24:05,610 --> 01:24:07,052
לחדש בתוך כשעה?

1740
01:24:07,052 --> 01:24:08,760
ואני להתמשך
קצת בשאלות.

1741
01:24:08,760 --> 01:24:11,343
ואז אני הולך צריך ללכת
לקחת שיחות זוג אם זה בסדר.

1742
01:24:11,343 --> 01:24:15,000
אני אדליק מוזיקה כלשהי בינתיים,
אבל הצהריים צריכים להיות מעבר לפינה.

1743
01:24:15,000 --> 01:24:17,862

