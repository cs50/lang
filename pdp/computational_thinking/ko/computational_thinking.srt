1
00:00:00,000 --> 00:00:00,270

2
00:00:00,270 --> 00:00:01,790
데이비드 마란는 : 모든 사람을 환영합니다.

3
00:00:01,790 --> 00:00:05,030
그래서 어제, 당신은 그것을 기억합니다
우리는 여기에서이 주제에 초점을 맞추었다.

4
00:00:05,030 --> 00:00:08,380
그래서 우리는 네 무엇보다 중요한 topics--했다
개인 정보 보호, 보안 및 사회;

5
00:00:08,380 --> 00:00:11,960
인터넷 기술; 클라우드 컴퓨팅;
궁극적으로, 웹 개발.

6
00:00:11,960 --> 00:00:14,170
>> 사람이 있었나요
대역폭이나 시간

7
00:00:14,170 --> 00:00:16,900
조금 존을 보는
올리버 지난 밤에?

8
00:00:16,900 --> 00:00:20,120
그것은 실제로 꽤 재미 있어요
조금 무서운없는 경우.

9
00:00:20,120 --> 00:00:24,700
아무것도에 대한 질문
우리는 어제나요?

10
00:00:24,700 --> 00:00:27,600
모든 사항?

11
00:00:27,600 --> 00:00:35,580
당신이 만들고 싶어 질문
우리는 몇 가지 형태로 오늘에 터치 있는지?

12
00:00:35,580 --> 00:00:37,300
그래서 깨끗한 상태.

13
00:00:37,300 --> 00:00:38,760
>> 그래서 오늘의 의제입니까?

14
00:00:38,760 --> 00:00:41,301
그래서 우리가 오늘 시작하는 줄 알았는데
일반적으로 무엇에 모습

15
00:00:41,301 --> 00:00:44,460
에서 계산 thinking--로 알려진
지나치게 단순화의 위험, 생각

16
00:00:44,460 --> 00:00:46,636
컴퓨터처럼, 아마도
엔지니어처럼 생각하고,

17
00:00:46,636 --> 00:00:48,510
과를 시작하려고
당신의 생각을 정리

18
00:00:48,510 --> 00:00:52,039
또는 당신의 더 나은 이해를 제공합니다
무엇을 실제로 지휘에 관여하는 것

19
00:00:52,039 --> 00:00:54,080
컴퓨터에 뭔가를 할 수
프로그래밍의 방법으로.

20
00:00:54,080 --> 00:00:56,663
그리고 우리는 꽤 그것을하겠습니다
높은 수준의, 거의 영어,

21
00:00:56,663 --> 00:00:59,850
하지만 익숙한의 사용하려고
예를 들면 방법을 공식화하기

22
00:00:59,850 --> 00:01:01,450
당신은 문제를 해결 갈 것입니다.

23
00:01:01,450 --> 00:01:04,080
>> 그리고 우리는 몇 가지 CS를 다시 방문합니다
주제, 추상화처럼,

24
00:01:04,080 --> 00:01:06,040
이는 몇 등장
시간의 어제,

25
00:01:06,040 --> 00:01:07,554
알고리즘하고 표현입니다.

26
00:01:07,554 --> 00:01:09,720
우리가 시작 볼 수있는 곳 그리고 그건
그냥 순간에 오늘.

27
00:01:09,720 --> 00:01:11,481
그 다음 우리는 프로그래밍을 살펴 보겠습니다.

28
00:01:11,481 --> 00:01:13,480
우리는 몇 가지 살펴 보겠습니다
기본 구조

29
00:01:13,480 --> 00:01:16,450
있는 당신은 잘 알고 있습니다
심지어 매우 직관적 찾을 수 있습니다.

30
00:01:16,450 --> 00:01:18,370
>> 우리는 사실, 볼 것이다,
샘플 프로그래밍에

31
00:01:18,370 --> 00:01:21,244
매우 접근의 환경,
아주 장난, 실제로 대상

32
00:01:21,244 --> 00:01:22,555
12 세까지합니다.

33
00:01:22,555 --> 00:01:25,930
우리는 거기에 몇 분을 보낼 것이다
다음 하부 레벨을 가지

34
00:01:25,930 --> 00:01:30,360
실제로 일부에 대해 이야기
알고리즘 및 데이터 구조

35
00:01:30,360 --> 00:01:32,360
그래서, 말을 그합니다
프로그래머는 일반적으로 사용

36
00:01:32,360 --> 00:01:35,040
훨씬 더 많은 문제를 해결할
효율적으로!보다 당신은 수도

37
00:01:35,040 --> 00:01:37,322
모두 그들없이 할 수있을.

38
00:01:37,322 --> 00:01:40,280
그런 다음 점심을 먹은 후, 우리는 살펴 보겠습니다
그냥 기술 스택에서

39
00:01:40,280 --> 00:01:42,240
말하는 멋진 방법
기술의 컬렉션

40
00:01:42,240 --> 00:01:43,690
당신은에 사용할 수있는
몇 가지 문제를 해결한다.

41
00:01:43,690 --> 00:01:46,670
그리고 우리는 알파벳에 대해 얘기하자
존재하는 언어의 수프 today--

42
00:01:46,670 --> 00:01:50,930
자바와 파이썬과 C ++ 및 PHP와
루비와 다른 것들의 모든 종류.

43
00:01:50,930 --> 00:01:53,740
>> 우리는 좀 짧게 할게요
디자인 패턴에서.

44
00:01:53,740 --> 00:01:57,730
프로그래머, 시간이 지남에,
채용 방법이

45
00:01:57,730 --> 00:02:00,690
그들을 도와하는 경향
보다 쉽게​​ 문제를 해결한다.

46
00:02:00,690 --> 00:02:04,390
당신이 시작할 때 작성하는 자신을 볼 수
또 다시 코드의 동일한 종류

47
00:02:04,390 --> 00:02:08,080
사람들은 그 반복을 공식화
그들과 돌리다 이름

48
00:02:08,080 --> 00:02:10,084
다음을 사용하여
궁극적으로,이를 촉진한다.

49
00:02:10,084 --> 00:02:12,250
그리고 우리는 조금 얘기하자
모바일 전략에 대해,

50
00:02:12,250 --> 00:02:16,099
같은 사실은 무엇을 의미 하는가
모바일 앱 또는 모바일 웹 사이트를 확인합니다.

51
00:02:16,099 --> 00:02:17,140
당신은 안드로이드를해야합니까?

52
00:02:17,140 --> 00:02:17,730
당신은 iOS 용해야합니까?

53
00:02:17,730 --> 00:02:19,160
당신은 그 모두에 대한합니까?

54
00:02:19,160 --> 00:02:20,326
그리고 장단점은 무엇인가?

55
00:02:20,326 --> 00:02:23,180
그리고 마지막으로, 우리는 할게요
보고 웹 프로그래밍, 어떤

56
00:02:23,180 --> 00:02:25,380
집단 용어입니다
정말 모든 시간을 설명하는

57
00:02:25,380 --> 00:02:28,410
당신의 소프트웨어를 작성
웹에서 실행하기위한 것,

58
00:02:28,410 --> 00:02:30,430
휴대 전화에 대한 여부
데스크톱 또는 노트북.

59
00:02:30,430 --> 00:02:33,490
우리에 대한 간략한 살펴 보겠습니다
데이터베이스 및 디자인

60
00:02:33,490 --> 00:02:39,049
거기에, 경우에만 있기 때문에 거의 모든
재미있는 웹 기반 응용 프로그램

61
00:02:39,049 --> 00:02:40,590
요즘은 데이터베이스의 어떤 종류가 있습니다.

62
00:02:40,590 --> 00:02:42,380
그렇지 않으면 것
그냥 정적 콘텐츠합니다.

63
00:02:42,380 --> 00:02:45,254
그리고 데이터베이스는 만​​들 수 있습니다
변경 시간이 지남에 따라, 자신 여부

64
00:02:45,254 --> 00:02:45,960
또는 사용자의.

65
00:02:45,960 --> 00:02:47,820
그리고 우리는 방법을 고려해야합니다
설계 가겠어요

66
00:02:47,820 --> 00:02:50,510
해당 데이터베이스와 전문 용어의 종류
그 엔지니어의에서 올 수도

67
00:02:50,510 --> 00:02:52,790
화이트 보드에 토론
때 실제로 구현

68
00:02:52,790 --> 00:02:53,900
처음으로 응용 프로그램.

69
00:02:53,900 --> 00:02:57,002
>> 우리는에 대해 간단히 얘기하자
API를 유용한 서비스

70
00:02:57,002 --> 00:02:59,960
당신은 서서하는 데 사용할 수있는
다른 사람의 어깨, 회사 여부

71
00:02:59,960 --> 00:03:02,619
또는 개인, 그리고 해결하여
더 빨리 자신의 문제.

72
00:03:02,619 --> 00:03:04,785
그리고 우리는 아마도 손 대고 있습니다
자바 스크립트와 비트,

73
00:03:04,785 --> 00:03:08,900
사용되는 프로그래밍 언어
브라우저에서 이러한 일뿐만 아니라, 두

74
00:03:08,900 --> 00:03:09,820
서버한다.

75
00:03:09,820 --> 00:03:11,890
그리고 아마도, 우리는거야
시간이 허락, 방문

76
00:03:11,890 --> 00:03:15,670
손 -에 웹 물건 우리의 일부
어제했고, 두 가지를 통합

77
00:03:15,670 --> 00:03:17,630
우리가 함께 휴회 전에.

78
00:03:17,630 --> 00:03:22,380
>> that--와 그래서 무슨 일이 ahead--가있어
아무것도가없는 당신이

79
00:03:22,380 --> 00:03:26,289
우리가 삽입되었는지 확인하고 싶습니다
그리고 어떤 점에서에 터치합니다.

80
00:03:26,289 --> 00:03:28,330
그것은 마음에 스프링의 경우,
머지 않아 그것을 가지고.

81
00:03:28,330 --> 00:03:32,010
그런데 왜 우리는 시작하지 않는다
전산 사고 봐.

82
00:03:32,010 --> 00:03:35,420
>> 그리고 내가 그 제안하자
전산 사고는 다시이며,

83
00:03:35,420 --> 00:03:38,830
높은 수준의 설명 일종의
컴퓨터 과학자가 할 수있는 것.

84
00:03:38,830 --> 00:03:42,470
그리고 실제로, 시작하자
세 가지 재료와 그

85
00:03:42,470 --> 00:03:44,207
전산 사고에 들어갈 수 있습니다.

86
00:03:44,207 --> 00:03:45,790
이 그것을 설명하는 하나의 방법입니다.

87
00:03:45,790 --> 00:03:48,490
우리는 확실히 정의 할 수 있습니다
방법의 수에서이.

88
00:03:48,490 --> 00:03:50,630
>> 하지만, 내가 제안하자
오늘날 위해,

89
00:03:50,630 --> 00:03:53,910
세계의 문제 즉,
세계의 모든 문제,

90
00:03:53,910 --> 00:03:56,730
a로 접근 할 때
컴퓨터 과학자 수

91
00:03:56,730 --> 00:04:00,990
로 볼 수 무엇을 우리는거야
전화 입력, 어떤

92
00:04:00,990 --> 00:04:08,142
우리가 전화 할게 무엇인지에 공급하는 데 필요한
다음 출력을 생성 알고리즘.

93
00:04:08,142 --> 00:04:10,600
즉, 전체
문제 해결 I 주장의 세계

94
00:04:10,600 --> 00:04:13,140
로 증류 될 수있다
이 세 가지 성분.

95
00:04:13,140 --> 00:04:14,450
그래서 입력에 의해 무엇을 의미합니까?

96
00:04:14,450 --> 00:04:17,060
입력 당신이있어 것입니다
해결하기 위해 핸드.

97
00:04:17,060 --> 00:04:20,052
>> 예를 들어, 여기에
오래된 학교 문제.

98
00:04:20,052 --> 00:04:22,760
내가 여기에 전화 번호부가있는 경우 및
나는 그것으로 뭔가를보고 싶어,

99
00:04:22,760 --> 00:04:23,760
이 내 입력된다.

100
00:04:23,760 --> 00:04:26,260
나는 1000 정도가
전화 번호부에있는 페이지를 참조하십시오.

101
00:04:26,260 --> 00:04:27,780
이건 내 문제에 입력된다.

102
00:04:27,780 --> 00:04:31,507
그리고 내가 뭔가를 찾으려면
마이크 스미스, 그래서 친구처럼

103
00:04:31,507 --> 00:04:33,840
그의 이름과 번호입니다
희망이 주소록있다.

104
00:04:33,840 --> 00:04:36,430
>> 이 셀의 일전이다
전화, 그래서 난 그냥 검색 할 수 없습니다.

105
00:04:36,430 --> 00:04:38,540
그래서 나는 오래해야
학교와 실제로 검색

106
00:04:38,540 --> 00:04:41,331
일부 답변이 입력.

107
00:04:41,331 --> 00:04:43,580
그리고 그 대답은 바로 것입니다
출력이라고합니다.

108
00:04:43,580 --> 00:04:44,871
그래서 입력 전화 번호부이다.

109
00:04:44,871 --> 00:04:47,787
이 알고리즘은의 어떤 집합입니다
단계는 내가 마이크 스미스를 찾기 위해 사용합니다.

110
00:04:47,787 --> 00:04:50,120
출력은 희망이며
마이크 스미스의 전화 번호.

111
00:04:50,120 --> 00:04:52,703
그리고 이것은 다음 단지 것
가장 문제의 대표

112
00:04:52,703 --> 00:04:55,210
와 당신은 손으로 입력됩니다
출력을 생성 할 수 있습니다.

113
00:04:55,210 --> 00:04:59,459
>> 우리는 과정을 고려하기 전에 그래서
하는 우리는 그 문제를 해결할 수있다,

114
00:04:59,459 --> 00:05:01,250
마이크 스미스를 찾는
그런 일,

115
00:05:01,250 --> 00:05:04,090
의 첫 번째 고려하자
last-- 입력 및 출력.

116
00:05:04,090 --> 00:05:08,060
실제로, 물론, 입력 여기
종이의 모두가 함께 붙어있다

117
00:05:08,060 --> 00:05:09,400
전화 번호부의 형태 일 수있다.

118
00:05:09,400 --> 00:05:13,660
그러나 컴퓨터, course-- 노트북을
데스크톱, 심지어 전화와

119
00:05:13,660 --> 00:05:16,430
이러한 사람들은 days--
전자 장치.

120
00:05:16,430 --> 00:05:20,920
>> 그리고 하루의 끝에, 무슨 일이야
컴퓨터에있는 유일한 입력?

121
00:05:20,920 --> 00:05:23,299
음, 같은 뭔가
여기에이 전원 코드.

122
00:05:23,299 --> 00:05:25,590
나는 벽에 연결하고,
I는 전자의 흐름을 얻을

123
00:05:25,590 --> 00:05:27,048
어느 날 컴퓨터를 실행할 수 있습니다.

124
00:05:27,048 --> 00:05:30,420
아니면 그 전자는
내 배터리의 방법으로 만들었습니다.

125
00:05:30,420 --> 00:05:33,790
그러나 결국, 그건
유일한 것은 내 노트북​​에 들어가는.

126
00:05:33,790 --> 00:05:35,772
그리고 흥미로운 너무 많은
물건은 궁극적으로

127
00:05:35,772 --> 00:05:37,480
여부 나오는
프린터의 방법으로

128
00:05:37,480 --> 00:05:40,320
화면 또는 audially 등 나.

129
00:05:40,320 --> 00:05:45,320
>> 우리 모두가 같이있는 경우에 그래서 우리의
컴퓨터에 기본 입력

130
00:05:45,320 --> 00:05:49,160
전기, 그래서 그냥
전자는,과 또는 외출

131
00:05:49,160 --> 00:05:54,465
그래서 우리가 어떻게이 입력을 사용할 수 있습니다
실제로 정보를 표현하는 방법?

132
00:05:54,465 --> 00:05:57,090
즉, 우리는 어떻게받을 수 있나요
전기 간단한 흐름

133
00:05:57,090 --> 00:06:00,350
실제 표현에
숫자 또는 실제 문자

134
00:06:00,350 --> 00:06:03,620
화면 또는 실제 이미지
실제 영화 나 이메일 또는

135
00:06:03,620 --> 00:06:05,690
또는 이들의 임의의 개수
높은 수준의 개념,

136
00:06:05,690 --> 00:06:07,680
만약에 당신, 그에서
하루의 끝 어떻게 든

137
00:06:07,680 --> 00:06:11,950
이 저장되어야한다
전자 기계 장치

138
00:06:11,950 --> 00:06:16,260
만 간단한 ingredients--를 사용하여
전자 및 나오는?

139
00:06:16,260 --> 00:06:19,530
>> 그래서 그런 것 같다,
가장 간단한 형태로,

140
00:06:19,530 --> 00:06:23,260
상태의 종류 만
정말, 내 세계에있는

141
00:06:23,260 --> 00:06:25,350
조건을 speak--하기
내을 전 세계가 하나 인에

142
00:06:25,350 --> 00:06:33,020
나는 전자가 흐르는이 전기
흐르는, 아니면 해제, 등등 이것도 아니고 ... 않습니다.

143
00:06:33,020 --> 00:06:35,850
그리고, 이제 온 오프 공식화하자
컴퓨터 과학자가 수도로

144
00:06:35,850 --> 00:06:37,255
1과 0 그냥와.

145
00:06:37,255 --> 00:06:39,880
그냥 어떤 임의의에 대해 설명하자
하지만 일관성 번호.

146
00:06:39,880 --> 00:06:41,970
1은 0이 꺼져 의미에 대한 의미한다.

147
00:06:41,970 --> 00:06:45,427
또는 당신은 또한이를 볼 수 있습니다
에 진정한 수단과 거짓을 의미합니다.

148
00:06:45,427 --> 00:06:47,510
또한 검정 할 수있는
흰색 또는 빨간색과 파란색.

149
00:06:47,510 --> 00:06:48,759
당신은 두 가지 설명이 필요합니다.

150
00:06:48,759 --> 00:06:52,240
그리고 컴퓨터 과학자는 것
일반적으로 단지 0과 1을 사용합니다.

151
00:06:52,240 --> 00:06:58,980
>> 그런 경우라면, 내 유일한 알파벳 그래서
0과 1로 구성되는, 방법에

152
00:06:58,980 --> 00:07:03,360
나는 아마도 수를 균일하게 얻을 수
컴퓨터에 2 형 숫자 3하자

153
00:07:03,360 --> 00:07:06,140
또는 알파벳의 편지
이미지 또는 동영상 및?

154
00:07:06,140 --> 00:07:08,910
어떻게 우리가 일종의 부트 스트랩 않습니다
이 기본 원칙에서 자신

155
00:07:08,910 --> 00:07:12,080
0과 1의 실제로
더 흥미로운 무언가를 표현?

156
00:07:12,080 --> 00:07:14,430
>> 음, 그 질문을 넣어 보자
그냥 잠시 보류

157
00:07:14,430 --> 00:07:17,520
뭔가를 고려
희망을 잘 알고,

158
00:07:17,520 --> 00:07:21,150
당신은 정말 생각하지 않은 경우에도
50 (10)에 대한 세부 사항, 20, 30, 40에

159
00:07:21,150 --> 00:07:22,520
년 이상.

160
00:07:22,520 --> 00:07:24,780
이것은 무엇입니까?

161
00:07:24,780 --> 00:07:28,050
당신은 어떻게 발음하는 것인가?

162
00:07:28,050 --> 00:07:30,770
아니 트릭 질문입니다.

163
00:07:30,770 --> 00:07:32,950
숫자는, 그러나 그것은 무엇인가?

164
00:07:32,950 --> 00:07:34,842
1, 2, 3, 123.

165
00:07:34,842 --> 00:07:37,800
당신이 말한 어떻게 내가 좋아하는 1, 2, 3,
그게 보는 하나의 방법이기 때문.

166
00:07:37,800 --> 00:07:39,870
1, 2, 3, 그것은 일련의
세 가지 기호.

167
00:07:39,870 --> 00:07:42,005
이 사진의 그 우리
지금은 단어가 있습니다.

168
00:07:42,005 --> 00:07:44,880
그리고 당신은 일종의 그들 모두를 읽을 경우
함께 영어로 일반적인 인간

169
00:07:44,880 --> 00:07:46,600
(123)를 말할 것입니다.

170
00:07:46,600 --> 00:07:48,350
그리고는의 일종
높은 수준의 개념,

171
00:07:48,350 --> 00:07:50,340
상당히 큰 숫자 같은 느낌이 든다.

172
00:07:50,340 --> 00:07:51,490
>> 그러나 우리는이 방법 거죠?

173
00:07:51,490 --> 00:07:54,640
음, 이후 잠시 수 있습니다
당신은 이런 식으로 생각했습니다

174
00:07:54,640 --> 00:07:56,680
하지만 다시 내 하루에, I
종류의이 배운

175
00:07:56,680 --> 00:08:01,030
1 칼럼으로, 10 년대
열 및 100의 열입니다.

176
00:08:01,030 --> 00:08:06,400
Lakisa 말한대로 그래서, 그것은이다
1, 2, 3,뿐만 아니라 (123)이다.

177
00:08:06,400 --> 00:08:08,700
그러나 우리는 어떻게에서받을 수 있나요
후자의 전?

178
00:08:08,700 --> 00:08:12,340
>> 글쎄, 당신은 일반적으로 할 것
100의 열, 나는 1 있습니다.

179
00:08:12,340 --> 00:08:14,794
그 100 회 1 말처럼 그래서.

180
00:08:14,794 --> 00:08:16,210
그리고 10의 열에서, 나는이 있습니다.

181
00:08:16,210 --> 00:08:18,464
그 10 배이 말처럼 그래서.

182
00:08:18,464 --> 00:08:19,630
1의 칼럼에서는 3 있습니다.

183
00:08:19,630 --> 00:08:21,720
즉, 1 회 3 말처럼 그래서.

184
00:08:21,720 --> 00:08:24,290
>> 그리고 나는이 일을 추가하는 경우
함께,이, 물론,

185
00:08:24,290 --> 00:08:27,470
100 플러스 10 플러스 3.

186
00:08:27,470 --> 00:08:31,750
나는이 얻을 이유 아, 그건
(123)의 상위 레벨 개념.

187
00:08:31,750 --> 00:08:37,220
그냥 기본적인 수학, 이에이있어
기호는, 그들에게 무게가 당신 경우

188
00:08:37,220 --> 00:08:39,620
자리 표시 자 또는 열 값 것이다.

189
00:08:39,620 --> 00:08:42,090
그리고 나는 모든 것을 곱하면
밖으로,이 번호를.

190
00:08:42,090 --> 00:08:47,840
>> 그래서 당신이 알고 얼마나 많은 방법을 이야기합니다
binary-- 0과 컴퓨터 등 1's--?

191
00:08:47,840 --> 00:08:50,410
OK, 완벽한, 아무도, 또는
당신의 아무도 당신이 생각하지 않습니다.

192
00:08:50,410 --> 00:08:52,550
하지만 난 당신을 주장 것
실제로 이미 알고있다.

193
00:08:52,550 --> 00:08:55,330
우리는 일종의 조정할 필요
우리의 정신 모델 조금.

194
00:08:55,330 --> 00:08:57,250
그러나이 과정은 동일하다.

195
00:08:57,250 --> 00:09:01,460
>> 내가 거기이 일을 떠나 보자
대신 잠시이 아래로 당깁니다.

196
00:09:01,460 --> 00:09:05,060
컴퓨터의 세계에서는,
우리는 0과 1이 있습니다.

197
00:09:05,060 --> 00:09:07,240
그래서 일이 그
변경하려면 어떻게되는거야?

198
00:09:07,240 --> 00:09:10,920
글쎄, 내 인간 세계에있어서,
십진법 12 월의 의미 (10)

199
00:09:10,920 --> 00:09:12,740
내 처분에 얼마나 많은 숫자가?

200
00:09:12,740 --> 00:09:15,270

201
00:09:15,270 --> 00:09:16,540
10, 오른쪽?

202
00:09:16,540 --> 00:09:17,880
0에서 9까지의 과정.

203
00:09:17,880 --> 00:09:21,210
>> 우리는이 이유입니다
10의 장소와 100의 장소.

204
00:09:21,210 --> 00:09:22,380
그건 어디에서 오는?

205
00:09:22,380 --> 00:09:24,430
음,이 0의 힘에 10입니다.

206
00:09:24,430 --> 00:09:28,440
따라서, 10 일의 전력으로 10
등 2의 전력 및합니다.

207
00:09:28,440 --> 00:09:32,110
당신은 당신의 열을 곱 유지
(10)에 의해, 단지 1 오프 시작

208
00:09:32,110 --> 00:09:33,700
여기에 오른쪽 일인치

209
00:09:33,700 --> 00:09:35,490
>> 의 세계에 따라서
컴퓨터, 당신의 경우 만

210
00:09:35,490 --> 00:09:39,600
binary-- 이중 의미를 가지고있다
2-- 또는 0과 1의 우리 단지

211
00:09:39,600 --> 00:09:42,420
정말 변경해야
그 수학의 기초.

212
00:09:42,420 --> 00:09:46,410
그래서 즉, 지금 우리는거야
짓이야 1의 열을 가지고

213
00:09:46,410 --> 00:09:51,270
이것은 2의 열을 딴 데 어디
4의 열, 어쩌면 넘어.

214
00:09:51,270 --> 00:09:52,250
그 이유는 무엇입니까?

215
00:09:52,250 --> 00:09:55,650
그런데, 이것은 0 승 2.

216
00:09:55,650 --> 00:09:57,270
이 2 일입니다.

217
00:09:57,270 --> 00:09:59,610
이것은 등등 2~2이고.

218
00:09:59,610 --> 00:10:04,910
>> 여기 반면 그래서, 우리는 1, 10 년대 가지고,
100의 1000의 10,000의, 10의 1

219
00:10:04,910 --> 00:10:10,560
등, 여기에 수백만하고,
우리는 1, 2, 4, 8, 16, 32, 64가있다.

220
00:10:10,560 --> 00:10:13,950
당신은, 2를 곱 유지
대신에 10을 곱한 유지.

221
00:10:13,950 --> 00:10:16,780
그래서 지금, 목표의 경우
손 대표하는 것입니다

222
00:10:16,780 --> 00:10:20,240
단지 0과 1의 사용 숫자
의 우리가 거​​기에 도착하는 방법을 살펴 보자.

223
00:10:20,240 --> 00:10:26,540
>> 물론, 이것은 패턴 0
0 0하지만 어떤 숫자 개념

224
00:10:26,540 --> 00:10:27,490
이 대표는 무엇입니까?

225
00:10:27,490 --> 00:10:35,430
음, 4 회 0 플러스 2 회 0 플러스
1 시간 0,의 함께 사람들을 추가 할 수 있습니다.

226
00:10:35,430 --> 00:10:40,030
4 회 공은 물론, 0, +2
시간 0 물론 0 더하기 1 시간 0

227
00:10:40,030 --> 00:10:40,850
물론, 0이다.

228
00:10:40,850 --> 00:10:44,910
그래서 아,이 나타내는
수 우리 인간은 0으로 알고있다.

229
00:10:44,910 --> 00:10:47,810
>> 글쎄, 지금의 아주 보자
빨리 빨리 감기.

230
00:10:47,810 --> 00:10:53,600
내가 대신 표현하고 있지 않다 경우
0 0 0 만의 할 수 있도록 1 0 1,

231
00:10:53,600 --> 00:10:57,010
즉이 될 수있는 방법을 Lakisa, 이전,
그냥 1 0 1 발음 것입니다.

232
00:10:57,010 --> 00:11:01,020
하지만 지금, 우리는 어떻게 이상으로 가져가 않습니다
우리 인간이 알 수있는 번호를 수준​​?

233
00:11:01,020 --> 00:11:04,220
그래서이 숫자는 무엇입니까?

234
00:11:04,220 --> 00:11:06,060
그것은 오, 우리가 5로 알 수 있습니다.

235
00:11:06,060 --> 00:11:06,870
>> 글쎄, 그건 왜?

236
00:11:06,870 --> 00:11:09,620
글쎄, 우리가 할 수있는 정말 종류의
질서 그것을 통해 도보

237
00:11:09,620 --> 00:11:14,880
4 회 1, 2 회 0, 1 회 1.

238
00:11:14,880 --> 00:11:19,880
그래서 함께 그 추가
이 4 더하기 0 더하기 1입니다.

239
00:11:19,880 --> 00:11:21,577
그리고 5, 참입니다.

240
00:11:21,577 --> 00:11:24,660
그래서 지금은 조금 지루한지고있어
또 다시 연산을 수행.

241
00:11:24,660 --> 00:11:26,300
그러나이 과정은 동일하다.

242
00:11:26,300 --> 00:11:28,380
>> 이 유일한
우리의 세계에서 변경

243
00:11:28,380 --> 00:11:32,740
우리 열 있다는 1, 2, 4, 8, 16,
등 대신 1, 10, 100,

244
00:11:32,740 --> 00:11:33,740
1000.

245
00:11:33,740 --> 00:11:40,000
우리의 알파벳이 있기 때문에 그리고 그것은 단지
그냥 0에서 1로 9 0에서 축소.

246
00:11:40,000 --> 00:11:50,851
>> 여기에 약간의 퀴즈, 방법은 것 같은 그래서
당신은 바이너리 숫자 7을 나타냅니다?

247
00:11:50,851 --> 00:11:51,350
0?

248
00:11:51,350 --> 00:11:53,490
음, 0, 당신은 0 0 0 의미?

249
00:11:53,490 --> 00:11:58,140

250
00:11:58,140 --> 00:11:59,693
다시 카리나을 말해봐.

251
00:11:59,693 --> 00:12:03,010

252
00:12:03,010 --> 00:12:03,550
완전한.

253
00:12:03,550 --> 00:12:04,370
그 이유는 무엇입니까?

254
00:12:04,370 --> 00:12:08,530
그것은 효과적으로 4 플러스 2 플러스 1입니다.

255
00:12:08,530 --> 00:12:09,580
그래서 좋아.

256
00:12:09,580 --> 00:12:14,364
>> 우리는 조금을 표현하려면 어떻게
another-- 방법 번호 2에 대한?

257
00:12:14,364 --> 00:12:18,360

258
00:12:18,360 --> 00:12:20,690
닫기하지만, 거꾸로.

259
00:12:20,690 --> 00:12:21,660
그래서 이것은 무엇입니까?

260
00:12:21,660 --> 00:12:26,290
즉 다시 5 그래서, 4 플러스 1입니다.

261
00:12:26,290 --> 00:12:28,310
>> 그래서 미안 해요 what's--, 카리나?

262
00:12:28,310 --> 00:12:29,220
0 1 0.

263
00:12:29,220 --> 00:12:34,762
0 1 0도 있기 때문에, 다시이 될
그것은 일종의 당신을 뛰어하지 않는 경우,

264
00:12:34,762 --> 00:12:35,470
단지 수학을.

265
00:12:35,470 --> 00:12:40,390
4 시간 0, 0, 2 회
1 0 0 1 2 배이다.

266
00:12:40,390 --> 00:12:42,830
그래서 이것은 우리가 2로 알 수입니다.

267
00:12:42,830 --> 00:12:44,030
>> 어떻게 숫자 8은 어떻습니까?

268
00:12:44,030 --> 00:12:51,240

269
00:12:51,240 --> 00:12:52,730
흠?

270
00:12:52,730 --> 00:12:53,330
좋은.

271
00:12:53,330 --> 00:12:56,130
그래서 우리는 종류의 다른 자리가 필요합니다.

272
00:12:56,130 --> 00:12:59,570
우리는 1 0 0 0이 필요합니다.

273
00:12:59,570 --> 00:13:02,280
그리고 그것은 우리의 종류의 사실
오래된 학교 진수 시스템.

274
00:13:02,280 --> 00:13:05,280
어떻게 번호 1000를 표현합니까?

275
00:13:05,280 --> 00:13:08,480
>> 글쎄, 당신은 할 것 같다
가지 힘든 자리에,

276
00:13:08,480 --> 00:13:10,390
경우에하는 것은 표현하도록 요청
수 천,

277
00:13:10,390 --> 00:13:14,960
당신처럼 자신을 포기하더라도 때문에
이 9, 이들 중 9, 이들의 0,

278
00:13:14,960 --> 00:13:18,730
있는 가장 큰 숫자가 당신
이, 당신은 꽤 1,000하지 않았다.

279
00:13:18,730 --> 00:13:26,920
그래서 1000, 당신은 또 다른 필요
위치, 그래서 당신은 1 0 0 0 작업을 수행 할 수 있습니다

280
00:13:26,920 --> 00:13:29,460
ERGO 수 1,000.

281
00:13:29,460 --> 00:13:34,200
>> 그래서 지금, 이제 이런 종류의지도를 보자
다시 하드웨어에 대한 개념적 논의

282
00:13:34,200 --> 00:13:37,470
여기서 다시, 상기 입력은했다
이 작은 전원 케이블, 전기

283
00:13:37,470 --> 00:13:39,300
들어오는 및 유출.

284
00:13:39,300 --> 00:13:44,740
그리고 그 여기에서 매핑 할
거기에, 음, 우리가 정말 무엇을해야합니까?

285
00:13:44,740 --> 00:13:49,460
글쎄, 당신은 내부에있는 생각할 수있는
컴퓨터, 전구의 전체 무리,

286
00:13:49,460 --> 00:13:50,450
당신이됩니다.

287
00:13:50,450 --> 00:13:52,040
그들은 정말 트랜지스터를 호출하고 있습니다.

288
00:13:52,040 --> 00:13:55,121
그리고 트랜지스터는 스위치입니다
그 또는 해제 할 수 있습니다.

289
00:13:55,121 --> 00:13:56,870
그래서 당신은 생각할 수
에서의 트랜지스터

290
00:13:56,870 --> 00:14:00,730
전기가 흐르게되고
중지로 꺼져 트랜지스터

291
00:14:00,730 --> 00:14:02,170
흐르는에서 전기.

292
00:14:02,170 --> 00:14:04,130
그리고 걸릴보다는
여기에 조명을 통해,

293
00:14:04,130 --> 00:14:06,450
왜 내가 이런 종류의 작업을 수행하지 않습니다
새로운 학교 스타일.

294
00:14:06,450 --> 00:14:11,360
그래서 이것은 1, 손전등 수 있습니다
만 거의하지만,에있는.

295
00:14:11,360 --> 00:14:14,050
그리고 이것은 0이 될 수도, 지금은 해제입니다.

296
00:14:14,050 --> 00:14:18,277
>> 그래서이 물리적 장치를 사용하여, I
지금 이진 시스템을 나타낼 수 있습니다.

297
00:14:18,277 --> 00:14:19,235
난 그냥이 상태가 필요합니다.

298
00:14:19,235 --> 00:14:21,660
그것은 무엇을 중요하지 않습니다
그것은 또는 무엇 인 색상.

299
00:14:21,660 --> 00:14:25,920
모든 문제는 내가 가지고있다
하나의 상태와 다른 상태 끕니다.

300
00:14:25,920 --> 00:14:30,605
그래서 여기 내 전화를 사용하여, 어떻게 할
우리가 0으로 알고 수를 나타냅니다?

301
00:14:30,605 --> 00:14:34,490

302
00:14:34,490 --> 00:14:38,550
또는, 동등하게 넣어 무엇을
수는 지금을 나타내는입니까?

303
00:14:38,550 --> 00:14:39,810
0 장치가 꺼져 있기 때문이다.

304
00:14:39,810 --> 00:14:41,560
>> 그리고 나는이 작업을 수행 할 경우?

305
00:14:41,560 --> 00:14:43,583
이제 어떻게 할
숫자 2를 나타냅니다?

306
00:14:43,583 --> 00:14:46,380

307
00:14:46,380 --> 00:14:50,930
나는 휴대 전화를 빌릴 수
여기, 우리가 어제처럼?

308
00:14:50,930 --> 00:14:58,490
내가 표현하고 싶은, 그래서 만약 그렇다면, 어디 보자
숫자 2이 숫자 2인가?

309
00:14:58,490 --> 00:14:59,050
아니.

310
00:14:59,050 --> 00:15:02,250
무슨 수를 실수로 I 오전
여기 나타내는?

311
00:15:02,250 --> 00:15:03,550
이것은 실제로 숫자 3이다.

312
00:15:03,550 --> 00:15:05,008
>> 그래서 어느 내가 해제 하시겠습니까?

313
00:15:05,008 --> 00:15:09,634
잘 or-- 검은 전화, they're-- 경우
검은 전화 또는 백색 전화?

314
00:15:09,634 --> 00:15:10,300
흰색 전화.

315
00:15:10,300 --> 00:15:17,020
그래서 나는이를 끄고 경우 우리
여기에 라인 그것을, 우리는 하나가

316
00:15:17,020 --> 00:15:19,487
2의 장소 및
1의 자리에 0.

317
00:15:19,487 --> 00:15:21,195
그래서 지금이야
숫자 2를 나타내는.

318
00:15:21,195 --> 00:15:24,680
이것은 물론, 숫자 것
3,이 빛의 지금 모두 때문에

319
00:15:24,680 --> 00:15:25,350
에 있습니다.

320
00:15:25,350 --> 00:15:27,480
>> 그리고, 여기에서 중단됩니다
그러나 그것은 추론하기 위하여 서

321
00:15:27,480 --> 00:15:31,100
나는를 표현하려면
번호 4 또는 8 이상,

322
00:15:31,100 --> 00:15:32,529
나는 더 많은 전화를 필요 해요.

323
00:15:32,529 --> 00:15:33,820
그러나 그것은 무슨 일이 전부입니다.

324
00:15:33,820 --> 00:15:37,800
그렇다면 당신은 이제까지 들었어요
할까 .. 내부에 방송 해요 컴퓨터를 감사

325
00:15:37,800 --> 00:15:42,269
수백만 개의 트랜지스터가, 그건입니다
작은 작은 스위치 단지 수백만.

326
00:15:42,269 --> 00:15:44,310
그리고 그들은 빛 아니에요
에와 해제 전구,

327
00:15:44,310 --> 00:15:48,340
하지만 그들은 하나 전기를 허용합니다
어딘가 흐름하거나 중지합니다.

328
00:15:48,340 --> 00:15:52,140
그리고 당신이이 있어요
또는 해제, 또는 해제 states--.

329
00:15:52,140 --> 00:15:55,730
>> 그래서 우리는 지금 것 같다
이 능력을 가지고

330
00:15:55,730 --> 00:16:00,590
이 개념을 표현하는 그
우리는 실제 하드웨어에 싶습니다.

331
00:16:00,590 --> 00:16:05,520
하지만 우리가 지금 가지고있는 모든 능력이다
이 보일 것입니다 수를 나타냅니다.

332
00:16:05,520 --> 00:16:08,580
그래서 우리는 표현에 대해 어떻게 가야합니까
알파벳의 문자, 어떤

333
00:16:08,580 --> 00:16:12,310
기능의 다음 종류의 느낌 당신
현대 컴퓨터에 추가 할 것

334
00:16:12,310 --> 00:16:14,280
당신은 번호가하면?

335
00:16:14,280 --> 00:16:16,930
>> 그리고 실제로, 당신이 생각하는 경우
그것은 역사적으로, 컴퓨터

336
00:16:16,930 --> 00:16:19,426
역할을 정말로 도입
로 수치 계산기들.

337
00:16:19,426 --> 00:16:21,300
그러나 물론,이
일, 그들은 훨씬 더 많은 일을 할.

338
00:16:21,300 --> 00:16:23,799
그들은 당신에게 부팅 할 경우에도
일반적으로 하나 이상의 단어를 참조하십시오.

339
00:16:23,799 --> 00:16:27,420
그렇다면 당신은 단어를 표현합니까,
당신이 가지고있는 모든 경우, 다시,

340
00:16:27,420 --> 00:16:31,054
의 마지막 전력
일, 또는 동일하게 0과 1의?

341
00:16:31,054 --> 00:16:34,430

342
00:16:34,430 --> 00:16:35,690
>> 네.

343
00:16:35,690 --> 00:16:38,320
그래, 내 말은, 우리는 가지 않았다
어떤 형태이 어제,

344
00:16:38,320 --> 00:16:40,200
여기서 어떤 점에서,
내가 임의로 I 생각

345
00:16:40,200 --> 00:16:46,741
우리가를 표현하려면,했다
편지 A, 우리는 단지 한 것을 호출 할 수 있습니다.

346
00:16:46,741 --> 00:16:49,990
또한, 암호화의 상황에 있었다
여기서 우리는 단지 코드의 일종 필요

347
00:16:49,990 --> 00:16:51,160
매핑의 일종.

348
00:16:51,160 --> 00:16:56,680
>> 그래서 어쩌면는로 표현 될
1, 및 B는 2로 표현 될

349
00:16:56,680 --> 00:17:01,560
Z는 표시됩니다
예를 들어 26, 등.

350
00:17:01,560 --> 00:17:07,430
그리고 유일하게주의해야 할 점은 난 경우이다
내 이메일에 문자를 인코딩하는 것

351
00:17:07,430 --> 00:17:10,430
또는 내 문자 메시지에
번호와 같은, 당신의 모든

352
00:17:10,430 --> 00:17:12,640
를 사용하도록 동의해야
규칙의 동일한 세트.

353
00:17:12,640 --> 00:17:14,619
그리고 실제로, 세계
정확히을했다.

354
00:17:14,619 --> 00:17:18,040
>> 세계의 시스템이있다
라는 ASCII, 미국 표준

355
00:17:18,040 --> 00:17:21,640
정보 교환을위한 코드,
이는 단순히 몇 년 결정이다

356
00:17:21,640 --> 00:17:25,720
인간은 만든 전에하는 것이
A가 아닌 동일 할 것입니다 결정

357
00:17:25,720 --> 00:17:32,260
1, 2, 26, 그래서 그것의 forth--
different-- 작은하지만 65, 66, 67.

358
00:17:32,260 --> 00:17:34,010
그리고 난 끌어거야
그냥 순간에 차트.

359
00:17:34,010 --> 00:17:34,580
그러나 임의입니다.

360
00:17:34,580 --> 00:17:36,329
그러나 그것은 중요하지 않습니다
그것이 임의입니다.

361
00:17:36,329 --> 00:17:38,620
세계는 일관성이 있어야한다.

362
00:17:38,620 --> 00:17:40,540
>> 이제, 최근
애호가 뭔가가있다

363
00:17:40,540 --> 00:17:45,430
유니 코드라는 세계의 종류 때문에
의는 컴퓨터를 발명 한 후, 실현

364
00:17:45,430 --> 00:17:50,977
잘보다가 있음
세계 256 문자

365
00:17:50,977 --> 00:17:53,560
우리가 표현 할 수 있음을,
특히 당신이 소개

366
00:17:53,560 --> 00:17:58,420
아시아 언어 및 기타 바코드
그게 당신보다 더 표현력이 필요합니다

367
00:17:58,420 --> 00:18:02,150
의 초기 버전에 맞게 수
ASCII 불렀다 코드.

368
00:18:02,150 --> 00:18:05,250
그래서 유니 코드는 실제로 수 있습니다
당신은 더 많은 0과 2 사용할 수 있습니다.

369
00:18:05,250 --> 00:18:08,830
특히, 당신은 듣고 계속
워드 바이트 사회에서, 심지어 단지

370
00:18:08,830 --> 00:18:09,400
어제.

371
00:18:09,400 --> 00:18:12,040
그리고 바이트는 무엇을 다시입니까?

372
00:18:12,040 --> 00:18:14,840
>> 바이트는 무엇입니까?

373
00:18:14,840 --> 00:18:15,700
그것은 단지 8 비트입니다.

374
00:18:15,700 --> 00:18:17,150
그래서 정말 무엇을 의미합니까?

375
00:18:17,150 --> 00:18:22,400
글쎄, 그 이전에, 의미, 우리가있을 때
이진에 대해 이야기하고 내가 사용하고 있었다

376
00:18:22,400 --> 00:18:28,010
임의의 3 비트 우리가 있었던
1의 자리 binary--에 대해 얘기,

377
00:18:28,010 --> 00:18:33,600
2의 장소, 그리고 4의 place-- 아니라,
바이트는 당신이 이야기하고 있다는 것을 의미

378
00:18:33,600 --> 00:18:38,730
하지 세 단위이지만
넷, 다섯, 여섯, 일곱 여덟

379
00:18:38,730 --> 00:18:46,910
이는 우리에게 8의 장소를 제공,
16 년대, 32 년대, 64 년대, 128의.

380
00:18:46,910 --> 00:18:50,010
>> 즉, 모든 비트가 아닌
그 측정의 유용한 단위,

381
00:18:50,010 --> 00:18:53,132
그것은 단지 하나의 작은 작은처럼 때문에
정보의 조각, 또는 해제.

382
00:18:53,132 --> 00:18:54,840
그래서 몇 년 전에,
세계는 결정

383
00:18:54,840 --> 00:18:59,060
그것은의 이야기를 조금 더 편리
바이트로 환산 한 번에 여덟 가지.

384
00:18:59,060 --> 00:19:01,670
그리고 이렇게 태어났다
바이트의 개념.

385
00:19:01,670 --> 00:19:03,640
그래서 우리는 여기에 8 비트가 있습니다.

386
00:19:03,640 --> 00:19:06,810
>> 그리고 비슷한 위해,도 밝혀
이유는, 세계는 년 결정

387
00:19:06,810 --> 00:19:12,439
전 그는 ASCII 문자를 표현하기 위해,
당신은 8 비트의 단위를 사용하는 것입니다.

388
00:19:12,439 --> 00:19:14,230
당신이하지 않도록 경우에도
당신이있어, 많은 필요

389
00:19:14,230 --> 00:19:18,130
항상에 8 비트를 사용하는 것
알파벳 문자를 나타냅니다.

390
00:19:18,130 --> 00:19:20,950
그리고 이것은, 편리
다음 당신 때문에 경우

391
00:19:20,950 --> 00:19:28,720
0 0 0 1 1이 메시지를 수신
1 1 0 다른 1 1 1 0 1 0이어서

392
00:19:28,720 --> 00:19:33,320
0 1, 그래서 당신은 (16)을받는 경우
비트, 세계는 수

393
00:19:33,320 --> 00:19:37,460
제 8 문자를 하나 있다고 가정
및 제 8 다른 문자이다.

394
00:19:37,460 --> 00:19:39,240
>> 얼마나 많은 문제가되지 않습니다.

395
00:19:39,240 --> 00:19:41,460
그냥하는 것이 중요
우리는 일관성을

396
00:19:41,460 --> 00:19:42,950
때 우리가이 비트를 해석하고 있습니다.

397
00:19:42,950 --> 00:19:44,377
그리고 이것은 무작위했다.

398
00:19:44,377 --> 00:19:47,210
즉, 무언가를 의미하지만 나는하지 않았다
정말 무엇을 의미하는지에 대해 생각합니다.

399
00:19:47,210 --> 00:19:49,620
>> 그래서 작은 거짓말입니다.

400
00:19:49,620 --> 00:19:51,990
원래는, ASCII
실제로 단지 7 비트를 사용했다.

401
00:19:51,990 --> 00:19:54,180
그리고 8 번째 비트입니다
확장 된 ASCII했다.

402
00:19:54,180 --> 00:19:56,290
그러나 중요한 점은 궁극적으로 동일하다.

403
00:19:56,290 --> 00:19:58,850
세계에서 일반적으로
8 비트 표준화.

404
00:19:58,850 --> 00:20:04,290
>> 그래서이 좀 될 것 같다
때문에 나는 단지 수 제한

405
00:20:04,290 --> 00:20:07,970
자본 A를 나타냅니다
자본 Z를 통해 자본 B

406
00:20:07,970 --> 00:20:10,940
그러나 실제로하지, 내가 가면 건 ...
자원의 무리가있다

407
00:20:10,940 --> 00:20:13,695
온라인, 예를 들면,
asciitable.com,이

408
00:20:13,695 --> 00:20:16,310
조금 될 것입니다
처음에는 압도적.

409
00:20:16,310 --> 00:20:18,910
하지만 지적합니다
무슨 일이 중요합니다.

410
00:20:18,910 --> 00:20:24,090
>> 그냥 일이 이따가하고 난거야
walk-- 내가 이상 여기 가면의가 보자.

411
00:20:24,090 --> 00:20:27,990
여기에 소수점에서,
열, 수 65.

412
00:20:27,990 --> 00:20:32,201
오른손 칼럼 서신
문자, 대하은 문자 A.입니다

413
00:20:32,201 --> 00:20:34,450
그리고 당신은, 지금은 무시할 수 있습니다
중간에 모든 것을.

414
00:20:34,450 --> 00:20:36,769
이것은 16 진수,
8 진수와 HTML 코드입니다.

415
00:20:36,769 --> 00:20:39,810
이 사이트에 그냥 던져하려고
에서 한 번에 많은 정보.

416
00:20:39,810 --> 00:20:42,970
그러나 우리는 걱정 모두 소수이다
열 및 문자 열.

417
00:20:42,970 --> 00:20:46,190
>> 따라서이 논리에 의해, 무엇이다
세계가 수

418
00:20:46,190 --> 00:20:50,510
A A 소문자가 대표로 결정했다?

419
00:20:50,510 --> 00:20:52,230
97 그래.

420
00:20:52,230 --> 00:20:55,850
그리고 단지 혼동
잠재적 약간,

421
00:20:55,850 --> 00:21:03,715
무슨 수를 세계로 결정했다
숫자 1을 나타내는 것?

422
00:21:03,715 --> 00:21:06,900

423
00:21:06,900 --> 00:21:10,910
오른쪽, 우우 49 때문 보인다
여기에, 아래로 아래에서 왼쪽.

424
00:21:10,910 --> 00:21:12,320
>> 지금, 나는 그 무엇을 의미합니까?

425
00:21:12,320 --> 00:21:14,830
그래서 그것은 밝혀
컴퓨터 시스템에있어서,

426
00:21:14,830 --> 00:21:16,840
일반적으로이
근본적인 차이

427
00:21:16,840 --> 00:21:19,920
숫자와 문자 간의.

428
00:21:19,920 --> 00:21:22,330
숫자는 일이 우리
학습을 할 때 성장

429
00:21:22,330 --> 00:21:23,830
우리는 초등학교에서 슈퍼 젊은했다.

430
00:21:23,830 --> 00:21:25,110
그것은 당신이 계산 일을합니다.

431
00:21:25,110 --> 00:21:30,220
그러나 문자는 단지 형상은이고,
글리프, 그래서 화면에, 말을합니다.

432
00:21:30,220 --> 00:21:36,200
>> 이제, 우리는 종류의 참조 인간이
이처럼 보이는 뭔가.

433
00:21:36,200 --> 00:21:39,060
그리고 우리는 아, 수 2, 말한다.

434
00:21:39,060 --> 00:21:44,999
하지만, 그 보이는 단지 상징이다
우리는 숫자 2로 알고있다.

435
00:21:44,999 --> 00:21:46,790
그래서이있다
근본적인 차이

436
00:21:46,790 --> 00:21:50,340
실제 숫자와 문자 사이.

437
00:21:50,340 --> 00:21:52,130
이 숫자입니다.

438
00:21:52,130 --> 00:21:54,420
그러나 일반적으로
컴퓨터 문맥

439
00:21:54,420 --> 00:21:56,809
대신 볼 경우
이 quoted-- 같은

440
00:21:56,809 --> 00:21:58,600
그리고 당신은 항상하지 않습니다
이 인용 참조해야

441
00:21:58,600 --> 00:22:01,474
하지만 discussion--을 위해 경우에 대한
당신은 숫자 주위에 따옴표를 참조

442
00:22:01,474 --> 00:22:02,730
이 이제 문자입니다.

443
00:22:02,730 --> 00:22:06,330
그래서이 2 번 아래
컴퓨터의 내부 후드

444
00:22:06,330 --> 00:22:12,220
패턴으로 표현 될 것이다
개수를 나타내는 비트

445
00:22:12,220 --> 00:22:14,850
50 온라인 차트에 따라.

446
00:22:14,850 --> 00:22:18,300
>> 그러나, 만약 컴퓨터
그냥,이를보고

447
00:22:18,300 --> 00:22:24,580
로 표현된다
비트 0 0 0 0 0 0 1 0 패턴.

448
00:22:24,580 --> 00:22:29,595
반면,이 문자는 것
실제로 as-- 지금 표현,

449
00:22:29,595 --> 00:22:34,710
나는이 그래서 조금 harder--을 생각하고있어
문자는 0으로 표현 될 것이다

450
00:22:34,710 --> 00:22:39,080
0 1-- 나는 여기에 무엇을해야합니까?

451
00:22:39,080 --> 00:22:44,450
0 0 1 1 0 0 1 0.

452
00:22:44,450 --> 00:22:45,480
어떻게 이런 짓을 한거야?

453
00:22:45,480 --> 00:22:49,580
그런데이 숫자 50, 당신의 경우
이러한 열을 사용하여 그것을 곱하면,

454
00:22:49,580 --> 00:22:53,530
이 2 번이고, 그래서
이 이분법이 이유입니다.

455
00:22:53,530 --> 00:22:55,850
>> 그리고 이것은 단지입니다
기능에 대한 지금 맛보기

456
00:22:55,850 --> 00:22:59,710
프로그래밍 언어에 있는지
우리는 나중에 오늘에 잠시 터치거야.

457
00:22:59,710 --> 00:23:01,950
프로그래밍 언어에서,
당신은, 일반적으로이

458
00:23:01,950 --> 00:23:04,495
항상은 아니지만, 물건
다른 데이터 유형을 호출합니다.

459
00:23:04,495 --> 00:23:06,870
즉, programmer--
때 그 또는 그녀가 쓰고,

460
00:23:06,870 --> 00:23:11,150
프로그래머는에 결정을 얻는 것
형식은 자신의 데이터를 저장합니다.

461
00:23:11,150 --> 00:23:14,120
할 수 있습니다하거나 데이터를 저장 등
숫자 2와 같은 원시 번호.

462
00:23:14,120 --> 00:23:17,940
아니면 문자열로 저장할 수 있습니다,
또는 문자 시퀀스

463
00:23:17,940 --> 00:23:21,550
당신은 일반적으로 표현하는 것
프로그래밍 언어의 따옴표.

464
00:23:21,550 --> 00:23:25,230
>> 당신은 일을 할 수 called--
나는 지나치게 단순화하고 전화 할게

465
00:23:25,230 --> 00:23:28,870
숫자 진짜 numbers-- 그
숫자 2와 같은하지의 정수이고,

466
00:23:28,870 --> 00:23:31,310
하지만 숫자는 4.56를 좋아한다.

467
00:23:31,310 --> 00:23:33,490
그래서 실수도 할 수
소수점을 가지고,

468
00:23:33,490 --> 00:23:36,340
그래서 근본적인 다른입니다
컴퓨터에있는 데이터의 조각.

469
00:23:36,340 --> 00:23:41,920
그리고 당신도 할 수 있습니다
또 다른 데이터 유형.

470
00:23:41,920 --> 00:23:45,810
그래서 정말 그냥 맛보기입니다
디자인 결정의 간단한

471
00:23:45,810 --> 00:23:50,960
프로그래머가 수도
후드 아래합니다.

472
00:23:50,960 --> 00:23:52,925
>> 그래서 질문이 아직?

473
00:23:52,925 --> 00:23:57,320

474
00:23:57,320 --> 00:23:59,860
그럼 만들려고하자
이 좀 더 현실.

475
00:23:59,860 --> 00:24:02,120
이 하드웨어는 아니다
더 이상 사용 그렇게.

476
00:24:02,120 --> 00:24:07,420
그러나 아마이 방에있는 대부분의 사람들
함께 성장하고 여전히 하드 드라이브를 사용

477
00:24:07,420 --> 00:24:08,010
몇 가지 방법입니다.

478
00:24:08,010 --> 00:24:10,100
>> 심지어 대부분의 생각
우리의 노트북 더 이상 없다

479
00:24:10,100 --> 00:24:15,900
이 같은 작동 장치가
대신 일반적으로 오늘 랩탑

480
00:24:15,900 --> 00:24:18,590
솔리드 스테이트 드라이브가
움직이는 부품.

481
00:24:18,590 --> 00:24:22,840
그리고 더 비싼 경향
불행하게도, 그러나 조금 더 빨리

482
00:24:22,840 --> 00:24:27,230
및 할까 .. 잘, 자주, 훨씬 빨리,
하는 이유 중 하나입니다.

483
00:24:27,230 --> 00:24:28,980
또한 그렇지 않습니다
많은 열을 발생.

484
00:24:28,980 --> 00:24:31,680
그것은 그래서 그것은 작을 수있다
긍정적 일반적으로 그물.

485
00:24:31,680 --> 00:24:35,030
>> 그러나 이것은 우리가를 매핑 할 수 있습니다
좀 더 구체적으로 무엇을

486
00:24:35,030 --> 00:24:38,460
우리가 공의에 대해 얘기하고
물리적 장치에 지금 1의 수준입니다.

487
00:24:38,460 --> 00:24:40,810
그것은 나를 이야기 할 한 가지
환산으로 약 0과 1의

488
00:24:40,810 --> 00:24:43,990
내 전화 또는 추상적 측면에서
의와 떨어져있는 전환됩니다.

489
00:24:43,990 --> 00:24:45,340
그러나 하드 드라이브에 대한?

490
00:24:45,340 --> 00:24:48,495
당신의 노트북에, 당신은 이전이있는 경우
하나, 또는 데스크톱 컴퓨터에서,

491
00:24:48,495 --> 00:24:51,200
또는 확실히 서버에서
오늘, 당신은 어디를가

492
00:24:51,200 --> 00:24:53,070
이 하드 드라이브
공간의 테라 바이트,

493
00:24:53,070 --> 00:24:55,560
공간의 4 테라 바이트,
물론 그게 무슨 뜻 이죠?

494
00:24:55,560 --> 00:24:59,560
>> 1를 가진 하드 드라이브
공간 수단 테라

495
00:24:59,560 --> 00:25:03,890
1 조 바이트가있다
어떻게 든 내부,

496
00:25:03,890 --> 00:25:10,450
또는 동등 내부 8,000,000,000,000 비트.

497
00:25:10,450 --> 00:25:16,240
1 테라 바이트는 8 테라 비트 것
또는 1 조 비트있는

498
00:25:16,240 --> 00:25:19,330
하드 경우 의미
드라이브, 당신은 어떻게 든해야

499
00:25:19,330 --> 00:25:22,400
또는 다른 조 0의
그것의 1의 내부.

500
00:25:22,400 --> 00:25:25,360
그리고 우리는 단지를 살펴 경우
하드 드라이브의 임의의 사진

501
00:25:25,360 --> 00:25:30,110
대표는이 하드 무슨이다
드라이브는 일반적으로 내부처럼 보일 수 있습니다.

502
00:25:30,110 --> 00:25:32,600
>> 그것은, 너무, 가지처럼
오래된 축음기 플레이어

503
00:25:32,600 --> 00:25:35,350
그러나 일반적으로
내부의 여러 레코드, 그래서

504
00:25:35,350 --> 00:25:38,270
여러 speak--하기
플래터는, 그들은 호출하는 바와 같이,

505
00:25:38,270 --> 00:25:42,259
금속 원형 디스크,
다음 약간의 읽기 헤드,

506
00:25:42,259 --> 00:25:43,550
오래 된 레코드 플레이어 등 많은.

507
00:25:43,550 --> 00:25:46,589
그리고 읽기 헤드가 다시 이동하고
앞으로 어떻게 든 비트를 읽습니다.

508
00:25:46,589 --> 00:25:49,380
게다가,이 플래터에 무슨
우리 인간은 그들을 볼 수 있지만,

509
00:25:49,380 --> 00:25:52,757
하나 현실에서 또는이 그림에서,
작은 작은 자기 입자가있다.

510
00:25:52,757 --> 00:25:55,090
그리고 당신은 긴 한 경우에도
전기가 어떻게 작동하는지 잊어 버린,

511
00:25:55,090 --> 00:25:57,550
자성 입자
즉, 일반적으로 충전 된 것

512
00:25:57,550 --> 00:26:00,570
북쪽 끝과 남쪽이
그래서 북쪽과 남쪽 end--.

513
00:26:00,570 --> 00:26:03,000
그래서 세계 단지
몇 시간 전에 결정

514
00:26:03,000 --> 00:26:06,570
즉 본질적으로 자기 프로토콜 경우
이런 식으로 정렬, 남북,

515
00:26:06,570 --> 00:26:07,610
의는 1 것을 호출 할 수 있습니다.

516
00:26:07,610 --> 00:26:10,470
대신 남북 있다면,
그냥 0 것을 호출 할 수 있습니다.

517
00:26:10,470 --> 00:26:13,350
그리고 당신에있는 경우
당신의 처리 조

518
00:26:13,350 --> 00:26:16,300
작은 자기 작은
particles-- 희망,

519
00:26:16,300 --> 00:26:18,740
하드웨어 독창성에
순서는 주위 사람들을 플립합니다

520
00:26:18,740 --> 00:26:24,450
당신이 fit-- 볼 당신이 원하는 경우
당신을 공의의 모두를 나타냅니다

521
00:26:24,450 --> 00:26:28,120
단 8 자성 입자가 필요
모든 같이 정렬됩니다.

522
00:26:28,120 --> 00:26:30,330
그리고 당신이 표현하고 싶은 경우
팔 1의 경우 단지

523
00:26:30,330 --> 00:26:33,170
정렬 8 자성 입자가 필요
다시 다음과 같이 다시 백업합니다.

524
00:26:33,170 --> 00:26:35,515
>> 나는 무엇을 의미합니까
자성 입자?

525
00:26:35,515 --> 00:26:38,390
솔직히,이 모든 년 후,
아직도 내 마음에 오는 것

526
00:26:38,390 --> 00:26:42,139
이 사람은, 당신의 경우
이 일을 함께 자랐습니다.

527
00:26:42,139 --> 00:26:43,930
이에 대한 little--입니다
그 unfamiliar--

528
00:26:43,930 --> 00:26:47,810
작은 어린 시절 장난감 그
여기 사나이 사람이

529
00:26:47,810 --> 00:26:51,690
그 모든 작은 작은 검은 색을 가지고
그것은 함께 자성 입자.

530
00:26:51,690 --> 00:26:53,930
그리고 그 붉은 막대기를 사용하여,
이는 단지 자석,

531
00:26:53,930 --> 00:26:58,460
당신이 종류의 그에게 콧수염을 제공 할 수 있습니다 또는
눈썹이나 그에게 머리 또는 아무것도.

532
00:26:58,460 --> 00:27:00,710
그래서 사실, 우리는 확대하는 경우
예를 들어,이에

533
00:27:00,710 --> 00:27:02,950
게임의 종류 당신
털북숭이 윌리와 함께 재생할 수 있습니다.

534
00:27:02,950 --> 00:27:06,570
>> 그리고 이것은,이 말을 아니라
더 큰 자성 입자는

535
00:27:06,570 --> 00:27:09,890
이상은, 하드 드라이브에 실제로
훨씬 적은 자성 입자.

536
00:27:09,890 --> 00:27:11,640
그러나의 실제 보자
당신은이 경우

537
00:27:11,640 --> 00:27:14,720
A의 작은 자성 입자
하드 드라이브, 어떻게 당신이 실제로 수

538
00:27:14,720 --> 00:27:19,090
데이터를 표현하기 위해 그들을 사용합니다.

539
00:27:19,090 --> 00:27:20,070
>> [VIDEO 재생]

540
00:27:20,070 --> 00:27:24,190
>> 년 - 하드 드라이브가 어디 PC입니다
저장 영구 데이터의 대부분을.

541
00:27:24,190 --> 00:27:27,170
데이터를 그렇게하려면
따라서 RAM에서 이동

542
00:27:27,170 --> 00:27:31,720
에게 소프트웨어 신호와
하드 데이터를 저장하는 방법을 구동한다.

543
00:27:31,720 --> 00:27:36,570
하드 드라이브 회로는 그 번역
전압 변동에 신호.

544
00:27:36,570 --> 00:27:40,880
이, 차례로, 하드 드라이브의 제어
몇 이동의 일부를 파트로 나뉘는데 이동

545
00:27:40,880 --> 00:27:43,440
부품은 현대 컴퓨터에 남아.

546
00:27:43,440 --> 00:27:47,650
>> 신호의 일부는 모터를 제어
이는 금속 코팅 플래터를 회전합니다.

547
00:27:47,650 --> 00:27:50,980
데이터가 실제로
이 플래터에 저장됩니다.

548
00:27:50,980 --> 00:27:56,250
다른 신호는 판독 / 기록 헤드를 이동
읽거나 플래터에 데이터를 기록합니다.

549
00:27:56,250 --> 00:28:00,100
이 기계는 매우 정확
즉, 인간의 머리카락조차 할 수 없었다

550
00:28:00,100 --> 00:28:02,800
헤드 사이를 통과
와 플래터를 회전합니다.

551
00:28:02,800 --> 00:28:04,887
그러나, 모두가 훌륭한 속도로 작동합니다.

552
00:28:04,887 --> 00:28:05,470
[END 재생]

553
00:28:05,470 --> 00:28:06,780
그리고 당신은에서 볼 수있다
비디오의 꼬리 끝,

554
00:28:06,780 --> 00:28:08,340
여러 개의 플래터는 일반적으로있다.

555
00:28:08,340 --> 00:28:10,250
그리고 그 읽기 헤드
바로 가기를 읽을 수 없습니다.

556
00:28:10,250 --> 00:28:12,458
그것은 종류의 같은 세의
네 개 이상의 판독 헤드

557
00:28:12,458 --> 00:28:14,920
이 같은 그 이동,
동시에 데이터를 읽는.

558
00:28:14,920 --> 00:28:17,407
>> 그래서 많이있다
복잡성과 타이밍의 종류

559
00:28:17,407 --> 00:28:18,740
그는 하드 드라이브에 관여하는 것.

560
00:28:18,740 --> 00:28:21,920
그리고 것은 정말 이놈 돌고있다
빨리, 너무 많은 복잡성이있다.

561
00:28:21,920 --> 00:28:25,220
하지만 이제 좀 더 깊이 확대하자
이러한 자성 입자가있는 곳 참조

562
00:28:25,220 --> 00:28:27,370
어떻게 우리가 그들을 얻고있다.

563
00:28:27,370 --> 00:28:28,750
>> [VIDEO 재생]

564
00:28:28,750 --> 00:28:31,830
>> 에 - 가자 보면 우리
다만 슬로우 모션으로 보았다.

565
00:28:31,830 --> 00:28:35,230
경우 전기 짧은 펄스
판독 / 기록 헤드에 보내진다

566
00:28:35,230 --> 00:28:39,000
이는 소형​​ 전자에 플립
순식간합니다.

567
00:28:39,000 --> 00:28:41,390
자석이 만드는
변경 필드,

568
00:28:41,390 --> 00:28:44,600
작은, 작은의 극성
금속 입자의 일부

569
00:28:44,600 --> 00:28:46,960
어떤 코트 각 플래터의 표면을.

570
00:28:46,960 --> 00:28:50,020
이 작은의 패턴 시리즈
디스크까지 충전 영역

571
00:28:50,020 --> 00:28:54,590
에서 데이터의 단일 비트를 나타낸다
컴퓨터에서 사용 진수 시스템입니다.

572
00:28:54,590 --> 00:28:57,510
>> 이제, 전류를 보내지면
읽기 / 쓰기 헤드를 통해 길

573
00:28:57,510 --> 00:28:59,899
영역이 한 방향으로 편광된다.

574
00:28:59,899 --> 00:29:01,940
현재는 전송 된 경우
반대 방향으로,

575
00:29:01,940 --> 00:29:04,020
편광은 반전됩니다.

576
00:29:04,020 --> 00:29:06,440
어떻게 하드 디스크에서 데이터를받을 수 있나요?

577
00:29:06,440 --> 00:29:08,190
그냥 과정을 역.

578
00:29:08,190 --> 00:29:10,440
그래서상의 입자의
전류를 얻을 디스크

579
00:29:10,440 --> 00:29:12,260
판독 / 기록 헤드를 이동.

580
00:29:12,260 --> 00:29:14,580
함께 수백만을 넣어
이러한 자화 세그먼트,

581
00:29:14,580 --> 00:29:16,220
당신은 파일을 가지고있다.

582
00:29:16,220 --> 00:29:21,030
>> 이제, 하나의 파일의 조각 일 수있다
모든 드라이브의 플래터에 흩어져,

583
00:29:21,030 --> 00:29:24,060
이러한 종류의 혼란 등
당신의 책상에 서류.

584
00:29:24,060 --> 00:29:27,590
그래서 특별한 추가 파일은 유지
모든 곳의 트랙.

585
00:29:27,590 --> 00:29:30,440
할 당신은 당신이 가지고 싶어하지
뭐 그런?

586
00:29:30,440 --> 00:29:31,290
>> [END 재생]

587
00:29:31,290 --> 00:29:36,260
>> 그래서 아마도이며,이 언급되고
삭제 어제에서 해당 항목을 참조하십시오.

588
00:29:36,260 --> 00:29:38,380
당신은을 삭제하면
파일, 어제 우리는 말했다

589
00:29:38,380 --> 00:29:41,020
컴퓨터 실제로 않는다는 것을
무엇을, 당신이 뭔가를 드래그

590
00:29:41,020 --> 00:29:44,110
휴지통 또는 쓰레기통에?

591
00:29:44,110 --> 00:29:45,150
그것은 그냥 잊어.

592
00:29:45,150 --> 00:29:47,540
하지만 0과 1,
자성 입자

593
00:29:47,540 --> 00:29:50,640
빨간색과 파란색 등이 모습
여기 물건, 또는 여기에 내 팔,

594
00:29:50,640 --> 00:29:52,350
하드 드라이브에 여전히 존재한다.

595
00:29:52,350 --> 00:29:56,090
>> 그래서 software--이 존재
노턴 유틸리티 및 작년

596
00:29:56,090 --> 00:29:58,159
다른 현대
software-- 그 단지

597
00:29:58,159 --> 00:30:01,200
보고 전체 하드 드라이브를 검색합니다
모든 0 년대와 1의, 그것 때문에에

598
00:30:01,200 --> 00:30:06,890
밝혀 대부분의 파일 formats--
워드 문서, 엑셀 파일, 이미지,

599
00:30:06,890 --> 00:30:10,380
동영상은 모두 특정이 files--
그 (것)들의 사이에서 일반적인 패턴입니다.

600
00:30:10,380 --> 00:30:12,550
모든 비디오 파일 수도
다른 비디오의 수,

601
00:30:12,550 --> 00:30:14,870
그러나 처음 몇을
비트는 일반적으로 동일하다.

602
00:30:14,870 --> 00:30:16,790
또는 지난 몇 비트
일반적으로 동일합니다.

603
00:30:16,790 --> 00:30:19,910
>> 그리고 높은 확률로,
당신은 그 패턴을 볼 수 있습니다.

604
00:30:19,910 --> 00:30:23,700
그리고 파일은 잊어 버린 경우에도
당신은 높은 확률로 말할 수있다

605
00:30:23,700 --> 00:30:28,460
그러나 이것은, Word 문서처럼 보이는
그것을 복구를 취소 잊지 수 있습니다,

606
00:30:28,460 --> 00:30:28,990
당신이됩니다.

607
00:30:28,990 --> 00:30:32,330
그리고 그건 당신이 복구 할 수있는 방법
중 실수이었다 데이터

608
00:30:32,330 --> 00:30:36,560
삭제 또는 삭제 또는 의도적으로
어떤 목적을 위해 삭제.

609
00:30:36,560 --> 00:30:42,530
>> 대조적으로, 보안 삭제는 어떻게합니까
이 같은 사진의 맥락에서?

610
00:30:42,530 --> 00:30:44,059
정확히 그들에게 모든 임의한다.

611
00:30:44,059 --> 00:30:46,350
그래서 그것은 일종의의 일부를 이동
그 아래, 그들 중 일부는,

612
00:30:46,350 --> 00:30:49,433
그들 중 일부는 변경되지 않습니다, 그리고
일반적으로 그것의 랜덤 노이즈를 만들고,

613
00:30:49,433 --> 00:30:52,960
아니면 어쩌면 모든 만든다
그 공의하거나 1의 모든.

614
00:30:52,960 --> 00:30:56,350
그리고 너무 일반적으로 수
멀리 데이터를 문질러.

615
00:30:56,350 --> 00:31:00,160
>> 그래서이 문제에 지금 돌아 보자
전산 사고, 이에의

616
00:31:00,160 --> 00:31:03,270
우리는 수식 입력을 가지고있다.

617
00:31:03,270 --> 00:31:06,390
그리고 알고리즘 제공
당신은 궁극적으로 출력한다.

618
00:31:06,390 --> 00:31:09,270
우리는 입력에 지금 집중하고
출력 해주기 때문에, I

619
00:31:09,270 --> 00:31:12,159
제 우리는 방법을
입력과 출력을 나타내는.

620
00:31:12,159 --> 00:31:13,450
우리는 단지 바이너리를 사용하는 것입니다.

621
00:31:13,450 --> 00:31:15,910
>> 그리고 상관없이 우리
오늘 표현하려면,

622
00:31:15,910 --> 00:31:20,230
그것은 숫자 나 문자가 있는지 여부
전화 번호부에 그 또는 수천

623
00:31:20,230 --> 00:31:23,210
마지막에 이미지 나 동영상, 또는
오늘의, 모든 0과 1을입니다.

624
00:31:23,210 --> 00:31:26,640
그리고 주장, 심지어이 생각
다만 공의와 슈퍼 간단한 세계입니다

625
00:31:26,640 --> 00:31:28,240
1의, 우리는 우리 자신을 구축 할 수 있습니다.

626
00:31:28,240 --> 00:31:32,210
그리고 우리는 하나의 예를 본 적이
지금까지 편지와 그.

627
00:31:32,210 --> 00:31:35,615
>> 그래서이 지금 집중하자
중간 성분, 알고리즘.

628
00:31:35,615 --> 00:31:38,190
그리고 이제이로 돌아가 보자
마이크 스미스의 예.

629
00:31:38,190 --> 00:31:41,689
인정 하듯이 전화 번호부에 따라서,
우리는 더 이상 너무 많이 사용하지 않는,

630
00:31:41,689 --> 00:31:42,980
해결해야 할 문제가있다.

631
00:31:42,980 --> 00:31:45,040
우리는 마이크 스미스 같은 사람을 찾고 싶어요.

632
00:31:45,040 --> 00:31:47,520
>> 그리고 마이크를 찾기 위해 무엇을 할 수 있는가?

633
00:31:47,520 --> 00:31:51,197
글쎄, 난 그냥이를 열 수
책, 첫 페이지에서 시작

634
00:31:51,197 --> 00:31:52,780
그리고 오, 나는이 (가) 섹션에있어, 실현.

635
00:31:52,780 --> 00:31:53,510
마이크가 아니다.

636
00:31:53,510 --> 00:31:55,510
나는 스미스의 S 부분이 필요합니다.

637
00:31:55,510 --> 00:31:58,192
따라서 단지 한 번에 한 페이지를 돌리기.

638
00:31:58,192 --> 00:32:00,900
내가이 모든 것을 척하자
화이트 페이지 및 노란색하지 페이지,

639
00:32:00,900 --> 00:32:02,910
우리가 발견하지 않을거야 때문에
어쨌든 옐로우 페이지에서 마이크.

640
00:32:02,910 --> 00:32:04,034
하지만 난 화이트 페이지에 있어요.

641
00:32:04,034 --> 00:32:05,340
그리고 지금, 나는 B 섹션입니다.

642
00:32:05,340 --> 00:32:06,810
나는 아직도 그를 발견하지 않았습니다.

643
00:32:06,810 --> 00:32:08,890
그래서 한 번에 한 페이지를 돌리기.

644
00:32:08,890 --> 00:32:10,130
>> 이 알고리즘이다.

645
00:32:10,130 --> 00:32:12,440
이 지침의 집합이다
몇 가지 문제를 해결합니다.

646
00:32:12,440 --> 00:32:16,480
즉, 볼
페이지, 마이크 그것에 아니라면,

647
00:32:16,480 --> 00:32:20,020
페이지를 설정하고, 반복
다시 또 다시,

648
00:32:20,020 --> 00:32:21,760
당신이 그것을하고있는 것처럼 이상적으로 아래를 내려다 보면서.

649
00:32:21,760 --> 00:32:24,120
따라서이 알고리즘은,
올바른이 과정?

650
00:32:24,120 --> 00:32:27,400

651
00:32:27,400 --> 00:32:28,830
>> 죄송합니다.

652
00:32:28,830 --> 00:32:30,056
아니, 어떤 번호를들을 수 있습니다.

653
00:32:30,056 --> 00:32:33,250

654
00:32:33,250 --> 00:32:36,125
OK,하지만 그래 is--,
그것은 확실히 지루한입니다.

655
00:32:36,125 --> 00:32:39,000
마찬가지로, 우리는 하루 종일 내가 만약 여기있을거야
이 속도로 마이크를 찾고 유지.

656
00:32:39,000 --> 00:32:41,430
그러나 내가 그것을 맞습니다 주장 할 수 있습니다.

657
00:32:41,430 --> 00:32:43,850
그것은 바보, 그러나 그것은 맞습니다.

658
00:32:43,850 --> 00:32:47,209
>> 하루의 끝에서, 그것이 수도로서
그가 거기에 있다면 나는 마이크를 찾을 취

659
00:32:47,209 --> 00:32:48,250
내가 주목하고있다.

660
00:32:48,250 --> 00:32:50,230
그리고 나는 결국 자신의 페이지에 도달합니다.

661
00:32:50,230 --> 00:32:52,890
그리고 너무 멀리 얻을 경우, 경우
나는 T 섹션에 도착

662
00:32:52,890 --> 00:32:55,900
나는 약간 최적화 할 수 있습니다
단지 흠, 모두 다,라고.

663
00:32:55,900 --> 00:32:57,980
난 낭비 할 필요가 없습니다
시간은 Z의가는.

664
00:32:57,980 --> 00:33:00,010
그러나 이것은 매우이다
선형 접근, 당신 경우

665
00:33:00,010 --> 00:33:03,370
매우 종류의 왼쪽에서 오른쪽합니다
접근 방식, 직선.

666
00:33:03,370 --> 00:33:05,560
그리고 올바른하지만 천천히.

667
00:33:05,560 --> 00:33:09,250
>> 그래서 정렬, 초등학교에서 기억
제 학년에서 최적화,

668
00:33:09,250 --> 00:33:13,756
내가하지 계산하는 방법을 배운 곳
사람이 아니라 twos-- 그래서 2, 4, 6에 의하여.

669
00:33:13,756 --> 00:33:15,630
그것은 훨씬 더 열심히에, A의
수행하지만, 이론적으로, 그것의

670
00:33:15,630 --> 00:33:20,149
faster-- 8, 10, 12, 14, 등.

671
00:33:20,149 --> 00:33:21,190
어떻게 그 알고리즘에 대해?

672
00:33:21,190 --> 00:33:23,150
그것은 더 효율적인가요?

673
00:33:23,150 --> 00:33:23,880
더 빨리인가?

674
00:33:23,880 --> 00:33:25,365
>> 청중 : 그것은 효율적입니다.

675
00:33:25,365 --> 00:33:28,560
>> DAVID 마란 : 네, 그래서 그것의 def--있어
문자 그대로 배 빠른, 가정 I

676
00:33:28,560 --> 00:33:30,170
어떻게 내 손가락으로 위로 넘어되지.

677
00:33:30,170 --> 00:33:32,294
이 때문에, 두 배 빠른 속도입니다
나는 두 가지를 통해 온거야

678
00:33:32,294 --> 00:33:36,560
일단 하나 대신에 페이지이지만있어
잠재적으로 올바른에, 왜 때문에?

679
00:33:36,560 --> 00:33:37,852
>> 청중 : 당신은 몇 가지를 건너 뛰는 것입니다.

680
00:33:37,852 --> 00:33:41,185
DAVID 마란 : 오른쪽, 마이크가 발생할 경우 어떤
나중에있을 때 아마 sandwiched--한다

681
00:33:41,185 --> 00:33:44,370
전화 번호부에, 마이크는 될 일이
이 두 페이지 사이에 끼워,

682
00:33:44,370 --> 00:33:46,720
난 그냥 맹목적으로 그 위에 건너 뜁니다.

683
00:33:46,720 --> 00:33:48,490
그래서 우리는 거기에 약간의 수정이 필요합니다.

684
00:33:48,490 --> 00:33:51,290
나는 T 섹션을 명중하면, I
그냥 자신있게 말할 수 없다,

685
00:33:51,290 --> 00:33:52,420
우리는 마이크 스미스를 찾지 못했습니다.

686
00:33:52,420 --> 00:33:53,770
나는 아마 다시 두 배로해야합니다.

687
00:33:53,770 --> 00:34:00,210
아니면 사실, 한 번 누군가에 도달
스미스에 대한 S-N, 대신 S-M의 이름,

688
00:34:00,210 --> 00:34:02,790
즉시, 나는 두 번 수
다시, 아마 그 때문에

689
00:34:02,790 --> 00:34:03,900
이전 페이지에서였다.

690
00:34:03,900 --> 00:34:05,070
>> 하지만 지금까지 두 번 다시 할 필요가 없습니다.

691
00:34:05,070 --> 00:34:08,030
이론적으로, 나는 오른쪽에 그것을 할 경우
시간, 나는 그냥 한 페이지 이동합니다.

692
00:34:08,030 --> 00:34:10,139
그래서 하나의 추가 단계를 추가하는 것.

693
00:34:10,139 --> 00:34:13,070
그래서, 두 배 빠른 갔어요
그러나 그것은 나에게 한 추가 페이지를 요했다.

694
00:34:13,070 --> 00:34:14,699
하지만 그 그물 승리 것 같은 느낌이 든다.

695
00:34:14,699 --> 00:34:17,230
>> 하지만이 방법을 대부분의 사람들에 없습니다
이 객실은이 문제를 해결합니다.

696
00:34:17,230 --> 00:34:20,313
어떤 것 전형적인 사람, 어쩌면
몇 년 전 마이크 스미스를 찾기 위해, 무엇입니까?

697
00:34:20,313 --> 00:34:22,900

698
00:34:22,900 --> 00:34:24,800
네, 마이크를 찾지 못했습니다.

699
00:34:24,800 --> 00:34:27,190
어떻게해야합니까?

700
00:34:27,190 --> 00:34:31,027
그래서 좀 더 가까이 얻을,하지만 난 할
전화 번호부에 대한 진실이 무엇인지 하란?

701
00:34:31,027 --> 00:34:32,110
청중 : 그것은 순서입니다.

702
00:34:32,110 --> 00:34:32,760
DAVID 마란 : 그것은 순서입니다.

703
00:34:32,760 --> 00:34:33,750
그것은 알파벳입니다.

704
00:34:33,750 --> 00:34:36,540
그리고 나는 M 섹션에있어 그렇다면,
마이크, 오른쪽 명확

705
00:34:36,540 --> 00:34:39,949
말 그대로 찢어 수 있습니다
반쪽은의 문제

706
00:34:39,949 --> 00:34:44,360
그것은 that-- 눈물보다 일반적으로 쉽게
반 문제와, 그것을 멀리 던져

707
00:34:44,360 --> 00:34:47,627
그래서 지금, 나는의 문제가
더 이상 1000 어려웠다 pages--,

708
00:34:47,627 --> 00:34:50,210
내가 생각하기 때문에 나는 실제로 찢어
이하지으로 .. 전화 번호부

709
00:34:50,210 --> 00:34:52,219
1,000 페이지,하지만 500.

710
00:34:52,219 --> 00:34:54,750
>> 그래서 큰 문제로 그대로 절반이다.

711
00:34:54,750 --> 00:34:58,170
그리고 그 때문에, 꽤 설득력있어
내 이전 알고리즘, 버전

712
00:34:58,170 --> 00:35:02,870
1, 2, I는 문제를 만들고 있었다
한 페이지 더 작은, 두 페이지 작은

713
00:35:02,870 --> 00:35:03,470
한번에.

714
00:35:03,470 --> 00:35:07,230
지금 반면, 나는 500를 만들어
한 번에 모든 페이지 이하이다.

715
00:35:07,230 --> 00:35:10,089
>> OK, 이제, 카림는 제안
나는 오른쪽 절반에 갈 것이다.

716
00:35:10,089 --> 00:35:12,380
그래서 대략 갈거야
중간에 포기 또는 걸릴.

717
00:35:12,380 --> 00:35:15,185
그리고 수학적으로 이런 짓을하는 경우,
나는 중간에 바로 갈 수있다.

718
00:35:15,185 --> 00:35:17,060
그리고 지금은, 오, 실현
나는 T 섹션입니다.

719
00:35:17,060 --> 00:35:18,280
사실은 너무 멀리 가지 않았다.

720
00:35:18,280 --> 00:35:21,670
>> 하지만, 다시는 눈물 수 있습니다
반 문제는, 그것을 멀리 던져.

721
00:35:21,670 --> 00:35:23,330
그리고 내 바이트로 크지 않다.

722
00:35:23,330 --> 00:35:28,780
그것은 것만 256 페이지 또는 250입니다
페이지, 제공 또는 지금 걸릴.

723
00:35:28,780 --> 00:35:31,570
하지만 여전히 방법이 더
한 페이지 또는 두 페이지보다.

724
00:35:31,570 --> 00:35:33,345
>> 그리고 지금, 나는 중간에 대략 이동합니다.

725
00:35:33,345 --> 00:35:35,330
아, 나는 지금 아주 충분히 멀리 가지 않았다.

726
00:35:35,330 --> 00:35:37,880
그래서 반복, 반복, 반복
내가 희망이야 때까지 반복

727
00:35:37,880 --> 00:35:40,360
한 페이지 왼쪽.

728
00:35:40,360 --> 00:35:44,000
>> 그래서 경우, 질문을 초대합니다 I
약 1,000 페이지를 시작,

729
00:35:44,000 --> 00:35:47,340
그것은 나를 걸릴 않았다 얼마나 많은 단계
내 알고리즘의 버전 1?

730
00:35:47,340 --> 00:35:50,420
음, 마이크는 S에있는 경우
부, 최악의 경우,

731
00:35:50,420 --> 00:35:52,630
그것은 꽤 가까이
알파벳의 끝.

732
00:35:52,630 --> 00:35:56,559
전화 번호부는 1,000 페이지가 있다면,
나는 1000 페이지 내에서 마이크를 찾을 수 있습니다

733
00:35:56,559 --> 00:35:57,100
제공 또는 걸릴.

734
00:35:57,100 --> 00:35:59,750
어쩌면 그것은, 800처럼 정도지만
그것은 1000 아주 가까이 있습니다.

735
00:35:59,750 --> 00:36:01,680
>> 반면, 두 번째에
알고리즘 얼마나

736
00:36:01,680 --> 00:36:06,840
페이지는 내가 수도 최대로 전환
마이크 스미스를 찾을 필요?

737
00:36:06,840 --> 00:36:09,970
이 1,000 페이지,하지만 난
한 번에 두 가지 일을.

738
00:36:09,970 --> 00:36:13,045
오른쪽 때문에, 500ish 같은 최대 그래서
나는 전체 전화 번호부를 통해 이동하는 경우,

739
00:36:13,045 --> 00:36:14,170
어떤 시점에서, 나는 중지 할 수 있습니다.

740
00:36:14,170 --> 00:36:16,669
하지만 난에 의해 몇 면도 할 수 있습니다
바로 T 섹션에서 중지.

741
00:36:16,669 --> 00:36:19,880
그러나 500 페이지의 경우 최악이다.

742
00:36:19,880 --> 00:36:24,710
>> 그래서 몇 번이나 내가 나눌 수있는
반 1,00o 페이지 전화 번호부 다시

743
00:36:24,710 --> 00:36:30,450
다시 및 again--에서
125-250에 500 천?

744
00:36:30,450 --> 00:36:32,250
얼마 동안은 한 페이지에 충돌하기 전에?

745
00:36:32,250 --> 00:36:35,510

746
00:36:35,510 --> 00:36:36,370
네, 약 10이다.

747
00:36:36,370 --> 00:36:40,780
라운딩 등에 따라,의
총 필요가 설정되는 약 10 페이지

748
00:36:40,780 --> 00:36:43,290
또는 전화 번호부를 찢어해야합니다.

749
00:36:43,290 --> 00:36:44,710
>> 그래서 꽤 강력합니다.

750
00:36:44,710 --> 00:36:48,170
우리는 1,000 페이지 문제 시작
이 이야기의 모든 삼인치

751
00:36:48,170 --> 00:36:51,850
그러나 첫째 알고리즘에서 그것
날 데려 갔어, 최악의 경우, 1,000 페이지

752
00:36:51,850 --> 00:36:52,740
마이크를 찾을집니다.

753
00:36:52,740 --> 00:36:55,590
두 번째 알고리즘 (500)
페이지는 마이크를 찾을 수 있습니다.

754
00:36:55,590 --> 00:36:58,480
셋째 알고리즘, 10 페이지 마이크를 찾을 수 있습니다.

755
00:36:58,480 --> 00:37:00,230
그리고 그것은 심지어 더
강력한 때 당신이 생각하는

756
00:37:00,230 --> 00:37:01,860
반대 시나리오의 종류에 대해.

757
00:37:01,860 --> 00:37:05,680
전화 회사 옆에 있다고 가정하자
올해는 아마 두 개의 마을을 병합

758
00:37:05,680 --> 00:37:08,550
그리고 전화 번호부 갑자기입니다
두꺼운, 대신 그이,

759
00:37:08,550 --> 00:37:12,470
그래서 2000 페이지 대신 1000.

760
00:37:12,470 --> 00:37:15,640
글쎄, 내 첫 번째 알고리즘이 찾고있는 사람이
2,000 페이지 전화 번호부에서 마이크 스미스,

761
00:37:15,640 --> 00:37:21,460
최악의 경우, 걸릴 거예요
내년에 얼마나 많은 페이지집니다?

762
00:37:21,460 --> 00:37:24,800
>> 전화 번호부는 2,000 페이지입니다
그러니까 ... 음, 한 번 더.

763
00:37:24,800 --> 00:37:29,540
전화 번호부는의 두 배 두꺼운 경우
첫 번째 알고리즘, 첫 번째 알고리즘,

764
00:37:29,540 --> 00:37:30,380
2000, 맞죠?

765
00:37:30,380 --> 00:37:33,005
최악의 경우, 마이크 정말
책의 끝 부분에 닫습니다,

766
00:37:33,005 --> 00:37:34,110
그래서 2000 페이지 회전을합니다.

767
00:37:34,110 --> 00:37:38,070
로가는 두 번째 알고리즘
조로, 1,000 페이지 등을들 수있다.

768
00:37:38,070 --> 00:37:41,490
>> 하지만 어떻게 세 번째 약
가장 최근의 알고리즘?

769
00:37:41,490 --> 00:37:44,950
전화 회사가 배가되면
1,000에서 2,000 페이지 수,

770
00:37:44,950 --> 00:37:47,770
얼마나 더 많은 시간을 내가 눈물 필요
반 그 책은 마이크를 찾는 방법은?

771
00:37:47,770 --> 00:37:48,710
>> 청중 : 그냥 하나.

772
00:37:48,710 --> 00:37:51,001
>> DAVID 마란 : 그냥 하나 더,
한 페이지 눈물 때문에,

773
00:37:51,001 --> 00:37:53,270
말 그대로 나눌 수 있습니다
당신이 경우와, 정복

774
00:37:53,270 --> 00:37:57,410
반 촬영에서 그 문제
그것을 밖으로 거대한 물린.

775
00:37:57,410 --> 00:38:01,420
그래서이의 예입니다
효율성과 틀림없이 알고리즘

776
00:38:01,420 --> 00:38:04,100
있는 우리 모두는
일종의 직관적으로 잘 알고.

777
00:38:04,100 --> 00:38:07,780
그러나 알맞은 단지
내 다른 알고리즘과 같은

778
00:38:07,780 --> 00:38:09,630
그 비틀기 용으로
두 번째 알고리즘,

779
00:38:09,630 --> 00:38:11,290
그러나 그것은 훨씬 더 효율적입니다.

780
00:38:11,290 --> 00:38:14,030
>> 그리고 사실, 어떤 컴퓨터
과학자, 또는 차례로 프로그래머,

781
00:38:14,030 --> 00:38:17,580
기록 할 때 일반적으로 할 것
코드를 알아 내기 위해 노력하고,

782
00:38:17,580 --> 00:38:19,960
모든 권리, 나는 싶지 않아 내
프로그램은, 정확합니다

783
00:38:19,960 --> 00:38:23,220
나는 또한 효율적으로 할
잘 문제를 해결.

784
00:38:23,220 --> 00:38:26,450
오늘날 현실 세계에서 상상,
구글 색인, 검색 등

785
00:38:26,450 --> 00:38:31,580
페이지의 수십억 같은 경우 상상 그들은
고양이를 찾기 위해 제 알고리즘을 사용

786
00:38:31,580 --> 00:38:34,620
보고 pages-- 억 중
그 데이터베이스의 첫 페이지,

787
00:38:34,620 --> 00:38:37,700
두 번째, 세 번째, 단지 찾고
고양이를 들어, 고양이를 찾고.

788
00:38:37,700 --> 00:38:40,350
즉, 무척는 것 같다 느리다.

789
00:38:40,350 --> 00:38:43,170
그들은 대신에 뭔가를 사용할 수 있습니다
라는 이진 검색, 어떤

790
00:38:43,170 --> 00:38:47,420
이 의미를 더 coincidence-- 양방향 우리는 없다
반쪽은에, 2 일을 분할 유지

791
00:38:47,420 --> 00:38:50,205
그들은 이진 검색을 사용할 수 있습니다
어쩌면, 더 빨리 고양이를 찾습니다

792
00:38:50,205 --> 00:38:51,830
또는 무엇이든 당신이 검색하는 것입니다.

793
00:38:51,830 --> 00:38:54,125
>> 그리고 솔직히, 거기에
심지어 애호가 알고리즘

794
00:38:54,125 --> 00:38:56,250
그것은 단지보다 훨씬 더 많은 일을 할
반에서 일을 분할

795
00:38:56,250 --> 00:38:58,180
위해 정보를 신속하게 찾을 수 있습니다.

796
00:38:58,180 --> 00:39:00,880
그리고 우리는 조금 얘기하자
점심 식사 후 그 오늘에 대해.

797
00:39:00,880 --> 00:39:02,640
그래서 내가 그냥이를 표현하려고 할 수 있습니다.

798
00:39:02,640 --> 00:39:05,380
우리는에 갈 필요가 없습니다
어떤 수학 또는 실제 수치.

799
00:39:05,380 --> 00:39:07,070
우리는 추상적으로 얘기 할 수 있습니다.

800
00:39:07,070 --> 00:39:11,580
>> 하지만, 나 그냥 제안하자 당신이 경우
지금 토론을했다

801
00:39:11,580 --> 00:39:13,491
엔지니어와
이 알고리즘을 제안

802
00:39:13,491 --> 00:39:15,490
당신은 만들려고 노력하고 있습니다
계산 된 결정,

803
00:39:15,490 --> 00:39:17,285
아마 때문에
엔지니어는 당신에게 말한다

804
00:39:17,285 --> 00:39:19,910
내가 구현할 수있는, 알고
이분 같은 선형 검색.

805
00:39:19,910 --> 00:39:21,150
그것은 그 쉽습니다.

806
00:39:21,150 --> 00:39:24,790
이진 검색, 그 공상이 아니라
10 분처럼 저를 취할 것

807
00:39:24,790 --> 00:39:26,650
그래서 5 배 긴.

808
00:39:26,650 --> 00:39:30,900
>> 무역도 측면에서, 여기있다
의 작성 어떤 소프트웨어를 결정.

809
00:39:30,900 --> 00:39:34,760
당신은 간단한 알고리즘을 작성 마십시오,
이는 당신에게 2 분 걸릴까요?

810
00:39:34,760 --> 00:39:39,880
아니면 더 많은 시간을 보내고 않습니다 10 분,
애호가 알고리즘을 작성?

811
00:39:39,880 --> 00:39:43,540
어떻게 질문의 종류를 결정합니까?

812
00:39:43,540 --> 00:39:46,710
아니면 당신은 좀 더 실제 만들 수 있습니다.

813
00:39:46,710 --> 00:39:50,610
나는 그것이 걸릴 거예요 내 상사에게
저 둘 중 하나 주 십주

814
00:39:50,610 --> 00:39:52,490
을 구현하는
이러한 방식으로 소프트웨어 방식

815
00:39:52,490 --> 00:39:56,103
당신은 결정 않는
녹색 빛 알고리즘?

816
00:39:56,103 --> 00:39:56,603
카림?

817
00:39:56,603 --> 00:39:57,550
>> 청중 : 관객 것 같아요.

818
00:39:57,550 --> 00:39:57,960
>> DAVID 마란 : 관객.

819
00:39:57,960 --> 00:39:59,460
당신은 관객 무엇을 의미합니까?

820
00:39:59,460 --> 00:40:03,460
>> 청중 : 그것은 무슨 경우
사용자가 사용할

821
00:40:03,460 --> 00:40:09,050
누구 [들리지] 사용자가 [들리지].

822
00:40:09,050 --> 00:40:11,232
그것은 뭔가가 있다면하지만 당신은있어
단지 자신을 위해 일을

823
00:40:11,232 --> 00:40:13,946
문제를 용이하게하기 위해,
[들리지] 빨리.

824
00:40:13,946 --> 00:40:16,820
데이비드 마란이 : 그래, 빨리 그리고
더러운 그것을 설명 할 수있는 좋은 방법입니다.

825
00:40:16,820 --> 00:40:18,695
사실, 당신은이 있다면
내 시간의 많은 부분을 설명

826
00:40:18,695 --> 00:40:23,630
대학원에서, 이에 종종,
나는 의식적으로 나쁜 코드를 작성 그러니까 ...

827
00:40:23,630 --> 00:40:26,490
적어도 그건 어떻게
의식적으로 그렇게 그건 ...을 합리화,

828
00:40:26,490 --> 00:40:30,670
내가 코드를 작성했다하더라도 때문에
즉, 실행 상대적으로 느렸다

829
00:40:30,670 --> 00:40:33,750
나는 코드 자체를 쓸 수 있었다
꽤 빨리, 지출 불과​​ 몇 분

830
00:40:33,750 --> 00:40:35,107
또는 시간없는 일.

831
00:40:35,107 --> 00:40:37,190
그리고 나는 밝혀졌다
가끔 잠을 필요로했다.

832
00:40:37,190 --> 00:40:41,270
그래서 내 코드는 8 필요한 경우에도
실행 시간, 그건 괜찮 아니라,

833
00:40:41,270 --> 00:40:42,850
난 그냥이 실행되는 동안 잠을로 이동합니다.

834
00:40:42,850 --> 00:40:46,350
>> 시 그래서, 나는이라고 생각했다
매우 영리한, 심지어하지만 분명히

835
00:40:46,350 --> 00:40:48,990
아주 천천히 내 박사 학위를했다.

836
00:40:48,990 --> 00:40:52,270
하지만 그의 반대입니다
즉, 내가 쓰고 있다면 소프트웨어

837
00:40:52,270 --> 00:40:55,930
다른 사람을위한 사람
물론, 나보다 더 중요

838
00:40:55,930 --> 00:40:59,580
를 갖는 8 시간을 기다려야
검색 결과를 다시 얻을 수

839
00:40:59,580 --> 00:41:01,350
모두 강력한 없습니다.

840
00:41:01,350 --> 00:41:04,090
그래서 더 많은 시간을 보내고
소프트웨어를 작성하는 앞까지

841
00:41:04,090 --> 00:41:07,300
즉 더 효율적이고, 더
세 번째 알고리즘 등,

842
00:41:07,300 --> 00:41:09,780
아마 시간이 지남에 따라 사용자에게 도움이됩니다.

843
00:41:09,780 --> 00:41:12,710
그래서 정말 이상 의존
시간은 그 비용이 방법을 추가 할 수 있습니다.

844
00:41:12,710 --> 00:41:14,960
당신이 작성 될 거라면
소프트웨어는 한 번 사용

845
00:41:14,960 --> 00:41:17,240
아마 잘 할 수 있습니다
신속하고 더러운, 그들이 말하는대로.

846
00:41:17,240 --> 00:41:18,198
그냥 함께 던져.

847
00:41:18,198 --> 00:41:20,560
그것은 당황 코드의
당신은 그것이 그렇게 나쁜

848
00:41:20,560 --> 00:41:23,860
하지만, 제대로 일을 얻는다
비록 그것은 효율적 아니에요.

849
00:41:23,860 --> 00:41:27,200
반대로, 당신은 더 많은 시간을 보내고
뭔가, 그것은 바로 찾으실 수 있습니다.

850
00:41:27,200 --> 00:41:30,730
그리고, 시간이 지남에 따라 상각
시간의 선행 비용

851
00:41:30,730 --> 00:41:34,330
당신이 계속하는 경우, 아마 가치가있다
일반적인 경우에 대한 최적화.

852
00:41:34,330 --> 00:41:37,620
>> 그리고 실제로, 그것은의 테마입니다
프로그래밍, 컴퓨터 과학 더

853
00:41:37,620 --> 00:41:41,390
일반적으로 최적화하기 위해 노력하고
하지 드문 경우에

854
00:41:41,390 --> 00:41:44,390
하지만 어떤 동작 공통 case--
또 다시 일어날 것입니까?

855
00:41:44,390 --> 00:41:47,730
당신은 수십억을 위하여려고하는 경우
사용자의 웹 사이트에서 검색,

856
00:41:47,730 --> 00:41:52,030
당신은 아마 여분을 지출해야
더 나은 소프트웨어를 작성 앞까지 주

857
00:41:52,030 --> 00:41:53,670
그래서 사용자의 모든 혜택을 누릴 것이다.

858
00:41:53,670 --> 00:41:57,840
이제, 이것을 캡처 해보자
작은 그림으로,하지만 너무 많은

859
00:41:57,840 --> 00:41:58,610
수치.

860
00:41:58,610 --> 00:42:01,680
>> 그래서 여기에 그냥 오래된 학교 차트입니다.

861
00:42:01,680 --> 00:42:04,260
그리고 날이 시간이라고 말할 수 있습니다.

862
00:42:04,260 --> 00:42:06,660
그리고 뭐 ... 중요하지 않습니다
실제로, 아니, 시간.

863
00:42:06,660 --> 00:42:08,320
의 다른 축에 그것을 넣어 보자.

864
00:42:08,320 --> 00:42:15,700
,의는이 시간이라고 가정 해 봅시다
이는 문제의 크기이다.

865
00:42:15,700 --> 00:42:17,830
>> 그리고 컴퓨터 과학자
일반적으로 호출 할 수 있습니다

866
00:42:17,830 --> 00:42:20,820
이 단지 N. 여기서 n은 같다
우리의 이동 -에 변수,

867
00:42:20,820 --> 00:42:26,351
n은 수 N 번호이며,은의
당신이 어떤 입력의 수입니다.

868
00:42:26,351 --> 00:42:28,100
이 경우, n은
페이지 수.

869
00:42:28,100 --> 00:42:30,150
그래서 1000이 될 수 있습니다
경우 우리는 단지 말했다.

870
00:42:30,150 --> 00:42:31,969
>> 그래서 시간이 측정의 단위가 될 수 있습니다.

871
00:42:31,969 --> 00:42:32,760
어쩌면, 그것은 두 번째입니다.

872
00:42:32,760 --> 00:42:33,410
어쩌면, 그것은 일입니다.

873
00:42:33,410 --> 00:42:34,590
아마,이 페이지 회전 같아요.

874
00:42:34,590 --> 00:42:35,215
중요하지 않습니다.

875
00:42:35,215 --> 00:42:38,840
당신은 것을에서 계산 원하는
시간이 수 또는 동등 비용을 것입니다.

876
00:42:38,840 --> 00:42:42,400
>> 그와 함께 그래서 처음
알고리즘, 나는 경우, 예를 들어,

877
00:42:42,400 --> 00:42:45,920
, 1,000 페이지 전화 번호부를했다
나는이 점을 그릴거야

878
00:42:45,920 --> 00:42:51,450
이 1,000 페이지를인지하기 때문에, 그것은했다
약 1,000 페이지에 제공하거나 취집니다.

879
00:42:51,450 --> 00:42:54,100
그리고 내가 가진 경우
2,000 페이지 전화 번호부,

880
00:42:54,100 --> 00:42:57,200
나는 두 번째를 그릴거야
때문에 2000 페이지에, 여기에 도트,

881
00:42:57,200 --> 00:42:59,810
그것은 2천초처럼
또는 페이지를 켜거나 뭐든간에.

882
00:42:59,810 --> 00:43:02,480
앞서 말했을 때 그리고, 그것은이다
선형 관계의 종류,

883
00:43:02,480 --> 00:43:06,020
내가 원한 때문에 즉, 고의적이었다
나중에 on-- 바로 now-- 선을 그립니다.

884
00:43:06,020 --> 00:43:07,770
그것은 직선의 종류의
라인 관계.

885
00:43:07,770 --> 00:43:10,180
당신이 경우 기울기는 1/1이다.

886
00:43:10,180 --> 00:43:14,630
>> 한편, 상기 제 2 알고리즘
1,000 페이지를 가지고있는 경우, 상기

887
00:43:14,630 --> 00:43:17,680
당신은 두 번째 알고리즘을 사용하고,
나는 2의 카운트 경우, 회전

888
00:43:17,680 --> 00:43:22,564
한 번에 두 페이지, 난을 그릴한다
아래 또는 내 원래의 점 위에 점?

889
00:43:22,564 --> 00:43:23,450
>> 청중 : 아래.

890
00:43:23,450 --> 00:43:27,992
>> DAVID 마란 : 다음, 우리가 본 바와 같이 있기 때문에,
그것은 많은 시간과 적은 시간 반이 걸립니다.

891
00:43:27,992 --> 00:43:29,950
그래서 점은 반해야한다
다른 높게.

892
00:43:29,950 --> 00:43:33,330
그리고 여기에 같은 거래,이 점
아마 약이 있어야합니다.

893
00:43:33,330 --> 00:43:39,666
그리고 내 두 번째 알고리즘, 유사,
시간에 선형 관계가 있습니다.

894
00:43:39,666 --> 00:43:41,990
그리고 우리는 등을 그릴 수 있습니다.

895
00:43:41,990 --> 00:43:45,950
>> 그래서 지금, 세 번째이자 마지막
알고리즘은 그릴 조금 어렵습니다.

896
00:43:45,950 --> 00:43:49,530
그러나 직관적으로, 나는 1000을 가지고있는 경우
세 번째 알고리즘 페이지,

897
00:43:49,530 --> 00:43:52,340
만 10 단계 같은 날을해야한다.

898
00:43:52,340 --> 00:43:57,500
그리고 2000 페이지를 가지고있는 경우
세 번째 알고리즘,

899
00:43:57,500 --> 00:44:01,570
그것은 10 날을해야
단계하지만 11, 하나 더.

900
00:44:01,570 --> 00:44:03,610
그래서 우리는 간신히이를 보게 될 것입니다.

901
00:44:03,610 --> 00:44:06,010
>> 그리고 경우, 밝혀
나는 난이 확대

902
00:44:06,010 --> 00:44:09,320
효과를 과장하는 것,
그 선 형상 궁극적

903
00:44:09,320 --> 00:44:11,990
직선 line--는 아니다
그것이 사실이었다 경우 때문에

904
00:44:11,990 --> 00:44:15,390
그것은 같은 더 보일 것이다
others-- 실제로는 곡선의

905
00:44:15,390 --> 00:44:19,265
우리는 확대하면 그, 것입니다
이 같은 더 많은 것을 볼 수 있습니다.

906
00:44:19,265 --> 00:44:21,670
그건 ... 음, OK,이 부분을 무시합니다.

907
00:44:21,670 --> 00:44:25,330
그건 내 펜이 각도의 것이었다.

908
00:44:25,330 --> 00:44:29,000
그것은 항상 곡선이다
항상, 항상, 항상 증가

909
00:44:29,000 --> 00:44:32,100
하지만 겨우 증가.

910
00:44:32,100 --> 00:44:36,260
>> 그리고 시간이 지남에, 당신은이
더이처럼 관계.

911
00:44:36,260 --> 00:44:37,540
그것은 거의 직선 보인다.

912
00:44:37,540 --> 00:44:40,330
하지만 계속 증가 천천히입니다.

913
00:44:40,330 --> 00:44:44,780
그러나 함께 거의 모든 점
하여 X 축, 가로 축,

914
00:44:44,780 --> 00:44:46,550
그것은 그 다른 라인보다 낮은입니다.

915
00:44:46,550 --> 00:44:49,930
>> 그래서이 관계 될 수 있습니다
N, 이에는 n 개의 페이지가있는 경우,

916
00:44:49,930 --> 00:44:51,100
당신 n 초 걸립니다.

917
00:44:51,100 --> 00:44:53,320
이 관계 N / 2 수 있습니다.

918
00:44:53,320 --> 00:44:56,710
당신은 n 개의 페이지가, 그것은 소요
당신 N / 2 초 반만큼.

919
00:44:56,710 --> 00:45:00,590
그리고 이것은 대수입니다
관계있는

920
00:45:00,590 --> 00:45:08,920
당신이 기억하는 경우, n 개의 캡처의 기본이 로그
이런 종류의 성장은 말하자면.

921
00:45:08,920 --> 00:45:12,000
그래서 이것은 거룩한의 일종이다
이 세 가지 중 성배

922
00:45:12,000 --> 00:45:15,940
여기에, 그것 때문에 너무 훨씬 더
효율적인하지만 틀림없이 더 복잡

923
00:45:15,940 --> 00:45:18,610
구현.

924
00:45:18,610 --> 00:45:20,510
질문?

925
00:45:20,510 --> 00:45:26,220
>> 그럼 내가이 작업을 수행 할 수 있습니다
나 텍스트 창을 엽니 다

926
00:45:26,220 --> 00:45:29,100
그냥 그래서 우리는 시도 할 수 있습니다
여기에 뭔가를 공식화.

927
00:45:29,100 --> 00:45:32,410
그래서 내가 지금 가서 보자
이 알고리즘을 구현

928
00:45:32,410 --> 00:45:35,170
코드 마이크 스미스를 찾는,
당신이 의사 코드됩니다.

929
00:45:35,170 --> 00:45:36,620
나는 Java 또는 C ++를 사용하지 않을거야.

930
00:45:36,620 --> 00:45:38,610
난 그냥 일종의 사용하는거야
영어와 같은 구문, 이는 우리

931
00:45:38,610 --> 00:45:40,151
일반적으로 의사 코드를 호출합니다.

932
00:45:40,151 --> 00:45:41,660
자, 내가 빈 창이 있습니다.

933
00:45:41,660 --> 00:45:48,180
그리고 나는 아주의 1 단계를 말하는거야
첫 번째 알고리즘은 전화 번호부를 선택합니다.

934
00:45:48,180 --> 00:45:51,740
2 단계는 첫 번째 페이지에 책이다.

935
00:45:51,740 --> 00:45:58,080
3 단계 볼 수 있습니다
마이크 스미스에 대한 페이지입니다.

936
00:45:58,080 --> 00:46:02,740
페이지의 경우, 마이크를 호출합니다.

937
00:46:02,740 --> 00:46:11,640
다른 차례 페이지와 3 단계로 이동합니다.

938
00:46:11,640 --> 00:46:13,590
완료, 이제 가정 해 봅시다.

939
00:46:13,590 --> 00:46:18,110
>> 그리고 그것은 아주 완벽 하진
저희는 잠시 볼 수 있습니다.

940
00:46:18,110 --> 00:46:21,050
하지만 이제 생각 해보자 무엇
개념은 나는 여기에 소개했습니다.

941
00:46:21,050 --> 00:46:24,450
따라서 1, 2, 3 단계
거의 동사입니다.

942
00:46:24,450 --> 00:46:26,544
그들은 문을있어, actions--이 작업을 수행.

943
00:46:26,544 --> 00:46:28,710
그리고 프로그래밍에
언어, 우리는 일반적으로 것

944
00:46:28,710 --> 00:46:32,349
그들에게 문을 전화 또는
기능이나 절차,

945
00:46:32,349 --> 00:46:33,640
물건의 번호를 호출합니다.

946
00:46:33,640 --> 00:46:35,460
그러나 그들은 이렇게 actions-- 그냥있어.

947
00:46:35,460 --> 00:46:40,370
>> 4 단계는, 기본적으로 다르​​다
이 종류의 질문을 때문에.

948
00:46:40,370 --> 00:46:42,400
우리가 친절 말하는
의 갈림길에서.

949
00:46:42,400 --> 00:46:48,000
마이크는 페이지에있는 경우, 호출
당신이 경우 그, 그래서, 좌회전합니다.

950
00:46:48,000 --> 00:46:52,170
그리고하지 않을 경우 것은 몇 가지로 돌아가
죄송합니다, page-- 다른 또는 오히려

951
00:46:52,170 --> 00:46:56,650
다른 단계로 돌아가있는
루프 구조의 일종을 유도한다.

952
00:46:56,650 --> 00:46:59,530
그리고 우리는 다시하고 다시하고 다시 그것을 할.

953
00:46:59,530 --> 00:47:01,300
>> 그리고 실제로, 당신은 알아?

954
00:47:01,300 --> 00:47:01,800
네.

955
00:47:01,800 --> 00:47:04,704

956
00:47:04,704 --> 00:47:09,010
다른 책 정지의 끝에있는 경우.

957
00:47:09,010 --> 00:47:11,624
그래서 우리는 세 번째 종류의 필요
조건, 당신 때문에

958
00:47:11,624 --> 00:47:14,290
페이지 광고를 선회 유지할 수 없다
nauseum, 나는거야 결국 때문에

959
00:47:14,290 --> 00:47:15,320
책의 끝을 맞았습니다.

960
00:47:15,320 --> 00:47:18,546
그리고 프로그램에 버그가있을 수 있습니다
이 시나리오를 기대하지.

961
00:47:18,546 --> 00:47:21,420
그리고 단지 실현 I, 오, 대기
분, 나는 세 번째 시나리오가 필요합니다.

962
00:47:21,420 --> 00:47:23,900
내가 페이지에서 해요, 난
정말 그냥 중지해야합니다.

963
00:47:23,900 --> 00:47:25,330
그렇지 않으면 정의합니다.

964
00:47:25,330 --> 00:47:29,260
어떻게 내가 계속하는 경우 일 것
페이지를 켜고 돌아가 말

965
00:47:29,260 --> 00:47:31,810
이 때 컴퓨터입니다
당신이 명중 할 때, 정지 또는 충돌

966
00:47:31,810 --> 00:47:34,160
같은 일부 예기치 못한 상황.

967
00:47:34,160 --> 00:47:37,280
>> 자, 마이크에 대한
스미스의 세 번째 algorithm--

968
00:47:37,280 --> 00:47:43,150
전화 번호부를 데리러
에 first--하는 책

969
00:47:43,150 --> 00:47:48,640
아니, 첫 페이지에이 시간을,
거라고, 잘, 오 middle--하기

970
00:47:48,640 --> 00:47:49,640
두 번째 알고리즘합니다.

971
00:47:49,640 --> 00:47:50,590
그냥 세 번째로 이동하자.

972
00:47:50,590 --> 00:47:50,930
>> 청중 : 아, 미안 해요.

973
00:47:50,930 --> 00:47:51,971
>> DAVID 마란 : 그건 괜찮아요.

974
00:47:51,971 --> 00:47:58,590
의 단지 third-- 열기로 이동하자
중간에 지금은 마이크 스미스를 찾습니다.

975
00:47:58,590 --> 00:48:02,300
페이지의 경우, 마이크를 호출합니다.

976
00:48:02,300 --> 00:48:04,910
그리고 우리가 여기서 말하고 싶은합니까?

977
00:48:04,910 --> 00:48:06,134
그 밖의 무엇?

978
00:48:06,134 --> 00:48:10,620

979
00:48:10,620 --> 00:48:12,370
우리는이를 표현할 수
임의의 수의 방법이다.

980
00:48:12,370 --> 00:48:13,369
어떤 정답이 없습니다.

981
00:48:13,369 --> 00:48:20,819

982
00:48:20,819 --> 00:48:23,735
확인을하지 않을 경우 다시, 그러나 우리는 필요
OK 군자, 우리는 두 가지로 나눌 않는다,

983
00:48:23,735 --> 00:48:25,630
그러나 우리는 왼쪽으로 이동 또는 오른쪽으로 이동 하시겠습니까?

984
00:48:25,630 --> 00:48:29,560
우리는 어떻게 그 개념을 표현합니까?

985
00:48:29,560 --> 00:48:31,790
음, 마이크의 경우, 예, 그 공정이다.

986
00:48:31,790 --> 00:48:35,050
그러나 OK, 그래서 실제로 좋은 지적입니다.

987
00:48:35,050 --> 00:48:35,550
괜찮아.

988
00:48:35,550 --> 00:48:36,924
우리는이 논리를 계속합니다.

989
00:48:36,924 --> 00:48:38,182
그래서--

990
00:48:38,182 --> 00:48:39,810
>> 청중 : 절반 이하.

991
00:48:39,810 --> 00:48:40,560
DAVID 마란 : 그래.

992
00:48:40,560 --> 00:48:49,820
페이지가 있다면 다른, 우리가 말할거야, 이하
스미스보다, 스미스의 왼쪽에,

993
00:48:49,820 --> 00:48:52,220
어디 보자 then--입니다
이 복잡​​ 것?

994
00:48:52,220 --> 00:49:01,885
다른 페이지는 스미스 앞에 오는 경우,
반에있는 반 버리고 눈물?

995
00:49:01,885 --> 00:49:05,643

996
00:49:05,643 --> 00:49:09,140
>> 청중 : 나는 생각했다
즉, [들리지이었다.

997
00:49:09,140 --> 00:49:11,650
>> DAVID 마란 : 나는 듣고 모두 답하고있다.

998
00:49:11,650 --> 00:49:12,431
>> 청중 : 왼쪽.

999
00:49:12,431 --> 00:49:14,430
DAVID 마란 : OK, 던져
멀리 Lakisa로 절반을 왼쪽

1000
00:49:14,430 --> 00:49:19,700
이전, 왼쪽 말했다
반, 나는 가지

1001
00:49:19,700 --> 00:49:23,940
내가 오른쪽으로 이동 이러시면 그냥 가고 싶어.

1002
00:49:23,940 --> 00:49:27,380
또는 동등하게, 그리고 좀했다
여기 처음의 혼란의 비트,

1003
00:49:27,380 --> 00:49:30,760
나는 효과적으로 원하는
다시 2 단계로 이동,

1004
00:49:30,760 --> 00:49:38,270
여기서 열린 middle-- 또는 open--에
그래, 그냥 말을 중간에 페이지를 할 수 있습니다.

1005
00:49:38,270 --> 00:49:39,020
그리고이 그것을 해결합니다.

1006
00:49:39,020 --> 00:49:39,936
그것은 더 이상 책 없습니다.

1007
00:49:39,936 --> 00:49:42,210
이 책의 절반이다
중간에 너무 열려있는 페이지를 참조하십시오.

1008
00:49:42,210 --> 00:49:44,010
>> 거의 else--했다.

1009
00:49:44,010 --> 00:49:54,000
페이지 스미스 다음에 오는 경우 다른 6 단계,
반으로 찢어 떨어져 오른쪽 절반을 던져,

1010
00:49:54,000 --> 00:49:55,680
다음 2 단계로 이동합니다.

1011
00:49:55,680 --> 00:49:58,920

1012
00:49:58,920 --> 00:50:05,230
다른 경우, 네 번째 시나리오를 종료
우리는 어떤 페이지가 켜 남아 있지 있습니다.

1013
00:50:05,230 --> 00:50:06,394
그래서 우리는이 문제를 정리 할 수​​있다.

1014
00:50:06,394 --> 00:50:07,560
그리고 우리는이 문제를 정리해야합니다.

1015
00:50:07,560 --> 00:50:10,656
이것은 매우 의사 코드는 당신이 경우
것, 매우 높은 수준의 설명.

1016
00:50:10,656 --> 00:50:12,280
그러나, 일반적으로 아이디어를 캡처 않는다.

1017
00:50:12,280 --> 00:50:16,040
>> 그리고, 다시,이 시나리오, 우리
, 조건의 개념이

1018
00:50:16,040 --> 00:50:20,450
분기, 도로에 포크, 만들기
이 길을 갈이 경우 decision--,

1019
00:50:20,450 --> 00:50:23,082
다른 경우,이 길을 갈
다른 경우, 그 길을 갈.

1020
00:50:23,082 --> 00:50:25,040
그리고 이것은 매우 일반적입니다
프로그래밍 기술

1021
00:50:25,040 --> 00:50:27,721
방향을 결정하는
가고, 말하자면.

1022
00:50:27,721 --> 00:50:29,970
그리고 우리는 또한 몇 가지 종류가
의 경우 구조를 반복

1023
00:50:29,970 --> 00:50:32,440
우리는 또 다시 일을하고 있습니다.

1024
00:50:32,440 --> 00:50:34,820
>> 지금, 그것은 많이 밝혀
이 예에서와 같이,

1025
00:50:34,820 --> 00:50:37,660
슈퍼 정확한되는 것이 중요합니다.

1026
00:50:37,660 --> 00:50:42,180
그러나 우리는 또한 뭔가를 봤어요
우리는 추상화를 호출 유지하는 것이.

1027
00:50:42,180 --> 00:50:45,490
이 전화 번호부를 데리러 무엇을 의미합니까?

1028
00:50:45,490 --> 00:50:47,740
우리는 종류의 복용하고
이 방에 부여

1029
00:50:47,740 --> 00:50:49,340
것을 그 어떤 의미 론적 의미를 갖습니다.

1030
00:50:49,340 --> 00:50:51,740
우리 모두는 가지, 오, 알고
물론, 전화 번호부를 선택합니다.

1031
00:50:51,740 --> 00:50:52,864
것이 정말 무엇을 의미 하는가?

1032
00:50:52,864 --> 00:50:59,060
글쎄, 그건 정말 확장을 의미합니다
손, 손가락을 확장, 기댈

1033
00:50:59,060 --> 00:51:03,890
손가락 사이에 책을 끼,
당신을 향해 손을 당겨, 일어나.

1034
00:51:03,890 --> 00:51:05,940
그리고 우리는 정말이 될 수
이에 대한 현학적,

1035
00:51:05,940 --> 00:51:08,640
정말 슈퍼 정확한 인
에 관해서는 내가 뭘하는지.

1036
00:51:08,640 --> 00:51:13,300
하지만 그 단계를 모두 총칭이다
이 전화 번호부를 데리러 무엇을 의미하는지.

1037
00:51:13,300 --> 00:51:16,940
>> 그리고 이전에, 내가 말했을 때, 각
이러한 처음 두 개의 문

1038
00:51:16,940 --> 00:51:20,830
로 생각 될 수있다
진행 또는 기능,

1039
00:51:20,830 --> 00:51:24,090
정말 그것은 무엇을 나타내는 지 우리
추상화를 계속 전화.

1040
00:51:24,090 --> 00:51:28,770
그것은 개념적 높은 수준처럼
문제의 설명이

1041
00:51:28,770 --> 00:51:31,110
사실은 꽤 몇 가지 단계를 포함한다.

1042
00:51:31,110 --> 00:51:34,190
그리고이도 인
프로그래밍 주제를 반복,

1043
00:51:34,190 --> 00:51:41,125
이에 내가 프로그램을 작성할 수 있습니다
이 항아리 같은 구문을 사용하여

1044
00:51:41,125 --> 00:51:42,000
pick_up_phone_book ().

1045
00:51:42,000 --> 00:51:44,344

1046
00:51:44,344 --> 00:51:46,510
그리고 구문, 난
뭔가를 훔치는 것

1047
00:51:46,510 --> 00:51:48,090
대부분의 프로그래밍 언어에서.

1048
00:51:48,090 --> 00:51:51,270
>> 이제 1 단계도 보인다
함수 같은 더,

1049
00:51:51,270 --> 00:51:53,160
프로그래머로 부를 것이다.

1050
00:51:53,160 --> 00:51:58,650
이 코드를 누군가처럼 보인다
에 이름을 부여하고 부여하고있다

1051
00:51:58,650 --> 00:52:03,300
나에게 다른에 somehow-- 사용
내가 강조했는지 라인 단어,

1052
00:52:03,300 --> 00:52:07,050
어쩌면 기능을 나타냅니다
난 나 자신을 구현하지 않았다.

1053
00:52:07,050 --> 00:52:10,410
오래된 사람보다 현명
날은 이미 파악

1054
00:52:10,410 --> 00:52:12,700
어떻게 개념을 표현
전화 번호부를 따기의.

1055
00:52:12,700 --> 00:52:15,860
그리고 그것은 다섯 단계처럼 나는 단지
내 머리 위로 떨어져 넘어갔습니다.

1056
00:52:15,860 --> 00:52:19,350
>> 그러나 그 또는 그녀는 이미 구현
이것은, 그 몇 가지 단계를했다

1057
00:52:19,350 --> 00:52:22,339
이름, pick_up_phone_book.

1058
00:52:22,339 --> 00:52:24,380
그리고 괄호입니다
그냥 뭐 대부분의 프로그래머를

1059
00:52:24,380 --> 00:52:27,100
이 같은 문장의 끝에 않습니다.

1060
00:52:27,100 --> 00:52:30,190
지금에 설 수있는 자신의
어깨와 결코 다시,

1061
00:52:30,190 --> 00:52:32,465
그것이 무엇을 의미하는지에 대해 생각
전화 번호부를 선택합니다.

1062
00:52:32,465 --> 00:52:34,090
난 그냥 말할 전화 번호부를 선택할 수 있습니다.

1063
00:52:34,090 --> 00:52:36,690
그리고 그것은 정확히이야
우리의 모든 인간은 여기에 있었다.

1064
00:52:36,690 --> 00:52:38,940
>> 우리는 아마 1 있었을 때
2 세, 오래된 년,

1065
00:52:38,940 --> 00:52:41,690
누군가가 우리를 가르 칠 수 있었다 무엇을
전화 번호부를 데리러 의미했다.

1066
00:52:41,690 --> 00:52:43,810
그리고 그 이후로,
우리는 멀리 추상화 한

1067
00:52:43,810 --> 00:52:46,739
그 아주 재미에서
기계적인 단계.

1068
00:52:46,739 --> 00:52:48,530
그리고 우리는 단지이
직관적 인 이해

1069
00:52:48,530 --> 00:52:50,480
그것으로 무엇을 의미하는지
전화 번호부를 선택합니다.

1070
00:52:50,480 --> 00:52:55,730
>> 그리고 당신은 지금 추정 할 수 있습니다
더 복잡한 things--에

1071
00:52:55,730 --> 00:52:57,640
건물을 구성.

1072
00:52:57,640 --> 00:52:59,940
마찬가지로, 어떤 사람들에게,
그 사실은 의미가있다.

1073
00:52:59,940 --> 00:53:03,080
계약자, 건축가,
그 어떤 의미를 갖습니다.

1074
00:53:03,080 --> 00:53:06,400
그리고 그들은, 경우 어떻게 할 것인지를 알 것
나는 말했다 건물을 건설 이동합니다.

1075
00:53:06,400 --> 00:53:10,520
>> 그러나 방에있는 우리의 대부분은 할 수 없었다
추상화의 수준 다룬다.

1076
00:53:10,520 --> 00:53:14,850
당신은 우리가 가서 좋아 말할 필요
삽과 콘크리트 가서

1077
00:53:14,850 --> 00:53:17,250
나무의 조각을 못
함께하고 어떤 다른

1078
00:53:17,250 --> 00:53:18,830
건물 건설에 참여하고있다.

1079
00:53:18,830 --> 00:53:21,690
우리가하지 않은 때문에 그건
아직 이해하도록 프로그램되어

1080
00:53:21,690 --> 00:53:23,629
이 건물을 구성하는 것이 무엇을 의미하는지.

1081
00:53:23,629 --> 00:53:24,920
우리는 추상화가 없습니다.

1082
00:53:24,920 --> 00:53:26,570
우리는 그 기능이 없습니다.

1083
00:53:26,570 --> 00:53:29,930
>> 그리고 당신은에서 볼 수 있습니다 무엇을
일반적으로, 프로그래밍 언어,

1084
00:53:29,930 --> 00:53:34,570
특히 더 현대적인 언어,
자바, PHP, 루비, 파이썬 등,

1085
00:53:34,570 --> 00:53:37,610
그들은 훨씬 더 성숙한 것
오래된 언어보다,

1086
00:53:37,610 --> 00:53:40,140
C 및 C ++ 아직 다른 이들처럼.

1087
00:53:40,140 --> 00:53:42,580
그래서 그들은 더와 함께
기능이 내장되어 있습니다.

1088
00:53:42,580 --> 00:53:45,640
더 많은 코드가 기록 된
과거에 사람들이

1089
00:53:45,640 --> 00:53:50,520
우리가 지금 호출 할 수 또는
내가 암시하고 있습니다로, 소환 또는 사용

1090
00:53:50,520 --> 00:53:52,231
과에서이 여기에 라인을 강조했다.

1091
00:53:52,231 --> 00:53:55,230
그리고 우리는 얘기를하지 않는 순간에도
그 자체 프로그래밍 언어에 대한,

1092
00:53:55,230 --> 00:54:00,230
그냥 의사 코드의 모든
아이디어는 토론에 여전히.

1093
00:54:00,230 --> 00:54:04,600
그리고 그것은 정밀도가 밝혀
슈퍼 중요한 추상화 같다.

1094
00:54:04,600 --> 00:54:06,570
그리고의가 봅시다
로 다음과 것이 통신합니다.

1095
00:54:06,570 --> 00:54:11,000
>> 실수로 버릇 수도
화면에 슬라이드를 점멸하여이

1096
00:54:11,000 --> 00:54:12,260
조기.

1097
00:54:12,260 --> 00:54:16,550
그러나 내가 용감한 자원 봉사에 대해 물어 보자,
당신은 오는 괜찮다면.

1098
00:54:16,550 --> 00:54:19,040
당신은 앞의 것
카메라, 그와 OK 있다면.

1099
00:54:19,040 --> 00:54:24,950
사람이 와서주고 싶습니다
여기에 귀하의 동료에게 지시?

1100
00:54:24,950 --> 00:54:29,540
그냥 여기 와서해야하고
여기 서서 몇 가지 단어를 말한다.

1101
00:54:29,540 --> 00:54:32,890
>> 빅토리아는 가장 웃
가장 내 눈을 피하는.

1102
00:54:32,890 --> 00:54:34,740
당신은 최대 어서시겠습니까?

1103
00:54:34,740 --> 00:54:35,240
승인.

1104
00:54:35,240 --> 00:54:38,480
그리고 당신의 좌석에 모두 다른 경우
스크랩 종이 조각을 걸릴 수 있습니다,

1105
00:54:38,480 --> 00:54:39,750
당신이됩니다.

1106
00:54:39,750 --> 00:54:40,760
줄이 그어진 된 종이는 괜찮습니다.

1107
00:54:40,760 --> 00:54:41,990
이 방법을 주위에 가자.

1108
00:54:41,990 --> 00:54:44,580
또는 용지의 일부가
당신이 어제 주어진,

1109
00:54:44,580 --> 00:54:46,493
그냥 빈 시트
종이, 경우에 당신은 할 수 있습니다.

1110
00:54:46,493 --> 00:54:52,240

1111
00:54:52,240 --> 00:54:54,870
그리고 당신은 어떤이없는 경우, 단지
당신이 할 수있는 경우 네 이웃을 부탁드립니다.

1112
00:54:54,870 --> 00:55:04,220

1113
00:55:04,220 --> 00:55:07,580
>> 순간을 위해, 대한 그래서
이 예, 빅토리아

1114
00:55:07,580 --> 00:55:11,520
의 역할을하는 것입니다
프로그래머, 엔지니어, 사람

1115
00:55:11,520 --> 00:55:16,130
로, 당신에게 모든 프로그램 필요
컴퓨터는 뭔가를 할 수 있습니다.

1116
00:55:16,130 --> 00:55:19,570
그리고 우리는 어떤 가정을 볼 수 있습니다
당신이 만들하기로 결정.

1117
00:55:19,570 --> 00:55:22,700
우리는 그녀가 할 선택하는 방법을 정확하게 볼 수 있습니다.

1118
00:55:22,700 --> 00:55:26,220
그리고이 데모가는 경우
교육적 아니라, 실수를 많이

1119
00:55:26,220 --> 00:55:29,220
우리는 그 다음 사용하는거야, 될 것이다
그 토론의 기회.

1120
00:55:29,220 --> 00:55:32,010
그러나 당신을위한 도전해야
이러한 실수를 방지하는,

1121
00:55:32,010 --> 00:55:32,896
좋은 프로그래머.

1122
00:55:32,896 --> 00:55:35,520
손 그리고 도전, 경우
당신은 여기 도보로 좋아하는 것

1123
00:55:35,520 --> 00:55:38,799
화면에서 빅토리아의 앞에
here--과 희망, 당신의 없음

1124
00:55:38,799 --> 00:55:40,590
때이 기억
화면에 떠올랐다.

1125
00:55:40,590 --> 00:55:44,097
그리고 있기 때문에, 모든 돌아서하지 않습니다
다른 화면이 방에있다

1126
00:55:44,097 --> 00:55:44,930
나는 끌 수있다.

1127
00:55:44,930 --> 00:55:46,620
그래서 돌아하지 않습니다.

1128
00:55:46,620 --> 00:55:49,090
>> 빅토리아 앞
같은 비명이다.

1129
00:55:49,090 --> 00:55:54,170
그리고 그녀의 작업은 이제 모든 말씀하는 것입니다
종이의 당신의 조각에 무엇을 그립니다.

1130
00:55:54,170 --> 00:55:57,020
그리고 우리는에 따라, 볼
혼자 구두 지시,

1131
00:55:57,020 --> 00:56:00,020
컴퓨터 코드, 만약에 당신,
얼마나 정확한 도면

1132
00:56:00,020 --> 00:56:02,330
귀하의 구현은으로 죠.

1133
00:56:02,330 --> 00:56:02,980
이해가?

1134
00:56:02,980 --> 00:56:03,604
>> 청중 : 네.

1135
00:56:03,604 --> 00:56:04,980
DAVID 마란 : OK, 실행합니다.

1136
00:56:04,980 --> 00:56:06,030
>> 청중 : 사각형을 그립니다.

1137
00:56:06,030 --> 00:56:09,050
>> [웃음]

1138
00:56:09,050 --> 00:56:12,310
>> DAVID 마란 : 그리고 더
질문은 질문 할 수있다.

1139
00:56:12,310 --> 00:56:13,720
단지 당신이 말을하는지 할 수 있습니다.

1140
00:56:13,720 --> 00:56:17,570

1141
00:56:17,570 --> 00:56:22,550
아, 그리고 당신은 할 경우 현재의 슬라이드
탭에서 열, 당신의 탭을보고하지 않습니다.

1142
00:56:22,550 --> 00:56:23,670
승인?

1143
00:56:23,670 --> 00:56:26,135
>> 청중 : OK, 원을 그립니다.

1144
00:56:26,135 --> 00:56:32,544

1145
00:56:32,544 --> 00:56:34,872
slope-- 나는 경사를 말할 수 있습니까?

1146
00:56:34,872 --> 00:56:35,830
DAVID 마란 : 당신까지.

1147
00:56:35,830 --> 00:56:38,230

1148
00:56:38,230 --> 00:56:38,980
청중 : 경사.

1149
00:56:38,980 --> 00:56:46,330

1150
00:56:46,330 --> 00:56:49,795
삼각형.

1151
00:56:49,795 --> 00:56:50,850
>> DAVID 마란 : 좋습니다.

1152
00:56:50,850 --> 00:56:52,286
그리고 잠시 여기있어.

1153
00:56:52,286 --> 00:56:56,046

1154
00:56:56,046 --> 00:56:58,910
그리고 올거야
주위에 잠시있다.

1155
00:56:58,910 --> 00:57:02,420
그리고 필요가 그것에 당신의 이름을 넣어 없습니다.

1156
00:57:02,420 --> 00:57:05,030
내가 돌아올하자
당신의 그림을 수집,

1157
00:57:05,030 --> 00:57:08,330
당신이 그들을 찢어 괜찮다면.

1158
00:57:08,330 --> 00:57:12,110
>> 여기에 우리가 돌​​아 왔을 것입니다.

1159
00:57:12,110 --> 00:57:14,770
나는 화면에 투사 할 수 있습니다.

1160
00:57:14,770 --> 00:57:18,310
나는 광장 참조 원,
기울기 및 삼각형.

1161
00:57:18,310 --> 00:57:20,130
그래서 거기에 한 가지 대답했다.

1162
00:57:20,130 --> 00:57:23,640
그리고 으악 let's--.

1163
00:57:23,640 --> 00:57:25,370
고맙습니다.

1164
00:57:25,370 --> 00:57:30,710
여기에 또 다른 구색입니다,
그 뒤에 하나.

1165
00:57:30,710 --> 00:57:34,130

1166
00:57:34,130 --> 00:57:37,120
>> 그래서 그들 모두는 정신을 캡처하는 것 같다.

1167
00:57:37,120 --> 00:57:38,600
고맙습니다.

1168
00:57:38,600 --> 00:57:44,970
거기에 또 다른, 그리고 여기에 또 다른 하나입니다.

1169
00:57:44,970 --> 00:57:51,590
기울기 통역 인
조금 다른, 매력적인 작은.

1170
00:57:51,590 --> 00:57:57,140
그리고, 하나 때문에 가장 가까운
당신이했습니다있는 멋진 특이성

1171
00:57:57,140 --> 00:58:03,520
설명, 또는 어쩌면 당신 종류의
그 이전에,이 참으로 보았다

1172
00:58:03,520 --> 00:58:06,340
빅토리아는 실제로 무엇을 설명했다.

1173
00:58:06,340 --> 00:58:09,190
>> 하지만 지금, 당신의 그 사람
그것은 아주 제대로하지 못했습니다,

1174
00:58:09,190 --> 00:58:11,140
이제 여기에 몇 가지 이의를 제공 할 수 있습니다.

1175
00:58:11,140 --> 00:58:13,770
그래서 빅토리아 먼저 사각형을 그립니다 말했다.

1176
00:58:13,770 --> 00:58:15,830
그리고 지금, 우리는 가정 할 수있다
오늘을 위해서

1177
00:58:15,830 --> 00:58:17,538
모두가 알
방법 사각형을 그립니다.

1178
00:58:17,538 --> 00:58:20,590
하지만, 오른쪽 전적으로 명확하지 않다?

1179
00:58:20,590 --> 00:58:23,220
어떻게 다른 당신은 할 수 있습니다
그린 광장, 또는 어디에

1180
00:58:23,220 --> 00:58:27,114
모호성의 일부를 수 있습니다
여기에 컴퓨터?

1181
00:58:27,114 --> 00:58:28,280
청중 : 위치 및 크기.

1182
00:58:28,280 --> 00:58:28,980
DAVID 마란 : 위치, 오른쪽?

1183
00:58:28,980 --> 00:58:32,070
여러분은 어떤 모양의 종이가 있었다
일반적으로 사각형,하지만 약간

1184
00:58:32,070 --> 00:58:32,830
다른 크기.

1185
00:58:32,830 --> 00:58:36,250
하지만 당신은 확실히, 그린 수
경우에 당신은 아마, 거대한 사각형을 원했다

1186
00:58:36,250 --> 00:58:37,220
작은 광장입니다.

1187
00:58:37,220 --> 00:58:38,417
아마도 이것은 회전시켰다.

1188
00:58:38,417 --> 00:58:39,500
나는 우리가 그것을보고 생각하지 않습니다.

1189
00:58:39,500 --> 00:58:41,790
그러나 더 다이아몬드 수 있었다
같은 그래도, 그럼에도 불구하고,

1190
00:58:41,790 --> 00:58:42,900
사각형을 수학적으로.

1191
00:58:42,900 --> 00:58:44,850
그래서 틀림없이 모호했다.

1192
00:58:44,850 --> 00:58:46,709
>> 그런 다음 그녀는 원을 그리 말했다.

1193
00:58:46,709 --> 00:58:49,250
당신의 일부는 다음에 그립니다 않았다
무리없는 것이,

1194
00:58:49,250 --> 00:58:52,450
인간은 생각 또는 읽기 경향이 있기 때문에
바로 대부분의 언어에 남아, 그렇게하지 ​​않으려면

1195
00:58:52,450 --> 00:58:53,017
나쁜 생각.

1196
00:58:53,017 --> 00:58:55,100
하지만 원은 할 수
사각형 내부에 있었다,

1197
00:58:55,100 --> 00:58:57,600
주위에 수 있었다
광장, 다른 수 있었다

1198
00:58:57,600 --> 00:58:59,480
시트에, 그래서 틀림없이 모호한.

1199
00:58:59,480 --> 00:59:03,290
>> 경사 어쩌면되었을 수 있습니다
구두로 가장 자유를 복용

1200
00:59:03,290 --> 00:59:04,200
그게 무슨 뜻인지와.

1201
00:59:04,200 --> 00:59:06,980
그리고 몇 가지 해석
그것을 구불 구불 한 선으로

1202
00:59:06,980 --> 00:59:08,560
직선 등이나.

1203
00:59:08,560 --> 00:59:11,719
그리고 삼각형도 할 수
임의의 수의 방법으로 배향되었다.

1204
00:59:11,719 --> 00:59:14,760
짧은에, 심지어 뭔가 그래서
그래서, 당신은 언뜻 당신은 와우, 같은거야

1205
00:59:14,760 --> 00:59:17,020
간단하고, 아이가 수
이 잘되지 그릴

1206
00:59:17,020 --> 00:59:19,640
정말하지 않는 한 당신은있어
슈퍼, 슈퍼 설득력

1207
00:59:19,640 --> 00:59:22,045
컴퓨터를 말해
정확히 무엇을 할 수 있습니다.

1208
00:59:22,045 --> 00:59:24,420
당신이있는 경우에, 우리가 할 수있는 경우 그래서
종이 다른 시트,하자

1209
00:59:24,420 --> 00:59:26,710
이 한 번 더하려고합니다.

1210
00:59:26,710 --> 00:59:29,880
그리고 난 빅토리아를 줄거야
여기에 화면에 다른 예.

1211
00:59:29,880 --> 00:59:34,060
그리고 다시 돌아하지 않습니다
및 슬라이드 보지 않습니다.

1212
00:59:34,060 --> 00:59:37,304
그리고 나는 그녀에게 잠시 시간을 줄 것이다
이것을 설명하는 방법에 대해 생각합니다.

1213
00:59:37,304 --> 00:59:39,012
그들을 보자하지 마십시오
당신의 눈에서 두려움.

1214
00:59:39,012 --> 00:59:40,820
>> [웃음]

1215
00:59:40,820 --> 00:59:43,710
>> 그리고 또,이 시간 활용
그 집에 사 가지고가는 요리의 일부

1216
00:59:43,710 --> 00:59:48,130
거의 모든 사람을 얻으려고
정답 적어도.

1217
00:59:48,130 --> 00:59:52,260
>> 청중 : 확인하는을
종이 조각 봐

1218
00:59:52,260 --> 00:59:54,500
종이의 조각의 중간입니다.

1219
00:59:54,500 --> 00:59:59,591
그 부분의 중간에
종이, 큐브를 그립니다.

1220
00:59:59,591 --> 01:00:01,244
>> [웃음]

1221
01:00:01,244 --> 01:00:02,660
DAVID 마란 : 우리가 배운 내용이?

1222
01:00:02,660 --> 01:00:03,540
우리는 너무 가까이 있었다.

1223
01:00:03,540 --> 01:00:06,320

1224
01:00:06,320 --> 01:00:09,045
당신이 할 수있는 경우 OK, 모두를 위해, 반복합니다.

1225
01:00:09,045 --> 01:00:13,210
>> 대상 :의 중간에
종이 조각은 객체를 그립니다

1226
01:00:13,210 --> 01:00:14,842
이는 큐브처럼 보인다.

1227
01:00:14,842 --> 01:00:17,332
>> DAVID 마란 : OK, 그건
모두가 함께 작동하도록 얻을.

1228
01:00:17,332 --> 01:00:20,010

1229
01:00:20,010 --> 01:00:23,080
내가 분석 할 수 있도록
중요한 것이 라기보다는,

1230
01:00:23,080 --> 01:00:25,720
하지만 주장을 만들려면
그 빅토리아 확실히

1231
01:00:25,720 --> 01:00:28,967
매우에서 생각하는 것 같다
높은 수준의 추상화, 어떤

1232
01:00:28,967 --> 01:00:29,800
무리하지 않다.

1233
01:00:29,800 --> 01:00:32,160
그렇지 않으면 때문에, 우리는 모든 거라고
꽤 역기능 수

1234
01:00:32,160 --> 01:00:35,740
우리가 아무리 정확해야한다면
모든 것을 우리는 세계에서 할.

1235
01:00:35,740 --> 01:00:38,890
>> 그러나 말하는 middle-- I로 이동
우리는 좋은 트랙에서 줄 알았는데

1236
01:00:38,890 --> 01:00:42,340
이 같은 아주 중앙으로 이동
페이지의 다음 큐브를 그립니다.

1237
01:00:42,340 --> 01:00:45,730
그래서 그녀는 추상화의 생각을,
그녀는 여전히 볼 수 있기 때문에

1238
01:00:45,730 --> 01:00:48,490
무엇은 실제로 화면에 큐브입니다.

1239
01:00:48,490 --> 01:00:51,185
그러나 많은 기회가있다
이 해석.

1240
01:00:51,185 --> 01:00:53,560
그리고 사실, 이렇게 많은있다
당신이 표현할 수있는 다른 방법

1241
01:00:53,560 --> 01:00:55,101
나는 순간에 제안합니다되는 그.

1242
01:00:55,101 --> 01:00:59,770
그래서 여기에 우리가 하나의 화신이
picture-- whoops-- 하나의

1243
01:00:59,770 --> 01:01:02,830
사진의 화신, 그래서
그것에 작은 3 차원,

1244
01:01:02,830 --> 01:01:04,160
어떤 좋은 것입니다.

1245
01:01:04,160 --> 01:01:08,470
>> 당신이이 곳 여기에 또 다른 하나의
같은, 그것은 오픈 큐브의 종류 비록.

1246
01:01:08,470 --> 01:01:12,020
일부 사람들은 그것을 조금했다
더 플랫, 두 차원.

1247
01:01:12,020 --> 01:01:13,910
그리고 괜찮아요.

1248
01:01:13,910 --> 01:01:17,380
그래서이 참에
용지의 중심.

1249
01:01:17,380 --> 01:01:22,720
이 사람은 당신이 거 같아요
같은, 우리가 여기 가면 때문에,

1250
01:01:22,720 --> 01:01:25,130
이것은 그녀가 설명 된 것입니다.

1251
01:01:25,130 --> 01:01:29,570
그래서 지금, 내가 제안하는 방법을 다른하자
우리는이 상황을 설명 할 수 있습니다.

1252
01:01:29,570 --> 01:01:34,070
>> 대부분의 위로 하루에, 하나
프로그래밍을 배울 수있는 일반적인 방법

1253
01:01:34,070 --> 01:01:38,900
코드를 작성하는 것이었다 기록
명령어 라인,

1254
01:01:38,900 --> 01:01:42,640
그건 좀 제어
화면에 거북이.

1255
01:01:42,640 --> 01:01:45,660
로고와이 다른 변종
언어의 이름이다.

1256
01:01:45,660 --> 01:01:47,550
그리고 거북은 세계에서 살았습니다.

1257
01:01:47,550 --> 01:01:49,970
>> 그래서이 직사각형을 가정
공간은 자신의 세계이다.

1258
01:01:49,970 --> 01:01:53,340
그리고 당신은 assuming-- I로 시작하는 것입니다
정말 거북이를 그리는 방법을 몰라,

1259
01:01:53,340 --> 01:01:54,740
그래서 이런 식으로 그것을 할 수 있습니다.

1260
01:01:54,740 --> 01:01:57,340
그리고 그는 쉘 있어요
다음 아마 몇 피트.

1261
01:01:57,340 --> 01:01:59,840
그래서 당신이 조금있을 수 있습니다
화면에 문자.

1262
01:01:59,840 --> 01:02:02,270
>> 그리고 이것의 목적
프로그래밍 언어

1263
01:02:02,270 --> 01:02:06,070
거북이를 강요했다
위로 이동, 아래, 오른쪽, 왼쪽

1264
01:02:06,070 --> 01:02:08,420
아래로 자신의 펜을 넣어
또는 그의 펜 픽업,

1265
01:02:08,420 --> 01:02:12,720
그래서 그는 실제로 화면에 그릴 수
바로이 평평한 직사각형 세계 요.

1266
01:02:12,720 --> 01:02:16,850
그래서 나는 당신이 갈 줄 알았는데 경우,
당신은 다이빙을 고려해야 곳

1267
01:02:16,850 --> 01:02:19,520
정신적으로까지 설명 할 때
더 일반적 지침,

1268
01:02:19,520 --> 01:02:21,720
내가 넣어 항 것이다 당신의
아래 middle-- 펜

1269
01:02:21,720 --> 01:02:23,100
우리는 없애합니다
거북이 때문에 그럴 수 없어 정말

1270
01:02:23,100 --> 01:02:24,680
아주 잘 그를 그리기 유지.

1271
01:02:24,680 --> 01:02:27,170
>> 그리고 지금, 어떻게 다른 사람은 할 수
나는 큐브를 그려 말?

1272
01:02:27,170 --> 01:02:32,830
음, 우리는 무승부 뭔가를 말할 수
대각선의 북동쪽, 예를 들어,

1273
01:02:32,830 --> 01:02:35,182
또는 위쪽으로 45도 각도로.

1274
01:02:35,182 --> 01:02:36,640
그리고 그 날 여기 받고 있습니다.

1275
01:02:36,640 --> 01:02:38,380
그리고 나는 꽤 멀리 큐브에서입니다.

1276
01:02:38,380 --> 01:02:42,430
하지만 지금은, 내가 뭔가를 말할 수
추천 왼쪽으로 90도 회전

1277
01:02:42,430 --> 01:02:47,370
과의 선을 그립니다
동일한 길이의 북서쪽.

1278
01:02:47,370 --> 01:02:49,470
그리고 나는 계속할 수 있었다
비슷한 방향으로.

1279
01:02:49,470 --> 01:02:50,720
그리고 그것은 쉽지 않을거야.

1280
01:02:50,720 --> 01:02:53,345
그리고 솔직히, 우리는 아마 것
5 분 동안 여기에 있었다.

1281
01:02:53,345 --> 01:02:59,600
하지만 어쩌면 우리는에 얻었을 것이다
일 그 하루의 끝에

1282
01:02:59,600 --> 01:03:04,280
큐브되고 끝납니다 만,
그 추상화의 내부에 뛰어 들었다

1283
01:03:04,280 --> 01:03:06,370
이러한 낮은 그것을 수행하는
수준은 당신이 할 수없는 정말

1284
01:03:06,370 --> 01:03:09,795
당신이 전체 때까지 무슨 일을하는지 참조
것은 페이지에 실제로있다.

1285
01:03:09,795 --> 01:03:12,670
그래서 이것은 일반적인 원칙이다,
다시, programming--이 아이디어의

1286
01:03:12,670 --> 01:03:13,320
추상화.

1287
01:03:13,320 --> 01:03:15,920
너무 멋지고입니다
강력한 다시 때문에,

1288
01:03:15,920 --> 01:03:19,281
그녀는 단지, 어떤 모든 큐브를 그려 말했다
우리는 꽤 많은 매우 빠르게 grok 수있다.

1289
01:03:19,281 --> 01:03:21,030
우리는 이해할 것이다,
OK, 큐브를 그립니다.

1290
01:03:21,030 --> 01:03:24,030
우리는 방향을 알고하지 않을 수 있습니다
그래서 우리는, 좀 더 정확한 수

1291
01:03:24,030 --> 01:03:26,297
그러나 우리는 일반적으로 그릴 수
또는 큐브가 무엇인지 알고있다.

1292
01:03:26,297 --> 01:03:28,130
그리고는, 유용
때문에 경우 때마다

1293
01:03:28,130 --> 01:03:31,540
프로그래머에 같이 앉아서
키보드는 코드를 작성하는

1294
01:03:31,540 --> 01:03:33,912
당신은에서 생각해야한다면
낮은 수준의 우리의 없음

1295
01:03:33,912 --> 01:03:35,120
지금까지 아무것도 끝낼 것입니다.

1296
01:03:35,120 --> 01:03:38,259
그리고 확실히, 우리 중 누구도 것
코드를 작성하는 과정을 즐길 수 있습니다.

1297
01:03:38,259 --> 01:03:41,550
그것은, 0과 1의 쓰기와 같은 것
이는 솔직하게 모든 것을 오래 전에 아니었다

1298
01:03:41,550 --> 01:03:43,680
인간은 0과 1의 코드를 작성했다.

1299
01:03:43,680 --> 01:03:46,960
그리고 우리는 매우 빨리 함께했다
이러한 높은 수준의 languages​​--

1300
01:03:46,960 --> 01:03:49,410
C ++ 및 Java 등이 있습니다.

1301
01:03:49,410 --> 01:03:52,500
>> 그래서 그냥이 한 번 더 해보자
, 테이블을 뒤집어 우리 모두 그렇게

1302
01:03:52,500 --> 01:03:55,450
생각하는 기회가
오히려 동일하게 실시 하였다.

1303
01:03:55,450 --> 01:03:59,230
우리는 또 하나의 자원이 얻을 수
시간은 이사회에 와서 그립니다

1304
01:03:59,230 --> 01:04:01,480
암송하지?

1305
01:04:01,480 --> 01:04:02,070
OK, 그래.

1306
01:04:02,070 --> 01:04:04,820
벤, 최대 어서.

1307
01:04:04,820 --> 01:04:08,510
그리고, 벤,이 경우에는 한번
보드를 직면 왼쪽 보이지 않는,

1308
01:04:08,510 --> 01:04:09,370
바로 보이지 않습니다.

1309
01:04:09,370 --> 01:04:12,367
만 일을 당신을
동료들은 당신을 알려줍니다.

1310
01:04:12,367 --> 01:04:14,950
그리고에서 다른 사람에 대한
방, 이제 프로그래머.

1311
01:04:14,950 --> 01:04:16,020
그는 컴퓨터입니다.

1312
01:04:16,020 --> 01:04:21,395
그리고 그림은 여기 선택한
사전에 여기 하나입니다.

1313
01:04:21,395 --> 01:04:24,490

1314
01:04:24,490 --> 01:04:27,660
그들은 생각하고 그냥 ...하고
재미있는 농담의 전부입니다.

1315
01:04:27,660 --> 01:04:31,510
>> 그래서 누군가에 같은 않는 것
첫 번째 명령을 자원 봉사

1316
01:04:31,510 --> 01:04:35,470
또는 문은해야
명령 벤의 펜?

1317
01:04:35,470 --> 01:04:40,850
그리고 우리는 어쩌면, 공동으로이 작업을 수행 할 수 있습니다
각 사람에서 하나의 명령.

1318
01:04:40,850 --> 01:04:41,440
죄송 해요?

1319
01:04:41,440 --> 01:04:42,440
>> 청중 : 원을 그립니다.

1320
01:04:42,440 --> 01:04:45,866
데이비드 마란는 : 원을 그립니다
내가들은 가장 먼저입니다.

1321
01:04:45,866 --> 01:04:47,100
>> 청중 : 최대 탑.

1322
01:04:47,100 --> 01:04:48,140
>> DAVID 마란 : 최대 탑.

1323
01:04:48,140 --> 01:04:52,504
OK, 우리는 당신이 삭제 취소 할 수 있습니다.

1324
01:04:52,504 --> 01:04:53,420
그리고 지금, 다른 사람.

1325
01:04:53,420 --> 01:04:55,994
단, 당신은 편안 것
다음 명령을 제공?

1326
01:04:55,994 --> 01:05:02,070
>> 청중 : 물론, 중심을 그립니다
원형의 바닥,

1327
01:05:02,070 --> 01:05:07,121
A는 조금 small--와
그에서 작은 공간,

1328
01:05:07,121 --> 01:05:15,420
세까지 직선을 그립니다
보드 내리막 길의 분기

1329
01:05:15,420 --> 01:05:17,845
왼쪽에 약간의 각도.

1330
01:05:17,845 --> 01:05:21,250

1331
01:05:21,250 --> 01:05:22,620
>> DAVID 마란 : 좋은.

1332
01:05:22,620 --> 01:05:24,086
>> 청중 : 약간의 각도.

1333
01:05:24,086 --> 01:05:32,807
>> DAVID 마란 : 실행 취소, 제어-Z. 승인.

1334
01:05:32,807 --> 01:05:34,890
앤드류, 당신은 제공 할
다음 명령까지?

1335
01:05:34,890 --> 01:05:35,515
>> 청중 : 물론.

1336
01:05:35,515 --> 01:05:43,250
그 라인의 바닥에서,
또 약간의 angle--

1337
01:05:43,250 --> 01:05:49,024
whoops-- 아마 제에 대한
길이 [들리지]

1338
01:05:49,024 --> 01:05:52,928
약간의 각도 아래쪽과 같은
[들리지]의 길이의 3 분.

1339
01:05:52,928 --> 01:05:57,550

1340
01:05:57,550 --> 01:06:00,578
그래서 그래, 그 시점에서,
선에게 세 번째 무승부

1341
01:06:00,578 --> 01:06:04,150
이전의 길이
더 왼쪽 라인.

1342
01:06:04,150 --> 01:06:08,416

1343
01:06:08,416 --> 01:06:10,040
>> DAVID 마란 : 즉, OK?

1344
01:06:10,040 --> 01:06:12,330
직선, 즉 OK인가?

1345
01:06:12,330 --> 01:06:14,900
OK, 올리비에는, 당신이 원하는
다음을 제공 하는가?

1346
01:06:14,900 --> 01:06:28,564
>> 청중 : [들리지]에서
원의 하단, [들리지].

1347
01:06:28,564 --> 01:06:32,000

1348
01:06:32,000 --> 01:06:45,126
오른쪽에 그리기
의 [들리지] 센티미터.

1349
01:06:45,126 --> 01:06:46,560
>> [웃음]

1350
01:06:46,560 --> 01:06:49,872
>> 데이비드 마란 : 당신이가는 것 같아요
즉 여기 인치의 변환합니다.

1351
01:06:49,872 --> 01:06:50,764
>> 청중 : 중지합니다.

1352
01:06:50,764 --> 01:06:52,186
>> [웃음]

1353
01:06:52,186 --> 01:06:54,570
>> DAVID 마란 : OK.

1354
01:06:54,570 --> 01:06:56,660
[? 아,?] 당신이 원하는
다음을 제공 하는가?

1355
01:06:56,660 --> 01:07:00,653

1356
01:07:00,653 --> 01:07:15,443
>> 청중 : 그립니다 [들리지]
위 [들리지] 같은.

1357
01:07:15,443 --> 01:07:28,829
[들리지] 원은 그릴
[들리지]와 [들림]립니다.

1358
01:07:28,829 --> 01:07:33,799

1359
01:07:33,799 --> 01:07:36,730
>> DAVID 마란 : OK, 더 이상 취소.

1360
01:07:36,730 --> 01:07:38,390
의 하나 또는 둘 이상의 명령을 수행 할 수 있습니다.

1361
01:07:38,390 --> 01:07:40,825
크리스, 당신은 하나를 제공 할?

1362
01:07:40,825 --> 01:07:46,182
>> 대상 : 하단에서
원, [들리지]

1363
01:07:46,182 --> 01:07:51,528
동일한 라인 slopping을 그립니다
왼쪽 [들리지]로 하향.

1364
01:07:51,528 --> 01:07:59,304

1365
01:07:59,304 --> 01:08:00,590
>> DAVID 마란 : OK.

1366
01:08:00,590 --> 01:08:01,170
앤드류?

1367
01:08:01,170 --> 01:08:02,472
우리는 카림 뭐 실수?

1368
01:08:02,472 --> 01:08:06,891

1369
01:08:06,891 --> 01:08:13,765
>> 대상 : 오른쪽 줄에서 시작,
왼쪽 라인의 끝 하단

1370
01:08:13,765 --> 01:08:21,012
당신에 대한 권리 갈거야
그 라인과 같은 길이

1371
01:08:21,012 --> 01:08:27,680
당신은 드로잉에있어
오른쪽 [들리지].

1372
01:08:27,680 --> 01:08:33,572

1373
01:08:33,572 --> 01:08:37,991
[들리지]도, 그래서 [들리지]
오른쪽에 학위.

1374
01:08:37,991 --> 01:08:41,919

1375
01:08:41,919 --> 01:08:43,500
>> DAVID 마란 : 좋습니다.

1376
01:08:43,500 --> 01:08:44,029
의 일시 중지 할 수 있습니다.

1377
01:08:44,029 --> 01:08:44,950
아직 돌아하지 마십시오.

1378
01:08:44,950 --> 01:08:46,783
의 일시 중지하자 및하자
하나의 다른 시도를하려고

1379
01:08:46,783 --> 01:08:48,850
우리는 벤에 공개하기 전에
그가 드로잉 됐어요.

1380
01:08:48,850 --> 01:08:51,189
당신은에 벤 셔플 수
right-- 또는 실제로,

1381
01:08:51,189 --> 01:08:54,080
아니, 그냥 당신을 줄 수 있습니다
다른 보드, 더 나은.

1382
01:08:54,080 --> 01:08:57,640
그래서 누군가 지금 싶습니다
접근의 더 걸릴 수 있습니다

1383
01:08:57,640 --> 01:09:02,149
빅토리아에 이전했다가, 어디
우리는 더 높은 레벨의 추상화로 이야기

1384
01:09:02,149 --> 01:09:05,149
단지 문장
두 벤에 설명

1385
01:09:05,149 --> 01:09:07,229
무엇없이 무승부
잡초로 받고,

1386
01:09:07,229 --> 01:09:10,670
그래서이 낮은 수준에서, 말하자면?

1387
01:09:10,670 --> 01:09:11,206
빅토리아.

1388
01:09:11,206 --> 01:09:11,706
[웃음]

1389
01:09:11,706 --> 01:09:14,249
청중 : 그림을 그리기
걷는 남자의.

1390
01:09:14,249 --> 01:09:18,866
그리고 그의 다리와 팔
오른쪽해야합니다.

1391
01:09:18,866 --> 01:09:20,505
>> DAVID 마란 : OK, 즉 당신이 얻을 모든입니다.

1392
01:09:20,505 --> 01:09:27,210

1393
01:09:27,210 --> 01:09:27,710
괜찮아.

1394
01:09:27,710 --> 01:09:31,609
왜 우리는 그가 무슨 짓을했는지 벤에 공개하지 않습니다.

1395
01:09:31,609 --> 01:09:32,890
박수 그래서 라운드.

1396
01:09:32,890 --> 01:09:35,700
즉, 어려운 아마도이었다.

1397
01:09:35,700 --> 01:09:37,931
>> 그래서 심지어 우리가 얘기하지만
상당히 바보 같은 측면에서

1398
01:09:37,931 --> 01:09:39,680
단지 그림에 대한
사진, 당신이 희망

1399
01:09:39,680 --> 01:09:44,226
정말 정도를 감상 할 수있다
해야 할 수도 있습니다 표현력

1400
01:09:44,226 --> 01:09:45,850
무엇을 할 수있는 컴퓨터를 이야기하기 위해서입니다.

1401
01:09:45,850 --> 01:09:50,370
사실, 그 사실 벤
이렇게 빨리이를 그릴 수 있었다

1402
01:09:50,370 --> 01:09:54,227
증거의 종류는를 사용하는 것입니다
언어, 어쩌면 상위 레벨

1403
01:09:54,227 --> 01:09:57,060
영어 버전, 즉 그를 수 있습니다
그냥 단어를 사용하거나 단어를 듣고

1404
01:09:57,060 --> 01:09:59,990
빅토리아에서 그를 허용하는
이건 그냥 그릴 abstractions--

1405
01:09:59,990 --> 01:10:03,020
받는 걷는 그림
right-- 일종의 갖는다

1406
01:10:03,020 --> 01:10:07,100
그것은 그에게 어떤 의미 론적 의미는 아니다
거의 분명 당신은있을 때

1407
01:10:07,100 --> 01:10:10,310
말을, 아래로 펜을 넣어 무승부
오른쪽 왼쪽으로 그린​​다.

1408
01:10:10,310 --> 01:10:12,420
>> 그래서이 역시 매우입니다
프로그래밍에서 일반적으로.

1409
01:10:12,420 --> 01:10:15,253
이것은 같은라고 할 것이다
매우 낮은 수준의 언어, 프로그래밍

1410
01:10:15,253 --> 01:10:16,730
만약에 당신 0과 1입니다.

1411
01:10:16,730 --> 01:10:19,320
그리고 이것은 높은 수준의 것
자바 언어 프로그래밍,

1412
01:10:19,320 --> 01:10:20,278
또는 그런 일.

1413
01:10:20,278 --> 01:10:22,050
의 비트
단순화,하지만 그건

1414
01:10:22,050 --> 01:10:24,310
감정 등의 종류
이 때 느끼는 느낌

1415
01:10:24,310 --> 01:10:26,630
일 또는 다른 한 종류를 사용하여.

1416
01:10:26,630 --> 01:10:32,650
필요에 의해 여기 좌절의 비트
이러한 정밀하지만 기회

1417
01:10:32,650 --> 01:10:34,930
와 약간 느슨한 될 수 있습니다
여기에 해석.

1418
01:10:34,930 --> 01:10:38,060
그러나 물론, 버그
결과로 발생할 수 있습니다.

1419
01:10:38,060 --> 01:10:40,500
>> 당신은 home--에서 원하는 경우 우리
그 수업에서이 일을하지 않을 것이다

1420
01:10:40,500 --> 01:10:41,900
하지만 당신은하고 싶은 경우
이 하나의 가정을 가지고,

1421
01:10:41,900 --> 01:10:43,387
나는 우리가이에 뛰어 거라 생각 했어요.

1422
01:10:43,387 --> 01:10:45,970
당신이 재생하려는 경우 그래서
당신의 중요한 다른과 게임

1423
01:10:45,970 --> 01:10:49,180
또는 아이 등, 당신
그뿐만 아니라 즐길 수 있습니다.

1424
01:10:49,180 --> 01:10:54,460
>> 그럼 가서 보자 마지막보고
여기에 전산 사고 것.

1425
01:10:54,460 --> 01:10:57,010
그리고 그 존에 우리를 제공합니다
아닌 클립 올리버,

1426
01:10:57,010 --> 01:11:00,070
당신이 지난 밤에 본 적이 있습니다,
하지만 다소 최근의 문제이다.

1427
01:11:00,070 --> 01:11:03,310
다시 몇 달, 폭스 바겐
방탄 꽤했다

1428
01:11:03,310 --> 01:11:05,651
어떤 이유로, 당신은 알고 있다면?

1429
01:11:05,651 --> 01:11:07,025
그들은 문제가 무엇을 얻었 는가?

1430
01:11:07,025 --> 01:11:10,270

1431
01:11:10,270 --> 01:11:14,030
>> 그래, emissions-- 때문에
배출량을 이길하려고했던

1432
01:11:14,030 --> 01:11:19,100
기본적으로 가짐으로써 테스트 자신의
자동차 적은 환경을 오염

1433
01:11:19,100 --> 01:11:23,620
자신의 차를 테스트 할 때
많은 환경을 오염

1434
01:11:23,620 --> 01:11:25,547
자동차는 테스트되지 때.

1435
01:11:25,547 --> 01:11:28,630
그리고 무슨 일이 점점 더 흥미 롭군요
세계로 당신은 추정이있을 수 있습니다

1436
01:11:28,630 --> 01:11:34,072
이렇게 ... 토론에서 어떤이다
그건 ... CarPlay, 자동차에 대한 애플의 소프트웨어

1437
01:11:34,072 --> 01:11:35,780
많은 사실
우리의 점점

1438
01:11:35,780 --> 01:11:38,390
우리 자동차에서 터치 스크린을 가지고
무서운 양이있다

1439
01:11:38,390 --> 01:11:41,250
사람들의 소프트웨어의
자동차 오늘, 어떤

1440
01:11:41,250 --> 01:11:45,650
솔직히 웜 때의 전체 캔을 엽니 다
그것은 보안과 물리적 위험에 온다.

1441
01:11:45,650 --> 01:11:48,070
그러나 오늘,하자
그냥 무엇에 초점

1442
01:11:48,070 --> 01:11:52,170
쓰기 소프트웨어에 포함
그 시스템을 gamed했을 수 있습니다.

1443
01:11:52,170 --> 01:11:54,510
>> 의 정의에 대한
문제, 익숙하지 않은 사람들을 위해,

1444
01:11:54,510 --> 01:11:55,740
의 존 올리버 살펴 보자.

1445
01:11:55,740 --> 01:11:58,115
그리고 익숙한 사람들을 위해
문제는, 이제 그것을 살펴 보자

1446
01:11:58,115 --> 01:12:00,480
뿐만 아니라 존 올리버를 통해 재미 렌즈입니다.

1447
01:12:00,480 --> 01:12:05,810
그래서, 내가 이것에 재생을 공격하자
세 분 소개, 생각합니다.

1448
01:12:05,810 --> 01:12:07,074
젠장.

1449
01:12:07,074 --> 01:12:07,740
[VIDEO 재생]

1450
01:12:07,740 --> 01:12:08,170
-Cars--

1451
01:12:08,170 --> 01:12:09,919
DAVID 마란 : 분명히,
YouTube에서, 그게 ...

1452
01:12:09,919 --> 01:12:12,500
- 고마웠다 똑똑한 문자
빠른 기세 영화.

1453
01:12:12,500 --> 01:12:16,080
이번 주, 독일의 자동차
폭스 바겐은 자체 발견

1454
01:12:16,080 --> 01:12:19,430
의 스캔들의 중간에
잠재적 범죄 비율.

1455
01:12:19,430 --> 01:12:23,020
>> -Volkswagen는 수십억 보강한다
벌금, 형사 책임

1456
01:12:23,020 --> 01:12:25,530
그 임원 등
이 회사는 사과

1457
01:12:25,530 --> 01:12:28,790
11 만대를 장비에 대한
이 방출 시험을 이길 도움이됩니다.

1458
01:12:28,790 --> 01:12:32,110
>> -Certain 디젤 모델을 설계 하였다
정교한 소프트웨어와 그

1459
01:12:32,110 --> 01:12:35,410
위치를 포함하여 사용 정보,
핸들 차량의

1460
01:12:35,410 --> 01:12:38,820
속도, 자동차이었다 결정
방출 시험을 진행.

1461
01:12:38,820 --> 01:12:42,620
그 상황에서, 엔진
독성 배출을 감소시킬 것이다.

1462
01:12:42,620 --> 01:12:46,040
그러나 자동차는 수동으로 조작되고 있었다
그것이가 구동 될 때.

1463
01:12:46,040 --> 01:12:51,370
배출량은 40 10 증가
허용 EPA 수준 이상 시간.

1464
01:12:51,370 --> 01:12:55,920
>> 구뒤, 10 내지 40 배
EPA에 이상이 있습니다.

1465
01:12:55,920 --> 01:12:59,570
즉 최악의 일이
폭스 바겐은 이제까지 수행 한

1466
01:12:59,570 --> 01:13:04,200
당신이 경우 말할 수 뭔가입니다
당신은 세계 대전의 들어 본 적이없는 것입니다.

1467
01:13:04,200 --> 01:13:09,710
방법하지만 어쩌면 가장 확실한 기호
폭스 바겐에 많은 문제가,

1468
01:13:09,710 --> 01:13:12,730
입니다 아주의 사람들
정상은 사임했다.

1469
01:13:12,730 --> 01:13:16,320
CEO는 후 수요일에 사임
손상 제어 할 스크램블링

1470
01:13:16,320 --> 01:13:20,380
그는 끝없이 미안하다고 말을하는
그것이 나왔던 때까지 큰 소리가났다

1471
01:13:20,380 --> 01:13:22,920
그는 단지 10 % 미안
하지만 그의 입을 리깅했다

1472
01:13:22,920 --> 01:13:25,600
인위적으로 자신의 sorriness을 팽창합니다.

1473
01:13:25,600 --> 01:13:29,700
그리고 한편, 폭스​​ 바겐의 미국
최고는 자신의 사과를했다.

1474
01:13:29,700 --> 01:13:33,580
>> 의 이것에 대해 명확하게 - 가자,
우리 회사는 정직했다.

1475
01:13:33,580 --> 01:13:37,140
그리고 내 독일어 즉, 우리
완전히 망쳐했다.

1476
01:13:37,140 --> 01:13:41,360
>> - 네,하지만 완전히 나사
최대 독일어 작동하지 않습니다.

1477
01:13:41,360 --> 01:13:43,750
그리고 독일어
많은 아름다운 문구가

1478
01:13:43,750 --> 01:13:50,070
다만이 같은 상황을 설명하기 위해,
이러한 대략 수단 [GERMAN]으로서

1479
01:13:50,070 --> 01:13:52,870
오는 슬픔
비즈니스 관련 거짓말에서,

1480
01:13:52,870 --> 01:13:59,060
또는 [독일어], 이는 변환
관련된 사람의 아버지를 창피으로

1481
01:13:59,060 --> 01:14:00,352
가솔린의 구름입니다.

1482
01:14:00,352 --> 01:14:02,060
그것은 아름다운 언어입니다.

1483
01:14:02,060 --> 01:14:04,660
그냥 혀를 항해.

1484
01:14:04,660 --> 01:14:07,920
그리고 그런데, 그 사람의 동안
사과는 진심 소리 모른다

1485
01:14:07,920 --> 01:14:12,260
그가에서 연설했다 주목할 필요가
2016 년 공식 런칭 파티

1486
01:14:12,260 --> 01:14:17,310
그 곧 의미 폭스 바겐 파사트,
죄송합니다 말을 한 후, 그는 이렇게 말했다.

1487
01:14:17,310 --> 01:14:18,850
>> 와 주셔서 대단히 고마워요.

1488
01:14:18,850 --> 01:14:19,630
저녁을 즐길 수 있습니다.

1489
01:14:19,630 --> 01:14:21,300
위로 다음 레니 크라비츠이다.

1490
01:14:21,300 --> 01:14:24,640
>> [음악 재생]

1491
01:14:24,640 --> 01:14:28,230
>> -OK, 확인, 종료하여
최대 옆에 사과

1492
01:14:28,230 --> 01:14:31,940
레니 크라비츠하지 않습니다
냉정한 회개 비명.

1493
01:14:31,940 --> 01:14:35,830
그것은 비명 소리, 우리는 봉 요청
조비, 그는 아무 말했다.

1494
01:14:35,830 --> 01:14:38,600
폭스 바겐의 브랜드가
심하게 손상되었다.

1495
01:14:38,600 --> 01:14:42,466
그리고 솔직히, 새로운 광고
캠페인은 정확하게 도움이되지 않습니다.

1496
01:14:42,466 --> 01:14:47,289
>> - [독일어], 폭스 바겐에서 우리는 싶습니다
당신을 속이고을 드려 죄송합니다

1497
01:14:47,289 --> 01:14:47,930
우리의 차량.

1498
01:14:47,930 --> 01:14:48,513
>> [END 재생]

1499
01:14:48,513 --> 01:14:54,090
데이비드 마란이 : 그래서이 선수
로터리 방식 동행입니다 sorry--

1500
01:14:54,090 --> 01:14:58,730
이의 원형 교차로 방법이었다
근본적인 문제를 도입

1501
01:14:58,730 --> 01:15:02,810
당신 것입니다 소프트웨어에
특정 조건을 검출 할 필요가있다.

1502
01:15:02,810 --> 01:15:07,680
여기에 손에 그리고 이렇게 질문
이며, 잠재적으로 차를 어떻게하는지,

1503
01:15:07,680 --> 01:15:09,870
소프트웨어에서 구현
이 프로그래머에 의해,

1504
01:15:09,870 --> 01:15:11,850
그것은 실제로 테스트중인 것을 감지?

1505
01:15:11,850 --> 01:15:14,150
그래서, 매우 명확합니다
그들이 무엇을하고 있었

1506
01:15:14,150 --> 01:15:17,940
환경 위치에 있었다
프로그래머는 생각

1507
01:15:17,940 --> 01:15:20,460
차는되고 있었다
테스트, 그들은 어떻게 든 만들어

1508
01:15:20,460 --> 01:15:24,840
차를 덜 배출을 방출 적은
배출, 그래서 덜 유독 가스

1509
01:15:24,840 --> 01:15:25,470
등.

1510
01:15:25,470 --> 01:15:27,261
하지만 보통 때
도로에서 운전,

1511
01:15:27,261 --> 01:15:30,350
그냥 많이 방출하는 것
이 원하는대로 오염.

1512
01:15:30,350 --> 01:15:33,870
>> 그래서 우리는 방법을 쓸 수있는
이 알고리즘의 의사 코드?

1513
01:15:33,870 --> 01:15:37,820
우리는 어떻게 의사를 작성할 수
차에서 실행되는 소프트웨어?

1514
01:15:37,820 --> 01:15:43,390
나는 간단히 말해서, 그것은 종기, 의미
이런 일에 이르기까지.

1515
01:15:43,390 --> 01:15:48,000
테스트중인 경우, 적게 방출한다.

1516
01:15:48,000 --> 01:15:50,750
다른 더 방출한다.

1517
01:15:50,750 --> 01:15:52,630
하지만 조금의
너무 높은 수준, 오른쪽?

1518
01:15:52,630 --> 01:15:58,580
>> 의 어떤이에게로 다이빙을 해보자
테스트 수단 인의 추상화입니다.

1519
01:15:58,580 --> 01:16:06,340
즉, 당신은 아무것도 몰라 경우에도
질문의 자동차에 대한, 어떤 종류의

1520
01:16:06,340 --> 01:16:13,440
당신이 있는지 확인하기 위해 요청할 수 있습니다
당신이 차 있다면 당신은, 테스트중인거야?

1521
01:16:13,440 --> 01:16:19,638
어떤 특성이 될 수 있습니다
차량 테스트되는 경우 존재?

1522
01:16:19,638 --> 01:16:21,026
>> 청중 : 테스트 장비.

1523
01:16:21,026 --> 01:16:22,420
>> DAVID 마란 : 테스트 장비.

1524
01:16:22,420 --> 01:16:26,060
시험 장비의 경우 그래서
근처에 적은 다음 방출한다.

1525
01:16:26,060 --> 01:16:28,669
그래서 구현 상상할 수
카메라의 일종으로 그

1526
01:16:28,669 --> 01:16:29,960
또는 당신의 주위에 무슨 검출.

1527
01:16:29,960 --> 01:16:32,870
그리고 내가 그 제안하자
너무 복잡하게 느낀다

1528
01:16:32,870 --> 01:16:37,914
실제로 추가해야합니다
단지 그 목적을 위해 하드웨어.

1529
01:16:37,914 --> 01:16:44,830
>> 청중 : 당신은에있는 경우
공원은 후드가 열려, 경우.

1530
01:16:44,830 --> 01:16:47,320
>> DAVID 마란 : 공원에서 또는
후드 오픈, 그래서 그 좋은입니다.

1531
01:16:47,320 --> 01:16:47,420
>> 청중 : 그리고 차 실행합니다.

1532
01:16:47,420 --> 01:16:50,480
>> 데이비드 마란 : 그래서 그건 좀있어
더 concrete-- 및 자동차 실행합니다.

1533
01:16:50,480 --> 01:16:55,690
그래서 이것은의 연계 것
몇 가지 조건이됩니다.

1534
01:16:55,690 --> 01:16:59,227
차가 공원이며하더라도 그래서
이것은 매우 기계적인 일이지만

1535
01:16:59,227 --> 01:17:01,060
일반적으로, 나는 할 수
소프트웨어를 작성 상상,

1536
01:17:01,060 --> 01:17:03,476
특히 거기 때문에
종종이 가벼운 요즘,

1537
01:17:03,476 --> 01:17:07,400
내가있는이 상상할 수
쉬프터를 조회 할 수있는 소프트웨어

1538
01:17:07,400 --> 01:17:10,634
또는, 당신은 공원에서 무엇을하지 않습니다
드라이브에 당신은, 역에서 당신을 수 있습니다.

1539
01:17:10,634 --> 01:17:12,550
그리고 나는 다시 얻을 수 있습니다
그 예 중 하나의 답변

1540
01:17:12,550 --> 01:17:14,400
또는 질문의 그 종류에는.하지

1541
01:17:14,400 --> 01:17:17,630
>> 그래서 나는 또한 아마 대답 할 수
질문은 같은 후드 열려 있습니다.

1542
01:17:17,630 --> 01:17:21,860
아마, 센서의 일종있다
그 1 또는 0을 나에게 다시 제공하거나,

1543
01:17:21,860 --> 01:17:23,720
참 또는 거짓, 후드가 열려 있습니다.

1544
01:17:23,720 --> 01:17:28,180
그리고 자동차 운전, 나는 감지 할 수
어떻게 든 어떤 메커니즘을 통해?

1545
01:17:28,180 --> 01:17:30,430
마찬가지로, 차는 실행, I
이 켜져 있음을 감지 할 수있다,

1546
01:17:30,430 --> 01:17:32,127
어떻게 든 감지 할 수
차가 움직이는 것을?

1547
01:17:32,127 --> 01:17:32,881
>> 청중 : RPM을.

1548
01:17:32,881 --> 01:17:35,190
>> DAVID 마란 : 네, 그래서 거기에
항상 바늘이

1549
01:17:35,190 --> 01:17:38,034
당신에게 당 얼마나 많은 회전을 알려줍니다
분 바퀴 경험하고 있습니다.

1550
01:17:38,034 --> 01:17:39,200
그래서 나는 볼 수 있었다.

1551
01:17:39,200 --> 01:17:43,090
그리고는 아마 0이 아니라면
차량이 이동하는 것을 의미한다.

1552
01:17:43,090 --> 01:17:45,400
그러나 우리는을해야
이주의 작은,

1553
01:17:45,400 --> 01:17:49,780
이유는 - 이제이 항아리 간단하게
우리가 방금 말한 경우, 자동차를 실행하는 경우,

1554
01:17:49,780 --> 01:17:53,070
우리가 덜 방출하지 않으려는,
자동차가 실행중인 경우 우리가 원하는

1555
01:17:53,070 --> 01:17:54,310
그리고 시험되고있다.

1556
01:17:54,310 --> 01:17:56,320
>> 그래서 몇 가지 다른를가
재료 그 사람

1557
01:17:56,320 --> 01:18:00,550
소프트웨어가하고있는 가정 한
존재 실제 소스 코드 때문에,

1558
01:18:00,550 --> 01:18:05,130
당신은 단지 종류의에서 추론 할 수있다
에 관해서는 자동차의 실제 효과 무엇

1559
01:18:05,130 --> 01:18:08,280
아래에 갈 수 있습니다
소프트웨어의 후드.

1560
01:18:08,280 --> 01:18:17,090
그래서 자동차, 어쩌면 실행하는 경우
말하자면, 후륜은 움직이지 않고,

1561
01:18:17,090 --> 01:18:19,420
이 나타낼 수 있습니다
시험의 어떤 종류의?

1562
01:18:19,420 --> 01:18:22,830
여기에 무엇을 암시하고있다?

1563
01:18:22,830 --> 01:18:24,830
그래, 어쩌면, 그것은 하나에 있어요
그 롤러 것들,

1564
01:18:24,830 --> 01:18:28,340
여기서, 바퀴 등을 돌리고있다
앞 또는 뒤쪽에,

1565
01:18:28,340 --> 01:18:32,570
그것은 앞 바퀴의 여부에 따라 또는
차륜 후륜 구동하므로 절반

1566
01:18:32,570 --> 01:18:34,420
이동하지만
다른 두 사람은 아닌있는

1567
01:18:34,420 --> 01:18:36,320
현실 세계에서 이상한 상황이다.

1568
01:18:36,320 --> 01:18:38,110
당신이 운전하는 경우
도로, 그런 일이 안된다.

1569
01:18:38,110 --> 01:18:40,568
하지만 당신은 창고에 있다면
롤러 시스템의 일종에,

1570
01:18:40,568 --> 01:18:41,630
그것은 참으로 발생할 수 있습니다.

1571
01:18:41,630 --> 01:18:46,980
>> 나는, 여러분도 아마 제안 생각
자동차가 실행 스티어링 경우

1572
01:18:46,980 --> 01:18:51,300
것으로, 움직이지 휘일
너무 신호가 될 수 있습니다,

1573
01:18:51,300 --> 01:18:54,090
그 합리적인 때문에
도로에 직선 등을들 수있다.

1574
01:18:54,090 --> 01:18:57,960
하지만 그렇다하더라도, 인간은 아마
그것을 확실히 조금 또는 이동

1575
01:18:57,960 --> 01:18:59,100
몇 초 동안.

1576
01:18:59,100 --> 01:19:01,030
아니면 과정
분, 확률은 그렇지 않아 있습니다

1577
01:19:01,030 --> 01:19:03,510
에 집착 할 것
동일 위치.

1578
01:19:03,510 --> 01:19:05,440
>> 환언하면, 우리
빼기를 취할 수 있습니다,

1579
01:19:05,440 --> 01:19:08,200
당신이 테스트되고 있으며,
해당 기능을 무너 뜨리는

1580
01:19:08,200 --> 01:19:10,420
이러한 구성 요소 성분으로.

1581
01:19:10,420 --> 01:19:13,440
그리고 그것은 진정으로 무엇 폭스 바겐의의
엔지니어들은 어떻게 든했다.

1582
01:19:13,440 --> 01:19:17,070
그들은 의식적에 소프트웨어를 썼다
자동차가 테스트되는 경우 탐지,

1583
01:19:17,070 --> 01:19:20,440
따라서 이하, 다른 사람을 방출
일반적인 방법으로 방출한다.

1584
01:19:20,440 --> 01:19:22,690
>> 그리고 여기 문제도,
소프트웨어가 없다는 것이다

1585
01:19:22,690 --> 01:19:26,080
당신이 정말로하지 않는 한 볼 수있는 일
당신은 소위 소스 코드가 있습니다.

1586
01:19:26,080 --> 01:19:29,060
따라서 두 가지 유형이있다
code-- 적어도 두 가지 유형

1587
01:19:29,060 --> 01:19:30,130
세계의 코드.

1588
01:19:30,130 --> 01:19:33,150
뭔가라는 소스가있다
무엇을 달리하지 않습니다 코드,

1589
01:19:33,150 --> 01:19:37,240
우리는 소스 코드를 작성했습니다.

1590
01:19:37,240 --> 01:19:40,099
>> 이것은 소스 코드로 작성
의사라는 언어,

1591
01:19:40,099 --> 01:19:41,640
이는 영어처럼 뭔가입니다.

1592
01:19:41,640 --> 01:19:43,140
그것의 공식적인 정의는 없다.

1593
01:19:43,140 --> 01:19:46,770
그러나 C, 자바, C ++, 그
모든 공식 언어는 그,

1594
01:19:46,770 --> 01:19:50,610
당신이 그들에 쓸 때, 당신은 무엇을 가지고
소스 코드를 포함하는 텍스트 파일이다.

1595
01:19:50,610 --> 01:19:54,850
>> 그러나 또한 무언가가있다
세계 기계 코드를했다.

1596
01:19:54,850 --> 01:20:00,579
그리고 기계 코드, 불행하게도,
단지 0과 1입니다.

1597
01:20:00,579 --> 01:20:02,870
그래서 기계 코드는 무엇입니까
기계는 물론, 이해합니다.

1598
01:20:02,870 --> 01:20:04,470
소스 코드는 인간이 이해하는 것입니다.

1599
01:20:04,470 --> 01:20:08,390
>> 일반적으로, 그러나
항상 프로그램이있다

1600
01:20:08,390 --> 01:20:14,090
프로그래머가 사용하는 소스 소요
코드는 기계 코드로 변합니다.

1601
01:20:14,090 --> 01:20:17,400
그리고 그 프로그램입니다
일반적으로 컴파일러했다.

1602
01:20:17,400 --> 01:20:19,820
그래서 입력 소스 코드 인,
당신의 출력은 기계 코드

1603
01:20:19,820 --> 01:20:22,890
그리고 컴파일러의 조각
이 과정을 수행하는 소프트웨어입니다.

1604
01:20:22,890 --> 01:20:26,260
그래서이 사실을 잘 매핑
우리 입력 알고리즘 출력한다.

1605
01:20:26,260 --> 01:20:30,400
>> 그러나 이것은 매우 구체적인 화신
그 중,하는 그런 말을하는 것입니다,

1606
01:20:30,400 --> 01:20:34,200
당신은 폭스 바겐의 중 하나를 소유하는 경우에도
이 유죄 자동차,

1607
01:20:34,200 --> 01:20:38,390
당신이 단지를 열 수 있습니다처럼하지
후드 또는 사용 설명서를 열거 나 봐

1608
01:20:38,390 --> 01:20:42,690
소스 코드 때문에 때에는
그것은 당신의 진입로에 차를 도달

1609
01:20:42,690 --> 01:20:45,580
이미되었습니다
0과 1로 변환.

1610
01:20:45,580 --> 01:20:51,310
그리고 그것은 불가능, 매우 어렵지 않다
하지만 매우 어려운 것도 많이 이삭하기

1611
01:20:51,310 --> 01:20:53,710
그냥보고에서
0과 1을 기본.

1612
01:20:53,710 --> 01:20:57,150
그래서 당신이 경우, 궁극적으로 그것을 알아낼 수 있습니다
어떻게 기계를 이해 operates--

1613
01:20:57,150 --> 01:20:59,870
당신이 이해하는 경우 인텔은이 안에있다
인텔 아키텍처,

1614
01:20:59,870 --> 01:21:01,440
그러나 그것은 매우 시간 소모입니다.

1615
01:21:01,440 --> 01:21:05,010
그리고 심지어 거기, 당신은 수도
모든 것을 볼 수 없습니다

1616
01:21:05,010 --> 01:21:08,220
코드가 실제로 수행 할 수있다.

1617
01:21:08,220 --> 01:21:12,521
>> 이 또는 이것에 대해 질문
더 일반적으로 프로세스의 종류?

1618
01:21:12,521 --> 01:21:15,134

1619
01:21:15,134 --> 01:21:18,300
실제로, 우리는이 토론을 묶을 수있다
애플의 어제의 토론.

1620
01:21:18,300 --> 01:21:22,500
이 역시 이유 연방 수사 국 (FBI) 할 수있는 단지를
가서 용의자의 휴대 전화에서 볼

1621
01:21:22,500 --> 01:21:26,820
과를 들어, 코드의 라인을 찾아
예, 암호를 사용하는 것이

1622
01:21:26,820 --> 01:21:28,940
또는 80 밀리 초 지연을 가능하게한다.

1623
01:21:28,940 --> 01:21:31,630
시간에 의해 그것의 때문에
동료의 아이폰에,

1624
01:21:31,630 --> 01:21:34,975
이미되었습니다
0과 1로 변환된다.

1625
01:21:34,975 --> 01:21:38,015

1626
01:21:38,015 --> 01:21:40,820
>> 음, 여기를 일시 중지 할 수 있도록 우리의
전산 사고 봐.

1627
01:21:40,820 --> 01:21:42,320
왜 우리는 15 분 휴식을 취할하지 않습니다.

1628
01:21:42,320 --> 01:21:44,130
우리가 돌​​아올 때, 우리는거야
프로그램을 살펴

1629
01:21:44,130 --> 01:21:46,550
자체의 일부를 맵핑하기 시작할
이러한 높은 수준의 개념

1630
01:21:46,550 --> 01:21:49,780
실제에, 장난 경우,
프로그래밍 언어.

1631
01:21:49,780 --> 01:21:51,089

