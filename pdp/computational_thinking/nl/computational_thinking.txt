DAVID MALAN: Welkom terug, iedereen. Dus gisteren, zult u zich herinneren dat richtten we ons op deze onderwerpen hier. Dus moesten we vier overkoepelende topics-- privacy, veiligheid, en de samenleving; internettechnologieën; cloud computing; en uiteindelijk, web development. Heeft iemand de bandbreedte of de tijd om een ​​beetje John kijken Oliver gisteravond? Het is eigenlijk vrij amusant, zo niet een beetje beangstigend. Heeft u vragen over om het even wat wij deden gisteren? Elke verduidelijkingen? Heeft u vragen die u wilt maken zeker dat we ingaan op vandaag de dag in een of andere vorm? Dus schone lei. 

Dus wat er op de agenda voor vandaag? Dus ik dacht dat we vandaag beginnen met een blik op wat er in het algemeen bekend als computationele thinking-- bij het risico van een te simpel, denken zoals een computer, misschien denken als een ingenieur, en proberen te beginnen het organiseren van uw gedachten of om u een beter gevoel van geven wat er bij eigenlijk commandant een computer om iets te doen bij wijze van programmeren. En we houden het bij een vrij hoog niveau, vrij veel Engels, maar probeer het gebruik van bekende voorbeelden te formaliseren hoe je zou gaan over het oplossen van problemen. 

En we zullen sommige CS opnieuw onderwerpen, zoals abstractie, die een paar kwam keren gisteren, algoritmes, en dan representatie. En dat is waar we zullen beginnen vandaag in slechts een moment. Dan zullen we een kijkje nemen op de programmering te nemen. We nemen een kijkje bij enkele nemen fundamentele constructen waarmee je misschien vertrouwd en zou zelfs kunnen vinden heel intuïtief. 

We zullen kijken, in feite, bij een steekproef programmering omgeving die is zeer toegankelijk, erg speels, en inderdaad gericht voor kinderen van 12 jaar en ouder. We zullen een paar minuten door te brengen en neem dan de dingen op een lager niveau en eigenlijk praten over een aantal van de algoritmes en datastructuren, zo te zeggen, dat programmeurs gebruiken meestal problemen veel oplossen efficiënter dan je misschien in staat zijn om helemaal te doen zonder hen. Dan na de lunch, zullen we een kijkje nemen op technologie stacks, dat is gewoon een mooie manier om te zeggen collecties van technologieën dat je zou kunnen gebruiken om het oplossen van een probleem. En we praten over het alfabet soep van de talen die er bestaan ​​today-- Java en Python en C ++ en PHP en Ruby en allerlei andere dingen. 

We nemen een kijkje te nemen in het kort op design patterns. Programmeurs, na verloop van tijd, hebben aangenomen methodologieën die de neiging hebben om hen te helpen problemen gemakkelijker. Als je begint om jezelf te zien schrijven het zelfde soort code opnieuw en opnieuw, mensen formaliseren die herhalingen en namen toeschrijven aan hen en vervolgens te gebruiken en bevorderen ze uiteindelijk. En we zullen een beetje praten over mobiele strategieën, als wat betekent het om werkelijk maken van een mobiele app of een mobiele website. Doe je het voor Android? Doe je het voor iOS? Doe je het voor deze beide? En wat zijn de trade-offs? En dan tot slot, zullen we nemen Kijk web programmeren, die is een verzamelnaam echt beschrijven elk moment je schrijft software die bedoeld om te draaien op het web, zowel op telefoons of desktops of laptops. We nemen een korte blik op te nemen databases en het ontwerp daarin, alleen al omdat vrijwel elk interessante web-based applicatie deze dagen heeft een soort van database. Anders, het zou gewoon statische content zijn. En een database kunt u bellen veranderingen in de tijd, of jezelf of van gebruikers. En we zullen nadenken over hoe je zou gaan over het ontwerpen die database en de aard van de jargon dat zou kunnen komen in een ingenieur bespreking op een wit bord wanneer de daadwerkelijke uitvoering een app voor de eerste keer. 

We zullen kort spreken over API's, nuttige diensten die u kunt gebruiken op te staan schouders van anderen, of bedrijven of individuen, en het oplossen van uw eigen problemen sneller. En dan zullen we misschien ploeteren een beetje met JavaScript, een programmeertaal die wordt gebruikt zowel in browsers deze dagen, maar ook in servers. En misschien zullen we opnieuw, de tijd het toelaat, een aantal van de hands-on web stuff we gisteren en de twee te integreren samen voordat we verdagen. 

Dus met dat-- wat ahead-- is er iets ontbreekt dat u wil ervoor zorgen dat we voegen en tik op op een bepaald punt. Als het veren voor de geest, breng het duurde niet lang. Maar waarom doen we niet beginnen met een kijk naar computationele denken. 

En laat me voorstellen dat computationele denken is, nogmaals, soort van het hoge niveau beschrijving van wat een computer wetenschapper zou kunnen doen. En inderdaad, laten we beginnen drie ingrediënten misschien gaan in computationele denken. Dit is slechts een manier om te beschrijven. We zouden zeker definiëren dit in een aantal manieren. 

Maar laat me voor te stellen, omwille vandaag dat de problemen in de wereld, alle problemen in de wereld, toen benaderd door een computer wetenschapper kon worden beschouwd als wat wij zullen oproepingangen, die nodig hebt om te eten krijgen in wat we zullen noemen algoritmen, die vervolgens verkregen uitgangen. Met andere woorden, het gehele wereld van probleemoplossende I vordering kan worden gedestilleerd tot Deze drie ingrediënten. Dus wat bedoel ik met ingangen? Ingangen is precies wat je bent overhandigd om op te lossen. 

Bijvoorbeeld, hier is een oude school probleem. Als ik een telefoonboek hier en Ik wil iets er naar kijken, dit is mijn inbreng. Ik heb 1000 of zo pagina's in een telefoonboek. Dit is de input voor mijn probleem. En ik wil om iets te vinden zoals Mike Smith, dus een vriend waarvan de naam en het nummer is hopelijk in dit adresboek. 

Dit is voor de tijd van cel telefoons, dus ik kan niet gewoon zoeken naar het. Dus ik heb het oude te doen school en eigenlijk zoeken deze ingangen voor enige antwoord. En dat antwoord is gewoon de uitgang te noemen. Dus de ingang is het telefoonboek. Het algoritme is wat set van stappen die ik gebruiken om Mike Smith te vinden. En de output is, hopelijk, Mike Smith telefoonnummer. En dit dan gewoon zou zijn representatief voor de meeste enig probleem om met je handen ingangen en willen uitgangen te produceren. 

Dus voordat we kijken naar het proces waarmee kunnen we dat probleem op te lossen, het vinden van Mike Smith en zoiets, laten we eens kijken naar de eerste en de de last-- in- en uitgangen. Fysiek natuurlijk de input here is een hele hoop papier aan elkaar gelijmd in de vorm van een telefoonboek. Maar computers, van laptops course-- en desktops en zelfs telefoons deze dagen-- dat zijn elektronische apparaten. 

En aan het eind van de dag, wat de enige ingevoerd in een computer? Nou, het is iets als Dit netsnoer hier. Ik steek de stekker in het stopcontact, en Ik krijg een stroom van elektronen, die me in staat stelt om de machine uit te voeren. Of misschien die elektronen door middel van mijn batterij. Maar aan het eind van de dag, dat het enige wat in te gaan op mijn laptop. En zo interessant spul is uiteindelijk coming out, of via de printer of het scherm of audially of dergelijke. 

Dus als alles wat we hebben als onze fundamentele ingevoerd in een computer is elektriciteit, dus gewoon elektronen gaan in en of uit en dus hoe kunnen we gebruik maken van die ingang om daadwerkelijk informatie te vertegenwoordigen? Met andere woorden, hoe krijgen we van een eenvoudige elektrische stroom gemaakt voor daadwerkelijke cijfers of letters feitelijke of daadwerkelijke beelden op het scherm of feitelijke films of e-mails of een aantal van deze hoger niveau concepten, als je wil, dat op het Uiteindelijk ergens moeten worden in deze elektronisch mechanisch apparaat met alleen de eenvoudige ingredients-- elektronen die in en uit? 

Dus het lijkt erop dat, in de eenvoudigste vorm, de enige soort van toestanden Ik heb in mijn wereld, dus voorwaarden speak-- in mijn wereld-- is ofwel Ik heb elektronen stromen, elektriciteit vloeiend, of doe ik niet-- zo aan, uit. En laten we formaliseren aan en uit, als een computer wetenschapper zou kunnen, met slechts 1 en 0. Laten we gewoon te beschrijven wat willekeurige maar consistent aantal aan. 1 betekent op, 0 betekent uitgeschakeld. Of is dit misschien ook dit als true middelen aan en waar betekent. Je zou ook zwarte doen en wit of rood en blauw. Je hoeft alleen maar twee omschrijvingen. En een computer wetenschappers zou over het algemeen gewoon gebruik maken van 0 en 1. 

Dus als dat het geval is, mijn enige alfabet is bestaande uit 0 en 1 is, hoe zou ik misschien naar het nummer toe, ook 2 in een computer, laat staan ​​het nummer 3 of een letter van het alfabet of een beeld of een film? Hoe kunnen we een soort van bootstrappen onszelf van dit basisbeginsel van 0 en 1 en daadwerkelijk iets interessanter te vertegenwoordigen? 

Nou, laten we deze vraag in de wacht voor slechts een moment en overwegen iets hopelijk bekend, zelfs als je niet echt over nagedacht Het in detail voor 10, 20, 30, 40, 50 meer jaren. Dit is wat? Hoe zou je dat uit? Niet een strikvraag. Een aantal, maar wat is het? 1, 2, 3 of 123. En ik vond hoe je zei dat 1, 2, 3, want dat is een manier van kijken naar het. 1, 2, 3, is het een sequentie drie symbolen. Het is foto's die we nu hebben woorden voor. En als je een soort van lees ze allemaal samen een typisch menselijke in Engels zou zeggen 123. En dat is een soort van een hoger niveau concept, voelt als een redelijk groot aantal. 

Maar hoe we daar? Nou, het is misschien een tijdje geleden zijn je hebt nagedacht over het op deze manier, maar terug in mijn dag, ik soort van deze geleerde zoals kolom 1 van de 10's kolom en kolom 100 is. Dus als Lakisa zegt, is het 1, 2, 3, maar het is ook 123. Maar hoe komen we uit de eerste aan de laatste? 

Nou, je zou meestal doen in kolom van de 100's, ik heb een 1. Dus dat is hetzelfde als zeggen 100 keer 1. En dan in kolom 10's, ik heb 2. Dus dat is hetzelfde als zeggen 10 keer 2. In kolom 1's, ik heb 3. Dus dat is hetzelfde als zeggen dat 1 keer 3. 

En als ik deze dingen toe te voegen bijelkaar natuurlijk is 100 plus de 10 plus 3. En oh, dat is waarom ik dit te krijgen hoger niveau begrip 123. Het is gewoon elementaire wiskunde, waarbij deze symbolen gewichten aan hen, als je zal, placeholder of kolom waarden. En zodra ik vermenigvuldig alles out, krijg ik dit nummer. 

Hoeveel van jullie weten hoe om te spreken binary-- 0 en 1's-- als een computer? OK, perfect, niemand, of niemand van jullie denken dat je doet. Maar ik zou u aanspraak eigenlijk weten dit al. We moeten gewoon een soort van tweak onze mentale model een beetje. Maar de werkwijze is precies hetzelfde. 

Laat me deze daar te verlaten en in plaats daarvan trekken deze enkele seconden ingedrukt. In de wereld van computers, we hebben alleen 0 en 1's. En zo het ding dat is gaat veranderen is wat? Nou, in mijn menselijke wereld, de decimale stelsel, december betekenis 10, Ik heb hoeveel cijfers tot mijn beschikking? 10, toch? 0 tot 9 natuurlijk. 

En dat is waarom we hebben de 10's plaats en de 100's plaats. Waar dat vandaan? Nou, dit is 10 tot de macht van 0. Dit is 10 tot de macht 1, 10 de macht van 2, enzovoort. Je houdt gewoon je columns vermenigvuldigen met 10, te beginnen met slechts 1 in de meest rechtse hier. 

Dus in de wereld computers, als je alleen hebben binary-- bi betekenis 2-- of 0's en 1's, we hebben net echt nodig om te veranderen de basis van die wiskunde. Dus met andere woorden, nu gaan we gewoon hebben de kolom 1 en the-- Waar is deze going-- kolom 2's, kolom 4 is, en misschien daarbuiten. Waarom is dat? Nou, dit is 2 van de 0-de macht. Dit is de 2 1. Dit is 2 de 2, enzovoort. 

Dus terwijl hier, we hebben 1, 10's, 100's, 1000's, 10.000's, 100.000, op 1 miljoenen, enzovoort, even Wij hebben 1, 2, 4, 8, 16, 32, 64. Je blijft gewoon te vermenigvuldigen met 2, plaats houden van vermenigvuldigen met 10. Dus nu, als het doel op hand te vertegenwoordigen getallen met alleen 0 en 1 is, laten we eens kijken hoe we er zijn. 

Dit is natuurlijk het patroon 0 0 0, maar welk nummer conceptueel doet het voor? Nou, 4 keer 0 plus 2 tijden 0 plus 1 tijden 0, laten we samen toe te voegen die. 4 tijden 0 is, natuurlijk, 0, plus 2 tijden 0 is, natuurlijk, plus 1 0 0 tijden is natuurlijk, 0. Dus ach, dit is de aantal wij mensen kennen als 0. 

Welnu, laten we heel snel snel vooruit. Als ik in plaats daarvan geen deel uitmaken van 0 0 0, maar laten we doen 1 0 1, dat zou kunnen zijn hoe Lakisa, eerder, zou gewoon uitspreken 1 0 1. Maar nu, hoe kunnen we het aan de hogere niveau het aantal wij mensen zouden weten? Dus wat is dit nummer? Het is 5, het nummer dat we kennen als 5. 

Nou ja, waarom is dat? Nou ja, kunnen we echt soort doorheen lopen methodisch 4 maal 1, 2 tijden 0, 1 keer 1. Voeg deze samen, zodat dit is 4 plus 0 plus 1. En dat is inderdaad 5. Dus het is een beetje vervelend nu doet het rekenkundig opnieuw en opnieuw. Maar de werkwijze is precies hetzelfde. 

Het enige dat heeft veranderd in onze wereld is dat onze kolommen 1, 2, 4, 8, 16, enzovoorts, in plaats van 1, 10, 100, 1000. En dat is alleen maar omdat ons alfabet heeft gekrompen van 0 tot 9 tot slechts 0-1. 

Dus als een kleine quiz hier, hoe zou u het nummer 7 in binaire vertegenwoordigen? 0? Nou, 0, je bedoelt 0 0 0? Zeg het nog eens, Karina. Perfect. Waarom is dat? Het is effectief 4 plus 2 plus 1. Geweldig. 

Hoe kunnen we vertegenwoordigen een beetje another-- hoe zit het nummer 2? Close, maar naar achteren. Dus wat is dit? Is 4 plus 1, dus dat is 5 weer. 

Dus what's-- Het spijt me, Karina? 0 1 0. 0 1 0 2 zou, omdat weer, zelfs als het soort van niet springen op je af, gewoon doen de wiskunde. 4 tijden 0, 0, 2 maal 1 is 2, 1 tijden 0 0 is. Dit is dus het getal bekend als 2. 

Hoe zit het met nummer 8? Hm? Goed. Dus we soort van een andere placeholder nodig. We moeten 1 0 0 0. En dat is waar van onze soort old school decimale stelsel. Hoe beoordeelt u het nummer 1000 te vertegenwoordigen? 

Nou, je lijkt te zijn soort in een moeilijke positie, als je vraagt ​​te vertegenwoordigen het nummer 1000, want zelfs als je jezelf als 9 van deze, 9 van deze, 0 daarvan, dat is het grootste aantal u hebt, heb je niet helemaal tot 1.000. Dus als je 1000, je hoeft alleen maar een ander positie, zodat u kunt doen 1 0 0 0, ergo het nummer 1000. 

Dus nu, laten we de kaart van dit soort conceptuele discussie terug naar hardware, waarbij opnieuw de input was gewoon deze kleine voedingskabel, elektriciteit die in en buiten stroomt. En zo daarvoor worden toegewezen vanaf hier om daar, nou, wat hebben we echt nodig? Nou ja, kunt u denken aan het zijn binnenkant van een computer, een hele hoop van gloeilampen, als je wil. Ze zijn echt transistors genoemd. En transistors zijn slechts schakelaars dat kan zowel in of uit. Zo kunt u denken aan een transistor dat er op is waardoor elektriciteit te stromen en een transistor die af als het stoppen elektriciteit uit stromend. En in plaats van te nemen over de verlichting hier, waarom heb ik dat niet doen dit soort van de nieuwe school stijl. Dus dit is misschien een 1, een zaklamp wezen op, nauwelijks dat wel. En dit zou kunnen zijn een 0, en nu is het af. 

Dus het gebruik van dit fysieke apparaat, I kunnen vertegenwoordigen nu het binaire systeem. Ik moet gewoon twee staten. Het maakt niet uit wat kleur het is of wat het is. Het enige dat telt is dat ik de ene staat op en een andere staat uit. Dus met behulp van mijn telefoon hier, hoe kan ik vertegenwoordigen de nummer wij kennen als 0? Of equivalent gezet, wat nummer moet ik die nu? 0, omdat het apparaat is uitgeschakeld. 

En als ik dit doe? En nu, hoe kan ik vertegenwoordigen de nummer 2? Kan ik lenen uw telefoon hier, zoals wij deden gisteren? Dus laten we eens kijken, dus als ik wil vertegenwoordigen de nummer 2, is dit de nummer 2? Nee. Welk nummer ben ik per ongeluk vertegenwoordigen hier? Dit is eigenlijk het nummer 3. 

Ja, welke wil ik uit te schakelen? De zwarte telefoon of-- goed, als they're-- zwarte telefoon of de witte telefoon? De witte telefoon. Dus als ik dit uitschakelen en we lijn het omhoog hier, we hebben een 1 in de 2 de plaats en een 0 in de 1's place. En dus ik ben nu dat het nummer 2. En, Natuurlijk zou het getal 3, want nu beide lichten zijn ingeschakeld. 

En ik zal hier stoppen, maar het spreekt vanzelf als ik wil de vertegenwoordigen 4 of 8 of hoger, Ik ga meer telefoons nodig hebben. Maar dat is alles wat er gaande is. Dus als je ooit gehoord dat binnenkant van een-- bedanken je-- computer is miljoenen transistors, dat is gewoon miljoenen piepkleine schakelaars. En ze zijn niet licht bollen die aan en uit te schakelen, maar ze ofwel laten elektriciteit om ergens te vloeien of te stoppen. En dus er is uw twee states-- aan of uit, in of uit. 

Dus zouden we nu lijken dit vermogen hebben dit concept verklaart dat we willen graag in de werkelijke hardware. Maar alles wat we nu hebben is het vermogen om nummers lijkt te vertegenwoordigen. Dus hoe kunnen we gaan over het vertegenwoordigen letters van het alfabet, waarbij voelt als de volgende soort functie die u zou willen toevoegen aan een moderne computer als je eenmaal hebt nummers? 

En inderdaad, als je erover nadenkt Het historisch gezien computers waren echt ingevoerd om te dienen als numeriek rekenmachines. Maar natuurlijk, deze dagen, ze doen nog veel meer. Zelfs als ze opstarten, u zie doorgaans één of meer woorden. Dus hoe kan je vertegenwoordigen woorden, als alles wat je hebt is, nogmaals, elektriciteit aan het einde van de dag of equivalent 0 en 1's? 

Ja. Ja, ik bedoel, we soort deden dit gisteren in een bepaalde vorm, waarbij op een gegeven moment, Ik denk dat ik willekeurig zei dat, als we willen het te vertegenwoordigen letter A, konden we gewoon bellen dat een 1. Het was in de context van cryptografie, waar we hadden alleen een soort van code, een soort mapping. 

Dus misschien A zal worden voorgesteld als een 1, en B wordt weergegeven als 2, en Z zal worden vertegenwoordigd als 26 bijvoorbeeld. En dan is het enige nadeel is dat als ik ben ga brieven coderen in mijn e-mail of in mijn sms-berichten als getallen, u allen in te stemmen met het gebruik van dezelfde set van conventies. En inderdaad, de wereld heeft precies dat gedaan. 

Er is een systeem ter wereld genaamd ASCII, American Standard Code for Information Interchange, dat is gewoon een beslissing enkele jaren geleden dat de mens gemaakt dat besloten dat A gaat evenaren, niet 1, 2, en 26, en dus het is een forth-- weinig different-- maar 65, 66, 67. En ik trek een diagram in slechts een moment. Maar het is willekeurig. Maar het maakt niet uit dat het arbitrair. De wereld moet gewoon consistent zijn. 

Nu, meer recentelijk, er is iets liefhebber genaamd Unicode, want soort in de wereld gerealiseerde, na het uitvinden van computers, dat er meer dan goed 256 symbolen in de wereld opdat wij zouden willen vertegenwoordigen, vooral als je te introduceren Aziatische talen en andere symbolieken dat er meer expressiviteit dan je nodig hebt past in de eerste versie van Deze code, die ASCII werd genoemd. Dus Unicode maakt eigenlijk u meer 0 en 2 te gebruiken. In het bijzonder, houdt u het horen van de woord bytes in de samenleving en zelfs alleen maar gisteren. En een byte is wat ook alweer? 

Wat is een byte? Het is slechts 8 bits. Dus wat betekent dat eigenlijk? Nou, dat betekent, eerder, toen we waren het over binaire en ik was met behulp van willekeurig drie bits toen we waren praten over binary-- de 1 plaats, de 2 de plaats, en de 4's plek-- goed, een byte betekent gewoon dat je praat niet in eenheden van drie, maar vier, vijf, zes, zeven acht, die geeft ons 8 plaats, 16's, 32's, 64's en 128's. 

Met andere woorden, wat is niet alles die nuttig zijn een maateenheid, want het is net als een klein stukje informatie, aan of uit. Dus een paar jaar geleden, de wereld net besloten het iets gemakkelijker te praten termen van bytes, acht dingen tegelijk. En dus zo werd geboren het begrip byte. En dus hebben we acht bits hier. 

En het blijkt ook, voor soortgelijke Daarom besloten de wereld jaren geleden dat een ASCII brief vertegenwoordigen, je gaat om eenheden van 8 bits. Dus zelfs als je dat niet doet nodig dat veel, je bent altijd gaat om 8 bits te gebruiken om vertegenwoordigen een letter van het alfabet. En dat is handig, want dan kun je een bericht ontvangt dat een 0 0 0 1 1 heeft 1 1 0 gevolgd door nog 1 1 1 0 1 0 0 1, dus als u ontvangt 16 bits, de wereld kan gewoon aangenomen dat de eerste 8 zijn één letter en de tweede 8 zijn een andere letter. 

Maakt niet uit hoeveel het er zijn. Het doet gewoon dat we zijn allemaal consequent als we de interpretatie van deze bits. En dit was gewoon willekeurig. Dat betekent iets, maar ik deed het niet echt na te denken over wat het betekent. 

Dus het is een klein leugentje om bestwil. Oorspronkelijk ASCII feitelijk gebruikt 7 bits. De achtste bit genaamd extended ASCII. Maar het punt is uiteindelijk hetzelfde. De wereld in het algemeen gestandaardiseerd op 8 bits. 

Dus dit lijkt een beetje te zijn beperken, omdat ik alleen maar kan kapitaal vertegenwoordigen A, hoofdletter B door middel van kapitaal Z. Maar inderdaad niet, als ik ga to-- er is een heleboel van de middelen online, bijvoorbeeld, asciitable.com deze gaat een beetje te zijn overweldigend op het eerste. Maar ik zal erop wijzen wat is hier belangrijk. 

Dit toevallig be-- en ik zal walk-- laten we eens kijken, als ik hier te gaan. Hier is, in de decimale kolom, het nummer 65. En over de brief rechterkolom karakter, Chr, is de letter A. En je kunt negeren, voor nu, alles in het midden. Dit is hexadecimaal, octale en een HTML-code. Om deze site is gewoon proberen te gooien een heleboel informatie op je af in een keer. Maar alles wat we zorg over is de decimale kolom en de kolom karakter. 

Dus deze logica, wat het getal dat de wereld besloten is een kleine a? Ja, 97. En net te verwarren potentieel licht, welk nummer heeft de wereld besloten zou de nummer 1 te vertegenwoordigen? Juist, omdat we-- 49, het lijkt Hier, in de linkerbenedenhoek. 

Nu, wat moet ik daarmee? Dus het blijkt dat in computersystemen, er over het algemeen een fundamenteel verschil tussen een nummer en een karakter. Een getal is het ding dat we geleerd opgroeien als we waren super jong in de lagere school. Het is dingen die je rekenen met. Maar een teken is gewoon een vorm, een glyph, om zo te zeggen, op het scherm. 

Nu, mensen we een soort van zien iets dat lijkt op dit. En wij zeggen: oh, dat is de nummer 2. Maar nee, dat is gewoon een symbool dat eruit ziet als wat we kennen als de nummer 2. En dus is er dit fundamenteel onderscheid tussen de werkelijke cijfers en letters. Dit is een getal. Maar over het algemeen, in de context van een computer, Als u in plaats daarvan zien zoiets als dit quoted-- en je hoeft niet altijd moet het zien geciteerd, maar omwille van discussion-- indien zie je aanhalingstekens rond het nummer, dit is nu een personage. Dus dit nummer 2 onderaan de kap binnenkant van een computer worden weergegeven met een patroon bits dat het aantal vertegenwoordigen 50 volgens de grafiek online. 

Indien echter een computer alleen ziet dit, deze worden vertegenwoordigd met patroon van bit 0 0 0 0 0 0 1 0. Overwegende dat dit karakter zou eigenlijk as-- en nu worden vertegenwoordigd, Ik kreeg een beetje harder-- dus dit denken karakter vertegenwoordigd zouden zijn met 0 0 1-- wat moet ik hier? 0 0 1 1 0 0 1 0. Hoe heb ik dit doen? Nou, dit is het nummer 50, als je vermenigvuldig het met behulp van deze kolommen, Dit is het nummer 2, enzovoort dat is waarom er deze tweedeling. 

En dit is slechts een teaser nu features die bestaan ​​in programmeertalen dat we ingaan op kort later vandaag. In programmeertalen, u hebben over het algemeen, maar niet altijd, beter noemen verschillende soorten data. Met andere woorden, een programmer-- wanneer hij schrijft, een programmeur krijgt om te bepalen hoe formaat zijn of haar gegevens. U kunt gegevens op te slaan als kale cijfers, zoals het aantal 2. Of je kunt ze opslaan als strings, of tekenreeksen dat je over het algemeen zou uitdrukken citaten in de programmeertaal. 

Je kunt dingen called-- Ik zal te eenvoudig en noemen ze reële numbers-- zodat getallen die zijn niet integers als de nummer 2, maar de aantallen willen 4.56. Zo kan ook reële getallen hebben cijfers achter de komma, dus dat is een andere fundamentele brok gegevens in een computer. En dan kun je zelfs andere soorten data nog steeds. Dus dat is slechts een teaser echt van de eenvoudigste van ontwerpbeslissingen dat een programmeur zou maken onder de motorkap. 

Dus gewoon nog vragen? Dus laten we proberen te maken dit een beetje meer reëel. Deze hardware is niet zo veel meer in gebruik. Maar bijna iedereen in deze kamer waarschijnlijk opgegroeid met en gebruikt nog steeds harde schijven in zekere zin. 

Hoewel de meeste onze laptops niet meer hebben apparaten die werken als dit, in plaats laptops vandaag de dag over het algemeen hebben solid state drives zonder bewegende delen. En die meestal duurder zijn, helaas, maar een beetje sneller en een-- goed, vaak een stuk sneller, dat is een van de redenen. En ook niet genereren veel warmte. Het kan kleiner zijn, dus het is over het algemeen een netto positief. 

Maar dit laat ons toe om een ​​kaart beetje meer concreet wat we hebben het hier over de 0 en 1 het niveau nu een fysiek apparaat. Het is één ding voor mij om te praten ongeveer 0 en 1 in termen van mijn telefoon of abstract in termen schakelaars zijn in en uit. Maar hoe zit het met harde schijven? In uw laptop, als je een oudere één, of in uw desktop computer, of in ieder geval in servers vandaag de dag, waar je harde schijven die hebben een terabyte aan ruimte, 4 terabyte aan ruimte, goed wat betekent dat? 

Een harde schijf met 1 terabyte aan ruimte middelen er is 1 triljoen bytes binnenkant van een of andere manier, of equivalent 8000000000000 bits in. 1 terabyte zou zijn 8 terabits of 1 triljoen bits, die betekent dat als u een harde drive, heb je een of andere manier of andere van een biljoen 0's 1 en de binnenkant ervan. En als we gewoon een kijkje nemen op een willekeurige foto van een harde schijf vertegenwoordiger, dit is wat een harde schijf kan meestal uitzien binnen. 

Ook zij is een soort een oude grammofoon speler maar meestal met meerdere records binnen, dus naar speak-- meerdere schotels, zoals ze heten, metaal cirkelvormige schijven, en dan een beetje leeskop, net als een oude platenspeler. En dat leeskop heen en heen en een of andere manier leest de bits. En wat er op deze schotels, zelfs hoewel wij mensen ze niet kunnen zien, hetzij in werkelijkheid of in dit beeld, er piepkleine magnetische deeltjes. En zelfs als je hebt lang vergeten hoe elektriciteit werkt, een magnetisch deeltje dat is over het algemeen in rekening gebracht heeft een noordelijke uiteinde en een zuid end-- dus noorden en het zuiden. En dus is de wereld enkel besloot enige tijd geleden dat indien een magnetisch protocol hoofdzaak is uitgelijnd als deze, noord-zuid, laten we noemen dat een 1. Als het in plaats zuid-noord, laten we noemen dat een 0. En dus als je op de beschikking over een biljoen piepkleine magnetische particles-- en hopelijk, de hardware vindingrijkheid in Om rond te draaien die zoals je ziet fit-- als je wilt vertegenwoordigen een hele hoop van 0's, je hoeft alleen maar 8 magnetische deeltjes Alle uitgelijnd als deze. En als je wilt vertegenwoordigen acht 1's, je gewoon moet 8 magnetische deeltjes uitgelijnd rug aan rug aan rug als dit. 

Wat bedoel ik door de magnetische deeltjes? Eerlijk gezegd, al die jaren later, de wat nog komt naar mijn mening is deze man, als je opgegroeid met dit ding. Dit is een voor little-- die unfamiliar-- een weinig kindertijd speelgoed dat Dit heeft haarloze man hier dat heeft al deze piepkleine zwarte magnetische deeltjes die daarbij horen. En met behulp van dat rode stok, dat is gewoon een magneet, je kunt een soort van hem een ​​snor of wenkbrauwen of haar of om het even wat op hem. Dus in feite, als we zoomen in, bijvoorbeeld, deze is het soort spel dat je kan spelen met Wooly Willy. 

En dit is alleen te zeggen dat deze veel grotere magnetische deeltjes dan zijn eigenlijk op een harde schijf, en veel minder magnetische deeltjes. Maar laten we eigenlijk zien dan kun je het hebben kleine magnetische deeltjes in een harde schijf, hoe kun je eigenlijk die te gebruiken om gegevens te vertegenwoordigen. 

[VIDEO AFSPELEN] 

-De Harde schijf is waar uw PC winkels het grootste deel van haar vaste data. Daarvoor gegevens reist van RAM samen met software signalen die het vertellen harde schijf hoe die gegevens op te slaan. De harde schijf circuits vertalen die signalen in spanningsschommelingen. Deze, op hun beurt, de controle van de harde schijf bewegende parts-- enkele van de weinige bewegende onderdelen links in de moderne computer. 

Enkele signalen bestuurt een motor, die draait met metaal beklede schotels. Uw gegevens is eigenlijk die zijn opgeslagen op deze schotels. Andere signalen bewegen de lees / schrijfkoppen om te lezen of gegevens op de platters te schrijven. Deze machine is zo nauwkeurig dat een menselijke haar kon niet eens passeren tussen de koppen en spinnen platters. Toch, het allemaal werkt op geweldige snelheden. [END AFSPELEN] En je kunt zien op de tail einde van de video, er over het algemeen meerdere platters. En zodat leeskop is niet alleen het lezen van de top. Het is net zoiets als drie of vier of meer leeskoppen die bewegen als deze, lezen van gegevens tegelijkertijd. 

Dus er is een heleboel complexiteit en de aard van de timing dat is betrokken bij een harde schijf. En het ding draait echt darn snel, dus er is veel complexiteit. Maar laten we in een beetje dieper te zoomen en zien waar zijn deze magnetische deeltjes en hoe we krijgen naar hen. 

[VIDEO AFSPELEN] 

-Laat blik bij wat we net zag in slow motion. Wanneer een korte puls van elektriciteit wordt naar de lees / schrijfkop, Het draait op een kleine elektromagnetische een fractie van een seconde. De magneet zorgt voor een veld, welke veranderingen de polariteit van een klein, klein gedeelte van de metaaldeeltjes die jas oppervlak elke schotel's. Een patroon reeks van deze minuscule opgeladen gebieden op de schijf een enkele bit van gegevens in de binair getal dat wordt gebruikt door computers. 

Nu, als de stroom stuurde een weg door de lees / schrijfkop, het gebied is gepolariseerd in een richting. Als de stroom wordt verzonden de tegengestelde richting, de polarisatie omgekeerd. Hoe krijg je de gegevens van de harde schijf? Gewoon het proces omkeren. Het is dus de deeltjes op de disk dat de huidige te krijgen in de lees / schrijfkop beweegt. Samen miljoenen deze gemagnetiseerde segmenten, en je hebt een bestand gekregen. 

Nu kan de stukken van een bestand verspreid over platters van een schijf, net zoiets als de puinhoop papieren op uw bureau. Dus een speciale extra bestand houdt spoor van waar alles is. Heb je niet wensen u had zoiets? 

[END AFSPELEN] 

Dus wordt gezinspeeld op daar, misschien, is dat onderwerp van gisteren van verwijdering. Als u verwijdert een file, gisteren zeiden we dat een computer eigenlijk doet wat, als je iets te slepen naar de prullenbak of afvalbak? Hij vergeet het gewoon. Maar de 0 en 1 is, de magnetische deeltjes die er uitzien als rood en blauw hier dingen, of mijn arm hier, zijn er nog steeds op de harde schijf. 

En dus bestaat er software-- Norton Utilities en Yesteryear en andere meer moderne software-- die net zal een hele harde schijf scannen op zoek naar al die 0 en 1 is, omdat het blijkt dat de meeste file formats-- Word-documenten, Excel-bestanden, afbeeldingen, video files-- allemaal bepaalde patronen die gemeenschappelijk onder hen zijn. Elk videobestand misschien zijn van een andere video, maar het eerste paar bits meestal hetzelfde. Of de laatste paar stukjes zijn meestal hetzelfde. 

En dus met een hoge waarschijnlijkheid, U kunt kijken voor die patronen. En zelfs als het bestand is vergeten, je kunt zeggen met een grote kans, maar dit ziet eruit als een Word-document, laat terug te krijgen en niet-vergeet het maar, als je wil. En dus dat is hoe u kunt herstellen gegevens die hetzij per ongeluk is geweest gewist of verwijderd of opzettelijk verwijderd wat doeleinden. 

Daarentegen veilige verwijdering doet wat in het kader van een foto als deze? Precies, maakt ze allemaal willekeurig. Dus het soort beweegt sommige ze naar beneden, sommigen van hen omhoog, laat sommige ongewijzigd, en over het algemeen maakt willekeurige ruis van te maken, of heel misschien maakt van al ze 0 of allemaal 1's. En ook dat kan in het algemeen scrub je data weg. 

Dus laten we nu terugkeren naar de kwestie van de computationele denken, waarbij we hebben de formule ingangen. En algoritmen geeft U voert uiteindelijk. Wij richten ons nu op de inputs en uitgangen, want nu heb ik vordering hebben we een manier van wat neerkomt op in- en uitgangen. We gaan gewoon naar binair gebruiken. 

En het maakt niet uit wat we willen vandaag te vertegenwoordigen, of het nu een nummer of een letter of duizenden daarvan in een telefoonboek of beelden of films aan het einde van de dag, het is allemaal 0's en 1's. En ik beweer dat, ook al is dit is een super eenvoudige wereld met slechts 0's en 1's, kunnen we onszelf op te bouwen. En we hebben een voorbeeld van gezien die met letters tot nu toe. 

Dus laten we nu concentreren op deze midden bestanddeel, een algoritme. En laten we terugkeren naar dit voorbeeld van Mike Smith. Dus in dit telefoonboek, die weliswaar, we niet zo veel meer te gebruiken, er een probleem op te lossen. We willen iemand als Mike Smith te vinden. 

En wat zou ik doen om Mike te vinden? Nou, ik kon gewoon openen van deze boek, beginnen bij de eerste pagina, en beseffen, oh, ik ben in de A sectie. Mike is er niet. Ik heb de S sectie voor Smith. Dus gewoon blijven draaien één pagina tegelijk. Laat me doen alsof dit allemaal witte pagina's en niet gele pagina's, omdat we niet van plan om uit te vinden Mike in de gele pagina's toch. Maar ik ben in de witte pagina's. En nu, ik ben in de sectie B. Ik heb nog steeds heb hem niet gevonden. Dus ik blijf het draaien van een pagina per keer. 

Dit is een algoritme. Het is een reeks instructies voor het oplossen van een probleem. Met andere woorden, kijk naar pagina, als Mike is niet op, draaien pagina en herhalingen opnieuw en opnieuw en opnieuw, idealiter op zoek naar beneden als je het doet. Dus is dit algoritme, Hierbij correct? 

Sorry. Nee, ik hoor wat nos. OK, maar het is-- ja, het is zeker vervelend. Zoals, zullen we hier de hele dag als ik blijven zoeken naar Mike op deze snelheid. Maar laat me beweren dat het correct is. Het is dom, maar het is correct. 

Aan het eind van de dag, zolang het misschien nemen, ik zal Mike vinden als hij daar en ik ben op te letten. En ik uiteindelijk zijn pagina te bereiken. En als ik te ver, als Ik krijg de T sectie, dan kan ik iets te optimaliseren en gewoon zeggen, hm, allemaal gedaan. Ik weet niet eens hoeft te verspillen tijd naar de Z's. Maar dit is een zeer lineaire benadering, als je zal een soort van links naar rechts aanpak, een rechte lijn. En zijn correct maar traag. 

Zo herinner ik me uit de lagere school, een soort van een optimalisatie van een eerste grader, waar ik geleerd hoe om te tellen niet mee door degenen maar door twos-- zo 2, 4, 6. Het is een, stuk moeilijker om , maar in principe is het faster-- 8, 10, 12, 14, enzovoort. Hoe zit dat algoritme? Is het efficiënter? Is het sneller? 

PUBLIEK: Het is efficiënt. 

DAVID MALAN: Ja, dus het is def-- het is letterlijk twee keer zo snel, uitgaande I niet omhoog krijgen struikelde met mijn vingers. Het is twee keer zo snel, want Ik ben het draaien door middel van twee pagina's tegelijk in plaats van één, maar het is potentieel in de juiste, want waarom? 

PUBLIEK: U bent het overslaan van een aantal. DAVID MALAN: Juist, wat als Mike gebeurt om misschien worden sandwiched-- toen ik later ben in het telefoonboek, Mike gebeurt te zijn ingeklemd tussen deze twee bladzijden, en ik gewoon blindelings over te slaan. Dus we moeten een beetje fix daar. Zodra ik raakte de T sectie, I kan niet zomaar gerust zeggen, we vonden het niet Mike Smith. Ik moet waarschijnlijk om terug te verdubbelen. Of in feite, zodra ik bij iemand genaamd S-N in plaats van S-M Smith, meteen, ik kon verdubbelen terug, want misschien is hij was op de vorige pagina. 

Maar ik wil niet te ver terug te verdubbelen. In theorie, als ik doe het op het juiste tijd, ik een pagina terug te gaan. Dus het is het toevoegen van slechts een extra stap. Dus ik heb twee keer zo snel gegaan, maar het kostte me een extra pagina. Maar dat voelt als een netto winst. 

Maar dit is niet hoe de meeste mensen in Deze kamer zou dit probleem op te lossen. Wat zou een typische persoon, misschien een Enkele jaren geleden doen, Mike Smith vinden? Ja, niet vinden Mike. Wat zal ik doen? Dus maak je een beetje dichterbij, maar ik doe weten-- wat waar is over een telefoonboek? PUBLIEK: Het is sequentieel. DAVID MALAN: Het is sequentieel. Het is alfabetisch. En dus als ik ben in de M sectie, Mike is duidelijk naar rechts, Ik kan letterlijk scheuren het probleem in half-- het is meestal makkelijker dan dat-- traan het probleem in de helft en gooi het weg, zodat nu, ik heb een probleem dat is niet langer 1000 pages-- dat hard was, omdat ik denk dat ik eigenlijk scheurde het telefoonboek dit tijd-- niet 1000 pagina's, maar 500. 

Het probleem is dus letterlijk half zo groot. En dat is vrij overtuigend, omdat met mijn vorige algoritmen, versie 1 en 2, was ik alleen maar het maken van het probleem één pagina kleinere, twee pagina's kleiner tegelijk. Overwegende dat nu, ik maakte het 500 pagina's kleinere allemaal tegelijk. 

OK, dus nu, Karim stelt dat ik naar de rechter helft. Dus ik ga ruwweg gaan naar het midden, geven of te nemen. En als ik dat deed dit wiskundig, Ik kon gaan recht naar het midden. En nu realiseer ik me, oh, Ik ben in de T sectie. Ik eigenlijk te ver gaan. 

Maar ik kan, nogmaals, scheur de probleem in de helft, gooi het weg. En mijn bytes niet zo groot. Het is alleen maar, wat, 256 pagina's of 250 pagina's, geven of nemen op dit moment. Maar het is nog veel meer dan één pagina of twee pagina's. 

En nu, ga ik ongeveer in het midden. Oh, ik heb niet heel ver genoeg nu gaan. Dus ik herhaal, herhalen, herhalen, herhalen, totdat ik ben hopelijk vertrokken met slechts één pagina. 

Dus dat roept de vraag, als ik begonnen met zo'n 1.000 pagina's, hoeveel stappen duurde het me met versie 1 van mijn algoritme? Nou, als Mike is in de S sectie, in het ergste geval, dat is vrij dicht bij het einde van het alfabet. Dus als het telefoonboek heeft 1.000 pagina's, Ik zal Mike vinden binnen 1.000 pagina's, Ongeveer. Misschien is het net als 800 of zo, maar het is vrij dicht bij 1000. 

Overwegende dat, in de tweede algoritme, hoeveel pagina wordt maximaal zou ik nodig hebben om Mike Smith vinden? Er is 1000 pagina's, maar ik ben doen ze twee tegelijk. Juist, dus max zoals 500ish, omdat als ik ga door het hele telefoonboek, op welk punt, kan ik stoppen. Maar ik kan afscheren een paar door gewoon stoppen bij de T sectie. Maar het is in het slechtste geval 500 pagina's. 

Dus hoe vaak kan ik delen een 1,00o-pagina telefoonboek in de helft weer en opnieuw en again-- uit 1000 500 tot 250-125? Hoe lang voordat ik raakte één pagina? Ja, het is ongeveer 10. Afhankelijk afronding en zodanig is ongeveer 10 bladzijden totaal moeten worden gedraaid of telefonisch boeken moeten worden gescheurd. 

Dus dat is vrij krachtig. We zijn begonnen met een 1000-pagina probleem in alle drie van deze verhalen. Maar in het eerste algoritme, is nam me mee, het ergste geval, 1000 pagina draait om Mike te vinden. Ten tweede algoritme, 500 pagina's om Mike te vinden. Ten derde algoritme, 10 pagina's om Mike te vinden. En het is nog krachtig wanneer je denkt over een soort van een tegenovergestelde scenario. Stel dat de telefoonmaatschappij volgende jaar fuseert misschien twee steden samen, en het telefoonboek is plotseling deze dikke, in plaats van deze die, dus 2.000 pagina's in plaats van 1000. Wel, mijn eerste algoritme op zoek naar Mike Smith in een 2000-pagina telefoonboek, het ergste geval, het gaat over te nemen hoeveel pagina verandert volgend jaar? 

Telefoonboek is 2000 pagina's, so-- goed, niet één meer. Als het telefoonboek is twee keer zo dik in het eerste algoritme, eerste algoritme, 2000, toch? In het ergste geval, Mike echt dicht bij het einde van het boek, dus het is pagina bochten 2000. Tweede algoritme gaat door tweeën, net als 1.000 pagina's. 

Maar hoe zit het in mijn derde en de meest recente algoritme? Als de telefoon bedrijf verdubbelt de aantal pagina's van 1000 tot 2000, hoeveel keren moet ik scheur dat boek in de helft om Mike te vinden? 

PUBLIEK: Slechts één. 

DAVID MALAN: Nog een, want met pagina scheur één, Ik kan letterlijk verdelen en overwinnen, als je wil, dat probleem doormidden nemen een enorme hap uit het. Dit is dus een voorbeeld van efficiëntie en misschien wel een algoritme waarmee we allemaal soort van intuïtief vertrouwd. Maar het is net zo goed als mijn andere algoritmen met deze tweak voor de tweede algoritme, maar het is zo veel efficiënter. 

En inderdaad, wat een computer wetenschapper, of op zijn beurt een programmeur, zouden in het algemeen doen bij het schrijven code is proberen te achterhalen, Oké, ik wil niet dat mijn programma alleen maar om juist te zijn, Ik wil ook dat het efficiënt zijn en het oplossen van problemen ook. Stelt u zich eens in de echte wereld van vandaag, zoals Google indexeert, zoekopdrachten als miljarden pagina's, stel je voor dat deze gebruikt het eerste algoritme katten vinden onder een miljard pages-- kijken de eerste pagina in hun database, de tweede, de derde, gewoon op zoek voor een kat, op zoek naar een kat. Dat is pretty darn langzaam lijkt. Zij kunnen in plaats daarvan gebruik iets genoemd binary search, die is geen coincidence-- bi betekent twee, we blijven delen iets 2, in half-- ze konden binary search gebruiken en misschien vind katten nog sneller, of wat het ook is dat je op zoek bent naar. 

En eerlijk gezegd, er is zelfs liefhebber algoritmen die veel meer dan alleen maar te doen het verdelen van dingen in de helft om informatie snel te vinden. En we zullen een beetje praten over die na de lunch vandaag. Dus laat me gewoon proberen om dit te vertegenwoordigen. We hoeven niet in te gaan geen wiskunde of het werkelijke aantal. We kunnen in de abstracte praten. 

Maar laat me voorstellen, als je hadden een discussie nu met de ingenieurs het voorstellen van dit algoritme en je probeert te maken een berekende beslissing, want misschien de engineer zegt tegen je, Weet je wat, ik kan implementeren lineair zoeken in als twee minuten. Het is zo makkelijk. Binary search is niet zo mooi, maar het gaat om me als 10 minuten, zo 5 keer zo lang. 

Er is een handel hier, zelfs in termen te beslissen welke software te schrijven. Heeft u het eenvoudiger algoritme te schrijven, die slechts twee minuten neemt u mee? Of heb je meer tijd besteden, 10 minuten, het schrijven van de liefhebber algoritme? Hoe bepaal je dat soort vragen? Of je kan het een beetje meer echt. Ik vertel mijn baas het gaat nemen me één week of 10 weken het werktuig software op deze manier, hoe beslis je welk algoritme om groen licht? Karim? 

Doelgroep: Het publiek, denk ik. 

DAVID MALAN: Het publiek. Wat bedoel je met het publiek? 

Publiek: Als het gaat te gebruiken door gebruikers die [onhoorbaar] door de gebruikers [ONVERSTAANBAAR]. Maar als het is iets wat je bent gewoon doen voor jezelf om bij te dragen, [Onhoorbaar] sneller. DAVID MALAN: Ja, het is snel en vuile is een goede manier om het te beschrijven. In feite, als je het beschrijven van een groot deel van mijn tijd in graduate school, waarbij vaak tijden, Ik schreef slechte code bewust so-- althans, dat is hoe ik gerationaliseerd het-- bewust zo, want hoewel ik code schrijven dat was relatief langzaam uit te voeren, Ik was in staat om de code zelf te schrijven vrij snel, de uitgaven slechts enkele minuten of uren in plaats van dagen. En het bleek, ik soms nodig om te slapen. Dus zelfs als mijn code vereist 8 uur te lopen, goed, dat is prima, Ik zal gewoon gaan slapen, terwijl het loopt. 

Dus op het moment, ik dacht dat dit was heel slim, hoewel ik blijkbaar doorgewerkt mijn promotieonderzoek heel langzaam. Maar het omgekeerde daarvan is dat, als ik het schrijven van software voor andere mensen die telde meer dan ik, nou ja, het hebben van hen wacht 8 uur terug te krijgen hun zoekresultaten is niet zo overtuigend. En dus meer tijd besteden up front om software te schrijven dat is efficiënter, zoals onze derde algoritme, waarschijnlijk ten goede aan de gebruikers in de tijd. Dus het hangt echt voorbij tijd hoe die kosten oplopen. Als je gaat schrijven software te gebruiken keer, Waarschijnlijk kan net zo goed doen quick and dirty, zoals ze zeggen. gooi het gewoon bij elkaar. Het is code die gênant u, het is zo slecht, maar het wordt het werk correct gedaan, ook al is het niet efficiënt. Omgekeerd, je meer tijd besteden aan op iets, krijgen het precies goed. En dan afgeschreven over de tijd, dat upfront kosten van de tijd is waarschijnlijk de moeite waard, als je blijft optimaliseren voor de gemeenschappelijke zaak. 

En inderdaad, dat is een thema in programmeren, of informatica meer algemeen proberen te optimaliseren niet voor de ongewone zaak maar de gemeenschappelijke case-- welke bewerking gaat weer gebeuren? Als je gaat om miljarden hebben van gebruikers die zoeken op uw website, moet je waarschijnlijk breng de extra weken van te voren schriftelijk betere software, zodat alle gebruikers ten goede komen. Laten we nu eens proberen om dit een te vangen weinig pictorially, maar niet zo veel numeriek. 

Dus hier is gewoon een oude school grafiek. En laat me zeggen dat dit de tijd. En het maakt niet uit what-- eigenlijk, nee, geen tijd. Laten we deze op de andere as. Laten we zeggen dat dit de tijd is, en dit is groot probleem. 

En een computer wetenschapper misschien over het algemeen noemen dit gewoon n. n is als onze go-to variabele, waarbij n een getal, n nummer, en het is de aantal van welke ingangen u hebt. Dus in dit geval, n het aantal pagina's. Dus het zou kunnen zijn in 1000 het geval dat we net verteld. 

Dus tijd kan een eenheid van de maatregel. Misschien is het tweede. Misschien is het dagen. Misschien is het net pagina bochten. Maakt niet uit. Wat u ook wilt in te tellen, dat zal tijd kosten of gelijkwaardig. 

Dus met dat allereerste algoritme, als ik bijvoorbeeld had een 1000-pagina telefoonboek, Ik ga naar een punt daar te tekenen, want als het 1.000 pagina's, het duurde ongeveer 1.000 pagina draait, geven of te nemen. En dan, als ik had een 2000-pagina telefoonboek, en ik ga naar een tweede te trekken dot hier, want voor 2000 pagina's, het is net als 2.000 seconden of een pagina omslaan of wat dan ook. En dus toen ik al eerder zei, het is vorm van een lineair verband, dat was opzettelijk, want ik wilde later on-- recht now-- om een ​​lijn te trekken. Het is een soort van een rechte lijn relatie. De helling is 1/1, als je wil. 

Intussen is de tweede algoritme zei, als je hebt 1.000 pagina's en je met behulp van de tweede algoritme, waar ik met 2's geteld, draaien twee pagina's tegelijk, zou ik trek een punt onder of boven mijn originele dot? 

PUBLIEK: Onder. 

DAVID MALAN: Onder, want zoals we zagen, het kost minder tijd, half zo veel tijd. Dus de dot moet helft zo hoog als de andere. En dezelfde deal hier, deze dot moet ongeveer er waarschijnlijk. En dus mijn tweede algoritme, op dezelfde manier, een lineaire relatie met de tijd. En we kunnen het tekenen als zodanig. 

Dus nu, de derde en laatste algoritme is een beetje moeilijker om te tekenen. Maar intuïtief, als ik heb 1000 pagina's met mijn derde algoritme, het moet alleen me als 10 stappen. En als ik heb 2.000 pagina's gekregen met mijn derde algoritme, het zou me niet 10 stappen, maar 11, slechts één meer. Dus we nauwelijks gaan om dit te zien. 

En het blijkt, als Ik opnieuw in op deze, ik ben gaan overdrijven voor effect, de vorm van die lijn, uiteindelijk, is geen rechte line-- want zelfs als het, het zou meer als het kijken others-- het is eigenlijk een gebogen lijn dat, als we inzoomen, gaat veel meer zo uitzien. Het-- goed, OK, negeren dit deel. Dat was mijn pen te gaan van de hoek. Het is een gebogen lijn die altijd verhogen, altijd, altijd, altijd toegenomen, maar slechts nauwelijks. 

En dus na verloop van tijd, heb je een relatie die is meer als dit. Het ziet er bijna recht. Maar het is heel langzaam toeneemt. Maar voor bijna alle punten langs Uw x-as, horizontale as, het is lager dan die andere lijnen. 

Dus dit is misschien een relatie n, waarbij als je n pagina's, neemt u mee n seconden. Dit kan een verhouding n / 2 zijn. Je hebt n pagina's, het duurt je n / 2 seconden, half zoveel. Dit is een logaritmische verhouding, die Als u herinnert aan, log base 2 van n vangt dergelijke groei zogezegd. Dus dit is het soort van heilige graal onder de drie van deze hier, want het is gewoon zo veel meer efficiënt, maar misschien wel meer complexe implementeren. Nog vragen? 

Nou laat me dit doen, laat me open te stellen een tekstvenster gewoon zo kunnen we proberen om formaliseren hier iets. Dus laat me nu ga je gang en uitvoering van dit algoritme voor het vinden van Mike Smith in de code, als je wil, pseudo-code. Ik ga niet naar Java of C ++ te gebruiken. Ik ga gewoon een soort van te gebruiken Engels-achtige syntax, die we zou over het algemeen noemen pseudo-code. Hier, ik heb een leeg venster. En ik zeg stap 1 van de zeer eerste algoritme is pick-up telefoonboek. Stap 2 is open boek tot de eerste pagina. Stap 3 zal kijken pagina voor Mike Smith. Als op pagina, bel Mike. anders turn pagina en ga naar stap 3. Gedaan, laten we zeggen. 

En dus het is niet helemaal perfect, die we zullen zien in een moment. Maar laten we eens kijken wat concepten Ik ben hier geïntroduceerd. Zo stappen 1 en 2 en 3 zijn vrij veel werkwoorden. Ze zijn verklaringen, actions-- doen. En dus in een programmeertaal taal, zouden wij over het algemeen noemen ze verklaringen of functies of procedures, noemen ze een aantal dingen. Maar ze actions-- gewoon dit te doen. 

Stap 4 is fundamenteel verschillend, want het is een soort van een vraag. Het is te zeggen dat we zijn soort of bij een splitsing in de weg. Als Mike is op de pagina, bel hem, dus linksaf, als je wil. En zo niet, ga dan terug naar een aantal andere page-- of liever gezegd, sorry, ga terug naar een andere stap, die induceert een soort van looping construct. En we doen het opnieuw en opnieuw en opnieuw. 

En eigenlijk, weet je wat? Ja. anders als aan het eind van het boek te stoppen. Dus we moeten soort van een derde staat, omdat je kan niet blijven draaien van de pagina advertentie nauseum, want uiteindelijk, zal ik raakte het einde van het boek. En een bug in een programma zou kunnen zijn niet anticiperen op dat scenario. En toen ik besefte, oh, wacht even, ik heb een derde scenario. Als ik uit van pagina's, I moet echt gewoon stoppen. Anders is het niet gedefinieerd. Wat gaat er gebeuren als ik blijf zeggen de bladzijde omslaan en terug te gaan, dit is wanneer computers bevriezen of crash, wanneer je geraakt een aantal onverwachte situatie als dat. 

Nu, hoe zit het met Mike derde algorithm-- Smith's pak de telefoon boek, open boek te first-- aan nee, niet de eerste pagina deze keer, naar middle-- oh, nou ja, dat zouden zijn de tweede algoritme. Laten we gewoon doorgaan naar de derde plaats. 

PUBLIEK: Oh, het spijt me. 

DAVID MALAN: Dat is prima. Laten we gewoon doorgaan naar de third-- geopend naar het midden en nu op zoek naar Mike Smith. indien op pagina, bel Mike. En wat doen we hier willen zeggen? anders wat? We kunnen dit uitdrukken in een aantal manieren. Er is geen juiste antwoord. OK, als niet meer, maar we moeten be-- OK, willen we verdelen in twee, maar willen we links gaan of naar rechts? Hoe kunnen we uitdrukken dat begrip? Nou, in het geval Mike's, ja, dat is eerlijk. Maar goed, dus dat is eigenlijk een goed punt. Dat is prima. We zullen blijven gaan met deze logica. Zo-- 

PUBLIEK: Minder dan de helft. DAVID MALAN: Yeah. Dus anders als pagina is, zullen we zeggen, minder dan Smith, links van Smith, then-- laten we eens kijken, is dit gaat bemoeilijken? anders als pagina komt voor Smith, scheur in de helft, weggooien waarvan de helft? 

Publiek: Ik dacht dat was [ONVERSTAANBAAR]. 

DAVID MALAN: Ik hoor en antwoorden. 

PUBLIEK: Left. DAVID MALAN: Oké, gooi weg links de helft, zoals Lakisa al eerder zei, de linker half, toen ik soort van willen gewoon gaan to-- ik naar rechts. Of equivalent, en ik maakte een klein beetje een puinhoop van het begin hier, Ik wil effectief te ga dan naar stap 2 weer, waarbij open voor het middle-- of open-- ja, laten we maar zeggen, pagina's te midden. En hiermee is opgelost is. Het is niet langer een boek. Het is maar de helft van een boek, zo open pagina's te midden. 

else-- waren er bijna. Stap 6, anders als pagina komt na Smith, scheur in de helft, weggooien rechter helft, ga dan naar stap 2. anders stoppen, een vierde scenario als we hebben geen pagina's naar links te draaien. Dus konden we dit opruimen. En we moeten dit opruimen. Dit is zeer pseudocode code, als je zal, zeer hoog niveau beschrijving. Maar het doet in het algemeen vast te leggen op het idee. 

En, nogmaals, in dit scenario, we de notie van een aandoening, een tak, een vork in de weg, waardoor een decision-- als dit, ga op deze manier, anders als, ga op deze manier, anders als, ga op die manier. En dit is een veel voorkomende programmeertechniek beslissen welke richting om te gaan, om zo te zeggen. En we hebben ook een soort van looping structuur, waarbij we iets te doen opnieuw en opnieuw. 

Nu, zo blijkt, veel zoals in dit voorbeeld zijnde super precies is belangrijk. Maar we hebben ook iets gezien dat we blijven bellen abstractie. Wat betekent het te halen telefoonboek? We zijn gewoon een soort van het nemen van als vanzelfsprekend in deze kamer dat heeft enkele semantische betekenis. Ieder van ons gewoon een soort van weten, oh, goed, pak de telefoon boek. Wat betekent dat eigenlijk? Nou, dat betekent echt uit te breiden de hand, mager over, uit te breiden vingers, knijpen boek tussen de vingers, sta op, trek de hand naar u toe. En we konden echt pedant over dit, echt zijn super nauwkeurige in verband met wat ik doe. Maar al die stappen gezamenlijk zijn wat het betekent om pick-up een telefoonboek. 

En dus eerder, toen ik zei, elk van deze eerste twee verklaringen kan worden gezien als een gaan of een functie, echt het vertegenwoordigt wat we blijven bellen een abstractie. Het is als een hoog niveau conceptuele Beschrijving van een probleem dat eigenlijk gaat om een ​​flink aantal stappen. En zo ook dit is een terugkerend onderwerp in de programmering, waarbij Ik heb misschien een programma te schrijven met behulp van syntax zoals dit-- pick_up_phone_book (). En dan syntactisch, ben ik ga iets te stelen de meeste programmeertalen. 

Nu, stap 1 ziet er zelfs meer een functie, als programmeur zou noemen. Het lijkt erop dat iemand code heeft een naam gegeven en gegeven mij somehow-- gebruiken in andere woorden, wat de lijn die ik heb gewezen op staat voor functionaliteit die misschien Ik wist niet eens uit te voeren mezelf. Iemand ouder, wijzer dan me al bedacht hoe je het begrip uitdrukken van het oppakken van een telefoonboek. En het is net als de vijf stappen die ik net ratelde, uit de top van mijn hoofd. 

Maar hij of zij reeds uitgevoerde Dit gaf de verschillende stappen een naam, pick_up_phone_book. En de haakjes net wat de meeste programmeurs doen aan het einde van uitspraken als deze. Ik kan nu op staan ​​zijn of haar schouders en nooit meer, na te denken over wat het betekent te halen een telefoonboek. Ik kan alleen maar zeggen, pak de telefoon boek. En dat is precies wat allemaal van ons mensen hier deed. 

Toen we waren waarschijnlijk 1 jaar oud, 2 jaar oud, iemand had om ons te leren wat het bedoeld om pick-up een telefoonboek. En sindsdien, we hebben weg geabstraheerd van die zeer oninteressant mechanische stappen. En we hebben gewoon een intuïtief begrip van wat het betekent om pick-up een telefoonboek. 

En je kunt nu extrapoleren om meer gecompliceerde things-- bouw van een gebouw. Zoals, voor sommige mensen, dat daadwerkelijk betekenis. Om aannemers, architecten, dat een betekenis heeft. En ze zouden weten wat te doen, als Ik zei, ga de bouw van een gebouw. 

Maar de meesten van ons in de kamer kon niet omgaan met dat niveau van abstractie. U moet ons vertellen graag gaan halen de schop en gaan halen de betonnen en nagel de stukken hout samen en wat anders is betrokken bij de bouw van een gebouw. En dat is omdat we niet Nog geprogrammeerd begrijpen wat het betekent om een ​​gebouw te bouwen. We hebben dat niet abstractie. We hebben dat niet functionaliteit. 

En dus wat je ziet in programmeertalen, in het algemeen, vooral meer moderne talen, zoals Java, PHP, Ruby en Python, ze veel meer volwassen dan oudere talen, zoals C en C ++ en nog anderen. En zo komen ze met meer functionaliteit ingebouwd. Meer code is geschreven door mensen in het verleden dat we nu kunnen bellen of te roepen of te gebruiken, aangezien ik zinspeelde op met benadrukte deze lijn hier. En dus hoewel we praten niet over programmeertalen per se, slechts pseudocode code, alle ideeën zijn nog steeds in die discussie. En het blijkt precisie super belangrijk, evenals abstractie. En laten we proberen om communiceren dat als volgt. 

Ik heb per ongeluk zou hebben verwend dit door te knipperen met een dia op het scherm voortijdig. Maar laat me vragen om een ​​dappere vrijwilliger, als je het niet erg vindt komen. Je zou in de voorkant van de camera, als je met dat OK. Zou iemand graag te komen en geef instructies om uw collega's? Gewoon hier te komen en sta hier over en zeggen sommige woorden. 

Victoria lacht de meest en het vermijden van mijn ogen het meest. Zou u bereid zijn om verder te komen zijn? OK. En als iedereen op uw plaatsen zou kunnen nemen uit een stuk van oud papier, als je wil. Gelinieerd papier is prima. Kom rond op deze manier. Of een deel van het papier je gisteren werden gegeven, zomaar een blanco vel van papier, als je kon. En als je die niet hebt, gewoon Vraag je buurman als je kon. 

Dus voor het moment, voor dit voorbeeld, Victoria gaat naar de rol van spelen een programmeur, een ingenieur, die moet u het programma al, als de computers, om iets te doen. En we zullen zien wat aannames u besluit te maken. We zullen zien hoe nauwkeurig ze kiest te zijn. En als deze demonstratie gaat pedagogisch goed, veel fouten zal worden gemaakt, dat we dan zullen gebruiken dat als een kans voor discussie. Maar de uitdaging voor u moet om deze fouten te voorkomen, een goede programmeur. En dus is de uitdaging bij de hand, als zou je graag om hier te lopen, ligt tegenover Victoria op het scherm hier-- en hopelijk niemand van jullie herinner me toen ik geflitst op het scherm. En draai je niet om helemaal niet, want is er een ander scherm in deze kamer dat ik uit kan draaien. Dus niet omdraaien. 

Voor Victoria is dat dezelfde schreeuw. En haar taak is nu om u te vertellen alle op uw stuk papier wat te tekenen. En we zullen zien, op basis van mondelinge instructies alleen, computer code, als je wil, hoe nauwkeurig uw tekeningen zijn-- uw implementaties. Zinvol? 

Publiek: Ja. DAVID MALAN: OK, uit te voeren. 

PUBLIEK: Teken een vierkant. 

[GELACH] 

DAVID MALAN: En nee vragen kunnen worden gesteld. Kan alleen doen wat je gezegd wordt. Oh, en als je slides van vandaag openen in een tab, kijk niet naar het tabblad. OK? 

PUBLIEK: OK, trek een cirkel. Een slope-- kan ik zeggen helling? DAVID MALAN: aan jou. PUBLIEK: Een helling. En een driehoek. 

DAVID MALAN: Oké. En blijf hier maar voor een ogenblik. En ik ga om te komen rond in slechts een moment. En geen behoefte om uw namen op het te zetten. Laat me rond te komen en het verzamelen van uw tekeningen, Als je het niet erg scheuren ze uit. 

Hier is wat we terug kwamen. Ik zal het op het scherm projecteren. Ik zie een vierkant, een cirkel, een helling, en een driehoek. Dus dat was een antwoord daar. En let's-- whoops. Dank je. Hier is nog een assortiment, en één erachter. 

Dus ze lijken allemaal om de geest te vangen. Dank je. Er is een andere, en hier is een andere. De helling interpretatie is een beetje anders, weinig curvy. En de dichtstbijzijnde, hetzij vanwege de prachtige specificiteit waarmee je hebt beschreven, of misschien heb je soort zag het al eerder, dit is inderdaad wat Victoria was eigenlijk beschrijven. 

Maar nu, degenen onder u die niet krijgen helemaal gelijk, laten we bieden een aantal bezwaren hier. Dus Victoria zei eerst tekenen van een plein. En nu, kunnen we aannemen omwille van vandaag dat iedereen weet hoe je een vierkant te tekenen. Maar dat is niet geheel duidelijk, toch? Hoe anders zou je hebt getrokken een vierkant, of wanneer misschien wel een deel van de onduidelijkheden hier voor de computer? PUBLIEK: Locatie en oppervlakte. DAVID MALAN: Location, toch? Ieder van jullie had een paper van een aantal vorm, algemeen rechthoeken, maar enigszins verschillende maten. Maar je hebt zeker zou hebben getrokken, als je wilde, een groot plein, misschien een klein plein. Misschien werd gedraaid. Ik denk niet dat we zagen dat. Maar het zou meer diamanten zijn geweest zoals maar toch, toch, mathematisch een vierkant. Dus dat was misschien wel dubbelzinnig. 

Toen zei ze, trek een cirkel. Sommigen van jullie hebben het naast trekken het, dat is niet onredelijk, omdat mensen de neiging om te denken of te lezen rechts naar links in de meeste talen, dus niet een slechte gok. Maar die kring zou kunnen hebben geweest in het vierkant, rond kunnen zijn vierkant, zou elders zijn geweest op het blad, dus misschien wel dubbelzinnig. 

Slope zou misschien zijn geweest het nemen van de meest vrijheden verbaal met wat dat betekent. En sommigen van jullie geïnterpreteerd het als een kronkelende lijn of een rechte lijn of iets dergelijks. Driehoek en dan ook kunnen hebben georiënteerd in een aantal manieren. Dus in het kort, zelfs met iets dat je blik en je net als, wow, dus simpel, een kind kan trekken dit, nou niet echt, tenzij je super, super overtuigend en vertel de computer precies wat te doen. Dus als we konden, als u een ander vel papier, laten we probeer dit eens te meer. En ik ga naar Victoria één geven ander voorbeeld op het scherm in. En nogmaals, niet omdraaien en kijk niet naar uw dia's. En ik zal haar even de tijd om te geven na te denken over hoe om dit te beschrijven. Laat ze niet te zien de angst in je ogen. 

[GELACH] 

En opnieuw, dit keer leverage sommige van die afhaalrestaurants en proberen om bijna iedereen te krijgen in ieder geval het juiste antwoord. 

PUBLIEK: OK, neem een stuk papier, kijk in het midden van dat stuk papier. In het midden van dat stuk papier, trek je een kubus. 

[GELACH] DAVID MALAN: Wat hebben we geleerd? We waren zo dichtbij. OK, herhalen als je kon, voor iedereen. 

PUBLIEK: In het midden van de stuk papier, teken een object, die eruit ziet als een kubus. 

DAVID MALAN: OK, dat is alles wat je krijgt om mee te werken. Sta mij toe analytisch en niet zo kritisch, maar om de claim te maken dat Victoria zeker lijkt te zeer te denken in hoog niveau abstracties, die is niet onredelijk. Want anders zouden we allemaal zijn mooie disfunctionele, als we ooit zo precies te zijn met alles wat we doen in de wereld. 

Maar zeggen ga naar het middle-- I dachten dat we op zo'n goede track daar, net als naar de middelste van de pagina, en teken een kubus. Dus ze denken in abstracties, omdat ze nog steeds het bekijken wat er op het scherm als inderdaad een kubus. Maar er zijn zo veel mogelijkheden voor de interpretatie daar. En in feite is er zo veel andere manieren waarop je zou kunnen uitdrukken dat, wat ik stel in een moment. Dus hier hebben we een incarnatie van de picture-- whoops-- één incarnatie van het beeld, zodat een kleine drie dimensionaliteit aan, dat is leuk. 

Hier is nog een, waar u de hetzelfde, maar het is een soort van een open kubus. Sommige mensen hebben het een beetje meer platte, tweedimensionale. En dat is prima. Dus er inderdaad in de midden van het papier. Deze Ik denk dat je net, want als we hier naartoe te gaan, dit is wat ze beschreef. Dus nu, laat me voorstellen hoe anders we zouden deze situatie te beschrijven. 

Vroeger, een van de meest meest voorkomende manieren om te leren programmeren was om code te schrijven, schrijft lijnen instructies, dat gecontroleerd een beetje schildpad op het scherm. Logo en andere varianten van deze was de naam van de taal. En de schildpad leefde in een wereld. 

Dus neem aan dat dit rechthoekige ruimte is zijn wereld. En je zou beginnen met assuming-- I niet echt weten hoe schildpad te trekken, dus laten we doen als dit. En dan heeft hij een schelp en dan misschien wat voeten. Dus je zou dit hebben weinig karakter op het scherm. 

En het doel van deze programmeertaal was om de schildpad te dwingen om omhoog te gaan, omlaag, links, rechts en zijn pen neer te zetten of pick-up zijn pen, dus hij kon eigenlijk tekenen op het scherm in deze zeer vlak rechthoekig wereld. Dus waar ik dacht dat je zou kunnen gaan, en waar je moet duiken overwegen naar beneden om mentaal bij het beschrijven instructies algemeen, Ik zou beweren, is zet je pen neer in de middle-- en we zullen ontdoen van de te krijgen schildpad, want ik kan niet echt houden tekenen hem heel goed. 

En nu, hoe anders kan Ik zeg trek een kubus? Nou, we konden iets als gelijkspel zeggen een diagonale lijn noordoosten, bijvoorbeeld, of bij een hoek van 45 graden naar boven. En dat zou me hier hebben gekregen. En ik ben vrij ver van een kubus. Maar nu kon ik iets te zeggen achtige draai 90 graden naar links en trek een lijn van gelijke lengte noordwesten. En ik kon blijven met gelijkaardige richtingen. En het is niet makkelijk zal zijn. En eerlijk gezegd, we waarschijnlijk zijn hier al vijf minuten bezig. Maar misschien zouden we hebben gekregen om iets dat aan het eind van de dag, eindigt in een kubus, maar we dook binnenkant van die abstractie het doen op zo'n lage level dat je niet kunt echt zien wat je aan het doen bent totdat de hele ding is eigenlijk is er op de pagina. En dus dit is een algemeen principe, opnieuw, van programming-- dit idee abstractie. Het is zo heerlijk krachtig, omdat weer, ze net zei, trek je een kubus, waarin alle ons vrij veel zou zeer snel Grok. We zouden alleen te begrijpen, OK, trek je een kubus. We weten misschien niet de oriëntatie, dus we konden een beetje meer precies te zijn, maar we kunnen over het algemeen beeld of weet wat een kubus is. En dat is handig, want als elke keer dat je ging zitten als programmeur bij uw toetsenbord om code te schrijven, als je moest denken op zo'n een laag niveau, niemand van ons zou wel eens iets gedaan. En zeker, niemand van ons zou genieten van het proces van het schrijven van code. Het zou zijn alsof schrijven in 0's en 1's, dat eerlijk gezegd was niet zo lang geleden mensen werden code schrijven in 0's en 1's. En we kwamen al snel met deze hogere niveau languages-- C ++ en Java en anderen. 

Dus laten we proberen dit eens te meer alleen maar om flip de tafels, zodat ieder van ons de kans hebben om na te denken in plaats dezelfde manier. Kunnen we nog een vrijwilliger deze tijd om te komen aan de raad en te tekenen, niet reciteren? Ja oke. Ben, kom op maximaal. En, Ben, in dit geval, als je eenmaal het gezicht van de raad van bestuur, niet kijk naar links, kijk niet naar rechts. Alleen doen wat je collega's vertellen. En voor iedereen in de kamer, je hebt nu de programmeur. Hij is de computer. En het beeld dat ik heb hier gekozen op voorhand is dit hier. Ze gewoon-- ze denken van een leuke grap is alles. 

Dus ik zou doet iemand willen vrijwilliger de eerste instructie of verklaring dat moet pen commando Ben's? En we zullen dit gezamenlijk doen, misschien een instructie van elke persoon. Het spijt me? 

PUBLIEK: Teken een cirkel. DAVID MALAN: Teken een cirkel is het eerste wat ik hoorde. 

PUBLIEK: Up top. 

DAVID MALAN: Up top. OK, kunnen we u laten verwijderen, ongedaan te maken. En nu, iemand anders. Dan, zou je comfortabel zijn die de volgende instructie? 

PUBLIEK: Zeker, trek het centrum van de onderkant van de cirkel, met een small-- een beetje kleine ruimte van dat, trek je een rechte lijn naar beneden tot drie kwart van de weg naar beneden het bord een lichte hoek aan uw linkerhand. 

DAVID MALAN: Goed. 

PUBLIEK: lichte hoek. 

DAVID MALAN: Undo, de Control-Z. OK. Andrew, je wilt bieden de volgende instructie? 

PUBLIEK: Zeker. Van de bodem van die lijn, een verdere lichte angle-- whoops-- misschien ongeveer een derde van de lengte [ONHOORBAAR] lichte hoek naar beneden en als een derde van de lengte van [ONVERSTAANBAAR]. Dus ja, vanaf dat punt, trek een lijn een derde van de lengte van de vorige lijn verder naar links. 

DAVID MALAN: Dat OK? Rechte lijn, dat is OK? OK, Olivier, je wilt naar de volgende offeren? 

PUBLIEK: [onhoorbaar] in de onderkant van de cirkel, [ONVERSTAANBAAR]. Teken aan de rechterzijde van [onhoorbaar] centimeter. 

[GELACH] 

DAVID MALAN: Ik denk dat je gaat te zetten die naast hier. 

PUBLIEK: Stop. 

[GELACH] 

DAVID MALAN: OK. [? Ara,?] Je wilt naar de volgende offeren? 

PUBLIEK: Teken een [ONVERSTAANBAAR] de bovenste [ONHOORBAAR] hetzelfde. [ONHOORBAAR] cirkel, te vestigen op de [Onhoorbaar] en teken [ONVERSTAANBAAR]. 

DAVID MALAN: OK, niet meer ongedaan maken. Laten we één of twee meer instructies. Chris, wil je een aanbod? 

PUBLIEK: Aan de onderkant van de cirkel, [ONVERSTAANBAAR] trek een gelijke lijn slopping naar beneden naar links [ONVERSTAANBAAR]. 

DAVID MALAN: OK. Andrew? We did-- Karim? 

Publiek: Vanaf de juiste lijn, het eind van de linkerlijn de bodem, je gaat naar rechts over te gaan dezelfde lengte als die lijn je bent op, tekenen aan de rechter [ONVERSTAANBAAR]. [ONHOORBAAR] graden, zodat [ONVERSTAANBAAR] graden aan de rechterkant. 

DAVID MALAN: Oké. Laten we pauzeren. Nog niet omdraaien. Laten we pauzeren, en laten we probeer een andere poging voordat we onthullen Ben wat hij al getekend. Kun je shuffle Ben naar de right-- of eigenlijk, Nee, laten we gewoon je geeft een ander board, nog beter. Zo iemand zou nu graag om meer van de aanpak dat Victoria nam eerder, waarbij we spreken in een hoger abstractieniveau en in slechts een zin of twee beschrijven Ben wat te tekenen zonder krijgen in het onkruid, dus op dit een lager niveau te spreken? Victoria. [GELACH] PUBLIEK: Teken een cijfer van de lopende mens. En zijn benen en armen moet de juiste kant. 

DAVID MALAN: OK, dat is alles wat je krijgt. Okee. Waarom gaan we niet onthullen Ben wat hij deed. Dus een applaus. Dat was het moeilijkste misschien. 

Dus hoewel we praten in tamelijk domme termen over enkel trekken foto's, hopelijk kan echt genieten van de mate van expressiviteit die nodig zouden kunnen zijn met het oog op een computer wat te doen te vertellen. En inderdaad, dat Ben was in staat om dit zo snel te trekken is een soort van bewijs van het gebruik van een taal, misschien een hoger niveau versie van het Engels, die hem toestaat om gewoon gebruik maken van woorden, of woorden te horen van Victoria, die hem mogelijk maken deze abstractions-- gewoon te trekken een figuur lopen naar de right-- dat soort heeft sommige semantische betekenis aan dat niet bijna net zo duidelijk als je gewoon zeggen, zet je pen neer, trek naar rechts, trek naar links. 

En zo ook dit is zeer gebruikelijk in de programmering. Dit kan worden gezegd dat als een zeer laag niveau taal, programmering in 0's en 1's als je wil. En dit zou een hoger niveau taal programmeren in Java, of zoiets. Een beetje een oversimplificatie, maar dat is het een beetje als emotioneel het gevoel dat je voelt wanneer via een soort dingen of een ander. Een beetje frustratie hier door de noodzaak dergelijke precisie, maar de kans een beetje losser zijn met de interpretatie hier. Maar natuurlijk, insecten kan voortvloeien. 

Als u wilt op thuis-- we zal deze in class-- niet doen maar als je wilt breng dit één huis, Ik dacht dat we zouden duiken in deze. Dus als je wilt om dit te spelen spel met uw partner of kinderen of iets dergelijks, u zou kunnen genieten dat ook. 

Dus laten we gaan vooruit en kijken naar een laatste ding hier voor computational denken. En dat brengt ons bij John Oliver, niet voor de clip je zou gisteravond hebben gezien, maar om een ​​enigszins recente uitgave. Een paar maanden terug, Volkswagen nam nogal wat flak om welke reden, als je weet? Wat hebben ze in de problemen komen voor? 

Ja, dus ze emissions-- probeerden om de uitstoot te verslaan proeven in hoofdzaak met die hun auto's vervuilen het milieu minder toen hun auto's werden getest en vervuilen het milieu meer wanneer de auto niet getest. En wat is er steeds interessanter in de wereld, zoals u wellicht afgeleid hebben Uit gesprekken van like-- wat is het-- CarPlay, Apple's software voor auto's en het feit dat veel van ons in toenemende mate hebben touch screens in onze auto's, er is een angstaanjagende hoeveelheid van de software in de mensen's auto's vandaag, die eerlijk gezegd opent een blik wormen bij het gaat om veiligheid en fysieke risico's. Maar voor vandaag, laten we concentreren op slechts wat die betrokken zijn bij het schrijven van software dat kan het systeem gamed. 

Voor de definitie van de probleem, voor degenen die niet bekend, laten we eens een kijkje nemen op John Oliver. En voor wie vertrouwd is met het probleem, laten we eens kijken in een leuke lens via John Oliver ook. Dus laat me hit spelen op dit, ik denk, drie minuten durende introductie. Verdorie. [VIDEO AFSPELEN] -Cars-- DAVID MALAN: Uiteraard, op YouTube, it's-- - --de Slimste tekens in de Fast and Furious films. Deze week, de Duitse automaker Volkswagen zag zich in het midden van een schandaal potentieel criminele proporties. 

-Volkswagen Is schrap voor miljarden in boetes, mogelijk strafrechtelijke vervolging voor zijn leidinggevenden, zoals het bedrijf verontschuldigt zich voor rigging 11 miljoen auto's aan helpen verslaan uitstoot testen. 

-bepaalde Diesel modellen werden ontworpen met geavanceerde software die gebruikte informatie, met inbegrip van de positie van het stuurwiel en het voertuig snelheid, bepalen de auto ondergaat uitstoot testen. Onder deze omstandigheid, de motor zou giftige uitstoot te verminderen. Maar de auto werd opgetuigd om bypass dat wanneer het werd bestuurd. Emissies zijn gestegen 10-40 keer hoger EPA aanvaardbare niveaus. 

-Wow, 10 tot 40 keer groter dan de EPO zorgt. Dat is het ergste Volkswagen heeft ooit heb gedaan, is iets wat je zou kunnen zeggen als zou je nog nooit gehoord van de Tweede Wereldoorlog. Maar misschien is de zekerste teken van hoe veel moeite Volkswagen is in, is dat mensen aan het top hebben afgetreden. De CEO ontslag op woensdag na klauteren om damage control te doen, zeggen dat hij eindeloos speet, dat klonk geweldig totdat het bleek Hij was slechts 10% spijt maar had zijn mond opgetuigd om kunstmatig zijn sorriness. En ondertussen, Volkswagen US chief had een verontschuldiging van zijn eigen. 

-Laten We duidelijk zijn over dit, ons bedrijf was oneerlijk. En in mijn Duitse woorden, we hebben helemaal verpest. 

-Ja, Maar totaal geschroefd up zijn geen Duits werken. En de Duitse taal heeft vele mooie zinnen om situaties te beschrijven net als dit, zoals [GERMAN], die ruwweg betekent, het verdriet dat komt van zakelijke leugens, of [DUITS], wat zich vertaalt als shaming degenen vader betrekken wolken benzine. Het is een mooie taal. Het vaart net buiten de tong. En door de manier, terwijl dat van de mens verontschuldiging kan oprecht hebben geklonken, het is vermeldenswaard dat hij sprak op een officiële launch party voor de 2016 Volkswagen Passat, wat betekent dat kort na het zeggen sorry, zei hij dit. 

-Dank U hartelijk voor uw komst. Geniet van de avond. Up next is Lenny Kravitz. 

[Muziek] 

-OK, OK, het beëindigen van uw verontschuldiging met naast Lenny Kravitz niet schreeuwen sober berouw. Het schreeuwt, vroegen we Bon Jovi, en hij zei nee. merk Volkswagen heeft is zwaar beschadigd. En eerlijk gezegd, hun nieuwe advertentie campagne is niet echt helpen. 

- [DUITS], we bij Volkswagen zouden willen om zich te verontschuldigen voor u bedriegen met onze voertuigen. 

[END AFSPELEN] DAVID MALAN: Dus dit was een omweg van-- sorry-- dit was een omweg inbrengen van een fundamenteel probleem in software, die je moeten bepaalde ziektebeelden. En dus is de vraag bij de hand hier is, hoe werkt een auto potentieel, zoals geïmplementeerd in software door deze programmeurs, detecteren dat het eigenlijk wordt getest? Dus om super duidelijk te zijn, wat ze deden was in omgevingen waar de programmeurs bedacht de auto werd getest, ze een of andere manier gemaakt de auto stoten minder uitstoot, minder uitstoot, dus minder giftige dampen en zo. Maar als het is normaal rijden op de weg, het zou net zo veel uitstoten vervuiling als het wilde. 

Dus hoe kunnen we schrijven de pseudocode voor dit algoritme? Hoe konden we schrijven de pseudocode voor de software die in de auto? Ik bedoel, in een notendop, het kookt naar beneden om iets als dit. indien getest, stoten minder. anders stoot meer. Maar dat is een beetje te hoog niveau, toch? 

Laten we proberen om te duiken in wat dit abstractie van het zijn geteste middelen. Met andere woorden, zelfs als je niets weet over auto's, wat voor soort vragen kan u vragen om te bepalen of je wordt getest, als u de auto bent? Welke eigenschappen zou kunnen zijn presenteren als een auto wordt getest? 

PUBLIEK: testapparatuur. 

DAVID MALAN: testapparatuur. Dus als het testen van apparatuur in de buurt, dan stoten minder. Dus ik kan me voorstellen uitvoering die met een soort camera of het opsporen van wat er om je heen. En laat me voorstellen dat voelt gewoon te ingewikkeld daadwerkelijk aanvullende hardware voor dat doel. 

Publiek: Als je in park, als uw motorkap open is. 

DAVID MALAN: In park of motorkap geopend, dus dat is goed. 

Publiek: En rijdende auto. 

DAVID MALAN: Dus dat is een beetje meer concrete-- en auto lopen. Dus zou dit de combinatie van een te zijn paar verschillende omstandigheden, als je wil. Dus als de auto in het park, en zelfs al is dit een zeer mechanisch ding typisch, ik kon stel je het schrijven van software, vooral omdat er vaak een lichte daar deze dagen, Ik kon er voorstellen dat software die de shifter kan opvragen of wat niet, bent u in het park, zijn u rijden, ben je in omgekeerde richting. En ik kan weer een antwoorden dat is ofwel ja of nee tegen dat soort vragen. 

En dus kon ik ook waarschijnlijk beantwoorden een vraag willen, is de kap geopend. Misschien is er een soort van sensor dat ofwel geeft me terug een 1 of een 0, waar of onwaar, de motorkap open is. En dan de auto lopen, ik kon detecteren dat een of andere manier via welk mechanisme? Zoals, de auto loopt, I kan detecteren dat het op, kon ik een of andere manier op te sporen dat de auto in beweging is? 

PUBLIEK: RPM. 

DAVID MALAN: Ja, dus er is altijd dat naald die vertelt u hoeveel omwentelingen per minuten de wielen ervaren. En dus ik kon kijken. En als het niet 0, die waarschijnlijk betekent dat de auto in beweging is. Maar we moeten een zijn beetje voorzichtig daar, because-- laten we vereenvoudigen dit-- als we alleen maar gezegd, als de auto lopen, we willen niet alleen stoten minder, we willen als de auto loopt en het wordt getest. 

Dus er zijn een paar andere ingrediënten die mensen hebben de hypothese de software doet, omdat afwezig zijn van de werkelijke broncode, u kunt alleen een soort van af te leiden uit de fysische effecten van de wagen wat zou kunnen gaan op onderstaande de kap software. Dus als de auto loopt en misschien, laten we zeggen, achterwielen niet beweegt, kan dit indicatief van een soort test? Wat ben ik zinspeelde op hier? Ja, misschien, is het op één van die rol dingen, waarbij net als de wielen draaien voorin of achterin, afhankelijk van of het voorwiel of achterwiel aandrijving, zodat de helft van de wielen zijn het bewegen, maar de twee andere niet, welke is een vreemde situatie in de echte wereld. Als je rijdt op de weg, dat mag niet gebeuren. Maar als je in een pakhuis op een of ander rolsysteem, dat zou inderdaad gebeuren. 

Ik denk dat mensen ook voorgesteld dat misschien, als de auto loopt en stuurinrichting wiel niet beweegt, dat Ook kan een signaal zijn, want dat is redelijk voor als een direct op een weg. Maar zelfs dan, de mens is waarschijnlijk het verplaatsen van het een beetje of zeker meer dan een paar seconden. Of de loop van een minute, is de kans groot dat het niet zal worden gefixeerd in precies dezelfde positie. 

Met andere woorden, we kan aftrekken nemen, ben je wordt getest, en breken die functionaliteit in deze component ingrediënten. En dat is echt wat Volkswagen ingenieurs of andere manier deed. Zij schreven software bewust te detecteren of de auto wordt getest Daarom stoten minder, anders uitstoten op de gebruikelijke wijze. 

Het probleem ook hier is dat de software is niet iets wat je kunt echt zien, tenzij u de zogenaamde broncode. Zodat er twee verschillende soorten code-- ten minste twee verschillende types code ter wereld. Er is zoiets als bron code, die niet anders dan wat we zijn het schrijven, broncode. 

Dit is de broncode geschreven in een taal genaamd pseudocode, dat is gewoon iets Engels-achtig. Er is geen formele definitie van het. Maar C en Java, C ++, die zijn alle formele talen die, als je schrijft in hen, wat je hebt is een tekstbestand met de broncode. 

Maar er is ook iets in de wereld genaamd machine code. En machine code, helaas, is gewoon 0's en 1's. Dus machine code is wat machines te begrijpen, natuurlijk. Broncode is wat de mens te begrijpen. 

En in het algemeen, maar niet steeds is er een programma dat een programmeur gebruikt dat duurt bron code en verandert het in machine code. En dat programma is algemeen genoemd een compiler. Dus uw inbreng is de broncode, Uw output is machinecode, en de compiler is een stuk van software die dat proces doet. Dus deze kaarten eigenlijk mooi aan onze ingangen, algoritmen, uitgangen. 

Maar dit is een zeer specifieke belichaming dat, dat wil zeggen, zelfs als u zelf een van Volkswagen auto's die zich schuldig maakt aan deze, het is niet alsof je kunt gewoon open de motorkap of open de handleiding of kijk de broncode, omdat tegen de tijd het uw auto komt in uw oprit, Het is al omgezet in 0 en 1 is. En het is heel moeilijk, niet onmogelijk, maar zeer moeilijk om op te lezen veel van iets van alleen te kijken naar de onderliggende 0 en 1 is. Dus je kunt uitzoeken, uiteindelijk, als je begrijpt hoe een machine operates-- Intel inside-- als je begrijpt de Intel-architectuur, maar het is zeer tijdrovend. En zelfs daar, zou je niet in staat zijn om alles te zien dat de code daadwerkelijk kan doen. 

Heeft u vragen over dit of dit soort proces meer in het algemeen? En eigenlijk kunnen we deze discussie te binden om de discussie over Apple gisteren. Ook dit is de reden waarom de FBI niet zomaar gaan kijken in de telefoon van de verdachte en vind de regels code, voor Zo, die het mogelijk maken de toegangscode of in staat stellen dat 80 milliseconden vertraging. Omdat tegen de tijd dat het op de iPhone van de collega's, Het is al geconverteerd naar 0 en 1 is. 

Nou, laten we pauzeren hier voor onze kijk naar computationele denken. Waarom gaan we niet nemen een pauze van 15 minuten. En wanneer we terugkeren, zullen we neem een ​​kijkje op de programmering zelf en beginnen met een aantal in kaart van deze hoog niveau concepten tot een feitelijke, als speels, programmeertaal. 