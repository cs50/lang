DAVID Malan: Selamat datang kembali, semua orang. Jadi kemarin, Anda akan ingat bahwa kami fokus pada topik ini di sini. Jadi kami memiliki empat topics-- menyeluruh privasi, keamanan, dan masyarakat; teknologi internet; cloud computing; dan akhirnya, pengembangan web. Apakah ada yang punya bandwidth atau waktu untuk menonton John sedikit Oliver tadi malam? Ini sebenarnya cukup lucu, jika tidak sedikit menakutkan. Pertanyaan tentang apa-apa kita lakukan kemarin? Klarifikasi? Pertanyaan yang ingin Anda untuk membuat yakin kita menyentuh pada saat ini dalam beberapa bentuk? slate begitu bersih. 

Jadi apa yang ada di agenda untuk hari ini? Jadi saya pikir kami akan mulai hari ini dengan melihat apa yang umumnya dikenal sebagai thinking-- komputasi di risiko yang terlalu menyederhanakan, berpikir seperti komputer, mungkin berpikir seperti seorang insinyur, dan mencoba untuk mulai mengatur pikiran Anda atau untuk memberikan rasa yang lebih baik apa yang terlibat dalam sebenarnya memerintah komputer untuk melakukan sesuatu dengan cara pemrograman. Dan kami akan tetap pada cukup tingkat tinggi, cukup banyak bahasa Inggris, tetapi cobalah untuk menggunakan akrab contoh untuk meresmikan bagaimana Anda akan pergi tentang pemecahan masalah. 

Dan kami akan kembali beberapa CS topik, seperti abstraksi, yang datang pasangan kali kemarin, algoritma, dan kemudian representasi. Dan di sanalah kami akan mulai hari ini hanya dalam beberapa saat. Kemudian kita akan melihat pada pemrograman. Kita akan melihat beberapa konstruksi dasar yang Anda mungkin akrab dan bahkan mungkin menemukan cukup intuitif. 

Kita akan melihat, pada kenyataannya, pada pemrograman sampel lingkungan yang sangat mudah, sangat menyenangkan, dan memang ditargetkan untuk usia 12 tahun ke atas. Kami akan menghabiskan beberapa menit di sana dan kemudian mengambil hal-hal ke tingkat yang lebih rendah dan benar-benar berbicara tentang beberapa algoritma dan struktur data, sehingga untuk berbicara, yang programmer biasanya menggunakan untuk memecahkan masalah yang jauh lebih efisien daripada Anda mungkin dapat melakukannya tanpa mereka sama sekali. Kemudian setelah makan siang, kami akan lihat di tumpukan teknologi, yang hanya cara mewah untuk mengatakan koleksi teknologi yang mungkin Anda gunakan untuk memecahkan beberapa masalah. Dan kita akan bicara tentang alfabet sup bahasa yang ada today-- Java dan Python dan C ++ dan PHP dan Ruby dan segala macam hal lainnya. 

Kami akan melihat secara singkat di pola desain. Programmer, dari waktu ke waktu, memiliki metodologi yang diadopsi yang cenderung untuk membantu mereka memecahkan masalah lebih mudah. Ketika Anda mulai melihat diri Anda menulis jenis yang sama dari kode lagi dan lagi, orang meresmikan mereka pengulangan dan nama menganggap mereka dan kemudian menggunakannya dan mempromosikan mereka, akhirnya. Dan kita akan bicara sedikit tentang strategi mobile, seperti apa artinya untuk benar-benar membuat aplikasi mobile atau situs mobile. Apakah Anda melakukannya untuk Android? Apakah Anda melakukannya untuk iOS? Apakah Anda melakukannya untuk kedua dari mereka? Dan apa trade-off? Dan akhirnya, kita akan pemrograman web tampilan, yang adalah istilah kolektif benar-benar menggambarkan setiap saat Anda menulis perangkat lunak yang dimaksudkan untuk berjalan di web, apakah pada ponsel atau desktop atau laptop. Kami akan melihat sekilas database dan desain di dalamnya, jika hanya karena hampir semua aplikasi berbasis web yang menarik hari ini memiliki beberapa jenis database. Jika tidak, itu akan hanya menjadi konten statis. Dan database memungkinkan Anda untuk membuat perubahan dari waktu ke waktu, apakah diri Anda atau dari pengguna. Dan kami akan mempertimbangkan bagaimana Anda akan pergi tentang merancang bahwa database dan jenis jargon yang mungkin akan muncul di seorang insinyur diskusi di papan putih ketika benar-benar menerapkan aplikasi untuk pertama kalinya. 

Kita akan berbicara secara singkat tentang API, layanan yang bermanfaat yang dapat Anda gunakan untuk berdiri di bahu orang lain, apakah perusahaan atau individu, dan memecahkan Anda masalah sendiri lebih cepat. Dan kemudian kami akan mencoba-coba mungkin sedikit dengan JavaScript, bahasa pemrograman yang digunakan baik di browser hari ini, tapi juga di server. Dan mungkin, kita akan kembali, waktu memungkinkan, beberapa tangan-on kami hal web lakukan kemarin dan mengintegrasikan dua bersama-sama sebelum kita menunda. 

Jadi dengan itu-- apa ahead-- adalah ada sesuatu yang hilang yang Anda ingin memastikan bahwa kami memasukkan dan menyentuh pada di beberapa titik. Jika itu muncul dalam pikiran, membawanya sebelum lama. Tapi kenapa tidak kita mulai dengan melihat berpikir komputasi. 

Dan biarkan aku mengusulkan bahwa berpikir komputasi adalah, sekali lagi, semacam deskripsi tingkat tinggi apa yang mungkin dilakukan seorang ilmuwan komputer. Dan memang, mari kita mulai dengan tiga bahan yang mungkin masuk ke pemikiran komputasi. Ini adalah salah satu cara untuk menggambarkan itu. Kita pasti bisa mendefinisikan ini dalam beberapa cara. 

Tapi biarkan aku mengusulkan, demi hari, bahwa masalah dunia, semua masalah di dunia, ketika didekati oleh ilmuwan komputer bisa dipandang sebagai apa yang kita akan input panggilan, yang perlu untuk dimasukkan ke dalam apa yang akan kita sebut algoritma, yang kemudian menghasilkan output. Dengan kata lain, seluruh orang dunia pemecahan masalah saya klaim dapat disuling menjadi tiga bahan tersebut. Jadi apa yang saya maksud dengan masukan? Input adalah hanya apa yang Anda diserahkan dalam rangka memecahkan. 

Misalnya, inilah masalah sekolah tua. Jika saya memiliki buku telepon di sini dan Saya ingin melihat sesuatu ke dalamnya, ini masukan saya. Saya memiliki 1.000 atau lebih halaman dalam buku telepon. Ini adalah masukan untuk masalah saya. Dan saya ingin menemukan sesuatu seperti Mike Smith, jadi teman yang nama dan nomor adalah mudah-mudahan dalam buku alamat ini. 

Ini adalah sebelum hari sel telepon, jadi saya tidak bisa hanya mencari untuk itu. Jadi saya harus melakukannya tua sekolah dan benar-benar pencari masukan ini untuk beberapa jawaban. Dan jawaban itu hanya akan disebut output. Jadi input adalah buku telepon. Algoritma adalah apa pun set langkah yang saya gunakan untuk menemukan Mike Smith. Dan output, mudah-mudahan, nomor telepon Mike Smith. Dan ini maka akan hanya perwakilan dari sebagian besar masalah untuk dengan Anda masukan tangan dan ingin menghasilkan output. 

Jadi sebelum kita mempertimbangkan proses dengan mana kita dapat mengatasi masalah tersebut, menemukan Mike Smith dan sesuatu seperti itu, mari kita mempertimbangkan pertama dan input last-- dan output. Secara fisik, tentu saja, masukan di sini adalah sejumlah kertas direkatkan dalam bentuk buku telepon. Tetapi komputer, laptop course-- dan desktop dan bahkan telepon ini days-- mereka adalah perangkat elektronik. 

Dan pada akhir hari, apa satu-satunya input ke komputer? Nah, itu sesuatu seperti kabel listrik ini di sini. Saya pasang ke dinding, dan Saya mendapatkan aliran elektron, yang memungkinkan saya untuk menjalankan mesin. Atau mungkin mereka elektron yang dibuat dengan cara baterai saya. Tetapi pada akhir hari, itu satu-satunya hal yang akan ke laptop saya. Dan begitu banyak menarik hal ini akhirnya keluar, apakah dengan cara printer atau layar atau audially atau sejenisnya. 

Jadi, jika semua yang kita miliki sebagai kami masukan mendasar untuk komputer adalah listrik, jadi hanya elektron akan masuk dan atau keluar, dan bagaimana kita dapat menggunakan input yang untuk benar-benar mewakili informasi? Dengan kata lain, bagaimana kita mendapatkan dari aliran sederhana listrik untuk mewakili aktual angka atau huruf yang sebenarnya atau gambar sebenarnya pada layar atau film aktual atau e-mail atau jumlah tersebut konsep tingkat lebih tinggi, jika Anda mau, bahwa pada akhir hari entah bagaimana telah disimpan dalam ini perangkat mekanik elektronik menggunakan hanya mereka ingredients-- sederhana elektron yang datang dan keluar? 

Jadi akan terlihat bahwa, dalam bentuk yang paling sederhana, satu-satunya jenis negara Saya miliki di dunia saya, jadi untuk speak-- kondisi di dunia-- saya adalah baik Saya memiliki elektron mengalir, listrik mengalir, atau saya lakukan not-- sebagainya, off. Dan mari kita meresmikan dan mematikan, sebagai seorang ilmuwan komputer mungkin, hanya dengan 1 dan 0. Mari kita menjelaskan beberapa sewenang-wenang namun jumlah yang konsisten untuk itu. 1 berarti pada, 0 berarti off. Atau Anda mungkin juga melihat ini sebagai cara yang benar dan cara yang salah. Anda juga bisa melakukan hitam dan putih atau merah dan biru. Anda hanya perlu dua deskriptor. Dan ilmuwan komputer akan umumnya hanya menggunakan 0 dan 1. 

Jadi, jika itu yang terjadi, hanya alfabet saya adalah terdiri dari 0 dan 1, bagaimana mungkin aku bisa mendapatkan untuk bahkan nomor 2 di komputer, apalagi jumlah 3 atau huruf alfabet atau gambar atau film? Bagaimana kita semacam bootstrap diri dari prinsip dasar ini 0 dan 1 dan benar-benar mewakili sesuatu yang lebih menarik? 

Nah, mari kita mengajukan pertanyaan yang ditahan untuk sesaat dan mempertimbangkan sesuatu mudah-mudahan akrab, bahkan jika Anda belum benar-benar berpikir tentang itu secara rinci selama 10, 20, 30, 40, 50 tahun lagi. Ini adalah apa? Bagaimana Anda mengucapkan itu? Bukan pertanyaan jebakan. Sejumlah, tapi apa itu? 1, 2, 3, atau 123. Dan aku suka bagaimana Anda mengatakan 1, 2, 3, karena itulah salah satu cara melihatnya. 1, 2, 3, itu berurutan dari tiga simbol. Ini gambar yang kita sekarang memiliki kata-kata untuk. Dan jika Anda semacam membaca semuanya bersama-sama, manusia yang khas dalam bahasa Inggris akan mengatakan 123. Dan itu semacam Konsep tingkat yang lebih tinggi, terasa seperti sejumlah cukup besar. 

Tapi bagaimana kita sampai di sana? Nah, mungkin sementara karena Anda sudah berpikir tentang hal seperti ini, tapi kembali pada hari saya, saya jenis belajar ini sebagai kolom 1 ini, 10 ini kolom, dan kolom 100. Sehingga Lakisa mengatakan, itu adalah 1, 2, 3, tetapi juga 123. Tapi bagaimana kita dapatkan dari mantan untuk yang terakhir? 

Nah, Anda biasanya akan dilakukan di kolom 100, saya memiliki 1. Jadi itu seperti mengatakan 100 kali 1. Dan kemudian di kolom 10, saya memiliki 2. Jadi itu seperti mengatakan 10 kali 2. Dalam kolom 1, saya memiliki 3. Jadi itu seperti mengatakan 1 kali 3. 

Dan jika saya menambahkan hal-hal ini bersama-sama, ini, tentu saja, adalah 100 ditambah 10 ditambah 3. Dan oh, itu sebabnya aku mendapatkan ini Gagasan tingkat yang lebih tinggi dari 123. Itu hanya matematika dasar, dimana ini Simbol memiliki bobot kepada mereka, jika Anda akan, placeholder atau nilai kolom. Dan setelah saya kalikan semuanya keluar, saya mendapatkan nomor ini. 

Jadi berapa banyak dari Anda tahu bagaimana berbicara binary-- 0 dan 1's-- seperti komputer? OK, sempurna, tidak ada, atau tidak satupun dari yang Anda pikir Anda lakukan. Tapi aku akan mengklaim Anda benar-benar tahu ini sudah. Kita hanya perlu semacam men-tweak Model mental kita sedikit. Namun proses ini persis sama. 

Biarkan aku meninggalkan satu ini di sana dan bukannya menarik ini turun sejenak. Dalam dunia komputer, kita hanya memiliki 0 dan 1. Dan hal itu akan mengubah adalah apa? Nah, di dunia manusia saya, sistem desimal, Desember makna 10, Saya memiliki berapa banyak angka di pembuangan saya? 10, kan? 0 sampai 9, tentu saja. 

Dan itulah mengapa kita memiliki Tempat 10 dan tempat 100. Mana yang datang dari? Nah, ini adalah 10 pangkat 0. Ini adalah 10 pangkat dari 1, 10 dengan kekuatan 2, dan sebagainya. Anda hanya terus mengalikan kolom Anda 10, memulai dengan hanya 1 di satu paling kanan di sini. 

Jadi dalam dunia komputer, jika Anda hanya memiliki makna bi binary-- 2-- atau 0 dan 1, kita hanya benar-benar perlu untuk mengubah dasar matematika itu. Jadi dengan kata lain, sekarang kita hanya akan memiliki kolom 1 dan the-- mana ini going-- kolom 2 ini, kolom 4 ini, dan mungkin di luar. Mengapa demikian? Nah, ini adalah 2 kekuatan 0-th. Ini adalah 2 1. Ini adalah 2 ke 2, dan seterusnya. 

Jadi sedangkan di sini, kami memiliki 1, 10 ini, 100, 1.000 ', 10.000 ini, 100.000 ini, 1 jutaan, dan sebagainya, di sini kami memiliki 1, 2, 4, 8, 16, 32, 64. Anda hanya terus mengalikan dengan 2, bukannya menjaga mengalikan dengan 10. Jadi sekarang, jika tujuan di tangan adalah untuk mewakili nomor hanya menggunakan 0 dan 1, mari kita mempertimbangkan bagaimana kita sampai di sana. 

Ini, tentu saja, adalah pola 0 0 0, tapi apa jumlah konseptual apakah itu mewakili? Nah, 4 kali 0 ditambah 2 kali 0 ditambah 1 kali 0, mari kita tambahkan mereka bersama-sama. 4 kali 0, tentu saja, 0, ditambah 2 kali 0, tentu saja, 0 ditambah 1 kali 0 adalah, tentu saja, 0. Jadi ah, ini merupakan Jumlah kita manusia kenal sebagai 0. 

Nah, sekarang, mari kita sangat maju cepat cepat. Jika saya bukan tidak mewakili 0 0 0, tapi mari kita lakukan 1 0 1, yang mungkin bagaimana Lakisa, sebelumnya, hanya akan mengucapkannya 1 0 1. Tapi sekarang, bagaimana kita bawa ke yang lebih tinggi tingkat jumlah kita manusia mungkin tahu? Jadi apa nomor ini? Ini 5, jumlah yang kita kenal sebagai 5. 

Nah, kenapa begitu? Nah, kita bisa benar-benar semacam berjalan melalui itu metodis 4 kali 1, 2 kali 0, 1 kali 1. Tambahkan mereka bersama-sama, sehingga ini adalah 4 ditambah 0 ditambah 1. Dan itu, memang, 5. Jadi itu semakin sedikit membosankan sekarang melakukan aritmatika lagi dan lagi. Namun proses ini persis sama. 

Satu-satunya hal yang memiliki berubah dalam dunia kita adalah bahwa kolom kami 1, 2, 4, 8, 16, dan sebagainya, bukan 1, 10, 100, 1.000. Dan itu hanya karena alfabet kami memiliki menyusut dari 0 sampai 9 hanya 0-1. 

Jadi sebagai kuis kecil di sini, bagaimana akan Anda merupakan jumlah 7 dalam biner? 0? Nah, 0, Anda berarti 0 0 0? Mengatakannya lagi, Karina. Sempurna. Mengapa demikian? Ini efektif 4 ditambah 2 ditambah 1. Sangat baik. 

Bagaimana kita mewakili sedikit another-- bagaimana nomor 2? Dekat, tapi mundur. Jadi apa ini? Adalah 4 ditambah 1, jadi itu 5 lagi. 

Jadi what's-- Maaf, Karina? 0 1 0. 0 1 0 akan menjadi 2, karena lagi-lagi, bahkan jika semacam tidak melompat keluar pada Anda, hanya melakukan matematika. 4 kali 0, 0, 2 kali 1 adalah 2, 1 kali 0 adalah 0. Jadi ini adalah jumlah yang kita kenal sebagai 2. 

Bagaimana dengan angka 8? Hm? Baik. Jadi kita agak perlu placeholder lain. Kita perlu 1 0 0 0. Dan itu benar semacam kami sistem desimal sekolah tua. Bagaimana Anda merupakan jumlah 1.000? 

Nah, Anda tampaknya akan menjadi jenis di tempat yang sulit, jika meminta Anda untuk mewakili jumlah 1.000, karena bahkan jika Anda memberikan diri Anda seperti 9 ini, 9 ini, 0 ini, yang merupakan jumlah terbesar Anda memiliki, Anda tidak cukup sampai ke 1.000. Jadi jika Anda 1000, Anda hanya perlu lain posisi, sehingga Anda dapat melakukan 1 0 0 0, ergo jumlah 1.000. 

Jadi sekarang, mari kita peta semacam ini diskusi konseptual kembali ke hardware, di mana lagi, masukan itu hanya ini sedikit kabel listrik, listrik datang dan mengalir keluar. Dan untuk itu harus dipetakan dari sini untuk ada, baik, apa yang kita benar-benar membutuhkan? Nah, Anda bisa memikirkan berada di dalam sebuah komputer, sejumlah besar bola lampu, jika Anda mau. Mereka benar-benar disebut transistor. Dan transistor hanya switch yang dapat menjadi on atau off. Jadi Anda bisa memikirkan transistor yang ada di adalah memungkinkan listrik mengalir dan transistor yang off berhenti listrik mengalir. Dan bukannya mengambil lebih lampu di sini, mengapa saya tidak melakukan hal semacam ini gaya sekolah baru. Jadi ini mungkin 1, senter berada di, hanya nyaris sekalipun. Dan mungkin ini 0, dan sekarang itu off. 

Jadi menggunakan perangkat fisik ini, saya sekarang dapat mewakili sistem biner. Aku hanya perlu dua negara. Tidak peduli apa warna itu atau apa itu. Yang penting adalah bahwa saya memiliki satu negara dan negara lain off. Jadi menggunakan ponsel saya di sini, bagaimana saya merupakan jumlah yang kita kenal sebagai 0? Atau menempatkan ekuivalen, apa nomor saya mewakili sekarang? 0, karena perangkat tidak aktif. 

Dan jika saya melakukan ini? Dan sekarang, bagaimana saya merupakan jumlah 2? Dapatkah saya meminjam telepon Anda di sini, seperti yang kita lakukan kemarin? Jadi mari kita lihat, jadi jika saya ingin mewakili nomor 2, apakah ini nomor 2? Tidak. Apa nomor aku sengaja mewakili di sini? Ini sebenarnya adalah nomor 3. 

Jadi mana yang harus saya ingin mematikan? Telepon hitam or-- baik, jika they're-- telepon hitam atau telepon putih? Telepon putih. Jadi jika saya mematikan ini dan kami baris itu di sini, kami memiliki 1 di tempat 2 dan 0 dalam 1 ini tempat. Dan jadi aku sekarang mewakili nomor 2. Dan ini, tentu saja, akan menjadi nomor 3, karena sekarang kedua lampu ini yang. 

Dan aku akan berhenti di sini, tapi masuk akal jika saya ingin mewakili 4 atau 8 atau lebih tinggi, Aku akan membutuhkan ponsel lebih. Tapi itu semua yang terjadi. Jadi, jika Anda pernah mendengar bahwa dalam a-- terima komputer you-- adalah jutaan transistor, yang hanya jutaan switch kecil kecil. Dan mereka tidak ringan lampu yang menghidupkan dan mematikan, tetapi mereka baik memungkinkan listrik mengalir di suatu tempat atau menghentikannya. Dan jadi ada dua Anda states-- on atau off, atau menonaktifkan. 

Jadi kita akan tampak sekarang memiliki kemampuan ini untuk mewakili konsep yang kami ingin di hardware sebenarnya. Tapi semua kita miliki sekarang adalah kemampuan untuk mewakili angka itu akan tampak. Jadi bagaimana kita pergi tentang mewakili huruf abjad, yang terasa seperti semacam berikutnya fitur Anda ingin menambah komputer modern setelah Anda memiliki nomor? 

Dan memang, jika Anda berpikir tentang itu, secara historis, komputer diperkenalkan benar-benar untuk melayani sebagai kalkulator numerik. Tapi tentu saja, ini hari, mereka melakukan lebih banyak lagi. Bahkan ketika mereka boot up, Anda biasanya melihat satu atau lebih kata-kata. Jadi bagaimana Anda mewakili kata-kata, jika semua yang Anda miliki adalah, sekali lagi, listrik pada akhir hari, atau ekuivalen 0 dan 1? 

Ya. Ya, maksudku, kita seperti melakukan kemarin ini dalam beberapa bentuk, di mana di beberapa titik, Saya pikir saya sewenang-wenang mengatakan bahwa, jika kita ingin mewakili huruf A, kita hanya bisa menyebut bahwa 1. Itu dalam konteks kriptografi, di mana kita hanya perlu semacam kode, semacam pemetaan. 

Jadi mungkin A akan diwakili sebagai 1, dan B akan diwakili sebagai 2, dan Z akan diwakili sebagai 26, misalnya. Dan kemudian satu-satunya pengecualian adalah bahwa jika saya akan mengkodekan huruf dalam email-email saya atau dalam pesan teks saya nomor, Anda semua harus setuju untuk menggunakan set yang sama konvensi. Dan memang, dunia telah melakukan hal itu. 

Ada sistem di dunia disebut ASCII, American Standard Kode untuk Informasi Interchange, yang hanya keputusan beberapa tahun lalu bahwa manusia dibuat bahwa memutuskan bahwa A akan sama, tidak 1, 2, dan 26, dan forth-- itu sedikit different-- tapi 65, 66, 67. Dan aku akan menarik sebuah grafik hanya dalam beberapa saat. Tapi itu sewenang-wenang. Tapi itu tidak masalah bahwa itu sewenang-wenang. dunia harus hanya menjadi konsisten. 

Sekarang, baru-baru ini, ada sesuatu yang lebih menarik disebut Unicode, karena jenis di dunia dari menyadari, setelah menciptakan komputer, bahwa ada lebih dari baik 256 simbol di dunia bahwa kita mungkin ingin untuk mewakili, terutama ketika Anda memperkenalkan bahasa-bahasa Asia dan simbol lainnya yang membutuhkan lebih ekspresif daripada Anda dapat disimpan dalam versi awal kode ini, yang disebut ASCII. Jadi Unicode sebenarnya memungkinkan Anda menggunakan lebih 0 dan 2. Secara khusus, Anda tetap mendengar byte kata dalam masyarakat dan bahkan hanya kemarin. Dan byte adalah apa lagi? 

Apa byte? Ini hanya 8 bit. Jadi, apa yang benar-benar berarti? Nah, itu berarti, sebelumnya, ketika kami berada di berbicara tentang biner dan saya menggunakan sewenang-wenang tiga bit ketika kami berada di berbicara tentang binary-- 1 ini tempat, tempat 2 ini, dan 4 ini place-- baik, byte hanya berarti bahwa Anda sedang berbicara tidak dalam satuan tiga tetapi empat, lima, enam, tujuh delapan, yang memberi kami tempat 8 ini, 16 ini, 32 ini, 64 ini, dan 128 ini. 

Dengan kata lain, sedikit tidak semua yang berguna satuan ukuran, karena itu hanya seperti satu kecil kecil sepotong informasi, atau mematikan. Jadi beberapa tahun yang lalu, dunia hanya memutuskan itu sedikit lebih nyaman untuk berbicara di hal bytes, delapan hal pada suatu waktu. Dan dengan demikian lahir gagasan byte. Dan jadi kami memiliki delapan bit di sini. 

Dan ternyata, juga, untuk serupa alasan, dunia memutuskan tahun lalu yang mewakili surat ASCII, Anda akan menggunakan unit 8 bit. Jadi bahkan jika Anda tidak membutuhkan banyak, Anda selalu akan menggunakan 8 bit untuk mewakili huruf dari alfabet. Dan ini nyaman, karena kemudian jika Anda menerima pesan yang memiliki 0 0 0 1 1 1 1 0 diikuti oleh yang lain 1 1 1 0 1 0 0 1, jadi jika Anda menerima 16 bit, dunia hanya bisa berasumsi bahwa pertama 8 adalah salah satu surat dan yang kedua 8 adalah surat lain. 

Tidak peduli berapa banyak ada. Itu hanya penting bahwa kita semua konsisten ketika kita menafsirkan bit-bit. Dan ini hanya acak. Itu berarti sesuatu, tapi aku tidak benar-benar berpikir tentang apa artinya. 

Jadi itu kebohongan putih kecil. Awalnya, ASCII benar-benar digunakan hanya 7 bit. Dan bit kedelapan adalah disebut extended ASCII. Tapi yang penting, pada akhirnya, sama. dunia pada umumnya standar pada 8 bit. 

Jadi ini tampaknya akan menjadi sedikit membatasi, karena saya hanya bisa mewakili modal A, modal B melalui Z. modal Tapi memang tidak, jika saya pergi to-- ada sekelompok sumber online, misalnya, asciitable.com, ini akan menjadi sedikit luar biasa pada awalnya. Tapi aku akan menunjukkan apa yang penting di sini. 

Ini hanya terjadi pada be-- dan aku akan walk-- mari kita lihat, jika saya pergi ke sini. Berikut ini adalah, di desimal kolom, jumlah 65. Dan surat kolom sebelah kanan karakter, Chr, adalah huruf A. Dan Anda dapat mengabaikan, untuk saat ini, segala sesuatu di tengah. Ini adalah heksadesimal, oktal, dan kode HTML. Untuk situs ini hanya mencoba untuk membuang banyak informasi pada Anda sekaligus. Tapi semua kita peduli tentang adalah desimal kolom dan kolom karakter. 

Jadi dengan logika ini, apa yang nomor yang dunia telah memutuskan merupakan huruf kecil a? Ya, 97. Dan hanya untuk membingungkan berpotensi sedikit, apa nomor telah dunia memutuskan akan mewakili nomor 1? Benar, karena we-- 49, tampaknya di sini, turun di bagian kiri bawah. 

Sekarang, apa yang saya maksud dengan itu? Jadi ternyata bahwa dalam sistem komputer, umumnya ada perbedaan mendasar antara jumlah dan karakter. Sejumlah adalah hal yang kita belajar tumbuh ketika kami super muda di sekolah dasar. Ini hal yang menghitung dengan. Tapi karakter hanya bentuk, sebuah mesin terbang, sehingga untuk berbicara, di layar. 

Sekarang, kita manusia semacam melihat sesuatu yang tampak seperti ini. Dan kita katakan, oh, itu adalah nomor 2. Tapi tidak, itu hanya simbol yang terlihat seperti apa yang kita kenal sebagai nomor 2. Dan jadi ada ini perbedaan mendasar antara angka yang sebenarnya dan karakter. Ini adalah angka. Namun umumnya, di konteks komputer, jika Anda malah melihat sesuatu seperti quoted-- ini dan Anda tidak selalu harus melihatnya dikutip, tapi demi discussion-- jika Anda melihat tanda kutip di nomor tersebut, ini sekarang karakter. Jadi nomor ini 2 bawahnya kap dalam komputer akan diwakili dengan pola bit yang mewakili nomor 50 menurut grafik online. 

Namun, jika komputer hanya melihat ini, ini akan diwakili dengan pola bit 0 0 0 0 0 0 1 0. Padahal, karakter ini akan sebenarnya diwakili as-- dan sekarang, Saya harus berpikir harder-- sedikit jadi ini Karakter akan diwakili dengan 0 0 1-- apa yang saya butuhkan di sini? 0 0 1 1 0 0 1 0. Bagaimana saya melakukan ini? Nah ini adalah nomor 50, jika Anda kalikan dengan menggunakan kolom ini, ini adalah nomor 2, dan seterusnya itu sebabnya ada dikotomi ini. 

Dan ini hanya teaser sekarang ke fitur yang ada dalam bahasa pemrograman bahwa kita akan menyentuh pada singkat hari ini. Dalam bahasa pemrograman, Anda memiliki umumnya, tapi tidak selalu, hal-hal sebut jenis data yang berbeda. Dengan kata lain, programmer-- sebuah ketika ia menulis, programmer bisa memutuskan apa Format untuk menyimpan nya data. Anda dapat menyimpan data sebagai angka mentah, seperti nomor 2. Atau Anda dapat menyimpannya sebagai string, atau urutan karakter yang biasanya Anda akan mengungkapkan dengan kutipan dalam bahasa pemrograman Anda. 

Anda dapat memiliki hal-hal called-- Saya akan menyederhanakan dan memanggil mereka Numbers nyata sehingga angka yang tidak bilangan bulat seperti nomor 2, tapi nomor seperti 4.56. Jadi bilangan real juga bisa memiliki titik desimal, jadi itu berbeda mendasar sepotong data di komputer. Dan kemudian Anda bahkan dapat memiliki jenis data lainnya masih. Jadi itu hanya teaser benar-benar dari yang paling sederhana dari keputusan desain bahwa programmer mungkin membuat bawah tenda. 

Jadi pertanyaan dulu? Jadi mari kita coba untuk membuat ini sedikit lebih nyata. hardware ini tidak sehingga banyak di gunakan lagi. Tapi kebanyakan orang di ruangan ini mungkin tumbuh dengan dan masih menggunakan hard drive dalam beberapa cara. 

Meskipun sebagian besar laptop kami tidak lagi memiliki perangkat yang beroperasi seperti ini, bukannya laptop saat ini umumnya memiliki solid state drive tanpa bagian yang bergerak. Dan yang cenderung lebih mahal, sayangnya, tapi sedikit lebih cepat dan a-- baik, sering, jauh lebih cepat, yang merupakan salah satu alasan. Dan juga tidak menghasilkan lebih banyak panas. Hal ini dapat lebih kecil, sehingga umumnya bersih positif. 

Tapi ini memungkinkan kita untuk memetakan sedikit lebih konkret apa kita sedang berbicara tentang di 0 dan 1 ini tingkat sekarang untuk perangkat fisik. Itu salah satu hal bagi saya untuk berbicara tentang 0 dan 1 dalam hal telepon saya atau abstrak dalam hal dari switch berada di dan off. Tapi apa tentang hard drive? Di laptop Anda, jika Anda memiliki lebih tua satu, atau di komputer desktop, atau pasti di server hari ini, di mana Anda memiliki hard drive yang memiliki terabyte ruang, 4 terabyte ruang, baik apa artinya? 

Sebuah hard drive dengan 1 terabyte sarana ruang ada 1 triliun byte di dalamnya entah bagaimana, atau ekuivalen 8 triliun bit di dalam. 1 terabyte akan 8 terabit atau 1 triliun bit, yang berarti jika Anda memiliki hard drive, Anda harus entah bagaimana atau lainnya satu triliun 0 ini dan 1 di dalamnya. Dan jika kita hanya melihat pada gambar sewenang-wenang dari hard drive perwakilan, ini adalah apa yang sulit berkendara biasanya akan terlihat seperti di dalam. 

Ini, juga, adalah jenis seperti pemain fonograf tua tetapi umumnya dengan beberapa catatan di dalam, jadi untuk speak-- beberapa piring-piring, karena mereka disebut, logam disk melingkar, dan kemudian kepala membaca sedikit, seperti pemain catatan lama. Dan bahwa kepala membaca bergerak kembali dan sebagainya dan entah bagaimana membaca bit. Dan apa yang ada di piring-piring ini, bahkan meskipun kita manusia tidak dapat melihat mereka, baik dalam realitas atau dalam gambar ini, ada partikel magnetik kecil kecil. Dan bahkan jika Anda sudah lama lupa bagaimana listrik bekerja, partikel magnetik yang dibebankan pada umumnya memiliki ujung utara dan selatan yang end-- begitu utara dan selatan. Dan dunia hanya memutuskan beberapa waktu lalu bahwa, jika protokol magnetik pada dasarnya sejajar seperti ini, utara-selatan, mari kita sebut bahwa 1. Jika itu bukan selatan-utara, mari kita sebut bahwa 0. Dan jadi jika Anda memiliki Anda pembuangan triliun kecil kecil magnetik particles-- dan mudah-mudahan, kecerdikan hardware di Untuk membalik-orang di sekitar seperti yang Anda lihat fit-- jika Anda ingin mewakili sejumlah 0, Anda hanya perlu 8 partikel magnetik semua selaras seperti ini. Dan jika Anda ingin mewakili delapan 1 ini, Anda hanya membutuhkan 8 partikel magnetik sejajar kembali untuk kembali ke belakang seperti ini. 

Apa yang saya maksud dengan partikel magnetik? Terus terang, bertahun-tahun kemudian, hal yang masih datang ke pikiran saya orang ini, jika Anda dibesarkan dengan hal ini. Ini adalah little-- untuk mereka yang asing a mainan anak-anak kecil yang memiliki pria berbulu ini di sini yang memiliki semua ini hitam kecil kecil partikel magnetik yang datang dengan itu. Dan menggunakan tongkat merah, yang hanya magnet, Anda dapat semacam memberinya kumis atau alis atau rambut atau apa pun pada dirinya. Jadi sebenarnya, jika kita tampilannya di, misalnya, ini adalah jenis permainan Anda bisa bermain dengan Wooly Willy. 

Dan ini hanya untuk mengatakan, ini adalah partikel magnetik jauh lebih besar dari sebenarnya pada hard drive, dan partikel magnetik jauh lebih sedikit. Tapi mari kita benar-benar melihat maka jika Anda memiliki partikel magnetik kecil di hard drive, bagaimana Anda dapat benar-benar menggunakan mereka untuk mewakili data. 

[VIDEO PEMUTARAN] 

-The Hard drive di mana PC Anda toko paling data permanen. Untuk melakukan itu, data perjalanan dari RAM bersama dengan sinyal software yang menceritakan hard drive bagaimana untuk menyimpan data tersebut. Sirkuit hard drive menerjemahkan sinyal fluktuasi tegangan. Ini, pada gilirannya, mengontrol hard drive ini bergerak bagian- beberapa dari sedikit bergerak bagian yang tersisa di komputer modern. 

Beberapa sinyal mengendalikan motor, yang berputar piring-piring dilapisi logam-. Data Anda sebenarnya disimpan pada piring-piring ini. sinyal lain memindahkan kepala baca / tulis untuk membaca atau menulis data pada piring-piring. mesin ini begitu tepat bahwa rambut manusia bahkan tidak bisa melewati antara kepala dan berputar piring-piring. Namun, itu semua bekerja pada kecepatan yang hebat. [END PEMUTARAN] Dan Anda dapat melihat di ekor akhir video, biasanya ada beberapa piring-piring. Dan sehingga kepala membaca tidak hanya membaca atas. Ini semacam seperti tiga atau empat kepala membaca atau lebih bahwa langkah seperti ini, membaca data secara bersamaan. 

Jadi ada banyak kompleksitas dan jenis waktu yang terlibat dalam hard drive. Dan hal itu berputar-benar sialan cepat, sehingga ada banyak kompleksitas. Tapi mari kita memperbesar sedikit lebih dalam dan melihat di mana partikel magnetik dan bagaimana kita mendapatkan mereka. 

[VIDEO PEMUTARAN] 

lihat -Biarkan ini pada apa yang kita hanya melihat dalam gerakan lambat. Ketika pulsa singkat listrik dikirim ke membaca / menulis kepala, itu membalik pada elektromagnetik kecil untuk sepersekian detik. magnet menciptakan lapangan, yang mengubah polaritas kecil, kecil sebagian dari partikel logam yang melapisi permukaan masing-masing piring ini. Serangkaian pola kecil ini daerah dibebankan pada disk mewakili satu bit data dalam Sistem bilangan biner digunakan oleh komputer. 

Sekarang, jika saat ini dikirim satu jalan melalui membaca / menulis kepala, daerah terpolarisasi dalam satu arah. Jika saat ini dikirim di arah yang berlawanan, polarisasi terbalik. Bagaimana Anda mendapatkan data dari hard disk? Hanya membalikkan proses. Sehingga partikel pada disk yang mendapatkan saat ini dalam membaca / menulis kepala bergerak. Mengumpulkan jutaan segmen magnet, dan Anda punya file. 

Sekarang, potongan-potongan file tunggal mungkin tersebar di seluruh piring-piring drive ini, jenis seperti kekacauan kertas di meja Anda. Jadi file istimewa terus melacak di mana segala sesuatu. Apakah Anda tidak ingin Anda memiliki sesuatu seperti itu? 

[END PEMUTARAN] 

Jadi yang disinggung di sana, mungkin, adalah topik dari kemarin penghapusan. Ketika Anda menghapus File, kemarin kami mengatakan bahwa komputer sebenarnya apa, ketika Anda tarik sesuatu ke Recycle bin atau tong sampah? Itu hanya lupa itu. Tapi 0 dan 1, partikel magnetik yang terlihat seperti merah dan biru hal di sini, atau lengan saya di sini, masih ada pada hard drive. 

Dan terdapat software-- Norton Utilities dan Yesteryear dan lebih modern lainnya software-- yang hanya akan memindai seluruh hard drive mencari di semua 0 dan 1, karena Ternyata bahwa sebagian besar berkas formats-- kata dokumen, file Excel, gambar, Video files-- semua memiliki tertentu pola yang umum di antara mereka. Setiap file video mungkin menjadi video yang berbeda, tetapi beberapa pertama bit biasanya sama. Atau beberapa bit terakhir biasanya sama. 

Dan dengan probabilitas tinggi, Anda dapat mencari pola-pola. Dan bahkan jika file telah dilupakan, Anda dapat mengatakan dengan probabilitas tinggi, tapi ini terlihat seperti dokumen Word, memungkinkan memulihkannya dan un-melupakannya, jika Anda mau. Dan itulah bagaimana Anda dapat memulihkan Data yang baik telah sengaja dihapus atau dihapus atau sengaja dihapus untuk tujuan apa pun. 

Sebaliknya, penghapusan aman melakukan apa dalam konteks gambaran seperti ini? Tepat, membuat mereka semua acak. Jadi semacam bergerak beberapa mereka turun, beberapa dari mereka sampai, meninggalkan beberapa dari mereka tidak berubah, dan umumnya membuat gangguan acak dari itu, atau mungkin saja membuat semua mereka 0 atau semua dari mereka 1 ini. Dan itu juga umumnya bisa menggosok data Anda pergi. 

Jadi mari kita kembali sekarang untuk masalah ini berpikir komputasi, dimana kita memiliki input rumus. Dan algoritma memberikan Anda output akhirnya. Kami fokus sekarang pada input dan output, karena sekarang, saya klaim kami memiliki cara mewakili input dan output. Kami hanya akan menggunakan biner. 

Dan tidak peduli apa yang kita ingin mewakili hari ini, apakah itu nomor atau surat atau ribuan darinya dalam buku telepon atau gambar atau film, di akhir hari, itu semua 0 dan 1. Dan saya menyatakan bahwa, meskipun ini adalah dunia super sederhana dengan hanya 0 ini dan 1, kita dapat membangun diri kita. Dan kami telah melihat salah satu contoh dari bahwa dengan surat sejauh ini. 

Jadi mari kita fokus sekarang ini bahan tengah, sebuah algoritma. Dan mari kita kembali ke ini contoh Mike Smith. Jadi dalam buku telepon ini, yang diakui, kita tidak menggunakan begitu banyak lagi, ada masalah yang harus dipecahkan. Kami ingin menemukan seseorang seperti Mike Smith. 

Dan apa yang saya lakukan untuk menemukan Mike? Yah, aku hanya bisa membuka ini buku, mulai dari halaman pertama, dan menyadari, oh, aku di bagian A. Mike tidak ada. Aku butuh bagian S untuk Smith. Jadi hanya terus berputar satu halaman pada satu waktu. Biarkan aku berpura-pura bahwa ini adalah semua halaman putih dan halaman tidak kuning, karena kita tidak akan menemukan Mike di halaman kuning pula. Tapi aku di halaman putih. Dan sekarang, aku di bagian B. Saya masih belum menemukan dia. Jadi saya terus berputar satu halaman pada satu waktu. 

Ini adalah sebuah algoritma. Ini satu set instruksi untuk memecahkan beberapa masalah. Dengan kata lain, melihat Halaman, jika Mike tidak di atasnya, mengubah halaman, dan mengulangi lagi dan lagi dan lagi, idealnya melihat ke bawah karena Anda melakukannya. Jadi algoritma ini, Proses ini, yang benar? 

Maaf. Tidak, saya mendengar beberapa nos. OK, tapi is-- yeah, itu pasti membosankan. Seperti, kita akan berada di sini sepanjang hari jika aku terus mencari Mike pada kecepatan ini. Tapi biarkan aku mengklaim itu benar. Ini bodoh, tapi itu benar. 

Pada akhir hari, selama itu mungkin mengambil, saya akan menemukan Mike jika dia ada di sana dan saya membayar perhatian. Dan saya akhirnya mencapai halaman nya. Dan jika saya terlalu jauh, jika Aku sampai ke bagian T, maka saya sedikit dapat mengoptimalkan dan hanya mengatakan, hm, semua dilakukan. Aku bahkan tidak perlu membuang waktu pergi ke Z. Tapi ini adalah sangat Pendekatan linear, jika Anda akan, sangat semacam kiri ke kanan Pendekatan, garis lurus. Dan yang benar tetapi lambat. 

Jadi saya ingat dari sekolah dasar, semacam dari optimasi dari anak kelas pertama, di mana saya belajar bagaimana cara menghitung tidak oleh orang-orang tetapi dengan twos-- begitu 2, 4, 6. Ini A, jauh lebih sulit untuk dilakukan, tetapi dalam teori, itu faster-- 8, 10, 12, 14, dan sebagainya. Bagaimana algoritma itu? Apakah lebih efisien? Apakah lebih cepat? 

AUDIENCE: Ini efisien. 

DAVID Malan: Ya, jadi itu def-- itu harfiah dua kali lebih cepat, dengan asumsi saya tidak bisa tersandung dengan jari-jari saya. Ini dua kali lebih cepat, karena Aku berubah melalui dua halaman sekaligus, bukan satu, tapi itu berpotensi dalam yang benar, karena mengapa? 

AUDIENCE: Kau melewatkan beberapa. DAVID Malan: Benar, bagaimana jika Mike terjadi untuk sandwiched-- mungkin ketika saya nanti di buku telepon, Mike kebetulan terjepit di antara dua halaman tersebut, dan saya hanya membabi buta melewatkan itu. Jadi kita perlu memperbaiki sedikit di sana. Setelah aku memukul bagian T, saya tidak bisa hanya percaya diri mengatakan, kami tidak menemukan Mike Smith. Saya mungkin harus dua kali lipat kembali. Atau pada kenyataannya, setelah saya mencapai seseorang bernama S-N, bukan S-M untuk Smith, segera, saya bisa dua kali lipat kembali, karena mungkin dia berada di halaman sebelumnya. 

Tapi aku tidak perlu dua kali lipat kembali jauh. Secara teori, jika saya melakukannya di sebelah kanan waktu, saya hanya mundur satu halaman. Jadi itu hanya menambahkan satu langkah ekstra. Jadi saya sudah dua kali lebih cepat, tapi harganya satu tambahan. Tapi yang terasa seperti menang bersih. 

Tapi ini bukan bagaimana kebanyakan orang di Ruangan ini akan memecahkan masalah ini. Apa yang akan orang yang khas, mungkin Beberapa tahun yang lalu lakukan, untuk menemukan Mike Smith? Ya, tidak menemukan Mike. Apa yang saya lakukan? Jadi mendapatkan sedikit lebih dekat, tapi aku tahu-- apa yang benar tentang buku telepon? AUDIENCE: Ini berurutan. DAVID Malan: Ini berurutan. Ini abjad. Dan jika saya di bagian M, Mike jelas ke kanan, Aku benar-benar dapat merobek masalah di half-- itu biasanya lebih mudah daripada air mata itu-- masalah dalam setengah dan membuangnya, sehingga sekarang, saya punya masalah yang tidak lagi 1.000 pages-- yang sulit, karena saya pikir saya benar-benar merobek buku telepon ini time-- tidak 1.000 halaman, tapi 500. 

Jadi masalahnya adalah harfiah setengah besar. Dan itu cukup menarik, karena dengan algoritma saya sebelumnya, versi 1 dan 2, saya hanya membuat masalah satu halaman yang lebih kecil, dua halaman yang lebih kecil pada suatu waktu. Sedangkan sekarang, saya membuat 500 halaman yang lebih kecil sekaligus. 

OK, jadi sekarang, Karim mengusulkan bahwa saya pergi ke bagian kanan. Jadi aku akan pergi sekitar ke tengah, memberi atau mengambil. Dan jika saya melakukan ini secara matematis, Aku bisa pergi ke kanan ke tengah. Dan sekarang, aku menyadari, oh, Saya di bagian T. Aku benar-benar pergi terlalu jauh. 

Tapi aku bisa, sekali lagi, merobek masalah dalam setengah, membuangnya. Dan byte saya tidak besar. Ini hanya, apa, 256 halaman atau 250 halaman, memberi atau mengambil sekarang. Tapi masih cara yang lebih dari satu halaman atau dua halaman. 

Dan sekarang, aku pergi kira-kira ke tengah. Oh, aku tidak pergi cukup jauh sekarang. Jadi saya ulangi, ulangi, ulangi, ulangi, sampai aku mudah-mudahan kiri dengan hanya satu halaman. 

Sehingga mengundang pertanyaan, jika saya mulai dengan sekitar 1.000 halaman, berapa banyak langkah yang dibutuhkan saya dengan versi 1 dari algoritma saya? Nah, jika Mike adalah di S bagian, dalam kasus terburuk, itu cukup dekat dengan akhir alfabet. Jadi jika buku telepon memiliki 1.000 halaman, Aku akan menemukan Mike dalam 1.000 halaman, berikan atau ambil. Mungkin itu seperti 800 atau lebih, tetapi itu cukup dekat dengan 1.000. 

Sedangkan, di kedua algoritma, berapa banyak Halaman ternyata maksimal mungkin saya membutuhkan untuk menemukan Mike Smith? Ada 1.000 halaman, tapi aku melakukannya dua sekaligus. Benar, jadi max seperti 500ish, karena jika saya pergi melalui buku telepon utuh, di mana titik, saya bisa berhenti. Tapi aku bisa mencukur habis beberapa oleh hanya berhenti di bagian T. Tapi itu di kasus terburuk 500 halaman. 

Jadi berapa kali saya bisa membagi 1,00o-halaman buku telepon dalam setengah lagi dan lagi dan again-- dari 1.000 500 untuk 250-125? Berapa lama sebelum saya memukul salah satu halaman? Ya, itu adalah sekitar 10. Tergantung pada pembulatan dan semacamnya, itu sekitar 10 halaman total kebutuhan untuk diaktifkan atau buku telepon perlu robek. 

Jadi itu cukup kuat. Kami mulai dengan masalah 1.000-halaman dalam ketiga cerita tersebut. Namun dalam algoritma pertama, membawa saya, kasus terburuk, 1.000 halaman ternyata untuk menemukan Mike. algoritma kedua, 500 halaman untuk menemukan Mike. algoritma ketiga, 10 halaman untuk menemukan Mike. Dan itu bahkan lebih kuat ketika Anda berpikir tentang semacam skenario berlawanan. Misalkan perusahaan telepon berikutnya tahun mungkin menggabungkan dua kota bersama-sama, dan buku telepon tiba-tiba ini tebal, bukan yang ini, jadi 2.000 halaman bukannya 1.000. Nah, algoritma pertama saya mencari Mike Smith dalam buku telepon 2.000 halaman, kasus yang lebih buruk, itu akan mengambil berapa banyak halaman ternyata tahun depan? 

Buku telepon 2.000 halaman, so-- baik, tidak satu lagi. Jika buku telepon adalah dua kali lebih tebal di algoritma pertama, algoritma pertama, 2.000, kan? Dalam kasus terburuk, Mike benar-benar dekat dengan akhir buku ini, jadi 2.000 halaman bergantian. Kedua algoritma pergi dengan berpasangan, seperti 1.000 halaman. 

Tapi bagaimana di ketiga dan algoritma terbaru? Jika perusahaan telepon menggandakan jumlah halaman dari 1.000 menjadi 2.000, berapa banyak kali harus saya merobek bahwa buku dalam setengah untuk menemukan Mike? 

AUDIENCE: Hanya satu. 

DAVID Malan: Hanya satu, karena dengan satu halaman air mata, Aku benar-benar bisa membagi dan menaklukkan, jika Anda mau, bahwa masalah dalam setengah taking gigitan besar dari itu. Dan jadi ini adalah contoh dari efisiensi dan bisa dibilang sebuah algoritma dengan yang kita semua semacam intuitif akrab. Tapi itu hanya sebagai benar sebagai algoritma saya yang lain dengan Tweak bahwa untuk algoritma kedua, tapi itu jauh lebih efisien. 

Dan sebenarnya, apa komputer ilmuwan, atau pada gilirannya programmer, biasanya akan lakukan ketika menulis Kode adalah mencoba untuk mencari tahu, baiklah, saya tidak ingin saya Program hanya untuk menjadi benar, Saya juga ingin menjadi efisien dan memecahkan masalah dengan baik. Bayangkan di dunia nyata saat ini, seperti indeks Google, pencarian seperti milyaran halaman, bayangkan jika mereka menggunakan algoritma pertama yang menemukan kucing antara miliar pages-- melihat halaman pertama dalam database mereka, kedua, ketiga, hanya melihat untuk kucing, mencari kucing. Itu pretty darn lambat akan terlihat. Mereka malah bisa menggunakan sesuatu disebut binary pencarian, yang ada bi coincidence-- berarti dua, kami terus membagi sesuatu dalam 2, di half-- mereka bisa menggunakan pencarian biner dan mungkin menemukan kucing lebih cepat, atau apa pun itu yang Anda cari. 

Dan terus terang, ada bahkan algoritma pelamun yang melakukan lebih dari sekedar membagi hal-hal dalam setengah untuk menemukan informasi dengan cepat. Dan kita akan bicara sedikit tentang orang-orang setelah makan siang hari ini. Jadi biarkan aku hanya mencoba untuk mewakili ini. Kami tidak perlu pergi ke setiap matematika atau angka yang sebenarnya. Kita bisa bicara tentang hal ini secara abstrak. 

Tapi saya hanya mengusulkan, jika Anda sedang diskusi sekarang dengan insinyur mengusulkan algoritma ini dan Anda mencoba untuk membuat keputusan dihitung, karena mungkin insinyur mengatakan kepada Anda, Anda tahu apa, saya bisa menerapkan pencarian linear di seperti dua menit. Itu yang mudah. Pencarian biner tidak mewah itu, tapi itu akan membawa saya seperti 10 menit, jadi 5 kali lebih lama. 

Ada perdagangan di sini, bahkan dalam hal memutuskan software apa untuk menulis. Apakah Anda menulis algoritma sederhana, yang hanya akan membawa Anda dua menit? Atau apakah Anda menghabiskan lebih banyak waktu, 10 menit, menulis algoritma pengujian? Bagaimana Anda memutuskan bahwa jenis pertanyaan? Atau Anda bisa membuatnya sedikit lebih nyata. Saya memberitahu atasan saya itu akan mengambil saya baik satu minggu atau 10 minggu untuk melaksanakan software dengan cara ini, bagaimana Anda memutuskan mana algoritma untuk lampu hijau? Karim? 

AUDIENCE: Para penonton, saya kira. 

DAVID Malan: Para penonton. Apa yang Anda maksud dengan penonton? 

AUDIENCE: Jika akan yang akan digunakan oleh pengguna yang [tidak terdengar] oleh pengguna [tidak terdengar]. Tapi jika itu sesuatu yang Anda hanya melakukan untuk diri sendiri untuk memfasilitasi masalah, [Tidak terdengar] lebih cepat. DAVID Malan: Ya, itu cepat dan kotor adalah cara yang baik untuk menggambarkan hal itu. Bahkan, jika Anda menggambarkan banyak waktu saya di sekolah pascasarjana, dimana sering kali, Saya menulis kode yang buruk sadar so-- setidaknya, itulah bagaimana saya dirasionalisasi itu-- sadar begitu, karena meskipun saya sedang menulis kode yang relatif lambat untuk mengeksekusi, Saya bisa menulis kode sendiri cukup cepat, belanja hanya beberapa menit atau jam bukan hari. Dan ternyata, saya kadang-kadang diperlukan untuk tidur. Jadi bahkan jika kode saya diperlukan 8 jam untuk menjalankan, baik itu baik-baik saja, Aku hanya akan pergi tidur sementara berjalan. 

Jadi pada saat itu, saya pikir ini adalah sangat pintar, meskipun saya rupanya bekerja melalui PhD saya sangat lambat. Tapi sebaliknya dari yang itu, software jika saya sedang menulis bagi orang-orang lain yang lebih penting dari saya, baik, memiliki mereka menunggu 8 jam untuk mendapatkan kembali hasil pencarian mereka tidak semua yang menarik. Dan menghabiskan lebih banyak waktu di depan untuk menulis perangkat lunak yang lebih efisien, lebih seperti algoritma ketiga kami, mungkin menguntungkan pengguna dari waktu ke waktu. Jadi itu benar-benar tergantung atas waktu berapa biaya-biaya bertambah. Jika Anda akan menulis software untuk menggunakannya sekali, mungkin mungkin juga melakukan cepat dan kotor, seperti yang mereka katakan. Buang saja bersama-sama. Ini kode yang memalukan Anda, itu begitu buruk, tapi mendapatkan pekerjaan dilakukan dengan benar, meskipun itu tidak efisien. Sebaliknya, Anda menghabiskan lebih banyak waktu pada sesuatu, mendapatkannya tepat. Dan kemudian diamortisasi selama waktu, biaya yang dimuka waktu mungkin berharga, jika Anda terus mengoptimalkan kasus umum. 

Dan memang, itulah tema di pemrograman, atau ilmu komputer lebih umumnya, mencoba untuk mengoptimalkan tidak untuk kasus biasa tapi case-- umum apa operasi akan terjadi lagi dan lagi? Jika Anda akan memiliki miliaran pengguna mencari di website Anda, Anda mungkin harus menghabiskan tambahan minggu depan menulis perangkat lunak yang lebih baik, sehingga semua pengguna Anda manfaat. Sekarang, mari kita coba untuk menangkap ini sedikit pictorially, tetapi tidak begitu banyak numerik. 

Jadi di sini hanya sebuah grafik sekolah tua. Dan saya katakan bahwa ini adalah waktu. Dan tidak peduli-UMPC sebenarnya, tidak, tidak waktu. Mari kita menempatkan bahwa pada sumbu lainnya. Mari kita mengatakan bahwa ini adalah waktu, dan ini adalah ukuran masalah. 

Dan seorang ilmuwan komputer mungkin umumnya menyebutnya ini hanya n. n adalah seperti go-variabel kami, di mana n adalah angka, n nomor, dan itu adalah jumlah apapun input yang Anda miliki. Jadi dalam hal ini, n adalah jumlah halaman. Jadi mungkin 1.000 di kasus kami hanya mengatakan. 

Sehingga waktu dapat setiap satuan ukuran. Mungkin, itu yang kedua. Mungkin, itu hari. Mungkin, itu seperti halaman bergantian. Tidak masalah. Apa pun yang Anda ingin menghitung di, yang akan waktu atau biaya ekuivalen. 

Jadi dengan itu pertama algoritma, jika saya, misalnya, memiliki buku telepon 1.000 halaman, Aku akan menggambar sebuah titik di sana, karena jika itu 1.000 halaman, butuh sekitar 1.000 halaman berubah, memberi atau mengambil. Dan kemudian jika aku punya 2.000-halaman buku telepon, dan aku akan menggambar kedua dot sini, karena untuk 2000 halaman, itu seperti 2.000 detik atau membalik halaman atau apa pun. Dan jadi ketika saya katakan sebelumnya, itu jenis hubungan linear, itu disengaja, karena saya ingin kemudian on-- hak sekarang-- untuk menarik garis. Ini semacam lurus Hubungan line. kemiringan 1/1, jika Anda mau. 

Sementara itu, algoritma kedua kata, jika Anda punya 1.000 halaman dan Anda menggunakan algoritma kedua, di mana saya dihitung oleh 2, mengubahnya dua halaman pada suatu waktu, saya harus menggambar titik di bagian bawah atau di atas titik asli saya? 

AUDIENCE: Di bawah. 

DAVID Malan: Di bawah ini, karena seperti yang kita lihat, waktu yang panjang, setengah sebanyak waktu. Jadi titik harus setengah setinggi lainnya. Dan kesepakatan yang sama di sini, dot ini mungkin harus kasar di sana. Dan algoritma kedua saya, sama, memiliki hubungan linear dengan waktu. Dan kita dapat menarik seperti itu. 

Jadi sekarang, ketiga dan terakhir Algoritma ini sedikit lebih sulit untuk menarik. Tapi secara intuitif, jika saya punya 1.000 halaman dengan algoritma ketiga saya, hanya harus membawa saya seperti 10 langkah. Dan jika saya punya 2.000 halaman dengan algoritma ketiga, seharusnya membawa saya tidak 10 langkah, tetapi 11, hanya satu lagi. Jadi kita hanya nyaris akan melihat ini. 

Dan ternyata, jika Saya memperbesar ini, aku akan membesar-besarkan untuk efek, bentuk garis yang, pada akhirnya, bukan line-- lurus karena, memang jika itu, itu akan terlihat lebih seperti others-- itu sebenarnya garis melengkung bahwa, jika kita memperbesar, akan terlihat jauh lebih seperti ini. Itu-- baik, OK, abaikan bagian ini. Itu adalah pena saya akan sudut. Ini adalah garis melengkung yang selalu meningkatkan, selalu, selalu, selalu meningkat, tetapi hanya hanya nyaris. 

Dan dari waktu ke waktu, Anda memiliki Hubungan itu lebih seperti ini. Hampir tampak lurus. Tapi itu sangat perlahan meningkat. Tapi untuk hampir semua titik sepanjang x-axis, sumbu horisontal Anda, itu lebih rendah dibandingkan jalur lainnya. 

Jadi ini mungkin hubungan n, dimana jika Anda memiliki halaman n, membawa Anda n detik. Ini mungkin hubungan n / 2. Anda memiliki halaman n, dibutuhkan Anda n / 2 detik, setengah banyak. Dan ini adalah logaritmik hubungan, yang jika Anda ingat, log basis 2 dari n menangkap semacam ini pertumbuhan, sehingga untuk berbicara. Jadi ini adalah semacam suci grail di antara tiga ini di sini, karena itu hanya jauh lebih efisien, tapi bisa dibilang lebih kompleks untuk melaksanakan. Ada pertanyaan? 

Yah biarkan aku melakukan ini, biarkan saya membuka jendela teks hanya supaya kita dapat mencoba untuk meresmikan sesuatu di sini. Jadi biarkan aku pergi ke depan sekarang dan mengimplementasikan algoritma ini untuk menemukan Mike Smith dalam kode, jika Anda mau, kode pseudocode. Saya tidak akan menggunakan Java atau C ++. Aku hanya akan menggunakan semacam Inggris-seperti sintaks, yang kami umumnya akan memanggil kode pseudo. Di sini, saya memiliki jendela kosong. Dan saya katakan langkah 1 dari sangat algoritma pertama adalah mengambil buku telepon. Langkah 2 adalah buku yang terbuka untuk halaman pertama. Langkah 3 akan melihat halaman untuk Mike Smith. Jika pada halaman, sebut Mike. Halaman gilirannya lain dan lanjutkan ke langkah 3. Dilakukan, katakanlah. 

Dan sehingga tidak cukup sempurna, yang akan kita lihat sebentar lagi. Tapi mari kita mempertimbangkan apa konsep saya sudah diperkenalkan di sini. Jadi langkah 1 dan 2 dan 3 cukup banyak kata kerja. Mereka pernyataan, actions-- melakukan ini. Dan dalam pemrograman sebuah bahasa, kita akan umumnya memanggil mereka pernyataan atau fungsi atau prosedur, memanggil mereka banyak hal. Tapi mereka hanya actions-- melakukan hal ini. 

Langkah 4 secara fundamental berbeda, karena itu jenis mengajukan pertanyaan. Itu mengatakan kami baik dari di persimpangan jalan. Jika Mike adalah pada halaman, panggilan dia, jadi belok kiri, jika Anda mau. Dan jika tidak, kembali ke beberapa lainnya page-- atau lebih tepatnya, maaf, kembali ke beberapa langkah lain, yang menginduksi beberapa jenis looping konstruk. Dan kami melakukannya lagi dan lagi dan lagi. 

Dan sebenarnya, Anda tahu apa? Ya. lain jika di akhir buku berhenti. Jadi kita perlu semacam ketiga kondisi, karena Anda tidak bisa terus memutar iklan halaman nauseum, karena akhirnya, aku akan memukul akhir buku ini. Dan bug dalam sebuah program mungkin tidak mengantisipasi skenario itu. Dan kemudian aku baru sadar, oh, tunggu sebentar, saya perlu skenario ketiga. Jika aku keluar dari halaman, saya harus benar-benar hanya berhenti. Jika tidak, itu tidak terdefinisi. Apa yang akan terjadi jika saya terus mengatakan mengubah halaman dan kembali, ini adalah ketika komputer membekukan atau crash, ketika anda menekan beberapa situasi tak terduga seperti itu. 

Sekarang, bagaimana dengan Mike algorithm-- ketiga Smith mengambil buku telepon, buku yang terbuka untuk first-- ke tidak, tidak halaman pertama kali ini, untuk middle-- oh, baik, yang Sebaiknya menjadi algoritma kedua. Mari kita melompat ke ketiga. 

AUDIENCE: Oh, aku minta maaf. 

DAVID Malan: Itu baik-baik saja. Mari kita melompat ke terbuka third-- untuk menengah dan sekarang mencari Mike Smith. jika pada halaman, sebut Mike. Dan kemudian apa yang kita ingin katakan di sini? lain apa? Kita bisa mengungkapkan hal ini dalam beberapa cara. Tidak ada jawaban yang tepat. OK, jika tidak lagi, tapi kita perlu be-- OK, kita ingin membagi dua, tapi kita ingin pergi kiri atau ke kanan? Bagaimana kita mengekspresikan gagasan itu? Nah, dalam kasus Mike, ya, itu wajar. Tapi OK, jadi itu benar-benar titik yang baik. Tidak apa-apa. Kami akan terus dengan logika ini. Begitu-- 

AUDIENCE: Kurang dari setengah. DAVID Malan: Ya. Jadi lain jika halaman adalah, kita akan mengatakan, kurang dari Smith, di sebelah kiri Smith, then-- mari kita lihat, adalah ini akan mempersulit? lain jika halaman datang sebelum Smith, air mata di setengah, membuang yang setengah? 

AUDIENCE: Saya pikir itu [tidak terdengar]. 

DAVID Malan: Saya mendengar kedua jawaban. 

AUDIENCE: Kiri. DAVID Malan: OK, membuang pergi meninggalkan setengah, sebagai Lakisa mengatakan sebelumnya, kiri setengah, maka saya jenis ingin hanya pergi to-- aku pergi ke kanan. Atau ekuivalen, dan saya membuat sedikit sedikit berantakan awal di sini, Saya secara efektif ingin lanjutkan ke langkah 2 lagi, di mana terbuka untuk middle-- atau open-- ya, katakan saja, halaman ke tengah. Dan ini perbaikan itu. Hal ini tidak lagi sebuah buku. Itu hanya setengah dari buku, halaman sehingga terbuka untuk menengah. 

else-- hampir ada. Langkah 6, lain jika halaman datang setelah Smith, robek di setengah, membuang setengah lagi benar, kemudian pergi ke langkah 2. lain berhenti, skenario keempat jika kita tidak memiliki halaman kiri untuk berbelok. Jadi kita bisa membersihkan ini. Dan kita harus membersihkan ini. Ini adalah kode yang sangat pseudocode, jika Anda akan, deskripsi tingkat yang sangat tinggi. Tapi itu umumnya menangkap ide. 

Dan, sekali lagi, dalam skenario ini, kita memiliki gagasan kondisi, cabang, persimpangan jalan, membuat a decision-- apakah ini, pergi dengan cara ini, lain jika, pergi dengan cara ini, lain jika, pergi ke arah sana. Dan ini adalah sangat umum teknik pemrograman untuk memutuskan arah mana untuk pergi, sehingga untuk berbicara. Dan kami juga memiliki beberapa jenis perulangan struktur, di mana kita melakukan sesuatu lagi dan lagi. 

Sekarang, ternyata, banyak seperti dalam contoh ini, menjadi super tepat adalah penting. Tapi kita juga telah melihat sesuatu bahwa kita tetap memanggil abstraksi. Apa artinya untuk mengambil buku telepon? Kami hanya jenis mengambil begitu saja di ruangan ini yang yang memiliki beberapa makna semantik. Semua dari kita hanya jenis tahu, oh, baik, mengambil buku telepon. Apa yang benar-benar berarti? Nah, yang benar-benar berarti memperpanjang tangan, membungkuk, memperpanjang jari, mencubit buku antara jari, berdiri, tarik tangan ke arah Anda. Dan kita bisa benar-benar bertele-tele tentang hal ini, benar-benar menjadi super tepat seperti apa yang saya lakukan. Tapi semua langkah-langkah kolektif yang apa artinya untuk mengambil sebuah buku telepon. 

Dan sebelumnya, ketika saya mengatakan, masing-masing ini dua pernyataan pertama dapat dianggap sebagai melanjutkan atau fungsi, benar-benar mewakili apa yang kita terus menelepon abstraksi. Ini seperti tingkat tinggi konseptual deskripsi masalah yang sebenarnya melibatkan beberapa langkah. Dan ini juga, adalah topik berulang dalam pemrograman, dimana saya bisa menulis sebuah program menggunakan sintaks seperti ini-- pick_up_phone_book (). Dan kemudian sintaksis, aku akan mencuri sesuatu dari kebanyakan bahasa pemrograman. 

Sekarang, langkah 1 terlihat bahkan lebih seperti fungsi, sebagai programmer akan menyebutnya. Sepertinya seseorang kode yang telah memberikan nama untuk dan diberikan untuk saya untuk menggunakan somehow-- di lain kata-kata, apa garis yang saya disorot merupakan fungsi yang mungkin Aku bahkan tidak melaksanakan sendiri. Seseorang yang lebih tua, lebih bijaksana dari saya sudah tahu bagaimana Anda mengekspresikan gagasan memungut buku telepon. Dan itu seperti lima langkah saya hanya mengoceh, dari atas kepala saya. 

Tapi dia sudah dilaksanakan ini, memberi mereka beberapa langkah nama, pick_up_phone_book. Dan kurung adalah hanya apa yang kebanyakan programmer lakukan pada akhir pernyataan seperti ini. Saya sekarang bisa berdiri di atas nya bahu dan tidak pernah lagi, berpikir tentang apa artinya untuk mengambil sebuah buku telepon. Aku hanya bisa mengatakan, mengambil buku telepon. Dan itulah yang kita semua manusia lakukan di sini. 

Ketika kami mungkin 1 tahun, 2 tahun, seseorang harus mengajar kita apa dimaksudkan untuk mengambil sebuah buku telepon. Dan sejak saat itu, kami telah disarikan pergi dari orang-orang yang sangat menarik langkah mekanik. Dan kami hanya memiliki pemahaman intuitif apa artinya mengambil sebuah buku telepon. 

Dan Anda bisa memperkirakan sekarang untuk things-- lebih rumit membangun sebuah bangunan. Seperti, untuk beberapa orang, yang benar-benar memiliki arti. Untuk kontraktor, arsitek, yang memiliki beberapa makna. Dan mereka akan tahu apa yang harus dilakukan, jika Aku berkata, pergi membangun sebuah bangunan. 

Tapi kebanyakan dari kita di ruang tidak bisa berurusan dengan tingkat abstraksi. Anda harus memberitahu kami suka pergi mendapatkan sekop dan pergi mendapatkan beton dan kuku potongan kayu bersama-sama dan apa pun terlibat dalam membangun sebuah bangunan. Dan itu karena kita tidak memiliki belum diprogram untuk memahami apa artinya untuk membangun sebuah bangunan. Kami tidak memiliki abstraksi itu. Kami tidak memiliki fungsi itu. 

Dan apa yang akan Anda lihat di bahasa pemrograman, secara umum, bahasa terutama yang lebih modern, seperti Java, PHP, Ruby, dan Python, mereka jauh lebih matang dari bahasa yang lebih tua, seperti C dan C ++ dan yang lain. Dan sehingga mereka datang dengan lebih fungsi built in. kode lebih telah ditulis oleh orang-orang di masa lalu bahwa kita sekarang dapat memanggil atau memanggil atau menggunakan, karena saya mengisyaratkan di dengan ini disorot line di sini. Dan jadi meskipun kita tidak berbicara tentang bahasa pemrograman per se, Kode hanya pseudocode, semua ide-ide masih dalam diskusi itu. Dan ternyata presisi super penting, seperti abstraksi. Dan mari kita coba untuk berkomunikasi yang sebagai berikut. 

Saya sengaja mungkin manja ini dengan berkedip slide di layar sebelum waktunya. Tapi biarkan aku meminta sukarelawan berani, jika Anda tidak keberatan datang. Anda akan berada di depan kamera, jika Anda OK dengan itu. Apakah ada yang mau datang dan memberikan instruksi kepada rekan-rekan Anda di sini? Hanya harus datang ke sini dan berdiri di sini dan mengatakan beberapa kata. 

Victoria tersenyum paling dan menghindari mata saya yang paling. Apakah Anda bersedia untuk datang ke atas? BAIK. Dan jika semua orang di kursi Anda bisa mengambil secarik kertas memo, jika Anda mau. kertas bergaris baik-baik saja. Datang sekitar dengan cara ini. Atau beberapa kertas yang Anda diberi kemarin, sembarang lembaran kosong kertas, jika Anda bisa. Dan jika Anda tidak memiliki apapun, hanya meminta tetangga Anda jika Anda bisa. 

Jadi untuk saat ini, untuk contoh ini, Victoria akan memainkan peran programmer, seorang insinyur, yang kebutuhan untuk program Anda semua, sebagai komputer, untuk melakukan sesuatu. Dan kita akan melihat apa asumsi Anda memutuskan untuk membuat. Kita akan melihat bagaimana tepatnya dia memilih untuk menjadi. Dan jika demonstrasi ini berjalan pedagogis baik, banyak kesalahan akan dibuat, bahwa kita kemudian akan menggunakan bahwa sebagai kesempatan untuk diskusi. Namun tantangan untuk Anda harus untuk menghindari kesalahan-kesalahan, menjadi programmer yang baik. Dan tantangan di tangan, jika Anda akan menyukai untuk berjalan di sini, adalah di depan Victoria di layar sini-dan mudah-mudahan, tidak ada Anda ingat ini ketika saya muncul di layar. Dan tidak berbalik sama sekali, karena ada layar lain di ruangan ini bahwa saya bisa mematikan. Jadi jangan berbalik. 

Di depan Victoria adalah bahwa jeritan yang sama. Dan pekerjaannya sekarang adalah untuk memberitahu Anda semua pada bagian Anda kertas apa yang menarik. Dan kita akan lihat, berdasarkan instruksi lisan saja, kode komputer, jika Anda mau, seberapa akurat gambar Anda are-- implementasi Anda. Masuk akal? 

AUDIENCE: Ya. DAVID Malan: OK, mengeksekusi. 

AUDIENCE: Menggambar persegi. 

[TAWA] 

DAVID Malan: Dan tidak pertanyaan mungkin diminta. hanya dapat melakukan apa yang diperintahkan. Oh, dan jika Anda memiliki slide hari ini terbuka di tab, jangan melihat tab Anda. BAIK? 

AUDIENCE: OK, menggambar lingkaran. Sebuah slope-- bisa saya katakan lereng? DAVID Malan: Sampai Anda. AUDIENCE: A lereng. Dan segitiga. 

DAVID Malan: Baiklah. Dan tinggal di sini untuk sesaat. Dan aku akan datang sekitar hanya dalam beberapa saat. Dan tidak perlu untuk menempatkan nama Anda di atasnya. Biarkan aku datang sekitar dan mengumpulkan gambar Anda, jika Anda tidak keberatan merobek mereka. 

Berikut adalah apa yang kami kembali. Saya akan memproyeksikan pada layar. Saya melihat persegi, lingkaran, lereng, dan segitiga. Jadi itu satu jawaban di sana. Dan let's-- whoops. Terima kasih. Berikut bermacam-macam lain, dan satu di belakang itu. 

Jadi mereka semua tampaknya menangkap semangat. Terima kasih. Ada lagi, dan inilah satu lagi. Interpretasi kemiringan adalah sedikit berbeda, sedikit melengkung. Dan yang paling dekat, baik karena indah spesifisitas dengan yang telah Anda dijelaskan, atau mungkin Anda jenis melihat itu sebelumnya, ini memang apa yang sebenarnya menggambarkan Victoria. 

Tapi sekarang, Anda yang tidak mendapatkan cukup benar, mari kita menawarkan beberapa keberatan sini. Jadi Victoria pertama mengatakan menggambar persegi. Dan sekarang, kita dapat mengasumsikan demi hari bahwa semua orang tahu cara menggambar persegi. Tapi itu tidak sepenuhnya jelas, kan? Bagaimana lagi Anda bisa memiliki ditarik persegi, atau di mana mungkin beberapa ambiguitas di sini untuk komputer? AUDIENCE: Lokasi dan ukuran. DAVID Malan: Lokasi, kan? Anda semua memiliki kertas beberapa bentuk, umumnya persegi panjang, tetapi sedikit ukuran yang berbeda. Tapi Anda pasti bisa ditarik, jika Anda ingin, persegi besar, mungkin persegi kecil. Mungkin, itu diputar. Saya tidak berpikir kita melihat bahwa. Tapi bisa saja lebih berlian seperti tapi masih, tetap, matematis persegi. Jadi itu bisa dibilang ambigu. 

Lalu dia berkata, menggambar lingkaran. Beberapa dari Anda tidak menarik di samping itu, yang tidak masuk akal, karena manusia cenderung berpikir atau membaca kanan ke kiri dalam kebanyakan bahasa, sehingga tidak menebak buruk. Tapi lingkaran itu bisa memiliki berada di dalam alun-alun, bisa saja di sekitar persegi, bisa saja di tempat lain pada lembar, jadi bisa dibilang ambigu. 

Kemiringan mungkin telah mungkin mengambil paling kebebasan secara lisan dengan apa artinya. Dan beberapa dari Anda ditafsirkan sebagai garis berlekuk-lekuk atau garis lurus atau sejenisnya. Dan kemudian segitiga, juga, bisa memiliki telah berorientasi dalam sejumlah cara. Jadi singkatnya, bahkan dengan sesuatu yang Anda melirik dan Anda seperti, wow, sehingga sederhana, seorang anak bisa menggambar ini, juga tidak benar-benar, kecuali jika Anda super, super persuasif dan memberitahu komputer apa yang harus dilakukan. Jadi jika kita bisa, jika Anda memiliki selembar kertas, mari kita coba ini sekali lagi. Dan aku akan memberikan Victoria satu contoh lain pada layar di sini. Dan lagi, jangan berbalik dan tidak melihat slide Anda. Dan aku akan memberinya waktu untuk berpikir tentang bagaimana untuk menggambarkan ini. Jangan biarkan mereka melihat ketakutan di mata Anda. 

[TAWA] 

Dan lagi, ini waktu maksimal beberapa dari mereka takeaways dan mencoba untuk mendapatkan hampir semua orang setidaknya jawaban yang benar. 

AUDIENCE: OK, mengambil selembar kertas, melihat di tengah selembar kertas. Di tengah bagian yang kertas, menggambar kubus. 

[TAWA] DAVID Malan: Apa yang harus kita pelajari? Kami begitu dekat. OK, ulangi jika Anda bisa, untuk semua orang. 

AUDIENCE: Di tengah-tengah selembar kertas, menggambar objek, yang terlihat seperti kubus. 

DAVID Malan: OK, itu semua yang Anda bisa bekerja dengan. Izinkan saya untuk menjadi analitis dan tidak begitu banyak kritis, tetapi untuk membuat klaim bahwa Victoria pasti tampaknya berpikir dalam sangat tingkat tinggi abstraksi, yang tidak masuk akal. Karena jika tidak, kita semua cukup disfungsional, jika kita harus pernah begitu tepat dengan segala sesuatu yang kita lakukan di dunia ini. 

Tetapi mengatakan pergi ke middle-- I pikir kami berada di suatu track yang baik ada, seperti pergi ke sangat tengah halaman, dan kemudian menarik sebuah kubus. Jadi dia berpikir di abstraksi, karena dia masih melihat apa yang ada di layar karena memang kubus. Tapi ada begitu banyak peluang untuk interpretasi ada. Dan pada kenyataannya, ada begitu banyak cara lain Anda bisa mengekspresikan itu, yang saya akan mengusulkan dalam sekejap. Jadi di sini kita memiliki satu inkarnasi dari satu whoops-- picture-- inkarnasi dari gambar, sehingga sedikit tiga dimensi untuk itu, yang bagus. 

Ini satu lagi, di mana Anda memiliki yang sama, meskipun itu jenis batu terbuka. Beberapa orang mengambil sedikit lebih datar, dua dimensi. Dan itu baik-baik saja. Jadi ada, memang di tengah kertas. satu ini saya pikir Anda akan seperti, karena jika kita pergi ke sini, ini adalah apa yang dia menjelaskan. Jadi sekarang, biarkan saya mengusulkan bagaimana lagi kita mungkin menggambarkan situasi ini. 

Kembali pada hari, salah satu yang paling cara yang lebih umum untuk belajar pemrograman adalah menulis kode, menulis baris instruksi, yang dikendalikan sedikit penyu di layar. Logo dan varian lain dari ini adalah nama dari bahasa. Dan kura-kura hidup di dunia. 

Jadi misalkan persegi panjang ini ruang dunianya. Dan Anda akan mulai dengan assuming-- I tidak benar-benar tahu cara menggambar penyu, jadi mari kita melakukannya seperti ini. Dan kemudian dia punya shell dan kemudian mungkin beberapa kaki. Sehingga Anda mungkin harus sedikit ini karakter di layar. 

Dan obyek ini bahasa pemrograman adalah untuk memaksa penyu naik, bawah, kiri, kanan dan untuk meletakkan pena ke bawah atau mengambil pena up, sehingga ia benar-benar bisa menggambar di layar di dunia persegi panjang sangat datar ini. Jadi di mana saya pikir Anda mungkin akan, dan di mana Anda harus mempertimbangkan menyelam ke mental ketika menggambarkan instruksi lebih umum, Saya akan mengklaim, diletakkan Anda pena ke dalam middle-- yang dan kami akan menyingkirkan penyu, karena saya tidak bisa benar-benar terus menggambar dia sangat baik. 

Dan sekarang, bagaimana lagi bisa Saya katakan menggambar kubus? Nah, kita bisa mengatakan sesuatu seperti imbang garis timur laut diagonal, misalnya, atau pada sudut 45 derajat ke atas. Dan itu mungkin saja saya di sini. Dan aku cukup jauh dari kubus. Tapi sekarang, saya bisa mengatakan sesuatu seperti putar 90 derajat ke kiri dan menarik garis dari panjang yang sama laut. Dan aku bisa terus dengan arah yang sama. Dan itu tidak akan mudah. Dan terus terang, kita mungkin akan telah di sini selama lima menit. Tapi mungkin kita akan mendapatkan untuk sesuatu yang, pada akhir hari, akhirnya menjadi kubus, tapi kami menyelam dalam abstraksi yang melakukannya di seperti rendah tingkat bahwa Anda tidak bisa benar-benar melihat apa yang Anda lakukan sampai seluruh Hal ini sebenarnya ada pada halaman. Dan jadi ini adalah prinsip umum, lagi, dari programming-- ide ini abstraksi. Ini sangat mengagumkan kuat, karena sekali lagi, ia hanya berkata, menggambar kubus, yang semua kami cukup banyak akan grok sangat cepat. Kami hanya akan mengerti, OK, menggambar kubus. Kita mungkin tidak tahu orientasi, jadi kami bisa sedikit lebih tepat, tapi kita umumnya dapat membayangkan atau tahu apa kubus adalah. Dan yang berguna, karena jika setiap kali Anda duduk sebagai programmer di keyboard untuk menulis kode, jika Anda harus berpikir di seperti tingkat rendah, tidak satupun dari kita akan pernah mendapatkan apa-apa dilakukan. Dan tentu saja, tidak satupun dari kita akan menikmati proses penulisan kode. Ini akan seperti menulis di 0 dan 1, yang terus terang tidak semua yang lama yang lalu manusia yang menulis kode di 0 dan 1. Dan kami sangat cepat datang dengan ini lebih tinggi languages-- tingkat C ++ dan Java dan lain-lain. 

Jadi mari kita coba ini sekali lagi hanya untuk membalik meja, sehingga kita semua memiliki kesempatan untuk berpikir lewat cara yang sama. Bisakah kita mendapatkan satu relawan lainnya ini waktu untuk datang ke papan tulis dan menggambar, tidak membaca? Ya oke. Ben, ayolah up. Dan, Ben, dalam hal ini, setelah Anda menghadapi papan, tidak lihat kiri, tidak terlihat benar. Hanya melakukan apa yang Anda rekan-rekan di sini memberitahu Anda. Dan untuk orang lain di kamar, Anda sekarang adalah programmer. Dia komputer. Dan gambar saya telah memilih di sini di muka adalah salah satu ini di sini. Mereka hanya-- mereka berpikir dari lelucon lucu adalah semua. 

Jadi akan apakah seseorang ingin relawan instruksi pertama atau pernyataan yang seharusnya pen perintah Ben? Dan kami akan melakukan ini secara kolektif, mungkin satu instruksi dari setiap orang. Maafkan saya? 

AUDIENCE: Gambar lingkaran. DAVID Malan: Gambar lingkaran adalah hal pertama yang saya dengar. 

AUDIENCE: Up atas. 

DAVID Malan: Up atas. OK, kita dapat membiarkan Anda menghapus, membatalkan. Dan sekarang, orang lain. Dan, apakah Anda nyaman menawarkan instruksi berikutnya? 

AUDIENCE: Tentu, menggambar pusat dari bagian bawah lingkaran, dengan small-- sedikit ruang kecil itu, menarik garis lurus ke tiga perempat jalan turun papan sedikit miring ke kiri. 

DAVID Malan: Baik. 

AUDIENCE: sudut ringan. 

DAVID Malan: Undo, Control-Z. BAIK. Andrew, Anda ingin menawarkan up instruksi berikutnya? 

AUDIENCE: Tentu. Dari bawah garis, sedikit angle-- lanjut whoops-- mungkin sekitar sepertiga dari panjang [tidak terdengar], sedikit sudut ke bawah dan seperti sepertiga dari panjang [tidak terdengar]. Jadi ya, dari titik itu, menarik garis ketiga dari panjang sebelumnya garis lebih lanjut ke kiri. 

DAVID Malan: OK itu? garis lurus, itu OK? OK, Olivier, Anda ingin untuk menawarkan berikutnya? 

AUDIENCE: [tidak terdengar] dari bawah lingkaran, [tidak terdengar]. Menggambar pada sisi kanan dari [tidak terdengar] sentimeter. 

[TAWA] 

DAVID Malan: Saya pikir Anda akan harus mengkonversi yang inci di sini. 

AUDIENCE: Hentikan. 

[TAWA] 

DAVID Malan: OK. [? Ara,?] Anda ingin untuk menawarkan berikutnya? 

AUDIENCE: Menggambar [tidak terdengar] upper [tidak terdengar] yang sama. [Tidak terdengar] lingkaran, menggambar dengan [Tidak terdengar] dan menarik [tidak terdengar]. 

DAVID Malan: OK, tidak lebih membatalkan. Mari kita lakukan satu atau dua petunjuk lebih lanjut. Chris, Anda ingin menawarkan satu? 

AUDIENCE: Di bagian bawah lingkaran, [tidak terdengar] menarik garis tumpah sama ke bawah ke kiri [tidak terdengar]. 

DAVID Malan: OK. Andrew? Kami did-- Karim? 

AUDIENCE: Mulai dari garis yang tepat, akhir garis kiri, bawah, Anda akan pergi benar tentang panjang yang sama dengan garis yang Anda berada di, gambar untuk hak [tidak terdengar]. [Tidak terdengar] derajat, sehingga [tidak terdengar] derajat di sisi kanan. 

DAVID Malan: Baiklah. Mari kita berhenti sejenak. Jangan berbalik belum. Mari kita berhenti sejenak, dan mari kita mencoba salah satu upaya lainnya sebelum kita mengungkapkan kepada Ben apa yang dia telah menggambar. Anda dapat mengocok Ben untuk yang right-- atau sebenarnya, tidak, mari kita memberikan papan lain, bahkan lebih baik. Jadi akan seseorang sekarang seperti mengambil lebih dari pendekatan bahwa Victoria mengambil sebelumnya pada, di mana kita berbicara dalam abstraksi tingkat yang lebih tinggi dan hanya kalimat atau dua menjelaskan kepada Ben apa yang menarik tanpa masuk ke gulma, sehingga untuk berbicara, di ini tingkat yang lebih rendah? Victoria. [TAWA] AUDIENCE: Menggambar sosok dari orang berjalan. Dan kaki dan lengannya harus sisi kanan. 

DAVID Malan: OK, itu saja yang Anda dapatkan. Baiklah. Mengapa kita tidak mengungkapkan kepada Ben apa yang dia lakukan. Jadi tepuk tangan. Itu adalah yang paling sulit mungkin. 

Jadi meskipun kita berbicara dalam hal cukup konyol tentang hanya menggambar gambar, mudah-mudahan Anda benar-benar dapat menghargai derajat ekspresif yang mungkin diperlukan untuk memberitahu komputer apa yang harus dilakukan. Dan pada kenyataannya, fakta bahwa Ben mampu menarik ini begitu cepat adalah semacam bukti menggunakan bahasa, mungkin tingkat yang lebih tinggi versi bahasa Inggris, yang memungkinkan dia hanya menggunakan kata-kata, atau mendengar kata-kata dari Victoria, yang memungkinkan dia ini abstractions-- hanya menggambar sosok berjalan ke right-- semacam memiliki makna semantik untuk itu yang tidak hampir sama jelas ketika Anda hanya mengatakan, meletakkan pena Anda ke bawah, menarik ke kanan, menarik ke kiri. 

Dan ini juga, sangat umum dalam pemrograman. Ini akan dikatakan seperti bahasa tingkat yang sangat rendah, pemrograman di 0 dan 1 jika Anda mau. Dan ini akan menjadi tingkat yang lebih tinggi bahasa pemrograman di Jawa, atau semacam itu. Sebuah sedikit penyederhanaan, tapi itu jenis seperti emosional perasaan bahwa Anda rasakan ketika menggunakan satu jenis atau lain hal. Sedikit frustrasi di sini oleh kebutuhan untuk presisi seperti itu, tapi kesempatan menjadi sedikit longgar dengan interpretasi sini. Tapi tentu saja, bug dapat timbul sebagai hasilnya. 

Jika Anda ingin di home-- kami tidak akan melakukan ini di class-- tetapi jika Anda ingin membawa pulang satu ini, Saya pikir kami akan menyelam ke dalam ini. Jadi jika Anda ingin bermain ini game dengan lainnya yang signifikan Anda atau anak-anak atau sejenisnya, Anda mungkin menikmati itu juga. 

Jadi mari kita pergi ke depan dan melihat yang terakhir hal di sini untuk berpikir komputasi. Dan itu membawa kita ke John Oliver, bukan untuk klip Anda mungkin telah melihat tadi malam, tetapi untuk masalah yang agak baru-baru ini. Beberapa bulan yang lalu, Volkswagen mengambil sedikit antipeluru untuk alasan apa, jika Anda tahu? Apa yang mereka mendapatkan kesulitan untuk? 

Ya, jadi emissions-- mereka mencoba untuk mengalahkan emisi tes oleh dasarnya memiliki mereka mobil mencemari lingkungan kurang ketika mobil mereka sedang diuji dan mencemari lingkungan lebih ketika mobil tidak sedang diuji. Dan apa yang semakin menarik di dunia, karena Anda mungkin memiliki tereka dari diskusi like-- apa itu-- CarPlay, software Apple untuk mobil dan fakta bahwa banyak kita semakin memiliki layar sentuh di mobil kami, ada sejumlah menakutkan software di masyarakat mobil hari ini, yang terus terang membuka keseluruhan dapat cacing ketika datang ke keamanan dan risiko fisik. Tapi untuk saat ini, mari kita fokus hanya pada apa yang terlibat dalam menulis perangkat lunak yang mungkin telah gamed sistem. 

Untuk definisi masalah, untuk mereka yang tidak terbiasa, mari kita lihat John Oliver. Dan untuk mereka yang akrab dengan masalah, mari kita lihat itu di lensa menyenangkan melalui John Oliver juga. Jadi biarkan aku tekan tombol play ini, saya berpikir, pengenalan tiga menit. Sial. [VIDEO PEMUTARAN] -Cars-- DAVID Malan: Jelas, di YouTube, it's-- - --the Karakter terpandai di Fast dan Furious film. Minggu ini, produsen mobil Jerman Volkswagen menemukan dirinya di tengah-tengah skandal proporsi berpotensi kriminal. 

-Volkswagen Menguatkan untuk miliaran denda, tuduhan kriminal untuk eksekutif, seperti perusahaan meminta maaf untuk mencurangi 11 juta mobil untuk membantu mengalahkan tes emisi. 

model diesel -Certain dirancang dengan software canggih yang informasi yang digunakan, termasuk posisi dari roda kemudi dan kendaraan kecepatan, untuk menentukan mobil itu menjalani uji emisi. Dalam situasi itu, mesin akan mengurangi emisi beracun. Tapi mobil itu dicurangi untuk memotong yang ketika itu sedang didorong. Emisi meningkat 10 sampai 40 kali di atas tingkat EPA diterima. 

-Wow, 10 hingga 40 kali lebih besar dari EPA memungkinkan. Itu adalah hal terburuk Volkswagen yang pernah dilakukan, adalah sesuatu yang Anda mungkin mengatakan jika Anda tidak akan pernah mendengar tentang Perang Dunia II. Tapi mungkin tanda paling pasti tentang bagaimana banyak kesulitan Volkswagen di, adalah bahwa orang-orang di bagian paling atas telah mengundurkan diri. CEO mengundurkan diri pada Rabu setelah berebut untuk melakukan pengendalian kerusakan, mengatakan dia tanpa henti maaf, yang terdengar hebat sampai ternyata dia hanya 10% menyesal tetapi telah dicurangi mulutnya untuk artifisial mengembang sorriness nya. Dan sementara itu, Volkswagen AS Kepala memiliki permintaan maaf sendiri. 

-Biarkan Menjadi jelas tentang hal ini, perusahaan kami adalah jujur. Dan dalam kata-kata bahasa Jerman saya, kami telah benar-benar kacau. 

Yeah, tapi benar-benar kacau up tidak bekerja Jerman. Dan bahasa Jerman memiliki banyak frasa yang indah untuk menggambarkan situasi seperti ini, seperti [JERMAN], yang berarti kira-kira, kesedihan yang datang dari bisnis terkait kebohongan, atau [JERMAN], yang diterjemahkan sebagai mempermalukan ayah yang melibatkan awan bensin. Ini adalah bahasa yang indah. Itu hanya berlayar dari lidah. Dan omong-omong, sedangkan manusia maaf mungkin terdengar tulus, itu perlu dicatat ia berbicara di sebuah pesta peluncuran resmi untuk 2016 Volkswagen Passat, yang berarti bahwa tak lama setelah mengatakan maaf, dia mengatakan ini. 

-Terima Kasih banyak untuk datang. Menikmati malam. Up berikutnya adalah Lenny Kravitz. 

[MUSIC PLAYING] 

-OK, OK, berakhir Anda maaf dengan up berikutnya Lenny Kravitz tidak menjerit penyesalan mabuk. Jeritan, kami meminta Bon Jovi, dan ia mengatakan tidak. merek Volkswagen memiliki telah rusak parah. Dan terus terang, iklan baru mereka Kampanye tidak persis membantu. 

- [JERMAN], kami di Volkswagen ingin untuk meminta maaf untuk menipu Anda dengan kendaraan kami. 

[END PEMUTARAN] DAVID Malan: Jadi ini adalah cara bundaran of-- sorry-- ini adalah cara bundaran memperkenalkan masalah mendasar dalam perangkat lunak, yang adalah bahwa Anda perlu untuk mendeteksi kondisi tertentu. Dan pertanyaan di tangan disini adalah, bagaimana mobil berpotensi, seperti yang diterapkan dalam perangkat lunak oleh programmer ini, mendeteksi bahwa itu sebenarnya sedang diuji? Jadi untuk menjadi super jelas, apa yang mereka lakukan adalah, dalam lingkungan di mana programmer pikir mobil sedang diuji, mereka entah bagaimana membuat mobil memancarkan kurang emisi, lebih sedikit emisi, asap sehingga kurang beracun dan seperti. Tapi ketika itu biasanya berkendara di jalan, itu hanya akan memancarkan sebanyak polusi karena ingin. 

Jadi bagaimana kita bisa menulis pseudocode untuk algoritma ini? Bagaimana kita bisa menulis pseudocode untuk perangkat lunak yang berjalan di dalam mobil? Maksudku, singkatnya, mendidih ke sesuatu seperti ini. jika sedang diuji, memancarkan kurang. lain memancarkan lebih. Tapi itu sedikit terlalu tinggi, kan? 

Mari kita coba untuk menyelam di seperti apa ini abstraksi menjadi sarana diuji. Dengan kata lain, bahkan jika Anda tahu apa-apa tentang mobil, seperti apa pertanyaan mungkin Anda bertanya untuk menentukan apakah Anda sedang diuji, jika Anda mobil? Karakteristik apa yang mungkin hadir jika mobil sedang diuji? 

AUDIENCE: Pengujian peralatan. 

DAVID Malan: Pengujian peralatan. Jadi jika pengujian peralatan dekatnya, kemudian memancarkan kurang. Jadi saya bisa membayangkan menerapkan bahwa dengan beberapa jenis kamera atau mendeteksi apa yang ada di sekitar Anda. Dan biarkan aku mengusulkan, bahwa hanya merasa terlalu rumit untuk benar-benar memiliki tambahan hardware hanya untuk tujuan itu. 

AUDIENCE: Jika Anda berada di taman, jika hood Anda terbuka. 

DAVID Malan: Di taman atau kap terbuka, jadi itu bagus. 

AUDIENCE: Dan mobil berjalan. 

DAVID Malan: Jadi itu sedikit lebih concrete-- dan mobil berjalan. Jadi ini akan menjadi konjungsi dari beberapa kondisi yang berbeda, jika Anda mau. Jadi jika mobil di taman, dan bahkan meskipun ini adalah hal yang sangat mekanis biasanya, aku bisa bayangkan menulis perangkat lunak, terutama karena ada sering cahaya sana hari ini, Aku bisa membayangkan ada yang perangkat lunak yang dapat query shifter atau apa yang tidak, kau di taman, yang Anda di drive, apakah Anda secara terbalik. Dan saya bisa mendapatkan kembali menjawab itu baik ya atau tidak untuk orang-orang macam pertanyaan. 

Dan jadi saya juga bisa mungkin menjawab pertanyaan seperti, adalah kap terbuka. Mungkin, ada beberapa jenis sensor yang baik memberi saya kembali 1 atau 0, benar atau salah, kap terbuka. Dan kemudian mobil berjalan, aku bisa mendeteksi yang entah bagaimana melalui mekanisme apa? Seperti, mobil berjalan, saya bisa mendeteksi bahwa itu pada, bisa saya mendeteksi entah bagaimana bahwa mobil bergerak? 

AUDIENCE: RPM. 

DAVID Malan: Ya, jadi ada selalu jarum bahwa memberitahu Anda berapa banyak rotasi per menit roda mengalami. Dan jadi saya bisa melihat itu. Dan jika tidak 0, yang mungkin berarti mobil bergerak. Tapi kami harus menjadi sedikit berhati-hati di sana, because-- mari kita menyederhanakan ini-- jika kita hanya mengatakan, jika mobil berjalan, kita tidak ingin hanya memancarkan kurang, kita inginkan jika mobil berjalan dan itu sedang diuji. 

Jadi ada beberapa lainnya bahan yang orang telah memperkirakan perangkat lunak lakukan, karena tidak ada kode sumber yang sebenarnya, Anda dapat hanya semacam menyimpulkan dari efek fisik dari mobil untuk apa mungkin terjadi di bawah kap dalam perangkat lunak. Jadi jika mobil berjalan dan mungkin, katakanlah, roda belakang tidak bergerak, mungkin ini menjadi indikasi beberapa jenis tes? Apa yang saya mengisyaratkan di sini? Ya, mungkin, itu di salah satu dari mereka rol hal, mana seperti roda yang beralih di depan atau di belakang, tergantung pada apakah itu roda depan atau roda belakang, sehingga setengah dari roda yang bergerak, tapi dua lainnya tidak, yang adalah situasi yang aneh di dunia nyata. Jika Anda sedang mengemudi di jalan, yang seharusnya tidak terjadi. Tetapi jika Anda berada di sebuah gudang pada beberapa jenis sistem roller, bahwa memang mungkin terjadi. 

Saya pikir orang-orang juga mengusulkan bahwa mungkin, jika mobil berjalan dan kemudi setir tidak bergerak, yang terlalu mungkin sinyal, karena itulah wajar untuk seperti langsung di jalan. Tetapi bahkan kemudian, manusia mungkin bergerak sedikit atau pasti selama beberapa detik. Atau kursus dari menit, kemungkinan besar yang tidak akan terpaku di posisi yang sama persis. 

Jadi dengan kata lain, kita dapat mengambil pengurangan, kamu sedang diuji, dan memecah fungsi yang ke dalam bahan komponen. Dan itu benar-benar apa Volkswagen insinyur entah lakukan. Mereka menulis perangkat lunak secara sadar untuk mendeteksi jika mobil sedang diuji, Oleh karena itu memancarkan kurang, lain memancarkan dengan cara yang biasa. 

Dan masalah di sini, juga, adalah bahwa perangkat lunak tidak sesuatu yang Anda benar-benar bisa melihat kecuali Anda memiliki kode sumber yang disebut. Jadi ada dua jenis code-- setidaknya dua jenis yang berbeda kode di dunia. Ada sesuatu yang disebut sumber kode, yang tidak berbeda dengan apa kami telah menulis, kode sumber. 

Ini adalah kode sumber yang ditulis dalam bahasa yang disebut pseudo, yang hanya sesuatu bahasa Inggris-seperti. Tidak ada definisi formal dari itu. Tapi C, dan Java, C ++, mereka semua bahasa formal yang, ketika Anda menulis di dalamnya, apa yang Anda miliki adalah file teks yang berisi kode sumber. 

Tapi ada juga sesuatu dalam dunia yang disebut kode mesin. Dan kode mesin, sayangnya, hanya 0 dan 1. Jadi kode mesin yang mesin memahami, tentu saja. Source code adalah apa yang manusia mengerti. 

Dan umumnya, tapi tidak selalu, ada program bahwa programmer menggunakan yang mengambil sumber kode dan mengubahnya menjadi kode mesin. Dan program yang umumnya disebut kompilator. Jadi masukan Anda adalah kode sumber, output adalah kode mesin, dan compiler adalah sepotong perangkat lunak yang melakukan proses tersebut. Jadi ini benar-benar peta baik untuk masukan kami, algoritma, output. 

Tapi ini adalah inkarnasi sangat spesifik itu, yang mengatakan bahwa, bahkan jika Anda memiliki salah satu dari Volkswagen mobil yang bersalah dalam hal ini, tidak seperti Anda hanya dapat membuka hood atau membuka petunjuk pengguna atau melihat kode sumber, karena pada saat mencapai mobil Anda di jalan Anda, itu sudah diubah menjadi 0 dan 1. Dan itu sangat sulit, bukan tidak mungkin, tetapi sangat sulit untuk mengumpulkan apa-apa dari hanya melihat mendasari 0 dan 1. Jadi Anda bisa mencari tahu, akhirnya, jika Anda memahami bagaimana mesin operates-- Intel inside-- jika Anda memahami arsitektur Intel, tapi itu sangat memakan waktu. Dan bahkan di sana, Anda mungkin tidak dapat melihat segala sesuatu bahwa kode sebenarnya bisa melakukan. 

Pertanyaan tentang hal ini atau ini jenis proses yang lebih umum? Dan sebenarnya, kita bisa mengikat diskusi ini diskusi kemarin Apple. Ini juga sebabnya mengapa FBI tidak bisa hanya pergi dan melihat di telepon tersangka dan menemukan baris kode, untuk Misalnya, yang memungkinkan kode akses atau mengaktifkan bahwa 80-milidetik delay. Karena pada saat itu pada sesama iPhone, itu sudah dikonversi ke 0 dan 1. 

Nah, mari kita berhenti sebentar di sini untuk kami melihat berpikir komputasi. Mengapa kita tidak mengambil istirahat 15 menit. Dan ketika kita kembali, kita akan lihatlah pemrograman sendiri dan mulai memetakan beberapa konsep tingkat tinggi ini ke sebenarnya, jika main-main, bahasa pemrograman. 